{
    "hands_on_practices": [
        {
            "introduction": "稳定性是任何数值格式最基本的要求。本练习将通过一个直观的例子，帮助我们深入理解一维热方程显式格式著名的稳定性条件 $\\mu \\le 1/2$。我们将模拟一个尖锐脉冲的扩散过程，并亲眼见证当稳定性条件被破坏时，计算结果如何产生非物理的负值，从而为离散最大值原理这一理论概念提供一个具体的例证。",
            "id": "3389096",
            "problem": "考虑定义在有限区间上、带有齐次狄利克雷边界条件的一维热方程（一种抛物线型偏微分方程（PDE））。设扩散系数为正常数，记作 $a0$。在闭区间 $[0,1]$ 上使用包含 $N$ 个节点的均匀空间网格，其间距为 $h$；并采用时间步长为 $k$ 的显式前向欧拉方法进行时间离散化。用 $u_i^n$ 表示在空间节点 $x_i$ 和时间层 $t^n$ 上精确解的数值近似。定义无量纲比率 $\\mu := a\\,k/h^2$。初始条件为单个网格尖峰：除一个内部节点值为1外，所有其他节点的值均为0。边界值在所有时刻始终为0。\n\n您的任务如下：\n\n- 从热方程的定义、时间上的前向欧拉法以及空间二阶导数的标准中心有限差分近似出发，推导内部节点的显式格式以及相关的离散更新系数（用 $\\mu$ 表示）。\n- 仅使用离散格式和基本原理，论证单次时间步长是否会根据 $\\mu$ 的值产生初始数据中不存在的新极值。“新极值”是指新最小值低于初始最小值，或新最大值高于初始最大值。\n- 对尖峰初始条件和齐次狄利克雷边界，数值实现所推导的单步显式更新。对于下面测试套件中的每组参数，精确执行一个时间步，并报告是否产生了新极值（每种情况输出一个布尔值）。\n\n代码中需使用的假设和设置：\n\n- 空间域：$[0,1]$，包含 $N$ 个均匀分布的节点，间距 $h=1/(N-1)$。\n- 齐次狄利克雷边界条件：对于所有 $n$，有 $u_0^n=0$ 和 $u_{N-1}^n=0$。\n- 初始数据（单个尖峰）：在选定的内部索引 $i^\\star$ 处，$u_{i^\\star}^0=1$，而对于所有 $i\\neq i^\\star$，$u_i^0=0$。\n- 在代码中，使用 $a=1$ 来实例化 $\\mu = k/h^2$；然而，您的实现应直接使用 $\\mu$ 进行单步更新。\n\n一步后新极值的检测标准：\n\n- 设 $\\min^0$ 和 $\\max^0$ 分别表示初始时刻所有网格节点上的最小值和最大值。\n- 设 $\\min^1$ 和 $\\max^1$ 分别表示一个显式时间步后所有网格节点上的最小值和最大值。\n- 输出布尔值 $\\big(\\min^1  \\min^0\\big)\\ \\lor\\ \\big(\\max^1  \\max^0\\big)$。\n\n测试套件：\n\n- 所有情况均使用 $N=11$ 和 $i^\\star=5$。使用以下四个 $\\mu$ 值：\n    - 情况1：$\\mu=0$。\n    - 情况2：$\\mu=0.49$。\n    - 情况3：$\\mu=0.5$。\n    - 情况4：$\\mu=0.51$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与测试套件相同（例如，$[\\text{False},\\text{True},\\text{False},\\text{True}]$）。由于所有量在构造上都是无量纲的，因此输出中不需要物理单位。唯一允许的输出类型是如上指定的布尔值。",
            "solution": "该问题是有效的，因为它具有科学依据、提法明确且客观。它采用标准、可验证的方法，探讨了偏微分方程数值解中的基本概念。\n\n该问题需要三部分作答：数值格式的推导、其性质的理论分析，以及用于验证该分析的数值实现。\n\n**1. 显式格式的推导**\n\n一维热方程是一个抛物线型偏微分方程（PDE），其形式为：\n$$\n\\frac{\\partial u}{\\partial t} = a \\frac{\\partial^2 u}{\\partial x^2}\n$$\n其中 $u(x, t)$ 是位置 $x$ 和时间 $t$ 处的温度，$a  0$ 是热扩散系数。\n\n我们在一个均匀网格上对此方程进行离散化，空间步长为 $h$，时间步长为 $k$。在网格点 $(x_i, t^n)$ 处解的近似值记为 $u_i^n$。\n\n时间导数 $\\frac{\\partial u}{\\partial t}$ 使用一阶前向差分（前向欧拉法）进行近似：\n$$\n\\frac{\\partial u}{\\partial t} \\bigg|_{(x_i, t^n)} \\approx \\frac{u_i^{n+1} - u_i^n}{k}\n$$\n\n空间二阶导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 使用二阶中心差分进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2} \\bigg|_{(x_i, t^n)} \\approx \\frac{u_{i-1}^n - 2u_i^n + u_{i+1}^n}{h^2}\n$$\n\n将这些离散近似代入偏微分方程，得到有限差分方程：\n$$\n\\frac{u_i^{n+1} - u_i^n}{k} = a \\left( \\frac{u_{i-1}^n - 2u_i^n + u_{i+1}^n}{h^2} \\right)\n$$\n\n为求得 $u_i^{n+1}$ 的更新规则，我们整理这些项：\n$$\nu_i^{n+1} = u_i^n + \\frac{ak}{h^2} \\left( u_{i-1}^n - 2u_i^n + u_{i+1}^n \\right)\n$$\n\n问题定义了无量纲比率 $\\mu := a k / h^2$。将 $\\mu$ 代入方程可得：\n$$\nu_i^{n+1} = u_i^n + \\mu (u_{i-1}^n - 2u_i^n + u_{i+1}^n)\n$$\n\n最后，我们将时间层 $n$ 的项组合起来，得到任意内部节点 $i$ 的显式更新格式：\n$$\nu_i^{n+1} = \\mu u_{i-1}^n + (1 - 2\\mu) u_i^n + \\mu u_{i+1}^n\n$$\n\n在时间层 $n$ 的计算模板中，离散更新系数为：\n-   $u_{i-1}^n$ 的系数：$\\mu$\n-   $u_i^n$ 的系数：$1 - 2\\mu$\n-   $u_{i+1}^n$ 的系数：$\\mu$\n\n**2. 新极值产生的分析**\n\n如果在一次时间步后，新最小值小于初始最小值（$\\min^1  \\min^0$），或新最大值大于初始最大值（$\\max^1  \\max^0$），则称产生了“新极值”。\n\n更新规则表明 $u_i^{n+1}$ 是其在上一时间步邻近值的线性组合。为使该格式不产生新极值，它必须满足离散极值原理。如果该更新是一个凸组合，即所有系数都为非负，则此原理得以保证。系数之和为 $\\mu + (1 - 2\\mu) + \\mu = 1$。\n\n系数为非负的条件是：\n1.  $\\mu \\ge 0$：由于 $a  0$, $k \\ge 0$ 且 $h^2  0$，此条件始终满足。$\\mu=0$ 的情况对应于 $k=0$，此时解不发生演化。\n2.  $1 - 2\\mu \\ge 0$：这意味着 $2\\mu \\le 1$，即 $\\mu \\le 0.5$。\n\n**情况A：$0 \\le \\mu \\le 0.5$**\n在这种情况下，更新规则中的所有系数均为非负。值 $u_i^{n+1}$ 是 $u_{i-1}^n$、$u_i^n$ 和 $u_{i+1}^n$ 的凸组合。因此，其值被这三个值的最小值和最大值所界定：\n$$\n\\min(u_{i-1}^n, u_i^n, u_{i+1}^n) \\le u_i^{n+1} \\le \\max(u_{i-1}^n, u_i^n, u_{i+1}^n)\n$$\n这意味着对于任何内部节点 $i$，都有 $\\min^n \\le u_i^{n+1} \\le \\max^n$。齐次狄利克雷边界条件确保 $u_0^{n+1} = u_{N-1}^{n+1} = 0$。考虑到初始条件为 $\\min^0=0$ 和 $\\max^0=1$，边界值保持在此范围内。\n因此，对于所有节点 $i=0, \\dots, N-1$，我们有 $\\min^0 \\le u_i^1 \\le \\max^0$。这意味着 $\\min^1 \\ge \\min^0$ 且 $\\max^1 \\le \\max^0$。没有新极值产生。测试标准 $(\\min^1  \\min^0) \\lor (\\max^1  \\max^0)$ 的计算结果将为 **False**。\n\n**情况B：$\\mu  0.5$**\n在这种情况下，系数 $1 - 2\\mu$ 为负。该更新不再是凸组合，离散极值原理被违反。我们来分析其对给定尖峰初始条件的影响：$u_{i^\\star}^0=1$ 且对于所有 $i \\neq i^\\star$，$u_i^0=0$。初始极值为 $\\min^0=0$ 和 $\\max^0=1$。\n\n我们计算尖峰附近节点在时间 $n=1$ 时的值：\n-   对于 $i = i^\\star-1$：$u_{i^\\star-1}^1 = \\mu u_{i^\\star-2}^0 + (1-2\\mu)u_{i^\\star-1}^0 + \\mu u_{i^\\star}^0 = \\mu(0) + (1-2\\mu)(0) + \\mu(1) = \\mu$。\n-   对于 $i = i^\\star+1$：$u_{i^\\star+1}^1 = \\mu u_{i^\\star}^0 + (1-2\\mu)u_{i^\\star+1}^0 + \\mu u_{i^\\star+2}^0 = \\mu(1) + (1-2\\mu)(0) + \\mu(0) = \\mu$。\n-   对于 $i = i^\\star$：$u_{i^\\star}^1 = \\mu u_{i^\\star-1}^0 + (1-2\\mu)u_{i^\\star}^0 + \\mu u_{i^\\star+1}^0 = \\mu(0) + (1-2\\mu)(1) + \\mu(0) = 1 - 2\\mu$。\n所有其他节点 $u_i^1$ 的值将为 $0$。\n\n由于 $\\mu  0.5$，我们有 $2\\mu  1$，这意味着 $u_{i^\\star}^1 = 1 - 2\\mu  0$。\n在时间 $n=1$ 时的最小值为 $\\min^1 = \\min(0, \\mu, 1-2\\mu) = 1-2\\mu$。\n我们得到 $\\min^1  0$，而 $\\min^0=0$。因此，$\\min^1  \\min^0$。一个新最小值被产生，这是一个物理上不真实的下冲现象。测试标准 $(\\min^1  \\min^0) \\lor (\\max^1  \\max^0)$ 的计算结果为 **True**。\n\n条件 $\\mu \\le 0.5$ 是该显式格式著名的CFL (Courant-Friedrichs-Lewy) 稳定性条件。\n\n**3. 数值测试用例预测**\n\n-   情况1 ($\\mu=0$)：$0 \\le 0.5$。预期 **False**。\n-   情况2 ($\\mu=0.49$)：$0.49 \\le 0.5$。预期 **False**。\n-   情况3 ($\\mu=0.5$)：$0.5 \\le 0.5$。这是稳定性边界。预期 **False**。\n-   情况4 ($\\mu=0.51$)：$0.51  0.5$。格式不稳定。预期 **True**。\n\n实现将基于此经过验证的分析进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of detecting new extrema in a one-step explicit finite\n    difference scheme for the 1D heat equation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a value for the dimensionless ratio mu.\n    test_cases = [0.0, 0.49, 0.5, 0.51]\n\n    # Shared parameters for all test cases\n    N = 11      # Number of spatial grid nodes\n    i_star = 5  # Index of the initial spike\n\n    results = []\n    for mu in test_cases:\n        # Perform the one-step update for a single case.\n\n        # 1. Set up initial condition (u0)\n        # u^0 has a single spike at i_star and is zero everywhere else.\n        u0 = np.zeros(N, dtype=float)\n        u0[i_star] = 1.0\n\n        # Initial minimum and maximum are fixed by the problem description.\n        min0 = 0.0\n        max0 = 1.0\n\n        # 2. Compute the solution after one time step (u1)\n        # Initialize u1 to all zeros. The Dirichlet boundary conditions\n        # u1[0] = 0 and u1[N-1] = 0 are thus automatically satisfied.\n        u1 = np.zeros(N, dtype=float)\n\n        # Apply the explicit update rule for interior nodes (i=1 to N-2).\n        # u_i^{n+1} = mu*u_{i-1}^n + (1 - 2*mu)*u_i^n + mu*u_{i+1}^n\n        # A vectorized update is efficient and concise.\n        u1[1:-1] = mu * u0[:-2] + (1.0 - 2.0 * mu) * u0[1:-1] + mu * u0[2:]\n\n        # 3. Detect new extrema\n        # Find the minimum and maximum of the solution at the new time step.\n        min1 = np.min(u1)\n        max1 = np.max(u1)\n\n        # Apply the detection criterion given in the problem statement.\n        # A new extremum is created if the new min is below the old min,\n        # OR the new max is above the old max.\n        new_extremum_created = (min1  min0) or (max1 > max0)\n        results.append(new_extremum_created)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a Python list of booleans.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在保证了数值格式的稳定性之后，我们自然会关心它的精度。本练习聚焦于量化不同时间推进格式（如前向欧拉法、二阶和四阶龙格-库塔法）的计算精度。通过设计一个巧妙的实验来分离和研究时间方向的误差，我们将学习如何通过数值计算来确定收敛阶，并验证它是否与理论预测相符，这是代码验证和数值分析中的一项核心技能。",
            "id": "3389099",
            "problem": "考虑一维热方程，这是一个典范的抛物型偏微分方程，形式为 $u_t = \\alpha u_{xx}$。该方程定义在空间区间 $(0,1)$ 上，具有齐次狄利克雷边界条件 $u(0,t) = 0$ 和 $u(1,t) = 0$，以及光滑初始条件 $u(x,0) = \\sin(\\pi x)$。通过分离变量法以及在齐次狄利克雷边界条件下空间拉普拉斯算子的特征函数结构，对于所有 $t \\ge 0$，解都保持为单一模态，并可以写成 $u(x,t) = a(t)\\sin(\\pi x)$ 的形式。其中，模态振幅 $a(t)$ 满足线性常微分方程 (ordinary differential equation, ODE) $a'(t) = -\\lambda a(t)$，其中 $\\lambda = \\alpha \\pi^2$ 且 $a(0) = 1$。该 ODE 的精确解为 $a(t) = \\exp(-\\lambda t)$。\n\n这种简化消除了单一受激特征模态的空间离散误差，这等效于将空间分辨率取得足够精细，以至于空间误差可以忽略不计。在此背景下，你需要设计并实现一个显式时间加密研究，以分离出时间收敛性。你的程序必须实现三种应用于标量 ODE $a'(t) = -\\lambda a(t)$ 的显式时间推进格式：\n- 一阶显式前向欧拉法。\n- 二阶显式中点龙格－库塔法。\n- 经典四阶显式龙格－库塔法。\n\n对于每种方法，在一个指定的最终时间 $T$ 和一系列时间步长 $\\Delta t$ 上进行加密研究。对于序列中的每个 $\\Delta t$，使用恰好 $N = T / \\Delta t$ 个步长将数值解从 $t=0$ 推进到 $t=T$（选择 $T$ 和 $\\Delta t$ 使 $N$ 为整数），然后计算绝对误差 $E(\\Delta t) = \\lvert a_{\\mathrm{num}}(T) - a_{\\mathrm{exact}}(T) \\rvert$，其中 $a_{\\mathrm{exact}}(T) = \\exp(-\\lambda T)$。通过标度关系 $E(\\Delta t) \\approx C (\\Delta t)^p$ 估算连续时间步长 $\\Delta t_1$ 和 $\\Delta t_2$ 之间的观测阶数 $p$，计算公式为 $p = \\log\\left(E(\\Delta t_1) / E(\\Delta t_2)\\right) \\big/ \\log\\left(\\Delta t_1 / \\Delta t_2\\right)$。\n\n需要使用的基础知识：\n- 热方程 $u_t = \\alpha u_{xx}$ 及其在齐次狄利克雷边界条件下的模态分解。\n- 第一个特征模态所产生的标量 ODE $a'(t) = -\\lambda a(t)$（其中 $\\lambda = \\alpha \\pi^2$）及其精确解 $a(t) = \\exp(-\\lambda t)$。\n- 应用于 ODE 的显式前向欧拉法和显式龙格－库塔法的定义。\n\n你必须实现以下参数值测试套件，以评估加密研究的不同方面。在所有情况下，均使用 $\\alpha = 1$，因此 $\\lambda = \\pi^2$：\n1. 前向欧拉法的理想情况：\n   - 方法：前向欧拉法\n   - 最终时间：$T = 0.3$\n   - 时间步长：$\\Delta t \\in \\{0.05, 0.025, 0.0125\\}$\n\n2. 显式中点龙格－库塔法（二阶）的理想情况：\n   - 方法：显式中点龙格－库塔法\n   - 最终时间：$T = 1.0$\n   - 时间步长：$\\Delta t \\in \\{0.2, 0.1, 0.05\\}$\n\n3. 经典四阶龙格－库塔法的理想情况：\n   - 方法：经典四阶龙格－库塔法\n   - 最终时间：$T = 0.3$\n   - 时间步长：$\\Delta t \\in \\{0.1, 0.05, 0.025\\}$\n\n4. 前向欧拉法在负实轴上接近稳定区域边缘的边界稳定性情况：\n   - 方法：前向欧拉法\n   - 最终时间：$T = 0.95$\n   - 时间步长：$\\Delta t \\in \\{0.19, 0.095, 0.0475\\}$\n\n对于每个测试用例，计算序列中第一对和第二对连续时间步长的观测阶数（即，从第一个值到第二个值，以及从第二个值到第三个值）。程序必须以浮点数值的形式返回这些观测阶数。\n\n最终输出格式要求：\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，观测阶数按测试用例排序，并在每个测试用例内按对排序。具体来说，输出格式应为\n$[\\text{p}_{1,1},\\text{p}_{1,2},\\text{p}_{2,1},\\text{p}_{2,2},\\text{p}_{3,1},\\text{p}_{3,2},\\text{p}_{4,1},\\text{p}_{4,2}]$\n其中 $\\text{p}_{j,k}$ 表示测试用例 $j$ 和第 $k$ 对的观测阶数。不涉及物理单位，并且所有角度（如果有的话）在此均不适用。列表中的值必须是纯十进制数。",
            "solution": "该问题要求对应用于一个模型常微分方程 (ODE) 的几种显式时间积分格式，实施并分析一次时间加密研究。这个 ODE 源于具有齐次狄利克雷边界条件的一维热方程 $u_t = \\alpha u_{xx}$ 的模态分解。这一特定设置使用了仅激发第一特征模态的初始条件 $u(x,0) = \\sin(\\pi x)$，从而将该偏微分方程 (PDE) 简化为关于该模态随时间变化的振幅 $a(t)$ 的一个 ODE。这个过程有效地将时间离散误差与空间离散误差分离。\n\n控制第一模态振幅的 ODE 如下所示：\n$$\na'(t) = -\\lambda a(t)\n$$\n初始条件为 $a(0) = 1$。常数 $\\lambda$ 是对应于第一特征模态 $\\sin(\\pi x)$ 的特征值，即 $\\lambda = \\alpha \\pi^2$。对于所有测试用例，我们使用 $\\alpha=1$，因此 $\\lambda = \\pi^2$。\n\n通过直接积分可求得该初值问题的精确解：\n$$\na_{\\mathrm{exact}}(t) = \\exp(-\\lambda t)\n$$\n\n任务的核心是使用固定的时间步长 $\\Delta t$ 对此 ODE 从 $t=0$ 到最终时间 $T$ 进行数值求解，并研究当 $\\Delta t$ 被加密（减小）时，最终时间的误差如何变化。每次模拟的步数为 $N = T / \\Delta t$。\n\n我们将实现三种显式数值方法：\n\n1.  **一阶显式前向欧拉法：**\n    这是最简单的显式方法。解在第 $n+1$ 步由第 $n$ 步通过以下公式推进：\n    $$\n    a_{n+1} = a_n + \\Delta t \\cdot f(t_n, a_n)\n    $$\n    其中 $f(t_n, a_n) = -\\lambda a_n$。将此代入公式，得到迭代映射：\n    $$\n    a_{n+1} = a_n + \\Delta t (-\\lambda a_n) = (1 - \\lambda \\Delta t) a_n\n    $$\n\n2.  **二阶显式中点龙格－库塔法 (RK2)：**\n    该方法通过使用预测－校正方法达到二阶精度。它首先使用欧拉法预测的值来评估时间中点的斜率，然后使用这个中点斜率来执行一个完整步长的推进。\n    其分步计算如下：\n    $$\n    k_1 = f(t_n, a_n) = -\\lambda a_n\n    $$\n    $$\n    k_2 = f\\left(t_n + \\frac{\\Delta t}{2}, a_n + \\frac{\\Delta t}{2} k_1\\right) = -\\lambda \\left(a_n + \\frac{\\Delta t}{2} k_1\\right)\n    $$\n    更新规则是：\n    $$\n    a_{n+1} = a_n + \\Delta t \\cdot k_2\n    $$\n\n3.  **经典四阶显式龙格－库塔法 (RK4)：**\n    这是一种广泛使用的方法，通过在区间 $\\Delta t$ 内对四个斜率估计值进行加权平均来提供四阶精度。\n    其四个分步计算如下：\n    $$\n    k_1 = f(t_n, a_n) = -\\lambda a_n\n    $$\n    $$\n    k_2 = f\\left(t_n + \\frac{\\Delta t}{2}, a_n + \\frac{\\Delta t}{2} k_1\\right) = -\\lambda \\left(a_n + \\frac{\\Delta t}{2} k_1\\right)\n    $$\n    $$\n    k_3 = f\\left(t_n + \\frac{\\Delta t}{2}, a_n + \\frac{\\Delta t}{2} k_2\\right) = -\\lambda \\left(a_n + \\frac{\\Delta t}{2} k_2\\right)\n    $$\n    $$\n    k_4 = f(t_n + \\Delta t, a_n + \\Delta t k_3) = -\\lambda (a_n + \\Delta t k_3)\n    $$\n    最终的更新是这些斜率的加权平均：\n    $$\n    a_{n+1} = a_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n    $$\n\n对每个测试用例，都进行一次加密研究。这包括以下步骤：\n1.  对于给定的方法、最终时间 $T$ 和一个递减的时间步长序列 $(\\Delta t_1, \\Delta t_2, \\ldots)$，从 $a(0)=1$ 开始对 ODE 进行数值积分，以获得每个 $\\Delta t_i$ 对应的数值解 $a_{\\mathrm{num}}(T)$。\n2.  计算在最终时间的精确解 $a_{\\mathrm{exact}}(T) = \\exp(-\\lambda T)$。\n3.  计算每次模拟的绝对误差：$E(\\Delta t_i) = |a_{\\mathrm{num}}(T) - a_{\\mathrm{exact}}(T)|$。\n4.  一个 $p$ 阶方法的理论收敛性意味着对于足够小的 $\\Delta t$，误差表现为 $E(\\Delta t) \\approx C (\\Delta t)^p$。通过两次分别使用时间步长 $\\Delta t_1$ 和 $\\Delta t_2$ 的模拟，可以利用以下公式估算观测到的收敛阶数 $p$：\n    $$\n    p = \\frac{\\log\\left(E(\\Delta t_1) / E(\\Delta t_2)\\right)}{\\log\\left(\\Delta t_1 / \\Delta t_2\\right)}\n    $$\n\n程序将对四个指定的测试用例中的每一个执行此过程，为每个用例计算两个观测阶数（来自第一对和第二对连续的时间步长），并以规定的格式输出这八个值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the refinement study across all specified test cases.\n    \"\"\"\n\n    def solve_ode(method: str, T: float, dt: float, lambda_val: float) - float:\n        \"\"\"\n        Solves the ODE a'(t) = -lambda * a(t) from t=0 to T with time step dt.\n\n        Args:\n            method: The name of the numerical scheme ('forward_euler', 'rk2', 'rk4').\n            T: The final integration time.\n            dt: The time step size.\n            lambda_val: The coefficient lambda in the ODE.\n\n        Returns:\n            The numerical solution a_num(T).\n        \"\"\"\n        # Ensure the number of steps is an integer, as per problem statement.\n        # Use round to handle potential floating point inaccuracies.\n        N = int(round(T / dt))\n        a_n = 1.0  # Initial condition a(0) = 1\n\n        if method == \"forward_euler\":\n            for _ in range(N):\n                a_n = a_n + dt * (-lambda_val * a_n)\n        elif method == \"rk2\":\n            for _ in range(N):\n                k1 = -lambda_val * a_n\n                k2 = -lambda_val * (a_n + dt / 2.0 * k1)\n                a_n = a_n + dt * k2\n        elif method == \"rk4\":\n            for _ in range(N):\n                k1 = -lambda_val * a_n\n                k2 = -lambda_val * (a_n + dt / 2.0 * k1)\n                k3 = -lambda_val * (a_n + dt / 2.0 * k2)\n                k4 = -lambda_val * (a_n + dt * k3)\n                a_n = a_n + dt / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n        \n        return a_n\n\n    # Map problem statement method names to internal function identifiers.\n    method_map = {\n        \"forward Euler\": \"forward_euler\",\n        \"explicit midpoint Runge–Kutta\": \"rk2\",\n        \"classical fourth-order Runge–Kutta\": \"rk4\"\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"method\": \"forward Euler\", \"T\": 0.3, \"dts\": [0.05, 0.025, 0.0125]},\n        {\"method\": \"explicit midpoint Runge–Kutta\", \"T\": 1.0, \"dts\": [0.2, 0.1, 0.05]},\n        {\"method\": \"classical fourth-order Runge–Kutta\", \"T\": 0.3, \"dts\": [0.1, 0.05, 0.025]},\n        {\"method\": \"forward Euler\", \"T\": 0.95, \"dts\": [0.19, 0.095, 0.0475]}\n    ]\n\n    # Global parameter alpha and derived lambda\n    alpha = 1.0\n    lambda_val = alpha * np.pi**2\n\n    all_orders = []\n\n    for case in test_cases:\n        T = case[\"T\"]\n        dts = case[\"dts\"]\n        method_str = case[\"method\"]\n        method_id = method_map[method_str]\n\n        # Calculate exact solution at final time T\n        a_exact_T = np.exp(-lambda_val * T)\n        \n        # Calculate numerical solution and error for each time step\n        errors = []\n        for dt in dts:\n            a_num_T = solve_ode(method_id, T, dt, lambda_val)\n            error = np.abs(a_num_T - a_exact_T)\n            errors.append(error)\n\n        # Calculate observed convergence orders\n        # p = log(E1/E2) / log(dt1/dt2)\n        \n        # Order for the first pair of time steps (dt_1, dt_2)\n        dt_ratio_1 = dts[0] / dts[1]\n        order1 = np.log(errors[0] / errors[1]) / np.log(dt_ratio_1)\n        all_orders.append(order1)\n        \n        # Order for the second pair of time steps (dt_2, dt_3)\n        dt_ratio_2 = dts[1] / dts[2]\n        order2 = np.log(errors[1] / errors[2]) / np.log(dt_ratio_2)\n        all_orders.append(order2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{order:.7f}' for order in all_orders)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的物理过程往往是多维的，并且材料属性可能随方向变化（即各向异性）。本练习将把稳定性的概念从一维推广到二维各向异性热方程。我们将基于离散最大值原理，推导并计算出在给定网格和各向异性扩散系数下所允许的最大时间步长，从而揭示网格尺寸和不同方向的扩散率如何共同作用，对显式格式施加比简单情况更严格的稳定性约束。",
            "id": "3389038",
            "problem": "考虑定义在矩形域上的二维抛物型偏微分方程 $u_t = \\nabla \\cdot (K \\nabla u)$，其中 $K$ 是一个常数、对称、正定的扩散张量。为构造一种没有混合导数项的特定各向异性和网格方向，同时通过离散极值原理（DMP）对显式时间步长施加严格约束，设 $K$ 与坐标轴对齐，$K = \\mathrm{diag}(\\kappa_x,\\kappa_y)$，其各向异性分量为 $\\kappa_x = 7.5$ 和 $\\kappa_y = 0.3$。设网格为沿 $x$ 和 $y$ 轴方向的均匀矩形网格，网格间距为 $h_x = 0.02$ 和 $h_y = 0.015$。在空间上使用五点模板上的二阶中心差分进行离散，在时间上使用前向欧拉法进行离散。DMP要求每个网格点上的显式更新是当前值和相邻值的凸组合，这一条件通过非负的更新权重来强制执行。计算最大允许时间步长 $\\Delta t_{\\max}$，使得对于此离散化和数据，所有更新权重均为非负，从而证明任何 $\\Delta t  \\Delta t_{\\max}$ 都会因产生负权重而破坏DMP。将 $\\Delta t_{\\max}$ 作为一个无量纲数报告，并四舍五入到四位有效数字。",
            "solution": "首先对问题进行验证，以确保其是自洽的、有科学依据且适定的。\n\n### 步骤 1：提取已知条件\n-   **偏微分方程 (PDE)：** 在矩形域上的 $u_t = \\nabla \\cdot (K \\nabla u)$。\n-   **扩散张量 ($K$)：** 常数、对称、正定。具体来说，$K$ 是对角阵，$K = \\mathrm{diag}(\\kappa_x, \\kappa_y)$。\n-   **张量分量：** $\\kappa_x = 7.5$ 和 $\\kappa_y = 0.3$。\n-   **网格：** 与 $x$ 和 $y$ 轴对齐的均匀矩形网格。\n-   **网格间距：** $h_x = 0.02$ 和 $h_y = 0.015$。\n-   **空间离散化：** 五点模板上的二阶中心差分。\n-   **时间离散化：** 前向欧拉法。\n-   **约束条件：** 必须满足离散极值原理（DMP），该原理通过显式格式中所有更新权重均为非负的条件来强制执行。\n-   **目标：** 计算最大允许时间步长 $\\Delta t_{\\max}$，并四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据：** 该问题描述了各向异性热/扩散方程的前向时间中心空间（FTCS）离散化。从离散极值原理导出的稳定性条件是抛物型偏微分方程数值分析中的一个标准和基本概念。该问题在科学上和数学上都是合理的。\n-   **适定性：** 所有参数（$\\kappa_x, \\kappa_y, h_x, h_y$）均已给出，离散格式也已明确定义。DMP的条件导出一个明确的不等式，从中可以确定唯一的最大时间步长 $\\Delta t_{\\max}$。\n-   **目标：** 问题使用了数值分析中精确、标准的术语进行陈述。没有主观或含糊不清的表述。\n\n### 步骤 3：结论与操作\n该问题是**有效的**。这是一个定义明确的数值分析问题。可以继续进行求解过程。\n\n### 解答推导\n给定的抛物型偏微分方程为 $u_t = \\nabla \\cdot (K \\nabla u)$。由于扩散张量 $K = \\mathrm{diag}(\\kappa_x, \\kappa_y)$ 是对角阵，且 $\\kappa_x$ 和 $\\kappa_y$ 是常数，该方程展开为：\n$$\nu_t = \\frac{\\partial}{\\partial x}\\left(\\kappa_x \\frac{\\partial u}{\\partial x}\\right) + \\frac{\\partial}{\\partial y}\\left(\\kappa_y \\frac{\\partial u}{\\partial y}\\right) = \\kappa_x \\frac{\\partial^2 u}{\\partial x^2} + \\kappa_y \\frac{\\partial^2 u}{\\partial y^2}\n$$\n\n设 $u_{i,j}^n$ 为解 $u$ 在网格点 $(x_i, y_j) = (i h_x, j h_y)$ 和时间 $t_n = n \\Delta t$ 处的数值近似。\n\n我们使用指定的方法对偏微分方程进行离散化。\n时间导数 $u_t$ 使用前向欧拉法近似：\n$$\nu_t \\approx \\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t}\n$$\n空间二阶导数使用二阶中心差分近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n}{h_x^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2} \\approx \\frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{h_y^2}\n$$\n将这些近似代入偏微分方程，得到 FTCS（前向时间、中心空间）格式：\n$$\n\\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} = \\kappa_x \\left( \\frac{u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n}{h_x^2} \\right) + \\kappa_y \\left( \\frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{h_y^2} \\right)\n$$\n为了找到更新权重，我们求解 $u_{i,j}^{n+1}$：\n$$\nu_{i,j}^{n+1} = u_{i,j}^n + \\Delta t \\left[ \\kappa_x \\left( \\frac{u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n}{h_x^2} \\right) + \\kappa_y \\left( \\frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{h_y^2} \\right) \\right]\n$$\n让我们为每个方向定义无量纲网格傅里叶数（或类CFL数）：\n$$\nr_x = \\frac{\\kappa_x \\Delta t}{h_x^2} \\quad \\text{and} \\quad r_y = \\frac{\\kappa_y \\Delta t}{h_y^2}\n$$\n将这些代入格式中，并按时间层 $n$ 的空间位置对各项进行分组：\n$$\nu_{i,j}^{n+1} = u_{i,j}^n + r_x(u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n) + r_y(u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n)\n$$\n$$\nu_{i,j}^{n+1} = (1 - 2r_x - 2r_y)u_{i,j}^n + r_x u_{i+1,j}^n + r_x u_{i-1,j}^n + r_y u_{i,j+1}^n + r_y u_{i,j-1}^n\n$$\n在新时间步的值 $u_{i,j}^{n+1}$ 是来自五点模板的当前时间步值的线性组合。这些系数（权重）是：\n-   中心节点 $u_{i,j}^n$ 的权重：$w_C = 1 - 2r_x - 2r_y$\n-   $x$方向相邻节点 $u_{i\\pm 1,j}^n$ 的权重：$w_{E,W} = r_x$\n-   $y$方向相邻节点 $u_{i,j\\pm 1}^n$ 的权重：$w_{N,S} = r_y$\n\n离散极值原理（DMP）要求在时间 $n+1$ 时任意点 $(i,j)$ 的数值解受限于时间 $n$ 时整个计算域上解的最小值和最大值之间。对于这种显式格式，满足DMP的一个充分条件是更新是一个凸组合，这意味着前面提到的所有权重都必须是非负的。\n\n由于 $\\kappa_x, \\kappa_y, \\Delta t, h_x, h_y$ 都是正数，权重 $r_x$ 和 $r_y$ 天然是非负的。唯一非平凡的约束来自于中心节点的权重：\n$$\nw_C = 1 - 2r_x - 2r_y \\ge 0\n$$\n代入 $r_x$ 和 $r_y$ 的定义：\n$$\n1 - 2\\left(\\frac{\\kappa_x \\Delta t}{h_x^2}\\right) - 2\\left(\\frac{\\kappa_y \\Delta t}{h_y^2}\\right) \\ge 0\n$$\n我们可以解这个关于 $\\Delta t$ 的不等式：\n$$\n1 \\ge 2\\Delta t \\left(\\frac{\\kappa_x}{h_x^2} + \\frac{\\kappa_y}{h_y^2}\\right)\n$$\n$$\n\\Delta t \\le \\frac{1}{2 \\left(\\frac{\\kappa_x}{h_x^2} + \\frac{\\kappa_y}{h_y^2}\\right)}\n$$\n最大允许时间步长 $\\Delta t_{\\max}$ 对应于等式成立的情况：\n$$\n\\Delta t_{\\max} = \\frac{1}{2 \\left(\\frac{\\kappa_x}{h_x^2} + \\frac{\\kappa_y}{h_y^2}\\right)}\n$$\n任何时间步长 $\\Delta t > \\Delta t_{\\max}$ 都将导致 $w_C  0$，违反了权重的非负性，从而破坏了DMP。\n\n现在，我们代入给定的数值：$\\kappa_x = 7.5$，$\\kappa_y = 0.3$，$h_x = 0.02$ 和 $h_y = 0.015$。\n首先，计算分母中的各项：\n$$\n\\frac{\\kappa_x}{h_x^2} = \\frac{7.5}{(0.02)^2} = \\frac{7.5}{0.0004} = 18750\n$$\n$$\n\\frac{\\kappa_y}{h_y^2} = \\frac{0.3}{(0.015)^2} = \\frac{0.3}{0.000225} = \\frac{3000}{2.25} = \\frac{4000}{3} \\approx 1333.33...\n$$\n现在，计算这些项的和：\n$$\n\\frac{\\kappa_x}{h_x^2} + \\frac{\\kappa_y}{h_y^2} = 18750 + \\frac{4000}{3} = \\frac{56250}{3} + \\frac{4000}{3} = \\frac{60250}{3}\n$$\n最后，计算 $\\Delta t_{\\max}$：\n$$\n\\Delta t_{\\max} = \\frac{1}{2 \\left(\\frac{60250}{3}\\right)} = \\frac{1}{\\frac{120500}{3}} = \\frac{3}{120500}\n$$\n为了得到数值，我们进行除法运算：\n$$\n\\Delta t_{\\max} = 0.00002489626556...\n$$\n问题要求将此值四舍五入到四位有效数字。前四位有效数字是 $2$、$4$、$8$ 和 $9$。第五位有效数字是 $6$。由于 $6 \\ge 5$，我们将第四位数字向上取整。将 $9$ 向上取整得到 $0$ 并产生进位，因此 $2489$ 变为 $2490$。\n因此，$\\Delta t_{\\max} \\approx 0.00002490$。用科学记数法表示，即为 $2.490 \\times 10^{-5}$。",
            "answer": "$$\n\\boxed{2.490 \\times 10^{-5}}\n$$"
        }
    ]
}