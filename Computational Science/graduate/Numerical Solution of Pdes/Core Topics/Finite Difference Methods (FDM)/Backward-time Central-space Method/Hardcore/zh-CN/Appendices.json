{
    "hands_on_practices": [
        {
            "introduction": "在将任何数值方法应用于实际问题之前，验证其计算实现是否符合理论预期是至关重要的一步。本练习将指导您完成一个经典的网格加密研究（grid refinement study），以通过经验验证后向时间中心空间（BTCS）方法的收敛阶。通过精心设计实验来分离时间误差和空间误差的贡献，您将亲手确认该方法在时间上的一阶精度和在空间上的二阶精度 ，这是科学计算中验证代码正确性的基本技能。",
            "id": "3365331",
            "problem": "考虑定义在有限区间上、具有恒定扩散系数和齐次狄利克雷边界条件的一维热传导方程。其控制偏微分方程为 $u_t = \\alpha u_{xx}$，定义在 $x \\in [0,1]$，$t \\in [0,T]$ 上，边界条件为 $u(0,t)=0$，$u(1,t)=0$，初始条件为 $u(x,0)=\\sin(\\pi x)$。与这些数据一致的精确解为 $u(x,t)=\\exp(-\\alpha \\pi^2 t)\\sin(\\pi x)$。您将使用后向时间中心空间（BTCS）方法来数值逼近该解。该方法定义为时间上采用后向欧拉法，空间上采用标准的二阶中心差分格式。请从相容的空间有限差分和后向欧拉时间离散化的基本定义出发，推导在狄利克雷边界条件下每个时间步需要求解的线性系统。确保您推导的代数系统维度一致且符合边界值。\n\n您的任务是设计并实现一个网格加密实验，以经验性地验证 BTCS 方法的 $\\mathcal{O}(\\Delta t+\\Delta x^2)$ 收敛行为，并展示如何分离时间和空间误差的贡献。使用离散 $L^2$ 范数来量化误差，其对于内部节点上的网格函数 $e_i$ 定义为 $\\|e\\|_{L^2_h} = \\sqrt{\\Delta x}\\left(\\sum_i e_i^2\\right)^{1/2}$。相对于加密参数 $h$ 的观测收敛率，将通过对加密序列中 $\\log(E)$ 与 $\\log(h)$ 进行最小二乘拟合得到的斜率来衡量，其中 $E$ 表示在 $\\| \\cdot \\|_{L^2_h}$ 范数下的误差。\n\n实现以下三个实验，每个实验都旨在探究误差的不同方面：\n\n- 空间加密主导的实验（用于测量 $\\mathcal{O}(\\Delta x^2)$ 的贡献）：固定一个非常小的时间步长，使得时间误差相对于空间误差可以忽略不计。使用 $\\alpha = 1$，$T=0.01$，以及目标时间步长 $\\Delta t_{\\mathrm{target}}=10^{-5}$。对于每个 $N_x \\in \\{16,32,64,128\\}$，设置 $\\Delta x = 1/N_x$，设置时间步数 $N_t=\\lceil T/\\Delta t_{\\mathrm{target}} \\rceil$，然后将实际时间步长设置为 $\\Delta t = T/N_t$，以确保模拟恰好在 $t=T$ 结束。计算在 $t=T$ 时与精确解的离散 $L^2$ 误差，并通过拟合 $\\log(E)$ 与 $\\log(\\Delta x)$ 来估计观测到的空间收敛率。\n\n- 时间加密主导的实验（用于测量 $\\mathcal{O}(\\Delta t)$ 的贡献）：固定一个非常精细的空间网格，使得空间误差相对于时间误差可以忽略不计。使用 $\\alpha = 1$，$T=0.01$，固定 $N_x=512$ 以使 $\\Delta x = 1/512$，并对 $N_t \\in \\{4,8,16,32\\}$（即 $\\Delta t = T/N_t$）进行运行。计算在 $t=T$ 时的离散 $L^2$ 误差，并通过拟合 $\\log(E)$ 与 $\\log(\\Delta t)$ 来估计观测到的时间收敛率。\n\n- 耦合加密实验（用于验证贡献处于同一量级的组合 $\\mathcal{O}(\\Delta t + \\Delta x^2)$ 行为）：使用 $\\alpha = 1$，$T=0.01$，选择 $N_x \\in \\{16,32,64,128\\}$，并设置耦合常数 $c=0.4$。对于每个 $N_x$，首先计算名义时间步长 $\\Delta t_{\\mathrm{nom}} = c\\,\\Delta x^2$，然后设置 $N_t=\\max\\{1,\\mathrm{round}(T/\\Delta t_{\\mathrm{nom}})\\}$ 并使用实际时间步长 $\\Delta t=T/N_t$。计算在 $t=T$ 时的离散 $L^2$ 误差，并通过分别拟合 $\\log(E)$ 与 $\\log(\\Delta x)$ 以及 $\\log(E)$ 与 $\\log(\\Delta t)$ 来估计观测到的耦合收敛率。\n\n在所有实验中，仅针对内部点以完全离散的形式实现 BTCS，并精确处理狄利克雷边界。基于第一性原理构建线性系统，不使用任何预打包的偏微分方程求解器。确保在每个时间步中线性代数运算的一致性。\n\n测试套件和要求的输出：\n\n- 使用上述指定的三个实验及所述的参数值。这三个实验共同构成测试套件。它们涵盖了一般情况、分离了空间和时间误差，并包括了粗网格（$N_x=16$）和极少时间步（$N_t=4$）等边缘情况。\n\n- 对于空间加密主导的实验，报告一个浮点数：估计的空间阶数 $p_{\\mathrm{space}}$。\n\n- 对于时间加密主导的实验，报告一个浮点数：估计的时间阶数 $p_{\\mathrm{time}}$。\n\n- 对于耦合加密实验，报告两个浮点数：关于空间加密的估计阶数 $p_{\\mathrm{coupled},x}$ 和关于时间加密的估计阶数 $p_{\\mathrm{coupled},t}$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”）。该列表必须按 $[p_{\\mathrm{space}},p_{\\mathrm{time}},p_{\\mathrm{coupled},x},p_{\\mathrm{coupled},t}]$ 的顺序列出。所有输出必须是浮点数。此问题不涉及物理单位；所有量均为无量纲量。",
            "solution": "我们从一维热传导方程 $u_t=\\alpha u_{xx}$ 的基本公式开始，该方程定义在 $x\\in[0,1]$ 上，并满足边界条件 $u(0,t)=0$，$u(1,t)=0$ 和初始条件 $u(x,0)=\\sin(\\pi x)$。对于这些数据，精确解为 $u(x,t)=\\exp(-\\alpha \\pi^2 t)\\sin(\\pi x)$，这为评估数值误差提供了一个可靠的参考。后向时间中心空间方法在时间上使用后向欧拉法，在空间上使用标准的二阶中心有限差分来处理拉普拉斯算子。\n\n完全离散格式的推导遵循核心定义。设空间网格有 $N_x$ 个均匀子区间，间距为 $\\Delta x = 1/N_x$，内部节点为 $x_i=i\\Delta x$，其中 $i=1,2,\\dots,N_x-1$。设时间网格有 $N_t$ 个步长，步长为 $\\Delta t = T/N_t$，时间点为 $t^n = n\\Delta t$，其中 $n=0,1,\\dots,N_t$。定义 $u_i^n \\approx u(x_i,t^n)$。后向欧拉时间离散化为 $u_t(x_i,t^{n+1}) \\approx (u_i^{n+1} - u_i^n)/\\Delta t$。二阶导数的二阶中心差分为 $u_{xx}(x_i,t^{n+1}) \\approx (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1})/\\Delta x^2$。将这些代入 $u_t=\\alpha u_{xx}$ 可得\n$$(u_i^{n+1} - u_i^n)/\\Delta t = \\alpha \\frac{u_{i-1}^{n+1} - 2 u_i^{n+1} + u_{i+1}^{n+1}}{\\Delta x^2}.$$\n重新整理并定义 $r = \\alpha \\Delta t / \\Delta x^2$，我们得到关于内部索引 $i=1,\\dots,N_x-1$ 的线性系统：\n$$-r\\,u_{i-1}^{n+1} + (1+2r)\\,u_i^{n+1} - r\\,u_{i+1}^{n+1} = u_i^n.$$\n边界条件为 $u_0^{n+1}=u_{N_x}^{n+1}=0$，因此对于齐次狄利克雷边界，方程右侧没有额外项。以矩阵形式表示，对于内部未知向量 $u^{n+1}\\in\\mathbb{R}^{N_x-1}$，我们求解\n$$(I - \\Delta t\\,\\alpha\\,L_h) u^{n+1} = u^n,$$\n其中 $L_h$ 是用二阶中心差分并按 $\\Delta x^{-2}$ 缩放的离散拉普拉斯算子。对于 $\\alpha>0$，系数矩阵是严格对角占优且对称正定的，因此对于任何 $\\Delta t>0$，该系统都有唯一解。该方法是无条件稳定的，并且对于足够光滑的解，其局部截断误差在时间上是一阶的，在空间上是二阶的；因此，对于光滑解，全局误差的行为是 $\\mathcal{O}(\\Delta t + \\Delta x^2)$。\n\n为了经验性地验证此行为并分离时间和空间贡献，我们设计了三个实验：\n\n1. 空间加密主导的实验：固定一个非常小的 $\\Delta t$，使得在空间加密过程中 $\\mathcal{O}(\\Delta t)$ 项相对于 $\\mathcal{O}(\\Delta x^2)$ 项可以忽略不计。我们使用 $\\alpha=1$，$T=0.01$，以及一个目标时间步长 $\\Delta t_{\\mathrm{target}}=10^{-5}$。对于每个 $N_x\\in\\{16,32,64,128\\}$，设置 $N_t=\\lceil T/\\Delta t_{\\mathrm{target}}\\rceil$ 和 $\\Delta t=T/N_t$。对每个网格，我们计算在 $t=T$ 时离散 $L^2$ 范数下的误差 $E(\\Delta x)$，并通过对 $\\log(E)$ 与 $\\log(\\Delta x)$ 进行最小二乘拟合来估计空间阶数。因为在加密的网格上 $\\Delta t$ 远小于 $\\Delta x^2$（例如，对于 $N_x=128$，$\\Delta x^2 \\approx 6.10\\times 10^{-5}$ 而 $\\Delta t=10^{-5}$），观测到的斜率应接近于 $2$。\n\n2. 时间加密主导的实验：固定一个非常精细的空间网格，使得 $\\mathcal{O}(\\Delta x^2)$ 的空间误差相对于时间离散误差可以忽略不计。我们使用 $\\alpha=1$，$T=0.01$，固定 $N_x=512$ 使得 $\\Delta x^2 \\approx 3.81\\times 10^{-6}$，并改变 $N_t\\in\\{4,8,16,32\\}$，这样 $\\Delta t$ 的范围从 $2.5\\times 10^{-3}$ 降至 $3.125\\times 10^{-4}$，这些值都远大于 $\\Delta x^2$。我们计算误差 $E(\\Delta t)$ 并拟合 $\\log(E)$ 与 $\\log(\\Delta t)$。其斜率应接近于 $1$。\n\n3. 耦合加密实验：设置 $\\Delta t = c\\,\\Delta x^2$（考虑到为对齐最终时间而进行的取整），使得时间和空间误差处于同一量级。我们使用 $\\alpha=1$，$T=0.01$，$c=0.4$，以及 $N_x\\in\\{16,32,64,128\\}$。对于每个 $N_x$，计算名义时间步长 $\\Delta t_{\\mathrm{nom}}=c\\,\\Delta x^2$，然后选择 $N_t=\\max\\{1,\\mathrm{round}(T/\\Delta t_{\\mathrm{nom}})\\}$ 和 $\\Delta t=T/N_t$。计算在 $t=T$ 时的误差；当对 $\\Delta x$ 进行拟合时，误差行为类似于 $\\mathcal{O}(\\Delta x^2)$，产生的观测斜率接近 $2$。当对 $\\Delta t$ 进行拟合时，利用关系 $\\Delta t\\propto \\Delta x^2$，误差行为类似于 $\\mathcal{O}(\\Delta t)$，得到的斜率接近 $1$。\n\n算法设计细节如下：\n\n- 组装三对角矩阵，其主对角线元素为 $(1+2r)$，次对角线元素为 $(-r)$，其中 $r=\\alpha \\Delta t/\\Delta x^2$。这对应于作用在内部向量上的算子 $(I - \\Delta t\\,\\alpha\\,L_h)$。\n\n- 对于每一组 $(\\Delta x,\\Delta t)$，使用稀疏直接求解器对稀疏矩阵进行一次预分解，以加速每个时间步的重复求解过程。\n\n- 使用线性系统给出的递推关系进行 $N_t$ 步的时间推进。由于边界值为零且恒定，每个步骤的右侧是前一个时间步的内部向量。\n\n- 在内部网格点 $x_i=i\\Delta x$（其中 $i=1,\\dots,N_x-1$）和时间 $t=T$ 处评估精确解，计算误差 $e_i=u_i^{N_t}-u(x_i,T)$ 的离散 $L^2$ 范数，即 $\\|e\\|_{L^2_h}=\\sqrt{\\Delta x}\\left(\\sum_i e_i^2\\right)^{1/2}$。\n\n- 通过对 $\\log(E)$ 与 $\\log(h)$ 进行线性拟合，以最小二乘意义上的斜率来估计观测到的收敛率，其中 $h$ 根据实验的不同可以是 $\\Delta x$ 或 $\\Delta t$。\n\n最终程序执行这三个实验，计算所要求的四个度量指标 $[p_{\\mathrm{space}},p_{\\mathrm{time}},p_{\\mathrm{coupled},x},p_{\\mathrm{coupled},t}]$，并将它们以逗号分隔列表的形式打印在单行方括号内。对于光滑的精确解，我们预期得到的值接近 $[2,1,2,1]$，可能由于有限的样本量、对 $N_t$ 的取整以及在少量加密级别上进行的最小二乘拟合而存在微小偏差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, csc_matrix\nfrom scipy.sparse.linalg import splu\n\ndef exact_solution(x, t, alpha):\n    # Exact solution: exp(-alpha*pi^2*t) * sin(pi*x)\n    return np.exp(-alpha * (np.pi**2) * t) * np.sin(np.pi * x)\n\ndef build_btcs_solver(alpha, dx, dt, nx_interior):\n    # Build (I - dt*alpha*L_h) where L_h is centered second-difference / dx^2\n    r = alpha * dt / (dx * dx)\n    main = (1.0 + 2.0 * r) * np.ones(nx_interior)\n    off = (-r) * np.ones(nx_interior - 1)\n    A = diags(diagonals=[off, main, off], offsets=[-1, 0, 1], format='csc')\n    # Factorize once for repeated solves\n    solver = splu(A)\n    return solver\n\ndef btcs_heat(alpha, T, Nx, Nt):\n    # Returns interior solution at final time T, and grid spacing dx\n    dx = 1.0 / Nx\n    dt = T / Nt\n    nx_interior = Nx - 1\n    # Interior grid points x_i = i*dx, i = 1..Nx-1\n    x_interior = np.linspace(dx, 1.0 - dx, nx_interior)\n\n    # Initial condition on interior: sin(pi x)\n    u = np.sin(np.pi * x_interior).copy()\n\n    # Pre-factorized solver for the linear system\n    solver = build_btcs_solver(alpha, dx, dt, nx_interior)\n\n    # Time stepping\n    for _ in range(Nt):\n        u = solver.solve(u)\n\n    return u, x_interior, dx, dt\n\ndef discrete_L2_error(u_num, x_interior, dx, T, alpha):\n    u_ex = exact_solution(x_interior, T, alpha)\n    e = u_num - u_ex\n    return np.sqrt(dx) * np.linalg.norm(e, ord=2)\n\ndef observed_order(h_list, E_list):\n    # Fit log(E) = p * log(h) + c\n    logh = np.log(np.array(h_list))\n    logE = np.log(np.array(E_list))\n    p, _ = np.polyfit(logh, logE, 1)\n    return p\n\ndef spatial_refinement_experiment():\n    alpha = 1.0\n    T = 0.01\n    Nx_list = [16, 32, 64, 128]\n    # Target very small dt to suppress temporal error; adjust Nt to land on T\n    dt_target = 1e-5\n    Nt = int(np.ceil(T / dt_target))\n    # Final actual dt used\n    dt_actual = T / Nt\n\n    dx_list = []\n    E_list = []\n    for Nx in Nx_list:\n        u_num, x_interior, dx, _ = btcs_heat(alpha, T, Nx, Nt)\n        E = discrete_L2_error(u_num, x_interior, dx, T, alpha)\n        dx_list.append(dx)\n        E_list.append(E)\n    p_space = observed_order(dx_list, E_list)\n    return p_space\n\ndef temporal_refinement_experiment():\n    alpha = 1.0\n    T = 0.01\n    Nx = 512  # very fine spatial grid to suppress spatial error\n    Nt_list = [4, 8, 16, 32]\n\n    dt_list = []\n    E_list = []\n    for Nt in Nt_list:\n        u_num, x_interior, dx, dt = btcs_heat(alpha, T, Nx, Nt)\n        E = discrete_L2_error(u_num, x_interior, dx, T, alpha)\n        dt_list.append(dt)\n        E_list.append(E)\n    p_time = observed_order(dt_list, E_list)\n    return p_time\n\ndef coupled_refinement_experiment():\n    alpha = 1.0\n    T = 0.01\n    Nx_list = [16, 32, 64, 128]\n    c = 0.4\n\n    dx_list = []\n    dt_list = []\n    E_list = []\n    for Nx in Nx_list:\n        dx = 1.0 / Nx\n        dt_nom = c * dx * dx\n        # Choose Nt so that dt ~ c*dx^2 and T is reached exactly\n        Nt = int(max(1, round(T / dt_nom)))\n        u_num, x_interior, dx_used, dt_used = btcs_heat(alpha, T, Nx, Nt)\n        E = discrete_L2_error(u_num, x_interior, dx_used, T, alpha)\n        dx_list.append(dx_used)\n        dt_list.append(dt_used)\n        E_list.append(E)\n    p_coupled_x = observed_order(dx_list, E_list)\n    p_coupled_t = observed_order(dt_list, E_list)\n    return p_coupled_x, p_coupled_t\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Three experiments: spatial-dominated, temporal-dominated, coupled refinement\n    results = []\n    p_space = spatial_refinement_experiment()\n    results.append(f\"{p_space:.6f}\")\n    p_time = temporal_refinement_experiment()\n    results.append(f\"{p_time:.6f}\")\n    p_cx, p_ct = coupled_refinement_experiment()\n    results.append(f\"{p_cx:.6f}\")\n    results.append(f\"{p_ct:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一个优秀的数值格式不仅应具备稳定性与精度，还应能保持解的关键物理特性。对于许多由抛物型偏微分方程描述的物理过程，如热传导或化学物质浓度，解的非负性是一项基本物理约束。本练习将挑战您从第一性原理出发，推导出一个尖锐的条件，以保证BTCS格式在求解一个带反应项的扩散问题时能够保持解的非负性 。这个过程将抽象的单调矩阵理论与对方程中物理参数（如反应系数 $\\beta$）和数值参数（如时间步长 $\\Delta t$）之间关系的深刻理解联系起来。",
            "id": "3365252",
            "problem": "考虑单位区间上的线性反应扩散初边值问题，\n$$\nu_{t}(x,t) \\;=\\; \\kappa\\,u_{xx}(x,t) \\;+\\; \\beta\\,u(x,t), \\quad x\\in(0,1),\\; t>0,\n$$\n其具有固定的狄利克雷边界数据\n$$\nu(0,t) \\;=\\; g_{0}(t), \\qquad u(1,t) \\;=\\; g_{1}(t),\n$$\n和初始条件\n$$\nu(x,0) \\;=\\; u_{0}(x),\n$$\n其中 $\\kappa>0$ 和 $\\beta>0$ 是常数。假设数据具有非负性，即对所有 $x\\in[0,1]$ 有 $u_{0}(x)\\ge 0$，且对所有 $t\\ge 0$ 有 $g_{0}(t)\\ge 0$ 和 $g_{1}(t)\\ge 0$。\n\n用均匀网格 $x_{i}=i h$，$i=0,1,\\dots,M$，$h=1/M$ 对空间区间进行离散化，并定义时间网格 $t^{n}=n\\,\\Delta t$，$n\\in\\mathbb{N}$。令 $u_{i}^{n}$ 表示在内部节点 $i=1,\\dots,M-1$ 和时间 $n\\ge 0$ 处对 $u(x_{i},t^{n})$ 的近似。应用后向时间中心空间 (BTCS) 方法，对每个时间步 $n\\to n+1$，得到一个关于内部值 $u_{i}^{n+1}$ 的三对角线性系统，其中出现了扩散比\n$$\n\\lambda \\;=\\; \\frac{\\kappa\\,\\Delta t}{h^{2}}\n$$\n。\n\n仅使用单调矩阵和离散极值原理的基本性质，从第一性原理推导时间步长 $\\Delta t$ 的尖锐条件（仅用 $\\beta$ 表示），该条件保证 BTCS 更新具有以下保正性，且对所有空间网格（等价于，对所有 $\\lambda\\ge 0$）一致成立：\n\n如果对所有内部指标 $i$ 都有 $u_{i}^{n}\\ge 0$，并且在新时间层上的狄利克雷边界值满足 $g_{0}(t^{n+1})\\ge 0$ 和 $g_{1}(t^{n+1})\\ge 0$，那么在下一个时间层上的 BTCS 解满足对所有内部指标 $i$ 都有 $u_{i}^{n+1}\\ge 0$。\n\n你的最终答案应该是一个单一的闭式解析表达式，给出仅用 $\\beta$ 表示的最大允许 $\\Delta t$，且对所有 $\\lambda\\ge 0$ 有效。最终答案中不要提供不等式；而是将最大允许 $\\Delta t$ 作为显式表达式提供。最终答案中不需要数值取整。仅用 $\\beta$ 表示你的答案。",
            "solution": "该问题要求推导时间步长 $\\Delta t$ 的一个尖锐条件，该条件保证应用于给定反应扩散方程的后向时间中心空间 (BTCS) 方法具有保正性，并且对所有空间网格尺寸有效。\n\n偏微分方程 (PDE) 由下式给出\n$$u_{t}(x,t) \\;=\\; \\kappa\\,u_{xx}(x,t) \\;+\\; \\beta\\,u(x,t), \\quad x\\in(0,1),\\; t>0$$\n其中常数 $\\kappa>0$ 且 $\\beta>0$。边界条件为 $u(0,t) = g_{0}(t)$ 和 $u(1,t) = g_{1}(t)$，初始条件为 $u(x,0) = u_{0}(x)$。假设数据是非负的。\n\n我们首先构建 BTCS 数值格式。空间域用均匀网格 $x_{i}=i h$ ($i=0,1,\\dots,M$，$h=1/M$) 进行离散化。时间域离散为 $t^{n}=n\\,\\Delta t$。令 $u_{i}^{n}$ 表示 $u(x_{i},t^{n})$ 的数值近似。\n\nBTCS 方法在时间层 $t^{n+1}$ 对方程进行离散化。时间导数 $u_t$ 用后向差分近似，空间导数 $u_{xx}$ 用中心差分近似，两者都在 $(x_i, t^{n+1})$ 处计算。\n$$\n\\frac{u_{i}^{n+1} - u_{i}^{n}}{\\Delta t} \\;=\\; \\kappa\\,\\frac{u_{i+1}^{n+1} - 2u_{i}^{n+1} + u_{i-1}^{n+1}}{h^{2}} \\;+\\; \\beta\\,u_{i}^{n+1}\n$$\n该方程对内部网格点 $i=1, \\dots, M-1$ 成立。\n\n我们重排方程，将时间层 $n+1$ 的项归到左侧，时间层 $n$ 的项归到右侧。两边同乘以 $\\Delta t$ 得到\n$$\nu_{i}^{n+1} - u_{i}^{n} \\;=\\; \\frac{\\kappa\\,\\Delta t}{h^{2}}(u_{i+1}^{n+1} - 2u_{i}^{n+1} + u_{i-1}^{n+1}) \\;+\\; \\beta\\,\\Delta t\\,u_{i}^{n+1}\n$$\n使用给定的扩散比 $\\lambda = \\frac{\\kappa\\,\\Delta t}{h^{2}}$，我们有\n$$\nu_{i}^{n+1} - u_{i}^{n} \\;=\\; \\lambda(u_{i+1}^{n+1} - 2u_{i}^{n+1} + u_{i-1}^{n+1}) \\;+\\; \\beta\\,\\Delta t\\,u_{i}^{n+1}\n$$\n将上标为 $n+1$ 的项归到左侧，得到\n$$\n-\\lambda u_{i-1}^{n+1} + (1 + 2\\lambda - \\beta\\Delta t)u_{i}^{n+1} - \\lambda u_{i+1}^{n+1} \\;=\\; u_{i}^{n}\n$$\n这组关于 $i=1, \\dots, M-1$ 的方程构成了一个关于内部值未知向量 $\\mathbf{u}^{n+1} = [u_{1}^{n+1}, u_{2}^{n+1}, \\dots, u_{M-1}^{n+1}]^T$ 的线性系统。我们将其写成矩阵形式 $A\\mathbf{u}^{n+1} = \\mathbf{b}$。\n\n在内部区域的边界上，对于 $i=1$ 和 $i=M-1$，我们引入狄利克雷边界条件：$u_{0}^{n+1} = g_{0}(t^{n+1})$ 和 $u_{M}^{n+1} = g_{1}(t^{n+1})$。\n对于 $i=1$：\n$$\n-\\lambda u_{0}^{n+1} + (1 + 2\\lambda - \\beta\\Delta t)u_{1}^{n+1} - \\lambda u_{2}^{n+1} \\;=\\; u_{1}^{n}\n$$\n$$\n(1 + 2\\lambda - \\beta\\Delta t)u_{1}^{n+1} - \\lambda u_{2}^{n+1} \\;=\\; u_{1}^{n} + \\lambda g_{0}(t^{n+1})\n$$\n对于 $i=M-1$：\n$$\n-\\lambda u_{M-2}^{n+1} + (1 + 2\\lambda - \\beta\\Delta t)u_{M-1}^{n+1} - \\lambda u_{M}^{n+1} \\;=\\; u_{M-1}^{n}\n$$\n$$\n-\\lambda u_{M-2}^{n+1} + (1 + 2\\lambda - \\beta\\Delta t)u_{M-1}^{n+1} \\;=\\; u_{M-1}^{n} + \\lambda g_{1}(t^{n+1})\n$$\n矩阵 $A$ 是一个 $(M-1) \\times (M-1)$ 的三对角矩阵，其元素为：\n$$\na_{ii} = 1 + 2\\lambda - \\beta\\Delta t \\quad \\text{对于 } i=1, \\dots, M-1\n$$\n$$\na_{i,i-1} = a_{i,i+1} = -\\lambda \\quad \\text{对于相关的 } i\n$$\n右侧向量 $\\mathbf{b}$ 的分量为：\n$$\nb_{1} = u_{1}^{n} + \\lambda g_{0}(t^{n+1})\n$$\n$$\nb_{i} = u_{i}^{n} \\quad \\text{对于 } i=2, \\dots, M-2\n$$\n$$\nb_{M-1} = u_{M-1}^{n} + \\lambda g_{1}(t^{n+1})\n$$\n问题要求，如果在前一时间步的解是非负的（对所有 $i$ 有 $u_{i}^{n} \\ge 0$），并且边界数据是非负的（$g_{0}(t^{n+1}) \\ge 0$，$g_{1}(t^{n+1}) \\ge 0$），那么在新时间步的解也必须是非负的（对所有 $i$ 有 $u_{i}^{n+1} \\ge 0$）。\n已知 $\\kappa>0$，$\\Delta t > 0$ 且 $h>0$，则有 $\\lambda>0$。假设 $u_{i}^{n} \\ge 0$，$g_0 \\ge 0$，$g_1 \\ge 0$ 保证了向量 $\\mathbf{b}$ 的每个分量都是非负的，即 $\\mathbf{b} \\ge \\mathbf{0}$（逐分量）。\n因此，保正性转化为以下矩阵性质：如果 $\\mathbf{b} \\ge \\mathbf{0}$，则解 $\\mathbf{u}^{n+1} = A^{-1}\\mathbf{b}$ 必须满足 $\\mathbf{u}^{n+1} \\ge \\mathbf{0}$。这当且仅当逆矩阵 $A^{-1}$ 的所有元素都是非负的，即 $A^{-1} \\ge 0$。具有此性质的矩阵 $A$ 称为单调矩阵。\n\n一个矩阵是单调矩阵的一个充分条件是它是一个非奇异 M 矩阵。一个实方阵 $A=(a_{ij})$ 是 M 矩阵，如果它满足以下条件：\n1. 对所有 $i$，$a_{ii} > 0$（正对角元）。\n2. 对所有 $i \\ne j$，$a_{ij} \\le 0$（一个 Z 矩阵）。\n3. $A$ 是非奇异的，且 $A^{-1}$ 的所有元素都是非负的。确保这一点的一个常用方法是证明 $A$ 是严格或不可约对角占优的。\n\n我们来检查我们的矩阵 $A$ 是否满足这些条件。\n条件 2：非对角元素为 $a_{i,j} = -\\lambda$。由于 $\\lambda = \\frac{\\kappa \\Delta t}{h^2} \\ge 0$，此条件得到满足。$A$ 是一个 Z 矩阵。\n条件 1：对角元素必须为正：$a_{ii} = 1 + 2\\lambda - \\beta\\Delta t > 0$。此条件必须对所有可能的空间网格选择都成立，这意味着它必须对所有 $\\lambda \\ge 0$ 都成立。表达式 $1 + 2\\lambda - \\beta\\Delta t$ 是 $\\lambda$ 的一个线性函数。它在域 $\\lambda \\ge 0$ 上的最小值出现在 $\\lambda=0$ 处。因此，为使该不等式对所有 $\\lambda \\ge 0$ 成立，它必须在该最小值处成立：\n$$\n1 + 2(0) - \\beta\\Delta t > 0 \\implies 1 - \\beta\\Delta t > 0 \\implies \\Delta t  \\frac{1}{\\beta}\n$$\n我们来分析对角占优性作为另一条路径，它为一个候选 M 矩阵确立了非奇异性和单调性。一个矩阵 $A$ 是不可约对角占优的，如果它是不可约的，所有行都弱对角占优（$|a_{ii}| \\ge \\sum_{j\\ne i} |a_{ij}|$)，并且至少有一行是严格对角占优的（$|a_{ii}| > \\sum_{j\\ne i} |a_{ij}|$）。\n对于我们的矩阵 $A$，它是一个具有非零非对角线元素的三对角矩阵，因此是不可约的。\n对于行 $i=2, \\dots, M-2$ 的弱对角占优条件是：\n$$\n|1 + 2\\lambda - \\beta\\Delta t| \\ge |-\\lambda| + |-\\lambda| = 2\\lambda\n$$\n假设对角元为正，此条件为 $1 + 2\\lambda - \\beta\\Delta t \\ge 2\\lambda$，简化为 $1 - \\beta\\Delta t \\ge 0$。\n对于第一行和最后一行（$i=1, M-1$），条件是：\n$$\n|1 + 2\\lambda - \\beta\\Delta t| \\ge |-\\lambda| = \\lambda\n$$\n简化为 $1 + 2\\lambda - \\beta\\Delta t \\ge \\lambda$，或 $1 + \\lambda - \\beta\\Delta t \\ge 0$。\n为了使该条件对所有行和所有 $\\lambda \\ge 0$ 都成立，必须满足这些条件中最严格的一个。这显然是 $1 - \\beta\\Delta t \\ge 0$，即 $\\Delta t \\le 1/\\beta$。\n\n我们来验证 $\\Delta t \\le 1/\\beta$ 是一个充分条件。如果 $\\Delta t \\le 1/\\beta$，则 $1 - \\beta\\Delta t \\ge 0$。\n- 对角元为 $a_{ii} = (1 - \\beta\\Delta t) + 2\\lambda \\ge 2\\lambda$。对于任何有效的离散化（$\\Delta t>0, h>0$），我们有 $\\lambda > 0$，所以 $a_{ii} > 0$。\n- 非对角元为 $-\\lambda \\le 0$。\n- 我们已经为所有行建立了弱对角占优：对于内部行有 $a_{ii} \\ge 2\\lambda$，对于边界行有 $a_{ii} \\ge 2\\lambda > \\lambda$。\n矩阵 $A$ 是不可约对角占优的。这样的矩阵是一个非奇异 M 矩阵，其逆矩阵 $A^{-1}$ 的所有元素均为正。因此，如果 $\\Delta t \\le 1/\\beta$，则对任何 $h > 0$ 的选择，保正性都成立。\n\n现在我们必须证明这个条件是尖锐的（必要的）。假设我们选择一个时间步长 $\\Delta t$ 使得 $\\Delta t > 1/\\beta$。令 $\\Delta t = (1+\\epsilon)/\\beta$，其中某个 $\\epsilon > 0$。那么 $1 - \\beta\\Delta t = -\\epsilon  0$。\n矩阵 $A$ 的对角元变为 $a_{ii} = 1 + 2\\lambda - \\beta\\Delta t = 2\\lambda - \\epsilon$。\n保正性条件必须对所有空间网格成立，即对所有 $\\lambda \\ge 0$ 的值成立。我们可以自由选择一个网格尺寸 $h$ 从而得到任意的 $\\lambda$。如果我们选择一个粗网格（大的 $h$）或一个小的 $\\kappa$，我们可以使 $\\lambda$ 任意小。具体来说，我们可以选择 $h$ 使得 $\\lambda = \\frac{\\kappa \\Delta t}{h^2}  \\frac{\\epsilon}{2}$。\n对于这样的选择，对角元 $a_{ii} = 2\\lambda - \\epsilon$ 变为负数。一个具有负对角元的矩阵不可能是 M 矩阵，保正性也无法保证。\n为了更明确地看到这一点，考虑极限 $\\lambda \\to 0$。系统矩阵 $A$ 趋近于 $(1-\\beta\\Delta t)I = -\\epsilon I$，其中 $I$ 是单位矩阵。线性系统近似变为 $-\\epsilon \\mathbf{u}^{n+1} = \\mathbf{u}^n$。如果我们从 $\\mathbf{u}^n > \\mathbf{0}$ 开始，下一个解是 $\\mathbf{u}^{n+1} \\approx -\\frac{1}{\\epsilon}\\mathbf{u}^n$，这是负的。这违反了保正性。\n因此，条件 $\\Delta t \\le 1/\\beta$ 是必要的。\n\n由于条件 $\\Delta t \\le 1/\\beta$ 对于所有 $\\lambda \\ge 0$ 的保正性是充要的，尖锐条件是该不等式的边界情况。$\\Delta t$ 的最大允许值是满足此条件的最大值。\n\n最大允许的 $\\Delta t$ 是 $\\frac{1}{\\beta}$。",
            "answer": "$$\\boxed{\\frac{1}{\\beta}}$$"
        },
        {
            "introduction": "本练习将BTCS方法置于一个更高级的应用背景中：作为求解不可压缩Navier-Stokes方程的半隐式方法中处理粘性项的关键步骤。通过比较BTCS方法、经典的Crank-Nicolson (CN)方法以及一种改进的CN方法，您将深入探究不同隐式格式在抑制高频数值振荡方面的能力。通过数值计算最高频空间模式的放大因子 ，您将直观地观察到L-稳定性的概念，并理解为何时间上一阶的BTCS方法在处理刚性问题或作为多重网格法中的光滑子时，有时会比时间上二阶的CN方法更受青睐。",
            "id": "3365299",
            "problem": "考虑在不可压缩纳维-斯托克斯方程的半隐式处理中出现的黏性子步，其中对流项被显式处理，而黏性项被隐式处理。在没有对流贡献的情况下，该子步简化为单个速度分量的线性扩散方程，即一维热传导方程\n$$\n\\partial_t u(x,t) = \\nu \\,\\partial_{xx} u(x,t),\n$$\n此方程定义在长度为 $1$ 的周期性区间上，运动黏度 $\\nu > 0$。您必须分析并实现三种用于均匀周期性网格上隐式扩散子步的时间积分策略。\n\n基本基础与离散化框架：\n- 使用包含 $N$ 个点的均匀网格，网格间距为 $h = 1/N$。设网格点 $j$ 和时间层 $n$ 处的未知量表示为 $u_j^n$，其中 $j \\in \\{0,1,\\dots,N-1\\}$。\n- 使用标准的二阶中心差分（带周期性环绕）来近似拉普拉斯算子：\n$$\n(\\Delta_h u)_j = \\frac{u_{j+1} - 2 u_j + u_{j-1}}{h^2},\n$$\n其中索引对 $N$ 取模。\n- 引入无量纲步长参数\n$$\nr = \\frac{\\nu\\,\\Delta t}{h^2},\n$$\n其中 $\\Delta t$ 是时间步长。\n\n需要实现的时间离散化方法：\n- 后向时间中心空间法（BTCS）：采用后向欧拉时间离散和上述空间离散。这是通过用后向差分替换 $\\partial_t u$ 并用新时间层上的中心差分替换 $\\partial_{xx} u$ 而得到的标准无条件稳定隐式扩散格式。\n- Crank–Nicolson (CN) 方法：用于扩散子步的梯形（时间中心）方法，通过对时间层 $n$ 和 $n+1$ 上的空间算子取平均得到。\n- 带 Rannacher 启动的 Crank–Nicolson 方法：将第一个完整的 $\\Delta t$ 步替换为两个大小为 $\\Delta t/2$ 的后向欧拉半步（使用相同的空间算子），以为高频分量提供额外的阻尼。为此问题的目的，您只需考虑通过两个大小为 $\\Delta t/2$ 的后向欧拉求解实现的单步总时间 $\\Delta t$ 的传播；不进行后续步骤。\n\n评估任务：\n- 考虑周期性网格上可分辨的最高空间傅里叶模式，由网格函数 $v_j = (-1)^j$ 给出。这是均匀周期性网格上离散拉普拉斯算子的一个特征向量。对于上面列出的三种格式中的每一种，定义单步放大率如下：从 $u^0 = v$ 开始，根据该格式计算一个总时间步长 $\\Delta t$ 后的 $u^1$，并报告其比率\n$$\nG = \\frac{\\|u^1\\|_2}{\\|u^0\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 是欧几里得范数。此量衡量了该最高频率模式的黏性阻尼。由于网格算子是循环矩阵，$v$ 是一个特征向量，所以 $G$ 与相应标量放大因子的大小一致。\n- 您的程序必须构建与中心差分对应的周期性离散拉普拉斯矩阵，形成每种时间离散化所隐含的线性系统，并通过线性代数方法为下面指定的参数集数值计算 $G$。在您的实现中，不要使用任何预先推导的闭式放大公式；结果应通过构建和应用线性系统得出。\n\n测试套件：\n- 使用黏度 $\\nu = 0.01$ 和网格尺寸 $N = 64$（因此 $h = 1/64$）。\n- 对以下三个时间步长 $\\Delta t$ 中的每一个，评估单步放大率 $G$：\n  - 小步长：$\\Delta t = 0.0005$。\n  - 中等步长：$\\Delta t = 0.005$。\n  - 大步长：$\\Delta t = 0.05$。\n- 对于每个 $\\Delta t$，按照以下顺序计算并报告放大率三元组：BTCS、CN、带 Rannacher 启动的 CN（两个后向欧拉半步）。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含所有九个结果，形式为一个逗号分隔的列表，并用方括号括起来，按 $\\Delta t$ 递增排序，且对于每个 $\\Delta t$，按上述指定的格式顺序排序。具体而言，输出格式必须为\n$$\n[\\text{G\\_BTCS}(\\Delta t_1),\\text{G\\_CN}(\\Delta t_1),\\text{G\\_Rannacher}(\\Delta t_1),\\text{G\\_BTCS}(\\Delta t_2),\\text{G\\_CN}(\\Delta t_2),\\text{G\\_Rannacher}(\\Delta t_2),\\text{G\\_BTCS}(\\Delta t_3),\\text{G\\_CN}(\\Delta t_3),\\text{G\\_Rannacher}(\\Delta t_3)],\n$$\n其中 $\\Delta t_1 = 0.0005$，$\\Delta t_2 = 0.005$，以及 $\\Delta t_3 = 0.05$。每个数字必须四舍五入到 $6$ 位小数。不应打印任何其他文本。",
            "solution": "该问题要求对一维扩散方程 $\\partial_t u = \\nu \\partial_{xx} u$ 在周期域上的三种隐式时间积分格式进行分析和数值实现。目标是计算离散网格上最高频率傅里葉模式的单步放大率。\n\n控制偏微分方程（PDE）是热传导方程：\n$$\n\\partial_t u(x,t) = \\nu \\,\\partial_{xx} u(x,t)\n$$\n其中 $u(x,t)$ 是关注量（例如，速度分量），$x \\in [0,1)$ 是具有周期性边界条件的空间坐标，$t$ 是时间，$\\nu > 0$ 是恒定的运动黏度。\n\n我们首先对空间域进行离散化。使用一个有 $N$ 个点的均匀网格，网格间距为 $h = 1/N$。网格点为 $x_j = j h$，其中 $j \\in \\{0, 1, \\dots, N-1\\}$。设 $U(t)$ 为时间 $t$ 处网格值的列向量，$U(t) = [u(x_0,t), u(x_1,t), \\dots, u(x_{N-1},t)]^T$。二阶空间导数 $\\partial_{xx} u$ 使用带周期性边界条件的标准二阶中心差分算子进行近似：\n$$\n(\\Delta_h u)_j = \\frac{u_{j+1} - 2u_j + u_{j-1}}{h^2}\n$$\n其中索引对 $N$ 取模。这种空间离散化将偏微分方程转化为一个常微分方程（ODEs）组：\n$$\n\\frac{d U}{dt} = \\nu A U(t)\n$$\n这里，$A$ 是离散拉普拉斯算子 $\\Delta_h$ 的 $N \\times N$ 矩阵表示。它是一个实对称循环矩阵，形式如下：\n$$\nA = \\frac{1}{h^2}\n\\begin{pmatrix}\n-2  1  0  \\dots  0  1 \\\\\n1  -2  1  \\ddots   0 \\\\\n0  1  -2  \\ddots  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  1  0 \\\\\n0   \\ddots  1  -2  1 \\\\\n1  0  \\dots  0  1  -2\n\\end{pmatrix}\n$$\n设 $U^n$ 表示在时间 $t_n = n \\Delta t$ 处对 $U(t)$ 的数值近似。现在我们介绍三种时间步进格式。\n\n1.  **后向时间中心空间法 (BTCS)**：该格式对时间导数使用一阶后向欧拉方法，在未来的时间层 $n+1$ 处计算空间项。\n    $$\n    \\frac{U^{n+1} - U^n}{\\Delta t} = \\nu A U^{n+1}\n    $$\n    整理各项以求解 $U^{n+1}$，得到线性系统：\n    $$\n    (I - \\nu \\Delta t A) U^{n+1} = U^n\n    $$\n    其中 $I$ 是 $N \\times N$ 单位矩阵。\n\n2.  **Crank–Nicolson (CN) 方法**：该格式基于用于时间积分的二阶梯形法则，在时间层 $n$ 和 $n+1$ 处对空间项取平均。\n    $$\n    \\frac{U^{n+1} - U^n}{\\Delta t} = \\frac{\\nu A}{2} (U^n + U^{n+1})\n    $$\n    将涉及 $U^{n+1}$ 的项组合在左侧，涉及 $U^n$ 的项组合在右侧，我们得到线性系统：\n    $$\n    \\left(I - \\frac{\\nu \\Delta t}{2} A\\right) U^{n+1} = \\left(I + \\frac{\\nu \\Delta t}{2} A\\right) U^n\n    $$\n\n3.  **带 Rannacher 启动的 Crank–Nicolson 方法**：此过程通过执行两个后向欧拉步（每步时间步长为 $\\Delta t/2$）来阻尼高频振荡。对于此问题，这个两步过程构成了在一个完整时间步长 $\\Delta t$ 内的全部演化。\n    - 第 1 步（从 $t_n$ 到 $t_{n+1/2} = t_n + \\Delta t/2$）：\n      $$\n      \\left(I - \\nu \\frac{\\Delta t}{2} A\\right) U^{n+1/2} = U^n\n      $$\n    - 第 2 步（从 $t_{n+1/2}$ 到 $t_{n+1} = t_n + \\Delta t$）：\n      $$\n      \\left(I - \\nu \\frac{\\Delta t}{2} A\\right) U^{n+1} = U^{n+1/2}\n      $$\n    求解第一个方程得到 $U^{n+1/2}$ 并代入第二个方程，得到总体更新：\n    $$\n    U^{n+1} = \\left(I - \\nu \\frac{\\Delta t}{2} A\\right)^{-1} \\left[ \\left(I - \\nu \\frac{\\Delta t}{2} A\\right)^{-1} U^n \\right] = \\left(I - \\nu \\frac{\\Delta t}{2} A\\right)^{-2} U^n\n    $$\n    在数值上，这是通过求解两个具有相同系统矩阵的序贯线性系统来实现的。\n\n评估任务是计算特定初始条件 $U^0$（对应于网格函数 $v_j = (-1)^j$）的单步放大率 $G = \\|U^1\\|_2 / \\|U^0\\|_2$。此函数代表了周期性网格上可分辨的最高空间频率。由于 $v_j$ 是循环矩阵 $A$ 的一个特征向量， resulting vector $U^1$ 将是 $U^0$ 的一个标量倍数，而 $G$ 将是这个标量乘子（放大因子）的大小。数值步骤如下：\n- 为给定的 $N=64$ 和 $h=1/64$ 构建矩阵 $A$。\n- 构建初始向量 $U^0$，其元素为 $(U^0)_j = (-1)^j$。\n- 对于每种格式和每个给定的 $\\Delta t$：\n    - 为线性系统组装相应的矩阵。\n    - 求解解向量 $U^1$。\n    - 计算欧几里得范数 $\\|U^1\\|_2$ 和 $\\|U^0\\|_2$。\n    - 计算比率 $G = \\|U^1\\|_2 / \\|U^0\\|_2$。\n然后报告指定参数集的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes three time-integration schemes for the 1D heat equation by\n    computing the amplification magnitude for the highest-frequency Fourier mode.\n    \"\"\"\n    # Define parameters from the problem statement\n    nu = 0.01\n    N = 64\n    h = 1.0 / N\n\n    # Define the test cases for the time step delta_t\n    test_cases = [0.0005, 0.005, 0.05]\n\n    # Construct the initial condition vector u0 for the highest-frequency mode\n    # u_j = (-1)^j\n    j_indices = np.arange(N)\n    u0 = (-1.0)**j_indices\n    norm_u0 = np.linalg.norm(u0)\n\n    # Construct the discrete Laplacian matrix A\n    # A = (1/h^2) * L, where L is circulant with (-2, 1, ..., 1) in the first row.\n    diag_val = -2.0\n    off_diag_val = 1.0\n    \n    A_unscaled = np.diag(diag_val * np.ones(N)) + \\\n                 np.diag(off_diag_val * np.ones(N - 1), k=1) + \\\n                 np.diag(off_diag_val * np.ones(N - 1), k=-1)\n    \n    # Apply periodic boundary conditions for the corners\n    A_unscaled[0, N - 1] = off_diag_val\n    A_unscaled[N - 1, 0] = off_diag_val\n\n    A = A_unscaled / (h**2)\n\n    all_results = []\n\n    # Iterate through each test case (each delta_t)\n    for delta_t in test_cases:\n        # 1. Backward-Time Central-Space (BTCS)\n        # (I - nu * dt * A) * u1 = u0\n        mat_btcs = np.identity(N) - nu * delta_t * A\n        u1_btcs = np.linalg.solve(mat_btcs, u0)\n        g_btcs = np.linalg.norm(u1_btcs) / norm_u0\n        all_results.append(g_btcs)\n\n        # 2. Crank-Nicolson (CN)\n        # (I - nu*dt/2 * A) * u1 = (I + nu*dt/2 * A) * u0\n        mat_cn_lhs = np.identity(N) - (nu * delta_t / 2.0) * A\n        mat_cn_rhs = np.identity(N) + (nu * delta_t / 2.0) * A\n        rhs_cn = mat_cn_rhs @ u0\n        u1_cn = np.linalg.solve(mat_cn_lhs, rhs_cn)\n        g_cn = np.linalg.norm(u1_cn) / norm_u0\n        all_results.append(g_cn)\n        \n        # 3. Rannacher Startup (two BTCS half-steps)\n        # (I - nu*dt/2 * A) * u_half = u0\n        # (I - nu*dt/2 * A) * u1 = u_half\n        # The matrix is the same as the CN left-hand side matrix.\n        mat_rannacher = mat_cn_lhs\n        u_half = np.linalg.solve(mat_rannacher, u0)\n        u1_rannacher = np.linalg.solve(mat_rannacher, u_half)\n        g_rannacher = np.linalg.norm(u1_rannacher) / norm_u0\n        all_results.append(g_rannacher)\n\n    # Format the final output string to 6 decimal places per number\n    # The format '{:.6f}'.format is used to ensure trailing zeros are printed.\n    print(f\"[{','.join(map('{:.6f}'.format, all_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}