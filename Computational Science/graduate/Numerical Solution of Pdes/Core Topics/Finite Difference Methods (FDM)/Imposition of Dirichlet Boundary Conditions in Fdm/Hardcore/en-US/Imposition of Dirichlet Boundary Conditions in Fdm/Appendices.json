{
    "hands_on_practices": [
        {
            "introduction": "A powerful way to analyze the influence of boundary conditions is to formulate an operator that lives exclusively on the boundary. This exercise guides you through the derivation of the discrete Dirichlet-to-Neumann (DtN) map, which relates Dirichlet data directly to the resulting normal fluxes at the boundary. By using Schur complement elimination on the finite difference system, you will explicitly construct this operator for a 1D Laplacian, revealing the fundamental algebraic structure that governs the interaction between the domain's interior and its boundary .",
            "id": "3407312",
            "problem": "Consider the homogeneous Laplace Partial Differential Equation (PDE) $u''(x) = 0$ on the interval $[0,L]$ with unknown boundary Dirichlet data prescribed at the endpoints. Discretize $[0,L]$ using a uniform grid of $N+2$ points $x_j = j h$, where $h = \\frac{L}{N+1}$, with boundary nodes indexed by $j = 0$ and $j = N+1$, and interior nodes indexed by $j = 1,2,\\dots,N$. Let the Finite Difference Method (FDM) use the standard centered second-difference operator, so that the interior field $u_j$ satisfies $u_{j-1} - 2 u_j + u_{j+1} = 0$ for all $j = 1,\\dots,N$. Denote the boundary Dirichlet data by the vector $u_b = \\begin{pmatrix} u_0 \\\\ u_{N+1} \\end{pmatrix}$ and the interior unknown vector by $u_i = \\begin{pmatrix} u_1 \\\\ \\vdots \\\\ u_N \\end{pmatrix}$. Define the discrete outward normal flux vector at the endpoints by $q = \\begin{pmatrix} q_L \\\\ q_R \\end{pmatrix}$ with $q_L = -\\frac{u_1 - u_0}{h}$ at $x = 0$ and $q_R = \\frac{u_{N+1} - u_N}{h}$ at $x = L$. \n\nStarting from the block-structured linear system induced by the finite-difference stencil, use the Schur complement to eliminate the interior unknowns $u_i$ and express the discrete Dirichlet-to-Neumann (Steklov) map $S_h$ such that $q = S_h\\, u_b$. In your derivation, start from the definition of the discrete Laplacian and the Schur complement, and justify each algebraic step. Then analyze the computational cost, in big-$\\mathcal{O}$ notation, of forming and applying the Schur complement for the two-dimensional discrete Laplacian on an $m \\times m$ grid (with $(m-2)^2$ interior nodes) when using a sparse Cholesky factorization with nested dissection ordering. Finally, discuss the stability of the discrete Steklov problem by characterizing symmetry, (semi)definiteness, and the presence or absence of nullspaces for the one-dimensional $S_h$ you derived, including the scaling of its nonzero eigenvalue with $h$ and $N$.\n\nProvide as your final answer the explicit closed-form analytic expression for the $2 \\times 2$ matrix $S_h$ in terms of $N$ and $h$. No numerical rounding is required in this problem.",
            "solution": "The problem requires the derivation and analysis of the discrete Dirichlet-to-Neumann (DtN) map for the one-dimensional Laplace equation, an analysis of the computational cost for a related two-dimensional problem, and a stability analysis of the derived one-dimensional DtN map.\n\n### Part 1: Derivation of the Discrete DtN Map $S_h$\n\nWe begin with the finite difference discretization of the PDE $u''(x) = 0$ on the interval $[0, L]$. The domain is discretized into $N+2$ points $x_j = j h$ for $j=0, 1, \\dots, N+1$, where $h = L/(N+1)$. The governing equation for the interior nodes $u_j$ ($j=1, \\dots, N$) is given by the centered second-difference formula:\n$$u_{j-1} - 2 u_j + u_{j+1} = 0$$\nThis set of $N$ linear equations can be written in block-matrix form by partitioning the solution vector into interior unknowns $u_i = (u_1, u_2, \\dots, u_N)^T$ and boundary values $u_b = (u_0, u_{N+1})^T$.\n\nFor $j=1$, we have $u_0 - 2u_1 + u_2 = 0$.\nFor $j=2, \\dots, N-1$, we have $u_{j-1} - 2u_j + u_{j+1} = 0$.\nFor $j=N$, we have $u_{N-1} - 2u_N + u_{N+1} = 0$.\n\nSeparating the interior and boundary terms, we obtain a system for the interior unknowns $u_i$:\n$$\n\\begin{pmatrix}\n-2 & 1 & 0 & \\dots & 0 \\\\\n1 & -2 & 1 & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n0 & \\dots & 1 & -2 & 1 \\\\\n0 & \\dots & 0 & 1 & -2\n\\end{pmatrix}\n\\begin{pmatrix} u_1 \\\\ u_2 \\\\ \\vdots \\\\ u_{N-1} \\\\ u_N \\end{pmatrix}\n+\n\\begin{pmatrix}\nu_0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ u_{N+1}\n\\end{pmatrix}\n= \\begin{pmatrix} 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\nThis can be expressed in the compact block form $A_{ii} u_i + A_{ib} u_b = 0$, where:\n$A_{ii}$ is the $N \\times N$ symmetric tridiagonal matrix representing the interior discrete Laplacian:\n$$A_{ii} = \\begin{pmatrix}\n-2 & 1 & & \\\\\n1 & -2 & 1 & \\\\\n& \\ddots & \\ddots & \\ddots \\\\\n& & 1 & -2 & 1 \\\\\n& & & 1 & -2\n\\end{pmatrix}$$\n$A_{ib}$ is the $N \\times 2$ matrix coupling the interior to the boundary:\n$$A_{ib} = \\begin{pmatrix}\n1 & 0 \\\\\n0 & 0 \\\\\n\\vdots & \\vdots \\\\\n0 & 0 \\\\\n0 & 1\n\\end{pmatrix} = \\begin{pmatrix} e_1 & e_N \\end{pmatrix}$$\nwhere $e_j$ is the $j$-th standard basis vector in $\\mathbb{R}^N$.\n\nTo eliminate the interior unknowns $u_i$, we solve for them in terms of the boundary data $u_b$:\n$$u_i = -A_{ii}^{-1} A_{ib} u_b$$\nNext, we express the discrete outward normal flux vector $q = (q_L, q_R)^T$ in terms of $u_i$ and $u_b$. The fluxes are defined as $q_L = -\\frac{u_1 - u_0}{h}$ and $q_R = \\frac{u_{N+1} - u_N}{h}$. In matrix form, this is:\n$$q = \\frac{1}{h}\\begin{pmatrix} u_0 - u_1 \\\\ u_{N+1} - u_N \\end{pmatrix} = \\frac{1}{h}\\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}u_b + \\frac{1}{h}\\begin{pmatrix} -1 & 0 & \\dots & 0 \\\\ 0 & \\dots & 0 & -1 \\end{pmatrix}u_i$$\nThis corresponds to the block form $q = C u_b + B u_i$, where:\n$$C = \\frac{1}{h}I_2 \\quad \\text{and} \\quad B = \\frac{1}{h}\\begin{pmatrix} -e_1^T \\\\ -e_N^T \\end{pmatrix}$$\nSubstituting the expression for $u_i$ into the equation for $q$ yields the DtN map $S_h$:\n$$q = C u_b + B(-A_{ii}^{-1} A_{ib} u_b) = (C - B A_{ii}^{-1} A_{ib}) u_b$$\nThus, the DtN map, which is the Schur complement of the system, is $S_h = C - B A_{ii}^{-1} A_{ib}$.\n\nTo find an explicit expression for $S_h$, we need the inverse of $A_{ii}$. The inverse of this specific tridiagonal matrix is known analytically:\n$$(A_{ii}^{-1})_{jk} = -\\frac{1}{N+1} \\min(j,k)(N+1-\\max(j,k)) = -\\frac{1}{N+1} \\begin{cases} j(N+1-k) & \\text{if } j \\le k \\\\ k(N+1-j) & \\text{if } j > k \\end{cases}$$\nWe first compute the matrix product $B A_{ii}^{-1} A_{ib}$:\n$$B A_{ii}^{-1} A_{ib} = \\left( \\frac{1}{h}\\begin{pmatrix} -e_1^T \\\\ -e_N^T \\end{pmatrix} \\right) A_{ii}^{-1} \\begin{pmatrix} e_1 & e_N \\end{pmatrix} = \\frac{1}{h} \\begin{pmatrix} -e_1^T A_{ii}^{-1} e_1 & -e_1^T A_{ii}^{-1} e_N \\\\ -e_N^T A_{ii}^{-1} e_1 & -e_N^T A_{ii}^{-1} e_N \\end{pmatrix}$$\nThe entries are calculated using the formula for $A_{ii}^{-1}$:\n$e_1^T A_{ii}^{-1} e_1 = (A_{ii}^{-1})_{11} = -\\frac{1(N+1-1)}{N+1} = -\\frac{N}{N+1}$\n$e_1^T A_{ii}^{-1} e_N = (A_{ii}^{-1})_{1N} = -\\frac{1(N+1-N)}{N+1} = -\\frac{1}{N+1}$\n$e_N^T A_{ii}^{-1} e_1 = (A_{ii}^{-1})_{N1} = -\\frac{1(N+1-N)}{N+1} = -\\frac{1}{N+1}$\n$e_N^T A_{ii}^{-1} e_N = (A_{ii}^{-1})_{NN} = -\\frac{N(N+1-N)}{N+1} = -\\frac{N}{N+1}$\nPlugging these back into the expression for the product:\n$$B A_{ii}^{-1} A_{ib} = \\frac{1}{h} \\begin{pmatrix} -(-\\frac{N}{N+1}) & -(-\\frac{1}{N+1}) \\\\ -(-\\frac{1}{N+1}) & -(-\\frac{N}{N+1}) \\end{pmatrix} = \\frac{1}{h(N+1)}\\begin{pmatrix} N & 1 \\\\ 1 & N \\end{pmatrix}$$\nFinally, we compute $S_h$:\n$$S_h = C - B A_{ii}^{-1} A_{ib} = \\frac{1}{h}\\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} - \\frac{1}{h(N+1)}\\begin{pmatrix} N & 1 \\\\ 1 & N \\end{pmatrix}$$\n$$S_h = \\frac{1}{h(N+1)}\\begin{pmatrix} N+1 & 0 \\\\ 0 & N+1 \\end{pmatrix} - \\frac{1}{h(N+1)}\\begin{pmatrix} N & 1 \\\\ 1 & N \\end{pmatrix}$$\n$$S_h = \\frac{1}{h(N+1)}\\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$$\nThis is the explicit form for the $2 \\times 2$ matrix $S_h$. Notably, since $h=L/(N+1)$, we have $L=h(N+1)$. Therefore, $S_h = \\frac{1}{L}\\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$, which is identical to the DtN map for the continuous problem $u''(x)=0$. This occurs because the centered difference scheme is exact for linear functions, which are the solutions to the 1D Laplace equation.\n\n### Part 2: Computational Cost for the 2D Case\n\nFor a 2D discrete Laplacian on an $m \\times m$ grid, the number of interior nodes is $M = (m-2)^2$. The problem is to find the cost of forming and applying the Schur complement $S = A_{bb} - A_{bi} A_{ii}^{-1} A_{ib}$ using a sparse Cholesky factorization with nested dissection ordering. The interior matrix $A_{ii}$ has dimension $M \\times M$.\nThe number of boundary nodes is $N_b = m^2 - (m-2)^2 = 4m-4 = \\mathcal{O}(m)$.\n\n**Cost of Forming $S$:**\nThe formation of $S$ involves three main steps:\n1.  **Factorization of $A_{ii}$**: For a 2D grid graph with $M$ vertices, the nested dissection algorithm provides a sparse Cholesky factorization $A_{ii} = LL^T$ with computational cost (flops) of $\\mathcal{O}(M^{3/2})$. Substituting $M=\\mathcal{O}(m^2)$, the cost is $\\mathcal{O}((m^2)^{3/2}) = \\mathcal{O}(m^3)$.\n2.  **Solving for $X = A_{ii}^{-1} A_{ib}$**: This involves solving a system $A_{ii}x = c$ for each of the $N_b = \\mathcal{O}(m)$ columns of $A_{ib}$. The cost of a single solve (forward/backward substitution) using the sparse factor $L$ from nested dissection is $\\mathcal{O}(M \\log M)$. With $M=\\mathcal{O}(m^2)$, a single solve costs $\\mathcal{O}(m^2 \\log m)$. Performing this for all $N_b$ columns gives a total cost of $N_b \\times \\mathcal{O}(m^2 \\log m) = \\mathcal{O}(m) \\times \\mathcal{O}(m^2 \\log m) = \\mathcal{O}(m^3 \\log m)$.\n3.  **Matrix Multiplication**: The cost of computing $A_{bi}X$ is dominated by the previous steps. The matrix $X$ is dense of size $M \\times N_b$, but $A_{bi}$ is sparse with $\\mathcal{O}(m)$ non-zeros.\n\nThe overall cost of forming the dense Schur complement matrix $S$ is dominated by the multiple solves, resulting in a complexity of $\\mathcal{O}(m^3 \\log m)$.\n\n**Cost of Applying $S$:**\nOnce the matrix $S$ has been explicitly formed, it is a dense $N_b \\times N_b$ matrix, where $N_b = \\mathcal{O}(m)$. Applying $S$ to a boundary vector $u_b$ corresponds to the matrix-vector product $S u_b$. The cost is $\\mathcal{O}(N_b^2) = \\mathcal{O}((4m-4)^2) = \\mathcal{O}(m^2)$.\n\n### Part 3: Stability Analysis of the 1D $S_h$\n\nWe analyze the properties of $S_h = \\frac{1}{L} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$.\n\n**Symmetry**: The matrix is symmetric since $(S_h)_{12} = (S_h)_{21} = -1/L$. That is, $S_h = S_h^T$. This is expected as the operator is self-adjoint and the discretization used is symmetric.\n\n**Definiteness and Nullspace**: We examine the quadratic form $u_b^T S_h u_b$ for $u_b = (u_0, u_{N+1})^T$:\n$$u_b^T S_h u_b = \\frac{1}{L} \\begin{pmatrix} u_0 & u_{N+1} \\end{pmatrix} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} \\begin{pmatrix} u_0 \\\\ u_{N+1} \\end{pmatrix} = \\frac{1}{L} (u_0 - u_{N+1})^2$$\nSince $L > 0$, we have $u_b^T S_h u_b \\ge 0$ for all $u_b$. Therefore, $S_h$ is positive semi-definite. It is not positive definite because the quadratic form is zero for non-zero vectors where $u_0 = u_{N+1}$.\nThe nullspace of $S_h$ consists of vectors $u_b$ for which $S_h u_b = 0$. This condition gives $u_0 - u_{N+1} = 0$, so $u_0 = u_{N+1}$. The nullspace is spanned by the vector $\\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$. Physically, this corresponds to a constant boundary condition, $u(0)=u(L)$, which for the problem $u''(x)=0$ implies a constant solution $u(x)=c$. A constant solution has zero derivative, hence zero flux at the boundaries, which is consistent with $q=S_h u_b=0$.\n\n**Eigenvalues and Scaling**: We find the eigenvalues $\\lambda$ by solving $\\det(S_h - \\lambda I) = 0$:\n$$\\det \\begin{pmatrix} \\frac{1}{L} - \\lambda & -\\frac{1}{L} \\\\ -\\frac{1}{L} & \\frac{1}{L} - \\lambda \\end{pmatrix} = \\left(\\frac{1}{L} - \\lambda\\right)^2 - \\left(\\frac{1}{L}\\right)^2 = 0$$\nThis yields $(\\frac{1}{L} - \\lambda) = \\pm \\frac{1}{L}$, which gives the eigenvalues $\\lambda_1 = 0$ and $\\lambda_2 = \\frac{2}{L}$.\nThe zero eigenvalue corresponds to the nullspace. The nonzero eigenvalue is $\\lambda_2 = \\frac{2}{L}$. Since we established that $S_h$ is independent of the discretization parameters $h$ and $N$ for a fixed domain length $L$, its nonzero eigenvalue is also a constant, $\\frac{2}{L}$. Therefore, the scaling of the nonzero eigenvalue with respect to $h$ and $N$ is $\\mathcal{O}(1)$.",
            "answer": "$$\n\\boxed{\\frac{1}{h(N+1)} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "In many scientific and engineering applications, boundary data comes from physical measurements and is inherently noisy or inconsistent. Directly imposing this 'ill-posed' data can severely degrade the accuracy of a numerical solution. This practice confronts this challenge head-on by introducing a Tikhonov regularization step to smooth the boundary data *before* it is used in the finite difference solver for the Poisson equation, demonstrating a robust method for handling imperfect information .",
            "id": "3407296",
            "problem": "Consider the elliptic boundary value problem for the Partial Differential Equation (PDE) $-\\Delta u = f$ on the unit square $\\Omega = (0,1)^2$, subject to Dirichlet boundary conditions $u|_{\\partial \\Omega} = g$. In many practical settings, the measured boundary data $g$ are noisy or mutually inconsistent at corners, and may be incompatible with the interior forcing term $f$ in the sense that they do not correspond to the trace of any sufficiently smooth solution of the PDE with the given $f$. This can severely degrade the accuracy of numerical solutions when using the Finite Difference Method (FDM). Your task is to implement a finite difference solver that imposes Dirichlet boundary conditions after regularizing the noisy boundary data $g$ using Tikhonov filtering performed along the discrete boundary curve.\n\nYou must proceed as follows.\n\n1) Discretize $\\Omega$ with a uniform grid of $N+1$ by $N+1$ points for $N = 64$, with mesh width $h = 1/N$. Use the standard five-point stencil FDM for the operator $-\\Delta$ on the interior grid points, and enforce Dirichlet boundary conditions by eliminating boundary unknowns, which results in a linear system for the interior grid values with right-hand side contributions incorporating the boundary values.\n\n2) Choose the exact solution $u^\\star(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$, which implies\n$$\nf(x,y) = -\\Delta u^\\star(x,y) = 8\\pi^2 \\sin(2\\pi x)\\sin(2\\pi y),\n$$\nand the exact boundary trace is identically zero, i.e., $u^\\star|_{\\partial\\Omega} \\equiv 0$.\n\n3) Construct a discrete ordering of the boundary nodes as a single periodic cycle of length $4N$, enumerated in this order without duplicating corners: along the bottom edge from $(i,j)=(0,0)$ to $(N-1,0)$, then the right edge from $(N,0)$ to $(N,N-1)$, then the top edge from $(N,N)$ down to $(1,N)$, and finally the left edge from $(0,N)$ down to $(0,1)$. Let the vector $y \\in \\mathbb{R}^{4N}$ denote the measured Dirichlet data in this boundary order.\n\n4) Model ill-posed measured boundary data $y$ by adding independent Gaussian noise of amplitude $\\sigma$ to each boundary node and a single outlier of magnitude $\\delta$ at the first boundary index corresponding to the corner $(0,0)$. The noise must be generated by a fixed normal sequence with seed $314159$ so the results are reproducible. Explicitly, $y = \\sigma z + \\delta e_1$, where $z \\sim \\mathcal{N}(0, I)$ is fixed by the seed and $e_1$ is the first canonical basis vector.\n\n5) Regularize the measured boundary data by solving the one-dimensional Tikhonov smoothing problem on the closed boundary cycle:\n$$\ng_\\alpha = \\arg\\min_{g \\in \\mathbb{R}^{4N}} \\left\\{ \\lVert g - y \\rVert_2^2 + \\alpha \\lVert D g \\rVert_2^2 \\right\\},\n$$\nwhere $D \\in \\mathbb{R}^{4N \\times 4N}$ is the cyclic second-difference operator discretizing the second derivative along the boundary order with periodic wrap:\n$$\n(D g)_k = g_{k+1} - 2 g_k + g_{k-1} \\quad \\text{for all } k \\text{ with indices modulo } 4N.\n$$\nShow that the minimizer satisfies the normal equations\n$$\n(I + \\alpha D^\\top D) g_\\alpha = y.\n$$\nUse $g_\\alpha$ as the imposed Dirichlet boundary values in the FDM system.\n\n6) For each test case below, assemble the FDM linear system for the interior nodes using the five-point stencil, incorporate the Dirichlet boundary via $g_\\alpha$ on all boundary nodes (including corners), solve the linear system, reconstruct the full grid solution (interior plus boundary), and report the discrete $L^2$ error with respect to $u^\\star$ on the whole grid:\n$$\nE = \\left( h^2 \\sum_{i=0}^N \\sum_{j=0}^N \\left( u_{i,j} - u^\\star(x_i,y_j) \\right)^2 \\right)^{1/2},\n$$\nwhere $x_i = i h$ and $y_j = j h$.\n\nTest Suite:\n- Case $1$: $\\alpha = 0$, $\\sigma = 0.02$, $\\delta = 0.5$.\n- Case $2$: $\\alpha = 10^{-4}$, $\\sigma = 0.02$, $\\delta = 0.5$.\n- Case $3$: $\\alpha = 10^{-2}$, $\\sigma = 0.02$, $\\delta = 0.5$.\n- Case $4$: $\\alpha = 1$, $\\sigma = 0.02$, $\\delta = 0.5$.\n- Case $5$ (baseline, consistent data): $\\alpha = 0$, $\\sigma = 0$, $\\delta = 0$.\n\nAll quantities are dimensionless, so no physical units apply.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of the test cases, i.e., $[E_1,E_2,E_3,E_4,E_5]$, where each $E_k$ is the discrete $L^2$ error for the corresponding case.",
            "solution": "The user-provided problem has been analyzed and is determined to be valid. It is a well-posed problem in numerical analysis, grounded in the established principles of finite difference methods for partial differential equations and Tikhonov regularization for ill-posed inverse problems. All parameters and conditions are specified, and the task is computationally feasible.\n\nHere follows a complete, reasoned solution.\n\n### 1. Problem Formulation\nThe problem asks for the numerical solution of the two-dimensional Poisson equation with Dirichlet boundary conditions on the unit square $\\Omega = (0,1)^2$:\n$$\n-\\Delta u = f \\quad \\text{in } \\Omega\n$$\n$$\nu|_{\\partial \\Omega} = g\n$$\nThe core challenge lies in handling noisy and inconsistent boundary data $g$. The proposed method involves regularizing the boundary data $g$ before incorporating it into a finite difference scheme. The exact solution $u^\\star(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$ is used to define the forcing function $f(x,y) = -\\Delta u^\\star = 8\\pi^2 \\sin(2\\pi x)\\sin(2\\pi y)$ and to evaluate the accuracy of the numerical solution. The exact boundary data corresponding to $u^\\star$ is $u^\\star|_{\\partial\\Omega} \\equiv 0$.\n\n### 2. Discretization and Finite Difference Method (FDM)\nThe domain $\\Omega$ is discretized using a uniform grid with $N+1$ points in each direction, where $N=64$. The grid points are $(x_i, y_j) = (ih, jh)$ for $i,j \\in \\{0, 1, \\dots, N\\}$, with mesh spacing $h=1/N$. Let $u_{i,j}$ denote the numerical approximation of $u(x_i, y_j)$.\n\nThe negative Laplacian operator, $-\\Delta$, is approximated at each interior grid point $(x_i,y_j)$ for $i,j \\in \\{1, \\dots, N-1\\}$ using the standard five-point stencil:\n$$\n-\\Delta u(x_i, y_j) \\approx \\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2}\n$$\nEquating this to the forcing function $f(x_i, y_j)$ yields a system of linear equations for the $(N-1)^2$ interior unknown values:\n$$\n4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} = h^2 f_{i,j}\n$$\nThe values of $u$ on the boundary (where $i=0$, $i=N$, $j=0$, or $j=N$) are given by the Dirichlet condition.\n\n### 3. Regularization of Boundary Data\nThe measured boundary data is modeled as a vector $y \\in \\mathbb{R}^{4N}$ corresponding to a specific ordering of the $4N$ boundary nodes. This data is synthetically corrupted with Gaussian noise of amplitude $\\sigma$ and a corner outlier of magnitude $\\delta$: $y = \\sigma z + \\delta e_1$, where $z \\sim \\mathcal{N}(0, I)$ and $e_1$ is the first canonical basis vector.\n\nTo regularize this noisy data, we solve the Tikhonov minimization problem:\n$$\ng_\\alpha = \\arg\\min_{g \\in \\mathbb{R}^{4N}} J(g), \\quad \\text{where } J(g) = \\lVert g - y \\rVert_2^2 + \\alpha \\lVert D g \\rVert_2^2\n$$\nHere, $\\alpha \\ge 0$ is the regularization parameter. The operator $D \\in \\mathbb{R}^{4N \\times 4N}$ is the cyclic second-difference matrix, which approximates the second derivative along the boundary. For a vector $g$, $(Dg)_k = g_{k+1} - 2g_k + g_{k-1}$, with indices taken modulo $4N$.\n\nThe objective functional $J(g)$ is quadratic and convex. Its minimum is found by setting its gradient with respect to $g$ to zero. The functional can be written in vector notation as:\n$$\nJ(g) = (g-y)^\\top(g-y) + \\alpha (Dg)^\\top(Dg) = g^\\top g - 2y^\\top g + y^\\top y + \\alpha g^\\top D^\\top D g\n$$\nThe gradient with respect to $g$ is:\n$$\n\\nabla_g J(g) = 2g - 2y + 2\\alpha D^\\top D g\n$$\nSetting $\\nabla_g J(g) = 0$ yields the normal equations for the regularized data $g_\\alpha$:\n$$\n(I + \\alpha D^\\top D) g_\\alpha = y\n$$\nwhere $I$ is the $4N \\times 4N$ identity matrix. This is a linear system that can be solved for $g_\\alpha$. For $\\alpha=0$, the solution is simply $g_0 = y$, meaning no regularization is applied. For $\\alpha > 0$, the matrix $I + \\alpha D^\\top D$ is symmetric and positive definite, guaranteeing a unique solution.\n\n### 4. Assembling and Solving the Full System\nThe solution process is sequential:\n1.  **Solve for Boundary Data**: For each test case $(\\alpha, \\sigma, \\delta)$, construct the noisy vector $y$ and solve the Tikhonov system $(I + \\alpha D^\\top D) g_\\alpha = y$ to obtain the regularized boundary values $g_\\alpha$.\n\n2.  **Solve for Interior Solution**: The FDM equations for the interior nodes are rearranged to form a large linear system, $A_{pde} u_{int} = b_{pde}$.\n    *   The vector of unknowns $u_{int} \\in \\mathbb{R}^{(M)}$ where $M=(N-1)^2$ contains the values $u_{i,j}$ for $i,j \\in \\{1,\\dots,N-1\\}$, ordered row-by-row.\n    *   The matrix $A_{pde}$ is an $M \\times M$ sparse, block-tridiagonal matrix representing the discrete negative Laplacian on the interior grid. It is independent of the boundary data.\n    *   The right-hand side vector $b_{pde}$ incorporates both the forcing term $f$ and the boundary conditions. For an interior node $(i,j)$, the corresponding entry in $b_{pde}$ is $h^2 f_{i,j}$ plus any terms $u_{i',j'}$ where $(i',j')$ is a neighboring boundary node. The values for these boundary terms are taken from the computed $g_\\alpha$. For example, for the interior node $(1,1)$, the equation is $4u_{1,1} - u_{2,1} - u_{1,2} = h^2f_{1,1} + u_{0,1} + u_{1,0}$, where $u_{0,1}$ and $u_{1,0}$ are components of the regularized boundary data $g_\\alpha$.\n\nThis FDM system is solved for the interior values $u_{int}$.\n\n### 5. Solution Reconstruction and Error Evaluation\nThe final numerical solution $U$ on the full $(N+1) \\times (N+1)$ grid is reconstructed by combining the computed interior values from $u_{int}$ with the regularized boundary values from $g_\\alpha$.\n\nThe accuracy of this solution $U$ is measured against the exact solution sampled on the grid, $U^\\star_{i,j} = u^\\star(x_i, y_j) = \\sin(2\\pi x_i) \\sin(2\\pi y_j)$. The error is calculated using the discrete $L^2$-norm, which accounts for contributions from all grid points, including the boundary:\n$$\nE = \\left( h^2 \\sum_{i=0}^N \\sum_{j=0}^N \\left( u_{i,j} - u^\\star_{i,j} \\right)^2 \\right)^{1/2} = h \\left\\lVert U - U^\\star \\right\\rVert_F\n$$\nwhere $\\lVert \\cdot \\rVert_F$ denotes the Frobenius norm. This error metric will be computed for each test case.",
            "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the Poisson equation on a unit square with noisy Dirichlet boundary data,\n    regularized using Tikhonov filtering.\n    \"\"\"\n    N = 64\n    h = 1.0 / N\n\n    test_cases = [\n        # (alpha, sigma, delta)\n        (0.0, 0.02, 0.5),\n        (1e-4, 0.02, 0.5),\n        (1e-2, 0.02, 0.5),\n        (1.0, 0.02, 0.5),\n        (0.0, 0.0, 0.0),\n    ]\n\n    # --- Pre-computation Step ---\n\n    # 1. Define boundary node ordering: map linear index k to (i, j) coordinates\n    boundary_map = np.zeros((4 * N, 2), dtype=int)\n    # Bottom edge: (0,0) to (N-1,0)\n    k_range = np.arange(N)\n    boundary_map[k_range, 0] = k_range\n    boundary_map[k_range, 1] = 0\n    # Right edge: (N,0) to (N,N-1)\n    k_range = np.arange(N, 2 * N)\n    boundary_map[k_range, 0] = N\n    boundary_map[k_range, 1] = k_range - N\n    # Top edge: (N,N) to (1,N)\n    k_range = np.arange(2 * N, 3 * N)\n    boundary_map[k_range, 0] = N - (k_range - 2 * N)\n    boundary_map[k_range, 1] = N\n    # Left edge: (0,N) to (0,1)\n    k_range = np.arange(3 * N, 4 * N)\n    boundary_map[k_range, 0] = 0\n    boundary_map[k_range, 1] = N - (k_range - 3 * N)\n\n    # 2. Generate the fixed Gaussian noise vector\n    rng = np.random.default_rng(314159)\n    z = rng.normal(0, 1, 4 * N)\n    \n    # 3. Construct Tikhonov regularization operator D\n    diag_D = np.ones(4 * N)\n    D = sparse.diags([-2 * diag_D, diag_D, diag_D], [0, 1, -1], format='csc')\n    D[0, -1] = 1\n    D[-1, 0] = 1\n    DtD = D.T @ D\n\n    # 4. Construct FDM matrix for interior nodes\n    M = N - 1\n    n_unknowns = M * M\n    \n    # Using sparse.kron for a clean construction\n    T_M = sparse.diags([4, -1, -1, -1, -1], [0, -1, 1, -M, M], shape=(n_unknowns, n_unknowns), format='csc')\n    A_pde_h2 = T_M / h**2\n\n    # --- Main Loop for Test Cases ---\n    results = []\n    for alpha, sigma, delta in test_cases:\n        # a. Construct noisy boundary data y\n        e1 = np.zeros(4 * N)\n        e1[0] = 1.0\n        y = sigma * z + delta * e1\n\n        # b. Solve for regularized boundary data g_alpha\n        if alpha == 0.0:\n            g_alpha = y\n        else:\n            A_reg = sparse.identity(4 * N, format='csc') + alpha * DtD\n            g_alpha = spsolve(A_reg, y)\n\n        # c. Place g_alpha onto the boundary of a grid\n        U_b = np.zeros((N + 1, N + 1))\n        for k in range(4 * N):\n            i, j = boundary_map[k]\n            U_b[i, j] = g_alpha[k]\n        \n        # d. Construct the FDM right-hand-side vector b\n        x = np.linspace(0, 1, N + 1)\n        \n        # Using [:, None] and [None, :] for broadcasting\n        f_grid = 8 * (np.pi**2) * np.sin(2 * np.pi * x[:, None]) * np.sin(2 * np.pi * x[None, :])\n        b_pde_vec = f_grid[1:N, 1:N].flatten()\n        \n        # Add boundary contributions to b\n        for i_int in range(M):\n            for j_int in range(M):\n                k_vec = i_int * M + j_int\n                i, j = i_int + 1, j_int + 1\n                \n                if i == 1: b_pde_vec[k_vec] += U_b[0, j] / h**2\n                if i == N - 1: b_pde_vec[k_vec] += U_b[N, j] / h**2\n                if j == 1: b_pde_vec[k_vec] += U_b[i, 0] / h**2\n                if j == N - 1: b_pde_vec[k_vec] += U_b[i, N] / h**2\n                \n        # e. Solve for interior values u_int\n        u_int_vec = spsolve(A_pde_h2, b_pde_vec)\n        \n        # f. Reconstruct the full solution U\n        U_sol = np.copy(U_b)\n        U_sol[1:N, 1:N] = u_int_vec.reshape((M, M))\n\n        # g. Calculate the discrete L2 error\n        U_exact = np.sin(2 * np.pi * x[:, None]) * np.sin(2 * np.pi * x[None, :])\n        error_matrix = U_sol - U_exact\n        L2_error = h * np.linalg.norm(error_matrix)\n        results.append(L2_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.6g}' for err in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "When solving time-dependent PDEs, operator splitting schemes are widely used to handle different physical processes in separate steps. However, the sequence of these steps, particularly the imposition of time-varying Dirichlet boundary conditions, can introduce subtle yet significant errors. This exercise explores the local consistency error that arises at the boundary when using a Lie splitting scheme for a reaction-diffusion equation, highlighting the critical importance of how and when boundary conditions are enforced within each time step .",
            "id": "3407301",
            "problem": "Consider the linear reactionâ€“diffusion partial differential equation on the unit interval domain $\\Omega=(0,1)$ with time $t\\ge 0$,\n$$\nu_t = \\Delta u + R(u),\n$$\nwhere $R(u)$ is a reaction operator. Assume Dirichlet boundary conditions $u(0,t)=g_0(t)$ and $u(1,t)=g_1(t)$ are prescribed for all $t\\ge 0$. The focus of this problem is on the imposition of Dirichlet boundary conditions in a time-splitting (operator-splitting) scheme when the boundary is enforced in only one of the substeps, and on analyzing the resulting consistency error localized at the boundary $\\partial\\Omega$.\n\nWe restrict attention to a one-dimensional setting, adopt a uniform spatial mesh with $N+1$ grid points $x_i = i h$ for $i=0,1,\\dots,N$, with step size $h=1/N$, and use the standard second-order centered finite difference approximation of the Laplacian:\n$$\n\\Delta_h u_i := \\frac{u_{i+1} - 2 u_i + u_{i-1}}{h^2}, \\quad i=1,\\dots,N-1.\n$$\nWe employ explicit Euler time integration with time step $\\Delta t$ and Lie splitting where the diffusion substep is followed by the reaction substep. Dirichlet boundary conditions are imposed only in the diffusion substep. Specifically, for a single time step from $t_n$ to $t_{n+1}=t_n+\\Delta t$, the scheme is:\n1. Diffusion substep: for interior nodes $i=1,\\dots,N-1$,\n$$\n\\tilde{u}_i = u_i^n + \\Delta t \\, \\Delta_h u_i^n,\n$$\nand impose Dirichlet boundary at the end of this substep:\n$$\n\\tilde{u}_0 = g_0(t_{n+1}), \\quad \\tilde{u}_N = g_1(t_{n+1}).\n$$\n2. Reaction substep: for all nodes $i=0,1,\\dots,N$,\n$$\nu_i^{n+1} = \\tilde{u}_i + \\Delta t \\, R(\\tilde{u}_i),\n$$\nand the Dirichlet boundary is not reimposed after this substep.\n\nTo make the analysis concrete and testable, consider $R(u) = \\kappa u$ with a constant $\\kappa>0$, and choose boundary data and initial condition so that a closed-form exact solution is available:\n- Dirichlet boundary data $g_0(t) = 0$ and $g_1(t) = b \\, e^{\\kappa t}$ for a constant $b>0$.\n- Initial condition\n$$\nu(x,0) = a \\sin(\\pi x) + b x,\n$$\nwith constants $a,b>0$.\n\nFor this configuration, the exact solution of the continuous problem is\n$$\nu(x,t) = a \\, e^{(\\kappa - \\pi^2)t} \\sin(\\pi x) + b \\, e^{\\kappa t} \\, x,\n$$\nwhich satisfies $u_t = u_{xx} + \\kappa u$ and the given Dirichlet boundary conditions. The imposition of the Dirichlet boundary only in the diffusion substep causes the reaction substep to move the boundary nodes away from the prescribed values at $t_{n+1}$, inducing a consistency error localized at $\\partial\\Omega$.\n\nDefine the one-step local consistency error at node $i$ by\n$$\n\\mathcal{E}_i := u_i^{n+1} - u(x_i, t_{n+1}).\n$$\nYou are to:\n- Derive from first principles the leading-order behavior of $\\mathcal{E}_i$ at boundary versus interior nodes for the described scheme.\n- Implement a program that performs a single time step from $t_0=0$ to $t_1=\\Delta t$, starting from the exact initial data, applying the above splitting scheme, and computes:\n  - the maximum boundary-node error $\\max\\{|\\mathcal{E}_0|,|\\mathcal{E}_N|\\}$,\n  - the maximum interior-node error $\\max_{1\\le i\\le N-1} |\\mathcal{E}_i|$.\n- Return these two errors for each test case.\n\nThere are no physical units in this problem; all quantities are dimensionless. Numerical outputs must be real numbers. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is a two-element list $[\\text{boundary\\_error}, \\text{interior\\_error}]$ of Python floats.\n\nUse the following test suite, which probes different aspects of the boundary-localized consistency error:\n- Test 1 (baseline): $a=1.0$, $b=1.0$, $\\kappa=0.7$, $N=40$, $\\Delta t=10^{-2}$.\n- Test 2 (smaller time step): $a=1.0$, $b=1.0$, $\\kappa=0.7$, $N=40$, $\\Delta t=5\\times 10^{-3}$.\n- Test 3 (finer grid): $a=1.0$, $b=1.0$, $\\kappa=0.7$, $N=80$, $\\Delta t=10^{-2}$.\n- Test 4 (different amplitudes): $a=2.0$, $b=0.5$, $\\kappa=1.3$, $N=60$, $\\Delta t=2\\times 10^{-3}$.\n- Test 5 (edge case homogeneous right boundary): $a=1.0$, $b=0.0$, $\\kappa=0.7$, $N=40$, $\\Delta t=10^{-2}$.\n\nYour program should produce a single line of output of the form\n$$\n[\\,[E_b^{(1)},E_i^{(1)}],\\,[E_b^{(2)},E_i^{(2)}],\\,[E_b^{(3)},E_i^{(3)}],\\,[E_b^{(4)},E_i^{(4)}],\\,[E_b^{(5)},E_i^{(5)}]\\,],\n$$\nwhere $E_b^{(k)}$ and $E_i^{(k)}$ are the boundary and interior errors, respectively, for test case $k=1,\\dots,5$.",
            "solution": "The problem statement has been validated and is deemed a well-posed, scientifically grounded problem in numerical analysis. It requires the derivation of the local consistency error for a Lie splitting scheme applied to a linear reaction-diffusion equation and a numerical verification of the error behavior.\n\nThe core task is to analyze the one-step local consistency error, defined as $\\mathcal{E}_i := u_i^{n+1} - u(x_i, t_{n+1})$, where $u_i^{n+1}$ is the numerical solution after one step starting from the exact solution $u_i^n = u(x_i, t_n)$, and $u(x_i, t_{n+1})$ is the exact solution at the new time level. We perform the analysis for a single step from $t_n$ to $t_{n+1} = t_n + \\Delta t$.\n\n### Derivation of Local Consistency Error\n\nThe analysis must be performed separately for boundary nodes and interior nodes, as the numerical scheme treats them differently.\n\n#### Boundary Node Error\nLet's first analyze the error at the boundary nodes $i=0$ and $i=N$.\n\nAt the left boundary, $x_0 = 0$:\nThe prescribed boundary condition is $u(0,t) = g_0(t) = 0$.\nThe numerical scheme first sets the intermediate solution value to the exact boundary value at the new time $t_{n+1}$:\n$$ \\tilde{u}_0 = g_0(t_{n+1}) = 0 $$\nThe reaction substep then updates this value:\n$$ u_0^{n+1} = \\tilde{u}_0 + \\Delta t \\, \\kappa \\tilde{u}_0 = (1 + \\kappa \\Delta t) \\cdot 0 = 0 $$\nThe exact solution at this point is $u(x_0, t_{n+1}) = g_0(t_{n+1}) = 0$.\nThus, the local error at the left boundary is zero:\n$$ \\mathcal{E}_0 = u_0^{n+1} - u(x_0, t_{n+1}) = 0 - 0 = 0 $$\n\nAt the right boundary, $x_N = 1$:\nThe prescribed boundary condition is $u(1,t) = g_1(t) = b \\, e^{\\kappa t}$.\nThe diffusion substep sets the intermediate solution value:\n$$ \\tilde{u}_N = g_1(t_{n+1}) = b \\, e^{\\kappa t_{n+1}} $$\nThis value is exactly the correct boundary value at time $t_{n+1}$. However, the subsequent reaction substep modifies this value:\n$$ u_N^{n+1} = \\tilde{u}_N + \\Delta t \\, \\kappa \\tilde{u}_N = (1 + \\kappa \\Delta t) \\tilde{u}_N = (1 + \\kappa \\Delta t) g_1(t_{n+1}) $$\nThe exact solution at this node is $u(x_N, t_{n+1}) = g_1(t_{n+1})$.\nThe local error at the right boundary is therefore:\n$$ \\mathcal{E}_N = u_N^{n+1} - u(x_N, t_{n+1}) = (1 + \\kappa \\Delta t) g_1(t_{n+1}) - g_1(t_{n+1}) = \\kappa \\Delta t \\, g_1(t_{n+1}) $$\nFor the first step from $t_0=0$ to $t_1=\\Delta t$, this becomes $\\mathcal{E}_N = \\kappa \\Delta t \\, b \\, e^{\\kappa \\Delta t}$.\nThe leading-order term of the boundary error is $\\mathcal{E}_N = \\kappa b \\Delta t + O((\\Delta t)^2)$. This is a first-order error in $\\Delta t$, i.e., $\\mathcal{E}_N = O(\\Delta t)$. This error is introduced because the reaction operator is applied *after* the correct boundary condition has been enforced, corrupting the boundary value.\n\n#### Interior Node Error\nFor an interior node, $i=1, \\dots, N-1$, the numerical solution after one step is:\n$$ u_i^{n+1} = (1 + \\kappa \\Delta t) \\tilde{u}_i = (1 + \\kappa \\Delta t) (u_i^n + \\Delta t \\, \\Delta_h u_i^n) $$\nExpanding this, we get:\n$$ u_i^{n+1} = u_i^n + \\Delta t \\, \\Delta_h u_i^n + \\kappa \\Delta t u_i^n + \\kappa (\\Delta t)^2 \\Delta_h u_i^n $$\nStarting from the exact solution $u_i^n = u(x_i, t_n)$, we can replace the finite difference operator with its Taylor series expansion: $\\Delta_h u(x_i, t_n) = u_{xx}(x_i, t_n) + \\frac{h^2}{12}u_{xxxx}(x_i, t_n) + O(h^4)$. Substituting this into the numerical scheme gives:\n$$ u_i^{n+1} = u_i^n + \\Delta t \\left(u_{xx} + \\frac{h^2}{12}u_{xxxx} \\right) + \\kappa \\Delta t u_i^n + \\kappa (\\Delta t)^2 \\left(u_{xx} + O(h^2)\\right) + O(\\Delta t h^4) $$\nwhere all derivatives are evaluated at $(x_i, t_n)$. Rearranging terms:\n$$ u_i^{n+1} = u_i^n + \\Delta t (u_{xx} + \\kappa u_i^n) + \\frac{\\Delta t h^2}{12}u_{xxxx} + \\kappa (\\Delta t)^2 u_{xx} + O((\\Delta t)^2 h^2) $$\n\nNext, we expand the exact solution $u(x,t)$ in a Taylor series in time around $(x_i, t_n)$:\n$$ u(x_i, t_{n+1}) = u(x_i, t_n) + \\Delta t \\, u_t(x_i, t_n) + \\frac{(\\Delta t)^2}{2} u_{tt}(x_i, t_n) + O((\\Delta t)^3) $$\nUsing the PDE $u_t = u_{xx} + \\kappa u$, we can find higher time derivatives:\n$u_{tt} = \\frac{\\partial}{\\partial t}(u_{xx} + \\kappa u) = u_{xxt} + \\kappa u_t = (u_t)_{xx} + \\kappa u_t = (u_{xx} + \\kappa u)_{xx} + \\kappa(u_{xx} + \\kappa u) = u_{xxxx} + 2\\kappa u_{xx} + \\kappa^2 u$.\nSubstituting these into the Taylor expansion for $u(x_i, t_{n+1})$:\n$$ u(x_i, t_{n+1}) = u_i^n + \\Delta t (u_{xx} + \\kappa u_i^n) + \\frac{(\\Delta t)^2}{2} (u_{xxxx} + 2\\kappa u_{xx} + \\kappa^2 u_i^n) + O((\\Delta t)^3) $$\n\nThe local consistency error $\\mathcal{E}_i$ is the difference $u_i^{n+1} - u(x_i, t_{n+1})$:\n$$ \\mathcal{E}_i = \\left( \\frac{\\Delta t h^2}{12}u_{xxxx} + \\kappa (\\Delta t)^2 u_{xx} \\right) - \\left( \\frac{(\\Delta t)^2}{2} (u_{xxxx} + 2\\kappa u_{xx} + \\kappa^2 u_i^n) \\right) + \\text{h.o.t.} $$\n$$ \\mathcal{E}_i = \\frac{\\Delta t h^2}{12}u_{xxxx} - \\frac{(\\Delta t)^2}{2}u_{xxxx} - \\frac{(\\kappa \\Delta t)^2}{2}u_i^n + \\text{h.o.t.} $$\nThe leading-order terms for the interior error are $O(\\Delta t h^2)$ and $O((\\Delta t)^2)$. This error is of a higher order than the $O(\\Delta t)$ error observed at the boundary. This discrepancy, where the boundary error is of lower order than the interior error, is a known artifact of operator splitting schemes when time-dependent Dirichlet boundary conditions are naively imposed.\n\n### Numerical Implementation\nThe provided Python code implements the derived logic to compute the errors for the given test cases.\n1.  It iterates through each set of parameters $(a, b, \\kappa, N, \\Delta t)$.\n2.  A uniform spatial grid $x_i$ of size $N+1$ is constructed.\n3.  The initial condition $u^n$ at $t_n=0$ is set using the exact solution: $u_i^0 = a \\sin(\\pi x_i) + b x_i$.\n4.  A single time step is performed according to the Lie splitting scheme:\n    a. The diffusion substep calculates $\\tilde{u}_i = u_i^n + \\Delta t \\, \\Delta_h u_i^n$ for interior nodes.\n    b. The Dirichlet boundary values at $t_{n+1}=\\Delta t$ are imposed on the intermediate solution: $\\tilde{u}_0 = 0$ and $\\tilde{u}_N = b e^{\\kappa \\Delta t}$.\n    c. The reaction substep updates all nodes: $u_i^{n+1} = (1 + \\kappa \\Delta t)\\tilde{u}_i$.\n5.  The exact solution $u(x_i, \\Delta t)$ is computed for all nodes at time $t_1=\\Delta t$.\n6.  The local consistency error vector $\\mathcal{E}$ is found by subtracting the exact solution from the numerical solution, $\\mathcal{E}_i = u_i^{n+1} - u(x_i, \\Delta t)$.\n7.  Finally, the maximum absolute error at the boundary nodes, $\\max\\{|\\mathcal{E}_0|, |\\mathcal{E}_N|\\}$, and the maximum absolute error at the interior nodes, $\\max_{1\\le i\\le N-1} |\\mathcal{E}_i|$, are calculated and stored.\nThe results for all test cases are then formatted into a single line as specified.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the one-step local consistency error for a Lie splitting scheme\n    applied to a reaction-diffusion equation.\n    \"\"\"\n    \n    # Test cases: (a, b, kappa, N, dt)\n    test_cases = [\n        (1.0, 1.0, 0.7, 40, 1e-2),\n        (1.0, 1.0, 0.7, 40, 5e-3),\n        (1.0, 1.0, 0.7, 80, 1e-2),\n        (2.0, 0.5, 1.3, 60, 2e-3),\n        (1.0, 0.0, 0.7, 40, 1e-2),\n    ]\n\n    results = []\n\n    for a, b, kappa, N, dt in test_cases:\n        # Spatial-temporal parameters\n        h = 1.0 / N\n        x = np.linspace(0.0, 1.0, N + 1)\n        t_n = 0.0\n        t_np1 = dt\n\n        # Initial condition u^n = u(x, t_n=0)\n        u_n = a * np.sin(np.pi * x) + b * x\n        \n        # --- Lie splitting scheme for one step ---\n        \n        # 1. Diffusion substep (explicit Euler)\n        u_tilde = np.zeros(N + 1)\n        \n        # Update interior nodes\n        u_tilde_interior = u_n[1:-1] + (dt / h**2) * (u_n[2:] - 2 * u_n[1:-1] + u_n[:-2])\n        u_tilde[1:-1] = u_tilde_interior\n        \n        # Impose Dirichlet BCs at t_np1\n        g0_tnp1 = 0.0\n        g1_tnp1 = b * np.exp(kappa * t_np1)\n        u_tilde[0] = g0_tnp1\n        u_tilde[N] = g1_tnp1\n        \n        # 2. Reaction substep (explicit Euler)\n        u_np1 = u_tilde * (1.0 + kappa * dt)\n        \n        # --- Error Calculation ---\n        \n        # Exact solution at t_np1\n        term1 = a * np.exp((kappa - np.pi**2) * t_np1) * np.sin(np.pi * x)\n        term2 = b * np.exp(kappa * t_np1) * x\n        u_exact_tnp1 = term1 + term2\n        \n        # Local consistency error vector: E = u_numerical - u_exact\n        error_vec = u_np1 - u_exact_tnp1\n        \n        # Maximum boundary error\n        boundary_error = np.max(np.abs([error_vec[0], error_vec[N]]))\n        \n        # Maximum interior error\n        if N > 1:\n            interior_error = np.max(np.abs(error_vec[1:-1]))\n        else:\n            # Case with no interior points\n            interior_error = 0.0\n            \n        results.append((boundary_error, interior_error))\n\n    # Format and print the final result as a list of lists with no spaces\n    formatted_results = [f\"[{be},{ie}]\" for be, ie in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}