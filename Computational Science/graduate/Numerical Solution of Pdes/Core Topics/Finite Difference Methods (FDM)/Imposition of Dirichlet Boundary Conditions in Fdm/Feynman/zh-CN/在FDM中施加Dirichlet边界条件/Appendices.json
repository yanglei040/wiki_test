{
    "hands_on_practices": [
        {
            "introduction": "我们首先探索椭圆问题有限差分法的基本代数结构。这个练习将指导你使用舒尔补 (Schur complement) 来消去内部未知数，从而推导出离散的狄利克雷-诺伊曼 (Dirichlet-to-Neumann, DtN) 映射。理解这个映射至关重要，因为它封装了内部解对边界条件的完整响应，为理论分析和诸如区域分解等高级算法提供了强有力的工具。",
            "id": "3407312",
            "problem": "考虑在区间 $[0,L]$ 上的齐次 Laplace 偏微分方程 (PDE) $u''(x) = 0$，其端点上给定未知的 Dirichlet 边界数据。使用包含 $N+2$ 个点的均匀网格 $x_j = j h$ (其中 $h = \\frac{L}{N+1}$) 对区间 $[0,L]$ 进行离散化，边界节点索引为 $j = 0$ 和 $j = N+1$，内部节点索引为 $j = 1,2,\\dots,N$。令有限差分法 (FDM) 使用标准的中心二阶差分算子，使得内部场 $u_j$ 对所有 $j = 1,\\dots,N$ 满足 $u_{j-1} - 2 u_j + u_{j+1} = 0$。将 Dirichlet 边界数据记为向量 $u_b = \\begin{pmatrix} u_0 \\\\ u_{N+1} \\end{pmatrix}$，内部未知向量记为 $u_i = \\begin{pmatrix} u_1 \\\\ \\vdots \\\\ u_N \\end{pmatrix}$。定义端点处的离散外法向通量向量为 $q = \\begin{pmatrix} q_L \\\\ q_R \\end{pmatrix}$，其中在 $x=0$ 处 $q_L = -\\frac{u_1 - u_0}{h}$，在 $x=L$ 处 $q_R = \\frac{u_{N+1} - u_N}{h}$。\n\n从有限差分格式导出的分块结构线性系统出发，使用 Schur 补消去内部未知数 $u_i$，并表达离散的 Dirichlet-to-Neumann (Steklov) 映射 $S_h$，使得 $q = S_h\\, u_b$。在你的推导中，从离散 Laplace 算子和 Schur 补的定义开始，并证明每个代数步骤的合理性。然后，在使用带有多层分割排序的稀疏 Cholesky 分解时，分析在 $m \\times m$ 网格上（有 $(m-2)^2$ 个内部节点）为二维离散 Laplace 算子构造和应用 Schur 补的计算成本（用大$\\mathcal{O}$符号表示）。最后，通过描述你所推导的一维 $S_h$ 的对称性、(半)正定性以及零空间的存在与否，来讨论离散 Steklov 问题的稳定性，包括其非零特征值随 $h$ 和 $N$ 的变化关系。\n\n请给出 $2 \\times 2$ 矩阵 $S_h$ 关于 $N$ 和 $h$ 的显式闭式解析表达式作为最终答案。本题不要求进行数值取整。",
            "solution": "该问题要求推导和分析一维 Laplace 方程的离散 Dirichlet-to-Neumann (DtN) 映射，分析相关二维问题的计算成本，并对推导的一维 DtN 映射进行稳定性分析。\n\n### 第一部分：离散 DtN 映射 $S_h$ 的推导\n\n我们从区间 $[0, L]$ 上的偏微分方程 $u''(x) = 0$ 的有限差分离散化开始。该区域被离散化为 $N+2$ 个点 $x_j = j h$，$j=0, 1, \\dots, N+1$，其中 $h = L/(N+1)$。内部节点 $u_j$ ($j=1, \\dots, N$) 的控制方程由中心二阶差分公式给出：\n$$u_{j-1} - 2 u_j + u_{j+1} = 0$$\n通过将解向量划分为内部未知数 $u_i = (u_1, u_2, \\dots, u_N)^T$ 和边界值 $u_b = (u_0, u_{N+1})^T$，这组 $N$ 个线性方程可以写成分块矩阵形式。\n\n对于 $j=1$，我们有 $u_0 - 2u_1 + u_2 = 0$。\n对于 $j=2, \\dots, N-1$，我们有 $u_{j-1} - 2u_j + u_{j+1} = 0$。\n对于 $j=N$，我们有 $u_{N-1} - 2u_N + u_{N+1} = 0$。\n\n分离内部项和边界项，我们得到关于内部未知数 $u_i$ 的系统：\n$$\n\\begin{pmatrix}\n-2  & 1  & 0  & \\dots & 0 \\\\\n1  & -2  & 1  & \\dots & 0 \\\\\n0  & \\ddots & \\ddots & \\ddots & 0 \\\\\n0  & \\dots & 1  & -2 & 1 \\\\\n0  & \\dots & 0  & 1 & -2\n\\end{pmatrix}\n\\begin{pmatrix} u_1 \\\\ u_2 \\\\ \\vdots \\\\ u_{N-1} \\\\ u_N \\end{pmatrix}\n+\n\\begin{pmatrix}\nu_0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ u_{N+1}\n\\end{pmatrix}\n= \\begin{pmatrix} 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n这可以表示为紧凑的分块形式 $A_{ii} u_i + A_{ib} u_b = 0$，其中：\n$A_{ii}$ 是表示内部离散 Laplace 算子的 $N \\times N$ 对称三对角矩阵：\n$$A_{ii} = \\begin{pmatrix}\n-2 & 1   \\\\\n1 & -2 & 1  \\\\\n & \\ddots & \\ddots & \\ddots \\\\\n &  & 1 & -2 & 1 \\\\\n &   &  & 1 & -2\n\\end{pmatrix}$$\n$A_{ib}$ 是将内部与边界耦合的 $N \\times 2$ 矩阵：\n$$A_{ib} = \\begin{pmatrix}\n1 & 0 \\\\\n0 & 0 \\\\\n\\vdots & \\vdots \\\\\n0 & 0 \\\\\n0 & 1\n\\end{pmatrix} = \\begin{pmatrix} e_1 & e_N \\end{pmatrix}$$\n其中 $e_j$ 是 $\\mathbb{R}^N$ 中的第 $j$ 个标准基向量。\n\n为了消去内部未知数 $u_i$，我们用边界数据 $u_b$ 来表示它们：\n$$u_i = -A_{ii}^{-1} A_{ib} u_b$$\n接下来，我们用 $u_i$ 和 $u_b$ 表示离散外法向通量向量 $q = (q_L, q_R)^T$。通量定义为 $q_L = -\\frac{u_1 - u_0}{h}$ 和 $q_R = \\frac{u_{N+1} - u_N}{h}$。其矩阵形式为：\n$$q = \\frac{1}{h}\\begin{pmatrix} u_0 - u_1 \\\\ u_{N+1} - u_N \\end{pmatrix} = \\frac{1}{h}\\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}u_b + \\frac{1}{h}\\begin{pmatrix} -1 & 0 & \\dots & 0 \\\\ 0 & \\dots & 0 & -1 \\end{pmatrix}u_i$$\n这对应于分块形式 $q = C u_b + B u_i$，其中：\n$$C = \\frac{1}{h}I_2 \\quad \\text{和} \\quad B = \\frac{1}{h}\\begin{pmatrix} -e_1^T \\\\ -e_N^T \\end{pmatrix}$$\n将 $u_i$ 的表达式代入 $q$ 的方程，得到 DtN 映射 $S_h$：\n$$q = C u_b + B(-A_{ii}^{-1} A_{ib} u_b) = (C - B A_{ii}^{-1} A_{ib}) u_b$$\n因此，作为系统 Schur 补的 DtN 映射为 $S_h = C - B A_{ii}^{-1} A_{ib}$。\n\n为了找到 $S_h$ 的显式表达式，我们需要 $A_{ii}$ 的逆。这个特定三对角矩阵的逆有解析解：\n$$(A_{ii}^{-1})_{jk} = -\\frac{1}{N+1} \\min(j,k)(N+1-\\max(j,k)) = -\\frac{1}{N+1} \\begin{cases} j(N+1-k) & \\text{if } j \\le k \\\\ k(N+1-j) & \\text{if } j > k \\end{cases}$$\n我们首先计算矩阵乘积 $B A_{ii}^{-1} A_{ib}$：\n$$B A_{ii}^{-1} A_{ib} = \\left( \\frac{1}{h}\\begin{pmatrix} -e_1^T \\\\ -e_N^T \\end{pmatrix} \\right) A_{ii}^{-1} \\begin{pmatrix} e_1 & e_N \\end{pmatrix} = \\frac{1}{h} \\begin{pmatrix} -e_1^T A_{ii}^{-1} e_1 & -e_1^T A_{ii}^{-1} e_N \\\\ -e_N^T A_{ii}^{-1} e_1 & -e_N^T A_{ii}^{-1} e_N \\end{pmatrix}$$\n使用 $A_{ii}^{-1}$ 的公式计算各项：\n$e_1^T A_{ii}^{-1} e_1 = (A_{ii}^{-1})_{11} = -\\frac{1(N+1-1)}{N+1} = -\\frac{N}{N+1}$\n$e_1^T A_{ii}^{-1} e_N = (A_{ii}^{-1})_{1N} = -\\frac{1(N+1-N)}{N+1} = -\\frac{1}{N+1}$\n$e_N^T A_{ii}^{-1} e_1 = (A_{ii}^{-1})_{N1} = -\\frac{1(N+1-N)}{N+1} = -\\frac{1}{N+1}$\n$e_N^T A_{ii}^{-1} e_N = (A_{ii}^{-1})_{NN} = -\\frac{N(N+1-N)}{N+1} = -\\frac{N}{N+1}$\n将这些结果代回乘积的表达式中：\n$$B A_{ii}^{-1} A_{ib} = \\frac{1}{h} \\begin{pmatrix} -(-\\frac{N}{N+1}) & -(-\\frac{1}{N+1}) \\\\ -(-\\frac{1}{N+1}) & -(-\\frac{N}{N+1}) \\end{pmatrix} = \\frac{1}{h(N+1)}\\begin{pmatrix} N & 1 \\\\ 1 & N \\end{pmatrix}$$\n最后，我们计算 $S_h$：\n$$S_h = C - B A_{ii}^{-1} A_{ib} = \\frac{1}{h}\\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} - \\frac{1}{h(N+1)}\\begin{pmatrix} N & 1 \\\\ 1 & N \\end{pmatrix}$$\n$$S_h = \\frac{1}{h(N+1)}\\begin{pmatrix} N+1 & 0 \\\\ 0 & N+1 \\end{pmatrix} - \\frac{1}{h(N+1)}\\begin{pmatrix} N & 1 \\\\ 1 & N \\end{pmatrix}$$\n$$S_h = \\frac{1}{h(N+1)}\\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$$\n这是 $2 \\times 2$ 矩阵 $S_h$ 的显式形式。值得注意的是，由于 $h=L/(N+1)$，我们有 $L=h(N+1)$。因此，$S_h = \\frac{1}{L}\\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$，这与连续问题 $u''(x)=0$ 的 DtN 映射完全相同。这是因为中心差分格式对于作为一维 Laplace 方程解的线性函数是精确的。\n\n### 第二部分：二维情况下的计算成本\n\n对于 $m \\times m$ 网格上的二维离散 Laplace 算子，内部节点数为 $M = (m-2)^2$。问题是要求在使用带有多层分割排序的稀疏 Cholesky 分解时，构造和应用 Schur 补 $S = A_{bb} - A_{bi} A_{ii}^{-1} A_{ib}$ 的成本。内部矩阵 $A_{ii}$ 的维度是 $M \\times M$。\n边界节点数为 $N_b = m^2 - (m-2)^2 = 4m-4 = \\mathcal{O}(m)$。\n\n**构造 $S$ 的成本：**\n构造 $S$ 包括三个主要步骤：\n1.  **$A_{ii}$ 的分解**：对于一个有 $M$ 个顶点的二维网格图，多层分割算法提供的稀疏 Cholesky 分解 $A_{ii} = LL^T$ 的计算成本（浮点运算次数）为 $\\mathcal{O}(M^{3/2})$。代入 $M=\\mathcal{O}(m^2)$，成本为 $\\mathcal{O}((m^2)^{3/2}) = \\mathcal{O}(m^3)$。\n2.  **求解 $X = A_{ii}^{-1} A_{ib}$**：这涉及为 $A_{ib}$ 的 $N_b = \\mathcal{O}(m)$ 个列中的每一列求解一个系统 $A_{ii}x = c$。使用多层分割得到的稀疏因子 $L$ 进行单次求解（前向/后向替换）的成本是 $\\mathcal{O}(M \\log M)$。当 $M=\\mathcal{O}(m^2)$ 时，单次求解的成本为 $\\mathcal{O}(m^2 \\log m)$。对所有 $N_b$ 列执行此操作的总成本为 $N_b \\times \\mathcal{O}(m^2 \\log m) = \\mathcal{O}(m) \\times \\mathcal{O}(m^2 \\log m) = \\mathcal{O}(m^3 \\log m)$。\n3.  **矩阵乘法**：计算 $A_{bi}X$ 的成本由前面的步骤主导。矩阵 $X$ 是大小为 $M \\times N_b$ 的稠密矩阵，但 $A_{bi}$ 是稀疏的，有 $\\mathcal{O}(m)$ 个非零元。\n\n构造稠密 Schur 补矩阵 $S$ 的总成本主要由多次求解决定，其复杂度为 $\\mathcal{O}(m^3 \\log m)$。\n\n**应用 $S$ 的成本：**\n一旦矩阵 $S$ 被显式构造出来，它就是一个稠密的 $N_b \\times N_b$ 矩阵，其中 $N_b = \\mathcal{O}(m)$。将 $S$ 应用于边界向量 $u_b$ 对应于矩阵-向量乘积 $S u_b$。其成本为 $\\mathcal{O}(N_b^2) = \\mathcal{O}((4m-4)^2) = \\mathcal{O}(m^2)$。\n\n### 第三部分：一维 $S_h$ 的稳定性分析\n\n我们分析 $S_h = \\frac{1}{L} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$ 的性质。\n\n**对称性**：该矩阵是对称的，因为 $(S_h)_{12} = (S_h)_{21} = -1/L$。也就是说，$S_h = S_h^T$。这是预料之中的，因为算子是自伴的，并且所用的离散化也是对称的。\n\n**定性与零空间**：我们考察二次型 $u_b^T S_h u_b$，其中 $u_b = (u_0, u_{N+1})^T$：\n$$u_b^T S_h u_b = \\frac{1}{L} \\begin{pmatrix} u_0 & u_{N+1} \\end{pmatrix} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} \\begin{pmatrix} u_0 \\\\ u_{N+1} \\end{pmatrix} = \\frac{1}{L} (u_0 - u_{N+1})^2$$\n由于 $L > 0$，对所有 $u_b$ 都有 $u_b^T S_h u_b \\ge 0$。因此，$S_h$ 是半正定的。它不是正定的，因为当 $u_0 = u_{N+1}$ 时，对于非零向量，二次型为零。\n$S_h$ 的零空间由满足 $S_h u_b = 0$ 的向量 $u_b$ 组成。这个条件得出 $u_0 - u_{N+1} = 0$，即 $u_0 = u_{N+1}$。零空间由向量 $\\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$ 张成。在物理上，这对应于一个常数边界条件，$u(0)=u(L)$，对于问题 $u''(x)=0$，这意味着一个常数解 $u(x)=c$。常数解的导数为零，因此在边界处的通量为零，这与 $q=S_h u_b=0$ 一致。\n\n**特征值与缩放关系**：我们通过求解 $\\det(S_h - \\lambda I) = 0$ 来找到特征值 $\\lambda$：\n$$\\det \\begin{pmatrix} \\frac{1}{L} - \\lambda & -\\frac{1}{L} \\\\ -\\frac{1}{L} & \\frac{1}{L} - \\lambda \\end{pmatrix} = \\left(\\frac{1}{L} - \\lambda\\right)^2 - \\left(\\frac{1}{L}\\right)^2 = 0$$\n这得出 $(\\frac{1}{L} - \\lambda) = \\pm \\frac{1}{L}$，从而得到特征值 $\\lambda_1 = 0$ 和 $\\lambda_2 = \\frac{2}{L}$。\n零特征值对应于零空间。非零特征值是 $\\lambda_2 = \\frac{2}{L}$。由于我们已经确定，对于固定的域长度 $L$，$S_h$ 与离散化参数 $h$ 和 $N$ 无关，因此其非零特征值也是一个常数 $\\frac{2}{L}$。所以，非零特征值相对于 $h$ 和 $N$ 的缩放关系是 $\\mathcal{O}(1)$。",
            "answer": "$$\n\\boxed{\\frac{1}{h(N+1)} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "现实世界的问题通常涉及带有噪声或不一致的边界数据。本实践通过展示如何处理椭圆偏微分方程的这类“不适定”狄利克雷数据，来应对这一实际挑战。你将实现一个吉洪诺夫 (Tikhonov) 正则化方案，在将边界测量值施加到有限差分求解器之前对其进行“清洗”，从而展示在面对不完美数据时如何保持解的准确性。",
            "id": "3407296",
            "problem": "考虑单位正方形 $\\Omega = (0,1)^2$ 上的偏微分方程 (PDE) $-\\Delta u = f$ 的椭圆边界值问题，其服从 Dirichlet 边界条件 $u|_{\\partial \\Omega} = g$。在许多实际应用中，测量的边界数据 $g$ 是含噪声的，或者在角点处相互不一致，并且可能与内部强迫项 $f$ 不相容，即它们不对应于给定 $f$ 的 PDE 的任何足够光滑解的迹。在使用有限差分法 (FDM) 时，这会严重降低数值解的精度。您的任务是实现一个有限差分求解器，该求解器在通过沿离散边界曲线执行 Tikhonov 滤波对含噪声的边界数据 $g$ 进行正则化之后，施加 Dirichlet 边界条件。\n\n您必须按以下步骤进行。\n\n1) 对于 $N = 64$，使用一个 $N+1$ 乘 $N+1$ 个点的均匀网格来离散化 $\\Omega$，网格宽度为 $h = 1/N$。对内部网格点上的算子 $-\\Delta$ 使用标准的五点差分格式 FDM，并通过消去边界未知数来强制执行 Dirichlet 边界条件，这将得到一个针对内部网格值的线性系统，其右端项包含了边界值的贡献。\n\n2) 选择精确解 $u^\\star(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$，这意味着\n$$\nf(x,y) = -\\Delta u^\\star(x,y) = 8\\pi^2 \\sin(2\\pi x)\\sin(2\\pi y),\n$$\n并且精确的边界迹恒为零，即 $u^\\star|_{\\partial\\Omega} \\equiv 0$。\n\n3) 构造边界节点的离散排序，作为一个长度为 $4N$ 的单个周期性循环，按此顺序枚举且不重复角点：沿着底边从 $(i,j)=(0,0)$到$(N-1,0)$，然后是右边从 $(N,0)$到$(N,N-1)$，接着是顶边从 $(N,N)$到$(1,N)$，最后是左边从 $(0,N)$到$(0,1)$。令向量 $y \\in \\mathbb{R}^{4N}$ 表示按此边界顺序排列的测量 Dirichlet 数据。\n\n4) 通过向每个边界节点添加幅值为 $\\sigma$ 的独立高斯噪声，并在对应于角点 $(0,0)$ 的第一个边界索引处添加一个大小为 $\\delta$ 的单个异常值，来为不适定的测量边界数据 $y$ 建模。噪声必须由种子为 $314159$ 的固定正态序列生成，以便结果是可复现的。具体来说，$y = \\sigma z + \\delta e_1$，其中 $z \\sim \\mathcal{N}(0, I)$ 由种子固定，而 $e_1$ 是第一个标准基向量。\n\n5) 通过求解闭合边界循环上的一维 Tikhonov 平滑问题来对测量的边界数据进行正则化：\n$$\ng_\\alpha = \\arg\\min_{g \\in \\mathbb{R}^{4N}} \\left\\{ \\lVert g - y \\rVert_2^2 + \\alpha \\lVert D g \\rVert_2^2 \\right\\},\n$$\n其中 $D \\in \\mathbb{R}^{4N \\times 4N}$ 是循环二阶差分算子，它离散化了沿边界顺序的二阶导数，并具有周期性包裹：\n$$\n(D g)_k = g_{k+1} - 2 g_k + g_{k-1} \\quad \\text{对于所有 } k \\text{，索引模 } 4N。\n$$\n证明极小值点满足正规方程\n$$\n(I + \\alpha D^\\top D) g_\\alpha = y.\n$$\n在 FDM 系统中，使用 $g_\\alpha$作为施加的 Dirichlet 边界值。\n\n6) 对于下面的每个测试案例，使用五点差分格式为内部节点组装 FDM 线性系统，通过 $g_\\alpha$ 在所有边界节点（包括角点）上整合 Dirichlet 边界，求解线性系统，重构整个网格上的解（内部加边界），并报告相对于 $u^\\star$ 在整个网格上的离散 $L^2$ 误差：\n$$\nE = \\left( h^2 \\sum_{i=0}^N \\sum_{j=0}^N \\left( u_{i,j} - u^\\star(x_i,y_j) \\right)^2 \\right)^{1/2},\n$$\n其中 $x_i = i h$ 且 $y_j = j h$。\n\n测试套件：\n- 案例 1：$\\alpha = 0$, $\\sigma = 0.02$, $\\delta = 0.5$。\n- 案例 2：$\\alpha = 10^{-4}$, $\\sigma = 0.02$, $\\delta = 0.5$。\n- 案例 3：$\\alpha = 10^{-2}$, $\\sigma = 0.02$, $\\delta = 0.5$。\n- 案例 4：$\\alpha = 1$, $\\sigma = 0.02$, $\\delta = 0.5$。\n- 案例 5（基准，一致数据）：$\\alpha = 0$, $\\sigma = 0$, $\\delta = 0$。\n\n所有量都是无量纲的，因此没有物理单位适用。\n\n您的程序必须生成单行输出，其中包含按测试案例顺序排列的结果，形式为逗号分隔的列表，并用方括号括起来，即 $[E_1,E_2,E_3,E_4,E_5]$，其中每个 $E_k$ 是相应案例的离散 $L^2$ 误差。",
            "solution": "### 1. 问题表述\n该问题要求在单位正方形 $\\Omega = (0,1)^2$ 上对带有 Dirichlet 边界条件的二维泊松方程进行数值求解：\n$$\n-\\Delta u = f \\quad \\text{in } \\Omega\n$$\n$$\nu|_{\\partial \\Omega} = g\n$$\n核心挑战在于处理含噪声和不一致的边界数据 $g$。所提出的方法包括在将边界数据 $g$ 纳入有限差分格式之前对其进行正则化。精确解 $u^\\star(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$ 用于定义强迫函数 $f(x,y) = -\\Delta u^\\star = 8\\pi^2 \\sin(2\\pi x)\\sin(2\\pi y)$ 并评估数值解的精度。与 $u^\\star$ 对应的精确边界数据是 $u^\\star|_{\\partial\\Omega} \\equiv 0$。\n\n### 2. 离散化与有限差分法 (FDM)\n区域 $\\Omega$ 使用一个在每个方向上有 $N+1$ 个点的均匀网格进行离散化，其中 $N=64$。网格点为 $(x_i, y_j) = (ih, jh)$，对于 $i,j \\in \\{0, 1, \\dots, N\\}$，网格间距为 $h=1/N$。令 $u_{i,j}$ 表示 $u(x_i, y_j)$ 的数值近似。\n\n负拉普拉斯算子 $-\\Delta$ 在每个内部网格点 $(x_i,y_j)$（对于 $i,j \\in \\{1, \\dots, N-1\\}$）处，使用标准的五点差分格式进行近似：\n$$\n-\\Delta u(x_i, y_j) \\approx \\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2}\n$$\n将此近似式与强迫函数 $f(x_i, y_j)$ 相等，可得到一个关于 $(N-1)^2$ 个内部未知值的线性方程组：\n$$\n4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} = h^2 f_{i,j}\n$$\n边界上（其中 $i=0$、$i=N$、$j=0$ 或 $j=N$）$u$ 的值由 Dirichlet 条件给出。\n\n### 3. 边界数据的正则化\n测量的边界数据被建模为一个向量 $y \\in \\mathbb{R}^{4N}$，对应于 $4N$ 个边界节点的特定排序。该数据被人为地加入了幅值为 $\\sigma$ 的高斯噪声和一个大小为 $\\delta$ 的角点异常值：$y = \\sigma z + \\delta e_1$，其中 $z \\sim \\mathcal{N}(0, I)$ 且 $e_1$ 是第一个标准基向量。\n\n为了对这个含噪声的数据进行正则化，我们求解 Tikhonov 最小化问题：\n$$\ng_\\alpha = \\arg\\min_{g \\in \\mathbb{R}^{4N}} J(g), \\quad \\text{其中 } J(g) = \\lVert g - y \\rVert_2^2 + \\alpha \\lVert D g \\rVert_2^2\n$$\n此处，$\\alpha \\ge 0$ 是正则化参数。算子 $D \\in \\mathbb{R}^{4N \\times 4N}$ 是循环二阶差分矩阵，它近似了沿边界的二阶导数。对于一个向量 $g$，$(Dg)_k = g_{k+1} - 2g_k + g_{k-1}$，索引以 $4N$ 为模。\n\n目标泛函 $J(g)$ 是二次凸函数。其最小值可以通过将其关于 $g$ 的梯度设置为零来找到。该泛函可以用向量形式写为：\n$$\nJ(g) = (g-y)^\\top(g-y) + \\alpha (Dg)^\\top(Dg) = g^\\top g - 2y^\\top g + y^\\top y + \\alpha g^\\top D^\\top D g\n$$\n关于 $g$ 的梯度是：\n$$\n\\nabla_g J(g) = 2g - 2y + 2\\alpha D^\\top D g\n$$\n令 $\\nabla_g J(g) = 0$ 可得到正则化数据 $g_\\alpha$ 的正规方程：\n$$\n(I + \\alpha D^\\top D) g_\\alpha = y\n$$\n其中 $I$ 是 $4N \\times 4N$ 的单位矩阵。这是一个可以求解 $g_\\alpha$ 的线性系统。对于 $\\alpha=0$，解就是 $g_0 = y$，意味着没有应用正则化。对于 $\\alpha > 0$，矩阵 $I + \\alpha D^\\top D$ 是对称正定的，保证了唯一解的存在。\n\n### 4. 组装与求解完整系统\n求解过程是顺序的：\n1.  **求解边界数据**：对于每个测试案例 $(\\alpha, \\sigma, \\delta)$，构建噪声向量 $y$ 并求解 Tikhonov 系统 $(I + \\alpha D^\\top D) g_\\alpha = y$ 以获得正则化的边界值 $g_\\alpha$。\n\n2.  **求解内部解**：将内部节点的 FDM 方程重排，形成一个大型线性系统 $A_{pde} u_{int} = b_{pde}$。\n    *   未知数向量 $u_{int} \\in \\mathbb{R}^{(M)}$（其中 $M=(N-1)^2$）包含 $u_{i,j}$ 的值（对于 $i,j \\in \\{1,\\dots,N-1\\}$），按行优先排序。\n    *   矩阵 $A_{pde}$ 是一个 $M \\times M$ 的稀疏、块三对角矩阵，表示内部网格上的离散负拉普拉斯算子。它与边界数据无关。\n    *   右端向量 $b_{pde}$ 既包含了强迫项 $f$ 也包含了边界条件。对于一个内部节点 $(i,j)$， $b_{pde}$ 中对应的项是 $h^2 f_{i,j}$ 加上任何 $u_{i',j'}$ 项，其中 $(i',j')$ 是一个相邻的边界节点。这些边界项的值取自计算出的 $g_\\alpha$。例如，对于内部节点 $(1,1)$，方程是 $4u_{1,1} - u_{2,1} - u_{1,2} = h^2f_{1,1} + u_{0,1} + u_{1,0}$，其中 $u_{0,1}$ 和 $u_{1,0}$ 是正则化边界数据 $g_\\alpha$ 的分量。\n\n这个 FDM 系统被求解以获得内部值 $u_{int}$。\n\n### 5. 解的重构与误差评估\n最终的数值解 $U$ 是通过将计算出的内部值 $u_{int}$ 与正则化的边界值 $g_\\alpha$ 相结合，在完整的 $(N+1) \\times (N+1)$ 网格上重构出来的。\n\n该解 $U$ 的精度是通过与在网格上采样的精确解 $U^\\star_{i,j} = u^\\star(x_i, y_j) = \\sin(2\\pi x_i) \\sin(2\\pi y_j)$ 进行比较来衡量的。误差使用离散 $L^2$-范数计算，该范数考虑了所有网格点（包括边界）的贡献：\n$$\nE = \\left( h^2 \\sum_{i=0}^N \\sum_{j=0}^N \\left( u_{i,j} - u^\\star_{i,j} \\right)^2 \\right)^{1/2} = h \\left\\lVert U - U^\\star \\right\\rVert_F\n$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示 Frobenius 范数。将为每个测试案例计算此误差度量。",
            "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the Poisson equation on a unit square with noisy Dirichlet boundary data,\n    regularized using Tikhonov filtering.\n    \"\"\"\n    N = 64\n    h = 1.0 / N\n\n    test_cases = [\n        # (alpha, sigma, delta)\n        (0.0, 0.02, 0.5),\n        (1e-4, 0.02, 0.5),\n        (1e-2, 0.02, 0.5),\n        (1.0, 0.02, 0.5),\n        (0.0, 0.0, 0.0),\n    ]\n\n    # --- Pre-computation Step ---\n\n    # 1. Define boundary node ordering: map linear index k to (i, j) coordinates\n    boundary_map = np.zeros((4 * N, 2), dtype=int)\n    # Bottom edge: (0,0) to (N-1,0)\n    k_range = np.arange(N)\n    boundary_map[k_range, 0] = k_range\n    boundary_map[k_range, 1] = 0\n    # Right edge: (N,0) to (N,N-1)\n    k_range = np.arange(N, 2 * N)\n    boundary_map[k_range, 0] = N\n    boundary_map[k_range, 1] = k_range - N\n    # Top edge: (N,N) to (1,N)\n    k_range = np.arange(2 * N, 3 * N)\n    boundary_map[k_range, 0] = N - (k_range - 2 * N)\n    boundary_map[k_range, 1] = N\n    # Left edge: (0,N) to (0,1)\n    k_range = np.arange(3 * N, 4 * N)\n    boundary_map[k_range, 0] = 0\n    boundary_map[k_range, 1] = N - (k_range - 3 * N)\n\n    # 2. Generate the fixed Gaussian noise vector\n    rng = np.random.default_rng(314159)\n    z = rng.normal(0, 1, 4 * N)\n    \n    # 3. Construct Tikhonov regularization operator D\n    diag_D = np.ones(4 * N)\n    D = sparse.diags([-2 * diag_D, diag_D, diag_D], [0, 1, -1], format='csc')\n    D[0, -1] = 1\n    D[-1, 0] = 1\n    DtD = D.T @ D\n\n    # 4. Construct FDM matrix for interior nodes (scaled by h^2)\n    M = N - 1\n    n_unknowns = M * M\n    \n    # Using sparse.kron for a clean construction\n    T_M = sparse.diags([4, -1, -1], [0, -1, 1], shape=(M, M), format='csc')\n    I_M = sparse.identity(M, format='csc')\n    A_offdiag_kron = sparse.diags([-1, -1], [-1, 1], shape=(M, M), format='csc')\n    \n    A_pde = sparse.kron(I_M, T_M) + sparse.kron(A_offdiag_kron, sparse.identity(M, format='csc'))\n\n\n    # --- Main Loop for Test Cases ---\n    results = []\n    for alpha, sigma, delta in test_cases:\n        # a. Construct noisy boundary data y\n        e1 = np.zeros(4 * N)\n        e1[0] = 1.0\n        y = sigma * z + delta * e1\n\n        # b. Solve for regularized boundary data g_alpha\n        if alpha == 0.0:\n            g_alpha = y\n        else:\n            A_reg = sparse.identity(4 * N, format='csc') + alpha * DtD\n            g_alpha = spsolve(A_reg, y)\n\n        # c. Place g_alpha onto the boundary of a grid\n        U_b = np.zeros((N + 1, N + 1))\n        for k in range(4 * N):\n            i, j = boundary_map[k]\n            U_b[i, j] = g_alpha[k]\n        \n        # d. Construct the FDM right-hand-side vector b\n        x = np.linspace(0, 1, N + 1)\n        \n        # Using [:, None] and [None, :] for broadcasting\n        f_grid = 8 * (np.pi**2) * np.sin(2 * np.pi * x[:, None]) * np.sin(2 * np.pi * x[None, :])\n        \n        b_pde_vec = np.zeros(n_unknowns)\n        for j_int in range(M):\n            for i_int in range(M):\n                i, j = i_int + 1, j_int + 1\n                k_vec = j_int * M + i_int\n                \n                rhs_val = h**2 * f_grid[i, j]\n                if i == 1: rhs_val += U_b[0, j]\n                if i == N - 1: rhs_val += U_b[N, j]\n                if j == 1: rhs_val += U_b[i, 0]\n                if j == N - 1: rhs_val += U_b[i, N]\n                \n                b_pde_vec[k_vec] = rhs_val\n\n        # e. Solve for interior values u_int\n        u_int_vec = spsolve(A_pde, b_pde_vec)\n        \n        # f. Reconstruct the full solution U\n        U_sol = np.copy(U_b)\n        U_sol[1:N, 1:N] = u_int_vec.reshape((M, M), order='F')\n\n        # g. Calculate the discrete L2 error\n        U_exact = np.sin(2 * np.pi * x[:, None]) * np.sin(2 * np.pi * x[None, :])\n        error_matrix = U_sol - U_exact\n        L2_error = h * np.linalg.norm(error_matrix)\n        results.append(L2_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.6g}' for err in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从静态问题转向瞬态问题，在施加边界条件方面引入了新的微妙之处。本练习研究了算子分裂（或时间分裂）格式，这是一种处理复杂演化偏微分方程的常用技术。你将分析并验证，仅在其中一个子步骤中简单地施加狄利克雷条件，会如何导致在边界处产生显著的、局部的精度损失——这是开发稳健时间积分格式时的一个关键考量。",
            "id": "3407301",
            "problem": "考虑在单位区间域 $\\Omega=(0,1)$ 上，时间 $t\\ge 0$ 的线性反应扩散偏微分方程：\n$$\nu_t = \\Delta u + R(u),\n$$\n其中 $R(u)$ 是一个反应算子。假设对于所有 $t\\ge 0$，都规定了狄利克雷边界条件 $u(0,t)=g_0(t)$ 和 $u(1,t)=g_1(t)$。本问题的重点是，在时间分裂（算子分裂）格式中，当边界条件仅在其中一个子步骤中施加时，如何处理狄利克雷边界条件，并分析由此产生的局限于边界 $\\partial\\Omega$ 的相容性误差。\n\n我们仅限于一维情况，采用一个包含 $N+1$ 个网格点 $x_i = i h$（$i=0,1,\\dots,N$）的均匀空间网格，步长为 $h=1/N$，并使用拉普拉斯算子的标准二阶中心有限差分近似：\n$$\n\\Delta_h u_i := \\frac{u_{i+1} - 2 u_i + u_{i-1}}{h^2}, \\quad i=1,\\dots,N-1.\n$$\n我们采用时间步长为 $\\Delta t$ 的显式欧拉时间积分和李分裂方法，其中扩散子步之后是反应子步。狄利克雷边界条件仅在扩散子步中施加。具体来说，对于从 $t_n$ 到 $t_{n+1}=t_n+\\Delta t$ 的单个时间步，格式如下：\n1. 扩散子步：对于内部节点 $i=1,\\dots,N-1$，\n$$\n\\tilde{u}_i = u_i^n + \\Delta t \\, \\Delta_h u_i^n,\n$$\n并在此子步结束时施加狄利克雷边界条件：\n$$\n\\tilde{u}_0 = g_0(t_{n+1}), \\quad \\tilde{u}_N = g_1(t_{n+1}).\n$$\n2. 反应子步：对于所有节点 $i=0,1,\\dots,N$，\n$$\nu_i^{n+1} = \\tilde{u}_i + \\Delta t \\, R(\\tilde{u}_i),\n$$\n在此子步之后不再重新施加狄利克雷边界条件。\n\n为了使分析具体且可测试，我们考虑 $R(u) = \\kappa u$，其中 $\\kappa>0$ 为常数，并选择边界数据和初始条件，使得存在一个闭式精确解：\n- 狄利克雷边界数据 $g_0(t) = 0$ 和 $g_1(t) = b \\, e^{\\kappa t}$，其中常数 $b>0$。\n- 初始条件\n$$\nu(x,0) = a \\sin(\\pi x) + b x,\n$$\n其中常数 $a,b>0$。\n\n对于此配置，连续问题的精确解为\n$$\nu(x,t) = a \\, e^{(\\kappa - \\pi^2)t} \\sin(\\pi x) + b \\, e^{\\kappa t} \\, x,\n$$\n该解满足 $u_t = u_{xx} + \\kappa u$ 和给定的狄利克雷边界条件。仅在扩散子步中施加狄利克雷边界条件会导致反应子步使边界节点的值偏离 $t_{n+1}$ 时刻的规定值，从而在 $\\partial\\Omega$ 处引入局部的相容性误差。\n\n定义节点 $i$ 处的单步局部相容性误差为\n$$\n\\mathcal{E}_i := u_i^{n+1} - u(x_i, t_{n+1}).\n$$\n你需要：\n- 从第一性原理出发，推导所述格式在边界节点与内部节点上 $\\mathcal{E}_i$ 的主阶行为。\n- 实现一个程序，该程序从 $t_0=0$ 到 $t_1=\\Delta t$ 执行单个时间步，从精确的初始数据开始，应用上述分裂格式，并计算：\n  - 最大边界节点误差 $\\max\\{|\\mathcal{E}_0|,|\\mathcal{E}_N|\\}$，\n  - 最大内部节点误差 $\\max_{1\\le i\\le N-1} |\\mathcal{E}_i|$。\n- 为每个测试用例返回这两个误差。\n\n此问题中没有物理单位；所有量纲均为无量纲。数值输出必须是实数。你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，并且是一个形如 $[\\text{boundary\\_error}, \\text{interior\\_error}]$ 的包含两个 Python 浮点数的列表。\n\n使用以下测试套件，它探测了边界局部相容性误差的不同方面：\n- 测试 1 (基准): $a=1.0$, $b=1.0$, $\\kappa=0.7$, $N=40$, $\\Delta t=10^{-2}$。\n- 测试 2 (更小的时间步): $a=1.0$, $b=1.0$, $\\kappa=0.7$, $N=40$, $\\Delta t=5\\times 10^{-3}$。\n- 测试 3 (更精细的网格): $a=1.0$, $b=1.0$, $\\kappa=0.7$, $N=80$, $\\Delta t=10^{-2}$。\n- 测试 4 (不同的振幅): $a=2.0$, $b=0.5$, $\\kappa=1.3$, $N=60$, $\\Delta t=2\\times 10^{-3}$。\n- 测试 5 (右边界为齐次的边缘情况): $a=1.0$, $b=0.0$, $\\kappa=0.7$, $N=40$, $\\Delta t=10^{-2}$。\n\n你的程序应生成单行输出，格式如下：\n$$\n[\\,[E_b^{(1)},E_i^{(1)}],\\,[E_b^{(2)},E_i^{(2)}],\\,[E_b^{(3)},E_i^{(3)}],\\,[E_b^{(4)},E_i^{(4)}],\\,[E_b^{(5)},E_i^{(5)}]\\,],\n$$\n其中 $E_b^{(k)}$ 和 $E_i^{(k)}$ 分别是测试用例 $k=1,\\dots,5$ 的边界误差和内部误差。",
            "solution": "核心任务是分析单步局部相容性误差，定义为 $\\mathcal{E}_i := u_i^{n+1} - u(x_i, t_{n+1})$，其中 $u_i^{n+1}$ 是从精确解 $u_i^n = u(x_i, t_n)$ 开始经过一个步骤后的数值解，而 $u(x_i, t_{n+1})$ 是新时间层上的精确解。我们对从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个步骤进行分析。\n\n### 局部相容性误差的推导\n\n由于数值格式对边界节点和内部节点的处理方式不同，必须分开进行分析。\n\n#### 边界节点误差\n我们首先分析边界节点 $i=0$ 和 $i=N$ 处的误差。\n\n在左边界 $x_0 = 0$ 处：\n规定的边界条件是 $u(0,t) = g_0(t) = 0$。\n数值格式首先将中间解的值设置为新时间 $t_{n+1}$ 处的精确边界值：\n$$ \\tilde{u}_0 = g_0(t_{n+1}) = 0 $$\n然后，反应子步更新此值：\n$$ u_0^{n+1} = \\tilde{u}_0 + \\Delta t \\, \\kappa \\tilde{u}_0 = (1 + \\kappa \\Delta t) \\cdot 0 = 0 $$\n该点的精确解为 $u(x_0, t_{n+1}) = g_0(t_{n+1}) = 0$。\n因此，左边界的局部误差为零：\n$$ \\mathcal{E}_0 = u_0^{n+1} - u(x_0, t_{n+1}) = 0 - 0 = 0 $$\n\n在右边界 $x_N = 1$ 处：\n规定的边界条件是 $u(1,t) = g_1(t) = b \\, e^{\\kappa t}$。\n扩散子步设置中间解的值：\n$$ \\tilde{u}_N = g_1(t_{n+1}) = b \\, e^{\\kappa t_{n+1}} $$\n这个值恰好是时间 $t_{n+1}$ 处的正确边界值。然而，随后的反应子步会修改这个值：\n$$ u_N^{n+1} = \\tilde{u}_N + \\Delta t \\, \\kappa \\tilde{u}_N = (1 + \\kappa \\Delta t) \\tilde{u}_N = (1 + \\kappa \\Delta t) g_1(t_{n+1}) $$\n此节点的精确解为 $u(x_N, t_{n+1}) = g_1(t_{n+1})$。\n因此，右边界的局部误差为：\n$$ \\mathcal{E}_N = u_N^{n+1} - u(x_N, t_{n+1}) = (1 + \\kappa \\Delta t) g_1(t_{n+1}) - g_1(t_{n+1}) = \\kappa \\Delta t \\, g_1(t_{n+1}) $$\n对于从 $t_0=0$ 到 $t_1=\\Delta t$ 的第一步，这变为 $\\mathcal{E}_N = \\kappa \\Delta t \\, b \\, e^{\\kappa \\Delta t}$。\n边界误差的主阶项是 $\\mathcal{E}_N = \\kappa b \\Delta t + O((\\Delta t)^2)$。这是一个关于 $\\Delta t$ 的一阶误差，即 $\\mathcal{E}_N = O(\\Delta t)$。这个误差的引入是因为反应算子在施加了正确的边界条件*之后*才被应用，从而破坏了边界值。\n\n#### 内部节点误差\n对于内部节点 $i=1, \\dots, N-1$，一步之后的数值解是：\n$$ u_i^{n+1} = (1 + \\kappa \\Delta t) \\tilde{u}_i = (1 + \\kappa \\Delta t) (u_i^n + \\Delta t \\, \\Delta_h u_i^n) $$\n展开后得到：\n$$ u_i^{n+1} = u_i^n + \\Delta t \\, \\Delta_h u_i^n + \\kappa \\Delta t u_i^n + \\kappa (\\Delta t)^2 \\Delta_h u_i^n $$\n从精确解 $u_i^n = u(x_i, t_n)$ 开始，我们可以用其泰勒级数展开来替换有限差分算子：$\\Delta_h u(x_i, t_n) = u_{xx}(x_i, t_n) + \\frac{h^2}{12}u_{xxxx}(x_i, t_n) + O(h^4)$。将其代入数值格式中得到：\n$$ u_i^{n+1} = u_i^n + \\Delta t \\left(u_{xx} + \\frac{h^2}{12}u_{xxxx} \\right) + \\kappa \\Delta t u_i^n + \\kappa (\\Delta t)^2 \\left(u_{xx} + O(h^2)\\right) + O(\\Delta t h^4) $$\n其中所有导数均在 $(x_i, t_n)$ 处求值。整理各项：\n$$ u_i^{n+1} = u_i^n + \\Delta t (u_{xx} + \\kappa u_i^n) + \\frac{\\Delta t h^2}{12}u_{xxxx} + \\kappa (\\Delta t)^2 u_{xx} + O((\\Delta t)^2 h^2) $$\n\n接下来，我们将精确解 $u(x,t)$ 在 $(x_i, t_n)$ 附近按时间进行泰勒级数展开：\n$$ u(x_i, t_{n+1}) = u(x_i, t_n) + \\Delta t \\, u_t(x_i, t_n) + \\frac{(\\Delta t)^2}{2} u_{tt}(x_i, t_n) + O((\\Delta t)^3) $$\n使用偏微分方程 $u_t = u_{xx} + \\kappa u$，我们可以求得更高阶的时间导数：\n$u_{tt} = \\frac{\\partial}{\\partial t}(u_{xx} + \\kappa u) = u_{xxt} + \\kappa u_t = (u_t)_{xx} + \\kappa u_t = (u_{xx} + \\kappa u)_{xx} + \\kappa(u_{xx} + \\kappa u) = u_{xxxx} + 2\\kappa u_{xx} + \\kappa^2 u$。\n将这些代入 $u(x_i, t_{n+1})$ 的泰勒展开式中：\n$$ u(x_i, t_{n+1}) = u_i^n + \\Delta t (u_{xx} + \\kappa u_i^n) + \\frac{(\\Delta t)^2}{2} (u_{xxxx} + 2\\kappa u_{xx} + \\kappa^2 u_i^n) + O((\\Delta t)^3) $$\n\n局部相容性误差 $\\mathcal{E}_i$ 是 $u_i^{n+1} - u(x_i, t_{n+1})$ 的差值：\n$$ \\mathcal{E}_i = \\left( \\frac{\\Delta t h^2}{12}u_{xxxx} + \\kappa (\\Delta t)^2 u_{xx} \\right) - \\left( \\frac{(\\Delta t)^2}{2} (u_{xxxx} + 2\\kappa u_{xx} + \\kappa^2 u_i^n) \\right) + \\text{h.o.t.} $$\n$$ \\mathcal{E}_i = \\frac{\\Delta t h^2}{12}u_{xxxx} - \\frac{(\\Delta t)^2}{2}u_{xxxx} - \\frac{(\\kappa \\Delta t)^2}{2}u_i^n + \\text{h.o.t.} $$\n内部误差的主阶项为 $O(\\Delta t h^2)$ 和 $O((\\Delta t)^2)$。这个误差的阶数高于在边界上观察到的 $O(\\Delta t)$ 误差。这种边界误差阶数低于内部误差阶数的差异，是算子分裂格式在简单地施加时变狄利克雷边界条件时的一个已知的人为现象。\n\n### 数值实现\n提供的 Python 代码实现了上述推导的逻辑，以计算给定测试用例的误差。\n1.  它遍历每组参数 $(a, b, \\kappa, N, \\Delta t)$。\n2.  构建一个大小为 $N+1$ 的均匀空间网格 $x_i$。\n3.  使用精确解设置 $t_n=0$ 时的初始条件 $u^n$：$u_i^0 = a \\sin(\\pi x_i) + b x_i$。\n4.  根据李分裂格式执行单个时间步：\n    a. 扩散子步计算内部节点的 $\\tilde{u}_i = u_i^n + \\Delta t \\, \\Delta_h u_i^n$。\n    b. 将 $t_{n+1}=\\Delta t$ 时的狄利克雷边界值施加到中间解上：$\\tilde{u}_0 = 0$ 和 $\\tilde{u}_N = b e^{\\kappa \\Delta t}$。\n    c. 反应子步更新所有节点：$u_i^{n+1} = (1 + \\kappa \\Delta t)\\tilde{u}_i$。\n5.  计算时间 $t_1=\\Delta t$ 时所有节点的精确解 $u(x_i, \\Delta t)$。\n6.  通过从数值解中减去精确解来找到局部相容性误差向量 $\\mathcal{E}$，即 $\\mathcal{E}_i = u_i^{n+1} - u(x_i, \\Delta t)$。\n7.  最后，计算并存储边界节点处的最大绝对误差 $\\max\\{|\\mathcal{E}_0|, |\\mathcal{E}_N|\\}$ 和内部节点处的最大绝对误差 $\\max_{1\\le i\\le N-1} |\\mathcal{E}_i|$。\n然后，将所有测试用例的结果格式化为指定的单行输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the one-step local consistency error for a Lie splitting scheme\n    applied to a reaction-diffusion equation.\n    \"\"\"\n    \n    # Test cases: (a, b, kappa, N, dt)\n    test_cases = [\n        (1.0, 1.0, 0.7, 40, 1e-2),\n        (1.0, 1.0, 0.7, 40, 5e-3),\n        (1.0, 1.0, 0.7, 80, 1e-2),\n        (2.0, 0.5, 1.3, 60, 2e-3),\n        (1.0, 0.0, 0.7, 40, 1e-2),\n    ]\n\n    results = []\n\n    for a, b, kappa, N, dt in test_cases:\n        # Spatial-temporal parameters\n        h = 1.0 / N\n        x = np.linspace(0.0, 1.0, N + 1)\n        t_n = 0.0\n        t_np1 = dt\n\n        # Initial condition u^n = u(x, t_n=0)\n        u_n = a * np.sin(np.pi * x) + b * x\n        \n        # --- Lie splitting scheme for one step ---\n        \n        # 1. Diffusion substep (explicit Euler)\n        u_tilde = np.zeros(N + 1)\n        \n        # Update interior nodes\n        u_tilde_interior = u_n[1:-1] + (dt / h**2) * (u_n[2:] - 2 * u_n[1:-1] + u_n[:-2])\n        u_tilde[1:-1] = u_tilde_interior\n        \n        # Impose Dirichlet BCs at t_np1\n        g0_tnp1 = 0.0\n        g1_tnp1 = b * np.exp(kappa * t_np1)\n        u_tilde[0] = g0_tnp1\n        u_tilde[N] = g1_tnp1\n        \n        # 2. Reaction substep (explicit Euler)\n        u_np1 = u_tilde * (1.0 + kappa * dt)\n        \n        # --- Error Calculation ---\n        \n        # Exact solution at t_np1\n        term1 = a * np.exp((kappa - np.pi**2) * t_np1) * np.sin(np.pi * x)\n        term2 = b * np.exp(kappa * t_np1) * x\n        u_exact_tnp1 = term1 + term2\n        \n        # Local consistency error vector: E = u_numerical - u_exact\n        error_vec = u_np1 - u_exact_tnp1\n        \n        # Maximum boundary error\n        boundary_error = np.max(np.abs([error_vec[0], error_vec[N]]))\n        \n        # Maximum interior error\n        if N > 1:\n            interior_error = np.max(np.abs(error_vec[1:-1]))\n        else:\n            # Case with no interior points\n            interior_error = 0.0\n            \n        results.append([boundary_error, interior_error])\n\n    # Format and print the final result as a list of lists with no spaces\n    formatted_results = [f\"[{be:.10g},{ie:.10g}]\" for be, ie in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}