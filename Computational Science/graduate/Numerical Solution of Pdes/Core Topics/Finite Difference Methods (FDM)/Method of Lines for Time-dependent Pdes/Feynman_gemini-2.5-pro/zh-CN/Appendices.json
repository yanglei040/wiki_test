{
    "hands_on_practices": [
        {
            "introduction": "在应用线方法时，空间离散化将偏微分方程转化为一个常微分方程组。这个系统的性质，特别是空间算子的特征值，直接决定了显式时间积分格式的稳定性约束。本练习  将指导你通过分析离散拉普拉斯算子的谱，为一维热传导方程推导出著名的、类似于CFL条件的稳定性条件，从而深刻理解空间步长和时间步长之间的内在联系。",
            "id": "3420393",
            "problem": "考虑区间 $(0,L)$ 上的一维热传导方程 $u_{t}=\\nu u_{xx}$，对于 $t>0$，具有齐次狄利克雷边界条件 $u(0,t)=0$ 和 $u(L,t)=0$。设使用一个具有 $N$ 个内部点的均匀空间网格，网格间距为 $h=L/(N+1)$，节点值为 $u_{i}(t)\\approx u(x_{i},t)$，其中 $x_{i}=ih$，$i=1,2,\\dots,N$。空间二阶导数由标准的二阶中心差分近似，得到线法半离散系统\n$$\n\\frac{d\\boldsymbol{u}}{dt}=\\nu A\\boldsymbol{u},\n$$\n其中 $\\boldsymbol{u}(t)=(u_{1}(t),\\dots,u_{N}(t))^{\\top}$，$A$ 是对应于具有齐次狄利克雷边界条件的离散拉普拉斯算子的 $N\\times N$ 三对角矩阵。\n\n仅使用线性系统的基本性质和常微分方程的显式欧拉法，完成以下操作：\n\n- 计算矩阵 $A$ 的全套特征值，表示为 $h$ 和 $N$ 的函数。\n- 通过对应用于半离散系统的显式欧拉时间离散化进行逐模式稳定性分析，推导出一个形式为 $\\Delta t\\le C\\,h^{2}/\\nu$ 的充分时间步长限制，该限制与 $N$ 无关，并确定从此分析中可获得的精确常数 $C$。\n\n请以 $C$ 的数值作为最终答案。无需四舍五入。最终答案中不要包含单位。",
            "solution": "问题陈述已经过验证，并被认为是合理的。它在科学上是成立的、适定的、客观的。它提出了一个数值分析偏微分方程领域的标准且不平凡的问题。所有必要信息均已提供，且没有矛盾之处。因此，我们可以着手求解。\n\n该问题要求从一维热传导方程 $u_{t}=\\nu u_{xx}$ 在区域 $x \\in (0,L)$ 上，带有齐次狄利克雷边界条件 $u(0,t)=0$ 和 $u(L,t)=0$ 的线法离散化中推导出两个主要结果。离散化使用 $N$ 个内部点 $x_i = ih$（$i=1, 2, \\dots, N$），网格间距为均匀的 $h=L/(N+1)$。\n\n首先，我们确定半离散系统 $\\frac{d\\boldsymbol{u}}{dt}=\\nu A\\boldsymbol{u}$ 中矩阵 $A$ 的特征值。在内部节点 $x_i$ 处的空间二阶导数 $u_{xx}$ 使用标准的二阶中心差分进行近似：\n$$\nu_{xx}(x_i, t) \\approx \\frac{u(x_{i-1}, t) - 2u(x_i, t) + u(x_{i+1}, t)}{h^2}\n$$\n用节点近似值 $u_i(t) \\approx u(x_i, t)$ 替换连续函数 $u(x,t)$，该偏微分方程变为一个常微分方程（ODE）组：\n$$\n\\frac{du_i}{dt} = \\frac{\\nu}{h^2} (u_{i-1}(t) - 2u_i(t) + u_{i+1}(t)) \\quad \\text{对于 } i=1, \\dots, N.\n$$\n边界条件 $u(0,t)=0$ 和 $u(L,t)=0$ 意味着对于所有 $t$，$u_0(t)=0$ 和 $u_{N+1}(t)=0$。\n这个常微分方程组可以表示为矩阵形式 $\\frac{d\\boldsymbol{u}}{dt} = \\frac{\\nu}{h^2} T \\boldsymbol{u}$，其中 $\\boldsymbol{u}(t) = (u_1(t), \\dots, u_N(t))^\\top$，$T$ 是一个 $N \\times N$ 的三对角矩阵：\n$$\nT = \\begin{pmatrix} -2  & 1  & 0  & \\cdots  & 0 \\\\ 1 & -2  & 1 &  & 0 \\\\ 0 & 1 & \\ddots & \\ddots & \\vdots \\\\ \\vdots &  & \\ddots  & -2 & 1 \\\\ 0 & \\cdots &  & 1 & -2 \\end{pmatrix}\n$$\n根据问题陈述 $\\frac{d\\boldsymbol{u}}{dt}=\\nu A\\boldsymbol{u}$，我们确定 $A = \\frac{1}{h^2}T$。为了求出 $A$ 的特征值，我们首先求出 $T$ 的特征值。设 $\\lambda_T$ 是 $T$ 的一个特征值，$\\boldsymbol{v}=(v_1, \\dots, v_N)^\\top$ 是其对应的特征向量。特征值问题 $T\\boldsymbol{v} = \\lambda_T \\boldsymbol{v}$ 可以按分量写成：\n$$\nv_{j-1} - 2v_j + v_{j+1} = \\lambda_T v_j \\quad \\text{对于 } j=1, \\dots, N,\n$$\n边界条件为 $v_0 = 0$ 和 $v_{N+1} = 0$。这是一个二阶线性齐次差分方程：\n$$\nv_{j+1} - (2+\\lambda_T)v_j + v_{j-1} = 0.\n$$\n我们寻找形式为 $v_j = r^j$ 的解。将此设解代入差分方程，得到特征方程 $r^2 - (2+\\lambda_T)r + 1 = 0$。令 $2+\\lambda_T = 2\\cos(\\theta)$。特征方程变为 $r^2 - 2\\cos(\\theta)r + 1 = 0$，其根为 $r = \\cos(\\theta) \\pm i\\sin(\\theta) = e^{\\pm i\\theta}$。\n$v_j$ 的通解是这些根的线性组合：$v_j = C_1 e^{ij\\theta} + C_2 e^{-ij\\theta} = B_1 \\sin(j\\theta) + B_2 \\cos(j\\theta)$。\n应用边界条件 $v_0=0$ 得到 $B_1 \\sin(0) + B_2 \\cos(0) = B_2 = 0$。所以，特征向量的分量必须是 $v_j = B_1 \\sin(j\\theta)$ 的形式。\n应用另一个边界条件 $v_{N+1}=0$ 得到 $B_1 \\sin((N+1)\\theta) = 0$。对于非平凡特征向量，$B_1 \\neq 0$，这要求 $\\sin((N+1)\\theta)=0$。\n这意味着 $(N+1)\\theta = k\\pi$，其中 $k$ 是一个整数。所以，$\\theta_k = \\frac{k\\pi}{N+1}$。\n$k=1, 2, \\dots, N$ 的值产生 $N$ 个线性无关的特征向量。其他的 $k$ 的整数值要么产生平凡解（$k=0, N+1, \\dots$），要么是线性相关的。特征值 $\\lambda_T$ 由代换 $2+\\lambda_{T,k} = 2\\cos(\\theta_k)$ 得到：\n$$\n\\lambda_{T,k} = 2\\cos\\left(\\frac{k\\pi}{N+1}\\right) - 2 = -2\\left(1-\\cos\\left(\\frac{k\\pi}{N+1}\\right)\\right) = -4\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right).\n$$\n因此，矩阵 $A = \\frac{1}{h^2}T$ 的特征值 $\\lambda_k$ 为：\n$$\n\\lambda_k = -\\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right) \\quad \\text{对于 } k=1, 2, \\dots, N.\n$$\n这完成了问题的第一部分。\n\n接下来，我们分析应用于半离散系统的显式欧拉法的稳定性。时间步进格式为：\n$$\n\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^n + \\Delta t (\\nu A \\boldsymbol{u}^n) = (I + \\nu \\Delta t A)\\boldsymbol{u}^n.\n$$\n如果放大矩阵 $G = I + \\nu \\Delta t A$ 的谱半径小于或等于 $1$，则该格式是稳定的。$G$ 的特征值（记为 $\\mu_k$）与 $A$ 的特征值通过 $\\mu_k = 1 + \\nu \\Delta t \\lambda_k$ 相关。稳定性条件是对于所有 $k=1, \\dots, N$，$|\\mu_k| \\le 1$。\n代入 $\\lambda_k$ 的表达式：\n$$\n\\mu_k = 1 - \\frac{4\\nu \\Delta t}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right).\n$$\n由于 $\\nu > 0$, $\\Delta t > 0$, 且 $h > 0$，所有的 $\\lambda_k$ 都是实数且为负。因此，$\\mu_k \\le 1$ 总是成立的。稳定性条件简化为 $\\mu_k \\ge -1$：\n$$\n1 - \\frac{4\\nu \\Delta t}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right) \\ge -1\n$$\n$$\n\\frac{4\\nu \\Delta t}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right) \\le 2\n$$\n$$\n\\Delta t \\le \\frac{2h^2}{4\\nu \\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)} = \\frac{h^2}{2\\nu\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)}.\n$$\n这个不等式必须对所有模式，即对所有 $k=1, \\dots, N$ 都成立。最严格的条件是由使分母中的项 $\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)$ 最大化的模式所施加的。对于所有 $k \\in \\{1,\\dots,N\\}$，参数 $\\frac{k\\pi}{2(N+1)}$ 位于区间 $(0, \\pi/2)$ 内。由于 $\\sin(x)$ 在 $[0, \\pi/2]$ 上是递增的，最大值出现在 $k$ 的最大可能值处，即 $k=N$。\n这给出了对于固定 $N$ 的充要稳定性条件：\n$$\n\\Delta t \\le \\frac{h^2}{2\\nu\\sin^2\\left(\\frac{N\\pi}{2(N+1)}\\right)}.\n$$\n问题要求一个形式为 $\\Delta t\\le C\\,h^{2}/\\nu$ 的充分条件，其中常数 $C$ 与 $N$ 无关。这个条件必须对所有 $N \\ge 1$ 都有效。因此，我们必须有：\n$$\nC \\frac{h^2}{\\nu} \\le \\frac{h^2}{2\\nu\\sin^2\\left(\\frac{N\\pi}{2(N+1)}\\right)} \\quad \\text{对于所有 } N \\ge 1.\n$$\n这简化为：\n$$\nC \\le \\frac{1}{2\\sin^2\\left(\\frac{N\\pi}{2(N+1)}\\right)}.\n$$\n为确保这对所有 $N$ 都成立，$C$ 必须小于或等于右侧表达式在所有 $N \\ge 1$ 上的最小值（下确界）：\n$$\nC \\le \\inf_{N \\ge 1} \\left\\{ \\frac{1}{2\\sin^2\\left(\\frac{N\\pi}{2(N+1)}\\right)} \\right\\}.\n$$\n让我们分析函数 $f(N) = \\frac{1}{2\\sin^2\\left(\\frac{N\\pi}{2(N+1)}\\right)}$。正弦函数的参数 $x_N = \\frac{N\\pi}{2(N+1)} = \\frac{\\pi}{2}\\left(1-\\frac{1}{N+1}\\right)$ 是一个单调递增序列，当 $N \\to \\infty$ 时从下方收敛于 $\\pi/2$。由于 $\\sin^2(x)$ 在 $[0, \\pi/2]$ 上是递增的，分母 $2\\sin^2(x_N)$ 也是一个关于 $N$ 的单调递增函数。因此，$f(N)$ 是一个关于 $N$ 的单调递减函数。下确界是当 $N \\to \\infty$ 时的极限：\n$$\n\\inf_{N \\ge 1} f(N) = \\lim_{N \\to \\infty} \\frac{1}{2\\sin^2\\left(\\frac{N\\pi}{2(N+1)}\\right)} = \\frac{1}{2\\sin^2\\left(\\lim_{N \\to \\infty}\\frac{N\\pi}{2(N+1)}\\right)} = \\frac{1}{2\\sin^2(\\pi/2)} = \\frac{1}{2(1)^2} = \\frac{1}{2}.\n$$\n与 $N$ 无关的最精确（最大）的可能常数 $C$ 就是这个下确界。任何大于 $1/2$ 的 $C$ 值对于足够大的 $N$ 都会违反稳定性条件。因此，精确常数是 $C = 1/2$。",
            "answer": "$$\n\\boxed{\\frac{1}{2}}\n$$"
        },
        {
            "introduction": "数值方法的一个核心环节是验证代码实现是否达到了其理论精度。本练习  将通过一个网格加密研究来实践这一过程，这是衡量收敛阶的标准流程。通过一个巧妙的设计，该练习将时间积分误差完全消除，从而能够精确地分离并测量空间离散格式的收敛阶，让你亲手验证其理论上的二阶收敛性（即误差与 $h^2$ 成正比）。",
            "id": "3420375",
            "problem": "考虑在闭区间 $[0,1]$ 上的一维热方程，其具有齐次狄利克雷边界条件和光滑的初始条件。其控制偏微分方程（PDE）为\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in (0,1), \\quad t \\ge 0,\n$$\n边界条件为\n$$\nu(0,t) = 0, \\quad u(1,t) = 0,\n$$\n初始条件为\n$$\nu(x,0) = \\sin(\\pi x).\n$$\n假设无量纲单位下的热扩散系数参数为 $\\alpha = 1$。在这些条件下，该偏微分方程的精确解为\n$$\nu(x,t) = \\sin(\\pi x)\\, e^{-\\pi^2 t}.\n$$\n使用线法（MOL），仅对空间域进行离散化，以产生一个常微分方程的半离散系统。使用包含 $N$ 个内部点的均匀网格（间距为 $h = \\frac{1}{N+1}$）和二阶中心有限差分来近似空间导数算子。将得到的离散拉普拉斯算子表示为矩阵 $A_h \\in \\mathbb{R}^{N \\times N}$，半离散系统表示为\n$$\n\\frac{d \\mathbf{u}(t)}{dt} = A_h \\mathbf{u}(t), \\quad \\mathbf{u}(0) = \\mathbf{u}_0,\n$$\n其中 $\\mathbf{u}(t)$ 近似于网格点 $x_i = i h$（$i = 1,2,\\ldots,N$）处的 $u(x_i,t)$。对该半离散系统进行精确的时间积分以分离空间误差；即，计算\n$$\n\\mathbf{u}(T) = e^{T A_h} \\mathbf{u}_0\n$$\n利用所选初始条件在齐次狄利克雷边界条件下是中心差分拉普拉斯算子的一个离散特征向量这一事实。网格点上的连续参考解为\n$$\n\\mathbf{u}_{\\text{ref}}(T)_i = \\sin(\\pi x_i)\\, e^{-\\pi^2 T}.\n$$\n将最终时间 $T$ 的离散 $L^2$ 误差定义为\n$$\nE_h(T) = \\left( h \\sum_{i=1}^N \\left(\\mathbf{u}(T)_i - \\mathbf{u}_{\\text{ref}}(T)_i\\right)^2 \\right)^{1/2}.\n$$\n您的任务是设计并执行一个网格加密研究，通过使用上述解析积分的半离散系统来分离空间离散误差。当 $N$ 加倍（即 $h$ 减半）时，推导、证明并预测离散 $L^2$ 误差在 $h$ 上的观测收敛率。然后，实现一个程序来计算连续网格加密之间的经验收敛率。\n\n测试套件参数：\n- 使用三个最终时间 $T \\in \\{0.1,\\; 1.0,\\; 10.0\\}$。\n- 对于每个 $T$，使用内部网格尺寸序列 $N \\in \\{15,\\; 31,\\; 63,\\; 127\\}$，这样由于 $h = \\frac{1}{N+1}$，连续的 $N$ 值之间的网格间距恰好减半。\n- 对于每个 $T$，计算误差 $E_{h_k}(T)$（$k = 1,2,3,4$）和经验收敛率\n$$\np_k = \\frac{\\log\\left(E_{h_k}(T) / E_{h_{k+1}}(T)\\right)}{\\log\\left(h_k / h_{k+1}\\right)}, \\quad k = 1,2,3.\n$$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。输出格式必须是包含三个列表的列表，每个 $T$ 对应一个，其中每个内部列表按连续网格加密的顺序包含该 $T$ 的三个经验收敛率 $p_k$。例如，\n$$\n[ [p_1(T_1), p_2(T_1), p_3(T_1)], [p_1(T_2), p_2(T_2), p_3(T_2)], [p_1(T_3), p_2(T_3), p_3(T_3)] ].\n$$\n所有数值结果必须以无单位的浮点值形式报告。",
            "solution": "该问题是有效的。它在偏微分方程数值分析领域提出了一个适定且有科学依据的任务。所有必要的组成部分——控制偏微分方程、边界和初始条件、精确解、数值方法（线法）、误差度量以及网格加密研究的参数——都已提供且相互一致。该问题是客观且无歧义的，要求基于一个其解析性质已被充分理解的经典测试案例，执行一个标准程序（收敛率计算）。\n\n任务是使用线法（MOL）对一维热方程的数值解进行网格加密研究。核心思想是通过解析地积分得到的常微分方程（ODE）半离散系统来分离空间离散误差。\n\n首先，我们分析预期的收敛率。空间导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 使用二阶中心有限差分格式进行近似。此近似的局部截断误差为 $O(h^2)$ 阶，其中 $h$ 是空间网格间距。由于问题指定半离散常微分方程系统在时间上是精确求解的，因此没有时间离散误差。因此，数值解的全局误差完全由空间离散化决定。对于一个稳定且一致的格式，全局误差的阶数与局部截断误差的阶数相匹配。因此，我们预计离散 $L^2$ 误差 $E_h(T)$ 的行为将类似于 $E_h(T) \\approx C h^2$，其中 $C$ 是一个依赖于最终时间 $T$ 和解的性质但与 $h$ 无关的常数。\n\n经验收敛率 $p$ 是通过比较两种不同网格间距 $h_k$ 和 $h_{k+1}$ 的误差来计算的。根据问题描述，网格被加密，使得 $h_{k+1} = h_k/2$。收敛率由下式给出：\n$$\np_k = \\frac{\\log(E_{h_k} / E_{h_{k+1}})}{\\log(h_k / h_{k+1})}\n$$\n代入 $E_h \\approx C h^2$ 和 $h_{k+1} = h_k/2$，我们得到：\n$$\np_k \\approx \\frac{\\log((C h_k^2) / (C (h_k/2)^2))}{\\log(h_k / (h_k/2))} = \\frac{\\log(4)}{\\log(2)} = \\frac{2 \\log(2)}{\\log(2)} = 2\n$$\n预测的收敛率为 $2$。我们的数值实验应得出随着网格加密而趋近于此值的收敛率。\n\n现在，我们详细说明线法的实现。\n空间域 $[0,1]$ 使用 $N$ 个内部点 $x_i = i h$（$i=1, 2, \\ldots, N$）进行离散化，网格间距为 $h = 1/(N+1)$。在这些点上的函数 $u(x,t)$ 由一个向量 $\\mathbf{u}(t)$ 近似，其中 $\\mathbf{u}(t)_i \\approx u(x_i, t)$。\n偏微分方程为 $\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}$，其中 $\\alpha=1$。对二阶导数应用中心有限差分公式，\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x=x_i} \\approx \\frac{u(x_{i-1}, t) - 2u(x_i, t) + u(x_{i+1}, t)}{h^2}\n$$\n我们得到一个关于内部点的常微分方程组：\n$$\n\\frac{d\\mathbf{u}_i(t)}{dt} = \\frac{1}{h^2} (\\mathbf{u}_{i-1}(t) - 2\\mathbf{u}_i(t) + \\mathbf{u}_{i+1}(t)), \\quad i=1, \\ldots, N\n$$\n边界条件 $u(0,t)=0$ 和 $u(1,t)=0$ 意味着 $\\mathbf{u}_0(t)=0$ 和 $\\mathbf{u}_{N+1}(t)=0$。该系统可以写成矩阵形式：\n$$\n\\frac{d\\mathbf{u}(t)}{dt} = A_h \\mathbf{u}(t)\n$$\n其中 $A_h$ 是一个 $N \\times N$ 的三对角矩阵：\n$$\nA_h = \\frac{1}{h^2} \\begin{pmatrix}\n-2  & 1  & 0  & \\cdots  & 0 \\\\\n1 & -2  & 1 & \\cdots  & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots &  & 1 & -2 & 1 \\\\\n0 & \\cdots & 0 & 1 & -2\n\\end{pmatrix}\n$$\n这个常微分方程组的精确解是 $\\mathbf{u}(T) = e^{T A_h} \\mathbf{u}_0$。直接计算矩阵指数 $e^{T A_h}$ 的计算成本可能很高，并可能引入数值误差。然而，通过选择初始条件 $u(x,0) = \\sin(\\pi x)$，问题提供了一个关键的简化。相应的离散初始条件向量 $\\mathbf{u}_0$ 的分量为 $(\\mathbf{u}_0)_i = \\sin(\\pi x_i) = \\sin(\\pi i h)$。\n\n这个特定的初始条件向量是矩阵 $A_h$ 的一个特征向量。$A_h$ 的特征向量 $\\mathbf{v}_k$ 和特征值 $\\lambda_k$ 已知为：\n$$\n(\\mathbf{v}_k)_j = \\sin\\left(\\frac{k j \\pi}{N+1}\\right) = \\sin(k \\pi x_j), \\quad k=1, \\ldots, N\n$$\n$$\n\\lambda_k = \\frac{2}{h^2}(\\cos(k \\pi h) - 1) = -\\frac{4}{h^2} \\sin^2\\left(\\frac{k \\pi h}{2}\\right)\n$$\n我们的初始条件 $\\mathbf{u}_0$ 对应于第一个特征向量 $\\mathbf{v}_1$（$k=1$ 时）。由于 $\\mathbf{u}_0 = \\mathbf{v}_1$，矩阵指数的运算显著简化：\n$$\n\\mathbf{u}(T) = e^{T A_h} \\mathbf{u}_0 = e^{T A_h} \\mathbf{v}_1 = e^{T \\lambda_1} \\mathbf{v}_1\n$$\n其中 $\\lambda_1 = -\\frac{4}{h^2} \\sin^2\\left(\\frac{\\pi h}{2}\\right)$。这使我们能够解析地计算数值解向量，而无需构造或对矩阵 $A_h$ 进行指数运算。\n\n误差计算也得到了简化。网格点上的参考解为 $\\mathbf{u}_{\\text{ref}}(T)_i = \\sin(\\pi x_i) e^{-\\pi^2 T}$。误差向量为：\n$$\n(\\mathbf{u}(T) - \\mathbf{u}_{\\text{ref}}(T))_i = (e^{T \\lambda_1} - e^{-\\pi^2 T})\\sin(\\pi x_i)\n$$\n离散 $L^2$ 误差定义为 $E_h(T) = \\left( h \\sum_{i=1}^N \\left(\\mathbf{u}(T)_i - \\mathbf{u}_{\\text{ref}}(T)_i\\right)^2 \\right)^{1/2}$。代入误差向量：\n$$\nE_h(T) = \\left( h \\sum_{i=1}^N \\left[ (e^{T \\lambda_1} - e^{-\\pi^2 T})\\sin(\\pi x_i) \\right]^2 \\right)^{1/2} = |e^{T \\lambda_1} - e^{-\\pi^2 T}| \\left( h \\sum_{i=1}^N \\sin^2(\\pi x_i) \\right)^{1/2}\n$$\n该求和有一个已知的闭式解：$\\sum_{i=1}^N \\sin^2(\\frac{\\pi i}{N+1}) = \\frac{N+1}{2}$。因此，平方根下的项变为：\n$$\nh \\sum_{i=1}^N \\sin^2(\\pi x_i) = \\frac{1}{N+1} \\cdot \\frac{N+1}{2} = \\frac{1}{2}\n$$\n这将误差计算简化为一个只依赖于 $T$、$h$ 和已知常数的单一、优雅的表达式，完全避免了求和循环，从而消除了范数计算中的任何求积误差：\n$$\nE_h(T) = \\frac{1}{\\sqrt{2}} |e^{T \\lambda_1} - e^{-\\pi^2 T}|\n$$\n流程是，对于给定序列中的每个 $N_k$，计算此误差 $E_{h_k}(T)$，然后计算经验率 $p_k = \\log_2(E_{h_k}(T) / E_{h_{k+1}}(T))$（$k=1,2,3$）。对每个最终时间 $T$ 执行此操作。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a grid refinement study for the 1D heat equation using the method of lines\n    with an exact time integrator to isolate spatial discretization error.\n    \"\"\"\n    T_values = [0.1, 1.0, 10.0]\n    N_values = [15, 31, 63, 127]\n\n    all_results = []\n\n    for T in T_values:\n        errors = []\n        for N in N_values:\n            # h: grid spacing\n            h = 1.0 / (N + 1)\n            \n            # The numerical method uses an exact time integrator on the semi-discrete system.\n            # The initial condition sin(pi*x) is the first discrete eigenvector of the\n            # centered finite-difference Laplacian.\n            # The corresponding eigenvalue lambda_1 of the operator A_h = (1/h^2)*tridiag(1,-2,1)\n            # is given by:\n            lambda_1 = -4.0 / h**2 * np.sin(np.pi * h / 2.0)**2\n            \n            # The numerical solution at the grid points is u_h(T) = exp(T*lambda_1) * u_0.\n            # The exact solution at the grid points is u_ex(T) = exp(-pi^2*T) * u_0.\n            # The L2 error norm can be calculated analytically. The sum term in the norm\n            # S = h * sum_{i=1 to N} (sin(pi*x_i))^2 simplifies to 1/2.\n            # So, E_h(T) = |exp(T*lambda_1) - exp(-pi^2*T)| * sqrt(S).\n            \n            # Factor from the analytical solution of the error norm calculation\n            error_factor = np.abs(np.exp(T * lambda_1) - np.exp(-T * np.pi**2))\n            \n            # The discrete L2 norm simplifies to this expression\n            error = error_factor / np.sqrt(2.0)\n            \n            errors.append(error)\n\n        # Compute empirical convergence rates\n        # p_k = log(E_k / E_{k+1}) / log(h_k / h_{k+1})\n        # Since h_{k+1} = h_k / 2, the denominator is log(2).\n        rates = []\n        for k in range(len(errors) - 1):\n            # Check for zero error to prevent division by zero or log(0)\n            if errors[k] = 0.0 or errors[k+1] = 0.0:\n                # This case shouldn't happen in this problem but is good practice.\n                rate = 0.0 \n            else:\n                rate = np.log(errors[k] / errors[k+1]) / np.log(2.0)\n            rates.append(rate)\n        \n        all_results.append(rates)\n\n    # Format the output string as per the problem specification.\n    # e.g., [[rate1, rate2, rate3], [rate1, rate2, rate3], ... ]\n    final_output_str = f\"[{', '.join(map(str, all_results))}]\"\n    \n    print(final_output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "在许多实际应用中，我们更关心某个特定物理量（即“目标泛函”）的计算精度，而非解在整个区域上的整体误差。本练习  介绍了一种强大的后验误差估计技术——伴随方法（adjoint method）。你将学习如何通过求解一个逆时演化的伴随方程来估计目标泛函的误差，这为评估解的质量提供了一种更具针对性和实用性的途径。",
            "id": "3420381",
            "problem": "考虑一维线性抛物型偏微分方程 $u_t = \\nu u_{xx}$，该方程定义在周期性定义域 $x \\in [0,1]$ 上，具有光滑初始条件 $u(x,0) = u_0(x)$，其中 $\\nu  0$ 是一个常数扩散系数。使用方法线（MOL），即首先对连续空间变量进行离散化，然后对得到的常微分方程组进行时间积分，步骤如下。\n\n将空间 $x \\in [0,1]$ 离散化为 $N$ 个等距周期性节点 $x_j = j h$，$j = 0,1,\\dots,N-1$，其中 $h = 1/N$。令 $U(t) \\in \\mathbb{R}^N$ 表示节点值的集合 $U_j(t) \\approx u(x_j,t)$。在周期性边界条件下，使用标准的中心二阶差分来近似二阶导数，这产生离散拉普拉斯算子 $L \\in \\mathbb{R}^{N \\times N}$，定义为 $(LU)_j = \\frac{U_{j-1} - 2 U_j + U_{j+1}}{h^2}$，索引具有周期性。MOL半离散系统为 $U'(t) = A U(t)$，其中 $A = \\nu L$，并假设初始数据 $U(0) = U_0$ 是精确的。\n\n令关注的泛函为在网格节点 $j_0$ 处的逐点求值，即 $J(U(T)) = e_{j_0}^\\top U(T)$，其中 $e_{j_0} \\in \\mathbb{R}^N$ 是在第 $j_0$ 个分量为1、其余分量为0的标准基向量，$T  0$ 是最终时间。用 $U_h(t)$ 表示一个分段時間連續重构，该重构来自于将具有统一时间步长 $k$ 的前向欧拉时间积分器应用于MOL系统所产生的全离散数值解；即，对于 $n = 0,1,\\dots, M-1$，$U_{n+1} = U_n + k A U_n$，其中 $M k = T$。在每个时间区间 $[t_n, t_{n+1}]$ 内，重构为 $U_h(t) = U_n + (t - t_n) \\frac{U_{n+1}-U_n}{k}$。定义重构相对于半离散方程的连续残差为 $r(t) = U_h'(t) - A U_h(t)$。\n\n对于此线性和自治系统，关注泛函中误差的对偶加权残差表示是使用伴随（对偶）解 $z(t)$ 构建的，该解满足时间反向伴随常微分方程 $-z'(t) = A^\\top z(t)$（$t \\in [0,T]$），终端条件为 $z(T) = e_{j_0}$。在精确初始条件和线性自治设置下，误差表示为\n$$\nJ(U(T)) - J(U_h(T)) = \\int_0^T \\langle r(t), z(t) \\rangle \\, dt,\n$$\n其中 $\\langle \\cdot, \\cdot \\rangle$ 表示 $\\mathbb{R}^N$ 上的标准欧几里得内积。\n\n您的任务是在上述设置中，为泛函 $J(U(T))$ 实现这种基于伴随的后验误差估计，并做出以下特定选择以确保科学真实性和可测试性：\n\n- 选择初始条件 $u_0(x) = \\sin(2\\pi x) + \\tfrac{1}{2} \\sin(4\\pi x)$，在网格上采样以定义 $U_0 \\in \\mathbb{R}^N$。此选择是光滑的，且与周期性边界条件一致。\n- 对MOL系统 $U'(t) = A U(t)$ 和上述分段线性重构 $U_h(t)$ 使用前向欧拉时间步进。通过选择 $k$ 小于或等于离散热方程的前向欧拉稳定性极限，即 $k \\le \\frac{h^2}{2\\nu}$，来确保稳定性。为确定起见，设定一个目标 $k_{\\mathrm{guess}} = \\alpha \\, \\frac{h^2}{2\\nu}$，其中 $0  \\alpha \\le 1$，然后选择统一的步数 $M = \\lceil T / k_{\\mathrm{guess}} \\rceil$ 和 $k = T / M$，使得 $M k = T$ 且 $k \\le k_{\\mathrm{guess}}$。\n- 通过使用离散傅里叶变换对角化 $A$，精确计算所有 $t \\in [0,T]$ 的伴随解 $z(t)$。对于周期性二阶差分，$L$ 是一个循环矩阵，可被离散傅里叶变换对角化，$L$ 的特征值为 $\\lambda_k = \\frac{2\\cos(2\\pi k / N) - 2}{h^2}$，$k = 0,1,\\dots,N-1$。由于 $A = \\nu L$ 且 $A^\\top = A$，伴随解为 $z(t) = \\exp(A(T-t)) e_{j_0}$，可以使用傅里叶对角化进行高效计算。\n- 为前向欧拉分段线性重构精确计算残差 $r(t)$。在区间 $[t_n, t_{n+1}]$ 中，重构的导数是常数 $\\frac{U_{n+1}-U_n}{k} = A U_n$，重构本身为 $U_h(t) = U_n + (t-t_n) A U_n$，这得到 $r(t) = - (t-t_n) A^2 U_n$。\n- 使用辛普森三点求积法则来近似每个时间区间 $[t_n, t_{n+1}]$ 上的误差积分。即，对于 $t \\in [t_n, t_{n+1}]$，定义 $g(t) = \\langle r(t), z(t) \\rangle$，并近似 $\\int_{t_n}^{t_{n+1}} g(t) \\, dt \\approx \\frac{k}{6} \\left( g(t_n) + 4 g(t_n + \\tfrac{k}{2}) + g(t_{n+1}) \\right)$，注意到由于 $r(t_n)=0$ 所以 $g(t_n) = 0$。\n\n为量化估计量并提供一个测试套件，对于下面的每个参数集，您必须计算：\n- 泛函的绝对误差 $|J(U_{\\mathrm{exact}}(T)) - J(U_h(T))|$，其中 $U_{\\mathrm{exact}}(T) = \\exp(A T) U_0$ 通过傅里叶对角化精确计算，以及\n- 估计量与真实误差之间的绝对差 $|\\widehat{E} - (J(U_{\\mathrm{exact}}(T)) - J(U_h(T)))|$，其中 $\\widehat{E}$ 是对 $\\int_0^T \\langle r(t), z(t) \\rangle dt$ 基于辛普森法则的近似。\n\n实现一个单一程序，对于以下测试套件，计算每种情况下的这两个量，并将所有结果汇总到单行输出中，该行包含按顺序排列的六个浮点数，用方括号括起来并用逗号分隔：\n- 测试用例1：$N=64$，$\\nu=0.1$，$T=0.5$，$j_0=16$，$\\alpha=0.9$。\n- 测试用例2：$N=8$，$\\nu=0.5$，$T=0.1$，$j_0=3$，$\\alpha=0.9$。\n- 测试用例3：$N=128$，$\\nu=0.01$，$T=0.05$，$j_0=40$，$\\alpha=0.95$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5,r_6]$），其中每个测试用例的结果对的顺序为 $[|J(U_{\\mathrm{exact}}(T)) - J(U_h(T))|, |\\widehat{E} - (J(U_{\\mathrm{exact}}(T)) - J(U_h(T)))|]$。不涉及物理单位。不涉及角度。不涉及百分比。定义域长度为$1$，网格间距为$h = 1/N$。要使用的内积是 $\\mathbb{R}^N$ 上的欧几里得点积。",
            "solution": "任务是为定义在周期性定义域上的一维线性热方程 $u_t = \\nu u_{xx}$ 解的一个泛函实现并测试一个基于伴随的后验误差估计器。该问题使用方法线（MOL）进行离散化，并对得到的常微分方程（ODE）组进行数值求解。问题陈述的验证已确认其科学合理性、完整性和适定性。我们现在开始详细的求解过程。\n\n首先，将空间定义域 $x \\in [0,1]$ 离散化为 $N$ 个等距节点 $x_j = j h$，$j=0, 1, \\dots, N-1$，其中网格间距为 $h=1/N$。解 $u(x,t)$ 由一个节点值向量 $U(t) \\in \\mathbb{R}^N$ 近似，其中 $U_j(t) \\approx u(x_j, t)$。空间二阶导数 $u_{xx}$ 使用带有周期性边界条件的标准二阶中心差分格式进行近似。这导致一个线性的半离散常微分方程组：\n$$\nU'(t) = A U(t)\n$$\n其中矩阵 $A = \\nu L \\in \\mathbb{R}^{N \\times N}$。矩阵 $L$ 是离散拉普拉斯算子，其对向量 $U$ 的作用由 $(LU)_j = (U_{j-1} - 2U_j + U_{j+1})/h^2$ 给出，索引被周期性地解释。该系统的初始条件是通过在网格节点上对给定的光滑周期函数 $u_0(x) = \\sin(2\\pi x) + \\tfrac{1}{2} \\sin(4\\pi x)$ 进行采样获得的，从而得到向量 $U_0$。\n\n矩阵 $A$ 是一个实对称循环矩阵。循环矩阵的一个关键性质是它们可以被离散傅里叶变换（DFT）对角化。令 $\\mathcal{F}$ 表示DFT算子。则 $A = \\mathcal{F}^{-1} \\text{diag}(\\Lambda) \\mathcal{F}$，其中 $\\Lambda$ 是 $A$ 的特征值向量。周期性二阶差分算子 $L$ 的特征值为 $\\lambda_p = \\frac{2}{h^2}(\\cos(2\\pi p/N) - 1)$，波数 $p=0, 1, \\dots, N-1$。因此，$A = \\nu L$ 的特征值为 $\\Lambda_p = \\nu \\lambda_p$。这种对角化允许高效地计算矩阵向量积和矩阵指数。对于任意向量 $v \\in \\mathbb{R}^N$ 和标量 $\\tau$，解析函数 $f(A)$ 对 $v$ 的作用可计算为 $f(A)v = \\mathcal{F}^{-1}(f(\\Lambda) \\odot \\mathcal{F}(v))$，其中 $\\odot$ 表示逐元素乘法。\n\n在最终时间 $T$ 时半离散系统的“精确”解由 $U_{\\text{exact}}(T) = \\exp(AT)U_0$ 给出。这可以使用傅里叶方法高效地计算：\n$$\nU_{\\text{exact}}(T) = \\mathcal{F}^{-1}(\\exp(\\Lambda T) \\odot \\mathcal{F}(U_0))\n$$\n关注的泛函是 $J(U) = e_{j_0}^\\top U$，其中 $e_{j_0}$ 是标准基向量。泛函的精确值为 $J(U_{\\text{exact}}(T)) = e_{j_0}^\\top U_{\\text{exact}}(T)$。\n\n数值解是通过将前向欧拉法应用于具有时间步长 $k$ 的半离散系统获得的：\n$$\nU_{n+1} = U_n + k A U_n = (I + kA)U_n\n$$\n其中 $U_n$ 近似于时间 $t_n = n k$ 时的 $U(t_n)$。选择时间步长 $k$ 以满足稳定性条件 $k \\le h^2/(2\\nu)$。在 $M$ 步之后（$M k = T$），最终的数值解为 $U_M \\equiv U_h(T)$。每一步中矩阵 $A$ 的作用都是使用傅里叶方法计算的。泛函的数值为 $J(U_h(T)) = e_{j_0}^\\top U_h(T)$。泛函中的真实误差是差值 $E = J(U_{\\text{exact}}(T)) - J(U_h(T))$。\n\n任务的核心是使用对偶加权残差法计算后验误差估计 $\\widehat{E}$。误差由精确的积分表示给出：\n$$\nE = \\int_0^T \\langle r(t), z(t) \\rangle \\, dt\n$$\n其中 $\\langle \\cdot, \\cdot \\rangle$ 是欧几里得内积。被积函数的两个分量是残差 $r(t)$ 和伴随解 $z(t)$。\n\n伴随（或对偶）问题由 $-z'(t) = A^\\top z(t)$ 给出，终端条件为 $z(T) = e_{j_0}$。由于 $A$ 是对称的，$A^\\top = A$。解为 $z(t) = \\exp(A(T-t))e_{j_0}$。这可以在任何需要的时间 $t$ 使用傅里叶方法计算：\n$$\nz(t) = \\mathcal{F}^{-1}(\\exp(\\Lambda(T-t)) \\odot \\mathcal{F}(e_{j_0}))\n$$\n\n残差 $r(t)$ 衡量分段线性时间重构 $U_h(t)$ 对半离散方程的满足程度。对于 $t \\in [t_n, t_{n+1}]$，重构为 $U_h(t) = U_n + \\frac{t-t_n}{k}(U_{n+1}-U_n)$。其时间导数为 $U_h'(t) = \\frac{U_{n+1}-U_n}{k}$。使用前向欧拉更新规则 $U_{n+1}-U_n = k A U_n$，我们发现 $U_h'(t) = A U_n$。于是残差为：\n$$\nr(t) = U_h'(t) - A U_h(t) = A U_n - A\\left(U_n + \\frac{t-t_n}{k} k A U_n\\right) = -(t-t_n) A^2 U_n\n$$\n$A^2 U_n$ 的计算也通过傅里叶方法完成：$A^2 U_n = \\mathcal{F}^{-1}(\\Lambda^2 \\odot \\mathcal{F}(U_n))$。\n\n误差估计 $\\widehat{E}$ 是积分 $\\int_0^T \\langle r(t), z(t) \\rangle \\, dt$ 的一个近似。该积分被分解为在时间区间 $[t_n, t_{n+1}]$ 上的求和，每个子积分使用辛普森三点法则近似：\n$$\n\\int_{t_n}^{t_{n+1}} g(t) \\, dt \\approx \\frac{k}{6} \\left( g(t_n) + 4g(t_n + k/2) + g(t_{n+1}) \\right)\n$$\n其中 $g(t) = \\langle r(t), z(t) \\rangle$。由于 $r(t_n) = 0$，因此 $g(t_n)=0$。单步积分近似的公式简化为 $\\frac{k}{6} (4g(t_n + k/2) + g(t_{n+1}))$。总估计误差是所有 $M$ 个时间步上这些近似值的总和：\n$$\n\\widehat{E} = \\sum_{n=0}^{M-1} \\frac{k}{6} \\left( 4 \\langle r(t_n+k/2), z(t_n+k/2) \\rangle + \\langle r(t_{n+1}), z(t_{n+1}) \\rangle \\right)\n$$\n\n对于每个测试用例，我们计算两个量：泛函中真实误差的绝对值 $|E| = |J(U_{\\text{exact}}(T)) - J(U_h(T))|$，以及估计值与真实误差之间的绝对差 $|\\widehat{E} - E|$，后者衡量估计器本身的准确性。所有涉及矩阵 $A$ 的运算都在傅里叶空间中执行，以提高效率和准确性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests an adjoint-based a posteriori error estimator for the\n    1D periodic heat equation discretized with the Method of Lines.\n    \"\"\"\n\n    def run_case(N, nu, T, j0, alpha):\n        \"\"\"\n        Runs a single test case for the given parameters.\n\n        Returns:\n            - Absolute true error in the functional.\n            - Absolute accuracy of the error estimator.\n        \"\"\"\n        # 1. Initialization and Setup\n        h = 1.0 / N\n        x_grid = np.arange(N) * h\n        p_wavenumbers = np.arange(N)\n\n        # Initial condition U0\n        U0 = np.sin(2 * np.pi * x_grid) + 0.5 * np.sin(4 * np.pi * x_grid)\n\n        # Time-stepping parameters\n        k_stability_limit = h**2 / (2 * nu)\n        k_guess = alpha * k_stability_limit\n        M = int(np.ceil(T / k_guess))\n        k = T / M\n\n        # 2. Fourier Diagonalization Tools\n        # Eigenvalues of the spatial operator A = nu * L\n        lambda_L = (2 / h**2) * (np.cos(2 * np.pi * p_wavenumbers / N) - 1)\n        Lambda_A = nu * lambda_L\n\n        def apply_matrix_func(func_on_eigs, vec):\n            \"\"\"Applies a function of matrix A to a vector v using FFT.\"\"\"\n            vec_hat = np.fft.fft(vec)\n            result_hat = func_on_eigs * vec_hat\n            return np.real(np.fft.ifft(result_hat))\n\n        # 3. Compute the \"Exact\" Semi-Discrete Solution\n        exp_Lambda_T = np.exp(Lambda_A * T)\n        U_exact_T = apply_matrix_func(exp_Lambda_T, U0)\n        J_exact = U_exact_T[j0]\n        \n        # 4. Compute the Numerical Solution (Forward Euler)\n        U_n = U0.copy()\n        U_history = [U0.copy()]\n        # Action of A is needed for time stepping\n        def apply_A(vec):\n            return apply_matrix_func(Lambda_A, vec)\n            \n        for _ in range(M):\n            U_n += k * apply_A(U_n)\n            U_history.append(U_n.copy())\n            \n        U_h_T = U_history[-1]\n        J_h = U_h_T[j0]\n\n        # 5. Compute the A Posteriori Error Estimate\n        E_hat = 0.0\n        \n        # Precompute FFT of e_j0 for adjoint solution\n        e_j0 = np.zeros(N)\n        e_j0[j0] = 1.0\n        \n        # Action of A^2\n        Lambda_A_sq = Lambda_A**2\n        def apply_A2(vec):\n            return apply_matrix_func(Lambda_A_sq, vec)\n\n        for n in range(M):\n            t_n = n * k\n            U_n_current = U_history[n]\n            \n            # Compute needed values of residual r(t)\n            A2_Un = apply_A2(U_n_current)\n            r_mid = -(k / 2.0) * A2_Un\n            r_end = -k * A2_Un\n            \n            # Compute needed values of adjoint z(t)\n            t_mid = t_n + k / 2.0\n            t_end = t_n + k\n            \n            exp_Lambda_adj_mid = np.exp(Lambda_A * (T - t_mid))\n            z_mid = apply_matrix_func(exp_Lambda_adj_mid, e_j0)\n\n            exp_Lambda_adj_end = np.exp(Lambda_A * (T - t_end))\n            z_end = apply_matrix_func(exp_Lambda_adj_end, e_j0)\n\n            # Compute integrand g(t) at sample points\n            # g(t_n) is 0 because r(t_n) is 0\n            g_mid = np.dot(r_mid, z_mid)\n            g_end = np.dot(r_end, z_end)\n            \n            # Add this step's contribution (Simpson's rule) to the total estimate\n            E_hat += (k / 6.0) * (4.0 * g_mid + g_end)\n\n        # 6. Final Calculations\n        true_error_val = J_exact - J_h\n        abs_true_error = np.abs(true_error_val)\n        estimator_accuracy = np.abs(E_hat - true_error_val)\n        \n        return abs_true_error, estimator_accuracy\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 64, 'nu': 0.1, 'T': 0.5, 'j0': 16, 'alpha': 0.9},\n        {'N': 8, 'nu': 0.5, 'T': 0.1, 'j0': 3, 'alpha': 0.9},\n        {'N': 128, 'nu': 0.01, 'T': 0.05, 'j0': 40, 'alpha': 0.95},\n    ]\n\n    results = []\n    for case in test_cases:\n        abs_err, est_acc = run_case(**case)\n        results.append(abs_err)\n        results.append(est_acc)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}