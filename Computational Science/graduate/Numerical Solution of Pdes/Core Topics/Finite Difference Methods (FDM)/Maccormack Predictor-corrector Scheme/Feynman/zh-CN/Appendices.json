{
    "hands_on_practices": [
        {
            "introduction": "任何数值格式分析的第一步都是理解其稳定性和准确性。本练习将通过冯·诺依曼稳定性分析，带你深入剖析麦考马克格式最基本的特性。你不仅将推导出其稳定性条件，还将探索一个更有趣的概念——数值相误差，并找出会使格式传播波形最精确的特定库朗数。",
            "id": "3418392",
            "problem": "考虑常数波速 $a>0$ 且定义在空间周期性域上的线性平流方程 $u_{t} + a\\,u_{x} = 0$。设空间网格为 $x_{j} = j\\,\\Delta x$（其中 $j$ 为整数），时间层为 $t^{n} = n\\,\\Delta t$。定义库朗数（Courant number）为 $\\nu = a\\,\\Delta t/\\Delta x$。两步 MacCormack 预测-校正格式（对于 $a>0$，在预测步中使用向前空间差分，在校正步中使用向后空间差分）由下式给出：\n$$\nu_{j}^{*} = u_{j}^{n} - \\nu\\left(u_{j+1}^{n} - u_{j}^{n}\\right), \\quad\nu_{j}^{n+1} = \\frac{1}{2}\\left(u_{j}^{n} + u_{j}^{*}\\right) - \\frac{\\nu}{2}\\left(u_{j}^{*} - u_{j-1}^{*}\\right).\n$$\n通过假设平面波解 $u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$（其中无量纲波数 $\\theta = k\\,\\Delta x \\in [0,\\pi]$）来进行冯·诺伊曼（von Neumann）分析（或称傅里叶分析）。从上述定义和复指数的基本性质出发，完成以下任务：\n\n1) 推导单步更新式 $u_{j}^{n+1} = \\sum_{m=-1}^{1} c_{m}(\\nu)\\,u_{j+m}^{n}$，并由此获得作为 $\\nu$ 和 $\\theta$ 的显式函数的放大因子 $G(\\theta) = \\hat{u}^{n+1}/\\hat{u}^{n}$。\n\n2) 使用放大因子，通过要求对所有 $\\theta \\in [0,\\pi]$ 均有 $|G(\\theta)| \\leq 1$，来确定冯·诺伊曼稳定性对 $\\nu$ 的条件。\n\n3) 定义数值相位 $\\phi(\\theta)$ 为 $G(\\theta)$ 的连续辐角，选择使得 $\\phi(0)=0$ 的分支，并令单个时间步的精确相位为 $\\phi_{\\text{exact}}(\\theta) = -\\nu\\,\\theta$。定义相位误差度量\n$$\nE_{\\text{phase}}(\\nu) = \\sup_{\\theta \\in [0,\\pi]} \\left|\\phi(\\theta) - \\phi_{\\text{exact}}(\\theta)\\right|.\n$$\n确定使 $E_{\\text{phase}}(\\nu)$ 最小化的 $\\nu \\in (0,1]$ 的值。将最终答案表示为单个精确实数，无需四舍五入，也无需单位。",
            "solution": "该问题是有效的，因为它具有科学依据、问题提法得当且客观。它包含对线性平流方程的 MacCormack 格式的标准冯·诺伊曼稳定性和相位误差分析，这是偏微分方程数值解中的一个基本课题。所有定义都是标准的，任务在数学上是严谨的。\n\n我们依次解决问题的三个部分。\n\n### 第1部分：单步更新和放大因子\n\nMacCormack 格式由一对预测-校正方程给出：\n预测步：\n$$\nu_{j}^{*} = u_{j}^{n} - \\nu\\left(u_{j+1}^{n} - u_{j}^{n}\\right)\n\\label{eq:1} \\tag{1}\n$$\n校正步：\n$$\nu_{j}^{n+1} = \\frac{1}{2}\\left(u_{j}^{n} + u_{j}^{*}\\right) - \\frac{\\nu}{2}\\left(u_{j}^{*} - u_{j-1}^{*}\\right)\n\\label{eq:2} \\tag{2}\n$$\n其中 $\\nu = a\\Delta t / \\Delta x$ 是库朗数。\n\n为了推导单步更新公式，我们首先将预测步结果式 \\eqref{eq:1} 代入校正步方程，即式 \\eqref{eq:2}。\n首先，我们将 $u_j^*$ 和 $u_{j-1}^*$ 用时间层 $n$ 的值表示。\n由式 \\eqref{eq:1}，我们有：\n$$\nu_{j}^{*} = (1+\\nu)u_{j}^{n} - \\nu u_{j+1}^{n}\n$$\n通过将索引 $j$ 移至 $j-1$，我们得到相邻网格点上预测值的表达式：\n$$\nu_{j-1}^{*} = u_{j-1}^{n} - \\nu\\left(u_{j}^{n} - u_{j-1}^{n}\\right) = (1+\\nu)u_{j-1}^{n} - \\nu u_{j}^{n}\n$$\n现在，将这些代入校正步，即式 \\eqref{eq:2}：\n$$\nu_{j}^{n+1} = \\frac{1}{2}\\left(u_{j}^{n} + \\left[(1+\\nu)u_{j}^{n} - \\nu u_{j+1}^{n}\\right]\\right) - \\frac{\\nu}{2}\\left(\\left[(1+\\nu)u_{j}^{n} - \\nu u_{j+1}^{n}\\right] - \\left[(1+\\nu)u_{j-1}^{n} - \\nu u_{j}^{n}\\right]\\right)\n$$\n我们来收集 $u_{j-1}^{n}$、$u_{j}^{n}$ 和 $u_{j+1}^{n}$ 的系数。\n$u_{j-1}^{n}$ 的系数：\n$$\nc_{-1} = -\\frac{\\nu}{2} (-(1+\\nu)) = \\frac{\\nu(1+\\nu)}{2} = \\frac{\\nu^2+\\nu}{2}\n$$\n$u_{j+1}^{n}$ 的系数：\n$$\nc_{1} = \\frac{1}{2}(-\\nu) - \\frac{\\nu}{2}(-\\nu) = -\\frac{\\nu}{2} + \\frac{\\nu^2}{2} = \\frac{\\nu^2-\\nu}{2}\n$$\n$u_{j}^{n}$ 的系数：\n$$\nc_{0} = \\frac{1}{2}(1 + (1+\\nu)) - \\frac{\\nu}{2}((1+\\nu) - (-\\nu)) = \\frac{2+\\nu}{2} - \\frac{\\nu}{2}(1+2\\nu) = 1 + \\frac{\\nu}{2} - \\frac{\\nu}{2} - \\nu^2 = 1-\\nu^2\n$$\n因此，单步更新式为：\n$$\nu_{j}^{n+1} = \\left(\\frac{\\nu^2+\\nu}{2}\\right)u_{j-1}^{n} + (1-\\nu^2)u_{j}^{n} + \\left(\\frac{\\nu^2-\\nu}{2}\\right)u_{j+1}^{n}\n$$\n这具有 $u_{j}^{n+1} = \\sum_{m=-1}^{1} c_{m}(\\nu)\\,u_{j+m}^{n}$ 的形式，其中的系数 $c_{-1}$、$c_0$ 和 $c_1$ 已被推导出来。\n\n接下来，我们求解放大因子 $G(\\theta)$。我们将平面波解 $u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$ 代入单步公式。注意 $u_{j+m}^{n} = \\hat{u}^{n}\\,\\exp(i\\,(j+m)\\,\\theta) = u_{j}^{n}\\exp(i\\,m\\,\\theta)$。\n$$\n\\hat{u}^{n+1}e^{ij\\theta} = c_{-1}\\hat{u}^{n}e^{i(j-1)\\theta} + c_{0}\\hat{u}^{n}e^{ij\\theta} + c_{1}\\hat{u}^{n}e^{i(j+1)\\theta}\n$$\n两边同除以 $\\hat{u}^{n}e^{ij\\theta}$，我们得到放大因子 $G(\\theta) = \\hat{u}^{n+1}/\\hat{u}^{n}$：\n$$\nG(\\theta) = c_{-1}e^{-i\\theta} + c_{0} + c_{1}e^{i\\theta}\n$$\n代入系数的表达式：\n$$\nG(\\theta) = \\left(\\frac{\\nu^2+\\nu}{2}\\right)e^{-i\\theta} + (1-\\nu^2) + \\left(\\frac{\\nu^2-\\nu}{2}\\right)e^{i\\theta}\n$$\n我们将含有 $\\nu^2$ 和 $\\nu$ 的项分组：\n$$\nG(\\theta) = (1-\\nu^2) + \\frac{\\nu^2}{2}(e^{i\\theta} + e^{-i\\theta}) - \\frac{\\nu}{2}(e^{i\\theta} - e^{-i\\theta})\n$$\n使用欧拉恒等式 $\\cos\\theta = \\frac{e^{i\\theta} + e^{-i\\theta}}{2}$ 和 $\\sin\\theta = \\frac{e^{i\\theta} - e^{-i\\theta}}{2i}$：\n$$\nG(\\theta) = (1-\\nu^2) + \\nu^2\\cos\\theta - \\nu(i\\sin\\theta)\n$$\n最后，我们得到作为 $\\nu$ 和 $\\theta$ 的显式函数的放大因子：\n$$\nG(\\theta) = 1 - \\nu^2(1-\\cos\\theta) - i\\nu\\sin\\theta\n$$\n\n### 第2部分：冯·诺伊曼稳定性条件\n\n为了使格式在冯·诺伊曼意义下稳定，放大因子的模必须对所有相关波数，即对所有 $\\theta \\in [0, \\pi]$，满足 $|G(\\theta)| \\le 1$。我们分析 $|G(\\theta)|^2$：\n$$\n|G(\\theta)|^2 = (\\operatorname{Re}(G(\\theta)))^2 + (\\operatorname{Im}(G(\\theta)))^2\n$$\n根据第1部分推导的表达式：\n$\\operatorname{Re}(G(\\theta)) = 1 - \\nu^2(1-\\cos\\theta)$\n$\\operatorname{Im}(G(\\theta)) = -\\nu\\sin\\theta$\n所以，\n$$\n|G(\\theta)|^2 = \\left(1 - \\nu^2(1-\\cos\\theta)\\right)^2 + (-\\nu\\sin\\theta)^2\n$$\n$$\n|G(\\theta)|^2 = 1 - 2\\nu^2(1-\\cos\\theta) + \\nu^4(1-\\cos\\theta)^2 + \\nu^2\\sin^2\\theta\n$$\n我们使用恒等式 $\\sin^2\\theta = 1-\\cos^2\\theta$：\n$$\n|G(\\theta)|^2 = 1 - 2\\nu^2 + 2\\nu^2\\cos\\theta + \\nu^4(1-2\\cos\\theta+\\cos^2\\theta) + \\nu^2(1-\\cos^2\\theta)\n$$\n$$\n= (1 - 2\\nu^2 + \\nu^2) + (2\\nu^2\\cos\\theta) + \\nu^4 - 2\\nu^4\\cos\\theta + \\nu^4\\cos^2\\theta - \\nu^2\\cos^2\\theta\n$$\n$$\n= 1 - \\nu^2 + 2\\nu^2(1-\\nu^2)\\cos\\theta - \\nu^2(1-\\nu^2)\\cos^2\\theta\n$$\n这看起来很复杂。使用半角恒等式的另一种简化方法更为直接。我们使用 $1-\\cos\\theta = 2\\sin^2(\\theta/2)$ 和 $\\sin\\theta = 2\\sin(\\theta/2)\\cos(\\theta/2)$：\n$$\n\\operatorname{Re}(G(\\theta)) = 1 - 2\\nu^2\\sin^2(\\theta/2)\n$$\n$$\n\\operatorname{Im}(G(\\theta)) = -\\nu \\left(2\\sin(\\theta/2)\\cos(\\theta/2)\\right)\n$$\n$$\n|G(\\theta)|^2 = \\left(1 - 2\\nu^2\\sin^2(\\theta/2)\\right)^2 + \\left(-2\\nu\\sin(\\theta/2)\\cos(\\theta/2)\\right)^2\n$$\n$$\n= 1 - 4\\nu^2\\sin^2(\\theta/2) + 4\\nu^4\\sin^4(\\theta/2) + 4\\nu^2\\sin^2(\\theta/2)\\cos^2(\\theta/2)\n$$\n使用 $\\cos^2(\\theta/2) = 1-\\sin^2(\\theta/2)$：\n$$\n= 1 - 4\\nu^2\\sin^2(\\theta/2) + 4\\nu^4\\sin^4(\\theta/2) + 4\\nu^2\\sin^2(\\theta/2)\\left(1-\\sin^2(\\theta/2)\\right)\n$$\n$$\n= 1 - 4\\nu^2\\sin^2(\\theta/2) + 4\\nu^4\\sin^4(\\theta/2) + 4\\nu^2\\sin^2(\\theta/2) - 4\\nu^2\\sin^4(\\theta/2)\n$$\n项 $\\pm 4\\nu^2\\sin^2(\\theta/2)$ 相互抵消：\n$$\n|G(\\theta)|^2 = 1 + 4\\nu^4\\sin^4(\\theta/2) - 4\\nu^2\\sin^4(\\theta/2)\n$$\n$$\n|G(\\theta)|^2 = 1 - 4\\nu^2(1-\\nu^2)\\sin^4(\\theta/2)\n$$\n稳定性条件 $|G(\\theta)|^2 \\le 1$ 可转化为：\n$$\n1 - 4\\nu^2(1-\\nu^2)\\sin^4(\\theta/2) \\le 1\n$$\n$$\n-4\\nu^2(1-\\nu^2)\\sin^4(\\theta/2) \\le 0\n$$\n两边同除以 $-1$ 并反转不等号：\n$$\n4\\nu^2(1-\\nu^2)\\sin^4(\\theta/2) \\ge 0\n$$\n此不等式必须对所有 $\\theta \\in [0, \\pi]$ 成立。项 $4$、$\\nu^2$（因为 $\\nu=a\\Delta t/\\Delta x$ 且 $a>0$，所以有 $\\nu>0$）和 $\\sin^4(\\theta/2)$ 都是非负的。因此，格式的稳定性仅取决于项 $(1-\\nu^2)$ 的符号。\n我们必须有：\n$$\n1-\\nu^2 \\ge 0 \\implies \\nu^2 \\le 1\n$$\n由于 $\\nu>0$，冯·诺伊曼稳定性条件为 $0  \\nu \\le 1$。\n\n### 第3部分：相位误差最小化\n\n相位误差定义为数值相位 $\\phi(\\theta) = \\arg(G(\\theta))$ 与单个时间步的精确相位 $\\phi_{\\text{exact}}(\\theta) = -\\nu\\theta$ 之间的差。目标是找到使相位误差度量\n$$\nE_{\\text{phase}}(\\nu) = \\sup_{\\theta \\in [0,\\pi]} \\left|\\phi(\\theta) - \\phi_{\\text{exact}}(\\theta)\\right|\n$$\n最小化的 $\\nu \\in (0,1]$ 的值。\n根据定义，绝对值确保对所有 $\\nu$ 都有 $E_{\\text{phase}}(\\nu) \\geq 0$。该误差度量的最小可能值为 $0$。如果我们能找到一个 $\\nu \\in (0,1]$ 的值使得 $E_{\\text{phase}}(\\nu)=0$，那么该值必定是最小值点。\n\n我们来研究 $\\nu=1$ 的特殊情况。第2部分的稳定性分析表明这是稳定性极限。\n将 $\\nu=1$ 代入放大因子 $G(\\theta)$ 的表达式中：\n$$\nG(\\theta)|_{\\nu=1} = 1 - 1^2(1-\\cos\\theta) - i(1)\\sin\\theta\n$$\n$$\n= 1 - 1 + \\cos\\theta - i\\sin\\theta\n$$\n$$\n= \\cos\\theta - i\\sin\\theta\n$$\n使用欧拉公式，这可以简化为：\n$$\nG(\\theta)|_{\\nu=1} = \\exp(-i\\theta)\n$$\n数值相位 $\\phi(\\theta)$ 是 $G(\\theta)$ 的辐角。对于 $\\nu=1$：\n$$\n\\phi(\\theta)|_{\\nu=1} = \\arg(\\exp(-i\\theta)) = -\\theta\n$$\n根据问题约定 $\\phi(0)=0$，此式对 $\\theta \\in [0, \\pi]$ 成立。\n现在我们计算 $\\nu=1$ 时的精确相位：\n$$\n\\phi_{\\text{exact}}(\\theta)|_{\\nu=1} = -1 \\cdot \\theta = -\\theta\n$$\n因此，$\\nu=1$ 时的相位误差为：\n$$\n\\left|\\phi(\\theta) - \\phi_{\\text{exact}}(\\theta)\\right|_{\\nu=1} = |(-\\theta) - (-\\theta)| = |0| = 0\n$$\n这对所有 $\\theta \\in [0, \\pi]$ 的值都成立。\n因此，$\\nu=1$ 时的相位误差度量为：\n$$\nE_{\\text{phase}}(1) = \\sup_{\\theta \\in [0,\\pi]} 0 = 0\n$$\n由于对所有 $\\nu$ 都有 $E_{\\text{phase}}(\\nu) \\ge 0$，并且我们已经发现 $E_{\\text{phase}}(1)=0$，这意味着 $\\nu=1$ 导致了最小可能的相位误差。\n对于任何 $\\nu \\in (0,1)$，相位误差不恒为零。对于小的 $\\theta$，可以证明相位误差为 $\\phi(\\theta) - \\phi_{\\text{exact}}(\\theta) \\approx \\frac{\\nu(1-\\nu^2)}{6}\\theta^3$。当 $\\theta \\neq 0$ 且 $\\nu \\in (0,1)$ 时，该值非零，这意味着对于 $\\nu \\in (0,1)$ 有 $E_{\\text{phase}}(\\nu)  0$。\n\n因此，使相位误差度量 $E_{\\text{phase}}(\\nu)$ 最小化的 $\\nu \\in (0,1]$ 的值是 $1$。",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "从线性问题迈向非线性世界时，数值格式会展现出新的、更复杂的行为。本练习将通过一个经典的非线性方程——无粘伯格斯方程，向你揭示一个深刻的原理：守恒形式的重要性。你将通过编程实现守恒与非守恒两种形式的麦考马克格式，并亲眼见证只有守恒格式才能正确捕捉激波的传播速度，这是一个无法仅从线性分析中得到的关键见解。",
            "id": "3342598",
            "problem": "考虑守恒形式的一维无粘性 Burgers 方程，由 $u_t + \\left(\\frac{u^2}{2}\\right)_x = 0$ 给出，其中 $u = u(x,t)$ 表示在空间坐标为 $x$ 的周期性域上的标量速度场。该守恒律在弱解意义下理解，因此可能出现间断解，并且这些解遵循从守恒原理推导出的积分平衡。通量函数为 $f(u) = \\frac{u^2}{2}$。对于 $u_L > u_R$ 的 Riemann 型初值数据，该方程允许激波的存在，由 Rankine–Hugoniot 跳跃条件决定的激波速度为 $s = \\frac{f(u_L) - f(u_R)}{u_L - u_R} = \\frac{u_L + u_R}{2}$。\n\nMacCormack 预测-校正格式用于推进双曲型偏微分方程。在守恒律形式下，MacCormack 方法通过使用通量的前向空间差分进行预测，并使用预测通量的后向差分进行校正，从而推进求解。一种非守恒变体则使用非守恒微分形式 $u_t + u\\,u_x = 0$ 来推进变量，将前向和后向差分应用于 $u$ 而不是通量 $f(u)$。对于间断解，只有守恒格式能确保从积分守恒律推导出的正确激波运动，而非守恒格式不保证能以正确速度传播激波。\n\n您的任务是构建一个反例，证明对于无粘性 Burgers 方程，与守恒 MacCormack 更新和解析的 Rankine–Hugoniot 速度相比，非守恒 MacCormack 更新会产生不正确的激波位置。请按以下步骤进行：\n\n1. 使用长度为 $L = 2$ 的周期性域，等同于区间 $[-1,1)$。设 $N$ 为均匀分布的网格点数，则 $\\Delta x = L/N$。在网格中心 $x_i = -L/2 + i\\,\\Delta x$（$i = 0,1,\\dots,N-1$）处表示数值。\n\n2. 在时间 $t=0$ 时初始化 Riemann 数据，该数据在 $x = x_0$ 处有一个单个间断，定义为\n   $$\n   u(x,0) = \n   \\begin{cases}\n   u_L,  x  x_0, \\\\\n   u_R,  x \\ge x_0,\n   \\end{cases}\n   $$\n   在区间 $[-1,1)$ 外进行周期性延拓。\n\n3. 实现两种显式 MacCormack 预测-校正格式，使用恒定时间步长 $\\Delta t$，该步长满足基于最大特征速度的 Courant–Friedrichs–Lewy 条件。使用无量纲 Courant 数 $\\text{CFL}$，并设置 $\\Delta t = \\text{CFL}\\,\\Delta x / \\max(|u_L|,|u_R|)$。\n   - 守恒 MacCormack：使用通量函数 $f(u) = \\frac{u^2}{2}$ 的前向和后向差分应用预测子和校正子，确保离散化与守恒律一致。\n   - 非守恒 MacCormack：在非守恒形式 $u_t + u\\,u_x = 0$ 中，使用原始变量 $u$ 的前向和后向差分应用预测子和校正子。\n\n4. 将每种格式推进 $n$ 步，其中 $n = \\lceil T/\\Delta t \\rceil$，得到最终时间 $t_{\\text{end}} = n\\,\\Delta t$。\n\n5. 对于每种格式，在 $t_{\\text{end}}$ 时刻估计数值激波位置。方法是找出解在相邻网格点之间穿过中点值 $m = \\frac{u_L + u_R}{2}$ 的位置 $x$，使用网格中心之间的线性插值。如果由于周期性或数值振荡而存在多个穿越点，则选择其位置与解析激波位置的周期性距离最小的那个穿越点。如果未检测到穿越点，则通过离散梯度的最大幅值位置来近似激波位置，然后使用局部插值进行精化。\n\n6. 使用 Rankine–Hugoniot 速度 $s = \\frac{u_L + u_R}{2}$ 计算解析激波位置，即 $x_{\\text{exact}}(t_{\\text{end}}) = x_0 + s\\,t_{\\text{end}}$，并对位置按域长 $L$ 取模，使其保持在 $[-1,1)$ 内。\n\n7. 对于每个测试用例，分别报告守恒和非守恒 MacCormack 格式在 $t_{\\text{end}}$ 时刻的数值激波位置与解析激波位置之间的绝对周期性距离。\n\n使用以下测试套件，其中包括清晰的激波传播、中等强度的激波和静止激波：\n- 用例 1：$u_L = 2.0$, $u_R = 0.0$, $x_0 = 0.0$, $N = 1000$, $T = 0.3$, $\\text{CFL} = 0.4$。\n- 用例 2：$u_L = 1.5$, $u_R = 0.5$, $x_0 = -0.2$, $N = 1000$, $T = 0.5$, $\\text{CFL} = 0.4$。\n- 用例 3：$u_L = 1.0$, $u_R = -1.0$, $x_0 = 0.3$, $N = 1000$, $T = 0.4$, $\\text{CFL} = 0.4$。\n\n所有量均为无量纲；无需物理单位。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，按每个用例的守恒误差后跟非守恒误差的顺序列出结果，即 $[e_{\\text{cons},1},e_{\\text{noncons},1},e_{\\text{cons},2},e_{\\text{noncons},2},e_{\\text{cons},3},e_{\\text{noncons},3}]$，其中每个 $e$ 是一个浮点数，表示对应格式和用例在最终时刻计算出的激波位置与解析激波位置之间的绝对周期性距离。",
            "solution": "该问题要求构建一个数值反例，以证明非守恒有限差分格式与守恒格式不同，它无法为无粘性 Burgers 方程计算出正确的激波速度。这将通过实现和比较 MacCormack 方法的两种变体来完成。\n\n守恒律形式的一维无粘性 Burgers 方程为\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x} \\left( \\frac{u^2}{2} \\right) = 0\n$$\n其中 $u(x,t)$ 是速度，通量函数为 $f(u) = \\frac{u^2}{2}$。对于导数存在的光滑解，可以应用链式法则得到非守恒形式：\n$$\n\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = 0\n$$\n然而，像 Burgers 方程这样的双曲守恒律，即使从光滑的初值数据出发，也会产生间断（激波）。对于间断解，微分形式没有明确定义，必须参考守恒律的积分形式。间断的动力学由 Rankine–Hugoniot 跳跃条件控制，该条件是积分形式的直接推论。对于以速度 $s$ 移动、分隔左右两个常数状态 $u_L$ 和 $u_R$ 的激波，该条件为：\n$$\ns = \\frac{f(u_L) - f(u_R)}{u_L - u_R}\n$$\n对于 Burgers 方程，这给出了解析激波速度：\n$$\ns = \\frac{\\frac{1}{2}u_L^2 - \\frac{1}{2}u_R^2}{u_L - u_R} = \\frac{u_L + u_R}{2}\n$$\n数值格式必须以“守恒形式”构建，以确保其解收敛到满足此跳跃条件的弱解。非守恒格式不遵守积分平衡，通常会收敛到一个具有不正确激波速度的解。\n\n我们将使用 $N$ 个均匀间隔的网格中心 $x_i = -L/2 + i \\Delta x$（$i = 0, \\dots, N-1$）来离散化长度为 $L=2$ 的空间域 $x \\in [-1, 1)$，其中 $\\Delta x = L/N$。时间步长 $\\Delta t$ 由 Courant–Friedrichs–Lewy (CFL) 条件决定，$\\Delta t = \\text{CFL} \\Delta x / \\max(|u_L|, |u_R|)$，以确保数值稳定性。\n\n初始条件是在 $x=x_0$ 处有阶跃间断的 Riemann 问题：\n$$\nu(x,0) = \n\\begin{cases}\nu_L,  x  x_0, \\\\\nu_R,  x \\ge x_0,\n\\end{cases}\n$$\n我们将解推进到最终时间 $t_{\\text{end}} = n \\Delta t$，其中 $n = \\lceil T/\\Delta t \\rceil$。\n\n两种 MacCormack 格式的实现如下。设 $u_i^n$ 为网格点 $i$ 和时间 $t^n = n \\Delta t$ 处的数值解。\n\n**1. 守恒 MacCormack 格式**\n该格式离散化守恒律 $u_t + f(u)_x=0$。\n*   预测步（对通量使用前向差分）：\n    $$\n    u_i^* = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( f(u_{i+1}^n) - f(u_i^n) \\right)\n    $$\n*   校正步（对预测通量使用后向差分）：\n    $$\n    u_i^{n+1} = \\frac{1}{2} \\left( u_i^n + u_i^* - \\frac{\\Delta t}{\\Delta x} \\left( f(u_i^*) - f(u_{i-1}^*) \\right) \\right)\n    $$\n此处，下标进行周期性处理，例如 $u_{N} = u_0$ 和 $u_{-1} = u_{N-1}$。该格式是守恒形式，在网格细化的极限下，预期能计算出正确的激波速度。\n\n**2. 非守恒 MacCormack 格式**\n该格式离散化非守恒形式 $u_t + u u_x=0$。\n*   预测步（对 $u$ 使用前向差分）：\n    $$\n    u_i^* = u_i^n - u_i^n \\frac{\\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n)\n    $$\n*   校正步（对预测的 $u$ 使用后向差分）：\n    $$\n    u_i^{n+1} = \\frac{1}{2} \\left( u_i^n + u_i^* - u_i^* \\frac{\\Delta t}{\\Delta x} (u_i^* - u_{i-1}^*) \\right)\n    $$\n这种形式没有在网格界面上离散化通量差分，因此不强制执行局部守恒性质。因此，它不保证能捕捉到正确的激波动力学。\n\n在用两种格式将解演化到 $t_{\\text{end}}$ 后，我们确定数值激波位置。这是通过找到数值解剖面穿过中点值 $m = (u_L + u_R)/2$ 的位置来完成的。我们使用包夹穿越点的两个网格点之间进行线性插值。如果由于数值振荡而出现多个穿越点，我们选择在周期性距离上最接近解析激波位置 $x_{\\text{analytical}}(t_{\\text{end}}) = x_0 + s \\cdot t_{\\text{end}}$ 的那一个。在长度为 $L$ 的域上，两点 $p_1$ 和 $p_2$ 之间的绝对周期性距离由 $\\min(|p_1 - p_2|, L - |p_1 - p_2|)$ 给出。\n\n然后，将每种格式的误差计算为在最终时间 $t_{\\text{end}}$ 时，其计算出的数值激波位置 $x_{\\text{numerical}}$ 与解析激波位置 $x_{\\text{analytical}}$ 之间的绝对周期性距离。三个测试用例的结果将表明，非守恒格式的误差远大于守恒格式的误差，从而证实前者计算出了不正确的激波速度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the 1D inviscid Burgers' equation using conservative and nonconservative\n    MacCormack schemes to demonstrate the importance of conservation form\n    for shock capturing.\n    \"\"\"\n    test_cases = [\n        # (u_L, u_R, x_0, N, T, CFL)\n        (2.0, 0.0, 0.0, 1000, 0.3, 0.4),\n        (1.5, 0.5, -0.2, 1000, 0.5, 0.4),\n        (1.0, -1.0, 0.3, 1000, 0.4, 0.4),\n    ]\n\n    results = []\n\n    for u_L, u_R, x_0, N, T, CFL in test_cases:\n        L = 2.0\n        dx = L / N\n        x = -L/2 + np.arange(N) * dx\n        \n        # CFL condition and time steps\n        max_speed = max(abs(u_L), abs(u_R))\n        if max_speed == 0:\n            # Avoid division by zero if max speed is zero, choose a reasonable dt\n            max_speed = 1.0\n        dt = CFL * dx / max_speed\n        num_steps = math.ceil(T / dt)\n        t_end = num_steps * dt\n\n        # Initial condition\n        u0 = np.full(N, u_R, dtype=np.float64)\n        u0[x  x_0] = u_L\n        \n        u_cons = u0.copy()\n        u_noncons = u0.copy()\n\n        # --- Time evolution ---\n        for _ in range(num_steps):\n            # Conservative MacCormack\n            f = 0.5 * u_cons**2\n            # Predictor\n            u_star_c = u_cons - (dt / dx) * (np.roll(f, -1) - f)\n            # Corrector\n            f_star = 0.5 * u_star_c**2\n            u_cons = 0.5 * (u_cons + u_star_c - (dt / dx) * (f_star - np.roll(f_star, 1)))\n\n            # Nonconservative MacCormack\n            # Predictor\n            u_star_nc = u_noncons - u_noncons * (dt / dx) * (np.roll(u_noncons, -1) - u_noncons)\n            # Corrector\n            u_noncons = 0.5 * (u_noncons + u_star_nc - u_star_nc * (dt / dx) * (u_star_nc - np.roll(u_star_nc, 1)))\n        \n        # --- Analysis ---\n        # Analytical shock location\n        s = (u_L + u_R) / 2.0\n        x_analytical = x_0 + s * t_end\n        # Map to periodic domain [-L/2, L/2)\n        x_analytical = -L/2 + (x_analytical - (-L/2)) % L\n\n        midpoint_val = (u_L + u_R) / 2.0\n        \n        def find_shock_location(u_final, x_grid, L_domain, analytical_pos, dx_grid):\n            \"\"\"\n            Finds the numerical shock location by looking for a crossing of the\n            midpoint value, refined by linear interpolation.\n            \"\"\"\n            crossings = []\n            # Find all crossings of midpoint_val\n            for i in range(N):\n                u_i = u_final[i]\n                u_i_plus_1 = u_final[(i + 1) % N]\n                if (u_i - midpoint_val) * (u_i_plus_1 - midpoint_val) = 0 and u_i != u_i_plus_1:\n                    x_i = x_grid[i]\n                    x_cross = x_i + dx_grid * (midpoint_val - u_i) / (u_i_plus_1 - u_i)\n                    crossings.append(x_cross)\n\n            if crossings:\n                # Find crossing closest to analytical solution\n                min_dist = float('inf')\n                best_pos = crossings[0]\n                for pos in crossings:\n                    dist = abs(pos - analytical_pos)\n                    periodic_dist = min(dist, L_domain - dist)\n                    if periodic_dist  min_dist:\n                        min_dist = periodic_dist\n                        best_pos = pos\n                return best_pos\n            else:\n                # Fallback: max gradient\n                grad = np.abs(np.roll(u_final, -1) - u_final)\n                max_grad_idx = np.argmax(grad)\n                \n                u_a = u_final[max_grad_idx]\n                u_b = u_final[(max_grad_idx + 1) % N]\n                x_a = x_grid[max_grad_idx]\n                \n                if abs(u_b - u_a)  1e-9: # Avoid division by zero\n                    return x_a + dx_grid / 2.0\n                \n                x_pos = x_a + dx_grid * (midpoint_val - u_a) / (u_b - u_a)\n                return x_pos\n\n        def periodic_map(pos, length):\n            \"\"\"Maps a position to the periodic interval [-length/2, length/2).\"\"\"\n            return -length/2 + (pos - (-length/2)) % length\n\n        x_num_cons = find_shock_location(u_cons, x, L, x_analytical, dx)\n        x_num_noncons = find_shock_location(u_noncons, x, L, x_analytical, dx)\n        \n        x_num_cons = periodic_map(x_num_cons, L)\n        x_num_noncons = periodic_map(x_num_noncons, L)\n        \n        def periodic_distance(p1, p2, length):\n            \"\"\"Calculates the absolute periodic distance between two points.\"\"\"\n            dist = abs(p1 - p2)\n            return min(dist, length - dist)\n\n        error_cons = periodic_distance(x_num_cons, x_analytical, L)\n        error_noncons = periodic_distance(x_num_noncons, x_analytical, L)\n\n        results.extend([error_cons, error_noncons])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论上的高精度在实际应用中常常会遇到边界条件的挑战。本练习聚焦于将麦考马克格式应用于有限区域时的一个关键实际问题：如何处理边界才能不损失格式的整体精度。你将通过“人造解”方法，以数值实验的方式检验不同边界处理方案对精度的影响，并学习如何设计与内部格式精度相匹配的边界格式，从而在实践中真正实现高精度计算。",
            "id": "3418379",
            "problem": "考虑线性平流方程 $u_t + a u_x = 0$，其空间域为 $x \\in [0,1]$，时间域为 $t \\in [0,T]$，且具有恒定的平流速度 $a  0$。MacCormack 预测-校正格式是一种两步显式方法，它在间距为 $\\Delta x$ 的均匀网格上，通过使用空间前向差分的预测步和空间后向差分的校正步，将离散解 $u_i^n \\approx u(x_i,t^n)$ 从时间 $t^n$推进到时间 $t^{n+1} = t^n + \\Delta t$。当空间和时间离散化均为二阶，并且在每个阶段都一致地应用光滑边界数据时，内部节点使用时间中心更新，并能达到二阶精度。然而，在没有指定物理边界条件的出流边界处，需要使用数值封闭格式来更新边界节点，并为预测步和校正步提供所需的值。即使内部格式是二阶的，在任一阶段使用一阶单边封闭格式都可能将全局精度阶降至一阶。\n\n从第一性原理出发，以控制方程 $u_t + a u_x = 0$（其中 $a0$）和一个用作制造解的光滑精确解 $u(x,t)$ 开始。利用泰勒展开的一致性，并要求离散近似在所有节点（包括边界）上与连续微分算子匹配至指定阶数。在 $x=0$ 处的入流边界，使用一个光滑的指定边界函数 $g(t) = u(0,t)$，并在适当的阶段时间应用它。分析一阶出流边界封闭格式如何在 $x=1$ 处引入一个 $\\mathcal{O}(\\Delta x)$ 阶的局部截断误差，该误差可能主导全局误差。然后，在 $x=1$ 处设计一个与 MacCormack 时间积分相一致的边界修正模板，并使用二阶单边空间导数来更新 $u_N \\approx u(1,t)$，从而使整体格式恢复二阶收敛。\n\n您的程序必须在 MacCormack 预测-校正框架内，为一个具有 $N+1$ 个节点 $x_i = i \\Delta x$（其中 $\\Delta x = 1/N$）、库朗数 $\\nu = a \\Delta t/\\Delta x$ 且 $a=1$ 的均匀网格，实现 $x=1$ 处出流边界的三种变体：\n\n- 变体 A（朴素常数外推）：在预测步和校正步中，均通过 $u_N = u_{N-1}$ 设置出流边界值。\n- 变体 B（一阶后向差分边界更新）：在预测步，使用时间 $t^n$ 处 $u_x$ 的一阶后向差分来更新 $u_N$，即 $u_N^\\star = u_N^n - a \\Delta t \\, (u_N^n - u_{N-1}^n)/\\Delta x$。在校正步，使用带有一阶后向差分的梯形时间平均来更新 $u_N$，即 $u_N^{n+1} = u_N^n + \\tfrac{1}{2} \\Delta t \\, \\left(-a \\frac{u_N^n - u_{N-1}^n}{\\Delta x} - a \\frac{u_N^\\star - u_{N-1}^\\star}{\\Delta x} \\right)$。\n- 变体 C（二阶边界修正模板）：在预测步，使用时间 $t^n$ 处 $u_x$ 的二阶后向差分来更新 $u_N$，即 $u_N^\\star = u_N^n - a \\Delta t \\, \\left( \\frac{3 u_N^n - 4 u_{N-1}^n + u_{N-2}^n}{2 \\Delta x} \\right)$。在校正步，使用带二阶后向差分的梯形时间平均来更新 $u_N$，即 $u_N^{n+1} = u_N^n + \\tfrac{1}{2} \\Delta t \\, \\left( -a \\frac{3 u_N^n - 4 u_{N-1}^n + u_{N-2}^n}{2 \\Delta x} - a \\frac{3 u_N^\\star - 4 u_{N-1}^\\star + u_{N-2}^\\star}{2 \\Delta x} \\right)$。\n\n对于所有变体，在 $x=0$ 处应用入流边界条件，使用相应阶段时间的制造精确边界值：$u_0^n = g(t^n)$ 和 $u_0^\\star = g(t^{n+1})$。对于内部节点，使用带有前向差分的标准 MacCormack 预测步和带有后向差分的校正步。\n\n使用制造解 $u(x,t) = \\sin(2 \\pi (x - a t))$（其中 $a = 1$），该解精确满足齐次平流方程。通过 $u_i^0 = \\sin(2 \\pi x_i)$ 初始化离散解，并通过 $g(t) = \\sin(-2 \\pi t)$ 设置入流边界。积分至最终时间 $T = 1$，库朗数 $\\nu = 0.8$（无量纲）。选择时间步长 $\\Delta t$ 以满足 $\\nu \\le 0.8$ 且步数为整数，并如前所述，在每个阶段时间 $t^n$ 和 $t^{n+1}$ 处强制施加 $x=0$ 的边界条件。\n\n将时间 $T$ 的离散 $\\ell^2$ 误差定义为\n$$\nE(N) = \\left( \\frac{1}{N+1} \\sum_{i=0}^N \\left( u_i^N - \\sin(2 \\pi (x_i - a T)) \\right)^2 \\right)^{1/2}.\n$$\n对于每个变体，使用 $p = \\log_2\\left( \\frac{E(N)}{E(2N)} \\right)$ 计算两个连续网格加密 $N$ 和 $2N$ 之间的观测精度阶 $p$。\n\n测试套件规范：\n- 使用网格尺寸 $N \\in \\{64, 128, 256, 512\\}$。\n- 使用平流速度 $a = 1$，库朗数 $\\nu = 0.8$，最终时间 $T = 1$（无量纲）。\n- 对于每个变体，使用两个最精细的网格 $N=256$ 和 $N=512$ 来评估观测阶。\n- 三个测试用例分别对应于上文定义的变体 A、B 和 C。\n\n您的程序必须输出一行，其中包含一个由三个浮点数组成的列表 $[p_A, p_B, p_C]$，其中 $p_A$ 是变体 A 的观测阶，$p_B$ 是变体 B 的观测阶，$p_C$ 是变体 C 的观测阶，按此顺序排列。不涉及单位。该单行必须是一个用方括号括起来的、逗号分隔的列表，除了标准格式外没有额外的空白要求。答案值为浮点数。",
            "solution": "用户希望分析用于线性平流方程的 MacCormack 格式，重点关注出流边界条件对全局精度阶的影响。\n\n### 1. 问题阐述\n\n所考虑的问题是一维线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\n其空间域为 $x \\in [0, 1]$，时间域为 $t \\in [0, T]$，且具有恒定的平流速度 $a  0$。我们将使用制造解法来验证数值格式的精度阶。选择的精确解为 $u(x,t) = \\sin(2 \\pi (x - a t))$，它满足控制方程。这提供了一个初始条件 $u(x,0) = \\sin(2 \\pi x)$ 和一个在 $x=0$ 处的入流边界条件 $g(t) = u(0,t) = \\sin(-2 \\pi a t)$。由于 $a0$，特征线在边界 $x=1$ 处流出区域，因此此处未指定物理边界条件；需要一个数值封闭格式。\n\n将区域离散化为具有 $N+1$ 个点 $x_i = i \\Delta x$（其中 $i=0, 1, \\dots, N$，$ \\Delta x = 1/N$）的均匀网格。时间上以大小为 $\\Delta t$ 的步长推进，其中 $t^n = n \\Delta t$。无量纲的 Courant-Friedrichs-Lewy (CFL) 数定义为 $\\nu = a \\Delta t / \\Delta x$。\n\n### 2. 内部 MacCormack 格式\n\nMacCormack 格式是一种显式的、两步预测-校正方法。对于内部节点 $i=1, \\dots, N-1$，格式如下：\n\n**预测步：** 使用 $u_x$ 的前向空间差分进行一次前向欧拉时间步进：\n$$\nu_i^\\star = u_i^n - a \\frac{\\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n)\n$$\n这里，$u_i^n$ 是在 $(x_i, t^n)$ 处的数值解，$u_i^\\star$ 是在一个中间时间的预测值。\n\n**校正步：** 通过平均 $t^n$ 和预测状态下的时间导数，得到新时间层 $t^{n+1} = t^n + \\Delta t$ 的最终值，这类似于梯形法则。此步中的空间导数使用预测值上的后向差分：\n$$\nu_i^{n+1} = \\frac{1}{2} \\left( u_i^n + u_i^\\star - a \\frac{\\Delta t}{\\Delta x} (u_i^\\star - u_{i-1}^\\star) \\right)\n$$\n对于内部节点，只要解足够光滑，该格式在空间和时间上都是二阶精确的，即 $\\mathcal{O}(\\Delta t^2, \\Delta x^2)$。前向差分后跟后向差分的组合对于抵消主阶误差项至关重要，从而实现二阶精度。\n\n### 3. 出流边界条件分析\n\n数值格式的全局精度由计算域中任何位置的局部截断误差 (LTE) 的最低阶决定。如果数值边界条件的精度阶低于内部格式，它会污染整个解，并降低全局收敛阶。我们分析在出流边界 $x=1$（节点 $i=N$）处的三种不同数值边界条件。\n\n*   **变体 A（朴素常数外推）：** 问题将其描述为“在预测步和校正步中，均通过 $u_N = u_{N-1}$ 设置出流边界值”。我们将其解释为一个程序性规则：\n    1.  在计算内部节点的预测值 $u_i^\\star$ 后，边界上的预测值通过外推设置：$u_N^\\star = u_{N-1}^\\star$。\n    2.  在计算内部节点的校正值 $u_i^{n+1}$ 后，边界上的最终值通过外推设置：$u_N^{n+1} = u_{N-1}^{n+1}$。\n    这是零阶外推，等价于假设 $(\\partial u / \\partial x)_N = 0$。这通常与偏微分方程的解不一致。这在边界处引入了 $\\mathcal{O}(\\Delta x)$ 阶的局部截断误差。单个点上的一阶局部误差足以将整个格式的全局精度降低到一阶，即 $\\mathcal{O}(\\Delta x)$。\n\n*   **变体 B（一阶后向差分更新）：** 该变体使用与控制方程 $u_t = -a u_x$ 一致的模板来更新边界值 $u_N$，但空间差分为一阶精度。\n    -   预测步：$u_N^\\star = u_N^n - a \\Delta t \\left( \\frac{u_N^n - u_{N-1}^n}{\\Delta x} \\right)$。这是一个时间上的前向欧拉步，空间上使用一阶后向差分计算 $u_x$。\n    -   校正步：$u_N^{n+1} = u_N^n - \\frac{a \\Delta t}{2} \\left[ \\left(\\frac{u_N^n - u_{N-1}^n}{\\Delta x}\\right) + \\left(\\frac{u_N^\\star - u_{N-1}^\\star}{\\Delta x}\\right) \\right]$。这使用了梯形法则进行时间积分，其时间精度为二阶。\n    然而，空间离散化仍然是一阶精确的。MacCormack 格式的二阶精度依赖于前向预测步和后向校正步误差的特定对称抵消。通过在预测阶段使用后向差分（或除前向差分外的任何模板），这种误差抵消机制在边界及相邻节点处被破坏。边界附近的局部截断误差为 $\\mathcal{O}(\\Delta x^2)$，但抵消机制的破坏通常导致一阶的全局误差，即 $\\mathcal{O}(\\Delta x)$。\n\n*   **变体 C（二阶边界修正模板）：** 为了恢复二阶精度，数值边界条件本身必须至少是二阶精确的。该变体在边界节点 $i=N$ 处使用二阶精度的单边（后向）差分来计算空间导数 $u_x$。该模板由以下公式给出：\n    $$\n    \\left( \\frac{\\partial u}{\\partial x} \\right)_N \\approx \\frac{3 u_N - 4 u_{N-1} + u_{N-2}}{2 \\Delta x} + \\mathcal{O}(\\Delta x^2)\n    $$\n    此近似被用于与内部 MacCormack 方法一致的时间积分格式中：\n    -   预测步：$u_N^\\star = u_N^n - a \\Delta t \\left( \\frac{3 u_N^n - 4 u_{N-1}^n + u_{N-2}^n}{2 \\Delta x} \\right)$。\n    -   校正步：$u_N^{n+1} = u_N^n - \\frac{a \\Delta t}{2} \\left[ \\left(\\frac{3 u_N^n - 4 u_{N-1}^n + u_{N-2}^n}{2 \\Delta x}\\right) + \\left(\\frac{3 u_N^\\star - 4 u_{N-1}^\\star + u_{N-2}^\\star}{2 \\Delta x}\\right) \\right]$。\n    由于此边界更新的 LTE 为 $\\mathcal{O}(\\Delta x^2, \\Delta t^2)$，它与内部格式的二阶精度相匹配。因此，整个计算的全局精度阶预计为二阶，即 $\\mathcal{O}(\\Delta x^2)$。\n\n### 4. 实现与验证\n\n一个 Python 程序将实现这三种变体。对于每个变体，在一系列加密的网格尺寸（$N=256, 512$）上运行模拟。在最终时间 $T=1$ 时，通过将数值解与精确制造解进行比较，计算离散 $\\ell^2$ 误差 $E(N)$。然后，使用来自两个最精细网格的误差计算观测到的精度阶 $p$：\n$$\np = \\log_2\\left( \\frac{E(N)}{E(2N)} \\right)\n$$\n我们期望得到 $p_A \\approx 1$，$p_B \\approx 1$ 和 $p_C \\approx 2$。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(N, variant, a, nu, T):\n    \"\"\"\n    Solves the 1D linear advection equation using the MacCormack scheme\n    with specified outflow boundary condition variants.\n\n    Args:\n        N (int): Number of spatial intervals.\n        variant (str): Outflow boundary condition variant ('A', 'B', or 'C').\n        a (float): Advection speed.\n        nu (float): Courant number.\n        T (float): Final time.\n\n    Returns:\n        float: The discrete l2-error at the final time.\n    \"\"\"\n    # 1. Grid and Time Step Setup\n    dx = 1.0 / N\n    dt_ideal = nu * dx / a\n    # Ensure an integer number of steps to reach T exactly\n    num_steps = int(round(T / dt_ideal))\n    dt = T / num_steps\n    # Recalculate Courant number based on adjusted dt\n    nu = a * dt / dx\n\n    x = np.linspace(0.0, 1.0, N + 1)\n\n    # 2. Define Exact Solution and Boundary Conditions\n    def u_exact(x_coords, t_val):\n        return np.sin(2 * np.pi * (x_coords - a * t_val))\n\n    def g(t_val):\n        return np.sin(-2 * np.pi * a * t_val)\n\n    # 3. Initial Condition\n    u = u_exact(x, 0.0)\n    t = 0.0\n\n    # 4. Time-stepping Loop\n    for _ in range(num_steps):\n        u_old = u.copy()\n        t_next = t + dt\n\n        # --- Predictor Stage ---\n        u_star = np.zeros_like(u_old)\n\n        # Inflow boundary condition (i=0) as specified for the predicted state\n        u_star[0] = g(t_next)\n\n        # Interior nodes (i=1 to N-1) using forward difference\n        u_star[1:N] = u_old[1:N] - nu * (u_old[2:] - u_old[1:N])\n\n        # Outflow boundary condition (i=N) for the predictor stage\n        if variant == 'A':\n            # Naive constant extrapolation of the predicted value\n            u_star[N] = u_star[N-1]\n        elif variant == 'B':\n            # First-order backward-difference update\n            u_star[N] = u_old[N] - nu * (u_old[N] - u_old[N-1])\n        elif variant == 'C':\n            # Second-order backward-difference update\n            u_star[N] = u_old[N] - (nu / 2.0) * (3 * u_old[N] - 4 * u_old[N-1] + u_old[N-2])\n\n        # --- Corrector Stage ---\n        u_new = np.zeros_like(u_old)\n\n        # Inflow boundary condition (i=0) for the final state\n        u_new[0] = g(t_next)\n\n        # Interior nodes (i=1 to N-1) using backward difference\n        u_new[1:N] = 0.5 * (u_old[1:N] + u_star[1:N] - nu * (u_star[1:N] - u_star[0:N-1]))\n\n        # Outflow boundary condition (i=N) for the corrector stage\n        if variant == 'A':\n            # Naive constant extrapolation of the final value\n            u_new[N] = u_new[N-1]\n        elif variant == 'B':\n            # First-order trapezoidal update\n            u_new[N] = u_old[N] - (nu / 2.0) * ((u_old[N] - u_old[N-1]) + (u_star[N] - u_star[N-1]))\n        elif variant == 'C':\n            # Second-order trapezoidal update\n            u_new[N] = u_old[N] - (nu / 4.0) * (\n                (3 * u_old[N] - 4 * u_old[N-1] + u_old[N-2]) +\n                (3 * u_star[N] - 4 * u_star[N-1] + u_star[N-2])\n            )\n\n        u = u_new\n        t = t_next\n\n    # 5. Compute Error\n    u_e = u_exact(x, T)\n    error = np.sqrt(np.mean((u - u_e)**2))\n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and compute the order of accuracy.\n    \"\"\"\n    # Test Suite Specification\n    a = 1.0\n    nu_target = 0.8\n    T = 1.0\n    variants = ['A', 'B', 'C']\n    Ns = [256, 512]\n    \n    orders = []\n\n    for variant in variants:\n        errors = []\n        for N in Ns:\n            error = run_simulation(N, variant, a, nu_target, T)\n            errors.append(error)\n        \n        # Calculate observed order of accuracy p = log2(E(N) / E(2N))\n        # N=Ns[0], 2N=Ns[1]\n        order = np.log2(errors[0] / errors[1])\n        orders.append(order)\n\n    # Format the final output string\n    result_str = f\"[{orders[0]},{orders[1]},{orders[2]}]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}