{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any finite difference method lies in the accurate approximation of derivatives using values at discrete grid points. This first practice takes you back to basics, guiding you through the derivation of the celebrated 5-point stencil for the 2D Laplacian using Taylor series expansions . Mastering this derivation is crucial, as it reveals the origin of the stencil's structure and the source of its second-order accuracy, forming the theoretical bedrock for solving a vast class of elliptic partial differential equations.",
            "id": "3310233",
            "problem": "Consider the steady diffusion model in two spatial dimensions, governed by the Laplace operator appearing in many Computational Fluid Dynamics (CFD) applications as a canonical Partial Differential Equation (PDE). Let $\\Omega = (0,1)\\times(0,1)$ and let $\\{(x_i,y_j)\\}$ be a uniform Cartesian grid with spacing $h$ in both directions, so that $x_i = i h$ and $y_j = j h$ for integers $i$ and $j$. Denote the grid function values by $u_{i,j} = u(x_i,y_j)$. Starting from the coordinate definition of the Laplacian, $\\nabla^{2} u = \\frac{\\partial^{2} u}{\\partial x^{2}} + \\frac{\\partial^{2} u}{\\partial y^{2}}$, and using multivariate Taylor series expansions about an interior node $(x_i,y_j)$, construct a second-order accurate 5-point finite difference stencil for the two-dimensional Laplacian on this grid. Then, using this approximation, derive the discrete interior-node equation associated with the Poisson form $-\\,\\nabla^{2} u = f$, where $f$ is smooth.\n\nYour derivation must begin solely from the definition of the Laplacian and Taylorâ€™s theorem, and it must make no use of any pre-quoted finite difference formulas. As your final answer, provide the explicit expression for the discrete Laplacian operator $\\Delta_h u_{i,j}$ at an interior node $(i,j)$ on this uniform grid, expressed only in terms of $u_{i,j}$ and its four face-adjacent neighbors and the mesh spacing $h$. The final answer must be a single closed-form analytic expression without units.",
            "solution": "The problem requires the derivation of the second-order accurate 5-point finite difference stencil for the two-dimensional Laplacian operator, $\\nabla^{2} u$, on a uniform Cartesian grid. The derivation must proceed from first principles using Taylor series expansions. Subsequently, this stencil will be used to write the discrete form of the Poisson equation, $-\\nabla^{2} u = f$.\n\nThe two-dimensional Laplacian operator in Cartesian coordinates is defined as:\n$$\n\\nabla^{2} u = \\frac{\\partial^{2} u}{\\partial x^{2}} + \\frac{\\partial^{2} u}{\\partial y^{2}}\n$$\nWe will derive finite difference approximations for each second-order partial derivative separately at an interior grid node $(x_i, y_j)$. The grid is uniform with spacing $h$ in both directions, such that $x_{i\\pm1} = x_i \\pm h$ and $y_{j\\pm1} = y_j \\pm h$. We use the notation $u_{i,j} = u(x_i, y_j)$.\n\nFirst, consider the partial derivative with respect to $x$, $\\frac{\\partial^{2} u}{\\partial x^{2}}$. We use Taylor series expansions for $u(x_i+h, y_j)$ and $u(x_i-h, y_j)$ about the point $(x_i, y_j)$. Assuming the function $u(x,y)$ is sufficiently smooth, the expansions are:\n$$\nu(x_i+h, y_j) = u_{i+1,j} = u_{i,j} + h \\left(\\frac{\\partial u}{\\partial x}\\right)_{i,j} + \\frac{h^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} + \\frac{h^3}{3!} \\left(\\frac{\\partial^3 u}{\\partial x^3}\\right)_{i,j} + \\frac{h^4}{4!} \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + O(h^5)\n$$\n$$\nu(x_i-h, y_j) = u_{i-1,j} = u_{i,j} - h \\left(\\frac{\\partial u}{\\partial x}\\right)_{i,j} + \\frac{h^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} - \\frac{h^3}{3!} \\left(\\frac{\\partial^3 u}{\\partial x^3}\\right)_{i,j} + \\frac{h^4}{4!} \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + O(h^5)\n$$\nAdding these two equations eliminates the odd-order derivative terms:\n$$\nu_{i+1,j} + u_{i-1,j} = 2u_{i,j} + h^2 \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} + \\frac{2h^4}{24} \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + O(h^6)\n$$\nRearranging this expression to solve for the second partial derivative gives:\n$$\n\\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} - \\frac{h^2}{12} \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + O(h^4)\n$$\nThis provides a finite difference approximation for $\\frac{\\partial^{2} u}{\\partial x^{2}}$. The leading term of the truncation error is proportional to $h^2$, making this a second-order accurate central difference scheme.\n\nBy an analogous procedure for the $y$-direction, we consider the Taylor expansions for $u(x_i, y_j+h)$ and $u(x_i, y_j-h)$:\n$$\nu(x_i, y_j+h) = u_{i,j+1} = u_{i,j} + h \\left(\\frac{\\partial u}{\\partial y}\\right)_{i,j} + \\frac{h^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial y^2}\\right)_{i,j} + \\frac{h^3}{3!} \\left(\\frac{\\partial^3 u}{\\partial y^3}\\right)_{i,j} + O(h^4)\n$$\n$$\nu(x_i, y_j-h) = u_{i,j-1} = u_{i,j} - h \\left(\\frac{\\partial u}{\\partial y}\\right)_{i,j} + \\frac{h^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial y^2}\\right)_{i,j} - \\frac{h^3}{3!} \\left(\\frac{\\partial^3 u}{\\partial y^3}\\right)_{i,j} + O(h^4)\n$$\nAdding these two expansions and rearranging yields the approximation for $\\frac{\\partial^{2} u}{\\partial y^{2}}$:\n$$\n\\left(\\frac{\\partial^2 u}{\\partial y^2}\\right)_{i,j} = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} - \\frac{h^2}{12} \\left(\\frac{\\partial^4 u}{\\partial y^4}\\right)_{i,j} + O(h^4)\n$$\nThis is also a second-order accurate central difference approximation.\n\nWe can now construct the approximation for the Laplacian operator by summing the approximations for the two second partial derivatives:\n$$\n(\\nabla^2 u)_{i,j} = \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} + \\left(\\frac{\\partial^2 u}{\\partial y^2}\\right)_{i,j}\n$$\nSubstituting the derived expressions:\n$$\n(\\nabla^2 u)_{i,j} = \\left[ \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} \\right] + \\left[ \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} \\right] + T_{i,j}\n$$\nwhere $T_{i,j}$ is the local truncation error, given by:\n$$\nT_{i,j} = - \\frac{h^2}{12} \\left[ \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + \\left(\\frac{\\partial^4 u}{\\partial y^4}\\right)_{i,j} \\right] + O(h^4)\n$$\nSince the leading error term is proportional to $h^2$, the resulting scheme is second-order accurate.\n\nBy dropping the truncation error terms, we obtain the discrete Laplacian operator, denoted by $\\Delta_h$, acting on the grid function $u_{i,j}$:\n$$\n(\\nabla^2 u)_{i,j} \\approx \\Delta_h u_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2}\n$$\nThis expression is the 5-point finite difference stencil for the Laplacian, as it involves the central node $(i,j)$ and its four face-adjacent neighbors: $(i+1,j)$, $(i-1,j)$, $(i,j+1)$, and $(i,j-1)$.\n\nFinally, to derive the discrete interior-node equation for the Poisson form $-\\nabla^{2} u = f$, we replace the continuous operator and functions with their discrete counterparts at the node $(x_i, y_j)$:\n$$\n- (\\nabla^2 u)_{i,j} = f(x_i, y_j)\n$$\nSubstituting the discrete Laplacian operator $\\Delta_h u_{i,j}$ and setting $f_{i,j}=f(x_i,y_j)$ yields the discrete equation:\n$$\n- \\left( \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} \\right) = f_{i,j}\n$$\nThis is the discrete equation for an interior node. The final answer requested is the expression for the discrete Laplacian operator $\\Delta_h u_{i,j}$ itself.",
            "answer": "$$\n\\boxed{\\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2}}\n$$"
        },
        {
            "introduction": "A theoretical derivation, like the one for the 5-point stencil, comes with a prediction about its accuracy, encapsulated in the local truncation error. This next practice transitions from pen-and-paper theory to computational verification, where you will write a program to numerically measure the local truncation error and confirm that the 5-point stencil is indeed second-order accurate . By observing the error decrease as a function of grid spacing $h$, you will gain a concrete, quantitative understanding of what convergence rate means for a discrete operator.",
            "id": "2406729",
            "problem": "Write a complete, runnable program that, for smooth functions in two spatial dimensions, analyzes the local truncation error of the standard 5-point stencil approximation to the two-dimensional Laplace operator as a function of the grid spacing $h$, and confirms that it is of order $O(h^2)$. Use the following precise mathematical definitions.\n\nFor a smooth function $u:\\mathbb{R}^2 \\to \\mathbb{R}$ and grid spacing $h>0$, define the discrete 5-point stencil approximation to the Laplacian at a point $(x,y)$ by\n$$\n\\Delta_h u(x,y) \\;=\\; \\frac{u(x+h,y)+u(x-h,y)+u(x,y+h)+u(x,y-h)-4\\,u(x,y)}{h^2}.\n$$\nDefine the local truncation error $\\tau_h$ at $(x_0,y_0)$ by\n$$\n\\tau_h(x_0,y_0) \\;=\\; \\Delta_h u(x_0,y_0)\\;-\\;\\Delta u(x_0,y_0),\n$$\nwhere $\\Delta u \\equiv u_{xx}+u_{yy}$ is the continuous Laplace operator. All angles appearing in trigonometric functions must be interpreted in radians.\n\nYour program must evaluate $\\tau_h$ numerically according to the definition above and, based solely on those evaluations at specified $h$ values, produce quantitative evidence of the scaling $\\tau_h=O(h^2)$ in the form of real numbers as specified in the test suite below.\n\nTest suite to implement exactly:\n- Case $1$ (general smooth trigonometric): $u_1(x,y)=\\sin(x)\\cos(y)$, point $(x_0,y_0)=(0.3,-0.2)$, spacings $h_k=2^{-k}$ for $k\\in\\{1,2,3,4,5,6\\}$. Output a single real number $p_1$ representing the observed convergence order in $h$ inferred from the data $\\{(h_k,\\lvert \\tau_{h_k}(x_0,y_0)\\rvert)\\}$.\n- Case $2$ (general smooth exponential): $u_2(x,y)=\\exp(x+2y)$, point $(x_0,y_0)=(-0.7,0.4)$, spacings $h_k=2^{-k}$ for $k\\in\\{1,2,3,4,5,6\\}$. Output a single real number $p_2$ representing the observed convergence order in $h$ inferred from the data $\\{(h_k,\\lvert \\tau_{h_k}(x_0,y_0)\\rvert)\\}$.\n- Case $3$ (edge case with a quartic polynomial): $u_3(x,y)=x^4+y^4$, point $(x_0,y_0)=(0.5,-0.5)$, spacing $h=2^{-3}$. Output a single real number $c_3$ equal to the ratio $\\lvert \\tau_h(x_0,y_0)\\rvert/h^2$.\n\nYour program must produce as its final output a single line containing a Python list literal with three real numbers $[p_1,p_2,c_3]$, where $p_1$ and $p_2$ quantify the observed order of accuracy and $c_3$ quantifies the leading-order coefficient in Case $3$. All three real numbers must be rounded to exactly three digits after the decimal point. No physical units are involved in the answer, and all angles must be in radians. The final line format must be exactly one line of the form $[p_1,p_2,c_3]$ with comma separation and no additional text.",
            "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded, well-posed, and objective. It presents a standard problem in the numerical analysis of partial differential equations, with all necessary data and definitions provided. The task is to analyze the local truncation error of the 5-point finite difference stencil for the two-dimensional Laplacian, a fundamental concept in computational physics.\n\nThe analysis begins with the Taylor series expansion of a sufficiently smooth function $u(x,y)$ around a point $(x,y)$. The expansions in the $x$-direction are:\n$$\nu(x+h, y) = u + h u_x + \\frac{h^2}{2!} u_{xx} + \\frac{h^3}{3!} u_{xxx} + \\frac{h^4}{4!} u_{xxxx} + O(h^5)\n$$\n$$\nu(x-h, y) = u - h u_x + \\frac{h^2}{2!} u_{xx} - \\frac{h^3}{3!} u_{xxx} + \\frac{h^4}{4!} u_{xxxx} - O(h^5)\n$$\nwhere all partial derivatives are evaluated at $(x,y)$. Summing these two expressions cancels the odd-order derivative terms:\n$$\nu(x+h,y) + u(x-h,y) = 2u + h^2 u_{xx} + \\frac{h^4}{12} u_{xxxx} + O(h^6)\n$$\nAn analogous expression holds for the expansions in the $y$-direction:\n$$\nu(x,y+h) + u(x,y-h) = 2u + h^2 u_{yy} + \\frac{h^4}{12} u_{yyyy} + O(h^6)\n$$\nThe discrete Laplacian operator $\\Delta_h u(x,y)$ is defined as:\n$$\n\\Delta_h u(x,y) = \\frac{u(x+h,y)+u(x-h,y)+u(x,y+h)+u(x,y-h)-4u(x,y)}{h^2}\n$$\nSubstituting the Taylor series sums into this definition yields:\n$$\n\\Delta_h u(x,y) = \\frac{(2u + h^2 u_{xx} + \\frac{h^4}{12} u_{xxxx}) + (2u + h^2 u_{yy} + \\frac{h^4}{12} u_{yyyy}) - 4u + O(h^6)}{h^2}\n$$\n$$\n\\Delta_h u(x,y) = \\frac{h^2(u_{xx} + u_{yy}) + \\frac{h^4}{12}(u_{xxxx} + u_{yyyy}) + O(h^6)}{h^2}\n$$\n$$\n\\Delta_h u(x,y) = (u_{xx} + u_{yy}) + \\frac{h^2}{12}(u_{xxxx} + u_{yyyy}) + O(h^4)\n$$\nThe continuous Laplacian is $\\Delta u = u_{xx} + u_{yy}$. The local truncation error $\\tau_h$ is the difference between the discrete and continuous operators:\n$$\n\\tau_h(x,y) = \\Delta_h u(x,y) - \\Delta u(x,y) = \\frac{h^2}{12}(u_{xxxx} + u_{yyyy}) + O(h^4)\n$$\nThis derivation rigorously shows that the leading term of the error is proportional to $h^2$, and thus $\\tau_h = O(h^2)$. For small $h$, the magnitude of the error can be approximated as $|\\tau_h| \\approx C h^p$, where $p$ is the order of convergence. To find $p$ from numerical data, we take the natural logarithm:\n$$\n\\ln(|\\tau_h|) \\approx \\ln(C) + p \\ln(h)\n$$\nThis reveals a linear relationship between $\\ln(|\\tau_h|)$ and $\\ln(h)$, where the slope is the order of convergence $p$. We can therefore compute $p$ by performing a linear least-squares regression on the data points $(\\ln(h_k), \\ln(|\\tau_{h_k}|))$.\n\nThe problem requires implementation of this analysis for three specific cases.\n\nFor Case $1$ and Case $2$, we must find the observed order of convergence, $p_1$ and $p_2$. For each case, the test function $u(x,y)$ and its analytical Laplacian $\\Delta u(x,y)$ are defined. We compute $\\tau_{h_k}$ for a sequence of grid spacings $h_k = 2^{-k}$. Then, we compute the slope of the line of best fit for $\\ln(|\\tau_{h_k}|)$ versus $\\ln(h_k)$ using `numpy.polyfit` to determine the order $p$.\n- For $u_1(x,y) = \\sin(x)\\cos(y)$, the continuous Laplacian is $\\Delta u_1 = -\\sin(x)\\cos(y) - \\sin(x)\\cos(y) = -2\\sin(x)\\cos(y)$.\n- For $u_2(x,y) = \\exp(x+2y)$, the continuous Laplacian is $\\Delta u_2 = \\exp(x+2y) + 4\\exp(x+2y) = 5\\exp(x+2y)$.\n\nFor Case $3$, the function is a quartic polynomial, $u_3(x,y)=x^4+y^4$. For such a function, all partial derivatives of order higher than four are identically zero. The Taylor series expansion becomes exact, and the $O(h^4)$ term in the expression for $\\tau_h$ vanishes.\nThe fourth derivatives are $u_{xxxx} = 24$ and $u_{yyyy} = 24$. Therefore, the truncation error is given exactly by the leading term:\n$$\n\\tau_h(x,y) = \\frac{h^2}{12}(u_{xxxx} + u_{yyyy}) = \\frac{h^2}{12}(24 + 24) = 4h^2\n$$\nThis result is independent of the point $(x,y)$. The problem asks for the ratio $c_3 = |\\tau_h(x_0,y_0)|/h^2$ for a specific $h$. Based on the analytical derivation, this ratio must be exactly $4$. The program will compute this value numerically to confirm the theoretical result. The continuous Laplacian required for the numerical computation of $\\tau_h$ is $\\Delta u_3 = 12x^2 + 12y^2$.\n\nThe final program will implement these calculations, round the resulting numbers $p_1, p_2, c_3$ to three decimal places, and present them in the specified list format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the order of convergence and error coefficients for the 5-point\n    stencil approximation of the 2D Laplacian.\n    \"\"\"\n\n    # === Case 1: u(x,y) = sin(x)cos(y) ===\n    def u1(x, y):\n        return np.sin(x) * np.cos(y)\n\n    def delta_u1(x, y):\n        # u_xx = -sin(x)cos(y), u_yy = -sin(x)cos(y)\n        return -2.0 * np.sin(x) * np.cos(y)\n\n    # === Case 2: u(x,y) = exp(x+2y) ===\n    def u2(x, y):\n        return np.exp(x + 2.0 * y)\n    \n    def delta_u2(x, y):\n        # u_xx = exp(x+2y), u_yy = 4*exp(x+2y)\n        return 5.0 * np.exp(x + 2.0 * y)\n\n    # === Case 3: u(x,y) = x^4 + y^4 ===\n    def u3(x, y):\n        return x**4 + y**4\n\n    def delta_u3(x, y):\n        # u_xx = 12x^2, u_yy = 12y^2\n        return 12.0 * (x**2 + y**2)\n\n    def discrete_laplacian(u_func, x, y, h):\n        \"\"\"Computes the 5-point stencil discrete Laplacian.\"\"\"\n        u_iph = u_func(x + h, y)\n        u_imh = u_func(x - h, y)\n        u_jph = u_func(x, y + h)\n        u_jmh = u_func(x, y - h)\n        u_ij = u_func(x, y)\n        return (u_iph + u_imh + u_jph + u_jmh - 4.0 * u_ij) / h**2\n\n    def get_convergence_order(u_func, delta_u_func, x0, y0, h_values):\n        \"\"\"\n        Calculates the convergence order by performing a linear fit on\n        the log-log plot of truncation error vs. grid spacing.\n        \"\"\"\n        errors = []\n        for h in h_values:\n            delta_h_u = discrete_laplacian(u_func, x0, y0, h)\n            analytic_delta_u = delta_u_func(x0, y0)\n            tau_h = delta_h_u - analytic_delta_u\n            errors.append(np.abs(tau_h))\n        \n        log_h = np.log(h_values)\n        log_error = np.log(errors)\n        \n        # Fit a line: log_error = p * log_h + C\n        # The slope p is the order of convergence.\n        p, _ = np.polyfit(log_h, log_error, 1)\n        return p\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1,\n            \"u_func\": u1,\n            \"delta_u_func\": delta_u1,\n            \"point\": (0.3, -0.2),\n            \"h_k_range\": range(1, 7)\n        },\n        {\n            \"id\": 2,\n            \"u_func\": u2,\n            \"delta_u_func\": delta_u2,\n            \"point\": (-0.7, 0.4),\n            \"h_k_range\": range(1, 7)\n        },\n        {\n            \"id\": 3,\n            \"u_func\": u3,\n            \"delta_u_func\": delta_u3,\n            \"point\": (0.5, -0.5),\n            \"h\": 2.0**(-3)\n        },\n    ]\n\n    results = []\n    \n    # Process Case 1\n    case1 = test_cases[0]\n    x0_1, y0_1 = case1[\"point\"]\n    h_values_1 = [2.0**(-k) for k in case1[\"h_k_range\"]]\n    p1 = get_convergence_order(case1[\"u_func\"], case1[\"delta_u_func\"], x0_1, y0_1, h_values_1)\n    \n    # Process Case 2\n    case2 = test_cases[1]\n    x0_2, y0_2 = case2[\"point\"]\n    h_values_2 = [2.0**(-k) for k in case2[\"h_k_range\"]]\n    p2 = get_convergence_order(case2[\"u_func\"], case2[\"delta_u_func\"], x0_2, y0_2, h_values_2)\n\n    # Process Case 3\n    case3 = test_cases[2]\n    x0_3, y0_3 = case3[\"point\"]\n    h_3 = case3[\"h\"]\n    delta_h_u3 = discrete_laplacian(case3[\"u_func\"], x0_3, y0_3, h_3)\n    analytic_delta_u3 = case3[\"delta_u_func\"](x0_3, y0_3)\n    tau_h3 = delta_h_u3 - analytic_delta_u3\n    c3 = np.abs(tau_h3) / h_3**2\n    \n    # Final print statement in the exact required format.\n    print(f\"[{p1:.3f},{p2:.3f},{c3:.3f}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a verified discrete operator in hand, the ultimate goal is to solve a full boundary value problem. This final practice brings everything together by using the 5-point stencil to discretize and solve the Poisson equation on a unit square . You will implement a grid refinement study using the method of manufactured solutions to demonstrate that the local second-order accuracy of the stencil translates into global second-order convergence for the numerical solution, a cornerstone concept in the validation of numerical methods.",
            "id": "3453785",
            "problem": "Design and implement a refinement study for the scalar Poisson problem on the unit square that verifies the second-order convergence of a finite difference scheme based on the 5-point stencil for the two-dimensional Laplacian. The problem domain is $\\Omega = (0,1)\\times(0,1)$. Consider the boundary value problem $- \\Delta u = f$ on $\\Omega$ with Dirichlet boundary conditions $u|_{\\partial \\Omega} = g$, where $g$ is chosen consistently from a smooth manufactured exact solution $u$. Your task is to construct and solve the discrete linear system arising from second-order central differences on a uniform grid, compute discrete $L^2$ errors for a sequence of grid spacings $h$, and estimate the observed convergence rate.\n\nStart from the following fundamental bases:\n- The definition of the Laplacian $\\Delta u = \\partial^2 u/\\partial x^2 + \\partial^2 u/\\partial y^2$.\n- The second-order central difference approximation to the one-dimensional second derivative constructed via Taylor expansions about a grid point.\n- The discrete $L^2$ norm on a uniform grid with spacing $h$, defined as $\\|e_h\\|_{L^2_h} = \\left(h^2 \\sum_{i,j} |e_{i,j}|^2\\right)^{1/2}$ for an error field $e_{i,j}$ sampled at interior grid points.\n\nYou must not use any pre-stated stencil formula in your derivation of the discrete operator; derive the 5-point stencil starting from the Taylor expansions and combine the one-dimensional approximations dimension by dimension.\n\nConstruct a uniform Cartesian grid with $n$ interior points per direction and spacing $h = 1/(n+1)$ for each refinement level. Assemble the linear system corresponding to the discrete operator for $- \\Delta$ with Dirichlet boundary conditions enforced by incorporating boundary values into the right-hand side. Solve the linear system for the interior unknowns using any robust direct linear solver.\n\nDefine the discrete $L^2$ error at grid spacing $h$ as\n$$\nE(h) = \\left(h^2 \\sum_{i=1}^{n}\\sum_{j=1}^{n}\\left(u_h(x_i,y_j) - u(x_i,y_j)\\right)^2\\right)^{1/2},\n$$\nwhere $x_i = i h$, $y_j = j h$, and $u_h$ is the numerical solution defined on the interior nodes. For successive mesh spacings $h$ and $h/2$, define the observed order\n$$\np(h \\to h/2) = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)}.\n$$\n\nImplement a refinement study for each manufactured exact solution $u$ listed in the test suite below, using the sequence of interior grid sizes $\\{n\\} = \\{7, 15, 31, 63\\}$, which corresponds to spacings $h \\in \\{1/8, 1/16, 1/32, 1/64\\}$. For each $u$, compute the sequence of errors $\\{E(h)\\}$ and the sequence of observed orders $\\{p(h \\to h/2)\\}$ for the three refinement steps. Report, for each $u$, the observed order based on the two finest levels (that is, between $h=1/32$ and $h=1/64$), and also report a boolean indicating whether all three observed orders lie within the tolerance interval $[1.8, 2.2]$.\n\nTest suite:\n- Case $\\mathrm{A}$ (zero boundary data): $u(x,y) = \\sin(2\\pi x)\\,\\sin(3\\pi y)$, so that $f(x,y) = -\\Delta u(x,y) = \\left((2\\pi)^2 + (3\\pi)^2\\right) \\sin(2\\pi x)\\,\\sin(3\\pi y)$ and $g$ is $u$ restricted to $\\partial \\Omega$.\n- Case $\\mathrm{B}$ (nonzero boundary data, exponential): $u(x,y) = e^{x+y}$, so that $f(x,y) = -\\Delta u(x,y) = -2 e^{x+y}$ and $g$ is $u$ restricted to $\\partial \\Omega$.\n- Case $\\mathrm{C}$ (polynomial with mixed boundary behavior): $u(x,y) = x^2 y^2$, so that $f(x,y) = -\\Delta u(x,y) = -2(x^2 + y^2)$ and $g$ is $u$ restricted to $\\partial \\Omega$.\n\nYour program should:\n- For each of the three cases, perform the refinement study on the specified grid sequence, compute the error sequence $\\{E(h)\\}$, compute the observed orders $\\{p(h \\to h/2)\\}$, extract the finest-level observed order $p_\\mathrm{fine}$ from the last refinement step, and check whether all three observed orders lie in $[1.8, 2.2]$.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order: the three finest-level observed orders (one per case, as floating-point numbers), followed by three booleans (one per case) indicating whether all observed orders for that case are within $[1.8, 2.2]$. For example, the output must have the format\n$[p_{\\mathrm{A}}, p_{\\mathrm{B}}, p_{\\mathrm{C}}, b_{\\mathrm{A}}, b_{\\mathrm{B}}, b_{\\mathrm{C}}]$,\nwhere each $p_{\\mathrm{case}}$ is a floating-point number and each $b_{\\mathrm{case}}$ is either True or False.\n\nAll quantities are nondimensional; no physical units are required. Angles, where present in trigonometric functions, are in radians. The program must be completely self-contained, accept no input, and print exactly one line in the specified format.",
            "solution": "The problem requires the design and implementation of a numerical verification study for a second-order finite difference scheme applied to the two-dimensional Poisson equation, $-\\Delta u = f$, on the unit square domain $\\Omega = (0,1) \\times (0,1)$ with Dirichlet boundary conditions $u|_{\\partial\\Omega} = g$. The core of the task is to derive the discrete operator, construct and solve the resulting linear system, and perform a refinement study to confirm the method's theoretical second-order convergence. This is accomplished using the method of manufactured solutions.\n\nFirst, we derive the necessary finite difference approximation for the Laplacian operator, $\\Delta = \\partial^2/\\partial x^2 + \\partial^2/\\partial y^2$. This is done by first principles using Taylor series expansions. For a sufficiently smooth one-dimensional function $u(x)$, the expansions about a point $x_i$ for a step size $h$ are:\n$$\nu(x_i + h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) + O(h^5)\n$$\n$$\nu(x_i - h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) - O(h^5)\n$$\nSumming these two expressions serves to cancel the odd-order derivative terms, yielding:\n$$\nu(x_i + h) + u(x_i - h) = 2u(x_i) + h^2 u''(x_i) + \\frac{h^4}{12} u^{(4)}(x_i) + O(h^6)\n$$\nBy rearranging this equation to isolate the second derivative, we obtain:\n$$\nu''(x_i) = \\frac{u(x_i - h) - 2u(x_i) + u(x_i + h)}{h^2} - \\frac{h^2}{12} u^{(4)}(x_i) + O(h^4)\n$$\nThis provides the standard second-order central difference approximation for the second derivative, with a leading truncation error term of $O(h^2)$.\n\nTo discretize the two-dimensional Laplacian, we set up a uniform Cartesian grid on the domain with grid points $(x_i, y_j) = (ih, jh)$, where $h=1/(n+1)$ is the grid spacing in both directions and the indices for interior points are $i,j \\in \\{1, 2, \\dots, n\\}$. Let $u_{i,j} = u(x_i, y_j)$. We apply the one-dimensional approximation along each coordinate axis at a generic interior point $(x_i, y_j)$:\n$$\n\\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{(x_i, y_j)} \\approx \\frac{u_{i-1,j} - 2u_{i,j} + u_{i+1,j}}{h^2}\n$$\n$$\n\\left.\\frac{\\partial^2 u}{\\partial y^2}\\right|_{(x_i, y_j)} \\approx \\frac{u_{i,j-1} - 2u_{i,j} + u_{i,j+1}}{h^2}\n$$\nThe Laplacian is the sum of these partial derivatives. Summing the approximations yields the well-known 5-point stencil for the Laplacian:\n$$\n(\\Delta u)_{i,j} \\approx \\frac{u_{i-1,j} + u_{i+1,j} + u_{i,j-1} + u_{i,j+1} - 4u_{i,j}}{h^2}\n$$\nThe local truncation error for this approximation is $O(h^2)$, provided the solution $u$ possesses sufficiently high-order continuous derivatives.\n\nSubstituting this discrete operator into the Poisson equation, $-\\Delta u = f$, we obtain a linear equation for each interior grid point $(x_i, y_j)$:\n$$\n-\\frac{u_{i-1,j} + u_{i+1,j} + u_{i,j-1} + u_{i,j+1} - 4u_{i,j}}{h^2} \\approx f(x_i, y_j)\n$$\nMultiplying by $-h^2$ and rearranging leads to the discrete equation:\n$$\n4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} \\approx h^2 f_{i,j}\n$$\nThis set of $N=n^2$ equations for the $N$ unknown interior values $u_{i,j}$ forms a linear system $A \\mathbf{u}_h = \\mathbf{b}$. To construct the system explicitly, we map the two-dimensional grid of unknowns $(u_{i,j})$ to a one-dimensional vector $\\mathbf{u}_h$ of length $N$. A standard choice is row-major ordering, where the grid point $(i,j)$ maps to vector index $k = (j-1)n + (i-1)$ for $i,j \\in \\{1,\\dots,n\\}$.\n\nThe matrix $A$ represents the discrete negative Laplacian. The equation at point $(i,j)$ (row $k$ of the matrix) involves $u_{i,j}$ and its four neighbors. This structure leads to an $N \\times N$ matrix $A$ with five non-zero diagonals:\n- The main diagonal (stencil center, coefficient $4$) is at offset $0$.\n- The sub- and super-diagonals (x-neighbors, coefficient $-1$) are at offsets $\\pm 1$.\n- The far sub- and super-diagonals (y-neighbors, coefficient $-1$) are at offsets $\\pm n$.\nThe matrix $A$ is sparse, symmetric, and positive-definite.\n\nThe right-hand side vector $\\mathbf{b}$ incorporates the source term $f$ and the Dirichlet boundary conditions $g$. For an equation centered at $(x_i, y_j)$, the corresponding component of $\\mathbf{b}$ starts as $h^2 f(x_i, y_j)$. If any of the four neighbors in the stencil lie on the boundary $\\partial\\Omega$ (e.g., $u_{i-1,j}$ when $i=1$), its value is known from the boundary function $g$ (e.g., $u_{0,j} = g(0, y_j)$). This known value is moved to the right-hand side of the equation. The complete expression for the component of the right-hand side corresponding to point $(x_i, y_j)$ is:\n$$\nb_{i,j} = h^2 f(x_i, y_j) + \\delta_{i,1}g(0, y_j) + \\delta_{i,n}g(1, y_j) + \\delta_{j,1}g(x_i, 0) + \\delta_{j,n}g(x_i, 1)\n$$\nwhere $\\delta$ represents the Kronecker delta. The vector $\\mathbf{b}$ is assembled by flattening the grid of $b_{i,j}$ values, maintaining the same row-major ordering used for $\\mathbf{u}_h$.\n\nThe refinement study proceeds by solving the system $A\\mathbf{u}_h=\\mathbf{b}$ for a sequence of decreasing grid spacings $h$, corresponding to the given interior grid sizes $n \\in \\{7, 15, 31, 63\\}$. For each solution $u_h$, we compute the discrete $L^2$ error:\n$$\nE(h) = \\left(h^2 \\sum_{i=1}^{n}\\sum_{j=1}^{n}\\left(u_h(x_i,y_j) - u(x_i,y_j)\\right)^2\\right)^{1/2}\n$$\nThe observed order of convergence $p$ is then estimated between two successive refinements (e.g., with spacings $h$ and $h/2$) using the formula:\n$$\np(h \\to h/2) = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)}\n$$\nFor a second-order accurate scheme, we anticipate that as $h \\to 0$, $p$ will approach $2$. The implementation will calculate this order for each refinement step and check if the results fall within a specified tolerance of the theoretical value.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\nimport math\n\n# --- Problem Definition ---\n\n# The scalar Poisson problem is -Delta u = f on Omega = (0,1)x(0,1)\n# with Dirichlet boundary conditions u|dOmega = g.\n\n# --- Numerical Scheme ---\n\n# The implementation uses a second-order central finite difference scheme\n# on a uniform Cartesian grid with n interior points per direction.\n# This results in the 5-point stencil for the negative Laplacian. The\n# discrete equation at an interior node (i,j) is:\n#   4*u_ij - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} = h^2 * f_ij\n#\n# This leads to a linear system A*u_h = b, where A is a sparse,\n# symmetric positive-definite matrix. Boundary conditions are incorporated\n# into the right-hand side vector b.\n\ndef run_refinement_study(u_exact, f_source, n_list):\n    \"\"\"\n    Performs a grid refinement study for a given manufactured solution.\n\n    Args:\n        u_exact (callable): The exact solution u(x, y).\n        f_source (callable): The source term f(x, y) = -Delta u.\n        n_list (list of int): A sequence of interior grid sizes.\n\n    Returns:\n        tuple: A tuple containing:\n            - float: The observed order of convergence on the finest grid.\n            - bool: True if all observed orders are within [1.8, 2.2].\n    \"\"\"\n    errors = []\n    g_boundary = u_exact\n\n    for n in n_list:\n        # Total number of interior unknowns\n        N = n * n\n        # Grid spacing\n        h = 1.0 / (n + 1)\n\n        # 1. Construct the sparse matrix A for the negative Laplacian operator.\n        # The matrix has 5 diagonals based on the 5-point stencil.\n        # We use row-major ordering for mapping (i,j) -> k.\n        \n        # Main diagonal (coefficient 4)\n        d0 = np.ones(N) * 4\n        \n        # Off-diagonals for x-derivatives (coefficient -1)\n        d1 = np.ones(N - 1) * -1\n        # Set stencil connections at row boundaries to zero.\n        d1[n - 1::n] = 0\n        \n        # Off-diagonals for y-derivatives (coefficient -1)\n        dn = np.ones(N - n) * -1\n        \n        A = diags([d0, d1, d1, dn, dn], [0, 1, -1, n, -n], format='csr')\n\n        # 2. Construct the right-hand side vector b.\n        x_coords = np.linspace(h, 1 - h, n)\n        y_coords = np.linspace(h, 1 - h, n)\n        xx, yy = np.meshgrid(x_coords, y_coords, indexing='xy')\n        \n        # Start with the source term f\n        b_grid = h**2 * f_source(xx, yy)\n        \n        # Add contributions from Dirichlet boundary conditions\n        b_grid[0, :] += g_boundary(x_coords, 0.0)      # Bottom boundary (j=1)\n        b_grid[-1, :] += g_boundary(x_coords, 1.0)     # Top boundary (j=n)\n        b_grid[:, 0] += g_boundary(0.0, y_coords)      # Left boundary (i=1)\n        b_grid[:, -1] += g_boundary(1.0, y_coords)     # Right boundary (i=n)\n        \n        b_vec = b_grid.flatten()\n\n        # 3. Solve the linear system A * u_h = b\n        u_h_vec = spsolve(A, b_vec)\n        u_h_grid = u_h_vec.reshape((n, n))\n\n        # 4. Compute the discrete L2 error\n        u_exact_grid = u_exact(xx, yy)\n        error_grid = u_h_grid - u_exact_grid\n        \n        # E(h) = (h^2 * sum(e_ij^2))^(1/2) = h * ||e_ij||_F\n        l2_error = h * np.linalg.norm(error_grid)\n        errors.append(l2_error)\n\n    # 5. Compute the observed orders of convergence\n    orders = []\n    for i in range(len(errors) - 1):\n        # p = log(E(h)/E(h/2)) / log(2)\n        order = math.log(errors[i] / errors[i+1]) / math.log(2)\n        orders.append(order)\n        \n    finest_order = orders[-1]\n    all_in_tolerance = all(1.8 <= o <= 2.2 for o in orders)\n    \n    return finest_order, all_in_tolerance\n\n\ndef solve():\n    \"\"\"\n    Main driver function to run the test cases and print the final result.\n    \"\"\"\n    # Define the sequence of interior grid sizes for the refinement study\n    n_list = [7, 15, 31, 63]\n\n    # Test Case A: Smooth trigonometric solution, zero on boundary\n    u_A = lambda x, y: np.sin(2 * np.pi * x) * np.sin(3 * np.pi * y)\n    f_A = lambda x, y: ((2 * np.pi)**2 + (3 * np.pi)**2) * u_A(x, y)\n\n    # Test Case B: Exponential solution, non-zero on boundary\n    u_B = lambda x, y: np.exp(x + y)\n    f_B = lambda x, y: -2.0 * np.exp(x + y)\n    \n    # Test Case C: Polynomial solution\n    u_C = lambda x, y: x**2 * y**2\n    f_C = lambda x, y: -2.0 * (x**2 + y**2)\n\n    test_cases = [\n        {\"u\": u_A, \"f\": f_A},\n        {\"u\": u_B, \"f\": f_B},\n        {\"u\": u_C, \"f\": f_C},\n    ]\n    \n    # Store results for final output\n    p_results = []\n    b_results = []\n\n    for case in test_cases:\n        p_fine, b_tol = run_refinement_study(case[\"u\"], case[\"f\"], n_list)\n        p_results.append(p_fine)\n        b_results.append(b_tol)\n    \n    final_output_list = p_results + b_results\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, final_output_list))}]\")\n\nsolve()\n```"
        }
    ]
}