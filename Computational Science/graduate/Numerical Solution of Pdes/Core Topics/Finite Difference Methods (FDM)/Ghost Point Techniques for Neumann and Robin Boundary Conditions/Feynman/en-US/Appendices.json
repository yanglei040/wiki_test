{
    "hands_on_practices": [
        {
            "introduction": "Before implementing numerical schemes, it's crucial to understand their theoretical underpinnings. This practice focuses on the 1D Poisson equation with pure Neumann boundary conditions, a classic case that reveals a fundamental challenge: the singularity of the discrete operator. By deriving the discrete compatibility condition from first principles, you will gain insight into why a solution may not exist unless the data satisfies a specific constraint, a direct parallel to the continuous problem where the operator determines $u$ only up to an additive constant .",
            "id": "3400432",
            "problem": "Consider the one-dimensional Poisson equation $u''(x)=f(x)$ on the interval $[0,1]$ with Neumann boundary conditions $u'(0)=\\alpha$ and $u'(1)=\\beta$, where $f$ is smooth and $\\alpha,\\beta$ are given real constants. Let $x_i=i h$ for $i=0,1,\\dots,N$ with $h=1/N$, and denote $u_i\\approx u(x_i)$, $f_i=f(x_i)$. Use the following second-order finite-difference scheme with ghost points to approximate the problem:\n\n- For interior nodes $i=1,2,\\dots,N-1$, discretize the second derivative by the centered difference\n$$\\frac{u_{i-1}-2u_i+u_{i+1}}{h^2}=f_i.$$\n\n- Introduce ghost values $u_{-1}$ and $u_{N+1}$ to impose the Neumann boundary conditions via centered differences\n$$\\frac{u_1-u_{-1}}{2h}=\\alpha,\\qquad \\frac{u_{N+1}-u_{N-1}}{2h}=\\beta.$$\n\n- Do not discretize the Poisson equation at $i=0$ and $i=N$; that is, use the partial differential equation (PDE) only on interior nodes and use the boundary conditions only at the boundary.\n\nTask A (discrete compatibility): Starting from the above ghost-based discretization and from the continuous identity obtained by integrating the PDE and using integration by parts (namely $\\int_0^1 f(x)\\,\\mathrm{d}x=\\beta-\\alpha$), derive the discrete analogue of the compatibility condition that must hold for the finite-difference system to be solvable to second-order accuracy. Your derivation must begin from summing the interior finite-difference equations and consistently approximating the boundary fluxes using Taylor expansions about $x=0$ and $x=1$. Express the final compatibility as a single scalar expression in closed form in terms of $h$, the grid samples $f_0,\\dots,f_N$, and the boundary data $\\alpha,\\beta$, which evaluates to zero when the condition holds up to a truncation error of order $h^2$.\n\nTask B (normalization for uniqueness): The discrete system is singular because the continuous operator with Neumann data determines $u$ only up to an additive constant. Propose a normalization strategy that enforces a unique solution by requiring a discrete zero-mean condition that is consistent with your discrete compatibility relation from Task A. Give a closed-form formula for the normalization constant $c$ that must be subtracted from any discrete solution $\\{u_i\\}_{i=0}^N$ to enforce this zero-mean constraint. Your $c$ must be expressed in terms of $h$ and the grid values $u_0,\\dots,u_N$.\n\nAnswer specification: Provide as your final answer only the single scalar expression from Task A (do not include an equality sign). No units are required. Do not round; give exact symbolic form.",
            "solution": "The problem statement is critically validated and found to be valid. It is scientifically grounded in the field of numerical analysis for partial differential equations, is well-posed, objective, and self-contained.\n\nThe problem asks for two tasks related to the finite-difference discretization of the Poisson equation $u''(x)=f(x)$ on the interval $[0,1]$ with Neumann boundary conditions $u'(0)=\\alpha$ and $u'(1)=\\beta$.\n\nThe continuous problem has a compatibility condition for a solution to exist. Integrating the PDE from $x=0$ to $x=1$ yields:\n$$ \\int_0^1 u''(x) \\, \\mathrm{d}x = \\int_0^1 f(x) \\, \\mathrm{d}x $$\nBy the Fundamental Theorem of Calculus, the left side is $u'(1) - u'(0)$. Using the boundary conditions, we get:\n$$ \\beta - \\alpha = \\int_0^1 f(x) \\, \\mathrm{d}x $$\nThis condition states that the net change in the flux across the boundaries must equal the total source term within the domain.\n\n### Task A: Derivation of the Discrete Compatibility Condition\n\nThe finite-difference scheme is defined on a uniform grid $x_i=i h$ for $i=0, 1, \\dots, N$, with $h=1/N$. The discrete approximation to the solution is $u_i \\approx u(x_i)$.\n\nThe interior equations are given by the centered difference formula for the second derivative:\n$$ \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = f_i, \\quad \\text{for } i = 1, 2, \\dots, N-1 $$\nThe boundary conditions are imposed using ghost points $u_{-1}$ and $u_{N+1}$ and a centered difference for the first derivative:\n$$ \\frac{u_1 - u_{-1}}{2h} = \\alpha \\implies u_{-1} = u_1 - 2h\\alpha $$\n$$ \\frac{u_{N+1} - u_{N-1}}{2h} = \\beta \\implies u_{N+1} = u_{N-1} + 2h\\beta $$\nThe problem instructs us to derive the discrete compatibility condition by summing the interior finite-difference equations. Summing the $N-1$ interior equations gives:\n$$ \\sum_{i=1}^{N-1} (u_{i-1} - 2u_i + u_{i+1}) = h^2 \\sum_{i=1}^{N-1} f_i $$\nThe sum on the left-hand side is a telescoping sum:\n$$ (u_0 - 2u_1 + u_2) + (u_1 - 2u_2 + u_3) + \\dots + (u_{N-2} - 2u_{N-1} + u_N) = u_0 - u_1 - u_{N-1} + u_N $$\nRearranging this gives:\n$$ (u_N - u_{N-1}) - (u_1 - u_0) = h^2 \\sum_{i=1}^{N-1} f_i $$\nThis equation relates the first-order differences at the boundaries to the sum of the source term $f_i$ in the interior. To obtain the compatibility condition, we must relate these differences to the boundary data $\\alpha$ and $\\beta$ in a manner consistent with the second-order accuracy of the scheme. This is achieved by applying the same second-derivative stencil at the boundary points $i=0$ and $i=N$ and eliminating the ghost points.\n\nAt the boundary $x_0=0$, the stencil is:\n$$ \\frac{u_{-1} - 2u_0 + u_1}{h^2} = f_0 $$\nSubstituting the expression for the ghost point $u_{-1} = u_1 - 2h\\alpha$:\n$$ \\frac{(u_1 - 2h\\alpha) - 2u_0 + u_1}{h^2} = f_0 \\implies 2u_1 - 2u_0 - 2h\\alpha = h^2 f_0 $$\nThis can be rearranged to express the one-sided difference $(u_1-u_0)/h$:\n$$ \\frac{u_1 - u_0}{h} = \\alpha + \\frac{h}{2}f_0 $$\n\nAt the boundary $x_N=1$, the stencil is:\n$$ \\frac{u_{N-1} - 2u_N + u_{N+1}}{h^2} = f_N $$\nSubstituting the expression for the ghost point $u_{N+1} = u_{N-1} + 2h\\beta$:\n$$ \\frac{u_{N-1} - 2u_N + (u_{N-1} + 2h\\beta)}{h^2} = f_N \\implies 2u_{N-1} - 2u_N + 2h\\beta = h^2 f_N $$\nThis can be rearranged to express the one-sided difference $(u_N-u_{N-1})/h$:\n$$ \\frac{u_N - u_{N-1}}{h} = \\beta - \\frac{h}{2}f_N $$\n\nNow substitute these second-order accurate expressions for the boundary fluxes into the summed interior equation:\n$$ (u_N - u_{N-1}) - (u_1 - u_0) = h \\left( \\beta - \\frac{h}{2}f_N \\right) - h \\left( \\alpha + \\frac{h}{2}f_0 \\right) = h^2 \\sum_{i=1}^{N-1} f_i $$\nSimplifying this relation:\n$$ h(\\beta - \\alpha) - \\frac{h^2}{2}(f_0 + f_N) = h^2 \\sum_{i=1}^{N-1} f_i $$\n$$ h(\\beta - \\alpha) = h^2 \\left( \\frac{f_0 + f_N}{2} + \\sum_{i=1}^{N-1} f_i \\right) $$\nDividing by $h$ (since $h=1/N \\neq 0$), we obtain the discrete compatibility condition:\n$$ \\beta - \\alpha = h \\left( \\frac{f_0 + f_N}{2} + \\sum_{i=1}^{N-1} f_i \\right) $$\nThe right-hand side is the trapezoidal rule approximation of $\\int_0^1 f(x) \\, \\mathrm{d}x$. This condition is the discrete analogue of the continuous compatibility condition.\n\nThe problem asks for a single scalar expression that evaluates to zero when the condition holds. This expression is:\n$$ h \\left( \\frac{f_0 + f_N}{2} + \\sum_{i=1}^{N-1} f_i \\right) - (\\beta - \\alpha) $$\n\n### Task B: Normalization for Uniqueness\n\nThe linear system of equations for $\\{u_i\\}_{i=0}^N$ is singular. If $\\{u_i\\}$ is a solution, then $\\{u_i + C\\}$ is also a solution for any constant $C$, since the finite difference operator $(u_{i-1} - 2u_i + u_{i+1})/h^2$ annihilates a constant. To enforce a unique solution, we must add a normalization constraint.\n\nThe problem suggests a discrete zero-mean condition. The continuous zero-mean condition is $\\int_0^1 u(x)\\,\\mathrm{d}x = 0$. A discrete analogue that is consistent with the compatibility condition from Task A (which uses the trapezoidal rule) is to set the trapezoidal sum of the solution to zero:\n$$ h \\left( \\frac{u_0 + u_N}{2} + \\sum_{i=1}^{N-1} u_i \\right) = 0 $$\nLet $\\{u_i\\}_{i=0}^N$ be any particular solution to the discrete system. We seek a constant $c$ such that the normalized solution $u_i^{\\text{norm}} = u_i - c$ satisfies the zero-mean condition.\nSubstituting $u_i^{\\text{norm}}$ into the constraint:\n$$ h \\left( \\frac{(u_0 - c) + (u_N - c)}{2} + \\sum_{i=1}^{N-1} (u_i - c) \\right) = 0 $$\nSince $h \\neq 0$, we can divide by it and separate terms involving $u_i$ and $c$:\n$$ \\left( \\frac{u_0 + u_N}{2} + \\sum_{i=1}^{N-1} u_i \\right) - \\left( \\frac{c + c}{2} + \\sum_{i=1}^{N-1} c \\right) = 0 $$\n$$ \\left( \\frac{u_0 + u_N}{2} + \\sum_{i=1}^{N-1} u_i \\right) - \\left( c + (N-1)c \\right) = 0 $$\n$$ \\left( \\frac{u_0 + u_N}{2} + \\sum_{i=1}^{N-1} u_i \\right) - Nc = 0 $$\nSolving for the normalization constant $c$:\n$$ c = \\frac{1}{N} \\left( \\frac{u_0 + u_N}{2} + \\sum_{i=1}^{N-1} u_i \\right) $$\nUsing the relation $h = 1/N$, the formula for $c$ can be written in terms of $h$:\n$$ c = h \\left( \\frac{u_0 + u_N}{2} + \\sum_{i=1}^{N-1} u_i \\right) $$\nThis constant $c$ is the discrete average of the solution $\\{u_i\\}$ using the trapezoidal rule. Subtracting it ensures the resulting solution has a discrete mean of zero.\n\nThe final answer is requested for Task A only.",
            "answer": "$$\n\\boxed{h \\left(\\frac{f_0 + f_N}{2} + \\sum_{i=1}^{N-1} f_i\\right) - (\\beta - \\alpha)}\n$$"
        },
        {
            "introduction": "Formally, multiple discretization schemes can achieve the same order of accuracy, yet their practical performance can differ significantly due to the magnitude of their truncation errors. This hands-on coding exercise challenges you to implement and compare two distinct second-order accurate methods for a Robin boundary condition . By analyzing the boundary error constants of each method, you will develop a deeper appreciation for the nuances of numerical accuracy and learn how to design tests to evaluate competing schemes.",
            "id": "3400414",
            "problem": "Consider the one-dimensional stationary Poisson problem on the closed interval $[0,1]$,\n$$-u''(x) = f(x), \\quad x \\in (0,1),$$\nwith a Robin boundary condition at the left endpoint and a Dirichlet boundary condition at the right endpoint:\n$$\\alpha\\,u(0) + \\beta\\,u'(0) = \\gamma,\\quad u(1) = u_R.$$\nAssume a uniform grid with step size $h = 1/N$ and grid points $x_i = i h$ for $i=0,1,\\dots,N$. Let the exact solution be $u(x) = e^x$, so that $f(x) = -e^x$, and choose the boundary data to be consistent with the exact solution, namely $u_R = e^1$ and $\\gamma = \\alpha\\,u(0) + \\beta\\,u'(0) = \\alpha + \\beta$.\n\nYou must implement two algebraically different, formally second-order accurate boundary closures at $x=0$ (the Robin boundary), while using the standard second-order central difference for the interior discretization of $-u''$. Both methods should produce a linear system for the nodal values $\\{u_i\\}$ that is solved for the unknowns.\n\n- Method A (Centered ghost-derivative closure with a ghost node and boundary-pinned stencil at $i=0$):\n  - Use the second-order centered finite difference for $-u''$ at all grid points including $i=0$:\n    $$-u''(x_i)\\approx \\frac{-u_{i-1}+2u_i-u_{i+1}}{h^2}.$$\n  - Introduce a ghost value $u_{-1}$ at $x_{-1}=-h$. Enforce the Robin boundary by approximating $u'(0)$ with the centered difference that involves the ghost:\n    $$u'(0)\\approx \\frac{u_1 - u_{-1}}{2h}.$$\n    Eliminate the ghost $u_{-1}$ using the Robin boundary condition and substitute it into the discrete equation at $i=0$. Treat $i=N$ by the given Dirichlet data.\n\n- Method B (One-sided, three-point second-order derivative closure without a ghost node):\n  - For interior nodes $i=1,2,\\dots,N-1$, use the second-order central difference for $-u''$ as in Method A.\n  - At $i=0$, enforce the Robin boundary condition using a one-sided, three-point, second-order approximation of the derivative:\n    $$u'(0)\\approx \\frac{-3u_0 + 4u_1 - u_2}{2h}.$$\n\nFor both methods, build and solve the linear system for the unknowns at nodes $i=0,1,\\dots,N-1$, taking $u_N=u(1)=e^1$ as known. For each method and a given $N$, compute the boundary pointwise error $e_0(h) = |u_0 - u(0)| = |u_0 - e^0|$, and then form the boundary error constant estimator\n$$C(h) = \\frac{e_0(h)}{h^2}.$$\n\nYour task is to design a computational test that reveals which boundary closure yields a smaller boundary error constant. Specifically, for each test case below, estimate the ratio\n$$R = \\frac{C_B(h_\\text{fine})}{C_A(h_\\text{fine})},$$\nwhere $C_A$ and $C_B$ denote the boundary error constant estimators for Method A and Method B, respectively, evaluated at a sufficiently fine grid spacing $h_\\text{fine}$ (with the understanding that $C(h)$ is asymptotically constant for small $h$ in a second-order method). A ratio $R1$ indicates that Method B has a smaller boundary error constant than Method A for that test, while $R>1$ indicates the opposite.\n\nImplement the above for the following test suite, where each test specifies $(\\alpha,\\beta)$ for the Robin boundary at $x=0$:\n- Test $1$: $(\\alpha,\\beta)=(1,1)$.\n- Test $2$: $(\\alpha,\\beta)=(0,1)$.\n- Test $3$: $(\\alpha,\\beta)=(2,0.5)$.\n\nUse a fine grid with $N=512$ so that $h=1/512$. For each test, compute $R$ as defined above.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, namely the list $[R_1,R_2,R_3]$ for the three tests in the order given. Each $R_k$ must be printed as a floating-point number with exactly six digits after the decimal point.",
            "solution": "The problem as stated is scientifically sound, self-contained, and well-posed. It presents a standard numerical analysis task involving the comparison of two different second-order finite difference treatments for a Robin boundary condition. The problem is therefore deemed valid and a solution will be provided.\n\nThe problem under consideration is the one-dimensional stationary Poisson equation:\n$$ -u''(x) = f(x), \\quad x \\in (0,1) $$\nwith a Robin boundary condition at $x=0$ and a Dirichlet boundary condition at $x=1$:\n$$ \\alpha\\,u(0) + \\beta\\,u'(0) = \\gamma $$\n$$ u(1) = u_R $$\nWe are given the exact solution $u(x) = e^x$, which implies the source term must be $f(x) = -u''(x) = -e^x$. The boundary data are chosen to be consistent with this solution: $u_R = u(1) = e^1$, and $\\gamma = \\alpha\\,u(0) + \\beta\\,u'(0) = \\alpha\\,(1) + \\beta\\,(1) = \\alpha + \\beta$.\n\nWe use a uniform grid with $N+1$ points $x_i = ih$ for $i=0, 1, \\dots, N$, where the grid spacing is $h=1/N$. Let $u_i$ be the numerical approximation of the exact solution $u(x_i)$. The unknowns are the nodal values $\\{u_0, u_1, \\dots, u_{N-1}\\}$. The value $u_N$ is known from the Dirichlet condition: $u_N = u_R = e^1$. This gives a system of $N$ linear equations for $N$ unknowns.\n\nFor the interior grid points $i=1, 2, \\dots, N-1$, we use the standard second-order centered finite difference approximation for the second derivative:\n$$ -u''(x_i) \\approx \\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2} $$\nThis leads to the following set of $N-1$ linear equations:\n$$ -u_{i-1} + 2u_i - u_{i+1} = h^2 f(x_i) = -h^2 e^{x_i} \\quad \\text{for } i=1, \\dots, N-1. $$\nThe equation for $i=N-1$ involves the known value $u_N$:\n$$ -u_{N-2} + 2u_{N-1} - u_N = -h^2 e^{x_{N-1}} \\implies -u_{N-2} + 2u_{N-1} = -h^2 e^{x_{N-1}} + u_N $$\n\nThe final equation, corresponding to the node $i=0$, is derived from the Robin boundary condition using two different methods.\n\n### Method A: Ghost-node Centered Closure\nThis method enforces the PDE at the boundary point $i=0$ by introducing a \"ghost\" point at $x_{-1} = -h$ with an unknown value $u_{-1}$.\nThe PDE discretization at $i=0$ is:\n$$ \\frac{-u_{-1} + 2u_0 - u_1}{h^2} = f(x_0) = -e^0 = -1 $$\nThe Robin boundary condition is discretized using a second-order centered difference for the derivative $u'(0)$:\n$$ \\alpha u_0 + \\beta \\left(\\frac{u_1 - u_{-1}}{2h}\\right) = \\gamma $$\nWe eliminate the ghost value $u_{-1}$. From the discretized boundary condition, we solve for $u_{-1}$ (assuming $\\beta \\neq 0$, which is true for all test cases):\n$$ u_{-1} = u_1 - \\frac{2h}{\\beta}(\\gamma - \\alpha u_0) = u_1 + \\frac{2h\\alpha}{\\beta}u_0 - \\frac{2h\\gamma}{\\beta} $$\nSubstituting this expression for $u_{-1}$ into the discretized PDE at $i=0$:\n$$ -\\left(u_1 + \\frac{2h\\alpha}{\\beta}u_0 - \\frac{2h\\gamma}{\\beta}\\right) + 2u_0 - u_1 = -h^2 $$\nGrouping terms for the unknowns $u_0$ and $u_1$, we obtain the first equation of our linear system:\n$$ \\left(2 - \\frac{2h\\alpha}{\\beta}\\right)u_0 - 2u_1 = -h^2 - \\frac{2h\\gamma}{\\beta} $$\n\n### Method B: One-sided Derivative Closure\nThis method does not use a ghost point. Instead, the equation at $i=0$ is derived directly from the Robin boundary condition by employing a one-sided, second-order accurate approximation for the derivative $u'(0)$:\n$$ u'(0) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h} $$\nSubstituting this into the Robin boundary condition $\\alpha u_0 + \\beta u'(0) = \\gamma$ gives:\n$$ \\alpha u_0 + \\beta \\left(\\frac{-3u_0 + 4u_1 - u_2}{2h}\\right) = \\gamma $$\nMultiplying by $2h$ and grouping terms for the unknowns $u_0$, $u_1$, and $u_2$ yields the first equation of the linear system:\n$$ (2h\\alpha - 3\\beta)u_0 + 4\\beta u_1 - \\beta u_2 = 2h\\gamma $$\n\n### System Assembly and Solution\nFor each method, we assemble an $N \\times N$ matrix system $A\\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$.\n\n**System for Method A:**\n- First row ($i=0$):\n  $A_{0,0} = 2 - 2h\\alpha/\\beta$, $A_{0,1} = -2$, and $b_0 = -h^2 - 2h\\gamma/\\beta$.\n- Interior rows ($i=1, \\dots, N-2$):\n  $A_{i,i-1}=-1$, $A_{i,i}=2$, $A_{i,i+1}=-1$, and $b_i = -h^2e^{x_i}$.\n- Last row ($i=N-1$):\n  $A_{N-1,N-2}=-1$, $A_{N-1,N-1}=2$, and $b_{N-1} = -h^2e^{x_{N-1}} + u_N$.\n\n**System for Method B:**\n- First row ($i=0$):\n  $A_{0,0} = 2h\\alpha - 3\\beta$, $A_{0,1} = 4\\beta$, $A_{0,2} = -\\beta$, and $b_0 = 2h\\gamma$.\n- Interior and last rows are identical to those in Method A.\n\nFor each test case $(\\alpha, \\beta)$, and with $N=512$, we build and solve the linear systems for Method A and Method B to find the numerical solutions, specifically the boundary values $u_0^{(A)}$ and $u_0^{(B)}$.\n\nThe boundary pointwise error for each method is calculated as $e_0(h) = |u_0 - u(0)| = |u_0 - 1|$. The corresponding error constant estimators are $C_A(h) = e_0^{(A)}(h)/h^2$ and $C_B(h) = e_0^{(B)}(h)/h^2$. The final step is to compute the ratio $R = C_B(h)/C_A(h)$ for each test case.",
            "answer": "```python\nimport numpy as np\n\ndef solve_poisson_1d(N, alpha, beta, method):\n    \"\"\"\n    Solves the 1D Poisson problem with a Robin/Dirichlet BC using two methods.\n\n    Args:\n        N (int): Number of intervals, such that h = 1/N.\n        alpha (float): Robin condition parameter.\n        beta (float): Robin condition parameter.\n        method (str): 'A' or 'B' for the boundary closure method.\n\n    Returns:\n        float: The numerical solution u_0 at the boundary x=0.\n    \"\"\"\n    h = 1.0 / N\n    gamma = alpha + beta\n    u_R = np.exp(1.0)\n    \n    # Grid points and source function values\n    x_nodes = np.linspace(0, 1, N + 1)\n    f_vals = -np.exp(x_nodes)\n    \n    # System A*u = b for unknowns u = [u_0, ..., u_{N-1}]\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n    \n    # Interior rows (i=1 to N-2) are common to both methods\n    for i in range(1, N - 1):\n        A[i, i-1] = -1.0\n        A[i, i]   = 2.0\n        A[i, i+1] = -1.0\n        b[i] = h**2 * f_vals[i]\n        \n    # Last row (i=N-1) is common to both methods\n    if N  1:\n        A[N-1, N-2] = -1.0\n    A[N-1, N-1] = 2.0\n    b[N-1] = h**2 * f_vals[N-1] + u_R\n        \n    # First row (i=0) depends on the chosen method\n    if method == 'A':\n        # Method A: Ghost-node centered closure\n        # (2 - 2h*alpha/beta)u_0 - 2u_1 = h^2*f_0 - 2h*gamma/beta\n        A[0, 0] = 2.0 - 2.0 * h * alpha / beta\n        if N  1:\n            A[0, 1] = -2.0\n        b[0] = h**2 * f_vals[0] - 2.0 * h * gamma / beta\n    elif method == 'B':\n        # Method B: One-sided derivative closure\n        # (2h*alpha - 3*beta)u_0 + 4*beta*u_1 - beta*u_2 = 2h*gamma\n        A[0, 0] = 2.0 * h * alpha - 3.0 * beta\n        if N  1:\n            A[0, 1] = 4.0 * beta\n        if N  2:\n            A[0, 2] = -beta\n        b[0] = 2.0 * h * gamma\n    else:\n        raise ValueError(\"Invalid method specified. Choose 'A' or 'B'.\")\n        \n    # Solve the linear system\n    u_solution = np.linalg.solve(A, b)\n    \n    return u_solution[0]\n\ndef solve():\n    \"\"\"\n    Main function to run the computational test and print the results.\n    \"\"\"\n    N = 512\n    h = 1.0 / N\n    u_exact_0 = 1.0  # Exact solution u(0) = exp(0)\n    \n    test_cases = [\n        # (alpha, beta)\n        (1.0, 1.0),\n        (0.0, 1.0),\n        (2.0, 0.5)\n    ]\n    \n    R_values = []\n    \n    for alpha, beta in test_cases:\n        # Solve using Method A\n        u0_A = solve_poisson_1d(N, alpha, beta, method='A')\n        \n        # Solve using Method B\n        u0_B = solve_poisson_1d(N, alpha, beta, method='B')\n        \n        # Calculate boundary pointwise errors\n        e0_A = abs(u0_A - u_exact_0)\n        e0_B = abs(u0_B - u_exact_0)\n        \n        # Calculate error constant estimators\n        # C(h) = e0(h) / h^2\n        C_A = e0_A / h**2\n        C_B = e0_B / h**2\n        \n        # The problem formulation ensures C_A will be non-zero for these tests\n        if C_A == 0:\n            # Handle the unlikely case of zero error for Method A\n             R = np.inf if C_B != 0 else 1.0 # Or np.nan\n        else:\n             R = C_B / C_A\n\n        R_values.append(R)\n        \n    # Print the final result in the specified format\n    print(f\"[{','.join([f'{r:.6f}' for r in R_values])}]\")\n\n# Execute the solution\nsolve()\n```"
        },
        {
            "introduction": "The true power of ghost point techniques is realized when they are applied to complex, time-dependent partial differential equations. This comprehensive practice extends the concept to the 1D heat equation, where you will use the method of lines to create a semi-discrete system incorporating various Neumann and Robin boundary conditions . By implementing the robust Crank–Nicolson method for time integration, you will build a complete solver and verify its accuracy, bridging the gap from steady-state analysis to dynamic simulation.",
            "id": "3400489",
            "problem": "Consider the one-dimensional heat equation on a finite interval with mixed Neumann and Robin closures enforced via ghost points. Let the spatial domain be $x \\in [0,1]$, the time interval be $t \\in [0,T]$ with $T = 0.1$, and let the thermal diffusivity be $\\kappa = 1$. The partial differential equation (PDE) is\n$$\nu_t(x,t) = u_{xx}(x,t) + f(x,t),\n$$\nwith an initial condition\n$$\nu(x,0) = u_0(x),\n$$\nand general boundary closures at $x=0$ and $x=1$ of Neumann or Robin type. A Neumann boundary condition prescribes the normal flux $u_x = g(t)$, while a Robin boundary condition prescribes a linear combination $\\alpha\\,u + \\beta\\,u_x = r(t)$ with given constants $\\alpha$ and $\\beta$ and boundary data function $r(t)$. Use the ghost point technique to obtain second-order accurate spatial closures for both Neumann and Robin types at each boundary. Time integration should be by the Crank–Nicolson method.\n\nStart from the following fundamental base:\n- The heat equation $u_t = \\kappa u_{xx} + f$ with $\\kappa=1$.\n- Second-order accurate central finite differences for spatial derivatives on a uniform grid $x_i = i h$ with $h = 1/N$, where $i \\in \\{0,1,\\dots,N\\}$.\n- The Crank–Nicolson method for time stepping, which is second-order accurate in time for linear problems.\n\nYour implementation must:\n- Derive and enforce ghost point relations for the boundary conditions using only second-order accurate approximations compatible with a central-difference Laplacian stencil at the boundary-adjacent nodes.\n- Assemble a time-independent discrete Laplacian operator matrix, with modifications induced by the Robin coefficients at the boundaries, and an additive time-dependent vector capturing inhomogeneous boundary data.\n- Use the Crank–Nicolson method in a method-of-lines setting to advance the semi-discrete system in time from $t=0$ to $t=T$.\n\nTo make the problem fully verifiable, enforce the closures using an exact manufactured solution\n$$\nu_{\\text{exact}}(x,t) = e^{-t}\\,\\big(\\sin(\\pi x) + x\\big),\n$$\nand take the source term and initial data from this solution:\n$$\nf(x,t) = u_t(x,t) - u_{xx}(x,t) = e^{-t}\\,\\big((\\pi^2-1)\\sin(\\pi x) - x\\big), \\quad u_0(x) = u_{\\text{exact}}(x,0) = \\sin(\\pi x)+x.\n$$\nThe boundary data must be generated from $u_{\\text{exact}}$:\n- For a Neumann boundary at $x_b \\in \\{0,1\\}$, take $g_b(t) = \\partial_x u_{\\text{exact}}(x_b,t)$.\n- For a Robin boundary at $x_b \\in \\{0,1\\}$ with constants $(\\alpha_b,\\beta_b)$, take $r_b(t) = \\alpha_b\\,u_{\\text{exact}}(x_b,t) + \\beta_b\\,\\partial_x u_{\\text{exact}}(x_b,t)$.\n\nGhost point closures to derive and implement:\n- At $x=0$, introduce a ghost value $u_{-1}$ and enforce $u_x(0,t)$ with the second-order centered approximation $u_x(0,t) \\approx \\frac{u_1 - u_{-1}}{2h}$. For a Robin condition $\\alpha_0 u(0,t) + \\beta_0 u_x(0,t) = r_0(t)$, eliminate $u_{-1}$; for a Neumann condition, set $\\alpha_0=0$, $\\beta_0=1$, $r_0(t)=g_0(t)$.\n- At $x=1$, introduce a ghost value $u_{N+1}$ and enforce $u_x(1,t)$ with the second-order centered approximation $u_x(1,t) \\approx \\frac{u_{N+1} - u_{N-1}}{2h}$. For a Robin condition $\\alpha_1 u(1,t) + \\beta_1 u_x(1,t) = r_1(t)$, eliminate $u_{N+1}$; for a Neumann condition, set $\\alpha_1=0$, $\\beta_1=1$, $r_1(t)=g_1(t)$.\n\nFrom these, derive a modified discrete Laplacian acting on the vector of nodal values $(u_0,\\dots,u_N)$ together with a boundary-induced inhomogeneous vector so that the semidiscrete system reads\n$$\n\\frac{d\\mathbf{u}}{dt} = A \\mathbf{u} + \\mathbf{w}(t) + \\mathbf{f}(t),\n$$\nwhere $A$ is a constant $(N+1)\\times(N+1)$ matrix and $\\mathbf{w}(t)$ depends only on time through the boundary data. Apply the Crank–Nicolson method:\n$$\n\\left(I - \\frac{\\Delta t}{2} A\\right)\\mathbf{u}^{n+1} = \\left(I + \\frac{\\Delta t}{2} A\\right)\\mathbf{u}^{n} + \\frac{\\Delta t}{2}\\left(\\mathbf{f}^n + \\mathbf{f}^{n+1}\\right) + \\frac{\\Delta t}{2}\\left(\\mathbf{w}^n + \\mathbf{w}^{n+1}\\right).\n$$\n\nTest suite. For each case below, use final time $T=0.1$ and compute the maximum-norm error at $t=T$:\n$$\nE = \\max_{0 \\le i \\le N} \\left| u_i(T) - u_{\\text{exact}}(x_i,T) \\right|.\n$$\nSpecify boundary condition types and constants as follows. In all cases, set $\\kappa=1$ and $h=1/N$ with uniform grid points $x_i = i h$.\n\n- Case A (Neumann–Neumann): left boundary Neumann, right boundary Neumann; take $N=50$, $\\Delta t = 0.0002$.\n- Case B (Robin–Neumann): left boundary Robin with $(\\alpha_0,\\beta_0)=(1,1)$, right boundary Neumann; take $N=50$, $\\Delta t = 0.0002$.\n- Case C (Neumann–Robin): left boundary Neumann, right boundary Robin with $(\\alpha_1,\\beta_1)=(2,0.5)$; take $N=60$, $\\Delta t = 0.0001$.\n- Case D (Robin–Robin): left boundary Robin with $(\\alpha_0,\\beta_0)=(1.5,0.7)$, right boundary Robin with $(\\alpha_1,\\beta_1)=(0.5,1.2)$; take $N=80$, $\\Delta t = 0.0001$.\n\nYour program must:\n- Implement the second-order ghost point closures and the Crank–Nicolson march from $t=0$ to $t=T$ for each test case.\n- Initialize with $u_i(0) = u_{\\text{exact}}(x_i,0)$ for all $i$ and compute the manufactured source vector $\\mathbf{f}(t)$ at the grid points.\n- Output the list $[E_A,E_B,E_C,E_D]$, where each entry is the maximum-norm error for the corresponding case, rounded to $8$ decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, for example $[e_1,e_2,e_3,e_4]$, where each $e_j$ is a floating-point number rounded to $8$ decimal places.",
            "solution": "The user has provided a valid, well-posed problem in the domain of numerical partial differential equations. The task is to solve the one-dimensional heat equation with mixed Neumann and Robin boundary conditions using a finite difference scheme based on the method of lines, ghost points for boundary closures, and the Crank-Nicolson method for time integration. The correctness of the implementation is to be verified using the method of manufactured solutions.\n\nThe analysis proceeds in the following steps:\n1.  **Semi-Discretization**: The partial differential equation (PDE) is converted into a system of ordinary differential equations (ODEs) by discretizing the spatial domain.\n2.  **Boundary Condition Implementation**: The specified Neumann or Robin boundary conditions are incorporated into the discrete system using a second-order accurate ghost point technique.\n3.  **System Assembly**: The semi-discrete equations are assembled into a matrix system of the form $\\frac{d\\mathbf{u}}{dt} = A\\mathbf{u} + \\mathbf{w}(t) + \\mathbf{f}(t)$.\n4.  **Temporal Integration**: The Crank-Nicolson method is applied to solve the resulting system of ODEs.\n5.  **Manufactured Solution**: The provided exact solution is used to define the source term, initial condition, and boundary data necessary for the simulation and for error verification.\n\n**1. Semi-Discretization of the PDE**\n\nThe spatial domain $x \\in [0, 1]$ is discretized into $N$ uniform intervals of width $h = 1/N$. The grid points are $x_i = i h$ for $i \\in \\{0, 1, \\dots, N\\}$. The solution at these points at time $t$ is denoted by the vector $\\mathbf{u}(t) = [u_0(t), u_1(t), \\dots, u_N(t)]^T$, where $u_i(t) \\approx u(x_i, t)$.\n\nThe PDE is $u_t = \\kappa u_{xx} + f$, with $\\kappa=1$. For an interior grid point $x_i$ where $i \\in \\{1, \\dots, N-1\\}$, we approximate the spatial derivative $u_{xx}$ using a second-order central difference formula:\n$$\nu_{xx}(x_i, t) \\approx \\frac{u(x_{i-1}, t) - 2u(x_i, t) + u(x_{i+1}, t)}{h^2}\n$$\nThis leads to a system of ordinary differential equations, one for each interior node:\n$$\n\\frac{du_i}{dt} = \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} + f_i(t), \\quad \\text{for } i \\in \\{1, \\dots, N-1\\}\n$$\nwhere $f_i(t) = f(x_i, t)$.\n\n**2. Ghost Point Implementation of Boundary Conditions**\n\nTo maintain second-order accuracy at the boundaries ($i=0$ and $i=N$), we introduce ghost points $x_{-1} = -h$ and $x_{N+1} = 1+h$, with corresponding values $u_{-1}$ and $u_{N+1}$. The discretized PDE at the boundaries is then written using the same central difference stencil:\n$$\n\\frac{du_0}{dt} = \\frac{u_{-1} - 2u_0 + u_1}{h^2} + f_0(t)\n$$\n$$\n\\frac{du_N}{dt} = \\frac{u_{N-1} - 2u_N + u_{N+1}}{h^2} + f_N(t)\n$$\nThe ghost values $u_{-1}$ and $u_{N+1}$ are eliminated by enforcing the boundary conditions.\n\n**At the left boundary, $x=0$:**\nThe general Robin condition is $\\alpha_0 u(0,t) + \\beta_0 u_x(0,t) = r_0(t)$. We use a second-order central difference approximation for $u_x(0,t)$:\n$$\n\\alpha_0 u_0 + \\beta_0 \\frac{u_1 - u_{-1}}{2h} = r_0(t)\n$$\nAssuming $\\beta_0 \\neq 0$, we solve for the ghost value $u_{-1}$:\n$$\nu_{-1} = u_1 - \\frac{2h}{\\beta_0}(r_0(t) - \\alpha_0 u_0) = u_1 + \\frac{2h\\alpha_0}{\\beta_0}u_0 - \\frac{2h}{\\beta_0}r_0(t)\n$$\nSubstituting this into the equation for $du_0/dt$:\n$$\n\\frac{du_0}{dt} = \\frac{1}{h^2}\\left( \\left(u_1 + \\frac{2h\\alpha_0}{\\beta_0}u_0 - \\frac{2h}{\\beta_0}r_0(t)\\right) - 2u_0 + u_1 \\right) + f_0(t)\n$$\n$$\n\\frac{du_0}{dt} = \\left(-\\frac{2}{h^2} + \\frac{2\\alpha_0}{h\\beta_0}\\right)u_0 + \\frac{2}{h^2}u_1 - \\frac{2}{h\\beta_0}r_0(t) + f_0(t)\n$$\n\n**At the right boundary, $x=1$:**\nSimilarly, the Robin condition is $\\alpha_1 u(1,t) + \\beta_1 u_x(1,t) = r_1(t)$. Using the central difference $u_x(1,t) \\approx \\frac{u_{N+1} - u_{N-1}}{2h}$:\n$$\n\\alpha_1 u_N + \\beta_1 \\frac{u_{N+1} - u_{N-1}}{2h} = r_1(t)\n$$\nSolving for $u_{N+1}$ (assuming $\\beta_1 \\neq 0$):\n$$\nu_{N+1} = u_{N-1} + \\frac{2h}{\\beta_1}(r_1(t) - \\alpha_1 u_N) = u_{N-1} - \\frac{2h\\alpha_1}{\\beta_1}u_N + \\frac{2h}{\\beta_1}r_1(t)\n$$\nSubstituting this into the equation for $du_N/dt$:\n$$\n\\frac{du_N}{dt} = \\frac{1}{h^2}\\left( u_{N-1} - 2u_N + \\left(u_{N-1} - \\frac{2h\\alpha_1}{\\beta_1}u_N + \\frac{2h}{\\beta_1}r_1(t)\\right) \\right) + f_N(t)\n$$\n$$\n\\frac{du_N}{dt} = \\frac{2}{h^2}u_{N-1} + \\left(-\\frac{2}{h^2} - \\frac{2\\alpha_1}{h\\beta_1}\\right)u_N + \\frac{2}{h\\beta_1}r_1(t) + f_N(t)\n$$\nA Neumann condition $u_x = g(t)$ is a special case of the Robin condition with $\\alpha=0$, $\\beta=1$, and $r(t)=g(t)$.\n\n**3. The Assembled Matrix System**\n\nThe set of $(N+1)$ ODEs can be written in the matrix form $\\frac{d\\mathbf{u}}{dt} = A\\mathbf{u} + \\mathbf{w}(t) + \\mathbf{f}(t)$.\nThe matrix $A$ is a constant $(N+1) \\times (N+1)$ matrix representing the modified discrete Laplacian.\n- For interior rows $i \\in \\{1, \\dots, N-1\\}$:\n  $A_{i,i-1} = 1/h^2$, $A_{i,i} = -2/h^2$, $A_{i,i+1} = 1/h^2$.\n- For the first row ($i=0$):\n  $A_{0,0} = -2/h^2 + 2\\alpha_0/(h\\beta_0)$, $A_{0,1} = 2/h^2$.\n- For the last row ($i=N$):\n  $A_{N,N-1} = 2/h^2$, $A_{N,N} = -2/h^2 - 2\\alpha_1/(h\\beta_1)$.\n\nThe vector $\\mathbf{w}(t)$ depends on the inhomogeneous boundary data:\n- $w_0(t) = -2r_0(t)/(h\\beta_0)$\n- $w_i(t) = 0$ for $i \\in \\{1, \\dots, N-1\\}$\n- $w_N(t) = 2r_1(t)/(h\\beta_1)$\n\nThe vector $\\mathbf{f}(t)$ contains the source term evaluated at grid points: $\\mathbf{f}(t) = [f_0(t), \\dots, f_N(t)]^T$.\n\n**4. Crank-Nicolson Temporal Integration**\n\nThe Crank-Nicolson method is applied to the semi-discrete system. It is an implicit method with second-order accuracy in time. Applying the method to our system gives:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2}\\left( A\\mathbf{u}^{n+1} + \\mathbf{w}^{n+1} + \\mathbf{f}^{n+1} \\right) + \\frac{1}{2}\\left( A\\mathbf{u}^n + \\mathbf{w}^n + \\mathbf{f}^n \\right)\n$$\nwhere $\\mathbf{u}^n = \\mathbf{u}(t^n)$, $\\mathbf{w}^n = \\mathbf{w}(t^n)$, and $\\mathbf{f}^n = \\mathbf{f}(t^n)$, with $t^n = n\\Delta t$. Rearranging to solve for $\\mathbf{u}^{n+1}$:\n$$\n\\left(I - \\frac{\\Delta t}{2} A\\right)\\mathbf{u}^{n+1} = \\left(I + \\frac{\\Delta t}{2} A\\right)\\mathbf{u}^{n} + \\frac{\\Delta t}{2}\\left(\\mathbf{f}^n + \\mathbf{f}^{n+1}\\right) + \\frac{\\Delta t}{2}\\left(\\mathbf{w}^n + \\mathbf{w}^{n+1}\\right).\n$$\nAt each time step, we solve this linear system for the unknown vector $\\mathbf{u}^{n+1}$.\n\n**5. Manufactured Solution and Data**\n\nThe problem provides an exact solution to manufacture the source, initial, and boundary data.\n- Exact solution: $u_{\\text{exact}}(x,t) = e^{-t}(\\sin(\\pi x) + x)$\n- Initial condition ($t=0$): $u_0(x) = u(x,0) = \\sin(\\pi x) + x$\n- Derivatives:\n  - $u_t(x,t) = -e^{-t}(\\sin(\\pi x) + x)$\n  - $u_x(x,t) = e^{-t}(\\pi\\cos(\\pi x) + 1)$\n  - $u_{xx}(x,t) = -\\pi^2 e^{-t}\\sin(\\pi x)$\n- Source term: $f(x,t) = u_t - u_{xx} = e^{-t}((\\pi^2-1)\\sin(\\pi x) - x)$\n- Boundary data:\n  - At $x=0$: $u(0,t)=0$, $u_x(0,t) = (\\pi+1)e^{-t}$. The Robin data is $r_0(t) = \\alpha_0(0) + \\beta_0(\\pi+1)e^{-t} = \\beta_0(\\pi+1)e^{-t}$. The Neumann data is $g_0(t) = (\\pi+1)e^{-t}$.\n  - At $x=1$: $u(1,t)=e^{-t}$, $u_x(1,t) = (1-\\pi)e^{-t}$. The Robin data is $r_1(t) = \\alpha_1 e^{-t} + \\beta_1(1-\\pi)e^{-t} = (\\alpha_1+\\beta_1(1-\\pi))e^{-t}$. The Neumann data is $g_1(t) = (1-\\pi)e^{-t}$.\n\nThe algorithm proceeds by initializing $\\mathbf{u}$ at $t=0$ and repeatedly solving the Crank-Nicolson system until $t=T$. The final numerical solution is then compared to the exact solution to compute the error.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D heat equation with mixed boundary conditions using a\n    Crank-Nicolson scheme with ghost points for the specified test cases.\n    \"\"\"\n\n    T_FINAL = 0.1\n    KAPPA = 1.0\n\n    # --- Manufactured Solution and its derivatives ---\n    def u_exact_func(x, t):\n        return np.exp(-t) * (np.sin(np.pi * x) + x)\n\n    def f_source_func(x, t):\n        return np.exp(-t) * ((np.pi**2 - 1) * np.sin(np.pi * x) - x)\n    \n    def u_exact_dx_func(x, t):\n        return np.exp(-t) * (np.pi * np.cos(np.pi * x) + 1)\n\n    def run_simulation(N, dt, bc_left_type, bc_right_type, params_left, params_right):\n        \"\"\"\n        Runs a single simulation case and returns the max-norm error.\n\n        Args:\n            N (int): Number of spatial intervals.\n            dt (float): Time step size.\n            bc_left_type (str): 'neumann' or 'robin'.\n            bc_right_type (str): 'neumann' or 'robin'.\n            params_left (tuple): (alpha_0, beta_0) for Robin BC at x=0.\n            params_right (tuple): (alpha_1, beta_1) for Robin BC at x=1.\n\n        Returns:\n            float: Maximum norm error at T_FINAL.\n        \"\"\"\n        # --- Grid Setup ---\n        h = 1.0 / N\n        x = np.linspace(0.0, 1.0, N + 1)\n\n        # --- Boundary Data Functions ---\n        def r0_func(t):\n            if bc_left_type == 'neumann':\n                return u_exact_dx_func(0.0, t)  # g0(t)\n            else:\n                alpha0, beta0 = params_left\n                return alpha0 * u_exact_func(0.0, t) + beta0 * u_exact_dx_func(0.0, t)\n\n        def r1_func(t):\n            if bc_right_type == 'neumann':\n                return u_exact_dx_func(1.0, t)  # g1(t)\n            else:\n                alpha1, beta1 = params_right\n                return alpha1 * u_exact_func(1.0, t) + beta1 * u_exact_dx_func(1.0, t)\n\n        # --- System Assembly (A and w(t)) ---\n        A = np.zeros((N + 1, N + 1))\n        \n        # Interior points\n        gamma = KAPPA / h**2\n        for i in range(1, N):\n            A[i, i-1] = gamma\n            A[i, i] = -2.0 * gamma\n            A[i, i+1] = gamma\n\n        # Boundary conditions\n        alpha0, beta0 = (0.0, 1.0) if bc_left_type == 'neumann' else params_left\n        alpha1, beta1 = (0.0, 1.0) if bc_right_type == 'neumann' else params_right\n\n        # Left boundary (i=0)\n        A[0, 0] = -2.0 * gamma + 2.0 * KAPPA * alpha0 / (h * beta0)\n        A[0, 1] = 2.0 * gamma\n\n        # Right boundary (i=N)\n        A[N, N-1] = 2.0 * gamma\n        A[N, N] = -2.0 * gamma - 2.0 * KAPPA * alpha1 / (h * beta1)\n\n        def w_vec_func(t):\n            w = np.zeros(N + 1)\n            w[0] = -2.0 * KAPPA * r0_func(t) / (h * beta0)\n            w[N] = 2.0 * KAPPA * r1_func(t) / (h * beta1)\n            return w\n\n        # --- Crank-Nicolson Matrices ---\n        Id = np.identity(N + 1)\n        M_lhs = Id - (dt / 2.0) * A\n        M_rhs = Id + (dt / 2.0) * A\n        \n        # --- Initial Condition ---\n        u = u_exact_func(x, 0.0)\n        \n        # --- Time Stepping Loop ---\n        t = 0.0\n        num_steps = int(round(T_FINAL / dt))\n        for _ in range(num_steps):\n            t_n = t\n            t_n1 = t + dt\n            \n            f_n = f_source_func(x, t_n)\n            f_n1 = f_source_func(x, t_n1)\n            w_n = w_vec_func(t_n)\n            w_n1 = w_vec_func(t_n1)\n            \n            # Form RHS of the linear system\n            rhs = M_rhs @ u + (dt / 2.0) * (f_n + f_n1 + w_n + w_n1)\n            \n            # Solve for next time step\n            u_new = np.linalg.solve(M_lhs, rhs)\n            \n            u = u_new\n            t = t_n1\n            \n        # --- Error Calculation ---\n        u_final_exact = u_exact_func(x, T_FINAL)\n        error = np.max(np.abs(u - u_final_exact))\n        \n        return error\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case A: Neumann–Neumann\n        {'N': 50, 'dt': 0.0002, 'bc_left': 'neumann', 'bc_right': 'neumann', \n         'params_left': None, 'params_right': None},\n        # Case B: Robin–Neumann\n        {'N': 50, 'dt': 0.0002, 'bc_left': 'robin', 'bc_right': 'neumann', \n         'params_left': (1.0, 1.0), 'params_right': None},\n        # Case C: Neumann–Robin\n        {'N': 60, 'dt': 0.0001, 'bc_left': 'neumann', 'bc_right': 'robin', \n         'params_left': None, 'params_right': (2.0, 0.5)},\n        # Case D: Robin–Robin\n        {'N': 80, 'dt': 0.0001, 'bc_left': 'robin', 'bc_right': 'robin', \n         'params_left': (1.5, 0.7), 'params_right': (0.5, 1.2)},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_simulation(\n            N=case['N'],\n            dt=case['dt'],\n            bc_left_type=case['bc_left'],\n            bc_right_type=case['bc_right'],\n            params_left=case['params_left'],\n            params_right=case['params_right']\n        )\n        results.append(round(error, 8))\n\n    # --- Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}