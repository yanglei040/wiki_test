{
    "hands_on_practices": [
        {
            "introduction": "尽管多种数值格式可能具有相同的理论收敛阶，但由于其截断误差常数的不同，它们的实际性能可能会有显著差异。本练习  对两种用于实现 Robin 边界条件的、理论上均为二阶精度的不同方法进行了直接比较。通过分别实现经典的鬼点法和单侧模板法，您将定量地评估它们的精度，并体会区分不同数值公式的细微之处。",
            "id": "3400414",
            "problem": "考虑闭区间 $[0,1]$ 上的一维稳态泊松问题，\n$$-u''(x) = f(x), \\quad x \\in (0,1),$$\n其左端点为 Robin 边界条件，右端点为 Dirichlet 边界条件：\n$$\\alpha\\,u(0) + \\beta\\,u'(0) = \\gamma,\\quad u(1) = u_R.$$\n假设使用均匀网格，步长为 $h = 1/N$，网格点为 $x_i = i h$，$i=0,1,\\dots,N$。设精确解为 $u(x) = e^x$，因此 $f(x) = -e^x$，并选择与精确解一致的边界数据，即 $u_R = e^1$ 且 $\\gamma = \\alpha\\,u(0) + \\beta\\,u'(0) = \\alpha + \\beta$。\n\n您必须在 $x=0$（Robin 边界）处实现两种代数上不同、形式上二阶精度的边界封闭方法，同时对内部的 $-u''$ 离散化使用标准的二阶中心差分。两种方法都应生成一个关于节点值 $\\{u_i\\}$ 的线性系统，通过求解该系统来得到未知数。\n\n- 方法 A（使用虚拟节点和在 $i=0$ 处固定边界模板的中心化虚拟导数封闭法）：\n  - 在所有网格点（包括 $i=0$）上，对 $-u''$ 使用二阶中心有限差分：\n    $$-u''(x_i)\\approx \\frac{-u_{i-1}+2u_i-u_{i+1}}{h^2}.$$\n  - 在 $x_{-1}=-h$ 处引入一个虚拟值 $u_{-1}$。通过使用包含该虚拟值的中心差分来近似 $u'(0)$，从而施加 Robin 边界条件：\n    $$u'(0)\\approx \\frac{u_1 - u_{-1}}{2h}.$$\n    利用 Robin 边界条件消去虚拟值 $u_{-1}$，并将其代入 $i=0$ 处的离散方程。根据给定的 Dirichlet 数据处理 $i=N$。\n\n- 方法 B（不使用虚拟节点的单侧三点二阶导数封闭法）：\n  - 对于内部节点 $i=1,2,\\dots,N-1$，与方法 A 一样，对 $-u''$ 使用二阶中心差分。\n  - 在 $i=0$ 处，通过使用导数的单侧三点二阶近似来施加 Robin 边界条件：\n    $$u'(0)\\approx \\frac{-3u_0 + 4u_1 - u_2}{2h}.$$\n\n对于这两种方法，建立并求解节点 $i=0,1,\\dots,N-1$ 处未知数的线性系统，其中 $u_N=u(1)=e^1$ 为已知。对于每种方法和给定的 $N$，计算边界点误差 $e_0(h) = |u_0 - u(0)| = |u_0 - e^0|$，然后构建边界误差常数估计量\n$$C(h) = \\frac{e_0(h)}{h^2}.$$\n\n您的任务是设计一个计算测试，以揭示哪种边界封闭方法产生的边界误差常数更小。具体来说，对于下面的每个测试用例，估计比率\n$$R = \\frac{C_B(h_\\text{fine})}{C_A(h_\\text{fine})},$$\n其中 $C_A$ 和 $C_B$ 分别表示方法 A 和方法 B 的边界误差常数估计量，在足够精细的网格间距 $h_\\text{fine}$ 上进行评估（基于这样的理解：对于二阶方法，当 $h$ 很小时，$C(h)$ 是渐近常数）。比率 $R<1$ 表明在该测试中方法 B 的边界误差常数小于方法 A，而 $R>1$ 则表明情况相反。\n\n为以下测试套件实现上述过程，其中每个测试指定 $x=0$ 处 Robin 边界的 $(\\alpha,\\beta)$：\n- 测试 1：$(\\alpha,\\beta)=(1,1)$。\n- 测试 2：$(\\alpha,\\beta)=(0,1)$。\n- 测试 3：$(\\alpha,\\beta)=(2,0.5)$。\n\n使用 $N=512$ 的精细网格，因此 $h=1/512$。对于每个测试，计算如上定义的 $R$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，即按给定顺序排列的三个测试的列表 $[R_1,R_2,R_3]$。每个 $R_k$ 必须以浮点数形式打印，小数点后精确到六位。",
            "solution": "所述问题在科学上是合理的、自洽的且适定的。它提出了一个标准的数值分析任务，涉及比较两种不同的二阶有限差分方法来处理 Robin 边界条件。因此，该问题被认为是有效的，并将提供一个解决方案。\n\n所考虑的问题是一维稳态泊松方程：\n$$ -u''(x) = f(x), \\quad x \\in (0,1) $$\n其在 $x=0$ 处为 Robin 边界条件，在 $x=1$ 处为 Dirichlet 边界条件：\n$$ \\alpha\\,u(0) + \\beta\\,u'(0) = \\gamma $$\n$$ u(1) = u_R $$\n我们已知精确解为 $u(x) = e^x$，这意味着源项必须为 $f(x) = -u''(x) = -e^x$。边界数据被选择为与此解一致：$u_R = u(1) = e^1$，以及 $\\gamma = \\alpha\\,u(0) + \\beta\\,u'(0) = \\alpha\\,(1) + \\beta\\,(1) = \\alpha + \\beta$。\n\n我们使用一个包含 $N+1$ 个点 $x_i = ih$（$i=0, 1, \\dots, N$）的均匀网格，其中网格间距为 $h=1/N$。设 $u_i$ 是精确解 $u(x_i)$ 的数值近似。未知数是节点值 $\\{u_0, u_1, \\dots, u_{N-1}\\}$。值 $u_N$ 由 Dirichlet 条件可知：$u_N = u_R = e^1$。这就得到了一个包含 $N$ 个未知数的 $N$ 个线性方程组。\n\n对于内部网格点 $i=1, 2, \\dots, N-1$，我们对二阶导数使用标准的二阶中心有限差分近似：\n$$ -u''(x_i) \\approx \\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2} $$\n这导出了以下 $N-1$ 个线性方程组：\n$$ -u_{i-1} + 2u_i - u_{i+1} = h^2 f(x_i) = -h^2 e^{x_i} \\quad \\text{for } i=1, \\dots, N-1. $$\n对于 $i=N-1$ 的方程涉及已知值 $u_N$：\n$$ -u_{N-2} + 2u_{N-1} - u_N = -h^2 e^{x_{N-1}} \\implies -u_{N-2} + 2u_{N-1} = -h^2 e^{x_{N-1}} + u_N $$\n\n最后一个方程，对应于节点 $i=0$，是使用两种不同方法从 Robin 边界条件推导出来的。\n\n### 方法 A：虚拟节点中心封闭法\n此方法通过在 $x_{-1} = -h$ 处引入一个值为 $u_{-1}$ 的未知“虚拟”点，在边界点 $i=0$ 处施加偏微分方程。\n$i=0$ 处的偏微分方程离散化为：\n$$ \\frac{-u_{-1} + 2u_0 - u_1}{h^2} = f(x_0) = -e^0 = -1 $$\nRobin 边界条件使用 $u'(0)$ 导数的二阶中心差分进行离散化：\n$$ \\alpha u_0 + \\beta \\left(\\frac{u_1 - u_{-1}}{2h}\\right) = \\gamma $$\n我们消去虚拟值 $u_{-1}$。从离散化的边界条件中，我们求解 $u_{-1}$（假设 $\\beta \\neq 0$，这对所有测试用例都成立）：\n$$ u_{-1} = u_1 - \\frac{2h}{\\beta}(\\gamma - \\alpha u_0) = u_1 + \\frac{2h\\alpha}{\\beta}u_0 - \\frac{2h\\gamma}{\\beta} $$\n将 $u_{-1}$ 的这个表达式代入 $i=0$ 处的离散化偏微分方程：\n$$ -\\left(u_1 + \\frac{2h\\alpha}{\\beta}u_0 - \\frac{2h\\gamma}{\\beta}\\right) + 2u_0 - u_1 = -h^2 $$\n对未知数 $u_0$ 和 $u_1$ 的项进行分组，我们得到线性系统的第一个方程：\n$$ \\left(2 - \\frac{2h\\alpha}{\\beta}\\right)u_0 - 2u_1 = -h^2 - \\frac{2h\\gamma}{\\beta} $$\n\n### 方法 B：单侧导数封闭法\n此方法不使用虚拟点。相反，在 $i=0$ 处的方程是通过对导数 $u'(0)$ 采用单侧二阶精度近似，直接从 Robin 边界条件推导出来的：\n$$ u'(0) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h} $$\n将此代入 Robin 边界条件 $\\alpha u_0 + \\beta u'(0) = \\gamma$ 得到：\n$$ \\alpha u_0 + \\beta \\left(\\frac{-3u_0 + 4u_1 - u_2}{2h}\\right) = \\gamma $$\n乘以 $2h$ 并对未知数 $u_0$、$u_1$ 和 $u_2$ 的项进行分组，得到线性系统的第一个方程：\n$$ (2h\\alpha - 3\\beta)u_0 + 4\\beta u_1 - \\beta u_2 = 2h\\gamma $$\n\n### 系统组装与求解\n对于每种方法，我们组装一个 $N \\times N$ 的矩阵系统 $A\\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$。\n\n**方法 A 的系统：**\n- 第一行 ($i=0$)：\n  $A_{0,0} = 2 - 2h\\alpha/\\beta$，$A_{0,1} = -2$，以及 $b_0 = -h^2 - 2h\\gamma/\\beta$。\n- 内部行 ($i=1, \\dots, N-2$)：\n  $A_{i,i-1}=-1$，$A_{i,i}=2$，$A_{i,i+1}=-1$，以及 $b_i = -h^2e^{x_i}$。\n- 最后一行 ($i=N-1$)：\n  $A_{N-1,N-2}=-1$，$A_{N-1,N-1}=2$，以及 $b_{N-1} = -h^2e^{x_{N-1}} + u_N$。\n\n**方法 B 的系统：**\n- 第一行 ($i=0$)：\n  $A_{0,0} = 2h\\alpha - 3\\beta$，$A_{0,1} = 4\\beta$，$A_{0,2} = -\\beta$，以及 $b_0 = 2h\\gamma$。\n- 内部行和最后一行与方法 A 中的相同。\n\n对于每个测试用例 $(\\alpha, \\beta)$，以及 $N=512$，我们为方法 A 和方法 B 建立并求解线性系统，以找到数值解，特别是边界值 $u_0^{(A)}$ 和 $u_0^{(B)}$。\n\n每种方法的边界点误差计算为 $e_0(h) = |u_0 - u(0)| = |u_0 - 1|$。相应的误差常数估计量为 $C_A(h) = e_0^{(A)}(h)/h^2$ 和 $C_B(h) = e_0^{(B)}(h)/h^2$。最后一步是为每个测试用例计算比率 $R = C_B(h)/C_A(h)$。",
            "answer": "```python\nimport numpy as np\n\ndef solve_poisson_1d(N, alpha, beta, method):\n    \"\"\"\n    Solves the 1D Poisson problem with a Robin/Dirichlet BC using two methods.\n\n    Args:\n        N (int): Number of intervals, such that h = 1/N.\n        alpha (float): Robin condition parameter.\n        beta (float): Robin condition parameter.\n        method (str): 'A' or 'B' for the boundary closure method.\n\n    Returns:\n        float: The numerical solution u_0 at the boundary x=0.\n    \"\"\"\n    h = 1.0 / N\n    gamma = alpha + beta\n    u_R = np.exp(1.0)\n    \n    # Grid points and source function values\n    x_nodes = np.linspace(0, 1, N + 1)\n    f_vals = -np.exp(x_nodes)\n    \n    # System A*u = b for unknowns u = [u_0, ..., u_{N-1}]\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n    \n    # Interior rows (i=1 to N-2) are common to both methods\n    for i in range(1, N - 1):\n        A[i, i-1] = -1.0\n        A[i, i]   = 2.0\n        A[i, i+1] = -1.0\n        b[i] = h**2 * f_vals[i]\n        \n    # Last row (i=N-1) is common to both methods\n    if N > 1:\n        A[N-1, N-2] = -1.0\n    A[N-1, N-1] = 2.0\n    b[N-1] = h**2 * f_vals[N-1] + u_R\n        \n    # First row (i=0) depends on the chosen method\n    if method == 'A':\n        # Method A: Ghost-node centered closure\n        # (2 - 2h*alpha/beta)u_0 - 2u_1 = -h^2 - 2h*gamma/beta\n        A[0, 0] = 2.0 - 2.0 * h * alpha / beta\n        if N > 1:\n            A[0, 1] = -2.0\n        # Use f_vals[0] for f(x_0) which equals -h^2*exp(0) = -h^2.\n        b[0] = h**2 * f_vals[0] - 2.0 * h * gamma / beta\n    elif method == 'B':\n        # Method B: One-sided derivative closure\n        # (2h*alpha - 3*beta)u_0 + 4*beta*u_1 - beta*u_2 = 2h*gamma\n        A[0, 0] = 2.0 * h * alpha - 3.0 * beta\n        if N > 1:\n            A[0, 1] = 4.0 * beta\n        if N > 2:\n            A[0, 2] = -beta\n        b[0] = 2.0 * h * gamma\n    else:\n        raise ValueError(\"Invalid method specified. Choose 'A' or 'B'.\")\n        \n    # Solve the linear system\n    u_solution = np.linalg.solve(A, b)\n    \n    return u_solution[0]\n\ndef solve():\n    \"\"\"\n    Main function to run the computational test and print the results.\n    \"\"\"\n    N = 512\n    h = 1.0 / N\n    u_exact_0 = 1.0  # Exact solution u(0) = exp(0)\n    \n    test_cases = [\n        # (alpha, beta)\n        (1.0, 1.0),\n        (0.0, 1.0),\n        (2.0, 0.5)\n    ]\n    \n    R_values = []\n    \n    for alpha, beta in test_cases:\n        # Solve using Method A\n        u0_A = solve_poisson_1d(N, alpha, beta, method='A')\n        \n        # Solve using Method B\n        u0_B = solve_poisson_1d(N, alpha, beta, method='B')\n        \n        # Calculate boundary pointwise errors\n        e0_A = abs(u0_A - u_exact_0)\n        e0_B = abs(u0_B - u_exact_0)\n        \n        # Calculate error constant estimators\n        # C(h) = e0(h) / h^2\n        C_A = e0_A / h**2\n        C_B = e0_B / h**2\n        \n        # The problem formulation ensures C_A will be non-zero for these tests\n        if C_A == 0:\n            # Handle the unlikely case of zero error for Method A\n             R = np.inf if C_B != 0 else 1.0 # Or np.nan\n        else:\n             R = C_B / C_A\n\n        R_values.append(R)\n        \n    # Print the final result in the specified format\n    print(f\"[{','.join([f'{r:.6f}' for r in R_values])}]\")\n\n# Execute the solution\nsolve()\n```"
        },
        {
            "introduction": "标准的有限差分格式在简洁性与精度之间取得了平衡，但通过系统地修正主导截断误差项，我们往往可以获得更高的精度。本练习  深入探讨了一种高阶鬼点格式的构建过程。您将通过泰勒级数分析推导特定的修正项，并进行数值验证，以证明该修正格式确实提高了收敛速度，从而阐释一种设计高级数值算法的基本技巧。",
            "id": "3400494",
            "problem": "考虑区间 $[0,1]$ 上的标量场 $u(x)$ 的两点边值问题，该问题由常微分方程 $-u''(x)=f(x)$ 控制，在 $x=0$ 处服从 Neumann 型边界条件 $u'(0)=g$ 或 Robin 型边界条件 $a\\,u(0)+b\\,u'(0)=r$，并在 $x=1$ 处服从由精确制造解给定的 Dirichlet 条件。在均匀网格 $x_j=jh$（$j\\in\\{0,1,\\dots,N\\}$，$h=1/N$）上进行计算，并引入一个值为 $u_{-1}$ 的鬼点 $x_{-1}=-h$ 来封闭 $x=0$ 处的边界。\n\n在 $x=0$ 处使用以下配对边界封闭格式：一个在 $j=0$ 处求值的微分算子离散方程，\n$$\n\\frac{-u_1+2u_0-u_{-1}}{h^2}=f(0)+\\beta\\,h^2 f''(0),\n$$\n结合一个从 $x=0$ 处边界条件推导出的鬼点消除关系式，\n- Neumann：\n$$\n\\frac{u_1-u_{-1}}{2h}+\\alpha\\,h^2 f'(0)=g,\n$$\n- Robin：\n$$\na\\,u_0+b\\left(\\frac{u_1-u_{-1}}{2h}+\\alpha\\,h^2 f'(0)\\right)=r.\n$$\n\n任务1（推导）。仅从 $x=0$ 处的 Taylor 展开式以及微分方程 $-u''(x)=f(x)$ 及其导数出发，确定系数 $\\alpha$ 和 $\\beta$ 的值，以消除在 $x=0$ 处的配对封闭格式中的主阶边界截断误差。“消除”的概念是：当精确解 $u(x)$ 代入左侧，精确数据代入右侧时，对于一般光滑的 $u(x)$，配对系统在 $j=0$ 处的残差量级为 $\\mathcal{O}(h^3)$ 或更高；对于满足 $f''(0)\\neq 0$ 的解析函数 $u(x)$，残差量级达到 $\\mathcal{O}(h^4)$。你的推导必须从 $u(\\pm h)$ 的 Taylor 多项式开始，利用 $-u''=f$ 消去 $u^{(k)}(0)$ 并用 $f^{(\\ell)}(0)$ 表示，然后确定使 $\\mathcal{O}(h)$ 和 $\\mathcal{O}(h^2)$ 阶残差项同时为零所需的 $\\alpha$ 和 $\\beta$ 的条件。\n\n任务2（通过制造解进行验证）。实现两个具体的制造解及其导出数据：\n- 正弦：$u(x)=\\sin(\\pi x)$，因此 $f(x)=\\pi^2\\sin(\\pi x)$, $u'(0)=\\pi$, $f'(0)=\\pi^3$, $f''(0)=-\\pi^4\\sin(0)=0$。\n- 指数：$u(x)=e^{\\lambda x}$，其中 $\\lambda$ 是给定的固定参数，因此 $f(x)=-\\lambda^2 e^{\\lambda x}$, $u'(0)=\\lambda$, $f'(0)=-\\lambda^3$, $f''(0)=-\\lambda^4$。\n\n对于 Robin 边界条件，使用固定的实常数 $a$ 和 $b$（$b\\neq 0$），并根据制造解定义 $r=a\\,u(0)+b\\,u'(0)$。对于 Neumann 边界条件，根据制造解设置 $g=u'(0)$。在两种情况下，都在 $x=1$ 处使用精确值 $u(1)$，对于正弦情况是 $u(1)=\\sin(\\pi)$，对于指数情况是 $u(1)=e^{\\lambda}$。\n\n任务3（离散残差阶数测量）。对于每种制造解和每种边界类型（Neumann 和 Robin），通过将精确节点值 $u_0=u(0)$ 和 $u_1=u(h)$ 以及精确数据代入离散公式，构建 $j=0$ 处的配对边界残差。定义：\n- 基准格式：$\\alpha=0$ 且 $\\beta=0$。\n- 修正格式：使用你从任务1中推导出的 $\\alpha$ 和 $\\beta$。\n\n对于每种格式，从相应的边界关系式中代数地构造鬼点值 $u_{-1}$，然后在 $j=0$ 处计算离散微分方程的左侧，以获得离散残差 $R_0(h)$，即：\n$$\nR_0(h)=\\frac{-u_1+2u_0-u_{-1}}{h^2}-\\left(f(0)+\\beta\\,h^2 f''(0)\\right),\n$$\n其中 $u_1=u(h)$ 和 $u_0=u(0)$。通过对一对通过将 $h$ 减半而相关的网格尺寸计算\n$$\np=\\log_2\\left(\\frac{|R_0(h)|}{|R_0(h/2)|}\\right)\n$$\n来测量边界残差的观测阶 $p$。\n\n测试套件规范。使用以下参数集：\n- 制造解：正弦情况和 $\\lambda=2$ 的指数情况。\n- 边界类型：Neumann 和 Robin，系数为 $a=2$ 和 $b=1$。\n- 网格尺寸：$N_1=64$ 和 $N_2=128$（因此 $h_1=1/N_1$ 和 $h_2=1/N_2$）。\n\n你的程序必须为四种组合（Neumann-正弦，Neumann-指数，Robin-正弦，Robin-指数）中的每一种计算基准格式和修正格式的观测阶。最终输出应为单行，包含一个逗号分隔的 Python 列表，其中包含八个浮点数，顺序如下：\n$[\\text{Neu-sin 基准},\\text{Neu-sin 修正},\\text{Neu-exp 基准},\\text{Neu-exp 修正},\\text{Rob-sin 基准},\\text{Rob-sin 修正},\\text{Rob-exp 基准},\\text{Rob-exp 修正}]$。\n\n最终输出格式。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8]$）。不应打印任何附加文本。不涉及角度，也不需要物理单位。所有数值输出必须是普通的十进制浮点数；可以四舍五入到三位小数。代码必须完全自包含，不需要用户输入。",
            "solution": "该问题被评估为有效。这是一个数值分析领域的适定问题，涉及分析有限差分格式截断误差的标准、可验证技术。所有提供的信息都是自包含的、有科学依据且无歧义的。\n\n### 任务1：系数 $\\alpha$ 和 $\\beta$ 的推导\n\n目标是确定配对边界封闭格式中的系数 $\\alpha$ 和 $\\beta$，以消除在边界 $x=0$ 处的局部截断误差的主阶项。该过程包括将精确解 $u(x)$ 代入离散方程，进行 Taylor 级数分析，并选择 $\\alpha$ 和 $\\beta$ 来消去最低阶的误差项。\n\n在 $x=0$ 处的配对边界封闭格式由两个方程组成：\n1.  微分方程 $-u''(x)=f(x)$ 在 $x_0=0$ 处的修正离散形式：\n    $$ \\frac{-u_1+2u_0-u_{-1}}{h^2}=f(0)+\\beta\\,h^2 f''(0) $$\n2.  边界条件的离散表示，用于消除鬼点值 $u_{-1}$。我们分析 Neumann 和 Robin 两种情况。\n\n设 $u(x)$ 为精确解，并假定其足够光滑。我们使用记号 $u_j = u(x_j)$，$u_0 = u(0)$，$u_1 = u(h)$，$u_{-1}$ 是鬼点值，$u^{(k)}_0 = \\frac{d^k u}{dx^k}(0)$。从微分方程，我们有关系式 $u^{(k)}_0 = -f^{(k-2)}_0$ 对于 $k \\ge 2$，其中 $f^{(m)}_0 = \\frac{d^m f}{dx^m}(0)$。\n\n首先，考虑 Robin 边界条件 $a\\,u(0)+b\\,u'(0)=r$，其离散形式为：\n$$ a\\,u_0+b\\left(\\frac{u_1-u_{-1}}{2h}+\\alpha\\,h^2 f'(0)\\right)=r $$\n我们将精确值代入此关系式：$u_0 = u(0)$，$u_1 = u(h)$，以及 $r = a\\,u(0)+b\\,u'(0)$。\n$$ a\\,u(0)+b\\left(\\frac{u(h)-u_{-1}}{2h}+\\alpha\\,h^2 f'(0)\\right)=a\\,u(0)+b\\,u'(0) $$\n假设 $b \\neq 0$，我们可以解出隐含的鬼点值 $u_{-1}$：\n$$ \\frac{u(h)-u_{-1}}{2h}+\\alpha\\,h^2 f'(0) = u'(0) $$\n$$ u(h)-u_{-1} = 2h\\,u'(0) - 2h\\,\\alpha\\,h^2 f'(0) $$\n$$ u_{-1} = u(h) - 2h\\,u'(0) + 2\\alpha h^3 f'(0) $$\nNeumann 情况 $u'(0)=g$ 及其离散形式 $\\frac{u_1-u_{-1}}{2h}+\\alpha h^2 f'(0)=g$，在设置 $g=u'(0)$ 后，会为 $u_{-1}$ 产生相同的表达式。因此，两种边界条件类型的推导是相同的。\n\n核心任务是在代入 $u_{-1}$ 的表达式后，分析在 $j=0$ 处的离散微分方程的残差。残差 $R_0(h)$ 定义为将精确解代入数值格式：\n$$ R_0(h) = \\frac{-u(h)+2u(0)-u_{-1}}{h^2} - \\left(f(0)+\\beta\\,h^2 f''(0)\\right) $$\n代入 $u_{-1}$ 的表达式：\n$$ R_0(h) = \\frac{-u(h)+2u(0)-\\left(u(h) - 2h\\,u'(0) + 2\\alpha h^3 f'(0)\\right)}{h^2} - \\left(f(0)+\\beta\\,h^2 f''(0)\\right) $$\n$$ R_0(h) = \\frac{2u(0) - 2u(h) + 2h\\,u'(0)}{h^2} - 2\\alpha h f'(0) - f(0) - \\beta h^2 f''(0) $$\n为分析此表达式，我们使用 $u(h)$ 在 $x=0$ 附近的 Taylor 级数展开：\n$$ u(h) = u(0) + h\\,u'(0) + \\frac{h^2}{2}u''(0) + \\frac{h^3}{6}u'''(0) + \\frac{h^4}{24}u^{(4)}(0) + \\frac{h^5}{120}u^{(5)}(0) + \\mathcal{O}(h^6) $$\n将此代入包含 $u(h)$ 的项中：\n$$ 2u(0) - 2u(h) + 2h\\,u'(0) = 2u_0 - 2\\left(u_0 + h u'_0 + \\frac{h^2}{2}u''_0 + \\frac{h^3}{6}u'''_0 + \\dots\\right) + 2h u'_0 $$\n$$ = -h^2 u''_0 - \\frac{h^3}{3}u'''_0 - \\frac{h^4}{12}u^{(4)}_0 - \\frac{h^5}{60}u^{(5)}_0 - \\mathcal{O}(h^6) $$\n除以 $h^2$，残差的第一部分变为：\n$$ \\frac{2u(0) - 2u(h) + 2h\\,u'(0)}{h^2} = -u''_0 - \\frac{h}{3}u'''_0 - \\frac{h^2}{12}u^{(4)}_0 - \\frac{h^3}{60}u^{(5)}_0 - \\mathcal{O}(h^4) $$\n现在，我们使用来自常微分方程的关系式，$u''_0 = -f_0$，$u'''_0 = -f'_0$，$u^{(4)}_0 = -f''_0$，依此类推：\n$$ = -(-f_0) - \\frac{h}{3}(-f'_0) - \\frac{h^2}{12}(-f''_0) - \\frac{h^3}{60}(-f'''_0) - \\mathcal{O}(h^4) $$\n$$ = f_0 + \\frac{h}{3}f'_0 + \\frac{h^2}{12}f''_0 + \\frac{h^3}{60}f'''_0 + \\mathcal{O}(h^4) $$\n我们将此代回残差 $R_0(h)$ 的完整表达式中：\n$$ R_0(h) = \\left(f_0 + \\frac{h}{3}f'_0 + \\frac{h^2}{12}f''_0 + \\frac{h^3}{60}f'''_0\\right) - 2\\alpha h f'_0 - f_0 - \\beta h^2 f''_0 + \\mathcal{O}(h^4) $$\n按 $h$ 的幂次合并项：\n$$ R_0(h) = \\left(\\frac{1}{3} - 2\\alpha\\right)h f'_0 + \\left(\\frac{1}{12} - \\beta\\right)h^2 f''_0 + \\frac{h^3}{60}f'''_0 + \\mathcal{O}(h^4) $$\n为了消除主阶误差项，即 $\\mathcal{O}(h)$ 和 $\\mathcal{O}(h^2)$ 项，我们必须将其系数设为零：\n\\begin{enumerate}\n    \\item $h$ 的系数：$\\frac{1}{3} - 2\\alpha = 0 \\implies \\alpha = \\frac{1}{6}$\n    \\item $h^2$ 的系数：$\\frac{1}{12} - \\beta = 0 \\implies \\beta = \\frac{1}{12}$\n\\end{enumerate}\n使用这些值，残差变为：\n$$ R_0(h) = \\frac{h^3}{60}f'''_0 + \\mathcal{O}(h^4) $$\n因此，对于修正格式，只要 $f'''(0) \\neq 0$，残差的阶为 $\\mathcal{O}(h^3)$。这满足了量级为 $\\mathcal{O}(h^3)$ 或更高的要求。问题中提出的对于解析函数 $u(x)$ 且 $f''(0) \\neq 0$ 时该方法能达到 $\\mathcal{O}(h^4)$ 的说法，并未被这个直接推导所支持；如推导所示，主误差项是 $\\mathcal{O}(h^3)$。\n\n### 任务2和3：通过制造解进行验证和残差测量\n\n我们现在通过数值方法验证这些发现。我们将为基准格式（$\\alpha=0, \\beta=0$）和修正格式（$\\alpha=1/6, \\beta=1/12$）计算残差 $R_0(h)$ 及其收敛阶。\n\n制造解是：\n\\begin{itemize}\n    \\item **正弦情况**：$u(x)=\\sin(\\pi x)$。这给出 $f(x)=\\pi^2\\sin(\\pi x)$。在 $x=0$ 处，我们有 $u(0)=0$, $u'(0)=\\pi$, $f(0)=0$, $f'(0)=\\pi^3$, $f''(0)=0$。\n    \\item **指数情况**：$u(x)=e^{\\lambda x}$，其中 $\\lambda=2$。这给出 $f(x)=-\\lambda^2 e^{\\lambda x}$。在 $x=0$ 处，我们有 $u(0)=1$, $u'(0)=\\lambda=2$, $f(0)=-\\lambda^2=-4$, $f'(0)=-\\lambda^3=-8$, $f''(0)=-\\lambda^4=-16$。\n\\end{itemize}\n\n对于每种情况，我们为两个网格尺寸 $h_1=1/N_1$ 和 $h_2=1/N_2$（其中 $N_1=64$，$N_2=128$）计算残差 $R_0(h)$。残差的公式是：\n$$ R_0(h) = \\frac{-u(h)+2u(0)-u_{-1}}{h^2} - \\left(f(0)+\\beta\\,h^2 f''(0)\\right) $$\n其中 $u_{-1}$ 由边界条件关系式得出：\n$$ u_{-1} = u(h) - 2h\\,u'(0) + 2\\alpha h^3 f'(0) $$\n观测收敛阶 $p$ 的计算公式为：\n$$ p = \\log_2\\left(\\frac{|R_0(h_1)|}{|R_0(h_2)|}\\right) $$\n以下 Python 代码为四个指定的测试配置（Neumann/Robin 边界条件下的正弦/指数解）实现了此验证过程。如推导所示，残差 $R_0(h)$ 的计算对于 Neumann 和 Robin 边界条件是相同的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by deriving coefficients and performing numerical verification.\n    The derivation shows alpha=1/6 and beta=1/12. This is implemented and tested.\n    \"\"\"\n    \n    # Task 1 derived coefficients for the corrected scheme\n    ALPHA_CORRECTED = 1.0 / 6.0\n    BETA_CORRECTED = 1.0 / 12.0\n\n    # Baseline scheme coefficients\n    ALPHA_BASELINE = 0.0\n    BETA_BASELINE = 0.0\n\n    # Test parameters\n    LAMBDA = 2.0\n    A_ROBIN = 2.0\n    B_ROBIN = 1.0\n    N1 = 64\n    N2 = 128\n    \n    # --- Manufactured Solutions ---\n\n    # Sine case\n    u_sin = lambda x: np.sin(np.pi * x)\n    u_prime_sin = lambda x: np.pi * np.cos(np.pi * x)\n    f_sin = lambda x: np.pi**2 * np.sin(np.pi * x)\n    f_prime_sin = lambda x: np.pi**3 * np.cos(np.pi * x)\n    f_double_prime_sin = lambda x: -np.pi**4 * np.sin(np.pi * x)\n\n    # Exponential case\n    u_exp = lambda x: np.exp(LAMBDA * x)\n    u_prime_exp = lambda x: LAMBDA * np.exp(LAMBDA * x)\n    f_exp = lambda x: -LAMBDA**2 * np.exp(LAMBDA * x)\n    f_prime_exp = lambda x: -LAMBDA**3 * np.exp(LAMBDA * x)\n    f_double_prime_exp = lambda x: -LAMBDA**4 * np.exp(LAMBDA * x)\n\n    def calculate_residual(h, u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func, alpha, beta):\n        \"\"\"\n        Calculates the residual R_0(h) for a given manufactured solution and scheme.\n        \"\"\"\n        # Get exact values at x=0 and x=h\n        u0 = u_func(0)\n        u1 = u_func(h)\n        u_prime0 = u_prime_func(0)\n        f0 = f_func(0)\n        f_prime0 = f_prime_func(0)\n        f_double_prime0 = f_double_prime_func(0)\n        \n        # Calculate ghost point value u_{-1}\n        # This expression is the same for both Neumann and Robin cases as per the derivation.\n        u_minus_1 = u1 - 2 * h * u_prime0 + 2 * alpha * h**3 * f_prime0\n        \n        # Calculate the residual R_0(h)\n        lhs = (-u1 + 2 * u0 - u_minus_1) / h**2\n        rhs = f0 + beta * h**2 * f_double_prime0\n        residual = lhs - rhs\n        \n        return residual\n\n    def calculate_order(u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func, alpha, beta, n1, n2):\n        \"\"\"\n        Calculates the observed order of convergence p.\n        \"\"\"\n        h1 = 1.0 / n1\n        h2 = 1.0 / n2\n        \n        r1 = calculate_residual(h1, u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func, alpha, beta)\n        r2 = calculate_residual(h2, u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func, alpha, beta)\n        \n        # Handle cases where residual is zero to avoid division by zero or log(0)\n        if abs(r2) < 1e-15:\n            # If r2 is zero, the error is machine precision. If r1 was also zero, order is irrelevant.\n            # If r1 was not, convergence is faster than can be measured.\n            return np.inf\n        if abs(r1) < 1e-15:\n            # This case should not be hit if h is halved, but as a safe guard:\n            return 0.0\n\n        order = np.log2(abs(r1) / abs(r2))\n        return order\n\n\n    test_cases = [\n        # (name, u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func)\n        (\"Neu-sin\", u_sin, u_prime_sin, f_sin, f_prime_sin, f_double_prime_sin),\n        (\"Neu-exp\", u_exp, u_prime_exp, f_exp, f_prime_exp, f_double_prime_exp),\n        (\"Rob-sin\", u_sin, u_prime_sin, f_sin, f_prime_sin, f_double_prime_sin),\n        (\"Rob-exp\", u_exp, u_prime_exp, f_exp, f_prime_exp, f_double_prime_exp),\n    ]\n\n    results = []\n    for name, u, up, f, fp, fpp in test_cases:\n        # Baseline scheme\n        order_baseline = calculate_order(u, up, f, fp, fpp, ALPHA_BASELINE, BETA_BASELINE, N1, N2)\n        results.append(round(order_baseline, 3))\n        \n        # Corrected scheme\n        order_corrected = calculate_order(u, up, f, fp, fpp, ALPHA_CORRECTED, BETA_CORRECTED, N1, N2)\n        results.append(round(order_corrected, 3))\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的应用常常涉及具有复杂曲线边界的区域，这些边界与简单的笛卡尔网格并不对齐。这项高级练习  将鬼点技术推广到嵌入在结构化网格中的三维曲面边界上。您将利用符号距离函数来系统地定位鬼点并施加 Neumann 边界条件，从而获得处理复杂几何问题的强大方法的实践经验。",
            "id": "3400490",
            "problem": "考虑在一个三维笛卡尔网格上，对一个标量场使用基于有符号距离函数推导出的鬼点来数值强制施加诺伊曼边界条件。设计算区域为 $[-1,1]^3$，物理域 $\\Omega$ 为以原点为中心、半径为 $R$ 的球体内部，即边界 $\\partial \\Omega$ 由水平集 $\\{\\boldsymbol{x} \\in \\mathbb{R}^3 : \\phi(\\boldsymbol{x}) = 0\\}$ 给出，其中 $\\phi(\\boldsymbol{x}) = \\|\\boldsymbol{x}\\| - R$ 为有符号距离函数，在 $\\Omega$ 内部为负值。设未知标量场 $u(\\boldsymbol{x})$ 是光滑的。诺伊曼边界条件旨在在 $\\partial \\Omega$ 上强制施加 $\\partial u/\\partial n = g$，其中 $\\partial u/\\partial n$ 表示 $u$ 的法向导数，而 $g$ 是在 $\\partial \\Omega$ 上给定的光滑函数。\n\n您将研究在光滑弯曲边界上使用有符号距离函数的鬼点技术以施加诺伊曼边界条件。您的目标是量化鬼点构造的精度，并验证其在曲率和网格各向异性变化下的观测精度阶。此分析纯粹是数学和算法层面的，使用一个人造解。不涉及任何物理单位。\n\n将使用的基本定义：\n- 偏微分方程（PDE）的边界条件为 $\\partial u/\\partial n = g$ on $\\partial \\Omega$。\n- 有符号距离函数为 $\\phi(\\boldsymbol{x}) = \\|\\boldsymbol{x}\\| - R$；其梯度 $\\nabla \\phi(\\boldsymbol{x})$ 是在 $\\partial \\Omega$ 上的向外单位法向量 $\\boldsymbol{n}$，并且对于 $\\boldsymbol{x} \\neq \\boldsymbol{0}$ 等于 $\\boldsymbol{x}/\\|\\boldsymbol{x}\\|$。\n- 对于一个靠近边界的内部网格节点 $\\boldsymbol{x}_i$，其鬼点是通过沿有符号距离函数确定的法线方向跨 $\\partial \\Omega$ 反射构造的。\n\n人造解数据：\n- 设标量场为 $u(\\boldsymbol{x}) = \\sin(\\pi x) + \\cos(2 \\pi y) + \\sinh(z)$，其中 $\\boldsymbol{x} = (x,y,z)$。\n- 那么 $\\nabla u(\\boldsymbol{x}) = \\left(\\pi \\cos(\\pi x), -2 \\pi \\sin(2 \\pi y), \\cosh(z)\\right)$。\n- 对于 $\\boldsymbol{x}_B \\in \\partial \\Omega$，诺伊曼边界数据为 $g(\\boldsymbol{x}_B) = \\nabla u(\\boldsymbol{x}_B) \\cdot \\boldsymbol{n}(\\boldsymbol{x}_B)$。\n\n待实现的鬼点构造：\n- 对于一个网格节点 $\\boldsymbol{x}_i$，若其满足 $\\phi(\\boldsymbol{x}_i) < 0$ 且 $-\\phi(\\boldsymbol{x}_i) \\le h_{\\max}$，定义 $d = -\\phi(\\boldsymbol{x}_i) > 0$ 且 $\\boldsymbol{n}_i = \\boldsymbol{x}_i / \\|\\boldsymbol{x}_i\\|$。\n- 沿法线方向最近的边界点是 $\\boldsymbol{x}_B = \\boldsymbol{x}_i + d \\boldsymbol{n}_i$。\n- 反射后的鬼点位置是 $\\boldsymbol{x}_G = \\boldsymbol{x}_i + 2 d \\boldsymbol{n}_i$。\n- 通过沿法线的对称泰勒展开定义鬼点值来强制施加诺伊曼边界条件：$u_G^{\\text{num}} = u(\\boldsymbol{x}_i) + 2 d \\, g(\\boldsymbol{x}_B)$。\n- 用于误差评估的精确鬼点值为 $u_G^{\\text{exact}} = u(\\boldsymbol{x}_G)$。\n\n误差度量与观测精度阶：\n- 在满足 $-\\phi(\\boldsymbol{x}_i) \\le h_{\\max}$ 的内部节点集上（即邻近边界的一个单元厚度的内部带），定义均方根误差\n$$\nE = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N \\left(u_G^{\\text{num}}(\\boldsymbol{x}_i) - u_G^{\\text{exact}}(\\boldsymbol{x}_i) \\right)^2},\n$$\n其中 $N$ 是该集合中的节点数。\n- 对每个测试案例执行两种网格分辨率，其中细网格的最大网格间距是粗网格的一半。观测精度阶为\n$$\np = \\frac{\\log\\left(E_{\\text{coarse}}/E_{\\text{fine}}\\right)}{\\log(2)}.\n$$\n\n网格生成：\n- 使用允许各向异性间距的笛卡尔网格。对于给定的 $x$、$y$、$z$ 方向上的节点数 $N_x$、$N_y$、$N_z$，通过在 $[-1,1]$ 上使用均匀线性间隔来定义网格，即 $x_j = -1 + j \\, h_x$，$h_x = 2/(N_x-1)$，对 $y$ 和 $z$ 也类似。\n- 定义 $h_{\\max} = \\max\\{h_x, h_y, h_z\\}$。\n\n测试套件：\n- 案例 1：$R = 0.70$，粗网格 $(N_x,N_y,N_z) = (25,25,25)$，细网格 $(N_x,N_y,N_z) = (49,49,49)$。\n- 案例 2：$R = 0.35$，粗网格 $(N_x,N_y,N_z) = (25,25,25)$，细网格 $(N_x,N_y,N_z) = (49,49,49)$。\n- 案例 3：$R = 0.70$，粗网格 $(N_x,N_y,N_z) = (25,49,97)$，细网格 $(N_x,N_y,N_z) = (49,97,193)$。\n- 案例 4：$R = 0.35$，粗网格 $(N_x,N_y,N_z) = (25,49,97)$，细网格 $(N_x,N_y,N_z) = (49,97,193)$。\n\n您的程序应计算上述四个案例中每个案例的观测阶 $p$，并生成单行输出，其中包含四个 $p$ 值，形式为用方括号括起来的逗号分隔列表，例如 `[p_1,p_2,p_3,p_4]`。所有量都是无量纲的。角度（如果出现在三角函数中）以弧度为单位。最终答案是实数。",
            "solution": "问题陈述已经过验证，并被确定为一个适定的、科学上合理的数值分析练习。它概述了一个清晰的程序，用于验证一种特定鬼点方法的精度阶，该方法用于在嵌入笛卡尔网格中的弯曲边界上强制施加诺伊曼边界条件。所有定义、参数和人造解数据都是自洽和一致的。该问题没有逻辑缺陷、歧义或矛盾。原点处法向量未定义的潜在奇点，由于问题的参数选择而自然地被避免了，因为原点不落在执行计算的一单元厚度的边界层内。因此，我们可以继续进行求解。\n\n目标是计算观测精度阶 $p$，该精度阶用于一种鬼点构造方法，该方法在球形域上强制施加诺伊曼边界条件 $\\partial u/\\partial n = g$。这涉及使用人造解进行数值实验。该过程针对四个不同的测试案例执行，每个案例由一个球体半径 $R$ 和一组粗、细网格分辨率定义。\n\n该方法的核心是为每个测试案例的粗网格和细网格计算一个均方根（RMS）误差 $E$。然后使用以下公式确定观测精度阶 $p$：\n$$\np = \\frac{\\log\\left(E_{\\text{coarse}}/E_{\\text{fine}}\\right)}{\\log(2)}\n$$\n该公式量化了当网格间距减半时误差如何减小。一个误差为 $E = O(h^k)$ 的方法，预期会产生一个观测阶 $p \\approx k$。\n\n误差计算过程如下：\n首先，在计算域 $[-1, 1]^3$ 上生成一个具有指定节点数 $(N_x, N_y, N_z)$ 的均匀笛卡尔网格。网格间距为 $h_x = 2/(N_x-1)$、$h_y = 2/(N_y-1)$ 和 $h_z = 2/(N_z-1)$，且 $h_{\\max} = \\max\\{h_x, h_y, h_z\\}$。\n\n其次，我们识别出“近边界”内部网格节点集 $\\boldsymbol{x}_i$。这些节点的有符号距离函数 $\\phi(\\boldsymbol{x}_i) = \\|\\boldsymbol{x}_i\\| - R$ 为负（表示节点在球体内部），并且到边界的法向距离 $d = -\\phi(\\boldsymbol{x}_i)$ 不大于 $h_{\\max}$。这定义了邻近边界 $\\partial\\Omega$ 内部一侧的一个单元厚度的节点层。设该集合包含 $N$ 个节点。\n\n第三，对于此集合中的每个节点 $\\boldsymbol{x}_i$，我们构造其对应的鬼点，并计算在该鬼点位置处标量场 $u$ 的两个值：一个数值近似值 $u_G^{\\text{num}}$ 和一个精确值 $u_G^{\\text{exact}}$。\n\n该构造基于沿法线方向跨边界的反射。对于一个节点 $\\boldsymbol{x}_i$：\n1.  到边界的法向距离为 $d = -\\phi(\\boldsymbol{x}_i) = R - \\|\\boldsymbol{x}_i\\|$。\n2.  在 $\\boldsymbol{x}_i$ 处的向外法线方向近似为 $\\boldsymbol{n}_i = \\nabla\\phi(\\boldsymbol{x}_i) = \\boldsymbol{x}_i / \\|\\boldsymbol{x}_i\\|$。\n3.  沿此法线在边界上最近的点是 $\\boldsymbol{x}_B = \\boldsymbol{x}_i + d \\boldsymbol{n}_i = \\boldsymbol{x}_i (R / \\|\\boldsymbol{x}_i\\|)$。\n4.  反射后的鬼点位置是 $\\boldsymbol{x}_G = \\boldsymbol{x}_i + 2d \\boldsymbol{n}_i$。\n\n鬼点处的精确值 $u_G^{\\text{exact}}$ 是通过直接在 $\\boldsymbol{x}_G$ 处评估人造解得到的：\n$$\nu_G^{\\text{exact}} = u(\\boldsymbol{x}_G) = \\sin(\\pi x_G) + \\cos(2 \\pi y_G) + \\sinh(z_G)\n$$\n\n数值 $u_G^{\\text{num}}$ 是通过以内部点 $\\boldsymbol{x}_i$ 为中心的一阶泰勒展开来定义的，该展开在边界点 $\\boldsymbol{x}_B$ 处强制施加诺伊曼条件：\n$$\nu_G^{\\text{num}} = u(\\boldsymbol{x}_i) + 2d \\, g(\\boldsymbol{x}_B)\n$$\n这里，$u(\\boldsymbol{x}_i)$ 是人造解在内部节点处的值。边界数据 $g(\\boldsymbol{x}_B)$ 由人造解确定为 $g(\\boldsymbol{x}_B) = \\nabla u(\\boldsymbol{x}_B) \\cdot \\boldsymbol{n}(\\boldsymbol{x}_B)$，其中 $\\boldsymbol{n}(\\boldsymbol{x}_B) = \\boldsymbol{x}_B/R$ 是边界点处的精确单位法向量。梯度向量由 $\\nabla u(\\boldsymbol{x}) = (\\pi \\cos(\\pi x), -2 \\pi \\sin(2 \\pi y), \\cosh(z))$ 给出。\n\n$u_G^{\\text{num}} - u_G^{\\text{exact}}$ 的局部误差的泰勒级数分析表明，误差由一个与 $d^3$ 成正比的项主导：\n$$\nu_G^{\\text{num}}(\\boldsymbol{x}_i) - u_G^{\\text{exact}}(\\boldsymbol{x}_i) = -\\frac{d^3}{3} \\frac{\\partial^3 u}{\\partial n^3}\\Big|_{\\boldsymbol{x}_B} + O(d^4)\n$$\n由于 $d$ 与网格间距 $h$ 的量级相同，鬼点值的局部误差为 $O(h^3)$。\n\n最后，通过对 $N$ 个近边界节点上的平方差进行平均来计算 RMS 误差 $E$：\n$$\nE = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N \\left(u_G^{\\text{num}}(\\boldsymbol{x}_i) - u_G^{\\text{exact}}(\\boldsymbol{x}_i) \\right)^2}\n$$\n鉴于局部误差分析，RMS 误差 $E$ 预计为 $O(h^3)$，因此观测精度阶 $p$ 预计接近 3。\n\n该实现将利用向量化的 NumPy 操作为四个指定的测试案例分别执行这些计算，以提高效率。对于每个案例，计算 $E_{\\text{coarse}}$ 和 $E_{\\text{fine}}$，并报告得到的 $p$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef u_manufactured(points):\n    \"\"\"\n    Computes the scalar field u for a set of points (vectorized).\n\n    Args:\n        points: A numpy array of shape (N, 3) representing N points in 3D space.\n\n    Returns:\n        A numpy array of shape (N,) with the value of u at each point.\n    \"\"\"\n    x = points[:, 0]\n    y = points[:, 1]\n    z = points[:, 2]\n    return np.sin(np.pi * x) + np.cos(2 * np.pi * y) + np.sinh(z)\n\ndef grad_u_manufactured(points):\n    \"\"\"\n    Computes the gradient of the scalar field u for a set of points (vectorized).\n\n    Args:\n        points: A numpy array of shape (N, 3) representing N points in 3D space.\n\n    Returns:\n        A numpy array of shape (N, 3) with the gradient vector of u at each point.\n    \"\"\"\n    x = points[:, 0]\n    y = points[:, 1]\n    z = points[:, 2]\n    du_dx = np.pi * np.cos(np.pi * x)\n    du_dy = -2 * np.pi * np.sin(2 * np.pi * y)\n    du_dz = np.cosh(z)\n    return np.stack([du_dx, du_dy, du_dz], axis=1)\n\ndef compute_error(R, N_x, N_y, N_z):\n    \"\"\"\n    Computes the RMS error of the ghost point value approximation.\n\n    Args:\n        R (float): Radius of the spherical domain.\n        N_x (int): Number of grid points in the x-direction.\n        N_y (int): Number of grid points in the y-direction.\n        N_z (int): Number of grid points in the z-direction.\n\n    Returns:\n        float: The root-mean-square error E.\n    \"\"\"\n    # 1. Grid Generation\n    h_x = 2.0 / (N_x - 1) if N_x > 1 else 0.0\n    h_y = 2.0 / (N_y - 1) if N_y > 1 else 0.0\n    h_z = 2.0 / (N_z - 1) if N_z > 1 else 0.0\n    h_max = max(h_x, h_y, h_z)\n\n    x_coords = np.linspace(-1.0, 1.0, N_x)\n    y_coords = np.linspace(-1.0, 1.0, N_y)\n    z_coords = np.linspace(-1.0, 1.0, N_z)\n    \n    xx, yy, zz = np.meshgrid(x_coords, y_coords, z_coords, indexing='ij')\n    all_points = np.stack([xx.ravel(), yy.ravel(), zz.ravel()], axis=1)\n\n    # 2. Identify Nodes of Interest\n    phi = np.linalg.norm(all_points, axis=1) - R\n    interior_band_indices = np.where((phi < 0) & (-phi <= h_max))[0]\n    \n    if len(interior_band_indices) == 0:\n        return 0.0\n\n    x_i_set = all_points[interior_band_indices]\n\n    # 3. Ghost Point Construction (Vectorized)\n    d = -phi[interior_band_indices]\n    norm_x_i = np.linalg.norm(x_i_set, axis=1, keepdims=True)\n\n    # Filter out origin if it is in the set to avoid division by zero.\n    # The problem setup ensures this is not the case for the given test cases.\n    non_zero_mask = (norm_x_i > 1e-15).ravel()\n    if not np.all(non_zero_mask):\n        x_i_set = x_i_set[non_zero_mask]\n        d = d[non_zero_mask]\n        norm_x_i = norm_x_i[non_zero_mask]\n\n    n_i = x_i_set / norm_x_i\n    x_B = x_i_set * (R / norm_x_i)\n    x_G = x_i_set + 2 * d[:, np.newaxis] * n_i\n    \n    # 4. Calculate Numerical and Exact Ghost Values\n    # Numerical: u_G_num = u(x_i) + 2*d*g(x_B)\n    u_at_xi = u_manufactured(x_i_set)\n    grad_u_at_xB = grad_u_manufactured(x_B)\n    n_at_xB = x_B / R\n    g_at_xB = np.sum(grad_u_at_xB * n_at_xB, axis=1)\n    u_G_num = u_at_xi + 2 * d * g_at_xB\n    \n    # Exact: u_G_exact = u(x_G)\n    u_G_exact = u_manufactured(x_G)\n\n    # 5. Compute RMS Error\n    squared_errors = (u_G_num - u_G_exact)**2\n    rms_error = np.sqrt(np.mean(squared_errors))\n    \n    return rms_error\n    \ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute observed orders of accuracy.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (R, (Nx_coarse, Ny_coarse, Nz_coarse), (Nx_fine, Ny_fine, Nz_fine))\n        (0.70, (25, 25, 25), (49, 49, 49)),\n        (0.35, (25, 25, 25), (49, 49, 49)),\n        (0.70, (25, 49, 97), (49, 97, 193)),\n        (0.35, (25, 49, 97), (49, 97, 193)),\n    ]\n\n    results = []\n    for R, coarse_grid, fine_grid in test_cases:\n        E_coarse = compute_error(R, *coarse_grid)\n        E_fine = compute_error(R, *fine_grid)\n        \n        if E_fine > 0 and E_coarse > 0:\n            order = np.log(E_coarse / E_fine) / np.log(2.0)\n        else:\n            # This case shouldn't occur for this problem but is good practice\n            order = np.nan\n        \n        results.append(order)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}