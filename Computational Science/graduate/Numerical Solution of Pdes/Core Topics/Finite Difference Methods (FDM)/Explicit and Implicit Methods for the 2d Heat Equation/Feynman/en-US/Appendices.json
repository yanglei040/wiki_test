{
    "hands_on_practices": [
        {
            "introduction": "A critical first step in computational science is verifying that your code is working correctly. This exercise guides you through the process using the Method of Manufactured Solutions (MMS), a powerful technique for code verification. You will implement both the explicit Forward-Time Central-Space (FTCS) and the implicit Crank–Nicolson (CN) methods and test them against a known, smooth analytical solution to confirm that they achieve their predicted theoretical orders of accuracy in both space and time. Successfully completing this practice ensures you have a robust and reliable solver, a crucial foundation for tackling more complex problems. ",
            "id": "3388344",
            "problem": "Consider the two-dimensional heat equation with a manufactured smooth solution on the unit square. Let the spatial domain be $\\Omega = (0,1)\\times(0,1)$ and the time interval be $[0,T]$. The governing partial differential equation is\n$$\nu_t = \\alpha \\left(u_{xx} + u_{yy}\\right) + f(x,y,t)\\quad\\text{in}\\quad \\Omega\\times(0,T],\n$$\nwith Dirichlet boundary conditions\n$$\nu(x,y,t) = g(x,y,t)\\quad\\text{for}\\quad (x,y)\\in\\partial\\Omega,\\ t\\in[0,T],\n$$\nand initial condition\n$$\nu(x,y,0) = u_0(x,y)\\quad\\text{for}\\quad (x,y)\\in\\Omega.\n$$\nTake the thermal diffusivity to be $\\alpha = 1$. Use the method of manufactured solutions as the context-appropriate fundamental base: choose the exact smooth function\n$$\nu(x,y,t) = e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y),\n$$\nand construct the forcing term $f(x,y,t)$, the initial condition $u_0(x,y)$, and the boundary data $g(x,y,t)$ so that the above equation and data are satisfied exactly by $u(x,y,t)$. The discrete spatial operator must use second-order central differences on a uniform Cartesian interior grid with $N_x$ by $N_y$ unknowns, grid spacings $h_x = 1/(N_x+1)$ and $h_y = 1/(N_y+1)$. Dirichlet boundary conditions must be imposed strongly by using the exact boundary values. Time integration must be performed using:\n- the explicit Forward-Time Central-Space (FTCS) method (first-order one-step forward Euler in time with the central-difference Laplacian), and\n- the implicit Crank–Nicolson (CN) method (trapezoidal rule in time with the central-difference Laplacian).\n\nYour program must:\n- Assemble the discrete two-dimensional five-point Laplacian on the interior using second-order central differences.\n- For FTCS, respect the stability condition; in two dimensions with $h_x = h_y = h$, the stability constraint is $\\Delta t \\le h^2/4$ when $\\alpha = 1$.\n- For Crank–Nicolson, solve the linear system at each time step exactly (up to numerical linear algebra accuracy), accounting for the source term and Dirichlet boundary values.\n\nUse the discrete $\\ell^2$-error at final time $T$ computed as the square root of the interior-grid weighted sum of squares with cell area $h_x h_y$:\n$$\nE = \\left(h_x h_y \\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} \\left(u_{ij}^{\\text{num}}(T) - u(x_i,y_j,T)\\right)^2\\right)^{1/2},\n$$\nwhere $x_i = i h_x$ and $y_j = j h_y$. Use this $E$ to estimate observed orders of convergence by comparing errors under mesh or time-step refinement by a factor $r>1$:\n$$\np_{\\text{obs}} = \\frac{\\log\\left(E_{\\text{coarse}}/E_{\\text{fine}}\\right)}{\\log(r)}.\n$$\n\nImplement both methods and compute observed temporal and spatial convergence orders for each method using the following test suite. In each case, integrate to the final time $T = 0.01$. When a target time step $\\Delta t_{\\text{target}}$ is prescribed, use an integer number of steps $n = \\lceil T/\\Delta t_{\\text{target}}\\rceil$ and set the actual time step to $\\Delta t = T/n$.\n\nTest suite:\n- Test $1$ (FTCS temporal order): Use $N_x=N_y=80$, let $h=1/(N_x+1)$, and choose two target time steps $\\Delta t_{\\text{coarse}} = 0.2\\,h^2$ and $\\Delta t_{\\text{fine}} = \\Delta t_{\\text{coarse}}/2$. Compute the observed temporal order $p^{\\text{FTCS}}_t$ using the actual steps employed. Ensure the FTCS stability criterion $\\Delta t \\le h^2/4$ is satisfied.\n- Test $2$ (FTCS spatial order): Use two grids, $(N_x,N_y)=(20,20)$ and $(N_x,N_y)=(40,40)$. For each grid, let $h=1/(N_x+1)$ and choose a target time step $\\Delta t = 0.05\\,h^2$. Compute the observed spatial order $p^{\\text{FTCS}}_h$ using the two errors and the exact refinement ratio $r_h = h_{\\text{coarse}}/h_{\\text{fine}}$.\n- Test $3$ (Crank–Nicolson temporal order): Use $N_x=N_y=80$. Choose $\\Delta t_{\\text{coarse}} = 0.0025$ and $\\Delta t_{\\text{fine}} = \\Delta t_{\\text{coarse}}/2$. Compute the observed temporal order $p^{\\text{CN}}_t$ using the actual steps employed.\n- Test $4$ (Crank–Nicolson spatial order): Use two grids, $(N_x,N_y)=(16,16)$ and $(N_x,N_y)=(32,32)$. For each grid, let $h=1/(N_x+1)$ and choose a target time step $\\Delta t = h^2$. Compute the observed spatial order $p^{\\text{CN}}_h$ using the two errors and $r_h$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$$\n\\left[p^{\\text{FTCS}}_t,\\ p^{\\text{FTCS}}_h,\\ p^{\\text{CN}}_t,\\ p^{\\text{CN}}_h\\right].\n$$\nAll four outputs must be real numbers (floats). No other text should be printed.",
            "solution": "The user-provided problem is a well-defined exercise in the numerical solution of partial differential equations. It requires implementing and verifying two standard finite difference methods for the two-dimensional heat equation. The problem is valid as it is scientifically grounded, self-contained, and objective. We will proceed with a full solution.\n\nThe core of the problem is to solve the two-dimensional heat equation on a unit square domain $\\Omega = (0,1)\\times(0,1)$ over the time interval $[0,T]$:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) + f(x,y,t)\n$$\nThe problem specifies using the method of manufactured solutions, where a known, smooth function is chosen as the exact solution, and the problem data (forcing term, initial and boundary conditions) are derived from it.\n\n**1. Formulation via Manufactured Solution**\n\nThe prescribed exact solution is:\n$$\nu(x,y,t) = e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)\n$$\nThe thermal diffusivity is given as $\\alpha = 1$. We derive the problem components by substituting $u(x,y,t)$ into the governing PDE.\n\nThe partial derivatives of $u$ are:\n- Time derivative: $u_t = \\frac{\\partial}{\\partial t} \\left(e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)\\right) = e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)$.\n- Spatial derivatives:\n  - $u_x = \\pi e^{t}\\,\\cos(\\pi x)\\,\\sin(\\pi y) \\implies u_{xx} = -\\pi^2 e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)$.\n  - $u_y = \\pi e^{t}\\,\\sin(\\pi x)\\,\\cos(\\pi y) \\implies u_{yy} = -\\pi^2 e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)$.\n\nThe forcing term $f(x,y,t)$ is determined by rearranging the PDE: $f = u_t - \\alpha(u_{xx} + u_{yy})$.\n$$\nf(x,y,t) = e^{t}\\sin(\\pi x)\\sin(\\pi y) - (1)\\left(-\\pi^2 e^{t}\\sin(\\pi x)\\sin(\\pi y) - \\pi^2 e^{t}\\sin(\\pi x)\\sin(\\pi y)\\right)\n$$\n$$\nf(x,y,t) = (1 + 2\\pi^2)e^{t}\\sin(\\pi x)\\sin(\\pi y)\n$$\n\nThe initial condition $u_0(x,y)$ at $t=0$ is:\n$$\nu_0(x,y) = u(x,y,0) = e^{0}\\,\\sin(\\pi x)\\,\\sin(\\pi y) = \\sin(\\pi x)\\,\\sin(\\pi y)\n$$\n\nThe Dirichlet boundary condition $g(x,y,t)$ is the value of $u(x,y,t)$ on the boundary $\\partial\\Omega$:\n$$\ng(x,y,t) = u(x,y,t)|_{(x,y) \\in \\partial\\Omega}\n$$\nThe boundary $\\partial\\Omega$ consists of the four line segments where $x=0$, $x=1$, $y=0$, or $y=1$. Since $\\sin(0) = 0$ and $\\sin(\\pi) = 0$, the manufactured solution is zero on the entire boundary for all time:\n$$\ng(x,y,t) = 0\n$$\n\n**2. Discretization**\n\nWe define a uniform Cartesian grid with $N_x \\times N_y$ interior points. The grid spacings are $h_x = 1/(N_x+1)$ and $h_y = 1/(N_y+1)$. The grid points are $(x_i, y_j)$, where $x_i = i h_x$ and $y_j = j h_y$, for $i \\in \\{0, 1, \\dots, N_x+1\\}$ and $j \\in \\{0, 1, \\dots, N_y+1\\}$. The numerical solution at $(x_i, y_j)$ at time $t_n = n\\Delta t$ is denoted by $U_{ij}^n$.\n\nThe spatial derivatives are approximated using second-order central differences. The discrete Laplacian operator, $\\nabla_h^2$, acting on $U$ at an interior grid point $(i,j)$ is:\n$$\n\\nabla_h^2 U_{ij} = \\frac{U_{i+1,j} - 2U_{ij} + U_{i-1,j}}{h_x^2} + \\frac{U_{i,j+1} - 2U_{ij} + U_{i,j-1}}{h_y^2}\n$$\n\n**3. Time Integration Schemes**\n\n**a) Forward-Time Central-Space (FTCS) Method**\nThis method is explicit, using a forward Euler step in time and the central difference operator for space.\n$$\n\\frac{U_{ij}^{n+1} - U_{ij}^n}{\\Delta t} = \\alpha \\nabla_h^2 U_{ij}^n + f(x_i, y_j, t_n)\n$$\nSolving for $U_{ij}^{n+1}$, we get the update rule:\n$$\nU_{ij}^{n+1} = U_{ij}^n + \\alpha \\Delta t \\left( \\frac{U_{i+1,j}^n - 2U_{ij}^n + U_{i-1,j}^n}{h_x^2} + \\frac{U_{i,j+1}^n - 2U_{ij}^n + U_{i,j-1}^n}{h_y^2} \\right) + \\Delta t f_{ij}^n\n$$\nwhere $f_{ij}^n = f(x_i, y_j, t_n)$. This scheme is first-order accurate in time, $\\mathcal{O}(\\Delta t)$, and second-order in space, $\\mathcal{O}(h_x^2, h_y^2)$. It is conditionally stable, requiring $\\alpha \\Delta t (1/h_x^2 + 1/h_y^2) \\le 1/2$. For the test cases where $h_x=h_y=h$ and $\\alpha=1$, this simplifies to the provided condition $\\Delta t \\le h^2/4$.\n\n**b) Crank-Nicolson (CN) Method**\nThis method is implicit, based on the trapezoidal rule for time integration, which averages the spatial operator over the current and next time levels.\n$$\n\\frac{U^{n+1}_{ij} - U^{n}_{ij}}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\nabla^2_h U^{n+1}_{ij} + \\nabla^2_h U^n_{ij} \\right) + \\frac{f_{ij}^{n+1} + f_{ij}^{n}}{2}\n$$\nRearranging terms to isolate the unknowns ($U^{n+1}$) on the left-hand side:\n$$\nU^{n+1}_{ij} - \\frac{\\alpha \\Delta t}{2} \\nabla_h^2 U^{n+1}_{ij} = U^{n}_{ij} + \\frac{\\alpha \\Delta t}{2} \\nabla_h^2 U^n_{ij} + \\frac{\\Delta t}{2}(f_{ij}^{n+1} + f_{ij}^{n})\n$$\nThis equation forms a large, sparse linear system for the vector of unknowns $\\mathbf{U}^{n+1}$ at each time step. Let $\\mathbf{L}_h$ be the matrix representation of the discrete Laplacian $\\nabla_h^2$. The system can be written as:\n$$\n\\left(\\mathbf{I} - \\frac{\\alpha \\Delta t}{2}\\mathbf{L}_h\\right)\\mathbf{U}^{n+1} = \\left(\\mathbf{I} + \\frac{\\alpha \\Delta t}{2}\\mathbf{L}_h\\right)\\mathbf{U}^n + \\frac{\\Delta t}{2}(\\mathbf{F}^{n+1} + \\mathbf{F}^n)\n$$\nwhere $\\mathbf{I}$ is the identity matrix and $\\mathbf{U}^n$ is the flattened vector of interior grid values at time $t_n$. The matrix $\\mathbf{A} = (\\mathbf{I} - \\frac{\\alpha \\Delta t}{2}\\mathbf{L}_h)$ is constant for a fixed $\\Delta t$, so it can be constructed and factorized once before the time-stepping loop for efficiency. The CN method is unconditionally stable and second-order accurate in both time and space, $\\mathcal{O}(\\Delta t^2, h_x^2, h_y^2)$.\n\n**4. Convergence Analysis**\n\nThe numerical error is quantified using the discrete $\\ell^2$-norm at the final time $T$:\n$$\nE = \\left(h_x h_y \\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} \\left(U_{ij}^{\\text{num}}(T) - u(x_i,y_j,T)\\right)^2\\right)^{1/2}\n$$\nThe observed order of convergence, $p_{\\text{obs}}$, is estimated by running simulations with a coarse parameter (step size $h_1$ or $\\Delta t_1$) and a fine parameter (step size $h_2$ or $\\Delta t_2$) yielding errors $E_1$ and $E_2$, respectively. With a refinement ratio $r = h_1/h_2$ or $r = \\Delta t_1/\\Delta t_2$:\n$$\np_{\\text{obs}} = \\frac{\\log(E_1/E_2)}{\\log(r)}\n$$\nThe implementation will carry out the four tests specified in the problem to calculate the temporal and spatial convergence orders for both FTCS and CN methods. For temporal tests, the spatial grid is held fixed and $\\Delta t$ is refined. For spatial tests, both the grid spacing $h$ and the time step $\\Delta t$ (which is coupled to $h$) are refined.\n\n**5. Implementation Strategy**\n\n- **FTCS Solver**: This will be implemented using NumPy array operations for efficiency. The solution domain will be represented by an $(N_y+2) \\times (N_x+2)$ array, where the boundary cells are kept at zero, simplifying the update for interior points.\n- **Crank-Nicolson Solver**: This requires building the sparse matrix $\\mathbf{L}_h$ representing the $2$D Laplacian with lexicographical ordering of the $N_x \\times N_y$ interior grid points. `scipy.sparse` is ideal for constructing this matrix and the system matrix $\\mathbf{A}$. The linear system at each step is solved using `scipy.sparse.linalg.spsolve` or, for greater efficiency, by pre-factorizing $\\mathbf{A}$ with `scipy.sparse.linalg.factorized`. The solution vector is reshaped back into a $2$D grid for analysis if needed.\n- **Main Driver**: A main function will execute the four test cases, calling the appropriate solver with coarse and fine parameters, collecting the errors, and calculating the four required convergence orders. The final output will be formatted as a comma-separated list in brackets.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and print the results.\n    \"\"\"\n    \n    # Global parameters\n    ALPHA = 1.0\n    T_FINAL = 0.01\n\n    def u_exact(x, y, t):\n        \"\"\"Manufactured exact solution.\"\"\"\n        return np.exp(t) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def f_source(x, y, t):\n        \"\"\"Derived source term for the manufactured solution.\"\"\"\n        return (1.0 + 2.0 * np.pi**2 * ALPHA) * np.exp(t) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def solve_ftcs(Nx, Ny, dt_target):\n        \"\"\"\n        Solves the 2D heat equation using the FTCS method.\n        Returns the discrete l2-error and the actual time step used.\n        \"\"\"\n        # Grid setup\n        hx = 1.0 / (Nx + 1)\n        hy = 1.0 / (Ny + 1)\n        x = np.linspace(0, 1, Nx + 2)\n        y = np.linspace(0, 1, Ny + 2)\n        \n        # Time setup\n        n_steps = int(np.ceil(T_FINAL / dt_target))\n        dt = T_FINAL / n_steps\n        \n        # Initial condition (u=0 on boundaries is implicit)\n        u_n = np.zeros((Ny + 2, Nx + 2))\n        for j in range(1, Ny + 1):\n            for i in range(1, Nx + 1):\n                u_n[j, i] = u_exact(x[i], y[j], 0.0)\n\n        # Time stepping loop\n        for n in range(n_steps):\n            t_n = n * dt\n            \n            # Vectorized update of interior points\n            laplacian_u = (u_n[1:-1, 2:] - 2 * u_n[1:-1, 1:-1] + u_n[1:-1, :-2]) / hx**2 \\\n                        + (u_n[2:, 1:-1] - 2 * u_n[1:-1, 1:-1] + u_n[:-2, 1:-1]) / hy**2\n            \n            # Source term evaluated on interior grid\n            xx, yy = np.meshgrid(x[1:-1], y[1:-1])\n            f_n = f_source(xx, yy, t_n)\n            \n            u_n[1:-1, 1:-1] += dt * (ALPHA * laplacian_u + f_n)\n\n        # Compute error at final time T\n        u_final_exact_grid = np.zeros_like(u_n)\n        for j in range(1, Ny + 1):\n            for i in range(1, Nx + 1):\n                u_final_exact_grid[j, i] = u_exact(x[i], y[j], T_FINAL)\n\n        error_grid = u_n[1:-1, 1:-1] - u_final_exact_grid[1:-1, 1:-1]\n        l2_error = np.sqrt(hx * hy * np.sum(error_grid**2))\n        \n        return l2_error, dt\n\n    def solve_cn(Nx, Ny, dt_target):\n        \"\"\"\n        Solves the 2D heat equation using the Crank-Nicolson method.\n        Returns the discrete l2-error and the actual time step used.\n        \"\"\"\n        # Grid setup\n        hx = 1.0 / (Nx + 1)\n        hy = 1.0 / (Ny + 1)\n        \n        x_int = np.linspace(hx, 1.0 - hx, Nx)\n        y_int = np.linspace(hy, 1.0 - hy, Ny)\n        xx, yy = np.meshgrid(x_int, y_int)\n\n        # Time setup\n        n_steps = int(np.ceil(T_FINAL / dt_target))\n        dt = T_FINAL / n_steps\n\n        # Initial condition (vectorized)\n        u_vec_n = u_exact(xx, yy, 0.0).flatten()\n\n        # System matrices\n        N = Nx * Ny\n        \n        main_diag = np.ones(N) * (-2/hx**2 - 2/hy**2)\n        x_diag = np.ones(N - 1) * (1/hx**2)\n        for i in range(1, Ny):\n            x_diag[i * Nx - 1] = 0\n        y_diag = np.ones(N - Nx) * (1/hy**2)\n        \n        L = sparse.diags([main_diag, x_diag, x_diag, y_diag, y_diag], \n                          [0, -1, 1, -Nx, Nx], shape=(N, N), format='csc')\n\n        A = sparse.identity(N) - (dt / 2.0) * ALPHA * L\n        B = sparse.identity(N) + (dt / 2.0) * ALPHA * L\n        \n        # Factorize A for repeated solves\n        solve_A = linalg.factorized(A)\n\n        # Time stepping loop\n        for n in range(n_steps):\n            t_n = n * dt\n            t_np1 = (n + 1) * dt\n            \n            F_n = f_source(xx, yy, t_n).flatten()\n            F_np1 = f_source(xx, yy, t_np1).flatten()\n            F_avg = (F_n + F_np1) / 2.0\n            \n            rhs = B.dot(u_vec_n) + dt * F_avg\n            u_vec_n = solve_A(rhs)\n\n        # Compute error at final time T\n        u_final_exact_vec = u_exact(xx, yy, T_FINAL).flatten()\n        error_vec = u_vec_n - u_final_exact_vec\n        l2_error = np.sqrt(hx * hy * np.sum(error_vec**2))\n        \n        return l2_error, dt\n\n    def get_order(E_coarse, E_fine, r):\n        \"\"\"Computes the observed order of convergence.\"\"\"\n        return np.log(E_coarse / E_fine) / np.log(r)\n\n    results = []\n\n    # Test 1: FTCS temporal order\n    N = 80\n    h = 1.0 / (N + 1)\n    dt_target_coarse_1 = 0.2 * h**2\n    dt_target_fine_1 = dt_target_coarse_1 / 2.0\n    \n    E_coarse, dt_coarse = solve_ftcs(N, N, dt_target_coarse_1)\n    E_fine, dt_fine = solve_ftcs(N, N, dt_target_fine_1)\n    r_t = dt_coarse / dt_fine\n    p_ftcs_t = get_order(E_coarse, E_fine, r_t)\n    results.append(p_ftcs_t)\n\n    # Test 2: FTCS spatial order\n    N_coarse, N_fine = 20, 40\n    h_coarse = 1.0 / (N_coarse + 1)\n    h_fine = 1.0 / (N_fine + 1)\n    dt_target_coarse = 0.05 * h_coarse**2\n    dt_target_fine = 0.05 * h_fine**2\n    \n    E_coarse, _ = solve_ftcs(N_coarse, N_coarse, dt_target_coarse)\n    E_fine, _ = solve_ftcs(N_fine, N_fine, dt_target_fine)\n    r_h = h_coarse / h_fine\n    p_ftcs_h = get_order(E_coarse, E_fine, r_h)\n    results.append(p_ftcs_h)\n    \n    # Test 3: Crank-Nicolson temporal order\n    N = 80\n    dt_target_coarse = 0.0025\n    dt_target_fine = dt_target_coarse / 2.0\n    \n    E_coarse, dt_coarse = solve_cn(N, N, dt_target_coarse)\n    E_fine, dt_fine = solve_cn(N, N, dt_target_fine)\n    r_t = dt_coarse / dt_fine\n    p_cn_t = get_order(E_coarse, E_fine, r_t)\n    results.append(p_cn_t)\n    \n    # Test 4: Crank-Nicolson spatial order\n    N_coarse, N_fine = 16, 32\n    h_coarse = 1.0 / (N_coarse + 1)\n    h_fine = 1.0 / (N_fine + 1)\n    dt_target_coarse = h_coarse**2\n    dt_target_fine = h_fine**2\n    \n    E_coarse, _ = solve_cn(N_coarse, N_coarse, dt_target_coarse)\n    E_fine, _ = solve_cn(N_fine, N_fine, dt_target_fine)\n    r_h = h_coarse / h_fine\n    p_cn_h = get_order(E_coarse, E_fine, r_h)\n    results.append(p_cn_h)\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While uniform, isotropic meshes are ideal for textbook examples, practical simulations often involve complex geometries that necessitate anisotropic grids with high aspect-ratio cells. This hands-on practice explores the severe consequences of mesh anisotropy: for explicit methods, it can lead to an impractically small time step restriction, while for implicit methods, it degrades the conditioning of the linear system, making it harder to solve. You will quantify this degradation for the standard five-point stencil and then investigate how a more sophisticated nine-point stencil can mitigate these issues, providing a valuable lesson in choosing appropriate discretizations for challenging, real-world scenarios. ",
            "id": "3388339",
            "problem": "Consider the two-dimensional heat equation on a rectangle with homogeneous Dirichlet boundary conditions, governed by $$u_t = \\alpha \\, \\nabla^2 u,$$ where $u(x,y,t)$ is the temperature, $t$ is time, $x$ and $y$ are spatial coordinates, and $\\alpha$ is the thermal diffusivity. You will study the impact of mesh anisotropy on the explicit forward Euler stability limit (Courant–Friedrichs–Lewy (CFL) constraint) and on the conditioning of the implicit backward Euler linear system, and then quantify improvements achieved by a mesh-aligned nine-point diffusion discretization compared to the standard five-point stencil.\n\nYour task is to construct discrete Laplacian matrices using two stencils over a uniform but anisotropic Cartesian grid with interior grid sizes $N_x$ and $N_y$. Let the domain be $[0,L_x]\\times[0,L_y]$ with interior grid spacings $$h_x = \\frac{L_x}{N_x+1}, \\qquad h_y = \\frac{L_y}{N_y+1}.$$ Use homogeneous Dirichlet boundary conditions ($u=0$ on the boundary), so the discrete solution is defined on $N_x \\times N_y$ interior points. Define the thermal diffusivity as $$\\alpha = 1 \\text{ m}^2\\text{/s}.$$ For each discretization, form the matrix $L$ that represents the discrete Laplacian operator acting on the vectorized interior grid values.\n\n1. Standard five-point stencil (axis-aligned second-order central differences): for each interior node $(i,j)$, the discrete operator is\n$$\\left(L_5 u\\right)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}.$$\nIn matrix form, this defines a symmetric negative definite matrix $L_5$.\n\n2. Mesh-aligned nine-point stencil (axis and diagonal neighbors), derived by matching the second-derivative consistency via Taylor expansion and choosing a diagonal weight to reduce spectral radius while preserving consistency. Let the diagonal weight be\n$$w_d = \\frac{1}{3\\left(h_x^2 + h_y^2\\right)}.$$\nThen the axis neighbor weights and the central coefficient are determined by consistency:\n$$w_x = \\frac{1 - 2 w_d h_x^2}{h_x^2}, \\qquad w_y = \\frac{1 - 2 w_d h_y^2}{h_y^2}, \\qquad c_0 = -2 w_x - 2 w_y - 4 w_d.$$\nThe resulting nine-point discrete operator is\n$$\\left(L_9 u\\right)_{i,j} = c_0 \\, u_{i,j} + w_x \\left(u_{i+1,j} + u_{i-1,j}\\right) + w_y \\left(u_{i,j+1} + u_{i,j-1}\\right) + w_d \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right).$$\nIn matrix form, this defines a symmetric negative definite matrix $L_9$. For $h_x = h_y = h$, this reduces to the classical fourth-order accurate nine-point Laplacian with coefficients $$c_0 = -\\frac{10}{3 h^2},\\quad w_x = w_y = \\frac{2}{3 h^2},\\quad w_d = \\frac{1}{6 h^2}.$$\n\nLet the explicit forward Euler scheme be $$u^{n+1} = u^n + \\Delta t \\, \\alpha \\, L \\, u^n.$$ For stability, the largest admissible time step satisfies $$\\Delta t_{\\max} = \\frac{2}{\\alpha \\, \\rho\\!\\left(L\\right)},$$ where $\\rho(L)$ is the spectral radius of $L$ (the largest absolute eigenvalue of $L$), and $L$ is negative definite. For the implicit backward Euler scheme $$\\left(I - \\Delta t \\, \\alpha \\, L\\right) u^{n+1} = u^n,$$ the linear system matrix is symmetric positive definite with eigenvalues $$\\lambda\\!\\left(I - \\Delta t \\, \\alpha \\, L\\right) = 1 + \\Delta t \\, \\alpha \\, \\left|\\lambda\\!\\left(L\\right)\\right|.$$ Its two-norm condition number is $$\\kappa_2\\!\\left(I - \\Delta t \\, \\alpha \\, L\\right) = \\frac{1 + \\Delta t \\, \\alpha \\, \\lambda_{\\max}^{\\text{abs}}(L)}{1 + \\Delta t \\, \\alpha \\, \\lambda_{\\min}^{\\text{abs}}(L)},$$ where $\\lambda_{\\max}^{\\text{abs}}(L)$ and $\\lambda_{\\min}^{\\text{abs}}(L)$ are the largest and smallest absolute eigenvalues of $L$.\n\nCompute the following quantitative metrics that capture degradation due to mesh anisotropy and improvements due to the nine-point stencil:\n\n- Explicit CFL degradation for the five-point stencil: $$E_{\\text{deg},5}(r) = \\frac{\\Delta t_{\\max,5}(r)}{\\Delta t_{\\max,5}(1)},$$ where $r$ is the mesh aspect ratio defined by $$r = \\frac{h_x}{h_y} = \\frac{L_x(N_y+1)}{L_y(N_x+1)}.$$ The baseline isotropic case has $r=1$.\n- Implicit conditioning degradation for the five-point stencil at a fixed reference time step: choose $$\\Delta t_{\\text{ref}} = 0.9 \\, \\Delta t_{\\max,5}(1).$$ Then\n$$K_{\\text{deg},5}(r) = \\frac{\\kappa_2\\!\\left(I - \\Delta t_{\\text{ref}} \\, \\alpha \\, L_5(r)\\right)}{\\kappa_2\\!\\left(I - \\Delta t_{\\text{ref}} \\, \\alpha \\, L_5(1)\\right)}.$$\n- Explicit CFL improvement factor of nine-point over five-point for the same anisotropic mesh:\n$$E_{\\text{imp}}(r) = \\frac{\\Delta t_{\\max,9}(r)}{\\Delta t_{\\max,5}(r)}.$$\n- Implicit conditioning improvement factor of nine-point over five-point for the same anisotropic mesh at the same $\\Delta t_{\\text{ref}}$:\n$$K_{\\text{imp}}(r) = \\frac{\\kappa_2\\!\\left(I - \\Delta t_{\\text{ref}} \\, \\alpha \\, L_9(r)\\right)}{\\kappa_2\\!\\left(I - \\Delta t_{\\text{ref}} \\, \\alpha \\, L_5(r)\\right)}.$$\n\nTest Suite. Use the following parameter sets, all with $N_x = N_y = 12$, $L_x = 1 \\text{ m}$, and $\\alpha = 1 \\text{ m}^2\\text{/s}$:\n- Case A (baseline isotropic): $L_y = 1 \\text{ m}$ so $r=1$.\n- Case B (moderate anisotropy): $L_y = \\frac{1}{5} \\text{ m}$ so $r=5$.\n- Case C (strong anisotropy): $L_y = \\frac{1}{25} \\text{ m}$ so $r=25$.\n- Case D (extreme anisotropy): $L_y = \\frac{1}{50} \\text{ m}$ so $r=50$.\n\nFor each case, compute the quadruple $$\\left[E_{\\text{deg},5}(r),\\, K_{\\text{deg},5}(r),\\, E_{\\text{imp}}(r),\\, K_{\\text{imp}}(r)\\right],$$ which are dimensionless real numbers. Your program should produce a single line of output containing the four case results as a comma-separated list enclosed in square brackets, where each case result is itself a list in the same order. For example, the format must be $$\\left[\\left[e_1,k_1,i_1,j_1\\right],\\left[e_2,k_2,i_2,j_2\\right],\\left[e_3,k_3,i_3,j_3\\right],\\left[e_4,k_4,i_4,j_4\\right]\\right],$$ with each $e_i, k_i, i_i, j_i$ represented as decimal floating-point numbers. No units should be printed since all metrics are dimensionless.",
            "solution": "The user wants to analyze the properties of two different finite difference discretizations of the two-dimensional Laplacian operator, $\\nabla^2$, on an anisotropic Cartesian grid. The analysis focuses on the stability of the explicit forward Euler time integration scheme and the conditioning of the linear system arising from the implicit backward Euler scheme for the 2D heat equation, $u_t = \\alpha \\nabla^2 u$.\n\n### Problem Validation\nThe problem statement has been meticulously validated.\n**Givens Extracted**:\n- PDE: $u_t = \\alpha \\, \\nabla^2 u$ with $\\alpha = 1 \\text{ m}^2\\text{/s}$.\n- Domain: $[0,L_x]\\times[0,L_y]$ with homogeneous Dirichlet boundary conditions.\n- Discretization: $N_x \\times N_y$ interior grid points, with $h_x = \\frac{L_x}{N_x+1}$ and $h_y = \\frac{L_y}{N_y+1}$.\n- Stencils: Standard five-point and a specific mesh-aligned nine-point stencil for the Laplacian operator, yielding matrices $L_5$ and $L_9$.\n- Time-stepping: Explicit Forward Euler and Implicit Backward Euler schemes.\n- Metrics: Definitions for $E_{\\text{deg},5}(r)$, $K_{\\text{deg},5}(r)$, $E_{\\text{imp}}(r)$, $K_{\\text{imp}}(r)$ based on eigenvalues of $L_5$ and $L_9$ and a reference time step $\\Delta t_{\\text{ref}} = 0.9 \\, \\Delta t_{\\max,5}(1)$.\n- Test Parameters: Constants $N_x=12, N_y=12, L_x=1$. Four cases for $L_y$: $1, 1/5, 1/25, 1/50$, corresponding to mesh aspect ratios $r = h_x/h_y$ of $1, 5, 25, 50$.\n\n**Validation Verdict**:\nThe problem is **valid**. It is scientifically grounded in the numerical analysis of partial differential equations, well-posed with a unique computational solution, and expressed in objective, formal language. All constants, formulas, and procedures are clearly defined and consistent. The problem is a standard, albeit detailed, exercise in the field.\n\n### Solution Approach\n\nThe core of the problem requires computing the minimum and maximum absolute eigenvalues of the discrete Laplacian matrices $L_5$ and $L_9$. For a rectangular domain with Dirichlet boundary conditions, the eigenvectors of these discrete operators are known to be discrete sine functions. This allows for the derivation of analytical expressions for the eigenvalues, obviating the need for numerical eigensolvers and yielding exact results.\n\n**1. Eigenvalues of the 5-point Laplacian ($L_5$)**\nThe discrete operator is:\n$(\\left(L_5 u\\right)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}.$\nIts eigenvalues $\\lambda_{p,q}(L_5)$ for $p=1, \\dots, N_x$ and $q=1, \\dots, N_y$ are given by:\n$$ \\lambda_{p,q}(L_5) = \\frac{2}{h_x^2} \\left( \\cos\\left(\\frac{p \\pi}{N_x+1}\\right) - 1 \\right) + \\frac{2}{h_y^2} \\left( \\cos\\left(\\frac{q \\pi}{N_y+1}\\right) - 1 \\right) $$\nUsing the identity $1 - \\cos(\\theta) = 2 \\sin^2(\\theta/2)$, and noting that all eigenvalues are negative, their absolute values are:\n$$ |\\lambda_{p,q}(L_5)| = \\frac{4}{h_x^2} \\sin^2\\left(\\frac{p \\pi}{2(N_x+1)}\\right) + \\frac{4}{h_y^2} \\sin^2\\left(\\frac{q \\pi}{2(N_y+1)}\\right) $$\nThe minimum and maximum absolute eigenvalues are found by taking $(p,q)=(1,1)$ and $(p,q)=(N_x, N_y)$, respectively.\n\n**2. Eigenvalues of the 9-point Laplacian ($L_9$)**\nThe 9-point operator is defined by coefficients $w_d, w_x, w_y, c_0$. Since the eigenvectors are the same as for $L_5$, we can find the eigenvalues $\\lambda_{p,q}(L_9)$ by applying the operator to a generic eigenvector. This leads to the following expression:\n$$ \\lambda_{p,q}(L_9) = c_0 + 2w_x \\cos\\left(\\frac{p\\pi}{N_x+1}\\right) + 2w_y \\cos\\left(\\frac{q\\pi}{N_y+1}\\right) + 4w_d \\cos\\left(\\frac{p\\pi}{N_x+1}\\right) \\cos\\left(\\frac{q\\pi}{N_y+1}\\right) $$\nSubstituting the definitions for $w_x, w_y,$ and $c_0$ and simplifying algebraically yields a more insightful form:\n$$ \\lambda_{p,q}(L_9) = \\lambda_{p,q}(L_5) + 16 w_d \\sin^2\\left(\\frac{p\\pi}{2(N_x+1)}\\right) \\sin^2\\left(\\frac{q\\pi}{2(N_y+1)}\\right) $$\nSince $w_d = 1/(3(h_x^2+h_y^2)) > 0$ and the sine terms are non-negative, the second term is positive or zero. This confirms that all eigenvalues of $L_9$ are negative (as shown in the thought process) and that $|\\lambda_{p,q}(L_9)| < |\\lambda_{p,q}(L_5)|$ for $p,q > 0$. The minimum and maximum absolute eigenvalues of $L_9$ are found by computing $|\\lambda_{p,q}(L_9)|$ for all pairs $(p,q)$ and finding the minimum and maximum of the resulting values.\n\n**3. Computation of Metrics**\nWith the ability to calculate the spectral bounds $\\lambda_{\\min}^{\\text{abs}}(L)$ and $\\lambda_{\\max}^{\\text{abs}}(L)$ for both stencils, we can compute the required metrics.\n\nFirst, the baseline isotropic case ($r=1$) is computed to establish $\\Delta t_{\\max,5}(1)$ and the reference condition number $\\kappa_2(I - \\Delta t_{\\text{ref}} \\alpha L_5(1))$. The reference time step is $\\Delta t_{\\text{ref}} = 0.9 \\, \\Delta t_{\\max,5}(1)$.\n\nThen, for each test case (including the baseline), we compute:\n- $\\Delta t_{\\max,5}(r) = \\frac{2}{\\alpha \\lambda_{\\max}^{\\text{abs}}(L_5(r))}$\n- $\\Delta t_{\\max,9}(r) = \\frac{2}{\\alpha \\lambda_{\\max}^{\\text{abs}}(L_9(r))}$\n- $\\kappa_{2,5}(r) = \\frac{1 + \\Delta t_{\\text{ref}} \\alpha \\lambda_{\\max}^{\\text{abs}}(L_5(r))}{1 + \\Delta t_{\\text{ref}} \\alpha \\lambda_{\\min}^{\\text{abs}}(L_5(r))}$\n- $\\kappa_{2,9}(r) = \\frac{1 + \\Delta t_{\\text{ref}} \\alpha \\lambda_{\\max}^{\\text{abs}}(L_9(r))}{1 + \\Delta t_{\\text{ref}} \\alpha \\lambda_{\\min}^{\\text{abs}}(L_9(r))}$\n\nFinally, these values are used to compute the four dimensionless ratios $E_{\\text{deg},5}(r)$, $K_{\\text{deg},5}(r)$, $E_{\\text{imp}}(r)$, and $K_{\\text{imp}}(r)$ as defined in the problem statement.\n\nThe implementation will follow this analytical approach for precision and efficiency. A Python script will perform these calculations for the four specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef get_eigenvalues_L5(Nx, Ny, hx, hy):\n    \"\"\"\n    Computes the min and max absolute eigenvalues of the 5-point discrete Laplacian\n    using the analytical formula.\n    \"\"\"\n    p = np.arange(1, Nx + 1)\n    q = np.arange(1, Ny + 1)\n    \n    # Eigenvalues of 1D Laplacians in x and y directions\n    lambda_p_abs = (4 / hx**2) * np.sin(p * np.pi / (2 * (Nx + 1)))**2\n    lambda_q_abs = (4 / hy**2) * np.sin(q * np.pi / (2 * (Ny + 1)))**2\n    \n    # 2D eigenvalues are sums of 1D eigenvalues.\n    # The smallest is sum of smallest, largest is sum of largest.\n    lambda_min_abs = lambda_p_abs[0] + lambda_q_abs[0]\n    lambda_max_abs = lambda_p_abs[-1] + lambda_q_abs[-1]\n    \n    return lambda_min_abs, lambda_max_abs\n\ndef get_eigenvalues_L9(Nx, Ny, hx, hy):\n    \"\"\"\n    Computes the min and max absolute eigenvalues of the 9-point discrete Laplacian\n    by correcting the 5-point eigenvalues.\n    \"\"\"\n    p = np.arange(1, Nx + 1)\n    q = np.arange(1, Ny + 1)\n    \n    # Pre-calculate sine-squared terms\n    sp_sq = np.sin(p * np.pi / (2 * (Nx + 1)))**2\n    sq_sq = np.sin(q * np.pi / (2 * (Ny + 1)))**2\n    \n    # Matrix of absolute eigenvalues for the 5-point stencil\n    lambda5_abs_mat = np.add.outer((4 / hx**2) * sp_sq, (4 / hy**2) * sq_sq)\n    \n    # Diagonal weight for the 9-point stencil\n    wd = 1 / (3 * (hx**2 + hy**2))\n    \n    # Correction term to get 9-point eigenvalues from 5-point\n    correction_mat = 16 * wd * np.outer(sp_sq, sq_sq)\n    \n    # Matrix of absolute eigenvalues for the 9-point stencil\n    # As derived, lambda9 = lambda5 + correction, and lambda5 is negative.\n    # So |lambda9| = |lambda5| - correction.\n    lambda9_abs_mat = lambda5_abs_mat - correction_mat\n    \n    lambda_min_abs = np.min(lambda9_abs_mat)\n    lambda_max_abs = np.max(lambda9_abs_mat)\n    \n    return lambda_min_abs, lambda_max_abs\n    \ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculation of metrics for all test cases.\n    \"\"\"\n    # Global parameters\n    Nx = 12\n    Ny = 12\n    Lx = 1.0\n    alpha = 1.0\n    \n    # Test cases defined by Ly values\n    test_cases = [\n        1.0,        # Case A: r=1\n        1.0 / 5.0,  # Case B: r=5\n        1.0 / 25.0, # Case C: r=25\n        1.0 / 50.0  # Case D: r=50\n    ]\n\n    # --- Baseline Calculation (r=1) ---\n    Ly_base = test_cases[0]\n    hx_base = Lx / (Nx + 1)\n    hy_base = Ly_base / (Ny + 1)\n\n    lambda_min_5_base, lambda_max_5_base = get_eigenvalues_L5(Nx, Ny, hx_base, hy_base)\n    \n    dt_max_5_base = 2.0 / (alpha * lambda_max_5_base)\n    dt_ref = 0.9 * dt_max_5_base\n    \n    kappa_5_base = (1 + dt_ref * alpha * lambda_max_5_base) / (1 + dt_ref * alpha * lambda_min_5_base)\n\n    results = []\n    \n    # --- Loop over all cases ---\n    for Ly in test_cases:\n        hx = Lx / (Nx + 1)\n        hy = Ly / (Ny + 1)\n        \n        # --- 5-point stencil calculations ---\n        lambda_min_5, lambda_max_5 = get_eigenvalues_L5(Nx, Ny, hx, hy)\n        \n        dt_max_5 = 2.0 / (alpha * lambda_max_5)\n        E_deg_5 = dt_max_5 / dt_max_5_base\n        \n        kappa_5 = (1 + dt_ref * alpha * lambda_max_5) / (1 + dt_ref * alpha * lambda_min_5)\n        K_deg_5 = kappa_5 / kappa_5_base\n        \n        # --- 9-point stencil calculations ---\n        lambda_min_9, lambda_max_9 = get_eigenvalues_L9(Nx, Ny, hx, hy)\n        \n        dt_max_9 = 2.0 / (alpha * lambda_max_9)\n        E_imp = dt_max_9 / dt_max_5\n        \n        kappa_9 = (1 + dt_ref * alpha * lambda_max_9) / (1 + dt_ref * alpha * lambda_min_9)\n        K_imp = kappa_9 / kappa_5\n        \n        # Store the quadruple of metrics for the current case\n        results.append([E_deg_5, K_deg_5, E_imp, K_imp])\n\n    # Format output as a single-line string representation of a list of lists.\n    # The problem's output template suggests this formatting strategy.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Implicit methods like Crank-Nicolson are unconditionally stable, which might suggest that decreasing the time step $\\Delta t$ will always improve accuracy. This exercise challenges that assumption by exploring the practical limits of numerical precision. You will implement a model to simulate the effect of floating-point roundoff error and discover a regime where making $\\Delta t$ smaller actually degrades the solution's accuracy, as truncation error becomes subdominant to the accumulation of roundoff noise. This practice provides a critical lesson on the trade-off between theoretical accuracy and the finite-precision nature of computation, a fundamental concept for any advanced numerical practitioner. ",
            "id": "3388335",
            "problem": "Consider the two-dimensional heat equation on the unit square with homogeneous Dirichlet boundary conditions. Let the temperature field be $u(x,y,t)$ satisfying\n$$\nu_t = \\alpha \\left(u_{xx} + u_{yy}\\right), \\quad (x,y) \\in (0,1)\\times(0,1), \\quad t \\ge 0,\n$$\nwith boundary conditions $u(0,y,t) = u(1,y,t) = u(x,0,t) = u(x,1,t) = 0$, and initial condition $u(x,y,0) = \\sin(\\pi x)\\,\\sin(\\pi y)$. The analytic solution is known to be\n$$\nu(x,y,t) = e^{-2\\pi^2 \\alpha t} \\sin(\\pi x)\\,\\sin(\\pi y).\n$$\nStarting from the partial differential equation definition and the standard second-order central difference approximation for the spatial Laplacian, discretize space using an interior grid of $M \\times M$ points with uniform spacing $h = \\frac{1}{M+1}$, and derive the method-of-lines semi-discrete system for the interior values $\\mathbf{u}(t) \\in \\mathbb{R}^{M^2}$. Then, discretize time by applying the trapezoidal rule to this semi-discrete system to obtain the Crank–Nicolson (CN) scheme. Do not use any pre-derived time-stepping formulas; the time discretization must be derived from first principles (the trapezoidal rule applied to a linear ordinary differential equation system).\n\nTo quantify roundoff effects in the extremely small time-step regime, model floating-point roundoff error at each CN time step by injecting an additive elementwise perturbation of order $\\mathcal{O}(\\epsilon_{\\text{mach}})$ into the right-hand side of the CN linear system, where $\\epsilon_{\\text{mach}}$ denotes machine precision of double-precision arithmetic. Concretely, for each time step $n$, let the right-hand side vector be $\\mathbf{r}^n$; then define the perturbation as $\\boldsymbol{\\eta}^n = \\epsilon_{\\text{mach}}\\cdot (1+\\lvert \\mathbf{r}^n\\rvert)\\odot \\boldsymbol{\\xi}^n$, where $\\boldsymbol{\\xi}^n$ has independent standard normal components, $\\odot$ denotes elementwise multiplication, and $\\lvert \\cdot \\rvert$ is taken elementwise. Use a fixed random seed equal to $42$ to ensure reproducibility. This perturbation is added only in the roundoff-error–augmented run; the baseline run omits it.\n\nImplement the CN method with the above roundoff model for the following test suite of parameter values:\n- Case $\\mathsf{A}$: $\\alpha = 1$, $M = 12$, final time $T = 10^{-3}$, and time step $\\Delta t = 10^{-4}$.\n- Case $\\mathsf{B}$: $\\alpha = 1$, $M = 12$, final time $T = 10^{-3}$, and time step $\\Delta t = 10^{-5}$.\n- Case $\\mathsf{C}$: $\\alpha = 1$, $M = 12$, final time $T = 10^{-3}$, and time step $\\Delta t = 10^{-6}$.\n\nFor each case, compute the numerical solution at time $T$ using:\n1. The baseline CN method (no injected perturbations),\n2. The CN method with the roundoff perturbation model injected at every time step.\n\nFor each run, measure the discrete $L^2$ error at time $T$ against the analytic solution $u(x,y,T)$ on the interior grid, using the quadrature-weighted discrete $L^2$ norm\n$$\n\\left\\| \\mathbf{e} \\right\\|_{L^2_h} = \\sqrt{h^2 \\sum_{i=1}^{M} \\sum_{j=1}^{M} e_{ij}^2},\n$$\nwhere $e_{ij}$ are the pointwise errors and $h = \\frac{1}{M+1}$ as above.\n\nAdditionally, quantify stability via energy monotonicity for Case $\\mathsf{C}$ by tracking the discrete $L^2$ norm of the numerical solution during the time integration. Report the energy ratio\n$$\nR = \\frac{\\max_{0 \\le n \\le N} \\left\\| \\mathbf{u}^n \\right\\|_{L^2_h}}{\\left\\| \\mathbf{u}^0 \\right\\|_{L^2_h}},\n$$\nwhere $N = \\left\\lfloor \\frac{T}{\\Delta t} \\right\\rfloor$ is the number of time steps, for both the baseline run and the roundoff-augmented run.\n\nFinally, estimate the observed order of accuracy in time by computing, for both the baseline and roundoff-augmented runs, the slopes between the error pairs $(\\Delta t_A,\\Delta t_B)$ and $(\\Delta t_B,\\Delta t_C)$:\n$$\ns_{A\\to B} = \\frac{\\log\\left(E_A/E_B\\right)}{\\log\\left(\\Delta t_A/\\Delta t_B\\right)}, \\quad s_{B\\to C} = \\frac{\\log\\left(E_B/E_C\\right)}{\\log\\left(\\Delta t_B/\\Delta t_C\\right)},\n$$\nwhere $E_A$, $E_B$, and $E_C$ are the discrete $L^2$ errors at time $T$ for Cases $\\mathsf{A}$, $\\mathsf{B}$, and $\\mathsf{C}$ respectively.\n\nYour program must produce a single line of output with the following comma-separated floats enclosed in square brackets:\n$$\n\\big[ E_A^{\\text{base}}, E_A^{\\text{noise}}, E_B^{\\text{base}}, E_B^{\\text{noise}}, E_C^{\\text{base}}, E_C^{\\text{noise}}, s_{A\\to B}^{\\text{base}}, s_{B\\to C}^{\\text{base}}, s_{A\\to B}^{\\text{noise}}, s_{B\\to C}^{\\text{noise}}, R^{\\text{base}}, R^{\\text{noise}} \\big].\n$$\nNo physical units are required; all reported quantities are dimensionless real numbers. The line must contain only this list in the specified format.",
            "solution": "The user-provided problem is assessed to be **valid**. It is scientifically grounded in the numerical analysis of partial differential equations, well-posed with all necessary conditions provided, and articulated using objective, formal language. The problem is self-contained, internally consistent, and requires a non-trivial application of standard numerical methods. We may therefore proceed with a full solution.\n\nThe solution is developed in three stages: first, we derive the semi-discrete system of ordinary differential equations (ODEs) using the method of lines; second, we derive the fully discrete Crank-Nicolson scheme by applying the trapezoidal rule to this ODE system; and third, we detail the implementation of the numerical simulation, including the specified roundoff error model.\n\n### 1. Semi-Discretization using the Method of Lines\nThe governing partial differential equation (PDE) is the two-dimensional heat equation:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right), \\quad \\text{for } (x,y) \\in (0,1)\\times(0,1), \\ t \\ge 0.\n$$\nSpace is discretized on a uniform grid with $M$ interior points in each direction. The grid points are $(x_i, y_j) = (ih, jh)$ for $i,j \\in \\{0, 1, \\dots, M+1\\}$, where the spatial step size is $h = \\frac{1}{M+1}$. The numerical solution at the interior grid points $(x_i, y_j)$ for $i,j \\in \\{1, \\dots, M\\}$ is denoted by $u_{ij}(t) \\approx u(x_i, y_j, t)$.\n\nThe spatial second derivatives (the Laplacian operator $\\Delta = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$) are approximated using a second-order central difference stencil:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i,y_j)} \\approx \\frac{u(x_{i+1}, y_j, t) - 2u(x_i, y_j, t) + u(x_{i-1}, y_j, t)}{h^2} \\approx \\frac{u_{i+1,j}(t) - 2u_{ij}(t) + u_{i-1,j}(t)}{h^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i,y_j)} \\approx \\frac{u(x_i, y_{j+1}, t) - 2u(x_i, y_j, t) + u(x_i, y_{j-1}, t)}{h^2} \\approx \\frac{u_{i,j+1}(t) - 2u_{ij}(t) + u_{i,j-1}(t)}{h^2}\n$$\nSubstituting these approximations into the heat equation yields a system of $M^2$ coupled ordinary differential equations, one for each interior grid point:\n$$\n\\frac{d u_{ij}}{dt} = \\frac{\\alpha}{h^2} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{ij} \\right).\n$$\nThe homogeneous Dirichlet boundary conditions, $u(0,y,t) = u(1,y,t) = u(x,0,t) = u(x,1,t) = 0$, imply that $u_{0,j} = u_{M+1,j} = u_{i,0} = u_{i,M+1} = 0$ for all $i,j \\in \\{1, \\dots, M\\}$ and $t \\ge 0$.\n\nTo write this system in matrix form, we flatten the $M \\times M$ grid of unknowns into a single vector $\\mathbf{u}(t) \\in \\mathbb{R}^{M^2}$. We adopt a lexicographical (row-major) ordering, where the unknown $u_{ij}$ corresponds to the element at index $k = (i-1)M + (j-1)$ (using $0$-based indexing for a vector of length $M^2$). The system of ODEs can then be expressed as:\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{A} \\mathbf{u}(t)\n$$\nThe matrix $\\mathbf{A} \\in \\mathbb{R}^{M^2 \\times M^2}$ represents the discrete Laplacian operator scaled by the thermal diffusivity $\\alpha$. It is given by $\\mathbf{A} = \\alpha \\mathbf{L}_{2D}$, where $\\mathbf{L}_{2D}$ is the matrix for the discrete Laplacian. This matrix can be constructed using the Kronecker product ($\\otimes$) of one-dimensional Laplacian matrices. Let $\\mathbf{I}_M$ be the $M \\times M$ identity matrix, and let $\\mathbf{L}_{1D}$ be the $M \\times M$ matrix for the one-dimensional discrete Laplacian with step size $h$:\n$$\n\\mathbf{L}_{1D} = \\frac{1}{h^2} \\begin{pmatrix} -2 & 1 & & \\\\ 1 & -2 & 1 & \\\\ & \\ddots & \\ddots & \\ddots \\\\ & & 1 & -2 & 1 \\\\ & & & 1 & -2 \\end{pmatrix}\n$$\nThe two-dimensional Laplacian matrix $\\mathbf{L}_{2D}$ is then given by:\n$$\n\\mathbf{L}_{2D} = (\\mathbf{L}_{1D} \\otimes \\mathbf{I}_M) + (\\mathbf{I}_M \\otimes \\mathbf{L}_{1D})\n$$\nThis results in the block-tridiagonal matrix $\\mathbf{A} = \\frac{\\alpha}{h^2} \\left( (\\mathbf{T}_M \\otimes \\mathbf{I}_M) + (\\mathbf{I}_M \\otimes \\mathbf{T}_M) \\right)$ where $\\mathbf{T}_M$ is a tridiagonal matrix with $1$ on the sub- and super-diagonals and $-2$ on the main diagonal. Summing these Kronecker products produces the well-known five-point stencil matrix for the 2D Laplacian, which has $-4$ on the main diagonal and $1$s on four off-diagonals.\n\n### 2. Time Discretization via the Trapezoidal Rule (Crank-Nicolson)\nThe problem requires deriving the time-stepping scheme from first principles. We apply the trapezoidal rule to integrate the semi-discrete system $\\mathbf{u}'(t) = \\mathbf{A}\\mathbf{u}(t)$ over one time step, from $t_n$ to $t_{n+1} = t_n + \\Delta t$. First, we integrate the ODE system:\n$$\n\\int_{t_n}^{t_{n+1}} \\frac{d\\mathbf{u}}{dt} dt = \\int_{t_n}^{t_{n+1}} \\mathbf{A}\\mathbf{u}(t) dt \\implies \\mathbf{u}(t_{n+1}) - \\mathbf{u}(t_n) = \\int_{t_n}^{t_{n+1}} \\mathbf{A}\\mathbf{u}(t) dt.\n$$\nThe trapezoidal rule for a generic integral $\\int_a^b f(\\tau)d\\tau$ is $\\frac{b-a}{2}(f(a)+f(b))$. Applying this to the right-hand side integral gives:\n$$\n\\int_{t_n}^{t_{n+1}} \\mathbf{A}\\mathbf{u}(t) dt \\approx \\frac{\\Delta t}{2} \\left( \\mathbf{A}\\mathbf{u}(t_n) + \\mathbf{A}\\mathbf{u}(t_{n+1}) \\right).\n$$\nLetting $\\mathbf{u}^n$ be the numerical approximation to $\\mathbf{u}(t_n)$, we obtain the scheme:\n$$\n\\mathbf{u}^{n+1} - \\mathbf{u}^n = \\frac{\\Delta t}{2} \\left( \\mathbf{A}\\mathbf{u}^n + \\mathbf{A}\\mathbf{u}^{n+1} \\right).\n$$\nThis is the Crank-Nicolson method. To solve for the unknown state $\\mathbf{u}^{n+1}$, we rearrange the terms, grouping those at time level $n+1$ on the left and those at $n$ on the right:\n$$\n\\mathbf{u}^{n+1} - \\frac{\\Delta t}{2} \\mathbf{A}\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\frac{\\Delta t}{2} \\mathbf{A}\\mathbf{u}^n\n$$\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2} \\mathbf{A}\\right) \\mathbf{u}^{n+1} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2} \\mathbf{A}\\right) \\mathbf{u}^n.\n$$\nwhere $\\mathbf{I}$ is the $M^2 \\times M^2$ identity matrix. This is a linear system of equations of the form $\\mathbf{L}\\mathbf{x} = \\mathbf{b}$ to be solved at each time step, where the system matrix is $\\mathbf{L} = \\left(\\mathbf{I} - \\frac{\\Delta t}{2} \\mathbf{A}\\right)$, the unknown is $\\mathbf{x} = \\mathbf{u}^{n+1}$, and the right-hand side vector is $\\mathbf{b} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2} \\mathbf{A}\\right) \\mathbf{u}^n$.\n\n### 3. Implementation and Error Analysis\nThe numerical implementation involves setting up the matrices, initializing the solution from the initial condition, and iterating the Crank-Nicolson step until the final time $T$.\n\n**Initial Condition:** The initial state $\\mathbf{u}^0$ is obtained by evaluating the given function $u(x,y,0) = \\sin(\\pi x)\\sin(\\pi y)$ at the interior grid points $(x_i, y_j)$ for $i,j \\in \\{1,\\dots,M\\}$.\n\n**Roundoff Error Model:** To simulate roundoff error, the right-hand side vector $\\mathbf{r}^n = (\\mathbf{I} + \\frac{\\Delta t}{2} \\mathbf{A}) \\mathbf{u}^n$ is perturbed at each step. The full linear system for the noise-augmented run is:\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2} \\mathbf{A}\\right) \\mathbf{u}^{n+1} = \\mathbf{r}^n + \\boldsymbol{\\eta}^n,\n$$\nwhere the perturbation $\\boldsymbol{\\eta}^n$ is defined as $\\boldsymbol{\\eta}^n = \\epsilon_{\\text{mach}}\\cdot (1+\\lvert \\mathbf{r}^n\\rvert)\\odot \\boldsymbol{\\xi}^n$. Here, $\\epsilon_{\\text{mach}}$ is double-precision machine epsilon, $\\lvert\\cdot\\rvert$ is elementwise absolute value, $\\odot$ is elementwise multiplication, and $\\boldsymbol{\\xi}^n$ is a vector of independent standard normal random variables, generated using a fixed random seed for reproducibility.\n\n**Computed Quantities:**\n- **Discrete $L^2$ Error:** At the final time $T$, the numerical solution $\\mathbf{u}^N$ (as a flattened vector) is compared to the analytic solution evaluated on the grid, $\\mathbf{u}_{\\text{analytic}}(T)$. The error vector is $\\mathbf{e} = \\mathbf{u}^N - \\mathbf{u}_{\\text{analytic}}(T)$. The discrete, quadrature-weighted $L^2$ norm is calculated as $\\|\\mathbf{e}\\|_{L^2_h} = \\sqrt{h^2 \\sum_{k=1}^{M^2} e_k^2} = h \\|\\mathbf{e}\\|_{\\ell_2}$.\n- **Energy Stability Ratio ($R$):** For Case $\\mathsf{C}$, the discrete $L^2$ norm of the solution vector, $\\|\\mathbf{u}^n\\|_{L^2_h}$, is tracked at each time step $n$. The ratio $R$ is the maximum norm observed during the simulation divided by the initial norm: $R = \\frac{\\max_{0 \\le n \\le N} \\|\\mathbf{u}^n\\|_{L^2_h}}{\\|\\mathbf{u}^0\\|_{L^2_h}}$.\n- **Order of Accuracy ($s$):** The temporal order of accuracy is estimated from pairs of runs with different time steps $(\\Delta t_1, \\Delta t_2)$ and corresponding errors $(E_1, E_2)$ using the formula $s = \\log(E_1/E_2) / \\log(\\Delta t_1/\\Delta t_2)$. The Crank-Nicolson method is formally second-order accurate in time, so we expect $s \\approx 2$ when truncation error dominates. As $\\Delta t \\to 0$, the simulated roundoff error in the noise-augmented run may begin to dominate, causing $s$ to deviate from $2$ and potentially become negative.\n\nThe Python implementation will use `numpy` for array operations and `scipy.sparse` to efficiently construct and solve the linear systems involved.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, eye, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef run_simulation(alpha, M, T, dt, add_noise, rng):\n    \"\"\"\n    Solves the 2D heat equation using the Crank-Nicolson method.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        M (int): Number of interior grid points in one dimension.\n        T (float): Final simulation time.\n        dt (float): Time step size.\n        add_noise (bool): If True, injects roundoff error model noise.\n        rng (np.random.Generator): A numpy random number generator instance.\n\n    Returns:\n        tuple: A tuple containing:\n            - L2_error (float): The discrete L2 error at the final time.\n            - stability_ratio (float): The energy stability ratio R.\n    \"\"\"\n    h = 1.0 / (M + 1)\n    # Number of time steps as per problem: N = floor(T/dt)\n    N = int(T / dt)\n    final_time = N * dt\n\n    # Grid setup\n    grid_coords = np.linspace(h, 1.0 - h, M)\n    X, Y = np.meshgrid(grid_coords, grid_coords)\n\n    # Initial Condition\n    u0_mat = np.sin(np.pi * X) * np.sin(np.pi * Y)\n    u_current_vec = u0_mat.flatten()\n    u0_vec = u_current_vec.copy()\n\n    # System Matrices (Method of Lines and Crank-Nicolson)\n    L_1D_m = (1.0 / h**2) * diags([1, -2, 1], [-1, 0, 1], shape=(M, M), format='csc')\n    I_M = eye(M, format='csc')\n    A_mat = alpha * (kron(I_M, L_1D_m) + kron(L_1D_m, I_M))\n\n    L_mat = eye(M**2, format='csc') - (dt / 2.0) * A_mat\n    R_mat = eye(M**2, format='csc') + (dt / 2.0) * A_mat\n\n    # For stability ratio R calculation\n    max_norm_sq = np.sum(u_current_vec**2)\n    \n    # Machine epsilon for noise model\n    if add_noise:\n        eps_mach = np.finfo(float).eps\n\n    # Time stepping loop\n    for _ in range(N):\n        rhs_vec = R_mat @ u_current_vec\n\n        if add_noise:\n            xi_n = rng.standard_normal(size=M**2)\n            eta_n = eps_mach * (1.0 + np.abs(rhs_vec)) * xi_n\n            rhs_vec += eta_n\n\n        u_next_vec = spsolve(L_mat, rhs_vec)\n        u_current_vec = u_next_vec\n\n        # Track max norm for stability ratio\n        current_norm_sq = np.sum(u_current_vec**2)\n        if current_norm_sq > max_norm_sq:\n            max_norm_sq = current_norm_sq\n\n    # Final numeric solution\n    u_final_vec = u_current_vec\n\n    # Analytic solution at T\n    u_analytic_mat = np.exp(-2.0 * np.pi**2 * alpha * final_time) * np.sin(np.pi * X) * np.sin(np.pi * Y)\n    u_analytic_vec = u_analytic_mat.flatten()\n\n    # Error calculation (discrete L2 norm)\n    error_vec = u_final_vec - u_analytic_vec\n    L2_error = h * np.linalg.norm(error_vec)\n\n    # Stability ratio R\n    initial_norm = np.linalg.norm(u0_vec)\n    max_l2_norm = np.sqrt(max_norm_sq)\n    stability_ratio = max_l2_norm / initial_norm if initial_norm > 0 else 1.0\n\n    return L2_error, stability_ratio\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Define test cases\n    cases = {\n        'A': {'alpha': 1.0, 'M': 12, 'T': 1e-3, 'dt': 1e-4},\n        'B': {'alpha': 1.0, 'M': 12, 'T': 1e-3, 'dt': 1e-5},\n        'C': {'alpha': 1.0, 'M': 12, 'T': 1e-3, 'dt': 1e-6},\n    }\n\n    # Use a single RNG instance with the specified seed for all noise runs\n    seed = 42\n    rng = np.random.default_rng(seed)\n\n    # Run simulations and collect results\n    E_A_base, _ = run_simulation(**cases['A'], add_noise=False, rng=rng)\n    # Reset rng to ensure noise is comparable across runs\n    rng = np.random.default_rng(seed)\n    E_A_noise, _ = run_simulation(**cases['A'], add_noise=True, rng=rng)\n\n    E_B_base, _ = run_simulation(**cases['B'], add_noise=False, rng=rng)\n    rng = np.random.default_rng(seed)\n    E_B_noise, _ = run_simulation(**cases['B'], add_noise=True, rng=rng)\n\n    E_C_base, R_base_C = run_simulation(**cases['C'], add_noise=False, rng=rng)\n    rng = np.random.default_rng(seed)\n    E_C_noise, R_noise_C = run_simulation(**cases['C'], add_noise=True, rng=rng)\n\n    # Calculate observed order of accuracy (slopes)\n    dt_A, dt_B, dt_C = cases['A']['dt'], cases['B']['dt'], cases['C']['dt']\n\n    s_AB_base = np.log(E_A_base / E_B_base) / np.log(dt_A / dt_B)\n    s_BC_base = np.log(E_B_base / E_C_base) / np.log(dt_B / dt_C)\n\n    s_AB_noise = np.log(E_A_noise / E_B_noise) / np.log(dt_A / dt_B)\n    s_BC_noise = np.log(E_B_noise / E_C_noise) / np.log(dt_B / dt_C)\n\n    # Assemble final output list\n    results = [\n        E_A_base, E_A_noise,\n        E_B_base, E_B_noise,\n        E_C_base, E_C_noise,\n        s_AB_base, s_BC_base,\n        s_AB_noise, s_BC_noise,\n        R_base_C, R_noise_C\n    ]\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}