{
    "hands_on_practices": [
        {
            "introduction": "理论联系实践是掌握数值方法的关键。本练习将指导您完成一个核心实践：使用“制造解方法”（Method of Manufactured Solutions）来验证代码的正确性。该方法通过预设一个精确解，反向推导出相应的源项和边界条件，从而构建一个“已知答案”的测试问题。您将亲自实现前向时间中心差分（FTCS）和克兰克-尼科尔森（Crank-Nicolson）两种方案，并计算它们在时间和空间上的收敛阶，将其与理论值进行比较，从而深刻理解截断误差和收敛性的概念。",
            "id": "3388344",
            "problem": "考虑单位正方形上的二维热方程，并使用一个光滑的制造解。设空间域为 $\\Omega = (0,1)\\times(0,1)$，时间区间为 $[0,T]$。其控制偏微分方程为\n$$\nu_t = \\alpha \\left(u_{xx} + u_{yy}\\right) + f(x,y,t)\\quad\\text{在}\\quad \\Omega\\times(0,T],\n$$\nDirichlet 边值条件为\n$$\nu(x,y,t) = g(x,y,t)\\quad\\text{对于}\\quad (x,y)\\in\\partial\\Omega,\\ t\\in[0,T],\n$$\n初始条件为\n$$\nu(x,y,0) = u_0(x,y)\\quad\\text{对于}\\quad (x,y)\\in\\Omega.\n$$\n取热扩散系数 $\\alpha = 1$。使用制造解方法作为适合该情境的基本方法：选择一个精确的光滑函数\n$$\nu(x,y,t) = e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n并构造强迫项 $f(x,y,t)$、初始条件 $u_0(x,y)$ 和边界数据 $g(x,y,t)$，使得上述方程和数据能被 $u(x,y,t)$ 精确满足。离散空间算子必须在具有 $N_x \\times N_y$ 个未知数的均匀笛卡尔内部网格上使用二阶中心差分，网格间距为 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$。必须通过使用精确的边界值来强加 Dirichlet 边界条件。时间积分必须使用以下方法进行：\n- 显式时间前向中心空间 (FTCS) 方法（时间上采用一阶单步前向 Euler 法，并结合中心差分拉普拉斯算子），以及\n- 隐式 Crank–Nicolson (CN) 方法（时间上采用梯形法则，并结合中心差分拉普拉斯算子）。\n\n您的程序必须：\n- 使用二阶中心差分在内部网格上组装离散的二维五点拉普拉斯算子。\n- 对于 FTCS 方法，遵守稳定性条件；在二维情况下，当 $h_x = h_y = h$ 且 $\\alpha = 1$ 时，稳定性约束为 $\\Delta t \\le h^2/4$。\n- 对于 Crank–Nicolson 方法，在每个时间步精确求解线性系统（达到数值线性代数的精度），同时考虑源项和 Dirichlet 边界值。\n\n使用最终时刻 $T$ 的离散 $\\ell^2$-误差，该误差计算为内部网格上加权平方和的平方根，权重为单元面积 $h_x h_y$：\n$$\nE = \\left(h_x h_y \\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} \\left(u_{ij}^{\\text{num}}(T) - u(x_i,y_j,T)\\right)^2\\right)^{1/2},\n$$\n其中 $x_i = i h_x$ 且 $y_j = j h_y$。通过比较在网格或时间步长以因子 $r>1$ 加密下的误差，使用此 $E$ 来估计观测到的收敛阶：\n$$\np_{\\text{obs}} = \\frac{\\log\\left(E_{\\text{coarse}}/E_{\\text{fine}}\\right)}{\\log(r)}.\n$$\n\n实现这两种方法，并使用以下测试套件计算每种方法的观测时间和空间收敛阶。在每种情况下，积分到最终时间 $T = 0.01$。当指定目标时间步长 $\\Delta t_{\\text{target}}$ 时，使用整数步数 $n = \\lceil T/\\Delta t_{\\text{target}}\\rceil$ 并将实际时间步长设置为 $\\Delta t = T/n$。\n\n测试套件：\n- 测试 $1$ (FTCS 时间阶)：使用 $N_x=N_y=80$，令 $h=1/(N_x+1)$，并选择两个目标时间步长 $\\Delta t_{\\text{coarse}} = 0.2\\,h^2$ 和 $\\Delta t_{\\text{fine}} = \\Delta t_{\\text{coarse}}/2$。使用实际采用的步长计算观测到的时间阶 $p^{\\text{FTCS}}_t$。确保满足 FTCS 稳定性准则 $\\Delta t \\le h^2/4$。\n- 测试 $2$ (FTCS 空间阶)：使用两个网格，$(N_x,N_y)=(20,20)$ 和 $(N_x,N_y)=(40,40)$。对于每个网格，令 $h=1/(N_x+1)$ 并选择一个目标时间步长 $\\Delta t = 0.05\\,h^2$。使用这两个误差和精确的加密比 $r_h = h_{\\text{coarse}}/h_{\\text{fine}}$ 计算观测到的空间阶 $p^{\\text{FTCS}}_h$。\n- 测试 $3$ (Crank–Nicolson 时间阶)：使用 $N_x=N_y=80$。选择 $\\Delta t_{\\text{coarse}} = 0.0025$ 和 $\\Delta t_{\\text{fine}} = \\Delta t_{\\text{coarse}}/2$。使用实际采用的步长计算观测到的时间阶 $p^{\\text{CN}}_t$。\n- 测试 $4$ (Crank–Nicolson 空间阶)：使用两个网格，$(N_x,N_y)=(16,16)$ 和 $(N_x,N_y)=(32,32)$。对于每个网格，令 $h=1/(N_x+1)$ 并选择一个目标时间步长 $\\Delta t = h^2$。使用这两个误差和 $r_h$ 计算观测到的空间阶 $p^{\\text{CN}}_h$。\n\n您的程序必须生成单行输出，其中包含按以下顺序排列、用逗号分隔并括在方括号中的结果\n$$\n\\left[p^{\\text{FTCS}}_t,\\ p^{\\text{FTCS}}_h,\\ p^{\\text{CN}}_t,\\ p^{\\text{CN}}_h\\right].\n$$\n所有四个输出都必须是实数（浮点数）。不应打印任何其他文本。",
            "solution": "用户提供的问题是一个关于偏微分方程数值解的明确定义的练习。它要求实现并验证两种用于二维热方程的标准有限差分方法。该问题是有效的，因为它具有科学依据、内容自洽且客观。我们将提供一个完整的解法。\n\n问题的核心是在单位正方形域 $\\Omega = (0,1)\\times(0,1)$ 和时间区间 $[0,T]$ 上求解二维热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) + f(x,y,t)\n$$\n该问题指定使用制造解方法，即选择一个已知的光滑函数作为精确解，并从中推导出问题数据（强迫项、初始条件和边界条件）。\n\n**1. 通过制造解构建方程**\n\n指定的精确解为：\n$$\nu(x,y,t) = e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)\n$$\n给定热扩散系数 $\\alpha = 1$。我们将 $u(x,y,t)$ 代入控制偏微分方程来推导问题的各个组成部分。\n\n$u$ 的偏导数如下：\n- 时间导数： $u_t = \\frac{\\partial}{\\partial t} \\left(e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)\\right) = e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)$。\n- 空间导数：\n  - $u_x = \\pi e^{t}\\,\\cos(\\pi x)\\,\\sin(\\pi y) \\implies u_{xx} = -\\pi^2 e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)$。\n  - $u_y = \\pi e^{t}\\,\\sin(\\pi x)\\,\\cos(\\pi y) \\implies u_{yy} = -\\pi^2 e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)$。\n\n强迫项 $f(x,y,t)$ 通过重排偏微分方程得到：$f = u_t - \\alpha(u_{xx} + u_{yy})$。\n$$\nf(x,y,t) = e^{t}\\sin(\\pi x)\\sin(\\pi y) - (1)\\left(-\\pi^2 e^{t}\\sin(\\pi x)\\sin(\\pi y) - \\pi^2 e^{t}\\sin(\\pi x)\\sin(\\pi y)\\right)\n$$\n$$\nf(x,y,t) = (1 + 2\\pi^2)e^{t}\\sin(\\pi x)\\sin(\\pi y)\n$$\n\n$t=0$ 时的初始条件 $u_0(x,y)$ 为：\n$$\nu_0(x,y) = u(x,y,0) = e^{0}\\,\\sin(\\pi x)\\,\\sin(\\pi y) = \\sin(\\pi x)\\,\\sin(\\pi y)\n$$\n\nDirichlet 边界条件 $g(x,y,t)$ 是 $u(x,y,t)$ 在边界 $\\partial\\Omega$ 上的值：\n$$\ng(x,y,t) = u(x,y,t)|_{(x,y) \\in \\partial\\Omega}\n$$\n边界 $\\partial\\Omega$ 由 $x=0$、$x=1$、$y=0$ 或 $y=1$ 这四条线段组成。由于 $\\sin(0) = 0$ 和 $\\sin(\\pi) = 0$，制造解在任何时候在整个边界上都为零：\n$$\ng(x,y,t) = 0\n$$\n\n**2. 离散化**\n\n我们定义一个包含 $N_x \\times N_y$ 个内部点的均匀笛卡尔网格。网格间距为 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$。网格点为 $(x_i, y_j)$，其中 $x_i = i h_x$ 且 $y_j = j h_y$，对于 $i \\in \\{0, 1, \\dots, N_x+1\\}$ 和 $j \\in \\{0, 1, \\dots, N_y+1\\}$。在时间 $t_n = n\\Delta t$ 时，点 $(x_i, y_j)$ 处的数值解记为 $U_{ij}^n$。\n\n空间导数使用二阶中心差分进行近似。作用于内部网格点 $(i,j)$ 上的离散拉普拉斯算子 $\\nabla_h^2$ 为：\n$$\n\\nabla_h^2 U_{ij} = \\frac{U_{i+1,j} - 2U_{ij} + U_{i-1,j}}{h_x^2} + \\frac{U_{i,j+1} - 2U_{ij} + U_{i,j-1}}{h_y^2}\n$$\n\n**3. 时间积分格式**\n\n**a) 时间前向中心空间 (FTCS) 方法**\n此方法是显式的，时间上使用前向 Euler 步，空间上使用中心差分算子。\n$$\n\\frac{U_{ij}^{n+1} - U_{ij}^n}{\\Delta t} = \\alpha \\nabla_h^2 U_{ij}^n + f(x_i, y_j, t_n)\n$$\n求解 $U_{ij}^{n+1}$，我们得到更新规则：\n$$\nU_{ij}^{n+1} = U_{ij}^n + \\alpha \\Delta t \\left( \\frac{U_{i+1,j}^n - 2U_{ij}^n + U_{i-1,j}^n}{h_x^2} + \\frac{U_{i,j+1}^n - 2U_{ij}^n + U_{i,j-1}^n}{h_y^2} \\right) + \\Delta t f_{ij}^n\n$$\n其中 $f_{ij}^n = f(x_i, y_j, t_n)$。该格式在时间上是一阶精度，$\\mathcal{O}(\\Delta t)$，在空间上是二阶精度，$\\mathcal{O}(h_x^2, h_y^2)$。它是条件稳定的，要求 $\\alpha \\Delta t (1/h_x^2 + 1/h_y^2) \\le 1/2$。对于测试用例中 $h_x=h_y=h$ 和 $\\alpha=1$ 的情况，这简化为所给出的条件 $\\Delta t \\le h^2/4$。\n\n**b) Crank-Nicolson (CN) 方法**\n此方法是隐式的，基于时间积分的梯形法则，它对当前和下一个时间层上的空间算子进行平均。\n$$\n\\frac{U^{n+1}_{ij} - U^{n}_{ij}}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\nabla^2_h U^{n+1}_{ij} + \\nabla^2_h U^n_{ij} \\right) + \\frac{f_{ij}^{n+1} + f_{ij}^{n}}{2}\n$$\n重排各项，将未知数 ($U^{n+1}$) 分离到左侧：\n$$\nU^{n+1}_{ij} - \\frac{\\alpha \\Delta t}{2} \\nabla_h^2 U^{n+1}_{ij} = U^{n}_{ij} + \\frac{\\alpha \\Delta t}{2} \\nabla_h^2 U^n_{ij} + \\frac{\\Delta t}{2}(f_{ij}^{n+1} + f_{ij}^{n})\n$$\n在每个时间步，该方程为未知数向量 $\\mathbf{U}^{n+1}$ 构成一个大型稀疏线性系统。设 $\\mathbf{L}_h$ 是离散拉普拉斯算子 $\\nabla_h^2$ 的矩阵表示。该系统可写为：\n$$\n\\left(\\mathbf{I} - \\frac{\\alpha \\Delta t}{2}\\mathbf{L}_h\\right)\\mathbf{U}^{n+1} = \\left(\\mathbf{I} + \\frac{\\alpha \\Delta t}{2}\\mathbf{L}_h\\right)\\mathbf{U}^n + \\frac{\\Delta t}{2}(\\mathbf{F}^{n+1} + \\mathbf{F}^n)\n$$\n其中 $\\mathbf{I}$ 是单位矩阵，$\\mathbf{U}^n$ 是时间 $t_n$ 时内部网格值的扁平化向量。对于固定的 $\\Delta t$，矩阵 $\\mathbf{A} = (\\mathbf{I} - \\frac{\\alpha \\Delta t}{2}\\mathbf{L}_h)$ 是常数，因此可以在时间步进循环开始前构造并分解一次以提高效率。CN 方法是无条件稳定的，并且在时间和空间上都是二阶精度，$\\mathcal{O}(\\Delta t^2, h_x^2, h_y^2)$。\n\n**4. 收敛性分析**\n\n数值误差通过最终时刻 $T$ 的离散 $\\ell^2$-范数来量化：\n$$\nE = \\left(h_x h_y \\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} \\left(U_{ij}^{\\text{num}}(T) - u(x_i,y_j,T)\\right)^2\\right)^{1/2}\n$$\n观测到的收敛阶 $p_{\\text{obs}}$ 通过运行两次模拟来估计，一次使用粗糙参数（步长 $h_1$ 或 $\\Delta t_1$），另一次使用精细参数（步长 $h_2$ 或 $\\Delta t_2$），分别得到误差 $E_1$ 和 $E_2$。对于加密比 $r = h_1/h_2$ 或 $r = \\Delta t_1/\\Delta t_2$：\n$$\np_{\\text{obs}} = \\frac{\\log(E_1/E_2)}{\\log(r)}\n$$\n实现将执行问题中指定的四个测试，以计算 FTCS 和 CN 方法的时间和空间收敛阶。对于时间测试，空间网格保持固定，并对 $\\Delta t$ 进行加密。对于空间测试，网格间距 $h$ 和时间步长 $\\Delta t$（与 $h$ 相关）都将进行加密。\n\n**5. 实现策略**\n\n- FTCS 求解器：将使用 NumPy 数组操作以提高效率。解域将由一个 $(N_y+2) \\times (N_x+2)$ 的数组表示，其中边界单元保持为零，从而简化内部点的更新。\n- Crank-Nicolson 求解器：这需要构建稀疏矩阵 $\\mathbf{L}_h$，它表示按字典序排列的 $N_x \\times N_y$ 内部网格点的二维拉普拉斯算子。`scipy.sparse` 是构建此矩阵和系统矩阵 $\\mathbf{A}$ 的理想工具。每一步的线性系统使用 `scipy.sparse.linalg.spsolve` 求解，或者为了更高效率，通过使用 `scipy.sparse.linalg.factorized` 预分解 $\\mathbf{A}$。如果需要，解向量可以重塑为二维网格以进行分析。\n- 主驱动程序：一个主函数将执行四个测试用例，使用粗糙和精细参数调用相应的求解器，收集误差，并计算所需的四个收敛阶。最终输出将格式化为方括号内的逗号分隔列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and print the results.\n    \"\"\"\n    \n    # Global parameters\n    ALPHA = 1.0\n    T_FINAL = 0.01\n\n    def u_exact(x, y, t):\n        \"\"\"Manufactured exact solution.\"\"\"\n        return np.exp(t) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def f_source(x, y, t):\n        \"\"\"Derived source term for the manufactured solution.\"\"\"\n        return (1.0 + 2.0 * np.pi**2 * ALPHA) * np.exp(t) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def solve_ftcs(Nx, Ny, dt_target):\n        \"\"\"\n        Solves the 2D heat equation using the FTCS method.\n        Returns the discrete l2-error and the actual time step used.\n        \"\"\"\n        # Grid setup\n        hx = 1.0 / (Nx + 1)\n        hy = 1.0 / (Ny + 1)\n        x = np.linspace(0, 1, Nx + 2)\n        y = np.linspace(0, 1, Ny + 2)\n        \n        # Time setup\n        n_steps = int(np.ceil(T_FINAL / dt_target))\n        dt = T_FINAL / n_steps\n        \n        # Initial condition (u=0 on boundaries is implicit)\n        u_n = np.zeros((Ny + 2, Nx + 2))\n        for j in range(1, Ny + 1):\n            for i in range(1, Nx + 1):\n                u_n[j, i] = u_exact(x[i], y[j], 0.0)\n\n        # Time stepping loop\n        for n in range(n_steps):\n            t_n = n * dt\n            \n            # Vectorized update of interior points\n            laplacian_u = (u_n[1:-1, 2:] - 2 * u_n[1:-1, 1:-1] + u_n[1:-1, :-2]) / hx**2 \\\n                        + (u_n[2:, 1:-1] - 2 * u_n[1:-1, 1:-1] + u_n[:-2, 1:-1]) / hy**2\n            \n            # Source term evaluated on interior grid\n            xx, yy = np.meshgrid(x[1:-1], y[1:-1])\n            f_n = f_source(xx, yy, t_n)\n            \n            u_n[1:-1, 1:-1] += dt * (ALPHA * laplacian_u + f_n)\n\n        # Compute error at final time T\n        u_final_exact_grid = np.zeros_like(u_n)\n        for j in range(1, Ny + 1):\n            for i in range(1, Nx + 1):\n                u_final_exact_grid[j, i] = u_exact(x[i], y[j], T_FINAL)\n\n        error_grid = u_n[1:-1, 1:-1] - u_final_exact_grid[1:-1, 1:-1]\n        l2_error = np.sqrt(hx * hy * np.sum(error_grid**2))\n        \n        return l2_error, dt\n\n    def solve_cn(Nx, Ny, dt_target):\n        \"\"\"\n        Solves the 2D heat equation using the Crank-Nicolson method.\n        Returns the discrete l2-error and the actual time step used.\n        \"\"\"\n        # Grid setup\n        hx = 1.0 / (Nx + 1)\n        hy = 1.0 / (Ny + 1)\n        \n        x_int = np.linspace(hx, 1.0 - hx, Nx)\n        y_int = np.linspace(hy, 1.0 - hy, Ny)\n        xx, yy = np.meshgrid(x_int, y_int)\n\n        # Time setup\n        n_steps = int(np.ceil(T_FINAL / dt_target))\n        dt = T_FINAL / n_steps\n\n        # Initial condition (vectorized)\n        u_vec_n = u_exact(xx, yy, 0.0).flatten()\n\n        # System matrices\n        N = Nx * Ny\n        \n        main_diag = np.ones(N) * (-2/hx**2 - 2/hy**2)\n        x_diag = np.ones(N - 1) * (1/hx**2)\n        for i in range(1, Ny):\n            x_diag[i * Nx - 1] = 0\n        y_diag = np.ones(N - Nx) * (1/hy**2)\n        \n        L = sparse.diags([main_diag, x_diag, x_diag, y_diag, y_diag], \n                          [0, -1, 1, -Nx, Nx], shape=(N, N), format='csc')\n\n        A = sparse.identity(N) - (dt / 2.0) * ALPHA * L\n        B = sparse.identity(N) + (dt / 2.0) * ALPHA * L\n        \n        # Factorize A for repeated solves\n        solve_A = linalg.factorized(A)\n\n        # Time stepping loop\n        for n in range(n_steps):\n            t_n = n * dt\n            t_np1 = (n + 1) * dt\n            \n            F_n = f_source(xx, yy, t_n).flatten()\n            F_np1 = f_source(xx, yy, t_np1).flatten()\n            F_avg = (F_n + F_np1) / 2.0\n            \n            rhs = B.dot(u_vec_n) + dt * F_avg\n            u_vec_n = solve_A(rhs)\n\n        # Compute error at final time T\n        u_final_exact_vec = u_exact(xx, yy, T_FINAL).flatten()\n        error_vec = u_vec_n - u_final_exact_vec\n        l2_error = np.sqrt(hx * hy * np.sum(error_vec**2))\n        \n        return l2_error, dt\n\n    def get_order(E_coarse, E_fine, r):\n        \"\"\"Computes the observed order of convergence.\"\"\"\n        return np.log(E_coarse / E_fine) / np.log(r)\n\n    results = []\n\n    # Test 1: FTCS temporal order\n    N = 80\n    h = 1.0 / (N + 1)\n    dt_target_coarse_1 = 0.2 * h**2\n    dt_target_fine_1 = dt_target_coarse_1 / 2.0\n    \n    E_coarse, dt_coarse = solve_ftcs(N, N, dt_target_coarse_1)\n    E_fine, dt_fine = solve_ftcs(N, N, dt_target_fine_1)\n    r_t = dt_coarse / dt_fine\n    p_ftcs_t = get_order(E_coarse, E_fine, r_t)\n    results.append(p_ftcs_t)\n\n    # Test 2: FTCS spatial order\n    N_coarse, N_fine = 20, 40\n    h_coarse = 1.0 / (N_coarse + 1)\n    h_fine = 1.0 / (N_fine + 1)\n    dt_target_coarse = 0.05 * h_coarse**2\n    dt_target_fine = 0.05 * h_fine**2\n    \n    E_coarse, _ = solve_ftcs(N_coarse, N_coarse, dt_target_coarse)\n    E_fine, _ = solve_ftcs(N_fine, N_fine, dt_target_fine)\n    r_h = h_coarse / h_fine\n    p_ftcs_h = get_order(E_coarse, E_fine, r_h)\n    results.append(p_ftcs_h)\n    \n    # Test 3: Crank-Nicolson temporal order\n    N = 80\n    dt_target_coarse = 0.0025\n    dt_target_fine = dt_target_coarse / 2.0\n    \n    E_coarse, dt_coarse = solve_cn(N, N, dt_target_coarse)\n    E_fine, dt_fine = solve_cn(N, N, dt_target_fine)\n    r_t = dt_coarse / dt_fine\n    p_cn_t = get_order(E_coarse, E_fine, r_t)\n    results.append(p_cn_t)\n    \n    # Test 4: Crank-Nicolson spatial order\n    N_coarse, N_fine = 16, 32\n    h_coarse = 1.0 / (N_coarse + 1)\n    h_fine = 1.0 / (N_fine + 1)\n    dt_target_coarse = h_coarse**2\n    dt_target_fine = h_fine**2\n    \n    E_coarse, _ = solve_cn(N_coarse, N_coarse, dt_target_coarse)\n    E_fine, _ = solve_cn(N_fine, N_fine, dt_target_fine)\n    r_h = h_coarse / h_fine\n    p_cn_h = get_order(E_coarse, E_fine, r_h)\n    results.append(p_cn_h)\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "克兰克-尼科尔森（Crank-Nicolson）等隐式方法以其“无条件稳定”的特性而备受青睐，但这是否意味着我们可以毫无顾忌地选择任意小的时间步长 $\\Delta t$ 呢？本练习旨在揭示一个更深层次的数值现象：当 $\\Delta t$ 变得极小时，舍入误差的累积效应可能会超过理论上的截断误差，成为主导误差来源，从而破坏解的精度。通过一个精心设计的数值实验，您将量化这种效应，并观察到在舍入误差主导的区域，减小 $\\Delta t$ 反而可能导致精度下降，这为我们理解和使用无条件稳定格式提供了重要的实践洞察。",
            "id": "3388335",
            "problem": "考虑单位正方形上的二维热传导方程，其具有齐次狄利克雷边界条件。令温度场为 $u(x,y,t)$，满足\n$$\nu_t = \\alpha \\left(u_{xx} + u_{yy}\\right), \\quad (x,y) \\in (0,1)\\times(0,1), \\quad t \\ge 0,\n$$\n边界条件为 $u(0,y,t) = u(1,y,t) = u(x,0,t) = u(x,1,t) = 0$，初始条件为 $u(x,y,0) = \\sin(\\pi x)\\,\\sin(\\pi y)$。已知其解析解为\n$$\nu(x,y,t) = e^{-2\\pi^2 \\alpha t} \\sin(\\pi x)\\,\\sin(\\pi y).\n$$\n从偏微分方程的定义和空间拉普拉斯算子的标准二阶中心差分近似出发，使用一个包含 $M \\times M$ 个内部点的网格对空间进行离散化，网格间距均匀为 $h = \\frac{1}{M+1}$，并推导关于内部值 $\\mathbf{u}(t) \\in \\mathbb{R}^{M^2}$ 的直线法半离散系统。然后，通过对此半离散系统应用梯形法则来对时间进行离散化，以获得 Crank–Nicolson (CN) 格式。不要使用任何预先推导的时间步进公式；时间离散化必须从第一性原理（即，将梯形法则应用于线性常微分方程组）推导得出。\n\n为了在极小时间步长情况下量化舍入效应，通过在 CN 线性系统的右端项中注入一个量级为 $O(\\epsilon_{\\text{mach}})$ 的加性逐元素扰动，来对每个 CN 时间步的浮点舍入误差进行建模，其中 $\\epsilon_{\\text{mach}}$ 表示双精度浮点运算的机器精度。具体来说，对于每个时间步 $n$，令右端向量为 $\\mathbf{r}^n$；然后将扰动定义为 $\\boldsymbol{\\eta}^n = \\epsilon_{\\text{mach}}\\cdot (1+\\lvert \\mathbf{r}^n\\rvert)\\odot \\boldsymbol{\\xi}^n$，其中 $\\boldsymbol{\\xi}^n$ 的分量是独立的标准正态随机变量，$\\odot$ 表示逐元素乘法，$\\lvert \\cdot \\rvert$ 也是逐元素作用的。使用等于 $42$ 的固定随机种子以确保可复现性。此扰动仅在增加了舍入误差的运行中添加；基准运行则省略此扰动。\n\n针对以下参数值测试套件，实现带有上述舍入模型的 CN 方法：\n- 情况 $\\mathsf{A}$：$\\alpha = 1$，$M = 12$，最终时间 $T = 10^{-3}$，时间步长 $\\Delta t = 10^{-4}$。\n- 情况 $\\mathsf{B}$：$\\alpha = 1$，$M = 12$，最终时间 $T = 10^{-3}$，时间步长 $\\Delta t = 10^{-5}$。\n- 情况 $\\mathsf{C}$：$\\alpha = 1$，$M = 12$，最终时间 $T = 10^{-3}$，时间步长 $\\Delta t = 10^{-6}$。\n\n对于每种情况，使用以下方法计算在时间 $T$ 的数值解：\n1. 基准 CN 方法（无注入扰动），\n2. 在每个时间步都注入舍入扰动模型的 CN 方法。\n\n对于每次运行，使用求积加权的离散 $L^2$ 范数来度量在时间 $T$ 时内部网格上的数值解与解析解 $u(x,y,T)$ 之间的离散 $L^2$ 误差\n$$\n\\left\\| \\mathbf{e} \\right\\|_{L^2_h} = \\sqrt{h^2 \\sum_{i=1}^{M} \\sum_{j=1}^{M} e_{ij}^2},\n$$\n其中 $e_{ij}$ 是逐点误差，$h = \\frac{1}{M+1}$ 如上文所述。\n\n此外，对于情况 $\\mathsf{C}$，通过在时间积分过程中追踪数值解的离散 $L^2$ 范数，来通过能量单调性量化其稳定性。报告能量比\n$$\nR = \\frac{\\max_{0 \\le n \\le N} \\left\\| \\mathbf{u}^n \\right\\|_{L^2_h}}{\\left\\| \\mathbf{u}^0 \\right\\|_{L^2_h}},\n$$\n其中 $N = \\left\\lfloor \\frac{T}{\\Delta t} \\right\\rfloor$ 是时间步数，此比率需对基准运行和增加了舍入误差的运行分别报告。\n\n最后，通过计算误差对 $(\\Delta t_A,\\Delta t_B)$ 和 $(\\Delta t_B,\\Delta t_C)$ 之间的斜率来估算观测到的时间精度阶，此计算需对基准运行和增加了舍入误差的运行分别进行：\n$$\ns_{A\\to B} = \\frac{\\log\\left(E_A/E_B\\right)}{\\log\\left(\\Delta t_A/\\Delta t_B\\right)}, \\quad s_{B\\to C} = \\frac{\\log\\left(E_B/E_C\\right)}{\\log\\left(\\Delta t_B/\\Delta t_C\\right)},\n$$\n其中 $E_A$、$E_B$ 和 $E_C$ 分别是情况 $\\mathsf{A}$、$\\mathsf{B}$ 和 $\\mathsf{C}$ 在时间 $T$ 的离散 $L^2$ 误差。\n\n你的程序必须生成单行输出，包含以下用方括号括起来并以逗号分隔的浮点数：\n$$\n\\big[ E_A^{\\text{base}}, E_A^{\\text{noise}}, E_B^{\\text{base}}, E_B^{\\text{noise}}, E_C^{\\text{base}}, E_C^{\\text{noise}}, s_{A\\to B}^{\\text{base}}, s_{B\\to C}^{\\text{base}}, s_{A\\to B}^{\\text{noise}}, s_{B\\to C}^{\\text{noise}}, R^{\\text{base}}, R^{\\text{noise}} \\big].\n$$\n不需要物理单位；所有报告的量均为无量纲实数。该行必须仅包含此指定格式的列表。",
            "solution": "用户提供的问题被评估为 **有效**。它在偏微分方程数值分析领域有坚实的科学基础，是适定的，提供了所有必要条件，并使用客观、正式的语言进行阐述。该问题是自洽的、内部一致的，并要求对标准数值方法进行非平凡的应用。因此，我们可以着手提供完整解答。\n\n解答分为三个阶段展开：首先，我们使用直线法推导常微分方程（ODE）的半离散系统；其次，我们通过对此 ODE 系统应用梯形法则来推导全离散的 Crank-Nicolson 格式；第三，我们详细说明数值模拟的实现，包括指定的舍入误差模型。\n\n### 1. 使用直线法进行半离散化\n控制偏微分方程 (PDE) 是二维热传导方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right), \\quad \\text{for } (x,y) \\in (0,1)\\times(0,1), \\ t \\ge 0.\n$$\n空间在均匀网格上进行离散化，每个方向上有 $M$ 个内部点。网格点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{0, 1, \\dots, M+1\\}$，空间步长为 $h = \\frac{1}{M+1}$。在内部网格点 $(x_i, y_j)$（其中 $i,j \\in \\{1, \\dots, M\\}$）的数值解记为 $u_{ij}(t) \\approx u(x_i, y_j, t)$。\n\n空间二阶导数（拉普拉斯算子 $\\Delta = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$）使用二阶中心差分格式进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i,y_j)} \\approx \\frac{u(x_{i+1}, y_j, t) - 2u(x_i, y_j, t) + u(x_{i-1}, y_j, t)}{h^2} \\approx \\frac{u_{i+1,j}(t) - 2u_{ij}(t) + u_{i-1,j}(t)}{h^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i,y_j)} \\approx \\frac{u(x_i, y_{j+1}, t) - 2u(x_i, y_j, t) + u(x_i, y_{j-1}, t)}{h^2} \\approx \\frac{u_{i,j+1}(t) - 2u_{ij}(t) + u_{i,j-1}(t)}{h^2}\n$$\n将这些近似代入热传导方程，得到一个包含 $M^2$ 个耦合常微分方程的系统，每个方程对应一个内部网格点：\n$$\n\\frac{d u_{ij}}{dt} = \\frac{\\alpha}{h^2} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{ij} \\right).\n$$\n齐次狄利克雷边界条件 $u(0,y,t) = u(1,y,t) = u(x,0,t) = u(x,1,t) = 0$ 意味着 $u_{0,j} = u_{M+1,j} = u_{i,0} = u_{i,M+1} = 0$ 对于所有 $i,j \\in \\{1, \\dots, M\\}$ 和 $t \\ge 0$。\n\n为将此系统写成矩阵形式，我们将 $M \\times M$ 的未知量网格展平为一个向量 $\\mathbf{u}(t) \\in \\mathbb{R}^{M^2}$。我们采用字典序（行主序），其中未知量 $u_{ij}$ 对应于索引为 $k = (i-1)M + (j-1)$ 的元素（对于长度为 $M^2$ 的向量使用从0开始的索引）。ODE 系统进而可以表示为：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{A} \\mathbf{u}(t)\n$$\n矩阵 $\\mathbf{A} \\in \\mathbb{R}^{M^2 \\times M^2}$ 表示按热扩散系数 $\\alpha$ 缩放后的离散拉普拉斯算子。它由 $\\mathbf{A} = \\alpha \\mathbf{L}_{2D}$ 给出，其中 $\\mathbf{L}_{2D}$ 是离散拉普拉斯算子的矩阵。该矩阵可以使用一维拉普拉斯矩阵的克罗内克积（$\\otimes$）来构造。令 $\\mathbf{I}_M$ 为 $M \\times M$ 单位矩阵，令 $\\mathbf{L}_{1D}$ 为步长为 $h$ 的一维离散拉普拉斯算子的 $M \\times M$ 矩阵：\n$$\n\\mathbf{L}_{1D} = \\frac{1}{h^2} \\begin{pmatrix} -2  1   \\\\ 1  -2  1  \\\\  \\ddots  \\ddots  \\ddots \\\\   1  -2  1 \\\\    1  -2 \\end{pmatrix}\n$$\n那么，二维拉普拉斯矩阵 $\\mathbf{L}_{2D}$ 由以下公式给出：\n$$\n\\mathbf{L}_{2D} = (\\mathbf{L}_{1D} \\otimes \\mathbf{I}_M) + (\\mathbf{I}_M \\otimes \\mathbf{L}_{1D})\n$$\n这就得到了块三对角矩阵 $\\mathbf{A} = \\frac{\\alpha}{h^2} \\left( (\\mathbf{T}_M \\otimes \\mathbf{I}_M) + (\\mathbf{I}_M \\otimes \\mathbf{T}_M) \\right)$，其中 $\\mathbf{T}_M$ 是一个三对角矩阵，其主对角线元素为 -2，次对角线和超对角线元素为 1。将这些克罗内克积相加，便得到著名的二维拉普拉斯算子的五点差分格式矩阵，其主对角线元素为 -4，四条偏对角线上的元素为 1。\n\n### 2. 通过梯形法则（Crank-Nicolson）进行时间离散化\n问题要求从第一性原理推导时间步进格式。我们应用梯形法则对半离散系统 $\\mathbf{u}'(t) = \\mathbf{A}\\mathbf{u}(t)$ 在一个时间步长（从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$）上进行积分。首先，我们对 ODE 系统积分：\n$$\n\\int_{t_n}^{t_{n+1}} \\frac{d\\mathbf{u}}{dt} dt = \\int_{t_n}^{t_{n+1}} \\mathbf{A}\\mathbf{u}(t) dt \\implies \\mathbf{u}(t_{n+1}) - \\mathbf{u}(t_n) = \\int_{t_n}^{t_{n+1}} \\mathbf{A}\\mathbf{u}(t) dt.\n$$\n对于一个通用积分 $\\int_a^b f(\\tau)d\\tau$，梯形法则是 $\\frac{b-a}{2}(f(a)+f(b))$。将其应用于右端的积分，可得：\n$$\n\\int_{t_n}^{t_{n+1}} \\mathbf{A}\\mathbf{u}(t) dt \\approx \\frac{\\Delta t}{2} \\left( \\mathbf{A}\\mathbf{u}(t_n) + \\mathbf{A}\\mathbf{u}(t_{n+1}) \\right).\n$$\n令 $\\mathbf{u}^n$ 为 $\\mathbf{u}(t_n)$ 的数值近似，我们得到以下格式：\n$$\n\\mathbf{u}^{n+1} - \\mathbf{u}^n = \\frac{\\Delta t}{2} \\left( \\mathbf{A}\\mathbf{u}^n + \\mathbf{A}\\mathbf{u}^{n+1} \\right).\n$$\n这就是 Crank-Nicolson 方法。为了求解未知状态 $\\mathbf{u}^{n+1}$，我们重新整理各项，将时间层 $n+1$ 的项归到左边，时间层 $n$ 的项归到右边：\n$$\n\\mathbf{u}^{n+1} - \\frac{\\Delta t}{2} \\mathbf{A}\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\frac{\\Delta t}{2} \\mathbf{A}\\mathbf{u}^n\n$$\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2} \\mathbf{A}\\right) \\mathbf{u}^{n+1} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2} \\mathbf{A}\\right) \\mathbf{u}^n.\n$$\n其中 $\\mathbf{I}$ 是 $M^2 \\times M^2$ 的单位矩阵。这是一个形式为 $\\mathbf{L}\\mathbf{x} = \\mathbf{b}$ 的线性方程组，需要在每个时间步求解。其中系统矩阵为 $\\mathbf{L} = \\left(\\mathbf{I} - \\frac{\\Delta t}{2} \\mathbf{A}\\right)$，未知量为 $\\mathbf{x} = \\mathbf{u}^{n+1}$，右端向量为 $\\mathbf{b} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2} \\mathbf{A}\\right) \\mathbf{u}^n$。\n\n### 3. 实现与误差分析\n数值实现包括建立矩阵，根据初始条件初始化解，并迭代 Crank-Nicolson 步直到最终时间 $T$。\n\n**初始条件：** 通过在内部网格点 $(x_i, y_j)$（其中 $i,j \\in \\{1,\\dots,M\\}$）上计算给定函数 $u(x,y,0) = \\sin(\\pi x)\\sin(\\pi y)$ 的值来获得初始状态 $\\mathbf{u}^0$。\n\n**舍入误差模型：** 为模拟舍入误差，在每一步中对右端向量 $\\mathbf{r}^n = (\\mathbf{I} + \\frac{\\Delta t}{2} \\mathbf{A}) \\mathbf{u}^n$ 进行扰动。增加了噪声的运行的完整线性系统为：\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2} \\mathbf{A}\\right) \\mathbf{u}^{n+1} = \\mathbf{r}^n + \\boldsymbol{\\eta}^n,\n$$\n其中扰动 $\\boldsymbol{\\eta}^n$ 定义为 $\\boldsymbol{\\eta}^n = \\epsilon_{\\text{mach}}\\cdot (1+\\lvert \\mathbf{r}^n\\rvert)\\odot \\boldsymbol{\\xi}^n$。这里，$\\epsilon_{\\text{mach}}$ 是双精度机器ε，$\\lvert\\cdot\\rvert$ 是逐元素绝对值，$\\odot$ 是逐元素乘法，$\\boldsymbol{\\xi}^n$ 是一个由独立标准正态随机变量组成的向量，使用固定的随机种子生成以保证可复现性。\n\n**计算量：**\n- **离散 $L^2$ 误差：** 在最终时间 $T$，将数值解 $\\mathbf{u}^N$（作为展平的向量）与在网格上计算的解析解 $\\mathbf{u}_{\\text{analytic}}(T)$ 进行比较。误差向量为 $\\mathbf{e} = \\mathbf{u}^N - \\mathbf{u}_{\\text{analytic}}(T)$。离散的、求积加权的 $L^2$ 范数计算如下：$\\|\\mathbf{e}\\|_{L^2_h} = \\sqrt{h^2 \\sum_{k=1}^{M^2} e_k^2} = h \\|\\mathbf{e}\\|_{\\ell_2}$。\n- **能量稳定比 ($R$)：** 对于情况 $\\mathsf{C}$，在每个时间步 $n$ 追踪解向量的离散 $L^2$ 范数 $\\|\\mathbf{u}^n\\|_{L^2_h}$。比率 $R$ 是模拟过程中观测到的最大范数除以初始范数：$R = \\frac{\\max_{0 \\le n \\le N} \\|\\mathbf{u}^n\\|_{L^2_h}}{\\|\\mathbf{u}^0\\|_{L^2_h}}$。\n- **精度阶 ($s$)：** 时间精度阶是通过具有不同时间步长 $(\\Delta t_1, \\Delta t_2)$ 和相应误差 $(E_1, E_2)$ 的成对运行结果，使用公式 $s = \\log(E_1/E_2) / \\log(\\Delta t_1/\\Delta t_2)$ 来估算的。Crank-Nicolson 方法在时间上是形式二阶精确的，因此当截断误差占主导时，我们期望 $s \\approx 2$。当 $\\Delta t \\to 0$ 时，在增加了噪声的运行中，模拟的舍入误差可能开始占主导地位，导致 $s$ 偏离 2 并可能变为负值。\n\nPython 实现将使用 `numpy`进行数组操作，并使用 `scipy.sparse`来高效地构造和求解所涉及的线性系统。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, eye, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef run_simulation(alpha, M, T, dt, add_noise, rng):\n    \"\"\"\n    Solves the 2D heat equation using the Crank-Nicolson method.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        M (int): Number of interior grid points in one dimension.\n        T (float): Final simulation time.\n        dt (float): Time step size.\n        add_noise (bool): If True, injects roundoff error model noise.\n        rng (np.random.Generator): A numpy random number generator instance.\n\n    Returns:\n        tuple: A tuple containing:\n            - L2_error (float): The discrete L2 error at the final time.\n            - stability_ratio (float): The energy stability ratio R.\n    \"\"\"\n    h = 1.0 / (M + 1)\n    # Number of time steps as per problem: N = floor(T/dt)\n    N = int(T / dt)\n    final_time = N * dt\n\n    # Grid setup\n    grid_coords = np.linspace(h, 1.0 - h, M)\n    X, Y = np.meshgrid(grid_coords, grid_coords)\n\n    # Initial Condition\n    u0_mat = np.sin(np.pi * X) * np.sin(np.pi * Y)\n    u_current_vec = u0_mat.flatten()\n    u0_vec = u_current_vec.copy()\n\n    # System Matrices (Method of Lines and Crank-Nicolson)\n    L_1D_m = (1.0 / h**2) * diags([1, -2, 1], [-1, 0, 1], shape=(M, M), format='csc')\n    I_M = eye(M, format='csc')\n    A_mat = alpha * (kron(I_M, L_1D_m) + kron(L_1D_m, I_M))\n\n    L_mat = eye(M**2, format='csc') - (dt / 2.0) * A_mat\n    R_mat = eye(M**2, format='csc') + (dt / 2.0) * A_mat\n\n    # For stability ratio R calculation\n    max_norm_sq = np.sum(u_current_vec**2)\n    \n    # Machine epsilon for noise model\n    if add_noise:\n        eps_mach = np.finfo(float).eps\n\n    # Time stepping loop\n    for _ in range(N):\n        rhs_vec = R_mat @ u_current_vec\n\n        if add_noise:\n            xi_n = rng.standard_normal(size=M**2)\n            eta_n = eps_mach * (1.0 + np.abs(rhs_vec)) * xi_n\n            rhs_vec += eta_n\n\n        u_next_vec = spsolve(L_mat, rhs_vec)\n        u_current_vec = u_next_vec\n\n        # Track max norm for stability ratio\n        current_norm_sq = np.sum(u_current_vec**2)\n        if current_norm_sq > max_norm_sq:\n            max_norm_sq = current_norm_sq\n\n    # Final numeric solution\n    u_final_vec = u_current_vec\n\n    # Analytic solution at T\n    u_analytic_mat = np.exp(-2.0 * np.pi**2 * alpha * final_time) * np.sin(np.pi * X) * np.sin(np.pi * Y)\n    u_analytic_vec = u_analytic_mat.flatten()\n\n    # Error calculation (discrete L2 norm)\n    error_vec = u_final_vec - u_analytic_vec\n    L2_error = h * np.linalg.norm(error_vec)\n\n    # Stability ratio R\n    initial_norm = np.linalg.norm(u0_vec)\n    max_l2_norm = np.sqrt(max_norm_sq)\n    stability_ratio = max_l2_norm / initial_norm if initial_norm > 0 else 1.0\n\n    return L2_error, stability_ratio\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Define test cases\n    cases = {\n        'A': {'alpha': 1.0, 'M': 12, 'T': 1e-3, 'dt': 1e-4},\n        'B': {'alpha': 1.0, 'M': 12, 'T': 1e-3, 'dt': 1e-5},\n        'C': {'alpha': 1.0, 'M': 12, 'T': 1e-3, 'dt': 1e-6},\n    }\n\n    # Use a single RNG instance with the specified seed for all noise runs\n    seed = 42\n    rng = np.random.default_rng(seed)\n\n    # Run simulations and collect results\n    E_A_base, _ = run_simulation(**cases['A'], add_noise=False, rng=rng)\n    # Reset rng to ensure noise is comparable across runs\n    rng = np.random.default_rng(seed)\n    E_A_noise, _ = run_simulation(**cases['A'], add_noise=True, rng=rng)\n\n    E_B_base, _ = run_simulation(**cases['B'], add_noise=False, rng=rng)\n    rng = np.random.default_rng(seed)\n    E_B_noise, _ = run_simulation(**cases['B'], add_noise=True, rng=rng)\n\n    E_C_base, R_base_C = run_simulation(**cases['C'], add_noise=False, rng=rng)\n    rng = np.random.default_rng(seed)\n    E_C_noise, R_noise_C = run_simulation(**cases['C'], add_noise=True, rng=rng)\n\n    # Calculate observed order of accuracy (slopes)\n    dt_A, dt_B, dt_C = cases['A']['dt'], cases['B']['dt'], cases['C']['dt']\n\n    s_AB_base = np.log(E_A_base / E_B_base) / np.log(dt_A / dt_B)\n    s_BC_base = np.log(E_B_base / E_C_base) / np.log(dt_B / dt_C)\n\n    s_AB_noise = np.log(E_A_noise / E_B_noise) / np.log(dt_A / dt_B)\n    s_BC_noise = np.log(E_B_noise / E_C_noise) / np.log(dt_B / dt_C)\n\n    # Assemble final output list\n    results = [\n        E_A_base, E_A_noise,\n        E_B_base, E_B_noise,\n        E_C_base, E_C_noise,\n        s_AB_base, s_BC_base,\n        s_AB_noise, s_BC_noise,\n        R_base_C, R_noise_C\n    ]\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}