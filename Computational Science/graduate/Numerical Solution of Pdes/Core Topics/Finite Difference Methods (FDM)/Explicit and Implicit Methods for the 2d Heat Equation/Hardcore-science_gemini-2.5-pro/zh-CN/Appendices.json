{
    "hands_on_practices": [
        {
            "introduction": "从理论到实践的转换是数值方法学习中的关键一步。任何数值计算实践者的首要任务都是验证自己编写的程序的正确性。为此，“人造解”方法 (Method of Manufactured Solutions, MMS) 是一个强大而严谨的工具，它让我们能够用一个已知的精确解来测试代码。本练习  将指导您实现显式的FTCS方法和隐式的Crank-Nicolson方法，并验证它们在时间和空间上的理论收敛阶，这是开发可靠数值求解器的核心技能。",
            "id": "3388344",
            "problem": "考虑在单位正方形上使用人造光滑解的二维热方程。设空间域为 $\\Omega = (0,1)\\times(0,1)$，时间区间为 $[0,T]$。控制偏微分方程为\n$$\nu_t = \\alpha \\left(u_{xx} + u_{yy}\\right) + f(x,y,t)\\quad\\text{在}\\quad \\Omega\\times(0,T],\n$$\n狄利克雷(Dirichlet)边界条件为\n$$\nu(x,y,t) = g(x,y,t)\\quad\\text{对于}\\quad (x,y)\\in\\partial\\Omega,\\ t\\in[0,T],\n$$\n以及初始条件为\n$$\nu(x,y,0) = u_0(x,y)\\quad\\text{对于}\\quad (x,y)\\in\\Omega.\n$$\n取热扩散系数为 $\\alpha = 1$。使用人造解方法作为符合上下文的基本依据：选择精确的光滑函数\n$$\nu(x,y,t) = e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n并构造强迫项 $f(x,y,t)$、初始条件 $u_0(x,y)$ 和边界数据 $g(x,y,t)$，以使上述方程和数据可被 $u(x,y,t)$ 精确满足。离散空间算子必须在具有 $N_x \\times N_y$ 个未知数的均匀笛卡尔内部网格上使用二阶中心差分，网格间距为 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$。必须通过使用精确边界值来强加狄利克雷(Dirichlet)边界条件。时间积分必须使用以下方法进行：\n- 显式前向时间中心空间 (FTCS) 方法（时间上为一阶单步前向欧拉法，配合中心差分拉普拉斯算子），以及\n- 隐式 Crank–Nicolson (CN) 方法（时间上为梯形法则，配合中心差分拉普拉斯算子）。\n\n您的程序必须：\n- 在内部网格上使用二阶中心差分来组装离散的二维五点拉普拉斯算子。\n- 对于 FTCS，需遵守稳定性条件；在二维情况下，当 $h_x = h_y = h$ 且 $\\alpha = 1$ 时，稳定性约束为 $\\Delta t \\le h^2/4$。\n- 对于 Crank–Nicolson 方法，在每个时间步精确求解线性系统（达到数值线性代数精度），并考虑源项和狄利克雷边界值。\n\n使用在最终时间 $T$ 的离散 $\\ell^2$ 误差，该误差通过对内部网格上加权（权重为单元面积 $h_x h_y$）平方和求平方根计算得出：\n$$\nE = \\left(h_x h_y \\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} \\left(u_{ij}^{\\text{num}}(T) - u(x_i,y_j,T)\\right)^2\\right)^{1/2},\n$$\n其中 $x_i = i h_x$ 且 $y_j = j h_y$。使用此 $E$ 来估计观测收敛阶，方法是通过比较网格或时间步长以因子 $r>1$ 加密前后的误差：\n$$\np_{\\text{obs}} = \\frac{\\log\\left(E_{\\text{coarse}}/E_{\\text{fine}}\\right)}{\\log(r)}.\n$$\n\n实现这两种方法，并使用以下测试套件计算每种方法的观测时间和空间收敛阶。在每种情况下，积分至最终时间 $T = 0.01$。当指定目标时间步长 $\\Delta t_{\\text{target}}$ 时，使用整数步数 $n = \\lceil T/\\Delta t_{\\text{target}}\\rceil$ 并将实际时间步长设置为 $\\Delta t = T/n$。\n\n测试套件：\n- 测试 1 (FTCS 时间阶): 使用 $N_x=N_y=80$，令 $h=1/(N_x+1)$，并选择两个目标时间步长 $\\Delta t_{\\text{coarse}} = 0.2\\,h^2$ 和 $\\Delta t_{\\text{fine}} = \\Delta t_{\\text{coarse}}/2$。使用实际采用的步长计算观测到的时间阶 $p^{\\text{FTCS}}_t$。确保满足 FTCS 稳定性准则 $\\Delta t \\le h^2/4$。\n- 测试 2 (FTCS 空间阶): 使用两个网格，$(N_x,N_y)=(20,20)$ 和 $(N_x,N_y)=(40,40)$。对于每个网格，令 $h=1/(N_x+1)$ 并选择一个目标时间步长 $\\Delta t = 0.05\\,h^2$。使用两个误差和精确的加密比 $r_h = h_{\\text{coarse}}/h_{\\text{fine}}$ 计算观测到的空间阶 $p^{\\text{FTCS}}_h$。\n- 测试 3 (Crank–Nicolson 时间阶): 使用 $N_x=N_y=80$。选择 $\\Delta t_{\\text{coarse}} = 0.0025$ 和 $\\Delta t_{\\text{fine}} = \\Delta t_{\\text{coarse}}/2$。使用实际采用的步长计算观测到的时间阶 $p^{\\text{CN}}_t$。\n- 测试 4 (Crank–Nicolson 空间阶): 使用两个网格，$(N_x,N_y)=(16,16)$ 和 $(N_x,N_y)=(32,32)$。对于每个网格，令 $h=1/(N_x+1)$ 并选择一个目标时间步长 $\\Delta t = h^2$。使用两个误差和 $r_h$ 计算观测到的空间阶 $p^{\\text{CN}}_h$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n\\left[p^{\\text{FTCS}}_t,\\ p^{\\text{FTCS}}_h,\\ p^{\\text{CN}}_t,\\ p^{\\text{CN}}_h\\right].\n$$\n所有四个输出都必须是实数（浮点数）。不应打印任何其他文本。",
            "solution": "用户提供的问题是偏微分方程数值解领域一个定义明确的练习。它要求实现并验证两种用于二维热方程的标准有限差分方法。该问题是有效的，因为它具有科学依据、自成体系且客观。我们将提供一个完整的解法。\n\n核心问题是在单位正方形域 $\\Omega = (0,1)\\times(0,1)$ 上、时间区间 $[0,T]$ 内求解二维热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) + f(x,y,t)\n$$\n问题指定使用人造解方法，即选择一个已知的、光滑的函数作为精确解，并由此推导出问题数据（强迫项、初始条件和边界条件）。\n\n**1. 通过人造解进行公式化**\n\n指定的精确解为：\n$$\nu(x,y,t) = e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)\n$$\n热扩散系数给定为 $\\alpha = 1$。我们通过将 $u(x,y,t)$ 代入控制偏微分方程来推导问题的各个组成部分。\n\n$u$ 的偏导数是：\n- 时间导数： $u_t = \\frac{\\partial}{\\partial t} \\left(e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)\\right) = e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)$。\n- 空间导数：\n  - $u_x = \\pi e^{t}\\,\\cos(\\pi x)\\,\\sin(\\pi y) \\implies u_{xx} = -\\pi^2 e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)$。\n  - $u_y = \\pi e^{t}\\,\\sin(\\pi x)\\,\\cos(\\pi y) \\implies u_{yy} = -\\pi^2 e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)$。\n\n强迫项 $f(x,y,t)$ 通过重新整理偏微分方程得到：$f = u_t - \\alpha(u_{xx} + u_{yy})$。\n$$\nf(x,y,t) = e^{t}\\sin(\\pi x)\\sin(\\pi y) - (1)\\left(-\\pi^2 e^{t}\\sin(\\pi x)\\sin(\\pi y) - \\pi^2 e^{t}\\sin(\\pi x)\\sin(\\pi y)\\right)\n$$\n$$\nf(x,y,t) = (1 + 2\\pi^2)e^{t}\\sin(\\pi x)\\sin(\\pi y)\n$$\n\n$t=0$ 时的初始条件 $u_0(x,y)$ 是：\n$$\nu_0(x,y) = u(x,y,0) = e^{0}\\,\\sin(\\pi x)\\,\\sin(\\pi y) = \\sin(\\pi x)\\,\\sin(\\pi y)\n$$\n\n狄利克雷边界条件 $g(x,y,t)$ 是 $u(x,y,t)$ 在边界 $\\partial\\Omega$ 上的值：\n$$\ng(x,y,t) = u(x,y,t)|_{(x,y) \\in \\partial\\Omega}\n$$\n边界 $\\partial\\Omega$ 由 $x=0$, $x=1$, $y=0$ 或 $y=1$ 这四条线段组成。由于 $\\sin(0) = 0$ 和 $\\sin(\\pi) = 0$，人造解在所有时间在整个边界上都为零：\n$$\ng(x,y,t) = 0\n$$\n\n**2. 离散化**\n\n我们定义一个具有 $N_x \\times N_y$ 个内部点的均匀笛卡尔网格。网格间距为 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$。网格点为 $(x_i, y_j)$，其中 $x_i = i h_x$ 且 $y_j = j h_y$，对于 $i \\in \\{0, 1, \\dots, N_x+1\\}$ 和 $j \\in \\{0, 1, \\dots, N_y+1\\}$。在时间 $t_n = n\\Delta t$ 时，点 $(x_i, y_j)$ 的数值解记为 $U_{ij}^n$。\n\n空间导数使用二阶中心差分进行近似。作用于内部网格点 $(i,j)$ 上的离散拉普拉斯算子 $\\nabla_h^2$ 为：\n$$\n\\nabla_h^2 U_{ij} = \\frac{U_{i+1,j} - 2U_{ij} + U_{i-1,j}}{h_x^2} + \\frac{U_{i,j+1} - 2U_{ij} + U_{i,j-1}}{h_y^2}\n$$\n\n**3. 时间积分方案**\n\n**a) 前向时间中心空间 (FTCS) 方法**\n该方法是显式的，时间上使用前向欧拉步，空间上使用中心差分算子。\n$$\n\\frac{U_{ij}^{n+1} - U_{ij}^n}{\\Delta t} = \\alpha \\nabla_h^2 U_{ij}^n + f(x_i, y_j, t_n)\n$$\n求解 $U_{ij}^{n+1}$，我们得到更新规则：\n$$\nU_{ij}^{n+1} = U_{ij}^n + \\alpha \\Delta t \\left( \\frac{U_{i+1,j}^n - 2U_{ij}^n + U_{i-1,j}^n}{h_x^2} + \\frac{U_{i,j+1}^n - 2U_{ij}^n + U_{i,j-1}^n}{h_y^2} \\right) + \\Delta t f_{ij}^n\n$$\n其中 $f_{ij}^n = f(x_i, y_j, t_n)$。该格式在时间上是一阶精度，$\\mathcal{O}(\\Delta t)$，在空间上是二阶精度，$\\mathcal{O}(h_x^2, h_y^2)$。它是条件稳定的，要求 $\\alpha \\Delta t (1/h_x^2 + 1/h_y^2) \\le 1/2$。对于测试用例中 $h_x=h_y=h$ 和 $\\alpha=1$ 的情况，这简化为所给的条件 $\\Delta t \\le h^2/4$。\n\n**b) Crank-Nicolson (CN) 方法**\n该方法是隐式的，基于梯形法则进行时间积分，该法则对当前和下一个时间层的空间算子进行平均。\n$$\n\\frac{U^{n+1}_{ij} - U^{n}_{ij}}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\nabla^2_h U^{n+1}_{ij} + \\nabla^2_h U^n_{ij} \\right) + \\frac{f_{ij}^{n+1} + f_{ij}^{n}}{2}\n$$\n重新整理各项，将未知数 ($U^{n+1}$) 放在左侧：\n$$\nU^{n+1}_{ij} - \\frac{\\alpha \\Delta t}{2} \\nabla_h^2 U^{n+1}_{ij} = U^{n}_{ij} + \\frac{\\alpha \\Delta t}{2} \\nabla_h^2 U^n_{ij} + \\frac{\\Delta t}{2}(f_{ij}^{n+1} + f_{ij}^{n})\n$$\n在每个时间步，此方程为未知数向量 $\\mathbf{U}^{n+1}$ 构成一个大型稀疏线性系统。设 $\\mathbf{L}_h$ 是离散拉普拉斯算子 $\\nabla_h^2$ 的矩阵表示。该系统可写为：\n$$\n\\left(\\mathbf{I} - \\frac{\\alpha \\Delta t}{2}\\mathbf{L}_h\\right)\\mathbf{U}^{n+1} = \\left(\\mathbf{I} + \\frac{\\alpha \\Delta t}{2}\\mathbf{L}_h\\right)\\mathbf{U}^n + \\frac{\\Delta t}{2}(\\mathbf{F}^{n+1} + \\mathbf{F}^n)\n$$\n其中 $\\mathbf{I}$ 是单位矩阵，$\\mathbf{U}^n$ 是在时间 $t_n$ 的内部网格值的扁平化向量。对于固定的 $\\Delta t$，矩阵 $\\mathbf{A} = (\\mathbf{I} - \\frac{\\alpha \\Delta t}{2}\\mathbf{L}_h)$ 是常数，因此可以在时间步进循环之前构造和分解一次以提高效率。CN 方法是无条件稳定的，并且在时间和空间上都是二阶精度，$\\mathcal{O}(\\Delta t^2, h_x^2, h_y^2)$。\n\n**4. 收敛性分析**\n\n数值误差使用在最终时间 $T$ 的离散 $\\ell^2$ 范数来量化：\n$$\nE = \\left(h_x h_y \\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} \\left(U_{ij}^{\\text{num}}(T) - u(x_i,y_j,T)\\right)^2\\right)^{1/2}\n$$\n观测收敛阶 $p_{\\text{obs}}$ 是通过分别使用粗参数（步长 $h_1$ 或 $\\Delta t_1$）和细参数（步长 $h_2$ 或 $\\Delta t_2$）运行模拟得到误差 $E_1$ 和 $E_2$ 来估计的。加密比为 $r = h_1/h_2$ 或 $r = \\Delta t_1/\\Delta t_2$：\n$$\np_{\\text{obs}} = \\frac{\\log(E_1/E_2)}{\\log(r)}\n$$\n实现将执行问题中指定的四个测试，以计算 FTCS 和 CN 方法的时间和空间收敛阶。对于时间测试，空间网格保持固定，并对 $\\Delta t$ 进行加密。对于空间测试，网格间距 $h$ 和时间步长 $\\Delta t$（与 $h$ 耦合）都将被加密。\n\n**5. 实现策略**\n\n- **FTCS 求解器**：将使用 NumPy 数组操作实现以提高效率。求解域将由一个 $(N_y+2) \\times (N_x+2)$ 数组表示，其中边界单元保持为零，从而简化内部点的更新。\n- **Crank-Nicolson 求解器**：这需要构建表示二维拉普拉斯算子的稀疏矩阵 $\\mathbf{L}_h$，其中 $N_x \\times N_y$ 个内部网格点按字典序排列。`scipy.sparse` 是构建此矩阵和系统矩阵 $\\mathbf{A}$ 的理想选择。每个步骤中的线性系统可以使用 `scipy.sparse.linalg.spsolve` 求解，或者为了更高效率，通过使用 `scipy.sparse.linalg.factorized` 对 $\\mathbf{A}$ 进行预分解。如果需要，解向量可以被重塑回二维网格以进行分析。\n- **主驱动程序**：一个主函数将执行四个测试用例，使用粗、细参数调用相应的求解器，收集误差，并计算所需的四个收敛阶。最终输出将格式化为方括号内的逗号分隔列表。",
            "answer": "# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and print the results.\n    \"\"\"\n    \n    # Global parameters\n    ALPHA = 1.0\n    T_FINAL = 0.01\n\n    def u_exact(x, y, t):\n        \"\"\"Manufactured exact solution.\"\"\"\n        return np.exp(t) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def f_source(x, y, t):\n        \"\"\"Derived source term for the manufactured solution.\"\"\"\n        return (1.0 + 2.0 * np.pi**2 * ALPHA) * np.exp(t) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def solve_ftcs(Nx, Ny, dt_target):\n        \"\"\"\n        Solves the 2D heat equation using the FTCS method.\n        Returns the discrete l2-error and the actual time step used.\n        \"\"\"\n        # Grid setup\n        hx = 1.0 / (Nx + 1)\n        hy = 1.0 / (Ny + 1)\n        x = np.linspace(0, 1, Nx + 2)\n        y = np.linspace(0, 1, Ny + 2)\n        \n        # Time setup\n        n_steps = int(np.ceil(T_FINAL / dt_target))\n        dt = T_FINAL / n_steps\n        \n        # Initial condition (u=0 on boundaries is implicit)\n        u_n = np.zeros((Ny + 2, Nx + 2))\n        for j in range(1, Ny + 1):\n            for i in range(1, Nx + 1):\n                u_n[j, i] = u_exact(x[i], y[j], 0.0)\n\n        # Time stepping loop\n        for n in range(n_steps):\n            t_n = n * dt\n            \n            # Vectorized update of interior points\n            laplacian_u = (u_n[1:-1, 2:] - 2 * u_n[1:-1, 1:-1] + u_n[1:-1, :-2]) / hx**2 \\\n                        + (u_n[2:, 1:-1] - 2 * u_n[1:-1, 1:-1] + u_n[:-2, 1:-1]) / hy**2\n            \n            # Source term evaluated on interior grid\n            xx, yy = np.meshgrid(x[1:-1], y[1:-1])\n            f_n = f_source(xx, yy, t_n)\n            \n            u_n[1:-1, 1:-1] += dt * (ALPHA * laplacian_u + f_n)\n\n        # Compute error at final time T\n        u_final_exact_grid = np.zeros_like(u_n)\n        for j in range(1, Ny + 1):\n            for i in range(1, Nx + 1):\n                u_final_exact_grid[j, i] = u_exact(x[i], y[j], T_FINAL)\n\n        error_grid = u_n[1:-1, 1:-1] - u_final_exact_grid[1:-1, 1:-1]\n        l2_error = np.sqrt(hx * hy * np.sum(error_grid**2))\n        \n        return l2_error, dt\n\n    def solve_cn(Nx, Ny, dt_target):\n        \"\"\"\n        Solves the 2D heat equation using the Crank-Nicolson method.\n        Returns the discrete l2-error and the actual time step used.\n        \"\"\"\n        # Grid setup\n        hx = 1.0 / (Nx + 1)\n        hy = 1.0 / (Ny + 1)\n        \n        x_int = np.linspace(hx, 1.0 - hx, Nx)\n        y_int = np.linspace(hy, 1.0 - hy, Ny)\n        xx, yy = np.meshgrid(x_int, y_int)\n\n        # Time setup\n        n_steps = int(np.ceil(T_FINAL / dt_target))\n        dt = T_FINAL / n_steps\n\n        # Initial condition (vectorized)\n        u_vec_n = u_exact(xx, yy, 0.0).flatten()\n\n        # System matrices\n        N = Nx * Ny\n        \n        main_diag = np.ones(N) * (-2/hx**2 - 2/hy**2)\n        x_diag = np.ones(N - 1) * (1/hx**2)\n        for i in range(1, Ny):\n            x_diag[i * Nx - 1] = 0\n        y_diag = np.ones(N - Nx) * (1/hy**2)\n        \n        L = sparse.diags([main_diag, x_diag, x_diag, y_diag, y_diag], \n                          [0, -1, 1, -Nx, Nx], shape=(N, N), format='csc')\n\n        A = sparse.identity(N) - (dt / 2.0) * ALPHA * L\n        B = sparse.identity(N) + (dt / 2.0) * ALPHA * L\n        \n        # Factorize A for repeated solves\n        solve_A = linalg.factorized(A)\n\n        # Time stepping loop\n        for n in range(n_steps):\n            t_n = n * dt\n            t_np1 = (n + 1) * dt\n            \n            F_n = f_source(xx, yy, t_n).flatten()\n            F_np1 = f_source(xx, yy, t_np1).flatten()\n            F_avg = (F_n + F_np1) / 2.0\n            \n            rhs = B.dot(u_vec_n) + dt * F_avg\n            u_vec_n = solve_A(rhs)\n\n        # Compute error at final time T\n        u_final_exact_vec = u_exact(xx, yy, T_FINAL).flatten()\n        error_vec = u_vec_n - u_final_exact_vec\n        l2_error = np.sqrt(hx * hy * np.sum(error_vec**2))\n        \n        return l2_error, dt\n\n    def get_order(E_coarse, E_fine, r):\n        \"\"\"Computes the observed order of convergence.\"\"\"\n        return np.log(E_coarse / E_fine) / np.log(r)\n\n    results = []\n\n    # Test 1: FTCS temporal order\n    N = 80\n    h = 1.0 / (N + 1)\n    dt_target_coarse_1 = 0.2 * h**2\n    dt_target_fine_1 = dt_target_coarse_1 / 2.0\n    \n    E_coarse, dt_coarse = solve_ftcs(N, N, dt_target_coarse_1)\n    E_fine, dt_fine = solve_ftcs(N, N, dt_target_fine_1)\n    r_t = dt_coarse / dt_fine\n    p_ftcs_t = get_order(E_coarse, E_fine, r_t)\n    results.append(p_ftcs_t)\n\n    # Test 2: FTCS spatial order\n    N_coarse, N_fine = 20, 40\n    h_coarse = 1.0 / (N_coarse + 1)\n    h_fine = 1.0 / (N_fine + 1)\n    dt_target_coarse = 0.05 * h_coarse**2\n    dt_target_fine = 0.05 * h_fine**2\n    \n    E_coarse, _ = solve_ftcs(N_coarse, N_coarse, dt_target_coarse)\n    E_fine, _ = solve_ftcs(N_fine, N_fine, dt_target_fine)\n    r_h = h_coarse / h_fine\n    p_ftcs_h = get_order(E_coarse, E_fine, r_h)\n    results.append(p_ftcs_h)\n    \n    # Test 3: Crank-Nicolson temporal order\n    N = 80\n    dt_target_coarse = 0.0025\n    dt_target_fine = dt_target_coarse / 2.0\n    \n    E_coarse, dt_coarse = solve_cn(N, N, dt_target_coarse)\n    E_fine, dt_fine = solve_cn(N, N, dt_target_fine)\n    r_t = dt_coarse / dt_fine\n    p_cn_t = get_order(E_coarse, E_fine, r_t)\n    results.append(p_cn_t)\n    \n    # Test 4: Crank-Nicolson spatial order\n    N_coarse, N_fine = 16, 32\n    h_coarse = 1.0 / (N_coarse + 1)\n    h_fine = 1.0 / (N_fine + 1)\n    dt_target_coarse = h_coarse**2\n    dt_target_fine = h_fine**2\n    \n    E_coarse, _ = solve_cn(N_coarse, N_coarse, dt_target_coarse)\n    E_fine, _ = solve_cn(N_fine, N_fine, dt_target_fine)\n    r_h = h_coarse / h_fine\n    p_cn_h = get_order(E_coarse, E_fine, r_h)\n    results.append(p_cn_h)\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个正确的实现是必要的，但还不够；对于显式方法而言，稳定性是至关重要的。虽然前一个练习直接给出了FTCS方法的稳定性约束条件，但本练习  要求您使用冯·诺依曼稳定性分析，从第一性原理出发推导出这一结论。通过分析诺伊曼（绝热）边界条件下的情况，您将探索该分析如何处理不同的边界数据，并判断它是否会改变二维热方程著名的稳定性极限，从而加深您对数值稳定性的理论理解。",
            "id": "3388348",
            "problem": "考虑一个矩形域上的二维热方程，其边界条件为齐次诺伊曼边界条件。设温度场 $u(x,y,t)$ 根据偏微分方程 $u_{t}=\\kappa\\,(u_{xx}+u_{yy})$ 演化，其中 $x\\in[0,L_{x}]$，$y\\in[0,L_{y}]$，$t\\ge 0$，且 $\\kappa>0$ 为热扩散系数。边界条件为对所有适用的 $(x,y,t)$ 均有 $u_{x}(0,y,t)=0$，$u_{x}(L_{x},y,t)=0$，$u_{y}(x,0,t)=0$ 和 $u_{y}(x,L_{y},t)=0$。用包含边界的均匀网格对空间域进行离散化：$x_{i}=i\\,\\Delta x$，$i=0,1,\\dots,N_{x}$，其中 $\\Delta x=L_{x}/N_{x}$；以及 $y_{j}=j\\,\\Delta y$，$j=0,1,\\dots,N_{y}$，其中 $\\Delta y=L_{y}/N_{y}$。在时间上，使用时间步长为 $\\Delta t>0$ 的时间前向中心差分 (FTCS) 格式，因此节点值 $u_{i,j}^{n}$ 近似于 $u(x_{i},y_{j},t_{n})$，其中 $t_{n}=n\\,\\Delta t$。通过使用镜像虚拟节点满足 $u_{-1,j}^{n}=u_{1,j}^{n}$、$u_{N_{x}+1,j}^{n}=u_{N_{x}-1,j}^{n}$、$u_{i,-1}^{n}=u_{i,1}^{n}$ 和 $u_{i,N_{y}+1}^{n}=u_{i,N_{y}-1}^{n}$ 的二阶中心差分来施加诺伊曼边界条件。\n\n从控制方程和这些离散边界封闭条件出发，推导 FTCS 方法的线性更新式，并使用与齐次诺伊曼边界条件一致的本征模进行模态稳定性分析。令 $r_{x}=\\kappa\\,\\Delta t/\\Delta x^{2}$ 和 $r_{y}=\\kappa\\,\\Delta t/\\Delta y^{2}$。通过要求每个容许空间模式的放大因子的模不大于1，确定组合无量纲时间步长参数 $r_{x}+r_{y}$ 在诺伊曼边界条件下保证 FTCS 稳定性的最大允许值。请用一个无量纲数表示你的最终答案。",
            "solution": "在尝试求解之前，将对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n问题陈述中提供了以下信息：\n- **控制方程：** 二维热方程，$u_{t}=\\kappa\\,(u_{xx}+u_{yy})$。\n- **区域：** $x\\in[0,L_{x}]$，$y\\in[0,L_{y}]$ 和 $t\\ge 0$。\n- **物理常数：** 热扩散系数 $\\kappa>0$。\n- **边界条件 (BCs)：** 齐次诺伊曼边界条件：$u_{x}(0,y,t)=0$，$u_{x}(L_{x},y,t)=0$，$u_{y}(x,0,t)=0$ 和 $u_{y}(x,L_{y},t)=0$。\n- **空间离散化：** 均匀网格，$x_{i}=i\\,\\Delta x$，$i=0,1,\\dots,N_{x}$，其中 $\\Delta x=L_{x}/N_{x}$；以及 $y_{j}=j\\,\\Delta y$，$j=0,1,\\dots,N_{y}$，其中 $\\Delta y=L_{y}/N_{y}$。\n- **时间离散化：** 均匀时间步长 $\\Delta t>0$，$t_n = n\\,\\Delta t$。网格点 $(x_i, y_j)$ 在时间 $t_n$ 的解记为 $u_{i,j}^{n}$。\n- **数值格式：** 时间前向中心差分 (FTCS)。\n- **离散边界条件实现：** 使用虚拟节点的二阶中心差分，由关系式 $u_{-1,j}^{n}=u_{1,j}^{n}$、$u_{N_{x}+1,j}^{n}=u_{N_{x}-1,j}^{n}$、$u_{i,-1}^{n}=u_{i,1}^{n}$ 和 $u_{i,N_{y}+1}^{n}=u_{i,N_{y}-1}^{n}$ 指定。\n- **无量纲参数：** $r_{x}=\\kappa\\,\\Delta t/\\Delta x^{2}$ 和 $r_{y}=\\kappa\\,\\Delta t/\\Delta y^{2}$。\n- **目标：** 确定保证 FTCS 格式稳定性的 $r_{x}+r_{y}$ 的最大允许值。\n\n### 步骤2：使用提取的已知条件进行验证\n根据提取的已知条件对问题进行严格评估：\n- **科学依据：** 问题基于热方程，这是物理学和工程学中的一个基本抛物型偏微分方程 (PDE)。FTCS 方法是求解此类偏微分方程的标准（尽管简单）数值格式。稳定性分析是数值分析的基石。该问题没有任何伪科学或事实错误。\n- **适定性：** 问题给出了清晰的偏微分方程、区域和边界条件。离散化方法和边界条件的处理方式都明确无误。问题要求一个可推导的单一数值——稳定性极限，已知该值在此设置下存在且唯一。\n- **客观性：** 语言精确、技术性强，没有任何主观性或含糊之处。所有术语都是数值偏微分方程领域的标准术语。\n- **完整性和一致性：** 问题是自洽的。提供了推导稳定性准则所需的所有必要信息。使用虚拟点来实现诺伊曼边界条件与二阶中心差分模板是一致的。\n\n### 步骤3：结论与行动\n该问题是有效的，因为它具有科学性、适定性、客观性和内部一致性。现在将推导求解过程。\n\n第一步是使用时间前向中心差分 (FTCS) 格式写出控制偏微分方程的离散形式。时间导数用前向差分近似，空间导数用中心差分近似：\n$$\n\\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} = \\kappa \\left( \\frac{u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n}{\\Delta x^2} + \\frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{\\Delta y^2} \\right)\n$$\n只要我们使用指定的虚拟节点条件，该方程就对所有网格点（包括边界）成立。让我们重新整理方程，用当前时间步 $u^n$ 的解来表示新时间步 $u_{i,j}^{n+1}$ 的解：\n$$\nu_{i,j}^{n+1} = u_{i,j}^n + \\frac{\\kappa \\Delta t}{\\Delta x^2} (u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n) + \\frac{\\kappa \\Delta t}{\\Delta y^2} (u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n)\n$$\n引入无量纲参数 $r_x = \\kappa \\Delta t / \\Delta x^2$ 和 $r_y = \\kappa \\Delta t / \\Delta y^2$，更新方程变为：\n$$\nu_{i,j}^{n+1} = u_{i,j}^n + r_x (u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n) + r_y (u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n)\n$$\n可以重新组合为：\n$$\nu_{i,j}^{n+1} = (1 - 2r_x - 2r_y)u_{i,j}^n + r_x(u_{i+1,j}^n + u_{i-1,j}^n) + r_y(u_{i,j+1}^n + u_{i,j-1}^n)\n$$\n为了进行模态分析或冯·诺伊曼稳定性分析，我们研究单个空间模式的放大情况。具有齐次诺伊曼边界条件的连续问题的解析解可以表示为傅里叶余弦级数。这启发我们选择一个具有相同空间形式的离散试探解。单个模式可以表示为：\n$$\nu_{i,j}^n = A(\\Delta t)^n \\cos\\left(\\frac{p\\pi x_i}{L_x}\\right) \\cos\\left(\\frac{q\\pi y_j}{L_y}\\right)\n$$\n其中 $p$ 和 $q$ 是整数波数。代入 $x_i = i\\Delta x = i L_x/N_x$ 和 $y_j = j\\Delta y = j L_y/N_y$，我们得到：\n$$\nu_{i,j}^n = G^n \\cos\\left(\\frac{p\\pi i}{N_x}\\right) \\cos\\left(\\frac{q\\pi j}{N_y}\\right)\n$$\n这里，$G$ 是每个时间步的放大因子。整数 $p$ 和 $q$ 代表模式数，范围从 $p=0, 1, \\dots, N_x$ 和 $q=0, 1, \\dots, N_y$，用以表示网格上所有唯一的模式。这种形式的解内在地满足离散诺伊曼边界条件。例如，在 $i=0$ 处，条件是 $u_{-1,j}^n = u_{1,j}^n$。对于我们的试探解：\n$$\nu_{-1,j}^n = G^n \\cos\\left(\\frac{-p\\pi}{N_x}\\right) \\cos\\left(\\frac{q\\pi j}{N_y}\\right) = G^n \\cos\\left(\\frac{p\\pi}{N_x}\\right) \\cos\\left(\\frac{q\\pi j}{N_y}\\right) = u_{1,j}^n\n$$\n由于余弦函数的偶函数性质 $\\cos(-\\theta) = \\cos(\\theta)$，该式成立。同样的逻辑也适用于其他三个边界。\n\n现在，我们将试探解代入离散更新方程。令 $\\phi_p = \\frac{p\\pi}{N_x}$ 和 $\\phi_q = \\frac{q\\pi}{N_y}$。试探解为 $u_{i,j}^n = G^n \\cos(i\\phi_p) \\cos(j\\phi_q)$。\n代入 FTCS 方程：\n$$\nG^{n+1} \\cos(i\\phi_p) \\cos(j\\phi_q) = (1 - 2r_x - 2r_y)G^n \\cos(i\\phi_p) \\cos(j\\phi_q) + r_x G^n \\cos(j\\phi_q)[\\cos((i+1)\\phi_p) + \\cos((i-1)\\phi_p)] + r_y G^n \\cos(i\\phi_p)[\\cos((j+1)\\phi_q) + \\cos((j-1)\\phi_q)]\n$$\n我们使用三角恒等式 $\\cos(A+B) + \\cos(A-B) = 2\\cos A \\cos B$。\n这得到 $\\cos((i+1)\\phi_p) + \\cos((i-1)\\phi_p) = 2\\cos(i\\phi_p)\\cos(\\phi_p)$，$y$ 方向同理。\n将这些代入方程，并除以公因子 $G^n \\cos(i\\phi_p) \\cos(j\\phi_q)$（对于一般模式，该因子不为零），我们得到放大因子 $G$ 的表达式：\n$$\nG = (1 - 2r_x - 2r_y) + r_x(2\\cos(\\phi_p)) + r_y(2\\cos(\\phi_q))\n$$\n$$\nG = 1 - 2r_x(1 - \\cos(\\phi_p)) - 2r_y(1 - \\cos(\\phi_q))\n$$\n使用半角公式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$：\n$$\nG = 1 - 4r_x \\sin^2\\left(\\frac{\\phi_p}{2}\\right) - 4r_y \\sin^2\\left(\\frac{\\phi_q}{2}\\right)\n$$\n代回 $\\phi_p$ 和 $\\phi_q$ 的定义：\n$$\nG(p,q) = 1 - 4r_x \\sin^2\\left(\\frac{p\\pi}{2N_x}\\right) - 4r_y \\sin^2\\left(\\frac{q\\pi}{2N_y}\\right)\n$$\n为使数值格式稳定，每个模式的放大因子模不得超过1，即对所有有效的 $p$ 和 $q$，都有 $|G(p,q)| \\le 1$。这等价于条件 $-1 \\le G(p,q) \\le 1$。\n\n我们来检查每个不等式：\n1. $G(p,q) \\le 1$：\n$$\n1 - 4r_x \\sin^2\\left(\\frac{p\\pi}{2N_x}\\right) - 4r_y \\sin^2\\left(\\frac{q\\pi}{2N_y}\\right) \\le 1\n$$\n$$\n-4\\left[ r_x \\sin^2\\left(\\frac{p\\pi}{2N_x}\\right) + r_y \\sin^2\\left(\\frac{q\\pi}{2N_y}\\right) \\right] \\le 0\n$$\n由于 $r_x > 0$，$r_y > 0$，且平方正弦项总是非负的，这个不等式总是成立的。\n\n2. $G(p,q) \\ge -1$：\n$$\n1 - 4r_x \\sin^2\\left(\\frac{p\\pi}{2N_x}\\right) - 4r_y \\sin^2\\left(\\frac{q\\pi}{2N_y}\\right) \\ge -1\n$$\n$$\n2 \\ge 4r_x \\sin^2\\left(\\frac{p\\pi}{2N_x}\\right) + 4r_y \\sin^2\\left(\\frac{q\\pi}{2N_y}\\right)\n$$\n$$\n\\frac{1}{2} \\ge r_x \\sin^2\\left(\\frac{p\\pi}{2N_x}\\right) + r_y \\sin^2\\left(\\frac{q\\pi}{2N_y}\\right)\n$$\n这个条件必须对所有模式成立，即对所有 $p \\in \\{0, 1, \\dots, N_x\\}$ 和 $q \\in \\{0, 1, \\dots, N_y\\}$ 都成立。为确保这一点，我们必须为“最坏情况”满足该不等式，即对应于使不等式右侧最大化的 $p$ 和 $q$ 的组合。当平方正弦项的自变量尽可能接近 $\\pi/2$ 时，它们达到最大值。\n当 $p=N_x$ 时，项 $\\sin^2\\left(\\frac{p\\pi}{2N_x}\\right)$ 达到其最大值 $1$。\n当 $q=N_y$ 时，项 $\\sin^2\\left(\\frac{q\\pi}{2N_y}\\right)$ 达到其最大值 $1$。\n这些代表了网格能分辨的最高频率模式。\n\n将这些最大值代入稳定性不等式，得到最严格的条件：\n$$\n\\frac{1}{2} \\ge r_x (1) + r_y (1)\n$$\n$$\nr_x + r_y \\le \\frac{1}{2}\n$$\n这就是二维热方程在齐次诺伊曼边界条件下 FTCS 格式的稳定性条件。因此，组合无量纲时间步长参数 $r_x + r_y$ 的最大允许值为 $\\frac{1}{2}$。",
            "answer": "$$\n\\boxed{\\frac{1}{2}}\n$$"
        },
        {
            "introduction": "现实世界的问题很少拥有完美的均匀网格。网格的各向异性，即网格单元在某一方向上被拉伸（例如 $h_x \\gg h_y$），是一种常见情况，它带来了严峻的挑战：它会严重限制显式方法的时间步长，并降低隐式方法求解器的性能。本练习  将量化这些效应对标准五点差分格式的影响，并探索一个更复杂的九点差分格式如何缓解这些问题，为针对复杂几何形状设计鲁棒的离散化方案提供宝贵的见解。",
            "id": "3388339",
            "problem": "考虑一个矩形上的二维热方程，其具有齐次狄利克雷边界条件，方程为 $$u_t = \\alpha \\, \\nabla^2 u,$$ 其中 $u(x,y,t)$ 是温度，$t$ 是时间，$x$ 和 $y$ 是空间坐标，$\\alpha$ 是热扩散系数。您将研究网格各向异性对显式前向欧拉法稳定性极限（Courant–Friedrichs–Lewy (CFL) 约束）以及对隐式后向欧拉法线性系统条件数的影响，然后量化与标准五点模板相比，网格对齐的九点扩散离散化所实现的改进。\n\n您的任务是使用两种模板，在具有内部网格尺寸 $N_x$ 和 $N_y$ 的均匀但各向异性的笛卡尔网格上构建离散拉普拉斯矩阵。设域为 $[0,L_x]\\times[0,L_y]$，内部网格间距为 $$h_x = \\frac{L_x}{N_x+1}, \\qquad h_y = \\frac{L_y}{N_y+1}.$$ 使用齐次狄利克雷边界条件（边界上 $u=0$），因此离散解定义在 $N_x \\times N_y$ 个内部点上。将热扩散系数定义为 $$\\alpha = 1 \\text{ m}^2\\text{/s}.$$ 对于每种离散化方法，构建矩阵 $L$，该矩阵表示作用于矢量化内部网格值的离散拉普拉斯算子。\n\n1. 标准五点模板（轴对齐二阶中心差分）：对于每个内部节点 $(i,j)$，离散算子为\n$$\\left(L_5 u\\right)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}.$$\n以矩阵形式，这定义了一个对称负定矩阵 $L_5$。\n\n2. 网格对齐九点模板（轴向和对角相邻点），通过泰勒展开匹配二阶导数一致性并选择对角权重以减小谱半径同时保持一致性来导出。令对角权重为\n$$w_d = \\frac{1}{3\\left(h_x^2 + h_y^2\\right)}.$$\n那么轴向相邻点的权重和中心系数由一致性确定：\n$$w_x = \\frac{1 - 2 w_d h_x^2}{h_x^2}, \\qquad w_y = \\frac{1 - 2 w_d h_y^2}{h_y^2}, \\qquad c_0 = -2 w_x - 2 w_y - 4 w_d.$$\n由此产生的九点离散算子为\n$$\\left(L_9 u\\right)_{i,j} = c_0 \\, u_{i,j} + w_x \\left(u_{i+1,j} + u_{i-1,j}\\right) + w_y \\left(u_{i,j+1} + u_{i,j-1}\\right) + w_d \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right).$$\n以矩阵形式，这定义了一个对称负定矩阵 $L_9$。对于 $h_x = h_y = h$ 的情况，这简化为经典的四阶精度九点拉普拉斯算子，其系数为 $$c_0 = -\\frac{10}{3 h^2},\\quad w_x = w_y = \\frac{2}{3 h^2},\\quad w_d = \\frac{1}{6 h^2}.$$\n\n令显式前向欧拉格式为 $$u^{n+1} = u^n + \\Delta t \\, \\alpha \\, L \\, u^n.$$ 为了保证稳定性，最大允许时间步长满足 $$\\Delta t_{\\max} = \\frac{2}{\\alpha \\, \\rho\\!\\left(L\\right)},$$ 其中 $\\rho(L)$ 是 $L$ 的谱半径（$L$ 的最大绝对特征值），且 $L$ 是负定的。对于隐式后向欧拉格式 $$\\left(I - \\Delta t \\, \\alpha \\, L\\right) u^{n+1} = u^n,$$ 线性系统矩阵是对称正定的，其特征值为 $$\\lambda\\!\\left(I - \\Delta t \\, \\alpha \\, L\\right) = 1 + \\Delta t \\, \\alpha \\, \\left|\\lambda\\!\\left(L\\right)\\right|.$$ 其二范数条件数为 $$\\kappa_2\\!\\left(I - \\Delta t \\, \\alpha \\, L\\right) = \\frac{1 + \\Delta t \\, \\alpha \\, \\lambda_{\\max}^{\\text{abs}}(L)}{1 + \\Delta t \\, \\alpha \\, \\lambda_{\\min}^{\\text{abs}}(L)},$$ 其中 $\\lambda_{\\max}^{\\text{abs}}(L)$ 和 $\\lambda_{\\min}^{\\text{abs}}(L)$ 分别是 $L$ 的最大和最小绝对特征值。\n\n计算以下定量指标，以捕捉网格各向异性导致的性能下降和九点模板带来的改进：\n\n- 五点模板的显式CFL退化：$$E_{\\text{deg},5}(r) = \\frac{\\Delta t_{\\max,5}(r)}{\\Delta t_{\\max,5}(1)},$$ 其中 $r$ 是由 $$r = \\frac{h_x}{h_y} = \\frac{L_x(N_y+1)}{L_y(N_x+1)}$$ 定义的网格纵横比。基准各向同性情况为 $r=1$。\n- 在固定参考时间步长下五点模板的隐式条件数退化：选择 $$\\Delta t_{\\text{ref}} = 0.9 \\, \\Delta t_{\\max,5}(1).$$ 则\n$$K_{\\text{deg},5}(r) = \\frac{\\kappa_2\\!\\left(I - \\Delta t_{\\text{ref}} \\, \\alpha \\, L_5(r)\\right)}{\\kappa_2\\!\\left(I - \\Delta t_{\\text{ref}} \\, \\alpha \\, L_5(1)\\right)}.$$\n- 对于相同的各向异性网格，九点模板相对于五点模板的显式CFL改善因子：\n$$E_{\\text{imp}}(r) = \\frac{\\Delta t_{\\max,9}(r)}{\\Delta t_{\\max,5}(r)}.$$\n- 对于相同的各向异性网格和相同的 $\\Delta t_{\\text{ref}}$，九点模板相对于五点模板的隐式条件数改善因子：\n$$K_{\\text{imp}}(r) = \\frac{\\kappa_2\\!\\left(I - \\Delta t_{\\text{ref}} \\, \\alpha \\, L_9(r)\\right)}{\\kappa_2\\!\\left(I - \\Delta t_{\\text{ref}} \\, \\alpha \\, L_5(r)\\right)}.$$\n\n测试套件。使用以下参数集，所有情况均设置 $N_x = N_y = 12$，$L_x = 1 \\text{ m}$，且 $\\alpha = 1 \\text{ m}^2\\text{/s}$：\n- 情况 A (基准各向同性): $L_y = 1 \\text{ m}$ 因此 $r=1$。\n- 情况 B (中等各向异性): $L_y = \\frac{1}{5} \\text{ m}$ 因此 $r=5$。\n- 情况 C (强各向异性): $L_y = \\frac{1}{25} \\text{ m}$ 因此 $r=25$。\n- 情况 D (极端各向异性): $L_y = \\frac{1}{50} \\text{ m}$ 因此 $r=50$。\n\n对于每种情况，计算四元组 $$\\left[E_{\\text{deg},5}(r),\\, K_{\\text{deg},5}(r),\\, E_{\\text{imp}}(r),\\, K_{\\text{imp}}(r)\\right],$$ 这些都是无量纲实数。您的程序应生成单行输出，其中包含四个情况的结果，格式为方括号括起来的逗号分隔列表，其中每个情况的结果本身也是一个按相同顺序排列的列表。例如，格式必须是 $$\\left[\\left[e_1,k_1,i_1,j_1\\right],\\left[e_2,k_2,i_2,j_2\\right],\\left[e_3,k_3,i_3,j_3\\right],\\left[e_4,k_4,i_4,j_4\\right]\\right],$$ 其中每个 $e_i, k_i, i_i, j_i$ 都表示为十进制浮点数。由于所有指标都是无量纲的，因此不应打印任何单位。",
            "solution": "用户希望在各向异性笛卡尔网格上，分析二维拉普拉斯算子 $\\nabla^2$ 两种不同有限差分离散化的性质。分析的重点是显式前向欧拉时间积分格式的稳定性，以及用于二维热方程 $u_t = \\alpha \\nabla^2 u$ 的隐式后向欧拉格式所产生的线性系统的条件数。\n\n### 问题验证\n问题陈述已经过仔细验证。\n**提取的已知条件**：\n- 偏微分方程 (PDE): $u_t = \\alpha \\, \\nabla^2 u$，其中 $\\alpha = 1 \\text{ m}^2\\text{/s}$。\n- 域: $[0,L_x]\\times[0,L_y]$，具有齐次狄利克雷边界条件。\n- 离散化: $N_x \\times N_y$ 个内部网格点，其中 $h_x = \\frac{L_x}{N_x+1}$ 和 $h_y = \\frac{L_y}{N_y+1}$。\n- 模板: 用于拉普拉斯算子的标准五点模板和特定的网格对齐九点模板，产生矩阵 $L_5$ 和 $L_9$。\n- 时间步进: 显式前向欧拉格式和隐式后向欧拉格式。\n- 指标: $E_{\\text{deg},5}(r)$, $K_{\\text{deg},5}(r)$, $E_{\\text{imp}}(r)$, $K_{\\text{imp}}(r)$ 的定义，基于 $L_5$ 和 $L_9$ 的特征值以及参考时间步长 $\\Delta t_{\\text{ref}} = 0.9 \\, \\Delta t_{\\max,5}(1)$。\n- 测试参数: 常量 $N_x=12, N_y=12, L_x=1$。$L_y$ 的四种情况: $1, 1/5, 1/25, 1/50$，对应于网格纵横比 $r = h_x/h_y$ 分别为 $1, 5, 25, 50$。\n\n**验证结论**：\n该问题是**有效的**。它在偏微分方程的数值分析领域具有科学依据，是良态的，具有唯一的计算解，并以客观、正式的语言表述。所有常数、公式和步骤都定义清晰且一致。该问题是该领域一个标准的、尽管详细的练习。\n\n### 求解方法\n\n问题的核心是计算离散拉普拉斯矩阵 $L_5$ 和 $L_9$ 的最小和最大绝对特征值。对于具有狄利克雷边界条件的矩形域，这些离散算子的特征向量已知是离散正弦函数。这使得可以推导出特征值的解析表达式，从而无需使用数值特征值求解器，并能得出精确结果。\n\n**1. 5点拉普拉斯算子 ($L_5$) 的特征值**\n离散算子为：\n$(\\left(L_5 u\\right)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}.$\n其特征值 $\\lambda_{p,q}(L_5)$（其中 $p=1, \\dots, N_x$ 且 $q=1, \\dots, N_y$）由下式给出：\n$$ \\lambda_{p,q}(L_5) = \\frac{2}{h_x^2} \\left( \\cos\\left(\\frac{p \\pi}{N_x+1}\\right) - 1 \\right) + \\frac{2}{h_y^2} \\left( \\cos\\left(\\frac{q \\pi}{N_y+1}\\right) - 1 \\right) $$\n使用恒等式 $1 - \\cos(\\theta) = 2 \\sin^2(\\theta/2)$，并注意到所有特征值都是负的，它们的绝对值为：\n$$ |\\lambda_{p,q}(L_5)| = \\frac{4}{h_x^2} \\sin^2\\left(\\frac{p \\pi}{2(N_x+1)}\\right) + \\frac{4}{h_y^2} \\sin^2\\left(\\frac{q \\pi}{2(N_y+1)}\\right) $$\n最小和最大绝对特征值分别通过取 $(p,q)=(1,1)$ 和 $(p,q)=(N_x, N_y)$ 得到。\n\n**2. 9点拉普拉斯算子 ($L_9$) 的特征值**\n9点算子由系数 $w_d, w_x, w_y, c_0$ 定义。由于其特征向量与 $L_5$ 相同，我们可以通过将算子应用于一个通用特征向量来找到特征值 $\\lambda_{p,q}(L_9)$。这会得到以下表达式：\n$$ \\lambda_{p,q}(L_9) = c_0 + 2w_x \\cos\\left(\\frac{p\\pi}{N_x+1}\\right) + 2w_y \\cos\\left(\\frac{q\\pi}{N_y+1}\\right) + 4w_d \\cos\\left(\\frac{p\\pi}{N_x+1}\\right) \\cos\\left(\\frac{q\\pi}{N_y+1}\\right) $$\n代入 $w_x, w_y,$ 和 $c_0$ 的定义并进行代数简化，可以得到一个更具洞察力的形式：\n$$ \\lambda_{p,q}(L_9) = \\lambda_{p,q}(L_5) - 16 w_d \\sin^2\\left(\\frac{p\\pi}{2(N_x+1)}\\right) \\sin^2\\left(\\frac{q\\pi}{2(N_y+1)}\\right) $$\n由于 $w_d = 1/(3(h_x^2+h_y^2)) > 0$ 且正弦项为非负，第二项为正或零。这证实了 $L_9$ 的所有特征值都是负的（如思考过程所示），且对于 $p,q > 0$ 有 $|\\lambda_{p,q}(L_9)|  |\\lambda_{p,q}(L_5)|$。$L_9$ 的最小和最大绝对特征值通过计算所有 $(p,q)$ 对的 $|\\lambda_{p,q}(L_9)|$ 并找到结果值的最小和最大值来得到。\n\n**3. 指标计算**\n有了计算两种模板谱边界 $\\lambda_{\\min}^{\\text{abs}}(L)$ 和 $\\lambda_{\\max}^{\\text{abs}}(L)$ 的能力，我们就可以计算所需的指标。\n\n首先，计算基准各向同性情况 ($r=1$) 以确定 $\\Delta t_{\\max,5}(1)$ 和参考条件数 $\\kappa_2(I - \\Delta t_{\\text{ref}} \\alpha L_5(1))$。参考时间步长为 $\\Delta t_{\\text{ref}} = 0.9 \\, \\Delta t_{\\max,5}(1)$。\n\n然后，对于每个测试用例（包括基准情况），我们计算：\n- $\\Delta t_{\\max,5}(r) = \\frac{2}{\\alpha \\lambda_{\\max}^{\\text{abs}}(L_5(r))}$\n- $\\Delta t_{\\max,9}(r) = \\frac{2}{\\alpha \\lambda_{\\max}^{\\text{abs}}(L_9(r))}$\n- $\\kappa_{2,5}(r) = \\frac{1 + \\Delta t_{\\text{ref}} \\alpha \\lambda_{\\max}^{\\text{abs}}(L_5(r))}{1 + \\Delta t_{\\text{ref}} \\alpha \\lambda_{\\min}^{\\text{abs}}(L_5(r))}$\n- $\\kappa_{2,9}(r) = \\frac{1 + \\Delta t_{\\text{ref}} \\alpha \\lambda_{\\max}^{\\text{abs}}(L_9(r))}{1 + \\Delta t_{\\text{ref}} \\alpha \\lambda_{\\min}^{\\text{abs}}(L_9(r))}$\n\n最后，使用这些值来计算问题陈述中定义的四个无量纲比率 $E_{\\text{deg},5}(r)$, $K_{\\text{deg},5}(r)$, $E_{\\text{imp}}(r)$ 和 $K_{\\text{imp}}(r)$。\n\n实现将遵循这种解析方法以确保精度和效率。一个 Python 脚本将为四个指定的测试用例执行这些计算。",
            "answer": "```python\nimport numpy as np\n\ndef get_eigenvalues_L5(Nx, Ny, hx, hy):\n    \"\"\"\n    Computes the min and max absolute eigenvalues of the 5-point discrete Laplacian\n    using the analytical formula.\n    \"\"\"\n    p = np.arange(1, Nx + 1)\n    q = np.arange(1, Ny + 1)\n    \n    # Eigenvalues of 1D Laplacians in x and y directions\n    lambda_p_abs = (4 / hx**2) * np.sin(p * np.pi / (2 * (Nx + 1)))**2\n    lambda_q_abs = (4 / hy**2) * np.sin(q * np.pi / (2 * (Ny + 1)))**2\n    \n    # 2D eigenvalues are sums of 1D eigenvalues.\n    # The smallest is sum of smallest, largest is sum of largest.\n    lambda_min_abs = lambda_p_abs[0] + lambda_q_abs[0]\n    lambda_max_abs = lambda_p_abs[-1] + lambda_q_abs[-1]\n    \n    return lambda_min_abs, lambda_max_abs\n\ndef get_eigenvalues_L9(Nx, Ny, hx, hy):\n    \"\"\"\n    Computes the min and max absolute eigenvalues of the 9-point discrete Laplacian\n    by correcting the 5-point eigenvalues.\n    \"\"\"\n    p = np.arange(1, Nx + 1)\n    q = np.arange(1, Ny + 1)\n    \n    # Pre-calculate sine-squared terms\n    sp_sq = np.sin(p * np.pi / (2 * (Nx + 1)))**2\n    sq_sq = np.sin(q * np.pi / (2 * (Ny + 1)))**2\n    \n    # Matrix of absolute eigenvalues for the 5-point stencil\n    lambda5_abs_mat = np.add.outer((4 / hx**2) * sp_sq, (4 / hy**2) * sq_sq)\n    \n    # Diagonal weight for the 9-point stencil\n    wd = 1 / (3 * (hx**2 + hy**2))\n    \n    # Correction term to get 9-point eigenvalues from 5-point\n    # For a negative definite operator L, |L| = -L.\n    # L9 = L5 + Correction, so |L9| = |L5| - Correction\n    correction_mat = 16 * wd * np.outer(sp_sq, sq_sq)\n    \n    # Matrix of absolute eigenvalues for the 9-point stencil\n    lambda9_abs_mat = lambda5_abs_mat - correction_mat\n    \n    lambda_min_abs = np.min(lambda9_abs_mat)\n    lambda_max_abs = np.max(lambda9_abs_mat)\n    \n    return lambda_min_abs, lambda_max_abs\n    \ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculation of metrics for all test cases.\n    \"\"\"\n    # Global parameters\n    Nx = 12\n    Ny = 12\n    Lx = 1.0\n    alpha = 1.0\n    \n    # Test cases defined by Ly values\n    test_cases = [\n        1.0,        # Case A: r=1\n        1.0 / 5.0,  # Case B: r=5\n        1.0 / 25.0, # Case C: r=25\n        1.0 / 50.0  # Case D: r=50\n    ]\n\n    # --- Baseline Calculation (r=1) ---\n    Ly_base = test_cases[0]\n    hx_base = Lx / (Nx + 1)\n    hy_base = Ly_base / (Ny + 1)\n\n    lambda_min_5_base, lambda_max_5_base = get_eigenvalues_L5(Nx, Ny, hx_base, hy_base)\n    \n    dt_max_5_base = 2.0 / (alpha * lambda_max_5_base)\n    dt_ref = 0.9 * dt_max_5_base\n    \n    kappa_5_base = (1 + dt_ref * alpha * lambda_max_5_base) / (1 + dt_ref * alpha * lambda_min_5_base)\n\n    results = []\n    \n    # --- Loop over all cases ---\n    for Ly in test_cases:\n        hx = Lx / (Nx + 1)\n        hy = Ly / (Ny + 1)\n        \n        # --- 5-point stencil calculations ---\n        lambda_min_5, lambda_max_5 = get_eigenvalues_L5(Nx, Ny, hx, hy)\n        \n        dt_max_5 = 2.0 / (alpha * lambda_max_5)\n        E_deg_5 = dt_max_5 / dt_max_5_base\n        \n        kappa_5 = (1 + dt_ref * alpha * lambda_max_5) / (1 + dt_ref * alpha * lambda_min_5)\n        K_deg_5 = kappa_5 / kappa_5_base\n        \n        # --- 9-point stencil calculations ---\n        lambda_min_9, lambda_max_9 = get_eigenvalues_L9(Nx, Ny, hx, hy)\n        \n        dt_max_9 = 2.0 / (alpha * lambda_max_9)\n        E_imp = dt_max_9 / dt_max_5\n        \n        kappa_9 = (1 + dt_ref * alpha * lambda_max_9) / (1 + dt_ref * alpha * lambda_min_9)\n        K_imp = kappa_9 / kappa_5\n        \n        # Store the quadruple of metrics for the current case\n        results.append([E_deg_5, K_deg_5, E_imp, K_imp])\n\n    # Format output as a single-line string representation of a list of lists.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}