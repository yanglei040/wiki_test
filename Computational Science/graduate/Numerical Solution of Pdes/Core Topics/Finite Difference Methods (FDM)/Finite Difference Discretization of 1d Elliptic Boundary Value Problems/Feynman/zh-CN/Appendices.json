{
    "hands_on_practices": [
        {
            "introduction": "在实现了数值格式后，验证其正确性和收敛阶至关重要。第一个实践将引导你使用“人造解方法”（Method of Manufactured Solutions, MMS），这是一种严格的技术，用于确认你的代码是否达到了理论精度阶。你还将应用理查森外推法（Richardson extrapolation），这是一种以后处理方式提高解的精度的强大技术，而计算成本增加很小。",
            "id": "3392829",
            "problem": "考虑在闭区间 $[0,1]$ 上的以下一维线性二阶椭圆边值问题，其守恒形式为：\n$$\n-\\frac{d}{dx}\\left(a(x)\\,\\frac{du(x)}{dx}\\right) + c(x)\\,u(x) = f(x).\n$$\n您将使用制造解方法（Method of Manufactured Solutions, MMS）验证一个二阶守恒有限差分格式的精度，然后应用理查森外推（Richardson extrapolation）来改进一个点态解的估计。所有三角函数的参数都应解释为弧度。\n\n基本定义与离散化。设 $N\\in\\mathbb{N}$ 为均匀子区间的数量，$h = 1/N$ 为网格间距，$x_i = i\\,h$（$i=0,1,\\dots,N$）为网格节点。对于内部索引 $i=1,\\dots,N-1$，定义中点位置 $x_{i\\pm \\frac{1}{2}} = x_i \\pm \\frac{h}{2}$。内部节点处的二阶守恒有限差分格式由守恒形式和扩散系数的中点求值构造而成：\n$$\n-\\frac{1}{h}\\left(a\\!\\left(x_{i+\\frac{1}{2}}\\right)\\frac{u_{i+1}-u_i}{h} - a\\!\\left(x_{i-\\frac{1}{2}}\\right)\\frac{u_i-u_{i-1}}{h}\\right) + c(x_i)\\,u_i = f(x_i).\n$$\n对于 $x=0$ 和 $x=1$ 处的狄利克雷（Dirichlet）边界条件，将 $u_0$ 和 $u_N$ 设置为精确的边界值。对于 $x=0$ 处形式为\n$$\n\\alpha\\,u(0) + \\beta\\,u'(0) = \\gamma,\n$$\n的罗宾（Robin）边界条件，使用二阶单边差分近似\n$$\nu'(0) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h},\n$$\n来强制执行该边界方程，并将此方程作为线性系统的第一个方程（内部方程位于 $i=1,\\dots,N-1$，右侧的狄利克雷边界在 $x=1$ 处通过代入 $u_N$ 来强施加）。\n\n制造解方法（MMS）。对于下面的每个测试，选择一个光滑的精确解 $u_{\\text{ex}}(x)$，并通过将 $u_{\\text{ex}}(x)$ 代入微分算子来定义数据 $f(x)$：\n$$\nf(x) = -\\left(a(x)\\,u_{\\text{ex}}''(x) + a'(x)\\,u_{\\text{ex}}'(x)\\right) + c(x)\\,u_{\\text{ex}}(x).\n$$\n使用 $u_{\\text{ex}}$ 以及在需要时使用 $u_{\\text{ex}}'$ 来精确施加边界条件。\n\n观测精度阶与理查森外推。设 $\\|e_h\\|_{\\infty}$ 表示在间距为 $h$ 的网格上的最大范数误差，其定义为 $\\|e_h\\|_{\\infty} = \\max_{0\\le i\\le N} |u_i - u_{\\text{ex}}(x_i)|$（当两个端点都包含在未知量中时），或者当狄利克雷值被强施加时，定义为所有节点（包括精确边界值）上的最大值。由两个尺寸分别为 $h$ 和 $h/2$ 的嵌套网格计算出的观测阶为\n$$\np_{\\infty} = \\log_2\\!\\left(\\frac{\\|e_h\\|_{\\infty}}{\\|e_{h/2}\\|_{\\infty}}\\right).\n$$\n给定在固定点 $x^\\star\\in(0,1)$ 处对 $u(x^\\star)$ 的近似值 $U_h(x^\\star)$ 和 $U_{h/2}(x^\\star)$（通过在两个网格上进行线性插值得到），以及收敛阶的估计值 $p$，理查森外推值（Richardson-extrapolated value）为\n$$\nU_{\\text{RE}}(x^\\star) = \\frac{2^p\\,U_{h/2}(x^\\star) - U_{h}(x^\\star)}{2^p - 1}.\n$$\n\n任务。实现上述有限差分方法，在测试套件上使用MMS验证观测阶，并在指定点执行理查森外推。您的程序必须解决以下三个制造解测试问题：\n\n- 测试 A（光滑可变系数，狄利克雷-狄利克雷）：\n  - $a(x) = 2 + \\sin(3x)$,\n  - $c(x) = 1 + x$,\n  - $u_{\\text{ex}}(x) = e^{x}\\,\\sin(2\\pi x)$,\n  - 边界：$u(0) = u_{\\text{ex}}(0)$，$u(1) = u_{\\text{ex}}(1)$。\n\n- 测试 B（扩散主导，狄利克雷-狄利克雷）：\n  - $a(x) = e^{x}$,\n  - $c(x) = 0$,\n  - $u_{\\text{ex}}(x) = \\sin(5x)$,\n  - 边界：$u(0) = u_{\\text{ex}}(0)$，$u(1) = u_{\\text{ex}}(1)$。\n\n- 测试 C（可变扩散与反应项，罗宾-狄利克雷）：\n  - $a(x) = 1 + x$,\n  - $c(x) = 2$,\n  - $u_{\\text{ex}}(x) = \\cos(3\\pi x)$,\n  - 左边界（$x=0$ 处的罗宾条件）：$\\alpha = 1$，$\\beta = 1$，$\\gamma = \\alpha\\,u_{\\text{ex}}(0) + \\beta\\,u_{\\text{ex}}'(0)$，\n  - 右边界（$x=1$ 处的狄利克雷条件）：$u(1) = u_{\\text{ex}}(1)$。\n\n数值实验规格：\n\n- 对于每个测试，使用来自两个网格尺寸 $N = 64$ 和 $N = 128$（因此 $h = 1/64$ 和 $h/2 = 1/128$）的无穷范数误差计算观测阶 $p_{\\infty}$。\n- 仅对测试 A，在内点 $x^\\star = 0.37$ 处执行理查森外推。通过分别对 $N=64$ 和 $N=128$ 网格上的离散解进行线性插值，计算 $U_h(x^\\star)$ 和 $U_{h/2}(x^\\star)$。使用为测试 A 计算的观测阶 $p_{\\infty}$ 来构成 $U_{\\text{RE}}(x^\\star)$，并以浮点数形式报告绝对误差 $|U_{\\text{RE}}(x^\\star)-u_{\\text{ex}}(x^\\star)|$。\n\n角度单位：所有三角函数均使用弧度。\n\n最终输出格式：您的程序必须生成单行，包含一个 Python 风格的列表，内有四个浮点数\n$$\n\\big[\\,p_{\\infty}^{(A)},\\; p_{\\infty}^{(B)},\\; p_{\\infty}^{(C)},\\; E_{\\text{RE}}^{(A)}(x^\\star)\\,\\big],\n$$\n其中 $p_{\\infty}^{(A)}$、$p_{\\infty}^{(B)}$ 和 $p_{\\infty}^{(C)}$ 分别是测试 A、B 和 C 的观测阶，而 $E_{\\text{RE}}^{(A)}(x^\\star)$ 是测试 A 在 $x^\\star = 0.37$ 处的绝对理查森外推误差。程序应以\n$$\n[{\\tt pA},{\\tt pB},{\\tt pC},{\\tt errRE}]\n$$\n形式精确打印一行，用数值替换占位符。",
            "solution": "用户提供的问题经评估有效。它是一个在偏微分方程数值分析领域中适定、科学上合理且完整的问题。所有必要的数据、函数和步骤都已明确定义。任务涉及实现一个标准的二阶有限差分方法，使用制造解方法验证其精度，并应用理查森外推，这些都是标准且严谨的技术。\n\n我们着手提供一个完整的解决方案。\n\n### 1. 问题提法与离散化\n\n控制性的一维椭圆边值问题以守恒形式给出：\n$$\n-\\frac{d}{dx}\\left(a(x)\\,\\frac{du(x)}{dx}\\right) + c(x)\\,u(x) = f(x) \\quad \\text{for } x \\in [0, 1].\n$$\n我们使用具有 $N$ 个子区间的均匀网格对定义域 $[0, 1]$ 进行离散化，得到网格间距 $h=1/N$。网格节点表示为 $x_i = i h$，其中 $i=0, 1, \\dots, N$。这些节点上的数值解为 $u_i \\approx u(x_i)$。\n\n该方法的核心是针对内部节点 $x_i$（其中 $i=1, \\dots, N-1$）的二阶精度守恒有限差分格式：\n$$\n-\\frac{1}{h}\\left(a\\left(x_{i+\\frac{1}{2}}\\right)\\frac{u_{i+1}-u_i}{h} - a\\left(x_{i-\\frac{1}{2}}\\right)\\frac{u_i-u_{i-1}}{h}\\right) + c(x_i)\\,u_i = f(x_i).\n$$\n这里，$x_{i \\pm \\frac{1}{2}} = x_i \\pm \\frac{h}{2}$ 是网格节点之间的中点。为便于构建线性系统，我们将方程两边乘以 $h^2$ 并收集对应于 $u_{i-1}$、$u_i$ 和 $u_{i+1}$ 的项来进行重排：\n$$\n-a\\left(x_{i-\\frac{1}{2}}\\right) u_{i-1} + \\left(a\\left(x_{i+\\frac{1}{2}}\\right) + a\\left(x_{i-\\frac{1}{2}}\\right) + h^2 c(x_i)\\right) u_i - a\\left(x_{i+\\frac{1}{2}}\\right) u_{i+1} = h^2 f(x_i).\n$$\n该方程对每个内部节点都成立，并构成一个线性方程组 $A\\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u}$ 是未知节点值的向量。$A$ 和 $\\mathbf{b}$ 的具体结构取决于边界条件。\n\n### 2. 边界条件\n\n#### 2.1. 狄利克雷-狄利克雷边界条件（测试 A 和 B）\n当给定狄利克雷条件 $u(0)=u_0$ 和 $u(1)=u_N$ 时，值 $u_0$ 和 $u_N$ 是已知的。未知数是内部节点值 $\\mathbf{u} = [u_1, u_2, \\dots, u_{N-1}]^T$。方程组的大小为 $(N-1) \\times (N-1)$。\n第一个内部节点 $i=1$ 的方程为：\n$$\n\\left(a\\left(x_{\\frac{3}{2}}\\right) + a\\left(x_{\\frac{1}{2}}\\right) + h^2 c(x_1)\\right) u_1 - a\\left(x_{\\frac{3}{2}}\\right) u_2 = h^2 f(x_1) + a\\left(x_{\\frac{1}{2}}\\right) u_0.\n$$\n最后一个内部节点 $i=N-1$ 的方程为：\n$$\n-a\\left(x_{N-\\frac{3}{2}}\\right) u_{N-2} + \\left(a\\left(x_{N-\\frac{1}{2}}\\right) + a\\left(x_{N-\\frac{3}{2}}\\right) + h^2 c(x_{N-1})\\right) u_{N-1} = h^2 f(x_{N-1}) + a\\left(x_{N-\\frac{1}{2}}\\right) u_N.\n$$\n如果 $a(x)$ 是常数，则所得矩阵 $A$ 是三对角的且对称的。对于可变的 $a(x)$，它仍然是三对角的。\n\n#### 2.2. 罗宾-狄利克雷边界条件（测试 C）\n对于 $x=0$ 处的罗宾条件 $\\alpha u(0) + \\beta u'(0) = \\gamma$ 和 $x=1$ 处的狄利克雷条件 $u(1)=u_N$。未知数为 $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$。系统大小为 $N \\times N$。\n\n第一个方程来自罗宾条件，使用 $u'(0)$ 的二阶前向差分近似：\n$$\n\\alpha u_0 + \\beta \\left(\\frac{-3u_0 + 4u_1 - u_2}{2h}\\right) = \\gamma.\n$$\n两边乘以 $2h$ 并重排，得到我们线性系统的第一行：\n$$\n(2h\\alpha - 3\\beta) u_0 + 4\\beta u_1 - \\beta u_2 = 2h\\gamma.\n$$\n对于 $i=1, \\dots, N-2$ 的内部方程遵循标准格式。最后一个方程，即节点 $i=N-1$ 的方程，包含了已知值 $u_N$：\n$$\n-a\\left(x_{N-\\frac{3}{2}}\\right) u_{N-2} + \\left(a\\left(x_{N-\\frac{1}{2}}\\right) + a\\left(x_{N-\\frac{3}{2}}\\right) + h^2 c(x_{N-1})\\right) u_{N-1} = h^2 f(x_{N-1}) + a\\left(x_{N-\\frac{1}{2}}\\right) u_N.\n$$\n所得矩阵 $A$ 几乎是三对角的，在 $A_{0,2}$ 处有一个额外的非零项。\n\n### 3. 制造解方法（MMS）与误差分析\n\nMMS 用于验证代码的正确性和收敛率。我们选择一个光滑函数 $u_{\\text{ex}}(x)$作为精确解。然后通过将 $u_{\\text{ex}}(x)$ 代入微分算子来制造源项 $f(x)$：\n$$\nf(x) = -\\frac{d}{dx}\\left(a(x)\\,\\frac{du_{\\text{ex}}(x)}{dx}\\right) + c(x)\\,u_{\\text{ex}}(x) = -\\left(a(x)\\,u_{\\text{ex}}''(x) + a'(x)\\,u_{\\text{ex}}'(x)\\right) + c(x)\\,u_{\\text{ex}}(x).\n$$\n边界条件也由 $u_{\\text{ex}}(x)$ 导出。在求解数值系统得到 $u_i$ 后，使用最大范数计算误差：\n$$\n\\|e_h\\|_{\\infty} = \\max_{0 \\le i \\le N} |u_i - u_{\\text{ex}}(x_i)|.\n$$\n对于一个二阶精度的方法，误差行为应为 $\\|e_h\\|_{\\infty} \\approx C h^2$，其中 $C$ 为某个常数。观测精度阶 $p_{\\infty}$ 由两个间距分别为 $h$ 和 $h/2$ 的嵌套网格上的解计算得出：\n$$\np_{\\infty} = \\log_2\\left(\\frac{\\|e_h\\|_{\\infty}}{\\|e_{h/2}\\|_{\\infty}}\\right).\n$$\n\n### 4. 理查森外推\n\n理查森外推提高了在特定点 $x^\\star$ 处近似的精度。给定从网格 $h$ 得到的解 $U_h(x^\\star)$ 和从网格 $h/2$ 得到的解 $U_{h/2}(x^\\star)$，并且知道该方法的首项误差阶为 $p$，则改进后的估计值为：\n$$\nU_{\\text{RE}}(x^\\star) = U_{h/2}(x^\\star) + \\frac{U_{h/2}(x^\\star) - U_h(x^\\star)}{2^p - 1} = \\frac{2^p U_{h/2}(x^\\star) - U_h(x^\\star)}{2^p - 1}.\n$$\n值 $U_h(x^\\star)$ 和 $U_{h/2}(x^\\star)$ 是通过对离散解进行线性插值得到的。如果 $x_j \\le x^\\star \\le x_{j+1}$，则插值结果为：\n$$\nU(x^\\star) = u_j + (u_{j+1} - u_j) \\frac{x^\\star - x_j}{h}.\n$$\n对于本问题，我们在外推公式中使用数值观测阶 $p=p_{\\infty}$。\n\n### 5. 测试用例的实现\n\n将所描述的方法应用于三个测试用例。对每个用例，我们定义具体的函数 $a(x)$、$c(x)$、$u_{\\text{ex}}(x)$ 及其导数，以计算源项 $f(x)$ 和边界数据。\n\n- **测试 A：** $a(x) = 2 + \\sin(3x)$，$c(x) = 1 + x$，$u_{\\text{ex}}(x) = e^x\\sin(2\\pi x)$。\n- **测试 B：** $a(x) = e^x$，$c(x) = 0$，$u_{\\text{ex}}(x) = \\sin(5x)$。\n- **测试 C：** $a(x) = 1 + x$，$c(x) = 2$，$u_{\\text{ex}}(x) = \\cos(3\\pi x)$。\n\n对于每个测试，我们求解 $N=64$ 和 $N=128$ 的系统，计算误差 $\\|e_{1/64}\\|_{\\infty}$ 和 $\\|e_{1/128}\\|_{\\infty}$，并找出观测阶 $p_{\\infty}$。对于测试 A，我们额外在 $x^\\star = 0.37$ 处使用来自 $N=64$ 和 $N=128$ 的解以及为测试 A 计算出的 $p_{\\infty}$ 执行理查森外推，并报告此外推值的绝对误差。\n\n最终输出由三个观测阶和一个外推误差组成，以四个浮点数的列表形式呈现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the three test cases specified in the problem, computes observed\n    orders of accuracy, performs Richardson extrapolation for Test A, and\n    prints the results in the specified format.\n    \"\"\"\n\n    # --- Test Case A: Smooth variable coefficients, Dirichlet-Dirichlet ---\n    def get_test_A():\n        case = {\n            'a': lambda x: 2 + np.sin(3*x),\n            'a_prime': lambda x: 3 * np.cos(3*x),\n            'c': lambda x: 1 + x,\n            'u_ex': lambda x: np.exp(x) * np.sin(2*np.pi*x),\n            'u_ex_prime': lambda x: np.exp(x) * (np.sin(2*np.pi*x) + 2*np.pi*np.cos(2*np.pi*x)),\n            'u_ex_double_prime': lambda x: np.exp(x) * ((1 - 4*np.pi**2)*np.sin(2*np.pi*x) + 4*np.pi*np.cos(2*np.pi*x)),\n            'bc_type': ('dirichlet', 'dirichlet'),\n        }\n        case['f'] = lambda x: -(case['a'](x)*case['u_ex_double_prime'](x) + case['a_prime'](x)*case['u_ex_prime'](x)) + case['c'](x)*case['u_ex'](x)\n        case['bc_left_val'] = case['u_ex'](0.0)\n        case['bc_right_val'] = case['u_ex'](1.0)\n        return case\n\n    # --- Test Case B: Diffusion-dominated, Dirichlet-Dirichlet ---\n    def get_test_B():\n        case = {\n            'a': lambda x: np.exp(x),\n            'a_prime': lambda x: np.exp(x),\n            'c': lambda x: 0.0,\n            'u_ex': lambda x: np.sin(5*x),\n            'u_ex_prime': lambda x: 5 * np.cos(5*x),\n            'u_ex_double_prime': lambda x: -25 * np.sin(5*x),\n            'bc_type': ('dirichlet', 'dirichlet'),\n        }\n        case['f'] = lambda x: -(case['a'](x)*case['u_ex_double_prime'](x) + case['a_prime'](x)*case['u_ex_prime'](x)) + case['c'](x)*case['u_ex'](x)\n        case['bc_left_val'] = case['u_ex'](0.0)\n        case['bc_right_val'] = case['u_ex'](1.0)\n        return case\n\n    # --- Test Case C: Variable diffusion and reaction, Robin-Dirichlet ---\n    def get_test_C():\n        alpha, beta = 1.0, 1.0\n        case = {\n            'a': lambda x: 1 + x,\n            'a_prime': lambda x: 1.0,\n            'c': lambda x: 2.0,\n            'u_ex': lambda x: np.cos(3*np.pi*x),\n            'u_ex_prime': lambda x: -3 * np.pi * np.sin(3*np.pi*x),\n            'u_ex_double_prime': lambda x: -9 * np.pi**2 * np.cos(3*np.pi*x),\n            'bc_type': ('robin', 'dirichlet'),\n            'robin_params': (alpha, beta)\n        }\n        case['f'] = lambda x: -(case['a'](x)*case['u_ex_double_prime'](x) + case['a_prime'](x)*case['u_ex_prime'](x)) + case['c'](x)*case['u_ex'](x)\n        gamma = alpha * case['u_ex'](0.0) + beta * case['u_ex_prime'](0.0)\n        case['bc_left_val'] = gamma\n        case['bc_right_val'] = case['u_ex'](1.0)\n        return case\n\n    test_cases = [get_test_A(), get_test_B(), get_test_C()]\n    results = []\n\n    for i, case in enumerate(test_cases):\n        # Solve for N=64\n        u_h, x_h = solve_bvp(64, case)\n        u_ex_h = case['u_ex'](x_h)\n        err_h = np.linalg.norm(u_h - u_ex_h, np.inf)\n        \n        # Solve for N=128\n        u_h_2, x_h_2 = solve_bvp(128, case)\n        u_ex_h_2 = case['u_ex'](x_h_2)\n        err_h_2 = np.linalg.norm(u_h_2 - u_ex_h_2, np.inf)\n        \n        # Compute observed order\n        p_inf = np.log2(err_h / err_h_2)\n        results.append(p_inf)\n        \n        # Perform Richardson Extrapolation for Test A\n        if i == 0:\n            x_star = 0.37\n            \n            # Interpolate for N=64\n            h = 1.0/64\n            j = int(x_star / h)\n            U_h_star = u_h[j] + (u_h[j+1] - u_h[j]) * (x_star - x_h[j]) / h\n            \n            # Interpolate for N=128\n            h_2 = 1.0/128\n            j_2 = int(x_star / h_2)\n            U_h_2_star = u_h_2[j_2] + (u_h_2[j_2+1] - u_h_2[j_2]) * (x_star - x_h_2[j_2]) / h_2\n            \n            # Extrapolate\n            U_RE = (2**p_inf * U_h_2_star - U_h_star) / (2**p_inf - 1)\n            \n            # Compute error\n            u_ex_star = case['u_ex'](x_star)\n            err_RE = np.abs(U_RE - u_ex_star)\n            \n            # Store results, but need to append the error at the end\n            extrap_error = err_RE\n\n    # Reorder results to match output format\n    final_results = [results[0], results[1], results[2], extrap_error]\n    print(f\"[{','.join(map(str, final_results))}]\")\n\n\ndef solve_bvp(N, case):\n    \"\"\"\n    General solver for the 1D BVP.\n    Assembles and solves the linear system based on the boundary condition types.\n    \"\"\"\n    h = 1.0 / N\n    x = np.linspace(0, 1, N + 1)\n    \n    a_func = case['a']\n    c_func = case['c']\n    f_func = case['f']\n    bc_type = case['bc_type']\n    \n    if bc_type == ('dirichlet', 'dirichlet'):\n        # --- Dirichlet-Dirichlet System Assembly ---\n        # Unknowns are u_1, ..., u_{N-1}\n        num_unknowns = N - 1\n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n        \n        u0 = case['bc_left_val']\n        uN = case['bc_right_val']\n\n        for i in range(1, N):\n            idx = i - 1 # Matrix index\n            \n            x_i = x[i]\n            x_imhalf = x_i - h/2\n            x_iphalf = x_i + h/2\n            \n            a_imhalf = a_func(x_imhalf)\n            a_iphalf = a_func(x_iphalf)\n            \n            diag_val = a_iphalf + a_imhalf + h**2 * c_func(x_i)\n            \n            A[idx, idx] = diag_val\n            if i > 1:\n                A[idx, idx - 1] = -a_imhalf\n            if i  N - 1:\n                A[idx, idx + 1] = -a_iphalf\n            \n            b[idx] = h**2 * f_func(x_i)\n            \n            # Boundary contributions to RHS\n            if i == 1:\n                b[idx] += a_imhalf * u0\n            if i == N - 1:\n                b[idx] += a_iphalf * uN\n        \n        u_interior = np.linalg.solve(A, b)\n        u_full = np.concatenate(([u0], u_interior, [uN]))\n\n    elif bc_type == ('robin', 'dirichlet'):\n        # --- Robin-Dirichlet System Assembly ---\n        # Unknowns are u_0, ..., u_{N-1}\n        num_unknowns = N\n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n        \n        alpha, beta = case['robin_params']\n        gamma = case['bc_left_val']\n        uN = case['bc_right_val']\n        \n        # Row 0: Robin condition at x=0\n        A[0, 0] = 2*h*alpha - 3*beta\n        A[0, 1] = 4*beta\n        A[0, 2] = -beta\n        b[0] = 2*h*gamma\n        \n        # Rows 1 to N-1: Interior finite difference equations\n        for i in range(1, N):\n            x_i = x[i]\n            x_imhalf = x_i - h/2\n            x_iphalf = x_i + h/2\n            \n            a_imhalf = a_func(x_imhalf)\n            a_iphalf = a_func(x_iphalf)\n            \n            diag_val = a_iphalf + a_imhalf + h**2 * c_func(x_i)\n            \n            A[i, i] = diag_val\n            A[i, i - 1] = -a_imhalf\n            if i  N - 1:\n                A[i, i + 1] = -a_iphalf\n                \n            b[i] = h**2 * f_func(x_i)\n            \n            # Boundary contribution to RHS for last equation\n            if i == N - 1:\n                b[i] += a_iphalf * uN\n\n        u_solved = np.linalg.solve(A, b)\n        u_full = np.concatenate((u_solved, [uN]))\n    else:\n        raise ValueError(\"Unsupported boundary condition configuration.\")\n\n    return u_full, x\n\nsolve()\n```"
        },
        {
            "introduction": "许多物理系统涉及不同材料间的界面，这导致偏微分方程中出现不连续的系数。一个朴素的有限差分格式在这种界面处可能会产生巨大的、非物理的误差。本实践将指导你推导并实现一种使用调和平均的稳健格式，它能正确地捕捉通量的连续性，从而确保解的稳定性和准确性。",
            "id": "3392861",
            "problem": "考虑区间 $[0,1]$ 上的具有齐次狄利克雷边界条件的一维椭圆边值问题，\n$$\n-(a(x)\\,u'(x))' + c(x)\\,u(x) = f(x),\\qquad u(0)=0,\\quad u(1)=0,\n$$\n其中 $a(x)0$ 是扩散系数，$c(x)\\ge 0$ 是反应系数，$f(x)$ 是给定的源项。目标是构建一个保守、对称且 $L^2$ 稳定的有限差分离散格式，该格式在 $a(x)$ 出现剧烈跳跃时仍保持鲁棒性。您必须使用由调和平均定义的界面系数来构建离散通量，并将其性能与算术平均在 $a(x)$ 剧烈变化问题上的性能进行比较。\n\n仅从基本定义（通量的守恒性和相容性、离散双线性形式的对称性和正定性）出发，推导一个在具有 $m$ 个网格段的均匀网格（因此网格尺寸为 $h=1/m$，网格点为 $x_j=jh$，其中 $j=0,1,\\dots,m$）上的二阶保守有限差分格式。未知量是内部节点值 $u_j\\approx u(x_j)$，其中 $j=1,\\dots,m-1$。对于每个内部节点 $j$，使用以下方法构建跨越界面 $x_{j\\pm 1/2}$ 的离散通量：\n- 调和平均 $H(a_j,a_{j+1})=\\dfrac{2\\,a_j\\,a_{j+1}}{a_j+a_{j+1}}$，以及\n- 算术平均 $A(a_j,a_{j+1})=\\dfrac{a_j+a_{j+1}}{2}$，\n其中 $a_j:=a(x_j)$。\n\n待使用的测试问题必须具有以下形式：\n- 定义域 $[0,1]$；\n- 齐次狄利克雷边界条件 $u(0)=u(1)=0$；\n- 反应系数 $c(x)=0$；\n- 源项 $f(x)=1$（应根据未知量 $u$ 的单位进行解释；由于这是一个纯数学问题陈述，请勿附加物理单位）；\n- 扩散系数 $a(x)$ 是一个在 $x=0.5$ 处有剧烈跳跃的分段常数，\n$$\na(x) =\n\\begin{cases}\n1,  x  0.5, \\\\\n\\alpha,  x \\ge 0.5,\n\\end{cases}\n$$\n其中 $\\alpha0$ 是一个控制跳跃大小的参数。\n\n您的推导必须论证为什么界面处的调和平均会产生一个 $L^2$ 稳定的离散算子，并且必须解释对称性和正定性（矫顽性）对于所得线性系统意味着什么。推导过程不能使用最终离散算子的简便公式；它必须从保守通量平衡和界面系数的定义出发。\n\n实现两种离散格式（调和平均和算术平均），并对每种格式，在具有 $m=200$ 个网格段（因此 $h=1/200$）的均匀网格上求解所得的线性系统。为了进行误差评估，请使用通过分段求解问题并保证 $u$ 的连续性以及通量 $a\\,u'$ 在 $x=0.5$ 处的连续性而获得的精确解。对调和平均和算术平均两种方法，计算离散 $L^2$ 误差\n$$\nE = \\left(h\\,\\sum_{j=1}^{m-1} \\left(u_j - u(x_j)\\right)^2\\right)^{1/2}。\n$$\n\n此外，为了定量地验证 $L^2$ 稳定性和对称性，请为每种平均策略计算离散算子的最小特征值，并报告其是否严格为正，这表示矩阵是对称正定的（SPD）。您还必须报告每个测试用例的误差比 $E_A/E_H$。\n\n测试套件：\n- 用例 1：$\\alpha=1$（无跳跃）。\n- 用例 2：$\\alpha=10^{-3}$（右侧扩散极小）。\n- 用例 3：$\\alpha=10^{3}$（右侧扩散极大）。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个用例，按顺序输出以下五个量：\n- $E_H$：调和平均的 $L^2$ 误差（浮点数），\n- $E_A$：算术平均的 $L^2$ 误差（浮点数），\n- $\\mathrm{SPD}_H$：一个布尔值，指示调和平均矩阵是否为 SPD（如果其最小特征值严格为正，则为 true），\n- $\\mathrm{SPD}_A$：一个布尔值，指示算术平均矩阵是否为 SPD，\n- $R$：误差比 $E_A/E_H$（浮点数）。\n\n因此，最终输出应将所有三个用例的结果汇总到一个长度为 15 的单个列表中，排序如下：\n$$\n[E_H^{(1)},E_A^{(1)},\\mathrm{SPD}_H^{(1)},\\mathrm{SPD}_A^{(1)},R^{(1)},E_H^{(2)},E_A^{(2)},\\mathrm{SPD}_H^{(2)},\\mathrm{SPD}_A^{(2)},R^{(2)},E_H^{(3)},E_A^{(3)},\\mathrm{SPD}_H^{(3)},\\mathrm{SPD}_A^{(3)},R^{(3)}].\n$$",
            "solution": "该问题要求对一个具有不连续扩散系数的一维椭圆边值问题，推导、实现和比较两种有限差分格式。在思考过程中详细说明的验证过程，确认了该问题在科学上是合理的、适定的和完整的。我们现在开始解答。\n\n### 保守有限差分格式的推导\n\n我们从区间 $[0,1]$ 上的给定一维椭圆边值问题开始：\n$$\n-(a(x)\\,u'(x))' + c(x)\\,u(x) = f(x), \\quad u(0)=0, \\quad u(1)=0\n$$\n此处，$a(x)0$ 是扩散系数，$c(x)\\ge 0$ 是反应系数，$f(x)$ 是源项。\n\n我们使用一个有 $m$ 个网格段的均匀网格对定义域 $[0,1]$ 进行离散化，得到网格尺寸 $h=1/m$。网格点为 $x_j = jh$，其中 $j=0, 1, \\dots, m$。我们在内部网格点上求解数值解，记为 $u_j \\approx u(x_j)$，其中 $j=1, \\dots, m-1$。\n\n为了推导保守格式，我们对微分方程在以每个内部节点 $x_j$ 为中心的控制体积 $V_j = [x_{j-1/2}, x_{j+1/2}]$ 上进行积分。该体积的宽度为 $h=x_{j+1/2} - x_{j-1/2}$。\n$$\n\\int_{x_{j-1/2}}^{x_{j+1/2}} \\left( -(a(x)\\,u'(x))' + c(x)\\,u(x) \\right) dx = \\int_{x_{j-1/2}}^{x_{j+1/2}} f(x) dx\n$$\n令 $F(x) = -a(x)u'(x)$ 表示物理通量。将微积分基本定理应用于第一项，我们得到跨越控制体积边界的净通量：\n$$\n\\left[ -a(x)u'(x) \\right]_{x_{j-1/2}}^{x_{j+1/2}} + \\int_{x_{j-1/2}}^{x_{j+1/2}} c(x)u(x) dx = \\int_{x_{j-1/2}}^{x_{j+1/2}} f(x) dx\n$$\n$$\nF(x_{j-1/2}) - F(x_{j+1/2}) + \\int_{x_{j-1/2}}^{x_{j+1/2}} c(x)u(x) dx = \\int_{x_{j-1/2}}^{x_{j+1/2}} f(x) dx\n$$\n现在我们对每一项进行近似。积分项使用中点法则进行近似：\n$$\n\\int_{x_{j-1/2}}^{x_{j+1/2}} c(x)u(x) dx \\approx h c(x_j)u(x_j) = h c_j u_j\n$$\n$$\n\\int_{x_{j-1/2}}^{x_{j+1/2}} f(x) dx \\approx h f(x_j) = h f_j\n$$\n单元界面 $x_{j\\pm 1/2}$ 处的通量使用导数的中心差分进行近似：\n$$\nF_{j+1/2} = F(x_{j+1/2}) \\approx -a(x_{j+1/2}) \\frac{u(x_{j+1}) - u(x_j)}{h} \\approx -a_{j+1/2} \\frac{u_{j+1} - u_j}{h}\n$$\n$$\nF_{j-1/2} = F(x_{j-1/2}) \\approx -a(x_{j-1/2}) \\frac{u(x_j) - u(x_{j-1})}{h} \\approx -a_{j-1/2} \\frac{u_j - u_{j-1}}{h}\n$$\n项 $a_{j\\pm 1/2}$ 表示界面处的有效扩散系数。当 $a(x)$ 变化时，其定义至关重要。将这些近似代入积分后的方程，得到节点 $j$ 处的离散守恒律：\n$$\n-a_{j-1/2} \\frac{u_j - u_{j-1}}{h} - \\left(-a_{j+1/2} \\frac{u_{j+1} - u_j}{h}\\right) + h c_j u_j = h f_j\n$$\n两边同除以 $h$ 并整理各项，我们得到每个内部节点 $j=1, \\dots, m-1$ 的有限差分方程：\n$$\n\\frac{1}{h^2} \\left[ -a_{j-1/2}u_{j-1} + (a_{j-1/2} + a_{j+1/2})u_j - a_{j+1/2}u_{j+1} \\right] + c_j u_j = f_j\n$$\n这组 $m-1$ 个线性方程，连同边界条件 $u_0=0$ 和 $u_m=0$，构成了一个线性系统 $K\\mathbf{u} = \\mathbf{f}$。\n\n### 调和平均的合理性论证\n\n格式的精度取决于界面系数 $a_{j+1/2}$ 的选择。连续问题的一个关键物理原理是通量 $F(x) = -a(x)u'(x)$ 的连续性。对于在界面（例如 $x_{j+1/2}$）处有跳跃的分段常数 $a(x)$，这个条件必须被精确地捕捉。假设通量在区间 $[x_j, x_{j+1}]$ 上近似为常数，即 $-a(x)u'(x) \\approx F_{j+1/2}$。那么 $u'(x) \\approx -F_{j+1/2}/a(x)$。从 $x_j$ 到 $x_{j+1}$ 积分：\n$$\nu(x_{j+1}) - u(x_j) = \\int_{x_j}^{x_{j+1}} u'(x) dx \\approx -F_{j+1/2} \\int_{x_j}^{x_{j+1}} \\frac{dx}{a(x)}\n$$\n这意味着一个精确的数值通量应该满足：\n$$\nF_{j+1/2} \\approx -\\frac{u_{j+1} - u_j}{\\int_{x_j}^{x_{j+1}} \\frac{dx}{a(x)}}\n$$\n将此与我们的离散通量定义 $F_{j+1/2} = -a_{j+1/2} \\frac{u_{j+1}-u_j}{h}$ 进行比较，我们确定物理上正确的有效扩散系数为：\n$$\na_{j+1/2} = \\frac{h}{\\int_{x_j}^{x_{j+1}} \\frac{dx}{a(x)}}\n$$\n这是 $a(x)$ 在该区间上的积分形式的调和平均。如果我们假设 $a(x)$ 是分段常数，且跳跃点恰好在界面 $x_{j+1/2}$ 处，其在 $[x_j, x_{j+1/2}]$ 上取值为 $a_j=a(x_j)$，在 $[x_{j+1/2}, x_{j+1}]$ 上取值为 $a_{j+1}=a(x_{j+1})$，则该积分变为：\n$$\n\\int_{x_j}^{x_{j+1}} \\frac{dx}{a(x)} = \\frac{h/2}{a_j} + \\frac{h/2}{a_{j+1}} = \\frac{h}{2}\\left(\\frac{1}{a_j} + \\frac{1}{a_{j+1}}\\right)\n$$\n将此代回，得到界面系数：\n$$\na_{j+1/2} = \\frac{h}{\\frac{h}{2}\\left(\\frac{a_j+a_{j+1}}{a_j a_{j+1}}\\right)} = \\frac{2 a_j a_{j+1}}{a_j+a_{j+1}}\n$$\n这正是调和平均 $H(a_j, a_{j+1})$。该推导表明，使用调和平均作为界面系数能正确地模拟分段常数系数的连续通量条件。而算术平均 $A(a_j, a_{j+1}) = (a_j+a_{j+1})/2$ 不具备此性质，并且已知会在剧烈跳跃处产生大的误差。\n\n### 矩阵性质：对称性与正定性（$L^2$ 稳定性）\n\n该方程组可以写成 $K\\mathbf{u}=\\mathbf{f}$ 的形式，其中 $\\mathbf{u}=[u_1, \\dots, u_{m-1}]^T$。矩阵 $K$ 是三对角的。第 $i$ 行（表示未知数 $u_i$）和第 $j$ 列的元素记为 $K_{ij}$。对于 $i=1, \\dots, m-1$：\n- 主对角线：$K_{ii} = \\frac{1}{h^2}(a_{i-1/2} + a_{i+1/2}) + c_i$\n- 次对角线：$K_{i, i-1} = -\\frac{1}{h^2}a_{i-1/2}$ 和 $K_{i, i+1} = -\\frac{1}{h^2}a_{i+1/2}$\n\n**对称性**：矩阵 $K$ 是对称的，因为 $K_{i,i+1} = -\\frac{1}{h^2}a_{i+1/2}$ 且 $K_{i+1,i} = -\\frac{1}{h^2}a_{(i+1)-1/2} = -\\frac{1}{h^2}a_{i+1/2}$，所以 $K_{i,i+1}=K_{i+1,i}$。这对 $a_{i+1/2}$ 的任何定义都成立。\n\n**正定性**：如果对于任何非零向量 $\\mathbf{v}$，二次型 $\\mathbf{v}^T K \\mathbf{v}  0$ 都成立，则对称矩阵是正定的。此性质确保矩阵是可逆的，并意味着数值格式的稳定性。令 $\\mathbf{u}$ 为节点值向量，且 $u_0=u_m=0$。二次型为：\n$$\n\\mathbf{u}^T K \\mathbf{u} = \\sum_{j=1}^{m-1} u_j \\left( \\frac{1}{h^2} \\left[ -a_{j-1/2}u_{j-1} + (a_{j-1/2} + a_{j+1/2})u_j - a_{j+1/2}u_{j+1} \\right] + c_j u_j \\right)\n$$\n通过分部求和法，这可以被重新整理为离散“能量”：\n$$\n\\mathbf{u}^T K \\mathbf{u} = \\frac{1}{h^2} \\sum_{j=0}^{m-1} a_{j+1/2} (u_{j+1}-u_j)^2 + \\sum_{j=1}^{m-1} c_j u_j^2\n$$\n由于 $c(x) \\ge 0$，第二项是非负的。为了使第一项为正，我们要求 $a_{j+1/2}  0$。由于 $a(x)0$，正值的调和平均和算术平均都是正的。和式 $\\sum_{j=0}^{m-1} a_{j+1/2} (u_{j+1}-u_j)^2$ 为零当且仅当对所有 $j$ 都有 $u_{j+1}-u_j=0$，这意味着 $u_0=u_1=\\dots=u_m$。边界条件 $u_0=0$ 迫使所有 $u_j=0$，即 $\\mathbf{u}=\\mathbf{0}$。因此，对于任何非零向量 $\\mathbf{u}$，我们有 $\\mathbf{u}^T K \\mathbf{u}  0$。两种格式都产生一个对称正定（SPD）矩阵，这保证了唯一解的存在并提供了 $L^2$ 稳定性。一个 SPD 矩阵的最小特征值是严格为正的。\n\n### 测试问题的精确解\n\n测试问题为 $-(a(x)u'(x))' = 1$，其中 $u(0)=u(1)=0$，$c(x)=0$ 且 $a(x)$ 定义如下：\n$$\na(x) = \\begin{cases} 1,  x  0.5 \\\\ \\alpha,  x \\ge 0.5 \\end{cases}\n$$\n令 $x^*=0.5$。我们分段求解该常微分方程（ODE）。\n对于 $x \\in [0, x^*)$：$-u_1''(x)=1 \\implies u_1(x) = -x^2/2 + C_1 x + C_2$。\n对于 $x \\in (x^*, 1]$：$-\\alpha u_2''(x)=1 \\implies u_2(x) = -x^2/(2\\alpha) + C_3 x + C_4$。\n\n这四个未知常数由四个条件确定：\n1. 边界条件 $u_1(0)=0 \\implies C_2=0$。\n2. 边界条件 $u_2(1)=0 \\implies -1/(2\\alpha) + C_3 + C_4 = 0$。\n3. 解的连续性 $u_1(x^*) = u_2(x^*)$。\n4. 通量的连续性 $1 \\cdot u_1'(x^*) = \\alpha \\cdot u_2'(x^*)$。\n\n根据通量连续性，我们得到 $-x^*+C_1 = \\alpha(-x^*/\\alpha+C_3)$，化简为 $C_1 = \\alpha C_3$。\n求解关于 $C_1, C_3, C_4$ 的线性方程组（其中 $x^*=0.5$），可得：\n$$\nC_1 = \\frac{\\alpha+3}{4(\\alpha+1)}, \\quad C_3 = \\frac{\\alpha+3}{4\\alpha(\\alpha+1)}, \\quad C_4 = \\frac{\\alpha-1}{4\\alpha(\\alpha+1)}\n$$\n因此，精确解为：\n$$\nu(x) =\n\\begin{cases}\n-\\dfrac{x^2}{2} + \\dfrac{\\alpha+3}{4(\\alpha+1)}\\,x,  x  0.5, \\\\\n-\\dfrac{x^2}{2\\alpha} + \\dfrac{\\alpha+3}{4\\alpha(\\alpha+1)}\\,x + \\dfrac{\\alpha-1}{4\\alpha(\\alpha+1)},  x \\ge 0.5,\n\\end{cases}\n$$\n该解用于评估数值格式的精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded, eigvalsh_tridiagonal\n\ndef build_and_solve(m, alpha, averaging_method):\n    \"\"\"\n    Builds and solves the finite difference system for a given averaging method.\n\n    Args:\n        m (int): Number of grid segments.\n        alpha (float): Jump parameter for the diffusion coefficient.\n        averaging_method (str): 'harmonic' or 'arithmetic'.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The numerical solution vector at interior nodes.\n            - bool: True if the resulting matrix is Symmetric Positive Definite.\n    \"\"\"\n    h = 1.0 / m\n    N = m - 1  # Number of interior unknowns\n\n    # Define diffusion coefficient a(x) at grid points x_j\n    a_vals = np.ones(m + 1)\n    jump_index = m // 2\n    a_vals[jump_index:] = alpha\n\n    # Construct interface coefficients a_{j+1/2}\n    a_half = np.zeros(m)  # a_half[j] corresponds to a_{j+1/2}\n    for j in range(m):\n        a_left = a_vals[j]\n        a_right = a_vals[j+1]\n        \n        if averaging_method == 'harmonic':\n            if a_left + a_right == 0.0:\n                 a_half[j] = 0.0\n            else:\n                 a_half[j] = 2.0 * a_left * a_right / (a_left + a_right)\n        elif averaging_method == 'arithmetic':\n            a_half[j] = 0.5 * (a_left + a_right)\n        else:\n            raise ValueError(\"Unknown averaging method\")\n\n    # Construct the tridiagonal matrix A such that A*u = h^2 * f\n    # The matrix K in the derivation is A/h^2.\n    # d: main diagonal, e: off-diagonal (for a symmetric tridiagonal matrix)\n    # The matrix size is N x N, where N = m-1.\n    # The i-th row (0-indexed) corresponds to unknown u_{i+1}.\n    # d[i] = a_{i+1/2} + a_{i+3/2}\n    # e[i] = -a_{i+3/2}\n    d = a_half[:-1] + a_half[1:]  # Main diagonal, size N\n    e = -a_half[1:-1]            # Off-diagonal, size N-1\n\n    # Right-hand side vector\n    b = h**2 * np.ones(N)\n    \n    # Use scipy's efficient banded solver.\n    # The matrix must be in a specific format for solve_banded.\n    # For a symmetric tridiagonal matrix (l=1, u=1), shape is (3, N)\n    ab = np.zeros((3, N))\n    ab[0, 1:] = e   # Super-diagonal\n    ab[1, :] = d    # Main diagonal\n    ab[2, :-1] = e  # Sub-diagonal\n    \n    u_num = solve_banded((1, 1), ab, b)\n    \n    # Compute the smallest eigenvalue to check for SPD property.\n    # eigvalsh_tridiagonal is efficient for this.\n    # A matrix is SPD if and only if all its eigenvalues are strictly positive.\n    min_eig = eigvalsh_tridiagonal(d, e, select='i', select_range=(0, 0))[0]\n    is_spd = min_eig > 0\n\n    return u_num, is_spd\n\ndef exact_solution(x_vals, alpha):\n    \"\"\"\n    Computes the exact solution of the BVP for a given alpha.\n    \"\"\"\n    # Integration constants from the derivation\n    c1 = (alpha + 3.0) / (4.0 * (alpha + 1.0))\n    c3 = (alpha + 3.0) / (4.0 * alpha * (alpha + 1.0))\n    c4 = (alpha - 1.0) / (4.0 * alpha * (alpha + 1.0))\n\n    sol = np.zeros_like(x_vals, dtype=float)\n    mask_left = x_vals  0.5\n    \n    # Function for x  0.5\n    sol[mask_left] = -0.5 * x_vals[mask_left]**2 + c1 * x_vals[mask_left]\n    # Function for x >= 0.5\n    sol[~mask_left] = -0.5 * x_vals[~mask_left]**2 / alpha + c3 * x_vals[~mask_left] + c4\n    \n    return sol\n\ndef compute_l2_error(h, u_num, u_exact_vals):\n    \"\"\"\n    Computes the discrete L2 error.\n    \"\"\"\n    return np.sqrt(h * np.sum((u_num - u_exact_vals)**2))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        1.0,        # Case 1: alpha = 1 (no jump)\n        1e-3,       # Case 2: alpha = 10^-3\n        1e3,        # Case 3: alpha = 10^3\n    ]\n\n    results = []\n    m = 200\n    h = 1.0 / m\n    x_interior = np.linspace(0, 1, m + 1)[1:-1]\n    \n    for alpha in test_cases:\n        # Evaluate exact solution at interior grid points\n        u_exact_vals = exact_solution(x_interior, alpha)\n\n        # Harmonic averaging solution\n        u_h, spd_h = build_and_solve(m, alpha, 'harmonic')\n        E_H = compute_l2_error(h, u_h, u_exact_vals)\n\n        # Arithmetic averaging solution\n        u_a, spd_a = build_and_solve(m, alpha, 'arithmetic')\n        E_A = compute_l2_error(h, u_a, u_exact_vals)\n        \n        # Calculate the error ratio\n        if E_H == 0:\n            ratio = np.inf if E_A > 0 else 1.0\n        else:\n            ratio = E_A / E_H\n        \n        results.extend([\n            E_H,\n            E_A,\n            str(spd_h).lower(),\n            str(spd_a).lower(),\n            ratio\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "除了求解正问题，数值模型也是通过反演问题来解释实验数据的强大工具。本练习介绍了参数辨识的基本概念，其目标是根据对解的测量值来确定未知的模型系数。你将使用高效的离散伴随方法来推导参数到观测量映射的雅可比矩阵，这是数据同化和优化领域的基石。",
            "id": "3392786",
            "problem": "考虑区间 $[0,1]$ 上的一维椭圆偏微分方程 (PDE) $-(a(x) u^{\\prime}(x))^{\\prime} = f(x)$，其狄利克雷边界条件为 $u(0) = g_0$ 和 $u(1) = g_1$。假设扩散系数 $a(x)$ 是分段常数，具有两个未知参数：当 $x \\in [0,\\tfrac{1}{2}]$ 时，$a(x) = a_1$；当 $x \\in [\\tfrac{1}{2},1]$ 时，$a(x) = a_2$，其中 $a_1  0$ 且 $a_2  0$。\n\n使用带有节点 $x_0 = 0$、$x_1 = \\tfrac{1}{2}$ 和 $x_2 = 1$ 的均匀网格（网格尺寸 $h = \\tfrac{1}{2}$）对 PDE 进行离散化。在内部节点 $x_1$ 处，使用保守的二阶有限差分法 (FDM)，界面系数为 $a_{1/2} = a_1$ 和 $a_{3/2} = a_2$，以获得将 $u_1 \\approx u(x_1)$ 与边界数据 $u_0 = g_0$、$u_2 = g_1$ 以及单元中心的源项 $f_1 \\approx f(x_1)$ 联系起来的单一内部方程。\n\n你需要提出并分析一个反问题，在多次实验下，从内部状态 $u_1$ 的离散测量中恢复参数 $a_1$ 和 $a_2$。按以下步骤进行：\n\n1. 从 $-(a u^{\\prime})^{\\prime} = f$ 的保守差分近似开始，推导在 $x_1$ 处的离散正向方程。用 $a_1$、$a_2$、$u_0$、$u_1$、$u_2$ 和 $f_1$ 明确表示结果。\n\n2. 考虑两个独立的实验 $k \\in \\{1,2\\}$，它们具有不同的边界数据和源项：\n   - 实验 $k=1$：$g_0^{(1)} = 0$，$g_1^{(1)} = 1$，$f_1^{(1)} = 0$。\n   - 实验 $k=2$：$g_0^{(2)} = 1$，$g_1^{(2)} = 0$，$f_1^{(2)} = 1$。\n   对于每次实验，测量值为内部值 $y^{(k)}(a_1,a_2) = u_1^{(k)}(a_1,a_2)$。\n\n3. 对于给定的数据 $d^{(k)}$，定义两次实验的最小二乘目标函数 $\\Phi(a_1,a_2) = \\tfrac{1}{2} \\sum_{k=1}^{2} \\left( y^{(k)}(a_1,a_2) - d^{(k)} \\right)^2$。使用基于线性化离散正向映射的离散伴随公式，推导雅可比矩阵 $\\mathbf{J} \\in \\mathbb{R}^{2 \\times 2}$，其元素为 $J_{kj} = \\partial y^{(k)} / \\partial a_j$。你的推导必须从离散正向方程开始，并使用与输出泛函 $y^{(k)} = P u^{(k)}$ 对应的伴随方程，其中 $P$ 用于提取内部值。\n\n4. 使用你的雅可比矩阵，构建 $2 \\times 2$ 格拉姆矩阵 $\\mathbf{G} = \\mathbf{J}^{\\top} \\mathbf{J}$，并计算其行列式 $\\det(\\mathbf{G})$，作为上述两个实验中关于 $a_1$ 和 $a_2$ 的封闭形式解析表达式。\n\n5. 根据你的雅可比矩阵结构，简要讨论 $(a_1,a_2)$ 的可辨识性如何依赖于边界数据和源项的选择，并将给定的双实验设置与仅使用零源项的狄利克雷边界变化的特殊情况进行对比。\n\n你的最终答案必须是关于 $a_1$ 和 $a_2$ 的 $\\det(\\mathbf{G})$ 的解析表达式。不要包含单位。不要近似；需要一个精确的表达式。",
            "solution": "该问题被评估为有效，因为它具有科学依据、良定、客观，并包含严格求解所需的所有必要信息。我们按要求进行推导。\n\n一维椭圆边值问题由下式给出\n$$ -(a(x) u'(x))' = f(x) \\quad \\text{for } x \\in [0,1] $$\n带有狄利克雷边界条件 $u(0) = g_0$ 和 $u(1) = g_1$。系数 $a(x)$ 是分段常数：当 $x \\in [0, \\frac{1}{2}]$ 时，$a(x) = a_1$；当 $x \\in [\\frac{1}{2}, 1]$ 时，$a(x) = a_2$，其中 $a_1  0$ 且 $a_2  0$。\n\n我们使用一个带有节点 $x_0=0$、$x_1=\\frac{1}{2}$ 和 $x_2=1$ 的均匀网格。网格尺寸为 $h = x_{i+1} - x_i = \\frac{1}{2}$。在 $x_1 = \\frac{1}{2}$ 处有一个单一的内部节点。\n\n1. 离散正向方程的推导。\n在内部节点 $x_i$ 处的保守有限差分离散化由下式给出\n$$ -\\frac{1}{h} \\left( F_{i+1/2} - F_{i-1/2} \\right) = f_i $$\n其中 $F = -a(x)u'(x)$ 是通量。在单元面上的通量近似为 $F_{i \\pm 1/2} \\approx -a_{i \\pm 1/2} \\frac{u_{i \\pm 1} - u_i}{h}$。将此应用于内部节点 $x_1$ 可得：\n$$ -\\frac{1}{h} \\left( \\left( -a_{3/2} \\frac{u_2 - u_1}{h} \\right) - \\left( -a_{1/2} \\frac{u_1 - u_0}{h} \\right) \\right) = f_1 $$\n这可以整理为：\n$$ \\frac{1}{h^2} \\left( a_2(u_2-u_1) + a_1(u_0-u_1) \\right) = f_1 $$\n代入 $h=1/2$，$u_0=g_0$ 和 $u_2=g_1$，我们有：\n$$ 4 \\left( a_2(g_1 - u_1) + a_1(g_0 - u_1) \\right) = f_1 $$\n重新整理各项以求解 $u_1$：\n$$ 4(a_1 g_0 + a_2 g_1) - 4(a_1+a_2)u_1 = f_1 $$\n这给出了单个未知数 $u_1$ 的离散正向方程，求解 $u_1$ 可得：\n$$ u_1 = \\frac{4(a_1 g_0 + a_2 g_1) - f_1}{4(a_1 + a_2)} $$\n\n2. 两次实验的正向解。\n每次实验 $k$ 的测量值为 $y^{(k)}(a_1, a_2) = u_1^{(k)}(a_1, a_2)$。\n对于实验 $k=1$：$g_0^{(1)} = 0$，$g_1^{(1)} = 1$，$f_1^{(1)} = 0$。\n$$ y^{(1)}(a_1, a_2) = \\frac{4(a_1 \\cdot 0 + a_2 \\cdot 1) - 0}{4(a_1 + a_2)} = \\frac{4a_2}{4(a_1 + a_2)} = \\frac{a_2}{a_1 + a_2} $$\n对于实验 $k=2$：$g_0^{(2)} = 1$，$g_1^{(2)} = 0$，$f_1^{(2)} = 1$。\n$$ y^{(2)}(a_1, a_2) = \\frac{4(a_1 \\cdot 1 + a_2 \\cdot 0) - 1}{4(a_1 + a_2)} = \\frac{4a_1 - 1}{4(a_1 + a_2)} $$\n\n3. 通过离散伴随法推导雅可比矩阵。\n设参数向量为 $\\mathbf{a} = (a_1, a_2)^T$。对于每次实验，离散正向方程可以写成残差方程 $R(u_1, \\mathbf{a}) = 0$。对于具有数据 $(g_0, g_1, f_1)$ 的一般实验，即为：\n$$ R(u_1, a_1, a_2) = 4(a_1 + a_2) u_1 - 4(a_1 g_0 + a_2 g_1) + f_1 = 0 $$\n我们感兴趣的量（测量值）是状态的线性泛函，$y = P u_1 = u_1$。为了找到灵敏度 $\\frac{\\partial y}{\\partial a_j}$，伴随方法提供了一种高效的计算方式。伴随状态 $p$ 是伴随方程的解：\n$$ \\left( \\frac{\\partial R}{\\partial u_1} \\right)^* p = \\left( \\frac{\\partial y}{\\partial u_1} \\right)^* $$\n由于我们的状态 $u_1$ 和输出 $y$ 都是标量，这简化为 $\\frac{\\partial R}{\\partial u_1} p = \\frac{\\partial y}{\\partial u_1}$。\n我们有 $\\frac{\\partial R}{\\partial u_1} = 4(a_1 + a_2)$ 和 $\\frac{\\partial y}{\\partial u_1} = \\frac{\\partial u_1}{\\partial u_1} = 1$。\n伴随方程是 $4(a_1 + a_2) p = 1$，所以伴随状态为 $p = \\frac{1}{4(a_1 + a_2)}$。\n然后灵敏度由 $\\frac{\\partial y}{\\partial a_j} = - p \\frac{\\partial R}{\\partial a_j}$ 给出。我们计算 $R$ 对参数 $a_1$ 和 $a_2$ 的偏导数：\n$$ \\frac{\\partial R}{\\partial a_1} = 4u_1 - 4g_0 = 4(u_1 - g_0) $$\n$$ \\frac{\\partial R}{\\partial a_2} = 4u_1 - 4g_1 = 4(u_1 - g_1) $$\n所以，灵敏度为：\n$$ \\frac{\\partial y}{\\partial a_1} = -p \\cdot 4(u_1 - g_0) = -\\frac{1}{4(a_1+a_2)} \\cdot 4(u_1 - g_0) = -\\frac{u_1 - g_0}{a_1 + a_2} $$\n$$ \\frac{\\partial y}{\\partial a_2} = -p \\cdot 4(u_1 - g_1) = -\\frac{1}{4(a_1+a_2)} \\cdot 4(u_1 - g_1) = -\\frac{u_1 - g_1}{a_1 + a_2} $$\n雅可比矩阵 $\\mathbf{J}$ 的元素为 $J_{kj} = \\partial y^{(k)} / \\partial a_j$。\n对于实验 $k=1$：$u_1^{(1)} = \\frac{a_2}{a_1+a_2}$，$g_0^{(1)}=0$，$g_1^{(1)}=1$。\n$$ J_{11} = -\\frac{\\frac{a_2}{a_1+a_2} - 0}{a_1+a_2} = -\\frac{a_2}{(a_1+a_2)^2} $$\n$$ J_{12} = -\\frac{\\frac{a_2}{a_1+a_2} - 1}{a_1+a_2} = -\\frac{a_2 - (a_1+a_2)}{(a_1+a_2)^2} = -\\frac{-a_1}{(a_1+a_2)^2} = \\frac{a_1}{(a_1+a_2)^2} $$\n对于实验 $k=2$：$u_1^{(2)} = \\frac{4a_1-1}{4(a_1+a_2)}$，$g_0^{(2)}=1$，$g_1^{(2)}=0$。\n$$ J_{21} = -\\frac{\\frac{4a_1-1}{4(a_1+a_2)} - 1}{a_1+a_2} = -\\frac{4a_1-1 - 4(a_1+a_2)}{4(a_1+a_2)^2} = -\\frac{-1-4a_2}{4(a_1+a_2)^2} = \\frac{4a_2 + 1}{4(a_1+a_2)^2} $$\n$$ J_{22} = -\\frac{\\frac{4a_1-1}{4(a_1+a_2)} - 0}{a_1+a_2} = -\\frac{4a_1-1}{4(a_1+a_2)^2} $$\n雅可比矩阵是：\n$$ \\mathbf{J} = \\begin{pmatrix} -\\frac{a_2}{(a_1+a_2)^2}  \\frac{a_1}{(a_1+a_2)^2} \\\\ \\frac{4a_2+1}{4(a_1+a_2)^2}  -\\frac{4a_1-1}{4(a_1+a_2)^2} \\end{pmatrix} $$\n\n4. 格拉姆矩阵行列式的计算。\n格拉姆矩阵是 $\\mathbf{G} = \\mathbf{J}^T \\mathbf{J}$。其行列式为 $\\det(\\mathbf{G}) = \\det(\\mathbf{J}^T)\\det(\\mathbf{J}) = (\\det(\\mathbf{J}))^2$。我们计算 $\\mathbf{J}$ 的行列式：\n$$ \\det(\\mathbf{J}) = J_{11}J_{22} - J_{12}J_{21} $$\n$$ \\det(\\mathbf{J}) = \\left(-\\frac{a_2}{(a_1+a_2)^2}\\right) \\left(-\\frac{4a_1-1}{4(a_1+a_2)^2}\\right) - \\left(\\frac{a_1}{(a_1+a_2)^2}\\right) \\left(\\frac{4a_2+1}{4(a_1+a_2)^2}\\right) $$\n$$ \\det(\\mathbf{J}) = \\frac{1}{4(a_1+a_2)^4} \\left( a_2(4a_1-1) - a_1(4a_2+1) \\right) $$\n$$ \\det(\\mathbf{J}) = \\frac{1}{4(a_1+a_2)^4} \\left( 4a_1a_2 - a_2 - 4a_1a_2 - a_1 \\right) $$\n$$ \\det(\\mathbf{J}) = \\frac{-(a_1+a_2)}{4(a_1+a_2)^4} = -\\frac{1}{4(a_1+a_2)^3} $$\n因此，格拉姆矩阵的行列式为：\n$$ \\det(\\mathbf{G}) = (\\det(\\mathbf{J}))^2 = \\left( -\\frac{1}{4(a_1+a_2)^3} \\right)^2 = \\frac{1}{16(a_1+a_2)^6} $$\n\n5. 关于可辨识性的讨论。\n如果雅可比矩阵 $\\mathbf{J}$ 是满秩的，则参数 $(a_1, a_2)$ 是局部可辨识的，这等价于 $\\det(\\mathbf{J}) \\neq 0$ 或等价地 $\\det(\\mathbf{G})  0$。对于指定的两个实验，$\\det(\\mathbf{G}) = \\frac{1}{16(a_1+a_2)^6}$。因为问题陈述 $a_1  0$ 和 $a_2  0$，所以 $a_1+a_2  0$，因此 $\\det(\\mathbf{G})$ 是严格正的。这意味着 $\\mathbf{J}$ 的列是线性无关的，并且参数 $(a_1, a_2)$ 是局部可辨识的。\n\n将此与仅使用零源项实验的特殊情况进行对比，即 $f_1=0$。在这种情况下，具有边界数据 $(g_0, g_1)$ 的实验的正向解是 $y = \\frac{a_1 g_0 + a_2 g_1}{a_1 + a_2}$。灵敏度向量（雅可比矩阵的一行）可以计算为：\n$$ \\frac{\\partial y}{\\partial a_1} = \\frac{g_0(a_1+a_2) - (a_1g_0+a_2g_1)}{(a_1+a_2)^2} = \\frac{a_2(g_0-g_1)}{(a_1+a_2)^2} $$\n$$ \\frac{\\partial y}{\\partial a_2} = \\frac{g_1(a_1+a_2) - (a_1g_0+a_2g_1)}{(a_1+a_2)^2} = \\frac{a_1(g_1-g_0)}{(a_1+a_2)^2} $$\n灵敏度向量是 $(\\frac{\\partial y}{\\partial a_1}, \\frac{\\partial y}{\\partial a_2}) = \\frac{g_0-g_1}{(a_1+a_2)^2} (a_2, -a_1)$。\n如果我们进行两个这样的实验，一个使用数据 $(g_0^{(1)}, g_1^{(1)})$，另一个使用 $(g_0^{(2)}, g_1^{(2)})$，雅可比矩阵的两行将是：\n$$ \\text{第一行: } \\frac{g_0^{(1)}-g_1^{(1)}}{(a_1+a_2)^2} (a_2, -a_1) $$\n$$ \\text{第二行: } \\frac{g_0^{(2)}-g_1^{(2)}}{(a_1+a_2)^2} (a_2, -a_1) $$\n这两行互为标量倍数。因此，雅可比矩阵的秩为 $1$ (假设至少有一个 $g_0 \\neq g_1$)，其行列式为零。因此，$\\det(\\mathbf{G})=0$，并且参数 $(a_1, a_2)$ 是不可辨识的。从物理上讲，当 $f=0$ 时，测量值 $y = u_1$ 仅取决于比率 $a_1/a_2$，而不单独取决于 $a_1$ 和 $a_2$。包含一个带有非零源项的实验，如此问题设置中的实验 $k=2$，会在测量数据中引入不同的变化来源，使得灵敏度向量线性无关，从而能够辨识两个参数。",
            "answer": "$$\\boxed{\\frac{1}{16(a_1+a_2)^{6}}}$$"
        }
    ]
}