{
    "hands_on_practices": [
        {
            "introduction": "The Forward-Time Central-Space (FTCS) method is simple and intuitive, but its application is governed by a strict stability constraint. This first exercise serves as a powerful cautionary tale, demonstrating what happens when this constraint is ignored. By applying the FTCS update with a set of parameters that violate the monotonicity condition, you will observe firsthand how the numerical scheme can generate non-physical results, such as negative values from non-negative initial data . This hands-on calculation provides the essential motivation for why the stability ratio $r = \\frac{\\kappa k}{h^2} \\le \\frac{1}{2}$ is not merely a theoretical suggestion, but a practical necessity.",
            "id": "3395792",
            "problem": "Consider the one-dimensional heat equation (also called the diffusion equation) on a sufficiently large domain so that boundary influences are negligible over one time step, given by the partial differential equation\n$$\nu_{t}(x,t) \\;=\\; \\kappa\\,u_{xx}(x,t),\n$$\nwhere $\\kappa0$ is a constant diffusivity. The Forward-Time Central-Space (FTCS) method defines a finite difference scheme using forward differencing in time and central differencing in space on a uniform grid with spatial step size $h0$ and time step size $k0$. The classical monotonicity requirement for explicit schemes in this setting demands that the discrete update map be a convex combination of neighboring values. In practice, this imposes a condition that involves the dimensionless ratio $r=\\kappa k/h^{2}$.\n\nConstruct a counterexample demonstrating that when the FTCS update violates the monotonicity constraint, it can produce spurious negative values from nonnegative initial data in a single time step. To that end, take $\\kappa=1$, $h=1$, and $k=1$, and consider an initial condition that is nonnegative and compactly supported on the grid, specified by\n$$\nu_{i}^{0} \\;=\\;\n\\begin{cases}\n1,  i=1,\\\\\n0,  i\\neq 1,\n\\end{cases}\n$$\nwhere $i\\in\\mathbb{Z}$ indexes the spatial grid points and $u_{i}^{n}$ denotes the numerical approximation to $u$ at spatial index $i$ and time level $n$. Apply a single FTCS update at the central index $i=1$ to obtain $u_{1}^{1}$.\n\nCompute the value of $u_{1}^{1}$. Your final answer must be a single real number. No rounding is required and no physical units are to be reported. Explain your reasoning starting from fundamental principles and core definitions of the finite difference approximation of the heat equation, and articulate why this explicit calculation constitutes a counterexample to monotonicity when the constraint is violated.",
            "solution": "The problem requires us to compute the value of a numerical solution to the one-dimensional heat equation after one time step using the Forward-Time Central-Space (FTCS) method, with parameters chosen specifically to violate the scheme's monotonicity condition. We must then articulate why the result constitutes a counterexample.\n\nThe governing partial differential equation (PDE) is the heat equation:\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\kappa \\frac{\\partial^2 u}{\\partial x^2}(x,t)\n$$\nwhere $u(x,t)$ represents the quantity (e.g., temperature) at spatial position $x$ and time $t$, and $\\kappa  0$ is the constant diffusivity.\n\nThe FTCS method discretizes this PDE on a uniform grid where $x_i = i h$ and $t_n = n k$, with $h$ being the spatial step size and $k$ being the time step size. The numerical approximation to $u(x_i, t_n)$ is denoted by $u_i^n$.\n\nTo construct the FTCS scheme, we approximate the derivatives using finite differences:\n$1$. The time derivative $\\frac{\\partial u}{\\partial t}$ at $(x_i, t_n)$ is approximated by a first-order forward difference:\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{(x_i, t_n)} \\approx \\frac{u_i^{n+1} - u_i^n}{k}\n$$\n$2$. The spatial second derivative $\\frac{\\partial^2 u}{\\partial x^2}$ at $(x_i, t_n)$ is approximated by a second-order central difference:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i, t_n)} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}\n$$\nSubstituting these approximations into the heat equation yields the FTCS finite difference equation:\n$$\n\\frac{u_i^{n+1} - u_i^n}{k} = \\kappa \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}\n$$\nThis is an explicit scheme, as we can solve for the unknown value $u_i^{n+1}$ at the next time level in terms of known values at the current time level $n$:\n$$\nu_i^{n+1} = u_i^n + \\frac{\\kappa k}{h^2} (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\nLet's define the dimensionless diffusion number, or mesh ratio, as $r = \\frac{\\kappa k}{h^2}$. The update rule can be rewritten as:\n$$\nu_i^{n+1} = u_i^n + r(u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\nBy grouping terms corresponding to the spatial grid points at time level $n$, we get:\n$$\nu_i^{n+1} = r u_{i-1}^n + (1 - 2r) u_i^n + r u_{i+1}^n\n$$\nThe physical heat equation adheres to a maximum principle, which implies that for non-negative initial data, the solution remains non-negative for all future times. A numerical scheme is called monotone if it preserves this property. For the FTCS scheme, monotonicity is guaranteed if all the coefficients in the update rule for $u_i^{n+1}$ are non-negative. Since $\\kappa, k, h$ are all positive, $r  0$. The condition for monotonicity therefore reduces to requiring the coefficient of $u_i^n$ to be non-negative:\n$$\n1 - 2r \\ge 0 \\implies 2r \\le 1 \\implies r \\le \\frac{1}{2}\n$$\nThus, the monotonicity (and von Neumann stability) condition for the FTCS scheme is $r = \\frac{\\kappa k}{h^2} \\le \\frac{1}{2}$.\n\nThe problem specifies parameter values that are intended to violate this condition. The given values are:\n- Diffusivity: $\\kappa = 1$\n- Spatial step: $h = 1$\n- Time step: $k = 1$\n\nWith these values, the mesh ratio $r$ is:\n$$\nr = \\frac{\\kappa k}{h^2} = \\frac{1 \\cdot 1}{1^2} = 1\n$$\nSince $r=1$, the condition $r \\le \\frac{1}{2}$ is violated. We expect the scheme to exhibit non-physical behavior. The update rule for this specific choice of parameters becomes:\n$$\nu_i^{n+1} = (1) u_{i-1}^n + (1 - 2(1)) u_i^n + (1) u_{i+1}^n = u_{i-1}^n - u_i^n + u_{i+1}^n\n$$\nThe problem asks us to compute $u_1^1$, which is the value at spatial index $i=1$ after one time step ($n=0 \\to n=1$). Using the derived update rule with $i=1$ and $n=0$:\n$$\nu_1^1 = u_{1-1}^0 - u_1^0 + u_{1+1}^0 = u_0^0 - u_1^0 + u_2^0\n$$\nThe initial condition is given as a discrete delta function:\n$$\nu_i^0 =\n\\begin{cases}\n1,  i=1, \\\\\n0,  i\\neq 1.\n\\end{cases}\n$$\nFrom this initial condition, we have:\n- $u_1^0 = 1$\n- $u_0^0 = 0$ (since $0 \\neq 1$)\n- $u_2^0 = 0$ (since $2 \\neq 1$)\n\nSubstituting these values into the expression for $u_1^1$:\n$$\nu_1^1 = 0 - 1 + 0 = -1\n$$\nThis result constitutes a definitive counterexample. The initial data $u_i^0$ is non-negative everywhere on the grid. However, after a single time step, the numerical solution at grid point $i=1$ becomes $u_1^1 = -1$, which is negative. This is a physically impossible outcome for a diffusion process, which should only smooth out initial distributions and cannot create new minima or maxima. The generation of a negative value from non-negative initial data is a direct consequence of violating the monotonicity condition $r \\le 1/2$. The negative coefficient for $u_i^n$ in the update stencil when $r  1/2$ allows for this unphysical behavior.",
            "answer": "$$\n\\boxed{-1}\n$$"
        },
        {
            "introduction": "Having established the critical importance of the stability condition, we now move from a conceptual demonstration to a full-fledged implementation. This practice guides you through the process of writing a robust FTCS solver for the one-dimensional diffusion equation with Dirichlet boundary conditions . You will translate the discrete update rule into vectorized code, algorithmically enforce the stability constraint to select a proper time step, and validate your results against a known analytical solution to quantify the numerical error.",
            "id": "3395765",
            "problem": "Consider the one-dimensional diffusion (heat) equation on a finite interval, with fixed Dirichlet boundary conditions, defined by the partial differential equation $u_t = \\alpha\\,u_{xx}$ for $x \\in [0,L]$ and $t \\ge 0$, where $u(0,t) = 0$ and $u(L,t) = 0$. The Forward-Time Central-Space (FTCS) method is to be derived and implemented starting from first principles. You must design an algorithm that uses a contiguous one-dimensional memory layout for the spatial grid (including boundary nodes), vectorizes the spatial update over the interior grid points, and selects a time step that enforces the provable FTCS stability requirement for diffusion. The algorithm must verify its correctness by comparing the numerical solution against a known analytical solution for a family of initial data that are eigenfunctions of the Laplacian with Dirichlet boundary conditions. Your derivation must start from the governing equation $u_t = \\alpha\\,u_{xx}$ and the definition of a uniform spatial grid, and must not rely on shortcut formulas. You must explain why the stability restriction arises and how to enforce it algorithmically. No physical units are required; treat all quantities as non-dimensional.\n\nYou are to implement a complete program that:\n- Constructs a uniform grid with $N_x$ points over $[0,L]$, where the grid spacing is $\\Delta x = L/(N_x - 1)$.\n- Uses a contiguous one-dimensional array to store $u(x_i,t_n)$ at all grid points, including boundaries at $i = 0$ and $i = N_x - 1$.\n- Applies the FTCS scheme by a vectorized interior update over the slice of indices $i = 1,2,\\dots,N_x-2$ at each time step.\n- Selects the time step $\\Delta t$ to ensure the nondimensional FTCS ratio $r$ obeys the diffusion FTCS stability criterion $r \\le 1/2$.\n- Evolves the solution from $t=0$ to a specified final time $T$ by iterating the time-stepping update.\n- Uses the initial condition $u(x,0) = \\sin(n\\pi x)$, for either $n=1$ or $n=2$, which has the analytical solution $u(x,t) = e^{-\\alpha (n\\pi)^2 t}\\,\\sin(n\\pi x)$ under homogeneous Dirichlet boundary conditions.\n- Computes the discrete $L^2$ error at the final time by comparing the numerical solution to the analytical solution over the interior grid points as $\\|e\\|_2 \\approx \\sqrt{\\Delta x \\sum_{i=1}^{N_x-2} \\left(u_i^{N}-u(x_i,T)\\right)^2}$, where $u_i^{N}$ is the numerical approximation at the final time on grid index $i$.\n\nYour program must implement the following test suite, with parameters given as tuples $(\\alpha, L, N_x, T, \\Delta t_{\\text{nom}}, n)$:\n- Case $1$ (happy path): $(0.1,\\,1,\\,101,\\,0.05,\\,0.0002,\\,1)$\n- Case $2$ (stability boundary $r=1/2$ via selection): $(0.1,\\,1,\\,51,\\,0.05,\\,1.0,\\,2)$\n- Case $3$ (nominal $\\Delta t$ violates stability, enforce selection): $(1.0,\\,1,\\,21,\\,0.02,\\,0.01,\\,1)$\n- Case $4$ (edge case with minimal interior, $N_x=3$): $(0.5,\\,1,\\,3,\\,0.5,\\,1.0,\\,1)$\n\nFor each case, your program must:\n- Select $\\Delta t$ to enforce the FTCS stability condition $r \\le 1/2$,\n- Evolve the solution from $t=0$ to $t=T$ using FTCS with vectorized interior updates,\n- Compute the discrete $L^2$ error at time $T$ using the analytical solution with the same parameter $n$,\n- Report both the resulting discrete $L^2$ error and the actual $r$ used.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\text{error}_1, r_1, \\text{error}_2, r_2, \\text{error}_3, r_3, \\text{error}_4, r_4]$, where each $\\text{error}_k$ is a floating-point number and each $r_k$ is the floating-point value of the nondimensional FTCS ratio used in case $k$.\n\nAnswer all results without any physical units. Angles are not involved. Express all values as plain decimal numbers (no percentages).",
            "solution": "The problem is to derive and implement the Forward-Time Central-Space (FTCS) numerical method to solve the one-dimensional diffusion equation, also known as the heat equation. The solution must be validated against a known analytical solution, and the numerical stability of the scheme must be algorithmically enforced.\n\n### Step 1: Derivation of the FTCS Scheme\n\nThe governing partial differential equation (PDE) for one-dimensional diffusion is:\n$$\nu_t = \\alpha \\, u_{xx}\n$$\nwhere $u(x,t)$ is the quantity of interest (e.g., temperature) as a function of spatial position $x$ and time $t$, and $\\alpha$ is the constant thermal diffusivity. The problem is defined on a finite spatial domain $x \\in [0, L]$ with homogeneous Dirichlet boundary conditions:\n$$\nu(0, t) = 0 \\quad \\text{and} \\quad u(L, t) = 0 \\quad \\text{for all } t \\ge 0\n$$\n\nTo solve this PDE numerically, we discretize the continuous domain $(x, t)$ into a discrete grid. We define a uniform spatial grid with $N_x$ points, where the grid points are $x_i = i \\Delta x$ for $i = 0, 1, \\dots, N_x-1$. The spatial step size is $\\Delta x = L / (N_x - 1)$. Time is also discretized into steps $t_n = n \\Delta t$ for $n = 0, 1, 2, \\dots$, with a constant time step $\\Delta t$. We denote the numerical approximation of the solution at a grid point as $u_i^n \\approx u(x_i, t_n)$.\n\nThe FTCS method approximates the time and space derivatives using finite differences.\n- The time derivative $u_t$ at $(x_i, t_n)$ is approximated using a first-order accurate **forward difference** in time:\n$$\nu_t \\bigg|_{(x_i, t_n)} \\approx \\frac{u(x_i, t_{n+1}) - u(x_i, t_n)}{\\Delta t} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\n- The second spatial derivative $u_{xx}$ at $(x_i, t_n)$ is approximated using a second-order accurate **central difference** in space:\n$$\nu_{xx} \\bigg|_{(x_i, t_n)} \\approx \\frac{u(x_{i+1}, t_n) - 2u(x_i, t_n) + u(x_{i-1}, t_n)}{(\\Delta x)^2} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\n$$\n\nSubstituting these approximations into the governing PDE, we get the FTCS finite difference equation:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\left( \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2} \\right)\n$$\nThis equation is an explicit scheme because the unknown value at the new time step, $u_i^{n+1}$, can be calculated directly from known values at the current time step, $n$. To make the update rule clear, we solve for $u_i^{n+1}$:\n$$\nu_i^{n+1} = u_i^n + \\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\left( u_{i+1}^n - 2u_i^n + u_{i-1}^n \\right)\n$$\nIt is conventional to define the non-dimensional parameter $r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$, often called the FTCS ratio or Courant number for diffusion. The update rule simplifies to:\n$$\nu_i^{n+1} = u_i^n + r \\left( u_{i+1}^n - 2u_i^n + u_{i-1}^n \\right)\n$$\nThis update is applied to all interior grid points, i.e., for $i = 1, 2, \\dots, N_x-2$. The boundary points $u_0^{n+1}$ and $u_{N_x-1}^{n+1}$ are fixed by the Dirichlet boundary conditions to $0$.\n\n### Step 2: Numerical Stability\n\nThe FTCS scheme for the diffusion equation is only conditionally stable. An instability would cause small initial errors (like round-off errors) to grow exponentially, rendering the numerical solution meaningless. A von Neumann stability analysis reveals the stability constraint. We seek solutions of the form $u_i^n = G^n e^{j k x_i}$, where $G$ is the amplification factor per time step for a Fourier mode with wave number $k$, and $j = \\sqrt{-1}$. For a stable scheme, the magnitude of the amplification factor must not exceed unity for all possible wave numbers, i.e., $|G| \\le 1$.\n\nSubstituting this form into the FTCS update rule yields:\n$$\nG = 1 + r (e^{j k \\Delta x} - 2 + e^{-j k \\Delta x})\n$$\nUsing Euler's identity $e^{j\\theta} + e^{-j\\theta} = 2\\cos(\\theta)$, this becomes:\n$$\nG = 1 + 2r(\\cos(k \\Delta x) - 1)\n$$\nUsing the half-angle identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$, we obtain:\n$$\nG = 1 - 4r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\nThe stability condition $|G| \\le 1$ translates to $-1 \\le 1 - 4r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 1$.\n- The right-hand side, $1 - 4r \\sin^2(\\dots) \\le 1$, implies $-4r \\sin^2(\\dots) \\le 0$, which is always true since $r \\ge 0$ and $\\sin^2(\\dots) \\ge 0$.\n- The left-hand side, $-1 \\le 1 - 4r \\sin^2(\\dots)$, is the crucial constraint. It requires $4r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 2$, or $r \\le \\frac{1}{2 \\sin^2(k \\Delta x/2)}$.\nThis condition must hold for all wave numbers $k$. The most restrictive (worst-case) scenario occurs when $\\sin^2(k \\Delta x/2)$ is at its maximum value of $1$. This leads to the stability criterion:\n$$\nr = \\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\le \\frac{1}{2}\n$$\n\n### Step 3: Algorithmic Implementation\n\nThe algorithm is designed to enforce this stability condition and execute the FTCS scheme.\n\n1.  **Grid and Parameter Setup:** For given $\\alpha$, $L$, and $N_x$, compute the spatial step $\\Delta x = L/(N_x - 1)$.\n2.  **Time Step Selection:** To guarantee stability, the time step $\\Delta t$ must be chosen such that $r \\le 1/2$. The maximum allowed time step is $\\Delta t_{\\text{max}} = \\frac{1}{2}\\frac{(\\Delta x)^2}{\\alpha}$. The problem provides a nominal time step, $\\Delta t_{\\text{nom}}$. The algorithm must select a candidate time step, $\\Delta t_{\\text{cand}} = \\min(\\Delta t_{\\text{nom}}, \\Delta t_{\\text{max}})$, to satisfy both the user's preference (if stable) and the stability requirement. The total simulation time is $T$. To ensure the simulation ends exactly at time $T$, the number of steps is calculated as $N_t = \\lceil T / \\Delta t_{\\text{cand}} \\rceil$, and the actual time step used is set to $\\Delta t = T / N_t$. This procedure guarantees $\\Delta t \\le \\Delta t_{\\text{cand}} \\le \\Delta t_{\\text{max}}$, thereby satisfying stability.\n3.  **Initialization:** Create a 1D array `u` of size $N_x$. Initialize it with the initial condition $u(x,0) = \\sin(n\\pi x/L)$. The grid coordinates $x_i$ can be generated using `np.linspace(0, L, Nx)`. The boundary values $u[0]$ and $u[N_x-1]$ will be zero due to this specific choice of initial condition and will be maintained at zero.\n4.  **Time Evolution:** Iterate $N_t$ times. In each step, compute the solution at time $t_{n+1}$ from the solution at $t_n$. This is done using a vectorized update on the interior points. For an array `u` representing the solution at time $t_n$, the interior of the solution at $t_{n+1}$ is calculated as:\n    `u[1:-1] = u[1:-1] + r * (u[2:] - 2*u[1:-1] + u[:-2])`.\n    NumPy evaluates the entire right-hand side, creating a temporary array based on the old `u` values, before assigning the result to the slice `u[1:-1]`. This correctly implements the explicit update without data-races. The boundary values `u[0]` and `u[-1]` remain $0$.\n5.  **Analytical Solution and Error:** The prescribed initial condition $u(x,0) = \\sin(n\\pi x/L)$ is an eigenfunction of the diffusion operator $\\alpha \\frac{\\partial^2}{\\partial x^2}$ on $[0, L]$ with homogeneous Dirichlet boundary conditions. The corresponding eigenvalue is $\\lambda_n = \\alpha (n\\pi/L)^2$. The analytical solution is therefore:\n    $$\n    u(x,t) = e^{-\\lambda_n t} u(x,0) = e^{-\\alpha (n\\pi/L)^2 t} \\sin(n\\pi x/L)\n    $$\n    For the test cases with $L=1$, this simplifies to $u(x,t) = e^{-\\alpha (n\\pi)^2 t} \\sin(n\\pi x)$. At the final time $T$, we compute this analytical solution on the grid.\n6.  **Error Calculation:** The discrete $L^2$ error between the final numerical solution $u_i^{N_t}$ and the analytical solution $u(x_i, T)$ is computed over the interior points ($i=1, \\dots, N_x-2$) using the provided formula:\n    $$\n    \\|e\\|_2 \\approx \\sqrt{\\Delta x \\sum_{i=1}^{N_x-2} \\left(u_i^{N_t} - u(x_i, T)\\right)^2}\n    $$\nThis procedure systematically derives, implements, and verifies the FTCS method as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Forward-Time Central-Space (FTCS) method for the 1D diffusion\n    equation and computes the L2 error against an analytical solution for a\n    suite of test cases.\n    \"\"\"\n    # Test cases defined as tuples: (alpha, L, Nx, T, dt_nom, n)\n    test_cases = [\n        (0.1, 1.0, 101, 0.05, 0.0002, 1),\n        (0.1, 1.0, 51, 0.05, 1.0, 2),\n        (1.0, 1.0, 21, 0.02, 0.01, 1),\n        (0.5, 1.0, 3, 0.5, 1.0, 1),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        alpha, L, Nx, T, dt_nom, n = case\n\n        # Step 1: Grid and Parameter Setup\n        dx = L / (Nx - 1) if Nx > 1 else L\n        x = np.linspace(0, L, Nx)\n\n        # Step 2: Time Step Selection to enforce stability\n        # Calculate the maximum time step allowed by the stability criterion r = 0.5\n        # r = alpha * dt / dx**2  =  dt = 0.5 * dx**2 / alpha\n        dt_stable_max = 0.5 * dx**2 / alpha if alpha > 0 else float('inf')\n\n        # Choose a candidate dt that respects both the nominal value and stability\n        # If dt_nom is already stable, use it. Otherwise, use the max stable dt.\n        dt_candidate = min(dt_nom, dt_stable_max)\n        \n        # Calculate the number of steps to reach final time T.\n        # np.ceil ensures we simulate for at least time T.\n        # The number of steps must be at least 1 if T  0.\n        if T > 0 and dt_candidate > 0:\n            num_steps = int(np.ceil(T / dt_candidate))\n        else:\n            num_steps = 0\n            \n        # Recalculate the actual dt to land exactly on T\n        dt = T / num_steps if num_steps > 0 else 0\n        \n        # Calculate the final stability ratio 'r' used in the simulation\n        r = alpha * dt / dx**2 if dx > 0 else 0\n\n        # Step 3: Initialization\n        # Set the initial condition u(x,0) = sin(n*pi*x/L)\n        u = np.sin(n * np.pi * x / L)\n        # The homogeneous Dirichlet boundary conditions u[0]=0 and u[-1]=0 are\n        # automatically satisfied by the initial condition at x=0 and x=L.\n        # They will be maintained throughout the simulation.\n\n        # Step 4: Time Evolution using vectorized FTCS update\n        for _ in range(num_steps):\n            # The FTCS update rule for interior points is:\n            # u_i^{n+1} = u_i^n + r * (u_{i+1}^n - 2*u_i^n + u_{i-1}^n)\n            # This is vectorized using NumPy slices. NumPy evaluates the entire\n            # RHS first based on the old state of `u`, creating a temporary\n            # array, which is then assigned to the LHS slice. This correctly\n            # implements the explicit scheme.\n            if Nx > 2:\n                u_old = u.copy()\n                u[1:-1] = u_old[1:-1] + r * (u_old[2:] - 2 * u_old[1:-1] + u_old[0:-2])\n            # Boundary conditions u[0]=0 and u[-1]=0 are preserved.\n\n        # At this point, `u` contains the final numerical solution.\n\n        # Step 5: Analytical Solution\n        # For the IC u(x,0) = sin(n*pi*x/L), the analytical solution is\n        # u(x,t) = exp(-alpha * (n*pi/L)^2 * t) * sin(n*pi*x/L)\n        eigenvalue = alpha * (n * np.pi / L)**2\n        u_analytical = np.exp(-eigenvalue * T) * np.sin(n * np.pi * x / L)\n\n        # Step 6: Error Calculation\n        # The discrete L2 error is computed over interior points only.\n        if Nx > 2:\n            u_numerical_interior = u[1:-1]\n            u_analytical_interior = u_analytical[1:-1]\n        \n            squared_errors = (u_numerical_interior - u_analytical_interior)**2\n            l2_error = np.sqrt(dx * np.sum(squared_errors))\n        else:\n            l2_error = 0.0 # No interior points\n        \n        results.append(l2_error)\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A functioning code that produces a seemingly reasonable solution is a good first step, but how can we be confident that it is converging correctly? This advanced practice introduces the crucial concept of code verification by using Richardson extrapolation to analyze the convergence rate of our FTCS solver . By systematically refining the temporal and spatial grids, you will empirically measure the method's order of accuracy and confirm that it matches the theoretical prediction of being first-order in time and second-order in space.",
            "id": "3395832",
            "problem": "Consider the one-dimensional heat equation (also called the diffusion equation) on the unit interval with homogeneous Dirichlet boundary conditions,\n$$\nu_t(x,t) = \\alpha\\,u_{xx}(x,t),\\quad x\\in(0,1),\\ t\\in(0,T],\n$$\nwith data\n$$\nu(0,t)=0,\\quad u(1,t)=0,\\quad u(x,0)=\\sin(\\pi x),\\quad \\alpha=1.\n$$\nFor this problem, the exact solution is known from separation of variables:\n$$\nu(x,t) = e^{-\\pi^2 t}\\,\\sin(\\pi x).\n$$\nThe task is to discretize this initial-boundary value problem using the Forward-Time Central-Space (FTCS) method, which by definition uses a forward finite difference in time for $u_t$ and a central finite difference in space for $u_{xx}$ on a uniform grid. You must implement the explicit scheme under a Courant–Friedrichs–Lewy (CFL) stability constraint appropriate to the FTCS method for the heat equation. Use Dirichlet boundary values directly at the end points for all time steps. Do not use any implicit time-stepping.\n\nYou will apply Richardson extrapolation to a set of carefully chosen meshes to do the following:\n- Estimate the true solution error at selected points,\n- Verify the observed first-order accuracy in time and second-order accuracy in space of the FTCS method.\n\nAll computations must target the final time $T = 0.01$ (i.e., $T = 0.01$ seconds). Spatial and temporal meshes must be uniform, and time-marching must end exactly at $t=T$ with a constant time step on each run.\n\nDefinitions to use:\n- The Forward-Time Central-Space (FTCS) method employs forward differencing in time and central differencing in space on uniform grids.\n- The Courant–Friedrichs–Lewy (CFL) number for the heat equation in one dimension is $\\lambda = \\alpha\\,\\Delta t/\\Delta x^2$.\n\nYou must implement the following test suite. For each test, use the exact solution above to evaluate reference values at the specified locations.\n\nTest 1 (temporal order via Richardson at fixed fine space):\n- Domain length $L=1$.\n- Final time $T=0.01$.\n- Diffusion coefficient $\\alpha=1$.\n- Spatial grid: choose $N_x = 400$ uniform subintervals, so that $\\Delta x = 1/N_x$.\n- Choose a target CFL number $\\lambda_0 = 0.4$ and set the coarse time step $\\Delta t_0 = \\lambda_0 \\Delta x^2$.\n- Construct two refinements in time with ratios $r_t=2$: $\\Delta t_1 = \\Delta t_0/2$, $\\Delta t_2 = \\Delta t_1/2$, ensuring that $T/\\Delta t_i$ is an integer for $i\\in\\{0,1,2\\}$.\n- Evolve the FTCS scheme to $t=T$ for each of the three time steps using the same spatial grid, and record the numerical solutions $U_{\\Delta t_0}$, $U_{\\Delta t_1}$, $U_{\\Delta t_2}$ at the spatial location $x^\\star=0.5$.\n- Using Richardson extrapolation with refinement factor $r_t=2$, estimate the observed temporal order $p_t$ from these three approximations. Report the scalar value $p_t$ and also report a boolean asserting whether $|p_t-1|\\le 0.05$.\n\nTest 2 (spatial order via Richardson with near-constant CFL):\n- Domain length $L=1$.\n- Final time $T=0.01$.\n- Diffusion coefficient $\\alpha=1$.\n- Use three nested spatial grids with $N_x\\in\\{50,100,200\\}$ so that $\\Delta x_h=1/N_x$, $\\Delta x_{h/2} = \\Delta x_h/2$, $\\Delta x_{h/4}=\\Delta x_h/4$.\n- For each spatial grid, select the number of time steps $N_t$ as $N_t = \\left\\lceil T/(0.49\\,\\Delta x^2)\\right\\rceil$ and take $\\Delta t = T/N_t$, so that the resulting CFL numbers satisfy $\\lambda\\le 0.49$.\n- Evolve the FTCS scheme to $t=T$ on each grid and record the numerical values $U_h$, $U_{h/2}$, $U_{h/4}$ at the common spatial location $x^\\star=0.3$.\n- Using Richardson extrapolation with refinement factor $r_x=2$, estimate the observed spatial order $p_x$ from these three approximations. Report the scalar value $p_x$ and also report a boolean asserting whether $|p_x-2|\\le 0.1$.\n\nTest 3 (two-stage Richardson extrapolation to estimate the true solution at a point):\n- Domain length $L=1$.\n- Final time $T=0.01$.\n- Diffusion coefficient $\\alpha=1$.\n- Spatial grids: coarse with $N_x^{(c)}=50$ and fine with $N_x^{(f)}=100$.\n- For each spatial grid independently, choose a baseline number of time steps \n$$\nN_t^{(c)}=\\left\\lceil \\frac{T}{0.4\\,(\\Delta x^{(c)})^2}\\right\\rceil,\\quad N_t^{(f)}=\\left\\lceil \\frac{T}{0.4\\,(\\Delta x^{(f)})^2}\\right\\rceil,\n$$\nand define the refined counts $2N_t^{(c)}$ and $2N_t^{(f)}$ to generate halved time steps at fixed space.\n- For each spatial grid, compute two FTCS solutions at $t=T$ with time steps $\\Delta t$ and $\\Delta t/2$, and use Richardson extrapolation in time with refinement factor $2$ to form time-extrapolated approximations on the coarse and fine spatial grids. Then, perform a second Richardson extrapolation step in space with refinement factor $2$ (i.e., between the time-extrapolated coarse and fine solutions) to obtain a two-stage extrapolated estimate of $u(x^\\star,T)$ at $x^\\star=0.3$.\n- Compute the absolute error of this two-stage extrapolated estimate with respect to the exact solution at $(x^\\star,T)$, and report this scalar error.\n\nYour program must compute the five outputs described above, in the following order:\n1. The estimated temporal order $p_t$ from Test $1$.\n2. A boolean stating whether $|p_t-1|\\le 0.05$.\n3. The estimated spatial order $p_x$ from Test $2$.\n4. A boolean stating whether $|p_x-2|\\le 0.1$.\n5. The absolute error from Test $3$.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$). The first, third, and fifth entries must be real numbers (floats), and the second and fourth entries must be booleans. No other text should be printed.",
            "solution": "The problem is valid. It is a well-posed, scientifically sound exercise in numerical analysis, concerning the application of the Forward-Time Central-Space (FTCS) method to the one-dimensional heat equation. All parameters and procedures are clearly defined and consistent.\n\nThe solution proceeds in three stages: first, the derivation of the numerical scheme; second, the formulation of the Richardson extrapolation procedure for analyzing the scheme's accuracy; and third, the step-by-step execution of the three computational tests specified in the problem statement.\n\n### 1. FTCS Discretization\n\nThe governing partial differential equation (PDE) is the one-dimensional heat equation:\n$$\nu_t(x,t) = \\alpha\\,u_{xx}(x,t), \\quad x \\in (0, 1), \\ t \\in (0, T]\n$$\nwith diffusion coefficient $\\alpha=1$, final time $T=0.01$, homogeneous Dirichlet boundary conditions $u(0,t)=u(1,t)=0$, and initial condition $u(x,0)=\\sin(\\pi x)$.\n\nTo discretize this equation, we define a uniform grid in space and time. The spatial domain $[0,1]$ is divided into $N_x$ subintervals of width $\\Delta x = 1/N_x$, yielding grid points $x_j = j \\Delta x$ for $j=0, 1, \\dots, N_x$. The time interval $[0,T]$ is divided into $N_t$ steps of duration $\\Delta t = T/N_t$, yielding time levels $t_n = n \\Delta t$ for $n=0, 1, \\dots, N_t$. Let $U_j^n$ be the numerical approximation of the exact solution $u(x_j, t_n)$.\n\nThe FTCS method uses a forward difference for the time derivative and a second-order central difference for the spatial derivative:\n$$\n\\frac{u(x_j, t_{n+1}) - u(x_j, t_n)}{\\Delta t} \\approx u_t(x_j, t_n)\n$$\n$$\n\\frac{u(x_{j-1}, t_n) - 2u(x_j, t_n) + u(x_{j+1}, t_n)}{\\Delta x^2} \\approx u_{xx}(x_j, t_n)\n$$\nSubstituting these approximations into the PDE gives the FTCS finite difference equation:\n$$\n\\frac{U_j^{n+1} - U_j^n}{\\Delta t} = \\alpha \\frac{U_{j+1}^n - 2U_j^n + U_{j-1}^n}{\\Delta x^2}\n$$\nRearranging to solve for the solution at the next time step, $U_j^{n+1}$, yields the explicit update formula:\n$$\nU_j^{n+1} = U_j^n + \\alpha \\frac{\\Delta t}{\\Delta x^2} (U_{j+1}^n - 2U_j^n + U_{j-1}^n)\n$$\nBy defining the Courant–Friedrichs–Lewy (CFL) number for the heat equation as $\\lambda = \\alpha \\Delta t / \\Delta x^2$, the formula can be written more compactly:\n$$\nU_j^{n+1} = \\lambda U_{j-1}^n + (1 - 2\\lambda)U_j^n + \\lambda U_{j+1}^n\n$$\nThis update rule is applied to all interior grid points $j=1, 2, \\dots, N_x-1$. The scheme is known to be stable only if the CFL condition $\\lambda \\le 1/2$ is satisfied. The problem specifies CFL numbers $\\lambda=0.4$ and $\\lambda\\le0.49$, which are within this stable region.\n\nThe boundary values are fixed for all time: $U_0^n = 0$ and $U_{N_x}^n = 0$ for all $n$. The initial state of the numerical solution is set by the initial condition: $U_j^0 = \\sin(\\pi x_j)$ for $j=0, 1, \\dots, N_x$.\n\n### 2. Richardson Extrapolation\n\nRichardson extrapolation is a technique to estimate the error of a numerical method and to obtain a more accurate approximation. If a numerical method produces an approximation A(h) that depends on a step size $h$ and has an error expansion of the form $A(h) = A_{\\text{exact}} + C h^p + O(h^{p+k})$ for some $k0$, we can use multiple computations to analyze this error.\n\n**Order Estimation:** Using three approximations computed with step sizes $h$, $h/r$, and $h/r^2$ (where $r$ is the refinement factor), the observed order of convergence $p$ can be estimated as:\n$$\np \\approx \\log_r \\left( \\frac{A(h) - A(h/r)}{A(h/r) - A(h/r^2)} \\right)\n$$\n**Error Cancellation:** Using two approximations, $A(h)$ and $A(h/r)$, a more accurate estimate, $A_{\\text{extra}}$, can be derived by eliminating the leading error term:\n$$\nA_{\\text{extra}} = \\frac{r^p A(h/r) - A(h)}{r^p - 1}\n$$\n\n### 3. Execution of Test Suite\n\nAn FTCS solver is implemented based on the derived update rule. This solver is then used to perform the three tests.\n\n**Test 1: Temporal Order of Accuracy**\nThe goal is to verify the first-order accuracy in time, $p_t=1$, of the FTCS method. The spatial grid is held fixed with $N_x=400$ subintervals ($\\Delta x = 1/400$), which makes the spatial discretization error constant and small. Three simulations are run to time $T=0.01$ with successively refined time steps.\n- Grid parameters: $N_x = 400$. The point of interest is $x^\\star=0.5$, which corresponds to grid index $j=200$.\n- Time steps: A base CFL number $\\lambda_0 = 0.4$ is used to define a coarse time step $\\Delta t_0 = \\lambda_0 \\Delta x^2 = 0.4 \\times (1/400)^2$. This yields $N_{t,0} = T/\\Delta t_0 = 4000$ time steps. Two refined simulations are run with $N_{t,1} = 2N_{t,0} = 8000$ and $N_{t,2} = 4N_{t,0} = 16000$ steps. The refinement factor is $r_t=2$.\n- Let $U_{\\Delta t_0}$, $U_{\\Delta t_1}$, $U_{\\Delta t_2}$ be the numerical solutions at $x^\\star=0.5$ for the three time steps. The observed temporal order $p_t$ is computed using the formula for order estimation with $r=2$:\n$$\np_t = \\log_2 \\left( \\frac{U_{\\Delta t_0} - U_{\\Delta t_1}}{U_{\\Delta t_1} - U_{\\Delta t_2}} \\right)\n$$\nThe value of $p_t$ is expected to be close to $1$. The condition $|p_t-1|\\le 0.05$ is checked.\n\n**Test 2: Spatial Order of Accuracy**\nThe goal is to verify the second-order accuracy in space, $p_x=2$. Three simulations are run on nested spatial grids with $N_x \\in \\{50, 100, 200\\}$, so the refinement factor is $r_x=2$. The point of interest is $x^\\star=0.3$, which corresponds to indices $j \\in \\{15, 30, 60\\}$ on the respective grids.\n- To isolate the spatial error, the temporal error contribution is suppressed by choosing $\\Delta t$ small enough such that it is proportional to $\\Delta x^2$. For each grid, the number of time steps is set to $N_t = \\lceil T/(0.49 \\Delta x^2) \\rceil$, keeping $\\lambda \\le 0.49$. This results in $N_t$ values of $52$, $205$, and $817$ for the coarse, medium, and fine grids, respectively.\n- Let $U_h$, $U_{h/2}$, $U_{h/4}$ be the numerical solutions at $x^\\star=0.3$. The observed spatial order $p_x$ is computed:\n$$\np_x = \\log_2 \\left( \\frac{U_h - U_{h/2}}{U_{h/2} - U_{h/4}} \\right)\n$$\nThe value of $p_x$ is expected to be close to $2$. The condition $|p_x-2|\\le 0.1$ is checked.\n\n**Test 3: Two-Stage Richardson Extrapolation**\nThis test demonstrates improving the solution accuracy by sequentially extrapolating in time and space.\n- **Stage 1 (Time Extrapolation):**\n    - On a coarse spatial grid ($N_x^{(c)}=50$), two solutions, $A_{c,1}$ and $A_{c,2}$, are computed at $x^\\star=0.3$ using $N_t = 63$ and $N_t = 126$ time steps, respectively. A time-extrapolated value $A_c^{\\text{extra}}$ is calculated using $p=1$ and $r=2$: $A_c^{\\text{extra}} = 2A_{c,2} - A_{c,1}$.\n    - On a fine spatial grid ($N_x^{(f)}=100$), two solutions, $A_{f,1}$ and $A_{f,2}$, are computed at $x^\\star=0.3$ using $N_t = 250$ and $N_t = 500$ time steps. A time-extrapolated value $A_f^{\\text{extra}}$ is calculated: $A_f^{\\text{extra}} = 2A_{f,2} - A_{f,1}$.\n- **Stage 2 (Space Extrapolation):**\n    - The two time-extrapolated solutions, $A_c^{\\text{extra}}$ (on a grid with step size $\\Delta x^{(c)}$) and $A_f^{\\text{extra}}$ (on a grid with step size $\\Delta x^{(f)} = \\Delta x^{(c)}/2$), are themselves treated as approximations whose dominant error is spatial and of order $p=2$. A final, higher-accuracy estimate, $A^{\\text{final}}$, is computed using spatial Richardson extrapolation with $p=2$ and $r=2$:\n    $$\n    A^{\\text{final}} = \\frac{2^2 A_f^{\\text{extra}} - A_c^{\\text{extra}}}{2^2 - 1} = \\frac{4A_f^{\\text{extra}} - A_c^{\\text{extra}}}{3}\n    $$\n- **Error Calculation:** The absolute error of this two-stage extrapolated value is calculated with respect to the exact solution $u(x^\\star, T) = e^{-\\pi^2 T} \\sin(\\pi x^\\star)$ at $x^\\star=0.3$ and $T=0.01$. This error is the final reported value for this test.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ftcs_solver(L, T, alpha, Nx, Nt):\n    \"\"\"\n    Solves the 1D heat equation u_t = alpha * u_xx with homogeneous Dirichlet BCs\n    using the Forward-Time Central-Space (FTCS) method.\n\n    Args:\n        L (float): Domain length.\n        T (float): Final time.\n        alpha (float): Diffusion coefficient.\n        Nx (int): Number of spatial subintervals.\n        Nt (int): Number of time steps.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The spatial grid points.\n            - np.ndarray: The numerical solution U at the final time T.\n    \"\"\"\n    dx = L / Nx\n    dt = T / Nt\n    lam = alpha * dt / dx**2\n\n    # As per the problem, all lambda values are within the stability limit.\n    # if lam  0.5:\n    #     raise ValueError(\"Stability condition violated: lambda  0.5\")\n\n    x = np.linspace(0, L, Nx + 1)\n    \n    # Initial condition\n    U = np.sin(np.pi * x / L)\n\n    # Time-marching loop\n    for _ in range(Nt):\n        U_old = U.copy()\n        # Vectorized update for interior points\n        U[1:-1] = U_old[1:-1] + lam * (U_old[0:-2] - 2 * U_old[1:-1] + U_old[2:])\n        # BCs u(0,t)=0 and u(L,t)=0 are maintained as U[0] and U[Nx] are not updated.\n    \n    return x, U\n\ndef solve():\n    \"\"\"\n    Executes the three tests described in the problem statement and prints the results.\n    \"\"\"\n    # Common parameters\n    L = 1.0\n    T = 0.01\n    alpha = 1.0\n\n    # --- Test 1: Temporal Order of Accuracy ---\n    Nx_t = 400\n    x_star_t = 0.5\n    idx_t = int(x_star_t * Nx_t / L)\n    \n    dx_t = L / Nx_t\n    lam0_t = 0.4\n    dt0_t = lam0_t * dx_t**2\n    \n    Nt0_t = int(round(T / dt0_t))\n    Nt1_t = 2 * Nt0_t\n    Nt2_t = 4 * Nt0_t\n    \n    _, U0_t = ftcs_solver(L, T, alpha, Nx_t, Nt0_t)\n    _, U1_t = ftcs_solver(L, T, alpha, Nx_t, Nt1_t)\n    _, U2_t = ftcs_solver(L, T, alpha, Nx_t, Nt2_t)\n    \n    sol_0 = U0_t[idx_t]\n    sol_1 = U1_t[idx_t]\n    sol_2 = U2_t[idx_t]\n    \n    # Richardson extrapolation for order p\n    ratio_t = (sol_0 - sol_1) / (sol_1 - sol_2)\n    p_t = np.log2(ratio_t)\n    is_pt_valid = abs(p_t - 1.0) = 0.05\n\n    # --- Test 2: Spatial Order of Accuracy ---\n    x_star_x = 0.3\n    Nx_vals_x = [50, 100, 200]\n    sols_x = []\n\n    for Nx in Nx_vals_x:\n        dx = L / Nx\n        # Calculate Nt to keep lambda = 0.49\n        Nt = int(np.ceil(T / (0.49 * dx**2)))\n        idx = int(x_star_x * Nx / L)\n        \n        _, U = ftcs_solver(L, T, alpha, Nx, Nt)\n        sols_x.append(U[idx])\n\n    ratio_x = (sols_x[0] - sols_x[1]) / (sols_x[1] - sols_x[2])\n    p_x = np.log2(ratio_x)\n    is_px_valid = abs(p_x - 2.0) = 0.1\n\n    # --- Test 3: Two-Stage Richardson Extrapolation ---\n    x_star_e = 0.3\n\n    # Coarse spatial grid calculations\n    Nx_c = 50\n    dx_c = L / Nx_c\n    idx_c = int(x_star_e * Nx_c / L)\n    Nt_c1 = int(np.ceil(T / (0.4 * dx_c**2)))\n    Nt_c2 = 2 * Nt_c1\n    _, U_c1 = ftcs_solver(L, T, alpha, Nx_c, Nt_c1)\n    _, U_c2 = ftcs_solver(L, T, alpha, Nx_c, Nt_c2)\n    sol_c1 = U_c1[idx_c]\n    sol_c2 = U_c2[idx_c]\n    # Time extrapolation (p=1, r=2)\n    sol_c_extra = (2.0 * sol_c2 - sol_c1)\n\n    # Fine spatial grid calculations\n    Nx_f = 100\n    dx_f = L / Nx_f\n    idx_f = int(x_star_e * Nx_f / L)\n    Nt_f1 = int(np.ceil(T / (0.4 * dx_f**2)))\n    Nt_f2 = 2 * Nt_f1\n    _, U_f1 = ftcs_solver(L, T, alpha, Nx_f, Nt_f1)\n    _, U_f2 = ftcs_solver(L, T, alpha, Nx_f, Nt_f2)\n    sol_f1 = U_f1[idx_f]\n    sol_f2 = U_f2[idx_f]\n    # Time extrapolation (p=1, r=2)\n    sol_f_extra = (2.0 * sol_f2 - sol_f1)\n\n    # Space extrapolation (p=2, r=2)\n    sol_final = (4.0 * sol_f_extra - sol_c_extra) / 3.0\n\n    # Exact solution\n    u_exact = np.exp(-alpha * np.pi**2 * T) * np.sin(np.pi * x_star_e / L)\n\n    # Absolute error of the two-stage extrapolated estimate\n    error_e = abs(sol_final - u_exact)\n\n    # Final results assembly\n    results = [p_t, is_pt_valid, p_x, is_px_valid, error_e]\n\n    # Print in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}