{
    "hands_on_practices": [
        {
            "introduction": "理论上的稳定性限制在实践中具有切实且往往是戏剧性的后果。这个练习旨在通过一个具体的反例，清晰地展示当 FTCS 格式的稳定性条件被违反时会发生什么 。通过一个简单的计算，我们将看到一个非负的初始条件如何能在一个时间步内产生非物理的负值，这为在数值模拟中谨慎选择时间步长提供了强有力的动机。",
            "id": "3395792",
            "problem": "考虑一维热方程（也称为扩散方程），该方程定义在一个足够大的区域上，使得边界影响在一个时间步长内可以忽略不计。其偏微分方程形式如下：\n$$\nu_{t}(x,t) \\;=\\; \\kappa\\,u_{xx}(x,t),\n$$\n其中 $\\kappa0$ 是一个常数扩散系数。前向时间中心空间（FTCS）方法在空间步长为 $h0$、时间步长为 $k0$ 的均匀网格上，使用时间上的前向差分和空间上的中心差分来定义一个有限差分格式。在这种情况下，显式格式的经典单调性要求离散更新映射是相邻值的凸组合。在实践中，这施加了一个涉及无量纲比 $r=\\kappa k/h^{2}$ 的条件。\n\n构建一个反例，证明当 FTCS 更新违反单调性约束时，它可以在单个时间步长内从非负初始数据产生伪负值。为此，取 $\\kappa=1$，$h=1$ 和 $k=1$，并考虑一个在网格上非负且具有紧支集的初始条件，具体由下式给出：\n$$\nu_{i}^{0} \\;=\\;\n\\begin{cases}\n1,   i=1,\\\\\n0,   i\\neq 1,\n\\end{cases}\n$$\n其中 $i\\in\\mathbb{Z}$ 是空间网格点的索引，$u_{i}^{n}$ 表示在空间索引 $i$ 和时间层 $n$ 处对 $u$ 的数值近似。在中心索引 $i=1$ 处应用单次 FTCS 更新以获得 $u_{1}^{1}$。\n\n计算 $u_{1}^{1}$ 的值。您的最终答案必须是一个实数。不需要四舍五入，也不需要报告物理单位。从热方程有限差分近似的基本原理和核心定义出发解释您的推理，并阐明为什么当约束被违反时，这个显式计算构成了一个对单调性的反例。",
            "solution": "该问题要求我们使用前向时间中心空间（FTCS）方法，在特意选择用来违反格式单调性条件的参数下，计算一维热方程的数值解在一个时间步长后的值。然后我们必须阐明为什么这个结果构成一个反例。\n\n控制偏微分方程（PDE）是热方程：\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\kappa \\frac{\\partial^2 u}{\\partial x^2}(x,t)\n$$\n其中 $u(x,t)$ 代表在空间位置 $x$ 和时间 $t$ 处的量（例如温度），而 $\\kappa  0$ 是常数扩散系数。\n\nFTCS 方法在均匀网格上离散化这个偏微分方程，其中 $x_i = i h$ 且 $t_n = n k$，$h$ 是空间步长，$k$ 是时间步长。对 $u(x_i, t_n)$ 的数值近似记为 $u_i^n$。\n\n为了构建 FTCS 格式，我们使用有限差分来近似导数：\n1. 时间导数 $\\frac{\\partial u}{\\partial t}$ 在 $(x_i, t_n)$ 处由一阶前向差分近似：\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{(x_i, t_n)} \\approx \\frac{u_i^{n+1} - u_i^n}{k}\n$$\n2. 空间二阶导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 在 $(x_i, t_n)$ 处由二阶中心差分近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i, t_n)} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}\n$$\n将这些近似值代入热方程，得到 FTCS 有限差分方程：\n$$\n\\frac{u_i^{n+1} - u_i^n}{k} = \\kappa \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}\n$$\n这是一个显式格式，因为我们可以用当前时间层 $n$ 的已知值来求解下一个时间层的未知值 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n + \\frac{\\kappa k}{h^2} (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\n我们定义无量纲扩散数，或称网格比，为 $r = \\frac{\\kappa k}{h^2}$。更新规则可以重写为：\n$$\nu_i^{n+1} = u_i^n + r(u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\n将与时间层 $n$ 处的空间网格点相对应的项分组，我们得到：\n$$\nu_i^{n+1} = r u_{i-1}^n + (1 - 2r) u_i^n + r u_{i+1}^n\n$$\n物理上的热方程遵循极值原理，这意味着对于非负的初始数据，解在所有未来时间里都保持非负。如果一个数值格式保持了这个性质，它就被称为单调的。对于 FTCS 格式，如果 $u_i^{n+1}$ 更新规则中的所有系数都是非负的，那么单调性就得到保证。由于 $\\kappa, k, h$ 都是正数，所以 $r  0$。因此，单调性条件简化为要求 $u_i^n$ 的系数为非负：\n$$\n1 - 2r \\ge 0 \\implies 2r \\le 1 \\implies r \\le \\frac{1}{2}\n$$\n因此，FTCS 格式的单调性（以及冯·诺依曼稳定性）条件是 $r = \\frac{\\kappa k}{h^2} \\le \\frac{1}{2}$。\n\n问题指定的参数值旨在违反此条件。给定的值为：\n- 扩散系数：$\\kappa = 1$\n- 空间步长：$h = 1$\n- 时间步长：$k = 1$\n\n使用这些值，网格比 $r$ 为：\n$$\nr = \\frac{\\kappa k}{h^2} = \\frac{1 \\cdot 1}{1^2} = 1\n$$\n由于 $r=1$，条件 $r \\le \\frac{1}{2}$ 被违反了。我们预期该格式会表现出非物理行为。对于这个特定的参数选择，更新规则变为：\n$$\nu_i^{n+1} = (1) u_{i-1}^n + (1 - 2(1)) u_i^n + (1) u_{i+1}^n = u_{i-1}^n - u_i^n + u_{i+1}^n\n$$\n问题要求我们计算 $u_1^1$，即在空间索引 $i=1$ 处，经过一个时间步长（$n=0 \\to n=1$）后的值。使用推导出的更新规则，令 $i=1$ 和 $n=0$：\n$$\nu_1^1 = u_{1-1}^0 - u_1^0 + u_{1+1}^0 = u_0^0 - u_1^0 + u_2^0\n$$\n初始条件以离散狄拉克函数的形式给出：\n$$\nu_i^0 =\n\\begin{cases}\n1,   i=1, \\\\\n0,   i\\neq 1.\n\\end{cases}\n$$\n根据此初始条件，我们有：\n- $u_1^0 = 1$\n- $u_0^0 = 0$ (因为 $0 \\neq 1$)\n- $u_2^0 = 0$ (因为 $2 \\neq 1$)\n\n将这些值代入 $u_1^1$ 的表达式中：\n$$\nu_1^1 = 0 - 1 + 0 = -1\n$$\n这个结果构成了一个明确的反例。初始数据 $u_i^0$ 在网格上处处非负。然而，在单个时间步长后，网格点 $i=1$ 处的数值解变为 $u_1^1 = -1$，这是一个负值。对于一个扩散过程来说，这是一个物理上不可能的结果，因为它只应该平滑初始分布，而不能创造新的最小值或最大值。从非负初始数据生成负值是违反单调性条件 $r \\le 1/2$ 的直接后果。当 $r  1/2$ 时，更新模板中 $u_i^n$ 的负系数导致了这种非物理行为。",
            "answer": "$$\n\\boxed{-1}\n$$"
        },
        {
            "introduction": "在理解了稳定性的重要性之后，下一步是构建一个能够遵循这一约束的稳健求解器。本练习将指导你完整地实现求解一维扩散方程的 FTCS 方法，涵盖从网格设置到算法上强制执行稳定性条件的全过程 。通过将数值结果与已知的解析解进行比较，你还将实践代码验证这一至关重要的技能，确保你的模拟既稳定又准确。",
            "id": "3395765",
            "problem": "考虑一个定义在有限区间上的，具有固定狄利克雷（Dirichlet）边界条件的一维扩散（热）方程。该问题由偏微分方程 $u_t = \\alpha\\,u_{xx}$（其中 $x \\in [0,L]$ 且 $t \\ge 0$）以及边界条件 $u(0,t) = 0$ 和 $u(L,t) = 0$ 定义。要求从第一性原理出发，推导并实现前向时间中心空间（FTCS）方法。您必须设计一个算法，该算法对空间网格（包括边界节点）使用连续的一维内存布局，对内部网格点上的空间更新进行向量化操作，并选择一个时间步长以强制满足可证明的扩散问题FTCS稳定性要求。该算法必须通过将数值解与一族初始数据的已知解析解进行比较来验证其正确性，这些初始数据是带有狄利克雷边界条件的拉普拉斯算子的特征函数。您的推导必须从控制方程 $u_t = \\alpha\\,u_{xx}$ 和均匀空间网格的定义开始，并且不得依赖任何现成公式。您必须解释稳定性限制为何出现，以及如何通过算法来强制满足该限制。无需物理单位；将所有量视为无量纲量。\n\n您需要实现一个完整的程序，该程序能够：\n- 在 $[0,L]$ 上构建一个包含 $N_x$ 个点的均匀网格，网格间距为 $\\Delta x = L/(N_x - 1)$。\n- 使用一个连续的一维数组存储所有网格点上的 $u(x_i,t_n)$，包括 $i = 0$ 和 $i = N_x - 1$ 处的边界。\n- 在每个时间步，通过对索引切片 $i = 1,2,\\dots,N_x-2$ 进行向量化的内部更新来应用FTCS格式。\n- 选择时间步长 $\\Delta t$，确保无量纲FTCS比率 $r$ 满足扩散FTCS稳定性判据 $r \\le 1/2$。\n- 通过迭代时间步进更新，将解从 $t=0$ 演化到指定的最终时间 $T$。\n- 使用初始条件 $u(x,0) = \\sin(n\\pi x)$（其中 $n=1$ 或 $n=2$），在齐次狄利克雷边界条件下，该初始条件对应的解析解为 $u(x,t) = e^{-\\alpha (n\\pi)^2 t}\\,\\sin(n\\pi x)$。\n- 在最终时间，通过比较数值解与解析解在内部网格点上的差异，计算离散 $L^2$ 误差，公式为 $\\|e\\|_2 \\approx \\sqrt{\\Delta x \\sum_{i=1}^{N_x-2} \\left(u_i^{N}-u(x_i,T)\\right)^2}$，其中 $u_i^{N}$ 是网格索引 $i$ 上最终时间的数值近似解。\n\n您的程序必须实现以下测试套件，参数以元组 $(\\alpha, L, N_x, T, \\Delta t_{\\text{nom}}, n)$ 的形式给出：\n- 案例1（理想情况）：$(0.1,\\,1,\\,101,\\,0.05,\\,0.0002,\\,1)$\n- 案例2（通过选择达到稳定性边界 $r=1/2$）：$(0.1,\\,1,\\,51,\\,0.05,\\,1.0,\\,2)$\n- 案例3（名义 $\\Delta t$ 违反稳定性，强制选择）：$(1.0,\\,1,\\,21,\\,0.02,\\,0.01,\\,1)$\n- 案例4（内部点数最少的边缘情况，$N_x=3$）：$(0.5,\\,1,\\,3,\\,0.5,\\,1.0,\\,1)$\n\n对于每个案例，您的程序必须：\n- 选择 $\\Delta t$ 以强制满足FTCS稳定性条件 $r \\le 1/2$，\n- 使用带有向量化内部更新的FTCS方法，将解从 $t=0$ 演化到 $t=T$，\n- 使用具有相同参数 $n$ 的解析解，计算在时间 $T$ 的离散 $L^2$ 误差，\n- 报告最终的离散 $L^2$ 误差和实际使用的 $r$ 值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为 $[\\text{error}_1, r_1, \\text{error}_2, r_2, \\text{error}_3, r_3, \\text{error}_4, r_4]$，其中每个 $\\text{error}_k$ 是一个浮点数，每个 $r_k$ 是案例 $k$ 中使用的无量纲FTCS比率的浮点值。\n\n所有结果均不带任何物理单位。不涉及角度。所有值都表示为普通十进制数（非百分比）。",
            "solution": "本问题要求推导并实现前向时间中心空间（FTCS）数值方法，以求解一维扩散方程（也称为热方程）。解必须通过与已知解析解进行比较来验证，并且该格式的数值稳定性必须通过算法强制满足。\n\n### 步骤1：FTCS格式的推导\n\n一维扩散的控制偏微分方程（PDE）为：\n$$\nu_t = \\alpha \\, u_{xx}\n$$\n其中 $u(x,t)$ 是作为空间位置 $x$ 和时间 $t$ 函数的所求量（例如，温度），$\\alpha$ 是常数热扩散系数。该问题定义在有限空间域 $x \\in [0, L]$上，具有齐次狄利克雷边界条件：\n$$\nu(0, t) = 0 \\quad \\text{和} \\quad u(L, t) = 0 \\quad \\text{对所有 } t \\ge 0\n$$\n\n为了数值求解此偏微分方程，我们将连续域 $(x, t)$ 离散化为一个离散网格。我们定义一个包含 $N_x$ 个点的均匀空间网格，网格点为 $x_i = i \\Delta x$，其中 $i = 0, 1, \\dots, N_x-1$。空间步长为 $\\Delta x = L / (N_x - 1)$。时间同样被离散化为步长为 $\\Delta t$ 的时间点 $t_n = n \\Delta t$，其中 $n = 0, 1, 2, \\dots$。我们将网格点上的解的数值近似值表示为 $u_i^n \\approx u(x_i, t_n)$。\n\nFTCS方法使用有限差分来近似时间和空间导数。\n- 在 $(x_i, t_n)$ 处的时间导数 $u_t$ 使用时间上的**一阶精度前向差分**进行近似：\n$$\nu_t \\bigg|_{(x_i, t_n)} \\approx \\frac{u(x_i, t_{n+1}) - u(x_i, t_n)}{\\Delta t} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\n- 在 $(x_i, t_n)$ 处的空间二阶导数 $u_{xx}$ 使用空间上的**二阶精度中心差分**进行近似：\n$$\nu_{xx} \\bigg|_{(x_i, t_n)} \\approx \\frac{u(x_{i+1}, t_n) - 2u(x_i, t_n) + u(x_{i-1}, t_n)}{(\\Delta x)^2} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\n$$\n\n将这些近似代入控制偏微分方程，我们得到FTCS有限差分方程：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\left( \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2} \\right)\n$$\n这个方程是一个显式格式，因为新时间步的未知值 $u_i^{n+1}$ 可以直接由当前时间步 $n$ 的已知值计算得出。为了使更新规则更清晰，我们求解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n + \\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\left( u_{i+1}^n - 2u_i^n + u_{i-1}^n \\right)\n$$\n通常定义一个无量纲参数 $r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$，常被称为FTCS比率或扩散问题的库朗数（Courant number）。更新规则简化为：\n$$\nu_i^{n+1} = u_i^n + r \\left( u_{i+1}^n - 2u_i^n + u_{i-1}^n \\right)\n$$\n此更新应用于所有内部网格点，即 $i = 1, 2, \\dots, N_x-2$。边界点 $u_0^{n+1}$ 和 $u_{N_x-1}^{n+1}$ 由狄利克雷边界条件固定为 $0$。\n\n### 步骤2：数值稳定性\n\n扩散方程的FTCS格式只是条件稳定的。不稳定性会导致微小的初始误差（如舍入误差）指数级增长，从而使数值解毫无意义。von Neumann 稳定性分析揭示了稳定性约束。我们寻找形如 $u_i^n = G^n e^{j k x_i}$ 的解，其中 $G$ 是波数为 $k$ 的傅里叶模态在每个时间步的增长因子，$j = \\sqrt{-1}$。对于一个稳定的格式，所有可能波数的增长因子的模都不能超过1，即 $|G| \\le 1$。\n\n将这种形式代入FTCS更新规则，得到：\n$$\nG = 1 + r (e^{j k \\Delta x} - 2 + e^{-j k \\Delta x})\n$$\n使用欧拉恒等式 $e^{j\\theta} + e^{-j\\theta} = 2\\cos(\\theta)$，上式变为：\n$$\nG = 1 + 2r(\\cos(k \\Delta x) - 1)\n$$\n使用半角公式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$，我们得到：\n$$\nG = 1 - 4r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\n稳定性条件 $|G| \\le 1$ 转化为 $-1 \\le 1 - 4r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 1$。\n- 右侧不等式 $1 - 4r \\sin^2(\\dots) \\le 1$ 意味着 $-4r \\sin^2(\\dots) \\le 0$，因为 $r \\ge 0$ 且 $\\sin^2(\\dots) \\ge 0$，所以此式恒成立。\n- 左侧不等式 $-1 \\le 1 - 4r \\sin^2(\\dots)$ 是关键的约束。它要求 $4r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 2$，即 $r \\le \\frac{1}{2 \\sin^2(k \\Delta x/2)}$。\n这个条件必须对所有波数 $k$ 都成立。最严格的（最坏情况）场景发生在 $\\sin^2(k \\Delta x/2)$ 取其最大值 $1$ 时。这导出了稳定性判据：\n$$\nr = \\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\le \\frac{1}{2}\n$$\n\n### 步骤3：算法实现\n\n该算法旨在强制满足此稳定性条件并执行FTCS格式。\n\n1.  **网格与参数设置：** 对于给定的 $\\alpha$、$L$ 和 $N_x$，计算空间步长 $\\Delta x = L/(N_x - 1)$。\n2.  **时间步长选择：** 为保证稳定性，必须选择时间步长 $\\Delta t$ 以满足 $r \\le 1/2$。最大允许时间步长为 $\\Delta t_{\\text{max}} = \\frac{1}{2}\\frac{(\\Delta x)^2}{\\alpha}$。问题提供了一个名义时间步长 $\\Delta t_{\\text{nom}}$。算法必须选择一个候选时间步长 $\\Delta t_{\\text{cand}} = \\min(\\Delta t_{\\text{nom}}, \\Delta t_{\\text{max}})$，以同时满足用户的偏好（如果稳定）和稳定性要求。总模拟时间为 $T$。为确保模拟在恰好 $T$ 时刻结束，步数计算为 $N_t = \\lceil T / \\Delta t_{\\text{cand}} \\rceil$（向上取整），实际使用的时间步长则设为 $\\Delta t = T / N_t$。此过程保证了 $\\Delta t \\le \\Delta t_{\\text{cand}} \\le \\Delta t_{\\text{max}}$，从而满足稳定性要求。\n3.  **初始化：** 创建一个大小为 $N_x$ 的一维数组 `u`。用初始条件 $u(x,0) = \\sin(n\\pi x/L)$ 对其进行初始化。网格坐标 $x_i$ 可以使用 `np.linspace(0, L, Nx)` 生成。由于这个特定的初始条件选择，边界值 $u[0]$ 和 $u[N_x-1]$ 将为零，并将在计算中保持为零。\n4.  **时间演化：** 迭代 $N_t$ 次。在每一步中，根据 $t_n$ 时刻的解计算 $t_{n+1}$ 时刻的解。这是通过对内部点进行向量化更新来完成的。对于表示 $t_n$ 时刻解的数组 `u`， $t_{n+1}$ 时刻解的内部点计算如下：`u[1:-1] = u[1:-1] + r * (u[2:] - 2*u[1:-1] + u[:-2])`。NumPy会先基于旧的 `u` 值计算整个右侧表达式，创建一个临时数组，然后将结果赋给切片 `u[1:-1]`。这正确地实现了显式更新，且没有数据竞争。边界值 `u[0]` 和 `u[-1]` 保持为 $0$。\n5.  **解析解与误差：** 指定的初始条件 $u(x,0) = \\sin(n\\pi x/L)$ 是扩散算子 $\\alpha \\frac{\\partial^2}{\\partial x^2}$ 在 $[0, L]$ 上带有齐次狄利克雷边界条件的特征函数。对应的特征值为 $\\lambda_n = \\alpha (n\\pi/L)^2$。因此，解析解为：\n    $$\n    u(x,t) = e^{-\\lambda_n t} u(x,0) = e^{-\\alpha (n\\pi/L)^2 t} \\sin(n\\pi x/L)\n    $$\n    对于 $L=1$ 的测试案例，这简化为 $u(x,t) = e^{-\\alpha (n\\pi)^2 t} \\sin(n\\pi x)$。在最终时间 $T$，我们在网格上计算此解析解。\n6.  **误差计算：** 最终数值解 $u_i^{N_t}$ 与解析解 $u(x_i, T)$ 之间的离散 $L^2$ 误差是根据所提供的公式在内部点（$i=1, \\dots, N_x-2$）上计算的：\n    $$\n    \\|e\\|_2 \\approx \\sqrt{\\Delta x \\sum_{i=1}^{N_x-2} \\left(u_i^{N_t} - u(x_i, T)\\right)^2}\n    $$\n这个过程按照要求系统地推导、实现和验证了FTCS方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Forward-Time Central-Space (FTCS) method for the 1D diffusion\n    equation and computes the L2 error against an analytical solution for a\n    suite of test cases.\n    \"\"\"\n    # Test cases defined as tuples: (alpha, L, Nx, T, dt_nom, n)\n    test_cases = [\n        (0.1, 1.0, 101, 0.05, 0.0002, 1),\n        (0.1, 1.0, 51, 0.05, 1.0, 2),\n        (1.0, 1.0, 21, 0.02, 0.01, 1),\n        (0.5, 1.0, 3, 0.5, 1.0, 1),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        alpha, L, Nx, T, dt_nom, n = case\n\n        # Step 1: Grid and Parameter Setup\n        dx = L / (Nx - 1)\n        x = np.linspace(0, L, Nx)\n\n        # Step 2: Time Step Selection to enforce stability\n        # Calculate the maximum time step allowed by the stability criterion r = 0.5\n        # r = alpha * dt / dx**2  =>  dt = 0.5 * dx**2 / alpha\n        dt_stable_max = 0.5 * dx**2 / alpha\n\n        # Choose a candidate dt that respects both the nominal value and stability\n        # If dt_nom is already stable, use it. Otherwise, use the max stable dt.\n        dt_candidate = min(dt_nom, dt_stable_max)\n        \n        # Calculate the number of steps to reach final time T.\n        # np.ceil ensures we simulate for at least time T.\n        # The number of steps must be at least 1 if T > 0.\n        if T > 0:\n            num_steps = int(np.ceil(T / dt_candidate))\n        else:\n            num_steps = 0\n            \n        # Recalculate the actual dt to land exactly on T\n        dt = T / num_steps if num_steps > 0 else 0\n        \n        # Calculate the final stability ratio 'r' used in the simulation\n        r = alpha * dt / dx**2\n\n        # Step 3: Initialization\n        # Set the initial condition u(x,0) = sin(n*pi*x/L)\n        u = np.sin(n * np.pi * x / L)\n        # The homogeneous Dirichlet boundary conditions u[0]=0 and u[-1]=0 are\n        # automatically satisfied by the initial condition at x=0 and x=L.\n        # They will be maintained throughout the simulation.\n\n        # Step 4: Time Evolution using vectorized FTCS update\n        for _ in range(num_steps):\n            # The FTCS update rule for interior points is:\n            # u_i^{n+1} = u_i^n + r * (u_{i+1}^n - 2*u_i^n + u_{i-1}^n)\n            # This is vectorized using NumPy slices. NumPy evaluates the entire\n            # RHS first based on the old state of `u`, creating a temporary\n            # array, which is then assigned to the LHS slice. This correctly\n            # implements the explicit scheme.\n            u[1:-1] = u[1:-1] + r * (u[2:] - 2 * u[1:-1] + u[0:-2])\n            # Boundary conditions u[0]=0 and u[-1]=0 are preserved.\n\n        # At this point, `u` contains the final numerical solution.\n\n        # Step 5: Analytical Solution\n        # For the IC u(x,0) = sin(n*pi*x/L), the analytical solution is\n        # u(x,t) = exp(-alpha * (n*pi/L)^2 * t) * sin(n*pi*x/L)\n        eigenvalue = alpha * (n * np.pi / L)**2\n        u_analytical = np.exp(-eigenvalue * T) * np.sin(n * np.pi * x / L)\n\n        # Step 6: Error Calculation\n        # The discrete L2 error is computed over interior points only.\n        u_numerical_interior = u[1:-1]\n        u_analytical_interior = u_analytical[1:-1]\n        \n        squared_errors = (u_numerical_interior - u_analytical_interior)**2\n        l2_error = np.sqrt(dx * np.sum(squared_errors))\n        \n        results.append(l2_error)\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个数值格式被正确实现后，验证其精度是否符合理论预期至关重要。这项高级练习引入了理查森外推法 (Richardson extrapolation)，这是一种用于数值化地估计方法收敛阶的强大技术 。通过将该技术应用于你构建的 FTCS 求解器，你将能够亲自验证其在时间上的一阶精度和在空间上的二阶精度，从而更深入地理解数值误差分析。",
            "id": "3395832",
            "problem": "考虑单位区间上具有齐次狄利克雷边界条件的一维热方程（也称为扩散方程），\n$$\nu_t(x,t) = \\alpha\\,u_{xx}(x,t),\\quad x\\in(0,1),\\ t\\in(0,T],\n$$\n数据如下\n$$\nu(0,t)=0,\\quad u(1,t)=0,\\quad u(x,0)=\\sin(\\pi x),\\quad \\alpha=1.\n$$\n对于此问题，通过分离变量法可知其精确解为：\n$$\nu(x,t) = e^{-\\pi^2 t}\\,\\sin(\\pi x).\n$$\n任务是使用前向时间中心空间 (FTCS) 方法对该初边值问题进行离散化，该方法根据定义在均匀网格上对 $u_t$ 使用时间前向有限差分，对 $u_{xx}$ 使用空间中心有限差分。您必须在适用于热方程的 FTCS 方法的 Courant–Friedrichs–Lewy (CFL) 稳定性约束下，实现显式格式。在所有时间步长中，直接在端点使用狄利克雷边界值。不要使用任何隐式时间步进法。\n\n您将对一组精心选择的网格应用理查森外推法，以完成以下操作：\n- 在选定点估计真实解的误差，\n- 验证 FTCS 方法在时间上的一阶精度和在空间上的二阶精度。\n\n所有计算必须以最终时间 $T = 0.01$（即 $T = 0.01$ 秒）为目标。空间和时间网格必须是均匀的，并且每次运行时，时间推进必须在 $t=T$ 处以恒定的时间步长精确结束。\n\n使用的定义：\n- 前向时间中心空间 (FTCS) 方法在均匀网格上采用时间前向差分和空间中心差分。\n- 一维热方程的 Courant–Friedrichs–Lewy (CFL) 数为 $\\lambda = \\alpha\\,\\Delta t/\\Delta x^2$。\n\n您必须实现以下测试套件。对于每个测试，使用上述精确解来评估指定位置的参考值。\n\n测试 1（在固定精细空间上通过理查森外推法确定时间阶）：\n- 区域长度 $L=1$。\n- 最终时间 $T=0.01$。\n- 扩散系数 $\\alpha=1$。\n- 空间网格：选择 $N_x = 400$ 个均匀子区间，因此 $\\Delta x = 1/N_x$。\n- 选择目标 CFL 数 $\\lambda_0 = 0.4$ 并设置粗略时间步长 $\\Delta t_0 = \\lambda_0 \\Delta x^2$。\n- 构建两个时间上的加密，加密比为 $r_t=2$：$\\Delta t_1 = \\Delta t_0/2$，$\\Delta t_2 = \\Delta t_1/2$，确保对于 $i\\in\\{0,1,2\\}$，$T/\\Delta t_i$ 是一个整数。\n- 使用相同的空间网格，对三个时间步长分别将 FTCS 格式演化到 $t=T$，并记录在空间位置 $x^\\star=0.5$ 处的数值解 $U_{\\Delta t_0}$、$U_{\\Delta t_1}$、$U_{\\Delta t_2}$。\n- 使用加密因子 $r_t=2$ 的理查森外推法，从这三个近似值中估计观测到的时间阶 $p_t$。报告标量值 $p_t$ 以及一个布尔值，断言 $|p_t-1|\\le 0.05$ 是否成立。\n\n测试 2（在近似恒定的 CFL 下通过理查森外推法确定空间阶）：\n- 区域长度 $L=1$。\n- 最终时间 $T=0.01$。\n- 扩散系数 $\\alpha=1$。\n- 使用三个嵌套的空间网格，其中 $N_x\\in\\{50,100,200\\}$，因此 $\\Delta x_h=1/N_x$，$\\Delta x_{h/2} = \\Delta x_h/2$，$\\Delta x_{h/4}=\\Delta x_h/4$。\n- 对于每个空间网格，选择时间步数 $N_t$ 为 $N_t = \\left\\lceil T/(0.49\\,\\Delta x^2)\\right\\rceil$ 并取 $\\Delta t = T/N_t$，以使得到的 CFL 数满足 $\\lambda\\le 0.49$。\n- 在每个网格上将 FTCS 格式演化到 $t=T$，并记录在公共空间位置 $x^\\star=0.3$ 处的数值 $U_h$、$U_{h/2}$、$U_{h/4}$。\n- 使用加密因子 $r_x=2$ 的理查森外推法，从这三个近似值中估计观测到的空间阶 $p_x$。报告标量值 $p_x$ 以及一个布尔值，断言 $|p_x-2|\\le 0.1$ 是否成立。\n\n测试 3（两阶段理查森外推法以估计某一点的真实解）：\n- 区域长度 $L=1$。\n- 最终时间 $T=0.01$。\n- 扩散系数 $\\alpha=1$。\n- 空间网格：粗网格 $N_x^{(c)}=50$ 和细网格 $N_x^{(f)}=100$。\n- 对于每个空间网格，独立选择基准时间步数\n$$\nN_t^{(c)}=\\left\\lceil \\frac{T}{0.4\\,(\\Delta x^{(c)})^2}\\right\\rceil,\\quad N_t^{(f)}=\\left\\lceil \\frac{T}{0.4\\,(\\Delta x^{(f)})^2}\\right\\rceil,\n$$\n并定义加密后的步数 $2N_t^{(c)}$ 和 $2N_t^{(f)}$，以在固定空间上生成减半的时间步长。\n- 对于每个空间网格，用时间步长 $\\Delta t$ 和 $\\Delta t/2$ 计算 $t=T$ 时的两个 FTCS 解，并使用加密因子为 2 的时间理查森外推法，在粗、细空间网格上形成时间外推的近似值。然后，在空间上执行第二个加密因子为 2 的理查森外推步骤（即，在时间外推的粗、细解之间），以获得在 $x^\\star=0.3$ 处 $u(x^\\star,T)$ 的两阶段外推估计。\n- 计算这个两阶段外推估计值相对于 $(x^\\star,T)$ 处精确解的绝对误差，并报告此标量误差。\n\n您的程序必须按以下顺序计算上述五个输出：\n1. 测试 1 中估计的时间阶 $p_t$。\n2. 一个布尔值，说明 $|p_t-1|\\le 0.05$ 是否成立。\n3. 测试 2 中估计的空间阶 $p_x$。\n4. 一个布尔值，说明 $|p_x-2|\\le 0.1$ 是否成立。\n5. 测试 3 的绝对误差。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$）。第一、三、五个条目必须是实数（浮点数），第二和第四个条目必须是布尔值。不应打印任何其他文本。",
            "solution": "该问题是有效的。这是一个适定的、科学上合理的数值分析练习，涉及将前向时间中心空间 (FTCS) 方法应用于一维热方程。所有参数和过程都定义清晰且一致。\n\n解决方案分三个阶段进行：首先，推导数值格式；其次，制定用于分析该格式精度的理查森外推法程序；第三，逐步执行问题陈述中指定的三个计算测试。\n\n### 1. FTCS 离散化\n\n控制偏微分方程 (PDE) 是一维热方程：\n$$\nu_t(x,t) = \\alpha\\,u_{xx}(x,t), \\quad x \\in (0, 1), \\ t \\in (0, T]\n$$\n其中扩散系数 $\\alpha=1$，最终时间 $T=0.01$，齐次狄利克雷边界条件 $u(0,t)=u(1,t)=0$，以及初始条件 $u(x,0)=\\sin(\\pi x)$。\n\n为离散化该方程，我们在空间和时间上定义一个均匀网格。空间域 $[0,1]$ 被划分为 $N_x$ 个宽度为 $\\Delta x = 1/N_x$ 的子区间，从而得到网格点 $x_j = j \\Delta x$，$j=0, 1, \\dots, N_x$。时间区间 $[0,T]$ 被划分为 $N_t$ 个时长为 $\\Delta t = T/N_t$ 的步，从而得到时间层级 $t_n = n \\Delta t$，$n=0, 1, \\dots, N_t$。令 $U_j^n$ 为精确解 $u(x_j, t_n)$ 的数值近似。\n\nFTCS 方法对时间导数使用前向差分，对空间导数使用二阶中心差分：\n$$\n\\frac{u(x_j, t_{n+1}) - u(x_j, t_n)}{\\Delta t} \\approx u_t(x_j, t_n)\n$$\n$$\n\\frac{u(x_{j-1}, t_n) - 2u(x_j, t_n) + u(x_{j+1}, t_n)}{\\Delta x^2} \\approx u_{xx}(x_j, t_n)\n$$\n将这些近似值代入 PDE，得到 FTCS 有限差分方程：\n$$\n\\frac{U_j^{n+1} - U_j^n}{\\Delta t} = \\alpha \\frac{U_{j+1}^n - 2U_j^n - U_{j-1}^n}{\\Delta x^2}\n$$\n重新整理以求解下一时间步的解 $U_j^{n+1}$，得到显式更新公式：\n$$\nU_j^{n+1} = U_j^n + \\alpha \\frac{\\Delta t}{\\Delta x^2} (U_{j+1}^n - 2U_j^n + U_{j-1}^n)\n$$\n通过将热方程的 Courant–Friedrichs–Lewy (CFL) 数定义为 $\\lambda = \\alpha \\Delta t / \\Delta x^2$，该公式可以写得更紧凑：\n$$\nU_j^{n+1} = \\lambda U_{j-1}^n + (1 - 2\\lambda)U_j^n + \\lambda U_{j+1}^n\n$$\n此更新规则应用于所有内部网格点 $j=1, 2, \\dots, N_x-1$。众所周知，该格式仅在满足 CFL 条件 $\\lambda \\le 1/2$ 时才稳定。问题指定的 CFL 数 $\\lambda=0.4$ 和 $\\lambda\\le0.49$ 均在此稳定区域内。\n\n边界值在所有时间上都是固定的：对于所有 $n$，$U_0^n = 0$ 且 $U_{N_x}^n = 0$。数值解的初始状态由初始条件设定：$U_j^0 = \\sin(\\pi x_j)$，对于 $j=0, 1, \\dots, N_x$。\n\n### 2. 理查森外推法\n\n理查森外推法是一种估计数值方法误差并获得更精确近似值的技术。如果一个数值方法产生一个依赖于步长 $h$ 的近似值 A(h)，且其误差展开式为 $A(h) = A_{\\text{exact}} + C h^p + O(h^{p+k})$（其中 $k0$），我们可以使用多次计算来分析此误差。\n\n**阶的估计：** 使用步长为 $h$、$h/r$ 和 $h/r^2$（其中 $r$ 是加密因子）计算出的三个近似值，可以估计观测到的收敛阶 $p$ 为：\n$$\np \\approx \\log_r \\left( \\frac{A(h) - A(h/r)}{A(h/r) - A(h/r^2)} \\right)\n$$\n**误差消除：** 使用两个近似值 $A(h)$ 和 $A(h/r)$，可以通过消除主误差项来推导出一个更精确的估计值 $A_{\\text{extra}}$：\n$$\nA_{\\text{extra}} = \\frac{r^p A(h/r) - A(h)}{r^p - 1}\n$$\n\n### 3. 执行测试套件\n\n基于推导出的更新规则实现了一个 FTCS 求解器。然后使用此求解器执行三个测试。\n\n**测试 1：时间精度阶**\n目标是验证 FTCS 方法在时间上的一阶精度，即 $p_t=1$。空间网格固定为 $N_x=400$ 个子区间（$\\Delta x = 1/400$），这使得空间离散化误差保持恒定且较小。用连续加密的时间步长运行三次模拟直到时间 $T=0.01$。\n- 网格参数：$N_x = 400$。关注点是 $x^\\star=0.5$，对应于网格索引 $j=200$。\n- 时间步长：使用基准 CFL 数 $\\lambda_0 = 0.4$ 定义粗略时间步长 $\\Delta t_0 = \\lambda_0 \\Delta x^2 = 0.4 \\times (1/400)^2$。这得到 $N_{t,0} = T/\\Delta t_0 = 4000$ 个时间步。再运行两次加密的模拟，步数分别为 $N_{t,1} = 2N_{t,0} = 8000$ 和 $N_{t,2} = 4N_{t,0} = 16000$。加密因子为 $r_t=2$。\n- 设 $U_{\\Delta t_0}$、$U_{\\Delta t_1}$、$U_{\\Delta t_2}$ 是三个时间步长在 $x^\\star=0.5$ 处的数值解。观测到的时间阶 $p_t$ 使用 $r=2$ 的阶估计公式计算：\n$$\np_t = \\log_2 \\left( \\frac{U_{\\Delta t_0} - U_{\\Delta t_1}}{U_{\\Delta t_1} - U_{\\Delta t_2}} \\right)\n$$\n$p_t$ 的值预期接近 $1$。检查条件 $|p_t-1|\\le 0.05$ 是否满足。\n\n**测试 2：空间精度阶**\n目标是验证在空间上的二阶精度，即 $p_x=2$。在嵌套的空间网格上运行三次模拟，其中 $N_x \\in \\{50, 100, 200\\}$，因此加密因子为 $r_x=2$。关注点是 $x^\\star=0.3$，在各自网格上对应于索引 $j \\in \\{15, 30, 60\\}$。\n- 为分离空间误差，通过选择足够小的 $\\Delta t$ 使其与 $\\Delta x^2$ 成比例来抑制时间误差的贡献。对于每个网格，时间步数设置为 $N_t = \\lceil T/(0.49 \\Delta x^2) \\rceil$，保持 $\\lambda \\le 0.49$。对于粗、中、细网格，这分别得到 $N_t$ 值为 $52$、$205$ 和 $817$。\n- 设 $U_h$、$U_{h/2}$、$U_{h/4}$ 为在 $x^\\star=0.3$ 处的数值解。观测到的空间阶 $p_x$ 计算如下：\n$$\np_x = \\log_2 \\left( \\frac{U_h - U_{h/2}}{U_{h/2} - U_{h/4}} \\right)\n$$\n$p_x$ 的值预期接近 $2$。检查条件 $|p_x-2|\\le 0.1$ 是否满足。\n\n**测试 3：两阶段理查森外推法**\n此测试展示了通过在时间和空间上顺序外推来提高解的精度。\n- **阶段 1（时间外推）：**\n    - 在粗空间网格（$N_x^{(c)}=50$）上，分别使用 $N_t = 63$ 和 $N_t = 126$ 个时间步，计算在 $x^\\star=0.3$ 处的两个解 $A_{c,1}$ 和 $A_{c,2}$。使用 $p=1$ 和 $r=2$ 计算时间外推值 $A_c^{\\text{extra}}$：$A_c^{\\text{extra}} = 2A_{c,2} - A_{c,1}$。\n    - 在细空间网格（$N_x^{(f)}=100$）上，分别使用 $N_t = 250$ 和 $N_t = 500$ 个时间步，计算在 $x^\\star=0.3$ 处的两个解 $A_{f,1}$ 和 $A_{f,2}$。计算时间外推值 $A_f^{\\text{extra}}$：$A_f^{\\text{extra}} = 2A_{f,2} - A_{f,1}$。\n- **阶段 2（空间外推）：**\n    - 这两个时间外推解 $A_c^{\\text{extra}}$（在步长为 $\\Delta x^{(c)}$ 的网格上）和 $A_f^{\\text{extra}}$（在步长为 $\\Delta x^{(f)} = \\Delta x^{(c)}/2$ 的网格上），它们本身被视为近似值，其主导误差是空间的，且阶数为 $p=2$。使用 $p=2$ 和 $r=2$ 的空间理查森外推法计算最终的更高精度估计值 $A^{\\text{final}}$：\n    $$\n    A^{\\text{final}} = \\frac{2^2 A_f^{\\text{extra}} - A_c^{\\text{extra}}}{2^2 - 1} = \\frac{4A_f^{\\text{extra}} - A_c^{\\text{extra}}}{3}\n    $$\n- **误差计算：** 计算这个两阶段外推值相对于在 $x^\\star=0.3$ 和 $T=0.01$ 处的精确解 $u(x^\\star, T) = e^{-\\pi^2 T} \\sin(\\pi x^\\star)$ 的绝对误差。此误差是本测试最终报告的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ftcs_solver(L, T, alpha, Nx, Nt):\n    \"\"\"\n    Solves the 1D heat equation u_t = alpha * u_xx with homogeneous Dirichlet BCs\n    using the Forward-Time Central-Space (FTCS) method.\n\n    Args:\n        L (float): Domain length.\n        T (float): Final time.\n        alpha (float): Diffusion coefficient.\n        Nx (int): Number of spatial subintervals.\n        Nt (int): Number of time steps.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The spatial grid points.\n            - np.ndarray: The numerical solution U at the final time T.\n    \"\"\"\n    dx = L / Nx\n    dt = T / Nt\n    lam = alpha * dt / dx**2\n\n    # As per the problem, all lambda values are within the stability limit.\n    # if lam > 0.5:\n    #     raise ValueError(\"Stability condition violated: lambda > 0.5\")\n\n    x = np.linspace(0, L, Nx + 1)\n    \n    # Initial condition\n    U = np.sin(np.pi * x / L)\n\n    # Time-marching loop\n    for _ in range(Nt):\n        U_old = U.copy()\n        # Vectorized update for interior points\n        U[1:-1] = U_old[1:-1] + lam * (U_old[0:-2] - 2 * U_old[1:-1] + U_old[2:])\n        # BCs u(0,t)=0 and u(L,t)=0 are maintained as U[0] and U[Nx] are not updated.\n    \n    return x, U\n\ndef solve():\n    \"\"\"\n    Executes the three tests described in the problem statement and prints the results.\n    \"\"\"\n    # Common parameters\n    L = 1.0\n    T = 0.01\n    alpha = 1.0\n\n    # --- Test 1: Temporal Order of Accuracy ---\n    Nx_t = 400\n    x_star_t = 0.5\n    idx_t = int(x_star_t * Nx_t / L)\n    \n    dx_t = L / Nx_t\n    lam0_t = 0.4\n    dt0_t = lam0_t * dx_t**2\n    \n    Nt0_t = int(round(T / dt0_t))\n    Nt1_t = 2 * Nt0_t\n    Nt2_t = 4 * Nt0_t\n    \n    _, U0_t = ftcs_solver(L, T, alpha, Nx_t, Nt0_t)\n    _, U1_t = ftcs_solver(L, T, alpha, Nx_t, Nt1_t)\n    _, U2_t = ftcs_solver(L, T, alpha, Nx_t, Nt2_t)\n    \n    sol_0 = U0_t[idx_t]\n    sol_1 = U1_t[idx_t]\n    sol_2 = U2_t[idx_t]\n    \n    # Richardson extrapolation for order p\n    ratio_t = (sol_0 - sol_1) / (sol_1 - sol_2)\n    p_t = np.log2(ratio_t) if ratio_t > 0 else -1.0 # Avoid log of non-positive\n    is_pt_valid = abs(p_t - 1.0) = 0.05\n\n    # --- Test 2: Spatial Order of Accuracy ---\n    x_star_x = 0.3\n    Nx_vals_x = [50, 100, 200]\n    sols_x = []\n\n    for Nx in Nx_vals_x:\n        dx = L / Nx\n        # Calculate Nt to keep lambda = 0.49\n        Nt = int(np.ceil(T / (0.49 * dx**2)))\n        idx = int(x_star_x * Nx / L)\n        \n        _, U = ftcs_solver(L, T, alpha, Nx, Nt)\n        sols_x.append(U[idx])\n\n    ratio_x = (sols_x[0] - sols_x[1]) / (sols_x[1] - sols_x[2])\n    p_x = np.log2(ratio_x) if ratio_x > 0 else -1.0 # Avoid log of non-positive\n    is_px_valid = abs(p_x - 2.0) = 0.1\n\n    # --- Test 3: Two-Stage Richardson Extrapolation ---\n    x_star_e = 0.3\n\n    # Coarse spatial grid calculations\n    Nx_c = 50\n    dx_c = L / Nx_c\n    idx_c = int(x_star_e * Nx_c / L)\n    Nt_c1 = int(np.ceil(T / (0.4 * dx_c**2)))\n    Nt_c2 = 2 * Nt_c1\n    _, U_c1 = ftcs_solver(L, T, alpha, Nx_c, Nt_c1)\n    _, U_c2 = ftcs_solver(L, T, alpha, Nx_c, Nt_c2)\n    sol_c1 = U_c1[idx_c]\n    sol_c2 = U_c2[idx_c]\n    # Time extrapolation (p=1, r=2)\n    sol_c_extra = (2.0 * sol_c2 - sol_c1)\n\n    # Fine spatial grid calculations\n    Nx_f = 100\n    dx_f = L / Nx_f\n    idx_f = int(x_star_e * Nx_f / L)\n    Nt_f1 = int(np.ceil(T / (0.4 * dx_f**2)))\n    Nt_f2 = 2 * Nt_f1\n    _, U_f1 = ftcs_solver(L, T, alpha, Nx_f, Nt_f1)\n    _, U_f2 = ftcs_solver(L, T, alpha, Nx_f, Nt_f2)\n    sol_f1 = U_f1[idx_f]\n    sol_f2 = U_f2[idx_f]\n    # Time extrapolation (p=1, r=2)\n    sol_f_extra = (2.0 * sol_f2 - sol_f1)\n\n    # Space extrapolation (p=2, r=2)\n    sol_final = (4.0 * sol_f_extra - sol_c_extra) / 3.0\n\n    # Exact solution\n    u_exact = np.exp(-alpha * np.pi**2 * T) * np.sin(np.pi * x_star_e / L)\n\n    # Absolute error of the two-stage extrapolated estimate\n    error_e = abs(sol_final - u_exact)\n\n    # Final results assembly\n    results = [p_t, is_pt_valid, p_x, is_px_valid, error_e]\n\n    # Print in the required format\n    # The boolean values are lowercased for Python to string conversion.\n    # The final output format does not specify case, so this is fine.\n    print(f\"[{','.join(map(str, [p_t, str(is_pt_valid), p_x, str(is_px_valid), error_e]))}]\".replace(\"True\",\"true\").replace(\"False\", \"false\"))\n\nsolve()\n```"
        }
    ]
}