{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any reliable time-dependent simulation is numerical stability. For explicit methods like the Forward-Time, Centered-Space (FTCS) scheme, the choice of time step $\\Delta t$ is not arbitrary; it is strictly limited by the spatial grid spacing. This foundational exercise guides you through a von Neumann stability analysis to derive this critical constraint from first principles, revealing how the maximum allowable time step depends on the thermal diffusivity $\\kappa$ and the grid spacings $h_x$ and $h_y$. Understanding this relationship is the first step toward building robust and accurate simulations of diffusion processes .",
            "id": "3393371",
            "problem": "Consider the constant-coefficient two-dimensional heat equation\n$$\nu_{t}=\\kappa\\left(u_{xx}+u_{yy}\\right),\n$$\nposed on a doubly periodic rectangular domain, where $\\kappa>0$ is the thermal diffusivity. Let the domain be covered by a uniform Cartesian grid with spacings $h_{x}$ and $h_{y}$ in the $x$- and $y$-directions, respectively, and let time be advanced with step $\\Delta t$. Discretize $u_{xx}$ and $u_{yy}$ by standard centered second-order finite differences and advance in time by forward Euler, yielding an explicit update at each interior grid point $(i,j)$ of the form\n$$\nu^{n+1}_{i,j}=u^{n}_{i,j}+\\kappa\\,\\Delta t\\left(\\frac{u^{n}_{i+1,j}-2u^{n}_{i,j}+u^{n}_{i-1,j}}{h_{x}^{2}}+\\frac{u^{n}_{i,j+1}-2u^{n}_{i,j}+u^{n}_{i,j-1}}{h_{y}^{2}}\\right).\n$$\nUsing von Neumann (Fourier) stability analysis from first principles, determine which discrete Fourier mode is the most restrictive for stability when $h_{x}\\neq h_{y}$, and derive the corresponding sharp stability constraint on $\\Delta t$ that ensures no amplification in magnitude of any mode in a single time step. Express your final result as a closed-form analytic expression for the maximum allowable time step $\\Delta t_{\\max}$ in terms of $h_{x}$, $h_{y}$, and $\\kappa$. Express $\\Delta t_{\\max}$ in seconds. No numerical evaluation or rounding is required.",
            "solution": "The problem statement is evaluated for validity.\n\n### Step 1: Extract Givens\n- **Partial Differential Equation**: The constant-coefficient two-dimensional heat equation is $u_{t}=\\kappa\\left(u_{xx}+u_{yy}\\right)$, with $\\kappa>0$.\n- **Domain**: A doubly periodic rectangular domain.\n- **Discretization Parameters**: Uniform Cartesian grid with spacings $h_{x}$ and $h_{y}$ in the $x$- and $y$-directions, respectively. Time is advanced with step $\\Delta t$. It is specified that $h_x \\neq h_y$.\n- **Numerical Scheme**: The spatial derivatives $u_{xx}$ and $u_{yy}$ are discretized using standard centered second-order finite differences. The time integration is performed using the forward Euler method.\n- **Finite Difference Equation**: The resulting explicit update rule is given as:\n$u^{n+1}_{i,j}=u^{n}_{i,j}+\\kappa\\,\\Delta t\\left(\\frac{u^{n}_{i+1,j}-2u^{n}_{i,j}+u^{n}_{i-1,j}}{h_{x}^{2}}+\\frac{u^{n}_{i,j+1}-2u^{n}_{i,j}+u^{n}_{i,j-1}}{h_{y}^{2}}\\right)$.\n- **Analysis Method**: The analysis is to be conducted using von Neumann (Fourier) stability analysis from first principles.\n- **Objective**: Determine the most restrictive Fourier mode for stability and derive the corresponding sharp stability constraint on the maximum allowable time step, $\\Delta t_{\\max}$, in terms of $h_{x}$, $h_{y}$, and $\\kappa$. The result for $\\Delta t_{\\max}$ is to be expressed in seconds.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is a canonical example in the field of numerical analysis for partial differential equations. The heat equation, the FTCS (Forward-Time Centered-Space) discretization, and von Neumann stability analysis are all standard, well-established concepts. The problem is scientifically and mathematically sound.\n- **Well-Posed**: The problem is well-posed. It provides all necessary information (the PDE, the discretization scheme, the analysis method) to derive a unique and meaningful stability criterion.\n- **Objective**: The problem is stated using precise and unambiguous mathematical language. There are no subjective or opinion-based elements.\n- **Other Flaws**: The problem setup is complete, consistent, realistic (within the context of numerical analysis), and non-trivial. It does not violate any of the criteria for a valid problem. The mention of expressing the final answer in seconds implies that the input parameters $\\kappa$, $h_x$, and $h_y$ should be considered in a consistent set of units (e.g., SI units), such that the resulting time step is naturally in seconds. This does not constitute a flaw.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\nThe stability of the given finite difference scheme is analyzed using the von Neumann method. This method examines the time evolution of individual Fourier modes of the solution. We consider a single generic Fourier mode on the computational grid $(x_i, y_j) = (i h_x, j h_y)$ of the form:\n$$\nu^n_{i,j} = \\hat{u}^n(k_x, k_y) \\exp(I(k_x x_i + k_y y_j)) = \\hat{u}^n \\exp(I(k_x i h_x + k_y j h_y))\n$$\nwhere $n$ is the time level index, $(i,j)$ are the spatial grid indices, $k_x$ and $k_y$ are the wave numbers in the $x$- and $y$-directions, respectively, $\\hat{u}^n$ is the amplitude of the mode at time level $n$, and $I = \\sqrt{-1}$ is the imaginary unit.\n\nThe amplitude at the next time step, $\\hat{u}^{n+1}$, is related to the current amplitude by the amplification factor $G(k_x, k_y)$:\n$$\n\\hat{u}^{n+1} = G(k_x, k_y) \\hat{u}^n\n$$\nFor the numerical scheme to be stable, the magnitude of the amplification factor must not exceed $1$ for any possible wave numbers, i.e., $|G(k_x, k_y)| \\le 1$.\n\nWe substitute the Fourier mode ansatz into the finite difference equation:\n$$\n\\hat{u}^{n+1} \\exp(I(k_x i h_x + k_y j h_y)) = \\hat{u}^{n} \\exp(I(k_x i h_x + k_y j h_y)) + \\kappa \\Delta t \\left( \\frac{\\hat{u}^n \\left(e^{I k_x (i+1)h_x} - 2e^{I k_x i h_x} + e^{I k_x (i-1)h_x}\\right)e^{I k_y j h_y}}{h_x^2} + \\frac{\\hat{u}^n \\left(e^{I k_y (j+1)h_y} - 2e^{I k_y j h_y} + e^{I k_y (j-1)h_y}\\right)e^{I k_x i h_x}}{h_y^2} \\right)\n$$\nDividing by $\\hat{u}^n \\exp(I(k_x i h_x + k_y j h_y))$ and using $\\hat{u}^{n+1}/\\hat{u}^n = G$, we obtain an expression for the amplification factor:\n$$\nG = 1 + \\kappa \\Delta t \\left( \\frac{e^{I k_x h_x} - 2 + e^{-I k_x h_x}}{h_x^2} + \\frac{e^{I k_y h_y} - 2 + e^{-I k_y h_y}}{h_y^2} \\right)\n$$\nUsing the identity $e^{I\\theta} + e^{-I\\theta} = 2\\cos(\\theta)$, the expression becomes:\n$$\nG = 1 + \\kappa \\Delta t \\left( \\frac{2\\cos(k_x h_x) - 2}{h_x^2} + \\frac{2\\cos(k_y h_y) - 2}{h_y^2} \\right)\n$$\nFactoring out $-2$ and using the half-angle identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$, we get:\n$$\nG = 1 - 2\\kappa \\Delta t \\left( \\frac{1 - \\cos(k_x h_x)}{h_x^2} + \\frac{1 - \\cos(k_y h_y)}{h_y^2} \\right)\n$$\n$$\nG(k_x, k_y) = 1 - 4\\kappa \\Delta t \\left( \\frac{\\sin^2(k_x h_x / 2)}{h_x^2} + \\frac{\\sin^2(k_y h_y / 2)}{h_y^2} \\right)\n$$\nSince $\\kappa > 0$, $\\Delta t > 0$, and the sine-squared terms are non-negative, the amplification factor $G$ is always real and less than or equal to $1$. The stability condition $|G| \\le 1$ thus simplifies to the single inequality $G \\ge -1$:\n$$\n1 - 4\\kappa \\Delta t \\left( \\frac{\\sin^2(k_x h_x / 2)}{h_x^2} + \\frac{\\sin^2(k_y h_y / 2)}{h_y^2} \\right) \\ge -1\n$$\n$$\n2 \\ge 4\\kappa \\Delta t \\left( \\frac{\\sin^2(k_x h_x / 2)}{h_x^2} + \\frac{\\sin^2(k_y h_y / 2)}{h_y^2} \\right)\n$$\nSolving for $\\Delta t$, we have:\n$$\n\\Delta t \\le \\frac{2}{4\\kappa \\left( \\frac{\\sin^2(k_x h_x / 2)}{h_x^2} + \\frac{\\sin^2(k_y h_y / 2)}{h_y^2} \\right)} = \\frac{1}{2\\kappa \\left( \\frac{\\sin^2(k_x h_x / 2)}{h_x^2} + \\frac{\\sin^2(k_y h_y / 2)}{h_y^2} \\right)}\n$$\nThis inequality must hold for all possible wave numbers $k_x$ and $k_y$. To find the most restrictive constraint on $\\Delta t$, we must find the minimum value of the right-hand side. This occurs when the denominator is at its maximum. The term to be maximized is $\\frac{\\sin^2(k_x h_x / 2)}{h_x^2} + \\frac{\\sin^2(k_y h_y / 2)}{h_y^2}$.\n\nThe maximum value of the function $\\sin^2(\\theta)$ is $1$. This maximum is achieved when we select the wave numbers that maximize both $\\sin^2(k_x h_x/2)$ and $\\sin^2(k_y h_y/2)$ simultaneously. This occurs for the highest frequency modes the grid can resolve, which correspond to:\n$$\nk_x h_x / 2 = \\frac{\\pi}{2} \\implies k_x = \\frac{\\pi}{h_x}\n$$\n$$\nk_y h_y / 2 = \\frac{\\pi}{2} \\implies k_y = \\frac{\\pi}{h_y}\n$$\nThese modes, characterized by alternating signs at adjacent grid points, are the most restrictive for stability. Substituting $\\sin^2(k_x h_x/2) = 1$ and $\\sin^2(k_y h_y/2) = 1$ into the inequality yields the sharp stability bound:\n$$\n\\Delta t \\le \\frac{1}{2\\kappa \\left( \\frac{1}{h_x^2} + \\frac{1}{h_y^2} \\right)}\n$$\nThe maximum allowable time step, $\\Delta t_{\\max}$, is therefore:\n$$\n\\Delta t_{\\max} = \\frac{1}{2\\kappa \\left( \\frac{1}{h_x^2} + \\frac{1}{h_y^2} \\right)}\n$$\nThis expression can be simplified by combining the terms in the denominator:\n$$\n\\Delta t_{\\max} = \\frac{1}{2\\kappa \\left( \\frac{h_y^2 + h_x^2}{h_x^2 h_y^2} \\right)} = \\frac{h_x^2 h_y^2}{2\\kappa (h_x^2 + h_y^2)}\n$$\nThis is the final analytical expression for the maximum stable time step. If the physical quantities $\\kappa$, $h_x$, and $h_y$ are given in SI units (m$^2$/s for $\\kappa$, and m for $h_x$ and $h_y$), then the resulting $\\Delta t_{\\max}$ will have units of seconds, as requested.",
            "answer": "$$\n\\boxed{\\frac{h_{x}^{2} h_{y}^{2}}{2 \\kappa (h_{x}^{2} + h_{y}^{2})}}\n$$"
        },
        {
            "introduction": "While explicit methods are simple to implement, their restrictive stability constraints can make them inefficient for stiff problems, such as those with fine spatial grids or high diffusivity. Implicit methods, such as Backward Euler and Crank-Nicolson, overcome this limitation by being unconditionally stable. However, stability alone is not the whole story; their ability to damp high-frequency numerical oscillations is also critical. This hands-on coding practice allows you to directly compare the L-stable Backward Euler method with the A-stable Crank-Nicolson scheme, observing how they handle the stiffest discrete mode and demonstrating why strong numerical dissipation is often a desirable property for robust simulations .",
            "id": "3393393",
            "problem": "Consider the two-dimensional heat equation on the unit square with homogeneous Dirichlet boundary conditions, given by $u_t = \\alpha \\Delta u$ on $\\Omega = (0,1)\\times(0,1)$, with $u=0$ on $\\partial\\Omega$ and initial condition $u(x,y,0) = u_0(x,y)$. Let a uniform Cartesian finite difference (FD) grid be defined using $N$ interior points along each coordinate direction, so the grid spacing is $h = 1/(N+1)$ and the interior grid indices are $i=1,\\dots,N$ and $j=1,\\dots,N$. Let the five-point FD Laplacian be used for the spatial discretization, yielding the semi-discrete system $U'(t) = \\alpha A U(t)$, where $U(t)\\in\\mathbb{R}^{N^2}$ is the vector of interior nodal values and $A\\in\\mathbb{R}^{N^2\\times N^2}$ is the FD Laplacian matrix with homogeneous Dirichlet boundary conditions.\n\nTwo implicit one-step time discretizations are to be contrasted:\n\n- The backward Euler method (also called implicit Euler), which advances $U^0$ to $U^1$ over one step of size $\\Delta t$ via $(I - \\Delta t\\,\\alpha A)\\,U^1 = U^0$.\n\n- The Crank–Nicolson (CN) method, which advances $U^0$ to $U^1$ over one step of size $\\Delta t$ via $(I - \\tfrac{1}{2}\\Delta t\\,\\alpha A)\\,U^1 = (I + \\tfrac{1}{2}\\Delta t\\,\\alpha A)\\,U^0$.\n\nTo isolate and measure the behavior on very stiff components, let the initial condition be chosen as the highest-frequency discrete Dirichlet eigenmode on the FD grid, namely $u^0_{i,j} = \\sin\\!\\big(\\tfrac{i N \\pi}{N+1}\\big)\\,\\sin\\!\\big(\\tfrac{j N \\pi}{N+1}\\big)$ for $i=1,\\dots,N$, $j=1,\\dots,N$, flattened into $U^0\\in\\mathbb{R}^{N^2}$. Denote by $v\\in\\mathbb{R}^{N^2}$ this discrete eigenmode vector. After applying a single time step with each method, define the measured amplification magnitude of the high-frequency component by projection onto $v$:\n$$\nr_{\\mathrm{BE}} = \\left|\\frac{v^\\top U^1_{\\mathrm{BE}}}{v^\\top U^0}\\right|,\\qquad\nr_{\\mathrm{CN}} = \\left|\\frac{v^\\top U^1_{\\mathrm{CN}}}{v^\\top U^0}\\right|.\n$$\nThese quantities capture the decay (or lack thereof) of the stiffest mode under each scheme. All quantities are dimensionless.\n\nImplement a program that constructs $A$ using the five-point FD Laplacian with homogeneous Dirichlet boundary conditions, builds the initial eigenmode $v$, performs one time step with both backward Euler and Crank–Nicolson for each test parameter set, and outputs the measured amplification magnitudes $r_{\\mathrm{BE}}$ and $r_{\\mathrm{CN}}$ as specified below.\n\nUse the following test suite, which explores a boundary case and increasingly stiff regimes:\n- Test $1$: $N=64$, $\\alpha=1$, $\\Delta t = 0$.\n- Test $2$: $N=64$, $\\alpha=1$, $\\Delta t = 10^{-4}$.\n- Test $3$: $N=64$, $\\alpha=1$, $\\Delta t = 10^{-3}$.\n- Test $4$: $N=64$, $\\alpha=1$, $\\Delta t = 10^{-2}$.\n\nFor each test, compute $r_{\\mathrm{BE}}$ and $r_{\\mathrm{CN}}$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[r_{\\mathrm{BE}}^{(1)}, r_{\\mathrm{CN}}^{(1)}, r_{\\mathrm{BE}}^{(2)}, r_{\\mathrm{CN}}^{(2)}, r_{\\mathrm{BE}}^{(3)}, r_{\\mathrm{CN}}^{(3)}, r_{\\mathrm{BE}}^{(4)}, r_{\\mathrm{CN}}^{(4)}]$, where the superscript denotes the test index. Each entry must be a floating-point number.",
            "solution": "The problem statement has been meticulously validated and is determined to be valid. It is scientifically grounded, well-posed, and objective, presenting a standard problem in the numerical solution of partial differential equations. All necessary data and definitions are provided, and there are no internal contradictions or ambiguities.\n\nThe problem requires a comparison of the Backward Euler (BE) and Crank–Nicolson (CN) time-stepping schemes for the two-dimensional heat equation, $u_t = \\alpha \\Delta u$, on a unit square domain $\\Omega=(0,1)\\times(0,1)$ with homogeneous Dirichlet boundary conditions. The spatial discretization is performed using a five-point finite difference (FD) stencil on a uniform grid with $N$ interior points in each dimension, leading to a grid spacing of $h = 1/(N+1)$. This semi-discretization results in a system of ordinary differential equations (ODEs), $U'(t) = \\alpha A U(t)$, where $U \\in \\mathbb{R}^{N^2}$ is the vector of temperature values at the interior grid nodes, and $A \\in \\mathbb{R}^{N^2\\times N^2}$ is the matrix representation of the FD Laplacian operator.\n\nThe matrix $A$ corresponding to the five-point stencil for the Laplacian $\\Delta$ on a grid with spacing $h$ is given by applying the operator $\\Delta_h u_{i,j} = \\frac{1}{h^2}(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})$ at each interior node $(i,j)$ for $i,j \\in \\{1,\\dots,N\\}$. This results in a sparse, symmetric, and negative-definite block-tridiagonal matrix.\n\nThe problem investigates the damping properties of the BE and CN schemes on the stiffest component of the system. This component corresponds to the eigenvector of $A$ with the largest-magnitude (most negative) eigenvalue. For the specified domain and boundary conditions, the discrete eigenvectors are given by $v^{(k,m)}_{i,j} = \\sin(\\frac{ik\\pi}{N+1})\\sin(\\frac{jm\\pi}{N+1})$ with corresponding eigenvalues $\\lambda_{k,m} = \\frac{2}{h^2}\\left(\\cos(\\frac{k\\pi}{N+1}) + \\cos(\\frac{m\\pi}{N+1}) - 2\\right)$ for $k,m \\in \\{1,\\dots,N\\}$. The problem correctly identifies the highest-frequency mode by setting $k=m=N$, and designates the corresponding vectorized eigenvector as $v = U^0$.\n\nWhen the initial condition $U^0$ is an eigenvector $v$ of the matrix $A$ with eigenvalue $\\lambda$, the application of a single time step with a linear, time-invariant scheme simplifies considerably. The solution after one step, $U^1$, remains proportional to the initial eigenvector, i.e., $U^1 = g(\\Delta t, \\alpha, \\lambda) v$, where $g$ is the scalar amplification factor of the numerical scheme.\n\nFor the Backward Euler method, the scheme is $(I - \\Delta t\\,\\alpha A)\\,U^1 = U^0$. Substituting $U^0=v$ and $U^1=g_{BE}v$:\n$(I - \\Delta t\\,\\alpha A)(g_{BE}v) = v$\n$g_{BE}(v - \\Delta t\\,\\alpha Av) = v$\n$g_{BE}(v - \\Delta t\\,\\alpha \\lambda v) = v$\n$g_{BE}(1 - \\Delta t\\,\\alpha \\lambda)v = v$\nThis yields the amplification factor $g_{BE} = (1 - \\Delta t\\,\\alpha \\lambda)^{-1}$. The quantity to be measured, $r_{\\mathrm{BE}}$, is precisely the magnitude of this factor: $r_{\\mathrm{BE}} = |g_{BE}| = |(1 - \\Delta t\\,\\alpha \\lambda)^{-1}|$.\n\nFor the Crank–Nicolson method, the scheme is $(I - \\tfrac{1}{2}\\Delta t\\,\\alpha A)\\,U^1 = (I + \\tfrac{1}{2}\\Delta t\\,\\alpha A)\\,U^0$. Substituting $U^0=v$ and $U^1=g_{CN}v$:\n$(I - \\tfrac{1}{2}\\Delta t\\,\\alpha A)(g_{CN}v) = (I + \\tfrac{1}{2}\\Delta t\\,\\alpha A)v$\n$g_{CN}(v - \\tfrac{1}{2}\\Delta t\\,\\alpha \\lambda v) = (v + \\tfrac{1}{2}\\Delta t\\,\\alpha \\lambda v)$\n$g_{CN}(1 - \\tfrac{1}{2}\\Delta t\\,\\alpha \\lambda)v = (1 + \\tfrac{1}{2}\\Delta t\\,\\alpha \\lambda)v$\nThis yields the amplification factor $g_{CN} = \\frac{1 + \\frac{1}{2}\\Delta t\\,\\alpha \\lambda}{1 - \\frac{1}{2}\\Delta t\\,\\alpha \\lambda}$. The measured quantity is $r_{\\mathrm{CN}} = |g_{CN}| = \\left|\\frac{1 + \\frac{1}{2}\\Delta t\\,\\alpha \\lambda}{1 - \\frac{1}{2}\\Delta t\\,\\alpha \\lambda}\\right|$.\n\nThe implementation will proceed as follows:\n1.  For each test case with parameters $N$, $\\alpha$, and $\\Delta t$, the grid spacing $h=1/(N+1)$ is determined.\n2.  The sparse matrix $A$ of size $N^2 \\times N^2$ is constructed. A computationally efficient way to form this matrix is via the Kronecker sum of two $N \\times N$ 1D Laplacian matrices. The 1D Laplacian stencil matrix is $L_{1D} = \\text{tridiag}(1, -2, 1)$. The 2D Laplacian matrix is then $A = \\frac{1}{h^2}(I \\otimes L_{1D} + L_{1D} \\otimes I)$.\n3.  The initial condition vector $v=U^0$ is constructed by evaluating $u^0_{i,j} = \\sin(\\frac{iN\\pi}{N+1})\\sin(\\frac{jN\\pi}{N+1})$ for $i,j \\in \\{1, \\dots, N\\}$ and flattening the resulting $N \\times N$ array into a vector of length $N^2$.\n4.  For Backward Euler, the linear system $(I - \\Delta t\\,\\alpha A)\\,U^1_{\\mathrm{BE}} = v$ is formed and solved for $U^1_{\\mathrm{BE}}$.\n5.  For Crank-Nicolson, the right-hand side vector $b_{\\mathrm{CN}} = (I + \\tfrac{1}{2}\\Delta t\\,\\alpha A)v$ is computed. Then, the linear system $(I - \\tfrac{1}{2}\\Delta t\\,\\alpha A)\\,U^1_{\\mathrm{CN}} = b_{\\mathrm{CN}}$ is formed and solved for $U^1_{\\mathrm{CN}}$. Sparse linear algebra routines are essential for efficiency.\n6.  The amplification magnitudes are calculated using the specified projection formula:\n    $r_{\\mathrm{BE}} = |\\frac{v^\\top U^1_{\\mathrm{BE}}}{v^\\top v}|$ and $r_{\\mathrm{CN}} = |\\frac{v^\\top U^1_{\\mathrm{CN}}}{v^\\top v}|$.\n7.  The results for all test cases are collected and formatted into a single output line as requested. For the degenerate case $\\Delta t=0$, both methods reduce to $U^1=U^0$, yielding $r_{\\mathrm{BE}}=r_{\\mathrm{CN}}=1$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing Backward Euler and Crank-Nicolson schemes\n    for the 2D heat equation on its highest-frequency eigenmode.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, alpha, dt)\n        (64, 1.0, 0.0),\n        (64, 1.0, 1e-4),\n        (64, 1.0, 1e-3),\n        (64, 1.0, 1e-2),\n    ]\n\n    results = []\n    \n    for N, alpha, dt in test_cases:\n        # 1. Grid and Matrix Setup\n        h = 1.0 / (N + 1)\n        N_sq = N * N\n\n        # Construct the 1D second-derivative stencil matrix\n        main_diag = -2.0 * np.ones(N)\n        off_diag = np.ones(N - 1)\n        T_1D = sparse.diags([off_diag, main_diag, off_diag], [-1, 0, 1], shape=(N, N), format='csc')\n        \n        # Construct the 2D Laplacian matrix A using Kronecker sum\n        # A represents the operator Delta_h = 1/h^2 * (stencil)\n        I_N = sparse.identity(N, format='csc')\n        A = (1.0 / h**2) * (sparse.kron(I_N, T_1D) + sparse.kron(T_1D, I_N))\n        \n        # 2. Initial Condition Vector (Highest-Frequency Eigenmode)\n        i = np.arange(1, N + 1)\n        j = np.arange(1, N + 1)\n        ii, jj = np.meshgrid(i, j, indexing='ij')\n        \n        # u^0_{i,j} = sin(i*N*pi/(N+1)) * sin(j*N*pi/(N+1))\n        arg_factor = N * np.pi / (N + 1)\n        u0_grid = np.sin(ii * arg_factor) * np.sin(jj * arg_factor)\n        \n        # Flatten the 2D grid data into a 1D vector v = U^0\n        v = u0_grid.flatten()\n        \n        # Identity matrix of size N^2 x N^2\n        I_N_sq = sparse.identity(N_sq, format='csc')\n\n        # Handle the case dt = 0 separately for robustness, although the\n        # general formulas below would also work.\n        if dt == 0.0:\n            U1_BE = v\n            U1_CN = v\n        else:\n            # 3. Backward Euler (BE) Step\n            # Solve (I - dt * alpha * A) * U^1_BE = U^0\n            M_BE = I_N_sq - dt * alpha * A\n            U1_BE = spsolve(M_BE, v)\n        \n            # 4. Crank-Nicolson (CN) Step\n            # Solve (I - 0.5 * dt * alpha * A) * U^1_CN = (I + 0.5 * dt * alpha * A) * U^0\n            M_CN_LHS = I_N_sq - 0.5 * dt * alpha * A\n            # Compute RHS = (I + 0.5 * dt * alpha * A) * v\n            # The matrix-vector product is more efficient than forming the RHS matrix\n            RHS_CN = v + (0.5 * dt * alpha) * (A @ v)\n            U1_CN = spsolve(M_CN_LHS, RHS_CN)\n\n        # 5. Compute Amplification Magnitudes\n        # r = |(v^T * U^1) / (v^T * v)|\n        v_dot_v = np.dot(v, v)\n        \n        v_dot_U1_BE = np.dot(v, U1_BE)\n        r_BE = np.abs(v_dot_U1_BE / v_dot_v)\n        \n        v_dot_U1_CN = np.dot(v, U1_CN)\n        r_CN = np.abs(v_dot_U1_CN / v_dot_v)\n        \n        results.extend([r_BE, r_CN])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world physical systems rarely have uniform properties. Discretizing equations with spatially varying coefficients, such as a variable thermal conductivity $k(x,y)$, introduces new challenges that test the physical fidelity of a numerical scheme. This practice explores a classic pitfall where a naive discretization of the steady-state heat equation $\\nabla \\cdot (k \\nabla u) = 0$ with highly oscillatory coefficients produces unphysical, grid-scale checkerboard patterns in the solution. By implementing and comparing this naive approach with a flux-conservative method, you will learn why honoring physical conservation laws at the discrete level is essential for obtaining meaningful results in heterogeneous media .",
            "id": "3393344",
            "problem": "Consider the two-dimensional heat equation with spatially varying thermal conductivity, given by the partial differential equation $$u_t = \\nabla \\cdot \\left(k(x,y)\\nabla u\\right),$$ where $u(x,y,t)$ is the temperature field, $k(x,y) > 0$ is the thermal conductivity, and the operator $\\nabla \\cdot (\\cdot)$ denotes the divergence in two spatial dimensions. In the steady state, the governing equation reduces to $$\\nabla \\cdot \\left(k(x,y)\\nabla u\\right) = 0.$$ This problem explores how spatial checkerboard patterns in the conductivity $k(x,y)$ interact with finite difference discretizations of the steady-state equation and how they can induce nonphysical grid-scale oscillations if stencils do not properly conserve fluxes. The goal is to diagnose such oscillations and implement a flux-weighted stencil that suppresses them without sacrificing accuracy.\n\nYou must implement two distinct discretizations on a uniform Cartesian grid for the steady-state equation with Dirichlet boundary conditions on the unit square domain $[0,1]\\times[0,1]$:\n\n- A naive node-weighted stencil that applies local conductivity values directly at grid nodes to weight the discrete Laplacian.\n- A flux-weighted conservative stencil that approximates the divergence form by constructing face-centered fluxes consistent with physical conservation.\n\nThe discretization must be constructed from first principles, beginning with the divergence form of the operator, enforcing that fluxes are balanced at each interior node, and treating boundary conditions through appropriate source terms. You must design the flux stencil so that it uses a physically consistent averaging at cell faces, thereby capturing the effect of highly oscillatory $k(x,y)$ and eliminating nonphysical grid-scale modes.\n\nDiscretize the domain with a uniform square grid of $N\\times N$ nodes, where $N$ is the number of points in each direction including boundaries. Use Dirichlet boundary values given by $$u(0,y)=0,\\quad u(1,y)=1,\\quad u(x,0)=0,\\quad u(x,1)=0,$$ which must be interpreted in numerical units consistent with a dimensionless problem formulation (no physical units are required in the answer). For all test cases, use a uniform grid spacing $$h=\\frac{1}{N-1}.$$\n\nDefine a checkerboard conductivity on the grid nodes by $$k_{i,j}=\\begin{cases}k_{\\text{even}},&\\text{if }(i+j)\\text{ is even},\\\\k_{\\text{odd}},&\\text{if }(i+j)\\text{ is odd},\\end{cases}$$ where $i,j$ index the grid nodes in the $x$ and $y$ directions, respectively. The checkerboard alternation is intended to maximize the contrast at the grid scale.\n\nYour program must assemble and solve the linear system for the interior unknowns for each stencil and each test case. After obtaining the interior solution $u_{i,j}$ for each configuration, you must diagnose grid-scale oscillations by projecting the solution onto the checkerboard pattern with the indicator $$s_{i,j}=(-1)^{i+j}.$$ Define the oscillation amplitude as the projection coefficient $$\\alpha=\\frac{\\sum_{i,j}u_{i,j}s_{i,j}}{\\sum_{i,j}s_{i,j}^2},$$ where the sums run over interior nodes only. Report the absolute value $|\\alpha|$ as a dimensionless float to quantify the strength of the nonphysical checkerboard content in the numerical solution.\n\nImplement the following test suite to ensure coverage of high contrast, low contrast, and uniform cases:\n\n- Test case $1$ (high contrast, odd nodes are weak): $N=32$, $k_{\\text{even}}=1$, $k_{\\text{odd}}=10^{-6}$.\n- Test case $2$ (high contrast, odd nodes are strong): $N=32$, $k_{\\text{even}}=1$, $k_{\\text{odd}}=10^{6}$.\n- Test case $3$ (uniform conductivity): $N=32$, $k_{\\text{even}}=1$, $k_{\\text{odd}}=1$.\n\nFor each test case, compute two amplitudes: one for the naive node-weighted stencil and one for the flux-weighted conservative stencil, both evaluated on the same grid and boundary conditions. Your program should produce a single line of output containing the results as a comma-separated list of lists, each inner list having two floats in the order $[\\lvert \\alpha\\rvert_{\\text{naive}},\\lvert \\alpha\\rvert_{\\text{flux}}]$. For the three specified test cases, the final output format must be\n$$\\text{[ [}\\lvert \\alpha\\rvert_{\\text{naive,1}},\\lvert \\alpha\\rvert_{\\text{flux,1}}\\text{], [}\\lvert \\alpha\\rvert_{\\text{naive,2}},\\lvert \\alpha\\rvert_{\\text{flux,2}}\\text{], [}\\lvert \\alpha\\rvert_{\\text{naive,3}},\\lvert \\alpha\\rvert_{\\text{flux,3}}\\text{] ]}.$$",
            "solution": "The user wants to solve the steady-state 2D heat equation with spatially varying conductivity and compare two finite difference discretization schemes.\n\n### Step 1: Extract Givens\n- **Governing Equation (Steady State)**: $\\nabla \\cdot \\left(k(x,y)\\nabla u\\right) = 0$.\n- **Domain**: Unit square, $[0,1]\\times[0,1]$.\n- **Grid**: Uniform Cartesian grid with $N \\times N$ nodes. Grid spacing is $h = \\frac{1}{N-1}$.\n- **Boundary Conditions (Dirichlet)**:\n    - $u(0,y) = 0$\n    - $u(1,y) = 1$\n    - $u(x,0) = 0$\n    - $u(x,1) = 0$\n- **Thermal Conductivity**: A checkerboard pattern defined on the grid nodes $(i,j)$ for $i,j \\in \\{0, 1, \\dots, N-1\\}$:\n    $$ k_{i,j}=\\begin{cases}k_{\\text{even}},&\\text{if }(i+j)\\text{ is even},\\\\k_{\\text{odd}},&\\text{if }(i+j)\\text{ is odd}.\\end{cases} $$\n- **Discretization Schemes**:\n    1.  **Naive node-weighted stencil**: A non-conservative scheme.\n    2.  **Flux-weighted conservative stencil**: A conservative scheme.\n- **Analysis Metric**: The oscillation amplitude, defined as the projection of the interior solution onto the checkerboard mode $s_{i,j}=(-1)^{i+j}$:\n    $$ \\alpha = \\frac{\\sum_{i,j} u_{i,j}s_{i,j}}{\\sum_{i,j} s_{i,j}^2} $$\n    The sums are over interior nodes only. The value to be reported is $|\\alpha|$.\n- **Test Cases**:\n    1.  $N=32$, $k_{\\text{even}}=1$, $k_{\\text{odd}}=10^{-6}$.\n    2.  $N=32$, $k_{\\text{even}}=1$, $k_{\\text{odd}}=10^{6}$.\n    3.  $N=32$, $k_{\\text{even}}=1$, $k_{\\text{odd}}=1$.\n- **Output Format**: A single line string representing a list of lists of floats: `[[|α|_naive,1, |α|_flux,1], [|α|_naive,2, |α|_flux,2], [|α|_naive,3, |α|_flux,3]]`.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically and mathematically sound. It describes a standard method in numerical analysis for partial differential equations (PDEs) to test the robustness of discretization schemes for elliptic equations with discontinuous or highly varying coefficients.\n- **Scientifically Grounded**: The problem is rooted in the well-established field of numerical solutions for PDEs. The steady-state heat equation is a fundamental elliptic PDE. The use of checkerboard coefficients is a classical and rigorous method to expose flaws like non-physical oscillations in numerical schemes.\n- **Well-Posed**: The PDE with the given Dirichlet boundary conditions is well-posed, admitting a unique, stable solution. The numerical problem translates to solving a linear system $A\\mathbf{u}=\\mathbf{b}$. Both proposed discretization methods will result in a matrix $A$ that is sparse, diagonally dominant (under certain conditions), and non-singular, ensuring a unique numerical solution.\n- **Objective**: All terms, conditions, and metrics are defined with mathematical precision. There are no subjective or ambiguous statements.\n- **Completeness and Consistency**: The problem is self-contained. It provides all necessary information (equation, domain, boundary conditions, discretization parameters, and test cases) to construct and solve the problem. There are no contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. A full solution will be provided.\n\n### Principle-Based Solution\nThe core of the problem is to discretize the divergence form of the steady-state heat equation, $\\frac{\\partial}{\\partial x}(k \\frac{\\partial u}{\\partial x}) + \\frac{\\partial}{\\partial y}(k \\frac{\\partial u}{\\partial y}) = 0$, on a uniform grid. We employ a finite volume/difference approach centered at each interior grid node $(i,j)$, where $i,j \\in \\{1, \\dots, N-2\\}$.\n\nApplying a second-order central difference scheme to the divergence operator, the equation at node $(i,j)$ becomes:\n$$ \\frac{1}{h} \\left[ \\left(k \\frac{\\partial u}{\\partial x}\\right)_{i+1/2, j} - \\left(k \\frac{\\partial u}{\\partial x}\\right)_{i-1/2, j} \\right] + \\frac{1}{h} \\left[ \\left(k \\frac{\\partial u}{\\partial y}\\right)_{i, j+1/2} - \\left(k \\frac{\\partial u}{\\partial y}\\right)_{i, j-1/2} \\right] = 0 $$\nThe derivatives of $u$ at the cell faces (half-integer indices) are approximated as:\n$$ \\left(\\frac{\\partial u}{\\partial x}\\right)_{i+1/2, j} \\approx \\frac{u_{i+1, j} - u_{i, j}}{h} $$\nSubstituting these into the equation and multiplying by $h^2$ yields the general form of the 5-point stencil:\n$$ k_{i-1/2, j}(u_{i-1,j} - u_{i,j}) + k_{i+1/2, j}(u_{i+1,j} - u_{i,j}) + k_{i, j-1/2}(u_{i,j-1} - u_{i,j}) + k_{i, j+1/2}(u_{i,j+1} - u_{i,j}) = 0 $$\nThe crucial difference between the two required stencils lies in the approximation of the conductivity $k$ at the cell faces, given that $k$ is defined only at the grid nodes.\n\n**1. Naive Node-Weighted Stencil**\nThis scheme uses the arithmetic mean to approximate the conductivity at a cell face. For example, the conductivity at the face between nodes $(i,j)$ and $(i+1, j)$ is:\n$$ k_{i+1/2, j} = \\frac{k_{i,j} + k_{i+1,j}}{2} $$\nThis method is simple to implement but is not conservative, especially for high-contrast media. It effectively averages the resistivities incorrectly, leading to a decoupling of the linear system into two sub-grids (even and odd nodes) and permitting non-physical, grid-scale oscillations. This is the \"naive\" method specified.\n\n**2. Flux-Weighted Conservative Stencil**\nA physically-based conservative scheme ensures that the flux leaving one cell and entering another is computed consistently. This is achieved by correctly modeling the series resistance of the two half-cells adjacent to a face. The effective conductivity is the harmonic mean of the conductivities of the adjacent nodes:\n$$ k_{i+1/2, j} = \\left( \\frac{1/k_{i,j} + 1/k_{i+1,j}}{2} \\right)^{-1} = \\frac{2k_{i,j}k_{i+1,j}}{k_{i,j} + k_{i+1,j}} $$\nThis method is known to be robust and accurate for problems with discontinuous or sharply varying coefficients as it correctly captures the high resistance of low-conductivity regions and suppresses spurious oscillations.\n\n**System Assembly and Solution**\nFor each interior node $(i,j)$, we formulate one linear equation using the chosen stencil. The set of all such equations for the $(N-2) \\times (N-2)$ interior nodes forms a linear system $A\\mathbf{u} = \\mathbf{b}$.\n- The unknowns are the temperature values $u_{i,j}$ at the interior nodes, which are mapped to a 1D vector $\\mathbf{u}$. We use a row-major mapping: the 2D node $(i,j)$ corresponds to the 1D index $m = (i-1)(N-2) + (j-1)$.\n- The matrix $A$ contains the coefficients of the unknowns from the stencils. For a node $(i,j)$, the stencil coefficients for its neighbors become off-diagonal entries in row $m$ of $A$, and the sum of these coefficients (with a negative sign) forms the diagonal entry $A_{m,m}$.\n- The vector $\\mathbf{b}$ contains terms resulting from the Dirichlet boundary conditions. When a neighbor of an interior node is a boundary node, its value is known. This known value is multiplied by its corresponding stencil coefficient and moved to the right-hand side of the equation. In this problem, only the boundary $u(1,y)=1$ contributes non-zero terms to $\\mathbf{b}$.\n\nAfter solving the system $A\\mathbf{u}=\\mathbf{b}$ using a standard linear solver, we obtain the vector of interior solutions $\\mathbf{u}$. This is reshaped into a 2D array, $u_{\\text{interior}}$.\n\n**Oscillation Analysis**\nTo quantify the grid-scale oscillations, we project the numerical solution onto the checkerboard pattern $s_{i,j}=(-1)^{i+j}$. The projection coefficient $\\alpha$ is calculated over the interior nodes:\n$$ \\alpha = \\frac{\\sum_{i=1}^{N-2} \\sum_{j=1}^{N-2} u_{i,j}s_{i,j}}{\\sum_{i=1}^{N-2} \\sum_{j=1}^{N-2} s_{i,j}^2} $$\nSince $s_{i,j}^2 = 1$ for all $i,j$, the denominator is simply the number of interior nodes, $(N-2)^2$. A large value of $|\\alpha|$ indicates a strong presence of non-physical checkerboard oscillations in the solution. The naive stencil is expected to yield a large $|\\alpha|$ for high-contrast test cases, while the conservative stencil should yield a value close to zero. For the uniform conductivity case, both methods are identical and should produce a smooth solution with a negligible $|\\alpha|$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D steady-state heat equation with checkerboard conductivity\n    using two different finite difference stencils and analyzes the resulting\n    grid-scale oscillations.\n    \"\"\"\n\n    def compute_alpha(N, k_even, k_odd, stencil_type):\n        \"\"\"\n        Assembles and solves the linear system for a given stencil type and\n        computes the oscillation amplitude alpha.\n\n        Args:\n            N (int): Number of grid points in each direction.\n            k_even (float): Conductivity for nodes where (i+j) is even.\n            k_odd (float): Conductivity for nodes where (i+j) is odd.\n            stencil_type (str): 'naive' for arithmetic mean, 'flux' for harmonic mean.\n\n        Returns:\n            float: The absolute value of the oscillation amplitude |alpha|.\n        \"\"\"\n        num_interior_nodes_1d = N - 2\n        M = num_interior_nodes_1d**2\n        \n        A = np.zeros((M, M))\n        b = np.zeros(M)\n        \n        k = np.zeros((N, N))\n        for i in range(N):\n            for j in range(N):\n                if (i + j) % 2 == 0:\n                    k[i, j] = k_even\n                else:\n                    k[i, j] = k_odd\n\n        if stencil_type == 'naive':\n            avg_k = lambda k1, k2: (k1 + k2) / 2.0\n        elif stencil_type == 'flux':\n            avg_k = lambda k1, k2: 2.0 * k1 * k2 / (k1 + k2) if (k1 + k2) > 0 else 0\n        else:\n            raise ValueError(\"Unknown stencil_type\")\n\n        # Assemble the matrix A and vector b based on the problem's (x,y) convention.\n        # i is the global x index (horizontal), j is the global y index (vertical).\n        for i in range(1, N - 1):\n            for j in range(1, N - 1):\n                m = (i - 1) * num_interior_nodes_1d + (j - 1)\n                \n                k_center = k[i, j]\n\n                # West neighbor (i-1, j)\n                c_W = avg_k(k_center, k[i-1, j])\n                if i - 1 > 0:\n                    m_W = (i - 2) * num_interior_nodes_1d + (j - 1)\n                    A[m, m_W] = c_W\n                else: # Boundary u(0,y)=0\n                    pass\n\n                # East neighbor (i+1, j)\n                c_E = avg_k(k_center, k[i+1, j])\n                if i + 1  N - 1:\n                    m_E = i * num_interior_nodes_1d + (j - 1)\n                    A[m, m_E] = c_E\n                else: # Boundary u(1,y)=1\n                    b[m] -= c_E * 1.0\n\n                # South neighbor (i, j-1)\n                c_S = avg_k(k_center, k[i, j-1])\n                if j - 1 > 0:\n                    m_S = (i - 1) * num_interior_nodes_1d + (j - 2)\n                    A[m, m_S] = c_S\n                else: # Boundary u(x,0)=0\n                    pass\n\n                # North neighbor (i, j+1)\n                c_N = avg_k(k_center, k[i, j+1])\n                if j + 1  N - 1:\n                    m_N = (i - 1) * num_interior_nodes_1d + j\n                    A[m, m_N] = c_N\n                else: # Boundary u(x,1)=0\n                    pass\n                \n                A[m, m] = -(c_W + c_E + c_S + c_N)\n\n        u_vec = np.linalg.solve(A, b)\n        \n        u_interior = u_vec.reshape((num_interior_nodes_1d, num_interior_nodes_1d))\n        \n        s_interior = np.zeros((num_interior_nodes_1d, num_interior_nodes_1d))\n        for p in range(num_interior_nodes_1d):\n            for q in range(num_interior_nodes_1d):\n                i, j = p + 1, q + 1\n                s_interior[p, q] = (-1)**(i + j)\n        \n        numerator = np.sum(u_interior * s_interior)\n        denominator = M\n        alpha = numerator / denominator\n        \n        return abs(alpha)\n\n    test_cases = [\n        (32, 1, 1e-6),\n        (32, 1, 1e6),\n        (32, 1, 1),\n    ]\n\n    results = []\n    for N_val, k_e, k_o in test_cases:\n        alpha_naive = compute_alpha(N_val, k_e, k_o, 'naive')\n        alpha_flux = compute_alpha(N_val, k_e, k_o, 'flux')\n        results.append([alpha_naive, alpha_flux])\n\n    sub_lists = []\n    for res_pair in results:\n        sub_lists.append(f\"[{res_pair[0]},{res_pair[1]}]\")\n    final_output_str = f\"[{','.join(sub_lists)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}