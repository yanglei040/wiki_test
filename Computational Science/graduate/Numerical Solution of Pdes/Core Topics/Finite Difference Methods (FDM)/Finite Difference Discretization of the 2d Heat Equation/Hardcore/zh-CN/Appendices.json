{
    "hands_on_practices": [
        {
            "introduction": "显式时间积分方法，如前向欧拉法，因其简单直观而常作为入门选择。然而，这种简单性是有代价的：其稳定性受到严格的时间步长限制。本练习 () 将指导您运用 von Neumann 稳定性分析，从第一性原理出发，为各向异性网格上的二维热方程推导出精确的稳定性约束，从而加深对离散格式稳定性与网格参数之间内在联系的理解。",
            "id": "3393371",
            "problem": "考虑恒定系数的二维热方程\n$$\nu_{t}=\\kappa\\left(u_{xx}+u_{yy}\\right),\n$$\n该方程定义在一个双周期矩形域上，其中 $\\kappa>0$ 是热扩散系数。设该域被一个均匀的笛卡尔网格所覆盖，其在 $x$ 和 $y$ 方向上的间距分别为 $h_{x}$ 和 $h_{y}$，时间步长为 $\\Delta t$。使用标准的中心二阶有限差分对 $u_{xx}$ 和 $u_{yy}$ 进行离散，并使用前向欧拉法在时间上推进，得到每个内部网格点 $(i,j)$ 的显式更新形式如下\n$$\nu^{n+1}_{i,j}=u^{n}_{i,j}+\\kappa\\,\\Delta t\\left(\\frac{u^{n}_{i+1,j}-2u^{n}_{i,j}+u^{n}_{i-1,j}}{h_{x}^{2}}+\\frac{u^{n}_{i,j+1}-2u^{n}_{i,j}+u^{n}_{i,j-1}}{h_{y}^{2}}\\right).\n$$\n使用 von Neumann (傅里叶) 稳定性分析方法，从第一性原理出发，确定当 $h_{x}\\neq h_{y}$ 时，哪个离散傅里叶模态对稳定性的限制最强，并推导出相应的严格稳定性约束条件，该条件确保在单个时间步内任何模态的振幅都不会被放大。请将您的最终结果表示为最大允许时间步长 $\\Delta t_{\\max}$ 关于 $h_{x}$、$h_{y}$ 和 $\\kappa$ 的闭式解析表达式。请以秒为单位表示 $\\Delta t_{\\max}$。无需进行数值计算或四舍五入。",
            "solution": "对问题陈述的有效性进行评估。\n\n### 步骤 1：提取已知条件\n- **偏微分方程**：恒定系数二维热方程为 $u_{t}=\\kappa\\left(u_{xx}+u_{yy}\\right)$，其中 $\\kappa>0$。\n- **定义域**：一个双周期矩形域。\n- **离散化参数**：均匀笛卡尔网格，在 $x$ 和 $y$ 方向上的间距分别为 $h_{x}$ 和 $h_{y}$。时间步长为 $\\Delta t$。题目指定 $h_x \\neq h_y$。\n- **数值格式**：空间导数 $u_{xx}$ 和 $u_{yy}$ 使用标准中心二阶有限差分进行离散。时间积分采用前向欧拉法。\n- **有限差分方程**：得到的显式更新规则如下：\n$u^{n+1}_{i,j}=u^{n}_{i,j}+\\kappa\\,\\Delta t\\left(\\frac{u^{n}_{i+1,j}-2u^{n}_{i,j}+u^{n}_{i-1,j}}{h_{x}^{2}}+\\frac{u^{n}_{i,j+1}-2u^{n}_{i,j}+u^{n}_{i,j-1}}{h_{y}^{2}}\\right)$。\n- **分析方法**：分析需使用 von Neumann (傅里叶) 稳定性分析法，并从第一性原理出发。\n- **目标**：确定对稳定性限制最强的傅里叶模态，并推导出最大允许时间步长 $\\Delta t_{\\max}$ 关于 $h_{x}$、$h_{y}$ 和 $\\kappa$ 的严格稳定性约束。$\\Delta t_{\\max}$ 的结果需以秒为单位表示。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题是偏微分方程数值分析领域的典型例子。热方程、FTCS (时间前向，空间中心) 离散格式以及 von Neumann 稳定性分析都是标准且成熟的概念。该问题在科学上和数学上都是合理的。\n- **适定性**：该问题是适定的。它提供了推导唯一且有意义的稳定性准则所需的所有必要信息（偏微分方程、离散格式、分析方法）。\n- **目标**：问题以精确、无歧义的数学语言陈述。没有主观或基于观点的元素。\n- **其他缺陷**：问题设置是完整的、一致的、现实的（在数值分析的背景下）且非平凡的。它没有违反任何有效问题的标准。提及最终答案以秒为单位表示，意味着输入参数 $\\kappa$、$h_x$ 和 $h_y$ 应被视为使用一套一致的单位（例如，国际单位制），从而使得到的时间步长自然以秒为单位。这不构成缺陷。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整的解答。\n\n### 解答推导\n我们使用 von Neumann 方法分析给定有限差分格式的稳定性。该方法研究解的单个傅里叶模态随时间的演化。我们考虑计算网格 $(x_i, y_j) = (i h_x, j h_y)$ 上的一个通用傅里叶模态，其形式为：\n$$\nu^n_{i,j} = \\hat{u}^n(k_x, k_y) \\exp(I(k_x x_i + k_y y_j)) = \\hat{u}^n \\exp(I(k_x i h_x + k_y j h_y))\n$$\n其中 $n$ 是时间层索引，$(i,j)$ 是空间网格索引，$k_x$ 和 $k_y$ 分别是 $x$ 和 $y$ 方向的波数，$\\hat{u}^n$ 是时间层 $n$ 的模态振幅，$I = \\sqrt{-1}$ 是虚数单位。\n\n下一个时间步的振幅 $\\hat{u}^{n+1}$ 通过放大因子 $G(k_x, k_y)$ 与当前振幅相关联：\n$$\n\\hat{u}^{n+1} = G(k_x, k_y) \\hat{u}^n\n$$\n为使数值格式稳定，对于任何可能的波数，放大因子的模都不能超过 $1$，即 $|G(k_x, k_y)| \\le 1$。\n\n我们将傅里叶模态的假设代入有限差分方程：\n$$\n\\hat{u}^{n+1} \\exp(I(k_x i h_x + k_y j h_y)) = \\hat{u}^{n} \\exp(I(k_x i h_x + k_y j h_y)) + \\kappa \\Delta t \\left( \\frac{\\hat{u}^n \\left(e^{I k_x (i+1)h_x} - 2e^{I k_x i h_x} + e^{I k_x (i-1)h_x}\\right)e^{I k_y j h_y}}{h_x^2} + \\frac{\\hat{u}^n \\left(e^{I k_y (j+1)h_y} - 2e^{I k_y j h_y} + e^{I k_y (j-1)h_y}\\right)e^{I k_x i h_x}}{h_y^2} \\right)\n$$\n两边同除以 $\\hat{u}^n \\exp(I(k_x i h_x + k_y j h_y))$ 并利用 $\\hat{u}^{n+1}/\\hat{u}^n = G$，我们得到放大因子的表达式：\n$$\nG = 1 + \\kappa \\Delta t \\left( \\frac{e^{I k_x h_x} - 2 + e^{-I k_x h_x}}{h_x^2} + \\frac{e^{I k_y h_y} - 2 + e^{-I k_y h_y}}{h_y^2} \\right)\n$$\n利用恒等式 $e^{I\\theta} + e^{-I\\theta} = 2\\cos(\\theta)$，该表达式变为：\n$$\nG = 1 + \\kappa \\Delta t \\left( \\frac{2\\cos(k_x h_x) - 2}{h_x^2} + \\frac{2\\cos(k_y h_y) - 2}{h_y^2} \\right)\n$$\n提出因子 $-2$ 并使用半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$，我们得到：\n$$\nG = 1 - 2\\kappa \\Delta t \\left( \\frac{1 - \\cos(k_x h_x)}{h_x^2} + \\frac{1 - \\cos(k_y h_y)}{h_y^2} \\right)\n$$\n$$\nG(k_x, k_y) = 1 - 4\\kappa \\Delta t \\left( \\frac{\\sin^2(k_x h_x / 2)}{h_x^2} + \\frac{\\sin^2(k_y h_y / 2)}{h_y^2} \\right)\n$$\n由于 $\\kappa > 0$，$\\Delta t > 0$，且正弦平方项为非负数，放大因子 $G$ 始终为实数且小于或等于 $1$。因此，稳定性条件 $|G| \\le 1$ 可简化为单个不等式 $G \\ge -1$：\n$$\n1 - 4\\kappa \\Delta t \\left( \\frac{\\sin^2(k_x h_x / 2)}{h_x^2} + \\frac{\\sin^2(k_y h_y / 2)}{h_y^2} \\right) \\ge -1\n$$\n$$\n2 \\ge 4\\kappa \\Delta t \\left( \\frac{\\sin^2(k_x h_x / 2)}{h_x^2} + \\frac{\\sin^2(k_y h_y / 2)}{h_y^2} \\right)\n$$\n解出 $\\Delta t$，我们有：\n$$\n\\Delta t \\le \\frac{2}{4\\kappa \\left( \\frac{\\sin^2(k_x h_x / 2)}{h_x^2} + \\frac{\\sin^2(k_y h_y / 2)}{h_y^2} \\right)} = \\frac{1}{2\\kappa \\left( \\frac{\\sin^2(k_x h_x / 2)}{h_x^2} + \\frac{\\sin^2(k_y h_y / 2)}{h_y^2} \\right)}\n$$\n这个不等式必须对所有可能的波数 $k_x$ 和 $k_y$ 都成立。为了找到对 $\\Delta t$ 最严格的约束，我们必须找到右侧表达式的最小值。这发生在分母取最大值时。需要最大化的项是 $\\frac{\\sin^2(k_x h_x / 2)}{h_x^2} + \\frac{\\sin^2(k_y h_y / 2)}{h_y^2}$。\n\n函数 $\\sin^2(\\theta)$ 的最大值为 $1$。当我们选择的波数能同时最大化 $\\sin^2(k_x h_x/2)$ 和 $\\sin^2(k_y h_y/2)$ 时，即可达到此最大值。这发生在网格能分辨的最高频率模态下，对应于：\n$$\nk_x h_x / 2 = \\frac{\\pi}{2} \\implies k_x = \\frac{\\pi}{h_x}\n$$\n$$\nk_y h_y / 2 = \\frac{\\pi}{2} \\implies k_y = \\frac{\\pi}{h_y}\n$$\n这些模态在相邻网格点上符号交替，是对稳定性限制最强的模态。将 $\\sin^2(k_x h_x/2) = 1$ 和 $\\sin^2(k_y h_y/2) = 1$ 代入不等式，得到严格的稳定性边界：\n$$\n\\Delta t \\le \\frac{1}{2\\kappa \\left( \\frac{1}{h_x^2} + \\frac{1}{h_y^2} \\right)}\n$$\n因此，最大允许时间步长 $\\Delta t_{\\max}$ 为：\n$$\n\\Delta t_{\\max} = \\frac{1}{2\\kappa \\left( \\frac{1}{h_x^2} + \\frac{1}{h_y^2} \\right)}\n$$\n通过合并分母中的项，可以简化此表达式：\n$$\n\\Delta t_{\\max} = \\frac{1}{2\\kappa \\left( \\frac{h_y^2 + h_x^2}{h_x^2 h_y^2} \\right)} = \\frac{h_x^2 h_y^2}{2\\kappa (h_x^2 + h_y^2)}\n$$\n这就是最大稳定时间步长的最终解析表达式。如果物理量 $\\kappa$、$h_x$ 和 $h_y$ 以国际单位制（$\\kappa$ 的单位为 m$^2$/s，$h_x$ 和 $h_y$ 的单位为 m）给出，那么得到的 $\\Delta t_{\\max}$ 的单位将是秒，符合题目要求。",
            "answer": "$$\n\\boxed{\\frac{h_{x}^{2} h_{y}^{2}}{2 \\kappa (h_{x}^{2} + h_{y}^{2})}}\n$$"
        },
        {
            "introduction": "对于包含多种时间尺度的“刚性”问题，显式方法的稳定性限制可能变得不切实际。隐式方法，如后向欧拉法和 Crank-Nicolson 方法，通过提供无条件稳定性来解决这一难题。本编码练习 () 旨在揭示一个更深层次的特性：不同的隐式格式如何处理数值解中的高频（刚性）分量，并突显后向欧拉法的 L-稳定性在有效抑制非物理振荡方面的优势。",
            "id": "3393393",
            "problem": "考虑单位正方形上的二维热传导方程，其具有均匀狄利克雷边界条件，方程为 $u_t = \\alpha \\Delta u$，定义在 $\\Omega = (0,1)\\times(0,1)$ 上，边界条件为 $\\partial\\Omega$ 上 $u=0$，初始条件为 $u(x,y,0) = u_0(x,y)$。设一个均匀笛卡尔有限差分（FD）网格沿每个坐标方向使用 $N$ 个内部点定义，因此网格间距为 $h = 1/(N+1)$，内部网格索引为 $i=1,\\dots,N$ 和 $j=1,\\dots,N$。使用五点有限差分拉普拉斯算子进行空间离散化，得到半离散系统 $U'(t) = \\alpha A U(t)$，其中 $U(t)\\in\\mathbb{R}^{N^2}$ 是内部节点值的向量，$A\\in\\mathbb{R}^{N^2\\times N^2}$ 是带有均匀狄利克雷边界条件的有限差分拉普拉斯矩阵。\n\n对比两种隐式单步时间离散化方法：\n\n- 后向欧拉法（也称为隐式欧拉法），它通过 $(I - \\Delta t\\,\\alpha A)\\,U^1 = U^0$ 将 $U^0$ 在大小为 $\\Delta t$ 的一个步长内推进到 $U^1$。\n\n- Crank–Nicolson（CN）方法，它通过 $(I - \\tfrac{1}{2}\\Delta t\\,\\alpha A)\\,U^1 = (I + \\tfrac{1}{2}\\Delta t\\,\\alpha A)\\,U^0$ 将 $U^0$ 在大小为 $\\Delta t$ 的一个步长内推进到 $U^1$。\n\n为了分离和测量在非常刚性分量上的行为，选择初始条件为有限差分网格上的最高频率离散狄利克雷本征模，即对于 $i=1,\\dots,N$，$j=1,\\dots,N$，有 $u^0_{i,j} = \\sin\\!\\big(\\tfrac{i N \\pi}{N+1}\\big)\\,\\sin\\!\\big(\\tfrac{j N \\pi}{N+1}\\big)$，并将其展开成 $U^0\\in\\mathbb{R}^{N^2}$。用 $v\\in\\mathbb{R}^{N^2}$ 表示这个离散本征模向量。在每种方法应用单个时间步后，通过在 $v$ 上的投影来定义高频分量的测量放大系数：\n$$\nr_{\\mathrm{BE}} = \\left|\\frac{v^\\top U^1_{\\mathrm{BE}}}{v^\\top U^0}\\right|,\\qquad\nr_{\\mathrm{CN}} = \\left|\\frac{v^\\top U^1_{\\mathrm{CN}}}{v^\\top U^0}\\right|.\n$$\n这些量捕捉了每种格式下最刚性模态的衰减（或不衰减）情况。所有量都是无量纲的。\n\n实现一个程序，该程序使用带有均匀狄利克雷边界条件的五点有限差分拉普拉斯算子构造 $A$，构建初始本征模 $v$，对每个测试参数集使用后向欧拉法和 Crank–Nicolson 方法执行一个时间步，并如下文所述输出测量的放大系数 $r_{\\mathrm{BE}}$ 和 $r_{\\mathrm{CN}}$。\n\n使用以下测试套件，它探索了一个边界情况和逐渐增加的刚性区域：\n- 测试 $1$: $N=64$, $\\alpha=1$, $\\Delta t = 0$。\n- 测试 $2$: $N=64$, $\\alpha=1$, $\\Delta t = 10^{-4}$。\n- 测试 $3$: $N=64$, $\\alpha=1$, $\\Delta t = 10^{-3}$。\n- 测试 $4$: $N=64$, $\\alpha=1$, $\\Delta t = 10^{-2}$。\n\n对于每个测试，计算如上定义的 $r_{\\mathrm{BE}}$ 和 $r_{\\mathrm{CN}}$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为 $[r_{\\mathrm{BE}}^{(1)}, r_{\\mathrm{CN}}^{(1)}, r_{\\mathrm{BE}}^{(2)}, r_{\\mathrm{CN}}^{(2)}, r_{\\mathrm{BE}}^{(3)}, r_{\\mathrm{CN}}^{(3)}, r_{\\mathrm{BE}}^{(4)}, r_{\\mathrm{CN}}^{(4)}]$，其中上标表示测试索引。每个条目必须是浮点数。",
            "solution": "问题陈述已经过仔细验证，并被确定为有效。它具有科学依据，是适定且客观的，提出了一个求解偏微分方程数值解的标准问题。所有必要的数据和定义都已提供，没有内部矛盾或歧义。\n\n该问题要求对单位正方形域 $\\Omega=(0,1)\\times(0,1)$ 上具有均匀狄利克雷边界条件的二维热传导方程 $u_t = \\alpha \\Delta u$ 的后向欧拉（BE）和 Crank–Nicolson（CN）时间步进格式进行比较。空间离散化是在一个均匀网格上使用五点有限差分（FD）格式进行的，每个维度有 $N$ 个内部点，从而得到网格间距 $h = 1/(N+1)$。这种半离散化产生了一个常微分方程组（ODEs），$U'(t) = \\alpha A U(t)$，其中 $U \\in \\mathbb{R}^{N^2}$ 是内部网格节点上的温度值向量，$A \\in \\mathbb{R}^{N^2\\times N^2}$ 是有限差分拉普拉斯算子的矩阵表示。\n\n在间距为 $h$ 的网格上，对应于拉普拉斯算子 $\\Delta$ 的五点格式的矩阵 $A$ 是通过在每个内部节点 $(i,j)$（其中 $i,j \\in \\{1,\\dots,N\\}$）上应用算子 $\\Delta_h u_{i,j} = \\frac{1}{h^2}(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})$ 得到的。这将产生一个稀疏、对称、负定的块三对角矩阵。\n\n该问题研究了 BE 和 CN 格式对系统最刚性分量的阻尼特性。该分量对应于矩阵 $A$ 的具有最大模（最负）特征值的特征向量。对于指定的域和边界条件，离散特征向量由 $v^{(k,m)}_{i,j} = \\sin(\\frac{ik\\pi}{N+1})\\sin(\\frac{jm\\pi}{N+1})$ 给出，其对应的特征值为 $\\lambda_{k,m} = \\frac{2}{h^2}\\left(\\cos(\\frac{k\\pi}{N+1}) + \\cos(\\frac{m\\pi}{N+1}) - 2\\right)$，其中 $k,m \\in \\{1,\\dots,N\\}$。问题通过设置 $k=m=N$ 正确地识别了最高频率模态，并将其对应的向量化特征向量指定为 $v = U^0$。\n\n当初始条件 $U^0$ 是矩阵 $A$ 的一个特征向量 $v$，其特征值为 $\\lambda$ 时，应用线性时不变格式的单个时间步会大大简化。一步之后的解 $U^1$ 仍然与初始特征向量成比例，即 $U^1 = g(\\Delta t, \\alpha, \\lambda) v$，其中 $g$ 是数值格式的标量放大因子。\n\n对于后向欧拉法，格式为 $(I - \\Delta t\\,\\alpha A)\\,U^1 = U^0$。代入 $U^0=v$ 和 $U^1=g_{BE}v$：\n$(I - \\Delta t\\,\\alpha A)(g_{BE}v) = v$\n$g_{BE}(v - \\Delta t\\,\\alpha Av) = v$\n$g_{BE}(v - \\Delta t\\,\\alpha \\lambda v) = v$\n$g_{BE}(1 - \\Delta t\\,\\alpha \\lambda)v = v$\n这得出的放大因子为 $g_{BE} = (1 - \\Delta t\\,\\alpha \\lambda)^{-1}$。待测量的量 $r_{\\mathrm{BE}}$ 正是该因子的模：$r_{\\mathrm{BE}} = |g_{BE}| = |(1 - \\Delta t\\,\\alpha \\lambda)^{-1}|$。\n\n对于 Crank–Nicolson 方法，格式为 $(I - \\tfrac{1}{2}\\Delta t\\,\\alpha A)\\,U^1 = (I + \\tfrac{1}{2}\\Delta t\\,\\alpha A)\\,U^0$。代入 $U^0=v$ 和 $U^1=g_{CN}v$：\n$(I - \\tfrac{1}{2}\\Delta t\\,\\alpha A)(g_{CN}v) = (I + \\tfrac{1}{2}\\Delta t\\,\\alpha A)v$\n$g_{CN}(v - \\tfrac{1}{2}\\Delta t\\,\\alpha \\lambda v) = (v + \\tfrac{1}{2}\\Delta t\\,\\alpha \\lambda v)$\n$g_{CN}(1 - \\tfrac{1}{2}\\Delta t\\,\\alpha \\lambda)v = (1 + \\tfrac{1}{2}\\Delta t\\,\\alpha \\lambda)v$\n这得出的放大因子为 $g_{CN} = \\frac{1 + \\frac{1}{2}\\Delta t\\,\\alpha \\lambda}{1 - \\frac{1}{2}\\Delta t\\,\\alpha \\lambda}$。测量的量是 $r_{\\mathrm{CN}} = |g_{CN}| = \\left|\\frac{1 + \\frac{1}{2}\\Delta t\\,\\alpha \\lambda}{1 - \\frac{1}{2}\\Delta t\\,\\alpha \\lambda}\\right|$。\n\n实现将按以下步骤进行：\n1.  对于每个具有参数 $N$、$\\alpha$ 和 $\\Delta t$ 的测试用例，确定网格间距 $h=1/(N+1)$。\n2.  构造大小为 $N^2 \\times N^2$ 的稀疏矩阵 $A$。一种计算上高效的构造该矩阵的方法是通过两个 $N \\times N$ 的一维拉普拉斯矩阵的克罗内克和。一维拉普拉斯格式矩阵是 $L_{1D} = \\text{tridiag}(1, -2, 1)$。然后二维拉普拉斯矩阵是 $A = \\frac{1}{h^2}(I \\otimes L_{1D} + L_{1D} \\otimes I)$。\n3.  通过计算 $i,j \\in \\{1, \\dots, N\\}$ 的 $u^0_{i,j} = \\sin(\\frac{iN\\pi}{N+1})\\sin(\\frac{jN\\pi}{N+1})$ 并将得到的 $N \\times N$ 数组展开为长度为 $N^2$ 的向量，来构造初始条件向量 $v=U^0$。\n4.  对于后向欧拉法，形成线性系统 $(I - \\Delta t\\,\\alpha A)\\,U^1_{\\mathrm{BE}} = v$ 并求解 $U^1_{\\mathrm{BE}}$。\n5.  对于 Crank-Nicolson 方法，计算右侧向量 $b_{\\mathrm{CN}} = (I + \\tfrac{1}{2}\\Delta t\\,\\alpha A)v$。然后，形成线性系统 $(I - \\tfrac{1}{2}\\Delta t\\,\\alpha A)\\,U^1_{\\mathrm{CN}} = b_{\\mathrm{CN}}$ 并求解 $U^1_{\\mathrm{CN}}$。为了提高效率，使用稀疏线性代数程序至关重要。\n6.  使用指定的投影公式计算放大系数：$r_{\\mathrm{BE}} = |\\frac{v^\\top U^1_{\\mathrm{BE}}}{v^\\top v}|$ 和 $r_{\\mathrm{CN}} = |\\frac{v^\\top U^1_{\\mathrm{CN}}}{v^\\top v}|$。\n7.  收集所有测试用例的结果，并按要求格式化为单行输出。对于退化情况 $\\Delta t=0$，两种方法都简化为 $U^1=U^0$，得出 $r_{\\mathrm{BE}}=r_{\\mathrm{CN}}=1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing Backward Euler and Crank-Nicolson schemes\n    for the 2D heat equation on its highest-frequency eigenmode.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, alpha, dt)\n        (64, 1.0, 0.0),\n        (64, 1.0, 1e-4),\n        (64, 1.0, 1e-3),\n        (64, 1.0, 1e-2),\n    ]\n\n    results = []\n    \n    for N, alpha, dt in test_cases:\n        # 1. Grid and Matrix Setup\n        h = 1.0 / (N + 1)\n        N_sq = N * N\n\n        # Construct the 1D second-derivative stencil matrix\n        main_diag = -2.0 * np.ones(N)\n        off_diag = np.ones(N - 1)\n        T_1D = sparse.diags([off_diag, main_diag, off_diag], [-1, 0, 1], shape=(N, N), format='csc')\n        \n        # Construct the 2D Laplacian matrix A using Kronecker sum\n        # A represents the operator Delta_h = 1/h^2 * (stencil)\n        I_N = sparse.identity(N, format='csc')\n        A = (1.0 / h**2) * (sparse.kron(I_N, T_1D) + sparse.kron(T_1D, I_N))\n        \n        # 2. Initial Condition Vector (Highest-Frequency Eigenmode)\n        i = np.arange(1, N + 1)\n        j = np.arange(1, N + 1)\n        ii, jj = np.meshgrid(i, j, indexing='ij')\n        \n        # u^0_{i,j} = sin(i*N*pi/(N+1)) * sin(j*N*pi/(N+1))\n        arg_factor = N * np.pi / (N + 1)\n        u0_grid = np.sin(ii * arg_factor) * np.sin(jj * arg_factor)\n        \n        # Flatten the 2D grid data into a 1D vector v = U^0\n        v = u0_grid.flatten()\n        \n        # Identity matrix of size N^2 x N^2\n        I_N_sq = sparse.identity(N_sq, format='csc')\n\n        # Handle the case dt = 0 separately for robustness, although the\n        # general formulas below would also work.\n        if dt == 0.0:\n            U1_BE = v\n            U1_CN = v\n        else:\n            # 3. Backward Euler (BE) Step\n            # Solve (I - dt * alpha * A) * U^1_BE = U^0\n            M_BE = I_N_sq - dt * alpha * A\n            U1_BE = spsolve(M_BE, v)\n        \n            # 4. Crank-Nicolson (CN) Step\n            # Solve (I - 0.5 * dt * alpha * A) * U^1_CN = (I + 0.5 * dt * alpha * A) * U^0\n            M_CN_LHS = I_N_sq - 0.5 * dt * alpha * A\n            # Compute RHS = (I + 0.5 * dt * alpha * A) * v\n            # The matrix-vector product is more efficient than forming the RHS matrix\n            RHS_CN = v + (0.5 * dt * alpha) * (A @ v)\n            U1_CN = spsolve(M_CN_LHS, RHS_CN)\n\n        # 5. Compute Amplification Magnitudes\n        # r = |(v^T * U^1) / (v^T * v)|\n        v_dot_v = np.dot(v, v)\n        \n        v_dot_U1_BE = np.dot(v, U1_BE)\n        r_BE = np.abs(v_dot_U1_BE / v_dot_v)\n        \n        v_dot_U1_CN = np.dot(v, U1_CN)\n        r_CN = np.abs(v_dot_U1_CN / v_dot_v)\n        \n        results.extend([r_BE, r_CN])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了稳定性，精度是评估数值方法的另一个关键维度，尤其是在处理具有复杂物理特性的问题时。例如，当热扩散具有强各向异性（即在一个方向上的扩散远快于另一个方向）时，解中可能会出现薄边界层，这对网格分辨率提出了严峻挑战。本练习 () 将理论推导与数值实验相结合，引导您分析在这种情况下截断误差的标度行为，从而揭示名义上的二阶精度是如何在网格未能充分解析物理尺度时失效的。",
            "id": "3393392",
            "problem": "考虑单位正方形域 $[0,1]\\times[0,1]$ 上的各向异性二维热方程（一种偏微分方程 (PDE)），\n$$\nu_t = \\partial_x\\left(\\epsilon\\,\\partial_x u\\right) + \\partial_y\\left(\\partial_y u\\right),\n$$\n其中各向异性参数 $\\epsilon > 0$ 且 $\\epsilon \\ll 1$ 为常数。设 $u(x,y,t)$ 足够光滑，并假设空间离散化在 $x$ 和 $y$ 方向上使用均匀张量积网格，其网格间距分别为 $h_x = 1/(N_x-1)$ 和 $h_y = 1/(N_y-1)$，采用二阶中心有限差分法，其中 $N_x \\ge 3$ 和 $N_y \\ge 3$ 为整数。仅关注算子\n$$\n\\mathcal{L}[u] = \\epsilon\\,u_{xx} + u_{yy},\n$$\n的空间离散化，并通过考虑一个与时间无关的人造光滑解来忽略任何时间步进误差。\n\n从有限差分和泰勒展开的基本定义出发，并利用当 $\\epsilon \\ll 1$ 时可能出现薄边界层这一事实，推导 $\\mathcal{L}[u]$ 的二阶中心差分近似的空间截断误差关于 $h_x$、$h_y$ 和 $\\epsilon$ 的主阶缩放规律。您的推导必须从以下几点开始：\n- 一维二阶导数的中心二阶差分近似，\n- 围绕网格点的泰勒展开，\n- 一个函数的导数的合理缩放，该函数表现出一个沿 $x$ 轴对齐、特征厚度依赖于 $\\epsilon$ 的边界层。\n\n然后，使用以下与时间无关且表现出 $x$ 方向薄层的人造解，通过经验验证您的缩放定律：\n$$\nU(x,y) = \\exp\\!\\left(-\\frac{x}{\\sqrt{\\epsilon}}\\right)\\,\\sin(\\pi y).\n$$\n对于此 $U(x,y)$，精确的算子值为\n$$\n\\mathcal{L}[U](x,y) = \\epsilon\\,U_{xx}(x,y) + U_{yy}(x,y),\n$$\n需通过解析方法计算。\n\n实现一个程序，该程序：\n- 在 $[0,1]\\times[0,1]$ 上构建均匀网格 $(x_i,y_j)$，其中 $i=0,\\dots,N_x-1$ 且 $j=0,\\dots,N_y-1$，\n- 在网格点上计算 $U$，\n- 在内部点 $(i,j)$（其中 $1\\le i \\le N_x-2$ 且 $1\\le j \\le N_y-2$）上，使用在 $i=0$、$i=N_x-1$、$j=0$ 和 $j=N_y-1$ 处的精确边界值 $U$ 构建二阶中心差分近似 $\\mathcal{L}_h[U]$，\n- 计算最大范数空间离散误差\n$$\nE(N_x,N_y;\\epsilon) = \\max_{1\\le i\\le N_x-2,\\,1\\le j\\le N_y-2} \\left| \\mathcal{L}_h[U](x_i,y_j) - \\mathcal{L}[U](x_i,y_j)\\right|.\n$$\n\n使用以下测试套件评估误差缩放的不同方面：\n- 测试 1（$x$ 方向的分辨率；理想情况）：$\\epsilon=10^{-3}$，$(N_x,N_y)$ 对为 $(801,1601)$ 和 $(1601,1601)$。计算关于 $h_x$ 的经验阶，\n$$\np_x = \\frac{\\log\\left(E(801,1601;10^{-3})/E(1601,1601;10^{-3})\\right)}{\\log\\left(h_x(801)/h_x(1601)\\right)}.\n$$\n- 测试 2（$y$ 方向的分辨率；理想情况）：$\\epsilon=10^{-3}$，$(N_x,N_y)$ 对为 $(1601,81)$ 和 $(1601,161)$。计算关于 $h_y$ 的经验阶，\n$$\np_y = \\frac{\\log\\left(E(1601,81;10^{-3})/E(1601,161;10^{-3})\\right)}{\\log\\left(h_y(81)/h_y(161)\\right)}.\n$$\n- 测试 3（各向异性缩放；参数敏感性）：在 $(N_x,N_y)=(801,3201)$ 固定的情况下，比较 $\\epsilon_1=10^{-3}$ 和 $\\epsilon_2=2\\times 10^{-3}$。计算误差关于 $\\epsilon$ 的经验指数，\n$$\nq_\\epsilon = \\frac{\\log\\left(E(801,3201;10^{-3})/E(801,3201;2\\times 10^{-3})\\right)}{\\log\\left((2\\times 10^{-3})/(10^{-3})\\right)}.\n$$\n- 测试 4（边界层欠解析；边界情况）：报告相对于层厚度而言 $x$ 网格较粗时的误差，$\\epsilon=10^{-3}$，$(N_x,N_y)=(33,161)$，\n$$\nE_{\\text{bad}} = E(33,161;10^{-3}).\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：$[p_x,p_y,q_\\epsilon,E_{\\text{bad}}]$。所有四个输出都必须是实数（浮点值）。不应打印任何其他文本。",
            "solution": "该问题提法恰当，科学上合理，并为理论推导和经验验证提供了所有必要信息。因此，我们可以着手求解。\n\n任务是确定各向异性算子 $\\mathcal{L}[u] = \\epsilon\\,u_{xx} + u_{yy}$ 的有限差分近似的空间截断误差的缩放规律，并通过数值方法验证该缩放规律。\n\n### 第一部分：截断误差缩放的推导\n\n我们首先对离散化进行形式化，并推导其截断误差。\n\n待离散化的算子是 $\\mathcal{L}[u](x,y) = \\epsilon \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。我们使用间距为 $h_x$ 和 $h_y$ 的均匀网格。在网格点 $(x_i, y_j)$ 处，二阶偏导数的标准二阶中心差分近似为：\n$$\n\\delta_x^2 u_{i,j} = \\frac{u(x_i+h_x, y_j) - 2u(x_i, y_j) + u(x_i-h_x, y_j)}{h_x^2}\n$$\n$$\n\\delta_y^2 u_{i,j} = \\frac{u(x_i, y_j+h_y) - 2u(x_i, y_j) + u(x_i, y_j-h_y)}{h_y^2}\n$$\n离散算子 $\\mathcal{L}_h$ 定义为 $\\mathcal{L}_h[u]_{i,j} = \\epsilon \\delta_x^2 u_{i,j} + \\delta_y^2 u_{i,j}$。\n\n为求截断误差，我们假设 $u$ 足够光滑，在点 $(x_i, y_j)$ 周围进行泰勒级数展开。对于 $x$ 方向：\n$$\nu(x_i \\pm h_x, y_j) = u \\pm h_x u_x + \\frac{h_x^2}{2} u_{xx} \\pm \\frac{h_x^3}{6} u_{xxx} + \\frac{h_x^4}{24} u_{xxxx} + O(h_x^5)\n$$\n其中所有偏导数均在 $(x_i, y_j)$ 处求值。将此代入 $\\delta_x^2 u_{i,j}$ 的表达式，得到：\n$$\n\\delta_x^2 u_{i,j} = \\frac{1}{h_x^2} \\left( (u+h_x u_x + \\dots) - 2u + (u-h_x u_x + \\dots) \\right) = \\frac{h_x^2 u_{xx} + \\frac{h_x^4}{12}u_{xxxx} + O(h_x^6)}{h_x^2} = u_{xx} + \\frac{h_x^2}{12}u_{xxxx} + O(h_x^4)\n$$\n对 $y$ 方向进行类似推导可得：\n$$\n\\delta_y^2 u_{i,j} = u_{yy} + \\frac{h_y^2}{12}u_{yyyy} + O(h_y^4)\n$$\n截断误差 $\\tau_{i,j}$ 定义为离散算子和连续算子作用于精确解 $u$ 的差：\n$$\n\\tau_{i,j} = \\mathcal{L}_h[u]_{i,j} - \\mathcal{L}[u]_{i,j} = (\\epsilon \\delta_x^2 u_{i,j} + \\delta_y^2 u_{i,j}) - (\\epsilon u_{xx} + u_{yy})\n$$\n代入有限差分的泰勒级数结果，我们得到：\n$$\n\\tau_{i,j} = \\epsilon\\left(u_{xx} + \\frac{h_x^2}{12}u_{xxxx} + O(h_x^4)\\right) + \\left(u_{yy} + \\frac{h_y^2}{12}u_{yyyy} + O(h_y^4)\\right) - (\\epsilon u_{xx} + u_{yy})\n$$\n因此，主阶截断误差为：\n$$\n\\tau_{i,j} \\approx \\frac{\\epsilon h_x^2}{12} \\frac{\\partial^4 u}{\\partial x^4} + \\frac{h_y^2}{12} \\frac{\\partial^4 u}{\\partial y^4}\n$$\n问题陈述指出，当 $\\epsilon \\ll 1$ 时，可能出现薄边界层。所选的人造解 $U(x,y) = \\exp(-x/\\sqrt{\\epsilon})\\sin(\\pi y)$ 旨在沿 $x=0$ 边界展现这样一个层，其特征厚度为 $\\delta \\sim \\sqrt{\\epsilon}$。我们必须计算该解的偏导数的大小。\n\n让我们计算 $U(x,y)$ 所需的导数：\n关于 $x$ 的 $k$ 阶偏导数为：\n$$\n\\frac{\\partial^k U}{\\partial x^k} = \\left(-\\frac{1}{\\sqrt{\\epsilon}}\\right)^k \\exp\\left(-\\frac{x}{\\sqrt{\\epsilon}}\\right)\\sin(\\pi y) = (-1)^k \\epsilon^{-k/2} U(x,y)\n$$\n因此，对于 $k=4$：\n$$\n\\frac{\\partial^4 U}{\\partial x^4} = \\epsilon^{-2} U(x,y)\n$$\n关于 $y$ 的偏导数为：\n$$\n\\frac{\\partial^2 U}{\\partial y^2} = -\\pi^2 \\exp\\left(-\\frac{x}{\\sqrt{\\epsilon}}\\right)\\sin(\\pi y) = -\\pi^2 U(x,y)\n$$\n$$\n\\frac{\\partial^4 U}{\\partial y^4} = \\pi^4 \\exp\\left(-\\frac{x}{\\sqrt{\\epsilon}}\\right)\\sin(\\pi y) = \\pi^4 U(x,y)\n$$\n$y$ 方向的导数不具有对 $\\epsilon$ 的奇异依赖性（即，它们在 $\\epsilon$ 上是 $O(1)$），而 $x$ 方向的导数在 $\\epsilon \\to 0$ 时缩放得非常不利。\n\n将这些导数的大小代入截断误差的表达式，得到其缩放规律：\n$$\n\\tau \\approx \\frac{\\epsilon h_x^2}{12} \\left(\\epsilon^{-2} U(x,y)\\right) + \\frac{h_y^2}{12} \\left(\\pi^4 U(x,y)\\right) = \\left( \\frac{h_x^2}{12\\epsilon} + \\frac{\\pi^4 h_y^2}{12} \\right) U(x,y)\n$$\n问题中测量的误差 $E$ 是该截断误差在内部网格点上的最大范数。域上 $|U(x,y)|$ 的最大值为 $1$。因此，误差由括号中两个项中较大的一个主导：\n$$\nE(N_x, N_y; \\epsilon) \\sim O\\left(\\frac{h_x^2}{\\epsilon} + h_y^2\\right)\n$$\n这就是空间截断误差的主要缩放定律。\n\n### 第二部分：对经验测试的预测\n\n我们现在可以使用这个缩放定律来预测四个测试的结果。\n\n1.  **测试 1 ($p_x$)**：此处，$h_y$ 很小 ($N_y=1601$)，而 $h_x$ 是变化的。与包含 $h_x$ 的项相比，$h_y^2$ 项可以忽略不计。误差预计将按 $E \\propto h_x^2$ 缩放。经验阶 $p_x$ 是通过将 $h_x$ 减半的加密研究计算得出的。因此，我们预测 $p_x \\approx 2$。\n\n2.  **测试 2 ($p_y$)**：此处，$h_x$ 很小 ($N_x=1601$)，因此 $h_x^2/\\epsilon$ 项变得很小。误差应由第二项 $E \\propto h_y^2$ 主导。因此，我们预测经验阶为 $p_y \\approx 2$。\n\n3.  **测试 3 ($q_\\epsilon$)**：此处，$h_x=1/800$ 和 $h_y=1/3200$ 是固定的，而 $\\epsilon$ 是变化的。让我们比较当 $\\epsilon \\sim 10^{-3}$ 时两个误差项的大小：\n    - 第 1 项: $\\frac{h_x^2}{\\epsilon} = \\frac{(1/800)^2}{10^{-3}} = \\frac{1000}{640000} = \\frac{1}{640} \\approx 1.56 \\times 10^{-3}$。\n    - 第 2 项: $h_y^2 = (1/3200)^2 \\approx 9.77 \\times 10^{-8}$。\n    第一项比第二项大几个数量级，占主导地位。我们可以假设 $E \\propto \\epsilon^{-1}$。设 $E_1 = E(\\epsilon_1)$ 和 $E_2 = E(\\epsilon_2)$。那么 $E_1/E_2 \\approx (\\epsilon_1^{-1})/(\\epsilon_2^{-1}) = \\epsilon_2/\\epsilon_1$。要计算的量是 $q_\\epsilon = \\frac{\\log(E_1/E_2)}{\\log(\\epsilon_2/\\epsilon_1)}$。代入我们的近似值得到 $q_\\epsilon \\approx \\frac{\\log(\\epsilon_2/\\epsilon_1)}{\\log(\\epsilon_2/\\epsilon_1)} = 1$。我们预测 $q_\\epsilon \\approx 1$。\n\n4.  **测试 4 ($E_{\\text{bad}}$)**：在这种情况下，$\\epsilon = 10^{-3}$ 且 $(N_x, N_y) = (33, 161)$。特征层宽度为 $\\delta = \\sqrt{\\epsilon} \\approx 0.0316$。$x$ 方向的网格间距为 $h_x = 1/(33-1) = 1/32 = 0.03125$。比率 $h_x/\\delta \\approx 1$，意味着边界层严重欠解析。假设 $h_x$ 小到足以使泰勒展开有效的渐近理论可能会失效。然而，使用主阶误差项作为估计，得到 $E \\approx \\frac{h_x^2}{12\\epsilon} = \\frac{(1/32)^2}{12 \\times 10^{-3}} \\approx 0.081$。我们预计会出现如此量级的大误差，这反映了标准二阶收敛的失效。\n\n现在将通过实现来验证这些预测。一个重要的准备步骤是计算 $\\mathcal{L}[U]$ 的确切形式。使用我们之前的导数计算：\n$$\n\\mathcal{L}[U] = \\epsilon U_{xx} + U_{yy} = \\epsilon \\left(\\frac{1}{\\epsilon} U\\right) + (-\\pi^2 U) = U - \\pi^2 U = (1-\\pi^2)U\n$$\n这个方便的解析形式将用于计算精确误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_error(Nx, Ny, epsilon):\n    \"\"\"\n    Computes the maximum-norm spatial discretization error for the\n    anisotropic heat operator on a manufactured solution.\n\n    Args:\n        Nx (int): Number of grid points in the x-direction.\n        Ny (int): Number of grid points in the y-direction.\n        epsilon (float): Anisotropy parameter.\n\n    Returns:\n        float: The maximum-norm error E(Nx, Ny; epsilon).\n    \"\"\"\n    # 1. Construct the grid\n    hx = 1.0 / (Nx - 1)\n    hy = 1.0 / (Ny - 1)\n    x = np.linspace(0.0, 1.0, Nx)\n    y = np.linspace(0.0, 1.0, Ny)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Evaluate the manufactured solution on the grid\n    # U(x,y) = exp(-x/sqrt(epsilon)) * sin(pi*y)\n    sqrt_eps = np.sqrt(epsilon)\n    U = np.exp(-xx / sqrt_eps) * np.sin(np.pi * yy)\n\n    # 3. Evaluate the exact operator value\n    # L[U] = epsilon*U_xx + U_yy = (1 - pi^2) * U\n    L_exact = (1.0 - np.pi**2) * U\n\n    # 4. Form the second-order central-difference approximation Lh[U]\n    # This is computed only at interior points (1 = i = Nx-2, 1 = j = Ny-2)\n    # The slicing U[2:, 1:-1] corresponds to u_{i+1,j} for interior i,j etc.\n    U_xx_approx = (U[2:, 1:-1] - 2*U[1:-1, 1:-1] + U[:-2, 1:-1]) / (hx**2)\n    U_yy_approx = (U[1:-1, 2:] - 2*U[1:-1, 1:-1] + U[1:-1, :-2]) / (hy**2)\n\n    Lh_U_interior = epsilon * U_xx_approx + U_yy_approx\n\n    # 5. Compute the maximum-norm error on the interior\n    L_exact_interior = L_exact[1:-1, 1:-1]\n    error = np.max(np.abs(Lh_U_interior - L_exact_interior))\n\n    return error\n\ndef solve():\n    \"\"\"\n    Executes the full test suite as defined in the problem statement\n    and prints the results in the specified format.\n    \"\"\"\n    # --- Test 1: Empirical order in x (px) ---\n    epsilon1 = 1e-3\n    Nx1_1, Ny1_1 = 801, 1601\n    Nx1_2, Ny1_2 = 1601, 1601\n    \n    E1_1 = compute_error(Nx1_1, Ny1_1, epsilon1)\n    E1_2 = compute_error(Nx1_2, Ny1_2, epsilon1)\n\n    hx1_1 = 1.0 / (Nx1_1 - 1)\n    hx1_2 = 1.0 / (Nx1_2 - 1)\n\n    px = np.log(E1_1 / E1_2) / np.log(hx1_1 / hx1_2)\n\n    # --- Test 2: Empirical order in y (py) ---\n    epsilon2 = 1e-3\n    Nx2_1, Ny2_1 = 1601, 81\n    Nx2_2, Ny2_2 = 1601, 161\n\n    E2_1 = compute_error(Nx2_1, Ny2_1, epsilon2)\n    E2_2 = compute_error(Nx2_2, Ny2_2, epsilon2)\n\n    hy2_1 = 1.0 / (Ny2_1 - 1)\n    hy2_2 = 1.0 / (Ny2_2 - 1)\n\n    py = np.log(E2_1 / E2_2) / np.log(hy2_1 / hy2_2)\n\n    # --- Test 3: Anisotropy scaling (q_epsilon) ---\n    Nx3, Ny3 = 801, 3201\n    epsilon3_1 = 1e-3\n    epsilon3_2 = 2e-3\n\n    E3_1 = compute_error(Nx3, Ny3, epsilon3_1)\n    E3_2 = compute_error(Nx3, Ny3, epsilon3_2)\n\n    # Formula from problem: log(E1/E2) / log(eps2/eps1)\n    q_epsilon = np.log(E3_1 / E3_2) / np.log(epsilon3_2 / epsilon3_1)\n\n    # --- Test 4: Boundary-layer under-resolution (E_bad) ---\n    epsilon4 = 1e-3\n    Nx4, Ny4 = 33, 161\n    E_bad = compute_error(Nx4, Ny4, epsilon4)\n\n    # --- Final Output ---\n    results = [px, py, q_epsilon, E_bad]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}