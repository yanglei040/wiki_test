{
    "hands_on_practices": [
        {
            "introduction": "在迭代求解器中，仅观察残差的绝对大小意义不大；我们真正关心的是其相对下降幅度。然而，“相对”于什么进行比较是一个关键但常常被忽视的问题。本实践将指导您通过一个简化的可压缩流体力学问题，亲手实现并对比三种主流的残差归一化策略，从而深刻理解在网格加密或物理参数（如雷诺数 $Re$）变化时，不同的收敛判据如何影响我们对“收敛”的判断。",
            "id": "3305239",
            "problem": "您的任务是研究不同的残差归一化选择如何影响在可压缩Navier–Stokes方程的牛顿线性化过程中产生的迭代线性求解器的表观收敛性。请在一个一维、无量纲的设定下进行研究，该设定能捕捉对流和扩散输运的标度律以及可压缩性稳定化的影响。其基础是以下广泛使用的过程：通过牛顿法求解非线性残差方程 $F(U) = 0$，在非线性迭代步 $m$ 处产生一个线性系统 $J(U^{(m)}) \\,\\Delta U^{(m)} = -F(U^{(m)})$，其中 $J$ 是 $F$ 的雅可比矩阵。对于一个固定的非线性迭代解 $U^{(m)}$，内层线性迭代求解器在求解 $J x = b$（其中 $b = -F(U^{(m)})$）时维持一个当前迭代解 $x^{(k)}$，并定义线性残差为 $r^{(k)} = b - J x^{(k)}$。内层求解器的收敛通常通过检查某个归一化残差是否低于一个容差来判断。\n\n以此为基础，构建一个合成的一维线性化算子，并研究三种残差归一化策略：按初始残差范数缩放、按右端项范数缩放以及按雅可比矩阵的对角线缩放。使用来自带可压缩性稳定化的一维对流扩散问题的基本标度关系，将 $J \\in \\mathbb{R}^{n \\times n}$ 定义为一个三对角矩阵：\n- 对角线元素为 $J_{ii} = \\alpha + \\dfrac{2 \\nu}{h^2}$。\n- 次对角线元素为 $J_{i,i-1} = -\\dfrac{\\nu}{h^2} - \\dfrac{U}{2 h}$（对于 $i \\geq 2$）。\n- 超对角线元素为 $J_{i,i+1} = -\\dfrac{\\nu}{h^2} + \\dfrac{U}{2 h}$（对于 $i \\leq n-1$）。\n此处，$h = \\dfrac{1}{n}$ 是单位区间上的网格间距，$U$ 是一个恒定的平流速度，$\\nu = \\dfrac{1}{Re}$ 是无量纲形式的运动粘度，其中 $Re$ 是雷诺数。参数 $\\alpha  0$ 代表可压缩性或伪时间稳定化，并且可以取足够大的值以确保在整个测试套件中矩阵都是对角占优的。\n\n将右端项定义为 $b_i = \\sin(\\pi x_i)$，其中 $x_i = i h$，$i = 1, \\dots, n$。使用初始猜测 $x^{(0)}_i = x_i$，$i = 1, \\dots, n$，因此有 $r^{(0)} = b - J x^{(0)} \\neq b$。\n\n使用加权雅可比（WJ）迭代来推进线性求解过程：\n$$\nx^{(k+1)} = x^{(k)} + \\omega D^{-1} \\left(b - J x^{(k)}\\right),\n$$\n其中 $D = \\mathrm{diag}(J)$ 且 $\\omega \\in (0, 2)$ 是一个松弛参数。选择固定的内迭代次数 $K$ 和固定的松弛参数 $\\omega$，并假设 $D$ 的所有元素都严格为正。\n\n对于每个测试用例，在 $K$ 次迭代后，计算残差 $r^{(K)}$ 并评估以下三种归一化残差的定义：\n1. 按初始残差范数缩放：$R_{r_0} = \\dfrac{\\lVert r^{(K)} \\rVert_2}{\\lVert r^{(0)} \\rVert_2}$。\n2. 按右端项范数缩放：$R_{b} = \\dfrac{\\lVert r^{(K)} \\rVert_2}{\\lVert b \\rVert_2}$。\n3. 按雅可比矩阵对角线缩放（行向平衡）：$R_{D} = \\dfrac{\\lVert D^{-1} r^{(K)} \\rVert_2}{\\lVert D^{-1} r^{(0)} \\rVert_2}$。\n\n此外，对于每种归一化方法，通过与固定容差 $\\tau$ 进行比较来定义一个布尔收敛标志：对于归一化 $R_{\\star}$，如果 $R_{\\star} \\le \\tau$，则设置 $C_{\\star} = \\mathrm{True}$，否则设置 $C_{\\star} = \\mathrm{False}$。\n\n您的程序必须使用以下固定参数来实现上述过程：\n- 使用 $U = 1$。\n- 使用 $\\alpha = 500$。\n- 使用 $\\omega = 1$。\n- 使用 $K = 30$。\n- 使用 $\\tau = 10^{-6}$。\n所有量都是无量纲的，且不使用角度。\n\n构建并运行以下测试套件，其旨在探测网格加密和雷诺数变化的影响：\n- 用例 1：$n = 50$, $Re = 50$。\n- 用例 2：$n = 200$, $Re = 50$。\n- 用例 3：$n = 50$, $Re = 1000$。\n- 用例 4：$n = 200$, $Re = 1000$。\n- 用例 5：$n = 50$, $Re = 5$。\n\n对于每个用例，您的程序必须返回一个列表，顺序为 $[R_{r_0}, R_b, R_D, C_{r_0}, C_b, C_D]$，其中包含三个浮点数和三个布尔值。将所有用例的结果汇总到一个列表中，最终输出为单行文本，其中包含由逗号分隔的五个用例结果，并用方括号括起来。例如，打印的行必须类似于 $[\\,[\\dots],\\,[\\dots],\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$，每个内部列表都按指定顺序排列。不得打印任何额外文本。",
            "solution": "该问题要求对用于评估迭代线性求解器收敛性的三种不同残差归一化策略进行批判性研究。其背景是一个合成的一维问题，该问题代表了计算流体动力学（CFD）中遇到的典型问题，特别是源于可压缩Navier-Stokes方程的牛顿线性化。分析将通过实现指定的数值方案并将其应用于一套测试用例来进行。\n\n首先，我们将问题设定形式化。核心任务是迭代求解以下线性方程组：\n$$\nJ x = b\n$$\n此处，$J \\in \\mathbb{R}^{n \\times n}$ 是一个稀疏三对角矩阵，代表带稳定项的离散化一维对流扩散算子。其元素是基于单位区间上间距为 $h = \\dfrac{1}{n}$ 的均匀网格定义的。参数包括恒定的平流速度 $U$、运动粘度 $\\nu = \\dfrac{1}{Re}$（其中 $Re$ 是雷诺数）以及稳定化参数 $\\alpha$。矩阵元素如下：\n- 对角线：$J_{ii} = \\alpha + \\dfrac{2 \\nu}{h^2}$\n- 次对角线：$J_{i,i-1} = -\\dfrac{\\nu}{h^2} - \\dfrac{U}{2 h}$，对于 $i = 2, \\dots, n$\n- 超对角线：$J_{i,i+1} = -\\dfrac{\\nu}{h^2} + \\dfrac{U}{2 h}$，对于 $i = 1, \\dots, n-1$\n\n右端项（RHS）向量 $b \\in \\mathbb{R}^n$ 是通过在网格点 $x_i = i h$（$i = 1, \\dots, n$）上评估一个平滑函数来定义的：\n$$\nb_i = \\sin(\\pi x_i)\n$$\n迭代求解过程始于一个初始猜测 $x^{(0)} \\in \\mathbb{R}^n$，它被指定为网格坐标向量：\n$$\nx^{(0)}_i = x_i\n$$\n\n所选的迭代求解器是加权雅可比（WJ）方法。解从迭代步 $k$ 推进到 $k+1$ 使用以下公式：\n$$\nx^{(k+1)} = x^{(k)} + \\omega D^{-1} \\left(b - J x^{(k)}\\right)\n$$\n其中 $D = \\mathrm{diag}(J)$ 是 $J$ 的对角部分，$\\omega$ 是一个松弛参数，括号中的项是在迭代步 $k$ 处的线性残差，定义为 $r^{(k)} = b - J x^{(k)}$。对于此问题，参数是固定的：$\\omega = 1$（这将方法简化为标准雅可比迭代），并且迭代次数固定为 $K = 30$。问题假设 $D$ 的元素严格为正，由于 $J_{ii} = \\alpha + \\frac{2\\nu}{h^2}$ 且有 $\\alpha  0$ 和 $\\nu  0$，此条件在此处得到满足。\n\n在执行 $K=30$ 次迭代后，我们得到最终状态 $x^{(K)}$ 和最终残差 $r^{(K)} = b - J x^{(K)}$。核心任务是评估三种不同的归一化残差：\n1.  **按初始残差范数缩放**：此度量 $R_{r_0}$ 衡量残差量级相对于其初始值的减小程度。初始残差为 $r^{(0)} = b - J x^{(0)}$。\n    $$\n    R_{r_0} = \\dfrac{\\lVert r^{(K)} \\rVert_2}{\\lVert r^{(0)} \\rVert_2}\n    $$\n2.  **按右端项范数缩放**：此度量 $R_{b}$ 衡量最终残差量级相对于强迫项 $b$ 的大小。\n    $$\n    R_{b} = \\dfrac{\\lVert r^{(K)} \\rVert_2}{\\lVert b \\rVert_2}\n    $$\n3.  **按雅可比矩阵对角线缩放（行向平衡）**：此度量 $R_{D}$ 衡量预处理后残差范数的减小程度，其中预处理器是雅可比矩阵的对角线。这通常提供了一种尺度不变的收敛性度量。\n    $$\n    R_{D} = \\dfrac{\\lVert D^{-1} r^{(K)} \\rVert_2}{\\lVert D^{-1} r^{(0)} \\rVert_2}\n    $$\n\n对于这些归一化残差中的每一个 $R_{\\star}$，通过将其与固定容差 $\\tau = 10^{-6}$ 进行比较来确定一个布尔收敛标志 $C_{\\star}$。如果 $R_{\\star} \\le \\tau$，则该标志设置为 $\\mathrm{True}$，否则设置为 $\\mathrm{False}$。\n\n每个测试用例 $(n, Re)$ 的计算过程如下：\n1. 设置固定参数：$U = 1$，$\\alpha = 500$，$\\omega = 1$，$K = 30$，$\\tau = 10^{-6}$。\n2. 计算派生参数：$h = 1/n$ 和 $\\nu = 1/Re$。\n3. 构建 $n \\times n$ 的三对角矩阵 $J$。\n4. 构建网格向量 $x_{grid}$，其元素为 $x_i = i h$。\n5. 构建右端项向量 $b$，其元素为 $b_i = \\sin(\\pi x_i)$。\n6. 设置初始解向量 $x^{(0)} = x_{grid}$。\n7. 计算初始残差 $r^{(0)} = b - Jx^{(0)}$。\n8. 从 $J$ 中提取对角矩阵 $D$。\n9. 计算并存储分母中的范数：$\\lVert r^{(0)} \\rVert_2$、$\\lVert b \\rVert_2$ 和 $\\lVert D^{-1} r^{(0)} \\rVert_2$。\n10. 执行雅可比迭代循环，其中 $k$ 从 $0$ 到 $K-1=29$：$x^{(k+1)} = x^{(k)} + \\omega D^{-1} (b - J x^{(k)})$。\n11. 完成后，计算最终残差 $r^{(K)} = b - J x^{(K)}$。\n12. 计算分子中的范数：$\\lVert r^{(K)} \\rVert_2$ 和 $\\lVert D^{-1} r^{(K)} \\rVert_2$。\n13. 计算三个比率 $R_{r_0}$、$R_{b}$ 和 $R_{D}$。\n14. 确定三个布尔标志 $C_{r_0}$、$C_{b}$ 和 $C_{D}$。\n15. 将结果整理成 $[R_{r_0}, R_b, R_D, C_{r_0}, C_b, C_D]$ 形式的列表。\n\n此过程被系统地应用于所有指定的测试用例，并将最终结果汇总到一个单一列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(n, Re, U, alpha, omega, K, tau):\n    \"\"\"\n    Solves the 1D convection-diffusion problem for one test case.\n\n    Args:\n        n (int): Number of grid points.\n        Re (float): Reynolds number.\n        U (float): Advection speed.\n        alpha (float): Stabilization parameter.\n        omega (float): Weighted Jacobi relaxation parameter.\n        K (int): Number of iterations.\n        tau (float): Convergence tolerance.\n\n    Returns:\n        list: A list containing [R_r0, R_b, R_D, C_r0, C_b, C_D].\n    \"\"\"\n    # 1. Calculate derived parameters\n    h = 1.0 / n\n    nu = 1.0 / Re\n\n    # 2. Construct the tridiagonal Jacobian matrix J\n    J = np.zeros((n, n))\n    \n    # Diagonal term\n    diag_val = alpha + (2 * nu / h**2)\n    # Sub-diagonal term\n    sub_diag_val = -nu / h**2 - U / (2 * h)\n    # Super-diagonal term\n    sup_diag_val = -nu / h**2 + U / (2 * h)\n\n    # Fill the matrix J using np.diag\n    J += np.diag(np.full(n, diag_val))\n    J += np.diag(np.full(n - 1, sub_diag_val), k=-1)\n    J += np.diag(np.full(n - 1, sup_diag_val), k=1)\n    \n    # 3. Construct grid, RHS vector b, and initial guess x_k\n    # Grid points x_i = i*h for i=1,...,n, corresponding to array indices 0,...,n-1\n    x_grid = h * (np.arange(n) + 1)\n    \n    b = np.sin(np.pi * x_grid)\n    x_k = x_grid.copy() # Initial guess x^(0)\n\n    # 4. Extract diagonal D and compute its inverse\n    D = np.diag(J)\n    D_inv = 1.0 / D\n\n    # 5. Calculate initial residual r^(0) and required norms\n    r0 = b - J @ x_k\n    norm_r0 = np.linalg.norm(r0, 2)\n    norm_b = np.linalg.norm(b, 2)\n    \n    # Preconditioned initial residual and its norm\n    # D_inv is a 1D array, so we use element-wise multiplication\n    D_inv_r0 = D_inv * r0\n    norm_D_inv_r0 = np.linalg.norm(D_inv_r0, 2)\n    \n    # Edge case: If initial residual is zero, convergence is perfect.\n    if np.isclose(norm_r0, 0.0):\n        return [0.0, 0.0, 0.0, True, True, True]\n\n    # 6. Perform K iterations of the Weighted Jacobi method\n    for _ in range(K):\n        r_k = b - J @ x_k\n        x_k += omega * D_inv * r_k\n        \n    # 7. Compute final residual r^(K) and its norms\n    r_K = b - J @ x_k\n    norm_rK = np.linalg.norm(r_K, 2)\n    \n    D_inv_r_K = D_inv * r_K\n    norm_D_inv_r_K = np.linalg.norm(D_inv_r_K, 2)\n\n    # 8. Calculate the three normalized residual metrics\n    R_r0 = norm_rK / norm_r0\n    R_b = norm_rK / norm_b if norm_b > 0 else np.inf\n    # Handle division by zero for R_D, although norm_D_inv_r0 is unlikely to be zero\n    # if norm_r0 wasn't.\n    R_D = norm_D_inv_r_K / norm_D_inv_r0 if norm_D_inv_r0 > 0 else np.inf\n\n    # 9. Determine the convergence flags\n    C_r0 = R_r0 = tau\n    C_b = R_b = tau\n    C_D = R_D = tau\n\n    return [R_r0, R_b, R_D, C_r0, C_b, C_D]\n\ndef solve():\n    # Define the fixed parameters from the problem statement.\n    U = 1.0\n    alpha = 500.0\n    omega = 1.0\n    K = 30\n    tau = 1.0e-6\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (50, 50.0),    # Case 1\n        (200, 50.0),   # Case 2\n        (50, 1000.0),  # Case 3\n        (200, 1000.0), # Case 4\n        (50, 5.0),     # Case 5\n    ]\n\n    all_results = []\n    for n, Re in test_cases:\n        result = run_case(n, Re, U, alpha, omega, K, tau)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists matches the required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "一个数学上看似收敛的解（即具有很小的残差）是否一定是一个物理上可信的解？答案是否定的。在计算流体力学等领域，确保基本物理定律（如质量守恒）的满足与降低数值残差同等重要。本练习通过一个抽象但具代表性的模型，揭示了仅依赖残差判据可能导致的陷阱：即使残差已经达标，关键的物理量（如此处的全局质量通量）可能仍存在显著误差。通过本实践，您将学会构建并评估复合收敛判据的必要性，确保计算结果的物理真实性。",
            "id": "3305180",
            "problem": "考虑在计算流体动力学 (CFD) 的背景下，一个稳态、不可压缩的顶盖驱动方腔流问题，其中迭代求解器被应用于离散的动量和连续性方程。全局质量守恒的物理要求通过不可压缩条件 $\\nabla \\cdot \\mathbf{u} = 0$ 表达，在数值上则通过确保稳态时离散散度处处为零来实现。设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个对称正定矩阵，它源于压力泊松方程或速度修正步骤的一致性离散化，$x_k$ 是第 $k$ 次迭代的迭代解，$b$ 是右端项。定义线性残差向量 $r_k = b - A x_k$ 及其欧几里得范数 $||r_k||_2$。在实践中，如果连续性强制或压力-速度耦合的收敛速度不同或收敛到一个有偏的平台期，那么仅基于减小 $||r_k||_2$ 的停止准则可能无法保证满足全局质量守恒。\n\n在迭代 $k = 0, 1, 2, \\dots$ 过程中，对两个度量的收敛性进行建模：\n- 相对残差比 $||r_k||_2 / ||r_0||_2$，假设其以 $||r_k||_2 / ||r_0||_2 = \\alpha^k$ 的形式衰减，其中收缩因子为 $0  \\alpha  1$。\n- 归一化全局质量不平衡 $\\epsilon_k$，定义为通过特征通量尺度归一化的体积分离散散度，其模型为 $\\epsilon_k = \\epsilon_\\infty + (\\epsilon_0 - \\epsilon_\\infty)\\,\\beta^k$，其中 $0 \\le \\epsilon_\\infty \\le \\epsilon_0$ 且 $0  \\beta  1$。\n\n所有量均为无量纲。设残差阈值为 $\\tau_r  0$，质量不平衡阈值为 $\\tau_m  0$，两者都以小数形式指定（例如，$0.01$ 代表百分之一的水平）。仅基于残差的停止规则在满足 $||r_k||_2 / ||r_0||_2 \\le \\tau_r$ 的最小迭代次数 $k_r$ 处停止。复合停止规则要求同时满足 $||r_k||_2 / ||r_0||_2 \\le \\tau_r$ 和 $\\epsilon_k \\le \\tau_m$，并在满足这两个条件的最小迭代次数 $k_c$ 处停止。如果 $\\epsilon_\\infty \\ge \\tau_m$ 且 $\\epsilon_0  \\tau_m$，则没有任何有限次迭代可以满足质量不平衡目标，此时复合规则是不可达的。\n\n您的任务是实现一个程序，对于给定的一组参数测试集 $(\\alpha, \\beta, \\tau_r, \\tau_m, \\epsilon_\\infty, ||r_0||_2, \\epsilon_0)$，为每一组计算：\n1. 仅基于残差的最小停止迭代次数 $k_r$。\n2. 在仅基于残差的停止迭代次数下的质量不平衡 $\\epsilon_{k_r}$。\n3. 复合停止迭代次数 $k_c$（如果不可达则为 $-1$）。\n4. 一个布尔值，指示复合准则是否可达。\n\n使用以下测试集，其设计旨在覆盖一个典型案例、理想情况、延迟的质量收敛以及一个等式边界情况。在测试用例1中，选择参数来表示一个稳态顶盖驱动方腔流场景，其中在 $||r||_2$ 的相对残差下降到 $10^{-6}$ 时停止，仍然产生量级为 $0.01$ 的质量不平衡：\n- 测试用例1：$(\\alpha, \\beta, \\tau_r, \\tau_m, \\epsilon_\\infty, ||r_0||_2, \\epsilon_0) = (0.8, 0.93, 10^{-6}, 0.005, 0.0102, 1.0, 0.1)$。\n- 测试用例2：$(\\alpha, \\beta, \\tau_r, \\tau_m, \\epsilon_\\infty, ||r_0||_2, \\epsilon_0) = (0.9, 0.6, 10^{-6}, 10^{-4}, 0.0, 1.0, 0.05)$。\n- 测试用例3：$(\\alpha, \\beta, \\tau_r, \\tau_m, \\epsilon_\\infty, ||r_0||_2, \\epsilon_0) = (0.7, 0.9, 10^{-6}, 0.001, 0.0004, 1.0, 0.1)$。\n- 测试用例4：$(\\alpha, \\beta, \\tau_r, \\tau_m, \\epsilon_\\infty, ||r_0||_2, \\epsilon_0) = \\left(10^{-0.6}, 10^{-0.3}, 10^{-6}, 10^{-3}, 0.0, 1.0, 1.0\\right)$。\n\n算法要求：\n- 计算 $k_r$ 为满足 $\\alpha^k \\le \\tau_r$ 的最小整数 $k$。如果 $\\tau_r \\ge 1$，则设 $k_r = 0$。\n- 计算 $\\epsilon_{k_r} = \\epsilon_\\infty + (\\epsilon_0 - \\epsilon_\\infty)\\,\\beta^{k_r}$。\n- 判断质量准则的可达性：如果 $\\epsilon_\\infty \\ge \\tau_m$ 且 $\\epsilon_0  \\tau_m$，则复合规则不可达。否则，计算满足 $\\epsilon_k \\le \\tau_m$ 的最小整数 $k_m$。然后设 $k_c = \\max(k_r, k_m)$。\n- 对阈值使用包含性比较（即，$\\le$ 满足准则）。\n\n您的程序应生成单行输出，包含一个以逗号分隔的列表，列表用方括号括起来，其中每个测试用例的结果是一个形如 $[k_r, \\epsilon_{k_r}, k_c, \\text{reachable}]$ 的列表。例如，输出应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。\n\n最终答案必须是小数或整数，而不是百分比。由于所有量均为无量纲，因此不需要物理单位。",
            "solution": "该问题经评估有效。它在科学上基于计算流体动力学的原理，特别是关于不可压缩流迭代求解器的收敛特性。该问题是良构的，所有参数、模型和目标都有清晰的数学定义。它是客观的，没有任何不可验证或模棱两可的陈述。\n\n任务是基于两个不同的度量来分析收敛行为：线性系统的相对残差和全局质量不平衡。我们将为满足每个度量以及复合准则的指定阈值所需的迭代次数推导解析表达式。\n\n### 1. 仅基于残差的停止迭代次数 ($k_r$) 的推导\n\n残差的停止准则基于相对残差比 $||r_k||_2 / ||r_0||_2$，其模型为 $\\alpha^k$。求解器在满足此比率小于或等于给定阈值 $\\tau_r  0$ 的最小整数迭代次数 $k_r$ 处停止。\n\n条件是：\n$$\n\\alpha^{k} \\le \\tau_r\n$$\n\n根据问题陈述，如果 $\\tau_r \\ge 1$，则在迭代 $k=0$ 时条件已满足（因为 $\\alpha^0 = 1$），所以我们设 $k_r = 0$。\n\n如果 $\\tau_r  1$，我们可以解出 $k$。因为 $0  \\alpha  1$，对数 $\\log(\\alpha)$ 是负的。对不等式两边取自然对数，我们得到：\n$$\nk \\log(\\alpha) \\le \\log(\\tau_r)\n$$\n两边同除以 $\\log(\\alpha)$ 会使不等号反向：\n$$\nk \\ge \\frac{\\log(\\tau_r)}{\\log(\\alpha)}\n$$\n由于 $k$ 必须是整数，满足此条件的最小整数 $k$ 是右侧表达式的上取整。因此，仅基于残差的停止迭代次数是：\n$$\nk_r = \\left\\lceil \\frac{\\log(\\tau_r)}{\\log(\\alpha)} \\right\\rceil \\quad \\text{对于 } \\tau_r  1\n$$\n\n### 2. $k_r$ 时的质量不平衡 ($\\epsilon_{k_r}$) 计算\n\n在第 $k$ 次迭代时的归一化全局质量不平衡由以下模型给出：\n$$\n\\epsilon_k = \\epsilon_\\infty + (\\epsilon_0 - \\epsilon_\\infty)\\,\\beta^k\n$$\n其中 $\\epsilon_0$ 是初始不平衡，$\\epsilon_\\infty$ 是渐近不平衡，$0  \\beta  1$ 是此度量的收缩因子。为了找到仅基于残差的准则停止时刻的质量不平衡，我们将 $k = k_r$ 代入此方程：\n$$\n\\epsilon_{k_r} = \\epsilon_\\infty + (\\epsilon_0 - \\epsilon_\\infty)\\,\\beta^{k_r}\n$$\n\n### 3. 复合停止准则的分析\n\n复合准则要求同时满足残差和质量不平衡的阈值。设 $k_c$ 为同时满足 $||r_k||_2 / ||r_0||_2 \\le \\tau_r$ 和 $\\epsilon_k \\le \\tau_m$ 的最小迭代次数。\n\n#### 3.1. 质量不平衡准则的可达性\n\n质量不平衡 $\\epsilon_k$ 是一个单调递减序列，当 $k \\to \\infty$ 时收敛到 $\\epsilon_\\infty$（假设 $\\epsilon_0  \\epsilon_\\infty$）。需要满足的条件是 $\\epsilon_k \\le \\tau_m$。\n如果不平衡的渐近极限 $\\epsilon_\\infty$ 本身大于或等于阈值 $\\tau_m$，那么对于任何有限的 $k$，该准则永远无法被满足，前提是迭代从一个不满足的状态开始，即 $\\epsilon_0  \\tau_m$。这就确定了问题中陈述的不可达条件：如果 $\\epsilon_\\infty \\ge \\tau_m$ 且 $\\epsilon_0  \\tau_m$，则复合准则不可达。在这种情况下，我们设 $k_c = -1$。否则，该准则是可达的。\n\n#### 3.2. 质量不平衡停止迭代次数 ($k_m$) 的推导\n\n如果准则是可达的，我们必须找到满足 $\\epsilon_k \\le \\tau_m$ 的最小整数迭代次数 $k_m$。\n如果初始状态已经满足条件，即 $\\epsilon_0 \\le \\tau_m$，则最小迭代次数为 $k_m = 0$。\n\n如果 $\\epsilon_0  \\tau_m$，我们解不等式：\n$$\n\\epsilon_\\infty + (\\epsilon_0 - \\epsilon_\\infty)\\beta^k \\le \\tau_m\n$$\n$$\n(\\epsilon_0 - \\epsilon_\\infty)\\beta^k \\le \\tau_m - \\epsilon_\\infty\n$$\n假设 $\\epsilon_0  \\epsilon_\\infty$（收敛的标准情况），我们可以除以正量 $(\\epsilon_0 - \\epsilon_\\infty)$：\n$$\n\\beta^k \\le \\frac{\\tau_m - \\epsilon_\\infty}{\\epsilon_0 - \\epsilon_\\infty}\n$$\n因为准则是可达的且我们处于 $\\epsilon_0  \\tau_m$ 的情况，所以必然有 $\\epsilon_\\infty  \\tau_m$，因此右侧是一个小于1的正值。取自然对数：\n$$\nk \\log(\\beta) \\le \\log\\left(\\frac{\\tau_m - \\epsilon_\\infty}{\\epsilon_0 - \\epsilon_\\infty}\\right)\n$$\n除以负项 $\\log(\\beta)$ 会使不等号反向：\n$$\nk \\ge \\frac{\\log\\left( (\\tau_m - \\epsilon_\\infty) / (\\epsilon_0 - \\epsilon_\\infty) \\right)}{\\log(\\beta)}\n$$\n因此，最小整数迭代次数 $k_m$ 是：\n$$\nk_m = \\left\\lceil \\frac{\\log\\left( (\\tau_m - \\epsilon_\\infty) / (\\epsilon_0 - \\epsilon_\\infty) \\right)}{\\log(\\beta)} \\right\\rceil \\quad \\text{对于 } \\epsilon_0  \\tau_m \\text{ 且可达的情况}\n$$\n\n#### 3.3. 复合停止迭代次数 ($k_c$)\n\n如果复合准则是可达的，求解器必须继续进行直到两个条件都满足。这将在两个单独准则所需迭代次数的最大值处发生。\n$$\nk_c = \\max(k_r, k_m)\n$$\n\n这些推导出的公式在提供的程序中实现，用以计算每个测试用例所需的量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the convergence analysis problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: Canonical case where residual-only stop is insufficient.\n        {'alpha': 0.8, 'beta': 0.93, 'tau_r': 1e-6, 'tau_m': 0.005, 'e_inf': 0.0102, 'r0_norm': 1.0, 'e_0': 0.1},\n        # Test Case 2: Happy path, fast mass convergence.\n        {'alpha': 0.9, 'beta': 0.6, 'tau_r': 1e-6, 'tau_m': 1e-4, 'e_inf': 0.0, 'r0_norm': 1.0, 'e_0': 0.05},\n        # Test Case 3: Delayed mass convergence, composite stop is later.\n        {'alpha': 0.7, 'beta': 0.9, 'tau_r': 1e-6, 'tau_m': 0.001, 'e_inf': 0.0004, 'r0_norm': 1.0, 'e_0': 0.1},\n        # Test Case 4: Equality boundary case.\n        {'alpha': 10**-0.6, 'beta': 10**-0.3, 'tau_r': 1e-6, 'tau_m': 1e-3, 'e_inf': 0.0, 'r0_norm': 1.0, 'e_0': 1.0}\n    ]\n\n    results = []\n    for params in test_cases:\n        result = analyze_convergence(params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list includes spaces after commas,\n    # which matches the problem's example format: [k_r, e_kr, k_c, reachable].\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef analyze_convergence(params):\n    \"\"\"\n    Computes convergence metrics for a single parameter set.\n\n    Args:\n        params (dict): A dictionary of parameters: \n                       alpha, beta, tau_r, tau_m, e_inf, r0_norm, e_0\n\n    Returns:\n        list: A list containing [k_r, e_kr, k_c, reachable].\n    \"\"\"\n    alpha = params['alpha']\n    beta = params['beta']\n    tau_r = params['tau_r']\n    tau_m = params['tau_m']\n    e_inf = params['e_inf']\n    e_0 = params['e_0']\n\n    # 1. Compute the minimal residual-only stopping iteration, k_r.\n    # The condition is alpha^k = tau_r.\n    if tau_r >= 1.0:\n        k_r = 0\n    else:\n        # k >= log(tau_r) / log(alpha). Since alpha  1, log(alpha) is negative.\n        # np.log is the natural logarithm.\n        k_r = int(np.ceil(np.log(tau_r) / np.log(alpha)))\n\n    # 2. Compute the mass imbalance at the residual-only stop, e_kr.\n    e_kr = e_inf + (e_0 - e_inf) * (beta ** k_r)\n\n    # 3.  4. Determine reachability and compute the composite stopping iteration, k_c.\n    \n    # The composite criterion is unreachable if the asymptotic mass imbalance is\n    # not better than the threshold AND the starting imbalance is worse.\n    is_reachable = not (e_inf >= tau_m and e_0 > tau_m)\n\n    if not is_reachable:\n        k_c = -1\n    else:\n        # Mass criterion is reachable. Find the minimal iteration k_m for it.\n        # The condition is e_k = tau_m.\n        if e_0 = tau_m:\n            k_m = 0\n        else:\n            # e_inf + (e_0 - e_inf) * beta^k = tau_m\n            # beta^k = (tau_m - e_inf) / (e_0 - e_inf)\n            # k >= log( (tau_m - e_inf) / (e_0 - e_inf) ) / log(beta)\n            # Since beta  1, log(beta) is negative, inequality flips.\n            # And since reachable with e_0 > tau_m, we have e_inf  tau_m.\n            ratio = (tau_m - e_inf) / (e_0 - e_inf)\n            k_m = int(np.ceil(np.log(ratio) / np.log(beta)))\n\n        # The composite rule stops when both criteria are met.\n        k_c = max(k_r, k_m)\n    \n    return [k_r, e_kr, k_c, is_reachable]\n\n# Execute the main function.\nsolve()\n```"
        },
        {
            "introduction": "在实际的CFD计算中，为了高效地捕捉边界层等流动细节，我们常常使用在特定方向上被高度拉伸的各向异性网格。在这种情况下，我们如何“衡量”残差场的大小？传统的$L_1$、$L_2$或$L_\\infty$范数可能会因为网格的几何畸变而给出误导性的结论。本实践将引导您探索这一高级主题，通过对比标准范数与一种考虑了网格几何特征的“度量张量范数”，您将发现为何在各向异性网格上，一个更精巧的、与几何相关的判据对于避免“假收敛”至关重要。",
            "id": "3305185",
            "problem": "考虑一个应用于计算流体动力学 (CFD) 中纳维-斯托克斯 (NS) 方程组的稳态、无量纲化动量方程的迭代求解器。在每次迭代中，一个由 $N$ 个控制体（单元）组成的网格上会产生一个离散残差场。对于单元 $i$，其残差向量为 $r_i \\in \\mathbb{R}^2$，正标量测度（例如，面积）为 $w_i \\in \\mathbb{R}_{+}$，局部网格度量张量为一个对称正定矩阵 $M_i \\in \\mathbb{S}_{++}^{2}$，该矩阵编码了各向异性（网格方向的相对拉伸和朝向）。每个 $r_i$ 都是无量纲化的（无物理单位），每个 $M_i$ 代表一个由网格几何形状引出的无量纲度量。\n\n停止迭代需要选择离散残差场的全局范数。标准选择包括基于 $r_i$ 的欧几里得模长和跨单元加权聚合的 $L_1$、$L_2$ 和 $L_\\infty$ 范数。然而，在各向异性边界层网格上，如果较大的残差分量与占据小测度（即 $w_i$ 很小）的强约束方向对齐，这些范数可能会导致假收敛。为缓解此问题，应设计一种基于局部网格度量张量的范数。\n\n任务：\n1. 使用有限维空间中向量的 $L_1$、$L_2$ 和 $L_\\infty$ 范数的标准定义，为离散场 $\\{r_i\\}_{i=1}^N$ 实现以下内容：\n   - 使用 $\\{w_i\\}$，计算各单元欧几里得模长 $\\|r_i\\|_2$ 的加权 $L_1$ 聚合。\n   - 使用 $\\{w_i\\}$，计算各单元欧几里得模长 $\\|r_i\\|_2$ 的加权 $L_2$ 聚合。\n   - 计算 $L_\\infty$ 聚合，即所有单元中欧几里得模长 $\\|r_i\\|_2$ 的最大值。\n2. 从有限维赋范向量空间上的内积的第一性原理出发，设计一个度量感知的局部范数 $\\|r_i\\|_{M_i}$，它依赖于 $M_i$ 并满足以下所有条件：\n   - 对于单位度量 $M_i = I$，它退化为欧几里得范数 $\\|r_i\\|_2$。\n   - 它由一个对称正定双线性形式导出，并在标准正交基变换下保持不变。\n   - 当残差与 $M_i$ 编码为强约束的方向（例如，边界层网格中快速变化的法线方向）对齐时，该范数会增大。\n   使用 $\\{w_i\\}$ 和 $\\{\\|r_i\\|_{M_i}\\}$，将全局度量感知聚合实现为基于单元的加权 $L_2$ 范数。\n3. 对于下方的每个测试用例，分别计算四个布尔值，指示在与给定容差 $(\\varepsilon_{1}, \\varepsilon_{2}, \\varepsilon_{\\infty}, \\varepsilon_{M})$ 比较时，迭代是否会在四种范数中的每一种下停止。仅使用无量纲量。不涉及角度或百分比。如果对应的全局范数小于或等于其容差，则相应的布尔值为真 (true)，否则为假 (false)。\n4. 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个四元素列表，顺序为 $[L_1\\text{ stop}, L_2\\text{ stop}, L_\\infty\\text{ stop}, M\\text{-norm stop}]$。例如：$[[\\text{True},\\text{False},\\text{True},\\text{False}],\\dots]$。\n\n测试套件：\n- 案例 1（各向同性网格，小残差）：\n  - $N = 4$。\n  - 残差：$r_1 = (10^{-6}, -2 \\cdot 10^{-6})$，$r_2 = (5 \\cdot 10^{-7}, 5 \\cdot 10^{-7})$，$r_3 = (10^{-6}, 10^{-6})$，$r_4 = (0, 3 \\cdot 10^{-6})$。\n  - 权重：$w_1 = 1$，$w_2 = 1$，$w_3 = 1$，$w_4 = 1$。\n  - 度量：$M_1 = I$，$M_2 = I$，$M_3 = I$，$M_4 = I$。\n  - 容差：$\\varepsilon_{1} = 10^{-5}$，$\\varepsilon_{2} = 10^{-5}$，$\\varepsilon_{\\infty} = 5 \\cdot 10^{-6}$，$\\varepsilon_{M} = 10^{-5}$。\n- 案例 2（各向异性边界层网格；大的法向残差集中在小测度单元中）：\n  - $N = 6$。\n  - 残差：$r_1 = (10^{-6}, 2 \\cdot 10^{-4})$，$r_2 = (-10^{-6}, 2.2 \\cdot 10^{-4})$，$r_3 = (10^{-6}, 10^{-6})$，$r_4 = (2 \\cdot 10^{-6}, -10^{-6})$，$r_5 = (5 \\cdot 10^{-7}, 5 \\cdot 10^{-7})$，$r_6 = (10^{-6}, -5 \\cdot 10^{-7})$。\n  - 权重：$w_1 = 10^{-3}$，$w_2 = 10^{-3}$，$w_3 = 1$，$w_4 = 1$，$w_5 = 1$，$w_6 = 1$。\n  - 度量：$M_1 = \\mathrm{diag}(1, 100)$，$M_2 = \\mathrm{diag}(1, 100)$，$M_3 = I$，$M_4 = I$，$M_5 = I$，$M_6 = I$。\n  - 容差：$\\varepsilon_{1} = 10^{-5}$，$\\varepsilon_{2} = 10^{-5}$，$\\varepsilon_{\\infty} = 10^{-5}$，$\\varepsilon_{M} = 5 \\cdot 10^{-5}$。\n- 案例 3（极端各向异性；单个微小测度单元中存在非常大的法向残差）：\n  - $N = 3$。\n  - 残差：$r_1 = (10^{-6}, 10^{-3})$，$r_2 = (10^{-6}, 10^{-6})$，$r_3 = (10^{-6}, 10^{-6})$。\n  - 权重：$w_1 = 10^{-6}$，$w_2 = 1$，$w_3 = 1$。\n  - 度量：$M_1 = \\mathrm{diag}(1, 100)$，$M_2 = I$，$M_3 = I$。\n  - 容差：$\\varepsilon_{1} = 10^{-5}$，$\\varepsilon_{2} = 10^{-5}$，$\\varepsilon_{\\infty} = 10^{-4}$，$\\varepsilon_{M} = 5 \\cdot 10^{-6}$。\n- 案例 4（所有残差恒为零）：\n  - $N = 3$。\n  - 残差：$r_1 = (0, 0)$，$r_2 = (0, 0)$，$r_3 = (0, 0)$。\n  - 权重：$w_1 = 1$，$w_2 = 1$，$w_3 = 1$。\n  - 度量：$M_1 = I$，$M_2 = I$，$M_3 = I$。\n  - 容差：$\\varepsilon_{1} = 10^{-12}$，$\\varepsilon_{2} = 10^{-12}$，$\\varepsilon_{\\infty} = 10^{-12}$，$\\varepsilon_{M} = 10^{-12}$。",
            "solution": "该问题要求对一个离散残差场进行公式化和计算四种不同的范数，该残差场源自纳维-斯托克斯方程的数值解，用作迭代求解器的收敛准则。分析必须针对几个测试用例进行，每个用例代表不同的物理或数值情景。\n\n离散残差场由一组向量 $\\{r_i\\}_{i=1}^N$ 给出，其中 $ r_i \\in \\mathbb{R}^2 $ 是单元 $i$ 中的残差。每个单元还关联一个正标量测度（权重）$w_i \\in \\mathbb{R}_{+}$ 和一个局部网格度量张量 $M_i \\in \\mathbb{S}_{++}^{2}$，它是一个 $2 \\times 2$ 的对称正定矩阵。\n\n首先，我将按规定定义四种全局范数。前三种基于局部残差向量的欧几里得范数，即 $\\|r_i\\|_2 = \\sqrt{r_{i,1}^2 + r_{i,2}^2}$。\n\n1.  **加权 $L_1$ 聚合 ($N_1$)**：此范数定义为局部残差的欧几里得模长之和，按单元测度加权。它表示在离散化域上积分的总残差。\n    $$N_1 = \\sum_{i=1}^N w_i \\|r_i\\|_2$$\n    基于此范数的停止准则为 $N_1 \\le \\varepsilon_1$。\n\n2.  **加权 $L_2$ 聚合 ($N_2$)**：此范数是加权平方欧几里得模长之和的平方根。它是一种均方根 (RMS) 类型的范数，相比 $L_1$ 范数更强调较大的残差。\n    $$N_2 = \\sqrt{\\sum_{i=1}^N w_i \\|r_i\\|_2^2}$$\n    基于此范数的停止准则为 $N_2 \\le \\varepsilon_2$。\n\n3.  **$L_\\infty$ 聚合 ($N_\\infty$)**：此范数是所有单元中局部欧几里得模长的最大值。它对局部的大残差最敏感，因为它不会被其他单元平均或加权降低。\n    $$N_\\infty = \\max_{i=1, \\dots, N} \\|r_i\\|_2$$\n    基于此范数的停止准则为 $N_\\infty \\le \\varepsilon_\\infty$。\n\n4.  **度量感知聚合 ($N_M$)**：此范数旨在考虑网格各向异性，该特性编码在度量张量 $M_i$ 中。我们的任务是从第一性原理出发设计一个局部范数 $\\|r_i\\|_{M_i}$。\n    向量空间上的范数是由内积导出的。对于向量空间 $\\mathbb{R}^k$，一个通用的内积可以由一个对称正定矩阵 $M \\in \\mathbb{S}_{++}^{k}$ 定义为 $\\langle u, v \\rangle_M = u^T M v$。由于问题中的每个 $M_i$ 都被给定为对称正定矩阵，因此它可以在 $\\mathbb{R}^2$ 上定义一个唯一的内积。\n    由此内积导出的范数是：\n    $$\\|r_i\\|_{M_i} = \\sqrt{\\langle r_i, r_i \\rangle_{M_i}} = \\sqrt{r_i^T M_i r_i}$$\n    让我们验证这个定义是否满足所要求的四个属性：\n    - 如果 $M_i = I$（单位矩阵），则 $\\|r_i\\|_I = \\sqrt{r_i^T I r_i} = \\sqrt{r_i^T r_i} = \\|r_i\\|_2$。该属性得到满足。\n    - 该范数由双线性形式 $\\langle u, v \\rangle_{M_i} = u^T M_i v$ 导出，根据 $M_i$ 的定义，该形式是对称正定的。该属性得到满足。\n    - 标准正交基变换由一个标准正交矩阵 $Q$ ($Q^T Q = I$) 表示。内积的无坐标定义在此类变换下是不变的。该属性得到满足。\n    - 设 $M_i$ 的特征值为 $\\lambda_1 \\le \\lambda_2$，对应的标准正交特征向量为 $v_1, v_2$。“强约束”方向是 $v_2$。对于与此方向对齐的残差 $r_i$，有 $r_i = c v_2$（其中 $c$ 为某个标量）。范数的平方为 $\\|r_i\\|_{M_i}^2 = (c v_2)^T M_i (c v_2) = c^2 v_2^T (\\lambda_2 v_2) = c^2 \\lambda_2 \\|v_2\\|_2^2 = c^2 \\lambda_2$。如果 $r_i$ 与 $v_1$ 对齐，则范数的平方为 $c^2 \\lambda_1$。由于 $\\lambda_2 > \\lambda_1$，对于与强约束方向对齐的残差，范数确实更大。该属性得到满足。\n\n    全局度量感知聚合范数 $N_M$ 定义为局部度量感知范数的加权 $L_2$ 范数：\n    $$N_M = \\sqrt{\\sum_{i=1}^N w_i \\|r_i\\|_{M_i}^2} = \\sqrt{\\sum_{i=1}^N w_i (r_i^T M_i r_i)}$$\n    基于此范数的停止准则为 $N_M \\le \\varepsilon_M$。\n\n现在，我们将这四个定义应用于每个测试用例。对于每种范数，我们计算其值并与给定的容差进行比较，以确定布尔停止决策。\n\n作为一个说明性示例，让我们详细说明案例2的计算过程。\n- 已知条件：$N=6$，$r_1=(10^{-6}, 2 \\cdot 10^{-4})$，$r_2=(-10^{-6}, 2.2 \\cdot 10^{-4})$，其他残差很小。$w_1=w_2=10^{-3}$，其他为 $1$。$M_1=M_2=\\mathrm{diag}(1, 100)$，其他为 $I$。\n- 局部欧几里得范数 $\\|r_i\\|_2$：$\\|r_1\\|_2 \\approx 2.00 \\times 10^{-4}$，$\\|r_2\\|_2 \\approx 2.20 \\times 10^{-4}$，所有其他 $\\|r_i\\|_2$ 约为 $10^{-6}$ 量级。\n- $N_1 = \\sum w_i \\|r_i\\|_2 = (10^{-3})(2.00 \\times 10^{-4}) + (10^{-3})(2.20 \\times 10^{-4}) + \\dots \\approx 5.90 \\times 10^{-6}$。\n  由于 $5.90 \\times 10^{-6} \\le \\varepsilon_1 = 10^{-5}$，因此 $L_1$ 停止条件为 True。\n- $N_2 = \\sqrt{\\sum w_i \\|r_i\\|_2^2} = \\sqrt{(10^{-3})(2.00 \\times 10^{-4})^2 + (10^{-3})(2.20 \\times 10^{-4})^2 + \\dots} \\approx 9.86 \\times 10^{-6}$。\n  由于 $9.86 \\times 10^{-6} \\le \\varepsilon_2 = 10^{-5}$，因此 $L_2$ 停止条件为 True。由于具有大残差的单元上的权重 $w_1, w_2$ 很小，$N_1$ 和 $N_2$ 都很小，这预示着假收敛。\n- $N_\\infty = \\max_i \\|r_i\\|_2 = \\|r_2\\|_2 \\approx 2.20 \\times 10^{-4}$。\n  由于 $2.20 \\times 10^{-4}  \\varepsilon_\\infty = 10^{-5}$，因此 $L_\\infty$ 停止条件为 False，正确地识别出大的局部残差。\n- $N_M = \\sqrt{\\sum w_i (r_i^T M_i r_i)}$。对于单元 1，$r_1^T M_1 r_1 = (10^{-6})^2 + 100(2 \\cdot 10^{-4})^2 \\approx 4.00 \\times 10^{-6}$。度量惩罚了大的垂直分量。\n  $N_M = \\sqrt{ w_1(r_1^T M_1 r_1) + w_2(r_2^T M_2 r_2) + \\dots } = \\sqrt{ (10^{-3})(4.00 \\times 10^{-6}) + (10^{-3})(4.84 \\times 10^{-6}) + \\dots } \\approx 9.41 \\times 10^{-5}$。\n  由于 $9.41 \\times 10^{-5}  \\varepsilon_M = 5 \\times 10^{-5}$，因此度量感知停止条件为 False。此范数也通过惩罚与网格精细分辨率方向对齐的残差分量，正确地识别了未收敛状态，尽管该单元的测度很小。\n\n对所有测试用例执行类似计算，并按要求汇编结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes four different residual norms for several test cases and determines\n    convergence based on specified tolerances.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: Isotropic mesh, small residuals\n        {\n            \"N\": 4,\n            \"residuals\": [np.array([1e-6, -2e-6]), np.array([5e-7, 5e-7]), \n                          np.array([1e-6, 1e-6]), np.array([0, 3e-6])],\n            \"weights\": [1.0, 1.0, 1.0, 1.0],\n            \"metrics\": [np.identity(2), np.identity(2), np.identity(2), np.identity(2)],\n            \"tolerances\": {\"e1\": 1e-5, \"e2\": 1e-5, \"e_inf\": 5e-6, \"eM\": 1e-5}\n        },\n        # Case 2: Anisotropic boundary layer mesh\n        {\n            \"N\": 6,\n            \"residuals\": [np.array([1e-6, 2e-4]), np.array([-1e-6, 2.2e-4]),\n                          np.array([1e-6, 1e-6]), np.array([2e-6, -1e-6]),\n                          np.array([5e-7, 5e-7]), np.array([1e-6, -5e-7])],\n            \"weights\": [1e-3, 1e-3, 1.0, 1.0, 1.0, 1.0],\n            \"metrics\": [np.diag([1, 100]), np.diag([1, 100]), \n                        np.identity(2), np.identity(2), np.identity(2), np.identity(2)],\n            \"tolerances\": {\"e1\": 1e-5, \"e2\": 1e-5, \"e_inf\": 1e-5, \"eM\": 5e-5}\n        },\n        # Case 3: Extreme anisotropy, single large residual in tiny cell\n        {\n            \"N\": 3,\n            \"residuals\": [np.array([1e-6, 1e-3]), np.array([1e-6, 1e-6]), np.array([1e-6, 1e-6])],\n            \"weights\": [1e-6, 1.0, 1.0],\n            \"metrics\": [np.diag([1, 100]), np.identity(2), np.identity(2)],\n            \"tolerances\": {\"e1\": 1e-5, \"e2\": 1e-5, \"e_inf\": 1e-4, \"eM\": 5e-6}\n        },\n        # Case 4: All residuals identically zero\n        {\n            \"N\": 3,\n            \"residuals\": [np.array([0.0, 0.0]), np.array([0.0, 0.0]), np.array([0.0, 0.0])],\n            \"weights\": [1.0, 1.0, 1.0],\n            \"metrics\": [np.identity(2), np.identity(2), np.identity(2)],\n            \"tolerances\": {\"e1\": 1e-12, \"e2\": 1e-12, \"e_inf\": 1e-12, \"eM\": 1e-12}\n        }\n    ]\n\n    final_results = []\n    for case in test_cases:\n        residuals = case[\"residuals\"]\n        weights = np.array(case[\"weights\"])\n        metrics = case[\"metrics\"]\n        tolerances = case[\"tolerances\"]\n        \n        # Calculate local norms\n        r_norms_L2 = np.array([np.linalg.norm(r) for r in residuals])\n        \n        # 1. Weighted L1 norm\n        norm_L1 = np.sum(weights * r_norms_L2)\n        \n        # 2. Weighted L2 norm\n        norm_L2 = np.sqrt(np.sum(weights * r_norms_L2**2))\n        \n        # 3. L_infinity norm\n        norm_Linf = np.max(r_norms_L2) if r_norms_L2.size > 0 else 0.0\n        \n        # 4. Metric-aware norm\n        local_metric_norms_sq = np.array([r.T @ M @ r for r, M in zip(residuals, metrics)])\n        norm_M = np.sqrt(np.sum(weights * local_metric_norms_sq))\n        \n        # Determine stop conditions\n        stop_L1 = norm_L1 = tolerances[\"e1\"]\n        stop_L2 = norm_L2 = tolerances[\"e2\"]\n        stop_Linf = norm_Linf = tolerances[\"e_inf\"]\n        stop_M = norm_M = tolerances[\"eM\"]\n        \n        final_results.append([stop_L1, stop_L2, stop_Linf, stop_M])\n\n    # The conversion of a list to string produces the required format, \n    # e.g., str([True, False]) -> \"[True, False]\".\n    # Joining these string-converted lists with commas and enclosing in brackets\n    # gives the final required output format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}