{
    "hands_on_practices": [
        {
            "introduction": "仅仅计算残差向量本身并不足以判断收敛。我们需要将其缩放，以获得一个有意义的、可供比较的标量值。本练习旨在探讨三种常见的残差归一化策略，并揭示不同策略如何影响我们对收敛的判断，尤其是在网格尺寸或物理参数（如雷诺数）等问题参数发生变化时。通过这个实践，你将学会批判性地选择最适合特定问题的归一化方法。",
            "id": "3305239",
            "problem": "您的任务是研究不同的残差归一化选择如何影响迭代线性求解器的感知收敛性，该求解器源于可压缩纳维-斯托克斯方程的牛顿线性化。研究将在一个一维、无量纲的设定下进行，该设定能捕捉对流和扩散输运以及可压缩性稳定化的标度律。其基础是以下广泛使用的过程：通过牛顿法求解非线性残差方程 $F(U) = 0$，在非线性迭代索引为 $m$ 时，产生一个线性系统 $J(U^{(m)}) \\,\\Delta U^{(m)} = -F(U^{(m)})$，其中 $J$ 是 $F$ 的雅可比矩阵。对于一个固定的非线性迭代步 $U^{(m)}$，内部的线性迭代求解器维持一个当前迭代解 $x^{(k)}$ 以求解 $J x = b$（其中 $b = -F(U^{(m)})$），并定义线性残差为 $r^{(k)} = b - J x^{(k)}$。内部求解器的收敛通常通过检查归一化残差是否低于某个容差来判断。\n\n以此为基础，构建一个合成的一维线性化算子，并研究三种残差归一化策略：按初始残差范数缩放、按右端项范数缩放，以及按雅可比矩阵的对角线缩放。使用来自带可压缩性稳定化的一维对流-扩散问题的基本标度律，将 $J \\in \\mathbb{R}^{n \\times n}$ 定义为一个三对角矩阵：\n- 对角线元素为 $J_{ii} = \\alpha + \\dfrac{2 \\nu}{h^2}$。\n- 次对角线元素为 $J_{i,i-1} = -\\dfrac{\\nu}{h^2} - \\dfrac{U}{2 h}$，对于 $i \\geq 2$。\n- 超对角线元素为 $J_{i,i+1} = -\\dfrac{\\nu}{h^2} + \\dfrac{U}{2 h}$，对于 $i \\leq n-1$。\n此处，$h = \\dfrac{1}{n}$ 是单位区间上的网格间距，$U$ 是一个恒定的平流速度，$\\nu = \\dfrac{1}{Re}$ 是无量纲形式的运动粘度，其中 $Re$ 是雷诺数。参数 $\\alpha > 0$ 代表可压缩性或伪时间稳定化，并且可以取足够大的值以确保在整个测试套件中矩阵的对角占优性。\n\n将右端项定义为 $b_i = \\sin(\\pi x_i)$，其中 $x_i = i h$，对于 $i = 1, \\dots, n$。使用初始猜测 $x^{(0)}_i = x_i$，对于 $i = 1, \\dots, n$，因此有 $r^{(0)} = b - J x^{(0)} \\neq b$。\n\n使用加权雅可比（WJ）迭代来推进线性求解过程：\n$$\nx^{(k+1)} = x^{(k)} + \\omega D^{-1} \\left(b - J x^{(k)}\\right),\n$$\n其中 $D = \\mathrm{diag}(J)$ 且 $\\omega \\in (0, 2)$ 是一个松弛因子。选择固定的内部迭代次数 $K$ 和固定的松弛因子 $\\omega$，并假设 $D$ 的所有元素均为正。\n\n对于每个测试用例，在进行 $K$ 次迭代后，计算残差 $r^{(K)}$ 并评估以下三种归一化残差的定义：\n1. 按初始残差范数缩放：$R_{r_0} = \\dfrac{\\lVert r^{(K)} \\rVert_2}{\\lVert r^{(0)} \\rVert_2}$。\n2. 按右端项范数缩放：$R_{b} = \\dfrac{\\lVert r^{(K)} \\rVert_2}{\\lVert b \\rVert_2}$。\n3. 按雅可比矩阵对角线缩放（逐行均衡）：$R_{D} = \\dfrac{\\lVert D^{-1} r^{(K)} \\rVert_2}{\\lVert D^{-1} r^{(0)} \\rVert_2}$。\n\n此外，为每种归一化定义一个布尔类型的收敛标志，方法是与一个固定的容差 $\\tau$ 进行比较：对于归一化 $R_{\\star}$，如果 $R_{\\star} \\le \\tau$，则设 $C_{\\star} = \\mathrm{True}$，否则设为 $\\mathrm{False}$。\n\n您的程序必须使用以下固定参数来实现上述过程：\n- 使用 $U = 1$。\n- 使用 $\\alpha = 500$。\n- 使用 $\\omega = 1$。\n- 使用 $K = 30$。\n- 使用 $\\tau = 10^{-6}$。\n所有量均为无量纲，且不使用角度。\n\n构建并运行以下测试套件，其设计旨在探究网格细化和雷诺数变化的影响：\n- 用例 1：$n = 50$，$Re = 50$。\n- 用例 2：$n = 200$，$Re = 50$。\n- 用例 3：$n = 50$，$Re = 1000$。\n- 用例 4：$n = 200$，$Re = 1000$。\n- 用例 5：$n = 50$，$Re = 5$。\n\n对于每个用例，您的程序必须返回一个列表，其顺序为 $[R_{r_0}, R_b, R_D, C_{r_0}, C_b, C_D]$，包含三个浮点数和三个布尔值。将所有用例的结果汇总到一个列表中，因此最终输出为单行文本，包含一个由方括号括起来的、逗号分隔的五个用例结果的列表。例如，打印的行必须类似于 $[\\,[\\dots],\\,[\\dots],\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$，其中每个内部列表都按指定顺序排列。不得打印任何额外文本。",
            "solution": "该问题要求对用于评估迭代线性求解器收敛性的三种不同残差归一化策略进行批判性检验。其背景是一个合成的一维问题，该问题代表了计算流体动力学（CFD）中遇到的典型问题，特别是源于可压缩纳维-斯托克斯方程的牛顿线性化。分析将通过实现指定的数值方案并将其应用于一系列测试用例来执行。\n\n首先，我们对问题设定进行形式化。核心任务是迭代求解以下线性方程组：\n$$\nJ x = b\n$$\n此处，$J \\in \\mathbb{R}^{n \\times n}$ 是一个稀疏的三对角矩阵，代表带稳定项的离散化一维对流-扩散算子。其元素是基于单位区间上间距为 $h = \\dfrac{1}{n}$ 的均匀网格定义的。参数包括一个恒定的平流速度 $U$、运动粘度 $\\nu = \\dfrac{1}{Re}$（其中 $Re$ 是雷诺数）和一个稳定化参数 $\\alpha$。矩阵元素如下：\n- 对角线：$J_{ii} = \\alpha + \\dfrac{2 \\nu}{h^2}$\n- 次对角线：$J_{i,i-1} = -\\dfrac{\\nu}{h^2} - \\dfrac{U}{2 h}$ 对于 $i = 2, \\dots, n$\n- 超对角线：$J_{i,i+1} = -\\dfrac{\\nu}{h^2} + \\dfrac{U}{2 h}$ 对于 $i = 1, \\dots, n-1$\n\n右端项（RHS）向量 $b \\in \\mathbb{R}^n$ 是通过在网格点 $x_i = i h$（$i = 1, \\dots, n$）上评估一个光滑函数来定义的：\n$$\nb_i = \\sin(\\pi x_i)\n$$\n迭代求解过程始于一个初始猜测 $x^{(0)} \\in \\mathbb{R}^n$，它被指定为网格坐标向量：\n$$\nx^{(0)}_i = x_i\n$$\n\n所选的迭代求解器是加权雅可比（WJ）方法。解从迭代步 $k$ 推进到 $k+1$ 使用以下公式：\n$$\nx^{(k+1)} = x^{(k)} + \\omega D^{-1} \\left(b - J x^{(k)}\\right)\n$$\n其中 $D = \\mathrm{diag}(J)$ 是 $J$ 的对角部分，$\\omega$ 是一个松弛因子，括号中的项是在第 $k$ 次迭代时的线性残差，定义为 $r^{(k)} = b - J x^{(k)}$。对于此问题，参数是固定的：$\\omega = 1$（这将方法简化为标准的雅可比迭代），迭代次数固定为 $K = 30$。问题假设 $D$ 的元素严格为正，此条件在此处得到满足，因为 $J_{ii} = \\alpha + \\frac{2\\nu}{h^2}$ 且 $\\alpha > 0$ 和 $\\nu > 0$。\n\n在执行 $K=30$ 次迭代后，我们得到最终状态 $x^{(K)}$ 和最终残差 $r^{(K)} = b - J x^{(K)}$。核心任务是评估三种不同的归一化残差：\n1.  **按初始残差范数缩放**：此度量，$R_{r_0}$，衡量残差量值相对于其初始值的减小程度。初始残差为 $r^{(0)} = b - J x^{(0)}$。\n    $$\n    R_{r_0} = \\dfrac{\\lVert r^{(K)} \\rVert_2}{\\lVert r^{(0)} \\rVert_2}\n    $$\n2.  **按右端项范数缩放**：此度量，$R_{b}$，衡量最终残差量值相对于强迫项 $b$ 的大小。\n    $$\n    R_{b} = \\dfrac{\\lVert r^{(K)} \\rVert_2}{\\lVert b \\rVert_2}\n    $$\n3.  **按雅可比矩阵对角线缩放（逐行均衡）**：此度量，$R_{D}$，衡量预处理残差范数的减小程度，其中预处理器是雅可比矩阵的对角线。这通常提供一种尺度不变的收敛度量。\n    $$\n    R_{D} = \\dfrac{\\lVert D^{-1} r^{(K)} \\rVert_2}{\\lVert D^{-1} r^{(0)} \\rVert_2}\n    $$\n\n对于每种归一化残差 $R_{\\star}$，通过与固定容差 $\\tau = 10^{-6}$ 进行比较来确定一个布尔类型的收敛标志 $C_{\\star}$。如果 $R_{\\star} \\le \\tau$，则该标志设置为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n每个测试用例 $(n, Re)$ 的计算流程如下：\n1.  设置固定参数：$U = 1$、$\\alpha = 500$、$\\omega = 1$、$K = 30$、$\\tau = 10^{-6}$。\n2.  计算派生参数：$h = 1/n$ 和 $\\nu = 1/Re$。\n3.  构建 $n \\times n$ 的三对角矩阵 $J$。\n4.  构建网格向量 $x_{grid}$，其元素为 $x_i = i h$。\n5.  构建右端项向量 $b$，其元素为 $b_i = \\sin(\\pi x_i)$。\n6.  设置初始解向量 $x^{(0)} = x_{grid}$。\n7.  计算初始残差 $r^{(0)} = b - Jx^{(0)}$。\n8.  从 $J$ 中提取对角矩阵 $D$。\n9.  计算并存储分母范数：$\\lVert r^{(0)} \\rVert_2$、$\\lVert b \\rVert_2$ 和 $\\lVert D^{-1} r^{(0)} \\rVert_2$。\n10. 对 $k$ 从 $0$ 到 $K-1=29$ 执行雅可比迭代循环：\n    $x^{(k+1)} = x^{(k)} + \\omega D^{-1} (b - J x^{(k)})$。\n11. 完成后，计算最终残差 $r^{(K)} = b - J x^{(K)}$。\n12. 计算分子范数：$\\lVert r^{(K)} \\rVert_2$ 和 $\\lVert D^{-1} r^{(K)} \\rVert_2$。\n13. 计算三个比率 $R_{r_0}$、$R_{b}$ 和 $R_{D}$。\n14. 确定三个布尔标志 $C_{r_0}$、$C_{b}$ 和 $C_{D}$。\n15. 将结果整理成 $[R_{r_0}, R_b, R_D, C_{r_0}, C_b, C_D]$ 形式的列表。\n\n此流程被系统地应用于所有指定的测试用例，并且最终结果被汇总到一个单一列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(n, Re, U, alpha, omega, K, tau):\n    \"\"\"\n    Solves the 1D convection-diffusion problem for one test case.\n\n    Args:\n        n (int): Number of grid points.\n        Re (float): Reynolds number.\n        U (float): Advection speed.\n        alpha (float): Stabilization parameter.\n        omega (float): Weighted Jacobi relaxation parameter.\n        K (int): Number of iterations.\n        tau (float): Convergence tolerance.\n\n    Returns:\n        list: A list containing [R_r0, R_b, R_D, C_r0, C_b, C_D].\n    \"\"\"\n    # 1. Calculate derived parameters\n    h = 1.0 / n\n    nu = 1.0 / Re\n\n    # 2. Construct the tridiagonal Jacobian matrix J\n    J = np.zeros((n, n))\n    \n    # Diagonal term\n    diag_val = alpha + (2 * nu / h**2)\n    # Sub-diagonal term\n    sub_diag_val = -nu / h**2 - U / (2 * h)\n    # Super-diagonal term\n    sup_diag_val = -nu / h**2 + U / (2 * h)\n\n    # Fill the matrix J using np.diag\n    J += np.diag(np.full(n, diag_val))\n    J += np.diag(np.full(n - 1, sub_diag_val), k=-1)\n    J += np.diag(np.full(n - 1, sup_diag_val), k=1)\n    \n    # 3. Construct grid, RHS vector b, and initial guess x_k\n    # Grid points x_i = i*h for i=1,...,n, corresponding to array indices 0,...,n-1\n    x_grid = h * (np.arange(n) + 1)\n    \n    b = np.sin(np.pi * x_grid)\n    x_k = x_grid.copy() # Initial guess x^(0)\n\n    # 4. Extract diagonal D and compute its inverse\n    D = np.diag(J)\n    D_inv = 1.0 / D\n\n    # 5. Calculate initial residual r^(0) and required norms\n    r0 = b - J @ x_k\n    norm_r0 = np.linalg.norm(r0, 2)\n    norm_b = np.linalg.norm(b, 2)\n    \n    # Preconditioned initial residual and its norm\n    # D_inv is a 1D array, so we use element-wise multiplication\n    D_inv_r0 = D_inv * r0\n    norm_D_inv_r0 = np.linalg.norm(D_inv_r0, 2)\n    \n    # Edge case: If initial residual is zero, convergence is perfect.\n    if np.isclose(norm_r0, 0.0):\n        return [0.0, 0.0, 0.0, True, True, True]\n\n    # 6. Perform K iterations of the Weighted Jacobi method\n    for _ in range(K):\n        r_k = b - J @ x_k\n        x_k += omega * D_inv * r_k\n        \n    # 7. Compute final residual r^(K) and its norms\n    r_K = b - J @ x_k\n    norm_rK = np.linalg.norm(r_K, 2)\n    \n    D_inv_r_K = D_inv * r_K\n    norm_D_inv_r_K = np.linalg.norm(D_inv_r_K, 2)\n\n    # 8. Calculate the three normalized residual metrics\n    R_r0 = norm_rK / norm_r0\n    R_b = norm_rK / norm_b if norm_b > 0 else np.inf\n    # Handle division by zero for R_D, although norm_D_inv_r0 is unlikely to be zero\n    # if norm_r0 wasn't.\n    R_D = norm_D_inv_r_K / norm_D_inv_r0 if norm_D_inv_r0 > 0 else np.inf\n\n    # 9. Determine the convergence flags\n    C_r0 = R_r0 = tau\n    C_b = R_b = tau\n    C_D = R_D = tau\n\n    return [R_r0, R_b, R_D, C_r0, C_b, C_D]\n\ndef solve():\n    # Define the fixed parameters from the problem statement.\n    U = 1.0\n    alpha = 500.0\n    omega = 1.0\n    K = 30\n    tau = 1.0e-6\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (50, 50.0),    # Case 1\n        (200, 50.0),   # Case 2\n        (50, 1000.0),  # Case 3\n        (200, 1000.0), # Case 4\n        (50, 5.0),     # Case 5\n    ]\n\n    all_results = []\n    for n, Re in test_cases:\n        result = run_case(n, Re, U, alpha, omega, K, tau)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists matches the required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "一个经过良好归一化的残差是衡量数值收敛性的有力指标，但这并不总能保证模型底层的物理原理（如质量守恒）得到满足。本练习模拟了一个场景：即使线性系统的残差已经降得很低，系统仍然存在显著的物理不平衡。这个例子清晰地表明了使用组合准则的必要性，即同时监控数值收敛指标和关键物理量。",
            "id": "3305180",
            "problem": "考虑计算流体动力学 (CFD) 背景下的稳态不可压缩顶盖驱动方腔流，其中迭代求解器被应用于离散化的动量和连续性方程。全局质量守恒的物理要求通过不可压缩条件 $\\nabla \\cdot \\mathbf{u} = 0$ 表达，在数值上则通过确保稳态时离散散度处处为零来实现。设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个对称正定矩阵，它来自于压力泊松方程或速度修正步骤的一致性离散化，$x_k$ 是第 $k$ 次迭代的迭代解，$b$ 是右侧项。定义线性残差向量 $r_k = b - A x_k$ 及其欧几里得范数 $||r_k||_2$。在实践中，如果连续性方程的强制执行或压力-速度耦合以不同的速率收敛或收敛到一个有偏差的平台，仅基于减小 $||r_k||_2$ 的停止准则可能无法保证满足全局质量守恒。\n\n在迭代 $k = 0, 1, 2, \\dots$ 过程中，对两个指标的收敛进行建模：\n- 相对残差比 $||r_k||_2 / ||r_0||_2$，假设其以 $||r_k||_2 / ||r_0||_2 = \\alpha^k$ 的形式衰减，其中收缩因子为 $0  \\alpha  1$。\n- 归一化全局质量不平衡量 $\\epsilon_k$，定义为通过特征通量尺度归一化的、经过体积积分的离散散度，其模型为 $\\epsilon_k = \\epsilon_\\infty + (\\epsilon_0 - \\epsilon_\\infty)\\,\\beta^k$，其中 $0 \\le \\epsilon_\\infty \\le \\epsilon_0$ 且 $0  \\beta  1$。\n\n所有量均为无量纲。设残差阈值为 $\\tau_r  0$，质量不平衡阈值为 $\\tau_m  0$，两者均以小数形式指定（例如，$0.01$ 代表百分之一的水平）。仅基于残差的停止规则在满足 $||r_k||_2 / ||r_0||_2 \\le \\tau_r$ 的最小迭代次数 $k_r$ 处停止。复合停止规则要求同时满足 $||r_k||_2 / ||r_0||_2 \\le \\tau_r$ 和 $\\epsilon_k \\le \\tau_m$，并在满足两者的最小迭代次数 $k_c$ 处停止。如果 $\\epsilon_\\infty \\ge \\tau_m$ 且 $\\epsilon_0  \\tau_m$，则任何有限的迭代次数都无法满足质量不平衡目标，复合规则是不可达的。\n\n您的任务是实现一个程序，给定一个由参数集 $(\\alpha, \\beta, \\tau_r, \\tau_m, \\epsilon_\\infty, ||r_0||_2, \\epsilon_0)$ 组成的测试套件，为每个集合计算：\n1. 仅基于残差的最小停止迭代次数 $k_r$。\n2. 在仅基于残差的停止点处的质量不平衡量 $\\epsilon_{k_r}$。\n3. 复合停止迭代次数 $k_c$（如果不可达则为 $-1$）。\n4. 一个布尔值，指示复合准则是否可达。\n\n使用以下测试套件，其设计旨在覆盖一个典型案例、理想路径、延迟的质量收敛以及一个等式边界情况。在测试案例1中，选择的参数代表了一个稳态顶盖驱动方腔流场景，其中当 $||r||_2$ 的相对残差下降到 $10^{-6}$ 时停止，仍然产生量级为 $0.01$ 的质量不平衡：\n- 测试案例 1：$(\\alpha, \\beta, \\tau_r, \\tau_m, \\epsilon_\\infty, ||r_0||_2, \\epsilon_0) = (0.8, 0.93, 10^{-6}, 0.005, 0.0102, 1.0, 0.1)$。\n- 测试案例 2：$(\\alpha, \\beta, \\tau_r, \\tau_m, \\epsilon_\\infty, ||r_0||_2, \\epsilon_0) = (0.9, 0.6, 10^{-6}, 10^{-4}, 0.0, 1.0, 0.05)$。\n- 测试案例 3：$(\\alpha, \\beta, \\tau_r, \\tau_m, \\epsilon_\\infty, ||r_0||_2, \\epsilon_0) = (0.7, 0.9, 10^{-6}, 0.001, 0.0004, 1.0, 0.1)$。\n- 测试案例 4：$(\\alpha, \\beta, \\tau_r, \\tau_m, \\epsilon_\\infty, ||r_0||_2, \\epsilon_0) = \\left(10^{-0.6}, 10^{-0.3}, 10^{-6}, 10^{-3}, 0.0, 1.0, 1.0\\right)$。\n\n算法要求：\n- 计算 $k_r$ 为满足 $\\alpha^k \\le \\tau_r$ 的最小整数 $k$。如果 $\\tau_r \\ge 1$，则设 $k_r = 0$。\n- 计算 $\\epsilon_{k_r} = \\epsilon_\\infty + (\\epsilon_0 - \\epsilon_\\infty)\\,\\beta^{k_r}$。\n- 确定质量准则的可达性：如果 $\\epsilon_\\infty \\ge \\tau_m$ 且 $\\epsilon_0  \\tau_m$，则复合规则不可达。否则，计算满足 $\\epsilon_k \\le \\tau_m$ 的最小整数 $k_m$。然后设 $k_c = \\max(k_r, k_m)$。\n- 对阈值使用包含性比较（即，$\\le$ 满足准则）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试案例的结果是一个形如 $[k_r, \\epsilon_{k_r}, k_c, \\text{reachable}]$ 的列表。例如，输出应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。\n\n最终答案必须是小数或整数，而不是百分比。由于所有量均为无量纲，因此不需要物理单位。",
            "solution": "此问题经评估为有效。它在科学上基于计算流体动力学的原理，特别是关于不可压缩流迭代求解器的收敛特性。该问题是适定的，所有参数、模型和目标都有清晰的数学定义。它是客观的，没有任何无法验证或模棱两可的陈述。\n\n任务是基于两个不同的指标来分析收敛行为：线性系统的相对残差和全局质量不平衡量。我们将推导出满足每个指标和复合准则所指定阈值所需的迭代次数的解析表达式。\n\n### 1. 仅基于残差的停止迭代次数 ($k_r$) 的推导\n\n残差的停止准则基于相对残差比 $||r_k||_2 / ||r_0||_2$，其模型为 $\\alpha^k$。求解器在满足该比率小于或等于给定阈值 $\\tau_r  0$ 的最小整数迭代次数 $k_r$ 处停止。\n\n条件是：\n$$\n\\alpha^{k} \\le \\tau_r\n$$\n\n根据问题陈述，如果 $\\tau_r \\ge 1$，则在迭代 $k=0$ 时条件即被满足（因为 $\\alpha^0 = 1$），所以我们设 $k_r = 0$。\n\n如果 $\\tau_r  1$，我们可以求解 $k$。由于 $0  \\alpha  1$，对数 $\\log(\\alpha)$ 为负。对不等式两边取自然对数，我们得到：\n$$\nk \\log(\\alpha) \\le \\log(\\tau_r)\n$$\n两边同除以 $\\log(\\alpha)$ 会使不等号反向：\n$$\nk \\ge \\frac{\\log(\\tau_r)}{\\log(\\alpha)}\n$$\n由于 $k$ 必须是整数，满足此条件的最小整数 $k$ 是右侧项的向上取整。因此，仅基于残差的停止迭代次数为：\n$$\nk_r = \\left\\lceil \\frac{\\log(\\tau_r)}{\\log(\\alpha)} \\right\\rceil \\quad \\text{for } \\tau_r  1\n$$\n\n### 2. $k_r$ 处的质量不平衡量 ($\\epsilon_{k_r}$) 的计算\n\n在迭代 $k$ 处的归一化全局质量不平衡量由以下模型给出：\n$$\n\\epsilon_k = \\epsilon_\\infty + (\\epsilon_0 - \\epsilon_\\infty)\\,\\beta^k\n$$\n其中 $\\epsilon_0$ 是初始不平衡量，$\\epsilon_\\infty$ 是渐近不平衡量，而 $0  \\beta  1$ 是此指标的收缩因子。为了找到在仅残差准则停止时刻的质量不平衡量，我们将 $k = k_r$ 代入此方程：\n$$\n\\epsilon_{k_r} = \\epsilon_\\infty + (\\epsilon_0 - \\epsilon_\\infty)\\,\\beta^{k_r}\n$$\n\n### 3. 复合停止准则的分析\n\n复合准则要求同时满足残差和质量不平衡阈值。设 $k_c$ 为同时满足 $||r_k||_2 / ||r_0||_2 \\le \\tau_r$ 和 $\\epsilon_k \\le \\tau_m$ 的最小迭代次数。\n\n#### 3.1. 质量不平衡准则的可达性\n\n质量不平衡量 $\\epsilon_k$ 是一个单调递减序列，当 $k \\to \\infty$ 时收敛于 $\\epsilon_\\infty$（假设 $\\epsilon_0  \\epsilon_\\infty$）。需要满足的条件是 $\\epsilon_k \\le \\tau_m$。\n如果不平衡量的渐近极限 $\\epsilon_\\infty$ 本身大于或等于阈值 $\\tau_m$，且迭代从一个不满足的状态开始，即 $\\epsilon_0  \\tau_m$，那么对于任何有限的 $k$ 都永远无法满足该准则。这就确立了问题中陈述的不可达条件：如果 $\\epsilon_\\infty \\ge \\tau_m$ 且 $\\epsilon_0  \\tau_m$，则复合准则是不可达的。在这种情况下，我们设 $k_c = -1$。否则，该准则是可达的。\n\n#### 3.2. 质量不平衡停止迭代次数 ($k_m$) 的推导\n\n如果准则是可达的，我们必须找到满足 $\\epsilon_k \\le \\tau_m$ 的最小整数迭代次数 $k_m$。\n如果初始状态已经满足条件，即 $\\epsilon_0 \\le \\tau_m$，则最小迭代次数为 $k_m = 0$。\n\n如果 $\\epsilon_0  \\tau_m$，我们求解不等式：\n$$\n\\epsilon_\\infty + (\\epsilon_0 - \\epsilon_\\infty)\\beta^k \\le \\tau_m\n$$\n$$\n(\\epsilon_0 - \\epsilon_\\infty)\\beta^k \\le \\tau_m - \\epsilon_\\infty\n$$\n假设 $\\epsilon_0  \\epsilon_\\infty$（收敛的标准情况），我们可以除以正量 $(\\epsilon_0 - \\epsilon_\\infty)$：\n$$\n\\beta^k \\le \\frac{\\tau_m - \\epsilon_\\infty}{\\epsilon_0 - \\epsilon_\\infty}\n$$\n由于准则是可达的，并且我们处于 $\\epsilon_0  \\tau_m$ 的情况，那么必然有 $\\epsilon_\\infty  \\tau_m$，所以右侧项是一个小于 1 的正值。取自然对数：\n$$\nk \\log(\\beta) \\le \\log\\left(\\frac{\\tau_m - \\epsilon_\\infty}{\\epsilon_0 - \\epsilon_\\infty}\\right)\n$$\n除以负项 $\\log(\\beta)$ 会使不等式反向：\n$$\nk \\ge \\frac{\\log\\left( (\\tau_m - \\epsilon_\\infty) / (\\epsilon_0 - \\epsilon_\\infty) \\right)}{\\log(\\beta)}\n$$\n因此，最小整数迭代次数 $k_m$ 为：\n$$\nk_m = \\left\\lceil \\frac{\\log\\left( (\\tau_m - \\epsilon_\\infty) / (\\epsilon_0 - \\epsilon_\\infty) \\right)}{\\log(\\beta)} \\right\\rceil \\quad \\text{for } \\epsilon_0  \\tau_m \\text{ and reachable}\n$$\n\n#### 3.3. 复合停止迭代次数 ($k_c$)\n\n如果复合准则是可达的，求解器必须继续进行直到两个条件都满足。这将在两个单独准则所需迭代次数的最大值处发生。\n$$\nk_c = \\max(k_r, k_m)\n$$\n\n这些推导出的公式在提供的程序中被实现，用于计算每个测试案例所需量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the convergence analysis problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: Canonical case where residual-only stop is insufficient.\n        {'alpha': 0.8, 'beta': 0.93, 'tau_r': 1e-6, 'tau_m': 0.005, 'e_inf': 0.0102, 'r0_norm': 1.0, 'e_0': 0.1},\n        # Test Case 2: Happy path, fast mass convergence.\n        {'alpha': 0.9, 'beta': 0.6, 'tau_r': 1e-6, 'tau_m': 1e-4, 'e_inf': 0.0, 'r0_norm': 1.0, 'e_0': 0.05},\n        # Test Case 3: Delayed mass convergence, composite stop is later.\n        {'alpha': 0.7, 'beta': 0.9, 'tau_r': 1e-6, 'tau_m': 0.001, 'e_inf': 0.0004, 'r0_norm': 1.0, 'e_0': 0.1},\n        # Test Case 4: Equality boundary case.\n        {'alpha': 10**-0.6, 'beta': 10**-0.3, 'tau_r': 1e-6, 'tau_m': 1e-3, 'e_inf': 0.0, 'r0_norm': 1.0, 'e_0': 1.0}\n    ]\n\n    results = []\n    for params in test_cases:\n        result = analyze_convergence(params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list includes spaces after commas,\n    # which matches the problem's example format: [k_r, e_kr, k_c, reachable].\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef analyze_convergence(params):\n    \"\"\"\n    Computes convergence metrics for a single parameter set.\n\n    Args:\n        params (dict): A dictionary of parameters: \n                       alpha, beta, tau_r, tau_m, e_inf, r0_norm, e_0\n\n    Returns:\n        list: A list containing [k_r, e_kr, k_c, reachable].\n    \"\"\"\n    alpha = params['alpha']\n    beta = params['beta']\n    tau_r = params['tau_r']\n    tau_m = params['tau_m']\n    e_inf = params['e_inf']\n    e_0 = params['e_0']\n\n    # 1. Compute the minimal residual-only stopping iteration, k_r.\n    # The condition is alpha^k = tau_r.\n    if tau_r = 1.0:\n        k_r = 0\n    else:\n        # k = log(tau_r) / log(alpha). Since alpha  1, log(alpha) is negative.\n        # np.log is the natural logarithm.\n        k_r = int(np.ceil(np.log(tau_r) / np.log(alpha)))\n\n    # 2. Compute the mass imbalance at the residual-only stop, e_kr.\n    e_kr = e_inf + (e_0 - e_inf) * (beta ** k_r)\n\n    # 3.  4. Determine reachability and compute the composite stopping iteration, k_c.\n    \n    # The composite criterion is unreachable if the asymptotic mass imbalance is\n    # not better than the threshold AND the starting imbalance is worse.\n    is_reachable = not (e_inf = tau_m and e_0  tau_m)\n\n    if not is_reachable:\n        k_c = -1\n    else:\n        # Mass criterion is reachable. Find the minimal iteration k_m for it.\n        # The condition is e_k = tau_m.\n        if e_0 = tau_m:\n            k_m = 0\n        else:\n            # e_inf + (e_0 - e_inf) * beta^k = tau_m\n            # beta^k = (tau_m - e_inf) / (e_0 - e_inf)\n            # k = log( (tau_m - e_inf) / (e_0 - e_inf) ) / log(beta)\n            # Since beta  1, log(beta) is negative, inequality flips.\n            # And since reachable with e_0  tau_m, we have e_inf  tau_m.\n            ratio = (tau_m - e_inf) / (e_0 - e_inf)\n            k_m = int(np.ceil(np.log(ratio) / np.log(beta)))\n\n        # The composite rule stops when both criteria are met.\n        k_c = max(k_r, k_m)\n    \n    return [k_r, e_kr, k_c, is_reachable]\n\n# Execute the main function.\nsolve()\n```"
        },
        {
            "introduction": "残差要多小才算“足够小”？这个问题引出了收敛的终极限制。本练习将视角从相对比较转向绝对极限，探讨了浮点运算如何为可实现的残差范数设定一个基本下限。通过推导和计算这个停滞阈值，你将深入理解后向误差的概念，并学会识别何时继续迭代已不再有效，从而避免不必要的计算开销。",
            "id": "3374577",
            "problem": "考虑在单位正方形 $(0,1)^{2}$ 上定义的、带有齐次狄利克雷边界条件的二维泊松方程 $-\\Delta u = f$。在均匀网格上使用标准的五点二阶有限差分格式进行离散化，每个空间坐标方向有 $n=127$ 个内部格点，因此网格间距为 $h = 1/(n+1) = 1/128$。由此得到的线性系统为 $A x = b$，其中 $A \\in \\mathbb{R}^{m \\times m}$，$m = n^{2}$。设精确解向量 $x^{\\star} \\in \\mathbb{R}^{m}$ 的所有分量均为 $1$，并设 $b := A x^{\\star}$。\n\n假设将一个迭代克雷洛夫子空间方法，如共轭梯度法（CG），应用于 $A x = b$。在每次迭代中，使用机器精度为 $\\epsilon_{\\text{mach}} = 2^{-53}$ 的标准浮点运算计算残差 $r_{k} = b - A x_{k}$。假设矩阵向量乘积的浮点计算满足通常的一阶舍入模型，并且谱范数 $\\|A\\|_{2}$ 由该网格上离散拉普拉斯算子的最大特征值决定。\n\n仅使用浮点舍入模型和后向误差分析的基本原理，以及离散拉普拉斯算子的标准谱性质，完成以下任务：\n\n1. 推导在 $\\epsilon_{\\text{mach}}$ 的主阶项下，可达残差范数 $\\|r_{k}\\|_{2}$ 的一个有原则的停滞阈值 $R_{\\star}$。当残差范数低于此阈值时，由于浮点效应占主导，进一步减小残差是低效的。请用 $\\epsilon_{\\text{mach}}$、$\\|A\\|_{2}$ 和 $\\|x^{\\star}\\|_{2}$ 表示 $R_{\\star}$，并解释当 $\\|r_{k}\\|_{2} \\approx R_{\\star}$ 时终止迭代的后向误差含义。\n\n2. 对于由 $n=127$ 离散化得到的特定矩阵 $A$，使用单位正方形上带有齐次狄利克雷边界条件的五点离散拉普拉斯算子的精确最大特征值来计算 $\\|A\\|_{2}$，并对全一向量使用精确的 $\\|x^{\\star}\\|_{2}$。然后，在此设置下计算\n$$\nR_{\\star} = \\epsilon_{\\text{mach}} \\,\\|A\\|_{2}\\, \\|x^{\\star}\\|_{2}\n$$\n的数值。将最终的 $R_{\\star}$ 数值结果四舍五入至四位有效数字。\n\n你的最终答案应该是 $R_{\\star}$ 的单一舍入值，不带单位。如果在你的计算中出现角度，必须以弧度为单位。",
            "solution": "该问题要求推导迭代求解器中由于浮点效应导致的残差范数的停滞阈值，然后为一个特定的离散化泊松问题计算该阈值。\n\n第1部分：停滞阈值 $R_{\\star}$ 的推导与解释\n\n应用于线性系统 $A x = b$ 的迭代方法会生成一个近似解序列 $x_k$。收敛性通过真实残差 $r_k = b - A x_k$ 的范数来监控。在使用浮点运算的计算机中，我们只能计算一个近似残差 $\\hat{r}_k$。$\\hat{r}_k$ 的计算过程为 $\\hat{r}_k = \\text{fl}(b - \\text{fl}(A x_k))$，其中 $\\text{fl}(\\cdot)$ 表示浮点计算的结果。\n\n此计算中的主要误差来源是矩阵向量乘积 $\\text{fl}(A x_k)$。根据浮点矩阵向量乘法的标准一阶前向误差模型，误差受参与计算的量的范数限制。具体来说，误差向量 $e_k = \\text{fl}(A x_k) - A x_k$ 的范数可以被界定为：\n$$\n\\|e_k\\|_2 = \\|\\text{fl}(A x_k) - A x_k\\|_2 \\lesssim c \\cdot \\epsilon_{\\text{mach}} \\|A\\|_2 \\|x_k\\|_2\n$$\n其中 $\\epsilon_{\\text{mach}}$ 是机器精度，$c$ 是一个数量级为 $1$ 的常数，其精确值取决于矩阵的维度和稀疏性，但对于主阶分析，通常取 $c \\approx 1$。\n\n因此，计算出的残差 $\\hat{r}_k$ 是真实残差 $r_k$ 的一个近似。其值由 $b$ 减去 $\\text{fl}(A x_k)$ 的浮点运算决定。在一阶近似下，矩阵向量乘积的误差是对计算残差误差的最大贡献，特别是当真实残差很小时。我们可以写出：\n$$\n\\hat{r}_k \\approx (b - A x_k) - (\\text{fl}(A x_k) - A x_k) = r_k - e_k\n$$\n随着迭代方法的收敛，近似解 $x_k$ 接近精确解 $x^{\\star}$，这意味着真实残差 $r_k$ 趋近于零向量，即 $\\|r_k\\|_2 \\to 0$。然而，浮点误差项 $e_k$ 不会消失。当 $\\|x_k\\|_2$ 接近 $\\|x^{\\star}\\|_2$ 时，其大小趋于稳定。因此，计算残差的范数 $\\|\\hat{r}_k\\|_2$ 将由误差的范数 $\\|e_k\\|_2$ 主导。\n$$\n\\lim_{k \\to \\infty} \\|\\hat{r}_k\\|_2 \\approx \\|e_k\\|_2 \\approx \\epsilon_{\\text{mach}} \\|A\\|_2 \\|x^{\\star}\\|_2\n$$\n这个极限值代表了一个下限，低于该下限，计算残差的范数就无法被可靠地减小。真实残差 $\\|r_k\\|_2$ 的任何进一步减小都会被浮点噪声所掩盖。因此，一个有原则的停滞阈值 $R_{\\star}$ 由下式给出：\n$$\nR_{\\star} = \\epsilon_{\\text{mach}} \\|A\\|_2 \\|x^{\\star}\\|_2\n$$\n该阈值的后向误差解释如下。当真实残差范数满足 $\\|r_k\\|_2 \\approx R_{\\star}$ 时，我们有：\n$$\n\\|b - A x_k\\|_2 \\approx \\epsilon_{\\text{mach}} \\|A\\|_2 \\|x^{\\star}\\|_2\n$$\n假设在收敛附近 $\\|x_k\\|_2 \\approx \\|x^{\\star}\\|_2$，这可以重新整理为：\n$$\n\\frac{\\|b - A x_k\\|_2}{\\|A\\|_2 \\|x_k\\|_2} \\approx \\epsilon_{\\text{mach}}\n$$\n左边的项是近似解 $x_k$ 的范数形式的相对后向误差。它表示使得 $x_k$ 是扰动系统 $(A + \\delta A) x_k = b$ 的精确解的最小相对扰动 $\\delta A$。因此，当残差范数达到 $R_{\\star}$ 时终止迭代，相当于找到了一个近似解 $x_k$，该解是一个邻近问题的精确解，其中“邻近”的程度在机器精度的数量级。这通常是在浮点运算中可以达到的最佳结果。\n\n第2部分：针对给定问题的数值计算\n\n我们需要根据给定参数计算 $R_{\\star} = \\epsilon_{\\text{mach}} \\|A\\|_2 \\|x^{\\star}\\|_2$。\n\n1.  **给定值**：\n    - 机器精度：$\\epsilon_{\\text{mach}} = 2^{-53}$。\n    - 每个维度的内部格点数：$n=127$。\n    - 未知数的总数为 $m = n^2 = 127^2 = 16129$。\n    - 网格间距为 $h = 1/(n+1) = 1/128$。\n\n2.  **计算 $\\|x^{\\star}\\|_{2}$**：\n    精确解向量 $x^{\\star} \\in \\mathbb{R}^{m}$ 的所有 $m=n^2$ 个分量都等于 $1$。其欧几里得范数为：\n    $$\n    \\|x^{\\star}\\|_2 = \\sqrt{\\sum_{i=1}^{n^2} 1^2} = \\sqrt{n^2} = n = 127\n    $$\n\n3.  **计算 $\\|A\\|_{2}$**：\n    矩阵 $A$ 来自于负拉普拉斯算子 $-\\Delta$ 的标准五点有限差分格式离散化。矩阵 $A$ 是对称的，因此其 $2$-范数等于其最大特征值（谱半径）：$\\|A\\|_2 = \\lambda_{\\max}(A)$。在单位正方形上，网格参数为 $n$ 且带有齐次狄利克雷边界条件的离散拉普拉斯算子的特征值是已知的：\n    $$\n    \\lambda_{p,q} = \\frac{1}{h^2} \\left(4 - 2\\cos\\left(\\frac{p\\pi}{n+1}\\right) - 2\\cos\\left(\\frac{q\\pi}{n+1}\\right)\\right) \\quad \\text{for } p,q = 1, 2, \\ldots, n\n    $$\n    最大特征值 $\\lambda_{\\max}$ 在余弦项取最小值时出现，这对应于最大索引 $p=n$ 和 $q=n$。\n    $$\n    \\|A\\|_2 = \\lambda_{n,n} = \\frac{2}{h^2} \\left(2 - 2\\cos\\left(\\frac{n\\pi}{n+1}\\right)\\right) = \\frac{4}{h^2} \\left(1 - \\cos\\left(\\frac{n\\pi}{n+1}\\right)\\right)\n    $$\n    使用恒等式 $\\cos(\\pi - \\theta) = -\\cos(\\theta)$，我们可以写出 $\\cos\\left(\\frac{n\\pi}{n+1}\\right) = \\cos\\left(\\pi - \\frac{\\pi}{n+1}\\right) = -\\cos\\left(\\frac{\\pi}{n+1}\\right)$。将此代入 $\\|A\\|_2$ 的表达式中：\n    $$\n    \\|A\\|_2 = \\frac{4}{h^2} \\left(1 + \\cos\\left(\\frac{\\pi}{n+1}\\right)\\right)\n    $$\n    当 $n=127$ 时，我们有 $n+1=128$ 且 $h=1/128$。\n    $$\n    \\|A\\|_2 = \\frac{4}{(1/128)^2} \\left(1 + \\cos\\left(\\frac{\\pi}{128}\\right)\\right) = 4 \\cdot 128^2 \\left(1 + \\cos\\left(\\frac{\\pi}{128}\\right)\\right)\n    $$\n\n4.  **计算 $R_{\\star}$**：\n    现在我们组合 $R_{\\star}$ 的表达式：\n    $$\n    R_{\\star} = \\epsilon_{\\text{mach}} \\|A\\|_2 \\|x^{\\star}\\|_2 = 2^{-53} \\cdot \\left[4 \\cdot 128^2 \\left(1 + \\cos\\left(\\frac{\\pi}{128}\\right)\\right)\\right] \\cdot 127\n    $$\n    我们可以简化 $2$ 的幂。由于 $128 = 2^7$ 且 $4=2^2$，我们有 $4 \\cdot 128^2 = 2^2 \\cdot (2^7)^2 = 2^2 \\cdot 2^{14} = 2^{16}$。\n    $$\n    R_{\\star} = 2^{-53} \\cdot 2^{16} \\cdot 127 \\cdot \\left(1 + \\cos\\left(\\frac{\\pi}{128}\\right)\\right) = 2^{-37} \\cdot 127 \\cdot \\left(1 + \\cos\\left(\\frac{\\pi}{128}\\right)\\right)\n    $$\n    我们现在对这个表达式进行数值计算：\n    $R_{\\star} \\approx (7.2759576 \\times 10^{-12}) \\cdot 127 \\cdot (1 + 0.9996988) = (7.2759576 \\times 10^{-12}) \\cdot 127 \\cdot (1.9996988)$\n    $R_{\\star} \\approx 1.84784081699 \\times 10^{-9}$\n\n将此值四舍五入至四位有效数字，我们得到：\n$R_{\\star} \\approx 1.848 \\times 10^{-9}$。",
            "answer": "$$\n\\boxed{1.848 \\times 10^{-9}}\n$$"
        }
    ]
}