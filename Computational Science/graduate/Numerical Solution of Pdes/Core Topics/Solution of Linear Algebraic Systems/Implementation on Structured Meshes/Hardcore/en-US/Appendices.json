{
    "hands_on_practices": [
        {
            "introduction": "A crucial first step in developing any numerical solver is to verify its correctness and confirm that it achieves the designed order of accuracy. This practice guides you through a grid refinement study for the 2D heat equation, a cornerstone of verification and validation. By implementing a standard finite difference and Crank-Nicolson scheme and comparing the numerical results against a known \"manufactured\" solution, you will empirically measure the convergence rates, providing concrete evidence that your implementation is free of bugs and behaves as theoretically predicted .",
            "id": "3405925",
            "problem": "Design and implement a grid refinement study on a two-dimensional structured mesh to empirically verify second-order convergence for a discretization of the heat equation. Consider the nondimensional heat equation on the unit square domain $[0,1] \\times [0,1]$ with homogeneous Dirichlet boundary conditions. The governing partial differential equation is $u_t - \\alpha \\Delta u = 0$ with $u(x,y,t) = 0$ for $(x,y) \\in \\partial([0,1]^2)$ and $t \\ge 0$, where $\\alpha > 0$ is a constant thermal diffusivity. Use the method of manufactured solutions by defining a smooth exact solution $u_{\\mathrm{exact}}(x,y,t)$ that satisfies the equation and boundary conditions on the domain. Specifically, use the family of functions\n$$\nu_{\\mathrm{exact}}(x,y,t) = \\sin(k_x \\pi x)\\sin(k_y \\pi y)\\exp\\!\\left(-\\alpha \\pi^2 (k_x^2 + k_y^2) t\\right),\n$$\nwhere $k_x$ and $k_y$ are positive integers and $(x,y) \\in [0,1]^2$. This $u_{\\mathrm{exact}}$ satisfies the heat equation $u_t - \\alpha \\Delta u = 0$ with homogeneous Dirichlet boundary conditions on the unit square.\n\nDiscretize the spatial domain using a uniform structured mesh with $N$ intervals per dimension, resulting in grid spacing $h = 1/N$ and interior unknowns at the nodes $(x_i, y_j)$ with $x_i = i h$ and $y_j = j h$ for $i,j \\in \\{1,2,\\dots,N-1\\}$. Use second-order centered finite differences to approximate the Laplacian $\\Delta u$ with a five-point stencil. Discretize time using the Crank-Nicolson (CN) method with a uniform time step $\\Delta t$, ensuring that the fully discrete scheme is second order in both space and time. Initialize the numerical solution with $u(x,y,0) = u_{\\mathrm{exact}}(x,y,0)$ and evolve to a final time $T > 0$. Compute the error $e(x_i,y_j) = u_{\\mathrm{num}}(x_i,y_j,T) - u_{\\mathrm{exact}}(x_i,y_j,T)$ at interior nodes.\n\nDefine the discrete norms as follows:\n- The discrete $L^2$ norm is\n$$\n\\|e\\|_{L^2_h} = \\left(h^2 \\sum_{i=1}^{N-1} \\sum_{j=1}^{N-1} \\left|e(x_i,y_j)\\right|^2\\right)^{1/2}.\n$$\n- The discrete $L^\\infty$ norm is\n$$\n\\|e\\|_{L^\\infty_h} = \\max_{1 \\le i,j \\le N-1} \\left|e(x_i,y_j)\\right|.\n$$\n\nPerform grid refinement by doubling $N$ and, for each refinement pair $(N,2N)$, compute the observed order of convergence $p$ in each norm using\n$$\np = \\frac{\\log\\left(\\frac{E(N)}{E(2N)}\\right)}{\\log(2)},\n$$\nwhere $E(N)$ denotes the error norm at resolution $N$. For stability and accuracy, choose time steps according to two policies:\n- Policy A: $\\Delta t = T/N^2$, ensuring the temporal error is asymptotically negligible compared to spatial error and that the number of time steps is exactly $N^2$ for final time $T$.\n- Policy B (edge case): use a fixed number of time steps independent of $N$, specifically $50$ steps so that $\\Delta t = T/50$, demonstrating degradation when temporal discretization error is not refined.\n\nImplement the discretization on a structured mesh and assemble the finite difference operator using lexicographic ordering of interior nodes. Solve the linear systems arising from the Crank-Nicolson method at each time step.\n\nYour program must execute the following test suite and produce the specified outputs:\n- Test case $1$ (happy path): $\\alpha = 1.0$, $k_x = 1$, $k_y = 1$, $T = 0.1$, $N \\in \\{8,16,32\\}$, Policy A for $\\Delta t$.\n- Test case $2$ (happy path with anisotropy): $\\alpha = 0.7$, $k_x = 2$, $k_y = 3$, $T = 0.1$, $N \\in \\{8,16,32\\}$, Policy A for $\\Delta t$.\n- Test case $3$ (edge case with fixed time steps): $\\alpha = 1.0$, $k_x = 1$, $k_y = 1$, $T = 0.1$, $N \\in \\{8,16,32\\}$, Policy B for $\\Delta t$.\n\nFor each test case, compute the average observed order of convergence across the two refinement pairs $(8,16)$ and $(16,32)$ in both the discrete $L^2$ and discrete $L^\\infty$ norms. The final output must be a single line containing the six floating-point numbers in the following order:\n$$\n[p^{(1)}_{L^2}, p^{(1)}_{L^\\infty}, p^{(2)}_{L^2}, p^{(2)}_{L^\\infty}, p^{(3)}_{L^2}, p^{(3)}_{L^\\infty}],\n$$\nwhere $p^{(m)}_{\\cdot}$ denotes the average observed order for test case $m \\in \\{1,2,3\\}$. The program must print exactly one line with this list using comma-separated values enclosed in square brackets. No physical units are required; all quantities are nondimensional. Angles are not involved in this problem. All answers must be floating-point numbers.",
            "solution": "The user requires the design and implementation of a grid refinement study to verify the order of convergence for a numerical solution to the two-dimensional heat equation. The problem is valid as it is scientifically grounded in the principles of partial differential equations and numerical analysis, is well-posed, and all parameters and methods are defined objectively and completely.\n\nThe governing partial differential equation (PDE) is the nondimensional heat equation on the unit square domain $\\Omega = [0,1] \\times [0,1]$:\n$$\n\\frac{\\partial u}{\\partial t} - \\alpha \\Delta u = 0, \\quad (x,y) \\in \\Omega, \\quad t \\ge 0\n$$\nwith homogeneous Dirichlet boundary conditions, $u(x,y,t) = 0$ for $(x,y) \\in \\partial\\Omega$. Here, $\\alpha > 0$ is the constant thermal diffusivity.\n\nA manufactured solution is provided to facilitate error analysis:\n$$\nu_{\\mathrm{exact}}(x,y,t) = \\sin(k_x \\pi x)\\sin(k_y \\pi y)\\exp\\!\\left(-\\alpha \\pi^2 (k_x^2 + k_y^2) t\\right)\n$$\nwhere $k_x$ and $k_y$ are positive integers. This function satisfies both the PDE and the boundary conditions. The numerical solution must start from the initial condition $u(x,y,0) = u_{\\mathrm{exact}}(x,y,0)$.\n\nThe solution approach involves discretizing the PDE in both space and time and then performing a convergence study.\n\n**1. Spatial Discretization**\n\nThe domain is discretized using a uniform structured mesh with $N$ intervals in each dimension, giving a grid spacing of $h = 1/N$. This results in an $(N-1) \\times (N-1)$ grid of interior nodes $(x_j, y_i) = (j h, i h)$ for $i,j \\in \\{1, \\ldots, N-1\\}$. The value of the solution at these nodes is denoted by $u_{i,j}(t) \\approx u(x_j, y_i, t)$.\n\nThe Laplacian operator, $\\Delta u = u_{xx} + u_{yy}$, is approximated using a second-order centered finite difference scheme (a five-point stencil):\n$$\n(\\Delta u)_{i,j} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} + \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2}\n$$\nThe values for $u$ on the boundary are zero due to the Dirichlet conditions.\nIf we arrange the $(N-1)^2$ interior unknown values into a single column vector $\\mathbf{u}$ using lexicographical (row-major) ordering, the semi-discretized system can be written as an ordinary differential equation (ODE) system:\n$$\n\\frac{d\\mathbf{u}}{dt} = \\alpha A_h \\mathbf{u}\n$$\nHere, $A_h$ is the sparse matrix representation of the discretized Laplacian operator. For row-major ordering, where the index over $x$ varies fastest, $A_h$ can be constructed using Kronecker products of the one-dimensional second-derivative matrix, $K_{1D}$, and the identity matrix, $I_{N-1}$:\n$$\nA_h = \\frac{1}{h^2} (I_{N-1} \\otimes K_{1D} + K_{1D} \\otimes I_{N-1})\n$$\nwhere $I_{N-1}$ is the identity matrix of size $(N-1) \\times (N-1)$ and $K_{1D}$ is the tridiagonal matrix of the same size with stencil $(1, -2, 1)$ on its diagonals.\n\n**2. Temporal Discretization**\n\nThe Crank-Nicolson method, an implicit second-order accurate scheme, is used for time integration. Applying it to the semi-discretized system gives:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{\\alpha}{2} A_h (\\mathbf{u}^{n+1} + \\mathbf{u}^n)\n$$\nwhere $\\mathbf{u}^n$ is the solution vector at time $t_n = n \\Delta t$. To solve for the solution at the next time step, $\\mathbf{u}^{n+1}$, we rearrange the equation:\n$$\n\\left(I - \\frac{\\alpha \\Delta t}{2} A_h\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\alpha \\Delta t}{2} A_h\\right) \\mathbf{u}^n\n$$\nwhere $I$ is the identity matrix of size $(N-1)^2 \\times (N-1)^2$. At each time step, this equation forms a linear system of equations, $L \\mathbf{u}^{n+1} = R \\mathbf{u}^n$, which must be solved for $\\mathbf{u}^{n+1}$. The matrices $L$ and $R$ are sparse, and efficient sparse linear solvers can be employed.\n\n**3. Convergence Study**\n\nThe fully discrete scheme is second-order in both space ($O(h^2)$) and time ($O(\\Delta t^2)$). The study proceeds as follows:\n- For a sequence of grid resolutions, $N \\in \\{8, 16, 32\\}$, the numerical solution $\\mathbf{u}_{\\mathrm{num}}(T)$ is computed up to a final time $T$.\n- The error vector $\\mathbf{e} = \\mathbf{u}_{\\mathrm{num}}(T) - \\mathbf{u}_{\\mathrm{exact}}(T)$ is calculated at the interior nodes.\n- The discrete $L^2_h$ and $L^\\infty_h$ norms of the error, denoted $E$, are computed.\n- For each refinement from $N$ to $2N$, the observed order of convergence, $p$, is calculated using the formula:\n$$\np = \\frac{\\log(E(N)/E(2N))}{\\log(2)}\n$$\n- The final reported order is the average of the orders computed from the refinement pairs $(8,16)$ and $(16,32)$.\n\nTwo time-stepping policies are investigated:\n- **Policy A**: $\\Delta t = T/N^2$. Since $h \\propto 1/N$, this means $\\Delta t \\propto h^2$. The temporal error, $O(\\Delta t^2)$, becomes $O(h^4)$, which is of higher order than the spatial error, $O(h^2)$. Thus, the overall error will be dominated by the spatial discretization, and the observed order of convergence $p$ is expected to be approximately $2$.\n- **Policy B**: $\\Delta t = T/50$ (a fixed number of steps). As $N$ increases, the spatial error $O(h^2)$ decreases, but the temporal error $O(\\Delta t^2)$ remains constant. The total error will be dominated by the fixed temporal error. Consequently, the error norm $E(N)$ will converge to a non-zero constant, the ratio $E(N)/E(2N)$ will approach $1$, and the observed order $p$ will approach $0$.\n\nThe implementation will construct the sparse matrices and use a sparse linear solver at each step of the time-marching scheme. The results from the specified test cases will be calculated and formatted as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the 2D heat equation\n    and print the convergence orders.\n    \"\"\"\n\n    def exact_solution(x, y, t, alpha, kx, ky):\n        \"\"\"\n        Calculates the exact manufactured solution on a grid.\n        x, y can be meshgrid arrays.\n        \"\"\"\n        lambda_term = alpha * np.pi**2 * (kx**2 + ky**2)\n        return np.sin(kx * np.pi * x) * np.sin(ky * np.pi * y) * np.exp(-lambda_term * t)\n\n    def run_simulation(N, alpha, kx, ky, T, policy):\n        \"\"\"\n        Runs a single simulation for a given grid size N and physical parameters.\n        Returns the L2 and L-infinity error norms.\n        \"\"\"\n        M = N - 1\n        h = 1.0 / N\n\n        # Determine time step dt based on the policy\n        if policy == 'A':\n            num_steps = N**2\n        else:  # policy == 'B'\n            num_steps = 50\n        dt = T / num_steps\n\n        # Create grid for interior points. We use row-major (C-style) ordering,\n        # where u_grid[i, j] corresponds to point (x_j, y_i).\n        x = np.linspace(h, 1.0 - h, M)\n        y = np.linspace(h, 1.0 - h, M)\n        xx, yy = np.meshgrid(x, y, indexing='xy')\n\n        # Construct the 2D Laplacian operator A_h for row-major flattening.\n        diags_1d = [np.ones(M - 1), -2 * np.ones(M), np.ones(M - 1)]\n        K_1D = sparse.diags(diags_1d, [-1, 0, 1], format='csc')\n        I_M = sparse.identity(M, format='csc')\n\n        # sparse.kron(I_M, K_1D) handles x-derivatives (fastest index)\n        # sparse.kron(K_1D, I_M) handles y-derivatives (slower index)\n        A_h = (1 / h**2) * (sparse.kron(I_M, K_1D) + sparse.kron(K_1D, I_M))\n\n        # Construct Crank-Nicolson matrices (LHS and RHS).\n        I_M2 = sparse.identity(M**2, format='csc')\n        LHS = I_M2 - (alpha * dt / 2.0) * A_h\n        RHS = I_M2 + (alpha * dt / 2.0) * A_h\n        \n        # Initial condition from exact solution at t=0\n        u0_grid = exact_solution(xx, yy, 0, alpha, kx, ky)\n        u_vec = u0_grid.flatten()  # Row-major flattening by default\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            b_vec = RHS @ u_vec\n            u_vec = linalg.spsolve(LHS, b_vec)\n\n        # Calculate error at final time T\n        u_final_grid = u_vec.reshape((M, M))\n        u_exact_final_grid = exact_solution(xx, yy, T, alpha, kx, ky)\n        \n        error_grid = u_final_grid - u_exact_final_grid\n        \n        # Compute discrete L2 and L-infinity norms\n        error_l2 = h * np.linalg.norm(error_grid.flatten())\n        error_linf = np.max(np.abs(error_grid))\n\n        return error_l2, error_linf\n\n    def run_convergence_study(params):\n        \"\"\"\n        Runs simulations for a range of N and computes the average order of convergence.\n        \"\"\"\n        errors_l2 = []\n        errors_linf = []\n        \n        for N in params['Ns']:\n            l2_err, linf_err = run_simulation(\n                N, params['alpha'], params['kx'], params['ky'], params['T'], params['policy']\n            )\n            errors_l2.append(l2_err)\n            errors_linf.append(linf_err)\n\n        def calculate_avg_order(errors):\n            orders = []\n            for i in range(len(errors) - 1):\n                # Ratio of errors from grid N to 2N\n                ratio = errors[i] / errors[i+1]\n                if ratio > 1e-12:  # Avoid log of zero or negative\n                    order = np.log(ratio) / np.log(2)\n                    orders.append(order)\n            \n            if not orders:\n                return float('nan')\n            return np.mean(orders)\n\n        avg_p_l2 = calculate_avg_order(errors_l2)\n        avg_p_linf = calculate_avg_order(errors_linf)\n\n        return avg_p_l2, avg_p_linf\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path)\n        {'alpha': 1.0, 'kx': 1, 'ky': 1, 'T': 0.1, 'Ns': [8, 16, 32], 'policy': 'A'},\n        # Test case 2 (happy path with anisotropy)\n        {'alpha': 0.7, 'kx': 2, 'ky': 3, 'T': 0.1, 'Ns': [8, 16, 32], 'policy': 'A'},\n        # Test case 3 (edge case with fixed time steps)\n        {'alpha': 1.0, 'kx': 1, 'ky': 1, 'T': 0.1, 'Ns': [8, 16, 32], 'policy': 'B'},\n    ]\n\n    results = []\n    for case in test_cases:\n        p_l2, p_linf = run_convergence_study(case)\n        results.extend([p_l2, p_linf])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond quantitative accuracy, a robust numerical scheme should also preserve key qualitative properties of the underlying partial differential equation. This exercise explores the Discrete Maximum Principle (DMP), a fundamental property for elliptic equations like the Poisson equation, which ensures that solutions do not exhibit spurious oscillations. You will implement and compare two different finite difference stencils—one standard and one deliberately non-monotone—to see firsthand how the structure of the discrete operator dictates whether the solution respects this vital physical principle .",
            "id": "3405941",
            "problem": "Consider the elliptic boundary value problem $-\\Delta u = f \\ge 0$ on the unit square $\\Omega = (0,1)\\times(0,1)$ with homogeneous Dirichlet boundary conditions $u|_{\\partial \\Omega} = 0$. You will design and implement a discrete maximum principle (DMP) test on a two-dimensional structured mesh to assess whether a given finite difference scheme on a uniform grid is monotone, in the sense that it preserves the sign properties implied by the continuous maximum principle. Begin from the following fundamental base: (i) the classical maximum principle for second-order elliptic partial differential equations states that if $-\\Delta u \\ge 0$ in $\\Omega$ and $u$ attains its minimum in the interior, then $u$ is constant; in particular, for $-\\Delta u = f \\ge 0$ with $u|_{\\partial \\Omega} \\ge 0$, the solution satisfies $u \\ge 0$ in $\\Omega$, (ii) on a uniform structured mesh with mesh spacing $h = 1/(N-1)$ for $N$ nodes in each spatial direction, a finite difference discretization of $-\\Delta u$ at an interior mesh point $(i,j)$ has the general form $a_{0,0} u_{i,j} + \\sum_{(p,q)\\neq (0,0)} a_{p,q} u_{i+p,j+q}$, where the coefficients $a_{p,q}$ are mesh-dependent and encode the stencil. A discrete operator is monotone if its matrix is an $M$-matrix (nonpositive off-diagonals, positive diagonal, and inverse nonnegative), which in turn guarantees a discrete maximum principle: for $f \\ge 0$ and nonnegative Dirichlet boundary data, the discrete solution is nonnegative at all interior nodes.\n\nYour task is to implement two schemes on a uniform structured mesh and to test the discrete maximum principle by constructing forcings $f$ that stress monotonicity:\n\n- Scheme $\\mathsf{S}_1$ (monotone): the standard $5$-point stencil for $-\\Delta$ on a uniform grid, given by\n$$\n\\left(-\\Delta_h^{(5)} u\\right)_{i,j} \\;=\\; \\frac{4 u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2},\n$$\nwith homogeneous Dirichlet conditions enforced on $\\partial \\Omega$.\n\n- Scheme $\\mathsf{S}_2$ (deliberately nonmonotone): an $8$-neighbor modification that adds an \"anti-diffusive\" diagonal coupling with a positive weight $\\alpha > 0$,\n$$\n\\left(\\mathcal{A}_h^{(\\alpha)} u\\right)_{i,j} \\;=\\; \\frac{4 u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} + \\alpha \\left(u_{i-1,j-1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i+1,j+1}\\right)}{h^2},\n$$\nagain with homogeneous Dirichlet conditions. For $\\alpha > 0$, this operator has positive off-diagonal entries in the diagonal directions and is generally not an $M$-matrix, so the discrete maximum principle can fail.\n\nDefine the discrete maximum principle test as follows. For a given scheme and a nonnegative forcing $f \\ge 0$, assemble the interior linear system $A \\mathbf{u} = \\mathbf{f}$ for the unknown interior nodal values $\\mathbf{u}$. Compute the solution and measure the violation magnitude\n$$\n\\mathcal{V} \\;=\\; \\max\\{0,\\; -\\min_{(i,j)\\text{ interior}} u_{i,j}\\}.\n$$\nA monotone scheme with $f \\ge 0$ and $u|_{\\partial \\Omega}=0$ should satisfy $u_{i,j} \\ge 0$, hence $\\mathcal{V} = 0$ up to numerical roundoff. A positive value $\\mathcal{V} > 0$ indicates a DMP violation (undershoot below $0$) in the interior.\n\nImplement the following forcings on the structured mesh and use them as a test suite. In each case, $N$ denotes the total number of nodes in each coordinate direction (including boundary nodes), $h = 1/(N-1)$, and all Dirichlet boundary values are exactly $0$. The forcings are nonnegative by construction and are expressed in discrete form on interior nodes:\n\n- Forcing $\\mathsf{F}_\\delta$: a discrete point source at the mesh center scaled by $h^{-2}$. Let $(i_c,j_c)$ be the interior node closest to $(x,y)=(0.5,0.5)$. Set $f_{i_c,j_c} = A_\\delta \\, h^{-2}$ and $f_{i,j}=0$ for all other interior nodes. Here $A_\\delta$ is a positive amplitude.\n\n- Forcing $\\mathsf{F}_{\\mathrm{ring}}$: a thin positive ring centered at $(0.5,0.5)$ of radius $r_0$ and half-width $w$ specified in cells. For interior node $(i,j)$ at coordinates $(x_i,y_j)$, define $r_{i,j} = \\sqrt{(x_i-0.5)^2 + (y_j-0.5)^2}$ and set $f_{i,j} = A_{\\mathrm{ring}} \\, h^{-2}$ if $|r_{i,j}-r_0| \\le w h$, and $f_{i,j}=0$ otherwise. Here $A_{\\mathrm{ring}}$ is a positive amplitude, $r_0 \\in (0,0.5)$, and $w$ is a positive integer.\n\nYour program must assemble the linear systems for the interior nodes using the specified stencil coefficients and exact Dirichlet elimination, solve for the interior values, compute the violation magnitude $\\mathcal{V}$ for each test, and aggregate the results in the required output format.\n\nTest suite to implement and evaluate:\n\n- Case $1$: $N=33$, scheme $\\mathsf{S}_1$ (standard $5$-point), forcing $\\mathsf{F}_\\delta$ with $A_\\delta=1.0$.\n\n- Case $2$: $N=33$, scheme $\\mathsf{S}_2$ with $\\alpha=0.9$, forcing $\\mathsf{F}_\\delta$ with $A_\\delta=10.0$.\n\n- Case $3$: $N=25$, scheme $\\mathsf{S}_1$ (standard $5$-point), forcing $\\mathsf{F}_{\\mathrm{ring}}$ with $A_{\\mathrm{ring}}=5.0$, $r_0=0.30$, $w=2$.\n\n- Case $4$: $N=41$, scheme $\\mathsf{S}_2$ with $\\alpha=0.7$, forcing $\\mathsf{F}_{\\mathrm{ring}}$ with $A_{\\mathrm{ring}}=40.0$, $r_0=0.28$, $w=3$.\n\nFinal output format: Your program should produce a single line of output containing the violation magnitudes $\\mathcal{V}$ for Cases $1$ through $4$ as a comma-separated list enclosed in square brackets, for example, $[\\nu_1,\\nu_2,\\nu_3,\\nu_4]$, where each $\\nu_k$ is a floating-point number. No other text should be printed. Angles do not appear in this problem, and no physical units are required. The results must be computed by your program and not hard-coded.",
            "solution": "The user wants me to solve a numerical analysis problem.\n\nHere's a plan:\n1.  **Validate the Problem**:\n    *   **Step 1: Extract Givens**: I'll list all the equations, definitions, and parameters provided in the problem statement.\n    *   **Step 2: Validate Using Extracted Givens**: I'll check the problem for scientific soundness, well-posedness, objectivity, completeness, and other criteria.\n        *   **Scientific Grounded**: The problem is about the numerical solution of PDEs, specifically the Poisson equation. The concepts of finite difference methods, structured meshes, discrete maximum principle (DMP), M-matrices, and stencil definitions are standard in numerical analysis. The 5-point stencil for the Laplacian is canonical. The modified 8-neighbor stencil is a valid, though non-standard, construction designed to illustrate a point about DMP failure. The definitions are mathematically rigorous. This seems sound.\n        *   **Well-Posed**: The problem is well-posed. It asks to implement specific numerical schemes for a specific PDE with specific boundary conditions and specific forcing terms. The task is to compute a well-defined metric, the \"violation magnitude\" $\\mathcal{V}$. The problem provides all necessary parameters for four test cases. A unique solution exists for each test case.\n        *   **Objective**: The problem is stated objectively using mathematical and algorithmic language. There are no subjective claims.\n        *   **Other Flaws**:\n            *   **Incomplete/Contradictory**: The problem is self-contained. All parameters ($N$, $\\alpha$, amplitudes, radii, widths) are given for each case. The schemes and forcings are precisely defined. The domain is the unit square. Boundary conditions are homogeneous Dirichlet. No contradictions are apparent.\n            *   **Unrealistic**: The problem is a numerical experiment, so physical realism isn't the primary concern, but the setup is a standard model problem (Poisson equation) used to teach and test numerical methods. It is entirely feasible.\n            *   **Ill-Posed**: The linear systems resulting from these finite difference schemes on the Poisson equation are non-singular, so a unique solution exists. The metric $\\mathcal{V}$ is well-defined.\n            *   **Trivial/Pseudo-Profound**: The problem is not trivial. It requires assembling and solving a linear system for a 2D PDE, which involves careful indexing and matrix construction. It demonstrates a core concept in numerical PDEs (monotonicity and the DMP).\n            *   **Unverifiable**: The results are computationally verifiable.\n\n    *   **Step 3: Verdict and Action**: The problem is valid. I will proceed to solve it.\n\n2.  **Develop the Solution**:\n    *   **Core Task**: Implement a solver for the 2D Poisson equation $-\\Delta u = f$ on a uniform grid using finite differences. The solver needs to handle different stencils and different forcing functions.\n    *   **Domain and Grid**: The domain is $\\Omega = (0,1) \\times (0,1)$. The grid has $N$ nodes in each direction, so the mesh spacing is $h = 1/(N-1)$. The grid points are $(x_i, y_j) = (i h, j h)$ for $i, j \\in \\{0, 1, \\dots, N-1\\}$.\n    *   **Interior Nodes**: The unknowns are the values $u_{i,j}$ at the interior nodes, where $i, j \\in \\{1, 2, \\dots, N-2\\}$. The number of interior nodes is $(N-2) \\times (N-2)$.\n    *   **Linear System**: The discrete equation gives rise to a linear system $A \\mathbf{u} = \\mathbf{f}$.\n        *   The vector $\\mathbf{u}$ contains the unknown values $u_{i,j}$ at the interior nodes, flattened into a 1D array. A common mapping is the natural row-major ordering: the global index $k$ for the node $(i,j)$ is $k = (j-1)(N-2) + (i-1)$. Here, $i, j$ are the grid indices from $1$ to $N-2$.\n        *   The matrix $A$ represents the discrete operator. Its entries are determined by the stencil coefficients.\n        *   The vector $\\mathbf{f}$ contains the values of the forcing function $f_{i,j}$ at the interior nodes, also flattened using the same ordering.\n    *   **Assembling the Matrix A**:\n        *   The size of the matrix $A$ will be $(N-2)^2 \\times (N-2)^2$.\n        *   For each interior node $(i,j)$, which corresponds to a row $k = (j-1)(N-2) + (i-1)$ in the matrix, I need to place the stencil coefficients in the correct columns.\n        *   Let's analyze the stencil: $L_h u_{i,j} = \\sum_{p,q} a_{p,q} u_{i+p, j+q}$.\n        *   The equation at node $(i,j)$ is $L_h u_{i,j} = f_{i,j}$.\n        *   The diagonal entry of the matrix $A$ at row $k$ will be $A_{k,k} = a_{0,0}$.\n        *   The off-diagonal entries correspond to neighbors. For a neighbor $(i+p, j+q)$, its global index is $k' = ((j+q)-1)(N-2) + ((i+p)-1)$. The entry $A_{k,k'}$ will be $a_{p,q}$.\n        *   **Boundary Conditions**: Homogeneous Dirichlet, $u=0$ on the boundary. This means if a neighbor $(i+p,j+q)$ is on the boundary, its value $u_{i+p,j+q}$ is $0$. This term simply drops out of the equation for the interior node $(i,j)$. The assembly process implicitly handles this by only considering connections between interior nodes.\n        *   **Scheme $\\mathsf{S}_1$ (5-point stencil)**:\n            *   $(-\\Delta_h^{(5)} u)_{i,j} = \\frac{1}{h^2} (4 u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}) = f_{i,j}$.\n            *   So, the matrix $A$ has diagonal entries $A_{k,k} = 4/h^2$.\n            *   Off-diagonal entries for neighbors are $-1/h^2$.\n                *   For neighbor $(i-1,j)$, the global index is $k-1$. $A_{k, k-1} = -1/h^2$. (If $i>1$)\n                *   For neighbor $(i+1,j)$, the global index is $k+1$. $A_{k, k+1} = -1/h^2$. (If $i<N-2$)\n                *   For neighbor $(i,j-1)$, the global index is $k-(N-2)$. $A_{k, k-(N-2)} = -1/h^2$. (If $j>1$)\n                *   For neighbor $(i,j+1)$, the global index is $k+(N-2)$. $A_{k, k+(N-2)} = -1/h^2$. (If $j<N-2$)\n        *   **Scheme $\\mathsf{S}_2$ (modified 8-neighbor stencil)**:\n            *   $(\\mathcal{A}_h^{(\\alpha)} u)_{i,j} = \\frac{1}{h^2} [4 u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} + \\alpha (u_{i-1,j-1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i+1,j+1})] = f_{i,j}$.\n            *   Diagonal entries: $A_{k,k} = 4/h^2$.\n            *   Off-diagonal entries for cardinal neighbors: $-1/h^2$. Same as $\\mathsf{S}_1$.\n            *   Off-diagonal entries for diagonal neighbors: $+\\alpha/h^2$. These are the positive off-diagonals that break the M-matrix property.\n                *   Neighbor $(i-1,j-1)$: index $k-1-(N-2)$. $A_{k, k-1-(N-2)} = \\alpha/h^2$.\n                *   Neighbor $(i-1,j+1)$: index $k-1+(N-2)$. $A_{k, k-1+(N-2)} = \\alpha/h^2$.\n                *   Neighbor $(i+1,j-1)$: index $k+1-(N-2)$. $A_{k, k+1-(N-2)} = \\alpha/h^2$.\n                *   Neighbor $(i+1,j+1)$: index $k+1+(N-2)$. $A_{k, k+1+(N-2)} = \\alpha/h^2$.\n    *   **Using `scipy.sparse`**: Constructing the matrix `A` explicitly as a dense matrix will be inefficient for larger $N$. It's better to use a sparse matrix format, e.g., `scipy.sparse.lil_matrix` or `scipy.sparse.csc_matrix`. Using `scipy.sparse.diags` is even better for structured-grid Laplacians.\n        *   The standard 5-point stencil results in a block tridiagonal matrix.\n        *   The main diagonal corresponds to $4/h^2$.\n        *   The diagonals at offsets $\\pm 1$ correspond to $-1/h^2$ (with some zeros where rows wrap).\n        *   The diagonals at offsets $\\pm (N-2)$ correspond to $-1/h^2$.\n        *   The modified stencil adds diagonals at $\\pm ((N-2) \\pm 1)$.\n        *   Let's stick to a loop-based assembly into a `scipy.sparse.lil_matrix`, which is efficient for this kind of construction.\n\n    *   **Assembling the Forcing Vector `f`**:\n        *   The vector `f` has length $(N-2)^2$. It needs to be filled according to the definitions of $\\mathsf{F}_\\delta$ and $\\mathsf{F}_{\\mathrm{ring}}$.\n        *   **Forcing $\\mathsf{F}_\\delta$**:\n            *   Find the interior node $(i_c, j_c)$ closest to $(0.5, 0.5)$.\n            *   Grid coordinates are $x_i = i h, y_j = j h$.\n            *   We want $i h \\approx 0.5$ and $j h \\approx 0.5$.\n            *   $i \\approx 0.5/h = 0.5(N-1)$. $j \\approx 0.5(N-1)$.\n            *   So, $i_c = j_c = \\text{round}(0.5(N-1))$. Since $i,j$ are 1-based indices for interior points, they range from $1$ to $N-2$. The 0-based Fortran-style indices are $0, \\dots, N-1$. The problem statement uses $i,j$ for general mesh points, let's assume they are the 0-based indices from $0$ to $N-1$. Interior nodes are $i,j \\in \\{1, \\dots, N-2\\}$. Let's double-check the indexing.\n            *   The problem says \"interior node $(i,j)$\". Let's assume this means the indices $i,j$ for the full grid, so $i, j \\in \\{1, \\dots, N-2\\}$.\n            *   The center of the grid is at `(N-1)/2`. So the closest indices are `i_c = j_c = round((N-1)/2)`. For $N=33$, $(N-1)/2=16$. So $(i_c, j_c) = (16, 16)$. These are valid interior indices. For $N=25$, $(N-1)/2 = 12$. So $(i_c, j_c) = (12, 12)$.\n            *   Create an `f` vector of zeros. Find the global index $k_c$ for $(i_c, j_c)$. Set $f_{k_c} = A_\\delta / h^2$.\n        *   **Forcing $\\mathsf{F}_{\\mathrm{ring}}$**:\n            *   Iterate through all interior nodes $(i,j)$ for $i,j \\in \\{1, \\dots, N-2\\}$.\n            *   For each node, calculate its coordinates $(x_i, y_j) = (i h, j h)$.\n            *   Calculate the distance from the center: $r_{i,j} = \\sqrt{(x_i-0.5)^2 + (y_j-0.5)^2}$.\n            *   Check the condition: $|r_{i,j} - r_0| \\le w h$.\n            *   If the condition is met, find the global index $k$ for $(i,j)$ and set $f_k = A_{\\mathrm{ring}} / h^2$.\n    *   **Solving the System**:\n        *   Use `scipy.sparse.linalg.spsolve(A, f)` to find the solution vector `u_flat`.\n    *   **Calculating the Violation Magnitude $\\mathcal{V}$**:\n        *   The solution `u_flat` contains the values at interior nodes.\n        *   The violation is $\\mathcal{V} = \\max\\{0, -\\min(\\mathbf{u})\\}$.\n        *   So, find `min_u = u_flat.min()`.\n        *   `V = max(0, -min_u)`.\n    *   **Putting it all together**: I need a main function that takes the parameters for a case ($N$, scheme type, $\\alpha$, forcing type, forcing parameters) and returns $\\mathcal{V}$.\n        *   This function will:\n            1.  Calculate `h` and the number of interior points `n_int = (N-2)**2`.\n            2.  Assemble the sparse matrix `A` based on the scheme type.\n            3.  Assemble the forcing vector `f` based on the forcing type.\n            4.  Solve `A u = f` for `u`.\n            5.  Calculate and return `V`.\n    *   **Implementation details**:\n        *   A helper function to map 2D grid indices $(i,j)$ (where $i,j \\in \\{1,\\dots,N-2\\}$) to a 1D vector index $k$ (where $k \\in \\{0, \\dots, (N-2)^2-1\\}$) is useful. `k = (j-1)*(N-2) + (i-1)`.\n        *   The matrix `A` will be of size `(N-2)^2 x (N-2)^2`. A `lil_matrix` is good for assembly.\n        *   Main loop through test cases.\n        *   Collect results in a list.\n        *   Format the final output string.\n\nLet's walk through Case 2 ($N=33, \\mathsf{S}_2, \\alpha=0.9, \\mathsf{F}_\\delta, A_\\delta=10.0$) as a thought experiment.\n1.  $N=33$, $h = 1/32$.\n2.  Number of interior points per dimension: $N-2 = 31$. Total unknowns: $(N-2)^2 = 31^2 = 961$. Matrix size is $961 \\times 961$.\n3.  **Assemble `A`**:\n    *   Matrix `A` is `lil_matrix((961, 961))`.\n    *   `h2 = h*h`.\n    *   Iterate $j$ from $1$ to $31$, $i$ from $1$ to $31$.\n    *   `k = (j-1)*31 + (i-1)`.\n    *   `A[k,k] = 4 / h2`.\n    *   Neighbors (cardinal):\n        *   `i>1`: `A[k, k-1] = -1 / h2`.\n        *   `i<31`: `A[k, k+1] = -1 / h2`.\n        *   `j>1`: `A[k, k-31] = -1 / h2`.\n        *   `j<31`: `A[k, k+31] = -1 / h2`.\n    *   Neighbors (diagonal, with $\\alpha=0.9$):\n        *   `i>1, j>1`: `A[k, k-1-31] = 0.9 / h2`.\n        *   `i>1, j<31`: `A[k, k-1+31] = 0.9 / h2`.\n        *   `i<31, j>1`: `A[k, k+1-31] = 0.9 / h2`.\n        *   `i<31, j<31`: `A[k, k+1+31] = 0.9 / h2`.\n4.  **Assemble `f`**:\n    *   Forcing is $\\mathsf{F}_\\delta$ with $A_\\delta=10.0$.\n    *   `f` is a vector of zeros, size 961.\n    *   Center node: $i_c = j_c = \\text{round}(0.5 * (33-1)) = \\text{round}(16) = 16$.\n    *   Global index of center: $k_c = (16-1)*31 + (16-1) = 15*31 + 15 = 465 + 15 = 480$.\n    *   `f[k_c] = 10.0 / h2`.\n5.  **Solve**:\n    *   Convert `A` to CSR or CSC format for efficient solving: `A_csr = A.tocsr()`.\n    *   `u_flat = spsolve(A_csr, f)`.\n6.  **Calculate $\\mathcal{V}$**:\n    *   `min_u = np.min(u_flat)`.\n    *   `V = np.max([0, -min_u])`.\n    *   Since this is a non-monotone scheme, I expect `min_u` to be negative, so `V > 0`.\n\nNow let's walk through Case 4 ($N=41, \\mathsf{S}_2, \\alpha=0.7, \\mathsf{F}_{\\mathrm{ring}}, A_{\\mathrm{ring}}=40.0, r_0=0.28, w=3$).\n1.  $N=41, h = 1/40$.\n2.  Interior points per dim: $N-2=39$. Total unknowns: $39^2 = 1521$. Matrix size is $1521 \\times 1521$.\n3.  **Assemble `A`**: Same logic as before, just with $N-2=39$ and $\\alpha=0.7$.\n4.  **Assemble `f`**:\n    *   Forcing is $\\mathsf{F}_{\\mathrm{ring}}$ with $A_{\\mathrm{ring}}=40.0, r_0=0.3, w=3$.\n    *   `f` is a vector of zeros, size 1521.\n    *   `h2 = h*h`. `val = 40.0 / h2`.\n    *   Loop $j$ from $1$ to $39$, $i$ from $1$ to $39$.\n    *   `x_i = i * h`, `y_j = j * h`.\n    *   `r_ij = sqrt((x_i - 0.5)**2 + (y_j - 0.5)**2)`.\n    *   If `abs(r_ij - 0.3) <= 3 * h`:\n        *   `k = (j-1)*39 + (i-1)`.\n        *   `f[k] = val`.\n5.  **Solve and Calculate $\\mathcal{V}$**: Same logic as before.\n\nThe logic seems solid. I will structure the code with a main `solve_case` function that handles the setup for a given case and calls the core logic.\n\nThe problem defines the operators `(-Δ_h u)` and `(A_h u)` which are then set equal to `f`. So the linear system is `A u = f` where the matrix `A` is derived directly from the stencil coefficients.\nFor `S1`: `A_{k,k} = 4/h^2`, `A_{k, neighbor} = -1/h^2`. This is correct.\nFor `S2`: `A_{k,k} = 4/h^2`, `A_{k, cardinal} = -1/h^2`, `A_{k, diagonal} = +α/h^2`. This is also correct. The positive off-diagonals are what can violate the M-matrix condition. An M-matrix must have non-positive off-diagonals.\n\nThe definition of $\\mathcal{V}$ is $\\max\\{0, -\\min_{(i,j)\\text{ interior}} u_{i,j}\\}$. This is correctly translated to `max(0, -u.min())`.\n\nEverything appears correct and I'm ready to write the code. I'll create a single function `run_dmp_test` that encapsulates the logic for one test case. Then the `solve` function will call this for each of the four cases.\n\n```python\n# test_cases = [\n#     {'N': 33, 'scheme': 'S1', 'alpha': 0.0, 'forcing': 'F_delta', 'params': {'A_delta': 1.0}},\n#     {'N': 33, 'scheme': 'S2', 'alpha': 0.9, 'forcing': 'F_delta', 'params': {'A_delta': 10.0}},\n#     {'N': 25, 'scheme': 'S1', 'alpha': 0.0, 'forcing': 'F_ring', 'params': {'A_ring': 5.0, 'r0': 0.30, 'w': 2}},\n#     {'N': 41, 'scheme': 'S2', 'alpha': 0.7, 'forcing': 'F_ring', 'params': {'A_ring': 40.0, 'r0': 0.28, 'w': 3}},\n# ]\n```\nThis structure is good. My helper function `run_dmp_test` matches this design. I'll make sure the `solve` function in the final code is correctly implemented.\n\nThe output format is `[v1,v2,v3,v4]`. `','.join(map(str, results))` will achieve this.\nI'm confident in the plan. I will now write the full solution.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef run_dmp_test(N, scheme, alpha, forcing, forcing_params):\n    \"\"\"\n    Runs a single Discrete Maximum Principle test case by assembling and\n    solving the corresponding linear system.\n\n    Args:\n        N (int): Number of nodes in each spatial dimension.\n        scheme (str): 'S1' for the standard 5-point stencil, or 'S2' for\n                      the non-monotone 8-neighbor stencil.\n        alpha (float): Positive weight for the diagonal coupling in scheme S2.\n        forcing (str): 'F_delta' for a point source or 'F_ring' for a ring source.\n        forcing_params (dict): Parameters for the specified forcing function.\n\n    Returns:\n        float: The computed violation magnitude V.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    h2 = h * h\n    n_int = N - 2\n    n_unknowns = n_int * n_int\n\n    if n_unknowns == 0:\n        return 0.0\n\n    # Assemble the sparse matrix A representing the discrete operator.\n    # We use lil_matrix for efficient construction.\n    A = lil_matrix((n_unknowns, n_unknowns), dtype=np.float64)\n\n    for j_int in range(n_int):  # Interior y-index (0-based)\n        for i_int in range(n_int):  # Interior x-index (0-based)\n            # Map 2D interior indices (i_int, j_int) to a 1D vector index k.\n            k = j_int * n_int + i_int\n            \n            # Full grid indices (1-based from 1 to N-2)\n            i, j = i_int + 1, j_int + 1\n\n            # Diagonal entry from the (4 * u_ij) term\n            A[k, k] = 4.0 / h2\n            \n            # Off-diagonal entries for cardinal neighbors\n            # Connection to u_{i-1, j}\n            if i > 1:\n                A[k, k - 1] = -1.0 / h2\n            # Connection to u_{i+1, j}\n            if i < N - 2:\n                A[k, k + 1] = -1.0 / h2\n            # Connection to u_{i, j-1}\n            if j > 1:\n                A[k, k - n_int] = -1.0 / h2\n            # Connection to u_{i, j+1}\n            if j < N - 2:\n                A[k, k + n_int] = -1.0 / h2\n\n            # Additional off-diagonal entries for diagonal neighbors in Scheme S2\n            if scheme == 'S2':\n                # Connection to u_{i-1, j-1}\n                if i > 1 and j > 1:\n                    A[k, k - n_int - 1] = alpha / h2\n                # Connection to u_{i-1, j+1}\n                if i > 1 and j < N - 2:\n                    A[k, k + n_int - 1] = alpha / h2\n                # Connection to u_{i+1, j-1}\n                if i < N - 2 and j > 1:\n                    A[k, k - n_int + 1] = alpha / h2\n                # Connection to u_{i+1, j+1}\n                if i < N - 2 and j < N - 2:\n                    A[k, k + n_int + 1] = alpha / h2\n    \n    # Convert A to CSR format for efficient matrix-vector products and solving.\n    A_csr = A.tocsr()\n\n    # Assemble the forcing vector f.\n    f_vec = np.zeros(n_unknowns, dtype=np.float64)\n    \n    if forcing == 'F_delta':\n        A_delta = forcing_params['A_delta']\n        # Find the full-grid index of the node closest to the center (0.5, 0.5)\n        i_c = int(round(0.5 * (N - 1)))\n        j_c = int(round(0.5 * (N - 1)))\n        \n        # Convert to 0-based interior indices\n        ic_int, jc_int = i_c - 1, j_c - 1\n        \n        if 0 <= ic_int < n_int and 0 <= jc_int < n_int:\n            k_c = jc_int * n_int + ic_int\n            f_vec[k_c] = A_delta / h2\n\n    elif forcing == 'F_ring':\n        A_ring = forcing_params['A_ring']\n        r0 = forcing_params['r0']\n        w = forcing_params['w']\n        \n        for j_int in range(n_int):\n            for i_int in range(n_int):\n                i, j = i_int + 1, j_int + 1\n                x_i, y_j = i * h, j * h\n                \n                # Calculate distance from the domain center\n                r_ij = np.sqrt((x_i - 0.5)**2 + (y_j - 0.5)**2)\n                \n                # Check if the node lies within the ring\n                if abs(r_ij - r0) <= w * h:\n                    k = j_int * n_int + i_int\n                    f_vec[k] = A_ring / h2\n\n    # Solve the linear system A*u = f for the interior nodal values u.\n    u_flat = spsolve(A_csr, f_vec)\n    \n    # Compute the violation magnitude V = max(0, -min(u)).\n    min_u = np.min(u_flat) if u_flat.size > 0 else 0.0\n    V = max(0.0, -min_u)\n    \n    return V\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the discrete maximum principle test.\n    \"\"\"\n    test_cases = [\n        # Case 1: Monotone scheme with point source\n        {'N': 33, 'scheme': 'S1', 'alpha': 0.0, 'forcing': 'F_delta', \n         'params': {'A_delta': 1.0}},\n        # Case 2: Non-monotone scheme with point source\n        {'N': 33, 'scheme': 'S2', 'alpha': 0.9, 'forcing': 'F_delta', \n         'params': {'A_delta': 10.0}},\n        # Case 3: Monotone scheme with ring source\n        {'N': 25, 'scheme': 'S1', 'alpha': 0.0, 'forcing': 'F_ring', \n         'params': {'A_ring': 5.0, 'r0': 0.30, 'w': 2}},\n        # Case 4: Non-monotone scheme with ring source\n        {'N': 41, 'scheme': 'S2', 'alpha': 0.7, 'forcing': 'F_ring', \n         'params': {'A_ring': 40.0, 'r0': 0.28, 'w': 3}},\n    ]\n\n    results = []\n    for case in test_cases:\n        violation = run_dmp_test(\n            N=case['N'],\n            scheme=case['scheme'],\n            alpha=case['alpha'],\n            forcing=case['forcing'],\n            forcing_params=case['params']\n        )\n        results.append(violation)\n\n    # Format the results as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "For certain physical systems, particularly in fluid dynamics, the choice of grid structure is paramount for stability and accuracy. This practice introduces the Marker-and-Cell (MAC) staggered grid, a classic and powerful approach for incompressible flows, and delves into the algebraic structure of the discrete operators. By verifying that the discrete gradient and divergence operators are adjoints and that the projection step yields a perfectly divergence-free field, you will gain insight into how \"mimetic\" or structure-preserving discretizations maintain fundamental physical conservation laws at the discrete level .",
            "id": "3405983",
            "problem": "Consider a two-dimensional periodic square domain discretized by a Marker-and-Cell (MAC) staggered grid with $N_x$ cells in the $x$-direction, $N_y$ cells in the $y$-direction, physical domain lengths $L_x$ and $L_y$, and corresponding grid spacings $d_x = L_x / N_x$ and $d_y = L_y / N_y$. Let a scalar field $p$ be stored at cell centers and the velocity field $\\boldsymbol{u} = (u_x, u_y)$ be stored at cell faces, with $u_x$ located at the centers of vertical faces and $u_y$ located at the centers of horizontal faces. Periodic boundary conditions hold in both directions.\n\nDefine the discrete gradient operator $\\mathcal{G}$ mapping cell-centered scalars to face-centered components by forward differences,\n$$\n\\left(\\mathcal{G}_x p\\right)_{i,j} = \\frac{p_{i+1,j} - p_{i,j}}{d_x}, \\quad\n\\left(\\mathcal{G}_y p\\right)_{i,j} = \\frac{p_{i,j+1} - p_{i,j}}{d_y},\n$$\nwhere indices are wrapped periodically in both directions. Define the discrete divergence operator $\\mathcal{D}$ mapping face-centered velocities to a cell-centered scalar by backward differences,\n$$\n\\left(\\mathcal{D}\\boldsymbol{u}\\right)_{i,j} = \\frac{u_{x, i,j} - u_{x, i-1,j}}{d_x} + \\frac{u_{y, i,j} - u_{y, i,j-1}}{d_y},\n$$\nagain with periodic wrapping. Let the discrete Laplacian be defined by the composition $\\mathcal{L} = \\mathcal{D}\\mathcal{G}$, which yields the standard second-order periodic discrete Laplacian on cell centers.\n\nEquip the space of cell-centered scalars with the discrete inner product\n$$\n\\langle p, q \\rangle_c = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} p_{i,j} q_{i,j} \\, d_x d_y,\n$$\nand the space of face-centered velocities with\n$$\n\\langle \\boldsymbol{u}, \\boldsymbol{v} \\rangle_f = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left[u_{x,i,j} v_{x,i,j} + u_{y,i,j} v_{y,i,j}\\right] \\, d_x d_y.\n$$\n\nYour task is to implement a discrete experiment on this MAC grid to verify two properties:\n\n1. Projection to divergence-free: Given an intermediate velocity $\\boldsymbol{u}^\\star$, compute a cell-centered pressure $p$ by solving the periodic Poisson equation\n$$\n\\mathcal{L} p = \\frac{1}{\\Delta t} \\, \\mathcal{D}\\boldsymbol{u}^\\star,\n$$\nwith the constraint that the mean of $p$ is exactly zero (to select a unique solution in the periodic setting). Then form the projected velocity\n$$\n\\boldsymbol{u} = \\boldsymbol{u}^\\star - \\Delta t \\, \\mathcal{G}p,\n$$\nand numerically verify that the discrete divergence $\\mathcal{D}\\boldsymbol{u}$ is identically zero to machine precision by reporting the maximum absolute value over all cells.\n\n2. Discrete adjointness: Verify that $\\mathcal{G}$ and $\\mathcal{D}$ are adjoint operators under the given inner products by computing, for random $p$ and $\\boldsymbol{u}$,\n$$\n\\epsilon = \\left| \\langle p, \\mathcal{D}\\boldsymbol{u} \\rangle_c + \\langle \\mathcal{G}p, \\boldsymbol{u} \\rangle_f \\right|,\n$$\nwhich should be zero up to round-off error due to discrete summation-by-parts under periodic boundary conditions.\n\nUse the Fast Fourier Transform (FFT) to solve the periodic Poisson equation on the cell-centered grid. The eigenvalues of the periodic discrete Laplacian acting on cell centers are\n$$\n\\lambda_{k,\\ell} = \\frac{2 \\left(\\cos\\left(\\frac{2\\pi k}{N_x}\\right) - 1\\right)}{d_x^2} + \\frac{2 \\left(\\cos\\left(\\frac{2\\pi \\ell}{N_y}\\right) - 1\\right)}{d_y^2}, \\quad k \\in \\{0,\\dots,N_x-1\\}, \\ \\ell \\in \\{0,\\dots,N_y-1\\}.\n$$\nUse these to construct the spectral solution, setting the zero mode $\\lambda_{0,0}$ to zero and enforcing zero mean for $p$.\n\nImplement the program to run the following test suite. For each case, generate $\\boldsymbol{u}^\\star$ with a reproducible random seed and independently generate $p$ and $\\boldsymbol{u}$ for the adjointness test with another seed. Report two floats per case: the maximum absolute divergence after projection and the adjointness defect $\\epsilon$.\n\nTest suite:\n- Case A (happy path): $N_x = 32$, $N_y = 20$, $L_x = 1$, $L_y = 1$, $\\Delta t = 0.5$, seed for $\\boldsymbol{u}^\\star$ is $7$, seed for adjointness fields is $13$.\n- Case B (small grid boundary condition stress test): $N_x = 2$, $N_y = 3$, $L_x = 1$, $L_y = 1$, $\\Delta t = 1.3$, seed for $\\boldsymbol{u}^\\star$ is $3$, seed for adjointness fields is $5$.\n- Case C (anisotropic spacings): $N_x = 16$, $N_y = 16$, $L_x = 2$, $L_y = 1$, $\\Delta t = 0.75$, seed for $\\boldsymbol{u}^\\star$ is $101$, seed for adjointness fields is $202$.\n- Case D (non-square, larger grid): $N_x = 17$, $N_y = 29$, $L_x = 3$, $L_y = 2$, $\\Delta t = 2.0$, seed for $\\boldsymbol{u}^\\star$ is $42$, seed for adjointness fields is $99$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to one test case and is itself a two-element list of floats in the order $[\\max|\\mathcal{D}\\boldsymbol{u}|, \\epsilon]$. For example, the output format must be exactly like\n$$\n\\left[ [r_1, e_1], [r_2, e_2], [r_3, e_3], [r_4, e_4] \\right],\n$$\nwith floats printed in standard Python formatting and no additional text. No physical units, angle units, or percentages are required; report raw numeric values.",
            "solution": "The problem presents a verification task for a numerical method commonly used in computational fluid dynamics, specifically the projection method for solving the incompressible Navier-Stokes equations on a two-dimensional periodic domain. The discretization employs a Marker-and-Cell (MAC) staggered grid. The task is to numerically verify two fundamental properties of the discrete operators: the efficacy of the projection step in enforcing the divergence-free condition and the adjoint relationship between the discrete gradient and divergence operators.\n\nFirst, we establish the discrete framework. The domain is a rectangle of size $L_x \\times L_y$, discretized into $N_x \\times N_y$ cells, yielding grid spacings $d_x = L_x / N_x$ and $d_y = L_y / N_y$. On this grid, the scalar pressure field $p$ is located at cell centers $(i,j)$, while the velocity components $u_x$ and $u_y$ are staggered, located at the centers of vertical faces $(i+1/2, j)$ and horizontal faces $(i, j+1/2)$, respectively. All field indices, such as $p_{i,j}$, $u_{x,i,j}$, and $u_{y,i,j}$, range from $i \\in \\{0, \\dots, N_x-1\\}$ and $j \\in \\{0, \\dots, N_y-1\\}$.\n\nThe discrete gradient operator, $\\mathcal{G}$, maps the cell-centered scalar field $p$ to face-centered vector components. It is defined using forward differences, which is natural given the staggered grid layout:\n$$\n\\left(\\mathcal{G}_x p\\right)_{i,j} = \\frac{p_{i+1,j} - p_{i,j}}{d_x}\n$$\n$$\n\\left(\\mathcal{G}_y p\\right)_{i,j} = \\frac{p_{i,j+1} - p_{i,j}}{d_y}\n$$\nDue to the periodic boundary conditions, indices are wrapped, e.g., $p_{N_x,j} = p_{0,j}$.\n\nThe discrete divergence operator, $\\mathcal{D}$, maps the face-centered velocity field $\\boldsymbol{u}$ to a cell-centered scalar. It is defined using backward differences, a choice which, in conjunction with the forward-difference gradient, is crucial for the mathematical properties of the scheme:\n$$\n\\left(\\mathcal{D}\\boldsymbol{u}\\right)_{i,j} = \\frac{u_{x, i,j} - u_{x, i-1,j}}{d_x} + \\frac{u_{y, i,j} - u_{y, i,j-1}}{d_y}\n$$\nAgain, indices are wrapped periodically. The composition of these operators defines the discrete Laplacian, $\\mathcal{L} = \\mathcal{D}\\mathcal{G}$. Applying these definitions yields the standard $5$-point stencil for the Laplacian on a Cartesian grid:\n$$\n(\\mathcal{L}p)_{i,j} = \\frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{d_x^2} + \\frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{d_y^2}\n$$\n\nThe first task is to verify the projection step. Given an intermediate velocity field $\\boldsymbol{u}^\\star$ which is not necessarily divergence-free, the projection method computes a pressure correction $p$ by solving a Poisson equation and then updates the velocity.\nThe Poisson equation for pressure is:\n$$\n\\mathcal{L} p = \\frac{1}{\\Delta t} \\mathcal{D}\\boldsymbol{u}^\\star\n$$\nFor a periodic domain, the operator $\\mathcal{L}$ has a null space consisting of constant fields. A solution exists only if the right-hand side is orthogonal to this null space, which means its integral (or sum, in the discrete case) must be zero. The sum of $(\\mathcal{D}\\boldsymbol{u}^\\star)_{i,j}$ over all cells forms a telescoping sum in each direction due to periodicity, and is thus identically zero. This ensures the existence of a solution for $p$. To obtain a unique solution, we enforce the constraint that the mean of $p$ is zero.\n\nThe solution $p$ is found efficiently using the Fast Fourier Transform (FFT). In Fourier space, the discrete Laplacian becomes a simple multiplication by its eigenvalues, $\\lambda_{k,\\ell}$. The equation becomes $\\lambda_{k,\\ell} \\hat{p}_{k,\\ell} = \\frac{1}{\\Delta t} (\\widehat{\\mathcal{D}\\boldsymbol{u}^\\star})_{k,\\ell}$. Thus, the Fourier coefficients of the pressure are $\\hat{p}_{k,\\ell} = \\frac{1}{\\Delta t \\cdot \\lambda_{k,\\ell}} (\\widehat{\\mathcal{D}\\boldsymbol{u}^\\star})_{k,\\ell}$. For the zero-frequency mode $(k,\\ell)=(0,0)$, $\\lambda_{0,0}=0$. The zero-mean constraint on $p$ implies $\\hat{p}_{0,0}=0$. For all other modes, the division is well-defined. After computing all $\\hat{p}_{k,\\ell}$, an inverse FFT yields the pressure field $p$.\n\nOnce $p$ is known, the projected, divergence-free velocity field $\\boldsymbol{u}$ is computed as:\n$$\n\\boldsymbol{u} = \\boldsymbol{u}^\\star - \\Delta t \\, \\mathcal{G}p\n$$\nTo verify the method, we compute the divergence of the new field, $\\mathcal{D}\\boldsymbol{u}$:\n$$\n\\mathcal{D}\\boldsymbol{u} = \\mathcal{D}(\\boldsymbol{u}^\\star - \\Delta t \\, \\mathcal{G}p) = \\mathcal{D}\\boldsymbol{u}^\\star - \\Delta t \\, \\mathcal{D}\\mathcal{G}p = \\mathcal{D}\\boldsymbol{u}^\\star - \\Delta t \\, \\mathcal{L}p\n$$\nSubstituting the Poisson equation $\\mathcal{L}p = \\frac{1}{\\Delta t}\\mathcal{D}\\boldsymbol{u}^\\star$, we find:\n$$\n\\mathcal{D}\\boldsymbol{u} = \\mathcal{D}\\boldsymbol{u}^\\star - \\Delta t \\left(\\frac{1}{\\Delta t} \\mathcal{D}\\boldsymbol{u}^\\star\\right) = 0\n$$\nThis identity should hold to machine precision. We will report the maximum absolute value of $\\mathcal{D}\\boldsymbol{u}$ across all cells.\n\nThe second task is to verify the discrete adjoint relationship between $\\mathcal{G}$ and $\\mathcal{D}$. The operators are adjoints if $\\langle p, \\mathcal{D}\\boldsymbol{u} \\rangle_c = \\langle -\\mathcal{G}p, \\boldsymbol{u} \\rangle_f$, or $\\langle p, \\mathcal{D}\\boldsymbol{u} \\rangle_c + \\langle \\mathcal{G}p, \\boldsymbol{u} \\rangle_f = 0$. This property is a discrete analogue of the integration by parts formula $\\int p (\\nabla \\cdot \\boldsymbol{u}) \\, dV = -\\int (\\nabla p) \\cdot \\boldsymbol{u} \\, dV$ for periodic domains. We can prove this relationship via summation by parts. Consider the term involving the $x$-component in $\\langle \\mathcal{G}p, \\boldsymbol{u} \\rangle_f$:\n$$\n\\sum_{i,j} (\\mathcal{G}_x p)_{i,j} u_{x,i,j} d_x d_y = \\sum_{i,j} \\frac{p_{i+1,j} - p_{i,j}}{d_x} u_{x,i,j} d_x d_y = \\sum_{i,j} (p_{i+1,j} - p_{i,j}) u_{x,i,j} d_y d_x\n$$\nBy re-indexing the sum (shifting $i \\to i-1$ in the first term) and using periodicity, this becomes:\n$$\n\\sum_{i,j} p_{i,j} u_{x,i-1,j} d_y d_x - \\sum_{i,j} p_{i,j} u_{x,i,j} d_y d_x = \\sum_{i,j} p_{i,j} (u_{x,i-1,j} - u_{x,i,j}) d_y d_x\n$$\nCombining this with the similar term for the $y$-component, we get:\n$$\n\\langle \\mathcal{G}p, \\boldsymbol{u} \\rangle_f = \\sum_{i,j} p_{i,j} \\left( \\frac{u_{x,i-1,j} - u_{x,i,j}}{d_x} + \\frac{u_{y,i,j-1} - u_{y,i,j}}{d_y} \\right) d_x d_y = - \\langle p, \\mathcal{D}\\boldsymbol{u} \\rangle_c\n$$\nThus, the quantity $\\epsilon = \\left| \\langle p, \\mathcal{D}\\boldsymbol{u} \\rangle_c + \\langle \\mathcal{G}p, \\boldsymbol{u} \\rangle_f \\right|$ for randomly generated fields should be zero up to floating-point round-off error.\n\nThe following Python implementation will execute these two verification tests for each specified case in the test suite.",
            "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path)\n        (32, 20, 1.0, 1.0, 0.5, 7, 13),\n        # Case B (small grid boundary condition stress test)\n        (2, 3, 1.0, 1.0, 1.3, 3, 5),\n        # Case C (anisotropic spacings)\n        (16, 16, 2.0, 1.0, 0.75, 101, 202),\n        # Case D (non-square, larger grid)\n        (17, 29, 3.0, 2.0, 2.0, 42, 99),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        res_tuple = run_case(*params)\n        all_results.append(res_tuple)\n    \n    # Format the output exactly as specified.\n    str_results = [f\"[{r}, {e}]\" for r, e in all_results]\n    print(f\"[{','.join(str_results)}]\")\n\ndef run_case(Nx, Ny, Lx, Ly, dt, seed_u_star, seed_adjoint):\n    \"\"\"\n    Runs the two verification experiments for a single test case.\n    \n    Returns:\n        A tuple (max_abs_div, epsilon) containing the results.\n    \"\"\"\n    dx = Lx / Nx\n    dy = Ly / Ny\n    \n    # Define discrete operators\n    def grad(p_cc):\n        \"\"\"Computes discrete gradient of a cell-centered scalar.\"\"\"\n        gpx_fc = (np.roll(p_cc, -1, axis=1) - p_cc) / dx\n        gpy_fc = (np.roll(p_cc, -1, axis=0) - p_cc) / dy\n        return gpx_fc, gpy_fc\n\n    def div(ux_fc, uy_fc):\n        \"\"\"Computes discrete divergence of a face-centered vector.\"\"\"\n        div_cc = (ux_fc - np.roll(ux_fc, 1, axis=1)) / dx + \\\n                 (uy_fc - np.roll(uy_fc, 1, axis=0)) / dy\n        return div_cc\n\n    def poisson_solver_fft(rhs_cc):\n        \"\"\"Solves the periodic Poisson equation using FFTs.\"\"\"\n        # 1. Fourier transform the RHS\n        rhs_hat = fft.fft2(rhs_cc)\n        \n        # 2. Construct eigenvalues of the discrete Laplacian\n        k = fft.fftfreq(Nx) * Nx\n        l = fft.fftfreq(Ny) * Ny\n        kk, ll = np.meshgrid(k, l)\n        \n        lambda_kl = (2 * (np.cos(2 * np.pi * kk / Nx) - 1) / dx**2 +\n                     2 * (np.cos(2 * np.pi * ll / Ny) - 1) / dy**2)\n        \n        # 3. Solve in Fourier space, handling the zero-frequency mode\n        p_hat = np.zeros_like(rhs_hat, dtype=np.complex128)\n        # Avoid division by zero\n        non_zero_modes = lambda_kl != 0\n        p_hat[non_zero_modes] = rhs_hat[non_zero_modes] / lambda_kl[non_zero_modes]\n        # The mean of p is set to zero by setting the (0,0) Fourier mode to 0\n        p_hat[0, 0] = 0.0\n\n        # 4. Inverse Fourier transform to get the solution\n        p_cc = fft.ifft2(p_hat).real\n        return p_cc\n\n    # --- Task 1: Projection to divergence-free ---\n    rng = np.random.default_rng(seed_u_star)\n    u_star_x = rng.random((Ny, Nx))\n    u_star_y = rng.random((Ny, Nx))\n    \n    # Compute divergence of the intermediate velocity\n    div_u_star = div(u_star_x, u_star_y)\n    \n    # Solve the Poisson equation for pressure\n    rhs_p = div_u_star / dt\n    p_corr = poisson_solver_fft(rhs_p)\n    \n    # Compute the pressure gradient\n    gp_x, gp_y = grad(p_corr)\n    \n    # Project the velocity to be divergence-free\n    u_final_x = u_star_x - dt * gp_x\n    u_final_y = u_star_y - dt * gp_y\n    \n    # Verify the divergence of the final velocity\n    div_u_final = div(u_final_x, u_final_y)\n    max_abs_div = np.max(np.abs(div_u_final))\n\n    # --- Task 2: Discrete adjointness ---\n    rng = np.random.default_rng(seed_adjoint)\n    p_rand = rng.random((Ny, Nx))\n    u_rand_x = rng.random((Ny, Nx))\n    u_rand_y = rng.random((Ny, Nx))\n\n    # Define inner products\n    cell_vol = dx * dy\n    def inner_c(p, q):\n        return np.sum(p * q) * cell_vol\n    \n    def inner_f(ux, uy, vx, vy):\n        return (np.sum(ux * vx) + np.sum(uy * vy)) * cell_vol\n\n    # Compute <p, D(u)>_c\n    div_u_rand = div(u_rand_x, u_rand_y)\n    term_c = inner_c(p_rand, div_u_rand)\n    \n    # Compute <G(p), u>_f\n    gp_rand_x, gp_rand_y = grad(p_rand)\n    term_f = inner_f(gp_rand_x, gp_rand_y, u_rand_x, u_rand_y)\n    \n    # Compute the adjointness defect epsilon\n    epsilon = np.abs(term_c + term_f)\n\n    return max_abs_div, epsilon\n\nsolve()\n\n```"
        }
    ]
}