{
    "hands_on_practices": [
        {
            "introduction": "着手处理稀疏矩阵的第一步是理解其内存占用。本练习将引导您对压缩稀疏行（CSR）格式进行基础分析，从基本原理出发推导其存储成本。通过将 CSR 格式存储结构化三对角矩阵的成本与专门的带状存储方案进行比较，您将具体理解通用格式与高度优化的、感知结构的格式之间的权衡。",
            "id": "3445552",
            "problem": "设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个稀疏矩阵，它由均匀网格上使用标准三点差分格式对一维二阶线性偏微分方程进行有限差分法离散化而产生。两种广泛使用的稀疏矩阵存储格式是压缩稀疏行（CSR）和压缩稀疏列（CSC）。假设所有存储的值都是 $64$ 位浮点数，所有索引和指针数组都是 $64$ 位有符号整数。在此设置中，每个存储的浮点值占用 $8$ 字节，每个存储的索引占用 $8$ 字节，任何指针数组的每个条目也占用 $8$ 字节。\n\na) 仅使用数据结构的核心定义，不借助任何预先记忆的公式，定义压缩稀疏行（CSR）和压缩稀疏列（CSC）存储格式，并精确说明它们包含哪些数组以及每个数组代表什么。\n\nb) 考虑一个由上述差分格式和狄利克雷（Dirichlet）边界条件生成的 $n \\times n$ 三对角矩阵，该矩阵恰好有 $3n - 2$ 个非零元。从第一性原理出发，推导以CSR格式存储此矩阵所需的总内存占用（以字节为单位），并分别推导以一种专门的三对角带状存储格式（仅存储下、主、上三个对角线，不含任何索引数组）存储它所需的总内存占用（以字节为单位）。\n\nc) 现在考虑一个具有 $m$ 个非零元且无其他附加结构的通用稀疏 $n \\times n$ 矩阵。在相同的数据大小假设下，推导以CSR（或等效的CSC）格式存储此矩阵所需的总内存占用（以字节为单位）。\n\n将你的最终答案表示为一个包含三个条目的行向量，顺序如下：\n- b)部分中三对角矩阵的CSR字节数，\n- c)部分中具有 $m$ 个非零元的通用稀疏矩阵的CSR字节数，\n- b)部分中三对角矩阵的CSR字节数与专门的三对角带状存储字节数的比率。\n\n无需进行数值四舍五入。最终答案中不要包含单位；这些条目分别对应于字节或无单位的比率。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n### 第1步：提取已知条件\n- 矩阵为 $A \\in \\mathbb{R}^{n \\times n}$ 且是稀疏的。\n- 它由均匀网格上的标准三点差分格式对一维二阶线性偏微分方程进行有限差分法离散化而产生。\n- 考虑了两种存储格式：压缩稀疏行（CSR）和压缩稀疏列（CSC）。\n- 存储的值是64位浮点数，相当于8字节。\n- 索引和指针数组条目是64位有符号整数，相当于8字节。\n- a)部分要求定义CSR和CSC格式。\n- b)部分考虑一个特殊情况：一个具有狄利克雷（Dirichlet）边界条件的 $n \\times n$ 三对角矩阵，它恰好有 $3n - 2$ 个非零元。它要求计算CSR格式的内存占用（以字节为单位）以及专门的三对角带状存储格式（仅存储三个对角线，不含索引数组）的内存占用。\n- c)部分考虑一个具有 $m$ 个非零元且无其他假设结构的通用稀疏 $n \\times n$ 矩阵。它要求计算CSR格式的内存占用（以字节为单位）。\n- 最终答案被指定为一个包含三个条目的行向量。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据：**该问题牢固地植根于数值线性代数和科学计算。CSR、CSC和带状存储是处理由偏微分方程（PDE）离散化产生的稀疏矩阵的标准、定义明确的数据结构。所有陈述都是事实正确的。\n- **适定性：**该问题是适定的。它提供了所有必要的信息（矩阵维度、非零元数量、数据类型大小），以推导出以 $n$ 和 $m$ 为符号表达式的所需内存占用。问题明确无歧义，并能导出唯一、可验证的答案。\n- **客观性：**语言技术性强、精确，不含任何主观或基于观点的内容。\n\n### 第3步：结论与行动\n该问题在科学上是合理的、适定的和客观的，没有明显缺陷。因此，它被判定为**有效**。我们可以继续构建解决方案。\n\n### a) 部分 CSR 和 CSC 格式的定义\n\n压缩稀疏行（CSR）和压缩稀疏列（CSC）格式是存储稀疏矩阵的标准方法，可以避免存储零元素。它们的定义基于三个数组。设 $A$ 是一个有 $nnz$ 个非零元的 $n \\times n$ 矩阵。\n\n**压缩稀疏行（CSR）格式：**\n此格式逐行存储矩阵。它由三个数组组成：\n1.  一个 `values` 数组，我们称之为 $V$，长度为 $nnz$。此数组按行主序（即遍历第0行，然后是第1行，依此类推）存储矩阵 $A$ 的非零元素。单行内的值可以按任何顺序存储，但通常按其列索引的递增顺序存储。每个元素都是一个浮点数。\n2.  一个 `column_indices` 数组，我们称之为 $J$，长度为 $nnz$。对于 $V$ 中的每个元素，此数组存储其在原始矩阵 $A$ 中对应的列索引。也就是说，如果 $V[k] = A_{i,j}$，那么 $J[k] = j$。每个元素都是一个整数。\n3.  一个 `row_pointers` 数组，我们称之为 $R_p$，长度为 $n+1$。此数组存储 $V$ 数组中每一行起始的位置。具体来说，$R_p[i]$ 是第 $i$ 行第一个非零元素在 $V$（和 $J$）中的索引。第 $i$ 行的非零元素数量由 $R_p[i+1] - R_p[i]$ 给出。第一个元素 $R_p[0]$ 总是 $0$，最后一个元素 $R_p[n]$ 总是 $nnz$。每个元素都是一个整数。\n\n**压缩稀疏列（CSC）格式：**\n此格式与CSR类似，但逐列存储矩阵。它等同于矩阵转置 $A^T$ 的CSR表示。它也由三个数组组成：\n1.  一个 `values` 数组 $V$，长度为 $nnz$，按列主序存储 $A$ 的非零元素。\n2.  一个 `row_indices` 数组，我们称之为 $I$，长度为 $nnz$。对于 $V$ 中的每个元素，此数组存储其对应的行索引。也就是说，如果 $V[k] = A_{i,j}$，那么 $I[k] = i$。\n3.  一个 `column_pointers` 数组，我们称之为 $C_p$，长度为 $n+1$。$C_p[j]$ 是第 $j$ 列第一个非零元素在 $V$ 中的索引。第 $j$ 列的非零元素数量是 $C_p[j+1] - C_p[j]$。$C_p[0]$ 总是 $0$，而 $C_p[n]$ 总是 $nnz$。\n\n### b) 部分 三对角矩阵的内存占用\n\n给定一个 $n \\times n$ 的三对角矩阵，恰好有 $m = 3n - 2$ 个非零元。每个存储的值的大小为8字节，每个索引或指针的大小为8字节。\n\n**CSR格式内存计算：**\n我们计算CSR格式中三个数组所需的内存。非零元的数量是 $nnz = 3n - 2$。\n1.  `values` 数组（$V$）存储所有 $3n - 2$ 个非零浮点值。\n    $V$ 的内存 = $(3n - 2) \\text{ 个值} \\times 8 \\frac{\\text{字节}}{\\text{值}} = 8(3n - 2)$ 字节。\n2.  `column_indices` 数组（$J$）存储 $3n - 2$ 个非零值中每一个的列索引。\n    $J$ 的内存 = $(3n - 2) \\text{ 个索引} \\times 8 \\frac{\\text{字节}}{\\text{索引}} = 8(3n - 2)$ 字节。\n3.  `row_pointers` 数组（$R_p$）的长度为 $n+1$。\n    $R_p$ 的内存 = $(n + 1) \\text{ 个指针} \\times 8 \\frac{\\text{字节}}{\\text{指针}} = 8(n + 1)$ 字节。\n\nCSR格式的总内存占用 $M_{CSR,tridi}$ 是这三部分的总和：\n$$M_{CSR,tridi} = 8(3n - 2) + 8(3n - 2) + 8(n + 1)$$\n$$M_{CSR,tridi} = 16(3n - 2) + 8(n + 1)$$\n$$M_{CSR,tridi} = 48n - 32 + 8n + 8$$\n$$M_{CSR,tridi} = 56n - 24 \\text{ 字节}$$\n\n**专门的三对角带状存储内存计算：**\n这种格式只存储三个非零对角线。对于一个 $n \\times n$ 矩阵，这些是主对角线（长度为 $n$）、下对角线（长度为 $n-1$）和上对角线（长度为 $n-1$）。\n需要存储的元素总数为 $n + (n-1) + (n-1) = 3n - 2$。这与给定的非零元数量相符。\n问题陈述指出这种格式不使用索引数组。因此，我们只存储这 $3n-2$ 个浮点值。\n这种专门的带状存储的总内存占用 $M_{band}$ 是：\n$$M_{band} = (3n - 2) \\text{ 个值} \\times 8 \\frac{\\text{字节}}{\\text{值}} = 8(3n - 2) \\text{ 字节}$$\n$$M_{band} = 24n - 16 \\text{ 字节}$$\n\n### c) 部分 通用稀疏矩阵的内存占用\n\n我们考虑一个具有 $m$ 个非零元的通用 $n \\times n$ 稀疏矩阵。\n\n**CSR格式内存计算：**\n逻辑与三对角矩阵的情况相同，但我们使用通用符号 $m$ 表示非零元的数量（$nnz = m$）。\n1.  `values` 数组（$V$）存储 $m$ 个非零浮点值。\n    $V$ 的内存 = $m \\times 8$ 字节。\n2.  `column_indices` 数组（$J$）存储 $m$ 个列索引。\n    $J$ 的内存 = $m \\times 8$ 字节。\n3.  `row_pointers` 数组（$R_p$）的长度为 $n+1$。\n    $R_p$ 的内存 = $(n + 1) \\times 8$ 字节。\n\n一个通用稀疏矩阵在CSR格式下的总内存占用 $M_{CSR,gen}$ 是其总和：\n$$M_{CSR,gen} = 8m + 8m + 8(n + 1)$$\n$$M_{CSR,gen} = 16m + 8n + 8 \\text{ 字节}$$\n注意，CSC格式的内存占用是相同的，因为它也有两个长度为 $m$ 的数组和一个长度为 $n+1$ 的数组。\n\n### 最终答案组合\n\n我们被要求提供一个包含三个条目的行向量：\n1.  三对角矩阵的CSR字节数：$M_{CSR,tridi} = 56n - 24$。\n2.  具有 $m$ 个非零元的通用稀疏矩阵的CSR字节数：$M_{CSR,gen} = 16m + 8n + 8$。\n3.  三对角矩阵的CSR字节数与专门的带状存储字节数的比率：\n    $$ \\text{比率} = \\frac{M_{CSR,tridi}}{M_{band}} = \\frac{56n - 24}{24n - 16} $$\n    我们可以通过提取公因子 $8$ 来简化这个表达式：\n    $$ \\text{比率} = \\frac{8(7n - 3)}{8(3n - 2)} = \\frac{7n - 3}{3n - 2} $$\n最终答案是包含这三个表达式的行向量。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 56n - 24  & 16m + 8n + 8  & \\frac{7n - 3}{3n - 2} \\end{pmatrix} } $$"
        },
        {
            "introduction": "除了静态内存成本，存储格式的真正考验在于其在关键运算（如稀疏矩阵向量乘法，SpMV）中的性能。本实践引入了一个简化的性能模型（类似于 roofline 模型）来估算运行时间。通过分析 CSR 和 COO 格式独特的内存访问模式，您将学会预测一个运算是由计算能力限制还是由内存带宽限制，这是高性能计算中的一项关键技能。",
            "id": "3271435",
            "problem": "要求您设计并实现一个程序，来预测稀疏矩阵向量乘法在两种常见稀疏存储格式下的性能：压缩稀疏行（Compressed Sparse Row, CSR）和坐标列表（Coordinate List, COO）。此任务侧重于基础科学计算原理、计算成本和内存流量建模，以及应用性能模型来估算运行时间。您的程序必须为给定的测试套件计算预测的运行时间，并以指定的单一格式输出结果。\n\n从以下基本依据开始：\n\n- 稀疏矩阵向量乘法计算 $y = A x$，其中 $A$ 是稀疏矩阵。对于每个非零元素 $a_{ij}$，计算涉及一次乘法和一次加法，即每个非零元总共有 $2$ 次浮点运算。\n- 在一个与roofline方法一致的简单性能模型中，总时间 $T$ 的估算公式为\n$$\nT = \\max\\left(\\frac{\\text{FLOPs}}{P_{\\mathrm{peak}}}, \\frac{\\text{Bytes}}{B_{\\mathrm{peak}}}\\right),\n$$\n其中 $\\text{FLOPs}$ 是浮点运算次数，$P_{\\mathrm{peak}}$ 是峰值浮点吞吐量（单位为 $\\mathrm{FLOP/s}$），$\\text{Bytes}$ 是总数据流量（单位为字节），$B_{\\mathrm{peak}}$ 是峰值内存带宽（单位为 $\\mathrm{byte/s}$）。\n- 对于CSR和COO格式，在流式处理和COO非排序累加的假设下（即由于缓存而没有向量元素的重用，并且COO直接为每个非零元累加到 $y$ 中），总移动字节数可以从算法循环和数据结构中推导出来：\n  - CSR格式存储了值、列索引和一个行指针数组。其实现遍历行，在寄存器中累加 $y_i$，并在每行结束后写回一次。移动的字节数建模为\n  $$\n  \\text{Bytes}_{\\mathrm{CSR}} = \\underbrace{n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{值}} + \\underbrace{n n z \\cdot i_{\\mathrm{bytes}}}_{\\text{列索引}} + \\underbrace{(n+1) \\cdot i_{\\mathrm{bytes}}}_{\\text{行指针}} + \\underbrace{n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } x} + \\underbrace{n \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } y \\text{ 存储}}.\n  $$\n  - COO格式存储了值、行索引和列索引的数组。其实现直接累加到 $y$ 中，为每个非零元读取和写入 $y$。移动的字节数建模为\n  $$\n  \\text{Bytes}_{\\mathrm{COO}} = \\underbrace{n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{值}} + \\underbrace{n n z \\cdot i_{\\mathrm{bytes}}}_{\\text{列索引}} + \\underbrace{n n z \\cdot i_{\\mathrm{bytes}}}_{\\text{行索引}} + \\underbrace{n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } x} + \\underbrace{2 \\cdot n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } y \\text{ 读和写}}.\n  $$\n- $y = A x$ 的浮点运算次数为\n$$\n\\text{FLOPs} = 2 \\cdot n n z.\n$$\n\n在代码中实现上述模型，并为每个测试用例计算CSR和COO的预测运行时间（以秒为单位），除非另有说明，否则假设值为双精度。\n\n对所有测试用例使用以下硬件参数：\n- 峰值浮点吞吐量 $P_{\\mathrm{peak}} = 100 \\times 10^9$ $\\mathrm{FLOP/s}$。\n- 峰值内存带宽 $B_{\\mathrm{peak}} = 50 \\times 10^9$ $\\mathrm{byte/s}$。\n\n您的程序必须处理以下测试套件，其中每个测试用例是一个元组 $(n, m, n n z, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}})$：\n- 测试 $1$：$(1000, 1000, 50000, 4, 8)$。\n- 测试 $2$：$(5, 5, 7, 8, 8)$。\n- 测试 $3$：$(10000, 10000, 10000, 4, 8)$。\n- 测试 $4$：$(20000, 2000, 80000, 4, 8)$。\n- 测试 $5$：$(3000, 3000, 600000, 8, 8)$。\n\n对于每个测试用例：\n- 计算 $\\text{FLOPs}$。\n- 计算 $\\text{Bytes}_{\\mathrm{CSR}}$ 和 $\\text{Bytes}_{\\mathrm{COO}}$。\n- 计算 $T_{\\mathrm{CSR}} = \\max\\left(\\frac{\\text{FLOPs}}{P_{\\mathrm{peak}}}, \\frac{\\text{Bytes}_{\\mathrm{CSR}}}{B_{\\mathrm{peak}}}\\right)$ 和 $T_{\\mathrm{COO}} = \\max\\left(\\frac{\\text{FLOPs}}{P_{\\mathrm{peak}}}, \\frac{\\text{Bytes}_{\\mathrm{COO}}}{B_{\\mathrm{peak}}}\\right)$。\n\n科学现实性约束：\n- 所有值 $n$、$m$ 和 $n n z$ 都是严格的正整数。\n- 索引大小 $i_{\\mathrm{bytes}}$ 为 $4$ 或 $8$ 字节。\n- 值大小 $v_{\\mathrm{bytes}}$ 为 $4$ 或 $8$ 字节；如果 $v_{\\mathrm{bytes}} = 8$，则将矩阵解释为双精度。\n\n角度单位不适用。除秒之外，不使用其他物理单位。所有运行时间以秒为单位表示，为浮点数，四舍五入到六位小数。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含结果，形式为一个逗号分隔的列表，每个测试用例对应一对用方括号括起来的 $[T_{\\mathrm{CSR}}, T_{\\mathrm{COO}}]$，并按顺序排列。\n- 例如，输出必须如下所示\n$$\n\\text{[[t_{1,\\mathrm{CSR}},t_{1,\\mathrm{COO}}],[t_{2,\\mathrm{CSR}},t_{2,\\mathrm{COO}}],\\dots]}\n$$\n其中每个 $t$ 以秒为单位，四舍五入到六位小数。",
            "solution": "该问题要求为两种不同的稀疏矩阵存储格式——压缩稀疏行（CSR）和坐标列表（COO）——构建并实现一个性能模型，以预测稀疏矩阵向量乘法（SpMV）的运行时间。该分析基于一个简化的roofline模型，这是高性能计算中的一个基本概念，用于根据硬件的峰值浮点吞吐量和内存带宽来估计算法的性能边界。\n\n性能模型的核心是估算总执行时间 $T$，即计算所需时间 $T_{\\text{compute}}$ 和内存访问所需时间 $T_{\\text{memory}}$ 中的最大值：\n$$T = \\max\\left(T_{\\text{compute}}, T_{\\text{memory}}\\right)$$\n这些组成部分由总浮点运算次数（$\\text{FLOPs}$）、处理器与主存之间传输的总数据字节数（$\\text{Bytes}$）以及机器的峰值性能特征决定：\n$$T_{\\text{compute}} = \\frac{\\text{FLOPs}}{P_{\\mathrm{peak}}}$$\n$$T_{\\text{memory}} = \\frac{\\text{Bytes}}{B_{\\mathrm{peak}}}$$\n问题提供了以下在所有测试用例中保持不变的硬件参数：\n- 峰值浮点吞吐量：$P_{\\mathrm{peak}} = 100 \\times 10^9$ $\\mathrm{FLOP/s}$。\n- 峰值内存带宽：$B_{\\mathrm{peak}} = 50 \\times 10^9$ $\\mathrm{byte/s}$。\n\nSpMV操作计算 $y = A x$，其中 $A$ 是一个 $n \\times m$ 的稀疏矩阵，有 $nnz$ 个非零元素。对于每个非零元素 $a_{ij}$，会执行一次乘法（$a_{ij} \\cdot x_j$）和一次加法（加到 $y_i$ 的累加器上）。因此，总FLOP计数为：\n$$\\text{FLOPs} = 2 \\cdot nnz$$\n\n内存流量模型基于每种格式特定的算法假设。\n对于CSR格式，它存储非零值、列索引和一个行指针数组。假设的算法在寄存器中为每行 $y_i$ 累加结果，并在每行计算完成后将最终值写回内存一次。总内存流量 $\\text{Bytes}_{\\mathrm{CSR}}$ 是从三个CSR数据数组（值、列索引、行指针）的读取、从输入向量 $x$ 的读取以及向输出向量 $y$ 的写入之和：\n$$\\text{Bytes}_{\\mathrm{CSR}} = \\underbrace{nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{值}} + \\underbrace{nnz \\cdot i_{\\mathrm{bytes}}}_{\\text{列索引}} + \\underbrace{(n+1) \\cdot i_{\\mathrm{bytes}}}_{\\text{行指针}} + \\underbrace{nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } x} + \\underbrace{n \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } y \\text{ 存储}}$$\n这里，$v_{\\mathrm{bytes}}$ 是一个值的字节大小，$i_{\\mathrm{bytes}}$ 是一个索引的字节大小。简化后得到：\n$$\\text{Bytes}_{\\mathrm{CSR}} = nnz \\cdot (2 v_{\\mathrm{bytes}} + i_{\\mathrm{bytes}}) + (n+1)i_{\\mathrm{bytes}} + n \\cdot v_{\\mathrm{bytes}}$$\n\n对于COO格式，它在三个独立的数组中存储值、行索引和列索引。假设的算法为每个非零元素对输出向量 $y$ 执行一次原子性的读-改-写操作。总内存流量 $\\text{Bytes}_{\\mathrm{COO}}$ 是：\n$$\\text{Bytes}_{\\mathrm{COO}} = \\underbrace{nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{值}} + \\underbrace{nnz \\cdot i_{\\mathrm{bytes}}}_{\\text{列索引}} + \\underbrace{nnz \\cdot i_{\\mathrm{bytes}}}_{\\text{行索引}} + \\underbrace{nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } x} + \\underbrace{2 \\cdot nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } y \\text{ 读/写}}$$\n简化后得到：\n$$\\text{Bytes}_{\\mathrm{COO}} = nnz \\cdot (4 v_{\\mathrm{bytes}} + 2 i_{\\mathrm{bytes}})$$\n\n我们现在将这些模型应用于每个测试用例。所有运行时间均以秒为单位报告，并四舍五入到六位小数。\n\n**测试用例 1:** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (1000, 1000, 50000, 4, 8)$\n- $\\text{FLOPs} = 2 \\cdot 50000 = 100000$。\n- $T_{\\text{compute}} = \\frac{100000}{100 \\times 10^9} = 1.0 \\times 10^{-6} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 50000 \\cdot (2 \\cdot 8 + 4) + (1000+1) \\cdot 4 + 1000 \\cdot 8 = 1012004$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{1012004}{50 \\times 10^9} \\approx 2.024008 \\times 10^{-5} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(1.0 \\times 10^{-6}, 2.024008 \\times 10^{-5}) \\approx 0.000020 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 50000 \\cdot (4 \\cdot 8 + 2 \\cdot 4) = 2000000$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{2000000}{50 \\times 10^9} = 4.0 \\times 10^{-5} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(1.0 \\times 10^{-6}, 4.0 \\times 10^{-5}) = 0.000040 \\text{ s}$。\n\n**测试用例 2:** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (5, 5, 7, 8, 8)$\n- $\\text{FLOPs} = 2 \\cdot 7 = 14$。\n- $T_{\\text{compute}} = \\frac{14}{100 \\times 10^9} = 1.4 \\times 10^{-10} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 7 \\cdot (2 \\cdot 8 + 8) + (5+1) \\cdot 8 + 5 \\cdot 8 = 256$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{256}{50 \\times 10^9} = 5.12 \\times 10^{-9} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(1.4 \\times 10^{-10}, 5.12 \\times 10^{-9}) \\approx 0.000000 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 7 \\cdot (4 \\cdot 8 + 2 \\cdot 8) = 336$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{336}{50 \\times 10^9} = 6.72 \\times 10^{-9} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(1.4 \\times 10^{-10}, 6.72 \\times 10^{-9}) \\approx 0.000000 \\text{ s}$。\n\n**测试用例 3:** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (10000, 10000, 10000, 4, 8)$\n- $\\text{FLOPs} = 2 \\cdot 10000 = 20000$。\n- $T_{\\text{compute}} = \\frac{20000}{100 \\times 10^9} = 2.0 \\times 10^{-7} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 10000 \\cdot (2 \\cdot 8 + 4) + (10000+1) \\cdot 4 + 10000 \\cdot 8 = 320004$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{320004}{50 \\times 10^9} \\approx 6.40008 \\times 10^{-6} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(2.0 \\times 10^{-7}, 6.40008 \\times 10^{-6}) \\approx 0.000006 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 10000 \\cdot (4 \\cdot 8 + 2 \\cdot 4) = 400000$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{400000}{50 \\times 10^9} = 8.0 \\times 10^{-6} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(2.0 \\times 10^{-7}, 8.0 \\times 10^{-6}) = 0.000008 \\text{ s}$。\n\n**测试用例 4:** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (20000, 2000, 80000, 4, 8)$\n- $\\text{FLOPs} = 2 \\cdot 80000 = 160000$。\n- $T_{\\text{compute}} = \\frac{160000}{100 \\times 10^9} = 1.6 \\times 10^{-6} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 80000 \\cdot (2 \\cdot 8 + 4) + (20000+1) \\cdot 4 + 20000 \\cdot 8 = 1840004$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{1840004}{50 \\times 10^9} \\approx 3.680008 \\times 10^{-5} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(1.6 \\times 10^{-6}, 3.680008 \\times 10^{-5}) \\approx 0.000037 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 80000 \\cdot (4 \\cdot 8 + 2 \\cdot 4) = 3200000$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{3200000}{50 \\times 10^9} = 6.4 \\times 10^{-5} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(1.6 \\times 10^{-6}, 6.4 \\times 10^{-5}) = 0.000064 \\text{ s}$。\n\n**测试用例 5:** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (3000, 3000, 600000, 8, 8)$\n- $\\text{FLOPs} = 2 \\cdot 600000 = 1200000$。\n- $T_{\\text{compute}} = \\frac{1200000}{100 \\times 10^9} = 1.2 \\times 10^{-5} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 600000 \\cdot (2 \\cdot 8 + 8) + (3000+1) \\cdot 8 + 3000 \\cdot 8 = 14448008$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{14448008}{50 \\times 10^9} \\approx 2.8896016 \\times 10^{-4} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(1.2 \\times 10^{-5}, 2.8896016 \\times 10^{-4}) \\approx 0.000289 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 600000 \\cdot (4 \\cdot 8 + 2 \\cdot 8) = 28800000$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{28800000}{50 \\times 10^9} = 5.76 \\times 10^{-4} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(1.2 \\times 10^{-5}, 5.76 \\times 10^{-4}) = 0.000576 \\text{ s}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes predicted runtimes for sparse matrix-vector multiplication (SpMV)\n    for CSR and COO formats based on a simplified roofline performance model.\n    \"\"\"\n\n    # Define hardware parameters from the problem statement.\n    P_peak = 100e9  # Peak floating point throughput in FLOP/s\n    B_peak = 50e9   # Peak memory bandwidth in byte/s\n\n    # Define the test suite. Each tuple is (n, m, nnz, i_bytes, v_bytes).\n    test_cases = [\n        (1000, 1000, 50000, 4, 8),\n        (5, 5, 7, 8, 8),\n        (10000, 10000, 10000, 4, 8),\n        (20000, 2000, 80000, 4, 8),\n        (3000, 3000, 600000, 8, 8),\n    ]\n\n    # List to store the results for each test case as a [T_csr, T_coo] pair.\n    results = []\n\n    for case in test_cases:\n        n, m, nnz, i_bytes, v_bytes = case\n\n        # 1. Compute FLOPs\n        # Each nonzero element results in one multiplication and one addition.\n        flops = 2 * nnz\n\n        # 2. Compute compute time\n        t_compute = flops / P_peak\n\n        # 3. Compute Bytes transferred for CSR format\n        # Bytes_CSR = (nnz*v_bytes) + (nnz*i_bytes) + ((n+1)*i_bytes) + (nnz*v_bytes) + (n*v_bytes)\n        bytes_csr = nnz * (2 * v_bytes + i_bytes) + (n + 1) * i_bytes + n * v_bytes\n        \n        # 4. Compute Bytes transferred for COO format\n        # Bytes_COO = (nnz*v_bytes) + (nnz*i_bytes) + (nnz*i_bytes) + (nnz*v_bytes) + (2*nnz*v_bytes)\n        bytes_coo = nnz * (4 * v_bytes + 2 * i_bytes)\n\n        # 5. Compute memory-bound times\n        t_mem_csr = bytes_csr / B_peak\n        t_mem_coo = bytes_coo / B_peak\n\n        # 6. Compute final predicted runtimes using the roofline model\n        t_csr = max(t_compute, t_mem_csr)\n        t_coo = max(t_compute, t_mem_coo)\n\n        results.append((t_csr, t_coo))\n\n    # Format the output as specified: [[t_1_csr,t_1_coo],[t_2_csr,t_2_coo],...]\n    # Runtimes are rounded to six decimal places.\n    output_pairs = [f\"[{t_csr:.6f},{t_coo:.6f}]\" for t_csr, t_coo in results]\n    final_output_string = f\"[[{','.join(output_pairs)}]]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "从矩阵组装到计算的过渡通常涉及不同稀疏格式之间的转换，但这个过程充满了微妙的陷阱。本问题探讨了坐标（COO）和 CSR 格式之间的一个关键语义差异：对重复条目的处理。通过一个具体的反例，您将看到为什么在转换为 CSR 之前未能正确“合并”重复项会导致错误结果，从而强调了尊重矩阵底层数学定义的重要性。",
            "id": "3580366",
            "problem": "考虑一个由 $y \\leftarrow A x$ 定义的稀疏矩阵向量乘法 (SpMV)，其中 $A \\in \\mathbb{R}^{m \\times n}$，$x \\in \\mathbb{R}^{n}$，且 $y \\in \\mathbb{R}^{m}$。在坐标列表 (COO) 格式中，矩阵 $A$ 由三元组 $(i_k, j_k, v_k)$ ($k = 1, \\ldots, K$) 指定，这些三元组表示元素 $a_{i_k j_k}$。当多个三元组共享相同的索引对 $(i, j)$ 时，这些元素将通过求和累加到代数矩阵 $A$ 中。在压缩稀疏行 (CSR) 格式中，矩阵由三个数组表示，这些数组为每一行 $i$ 编码了一个连续的列索引和值段。在结构上，CSR 表示对每个结构位置 $(i, j)$ 只保存一个存储值。\n\n根据基本原理，SpMV 对每个 $i \\in \\{1, \\ldots, m\\}$ 计算 $y_i = \\sum_{j=1}^{n} a_{ij} x_j$，其中 $a_{ij}$ 表示通过对重复项求和来组合所有 COO 三元组后得到的代数矩阵元素。在有限元组合和其他加性离散化中，COO 格式中的重复项很常见，并且在形成 CSR 之前必须合并 (coalesce) 成单个 $a_{ij}$，以反映真实的代数矩阵。\n\n假设某个实现将 COO 转换为 CSR，但没有通过对重复的 $(i, j)$ 对的值求和来显式地合并重复项。相反，它通过按 $(i, j)$ 对三元组进行排序来构造 CSR，并为每个 $(i, j)$ 只保留最后一次出现的值（即，覆盖先前的值而不是求和），从而违反了形成正确矩阵所需的代数累加规则。\n\n哪个选项提供了一个具体的反例，证明这种未能合并重复项的做法会导致错误的 SpMV 结果，并正确地指出了其结构性原因？\n\nA. 设 $A \\in \\mathbb{R}^{3 \\times 3}$ 在 COO 格式中由三元组 $(0, 1, 1)$、$(0, 1, -2)$、$(0, 1, 3)$、$(1, 0, 4)$、$(1, 2, 5)$、$(2, 2, -1)$ 给出，并设 $x = [1, 2, 3]^{\\top}$。代数合并后的矩阵有 $a_{0,1} = 1 + (-2) + 3 = 2$，所以正确的 SpMV 产生 $y = [4, 19, -3]^{\\top}$，因为 $y_0 = 2 \\cdot x_1 = 4$，$y_1 = 4 \\cdot x_0 + 5 \\cdot x_2 = 19$，$y_2 = -1 \\cdot x_2 = -3$。如果 CSR 是通过保留每个 $(i, j)$ 的最后一次出现来形成的，使得 $a_{0,1}$ 被设置为 $3$ (丢棄了之前的贡献)，那么计算出的 SpMV 结果是 $y = [6, 19, -3]^{\\top}$，这是不正确的。结构性原因：CSR 在行段中为每个结构索引对 $(i, j)$ 只存储一个值；如果在形成 CSR 之前没有对重复项求和，而是应用了最后值覆盖，那么为 $(i, j)$ 存储的数值就不等于 COO 组合所需的代数和，从而改变了 $a_{ij}$，进而改变了 $y_i = \\sum_j a_{ij} x_j$。\n\nB. 设 $A \\in \\mathbb{R}^{2 \\times 2}$ 在 COO 格式中由 $(0, 0, 2)$ 和 $(0, 0, 3)$ 给出，并设 $x = [1, 1]^{\\top}$。即使在没有合并重复项的情况下形成 CSR，SpMV 也会是正确的，因为重复项会通过 CSR 中的逐行累加而固有地相加；因此根本不需要显式合并。结构性原因：CSR 的行指针保证了任何重复项在 SpMV 过程中都会被正确相加，因为它们表现为重复的条目。\n\nC. 设 $A \\in \\mathbb{R}^{2 \\times 2}$ 在 COO 格式中由 $(0, 1, 1)$ 和 $(0, 1, -1)$ 给出，并设 $x = [2, 5]^{\\top}$。如果不进行合并，CSR SpMV 是正确的，因为重复项在乘法过程中会相互抵消，得到 $y_0 = (1 + (-1)) \\cdot x_1 = 0$。结构性原因：由于重复项的总和为零，未能合并没有任何影响，并且 CSR 可以安全地忽略早期的条目。\n\nD. 设 $A \\in \\mathbb{R}^{3 \\times 3}$ 在 COO 格式中由 $(0, 2, 4)$、$(1, 2, -4)$、$(1, 2, 1)$、$(2, 0, 7)$ 给出，并设 $x = [1, 2, 3]^{\\top}$。如果 CSR 是通过计算行出现次数但不合并重复项来形成的，SpMV 会变得数值不稳定，因为行指针会错位，并且算法会读取错误的列。结构性原因：重复项必然会破坏 CSR 中的行指针结构，使得任何 SpMV 都不正确，无论值是如何处理的。\n\n选择唯一的正确选项。",
            "solution": "问题陈述提出了一个关于稀疏矩阵存储格式以及从坐标 (COO) 格式到压缩稀疏行 (CSR) 格式转换的一种特定、有缺陷的实现的后果的问题。问题的核心在于如何从 COO 三元组列表定义矩阵 $A$，这需要对重复的 $(i, j)$ 索引的值进行求和以形成真实的代数矩阵。有缺陷的实现绕过了这个求和过程，而是执行“最后值覆盖”操作。\n\n问题是要找出一个反例，它能正确地展示这种有缺陷的实现导致的错误结果，并给出失败的正确结构性原因。\n\n首先，让我们形式化给出的定义。\n- 矩阵向量积定义为 $y \\leftarrow Ax$，对每一行 $i$ 计算为 $y_i = \\sum_{j=1}^{n} a_{ij} x_j$。\n- COO 格式是一个三元组列表 $(i_k, j_k, v_k)$。矩阵 $A$ 的代数元素 $a_{ij}$ 由所有对应索引 $(i_k, j_k)$ 等于 $(i, j)$ 的值 $v_k$ 的总和给出：$a_{ij} = \\sum_{k | (i_k, j_k) = (i,j)} v_k$。这个过程被称为合并 (coalescing)。\n- CSR 格式在其结构内不能表示重复的 $(i, j)$ 条目；它为每个非零位置存储一个单一的值。\n- 从 COO 到 CSR 的有缺陷转换按 $(i,j)$ 对三元組进行字典序排序，并对于每个唯一的索引对 $(i,j)$，它只存储排序列表中最后一个三元组的值，从而有效地覆盖了该相同 $(i,j)$ 的任何先前值。让我们将这个有缺陷过程产生的矩阵表示为 $A'$。\n\n我们必须评估每个选项，看它是否提供了一个有效的反例和正确的解释。\n\n### 逐项分析\n\n**A. 设 $A \\in \\mathbb{R}^{3 \\times 3}$ 在 COO 格式中由三元组 $(0, 1, 1)$、$(0, 1, -2)$、$(0, 1, 3)$、$(1, 0, 4)$、$(1, 2, 5)$、$(2, 2, -1)$ 给出，并设 $x = [1, 2, 3]^{\\top}$。**\n\n1.  **正确的代数 SpMV：**\n    首先，我们通过对 COO 三元组求和合并来确定真实代数矩阵 $A$ 的元素。\n    - 对于索引对 $(0, 1)$，我们有三个三元组：$(0, 1, 1)$、$(0, 1, -2)$ 和 $(0, 1, 3)$。合并后的值为 $a_{0,1} = 1 + (-2) + 3 = 2$。\n    - 对于索引对 $(1, 0)$，我们有一个三元组：$(1, 0, 4)$。因此，$a_{1,0} = 4$。\n    - 对于索引对 $(1, 2)$，我们有一个三元组：$(1, 2, 5)$。因此，$a_{1,2} = 5$。\n    - 对于索引对 $(2, 2)$，我们有一个三元组：$(2, 2, -1)$。因此，$a_{2,2} = -1$。\n    得到的代数矩阵 $A$ 是：\n    $$ A = \\begin{pmatrix} 0 & 2 & 0 \\\\ 4 & 0 & 5 \\\\ 0 & 0 & -1 \\end{pmatrix} $$\n    现在，我们用 $x = [1, 2, 3]^{\\top}$ 计算正确的 SpMV 结果 $y = Ax$。\n    - $y_0 = (0 \\cdot 1) + (2 \\cdot 2) + (0 \\cdot 3) = 4$。\n    - $y_1 = (4 \\cdot 1) + (0 \\cdot 2) + (5 \\cdot 3) = 4 + 15 = 19$。\n    - $y_2 = (0 \\cdot 1) + (0 \\cdot 2) + (-1 \\cdot 3) = -3$。\n    所以，正确的结果是 $y = [4, 19, -3]^{\\top}$。这与选项中的计算相符。\n\n2.  **有缺陷的 CSR 转换导致的错误 SpMV：**\n    有缺陷的实现按 $(i, j)$ 对三元组排序并保留每对的最后一个值。对于索引对 $(0, 1)$，三元组为 $(0, 1, 1)$、$(0, 1, -2)$、$(0, 1, 3)$。最后一个值是 $3$。\n    有缺陷的矩阵 $A'$ 的元素是：\n    - $a'_{0,1} = 3$ (最后值覆盖)。\n    - $a'_{1,0} = 4$ (只有一个条目)。\n    - $a'_{1,2} = 5$ (只有一个条目)。\n    - $a'_{2,2} = -1$ (只有一个条目)。\n    有缺陷的矩阵 $A'$ 是：\n    $$ A' = \\begin{pmatrix} 0 & 3 & 0 \\\\ 4 & 0 & 5 \\\\ 0 & 0 & -1 \\end{pmatrix} $$\n    现在，我们计算错误的 SpMV 结果 $y' = A'x$。\n    - $y'_0 = (0 \\cdot 1) + (3 \\cdot 2) + (0 \\cdot 3) = 6$。\n    - $y'_1 = (4 \\cdot 1) + (0 \\cdot 2) + (5 \\cdot 3) = 4 + 15 = 19$。\n    - $y'_2 = (0 \\cdot 1) + (0 \\cdot 2) + (-1 \\cdot 3) = -3$。\n    所以，错误的结果是 $y' = [6, 19, -3]^{\\top}$。这也与选项中的计算相符。\n\n3.  **原因评估：**\n    正确结果 $y$ 和错误结果 $y'$ 不同，因此这是一个有效的反例。提供的理由是：“CSR 在行段中为每个结构索引对 $(i, j)$ 只存储一个值……如果在形成 CSR 之前没有对重复项求和，而是应用了最后值覆盖，那么为 $(i, j)$ 存储的数值就不等于 COO 组合所需的代数和，从而改变了 $a_{ij}$，进而改变了 $y_i = \\sum_j a_{ij} x_j$。”这个解释是精确和正确的。CSR 的结构约束（每个 $(i, j)$ 只有一个条目）使得必须有一个合并步骤来正确表示由加性 COO 语义定义的矩阵。有缺陷的“覆盖”方法用不正确的数值填充了 CSR 结构，从而导致了错误的 SpMV 结果。\n\n**结论：正确。**\n\n**B. 设 $A \\in \\mathbb{R}^{2 \\times 2}$ 在 COO 格式中由 $(0, 0, 2)$ 和 $(0, 0, 3)$ 给出，并设 $x = [1, 1]^{\\top}$。**\n\n该选项声称 SpMV 将是正确的，因为“重复项会通过 CSR 中的逐行累加而固有地相加”。这个前提根本上是有缺陷的。一个标准的 CSR 格式没有机制来存储重复条目，更不用说对它们求和了。CSR 的结构由三个数组组成：`row_ptr`、`col_ind` 和 `values`。对于给定的行 $i$，段 `col_ind[row_ptr[i] : row_ptr[i+1]]` 应该包含唯一的列索引。如果创建了一个带有重复列索引的非标准 CSR（例如，第 0 行的 `col_ind` 是 `[0, 0]`），则需要一个自定义的 SpMV 内核来处理它。一个标准的内核只会简单地迭代并执行两次独立的乘法，实际上是将它们相加，但这依赖于一个格式错误的 CSR。问题陈述中对 CSR 的定义（“对每个结构位置只保存一个存储值”）和指定的缺陷（覆盖）与此选项中的逻辑相矛盾。所提供的结构性原因（“CSR 的行指针保证了任何重复项都会被正确相加”）是对行指针功能的错误陈述。\n\n**结论：不正确。**\n\n**C. 设 $A \\in \\mathbb{R}^{2 \\times 2}$ 在 COO 格式中由 $(0, 1, 1)$ 和 $(0, 1, -1)$ 给出，并设 $x = [2, 5]^{\\top}$。**\n\n这个选项声称结果是正确的，因为重复项会抵消。\n1.  **正确的代数 SpMV：**\n    COO 三元组是 $(0, 1, 1)$ 和 $(0, 1, -1)$。合并后得到 $a_{0,1} = 1 + (-1) = 0$。\n    正确的 SpMV 结果是 $y_0 = a_{0,1} x_1 = 0 \\cdot 5 = 0$。\n2.  **有缺陷的 CSR 转换导致的错误 SpMV：**\n    有缺陷的实现取最后一个值。最后一个三元组是 $(0, 1, -1)$，所以 $a'_{0,1} = -1$。\n    错误的 SpMV 结果是 $y'_0 = a'_{0,1} x_1 = -1 \\cdot 5 = -5$。\n由于 $0 \\neq -5$，声称 SpMV 结果正确的断言是错误的。该选项误解了有缺陷的算法；它假设值被求和，而问题明确指出它们被覆盖。值总和为零这个特殊的数值属性与指定的有缺陷算法的结果无关。\n\n**结论：不正确。**\n\n**D. 设 $A \\in \\mathbb{R}^{3 \\times 3}$ 在 COO 格式中由 $(0, 2, 4)$、$(1, 2, -4)$、$(1, 2, 1)$、$(2, 0, 7)$ 给出，并设 $x = [1, 2, 3]^{\\top}$。**\n\n这个选项引入了一种缺陷机制（“计算行出现次数但不合并重复项”），这与问题陈述中定义的机制（“只保留最后一次出现的值”）不同。这使得该选项没有回答问题。此外，其推理也是有缺陷的。它声称“行指针会错位”并且 SpMV 会变得“数值不稳定”。这些是对错误的不精确和不正确的描述。错误是一个逻辑错误：表示了错误的矩阵。在问题指定的“覆盖”缺陷下，生成的 CSR 结构将是完全格式正确的，而不是“损坏的”，并且 SpMV 将是数值稳定的；它只是简单地计算与错误矩阵 $A'$ 的乘积。“数值不稳定性”一词指的是算法对输入数据微小变化（例如舍入误差）的敏感性，而这里的问题并非如此。对于问题中指定的基于覆盖的缺陷，所给出的结构性原因（“重复项必然会破坏 CSR 中的行指针结构”）是错误的。\n\n**结论：不正确。**\n\n基于详尽的分析，只有选项 A 提供了一个与问题中对有缺陷算法的定义相符的、数值上正确的反例，并且它为由此产生的错误提供了清晰、准确的结构性解释。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}