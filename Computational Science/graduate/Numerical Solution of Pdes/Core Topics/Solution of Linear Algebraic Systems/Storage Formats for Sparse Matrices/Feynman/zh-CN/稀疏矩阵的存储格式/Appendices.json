{
    "hands_on_practices": [
        {
            "introduction": "理解稀疏矩阵存储格式的第一步是量化其内存成本。本练习将指导您从第一性原理出发，推导压缩稀疏行（CSR）格式的内存占用，并将其与专用带状格式进行对比。通过这个实践，您将深入理解索引和指针数组带来的开销，以及针对特定矩阵结构进行存储优化的重要性。",
            "id": "3445552",
            "problem": "设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个稀疏矩阵，它由一维二阶线性偏微分方程在均匀网格上使用标准三点模板进行有限差分-离散化得到。两种广泛使用的稀疏矩阵存储格式是压缩稀疏行 (CSR) 和压缩稀疏列 (CSC)。假设所有存储的值都是 $64$ 位浮点数，所有索引和指针数组都是 $64$ 位有符号整数。在这种设置下，每个存储的浮点值占用 $8$ 字节，每个存储的索引占用 $8$ 字节，任何指针数组的每个条目也占用 $8$ 字节。\n\na) 仅使用数据结构的核心定义，不调用任何预先记忆的公式，定义压缩稀疏行 (CSR) 和压缩稀疏列 (CSC) 存储格式，并明确说明它们包含哪些数组以及每个数组代表什么。\n\nb) 考虑由上述模板生成的、带有狄利克雷边界条件的 $n \\times n$ 三对角矩阵，该矩阵恰好有 $3n - 2$ 个非零元。从第一性原理出发，推导以 CSR 格式存储此矩阵所需的总内存占用（以字节为单位），并分别推导以一种专门的三对角带状存储格式（仅保留三个对角线——下对角线、主对角线、上对角线，不使用任何索引数组）存储它所需的总内存占用（以字节为单位）。\n\nc) 现在考虑一个一般的稀疏 $n \\times n$ 矩阵，它恰好有 $m$ 个非零元，并且没有其他附加结构。在相同的数据大小假设下，推导以 CSR（或等效的 CSC）格式存储此矩阵所需的总内存占用（以字节为单位）。\n\n将你的最终答案表示为一个包含三个条目的单行向量，顺序如下：\n- b) 部分中三对角矩阵的 CSR 格式字节数，\n- c) 部分中具有 $m$ 个非零元的一般稀疏矩阵的 CSR 格式字节数，\n- b) 部分中三对角矩阵的 CSR 格式字节数与专门的三对角带状存储字节数的比率。\n\n不需要进行数值四舍五入。最终答案中不要包含单位；这些条目分别隐含地对应于字节或无量纲比率。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n### 第一步：提取已知条件\n- 矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是稀疏的。\n- 它源于使用标准三点模板对一维二阶线性偏微分方程进行有限差分-离散化。\n- 考虑两种存储格式：压缩稀疏行 (CSR) 和压缩稀疏列 (CSC)。\n- 存储的值是 $64$ 位浮点数，相当于 $8$ 字节。\n- 索引和指针数组条目是 $64$ 位有符号整数，相当于 $8$ 字节。\n- a) 部分要求给出 CSR 和 CSC 格式的定义。\n- b) 部分考虑一个具体情况：一个带有狄利克雷边界条件的 $n \\times n$ 三对角矩阵，恰好有 $3n - 2$ 个非零元。它要求计算 CSR 格式和专门的三对角带状存储格式（只存储三个对角线，无索引数组）下的内存占用（以字节为单位）。\n- c) 部分考虑一个具有 $m$ 个非零元且无其他假设结构的一般稀疏 $n \\times n$ 矩阵。它要求计算 CSR 格式下的内存占用（以字节为单位）。\n- 最终答案被指定为一个包含三个条目的行向量。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学性：** 该问题牢固地植根于数值线性代数和科学计算领域。CSR、CSC 和带状存储是处理源自偏微分方程离散化的稀疏矩阵的标准、定义明确的数据结构。所有陈述都是事实正确的。\n- **适定性：** 该问题是适定的。它提供了所有必要的信息（矩阵维度、非零元数量、数据类型大小）来推导所需的内存占用，表示为关于 $n$ 和 $m$ 的符号表达式。问题明确无歧义，并能得出唯一、可验证的答案。\n- **客观性：** 语言技术性强、精确，不含任何主观或基于观点的内容。\n\n### 第三步：结论与行动\n该问题具有科学性、适定性和客观性，没有明显的缺陷。因此，它被认为是有效的。我们可以继续构建解决方案。\n\n### a) CSR 和 CSC 格式的定义\n\n压缩稀疏行 (CSR) 和压缩稀疏列 (CSC) 格式是存储稀疏矩阵的标准方法，它们避免存储零元素。它们的定义基于三个数组。设 $A$ 是一个具有 $nnz$ 个非零元的 $n \\times n$ 矩阵。\n\n**压缩稀疏行 (CSR) 格式：**\n此格式逐行存储矩阵。它由三个数组组成：\n1.  一个 `values` 数组，我们称之为 $V$，长度为 $nnz$。该数组存储矩阵 $A$ 的非零元素，按行主序扫描（即遍历第 $0$ 行，然后第 $1$ 行，依此类推）。单行内的值可以按任何顺序存储，但通常按其列索引的升序存储。每个元素都是一个浮点数。\n2.  一个 `column_indices` 数组，我们称之为 $J$，长度为 $nnz$。对于 $V$ 中的每个元素，此数组存储其在原始矩阵 $A$ 中对应的列索引。也就是说，如果 $V[k] = A_{i,j}$，则 $J[k] = j$。每个元素都是一个整数。\n3.  一个 `row_pointers` 数组，我们称之为 $R_p$，长度为 $n+1$。此数组存储 $V$ 数组中每一行起始的位置。具体来说，$R_p[i]$ 是第 $i$ 行第一个非零元素在 $V$（和 $J$）中的索引。第 $i$ 行的非零元素数量由 $R_p[i+1] - R_p[i]$ 给出。第一个元素 $R_p[0]$ 总是 $0$，最后一个元素 $R_p[n]$ 总是 $nnz$。每个元素都是一个整数。\n\n**压缩稀疏列 (CSC) 格式：**\n此格式与 CSR 类似，但逐列存储矩阵。它等同于矩阵转置 $A^T$ 的 CSR 表示。它也由三个数组组成：\n1.  一个 `values` 数组 $V$，长度为 $nnz$，按列主序存储 $A$ 的非零元素。\n2.  一个 `row_indices` 数组，我们称之为 $I$，长度为 $nnz$。对于 $V$ 中的每个元素，此数组存储其对应的行索引。也就是说，如果 $V[k] = A_{i,j}$，则 $I[k] = i$。\n3.  一个 `column_pointers` 数组，我们称之为 $C_p$，长度为 $n+1$。$C_p[j]$ 是第 $j$ 列第一个非零元素在 $V$ 中的索引。第 $j$ 列的非零元素数量是 $C_p[j+1] - C_p[j]$。$C_p[0]$ 总是 $0$，而 $C_p[n]$ 总是 $nnz$。\n\n### b) 三对角矩阵的内存占用\n\n给定一个 $n \\times n$ 的三对角矩阵，它恰好有 $m = 3n - 2$ 个非零元。每个存储的值的大小为 $8$ 字节，每个索引或指针的大小为 $8$ 字节。\n\n**CSR 格式内存计算：**\n我们计算 CSR 格式中三个数组分别所需的内存。非零元的数量是 $nnz = 3n - 2$。\n1.  `values` 数组 ($V$) 存储所有 $3n - 2$ 个非零浮点值。\n    $V$ 的内存 = $(3n - 2) \\text{ 个值} \\times 8 \\frac{\\text{字节}}{\\text{值}} = 8(3n - 2)$ 字节。\n2.  `column_indices` 数组 ($J$) 存储这 $3n - 2$ 个非零值中每一个的列索引。\n    $J$ 的内存 = $(3n - 2) \\text{ 个索引} \\times 8 \\frac{\\text{字节}}{\\text{索引}} = 8(3n - 2)$ 字节。\n3.  `row_pointers` 数组 ($R_p$) 的长度为 $n+1$。\n    $R_p$ 的内存 = $(n + 1) \\text{ 个指针} \\times 8 \\frac{\\text{字节}}{\\text{指针}} = 8(n + 1)$ 字节。\n\nCSR 格式的总内存占用 $M_{CSR,tridi}$ 是这三项之和：\n$$M_{CSR,tridi} = 8(3n - 2) + 8(3n - 2) + 8(n + 1)$$\n$$M_{CSR,tridi} = 16(3n - 2) + 8(n + 1)$$\n$$M_{CSR,tridi} = 48n - 32 + 8n + 8$$\n$$M_{CSR,tridi} = 56n - 24 \\text{ 字节}$$\n\n**专门的三对角带状存储内存计算：**\n此格式仅存储三个非零对角线。对于一个 $n \\times n$ 矩阵，这包括主对角线（长度 $n$）、下对角线（长度 $n-1$）和上对角线（长度 $n-1$）。\n需要存储的元素总数为 $n + (n-1) + (n-1) = 3n - 2$。这与给定的非零元数量相符。\n问题陈述说明此格式不使用索引数组。因此，我们只存储这 $3n-2$ 个浮点值。\n这种专门带状存储的总内存占用 $M_{band}$ 是：\n$$M_{band} = (3n - 2) \\text{ 个值} \\times 8 \\frac{\\text{字节}}{\\text{值}} = 8(3n - 2) \\text{ 字节}$$\n$$M_{band} = 24n - 16 \\text{ 字节}$$\n\n### c) 一般稀疏矩阵的内存占用\n\n我们考虑一个具有 $m$ 个非零元的一般 $n \\times n$ 稀疏矩阵。\n\n**CSR 格式内存计算：**\n逻辑与三对角矩阵的情况相同，但我们使用通用符号 $m$ 表示非零元的数量 ($nnz = m$)。\n1.  `values` 数组 ($V$) 存储 $m$ 个非零浮点值。\n    $V$ 的内存 = $m \\times 8$ 字节。\n2.  `column_indices` 数组 ($J$) 存储 $m$ 个列索引。\n    $J$ 的内存 = $m \\times 8$ 字节。\n3.  `row_pointers` 数组 ($R_p$) 的长度为 $n+1$。\n    $R_p$ 的内存 = $(n + 1) \\times 8$ 字节。\n\n一般稀疏矩阵在 CSR 格式下的总内存占用 $M_{CSR,gen}$ 是其总和：\n$$M_{CSR,gen} = 8m + 8m + 8(n + 1)$$\n$$M_{CSR,gen} = 16m + 8n + 8 \\text{ 字节}$$\n注意 CSC 格式的内存占用将是相同的，因为它也包含两个长度为 $m$ 的数组和一个长度为 $n+1$ 的数组。\n\n### 最终答案组合\n\n题目要求我们提供一个包含三个条目的行向量：\n1.  三对角矩阵的 CSR 格式字节数：$M_{CSR,tridi} = 56n - 24$。\n2.  具有 $m$ 个非零元的一般稀疏矩阵的 CSR 格式字节数：$M_{CSR,gen} = 16m + 8n + 8$。\n3.  三对角矩阵的 CSR 格式字节数与专门带状存储字节数的比率：\n    $$ \\text{比率} = \\frac{M_{CSR,tridi}}{M_{band}} = \\frac{56n - 24}{24n - 16} $$\n    我们可以通过提取公因子 $8$ 来简化这个表达式：\n    $$ \\text{比率} = \\frac{8(7n - 3)}{8(3n - 2)} = \\frac{7n - 3}{3n - 2} $$\n最终答案是一个包含这三个表达式的行向量。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 56n - 24 & 16m + 8n + 8 & \\frac{7n - 3}{3n - 2} \\end{pmatrix} } $$"
        },
        {
            "introduction": "存储格式的选择直接影响计算性能，尤其是在稀疏矩阵向量乘法（SpMV）等核心运算中。本练习要求您应用一个简化的性能模型来预测不同存储格式下的SpMV运行时间。通过这个编码实践，您将学会如何量化内存访问和浮点运算对总体性能的贡献，并理解为何SpMV通常是受内存带宽限制的。",
            "id": "3271435",
            "problem": "要求您设计并实现一个程序，用于预测两种常见稀疏存储格式（压缩稀疏行（CSR）和坐标列表（COO））下稀疏矩阵向量乘法的性能。该任务侧重于基础科学计算原理、计算成本和内存流量建模，以及应用性能模型来估计运行时间。您的程序必须为给定的测试套件计算预测的运行时间，并以单一指定格式输出结果。\n\n从以下基本依据开始：\n\n- 稀疏矩阵向量乘法计算 $y = A x$，其中 $A$ 是稀疏矩阵。对于每个非零元素 $a_{ij}$，计算涉及一次乘法和一次加法，即每个非零元素总共有 $2$ 个浮点运算。\n- 在一个与 roofline 方法一致的简单性能模型中，总时间 $T$ 估算如下：\n$$\nT = \\max\\left(\\frac{\\text{FLOPs}}{P_{\\mathrm{peak}}}, \\frac{\\text{Bytes}}{B_{\\mathrm{peak}}}\\right),\n$$\n其中 $\\text{FLOPs}$ 是浮点运算次数，$P_{\\mathrm{peak}}$ 是以 $\\mathrm{FLOP/s}$ 为单位的峰值浮点吞吐量，$\\text{Bytes}$ 是以字节为单位的总数据流量，$B_{\\mathrm{peak}}$ 是以 $\\mathrm{byte/s}$ 为单位的峰值内存带宽。\n- 对于 CSR 和 COO 格式，在流式和无序 COO 累加的假设下（由于缓存，向量元素没有复用，并且对于每个非零元素，COO 直接累加到 $y$ 中），总移动字节数可以从算法循环和数据结构中推导出来：\n  - CSR 格式存储值、列索引和行指针的数组。其实现遍历行，在寄存器中累加 $y_i$，并且每行写入一次。移动的字节数建模为\n  $$\n  \\text{Bytes}_{\\mathrm{CSR}} = \\underbrace{n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{values}} + \\underbrace{n n z \\cdot i_{\\mathrm{bytes}}}_{\\text{column indices}} + \\underbrace{(n+1) \\cdot i_{\\mathrm{bytes}}}_{\\text{row pointer}} + \\underbrace{n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{vector } x} + \\underbrace{n \\cdot v_{\\mathrm{bytes}}}_{\\text{vector } y \\text{ stores}}.\n  $$\n  - COO 格式存储值、行索引和列索引的数组。其实现直接累加到 $y$ 中，对每个非零元素都读取和写入 $y$。移动的字节数建模为\n  $$\n  \\text{Bytes}_{\\mathrm{COO}} = \\underbrace{n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{values}} + \\underbrace{n n z \\cdot i_{\\mathrm{bytes}}}_{\\text{column indices}} + \\underbrace{n n z \\cdot i_{\\mathrm{bytes}}}_{\\text{row indices}} + \\underbrace{n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{vector } x} + \\underbrace{2 \\cdot n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{vector } y \\text{ read and write}}.\n  $$\n- 对于 $y = A x$ 的浮点运算次数为\n$$\n\\text{FLOPs} = 2 \\cdot n n z.\n$$\n\n在代码中实现上述模型，并为每个测试用例计算 CSR 和 COO 的预测运行时间（以秒为单位），除非另有说明，否则假设值为双精度。\n\n对所有测试用例使用以下硬件参数：\n- 峰值浮点吞吐量 $P_{\\mathrm{peak}} = 100 \\times 10^9$ $\\mathrm{FLOP/s}$。\n- 峰值内存带宽 $B_{\\mathrm{peak}} = 50 \\times 10^9$ $\\mathrm{byte/s}$。\n\n您的程序必须处理以下测试套件，其中每个测试用例是一个元组 $(n, m, n n z, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}})$：\n- 测试 $1$：$(1000, 1000, 50000, 4, 8)$。\n- 测试 $2$：$(5, 5, 7, 8, 8)$。\n- 测试 $3$：$(10000, 10000, 10000, 4, 8)$。\n- 测试 $4$：$(20000, 2000, 80000, 4, 8)$。\n- 测试 $5$：$(3000, 3000, 600000, 8, 8)$。\n\n对于每个测试用例：\n- 计算 $\\text{FLOPs}$。\n- 计算 $\\text{Bytes}_{\\mathrm{CSR}}$ 和 $\\text{Bytes}_{\\mathrm{COO}}$。\n- 计算 $T_{\\mathrm{CSR}} = \\max\\left(\\frac{\\text{FLOPs}}{P_{\\mathrm{peak}}}, \\frac{\\text{Bytes}_{\\mathrm{CSR}}}{B_{\\mathrm{peak}}}\\right)$ 和 $T_{\\mathrm{COO}} = \\max\\left(\\frac{\\text{FLOPs}}{P_{\\mathrm{peak}}}, \\frac{\\text{Bytes}_{\\mathrm{COO}}}{B_{\\mathrm{peak}}}\\right)$。\n\n科学真实性约束：\n- 所有值 $n$、$m$ 和 $n n z$ 均为严格正整数。\n- 索引大小 $i_{\\mathrm{bytes}}$ 为 $4$ 或 $8$ 字节。\n- 值大小 $v_{\\mathrm{bytes}}$ 为 $4$ 或 $8$ 字节；如果 $v_{\\mathrm{bytes}} = 8$，则将矩阵解释为双精度。\n\n角度单位不适用。除秒之外，不使用其他物理单位。所有运行时间以秒为单位表示，并四舍五入到六位小数的浮点数。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含结果，形式为一个逗号分隔的列表，每个测试用例对应一对用方括号括起来的数值，按顺序排列，每对数值为 $[T_{\\mathrm{CSR}}, T_{\\mathrm{COO}}]$。\n- 例如，输出必须如下所示\n$$\n\\text{[[t_{1,\\mathrm{CSR}},t_{1,\\mathrm{COO}}],[t_{2,\\mathrm{CSR}},t_{2,\\mathrm{COO}}],\\dots]}\n$$\n其中每个 $t$ 以秒为单位，四舍五入到六位小数。",
            "solution": "该问题要求制定并实现一个性能模型，以预测两种不同稀疏矩阵存储格式（压缩稀疏行（CSR）和坐标列表（COO））下稀疏矩阵向量乘法（SpMV）的运行时间。该分析基于简化的 roofline 模型，这是高性能计算中的一个基本概念，用于根据硬件的峰值浮点吞吐量和内存带宽来估计算法的性能边界。\n\n该性能模型的核心是估算总执行时间 $T$，即计算所需时间 $T_{\\text{compute}}$ 和内存访问所需时间 $T_{\\text{memory}}$ 的最大值：\n$$T = \\max\\left(T_{\\text{compute}}, T_{\\text{memory}}\\right)$$\n这些部分由浮点运算总数（$\\text{FLOPs}$）、处理器与主存之间传输的总数据字节数（$\\text{Bytes}$）以及机器的峰值性能特征决定：\n$$T_{\\text{compute}} = \\frac{\\text{FLOPs}}{P_{\\mathrm{peak}}}$$\n$$T_{\\text{memory}} = \\frac{\\text{Bytes}}{B_{\\mathrm{peak}}}$$\n问题提供了以下硬件参数，这些参数在所有测试用例中都是恒定的：\n- 峰值浮点吞吐量：$P_{\\mathrm{peak}} = 100 \\times 10^9$ $\\mathrm{FLOP/s}$。\n- 峰值内存带宽：$B_{\\mathrm{peak}} = 50 \\times 10^9$ $\\mathrm{byte/s}$。\n\nSpMV 操作计算 $y = A x$，其中 $A$ 是一个 $n \\times m$ 的稀疏矩阵，有 $nnz$ 个非零元素。对于每个非零元素 $a_{ij}$，会执行一次乘法（$a_{ij} \\cdot x_j$）和一次加法（加到 $y_i$ 的累加器中）。因此，总 FLOP 计数为：\n$$\\text{FLOPs} = 2 \\cdot nnz$$\n\n内存流量模型基于每种格式特定的算法假设。\n对于 CSR 格式，它存储非零值、列索引和行指针数组，假定的算法在寄存器中为每行 $y_i$ 累加结果，并每行将最终值写入内存一次。总内存流量 $\\text{Bytes}_{\\mathrm{CSR}}$ 是从三个 CSR 数据数组（值、列索引、行指针）读取、从输入向量 $x$ 读取以及向输出向量 $y$ 写入的总和：\n$$\\text{Bytes}_{\\mathrm{CSR}} = \\underbrace{nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{values}} + \\underbrace{nnz \\cdot i_{\\mathrm{bytes}}}_{\\text{column indices}} + \\underbrace{(n+1) \\cdot i_{\\mathrm{bytes}}}_{\\text{row pointer}} + \\underbrace{nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{vector } x} + \\underbrace{n \\cdot v_{\\mathrm{bytes}}}_{\\text{vector } y \\text{ stores}}$$\n这里，$v_{\\mathrm{bytes}}$ 是一个值的字节大小，$i_{\\mathrm{bytes}}$ 是一个索引的字节大小。这可以简化为：\n$$\\text{Bytes}_{\\mathrm{CSR}} = nnz \\cdot (2 v_{\\mathrm{bytes}} + i_{\\mathrm{bytes}}) + (n+1)i_{\\mathrm{bytes}} + n \\cdot v_{\\mathrm{bytes}}$$\n\n对于 COO 格式，它将值、行索引和列索引存储在三个独立的数组中，假定的算法对每个非零元素在输出向量 $y$ 上执行原子性的读-改-写操作。总内存流量 $\\text{Bytes}_{\\mathrm{COO}}$ 是：\n$$\\text{Bytes}_{\\mathrm{COO}} = \\underbrace{nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{values}} + \\underbrace{nnz \\cdot i_{\\mathrm{bytes}}}_{\\text{column indices}} + \\underbrace{nnz \\cdot i_{\\mathrm{bytes}}}_{\\text{row indices}} + \\underbrace{nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{vector } x} + \\underbrace{2 \\cdot nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{vector } y \\text{ read/write}}$$\n这可以简化为：\n$$\\text{Bytes}_{\\mathrm{COO}} = nnz \\cdot (4 v_{\\mathrm{bytes}} + 2 i_{\\mathrm{bytes}})$$\n\n我们现在将这些模型应用于每个测试用例。所有运行时间均以秒报告，并四舍五入到六位小数。\n\n**测试用例 1：** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (1000, 1000, 50000, 4, 8)$\n- $\\text{FLOPs} = 2 \\cdot 50000 = 100000$。\n- $T_{\\text{compute}} = \\frac{100000}{100 \\times 10^9} = 1.0 \\times 10^{-6} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 50000 \\cdot (2 \\cdot 8 + 4) + (1000+1) \\cdot 4 + 1000 \\cdot 8 = 1012004$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{1012004}{50 \\times 10^9} \\approx 2.024008 \\times 10^{-5} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(1.0 \\times 10^{-6}, 2.024008 \\times 10^{-5}) \\approx 0.000020 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 50000 \\cdot (4 \\cdot 8 + 2 \\cdot 4) = 2000000$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{2000000}{50 \\times 10^9} = 4.0 \\times 10^{-5} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(1.0 \\times 10^{-6}, 4.0 \\times 10^{-5}) = 0.000040 \\text{ s}$。\n\n**测试用例 2：** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (5, 5, 7, 8, 8)$\n- $\\text{FLOPs} = 2 \\cdot 7 = 14$。\n- $T_{\\text{compute}} = \\frac{14}{100 \\times 10^9} = 1.4 \\times 10^{-10} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 7 \\cdot (2 \\cdot 8 + 8) + (5+1) \\cdot 8 + 5 \\cdot 8 = 256$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{256}{50 \\times 10^9} = 5.12 \\times 10^{-9} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(1.4 \\times 10^{-10}, 5.12 \\times 10^{-9}) \\approx 0.000000 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 7 \\cdot (4 \\cdot 8 + 2 \\cdot 8) = 336$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{336}{50 \\times 10^9} = 6.72 \\times 10^{-9} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(1.4 \\times 10^{-10}, 6.72 \\times 10^{-9}) \\approx 0.000000 \\text{ s}$。\n\n**测试用例 3：** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (10000, 10000, 10000, 4, 8)$\n- $\\text{FLOPs} = 2 \\cdot 10000 = 20000$。\n- $T_{\\text{compute}} = \\frac{20000}{100 \\times 10^9} = 2.0 \\times 10^{-7} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 10000 \\cdot (2 \\cdot 8 + 4) + (10000+1) \\cdot 4 + 10000 \\cdot 8 = 320004$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{320004}{50 \\times 10^9} \\approx 6.40008 \\times 10^{-6} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(2.0 \\times 10^{-7}, 6.40008 \\times 10^{-6}) \\approx 0.000006 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 10000 \\cdot (4 \\cdot 8 + 2 \\cdot 4) = 400000$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{400000}{50 \\times 10^9} = 8.0 \\times 10^{-6} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(2.0 \\times 10^{-7}, 8.0 \\times 10^{-6}) = 0.000008 \\text{ s}$。\n\n**测试用例 4：** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (20000, 2000, 80000, 4, 8)$\n- $\\text{FLOPs} = 2 \\cdot 80000 = 160000$。\n- $T_{\\text{compute}} = \\frac{160000}{100 \\times 10^9} = 1.6 \\times 10^{-6} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 80000 \\cdot (2 \\cdot 8 + 4) + (20000+1) \\cdot 4 + 20000 \\cdot 8 = 1840004$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{1840004}{50 \\times 10^9} \\approx 3.680008 \\times 10^{-5} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(1.6 \\times 10^{-6}, 3.680008 \\times 10^{-5}) \\approx 0.000037 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 80000 \\cdot (4 \\cdot 8 + 2 \\cdot 4) = 3200000$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{3200000}{50 \\times 10^9} = 6.4 \\times 10^{-5} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(1.6 \\times 10^{-6}, 6.4 \\times 10^{-5}) = 0.000064 \\text{ s}$。\n\n**测试用例 5：** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (3000, 3000, 600000, 8, 8)$\n- $\\text{FLOPs} = 2 \\cdot 600000 = 1200000$。\n- $T_{\\text{compute}} = \\frac{1200000}{100 \\times 10^9} = 1.2 \\times 10^{-5} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 600000 \\cdot (2 \\cdot 8 + 8) + (3000+1) \\cdot 8 + 3000 \\cdot 8 = 14448008$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{14448008}{50 \\times 10^9} \\approx 2.8896016 \\times 10^{-4} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(1.2 \\times 10^{-5}, 2.8896016 \\times 10^{-4}) \\approx 0.000289 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 600000 \\cdot (4 \\cdot 8 + 2 \\cdot 8) = 28800000$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{28800000}{50 \\times 10^9} = 5.76 \\times 10^{-4} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(1.2 \\times 10^{-5}, 5.76 \\times 10^{-4}) = 0.000576 \\text{ s}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes predicted runtimes for sparse matrix-vector multiplication (SpMV)\n    for CSR and COO formats based on a simplified roofline performance model.\n    \"\"\"\n\n    # Define hardware parameters from the problem statement.\n    P_peak = 100e9  # Peak floating point throughput in FLOP/s\n    B_peak = 50e9   # Peak memory bandwidth in byte/s\n\n    # Define the test suite. Each tuple is (n, m, nnz, i_bytes, v_bytes).\n    test_cases = [\n        (1000, 1000, 50000, 4, 8),\n        (5, 5, 7, 8, 8),\n        (10000, 10000, 10000, 4, 8),\n        (20000, 2000, 80000, 4, 8),\n        (3000, 3000, 600000, 8, 8),\n    ]\n\n    # List to store the results for each test case as a [T_csr, T_coo] pair.\n    results = []\n\n    for case in test_cases:\n        n, m, nnz, i_bytes, v_bytes = case\n\n        # 1. Compute FLOPs\n        # Each nonzero element results in one multiplication and one addition.\n        flops = 2 * nnz\n\n        # 2. Compute compute time\n        t_compute = flops / P_peak\n\n        # 3. Compute Bytes transferred for CSR format\n        # Bytes_CSR = (nnz*v_bytes) + (nnz*i_bytes) + ((n+1)*i_bytes) + (nnz*v_bytes) + (n*v_bytes)\n        bytes_csr = nnz * (2 * v_bytes + i_bytes) + (n + 1) * i_bytes + n * v_bytes\n        \n        # 4. Compute Bytes transferred for COO format\n        # Bytes_COO = (nnz*v_bytes) + (nnz*i_bytes) + (nnz*i_bytes) + (nnz*v_bytes) + (2*nnz*v_bytes)\n        bytes_coo = nnz * (4 * v_bytes + 2 * i_bytes)\n\n        # 5. Compute memory-bound times\n        t_mem_csr = bytes_csr / B_peak\n        t_mem_coo = bytes_coo / B_peak\n\n        # 6. Compute final predicted runtimes using the roofline model\n        t_csr = max(t_compute, t_mem_csr)\n        t_coo = max(t_compute, t_mem_coo)\n\n        results.append((t_csr, t_coo))\n\n    # Format the output as specified: [[t_1_csr,t_1_coo],[t_2_csr,t_2_coo],...]\n    # Runtimes are rounded to six decimal places.\n    output_pairs = [f\"[{t_csr:.6f},{t_coo:.6f}]\" for t_csr, t_coo in results]\n    final_output_string = f\"[{','.join(output_pairs)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在有限元分析等应用中，高效地“构建”稀疏矩阵与高效地“使用”它同等重要。本练习提出了一个高级挑战：在并行组装过程中，是先用灵活的COO格式收集数据再转换，还是直接在预分配的CSR结构中插入？您将通过建立一个详细的成本模型来量化这一决策，从而学会在复杂的性能权衡中做出有数据支持的算法选择。",
            "id": "3448718",
            "problem": "考虑在非结构化网格上，通过逐单元贡献的方式，组装一个由二阶椭圆偏微分方程的有限元 (FE) 离散化产生的全局稀疏刚度矩阵。您必须在组装过程中从两种存储格式中做出选择：坐标格式 (COO) 和压缩稀疏行 (CSR) 格式。该选择应通过一种定量启发式方法做出，该方法在指定的成本模型下比较估算的组装时间。假设最终的全局矩阵为方阵，尺寸为 $n$ 行 $n$ 列。\n\n从以下基本定义和广为接受的算法事实出发：\n\n- 在坐标格式 (COO) 中，该结构存储表示行索引、列索引和值的三元组 $(i,j,v)$。三元组在组装过程中被追加，重复的项可以在最后通过按 $(i,j)$ 排序然后对相同索引对的值求和来进行合并。按键排序的成本是基于比较的，对于 $N$ 个项目，其比较次数的规模为 $O(N \\log_2 N)$。\n- 在压缩稀疏行 (CSR) 格式中，该结构存储三个数组 $(\\text{rowptr}, \\text{colind}, \\text{data})$，使得每一行的条目都连续存储。如果在并行组装期间，通过一个符号预处理过程计算出各行的计数和偏移量，那么直接插入到 CSR 格式是可行的。并行插入通常对每行使用原子增量来分配槽位，这可能会引发竞争，其程度取决于每行的平均非零元数量和线程数。\n- 对于一个包含 $e$ 个单元且每个单元平均贡献 $c$ 个三元组的逐单元组装过程，任何合并操作前的总贡献三元组数量为 $N = e \\cdot c$。由于单元支撑域的重叠，每个唯一的全局非零元可能会接收到多次贡献。设平均重复因子为 $d$，意味着每个唯一的非零元预计平均被贡献 $d$ 次，因此唯一非零元的数量为 $m = \\frac{N}{d}$。\n- 定义每行的平均非零元数量为 $\\rho = \\frac{m}{n}$。\n- 假设在一个具有 $t$ 个线程的共享内存环境中，所有单元的贡献被分配给这些线程。对于 COO，假设使用线程局部缓冲区以避免竞争。对于 CSR，假设使用一个带有每行原子性槽位分配的预分配结构；成功插入的竞争因子按 $1 + \\phi \\cdot \\min(t-1,\\rho)$ 乘性扩展，其中 $\\phi$ 为给定的系数。\n\n假设以下标准化的单位操作成本（每个基本操作的无量纲时间单位）：\n\n- 在坐标格式中向线程局部缓冲区追加三元组：$\\alpha = 1.0$。\n- 用于按 $(i,j)$ 合并三元组的排序中的比较器成本：$\\beta = 1.0$。\n- 排序后用于（对重复项求和的）线性归约过程的每个三元组的成本：$\\gamma = 0.2$。\n- 将合并后的 COO 结构转换为最终 CSR 数组的每个条目的成本（包括对行的前缀和计算）：$\\xi = 0.5$。\n- 在确定 CSR 行偏移量的符号预处理过程中每个三元组的成本：$\\sigma = 1.5$。\n- 成功插入到预分配 CSR 中的成本（不包括竞争）：$\\kappa = 3.0$。\n- 当同一个 $(i,j)$被多次插入时，在 CSR 行内合并重复项的成本：$\\lambda = 12.0$。\n- CSR 插入的竞争系数：$\\phi = 0.5$。\n\n您的任务是实现一个启发式方法，该方法给定 $(e,c,d,n,t)$，通过从第一性原理聚合上述基本操作成本来估算 COO 和 CSR 的总标准化组装成本，然后选择成本更低的方法。使用以下建模原则来构建总成本：\n\n- 对于坐标格式 (COO)：\n  - 使用成本 $\\alpha$ 将所有 $N$ 个三元组追加到线程局部缓冲区，这会产生与 $N$ 成线性关系的成本。\n  - 合并重复项需要按 $(i,j)$ 排序，然后进行线性归约。使用基于比较的排序成本，模型为 $N \\cdot \\log_2 N$ 次比较，每次比较的成本为 $\\beta$，以及对 $N$ 个三元组进行线性扫描，每个三元组的成本为 $\\gamma$。\n  - 合并后转换为最终压缩稀疏行 (CSR) 数组的成本与唯一条目和行数成线性关系，模型为 $\\xi \\cdot (m + n)$。\n- 对于压缩稀疏行 (CSR，带预分配)：\n  - 一个符号预处理过程会访问每个贡献的三元组一次，以计算行计数和偏移量，每个三元组的成本为 $\\sigma$。\n  - 每个贡献的三元组都会执行一次提交插入到预分配的存储中。基础成本为每次插入 $\\kappa$，再乘以竞争因子 $1 + \\phi \\cdot \\min(t-1,\\rho)$。\n  - 对同一行中同一 $(i,j)$ 的重复贡献需要合并工作。将重复合并成本建模为每个唯一条目的每次额外贡献的成本为 $\\lambda$，因此整个矩阵的总重复合并工作量为 $\\lambda \\cdot m \\cdot (d - 1)$。\n\n将决策规则定义为：如果坐标格式 (COO) 的估算总成本严格小于压缩稀疏行 (CSR) 的成本，则选择 COO，否则选择 CSR。将结果编码为一个整数：选择坐标格式 (COO) 输出 $0$，选择压缩稀疏行 (CSR) 输出 $1$。\n\n实现一个程序，对以下测试套件评估此决策。每个测试用例是一个元组 $(e,c,d,n,t)$：\n\n- 测试 $1$：$(e,c,d,n,t) = (10000, 144, 4, 50000, 16)$。\n- 测试 $2$：$(e,c,d,n,t) = (50, 16, 2, 200, 2)$。\n- 测试 $3$：$(e,c,d,n,t) = (20000, 100, 20, 80000, 8)$。\n- 测试 $4$：$(e,c,d,n,t) = (20000, 144, 3, 40000, 64)$。\n- 测试 $5$：$(e,c,d,n,t) = (5000, 64, 2, 200000, 8)$。\n- 测试 $6$：$(e,c,d,n,t) = (150000, 121, 3, 180000, 32)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,\\dots,r_6]$，其中每个 $r_i$ 是集合 $\\{0,1\\}$ 中的一个整数，对应于第 $i$ 个测试的决策。",
            "solution": "问题陈述已经过评估并被认为是有效的。它具有科学依据，定义明确且客观，提出了一个与偏微分方程数值方法相关的形式化成本建模练习。所提供的参数和成本公式足以推导出一个唯一且可验证的解。\n\n任务是开发一种启发式方法，用于在组装稀疏刚度矩阵时，在坐标 (COO) 和压缩稀疏行 (CSR) 存储格式之间进行选择。该选择基于从第一性原理建模的估算组装时间的定量比较。\n\n首先，我们根据输入参数定义中间量：单元数量 $e$、每个单元的平均三元组数 $c$、平均重复因子 $d$、矩阵维度 $n$ 和线程数 $t$。\n- 包括重复项在内的总贡献三元组数量为 $N = e \\cdot c$。\n- 最终矩阵中唯一非零条目的数量为 $m = \\frac{N}{d}$。\n- 每行的平均非零元数量为 $\\rho = \\frac{m}{n}$。\n\n接下来，我们使用提供的模型和标准化的单位操作成本来构建每种格式的总成本公式。\n\n**坐标格式 (COO) 成本模型**\n\n基于 COO 的组装总成本 $C_{COO}$ 是三个阶段的总和：三元组追加、合并以及转换为 CSR。\n\n1.  **追加成本**：将 $N$ 个三元组追加到线程局部缓冲区具有线性成本。\n    $$ C_{\\text{append}} = \\alpha \\cdot N $$\n    给定 $\\alpha = 1.0$，此成本为 $1.0 \\cdot N$。\n\n2.  **合并成本**：此阶段涉及对所有 $N$ 个三元组进行排序，然后对重复项求和。\n    - 排序成本模型为 $N \\log_2 N$ 次比较，每次比较的成本为 $\\beta$。\n    $$ C_{\\text{sort}} = \\beta \\cdot N \\log_2 N $$\n    - 随后对已排序的 $N$ 个三元组进行一次线性扫描以执行归约（对重复的 $(i,j)$ 对的值求和），每个三元组的成本为 $\\gamma$。\n    $$ C_{\\text{reduce}} = \\gamma \\cdot N $$\n    - 总合并成本为 $C_{\\text{sort}} + C_{\\text{reduce}}$。给定 $\\beta = 1.0$ 和 $\\gamma = 0.2$，此成本为 $(1.0 \\cdot N \\log_2 N) + (0.2 \\cdot N)$。\n\n3.  **转换成本**：合并后，有 $m$ 个唯一的三元组。将此结构转换为最终 CSR 格式需要对 $m$ 个条目和 $n$ 行进行线性扫描。\n    $$ C_{\\text{convert}} = \\xi \\cdot (m + n) $$\n    给定 $\\xi = 0.5$，此成本为 $0.5 \\cdot (m+n)$。\n\n总的 COO 成本是这些组成部分的总和：\n$$ C_{COO} = (\\alpha \\cdot N) + (\\beta \\cdot N \\log_2 N + \\gamma \\cdot N) + \\xi \\cdot (m + n) $$\n代入常量值：\n$$ C_{COO} = N \\cdot (\\alpha + \\gamma + \\beta \\log_2 N) + \\xi \\cdot (m + n) $$\n$$ C_{COO} = N \\cdot (1.0 + 0.2 + 1.0 \\cdot \\log_2 N) + 0.5 \\cdot (m + n) $$\n$$ C_{COO} = N \\cdot (1.2 + \\log_2 N) + 0.5 \\cdot (m + n) $$\n\n**压缩稀疏行 (CSR) 成本模型**\n\n基于预分配 CSR 的组装总成本 $C_{CSR}$ 是符号预处理、带竞争的插入以及重复项合并的总和。\n\n1.  **符号预处理成本**：一个预计算步骤确定用于预分配的行计数。此过程会访问所有 $N$ 个贡献的三元组一次。\n    $$ C_{\\text{symbolic}} = \\sigma \\cdot N $$\n    给定 $\\sigma = 1.5$，此成本为 $1.5 \\cdot N$。\n\n2.  **插入成本**：$N$ 个三元组中的每一个都被插入到预分配的结构中。每次插入的成本是基础成本 $\\kappa$ 乘以一个竞争因子。\n    $$ C_{\\text{insert}} = \\kappa \\cdot N \\cdot (1 + \\phi \\cdot \\min(t-1, \\rho)) $$\n    给定 $\\kappa = 3.0$ 和 $\\phi = 0.5$，此成本为 $3.0 \\cdot N \\cdot (1 + 0.5 \\cdot \\min(t-1, \\rho))$。\n\n3.  **重复项合并成本**：当一个三元组 $(i,j,v)$ 被贡献且位置 $(i,j)$ 处已有条目时，需要进行合并操作（求和）。对于 $m$ 个唯一非零元中的每一个，平均有 $d-1$ 个重复贡献。\n    $$ C_{\\text{merge}} = \\lambda \\cdot m \\cdot (d-1) $$\n    给定 $\\lambda = 12.0$，此成本为 $12.0 \\cdot m \\cdot (d-1)$。\n\n总的 CSR 成本是这些组成部分的总和：\n$$ C_{CSR} = C_{\\text{symbolic}} + C_{\\text{insert}} + C_{\\text{merge}} $$\n$$ C_{CSR} = \\sigma \\cdot N + \\kappa \\cdot N \\cdot (1 + \\phi \\cdot \\min(t-1, \\rho)) + \\lambda \\cdot m \\cdot (d-1) $$\n代入常量值：\n$$ C_{CSR} = N \\cdot (\\sigma + \\kappa \\cdot (1 + \\phi \\cdot \\min(t-1, \\rho))) + \\lambda \\cdot m \\cdot (d-1) $$\n$$ C_{CSR} = N \\cdot (1.5 + 3.0 \\cdot (1 + 0.5 \\cdot \\min(t-1, \\rho))) + 12.0 \\cdot m \\cdot (d-1) $$\n$$ C_{CSR} = N \\cdot (4.5 + 1.5 \\cdot \\min(t-1, \\rho)) + 12.0 \\cdot m \\cdot (d-1) $$\n\n**决策规则**\n\n该启发式方法选择估算成本较低的格式。如果 $C_{COO}$ 严格小于 $C_{CSR}$，则选择 COO（输出 $0$）。否则，选择 CSR（输出 $1$）。\n$$ \\text{决策} = \\begin{cases} 0 & \\text{若 } C_{COO}  C_{CSR} \\\\ 1  \\text{若 } C_{COO} \\ge C_{CSR} \\end{cases} $$\n\n随附的程序实现了这些推导出的成本公式，以评估问题陈述中提供的每个测试用例的决策。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Evaluates the decision heuristic for COO vs. CSR assembly for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (e, c, d, n, t)\n        (10000, 144, 4, 50000, 16),\n        (50, 16, 2, 200, 2),\n        (20000, 100, 20, 80000, 8),\n        (20000, 144, 3, 40000, 64),\n        (5000, 64, 2, 200000, 8),\n        (150000, 121, 3, 180000, 32),\n    ]\n\n    # Normalized per-operation costs\n    alpha = 1.0       # Triplet append (COO)\n    beta = 1.0        # Comparator cost (COO sort)\n    gamma = 0.2       # Triplet reduction (COO coalesce)\n    xi = 0.5          # Conversion to CSR\n    sigma = 1.5       # Symbolic pass (CSR)\n    kappa = 3.0       # Insertion base cost (CSR)\n    lambda_ = 12.0    # Duplicate merge (CSR), named to avoid Python keyword\n    phi = 0.5         # Contention coefficient (CSR)\n\n    results = []\n    for case in test_cases:\n        e, c, d, n, t = case\n\n        # Calculate intermediate quantities. All calculations use floating-point\n        # arithmetic to handle potentially large numbers and ensure precision.\n        N = float(e * c)        # Total contributed triplets\n        m = N / d               # Number of unique nonzeros\n        rho = m / n             # Average nonzeros per row\n\n        # Calculate total cost for Coordinate format (COO)\n        # C_coo = N * (alpha + gamma + beta * log2(N)) + xi * (m + n)\n        cost_coo = N * (alpha + gamma + beta * np.log2(N)) + xi * (m + n)\n\n        # Calculate total cost for Compressed Sparse Row format (CSR)\n        # C_csr = N * (sigma + kappa * (1 + phi * min(t-1, rho))) + lambda * m * (d-1)\n        contention_term = min(t - 1.0, rho)\n        cost_csr = N * (sigma + kappa * (1.0 + phi * contention_term)) + lambda_ * m * (d - 1.0)\n        \n        # Apply the decision rule\n        if cost_coo  cost_csr:\n            decision = 0  # Choose COO\n        else:\n            decision = 1  # Choose CSR\n        \n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}