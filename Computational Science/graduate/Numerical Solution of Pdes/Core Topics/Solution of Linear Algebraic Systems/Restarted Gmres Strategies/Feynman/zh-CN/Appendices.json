{
    "hands_on_practices": [
        {
            "introduction": "在实际应用中，选择重启参数 $m$ 是使用 GMRES($m$) 的关键第一步，它直接影响算法的性能和资源消耗。这个选择需要在单次循环的计算成本、内存使用以及收敛速度之间进行权衡。本练习提供了一个具体的计算模型，旨在帮助您学习如何在给定的内存预算下确定最大可行的 $m$ 值，并根据不同偏微分方程离散化后算子的谱特性来预估收敛所需的循环次数 。",
            "id": "3440246",
            "problem": "考虑矩阵 $A_{\\mathrm{P}} \\in \\mathbb{R}^{N \\times N}$ 和 $A_{\\mathrm{H}} \\in \\mathbb{R}^{N \\times N}$，它们分别来自于两个偏微分方程（PDE）的有限差分法离散化：单位正方形上带有狄利克雷边界条件的泊松方程，以及带有波数 $k$ 和吸收边界条件的亥姆霍兹方程。我们使用带重启的广义最小残差（GMRES）方法（记为 GMRES$(m)$）求解 $A x = b$，其中 $m$ 是重启参数。\n\n您的内存预算最多允许同时存储 $S$ 个长度为 $N$ 的向量。在 GMRES$(m)$ 底层的 Arnoldi 过程的一个循环中，假设实现存储了以下长度为 $N$ 的向量：当前解 $x$、当前残差 $r$、一个用于形成和正交化 $A v_{j}$ 的工作向量 $w$，以及 Arnoldi 基向量 $v_{1}, \\dots, v_{m+1}$。忽略诸如赫森伯格矩阵（其大小为 $(m+1) \\times m$）等小型稠密结构的存储成本。在此模型下，根据 $S$ 确定最大可行重启参数 $m$。\n\n对于泊松方程的情形，假设已应用一个有效的对称正定（SPD）预处理器，使得预处理后算子的谱位于实区间 $[\\alpha_{\\mathrm{P}}, \\beta_{\\mathrm{P}}]$ 内，其中 $\\alpha_{\\mathrm{P}} = 0.2$ 且 $\\beta_{\\mathrm{P}} = 2.0$。对于亥姆霍兹方程的情形，假设一个移位拉普拉斯类型的预处理器产生一个正规算子，其谱位于关于原点对称的两个实区间的并集中，即 $[-\\beta_{\\mathrm{H}}, -\\alpha_{\\mathrm{H}}] \\cup [\\alpha_{\\mathrm{H}}, \\beta_{\\mathrm{H}}]$，其中 $\\alpha_{\\mathrm{H}} = 0.1$ 且 $\\beta_{\\mathrm{H}} = 2.0$。设初始残差范数为 $\\|r_{0}\\|$，目标是将其减小到 $10^{-8} \\|r_{0}\\|$。\n\n使用以下基本事实：\n- GMRES 构建一个次数为 $m$ 的残差多项式 $p_{m}$，满足 $p_{m}(0) = 1$，该多项式在克雷洛夫子空间上最小化残差范数；对于正规矩阵，$\\|r_{m}\\|/\\|r_{0}\\| \\le \\min_{p \\in \\Pi_{m},\\, p(0)=1} \\max_{\\lambda \\in \\Lambda(A)} |p(\\lambda)|$，其中 $\\Lambda(A)$ 表示 $A$ 的谱，$\\Pi_{m}$ 是次数最多为 $m$ 的多项式集合。\n- 对于包含在实区间 $[\\alpha, \\beta] \\subset (0,\\infty)$ 内的谱，使用切比雪夫多项式的极小化极大界给出 $\\|r_{m}\\|/\\|r_{0}\\| \\le 2 \\left(\\frac{\\sqrt{\\kappa}-1}{\\sqrt{\\kappa}+1}\\right)^{m}$，其中 $\\kappa = \\beta/\\alpha$ 是该区间的条件数。\n- 对于包含在对称区间对 $[-\\beta, -\\alpha] \\cup [\\alpha, \\beta]$（其中 $0  \\alpha  \\beta$）内的谱，满足 $p(0)=1$ 的最优 $m$ 次多项式可以取为 $z$ 的偶函数（即 $z^2$ 的函数），从而有效地在平方区间 $[\\alpha^{2}, \\beta^{2}]$ 内得到一个切比雪夫界，且次数降为 $\\lfloor m/2 \\rfloor$：$\\|r_{m}\\|/\\|r_{0}\\| \\le 2 \\left(\\frac{\\sqrt{\\kappa_{s}}-1}{\\sqrt{\\kappa_{s}}+1}\\right)^{\\lfloor m/2 \\rfloor}$，其中 $\\kappa_{s} = \\beta^{2}/\\alpha^{2}$。\n\n假设 $S=80$ 且 GMRES$(m)$ 算法遵循上述存储模型。确定：\n1. 最大可行重启参数 $m$。\n2. 对于泊松方程情形，达到 $\\|r\\| \\le 10^{-8}\\|r_{0}\\|$ 所需的 GMRES$(m)$ 循环的最小整数次数。\n3. 对于亥姆霍兹方程情形，达到 $\\|r\\| \\le 10^{-8}\\|r_{0}\\|$ 所需的 GMRES$(m)$ 循环的最小整数次数。\n\n请使用 LaTeX 的 pmatrix 环境将这三个答案一起以单行矩阵的形式报告。如果需要任何数值计算，请给出精确的整数；无需按有效数字进行四舍五入。",
            "solution": "用户提供了一个关于广义最小残差（GMRES）方法的分为三部分的问题。该问题定义明确，科学上合理，并包含了求解所需的所有信息。我将按顺序处理每个部分。\n\n### 第 1 部分：最大可行重启参数 $m$\n\n问题指定了一个内存预算，最多允许同时存储 $S$ 个长度为 $N$ 的向量。GMRES($m$) 算法单次循环的存储模型已明确定义。存储的长度为 $N$ 的向量总数为以下各项之和：\n\\begin{itemize}\n    \\item 当前解向量 $x$：1 个向量。\n    \\item 当前残差向量 $r$：1 个向量。\n    \\item 一个工作向量 $w$：1 个向量。\n    \\item Arnoldi 基向量 $v_1, \\dots, v_{m+1}$：$m+1$ 个向量。\n\\end{itemize}\n因此，存储的向量总数为 $1 + 1 + 1 + (m+1)$，化简为 $m+4$。\n\n这个总数不能超过内存预算 $S$。因此，我们得到不等式：\n$$ m + 4 \\le S $$\n已知存储预算为 $S = 80$，我们可以将此值代入不等式：\n$$ m + 4 \\le 80 $$\n解出 $m$：\n$$ m \\le 80 - 4 $$\n$$ m \\le 76 $$\n最大可行重启参数 $m$ 是满足此条件的最大整数。因此，最大重启值为 $m=76$。该值将用于问题的后续部分。\n\n### 第 2 部分：泊松方程情形的最小循环次数\n\n对于预处理后的泊松问题，算子的谱位于实区间 $[\\alpha_{\\mathrm{P}}, \\beta_{\\mathrm{P}}]$ 内，其中 $\\alpha_{\\mathrm{P}} = 0.2$ 且 $\\beta_{\\mathrm{P}} = 2.0$。此谱区间的条件数为：\n$$ \\kappa_{\\mathrm{P}} = \\frac{\\beta_{\\mathrm{P}}}{\\alpha_{\\mathrm{P}}} = \\frac{2.0}{0.2} = 10 $$\n问题给出了 GMRES($m$) 单次循环的收敛界：\n$$ \\frac{\\|r_{m}\\|}{\\|r_{0}\\|} \\le 2 \\left(\\frac{\\sqrt{\\kappa_{\\mathrm{P}}}-1}{\\sqrt{\\kappa_{\\mathrm{P}}}+1}\\right)^{m} $$\n设 $\\rho_{\\mathrm{P}}$ 为单次循环的残差缩减因子。使用 $m=76$ 和 $\\kappa_{\\mathrm{P}}=10$，我们有：\n$$ \\rho_{\\mathrm{P}} = 2 \\left(\\frac{\\sqrt{10}-1}{\\sqrt{10}+1}\\right)^{76} $$\n设 $C_{\\mathrm{P}}$ 为达到总残差缩减 $10^{-8}$ 所需的最小整数循环次数。条件为：\n$$ (\\rho_{\\mathrm{P}})^{C_{\\mathrm{P}}} \\le 10^{-8} $$\n我们首先计算 $\\rho_{\\mathrm{P}}$。括号内的项是 $\\frac{\\sqrt{10}-1}{\\sqrt{10}+1} \\approx 0.5195$。将其提高到 76 次方会得到一个极小的数。我们来更形式化地分析这一点。\n对于单次循环（$C_{\\mathrm{P}}=1$），我们检查是否 $\\rho_{\\mathrm{P}} \\le 10^{-8}$：\n$$ 2 \\left(\\frac{\\sqrt{10}-1}{\\sqrt{10}+1}\\right)^{76} \\le 10^{-8} $$\n对两边取自然对数：\n$$ \\ln(2) + 76 \\ln\\left(\\frac{\\sqrt{10}-1}{\\sqrt{10}+1}\\right) \\le \\ln(10^{-8}) $$\n$$ \\ln(2) + 76 \\ln\\left(\\frac{\\sqrt{10}-1}{\\sqrt{10}+1}\\right) \\le -8 \\ln(10) $$\n使用数值，$\\ln(2) \\approx 0.6931$ 且 $\\ln(10) \\approx 2.3026$。项 $\\ln\\left(\\frac{\\sqrt{10}-1}{\\sqrt{10}+1}\\right) \\approx -0.6549$。\n$$ 0.6931 + 76 \\times (-0.6549) \\approx 0.6931 - 49.7724 = -49.0793 $$\n不等式右边是 $-8 \\times 2.3026 = -18.4208$。\n不等式变为：\n$$ -49.0793 \\le -18.4208 $$\n此不等式成立。单次循环的缩减因子远小于要求的容差 $10^{-8}$。因此，单次循环就足够了。\n最小整数循环次数为 $C_{\\mathrm{P}} = 1$。\n\n### 第 3 部分：亥姆霍兹方程情形的最小循环次数\n\n对于预处理后的亥姆霍兹问题，谱是正规的且包含在 $[-\\beta_{\\mathrm{H}}, -\\alpha_{\\mathrm{H}}] \\cup [\\alpha_{\\mathrm{H}}, \\beta_{\\mathrm{H}}]$ 内，其中 $\\alpha_{\\mathrm{H}} = 0.1$ 且 $\\beta_{\\mathrm{H}} = 2.0$。收敛界使用一个修正的条件数 $\\kappa_s$：\n$$ \\kappa_s = \\frac{\\beta_{\\mathrm{H}}^2}{\\alpha_{\\mathrm{H}}^2} = \\frac{(2.0)^2}{(0.1)^2} = \\frac{4}{0.01} = 400 $$\n单次循环的收敛因子 $\\rho_{\\mathrm{H}}$ 由下式给出：\n$$ \\rho_{\\mathrm{H}} = 2 \\left(\\frac{\\sqrt{\\kappa_s}-1}{\\sqrt{\\kappa_s}+1}\\right)^{\\lfloor m/2 \\rfloor} $$\n使用 $m=76$，我们得到 $\\lfloor m/2 \\rfloor = \\lfloor 76/2 \\rfloor = 38$。并且 $\\sqrt{\\kappa_s} = \\sqrt{400}=20$。\n$$ \\rho_{\\mathrm{H}} = 2 \\left(\\frac{20-1}{20+1}\\right)^{38} = 2 \\left(\\frac{19}{21}\\right)^{38} $$\n设 $C_{\\mathrm{H}}$ 为最小循环次数。我们需要找到最小的整数 $C_{\\mathrm{H}}$ 使得：\n$$ (\\rho_{\\mathrm{H}})^{C_{\\mathrm{H}}} \\le 10^{-8} $$\n取自然对数：\n$$ C_{\\mathrm{H}} \\ln(\\rho_{\\mathrm{H}}) \\le \\ln(10^{-8}) = -8 \\ln(10) $$\n我们计算 $\\ln(\\rho_{\\mathrm{H}})$：\n$$ \\ln(\\rho_{\\mathrm{H}}) = \\ln\\left(2 \\left(\\frac{19}{21}\\right)^{38}\\right) = \\ln(2) + 38 \\ln\\left(\\frac{19}{21}\\right) $$\n使用数值，$\\ln(2) \\approx 0.693147$ 且 $\\ln(19/21) \\approx -0.100083$。\n$$ \\ln(\\rho_{\\mathrm{H}}) \\approx 0.693147 + 38 \\times (-0.100083) \\approx 0.693147 - 3.803154 = -3.110007 $$\n关于 $C_{\\mathrm{H}}$ 的不等式变为（注意我们除以一个负数，所以不等号反向）：\n$$ C_{\\mathrm{H}} \\ge \\frac{-8 \\ln(10)}{\\ln(\\rho_{\\mathrm{H}})} \\approx \\frac{-18.42068}{-3.110007} \\approx 5.9229 $$\n因为 $C_{\\mathrm{H}}$ 必须是整数，我们取该值的上取整：\n$$ C_{\\mathrm{H}} = \\lceil 5.9229 \\rceil = 6 $$\n亥姆霍兹方程情形所需的最小整数循环次数为 $C_{\\mathrm{H}} = 6$。\n\n总结一下，三个答案是：\n1.  最大可行重启参数 $m = 76$。\n2.  泊松方程情形的最小循环次数 $C_{\\mathrm{P}} = 1$。\n3.  亥姆霍兹方程情形的最小循环次数 $C_{\\mathrm{H}} = 6$。\n这些将按要求以单行矩阵的形式报告。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n76  1  6\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "重启 GMRES 最重要且时常违反直觉的行为之一是其可能出现的停滞现象，尤其是在处理对流主导问题中常见的强非正规矩阵时。这个动手编程练习将指导您构建一个典型的非正规算子（移位矩阵），并亲手验证停滞现象的发生 。通过分析其背后的 Krylov 子空间和残差多项式，本练习揭示了为何该方法可能无法取得任何进展，从而加深您对 GMRES($m$) 算法局限性的理解。",
            "id": "3440218",
            "problem": "考虑一维线性平流偏微分方程 $u_t + a u_x = 0$，定义在区间 $[0,1]$ 上，其中平流速度 $a  0$ 为常数。在 $n$ 个内部点上采用显式流入边界和吸收性流出的标准基于网格的离散化，可以从两个互补的视角来看待：\n\n1. 一个由 $u_x$ 的单边（迎风）差分构建的半离散生成元，它产生一个下双对角矩阵。该矩阵只有一个特征值和一条Jordan链，因此是强非正规的。\n\n2. 一个离散时间传播子，当库朗数等于1时，它将状态精确地向前移动一个网格单元。这通过一个严格下移位来实现，对应于在具有吸收性流出的均匀网格上进行单步平流。\n\n在本问题中，您将构造一个离散化平流算子 $A$，它通过严格下移位表现出强非正规性，并分析维数为 $m$ 的重启广义最小残差（GMRES）方法（记为GMRES($m$)）的行为，包括残差多项式 $p_m(A)$ 的作用。在每个周期中，对于初始残差 $r_0$，该多项式满足 $p_m(0) = 1$ 并最小化 $\\lVert p_m(A) r_0 \\rVert_2$。您将把它与一个通过中心差分周期性离散化得到的正规算子进行对比。\n\n从以下基本概念出发：\n- 平流定律 $u_t + a u_x = 0$，\n- 在具有流入和吸收性流出的均匀网格上的线性平流，当库朗数为1时产生一个离散时间移位算子，\n- Krylov子空间定义 $\\mathcal{K}_m(A,r_0) = \\mathrm{span}\\{r_0, A r_0, \\dots, A^{m-1} r_0\\}$，\n- 广义最小残差（GMRES）方法，它在 $x_0 + \\mathcal{K}_m(A,r_0)$ 上最小化残差范数，以及残差多项式表征 $r_m = p_m(A) r_0$（其中 $p_m(0)=1$），\n\n完成以下任务：\n\na) 构造严格下移位矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其定义为 $(A)_{i,i-1} = 1$（对于 $i=2,\\dots,n$）且所有其他元素为零。将 $A$ 解释为具有吸收性流出的单步离散平流传播子。解释为什么 $A$ 是强非正规的，并描述其Jordan范式。\n\nb) 使用Arnoldi过程实现重启的GMRES($m$)，其中 $x_0 = 0$。在每个周期中，执行 $m$ 个内步骤，更新近似解，并记录每个周期结束时的残差范数。对于由严格下移位给出的 $A$，展示GMRES($m$)在何种条件下会停滞，即残差范数在不同周期之间不减小。\n\nc) 当初始残差的第一个非零分量在索引 $j$ 处时（即 $r_0 = \\alpha e_j + (\\text{更高索引项})$），分析严格下移位的残差多项式 $p_m(A)$ 的作用。确定约束 $p_m(0)=1$ 和像空间 $A \\mathcal{K}_m(A,r_0)$ 如何限制可能的残差分量，并解释为什么对于许多右端项（例如，$r_0 = e_1$），最小化多项式 $p_m$ 会得到 $r_m = r_0$，从而导致停滞。\n\nd) 使用 $u_x$ 的中心差分空间离散化，在周期性网格上构造一个正规的平流相关算子 $A_{\\mathrm{per}}$：定义前向移位 $P$ 为 $(P)_{i,(i \\bmod n)+1} = 1$，令 $h = 1/n$，并构造 $D = \\frac{1}{2h} (P - P^\\top)$，然后对于一个固定的 $\\gamma  0$ 设置 $A_{\\mathrm{per}} = I - \\gamma D$。解释为什么 $D$ 是斜对称的，因而是正规的，并论证 $A_{\\mathrm{per}}$ 是正规的且对于GMRES($m$)表现更好，通常能避免停滞。\n\n您的程序必须实现GMRES($m$)算法并评估以下测试套件。对于每个测试用例，运行固定数量的重启周期，并输出一个布尔值指示是否发生停滞。停滞定义为：初始和最终残差范数的绝对差小于 $10^{-10}$，并且在每个周期中，残差范数都是非增的且变化量小于 $10^{-10}$。\n\n测试套件：\n- 情况1：$A$ 是严格下移位矩阵，$n=60$，$m=8$，$r_0 = e_1$，周期数 $= 5$。\n- 情况2：$A$ 是严格下移位矩阵，$n=60$，$m=8$，$r_0$ 是一个在 $[-1,1]^n$ 上均匀分布的随机向量，确定性种子为 $42$，周期数 $= 5$。\n- 情况3：$A_{\\mathrm{per}} = I - \\gamma D$，其中 $D$ 是如上所述的周期性中心差分，$n=60$，$\\gamma = 0.1$，$m=8$，$r_0$ 是一个在 $[-1,1]^n$ 上均匀分布的随机向量，确定性种子为 $7$，周期数 $= 5$。\n- 情况4：$A$ 是严格下移位矩阵，$n=30$，$m=1$，$r_0$ 是一个在 $[-1,1]^n$ 上均匀分布的随机向量，确定性种子为 $123$，周期数 $= 6$。\n\n您的程序应生成一行输出，其中包含四个情况的停滞结果，格式为方括号括起来的逗号分隔列表（例如，\"[$result1$,$result2$,$result3$,$result4$]\"），其中每个 $result$ 是 \"True\" 或 \"False\"。不涉及物理单位或角度单位；所有值都是无量纲的。",
            "solution": "该问题要求通过对比重启的广义最小残差方法GMRES($m$)在两个不同线性算子上的行为，来对其进行分析。这两个算子都源自一维线性平流方程 $u_t + a u_x = 0$。一个算子是严格下移位矩阵 $A$，它是强非正规的，并作为具有吸收性流出的纯平流模型。另一个算子 $A_{\\mathrm{per}}$ 是一个正规矩阵，源自周期性域上的中心差分离散化。分析的核心在于理解这些算子的代数性质（特别是正规性）如何影响GMRES($m$)的收敛性和可能的停滞。\n\n我们的任务是求解线性系统 $A x = b$。GMRES($m$)算法从一个初始猜测 $x_0$ 开始，计算初始残差 $r_0 = b - A x_0$。由于问题指定 $x_0=0$，初始残差就是右端项 $r_0=b$。然后算法迭代地改进解。\n\n**a) 严格下移位算子：构造与性质**\n\n严格下移位矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 由其元素 $(A)_{i,j} = \\delta_{i, j+1}$ 定义，或者更明确地说，$(A)_{i, i-1} = 1$（对于 $i=2, \\ldots, n$），所有其他元素均为零。\n$$\nA = \\begin{pmatrix}\n0  0  \\dots  0  0 \\\\\n1  0  \\dots  0  0 \\\\\n0  1  \\dots  0  0 \\\\\n\\vdots  \\vdots  \\ddots  \\vdots  \\vdots \\\\\n0  0  \\dots  1  0\n\\end{pmatrix}\n$$\n该算子模拟了一个在 $n$ 个点组成的均匀网格上的离散单步平流过程。如果向量 $v \\in \\mathbb{R}^n$ 代表网格上的状态，那么 $Av$ 代表库朗数为1时，经过一个时间步后的状态。网格点 $j-1$ 上的值被移位到网格点 $j$。网格点 $n$ 上的值被移出域（吸收性流出），而在网格点 $1$ 处进入一个值为 $0$ 的量（零流入条件）。\n\n一个矩阵如果与其共轭转置交换（即 $A^*A = AA^*$），则被定义为正规矩阵。对于实矩阵，此条件为 $A^\\top A = A A^\\top$。$A$ 的转置是严格上移位矩阵：\n$$\nA^\\top = \\begin{pmatrix}\n0  1  0  \\dots  0 \\\\\n0  0  1  \\dots  0 \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots \\\\\n0  0  0  \\dots  1 \\\\\n0  0  0  \\dots  0\n\\end{pmatrix}\n$$\n我们计算乘积：\n$$\nA A^\\top = \\text{diag}(0, 1, 1, \\dots, 1) \\in \\mathbb{R}^{n \\times n}\n$$\n$$\nA^\\top A = \\text{diag}(1, 1, \\dots, 1, 0) \\in \\mathbb{R}^{n \\times n}\n$$\n由于 $A A^\\top \\neq A^\\top A$，矩阵 $A$ 是非正规的。这些乘积之间的显著差异表明了强非正规性。\n\n$A$ 的特征值是其特征多项式 $\\det(A - \\lambda I) = (-\\lambda)^n=0$ 的根。因此，唯一的特征值是 $\\lambda=0$，其代数重数为 $n$。几何重数是零空间 $\\text{ker}(A)$ 的维数，该空间由向量 $e_1 = [1, 0, \\dots, 0]^\\top$ 张成。由于几何重数（$1$）严格小于代数重数（$n$），该矩阵是亏损的且不可对角化。它是一个幂零矩阵，因为当 $k  n$ 时 $A^k \\neq 0$ 但 $A^n=0$。其最小多项式为 $p(\\lambda) = \\lambda^n$。这种结构意味着 $A$ 的Jordan范式由一个对应于特征值 $0$ 的大小为 $n$ 的Jordan块组成，我们记为 $J_n(0)$。矩阵 $A$ 与 $J_n(0)^\\top$ 置换相似。这种极端的亏损性是强非正规性的一个标志。\n\n**b) 重启的GMRES($m$)与停滞条件**\n\nGMRES($m$) 寻找一个近似解 $x_m \\in x_0 + \\mathcal{K}_m(A, r_0)$，以最小化残差 $r_m = b - Ax_m$ 的欧几里得范数。搜索空间 $\\mathcal{K}_m(A, r_0) = \\text{span}\\{r_0, A r_0, \\dots, A^{m-1} r_0\\}$ 是维数至多为 $m$ 的Krylov子空间。经过 $m$ 次Arnoldi过程的迭代后，解被更新，然后算法使用新的残差作为下一个Krylov子空间的起始向量进行重启。\n\n当一个重启周期未能减小残差范数时，就会发生停滞。对于移位算子 $A$，让我们分析残差更新的结构。更新后的残差 $r_m$ 可以表示为 $r_m = r_0 - A z_m$，其中 $z_m$ 是某个属于 $\\mathcal{K}_m(A, r_0)$ 的向量。移位矩阵 $A$ 的一个关键性质是，对于任何向量 $v \\in \\mathbb{R}^n$， $Av$ 的第一个分量为零：$(Av)_1 = 0$。因此，无论如何选择 $z_m \\in \\mathcal{K}_m(A, r_0)$，$A z_m$ 的第一个分量也必须为零。\n\n这导致了关于残差第一个分量的一个关键观察：\n$$\n(r_m)_1 = (r_0)_1 - (A z_m)_1 = (r_0)_1 - 0 = (r_0)_1\n$$\n在整个GMRES过程中，残差的第一个分量是不变的。因此，如果 $(r_0)_1 \\neq 0$，残差范数永远无法减小到零。$\\lVert r_m \\rVert_2 \\geq |(r_m)_1| = |(r_0)_1|$。\n\n最严格意义上的停滞（范数无减小）发生在当最小化的选择为 $z_m = 0$ 时。这在子空间 $A \\mathcal{K}_m(A, r_0)$ 与 $r_0$ 正交时发生，或者更一般地，当 $A \\mathcal{K}_m(A, r_0)$ 中的任何向量都会增加残差范数时。\n\n**c) 用于停滞分析的残差多项式**\n\nGMRES残差可以用一个多项式来表征。该方法找到一个次数至多为 $m$ 且满足 $p_m(0)=1$ 的多项式 $p_m$，它最小化 $\\lVert p_m(A) r_0 \\rVert_2$。任何这样的多项式都可以写成 $p_m(z) = 1 + q_m(z)$，其中 $q_m(z)$ 是一个次数至多为 $m$ 且满足 $q_m(0)=0$ 的多项式，即 $q_m(z) = c_1 z + c_2 z^2 + \\dots + c_m z^m$。\n\n残差为 $r_m = p_m(A)r_0 = (I + c_1 A + \\dots + c_m A^m)r_0$。\n考虑初始残差为 $r_0 = e_1$ 的情况。Krylov向量为 $A^k r_0 = A^k e_1 = e_{k+1}$（对于 $k=0, \\dots, n-1$）。\n残差向量是：\n$$\nr_m = e_1 + c_1 A e_1 + \\dots + c_m A^m e_1 = e_1 + c_1 e_2 + \\dots + c_m e_{m+1}\n$$\n该残差的范数平方为：\n$$\n\\lVert r_m \\rVert_2^2 = \\lVert e_1 + c_1 e_2 + \\dots + c_m e_{m+1} \\rVert_2^2 = \\lVert e_1 \\rVert_2^2 + \\sum_{k=1}^m |c_k|^2 = 1 + \\sum_{k=1}^m |c_k|^2\n$$\n当所有系数 $c_k=0$（对于 $k=1, \\dots, m$）时，此表达式最小化。这对应于多项式 $p_m(z)=1$。产生的最小残差为 $r_m = I r_0 = r_0$。残差范数保持不变，因此对于任何 $m  n$，GMRES($m$)都会停滞。\n\n更一般地，如果 $r_0$ 的第一个非零分量在索引 $j$ 处（$r_0 = \\alpha_j e_j + \\dots$），那么Krylov子空间 $\\mathcal{K}_m(A, r_0)$ 中的任何向量 $v$ 的前 $j-1$ 个分量都将为零。像空间 $A \\mathcal{K}_m(A, r_0)$ 中的任何向量 $w$ 的前 $j$ 个分量都将为零。残差为 $r_m = r_0 - w$，因此 $r_m$ 的前 $j$ 个分量与 $r_0$ 的相同。这严重限制了GMRES减小残差的能力，常常导致停滞或极慢的收敛。\n\n**d) 用于周期性平流的正规算子**\n\n考虑将域 $[0,1]$ 视为周期性的，会得到一种不同的离散化。在网格间距为 $h=1/n$ 的网格上，对空间导数 $u_x$ 使用中心差分，得到离散算子 $D$。令 $P$ 为前向循环移位矩阵，定义为 $(P)_{i,j}=1$（如果 $j \\equiv i+1 \\pmod n$，使用从0开始的索引 $j=(i+1)\\%n$ 或从1开始的索引 $j=(i \\pmod n) + 1$），否则为 $0$。$P$ 是一个置换矩阵，因此是正交（酉）矩阵，所以 $P^{-1} = P^\\top$。$P^\\top$ 是后向循环移位。\n\n中心差分算子为 $D = \\frac{1}{2h}(P - P^\\top)$。我们检查其对称性：\n$$\nD^\\top = \\frac{1}{2h}(P - P^\\top)^\\top = \\frac{1}{2h}(P^\\top - (P^\\top)^\\top) = \\frac{1}{2h}(P^\\top - P) = -D\n$$\n由于 $D^\\top = -D$，$D$ 是斜对称的。任何斜对称矩阵都是正规的，因为 $D D^\\top = D(-D) = -D^2$ 且 $D^\\top D = (-D)D = -D^2$。\n\n问题定义的系统矩阵为 $A_{\\mathrm{per}} = I - \\gamma D$，其中 $\\gamma  0$。我们检查 $A_{\\mathrm{per}}$ 是否为正规矩阵：\n$$\n(A_{\\mathrm{per}})^\\top = (I - \\gamma D)^\\top = I^\\top - \\gamma D^\\top = I + \\gamma D\n$$\n$$\nA_{\\mathrm{per}}(A_{\\mathrm{per}})^\\top = (I - \\gamma D)(I + \\gamma D) = I + \\gamma D - \\gamma D - \\gamma^2 D^2 = I - \\gamma^2 D^2\n$$\n$$\n(A_{\\mathrm{per}})^\\top A_{\\mathrm{per}} = (I + \\gamma D)(I - \\gamma D) = I - \\gamma D + \\gamma D - \\gamma^2 D^2 = I - \\gamma^2 D^2\n$$\n由于 $A_{\\mathrm{per}}(A_{\\mathrm{per}})^\\top = (A_{\\mathrm{per}})^\\top A_{\\mathrm{per}}$，矩阵 $A_{\\mathrm{per}}$ 是正规的。\n\n一个正规矩阵是可酉对角化的。GMRES在正规矩阵上的收敛性由其特征值的分布决定。实斜对称矩阵 $D$ 的特征值是纯虚数，例如 $i\\mu_k$。因此，$A_{\\mathrm{per}}$ 的特征值为 $\\lambda_k = 1 - \\gamma (i\\mu_k) = 1 - i\\gamma\\mu_k$。它们都位于复平面上 $\\text{Re}(z)=1$ 这条竖直线上。对于正规矩阵，GMRES在特征值上找到最优的多项式逼近。与非正规情况不同，不存在算子幂的瞬态增长，并且在Arnoldi过程的每一步中，残差范数都保证是非增的。除非已经找到解，否则不会出现像移位矩阵那样的停滞（即方法取得零进展）。因此，可以预期 $A_{\\mathrm{per}}$ 对于GMRES($m$)的表现会好得多，避免了非正规移位算子的严重停滞问题。",
            "answer": "```python\nimport numpy as np\n\ndef gmres_m(A, b, m, cycles, x0=None):\n    \"\"\"\n    Implements the restarted Generalized Minimal Residual (GMRES(m)) method.\n\n    Args:\n        A (np.ndarray): The coefficient matrix of the linear system.\n        b (np.ndarray): The right-hand side vector.\n        m (int): The restart parameter (dimension of the Krylov subspace).\n        cycles (int): The number of restart cycles to perform.\n        x0 (np.ndarray, optional): The initial guess. Defaults to zero vector.\n\n    Returns:\n        tuple: A tuple containing:\n            - list[float]: Residual norms at the end of each cycle (including initial).\n            - np.ndarray: The final approximate solution vector.\n    \"\"\"\n    n = A.shape[0]\n    if x0 is None:\n        x = np.zeros(n)\n    else:\n        x = x0.copy()\n\n    residual_norms = []\n    \n    # Initial residual\n    r = b - A @ x\n    r_norm = np.linalg.norm(r)\n    residual_norms.append(r_norm)\n\n    for _ in range(cycles):\n        if r_norm  1e-12: # System solved\n            break\n\n        # Arnoldi process to build orthonormal basis V for Krylov subspace\n        V = np.zeros((n, m + 1))\n        H = np.zeros((m + 1, m))\n        \n        V[:, 0] = r / r_norm\n        \n        # Effective dimension of Krylov subspace in case of breakdown\n        j = 0\n        for j_iter in range(m):\n            j = j_iter\n            # w = A * v_j\n            w = A @ V[:, j]\n            \n            # Orthogonalize w against previous V vectors (Modified Gram-Schmidt)\n            for i in range(j + 1):\n                H[i, j] = V[:, i].T @ w\n                w = w - H[i, j] * V[:, i]\n            \n            H[j + 1, j] = np.linalg.norm(w)\n            \n            if H[j + 1, j]  1e-12: # Lucky breakdown: exact solution found\n                j += 1 # To make slicing work correctly later\n                break\n            \n            V[:, j + 1] = w / H[j + 1, j] \n        else:\n            j += 1 # Loop completed normally\n\n        # Solve the small least-squares problem\n        # min || beta * e_1 - H * y ||_2\n        beta_e1 = np.zeros(j + 1)\n        beta_e1[0] = r_norm\n        \n        # We need to solve for y in H[:j+1, :j] y = beta_e1[:j+1]\n        y, _, _, _ = np.linalg.lstsq(H[:j+1, :j], beta_e1, rcond=None)\n        \n        # Update solution\n        # x_m = x_0 + V_m y_m\n        x += V[:, :j] @ y\n\n        # Recompute residual for robustness\n        r = b - A @ x\n        r_norm = np.linalg.norm(r)\n        residual_norms.append(r_norm)\n        \n    return residual_norms, x\n\ndef check_stagnation(norms: list[float]) -> bool:\n    \"\"\"\n    Checks for stagnation based on the problem's specific definition.\n\n    Stagnation is defined as:\n    1. The absolute difference between the initial and final residual norms is  1e-10.\n    2. The residual norms across cycles are nonincreasing with changes  1e-10 at every cycle.\n    \"\"\"\n    initial_norm = norms[0]\n    final_norm = norms[-1]\n    \n    # Condition 1\n    if abs(initial_norm - final_norm) >= 1e-10:\n        return False\n        \n    # Condition 2\n    for i in range(1, len(norms)):\n        # Check nonincreasing and change magnitude\n        if not (norms[i] = norms[i-1] and (norms[i-1] - norms[i])  1e-10):\n            return False\n            \n    return True\n\ndef solve():\n    \"\"\"\n    Sets up and runs the four test cases specified in the problem.\n    \"\"\"\n    results = []\n\n    # Case 1: Shift operator, r0 = e1\n    n1 = 60\n    m1 = 8\n    cycles1 = 5\n    A1 = np.diag(np.ones(n1 - 1), -1)\n    b1 = np.zeros(n1)\n    b1[0] = 1.0\n    norms1, _ = gmres_m(A1, b1, m=m1, cycles=cycles1)\n    results.append(check_stagnation(norms1))\n\n    # Case 2: Shift operator, random r0\n    n2 = 60\n    m2 = 8\n    cycles2 = 5\n    A2 = np.diag(np.ones(n2 - 1), -1)\n    rng2 = np.random.default_rng(42)\n    b2 = rng2.uniform(-1, 1, n2)\n    norms2, _ = gmres_m(A2, b2, m=m2, cycles=cycles2)\n    results.append(check_stagnation(norms2))\n\n    # Case 3: Normal periodic operator, random r0\n    n3 = 60\n    gamma3 = 0.1\n    m3 = 8\n    cycles3 = 5\n    h3 = 1.0 / n3\n    # P is a forward circulant shift matrix\n    # P_ij=1 for j=(i+1)%n (0-based)\n    # This corresponds to rolling columns to the left (or rows down)\n    P3 = np.roll(np.eye(n3), 1, axis=0)\n    D3 = (1.0 / (2.0 * h3)) * (P3 - P3.T)\n    A3 = np.eye(n3) - gamma3 * D3\n    rng3 = np.random.default_rng(7)\n    b3 = rng3.uniform(-1, 1, n3)\n    norms3, _ = gmres_m(A3, b3, m=m3, cycles=cycles3)\n    results.append(check_stagnation(norms3))\n\n    # Case 4: Shift operator, m=1, random r0\n    n4 = 30\n    m4 = 1\n    cycles4 = 6\n    A4 = np.diag(np.ones(n4 - 1), -1)\n    rng4 = np.random.default_rng(123)\n    b4 = rng4.uniform(-1, 1, n4)\n    norms4, _ = gmres_m(A4, b4, m=m4, cycles=cycles4)\n    results.append(check_stagnation(norms4))\n\n    print(f\"[{','.join(map(str, [r.title() for r in results]))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Arnoldi 过程的理论优雅性在有限精度计算中会受到挑战，导致计算出的 Krylov 基向量失去正交性。本数值实验深入探讨了这一关键的实现细节，要求您比较一种数值不稳定的正交化方案（经典 Gram-Schmidt）和一种更稳健的方案（带重正交化的改进 Gram-Schmidt）。通过量化正交性的损失及其对最终解精度的影响，本练习突出了数值稳定性在开发可靠迭代求解器中的核心重要性。",
            "id": "3440205",
            "problem": "设计并实现一个数值实验，以量化有限精度舍入误差在将带重启的广义最小残差（GMRES）方法（记为 GMRES($m$)）应用于偏微分方程离散化所产生的线性系统时的影响。该实验必须分离并比较两种现象：周期内的 Arnoldi 过程稳定性与周期间的重启稳健性。您的程序必须从一维对流扩散算子构造病态矩阵，在 GMRES($m$) 内部实现两种正交化策略，并输出如下指定的量化指标。\n\n您必须仅基于以下基本要素进行推导和算法设计：Krylov 子空间方法的定义、Arnoldi 过程、广义最小残差（GMRES）方法，以及标准的浮点舍入误差考量。\n\n1. 数学模型与离散化。考虑单位区间上的带齐次 Dirichlet 边界条件的一维对流扩散边界值问题，写作\n$$\n-\\varepsilon u''(x) + \\beta u'(x) = f(x), \\quad x \\in (0,1), \\quad u(0)=u(1)=0,\n$$\n其中 $\\varepsilon  0$ 是一个扩散系数，$\\beta$ 是一个常数对流速度。在一个包含 $n$ 个内部点的均匀网格上，使用中心差分对 $u''$ 和 $u'$ 进行离散化，网格间距为 $h = \\frac{1}{n+1}$。这将产生一个稀疏三对角矩阵 $\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$，其元素为\n$$\n\\mathbf{A}_{i,i} = \\frac{2\\varepsilon}{h^2}, \\quad\n\\mathbf{A}_{i,i-1} = -\\frac{\\varepsilon}{h^2} - \\frac{\\beta}{2h}, \\quad\n\\mathbf{A}_{i,i+1} = -\\frac{\\varepsilon}{h^2} + \\frac{\\beta}{2h},\n$$\n对于 $i=1,\\dots,n$，超出范围的索引被省略。选择右端项 $\\mathbf{b} \\in \\mathbb{R}^n$，其元素 $\\mathbf{b}_i = 1$ 对所有 $i$ 成立。最终得到的线性系统是 $\\mathbf{A}\\mathbf{x}=\\mathbf{b}$。\n\n2. Krylov 子空间、Arnoldi 过程和 GMRES($m$) 方法。对于给定的初始残差 $\\mathbf{r}_0 = \\mathbf{b} - \\mathbf{A}\\mathbf{x}_0$（其中 $\\mathbf{x}_0 = \\mathbf{0}$），带重启参数 $m$ 的 GMRES 方法使用 Arnoldi 过程为 Krylov 子空间构建一个标准正交基 $\\mathbf{V}_{m+1} = [\\mathbf{v}_1,\\dots,\\mathbf{v}_{m+1}]$，并产生 Arnoldi 关系式\n$$\n\\mathbf{A}\\mathbf{V}_m = \\mathbf{V}_{m+1}\\overline{\\mathbf{H}}_m,\n$$\n其中 $\\mathbf{V}_m = [\\mathbf{v}_1,\\dots,\\mathbf{v}_m]$，$\\overline{\\mathbf{H}}_m \\in \\mathbb{R}^{(m+1)\\times m}$ 是上 Hessenberg 矩阵，且 $\\mathbf{v}_1 = \\mathbf{r}_0/\\|\\mathbf{r}_0\\|_2$。$m$ 步 GMRES 更新求解最小二乘问题\n$$\n\\min_{\\mathbf{y}\\in\\mathbb{R}^m}\\left\\|\\beta \\mathbf{e}_1 - \\overline{\\mathbf{H}}_m \\mathbf{y}\\right\\|_2, \\quad \\beta = \\|\\mathbf{r}_0\\|_2,\n$$\n并应用更新 $\\mathbf{x} \\leftarrow \\mathbf{x} + \\mathbf{V}_m \\mathbf{y}$。重启过程使用新的残差 $\\mathbf{r} = \\mathbf{b} - \\mathbf{A}\\mathbf{x}$ 重复此循环。\n\n3. 舍入误差、正交化策略和度量指标。在有限精度下，Arnoldi 基向量会失去正交性。实现并比较以下周期内正交化策略：\n- 单遍经典 Gram-Schmidt (CGS) 正交化，这种方法更容易因舍入误差导致正交性损失。\n- 带重正交化的修正 Gram-Schmidt (MGS) 正交化（即第二遍 MGS），这种方法通常更稳定。\n\n在每个 GMRES($m$) 周期中，计算以下两个周期内稳定性指标：\n- 最大周期内正交性损失\n$$\n\\eta = \\max_{1 \\leq j \\leq m} \\left\\| \\mathbf{V}_j^\\top \\mathbf{V}_j - \\mathbf{I}_j \\right\\|_F,\n$$\n其中 $\\mathbf{V}_j = [\\mathbf{v}_1,\\dots,\\mathbf{v}_j]$，$\\|\\cdot\\|_F$ 表示 Frobenius 范数。\n- 归一化的 Arnoldi 关系式残差\n$$\n\\tau = \\frac{\\left\\|\\mathbf{A}\\mathbf{V}_m - \\mathbf{V}_{m+1}\\overline{\\mathbf{H}}_m\\right\\|_F}{\\|\\mathbf{A}\\|_F \\, \\|\\mathbf{V}_m\\|_F}.\n$$\n\n在多次重启过程中，记录在所有周期中观察到的 $\\eta$ 和 $\\tau$ 的最大值。为量化周期之间的重启稳健性，在指定的重启次数后，为每种正交化策略计算最终相对残差范数\n$$\n\\rho = \\frac{\\|\\mathbf{b}-\\mathbf{A}\\mathbf{x}_{\\text{final}}\\|_2}{\\|\\mathbf{b}\\|_2}\n$$\n并报告其比率\n$$\n\\varphi = \\frac{\\rho_{\\text{CGS}}}{\\rho_{\\text{MGS-reorth}}}.\n$$\n$\\varphi$ 的值接近 1 表示在存在舍入误差的情况下对重启具有高稳健性；更大的值表示在 CGS 下，舍入误差更严重地降低了重启收敛性。\n\n4. 测试套件。使用 $\\beta = 1$ 和以下测试案例，每个案例指定为一个元组 $(n,\\varepsilon,m,R)$，其中 $n$ 是内部点数，$\\varepsilon$ 是扩散系数， $m$ 是重启长度， $R$ 是重启次数：\n- 案例 A（一般情况，中度病态）：$(150, 10^{-2}, 20, 8)$。\n- 案例 B（更病态）：$(150, 10^{-4}, 20, 8)$。\n- 案例 C（边界情况：小 $m$，多次重启）：$(150, 10^{-3}, 5, 30)$。\n- 案例 D（每个周期更大的子空间）：$(150, 10^{-4}, 60, 3)$。\n\n5. 要求的输出。对于每个测试案例，从 $\\mathbf{x}_0=\\mathbf{0}$ 开始运行两次 GMRES($m$) 求解：\n- 一次在 Arnoldi 过程中使用单遍 CGS。\n- 一次在 Arnoldi 过程中使用带重正交化的 MGS。\n\n对于每个案例，生成一个包含五个浮点值的列表\n$$\n\\left[\\eta_{\\text{CGS}}, \\eta_{\\text{MGS-reorth}}, \\tau_{\\text{CGS}}, \\tau_{\\text{MGS-reorth}}, \\varphi\\right],\n$$\n其中 $\\eta$ 和 $\\tau$ 是所有周期中的最大值，$\\varphi$ 是如上定义的稳健性比率。将四个案例的结果按 A, B, C, D 的顺序收集到一个列表中。\n\n6. 最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内为结果，不含任何额外文本。该列表必须按顺序包含四个案例的结果，每个结果本身也是如上所述的列表，例如\n$[$$[a_{1},a_{2},a_{3},a_{4},a_{5}]$$,$$[b_{1},b_{2},b_{3},b_{4},b_{5}]$$,$$[c_{1},c_{2},c_{3},c_{4},c_{5}]$$,$$[d_{1},d_{2},d_{3},d_{4},d_{5}]$$]$。",
            "solution": "用户提供的问题陈述在程序上和科学上都是有效的。这是一个适定的数值实验，旨在研究有限精度算术对带重启的广义最小残差方法（GMRES($m$)）的影响，这是数值线性代数中的一个经典课题。该问题提供了清晰的数学模型、标准的离散化方案、两种用于比较的独特且相关的算法变体，以及一组定义明确的量化评估指标。所有参数都已明确指定，使得问题自包含且可复现。\n\n问题的核心在于 Arnoldi 过程，GMRES 使用该过程为 Krylov 子空间 $\\mathcal{K}_m(\\mathbf{A}, \\mathbf{r}_0) = \\text{span}\\{\\mathbf{r}_0, \\mathbf{A}\\mathbf{r}_0, \\dots, \\mathbf{A}^{m-1}\\mathbf{r}_0\\}$ 构造一个标准正交基。Arnoldi 过程生成一系列标准正交向量 $\\mathbf{v}_1, \\dots, \\mathbf{v}_{m+1}$ 和一个上 Hessenberg 矩阵 $\\overline{\\mathbf{H}}_m$，它们满足 Arnoldi 关系式 $\\mathbf{A}\\mathbf{V}_m = \\mathbf{V}_{m+1}\\overline{\\mathbf{H}}_m$。在有限精度算术中，向量 $\\mathbf{v}_j$ 逐渐失去它们之间的相互正交性。这种损失的严重程度取决于矩阵 $\\mathbf{A}$ 的条件数，以及至关重要的，正交化算法的选择。\n\n本实验对比了两种这样的算法：\n1.  **经典 Gram-Schmidt (CGS):** 在每一步 $j$，新的向量 $\\mathbf{A}\\mathbf{v}_j$ 同时与之前所有的基向量 $\\mathbf{v}_1, \\dots, \\mathbf{v}_j$ 正交。具体来说，是减去投影 $\\sum_{i=1}^j (\\mathbf{v}_i^\\top \\mathbf{A}\\mathbf{v}_j)\\mathbf{v}_i$。这种单步投影计算效率高但数值上不稳定；$\\mathbf{v}_i$ 分量中的舍入误差可能导致新向量中灾难性的正交性损失。由 $\\|\\mathbf{I} - \\mathbf{V}^\\top\\mathbf{V}\\|$ 衡量的正交性损失可能与矩阵 $\\mathbf{A}$ 的条件数成正比。\n\n2.  **带重正交化的修正 Gram-Schmidt (MGS):** MGS 将过程重新设计为一系列投影。向量 $\\mathbf{A}\\mathbf{v}_j$ 首先与 $\\mathbf{v}_1$ 正交，然后*得到的*向量再与 $\\mathbf{v}_2$ 正交，依此类推。这种顺序地移除分量的方式在数值上比 CGS 更稳定。为了进一步对抗舍入误差，应用了重正交化，这需要将整个 MGS 过程执行第二次。这种两遍 MGS 过程在保持正交性方面非常有效，确保 $\\|\\mathbf{I} - \\mathbf{V}^\\top\\mathbf{V}\\|$ 保持在机器精度附近，尽管其计算成本大约是单遍 MGS 的两倍。\n\n该实验旨在通过三类指标来衡量这种稳定性差异带来的后果：\n-   **周期内正交性损失 ($\\eta$):** 指标 $\\eta = \\max_{1 \\leq j \\leq m} \\| \\mathbf{V}_j^\\top \\mathbf{V}_j - \\mathbf{I}_j \\|_F$ 直接量化了在单个 GMRES 周期内维持标准正交基的失败程度。我们预计 $\\eta_{\\text{CGS}}$ 会显著大于 $\\eta_{\\text{MGS-reorth}}$，特别是对于病态矩阵。\n-   **周期内 Arnoldi 残差 ($\\tau$):** 指标 $\\tau = \\|\\mathbf{A}\\mathbf{V}_m - \\mathbf{V}_{m+1}\\overline{\\mathbf{H}}_m\\|_F / (\\|\\mathbf{A}\\|_F \\|\\mathbf{V}_m\\|_F)$ 衡量 Arnoldi 关系式的后向误差。正交性的大量损失会导致大的残差，表明计算生成的矩阵 $\\mathbf{V}_m, \\mathbf{V}_{m+1}, \\overline{\\mathbf{H}}_m$ 是对底层 Krylov 结构的不良表示。我们预计 $\\tau_{\\text{CGS}}  \\tau_{\\text{MGS-reorth}}$。\n-   **周期之间稳健性 ($\\varphi$):** GMRES 的更新依赖于 Arnoldi 关系式。如果由于舍入误差导致此关系式不准确，计算出的解更新将不是最优的。当 GMRES 重启时，这个误差会传播；新的残差是根据有缺陷的解计算出来的，可能减慢或停滞整体收敛。最终相对残差 $\\rho = \\|\\mathbf{b}-\\mathbf{A}\\mathbf{x}_{\\text{final}}\\|_2 / \\|\\mathbf{b}\\|_2$ 捕捉了这些误差在所有重启过程中的累积效应。比率 $\\varphi = \\rho_{\\text{CGS}}/\\rho_{\\text{MGS-reorth}}$ 分离出由于使用稳定性较差的 CGS 方法而导致的性能下降。$\\varphi  1$ 的值表示 CGS 中舍入误差的累积导致了比更稳定的带重正交化的 MGS 更差的整体收敛性。\n\n所选的对流扩散问题是一个极好的测试平台。对 $-\\varepsilon u'' + \\beta u'$ 的中心差分离散化产生一个非对称三对角矩阵。当扩散系数 $\\varepsilon$ 相对于对流参数 $\\beta$ 变得很小时，矩阵越来越由其反对称部分主导，导致高度的非正规性和病态性，这加剧了 Arnoldi 过程中的正交性损失。\n\n算法按以下步骤进行：\n1.  对于每个测试案例 $(n, \\varepsilon, m, R)$，构造三对角矩阵 $\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$ 和右端项 $\\mathbf{b} \\in \\mathbb{R}^n$。\n2.  实现一个通用的 GMRES($m$) 求解器。该求解器迭代 $R$ 个周期（重启）。\n3.  在每个周期内，执行 $m$ 步 Arnoldi 迭代以构建基 $\\mathbf{V}_{m+1}$ 和 Hessenberg 矩阵 $\\overline{\\mathbf{H}}_m$。求解器的这一内部部分可以使用 CGS 或两遍 MGS 正交化策略。\n4.  在一个周期内的 Arnoldi 迭代之后，计算该周期的指标 $\\eta$ 和 $\\tau$，并更新运行中的最大值。\n5.  求解关于 $\\mathbf{y}$ 的最小二乘问题 $\\min \\|\\beta \\mathbf{e}_1 - \\overline{\\mathbf{H}}_m \\mathbf{y}\\|_2$，并通过 $\\mathbf{x} \\leftarrow \\mathbf{x} + \\mathbf{V}_m \\mathbf{y}$ 更新解向量 $\\mathbf{x}$。\n6.  对每个测试案例，这个过程执行两次：一次使用 CGS，一次使用带重正交化的 MGS。\n7.  两次运行都完成后，使用最终残差计算稳健性比率 $\\varphi$。然后收集五个所需的指标。",
            "answer": "```python\nimport numpy as np\n\ndef build_matrix(n, epsilon, beta):\n    \"\"\"\n    Constructs the convection-diffusion matrix A.\n    \"\"\"\n    h = 1.0 / (n + 1)\n    \n    diag_val = (2.0 * epsilon) / (h * h)\n    upper_val = (-epsilon / (h * h)) + (beta / (2.0 * h))\n    lower_val = (-epsilon / (h * h)) - (beta / (2.0 * h))\n    \n    main_diag = np.full(n, diag_val)\n    upper_diag = np.full(n - 1, upper_val)\n    lower_diag = np.full(n - 1, lower_val)\n    \n    A = np.diag(main_diag) + np.diag(upper_diag, k=1) + np.diag(lower_diag, k=-1)\n    return A\n\ndef gmres_experiment(A, b, m, R, ortho_strategy):\n    \"\"\"\n    Implements GMRES(m) with specified restarts and orthonormalization strategy.\n    \n    Args:\n        A (np.ndarray): The system matrix.\n        b (np.ndarray): The right-hand side vector.\n        m (int): The restart parameter.\n        R (int): The number of restarts.\n        ortho_strategy (str): 'cgs' or 'mgs_reorth'.\n        \n    Returns:\n        tuple: (final solution x, max eta over all cycles, max tau over all cycles).\n    \"\"\"\n    n = A.shape[0]\n    x = np.zeros(n)\n    \n    A_norm_fro = np.linalg.norm(A, 'fro')\n    \n    max_eta_all_cycles = 0.0\n    max_tau_all_cycles = 0.0\n\n    for _ in range(R):\n        r = b - A @ x\n        r_norm = np.linalg.norm(r)\n        \n        V = np.zeros((n, m + 1))\n        H = np.zeros((m + 1, m))\n        \n        if r_norm == 0:\n            break\n        V[:, 0] = r / r_norm\n        \n        effective_m = m\n        for j in range(m):\n            w = A @ V[:, j]\n\n            h_col = np.zeros(j + 2) # Temp storage for h_j column\n            if ortho_strategy == 'cgs':\n                h_col_temp = V[:, :j+1].T @ w\n                H[:j+1, j] = h_col_temp\n                w = w - V[:, :j+1] @ h_col_temp\n            \n            elif ortho_strategy == 'mgs_reorth':\n                # First MGS pass\n                for i in range(j + 1):\n                    h_val = V[:, i].T @ w\n                    w = w - h_val * V[:, i]\n                    H[i, j] = h_val\n                \n                # Second MGS pass (reorthogonalization)\n                w_correction = V[:, :j+1].T @ w\n                w = w - V[:, :j+1] @ w_correction\n                H[:j+1, j] += w_correction\n            \n            w_norm = np.linalg.norm(w)\n            H[j + 1, j] = w_norm\n            \n            if w_norm  1e-12: # Breakdown\n                effective_m = j + 1\n                break\n\n            V[:, j + 1] = w / w_norm\n        \n        m_k = effective_m # Use effective m for this cycle\n        \n        # --- Metric calculations for this cycle ---\n        # 1. Intra-cycle orthogonality loss (eta)\n        cycle_eta = 0.0\n        for j_dim in range(1, m_k + 1):\n            V_j = V[:, :j_dim]\n            loss = np.linalg.norm(V_j.T @ V_j - np.eye(j_dim), 'fro')\n            if loss > cycle_eta:\n                cycle_eta = loss\n        \n        if cycle_eta > max_eta_all_cycles:\n            max_eta_all_cycles = cycle_eta\n\n        # 2. Normalized Arnoldi relation defect (tau)\n        V_mk = V[:, :m_k]\n        V_mk_plus_1 = V[:, :m_k+1]\n        H_bar_mk = H[:m_k+1, :m_k]\n        \n        arnoldi_defect = A @ V_mk - V_mk_plus_1 @ H_bar_mk\n        V_mk_norm_fro = np.linalg.norm(V_mk, 'fro')\n\n        if A_norm_fro * V_mk_norm_fro > 1e-12:\n            tau_cycle = np.linalg.norm(arnoldi_defect, 'fro') / (A_norm_fro * V_mk_norm_fro)\n        else:\n            tau_cycle = 0.0\n            \n        if tau_cycle > max_tau_all_cycles:\n            max_tau_all_cycles = tau_cycle\n        \n        # Solve least squares problem\n        rhs_ls = np.zeros(m_k + 1)\n        rhs_ls[0] = r_norm\n        \n        y, _, _, _ = np.linalg.lstsq(H_bar_mk, rhs_ls, rcond=None)\n        \n        x = x + V_mk @ y\n        \n        if effective_m  m: # If breakdown occurred\n            break\n\n    return x, max_eta_all_cycles, max_tau_all_cycles\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (150, 1e-2, 20, 8),   # Case A\n        (150, 1e-4, 20, 8),   # Case B\n        (150, 1e-3, 5, 30),  # Case C\n        (150, 1e-4, 60, 3),   # Case D\n    ]\n\n    all_results = []\n    beta = 1.0\n\n    for case in test_cases:\n        n, epsilon, m, R = case\n        \n        A = build_matrix(n, epsilon, beta)\n        b = np.ones(n)\n        b_norm = np.linalg.norm(b)\n\n        # Run with CGS\n        x_cgs, eta_cgs, tau_cgs = gmres_experiment(A, b, m, R, 'cgs')\n        rho_cgs = np.linalg.norm(b - A @ x_cgs) / b_norm\n\n        # Run with MGS with reorthogonalization\n        x_mgs, eta_mgs, tau_mgs = gmres_experiment(A, b, m, R, 'mgs_reorth')\n        rho_mgs = np.linalg.norm(b - A @ x_mgs) / b_norm\n\n        # Calculate resilience ratio phi\n        phi = rho_cgs / rho_mgs if rho_mgs > 1e-14 else float('inf')\n\n        case_results = [eta_cgs, eta_mgs, tau_cgs, tau_mgs, phi]\n        all_results.append(case_results)\n\n    # Format the final output string\n    result_strings = []\n    for res in all_results:\n        # Using a consistent format for floating point numbers\n        formatted_res = [f\"{x:.8e}\" for x in res]\n        result_strings.append(f\"[{','.join(formatted_res)}]\")\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}