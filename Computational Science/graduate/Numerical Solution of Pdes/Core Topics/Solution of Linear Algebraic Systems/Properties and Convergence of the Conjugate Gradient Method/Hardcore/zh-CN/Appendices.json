{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握一个算法，没有比手动计算更有效的方法了。这个练习将引导您在一个小规模的良态系统上，逐步完成共轭梯度法的核心计算步骤。通过亲手计算残差、搜索方向和步长，您将为这些组件如何协同作用以最小化误差的$A$-范数并最终达到解的过程建立起具体直观的认识，从而巩固对算法基本步骤的理解 ()。",
            "id": "3436339",
            "problem": "考虑一个源于椭圆偏微分方程的伽辽金离散化的对称正定线性系统，其矩阵为 $A=\\begin{pmatrix}4&1\\\\1&3\\end{pmatrix}$，右端向量为 $b=\\begin{pmatrix}1\\\\2\\end{pmatrix}$，以及初始猜测为 $x_0=\\begin{pmatrix}0\\\\0\\end{pmatrix}$。应用共轭梯度（CG）法，使用精确算术、标准残差 $r_k=b-Ax_k$、$A$-共轭的搜索方向，以及为最小化每个搜索方向上的二次能量而选择的步长。令 $x_\\star$ 表示 $Ax_\\star=b$ 的唯一解，令 $e_k=x_\\star-x_k$ 表示第k次迭代的误差，并令能量范数定义为 $\\|e\\|_A=\\sqrt{e^{\\top}Ae}$。从 $x_0$ 开始执行恰好两次CG迭代，以计算 $x_2$，$r_2$ 和 $\\|e_2\\|_A$。将你的最终答案表示为单个行矩阵，按顺序包含 $x_2$ 的两个分量、$r_2$ 的两个分量以及标量 $\\|e_2\\|_A$。提供精确值；无需四舍五入。",
            "solution": "首先对问题进行验证，以确保其具有科学依据、是适定的且是客观的。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n- 线性系统由矩阵 $A=\\begin{pmatrix}4&1\\\\1&3\\end{pmatrix}$ 和右端向量 $b=\\begin{pmatrix}1\\\\2\\end{pmatrix}$ 定义。\n- 初始猜测为 $x_0=\\begin{pmatrix}0\\\\0\\end{pmatrix}$。\n- 使用的方法是共轭梯度（CG）法，采用精确算术。\n- 要执行的迭代次数恰好为 $2$ 次。\n- 要计算的量是解的估计值 $x_2$、残差 $r_2$ 以及误差的能量范数 $\\|e_2\\|_A$。\n- 提供的定义有：残差 $r_k=b-Ax_k$，误差 $e_k=x_\\star-x_k$ （其中 $x_\\star$ 是 $Ax_\\star=b$ 的精确解），以及能量范数 $\\|e\\|_A=\\sqrt{e^{\\top}Ae}$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题要求应用共轭梯度法，这是数值线性代数中用于求解对称正定（SPD）矩阵线性系统的典型算法。该问题基于已建立的数学原理。\n- **适定性：** 为了使CG法适用，矩阵 $A$ 必须是对称正定的（SPD）。\n  - 对称性：矩阵 $A$ 是对称的，因为 $A_{12} = A_{21} = 1$。\n  - 正定性：我们检查 $A$ 的顺序主子式。第一个顺序主子式是 $\\det(4) = 4 > 0$。第二个顺序主子式是 $\\det(A) = 4 \\times 3 - 1 \\times 1 = 12 - 1 = 11 > 0$。由于所有顺序主子式都为正，根据西尔维斯特准则，$A$ 是正定的。\n- 因为 $A$ 是对称正定的，所以它是可逆的，这保证了唯一解 $x_\\star$ 的存在。CG算法是良定义的，并且保证对于一个 $2 \\times 2$ 系统，在精确算术下，最多 $n=2$ 步内收敛到精确解。\n- **客观性：** 该问题使用精确的数学术语、定义和数值进行陈述，没有歧义或主观因素。\n\n**步骤3：结论与行动**\n该问题被认为是**有效的**，因为它具有科学性、适定性和客观性。将提供一个完整的解答。\n\n**求解过程**\n\n共轭梯度算法的步骤如下。\n\n**初始化 (k=0):**\n初始猜测为 $x_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。\n初始残差为 $r_0 = b - A x_0 = b = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$。\n初始搜索方向设为残差：$p_0 = r_0 = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$。\n\n**第1次迭代 (k=0 到 k=1):**\n首先，我们计算步长 $\\alpha_0$：\n$$ \\alpha_0 = \\frac{r_0^{\\top} r_0}{p_0^{\\top} A p_0} $$\n分子是 $r_0^{\\top} r_0 = \\begin{pmatrix} 1 & 2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = 1^2 + 2^2 = 5$。\n对于分母，我们首先计算 $A p_0$：\n$$ A p_0 = \\begin{pmatrix} 4 & 1 \\\\ 1 & 3 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 4(1) + 1(2) \\\\ 1(1) + 3(2) \\end{pmatrix} = \\begin{pmatrix} 6 \\\\ 7 \\end{pmatrix} $$\n然后，$p_0^{\\top} A p_0 = \\begin{pmatrix} 1 & 2 \\end{pmatrix} \\begin{pmatrix} 6 \\\\ 7 \\end{pmatrix} = 1(6) + 2(7) = 20$。\n所以，步长为 $\\alpha_0 = \\frac{5}{20} = \\frac{1}{4}$。\n\n现在，我们更新解和残差：\n$$ x_1 = x_0 + \\alpha_0 p_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} + \\frac{1}{4} \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix} $$\n$$ r_1 = r_0 - \\alpha_0 A p_0 = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} - \\frac{1}{4} \\begin{pmatrix} 6 \\\\ 7 \\end{pmatrix} = \\begin{pmatrix} 1 - 6/4 \\\\ 2 - 7/4 \\end{pmatrix} = \\begin{pmatrix} 1 - 3/2 \\\\ 8/4 - 7/4 \\end{pmatrix} = \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix} $$\n\n接下来，我们通过计算 $\\beta_0$ 和新的搜索方向 $p_1$ 为第二次迭代做准备：\n$$ \\beta_0 = \\frac{r_1^{\\top} r_1}{r_0^{\\top} r_0} $$\n新的分子是 $r_1^{\\top} r_1 = \\begin{pmatrix} -1/2 & 1/4 \\end{pmatrix} \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix} = (-\\frac{1}{2})^2 + (\\frac{1}{4})^2 = \\frac{1}{4} + \\frac{1}{16} = \\frac{5}{16}$。\n分母 $r_0^{\\top} r_0 = 5$ 先前已经计算过。\n所以，$\\beta_0 = \\frac{5/16}{5} = \\frac{1}{16}$。\n\n新的搜索方向是：\n$$ p_1 = r_1 + \\beta_0 p_0 = \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix} + \\frac{1}{16} \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} -8/16 + 1/16 \\\\ 4/16 + 2/16 \\end{pmatrix} = \\begin{pmatrix} -7/16 \\\\ 6/16 \\end{pmatrix} $$\n\n**第2次迭代 (k=1 到 k=2):**\n我们计算步长 $\\alpha_1$：\n$$ \\alpha_1 = \\frac{r_1^{\\top} r_1}{p_1^{\\top} A p_1} $$\n分子 $r_1^{\\top} r_1 = 5/16$ 刚刚计算过。\n对于分母，我们首先计算 $A p_1$：\n$$ A p_1 = \\begin{pmatrix} 4 & 1 \\\\ 1 & 3 \\end{pmatrix} \\begin{pmatrix} -7/16 \\\\ 6/16 \\end{pmatrix} = \\frac{1}{16} \\begin{pmatrix} 4(-7) + 1(6) \\\\ 1(-7) + 3(6) \\end{pmatrix} = \\frac{1}{16} \\begin{pmatrix} -22 \\\\ 11 \\end{pmatrix} $$\n然后，$p_1^{\\top} A p_1 = \\begin{pmatrix} -7/16 & 6/16 \\end{pmatrix} \\frac{1}{16} \\begin{pmatrix} -22 \\\\ 11 \\end{pmatrix} = \\frac{1}{256} \\left( (-7)(-22) + 6(11) \\right) = \\frac{1}{256} (154 + 66) = \\frac{220}{256} = \\frac{55}{64}$。\n所以，步长为 $\\alpha_1 = \\frac{5/16}{55/64} = \\frac{5}{16} \\cdot \\frac{64}{55} = \\frac{1}{1} \\cdot \\frac{4}{11} = \\frac{4}{11}$。\n\n现在我们更新解得到 $x_2$，更新残差得到 $r_2$：\n$$ x_2 = x_1 + \\alpha_1 p_1 = \\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix} + \\frac{4}{11} \\begin{pmatrix} -7/16 \\\\ 6/16 \\end{pmatrix} = \\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix} + \\begin{pmatrix} -7/44 \\\\ 6/44 \\end{pmatrix} = \\begin{pmatrix} 11/44 - 7/44 \\\\ 22/44 + 6/44 \\end{pmatrix} = \\begin{pmatrix} 4/44 \\\\ 28/44 \\end{pmatrix} = \\begin{pmatrix} 1/11 \\\\ 7/11 \\end{pmatrix} $$\n$$ r_2 = r_1 - \\alpha_1 A p_1 = \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix} - \\frac{4}{11} \\left( \\frac{1}{16} \\begin{pmatrix} -22 \\\\ 11 \\end{pmatrix} \\right) = \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix} - \\frac{1}{44} \\begin{pmatrix} -22 \\\\ 11 \\end{pmatrix} = \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix} - \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} $$\n\n所求的量为 $x_2$，$r_2$ 和 $\\|e_2\\|_A$。\n我们已经求得 $x_2 = \\begin{pmatrix} 1/11 \\\\ 7/11 \\end{pmatrix}$ 和 $r_2 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。\n$r_2 = b - A x_2 = 0$ 这一事实意味着 $A x_2 = b$。因此，$x_2$ 是精确解，所以 $x_2 = x_\\star$。\n第2次迭代的误差是 $e_2 = x_\\star - x_2 = x_2 - x_2 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。\n误差的能量范数计算如下：\n$$ \\|e_2\\|_A = \\sqrt{e_2^{\\top} A e_2} = \\sqrt{\\begin{pmatrix} 0 & 0 \\end{pmatrix} \\begin{pmatrix} 4 & 1 \\\\ 1 & 3 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}} = \\sqrt{0} = 0 $$\n\n最终答案要求一个单一的行矩阵，按顺序包含 $x_2$ 的分量、$r_2$ 的分量和标量 $\\|e_2\\|_A$。\n$x_2$ 的分量是 $1/11$ 和 $7/11$。\n$r_2$ 的分量是 $0$ 和 $0$。\n$\\|e_2\\|_A$ 的值是 $0$。\n得到的行矩阵是 $\\begin{pmatrix} \\frac{1}{11} & \\frac{7}{11} & 0 & 0 & 0 \\end{pmatrix}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{11} & \\frac{7}{11} & 0 & 0 & 0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "共轭梯度法的一个关键理论特性是其收敛行为与矩阵谱（特征值分布）之间的深刻联系。这个实践从简单的应用题升级为构造题，要求您构建一个保证共轭梯度法在特定步数内收敛的线性系统 ()。这背后的原理是：如果一个矩阵有$k$个不同的特征值，共轭梯度法最多在$k$次迭代内就能找到精确解。通过构造一个具有预定数量不同特征值的矩阵并验证其收敛行为，您将更深入地理解系统代数性质与迭代求解器性能之间的联系。",
            "id": "3436325",
            "problem": "考虑将共轭梯度（CG）方法应用于由对称正定离散化产生的线性系统，这种情况在椭圆型偏微分方程（PDE）的数值解中很常见。您的任务是构造并验证一个具体实例，在该实例中，CG 方法在精确算术下恰好在 $2$ 步内终止。\n\n提供一个显式的 $3 \\times 3$ 对称正定矩阵 $A$，该矩阵恰好有两个不同的特征值，以及一个右端向量 $b$，该向量在与 $A$ 的两个不同特征值相关联的特征空间上的投影分量均不为零。从 $x_0 = 0$ 开始 CG 迭代。仅使用 CG 方法的基本定义（残差、搜索方向以及由 $A$ 诱导的内积和欧几里得内积定义的步长），符号化且精确地执行前两次迭代，并通过证明 $2$ 步后的误差 $e_2 := x_{\\ast} - x_2$ 为零向量来验证终止，其中 $x_{\\ast}$ 表示 $A x = b$ 的精确解。\n\n作为最终答案，报告平方欧几里得范数 $\\|e_2\\|_2^2$ 的精确值。不需要四舍五入，也不需要单位。",
            "solution": "### 问题验证\n\n**第 1 步：提取已知条件**\n\n*   **任务：**构造一个显式的 $3 \\times 3$ 对称正定（SPD）矩阵 $A$。\n*   **约束 1：** $A$ 必须恰好有两个不同的特征值。\n*   **任务：**构造一个右端向量 $b$。\n*   **约束 2：**对于 $x_0=0$ 的初始误差，即 $x_*=A^{-1}b$，必须在与 $A$ 的两个不同特征值相关联的特征空间上具有非零投影。这等价于初始残差 $r_0 = b$ 在这些特征空间上具有非零投影。\n*   **初始条件：**共轭梯度（CG）迭代从 $x_0 = 0$ 开始。\n*   **方法：**使用 CG 方法的基本定义，符号化且精确地执行前两次迭代。\n*   **验证：**证明 $2$ 步后的误差 $e_2 := x_* - x_2$ 是零向量，从而验证在恰好 2 步内终止。\n*   **要求输出：**报告平方欧几里得范数 $\\|e_2\\|_2^2$ 的精确值。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n这个问题具有科学依据。共轭梯度法及其收敛性质是数值线性代数的基石。一个著名的定理指出，如果系统 $Ax=b$ 中的矩阵 $A$ 有 $k$ 个不同的特征值，并且初始残差在所有相应特征空间上都有分量，那么在精确算术下，CG 方法至多在 $k$ 次迭代内找到精确解。本问题要求针对一个具有 $k=2$ 个不同特征值的 $3 \\times 3$ 矩阵，对该定理进行具体构造和验证。\n\n问题是适定的、客观的。它为构造一个特定例子（$3 \\times 3$ SPD，2 个不同特征值，$x_0=0$）提供了清晰、形式化的约束，并要求一个确定性的验证过程（运行 CG 2 步并证明结果误差为零）。所要求的输出是一个单一、明确的数值。\n\n问题的设定是完整和一致的。构造例子和执行验证所需的所有信息要么已经提供，要么是构造任务本身的一部分。这是一个数值分析中标准的、非平凡的练习，旨在测试对 CG 方法理论基础的理解。它没有违反任何无效性标准。\n\n**第 3 步：结论与行动**\n\n问题有效。我将继续进行解答。\n\n### 解答\n\n问题的核心是展示共轭梯度（CG）方法的终止特性。该方法保证在至多 $k$ 步内找到 $Ax=b$ 的精确解，其中 $k$ 是矩阵 $A$ 的不同特征值的数量，前提是初始残差在所有相应的特征空间上都有分量。我们将构造一个具有 $k=2$ 个不同特征值的 $3 \\times 3$ 对称正定矩阵 $A$ 和一个向量 $b$，使得 CG 算法恰好在 $2$ 步内终止。\n\n**1. 构造矩阵 $A$ 和向量 $b$**\n\n设两个不同的特征值为 $\\lambda_1 = 1$ 和 $\\lambda_2 = 2$。对于一个 $3 \\times 3$ 矩阵，其中一个特征值的代数重数必须为 $2$。我们设定 $\\lambda_1=1$（重数为 $1$）和 $\\lambda_2=2$（重数为 $2$）。\n\n为了构造 $A$，我们使用谱分解 $A = Q \\Lambda Q^T$。我们选择一组简单的标准正交特征向量基。\n*   对于 $\\lambda_1 = 1$，设单位化特征向量为 $v_1 = \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$。\n*   对于 $\\lambda_2 = 2$，我们需要两个与 $v_1$ 正交的特征向量。我们可以选择 $v_2 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix}$ 和 $v_3 = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1 \\\\ 1 \\\\ -2 \\end{pmatrix}$。\n\n特征向量矩阵为 $Q = \\begin{pmatrix} v_1 & v_2 & v_3 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{6}} \\\\ \\frac{1}{\\sqrt{3}} & -\\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{6}} \\\\ \\frac{1}{\\sqrt{3}} & 0 & -\\frac{2}{\\sqrt{6}} \\end{pmatrix}$，特征值对角矩阵为 $\\Lambda = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 2 \\end{pmatrix}$。\n\n计算 $A = Q \\Lambda Q^T$：\n$$ A = \\begin{pmatrix} \\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{6}} \\\\ \\frac{1}{\\sqrt{3}} & -\\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{6}} \\\\ \\frac{1}{\\sqrt{3}} & 0 & -\\frac{2}{\\sqrt{6}} \\end{pmatrix} \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 2 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{3}} \\\\ \\frac{1}{\\sqrt{2}} & -\\frac{1}{\\sqrt{2}} & 0 \\\\ \\frac{1}{\\sqrt{6}} & \\frac{1}{\\sqrt{6}} & -\\frac{2}{\\sqrt{6}} \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 5 & -1 & -1 \\\\ -1 & 5 & -1 \\\\ -1 & -1 & 5 \\end{pmatrix} $$\n根据构造，该矩阵是对称的。其特征值为 $1$ 和 $2$，均为正数，因此 $A$ 是正定的。\n\n接下来，我们构造向量 $b$。初始残差为 $r_0 = b - A x_0$。由于 $x_0 = 0$，我们有 $r_0 = b$。为了恰好在 $2$ 步内终止，$r_0$ 必须在 $\\lambda_1$ 的特征空间和 $\\lambda_2$ 的特征空间中都有非零分量。实现这一点的一个简单方法是将 $b$ 定义为来自每个空间的特征向量的线性组合。我们选择 $b = v_1' + v_2'$，其中 $v_1'$ 在 $\\lambda_1$ 的特征空间中，$v_2'$ 在 $\\lambda_2$ 的特征空间中。为简单起见，我们使用未单位化的特征向量：\n$v_1' = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$ 和 $v_2' = \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix}$。\n$$ b = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix} $$\n\n**2. 共轭梯度迭代**\n\n我们应用 CG 算法求解 $Ax=b$，其中 $x_0=0$。\n该系统为：\n$$ \\frac{1}{3}\\begin{pmatrix} 5 & -1 & -1 \\\\ -1 & 5 & -1 \\\\ -1 & -1 & 5 \\end{pmatrix} x = \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix}, \\quad x_0 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\n\n初始设置：\n$r_0 = b - Ax_0 = b = \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix}$\n$p_0 = r_0 = \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix}$\n\n**第 $1$ 次迭代（$k=0$）：**\n步长 $\\alpha_0 = \\frac{r_0^T r_0}{p_0^T A p_0}$：\n$r_0^T r_0 = 2^2 + 0^2 + 1^2 = 5$\n$A p_0 = \\frac{1}{3}\\begin{pmatrix} 5 & -1 & -1 \\\\ -1 & 5 & -1 \\\\ -1 & -1 & 5 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 10 - 1 \\\\ -2 - 1 \\\\ -2 + 5 \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 9 \\\\ -3 \\\\ 3 \\end{pmatrix} = \\begin{pmatrix} 3 \\\\ -1 \\\\ 1 \\end{pmatrix}$\n$p_0^T A p_0 = r_0^T (A p_0) = \\begin{pmatrix} 2 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 3 \\\\ -1 \\\\ 1 \\end{pmatrix} = 6 + 0 + 1 = 7$\n$\\alpha_0 = \\frac{5}{7}$\n\n更新解和残差：\n$x_1 = x_0 + \\alpha_0 p_0 = 0 + \\frac{5}{7} \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 10/7 \\\\ 0 \\\\ 5/7 \\end{pmatrix}$\n$r_1 = r_0 - \\alpha_0 A p_0 = \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix} - \\frac{5}{7} \\begin{pmatrix} 3 \\\\ -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 14/7 - 15/7 \\\\ 5/7 \\\\ 7/7 - 5/7 \\end{pmatrix} = \\frac{1}{7}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix}$\n由于 $r_1 \\neq 0$，算法尚未终止。\n\n为下一次迭代做准备：\n$\\beta_0 = \\frac{r_1^T r_1}{r_0^T r_0}$：\n$r_1^T r_1 = \\left(\\frac{1}{7}\\right)^2 ((-1)^2 + 5^2 + 2^2) = \\frac{1}{49}(1+25+4) = \\frac{30}{49}$\n$\\beta_0 = \\frac{30/49}{5} = \\frac{6}{49}$\n$p_1 = r_1 + \\beta_0 p_0 = \\frac{1}{7}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix} + \\frac{6}{49}\\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{49} \\left( 7\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix} + 6\\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix} \\right) = \\frac{1}{49} \\begin{pmatrix} -7+12 \\\\ 35+0 \\\\ 14+6 \\end{pmatrix} = \\frac{1}{49}\\begin{pmatrix} 5 \\\\ 35 \\\\ 20 \\end{pmatrix} = \\frac{5}{49}\\begin{pmatrix} 1 \\\\ 7 \\\\ 4 \\end{pmatrix}$\n\n**第 $2$ 次迭代（$k=1$）：**\n步长 $\\alpha_1 = \\frac{r_1^T r_1}{p_1^T A p_1}$：\n$r_1^T r_1 = \\frac{30}{49}$\n$A p_1 = \\frac{5}{49} A \\begin{pmatrix} 1 \\\\ 7 \\\\ 4 \\end{pmatrix} = \\frac{5}{49} \\frac{1}{3}\\begin{pmatrix} 5-7-4 \\\\ -1+35-4 \\\\ -1-7+20 \\end{pmatrix} = \\frac{5}{147}\\begin{pmatrix} -6 \\\\ 30 \\\\ 12 \\end{pmatrix} = \\frac{30}{147}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix} = \\frac{10}{49}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix}$\n$p_1^T A p_1 = \\left(\\frac{5}{49}\\begin{pmatrix} 1 \\\\ 7 \\\\ 4 \\end{pmatrix}^T\\right) \\left(\\frac{10}{49}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix}\\right) = \\frac{50}{49^2} (1(-1) + 7(5) + 4(2)) = \\frac{50}{49^2}(-1+35+8) = \\frac{50 \\cdot 42}{49^2} = \\frac{50 \\cdot 6 \\cdot 7}{49 \\cdot 49} = \\frac{300}{343}$\n$\\alpha_1 = \\frac{30/49}{300/343} = \\frac{30}{49} \\cdot \\frac{343}{300} = \\frac{1}{10} \\cdot \\frac{7^3}{7^2} = \\frac{7}{10}$\n\n更新解和残差：\n$x_2 = x_1 + \\alpha_1 p_1 = \\begin{pmatrix} 10/7 \\\\ 0 \\\\ 5/7 \\end{pmatrix} + \\frac{7}{10} \\left( \\frac{5}{49}\\begin{pmatrix} 1 \\\\ 7 \\\\ 4 \\end{pmatrix} \\right) = \\begin{pmatrix} 10/7 \\\\ 0 \\\\ 5/7 \\end{pmatrix} + \\frac{1}{14}\\begin{pmatrix} 1 \\\\ 7 \\\\ 4 \\end{pmatrix} = \\begin{pmatrix} 20/14 + 1/14 \\\\ 7/14 \\\\ 10/14 + 4/14 \\end{pmatrix} = \\begin{pmatrix} 21/14 \\\\ 7/14 \\\\ 14/14 \\end{pmatrix} = \\begin{pmatrix} 3/2 \\\\ 1/2 \\\\ 1 \\end{pmatrix}$\n$r_2 = r_1 - \\alpha_1 A p_1 = \\frac{1}{7}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix} - \\frac{7}{10} \\left( \\frac{10}{49}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix} \\right) = \\frac{1}{7}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix} - \\frac{1}{7}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$\n由于 $r_2=0$，CG 算法恰好在第 $2$ 步终止。\n\n**3. 解的验证**\n\n为了验证 $x_2$ 是精确解 $x_*$，我们直接求解 $Ax=b$。\n首先，我们求 $A^{-1}$。对于形如 $c_1 I + c_2 J$ 的矩阵（其中 $J$ 是全一矩阵），有一个有用的恒等式：$(c_1 I + c_2 J)^{-1} = \\frac{1}{c_1}I - \\frac{c_2}{c_1(c_1+nc_2)}J$。我们的矩阵是 $A = 2I - \\frac{1}{3}J$。这里 $n=3, c_1=2, c_2=-1/3$。\n$A^{-1} = \\frac{1}{2}I - \\frac{-1/3}{2(2+3(-1/3))}J = \\frac{1}{2}I + \\frac{1/3}{2(2-1)}J = \\frac{1}{2}I + \\frac{1}{6}J$。\n$$ A^{-1} = \\frac{1}{2}\\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} + \\frac{1}{6}\\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix} = \\frac{1}{6}\\begin{pmatrix} 3+1 & 1 & 1 \\\\ 1 & 3+1 & 1 \\\\ 1 & 1 & 3+1 \\end{pmatrix} = \\frac{1}{6}\\begin{pmatrix} 4 & 1 & 1 \\\\ 1 & 4 & 1 \\\\ 1 & 1 & 4 \\end{pmatrix} $$\n现在，我们计算精确解 $x_* = A^{-1}b$：\n$$ x_* = \\frac{1}{6}\\begin{pmatrix} 4 & 1 & 1 \\\\ 1 & 4 & 1 \\\\ 1 & 1 & 4 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{6}\\begin{pmatrix} 4(2)+1(0)+1(1) \\\\ 1(2)+4(0)+1(1) \\\\ 1(2)+1(0)+4(1) \\end{pmatrix} = \\frac{1}{6}\\begin{pmatrix} 9 \\\\ 3 \\\\ 6 \\end{pmatrix} = \\begin{pmatrix} 9/6 \\\\ 3/6 \\\\ 6/6 \\end{pmatrix} = \\begin{pmatrix} 3/2 \\\\ 1/2 \\\\ 1 \\end{pmatrix} $$\n将我们的 CG 结果 $x_2$ 与精确解 $x_*$ 进行比较：\n$$ x_2 = \\begin{pmatrix} 3/2 \\\\ 1/2 \\\\ 1 \\end{pmatrix} = x_* $$\n$2$ 步后的误差为 $e_2 = x_* - x_2 = 0$。\n误差的平方欧几里得范数为 $\\|e_2\\|_2^2 = \\|0\\|_2^2 = 0^2+0^2+0^2 = 0$。验证完成。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "在实际应用中，我们需要可靠的停止准则来终止迭代，而残差的范数是一个常见的选择。然而，尽管误差的能量范数 ($A$-范数) 保证单调递减，残差的欧几里得范数却并非如此。这个计算练习旨在揭示这一关键且时而反直觉的特性 ()。通过为一个离散化的偏微分方程实现共轭梯度法，并观察残差范数的非单调行为，您将理解仅基于残差范数下降的朴素停止准则的潜在缺陷，并体会到选择与方法理论保证相符的收敛度量标准的重要性。",
            "id": "3436372",
            "problem": "考虑在开区间 $(0,1)$ 上的一个一维反应扩散方程的边值问题，其边界条件为齐次狄利克雷边界条件：求解 $u : [0,1] \\to \\mathbb{R}$ 使得\n$$\n- \\frac{d^2 u}{dx^2} + \\alpha u = f(x), \\quad x \\in (0,1), \\quad u(0) = u(1) = 0,\n$$\n其中 $\\alpha \\ge 0$ 是一个常数反应系数。使用标准的二阶中心有限差分法，在 $n$ 个内部网格点上对该问题进行离散化。令 $h = \\frac{1}{n+1}$ 且 $x_i = i h$，$i = 1,2,\\ldots,n$。离散系统具有以下形式\n$$\nA \\mathbf{u} = \\mathbf{b},\n$$\n其中 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定矩阵，其形式为 $A = \\frac{1}{h^2} \\operatorname{tridiag}(-1,2,-1) + \\alpha I$；$\\mathbf{u} \\in \\mathbb{R}^n$ 是内部点上解的近似；$\\mathbf{b} \\in \\mathbb{R}^n$ 汇集了值 $f(x_i)$。对于此类问题，当 $A$ 是对称正定时，共轭梯度法 (CG) 是求解 $A \\mathbf{u} = \\mathbf{b}$ 的一种基本迭代算法。\n\n定义第 $k$ 次迭代的误差为 $\\mathbf{e}_k = \\mathbf{x}_k - \\mathbf{x}^\\star$，其中 $\\mathbf{x}^\\star$ 是线性系统的精确解；定义残差为 $\\mathbf{r}_k = \\mathbf{b} - A \\mathbf{x}_k$。由 $A$ 诱导的能量范数为 $\\|\\mathbf{e}_k\\|_A = \\sqrt{\\mathbf{e}_k^\\top A \\mathbf{e}_k}$，残差的欧几里得范数为 $\\|\\mathbf{r}_k\\|_2 = \\sqrt{\\mathbf{r}_k^\\top \\mathbf{r}_k}$。\n\n从以下基本事实出发：\n- 对于所有 $\\alpha \\ge 0$，有限差分离散都会产生一个对称正定矩阵 $A$。\n- 共轭梯度法在仿射克雷洛夫序列 $\\mathbf{x}_0 + \\mathcal{K}_k(A,\\mathbf{r}_0)$ 中生成迭代向量 $\\mathbf{x}_k$，其中 $\\mathcal{K}_k(A,\\mathbf{r}_0) = \\operatorname{span}\\{\\mathbf{r}_0, A \\mathbf{r}_0, \\ldots, A^{k-1} \\mathbf{r}_0\\}$，且 $\\mathbf{r}_0 = \\mathbf{b} - A \\mathbf{x}_0$。\n- 共轭梯度法确保误差的能量范数 $\\|\\mathbf{e}_k\\|_A$ 在精确算术中单调递减（严格递减，除非已达到解），\n设计并实现一个程序，构建上述离散偏微分方程的特定实例，以证明即使在能量范数 $\\|\\mathbf{e}_k\\|_A$ 严格递减的情况下，残差范数 $\\|\\mathbf{r}_k\\|_2$ 也可能不是单调的。请使用以下设计要求：\n\n1. 在每个测试用例中，将 $\\mathbf{b}$ 构建为 $A$ 的离散正弦特征向量的双模组合，以强调谱分离效应。对于具有 $n$ 个内部点的网格，按分量定义离散正弦特征向量 $v_j \\in \\mathbb{R}^n$ 为 $(v_j)_i = \\sin\\left(\\frac{j \\pi i}{n+1}\\right)$，$j=1,2,\\ldots,n$。在每个测试用例中，令\n$$\n\\mathbf{b} = c_1 v_1 + c_2 v_n,\n$$\n其中 $c_1, c_2 \\in \\mathbb{R}$ 是指定的系数。注意，加上 $\\alpha I$ 不会改变离散拉普拉斯算子的正弦特征向量，因此这些 $v_j$ 仍然是 $A$ 的特征向量。\n\n2. 实现用于对称正定矩阵的标准共轭梯度法，从初始猜测 $\\mathbf{x}_0 = \\mathbf{0}$ 开始，并在每次迭代 $k$ 中记录：\n   - 残差范数 $\\|\\mathbf{r}_k\\|_2$。\n   - 误差的能量范数 $\\|\\mathbf{e}_k\\|_A$，该范数通过使用直接法求解 $A \\mathbf{x}^\\star = \\mathbf{b}$ 得到的精确解 $\\mathbf{x}^\\star$ 来计算。\n\n3. 使用以下停止指标：\n   - 基于残差的指标 $k_{\\mathrm{res}}$：满足 $\\|\\mathbf{r}_k\\|_2 \\le \\tau_{\\mathrm{res}} \\|\\mathbf{r}_0\\|_2$ 的最小迭代次数 $k$，其中 $\\tau_{\\mathrm{res}} = 10^{-8}$。\n   - 基于能量的指标 $k_{\\mathrm{energy}}$：满足 $\\|\\mathbf{e}_k\\|_A \\le \\tau_{\\mathrm{energy}} \\|\\mathbf{e}_0\\|_A$ 的最小迭代次数 $k$，其中 $\\tau_{\\mathrm{energy}} = 10^{-8}$。\n\n4. 检测并报告残差范数序列是否非单调，即是否存在迭代 $k \\ge 1$ 使得 $\\|\\mathbf{r}_k\\|_2 > \\|\\mathbf{r}_{k-1}\\|_2$。同时报告能量范数序列在记录的迭代中是否严格递减，即在终止前对于所有 $k \\ge 1$ 是否都有 $\\|\\mathbf{e}_k\\|_A  \\|\\mathbf{e}_{k-1}\\|_A$。\n\n5. 评估一个错误地假设残差范数是单调的朴素停止规则所带来的影响。在第一个满足 $\\|\\mathbf{r}_k\\|_2  \\|\\mathbf{r}_{k-1}\\|_2$ 的迭代 $k$ 处定义一个假设性的提前停止。报告这样的朴素停止是否会严格地在达到基于能量的容差之前发生，即该迭代指标是否小于 $k_{\\mathrm{energy}}$。\n\n实现您的程序以运行以下测试套件，每个测试用例由三元组 $(n,\\alpha,(c_1,c_2))$ 参数化：\n\n- 测试用例 1 (一般双模，强谱隙)：$(n,\\alpha,(c_1,c_2)) = (50, 0, (1.0, 0.3))$。\n- 测试用例 2 (反应位移下的双模)：$(n,\\alpha,(c_1,c_2)) = (80, 5.0, (1.0, 0.2))$。\n- 测试用例 3 (单模边界情况)：$(n,\\alpha,(c_1,c_2)) = (60, 0, (1.0, 0.0))$。\n\n对于每个测试用例，您的程序必须输出一个包含五个基本值的列表：\n- 一个布尔值，指示残差范数是否非单调。\n- 一个布尔值，指示能量范数在每次迭代中是否严格递减，直到达到容差。\n- 一个布尔值，指示基于残差增加的朴素停止规则是否会在满足基于能量的容差之前停止。\n- 整数 $k_{\\mathrm{res}}$。\n- 整数 $k_{\\mathrm{energy}}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个以逗号分隔并用方括号括起来的列表，列表中的每个元素是对应于一个测试用例的五个值的列表。例如：\"[[true,true,false,2,2],[...],[...] ]\"。所有布尔值必须以小写形式打印为 \"True\" 或 \"False\"，整数则以十进制表示法打印。\n\n此问题不涉及物理单位，如果出现任何角度，应以弧度为单位；然而，此任务中并未明确出现角度。",
            "solution": "### 1. 问题阐述与离散化\n\n该问题涉及一维反应扩散边值问题的数值解：\n$$\n- \\frac{d^2 u}{dx^2} + \\alpha u = f(x), \\quad x \\in (0,1)\n$$\n其边界条件为齐次狄利克雷边界条件 $u(0) = u(1) = 0$。常数 $\\alpha \\ge 0$ 代表反应系数。\n\n我们在一个具有 $n$ 个内部点 $x_i = i h$（$i=1, \\dots, n$）的均匀网格上离散化该方程，其中网格间距为 $h = \\frac{1}{n+1}$。对二阶导数使用二阶中心有限差分近似，我们得到一个线性方程组 $A \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} \\in \\mathbb{R}^n$ 是近似解值 $u(x_i)$ 的向量。矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 由下式给出：\n$$\nA = \\frac{1}{h^2} \\operatorname{tridiag}(-1, 2, -1) + \\alpha I\n$$\n其中 $I$ 是 $n \\times n$ 单位矩阵。对于所有 $\\alpha \\ge 0$，矩阵 $A$ 都是对称正定的 (SPD)，这是应用共轭梯度法的必要条件。\n\n右端向量 $\\mathbf{b} \\in \\mathbb{R}^n$ 是通过 $A$ 的两个特定特征向量的线性组合来构造的。离散拉普拉斯算子（因此也是 $A$）的（未归一化的）特征向量是离散正弦向量 $v_j$，其分量为 $(v_j)_i = \\sin\\left(\\frac{j \\pi i}{n+1}\\right)$。问题指定将 $\\mathbf{b}$ 构造为：\n$$\n\\mathbf{b} = c_1 v_1 + c_2 v_n\n$$\n这种构造激发了系统的最低频率模式 ($v_1$) 和最高频率模式 ($v_n$)，它们分别对应于 $A$ 的最小和最大特征值。这是一种研究迭代法在具有大条件数问题上收敛行为的标准技术。\n\n### 2. 共轭梯度法与收敛度量\n\n共轭梯度 (CG) 法是一种用于求解大型稀疏线性系统 $A \\mathbf{x} = \\mathbf{b}$ 的迭代算法，其中 $A$ 是对称正定的。从一个初始猜测 $\\mathbf{x}_0$ 开始，CG 生成一个迭代序列 $\\mathbf{x}_k$，该序列收敛到精确解 $\\mathbf{x}^\\star = A^{-1}\\mathbf{b}$。\n\nCG 的一个关键性质是，在每次迭代 $k$ 中，迭代向量 $\\mathbf{x}_k$ 在仿射克雷洛夫子空间 $\\mathbf{x}_0 + \\mathcal{K}_k(A, \\mathbf{r}_0)$ 上最小化误差的 $A$-范数 $\\|\\mathbf{e}_k\\|_A$。其中，误差为 $\\mathbf{e}_k = \\mathbf{x}_k - \\mathbf{x}^\\star$，初始残差为 $\\mathbf{r}_0 = \\mathbf{b} - A \\mathbf{x}_0$。$A$-范数，或称能量范数，定义为：\n$$\n\\|\\mathbf{e}\\|_A = \\sqrt{\\mathbf{e}^\\top A \\mathbf{e}}\n$$\n由于克雷洛夫子空间是嵌套的 ($\\mathcal{K}_k \\subseteq \\mathcal{K}_{k+1}$)，这种最小化性质保证了误差的能量范数是单调非增的：\n$$\n\\|\\mathbf{e}_{k+1}\\|_A \\le \\|\\mathbf{e}_k\\|_A\n$$\n在精确算术中，除非已经找到解（$\\mathbf{e}_k = \\mathbf{0}$），否则该不等式是严格的（$\\|\\mathbf{e}_{k+1}\\|_A  \\|\\mathbf{e}_k\\|_A$）。\n\n关注的第二个度量是残差的欧几里得范数 $\\|\\mathbf{r}_k\\|_2$，其中 $\\mathbf{r}_k = \\mathbf{b} - A \\mathbf{x}_k$。虽然通常用作实用的停止准则，但序列 $\\|\\mathbf{r}_k\\|_2$ **不**保证是单调的。CG 算法通过短递推关系更新残差，这种方式虽然计算上高效，但可能导致残差范数的暂时增加。这种现象在谱条件数大的问题中最为显著，此时算法试图消除与谱的不同部分相对应的误差分量。从与极端特征值相关的特征向量构造 $\\mathbf{b}$ 正是为了引出这种行为。\n\n### 3. 实现与分析策略\n\n任务的核心是实现 CG 算法，并为特定的问题实例跟踪这两个范数。\n\n**步骤 1：系统构建**\n对于由 $(n, \\alpha, (c_1, c_2))$ 定义的每个测试用例，我们首先根据所提供的公式构建矩阵 $A$ 和向量 $\\mathbf{b}$。\n\n**步骤 2：精确解**\n为了计算误差 $\\mathbf{e}_k$ 及其能量范数 $\\|\\mathbf{e}_k\\|_A$，需要精确解 $\\mathbf{x}^\\star$。我们在每个测试用例开始时，通过使用直接求解器（例如 `numpy.linalg.solve`）求解 $A \\mathbf{x}^\\star = \\mathbf{b}$ 来计算一次该解。\n\n**步骤 3：CG 迭代与数据收集**\n我们实现标准的 CG 算法，从 $\\mathbf{x}_0 = \\mathbf{0}$ 开始。我们迭代足够的步数（例如 $n+1$ 步）以观察收敛行为，并在每次迭代 $k=0, 1, 2, \\dots$ 中记录 $\\|\\mathbf{r}_k\\|_2$ 和 $\\|\\mathbf{e}_k\\|_A$ 的值。\n\n**步骤 4：后处理与报告**\n在收集范数历史记录后，我们对其进行分析，以确定每个测试用例所需的五个输出：\n1.  **残差非单调性**：我们检查是否存在任何 $k \\ge 1$ 使得 $\\|\\mathbf{r}_k\\|_2  \\|\\mathbf{r}_{k-1}\\|_2$。\n2.  **能量范数严格递减**：我们验证对于所有 $k \\ge 1$ 且 $\\|\\mathbf{e}_{k-1}\\|_A$ 不可忽略的情况下，是否有 $\\|\\mathbf{e}_k\\|_A  \\|\\mathbf{e}_{k-1}\\|_A$。在精确算术中，这在收敛前总是成立的。\n3.  **朴素停止条件**：如果残差范数是非单调的，我们确定出现增加的第一次迭代 $k_{naive}$。然后我们确定满足能量范数容差 $\\|\\mathbf{e}_k\\|_A \\le 10^{-8} \\|\\mathbf{e}_0\\|_A$ 的迭代次数 $k_{\\mathrm{energy}}$。如果 $k_{naive}  k_{\\mathrm{energy}}$，则输出为 `True`，表示基于残差增加的朴素停止规则会过早终止。\n4.  **$k_{\\mathrm{res}}$**：我们找到满足基于残差的停止准则 $\\|\\mathbf{r}_k\\|_2 \\le 10^{-8} \\|\\mathbf{r}_0\\|_2$ 的最小迭代次数 $k$。\n5.  **$k_{\\mathrm{energy}}$**：我们找到满足基于能量的停止准则的最小迭代次数 $k$。\n\n这种系统化的方法将使我们能够严格地证明共轭梯度法指定的收敛性质。对于测试用例 3，其中 $\\mathbf{b}$ 是单个特征向量 ($c_2=0.0$)，我们预计 CG 将在单次迭代中收敛，从而导致范数单调递减且不会提前停止。\n\n```python\nimport numpy as np\n\ndef run_cg_test(n, alpha_const, c_coeffs):\n    \"\"\"\n    Runs a single test case for the Conjugate Gradient method analysis.\n\n    For a given problem configuration (n, alpha, c_coeffs), this function:\n    1. Constructs the problem matrix A and right-hand side b.\n    2. Solves for the exact solution x_star to enable error calculations.\n    3. Implements the Conjugate Gradient algorithm, storing the history of\n       the residual norm and the energy norm of the error.\n    4. Analyzes the norm histories to determine the five required metrics:\n       - Whether the residual norm was non-monotone.\n       - Whether the energy norm was strictly decreasing.\n       - Whether a naive stop based on residual increase would be premature.\n       - The iteration count to meet the residual tolerance (k_res).\n       - The iteration count to meet the energy norm tolerance (k_energy).\n    \n    Returns a tuple of these five results.\n    \"\"\"\n    c1, c2 = c_coeffs\n    h = 1.0 / (n + 1)\n    \n    # Construct the matrix A for the 1D Poisson problem with reaction\n    main_diag = 2.0 * np.ones(n)\n    off_diag = -1.0 * np.ones(n - 1)\n    A = (1.0 / h**2) * (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1))\n    if alpha_const > 0:\n        A += alpha_const * np.eye(n)\n\n    # Construct the right-hand side vector b from eigenvectors\n    i_vec = np.arange(1, n + 1)\n    v1 = np.sin(np.pi * i_vec / (n + 1))\n    vn = np.sin(n * np.pi * i_vec / (n + 1))\n    b = c1 * v1 + c2 * vn\n\n    # Compute exact solution using a direct solver for error calculation\n    x_star = np.linalg.solve(A, b)\n\n    # CG algorithm initialization\n    x = np.zeros(n)\n    r = b.copy() # Since x_0=0, r_0 = b - A*0 = b\n    p = r.copy()\n    rs_old_sq = r.T @ r\n\n    r0_norm = np.sqrt(rs_old_sq)\n    e0 = x - x_star\n    e0_A_norm = np.sqrt(e0.T @ A @ e0)\n\n    res_norms = []\n    energy_norms = []\n\n    # Run CG for a fixed number of iterations to collect a full history\n    max_iter = n + 1 \n    for k in range(max_iter):\n        # Calculate and store norms for the current iteration k\n        e = x - x_star\n        res_norms.append(np.sqrt(r.T @ r))\n        energy_norms.append(np.sqrt(e.T @ A @ e))\n\n        # Check for convergence to avoid division by zero and unnecessary computation\n        if np.sqrt(rs_old_sq)  1e-16:\n             # Fill remaining norm history if we stopped early\n             for _ in range(k + 1, max_iter):\n                 res_norms.append(res_norms[-1])\n                 energy_norms.append(energy_norms[-1])\n             break\n        \n        # Standard CG step\n        Ap = A @ p\n        alpha_cg = rs_old_sq / (p.T @ Ap)\n        x += alpha_cg * p\n        r -= alpha_cg * Ap\n        rs_new_sq = r.T @ r\n        beta = rs_new_sq / rs_old_sq\n        p = r + beta * p\n        rs_old_sq = rs_new_sq\n\n    # --- Analyze the collected data ---\n    \n    # 1. Check if the residual norm sequence is non-monotone\n    is_res_non_monotone = False\n    naive_stop_iter = -1\n    for k in range(1, len(res_norms)):\n        if res_norms[k] > res_norms[k-1] and res_norms[k-1] > 1e-15:\n            is_res_non_monotone = True\n            if naive_stop_iter == -1: # Record first occurrence\n                naive_stop_iter = k\n    \n    # 2. Check if the energy norm is strictly decreasing\n    is_energy_strictly_decreasing = True\n    for k in range(1, len(energy_norms)):\n        if energy_norms[k-1] > 1e-15: # If previous norm was non-zero\n            if energy_norms[k] >= energy_norms[k-1]:\n                is_energy_strictly_decreasing = False\n                break\n    \n    # 5. Find k_energy: iteration to meet energy norm tolerance\n    tau_energy = 1e-8\n    try:\n        # Use a small tolerance to prevent issues with e0_A_norm being zero\n        if e0_A_norm > 1e-15:\n            k_energy = next(k for k, norm in enumerate(energy_norms) if norm = tau_energy * e0_A_norm)\n        else:\n            k_energy = 0\n    except StopIteration:\n        k_energy = -1 # Sentinel for not converged\n\n    # 3. Check if a naive stop would be premature\n    is_naive_stop_early = False\n    if naive_stop_iter != -1 and (k_energy == -1 or naive_stop_iter  k_energy):\n        is_naive_stop_early = True\n\n    # 4. Find k_res: iteration to meet residual norm tolerance\n    tau_res = 1e-8\n    try:\n        if r0_norm > 1e-15:\n            k_res = next(k for k, norm in enumerate(res_norms) if norm = tau_res * r0_norm)\n        else:\n            k_res = 0\n    except StopIteration:\n        k_res = -1 # Sentinel for not converged\n\n    return is_res_non_monotone, is_energy_strictly_decreasing, is_naive_stop_early, k_res, k_energy\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (50, 0.0, (1.0, 0.3)),\n        (80, 5.0, (1.0, 0.2)),\n        (60, 0.0, (1.0, 0.0)),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        # Unpack n, alpha, and the tuple (c1, c2)\n        n, alpha_const, c_coeffs = params\n        result_tuple = run_cg_test(n, alpha_const, c_coeffs)\n        all_results.append(list(result_tuple))\n    \n    # Format the final output string as specified in the problem statement.\n    # e.g., [[true,true,false,2,2],[...],[...]]\n    item_strs = []\n    for res in all_results:\n        # Convert booleans to lowercase strings \"true\" or \"false\"\n        str_res = [str(r).lower() if isinstance(r, bool) else str(r) for r in res]\n        item_strs.append(f\"[{','.join(str_res)}]\")\n    \n    final_output = f\"[{','.join(item_strs)}]\"\n    print(final_output)\n\n# To generate the required output, this function would be executed.\n# solve()\n```",
            "answer": "$$\n\\boxed{[[true,true,true,51,51],[true,true,true,81,81],[false,true,false,1,1]]}\n$$"
        }
    ]
}