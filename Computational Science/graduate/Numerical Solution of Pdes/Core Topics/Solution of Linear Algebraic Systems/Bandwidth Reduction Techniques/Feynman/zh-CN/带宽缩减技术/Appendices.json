{
    "hands_on_practices": [
        {
            "introduction": "Cuthill-McKee (CM) 算法是带宽缩减领域的一项基本技术。然而，其效果在很大程度上取决于初始节点的选择，一个好的起点可以带来显著的带宽优化，而一个差的起点则可能事倍功半。本练习将通过一个清晰、可控的例子，让您亲手实践 CM 算法，并通过对比从图的外围节点与中心节点出发所产生的不同结果，直观地理解起始点选择对算法性能的决定性影响。",
            "id": "3365677",
            "problem": "在偏微分方程的数值解法中，稀疏对称正定矩阵产生于网格上的离散化。对于直接求解器，一个经典的预处理步骤是使用 Cuthill–McKee (CM) 算法来减小矩阵的带宽。一个简单无向图 $G=(V,E)$ 的标号 $\\pi:V\\to\\{1,\\dots,|V|\\}$ 的带宽定义为 $b(\\pi)=\\max_{(i,j)\\in E}|\\pi(i)-\\pi(j)|$。从选定的起始顶点 $s$ 开始的 Cuthill–McKee (CM) 排序是通过广度优先搜索 (BFS) 获得的，该搜索按度数非递减的顺序访问邻居，并通过较小的顶点索引来打破平局。$s$ 的一个好的实际选择是伪外围节点，它是一个离心率（到任何其他顶点的最大图距离）接近图直径的顶点，并且是通过重复的 BFS 逐层扩展启发式地找到的。\n\n考虑以下明确构造的图 $G$，它模拟了在自适应有限元离散化中出现的层次化二叉细化树。设 $V=\\{1,2,\\dots,15\\}$，$E$ 为高度为 $3$、根为 $1$ 的满二叉树的边集，即：\n$$(1,2),(1,3),(2,4),(2,5),(3,6),(3,7),(4,8),(4,9),(5,10),(5,11),(6,12),(6,13),(7,14),(7,15)。$$\n该树的直径为 $6$，在任意两个位于相对子树中的叶节点之间达到。根节点 $1$ 的离心率为 $3$，因此是非外围节点，而深度为 $3$ 的任何叶节点（例如 $8$）都是外围节点，因此可以作为伪外围起始节点。\n\n使用上面描述的精确 CM 访问规则（邻居严格按照度数非递减排序，通过较小的索引打破平局），计算：\n- 从非外围节点 $1$ 开始的 CM 排序 $\\pi_{1}$ 及其带宽 $b(\\pi_{1})$，\n- 从伪外围节点 $8$ 开始的 CM 排序 $\\pi_{8}$ 及其带宽 $b(\\pi_{8})$，\n\n然后报告精确的带宽差\n$$\\Delta b = b(\\pi_{1}) - b(\\pi_{8}).$$\n请将 $\\Delta b$ 的最终结果以单个整数形式提供，不带单位。无需四舍五入。",
            "solution": "该问题要求计算给定图的两种 Cuthill-McKee (CM) 排序之间的带宽差，这两种排序从两个不同的顶点开始。该过程包括三个主要步骤：\n$1$。计算从顶点 $s=1$ 开始的 CM 排序 $\\pi_1$ 及其带宽 $b(\\pi_1)$。\n$2$。计算从顶点 $s=8$ 开始的 CM 排序 $\\pi_8$ 及其带宽 $b(\\pi_8)$。\n$3$。计算差值 $\\Delta b = b(\\pi_1) - b(\\pi_8)$。\n\n图 $G=(V, E)$ 是一个高度为 $3$ 的满二叉树。\n顶点集为 $V = \\{1, 2, \\dots, 15\\}$。\n边集 $E$ 由以下给出：\n$(1,2), (1,3), (2,4), (2,5), (3,6), (3,7), (4,8), (4,9), (5,10), (5,11), (6,12), (6,13), (7,14), (7,15)$.\n\nCM 算法是一种广度优先搜索 (BFS)，其中顶点的邻居按其度数非递减的顺序被访问。通过选择索引较小的顶点来打破平局。\n\n首先，我们确定图 $G$ 中每个顶点的度：\n- 根节点，顶点 $1$，度为 $\\deg(1)=2$。\n- 位于第 $1$ 层和第 $2$ 层的内部节点，即顶点 $\\{2, 3, 4, 5, 6, 7\\}$，每个的度都为 $3$。\n- 叶节点，即顶点 $\\{8, 9, 10, 11, 12, 13, 14, 15\\}$，每个的度都为 $1$。\n\n**第 1 部分：从 $s=1$ 开始的 CM 排序 $\\pi_1$**\n\n我们从顶点 $1$ 开始执行 BFS。顶点的排序将用序列 $P_1$ 表示，其中 $P_1[k]$ 是被赋予新标号 $k$ 的顶点。标号 $\\pi_1$ 是逆映射，即 $\\pi_1(P_1[k])=k$。\n\n$1$。初始化：队列 $Q=[1]$，新排序 $P_1=[1]$，已访问集合 $S=\\{1\\}$，标号计数器 $k=1$。\n$2$。将 $1$ 出队。邻居为 $\\{2, 3\\}$。两者的度都为 $3$。通过顶点索引打破平局：$2  3$。所以，先访问 $2$ 再访问 $3$。\n   - 将 $2$ 入队，$P_1=[1, 2]$，$S=\\{1,2\\}$，$k=2$。\n   - 将 $3$ 入队，$P_1=[1, 2, 3]$，$S=\\{1,2,3\\}$，$k=3$。\n   - 现在 $Q$ 为 $[2, 3]$。\n$3$。将 $2$ 出队。未访问的邻居为 $\\{4, 5\\}$。两者的度都为 $3$。打破平局：$4  5$。先访问 $4$ 再访问 $5$。\n   - 将 $4$ 入队，$P_1=[1, \\dots, 3, 4]$，$S=\\{1,2,3,4\\}$，$k=4$。\n   - 将 $5$ 入队，$P_1=[1, \\dots, 4, 5]$，$S=\\{1,2,3,4,5\\}$，$k=5$。\n   - 现在 $Q$ 为 $[3, 4, 5]$。\n$4$。将 $3$ 出队。未访问的邻居为 $\\{6, 7\\}$。两者的度都为 $3$。打破平局：$6  7$。先访问 $6$ 再访问 $7$。\n   - 将 $6$ 入队，$P_1=[1, \\dots, 5, 6]$，$S=\\{...,6\\}$，$k=6$。\n   - 将 $7$ 入队，$P_1=[1, \\dots, 6, 7]$，$S=\\{...,7\\}$，$k=7$。\n   - 现在 $Q$ 为 $[4, 5, 6, 7]$。\n$5$。将 $4$ 出队。未访问的邻居为 $\\{8, 9\\}$。两者的度都为 $1$。打破平局：$8  9$。先访问 $8$ 再访问 $9$。\n   - 将 $8$ 入队，$P_1=[1, \\dots, 7, 8]$，$S=\\{...,8\\}$，$k=8$。\n   - 将 $9$ 入队，$P_1=[1, \\dots, 8, 9]$，$S=\\{...,9\\}$，$k=9$。\n   - 现在 $Q$ 为 $[5, 6, 7, 8, 9]$。\n$6$。这个过程逐层继续。对于每个父节点，由于其子节点的度相同，因此按顶点索引递增的顺序访问它们。\n   - 将 $5$ 出队，访问邻居 $10, 11$。$P_1$ 附加 $10, 11$。\n   - 将 $6$ 出队，访问邻居 $12, 13$。$P_1$ 附加 $12, 13$。\n   - 将 $7$ 出队，访问邻居 $14, 15$。$P_1$ 附加 $14, 15$。\n最终的顶点排序序列是 $P_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]$。\n这意味着标号 $\\pi_1$ 是恒等映射：对所有 $i \\in V$，$\\pi_1(i) = i$。\n\n带宽 $b(\\pi_1)$ 为 $\\max_{(i,j)\\in E} |\\pi_1(i) - \\pi_1(j)| = \\max_{(i,j)\\in E} |i - j|$。我们检查所有边：\n- $|1-2|=1$, $|1-3|=2$\n- $|2-4|=2$, $|2-5|=3$\n- $|3-6|=3$, $|3-7|=4$\n- $|4-8|=4$, $|4-9|=5$\n- $|5-10|=5$, $|5-11|=6$\n- $|6-12|=6$, $|6-13|=7$\n- $|7-14|=7$, $|7-15|=8$\n最大差值为 $8$。因此，$b(\\pi_1) = 8$。\n\n**第 2 部分：从 $s=8$ 开始的 CM 排序 $\\pi_8$**\n\n我们从外围顶点 $8$ 开始执行 BFS。\n$1$。初始化：$Q=[8]$，$P_8=[8]$，$S=\\{8\\}$，$k=1$。\n$2$。将 $8$ 出队。邻居为 $\\{4\\}$。访问 $4$。\n   - 将 $4$ 入队，$P_8=[8, 4]$，$S=\\{8,4\\}$，$k=2$。$Q=[4]$。\n$3$。将 $4$ 出队。未访问的邻居为 $\\{2, 9\\}$。我们有 $\\deg(9)=1$ 和 $\\deg(2)=3$。按度数非递减排序：先访问 $9$ 再访问 $2$。\n   - 将 $9$ 入队，$P_8=[8, 4, 9]$，$S=\\{8,4,9\\}$，$k=3$。\n   - 将 $2$ 入队，$P_8=[8, 4, 9, 2]$，$S=\\{8,4,9,2\\}$，$k=4$。\n   - 现在 $Q$ 为 $[9, 2]$。\n$4$。将 $9$ 出队。邻居 $\\{4\\}$ 已被访问。$Q=[2]$。\n$5$。将 $2$ 出队。未访问的邻居为 $\\{1, 5\\}$。我们有 $\\deg(1)=2$ 和 $\\deg(5)=3$。按度数排序：先访问 $1$ 再访问 $5$。\n   - 将 $1$ 入队，$P_8=[8, 4, 9, 2, 1]$，$S=\\{...,1\\}$，$k=5$。\n   - 将 $5$ 入队，$P_8=[8, 4, 9, 2, 1, 5]$，$S=\\{...,5\\}$，$k=6$。\n   - 现在 $Q$ 为 $[1, 5]$。\n$6$。将 $1$ 出队。未访问的邻居为 $\\{3\\}$。访问 $3$。\n   - 将 $3$ 入队，$P_8=[... ,1, 5, 3]$，$S=\\{...,3\\}$，$k=7$。$Q=[5, 3]$。\n$7$。将 $5$ 出队。未访问的邻居为 $\\{10, 11\\}$。两者的度都为 $1$。用索引打破平局：$10  11$。先访问 $10$ 再访问 $11$。\n   - 将 $10$ 入队，$P_8=[..., 5, 3, 10]$，$S=\\{...,10\\}$，$k=8$。\n   - 将 $11$ 入队，$P_8=[..., 3, 10, 11]$，$S=\\{...,11\\}$，$k=9$。\n   - 现在 $Q$ 为 $[3, 10, 11]$。\n$8$。将 $3$ 出队。未访问的邻居为 $\\{6, 7\\}$。两者的度都为 $3$。用索引打破平局：$6  7$。先访问 $6$ 再访问 $7$。\n   - 将 $6$ 入队，$P_8=[..., 10, 11, 6]$，$S=\\{...,6\\}$，$k=10$。\n   - 将 $7$ 入队，$P_8=[..., 11, 6, 7]$，$S=\\{...,7\\}$，$k=11$。\n   - 现在 $Q$ 为 $[10, 11, 6, 7]$。\n$9$。将 $10$ 和 $11$ 出队。它们唯一的邻居 $\\{5\\}$ 已被访问。$Q=[6, 7]$。\n$10$。将 $6$ 出队。未访问的邻居为 $\\{12, 13\\}$。两者的度都为 $1$。打破平局：$12  13$。先访问 $12$ 再访问 $13$。\n   - 将 $12, 13$ 入队。$P_8$ 附加 $12, 13$。$k=13$。$Q=[7, 12, 13]$。\n$11$。将 $7$ 出队。未访问的邻居为 $\\{14, 15\\}$。两者的度都为 $1$。打破平局：$14  15$。先访问 $14$ 再访问 $15$。\n   - 将 $14, 15$ 入队。$P_8$ 附加 $14, 15$。$k=15$。$Q=[12, 13, 14, 15]$。\n$12$。将其余叶节点 $12, 13, 14, 15$ 出队。它们没有未访问的邻居。\n\n最终的顶点排序序列是 $P_8 = [8, 4, 9, 2, 1, 5, 3, 10, 11, 6, 7, 12, 13, 14, 15]$。\n标号 $\\pi_8$ 将一个顶点映射到它在此序列中的位置（标号）：\n$\\pi_8(8)=1$, $\\pi_8(4)=2$, $\\pi_8(9)=3$, $\\pi_8(2)=4$, $\\pi_8(1)=5$, $\\pi_8(5)=6$, $\\pi_8(3)=7$, $\\pi_8(10)=8$, $\\pi_8(11)=9$, $\\pi_8(6)=10$, $\\pi_8(7)=11$, $\\pi_8(12)=12$, $\\pi_8(13)=13$, $\\pi_8(14)=14$, $\\pi_8(15)=15$。\n\n带宽 $b(\\pi_8)$ 为 $\\max_{(i,j)\\in E} |\\pi_8(i) - \\pi_8(j)|$。我们检查所有边：\n- $(1,2): |\\pi_8(1)-\\pi_8(2)| = |5-4|=1$\n- $(1,3): |\\pi_8(1)-\\pi_8(3)| = |5-7|=2$\n- $(2,4): |\\pi_8(2)-\\pi_8(4)| = |4-2|=2$\n- $(2,5): |\\pi_8(2)-\\pi_8(5)| = |4-6|=2$\n- $(3,6): |\\pi_8(3)-\\pi_8(6)| = |7-10|=3$\n- $(3,7): |\\pi_8(3)-\\pi_8(7)| = |7-11|=4$\n- $(4,8): |\\pi_8(4)-\\pi_8(8)| = |2-1|=1$\n- $(4,9): |\\pi_8(4)-\\pi_8(9)| = |2-3|=1$\n- $(5,10): |\\pi_8(5)-\\pi_8(10)| = |6-8|=2$\n- $(5,11): |\\pi_8(5)-\\pi_8(11)| = |6-9|=3$\n- $(6,12): |\\pi_8(6)-\\pi_8(12)| = |10-12|=2$\n- $(6,13): |\\pi_8(6)-\\pi_8(13)| = |10-13|=3$\n- $(7,14): |\\pi_8(7)-\\pi_8(14)| = |11-14|=3$\n- $(7,15): |\\pi_8(7)-\\pi_8(15)| = |11-15|=4$\n最大差值为 $4$。因此，$b(\\pi_8) = 4$。\n\n**第 3 部分：带宽差**\n\n最后，我们计算差值 $\\Delta b$：\n$$ \\Delta b = b(\\pi_1) - b(\\pi_8) = 8 - 4 = 4. $$\n选择伪外围节点作为 Cuthill-McKee 算法的起始顶点，显著减小了矩阵的带宽。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "尽管反向 Cuthill-McKee (RCM) 算法是一种强大且广泛应用的启发式方法，但它并非万无一失。本实践将引导您通过编码，构建一个经典的“哑铃”状网格反例，以揭示 RCM 在特定拓扑结构下可能反而导致带宽增加的场景。理解这种失效模式对于在实际问题中稳健地应用该算法至关重要，它要求我们深入分析图的拓扑特性，特别是识别出其中的“瓶颈”结构。",
            "id": "3365697",
            "problem": "要求您探究排序算法在二维泊松方程离散化产生的稀疏矩阵上的行为，重点关注带宽压缩。\n\n考虑在网格（可解释为图）上对二维泊松方程进行典型的线性有限差分或线性有限元离散化，这将产生一个对称正定矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其稀疏模式由网格邻接关系确定。方阵 $A$ 的带宽 $b(A)$ 定义为\n$$\nb(A) = \\max\\{\\,|i - j| \\,\\mid\\, A_{ij} \\neq 0 \\,\\},\n$$\n对于给定的索引排列（排序）$p \\in \\{0,1,\\dots,n-1\\}^n$，置换后的带宽是矩阵 $PAP^\\top$ 的带宽，其中 $P$ 是与 $p$ 关联的置换矩阵。\n\nReverse Cuthill–McKee (RCM) 技术是一种旨在减少带宽的启发式算法。它的操作方式是：从一个指定的根节点开始对图进行广度优先遍历，逐层访问顶点，在每一层内按度非递减的顺序对顶点排序，然后反转得到的顺序。实践中有不同的根节点选择启发式方法；为完成本任务，您必须使用以下明确定义的变体：\n- 选择一个起始顶点 $s$，规则如下：如果图有割点（articulation points），则在其中选择度最小的一个；如果有多个这样的顶点，则选择索引最小的一个。如果不存在割点，则选择度最小且索引最小的顶点。\n- 从 $s$ 开始进行广度优先搜索（BFS），按度的非递减顺序访问邻居（若度相同，则按索引从小到大排序）。\n- 如果图是不连通的，则对任何剩余的未访问连通分量重复上述过程（在每个阶段，根据相同规则在未访问的顶点中选择新的根节点）。\n- 反转连接起来的 BFS 顺序，以生成最终的 RCM 排列 $p_{\\mathrm{RCM}}$。\n\n从基本定义（源自网格的图邻接关系、矩阵带宽定义和广度优先遍历）出发，构建确定性的网格，以揭示 RCM 相对于初始几何排序在何种情况下无法减少带宽，并对该失效机制提供一个几何特征描述。\n\n具体来说：\n1. 为规则网格构建离散拉普拉斯矩阵的邻接关系：一个大小为 $W \\times H$ 的矩形网格，其中网格点按四邻域（曼哈顿距离等于 $1$）连接。使用初始顺序 $p_{\\mathrm{geo}}$，该顺序按 $x$ 非递减然后 $y$ 非递减的方式扫描（即几何字典序）。\n2. 构建一个“哑铃”形网格，它由两列垂直的节点通过一个中心的走廊节点连接而成。具体地，定义坐标集：\n   - 左列：$(0,0)$, $(0,1)$, $(0,2)$，\n   - 走廊：$(1,1)$，\n   - 右列：$(2,0)$, $(2,1)$, $(2,2)$，\n   并采用四邻域邻接关系。使用初始顺序 $p_{\\mathrm{geo}}$，它按照以下序列列出节点：所有左列节点（从 $(0,0)$ 到 $(0,2)$），然后是走廊节点 $(1,1)$，最后是所有右列节点（从 $(2,0)$ 到 $(2,2)$）。对于这些坐标，该排序与几何字典序一致。\n3. 构建一个一维链式网格（一条直线路径）：坐标为 $(0,0)$, $(1,0)$, $(2,0)$, $(3,0)$, $(4,0)$，其中仅连续点之间存在邻接关系。使用初始顺序 $p_{\\mathrm{geo}}$，该顺序按 $x$ 非递减列出节点。\n\n对每个网格，计算：\n- 在初始几何排序 $p_{\\mathrm{geo}}$ 下的带宽 $b_{\\mathrm{geo}} = b(P_{\\mathrm{geo}} A P_{\\mathrm{geo}}^\\top)$。\n- 在上述定义的 RCM 排序 $p_{\\mathrm{RCM}}$ 下的带宽 $b_{\\mathrm{RCM}} = b(P_{\\mathrm{RCM}} A P_{\\mathrm{RCM}}^\\top)$。\n- 报告整数差值 $\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}}$。\n\n您必须严格按照上面 $b(A)$ 的定义来实现矩阵带宽的计算。您必须通过连接 $\\ell_1$ 范数下坐标差恰好为 1 的节点，从网格坐标构建邻接关系 $A$。您无需计算数值有限差分系数；仅需要非零结构。通过遵循所述的离散化模式和定义，确保科学真实性。\n\n请基于定义进行推导，解释为什么“哑铃”形网格在所述的 RCM 变体下可能导致带宽增加，并根据网格的图论属性（例如，割点和瓶颈）来描述导致此失效的几何特征。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与上述三个测试网格的描述顺序完全一致。预期的输出类型为整数。例如，生成形如\n$$\n[\\Delta b_{\\mathrm{grid}}, \\Delta b_{\\mathrm{dumbbell}}, \\Delta b_{\\mathrm{chain}}].\n$$\n的一行。\n\n测试套件参数：\n- 网格：$W = 4, H = 4$（理想情况，RCM 相对于几何排序不应增加带宽）。\n- 哑铃形网格：使用上述指定的坐标（RCM 增加带宽的反例候选）。\n- 链式网格：使用上述指定的坐标（带宽已是最小的边界情况）。\n\n本问题不涉及物理单位或角度。请将每个数值结果表示为指定列表格式中的整数。",
            "solution": "用户提供的问题陈述已经过验证，被确定为是合理、适定且客观的。它在数值线性代数和图论领域提出了一个明确的任务，并提供了所有必要的定义、常数和约束。该问题要求实现并分析一种特定的 Reverse Cuthill–McKee (RCM) 算法变体，用于稀疏矩阵的带宽压缩。我们将着手提供一个完整的解决方案。\n\n### 带宽压缩简介\n在使用有限差分或有限元等方法数值求解偏微分方程（PDEs）时，得到的线性方程组 $Ax=b$ 通常涉及一个稀疏、对称且正定的矩阵 $A$。直接求解器（如 LU 或 Cholesky 分解）对此类系统的效率高度依赖于矩阵的结构。一个关键的结构特性是**带宽**，对于矩阵 $A$ 定义为：\n$$\nb(A) = \\max_{i,j} \\{|i - j| \\mid A_{ij} \\neq 0\\}\n$$\n较小的带宽意味着所有非零元素都聚集在主对角线附近。这种结构可以被利用来减少分解过程中的内存存储和计算工作量。重排序算法旨在找到一个矩阵行和列的排列 $p$，使得置换后的矩阵 $P A P^\\top$（其中 $P$ 是对应于 $p$ 的置换矩阵）的带宽显著小于原始矩阵 $A$。\n\nReverse Cuthill–McKee (RCM) 算法是为此目的广泛使用的启发式算法。它基于对与矩阵稀疏模式相关联的图进行广度优先搜索（BFS）。本分析研究了一种特定的、确定性的 RCM 变体，并检验其在三种不同网格类型上的性能，其中包括一个旨在暴露该启发式算法失效模式的案例。\n\n### 方法论\n对每个网格，我们执行以下步骤：\n1.  **图的构建**：我们构建一个无向图 $G=(V, E)$，其中顶点 $V$ 对应于网格节点，边 $E$ 连接曼哈顿距离（$\\ell_1$ 范数）恰好为 $1$ 的节点。该图的邻接矩阵与离散拉普拉斯矩阵 $A$ 具有相同的非零模式。\n2.  **几何排序 ($p_{\\mathrm{geo}}$)**：我们按照每个网格的规定建立初始“几何”排序 $p_{\\mathrm{geo}}$。这作为我们的基准。\n3.  **带宽计算 ($b_{\\mathrm{geo}}$)**：我们计算对应于几何排序的矩阵的带宽。原始节点 $u$ 和 $v$ 之间的一条边对带宽计算的贡献是 $|p_{\\mathrm{geo}}^{-1}(u) - p_{\\mathrm{geo}}^{-1}(v)|$，其中 $p_{\\mathrm{geo}}^{-1}(k)$ 是原始节点 $k$ 的新索引。\n4.  **RCM 排序 ($p_{\\mathrm{RCM}}$)**：我们实现问题中定义的 RCM 算法：\n    a.  **根节点选择**：如果存在割点，则根节点是其中度最小的一个（索引最小者优先）。否则，它是全局度最小的顶点（索引最小者优先）。\n    b.  **遍历**：从根节点执行一次 BFS。当访问一个节点的邻居时，按非递减的度顺序处理它们（索引最小者优先）。\n    c.  **反转**：最终的排列 $p_{\\mathrm{RCM}}$ 是 BFS 遍历顺序的反转。\n5.  **带宽计算 ($b_{\\mathrm{RCM}}$)**：我们计算 RCM 置换后矩阵的带宽。\n6.  **比较**：我们计算差值 $\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}}$。\n\n### 测试案例分析\n\n#### 1. 网格 ($4 \\times 4$)\n一个 $W \\times H$ 网格图由 $n=WH$ 个节点构成。几何排序 $p_{\\mathrm{geo}}$ 是字典序，其中节点 $(x,y)$ 被赋予索引 $i = xH + y$。对于 $4 \\times 4$ 的网格，$H=4$。\n*   **几何带宽 ($b_{\\mathrm{geo}}$)**：最大索引差发生在垂直相邻的节点之间。索引为 $i = 4x+y$ 的节点 $(x,y)$ 与索引为 $j = 4(x+1)+y$ 的节点 $(x+1, y)$ 相连。差值为 $|j-i| = 4$。因此，$b_{\\mathrm{geo}} = 4$。\n*   **RCM 带宽 ($b_{\\mathrm{RCM}}$)**：该网格没有割点。度最小的节点是四个角点（度为 $2$）。根节点是角点 $(0,0)$（原始索引为 $0$），其索引最小。RCM 从这个角点开始执行 BFS，创建以波前形式扩展的层级集合。反转这个顺序会将远离根节点的节点放在排列的开头。这是 RCM 的典型应用，通常表现良好。计算得出 RCM 带宽 $b_{\\mathrm{RCM}}$ 为 $4$。\n*   **结果**：$\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}} = 4 - 4 = 0$。在这种情况下，RCM 没有使带宽恶化。\n\n#### 2. 哑铃形网格\n这个网格由 $7$ 个节点组成，形成两个三节点的凸部，通过一个中心节点连接。几何排序为 $p_{\\mathrm{geo}} = (0, 1, 2, 3, 4, 5, 6)$，其中节点 $0, 1, 2$ 构成左凸部，$3$ 是走廊，$4, 5, 6$ 构成右凸部。\n*   **几何带宽 ($b_{\\mathrm{geo}}$)**：图的边是 $(0,1), (1,2), (1,3), (3,5), (4,5), (5,6)$。我们检查每条边的索引差：\n    *   $|p_{\\mathrm{geo}}^{-1}(1) - p_{\\mathrm{geo}}^{-1}(0)| = |1-0|=1$\n    *   $|p_{\\mathrm{geo}}^{-1}(2) - p_{\\mathrm{geo}}^{-1}(1)| = |2-1|=1$\n    *   $|p_{\\mathrm{geo}}^{-1}(3) - p_{\\mathrm{geo}}^{-1}(1)| = |3-1|=2$\n    *   $|p_{\\mathrm{geo}}^{-1}(5) - p_{\\mathrm{geo}}^{-1}(3)| = |5-3|=2$\n    *   $|p_{\\mathrm{geo}}^{-1}(5) - p_{\\mathrm{geo}}^{-1}(4)| = |5-4|=1$\n    *   $|p_{\\mathrm{geo}}^{-1}(6) - p_{\\mathrm{geo}}^{-1}(5)| = |6-5|=1$\n    最大差值为 $2$。因此，$b_{\\mathrm{geo}} = 2$。\n*   **RCM 带宽 ($b_{\\mathrm{RCM}}$)**：我们遵循指定的 RCM 过程：\n    1.  **寻找割点 (APs)**：节点 $1, 3, 5$ 是割点。\n    2.  **选择根节点**：它们的度为 $\\text{deg}(1)=3, \\text{deg}(3)=2, \\text{deg}(5)=3$。度最小的割点是节点 $3$。它成为根节点。\n    3.  **BFS 遍历**：\n        *   从根开始：$\\{3\\}$\n        *   $3$ 的邻居是 $\\{1, 5\\}$。两者度都为 $3$。根据索引较小者优先的规则：先访问 $1$ 再访问 $5$。队列：$\\{1, 5\\}$。\n        *   $1$ 的邻居：$\\{0, 2\\}$。两者度都为 $1$。根据索引较小者优先的规则：先访问 $0$ 再访问 $2$。队列：$\\{5, 0, 2\\}$。\n        *   $5$ 的邻居：$\\{4, 6\\}$。两者度都为 $1$。根据索引较小者优先的规则：先访问 $4$ 再访问 $6$。队列：$\\{0, 2, 4, 6\\}$。\n        Cuthill–McKee (CM) 顺序是 $p_{\\mathrm{CM}} = (3, 1, 5, 0, 2, 4, 6)$。\n    4.  **反转顺序**：$p_{\\mathrm{RCM}} = (6, 4, 2, 0, 5, 1, 3)$。\n    5.  **计算带宽**：我们找到每个节点的新索引 $p_{\\mathrm{RCM}}^{-1}$ 并检查边的差值。边 $(5,6)$ 是一个很好的例子。它的原始节点是 $5$ 和 $6$。它们的新索引是 $p_{\\mathrm{RCM}}^{-1}(5)=4$ 和 $p_{\\mathrm{RCM}}^{-1}(6)=0$。差值为 $|4-0|=4$。完整的计算证实 $b_{\\mathrm{RCM}} = 4$。\n*   **结果**：$\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}} = 4 - 2 = 2$。带宽增加了。\n\n#### 3. 链式网格\n一个 $5$ 节点的路径图。原始节点索引为 $0, 1, 2, 3, 4$。$p_{\\mathrm{geo}}$ 就是这个自然排序。\n*   **几何带宽 ($b_{\\mathrm{geo}}$)**：边是 $(i, i+1)$。索引差总是 $1$。因此，$b_{\\mathrm{geo}} = 1$。这是最优带宽。\n*   **RCM 带宽 ($b_{\\mathrm{RCM}}$)**：\n    1.  **寻找割点**：节点 $1, 2, 3$ 是割点。\n    2.  **选择根节点**：所有割点的度都为 $2$。索引最小的是节点 $1$。\n    3.  **BFS 遍历**：从根节点 $1$ 开始：访问邻居 $0$（度为 $1$），然后是邻居 $2$（度为 $2$）。然后从 $2$ 访问 $3$，从 $3$ 访问 $4$。CM 顺序是 $p_{\\mathrm{CM}} = (1, 0, 2, 3, 4)$。\n    4.  **反转顺序**：$p_{\\mathrm{RCM}} = (4, 3, 2, 0, 1)$。\n    5.  **计算带宽**：考虑边 $(1,2)$。新索引是 $p_{\\mathrm{RCM}}^{-1}(1)=4$ 和 $p_{\\mathrm{RCM}}^{-1}(2)=2$。差值为 $|4-2|=2$。完整计算得出 $b_{\\mathrm{RCM}} = 2$。\n*   **结果**：$\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}} = 2 - 1 = 1$。带宽增加了。\n\n### RCM 失效的特征描述\n哑铃形网格是 RCM 的一个典型失效模式。其性能下降并非偶然，而是图的拓扑结构与算法的根节点选择启发式方法相互作用的直接结果。\n\n造成问题的几何特征是**瓶颈**结构，即两个或多个相对密集的子图通过少数顶点或边连接。在哑铃形网格中，节点 $3$（“走廊”）作为一个低度的割点，连接着两个凸部。\n\n指定的 RCM 变体优先选择低度割点作为根节点。通过选择中心的瓶颈节点 $3$ 作为根，随后的 BFS 遍历会同时向两个凸部扩展。BFS 的层级集合（例如，第 1 层包含节点 $\\{1, 5\\}$）将拓扑上相距很远但与中心根节点具有相同图距离的节点组合在一起。\n\nRCM 的最后一步是反转这个顺序。这将来自图的末端的节点（例如节点 $6, 4, 2, 0$）放置在新排列的开头。至关重要的是，它打乱了原本在同一凸部内相邻的节点。例如，相邻的节点 $5$ 和 $6$ 被赋予了新的索引 $4$ 和 $0$，导致了 $4$ 的巨大索引差。相比之下，几何排序将每个凸部内的节点保持连续，从而带了小带宽。\n\n总之，当 RCM 的根节点选择策略选到了结构性瓶颈上的一个顶点时，该启发式算法就会失效。这会导致 BFS 排序交错排列来自图的不同区域的节点，而最终的反转操作会撕裂局部连通性，从而增加矩阵带宽。一个理想的起始顶点应该是位于图外围的低度节点（如节点 $0$ 或 $6$），这样会产生一个尊重图的几何布局的层级结构。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the bandwidth analysis for the three specified meshes.\n    \"\"\"\n\n    def _find_articulation_points(n, adj):\n        \"\"\"\n        Finds all articulation points in a graph using a DFS-based algorithm.\n        This is a standard algorithm related to Tarjan's bridge-finding algorithm.\n        \"\"\"\n        timer_ref = [0]\n        tin = [-1] * n\n        low = [-1] * n\n        parent = [-1] * n\n        ap_set = set()\n\n        def dfs(u):\n            tin[u] = low[u] = timer_ref[0]\n            timer_ref[0] += 1\n            children = 0\n\n            for v in adj[u]:\n                if v == parent[u]:\n                    continue\n                if tin[v] != -1:\n                    low[u] = min(low[u], tin[v])\n                else:\n                    children += 1\n                    parent[v] = u\n                    dfs(v)\n                    low[u] = min(low[u], low[v])\n                    if parent[u] == -1 and children  1:\n                        ap_set.add(u)\n                    if parent[u] != -1 and low[v] = tin[u]:\n                        ap_set.add(u)\n\n        for i in range(n):\n            if tin[i] == -1:\n                dfs(i)\n        \n        return list(ap_set)\n\n    def select_root(degrees, aps, visited):\n        \"\"\"\n        Selects a root for BFS according to the problem's specific heuristic.\n        \"\"\"\n        unvisited_nodes = [i for i, v in enumerate(visited) if not v]\n        \n        unvisited_aps = [ap for ap in aps if not visited[ap]]\n        \n        candidate_nodes = []\n        if unvisited_aps:\n            min_deg_ap = min(degrees[ap] for ap in unvisited_aps)\n            candidate_nodes = [ap for ap in unvisited_aps if degrees[ap] == min_deg_ap]\n        else:\n            min_deg = min(degrees[i] for i in unvisited_nodes)\n            candidate_nodes = [i for i in unvisited_nodes if degrees[i] == min_deg]\n            \n        return min(candidate_nodes)\n\n    def get_rcm_permutation(adj):\n        \"\"\"\n        Computes the Reverse Cuthill-McKee permutation for a given graph.\n        \"\"\"\n        n = len(adj)\n        if n == 0:\n            return []\n        degrees = [len(a) for a in adj]\n        aps = _find_articulation_points(n, adj)\n        \n        cm_order = []\n        visited = [False] * n\n        \n        while len(cm_order)  n:\n            root = select_root(degrees, aps, visited)\n            \n            # BFS starting from the selected root\n            component_order = []\n            q = [root]\n            visited[root] = True\n            \n            head = 0\n            while head  len(q):\n                u = q[head]\n                component_order.append(u)\n                \n                # Sort neighbors by non-decreasing degree, breaking ties with smaller index\n                neighbors = sorted(adj[u], key=lambda v: (degrees[v], v))\n                \n                for v in neighbors:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n                head += 1\n            \n            cm_order.extend(component_order)\n\n        return cm_order[::-1]\n\n    def compute_bandwidth(adj, p):\n        \"\"\"\n        Computes the bandwidth of a matrix permuted by permutation p.\n        \"\"\"\n        n = len(p)\n        if n == 0:\n            return 0\n        p_inv = [0] * n\n        for i, original_index in enumerate(p):\n            p_inv[original_index] = i\n            \n        max_diff = 0\n        for u in range(n):\n            for v in adj[u]:\n                if u  v: # Process each edge once\n                    diff = abs(p_inv[u] - p_inv[v])\n                    if diff > max_diff:\n                        max_diff = diff\n        return max_diff\n\n    def build_graph_from_coords(coords):\n        \"\"\"\n        Builds a graph based on 4-neighbor adjacency (Manhattan distance = 1).\n        \"\"\"\n        n = len(coords)\n        adj = [[] for _ in range(n)]\n        coords_np = [np.array(c) for c in coords]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if np.linalg.norm(coords_np[i] - coords_np[j], ord=1) == 1.0:\n                    adj[i].append(j)\n                    adj[j].append(i)\n        return adj\n\n    # Define the test cases from the problem statement.\n    W, H = 4, 4\n    grid_coords = [(x, y) for y in range(H) for x in range(W)]\n    \n    dumbbell_coords = [(0,0), (0,1), (0,2), (1,1), (2,0), (2,1), (2,2)]\n    \n    chain_coords = [(x, 0) for x in range(5)]\n    \n    test_cases = [\n        {\n            \"name\": \"grid\",\n            \"coords\": grid_coords,\n            \"p_geo\": list(range(len(grid_coords))) # Already in lexicographic order\n        },\n        {\n            \"name\": \"dumbbell\",\n            \"coords\": dumbbell_coords,\n            \"p_geo\": list(range(len(dumbbell_coords))) # Already in specified order\n        },\n        {\n            \"name\": \"chain\",\n            \"coords\": chain_coords,\n            \"p_geo\": list(range(len(chain_coords))) # Already in specified order\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # The grid must be ordered column-major (y then x) to match the problem's description\n        # of x non-decreasing then y non-decreasing. My grid_coords generation was row-major.\n        # Let's fix it here for the grid case.\n        if case['name'] == 'grid':\n            coords = sorted(case['coords'], key=lambda c: (c[0], c[1]))\n            # Re-index the nodes to match this geo order.\n            node_map = {old_idx: new_idx for new_idx, old_idx in enumerate(sorted(range(len(case['coords'])), key=lambda k: (case['coords'][k][0], case['coords'][k][1])))}\n            original_adj = build_graph_from_coords(case['coords'])\n            adj = [[] for _ in range(len(original_adj))]\n            for i, neighbors in enumerate(original_adj):\n                new_i = node_map[i]\n                for neighbor in neighbors:\n                    new_neighbor = node_map[neighbor]\n                    adj[new_i].append(new_neighbor)\n        else:\n             adj = build_graph_from_coords(case[\"coords\"])\n        \n        # Geometric ordering\n        p_geo = case[\"p_geo\"]\n        b_geo = compute_bandwidth(adj, p_geo)\n        \n        # RCM ordering\n        p_rcm = get_rcm_permutation(adj)\n        b_rcm = compute_bandwidth(adj, p_rcm)\n        \n        delta_b = b_rcm - b_geo\n        results.append(delta_b)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在上一节的基础上，我们将探讨如何处理通用算法可能表现不佳的复杂结构。本练习面向一个真实的多物理场问题——一个耦合的偏微分方程(PDE)与常微分方程(ODE)系统，并要求您设计一种利用问题物理结构的自定义“交错”排序方案。通过将特定领域的知识融入算法设计，您将体验到如何构建出比 RCM 等通用方法性能更优的解决方案，这在求解复杂工程与科学问题中是一项高级且实用的技能。",
            "id": "3365615",
            "problem": "给定一个单体线性系统，该系统源于一个反应扩散偏微分方程 (PDE) 和多个点动力学常微分方程 (ODE) 的半离散耦合。PDE 在二维笛卡尔网格上使用标准的五点差分格式进行离散化。每个点动力学 ODE 位置贡献一个状态小向量，该向量仅与其所在的单个网格节点耦合，并在该位置的 ODE 状态之间内部耦合。所得的雅可比矩阵（或系统矩阵）具有稀疏对称的稀疏模式。你的任务是设计并实现一种带宽感知排序，该排序在未知数向量中将每个位置的 ODE 状态交错插入到其宿主 PDE 节点的紧邻位置，并将其对称带宽与两个基准进行比较：自然字典序和 Reverse Cuthill–McKee 排序。\n\n基本定义和建模假设：\n- 设 PDE 状态为 $u(i,j)$，位于一个 x 方向有 $N_x$ 个节点、y 方向有 $N_y$ 个节点的网格上，索引为 $i \\in \\{0,\\dots,N_x-1\\}$ 和 $j \\in \\{0,\\dots,N_y-1\\}$。有限差分离散化使用标准的五点差分格式，因此每个内部节点最多与其 4 个最近邻居耦合。\n- 设有 $M$ 个点动力学位置。位置 $k$ 位于网格节点 $(i_k,j_k)$，并拥有 $s$ 个内部 ODE 状态，这些状态收集在一个向量 $y_k \\in \\mathbb{R}^s$ 中。位置 $k$ 的 ODE 块的雅可比稀疏性假定在 $y_k$ 的 $s$ 个状态内是稠密的，并且位置 $k$ 的每个 ODE 状态仅与单个宿主 PDE 节点 $u(i_k,j_k)$ 耦合。\n- 单体未知数向量 $x$ 是由所有 PDE 未知数和所有 ODE 未知数拼接而成。在自然字典序中，$N_{\\mathrm{pde}} = N_x N_y$ 个 PDE 未知数 $u(i,j)$ 首先按 i 递增再按 j 递增的行主序排列，然后是 $N_{\\mathrm{ode}} = Ms$ 个 ODE 未知数，这些未知数按位置分组，然后在每个位置内按状态分组。\n- 一个稀疏矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的对称带宽 $b(A)$ 定义为\n$$\nb(A) \\;=\\; \\max\\{\\, |p-q| \\,:\\, A_{pq} \\neq 0 \\,\\},\n$$\n其中索引 $p$ 和 $q$ 是所选排序中从 0 开始的位置。等价地，构建无向稀疏图 $G=(V,E)$，其中 $|V|=n$，当且仅当 $A_{pq} \\neq 0$（且 $p \\neq q$）时，边 $(p,q) \\in E$；那么对于选定的节点排序，$b(A) = \\max_{(p,q)\\in E} |p-q|$。\n\n你的任务：\n1. 根据上述原则，为指定的网格大小和 ODE 位置集合，构建单体系统的无向稀疏图。图中包括以下边：\n   - 由五点差分格式在网格内部和适当的边界邻近节点上所隐含的所有最近邻 PDE 耦合。\n   - 对于每个 ODE 位置 $k$，其 $s$ 个 ODE 状态之间的所有内部边（全连接），以及从位置 $k$ 的每个 ODE 状态到其宿主 PDE 节点 $(i_k,j_k)$ 的边。\n2. 实现单体未知数的三种排序：\n   - 自然字典序：所有 PDE 节点 $u(i,j)$ 首先按以 $i$ 为外层索引的行主序排列，然后是所有 ODE 未知数，按位置分组，再在每个位置内按状态分组。\n   - 带宽感知交错排序：对于每个承载 ODE 位置的 PDE 节点，将该位置的 $s$ 个 ODE 状态紧随该宿主 PDE 节点之后排列；否则，只列出该 PDE 节点。对于没有 ODE 位置的 PDE 节点，在 PDE 块内保留其字典序位置。\n   - Reverse Cuthill–McKee 排序：使用应用于完整单体无向稀疏图的标准图算法计算。\n3. 对每种排序计算对称带宽 $b(A)$。\n\n测试套件：\n实现你的程序以运行以下五个测试用例。每个测试用例指定 $(N_x,N_y)$、ODE 位置坐标集以及每个位置的 ODE 状态数 $s$。\n- 用例 1：$N_x=4$，$N_y=4$，位置 $=\\{(0,0),(1,2)\\}$，$s=2$。\n- 用例 2：$N_x=8$，$N_y=8$，位置 $=\\{(0,0),(0,7),(7,0),(7,7),(3,4)\\}$，$s=3$。\n- 用例 3：$N_x=5$，$N_y=9$，位置 $=\\{(2,1),(2,4),(2,7)\\}$，$s=2$。\n- 用例 4：$N_x=6$，$N_y=6$，位置 $=\\varnothing$，$s=1$。\n- 用例 5：$N_x=10$，$N_y=3$，位置 $=\\{(1,1),(3,1),(5,1),(7,1),(9,1)\\}$，$s=4$。\n\n输出要求：\n- 对于每个测试用例，返回一个整数三元组 $\\left[b_{\\text{nat}}, b_{\\text{int}}, b_{\\text{rcm}}\\right]$，其中 $b_{\\text{nat}}$ 是自然排序下的带宽，$b_{\\text{int}}$ 是交错排序下的带宽，$b_{\\text{rcm}}$ 是 Reverse Cuthill–McKee 排序下的带宽。\n- 你的程序应生成单行输出，其中包含这些三元组的结果，形式为逗号分隔的列表，每个三元组都写成一个用方括号括起来的逗号分隔的整数列表。最后一行必须具有以下形式\n$$\n\\big[\\,[b_{\\text{nat}}^{(1)},b_{\\text{int}}^{(1)},b_{\\text{rcm}}^{(1)}],\\,[b_{\\text{nat}}^{(2)},b_{\\text{int}}^{(2)},b_{\\text{rcm}}^{(2)}],\\,\\dots\\big],\n$$\n按顺序表示 5 个用例。例如，包含两个用例的输出看起来像 `[[1,2,3],[4,5,6]]`，但你必须按上述规定输出所有五个用例。\n\n注意：\n- 本任务不涉及角度和物理单位。\n- 所有索引都是从 0 开始的。确保所有位置都是唯一的，并且位于有效的网格节点上。\n- Reverse Cuthill–McKee 排序必须在完整的单体稀疏图上计算，而不仅仅是在 PDE 子图上。",
            "solution": "用户提供的问题具有科学依据、适定且客观。它描述了偏微分方程 (PDE) 数值解中的一个常见任务，即为高效求解而优化稀疏线性系统的结构。问题陈述完整、一致且可形式化。所有术语定义明确，测试用例无歧义。因此，该问题是有效的，并将提供一个解决方案。\n\n该问题要求在三种不同的未知变量排序下，比较由耦合 PDE-ODE 系统产生的稀疏矩阵的对称带宽。解决方案包括三个主要步骤：1) 构建系统稀疏模式的图表示，2) 实现指定的排序，以及 3) 为每种排序计算对称带宽。\n\n### 1. 系统的图表示\n\n包含离散化 PDE 状态和 ODE 状态的单体方程组，可以用一个无向图 $G=(V, E)$ 来表示，其中 $V$ 是所有未知变量（节点）的集合，$E$ 是耦合（边）的集合。该系统雅可比矩阵的稀疏模式就是这个图的邻接矩阵。\n\n设 PDE 在大小为 $N_x \\times N_y$ 的网格上离散化。PDE 节点的总数为 $N_{\\mathrm{pde}} = N_x N_y$。设有 $M$ 个点动力学位置，每个位置有 $s$ 个 ODE 状态。ODE 节点的总数为 $N_{\\mathrm{ode}} = M \\cdot s$。图中节点的总数为 $N = N_{\\mathrm{pde}} + N_{\\mathrm{ode}}$。\n\n我们首先为 $V$ 中的节点建立一个*自然*索引：\n-   对于 $i \\in \\{0, \\dots, N_x-1\\}$ 和 $j \\in \\{0, \\dots, N_y-1\\}$ 的一个 PDE 状态 $u(i,j)$，为其分配一个唯一索引 $p(i,j) = i \\cdot N_y + j$。这些索引的范围从 $0$ 到 $N_{\\mathrm{pde}}-1$。\n-   ODE 位置从 $k=0$ 到 $M-1$ 进行索引。位置 $k$ 的 $s$ 个状态被分配的索引范围从 $N_{\\mathrm{pde}} + k \\cdot s$ 到 $N_{\\mathrm{pde}} + (k+1) \\cdot s - 1$。\n\n边的集合 $E$ 是根据耦合关系构建的：\n1.  **PDE-PDE 耦合**：五点有限差分格式意味着每个内部 PDE 节点 $u(i,j)$ 都与其邻居 $u(i\\pm1, j)$ 和 $u(i, j\\pm1)$ 耦合。这对应于图中所有有效邻居索引的边 $(p(i,j), p(i\\pm1,j))$ 和 $(p(i,j), p(i,j\\pm1))$。\n2.  **PDE-ODE 耦合**：对于位于网格节点 $(i_k, j_k)$ 的每个位置 $k$，其 $s$ 个 ODE 状态中的每一个都与宿主 PDE 节点 $u(i_k, j_k)$ 耦合。这会在节点 $p(i_k, j_k)$ 与和位置 $k$ 相关联的 $s$ 个 ODE 节点之间创建 $s$ 条边。\n3.  **ODE-ODE 耦合**：在每个位置 $k$ 内部，所有 $s$ 个 ODE 状态相互耦合，形成一个团（clique）。这为每个位置增加了 $\\binom{s}{2}$ 条边。\n\n### 2. 节点排序方案\n\n排序是节点索引的一个置换 $\\pi$，它将每个节点从其在 $V$ 中的初始索引映射到一个从 0 到 $N-1$ 的新位置。我们实现了三种这样的排序。\n\n1.  **自然字典序**：此排序对应于上面定义的初始索引方案。所有 $N_{\\mathrm{pde}}$ 个 PDE 节点首先排序，然后是所有 $N_{\\mathrm{ode}}$ 个 ODE 节点。该置换是单位置换，$\\pi_{\\mathrm{nat}}(k) = k$。\n2.  **带宽感知交错排序**：此策略旨在通过将因变量在排序中彼此靠近放置来减小带宽。我们按自然字典序遍历 PDE 节点 $u(i,j)$。对于每个 $u(i,j)$，我们将其添加到新排序中。如果 $u(i,j)$ 是一个 ODE 位置的宿主，我们立即将该位置的所有 $s$ 个 ODE 状态附加到排序中，然后再移动到下一个 PDE 节点 $u(i,j+1)$ 或 $u(i+1,0)$。这将 ODE 自由度交错插入到 PDE 自由度序列中。\n3.  **Reverse Cuthill–McKee (RCM) 排序**：RCM 是一种标准的、广泛使用的启发式算法，用于减小稀疏矩阵的带宽和剖面。它是一种基于水平集的算法，作用于图 $G$。我们应用在 `scipy.sparse.csgraph.reverse_cuthill_mckee` 中实现的 RCM 算法于完整的单体图 $G$，以获得置换 $\\pi_{\\mathrm{rcm}}$。\n\n### 3. 带宽计算\n\n稀疏矩阵 $A$ 的对称带宽 $b(A)$ 定义为 $b(A) = \\max\\{\\, |p-q| \\,:\\, A_{pq} \\neq 0 \\,\\}$。对于给定的排序 $\\pi$，这等同于找到图中任意两个相连节点在新位置上的最大差值：\n$$b(G, \\pi) = \\max_{(u,v) \\in E} |\\pi(u) - \\pi(v)|$$\n为计算此值，我们首先构建逆置换 $\\pi^{-1}$，其中 $\\pi^{-1}(k)$ 给出原始节点 $k$ 的新位置。然后，对于每条边 $(u,v) \\in E$，我们计算距离 $|\\pi^{-1}(u) - \\pi^{-1}(v)|$ 并找出所有边中的最大值。\n\n### 4. 实现\n\n对每个测试用例，实现过程如下：\n1.  对位置集合进行排序以确保确定性的排序。计算节点总数 $N = N_x N_y + M s$。\n2.  构建一个邻接表来表示图 $G$，节点根据自然排序进行索引。\n3.  使用单位置换计算带宽 $b_{\\mathrm{nat}}$。\n4.  为交错排序构建一个新的置换向量。计算其逆，并用它来计算 $b_{\\mathrm{int}}$。\n5.  将邻接表转换为一个 `scipy.sparse.csc_matrix`。对此矩阵调用 `reverse_cuthill_mckee` 函数以获得 RCM 置换。然后计算相应的带宽 $b_{\\mathrm{rcm}}$。\n6.  对于每个用例，将得到的整数三元组 $[b_{\\text{nat}}, b_{\\text{int}}, b_{\\text{rcm}}]$ 存储起来。最后，将所有结果格式化为所需的输出字符串。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import csc_matrix, csgraph\n\ndef compute_bandwidth(adj, inv_perm):\n    \"\"\"\n    Computes the symmetric bandwidth of a graph given an ordering.\n    \n    Args:\n        adj (list of lists): Adjacency list of the graph.\n        inv_perm (np.array): An array where inv_perm[i] is the new position\n                             of the original node i.\n                             \n    Returns:\n        int: The symmetric bandwidth.\n    \"\"\"\n    if inv_perm.size == 0:\n        return 0\n    max_diff = 0\n    for u, neighbors in enumerate(adj):\n        # Process each edge (u, v) with u  v to avoid redundant checks.\n        for v in neighbors:\n            if u  v:\n                diff = abs(inv_perm[u] - inv_perm[v])\n                if diff  max_diff:\n                    max_diff = diff\n    return int(max_diff)\n\ndef process_case(Nx, Ny, sites, s):\n    \"\"\"\n    Builds the graph, creates the orderings, and computes the bandwidths\n    for a single test case.\n    \"\"\"\n    # To ensure deterministic behavior, sort the set of sites.\n    # The order of sites affects the 'natural' ordering.\n    sorted_sites = sorted(list(sites))\n\n    # Setup node counts and mappings for the 'natural' or 'original' indexing\n    Npde = Nx * Ny\n    M = len(sorted_sites)\n    N_total = Npde + M * s\n\n    site_map_coord_to_k = {coord: k for k, coord in enumerate(sorted_sites)}\n\n    def pde_coord_to_id(i, j): return i * Ny + j\n    def ode_site_k_to_ids(k): return range(Npde + k * s, Npde + (k + 1) * s)\n\n    # 1. Build the undirected sparsity graph (as an adjacency list)\n    adj = [[] for _ in range(N_total)]\n\n    # PDE-PDE couplings (5-point stencil)\n    for i in range(Nx):\n        for j in range(Ny):\n            p_id = pde_coord_to_id(i, j)\n            # Horizontal neighbor\n            if j + 1  Ny:\n                neighbor_id = pde_coord_to_id(i, j + 1)\n                adj[p_id].append(neighbor_id)\n                adj[neighbor_id].append(p_id)\n            # Vertical neighbor\n            if i + 1  Nx:\n                neighbor_id = pde_coord_to_id(i + 1, j)\n                adj[p_id].append(neighbor_id)\n                adj[neighbor_id].append(p_id)\n\n    # PDE-ODE and ODE-ODE couplings\n    for k, (ik, jk) in enumerate(sorted_sites):\n        pde_host_id = pde_coord_to_id(ik, jk)\n        ode_ids = list(ode_site_k_to_ids(k))\n        \n        for ode_id in ode_ids:\n            adj[pde_host_id].append(ode_id)\n            adj[ode_id].append(pde_host_id)\n            \n        for idx1 in range(len(ode_ids)):\n            for idx2 in range(idx1 + 1, len(ode_ids)):\n                u, v = ode_ids[idx1], ode_ids[idx2]\n                adj[u].append(v)\n                adj[v].append(u)\n\n    # 2. Implement orderings and compute bandwidths\n\n    # Natural Lexicographic Ordering\n    # The inverse permutation is the identity.\n    nat_perm_inv = np.arange(N_total)\n    b_nat = compute_bandwidth(adj, nat_perm_inv)\n\n    # Bandwidth-Aware Interleaved Ordering\n    int_perm_list = []\n    for i in range(Nx):\n        for j in range(Ny):\n            pde_id = pde_coord_to_id(i, j)\n            int_perm_list.append(pde_id)\n            if (i, j) in site_map_coord_to_k:\n                k = site_map_coord_to_k[(i, j)]\n                int_perm_list.extend(ode_site_k_to_ids(k))\n    \n    int_perm = np.array(int_perm_list)\n    int_perm_inv = np.argsort(int_perm) if N_total  0 else np.array([])\n    b_int = compute_bandwidth(adj, int_perm_inv)\n\n    # Reverse Cuthill–McKee (RCM) Ordering\n    b_rcm = 0\n    if N_total  0:\n        rows, cols = [], []\n        for u, neighbors in enumerate(adj):\n            for v in neighbors:\n                rows.append(u)\n                cols.append(v)\n        graph_matrix = csc_matrix((np.ones_like(rows), (rows, cols)), shape=(N_total, N_total))\n        \n        rcm_perm = csgraph.reverse_cuthill_mckee(graph_matrix, symmetric_mode=False)\n        rcm_perm_inv = np.argsort(rcm_perm)\n        b_rcm = compute_bandwidth(adj, rcm_perm_inv)\n\n    return [b_nat, b_int, b_rcm]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        (4, 4, {(0, 0), (1, 2)}, 2),\n        (8, 8, {(0, 0), (0, 7), (7, 0), (7, 7), (3, 4)}, 3),\n        (5, 9, {(2, 1), (2, 4), (2, 7)}, 2),\n        (6, 6, set(), 1),\n        (10, 3, {(1, 1), (3, 1), (5, 1), (7, 1), (9, 1)}, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, sites, s = case\n        results.append(process_case(Nx, Ny, sites, s))\n\n    # Format the output string as specified: [[a,b,c],[d,e,f],...]\n    formatted_results = []\n    for res_triple in results:\n        formatted_results.append(f\"[{res_triple[0]},{res_triple[1]},{res_triple[2]}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}