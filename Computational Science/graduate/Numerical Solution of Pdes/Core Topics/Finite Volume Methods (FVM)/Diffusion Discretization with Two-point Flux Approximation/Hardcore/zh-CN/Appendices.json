{
    "hands_on_practices": [
        {
            "introduction": "要掌握两点通量近似（TPFA）方法，我们必须从基本物理定律出发，推导其核心要素——传输率（transmissibility）。本练习将引导您完成这一基本推导，将两个相邻控制体之间的传输率 $T_{ij}$ 视为由一系列热阻产生的等效电导。通过进一步分析此传输率对几何参数的敏感性，您不仅能巩固对基本公式的理解，还能练习数值验证解析结果这一关键的计算科学技能。",
            "id": "3377678",
            "problem": "考虑一个非均匀介质中的稳态扩散方程，其导热系数为各向同性、分段常数，表示为 $\\nabla \\cdot (k \\nabla u) = 0$，其中 $u$ 是标量势（例如，温度，单位为开尔文（K）），$k$ 是导热系数（例如，热导率，单位为瓦每米开尔文（$\\text{W}/(\\text{m}\\cdot \\text{K})$））。两个相邻的凸控制体积（单元），索引为 $i$ 和 $j$，共享一个面积为 $|F|$（单位为平方米, $\\text{m}^2$）的平坦界面（面）。设 $d_i$ 和 $d_j$ 分别是单元 $i$ 和 $j$ 的中心沿界面法线方向到共享界面的垂直距离（单位为米, $\\text{m}$）。假设两点通量近似（two-point flux approximation）适用：势 $u$ 沿连接两单元中心的直线线性变化，并且穿过界面的通量可以用一个连接两个单元中心未知数的标量传递系数来表示。\n\n从基本守恒定律和 Fick/Fourier 型本构关系 $q = -k \\nabla u$ 出发，在上述假设下推导单元 $i$ 和 $j$ 之间穿过界面 $F$ 的传递系数。将穿过 $F$ 的通量 $q_F$ 表示为 $q_F = -T_{ij}(u_j - u_i)$，并获得 $T_{ij}$ 关于 $|F|$、$d_i$、$d_j$、$k_i$ 和 $k_j$ 的封闭形式表达式，其中 $k_i$ 和 $k_j$ 分别是单元 $i$ 和 $j$ 中的常数各向同性导热系数。使用控制方程和界面条件清晰地论证每一步，不要使用任何预设最终结果的快捷公式。\n\n接下来，分析传递系数对 $d_i$ 和 $d_j$ 扰动的敏感性。定义偏导数 $\\frac{\\partial T_{ij}}{\\partial d_i}$ 和 $\\frac{\\partial T_{ij}}{\\partial d_j}$，以及无量纲相对敏感性\n$$\nS_{d_i} = \\frac{d_i}{T_{ij}} \\frac{\\partial T_{ij}}{\\partial d_i}, \\quad S_{d_j} = \\frac{d_j}{T_{ij}} \\frac{\\partial T_{ij}}{\\partial d_j}.\n$$\n通过将解析敏感性与根据 $d_i$ 和 $d_j$ 的微小相对扰动计算出的中心差分有限差分近似值进行比较，来验证它们。\n\n使用以下参数集测试套件来评估 $T_{ij}$、$S_{d_i}$、$S_{d_j}$、解析导数和数值导数之间的相对误差，以及在容差范围内的布尔一致性指标。在所有情况下，将 $k$ 的单位解释为瓦每米开尔文（$\\text{W}/(\\text{m}\\cdot \\text{K})$），$|F|$ 的单位为平方米（$\\text{m}^2$），$d_i$ 和 $d_j$ 的单位为米（$\\text{m}$），并以瓦每开尔文（$\\text{W}/\\text{K}$）为单位报告 $T_{ij}$。导数比较的容差应设置为 $10^{-9}$ 的相对误差。对每个导数使用等于标称距离 $10^{-8}$ 倍的中心差分步长。\n\n测试套件：\n- 案例 A（一般非对称）：$|F| = 1.2$，$d_i = 0.5$，$d_j = 0.4$，$k_i = 2.0$，$k_j = 4.0$。\n- 案例 B（对称距离和导热系数）：$|F| = 2.0$，$d_i = 0.5$，$d_j = 0.5$，$k_i = 1.0$，$k_j = 1.0$。\n- 案例 C（高对比度导热系数）：$|F| = 1.0$，$d_i = 0.1$，$d_j = 0.1$，$k_i = 10.0$，$k_j = 0.1$。\n- 案例 D（薄厚单元对，相等导热系数）：$|F| = 0.5$，$d_i = 10^{-3}$，$d_j = 1.0$，$k_i = 5.0$，$k_j = 5.0$。\n\n您的程序必须：\n1.  为每个案例计算 $T_{ij}$、$S_{d_i}$、$S_{d_j}$。\n2.  使用指定扰动大小的中心差分法近似计算 $\\frac{\\partial T_{ij}}{\\partial d_i}$ 和 $\\frac{\\partial T_{ij}}{\\partial d_j}$。\n3.  报告数值导数相对于解析导数的相对误差。\n4.  返回布尔标志，指示每个相对误差是否小于或等于 $10^{-9}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。列表中的每个条目对应一个测试案例，并且本身必须是以下格式的列表\n$[T_{ij}, S_{d_i}, S_{d_j}, \\text{err}_{d_i}, \\text{err}_{d_j}, \\text{ok}_{d_i}, \\text{ok}_{d_j}]$，\n其中 $T_{ij}$ 的单位是瓦每开尔文（$\\text{W}/\\text{K}$），$S_{d_i}$ 和 $S_{d_j}$ 是无量纲的，$\\text{err}_{d_i}$ 和 $\\text{err}_{d_j}$ 是无量纲的相对误差，布尔值表示是否在容差范围内一致。例如：$[[\\dots],[\\dots],[\\dots],[\\dots]]$。",
            "solution": "该问题定义明确，有科学依据，并提供了获得唯一解所需的所有信息。这是偏微分方程数值分析中的一个标准练习，特别是在有限体积法的框架内。\n\n主要目标是推导稳态扩散过程中两个相邻控制体积 $i$ 和 $j$ 之间的传递系数 $T_{ij}$，并随后分析其对几何参数 $d_i$ 和 $d_j$ 的敏感性。\n\n**传递系数 $T_{ij}$ 的推导**\n\n控制方程是稳态扩散方程：\n$$\n\\nabla \\cdot (k \\nabla u) = 0\n$$\n其中 $u$ 是标量势，$k$ 是导热系数。本构关系是 Fick 定律或 Fourier 定律，它指出通量矢量 $\\vec{q}$ 与势的负梯度成正比：\n$$\n\\vec{q} = -k \\nabla u\n$$\n我们考虑两个单元，$i$ 和 $j$，其常数各向同性导热系数分别为 $k_i$ 和 $k_j$。它们共享一个面积为 $|F|$ 的平面 $F$。单元中心距离该界面的垂直距离分别为 $d_i$ 和 $d_j$。\n\n该问题做了一个关键的简化假设，称为两点通量近似（TPFA）：势 $u$ 沿连接两个单元中心的直线线性变化。该假设将问题简化为沿界面 $F$ 法线方向的一维分析。设沿此法线的坐标为 $x$，界面 $F$ 位于 $x=0$ 处。单元 $i$ 的中心位于 $x=-d_i$，单元 $j$ 的中心位于 $x=d_j$。这些中心的势表示为 $u_i = u(-d_i)$ 和 $u_j = u(d_j)$。\n\n在这种一维稳态设置中，控制方程 $\\nabla \\cdot \\vec{q} = 0$ 简化为 $\\frac{d q_x}{dx} = 0$，其中 $q_x$ 是垂直于界面的通量分量。这意味着 $q_x$ 在从 $-d_i$ 到 $d_j$ 的线段上是恒定的。设这个恒定的通量密度为 $f$。\n$$\nf = q_x = -k(x) \\frac{du}{dx} = \\text{constant}\n$$\n我们可以对这两个对应于单元 $i$ 和单元 $j$ 的线段积分此关系。\n\n1.  **第1段（在单元 $i$ 内）：从 $x=-d_i$ 到 $x=0$**\n    导热系数为 $k(x) = k_i$。\n    $$\n    f = -k_i \\frac{du}{dx}\n    $$\n    从单元中心 $i$ 积分到界面 $F$：\n    $$\n    \\int_{-d_i}^{0} f \\,dx = \\int_{-d_i}^{0} -k_i \\frac{du}{dx} \\,dx\n    $$\n    $$\n    f \\cdot (0 - (-d_i)) = -k_i (u(0) - u(-d_i))\n    $$\n    设 $u_F = u(0)$ 为界面上的势。那么：\n    $$\n    f d_i = -k_i (u_F - u_i) \\implies u_i - u_F = \\frac{f d_i}{k_i}\n    $$\n\n2.  **第2段（在单元 $j$ 内）：从 $x=0$ 到 $x=d_j$**\n    导热系数为 $k(x) = k_j$。\n    $$\n    f = -k_j \\frac{du}{dx}\n    $$\n    从界面 $F$ 积分到单元中心 $j$：\n    $$\n    \\int_{0}^{d_j} f \\,dx = \\int_{0}^{d_j} -k_j \\frac{du}{dx} \\,dx\n    $$\n    $$\n    f \\cdot (d_j - 0) = -k_j (u(d_j) - u(0))\n    $$\n    $$\n    f d_j = -k_j (u_j - u_F) \\implies u_F - u_j = \\frac{f d_j}{k_j}\n    $$\n\n3.  **消除界面势 $u_F$**\n    我们得到一个关于势差的两个线性方程组：\n    (1) $u_i - u_F = \\frac{f d_i}{k_i}$\n    (2) $u_F - u_j = \\frac{f d_j}{k_j}$\n    将这两个方程相加可以消除未知的界面势 $u_F$：\n    $$\n    (u_i - u_F) + (u_F - u_j) = \\frac{f d_i}{k_i} + \\frac{f d_j}{k_j}\n    $$\n    $$\n    u_i - u_j = f \\left( \\frac{d_i}{k_i} + \\frac{d_j}{k_j} \\right)\n    $$\n    重新整理以求解通量密度 $f$：\n    $$\n    f = \\frac{u_i - u_j}{\\frac{d_i}{k_i} + \\frac{d_j}{k_j}} = - \\frac{u_j - u_i}{\\frac{d_i}{k_i} + \\frac{d_j}{k_j}}\n    $$\n\n4.  **确定传递系数 $T_{ij}$**\n    通过界面 $F$ 的总通量 $q_F$ 是通量密度 $f$ 乘以面积 $|F|$。通量从高势流向低势。问题定义 $q_F$ 的方向，使得如果 $u_i > u_j$，从单元 $i$ 流向单元 $j$ 的通量为正。\n    $$\n    q_F = f \\cdot |F| = -\\left( \\frac{|F|}{\\frac{d_i}{k_i} + \\frac{d_j}{k_j}} \\right) (u_j - u_i)\n    $$\n    将其与给定定义 $q_F = -T_{ij}(u_j - u_i)$ 进行比较，我们确定传递系数 $T_{ij}$ 为：\n    $$\n    T_{ij} = \\frac{|F|}{\\frac{d_i}{k_i} + \\frac{d_j}{k_j}}\n    $$\n    这个表达式代表了两个单元中心之间的传导率，它是总热阻的倒数。项 $d_i/k_i$ 和 $d_j/k_j$ 类似于串联的电阻。另一种形式是：\n    $$\n    T_{ij} = \\frac{|F| k_i k_j}{d_i k_j + d_j k_i}\n    $$\n\n**敏感性分析**\n\n我们现在推导 $T_{ij}$ 对 $d_i$ 和 $d_j$ 的偏导数以及相应的无量纲相对敏感性。\n\n1.  **关于 $d_i$ 的偏导数**\n    使用形式 $T_{ij} = |F| k_i k_j (d_i k_j + d_j k_i)^{-1}$ 并应用链式法则：\n    $$\n    \\frac{\\partial T_{ij}}{\\partial d_i} = |F| k_i k_j \\cdot (-1) (d_i k_j + d_j k_i)^{-2} \\cdot \\frac{\\partial}{\\partial d_i}(d_i k_j + d_j k_i)\n    $$\n    $$\n    \\frac{\\partial T_{ij}}{\\partial d_i} = -|F| k_i k_j (d_i k_j + d_j k_i)^{-2} \\cdot (k_j)\n    $$\n    $$\n    \\frac{\\partial T_{ij}}{\\partial d_i} = - \\frac{|F| k_i k_j^2}{(d_i k_j + d_j k_i)^2}\n    $$\n\n2.  **无量纲敏感性 $S_{d_i}$**\n    相对敏感性 $S_{d_i}$ 定义为 $S_{d_i} = \\frac{d_i}{T_{ij}} \\frac{\\partial T_{ij}}{\\partial d_i}$。\n    $$\n    S_{d_i} = \\frac{d_i}{\\frac{|F| k_i k_j}{d_i k_j + d_j k_i}} \\left( - \\frac{|F| k_i k_j^2}{(d_i k_j + d_j k_i)^2} \\right)\n    $$\n    $$\n    S_{d_i} = d_i \\frac{d_i k_j + d_j k_i}{|F| k_i k_j} \\left( - \\frac{|F| k_i k_j^2}{(d_i k_j + d_j k_i)^2} \\right)\n    $$\n    消去各项后，我们得到：\n    $$\n    S_{d_i} = - \\frac{d_i k_j}{d_i k_j + d_j k_i}\n    $$\n\n3.  **关于 $d_j$ 的偏导数**\n    $T_{ij}$ 的表达式关于交换对 $(d_i, k_i)$ 和 $(d_j, k_j)$ 是对称的。因此，我们可以通过在关于 $\\frac{\\partial T_{ij}}{\\partial d_i}$ 的表达式中执行此交换来获得关于 $d_j$ 的导数：\n    $$\n    \\frac{\\partial T_{ij}}{\\partial d_j} = - \\frac{|F| k_j k_i^2}{(d_j k_i + d_i k_j)^2} = - \\frac{|F| k_i^2 k_j}{(d_i k_j + d_j k_i)^2}\n    $$\n\n4.  **无量纲敏感性 $S_{d_j}$**\n    类似地，应用定义 $S_{d_j} = \\frac{d_j}{T_{ij}} \\frac{\\partial T_{ij}}{\\partial d_j}$：\n    $$\n    S_{d_j} = - \\frac{d_j k_i}{d_i k_j + d_j k_i}\n    $$\n    注意 $S_{d_i} + S_{d_j} = - \\frac{d_i k_j + d_j k_i}{d_i k_j + d_j k_i} = -1$。这与 Euler 齐次函数定理一致，因为 $T_{ij}$ 是一个关于距离 $d_i$ 和 $d_j$ 的 -1 次齐次函数。\n\n**数值验证程序**\n\n为了验证解析导数，我们使用二阶中心差分公式。对于函数 $f(x)$，其导数 $f'(x)$ 的近似值为：\n$$\nf'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}\n$$\n步长 $h$ 被选为变量值的一个很小的分数。问题指定了 $10^{-8}$ 的相对步长。\n对于 $\\frac{\\partial T_{ij}}{\\partial d_i}$，其数值近似 $(\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{num}}$ 为：\n$$\n(\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{num}} = \\frac{T_{ij}(d_i + h_i, d_j) - T_{ij}(d_i - h_i, d_j)}{2h_i}, \\quad \\text{其中 } h_i = 10^{-8} d_i\n$$\n对关于 $d_j$ 的导数也使用类似的公式。然后，相对误差 $\\text{err}_{d_i}$ 计算为：\n$$\n\\text{err}_{d_i} = \\left| \\frac{(\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{num}} - (\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{ana}}}{(\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{ana}}} \\right|\n$$\n其中下标 'ana' 表示上面推导的解析导数。然后将这些结果与指定的 $10^{-9}$ 容差进行比较。\n\n一个程序将实现这些公式来处理给定的测试套件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes transmissibility, sensitivities, and validates derivatives for \n    a set of test cases according to the problem description.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    # Format: (|F|, d_i, d_j, k_i, k_j)\n    # Units:\n    # |F|: m^2\n    # d_i, d_j: m\n    # k_i, k_j: W/(m.K)\n    test_cases = [\n        # Case A (general asymmetric)\n        (1.2, 0.5, 0.4, 2.0, 4.0),\n        # Case B (symmetric distances and conductivities)\n        (2.0, 0.5, 0.5, 1.0, 1.0),\n        # Case C (high contrast conductivities)\n        (1.0, 0.1, 0.1, 10.0, 0.1),\n        # Case D (thin-thick pair, equal conductivities)\n        (0.5, 1e-3, 1.0, 5.0, 5.0),\n    ]\n\n    # Constants for numerical validation\n    DERIV_TOLERANCE = 1e-9\n    CENTRAL_DIFF_REL_STEP = 1e-8\n\n    def compute_t_ij(face_area, d_i, d_j, k_i, k_j):\n        \"\"\"Computes the transmissibility T_ij in W/K.\"\"\"\n        # T_ij = |F| / (d_i/k_i + d_j/k_j)\n        denominator = d_i / k_i + d_j / k_j\n        if denominator == 0:\n            return float('inf')\n        return face_area / denominator\n\n    def compute_dt_di_analytical(face_area, d_i, d_j, k_i, k_j):\n        \"\"\"Computes the analytical partial derivative of T_ij w.r.t. d_i.\"\"\"\n        # d(T_ij)/d(d_i) = -|F| * k_i * k_j^2 / (d_i*k_j + d_j*k_i)^2\n        denominator = d_i * k_j + d_j * k_i\n        if denominator == 0:\n            return float('-inf')\n        return -face_area * k_i * k_j**2 / denominator**2\n\n    def compute_dt_dj_analytical(face_area, d_i, d_j, k_i, k_j):\n        \"\"\"Computes the analytical partial derivative of T_ij w.r.t. d_j.\"\"\"\n        # d(T_ij)/d(d_j) = -|F| * k_j * k_i^2 / (d_i*k_j + d_j*k_i)^2\n        denominator = d_i * k_j + d_j * k_i\n        if denominator == 0:\n            return float('-inf')\n        return -face_area * k_j * k_i**2 / denominator**2\n    \n    def compute_s_di(d_i, d_j, k_i, k_j):\n        \"\"\"Computes the dimensionless relative sensitivity S_di.\"\"\"\n        # S_di = -d_i*k_j / (d_i*k_j + d_j*k_i)\n        denominator = d_i * k_j + d_j * k_i\n        if denominator == 0:\n            # This case implies T is infinite or undefined, sensitivity may also be.\n            return float('nan')\n        return -d_i * k_j / denominator\n\n    def compute_s_dj(d_i, d_j, k_i, k_j):\n        \"\"\"Computes the dimensionless relative sensitivity S_dj.\"\"\"\n        # S_dj = -d_j*k_i / (d_i*k_j + d_j*k_i)\n        denominator = d_i * k_j + d_j * k_i\n        if denominator == 0:\n            return float('nan')\n        return -d_j * k_i / denominator\n\n    results = []\n    for case in test_cases:\n        F_area, di, dj, ki, kj = case\n        \n        # 1. Compute T_ij, S_di, S_dj\n        t_ij = compute_t_ij(F_area, di, dj, ki, kj)\n        s_di = compute_s_di(di, dj, ki, kj)\n        s_dj = compute_s_dj(di, dj, ki, kj)\n        \n        # 2. Approximate derivatives using central differences\n        # For d_i\n        h_i = CENTRAL_DIFF_REL_STEP * di\n        t_plus_i = compute_t_ij(F_area, di + h_i, dj, ki, kj)\n        t_minus_i = compute_t_ij(F_area, di - h_i, dj, ki, kj)\n        dt_di_num = (t_plus_i - t_minus_i) / (2 * h_i)\n\n        # For d_j\n        h_j = CENTRAL_DIFF_REL_STEP * dj\n        t_plus_j = compute_t_ij(F_area, di, dj + h_j, ki, kj)\n        t_minus_j = compute_t_ij(F_area, di, dj - h_j, ki, kj)\n        dt_dj_num = (t_plus_j - t_minus_j) / (2 * h_j)\n\n        # 3. Report relative error of numerical derivatives\n        dt_di_ana = compute_dt_di_analytical(F_area, di, dj, ki, kj)\n        dt_dj_ana = compute_dt_dj_analytical(F_area, di, dj, ki, kj)\n\n        # Relative error for d_i derivative\n        if dt_di_ana != 0:\n            err_di = abs((dt_di_num - dt_di_ana) / dt_di_ana)\n        elif dt_di_num == 0: # 0/0 case\n            err_di = 0.0\n        else: # inf error if analytical is 0 but numerical is not\n            err_di = float('inf')\n\n        # Relative error for d_j derivative\n        if dt_dj_ana != 0:\n            err_dj = abs((dt_dj_num - dt_dj_ana) / dt_dj_ana)\n        elif dt_dj_num == 0:\n            err_dj = 0.0\n        else:\n            err_dj = float('inf')\n\n        # 4. Return boolean flags indicating agreement within tolerance\n        ok_di = err_di = DERIV_TOLERANCE\n        ok_dj = err_dj = DERIV_TOLERANCE\n\n        case_results = [\n            t_ij, \n            s_di, \n            s_dj, \n            err_di, \n            err_dj, \n            ok_di, \n            ok_dj\n        ]\n        results.append(case_results)\n\n    # Format the final output as a string representing a list of lists.\n    # The default str() for a list already uses '[]' and ', ' separators.\n    # str(True) is 'True', which is a valid boolean representation in many contexts.\n    # The prompt's example format is `[[...],[...],...]`, which is achieved by this.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "尽管两点通量近似（TPFA）方法简洁而强大，但理解其局限性至关重要，尤其是在网格与扩散张量 $K$ 的主方向不一致时，其精度会下降。本练习将TPFA与一种更稳健的技术——模拟有限差分（MFD）方法，在一个扭曲的网格上进行对比。通过实施这两种方法并将其计算的通量与精确解进行比较，您将直接观察到K-正交性的概念，并理解为何对于一般的各向异性扩散问题，需要更先进的离散格式。",
            "id": "3377674",
            "problem": "考虑二维空间中的稳态扩散方程，\n$$-\\nabla \\cdot (K \\nabla p) = f,$$\n其中，$K \\in \\mathbb{R}^{2 \\times 2}$ 为对称正定扩散张量，$p(x,y)$ 为标量势。物理通量定义为\n$$q = -K \\nabla p.$$\n您需要针对常数 $K$ 和一个构造的线性解，在同一个以单元为中心的网格上，实现并比较两点通量近似 (TPFA) 和模拟有限差分 (MFD) 对内部面法向通量的离散化。您的实现必须仅基于以下基本原理和定义：通量定义 $q = -K \\nabla p$、散度定理、面的几何度量（面长度和单位外法向量），以及根据相邻单元值重构常数梯度以精确表示线性场的概念。\n\n按如下方式构建网格。从单位正方形 $[0,1]^2$ 开始，将其划分为 $N_x \\times N_y$ 个与坐标轴对齐的矩形，顶点坐标为 $(i/N_x, j/N_y)$，其中整数 $i=0,\\dots,N_x$，$j=0,\\dots,N_y$。对所有顶点坐标应用一个给定的固定线性变换 $A \\in \\mathbb{R}^{2 \\times 2}$，以获得物理空间中可能非正交的网格。对于每个单元，将其中心定义为其四个变换后顶点的平均值。对于每个内部面，将其端点定义为相应的变换后顶点，其边向量定义为端点之差，其单位法向量定义为与边向量正交且从“左/下”单元指向“右/上”单元的唯一单位向量，其长度定义为边向量的范数。\n\n设构造解为线性势\n$$p(x,y) = a x + b y,$$\n其梯度为常数 $\\nabla p = (a,b)^\\top$。对于由单元 $i$ 和 $j$ 共享的每个内部面，通过该面的精确法向通量为\n$$F_{\\mathrm{ex}} = -|f|\\, n^\\top K \\nabla p,$$\n其中 $|f|$ 是面长度，$n$ 是从 $i$ 指向 $j$ 的单位法向量。TPFA 格式仅使用两个相邻的单元中心值和面的共法向量来近似法向通量，而 MFD 格式则重构一个对线性场精确的单元梯度，并用它来一致地近似面法向通量。您的程序必须以遵循上述基本定义的方式实现这两种近似，然后将它们与精确的面法向通量进行比较。\n\n您的任务：\n- 对于给定的 $N_x$、$N_y$ 和 $A$，通过在单位正方形分区上应用指定的仿射变换来实现网格生成。\n- 对每个内部面，计算：\n  1. 使用 $q = -K \\nabla p$ 和构造的线性场计算精确法向通量 $F_{\\mathrm{ex}}$。\n  2. 使用仅两个单元中心值、几何共法向量以及沿面法线投影的中心距，计算 TPFA 法向通量 $F_{\\mathrm{TPFA}}$。此计算应根据您在解答中建立的通量定义和跨面守恒定律推导得出。\n  3. 通过在每个单元中，根据其相邻单元中心值进行最小二乘拟合，重构一个对线性多项式精确的常数梯度，然后平均相邻单元的梯度，通过与 $K$ 和面法向量进行缩并形成面法向通量，从而计算 MFD 法向通量 $F_{\\mathrm{MFD}}$。\n- 计算所有内部面上的相对 $L^2$ 通量误差，\n$$E_{\\mathrm{TPFA}} = \\frac{\\left\\|F_{\\mathrm{TPFA}} - F_{\\mathrm{ex}}\\right\\|_2}{\\left\\|F_{\\mathrm{ex}}\\right\\|_2}, \\quad E_{\\mathrm{MFD}} = \\frac{\\left\\|F_{\\mathrm{MFD}} - F_{\\mathrm{ex}}\\right\\|_2}{\\left\\|F_{\\mathrm{ex}}\\right\\|_2}.$$\n- 通过检查差异 $\\left\\|F_{\\mathrm{TPFA}} - F_{\\mathrm{MFD}}\\right\\|_2$ 与 $\\left\\|F_{\\mathrm{ex}}\\right\\|_2$ 相比是否可忽略不计，来确定 TPFA 和 MFD 在给定情况下是否一致。\n\n使用以下参数值测试套件，其中涵盖了一致和不一致的条件。所有角度均以度为单位，无需物理单位。\n\n- 测试用例 1（正交网格，各向同性扩散，一般梯度）：\n  - $N_x = 8$，$N_y = 7$\n  - $A = I$（单位变换）\n  - $K = k I$，其中 $k = 2$\n  - $\\nabla p = (a,b)^\\top$，其中 $a = 1.3$，$b = -0.9$\n\n- 测试用例 2（倾斜网格，旋转的各向异性扩散，一般梯度）：\n  - $N_x = 8$，$N_y = 7$\n  - $A = \\begin{pmatrix}1  s \\\\ 0  1\\end{pmatrix}$，其中 $s = 0.7$\n  - $K = R \\,\\mathrm{diag}(k_x, k_y)\\, R^\\top$，其中 $k_x = 5$，$k_y = 1$，$R$ 是角度为 $\\theta = 30$ 度的旋转矩阵\n  - $\\nabla p = (a,b)^\\top$，其中 $a = 1.3$，$b = -0.9$\n\n- 测试用例 3（正交网格，与网格对齐的各向异性扩散，一般梯度）：\n  - $N_x = 8$，$N_y = 7$\n  - $A = I$\n  - $K = \\mathrm{diag}(k_x, k_y)$，其中 $k_x = 5$，$k_y = 1$\n  - $\\nabla p = (a,b)^\\top$，其中 $a = 1.3$，$b = -0.9$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身就是一个形如 $[E_{\\mathrm{TPFA}}, E_{\\mathrm{MFD}}, \\mathrm{coincide}]$ 的列表。例如：\n$$\\text{[[e1\\_tpfa,e1\\_mfd,true],[e2\\_tpfa,e2\\_mfd,false],[e3\\_tpfa,e3\\_mfd,true]]}$$\n其中，$e\\_*\\_{\\mathrm{tpfa}}$ 和 $e\\_*\\_{\\mathrm{mfd}}$ 是浮点数，$\\mathrm{coincide}$ 是布尔值。",
            "solution": "该问题要求在一个一般四边形网格上，针对二维稳态扩散方程，实现并比较两点通量近似 (TPFA) 和模拟有限差分 (MFD) 格式。我们将验证问题，推导数值通量的公式，然后实现它们以计算给定测试用例所需的误差度量。\n\n控制方程是稳态扩散方程：\n$$-\\nabla \\cdot (\\mathbf{q}) = f \\quad \\text{其中} \\quad \\mathbf{q} = -K \\nabla p$$\n其中 $p$ 是标量势，$K \\in \\mathbb{R}^{2 \\times 2}$ 是对称正定扩散张量，$\\mathbf{q}$ 是物理通量，$f$ 是源项。该问题在域 $\\Omega \\subset \\mathbb{R}^2$ 上分析，使用一个构造的线性势 $p(x,y) = ax+by$，对于此解，由于 $K$ 是常数，源项为 $f=0$。\n\n**1. 网格与几何**\n计算网格是通过对单位正方形 $[0,1]^2$ 上的均匀笛卡尔网格的顶点应用线性变换 $A \\in \\mathbb{R}^{2 \\times 2}$ 来构建的。设参考网格的顶点为 $\\mathbf{v}^{\\text{ref}}_{i,j} = (i/N_x, j/N_y)^\\top$，其中整数 $i \\in \\{0, \\dots, N_x\\}$ 和 $j \\in \\{0, \\dots, N_y\\}$。物理网格的顶点为 $\\mathbf{v}_{i,j} = A \\mathbf{v}^{\\text{ref}}_{i,j}$。\n\n一个单元 $C_{i,j}$ 是由顶点 $\\{\\mathbf{v}_{i,j}, \\mathbf{v}_{i+1,j}, \\mathbf{v}_{i,j+1}, \\mathbf{v}_{i+1,j+1}\\}$ 构成的四边形。其中心，对于以单元为中心的格式，定义为其顶点的重心（平均值）：\n$$\\mathbf{x}_{i,j} = \\frac{1}{4}(\\mathbf{v}_{i,j} + \\mathbf{v}_{i+1,j} + \\mathbf{v}_{i,j+1} + \\mathbf{v}_{i+1,j+1})$$\n\n一个内部面 $e$ 是两个相邻单元（例如 $C_L$ 和 $C_R$）共享的线段。设其端点为 $\\mathbf{v}_1$ 和 $\\mathbf{v}_2$。边向量为 $\\mathbf{e} = \\mathbf{v}_2 - \\mathbf{v}_1$，其长度为 $|e| = \\|\\mathbf{e}\\|_2$。单位法向量 $\\mathbf{n}$ 与 $\\mathbf{e}$ 正交（$ \\mathbf{n} \\cdot \\mathbf{e} = 0 $），并定向为从单元 $C_L$ 指向单元 $C_R$。对于向量 $\\mathbf{e}=(e_x, e_y)^\\top$，一个法向量由 $(-e_y, e_x)^\\top$ 给出。我们选择符号以确保 $\\mathbf{n} \\cdot (\\mathbf{x}_R - \\mathbf{x}_L)  0$。\n\n**2. 构造解与精确通量**\n势场被给定为一个线性函数 $p(x,y) = ax+by$。在向量表示法中，$p(\\mathbf{x}) = \\mathbf{g} \\cdot \\mathbf{x}$，其中 $\\mathbf{g} = (a, b)^\\top$ 是常数梯度，$\\nabla p = \\mathbf{g}$。在单元中心 $\\mathbf{x}_i$ 处的势为 $p_i = p(\\mathbf{x}_i) = \\mathbf{g} \\cdot \\mathbf{x}_i$。\n\n穿过一个面 $e$ 的法向通量是物理通量 $\\mathbf{q} = -K \\nabla p$ 的法向分量的积分：\n$$F_e = \\int_e \\mathbf{q} \\cdot \\mathbf{n} \\,ds$$\n由于我们的构造解中 $\\mathbf{q}$ 是常数，该积分得以简化。精确的法向通量为：\n$$F^{\\text{ex}}_e = (\\mathbf{q} \\cdot \\mathbf{n}) \\int_e ds = (-K \\mathbf{g} \\cdot \\mathbf{n}) |e| = -|e| \\mathbf{n}^\\top K \\mathbf{g}$$\n\n**3. 两点通量近似 (TPFA)**\nTPFA 格式仅使用两个单元 $C_L$ 和 $C_R$ 的单元中心势 $p_L$ 和 $p_R$ 来近似它们之间的通量。其推导基于沿面法线方向流动的一维假设。通过在面中心强制通量连续性并使用有限差分近似梯度，可以得到通量的表达式。得到的通量近似为：\n$$F^{\\text{TPFA}}_e = -T_e (p_R - p_L)$$\n其中 $T_e$ 是面的传导率。对于一般的张量 $K$，传导率是在势沿法线方向线性变化的假设下推导出来的，这得到：\n$$T_e = |e| \\frac{\\mathbf{n}^\\top K \\mathbf{n}}{(\\mathbf{x}_R - \\mathbf{x}_L) \\cdot \\mathbf{n}}$$\n势差为 $p_R - p_L = \\mathbf{g} \\cdot (\\mathbf{x}_R - \\mathbf{x}_L)$。将这些代入通量表达式得到：\n$$F^{\\text{TPFA}}_e = -|e| \\frac{\\mathbf{n}^\\top K \\mathbf{n}}{(\\mathbf{x}_R - \\mathbf{x}_L) \\cdot \\mathbf{n}} (\\mathbf{g} \\cdot (\\mathbf{x}_R - \\mathbf{x}_L))$$\n这个近似是精确的，当且仅当网格是 K-正交的，即对于每个面，向量 $K(\\mathbf{x}_R - \\mathbf{x}_L)$ 都平行于面法向量 $\\mathbf{n}$。这个条件对于具有各向同性（$K=kI$）或与坐标轴对齐的各向异性（$K=\\text{diag}(k_x, k_y)$）扩散张量的正交网格是满足的。在倾斜网格或使用旋转的各向异性张量时，TPFA 会引入相容性误差。\n\n**4. 模拟有限差分 (MFD) 通量**\nMFD 方法通过首先在每个单元内重构一个梯度，然后用它来计算通量，从而提供更准确的通量近似。\n\n**4.1. 梯度重构**\n对于每个单元 $C_i$，通过对其面相邻单元的势进行最小二乘拟合，计算一个常数梯度向量 $\\nabla p_i$。设 $N(i)$ 是单元 $C_i$ 的面相邻单元的索引集。我们寻找 $\\mathbf{g}_i \\approx \\nabla p_i$ 来最小化残差平方和：\n$$\\underset{\\mathbf{g}_i \\in \\mathbb{R}^2}{\\text{minimize}} \\sum_{j \\in N(i)} \\left( (p_j - p_i) - \\mathbf{g}_i \\cdot (\\mathbf{x}_j - \\mathbf{x}_i) \\right)^2$$\n这是一个标准的线性最小二乘问题。设 $\\mathbf{d}_{ij} = \\mathbf{x}_j - \\mathbf{x}_i$ 和 $\\Delta p_{ij} = p_j - p_i$。该系统可以写成 $M \\mathbf{g}_i = \\mathbf{b}$，其中 $M$ 的行是 $\\mathbf{d}_{ij}^\\top$，$\\mathbf{b}$ 的项是 $\\Delta p_{ij}$。解由以下公式给出：\n$$\\mathbf{g}_i = (M^\\top M)^{-1} M^\\top \\mathbf{b}$$\n其中 $M^\\top M = \\sum_{j \\in N(i)} \\mathbf{d}_{ij} \\mathbf{d}_{ij}^\\top$，$M^\\top \\mathbf{b} = \\sum_{j \\in N(i)} \\mathbf{d}_{ij} \\Delta p_{ij}$。\n这种重构的一个关键特性是它对于线性势场是精确的。如果 $p(\\mathbf{x}) = \\mathbf{g}_{\\text{true}} \\cdot \\mathbf{x} + c$，那么 $p_j - p_i = \\mathbf{g}_{\\text{true}} \\cdot (\\mathbf{x}_j - \\mathbf{x}_i)$，所以对于 $\\mathbf{g}_i = \\mathbf{g}_{\\text{true}}$，最小二乘问题中的残差为零。因此，对于我们的构造解，每个单元中重构的梯度 $\\mathbf{g}_i$ 将等于真实梯度 $\\mathbf{g}$，直到机器精度。\n\n**4.2. 通量计算**\n穿过单元 $C_L$ 和 $C_R$ 之间面 $e$ 的 MFD 通量是使用重构的梯度计算的。面上的通量向量通过相邻单元通量向量的算术平均来近似：\n$$\\mathbf{q}_e \\approx \\frac{\\mathbf{q}_L + \\mathbf{q}_R}{2} = -\\frac{K\\nabla p_L + K\\nabla p_R}{2}$$\n由于 $K$ 是常数，且对于线性势，重构是精确的（$\\nabla p_L = \\nabla p_R = \\mathbf{g}$），因此面通量向量就是 $\\mathbf{q}_e = -K\\mathbf{g}$。法向通量则为：\n$$F^{\\text{MFD}}_e = |e| (\\mathbf{q}_e \\cdot \\mathbf{n}) = -|e| \\mathbf{n}^\\top K \\left(\\frac{\\nabla p_L + \\nabla p_R}{2}\\right)$$\n对于线性构造解，这变为：\n$$F^{\\text{MFD}}_e = -|e| \\mathbf{n}^\\top K \\left(\\frac{\\mathbf{g} + \\mathbf{g}}{2}\\right) = -|e| \\mathbf{n}^\\top K \\mathbf{g} = F^{\\text{ex}}_e$$\n因此，MFD 格式对于任意网格上的线性势是精确的，应该产生接近于零的数值误差。\n\n**5. 误差与一致性分析**\n每个格式的精度由通量近似在所有 $N_f$ 个内部面上的误差的相对 $L^2$ 范数来衡量：\n$$E = \\frac{\\left\\|F_{\\text{approx}} - F_{\\text{ex}}\\right\\|_2}{\\left\\|F_{\\text{ex}}\\right\\|_2} = \\frac{\\left(\\sum_e (F^{\\text{approx}}_e - F^{\\text{ex}}_e)^2\\right)^{1/2}}{\\left(\\sum_e (F^{\\text{ex}}_e)^2\\right)^{1/2}}$$\n我们必须为 $F_{\\text{approx}} = F_{\\text{TPFA}}$ 和 $F_{\\text{approx}} = F_{\\text{MFD}}$ 分别计算这个误差。\n\n如果两种格式通量之差的 $L^2$ 范数与精确通量的范数相比可以忽略不计，则认为它们是一致的。我们使用一个小的容差 $\\epsilon$ 来定义这一点：\n$$\\frac{\\left\\|F_{\\text{TPFA}} - F_{\\text{MFD}}\\right\\|_2}{\\left\\|F_{\\text{ex}}\\right\\|_2}  \\epsilon$$\n对于双精度浮点运算，容差 $\\epsilon=10^{-12}$ 是合适的。当 TPFA 格式也是精确的，即在 K-正交网格上时，预计会发生一致性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1: Orthogonal mesh, isotropic K\",\n            \"Nx\": 8, \"Ny\": 7,\n            \"A\": np.identity(2),\n            \"K_params\": {\"type\": \"iso\", \"k\": 2.0},\n            \"grad_p\": np.array([1.3, -0.9])\n        },\n        {\n            \"name\": \"Case 2: Skewed mesh, anisotropic K\",\n            \"Nx\": 8, \"Ny\": 7,\n            \"A\": np.array([[1.0, 0.7], [0.0, 1.0]]),\n            \"K_params\": {\"type\": \"aniso_rot\", \"kx\": 5.0, \"ky\": 1.0, \"theta_deg\": 30.0},\n            \"grad_p\": np.array([1.3, -0.9])\n        },\n        {\n            \"name\": \"Case 3: Orthogonal mesh, anisotropic K (aligned)\",\n            \"Nx\": 8, \"Ny\": 7,\n            \"A\": np.identity(2),\n            \"K_params\": {\"type\": \"aniso_aligned\", \"kx\": 5.0, \"ky\": 1.0},\n            \"grad_p\": np.array([1.3, -0.9])\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_flux_errors(case)\n        results.append(result)\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join(\n        f\"[{res[0]},{res[1]},{str(res[2]).lower()}]\" for res in results\n    ) + \"]\"\n    print(output_str)\n\ndef compute_flux_errors(case_params):\n    \"\"\"\n    Computes mesh, fluxes, and errors for a single test case.\n    \"\"\"\n    Nx, Ny = case_params[\"Nx\"], case_params[\"Ny\"]\n    A = case_params[\"A\"]\n    grad_p = case_params[\"grad_p\"]\n\n    # Build diffusion tensor K\n    k_params = case_params[\"K_params\"]\n    if k_params[\"type\"] == \"iso\":\n        K = k_params[\"k\"] * np.identity(2)\n    elif k_params[\"type\"] == \"aniso_aligned\":\n        K = np.diag([k_params[\"kx\"], k_params[\"ky\"]])\n    elif k_params[\"type\"] == \"aniso_rot\":\n        theta = np.deg2rad(k_params[\"theta_deg\"])\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s], [s, c]])\n        D = np.diag([k_params[\"kx\"], k_params[\"ky\"]])\n        K = R @ D @ R.T\n\n    # 1. Mesh Generation\n    ref_x = np.linspace(0, 1, Nx + 1)\n    ref_y = np.linspace(0, 1, Ny + 1)\n    ref_vx, ref_vy = np.meshgrid(ref_x, ref_y, indexing='ij')\n    ref_vertices = np.stack([ref_vx, ref_vy], axis=-1)\n    \n    vertices = np.einsum('ij,klj-kli', A, ref_vertices)\n\n    cell_centers = np.zeros((Nx, Ny, 2))\n    for i in range(Nx):\n        for j in range(Ny):\n            cell_centers[i, j] = 0.25 * (vertices[i, j] + vertices[i+1, j] +\n                                         vertices[i, j+1] + vertices[i+1, j+1])\n\n    # 2. MFD: Reconstruct gradients in all cells\n    p_cell = np.einsum('ij,j-i', cell_centers.reshape(-1, 2), grad_p).reshape(Nx, Ny)\n    grad_p_mfd = np.zeros((Nx, Ny, 2))\n    for i in range(Nx):\n        for j in range(Ny):\n            neighbors = []\n            if i  0: neighbors.append((i - 1, j))\n            if i  Nx - 1: neighbors.append((i + 1, j))\n            if j  0: neighbors.append((i, j - 1))\n            if j  Ny - 1: neighbors.append((i, j + 1))\n            \n            num_neighbors = len(neighbors)\n            M = np.zeros((num_neighbors, 2))\n            b = np.zeros(num_neighbors)\n            \n            for k, (ni, nj) in enumerate(neighbors):\n                M[k, :] = cell_centers[ni, nj] - cell_centers[i, j]\n                b[k] = p_cell[ni, nj] - p_cell[i, j]\n            \n            # Least-squares solve: grad = (M^T M)^-1 M^T b\n            MTM = M.T @ M\n            MTb = M.T @ b\n            grad_p_mfd[i, j] = np.linalg.solve(MTM, MTb)\n\n    # 3. Loop over interior faces to compute fluxes\n    F_ex_list, F_tpfa_list, F_mfd_list = [], [], []\n\n    # Vertical interior faces\n    for i in range(Nx - 1):\n        for j in range(Ny):\n            # Face between C(i,j) and C(i+1,j)\n            L_idx, R_idx = (i, j), (i + 1, j)\n            \n            v1, v2 = vertices[i + 1, j], vertices[i + 1, j + 1]\n            edge = v2 - v1\n            length = np.linalg.norm(edge)\n            \n            normal_cand = np.array([-edge[1], edge[0]])\n            center_vec = cell_centers[R_idx] - cell_centers[L_idx]\n            if np.dot(normal_cand, center_vec)  0:\n                normal_cand = -normal_cand\n            normal = normal_cand / np.linalg.norm(normal_cand)\n\n            xL, xR = cell_centers[L_idx], cell_centers[R_idx]\n            pL, pR = p_cell[L_idx], p_cell[R_idx]\n\n            # Exact flux\n            F_ex = -length * normal.T @ K @ grad_p\n            F_ex_list.append(F_ex)\n\n            # TPFA flux\n            trans = length * (normal.T @ K @ normal) / np.dot(normal, xR - xL)\n            F_tpfa = -trans * (pR - pL)\n            F_tpfa_list.append(F_tpfa)\n\n            # MFD flux\n            grad_L, grad_R = grad_p_mfd[L_idx], grad_p_mfd[R_idx]\n            grad_face = 0.5 * (grad_L + grad_R)\n            F_mfd = -length * normal.T @ K @ grad_face\n            F_mfd_list.append(F_mfd)\n\n    # Horizontal interior faces\n    for i in range(Nx):\n        for j in range(Ny - 1):\n            # Face between C(i,j) and C(i,j+1)\n            L_idx, R_idx = (i, j), (i, j + 1)\n            \n            v1, v2 = vertices[i, j + 1], vertices[i + 1, j + 1]\n            edge = v2 - v1\n            length = np.linalg.norm(edge)\n\n            normal_cand = np.array([-edge[1], edge[0]])\n            center_vec = cell_centers[R_idx] - cell_centers[L_idx]\n            if np.dot(normal_cand, center_vec)  0:\n                normal_cand = -normal_cand\n            normal = normal_cand / np.linalg.norm(normal_cand)\n            \n            xL, xR = cell_centers[L_idx], cell_centers[R_idx]\n            pL, pR = p_cell[L_idx], p_cell[R_idx]\n\n            # Exact flux\n            F_ex = -length * normal.T @ K @ grad_p\n            F_ex_list.append(F_ex)\n\n            # TPFA flux\n            trans = length * (normal.T @ K @ normal) / np.dot(normal, xR - xL)\n            F_tpfa = -trans * (pR - pL)\n            F_tpfa_list.append(F_tpfa)\n\n            # MFD flux\n            grad_L, grad_R = grad_p_mfd[L_idx], grad_p_mfd[R_idx]\n            grad_face = 0.5 * (grad_L + grad_R)\n            F_mfd = -length * normal.T @ K @ grad_face\n            F_mfd_list.append(F_mfd)\n            \n    # 4. Calculate final errors and coincidence\n    F_ex_vec = np.array(F_ex_list)\n    F_tpfa_vec = np.array(F_tpfa_list)\n    F_mfd_vec = np.array(F_mfd_list)\n\n    norm_F_ex = np.linalg.norm(F_ex_vec)\n    if norm_F_ex == 0: # Avoid division by zero\n        E_tpfa = np.linalg.norm(F_tpfa_vec - F_ex_vec)\n        E_mfd = np.linalg.norm(F_mfd_vec - F_ex_vec)\n        coincidence_err = np.linalg.norm(F_tpfa_vec - F_mfd_vec)\n    else:\n        E_tpfa = np.linalg.norm(F_tpfa_vec - F_ex_vec) / norm_F_ex\n        E_mfd = np.linalg.norm(F_mfd_vec - F_ex_vec) / norm_F_ex\n        coincidence_err = np.linalg.norm(F_tpfa_vec - F_mfd_vec) / norm_F_ex\n\n    coincide = coincidence_err  1e-12\n\n    return [E_tpfa, E_mfd, coincide]\n\n# Execute the solver\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "数值方法的精度不仅取决于离散格式和网格，还取决于解本身的光滑性。本练习将处理工程问题中的一个常见挑战：由区域中的凹角引起的解的奇异性。您将在极坐标网格上实施TPFA，并探索如何通过策略性的网格加密——在奇异点附近系统地加密网格——来为非光滑解恢复最佳收敛阶。",
            "id": "3377656",
            "problem": "考虑二维空间中具有各向同性常数扩散系数的齐次扩散方程，在极坐标中写为扇形域上的拉普拉斯方程 $-\\nabla \\cdot (\\nabla u) = 0$。设物理域为扇形 $\\Omega = \\{(r,\\theta) : r \\in (0,1], \\theta \\in (0,\\omega)\\}$，其张角为 $\\omega = \\tfrac{3\\pi}{2}$。在边界 $\\theta=0$ 和 $\\theta=\\omega$ 上施加齐次狄利克雷数据 $u=0$，并在 $r=1$ 上施加等于精确解迹的狄利克雷数据。该扇形域中的精确调和奇异解为 $u_{\\star}(r,\\theta) = r^{\\alpha} \\sin(\\alpha \\theta)$，其中 $\\alpha = \\pi/\\omega = 2/3$。对于 $r0$，该解在经典意义上满足边界条件和 $\\Omega$ 内的 $-\\Delta u_{\\star} = 0$。\n\n您的任务是推导并实现一个基于极坐标网格构建的正交控制体上的两点通量近似 (TPFA) 有限体积法，然后用它来研究径向网格加密对 $u_{\\star}$ 的 $L^2$ 误差收敛性的影响。推导必须从散度定理和通量的定义开始，而不是从预先组装好的离散模板开始。\n\n离散化设置：\n- 使用一个包含 $N_r$ 个径向单元和 $N_{\\theta}$ 个角向单元的极坐标网格。设角向面是均匀的，$\\theta_{f,j} = j \\Delta \\theta$, $j=0,\\dots,N_{\\theta}$，$\\Delta \\theta = \\omega/N_{\\theta}$，角向中心位于 $\\theta_{c,j} = (j+\\tfrac{1}{2})\\Delta\\theta$。设径向面通过一个映射进行几何加密\n$$\nr_{f,i} = \\left(\\frac{i + \\tfrac{1}{2}}{N_r + \\tfrac{1}{2}}\\right)^{\\beta}, \\quad i=0,\\dots,N_r,\n$$\n其中 $\\beta0$ 是加密参数，径向中心位于 $r_{c,i} = \\tfrac{1}{2}(r_{f,i}+r_{f,i+1})$，$i=0,\\dots,N_r-1$。\n- 控制体 $(i,j)$ 是由 $r \\in (r_{f,i}, r_{f,i+1})$ 和 $\\theta \\in (\\theta_{f,j}, \\theta_{f,j+1})$ 界定的环形扇面。\n\n推导要求：\n- 从应用于每个控制体的散度定理出发，\n$$\n\\int_{V_{ij}} -\\nabla \\cdot (\\nabla u)\\, dA = \\sum_{F \\subset \\partial V_{ij}} \\int_{F} - \\nabla u \\cdot n\\, ds = 0,\n$$\n通过使用相邻单元中心（或单元中心与狄利克雷边界）之间沿法线方向的两点差分来近似每个面通量，从而推导出 TPFA：\n    - 对于位于 $r = r_{f,i}$ 或 $r = r_{f,i+1}$ 的径向面：使用传导率\n    $$\n    T_r = \\frac{A_r}{\\delta_r}, \\quad A_r = r_f \\Delta\\theta, \\quad \\delta_r = \\text{distance along the radial normal between centers (interior)} \\ \\text{or center-to-face (boundary)}.\n    $$\n    - 对于位于 $\\theta = \\theta_{f,j}$ 或 $\\theta = \\theta_{f,j+1}$ 的角向面：使用传导率\n    $$\n    T_{\\theta} = \\frac{A_{\\theta}}{\\delta_{\\theta}}, \\quad A_{\\theta} = \\Delta r_i = r_{f,i+1} - r_{f,i}, \\quad \\delta_{\\theta} = r_{c,i} \\Delta \\theta \\ \\text{(interior)} \\ \\text{or} \\ r_{c,i}\\tfrac{\\Delta \\theta}{2} \\ \\text{(boundary)}.\n    $$\n- 组装线性系统，强制每个控制体中的出流通量总和为零，其中 $r=1$ 上的狄利克雷边界数据取自 $u_{\\star}$，而 $\\theta=0$ 和 $\\theta=\\omega$ 上的数据为零。在最内圈的径向面 $r=r_{f,0}0$ 上，施加等于 $u_{\\star}$ 的狄利克雷数据以对问题进行正则化，并通过一个随着 $N_r$ 增大而缩小的孔，使域远离奇异点 $r=0$。\n\n误差度量：\n- 对于计算出的单元中心解 $u_h(i,j)$，通过以下方式近似 $L^2$ 误差\n$$\n\\|u_h - u_{\\star}\\|_{L^2(\\Omega_h)} \\approx \\left(\\sum_{i=0}^{N_r-1}\\sum_{j=0}^{N_{\\theta}-1} \\left(u_h(i,j) - u_{\\star}(r_{c,i},\\theta_{c,j})\\right)^2 \\, |V_{ij}|\\right)^{1/2},\n$$\n其中控制体面积为 $|V_{ij}| = \\tfrac{1}{2}\\big(r_{f,i+1}^2 - r_{f,i}^2\\big)\\Delta\\theta$，离散域为 $\\Omega_h = \\bigcup V_{ij}$。\n\n收敛模型与预期速率：\n- 对于光滑解上的经典二阶方法，其 $L^2$ 误差为 $\\mathcal{O}(h^2)$。在存在角点奇异性 $u_{\\star}(r,\\theta)\\sim r^{\\alpha}$（其中 $\\alpha\\in(0,1)$）的情况下，径向贡献占主导地位，在加密网格 $r \\sim \\xi^{\\beta}$ 上，预计 $L^2$ 收敛速率接近于\n$$\np(\\beta) \\approx \\min\\{2,\\ 1 + \\alpha \\beta\\},\n$$\n即，当径向加密 $\\beta \\ge 1/\\alpha$ 时，可以在 $L^2$ 范数下恢复最优的二阶收敛速率，而加密不足则会降低收敛速率。\n\n计算研究：\n- 固定 $\\omega = \\tfrac{3\\pi}{2}$ 和 $\\alpha = \\pi/\\omega = 2/3$。对于每个加密参数 $\\beta \\in \\{0.5, 1.0, 1.5, 2.0\\}$，在三个层级的网格 $(N_r, N_{\\theta}) \\in \\{(32, 64), (64, 128), (128, 256)\\}$ 上求解离散问题，并计算实验收敛阶\n$$\n\\text{EOC} = \\frac{\\log\\left(\\|e_{N_r}\\|_{L^2}/\\|e_{2N_r}\\|_{L^2}\\right)}{\\log(2)},\n$$\n使用最后两个层级。将测得的 $\\text{EOC}$ 与预测的 $p(\\beta)$ 进行比较，如果对于容差 $\\tau=0.25$ 满足 $\\text{EOC} \\ge p(\\beta) - \\tau$，则返回布尔值 true。\n\n测试套件和输出规范：\n- 测试套件由四个加密参数 $\\beta \\in \\{0.5, 1.0, 1.5, 2.0\\}$ 以及上述指定的三个细化层级 $(N_r,N_{\\theta})$ 组成。\n- 您的程序的最终输出必须是单行，其中包含一个 Python 风格的布尔值列表，该列表包含按升序排列的与这些 $\\beta$ 值相对应的四个布尔值，例如 $[b_1,b_2,b_3,b_4]$。\n\n所有计算都是无量纲的，因此不需要物理单位。角度以弧度为单位。程序必须是自包含的，执行离散化，求解线性系统，计算误差和实验收敛阶，进行比较，并以确切要求的输出格式打印结果，不得包含任何额外文本。",
            "solution": "根据既定的验证标准，用户提供的问题被评估为有效。该问题在科学上基于偏微分方程的数值分析，特别是应用于拉普拉斯方程的有限体积法。问题是适定的，为确定唯一解提供了所有必要的参数、边界条件和定义。语言客观而精确，其任务——研究网格加密对具有已知角点奇异性问题的收敛性的影响——是计算科学中一个标准且有意义的练习。\n\n\\textbf{1. 有限体积离散化推导}\n\n有限体积法的基本原理是在划分域的一组控制体上以积分形式强制执行守恒定律。我们从守恒形式的拉普拉斯方程 $-\\nabla \\cdot (\\nabla u) = 0$ 开始。在控制体 $V_{ij}$ 上积分并应用高斯-格林定理或散度定理，得到：\n$$\n\\int_{V_{ij}} -\\nabla \\cdot (\\nabla u)\\, dA = \\oint_{\\partial V_{ij}} -(\\nabla u) \\cdot \\boldsymbol{n}\\, ds = 0\n$$\n其中 $\\partial V_{ij}$ 是控制体的边界，$\\boldsymbol{n}$ 是向外的单位法向量。向量场 $\\boldsymbol{F} = -\\nabla u$ 代表通量，该方程表明任何控制体的净流出通量为零，反映了没有源或汇。\n\n极坐标网格将控制体 $V_{ij}$ 定义为由半径 $r \\in [r_{f,i}, r_{f,i+1}]$ 和角度 $\\theta \\in [\\theta_{f,j}, \\theta_{f,j+1}]$ 界定的环形扇面。边界 $\\partial V_{ij}$ 由四个面组成：两个径向面（在恒定 $r$ 处）和两个角向面（在恒定 $\\theta$ 处）。通量平衡方程可以分解为穿过这些面的通量之和。设 $u_{ij}$ 为单元中心 $(r_{c,i}, \\theta_{c,j})$ 处解的近似值。\n\n\\textbf{径向面通量}：\n考虑位于 $r = r_{f,i+1}$ 的径向面，它分隔单元 $(i,j)$ 和 $(i+1,j)$。极坐标中的通量向量为 $\\boldsymbol{F} = -\\nabla u = -(\\frac{\\partial u}{\\partial r} \\boldsymbol{e}_r + \\frac{1}{r}\\frac{\\partial u}{\\partial \\theta} \\boldsymbol{e}_{\\theta})$。该面的法线为 $\\boldsymbol{n} = \\boldsymbol{e}_r$。穿过该面的总通量为：\n$$\n\\mathcal{F}_{i+1/2,j} = \\int_{\\theta_{f,j}}^{\\theta_{f,j+1}} (-\\nabla u \\cdot \\boldsymbol{e}_r)|_{r=r_{f,i+1}} \\, r_{f,i+1} d\\theta = \\int_{\\theta_{f,j}}^{\\theta_{f,j+1}} -\\frac{\\partial u}{\\partial r} \\Big|_{r=r_{f,i+1}} \\, r_{f,i+1} d\\theta\n$$\n在两点通量近似 (TPFA) 中，我们对此积分进行近似。径向导数通过单元 $(i,j)$ 和 $(i+1,j)$ 中心之间的两点有限差分来近似：\n$$\n\\frac{\\partial u}{\\partial r} \\Big|_{r=r_{f,i+1}} \\approx \\frac{u_{i+1,j} - u_{i,j}}{r_{c,i+1} - r_{c,i}}\n$$\n通过在面的中心评估被积函数并乘以面的弧长 $A_r = r_{f,i+1} \\Delta\\theta$ 来近似该积分：\n$$\n\\mathcal{F}_{i+1/2,j} \\approx -\\left(\\frac{u_{i+1,j} - u_{i,j}}{r_{c,i+1} - r_{c,i}}\\right) A_r = \\frac{A_r}{r_{c,i+1} - r_{c,i}} (u_{i,j} - u_{i+1,j})\n$$\n这定义了从单元 $(i,j)$ 到 $(i+1,j)$ 的通量为 $T_{r,i+1/2}(u_{i,j} - u_{i+1,j})$，其中径向传导率为 $T_{r,i+1/2} = A_r / \\delta_r$，且 $\\delta_r = r_{c,i+1} - r_{c,i}$。\n\n\\textbf{角向面通量}：\n考虑位于 $\\theta = \\theta_{f,j+1}$ 的角向面，它分隔单元 $(i,j)$ 和 $(i,j+1)$。法线为 $\\boldsymbol{n} = \\boldsymbol{e}_{\\theta}$。通量为：\n$$\n\\mathcal{F}_{i,j+1/2} = \\int_{r_{f,i}}^{r_{f,i+1}} (-\\nabla u \\cdot \\boldsymbol{e}_{\\theta})|_{\\theta=\\theta_{f,j+1}} \\, dr_c = \\int_{r_{f,i}}^{r_{f,i+1}} -\\frac{1}{r}\\frac{\\partial u}{\\partial \\theta} \\Big|_{\\theta=\\theta_{f,j+1}} \\, dr\n$$\n我们使用单元 $(i,j)$ 和 $(i,j+1)$ 的中心来近似导数，并在面的径向中心 $r_{c,i}$ 处评估 $1/r$ 项：\n$$\n\\frac{1}{r}\\frac{\\partial u}{\\partial \\theta} \\Big|_{\\theta=\\theta_{f,j+1}} \\approx \\frac{1}{r_{c,i}} \\frac{u_{i,j+1} - u_{i,j}}{\\theta_{c,j+1} - \\theta_{c,j}} = \\frac{1}{r_{c,i}} \\frac{u_{i,j+1} - u_{i,j}}{\\Delta\\theta}\n$$\n通过乘以面长 $A_{\\theta} = r_{f,i+1} - r_{f,i} = \\Delta r_i$ 来近似积分：\n$$\n\\mathcal{F}_{i,j+1/2} \\approx -\\left(\\frac{1}{r_{c,i}} \\frac{u_{i,j+1} - u_{i,j}}{\\Delta\\theta}\\right) A_{\\theta} = \\frac{A_{\\theta}}{r_{c,i}\\Delta\\theta} (u_{i,j} - u_{i,j+1})\n$$\n这定义了从单元 $(i,j)$ 到 $(i,j+1)$ 的通量为 $T_{\\theta,i,j+1/2}(u_{i,j} - u_{i,j+1})$，其中角向传导率为 $T_{\\theta,i,j+1/2} = A_{\\theta} / \\delta_{\\theta}$，且 $\\delta_{\\theta} = r_{c,i}\\Delta\\theta$。\n\n\\textbf{2. 线性系统组装}\n对于每个内部单元 $(i,j)$，守恒定律变为四个出流通量之和：\n$$\n\\sum_{\\text{faces}} \\mathcal{F}_{\\text{out}} = T_{r,i-1/2}(u_{i,j}-u_{i-1,j}) + T_{r,i+1/2}(u_{i,j}-u_{i+1,j}) + T_{\\theta,i,j-1/2}(u_{i,j}-u_{i,j-1}) + T_{\\theta,i,j+1/2}(u_{i,j}-u_{i,j+1}) = 0\n$$\n重新整理各项，我们得到关于 $u_{i,j}$ 的线性方程：\n$$\n(T_{r,i-1/2} + T_{r,i+1/2} + T_{\\theta,i,j-1/2} + T_{\\theta,i,j+1/2}) u_{i,j} - T_{r,i-1/2} u_{i-1,j} - T_{r,i+1/2} u_{i+1,j} - T_{\\theta,i,j-1/2} u_{i,j-1} - T_{\\theta,i,j+1/2} u_{i,j+1} = 0\n$$\n对于与狄利克雷边界相邻的单元，涉及已知边界值 $u_D$ 的通量项会被修改。传导率中的距离 $\\delta$ 变为从单元中心到边界面之间的较短距离。项 $T_D(u_{i,j}-u_D)$ 被拆分：$T_D u_{i,j}$ 贡献给系统矩阵 $A$ 的对角线，而 $T_D u_D$ 贡献给右侧向量 $\\boldsymbol{b}$。将此过程应用于所有 $N_r \\times N_{\\theta}$ 个单元，会生成一个稀疏线性系统 $A\\boldsymbol{U}=\\boldsymbol{b}$，求解该系统可得到单元中心未知量向量 $\\boldsymbol{U}$。\n\n\\textbf{3. 误差分析与收敛性}\n求解得到数值解 $u_h$ 后，我们通过将 $u_h$ 与所有单元中心处的精确解 $u_{\\star}$ 进行比较，并按单元面积加权，来计算离散 $L^2$ 误差：\n$$\n\\|u_h - u_{\\star}\\|_{L^2(\\Omega_h)} = \\left(\\sum_{i=0}^{N_r-1}\\sum_{j=0}^{N_{\\theta}-1} (u_{ij} - u_{\\star}(r_{c,i},\\theta_{c,j}))^2 |V_{ij}|\\right)^{1/2}\n$$\n然后，使用来自两个连续网格细化的误差计算实验收敛阶 (EOC)。将此测量速率与理论预测 $p(\\beta) = \\min\\{2, 1+\\alpha\\beta\\}$进行比较，该预测量化了径向网格加密参数 $\\beta$ 如何帮助减轻由解在原点的奇异性引起的精度损失。当加密足够强时，即对于 $\\beta \\ge 1/\\alpha$，可恢复最优速率 2。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.sparse\nimport scipy.sparse.linalg\n\ndef solve():\n    \"\"\"\n    Main driver for the convergence study.\n    Iterates through grading parameters, computes EOC, and compares to theory.\n    \"\"\"\n    \n    def u_star(r, theta, alpha):\n        \"\"\"Computes the exact singular solution.\"\"\"\n        return (r**alpha) * np.sin(alpha * theta)\n\n    def run_simulation(Nr, Ntheta, beta, omega, alpha):\n        \"\"\"\n        Sets up and solves the finite volume system for a given mesh and grading.\n        Returns the L2 error.\n        \"\"\"\n        # 1. Grid Generation\n        d_theta = omega / Ntheta\n        \n        # Angular grid\n        theta_c = (np.arange(Ntheta) + 0.5) * d_theta\n        \n        # Radial grid\n        i_vals_faces = np.arange(Nr + 1)\n        rf = ((i_vals_faces + 0.5) / (Nr + 0.5))**beta\n        rc = 0.5 * (rf[:-1] + rf[1:])\n        \n        # 2. System Assembly\n        N_cells = Nr * Ntheta\n        A = scipy.sparse.lil_matrix((N_cells, N_cells), dtype=float)\n        b = np.zeros(N_cells, dtype=float)\n        \n        for i in range(Nr):      # Radial cell index\n            dr_i = rf[i+1] - rf[i]\n            for j in range(Ntheta):  # Angular cell index\n                k = i * Ntheta + j\n                diag_sum = 0.0\n\n                # West face (smaller radius, i-1/2)\n                if i  0: # Interior face\n                    T_W = (rf[i] * d_theta) / (rc[i] - rc[i-1])\n                    diag_sum += T_W\n                    A[k, k - Ntheta] = -T_W\n                else: # Boundary face at r_f,0\n                    T_W = (rf[0] * d_theta) / (rc[0] - rf[0])\n                    diag_sum += T_W\n                    u_D = u_star(rf[0], theta_c[j], alpha)\n                    b[k] += T_W * u_D\n                    \n                # East face (larger radius, i+1/2)\n                if i  Nr - 1: # Interior face\n                    T_E = (rf[i+1] * d_theta) / (rc[i+1] - rc[i])\n                    diag_sum += T_E\n                    A[k, k + Ntheta] = -T_E\n                else: # Boundary face at r_f,Nr = 1\n                    T_E = (rf[Nr] * d_theta) / (rf[Nr] - rc[Nr-1])\n                    diag_sum += T_E\n                    u_D = u_star(rf[Nr], theta_c[j], alpha)\n                    b[k] += T_E * u_D\n                    \n                # South face (smaller angle, j-1/2)\n                if j  0: # Interior face\n                    T_S = dr_i / (rc[i] * d_theta)\n                    diag_sum += T_S\n                    A[k, k - 1] = -T_S\n                else: # Boundary face at theta = 0\n                    T_S = dr_i / (rc[i] * d_theta / 2.0)\n                    diag_sum += T_S\n                    # u_D = 0.0, so no contribution to b\n                    \n                # North face (larger angle, j+1/2)\n                if j  Ntheta - 1: # Interior face\n                    T_N = dr_i / (rc[i] * d_theta)\n                    diag_sum += T_N\n                    A[k, k + 1] = -T_N\n                else: # Boundary face at theta = omega\n                    T_N = dr_i / (rc[i] * d_theta / 2.0)\n                    diag_sum += T_N\n                    # u_D = 0.0, so no contribution to b\n                    \n                A[k, k] = diag_sum\n                \n        # 3. Solve System\n        A_csr = A.tocsr()\n        u_flat = scipy.sparse.linalg.spsolve(A_csr, b)\n        u_h = u_flat.reshape((Nr, Ntheta))\n        \n        # 4. Error Calculation\n        rc_grid, theta_c_grid = np.meshgrid(rc, theta_c, indexing='ij')\n        \n        u_exact_grid = u_star(rc_grid, theta_c_grid, alpha)\n        \n        rf_sq_diff = rf[1:]**2 - rf[:-1]**2\n        V_areas_grid = 0.5 * d_theta * np.tile(rf_sq_diff[:, np.newaxis], (1, Ntheta))\n        \n        error_sq_sum = np.sum(((u_h - u_exact_grid)**2) * V_areas_grid)\n        l2_error = np.sqrt(error_sq_sum)\n        \n        return l2_error\n\n    omega = 3.0 * np.pi / 2.0\n    alpha = np.pi / omega\n    tolerance = 0.25\n    \n    test_cases = [0.5, 1.0, 1.5, 2.0] # beta values\n    refinement_levels = [(32, 64), (64, 128), (128, 256)]\n    \n    results = []\n    \n    for beta in test_cases:\n        errors = []\n        for Nr, Ntheta in refinement_levels:\n            error = run_simulation(Nr, Ntheta, beta, omega, alpha)\n            errors.append(error)\n        \n        # EOC uses last two refinement levels\n        eoc = np.log(errors[-2] / errors[-1]) / np.log(2.0)\n        \n        # Predicted rate\n        p_beta = min(2.0, 1.0 + alpha * beta)\n        \n        # Compare and record result\n        results.append(eoc = p_beta - tolerance)\n\n    # Convert Python boolean to string representation for output\n    str_results = [str(r).lower() for r in results]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        }
    ]
}