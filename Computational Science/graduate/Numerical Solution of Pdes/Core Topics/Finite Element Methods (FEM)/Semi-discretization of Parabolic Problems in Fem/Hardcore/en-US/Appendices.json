{
    "hands_on_practices": [
        {
            "introduction": "A robust numerical method should, ideally, preserve the essential physical properties of the partial differential equation it approximates. For the heat equation, one such property is the maximum principle, which states that the maximum temperature will occur either at the initial time or on the boundary of the domain. This exercise  provides a crucial hands-on demonstration that this property is not automatically inherited by the standard Finite Element Method. Through a direct calculation on a carefully constructed mesh, you will discover how mesh geometry—specifically the presence of obtuse angles—can alter the algebraic structure of the stiffness matrix, leading to a violation of the conditions required for a discrete maximum principle.",
            "id": "3441983",
            "problem": "Consider the heat equation semi-discretized in space by the Finite Element Method (FEM) with continuous, piecewise linear basis functions (also called $P_1$ elements). The spatial bilinear form is $a(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, dx$, and the stiffness matrix $\\boldsymbol{K}$ is defined by $K_{ij} = a(\\varphi_{j},\\varphi_{i})$ for the global nodal basis $\\{\\varphi_{i}\\}$. It is known that a necessary condition for the Discrete Maximum Principle (DMP) in the semi-discrete method-of-lines system $\\boldsymbol{M} \\,\\dot{\\boldsymbol{u}} + \\boldsymbol{K} \\boldsymbol{u} = \\boldsymbol{f}$ is that $\\boldsymbol{K}$ has nonpositive off-diagonal entries (an $\\mathcal{M}$-matrix sign pattern).\n\nConstruct a counterexample patch showing failure of this sign condition as follows. Let the domain $\\Omega$ be the union of two triangles sharing the edge between nodes at coordinates $\\boldsymbol{p}_{1} = (0,0)$ and $\\boldsymbol{p}_{2} = (1,0)$:\n- Triangle $\\mathcal{T}_{1}$ with vertices $\\boldsymbol{p}_{1} = (0,0)$, $\\boldsymbol{p}_{2} = (1,0)$, and $\\boldsymbol{p}_{3} = \\left(\\tfrac{1}{2}, \\tfrac{1}{10}\\right)$.\n- Triangle $\\mathcal{T}_{2}$ with vertices $\\boldsymbol{p}_{1} = (0,0)$, $\\boldsymbol{p}_{2} = (1,0)$, and $\\boldsymbol{p}_{4} = \\left(\\tfrac{1}{2}, -\\tfrac{1}{4}\\right)$.\n\nOn this mesh, using $P_1$ basis functions, compute the assembled off-diagonal stiffness entry $$ K_{12} = \\sum_{\\mathcal{T} \\in \\{\\mathcal{T}_{1},\\mathcal{T}_{2}\\}} \\int_{\\mathcal{T}} \\nabla \\varphi_{2} \\cdot \\nabla \\varphi_{1} \\, dx $$. Provide the exact value of $K_{12}$ as a single simplified real number. No rounding is required.\n\nThen, briefly explain whether the sign of $K_{12}$ is compatible with the nonpositivity requirement for the off-diagonal entries of $\\boldsymbol{K}$ associated with the Discrete Maximum Principle (DMP) in the semi-discretized parabolic problem.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It presents a standard exercise in the numerical analysis of partial differential equations using the Finite Element Method (FEM).\n\nThe objective is to compute the off-diagonal entry $K_{12}$ of the global stiffness matrix $\\boldsymbol{K}$, which is assembled from the local contributions of the two triangles, $\\mathcal{T}_{1}$ and $\\mathcal{T}_{2}$, that share the edge connecting nodes $1$ and $2$. The definition of $K_{ij}$ is given by $K_{ij} = a(\\varphi_j, \\varphi_i)$, where $a(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, dx$ and $\\{\\varphi_i\\}$ are the $P_1$ nodal basis functions.\n\nThe assembled stiffness entry $K_{12}$ is the sum of the local stiffness entries from each triangle sharing the edge between nodes $1$ and $2$:\n$$\nK_{12} = K_{12}^{\\mathcal{T}_1} + K_{12}^{\\mathcal{T}_2} = \\int_{\\mathcal{T}_1} \\nabla \\varphi_2 \\cdot \\nabla \\varphi_1 \\, d\\boldsymbol{x} + \\int_{\\mathcal{T}_2} \\nabla \\varphi_2 \\cdot \\nabla \\varphi_1 \\, d\\boldsymbol{x}\n$$\nFor a triangular element $\\mathcal{T}$ with vertices $\\boldsymbol{p}_i, \\boldsymbol{p}_j, \\boldsymbol{p}_k$, the local stiffness matrix entry $K_{ij}^{\\mathcal{T}}$ is given by the well-known formula:\n$$\nK_{ij}^{\\mathcal{T}} = -\\frac{1}{2} \\cot(\\theta_k)\n$$\nwhere $\\theta_k$ is the interior angle of the triangle at the vertex $\\boldsymbol{p}_k$ opposite the edge connecting $\\boldsymbol{p}_i$ and $\\boldsymbol{p}_j$.\n\nIn our problem, we need to compute $K_{12}$. The edge connecting nodes $1$ and $2$ is common to both triangles $\\mathcal{T}_1$ and $\\mathcal{T}_2$.\nFor triangle $\\mathcal{T}_1$, with vertices $\\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_3$, the vertex opposite the edge $\\boldsymbol{p}_1\\boldsymbol{p}_2$ is $\\boldsymbol{p}_3$. Let $\\theta_3$ be the angle at $\\boldsymbol{p}_3$.\nFor triangle $\\mathcal{T}_2$, with vertices $\\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_4$, the vertex opposite the edge $\\boldsymbol{p}_1\\boldsymbol{p}_2$ is $\\boldsymbol{p}_4$. Let $\\theta_4$ be the angle at $\\boldsymbol{p}_4$.\n\nThus, the global stiffness entry is:\n$$\nK_{12} = K_{12}^{\\mathcal{T}_1} + K_{12}^{\\mathcal{T}_2} = -\\frac{1}{2} \\cot(\\theta_3) - \\frac{1}{2} \\cot(\\theta_4)\n$$\n\nWe proceed to calculate $\\cot(\\theta_3)$ and $\\cot(\\theta_4)$.\n\nFirst, for triangle $\\mathcal{T}_1$ with vertices $\\boldsymbol{p}_{1} = (0,0)$, $\\boldsymbol{p}_{2} = (1,0)$, and $\\boldsymbol{p}_{3} = \\left(\\frac{1}{2}, \\frac{1}{10}\\right)$.\nThe angle $\\theta_3$ is the angle between the vectors $\\boldsymbol{v}_{31} = \\boldsymbol{p}_1 - \\boldsymbol{p}_3$ and $\\boldsymbol{v}_{32} = \\boldsymbol{p}_2 - \\boldsymbol{p}_3$.\n$$\n\\boldsymbol{v}_{31} = (0,0) - \\left(\\frac{1}{2}, \\frac{1}{10}\\right) = \\left(-\\frac{1}{2}, -\\frac{1}{10}\\right)\n$$\n$$\n\\boldsymbol{v}_{32} = (1,0) - \\left(\\frac{1}{2}, \\frac{1}{10}\\right) = \\left(\\frac{1}{2}, -\\frac{1}{10}\\right)\n$$\nThe dot product is:\n$$\n\\boldsymbol{v}_{31} \\cdot \\boldsymbol{v}_{32} = \\left(-\\frac{1}{2}\\right)\\left(\\frac{1}{2}\\right) + \\left(-\\frac{1}{10}\\right)\\left(-\\frac{1}{10}\\right) = -\\frac{1}{4} + \\frac{1}{100} = -\\frac{25}{100} + \\frac{1}{100} = -\\frac{24}{100} = -\\frac{6}{25}\n$$\nThe magnitudes squared are:\n$$\n|\\boldsymbol{v}_{31}|^2 = \\left(-\\frac{1}{2}\\right)^2 + \\left(-\\frac{1}{10}\\right)^2 = \\frac{1}{4} + \\frac{1}{100} = \\frac{26}{100}\n$$\n$$\n|\\boldsymbol{v}_{32}|^2 = \\left(\\frac{1}{2}\\right)^2 + \\left(-\\frac{1}{10}\\right)^2 = \\frac{1}{4} + \\frac{1}{100} = \\frac{26}{100}\n$$\nSo, $|\\boldsymbol{v}_{31}| = |\\boldsymbol{v}_{32}| = \\frac{\\sqrt{26}}{10}$.\nThe cosine of the angle $\\theta_3$ is:\n$$\n\\cos(\\theta_3) = \\frac{\\boldsymbol{v}_{31} \\cdot \\boldsymbol{v}_{32}}{|\\boldsymbol{v}_{31}| |\\boldsymbol{v}_{32}|} = \\frac{-6/25}{26/100} = -\\frac{6}{25} \\cdot \\frac{100}{26} = -\\frac{6 \\cdot 4}{26} = -\\frac{12}{13}\n$$\nSince $\\theta_3$ is an angle in a triangle, $0  \\theta_3  \\pi$, so $\\sin(\\theta_3) > 0$.\n$$\n\\sin(\\theta_3) = \\sqrt{1 - \\cos^2(\\theta_3)} = \\sqrt{1 - \\left(-\\frac{12}{13}\\right)^2} = \\sqrt{1 - \\frac{144}{169}} = \\sqrt{\\frac{25}{169}} = \\frac{5}{13}\n$$\nThe cotangent is:\n$$\n\\cot(\\theta_3) = \\frac{\\cos(\\theta_3)}{\\sin(\\theta_3)} = \\frac{-12/13}{5/13} = -\\frac{12}{5}\n$$\nSince $\\cot(\\theta_3)$ is negative, the angle $\\theta_3$ is obtuse.\n\nSecond, for triangle $\\mathcal{T}_2$ with vertices $\\boldsymbol{p}_{1} = (0,0)$, $\\boldsymbol{p}_{2} = (1,0)$, and $\\boldsymbol{p}_{4} = \\left(\\frac{1}{2}, -\\frac{1}{4}\\right)$.\nThe angle $\\theta_4$ is the angle between the vectors $\\boldsymbol{v}_{41} = \\boldsymbol{p}_1 - \\boldsymbol{p}_4$ and $\\boldsymbol{v}_{42} = \\boldsymbol{p}_2 - \\boldsymbol{p}_4$.\n$$\n\\boldsymbol{v}_{41} = (0,0) - \\left(\\frac{1}{2}, -\\frac{1}{4}\\right) = \\left(-\\frac{1}{2}, \\frac{1}{4}\\right)\n$$\n$$\n\\boldsymbol{v}_{42} = (1,0) - \\left(\\frac{1}{2}, -\\frac{1}{4}\\right) = \\left(\\frac{1}{2}, \\frac{1}{4}\\right)\n$$\nThe dot product is:\n$$\n\\boldsymbol{v}_{41} \\cdot \\boldsymbol{v}_{42} = \\left(-\\frac{1}{2}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = -\\frac{1}{4} + \\frac{1}{16} = -\\frac{4}{16} + \\frac{1}{16} = -\\frac{3}{16}\n$$\nThe magnitudes squared are:\n$$\n|\\boldsymbol{v}_{41}|^2 = \\left(-\\frac{1}{2}\\right)^2 + \\left(\\frac{1}{4}\\right)^2 = \\frac{1}{4} + \\frac{1}{16} = \\frac{5}{16}\n$$\n$$\n|\\boldsymbol{v}_{42}|^2 = \\left(\\frac{1}{2}\\right)^2 + \\left(\\frac{1}{4}\\right)^2 = \\frac{1}{4} + \\frac{1}{16} = \\frac{5}{16}\n$$\nSo, $|\\boldsymbol{v}_{41}| = |\\boldsymbol{v}_{42}| = \\frac{\\sqrt{5}}{4}$.\nThe cosine of the angle $\\theta_4$ is:\n$$\n\\cos(\\theta_4) = \\frac{\\boldsymbol{v}_{41} \\cdot \\boldsymbol{v}_{42}}{|\\boldsymbol{v}_{41}| |\\boldsymbol{v}_{42}|} = \\frac{-3/16}{5/16} = -\\frac{3}{5}\n$$\n$$\n\\sin(\\theta_4) = \\sqrt{1 - \\cos^2(\\theta_4)} = \\sqrt{1 - \\left(-\\frac{3}{5}\\right)^2} = \\sqrt{1 - \\frac{9}{25}} = \\sqrt{\\frac{16}{25}} = \\frac{4}{5}\n$$\nThe cotangent is:\n$$\n\\cot(\\theta_4) = \\frac{\\cos(\\theta_4)}{\\sin(\\theta_4)} = \\frac{-3/5}{4/5} = -\\frac{3}{4}\n$$\nSince $\\cot(\\theta_4)$ is negative, the angle $\\theta_4$ is also obtuse.\n\nFinally, we assemble the value of $K_{12}$:\n$$\nK_{12} = -\\frac{1}{2} \\cot(\\theta_3) - \\frac{1}{2} \\cot(\\theta_4) = -\\frac{1}{2}\\left(-\\frac{12}{5}\\right) - \\frac{1}{2}\\left(-\\frac{3}{4}\\right)\n$$\n$$\nK_{12} = \\frac{12}{10} + \\frac{3}{8} = \\frac{6}{5} + \\frac{3}{8}\n$$\n$$\nK_{12} = \\frac{6 \\cdot 8}{40} + \\frac{3 \\cdot 5}{40} = \\frac{48 + 15}{40} = \\frac{63}{40}\n$$\nThe computed value is $K_{12} = \\frac{63}{40}$, which is a positive number.\n\nThe Discrete Maximum Principle (DMP) for the semi-discrete system requires, as a necessary condition, that the stiffness matrix $\\boldsymbol{K}$ is an $\\mathcal{M}$-matrix. A property of an $\\mathcal{M}$-matrix is that all its off-diagonal entries are nonpositive, i.e., $K_{ij} \\le 0$ for all $i \\neq j$.\nOur calculation for the given mesh yields $K_{12} = \\frac{63}{40} > 0$. This violates the nonpositivity condition. Therefore, the sign of $K_{12}$ is not compatible with the requirement for the DMP. This example demonstrates that triangulations containing obtuse angles can lead to a stiffness matrix that is not an $\\mathcal{M}$-matrix, and thus the DMP is not guaranteed.",
            "answer": "$$\n\\boxed{\\frac{63}{40}}\n$$"
        },
        {
            "introduction": "In solving time-dependent problems, computational efficiency is paramount. Mass lumping is a popular technique that simplifies the semi-discrete system $\\boldsymbol{M} \\dot{\\boldsymbol{U}} + \\boldsymbol{K} \\boldsymbol{U} = \\boldsymbol{F}$ by replacing the consistent mass matrix $\\boldsymbol{M}$ with a diagonal one, making the time-stepping solve trivial. However, this simplification is an approximation based on inexact numerical quadrature. This practice  guides you through a rigorous theoretical analysis to uncover the trade-off between this computational gain and numerical accuracy, showing precisely how the quadrature error introduced by mass lumping can degrade the method's overall convergence rate.",
            "id": "3442016",
            "problem": "Consider the one-dimensional heat equation on the unit interval with homogeneous Dirichlet boundary conditions,\n$$\nu_{t} - u_{xx} = 0 \\quad \\text{in } \\Omega := (0,1), \\quad u(0,t)=u(1,t)=0, \\quad t0,\n$$\nand smooth initial data\n$$\nu(x,0) = \\sin(\\pi x).\n$$\nThe exact solution is\n$$\nu(x,t) = \\exp(-\\pi^{2} t)\\sin(\\pi x).\n$$\nLet $\\mathcal{T}_{h}$ be a uniform partition of $\\Omega$ into $N$ subintervals of mesh-size $h=1/N$. Let $V_{h}\\subset H_{0}^{1}(\\Omega)$ denote the space of continuous piecewise quadratic polynomials on $\\mathcal{T}_{h}$, with the standard Lagrange nodal basis at the element endpoints and midpoints.\n\nDefine the semi-discrete Galerkin method with exact (consistent) mass by: find $u_{h}(t)\\in V_{h}$ such that for all $v_{h}\\in V_{h}$ and all $t0$,\n$$\n(u_{h}', v_{h}) + (u_{hx}, v_{hx}) = 0, \n$$\nwith initial condition $u_{h}(0) = I_{h}u(\\cdot,0)$, where $I_{h}$ is the Lagrange interpolation operator and $(\\cdot,\\cdot)$ is the $L^{2}(\\Omega)$ inner product.\n\nDefine the mass-lumped semi-discrete method by replacing the $L^{2}$ inner product with the elementwise three-point Gauss–Lobatto quadrature $(\\cdot,\\cdot)_{Q}$ that uses the element nodes (endpoints and midpoint) and yields a diagonal mass matrix: find $u_{h}^{L}(t)\\in V_{h}$ such that for all $v_{h}\\in V_{h}$ and all $t0$,\n$$\n(u_{h}^{L}{}', v_{h})_{Q} + (u_{h x}^{L}, v_{h x}) = 0,\n$$\nwith initial condition $u_{h}^{L}(0) = I_{h}u(\\cdot,0)$.\n\nUsing only fundamental principles of the Galerkin method, standard approximation properties of $I_{h}$ for $V_{h}$, the definition of the Gauss–Lobatto quadrature, and quadrature error analysis for sufficiently smooth integrands, construct and analyze this example to determine the largest integer $p$ such that there exists a constant $C$ independent of $h$ with\n$$\n\\|u(\\cdot,t) - u_{h}^{L}(\\cdot,t)\\|_{L^{2}(\\Omega)} \\le C\\, h^{p}, \\quad \\text{for each fixed } t\\in (0,1].\n$$\nYour analysis must make explicit how the quadrature error in the mass-lumped inner product degrades the $L^{2}(\\Omega)$ convergence order relative to the consistent mass case, via an adjoint (duality) or equivalent argument, and identify the dominant consistency-error term induced by the inexact quadrature.\n\nReport the integer $p$ as your final answer. No rounding is required, and no units are involved.",
            "solution": "The problem asks for the largest integer $p$ representing the order of convergence in the $L^2(\\Omega)$-norm for a mass-lumped semi-discrete finite element method for the one-dimensional heat equation. The space of trial and test functions, $V_h$, consists of continuous piecewise quadratic polynomials ($k=2$).\n\nThe error in the numerical solution, $e(t) = u(\\cdot, t) - u_h^L(\\cdot, t)$, can be split into two components: the interpolation error $\\eta(t) = u(\\cdot, t) - I_h u(\\cdot, t)$ and the discrete error $\\theta_h(t) = I_h u(\\cdot, t) - u_h^L(\\cdot, t)$. The total error is $e = \\eta + \\theta_h$.\n\nFor piecewise quadratic elements ($k=2$), standard interpolation theory for the Lagrange interpolant $I_h$ provides the following estimate for a sufficiently smooth function $u$:\n$$\n\\|\\eta(t)\\|_{L^2(\\Omega)} = \\|u(\\cdot, t) - I_h u(\\cdot, t)\\|_{L^2(\\Omega)} \\le C h^{k+1} \\|u(\\cdot, t)\\|_{H^{k+1}(\\Omega)} = C h^3 \\|u(\\cdot, t)\\|_{H^3(\\Omega)}.\n$$\nThe order of convergence $p$ is therefore determined by the minimum of $3$ and the order of convergence of $\\|\\theta_h(t)\\|_{L^2(\\Omega)}$. To find the convergence order of $\\theta_h$, we employ an adjoint (duality) argument.\n\nLet's first establish the error equation. The exact solution $u$ satisfies the weak form:\n$$\n(u_t, v_h) + (u_x, v_{hx}) = 0 \\quad \\forall v_h \\in V_h.\n$$\nThe mass-lumped semi-discrete solution $u_h^L$ satisfies:\n$$\n((u_h^L)_t, v_h)_Q + ((u_h^L)_x, v_{hx}) = 0 \\quad \\forall v_h \\in V_h.\n$$\nThe stiffness form $(u_x, v_{hx})$ is computed exactly, as the integrand is a product of two piecewise linear functions, resulting in a piecewise polynomial of degree $2$. The $3$-point Gauss-Lobatto quadrature rule is exact for polynomials of degree up to $2(3)-3 = 3$, so it integrates the stiffness term exactly.\n\nThe error $e=u-u_h^L$ satisfies the following relation derived by subtracting the numerical scheme from the weak form of the PDE and testing with $v_h \\in V_h$:\n$$\n(e_t, v_h) + (e_x, v_{hx}) = ((u_h^L)_t, v_h) - ((u_h^L)_t, v_h)_Q.\n$$\nLet us define the quadrature error functional $E_Q(f, g) = (f,g) - (f,g)_Q$. The error equation becomes:\n$$\n(e_t, v_h) + (e_x, v_{hx}) = E_Q((u_h^L)_t, v_h) = E_Q(u_t, v_h) - E_Q(e_t, v_h).\n$$\nTo estimate $\\|e(T)\\|_{L^2}$ for a fixed time $T>0$, we define the adjoint problem: find $\\phi$ such that\n$$\n-\\phi_t - \\phi_{xx} = 0 \\text{ in } \\Omega \\times (0,T), \\quad \\phi(0,t)=\\phi(1,t)=0, \\quad \\phi(x,T) = e(x,T).\n$$\nThis problem is well-posed and its solution possesses suitable regularity properties. We compute $\\|e(T)\\|_{L^2}^2$ as follows:\n$$\n\\|e(T)\\|_{L^2}^2 = (e(T), e(T)) = (e(T), \\phi(T)).\n$$\nIntegrating by parts in time from $0$ to $T$ and using the adjoint PDE:\n$$\n\\|e(T)\\|_{L^2}^2 = (e(0), \\phi(0)) + \\int_0^T \\left( (e_t, \\phi) + (e_x, \\phi_x) \\right) dt.\n$$\nLet $\\phi_h = I_h \\phi$ be the Lagrange interpolant of $\\phi$ in $V_h$. We split $\\phi = (\\phi - \\phi_h) + \\phi_h$ and substitute this into the integral to get:\n$$\n\\|e(T)\\|_{L^2}^2 = (e(0), \\phi(0)) + \\int_0^T \\left( (e_t, \\phi-\\phi_h) + (e_x, \\phi_x-\\phi_{hx}) \\right) dt + \\int_0^T \\left( (e_t, \\phi_h) + (e_x, \\phi_{hx}) \\right) dt.\n$$\nUsing the error equation $(e_t, \\phi_h) + (e_x, \\phi_{hx}) = E_Q(u_t, \\phi_h) - E_Q(e_t, \\phi_h)$, we have:\n$$\n\\|e(T)\\|_{L^2}^2 = (e(0), \\phi(0)) + \\int_0^T \\left( (e_t, \\phi-\\phi_h) + (e_x, \\phi_x-\\phi_{hx}) \\right) dt + \\int_0^T E_Q(u_t, \\phi_h) dt - \\int_0^T E_Q(e_t, \\phi_h) dt.\n$$\nWe now bound each term.\n1.  **Initial Error**: $e(0)=u(0)-u_h^L(0)=u(0)-I_h u(0)=-\\eta(0)$. This term is bounded by $O(h^3) \\|e(T)\\|_{L^2}$.\n\n2.  **Interpolation Error Terms**: The terms involving $\\phi-\\phi_h$ are standard in duality arguments and can be bounded by $O(h^3) \\|e(T)\\|_{L^2}$ as well.\n\n3.  **Quadrature Error on Error**: The term $\\int_0^T E_Q(e_t, \\phi_h) dt$ involves the error itself and can be shown to be of higher order and does not dominate.\n\n4.  **Dominant Consistency Error Term**: The crucial term is the one induced by applying the inexact quadrature to the exact solution's time derivative:\n    $$\n    \\mathcal{E}_{Q} = \\int_0^T E_Q(u_t, \\phi_h) dt = \\int_0^T \\left( (u_t, \\phi_h) - (u_t, \\phi_h)_Q \\right) dt.\n    $$\n    To analyze this term, let $g(t) = u_t(\\cdot, t)$ and $v_h = \\phi_h(t)$. We need to bound $|(g, v_h) - (g, v_h)_Q|$.\n    The 3-point Gauss-Lobatto quadrature rule has precision 3 (it is exact for polynomials of degree up to 3). For a general smooth function $f$, the error of this quadrature on an element of size $h$ is $O(h^5 \\|f^{(4)}\\|_{L^\\infty})$. The integrand is $f=gv_h$.\n    A standard quadrature error bound is $|(g, v_h) - (g, v_h)_Q| \\le C h^2 \\|g''\\|_{L^2} \\|v_h\\|_{L^2}$. This is a known result for this specific case (P2 elements with nodal quadrature). It arises because the quadrature error functional annihilates polynomials of degree 1.\n    Thus, we have:\n    $$\n    |\\mathcal{E}_Q| \\le \\int_0^T C h^2 \\|u_t''(\\cdot, t)\\|_{L^2} \\|\\phi_h(t)\\|_{L^2} dt.\n    $$\n    Using standard bounds on the interpolant and regularity of the adjoint solution:\n    $$\n    |\\mathcal{E}_Q| \\le C h^2 \\left( \\int_0^T \\|u_{txx}(\\cdot, t)\\|_{L^2} dt \\right) \\sup_{t \\in [0,T]}\\|\\phi(t)\\|_{L^2} \\le C' h^2 \\|e(T)\\|_{L^2}.\n    $$\n    The integral with respect to time is a constant depending on the exact solution $u$, which is smooth.\n\nCombining all bounds:\n$$\n\\|e(T)\\|_{L^2}^2 \\le C_1 h^3 \\|e(T)\\|_{L^2} + C_2 h^2 \\|e(T)\\|_{L^2} + \\text{higher order terms}.\n$$\nDividing by $\\|e(T)\\|_{L^2}$ (assuming $\\|e(T)\\|_{L^2} \\ne 0$):\n$$\n\\|e(T)\\|_{L^2} \\le C_1 h^3 + C_2 h^2 + \\dots\n$$\nFor small $h$, the term $C_2 h^2$ dominates. This term arises directly from the consistency error of the mass-lumping quadrature. Therefore, the overall convergence is limited by this term.\n$$\n\\|u(\\cdot, t) - u_h^L(\\cdot, t)\\|_{L^2} \\le C h^2.\n$$\nThe largest integer $p$ for which this inequality holds is $2$. This is a degradation from the expected $O(h^{k+1})=O(h^3)$ convergence for the consistent mass matrix method.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "Moving from theory to practice, the final and most critical step is ensuring your code is correct. A solver with subtle bugs can produce plausible but wrong results, making verification an indispensable part of scientific computing. This comprehensive practice  challenges you to build a complete FEM solver for the heat equation and then verify it using the Method of Manufactured Solutions (MMS), a cornerstone of modern code verification. By engineering a problem with a known solution, you can rigorously test whether your implementation achieves the theoretically predicted convergence rate, thereby building confidence in its correctness for solving real-world problems.",
            "id": "3442012",
            "problem": "Design and implement a program that verifies a semi-discrete Finite Element Method (FEM) for a parabolic Partial Differential Equation (PDE) using the method of manufactured solutions. Work in one space dimension on the open interval $\\left(0, 1\\right)$ and on the time interval $\\left(0, T\\right]$. Consider the linear heat equation with a source term\n$$\nu_t - \\left(k\\, u_x\\right)_x = s \\quad \\text{in } \\left(0, 1\\right)\\times\\left(0, T\\right],\n$$\nwith homogeneous Dirichlet boundary conditions\n$$\nu\\left(0, t\\right) = 0,\\quad u\\left(1, t\\right) = 0 \\quad \\text{for } t \\in \\left[0, T\\right],\n$$\nand initial condition\n$$\nu\\left(x, 0\\right) = u_0\\left(x\\right) \\quad \\text{for } x \\in \\left[0, 1\\right].\n$$\nSet the diffusion coefficient to the constant $k\\left(x\\right) = 1$. Use a Galerkin semi-discretization in space with continuous, piecewise linear basis functions on a uniform mesh with $N$ intervals, leading to a system of ordinary differential equations in time. Denote the piecewise linear basis by $\\left\\{\\varphi_i\\right\\}_{i=0}^{N}$ associated with the nodes $x_i = i\\,h$, where $h = 1/N$ and $i \\in \\left\\{0, 1, \\dots, N\\right\\}$. The semi-discrete solution is sought in the finite dimensional space $V_h = \\text{span}\\left\\{\\varphi_i\\right\\}_{i=1}^{N-1}$ due to the homogeneous Dirichlet boundary conditions.\n\nStart from the weak form obtained by multiplying the PDE by a test function $v \\in H_0^1\\left(0, 1\\right)$ and integrating over the spatial domain. Derive the method-of-lines semi-discrete system in the matrix form\n$$\nM\\, \\dot{\\mathbf{U}}\\left(t\\right) + K\\, \\mathbf{U}\\left(t\\right) = \\mathbf{F}\\left(t\\right),\n$$\nwhere $M$ is the mass matrix with entries $M_{ij} = \\int_0^1 \\varphi_i \\varphi_j \\, dx$, $K$ is the stiffness matrix with entries $K_{ij} = \\int_0^1 \\varphi_i' \\varphi_j' \\, dx$, $\\mathbf{U}\\left(t\\right)$ collects the nodal values of the semi-discrete solution at the interior nodes, and $\\mathbf{F}\\left(t\\right)$ is the load vector with entries $F_i\\left(t\\right) = \\int_0^1 s\\left(x, t\\right)\\, \\varphi_i\\left(x\\right)\\, dx$. Do not use mass lumping. Use the exact, consistent mass matrix.\n\nVerification by manufactured solutions. For each manufactured exact solution below, define the corresponding source $s\\left(x, t\\right)$ by substituting the exact solution into the PDE with $k\\left(x\\right) = 1$ and rearranging. Use the exact initial condition $u_0\\left(x\\right) = u\\left(x, 0\\right)$ and impose homogeneous Dirichlet boundary conditions $u\\left(0, t\\right) = u\\left(1, t\\right) = 0$. The manufactured exact solutions are:\n- Manufactured A: $u_A\\left(x, t\\right) = \\sin\\left(\\pi x\\right)\\, e^{-t}$.\n- Manufactured B: $u_B\\left(x, t\\right) = x\\left(1-x\\right) \\cos\\left(2 t\\right)$.\n\nYour program must:\n- Assemble $M$ and $K$ from first principles based on the bilinear forms stated above on the uniform mesh with $N$ intervals.\n- Construct $\\mathbf{F}\\left(t\\right)$ for each $t$ by numerically integrating the given $s\\left(x, t\\right)$ against basis functions using a Gaussian quadrature rule sufficiently accurate to make the spatial discretization error dominant over the quadrature error.\n- Eliminate the boundary degrees of freedom to enforce the homogeneous Dirichlet boundary conditions strongly, yielding the system for the interior unknowns.\n- Evolve the semi-discrete system in time from $t = 0$ to $t = T$ using an implicit, variable-step ordinary differential equation (ODE) solver from the scientific computing library, with relative tolerance $10^{-10}$ and absolute tolerance $10^{-12}$, so that temporal error is negligible compared to spatial error. Use the nodal interpolation of the exact initial condition on the interior nodes as the initial vector for the ODE.\n- At the final time $T$, compute the $L^2\\left(0, 1\\right)$-norm of the error between the exact solution $u\\left(\\cdot, T\\right)$ and the semi-discrete finite element solution $u_h\\left(\\cdot, T\\right)$:\n$$\n\\left\\|u\\left(\\cdot, T\\right) - u_h\\left(\\cdot, T\\right)\\right\\|_{L^2\\left(0, 1\\right)} = \\left(\\int_0^1 \\left(u\\left(x, T\\right) - u_h\\left(x, T\\right)\\right)^2 dx\\right)^{1/2}.\n$$\nUse Gaussian quadrature with enough points to ensure that the quadrature error is negligible relative to the finite element discretization error.\n\nTest suite. Your program must compute the above $L^2$-error for the following four test cases. Each test case is characterized by a pair $\\left(N, T\\right)$ together with the manufactured solution to use. There is no user input.\n\n- Test $1$ (happy path, moderate refinement): $N = 16$, $T = 0.1$, Manufactured A.\n- Test $2$ (refinement study): $N = 32$, $T = 0.1$, Manufactured A.\n- Test $3$ (different temporal behavior): $N = 16$, $T = 0.25$, Manufactured B.\n- Test $4$ (edge, very coarse mesh): $N = 2$, $T = 0.05$, Manufactured A.\n\nOutput specification. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the entries ordered as $\\left[\\text{error of Test }1,\\text{error of Test }2,\\text{error of Test }3,\\text{error of Test }4\\right]$. Each error must be output as a floating-point number. For example, the format must be exactly like\n$$\n\\left[\\text{float}_1,\\text{float}_2,\\text{float}_3,\\text{float}_4\\right].\n$$\n\nAngle units and physical units. There are no physical units in this problem. All angles in trigonometric functions are in radians.\n\nYour implementation must be a complete, runnable program in the specified language and environment and must strictly adhere to the output format.",
            "solution": "The user-provided problem is valid and represents a standard verification exercise for a Finite Element Method (FEM) implementation. The problem is scientifically grounded in numerical analysis for partial differential equations (PDEs), well-posed, objective, and provides a complete and consistent setup for a computational solution. We proceed with the derivation and implementation.\n\nThe core of the problem is to solve the one-dimensional heat equation, a parabolic PDE, using a semi-discretization approach. This method discretizes the spatial domain first, converting the PDE into a system of ordinary differential equations (ODEs) in time, which is then solved using a numerical ODE integrator.\n\n**1. Weak Formulation**\n\nThe given PDE is the linear heat equation with a source term $s(x,t)$, a constant diffusion coefficient $k=1$, and homogeneous Dirichlet boundary conditions:\n$$\nu_t - u_{xx} = s(x,t) \\quad \\text{for } x \\in (0, 1), t \\in (0, T]\n$$\n$$\nu(0, t) = u(1, t) = 0\n$$\n$$\nu(x, 0) = u_0(x)\n$$\nTo derive the weak formulation, we multiply the PDE by a test function $v(x)$ from an appropriate function space, in this case the Sobolev space $H_0^1(0, 1)$ which consists of functions that are square-integrable, have square-integrable weak derivatives, and are zero at the boundaries $x=0$ and $x=1$. Integrating over the spatial domain $\\Omega = (0, 1)$ gives:\n$$\n\\int_0^1 u_t v \\, dx - \\int_0^1 u_{xx} v \\, dx = \\int_0^1 s v \\, dx\n$$\nApplying integration by parts to the second term and using the fact that $v(0) = v(1) = 0$ yields:\n$$\n-\\int_0^1 u_{xx} v \\, dx = -[u_x v]_0^1 + \\int_0^1 u_x v_x \\, dx = \\int_0^1 u_x v_x \\, dx\n$$\nSubstituting this back, we obtain the weak form: Find $u(\\cdot, t) \\in H_0^1(0, 1)$ for $t  0$ such that for all $v \\in H_0^1(0, 1)$:\n$$\n\\int_0^1 u_t v \\, dx + \\int_0^1 u_x v_x \\, dx = \\int_0^1 s v \\, dx\n$$\nThe time derivative can be moved outside the integral, leading to the final form used for semi-discretization:\n$$\n\\frac{d}{dt} \\int_0^1 u v \\, dx + \\int_0^1 u_x v_x \\, dx = \\int_0^1 s v \\, dx\n$$\n\n**2. Galerkin Semi-Discretization**\n\nWe approximate the solution $u(x,t)$ in a finite-dimensional subspace $V_h \\subset H_0^1(0, 1)$. The domain $(0, 1)$ is partitioned into $N$ uniform intervals of length $h=1/N$. The nodes are $x_i = i h$ for $i=0, \\dots, N$. We use continuous, piecewise linear basis functions (\"hat\" functions) $\\varphi_i(x)$, where $\\varphi_i(x_j) = \\delta_{ij}$ (the Kronecker delta). Since the boundary conditions are homogeneous Dirichlet, the basis functions associated with the boundary nodes, $\\varphi_0$ and $\\varphi_N$, are excluded from the solution space. Thus, $V_h = \\text{span}\\{\\varphi_i\\}_{i=1}^{N-1}$.\n\nThe approximate solution $u_h(x,t)$ is written as a linear combination of these basis functions with time-dependent coefficients:\n$$\nu_h(x,t) = \\sum_{j=1}^{N-1} U_j(t) \\varphi_j(x)\n$$\nIn the Galerkin method, the test functions are chosen from the same space as the basis functions, i.e., $v = \\varphi_i(x)$ for $i=1, \\dots, N-1$. Substituting $u_h$ and $v=\\varphi_i$ into the weak form gives a system of $N-1$ ODEs:\n$$\n\\sum_{j=1}^{N-1} \\left( \\int_0^1 \\varphi_i \\varphi_j \\, dx \\right) \\frac{d U_j}{dt} + \\sum_{j=1}^{N-1} \\left( \\int_0^1 \\varphi_i' \\varphi_j' \\, dx \\right) U_j(t) = \\int_0^1 s(x,t) \\varphi_i(x) \\, dx\n$$\nThis is the method-of-lines system, which can be expressed in matrix form as:\n$$\nM \\mathbf{\\dot{U}}(t) + K \\mathbf{U}(t) = \\mathbf{F}(t)\n$$\nwhere $\\mathbf{U}(t) = [U_1(t), \\dots, U_{N-1}(t)]^T$ is the vector of unknown nodal values at the interior nodes. The matrices $M$ (mass matrix) and $K$ (stiffness matrix), and the vector $\\mathbf{F}(t)$ (load vector) have entries defined as:\n- $M_{ij} = \\int_0^1 \\varphi_i \\varphi_j \\, dx$\n- $K_{ij} = \\int_0^1 \\varphi_i' \\varphi_j' \\, dx$\n- $F_i(t) = \\int_0^1 s(x,t) \\varphi_i(x) \\, dx$\n(with indices $i, j$ running from $1$ to $N-1$).\n\n**3. Matrix Assembly**\n\nThe entries of $M$ and $K$ are non-zero only if the supports of $\\varphi_i$ and $\\varphi_j$ overlap, which for hat functions occurs only for $|i-j| \\le 1$. Direct integration yields the well-known tridiagonal structures for a uniform mesh of step size $h$:\n- Mass matrix element on an interval $[x_k, x_{k+1}]$: $\\frac{h}{6}\\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}$. Assembling for the interior nodes gives the $(N-1) \\times (N-1)$ matrix:\n$$\nM = \\frac{h}{6} \\begin{pmatrix} 4  1  0  \\dots \\\\ 1  4  1  \\dots \\\\  \\ddots  \\ddots  \\ddots \\\\ \\dots  0  1  4 \\end{pmatrix}\n$$\n- Stiffness matrix element on an interval $[x_k, x_{k+1}]$: $\\frac{1}{h}\\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$. Assembling gives the $(N-1) \\times (N-1)$ matrix:\n$$\nK = \\frac{1}{h} \\begin{pmatrix} 2  -1  0  \\dots \\\\ -1  2  -1  \\dots \\\\  \\ddots  \\ddots  \\ddots \\\\ \\dots  0  -1  2 \\end{pmatrix}\n$$\n\n**4. Method of Manufactured Solutions**\n\nTo verify the implementation, we use manufactured solutions. We prescribe a smooth function $u(x,t)$ that satisfies the boundary conditions, and then derive the source term $s(x,t)$ by substituting $u(x,t)$ into the PDE operator: $s = u_t - u_{xx}$.\n- **Solution A**: $u_A(x,t) = \\sin(\\pi x) e^{-t}$.\n$s_A(x,t) = \\frac{\\partial u_A}{\\partial t} - \\frac{\\partial^2 u_A}{\\partial x^2} = -\\sin(\\pi x)e^{-t} - (-\\pi^2 \\sin(\\pi x)e^{-t}) = (\\pi^2-1)\\sin(\\pi x)e^{-t}$.\n- **Solution B**: $u_B(x,t) = x(1-x) \\cos(2t)$.\n$s_B(x,t) = \\frac{\\partial u_B}{\\partial t} - \\frac{\\partial^2 u_B}{\\partial x^2} = -2x(1-x)\\sin(2t) - (-2\\cos(2t)) = 2\\cos(2t) - 2x(1-x)\\sin(2t)$.\nThe initial condition for the ODE system is the nodal projection of the exact solution at $t=0$, i.e., $U_j(0) = u(x_j, 0)$.\n\n**5. Numerical Implementation**\n\n- **Load Vector and Error Calculation**: The integrals for the load vector $\\mathbf{F}(t)$ and the final $L^2$ error norm are computed numerically. We use Gaussian quadrature on each element. A high-order rule (e.g., $5$-point) is chosen to ensure that the quadrature error is negligible compared to the spatial discretization error, which is $O(h^2)$ for linear elements.\n- **Time Integration**: The ODE system is rearranged to $\\mathbf{\\dot{U}}(t) = M^{-1}(\\mathbf{F}(t) - K \\mathbf{U}(t))$. This is a stiff system, so an implicit, high-order, adaptive time-stepping method is required. We use the `Radau` solver provided by `scipy.integrate.solve_ivp` with very strict tolerances ($rtol=10^{-10}$, $atol=10^{-12}$) to make the temporal error insignificant. The mass matrix $M$ is constant, so its LU-factorization is computed once and reused for efficient solving of the linear system $M\\mathbf{y} = \\mathbf{b}$ at each evaluation of the ODE's right-hand side.\n- **$L^2$-Error Norm**: At the final time $T$, the error is computed as $\\|e(\\cdot,T)\\|_{L^2} = \\left(\\int_0^1 (u(x,T) - u_h(x,T))^2 dx\\right)^{1/2}$. The integral is computed as a sum of integrals over each element, each evaluated using Gaussian quadrature:\n$$\n\\|e(\\cdot,T)\\|_{L^2}^2 = \\sum_{k=0}^{N-1} \\int_{x_k}^{x_{k+1}} (u(x,T) - u_h(x,T))^2 dx\n$$\n\nThe implementation encapsulates this entire procedure, running it for each of the four specified test cases and reporting the computed $L^2$ error.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.linalg import lu_factor, lu_solve\n# numpy.polynomial is part of numpy.\nfrom numpy.polynomial.legendre import leggauss\n\n# Manufactured solution A\ndef u_A(x, t):\n    \"\"\"Manufactured solution A: u(x,t) = sin(pi*x) * exp(-t)\"\"\"\n    return np.sin(np.pi * x) * np.exp(-t)\n\ndef s_A(x, t):\n    \"\"\"Source term corresponding to manufactured solution A.\"\"\"\n    return (np.pi**2 - 1) * np.sin(np.pi * x) * np.exp(-t)\n\n# Manufactured solution B\ndef u_B(x, t):\n    \"\"\"Manufactured solution B: u(x,t) = x(1-x)cos(2t)\"\"\"\n    return x * (1 - x) * np.cos(2 * t)\n\ndef s_B(x, t):\n    \"\"\"Source term corresponding to manufactured solution B.\"\"\"\n    return 2 * np.cos(2 * t) - 2 * x * (1 - x) * np.sin(2 * t)\n\ndef run_case(N, T, u_exact, s_func):\n    \"\"\"\n    Solves the heat equation for a single test case using FEM.\n\n    Args:\n        N (int): Number of spatial intervals.\n        T (float): Final time.\n        u_exact (callable): Function for the exact solution u(x,t).\n        s_func (callable): Function for the source term s(x,t).\n\n    Returns:\n        float: The L2 error at the final time T.\n    \"\"\"\n    h = 1.0 / N\n    x_nodes = np.linspace(0, 1, N + 1)\n    num_interior_nodes = N - 1\n\n    # Assemble Mass (M) and Stiffness (K) matrices for interior nodes\n    diag_M = np.full(num_interior_nodes, 4.0 * h / 6.0)\n    offdiag_M = np.full(num_interior_nodes - 1, h / 6.0)\n    M = np.diag(diag_M) + np.diag(offdiag_M, k=1) + np.diag(offdiag_M, k=-1)\n\n    diag_K = np.full(num_interior_nodes, 2.0 / h)\n    offdiag_K = np.full(num_interior_nodes - 1, -1.0 / h)\n    K = np.diag(diag_K) + np.diag(offdiag_K, k=1) + np.diag(offdiag_K, k=-1)\n\n    # Pre-compute LU factorization of M for efficiency\n    M_lu = lu_factor(M)\n\n    # Gaussian quadrature setup (sufficiently high order)\n    num_gauss_points = 5\n    gauss_pts_ref, gauss_wts_ref = leggauss(num_gauss_points)\n\n    def F_vec(t):\n        \"\"\"Computes the load vector F(t) using Gaussian quadrature.\"\"\"\n        f = np.zeros(num_interior_nodes)\n        for j_idx in range(num_interior_nodes):\n            j_node = j_idx + 1  # Node index (1 to N-1)\n\n            # Support of phi_j is [x_{j-1}, x_{j+1}]\n            # Integral over left element [x_{j-1}, x_j]\n            x_L, x_R = x_nodes[j_node - 1], x_nodes[j_node]\n            q_pts = 0.5 * (x_R - x_L) * gauss_pts_ref + 0.5 * (x_R + x_L)\n            q_wts = 0.5 * (x_R - x_L) * gauss_wts_ref\n            phi_j_vals = (q_pts - x_L) / h\n            integral_L = np.sum(q_wts * s_func(q_pts, t) * phi_j_vals)\n            \n            # Integral over right element [x_j, x_{j+1}]\n            x_L, x_R = x_nodes[j_node], x_nodes[j_node + 1]\n            q_pts = 0.5 * (x_R - x_L) * gauss_pts_ref + 0.5 * (x_R + x_L)\n            q_wts = 0.5 * (x_R - x_L) * gauss_wts_ref\n            phi_j_vals = (x_R - q_pts) / h\n            integral_R = np.sum(q_wts * s_func(q_pts, t) * phi_j_vals)\n            \n            f[j_idx] = integral_L + integral_R\n        return f\n\n    def rhs(t, U):\n        \"\"\"Right-hand side of the ODE system dU/dt = M^{-1}(F(t) - K*U).\"\"\"\n        b = F_vec(t) - K @ U\n        return lu_solve(M_lu, b)\n\n    # Nodal interpolation for the initial condition\n    U0 = u_exact(x_nodes[1:-1], 0)\n\n    # Solve the system of ODEs\n    sol = solve_ivp(\n        rhs, (0, T), U0, method='Radau',\n        rtol=1e-10, atol=1e-12, t_eval=[T]\n    )\n    U_final = sol.y[:, -1]\n    \n    # Full solution vector including boundaries\n    U_full = np.concatenate(([0], U_final, [0]))\n\n    # Compute L2 error at final time T\n    total_err_sq = 0.0\n    for i in range(N):  # Loop over elements [x_i, x_{i+1}]\n        x_L, x_R = x_nodes[i], x_nodes[i+1]\n        \n        q_pts = 0.5 * (x_R - x_L) * gauss_pts_ref + 0.5 * (x_R + x_L)\n        q_wts = 0.5 * (x_R - x_L) * gauss_wts_ref\n        \n        u_exact_vals = u_exact(q_pts, T)\n        \n        # On element i, u_h(x) = U_i * phi_i(x) + U_{i+1} * phi_{i+1}(x)\n        phi_i_vals = (x_R - q_pts) / h\n        phi_i_plus_1_vals = (q_pts - x_L) / h\n        u_h_vals = U_full[i] * phi_i_vals + U_full[i+1] * phi_i_plus_1_vals\n        \n        total_err_sq += np.sum(q_wts * (u_exact_vals - u_h_vals)**2)\n    \n    return np.sqrt(total_err_sq)\n\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        {'N': 16, 'T': 0.1, 'u': u_A, 's': s_A},\n        {'N': 32, 'T': 0.1, 'u': u_A, 's': s_A},\n        {'N': 16, 'T': 0.25, 'u': u_B, 's': s_B},\n        {'N': 2, 'T': 0.05, 'u': u_A, 's': s_A}\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_case(case['N'], case['T'], case['u'], case['s'])\n        results.append(error)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}