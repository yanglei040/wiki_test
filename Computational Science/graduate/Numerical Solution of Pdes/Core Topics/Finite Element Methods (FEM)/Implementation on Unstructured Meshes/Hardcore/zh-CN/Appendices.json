{
    "hands_on_practices": [
        {
            "introduction": "有限元方法求解偏微分方程的第一步，是将控制方程离散化为一个大型线性系统。本练习将指导您完成这一核心过程，即为泊松方程推导并实现刚度矩阵的组装。通过这个实践，您将掌握从局部单元贡献到全局稀疏矩阵的映射，这是构建任何有限元程序都必须具备的基础技能。",
            "id": "3406212",
            "problem": "考虑一个在多边形域上的标量泊松问题，该域具有恒定的各向同性扩散系数，并用非结构化三角网格进行离散。其强形式由以下边值问题给出\n$$\n-\\nabla \\cdot (\\nabla u) = f \\quad \\text{in } \\Omega,\\qquad u = 0 \\quad \\text{on } \\partial\\Omega,\n$$\n其中 $\\Omega \\subset \\mathbb{R}^2$ 是一个具有足够正则边界的有界开集。相应的弱（变分）形式为：寻找 $u \\in H_0^1(\\Omega)$，使得对于所有 $v \\in H_0^1(\\Omega)$，\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} f v \\, d\\Omega.\n$$\n给定 $\\Omega$ 的一个协调单纯形网格，并令 $V_h \\subset H_0^1(\\Omega)$ 表示与网格节点相关联的连续分段线性函数（也称为 $P_1$ 拉格朗日基函数）空间。令 $\\{\\varphi_i\\}$ 为全局节点基。离散 Galerkin 方法旨在寻找 $u_h \\in V_h$，使得\n$$\n\\sum_{i,j} \\left( \\int_{\\Omega} \\nabla \\varphi_i \\cdot \\nabla \\varphi_j \\, d\\Omega \\right) U_j \\, \\delta v_i = \\sum_i \\left( \\int_{\\Omega} f \\, \\varphi_i \\, d\\Omega \\right) \\delta v_i,\n$$\n这导出了一个线性系统 $K U = F$，其刚度矩阵项为\n$$\nK_{ij} = \\int_{\\Omega} \\nabla \\varphi_i \\cdot \\nabla \\varphi_j \\, d\\Omega.\n$$\n\n任务 1（局部单元推导）：对于一个顶点坐标为 $(x_1,y_1)$、$(x_2,y_2)$、$(x_3,y_3)$ 的单个三角形 $T$ 以及与这些顶点相关联的局部 $P_1$ 基函数 $\\{\\phi_1,\\phi_2,\\phi_3\\}$，请从第一性原理出发推导出\n$$\nK_T(i,j) = \\int_T \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, dA = |T| \\, \\nabla \\phi_i \\cdot \\nabla \\phi_j,\n$$\n并且梯度在 $T$ 上是常数。使用重心坐标恒等式，证明\n$$\n\\nabla \\phi_i = \\frac{1}{2|T|}\\begin{bmatrix} b_i \\\\ c_i \\end{bmatrix}, \\quad \\text{where } b_i = y_j - y_k, \\; c_i = x_k - x_j, \\; \\text{for a cyclic permutation } (i,j,k) \\text{ of } (1,2,3),\n$$\n并由此获得显式的局部刚度矩阵\n$$\nK_T(i,j) = \\frac{1}{4|T|}\\left(b_i b_j + c_i c_j\\right), \\quad i,j \\in \\{1,2,3\\}.\n$$\n这里 $|T|$ 表示 $T$ 的面积，无论局部顶点的方向如何，都必须取为正值。\n\n任务 2（在非结构化网格上进行全局组装）：设网格由以下方式指定：\n- 一个包含 $N$ 个节点坐标的列表，形式为形状为 $N \\times 2$ 的数组，其中第 $p$ 行包含 $(x_p,y_p)$。\n- 一个包含 $M$ 个三角形的列表，形式为形状为 $M \\times 3$ 的数组，其中第 $e$ 行使用从零开始的索引列出了单元 $e$ 的顶点的全局节点索引 $(g_1,g_2,g_3)$。\n定义一个一致的局部到全局映射，该映射根据连接关系数组将单元 $e$ 的局部索引 $i \\in \\{0,1,2\\}$ 映射到全局索引 $g_i$。通过对局部贡献求和，以压缩稀疏行（CSR）格式组装全局刚度矩阵 $K \\in \\mathbb{R}^{N \\times N}$：\n$$\nK(g_i,g_j) \\mathrel{+}= K_T(i,j) \\quad \\text{for all elements } T \\text{ and all pairs } (i,j) \\in \\{0,1,2\\}^2.\n$$\n确保最终的 CSR 结构中每行的列索引都是排序的。\n\n测试套件和要求输出：实现一个程序，为以下三个独立的测试用例计算全局刚度矩阵。对于每个测试用例，将组装好的全局 CSR 矩阵转换为一个稠密数组，以行主序将其展开，并将每个条目四舍五入到小数点后 $10$ 位。程序必须输出一行内容，该行包含一个列表，其中按测试用例的顺序包含这三个展开后的列表，并且全程使用从零开始的索引。\n\n- 测试用例 A（单个规范直角三角形）：节点 $N_A = 3$，坐标为 $\\big[(0,0),(1,0),(0,1)\\big]$；单元 $M_A = 1$，连接关系为 $\\big[(0,1,2)\\big]$。\n- 测试用例 B（两个三角形构成一个单位正方形）：节点 $N_B = 4$，坐标为 $\\big[(0,0),(1,0),(1,1),(0,1)\\big]$；单元 $M_B = 2$，连接关系为 $\\big[(0,1,3),(1,2,3)\\big]$。\n- 测试用例 C（单个钝角、非轴对齐三角形）：节点 $N_C = 3$，坐标为 $\\big[(0.2,0.3),(1.1,0.4),(0.5,1.2)\\big]$；单元 $M_C = 1$，连接关系为 $\\big[(0,1,2)\\big]$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表恰好包含三个内部列表，每个测试用例一个，每个内部列表是行主序展开的、四舍五入到小数点后 10 位的稠密全局刚度矩阵条目，例如\n$$\n[\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,].\n$$\n此问题不涉及物理单位。不使用角度。在您的实现中，所有数值索引都必须是从零开始的。",
            "solution": "该问题要求为泊松方程的 $P_1$ 三角形有限元推导局部刚度矩阵，并随后实现一个算法来为非结构化三角网格组装全局刚度矩阵。\n\n### 任务 1：局部刚度矩阵的推导\n\n起点是单个三角形单元 $T$ 的局部刚度矩阵 $K_T$ 的条目：\n$$\nK_T(i,j) = \\int_T \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, dA\n$$\n其中 $\\{\\phi_i\\}_{i=1,2,3}$ 是 $T$ 上的局部 $P_1$ 拉格朗日基函数。根据定义，$P_1$ 基函数 $\\phi_i$ 是空间坐标 $(x,y)$ 的线性多项式，形式为 $\\phi_i(x,y) = \\alpha_i + \\beta_i x + \\gamma_i y$。该函数的梯度是一个常向量：\n$$\n\\nabla \\phi_i = \\begin{pmatrix} \\frac{\\partial \\phi_i}{\\partial x} \\\\ \\frac{\\partial \\phi_i}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} \\beta_i \\\\ \\gamma_i \\end{pmatrix}\n$$\n由于梯度 $\\nabla \\phi_i$ 和 $\\nabla \\phi_j$ 在整个单元 $T$ 上是常向量，它们的点积 $\\nabla \\phi_i \\cdot \\nabla \\phi_j$ 是一个常标量。一个常数在某个域上的积分就是该常数乘以该域的测度（面积）。因此，积分简化为：\n$$\nK_T(i,j) = (\\nabla \\phi_i \\cdot \\nabla \\phi_j) \\int_T \\, dA = |T| (\\nabla \\phi_i \\cdot \\nabla \\phi_j)\n$$\n其中 $|T|$ 是三角形 $T$ 的面积。这验证了所需推导的第一部分。\n\n接下来，我们推导梯度的显式公式。基函数 $\\phi_i$ 与三角形顶点 $i$ 关联的重心坐标 $\\lambda_i$ 是相同的。对于 $(1,2,3)$ 的一个循环置换，设 $T$ 的顶点为 $v_i=(x_i, y_i)$、$v_j=(x_j, y_j)$ 和 $v_k=(x_k, y_k)$。点 $P=(x,y)$ 的重心坐标 $\\lambda_i$ 是由点 $P$ 和另外两个顶点形成的子三角形的面积与整个三角形 $T$ 的面积之比。顶点为 $(x_a, y_a)$、$(x_b, y_b)$、$(x_c, y_c)$ 的三角形的有向面积可以用行列式表示：\n$$\n\\text{Area}(v_a, v_b, v_c) = \\frac{1}{2} \\det \\begin{pmatrix} x_a  y_a  1 \\\\ x_b  y_b  1 \\\\ x_c  y_c  1 \\end{pmatrix} = \\frac{1}{2} [x_a(y_b - y_c) + x_b(y_c - y_a) + x_c(y_a - y_b)]\n$$\n$|T|$ 的值是该表达式对单元三个顶点计算结果的绝对值。基函数 $\\phi_i(x,y)$ 为：\n$$\n\\phi_i(x,y) = \\lambda_i(x,y) = \\frac{\\text{Area}(P, v_j, v_k)}{\\text{Area}(v_i, v_j, v_k)} = \\frac{1}{2|T|} [x(y_j - y_k) + y(x_k - x_j) + (x_j y_k - x_k y_j)]\n$$\n通过对 $x$ 和 $y$ 求导，可以找到梯度 $\\nabla \\phi_i$：\n$$\n\\frac{\\partial \\phi_i}{\\partial x} = \\frac{1}{2|T|} (y_j - y_k)\n$$\n$$\n\\frac{\\partial \\phi_i}{\\partial y} = \\frac{1}{2|T|} (x_k - x_j)\n$$\n对于 $(1,2,3)$ 的循环置换 $(i,j,k)$，定义 $b_i = y_j - y_k$ 和 $c_i = x_k - x_j$，我们得到梯度的向量表达式：\n$$\n\\nabla \\phi_i = \\frac{1}{2|T|} \\begin{pmatrix} b_i \\\\ c_i \\end{pmatrix}\n$$\n这证明了所需的梯度公式。\n\n最后，我们将这个梯度表达式代回到 $K_T(i,j)$ 的简化积分中：\n$$\nK_T(i,j) = |T| (\\nabla \\phi_i \\cdot \\nabla \\phi_j) = |T| \\left( \\left( \\frac{1}{2|T|} \\begin{pmatrix} b_i \\\\ c_i \\end{pmatrix} \\right) \\cdot \\left( \\frac{1}{2|T|} \\begin{pmatrix} b_j \\\\ c_j \\end{pmatrix} \\right) \\right)\n$$\n$$\nK_T(i,j) = |T| \\frac{1}{4|T|^2} (b_i b_j + c_i c_j) = \\frac{1}{4|T|} (b_i b_j + c_i c_j)\n$$\n这样就完成了局部刚度矩阵 $K_T$ 条目的显式公式推导。\n\n### 任务 2：全局刚度矩阵组装\n\n全局刚度矩阵 $K$ 是一个 $N \\times N$ 矩阵，其中 $N$ 是网格中节点的总数。它是通过对网格中所有 $M$ 个三角形单元的贡献求和来组装的。组装过程遵循以下规则：\n$$\nK(g_i, g_j) \\mathrel{+}= K_T(i,j)\n$$\n这意味着对于每个单元 $T$，其局部刚度条目 $K_T(i,j)$（连接局部节点 $i$ 和 $j$）被加到全局刚度矩阵条目 $K(g_i, g_j)$ 中，其中 $g_i$ 和 $g_j$ 是与局部索引 $i$ 和 $j$ 对应的全局索引。此映射由网格连接关系数组提供。\n\n一个用于此组装过程的标准且高效的算法是首先以坐标（COO）格式构建矩阵，然后将其转换为压缩稀疏行（CSR）格式。COO 格式使用三个列表：一个用于行索引，一个用于列索引，一个用于相应的值。\n\n该算法如下：\n1.  初始化三个空列表：`coo_data`、`coo_row_indices`、`coo_col_indices`。\n2.  遍历网格中的每个三角形 $T_e$，其中 $e = 0, \\dots, M-1$。\n    a. 从连接关系数组中检索其顶点的全局索引 $(g_0, g_1, g_2)$。\n    b. 从节点坐标数组中检索这些顶点的坐标 $(x_0,y_0)$、$(x_1,y_1)$ 和 $(x_2,y_2)$。\n    c. 使用鞋带公式计算面积 $|T_e|$，并确保其为正值：\n       $$\n       |T_e| = \\frac{1}{2} |x_0(y_1-y_2) + x_1(y_2-y_0) + x_2(y_0-y_1)|\n       $$\n    d. 对于每个局部节点 $i \\in \\{0,1,2\\}$，计算系数 $b_i$ 和 $c_i$。使用从零开始的索引和循环置换 $(i, (i+1)\\%3, (i+2)\\%3)$：\n       $$\n       b_i = y_{(i+1)\\%3} - y_{(i+2)\\%3} \\quad , \\quad c_i = x_{(i+2)\\%3} - x_{(i+1)\\%3}\n       $$\n    e. 使用推导出的公式 $K_{T_e}(i,j) = \\frac{1}{4|T_e|}(b_i b_j + c_i c_j)$ 计算 $3 \\times 3$ 局部刚度矩阵 $K_{T_e}$。\n    f. 对于每个局部条目 $K_{T_e}(i,j)$，其中 $i,j \\in \\{0,1,2\\}$，将全局行索引 $g_i$ 附加到 `coo_row_indices`，全局列索引 $g_j$ 附加到 `coo_col_indices`，并将值 $K_{T_e}(i,j)$ 附加到 `coo_data`。\n3.  遍历完所有单元后，从 COO 列表创建全局 CSR 矩阵。此步骤会自动处理对由多个单元（即共享边或节点）贡献的条目 $(g_i, g_j)$ 的贡献求和。该过程还确保最终 CSR 结构中每行的列索引都是排序的。\n4.  对于最终输出，将此稀疏矩阵转换为稠密的 `numpy` 数组，以行主序展开为一维数组，并将其条目四舍五入到指定的精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix\n\ndef assemble_stiffness_matrix(nodes, triangles):\n    \"\"\"\n    Assembles the global stiffness matrix for a 2D Poisson problem\n    on an unstructured triangular mesh using P1 finite elements.\n\n    Args:\n        nodes (np.ndarray): Array of node coordinates, shape (N, 2).\n        triangles (np.ndarray): Array of triangle connectivity, shape (M, 3),\n                                listing global node indices for each element.\n\n    Returns:\n        list: The flattened, row-major, dense global stiffness matrix,\n              with entries rounded to 10 decimal places.\n    \"\"\"\n    num_nodes = nodes.shape[0]\n    coo_data = []\n    coo_row = []\n    coo_col = []\n\n    for tri_indices in triangles:\n        # 1. Get vertex coordinates using the global indices\n        # tri_indices are the global indices, e.g., [g0, g1, g2]\n        # vertices are the corresponding coordinates\n        v0, v1, v2 = nodes[tri_indices[0]], nodes[tri_indices[1]], nodes[tri_indices[2]]\n\n        # 2. Calculate triangle area |T| (must be positive)\n        area = 0.5 * np.abs(v0[0] * (v1[1] - v2[1]) + v1[0] * (v2[1] - v0[1]) + v2[0] * (v0[1] - v1[1]))\n        \n        # Avoid division by zero for degenerate triangles\n        if area  1e-14:\n            continue\n\n        # 3. Calculate b and c coefficients for local nodes {0,1,2}\n        # b_i = y_j - y_k, c_i = x_k - x_j for cyclic (i,j,k)\n        # For local node 0 (maps to global g0): coords are v0=(x0,y0)\n        # j refers to local node 1, k to local node 2\n        b = np.array([v1[1] - v2[1], v2[1] - v0[1], v0[1] - v1[1]])\n        c = np.array([v2[0] - v1[0], v0[0] - v2[0], v1[0] - v0[0]])\n\n        # 4. Calculate the 3x3 local stiffness matrix K_T\n        # K_T(i,j) = (b_i*b_j + c_i*c_j) / (4*|T|)\n        factor = 1.0 / (4.0 * area)\n        k_local = factor * (np.outer(b, b) + np.outer(c, c))\n\n        # 5. Add local contributions to COO-format lists\n        for i in range(3):\n            for j in range(3):\n                # Map local indices (i,j) to global indices (g_i, g_j)\n                global_row_idx = tri_indices[i]\n                global_col_idx = tri_indices[j]\n                \n                coo_row.append(global_row_idx)\n                coo_col.append(global_col_idx)\n                coo_data.append(k_local[i, j])\n\n    # 6. Create the sparse CSR matrix from the COO data.\n    # Duplicates are automatically summed.\n    k_global_sparse = csr_matrix((coo_data, (coo_row, coo_col)), shape=(num_nodes, num_nodes))\n    \n    # 7. Convert to dense, flatten, round, and convert to list for output\n    k_global_dense = k_global_sparse.toarray()\n    result = np.round(k_global_dense.flatten(), 10).tolist()\n    \n    return result\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"nodes\": np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0]]),\n            \"triangles\": np.array([[0, 1, 2]])\n        },\n        {\n            \"nodes\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"triangles\": np.array([[0, 1, 3], [1, 2, 3]])\n        },\n        {\n            \"nodes\": np.array([[0.2, 0.3], [1.1, 0.4], [0.5, 1.2]]),\n            \"triangles\": np.array([[0, 1, 2]])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        stiffness_flat = assemble_stiffness_matrix(case[\"nodes\"], case[\"triangles\"])\n        all_results.append(stiffness_flat)\n\n    # Final print statement in the exact required format.\n    # The str() of a list in Python produces the desired '[...]' format.\n    # ','.join() then separates these list-strings with commas.\n    # The outer f-string adds the final container brackets.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在许多科学与工程问题中，例如多相流或断裂力学，物理场在不与网格线对齐的界面上会存在间断。本练习旨在解决在被间断界面切割的多边形单元上进行精确数值积分的挑战。通过实现几何裁剪算法和矩拟合积分，您将掌握处理此类复杂几何构型的关键技术，这对于开发高级数值方法（如扩展有限元方法）至关重要。",
            "id": "3406224",
            "problem": "您的任务是为非结构化网格上的多边形单元实现一种稳健的数值积分算法，用于处理不连续函数。目标是比较两种针对不连续界面的几何处理方法，并量化几何近似误差。不连续性由一个标量场的零水平集所表示的光滑隐式曲线来定义，并且分段函数在界面的两侧均为线性函数。\n\n考虑一个多边形单元 $P \\subset \\mathbb{R}^2$，其顶点按逆时針顺序排列。定义一个水平集场 $\\phi:\\mathbb{R}^2\\to\\mathbb{R}$ 如下：\n$$\n\\phi(x,y) = (x - c_x)^2 + (y - c_y)^2 - R^2,\n$$\n其中 $(c_x,c_y)\\in\\mathbb{R}^2$ 是圆心， $R0$ 是半径。不连续界面为 $\\{\\phi=0\\}$，它将内部区域 $\\{\\phi  0\\}$ (圆盘) 与外部区域 $\\{\\phi  0\\}$ (其补集) 分開。\n\n设目标被积函数为不连续函数\n$$\nf(x,y) = H(\\phi(x,y))\\,f_+(x,y) + \\left(1 - H(\\phi(x,y))\\right)\\,f_-(x,y),\n$$\n其中 $H$ 是亥维赛阶跃函数，$f_+$ 和 $f_-$ 是线性函数：\n$$\nf_+(x,y) = \\alpha_0 + \\alpha_1 x + \\alpha_2 y,\\qquad f_-(x,y) = \\beta_0 + \\beta_1 x + \\beta_2 y,\n$$\n其中系数 $\\alpha_0,\\alpha_1,\\alpha_2$ 和 $\\beta_0,\\beta_1,\\beta_2$ 均为实数。\n\n您的程序必须为每个给定的多边形单元和水平集参数 $(c_x,c_y,R)$ 计算因在单元内用直线段（弦）近似弯曲界面 $\\{\\phi=0\\}$ 而引入的绝对误差。具体来说，基于以下方法计算积分的两种近似值：\n$$\nI = \\int_P f(x,y)\\,dA,\n$$\n\n- 通过凸多边形裁剪和矩公式的高精度参考方法：\n  - 观察以下恒等式\n    $$\n    I = \\int_P f_+(x,y)\\,dA + \\int_{P \\cap \\{\\phi  0\\}} \\left( f_-(x,y) - f_+(x,y) \\right)\\,dA.\n    $$\n  - 用一个中心在 $(c_x,c_y)$、半径为 $R$、有 $N$ 个顶点的正 $N$ 边形来近似圆盘 $\\{\\phi  0\\}$，其中 $N$ 很大 (例如, $N=2048$)，从而形成一个顶点按逆时针顺序排列的凸多边形 $C_N$。\n  - 使用稳健的凸多边形裁剪算法计算凸多边形交集 $R_{\\text{ref}} = P \\cap C_N$。\n  - 使用由格林公式推导出的基于面积和质心的矩公式，来计算线性函数在 $P$ 和 $R_{\\text{ref}}$ 上的积分。积分时使用正面积测度。\n\n- 通过局部弦的几何近似方法：\n  - 如果根据 $P$ 顶点处 $\\phi$ 值的符号， $P$ 完全位于界面的某一側，则进行相应分类，并将内部区域设为 $P$ 或空集。\n  - 否则，找出圆 $\\{\\phi=0\\}$ 与 $P$ 的所有边的交点。如果至少存在两个不同的交点，则选择欧几里得距离最大的那对交点，并将连接这对点的直线段定义为弦。定义一个半平面，其边界为该弦且包含圆心 $(c_x,c_y)$。\n  - 将 $P$ 用此半平面进行裁剪，得到的多边形即为 $R_{\\text{chord}}$。\n  - 使用相同的矩公式计算在 $P$ 和 $R_{\\text{chord}}$ 上的积分：\n    $$\n    I_{\\text{chord}} = \\int_P f_+(x,y)\\,dA + \\int_{R_{\\text{chord}}} \\left( f_-(x,y) - f_+(x,y) \\right)\\,dA.\n    $$\n\n将几何近似误差定义为\n$$\nE = \\left| I_{\\text{chord}} - I_{\\text{ref}} \\right|.\n$$\n\n您必须用来设计算法并论证每个步骤的基础理论：\n- 使用亥维赛阶跃函数和内部区域 $\\{\\phi  0\\}$ 得到的积分 $I$ 的分解恒等式。\n- 格林公式和多边形矩公式，它们确立了任意线性函数 $g(x,y)=\\gamma_0+\\gamma_1 x+\\gamma_2 y$ 在一个面积为 $A$、质心为 $(\\bar{x},\\bar{y})$ 的多边形上的积分等于\n  $$\n  \\int_{\\text{polygon}} g(x,y)\\,dA = A\\left(\\gamma_0 + \\gamma_1 \\bar{x} + \\gamma_2 \\bar{y}\\right).\n  $$\n- 用于凸裁剪多边形和半平面的稳健多边形裁剪算法。\n\n请为以下测试套件实现上述算法。所有坐标和参数均为实数，无物理单位。如果在内部使用了角度，单位为弧度。每个测试用例提供：\n- 多边形顶点（逆时針順序）。\n- 圆的参数 $(c_x,c_y,R)$。\n- 系数 $(\\alpha_0,\\alpha_1,\\alpha_2)$ 和 $(\\beta_0,\\beta_1,\\beta_2)$。\n\n所有测试用例使用相同的系数：\n- $f_+$ 系数： $\\alpha_0 = 1.2$, $\\alpha_1 = -0.7$, $\\alpha_2 = 0.3$。\n- $f_-$ 系数： $\\beta_0 = -0.5$, $\\beta_1 = 0.4$, $\\beta_2 = 0.9$。\n\n在参考计算中，使用具有 $N=2048$ 个顶点的正多边形来近似圆盘 $\\{\\phi  0\\}$。\n\n多边形和水平集参数的测试套件：\n- 测试用例 1 (理想情况，凸四边形被界面切割)：多边形 $P_1$ 顶点为 $(-0.1,-0.05)$, $(0.6,0.1)$, $(0.45,0.5)$, $(-0.2,0.35)$；圆心 $(0,0)$，半径 $R=0.5$。\n- 测试用例 2 (完全位于内部)：多边形 $P_2$ 为三角形，顶点为 $(0.1,0.0)$, $(0.2,0.05)$, $(0.05,0.15)$；圆心 $(0,0)$，半径 $R=1.0$。\n- 测试用例 3 (完全位于外部)：多边形 $P_3$ 为三角形，顶点为 $(0.8,0.8)$, $(0.9,0.7)$, $(0.7,0.9)$；圆心 $(0,0)$，半径 $R=0.5$。\n- 测试用例 4 (相切边界情况)：多边形 $P_4$ 为四边形，顶点为 $(-0.1,0.5)$, $(0.1,0.5)$, $(0.1,0.7)$, $(-0.1,0.7)$；圆心 $(0,0)$，半径 $R=0.5$。\n\n程序要求：\n- 精确地按描述实现算法。\n- 对于每个测试用例，计算绝对几何近似误差 $E$，结果为一个浮点数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为各测试用例的结果，顺序与测试用例一致，每个数字四舍五入到 $8$ 位小数，例如，$\\left[\\dots\\right]$。\n\n不提供外部输入；所有数据都嵌入在程序中。答案只需要无量纲的浮点值，并且必须严格按照指定格式作为单行打印输出。",
            "solution": "用户提供的问题经评估为 **有效**。这是一个数值分析和计算几何领域的适定问题，具体涉及非结构化网格上不连续函数的数值积分，这一主题与扩展有限元法 (XFEM) 等方法相关。所有数据、定义和所需算法都得到了完整且一致的说明，并为最终结果提供了清晰客观的衡量标准。该问题在科学上基于已建立的数学原理，如格林公式和多边形裁剪算法。\n\n解决方案的步骤是，首先实现两种指定的方法来近似计算不连续函数在多边形单元上的积分，然后计算它们结果之间的绝对差。\n\n不连续的被积函数由下式给出\n$$\nf(x,y) = H(\\phi(x,y))\\,f_+(x,y) + \\left(1 - H(\\phi(x,y))\\right)\\,f_-(x,y)\n$$\n其中 $\\phi(x,y) = (x - c_x)^2 + (y - c_y)^2 - R^2$ 是定义圆形接口的水平集函数，$H$ 是亥维赛阶跃函数，$f_+$ 和 $f_-$ 是线性函数。需要计算的积分是 $I = \\int_P f(x,y)\\,dA$，积分区域为多边形 $P$。\n\n一个关键步骤是分解该积分。$1 - H(\\phi) = 1$ 的区域是圆的内部 $\\{\\phi  0\\}$，$H(\\phi) = 1$ 的区域是外部 $\\{\\phi > 0\\}$。该积分可以重写为：\n$$\nI = \\int_P \\left( H(\\phi)f_+ + (1-H(\\phi))f_- \\right) dA = \\int_P f_+ dA + \\int_P (1-H(\\phi))(f_- - f_+) dA\n$$\n项 $(1-H(\\phi))$ 充当区域 $\\{\\phi  0\\}$ 的指示函数。因此，令 $g(x,y) = f_-(x,y) - f_+(x,y)$，积分变为：\n$$\nI = \\int_P f_+(x,y) \\,dA + \\int_{P \\cap \\{\\phi  0\\}} g(x,y) \\,dA\n$$\n由于 $f_+$ 和 $f_-$ 是线性的，它们的差 $g$ 也是一个线性函数。因此，问题简化为在多边形上对线性函数进行积分。根据格林公式，线性函数 $\\gamma(x,y) = \\gamma_0 + \\gamma_1 x + \\gamma_2 y$ 在一个面积为 $A$、质心为 $(\\bar{x}, \\bar{y})$ 的多边形 $\\mathcal{P}$ 上的积分由下式给出：\n$$\n\\int_{\\mathcal{P}} \\gamma(x,y) \\,dA = A \\cdot \\gamma(\\bar{x}, \\bar{y}) = A(\\gamma_0 + \\gamma_1 \\bar{x} + \\gamma_2 \\bar{y})\n$$\n为了实现这一点，我们需要一个稳健的方法来计算任意简单多边形的面积和质心。对于一个顶点按顺序为 $(x_0, y_0), (x_1, y_1), \\dots, (x_{n-1}, y_{n-1})$ 的多边形，其有向面积 $A$ 和质心 $(\\bar{x}, \\bar{y})$ 计算如下：\n$$\nA = \\frac{1}{2} \\sum_{i=0}^{n-1} (x_i y_{i+1} - x_{i+1} y_i)\n$$\n$$\n\\bar{x} = \\frac{1}{6A} \\sum_{i=0}^{n-1} (x_i + x_{i+1})(x_i y_{i+1} - x_{i+1} y_i)\n$$\n$$\n\\bar{y} = \\frac{1}{6A} \\sum_{i=0}^{n-1} (y_i + y_{i+1})(x_i y_{i+1} - x_{i+1} y_i)\n$$\n其中 $(x_n, y_n) = (x_0, y_0)$。问题要求使用正面积测度，所以我们使用 $|A|$。\n\n积分的两种近似值 $I_{\\text{ref}}$ 和 $I_{\\text{chord}}$ 的区别在于它们如何近似第二项的积分区域 $P_{\\text{in}} = P \\cap \\{\\phi  0\\}$。\n\n1.  **参考计算 ($I_{\\text{ref}}$)**：圆形区域 $\\{\\phi  0\\}$ 由一个具有 $N=2048$ 个顶点的高分辨率正 $N$ 边形 $C_N$ 来近似。积分域则为 $R_{\\text{ref}} = P \\cap C_N$。这个两个凸多边形的交集（因为测试用例中的 $P$ 是凸的，$C_N$ 也是凸的）是使用 Sutherland-Hodgman 算法计算的，该算法用一个凸裁剪多边形的边来裁剪一个被裁多边形。积分则为 $I_{\\text{ref}} = \\int_P f_+ dA + \\int_{R_{\\text{ref}}} g\\,dA$。\n\n2.  **弦近似 ($I_{\\text{chord}}$)**：此方法简化了单元 $P$ 内的弯曲界面。\n    - 首先，如果 $P$ 的所有顶点的 $\\phi$ 值符号相同，则该单元被分类为完全位于内部 ($\\phi \\le 0$) 或外部 ($\\phi \\ge 0$)。在这种情况下，$R_{\\text{chord}}$ 分别被设为 $P$ 或空集。\n    - 否则，该单元被切割。通过对每条边求解一个二次方程来计算圆 $\\{\\phi=0\\}$ 与 $P$ 的边的交点。\n    - 从不同的交点集合中，欧几里得距离最大的那对点定义了一条弦。这条弦将平面划分为两个半平面。\n    - 正确的半平面是包含圆心 $(c_x, c_y)$ 的那个。\n    - $R_{\\text{chord}}$ 是将 $P$ 对此半平面进行裁剪的结果。这个裁剪过程是 Sutherland-Hodgman 算法的一次传递。\n    - 积分为 $I_{\\text{chord}} = \\int_P f_+ dA + \\int_{R_{\\text{chord}}} g\\,dA$。\n\n几何近似误差是绝对差 $E = |I_{\\text{chord}} - I_{\\text{ref}}|$。该实现将这些几何和积分基元封装到一个工作流中，为每个测试用例处理并计算此误差。对于多边形完全位于界面一侧的情况，两种方法产生相同（精确）的结果，导致误差为零。只有当单元被切割且弦是圆弧的非精确近似时，误差才不为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the computation for all test cases.\n    It calculates the geometric approximation error E for each case and prints the results.\n    \"\"\"\n    \n    # --- Global Constants and Coefficients ---\n    \n    # Coefficients for the linear functions f_+(x,y) and f_-(x,y)\n    # f_+(x,y) = alpha_0 + alpha_1*x + alpha_2*y\n    ALPHA_COEFFS = np.array([1.2, -0.7, 0.3])\n    # f_-(x,y) = beta_0 + beta_1*x + beta_2*y\n    BETA_COEFFS = np.array([-0.5, 0.4, 0.9])\n    \n    # Coefficients for the difference function g(x,y) = f_-(x,y) - f_+(x,y)\n    GAMMA_COEFFS = BETA_COEFFS - ALPHA_COEFFS\n    \n    # Number of vertices for the regular polygon approximation of the circle\n    N_REF = 2048\n    \n    # Tolerance for floating-point comparisons\n    TOL = 1e-12\n\n    # --- Geometric and Integration Helper Functions ---\n\n    def poly_area_centroid(poly_verts):\n        \"\"\"\n        Computes the signed area and centroid of a non-self-intersecting polygon\n        using the shoelace formula. Vertices are assumed to be in order.\n        \"\"\"\n        if poly_verts.shape[0]  3:\n            return 0.0, np.array([0.0, 0.0])\n\n        x = poly_verts[:, 0]\n        y = poly_verts[:, 1]\n        \n        x_plus_1 = np.roll(x, -1)\n        y_plus_1 = np.roll(y, -1)\n        \n        cross_prod_terms = x * y_plus_1 - x_plus_1 * y\n        signed_area = 0.5 * np.sum(cross_prod_terms)\n\n        if abs(signed_area)  TOL:\n            return 0.0, np.mean(poly_verts, axis=0)\n\n        cx = (1 / (6 * signed_area)) * np.sum((x + x_plus_1) * cross_prod_terms)\n        cy = (1 / (6 * signed_area)) * np.sum((y + y_plus_1) * cross_prod_terms)\n        \n        return signed_area, np.array([cx, cy])\n\n    def integrate_linear_over_poly(poly_verts, coeffs):\n        \"\"\"\n        Integrates a linear function g(x,y) over a polygon using the formula:\n        Integral(g) = Area(poly) * g(centroid(poly)).\n        \"\"\"\n        if poly_verts.shape[0]  3:\n            return 0.0\n        \n        signed_area, centroid = poly_area_centroid(poly_verts)\n        if abs(signed_area)  TOL: return 0.0\n\n        area = abs(signed_area)\n        val_at_centroid = coeffs[0] + coeffs[1] * centroid[0] + coeffs[2] * centroid[1]\n        \n        return area * val_at_centroid\n\n    def line_intersection(p1, p2, p3, p4):\n        \"\"\"Finds the intersection of two lines defined by (p1, p2) and (p3, p4).\"\"\"\n        den = (p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0])\n        if abs(den)  TOL: return p1  # Fallback for parallel/collinear lines\n        t = ((p1[0] - p3[0]) * (p3[1] - p4[1]) - (p1[1] - p3[1]) * (p3[0] - p4[0])) / den\n        return p1 + t * (p2 - p1)\n\n    def clip_sutherland_hodgman(subject_polygon, clip_polygon):\n        \"\"\"Clips a subject polygon against a convex clip polygon (both CCW).\"\"\"\n        clipped = subject_polygon\n        for i in range(clip_polygon.shape[0]):\n            if clipped.shape[0] == 0: return np.array([])\n            \n            p1, p2 = clip_polygon[i], clip_polygon[(i + 1) % clip_polygon.shape[0]]\n            input_list, output_list = clipped, []\n            S = input_list[-1]\n            for E in input_list:\n                s_cross = (p2[0]-p1[0])*(S[1]-p1[1]) - (p2[1]-p1[1])*(S[0]-p1[0])\n                e_cross = (p2[0]-p1[0])*(E[1]-p1[1]) - (p2[1]-p1[1])*(E[0]-p1[0])\n                s_inside, e_inside = s_cross >= -TOL, e_cross >= -TOL\n\n                if e_inside:\n                    if not s_inside:\n                        output_list.append(line_intersection(S, E, p1, p2))\n                    output_list.append(E)\n                elif s_inside:\n                    output_list.append(line_intersection(S, E, p1, p2))\n                S = E\n            clipped = np.array(output_list)\n        return clipped\n\n    def intersect_segment_circle(p1, p2, c_center, R):\n        \"\"\"Finds intersection points of a line segment with a circle.\"\"\"\n        d = p2 - p1; f = p1 - c_center\n        a, b, c = np.dot(d,d), 2*np.dot(f,d), np.dot(f,f) - R**2\n        if a  TOL: return []\n        discriminant = b**2 - 4*a*c\n        if discriminant  -TOL: return []\n        \n        t_vals = [-b/(2*a)] if discriminant  TOL else [(-b+np.sqrt(discriminant))/(2*a), (-b-np.sqrt(discriminant))/(2*a)]\n        return [p1 + max(0.0, min(1.0, t)) * d for t in t_vals if -TOL = t = 1 + TOL]\n\n    def get_chord_polygon(P, c_center, R):\n        \"\"\"Calculates the inside-region R_chord using the chord approximation.\"\"\"\n        phi_vals = np.sum((P - c_center)**2, axis=1) - R**2\n        if np.all(phi_vals >= -TOL): return np.array([])\n        if np.all(phi_vals = TOL): return P\n        \n        intersections = []\n        for i in range(P.shape[0]):\n            pts = intersect_segment_circle(P[i], P[(i + 1) % P.shape[0]], c_center, R)\n            for pt in pts:\n                if not any(np.linalg.norm(pt - ex_pt)  TOL for ex_pt in intersections):\n                    intersections.append(pt)\n        \n        if len(intersections)  2: return np.array([])\n\n        max_dist_sq, chord_p1, chord_p2 = -1.0, None, None\n        for i in range(len(intersections)):\n            for j in range(i + 1, len(intersections)):\n                dist_sq = np.sum((intersections[i] - intersections[j])**2)\n                if dist_sq > max_dist_sq:\n                    max_dist_sq, chord_p1, chord_p2 = dist_sq, intersections[i], intersections[j]\n\n        normal = np.array([chord_p2[1] - chord_p1[1], chord_p1[0] - chord_p2[0]])\n        center_side_val = np.dot(normal, c_center - chord_p1)\n        \n        output_list, S = [], P[-1]\n        for E in P:\n            s_dot = np.dot(normal, S - chord_p1)\n            e_dot = np.dot(normal, E - chord_p1)\n            s_inside, e_inside = s_dot * center_side_val >= -TOL, e_dot * center_side_val >= -TOL\n            \n            if e_inside:\n                if not s_inside: output_list.append(line_intersection(S, E, chord_p1, chord_p2))\n                output_list.append(E)\n            elif s_inside:\n                output_list.append(line_intersection(S, E, chord_p1, chord_p2))\n            S = E\n        return np.array(output_list)\n\n    def calculate_integral_approx(P, c_center, R, method):\n        \"\"\"\n        Computes I_ref or I_chord based on the specified method.\n        I = integral_P(f+) + integral_{R}(g), where R is the approximated inside region.\n        \"\"\"\n        integral_fplus_on_P = integrate_linear_over_poly(P, ALPHA_COEFFS)\n        \n        if method == 'ref':\n            angles = np.linspace(0, 2 * np.pi, N_REF, endpoint=False)\n            C_N_verts = c_center + R * np.c_[np.cos(angles), np.sin(angles)]\n            R_approx = clip_sutherland_hodgman(P, C_N_verts)\n        elif method == 'chord':\n            R_approx = get_chord_polygon(P, c_center, R)\n        else:\n            raise ValueError(\"Invalid method specified\")\n            \n        integral_g_on_R = integrate_linear_over_poly(R_approx, GAMMA_COEFFS)\n        return integral_fplus_on_P + integral_g_on_R\n\n    # --- Test Suite ---\n    test_cases = [\n        # (Polygon vertices, (circle_cx, circle_cy, circle_R))\n        ( [(-0.1,-0.05), (0.6,0.1), (0.45,0.5), (-0.2,0.35)], (0.0, 0.0, 0.5) ), # Case 1\n        ( [(0.1,0.0), (0.2,0.05), (0.05,0.15)], (0.0, 0.0, 1.0) ),              # Case 2\n        ( [(0.8,0.8), (0.9,0.7), (0.7,0.9)], (0.0, 0.0, 0.5) ),                # Case 3\n        ( [(-0.1,0.5), (0.1,0.5), (0.1,0.7), (-0.1,0.7)], (0.0, 0.0, 0.5) ),    # Case 4\n    ]\n\n    results = []\n    for P_verts, circle_params in test_cases:\n        P = np.array(P_verts)\n        c_center = np.array(circle_params[:2])\n        R = circle_params[2]\n        \n        I_ref = calculate_integral_approx(P, c_center, R, 'ref')\n        I_chord = calculate_integral_approx(P, c_center, R, 'chord')\n        \n        error = abs(I_chord - I_ref)\n        results.append(f\"{error:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "高效的数值模拟通常要求网格能够在计算过程中动态调整，以适应解的局部特征。本练习聚焦于网格自适应中的一个关键操作：网格粗化。您将通过实现一个基于边坍缩的算法，学习如何在满足特定几何与拓扑约束（如最小角度和单元面积）的同时，减少网格单元数量，并维护整个网格的有效性和质量。这项实践是开发高级自适应求解器的核心技能之一。",
            "id": "3406190",
            "problem": "考虑一个用于数值求解偏微分方程（PDE）的多边形区域的二维三角剖分。设网格由一组顶点 $\\{x_i\\}_{i=0}^{N-1}$（其中 $x_i \\in \\mathbb{R}^2$）和一组三角形 $\\mathcal{T} = \\{K_m\\}_{m=0}^{M-1}$ 表示，其中每个三角形 $K_m$ 是一个引用 $\\{x_i\\}$ 的顶点索引的有序三元组 $(i,j,k)$。如果任意两个不同三角形的交集为空、一个共享顶点或一条共享边，并且没有边邻接超过两个三角形，则该网格称为协调网格。粗化操作通过合并单元来降低网格复杂度，同时保持协调性并避免产生低质量三角形。\n\n您的任务是在一个非结构化三角网格上，根据几何约束实现一个基于边坍缩的粗化过程。该过程应尝试坍缩内部边，更新网格连接性和顶点位置，同时保持全局协调性并避免产生狭长三角形。\n\n从以下关于顶点为 $x_a, x_b, x_c \\in \\mathbb{R}^2$ 的三角形的基本几何定义开始：\n- 边长的平方为 $a^2 = \\|x_b - x_c\\|_2^2$，$b^2 = \\|x_c - x_a\\|_2^2$，$c^2 = \\|x_a - x_b\\|_2^2$。\n- 顶点处的角 $\\alpha, \\beta, \\gamma$ 满足余弦定理：\n$$\n\\cos(\\alpha) = \\frac{b^2 + c^2 - a^2}{2\\,\\sqrt{b^2}\\,\\sqrt{c^2}},\\quad\n\\cos(\\beta) = \\frac{c^2 + a^2 - b^2}{2\\,\\sqrt{c^2}\\,\\sqrt{a^2}},\\quad\n\\cos(\\gamma) = \\frac{a^2 + b^2 - c^2}{2\\,\\sqrt{a^2}\\,\\sqrt{b^2}},\n$$\n其中角度通过对夹紧的余弦值取 $\\arccos$ 计算。\n- (无符号)面积为\n$$\n\\mathcal{A}(K) = \\frac{1}{2}\\left| (x_b - x_a)^\\perp \\cdot (x_c - x_a) \\right|,\n$$\n其中对于 $v = (v_x, v_y)$，$v^\\perp = (v_y, -v_x)$ 且 $\\cdot$ 表示欧几里得点积。\n\n定义三角形 $K$ 的最小角为 $\\theta_{\\min}(K) = \\min\\{\\alpha,\\beta,\\gamma\\}$。对于给定的阈值 $\\alpha_{\\min}  0$（以弧度为单位）和 $A_{\\min}  0$（与坐标使用相同的面积单位），如果一个三角形满足 $\\theta_{\\min}(K)  \\alpha_{\\min}$ 或 $\\mathcal{A}(K)  A_{\\min}$，则称其为狭长三角形。\n\n实现一个尝试按如下方式坍缩内部边的粗化步骤：\n- 内部边 $(i,j)$ 是 $\\mathcal{T}$ 中恰好被两个三角形共享的边。\n- 一条边 $(i,j)$ 仅当其两个相邻三角形的面积都小于或等于预设的上界 $A_{\\max}$ 时，才有资格进行合并。\n- 坍缩 $(i,j)$ 会将这两个顶点替换为位于 $\\tilde{x} = \\frac{1}{2}(x_i + x_j)$ 的单个顶点。在数据结构中，使用索引 $i$ 来表示合并后的顶点，更新 $x_i \\leftarrow \\tilde{x}$，并将三角形列表中所有出现的索引 $j$ 替换为 $i$。\n- 替换后，立即移除任何具有重复顶点索引的退化三角形或面积严格小于 $A_{\\min}$ 的三角形，并移除具有相同顶点索引集的重复三角形。\n\n为避免狭长三角形并保持协调性的接受准则：\n- 除非操作后邻接于合并顶点所有三角形的最小角都大于或等于 $\\alpha_{\\min}$ 且面积大于或等于 $A_{\\min}$，否则必须拒绝 $(i,j)$ 的坍缩。\n- 全局边的邻接关系必须保持协调：每条边或邻接一个三角形（边界边），或邻接两个三角形（内部边），且不得有边邻接超过两个三角形。\n- 网格必须保持非空：在任何接受的坍缩操作后，必须至少保留一个三角形。\n\n算法要求：\n- 贪心地遍历所有符合条件的内部边，逐一尝试坍缩。每次接受坍缩后，更新网格并重新计算内部边的资格。当不存在符合条件且可接受的坍缩时，终止算法。\n- 实现稳健的角度计算，将余弦值夹紧在区间 $[-1,1]$ 内以避免舍入误差，并确保所有测试在数值上是稳定的。\n\n您必须根据上述定义推导并实现避免狭长三角形的条件，以确保粗化后的网格在保持全局协调性的同时，维持角度质量和面积的下界。\n\n角度单位要求：所有角度必须以弧度为单位。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表为所提供测试套件的结果。每个元素对应一个测试用例，本身是一个形如 $[n,\\mathrm{valid},\\theta]$ 的、用方括号括起来的逗号分隔三元组，其中 $n$ 是粗化后三角形的整数数量，$\\mathrm{valid}$ 是一个布尔值，指示最终网格是否满足上述定义的全局协调性以及角度和面积下界，$\\theta$ 是最终网格的最小角，以弧度为单位的浮点数。例如，包含两个测试用例的输出可能看起来像 $[[3,\\mathrm{True},0.523599],[5,\\mathrm{False},0.087266]]$。\n\n用于覆盖不同方面的测试套件和参数：\n- 案例1（一般情况）：顶点 $x_0=(0,0)$, $x_1=(1,0)$, $x_2=(1,1)$, $x_3=(0,1)$, $x_4=(0.5,0.5)$；三角形 $[4,0,1],[4,1,2],[4,2,3],[4,3,0]$；阈值 $\\alpha_{\\min}=0.3$, $A_{\\min}=0.01$, $A_{\\max}=0.3$。\n- 案例2（避免狭长三角形压力测试）：顶点 $x_0=(0,0)$, $x_1=(1.8,0)$, $x_2=(0.02,0.2)$, $x_3=(0,2)$, $x_4=(1.8,2)$；三角形 $[0,1,2],[0,2,3],[1,4,2],[3,2,4]$；阈值 $\\alpha_{\\min}=0.8$, $A_{\\min}=0.05$, $A_{\\max}=0.19$。\n- 案例3（仅边界，无内部边）：顶点 $x_0=(0,0)$, $x_1=(1,0)$, $x_2=(0,1)$；三角形 $[0,1,2]$；阈值 $\\alpha_{\\min}=0.2$, $A_{\\min}=0.001$, $A_{\\max}=0.5$。\n- 案例4（角度限制下的边界条件）：顶点 $x_0=(0,0)$, $x_1=(1,0)$, $x_2=(1,1)$, $x_3=(0,1)$, $x_4=(0.5,0.5)$；三角形 $[4,0,1],[4,1,2],[4,2,3],[4,3,0]$；阈值 $\\alpha_{\\min}=\\pi/4$, $A_{\\min}=0.01$, $A_{\\max}=0.24$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，其格式如上所述，包含所有结果。",
            "solution": "用户提供了一个计算几何问题，要求实现一个基于边坍缩的二维三角网格粗化算法。该过程必须遵守特定的几何和拓扑约束。\n\n### 问题验证\n\n**第1步：提取已知条件**\n- **网格表示**：一组二维顶点 $\\{x_i\\}_{i=0}^{N-1}$ 和一组三角形 $\\mathcal{T} = \\{K_m\\}_{m=0}^{M-1}$，其中每个三角形是顶点索引的有序三元组。\n- **协调网格定义**：任意两个不同三角形的交集为空、一个共享顶点或一条共享边。没有边邻接超过两个三角形。\n- **几何公式**：\n    - 边长的平方：$a^2 = \\|x_b - x_c\\|_2^2$，$b^2 = \\|x_c - x_a\\|_2^2$，$c^2 = \\|x_a - x_b\\|_2^2$。\n    - 通过余弦定理计算角度，并将值夹紧到 $[-1, 1]$。\n    - 面积计算：$\\mathcal{A}(K) = \\frac{1}{2}\\left| (x_b - x_a)^\\perp \\cdot (x_c - x_a) \\right|$。\n- **质量阈值**：最小角 $\\alpha_{\\min}$，最小面积 $A_{\\min}$，最大面积 $A_{\\max}$。所有角度均以弧度为单位。\n- **狭长三角形定义**：一个三角形 $K$，其 $\\theta_{\\min}(K)  \\alpha_{\\min}$ 或 $\\mathcal{A}(K)  A_{\\min}$。\n- **边坍缩过程**：\n    1.  **选择边**：选择一条*内部边* $(i,j)$（由恰好两个三角形共享）。\n    2.  **资格**：仅当两个相邻三角形的面积都小于或等于 $A_{\\max}$ 时，边 $(i,j)$ 才有资格。\n    3.  **坍缩**：将顶点 $x_i, x_j$ 合并到新顶点 $\\tilde{x} = \\frac{1}{2}(x_i + x_j)$。合并后的顶点使用索引 $i$，因此 $x_i \\leftarrow \\tilde{x}$，并且 $\\mathcal{T}$ 中所有出现的索引 $j$ 都被替换为 $i$。\n    4.  **清理**：替换后，移除退化三角形（重复索引）、面积小于 $A_{\\min}$ 的三角形以及重复三角形（顶点集相同）。\n- **坍缩的接受准则**：\n    1.  **质量**：所有邻接于合并后顶点的三角形必须满足 $\\theta_{\\min} \\ge \\alpha_{\\min}$ 和 $\\mathcal{A} \\ge A_{\\min}$。\n    2.  **协调性**：全局网格必须保持协调。\n    3.  **非空性**：坍缩后必须至少保留一个三角形。\n- **算法**：贪心地遍历所有符合条件的内部边。每次接受坍缩后，更新网格并重新开始此过程。当没有更多符合条件且可接受的坍缩时终止。\n- **输出格式**：一个结果列表，每个测试用例一个。每个结果是 `[n, valid, theta]`，其中 $n$ 是最终三角形数量，`valid` 是关于最终网格质量和协调性的布尔值，$\\theta$ 是最终网格的最小角。\n- **测试套件**：提供了四个测试用例，包含指定的顶点、三角形和阈值。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据**：该问题在计算几何和偏微分方程数值方法这一成熟领域中有充分的依据。三角网格、协调性、边坍缩和质量度量（最小角、面积）等概念都是标准概念。所提供的几何公式是正确的。\n- **良定性**：该问题描述了一个贪心算法。虽然贪心方法可能找不到全局最优解，但它定义了一个可终止的确定性过程。终止条件（没有更多可接受的坍缩）是明确的。该问题对于算法实现是良定的。遍历合格边的顺序未指定，但这种模糊性很常见，可以通过选择一个确定性顺序（例如，按顶点索引排序）来解决。\n- **客观性**：该问题使用精确、客观和定量的语言进行陈述。所有术语都有明确的定义。\n- 该问题是自包含的、可形式化的且科学上是合理的。它没有违反任何无效性标准。\n\n**第3步：结论与行动**\n问题是有效的。将制定一个合理的解决方案。\n\n### 算法设计与原则\n\n解决方案将构建为一个主循环，该循环重复尝试对网格进行粗化，直到没有更多有效的坍缩可以进行。算法的核心涉及识别候选边，模拟一次坍缩，并根据指定标准验证结果网格。\n\n**1. 几何辅助函数**\n- **面积计算**：一个函数 `calculate_area(p1, p2, p3)` 将实现公式 $\\mathcal{A} = \\frac{1}{2}\\left| (x_b - x_a)^\\perp \\cdot (x_c - x_a) \\right|$，其中 $x_a, x_b, x_c$ 是顶点坐标。这等同于二维叉积大小的一半，即 $\\frac{1}{2} |x_a(y_b - y_c) + x_b(y_c - y_a) + x_c(y_a - y_b)|$。\n- **角度计算**：一个函数 `calculate_min_angle(p1, p2, p3)` 将计算三角形的三个角。它会首先计算边长的平方 $a^2, b^2, c^2$ 以避免过早的 `sqrt` 操作。然后，它将按规定应用余弦定理。关键是，`arccos` 的参数将被夹紧到 $[-1, 1]$ 范围内，以防止浮点不精确导致的定义域错误。将返回计算出的三个角中的最小值。\n\n**2. 网格拓扑与状态管理**\n- **数据结构**：顶点将存储在形状为 $(N, 2)$ 的 NumPy 数组中，三角形存储在 $(M, 3)$ 的整数数组中。\n- **边到三角形的映射**：一个辅助函数 `get_edge_to_triangle_map(triangles)` 至关重要。它将创建一个字典，将每个边（表示为排序后的顶点索引元组 `(min(i,j), max(i,j))`）映射到包含该边的三角形索引列表。此映射可以高效地识别内部边（映射值的长度为2）和边界边（长度为1）。\n\n**3. 粗化算法**\n主要的粗化过程是一个 `while` 循环，只要在一轮遍历中发生了成功的坍缩，该循环就继续。\n\n- **迭代**：在循环内部，一个 `collapse_performed` 标志被初始化为 `False`。\n- **边识别**：使用边到三角形的映射识别所有内部边。\n- **资格筛选**：过滤内部边列表，以找到*符合条件*的边。对于邻接于三角形 $K_1$ 和 $K_2$ 的边 $(i, j)$，如果 $\\mathcal{A}(K_1) \\le A_{\\max}$ 且 $\\mathcal{A}(K_2) \\le A_{\\max}$，则它符合条件。为保证确定性，对符合条件的边列表进行排序。\n- **贪心尝试**：算法遍历排序后的合格边。对于每条边 $(i, j)$，它尝试进行一次坍缩。\n    - **提议状态**：创建一个假设性的新网格状态。\n        1.  复制顶点列表。将顶点 $x_i$ 更新为中点 $\\tilde{x} = \\frac{1}{2}(x_i + x_j)$。\n        2.  复制三角形列表。所有出现的索引 $j$ 都被替换为 $i$。\n        3.  **清理**：对提议的三角形列表进行清理：\n            a. 移除退化三角形（那些具有重复顶点索引的，例如 $(i,i,k)$）。\n            b. 移除面积严格小于 $A_{\\min}$ 的三角形。\n            c. 移除重复三角形（例如 $(i,k,l)$ 和 $(k,l,i)$）。这通过将每个三角形的顶点表示标准化（例如，作为一个 `frozenset`）并只保留唯一的集合来完成。\n    - **验证提议**：根据接受准则验证提议的网格：\n        1.  **非空**：提议的三角形列表不能为空。\n        2.  **角度/面积质量**：对于邻接到合并后顶点 $i$ 的每个三角形，其最小角必须 $\\ge \\alpha_{\\min}$ 且其面积必须 $\\ge A_{\\min}$。面积检查在清理步骤中已部分完成，但可作为一道保障。\n        3.  **协调性**：为提议的网格构建一个新的边到三角形的映射，并验证没有边邻接超过两个三角形。\n    - **提交或丢弃**：如果提议有效，则*接受*坍缩。用提议的网格更新主网格数据结构，将 `collapse_performed` 设置为 `True`，并中断对合格边的循环，以便从新网格的顶部重新开始整个过程。如果提议被拒绝，算法将继续处理下一条合格边。\n- **终止**：如果对所有合格边的完整遍历没有导致任何接受的坍缩，`collapse_performed` 标志将保持为 `False`，主 `while` 循环终止。\n\n**4. 最终分析**\n粗化循环结束后，对最终的网格进行最后一次验证，以生成输出元组 `[n, valid, theta]`。\n- $n$：最终网格中的三角形数量。\n- `valid`：一个布尔标志。当且仅当最终网格中的所有三角形都满足 $\\theta_{\\min} \\ge \\alpha_{\\min}$ 和 $\\mathcal{A} \\ge A_{\\min}$，并且网格是全局协调的时，它为 `True`。\n- $\\theta$：最终网格中所有三角形的最小角中的最小值。如果网格为空，则报告为 `0.0`。\n\n这种系统化的方法确保了问题陈述中的所有约束都得到遵守，从而实现了一个稳健的实现。",
            "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"vertices\": np.array([[0,0], [1,0], [1,1], [0,1], [0.5,0.5]]),\n            \"triangles\": np.array([[4,0,1],[4,1,2],[4,2,3],[4,3,0]]),\n            \"alpha_min\": 0.3, \"A_min\": 0.01, \"A_max\": 0.3\n        },\n        {\n            \"vertices\": np.array([[0,0], [1.8,0], [0.02,0.2], [0,2], [1.8,2]]),\n            \"triangles\": np.array([[0,1,2],[0,2,3],[1,4,2],[3,2,4]]),\n            \"alpha_min\": 0.8, \"A_min\": 0.05, \"A_max\": 0.19\n        },\n        {\n            \"vertices\": np.array([[0,0], [1,0], [0,1]]),\n            \"triangles\": np.array([[0,1,2]]),\n            \"alpha_min\": 0.2, \"A_min\": 0.001, \"A_max\": 0.5\n        },\n        {\n            \"vertices\": np.array([[0,0], [1,0], [1,1], [0,1], [0.5,0.5]]),\n            \"triangles\": np.array([[4,0,1],[4,1,2],[4,2,3],[4,3,0]]),\n            \"alpha_min\": math.pi / 4, \"A_min\": 0.01, \"A_max\": 0.24\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Use .copy() to avoid modifying the original test case data\n        final_verts, final_tris = coarsen_mesh(\n            case[\"vertices\"].copy(), case[\"triangles\"].copy(),\n            case[\"alpha_min\"], case[\"A_min\"], case[\"A_max\"]\n        )\n        n, is_valid, min_angle_final = analyze_final_mesh(\n            final_verts, final_tris, case[\"alpha_min\"], case[\"A_min\"]\n        )\n        results.append(f\"[{n},{is_valid},{min_angle_final}]\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_area(p1, p2, p3):\n    \"\"\"Calculates the area of a triangle given its 3 vertices.\"\"\"\n    return 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n\ndef calculate_min_angle(p1, p2, p3):\n    \"\"\"Calculates the minimum angle of a triangle in radians.\"\"\"\n    # Squared edge lengths\n    a2 = np.sum((p2-p3)**2)\n    b2 = np.sum((p1-p3)**2)\n    c2 = np.sum((p1-p2)**2)\n    \n    # Avoid division by zero for degenerate triangles\n    if a2 == 0 or b2 == 0 or c2 == 0:\n        return 0.0\n\n    a, b, c = np.sqrt(a2), np.sqrt(b2), np.sqrt(c2)\n\n    # Cosine values clamped to [-1, 1] for numerical stability\n    cos_alpha = np.clip((b2 + c2 - a2) / (2 * b * c), -1.0, 1.0)\n    cos_beta = np.clip((a2 + c2 - b2) / (2 * a * c), -1.0, 1.0)\n    cos_gamma = np.clip((a2 + b2 - c2) / (2 * a * b), -1.0, 1.0)\n\n    return min(np.arccos(cos_alpha), np.arccos(cos_beta), np.arccos(cos_gamma))\n    \ndef get_edge_to_triangle_map(triangles):\n    \"\"\"Builds a map from edges to triangles that contain them.\"\"\"\n    edge_map = defaultdict(list)\n    for i, tri in enumerate(triangles):\n        for j in range(3):\n            v1 = tri[j]\n            v2 = tri[(j + 1) % 3]\n            edge = tuple(sorted((v1, v2)))\n            edge_map[edge].append(i)\n    return edge_map\n\ndef coarsen_mesh(vertices, triangles, alpha_min, A_min, A_max):\n    \"\"\"\n    Performs the greedy edge-collapse coarsening procedure.\n    \"\"\"\n    while True:\n        collapse_performed = False\n        edge_map = get_edge_to_triangle_map(triangles)\n        \n        internal_edges = [edge for edge, tris in edge_map.items() if len(tris) == 2]\n\n        eligible_edges = []\n        for edge in internal_edges:\n            tri_idx1, tri_idx2 = edge_map[edge]\n            p1, p2, p3 = vertices[triangles[tri_idx1]]\n            area1 = calculate_area(p1, p2, p3)\n            p1, p2, p3 = vertices[triangles[tri_idx2]]\n            area2 = calculate_area(p1, p2, p3)\n            if area1 = A_max and area2 = A_max:\n                eligible_edges.append(edge)\n\n        # Sort for deterministic behavior\n        eligible_edges.sort()\n\n        for edge in eligible_edges:\n            i, j = edge # smaller index first\n            \n            # Propose collapse j -> i\n            proposed_verts = vertices.copy()\n            proposed_verts[i] = 0.5 * (vertices[i] + vertices[j])\n            \n            proposed_tris_list = list(triangles)\n            for k in range(len(proposed_tris_list)):\n                proposed_tris_list[k] = [i if v == j else v for v in proposed_tris_list[k]]\n            proposed_tris = np.array(proposed_tris_list)\n            \n            # --- Cleanup ---\n            # 1. Remove degenerate triangles (repeated vertices)\n            valid_tris_mask = [len(set(tri)) == 3 for tri in proposed_tris]\n            proposed_tris = proposed_tris[valid_tris_mask]\n            \n            # 2. Remove small area triangles\n            if len(proposed_tris) > 0:\n                area_ok_mask = [calculate_area(*proposed_verts[tri]) >= A_min for tri in proposed_tris]\n                proposed_tris = proposed_tris[area_ok_mask]\n            \n            # 3. Remove duplicate triangles\n            if len(proposed_tris) > 0:\n                unique_tris_reps = {}\n                for tri in proposed_tris:\n                    rep = frozenset(tri)\n                    if rep not in unique_tris_reps:\n                        unique_tris_reps[rep] = tri\n                proposed_tris = np.array(list(unique_tris_reps.values())) if unique_tris_reps else np.array([], dtype=int)\n\n            # --- Validation ---\n            is_acceptable = True\n            if len(proposed_tris) == 0:\n                is_acceptable = False # Mesh must not become empty\n\n            if is_acceptable:\n                # Check quality of triangles incident to merged vertex\n                incident_tris = [tri for tri in proposed_tris if i in tri]\n                for tri_indices in incident_tris:\n                    min_ang = calculate_min_angle(*proposed_verts[tri_indices])\n                    if min_ang  alpha_min:\n                        is_acceptable = False\n                        break\n                \n            if is_acceptable:\n                # Check global conformity\n                prop_edge_map = get_edge_to_triangle_map(proposed_tris)\n                if any(len(tris) > 2 for tris in prop_edge_map.values()):\n                    is_acceptable = False\n\n            if is_acceptable:\n                vertices = proposed_verts\n                triangles = proposed_tris\n                collapse_performed = True\n                break  # Restart greedy search with the new mesh\n        \n        if not collapse_performed:\n            break\n\n    return vertices, triangles\n\ndef analyze_final_mesh(vertices, triangles, alpha_min, A_min):\n    \"\"\"\n    Analyzes the final mesh for validity and computes its minimal angle.\n    \"\"\"\n    n = len(triangles)\n    if n == 0:\n        return 0, True, 0.0\n    \n    is_valid = True\n    min_angle_final = float('inf')\n\n    # Check conformity\n    edge_map = get_edge_to_triangle_map(triangles)\n    if any(len(tris) > 2 for tris in edge_map.values()):\n        is_valid = False\n\n    # Check triangle quality\n    for tri in triangles:\n        points = vertices[tri]\n        area = calculate_area(*points)\n        min_angle = calculate_min_angle(*points)\n        \n        if area  A_min or min_angle  alpha_min:\n            is_valid = False\n            \n        if min_angle  min_angle_final:\n            min_angle_final = min_angle\n            \n    return n, is_valid, min_angle_final if min_angle_final != float('inf') else 0.0\n\nsolve()\n```"
        }
    ]
}