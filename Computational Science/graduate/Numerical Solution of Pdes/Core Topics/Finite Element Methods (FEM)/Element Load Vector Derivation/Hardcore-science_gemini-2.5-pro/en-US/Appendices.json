{
    "hands_on_practices": [
        {
            "introduction": "The element load vector is the cornerstone of representing external forces or source terms in the finite element method. This first practice grounds you in the fundamental derivation, starting from the weak form of a simple 1D Poisson equation. You will manually compute element-level contributions using numerical quadrature and assemble them into a global vector, reinforcing the core mechanics of the FEM process.",
            "id": "3383737",
            "problem": "Consider the one-dimensional boundary value problem for the scalar field $u(x)$ on the interval $[0,2]$ governed by the second-order linear partial differential equation (PDE) $-u''(x)=f(x)$ with homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(2)=0$. Starting from the weak form that follows from multiplying the PDE by an arbitrary test function $v(x)$ in the Sobolev space $H_{0}^{1}([0,2])$ and integrating by parts, discretize the problem using the Finite Element Method (FEM) with continuous, piecewise linear Lagrange basis functions on a mesh with nodes at $x_{0}=0$, $x_{1}=1$, and $x_{2}=2$, thus forming two elements $[0,1]$ and $[1,2]$. Let the source term be $f(x)=1+x$. Using only the foundational definitions of the weak form, the reference-element shape functions, and the affine mapping from the reference domain to each physical element, derive the element-level right-hand side contributions and assemble them into the global Right-Hand Side (RHS) load vector. To evaluate the element integrals, use the minimum-order Gaussian Quadrature (GQ) on the canonical interval $[-1,1]$ that yields exact moments for these basis functions and this source term. Demonstrate that the assembled global RHS vector equals the exact global moments $\\int_{0}^{2} f(x) N_{i}(x)\\,\\mathrm{d}x$ for the three global basis functions $N_{0}(x)$, $N_{1}(x)$, and $N_{2}(x)$. Provide the final assembled global RHS load vector as a single row matrix of three entries.",
            "solution": "The problem posed is a standard, well-defined exercise in the application of the Finite Element Method (FEM) to a one-dimensional boundary value problem.\n\nThe governing differential equation is the one-dimensional Poisson equation:\n$$\n-u''(x) = f(x) \\quad \\text{for } x \\in [0, 2]\n$$\nwith a source term $f(x) = 1+x$ and homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(2)=0$.\n\nFirst, we derive the weak formulation. We multiply the equation by a test function $v(x) \\in H_{0}^{1}([0,2])$ and integrate over the domain $\\Omega = [0,2]$:\n$$\n-\\int_{0}^{2} u''(x) v(x) \\, \\mathrm{d}x = \\int_{0}^{2} f(x) v(x) \\, \\mathrm{d}x\n$$\nApplying integration by parts to the left-hand side (LHS) and using the fact that $v(0)=v(2)=0$ for any test function in $H_{0}^{1}([0,2])$ gives the weak form: Find $u(x) \\in H_{0}^{1}([0,2])$ such that\n$$\n\\int_{0}^{2} u'(x) v'(x) \\, \\mathrm{d}x = \\int_{0}^{2} f(x) v(x) \\, \\mathrm{d}x \\quad \\forall v(x) \\in H_{0}^{1}([0,2])\n$$\nIn FEM, we discretize the domain and set $v(x)$ to be each basis function $N_i(x)$ in turn. The components of the global load vector $\\mathbf{F}$ are given by $F_i = \\int_{0}^{2} f(x) N_i(x) \\, \\mathrm{d}x$. We assemble this vector from element contributions.\n\nTo evaluate element integrals, we map a reference element $\\hat{\\Omega} = [-1,1]$ with coordinate $\\xi$ to each physical element. The reference shape functions are $\\hat{N}_a(\\xi) = (1-\\xi)/2$ and $\\hat{N}_b(\\xi) = (1+\\xi)/2$. The element load integral is $F^{(e)} = \\int_{-1}^{1} f(x(\\xi)) \\hat{N}(\\xi) J_e \\, \\mathrm{d}\\xi$, where $J_e = h_e/2$ is the Jacobian of the affine map. The integrand is a quadratic polynomial in $\\xi$, so a 2-point Gaussian Quadrature (GQ) rule is required for exactness. The GQ points are $\\xi_{1,2} = \\mp 1/\\sqrt{3}$ and weights are $w_{1,2} = 1$.\n\n**Element 1: $\\Omega_1 = [0,1]$**\n- Length $h_1 = 1$, Jacobian $J_1 = 1/2$.\n- Mapping: $x(\\xi) = (1+\\xi)/2$.\n- Source term: $f(x(\\xi)) = 1 + (1+\\xi)/2 = (3+\\xi)/2$.\n- The local contributions are to global nodes 0 and 1.\n- For $F_0^{(1)}$, the integrand is $I_0(\\xi) = f(x(\\xi)) \\hat{N}_a(\\xi) J_1 = \\frac{1}{2}(3+\\xi) \\frac{1}{2}(1-\\xi) \\frac{1}{2} = \\frac{1}{8}(3+\\xi)(1-\\xi)$.\n$F_0^{(1)} = I_0(-1/\\sqrt{3}) + I_0(1/\\sqrt{3}) = \\frac{1}{8}(3-1/\\sqrt{3})(1+1/\\sqrt{3}) + \\frac{1}{8}(3+1/\\sqrt{3})(1-1/\\sqrt{3}) = \\frac{1}{8}(\\frac{8}{3}+\\frac{2}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{8}{3}-\\frac{2}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{16}{3}) = \\frac{2}{3}$.\n- For $F_1^{(1)}$, the integrand is $I_1(\\xi) = f(x(\\xi)) \\hat{N}_b(\\xi) J_1 = \\frac{1}{8}(3+\\xi)(1+\\xi)$.\n$F_1^{(1)} = I_1(-1/\\sqrt{3}) + I_1(1/\\sqrt{3}) = \\frac{1}{8}(3-1/\\sqrt{3})(1-1/\\sqrt{3}) + \\frac{1}{8}(3+1/\\sqrt{3})(1+1/\\sqrt{3}) = \\frac{1}{8}(\\frac{10}{3}-\\frac{4}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{10}{3}+\\frac{4}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{20}{3}) = \\frac{5}{6}$.\n\n**Element 2: $\\Omega_2 = [1,2]$**\n- Length $h_2 = 1$, Jacobian $J_2 = 1/2$.\n- Mapping: $x(\\xi) = (1/2)\\xi + 3/2$.\n- Source term: $f(x(\\xi)) = 1 + (1/2)\\xi + 3/2 = (5+\\xi)/2$.\n- The local contributions are to global nodes 1 and 2.\n- For $F_1^{(2)}$, the integrand is $I_1(\\xi) = f(x(\\xi)) \\hat{N}_a(\\xi) J_2 = \\frac{1}{8}(5+\\xi)(1-\\xi)$.\n$F_1^{(2)} = I_1(-1/\\sqrt{3}) + I_1(1/\\sqrt{3}) = \\frac{1}{8}(5-1/\\sqrt{3})(1+1/\\sqrt{3}) + \\frac{1}{8}(5+1/\\sqrt{3})(1-1/\\sqrt{3}) = \\frac{1}{8}(\\frac{14}{3}+\\frac{4}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{14}{3}-\\frac{4}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{28}{3}) = \\frac{7}{6}$.\n- For $F_2^{(2)}$, the integrand is $I_2(\\xi) = f(x(\\xi)) \\hat{N}_b(\\xi) J_2 = \\frac{1}{8}(5+\\xi)(1+\\xi)$.\n$F_2^{(2)} = I_2(-1/\\sqrt{3}) + I_2(1/\\sqrt{3}) = \\frac{1}{8}(5-1/\\sqrt{3})(1-1/\\sqrt{3}) + \\frac{1}{8}(5+1/\\sqrt{3})(1+1/\\sqrt{3}) = \\frac{1}{8}(\\frac{16}{3}-\\frac{6}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{16}{3}+\\frac{6}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{32}{3}) = \\frac{4}{3}$.\n\n**Assembly of the Global RHS Vector**\nThe global load vector $\\mathbf{F}$ is formed by summing the element contributions at the corresponding global node indices.\n$F_0 = F_0^{(1)} = \\frac{2}{3}$.\n$F_1 = F_1^{(1)} + F_1^{(2)} = \\frac{5}{6} + \\frac{7}{6} = \\frac{12}{6} = 2$.\n$F_2 = F_2^{(2)} = \\frac{4}{3}$.\nThe assembled global RHS vector is $\\mathbf{F} = \\begin{pmatrix} \\frac{2}{3}  2  \\frac{4}{3} \\end{pmatrix}^T$.\n\n**Verification via Exact Integration**\nWe can verify this result by directly calculating the global integrals.\n$F_0 = \\int_0^1 (1+x)(1-x)\\,\\mathrm{d}x = \\int_0^1 (1-x^2)\\,\\mathrm{d}x = [x - \\frac{x^3}{3}]_0^1 = 1 - \\frac{1}{3} = \\frac{2}{3}$. (Matches)\n$F_1 = \\int_0^1 (1+x)x\\,\\mathrm{d}x + \\int_1^2 (1+x)(2-x)\\,\\mathrm{d}x = [\\frac{x^2}{2}+\\frac{x^3}{3}]_0^1 + [2x+\\frac{x^2}{2}-\\frac{x^3}{3}]_1^2 = \\frac{5}{6} + \\frac{7}{6} = 2$. (Matches)\n$F_2 = \\int_1^2 (1+x)(x-1)\\,\\mathrm{d}x = \\int_1^2 (x^2-1)\\,\\mathrm{d}x = [\\frac{x^3}{3}-x]_1^2 = (\\frac{8}{3}-2) - (\\frac{1}{3}-1) = \\frac{4}{3}$. (Matches)\n\nThe calculations using Gaussian Quadrature are confirmed to be exact, as predicted by the theory. The final assembled global RHS load vector is correct.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{2}{3}  2  \\frac{4}{3}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Beyond the foundational theory, practical engineering often involves modeling choices and approximations. This exercise introduces the classic distinction between a 'consistent' load vector, derived rigorously from virtual work, and a simplified 'lumped' vector. By analyzing an Euler-Bernoulli beam element under dynamic loading, you will explore how this choice profoundly affects the prediction of modal forces and the overall dynamic response of a structure.",
            "id": "3383781",
            "problem": "Consider the Euler–Bernoulli beam, whose transverse dynamics are governed by the fourth-order partial differential equation (PDE) $E I \\,\\partial^4 w(x,t)/\\partial x^4 + \\rho A \\,\\partial^2 w(x,t)/\\partial t^2 = q(x,t)$, where $w(x,t)$ is the transverse displacement, $E$ is Young’s modulus, $I$ is the second moment of area, $\\rho$ is the mass density, $A$ is the cross-sectional area, and $q(x,t)$ is a distributed transverse load per unit length. The corresponding principle of virtual work states that, in the weak form, the external virtual work due to $q(x,t)$ over a beam segment $\\Omega_e = [0,L]$ is $W_e^{\\text{ext}} = \\int_{0}^{L} q(x,t) \\,\\delta w(x) \\, dx$, for any compatible virtual displacement $\\delta w(x)$ in the admissible function space.\n\nConsider a single two-node finite element of length $L$ with the standard Hermite cubic interpolation for the Euler–Bernoulli beam. The transverse displacement is approximated by $w(x) = N_1(\\xi) \\, w_1 + N_2(\\xi) \\, \\theta_1 + N_3(\\xi) \\, w_2 + N_4(\\xi) \\, \\theta_2$, where $\\xi = x/L \\in [0,1]$, $w_1$ and $w_2$ are nodal transverse displacements, and $\\theta_1$ and $\\theta_2$ are nodal rotations. The Hermite shape functions are\n$$\nN_1(\\xi) = 1 - 3\\xi^2 + 2\\xi^3,\\quad\nN_2(\\xi) = L\\left(\\xi - 2\\xi^2 + \\xi^3\\right),\\quad\nN_3(\\xi) = 3\\xi^2 - 2\\xi^3,\\quad\nN_4(\\xi) = L\\left(-\\xi^2 + \\xi^3\\right).\n$$\nBy the principle of virtual work, the consistent element load vector $\\mathbf{f}_e$ associated with a given $q(x,t)$ follows from matching external work with nodal virtual work in the finite element space, i.e., $\\delta \\mathbf{d}_e^{\\mathsf{T}} \\mathbf{f}_e = \\int_{0}^{L} q(x,t) \\,\\delta w(x) \\, dx$ for any virtual nodal vector $\\delta \\mathbf{d}_e = [\\delta w_1, \\delta \\theta_1, \\delta w_2, \\delta \\theta_2]^{\\mathsf{T}}$, which implies componentwise $f_{e,i}(t) = \\int_{0}^{L} N_i(x) \\, q(x,t) \\, dx$ for $i \\in \\{1,2,3,4\\}$.\n\nNow consider the following dynamic scenario: a clamped–free (cantilever) beam is modeled by a single Hermite element, with node $1$ clamped (i.e., $w_1 = 0$ and $\\theta_1 = 0$) and node $2$ free. The beam is subjected to a spatially uniform, temporally harmonic load $q(x,t) = q_0 \\cos(\\omega t)$, with $q_0 > 0$ and $\\omega > 0$. Two choices for the element load vector are considered:\n- A consistent element load vector, obtained via the above weak-form integration.\n- A lumped element load vector, which places the total resultant $\\int_{0}^{L} q(x,t) \\, dx$ equally on the nodal transverse displacement degrees of freedom while neglecting nodal moments (i.e., rotational entries are set to zero).\n\nThe discrete modal response for mode $j$ is governed by the modal equation $m_j \\,\\ddot{q}_j(t) + c_j \\,\\dot{q}_j(t) + k_j \\,q_j(t) = P_j(t)$, where $m_j$, $c_j$, and $k_j$ are the modal mass, damping, and stiffness, and $P_j(t) = \\boldsymbol{\\phi}_j^{\\mathsf{T}} \\mathbf{f}(t)$ is the generalized modal force obtained by projecting the global nodal force vector $\\mathbf{f}(t)$ onto the mode shape $\\boldsymbol{\\phi}_j$ (the $j$th eigenvector of the discretized system). In this cantilever single-element model, the first bending mode has a nonzero rotational component at the free end, i.e., the component associated with $\\theta_2$ in $\\boldsymbol{\\phi}_1$ is not zero.\n\nBased on the above, select the correct statements:\n\nA. For a spatially uniform distributed load $q(x,t) = q_0 \\cos(\\omega t)$ on a single Hermite beam element, the consistent element load vector contains nonzero entries in both the displacement and rotational components associated with each node. In the clamped–free single-element model, because the first bending mode has a nonzero free-end rotation, its generalized modal force computed with the consistent vector differs from that computed with the lumped vector that neglects nodal moments.\n\nB. Using a lumped element load vector generally increases the predicted natural frequencies in modal analysis compared to using the consistent element load vector, because concentrating forces at nodes stiffens the system.\n\nC. As the mesh is refined (i.e., as the number of Hermite beam elements increases while $L$ per element decreases), the difference between the consistent and lumped load vector projections onto any fixed low-order mode decreases, due to improved approximation of the distributed loading and convergence of the finite element space; hence their impact on modal response amplitudes diminishes.\n\nD. For a linearly varying load $q(x) = q_0 + q_1 x$ on a Hermite beam element, the consistent element load vector is obtained by integrating $N_i(x)\\,q(x)$ over the element for each $i$, which produces nonzero nodal moments even when $q_1 = 0$; by contrast, a naive lumped vector that distributes only the total resultant $\\int_{0}^{L} q(x) \\, dx$ onto displacement degrees of freedom yields zero nodal moments. This difference leads to distinct modal participation factors in dynamics.\n\nE. The generalized modal force $P_j(t)$ is determined solely by the total resultant $\\int_{0}^{L} q(x,t) \\, dx$ and is identical for consistent and lumped element load vectors for any beam element and any mode shape, regardless of the spatial distribution of $q(x,t)$ within the element.",
            "solution": "This problem tests the understanding of consistent versus lumped load vectors in the context of Euler-Bernoulli beam dynamics. To determine the correct statements, we will first derive the consistent and lumped load vectors for a uniform load and then analyze each option based on fundamental principles of finite element analysis and structural dynamics.\n\n**1. Derivation of Load Vectors**\n\nLet the uniform load be $q(x) = q_0$. The consistent element load vector $\\mathbf{f}_{e,c}$ is found by integrating the shape functions against the load: $f_{e,i} = \\int_{0}^{L} N_i(x) q_0 \\, dx$. Using the given shape functions in terms of $\\xi = x/L$ (so $dx = L d\\xi$):\n$f_{e,1} = \\int_{0}^{1} q_0 L(1 - 3\\xi^2 + 2\\xi^3) d\\xi = q_0 L \\left[\\xi - \\xi^3 + \\frac{\\xi^4}{2}\\right]_0^1 = \\frac{q_0 L}{2}$\n$f_{e,2} = \\int_{0}^{1} q_0 L^2(\\xi - 2\\xi^2 + \\xi^3) d\\xi = q_0 L^2 \\left[\\frac{\\xi^2}{2} - \\frac{2\\xi^3}{3} + \\frac{\\xi^4}{4}\\right]_0^1 = \\frac{q_0 L^2}{12}$\nBy symmetry, $f_{e,3} = f_{e,1} = \\frac{q_0 L}{2}$.\n$f_{e,4} = \\int_{0}^{1} q_0 L^2(-\\xi^2 + \\xi^3) d\\xi = q_0 L^2 \\left[-\\frac{\\xi^3}{3} + \\frac{\\xi^4}{4}\\right]_0^1 = -\\frac{q_0 L^2}{12}$\n\nSo, the consistent load vector is $\\mathbf{f}_{e,c} = q_0 \\cos(\\omega t) \\begin{bmatrix} L/2  L^2/12  L/2  -L^2/12 \\end{bmatrix}^T$.\n\nThe lumped load vector $\\mathbf{f}_{e,l}$ is defined by taking the total force, $F_{total} = \\int_0^L q_0 dx = q_0 L$, distributing it equally to the displacement DOFs, and setting moment DOFs to zero.\nSo, $\\mathbf{f}_{e,l} = q_0 \\cos(\\omega t) \\begin{bmatrix} L/2  0  L/2  0 \\end{bmatrix}^T$.\n\n**2. Option-by-Option Analysis**\n\n**A: Correct.** Our calculation shows the consistent load vector has nonzero force ($L/2$) and moment ($L^2/12$) components. The generalized modal force is $P_j(t) = \\boldsymbol{\\phi}_j^T \\mathbf{f}(t)$. For the cantilever, the mode shape has the form $\\boldsymbol{\\phi}_1 = [0, 0, \\phi_{1,w2}, \\phi_{1,\\theta2}]^T$. Since the problem states $\\phi_{1,\\theta2} \\neq 0$ and the consistent vector has a nonzero moment component while the lumped one does not, their dot products with $\\boldsymbol{\\phi}_1$ will be different. The difference in the generalized forces is $-\\phi_{1,\\theta2} (q_0 L^2/12) \\cos(\\omega t)$, which is nonzero.\n\n**B: Incorrect.** The natural frequencies and mode shapes of a system are determined by its mass and stiffness matrices ($\\mathbf{K}$, $\\mathbf{M}$) through the eigenvalue problem $(\\mathbf{K} - \\omega_n^2 \\mathbf{M})\\boldsymbol{\\phi}_n = \\mathbf{0}$. The applied load vector $\\mathbf{f}(t)$ influences the dynamic response (the right-hand side of the equation of motion), but not the inherent natural frequencies of the system. This statement incorrectly conflates the load vector with properties that determine system frequencies.\n\n**C: Correct.** The consistent load vector is derived from the weak form and provides a high-order approximation of the work done by the distributed load. The lumped vector is a lower-order approximation. As the mesh is refined (element length $L \\to 0$), both finite element approximations converge to the exact continuous solution. The FE mode shapes converge to the true mode shapes, and both representations of the generalized force converge to the true integral $\\int q(x) \\phi_j(x) dx$. Therefore, the difference between the two methods must diminish as the mesh is refined.\n\n**D: Correct.** The consistent load vector integrates the load against the cubic Hermite shape functions. For a uniform load ($q_1=0$), we've already shown this produces nonzero nodal moments ($q_0 L^2/12$ and $-q_0 L^2/12$). A lumped vector, as defined in the problem, has zero nodal moments. Since the load vectors are different, their projections onto a mode shape with rotational components will generally be different, leading to distinct generalized modal forces and thus distinct dynamic responses.\n\n**E: Incorrect.** This statement is false on two counts. First, as shown in A, the generalized modal force is *not* identical for consistent and lumped vectors if the mode shape has rotational components. Second, the generalized force $P_j(t) = \\int q(x,t) \\phi_j(x) dx$ is a weighted integral. The spatial distribution of the load $q(x,t)$ is critical; a load concentrated at a modal node does no work and produces zero generalized force for that mode, while the same total load concentrated at a modal anti-node produces maximum work. The total resultant load is not sufficient to determine the modal force.\n\nTherefore, statements A, C, and D are correct.",
            "answer": "$$\\boxed{ACD}$$"
        },
        {
            "introduction": "Many real-world phenomena are nonlinear, leading to source terms that depend on the solution itself, such as $f(u)$. Solving these problems with methods like Newton-Raphson requires the Jacobian of the element load vector. This advanced practice bridges theory and modern computation by having you derive this Jacobian both by hand (linearization) and by implementing forward-mode Automatic Differentiation (AD), a powerful technique for computing derivatives of complex computer programs.",
            "id": "3383773",
            "problem": "Consider a one-dimensional nonlinear strong form partial differential equation (PDE) whose finite element method (FEM) residual includes a source term modeled by a nonlinear function $f(u)$. For a two-node linear element with nodes at physical coordinates $x_1$ and $x_2$, the element load vector is defined via the standard Galerkin construction as the integral of the shape functions multiplied by $f(u_h)$, where $u_h$ is the nodal interpolant. Use this foundational definition and well-tested numerical quadrature facts to derive, implement, and verify the Jacobian of the element load vector with respect to the nodal values.\n\nFundamental base:\n- The element load vector components $L_i(u)$, for $i \\in \\{1,2\\}$, are defined by the integral over the physical element domain of the product of the $i$-th shape function and the nonlinear source function evaluated at the approximate solution $u_h$, using the canonical two-node linear shape functions on the reference interval $[-1,1]$ and the standard affine mapping to the physical element $[x_1,x_2]$.\n- The approximate solution is $u_h(x) = N_1(\\xi) u_1 + N_2(\\xi) u_2$, where $N_1(\\xi)$ and $N_2(\\xi)$ are the standard linear shape functions on the reference coordinate $\\xi \\in [-1,1]$, and the Jacobian of the affine map is $(x_2 - x_1)/2$.\n- Numerical integration must use Gauss–Legendre quadrature on the reference interval $[-1,1]$ with the specified order.\n\nYour task:\n1. Implement forward-mode Automatic Differentiation (AD) to compute the Jacobian (the matrix of partial derivatives with respect to the nodal values $u_1$ and $u_2$) of the element load vector $L(u)$.\n2. Independently derive the linearization of the element load vector from the variational base and implement its evaluation using the same quadrature rule to obtain a hand-derived Jacobian.\n3. Verify that the AD-produced entries $\\frac{dL_i}{du_j}$ match the entries obtained by the hand-derived linearization for the following test suite. Treat all quantities as dimensionless.\n\nReference element and mapping details:\n- Reference interval is $[-1,1]$.\n- Standard two-node linear shape functions on $[-1,1]$ are to be used.\n- The physical element mapping must be the unique affine map from $[-1,1]$ to $[x_1,x_2]$ with Jacobian $(x_2 - x_1)/2$.\n\nTest suite:\n- Case A (general nonlinear, moderate amplitude): $x_1 = 0$, $x_2 = 1$, $u_1 = 0.3$, $u_2 = -0.2$, $f(u) = \\sin(u) + u^3$, Gauss–Legendre order $5$.\n- Case B (small element length to test scaling): $x_1 = 0$, $x_2 = 0.01$, $u_1 = -0.5$, $u_2 = 0.8$, $f(u) = \\exp(u) + u^5$, Gauss–Legendre order $5$.\n- Case C (zero solution, derivative cancellations): $x_1 = -2$, $x_2 = 2$, $u_1 = 0$, $u_2 = 0$, $f(u) = \\cos(u) + u^3$, Gauss–Legendre order $3$.\n- Case D (large amplitude, mixed nonlinearities): $x_1 = -0.2$, $x_2 = 1.3$, $u_1 = 5.0$, $u_2 = -4.0$, $f(u) = u \\exp(u) + \\sin(u)$, Gauss–Legendre order $7$.\n\nVerification criterion:\n- For each case, compute the Jacobian via AD and via the hand-derived linearization and check equality within a numerical tolerance of $10^{-12}$ using the maximum absolute difference across the Jacobian entries.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one boolean per test case indicating whether the AD and hand-derived Jacobians match within the tolerance (for example, $[\\text{True},\\text{False},\\text{True},\\text{True}]$).",
            "solution": "The problem requires the derivation and implementation of the Jacobian of a nonlinear element load vector for a one-dimensional, two-node linear finite element. This Jacobian will be computed using two distinct methods: a direct analytical derivation (hand-derived) and forward-mode Automatic Differentiation (AD). The results from both methods must be verified for consistency across a suite of test cases.\n\n### 1. Foundational Formulation\n\nLet the physical element be defined by the interval $[x_1, x_2]$. We use an isoparametric formulation, mapping the reference element, defined by $\\xi \\in [-1, 1]$, to the physical element via the affine transformation:\n$$\nx(\\xi) = N_1(\\xi) x_1 + N_2(\\xi) x_2\n$$\nwhere $N_1(\\xi)$ and $N_2(\\xi)$ are the standard linear shape functions on the reference element:\n$$\nN_1(\\xi) = \\frac{1 - \\xi}{2}, \\quad N_2(\\xi) = \\frac{1 + \\xi}{2}\n$$\nThe differential relationship between the physical and reference coordinates is given by the Jacobian of the mapping, $J$:\n$$\ndx = \\frac{dx}{d\\xi} d\\xi = J d\\xi\n$$\nwhere\n$$\nJ = \\frac{dx}{d\\xi} = \\frac{d}{d\\xi} \\left( \\frac{1 - \\xi}{2} x_1 + \\frac{1 + \\xi}{2} x_2 \\right) = \\frac{x_2 - x_1}{2}\n$$\nThe approximate solution $u_h$ within the element is interpolated from the nodal values $u_1$ and $u_2$ using the same shape functions:\n$$\nu_h(x) \\rightarrow u_h(\\xi) = N_1(\\xi) u_1 + N_2(\\xi) u_2\n$$\nThe element load vector $L$ arises from the Galerkin formulation of a source term $f(u)$. For a two-node element, it is a $2 \\times 1$ vector whose components $L_i$ are given by:\n$$\nL_i(\\mathbf{u}) = \\int_{x_1}^{x_2} N_i(x) f(u_h(x)) \\, dx\n$$\nwhere $\\mathbf{u} = [u_1, u_2]^T$. Transforming this integral to the reference coordinate system, we get:\n$$\nL_i(\\mathbf{u}) = \\int_{-1}^{1} N_i(\\xi) f(u_h(\\xi)) J \\, d\\xi, \\quad i \\in \\{1, 2\\}\n$$\nThis integral is evaluated numerically using Gauss-Legendre quadrature with $n_p$ points:\n$$\nL_i \\approx \\sum_{k=1}^{n_p} w_k N_i(\\xi_k) f(u_h(\\xi_k)) J\n$$\nwhere $\\xi_k$ are the Gauss points and $w_k$ are the corresponding weights.\n\n### 2. Hand-Derived Jacobian\n\nThe Jacobian of the element load vector is a $2 \\times 2$ matrix $K$ with components $K_{ij} = \\frac{\\partial L_i}{\\partial u_j}$. We derive this by differentiating the integral expression for $L_i$ with respect to the nodal value $u_j$.\n$$\nK_{ij} = \\frac{\\partial L_i}{\\partial u_j} = \\frac{\\partial}{\\partial u_j} \\left[ \\int_{-1}^{1} N_i(\\xi) f(u_h(\\xi)) J \\, d\\xi \\right]\n$$\nSince the integration domain and the Jacobian $J$ are independent of $\\mathbf{u}$, we can move the derivative inside the integral:\n$$\nK_{ij} = \\int_{-1}^{1} N_i(\\xi) \\frac{\\partial}{\\partial u_j} \\left[ f(u_h(\\xi)) \\right] J \\, d\\xi\n$$\nUsing the chain rule, we have $\\frac{\\partial}{\\partial u_j} [f(u_h)] = f'(u_h) \\frac{\\partial u_h}{\\partial u_j}$, where $f'(u_h)$ is the derivative of $f$ with respect to its argument, evaluated at $u_h$. The derivative of the interpolated solution $u_h$ with respect to a nodal value $u_j$ is simply the corresponding shape function:\n$$\n\\frac{\\partial u_h(\\xi)}{\\partial u_j} = \\frac{\\partial}{\\partial u_j} \\left[ N_1(\\xi) u_1 + N_2(\\xi) u_2 \\right] = N_j(\\xi)\n$$\nSubstituting this back into the expression for $K_{ij}$ yields the analytical formula for the Jacobian entries:\n$$\nK_{ij} = \\int_{-1}^{1} N_i(\\xi) f'(u_h(\\xi)) N_j(\\xi) J \\, d\\xi\n$$\nThe numerical evaluation of this integral using Gauss-Legendre quadrature is:\n$$\nK_{ij} \\approx \\sum_{k=1}^{n_p} w_k N_i(\\xi_k) f'(u_h(\\xi_k)) N_j(\\xi_k) J\n$$\nwhere $u_h(\\xi_k) = N_1(\\xi_k)u_1 + N_2(\\xi_k)u_2$.\n\n### 3. Forward-Mode Automatic Differentiation (AD)\n\nForward-mode AD computes the derivative of a function by propagating derivatives of intermediate variables alongside their values. This is achieved by defining a `Dual` number algebra. A dual number is an ordered pair $(v, \\dot{v})$ representing the value $v$ and its derivative $\\dot{v}$. It can be written as $v + \\dot{v}\\epsilon$, where $\\epsilon$ is a nilpotent element with $\\epsilon^2 = 0$.\n\nLet $u = (u, \\dot{u})$ and $v = (v, \\dot{v})$. Arithmetic operations and elementary functions are overloaded as follows:\n- Addition/Subtraction: $(u, \\dot{u}) \\pm (v, \\dot{v}) = (u \\pm v, \\dot{u} \\pm \\dot{v})$\n- Multiplication: $(u, \\dot{u}) \\cdot (v, \\dot{v}) = (uv, u\\dot{v} + v\\dot{u})$\n- Function application (e.g., $\\sin$): $\\sin((u, \\dot{u})) = (\\sin(u), \\dot{u}\\cos(u))$\n\nTo compute the $j$-th column of the Jacobian matrix $K$, we \"seed\" the derivative of the $j$-th input variable $u_j$ to $1$ and all others to $0$. We then evaluate the load vector $L(\\mathbf{u})$ using dual number arithmetic. The derivative parts of the resulting dual numbers for $L_1$ and $L_2$ will form the $j$-th column of the Jacobian.\n\nFor example, to compute the first column ($\\frac{\\partial L}{\\partial u_1}$), we set the inputs as:\n$$\nu_1^{\\text{AD}} = (u_1, 1), \\quad u_2^{\\text{AD}} = (u_2, 0)\n$$\nThen we compute the load vector components using dual arithmetic in the quadrature loop:\n$$\nu_h^{\\text{AD}}(\\xi_k) = N_1(\\xi_k) u_1^{\\text{AD}} + N_2(\\xi_k) u_2^{\\text{AD}}\n$$\n$$\nL_i^{\\text{AD}} = \\sum_{k=1}^{n_p} w_k N_i(\\xi_k) f(u_h^{\\text{AD}}(\\xi_k)) J\n$$\nThe result for each component will be a dual number $L_i^{\\text{AD}} = (L_i, \\frac{\\partial L_i}{\\partial u_1})$. The derivative part is the desired Jacobian entry. We repeat this process, seeding $u_2$ (i.e., $u_1^{\\text{AD}} = (u_1, 0), u_2^{\\text{AD}} = (u_2, 1)$), to obtain the second column.\n\nThis procedure mechanically calculates the exact same derivatives as the hand-derived formula, provided the quadrature is held constant, thus serving as an excellent verification tool. The implementation will follow this logic for the specified test cases.",
            "answer": "```python\nimport numpy as np\n\nclass Dual:\n    \"\"\"A simple Dual number class for forward-mode automatic differentiation.\"\"\"\n    def __init__(self, value, deriv=0.0):\n        self.value = value\n        self.deriv = deriv\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value + other.value, self.deriv + other.deriv)\n        return Dual(self.value + other, self.deriv)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value - other.value, self.deriv - other.deriv)\n        return Dual(self.value - other, self.deriv)\n\n    def __rsub__(self, other):\n        return Dual(other - self.value, -self.deriv)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value * other.value, self.deriv * other.value + self.value * other.deriv)\n        return Dual(self.value * other, self.deriv * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __pow__(self, power):\n        val = self.value ** power\n        der = power * (self.value ** (power - 1)) * self.deriv\n        return Dual(val, der)\n    \n    def __repr__(self):\n        return f\"Dual(value={self.value}, deriv={self.deriv})\"\n\n# Overload math functions for Dual numbers\ndef sin(d):\n    return Dual(np.sin(d.value), d.deriv * np.cos(d.value))\n\ndef cos(d):\n    return Dual(np.cos(d.value), -d.deriv * np.sin(d.value))\n\ndef exp(d):\n    return Dual(np.exp(d.value), d.deriv * np.exp(d.value))\n\n\ndef solve():\n    \"\"\"\n    Computes and verifies the Jacobian of a nonlinear element load vector using\n    both hand-derivation and automatic differentiation.\n    \"\"\"\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            \"x1\": 0.0, \"x2\": 1.0, \"u1\": 0.3, \"u2\": -0.2, \"order\": 5,\n            \"f\": lambda u: np.sin(u) + u**3,\n            \"f_prime\": lambda u: np.cos(u) + 3 * u**2,\n            \"f_ad\": lambda u: sin(u) + u**3\n        },\n        {\n            \"x1\": 0.0, \"x2\": 0.01, \"u1\": -0.5, \"u2\": 0.8, \"order\": 5,\n            \"f\": lambda u: np.exp(u) + u**5,\n            \"f_prime\": lambda u: np.exp(u) + 5 * u**4,\n            \"f_ad\": lambda u: exp(u) + u**5\n        },\n        {\n            \"x1\": -2.0, \"x2\": 2.0, \"u1\": 0.0, \"u2\": 0.0, \"order\": 3,\n            \"f\": lambda u: np.cos(u) + u**3,\n            \"f_prime\": lambda u: -np.sin(u) + 3 * u**2,\n            \"f_ad\": lambda u: cos(u) + u**3\n        },\n        {\n            \"x1\": -0.2, \"x2\": 1.3, \"u1\": 5.0, \"u2\": -4.0, \"order\": 7,\n            \"f\": lambda u: u * np.exp(u) + np.sin(u),\n            \"f_prime\": lambda u: (1 + u) * np.exp(u) + np.cos(u),\n            \"f_ad\": lambda u: u * exp(u) + sin(u)\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x1, x2, u1, u2 = case[\"x1\"], case[\"x2\"], case[\"u1\"], case[\"u2\"]\n        order = case[\"order\"]\n        f_prime = case[\"f_prime\"]\n        f_ad = case[\"f_ad\"]\n        \n        # 1. Common setup\n        J_map = (x2 - x1) / 2.0\n        xi_points, weights = np.polynomial.legendre.leggauss(order)\n        N_vals = np.array([(1 - xi_points) / 2.0, (1 + xi_points) / 2.0]) # Shape functions evaluated at GPs\n\n        # 2. Hand-derived Jacobian\n        K_hand = np.zeros((2, 2))\n        for k in range(order):\n            # Evaluate shape functions at Gauss point k\n            N1_k, N2_k = N_vals[0, k], N_vals[1, k]\n            \n            # Evaluate uh at Gauss point k\n            u_h_k = N1_k * u1 + N2_k * u2\n            \n            # Evaluate f'(uh) at Gauss point k\n            f_prime_uh_k = f_prime(u_h_k)\n            \n            # Form outer product of shape functions\n            N_outer = np.outer([N1_k, N2_k], [N1_k, N2_k])\n            \n            # Accumulate contribution to Jacobian\n            K_hand += weights[k] * f_prime_uh_k * N_outer * J_map\n            \n        # 3. Automatic Differentiation Jacobian\n        K_ad = np.zeros((2, 2))\n        \n        # Compute column 1 (derivatives with respect to u1)\n        u1_ad = Dual(u1, 1.0)\n        u2_ad = Dual(u2, 0.0)\n        L_ad = [Dual(0.0, 0.0), Dual(0.0, 0.0)]\n        for k in range(order):\n            N1_k, N2_k = N_vals[0, k], N_vals[1, k]\n            u_h_ad_k = N1_k * u1_ad + N2_k * u2_ad\n            f_uh_ad = f_ad(u_h_ad_k)\n            \n            L_ad[0] += N1_k * f_uh_ad * weights[k] * J_map\n            L_ad[1] += N2_k * f_uh_ad * weights[k] * J_map\n        \n        K_ad[0, 0] = L_ad[0].deriv\n        K_ad[1, 0] = L_ad[1].deriv\n        \n        # Compute column 2 (derivatives with respect to u2)\n        u1_ad = Dual(u1, 0.0)\n        u2_ad = Dual(u2, 1.0)\n        L_ad = [Dual(0.0, 0.0), Dual(0.0, 0.0)]\n        for k in range(order):\n            N1_k, N2_k = N_vals[0, k], N_vals[1, k]\n            u_h_ad_k = N1_k * u1_ad + N2_k * u2_ad\n            f_uh_ad = f_ad(u_h_ad_k)\n\n            L_ad[0] += N1_k * f_uh_ad * weights[k] * J_map\n            L_ad[1] += N2_k * f_uh_ad * weights[k] * J_map\n            \n        K_ad[0, 1] = L_ad[0].deriv\n        K_ad[1, 1] = L_ad[1].deriv\n        \n        # 4. Verification\n        max_abs_diff = np.max(np.abs(K_hand - K_ad))\n        is_match = max_abs_diff  1e-12\n        results.append(is_match)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}