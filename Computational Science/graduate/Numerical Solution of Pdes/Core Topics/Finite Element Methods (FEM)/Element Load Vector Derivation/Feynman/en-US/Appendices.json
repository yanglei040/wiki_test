{
    "hands_on_practices": [
        {
            "introduction": "The element load vector represents the weak-form contribution of a source term over an element's domain. In its most fundamental form, this is an integral. This first practice  grounds our understanding by simplifying the integrand to a constant, revealing the direct link between the load vector and the element's geometry. By computing the load contribution for piecewise constant functions, you will see that the core task reduces to calculating the area of the element, providing a clear and intuitive starting point before we introduce more complex functions.",
            "id": "3383766",
            "problem": "Consider the mixed formulation of a scalar elliptic Partial Differential Equation (PDE) posed on a polygonal domain, written in first-order form as $p + \\nabla u = 0$ and $\\nabla \\cdot p = f$, where $p$ is the flux and $u$ is the scalar potential. In a mixed finite element method, let the flux $p$ be approximated in the lowest-order Raviart–Thomas space $RT_0$ and let the scalar field $u$ be approximated in the piecewise constant space $P_0$. On a single triangular element $K$, the element right-hand side (load vector) contribution associated with a $P_0$ test function $v$ is the local integral $b_K = \\int_K f\\,v\\,dx$.\n\nAssume $K$ is an affine triangle with vertices $(1,2)$, $(5,3)$, and $(2,7)$. On this element, let the source be constant with $f(x) \\equiv f_0$ for all $x \\in K$, and choose the $P_0$ test function to be the constant $v(x) \\equiv c_K$ for all $x \\in K$. Take $f_0 = 7$ and $c_K = 2$. Using only first principles (the weak formulation and the change-of-variables for affine mappings), compute the exact value of the element load contribution $b_K = \\int_K f\\,v\\,dx$.\n\nExpress your final answer as a single real number. No rounding is required.",
            "solution": "The problem is valid. It presents a clear, self-contained, and scientifically sound task within the field of numerical methods for partial differential equations. All necessary data and definitions are provided, and there are no contradictions or ambiguities.\n\nThe objective is to compute the element load vector contribution $b_K$ for a single triangular element $K$. According to the problem statement, this contribution is defined by the integral:\n$$b_K = \\int_K f\\,v\\,dx$$\nwhere $K$ is the triangular element domain, $f$ is the source term, and $v$ is a test function.\n\nThe problem specifies the following:\n1. The element $K$ is a triangle with vertices $V_1 = (1,2)$, $V_2 = (5,3)$, and $V_3 = (2,7)$.\n2. The source term $f(x)$ is constant over the element $K$, given by $f(x) \\equiv f_0 = 7$.\n3. The test function $v(x)$ is from the piecewise constant space $P_0$. On element $K$, it is given as the constant $v(x) \\equiv c_K = 2$.\n\nSubstituting the given constant functions for $f$ and $v$ into the integral definition of $b_K$, we have:\n$$b_K = \\int_K (f_0)(c_K)\\,dx$$\nSince $f_0$ and $c_K$ are constants, they can be factored out of the integral:\n$$b_K = f_0 c_K \\int_K 1\\,dx$$\nThe remaining integral, $\\int_K 1\\,dx$, represents the area of the triangular element $K$. Let us denote this area by $|K|$. Therefore, the expression for $b_K$ simplifies to:\n$$b_K = f_0 c_K |K|$$\n\nThis formulation aligns with the first principles of finite element methods. The integral is typically computed by transforming the physical element $K$ to a reference element $\\hat{K}$ via an affine map $x = F(\\hat{x})$. The integral then becomes $\\int_{\\hat{K}} f(F(\\hat{x})) v(F(\\hat{x})) |\\det(J_F)| \\,d\\hat{x}$, where $|\\det(J_F)|$ is the determinant of the Jacobian of the map. For an affine map, this determinant is constant and is equal to $2|K|$ if $\\hat{K}$ is the unit reference triangle (area $\\frac{1}{2}$). The calculation of $|K|$ is therefore the central geometric task.\n\nWe can compute the area of the triangle $K$ using its vertices. One method is to use the coordinates of the vertices in the determinant formula (a variant of the shoelace formula). An equivalent and physically intuitive method is to find the area as half the magnitude of the cross product of two edge vectors originating from the same vertex.\n\nLet's define two vectors spanning the triangle from vertex $V_1$:\n$$\\vec{a} = V_2 - V_1 = (5-1, 3-2) = (4, 1)$$\n$$\\vec{b} = V_3 - V_1 = (2-1, 7-2) = (1, 5)$$\n\nTo compute the cross product, we embed these vectors in three-dimensional space with a zero $z$-component: $\\vec{a} = (4, 1, 0)$ and $\\vec{b} = (1, 5, 0)$. The cross product is:\n$$\\vec{a} \\times \\vec{b} = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ 4 & 1 & 0 \\\\ 1 & 5 & 0 \\end{vmatrix} = \\mathbf{i}(1 \\cdot 0 - 0 \\cdot 5) - \\mathbf{j}(4 \\cdot 0 - 0 \\cdot 1) + \\mathbf{k}(4 \\cdot 5 - 1 \\cdot 1)$$\n$$\\vec{a} \\times \\vec{b} = (0)\\mathbf{i} - (0)\\mathbf{j} + (20 - 1)\\mathbf{k} = 19\\mathbf{k}$$\nThe magnitude of this resulting vector is $\\|\\vec{a} \\times \\vec{b}\\| = |19| = 19$. The area of the triangle $|K|$ is half of this magnitude:\n$$|K| = \\frac{1}{2} \\|\\vec{a} \\times \\vec{b}\\| = \\frac{19}{2}$$\n\nNow we have all the components to calculate $b_K$. Substituting the given values $f_0 = 7$, $c_K = 2$, and the calculated area $|K| = \\frac{19}{2}$ into our expression for $b_K$:\n$$b_K = (7) \\cdot (2) \\cdot \\left(\\frac{19}{2}\\right)$$\n$$b_K = 7 \\cdot 19$$\n$$b_K = 133$$\nThus, the exact value of the element load contribution is $133$.",
            "answer": "$$\\boxed{133}$$"
        },
        {
            "introduction": "Building upon the geometric intuition from the first exercise, we now tackle the more general case where the source term and basis functions are not constant. This practice  introduces the standard computational workflow for deriving an element load vector: mapping the physical element to a canonical reference domain and employing numerical quadrature to evaluate the resulting integral. By working through this one-dimensional example with linear basis functions, you will master the foundational mechanics of the Finite Element Method that are used in nearly all practical applications.",
            "id": "3383737",
            "problem": "Consider the one-dimensional boundary value problem for the scalar field $u(x)$ on the interval $[0,2]$ governed by the second-order linear partial differential equation (PDE) $-u''(x)=f(x)$ with homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(2)=0$. Starting from the weak form that follows from multiplying the PDE by an arbitrary test function $v(x)$ in the Sobolev space $H_{0}^{1}([0,2])$ and integrating by parts, discretize the problem using the Finite Element Method (FEM) with continuous, piecewise linear Lagrange basis functions on a mesh with nodes at $x_{0}=0$, $x_{1}=1$, and $x_{2}=2$, thus forming two elements $[0,1]$ and $[1,2]$. Let the source term be $f(x)=1+x$. Using only the foundational definitions of the weak form, the reference-element shape functions, and the affine mapping from the reference domain to each physical element, derive the element-level right-hand side contributions and assemble them into the global Right-Hand Side (RHS) load vector. To evaluate the element integrals, use the minimum-order Gaussian Quadrature (GQ) on the canonical interval $[-1,1]$ that yields exact moments for these basis functions and this source term. Demonstrate that the assembled global RHS vector equals the exact global moments $\\int_{0}^{2} f(x) N_{i}(x)\\,\\mathrm{d}x$ for the three global basis functions $N_{0}(x)$, $N_{1}(x)$, and $N_{2}(x)$. Provide the final assembled global RHS load vector as a single row matrix of three entries.",
            "solution": "The problem posed is a standard, well-defined exercise in the application of the Finite Element Method (FEM) to a one-dimensional boundary value problem. All necessary components are provided and are scientifically and mathematically consistent. The problem is valid and admits a unique, verifiable solution.\n\nThe governing differential equation is the one-dimensional Poisson equation:\n$$\n-u''(x) = f(x) \\quad \\text{for } x \\in [0, 2]\n$$\nwith a source term $f(x) = 1+x$ and homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(2)=0$.\n\nThe first step is to derive the weak formulation. We multiply the equation by a test function $v(x)$ from the space of functions where the solution is sought, $H_{0}^{1}([0,2])$, and integrate over the domain $\\Omega = [0,2]$:\n$$\n-\\int_{0}^{2} u''(x) v(x) \\, \\mathrm{d}x = \\int_{0}^{2} f(x) v(x) \\, \\mathrm{d}x\n$$\nApplying integration by parts to the left-hand side (LHS) yields:\n$$\n\\int_{0}^{2} u'(x) v'(x) \\, \\mathrm{d}x - [u'(x)v(x)]_{0}^{2} = \\int_{0}^{2} f(x) v(x) \\, \\mathrm{d}x\n$$\nSince the test function $v(x) \\in H_{0}^{1}([0,2])$, it must satisfy the homogeneous boundary conditions $v(0)=0$ and $v(2)=0$. Consequently, the boundary term $[u'(x)v(x)]_{0}^{2}$ vanishes. The weak form of the problem is: Find $u(x) \\in H_{0}^{1}([0,2])$ such that\n$$\n\\int_{0}^{2} u'(x) v'(x) \\, \\mathrm{d}x = \\int_{0}^{2} f(x) v(x) \\, \\mathrm{d}x \\quad \\forall v(x) \\in H_{0}^{1}([0,2])\n$$\nThis is of the form $a(u,v) = L(v)$, where $a(u,v)$ is the bilinear form and $L(v)$ is the linear functional representing the load.\n\nIn the FEM, we discretize the domain and approximate the solution $u(x)$ as a linear combination of basis functions $N_j(x)$: $u_h(x) = \\sum_{j=0}^{2} u_j N_j(x)$. The problem specifies continuous, piecewise linear Lagrange basis functions on a mesh with nodes at $x_0=0$, $x_1=1$, and $x_2=2$. This partitions the domain into two elements: $\\Omega_1 = [0,1]$ and $\\Omega_2 = [1,2]$. The discrete problem is obtained by testing against each basis function $N_i(x)$ (that is, setting $v(x) = N_i(x)$), leading to a system of linear equations $\\mathbf{K}\\mathbf{u} = \\mathbf{F}$, where $\\mathbf{K}$ is the stiffness matrix and $\\mathbf{F}$ is the global load vector. The components of the load vector are given by $F_i = L(N_i)$, which is:\n$$\nF_i = \\int_{0}^{2} f(x) N_i(x) \\, \\mathrm{d}x\n$$\nThe problem asks for the derivation of this vector $\\mathbf{F}$ with components $F_0$, $F_1$, and $F_2$. The integral is assembled from element-level contributions:\n$$\nF_i = \\sum_{e=1}^{2} F_i^{(e)} = \\sum_{e=1}^{2} \\int_{\\Omega_e} f(x) N_i(x) \\, \\mathrm{d}x\n$$\nTo evaluate these integrals, we use an affine mapping from a reference element $\\hat{\\Omega} = [-1,1]$ with coordinate $\\xi$ to each physical element $\\Omega_e = [x_L, x_R]$. The mapping is $x(\\xi) = x_L + \\frac{h_e}{2}(1+\\xi)$, where $h_e = x_R - x_L$ is the element length. An alternative common form is $x(\\xi) = \\frac{x_R-x_L}{2}\\xi + \\frac{x_R+x_L}{2}$. The differential element transforms as $\\mathrm{d}x = J_e \\, \\mathrm{d}\\xi$, where the Jacobian is $J_e = \\frac{\\mathrm{d}x}{\\mathrm{d}\\xi} = \\frac{h_e}{2}$.\n\nOn the reference element $\\hat{\\Omega}=[-1,1]$, the linear Lagrange shape functions associated with the local nodes at $\\xi=-1$ and $\\xi=1$ are:\n$$\n\\hat{N}_a(\\xi) = \\frac{1}{2}(1-\\xi) \\quad \\text{and} \\quad \\hat{N}_b(\\xi) = \\frac{1}{2}(1+\\xi)\n$$\nThe element integral for a generic basis function $\\hat{N}$ becomes:\n$$\nF^{(e)} = \\int_{x_L}^{x_R} f(x) N(x) \\, \\mathrm{d}x = \\int_{-1}^{1} f(x(\\xi)) \\hat{N}(\\xi) J_e \\, \\mathrm{d}\\xi\n$$\nThe integrand is $I(\\xi) = f(x(\\xi)) \\hat{N}(\\xi) J_e$. Since $f(x)=1+x$ is a linear polynomial and the mapping $x(\\xi)$ is linear, $f(x(\\xi))$ is a linear polynomial in $\\xi$. The shape function $\\hat{N}(\\xi)$ is also a linear polynomial in $\\xi$. The Jacobian $J_e$ is a constant. Therefore, the integrand $I(\\xi)$ is a quadratic polynomial in $\\xi$.\n\nA Gaussian Quadrature rule with $n$ points is exact for polynomials of degree up to $2n-1$. To integrate a quadratic (degree $m=2$) exactly, we require $2n-1 \\ge 2$, which implies $n \\ge 1.5$. The minimum integer number of quadrature points is therefore $n=2$. The 2-point GQ rule on $[-1,1]$ uses quadrature points $\\xi_{1,2} = \\mp \\frac{1}{\\sqrt{3}}$ and weights $w_{1,2} = 1$.\n\n**Element 1: $\\Omega_1 = [0,1]$**\nThe element length is $h_1 = 1-0=1$. Nodes are $x_0=0$ and $x_1=1$.\nMapping: $x(\\xi) = \\frac{1}{2}\\xi + \\frac{1}{2}$.\nJacobian: $J_1 = \\frac{h_1}{2} = \\frac{1}{2}$.\nSource term: $f(x(\\xi)) = 1+x(\\xi) = 1 + (\\frac{1}{2}\\xi + \\frac{1}{2}) = \\frac{3}{2} + \\frac{1}{2}\\xi$.\nThe local contributions are to global nodes $0$ and $1$.\n$F_0^{(1)} = \\int_0^1 f(x) N_0(x) \\, \\mathrm{d}x = \\int_{-1}^1 (\\frac{3}{2} + \\frac{1}{2}\\xi) \\hat{N}_a(\\xi) J_1 \\, \\mathrm{d}\\xi$. The integrand is $I_0(\\xi) = (\\frac{3}{2} + \\frac{1}{2}\\xi) \\frac{1}{2}(1-\\xi) \\frac{1}{2} = \\frac{1}{8}(3+\\xi)(1-\\xi)$.\n$F_0^{(1)} = \\sum_{k=1}^2 w_k I_0(\\xi_k) = I_0(-\\frac{1}{\\sqrt{3}}) + I_0(\\frac{1}{\\sqrt{3}})$.\n$I_0(-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3-\\frac{1}{\\sqrt{3}})(1+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 + \\sqrt{3} - \\frac{1}{3}) = \\frac{1}{8}(\\frac{8}{3} + \\frac{2}{\\sqrt{3}})$.\n$I_0(+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3+\\frac{1}{\\sqrt{3}})(1-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 - \\sqrt{3} - \\frac{1}{3}) = \\frac{1}{8}(\\frac{8}{3} - \\frac{2}{\\sqrt{3}})$.\n$F_0^{(1)} = \\frac{1}{8}(\\frac{8}{3} + \\frac{2}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{8}{3} - \\frac{2}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{16}{3}) = \\frac{2}{3}$.\n\n$F_1^{(1)} = \\int_0^1 f(x) N_1(x) \\, \\mathrm{d}x = \\int_{-1}^1 (\\frac{3}{2} + \\frac{1}{2}\\xi) \\hat{N}_b(\\xi) J_1 \\, \\mathrm{d}\\xi$. Integrand is $I_1(\\xi) = \\frac{1}{8}(3+\\xi)(1+\\xi)$.\n$F_1^{(1)} = I_1(-\\frac{1}{\\sqrt{3}}) + I_1(\\frac{1}{\\sqrt{3}})$.\n$I_1(-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3-\\frac{1}{\\sqrt{3}})(1-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 - \\frac{3}{\\sqrt{3}} - \\frac{1}{\\sqrt{3}} + \\frac{1}{3}) = \\frac{1}{8}(\\frac{10}{3} - \\frac{4}{\\sqrt{3}})$.\n$I_1(+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3+\\frac{1}{\\sqrt{3}})(1+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 + \\frac{3}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} + \\frac{1}{3}) = \\frac{1}{8}(\\frac{10}{3} + \\frac{4}{\\sqrt{3}})$.\n$F_1^{(1)} = \\frac{1}{8}(\\frac{10}{3} - \\frac{4}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{10}{3} + \\frac{4}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{20}{3}) = \\frac{5}{6}$.\n\n**Element 2: $\\Omega_2 = [1,2]$**\nThe element length is $h_2 = 2-1=1$. Nodes are $x_1=1$ and $x_2=2$.\nMapping: $x(\\xi) = \\frac{1}{2}\\xi + \\frac{3}{2}$.\nJacobian: $J_2 = \\frac{h_2}{2} = \\frac{1}{2}$.\nSource term: $f(x(\\xi)) = 1+x(\\xi) = 1 + (\\frac{1}{2}\\xi + \\frac{3}{2}) = \\frac{5}{2} + \\frac{1}{2}\\xi$.\nThe local contributions are to global nodes $1$ and $2$.\n$F_1^{(2)} = \\int_1^2 f(x) N_1(x) \\, \\mathrm{d}x = \\int_{-1}^1 (\\frac{5}{2} + \\frac{1}{2}\\xi) \\hat{N}_a(\\xi) J_2 \\, \\mathrm{d}\\xi$. Integrand is $I_1(\\xi) = \\frac{1}{8}(5+\\xi)(1-\\xi)$.\n$F_1^{(2)} = I_1(-\\frac{1}{\\sqrt{3}}) + I_1(\\frac{1}{\\sqrt{3}})$.\n$I_1(-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5-\\frac{1}{\\sqrt{3}})(1+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 + \\frac{5}{\\sqrt{3}} - \\frac{1}{\\sqrt{3}} - \\frac{1}{3}) = \\frac{1}{8}(\\frac{14}{3} + \\frac{4}{\\sqrt{3}})$.\n$I_1(+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5+\\frac{1}{\\sqrt{3}})(1-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 - \\frac{5}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} - \\frac{1}{3}) = \\frac{1}{8}(\\frac{14}{3} - \\frac{4}{\\sqrt{3}})$.\n$F_1^{(2)} = \\frac{1}{8}(\\frac{14}{3} + \\frac{4}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{14}{3} - \\frac{4}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{28}{3}) = \\frac{7}{6}$.\n\n$F_2^{(2)} = \\int_1^2 f(x) N_2(x) \\, \\mathrm{d}x = \\int_{-1}^1 (\\frac{5}{2} + \\frac{1}{2}\\xi) \\hat{N}_b(\\xi) J_2 \\, \\mathrm{d}\\xi$. Integrand is $I_2(\\xi) = \\frac{1}{8}(5+\\xi)(1+\\xi)$.\n$F_2^{(2)} = I_2(-\\frac{1}{\\sqrt{3}}) + I_2(\\frac{1}{\\sqrt{3}})$.\n$I_2(-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5-\\frac{1}{\\sqrt{3}})(1-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 - \\frac{5}{\\sqrt{3}} - \\frac{1}{\\sqrt{3}} + \\frac{1}{3}) = \\frac{1}{8}(\\frac{16}{3} - \\frac{6}{\\sqrt{3}})$.\n$I_2(+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5+\\frac{1}{\\sqrt{3}})(1+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 + \\frac{5}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} + \\frac{1}{3}) = \\frac{1}{8}(\\frac{16}{3} + \\frac{6}{\\sqrt{3}})$.\n$F_2^{(2)} = \\frac{1}{8}(\\frac{16}{3} - \\frac{6}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{16}{3} + \\frac{6}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{32}{3}) = \\frac{4}{3}$.\n\n**Assembly of the Global RHS Vector**\nThe global load vector $\\mathbf{F}$ is formed by summing the element contributions at the corresponding global node indices.\n$F_0 = F_0^{(1)} = \\frac{2}{3}$.\n$F_1 = F_1^{(1)} + F_1^{(2)} = \\frac{5}{6} + \\frac{7}{6} = \\frac{12}{6} = 2$.\n$F_2 = F_2^{(2)} = \\frac{4}{3}$.\nThe assembled global RHS vector is $\\mathbf{F} = \\begin{pmatrix} \\frac{2}{3} & 2 & \\frac{4}{3} \\end{pmatrix}^T$.\n\n**Verification via Exact Integration**\nWe verify this result by directly calculating the global moments. The global basis functions are:\n$N_0(x) = \\begin{cases} 1-x & x \\in [0,1] \\\\ 0 & \\text{otherwise} \\end{cases}$\n$N_1(x) = \\begin{cases} x & x \\in [0,1] \\\\ 2-x & x \\in [1,2] \\end{cases}$\n$N_2(x) = \\begin{cases} x-1 & x \\in [1,2] \\\\ 0 & \\text{otherwise} \\end{cases}$\n\n$F_0 = \\int_0^2 (1+x)N_0(x)\\,\\mathrm{d}x = \\int_0^1 (1+x)(1-x)\\,\\mathrm{d}x = \\int_0^1 (1-x^2)\\,\\mathrm{d}x = [x - \\frac{x^3}{3}]_0^1 = 1 - \\frac{1}{3} = \\frac{2}{3}$. This matches.\n\n$F_1 = \\int_0^2 (1+x)N_1(x)\\,\\mathrm{d}x = \\int_0^1 (1+x)x\\,\\mathrm{d}x + \\int_1^2 (1+x)(2-x)\\,\\mathrm{d}x$.\n$\\int_0^1 (x+x^2)\\,\\mathrm{d}x = [\\frac{x^2}{2}+\\frac{x^3}{3}]_0^1 = \\frac{1}{2}+\\frac{1}{3} = \\frac{5}{6}$.\n$\\int_1^2 (2+x-x^2)\\,\\mathrm{d}x = [2x+\\frac{x^2}{2}-\\frac{x^3}{3}]_1^2 = (4+2-\\frac{8}{3}) - (2+\\frac{1}{2}-\\frac{1}{3}) = (\\frac{10}{3}) - (\\frac{13}{6}) = \\frac{20-13}{6} = \\frac{7}{6}$.\n$F_1 = \\frac{5}{6} + \\frac{7}{6} = \\frac{12}{6} = 2$. This matches.\n\n$F_2 = \\int_0^2 (1+x)N_2(x)\\,\\mathrm{d}x = \\int_1^2 (1+x)(x-1)\\,\\mathrm{d}x = \\int_1^2 (x^2-1)\\,\\mathrm{d}x = [\\frac{x^3}{3}-x]_1^2 = (\\frac{8}{3}-2) - (\\frac{1}{3}-1) = \\frac{2}{3} - (-\\frac{2}{3}) = \\frac{4}{3}$. This matches.\n\nThe calculations using Gaussian Quadrature are confirmed to be exact, as predicted by the theory. The final assembled global RHS load vector is correct.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{2}{3} & 2 & \\frac{4}{3}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Real-world physical phenomena are often nonlinear, leading to PDEs where the source term $f$ depends on the solution $u$ itself. To solve such systems, iterative methods like Newton-Raphson are employed, which require the linearization of the governing equations—specifically, the Jacobian of the load vector. This advanced practice  guides you through the process of deriving this Jacobian and introduces Automatic Differentiation (AD) as a powerful computational tool to perform and verify this complex differentiation, directly connecting theoretical FEM with modern, practical implementation.",
            "id": "3383773",
            "problem": "Consider a one-dimensional nonlinear strong form partial differential equation (PDE) whose finite element method (FEM) residual includes a source term modeled by a nonlinear function $f(u)$. For a two-node linear element with nodes at physical coordinates $x_1$ and $x_2$, the element load vector is defined via the standard Galerkin construction as the integral of the shape functions multiplied by $f(u_h)$, where $u_h$ is the nodal interpolant. Use this foundational definition and well-tested numerical quadrature facts to derive, implement, and verify the Jacobian of the element load vector with respect to the nodal values.\n\nFundamental base:\n- The element load vector components $L_i(u)$, for $i \\in \\{1,2\\}$, are defined by the integral over the physical element domain of the product of the $i$-th shape function and the nonlinear source function evaluated at the approximate solution $u_h$, using the canonical two-node linear shape functions on the reference interval $[-1,1]$ and the standard affine mapping to the physical element $[x_1,x_2]$.\n- The approximate solution is $u_h(x) = N_1(\\xi) u_1 + N_2(\\xi) u_2$, where $N_1(\\xi)$ and $N_2(\\xi)$ are the standard linear shape functions on the reference coordinate $\\xi \\in [-1,1]$, and the Jacobian of the affine map is $(x_2 - x_1)/2$.\n- Numerical integration must use Gauss–Legendre quadrature on the reference interval $[-1,1]$ with the specified order.\n\nYour task:\n1. Implement forward-mode Automatic Differentiation (AD) to compute the Jacobian (the matrix of partial derivatives with respect to the nodal values $u_1$ and $u_2$) of the element load vector $L(u)$.\n2. Independently derive the linearization of the element load vector from the variational base and implement its evaluation using the same quadrature rule to obtain a hand-derived Jacobian.\n3. Verify that the AD-produced entries $\\frac{dL_i}{du_j}$ match the entries obtained by the hand-derived linearization for the following test suite. Treat all quantities as dimensionless.\n\nReference element and mapping details:\n- Reference interval is $[-1,1]$.\n- Standard two-node linear shape functions on $[-1,1]$ are to be used.\n- The physical element mapping must be the unique affine map from $[-1,1]$ to $[x_1,x_2]$ with Jacobian $(x_2 - x_1)/2$.\n\nTest suite:\n- Case A (general nonlinear, moderate amplitude): $x_1 = 0$, $x_2 = 1$, $u_1 = 0.3$, $u_2 = -0.2$, $f(u) = \\sin(u) + u^3$, Gauss–Legendre order $5$.\n- Case B (small element length to test scaling): $x_1 = 0$, $x_2 = 0.01$, $u_1 = -0.5$, $u_2 = 0.8$, $f(u) = \\exp(u) + u^5$, Gauss–Legendre order $5$.\n- Case C (zero solution, derivative cancellations): $x_1 = -2$, $x_2 = 2$, $u_1 = 0$, $u_2 = 0$, $f(u) = \\cos(u) + u^3$, Gauss–Legendre order $3$.\n- Case D (large amplitude, mixed nonlinearities): $x_1 = -0.2$, $x_2 = 1.3$, $u_1 = 5.0$, $u_2 = -4.0$, $f(u) = u \\exp(u) + \\sin(u)$, Gauss–Legendre order $7$.\n\nVerification criterion:\n- For each case, compute the Jacobian via AD and via the hand-derived linearization and check equality within a numerical tolerance of $10^{-12}$ using the maximum absolute difference across the Jacobian entries.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one boolean per test case indicating whether the AD and hand-derived Jacobians match within the tolerance (for example, $[\\text{True},\\text{False},\\text{True},\\text{True}]$).",
            "solution": "The problem requires the derivation and implementation of the Jacobian of a nonlinear element load vector for a one-dimensional, two-node linear finite element. This Jacobian will be computed using two distinct methods: a direct analytical derivation (hand-derived) and forward-mode Automatic Differentiation (AD). The results from both methods must be verified for consistency across a suite of test cases.\n\n### 1. Foundational Formulation\n\nLet the physical element be defined by the interval $[x_1, x_2]$. We use an isoparametric formulation, mapping the reference element, defined by $\\xi \\in [-1, 1]$, to the physical element via the affine transformation:\n$$\nx(\\xi) = N_1(\\xi) x_1 + N_2(\\xi) x_2\n$$\nwhere $N_1(\\xi)$ and $N_2(\\xi)$ are the standard linear shape functions on the reference element:\n$$\nN_1(\\xi) = \\frac{1 - \\xi}{2}, \\quad N_2(\\xi) = \\frac{1 + \\xi}{2}\n$$\nThe differential relationship between the physical and reference coordinates is given by the Jacobian of the mapping, $J$:\n$$\ndx = \\frac{dx}{d\\xi} d\\xi = J d\\xi\n$$\nwhere\n$$\nJ = \\frac{dx}{d\\xi} = \\frac{d}{d\\xi} \\left( \\frac{1 - \\xi}{2} x_1 + \\frac{1 + \\xi}{2} x_2 \\right) = \\frac{x_2 - x_1}{2}\n$$\nThe approximate solution $u_h$ within the element is interpolated from the nodal values $u_1$ and $u_2$ using the same shape functions:\n$$\nu_h(x) \\rightarrow u_h(\\xi) = N_1(\\xi) u_1 + N_2(\\xi) u_2\n$$\nThe element load vector $L$ arises from the Galerkin formulation of a source term $f(u)$. For a two-node element, it is a $2 \\times 1$ vector whose components $L_i$ are given by:\n$$\nL_i(\\mathbf{u}) = \\int_{x_1}^{x_2} N_i(x) f(u_h(x)) \\, dx\n$$\nwhere $\\mathbf{u} = [u_1, u_2]^T$. Transforming this integral to the reference coordinate system, we get:\n$$\nL_i(\\mathbf{u}) = \\int_{-1}^{1} N_i(\\xi) f(u_h(\\xi)) J \\, d\\xi, \\quad i \\in \\{1, 2\\}\n$$\nThis integral is evaluated numerically using Gauss-Legendre quadrature with $n_p$ points:\n$$\nL_i \\approx \\sum_{k=1}^{n_p} w_k N_i(\\xi_k) f(u_h(\\xi_k)) J\n$$\nwhere $\\xi_k$ are the Gauss points and $w_k$ are the corresponding weights.\n\n### 2. Hand-Derived Jacobian\n\nThe Jacobian of the element load vector is a $2 \\times 2$ matrix $K$ with components $K_{ij} = \\frac{\\partial L_i}{\\partial u_j}$. We derive this by differentiating the integral expression for $L_i$ with respect to the nodal value $u_j$.\n$$\nK_{ij} = \\frac{\\partial L_i}{\\partial u_j} = \\frac{\\partial}{\\partial u_j} \\left[ \\int_{-1}^{1} N_i(\\xi) f(u_h(\\xi)) J \\, d\\xi \\right]\n$$\nSince the integration domain and the Jacobian $J$ are independent of $\\mathbf{u}$, we can move the derivative inside the integral:\n$$\nK_{ij} = \\int_{-1}^{1} N_i(\\xi) \\frac{\\partial}{\\partial u_j} \\left[ f(u_h(\\xi)) \\right] J \\, d\\xi\n$$\nUsing the chain rule, we have $\\frac{\\partial}{\\partial u_j} [f(u_h)] = f'(u_h) \\frac{\\partial u_h}{\\partial u_j}$, where $f'(u_h)$ is the derivative of $f$ with respect to its argument, evaluated at $u_h$. The derivative of the interpolated solution $u_h$ with respect to a nodal value $u_j$ is simply the corresponding shape function:\n$$\n\\frac{\\partial u_h(\\xi)}{\\partial u_j} = \\frac{\\partial}{\\partial u_j} \\left[ N_1(\\xi) u_1 + N_2(\\xi) u_2 \\right] = N_j(\\xi)\n$$\nSubstituting this back into the expression for $K_{ij}$ yields the analytical formula for the Jacobian entries:\n$$\nK_{ij} = \\int_{-1}^{1} N_i(\\xi) f'(u_h(\\xi)) N_j(\\xi) J \\, d\\xi\n$$\nThe numerical evaluation of this integral using Gauss-Legendre quadrature is:\n$$\nK_{ij} \\approx \\sum_{k=1}^{n_p} w_k N_i(\\xi_k) f'(u_h(\\xi_k)) N_j(\\xi_k) J\n$$\nwhere $u_h(\\xi_k) = N_1(\\xi_k)u_1 + N_2(\\xi_k)u_2$.\n\n### 3. Forward-Mode Automatic Differentiation (AD)\n\nForward-mode AD computes the derivative of a function by propagating derivatives of intermediate variables alongside their values. This is achieved by defining a `Dual` number algebra. A dual number is an ordered pair $(v, \\dot{v})$ representing the value $v$ and its derivative $\\dot{v}$. It can be written as $v + \\dot{v}\\epsilon$, where $\\epsilon$ is a nilpotent element with $\\epsilon^2 = 0$.\n\nLet $u = (u, \\dot{u})$ and $v = (v, \\dot{v})$. Arithmetic operations and elementary functions are overloaded as follows:\n- Addition/Subtraction: $(u, \\dot{u}) \\pm (v, \\dot{v}) = (u \\pm v, \\dot{u} \\pm \\dot{v})$\n- Multiplication: $(u, \\dot{u}) \\cdot (v, \\dot{v}) = (uv, u\\dot{v} + v\\dot{u})$\n- Function application (e.g., $\\sin$): $\\sin((u, \\dot{u})) = (\\sin(u), \\dot{u}\\cos(u))$\n\nTo compute the $j$-th column of the Jacobian matrix $K$, we \"seed\" the derivative of the $j$-th input variable $u_j$ to $1$ and all others to $0$. We then evaluate the load vector $L(\\mathbf{u})$ using dual number arithmetic. The derivative parts of the resulting dual numbers for $L_1$ and $L_2$ will form the $j$-th column of the Jacobian.\n\nFor example, to compute the first column ($\\frac{\\partial L}{\\partial u_1}$), we set the inputs as:\n$$\nu_1^{\\text{AD}} = (u_1, 1), \\quad u_2^{\\text{AD}} = (u_2, 0)\n$$\nThen we compute the load vector components using dual arithmetic in the quadrature loop:\n$$\nu_h^{\\text{AD}}(\\xi_k) = N_1(\\xi_k) u_1^{\\text{AD}} + N_2(\\xi_k) u_2^{\\text{AD}}\n$$\n$$\nL_i^{\\text{AD}} = \\sum_{k=1}^{n_p} w_k N_i(\\xi_k) f(u_h^{\\text{AD}}(\\xi_k)) J\n$$\nThe result for each component will be a dual number $L_i^{\\text{AD}} = (L_i, \\frac{\\partial L_i}{\\partial u_1})$. The derivative part is the desired Jacobian entry. We repeat this process, seeding $u_2$ (i.e., $u_1^{\\text{AD}} = (u_1, 0), u_2^{\\text{AD}} = (u_2, 1)$), to obtain the second column.\n\nThis procedure mechanically calculates the exact same derivatives as the hand-derived formula, provided the quadrature is held constant, thus serving as an excellent verification tool. The implementation will follow this logic for the specified test cases.",
            "answer": "```python\nimport numpy as np\n\nclass Dual:\n    \"\"\"A simple Dual number class for forward-mode automatic differentiation.\"\"\"\n    def __init__(self, value, deriv=0.0):\n        self.value = value\n        self.deriv = deriv\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value + other.value, self.deriv + other.deriv)\n        return Dual(self.value + other, self.deriv)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value - other.value, self.deriv - other.deriv)\n        return Dual(self.value - other, self.deriv)\n\n    def __rsub__(self, other):\n        return Dual(other - self.value, -self.deriv)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value * other.value, self.deriv * other.value + self.value * other.deriv)\n        return Dual(self.value * other, self.deriv * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __pow__(self, power):\n        val = self.value ** power\n        der = power * (self.value ** (power - 1)) * self.deriv\n        return Dual(val, der)\n    \n    def __repr__(self):\n        return f\"Dual(value={self.value}, deriv={self.deriv})\"\n\n# Overload math functions for Dual numbers\ndef sin(d):\n    return Dual(np.sin(d.value), d.deriv * np.cos(d.value))\n\ndef cos(d):\n    return Dual(np.cos(d.value), -d.deriv * np.sin(d.value))\n\ndef exp(d):\n    return Dual(np.exp(d.value), d.deriv * np.exp(d.value))\n\n\ndef solve():\n    \"\"\"\n    Computes and verifies the Jacobian of a nonlinear element load vector using\n    both hand-derivation and automatic differentiation.\n    \"\"\"\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            \"x1\": 0.0, \"x2\": 1.0, \"u1\": 0.3, \"u2\": -0.2, \"order\": 5,\n            \"f\": lambda u: np.sin(u) + u**3,\n            \"f_prime\": lambda u: np.cos(u) + 3 * u**2,\n            \"f_ad\": lambda u: sin(u) + u**3\n        },\n        {\n            \"x1\": 0.0, \"x2\": 0.01, \"u1\": -0.5, \"u2\": 0.8, \"order\": 5,\n            \"f\": lambda u: np.exp(u) + u**5,\n            \"f_prime\": lambda u: np.exp(u) + 5 * u**4,\n            \"f_ad\": lambda u: exp(u) + u**5\n        },\n        {\n            \"x1\": -2.0, \"x2\": 2.0, \"u1\": 0.0, \"u2\": 0.0, \"order\": 3,\n            \"f\": lambda u: np.cos(u) + u**3,\n            \"f_prime\": lambda u: -np.sin(u) + 3 * u**2,\n            \"f_ad\": lambda u: cos(u) + u**3\n        },\n        {\n            \"x1\": -0.2, \"x2\": 1.3, \"u1\": 5.0, \"u2\": -4.0, \"order\": 7,\n            \"f\": lambda u: u * np.exp(u) + np.sin(u),\n            \"f_prime\": lambda u: (1 + u) * np.exp(u) + np.cos(u),\n            \"f_ad\": lambda u: u * exp(u) + sin(u)\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x1, x2, u1, u2 = case[\"x1\"], case[\"x2\"], case[\"u1\"], case[\"u2\"]\n        order = case[\"order\"]\n        f_prime = case[\"f_prime\"]\n        f_ad = case[\"f_ad\"]\n        \n        # 1. Common setup\n        J_map = (x2 - x1) / 2.0\n        xi_points, weights = np.polynomial.legendre.leggauss(order)\n        N_vals = np.array([(1 - xi_points) / 2.0, (1 + xi_points) / 2.0]) # Shape functions evaluated at GPs\n\n        # 2. Hand-derived Jacobian\n        K_hand = np.zeros((2, 2))\n        for k in range(order):\n            # Evaluate shape functions at Gauss point k\n            N1_k, N2_k = N_vals[0, k], N_vals[1, k]\n            \n            # Evaluate uh at Gauss point k\n            u_h_k = N1_k * u1 + N2_k * u2\n            \n            # Evaluate f'(uh) at Gauss point k\n            f_prime_uh_k = f_prime(u_h_k)\n            \n            # Form outer product of shape functions\n            N_outer = np.outer([N1_k, N2_k], [N1_k, N2_k])\n            \n            # Accumulate contribution to Jacobian\n            K_hand += weights[k] * f_prime_uh_k * N_outer * J_map\n            \n        # 3. Automatic Differentiation Jacobian\n        K_ad = np.zeros((2, 2))\n        \n        # Compute column 1 (derivatives with respect to u1)\n        u1_ad = Dual(u1, 1.0)\n        u2_ad = Dual(u2, 0.0)\n        L_ad = [Dual(0.0, 0.0), Dual(0.0, 0.0)]\n        for k in range(order):\n            N1_k, N2_k = N_vals[0, k], N_vals[1, k]\n            u_h_ad_k = N1_k * u1_ad + N2_k * u2_ad\n            f_uh_ad = f_ad(u_h_ad_k)\n            \n            L_ad[0] += N1_k * f_uh_ad * weights[k] * J_map\n            L_ad[1] += N2_k * f_uh_ad * weights[k] * J_map\n        \n        K_ad[0, 0] = L_ad[0].deriv\n        K_ad[1, 0] = L_ad[1].deriv\n        \n        # Compute column 2 (derivatives with respect to u2)\n        u1_ad = Dual(u1, 0.0)\n        u2_ad = Dual(u2, 1.0)\n        L_ad = [Dual(0.0, 0.0), Dual(0.0, 0.0)]\n        for k in range(order):\n            N1_k, N2_k = N_vals[0, k], N_vals[1, k]\n            u_h_ad_k = N1_k * u1_ad + N2_k * u2_ad\n            f_uh_ad = f_ad(u_h_ad_k)\n\n            L_ad[0] += N1_k * f_uh_ad * weights[k] * J_map\n            L_ad[1] += N2_k * f_uh_ad * weights[k] * J_map\n            \n        K_ad[0, 1] = L_ad[0].deriv\n        K_ad[1, 1] = L_ad[1].deriv\n        \n        # 4. Verification\n        max_abs_diff = np.max(np.abs(K_hand - K_ad))\n        is_match = max_abs_diff < 1e-12\n        results.append(is_match)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}