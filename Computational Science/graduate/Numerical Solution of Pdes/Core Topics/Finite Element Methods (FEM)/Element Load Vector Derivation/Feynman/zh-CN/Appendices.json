{
    "hands_on_practices": [
        {
            "introduction": "这个首要的练习将引导您完整地走过有限元载荷向量的组装过程。通过解决一个简单的一维问题，您将看到在参考单元上使用数值积分计算出的局部贡献，如何系统地组合成全局的右端向量。这个实践巩固了所有有限元软件所依赖的核心机制。",
            "id": "3383737",
            "problem": "考虑区间 $[0,2]$ 上标量场 $u(x)$ 的一维边值问题，该问题由二阶线性偏微分方程(PDE) $-u''(x)=f(x)$ 和齐次狄利克雷(Dirichlet)边界条件 $u(0)=0$ 及 $u(2)=0$ 控制。从弱形式出发——该弱形式通过将PDE乘以索伯列夫(Sobolev)空间 $H_{0}^{1}([0,2])$ 中的任意检验函数 $v(x)$ 并进行分部积分得到——使用有限元法(FEM)对问题进行离散化。离散化采用连续分片线性拉格朗日(Lagrange)基函数，网格节点位于 $x_{0}=0$、$x_{1}=1$ 和 $x_{2}=2$，从而形成两个单元 $[0,1]$ 和 $[1,2]$。设源项为 $f(x)=1+x$。仅使用弱形式、参考单元形函数以及从参考域到每个物理单元的仿射映射的基本定义，推导单元级右端项的贡献，并将它们组装成全局右端(RHS)载荷向量。为计算单元积分，请在标准区间 $[-1,1]$ 上使用最低阶的高斯求积(GQ)，该方法能为这些基函数和此源项产生精确的矩。证明组装后的全局RHS向量等于三个全局基函数 $N_{0}(x)$、$N_{1}(x)$ 和 $N_{2}(x)$ 的精确全局矩 $\\int_{0}^{2} f(x) N_{i}(x)\\,\\mathrm{d}x$。以一个包含三个元素的单行矩阵形式，提供最终组装的全局RHS载荷向量。",
            "solution": "所提出的问题是将有限元法(FEM)应用于一维边值问题的一个标准的、定义明确的练习。所有必要的组成部分均已提供，且在科学上和数学上是一致的。该问题是有效的，并存在唯一的可验证解。\n\n控制微分方程为一维泊松(Poisson)方程：\n$$\n-u''(x) = f(x) \\quad \\text{for } x \\in [0, 2]\n$$\n源项为 $f(x) = 1+x$，齐次狄利克雷(Dirichlet)边界条件为 $u(0)=0$ 和 $u(2)=0$。\n\n第一步是推导弱形式。我们将方程乘以一个检验函数 $v(x)$（该函数来自求解空间 $H_{0}^{1}([0,2])$），并在域 $\\Omega = [0,2]$ 上积分：\n$$\n-\\int_{0}^{2} u''(x) v(x) \\, \\mathrm{d}x = \\int_{0}^{2} f(x) v(x) \\, \\mathrm{d}x\n$$\n对左侧(LHS)应用分部积分得到：\n$$\n\\int_{0}^{2} u'(x) v'(x) \\, \\mathrm{d}x - [u'(x)v(x)]_{0}^{2} = \\int_{0}^{2} f(x) v(x) \\, \\mathrm{d}x\n$$\n由于检验函数 $v(x) \\in H_{0}^{1}([0,2])$，它必须满足齐次边界条件 $v(0)=0$ 和 $v(2)=0$。因此，边界项 $[u'(x)v(x)]_{0}^{2}$ 为零。问题的弱形式为：求 $u(x) \\in H_{0}^{1}([0,2])$，使得\n$$\n\\int_{0}^{2} u'(x) v'(x) \\, \\mathrm{d}x = \\int_{0}^{2} f(x) v(x) \\, \\mathrm{d}x \\quad \\forall v(x) \\in H_{0}^{1}([0,2])\n$$\n其形式为 $a(u,v) = L(v)$，其中 $a(u,v)$ 是双线性形式，$L(v)$ 是表示载荷的线性泛函。\n\n在有限元法中，我们离散化域并将解 $u(x)$ 近似为基函数 $N_j(x)$ 的线性组合：$u_h(x) = \\sum_{j=0}^{2} u_j N_j(x)$。问题指定了在节点为 $x_0=0, x_1=1, x_2=2$ 的网格上使用连续分片线性拉格朗日(Lagrange)基函数。这将域划分为两个单元：$\\Omega_1 = [0,1]$ 和 $\\Omega_2 = [1,2]$。离散问题通过对每个基函数 $N_i(x)$ 进行检验（即设 $v(x) = N_i(x)$）得到，从而导出一个线性方程组 $\\mathbf{K}\\mathbf{u} = \\mathbf{F}$，其中 $\\mathbf{K}$ 是刚度矩阵，$\\mathbf{F}$ 是全局载荷向量。载荷向量的分量由 $F_i = L(N_i)$ 给出，即：\n$$\nF_i = \\int_{0}^{2} f(x) N_i(x) \\, \\mathrm{d}x\n$$\n问题要求推导此向量 $\\mathbf{F}$ 及其分量 $F_0, F_1, F_2$。该积分由单元级贡献组装而成：\n$$\nF_i = \\sum_{e=1}^{2} F_i^{(e)} = \\sum_{e=1}^{2} \\int_{\\Omega_e} f(x) N_i(x) \\, \\mathrm{d}x\n$$\n为计算这些积分，我们使用一个从带有坐标 $\\xi$ 的参考单元 $\\hat{\\Omega} = [-1,1]$ 到每个物理单元 $\\Omega_e = [x_L, x_R]$ 的仿射映射。该映射为 $x(\\xi) = x_L + \\frac{h_e}{2}(1+\\xi)$，其中 $h_e = x_R - x_L$ 是单元长度。另一种常见的形式是 $x(\\xi) = \\frac{x_R-x_L}{2}\\xi + \\frac{x_R+x_L}{2}$。微分元变换为 $\\mathrm{d}x = J_e \\, \\mathrm{d}\\xi$，其中雅可比(Jacobian)为 $J_e = \\frac{\\mathrm{d}x}{\\mathrm{d}\\xi} = \\frac{h_e}{2}$。\n\n在参考单元 $\\hat{\\Omega}=[-1,1]$ 上，与局部节点 $\\xi=-1$ 和 $\\xi=1$ 相关联的线性拉格朗日(Lagrange)形函数为：\n$$\n\\hat{N}_a(\\xi) = \\frac{1}{2}(1-\\xi) \\quad \\text{and} \\quad \\hat{N}_b(\\xi) = \\frac{1}{2}(1+\\xi)\n$$\n对于一个通用的基函数 $\\hat{N}$，单元积分变为：\n$$\nF^{(e)} = \\int_{x_L}^{x_R} f(x) N(x) \\, \\mathrm{d}x = \\int_{-1}^{1} f(x(\\xi)) \\hat{N}(\\xi) J_e \\, \\mathrm{d}\\xi\n$$\n被积函数为 $I(\\xi) = f(x(\\xi)) \\hat{N}(\\xi) J_e$。由于 $f(x)=1+x$ 是一个线性多项式，且映射 $x(\\xi)$ 是线性的，因此 $f(x(\\xi))$ 是一个关于 $\\xi$ 的线性多项式。形函数 $\\hat{N}(\\xi)$ 也是一个关于 $\\xi$ 的线性多项式。雅可比(Jacobian) $J_e$ 是一个常数。因此，被积函数 $I(\\xi)$ 是一个关于 $\\xi$ 的二次多项式。\n\n具有 $n$ 个点的高斯求积法则对于次数最高为 $2n-1$ 的多项式是精确的。为了精确地对一个二次多项式（次数 $m=2$）进行积分，我们需要 $2n-1 \\ge 2$，这意味着 $n \\ge 1.5$。因此，求积点的最小整数数量为 $n=2$。在 $[-1,1]$ 上的2点高斯求积法则使用求积点 $\\xi_{1,2} = \\mp \\frac{1}{\\sqrt{3}}$ 和权重 $w_{1,2} = 1$。\n\n**单元1：$\\Omega_1 = [0,1]$**\n单元长度为 $h_1 = 1-0=1$。节点为 $x_0=0$ 和 $x_1=1$。\n映射：$x(\\xi) = \\frac{1}{2}\\xi + \\frac{1}{2}$。\n雅可比：$J_1 = \\frac{h_1}{2} = \\frac{1}{2}$。\n源项：$f(x(\\xi)) = 1+x(\\xi) = 1 + (\\frac{1}{2}\\xi + \\frac{1}{2}) = \\frac{3}{2} + \\frac{1}{2}\\xi$。\n局部贡献作用于全局节点 $0$ 和 $1$。\n$F_0^{(1)} = \\int_0^1 f(x) N_0(x) \\, \\mathrm{d}x = \\int_{-1}^1 (\\frac{3}{2} + \\frac{1}{2}\\xi) \\hat{N}_a(\\xi) J_1 \\, \\mathrm{d}\\xi$。被积函数为 $I_0(\\xi) = (\\frac{3}{2} + \\frac{1}{2}\\xi) \\frac{1}{2}(1-\\xi) \\frac{1}{2} = \\frac{1}{8}(3+\\xi)(1-\\xi)$。\n$F_0^{(1)} = \\sum_{k=1}^2 w_k I_0(\\xi_k) = I_0(-\\frac{1}{\\sqrt{3}}) + I_0(\\frac{1}{\\sqrt{3}})$。\n$I_0(-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 - \\frac{1}{\\sqrt{3}})(1 + \\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 + \\frac{3}{\\sqrt{3}} - \\frac{1}{\\sqrt{3}} - \\frac{1}{3}) = \\frac{1}{8}(\\frac{8}{3} + \\frac{2}{\\sqrt{3}})$。\n$I_0(+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 + \\frac{1}{\\sqrt{3}})(1 - \\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 - \\frac{3}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} - \\frac{1}{3}) = \\frac{1}{8}(\\frac{8}{3} - \\frac{2}{\\sqrt{3}})$。\n$F_0^{(1)} = \\frac{1}{8}(\\frac{8}{3} + \\frac{2}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{8}{3} - \\frac{2}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{16}{3}) = \\frac{2}{3}$。\n\n$F_1^{(1)} = \\int_0^1 f(x) N_1(x) \\, \\mathrm{d}x = \\int_{-1}^1 (\\frac{3}{2} + \\frac{1}{2}\\xi) \\hat{N}_b(\\xi) J_1 \\, \\mathrm{d}\\xi$。被积函数为 $I_1(\\xi) = \\frac{1}{8}(3+\\xi)(1+\\xi)$。\n$F_1^{(1)} = I_1(-\\frac{1}{\\sqrt{3}}) + I_1(\\frac{1}{\\sqrt{3}})$。\n$I_1(-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3-\\frac{1}{\\sqrt{3}})(1-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 - \\frac{3}{\\sqrt{3}} - \\frac{1}{\\sqrt{3}} + \\frac{1}{3}) = \\frac{1}{8}(\\frac{10}{3} - \\frac{4}{\\sqrt{3}})$。\n$I_1(+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3+\\frac{1}{\\sqrt{3}})(1+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 + \\frac{3}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} + \\frac{1}{3}) = \\frac{1}{8}(\\frac{10}{3} + \\frac{4}{\\sqrt{3}})$。\n$F_1^{(1)} = \\frac{1}{8}(\\frac{10}{3} - \\frac{4}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{10}{3} + \\frac{4}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{20}{3}) = \\frac{5}{6}$。\n\n**单元2：$\\Omega_2 = [1,2]$**\n单元长度为 $h_2 = 2-1=1$。节点为 $x_1=1$ 和 $x_2=2$。\n映射：$x(\\xi) = \\frac{1}{2}\\xi + \\frac{3}{2}$。\n雅可比：$J_2 = \\frac{h_2}{2} = \\frac{1}{2}$。\n源项：$f(x(\\xi)) = 1+x(\\xi) = 1 + (\\frac{1}{2}\\xi + \\frac{3}{2}) = \\frac{5}{2} + \\frac{1}{2}\\xi$。\n局部贡献作用于全局节点 $1$ 和 $2$。\n$F_1^{(2)} = \\int_1^2 f(x) N_1(x) \\, \\mathrm{d}x = \\int_{-1}^1 (\\frac{5}{2} + \\frac{1}{2}\\xi) \\hat{N}_a(\\xi) J_2 \\, \\mathrm{d}\\xi$。被积函数为 $I_1(\\xi) = \\frac{1}{8}(5+\\xi)(1-\\xi)$。\n$F_1^{(2)} = I_1(-\\frac{1}{\\sqrt{3}}) + I_1(\\frac{1}{\\sqrt{3}})$。\n$I_1(-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5-\\frac{1}{\\sqrt{3}})(1+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 + \\frac{5}{\\sqrt{3}} - \\frac{1}{\\sqrt{3}} - \\frac{1}{3}) = \\frac{1}{8}(\\frac{14}{3} + \\frac{4}{\\sqrt{3}})$。\n$I_1(+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5+\\frac{1}{\\sqrt{3}})(1-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 - \\frac{5}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} - \\frac{1}{3}) = \\frac{1}{8}(\\frac{14}{3} - \\frac{4}{\\sqrt{3}})$。\n$F_1^{(2)} = \\frac{1}{8}(\\frac{14}{3} + \\frac{4}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{14}{3} - \\frac{4}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{28}{3}) = \\frac{7}{6}$。\n\n$F_2^{(2)} = \\int_1^2 f(x) N_2(x) \\, \\mathrm{d}x = \\int_{-1}^1 (\\frac{5}{2} + \\frac{1}{2}\\xi) \\hat{N}_b(\\xi) J_2 \\, \\mathrm{d}\\xi$。被积函数为 $I_2(\\xi) = \\frac{1}{8}(5+\\xi)(1+\\xi)$。\n$F_2^{(2)} = I_2(-\\frac{1}{\\sqrt{3}}) + I_2(\\frac{1}{\\sqrt{3}})$。\n$I_2(-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5-\\frac{1}{\\sqrt{3}})(1-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 - \\frac{5}{\\sqrt{3}} - \\frac{1}{\\sqrt{3}} + \\frac{1}{3}) = \\frac{1}{8}(\\frac{16}{3} - \\frac{6}{\\sqrt{3}})$。\n$I_2(+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5+\\frac{1}{\\sqrt{3}})(1+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 + \\frac{5}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} + \\frac{1}{3}) = \\frac{1}{8}(\\frac{16}{3} + \\frac{6}{\\sqrt{3}})$。\n$F_2^{(2)} = \\frac{1}{8}(\\frac{16}{3} - \\frac{6}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{16}{3} + \\frac{6}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{32}{3}) = \\frac{4}{3}$。\n\n**全局RHS向量的组装**\n全局载荷向量 $\\mathbf{F}$ 是通过将相应全局节点索引处的单元贡献相加而形成的。\n$F_0 = F_0^{(1)} = \\frac{2}{3}$。\n$F_1 = F_1^{(1)} + F_1^{(2)} = \\frac{5}{6} + \\frac{7}{6} = \\frac{12}{6} = 2$。\n$F_2 = F_2^{(2)} = \\frac{4}{3}$。\n组装后的全局RHS向量为 $\\mathbf{F} = \\begin{pmatrix} \\frac{2}{3} & 2 & \\frac{4}{3} \\end{pmatrix}^T$。\n\n**通过精确积分进行验证**\n我们通过直接计算全局矩来验证此结果。全局基函数为：\n$N_0(x) = \\begin{cases} 1-x & x \\in [0,1] \\\\ 0 & \\text{otherwise} \\end{cases}$\n$N_1(x) = \\begin{cases} x & x \\in [0,1] \\\\ 2-x & x \\in [1,2] \\end{cases}$\n$N_2(x) = \\begin{cases} x-1 & x \\in [1,2] \\\\ 0 & \\text{otherwise} \\end{cases}$\n\n$F_0 = \\int_0^2 (1+x)N_0(x)\\,\\mathrm{d}x = \\int_0^1 (1+x)(1-x)\\,\\mathrm{d}x = \\int_0^1 (1-x^2)\\,\\mathrm{d}x = [x - \\frac{x^3}{3}]_0^1 = 1 - \\frac{1}{3} = \\frac{2}{3}$。结果相符。\n\n$F_1 = \\int_0^2 (1+x)N_1(x)\\,\\mathrm{d}x = \\int_0^1 (1+x)x\\,\\mathrm{d}x + \\int_1^2 (1+x)(2-x)\\,\\mathrm{d}x$。\n$\\int_0^1 (x+x^2)\\,\\mathrm{d}x = [\\frac{x^2}{2}+\\frac{x^3}{3}]_0^1 = \\frac{1}{2}+\\frac{1}{3} = \\frac{5}{6}$。\n$\\int_1^2 (2+x-x^2)\\,\\mathrm{d}x = [2x+\\frac{x^2}{2}-\\frac{x^3}{3}]_1^2 = (4+2-\\frac{8}{3}) - (2+\\frac{1}{2}-\\frac{1}{3}) = (\\frac{10}{3}) - (\\frac{13}{6}) = \\frac{20-13}{6} = \\frac{7}{6}$。\n$F_1 = \\frac{5}{6} + \\frac{7}{6} = \\frac{12}{6} = 2$。结果相符。\n\n$F_2 = \\int_0^2 (1+x)N_2(x)\\,\\mathrm{d}x = \\int_1^2 (1+x)(x-1)\\,\\mathrm{d}x = \\int_1^2 (x^2-1)\\,\\mathrm{d}x = [\\frac{x^3}{3}-x]_1^2 = (\\frac{8}{3}-2) - (\\frac{1}{3}-1) = \\frac{2}{3} - (-\\frac{2}{3}) = \\frac{4}{3}$。结果相符。\n\n使用高斯求积的计算被证实是精确的，正如理论所预测的那样。最终组装的全局RHS载荷向量是正确的。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{2}{3} & 2 & \\frac{4}{3}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在一维案例的基础上，本练习将单元载荷向量的概念扩展到二维三角形单元。它特别考虑了在混合有限元方法（例如在流体力学问题中）中常见的分片常数（$P_0$）基函数。这个练习突出了核心原理——将源项与测试函数进行积分——如何适应不同的单元几何形状和函数空间。",
            "id": "3383766",
            "problem": "考虑一个定义在多边形区域上的标量椭圆型偏微分方程 (PDE) 的混合格式，其一阶形式写作 $p + \\nabla u = 0$ 和 $\\nabla \\cdot p = f$，其中 $p$ 是通量，$u$ 是标量势。在一个混合有限元方法中，设通量 $p$ 在最低阶 Raviart–Thomas 空间 $RT_0$ 中近似，标量场 $u$ 在分片常数空间 $P_0$ 中近似。在单个三角形单元 $K$ 上，与 $P_0$ 检验函数 $v$ 相关联的单元右端项（载荷向量）贡献是局部积分 $b_K = \\int_K f\\,v\\,dx$。\n\n假设 $K$ 是一个仿射三角形，其顶点为 $(1,2)$、$(5,3)$ 和 $(2,7)$。在该单元上，设源项为常数 $f(x) \\equiv f_0$（对所有 $x \\in K$），并选择 $P_0$ 检验函数为常数 $v(x) \\equiv c_K$（对所有 $x \\in K$）。取 $f_0 = 7$ 和 $c_K = 2$。仅使用第一性原理（弱形式和仿射映射的变量替换），计算单元载荷贡献 $b_K = \\int_K f\\,v\\,dx$ 的精确值。\n\n将最终答案表示为单个实数。无需四舍五入。",
            "solution": "该问题是有效的。它在偏微分方程数值方法领域内提出了一个清晰、独立且科学上合理的任务。所有必要的数据和定义都已提供，不存在矛盾或歧义。\n\n目标是计算单个三角形单元 $K$ 的单元载荷向量贡献 $b_K$。根据问题陈述，该贡献由以下积分定义：\n$$b_K = \\int_K f\\,v\\,dx$$\n其中 $K$ 是三角形单元区域，$f$ 是源项，$v$ 是检验函数。\n\n问题指明了以下几点：\n1. 单元 $K$ 是一个三角形，其顶点为 $V_1 = (1,2)$、$V_2 = (5,3)$ 和 $V_3 = (2,7)$。\n2. 源项 $f(x)$ 在单元 $K$ 上为常数，由 $f(x) \\equiv f_0 = 7$ 给出。\n3. 检验函数 $v(x)$ 来自于分片常数空间 $P_0$。在单元 $K$ 上，它被指定为常数 $v(x) \\equiv c_K = 2$。\n\n将给定的常数函数 $f$ 和 $v$ 代入 $b_K$ 的积分定义中，我们得到：\n$$b_K = \\int_K (f_0)(c_K)\\,dx$$\n由于 $f_0$ 和 $c_K$ 是常数，它们可以从积分中提出来：\n$$b_K = f_0 c_K \\int_K 1\\,dx$$\n剩下的积分 $\\int_K 1\\,dx$ 代表三角形单元 $K$ 的面积。我们将此面积记为 $|K|$。因此，$b_K$ 的表达式简化为：\n$$b_K = f_0 c_K |K|$$\n\n这个公式与有限元方法的第一性原理一致。该积分通常通过一个仿射映射 $x = F(\\hat{x})$ 将物理单元 $K$ 变换到参考单元 $\\hat{K}$ 来计算。积分随后变为 $\\int_{\\hat{K}} f(F(\\hat{x})) v(F(\\hat{x})) |\\det(J_F)| \\,d\\hat{x}$，其中 $|\\det(J_F)|$ 是映射的雅可比行列式的绝对值。对于仿射映射，该行列式是常数，并且如果 $\\hat{K}$ 是单位参考三角形（面积为 $\\frac{1}{2}$），则它等于 $2|K|$。因此，计算 $|K|$ 是核心的几何任务。\n\n我们可以使用三角形 $K$ 的顶点来计算其面积。一种方法是在行列式公式（鞋带公式的一个变体）中使用顶点的坐标。一个等效且物理上直观的方法是，将面积作为从同一顶点出发的两个边向量的叉积大小的一半来计算。\n\n让我们定义从顶点 $V_1$ 出发张成该三角形的两个向量：\n$$\\vec{a} = V_2 - V_1 = (5-1, 3-2) = (4, 1)$$\n$$\\vec{b} = V_3 - V_1 = (2-1, 7-2) = (1, 5)$$\n\n为了计算叉积，我们将这些向量嵌入到三维空间中，并令其 z 分量为零：$\\vec{a} = (4, 1, 0)$ 和 $\\vec{b} = (1, 5, 0)$。叉积为：\n$$\\vec{a} \\times \\vec{b} = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ 4 & 1 & 0 \\\\ 1 & 5 & 0 \\end{vmatrix} = \\mathbf{i}(1 \\cdot 0 - 0 \\cdot 5) - \\mathbf{j}(4 \\cdot 0 - 0 \\cdot 1) + \\mathbf{k}(4 \\cdot 5 - 1 \\cdot 1)$$\n$$\\vec{a} \\times \\vec{b} = (0)\\mathbf{i} - (0)\\mathbf{j} + (20 - 1)\\mathbf{k} = 19\\mathbf{k}$$\n所得向量的模为 $\\|\\vec{a} \\times \\vec{b}\\| = |19| = 19$。三角形的面积 $|K|$ 是此模的一半：\n$$|K| = \\frac{1}{2} \\|\\vec{a} \\times \\vec{b}\\| = \\frac{19}{2}$$\n\n现在我们拥有了计算 $b_K$ 的所有要素。将给定值 $f_0 = 7$，$c_K = 2$ 和计算出的面积 $|K| = \\frac{19}{2}$ 代入 $b_K$ 的表达式中：\n$$b_K = (7) \\cdot (2) \\cdot \\left(\\frac{19}{2}\\right)$$\n$$b_K = 7 \\cdot 19$$\n$$b_K = 133$$\n因此，单元载荷贡献的精确值为 $133$。",
            "answer": "$$\\boxed{133}$$"
        },
        {
            "introduction": "许多现实世界中的物理现象都是非线性的，这导致有限元系统中的载荷向量本身依赖于解。这个高级实践探讨了如何计算这种非线性单元载荷向量的雅可比矩阵，这是使用牛顿法等方法求解非线性偏微分方程的关键步骤。您将比较传统的解析推导与强大高效的自动微分（AD）技术，从而深入了解现代计算工作流程。",
            "id": "3383773",
            "problem": "考虑一个一维非线性强形式偏微分方程（PDE），其有限元法（FEM）残差包含一个由非线性函数 $f(u)$ 建模的源项。对于一个在物理坐标 $x_1$ 和 $x_2$ 处有节点的双节点线性单元，单元载荷向量通过标准伽辽金构造定义，即形函数与 $f(u_h)$ 的乘积的积分，其中 $u_h$ 是节点插值。使用此基础定义和经过充分检验的数值积分方法，推导、实现并验证单元载荷向量关于节点值的雅可比矩阵。\n\n基本依据：\n- 单元载荷向量分量 $L_i(u)$（其中 $i \\in \\{1,2\\}$）的定义为：在物理单元域上，第 $i$ 个形函数与在近似解 $u_h$ 处求值的非线性源函数的乘积的积分。此过程使用参考区间 $[-1,1]$ 上的标准双节点线性形函数以及到物理单元 $[x_1,x_2]$ 的标准仿射映射。\n- 近似解为 $u_h(x) = N_1(\\xi) u_1 + N_2(\\xi) u_2$，其中 $N_1(\\xi)$ 和 $N_2(\\xi)$ 是参考坐标 $\\xi \\in [-1,1]$ 上的标准线性形函数，仿射映射的雅可比行列式为 $(x_2 - x_1)/2$。\n- 数值积分必须在参考区间 $[-1,1]$ 上使用指定阶数的 Gauss-Legendre 求积法。\n\n您的任务：\n1. 实现前向模式自动微分（AD），以计算单元载荷向量 $L(u)$ 的雅可比矩阵（即关于节点值 $u_1$ 和 $u_2$ 的偏导数矩阵）。\n2. 从变分基础独立推导单元载荷向量的线性化，并使用相同的求积法则实现其计算，以获得手动推导的雅可比矩阵。\n3. 验证对于以下测试套件，由AD生成的项 $\\frac{dL_i}{du_j}$ 与通过手动推导的线性化获得的项相匹配。将所有量视为无量纲。\n\n参考单元和映射细节：\n- 参考区间为 $[-1,1]$。\n- 需使用 $[-1,1]$ 上的标准双节点线性形函数。\n- 物理单元映射必须是从 $[-1,1]$到 $[x_1,x_2]$ 的唯一仿射映射，其雅可比行列式为 $(x_2 - x_1)/2$。\n\n测试套件：\n- 情况 A（一般非线性，中等振幅）：$x_1 = 0$, $x_2 = 1$, $u_1 = 0.3$, $u_2 = -0.2$, $f(u) = \\sin(u) + u^3$，Gauss-Legendre 阶数 $5$。\n- 情况 B（小单元长度以测试缩放）：$x_1 = 0$, $x_2 = 0.01$, $u_1 = -0.5$, $u_2 = 0.8$, $f(u) = \\exp(u) + u^5$，Gauss-Legendre 阶数 $5$。\n- 情况 C（零解，导数抵消）：$x_1 = -2$, $x_2 = 2$, $u_1 = 0$, $u_2 = 0$, $f(u) = \\cos(u) + u^3$，Gauss-Legendre 阶数 $3$。\n- 情况 D（大振幅，混合非线性）：$x_1 = -0.2$, $x_2 = 1.3$, $u_1 = 5.0$, $u_2 = -4.0$, $f(u) = u \\exp(u) + \\sin(u)$，Gauss-Legendre 阶数 $7$。\n\n验证标准：\n- 对于每种情况，通过 AD 和手动推导的线性化计算雅可比矩阵，并使用雅可比矩阵各项之间的最大绝对差，检查在 $10^{-12}$ 的数值容差内是否相等。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一个布尔值，指示 AD 和手动推导的雅可比矩阵是否在容差范围内匹配（例如，$[\\text{True},\\text{False},\\text{True},\\text{True}]$）。",
            "solution": "该问题要求针对一维双节点线性有限元，推导并实现非线性单元载荷向量的雅可比矩阵。此雅可比矩阵将使用两种不同的方法计算：直接解析推导（手动推导）和前向模式自动微分（AD）。两种方法的结果必须在一系列测试用例中进行一致性验证。\n\n### 1. 基本公式\n\n设物理单元由区间 $[x_1, x_2]$ 定义。我们使用等参格式，通过仿射变换将由 $\\xi \\in [-1, 1]$ 定义的参考单元映射到物理单元：\n$$\nx(\\xi) = N_1(\\xi) x_1 + N_2(\\xi) x_2\n$$\n其中 $N_1(\\xi)$ 和 $N_2(\\xi)$ 是参考单元上的标准线性形函数：\n$$\nN_1(\\xi) = \\frac{1 - \\xi}{2}, \\quad N_2(\\xi) = \\frac{1 + \\xi}{2}\n$$\n物理坐标和参考坐标之间的微分关系由映射的雅可比行列式 $J$ 给出：\n$$\ndx = \\frac{dx}{d\\xi} d\\xi = J d\\xi\n$$\n其中\n$$\nJ = \\frac{dx}{d\\xi} = \\frac{d}{d\\xi} \\left( \\frac{1 - \\xi}{2} x_1 + \\frac{1 + \\xi}{2} x_2 \\right) = \\frac{x_2 - x_1}{2}\n$$\n单元内的近似解 $u_h$ 是使用相同的形函数从节点值 $u_1$ 和 $u_2$ 插值得到的：\n$$\nu_h(x) \\rightarrow u_h(\\xi) = N_1(\\xi) u_1 + N_2(\\xi) u_2\n$$\n单元载荷向量 $L$ 源于源项 $f(u)$ 的伽辽金公式。对于一个双节点单元，它是一个 $2 \\times 1$ 的向量，其分量 $L_i$ 由以下公式给出：\n$$\nL_i(\\mathbf{u}) = \\int_{x_1}^{x_2} N_i(x) f(u_h(x)) \\, dx\n$$\n其中 $\\mathbf{u} = [u_1, u_2]^T$。将该积分变换到参考坐标系，我们得到：\n$$\nL_i(\\mathbf{u}) = \\int_{-1}^{1} N_i(\\xi) f(u_h(\\xi)) J \\, d\\xi, \\quad i \\in \\{1, 2\\}\n$$\n该积分使用含 $n_p$ 个点的 Gauss-Legendre 求积法进行数值计算：\n$$\nL_i \\approx \\sum_{k=1}^{n_p} w_k N_i(\\xi_k) f(u_h(\\xi_k)) J\n$$\n其中 $\\xi_k$ 是高斯点，而 $w_k$ 是对应的权重。\n\n### 2. 手动推导的雅可比矩阵\n\n单元载荷向量的雅可比矩阵是一个 $2 \\times 2$ 矩阵 $K$，其分量为 $K_{ij} = \\frac{\\partial L_i}{\\partial u_j}$。我们通过对 $L_i$ 的积分表达式关于节点值 $u_j$ 求导来推导它。\n$$\nK_{ij} = \\frac{\\partial L_i}{\\partial u_j} = \\frac{\\partial}{\\partial u_j} \\left[ \\int_{-1}^{1} N_i(\\xi) f(u_h(\\xi)) J \\, d\\xi \\right]\n$$\n由于积分域和雅可比行列式 $J$ 与 $\\mathbf{u}$ 无关，我们可以将导数移到积分内部：\n$$\nK_{ij} = \\int_{-1}^{1} N_i(\\xi) \\frac{\\partial}{\\partial u_j} \\left[ f(u_h(\\xi)) \\right] J \\, d\\xi\n$$\n使用链式法则，我们有 $\\frac{\\partial}{\\partial u_j} [f(u_h)] = f'(u_h) \\frac{\\partial u_h}{\\partial u_j}$，其中 $f'(u_h)$ 是 $f$ 对其参数的导数，在 $u_h$ 处求值。插值解 $u_h$ 对节点值 $u_j$ 的导数就是相应的形函数：\n$$\n\\frac{\\partial u_h(\\xi)}{\\partial u_j} = \\frac{\\partial}{\\partial u_j} \\left[ N_1(\\xi) u_1 + N_2(\\xi) u_2 \\right] = N_j(\\xi)\n$$\n将此代回 $K_{ij}$ 的表达式，得到雅可比矩阵项的解析公式：\n$$\nK_{ij} = \\int_{-1}^{1} N_i(\\xi) f'(u_h(\\xi)) N_j(\\xi) J \\, d\\xi\n$$\n使用 Gauss-Legendre 求积法对此积分进行数值计算的结果是：\n$$\nK_{ij} \\approx \\sum_{k=1}^{n_p} w_k N_i(\\xi_k) f'(u_h(\\xi_k)) N_j(\\xi_k) J\n$$\n其中 $u_h(\\xi_k) = N_1(\\xi_k)u_1 + N_2(\\xi_k)u_2$。\n\n### 3. 前向模式自动微分（AD）\n\n前向模式 AD 通过将中间变量的导数与其值一同传播来计算函数的导数。这是通过定义一个`对偶`（Dual）数代数来实现的。对偶数是一个有序对 $(v, \\dot{v})$，表示值 $v$ 及其导数 $\\dot{v}$。它可以写成 $v + \\dot{v}\\epsilon$，其中 $\\epsilon$ 是一个幂零元素，满足 $\\epsilon^2 = 0$。\n\n设 $u = (u, \\dot{u})$ 和 $v = (v, \\dot{v})$。算术运算和初等函数被重载如下：\n- 加法/减法：$(u, \\dot{u}) \\pm (v, \\dot{v}) = (u \\pm v, \\dot{u} \\pm \\dot{v})$\n- 乘法：$(u, \\dot{u}) \\cdot (v, \\dot{v}) = (uv, u\\dot{v} + v\\dot{u})$\n- 函数应用（例如，$\\sin$）：$\\sin((u, \\dot{u})) = (\\sin(u), \\dot{u}\\cos(u))$\n\n为了计算雅可比矩阵 $K$ 的第 $j$ 列，我们将第 $j$ 个输入变量 $u_j$ 的导数“播种”为 1，所有其他变量的导数播种为 0。然后我们使用对偶数算术来评估载荷向量 $L(\\mathbf{u})$。得到的 $L_1$ 和 $L_2$ 对偶数的导数部分将构成雅可比矩阵的第 $j$ 列。\n\n例如，为了计算第一列（$\\frac{\\partial L}{\\partial u_1}$），我们将输入设置为：\n$$\nu_1^{\\text{AD}} = (u_1, 1), \\quad u_2^{\\text{AD}} = (u_2, 0)\n$$\n然后，我们在求积循环中使用对偶数算术计算载荷向量分量：\n$$\nu_h^{\\text{AD}}(\\xi_k) = N_1(\\xi_k) u_1^{\\text{AD}} + N_2(\\xi_k) u_2^{\\text{AD}}\n$$\n$$\nL_i^{\\text{AD}} = \\sum_{k=1}^{n_p} w_k N_i(\\xi_k) f(u_h^{\\text{AD}}(\\xi_k)) J\n$$\n每个分量的结果将是一个对偶数 $L_i^{\\text{AD}} = (L_i, \\frac{\\partial L_i}{\\partial u_1})$。导数部分就是所求的雅可比矩阵项。我们重复此过程，对 $u_2$ 进行播种（即，$u_1^{\\text{AD}} = (u_1, 0), u_2^{\\text{AD}} = (u_2, 1)$），以获得第二列。\n\n只要求积法保持不变，此过程就能机械地计算出与手动推导公式完全相同的导数，因此可作为一个极好的验证工具。实现将遵循此逻辑处理指定的测试用例。",
            "answer": "```python\nimport numpy as np\n\nclass Dual:\n    \"\"\"A simple Dual number class for forward-mode automatic differentiation.\"\"\"\n    def __init__(self, value, deriv=0.0):\n        self.value = value\n        self.deriv = deriv\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value + other.value, self.deriv + other.deriv)\n        return Dual(self.value + other, self.deriv)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value - other.value, self.deriv - other.deriv)\n        return Dual(self.value - other, self.deriv)\n\n    def __rsub__(self, other):\n        return Dual(other - self.value, -self.deriv)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value * other.value, self.deriv * other.value + self.value * other.deriv)\n        return Dual(self.value * other, self.deriv * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __pow__(self, power):\n        val = self.value ** power\n        der = power * (self.value ** (power - 1)) * self.deriv\n        return Dual(val, der)\n    \n    def __repr__(self):\n        return f\"Dual(value={self.value}, deriv={self.deriv})\"\n\n# Overload math functions for Dual numbers\ndef sin(d):\n    return Dual(np.sin(d.value), d.deriv * np.cos(d.value))\n\ndef cos(d):\n    return Dual(np.cos(d.value), -d.deriv * np.sin(d.value))\n\ndef exp(d):\n    return Dual(np.exp(d.value), d.deriv * np.exp(d.value))\n\n\ndef solve():\n    \"\"\"\n    Computes and verifies the Jacobian of a nonlinear element load vector using\n    both hand-derivation and automatic differentiation.\n    \"\"\"\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            \"x1\": 0.0, \"x2\": 1.0, \"u1\": 0.3, \"u2\": -0.2, \"order\": 5,\n            \"f\": lambda u: np.sin(u) + u**3,\n            \"f_prime\": lambda u: np.cos(u) + 3 * u**2,\n            \"f_ad\": lambda u: sin(u) + u**3\n        },\n        {\n            \"x1\": 0.0, \"x2\": 0.01, \"u1\": -0.5, \"u2\": 0.8, \"order\": 5,\n            \"f\": lambda u: np.exp(u) + u**5,\n            \"f_prime\": lambda u: np.exp(u) + 5 * u**4,\n            \"f_ad\": lambda u: exp(u) + u**5\n        },\n        {\n            \"x1\": -2.0, \"x2\": 2.0, \"u1\": 0.0, \"u2\": 0.0, \"order\": 3,\n            \"f\": lambda u: np.cos(u) + u**3,\n            \"f_prime\": lambda u: -np.sin(u) + 3 * u**2,\n            \"f_ad\": lambda u: cos(u) + u**3\n        },\n        {\n            \"x1\": -0.2, \"x2\": 1.3, \"u1\": 5.0, \"u2\": -4.0, \"order\": 7,\n            \"f\": lambda u: u * np.exp(u) + np.sin(u),\n            \"f_prime\": lambda u: (1 + u) * np.exp(u) + np.cos(u),\n            \"f_ad\": lambda u: u * exp(u) + sin(u)\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x1, x2, u1, u2 = case[\"x1\"], case[\"x2\"], case[\"u1\"], case[\"u2\"]\n        order = case[\"order\"]\n        f_prime = case[\"f_prime\"]\n        f_ad = case[\"f_ad\"]\n        \n        # 1. Common setup\n        J_map = (x2 - x1) / 2.0\n        xi_points, weights = np.polynomial.legendre.leggauss(order)\n        N_vals = np.array([(1 - xi_points) / 2.0, (1 + xi_points) / 2.0]) # Shape functions evaluated at GPs\n\n        # 2. Hand-derived Jacobian\n        K_hand = np.zeros((2, 2))\n        for k in range(order):\n            # Evaluate shape functions at Gauss point k\n            N1_k, N2_k = N_vals[0, k], N_vals[1, k]\n            \n            # Evaluate uh at Gauss point k\n            u_h_k = N1_k * u1 + N2_k * u2\n            \n            # Evaluate f'(uh) at Gauss point k\n            f_prime_uh_k = f_prime(u_h_k)\n            \n            # Form outer product of shape functions\n            N_outer = np.outer([N1_k, N2_k], [N1_k, N2_k])\n            \n            # Accumulate contribution to Jacobian\n            K_hand += weights[k] * f_prime_uh_k * N_outer * J_map\n            \n        # 3. Automatic Differentiation Jacobian\n        K_ad = np.zeros((2, 2))\n        \n        # Compute column 1 (derivatives with respect to u1)\n        u1_ad = Dual(u1, 1.0)\n        u2_ad = Dual(u2, 0.0)\n        L_ad = [Dual(0.0, 0.0), Dual(0.0, 0.0)]\n        for k in range(order):\n            N1_k, N2_k = N_vals[0, k], N_vals[1, k]\n            u_h_ad_k = N1_k * u1_ad + N2_k * u2_ad\n            f_uh_ad = f_ad(u_h_ad_k)\n            \n            L_ad[0] += N1_k * f_uh_ad * weights[k] * J_map\n            L_ad[1] += N2_k * f_uh_ad * weights[k] * J_map\n        \n        K_ad[0, 0] = L_ad[0].deriv\n        K_ad[1, 0] = L_ad[1].deriv\n        \n        # Compute column 2 (derivatives with respect to u2)\n        u1_ad = Dual(u1, 0.0)\n        u2_ad = Dual(u2, 1.0)\n        L_ad = [Dual(0.0, 0.0), Dual(0.0, 0.0)]\n        for k in range(order):\n            N1_k, N2_k = N_vals[0, k], N_vals[1, k]\n            u_h_ad_k = N1_k * u1_ad + N2_k * u2_ad\n            f_uh_ad = f_ad(u_h_ad_k)\n\n            L_ad[0] += N1_k * f_uh_ad * weights[k] * J_map\n            L_ad[1] += N2_k * f_uh_ad * weights[k] * J_map\n            \n        K_ad[0, 1] = L_ad[0].deriv\n        K_ad[1, 1] = L_ad[1].deriv\n        \n        # 4. Verification\n        max_abs_diff = np.max(np.abs(K_hand - K_ad))\n        is_match = max_abs_diff  1e-12\n        results.append(is_match)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}