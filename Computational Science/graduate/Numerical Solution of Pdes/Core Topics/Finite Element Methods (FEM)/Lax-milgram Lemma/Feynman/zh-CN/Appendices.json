{
    "hands_on_practices": [
        {
            "introduction": "Lax-Milgram引理的第一个关键假设是双线性型的连续性（或称有界性），即存在一个常数 $M$ 使得 $|a(u,v)| \\le M \\|u\\| \\|v\\|$。估算这个连续性常数是应用该引理的基础步骤。下面的练习 () 将指导你对一个来源于扩散-反应方程的典型双线性型，利用Cauchy–Schwarz不等式和Poincaré不等式等基本工具，具体地推导出一个连续性常数 $M$。",
            "id": "3414246",
            "problem": "考虑 Sobolev 空间 $H_{0}^{1}(0,1)$，它由满足 $u(0)=u(1)=0$ 的函数 $u \\in H^{1}(0,1)$ 构成。在偏微分方程（PDE）的数值解法中，一个常见的 $H_{0}^{1}(0,1)$ 上的 Galerkin 双线性形式由一个扩散-反应算子产生，其结构如下\n$$\na(u,v) \\;=\\; \\int_{0}^{1} \\big( \\alpha(x)\\, u'(x)\\, v'(x) \\;+\\; \\beta(x)\\, u(x)\\, v(x) \\big)\\, dx,\n$$\n其中 $\\alpha,\\beta \\in L^{\\infty}(0,1)$ 是给定的系数函数。通过取如下函数构造一个具体例子\n$$\n\\alpha(x) \\;=\\; 2 + \\sin(2\\pi x), \\qquad \\beta(x) \\;=\\; x,\n$$\n并考虑 $a(\\cdot,\\cdot)$ 关于由梯度诱导的范数（即 $\\|u\\|_{H_{0}^{1}(0,1)} := \\|u'\\|_{L^{2}(0,1)}$）的连续性。\n\n从基本定义、Cauchy–Schwarz 不等式、本性上确界的性质以及 $(0,1)$ 上关于 $H_{0}^{1}(0,1)$ 函数的 Poincaré 不等式出发，推导您能证明的最小常数 $M$，使得\n$$\n|a(u,v)| \\;\\le\\; M\\, \\|u'\\|_{L^{2}(0,1)}\\, \\|v'\\|_{L^{2}(0,1)} \\quad \\text{对所有 } u,v \\in H_{0}^{1}(0,1).\n$$\n您的最终答案必须是根据您明确的 $\\alpha$ 和 $\\beta$ 所产生的量表示的单个闭式表达式。无需四舍五入；请给出精确表达式。",
            "solution": "我们首先回顾相关的结构。空间 $H_{0}^{1}(0,1)$ 是 $C_{c}^{\\infty}(0,1)$ 在 $H^{1}$ 范数下的闭包，且 $H_{0}^{1}(0,1)$ 中的函数在迹意义下满足 Dirichlet 边界条件 $u(0)=u(1)=0$。双线性形式\n$$\na(u,v) \\;=\\; \\int_{0}^{1} \\big( \\alpha(x)\\, u'(x)\\, v'(x) \\;+\\; \\beta(x)\\, u(x)\\, v(x) \\big)\\, dx\n$$\n当 $\\alpha,\\beta \\in L^{\\infty}(0,1)$ 时，对于 $u,v \\in H_{0}^{1}(0,1)$ 是良定义的，因为 $u',v' \\in L^{2}(0,1)$ 且 $u,v \\in L^{2}(0,1)$，这使得乘积 $\\alpha u' v'$ 和 $\\beta u v$ 可积。\n\n我们的目标是用 $\\|u'\\|_{L^{2}(0,1)}$ 和 $\\|v'\\|_{L^{2}(0,1)}$ 来界定 $|a(u,v)|$。使用三角不等式和 Cauchy–Schwarz 不等式，我们分别估计每一项：\n\n$$\n\\left| \\int_{0}^{1} \\alpha(x)\\, u'(x)\\, v'(x)\\, dx \\right|\n\\;\\le\\; \\|\\alpha\\|_{L^{\\infty}(0,1)}\\, \\|u'\\|_{L^{2}(0,1)}\\, \\|v'\\|_{L^{2}(0,1)}.\n$$\n\n对于反应项，我们首先使用本性上确界进行界定，然后使用 Poincaré 不等式。对于 $H_{0}^{1}(0,1)$ 中的函数，在 $(0,1)$ 上的 Poincaré 不等式表明，存在一个常数 $C_{P}>0$ 使得\n\n$$\n\\|u\\|_{L^{2}(0,1)} \\;\\le\\; C_{P}\\, \\|u'\\|_{L^{2}(0,1)} \\quad \\text{对所有 } u \\in H_{0}^{1}(0,1).\n$$\n\n在具有 Dirichlet 边界条件的区间 $(0,1)$ 上，最佳（最小）常数是 $C_{P} = \\frac{1}{\\pi}$，该常数由 $-d^{2}/dx^{2}$ 的第一 Dirichlet 特征值 $\\lambda_{1}=\\pi^{2}$ 以及不等式 $\\|u\\|_{L^{2}}^{2} \\le \\frac{1}{\\lambda_{1}} \\|u'\\|_{L^{2}}^{2}$ 导出。\n\n因此，\n\n$$\n\\left| \\int_{0}^{1} \\beta(x)\\, u(x)\\, v(x)\\, dx \\right|\n\\;\\le\\; \\|\\beta\\|_{L^{\\infty}(0,1)}\\, \\|u\\|_{L^{2}(0,1)}\\, \\|v\\|_{L^{2}(0,1)}\n\\;\\le\\; \\|\\beta\\|_{L^{\\infty}(0,1)}\\, C_{P}^{2}\\, \\|u'\\|_{L^{2}(0,1)}\\, \\|v'\\|_{L^{2}(0,1)}.\n$$\n\n结合这两个界，我们得到\n\n$$\n|a(u,v)| \\;\\le\\; \\big( \\|\\alpha\\|_{L^{\\infty}(0,1)} \\;+\\; C_{P}^{2}\\, \\|\\beta\\|_{L^{\\infty}(0,1)} \\big)\\, \\|u'\\|_{L^{2}(0,1)}\\, \\|v'\\|_{L^{2}(0,1)}.\n$$\n\n因此，一个有效的连续性常数是\n\n$$\nM \\;=\\; \\|\\alpha\\|_{L^{\\infty}(0,1)} \\;+\\; C_{P}^{2}\\, \\|\\beta\\|_{L^{\\infty}(0,1)}.\n$$\n\n根据我们给出的具体选择，\n\n$$\n\\alpha(x) \\;=\\; 2 + \\sin(2\\pi x) \\quad \\Rightarrow \\quad \\|\\alpha\\|_{L^{\\infty}(0,1)} \\;=\\; \\sup_{x \\in (0,1)} |2+\\sin(2\\pi x)| \\;=\\; 3,\n$$\n\n因为 $\\sin(2\\pi x) \\in [-1,1]$。同样地，\n\n$$\n\\beta(x) \\;=\\; x \\quad \\Rightarrow \\quad \\|\\beta\\|_{L^{\\infty}(0,1)} \\;=\\; \\sup_{x \\in (0,1)} |x| \\;=\\; 1.\n$$\n\n使用最佳 Poincaré 常数 $C_{P} = \\frac{1}{\\pi}$，我们得到\n\n$$\nM \\;=\\; 3 \\;+\\; \\left( \\frac{1}{\\pi} \\right)^{2} \\cdot 1 \\;=\\; 3 + \\frac{1}{\\pi^{2}}.\n$$\n\n对于所采用的界定策略，这个常数是锐利的：扩散项的贡献由 $\\|\\alpha\\|_{L^{\\infty}}$ 精确控制，而反应项的贡献由 $\\|\\beta\\|_{L^{\\infty}}$ 和在 $(0,1)$ 上的最优 Poincaré 常数控制。",
            "answer": "$$\\boxed{3+\\frac{1}{\\pi^{2}}}$$"
        },
        {
            "introduction": "Lax-Milgram引理的第二个关键假设是强制性，它保证了问题解的存在性、唯一性和稳定性。引理的强大之处在于它不要求双线性型是对称的（在复数域上即厄米特），这使其适用范围远超Riesz表示定理。这个练习 () 探討了一个源于流体动力学中对流扩散问题的更高级、更实际的例子，展示了如何为一个复的、非厄米特的半双线性型建立强制性。",
            "id": "3414236",
            "problem": "考虑在区间 $\\Omega = (0,1)$ 上具有齐次Dirichlet边界条件的一维线性对流-扩散模型。令Hilbert空间为 $H = H_{0}^{1}(\\Omega;\\mathbb{C})$，这是在边界上为零且具有平方可积弱导数的复值函数空间。令 $\\epsilon > 0$ 为扩散系数， $b > 0$ 为恒定对流速度，$\\tau \\ge 0$ 为迎风稳定化参数。在流线迎风Petrov-Galerkin (SUPG)方法 (Streamline Upwind Petrov-Galerkin (SUPG))中，稳定化弱形式导出以下半双线性形式：\n$$\na(u,v) = \\epsilon \\int_{0}^{1} u'(x)\\,\\overline{v'(x)}\\,dx \\;+\\; b \\int_{0}^{1} u'(x)\\,\\overline{v(x)}\\,dx \\;+\\; \\tau b^{2} \\int_{0}^{1} u'(x)\\,\\overline{v'(x)}\\,dx,\n$$\n对所有 $u,v \\in H$，其中撇号表示弱导数，上划线表示复共轭。该形式是通过在一维空间中，用SUPG测试函数 $v + \\tau b v'$ 对微分算子 $-\\epsilon u'' + b u'$ 进行检验得到的。\n\n从复Hilbert空间上半双线性形式的核心定义、Cauchy–Schwarz不等式以及 $H_{0}^{1}(\\Omega)$ 上的Poincaré不等式出发，完成以下任务：\n\n- 验证 $a(\\cdot,\\cdot)$ 在 $H$ 上是有界的和非Hermitian的。\n- 在范数 $\\|u\\|_{H_{0}^{1}} := \\|u'\\|_{L^{2}(\\Omega)}$ 下，证明复Lax–Milgram强制性条件成立，即存在 $\\alpha > 0$ 使得对所有 $u \\in H$ 都有 $\\Re\\big(a(u,u)\\big) \\ge \\alpha \\|u\\|_{H_{0}^{1}}^{2}$。\n- 确定与上述不等式相容的最大可能强制性常数 $\\alpha$。\n\n你的最终答案必须是该最大 $\\alpha$ 的闭式解析表达式。如果需要数值，请指明并使用有效数字，但此处期望的是一个精确表达式。",
            "solution": "该问题要求分析在复Hilbert空间 $H = H_{0}^{1}(\\Omega;\\mathbb{C})$（其中 $\\Omega = (0,1)$）上的一个给定半双线性形式 $a(\\cdot,\\cdot)$。空间 $H$ 由在边界 $x=0$ 和 $x=1$ 处为零且具有平方可积弱导数的复值函数组成。该空间上的范数由 $\\|u\\|_{H_{0}^{1}} := \\|u'\\|_{L^{2}(\\Omega)}$ 给出，由于Poincaré不等式，这确实是一个范数。\n\n该半双线性形式定义为：\n$$\na(u,v) = \\epsilon \\int_{0}^{1} u'(x)\\,\\overline{v'(x)}\\,dx \\;+\\; b \\int_{0}^{1} u'(x)\\,\\overline{v(x)}\\,dx \\;+\\; \\tau b^{2} \\int_{0}^{1} u'(x)\\,\\overline{v'(x)}\\,dx\n$$\n对 $u,v \\in H$，参数为 $\\epsilon > 0$，$b > 0$，以及 $\\tau \\ge 0$。撇号（'）表示弱导数，上划线（$\\overline{\\cdot}$）表示复共轭。使用$L^2(\\Omega)$内积 $\\langle f, g \\rangle = \\int_0^1 f(x) \\overline{g(x)} dx$，该形式可以紧凑地写为：\n$$\na(u,v) = (\\epsilon + \\tau b^2) \\langle u', v' \\rangle + b \\langle u', v \\rangle\n$$\n我们的任务是验证其有界性和非Hermitian性，证明强制性，并确定最大可能的强制性常数 $\\alpha$。\n\n首先，我们验证 $a(\\cdot,\\cdot)$ 是有界的。这需要证明存在一个常数 $M > 0$，使得对所有 $u, v \\in H$ 都有 $|a(u,v)| \\le M \\|u\\|_{H_{0}^{1}} \\|v\\|_{H_{0}^{1}}$。我们从 $a(u,v)$ 的定义出发，并对 $L^2$ 内积应用三角不等式和Cauchy-Schwarz不等式：\n$$\n|a(u,v)| = |(\\epsilon + \\tau b^2) \\langle u', v' \\rangle + b \\langle u', v \\rangle| \\le |\\epsilon + \\tau b^2| |\\langle u', v' \\rangle| + |b| |\\langle u', v \\rangle|\n$$\n由于 $\\epsilon > 0$，$b > 0$ 且 $\\tau \\ge 0$，这些参数都是非负的，所以我们可以去掉它们周围的绝对值符号。\n$$\n|a(u,v)| \\le (\\epsilon + \\tau b^2) \\|u'\\|_{L^2} \\|v'\\|_{L^2} + b \\|u'\\|_{L^2} \\|v\\|_{L^2}\n$$\n根据 $H_{0}^{1}(0,1)$ 上的Poincaré不等式，存在一个常数 $C_P$ 使得 $\\|v\\|_{L^2} \\le C_P \\|v'\\|_{L^2}$。对于区域 $\\Omega=(0,1)$，最优常数为 $C_P = 1/\\pi$。将此代入不等式可得：\n$$\n|a(u,v)| \\le (\\epsilon + \\tau b^2) \\|u'\\|_{L^2} \\|v'\\|_{L^2} + b C_P \\|u'\\|_{L^2} \\|v'\\|_{L^2}\n$$\n使用指定的范数 $\\|w\\|_{H_{0}^{1}} = \\|w'\\|_{L^2}$，我们得到：\n$$\n|a(u,v)| \\le (\\epsilon + \\tau b^2 + b C_P) \\|u\\|_{H_{0}^{1}} \\|v\\|_{H_{0}^{1}}\n$$\n因此，$a(\\cdot,\\cdot)$ 是有界的，其有界性常数为 $M = \\epsilon + \\tau b^2 + b/\\pi$。由于 $\\epsilon, b > 0$ 且 $\\tau \\ge 0$，我们有 $M > 0$。\n\n其次，我们验证 $a(\\cdot,\\cdot)$ 是非Hermitian的。如果对所有 $u,v \\in H$ 都有 $a(u,v) = \\overline{a(v,u)}$，则一个半双线性形式是Hermitian的。我们来计算 $\\overline{a(v,u)}$：\n$$\na(v,u) = (\\epsilon + \\tau b^2) \\langle v', u' \\rangle + b \\langle v', u \\rangle\n$$\n取复共轭，并利用性质 $\\overline{\\langle f, g \\rangle} = \\langle g, f \\rangle$ 以及所有参数均为实数的事实：\n$$\n\\overline{a(v,u)} = (\\epsilon + \\tau b^2) \\overline{\\langle v', u' \\rangle} + b \\overline{\\langle v', u \\rangle} = (\\epsilon + \\tau b^2) \\langle u', v' \\rangle + b \\langle u, v' \\rangle\n$$\n比较 $a(u,v)$ 和 $\\overline{a(v,u)}$：\n$$\na(u,v) = (\\epsilon + \\tau b^2) \\langle u', v' \\rangle + b \\langle u', v \\rangle\n$$\n$$\n\\overline{a(v,u)} = (\\epsilon + \\tau b^2) \\langle u', v' \\rangle + b \\langle u, v' \\rangle\n$$\n为使该形式是Hermitian的，我们必须有 $b\\langle u', v \\rangle = b\\langle u, v' \\rangle$。由于 $b > 0$，这简化为 $\\langle u', v \\rangle = \\langle u, v' \\rangle$。然而，对于 $u, v \\in H_{0}^{1}(\\Omega)$，分部积分给出：\n$$\n\\langle u', v \\rangle = \\int_0^1 u'(x)\\overline{v(x)} dx = [u(x)\\overline{v(x)}]_0^1 - \\int_0^1 u(x)\\overline{v'(x)} dx = 0 - \\langle u, v' \\rangle = -\\langle u, v' \\rangle\n$$\n边界项因为 $u(0)=u(1)=0$ 和 $v(0)=v(1)=0$ 而为零。所以，Hermitian的条件变为 $\\langle u', v \\rangle = -\\langle u', v \\rangle$，这意味着 $2\\langle u', v \\rangle = 0$，即对所有 $u, v \\in H$ 都有 $\\langle u', v \\rangle=0$。这在一般情况下是不成立的。例如，如果 $u(x) = x(1-x)$ 且 $v(x) = x^2(1-x)$，直接计算表明 $\\langle u', v \\rangle \\neq 0$。因此，由于 $b>0$，该半双线性形式 $a(\\cdot,\\cdot)$ 是非Hermitian的。\n\n最后，我们证明复Lax–Milgram强制性条件成立，并找到最大的强制性常数 $\\alpha$。我们必须证明存在 $\\alpha>0$ 使得对所有 $u \\in H$ 都有 $\\Re(a(u,u)) \\ge \\alpha \\|u\\|_{H_{0}^{1}}^2$。最大的这样一个 $\\alpha$ 由Rayleigh商的下确界给出：\n$$\n\\alpha = \\inf_{u \\in H \\setminus \\{0\\}} \\frac{\\Re(a(u,u))}{\\|u\\|_{H_{0}^{1}}^2}\n$$\n我们来计算 $a(u,u)$ 的实部：\n$$\na(u,u) = (\\epsilon + \\tau b^2) \\langle u', u' \\rangle + b \\langle u', u \\rangle = (\\epsilon + \\tau b^2) \\|u'\\|_{L^2}^2 + b \\langle u', u \\rangle\n$$\n$$\n\\Re(a(u,u)) = \\Re\\left((\\epsilon + \\tau b^2) \\|u'\\|_{L^2}^2\\right) + \\Re\\left(b \\langle u', u \\rangle\\right)\n$$\n由于 $\\epsilon, \\tau, b$ 是实数且 $\\|u'\\|_{L^2}^2$ 是实数，这简化为：\n$$\n\\Re(a(u,u)) = (\\epsilon + \\tau b^2) \\|u'\\|_{L^2}^2 + b \\Re(\\langle u', u \\rangle)\n$$\n我们分析 $\\Re(\\langle u', u \\rangle)$ 这一项。令 $u(x) = u_R(x) + i u_I(x)$。则 $u' \\overline{u} = (u_R' + i u_I')(u_R - i u_I) = (u_R' u_R + u_I' u_I) + i (u_I' u_R - u_R' u_I)$。被积函数的实部是 $\\Re(u' \\overline{u}) = u_R' u_R + u_I' u_I = \\frac{1}{2}\\frac{d}{dx}(u_R^2) + \\frac{1}{2}\\frac{d}{dx}(u_I^2) = \\frac{1}{2}\\frac{d}{dx}(u_R^2 + u_I^2) = \\frac{1}{2}\\frac{d}{dx}|u|^2$。\n将此从 $0$ 积分到 $1$：\n$$\n\\Re(\\langle u', u \\rangle) = \\int_0^1 \\Re(u'(x)\\overline{u(x)}) dx = \\int_0^1 \\frac{1}{2} \\frac{d}{dx}|u(x)|^2 dx = \\frac{1}{2}[|u(x)|^2]_0^1\n$$\n由于 $u \\in H_{0}^{1}(0,1)$，我们有 $u(0)=u(1)=0$，所以 $|u(0)|^2=0$ 且 $|u(1)|^2=0$。这得到：\n$$\n\\Re(\\langle u', u \\rangle) = \\frac{1}{2}(0 - 0) = 0\n$$\n将此结果代回到 $\\Re(a(u,u))$ 的表达式中：\n$$\n\\Re(a(u,u)) = (\\epsilon + \\tau b^2) \\|u'\\|_{L^2}^2\n$$\n使用给定的范数 $\\|u\\|_{H_{0}^{1}} = \\|u'\\|_{L^2}$：\n$$\n\\Re(a(u,u)) = (\\epsilon + \\tau b^2) \\|u\\|_{H_{0}^{1}}^2\n$$\n这对任何 $u \\in H$ 都是一个等式。强制性条件 $\\Re(a(u,u)) \\ge \\alpha \\|u\\|_{H_{0}^{1}}^2$ 变为 $(\\epsilon + \\tau b^2) \\|u\\|_{H_{0}^{1}}^2 \\ge \\alpha \\|u\\|_{H_{0}^{1}}^2$。对于任何非零的 $u$，这意味着 $\\epsilon + \\tau b^2 \\ge \\alpha$。满足此不等式的 $\\alpha$ 的最大可能值正是 $\\epsilon + \\tau b^2$。\n由于 $\\epsilon > 0$，$b > 0$ 且 $\\tau \\ge 0$，常数 $\\alpha = \\epsilon + \\tau b^2$ 是严格为正的。这证明了该形式在实部上是强制的。最大可能的强制性常数是比率 $\\Re(a(u,u)) / \\|u\\|_{H_{0}^{1}}^2$ 的下确界，我们已经证明了对于所有 $u \\neq 0$，该比率是一个常数。\n因此，最大可能的强制性常数是 $\\alpha = \\epsilon + \\tau b^2$。",
            "answer": "$$\\boxed{\\epsilon + \\tau b^{2}}$$"
        },
        {
            "introduction": "理论中的连续性常数 $M$ 和强制性常数 $\\alpha$ 并非纯粹的抽象概念，它们的比值 $M/\\alpha$ 在数值分析中扮演着至关重要的角色，其行为类似于问题的“条件数”，直接影响着有限元或有限差分等数值方法的求解精度。最后的这个实践 () 是一个计算任务，旨在通过数值实验直观地揭示这一深刻联系，展示一个大的各向异性比率（对应着大的 $M/\\alpha$）如何影响数值解的质量。",
            "id": "3414257",
            "problem": "考虑单位正方形区域 $[0,1] \\times [0,1]$ 上的各向异性扩散偏微分方程（PDE），其带有齐次 Dirichlet 边界条件，\n$$\n-\\nabla \\cdot \\big( A \\nabla u \\big) = f \\quad \\text{in} \\quad \\Omega = (0,1)^2, \\qquad u = 0 \\quad \\text{on} \\quad \\partial \\Omega,\n$$\n其中 $A \\in \\mathbb{R}^{2 \\times 2}$ 是一个用于模拟各向异性的常数对称正定矩阵。在本问题中，取 $A = \\mathrm{diag}(\\alpha, M)$，其中 $\\alpha > 0$ 且 $M \\ge \\alpha$，并定义双线性形式\n$$\na(u,v) = \\int_{\\Omega} (A \\nabla u) \\cdot \\nabla v \\, dx,\n$$\n和线性泛函\n$$\nL(v) = \\int_{\\Omega} f v \\, dx,\n$$\n于 Sobolev 空间 $H_0^1(\\Omega)$ 上。假设人造精确解为\n$$\nu(x,y) = \\sin(\\pi x)\\sin(\\pi y),\n$$\n并选择源项 $f$，使得 $u$ 精确满足该偏微分方程，即\n$$\nf(x,y) = \\pi^2(\\alpha + M) \\sin(\\pi x)\\sin(\\pi y).\n$$\n在 $H_0^1(\\Omega)$ 上定义 $a(\\cdot,\\cdot)$ 的连续性常数 $M_b$ 和矫顽性常数 $\\alpha_b$ 如下：\n$$\n|a(u,v)| \\le M_b \\, \\|u\\|_{H_0^1(\\Omega)} \\, \\|v\\|_{H_0^1(\\Omega)}, \\qquad a(v,v) \\ge \\alpha_b \\, \\|v\\|_{H_0^1(\\Omega)}^2,\n$$\n注意，对于常数矩阵 $A = \\mathrm{diag}(\\alpha,M)$，可以取 $M_b = M$ 和 $\\alpha_b = \\alpha$。Lax–Milgram 引理保证了弱解在 $H_0^1(\\Omega)$ 中的存在性和唯一性，而从 Lax–Milgram 框架导出的 Galerkin 误差界表明，误差常数取决于比率 $M_b/\\alpha_b = M/\\alpha$。\n\n您的任务是实现一个数值实验，在内部尺寸为 $N \\in \\{16,32,64\\}$ 的均匀网格上采用有限差分离散化，以经验性地研究比率 $M/\\alpha$ 如何影响由 $A$ 导出的能量范数下的观测收敛率和观测误差常数。对于每个网格尺寸 $N$（网格步长 $h = 1/(N+1)$），在 Dirichlet 边界条件下，使用精确边界数据和人造右端项 $f$，求解与 $-\\nabla \\cdot (A \\nabla u)$ 的五点模板近似相对应的离散线性系统。在计算出内部节点的离散解 $u_h$ 后，近似能量范数误差\n$$\nE_h = \\left( \\int_{\\Omega} (A \\nabla (u - u_h)) \\cdot \\nabla (u - u_h) \\, dx \\right)^{1/2}\n$$\n方法是用均匀网格求积代替积分，并用内部节点的中心差分代替梯度 $\\nabla u_h$。使用精确梯度\n$$\n\\nabla u(x,y) = \\left( \\pi \\cos(\\pi x)\\sin(\\pi y), \\ \\pi \\sin(\\pi x)\\cos(\\pi y) \\right).\n$$\n\n对于每个测试用例，使用三种网格尺寸估计能量范数下的观测收敛率：\n$$\np_{\\mathrm{obs}} = \\frac{1}{2} \\left( \\frac{\\log(E_{32}/E_{16})}{\\log(h_{32}/h_{16})} + \\frac{\\log(E_{64}/E_{32})}{\\log(h_{64}/h_{32})} \\right),\n$$\n并使用最细网格定义观测误差常数：\n$$\nC_{\\mathrm{obs}} = \\frac{E_{64}}{h_{64}^{p_{\\mathrm{obs}}}}.\n$$\n\n实现程序以运行以下各向异性参数的测试套件：\n- 测试 1：$(\\alpha, M) = (1, 1)$，比率 $M/\\alpha = 1$。\n- 测试 2：$(\\alpha, M) = (1, 10)$，比率 $M/\\alpha = 10$。\n- 测试 3：$(\\alpha, M) = (0.1, 10)$，比率 $M/\\alpha = 100$。\n- 测试 4：$(\\alpha, M) = (0.01, 1)$，比率 $M/\\alpha = 100$。\n\n对于每个测试，计算并返回三元组 $[M/\\alpha, p_{\\mathrm{obs}}, C_{\\mathrm{obs}}]$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例以子列表 $[M/\\alpha,p_{\\mathrm{obs}},C_{\\mathrm{obs}}]$ 的形式报告。例如，最终输出格式必须严格为\n$$\n[[\\kappa_1,p_1,C_1],[\\kappa_2,p_2,C_2],[\\kappa_3,p_3,C_3],[\\kappa_4,p_4,C_4]],\n$$\n其中 $\\kappa_i = M/\\alpha$ 代表第 $i$ 个测试。不涉及任何物理单位或角度单位；所有数值必须以普通浮点数形式报告。",
            "solution": "用户希望求解各向异性扩散方程并分析数值误差。\n\n### 步骤 1：问题验证\n\n问题在于执行一个数值实验，以研究各向异性对泊松型方程 $-\\nabla \\cdot (A \\nabla u) = f$ 的有限差分法收敛性的影响。\n\n#### 提取的已知条件\n-   **偏微分方程**：在单位正方形 $\\Omega = (0,1)^2$ 上为 $-\\nabla \\cdot \\big( A \\nabla u \\big) = f$。\n-   **边界条件**：齐次 Dirichlet 条件，$u = 0$ 在 $\\partial \\Omega$ 上。\n-   **扩散张量**：$A = \\mathrm{diag}(\\alpha, M)$，其中 $\\alpha > 0$ 且 $M \\ge \\alpha$。\n-   **精确解**：$u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n-   **源项**：$f(x,y) = \\pi^2(\\alpha + M) \\sin(\\pi x)\\sin(\\pi y)$，该项是为了与精确解和偏微分方程保持一致而推导出来的。\n-   **数值方法**：在具有 $N \\times N$ 个内部点的均匀网格上使用有限差分法。\n-   **网格尺寸**：$N \\in \\{16, 32, 64\\}$。网格步长为 $h=1/(N+1)$。\n-   **误差度量**：能量范数误差 $E_h = \\left( \\int_{\\Omega} (A \\nabla (u - u_h)) \\cdot \\nabla (u - u_h) \\, dx \\right)^{1/2}$。此误差将使用矩形求积法则以及数值解 $u_h$ 梯度的中心差分来近似计算。\n-   **收敛性度量**：\n    -   观测收敛率：$p_{\\mathrm{obs}} = \\frac{1}{2} \\left( \\frac{\\log(E_{32}/E_{16})}{\\log(h_{32}/h_{16})} + \\frac{\\log(E_{64}/E_{32})}{\\log(h_{64}/h_{32})} \\right)$。\n    -   观测误差常数：$C_{\\mathrm{obs}} = E_{64} / h_{64}^{p_{\\mathrm{obs}}}$。\n-   **测试用例**：\n    1.  $(\\alpha, M) = (1, 1)$，比率 $M/\\alpha = 1$。\n    2.  $(\\alpha, M) = (1, 10)$，比率 $M/\\alpha = 10$。\n    3.  $(\\alpha, M) = (0.1, 10)$，比率 $M/\\alpha = 100$。\n    4.  $(\\alpha, M) = (0.01, 1)$，比率 $M/\\alpha = 100$。\n-   **输出格式**：一个列表的列表：$[[\\kappa_1,p_1,C_1],[\\kappa_2,p_2,C_2], \\dots]$。\n\n#### 验证结论\n问题是**有效的**。\n-   **科学依据**：该问题是基于基本概念（有限差分法、人造解法、误差分析）的标准数值分析练习。该偏微分方程是物理和工程领域的一个基石模型。所有的数学公式，包括精确解与源项之间的关系，以及误差度量的定义，在数值偏微分方程领域都是正确且标准的。\n-   **适定性**：该问题是适定的。带有 Dirichlet 边界条件的椭圆偏微分方程由 Lax-Milgram 引理保证有唯一的弱解。相应的离散线性系统涉及一个对称正定矩阵，这确保了唯一的数值解。计算指令是确定性的，并导向一个单一、可验证的结果。\n-   **完整性与一致性**：问题陈述是自包含的，提供了所有必要的方程、参数和程序。没有矛盾之处。\n-   **客观性**：问题是用精确、客观的数学语言陈述的。\n\n问题通过了所有验证标准。我们可以继续进行求解。\n\n### 步骤 2：求解推导\n\n问题的核心是为方程 $-\\alpha \\frac{\\partial^2 u}{\\partial x^2} - M \\frac{\\partial^2 u}{\\partial y^2} = f$ 实现一个有限差分求解器。\n\n#### 离散化\n我们在每个方向上使用具有 $N$ 个内部点的均匀网格，$x_i = ih$ 和 $y_j = jh$，其中 $i,j=1,\\ldots,N$，步长 $h=1/(N+1)$。令 $u_{i,j}$ 为 $u(x_i, y_j)$ 的数值近似。二阶导数使用二阶中心差分格式来近似：\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i,y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} $$\n$$ \\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i,y_j)} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} $$\n将这些代入偏微分方程，得到每个内部节点 $(i,j)$ 的离散方程：\n$$ -\\alpha \\left(\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2}\\right) - M \\left(\\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\\right) = f_{i,j} $$\n齐次 Dirichlet 边界条件意味着 $u_{0,j} = u_{N+1,j} = u_{i,0} = u_{i,N+1} = 0$。\n\n#### 线性系统\n这个关于 $N^2$ 个未知数 $u_{i,j}$ 的 $N^2$ 个线性方程组可以写成矩阵形式 $K \\mathbf{u}_h = \\mathbf{f}$。如果我们按行主序（或字典序）排列未知数 $\\mathbf{u}_h$，其中 $u_{i,j}$ 的索引为 $k=(i-1)N + (j-1)$（假设数学索引 $i,j=1\\dots N$），则矩阵 $K$ 具有块三对角结构。它可以使用克罗内克积来构造。令 $T_N$ 为表示一维离散拉普拉斯算子的 $N \\times N$ 矩阵：\n$$ T_N = \\frac{1}{h^2} \\begin{pmatrix} 2  -1   \\\\ -1  2  -1  \\\\  \\ddots  \\ddots  \\ddots \\\\   -1  2 \\end{pmatrix} $$\n则完整的系统矩阵 $K$ 为：\n$$ K = \\alpha (I_N \\otimes T_N) + M (T_N \\otimes I_N) $$\n其中 $I_N$ 是 $N \\times N$ 的单位矩阵，$\\otimes$ 表示克罗内克积。该矩阵 $K$ 是稀疏、对称且正定的。\n\n#### 误差计算\n在求解 $K \\mathbf{u}_h = \\mathbf{f}$ 得到离散解向量 $\\mathbf{u}_h$ 后，我们将其重塑为一个 $N \\times N$ 的网格 $U_h$。为了计算能量范数误差 $E_h$，我们遵循问题的规定：\n1.  **近似积分**：使用简单的矩形求积法则，将 $\\Omega$ 上的积分替换为对所有 $N \\times N$ 个内部网格单元的求和，每个单元的面积为 $h^2$。\n2.  **近似梯度**：离散解的梯度 $\\nabla u_h$ 在每个内部节点上使用中心差分计算。\n$$ (\\partial_x u_h)_{i,j} \\approx \\frac{u_{i+1, j} - u_{i-1, j}}{2h}, \\quad (\\partial_y u_h)_{i,j} \\approx \\frac{u_{i, j+1} - u_{i, j-1}}{2h} $$\n为应用此公式，我们首先为 $u_h$ 构建一个带有已知零边界值的 $(N+2) \\times (N+2)$ 填充网格。\n3.  **组合**：能量范数误差的平方近似为：\n$$ E_h^2 \\approx \\sum_{j=1}^{N} \\sum_{i=1}^{N} h^2 \\left( \\alpha (\\partial_x u(x_i,y_j) - (\\partial_x u_h)_{i,j})^2 + M (\\partial_y u(x_i,y_j) - (\\partial_y u_h)_{i,j})^2 \\right) $$\n精确梯度 $\\nabla u$ 是给定的，并在网格点上进行评估。最后，$E_h = \\sqrt{E_h^2}$。\n\n#### 实现计划\n对于每个测试用例 $(\\alpha, M)$：\n1.  初始化一个字典来存储 $N \\in \\{16, 32, 64\\}$ 的误差。\n2.  遍历每个 $N$：\n    a.  设置网格和矩阵 $K$。`scipy.sparse` 是理想的选择。\n    b.  通过在网格上评估源函数来设置右端项向量 $\\mathbf{f}$。\n    c.  使用 `scipy.sparse.linalg.spsolve` 求解稀疏线性系统以得到 $\\mathbf{u}_h$。\n    d.  将 $\\mathbf{u}_h$ 重塑为一个 $N \\times N$ 数组并用零填充边界。\n    e.  使用中心差分（例如，通过 `numpy.gradient`）在内部网格上计算数值梯度 $\\nabla u_h$。\n    f.  在内部网格上计算精确梯度 $\\nabla u$。\n    g.  计算并存储能量范数误差 $E_h$。\n3.  循环结束后，使用存储的误差 $E_{16}, E_{32}, E_{64}$ 和相应的网格步长 $h_{16}, h_{32}, h_{64}$，根据提供的公式计算 $p_{\\mathrm{obs}}$ 和 $C_{\\mathrm{obs}}$。\n4.  存储结果三元组 $[M/\\alpha, p_{\\mathrm{obs}}, C_{\\mathrm{obs}}]$。\n5.  在所有测试用例完成后，将收集到的结果格式化为指定的单个字符串。\n能量范数（基于一阶导数误差）的预期收敛率 $p_{\\mathrm{obs}}$ 为 1，因为底层的有限差分格式的点态误差为 $O(h^2)$，而微分通常会使精度阶数降低一阶。预计常数 $C_{\\mathrm{obs}}$ 会随着各向异性比率 $M/\\alpha$ 的增加而增加，反映出对于高度各向异性问题性能的下降。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, M)\n        (1.0, 1.0),\n        (1.0, 10.0),\n        (0.1, 10.0),\n        (0.01, 1.0),\n    ]\n\n    grid_sizes = [16, 32, 64]\n    \n    all_results = []\n\n    for alpha, M in test_cases:\n        errors = {}\n        h_vals = {}\n        for N in grid_sizes:\n            h = 1.0 / (N + 1)\n            h_vals[N] = h\n            \n            # Create a grid for the interior points.\n            # Using 'xy' indexing, grid arrays will have shape (N, N).\n            # The first axis (0) corresponds to x, and the second (1) to y.\n            x_int = np.linspace(h, 1.0 - h, N)\n            y_int = np.linspace(h, 1.0 - h, N)\n            X_int, Y_int = np.meshgrid(x_int, y_int, indexing='xy')\n\n            # Construct the 1D discrete Laplacian matrix T_1d.\n            T_1d = sparse.diags([-1, 2, -1], [-1, 0, 1], shape=(N, N), format='csr') / (h**2)\n            \n            # Construct the 2D anisotropic operator matrix K using Kronecker products.\n            # For row-major flattening, used by np.flatten(order='C'), the operator\n            # -alpha*d^2/dx^2 - M*d^2/dy^2 is discretized as:\n            # K = alpha * kron(T_1d, I_N) + M * kron(I_N, T_1d)\n            # This is because the x-derivative couples elements in the same row,\n            # which are far apart in C-style flattening. The y-derivative couples\n            # adjacent rows.\n            I_N = sparse.eye(N)\n            Kx_op = sparse.kron(T_1d, I_N)\n            Ky_op = sparse.kron(I_N, T_1d)\n            K = alpha * Kx_op + M * Ky_op\n            K = K.tocsr() # CSR format is efficient for solving.\n\n            # Construct the right-hand side vector f.\n            f_vals = np.pi**2 * (alpha + M) * np.sin(np.pi * X_int) * np.sin(np.pi * Y_int)\n            # Flatten the grid values in row-major order ('C'-style).\n            f_vec = f_vals.flatten(order='C')\n\n            # Solve the linear system K * u_h = f.\n            u_vec = linalg.spsolve(K, f_vec)\n            # Reshape the solution vector back to a 2D grid.\n            U_h = u_vec.reshape((N, N), order='C')\n\n            # Pad the numerical solution with boundary zeros to form an (N+2)x(N+2) grid.\n            U_h_padded = np.zeros((N + 2, N + 2))\n            U_h_padded[1:-1, 1:-1] = U_h\n\n            # Compute numerical gradients of u_h at interior nodes.\n            # np.gradient uses central differences in the interior.\n            # The output order matches the input array's axis order (axis 0=x, axis 1=y)\n            grad_xh, grad_yh = np.gradient(U_h_padded, h, axis=(1, 0)) # axis=(x,y)\n            grad_xh_int = grad_xh[1:-1, 1:-1]\n            grad_yh_int = grad_yh[1:-1, 1:-1]\n\n            # Compute exact gradients of the manufactured solution u at interior grid points.\n            grad_ux_exact = np.pi * np.cos(np.pi * X_int) * np.sin(np.pi * Y_int)\n            grad_uy_exact = np.pi * np.sin(np.pi * X_int) * np.cos(np.pi * Y_int)\n\n            # Compute errors in the gradients.\n            err_grad_x = grad_ux_exact - grad_xh_int\n            err_grad_y = grad_uy_exact - grad_yh_int\n\n            # Approximate the energy norm error E_h using a quadrature rule.\n            # E_h^2 = integral( alpha*err_gx^2 + M*err_gy^2 ) dx dy\n            #       ~= sum( h^2 * (alpha*err_gx^2 + M*err_gy^2) ) over grid points\n            integrand = alpha * err_grad_x**2 + M * err_grad_y**2\n            energy_norm_sq = h**2 * np.sum(integrand)\n            errors[N] = np.sqrt(energy_norm_sq)\n\n        # After computing errors for all grid sizes, calculate convergence metrics.\n        E16, E32, E64 = errors[16], errors[32], errors[64]\n        h16, h32, h64 = h_vals[16], h_vals[32], h_vals[64]\n        \n        # Estimate the observed convergence rate p_obs.\n        p1 = np.log(E32 / E16) / np.log(h32 / h16)\n        p2 = np.log(E64 / E32) / np.log(h64 / h32)\n        p_obs = 0.5 * (p1 + p2)\n        \n        # Estimate the observed error constant C_obs.\n        C_obs = E64 / (h64**p_obs)\n        \n        ratio = M / alpha\n        all_results.append([ratio, p_obs, C_obs])\n\n    # Format the final results into the exact string format required.\n    result_strs = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in all_results]\n    print(f\"[{','.join(result_strs)}]\")\n\nsolve()\n```"
        }
    ]
}