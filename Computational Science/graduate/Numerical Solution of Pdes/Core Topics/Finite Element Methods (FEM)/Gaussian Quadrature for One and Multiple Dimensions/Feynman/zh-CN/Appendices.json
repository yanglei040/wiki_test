{
    "hands_on_practices": [
        {
            "introduction": "虽然通过求解非线性方程组可以推导低阶高斯求积的节点和权重，但这种方法对于高阶规则既不实用也不稳定。一个更强大、更通用的方法是将求积问题与一个优雅的线性代数问题联系起来。这个练习将指导您探索高斯求积与三对角（雅可比）矩阵的谱特性之间的深刻联系，即著名的 Golub-Welsch 算法，这是现代数值计算的基石。 通过从第一性原理推导雅可比矩阵并利用其特征值和特征向量来生成节点和权重，您将把正交多项式的抽象理论转化为具体的计算实践。",
            "id": "3398441",
            "problem": "设在 $[-1,1]$ 上的权函数为 $w(x)=1$，并考虑关于此权函数的勒让德（Legendre）正交多项式族。仅从以下基本事实出发：(i) 任何关于紧区间上正权函数的标准正交多项式系 $\\{p_k(x)\\}_{k\\ge 0}$ 都满足一个三项递推关系，形式为 $x\\,p_k(x)=\\beta_{k+1}\\,p_{k+1}(x)+\\alpha_k\\,p_k(x)+\\beta_k\\,p_{k-1}(x)$，其中 $\\alpha_k$ 为实数，$\\beta_k$ 为严格正数；(ii) 高斯求积的节点和权重源于在此标准正交基中与乘子 $x$ 相关的谱测度。请完成以下任务。\n\n1) 对于 $n=3$ 的情况，显式推导在 $[-1,1]$ 上的标准正交勒让德多项式的对称三对角雅可比矩阵 $J\\in\\mathbb{R}^{n\\times n}$。你必须从第一性原理出发，确定 $J$ 的非零元素的具体数值，包括标准正交化的影响。\n\n2) 仅使用与 $J$ 相关的特征值问题，以机器精度求得在 $[-1,1]$ 上 $n=3$ 的高斯-勒让德节点和权重。你必须从理论上证明为什么 $J$ 的特征值是求积节点，以及如何从特征向量和零阶矩 $\\mu_0=\\int_{-1}^{1}w(x)\\,\\mathrm{d}x$ 中恢复权重。\n\n3) 解释并实现高斯求积到多维的张量积扩展，并将其应用于一个二元可分离被积函数。\n\n你的程序必须通过算法实现上述推导，并生成数值输出，通过以下测试套件验证其正确性。除非另有说明，所有比较都必须使用双精度和容差 $\\tau=10^{-14}$ 进行。\n\n测试套件：\n- 测试 $\\mathrm{T1}$ (基于特征值的节点): 从 $J$ 的特征值计算节点 $\\{x_i\\}_{i=1}^3$，并将其与按升序排列的解析值 $\\{-\\sqrt{3/5},\\,0,\\,\\sqrt{3/5}\\}$ 进行比较。报告最大绝对差，形式为单个浮点数。\n- 测试 $\\mathrm{T2}$ (基于特征值的权重): 从特征向量和 $\\mu_0=2$ 计算权重 $\\{w_i\\}_{i=1}^3$，并将其与按节点顺序对应的解析值 $\\{5/9,\\,8/9,\\,5/9\\}$ 进行比较。报告最大绝对差，形式为单个浮点数。\n- 测试 $\\mathrm{T3}$ (一维多项式精确性): 使用计算出的节点和权重，近似计算 $\\int_{-1}^{1} x^k\\,\\mathrm{d}x$ (其中 $k\\in\\{0,1,2,3,4,5\\}$)，并与精确值 (当 $k$ 为偶数时为 $2/(k+1)$，当 $k$ 为奇数时为 $0$) 进行比较。报告这 $6$ 个案例中的最大绝对误差，形式为单个浮点数。\n- 测试 $\\mathrm{T4}$ (二维张量积精确性): 根据一维节点和权重构建张量积求积法则，并近似计算 $\\iint_{[-1,1]^2} x^4\\,y^2\\,\\mathrm{d}x\\,\\mathrm{d}y$。将其与精确值 $(2/5)\\cdot(2/3)=4/15$ 进行比较。报告绝对误差，形式为单个浮点数。\n- 测试 $\\mathrm{T5}$ (二维光滑非多项式函数): 使用相同的张量积求积法则，近似计算 $\\iint_{[-1,1]^2} e^{x+y}\\,\\mathrm{d}x\\,\\mathrm{d}y$，并与精确值 $\\left(\\int_{-1}^{1} e^x\\,\\mathrm{d}x\\right)^2=\\left(e-1/e\\right)^2$ 进行比较。报告绝对误差，形式为单个浮点数。\n- 测试 $\\mathrm{T6}$ (权重合理性检查): 验证所有计算出的权重均为严格正数，并且 $\\sum_{i=1}^3 w_i=2$ 在容差 $\\tau$ 范围内成立。报告一个布尔值，当且仅当两个条件都满足时为真。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含 $\\mathrm{T1}$ 到 $\\mathrm{T6}$ 的结果，按此顺序排列，形式为用方括号括起来的逗号分隔列表，例如 $[v_A,v_B,v_C,v_D,v_E,v_F]$，其中 $v_A,\\dots,v_E$ 是浮点数，$v_F$ 是布尔值。不应打印任何额外文本。",
            "solution": "该问题是有效的，要求推导和实现用于生成高斯-勒让德求积法则的 Golub-Welsch 算法，然后应用张量积扩展来处理二维积分。\n\n### 第1部分：雅可比矩阵的推导 ($n=3$)\n\n对于权函数 $w(x)$ 在区间 $[a, b]$ 上的一系列标准正交多项式 $\\{p_k(x)\\}_{k=0}^{n-1}$，其三项递推关系由下式给出\n$$x\\,p_k(x) = \\beta_{k+1}\\,p_{k+1}(x) + \\alpha_k\\,p_k(x) + \\beta_k\\,p_{k-1}(x)$$\n对于 $k = 0, 1, \\dots, n-2$，并约定 $p_{-1}(x) = 0$。系数 $\\alpha_k$ 和 $\\beta_k$ 是实数，且 $\\beta_k > 0$。这个方程组可以写成矩阵形式，从而得到雅可比矩阵。对于一个大小为 $n$ 的系统，其 $n \\times n$ 对称三对角雅可比矩阵 $J_n$ 为：\n$$\nJ_n = \\begin{pmatrix}\n\\alpha_0  &\\beta_1  &0  &\\dots  &0 \\\\\n\\beta_1  &\\alpha_1  &\\beta_2   & &0 \\\\\n0  &\\beta_2  &\\alpha_2  &\\ddots  &\\vdots \\\\\n\\vdots   &\\ddots  &\\ddots  & &\\beta_{n-1} \\\\\n0  &0  &\\dots  &\\beta_{n-1}  &\\alpha_{n-1}\n\\end{pmatrix}\n$$\n系数由内积 $\\langle f, g \\rangle = \\int_a^b f(x)g(x)w(x)\\,\\mathrm{d}x$ 定义如下：\n- $\\alpha_k = \\langle x p_k, p_k \\rangle = \\int_a^b x (p_k(x))^2 w(x)\\,\\mathrm{d}x$\n- $\\beta_k = \\langle x p_{k-1}, p_k \\rangle = \\int_a^b x p_{k-1}(x) p_k(x) w(x)\\,\\mathrm{d}x$\n\n对于本问题，我们考虑在 $[-1, 1]$ 上，权函数为 $w(x) = 1$ 的勒让德多项式。标准的勒让德多项式记作 $P_k(x)$，它们是正交的但非标准正交。其归一化由 $\\int_{-1}^1 (P_k(x))^2\\,\\mathrm{d}x = \\frac{2}{2k+1}$ 给出。\n相应的标准正交多项式 $p_k(x)$ 通过缩放得到：\n$$p_k(x) = \\sqrt{\\frac{2k+1}{2}} P_k(x)$$\n零阶多项式是 $P_0(x)=1$，所以 $p_0(x) = \\sqrt{1/2}$。\n\n首先，我们确定对角元素 $\\alpha_k$。函数 $(p_k(x))^2 w(x) = (p_k(x))^2$ 在 $[-1, 1]$ 上总是一个偶函数，因为 $p_k(x)$ 具有确定的奇偶性 ($p_k(-x) = (-1)^k p_k(x)$)。一个奇函数（即 $x$ 乘以一个偶函数）在对称区间 $[-1, 1]$ 上的积分为零。\n$$\\alpha_k = \\int_{-1}^1 x (p_k(x))^2 \\,\\mathrm{d}x = 0 \\quad \\text{对所有 } k$$\n因此，标准正交勒让德多项式的雅可比矩阵的主对角线全为零。\n\n接下来，我们确定非对角元素 $\\beta_k$。我们使用勒让德多项式 $P_k(x)$ 的标准递推关系：\n$$(k+1)P_{k+1}(x) = (2k+1)x P_k(x) - k P_{k-1}(x)$$\n整理得到 $x P_k(x)$：\n$$x P_k(x) = \\frac{k+1}{2k+1} P_{k+1}(x) + \\frac{k}{2k+1} P_{k-1}(x)$$\n现在，我们将 $P_k(x) = \\sqrt{\\frac{2}{2k+1}} p_k(x)$ 代入此关系式：\n$$x \\sqrt{\\frac{2}{2k+1}} p_k(x) = \\frac{k+1}{2k+1} \\sqrt{\\frac{2}{2(k+1)+1}} p_{k+1}(x) + \\frac{k}{2k+1} \\sqrt{\\frac{2}{2(k-1)+1}} p_{k-1}(x)$$\n两边乘以 $\\sqrt{\\frac{2k+1}{2}}$ 得到标准正交多项式 $p_k(x)$ 的递推关系：\n$$x p_k(x) = \\frac{k+1}{2k+1} \\sqrt{\\frac{2k+1}{2k+3}} p_{k+1}(x) + \\frac{k}{2k+1} \\sqrt{\\frac{2k+1}{2k-1}} p_{k-1}(x)$$\n$$x p_k(x) = \\frac{k+1}{\\sqrt{(2k+1)(2k+3)}} p_{k+1}(x) + \\frac{k}{\\sqrt{(2k-1)(2k+1)}} p_{k-1}(x)$$\n通过将其与一般形式 $x\\,p_k(x) = \\beta_{k+1}\\,p_{k+1}(x) + \\alpha_k\\,p_k(x) + \\beta_k\\,p_{k-1}(x)$ 进行比较，我们可以确定 $k \\ge 1$ 的系数：\n$$\\alpha_k = 0 \\quad \\text{以及} \\quad \\beta_k = \\frac{k}{\\sqrt{4k^2-1}}$$\n对于 $n=3$，我们需要构建矩阵 $J_3$，这需要 $\\alpha_0, \\alpha_1, \\alpha_2$ 和 $\\beta_1, \\beta_2$。\n- 对角线元素为 $\\alpha_0 = \\alpha_1 = \\alpha_2 = 0$。\n- 非对角线元素为：\n  - $\\beta_1 = \\frac{1}{\\sqrt{4(1)^2-1}} = \\frac{1}{\\sqrt{3}}$\n  - $\\beta_2 = \\frac{2}{\\sqrt{4(2)^2-1}} = \\frac{2}{\\sqrt{15}}$\n得到的 $3 \\times 3$ 雅可比矩阵是：\n$$\nJ_3 = \\begin{pmatrix}\n0  &1/\\sqrt{3}  &0 \\\\\n1/\\sqrt{3}  &0  &2/\\sqrt{15} \\\\\n0  &2/\\sqrt{15}  &0\n\\end{pmatrix}\n$$\n\n### 第2部分：从特征值得出高斯求积节点和权重\n\n高斯求积和雅可比矩阵之间的联系是数值分析中的一个基本结果，通常被称为 Golub-Welsch 算法。\n\n**理论论证：**\n设 $\\vec{p}(x) = [p_0(x), p_1(x), \\dots, p_{n-1}(x)]^T$ 为前 $n$ 个标准正交多项式的向量。对于 $k=0, \\dots, n-2$ 的三项递推关系可以表示为矩阵形式：\n$$x \\vec{p}(x) = J_n \\vec{p}(x) + \\beta_n p_n(x) \\vec{e}_{n-1}$$\n其中 $\\vec{e}_{n-1} = [0, \\dots, 0, 1]^T$。\n$n$ 点高斯求积法则的 $n$ 个节点 $\\{x_i\\}_{i=1}^n$ 正是 $n$ 次正交多项式 $p_n(x)$ 的根。如果我们在 $p_n(x)$ 的一个根 $x_i$ 处计算该矩阵方程，则 $p_n(x_i)$ 项消失：\n$$x_i \\vec{p}(x_i) = J_n \\vec{p}(x_i)$$\n这就是标准的特征值方程 $A\\vec{v} = \\lambda\\vec{v}$。它表明 $p_n(x)$ 的根 $x_i$ 是雅可比矩阵 $J_n$ 的特征值，而相应的特征向量与在这些根处求值的多项式向量 $\\vec{p}(x_i)$ 成比例。\n\n求积权重 $\\{w_i\\}_{i=1}^n$ 可以从 $J_n$ 的归一化特征向量中恢复。设 $J_n = V \\Lambda V^T$ 是 $J_n$ 的谱分解，其中 $\\Lambda = \\mathrm{diag}(x_1, \\dots, x_n)$，$V$ 是一个正交矩阵，其列 $\\vec{v}_i$ 是归一化的特征向量。与特征值 $x_i$ 对应的归一化特征向量 $\\vec{v}_i$ 的第一个分量 $v_{i,0}$ 与权重 $\\{w_i\\}$ 之间存在一个直接关系：\n$$w_i = \\mu_0 (v_{i,0})^2$$\n其中 $\\mu_0 = \\int_a^b w(x)\\,\\mathrm{d}x$ 是权函数的零阶矩。\n这个关系可以如下推导：根据定义，权重是 $w_i = \\left(\\sum_{k=0}^{n-1} (p_k(x_i))^2\\right)^{-1}$。对于标准正交多项式，零阶多项式 $p_0(x)$ 是一个常数。由归一化条件 $\\int (p_0(x))^2 w(x) \\,dx = 1$，我们得到 $p_0^2 \\mu_0 = 1$，因此 $p_0 = 1/\\sqrt{\\mu_0}$。\n归一化特征向量 $\\vec{v}_i$ 的第一个分量是 $v_{i,0} = \\frac{p_0(x_i)}{\\|\\vec{p}(x_i)\\|_2} = \\frac{1/\\sqrt{\\mu_0}}{\\sqrt{\\sum_{k=0}^{n-1} (p_k(x_i))^2}}$。\n两边平方得到 $(v_{i,0})^2 = \\frac{1/\\mu_0}{\\sum (p_k(x_i))^2} = \\frac{w_i}{\\mu_0}$。\n整理后即得 $w_i = \\mu_0 (v_{i,0})^2$。对于我们的问题，$\\mu_0 = \\int_{-1}^1 1\\,\\mathrm{d}x = 2$。\n\n**$n=3$ 的计算：**\n我们计算 $J_3$ 的特征值和特征向量。特征值将是节点 $\\{x_i\\}_{i=1}^3$。权重 $\\{w_i\\}_{i=1}^3$ 计算为 $w_i = 2 (v_{i,0})^2$，其中 $v_{i,0}$ 是与 $x_i$ 对应的归一化特征向量的第一个分量。\n\n### 第3部分：多维的张量积求积\n\n为了近似计算矩形域上的二维积分 $\\iint_{[-1,1]^2} f(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y$，我们可以迭代地应用一维求积法则。根据 Fubini 定理，该积分可以写成：\n$$\\int_{-1}^1 \\left( \\int_{-1}^1 f(x,y)\\,\\mathrm{d}y \\right) \\mathrm{d}x$$\n我们可以使用 $n$ 点高斯-勒让德法则 $\\{x_j, w_j\\}_{j=1}^n$ 来近似内部积分：\n$$\\int_{-1}^1 f(x,y)\\,\\mathrm{d}y \\approx \\sum_{j=1}^n w_j f(x, y_j)$$\n将此代回外部积分：\n$$\\int_{-1}^1 \\left( \\sum_{j=1}^n w_j f(x, y_j) \\right) \\mathrm{d}x = \\sum_{j=1}^n w_j \\int_{-1}^1 f(x, y_j) \\mathrm{d}x$$\n对剩余的积分应用相同的求积法则（节点为 $\\{x_i, w_i\\}_{i=1}^n$）得到张量积法则：\n$$\\iint_{[-1,1]^2} f(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y \\approx \\sum_{j=1}^n w_j \\left( \\sum_{i=1}^n w_i f(x_i, y_j) \\right) = \\sum_{i=1}^n \\sum_{j=1}^n w_i w_j f(x_i, y_j)$$\n该公式使用一个包含 $n^2$ 个点 $(x_i, y_j)$ 的网格，其对应的权重为 $w_i w_j$。对于可分离函数 $f(x,y) = g(x)h(y)$，此方法尤其高效，因为积分及其近似都变成了乘积形式：\n$$\\iint_{[-1,1]^2} g(x)h(y)\\,\\mathrm{d}x\\,\\mathrm{d}y = \\left( \\int_{-1}^1 g(x)\\,\\mathrm{d}x \\right) \\left( \\int_{-1}^1 h(y)\\,\\mathrm{d}y \\right) \\approx \\left( \\sum_{i=1}^n w_i g(x_i) \\right) \\left( \\sum_{j=1}^n w_j h(y_j) \\right)$$\n测试将涉及一个可分离的多项式和一个非多项式的光滑函数，对它们将使用计算出的 3 点高斯-勒让德节点和权重来应用张量积法则。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies the 3-point Gauss-Legendre quadrature rule\n    using the Golub-Welsch algorithm (eigenvalue problem of the Jacobi matrix).\n    \"\"\"\n\n    # --- Part 1  2: Derive Jacobi Matrix, compute Nodes and Weights ---\n    n = 3\n    \n    # The Jacobi matrix for orthonormal Legendre polynomials has alpha_k = 0.\n    # The off-diagonal entries are beta_k = k / sqrt(4k^2 - 1).\n    beta = [k / np.sqrt(4 * k**2 - 1) for k in range(1, n)]\n    \n    # Construct the symmetric tridiagonal Jacobi matrix J\n    J = np.diag(beta, k=1) + np.diag(beta, k=-1)\n    \n    # The nodes are the eigenvalues of J.\n    # The weights are derived from the first component of the eigenvectors.\n    # np.linalg.eigh is used for symmetric matrices; it returns sorted eigenvalues\n    # and corresponding eigenvectors as columns.\n    nodes, V = np.linalg.eigh(J)\n    \n    # The zeroth moment (total mass) is mu_0 = integral from -1 to 1 of w(x)=1 dx.\n    mu0 = 2.0\n    \n    # Weights w_i = mu_0 * (v_{i,0})^2, where v_{i,0} is the first component of\n    # the i-th normalized eigenvector. Eigenvectors are columns of V, so we\n    # take the first row of V.\n    weights = mu0 * V[0, :]**2\n\n    # --- Part 3: Run Test Suite ---\n    results = []\n    \n    # T1: Compare computed nodes to analytic values\n    analytic_nodes = np.array([-np.sqrt(3.0 / 5.0), 0, np.sqrt(3.0 / 5.0)])\n    test1_error = np.max(np.abs(nodes - analytic_nodes))\n    results.append(test1_error)\n    \n    # T2: Compare computed weights to analytic values\n    # The weights correspond to the increasingly sorted nodes.\n    # For node 0, weight is 8/9. For nodes +/-sqrt(3/5), weight is 5/9.\n    analytic_weights = np.array([5.0 / 9.0, 8.0 / 9.0, 5.0 / 9.0])\n    test2_error = np.max(np.abs(weights - analytic_weights))\n    results.append(test2_error)\n    \n    # T3: Check polynomial exactness in 1D\n    # A n-point Gauss rule is exact for polynomials of degree up to 2n-1.\n    # For n=3, it should be exact for degrees up to 5.\n    max_poly_error = 0.0\n    for k in range(6):\n        integrand_values = nodes**k\n        quadrature_result = np.sum(weights * integrand_values)\n        exact_result = 0.0 if k % 2 != 0 else 2.0 / (k + 1)\n        error = np.abs(quadrature_result - exact_result)\n        if error > max_poly_error:\n            max_poly_error = error\n    results.append(max_poly_error)\n    \n    # T4: Check tensor-product quadrature for a separable polynomial in 2D\n    # The 3-point rule is exact for x^4 and y^2 individually.\n    f_t4 = lambda x, y: x**4 * y**2\n    # Use np.outer to efficiently compute tensor product sums\n    integral_t4_outer_product = f_t4(nodes[:, np.newaxis], nodes[np.newaxis, :])\n    integral_t4_approx = np.sum(np.outer(weights, weights) * integral_t4_outer_product)\n    integral_t4_exact = (2.0 / 5.0) * (2.0 / 3.0)\n    test4_error = np.abs(integral_t4_approx - integral_t4_exact)\n    results.append(test4_error)\n\n    # T5: Check tensor-product quadrature for a smooth non-polynomial in 2D\n    f_t5 = lambda x, y: np.exp(x + y)\n    integral_t5_outer_product = f_t5(nodes[:, np.newaxis], nodes[np.newaxis, :])\n    integral_t5_approx = np.sum(np.outer(weights, weights) * integral_t5_outer_product)\n    integral_t5_exact = (np.exp(1.0) - np.exp(-1.0))**2\n    test5_error = np.abs(integral_t5_approx - integral_t5_exact)\n    results.append(test5_error)\n\n    # T6: Sanity check for weights\n    tau = 1e-14\n    are_positive = np.all(weights > 0)\n    sum_is_mu0 = np.abs(np.sum(weights) - mu0)  tau\n    test6_result = are_positive and sum_is_mu0\n    results.append(test6_result)\n\n    # Format and print final output\n    # Use a custom formatter to avoid scientific notation for small numbers if needed\n    # but str() is usually sufficient for the required output format.\n    formatted_results = [f\"{r:.15e}\" if isinstance(r, float) else str(r).lower() for r in results]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在科学与工程领域，尤其是在使用有限元方法 (FEM) 时，几何区域很少是简单的矩形。对于更复杂的形状，如三角形或四面体，张量积求积法不再适用，必须开发新的积分策略。 本练习将引导您为标准的二维参考三角形构造一个对称求积法则（也称容积法则，cubature）。通过在重心坐标系下，为一组单项式基函数强制精确积分，您将确定求积点的位置和权重，这是为复杂几何形状设计高效积分法则的一项基本技能。",
            "id": "3398406",
            "problem": "在组装用于三角形网格上的二阶椭圆偏微分方程(PDE)的伽辽金有限元法(FEM)算子时，通常需要在每个单元上对最高三次的多项式被积函数进行精确数值积分。考虑参考三角形 $\\mathcal{T} \\subset \\mathbb{R}^{2}$，其顶点为 $(0,0)$、$(1,0)$ 和 $(0,1)$，因此 $\\mathcal{T} = \\{(x,y) \\,:\\, x \\ge 0,\\ y \\ge 0,\\ x+y \\le 1\\}$。使用满足 $\\lambda_{1}+\\lambda_{2}+\\lambda_{3}=1$ 的重心坐标 $(\\lambda_{1},\\lambda_{2},\\lambda_{3})$ 和映射 $(x,y) = (\\lambda_{2}, \\lambda_{3})$，在 $\\mathcal{T}$ 上构造一个代数精度为 $3$ 的对称求积格式，该格式包含四个节点：三个节点位于 $(a,a,1-2a)$ 的排列位置，一个节点位于形心 $(\\tfrac{1}{3},\\tfrac{1}{3},\\tfrac{1}{3})$。为三个排列节点赋予共同的权重 $w_{a}$，为形心节点赋予权重 $w_{c}$。通过对所有满足 $i+j \\le 3$ 的单项式 $x^{i} y^{j}$ 强制精确性来确定参数 $a$、$w_{a}$ 和 $w_{c}$，其中解析积分是通过在 $\\mathcal{T}$ 上的贝塔函数恒等式从第一性原理得到的。然后，使用你构造的格式，计算最大绝对误差\n$$\nE \\;=\\; \\max_{\\,i,j \\,\\ge 0,\\, i+j \\le 3} \\left| \\int_{\\mathcal{T}} x^{i} y^{j} \\, dx\\,dy \\;-\\; \\sum_{k=1}^{4} w_{k}\\, x_{k}^{i} y_{k}^{j} \\right|.\n$$\n将 $E$ 的最终值表示为一个无单位的实数。无需四舍五入。",
            "solution": "该问题要求在参考三角形 $\\mathcal{T}$ 上构造一个对称的四点求积格式，并随后计算对于最高三次单项式的最大误差。求解过程分两个阶段：首先，确定该格式的参数；其次，根据该格式的性质评估误差。\n\n参考三角形由 $\\mathcal{T} = \\{(x,y) \\in \\mathbb{R}^{2} \\,|\\, x \\ge 0, y \\ge 0, x+y \\le 1\\}$ 给出。$\\mathcal{T}$ 的面积是 $\\frac{1}{2}$。问题指定了一个形式为\n$$ \\int_{\\mathcal{T}} f(x,y) \\,dx\\,dy \\approx \\sum_{k=1}^{4} w_k f(x_k, y_k) $$\n的求积格式，该格式必须对所有总次数最高为 $3$ 的多项式 $f(x,y)$ 精确。这等价于要求该格式对所有满足 $i,j \\ge 0$ 且 $i+j \\le 3$ 的单项式 $x^i y^j$ 精确。\n\n首先，我们确定这些单项式积分的精确值。利用贝塔函数的提示，我们推导出 $I_{ij} = \\int_{\\mathcal{T}} x^i y^j \\,dx\\,dy$ 的通用公式：\n$$ I_{ij} = \\int_0^1 \\int_0^{1-y} x^i y^j \\,dx\\,dy = \\int_0^1 y^j \\left[ \\frac{x^{i+1}}{i+1} \\right]_0^{1-y} dy = \\frac{1}{i+1} \\int_0^1 y^j (1-y)^{i+1} dy $$\n该积分为贝塔函数 $B(j+1, i+2)$。因此，\n$$ I_{ij} = \\frac{1}{i+1} \\frac{\\Gamma(j+1)\\Gamma(i+2)}{\\Gamma(j+i+3)} = \\frac{1}{i+1} \\frac{j! (i+1)!}{(i+j+2)!} = \\frac{i! j!}{(i+j+2)!} $$\n使用此公式，我们计算所需的精确积分值：\n\\begin{itemize}\n    \\item 0次：$I_{00} = \\frac{0!0!}{2!} = \\frac{1}{2}$\n    \\item 1次：$I_{10} = \\frac{1!0!}{3!} = \\frac{1}{6}$，$I_{01} = \\frac{0!1!}{3!} = \\frac{1}{6}$\n    \\item 2次：$I_{20} = \\frac{2!0!}{4!} = \\frac{1}{12}$，$I_{11} = \\frac{1!1!}{4!} = \\frac{1}{24}$\n    \\item 3次：$I_{30} = \\frac{3!0!}{5!} = \\frac{1}{20}$，$I_{21} = \\frac{2!1!}{5!} = \\frac{1}{60}$\n\\end{itemize}\n由于区域 $\\mathcal{T}$ 关于直线 $y=x$ 对称，我们有 $I_{ij} = I_{ji}$。\n\n该求积格式有四个节点。从重心坐标 $(\\lambda_1, \\lambda_2, \\lambda_3)$ 到笛卡尔坐标的映射是 $(x,y) = (\\lambda_2, \\lambda_3)$。\n\\begin{enumerate}\n    \\item 一个节点位于形心 $P_c$：重心坐标 $(\\frac{1}{3},\\frac{1}{3},\\frac{1}{3})$，笛卡尔坐标 $(x_c,y_c) = (\\frac{1}{3},\\frac{1}{3})$。其权重为 $w_c$。\n    \\item 三个节点由重心坐标 $(a,a,1-2a)$ 的排列定义。节点在 $\\mathcal{T}$ 内的约束要求 $a \\ge 0$ 和 $1-2a \\ge 0$，因此 $0 \\le a \\le \\frac{1}{2}$。\n    \\begin{itemize}\n        \\item $P_{a1}$：由 $(\\lambda_1,\\lambda_2,\\lambda_3) = (a,a,1-2a) \\implies (x,y) = (a, 1-2a)$\n        \\item $P_{a2}$：由 $(\\lambda_1,\\lambda_2,\\lambda_3) = (a,1-2a,a) \\implies (x,y) = (1-2a, a)$\n        \\item $P_{a3}$：由 $(\\lambda_1,\\lambda_2,\\lambda_3) = (1-2a,a,a) \\implies (x,y) = (a, a)$\n    \\end{itemize}\n    这三个节点有共同的权重 $w_a$。\n\\end{enumerate}\n对于一个函数 $f(x,y)$，其求和（记作 $Q(f)$）为：\n$$ Q(f) = w_c f(\\tfrac{1}{3},\\tfrac{1}{3}) + w_a \\left[ f(a, 1-2a) + f(1-2a, a) + f(a,a) \\right] $$\n我们强制对 $i+j \\le 3$ 成立 $Q(x^i y^j) = I_{ij}$。由于该格式构造的对称性，如果该条件对 $x^i y^j$ 成立，那么它对 $x^j y^i$ 也自动成立。我们只需要测试一组非对称单项式的基：\n\\begin{enumerate}\n    \\item 0次 ($1$)：$I_{00} = \\frac{1}{2}$。$Q(1) = w_c + 3w_a$。 $\\implies w_c + 3w_a = \\frac{1}{2} \\quad (1)$\n    \\item 1次 ($x$)：$I_{10} = \\frac{1}{6}$。$Q(x) = w_c(\\frac{1}{3}) + w_a(a + (1-2a) + a) = \\frac{w_c}{3} + w_a$。 $\\implies \\frac{w_c}{3} + w_a = \\frac{1}{6} \\quad (2)$\n    将方程(2)乘以 $3$ 得到 $w_c + 3w_a = \\frac{1}{2}$，这与(1)相同。这表明存在退化，我们必须继续到更高次数。\n    \\item 2次 ($x^2$)：$I_{20} = \\frac{1}{12}$。$Q(x^2) = w_c(\\frac{1}{3})^2 + w_a(a^2 + (1-2a)^2 + a^2) = \\frac{w_c}{9} + w_a(6a^2-4a+1)$。\n    $\\implies \\frac{w_c}{9} + w_a(6a^2-4a+1) = \\frac{1}{12} \\quad (3)$\n    \\item 2次 ($xy$)：$I_{11} = \\frac{1}{24}$。$Q(xy) = w_c(\\frac{1}{3})^2 + w_a(a(1-2a) + (1-2a)a + a^2) = \\frac{w_c}{9} + w_a(2a-3a^2)$。\n    $\\implies \\frac{w_c}{9} + w_a(2a-3a^2) = \\frac{1}{24} \\quad (4)$\n\\end{enumerate}\n从(3)中减去(4)：$w_a[(6a^2-4a+1) - (2a-3a^2)] = \\frac{1}{12} - \\frac{1}{24} = \\frac{1}{24}$。\n这可以简化为 $w_a(9a^2 - 6a + 1) = \\frac{1}{24}$，或 $w_a(3a-1)^2 = \\frac{1}{24} \\quad (5)$。\n将(1)中的 $w_c = \\frac{1}{2} - 3w_a$ 代入(4)中可以证实同样的关系，这表明二次多项式的方程只提供了一个新的独立约束。我们必须使用三次多项式。\n\\begin{enumerate}\n    \\item[5.] 3次 ($x^3$)：$I_{30} = \\frac{1}{20}$。$Q(x^3) = w_c(\\frac{1}{27}) + w_a(a^3 + (1-2a)^3 + a^3) = \\frac{w_c}{27} + w_a(-6a^3+12a^2-6a+1)$。\n    $\\implies \\frac{w_c}{27} + w_a(-6a^3+12a^2-6a+1) = \\frac{1}{20} \\quad (6)$\n    \\item[6.] 3次 ($x^2y$)：$I_{21} = \\frac{1}{60}$。$Q(x^2y) = w_c(\\frac{1}{27}) + w_a(a^2(1-2a) + (1-2a)^2 a + a^3) = \\frac{w_c}{27} + w_a(3a^3-3a^2+a)$。\n    $\\implies \\frac{w_c}{27} + w_a(3a^3-3a^2+a) = \\frac{1}{60} \\quad (7)$\n\\end{enumerate}\n从(6)中减去(7)：$w_a[(-6a^3+12a^2-6a+1) - (3a^3-3a^2+a)] = \\frac{1}{20} - \\frac{1}{60} = \\frac{1}{30}$。\n这可以简化为 $w_a(-9a^3+15a^2-7a+1) = \\frac{1}{30} \\quad (8)$。\n我们现在解由(5)和(8)组成的方程组。假设 $a \\ne \\frac{1}{3}$ (因为如果 $a=\\frac{1}{3}$，(5)式变为 $0 = \\frac{1}{24}$，这是一个矛盾)，我们可以将(8)除以(5)：\n$$ \\frac{w_a(-9a^3+15a^2-7a+1)}{w_a(9a^2-6a+1)} = \\frac{1/30}{1/24} = \\frac{24}{30} = \\frac{4}{5} $$\n$$ 5(-9a^3+15a^2-7a+1) = 4(9a^2-6a+1) $$\n$$ -45a^3 + 75a^2 - 35a + 5 = 36a^2 - 24a + 4 $$\n$$ 45a^3 - 39a^2 + 11a - 1 = 0 $$\n这个关于 $a$ 的三次方程可以因式分解为 $(5a-1)(9a^2-6a+1) = (5a-1)(3a-1)^2 = 0$。\n其根为 $a = \\frac{1}{5}$ 和一个二重根 $a = \\frac{1}{3}$。如前所述，$a \\ne \\frac{1}{3}$，所以唯一有效的解是 $a = \\frac{1}{5}$。该值位于所需范围 $[0, \\frac{1}{2}]$ 内。\n\n当 $a = \\frac{1}{5}$ 时，我们求权重。由(5)式：\n$w_a(3(\\frac{1}{5})-1)^2 = \\frac{1}{24} \\implies w_a(-\\frac{2}{5})^2 = \\frac{1}{24} \\implies w_a(\\frac{4}{25}) = \\frac{1}{24} \\implies w_a = \\frac{25}{96}$。\n由(1)式：\n$w_c = \\frac{1}{2} - 3w_a = \\frac{1}{2} - 3(\\frac{25}{96}) = \\frac{1}{2} - \\frac{75}{96} = \\frac{48-75}{96} = -\\frac{27}{96} = -\\frac{9}{32}$。\n\n因此，参数为 $a = \\frac{1}{5}$，$w_a = \\frac{25}{96}$，以及 $w_c = -\\frac{9}{32}$。我们已经成功地构造了指定的求积格式。根据其构造，它对所有总次数最高为 $3$ 的多项式都是精确的；其代数精度为 $3$。\n\n最后，我们必须计算最大绝对误差：\n$$ E \\;=\\; \\max_{\\,i,j \\,\\ge 0,\\, i+j \\le 3} \\left| \\int_{\\mathcal{T}} x^{i} y^{j} \\, dx\\,dy \\;-\\; \\sum_{k=1}^{4} w_{k}\\, x_{k}^{i} y_{k}^{j} \\right| $$\n单项式集合 $\\{x^i y^j \\,:\\, i,j \\ge 0, i+j \\le 3\\}$ 构成了次数至多为 $3$ 的多项式空间的一组基。我们的构造强制要求对于这些基单项式中的每一个，求积误差都精确为零。也就是说，对于每一对满足 $i,j \\ge 0$ 和 $i+j \\le 3$ 的整数 $i, j$：\n$$ \\int_{\\mathcal{T}} x^{i} y^{j} \\, dx\\,dy \\;-\\; \\sum_{k=1}^{4} w_{k}\\, x_{k}^{i} y_{k}^{j} = 0 $$\n因此，对于所有考虑的单项式，绝对值内的项均为 $0$。一组零的最大值为 $0$。\n因此，$E=0$。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "在数值模拟中，拥有一个精确的求积法则只是第一步；如何高效地应用它同样至关重要。这个高级练习模拟了有限元方法中的一个常见场景：计算一个由非多项式系数和多项式基函数乘积构成的积分。 您将对比两种不同的策略——一种是“免求积”的矩量法，另一种是直接对整个被积函数进行高斯求积。通过分析每种方法的准确性和计算成本（以函数求值次数衡量），您将深入理解在实际的高性能科学计算中，必须在精度和效率之间做出权衡的现实考量。",
            "id": "3398403",
            "problem": "考虑在一维和二维空间中，为参考域上的拉格朗日单元组装局部质量矩阵。设双线性形式由 $m(u,v) = \\int_{\\hat{K}} a(\\boldsymbol{x})\\, u(\\boldsymbol{x})\\, v(\\boldsymbol{x}) \\, d\\boldsymbol{x}$ 给出，其中在一维中 $\\hat{K}=[-1,1]$，在二维中 $\\hat{K}=[-1,1]^2$，$u$ 和 $v$ 取自各自参考域上的一阶拉格朗日基函数的张成空间。系数 $a(\\boldsymbol{x})$ 是光滑但非多项式的。\n\n将比较两种组装策略：\n\n- 多项式部分的无求积分解：将积分项写为 $a(\\boldsymbol{x}) p(\\boldsymbol{x})$，其中 $p(\\boldsymbol{x})= \\phi_i(\\boldsymbol{x}) \\phi_j(\\boldsymbol{x})$ 是基函数乘积产生的多项式。利用 $p(\\boldsymbol{x})$ 具有有限单项式展开以及单项式可以用足够阶数的高斯求积精确积分的事实。推导出一个表示，该表示分离出形如 $\\int_{\\hat{K}} a(\\boldsymbol{x})\\, \\boldsymbol{x}^{\\boldsymbol{\\alpha}} \\, d\\boldsymbol{x}$ 的积分（系数对单项式的矩），并仅用单独的高斯求积来近似这些矩。对多项式因子的解析操作必须是精确的。\n\n- 完整积分项的直接高斯求积：通过在高斯节点上计算 $a(\\boldsymbol{x})$ 和基函数乘积的值，并与相应的权重求和，来近似 $\\int_{\\hat{K}} a(\\boldsymbol{x}) \\phi_i(\\boldsymbol{x}) \\phi_j(\\boldsymbol{x})\\, d\\boldsymbol{x}$。\n\n使用以下基本事实作为推导的起点：\n\n- 在一维中，使用 $n$ 个点在 $[-1,1]$ 上的高斯-勒让德求积可以精确积分任何次数至多为 $2n-1$ 的多项式。\n\n- 在张量积域上，张量积高斯求积逐坐标地对可分离的多项式乘积进行积分，并逐坐标地保持一维的精确性属性。\n\n- $[-1,1]$ 上的一阶拉格朗日基函数是 $1$ 次多项式。$[-1,1]^2$ 上的一阶双线性基函数是一维 $1$ 次多项式的乘积。\n\n你的任务是，对下面的每个测试用例：\n\n- 使用指定的系数 $a(\\boldsymbol{x})$，在参考域上对两种方法组装局部质量矩阵。\n\n- 通过足够高阶的高斯求积计算一个高精度参考矩阵，用作基准真相。\n\n- 通过组装矩阵与参考矩阵之差的弗罗贝尼乌斯范数来量化每种方法的精度。\n\n- 通过每个单元所需的系数 $a(\\boldsymbol{x})$ 的求值次数来量化每种方法的计算成本（不计算基函数或权重的算术运算；仅计算在某点上求值 $a$ 的调用次数）。\n\n- 对每个测试用例，返回一个列表，其中包含：无求积方法的误差、直接高斯求积方法的误差、无求积方法的成本和直接方法的成本。\n\n细节和约定：\n\n- 一维（$d=1$）：在 $[-1,1]$ 上使用线性基 $\\{\\phi_1(x),\\phi_2(x)\\}$。\n\n- 二维（$d=2$）：使用与 $[-1,1]^2$ 四个角点相关的双线性基 $\\{\\phi_i(x,y)\\}_{i=1}^4$。\n\n- 对于无求积方法，你必须首先对 $\\phi_i \\phi_j$ 进行精确的多项式展开，然后仅通过高斯求积来近似系数-矩积分 $\\int_{\\hat{K}} a(\\boldsymbol{x})\\, \\boldsymbol{x}^{\\boldsymbol{\\alpha}} \\, d\\boldsymbol{x}$。你必须为给定单元中的所有所需矩重复使用在同一高斯节点上对 $a(\\boldsymbol{x})$ 的求值，以最小化成本。\n\n- 对于直接方法，你必须仅在高斯节点上求值 $a(\\boldsymbol{x})$，将这些值重复用于局部矩阵的所有条目，并构建标准的求积和。\n\n- 使用通过每坐标 $n_{\\mathrm{ref}}=50$ 个一维高斯-勒让德点获得的高精度参考，在二维中应用张量积。\n\n- 本问题不涉及角度单位。\n\n测试套件包括以下五个案例，每个案例描述了空间维度、系数以及两种方法的求积阶数：\n\n- 案例 A（理想情况，中等平滑度，一维）：$d=1$，$a(x)=\\exp(\\sin(x))$，无求积矩求积使用 $n_c=2$，直接求积使用 $n_d=2$。\n\n- 案例 B（更多振荡，一维）：$d=1$，$a(x)=\\exp(\\sin(5x))$，无求积矩求积使用 $n_c=3$，直接求积使用 $n_d=5$。\n\n- 案例 C（中等平滑度，二维）：$d=2$，$a(x,y)=\\exp\\!\\big(0.5\\,\\sin(3x)+0.25\\,\\cos(4y)\\big)$，无求积矩求积使用 $(n_c^x,n_c^y)=(3,3)$，直接求积使用 $(n_d^x,n_d^y)=(3,3)$。\n\n- 案例 D（边缘情况，近多项式系数，二维）：$d=2$，$a(x,y)=1+10^{-8}\\,\\sin(10x)\\cos(10y)$，无求积矩求积使用 $(n_c^x,n_c^y)=(1,1)$，直接求积使用 $(n_d^x,n_d^y)=(1,1)$。\n\n- 案例 E（高振荡，二维）：$d=2$，$a(x,y)=\\exp\\!\\big(2\\,\\sin(10x)+\\cos(10y)\\big)$，无求积矩求积使用 $(n_c^x,n_c^y)=(3,3)$，直接求积使用 $(n_d^x,n_d^y)=(5,5)$。\n\n最终输出格式：\n\n- 你的程序应生成单行输出，其中包含五个案例的结果列表，顺序与上面列出的一致。每个案例的结果必须是包含四个数字的列表，顺序为 $[\\mathrm{err}_{\\mathrm{QF}},\\mathrm{err}_{\\mathrm{DQ}},\\mathrm{cost}_{\\mathrm{QF}},\\mathrm{cost}_{\\mathrm{DQ}}]$，其中误差是实数（浮点数），成本是整数。输出必须是单行，不带任何附加文本，格式为用方括号括起来的逗号分隔列表。例如：[[eA_qf,eA_dq,cA_qf,cA_dq],[eB_qf,eB_dq,cB_qf,cB_dq],...]。",
            "solution": "该问题要求比较两种不同的数值策略，用于在参考域上为一阶拉格朗日单元组装局部质量矩阵 $M_{ij} = \\int_{\\hat{K}} a(\\boldsymbol{x}) \\phi_i(\\boldsymbol{x}) \\phi_j(\\boldsymbol{x}) \\, d\\boldsymbol{x}$。这两种策略是“无求积”（QF）分解方法和标准的直接高斯求积（DQ）方法。\n\n设 $\\hat{K}$ 为参考单元，在一维（$d=1$）中为 $[-1,1]$，在二维（$d=2$）中为 $[-1,1]^2$。函数 $\\phi_i$ 是与单元节点相关的一阶拉格朗日基函数。系数 $a(\\boldsymbol{x})$ 是一个光滑的非多项式函数。\n\n**1. 数学公式和基函数**\n\n在一维（$d=1$）中，参考单元是 $\\hat{K} = [-1,1]$。与节点 $x=-1$ 和 $x=1$ 相关的一阶（线性）拉格朗日基函数是：\n$$\n\\phi_1(x) = \\frac{1-x}{2}, \\quad \\phi_2(x) = \\frac{1+x}{2}\n$$\n局部质量矩阵 $M$ 是一个 $2 \\times 2$ 矩阵，其条目为 $M_{ij} = \\int_{-1}^{1} a(x) \\phi_i(x) \\phi_j(x) \\, dx$。\n\n在二维（$d=2$）中，参考单元是正方形 $\\hat{K} = [-1,1]^2$。一阶（双线性）拉格朗日基函数由一维基函数的张量积形成。假设从 $(-1,-1)$ 开始逆时针节点排序，四个基函数是：\n$$\n\\begin{aligned}\n\\phi_1(x,y) = \\phi_1(x)\\phi_1(y) = \\frac{1}{4}(1-x)(1-y)  \\quad \\text{(节点 } (-1,-1)) \\\\\n\\phi_2(x,y) = \\phi_2(x)\\phi_1(y) = \\frac{1}{4}(1+x)(1-y)  \\quad \\text{(节点 } (1,-1)) \\\\\n\\phi_3(x,y) = \\phi_2(x)\\phi_2(y) = \\frac{1}{4}(1+x)(1+y)  \\quad \\text{(节点 } (1,1)) \\\\\n\\phi_4(x,y) = \\phi_1(x)\\phi_2(y) = \\frac{1}{4}(1-x)(1+y)  \\quad \\text{(节点 } (-1,1))\n\\end{aligned}\n$$\n局部质量矩阵 $M$ 是一个 $4 \\times 4$ 矩阵，其条目为 $M_{ij} = \\int_{-1}^{1}\\int_{-1}^{1} a(x,y) \\phi_i(x,y) \\phi_j(x,y) \\, dx \\, dy$。\n\n**2. 方法 1：无求积（QF）分解**\n\n此方法将积分项分离为一个非多项式部分 $a(\\boldsymbol{x})$ 和一个多项式部分 $p_{ij}(\\boldsymbol{x}) = \\phi_i(\\boldsymbol{x})\\phi_j(\\boldsymbol{x})$。多项式 $p_{ij}(\\boldsymbol{x})$ 被展开为单项式基，$p_{ij}(\\boldsymbol{x}) = \\sum_{\\boldsymbol{\\alpha}} c_{ij,\\boldsymbol{\\alpha}} \\boldsymbol{x}^{\\boldsymbol{\\alpha}}$，其中 $\\boldsymbol{\\alpha}$ 是一个多重索引。矩阵条目则为：\n$$\nM_{ij} = \\int_{\\hat{K}} a(\\boldsymbol{x}) \\sum_{\\boldsymbol{\\alpha}} c_{ij,\\boldsymbol{\\alpha}} \\boldsymbol{x}^{\\boldsymbol{\\alpha}} \\, d\\boldsymbol{x} = \\sum_{\\boldsymbol{\\alpha}} c_{ij,\\boldsymbol{\\alpha}} \\left( \\int_{\\hat{K}} a(\\boldsymbol{x}) \\boldsymbol{x}^{\\boldsymbol{\\alpha}} \\, d\\boldsymbol{x} \\right) = \\sum_{\\boldsymbol{\\alpha}} c_{ij,\\boldsymbol{\\alpha}} \\mu_{\\boldsymbol{\\alpha}}\n$$\n积分 $\\mu_{\\boldsymbol{\\alpha}} = \\int_{\\hat{K}} a(\\boldsymbol{x}) \\boldsymbol{x}^{\\boldsymbol{\\alpha}} \\, d\\boldsymbol{x}$ 是系数函数的矩。这些是唯一通过数值求积近似的量。设 $\\{(\\boldsymbol{w}_q, \\boldsymbol{x}_q)\\}_{q=1}^{N_c}$ 是具有 $N_c$ 个点的高斯求积法则的点和权重。矩近似为：\n$$\n\\mu_{\\boldsymbol{\\alpha}} \\approx \\sum_{q=1}^{N_c} w_q a(\\boldsymbol{x}_q) \\boldsymbol{x}_q^{\\boldsymbol{\\alpha}}\n$$\n计算成本是此求积法则中的点数 $N_c$，因为 $a(\\boldsymbol{x}_q)$ 的求值计算一次后，会为所有需要的矩 $\\mu_{\\boldsymbol{\\alpha}}$ 以及随后为所有矩阵条目 $M_{ij}$ 重复使用。\n\n对于 $d=1$，基函数乘积是次数最高为 $2$ 的多项式。\n- $\\phi_1(x)^2 = \\frac{1}{4}(1 - 2x + x^2)$\n- $\\phi_2(x)^2 = \\frac{1}{4}(1 + 2x + x^2)$\n- $\\phi_1(x)\\phi_2(x) = \\frac{1}{4}(1 - x^2)$\n我们需要计算 $k \\in \\{0, 1, 2\\}$ 的矩 $\\mu_k = \\int_{-1}^1 a(x) x^k dx$。矩阵条目组装如下：\n$M_{11} = \\frac{1}{4}(\\mu_0 - 2\\mu_1 + \\mu_2)$，$M_{22} = \\frac{1}{4}(\\mu_0 + 2\\mu_1 + \\mu_2)$，$M_{12} = M_{21} = \\frac{1}{4}(\\mu_0 - \\mu_2)$。成本是 $n_c$ 次对 $a(x)$ 的求值。\n\n对于 $d=2$，乘积 $\\phi_i\\phi_j$ 是一个双二次多项式，在每个变量中的最高次数为 $2$。单项式展开的一般形式是 $\\sum_{k=0}^2 \\sum_{l=0}^2 c_{ijkl} x^k y^l$。这需要计算 $k,l \\in \\{0,1,2\\}$ 的 $9$ 个矩 $\\mu_{kl} = \\int_{-1}^1\\int_{-1}^1 a(x,y) x^k y^l \\, dx\\,dy$。系数 $c_{ijkl}$ 通过一维多项式乘积系数的张量积找到。对于具有 $(n_c^x, n_c^y)$ 个点的张量积求积法则，成本是对 $a(x,y)$ 的 $n_c^x n_c^y$ 次求值。\n\n**3. 方法 2：直接高斯求积（DQ）**\n\n这是标准方法，其中整个积分项 $f_{ij}(\\boldsymbol{x}) = a(\\boldsymbol{x}) \\phi_i(\\boldsymbol{x}) \\phi_j(\\boldsymbol{x})$ 直接使用高斯求积法则 $\\{(\\boldsymbol{w}_q, \\boldsymbol{x}_q)\\}_{q=1}^{N_d}$ 进行近似：\n$$\nM_{ij} = \\int_{\\hat{K}} f_{ij}(\\boldsymbol{x}) \\, d\\boldsymbol{x} \\approx \\sum_{q=1}^{N_d} w_q f_{ij}(\\boldsymbol{x}_q) = \\sum_{q=1}^{N_d} w_q a(\\boldsymbol{x}_q) \\phi_i(\\boldsymbol{x}_q) \\phi_j(\\boldsymbol{x}_q)\n$$\n在求积点上对 $a(\\boldsymbol{x}_q)$ 和基函数 $\\phi_i(\\boldsymbol{x}_q)$ 的求值执行一次，并为所有条目 $M_{ij}$ 重复使用。计算成本是求积点的数量 $N_d$。在一维中，这是 $n_d$。在二维中，对于张量积法则，它是 $n_d^x n_d^y$。\n\n**4. 参考解、误差和成本**\n\n对于每种情况，使用大量点（每维 $n_{\\mathrm{ref}}=50$）的直接求积方法计算一个高精度参考矩阵 $M_{\\mathrm{ref}}$。每种方法的精度通过计算矩阵与参考矩阵之差的弗罗贝尼乌斯范数量化：\n$$\n\\mathrm{err} = \\| M - M_{\\mathrm{ref}} \\|_F = \\sqrt{\\sum_{i,j} |M_{ij} - (M_{\\mathrm{ref}})_{ij}|^2}\n$$\n计算成本定义为组装整个局部质量矩阵所需的系数函数 $a(\\boldsymbol{x})$ 的求值次数。\n\n实现将首先设置函数以生成高斯-勒让德求积法则和评估基函数。然后，为 QF 和 DQ 组装方法实现单独的函数，并仔细跟踪成本度量。最后，一个遍历测试用例的循环计算矩阵、误差和成本，并按规定格式化结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the final result.\n    \"\"\"\n    # Define test cases from the problem statement\n    # Format: (dimension, a_func, n_c_points, n_d_points)\n    test_cases = [\n        (1, lambda x: np.exp(np.sin(x)), 2, 2),\n        (1, lambda x: np.exp(np.sin(5*x)), 3, 5),\n        (2, lambda x, y: np.exp(0.5 * np.sin(3*x) + 0.25 * np.cos(4*y)), (3, 3), (3, 3)),\n        (2, lambda x, y: 1.0 + 1e-8 * np.sin(10*x) * np.cos(10*y), (1, 1), (1, 1)),\n        (2, lambda x, y: np.exp(2 * np.sin(10*x) + np.cos(10*y)), (3, 3), (5, 5))\n    ]\n\n    n_ref = 50\n    all_results = []\n\n    for d, a_func, n_c, n_d in test_cases:\n        # --- High-accuracy reference solution ---\n        if d == 1:\n            m_ref, _ = assemble_matrix_dq(d, a_func, n_ref)\n        else:  # d == 2\n            m_ref, _ = assemble_matrix_dq(d, a_func, (n_ref, n_ref))\n\n        # --- Quadrature-Free (QF) approach ---\n        m_qf, cost_qf = assemble_matrix_qf(d, a_func, n_c)\n        err_qf = np.linalg.norm(m_qf - m_ref, 'fro')\n\n        # --- Direct Quadrature (DQ) approach ---\n        m_dq, cost_dq = assemble_matrix_dq(d, a_func, n_d)\n        err_dq = np.linalg.norm(m_dq - m_ref, 'fro')\n\n        all_results.append([err_qf, err_dq, cost_qf, cost_dq])\n\n    # Format the final output string exactly as required\n    print(f\"[{','.join([str(r) for r in all_results])}]\")\n\n\ndef get_basis_functions(d):\n    \"\"\"\n    Returns a list of lambda functions for the first-order Lagrange basis\n    on the reference element and the number of basis functions.\n    \"\"\"\n    if d == 1:\n        phi = [lambda x: 0.5 * (1 - x), lambda x: 0.5 * (1 + x)]\n        return phi, 2\n    elif d == 2:\n        phi_1d = [lambda t: 0.5 * (1 - t), lambda t: 0.5 * (1 + t)]\n        # Node ordering: (-1,-1), (1,-1), (1,1), (-1,1)\n        phi = [\n            lambda x, y: phi_1d[0](x) * phi_1d[0](y),\n            lambda x, y: phi_1d[1](x) * phi_1d[0](y),\n            lambda x, y: phi_1d[1](x) * phi_1d[1](y),\n            lambda x, y: phi_1d[0](x) * phi_1d[1](y)\n        ]\n        return phi, 4\n    raise ValueError(\"Dimension must be 1 or 2.\")\n\n\ndef assemble_matrix_dq(d, a_func, n_quad):\n    \"\"\"\n    Assembles the mass matrix using the Direct Quadrature (DQ) approach.\n    \"\"\"\n    basis_funcs, num_basis = get_basis_functions(d)\n    M = np.zeros((num_basis, num_basis))\n\n    if d == 1:\n        nodes, weights = roots_legendre(n_quad)\n        a_vals = a_func(nodes)\n        cost = len(nodes)\n        phi_vals = np.array([phi(nodes) for phi in basis_funcs])  # Shape (num_basis, n_quad)\n        for i in range(num_basis):\n            for j in range(i, num_basis):\n                integrand = a_vals * phi_vals[i, :] * phi_vals[j, :]\n                M[i, j] = np.sum(weights * integrand)\n                if i != j: M[j, i] = M[i, j]\n    elif d == 2:\n        nx, ny = n_quad\n        nodes_x, weights_x = roots_legendre(nx)\n        nodes_y, weights_y = roots_legendre(ny)\n        cost = nx * ny\n\n        xx, yy = np.meshgrid(nodes_x, nodes_y)\n        ww = np.outer(weights_y, weights_x)\n\n        a_vals = a_func(xx, yy)\n        phi_vals = np.array([phi(xx, yy) for phi in basis_funcs])  # Shape (num_basis, ny, nx)\n\n        for i in range(num_basis):\n            for j in range(i, num_basis):\n                integrand = a_vals * phi_vals[i, :, :] * phi_vals[j, :, :]\n                M[i, j] = np.sum(ww * integrand)\n                if i != j: M[j, i] = M[i, j]\n\n    return M, cost\n\n\ndef assemble_matrix_qf(d, a_func, n_quad):\n    \"\"\"\n    Assembles the mass matrix using the Quadrature-Free (QF) moment-based approach.\n    \"\"\"\n    _, num_basis = get_basis_functions(d)\n    M = np.zeros((num_basis, num_basis))\n\n    if d == 1:\n        nodes, weights = roots_legendre(n_quad)\n        a_vals = a_func(nodes)\n        cost = len(nodes)\n\n        # Compute moments mu_k = integral(a(x) * x^k dx) for k=0,1,2\n        mu = np.array([np.sum(weights * a_vals * (nodes**k)) for k in range(3)])\n\n        # Assemble matrix from moments based on polynomial expansion of phi_i*phi_j\n        M[0, 0] = 0.25 * (mu[0] - 2 * mu[1] + mu[2])\n        M[0, 1] = 0.25 * (mu[0] - mu[2])\n        M[1, 0] = M[0, 1]\n        M[1, 1] = 0.25 * (mu[0] + 2 * mu[1] + mu[2])\n    elif d == 2:\n        nx, ny = n_quad\n        nodes_x, weights_x = roots_legendre(nx)\n        nodes_y, weights_y = roots_legendre(ny)\n        cost = nx * ny\n\n        xx, yy = np.meshgrid(nodes_x, nodes_y)\n        ww = np.outer(weights_y, weights_x)\n        a_vals = a_func(xx, yy)\n\n        # Compute moments mu_kl = integral(a(x,y) * x^k * y^l dx dy)\n        moments = np.zeros((3, 3))\n        for k in range(3):\n            for l in range(3):\n                moments[k, l] = np.sum(ww * a_vals * (xx**k) * (yy**l))\n\n        # 1D product polynomial coefficients (for powers 0, 1, 2)\n        C_p1_p1 = 0.25 * np.array([1, -2, 1])\n        C_p2_p2 = 0.25 * np.array([1, 2, 1])\n        C_p1_p2 = 0.25 * np.array([1, 0, -1])\n        C_map = {(1, 1): C_p1_p1, (2, 2): C_p2_p2, (1, 2): C_p1_p2, (2, 1): C_p1_p2}\n        \n        # Maps basis function index {0,1,2,3} to its 1D component indices {1,2}\n        node_to_basis_idx = {0: (1, 1), 1: (2, 1), 2: (2, 2), 3: (1, 2)}\n\n        for i in range(num_basis):\n            for j in range(i, num_basis):\n                ix, iy = node_to_basis_idx[i]\n                jx, jy = node_to_basis_idx[j]\n                \n                Cx = C_map[(ix, jx)]\n                Cy = C_map[(iy, jy)]\n                \n                # 2D coefficient matrix from outer product of 1D coeff vectors\n                C_matrix = np.outer(Cx, Cy)\n                \n                M[i, j] = np.sum(C_matrix * moments)\n                if i != j: M[j, i] = M[i, j]\n\n    return M, cost\n\nsolve()\n```"
        }
    ]
}