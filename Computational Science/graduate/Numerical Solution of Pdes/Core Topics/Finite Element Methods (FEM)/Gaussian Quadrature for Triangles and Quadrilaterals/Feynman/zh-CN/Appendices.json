{
    "hands_on_practices": [
        {
            "introduction": "在三角形上进行积分可能很繁琐，因为其几何形状不便于使用简单的张量积规则。Duffy变换提供了一种优雅的方法，可以将单位正方形映射到参考三角形上。通过这种变量代换，我们可以利用那些为正方形域自然定义、并且高效的张量积高斯求积法则。本练习将引导你构建这样一个映射，并将其应用于一个精确的积分计算中，从而揭示在高斯求积理论中，域变换的核心作用。",
            "id": "3398652",
            "problem": "设 $T$ 为参考三角形 $T=\\{(x,y)\\in\\mathbb{R}^{2}: x\\ge 0,\\ y\\ge 0,\\ x+y\\le 1\\}$，并设 $S=[0,1]^{2}$ 为单位正方形。考虑积分\n$$\nI=\\iint_{T} x^{2}\\,y^{5}\\,\\bigl(1-x-y\\bigr)^{3}\\,dx\\,dy.\n$$\n仅从多变量积分的换元定理和 $[-1,1]$ 上 $m$ 点 Gauss–Legendre 法则的多项式精确性（该法则对所有次数最高为 $2m-1$ 的多项式都精确）出发，完成以下任务：\n\n(i) 构造一个 Duffy 型映射 $F:S\\to T$，该映射将 $S$ 中的一条坐标线压缩到 $T$ 的一个顶点，并将 $S$ 的边映射到 $T$ 的边。推导其雅可比行列式 $J(u,v)$。\n\n(ii) 使用此映射将 $I$ 转换为 $S$ 上的一个累次积分，并尽可能简化变换后的被积函数，将其表示为 $u$ 和 $v$ 的一维因子与 $|J(u,v)|$ 的乘积。\n\n(iii) 根据所得的关于 $u$ 和 $v$ 的一维多项式因子的次数，确定最小的 Gauss–Legendre 阶数 $m_{u}$ 和 $m_{v}$，使得 $S$ 上的张量积法则对变换后的被积函数是精确的。\n\n(iv) 精确计算 $I$。\n\n你的最终答案必须是 $I$ 的精确值，以单个简化数或无单位的闭式解析表达式的形式给出。不要四舍五入。",
            "solution": "该问题被评估为有效的，因为其科学基础在于多元微积分和数值分析理论，问题提法良好，目标明确，且没有任何矛盾、歧义或不合理的假设。\n\n该问题要求计算在参考三角形 $T=\\{(x,y)\\in\\mathbb{R}^{2}: x\\ge 0,\\ y\\ge 0,\\ x+y\\le 1\\}$ 上的积分\n$$\nI=\\iint_{T} x^{2}\\,y^{5}\\,\\bigl(1-x-y\\bigr)^{3}\\,dx\\,dy\n$$\n，并遵循一个涉及 Duffy 型变换的特定程序。\n\n(i) 映射及其雅可比行列式的构造\n一个从单位正方形 $S=[0,1]^{2}$到参考三角形 $T$ 的 Duffy 型映射 $F:S \\to T$ 可以这样定义：将第一个坐标直接映射到 $x$，然后缩放第二个坐标以适应剩余的三角形区域。设 $(u,v) \\in S$。我们将映射 $F(u,v) = (x,y)$ 定义为：\n$$\nx(u,v) = u\n$$\n$$\ny(u,v) = v(1-u)\n$$\n我们来验证这个映射。定义域为 $(u,v) \\in [0,1] \\times [0,1]$。\n对于任意 $(u,v) \\in S$：\n- $x=u \\ge 0$。\n- 由于 $u \\le 1$ 且 $v \\ge 0$，我们有 $y = v(1-u) \\ge 0$。\n- $x+y = u+v(1-u)$。由于 $v \\le 1$，所以 $x+y \\le u+(1-u)=1$。\n因此，$S$ 的像包含在 $T$ 中。\n我们来检查边界：\n- $S$ 中 $u=0$ 的边映射到 $(x,y)=(0,v)$，其中 $v \\in [0,1]$，这是 $T$ 的垂直边。\n- $S$ 中 $u=1$ 的边映射到 $(x,y)=(1,0)$，这是 $T$ 的一个顶点。这满足了一条坐标线被压缩到一个顶点的要求。\n- $S$ 中 $v=0$ 的边映射到 $(x,y)=(u,0)$，其中 $u \\in [0,1]$，这是 $T$ 的水平边。\n- $S$ 中 $v=1$ 的边映射到 $(x,y)=(u, 1-u)$，这对应于 $T$ 的斜边 $x+y=1$。\n该映射是从 $S$ 的内部到 $T$ 的内部的一个双射。\n\n为了求雅可比行列式，我们首先计算雅可比矩阵 $\\mathbf{J}_F(u,v)$：\n$$\n\\mathbf{J}_F(u,v) = \\begin{pmatrix} \\frac{\\partial x}{\\partial u}  \\frac{\\partial x}{\\partial v} \\\\ \\frac{\\partial y}{\\partial u}  \\frac{\\partial y}{\\partial v} \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ -v  1-u \\end{pmatrix}\n$$\n雅可比行列式，记为 $J(u,v)$，为：\n$$\nJ(u,v) = \\det(\\mathbf{J}_F(u,v)) = (1)(1-u) - (0)(-v) = 1-u\n$$\n\n(ii) 积分的变换\n使用多重积分的换元定理，我们有 $dx\\,dy = |J(u,v)|\\,du\\,dv$。由于 $u \\in [0,1]$，所以 $|J(u,v)| = |1-u| = 1-u$。\n积分 $I$ 变换如下：\n$$\nI = \\iint_{S} f(x(u,v), y(u,v)) |J(u,v)| \\,du\\,dv\n$$\n其中 $f(x,y) = x^2 y^5 (1-x-y)^3$。我们将 $x$、$y$ 和 $1-x-y$ 用 $u$ 和 $v$ 的表达式代入：\n- $x = u$\n- $y = v(1-u)$\n- $1-x-y = 1-u-v(1-u) = (1-u)(1-v)$\n$f(x(u,v), y(u,v))$ 项变为：\n$$\n(u)^2 [v(1-u)]^5 [(1-u)(1-v)]^3 = u^2 v^5 (1-u)^5 (1-u)^3 (1-v)^3 = u^2 v^5 (1-u)^8 (1-v)^3\n$$\n$(u,v)$ 坐标下的完整被积函数是此表达式乘以 $|J(u,v)| = 1-u$：\n$$\n\\text{Integrand} = \\left( u^2 v^5 (1-u)^8 (1-v)^3 \\right) (1-u) = u^2 v^5 (1-u)^9 (1-v)^3\n$$\n在正方形 $S=[0,1]^2$ 上的积分 $I$ 为：\n$$\nI = \\int_{0}^{1} \\int_{0}^{1} u^2 (1-u)^9 v^5 (1-v)^3 \\,du\\,dv\n$$\n被积函数是一个关于 $u$ 的函数与一个关于 $v$ 的函数的乘积。我们可以将累次积分分离为两个一维积分的乘积：\n$$\nI = \\left(\\int_{0}^{1} u^2 (1-u)^9 \\,du\\right) \\left(\\int_{0}^{1} v^5 (1-v)^3 \\,dv\\right)\n$$\n\n(iii) 最小 Gauss–Legendre 阶数\n如果一维求积法则对于各自的多项式因子是精确的，那么张量积求积法则对于变换后的积分就是精确的。$m$ 点 Gauss-Legendre 法则对于次数最高为 $2m-1$ 的多项式是精确的。该法则的积分域是 $[-1,1]$，但其精确次数与区间的线性映射无关。\n$u$-积分中的多项式因子是 $P_u(u) = u^2(1-u)^9$。其次数为 $2+9=11$。\n为了使 $u$-积分能被一个 $m_u$ 点 Gauss-Legendre 法则精确计算，必须满足：\n$$\n2m_u - 1 \\ge 11 \\implies 2m_u \\ge 12 \\implies m_u \\ge 6\n$$\n$u$ 方向的最小阶数是 $m_u = 6$。\n\n$v$-积分中的多项式因子是 $P_v(v) = v^5(1-v)^3$。其次数为 $5+3=8$。\n为了使 $v$-积分能被一个 $m_v$ 点 Gauss-Legendre 法则精确计算，必须满足：\n$$\n2m_v - 1 \\ge 8 \\implies 2m_v \\ge 9 \\implies m_v \\ge 4.5\n$$\n由于点数 $m_v$ 必须是整数，$v$ 方向的最小阶数是 $m_v = 5$。\n\n(iv) 积分的精确计算\n这两个一维积分是欧拉 Beta 函数的实例，其定义为：\n$$\nB(z_1, z_2) = \\int_{0}^{1} t^{z_1-1} (1-t)^{z_2-1} \\,dt = \\frac{\\Gamma(z_1)\\Gamma(z_2)}{\\Gamma(z_1+z_2)}\n$$\n其中 $\\Gamma(z)$ 是伽马函数。对于正整数 $n$，$\\Gamma(n)=(n-1)!$。\n\n关于 $u$ 的积分是：\n$$\n\\int_{0}^{1} u^2 (1-u)^9 \\,du = B(3, 10) = \\frac{\\Gamma(3)\\Gamma(10)}{\\Gamma(13)} = \\frac{2!\\,9!}{12!} = \\frac{2 \\cdot 1}{12 \\cdot 11 \\cdot 10} = \\frac{2}{1320} = \\frac{1}{660}\n$$\n关于 $v$ 的积分是：\n$$\n\\int_{0}^{1} v^5 (1-v)^3 \\,dv = B(6, 4) = \\frac{\\Gamma(6)\\Gamma(4)}{\\Gamma(10)} = \\frac{5!\\,3!}{9!} = \\frac{120 \\cdot 6}{9 \\cdot 8 \\cdot 7 \\cdot 6 \\cdot 5!} = \\frac{720}{362880} = \\frac{1}{504}\n$$\n最后，$I$ 的值是这两个结果的乘积：\n$$\nI = \\left(\\frac{1}{660}\\right) \\left(\\frac{1}{504}\\right) = \\frac{1}{660 \\times 504}\n$$\n乘积为 $660 \\times 504 = 660 \\times (500 + 4) = 330000 + 2640 = 332640$。\n因此，积分的精确值为：\n$$\nI = \\frac{1}{332640}\n$$\n或者，不提早约去公因子：\n$$\nI = B(3,10) \\cdot B(6,4) = \\frac{\\Gamma(3)\\Gamma(10)}{\\Gamma(13)} \\cdot \\frac{\\Gamma(6)\\Gamma(4)}{\\Gamma(10)} = \\frac{\\Gamma(3)\\Gamma(6)\\Gamma(4)}{\\Gamma(13)} = \\frac{2!\\,5!\\,3!}{12!}\n$$\n$$\nI = \\frac{(2)(120)(6)}{479001600} = \\frac{1440}{479001600} = \\frac{144}{47900160} = \\frac{1}{332640}\n$$",
            "answer": "$$\\boxed{\\frac{1}{332640}}$$"
        },
        {
            "introduction": "在掌握了理论变换之后，我们转向一个在有限元方法（FEM）中的核心应用。有限元解的精度在很大程度上取决于单元刚度矩阵的数值积分精度。这项动手编程练习旨在研究求积规则的选择和单元几何扭曲如何影响计算能量（即$H^1$-半范数）的准确性，这是衡量解质量的关键指标。通过该练习，你将对为何低阶求积规则在处理扭曲单元时可能失效获得一个定量的认识。",
            "id": "3398694",
            "problem": "考虑在单个二维四边形有限元上的标量泊松方程，其中局部刚度矩阵源自弱形式，节点函数的离散 $H^1$半范数由该刚度矩阵诱导的双线性形式表示。该问题的基础理论包括泊松方程的弱形式、四边形单元的等参映射以及张量积域上的高斯求积。具体而言，从弱形式出发，单元级刚度矩阵的各项定义为\n$$K_{ij} = \\int_{\\hat{\\Omega}} \\left(\\nabla N_i(\\boldsymbol{x}(\\boldsymbol{\\xi}))\\right) \\cdot \\left(\\nabla N_j(\\boldsymbol{x}(\\boldsymbol{\\xi}))\\right) \\,\\det\\left(J(\\boldsymbol{\\xi})\\right)\\, \\mathrm{d}\\boldsymbol{\\xi},$$\n其中 $\\hat{\\Omega} = [-1,1]\\times[-1,1]$ 是参考正方形，$\\boldsymbol{\\xi} = (\\xi,\\eta)$ 是参考坐标，$\\boldsymbol{x}(\\boldsymbol{\\xi})$ 是到物理坐标的等参映射，$N_i$ 是参考正方形上的双线性 ($Q_1$) 形函数，$J(\\boldsymbol{\\xi})$ 是该映射的雅可比矩阵。物理梯度满足\n$$\\nabla N_i(\\boldsymbol{x}(\\boldsymbol{\\xi})) = J(\\boldsymbol{\\xi})^{-\\top} \\, \\nabla_{\\boldsymbol{\\xi}} N_i(\\boldsymbol{\\xi}),$$\n其中 $J(\\boldsymbol{\\xi})$ 通常随 $\\boldsymbol{\\xi}$ 变化。单元上节点向量 $\\boldsymbol{u}$ 的离散 $H^1$半范数由下式给出\n$$|\\!|\\!|u_h|\\!|\\!|_{H^1(\\Omega_e)}^2 = \\boldsymbol{u}^\\top K \\boldsymbol{u}.$$\n在 $\\hat{\\Omega}$ 上使用每个坐标方向 $n$ 个点的张量积高斯求积法则，可得到近似值\n$$K_{ij}^{(n)} = \\sum_{a=1}^{n}\\sum_{b=1}^{n} w_a w_b \\left(\\nabla N_i(\\boldsymbol{x}(\\xi_a,\\eta_b))\\right) \\cdot \\left(\\nabla N_j(\\boldsymbol{x}(\\xi_a,\\eta_b))\\right) \\,\\det\\left(J(\\xi_a,\\eta_b)\\right),$$\n其中 $\\{(\\xi_a,w_a)\\}_{a=1}^n$ 和 $\\{(\\eta_b,w_b)\\}_{b=1}^n$ 分别是 $[-1,1]$上的一维高斯求积节点和权重。求积误差以标量差的形式传播到离散 $H^1$半范数中\n$$\\Delta_n(\\boldsymbol{u}) = \\left|\\boldsymbol{u}^\\top K \\boldsymbol{u} - \\boldsymbol{u}^\\top K^{(n)} \\boldsymbol{u}\\right|.$$\n您的任务是为一组具有不同扭曲程度的四边形单元定量评估 $\\Delta_n(\\boldsymbol{u})$，包括雅可比行列式 $\\det(J(\\boldsymbol{\\xi}))$ 在 $\\hat{\\Omega}$ 上快速变化的情况。使用每个坐标方向 $n_{\\text{exact}}$ 个点的高阶张量积高斯求积作为精确积分的替代。对于 $Q_1$ 单元，定义参考双线性基函数 $N_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$, $N_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$, $N_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$, $N_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$，并解析地计算它们的参考梯度 $\\nabla_{\\boldsymbol{\\xi}} N_i(\\xi,\\eta)$。通过标准插值 $\\boldsymbol{x}(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\boldsymbol{x}_i$ 构建等参映射，其中 $\\{\\boldsymbol{x}_i\\}_{i=1}^4$ 是下面按逆时针顺序列出的物理顶点坐标。\n\n实现一个程序，该程序：\n- 使用每个坐标方向 $n$ 个点的张量积高斯求积来组装局部刚度矩阵 $K^{(n)}$。\n- 使用每个坐标方向 $n_{\\text{exact}} = 20$ 个点来组装一个高精度的参考矩阵 $K^{(n_{\\text{exact}})}$。\n- 计算离散 $H^1$半范数之差 $\\Delta_n(\\boldsymbol{u}) = \\left|\\boldsymbol{u}^\\top K^{(n_{\\text{exact}})} \\boldsymbol{u} - \\boldsymbol{u}^\\top K^{(n)} \\boldsymbol{u}\\right|$。\n\n使用以下参数值测试套件，这些参数值旨在测试不同的行为：\n- 测试用例 1 (仿射，常数函数；边界行为): 单元顶点 $\\left((0.0,0.0),(1.0,0.0),(1.0,1.0),(0.0,1.0)\\right)$，节点向量 $\\boldsymbol{u} = (1.0,1.0,1.0,1.0)$，求积阶数 $n=1$。\n- 测试用例 2 (仿射，平行四边形；理想情况): 单元顶点 $\\left((0.0,0.0),(2.0,0.1),(2.2,1.1),(0.2,1.0)\\right)$，节点向量 $\\boldsymbol{u} = (0.3,0.7,1.1,-0.2)$，求积阶数 $n=1$。\n- 测试用例 3 (轻度扭曲；非仿射，不存在快速变化的雅可比行列式): 单元顶点 $\\left((0.0,0.0),(2.0,0.0),(1.9,1.0),(0.0,1.0)\\right)$，节点向量 $\\boldsymbol{u} = (0.3,0.7,1.1,-0.2)$，求积阶数 $n=1$。\n- 测试用例 4 (轻度扭曲；改进的求积): 与测试用例3顶点相同，$\\boldsymbol{u}$ 相同，求积阶数 $n=2$。\n- 测试用例 5 (严重扭曲；具有快速变化的雅可比行列式的非仿射情况): 单元顶点 $\\left((0.0,0.0),(2.0,-0.3),(2.3,1.1),(0.0,1.0)\\right)$，节点向量 $\\boldsymbol{u} = (0.3,0.7,1.1,-0.2)$，求积阶数 $n=2$。\n- 测试用例 6 (严重扭曲；更高阶的求积): 与测试用例5顶点相同，$\\boldsymbol{u}$ 相同，求积阶数 $n=3$。\n\n对于所有测试用例，设置 $n_{\\text{exact}} = 20$ 以获得参考刚度矩阵。要求的最终输出是一行内容，包含一个逗号分隔的列表，其中包含与给定顺序的测试用例相对应的六个标量误差 $\\left[\\Delta_{n}(\\boldsymbol{u})\\right]$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表 (例如 $\\left[ r_1, r_2, r_3, r_4, r_5, r_6 \\right]$)。此处不涉及物理单位；返回纯实数。不出现角度。将每个结果表示为浮点数。",
            "solution": "用户提供的问题经验证具有科学依据、是适定的、完整的和客观的。它代表了有限元法 (FEM) 分析领域内一项标准的数值验证任务。所有必要的数据、方程和定义均已提供。问题没有矛盾、歧义或伪科学论断。因此，我们可以着手求解。\n\n### 步骤 1：理论阐述\n\n问题要求计算四边形有限元上离散 $H^1$半范数的误差，该误差源于使用n阶数值求积来近似单元刚度矩阵。\n\n对于双线性四边形 ($Q_1$) 单元，单元刚度矩阵 $K$ 是一个 $4 \\times 4$ 矩阵，其各项由在参考正方形 $\\hat{\\Omega} = [-1,1] \\times [-1,1]$ 上的积分给出：\n$$\nK_{ij} = \\int_{\\hat{\\Omega}} \\left(\\nabla_{\\boldsymbol{x}} N_i\\right) \\cdot \\left(\\nabla_{\\boldsymbol{x}} N_j\\right) \\det(J(\\boldsymbol{\\xi})) \\, \\mathrm{d}\\boldsymbol{\\xi}\n$$\n此处，$N_i(\\boldsymbol{\\xi})$ 是参考单元上的双线性形函数，$\\boldsymbol{\\xi} = (\\xi, \\eta)$ 是 $\\hat{\\Omega}$ 上的坐标，$J(\\boldsymbol{\\xi})$ 是等参映射 $\\boldsymbol{x}(\\boldsymbol{\\xi})$ 的雅可比矩阵，$\\nabla_{\\boldsymbol{x}}$ 表示关于物理坐标 $\\boldsymbol{x}$ 的梯度。\n\n等参映射利用形函数自身将参考坐标 $\\boldsymbol{\\xi}$ 与物理坐标 $\\boldsymbol{x}$ 联系起来：\n$$\n\\boldsymbol{x}(\\boldsymbol{\\xi}) = \\sum_{k=1}^{4} N_k(\\boldsymbol{\\xi}) \\boldsymbol{x}_k\n$$\n其中 $\\boldsymbol{x}_k$ 是单元四个顶点的物理坐标。该映射的雅可比矩阵为：\n$$\nJ(\\boldsymbol{\\xi}) = \\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{\\xi}} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} \\sum_k \\frac{\\partial N_k}{\\partial \\xi} x_k  \\sum_k \\frac{\\partial N_k}{\\partial \\eta} x_k \\\\ \\sum_k \\frac{\\partial N_k}{\\partial \\xi} y_k  \\sum_k \\frac{\\partial N_k}{\\partial \\eta} y_k \\end{pmatrix}\n$$\n链式法则将物理梯度 $\\nabla_{\\boldsymbol{x}} N_i$ 与参考梯度 $\\nabla_{\\boldsymbol{\\xi}} N_i$ 联系起来：\n$$\n\\nabla_{\\boldsymbol{\\xi}} N_i = J(\\boldsymbol{\\xi})^\\top \\nabla_{\\boldsymbol{x}} N_i \\quad \\implies \\quad \\nabla_{\\boldsymbol{x}} N_i = J(\\boldsymbol{\\xi})^{-\\top} \\nabla_{\\boldsymbol{\\xi}} N_i\n$$\n$Q_1$ 基函数 $N_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$, $N_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$, $N_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$ 和 $N_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$ 的参考梯度可解析计算如下：\n\\begin{align*}\n\\nabla_{\\boldsymbol{\\xi}} N_1 = \\frac{1}{4} \\begin{pmatrix} -(1-\\eta) \\\\ -(1-\\xi) \\end{pmatrix},  \\nabla_{\\boldsymbol{\\xi}} N_2 = \\frac{1}{4} \\begin{pmatrix} 1-\\eta \\\\ -(1+\\xi) \\end{pmatrix} \\\\\n\\nabla_{\\boldsymbol{\\xi}} N_3 = \\frac{1}{4} \\begin{pmatrix} 1+\\eta \\\\ 1+\\xi \\end{pmatrix},  \\nabla_{\\boldsymbol{\\xi}} N_4 = \\frac{1}{4} \\begin{pmatrix} -(1+\\eta) \\\\ 1-\\xi \\end{pmatrix}\n\\end{align*}\n\n$K_{ij}$ 的积分使用 $n \\times n$ 张量积高斯求积法则来近似：\n$$\nK_{ij}^{(n)} \\approx \\sum_{a=1}^{n}\\sum_{b=1}^{n} w_a w_b \\left[ \\left( J^{-\\top} \\nabla_{\\boldsymbol{\\xi}} N_i \\right) \\cdot \\left( J^{-\\top} \\nabla_{\\boldsymbol{\\xi}} N_j \\right) \\det(J) \\right]_{\\boldsymbol{\\xi}=(\\xi_a,\\eta_b)}\n$$\n其中 $(\\xi_a, w_a)$ 和 $(\\eta_b, w_b)$ 是 $[-1,1]$ 上的一维高斯-勒让德求积节点和权重。\n\n最后，由节点向量 $\\boldsymbol{u}$ 表示的函数 $u_h = \\sum_i u_i N_i$ 的离散 $H^1$半范数是 $|\\!|\\!|u_h|\\!|\\!|_{H^1(\\Omega_e)}^2 = \\boldsymbol{u}^\\top K \\boldsymbol{u}$。由求积引起的误差是主要关注的量：\n$$\n\\Delta_n(\\boldsymbol{u}) = \\left| \\boldsymbol{u}^\\top K^{(n_{\\text{exact}})} \\boldsymbol{u} - \\boldsymbol{u}^\\top K^{(n)} \\boldsymbol{u} \\right|\n$$\n其中 $K^{(n_{\\text{exact}})}$ 是用 $n_{\\text{exact}} = 20$ 计算得到的高精度参考矩阵。\n\n### 步骤 2：算法实现\n\n我们开发一个函数 `assemble_stiffness_matrix(vertices, n)`，该函数实现基于求积的 $K^{(n)}$ 组装。\n\n1.  **获取求积法则**：对于给定的阶数 $n$，检索 $[-1,1]$ 上的一维高斯-勒让德节点 $\\{\\xi_a\\}_{a=1}^n$ 和权重 $\\{w_a\\}_{a=1}^n$。`numpy.polynomial.legendre.leggauss` 函数适用于此任务。\n\n2.  **初始化矩阵**：创建一个初始化为零的 $4 \\times 4$ 矩阵 $K^{(n)}$。\n\n3.  **遍历求积点**：对所有 $n \\times n$ 对求积点 $(\\xi_a, \\eta_b)$ 进行循环。对于每个点：\n    a.  **计算参考梯度**：在点 $(\\xi_a, \\eta_b)$ 处计算 $i=1..4$ 的 $\\nabla_{\\boldsymbol{\\xi}} N_i$ 的解析表达式。将这些结果存储在一个 $4 \\times 2$ 矩阵 `ref_grads` 中，其中 `ref_grads[i,:]` 是 $N_{i+1}$ 的梯度向量。\n    b.  **计算雅可比矩阵**：计算 $2 \\times 2$ 的雅可比矩阵 $J$。这可以通过矩阵乘法高效计算：$J = \\boldsymbol{V}^\\top \\cdot \\boldsymbol{G}_{\\boldsymbol{\\xi}}$，其中 $\\boldsymbol{V}$ 是顶点坐标的 $4 \\times 2$ 矩阵，$\\boldsymbol{G}_{\\boldsymbol{\\xi}}$ 是 $4 \\times 2$ 的 `ref_grads` 矩阵。\n    c.  **变换梯度**：计算雅可比矩阵的逆矩阵 $J^{-1}$。使用关系式 $(\\nabla_{\\boldsymbol{x}} N_i)^\\top = (\\nabla_{\\boldsymbol{\\xi}} N_i)^\\top J^{-1}$ 将所有四个基函数的参考梯度转换为物理梯度。这可以通过单个矩阵运算完成：`phys_grads = ref_grads @ inv_J`。\n    d.  **构建被积函数**：计算物理梯度的点积矩阵，$D_{ij} = (\\nabla_{\\boldsymbol{x}} N_i) \\cdot (\\nabla_{\\boldsymbol{x}} N_j)$。这可计算为 `phys_grads @ phys_grads.T`。\n    e.  **累加**：获取雅可比行列式 $\\det(J)$ 并更新刚度矩阵：$K^{(n)} += D \\times \\det(J) \\times w_a \\times w_b$。\n\n4.  **主循环**：对于提供的每个测试用例：\n    a.  使用给定的求积阶数 $n$ 调用 `assemble_stiffness_matrix` 以获得 $K^{(n)}$。\n    b.  使用 $n_{\\text{exact}}=20$ 调用 `assemble_stiffness_matrix` 以获得参考矩阵 $K^{(n_{\\text{exact}})}$。\n    c.  计算两个二次型 $S_n = \\boldsymbol{u}^\\top K^{(n)} \\boldsymbol{u}$ 和 $S_{\\text{exact}} = \\boldsymbol{u}^\\top K^{(n_{\\text{exact}})} \\boldsymbol{u}$。\n    d.  计算绝对差 $\\Delta_n(\\boldsymbol{u}) = |S_{\\text{exact}} - S_n|$ 并存储结果。\n\n5.  **输出**：将结果列表格式化为所需的逗号分隔字符串。\n\n该过程在提供的 Python 代码中实现，该代码为指定的测试用例正确计算了半范数差异，反映了单元扭曲和求积阶数对刚度矩阵积分准确性的影响。",
            "answer": "```python\nimport numpy as np\n# The problem can be solved using only numpy. Scipy is not required.\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating quadrature error in the H1-seminorm \n    for 2D quadrilateral finite elements.\n    \"\"\"\n\n    def get_ref_grads(xi, eta):\n        \"\"\"\n        Computes the gradients of the 4 bilinear shape functions on the\n        reference element [-1,1]x[-1,1] at point (xi, eta).\n        Ordering is CCW from (-1,-1).\n        \n        Args:\n            xi (float): First coordinate in the reference domain.\n            eta (float): Second coordinate in the reference domain.\n        \n        Returns:\n            numpy.ndarray: A 4x2 array where row i is [dN_i/dxi, dN_i/deta].\n        \"\"\"\n        dN_dxi = 0.25 * np.array([\n            -(1.0 - eta),\n             (1.0 - eta),\n             (1.0 + eta),\n            -(1.0 + eta)\n        ])\n        dN_deta = 0.25 * np.array([\n            -(1.0 - xi),\n            -(1.0 + xi),\n             (1.0 + xi),\n             (1.0 - xi)\n        ])\n        return np.vstack((dN_dxi, dN_deta)).T\n\n    def assemble_stiffness_matrix(vertices, n):\n        \"\"\"\n        Assembles the 4x4 local stiffness matrix for a Q1 quadrilateral element\n        using n-point tensor-product Gaussian quadrature.\n        \n        Args:\n            vertices (numpy.ndarray): 4x2 array of vertex coordinates in CCW order.\n            n (int): Number of Gaussian quadrature points in each direction.\n        \n        Returns:\n            numpy.ndarray: The 4x4 element stiffness matrix.\n        \"\"\"\n        K = np.zeros((4, 4))\n        \n        if n == 0:\n            return K\n\n        # Get 1D Gauss-Legendre quadrature nodes and weights\n        nodes, weights = np.polynomial.legendre.leggauss(n)\n        \n        # Tensor-product quadrature loops\n        for i in range(n):\n            xi = nodes[i]\n            w_xi = weights[i]\n            for j in range(n):\n                eta = nodes[j]\n                w_eta = weights[j]\n                \n                # Gradients of shape functions in reference coordinates (4x2 matrix)\n                ref_grads = get_ref_grads(xi, eta)\n                \n                # Jacobian matrix of the isoparametric mapping (2x2 matrix)\n                # J = V.T @ G_ref, where V are vertices and G_ref are ref_grads\n                J = np.dot(vertices.T, ref_grads)\n                \n                det_J = np.linalg.det(J)\n                \n                # A negative or zero determinant indicates an invalid mapping\n                # at the quadrature point. We assume this doesn't occur for the\n                # given test cases.\n                if det_J = 0:\n                   # A robust implementation might raise an error or handle this.\n                   # For this problem, we continue, which may lead to nan/inf results\n                   # if the matrix becomes singular, but it doesn't for these cases.\n                   pass\n                \n                inv_J = np.linalg.inv(J)\n                \n                # Gradients in physical coordinates\n                # (grad_phys_i)^T = (grad_ref_i)^T @ J^{-1}\n                # This applies to all shape functions simultaneously.\n                phys_grads = np.dot(ref_grads, inv_J)\n                \n                # Integrand for the stiffness matrix at the current quad point.\n                # The (i,j) element is (grad_phys_i) . (grad_phys_j)\n                integrand_matrix = np.dot(phys_grads, phys_grads.T)\n                \n                # Add weighted contribution to the stiffness matrix\n                K += integrand_matrix * det_J * w_xi * w_eta\n                \n        return K\n\n    # Test cases as defined in the problem statement\n    test_cases = [\n        {'vertices': np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n         'u': np.array([1.0, 1.0, 1.0, 1.0]), 'n': 1},\n        {'vertices': np.array([[0.0, 0.0], [2.0, 0.1], [2.2, 1.1], [0.2, 1.0]]),\n         'u': np.array([0.3, 0.7, 1.1, -0.2]), 'n': 1},\n        {'vertices': np.array([[0.0, 0.0], [2.0, 0.0], [1.9, 1.0], [0.0, 1.0]]),\n         'u': np.array([0.3, 0.7, 1.1, -0.2]), 'n': 1},\n        {'vertices': np.array([[0.0, 0.0], [2.0, 0.0], [1.9, 1.0], [0.0, 1.0]]),\n         'u': np.array([0.3, 0.7, 1.1, -0.2]), 'n': 2},\n        {'vertices': np.array([[0.0, 0.0], [2.0, -0.3], [2.3, 1.1], [0.0, 1.0]]),\n         'u': np.array([0.3, 0.7, 1.1, -0.2]), 'n': 2},\n        {'vertices': np.array([[0.0, 0.0], [2.0, -0.3], [2.3, 1.1], [0.0, 1.0]]),\n         'u': np.array([0.3, 0.7, 1.1, -0.2]), 'n': 3},\n    ]\n\n    n_exact = 20\n    results = []\n\n    for case in test_cases:\n        vertices = case['vertices']\n        u_vec = case['u']\n        n = case['n']\n\n        # Assemble stiffness matrices: one with order n, one with high order\n        K_n = assemble_stiffness_matrix(vertices, n)\n        K_exact = assemble_stiffness_matrix(vertices, n_exact)\n        \n        # Compute the quadratic forms, u^T * K * u\n        seminorm_sq_n = np.dot(u_vec.T, np.dot(K_n, u_vec))\n        seminorm_sq_exact = np.dot(u_vec.T, np.dot(K_exact, u_vec))\n        \n        # Calculate the absolute difference (error)\n        delta_n = abs(seminorm_sq_exact - seminorm_sq_n)\n        results.append(delta_n)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "前一个练习表明，对于几何扭曲的单元或复杂的被积函数，固定阶数的求积可能不够准确。因此，我们需要一种更稳健的策略。本练习将指导你实现一个自适应求积算法。通过使用嵌入式求积对来估计局部误差，并递归地细分单元，该算法能够自动将计算资源集中在最需要的地方，以达到预设的精度要求，这是专业有限元软件中广泛采用的一项强大技术。",
            "id": "3398658",
            "problem": "您的任务是实现一种用于二维有限元上的自适应嵌入式数值求积方法，以用于偏微分方程的数值求解。两种单元类型是三角形和四边形。目标是设计一种算法，该算法在给定单元几何形状和标量被积函数的情况下，通过组合一对用于误差估计的嵌入式求积规则和递归自适应细分来计算单元上的积分，以满足指定的容差。\n\n其根本基础必须始于从参考单元到物理单元映射下的积分变量替换公式。对于一个具有物理顶点 $(\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3)$ 的三角形和一个仿射映射 $\\Phi_{\\triangle}: (\\xi,\\eta) \\mapsto \\mathbf{x} = \\mathbf{v}_1 + \\xi(\\mathbf{v}_2-\\mathbf{v}_1) + \\eta(\\mathbf{v}_3-\\mathbf{v}_1)$，其中 $(\\xi,\\eta)$ 在参考三角形 $\\{(\\xi,\\eta)\\in\\mathbb{R}^2: \\xi\\ge 0, \\eta\\ge 0, \\xi+\\eta\\le 1\\}$ 内，标量函数 $f$ 的积分满足\n$$\n\\int_{K_{\\triangle}} f(\\mathbf{x})\\,dA = \\int_{T_{\\mathrm{ref}}} f\\!\\left(\\Phi_{\\triangle}(\\xi,\\eta)\\right)\\, \\left|\\det J_{\\triangle}\\right|\\, d\\xi\\, d\\eta,\n$$\n其中 $J_{\\triangle} = [\\mathbf{v}_2-\\mathbf{v}_1 \\;\\; \\mathbf{v}_3-\\mathbf{v}_1]$ 在该单元上为常数。对于一个具有有序顶点 $(\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3,\\mathbf{v}_4)$ 的凸四边形和双线性映射 $\\Phi_{\\square}: (\\xi,\\eta)\\in[-1,1]^2 \\mapsto \\mathbf{x} = \\sum_{i=1}^4 N_i(\\xi,\\eta)\\,\\mathbf{v}_i$，其中形函数为\n$$\nN_1(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_3(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta),\n$$\n其积分为\n$$\n\\int_{K_{\\square}} f(\\mathbf{x})\\,dA = \\int_{-1}^{1}\\int_{-1}^{1} f\\!\\left(\\Phi_{\\square}(\\xi,\\eta)\\right)\\, \\left|\\det J_{\\square}(\\xi,\\eta)\\right|\\, d\\xi\\, d\\eta,\n$$\n其中 $J_{\\square}(\\xi,\\eta)$ 是该映射的雅可比矩阵，而 $\\left|\\det J_{\\square}(\\xi,\\eta)\\right|$ 是局部面积缩放因子。\n\n您的程序必须实现：\n- 在三角形上的一对嵌入式求积规则，由参考三角形上的一个低阶规则和一个高阶规则组成，用于估计局部求积误差；以及一个自适应加密策略，当误差超过容差时，通过连接边的中点将三角形细分为四个子三角形。\n- 在四边形上的一对嵌入式求积规则，由参考正方形 $[-1,1]\\times[-1,1]$ 上两个不同阶的张量积高斯-勒让德规则组成，用于估计局部求积误差；以及一个自适应加密策略，当误差超过容差时，将参数域细分为四个子矩形。\n\n该算法必须：\n1. 对两种单元类型都使用变量替换公式作为基础。\n2. 对于三角形，在参考三角形上采用单点形心规则作为粗略规则，采用对称三点规则作为精细规则进行误差估计。如果精细估计和粗略估计之间的绝对差超过预设容差，则触发细分为四个子三角形，并对子三角形递归应用相同的策略，直到满足容差或达到最大递归深度。参考三角形为 $\\{(\\xi,\\eta): \\xi\\ge 0, \\eta\\ge 0, \\xi+\\eta\\le 1\\}$，其形心位于 $(\\xi,\\eta)=(\\tfrac{1}{3},\\tfrac{1}{3})$。\n3. 对于四边形，采用 $2\\times 2$ 阶的张量积高斯-勒让德规则作为粗略规则，采用 $3\\times 3$ 阶作为精细规则进行误差估计。如果在 $(\\xi,\\eta)$ 域中，精细估计和粗略估计之间的绝对差超过预设容差，则触发将参考正方形细分为四个相等的子矩形，并递归应用相同的策略，直到满足容差或达到最大递归深度。高斯-勒让德规则必须在参数域中正确地缩放到子区间。\n4. 确保退化或细长单元的数值稳定性。容差必须被视为单元积分的绝对误差容差。\n\n您的程序必须计算以下测试套件的单元积分。在每种情况下，顶点都按逆时针顺序排列，并且四边形顶点在双线性映射下对应于 $(\\xi,\\eta)=(-1,-1),(+1,-1),(+1,+1),(-1,+1)$：\n- 测试用例 $1$ (三角形，正常情况)：单元顶点 $(0,0)$、$(1,0)$、$(0,1)$；被积函数 $f(x,y)=x^2+y^2$；容差 $10^{-12}$；最大递归深度 $5$。\n- 测试用例 $2$ (三角形，细长边界条件)：单元顶点 $(0,0)$、$(10^{-6},0)$、$(0,1)$；被积函数 $f(x,y)=\\exp(x+y)$；容差 $10^{-10}$；最大递归深度 $10$。\n- 测试用例 $3$ (三角形，被积函数为零的边界情况)：单元顶点 $(-1,-1)$、$(2,-1)$、$(0,2)$；被积函数 $f(x,y)=0$；容差 $10^{-12}$；最大递归深度 $2$。\n- 测试用例 $4$ (四边形，可变雅可比)：单元顶点 $(0,0)$、$(2,0)$、$(2,1)$、$(0,2)$；被积函数 $f(x,y)=\\exp(x+y)$；容差 $10^{-8}$；最大递归深度 $7$。\n- 测试用例 $5$ (四边形，振荡函数)：单元顶点 $(0,0)$、$(1,0)$、$(1,1)$、$(0,1)$；被积函数 $f(x,y)=\\sin(20x)\\sin(20y)$，角度以弧度为单位；容差 $10^{-6}$；最大递归深度 $9$。\n- 测试用例 $6$ (四边形，带有局部峰值的倾斜几何体)：单元顶点 $(0,0)$、$(1.5,0.1)$、$(1.4,1.2)$、$(0.1,1.1)$；被积函数 $f(x,y)=\\dfrac{1}{1+100\\left((x-0.1)^2+(y-0.1)^2\\right)}$；容差 $10^{-7}$；最大递归深度 $7$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。六个结果必须按测试用例1到6的顺序列出，每个结果都是一个浮点数（例如，$[r_1,r_2,r_3,r_4,r_5,r_6]$）。",
            "solution": "出发点是积分的变量替换定理，该定理允许将物理单元上的积分转换为参考单元上的积分，并带有雅可比行列式缩放。对于三角形，映射是仿射的，因此雅可比行列式 $\\left|\\det J_{\\triangle}\\right|$ 是常数，等于从参考三角形（其面积为 $\\tfrac{1}{2}$）到物理三角形的面积缩放因子。对于四边形，映射是双线性的，因此雅可比行列式 $\\left|\\det J_{\\square}(\\xi,\\eta)\\right|$ 在单元上是变化的，必须在每个求积点上进行计算。\n\n为了构建自适应嵌入式求积策略，我们使用以下原则：\n1. 嵌入式规则对：为了在子域上进行误差估计，采用两个具有不同精确度的求积规则。设粗略估计为 $I_{\\mathrm{coarse}}$，精细估计为 $I_{\\mathrm{fine}}$。差值 $\\Delta = \\left|I_{\\mathrm{fine}} - I_{\\mathrm{coarse}}\\right|$ 作为后验局部误差指示器。这是自适应积分程序中一种经过充分检验的方法，其中只要高阶规则更准确，嵌入式规则对的节点就不需要嵌套。\n2. 自适应细分：如果 $\\Delta$ 超过预设容差 $T$，则将域细分为四个子子域，在每个子域上递归应用相同的嵌入式规则对，并对子积分求和。为确保全局误差以 $T$ 为界，需将容差分配给各个子域；根据绝对误差的三角不等式，将 $T/4$ 分配给每个子域即可，尽管也可能存在更复杂的预算分配方法。\n3. 参考单元上的求积规则：对于三角形，使用形心规则（参考三角形上一点 $(\\tfrac{1}{3},\\tfrac{1}{3})$，权重为 $\\tfrac{1}{2}$）作为 $I_{\\mathrm{coarse}}$，使用对称三点规则（点位于 $(\\tfrac{1}{6},\\tfrac{1}{6})$、$(\\tfrac{2}{3},\\tfrac{1}{6})$、$(\\tfrac{1}{6},\\tfrac{2}{3})$；每个点的权重为 $\\tfrac{1}{6}$）作为 $I_{\\mathrm{fine}}$。这些规则由参考三角形上的矩拟合导出，并经过了充分测试；三点规则对总次数不高于二的多项式是精确的。\n对于四边形，在 $[-1,1]$ 上使用张量积高斯-勒让德规则：$2\\times 2$ 规则的一维节点为 $\\pm \\frac{1}{\\sqrt{3}}$，权重为 $1$；$3\\times 3$ 规则的一维节点为 $-\\sqrt{\\tfrac{3}{5}}, 0, \\sqrt{\\tfrac{3}{5}}$，权重为 $\\tfrac{5}{9}, \\tfrac{8}{9}, \\tfrac{5}{9}$。在子矩形 $[\\xi_a,\\xi_b]\\times[\\eta_c,\\eta_d]$ 上，一维规则通过每个方向上的仿射变量变换进行缩放，为二维权重贡献一个因子 $\\tfrac{\\xi_b-\\xi_a}{2}\\cdot \\tfrac{\\eta_d-\\eta_c}{2}$。\n\n算法设计：\n- 三角形：\n  a. 对于具有顶点 $(\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3)$ 的三角形，在参考三角形上定义映射 $\\Phi_{\\triangle}(\\xi,\\eta)=\\mathbf{v}_1 + \\xi(\\mathbf{v}_2-\\mathbf{v}_1) + \\eta(\\mathbf{v}_3-\\mathbf{v}_1)$。\n  b. 计算 $\\left|\\det J_{\\triangle}\\right| = \\left|\\det\\left([\\mathbf{v}_2-\\mathbf{v}_1 \\;\\; \\mathbf{v}_3-\\mathbf{v}_1]\\right)\\right|$，其为常数。\n  c. 质心规则求值为 $I_{\\mathrm{coarse}} = \\tfrac{1}{2}\\, f\\!\\left(\\Phi_{\\triangle}(\\tfrac{1}{3},\\tfrac{1}{3})\\right)\\, \\left|\\det J_{\\triangle}\\right|$，而对称三点规则求值为 $I_{\\mathrm{fine}} = \\sum_{i=1}^{3} \\tfrac{1}{6}\\, f\\!\\left(\\Phi_{\\triangle}(\\xi_i,\\eta_i)\\right)\\, \\left|\\det J_{\\triangle}\\right|$。使用 $\\Delta=\\left|I_{\\mathrm{fine}}-I_{\\mathrm{coarse}}\\right|$。\n  d. 如果 $\\Delta \\le T$ 或达到最大递归深度，则接受 $I_{\\mathrm{fine}}$。否则，通过取中点 $\\mathbf{m}_{12}=\\tfrac{\\mathbf{v}_1+\\mathbf{v}_2}{2}$、$\\mathbf{m}_{23}=\\tfrac{\\mathbf{v}_2+\\mathbf{v}_3}{2}$、$\\mathbf{m}_{13}=\\tfrac{\\mathbf{v}_1+\\mathbf{v}_3}{2}$ 将三角形细分为四个子三角形 $(\\mathbf{v}_1,\\mathbf{m}_{12},\\mathbf{m}_{13})$、$(\\mathbf{m}_{12},\\mathbf{v}_2,\\mathbf{m}_{23})$、$(\\mathbf{m}_{13},\\mathbf{m}_{23},\\mathbf{v}_3)$ 和 $(\\mathbf{m}_{12},\\mathbf{m}_{23},\\mathbf{m}_{13})$。对每个子三角形以容差 $T/4$ 进行递归并求和。\n- 四边形：\n  a. 对于有序顶点 $(\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3,\\mathbf{v}_4)$，在 $[-1,1]^2$ 上使用双线性映射 $\\Phi_{\\square}(\\xi,\\eta)=\\sum_{i=1}^4 N_i(\\xi,\\eta)\\,\\mathbf{v}_i$。\n  b. 通过对形函数求导来计算每个求积点的 $\\left|\\det J_{\\square}(\\xi,\\eta)\\right|$：\n     $\\tfrac{\\partial N_1}{\\partial \\xi} = -\\tfrac{1}{4}(1-\\eta)$, $\\tfrac{\\partial N_1}{\\partial \\eta} = -\\tfrac{1}{4}(1-\\xi)$;\n     $\\tfrac{\\partial N_2}{\\partial \\xi} = +\\tfrac{1}{4}(1-\\eta)$, $\\tfrac{\\partial N_2}{\\partial \\eta} = -\\tfrac{1}{4}(1+\\xi)$;\n     $\\tfrac{\\partial N_3}{\\partial \\xi} = +\\tfrac{1}{4}(1+\\eta)$, $\\tfrac{\\partial N_3}{\\partial \\eta} = +\\tfrac{1}{4}(1+\\xi)$;\n     $\\tfrac{\\partial N_4}{\\partial \\xi} = -\\tfrac{1}{4}(1+\\eta)$, $\\tfrac{\\partial N_4}{\\partial \\eta} = +\\tfrac{1}{4}(1-\\xi)$.\n     然后 $\\tfrac{\\partial \\mathbf{x}}{\\partial \\xi} = \\sum_i \\tfrac{\\partial N_i}{\\partial \\xi}\\,\\mathbf{v}_i$，$\\tfrac{\\partial \\mathbf{x}}{\\partial \\eta} = \\sum_i \\tfrac{\\partial N_i}{\\partial \\eta}\\,\\mathbf{v}_i$，以及 $\\left|\\det J_{\\square}(\\xi,\\eta)\\right| = \\left|\\tfrac{\\partial x}{\\partial \\xi}\\tfrac{\\partial y}{\\partial \\eta} - \\tfrac{\\partial x}{\\partial \\eta}\\tfrac{\\partial y}{\\partial \\xi}\\right|$。\n  c. 在子矩形 $[\\xi_a,\\xi_b]\\times[\\eta_c,\\eta_d]$ 上，通过 $\\xi_i = \\tfrac{\\xi_b-\\xi_a}{2}\\hat{\\xi}_i + \\tfrac{\\xi_a+\\xi_b}{2}$ 对一维高斯-勒让德节点 $\\{\\hat{\\xi}_i\\}$ 和权重 $\\{w_i\\}$ 进行缩放，对 $\\eta_j$ 也做类似处理。二维权重因子乘以 $\\tfrac{\\xi_b-\\xi_a}{2}\\cdot \\tfrac{\\eta_d-\\eta_c}{2}$。分别使用 $2\\times 2$ 和 $3\\times 3$ 规则计算 $I_{\\mathrm{coarse}}$ 和 $I_{\\mathrm{fine}}$，以及 $\\Delta=\\left|I_{\\mathrm{fine}}-I_{\\mathrm{coarse}}\\right|$。\n  d. 如果 $\\Delta \\le T$ 或达到最大递归深度，则接受 $I_{\\mathrm{fine}}$。否则通过将每个参数区间二等分，将域细分为四个子矩形，并对每个子矩形以容差 $T/4$ 进行递归并求和。\n\n该设计将基本的变量替换原理与嵌入式误差估计和自适应域细分相结合，确保了科学真实性：三角形映射是仿射的，具有恒定的雅可比行列式；四边形映射是双线性的，具有可变的雅可比行列式。它遵守了容差是绝对的以及三角函数的角度单位在适用时为弧度的要求。将该算法应用于六个指定的测试用例，会按给定顺序生成一个包含六个浮点数结果的列表。最终的程序实现了这些规则，精确计算雅可比矩阵，执行带容差预算的自适应细分，并以方括号括起来的单个逗号分隔列表形式打印结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# -------------------------------\n# Integrand functions\n# -------------------------------\ndef f_poly(x, y):\n    return x**2 + y**2\n\ndef f_exp(x, y):\n    return np.exp(x + y)\n\ndef f_zero(x, y):\n    return 0.0\n\ndef f_osc(x, y):\n    # Angles in radians\n    return np.sin(20.0 * x) * np.sin(20.0 * y)\n\ndef f_peak(x, y):\n    return 1.0 / (1.0 + 100.0 * ((x - 0.1)**2 + (y - 0.1)**2))\n\n# -------------------------------\n# Triangle mapping and quadrature\n# -------------------------------\ndef tri_map(v1, v2, v3, xi, eta):\n    # Affine mapping from reference triangle to physical triangle\n    return v1 + xi * (v2 - v1) + eta * (v3 - v1)\n\ndef tri_detJ(v1, v2, v3):\n    # Determinant of Jacobian for affine triangle mapping\n    a = v2 - v1\n    b = v3 - v1\n    return abs(np.linalg.det(np.column_stack((a, b))))\n\ndef tri_coarse_fine(f, v1, v2, v3):\n    # Coarse: centroid rule (one point), weight on reference triangle is 1/2\n    detJ = tri_detJ(v1, v2, v3)\n    xi_c, eta_c = 1.0 / 3.0, 1.0 / 3.0\n    x_c, y_c = tri_map(v1, v2, v3, xi_c, eta_c)\n    I_coarse = 0.5 * f(x_c, y_c) * detJ\n\n    # Fine: symmetric 3-point rule on reference triangle, each weight = 1/6\n    pts = [(1.0/6.0, 1.0/6.0), (2.0/3.0, 1.0/6.0), (1.0/6.0, 2.0/3.0)]\n    I_fine = 0.0\n    for xi, eta in pts:\n        x, y = tri_map(v1, v2, v3, xi, eta)\n        I_fine += (1.0/6.0) * f(x, y) * detJ\n\n    return I_coarse, I_fine\n\ndef tri_subdivide(v1, v2, v3):\n    m12 = 0.5 * (v1 + v2)\n    m23 = 0.5 * (v2 + v3)\n    m13 = 0.5 * (v1 + v3)\n    # Return four sub-triangles\n    return [\n        (v1, m12, m13),\n        (m12, v2, m23),\n        (m13, m23, v3),\n        (m12, m23, m13),\n    ]\n\ndef tri_integrate_adaptive(f, verts, tol, max_depth):\n    v1 = np.array(verts[0], dtype=float)\n    v2 = np.array(verts[1], dtype=float)\n    v3 = np.array(verts[2], dtype=float)\n\n    def recurse(v1, v2, v3, local_tol, depth):\n        I_coarse, I_fine = tri_coarse_fine(f, v1, v2, v3)\n        err = abs(I_fine - I_coarse)\n        if err = local_tol or depth == 0:\n            return I_fine\n        # Subdivide into four sub-triangles\n        children = tri_subdivide(v1, v2, v3)\n        child_tol = local_tol / 4.0\n        total = 0.0\n        for (a, b, c) in children:\n            total += recurse(a, b, c, child_tol, depth - 1)\n        return total\n\n    return recurse(v1, v2, v3, tol, max_depth)\n\n# -------------------------------\n# Quadrilateral mapping and quadrature\n# -------------------------------\ndef quad_map_and_detJ(verts, xi, eta):\n    # Bilinear shape functions\n    v1 = np.array(verts[0], dtype=float)\n    v2 = np.array(verts[1], dtype=float)\n    v3 = np.array(verts[2], dtype=float)\n    v4 = np.array(verts[3], dtype=float)\n\n    N1 = 0.25 * (1.0 - xi) * (1.0 - eta)\n    N2 = 0.25 * (1.0 + xi) * (1.0 - eta)\n    N3 = 0.25 * (1.0 + xi) * (1.0 + eta)\n    N4 = 0.25 * (1.0 - xi) * (1.0 + eta)\n\n    x = N1 * v1[0] + N2 * v2[0] + N3 * v3[0] + N4 * v4[0]\n    y = N1 * v1[1] + N2 * v2[1] + N3 * v3[1] + N4 * v4[1]\n\n    # Derivatives of shape functions\n    dN1_dxi = -0.25 * (1.0 - eta)\n    dN2_dxi = +0.25 * (1.0 - eta)\n    dN3_dxi = +0.25 * (1.0 + eta)\n    dN4_dxi = -0.25 * (1.0 + eta)\n\n    dN1_deta = -0.25 * (1.0 - xi)\n    dN2_deta = -0.25 * (1.0 + xi)\n    dN3_deta = +0.25 * (1.0 + xi)\n    dN4_deta = +0.25 * (1.0 - xi)\n\n    dx_dxi = dN1_dxi * v1[0] + dN2_dxi * v2[0] + dN3_dxi * v3[0] + dN4_dxi * v4[0]\n    dx_deta = dN1_deta * v1[0] + dN2_deta * v2[0] + dN3_deta * v3[0] + dN4_deta * v4[0]\n    dy_dxi = dN1_dxi * v1[1] + dN2_dxi * v2[1] + dN3_dxi * v3[1] + dN4_dxi * v4[1]\n    dy_deta = dN1_deta * v1[1] + dN2_deta * v2[1] + dN3_deta * v3[1] + dN4_deta * v4[1]\n\n    detJ = abs(dx_dxi * dy_deta - dx_deta * dy_dxi)\n    return x, y, detJ\n\ndef quad_coarse_fine(f, verts, a, b, c, d):\n    # 2x2 Gauss-Legendre rule on [-1,1]: nodes ±1/sqrt(3), weights 1\n    xi2_1d = np.array([-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)])\n    wi2_1d = np.array([1.0, 1.0])\n\n    # 3x3 Gauss-Legendre rule on [-1,1]: nodes -sqrt(3/5), 0, +sqrt(3/5), weights 5/9, 8/9, 5/9\n    xi3_1d = np.array([-np.sqrt(3.0 / 5.0), 0.0, np.sqrt(3.0 / 5.0)])\n    wi3_1d = np.array([5.0 / 9.0, 8.0 / 9.0, 5.0 / 9.0])\n\n    # Scale factor for subrectangle\n    scale = ((b - a) / 2.0) * ((d - c) / 2.0)\n\n    # Coarse integral\n    I_coarse = 0.0\n    for i in range(len(xi2_1d)):\n        for j in range(len(xi2_1d)):\n            xi_hat = xi2_1d[i]\n            eta_hat = xi2_1d[j]\n            xi = (b - a) * 0.5 * xi_hat + (a + b) * 0.5\n            eta = (d - c) * 0.5 * eta_hat + (c + d) * 0.5\n            x, y, detJ = quad_map_and_detJ(verts, xi, eta)\n            I_coarse += wi2_1d[i] * wi2_1d[j] * f(x, y) * detJ\n    I_coarse *= scale\n\n    # Fine integral\n    I_fine = 0.0\n    for i in range(len(xi3_1d)):\n        for j in range(len(xi3_1d)):\n            xi_hat = xi3_1d[i]\n            eta_hat = xi3_1d[j]\n            xi = (b - a) * 0.5 * xi_hat + (a + b) * 0.5\n            eta = (d - c) * 0.5 * eta_hat + (c + d) * 0.5\n            x, y, detJ = quad_map_and_detJ(verts, xi, eta)\n            I_fine += wi3_1d[i] * wi3_1d[j] * f(x, y) * detJ\n    I_fine *= scale\n\n    return I_coarse, I_fine\n\ndef quad_integrate_adaptive(f, verts, tol, max_depth):\n    def recurse(a, b, c, d, local_tol, depth):\n        I_coarse, I_fine = quad_coarse_fine(f, verts, a, b, c, d)\n        err = abs(I_fine - I_coarse)\n        if err = local_tol or depth == 0:\n            return I_fine\n        # Subdivide into four subrectangles\n        mid_x = 0.5 * (a + b)\n        mid_y = 0.5 * (c + d)\n        child_tol = local_tol / 4.0\n        total = 0.0\n        total += recurse(a,    mid_x, c,    mid_y, child_tol, depth - 1)\n        total += recurse(mid_x, b,    c,    mid_y, child_tol, depth - 1)\n        total += recurse(a,    mid_x, mid_y, d,    child_tol, depth - 1)\n        total += recurse(mid_x, b,    mid_y, d,    child_tol, depth - 1)\n        return total\n\n    return recurse(-1.0, 1.0, -1.0, 1.0, tol, max_depth)\n\n# -------------------------------\n# Test suite assembly and solve\n# -------------------------------\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (element_type, vertices, integrand_function, tolerance, max_depth)\n    test_cases = [\n        (\"tri\", [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0)], f_poly, 1e-12, 5),\n        (\"tri\", [(0.0, 0.0), (1e-6, 0.0), (0.0, 1.0)], f_exp, 1e-10, 10),\n        (\"tri\", [(-1.0, -1.0), (2.0, -1.0), (0.0, 2.0)], f_zero, 1e-12, 2),\n        (\"quad\", [(0.0, 0.0), (2.0, 0.0), (2.0, 1.0), (0.0, 2.0)], f_exp, 1e-8, 7),\n        (\"quad\", [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)], f_osc, 1e-6, 9),\n        (\"quad\", [(0.0, 0.0), (1.5, 0.1), (1.4, 1.2), (0.1, 1.1)], f_peak, 1e-7, 7),\n    ]\n\n    results = []\n    for elem_type, verts, f, tol, max_depth in test_cases:\n        if elem_type == \"tri\":\n            res = tri_integrate_adaptive(f, verts, tol, max_depth)\n        elif elem_type == \"quad\":\n            res = quad_integrate_adaptive(f, verts, tol, max_depth)\n        else:\n            res = float(\"nan\")\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}