{
    "hands_on_practices": [
        {
            "introduction": "In the Finite Element Method (FEM), the integrals that define the stiffness matrix entries are typically computed numerically using quadrature rules. A critical question for ensuring the accuracy of the discretization is determining the minimum precision required for such a rule. This exercise  provides foundational practice in answering this question by analyzing the polynomial structure of the integrand, which is composed of material coefficients and gradients of the finite element basis functions. Successfully completing this task deepens your understanding of how the choice of element degree and the complexity of material properties dictate the necessary quality of numerical integration.",
            "id": "3437078",
            "problem": "Consider the scalar diffusion partial differential equation (PDE) on a bounded Lipschitz domain $\\,\\Omega \\subset \\mathbb{R}^{d}\\,$ with homogeneous Dirichlet boundary conditions,\n$$\n-\\nabla \\cdot \\big(\\kappa(x) \\nabla u(x)\\big) = f(x) \\quad \\text{in } \\Omega, \\qquad u=0 \\quad \\text{on } \\partial\\Omega,\n$$\nwhere the diffusion coefficient $\\,\\kappa(x)\\,$ is assumed to be piecewise polynomial of total degree $\\,r \\ge 0\\,$ when restricted to any element of a shape-regular simplicial mesh $\\,\\mathcal{T}_h\\,$ of $\\,\\Omega\\,$. Let $\\,V_h\\,$ be the standard conforming Lagrange finite element space of degree $\\,k \\ge 1\\,$ on $\\,\\mathcal{T}_h\\,$ with affine element mappings, and let $\\{\\varphi_i\\}$ denote the global nodal basis functions for $\\,V_h\\,$.\n\nThe global stiffness matrix $\\,A\\,$ has entries\n$$\nA_{ij} \\;=\\; \\int_{\\Omega} \\kappa(x)\\,\\nabla \\varphi_i(x) \\cdot \\nabla \\varphi_j(x)\\, \\mathrm{d}x,\n$$\nobtained by assembling elementwise contributions. Suppose that, on each element $\\,K \\in \\mathcal{T}_h\\,$, the volume integral is approximated by a quadrature rule that is exact for all polynomials on $\\,K\\,$ of total degree up to $\\,Q\\,$.\n\nStarting from fundamental definitions of the conforming Galerkin method and the polynomial-degree structure of Lagrange finite elements with affine mappings, determine the minimal integer $\\,Q_{\\min}\\,$ such that, for all meshes $\\,\\mathcal{T}_h\\,$ and all piecewise polynomial $\\,\\kappa\\,$ of degree $\\,r\\,$, the assembled quadrature-based global stiffness matrix is identical to the matrix obtained by exact integration. Express your final answer as a closed-form symbolic expression in terms of $\\,r\\,$ and $\\,k\\,$. No rounding is required, and no physical units apply to your answer.",
            "solution": "The problem as stated is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It is a standard problem in the analysis of the Finite Element Method (FEM). This warrants proceeding with a full solution.\n\nThe objective is to find the minimal integer $Q_{\\min}$ such that a numerical quadrature rule, exact for all polynomials on an element $K$ of total degree up to $Q$, will compute the element stiffness matrix exactly. For the quadrature-approximated global stiffness matrix to be identical to the exactly integrated one, this condition must hold for every element $K$ in the mesh $\\mathcal{T}_h$.\n\nThe entries of the global stiffness matrix $A$ are given by\n$$\nA_{ij} = \\int_{\\Omega} \\kappa(x)\\,\\nabla \\varphi_i(x) \\cdot \\nabla \\varphi_j(x)\\, \\mathrm{d}x.\n$$\nThis global integral is assembled by summing contributions from each element $K$ in the mesh $\\mathcal{T}_h$:\n$$\nA_{ij} = \\sum_{K \\in \\mathcal{T}_h} \\int_{K} \\kappa(x)\\,\\nabla \\varphi_i(x) \\cdot \\nabla \\varphi_j(x)\\, \\mathrm{d}x.\n$$\nThe numerical quadrature is applied to the integral over each element $K$. To ensure exact computation of this integral, the quadrature rule must be exact for the integrand function, which we denote by $I_K(x)$:\n$$\nI_K(x) = \\kappa(x)|_K \\, \\big(\\nabla \\varphi_i(x)|_K \\cdot \\nabla \\varphi_j(x)|_K\\big).\n$$\nTo determine the required degree of exactness $Q$, we must find the maximum possible total polynomial degree of $I_K(x)$ on an arbitrary element $K$. This degree is the sum of the degrees of its polynomial factors.\n\nLet's analyze the polynomial degree of each component of the integrand $I_K(x)$.\n\n1.  **The diffusion coefficient $\\kappa(x)$**: The problem states that when restricted to any element $K \\in \\mathcal{T}_h$, the function $\\kappa(x)$ is a polynomial of total degree at most $r$, where $r \\ge 0$. Let $\\text{deg}(\\kappa|_K)$ denote this degree.\n    $$\n    \\text{deg}(\\kappa|_K) \\le r.\n    $$\n\n2.  **The gradients of the basis functions $\\nabla \\varphi_i(x)$ and $\\nabla \\varphi_j(x)$**: The basis functions $\\varphi_i$ and $\\varphi_j$ belong to the standard conforming Lagrange finite element space $V_h$ of degree $k \\ge 1$. This means that on any element $K$, the restriction of a basis function $\\varphi_i|_K$ is a polynomial of total degree at most $k$.\n\n    The problem specifies that the element mappings are affine. Let $\\hat{K}$ be a reference element (e.g., the unit simplex) and let $F_K: \\hat{K} \\to K$ be the affine mapping from the reference to the physical element $K$. An affine map has the form $x = F_K(\\hat{x}) = B_K \\hat{x} + b_K$, where $B_K$ is a constant, invertible matrix (the Jacobian of the mapping) and $b_K$ is a constant vector. The inverse mapping $F_K^{-1}: K \\to \\hat{K}$ is also affine.\n\n    A basis function $\\varphi_i$ restricted to $K$ is obtained by composing a reference basis function $\\hat{\\varphi}_{\\alpha}(\\hat{x})$ (which is a polynomial of degree at most $k$ on $\\hat{K}$) with the inverse mapping:\n    $$\n    \\varphi_i|_K(x) = \\hat{\\varphi}_{\\alpha}(F_K^{-1}(x)).\n    $$\n    We compute the gradient of $\\varphi_i|_K(x)$ using the chain rule:\n    $$\n    \\nabla_x \\varphi_i|_K(x) = (B_K^{-T}) \\, \\nabla_{\\hat{x}} \\hat{\\varphi}_{\\alpha}(F_K^{-1}(x)).\n    $$\n    Here, $\\nabla_{\\hat{x}} \\hat{\\varphi}_{\\alpha}$ is the gradient of a polynomial of degree at most $k$ with respect to the reference coordinates $\\hat{x}$. The gradient operator reduces the polynomial degree by one. Thus, each component of the vector $\\nabla_{\\hat{x}} \\hat{\\varphi}_{\\alpha}$ is a polynomial of degree at most $k-1$.\n\n    Since $F_K^{-1}(x)$ is an affine function of $x$, composing $\\nabla_{\\hat{x}} \\hat{\\varphi}_{\\alpha}$ with $F_K^{-1}(x)$ results in a vector of polynomials in $x$ of degree at most $k-1$. The matrix $B_K^{-T}$ is constant, so multiplying by it does not change the polynomial degree. Therefore, for an affine mapping, the gradient of a degree-$k$ basis function is a vector of polynomials of degree at most $k-1$:\n    $$\n    \\text{deg}(\\nabla \\varphi_i|_K) \\le k-1 \\quad \\text{and} \\quad \\text{deg}(\\nabla \\varphi_j|_K) \\le k-1.\n    $$\n\n3.  **The dot product term $\\nabla \\varphi_i \\cdot \\nabla \\varphi_j$**: This term is the dot product of two vectors whose components are polynomials of degree at most $k-1$. The product of two such polynomials has a degree of at most $(k-1) + (k-1) = 2k-2$. The sum of such products, as in a dot product, will also have a degree of at most $2k-2$.\n    $$\n    \\text{deg}(\\nabla \\varphi_i|_K \\cdot \\nabla \\varphi_j|_K) \\le 2(k-1).\n    $$\n\n4.  **The total degree of the integrand $I_K(x)$**: The total degree of the integrand $I_K(x) = \\kappa|_K \\, (\\nabla \\varphi_i|_K \\cdot \\nabla \\varphi_j|_K)$ is the sum of the degrees of its factors:\n    $$\n    \\text{deg}(I_K(x)) \\le \\text{deg}(\\kappa|_K) + \\text{deg}(\\nabla \\varphi_i|_K \\cdot \\nabla \\varphi_j|_K) \\le r + 2(k-1).\n    $$\n    To ensure that the assembled stiffness matrix is exact for all possible choices of meshes and piecewise polynomial coefficients $\\kappa(x)$ (of degree $r$), the quadrature rule must be exact for polynomials up to this maximum possible degree. It is possible to construct a function $\\kappa(x)$ that is exactly degree $r$ on an element and to find basis functions $\\varphi_i, \\varphi_j$ (for $k \\ge 1$) whose gradients are polynomials of exactly degree $k-1$. Therefore, the upper bound of $r + 2(k-1)$ is sharp and represents the worst-case scenario.\n\n    Thus, the minimal integer $Q_{\\min}$ for the degree of exactness of the quadrature rule must be this value.\n    $$\n    Q_{\\min} = r + 2(k-1).\n    $$\nThis ensures that for any element $K$, the integral $\\int_K I_K(x) \\, \\mathrm{d}x$ is computed exactly, which in turn guarantees that the assembled global stiffness matrix is identical to the one obtained via exact integration.",
            "answer": "$$\n\\boxed{2(k-1) + r}\n$$"
        },
        {
            "introduction": "The global stiffness matrix $K$ and mass matrix $M$ do more than just solve static problems; together, they define a generalized eigenproblem $K\\mathbf{u} = \\lambda M\\mathbf{u}$ whose solutions describe the natural frequencies and mode shapes of a discretized physical system. The spectral properties of these matrices are therefore of paramount physical and numerical importance. This practice problem  challenges you to derive the exact eigenvalues for a canonical 1D problem, offering a clear window into how the structure of $K$ and $M$ reflects the underlying physics and how the discrete spectrum behaves as a function of mesh refinement.",
            "id": "3437086",
            "problem": "Consider the one-dimensional ($1\\text{-}$D) Laplacian eigenproblem on the interval $[0,1]$ with homogeneous Dirichlet boundary conditions: find $u \\neq 0$ and $\\lambda \\in \\mathbb{R}$ such that $-u''=\\lambda u$ in $(0,1)$ with $u(0)=u(1)=0$. The standard Galerkin finite element method (Finite Element Method, FEM) with continuous piecewise-linear basis functions on a uniform partition of $[0,1]$ into $N$ equal subintervals of length $h=1/N$ produces the generalized matrix eigenproblem $K \\mathbf{u} = \\lambda M \\mathbf{u}$, where $K$ is the global stiffness matrix and $M$ is the global consistent mass matrix assembled from the canonical hat functions.\n\nStarting from the weak form and the definition of the element-level matrices for linear shape functions, derive the exact closed-form expression of the largest generalized eigenvalue $\\lambda_{\\max}(N)$ of the discrete pencil $(K,M)$ as a function of $N$. Your derivation must proceed from first principles (weak form, basis functions, and assembly) and use only well-tested facts about the resulting matrices’ structure. Express your final result as a single closed-form analytic expression in terms of $N$. No rounding is required.",
            "solution": "The user-provided problem is valid as it is scientifically grounded, well-posed, objective, and contains a complete and consistent setup for a standard problem in the numerical analysis of partial differential equations. We may therefore proceed with the derivation.\n\nThe problem is to find the largest generalized eigenvalue $\\lambda_{\\max}(N)$ for the discrete system arising from a Finite Element Method (FEM) discretization of the $1\\text{-D}$ Laplacian eigenproblem.\n\nThe eigenproblem is given by:\n$$\n-u''(x) = \\lambda u(x), \\quad x \\in (0, 1)\n$$\nwith homogeneous Dirichlet boundary conditions $u(0) = u(1) = 0$.\n\nThe first step is to derive the weak formulation. We multiply the differential equation by a test function $v(x)$ from the Sobolev space $H_0^1(0,1)$, which consists of functions that are square-integrable, have square-integrable weak derivatives, and satisfy the homogeneous Dirichlet boundary conditions. Integrating over the domain $[0,1]$ yields:\n$$\n\\int_0^1 -u''(x) v(x) \\,dx = \\lambda \\int_0^1 u(x) v(x) \\,dx\n$$\nApplying integration by parts to the left-hand side:\n$$\n\\left[-u'(x)v(x)\\right]_0^1 + \\int_0^1 u'(x) v'(x) \\,dx = \\lambda \\int_0^1 u(x) v(x) \\,dx\n$$\nSince $v \\in H_0^1(0,1)$, we have $v(0)=v(1)=0$, causing the boundary term to vanish. This gives the weak formulation: Find $u \\in H_0^1(0,1)$ and $\\lambda \\in \\mathbb{R}$ such that for all $v \\in H_0^1(0,1)$:\n$$\na(u,v) = \\lambda b(u,v)\n$$\nwhere the bilinear forms are defined as $a(u,v) = \\int_0^1 u'(x) v'(x) \\,dx$ and $b(u,v) = \\int_0^1 u(x) v(x) \\,dx$.\n\nFor the FEM discretization, we partition the interval $[0,1]$ into $N$ equal subintervals $[x_{i-1}, x_i]$ for $i=1, \\dots, N$, where $x_i = i h$ and the mesh size is $h=1/N$. We define a finite-dimensional subspace $V_h \\subset H_0^1(0,1)$ spanned by continuous piecewise-linear basis functions (hat functions) $\\{\\phi_j\\}_{j=1}^{N-1}$. Each basis function $\\phi_j(x)$ is defined to be $1$ at node $x_j$ and $0$ at all other nodes $x_k$ ($k \\neq j$), and linear in between. The boundary conditions $u(0)=u(1)=0$ are enforced by excluding the basis functions corresponding to nodes $x_0$ and $x_N$. The dimension of $V_h$ is therefore $N-1$.\n\nThe FEM solution $u_h(x)$ is sought in $V_h$ as a linear combination of these basis functions:\n$$\nu_h(x) = \\sum_{j=1}^{N-1} c_j \\phi_j(x)\n$$\nThe Galerkin method requires finding $u_h \\in V_h$ and $\\lambda_h \\in \\mathbb{R}$ such that $a(u_h, v_h) = \\lambda_h b(u_h, v_h)$ for all $v_h \\in V_h$. By choosing the test functions $v_h$ to be the basis functions $\\phi_i$ for $i=1, \\dots, N-1$, we obtain a system of linear equations:\n$$\n\\sum_{j=1}^{N-1} c_j \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\,dx = \\lambda_h \\sum_{j=1}^{N-1} c_j \\int_0^1 \\phi_j(x) \\phi_i(x) \\,dx\n$$\nThis is the generalized matrix eigenvalue problem $K \\mathbf{c} = \\lambda_h M \\mathbf{c}$, where $\\mathbf{c} = (c_1, \\dots, c_{N-1})^T$ is the vector of unknown coefficients, and the entries of the global stiffness matrix $K$ and mass matrix $M$ are given by:\n$$\nK_{ij} = a(\\phi_j, \\phi_i) = \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\,dx\n$$\n$$\nM_{ij} = b(\\phi_j, \\phi_i) = \\int_0^1 \\phi_j(x) \\phi_i(x) \\,dx\n$$\nThe matrices are of size $(N-1) \\times (N-1)$. To construct them, we first compute the element matrices on a generic element $[x_k, x_{k+1}]$ of length $h$. The local basis functions on this element are $\\psi_1(x) = \\frac{x_{k+1}-x}{h}$ and $\\psi_2(x) = \\frac{x-x_k}{h}$. Their derivatives are $\\psi_1'(x) = -1/h$ and $\\psi_2'(x) = 1/h$.\n\nThe element stiffness matrix $K^e$ has entries $K^e_{ab} = \\int_{x_k}^{x_{k+1}} \\psi_a'(x) \\psi_b'(x) \\,dx$:\n$$\nK^e = \\int_0^h \\frac{1}{h^2} \\begin{pmatrix} (-1)(-1) & (-1)(1) \\\\ (1)(-1) & (1)(1) \\end{pmatrix} \\,dx = \\frac{1}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nThe element mass matrix $M^e$ has entries $M^e_{ab} = \\int_{x_k}^{x_{k+1}} \\psi_a(x) \\psi_b(x) \\,dx$. A change of variables to a reference element $[0,h]$ gives:\n$$\nM^e_{11} = \\int_0^h (1-\\frac{t}{h})^2 \\,dt = \\frac{h}{3}, \\quad M^e_{22} = \\int_0^h (\\frac{t}{h})^2 \\,dt = \\frac{h}{3}\n$$\n$$\nM^e_{12} = \\int_0^h (1-\\frac{t}{h})(\\frac{t}{h}) \\,dt = \\frac{h}{6}\n$$\nSo the element mass matrix is:\n$$\nM^e = \\frac{h}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}\n$$\nThe global matrices $K$ and $M$ are assembled by summing contributions from element matrices. The basis functions $\\phi_i$ and $\\phi_j$ have overlapping support only if $|i-j| \\leq 1$, making $K$ and $M$ tridiagonal.\nFor the diagonal entries $K_{ii}$ and $M_{ii}$, we sum contributions from two adjacent elements:\n$$\nK_{ii} = K^e_{22} + K^e_{11} = \\frac{1}{h} + \\frac{1}{h} = \\frac{2}{h}\n$$\n$$\nM_{ii} = M^e_{22} + M^e_{11} = \\frac{h}{3} + \\frac{h}{3} = \\frac{2h}{3}\n$$\nFor the off-diagonal entries $K_{i,i+1}$ and $M_{i,i+1}$, we have contribution from one element:\n$$\nK_{i,i+1} = K^e_{12} = -\\frac{1}{h}\n$$\n$$\nM_{i,i+1} = M^e_{12} = \\frac{h}{6}\n$$\nThus, the $(N-1) \\times (N-1)$ global matrices are:\n$$\nK = \\frac{1}{h} \\begin{pmatrix} 2 & -1 & & \\\\ -1 & 2 & -1 & \\\\ & \\ddots & \\ddots & \\ddots \\\\ & & -1 & 2 & -1 \\\\ & & & -1 & 2 \\end{pmatrix}, \\quad M = \\frac{h}{6} \\begin{pmatrix} 4 & 1 & & \\\\ 1 & 4 & 1 & \\\\ & \\ddots & \\ddots & \\ddots \\\\ & & 1 & 4 & 1 \\\\ & & & 1 & 4 \\end{pmatrix}\n$$\nThis is correct. An $n \\times n$ tridiagonal Toeplitz matrix $T = \\text{Tridiag}(b,a,b)$ has known eigenvalues $\\mu_k = a + 2b \\cos(\\frac{k\\pi}{n+1})$ for $k=1, \\dots, n$. Both $K$ and $M$ have this structure with $n=N-1$.\n\nFor the stiffness matrix $K$, we have a prefactor of $1/h$, and inside the matrix $a_K=2, b_K=-1$. The eigenvalues of $K$ are:\n$$\n\\mu_k(K) = \\frac{1}{h} \\left(2 + 2(-1) \\cos\\left(\\frac{k\\pi}{N}\\right)\\right) = \\frac{2}{h}\\left(1-\\cos\\left(\\frac{k\\pi}{N}\\right)\\right) = \\frac{4}{h}\\sin^2\\left(\\frac{k\\pi}{2N}\\right)\n$$\nFor the mass matrix $M$, we have a prefactor of $h/6$, and inside the matrix $a_M=4, b_M=1$. The eigenvalues of $M$ are:\n$$\n\\mu_k(M) = \\frac{h}{6} \\left(4 + 2(1) \\cos\\left(\\frac{k\\pi}{N}\\right)\\right) = \\frac{h}{3}\\left(2+\\cos\\left(\\frac{k\\pi}{N}\\right)\\right)\n$$\nWe use the identity $\\cos(\\theta) = 1-2\\sin^2(\\theta/2)$:\n$$\n\\mu_k(M) = \\frac{h}{3}\\left(2+1-2\\sin^2\\left(\\frac{k\\pi}{2N}\\right)\\right) = h\\left(1-\\frac{2}{3}\\sin^2\\left(\\frac{k\\pi}{2N}\\right)\\right)\n$$\nBoth matrices $K$ and $M$ are diagonalized by the same eigenvector matrix, whose columns are $\\mathbf{v}_k$ with components $[\\mathbf{v}_k]_j = \\sin(\\frac{jk\\pi}{N})$. Therefore, the generalized eigenvalues $\\lambda_k$ of the pencil $(K,M)$ are the ratios of the eigenvalues of $K$ and $M$:\n$$\n\\lambda_k = \\frac{\\mu_k(K)}{\\mu_k(M)} = \\frac{\\frac{4}{h}\\sin^2\\left(\\frac{k\\pi}{2N}\\right)}{h\\left(1-\\frac{2}{3}\\sin^2\\left(\\frac{k\\pi}{2N}\\right)\\right)} = \\frac{4}{h^2} \\frac{\\sin^2\\left(\\frac{k\\pi}{2N}\\right)}{1-\\frac{2}{3}\\sin^2\\left(\\frac{k\\pi}{2N}\\right)}\n$$\nSubstituting $h=1/N$, we get the expression for the $k$-th eigenvalue as a function of $N$:\n$$\n\\lambda_k(N) = 4N^2 \\frac{\\sin^2\\left(\\frac{k\\pi}{2N}\\right)}{1-\\frac{2}{3}\\sin^2\\left(\\frac{k\\pi}{2N}\\right)}, \\quad k=1, 2, \\dots, N-1.\n$$\nTo find the largest eigenvalue $\\lambda_{\\max}(N)$, we must maximize $\\lambda_k(N)$ with respect to $k$. Let $s_k = \\sin^2\\left(\\frac{k\\pi}{2N}\\right)$. The expression is proportional to the function $f(s_k) = \\frac{s_k}{1-2s_k/3}$. For $k \\in [1, N-1]$, the argument $\\frac{k\\pi}{2N}$ is in the interval $(0, \\pi/2)$. In this interval, $\\sin(\\cdot)$ is a positive and strictly increasing function, so $s_k = \\sin^2\\left(\\frac{k\\pi}{2N}\\right)$ is also strictly increasing with $k$.\nThe derivative of $f(s)$ with respect to $s$ is $f'(s) = \\frac{1(1-2s/3) - s(-2/3)}{(1-2s/3)^2} = \\frac{1}{(1-2s/3)^2}$, which is always positive. Therefore, $f(s_k)$ is a strictly increasing function of $s_k$, and thus $\\lambda_k(N)$ is a strictly increasing function of $k$.\nThe maximum value is attained at the largest possible value of $k$, which is $k=N-1$.\n$$\n\\lambda_{\\max}(N) = \\lambda_{N-1}(N) = 4N^2 \\frac{\\sin^2\\left(\\frac{(N-1)\\pi}{2N}\\right)}{1-\\frac{2}{3}\\sin^2\\left(\\frac{(N-1)\\pi}{2N}\\right)}\n$$\nWe simplify the trigonometric term using $\\sin(\\pi/2 - \\theta) = \\cos(\\theta)$:\n$$\n\\sin\\left(\\frac{(N-1)\\pi}{2N}\\right) = \\sin\\left(\\frac{\\pi}{2} - \\frac{\\pi}{2N}\\right) = \\cos\\left(\\frac{\\pi}{2N}\\right)\n$$\nSubstituting this into the expression for $\\lambda_{\\max}(N)$:\n$$\n\\lambda_{\\max}(N) = 4N^2 \\frac{\\cos^2\\left(\\frac{\\pi}{2N}\\right)}{1-\\frac{2}{3}\\cos^2\\left(\\frac{\\pi}{2N}\\right)}\n$$\nTo obtain a more compact form, we use the identity $\\cos^2(\\theta) = \\frac{1+\\cos(2\\theta)}{2}$. Here, $\\theta = \\frac{\\pi}{2N}$, so $2\\theta = \\frac{\\pi}{N}$.\nThe numerator becomes:\n$$\n4N^2 \\cos^2\\left(\\frac{\\pi}{2N}\\right) = 4N^2 \\left(\\frac{1+\\cos(\\pi/N)}{2}\\right) = 2N^2(1+\\cos(\\pi/N))\n$$\nThe denominator becomes:\n$$\n1-\\frac{2}{3}\\cos^2\\left(\\frac{\\pi}{2N}\\right) = 1-\\frac{2}{3}\\left(\\frac{1+\\cos(\\pi/N)}{2}\\right) = 1 - \\frac{1+\\cos(\\pi/N)}{3} = \\frac{3 - 1 - \\cos(\\pi/N)}{3} = \\frac{2-\\cos(\\pi/N)}{3}\n$$\nCombining these results gives the final closed-form expression:\n$$\n\\lambda_{\\max}(N) = \\frac{2N^2(1+\\cos(\\pi/N))}{\\frac{1}{3}(2-\\cos(\\pi/N))} = \\frac{6N^2(1+\\cos(\\pi/N))}{2-\\cos(\\pi/N)}\n$$",
            "answer": "$$\n\\boxed{\\frac{6N^{2}\\left(1+\\cos\\left(\\frac{\\pi}{N}\\right)\\right)}{2-\\cos\\left(\\frac{\\pi}{N}\\right)}}\n$$"
        },
        {
            "introduction": "While full-order numerical integration of an element stiffness matrix seems ideal, it can lead to pathological numerical behavior, such as volumetric locking in nearly incompressible materials. Conversely, uniformly reducing the integration order can introduce non-physical, zero-energy deformations known as hourglass modes. This hands-on coding problem  explores the powerful technique of Selective Reduced Integration (SRI), which offers a robust solution by treating the volumetric and deviatoric components of the stiffness matrix differently. By implementing and analyzing the eigenvalues of stiffness matrices generated with full, reduced, and selective integration, you will gain practical experience in diagnosing these common FEM challenges and appreciating the elegance of their resolution.",
            "id": "3599220",
            "problem": "Consider a three-dimensional small-strain, linear-elastic solid occupying the cube domain $\\Omega = [0,1] \\times [0,1] \\times [0,1]$ in $\\mathrm{m}^3$. Discretize $\\Omega$ with a uniform, structured mesh of $2 \\times 2 \\times 2$ trilinear eight-node hexahedral elements ($H_8$). Each node has three translational degrees of freedom. Impose homogeneous Dirichlet boundary conditions $u_x = u_y = u_z = 0$ on the entire face $\\{(x,y,z) \\in \\Omega \\mid z = 0\\}$ to eliminate rigid-body modes. Assume isotropic, homogeneous, linear elasticity with Young’s modulus $E$ (in $\\mathrm{Pa}$) and Poisson’s ratio $\\nu$, with Lamé parameters $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\dfrac{E}{2(1+\\nu)}$. Let the constitutive tensor in Voigt notation be the standard $6 \\times 6$ matrix for three-dimensional isotropic linear elasticity built from $\\lambda$ and $\\mu$. Use small-strain kinematics. No body forces or tractions are applied.\n\nStarting from the principle of virtual work for the static, unloaded configuration,\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\mathbf{v}) \\, \\mathrm{d}\\Omega = 0,\n$$\nwith the usual finite element Galerkin discretization using $H_8$ shape functions, assemble the global stiffness matrix $\\mathbf{K}$. The selective reduced integration (SRI, Selective Reduced Integration) strategy decomposes the constitutive response into volumetric and deviatoric parts and integrates them with different quadrature rules to alleviate locking while avoiding spurious zero-energy modes (hourglass modes). Specifically, for the element stiffness $\\mathbf{K}^e$:\n- The deviatoric term must be integrated using a tensor-product Gaussian rule with $2$ points per direction ($2 \\times 2 \\times 2$ integration).\n- The volumetric term must be integrated using a single integration point at the element center (one-point integration).\n\nIn contrast, for reference and comparison:\n- Full integration (FI, Full Integration) integrates the full constitutive response at $2 \\times 2 \\times 2$ Gauss points.\n- Reduced integration (RI, Reduced Integration) integrates the full constitutive response at a single element-center point (one-point integration).\n\nUse standard isoparametric $H_8$ shape functions on the parent domain $[-1,1]^3$ and the exact isoparametric mapping to physical coordinates. For the $2 \\times 2 \\times 2$ Gauss rule, use the one-dimensional abscissae $\\{\\pm 1/\\sqrt{3}\\}$ with weights $1$, composed in tensor product. For the one-point rule, use the abscissa $0$ with weight $2$ in each direction composed in tensor product. Treat the mesh as a uniform partition of the unit cube, so all element mappings are rectangular and aligned.\n\nYour task is to write a complete program that:\n- Builds the $H_8$ mesh of the unit cube with $2 \\times 2 \\times 2$ elements and assembles the global stiffness matrix $\\mathbf{K}$.\n- Applies homogeneous Dirichlet boundary conditions on the face $z=0$ by eliminating the associated rows and columns.\n- Computes the $k$ smallest eigenvalues (in ascending order) of the symmetric positive semidefinite matrix $\\mathbf{K}$ under three integration schemes: FI, RI, and SRI, for parameter sets specified below. The eigenvalues must be computed for the reduced matrix after applying boundary conditions, and reported in units of $\\mathrm{N}/\\mathrm{m}$.\n- Reports the eigenvalues as floating-point numbers.\n\nUse the following test suite with $k=6$ and $E = 10^5$ (in $\\mathrm{Pa}$):\n- Case $1$: scheme FI, $\\nu = 0.3$.\n- Case $2$: scheme RI, $\\nu = 0.3$.\n- Case $3$: scheme SRI, $\\nu = 0.3$.\n- Case $4$: scheme FI, $\\nu = 0.4999$.\n- Case $5$: scheme SRI, $\\nu = 0.4999$.\n\nDesign for coverage:\n- Case $2$ should reveal spurious near-zero eigenvalues (hourglass modes) due to one-point reduced integration on $H_8$.\n- Cases $1$ and $3$ should be free of hourglass modes, with strictly positive smallest eigenvalues after boundary conditions.\n- Cases $4$ and $5$ compare the behavior near incompressibility, showing that selective reduced integration mitigates volumetric locking without introducing hourglass modes.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated Python-style list of lists. Each inner list must contain the $k$ smallest eigenvalues (in $\\mathrm{N}/\\mathrm{m}$) for one test case in ascending order, rounded to $6$ decimal places. The five inner lists must be ordered as the five cases above. For example, the output must have the form\n$[ [e_{1,1}, e_{1,2}, e_{1,3}, e_{1,4}, e_{1,5}, e_{1,6}], [e_{2,1}, \\dots, e_{2,6}], \\dots, [e_{5,1}, \\dots, e_{5,6}] ]$\nall on a single line, where $e_{i,j}$ denotes the $j$-th eigenvalue of case $i$.",
            "solution": "The user-provided problem is assessed as **valid**. It is a well-defined, scientifically-grounded problem in computational solid mechanics that adheres to established principles of the Finite Element Method (FEM). The problem is self-contained, with all necessary data, boundary conditions, and material properties provided. The objectives are clear and the test cases are designed to illustrate known numerical phenomena (volumetric locking and hourglassing), which is a standard pedagogical exercise.\n\n### Principle-Based Design of the Solution\n\nThe solution is based on the Finite Element Method (FEM) for three-dimensional linear elasticity. The process begins with the principle of virtual work, which, for a static solid with no external loads, is stated as:\n$$\n\\delta W = \\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\delta\\mathbf{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\mathbf{u}) \\, \\mathrm{d}\\Omega = 0\n$$\nwhere $\\mathbf{u}$ is the displacement field, $\\delta\\mathbf{u}$ is a kinematically admissible virtual displacement field, $\\boldsymbol{\\varepsilon}$ is the small-strain tensor, $\\mathbb{C}$ is the fourth-order elasticity tensor, and $\\Omega$ is the material domain.\n\nThis continuous weak form is discretized by dividing the domain $\\Omega = [0,1]^3 \\ \\mathrm{m}^3$ into a mesh of $2 \\times 2 \\times 2 = 8$ trilinear hexahedral elements ($H_8$). Within each element $\\Omega_e$, the displacement field is approximated using isoparametric shape functions $N_i$ and nodal displacements $\\mathbf{d}^e$:\n$$\n\\mathbf{u}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{8} N_i(\\boldsymbol{\\xi}) \\mathbf{u}_i\n$$\nwhere $\\boldsymbol{\\xi} = (\\xi, \\eta, \\zeta)$ are the coordinates in the parent element domain $[-1,1]^3$. This approximation leads to a discrete strain-displacement relationship $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}^e$, where $\\mathbf{B}$ is the strain-displacement matrix, which depends on the spatial derivatives of the shape functions.\n\nSubstituting the FE approximation into the principle of virtual work and considering arbitrary nodal virtual displacements $\\delta\\mathbf{d}$ yields the discrete system of linear equations $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$. Since no external forces are applied, the system is homogeneous, and we analyze the properties of the global stiffness matrix $\\mathbf{K}$. The matrix $\\mathbf{K}$ is assembled from element stiffness matrices $\\mathbf{K}^e$:\n$$\n\\mathbf{K}^e = \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{C} \\mathbf{B} \\, \\mathrm{d}\\Omega\n$$\nwhere $\\mathbf{C}$ is the constitutive matrix in Voigt notation. For isotropic linear elasticity, it's defined by the Lamé parameters $\\lambda$ and $\\mu$. The integral is transformed to the parent domain and evaluated numerically using Gaussian quadrature:\n$$\n\\mathbf{K}^e = \\int_{-1}^{1}\\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}(\\boldsymbol{\\xi})^T \\mathbf{C} \\mathbf{B}(\\boldsymbol{\\xi}) \\det(\\mathbf{J}) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta \\, \\mathrm{d}\\zeta \\approx \\sum_{g} w_g \\mathbf{B}(\\boldsymbol{\\xi}_g)^T \\mathbf{C} \\mathbf{B}(\\boldsymbol{\\xi}_g) \\det(\\mathbf{J}(\\boldsymbol{\\xi}_g))\n$$\nwhere $\\mathbf{J}$ is the Jacobian of the mapping from parent to physical coordinates, and $w_g$ and $\\boldsymbol{\\xi}_g$ are the quadrature weights and points, respectively. For the given uniform mesh, $\\det(\\mathbf{J})$ is constant for all elements.\n\nThe problem requires a modal analysis (computation of eigenvalues) of the stiffness matrix $\\mathbf{K}$ under three different numerical integration schemes:\n\n1.  **Full Integration (FI)**: The integral for $\\mathbf{K}^e$ is evaluated using a $2 \\times 2 \\times 2$ Gaussian quadrature rule. This rule is sufficient to exactly integrate the stiffness matrix for rectangular elements and is rank-sufficient, meaning it does not introduce non-physical zero-energy modes. However, for nearly incompressible materials ($\\nu \\to 0.5$), it can lead to \"volumetric locking,\" an artificial stiffening of the element's response.\n\n2.  **Reduced Integration (RI)**: The integral is evaluated using a single Gauss point at the element center $(\\xi, \\eta, \\zeta)=(0,0,0)$. This scheme is known to alleviate volumetric locking but is rank-deficient for $H_8$ elements, leading to spurious zero-energy modes known as \"hourglass modes.\" These modes manifest as near-zero eigenvalues in the stiffness matrix even after rigid-body motion is constrained.\n\n3.  **Selective Reduced Integration (SRI)**: This hybrid approach aims to combine the benefits of FI and RI. The constitutive behavior is decomposed into volumetric and deviatoric parts. The same decomposition applies to the stiffness matrix: $\\mathbf{K}^e = \\mathbf{K}^e_{vol} + \\mathbf{K}^e_{dev}$. The stiff volumetric part, which causes locking, is integrated using a reduced (single-point) rule, while the deviatoric part is fully integrated ($2 \\times 2 \\times 2$ rule). This simultaneously prevents locking and controls hourglass modes. The decomposition of the constitutive matrix is:\n    $$\n    \\mathbf{C} = \\mathbf{C}_{dev} + \\mathbf{C}_{vol}\n    $$\n    where $\\mathbf{C}_{vol} = K \\mathbf{m} \\mathbf{m}^T$, with $K=\\lambda + \\frac{2}{3}\\mu$ being the bulk modulus and $\\mathbf{m} = [1, 1, 1, 0, 0, 0]^T$. The element stiffness is then:\n    $$\n    \\mathbf{K}^e_{SRI} = \\left(\\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{C}_{dev} \\mathbf{B} \\, \\mathrm{d}\\Omega\\right)_{\\text{FI}} + \\left(\\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{C}_{vol} \\mathbf{B} \\, \\mathrm{d}\\Omega\\right)_{\\text{RI}}\n    $$\n\nThe global stiffness matrix $\\mathbf{K}$ is assembled by summing the contributions from all $8$ element matrices. Homogeneous Dirichlet boundary conditions ($u_x = u_y = u_z = 0$) are applied to the $z=0$ face. This is accomplished by identifying all degrees of freedom (DOFs) on this face and removing the corresponding rows and columns from $\\mathbf{K}$ to form a reduced, positive-definite matrix $\\mathbf{K}_{red}$ (except for the RI case).\n\nFinally, an eigenvalue analysis is performed on the symmetric matrix $\\mathbf{K}_{red}$. The $k=6$ smallest eigenvalues, which correspond to the softest deformation modes of the constrained structure, are computed using `scipy.linalg.eigh`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef get_B_matrix(xi, eta, zeta, J_inv):\n    \"\"\"\n    Computes the strain-displacement matrix B for an H8 element at a given\n    point in parent coordinates.\n    J_inv is the inverse of the Jacobian matrix.\n    \"\"\"\n    # Parent coordinates of the 8 nodes of a standard H8 element\n    node_parent_coords = np.array([\n        [-1, -1, -1], [ 1, -1, -1], [ 1,  1, -1], [-1,  1, -1],\n        [-1, -1,  1], [ 1, -1,  1], [ 1,  1,  1], [-1,  1,  1]\n    ])\n\n    # Derivatives of shape functions w.r.t. parent coordinates (dNdxi)\n    dNdxi_eta_zeta = np.zeros((3, 8))\n    for i in range(8):\n        xi_i, eta_i, zeta_i = node_parent_coords[i]\n        dNdxi_eta_zeta[0, i] = 0.125 * xi_i * (1 + eta_i * eta) * (1 + zeta_i * zeta)\n        dNdxi_eta_zeta[1, i] = 0.125 * eta_i * (1 + xi_i * xi) * (1 + zeta_i * zeta)\n        dNdxi_eta_zeta[2, i] = 0.125 * zeta_i * (1 + xi_i * xi) * (1 + eta_i * eta)\n\n    # Derivatives of shape functions w.r.t. physical coordinates (dNdX)\n    dNdxyz = J_inv @ dNdxi_eta_zeta\n\n    # Assemble the B matrix (6x24)\n    B = np.zeros((6, 24))\n    for i in range(8):\n        dN_dx_i, dN_dy_i, dN_dz_i = dNdxyz[:, i]\n        B[0, 3*i    ] = dN_dx_i\n        B[1, 3*i + 1] = dN_dy_i\n        B[2, 3*i + 2] = dN_dz_i\n        B[3, 3*i    ] = dN_dy_i; B[3, 3*i + 1] = dN_dx_i\n        B[4, 3*i + 1] = dN_dz_i; B[4, 3*i + 2] = dN_dy_i\n        B[5, 3*i    ] = dN_dz_i; B[5, 3*i + 2] = dN_dx_i\n    return B\n\ndef calculate_element_stiffness(scheme, E, nu):\n    \"\"\"\n    Calculates the element stiffness matrix Ke for an H8 element based on the\n    integration scheme. All elements are identical cubes.\n    \"\"\"\n    h = 0.5  # Element side length\n    detJ = (h/2.0)**3\n    J_inv = np.diag([1.0 / (h / 2.0)] * 3)\n\n    # Material properties (Lamé parameters)\n    lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    mu = E / (2 * (1 + nu))\n\n    # Constitutive matrix C in Voigt notation\n    C = np.zeros((6, 6))\n    C[0, 0] = C[1, 1] = C[2, 2] = lmbda + 2 * mu\n    C[0, 1] = C[1, 0] = C[0, 2] = C[2, 0] = C[1, 2] = C[2, 1] = lmbda\n    C[3, 3] = C[4, 4] = C[5, 5] = mu\n    \n    Ke = np.zeros((24, 24))\n\n    if scheme == 'FI':\n        a = 1.0 / np.sqrt(3)\n        gps = [(x, y, z) for x in [-a, a] for y in [-a, a] for z in [-a, a]]\n        for xi, eta, zeta in gps:\n            B = get_B_matrix(xi, eta, zeta, J_inv)\n            Ke += B.T @ C @ B * 1.0 * detJ\n    elif scheme == 'RI':\n        B = get_B_matrix(0.0, 0.0, 0.0, J_inv)\n        Ke += B.T @ C @ B * 8.0 * detJ\n    elif scheme == 'SRI':\n        # Decompose C into deviatoric and volumetric parts\n        K_bulk = lmbda + 2.0/3.0 * mu\n        m = np.array([1, 1, 1, 0, 0, 0]).reshape(6, 1)\n        C_vol = K_bulk * (m @ m.T)\n        C_dev = C - C_vol\n\n        # Deviatoric part integrated with 2x2x2 rule\n        a = 1.0 / np.sqrt(3)\n        gps_dev = [(x, y, z) for x in [-a, a] for y in [-a, a] for z in [-a, a]]\n        for xi, eta, zeta in gps_dev:\n            B_dev = get_B_matrix(xi, eta, zeta, J_inv)\n            Ke += B_dev.T @ C_dev @ B_dev * 1.0 * detJ\n            \n        # Volumetric part integrated with 1-point rule\n        B_vol = get_B_matrix(0.0, 0.0, 0.0, J_inv)\n        Ke += B_vol.T @ C_vol @ B_vol * 8.0 * detJ\n    return Ke\n\ndef run_fem_analysis(scheme, E, nu, k):\n    \"\"\"\n    Runs the full FEM analysis: mesh, assembly, BCs, and eigenvalue solution.\n    \"\"\"\n    # Mesh properties\n    nx, ny, nz = 2, 2, 2\n    num_nodes_x, num_nodes_y, num_nodes_z = nx + 1, ny + 1, nz + 1\n    total_nodes = num_nodes_x * num_nodes_y * num_nodes_z\n    total_dofs = total_nodes * 3\n    \n    K_global = np.zeros((total_dofs, total_dofs))\n\n    # Pre-calculate the element stiffness matrix (all elements are identical)\n    Ke = calculate_element_stiffness(scheme, E, nu)\n\n    # Assemble the global stiffness matrix\n    for k_el in range(nz):\n        for j_el in range(ny):\n            for i_el in range(nx):\n                # Global node indices for this element\n                conn = np.array([\n                    (i_el)   + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el+1) + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el+1) + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el)   + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el)   + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el+1),\n                    (i_el+1) + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el+1),\n                    (i_el+1) + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el+1),\n                    (i_el)   + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el+1)\n                ], dtype=int)\n                \n                # Map element DOFs to global DOFs\n                dof_map = np.empty(24, dtype=int)\n                for i_node in range(8):\n                    dof_map[i_node*3 : i_node*3+3] = conn[i_node]*3 + np.arange(3)\n                \n                # Add element stiffness to global matrix\n                K_global[np.ix_(dof_map, dof_map)] += Ke\n\n    # Apply homogeneous Dirichlet boundary conditions on z=0 face\n    constrained_nodes = []\n    # k_node = 0 for the z=0 face\n    for j_node in range(num_nodes_y):\n        for i_node in range(num_nodes_x):\n            constrained_nodes.append(i_node + num_nodes_x * j_node)\n    \n    constrained_dofs = []\n    for node_idx in constrained_nodes:\n        constrained_dofs.extend([node_idx * 3, node_idx * 3 + 1, node_idx * 3 + 2])\n    \n    all_dofs = np.arange(total_dofs)\n    free_dofs = np.setdiff1d(all_dofs, constrained_dofs, assume_unique=True)\n    \n    K_reduced = K_global[np.ix_(free_dofs, free_dofs)]\n    \n    # Solve the eigenvalue problem for the k smallest eigenvalues\n    eigenvalues = eigh(K_reduced, eigvals_only=True, subset_by_index=[0, k-1])\n    \n    return eigenvalues\n\ndef solve():\n    test_cases = [\n        {'scheme': 'FI', 'nu': 0.3},\n        {'scheme': 'RI', 'nu': 0.3},\n        {'scheme': 'SRI', 'nu': 0.3},\n        {'scheme': 'FI', 'nu': 0.4999},\n        {'scheme': 'SRI', 'nu': 0.4999},\n    ]\n\n    E = 1e5\n    k = 6\n    \n    all_results = []\n    for case in test_cases:\n        eigenvalues = run_fem_analysis(case['scheme'], E, case['nu'], k)\n        rounded_eigs = [round(eig, 6) for eig in eigenvalues]\n        all_results.append(rounded_eigs)\n\n    # Format the output string to match the required format exactly\n    # repr() will create the string representation, then remove spaces\n    output_str = repr(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}