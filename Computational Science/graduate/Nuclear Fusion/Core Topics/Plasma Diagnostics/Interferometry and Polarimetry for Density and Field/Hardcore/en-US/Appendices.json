{
    "hands_on_practices": [
        {
            "introduction": "Before we can interpret measurements from an interferometer or polarimeter, we must first build a \"forward model\" to understand how the probe beam propagates through the spatially varying plasma. This exercise guides you through the process of deriving the fundamental ray equations from first principles and implementing a 2D ray tracing code to simulate the beam's path, accounting for refractive bending due to density gradients. Mastering this simulation is a cornerstone of designing and validating any line-integrated diagnostic system.",
            "id": "3704271",
            "problem": "You are tasked with deriving, implementing, and validating a two-dimensional ray tracing model for an electromagnetic probing beam in a tokamak with elongated flux surfaces in the plane described by cylindrical coordinates $(R,Z)$. The purpose is to simulate beam propagation for interferometry and polarimetry, accounting for refractive bending in a spatially varying electron density and magnetic field, and to explicitly avoid entering regions where propagation is not permitted (cutoffs). The problem must be framed from fundamental principles and solved using a first-principles derivation without relying on shortcut formulas that present the final model directly.\n\nAssumptions and modeling context:\n- Adopt the high-frequency, geometrical optics (eikonal) limit derived from Maxwell’s equations for a cold electron plasma in the International System of Units (SI).\n- Use an ordinary electromagnetic mode (O-mode) propagation model appropriate for interferometry in this limit.\n- Treat the tokamak cross-section as axisymmetric, with elongated flux surfaces defined by an elliptical family parameterized by a normalized minor radius coordinate, and with a toroidally varying magnetic field magnitude.\n- Compute the cumulative Faraday rotation angle along the beam path in radians using a polarimetry model derived in the same asymptotic regime.\n\nGeometry and profiles:\n- The tokamak has major radius $R_0$ and minor radius $a$, with elongation factor $\\kappa$. Elliptical flux surfaces are given implicitly by the normalized minor radius $\\rho$ via $(R - R_0)^2/a^2 + Z^2/(\\kappa a)^2 = \\rho^2$. Inside the plasma, $\\rho \\leq 1$, and outside the plasma, $\\rho  1$.\n- The electron density profile is $n_e(\\rho)$ that depends only on $\\rho$. The toroidal magnetic field magnitude is $B_\\phi(R)$ that depends only on $R$. The poloidal magnetic field is tangent to flux surfaces, with magnitude that varies weakly with radius through a specified parametrization based on safety factor.\n- Beam propagation must be limited to regions where the local refractive index squared remains positive. If the local refractive index squared approaches zero from above, this is a cutoff, and the algorithm must not integrate into regions where propagation is not permitted; it must terminate the path before entering such regions.\n\nRequired derivations:\n- Starting from Maxwell’s equations and the cold plasma dielectric response, obtain the O-mode dispersion relation in the high-frequency limit, and from it the local refractive index $n(R,Z)$ in terms of the local electron density and probe frequency. From eikonal theory, derive the ray equations of motion in an isotropic inhomogeneous medium and implement them in a form that can be numerically integrated in $(R,Z)$ with arc-length parameterization. Ensure that the dependence of $n$ on $R$ and $Z$ through $\\rho$ is handled consistently by the chain rule and the gradient.\n- Derive the cumulative Faraday rotation in radians along the path from the difference in phase velocities of the right- and left-hand circularly polarized modes under the same cold plasma assumptions, in the limit appropriate for high-frequency probe beams. The rotation must depend on the local electron density, the magnetic field component along the ray direction, and the probe wavelength.\n\nRay tracing task:\n- Implement a numerical integrator with fixed step size for the ray equations. The state variables are $(R,Z)$ and the unit tangent vector $\\hat{\\mathbf{s}}$ representing the direction of propagation. At each step:\n  - Compute the local refractive index $n(R,Z)$ and its gradient $\\nabla n(R,Z)$.\n  - Update the ray direction using the arc-length form of the geometrical optics ray equation.\n  - Update the position using the current direction.\n  - Accumulate the geometric path length in meters and the Faraday rotation angle in radians using the derived expressions.\n- Detect arrival at a circular detector of specified radius centered at a given point. Terminate and return when the ray reaches the detector, exits the computational domain, exceeds the maximum number of steps, or encounters a cutoff condition.\n- The angle used to specify the initial direction must be expressed in radians. All distances must be expressed in meters. The Faraday rotation angle must be expressed in radians.\n\nPhysical constants and units:\n- Use the International System of Units (SI) for all quantities. Constants needed include the speed of light $c$, the electron charge $e$, the electron mass $m_e$, and the vacuum permittivity $\\varepsilon_0$.\n\nComputational domain and cutoff handling:\n- Define a rectangular computational domain in $(R,Z)$ and terminate integration upon leaving it. To avoid stepping into non-propagating regions, impose a small positive threshold on the refractive index squared and stop integration once the local refractive index squared is less than or equal to that threshold.\n\nTest suite:\nFor each test case, you must use the provided parameters and produce a tuple of results containing:\n- A boolean indicating whether the detector was reached.\n- A float containing the total path length in meters.\n- A float containing the total Faraday rotation angle in radians.\n\nYour program must run these three test cases:\n\n- Test case $1$ (general propagation with comfortable margin from cutoff, elongated cross-section):\n  - Tokamak parameters: $R_0 = 1.7\\,\\mathrm{m}$, $a = 0.6\\,\\mathrm{m}$, $\\kappa = 1.7$, safety factor $q = 2.0$, toroidal field on axis $B_0 = 2.5\\,\\mathrm{T}$.\n  - Electron density: $n_0 = 6.0\\times 10^{19}\\,\\mathrm{m}^{-3}$, profile exponent $\\alpha = 1.2$, inside plasma: $n_e(\\rho) = n_0\\,(1 - \\rho^2)^\\alpha$ for $\\rho \\leq 1$, outside plasma: $n_e = 0$ for $\\rho  1$.\n  - Probe frequency: $f = 140.0\\times 10^{9}\\,\\mathrm{Hz}$.\n  - Entrance point: $(R,Z) = (2.5\\,\\mathrm{m},\\,0.6\\,\\mathrm{m})$.\n  - Initial direction angle relative to the $+R$ axis: $\\theta_0 = -1.1\\,\\mathrm{rad}$.\n  - Detector center: $(R,Z) = (2.5\\,\\mathrm{m},\\,-0.6\\,\\mathrm{m})$.\n  - Detector radius: $0.05\\,\\mathrm{m}$.\n  - Integration step size: $0.005\\,\\mathrm{m}$.\n  - Maximum number of steps: $20000$.\n  - Refractive index squared cutoff threshold: $10^{-4}$.\n  - Computational domain: $R \\in [0.5\\,\\mathrm{m},\\,3.0\\,\\mathrm{m}]$, $Z \\in [-1.5\\,\\mathrm{m},\\,1.5\\,\\mathrm{m}]$.\n\n- Test case $2$ (attempted propagation near or into cutoff due to lower frequency, expect termination before cutoff or failure to reach detector):\n  - Tokamak parameters: same as test case $1$.\n  - Electron density: same as test case $1$.\n  - Probe frequency: $f = 60.0\\times 10^{9}\\,\\mathrm{Hz}$.\n  - Entrance point: $(R,Z) = (2.5\\,\\mathrm{m},\\,0.0\\,\\mathrm{m})$.\n  - Initial direction angle: $\\theta_0 = 3.141592653589793\\,\\mathrm{rad}$.\n  - Detector center: $(R,Z) = (0.9\\,\\mathrm{m},\\,0.0\\,\\mathrm{m})$.\n  - Detector radius: $0.05\\,\\mathrm{m}$.\n  - Integration step size: $0.005\\,\\mathrm{m}$.\n  - Maximum number of steps: $20000$.\n  - Refractive index squared cutoff threshold: $10^{-4}$.\n  - Computational domain: $R \\in [0.5\\,\\mathrm{m},\\,3.0\\,\\mathrm{m}]$, $Z \\in [-1.5\\,\\mathrm{m},\\,1.5\\,\\mathrm{m}]$.\n\n- Test case $3$ (borderline propagation near cutoff, elongated cross-section):\n  - Tokamak parameters: same as test case $1$.\n  - Electron density: same as test case $1$.\n  - Probe frequency: $f = 80.0\\times 10^{9}\\,\\mathrm{Hz}$.\n  - Entrance point: $(R,Z) = (2.5\\,\\mathrm{m},\\,0.3\\,\\mathrm{m})$.\n  - Initial direction angle: $\\theta_0 = -0.7\\,\\mathrm{rad}$.\n  - Detector center: $(R,Z) = (2.5\\,\\mathrm{m},\\,-0.3\\,\\mathrm{m})$.\n  - Detector radius: $0.05\\,\\mathrm{m}$.\n  - Integration step size: $0.005\\,\\mathrm{m}$.\n  - Maximum number of steps: $20000$.\n  - Refractive index squared cutoff threshold: $10^{-4}$.\n  - Computational domain: $R \\in [0.5\\,\\mathrm{m},\\,3.0\\,\\mathrm{m}]$, $Z \\in [-1.5\\,\\mathrm{m},\\,1.5\\,\\mathrm{m}]$.\n\nMagnetic field specification:\n- Toroidal magnetic field magnitude: $B_\\phi(R) = B_0\\,R_0/R$.\n- Poloidal magnetic field magnitude: for $\\rho \\leq 1$, let $\\epsilon = (\\rho a)/R_0$, and $B_\\theta(R,Z) = B_\\phi(R)\\,\\epsilon/q$. Outside the plasma ($\\rho  1$), use $B_\\theta = 0$.\n- Poloidal magnetic field direction is tangent to flux surfaces in $(R,Z)$.\n\nOutput specification:\n- Your program should produce a single line of output containing the results for the three test cases as a comma-separated list of lists enclosed in square brackets. Each inner list must contain three values in the order: detector reached (boolean), total path length in meters (float), total Faraday rotation in radians (float). For example: $[\\,[\\mathrm{True},\\,1.234,\\,0.056],\\,[\\mathrm{False},\\,0.987,\\,0.012],\\,[\\mathrm{True},\\,1.111,\\,0.034]\\,]$.\n- Angles must be expressed in radians. Distances must be expressed in meters. The Faraday rotation must be expressed in radians.\n\nYour implementation must adhere strictly to the stated assumptions, derive and use the necessary equations from first principles, and execute deterministically on the provided test suite.",
            "solution": "The problem requires the derivation and implementation of a two-dimensional ray tracing model for an Ordinary (O-mode) electromagnetic wave in a tokamak plasma. The model must account for refractive bending due to spatial variations in electron density and the cumulative Faraday rotation of the polarization plane due to the magnetic field. The solution is developed from first principles, namely Maxwell's equations and the cold plasma model, in the high-frequency geometrical optics limit.\n\n### 1. O-Mode Refractive Index\n\nWe begin from the linearized equation of motion for an electron in a cold, magnetized plasma under the influence of a high-frequency electric field $\\mathbf{E}(\\mathbf{r}, t) = \\mathbf{E}(\\mathbf{r}) e^{-i\\omega t}$:\n$$\nm_e \\frac{d\\mathbf{v}}{dt} = -i\\omega m_e \\mathbf{v} = -e(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}_0)\n$$\nwhere $m_e$ is the electron mass, $-e$ is the electron charge, $\\mathbf{v}$ is the electron fluid velocity, $\\omega$ is the wave angular frequency, and $\\mathbf{B}_0$ is the background magnetic field. Solving for $\\mathbf{v}$ and using the definition of plasma current $\\mathbf{J} = -n_e e \\mathbf{v}$, we can find the plasma's relative dielectric tensor $\\boldsymbol{K}$, defined by $\\mathbf{D} = \\varepsilon_0 \\boldsymbol{K} \\mathbf{E}$.\n\nIn the high-frequency limit ($\\omega \\gg \\omega_{ci}$, where $\\omega_{ci}$ is the ion cyclotron frequency), only the electron response is significant. For the O-mode, the wave's electric field is oriented primarily parallel to the background magnetic field. The dispersion relation for the O-mode is notably independent of the magnetic field and is given by:\n$$\nn_O^2 = 1 - \\frac{\\omega_{pe}^2}{\\omega^2}\n$$\nwhere $n_O$ is the refractive index of the O-mode and $\\omega_{pe}$ is the electron plasma frequency, defined as:\n$$\n\\omega_{pe}^2 = \\frac{n_e e^2}{m_e \\varepsilon_0}\n$$\nHere, $n_e$ is the local electron density and $\\varepsilon_0$ is the vacuum permittivity. Propagation is only possible where $n_O^2  0$. The condition $n_O^2 = 0$ defines a cutoff. This occurs when the wave frequency $\\omega$ equals the plasma frequency $\\omega_{pe}$, or equivalently, when the electron density $n_e$ reaches the critical density $n_c$:\n$$\nn_c = \\frac{m_e \\varepsilon_0 \\omega^2}{e^2} = \\frac{4\\pi^2 f^2 m_e \\varepsilon_0}{e^2}\n$$\nThus, the refractive index $n$ (we drop the subscript $O$ for simplicity) at any point $(R,Z)$ is:\n$$\nn(R,Z)^2 = 1 - \\frac{n_e(R,Z)}{n_c}\n$$\nThe electron density $n_e$ is a function of the normalized elliptical minor radius $\\rho$, where $\\rho^2 = (R-R_0)^2/a^2 + Z^2/(\\kappa a)^2$. The profile is given as $n_e(\\rho) = n_0(1-\\rho^2)^\\alpha$ for $\\rho \\le 1$ and $n_e=0$ for $\\rho  1$.\n\n### 2. Ray Tracing Equations\n\nIn the geometrical optics approximation, the ray path $\\mathbf{r}(s)$, parameterized by arc length $s$, is governed by the ray equation:\n$$\n\\frac{d}{ds}\\left(n \\frac{d\\mathbf{r}}{ds}\\right) = \\nabla n\n$$\nLet $\\hat{\\mathbf{s}} = d\\mathbf{r}/ds$ be the unit tangent vector to the ray. Expanding the derivative on the left-hand side gives:\n$$\n\\frac{dn}{ds}\\hat{\\mathbf{s}} + n\\frac{d\\hat{\\mathbf{s}}}{ds} = \\nabla n\n$$\nThe term $dn/ds$ represents the directional derivative of $n$ along the ray, which is $\\nabla n \\cdot \\hat{\\mathbf{s}}$. Substituting this in and rearranging for the ray curvature $d\\hat{\\mathbf{s}}/ds$ yields:\n$$\n\\frac{d\\hat{\\mathbf{s}}}{ds} = \\frac{1}{n}\\left(\\nabla n - (\\nabla n \\cdot \\hat{\\mathbf{s}})\\hat{\\mathbf{s}}\\right) = \\frac{1}{n}(\\nabla n)_\\perp\n$$\nwhere $(\\nabla n)_\\perp$ is the component of the gradient of the refractive index perpendicular to the ray's direction. The system of ordinary differential equations to be integrated is thus:\n$$\n\\frac{d\\mathbf{r}}{ds} = \\hat{\\mathbf{s}} \\quad \\text{and} \\quad \\frac{d\\hat{\\mathbf{s}}}{ds} = \\frac{1}{n}\\left(\\nabla n - (\\hat{\\mathbf{s}} \\cdot \\nabla n)\\hat{\\mathbf{s}}\\right)\n$$\nTo evaluate these, we need the gradient $\\nabla n$. Using the chain rule, $\\nabla n = (dn/d\\rho)\\nabla\\rho$:\n$$\n\\nabla n = \\left( -\\frac{1}{2n n_c} \\frac{dn_e}{d\\rho} \\right) \\nabla\\rho\n$$\nwhere $\\frac{dn_e}{d\\rho} = -2\\alpha\\rho n_0(1-\\rho^2)^{\\alpha-1}$ for $\\rho \\le 1$. The gradient of $\\rho$ is $\\nabla\\rho = \\frac{1}{\\rho}\\left(\\frac{R-R_0}{a^2}\\hat{\\mathbf{R}} + \\frac{Z}{(\\kappa a)^2}\\hat{\\mathbf{Z}}\\right)$. Combining these terms, we obtain a form for $\\nabla n$ that is well-behaved as $\\rho \\to 0$:\n$$\n\\nabla n = \\frac{\\alpha n_0 (1-\\rho^2)^{\\alpha-1}}{n n_c}\\left(\\frac{R-R_0}{a^2}\\hat{\\mathbf{R}} + \\frac{Z}{(\\kappa a)^2}\\hat{\\mathbf{Z}}\\right)\n$$\nOutside the plasma ($\\rho1$), $n_e=0$, so $n=1$ and $\\nabla n=0$, resulting in straight-line propagation.\n\n### 3. Faraday Rotation\n\nFaraday rotation is the rotation of the polarization plane of a linearly polarized wave as it propagates through a magnetized plasma. This arises from the difference in refractive indices for the right-hand ($n_R$) and left-hand ($n_L$) circularly polarized components of the wave. The accumulated rotation angle $\\theta_F$ over a path length $s$ is:\n$$\n\\theta_F = \\frac{1}{2}\\Delta\\phi = \\frac{\\omega}{2c}\\int_0^s (n_L - n_R) ds'\n$$\nIn the high-frequency limit ($\\omega \\gg \\omega_{pe}, \\omega_{ce}$), and for quasi-longitudinal propagation (where the angle between the wavevector $\\mathbf{k}$ and $\\mathbf{B}_0$ is not close to $\\pi/2$), the difference in refractive indices can be approximated as:\n$$\nn_L - n_R \\approx \\frac{\\omega_{pe}^2 \\omega_{ce,\\parallel}}{\\omega^3} = \\frac{n_e e^2}{m_e\\varepsilon_0 \\omega^3} \\frac{e B_\\parallel}{m_e}\n$$\nwhere $B_\\parallel = \\mathbf{B}_0 \\cdot \\hat{\\mathbf{s}}$ is the component of the magnetic field along the ray path. The differential rotation is therefore:\n$$\n\\frac{d\\theta_F}{ds} = \\frac{\\omega}{2c}(n_L - n_R) = \\frac{e^3}{2c m_e^2 \\varepsilon_0 \\omega^2} n_e (\\mathbf{B}_0 \\cdot \\hat{\\mathbf{s}})\n$$\nThis expression is integrated along the ray path calculated previously. The total magnetic field is $\\mathbf{B}_0 = \\mathbf{B}_\\phi + \\mathbf{B}_\\theta$. As the ray propagates in the $(R,Z)$ plane, the ray direction vector $\\hat{\\mathbf{s}}$ is orthogonal to the toroidal magnetic field $\\mathbf{B}_\\phi$, so $\\mathbf{B}_\\phi \\cdot \\hat{\\mathbf{s}} = 0$. The parallel component thus reduces to $B_\\parallel = \\mathbf{B}_\\theta \\cdot \\hat{\\mathbf{s}}$.\nThe poloidal magnetic field vector $\\mathbf{B}_\\theta$ has magnitude $B_\\theta(R,Z)$ and is tangent to the elliptical flux surfaces. A tangent vector $\\hat{\\mathbf{t}}_\\theta$ is orthogonal to the surface normal $\\nabla\\rho$. We adopt a counter-clockwise convention for the direction of $\\mathbf{B}_\\theta$, yielding the tangent vector $\\mathbf{t}_{unnorm} = -Z/(\\kappa^2)\\hat{\\mathbf{R}} + (R-R_0)\\hat{\\mathbf{Z}}$ (scaled by $1/a^2$). Then $\\mathbf{B}_\\theta = B_\\theta \\hat{\\mathbf{t}}_\\theta$, where $\\hat{\\mathbf{t}}_\\theta$ is the normalized tangent vector.\n\n### 4. Numerical Implementation\n\nThe ray tracing is performed using a fixed-step Euler integrator.\n1.  **State Vector**: The system state at each step $i$ is described by the position $\\mathbf{r}_i=(R_i, Z_i)$ and the direction vector $\\hat{\\mathbf{s}}_i=(s_{R,i}, s_{Z,i})$.\n2.  **Initialization**: The ray starts at a given point $\\mathbf{r}_0$ with an initial direction $\\hat{\\mathbf{s}}_0 = (\\cos\\theta_0, \\sin\\theta_0)$. The path length $L$ and Faraday angle $\\theta_F$ are initialized to $0$.\n3.  **Integration Loop**: For each step of size $ds$:\n    a.  Calculate local plasma parameters: $\\rho$, $n_e$, $n$, and $\\nabla n$ at the current position $\\mathbf{r}_i$.\n    b.  Check for cutoff: if $n^2 \\le n^2_{thresh}$, terminate.\n    c.  Update position: $\\mathbf{r}_{i+1} = \\mathbf{r}_i + \\hat{\\mathbf{s}}_i ds$.\n    d.  Update direction: $d\\hat{\\mathbf{s}}/ds$ is computed, then $\\hat{\\mathbf{s}}_{i+1} = \\hat{\\mathbf{s}}_i + (d\\hat{\\mathbf{s}}/ds)ds$. The new vector $\\hat{\\mathbf{s}}_{i+1}$ is re-normalized.\n    e.  Accumulate path length: $L_{i+1} = L_i + ds$.\n    f.  Accumulate Faraday rotation: $d\\theta_F = K_F n_{e,i} (\\mathbf{B}_{\\theta,i} \\cdot \\hat{\\mathbf{s}}_i) ds$ is calculated and added to the total $\\theta_F$.\n4.  **Termination**: The loop terminates if the ray reaches the detector, leaves the computational domain, exceeds the maximum number of steps, or encounters a cutoff. The final results are then reported.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a 2D ray tracing model for an O-mode beam in a tokamak plasma.\n    \"\"\"\n    \n    # Physical Constants (SI units)\n    C = 299792458.0  # Speed of light in vacuum\n    M_E = 9.10938356e-31  # Electron mass\n    E_CHARGE = 1.602176634e-19  # Electron charge\n    EPSILON_0 = 8.854187817e-12  # Vacuum permittivity\n\n    def trace_ray(params):\n        # Unpack parameters\n        R0, a, kappa, q_val, B0 = params['tokamak']\n        n0, alpha = params['density']\n        f = params['frequency']\n        r_start, theta0 = params['beam_start']\n        r_det_center, det_radius = params['detector']\n        ds, max_steps = params['integration']\n        n2_thresh = params['cutoff_threshold']\n        R_domain, Z_domain = params['domain']\n\n        # Pre-calculate constants for this run\n        omega = 2.0 * np.pi * f\n        n_crit = M_E * EPSILON_0 * omega**2 / E_CHARGE**2\n        # Faraday rotation constant K_F for d(theta_F)/ds = K_F * n_e * B_parallel\n        K_F = E_CHARGE**3 / (2.0 * C * M_E**2 * EPSILON_0 * omega**2)\n\n        # Initialize state\n        r = np.array(r_start, dtype=float)\n        s_hat = np.array([np.cos(theta0), np.sin(theta0)], dtype=float)\n        path_length = 0.0\n        faraday_rotation = 0.0\n        \n        a2 = a**2\n        kappa2_a2 = (kappa * a)**2\n\n        for step in range(max_steps):\n            R, Z = r[0], r[1]\n            \n            # 1. Termination checks (pre-step)\n            # Detector hit\n            if np.linalg.norm(r - r_det_center) = det_radius:\n                return [True, path_length, faraday_rotation]\n            # Domain exit\n            if not (R_domain[0] = R = R_domain[1] and Z_domain[0] = Z = Z_domain[1]):\n                return [False, path_length, faraday_rotation]\n\n            # 2. Calculate local plasma properties\n            rho2 = (R - R0)**2 / a2 + Z**2 / kappa2_a2\n            \n            if rho2  1.0:\n                rho = np.sqrt(rho2)\n                ne = 0.0\n            else:\n                rho = np.sqrt(rho2)\n                ne = n0 * (1.0 - rho2)**alpha\n            \n            n_squared = 1.0 - ne / n_crit\n\n            # 3. Cutoff check\n            if n_squared = n2_thresh:\n                return [False, path_length, faraday_rotation]\n            \n            n = np.sqrt(n_squared)\n            \n            # 4. Calculate gradient of refractive index\n            if ne == 0.0 or rho  1e-9:\n                grad_n = np.array([0.0, 0.0])\n            else:\n                term1 = alpha * n0 * (1.0 - rho2)**(alpha - 1.0) / (n * n_crit)\n                grad_n_R = term1 * (R - R0) / a2\n                grad_n_Z = term1 * Z / kappa2_a2\n                grad_n = np.array([grad_n_R, grad_n_Z])\n\n            # 5. Accumulate Faraday Rotation\n            if ne  0:\n                # Poloidal magnetic field\n                B_phi = B0 * R0 / R\n                epsilon_r = rho * a / R0\n                B_theta_mag = B_phi * epsilon_r / q_val\n\n                # Poloidal field direction (counter-clockwise tangent)\n                # t_unnorm = (-Z / kappa, kappa * (R - R0))\n                # This form from parameterizing the ellipse is more robust near R0.\n                t_unnorm_R = -Z / kappa\n                t_unnorm_Z = kappa * (R - R0)\n                norm_t = np.sqrt(t_unnorm_R**2 + t_unnorm_Z**2)\n                \n                if norm_t  1e-9:\n                    # B_parallel = B_theta . s_hat\n                    B_parallel = B_theta_mag * (t_unnorm_R * s_hat[0] + t_unnorm_Z * s_hat[1]) / norm_t\n                else:\n                    B_parallel = 0.0\n                \n                d_theta_F = K_F * ne * B_parallel * ds\n                faraday_rotation += d_theta_F\n            \n            # 6. Update direction (Euler step)\n            s_dot_grad_n = np.dot(s_hat, grad_n)\n            ds_hat_ds = (1.0 / n) * (grad_n - s_dot_grad_n * s_hat)\n            s_hat_new = s_hat + ds_hat_ds * ds\n            s_hat = s_hat_new / np.linalg.norm(s_hat_new)\n\n            # 7. Update position (using PRE-UPDATE direction)\n            r = r + s_hat * ds\n            path_length += ds\n\n        # Max steps reached\n        return [False, path_length, faraday_rotation]\n\n    test_cases = [\n        # Test case 1\n        {\n            \"tokamak\": (1.7, 0.6, 1.7, 2.0, 2.5),\n            \"density\": (6.0e19, 1.2),\n            \"frequency\": 140.0e9,\n            \"beam_start\": ((2.5, 0.6), -1.1),\n            \"detector\": (np.array([2.5, -0.6]), 0.05),\n            \"integration\": (0.005, 20000),\n            \"cutoff_threshold\": 1.0e-4,\n            \"domain\": ([0.5, 3.0], [-1.5, 1.5]),\n        },\n        # Test case 2\n        {\n            \"tokamak\": (1.7, 0.6, 1.7, 2.0, 2.5),\n            \"density\": (6.0e19, 1.2),\n            \"frequency\": 60.0e9,\n            \"beam_start\": ((2.5, 0.0), np.pi),\n            \"detector\": (np.array([0.9, 0.0]), 0.05),\n            \"integration\": (0.005, 20000),\n            \"cutoff_threshold\": 1.0e-4,\n            \"domain\": ([0.5, 3.0], [-1.5, 1.5]),\n        },\n        # Test case 3\n        {\n            \"tokamak\": (1.7, 0.6, 1.7, 2.0, 2.5),\n            \"density\": (6.0e19, 1.2),\n            \"frequency\": 80.0e9,\n            \"beam_start\": ((2.5, 0.3), -0.7),\n            \"detector\": (np.array([2.5, -0.3]), 0.05),\n            \"integration\": (0.005, 20000),\n            \"cutoff_threshold\": 1.0e-4,\n            \"domain\": ([0.5, 3.0], [-1.5, 1.5]),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = trace_ray(case)\n        results.append(f\"[{result[0]},{result[1]:.7f},{result[2]:.7f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once a probe beam reaches the detector, the raw signal is invariably corrupted by noise. A common and powerful technique to improve the signal quality is coherent averaging, but this comes at a cost. This practice delves into the crucial trade-off between improving the signal-to-noise ratio ($SNR$) and sacrificing the temporal resolution needed to observe fast-changing plasma events.",
            "id": "3704245",
            "problem": "A microwave heterodyne interferometer for nuclear fusion plasma diagnostics measures the line-integrated electron density via the phase of a probe beam mixed with a local oscillator detuned to produce a beat at frequency $f_b$. The demodulated complex signal is modeled as $x(t) = \\phi(t) + w(t)$, where $\\phi(t)$ is the true plasma phase and $w(t)$ is additive white Gaussian noise (Additive White Gaussian Noise (AWGN)) that is zero-mean, statistically independent across successive beat cycles, and stationary over the averaging interval. To improve the Signal-to-Noise Ratio (SNR), the data processing applies coherent averaging of the complex demodulated samples over $N$ consecutive cycles of the beat, equivalently a rectangular moving average of duration $T_{\\text{avg}} = N/f_b$.\n\nAssume the line-averaged electron density has a small sinusoidal fluctuation superposed on a slowly varying background such that the phase can be written $\\phi(t) = \\phi_0 + \\Delta \\phi \\cos(2\\pi f_{\\text{var}} t)$, with fluctuation frequency $f_{\\text{var}}$. The estimator of $\\phi(t)$ is the moving-average output $y(t) = \\frac{1}{T_{\\text{avg}}} \\int_{t - T_{\\text{avg}}}^{t} x(\\tau)\\, d\\tau$.\n\nGiven $f_b = 2.0 \\times 10^{6}$ Hz, $N = 100$, and $f_{\\text{var}} = 1.0 \\times 10^{4}$ Hz:\n\n- Compute the SNR improvement factor (in power) achieved by coherent averaging relative to the unaveraged estimator, under the assumption that $w(t)$ is independent across beat cycles.\n- Quantify the trade-off in temporal resolution by computing the amplitude attenuation of the sinusoidal fluctuation at frequency $f_{\\text{var}}$ introduced by the averaging window, i.e., the magnitude of the filter’s frequency response at angular frequency $\\omega_{\\text{var}} = 2\\pi f_{\\text{var}}$.\n\nExpress the final answer as a row matrix with the two dimensionless numbers in the order $[$SNR improvement factor, amplitude attenuation$]$. Round your answer to four significant figures. The amplitude attenuation is an amplitude ratio (dimensionless). The SNR improvement factor is dimensionless.",
            "solution": "The problem is well-posed and scientifically grounded. It requires the application of fundamental principles of signal processing to a realistic scenario in plasma diagnostics. We will address the two parts of the problem in sequence.\n\nPart 1: SNR Improvement Factor\n\nThe signal-to-noise ratio (SNR) in power is defined as the ratio of the signal power to the noise power. The improvement factor is the ratio of the SNR after averaging to the SNR before averaging.\nLet the demodulated signal be $x(t) = \\phi(t) + w(t)$, where $\\phi(t)$ is the desired signal (plasma phase) and $w(t)$ is additive white Gaussian noise (AWGN).\n\nThe \"unaveraged estimator\" can be considered as a single sample of the noisy signal taken over one beat cycle. Let the variance of the noise component of this single sample be $\\sigma_w^2$. This corresponds to the input noise power, $P_{n, \\text{in}} = \\sigma_w^2$. Let the signal power be $P_{s, \\text{in}}$. The input SNR is $SNR_{\\text{in}} = P_{s, \\text{in}} / P_{n, \\text{in}}$.\n\nThe problem states that coherent averaging is applied over $N$ consecutive cycles of the beat. The noise $w(t)$ is specified as being \"statistically independent across successive beat cycles\". This allows us to model the noise components of $N$ consecutive samples, $w_1, w_2, \\dots, w_N$, as independent and identically distributed (i.i.d.) random variables, each with zero mean and variance $\\sigma_w^2$.\n\nThe averaging process computes the arithmetic mean of these $N$ samples. The resulting noise component is $w_{\\text{avg}} = \\frac{1}{N} \\sum_{i=1}^{N} w_i$. The variance of this averaged noise is the output noise power, $P_{n, \\text{out}}$. Due to the independence of the samples:\n$$P_{n, \\text{out}} = \\text{Var}(w_{\\text{avg}}) = \\text{Var}\\left(\\frac{1}{N} \\sum_{i=1}^{N} w_i\\right) = \\frac{1}{N^2} \\sum_{i=1}^{N} \\text{Var}(w_i) = \\frac{1}{N^2} (N \\sigma_w^2) = \\frac{\\sigma_w^2}{N}$$\nSo, the noise power is reduced by a factor of $N$:\n$$P_{n, \\text{out}} = \\frac{P_{n, \\text{in}}}{N}$$\n\"Coherent averaging\" implies that the signal component, which is slowly varying compared to the beat frequency, adds constructively. For a nearly constant signal over the averaging period $T_{\\text{avg}}$, the averaging process preserves the signal amplitude. Thus, the output signal power $P_{s, \\text{out}}$ is approximately equal to the input signal power $P_{s, \\text{in}}$.\n\nThe output SNR is $SNR_{\\text{out}} = P_{s, \\text{out}} / P_{n, \\text{out}}$.\nThe SNR improvement factor, $I_{SNR}$, is:\n$$I_{SNR} = \\frac{SNR_{\\text{out}}}{SNR_{\\text{in}}} = \\frac{P_{s, \\text{out}}/P_{n, \\text{out}}}{P_{s, \\text{in}}/P_{n, \\text{in}}} = \\left(\\frac{P_{s, \\text{out}}}{P_{s, \\text{in}}}\\right) \\left(\\frac{P_{n, \\text{in}}}{P_{n, \\text{out}}}\\right)$$\nSubstituting the relationships for power, we get:\n$$I_{SNR} \\approx (1) \\left(\\frac{P_{n, \\text{in}}}{P_{n, \\text{in}}/N}\\right) = N$$\nGiven $N=100$, the SNR improvement factor is exactly $100$. Expressed to four significant figures, this is $100.0$.\n\nPart 2: Amplitude Attenuation\n\nThe estimator is defined as a moving-average filter:\n$$y(t) = \\frac{1}{T_{\\text{avg}}} \\int_{t - T_{\\text{avg}}}^{t} x(\\tau)\\, d\\tau$$\nThis operation is a convolution of the input signal $x(t)$ with a rectangular impulse response $h(t)$, where:\n$$h(t) = \\begin{cases} 1/T_{\\text{avg}}  \\text{if } 0 \\le t \\le T_{\\text{avg}} \\\\ 0  \\text{otherwise} \\end{cases}$$\nThe amplitude attenuation of a sinusoidal component is given by the magnitude of the filter's frequency response, $H(\\omega) = \\mathcal{F}\\{h(t)\\}$, evaluated at the frequency of the sinusoid. The frequency response is the Fourier transform of the impulse response:\n$$H(\\omega) = \\int_{-\\infty}^{\\infty} h(t) \\exp(-i\\omega t) \\,dt = \\frac{1}{T_{\\text{avg}}} \\int_{0}^{T_{\\text{avg}}} \\exp(-i\\omega t) \\,dt$$\n$$H(\\omega) = \\frac{1}{T_{\\text{avg}}} \\left[ \\frac{\\exp(-i\\omega t)}{-i\\omega} \\right]_{0}^{T_{\\text{avg}}} = \\frac{1}{T_{\\text{avg}}} \\frac{\\exp(-i\\omega T_{\\text{avg}}) - 1}{-i\\omega}$$\nTo find the magnitude, we can rewrite this expression:\n$$H(\\omega) = \\frac{\\exp(-i\\omega T_{\\text{avg}}/2)}{-i\\omega T_{\\text{avg}}} \\left( \\exp(-i\\omega T_{\\text{avg}}/2) - \\exp(i\\omega T_{\\text{avg}}/2) \\right)$$\n$$H(\\omega) = \\frac{\\exp(-i\\omega T_{\\text{avg}}/2)}{-i\\omega T_{\\text{avg}}} \\left( -2i \\sin(\\omega T_{\\text{avg}}/2) \\right) = \\exp(-i\\omega T_{\\text{avg}}/2) \\frac{\\sin(\\omega T_{\\text{avg}}/2)}{\\omega T_{\\text{avg}}/2}$$\nThe amplitude attenuation is the magnitude of this complex function:\n$$|H(\\omega)| = \\left| \\exp(-i\\omega T_{\\text{avg}}/2) \\right| \\left| \\frac{\\sin(\\omega T_{\\text{avg}}/2)}{\\omega T_{\\text{avg}}/2} \\right| = \\left| \\frac{\\sin(\\omega T_{\\text{avg}}/2)}{\\omega T_{\\text{avg}}/2} \\right|$$\nThis is the magnitude of the normalized sinc function. We need to evaluate this at the fluctuation's angular frequency $\\omega_{\\text{var}} = 2\\pi f_{\\text{var}}$. The averaging time is $T_{\\text{avg}} = N/f_b$.\nThe argument of the function becomes:\n$$\\frac{\\omega_{\\text{var}} T_{\\text{avg}}}{2} = \\frac{(2\\pi f_{\\text{var}})(N/f_b)}{2} = \\frac{\\pi N f_{\\text{var}}}{f_b}$$\nSubstituting the given values:\n$N = 100$, $f_{\\text{var}} = 1.0 \\times 10^4$ Hz, and $f_b = 2.0 \\times 10^6$ Hz.\n$$\\frac{\\pi N f_{\\text{var}}}{f_b} = \\frac{\\pi \\times 100 \\times (1.0 \\times 10^4)}{2.0 \\times 10^6} = \\frac{\\pi \\times 10^2 \\times 10^4}{2 \\times 10^6} = \\frac{\\pi \\times 10^6}{2 \\times 10^6} = \\frac{\\pi}{2}$$\nThe amplitude attenuation is therefore:\n$$|H(\\omega_{\\text{var}})| = \\left| \\frac{\\sin(\\pi/2)}{\\pi/2} \\right| = \\frac{1}{\\pi/2} = \\frac{2}{\\pi}$$\nNow, we compute the numerical value and round to four significant figures:\n$$\\frac{2}{\\pi} \\approx 0.63661977...$$\nTo four significant figures, the amplitude attenuation is $0.6366$.\n\nThe final answer is a row matrix containing the SNR improvement factor ($100.0$) and the amplitude attenuation ($0.6366$).",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n100.0  0.6366\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The ultimate purpose of a multi-chord diagnostic system is to reconstruct the spatial distribution of a plasma quantity, such as the electron density $n_e$. This task requires solving an inverse problem, turning a set of line-integrated measurements into a 2D profile. In this exercise, you will formulate and implement a tomographic inversion based on Tikhonov regularization, a robust and widely-used method to obtain stable and physically meaningful solutions from experimental data.",
            "id": "3704205",
            "problem": "You are tasked with formulating and implementing a discretized tomographic inversion for non-axisymmetric plasma observables measured by interferometry and polarimetry. Start from fundamental physical relations and core definitions for line-of-sight diagnostics in plasmas and derive the conditions that a least-squares minimizer must satisfy when regularized by Tikhonov regularization. Then implement the resulting normal equations to recover voxelized fields from synthetic multi-chord data. All quantities must be treated in the International System of Units (SI).\n\nThe foundational base for this problem is the following widely accepted facts:\n- For electromagnetic waves traversing a magnetized plasma with electron number density $n_e(\\mathbf{r})$ and magnetic field $\\mathbf{B}(\\mathbf{r})$, the interferometric phase shift along a chord is well approximated (in the high-frequency approximation) by a line integral of $n_e$ times a known proportionality constant, which we will absorb into a scaling to deliver an effective line-integrated electron column with units $\\mathrm{m}^{-2}$.\n- The Faraday rotation of polarization (in radians) along a chord is well approximated (again in the high-frequency approximation) by a line integral of the product $n_e B_{\\parallel}$ times a known proportionality constant. We will absorb this constant into a scaling to deliver an effective line-integrated $n_e B_{\\parallel}$ with units $\\mathrm{T}\\cdot\\mathrm{m}^{-2}$. Use radians for angles.\n\nDiscretize a two-dimensional cross-section into rectangular voxels with piecewise-constant unknowns. For each chord $m$, the measurement is modeled by a weighted sum of the voxel values with weights equal to the path length in each voxel, producing the linear model $A x \\approx y$, where:\n- $A \\in \\mathbb{R}^{M \\times N}$ is the geometry matrix of path lengths (in $\\mathrm{m}$),\n- $x \\in \\mathbb{R}^{N}$ is the vector of unknown voxel values (either $n_e$ in $\\mathrm{m}^{-3}$ or $n_e B_{\\parallel}$ in $\\mathrm{T}\\cdot\\mathrm{m}^{-3}$),\n- $y \\in \\mathbb{R}^{M}$ is the vector of effective line-integrated measurements (either $\\mathrm{m}^{-2}$ or $\\mathrm{T}\\cdot\\mathrm{m}^{-2}$).\n\nTo stabilize the inversion for non-axisymmetric and possibly underdetermined geometries, use Tikhonov regularization with an operator $L \\in \\mathbb{R}^{P \\times N}$ (for example, first-order finite differences to promote smoothness, or the identity for ridge regression), and a prior $x_0 \\in \\mathbb{R}^{N}$.\n\nTask 1 (Derivation):\n- From first principles of least-squares optimization, and without using any shortcut formulas, derive the normal equations that the minimizer of the Tikhonov-regularized problem must satisfy when minimizing an objective formed by the data misfit and a quadratic penalty on $L(x - x_0)$ under the Euclidean norm. Clearly state all assumptions and demonstrate each logical step.\n\nTask 2 (Implementation):\n- Implement a program that, for each test case described below, constructs the matrices and vectors, solves the derived normal equations for $x$, and outputs the recovered voxel values. Your solver must handle a general rectangular $L$ and a general $A$, and must not rely on any external libraries beyond those specified.\n- Express recovered electron densities in $\\mathrm{m}^{-3}$ and recovered $n_e B_{\\parallel}$ in $\\mathrm{T}\\cdot\\mathrm{m}^{-3}$.\n- For all outputs, present numbers rounded to three significant figures.\n- Angles (where relevant to the underlying physics) must be treated in radians.\n\nTest Suite:\nAll matrices and vectors are given explicitly; each number is provided in SI units. Each test case specifies a geometry $A$, a regularization operator $L$, a regularization strength $\\lambda$ (in $\\mathrm{m}$), a prior $x_0$ (zero in all cases), and a measurement vector $y$.\n\nIndexing convention for voxel ordering is row-major in a $3\\times 3$ grid for Test Cases $1$ and $2$:\n$\n\\begin{bmatrix}\n0  1  2 \\\\\n3  4  5 \\\\\n6  7  8\n\\end{bmatrix}\n$,\nand row-major in a $2\\times 2$ grid for Test Cases $3$ and $4$:\n$\n\\begin{bmatrix}\n0  1 \\\\\n2  3\n\\end{bmatrix}\n$.\n\n- Test Case 1 (Interferometry, non-axisymmetric, smoothness regularization):\n  - Geometry $A \\in \\mathbb{R}^{6 \\times 9}$ with rows representing chords:\n    1. Middle horizontal through voxels $[3,4,5]$ with lengths $[0.01,0.01,0.01]$ $\\mathrm{m}$.\n    2. Right vertical through voxels $[2,5,8]$ with lengths $[0.01,0.01,0.01]$ $\\mathrm{m}$.\n    3. Top-left to bottom-right diagonal through voxels $[0,4,8]$ with lengths $[0.01414,0.01414,0.01414]$ $\\mathrm{m}$.\n    4. Top-right to bottom-left diagonal through voxels $[2,4,6]$ with lengths $[0.01414,0.01414,0.01414]$ $\\mathrm{m}$.\n    5. Top horizontal through voxels $[0,1,2]$ with lengths $[0.01,0.01,0.01]$ $\\mathrm{m}$.\n    6. Middle vertical through voxels $[1,4,7]$ with lengths $[0.01,0.01,0.01]$ $\\mathrm{m}$.\n    Explicitly:\n    $\n    A = \\begin{bmatrix}\n    0  0  0  0.01  0.01  0.01  0  0  0 \\\\\n    0  0  0.01  0  0  0.01  0  0  0.01 \\\\\n    0.01414  0  0  0  0.01414  0  0  0  0.01414 \\\\\n    0  0  0.01414  0  0.01414  0  0.01414  0  0 \\\\\n    0.01  0.01  0.01  0  0  0  0  0  0 \\\\\n    0  0.01  0  0  0.01  0  0.01  0  0\n    \\end{bmatrix}.\n    $\n  - Regularization operator $L \\in \\mathbb{R}^{12 \\times 9}$ of first-order differences on the $3\\times 3$ grid, with rows:\n    Horizontal differences:\n    $\n    [1,-1,0,0,0,0,0,0,0],\\ [0,1,-1,0,0,0,0,0,0],\\\n    [0,0,0,1,-1,0,0,0,0],\\ [0,0,0,0,1,-1,0,0,0],\\\n    [0,0,0,0,0,0,1,-1,0],\\ [0,0,0,0,0,0,0,1,-1]\n    $,\n    Vertical differences:\n    $\n    [1,0,0,-1,0,0,0,0,0],\\ [0,1,0,0,-1,0,0,0,0],\\\n    [0,0,1,0,0,-1,0,0,0],\\ [0,0,0,1,0,0,-1,0,0],\\\n    [0,0,0,0,1,0,0,-1,0],\\ [0,0,0,0,0,1,0,0,-1].\n    $\n  - Regularization strength $\\lambda = 0.02$ $\\mathrm{m}$, prior $x_0 = \\mathbf{0}$.\n  - Measurement vector $y$ in $\\mathrm{m}^{-2}$:\n    $\n    y = [4.5\\times 10^{17},\\ 2.5\\times 10^{17},\\ 5.656\\times 10^{17},\\ 6.0802\\times 10^{17},\\ 3.2\\times 10^{17},\\ 4.8\\times 10^{17}].\n    $\n\n  The recovered $x$ must be in $\\mathrm{m}^{-3}$.\n\n- Test Case 2 (Polarimetry, non-axisymmetric, identity regularization):\n  - Geometry $A \\in \\mathbb{R}^{6 \\times 9}$ identical to Test Case $1$.\n  - Regularization operator $L = I_{9}$ (identity), $\\lambda = 0.03$ $\\mathrm{m}$, prior $x_0 = \\mathbf{0}$.\n  - Measurement vector $y$ is the effective line-integrated $n_e B_{\\parallel}$ in $\\mathrm{T}\\cdot\\mathrm{m}^{-2}$:\n    $\n    y = [7.5\\times 10^{17},\\ 5.2\\times 10^{17},\\ 1.15948\\times 10^{18},\\ 9.898\\times 10^{17},\\ 6.5\\times 10^{17},\\ 8.5\\times 10^{17}].\n    $\n  The recovered $x$ must be $n_e B_{\\parallel}$ in $\\mathrm{T}\\cdot\\mathrm{m}^{-3}$.\n\n- Test Case 3 (Interferometry, underdetermined $2\\times 2$ grid, identity regularization):\n  - Geometry $A \\in \\mathbb{R}^{3 \\times 4}$:\n    $\n    A = \\begin{bmatrix}\n    0.01  0.01  0  0 \\\\\n    0.01  0  0.01  0 \\\\\n    0.01414  0  0  0.01414\n    \\end{bmatrix}.\n    $\n  - Regularization operator $L = I_{4}$, $\\lambda = 0.005$ $\\mathrm{m}$, prior $x_0 = \\mathbf{0}$.\n  - Measurement vector $y$ in $\\mathrm{m}^{-2}$:\n    $\n    y = [2.7\\times 10^{17},\\ 3.2\\times 10^{17},\\ 3.535\\times 10^{17}].\n    $\n  The recovered $x$ must be in $\\mathrm{m}^{-3}$.\n\n- Test Case 4 (Interferometry, same as Test Case 3 with strong regularization):\n  - Geometry $A$ and $L$ identical to Test Case $3$.\n  - $\\lambda = 1.0$ $\\mathrm{m}$, prior $x_0 = \\mathbf{0}$.\n  - Measurement vector $y$ identical to Test Case $3$.\n  The recovered $x$ must be in $\\mathrm{m}^{-3}$.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a comma-separated list of the recovered voxel values rounded to three significant figures and formatted in scientific notation. There must be no spaces anywhere in the output. For example: $[ [\\dots], [\\dots], [\\dots], [\\dots] ]$ but with no spaces: \"[[case1_values],[case2_values],[case3_values],[case4_values]]\".",
            "solution": "The problem requires the derivation and implementation of a solution to a Tikhonov-regularized linear inverse problem, which is a standard approach for tomographic reconstruction in plasma physics. The process is divided into two tasks: first, deriving the normal equations from first principles, and second, implementing a numerical solver for these equations based on the provided test cases.\n\n### Task 1: Derivation of the Normal Equations\n\nThe problem is to find a vector of voxel values, $x \\in \\mathbb{R}^{N}$, that best represents the plasma's state given a set of line-integrated measurements, $y \\in \\mathbb{R}^{M}$. The relationship between the unknowns and the measurements is modeled by the linear system $Ax \\approx y$, where $A \\in \\mathbb{R}^{M \\times N}$ is the geometry matrix containing the path lengths of measurement chords through each voxel.\n\nDue to the ill-posed nature of many tomographic problems (e.g., being underdetermined or having an ill-conditioned matrix $A$), we introduce Tikhonov regularization to stabilize the solution. The goal is to find the vector $x$ that minimizes a composite objective function, $J(x)$, which includes both a data-fidelity term and a regularization term.\n\nThe objective function $J(x)$ is defined as the sum of the squared Euclidean norm of the data misfit and the squared Euclidean norm of a regularized term:\n$$ J(x) = \\|Ax - y\\|_2^2 + \\alpha \\|L(x - x_0)\\|_2^2 $$\nHere, $L \\in \\mathbb{R}^{P \\times N}$ is the regularization operator, $x_0 \\in \\mathbb{R}^{N}$ is a prior estimate of the solution, and $\\alpha$ is a scalar regularization parameter that balances the two terms.\n\nThe problem specifies a regularization strength $\\lambda$ with units of length (meters, $\\mathrm{m}$). To ensure dimensional consistency in the objective function, we must set the parameter $\\alpha$ appropriately. Let's analyze the units for an interferometry case:\n- The measurement vector $y$ has units of $\\mathrm{m}^{-2}$. Thus, the data misfit term $\\|Ax - y\\|_2^2$ has units of $(\\mathrm{m}^{-2})^2 = \\mathrm{m}^{-4}$.\n- The unknown vector $x$ has units of $\\mathrm{m}^{-3}$. If the regularization operator $L$ is dimensionless (like the identity or a finite-difference operator), then the regularization term $\\|L(x - x_0)\\|_2^2$ has units of $(\\mathrm{m}^{-3})^2 = \\mathrm{m}^{-6}$.\n\nFor the two terms to be commensurate, $\\alpha$ must have units of $\\mathrm{m}^2$. Given $\\lambda$ in meters, a natural and common choice is $\\alpha = \\lambda^2$. The objective function is thus:\n$$ J(x) = \\|Ax - y\\|_2^2 + \\lambda^2 \\|L(x - x_0)\\|_2^2 $$\n\nTo find the vector $x$ that minimizes this function, we must find where the gradient of $J(x)$ with respect to $x$ is the zero vector. First, we express the squared norms as dot products using the transpose notation, where for a vector $v$, $\\|v\\|_2^2 = v^T v$:\n$$ J(x) = (Ax - y)^T(Ax - y) + \\lambda^2 (L(x - x_0))^T(L(x - x_0)) $$\n\nExpanding these terms:\n$$ J(x) = (x^T A^T - y^T)(Ax - y) + \\lambda^2 (x - x_0)^T L^T L (x - x_0) $$\n$$ J(x) = (x^T A^T Ax - x^T A^T y - y^T A x + y^T y) + \\lambda^2 (x^T L^T L x - x^T L^T L x_0 - x_0^T L^T L x + x_0^T L^T L x_0) $$\n\nRecognizing that the scalar terms $y^T A x$ and $x_0^T L^T L x$ are equal to their transposes $x^T A^T y$ and $x^T L^T L x_0$ respectively, we can simplify the expression:\n$$ J(x) = x^T (A^T A) x - 2 y^T A x + y^T y + \\lambda^2 [x^T (L^T L) x - 2 x_0^T L^T L x + x_0^T L^T L x_0] $$\n\nNow, we compute the gradient $\\nabla_x J(x) = \\frac{\\partial J(x)}{\\partial x}$ using standard matrix calculus identities: $\\frac{\\partial}{\\partial x} (c^T x) = c$ and $\\frac{\\partial}{\\partial x} (x^T M x) = (M + M^T)x$. Since both $A^T A$ and $L^T L$ are symmetric matrices, the derivatives of the quadratic terms simplify to $2(A^T A)x$ and $2(L^T L)x$.\n\nTaking the derivative of each term in $J(x)$ with respect to $x$:\n- $\\frac{\\partial}{\\partial x} (x^T (A^T A) x) = 2(A^T A)x$\n- $\\frac{\\partial}{\\partial x} (-2 y^T A x) = -2 A^T y$\n- $\\frac{\\partial}{\\partial x} (y^T y) = 0$ (constant with respect to $x$)\n- $\\frac{\\partial}{\\partial x} (\\lambda^2 x^T (L^T L) x) = 2 \\lambda^2 (L^T L)x$\n- $\\frac{\\partial}{\\partial x} (-2 \\lambda^2 x_0^T L^T L x) = -2 \\lambda^2 (L^T L)x_0$\n- $\\frac{\\partial}{\\partial x} (\\lambda^2 x_0^T L^T L x_0) = 0$ (constant with respect to $x$)\n\nSumming these derivatives gives the gradient of $J(x)$:\n$$ \\nabla_x J(x) = 2(A^T A)x - 2 A^T y + 2 \\lambda^2 (L^T L)x - 2 \\lambda^2 (L^T L)x_0 $$\n\nWe find the minimum of $J(x)$ by setting its gradient to the zero vector:\n$$ 2(A^T A)x - 2 A^T y + 2 \\lambda^2 (L^T L)x - 2 \\lambda^2 (L^T L)x_0 = \\mathbf{0} $$\n\nDividing by $2$ and rearranging terms to isolate $x$:\n$$ (A^T A)x + \\lambda^2 (L^T L)x = A^T y + \\lambda^2 (L^T L)x_0 $$\n$$ (A^T A + \\lambda^2 L^T L)x = A^T y + \\lambda^2 L^T L x_0 $$\n\nThis is the general form of the normal equations for Tikhonov regularization. For the specific cases in this problem, the prior is given as $x_0 = \\mathbf{0}$. This simplifies the right-hand side of the equation:\n$$ (A^T A + \\lambda^2 L^T L)x = A^T y $$\n\nThis is a linear system of the form $M_{sys} x = b_{sys}$, where the system matrix $M_{sys} = A^T A + \\lambda^2 L^T L$ and the right-hand side vector $b_{sys} = A^T y$. The solution $x$ can be found using a standard linear algebra solver. The matrix $M_{sys}$ is guaranteed to be invertible for $\\lambda  0$ as long as the null spaces of $A$ and $L$ do not have a non-trivial intersection, which is a condition met by the regularization operators used in the problem.\n\n### Task 2: Implementation\n\nThe implementation follows directly from the derived normal equations. For each test case, a Python script performs the following steps:\n1.  The matrices $A$ and $L$, the measurement vector $y$, the prior vector $x_0$, and the regularization parameter $\\lambda$ are defined using `numpy` arrays, based on the verbatim data from the problem statement.\n2.  The system matrix $M_{sys} = A^T A + \\lambda^2 L^T L$ is constructed. Matrix transpositions and multiplications are performed using `numpy`'s `.T` attribute and the `@` operator.\n3.  The right-hand side vector $b_{sys} = A^T y$ is constructed (since $x_0=\\mathbf{0}$ for all cases).\n4.  The linear system $M_{sys} x = b_{sys}$ is solved for the unknown vector $x$ using the function `np.linalg.solve()`.\n5.  The elements of the resulting solution vector $x$ are formatted into strings representing scientific notation with three significant figures (e.g., `1.23e+19`).\n6.  The formatted strings for all test cases are concatenated into a single output line conforming to the specified format `[[case1_results],[case2_results],...]`, with no whitespace.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Tikhonov-regularized tomographic inversion problem for the given test cases.\n    \"\"\"\n\n    def format_vector(x_vec):\n        \"\"\"\n        Formats a vector into a comma-separated string of values in scientific\n        notation with three significant figures.\n        \"\"\"\n        return ','.join([f\"{val:.2e}\" for val in x_vec])\n\n    def solve_tikhonov(A, L, lambd, x0, y):\n        \"\"\"\n        Solves the Tikhonov-regularized system (A^T A + lambda^2 L^T L)x = A^T y + lambda^2 L^T L x0.\n        \"\"\"\n        lambda_sq = lambd**2\n        \n        # Construct the system matrix M = A^T A + lambda^2 L^T L\n        M_sys = A.T @ A + lambda_sq * (L.T @ L)\n        \n        # Construct the right-hand-side vector b = A^T y + lambda^2 L^T L x0\n        # Since x0 is zero in all test cases, this simplifies to b = A^T y\n        b_sys = A.T @ y + lambda_sq * (L.T @ L) @ x0\n\n        # Solve the linear system Mx = b for x\n        x_recovered = np.linalg.solve(M_sys, b_sys)\n        \n        return x_recovered\n\n    # --- Test Case 1: Interferometry, smoothness regularization ---\n    A1 = np.array([\n        [0, 0, 0, 0.01, 0.01, 0.01, 0, 0, 0],\n        [0, 0, 0.01, 0, 0, 0.01, 0, 0, 0.01],\n        [0.01414, 0, 0, 0, 0.01414, 0, 0, 0, 0.01414],\n        [0, 0, 0.01414, 0, 0.01414, 0, 0.01414, 0, 0],\n        [0.01, 0.01, 0.01, 0, 0, 0, 0, 0, 0],\n        [0, 0.01, 0, 0, 0.01, 0, 0.01, 0, 0]\n    ])\n    L1 = np.array([\n        # Horizontal differences\n        [1, -1, 0, 0, 0, 0, 0, 0, 0], [0, 1, -1, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 1, -1, 0, 0, 0, 0], [0, 0, 0, 0, 1, -1, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 1, -1, 0], [0, 0, 0, 0, 0, 0, 0, 1, -1],\n        # Vertical differences\n        [1, 0, 0, -1, 0, 0, 0, 0, 0], [0, 1, 0, 0, -1, 0, 0, 0, 0],\n        [0, 0, 1, 0, 0, -1, 0, 0, 0], [0, 0, 0, 1, 0, 0, -1, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, -1, 0], [0, 0, 0, 0, 0, 1, 0, 0, -1]\n    ])\n    lambda1 = 0.02\n    x0_1 = np.zeros(9)\n    y1 = np.array([4.5e17, 2.5e17, 5.656e17, 6.0802e17, 3.2e17, 4.8e17])\n    \n    # --- Test Case 2: Polarimetry, identity regularization ---\n    A2 = A1  # Same geometry as Case 1\n    L2 = np.identity(9)\n    lambda2 = 0.03\n    x0_2 = np.zeros(9)\n    y2 = np.array([7.5e17, 5.2e17, 1.15948e18, 9.898e17, 6.5e17, 8.5e17])\n\n    # --- Test Case 3: Interferometry, underdetermined, identity regularization ---\n    A3 = np.array([\n        [0.01, 0.01, 0, 0],\n        [0.01, 0, 0.01, 0],\n        [0.01414, 0, 0, 0.01414]\n    ])\n    L3 = np.identity(4)\n    lambda3 = 0.005\n    x0_3 = np.zeros(4)\n    y3 = np.array([2.7e17, 3.2e17, 3.535e17])\n\n    # --- Test Case 4: Interferometry, strong regularization ---\n    A4 = A3  # Same geometry as Case 3\n    L4 = L3  # Same regularization operator as Case 3\n    lambda4 = 1.0\n    x0_4 = x0_3 # Same prior\n    y4 = y3  # Same measurements\n\n    # Consolidate test cases\n    test_cases = [\n        (A1, L1, lambda1, x0_1, y1),\n        (A2, L2, lambda2, x0_2, y2),\n        (A3, L3, lambda3, x0_3, y3),\n        (A4, L4, lambda4, x0_4, y4),\n    ]\n\n    # Process all test cases and collect results\n    results_list = []\n    for A, L, lambd, x0, y in test_cases:\n        x_recovered = solve_tikhonov(A, L, lambd, x0, y)\n        results_list.append(f\"[{format_vector(x_recovered)}]\")\n\n    # Print final output in the required format\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```"
        }
    ]
}