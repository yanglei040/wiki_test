{
    "hands_on_practices": [
        {
            "introduction": "在拉长的托卡马克中，垂直位移事件（Vertical Displacement Events, VDEs）是导致破裂的主要宏观不稳定性之一。该实践将引导您从第一性原理（洛伦兹力和麦克斯韦方程）出发，推导出一个简化的等离子体环的垂直运动动力学模型。通过计算不稳定性的增长率，您将掌握评估和理解这种快速、灾难性事件风险的基础，这是开发反馈控制系统以避免破裂的关键一步。",
            "id": "3695169",
            "problem": "考虑一个核聚变装置中环形等离子体的简化柱状模型。将等离子体建模为一个大半径为 $R$ 的细长、刚性圆形电流环，该环携带环向等离子体电流 $I_p$。该环位于垂直位置为 $z$ 的水平面内，并经历刚性垂直位移 $z(t)$ 而不发生内部变形。该等离子体柱具有圆形截面半径 $a$、均匀的质量密度 $\\rho$，其总质量由其体积决定。由线圈产生的外部垂直磁场是轴对称的，并且在中平面 $z = 0$ 附近，可以很好地近似为\n$$\nB_z(z) = B_0 + \\alpha z + \\frac{1}{2}\\,\\beta z^2,\n$$\n其中 $B_0$、$\\alpha$ 和 $\\beta$ 是由线圈几何形状决定的常数。忽略自场修正、电阻壁和反馈效应、等离子体压力梯度以及任何非理想效应，并将外部场视为给定场。\n\n从外磁场中电流环的基本电磁学原理出发，推导作用在等离子体环上的净垂直力 $F_z(z)$，并用垂直场梯度 $\\partial B_z/\\partial z$ 表示。然后，通过在 $z = 0$ 附近进行线性化，当曲率 $\\beta$ 使平衡不稳定时，求出小振幅垂直运动方程和相应的指数增长率 $\\gamma$。\n\n使用以下参数进行数值计算：\n- 大半径: $R = 1.6\\,\\mathrm{m}$。\n- 截面半径: $a = 0.5\\,\\mathrm{m}$。\n- 等离子体电流: $I_p = 1.2 \\times 10^6\\,\\mathrm{A}$。\n- 质量密度: $\\rho = 1.0 \\times 10^{-7}\\,\\mathrm{kg/m^3}$。\n- 场系数: $B_0 = 0.30\\,\\mathrm{T}$，$\\alpha = 0$，$\\beta = 1.0 \\times 10^{-4}\\,\\mathrm{T/m^2}$。\n\n假设刚性垂直位移，并计算求解线性化动力学方程的增长率 $\\gamma$。将您的数值答案四舍五入到四位有效数字，并以 $\\mathrm{s^{-1}}$ 为单位表示。",
            "solution": "该问题陈述经评估是有效的，具有科学依据、问题明确且客观。它提出了一个用于托卡马克中垂直不稳定性分析的标准（尽管是简化的）模型，没有矛盾或含糊之处。\n\n解答过程分三个阶段进行：\n1.  推导作用在等离子体环上的垂直力 $F_z(z)$。\n2.  推导线性化运动方程和增长率 $\\gamma$。\n3.  使用给定参数数值计算 $\\gamma$。\n\n**1. 垂直力 $F_z(z)$ 的推导**\n\n控制载流导体在磁场中所受力的基本原理是洛伦兹力定律。对于一个载有电流 $I_p$ 的闭合回路 $C$，总力 $\\vec{F}$ 由以下积分给出：\n$$\n\\vec{F} = \\oint_C I_p d\\vec{l} \\times \\vec{B}\n$$\n在此模型中，等离子体是一个大半径为 $R$、垂直位置为 $z$ 的刚性圆形环。电流 $I_p$ 是环向的。我们使用柱坐标系 $(r, \\phi, z)$，其中环的路径由 $r=R$ 和一个恒定的 $z$ 描述。沿环的微分长度元在环向方向上，为 $d\\vec{l} = R d\\phi \\hat{\\phi}$。给定的外部磁场是轴对称的，$\\vec{B} = B_r(r,z)\\hat{r} + B_z(r,z)\\hat{z}$。\n\n微分力元为：\n$$\nd\\vec{F} = I_p (R d\\phi \\hat{\\phi}) \\times (B_r(R,z)\\hat{r} + B_z(R,z)\\hat{z})\n$$\n使用柱坐标单位矢量的叉积关系，$\\hat{\\phi} \\times \\hat{r} = -\\hat{z}$ 和 $\\hat{\\phi} \\times \\hat{z} = \\hat{r}$，我们得到：\n$$\nd\\vec{F} = I_p R d\\phi [-B_r(R,z)\\hat{z} + B_z(R,z)\\hat{r}]\n$$\n为了求合力，我们对整个环路从 $\\phi=0$ 到 $\\phi=2\\pi$ 进行积分。由于对称性，力的径向分量相互抵消（即 $\\int_0^{2\\pi} \\hat{r}(\\phi) d\\phi = \\int_0^{2\\pi} (\\cos\\phi \\hat{x} + \\sin\\phi \\hat{y}) d\\phi = 0$）。然而，垂直分量不会抵消。由于在给定的 $z$ 处，$B_r$ 沿着环路是恒定的，所以净垂直力 $F_z$ 为：\n$$\nF_z = \\int_0^{2\\pi} -I_p R B_r(R,z) d\\phi = -2\\pi R I_p B_r(R,z)\n$$\n问题要求用垂直场梯度 $\\partial B_z/\\partial z$ 来表示力。为了联系 $B_r$ 和 $B_z$，我们使用麦克斯韦方程 $\\nabla \\cdot \\vec{B} = 0$。对于轴对称场，在柱坐标系中，该方程为：\n$$\n\\frac{1}{r}\\frac{\\partial(r B_r)}{\\partial r} + \\frac{\\partial B_z}{\\partial z} = 0\n$$\n问题通过提供 $B_z(z)$ 简化了外部场，这意味着对于此模型而言，其空间依赖性在等离子体环附近主要取决于 $z$。我们可以一致地假设 $\\partial B_z/\\partial z$ 在感兴趣的区域内近似独立于径向坐标 $r$。将散度方程对 $r$ 从 $0$ 到 $R$ 积分：\n$$\n\\int_0^R \\frac{\\partial(r B_r)}{\\partial r} dr = -\\int_0^R r \\frac{\\partial B_z}{\\partial z} dr\n$$\n$$\n[r B_r(r,z)]_0^R = - \\frac{\\partial B_z}{\\partial z} \\int_0^R r dr\n$$\n由于当 $r \\to 0$ 时 $rB_r \\to 0$，我们有：\n$$\nR B_r(R,z) = -\\frac{\\partial B_z}{\\partial z} \\frac{R^2}{2} \\implies B_r(R,z) = -\\frac{R}{2}\\frac{\\partial B_z}{\\partial z}\n$$\n将 $B_r$ 的这个表达式代入力方程，得到：\n$$\nF_z(z) = -2\\pi R I_p \\left(-\\frac{R}{2}\\frac{d B_z}{d z}\\right) = \\pi R^2 I_p \\frac{d B_z}{d z}\n$$\n这就是我们所求的环路上的净垂直力表达式。\n\n**2. 运动方程与增长率**\n\n问题给出了轴上的垂直场为 $B_z(z) = B_0 + \\alpha z + \\frac{1}{2}\\beta z^2$。其梯度为：\n$$\n\\frac{d B_z}{d z} = \\alpha + \\beta z\n$$\n因此，垂直力为：\n$$\nF_z(z) = \\pi R^2 I_p (\\alpha + \\beta z)\n$$\n等离子体环垂直运动的牛顿第二定律是 $m\\ddot{z} = F_z(z)$，其中 $m$ 是等离子体的总质量。等离子体被建模为一个大半径为 $R$、小半径为 $a$ 的环体。其体积为 $V = (2\\pi R)(\\pi a^2) = 2\\pi^2 R a^2$。对于均匀质量密度 $\\rho$，总质量为：\n$$\nm = \\rho V = 2\\pi^2 R a^2 \\rho\n$$\n运动方程变为：\n$$\n(2\\pi^2 R a^2 \\rho) \\ddot{z} = \\pi R^2 I_p (\\alpha + \\beta z)\n$$\n我们在平衡位置 $z=0$ 附近对该方程进行线性化，以处理小位移。问题指定 $\\alpha=0$，这证实了 $z=0$ 确实是平衡点，因为 $F_z(0) = \\pi R^2 I_p \\alpha = 0$。\n线性化的运动方程是：\n$$\nm \\ddot{z} = z \\left. \\frac{d F_z}{dz} \\right|_{z=0} = z \\left. \\frac{d}{dz} [\\pi R^2 I_p (\\alpha + \\beta z)] \\right|_{z=0} = (\\pi R^2 I_p \\beta) z\n$$\n整理后得到：\n$$\n\\ddot{z} = \\left(\\frac{\\pi R^2 I_p \\beta}{m}\\right) z\n$$\n这是一个二阶线性常微分方程。我们寻求形式为 $z(t) \\propto \\exp(\\gamma t)$ 的解。将此代入方程得到 $\\gamma^2 z = (\\frac{\\pi R^2 I_p \\beta}{m}) z$。\n如果 $\\gamma^2  0$，系统是不稳定的。由于 $R$、$I_p$、$m$ 都是正数，当 $\\beta  0$ 时会发生不稳定性。问题陈述 $\\beta$ 是一个正常数，因此系统是不稳定的。指数增长率 $\\gamma$ 为：\n$$\n\\gamma = \\sqrt{\\frac{\\pi R^2 I_p \\beta}{m}}\n$$\n代入质量 $m$ 的表达式：\n$$\n\\gamma = \\sqrt{\\frac{\\pi R^2 I_p \\beta}{2\\pi^2 R a^2 \\rho}} = \\sqrt{\\frac{R I_p \\beta}{2\\pi a^2 \\rho}}\n$$\n\n**3. 数值计算**\n\n我们有以下给定参数：\n- 大半径: $R = 1.6\\,\\mathrm{m}$\n- 截面半径: $a = 0.5\\,\\mathrm{m}$\n- 等离子体电流: $I_p = 1.2 \\times 10^6\\,\\mathrm{A}$\n- 质量密度: $\\rho = 1.0 \\times 10^{-7}\\,\\mathrm{kg/m^3}$\n- 场系数: $\\beta = 1.0 \\times 10^{-4}\\,\\mathrm{T/m^2}$\n\n将这些值代入 $\\gamma$ 的表达式中：\n$$\n\\gamma = \\sqrt{\\frac{(1.6\\,\\mathrm{m})(1.2 \\times 10^6\\,\\mathrm{A})(1.0 \\times 10^{-4}\\,\\mathrm{T/m^2})}{2\\pi (0.5\\,\\mathrm{m})^2 (1.0 \\times 10^{-7}\\,\\mathrm{kg/m^3})}}\n$$\n$$\n\\gamma = \\sqrt{\\frac{1.92 \\times 10^2}{2\\pi (0.25) (1.0 \\times 10^{-7})}} \\,\\mathrm{s^{-1}} = \\sqrt{\\frac{192}{0.5\\pi \\times 10^{-7}}} \\,\\mathrm{s^{-1}}\n$$\n$$\n\\gamma = \\sqrt{\\frac{384}{\\pi} \\times 10^7} \\,\\mathrm{s^{-1}} = \\sqrt{\\frac{3.84 \\times 10^9}{\\pi}} \\,\\mathrm{s^{-1}}\n$$\n$$\n\\gamma \\approx \\sqrt{1.2223099 \\times 10^9} \\,\\mathrm{s^{-1}} \\approx 34961.549 \\,\\mathrm{s^{-1}}\n$$\n将结果四舍五入到四位有效数字，得到 $34960\\,\\mathrm{s^{-1}}$。",
            "answer": "$$\\boxed{34960}$$"
        },
        {
            "introduction": "破裂风险分析不仅限于预测破裂本身，还包括评估其后果，其中逃逸电子的产生是一个关键问题。本练习将实践从确定性物理模型过渡到概率风险评估。我们将探讨当关键物理量（如平行电场和电子密度）不再是固定值，而是遵循统计分布时，如何量化逃逸电子的产生概率。通过这个练习，您将学会如何将一个物理判据转化为一个具体的、可量化的风险指标。",
            "id": "3695234",
            "problem": "考虑磁约束聚变等离子体中一次破坏后的热淬灭（Thermal Quench, TQ）。逃逸电子的产生通常用平行电场超过临界电场阈值的条件来建模。令平行电场表示为 $E_\\parallel$，电子数密度表示为 $n_e$。逃逸电子的产生条件由 $E_\\parallel  E_c(n_e)$ 给出，其中临界电场 $E_c$ 由 Connor-Hastie 表达式建模，\n$$\nE_c(n_e) = \\alpha \\, n_e,\n$$\n其中\n$$\n\\alpha = \\frac{e^3 \\ln \\Lambda}{4 \\pi \\epsilon_0^2 m_e c^2},\n$$\n式中 $e$ 是基本电荷，$\\epsilon_0$ 是真空介电常数，$m_e$ 是电子静止质量，$c$ 是真空中的光速，$\\ln \\Lambda$ 是库仑对数。假设在热淬灭（TQ）之后，随机变量 $E_\\parallel$ 和 $n_e$ 是独立的，且服从对数正态分布：\n$$\n\\ln E_\\parallel \\sim \\mathcal{N}(\\mu_E, \\sigma_E^2), \\qquad \\ln n_e \\sim \\mathcal{N}(\\mu_n, \\sigma_n^2),\n$$\n并且库仑对数 $\\ln \\Lambda$ 在每种情况下都被视为一个固定参数。\n\n仅从概率的定义、正态分布的性质以及上述物理定义出发，推导逃逸电子产生的概率表达式，\n$$\nP_{\\mathrm{run}} = \\mathbb{P}\\left(E_\\parallel  E_c(n_e)\\right),\n$$\n该表达式应表示为 $E_\\parallel$ 超过 $E_c(n_e)$ 的尾部概率在 $n_e$ 分布上的积分。然后，利用正态分布的恒等式，将此表达式简化为由参数 $\\mu_E$、$\\sigma_E$、$\\mu_n$、$\\sigma_n$ 和 $\\alpha$ 表示的闭式解。\n\n你将实现一个程序来计算若干测试用例的 $P_{\\mathrm{run}}$。所有物理量都必须采用国际单位制（SI单位），其中 $E_\\parallel$ 和 $E_c$ 的单位是 $\\mathrm{V/m}$，$n_e$ 的单位是 $\\mathrm{m^{-3}}$。最终答案应表示为无量纲的十进制概率值。\n\n在国际单位制中使用以下常量：\n- $e = 1.602176634 \\times 10^{-19}$，\n- $\\epsilon_0 = 8.8541878128 \\times 10^{-12}$，\n- $m_e = 9.10938356 \\times 10^{-31}$，\n- $c = 2.99792458 \\times 10^{8}$，\n- $\\pi = 3.141592653589793$。\n\n测试组。计算下列参数集的 $P_{\\mathrm{run}}$，每个参数集指定为 $(\\mu_E, \\sigma_E, \\mu_n, \\sigma_n, \\ln \\Lambda)$，其中每个 $\\mu$ 是相应对数正态变量中位数的自然对数：\n\n$1.$ $(\\ln(5), \\, 0.4, \\, \\ln(5 \\times 10^{20}), \\, 0.3, \\, 15)$。\n\n$2.$ $(\\ln(0.3), \\, 0.2, \\, \\ln(4 \\times 10^{20}), \\, 0.2, \\, 15)$。\n\n$3.$ $(\\ln(1.0), \\, 0.35, \\, \\ln(1.5 \\times 10^{21}), \\, 0.25, \\, 15)$。\n\n$4.$ $(\\ln(0.5), \\, 0.3, \\, \\ln(1.0 \\times 10^{21}), \\, 0.3, \\, 10)$。\n\n$5.$ $(\\ln(0.05), \\, 10^{-6}, \\, \\ln(5.0 \\times 10^{20}), \\, 10^{-6}, \\, 15)$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个概率值四舍五入到六位小数，例如 $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$。",
            "solution": "在进行求解之前，对问题陈述的有效性进行了严格评估。\n\n### 步骤1：提取已知条件\n- **物理模型**：逃逸电子的产生条件是 $E_\\parallel  E_c(n_e)$。\n- **临界电场定义**：$E_c(n_e) = \\alpha \\, n_e$。\n- **常数 $\\alpha$**：$\\alpha = \\frac{e^3 \\ln \\Lambda}{4 \\pi \\epsilon_0^2 m_e c^2}$。\n- **随机变量**：$E_\\parallel$ 和 $n_e$ 是独立的随机变量。\n- **分布**：\n  - $\\ln E_\\parallel \\sim \\mathcal{N}(\\mu_E, \\sigma_E^2)$，$E_\\parallel$ 的自然对数服从正态分布。\n  - $\\ln n_e \\sim \\mathcal{N}(\\mu_n, \\sigma_n^2)$，$n_e$ 的自然对数服从正态分布。\n- **任务**：\n  1. 推导逃逸电子产生概率 $P_{\\mathrm{run}} = \\mathbb{P}\\left(E_\\parallel  E_c(n_e)\\right)$ 的积分表达式。\n  2. 将此表达式简化为由参数 $\\mu_E、\\sigma_E、\\mu_n、\\sigma_n$ 和 $\\alpha$ 表示的闭式解。\n  3. 实现一个程序，为给定的测试用例计算 $P_{\\mathrm{run}}$。\n- **物理常数（SI单位）**：\n  - $e = 1.602176634 \\times 10^{-19}$\n  - $\\epsilon_0 = 8.8541878128 \\times 10^{-12}$\n  - $m_e = 9.10938356 \\times 10^{-31}$\n  - $c = 2.99792458 \\times 10^{8}$\n  - $\\pi = 3.141592653589793$\n- **测试组**：五个 $(\\mu_E, \\sigma_E, \\mu_n, \\sigma_n, \\ln \\Lambda)$ 参数集，其中 $\\mu_E$ 和 $\\mu_n$ 被指定为相应对数正态分布中位数的自然对数。\n  1. $(\\ln(5), \\, 0.4, \\, \\ln(5 \\times 10^{20}), \\, 0.3, \\, 15)$\n  2. $(\\ln(0.3), \\, 0.2, \\, \\ln(4 \\times 10^{20}), \\, 0.2, \\, 15)$\n  3. $(\\ln(1.0), \\, 0.35, \\, \\ln(1.5 \\times 10^{21}), \\, 0.25, \\, 15)$\n  4. $(\\ln(0.5), \\, 0.3, \\, \\ln(1.0 \\times 10^{21}), \\, 0.3, \\, 10)$\n  5. $(\\ln(0.05), \\, 10^{-6}, \\, \\ln(5.0 \\times 10^{20}), \\, 10^{-6}, \\, 15)$\n\n### 步骤2：使用提取的已知条件进行验证\n该问题根据既定标准进行评估：\n- **科学依据**：该问题基于聚变等离子体中逃逸电子的物理学。Connor-Hastie 临界电场是等离子体物理学中一个公认（尽管简化）的模型。$\\alpha$ 的公式源于电动力学的基本原理。使用对数正态分布对于具有正定性、波动的物理量来说是一种合理的统计假设。\n- **定义明确**：问题定义清晰，所有必要的参数、常数和分布都已指定。它要求进行推导和计算，从而得到唯一且有意义的解。独立性假设简化了问题，使其在解析上易于处理。\n- **客观性**：问题使用精确的数学和物理语言陈述，没有主观性或模糊性。\n\n该问题没有违反任何无效性标准。它在科学上是合理的，结构上是形式化的，自成一体，并且在计算上是可行的。物理量及其单位在国际单位制中是一致的。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将提供一个完整的、有理有据的解答。\n\n### 逃逸概率的推导\n逃逸电子产生的概率 $P_{\\mathrm{run}}$ 是平行电场 $E_\\parallel$ 超过临界电场 $E_c(n_e)$ 的概率。\n$$\nP_{\\mathrm{run}} = \\mathbb{P}\\left(E_\\parallel  E_c(n_e)\\right)\n$$\n使用给定的模型 $E_c(n_e) = \\alpha n_e$，条件变为：\n$$\nE_\\parallel  \\alpha n_e\n$$\n由于变量 $E_\\parallel$ 和 $n_e$ 严格为正，我们可以对不等式两边取自然对数而不改变不等号方向：\n$$\n\\ln E_\\parallel  \\ln(\\alpha n_e) = \\ln \\alpha + \\ln n_e\n$$\n我们定义两个新的随机变量：$X = \\ln E_\\parallel$ 和 $Y = \\ln n_e$。根据问题陈述，这些变量服从正态分布：\n$$\nX \\sim \\mathcal{N}(\\mu_E, \\sigma_E^2), \\qquad Y \\sim \\mathcal{N}(\\mu_n, \\sigma_n^2)\n$$\n该不等式可以用 $X$ 和 $Y$ 重写为：\n$$\nX  \\ln \\alpha + Y \\implies X - Y  \\ln \\alpha\n$$\n我们定义第三个随机变量 $Z = X - Y$。由于 $X$ 和 $Y$ 是独立的服从正态分布的随机变量，它们的差 $Z$ 也服从正态分布。$Z$ 的均值和方差由下式给出：\n$$\n\\mu_Z = \\mathbb{E}[Z] = \\mathbb{E}[X - Y] = \\mathbb{E}[X] - \\mathbb{E}[Y] = \\mu_E - \\mu_n\n$$\n$$\n\\sigma_Z^2 = \\mathrm{Var}(Z) = \\mathrm{Var}(X - Y) = \\mathrm{Var}(X) + \\mathrm{Var}(-Y) = \\mathrm{Var}(X) + (-1)^2 \\mathrm{Var}(Y) = \\sigma_E^2 + \\sigma_n^2\n$$\n因此，$Z$ 的分布为：\n$$\nZ \\sim \\mathcal{N}(\\mu_E - \\mu_n, \\sigma_E^2 + \\sigma_n^2)\n$$\n逃逸概率现在是 $Z$ 超过常数值 $\\ln \\alpha$ 的概率：\n$$\nP_{\\mathrm{run}} = \\mathbb{P}(Z  \\ln \\alpha)\n$$\n为了计算这个概率，我们将随机变量 $Z$ 标准化为标准正态变量 $S \\sim \\mathcal{N}(0, 1)$，其中 $S = (Z - \\mu_Z) / \\sigma_Z$。\n$$\nP_{\\mathrm{run}} = \\mathbb{P}\\left(\\frac{Z - \\mu_Z}{\\sigma_Z}  \\frac{\\ln \\alpha - \\mu_Z}{\\sigma_Z}\\right) = \\mathbb{P}\\left(S  \\frac{\\ln \\alpha - (\\mu_E - \\mu_n)}{\\sqrt{\\sigma_E^2 + \\sigma_n^2}}\\right)\n$$\n令 $\\Phi(\\cdot)$ 为标准正态分布的累积分布函数（CDF）。那么 $\\mathbb{P}(S  s) = 1 - \\mathbb{P}(S \\le s) = 1 - \\Phi(s)$。\n$$\nP_{\\mathrm{run}} = 1 - \\Phi\\left(\\frac{\\ln \\alpha - \\mu_E + \\mu_n}{\\sqrt{\\sigma_E^2 + \\sigma_n^2}}\\right)\n$$\n利用正态分布的对称性 $1 - \\Phi(s) = \\Phi(-s)$，我们得到最终的闭式解表达式：\n$$\nP_{\\mathrm{run}} = \\Phi\\left(-\\frac{\\ln \\alpha - \\mu_E + \\mu_n}{\\sqrt{\\sigma_E^2 + \\sigma_n^2}}\\right) = \\Phi\\left(\\frac{\\mu_E - \\mu_n - \\ln \\alpha}{\\sqrt{\\sigma_E^2 + \\sigma_n^2}}\\right)\n$$\n该表达式满足了将概率简化为闭式解的要求。问题还要求一个积分表达式。根据全概率公式，以 $n_e$ 为条件：\n$$\nP_{\\mathrm{run}} = \\int_0^\\infty \\mathbb{P}(E_\\parallel  \\alpha x | n_e=x) f_{n_e}(x) dx\n$$\n由于独立性，这等于 $\\int_0^\\infty \\mathbb{P}(E_\\parallel  \\alpha x) f_{n_e}(x) dx$，其中 $f_{n_e}(x)$ 是 $n_e$ 的对数正态概率密度函数（PDF）。推导出的闭式解是计算该积分的结果。\n\n在计算中，标准正态CDF $\\Phi(z)$ 可以使用误差函数 $\\mathrm{erf}(x)$ 来表示，该函数在科学计算库中广泛可用：\n$$\n\\Phi(z) = \\frac{1}{2}\\left[1 + \\mathrm{erf}\\left(\\frac{z}{\\sqrt{2}}\\right)\\right]\n$$\n设CDF的自变量为 $\\mathcal{A}$：\n$$\n\\mathcal{A} = \\frac{\\mu_E - \\mu_n - \\ln \\alpha}{\\sqrt{\\sigma_E^2 + \\sigma_n^2}}\n$$\n则概率为：\n$$\nP_{\\mathrm{run}} = \\frac{1}{2}\\left[1 + \\mathrm{erf}\\left(\\frac{\\mathcal{A}}{\\sqrt{2}}\\right)\\right] = \\frac{1}{2}\\left[1 + \\mathrm{erf}\\left(\\frac{\\mu_E - \\mu_n - \\ln \\alpha}{\\sqrt{2(\\sigma_E^2 + \\sigma_n^2)}}\\right)\\right]\n$$\n\n### 算法实现\n计算步骤如下：\n1.  以SI单位定义所需的物理常数。\n2.  对每个测试用例 $(\\mu_E, \\sigma_E, \\mu_n, \\sigma_n, \\ln \\Lambda)$：\n    a. 计算常数 $\\alpha = \\frac{e^3 \\ln \\Lambda}{4 \\pi \\epsilon_0^2 m_e c^2}$。\n    b. 计算其自然对数 $\\ln \\alpha$。\n    c. 计算自变量 $\\mathcal{A}$ 的分子：$\\mu_E - \\mu_n - \\ln \\alpha$。\n    d. 计算自变量 $\\mathcal{A}$ 的分母：$\\sqrt{\\sigma_E^2 + \\sigma_n^2}$。\n    e. 计算 $\\mathcal{A}$，然后使用误差函数公式计算 $P_{\\mathrm{run}}$。\n3.  收集所有测试用例的结果，并按要求格式化。\n实现将使用 `numpy` 进行高精度数值运算，并使用 `scipy.special.erf` 计算误差函数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Calculates the probability of runaway electron onset for several test cases.\n    \"\"\"\n    # Define physical constants in SI units.\n    E_CHARGE = 1.602176634e-19  # Elementary charge in C\n    EPSILON_0 = 8.8541878128e-12 # Vacuum permittivity in F/m\n    M_E = 9.10938356e-31       # Electron rest mass in kg\n    C_LIGHT = 2.99792458e8         # Speed of light in m/s\n    PI = np.pi\n\n    def calculate_alpha(ln_lambda):\n        \"\"\"\n        Calculates the Connor-Hastie coefficient alpha.\n        alpha = (e^3 * ln_lambda) / (4 * pi * epsilon_0^2 * m_e * c^2)\n        \"\"\"\n        numerator = (E_CHARGE**3) * ln_lambda\n        denominator = 4 * PI * (EPSILON_0**2) * M_E * (C_LIGHT**2)\n        return numerator / denominator\n\n    def calculate_runaway_prob(mu_e, sigma_e, mu_n, sigma_n, ln_lambda):\n        \"\"\"\n        Calculates the runaway probability P_run using the closed-form solution.\n        P_run = Phi((mu_e - mu_n - ln_alpha) / sqrt(sigma_e^2 + sigma_n^2))\n              = 0.5 * (1 + erf(arg / sqrt(2)))\n        \"\"\"\n        alpha = calculate_alpha(ln_lambda)\n        ln_alpha = np.log(alpha)\n\n        # Argument for the standard normal CDF Phi(z)\n        z_numerator = mu_e - mu_n - ln_alpha\n        z_denominator = np.sqrt(sigma_e**2 + sigma_n**2)\n        \n        # Handle cases with extremely small denominators to avoid division by zero,\n        # although the test cases do not pose this issue.\n        if z_denominator  1e-12: # Effectively deterministic case\n            return 1.0 if z_numerator > 0 else 0.0\n\n        z = z_numerator / z_denominator\n\n        # Use the error function erf(z/sqrt(2)) for numerical computation of Phi(z)\n        prob = 0.5 * (1.0 + erf(z / np.sqrt(2)))\n        return prob\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (mu_E, sigma_E, mu_n, sigma_n, ln_lambda)\n    # The parameters mu_E and mu_n are given as ln(value), so we use np.log\n    # to maintain precision.\n    test_cases = [\n        (np.log(5.0), 0.4, np.log(5.0e20), 0.3, 15.0),\n        (np.log(0.3), 0.2, np.log(4.0e20), 0.2, 15.0),\n        (np.log(1.0), 0.35, np.log(1.5e21), 0.25, 15.0),\n        (np.log(0.5), 0.3, np.log(1.0e21), 0.3, 10.0),\n        (np.log(0.05), 1.0e-6, np.log(5.0e20), 1.0e-6, 15.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        mu_e, sigma_e, mu_n, sigma_n, ln_lambda = case\n        prob = calculate_runaway_prob(mu_e, sigma_e, mu_n, sigma_n, ln_lambda)\n        results.append(prob)\n\n    # Final print statement in the exact required format.\n    # Each probability is formatted to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现代破裂预测系统严重依赖于从大量的实验数据中学习的机器学习模型。这个实践提供了一个从零开始构建一个基础概率分类器（朴素贝叶斯）的动手经验。您将学习整个流程，包括特征处理（信号离散化）、模型训练（使用平滑技术估计概率）以及性能评估（计算对数损失）。这项练习揭示了在真实聚变装置上运行的破裂预警系统背后的核心统计原理。",
            "id": "3695232",
            "problem": "您的任务是使用朴素贝叶斯原理和离散化的诊断信号区间，为磁约束聚变装置构建并评估一个用于破裂预测的二元分类器。该问题必须纯粹以数学和逻辑术语进行表述，同时在核聚变背景下保持其科学真实性。该分类器应能根据离散化信号估计破裂事件的概率，并使用一种有原则的度量标准来量化风险。\n\n破裂事件由一个二元随机变量 $Y \\in \\{0,1\\}$ 表示，其中 $Y=1$ 表示破裂，$Y=0$ 表示非破裂。每次放电由 $D$ 个离散化的诊断特征 $X = (B_1, B_2, \\dots, B_D)$ 描述，其中每个 $B_d$ 是特征 $d$ 的区间索引。对于特征 $d$，其区间索引的取值范围为 $\\{0,1,\\dots,K_d-1\\}$，其中整数 $K_d \\ge 2$。您将使用给定类别 ($Y$) 下的独立性假设，利用拉普拉斯平滑从计数中构建类条件似然，形成破裂的后验概率，并在验证集上评估期望对数损失。期望对数损失是使用自然对数计算的验证样本上的平均负对数似然 (NLL)。\n\n理论基础：从联合概率、条件概率的定义和贝叶斯定理出发，结合朴素贝叶斯模型的独立性假设（即给定类别下特征的条件独立性）。具体来说，使用以下经过充分检验的事实作为基础：条件概率的贝叶斯法则、对数对于乘积的加性，以及用于分类似然估计的拉普拉斯平滑。除这些基本原理外，不要假设或使用任何快捷公式。\n\n您的程序必须为每个测试用例实现以下步骤：\n- 使用指定的 $\\alpha  0$ 进行拉普拉斯平滑，根据训练计数 $n_{y,d,k}$ 为每个特征 $d$ 和区间 $k$ 构建类条件似然。\n- 从训练计数或（如果提供）从外部指定的先验覆盖值构建类先验概率 $P(Y=y)$。\n- 为每个验证样本 $x$ 计算后验概率 $P(Y=1 \\mid X=x)$。\n- 计算验证集上的期望对数损失，其值为 $-\\ln(p_{\\text{true}})$ 的平均值，其中 $p_{\\text{true}}$ 是分配给该样本真实类别标签的后验概率。使用自然对数，并将所有最终计算出的期望对数损失值表示为无量纲实数（无物理单位）。\n- 汇总所有测试用例的期望对数损失值，并完全按照本问题末尾指定的格式打印。\n\n您的实现必须对所有特征使用从零开始的区间索引。\n\n测试套件：\n请为以下 $4$ 个测试用例提供解决方案。每个测试用例都由特征数量 $D$、每个特征的区间数 $K_d$、每个类别和区间的训练计数 $n_{y,d,k}$、拉普拉斯平滑参数 $\\alpha$、验证样本及其真实标签，以及可能存在的外部指定的类先验覆盖值来指定。所有计数在科学上都是合理的，因为它们代表了为破裂预测而通常监测的信号（如线平均密度、等离子体电流爬升率、环电压、磁场时间导数和线辐射）的分箱统计数据。\n\n- 测试用例 $1$（平衡先验和中度平滑的一般情况）：\n  - 特征：$D=3$，区间数为 $K_1=3, K_2=3, K_3=4$。\n  - 训练计数 $n_{y,d,k}$：\n    - 特征 $1$（线平均密度）：$n_{0,1,:} = [24,50,26]$, $n_{1,1,:} = [30,40,30]$。\n    - 特征 $2$（等离子体电流爬升率）：$n_{0,2,:} = [60,30,10]$, $n_{1,2,:} = [20,40,40]$。\n    - 特征 $3$（环电压）：$n_{0,3,:} = [25,25,30,20]$, $n_{1,3,:} = [15,25,35,25]$。\n  - 拉普拉斯平滑：$\\alpha = 1.0$。\n  - 类先验：从计数中推导。\n  - 验证样本（每个样本为 $(B_1,B_2,B_3)$，使用从零开始的区间索引）和标签：\n    - $x^{(1)} = (1,2,2)$，标签为 $y^{(1)}=1$，\n    - $x^{(2)} = (0,0,1)$，标签为 $y^{(2)}=0$，\n    - $x^{(3)} = (2,1,3)$，标签为 $y^{(3)}=1$，\n    - $x^{(4)} = (1,1,0)$，标签为 $y^{(4)}=0$。\n\n- 测试用例 $2$（稀疏区间和极低平滑度以暴露接近零的概率）：\n  - 特征：$D=2$，区间数为 $K_1=4, K_2=2$。\n  - 训练计数 $n_{y,d,k}$：\n    - 特征 $1$（磁场时间导数）：$n_{0,1,:} = [80,15,5,0]$, $n_{1,1,:} = [10,20,30,40]$。\n    - 特征 $2$（线辐射）：$n_{0,2,:} = [85,15]$, $n_{1,2,:} = [30,70]$。\n  - 拉普拉斯平滑：$\\alpha = 0.01$。\n  - 类先验：从计数中推导。\n  - 验证样本和标签：\n    - $x^{(1)} = (3,1)$，标签为 $y^{(1)}=1$，\n    - $x^{(2)} = (0,0)$，标签为 $y^{(2)}=0$，\n    - $x^{(3)} = (2,1)$，标签为 $y^{(3)}=1$，\n    - $x^{(4)} = (1,0)$，标签为 $y^{(4)}=0$。\n\n- 测试用例 $3$（训练计数严重不平衡但有先验覆盖）：\n  - 特征：$D=3$，区间数为 $K_1=2, K_2=2, K_3=3$。\n  - 训练计数 $n_{y,d,k}$：\n    - 特征 $1$：$n_{0,1,:} = [400,100]$, $n_{1,1,:} = [20,30]$。\n    - 特征 $2$：$n_{0,2,:} = [450,50]$, $n_{1,2,:} = [30,20]$。\n    - 特征 $3$：$n_{0,3,:} = [250,200,50]$, $n_{1,3,:} = [10,20,20]$。\n  - 拉普拉斯平滑：$\\alpha = 1.0$。\n  - 类先验：用 $(P(Y=0), P(Y=1)) = (0.2, 0.8)$ 覆盖。\n  - 验证样本和标签：\n    - $x^{(1)} = (1,1,2)$，标签为 $y^{(1)}=1$，\n    - $x^{(2)} = (0,0,0)$，标签为 $y^{(2)}=0$，\n    - $x^{(3)} = (1,0,1)$，标签为 $y^{(3)}=0$，\n    - $x^{(4)} = (0,1,1)$，标签为 $y^{(4)}=1$。\n\n- 测试用例 $4$（单特征边界情况）：\n  - 特征：$D=1$，区间数为 $K_1=2$。\n  - 训练计数 $n_{y,1,k}$：\n    - $n_{0,1,:} = [50,50]$, $n_{1,1,:} = [30,70]$。\n  - 拉普拉斯平滑：$\\alpha = 1.0$。\n  - 类先验：从计数中推导。\n  - 验证样本和标签：\n    - $x^{(1)} = (1)$，标签为 $y^{(1)}=1$，\n    - $x^{(2)} = (0)$，标签为 $y^{(2)}=0$，\n    - $x^{(3)} = (1)$，标签为 $y^{(3)}=0$，\n    - $x^{(4)} = (0)$，标签为 $y^{(4)}=1$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试用例 1 到 4 的期望对数损失值，按顺序排列，形式为方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是一个实数。在损失计算中使用自然对数，并将值报告为原始十进制数。此输出不涉及物理单位或角度单位。",
            "solution": "该问题要求构建并评估一个用于预测磁约束聚变装置中破裂的朴素贝叶斯二元分类器。解决方案源自概率论的第一性原理。\n\n### 问题验证\n\n该问题已经过验证，并被确定为 **有效**。它在科学上植根于应用于等离子体物理学（聚变破裂预测）真实场景的统计学习理论。该问题是适定的，提供了所有必要的数据和清晰、明确的目标。使用带有拉普拉斯平滑的朴素贝叶斯模型是一种标准技术，其从基本原理（贝叶斯定理、条件独立性）出发的表述是一种严谨的方法。所提供的数据是合理且自洽的。任务是客观的，并且可以进行数学形式化。因此，将提供一个解决方案。\n\n### 理论基础\n\n目标是计算在给定一组 $D$ 个离散化诊断测量值 $X=x$ 的情况下，发生破裂的后验概率 $P(Y=1 \\mid X=x)$，其中 $x = (b_0, b_1, \\dots, b_{D-1})$ 是一个区间索引向量。类别变量 $Y$ 是二元的，其中 $Y=1$ 代表破裂，$Y=0$ 代表非破裂或正常的放电。\n\n根据贝叶斯定理，一个类别 $y \\in \\{0, 1\\}$ 的后验概率由下式给出：\n$$P(Y=y \\mid X=x) = \\frac{P(X=x \\mid Y=y) P(Y=y)}{P(X=x)}$$\n分母 $P(X=x)$ 是证据，作为一个归一化常数。它通过对所有可能类别的联合概率进行边缘化来计算：\n$$P(X=x) = \\sum_{y' \\in \\{0,1\\}} P(X=x \\mid Y=y') P(Y=y')$$\n\n朴素贝叶斯分类器的特点在于其“朴素”的假设，即在给定类别的情况下，特征之间条件独立。这个假设将类条件概率 $P(X=x \\mid Y=y)$ 简化为单个特征似然的乘积：\n$$P(X=x \\mid Y=y) = P(B_0=b_0, B_1=b_1, \\dots, B_{D-1}=b_{D-1} \\mid Y=y) = \\prod_{d=0}^{D-1} P(B_d=b_d \\mid Y=y)$$\n将此代入贝叶斯定理表达式，得到核心的朴素贝叶斯公式：\n$$P(Y=y \\mid X=x) = \\frac{P(Y=y) \\prod_{d=0}^{D-1} P(B_d=b_d \\mid Y=y)}{\\sum_{y' \\in \\{0,1\\}} P(Y=y') \\prod_{d=0}^{D-1} P(B_d=b_d \\mid Y=y')}$$\n\n为了实现分类器，我们必须从训练数据中估计两组参数：类先验概率 $P(Y=y)$ 和类条件似然 $P(B_d=b_d \\mid Y=y)$。\n\n### 参数估计\n\n1.  **类条件似然 $P(B_d=k \\mid Y=y)$**：\n    这些概率是根据提供的训练计数 $n_{y,d,k}$ 估计的，该计数代表类别为 $y$ 且特征 $d$ 落在区间 $k$ 中的训练样本数量。为了处理训练数据中某个区间的计数可能为零（这会导致整个似然乘积错误地变为零）的情况，我们采用拉普拉斯平滑（对于 $\\alpha=1$ 则是加一平滑）。对于平滑参数 $\\alpha  0$，平滑后的概率估计为：\n    $$P(B_d=k \\mid Y=y) = \\frac{n_{y,d,k} + \\alpha}{N_y + \\alpha K_d}$$\n    在此，$K_d$ 是特征 $d$ 的区间数量，$N_y = \\sum_{j=0}^{K_d-1} n_{y,d,j}$ 是类别 $y$ 的训练样本总数。问题指出，对于给定的类别 $y$，$N_y$ 在所有特征上是一致的。\n\n2.  **类先验概率 $P(Y=y)$**：\n    每个类别的先验概率可以从训练集中每个类别的样本总数来估计：\n    $$P(Y=y) = \\frac{N_y}{N_0 + N_1}$$\n    或者，如测试用例 3 中所指定，这些先验概率可以被外部指定的值所覆盖。\n\n### 数值实现与风险度量\n\n将许多小概率相乘可能导致数值下溢。一个更稳定的方法是计算对数之和。我们为每个类别 $y$ 定义一个未归一化的对数后验分数 $S_y(x)$：\n$$S_y(x) = \\ln P(Y=y) + \\sum_{d=0}^{D-1} \\ln P(B_d=b_d \\mid Y=y)$$\n之后可以在不发生下溢的情况下恢复后验概率。对于二元分类问题，类别 $Y=1$ 的后验概率可以使用对数分数差值的逻辑S型函数来表示：\n$$P(Y=1 \\mid X=x) = \\frac{e^{S_1(x)}}{e^{S_0(x)} + e^{S_1(x)}} = \\frac{1}{1 + e^{S_0(x) - S_1(x)}}$$\n类别 $Y=0$ 的后验概率就是 $P(Y=0 \\mid X=x) = 1 - P(Y=1 \\mid X=x)$。\n\n分类器的性能通过在包含 $M$ 个样本 $\\{(x^{(i)}, y^{(i)})\\}_{i=1}^M$ 的验证集上使用期望对数损失（也称为平均负对数似然，NLL）进行评估。单个样本的NLL是模型分配给真实类别标签的概率的负自然对数：\n$$L_i = -\\ln \\left( P(Y=y^{(i)} \\mid X=x^{(i)}) \\right)$$\n期望对数损失是这些值的平均值：\n$$E[\\text{log-loss}] = \\frac{1}{M} \\sum_{i=1}^{M} L_i$$\n\n### 算法摘要\n\n对于每个测试用例，所实现的算法按以下步骤进行：\n1.  确定类先验概率 $P(Y=0)$ 和 $P(Y=1)$，可以从训练计数中确定，也可以使用指定的覆盖值。\n2.  对于每个类别 $y \\in \\{0, 1\\}$、特征 $d \\in \\{0, \\dots, D-1\\}$ 和区间 $k \\in \\{0, \\dots, K_d-1\\}$，计算平滑后的类条件似然 $P(B_d=k \\mid Y=y)$。\n3.  对于每个验证样本 $(x^{(i)}, y^{(i)})$：\n    a. 计算对数后验分数 $S_0(x^{(i)})$ 和 $S_1(x^{(i)})$。\n    b. 计算后验概率 $P(Y=1 \\mid x^{(i)})$ 和 $P(Y=0 \\mid x^{(i)})$。\n    c. 确定真实标签的后验概率 $p_{\\text{true}}^{(i)} = P(Y=y^{(i)} \\mid x^{(i)})$。\n    d. 计算样本的 NLL，$L_i = -\\ln(p_{\\text{true}}^{(i)})$。\n4.  计算所有验证样本的 NLL 值的平均值，以获得该测试用例的最终期望对数损失。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solving of all test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Test Case 1\n        {\n            \"D\": 3, \"K\": [3, 3, 4],\n            \"counts\": {\n                0: [np.array([24, 50, 26]), np.array([60, 30, 10]), np.array([25, 25, 30, 20])],\n                1: [np.array([30, 40, 30]), np.array([20, 40, 40]), np.array([15, 25, 35, 25])]\n            },\n            \"alpha\": 1.0,\n            \"priors_override\": None,\n            \"validation\": [{\"x\": [1, 2, 2], \"y\": 1}, {\"x\": [0, 0, 1], \"y\": 0}, \n                           {\"x\": [2, 1, 3], \"y\": 1}, {\"x\": [1, 1, 0], \"y\": 0}]\n        },\n        # Test Case 2\n        {\n            \"D\": 2, \"K\": [4, 2],\n            \"counts\": {\n                0: [np.array([80, 15, 5, 0]), np.array([85, 15])],\n                1: [np.array([10, 20, 30, 40]), np.array([30, 70])]\n            },\n            \"alpha\": 0.01,\n            \"priors_override\": None,\n            \"validation\": [{\"x\": [3, 1], \"y\": 1}, {\"x\": [0, 0], \"y\": 0},\n                           {\"x\": [2, 1], \"y\": 1}, {\"x\": [1, 0], \"y\": 0}]\n        },\n        # Test Case 3\n        {\n            \"D\": 3, \"K\": [2, 2, 3],\n            \"counts\": {\n                0: [np.array([400, 100]), np.array([450, 50]), np.array([250, 200, 50])],\n                1: [np.array([20, 30]), np.array([30, 20]), np.array([10, 20, 20])]\n            },\n            \"alpha\": 1.0,\n            \"priors_override\": [0.2, 0.8],\n            \"validation\": [{\"x\": [1, 1, 2], \"y\": 1}, {\"x\": [0, 0, 0], \"y\": 0},\n                           {\"x\": [1, 0, 1], \"y\": 0}, {\"x\": [0, 1, 1], \"y\": 1}]\n        },\n        # Test Case 4\n        {\n            \"D\": 1, \"K\": [2],\n            \"counts\": {\n                0: [np.array([50, 50])],\n                1: [np.array([30, 70])]\n            },\n            \"alpha\": 1.0,\n            \"priors_override\": None,\n            \"validation\": [{\"x\": [1], \"y\": 1}, {\"x\": [0], \"y\": 0},\n                           {\"x\": [1], \"y\": 0}, {\"x\": [0], \"y\": 1}]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _calculate_expected_log_loss(\n            D=case[\"D\"],\n            K=case[\"K\"],\n            counts=case[\"counts\"],\n            alpha=case[\"alpha\"],\n            priors_override=case[\"priors_override\"],\n            validation=case[\"validation\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef _calculate_expected_log_loss(D, K, counts, alpha, priors_override, validation):\n    \"\"\"\n    Computes the expected log-loss for a single test case.\n    \"\"\"\n    \n    # --- 1. Construct Class Priors ---\n    if priors_override:\n        priors = np.array(priors_override, dtype=float)\n    else:\n        # As per problem, total counts per class are consistent across features.\n        # We can use the first feature's counts to determine total class counts.\n        N0 = np.sum(counts[0][0])\n        N1 = np.sum(counts[1][0])\n        N_total = N0 + N1\n        priors = np.array([N0 / N_total, N1 / N_total])\n    \n    log_priors = np.log(priors)\n    \n    # --- 2. Construct Class-Conditional Likelihoods ---\n    log_likelihoods = {0: [], 1: []}\n    for y_class in [0, 1]:\n        # Total samples for this class\n        N_y = np.sum(counts[y_class][0])\n        for d in range(D):\n            # Denominator for Laplace smoothing\n            denominator = N_y + alpha * K[d]\n            # Probabilities for each bin of feature d\n            probs = (counts[y_class][d] + alpha) / denominator\n            log_likelihoods[y_class].append(np.log(probs))\n            \n    # --- 3. Compute Log-Loss on Validation Set ---\n    total_log_loss = 0.0\n    num_samples = len(validation)\n    \n    for sample in validation:\n        x_vec = sample[\"x\"]\n        y_true = sample[\"y\"]\n        \n        # Calculate unnormalized log-posterior scores S_y(x)\n        log_scores = np.zeros(2)\n        for y_class in [0, 1]:\n            score = log_priors[y_class]\n            for d in range(D):\n                bin_index = x_vec[d]\n                score += log_likelihoods[y_class][d][bin_index]\n            log_scores[y_class] = score\n            \n        # Compute posterior probabilities\n        # P(Y=1|X) = 1 / (1 + exp(S_0 - S_1))\n        log_odds_ratio = log_scores[1] - log_scores[0]\n        p1 = 1.0 / (1.0 + np.exp(-log_odds_ratio))\n        \n        posteriors = np.array([1.0 - p1, p1])\n        \n        # Get probability assigned to the true class\n        p_true = posteriors[y_true]\n        \n        # Add negative log-likelihood to total\n        total_log_loss += -np.log(p_true)\n        \n    # --- 4. Return Average Log-Loss ---\n    return total_log_loss / num_samples\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}