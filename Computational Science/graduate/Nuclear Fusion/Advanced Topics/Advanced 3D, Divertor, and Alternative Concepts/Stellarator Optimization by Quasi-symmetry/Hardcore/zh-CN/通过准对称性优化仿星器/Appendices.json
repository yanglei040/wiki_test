{
    "hands_on_practices": [
        {
            "introduction": "这个首个练习将向您介绍评估仿星器构型的基本任务。您将学习计算磁场强度在布泽尔坐标系下的傅里叶谱，这是诊断等离子体约束性质的关键步骤。通过基于此谱实现一个准对称性度量，您将获得量化给定设计接近理想约束状态程度的实践经验。",
            "id": "3719824",
            "problem": "您的任务是计算 Boozer 坐标中磁场强度的二维傅里叶谱，以评估选定磁通面上的准对称性 (QS)。请从直场线坐标中的磁场表示以及磁通面上 Boozer 坐标的定义开始推导。假设以下基本关系作为您推导的基础：(i) 直场线角度中的磁场具有逆变表示 $\\mathbf{B} = \\nabla \\psi \\times \\nabla \\theta + \\iota(\\psi)\\,\\nabla \\phi \\times \\nabla \\psi$，(ii) 在 Boozer 坐标中，$\\mathbf{B}$ 的协变分量是磁通函数，因此 Boozer 雅可比行列式 $J_{\\mathrm{B}}$ 满足 $J_{\\mathrm{B}}(\\psi,\\theta,\\phi) = \\left(G(\\psi)+\\iota(\\psi) I(\\psi)\\right)/B^{2}(\\psi,\\theta,\\phi)$，以及 (iii) 给定磁通面上的磁场强度可以展开为关于 Boozer 角的双重傅里叶级数，$B(\\theta,\\phi) = \\sum_{m=-m_{\\max}}^{m_{\\max}} \\sum_{n=-n_{\\max}}^{n_{\\max}} B_{m,n}\\,\\mathrm{e}^{\\mathrm{i}(m\\theta - n\\phi)}$。具有整数 $M$ 和 $N$ 的准对称性，其特征是满足选择定则 $mM - nN = 0$ 的模式占主导地位，这对应于 $B(\\theta,\\phi)$ 主要依赖于一个螺旋角组合。\n\n您的程序必须：\n1. 在指定的均匀角度网格上，使用一个主导螺旋模和几个次主导非共振模的叠加，构建合成的 Boozer 坐标场 $B(\\theta,\\phi)$。所有角度均使用弧度。\n2. 使用标准的未加权双角度平均值计算离散傅里叶系数 $B_{m,n}$：\n$$\nB_{m,n} \\approx \\frac{1}{N_{\\theta} N_{\\phi}} \\sum_{j=0}^{N_{\\theta}-1}\\sum_{k=0}^{N_{\\phi}-1} B(\\theta_{j},\\phi_{k})\\,\\mathrm{e}^{-\\mathrm{i}(m\\theta_{j} - n\\phi_{k})},\n$$\n其中 $\\theta_{j} = 2\\pi j/N_{\\theta}$ 且 $\\phi_{k} = 2\\pi k/N_{\\phi}$。对于下面定义的合成余弦内容，此近似在均匀网格上是精确的。\n3. 通过以下比率量化准对称性：\n$$\n\\mathcal{R} = \\frac{\\sum_{(m,n)\\in \\mathcal{S}} \\lvert B_{m,n}\\rvert^{2}}{\\sum_{(m,n)\\neq (0,0)} \\lvert B_{m,n}\\rvert^{2}},\n$$\n其中 $\\mathcal{S} = \\{(m,n) \\in \\mathbb{Z}^{2} : mM - nN = 0,\\ (m,n)\\neq(0,0)\\}$。从分子和分母中都排除平均模 $(0,0)$。如果分母为零（均匀场），则定义 $\\mathcal{R} = 1$。\n4. 将 $\\mathcal{R}$ 与特定情况的阈值 $\\tau$ 进行比较，并返回一个布尔值，指示是否满足 $\\mathcal{R} \\ge \\tau$。\n\n为您提供了一个包含四种情况的测试套件。在每种情况下，将 $I(\\psi)$ 和 $G(\\psi)$ 视为给定的磁通函数（在磁通面上为常数）；为完整起见，它们被包含在内，这些信息来自变分矩平衡代码 (Variational Moments Equilibrium Code, VMEC) 的输出，但从均匀 Boozer 网格计算傅里叶级数时并不需要它们。所有角度必须以弧度为单位，基础磁场强度 $B_{0}$ 必须解释为特斯拉；然而，最终输出是无量纲的布尔值，不需要单位。对于每种情况，合成\n$$\nB(\\theta,\\phi) = B_{0}\\left[1 + \\varepsilon \\cos(m_{0}\\theta - n_{0}\\phi)\\right] + \\sum_{\\ell=1}^{L} a_{\\ell}\\cos(m_{\\ell}\\theta - n_{\\ell}\\phi + \\varphi_{\\ell}),\n$$\n使用指定的振幅和相位 $\\varphi_{\\ell}$。\n\n测试套件（每种情况都是一个参数元组）：\n- 情况 1（理想情况，强准对称性）：\n    - 网格：$N_{\\theta} = 64$, $N_{\\phi} = 64$。\n    - 类似 VMEC 的磁通函数：$I(\\psi) = 2.0$, $G(\\psi) = 3.0$。\n    - 对称性整数：$M=1$, $N=1$。\n    - 基础磁场：$B_{0} = 3.0$ 特斯拉。\n    - 主导模式：$(m_{0},n_{0}) = (1,1)$，$\\varepsilon = 0.2$。\n    - 非共振模式：$[(2,1,0.02,0.0), (1,0,0.015,0.3), (3,2,0.01,1.0)]$，解释为 $(m_{\\ell},n_{\\ell},a_{\\ell},\\varphi_{\\ell})$。\n    - 谱范围：$m_{\\max}=4$, $n_{\\max}=4$。\n    - 阈值：$\\tau = 0.9$。\n- 情况 2（接近边界，中等准对称性）：\n    - 网格：$N_{\\theta} = 64$, $N_{\\phi} = 64$。\n    - 类似 VMEC 的磁通函数：$I(\\psi) = 1.0$, $G(\\psi) = 2.5$。\n    - 对称性整数：$M=2$, $N=1$。\n    - 基础磁场：$B_{0} = 2.5$ 特斯拉。\n    - 主导模式：$(m_{0},n_{0}) = (1,2)$，$\\varepsilon = 0.05$。\n    - 非共振模式：$[(1,0,0.04,0.2), (0,1,0.03,0.5), (3,1,0.03,0.7)]$。\n    - 谱范围：$m_{\\max}=4$, $n_{\\max}=4$。\n    - 阈值：$\\tau = 0.6$。\n- 情况 3（非准对称，预期失败）：\n    - 网格：$N_{\\theta} = 64$, $N_{\\phi} = 64$。\n    - 类似 VMEC 的磁通函数：$I(\\psi) = 0.5$, $G(\\psi) = 3.5$。\n    - 对称性整数：$M=3$, $N=1$。\n    - 基础磁场：$B_{0} = 2.8$ 特斯拉。\n    - 主导模式：无（设置 $\\varepsilon = 0$）。\n    - 非共振模式：$[(1,0,0.06,0.1), (2,3,0.05,0.4), (3,0,0.04,1.1)]$。\n    - 谱范围：$m_{\\max}=5$, $n_{\\max}=5$。\n    - 阈值：$\\tau = 0.5$。\n- 情况 4（边缘情况，均匀场）：\n    - 网格：$N_{\\theta} = 64$, $N_{\\phi} = 64$。\n    - 类似 VMEC 的磁通函数：$I(\\psi) = 1.0$, $G(\\psi) = 1.0$。\n    - 对称性整数：$M=1$, $N=1$。\n    - 基础磁场：$B_{0} = 3.2$ 特斯拉。\n    - 主导模式：无（设置 $\\varepsilon = 0$）。\n    - 非共振模式：空列表。\n    - 谱范围：$m_{\\max}=3$, $n_{\\max}=3$。\n    - 阈值：$\\tau = 0.99$。\n\n您的程序必须：\n- 为每种情况实现 $B(\\theta,\\phi)$ 的合成，在规定的谱范围内计算离散谱 $B_{m,n}$，计算 $\\mathcal{R}$，与 $\\tau$ 比较，并输出一行，其中包含一个含有四个布尔值的列表 $[\\text{case1},\\text{case2},\\text{case3},\\text{case4}]$，指示每种情况是否满足所述准则下的准对称性。\n- 最终输出必须是精确的一行，列表以方括号括起来的 Python 布尔字面量形式打印。",
            "solution": "该问题是有效的，因为它科学地基于等离子体物理和仿星器理论的原理，问题设定良好，目标明确且包含所有必要数据，并以客观、正式的语言表达。因此，我们可以着手解决。\n\n目标是评估在磁通面上人工生成的磁场强度 $B$ 的准对称性 (QS) 程度。准对称性是仿星器中磁场构型的一个属性，其中当用布泽尔坐标 $(\\theta, \\phi)$ 表示时，磁场强度是单个螺旋角的函数，即 $B = B(m\\theta - n\\phi)$。这意味着 $B$ 的傅里叶谱由满足特定线性关系 $mM - nN = 0$（对于某些整数 $M$ 和 $N$）的模式 $(m, n)$ 主导。\n\n问题为给定磁通面上的磁场强度提供了一个合成模型：\n$$\nB(\\theta,\\phi) = B_{0}\\left[1 + \\varepsilon \\cos(m_{0}\\theta - n_{0}\\phi)\\right] + \\sum_{\\ell=1}^{L} a_{\\ell}\\cos(m_{\\ell}\\theta - n_{\\ell}\\phi + \\varphi_{\\ell})\n$$\n我们被要求计算二维傅里叶谱 $B_{m,n}$，并用它来计算准对称性度量 $\\mathcal{R}$。磁场由傅里叶级数表示：\n$$\nB(\\theta,\\phi) = \\sum_{m,n} B_{m,n}\\,\\mathrm{e}^{\\mathrm{i}(m\\theta - n\\phi)}\n$$\n问题指出，对于给定的 $B(\\theta,\\phi)$ 的合成形式，所提供的离散傅里叶变换公式会产生精确的结果。这使我们能够解析地确定系数 $B_{m,n}$，这比 DFT 的数值实现更精确。\n\n我们使用欧拉公式 $\\cos(x) = \\frac{1}{2}(\\mathrm{e}^{\\mathrm{i}x} + \\mathrm{e}^{-\\mathrm{i}x})$ 来分解 $B(\\theta, \\phi)$ 表达式中的每个余弦项。\n一个形如 $\\alpha \\cos(m_k\\theta - n_k\\phi + \\varphi_k)$ 的通用项可以写为：\n$$\n\\alpha \\cos(m_k\\theta - n_k\\phi + \\varphi_k) = \\frac{\\alpha}{2}\\left( \\mathrm{e}^{\\mathrm{i}(m_k\\theta - n_k\\phi + \\varphi_k)} + \\mathrm{e}^{-\\mathrm{i}(m_k\\theta - n_k\\phi + \\varphi_k)} \\right)\n$$\n$$\n= \\left(\\frac{\\alpha}{2}\\mathrm{e}^{\\mathrm{i}\\varphi_k}\\right)\\mathrm{e}^{\\mathrm{i}(m_k\\theta - n_k\\phi)} + \\left(\\frac{\\alpha}{2}\\mathrm{e}^{-\\mathrm{i}\\varphi_k}\\right)\\mathrm{e}^{\\mathrm{i}(-m_k\\theta - (-n_k)\\phi)}\n$$\n通过将其与傅里叶级数的定义进行比较，我们可以识别出系数：\n- 项 $\\mathrm{e}^{\\mathrm{i}(m_k\\theta - n_k\\phi)}$ 对系数 $B_{m_k,n_k}$ 有贡献。\n- 项 $\\mathrm{e}^{\\mathrm{i}(-m_k\\theta - (-n_k)\\phi)}$ 对系数 $B_{-m_k,-n_k}$ 有贡献。\n\n因此，对于每个余弦分量，我们都有一对非零的傅里叶系数：\n- $B_{m_k,n_k} = \\frac{\\alpha}{2}\\mathrm{e}^{\\mathrm{i}\\varphi_k}$\n- $B_{-m_k,-n_k} = \\frac{\\alpha}{2}\\mathrm{e}^{-\\mathrm{i}\\varphi_k} = (B_{m_k,n_k})^*$\n\n对于给定的 $B(\\theta,\\phi)$，完整的解析系数集合是：\n1.  常数项 $B_0$ 对应于 $(m,n)=(0,0)$ 模：$B_{0,0} = B_0$。\n2.  振幅为 $\\varepsilon B_0$、相位为 $\\varphi_0=0$ 的“主导”模给出：\n    $B_{m_0,n_0} = \\frac{\\varepsilon B_0}{2}$ 和 $B_{-m_0,-n_0} = \\frac{\\varepsilon B_0}{2}$。\n3.  每个振幅为 $a_\\ell$、相位为 $\\varphi_\\ell$ 的“非共振”模 $\\ell$ 给出：\n    $B_{m_\\ell,n_\\ell} = \\frac{a_\\ell}{2}\\mathrm{e}^{\\mathrm{i}\\varphi_\\ell}$ 和 $B_{-m_\\ell,-n_\\ell} = \\frac{a_\\ell}{2}\\mathrm{e}^{-\\mathrm{i}\\varphi_\\ell}$。\n\n有了这些系数，我们计算准对称性比率 $\\mathcal{R}$：\n$$\n\\mathcal{R} = \\frac{\\sum_{(m,n)\\in \\mathcal{S}} \\lvert B_{m,n}\\rvert^{2}}{\\sum_{(m,n)\\neq (0,0)} \\lvert B_{m,n}\\rvert^{2}}\n$$\n其中 $\\mathcal{S} = \\{(m,n) \\in \\mathbb{Z}^{2} : mM - nN = 0, (m,n)\\neq(0,0)\\}$。分子是所有满足准对称性条件的非零、非直流傅里叶系数的模的平方和。分母是所有非直流傅里叶系数的模的平方和。\n如果分母为零（即场是均匀的，$B=B_0$），$\\mathcal{R}$ 定义为 $1$。\n\n每个测试用例的算法如下：\n1.  初始化一个字典来存储非零、非直流模式的复傅里叶系数 $B_{m,n}$。\n2.  解析地计算主导模式和非共振模式的系数，并填充字典。对于模式 $(m, n, \\alpha, \\varphi)$，我们将 $\\frac{\\alpha}{2}\\mathrm{e}^{\\mathrm{i}\\varphi}$ 添加到 $(m,n)$ 的字典条目中，将 $\\frac{\\alpha}{2}\\mathrm{e}^{-\\mathrm{i}\\varphi}$ 添加到 $(-m,-n)$ 的条目中。\n3.  通过对字典中所有条目的 $|B_{m,n}|^2$ 求和来计算分母项。\n4.  仅对满足特定情况对称条件 $mM - nN = 0$ 的条目 $(m,n)$ 求和 $|B_{m,n}|^2$ 来计算分子项。\n5.  计算 $\\mathcal{R}$，处理分母为零的特殊情况。\n6.  将 $\\mathcal{R}$ 与阈值 $\\tau$ 进行比较，并确定布尔结果。\n\n对于给定的问题结构，这种解析方法是精确的，并避免了数值 FFT 实现的复杂性和潜在的浮点不精确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the quasi-symmetry problem for a suite of four test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, strong quasi-symmetry)\n        {\n            \"grid\": (64, 64), \"vmec\": (2.0, 3.0), \"symmetry\": (1, 1),\n            \"base_field\": 3.0, \"dominant_mode\": (1, 1, 0.2), \n            \"off_resonant_modes\": [(2, 1, 0.02, 0.0), (1, 0, 0.015, 0.3), (3, 2, 0.01, 1.0)],\n            \"spectral_bounds\": (4, 4), \"threshold\": 0.9\n        },\n        # Case 2 (near boundary, moderate quasi-symmetry)\n        {\n            \"grid\": (64, 64), \"vmec\": (1.0, 2.5), \"symmetry\": (2, 1),\n            \"base_field\": 2.5, \"dominant_mode\": (1, 2, 0.05),\n            \"off_resonant_modes\": [(1, 0, 0.04, 0.2), (0, 1, 0.03, 0.5), (3, 1, 0.03, 0.7)],\n            \"spectral_bounds\": (4, 4), \"threshold\": 0.6\n        },\n        # Case 3 (non-quasi-symmetric, failure expected)\n        {\n            \"grid\": (64, 64), \"vmec\": (0.5, 3.5), \"symmetry\": (3, 1),\n            \"base_field\": 2.8, \"dominant_mode\": (0, 0, 0.0),\n            \"off_resonant_modes\": [(1, 0, 0.06, 0.1), (2, 3, 0.05, 0.4), (3, 0, 0.04, 1.1)],\n            \"spectral_bounds\": (5, 5), \"threshold\": 0.5\n        },\n        # Case 4 (edge case, uniform field)\n        {\n            \"grid\": (64, 64), \"vmec\": (1.0, 1.0), \"symmetry\": (1, 1),\n            \"base_field\": 3.2, \"dominant_mode\": (0, 0, 0.0),\n            \"off_resonant_modes\": [],\n            \"spectral_bounds\": (3, 3), \"threshold\": 0.99\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        M, N = case[\"symmetry\"]\n        B0 = case[\"base_field\"]\n        m0, n0, epsilon = case[\"dominant_mode\"]\n        off_resonant = case[\"off_resonant_modes\"]\n        tau = case[\"threshold\"]\n\n        # Use a defaultdict to store complex Fourier coefficients B_mn\n        # for (m,n) != (0,0)\n        coeffs = defaultdict(complex)\n\n        # Process dominant mode\n        if epsilon > 0.0:\n            m, n = m0, n0\n            alpha = B0 * epsilon\n            # For a cosine term alpha*cos(m*theta - n*phi), the coefficients are\n            # B_mn = alpha/2 and B_-m,-n = alpha/2\n            if m != 0 or n != 0:\n                coeffs[(m, n)] += alpha / 2.0\n                coeffs[(-m, -n)] += alpha / 2.0\n\n        # Process off-resonant modes\n        for m_l, n_l, a_l, phi_l in off_resonant:\n            m, n = m_l, n_l\n            alpha = a_l\n            val = (alpha / 2.0) * np.exp(1j * phi_l)\n            # For a term a*cos(m*theta - n*phi + phi_l), the coefficients are\n            # B_mn = (a/2)*exp(i*phi_l) and B_-m,-n = (a/2)*exp(-i*phi_l)\n            if m != 0 or n != 0:\n                coeffs[(m, n)] += val\n                coeffs[(-m, -n)] += np.conj(val)\n\n        # Calculate the numerator and denominator for the ratio R\n        numerator_sum_sq = 0.0\n        denominator_sum_sq = 0.0\n\n        for (m, n), b_mn in coeffs.items():\n            power = np.abs(b_mn)**2\n            denominator_sum_sq += power\n            \n            # Check for quasi-symmetry condition: mM - nN = 0\n            if m * M - n * N == 0:\n                numerator_sum_sq += power\n\n        # Calculate R\n        if denominator_sum_sq == 0.0:\n            # Uniform field case, as defined in the problem\n            R = 1.0\n        else:\n            R = numerator_sum_sq / denominator_sum_sq\n            \n        results.append(R >= tau)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在掌握了如何量化准对称性之后，本练习将深入探讨仿星器设计的“优化”方面。您将探索准对称性度量如何响应磁场傅里叶系数的微小变化，这些系数代表了对等离子体边界形状的扰动。通过推导和验证准对称性泛函的梯度和Hessian矩阵，您将掌握基于梯度的优化算法所需的核心数学工具。",
            "id": "3719834",
            "problem": "考虑一个仿星器构型，其特征在于角向角 $\\theta$ 和环向角 $\\zeta$（角度必须以弧度处理）。在准对称（QS）中，磁场强度 $B$ 应仅依赖于由 $\\alpha = M \\theta - N \\zeta$ 定义的螺旋角 $\\alpha$，其中 $M$ 和 $N$ 是描述准对称螺旋性的固定整数。准对称的一个基本特征是，$B(\\theta,\\zeta)$ 对 $\\alpha$ 的单变量依赖性的偏离，会通过一个泛函进行惩罚，该泛函测量 $\\nabla B$ 在与 $\\alpha$ 变化相关方向正交的分量。\n\n从以下基本基础出发：\n- 在具有周期性角度的环形系统中，任何足够光滑的 $B(\\theta,\\zeta)$ 都可以用有限傅里叶级数表示。螺旋谐波 $\\cos(m \\theta - n \\zeta)$ 和 $\\sin(m \\theta - n \\zeta)$ 在 $2\\pi$-周期的环面上构成一个正交基。\n- 如果 $B(\\theta,\\zeta)$ 仅依赖于 $\\alpha = M \\theta - N \\zeta$，那么梯度 $\\nabla B$ 完全位于 $(\\theta,\\zeta)$ 平面中向量 $(M,-N)$ 的张成空间内，因此 $\\nabla B$ 任何与 $(M,-N)$ 正交的分量都表示对准对称性的违背。\n- 准对称违背泛函 $\\mathcal{R}_{\\mathrm{QS}}$ 可以定义为 $\\nabla B$ 在与 $(M,-N)$ 正交的分量的模平方在 $2\\pi$-周期域上的面积分。\n\n设磁场强度由傅里叶级数近似表示\n$$\nB(\\theta,\\zeta) = B_0 + \\sum_{k=1}^{K} \\left[a_k \\cos(m_k \\theta - n_k \\zeta) + b_k \\sin(m_k \\theta - n_k \\zeta)\\right],\n$$\n其中 $B_0$ 是一个常数，$\\{(m_k,n_k)\\}_{k=1}^{K}$ 是指定的整数模数对。令参数向量 $x \\in \\mathbb{R}^{2K}$ 集合了傅里叶系数，即 $x = (a_1,\\dots,a_K,b_1,\\dots,b_K)$。考虑一个由方向 $p \\in \\mathbb{R}^{2K}$ 和振幅 $\\varepsilon \\in \\mathbb{R}$ 代表的边界形状的微小扰动，导致扰动后的系数为 $x(\\varepsilon) = x_0 + \\varepsilon p$。\n\n任务：\n1. 使用上述定义，从第一性原理出发，推导 $\\mathcal{R}_{\\mathrm{QS}}(x)$ 关于傅里叶系数 $\\{a_k,b_k\\}$、螺旋性 $(M,N)$ 和模数整数 $(m_k,n_k)$ 的二次型。然后，推导其关于 $x$ 的梯度 $\\nabla \\mathcal{R}_{\\mathrm{QS}}(x)$ 和 Hessian 矩阵 $H(x)$。\n2. 对于给定的 $x_0$、方向 $p$ 和小振幅 $\\varepsilon$，推导 $\\mathcal{R}_{\\mathrm{QS}}$ 变化的二阶泰勒预测：\n$$\n\\Delta^{(2)}(\\varepsilon) = \\frac{1}{2}\\varepsilon^2\\, p^\\top H(x_0)\\, p.\n$$\n同时推导在 $\\varepsilon = 0$ 处沿 $p$ 方向的有限差分中心二阶导数：\n$$\nD^{(2)}_{\\mathrm{FD}}(\\varepsilon) = \\frac{\\mathcal{R}_{\\mathrm{QS}}(x_0+\\varepsilon p) - 2\\,\\mathcal{R}_{\\mathrm{QS}}(x_0) + \\mathcal{R}_{\\mathrm{QS}}(x_0-\\varepsilon p)}{\\varepsilon^2}.\n$$\n3. 通过为每个测试用例检查两个条件来验证该二次模型：\n   - 中心二阶导数 $D^{(2)}_{\\mathrm{FD}}(\\varepsilon)$ 在指定公差内与 $p^\\top H(x_0)\\, p$ 匹配。\n   - 实际变化量 $\\mathcal{R}_{\\mathrm{QS}}(x_0+\\varepsilon p) - \\mathcal{R}_{\\mathrm{QS}}(x_0) - \\varepsilon\\, \\nabla \\mathcal{R}_{\\mathrm{QS}}(x_0)^\\top p$ 在相同公差内等于 $\\Delta^{(2)}(\\varepsilon)$。\n\n本问题中的所有量均为无量纲。角度必须以弧度处理。您的程序必须实现所推导的表达式，并对以下参数值测试套件进行验证：\n\n- 测试用例 1 (一般情况):\n  - $(M,N) = (1,4)$,\n  - 模数: $[(1,0),(2,1),(3,-2)]$,\n  - $x_0$: $a = [0.3,-0.12,0.05]$, $b = [0.1,0.2,-0.07]$,\n  - $p$: $p_a = [0.05,-0.03,0.02]$, $p_b = [-0.02,0.01,0.04]$,\n  - $\\varepsilon = 10^{-3}$,\n  - 公差: $10^{-12}$.\n\n- 测试用例 2 (螺旋对齐，边界条件):\n  - $(M,N) = (2,3)$,\n  - 模数: $[(2,3)]$,\n  - $x_0$: $a = [0.7]$, $b = [-0.5]$,\n  - $p$: $p_a = [0.1]$, $p_b = [-0.2]$,\n  - $\\varepsilon = 10^{-6}$,\n  - 公差: $10^{-18}$.\n\n- 测试用例 3 (零基底系数):\n  - $(M,N) = (1,1)$,\n  - 模数: $[(1,2),(2,1)]$,\n  - $x_0$: $a = [0.0,0.0]$, $b = [0.0,0.0]$,\n  - $p$: $p_a = [0.2,-0.15]$, $p_b = [0.05,0.1]$,\n  - $\\varepsilon = 10^{-4}$,\n  - 公差: $10^{-12}$.\n\n- 测试用例 4 (极小扰动振幅):\n  - $(M,N) = (3,1)$,\n  - 模数: $[(1,1),(2,3),(4,-1)]$,\n  - $x_0$: $a = [0.25,-0.08,0.12]$, $b = [-0.05,0.06,-0.09]$,\n  - $p$: $p_a = [0.01,0.02,-0.015]$, $p_b = [0.02,-0.01,0.005]$,\n  - $\\varepsilon = 10^{-12}$,\n  - 公差: $10^{-18}$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,result_3,result_4]$），其中每个 $result_i$ 是一个布尔值，指示任务 3 中的两个验证是否都对相应的测试用例通过。",
            "solution": "该问题被评估为有效。它在科学上基于等离子体物理和仿星器设计的原理，特别是准对称的概念。该问题是适定的，提供了所有必要的数学定义、参数和约束。语言客观、正式。这些任务构成了微积分、线性代数和数值验证的标准练习，内容自洽，没有矛盾或歧义。\n\n### 推导\n\n解决方案需要推导准对称残差泛函 $\\mathcal{R}_{\\mathrm{QS}}$、其梯度和 Hessian 矩阵，然后验证其二次模型。\n\n**1. 泛函 $\\mathcal{R}_{\\mathrm{QS}}(x)$ 的推导**\n\n问题将准对称违背泛函 $\\mathcal{R}_{\\mathrm{QS}}$ 定义为磁场梯度 $\\nabla B$ 与螺旋方向向量正交的分量的模平方的面积分。\n\n在 $(\\theta, \\zeta)$ 坐标平面中的螺旋方向由向量 $v_h = (M, -N)$ 给出。与 $v_h$ 正交的向量是 $v_h^{\\perp} = (N, M)$。$\\nabla B$ 与 $v_h$ 正交的分量的模平方由 $\\nabla B$ 在 $v_h^{\\perp}$ 上的投影的平方给出：\n$$\n\\left| \\text{proj}_{v_h^{\\perp}}(\\nabla B) \\right|^2 = \\frac{(\\nabla B \\cdot v_h^{\\perp})^2}{\\|v_h^{\\perp}\\|^2} = \\frac{\\left( N \\frac{\\partial B}{\\partial \\theta} + M \\frac{\\partial B}{\\partial \\zeta} \\right)^2}{N^2 + M^2}\n$$\n泛函 $\\mathcal{R}_{\\mathrm{QS}}$ 是该量在环形域上的积分，该域在 $\\theta$ 和 $\\zeta$ 上均跨越 $2\\pi$：\n$$\n\\mathcal{R}_{\\mathrm{QS}} = \\int_0^{2\\pi} \\int_0^{2\\pi} \\frac{1}{M^2+N^2} \\left( N \\frac{\\partial B}{\\partial \\theta} + M \\frac{\\partial B}{\\partial \\zeta} \\right)^2 d\\theta d\\zeta\n$$\n磁场 $B(\\theta, \\zeta)$ 由傅里叶级数给出：\n$$\nB(\\theta,\\zeta) = B_0 + \\sum_{k=1}^{K} \\left[a_k \\cos(m_k \\theta - n_k \\zeta) + b_k \\sin(m_k \\theta - n_k \\zeta)\\right]\n$$\n其偏导数为：\n$$\n\\frac{\\partial B}{\\partial \\theta} = \\sum_{k=1}^{K} \\left[ -a_k m_k \\sin(m_k \\theta - n_k \\zeta) + b_k m_k \\cos(m_k \\theta - n_k \\zeta) \\right]\n$$\n$$\n\\frac{\\partial B}{\\partial \\zeta} = \\sum_{k=1}^{K} \\left[ a_k n_k \\sin(m_k \\theta - n_k \\zeta) - b_k n_k \\cos(m_k \\theta - n_k \\zeta) \\right]\n$$\n我们构造积分括号内的线性组合：\n$$\nN \\frac{\\partial B}{\\partial \\theta} + M \\frac{\\partial B}{\\partial \\zeta} = \\sum_{k=1}^{K} \\left[ (-N m_k a_k + M n_k a_k) \\sin(\\phi_k) + (N m_k b_k - M n_k b_k) \\cos(\\phi_k) \\right]\n$$\n其中 $\\phi_k = m_k \\theta - n_k \\zeta$。令 $\\delta_k = M n_k - N m_k$。表达式简化为：\n$$\nN \\frac{\\partial B}{\\partial \\theta} + M \\frac{\\partial B}{\\partial \\zeta} = \\sum_{k=1}^{K} \\delta_k \\left[ a_k \\sin(\\phi_k) - b_k \\cos(\\phi_k) \\right]\n$$\n将其代入积分并对和进行平方，得到：\n$$\n\\mathcal{R}_{\\mathrm{QS}} = \\frac{1}{M^2+N^2} \\int_0^{2\\pi} \\int_0^{2\\pi} \\left( \\sum_{k=1}^{K} \\delta_k [a_k \\sin(\\phi_k) - b_k \\cos(\\phi_k)] \\right) \\left( \\sum_{j=1}^{K} \\delta_j [a_j \\sin(\\phi_j) - b_j \\cos(\\phi_j)] \\right) d\\theta d\\zeta\n$$\n由于三角基函数在域 $[0, 2\\pi] \\times [0, 2\\pi]$ 上的正交性，交叉项（其中 $k \\neq j$）的积分为零。我们使用以下恒等式（对于非零模数 $(m_k,n_k)$）：\n$$\n\\int_0^{2\\pi} \\int_0^{2\\pi} \\sin^2(\\phi_k) d\\theta d\\zeta = 2\\pi^2, \\quad \\int_0^{2\\pi} \\int_0^{2\\pi} \\cos^2(\\phi_k) d\\theta d\\zeta = 2\\pi^2, \\quad \\int_0^{2\\pi} \\int_0^{2\\pi} \\sin(\\phi_k)\\cos(\\phi_k) d\\theta d\\zeta = 0\n$$\n因此，泛函简化为对角线项（$k=j$）的和：\n$$\n\\mathcal{R}_{\\mathrm{QS}} = \\frac{1}{M^2+N^2} \\sum_{k=1}^{K} \\delta_k^2 \\int_0^{2\\pi} \\int_0^{2\\pi} [a_k^2 \\sin^2(\\phi_k) + b_k^2 \\cos^2(\\phi_k)] d\\theta d\\zeta\n$$\n$$\n\\mathcal{R}_{\\mathrm{QS}} = \\frac{1}{M^2+N^2} \\sum_{k=1}^{K} \\delta_k^2 [a_k^2 (2\\pi^2) + b_k^2 (2\\pi^2)]\n$$\n这给出了泛函关于系数 $x = (a_1, \\dots, a_K, b_1, \\dots, b_K)$ 的最终二次型：\n$$\n\\mathcal{R}_{\\mathrm{QS}}(x) = \\frac{2\\pi^2}{M^2+N^2} \\sum_{k=1}^{K} (M n_k - N m_k)^2 (a_k^2 + b_k^2)\n$$\n\n**2. 梯度 $\\nabla \\mathcal{R}_{\\mathrm{QS}}(x)$ 和 Hessian 矩阵 $H(x)$ 的推导**\n\n梯度 $\\nabla \\mathcal{R}_{\\mathrm{QS}}(x)$ 是一个关于 $x$ 分量的 $2K$ 维偏导数向量。对于给定的模数索引 $j \\in \\{1, \\dots, K\\}$：\n$$\n\\frac{\\partial \\mathcal{R}_{\\mathrm{QS}}}{\\partial a_j} = \\frac{\\partial}{\\partial a_j} \\left( \\frac{2\\pi^2}{M^2+N^2} \\sum_{k=1}^{K} \\delta_k^2 (a_k^2 + b_k^2) \\right) = \\frac{2\\pi^2}{M^2+N^2} \\delta_j^2 (2 a_j) = \\frac{4\\pi^2}{M^2+N^2} (M n_j - N m_j)^2 a_j\n$$\n类似地，对于系数 $b_j$：\n$$\n\\frac{\\partial \\mathcal{R}_{\\mathrm{QS}}}{\\partial b_j} = \\frac{4\\pi^2}{M^2+N^2} (M n_j - N m_j)^2 b_j\n$$\nHessian 矩阵 $H(x)$ 是二阶偏导数的 $2K \\times 2K$ 矩阵。由于 $\\mathcal{R}_{\\mathrm{QS}}(x)$ 是一个纯二次函数，不同模数之间或 $a_k$ 与 $b_j$ 之间没有交叉项，因此 Hessian 矩阵是一个常数对角矩阵。对角元素为：\n$$\nH_{a_j, a_j} = \\frac{\\partial^2 \\mathcal{R}_{\\mathrm{QS}}}{\\partial a_j^2} = \\frac{4\\pi^2}{M^2+N^2} (M n_j - N m_j)^2\n$$\n$$\nH_{b_j, b_j} = \\frac{\\partial^2 \\mathcal{R}_{\\mathrm{QS}}}{\\partial b_j^2} = \\frac{4\\pi^2}{M^2+N^2} (M n_j - N m_j)^2\n$$\n所有非对角元素均为零。对于给定的 $k$，对应于 $a_k$ 和 $b_k$ 的对角元素是相同的。\n\n**3. 验证表达式**\n\n问题要求基于在 $x_0$ 附近的泰勒展开来验证两个恒等式。\n$\\mathcal{R}_{\\mathrm{QS}}(x_0 + \\varepsilon p)$ 的泰勒级数为：\n$$\n\\mathcal{R}_{\\mathrm{QS}}(x_0 + \\varepsilon p) = \\mathcal{R}_{\\mathrm{QS}}(x_0) + \\varepsilon \\nabla \\mathcal{R}_{\\mathrm{QS}}(x_0)^\\top p + \\frac{1}{2} \\varepsilon^2 p^\\top H(x_0) p + O(\\varepsilon^3)\n$$\n由于 $\\mathcal{R}_{\\mathrm{QS}}$ 是一个二次多项式，展开是精确的，$O(\\varepsilon^3)$ 及更高阶的项为零。\n\n- **条件 1 验证: $D^{(2)}_{\\mathrm{FD}}(\\varepsilon) = p^\\top H(x_0) p$**\n二阶导数的中心有限差分公式为：\n$$\nD^{(2)}_{\\mathrm{FD}}(\\varepsilon) = \\frac{\\mathcal{R}_{\\mathrm{QS}}(x_0+\\varepsilon p) - 2\\mathcal{R}_{\\mathrm{QS}}(x_0) + \\mathcal{R}_{\\mathrm{QS}}(x_0-\\varepsilon p)}{\\varepsilon^2}\n$$\n使用 $\\mathcal{R}_{\\mathrm{QS}}(x_0 \\pm \\varepsilon p)$ 的精确泰勒展开：\n$$\n\\mathcal{R}_{\\mathrm{QS}}(x_0 \\pm \\varepsilon p) = \\mathcal{R}_{\\mathrm{QS}}(x_0) \\pm \\varepsilon \\nabla \\mathcal{R}_{\\mathrm{QS}}(x_0)^\\top p + \\frac{1}{2}\\varepsilon^2 p^\\top H(x_0) p\n$$\n代入 $D^{(2)}_{\\mathrm{FD}}(\\varepsilon)$ 的分子：\n$$\n\\text{Numerator} = \\left(\\mathcal{R}_{\\mathrm{QS}}(x_0) + \\dots\\right) - 2\\mathcal{R}_{\\mathrm{QS}}(x_0) + \\left(\\mathcal{R}_{\\mathrm{QS}}(x_0) - \\dots\\right)\n$$\n$$\n= (\\varepsilon \\nabla \\mathcal{R}_{\\mathrm{QS}}(x_0)^\\top p - \\varepsilon \\nabla \\mathcal{R}_{\\mathrm{QS}}(x_0)^\\top p) + (\\frac{1}{2}\\varepsilon^2 p^\\top H p + \\frac{1}{2}\\varepsilon^2 p^\\top H p) = \\varepsilon^2 p^\\top H(x_0) p\n$$\n因此，解析上：\n$$\nD^{(2)}_{\\mathrm{FD}}(\\varepsilon) = \\frac{\\varepsilon^2 p^\\top H(x_0) p}{\\varepsilon^2} = p^\\top H(x_0) p\n$$\n数值检验验证 $|D^{(2)}_{\\mathrm{FD}}(\\varepsilon) - p^\\top H(x_0) p| \\le \\text{公差}$。\n\n- **条件 2 验证: $\\mathcal{R}_{\\mathrm{QS}}(x_0+\\varepsilon p) - \\mathcal{R}_{\\mathrm{QS}}(x_0) - \\varepsilon \\nabla \\mathcal{R}_{\\mathrm{QS}}(x_0)^\\top p = \\Delta^{(2)}(\\varepsilon)$**\n左侧（LHS）表示实际变化量减去一阶泰勒近似。右侧（RHS）是二阶项 $\\Delta^{(2)}(\\varepsilon) = \\frac{1}{2}\\varepsilon^2 p^\\top H(x_0) p$。\n根据精确泰勒展开：\n$$\n\\mathcal{R}_{\\mathrm{QS}}(x_0+\\varepsilon p) - \\mathcal{R}_{\\mathrm{QS}}(x_0) - \\varepsilon \\nabla \\mathcal{R}_{\\mathrm{QS}}(x_0)^\\top p = \\frac{1}{2}\\varepsilon^2 p^\\top H(x_0) p\n$$\n这表明 LHS 在解析上等于 RHS。数值检验验证 $| \\text{LHS} - \\text{RHS} | \\le \\text{公差}$。\n两个条件对于二次函数都是恒等式，因此验证主要测试实现的正确性并评估浮点精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the verification for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"M\": 1, \"N\": 4,\n            \"modes\": np.array([[1, 0], [2, 1], [3, -2]]),\n            \"x0_a\": np.array([0.3, -0.12, 0.05]),\n            \"x0_b\": np.array([0.1, 0.2, -0.07]),\n            \"p_a\": np.array([0.05, -0.03, 0.02]),\n            \"p_b\": np.array([-0.02, 0.01, 0.04]),\n            \"eps\": 1e-3,\n            \"tol\": 1e-12\n        },\n        {\n            \"M\": 2, \"N\": 3,\n            \"modes\": np.array([[2, 3]]),\n            \"x0_a\": np.array([0.7]),\n            \"x0_b\": np.array([-0.5]),\n            \"p_a\": np.array([0.1]),\n            \"p_b\": np.array([-0.2]),\n            \"eps\": 1e-6,\n            \"tol\": 1e-18\n        },\n        {\n            \"M\": 1, \"N\": 1,\n            \"modes\": np.array([[1, 2], [2, 1]]),\n            \"x0_a\": np.array([0.0, 0.0]),\n            \"x0_b\": np.array([0.0, 0.0]),\n            \"p_a\": np.array([0.2, -0.15]),\n            \"p_b\": np.array([0.05, 0.1]),\n            \"eps\": 1e-4,\n            \"tol\": 1e-12\n        },\n        {\n            \"M\": 3, \"N\": 1,\n            \"modes\": np.array([[1, 1], [2, 3], [4, -1]]),\n            \"x0_a\": np.array([0.25, -0.08, 0.12]),\n            \"x0_b\": np.array([-0.05, 0.06, -0.09]),\n            \"p_a\": np.array([0.01, 0.02, -0.015]),\n            \"p_b\": np.array([0.02, -0.01, 0.005]),\n            \"eps\": 1e-12,\n            \"tol\": 1e-18\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_verification(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calc_R_QS(M, N, modes, coeffs):\n    \"\"\"\n    Calculates the quasi-symmetry residual R_QS for a given set of coefficients.\n    \n    Args:\n        M, N (int): Helicity integers.\n        modes (np.ndarray): Array of (m_k, n_k) mode pairs, shape (K, 2).\n        coeffs (np.ndarray): Vector of coefficients [a_1,..,a_K, b_1,..,b_K].\n\n    Returns:\n        float: The value of the R_QS functional.\n    \"\"\"\n    K = modes.shape[0]\n    a = coeffs[:K]\n    b = coeffs[K:]\n    \n    m = modes[:, 0]\n    n = modes[:, 1]\n    \n    if M**2 + N**2 == 0:\n        return 0.0\n\n    delta = M * n - N * m\n    delta_sq = delta**2\n    \n    prefactor = (2 * np.pi**2) / (M**2 + N**2)\n    \n    sum_term = np.sum(delta_sq * (a**2 + b**2))\n    \n    return prefactor * sum_term\n\ndef calc_grad_R_QS(M, N, modes, coeffs):\n    \"\"\"\n    Calculates the gradient of R_QS.\n    \"\"\"\n    K = modes.shape[0]\n    a = coeffs[:K]\n    b = coeffs[K:]\n    \n    m = modes[:, 0]\n    n = modes[:, 1]\n    \n    if M**2 + N**2 == 0:\n        return np.zeros_like(coeffs)\n\n    delta = M * n - N * m\n    delta_sq = delta**2\n    \n    prefactor = (4 * np.pi**2) / (M**2 + N**2)\n    \n    grad_a = prefactor * delta_sq * a\n    grad_b = prefactor * delta_sq * b\n    \n    return np.concatenate([grad_a, grad_b])\n\ndef calc_hessian_diag(M, N, modes):\n    \"\"\"\n    Calculates the diagonal of the Hessian of R_QS.\n    \"\"\"\n    K = modes.shape[0]\n    \n    m = modes[:, 0]\n    n = modes[:, 1]\n    \n    if M**2 + N**2 == 0:\n        return np.zeros(2*K)\n    \n    delta = M * n - N * m\n    delta_sq = delta**2\n    \n    prefactor = (4 * np.pi**2) / (M**2 + N**2)\n    \n    h_k = prefactor * delta_sq\n    \n    return np.concatenate([h_k, h_k])\n\ndef run_verification(params):\n    \"\"\"\n    Runs the two verification conditions for a single test case.\n    \n    Args:\n        params (dict): A dictionary containing all parameters for the test case.\n\n    Returns:\n        bool: True if both conditions pass, False otherwise.\n    \"\"\"\n    M, N = params[\"M\"], params[\"N\"]\n    modes = params[\"modes\"]\n    x0_a, x0_b = params[\"x0_a\"], params[\"x0_b\"]\n    p_a, p_b = params[\"p_a\"], params[\"p_b\"]\n    eps, tol = params[\"eps\"], params[\"tol\"]\n\n    x0 = np.concatenate([x0_a, x0_b])\n    p = np.concatenate([p_a, p_b])\n\n    # --- Condition 1 Verification ---\n    # Compare D_FD^{(2)}(eps) with p^T H p\n    \n    # Calculate p^T H p\n    H_diag = calc_hessian_diag(M, N, modes)\n    pT_H_p = np.sum(H_diag * p**2)\n\n    # Calculate D_FD^{(2)}\n    R_plus = calc_R_QS(M, N, modes, x0 + eps * p)\n    R_zero = calc_R_QS(M, N, modes, x0)\n    R_minus = calc_R_QS(M, N, modes, x0 - eps * p)\n    \n    # Avoid division by zero if eps is extremely small\n    if eps**2  1e-30:\n        # For a quadratic, D2_FD is independent of eps and equals pT_H_p\n        D2_FD = pT_H_p \n    else:    \n        D2_FD = (R_plus - 2 * R_zero + R_minus) / eps**2\n    \n    cond1_passed = abs(D2_FD - pT_H_p) = tol\n    \n    # --- Condition 2 Verification ---\n    # Compare actual change minus linear term with the 2nd-order Taylor term\n    \n    # Calculate LHS: actual change - linear term\n    grad_R0 = calc_grad_R_QS(M, N, modes, x0)\n    grad_term = eps * np.dot(grad_R0, p)\n    actual_change = R_plus - R_zero - grad_term\n    \n    # Calculate RHS: 2nd-order Taylor term Delta^(2)\n    taylor_approx = 0.5 * eps**2 * pT_H_p\n    \n    cond2_passed = abs(actual_change - taylor_approx) = tol\n\n    return cond1_passed and cond2_passed\n\nsolve()\n\n```"
        },
        {
            "introduction": "任何优化研究的准确性都严重依赖于其数值计算的保真度。本练习聚焦于一个关键的实际问题：为计算来自练习  的磁场谱而选择的计算网格。通过比较均匀网格与高斯-勒让德网格的准确性，您将深入理解不同数值积分方法如何影响结果，并学会做出明智选择以确保计算的可靠性和效率。",
            "id": "3719877",
            "problem": "给定一个角环面上的周期函数，它表示仿星器中固定磁通面上的磁场强度，用角向角 $\\theta$ 和环向角 $\\zeta$ 表示，两者均以弧度为单位。在核聚变和通过准对称性 (QS) 进行仿星器优化的背景下，通过以下基本关系定义复双傅里叶系数 $B_{m,n}$\n$$\nB_{m,n} = \\frac{1}{4\\pi^2} \\int_{0}^{2\\pi} \\int_{0}^{2\\pi} B(\\theta,\\zeta)\\, e^{-i(m\\theta - n\\zeta)} \\, d\\theta \\, d\\zeta,\n$$\n其中 $m$ 和 $n$ 为整数。考虑解析磁场强度\n$$\nB(\\theta,\\zeta) = B_0 + \\epsilon_1 \\cos(\\bar{m}\\,\\theta - \\bar{n}\\,\\zeta) + \\epsilon_2 \\cos(2\\theta) + \\epsilon_3 \\cos(3\\zeta) + \\epsilon_4 \\cos(2\\bar{m}\\,\\theta - 2\\bar{n}\\,\\zeta),\n$$\n其参数为 $B_0$、$\\epsilon_1$、$\\epsilon_2$、$\\epsilon_3$、$\\epsilon_4$，目标准对称方向为 $(\\bar{m},\\bar{n})$。准对称性 (QS) 度量基于相同的基础定义，即偏离 QS 螺旋线的谱能量与总非恒定谱能量之比。设截断域内的 QS 螺旋集 $\\mathcal{S}$ 为\n$$\n\\mathcal{S} = \\{(k\\bar{m}, k\\bar{n}) : k \\in \\mathbb{Z} \\text{ and } (k\\bar{m}, k\\bar{n}) \\text{ is in the truncation}\\},\n$$\n并定义 QS 度量\n$$\n\\mathcal{M}_{\\mathrm{QS}} = \\frac{\\sum_{(m,n) \\in \\mathcal{R} \\setminus (\\mathcal{S} \\cup \\{(0,0)\\})} |B_{m,n}|^2}{\\sum_{(m,n) \\in \\mathcal{R} \\setminus \\{(0,0)\\}} |B_{m,n}|^2},\n$$\n其中 $\\mathcal{R}$ 是 $(m,n)$ 空间中选定的矩形截断。角度必须严格以弧度处理。\n\n您的任务是量化 $(\\theta,\\zeta)$ 中配置网格的选择对计算出的 $B_{m,n}$ 和 QS 度量精度的影响。使用两种求积策略来近似该二重积分：\n- 具有 $N_\\theta$ 和 $N_\\zeta$ 个点且等权重 $w_\\theta = 2\\pi/N_\\theta$、$w_\\zeta = 2\\pi/N_\\zeta$ 的均匀周期梯形网格，以及\n- 具有 $N_\\theta$ 和 $N_\\zeta$ 个节点、从 $[-1,1]$ 映射到 $[0,2\\pi]$ 的张量积高斯-勒让德网格，其中映射后的节点为 $\\theta_i = \\pi(x_i+1)$ 和 $\\zeta_j = \\pi(y_j+1)$，映射后的权重为 $w_{\\theta,i} = \\pi\\,\\omega_i$ 和 $w_{\\zeta,j} = \\pi\\,\\nu_j$，分别对应节点 $(x_i,\\omega_i)$ 和 $(y_j,\\nu_j)$。\n\n根据第一性原理，通过将积分替换为在选定节点上的相应加权和，可以获得 $B_{m,n}$ 的离散近似值。使用这些近似值，计算每个网格的近似 QS 度量，并将其与直接从给定的 $B(\\theta,\\zeta)$ 获得的解析基准真相进行比较。\n\n使用以下参数值和截断：\n- 目标螺旋方向 $(\\bar{m},\\bar{n}) = (2,1)$。\n- 系数：$B_0 = 1.0$，$\\epsilon_1 = 0.3$，$\\epsilon_2 = 0.1$，$\\epsilon_3 = 0.08$，$\\epsilon_4 = 0.05$。\n- 截断矩形 $\\mathcal{R}$ 由 $m \\in \\{-M,\\ldots,M\\}$ 和 $n \\in \\{-N,\\ldots,N\\}$ 给出，其中 $M = 6$ 且 $N = 6$。\n\n定义包含三个配置网格 $(N_\\theta,N_\\zeta)$ 的测试套件：\n- 测试 $1$：$(N_\\theta,N_\\zeta) = (16,16)$。\n- 测试 $2$：$(N_\\theta,N_\\zeta) = (8,8)$。\n- 测试 $3$：$(N_\\theta,N_\\zeta) = (64,16)$。\n\n对于每个测试用例，计算：\n- 高斯-勒让德网格和均匀网格的 QS 度量绝对误差，定义为 $|\\widehat{\\mathcal{M}}_{\\mathrm{QS}} - \\mathcal{M}_{\\mathrm{QS}}|$，其中 $\\widehat{\\mathcal{M}}_{\\mathrm{QS}}$ 是从数值 $B_{m,n}$ 计算出的度量，而 $\\mathcal{M}_{\\mathrm{QS}}$ 是解析度量。\n- 高斯-勒让德网格和均匀网格在 $\\mathcal{R}$ 上的完整系数数组的相对 $\\ell_2$ 误差，定义为\n$$\n\\frac{\\left(\\sum_{(m,n)\\in \\mathcal{R}} | \\widehat{B}_{m,n} - B_{m,n} |^2\\right)^{1/2}}{\\left(\\sum_{(m,n)\\in \\mathcal{R}} | B_{m,n} |^2\\right)^{1/2}}.\n$$\n\n最后，通过比较三个测试用例的平均 QS 度量绝对误差，推荐一种能最小化整个套件中 QS 度量误差的网格类型。将建议编码为一个整数：如果均匀网格的平均 QS 度量误差更低或相等，则输出 $0$；如果高斯-勒让德网格的误差更低，则输出 $1$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的精确顺序如下：\n$[$error$_{\\mathrm{GL},1}$, error$_{\\mathrm{U},1}$, coeffErr$_{\\mathrm{GL},1}$, coeffErr$_{\\mathrm{U},1}$, error$_{\\mathrm{GL},2}$, error$_{\\mathrm{U},2}$, coeffErr$_{\\mathrm{GL},2}$, coeffErr$_{\\mathrm{U},2}$, error$_{\\mathrm{GL},3}$, error$_{\\mathrm{U},3}$, coeffErr$_{\\mathrm{GL},3}$, coeffErr$_{\\mathrm{U},3}$, recommendation$]$。\n\n所有角度都必须以弧度处理，所有输出必须是指定的实数（浮点数）或整数。不应打印任何其他文本。",
            "solution": "### 问题验证\n\n#### 步骤 1：提取已知信息\n\n问题提供了以下信息：\n\n1.  **磁场函数**：磁通面上的磁场强度被给定为角向角 $\\theta$ 和环向角 $\\zeta$ 的周期函数：\n    $B(\\theta,\\zeta) = B_0 + \\epsilon_1 \\cos(\\bar{m}\\,\\theta - \\bar{n}\\,\\zeta) + \\epsilon_2 \\cos(2\\theta) + \\epsilon_3 \\cos(3\\zeta) + \\epsilon_4 \\cos(2\\bar{m}\\,\\theta - 2\\bar{n}\\,\\zeta)$。\n2.  **傅里叶系数**：复双傅里叶系数 $B_{m,n}$ 定义为：\n    $B_{m,n} = \\frac{1}{4\\pi^2} \\int_{0}^{2\\pi} \\int_{0}^{2\\pi} B(\\theta,\\zeta)\\, e^{-i(m\\theta - n\\zeta)} \\, d\\theta \\, d\\zeta$。\n3.  **准对称性 (QS) 度量**：QS 度量 $\\mathcal{M}_{\\mathrm{QS}}$ 定义为谱功率之比：\n    $\\mathcal{M}_{\\mathrm{QS}} = \\frac{\\sum_{(m,n) \\in \\mathcal{R} \\setminus (\\mathcal{S} \\cup \\{(0,0)\\})} |B_{m,n}|^2}{\\sum_{(m,n) \\in \\mathcal{R} \\setminus \\{(0,0)\\}} |B_{m,n}|^2}$。\n4.  **QS 螺旋集**：准对称模式集合 $\\mathcal{S}$ 定义为：\n    $\\mathcal{S} = \\{(k\\bar{m}, k\\bar{n}) : k \\in \\mathbb{Z} \\text{ and } (k\\bar{m}, k\\bar{n}) \\text{ is in the truncation}\\}$。\n5.  **参数**：\n    *   目标准对称方向：$(\\bar{m},\\bar{n}) = (2,1)$。\n    *   场系数：$B_0 = 1.0$, $\\epsilon_1 = 0.3$, $\\epsilon_2 = 0.1$, $\\epsilon_3 = 0.08$, $\\epsilon_4 = 0.05$。\n6.  **截断域**：矩形截断 $\\mathcal{R}$ 由 $m \\in \\{-6, \\dots, 6\\}$ 和 $n \\in \\{-6, \\dots, 6\\}$ 定义。\n7.  **数值方法**：\n    *   具有 $N_\\theta, N_\\zeta$ 个点和权重 $w_\\theta = 2\\pi/N_\\theta$、$w_\\zeta = 2\\pi/N_\\zeta$ 的均匀周期梯形网格。\n    *   具有 $N_\\theta, N_\\zeta$ 个节点、从 $[-1,1]$ 映射到 $[0,2\\pi]$ 的张量积高斯-勒让德网格。\n8.  **测试用例**：三个配置网格 $(N_\\theta, N_\\zeta)$：\n    *   测试 1：$(16,16)$。\n    *   测试 2：$(8,8)$。\n    *   测试 3：$(64,16)$。\n9.  **误差度量**：\n    *   QS 度量绝对误差：$|\\widehat{\\mathcal{M}}_{\\mathrm{QS}} - \\mathcal{M}_{\\mathrm{QS}}|$。\n    *   相对 $\\ell_2$ 系数误差：$\\frac{\\left(\\sum_{(m,n)\\in \\mathcal{R}} | \\widehat{B}_{m,n} - B_{m,n} |^2\\right)^{1/2}}{\\left(\\sum_{(m,n)\\in \\mathcal{R}} | B_{m,n} |^2\\right)^{1/2}}$。\n10. **最终任务**：基于三个测试中的平均 QS 度量绝对误差，推荐一种网格类型（均匀网格或高斯-勒让德网格），编码为：如果均匀网格的误差小于或等于高斯-勒让德网格的误差，则为 $0$；如果高斯-勒让德网格的误差严格更小，则为 $1$。\n11. **输出格式**：单行、逗号分隔、用方括号括起来的结果列表。\n\n#### 步骤 2：使用提取的已知信息进行验证\n\n根据验证标准评估该问题：\n\n*   **有科学依据**：该问题牢固地植根于核聚变领域，特别是仿星器磁约束装置的设计。准对称性、环面上磁场的傅里叶分析以及数值求积等概念在这一领域是标准和基础的。\n*   **良态的**：该问题是良态的。所有参数、函数和目标都有清晰的定义。磁场的解析形式允许计算精确的基准真相，数值方法可以与之进行明确的比较。所有必需的计算都存在唯一解。\n*   **客观的**：语言精确、量化，且不含主观性。\n*   **一致性和完整性**：问题提供了所有必要的数据和定义。没有明显的矛盾。将数值求积方法与解析解进行比较的要求是计算科学中一个标准且有价值的练习。\n\n该问题没有表现出任何缺陷，如科学上的不合理性、对伪科学的依赖、不完整性或模糊性。\n\n#### 步骤 3：结论和行动\n\n问题是**有效的**。开始求解。\n\n### 解法\n\n目标是评估两种数值求积方案——均匀周期梯形法则和高斯-勒让德求积——在计算仿星器磁场的傅里叶谱及派生的准对称性 (QS) 度量方面的精度。\n\n#### 1. 解析基准真相计算\n\n第一步是确定给定磁场 $B(\\theta,\\zeta)$ 的精确傅里叶系数 $B_{m,n}$。该场是余弦项之和，其系数可以通过利用欧拉公式 $\\cos(x) = \\frac{1}{2}(e^{ix} + e^{-ix})$ 以及复指数在域 $[0, 2\\pi] \\times [0, 2\\pi]$ 上的正交性来找到。\n\n傅里叶系数的定义是：\n$$B_{m,n} = \\frac{1}{4\\pi^2} \\int_{0}^{2\\pi} \\int_{0}^{2\\pi} B(\\theta,\\zeta)\\, e^{-i(m\\theta - n\\zeta)} \\, d\\theta \\, d\\zeta$$\n对于形式为 $C \\cos(A\\theta - B\\zeta) = \\frac{C}{2}(e^{i(A\\theta - B\\zeta)} + e^{-i(A\\theta - B\\zeta)})$ 的项，只有当指数抵消时，积分才非零。项 $e^{i(A\\theta - B\\zeta)}$ 对 $B_{A,B}$ 有贡献，项 $e^{-i(A\\theta - B\\zeta)}$ 对 $B_{-A,-B}$ 有贡献。在这两种情况下，系数都是 $\\frac{C}{2}$。\n\n对于给定的 $B(\\theta,\\zeta)$ 及其参数 $(\\bar{m},\\bar{n}) = (2,1)$、$B_0=1.0$、$\\epsilon_1=0.3$、$\\epsilon_2=0.1$、$\\epsilon_3=0.08$、$\\epsilon_4=0.05$，非零解析系数为：\n*   $B_{0,0} = B_0 = 1.0$ (来自常数项)\n*   $B_{2,1} = B_{-2,-1} = \\epsilon_1/2 = 0.15$ (来自 $\\epsilon_1 \\cos(2\\theta - \\zeta)$)\n*   $B_{2,0} = B_{-2,0} = \\epsilon_2/2 = 0.05$ (来自 $\\epsilon_2 \\cos(2\\theta)$)\n*   $B_{0,3} = B_{0,-3} = \\epsilon_3/2 = 0.04$ (来自 $\\epsilon_3 \\cos(3\\zeta) = \\epsilon_3 \\cos(0\\theta - (-3)\\zeta)$)\n*   $B_{4,2} = B_{-4,-2} = \\epsilon_4/2 = 0.025$ (来自 $\\epsilon_4 \\cos(4\\theta - 2\\zeta)$)\n所有其他 $B_{m,n}$ 系数均为零。\n\n接下来，我们计算解析 QS 度量 $\\mathcal{M}_{\\mathrm{QS}}$。截断域为 $\\mathcal{R} = \\{(m,n) | m,n \\in \\{-6, ..., 6\\}\\}$。QS 螺旋集为 $\\mathcal{S} = \\{(2k, k)\\}$，其中 $k$ 为整数。$\\mathcal{S}$ 中的非零模式是 $(\\pm 2, \\pm 1)$ 和 $(\\pm 4, \\pm 2)$。不在 $\\mathcal{S}$ 中的模式（即“非 QS”模式）是 $(\\pm 2, 0)$ 和 $(0, \\pm 3)$。\n\n$\\mathcal{M}_{\\mathrm{QS}}$ 的分子是非零、非恒定、非 QS 模式的幅值平方和：\n$$ \\sum_{\\text{non-QS}} |B_{m,n}|^2 = |B_{2,0}|^2 + |B_{-2,0}|^2 + |B_{0,3}|^2 + |B_{0,-3}|^2 = 2 \\cdot (0.05)^2 + 2 \\cdot (0.04)^2 = 0.0082 $$\n分母是所有非零、非恒定模式的幅值平方和：\n$$ \\sum_{\\text{non-zero AC}} |B_{m,n}|^2 = 2|B_{2,1}|^2 + 2|B_{2,0}|^2 + 2|B_{0,3}|^2 + 2|B_{4,2}|^2 $$\n$$ = 2 \\cdot (0.15)^2 + 2 \\cdot (0.05)^2 + 2 \\cdot (0.04)^2 + 2 \\cdot (0.025)^2 = 0.045 + 0.005 + 0.0032 + 0.00125 = 0.05445 $$\n解析 QS 度量为：\n$$ \\mathcal{M}_{\\mathrm{QS}} = \\frac{0.0082}{0.05445} \\approx 0.15059687786960515 $$\n\n#### 2. 数值求积方案\n\n$B_{m,n}$ 的积分通过在离散点网格 $(\\theta_i, \\zeta_j)$ 上的加权和来近似：\n$$ \\widehat{B}_{m,n} = \\frac{1}{4\\pi^2} \\sum_{i=1}^{N_\\theta} \\sum_{j=1}^{N_\\zeta} B(\\theta_i,\\zeta_j)\\, e^{-i(m\\theta_i - n\\zeta_j)} \\, w_{\\theta,i} w_{\\zeta,j} $$\n\n**均匀周期梯形网格**：\n节点是等距分布的：$\\theta_i = \\frac{2\\pi i}{N_\\theta}$ for $i=0, \\dots, N_\\theta - 1$ 和 $\\zeta_j = \\frac{2\\pi j}{N_\\zeta}$ for $j=0, \\dots, N_\\zeta - 1$。权重是恒定的：$w_{\\theta,i} = \\frac{2\\pi}{N_\\theta}$ 和 $w_{\\zeta,j} = \\frac{2\\pi}{N_\\zeta}$。\n近似变为：\n$$ \\widehat{B}_{m,n} = \\frac{1}{N_\\theta N_\\zeta} \\sum_{i=0}^{N_\\theta-1} \\sum_{j=0}^{N_\\zeta-1} B(\\theta_i,\\zeta_j)\\, e^{-i(m\\theta_i - n\\zeta_j)} $$\n这是一个二维离散傅里叶变换，已知如果网格足够精细以满足奈奎斯特准则，它对带限周期函数具有谱精度。\n\n**高斯-勒让德网格**：\n此方法使用为积分多项式而优化的节点和权重。标准的高斯-勒让德节点 $x_k$ 和权重 $\\omega_k$ 定义在 $[-1,1]$ 上。它们被映射到 $[0, 2\\pi]$ 区间：\n*   节点：$\\theta_i = \\pi(x_i+1)$，$\\zeta_j = \\pi(y_j+1)$\n*   权重：$w_{\\theta,i} = \\pi \\omega_{\\theta,i}$，$w_{\\zeta,j} = \\pi \\omega_{\\zeta,j}$ (因子 $\\pi$ 来自线性变换的雅可比行列式 $d\\theta = \\pi dx$)。\n近似为：\n$$ \\widehat{B}_{m,n} = \\frac{1}{4} \\sum_{i=1}^{N_\\theta} \\sum_{j=1}^{N_\\zeta} B(\\theta_i,\\zeta_j)\\, e^{-i(m\\theta_i - n\\zeta_j)} \\, \\omega_{\\theta,i} \\omega_{\\zeta,j} $$\n尽管高斯-勒让德求积是为多项式设计的，但它对光滑的非多项式函数也非常有效，通常比梯形法则收敛得更快。\n\n#### 3. 误差度量与算法\n\n对于每个测试用例和网格类型，我们计算截断域 $\\mathcal{R}$ 中所有 $(m,n)$ 的数值系数 $\\widehat{B}_{m,n}$。根据这些系数，我们计算数值 QS 度量 $\\widehat{\\mathcal{M}}_{\\mathrm{QS}}$。然后我们计算两种误差：\n1.  **QS 度量绝对误差**：$|\\widehat{\\mathcal{M}}_{\\mathrm{QS}} - \\mathcal{M}_{\\mathrm{QS}}|$\n2.  **系数相对 $\\ell_2$ 误差**：这衡量了整个谱表示中的误差：\n    $$ E_{\\ell_2} = \\frac{\\left(\\sum_{m,n \\in \\mathcal{R}} | \\widehat{B}_{m,n} - B_{m,n} |^2\\right)^{1/2}}{\\left(\\sum_{m,n \\in \\mathcal{R}} | B_{m,n} |^2\\right)^{1/2}} $$\n\n总体算法如下：\n1.  计算解析系数 $B_{m,n}$、解析度量 $\\mathcal{M}_{\\mathrm{QS}}$以及解析系数向量的总 $\\ell_2$ 范数。\n2.  遍历每个测试用例 $(N_\\theta, N_\\zeta)$。\n3.  对每种情况，为高斯-勒让德网格和均匀网格执行以下操作：\n    a.  构建节点和权重的二维网格。\n    b.  在网格上评估磁场函数 $B(\\theta, \\zeta)$。\n    c.  使用相应的离散求和公式计算域 $\\mathcal{R}$ 上的数值系数矩阵 $\\widehat{B}_{m,n}$。\n    d.  从 $\\widehat{B}_{m,n}$ 值计算数值 QS 度量 $\\widehat{\\mathcal{M}}_{\\mathrm{QS}}$。\n    e.  计算并存储 QS 度量误差和系数误差。\n4.  处理完所有测试用例后，计算每种网格类型的平均 QS 度量误差。\n5.  推荐平均误差较低的网格类型，将选择编码为：均匀网格（或持平）为 0，高斯-勒让德网格为 1。\n6.  将所有计算结果格式化为单个逗号分隔的列表以供输出。\n\n这种系统性的比较将揭示网格选择和分辨率对仿星器优化研究中谱计算精度的影响。特别是，分辨率不足的情况 $(N_\\theta, N_\\zeta) = (8,8)$ 预计将凸显两种方法的不同收敛特性，因为均匀网格会遭受混叠效应的影响，而高斯-勒让德网格可能仍能产生合理的精度。",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Computes and compares errors in stellarator quasi-symmetry metrics\n    derived from uniform and Gauss-Legendre quadrature grids.\n    \"\"\"\n    # 1. Define problem parameters\n    B0 = 1.0\n    eps1, eps2, eps3, eps4 = 0.3, 0.1, 0.08, 0.05\n    m_bar, n_bar = 2, 1\n    M, N = 6, 6\n\n    test_cases = [\n        (16, 16),\n        (8, 8),\n        (64, 16),\n    ]\n\n    # 2. Analytic Ground Truth Calculation\n    B_mn_analytic = {}\n    B_mn_analytic[(0, 0)] = complex(B0, 0)\n    B_mn_analytic[(m_bar, n_bar)] = complex(eps1 / 2, 0)\n    B_mn_analytic[(-m_bar, -n_bar)] = complex(eps1 / 2, 0)\n    B_mn_analytic[(2, 0)] = complex(eps2 / 2, 0)\n    B_mn_analytic[(-2, 0)] = complex(eps2 / 2, 0)\n    B_mn_analytic[(0, 3)] = complex(eps3 / 2, 0)\n    B_mn_analytic[(0, -3)] = complex(eps3 / 2, 0)\n    B_mn_analytic[(2 * m_bar, 2 * n_bar)] = complex(eps4 / 2, 0)\n    B_mn_analytic[(-2 * m_bar, -2 * n_bar)] = complex(eps4 / 2, 0)\n\n    m_vals = np.arange(-M, M + 1)\n    n_vals = np.arange(-N, N + 1)\n\n    qs_modes = set()\n    # Allowing k to be larger than M, N ensures we capture all possible modes within the truncation\n    k_range = max(M // abs(m_bar) if m_bar != 0 else M, N // abs(n_bar) if n_bar != 0 else N)\n    for k in range(-k_range -1, k_range + 2):\n        m, n = k * m_bar, k * n_bar\n        if abs(m) = M and abs(n) = N:\n            qs_modes.add((m, n))\n\n    sum_sq_off_qs = 0.0\n    sum_sq_total_ac = 0.0\n    B_analytic_matrix = np.zeros((2 * M + 1, 2 * N + 1), dtype=complex)\n    norm_B_analytic_sq = 0.0\n\n    for i, m in enumerate(m_vals):\n        for j, n in enumerate(n_vals):\n            val = B_mn_analytic.get((m, n), 0)\n            B_analytic_matrix[i, j] = val\n            norm_B_analytic_sq += np.abs(val)**2\n            if (m, n) == (0, 0):\n                continue\n            \n            sum_sq_total_ac += np.abs(val)**2\n            if (m, n) not in qs_modes:\n                sum_sq_off_qs += np.abs(val)**2\n\n    M_qs_analytic = sum_sq_off_qs / sum_sq_total_ac if sum_sq_total_ac != 0 else 0.0\n    norm_B_analytic = np.sqrt(norm_B_analytic_sq)\n\n    def B_field(theta, zeta):\n        return (B0 +\n                eps1 * np.cos(m_bar * theta - n_bar * zeta) +\n                eps2 * np.cos(2 * theta) +\n                eps3 * np.cos(3 * zeta) +\n                eps4 * np.cos(2 * m_bar * theta - 2 * n_bar * zeta))\n\n    def compute_errors(N_theta, N_zeta, grid_type):\n        if grid_type == 'uniform':\n            theta_nodes = np.linspace(0, 2 * np.pi, N_theta, endpoint=False)\n            zeta_nodes = np.linspace(0, 2 * np.pi, N_zeta, endpoint=False)\n            theta_weights = np.full(N_theta, 2 * np.pi / N_theta)\n            zeta_weights = np.full(N_zeta, 2 * np.pi / N_zeta)\n        elif grid_type == 'gauss':\n            theta_x, theta_w = leggauss(N_theta)\n            zeta_x, zeta_w = leggauss(N_zeta)\n            theta_nodes = np.pi * (theta_x + 1)\n            zeta_nodes = np.pi * (zeta_x + 1)\n            theta_weights = np.pi * theta_w\n            zeta_weights = np.pi * zeta_w\n        else:\n            raise ValueError(\"Unknown grid_type\")\n\n        theta_grid, zeta_grid = np.meshgrid(theta_nodes, zeta_nodes, indexing='ij')\n        weights_grid = np.outer(theta_weights, zeta_weights)\n        B_on_grid = B_field(theta_grid, zeta_grid)\n\n        B_hat_matrix = np.zeros_like(B_analytic_matrix, dtype=complex)\n        for i, m in enumerate(m_vals):\n            for j, n in enumerate(n_vals):\n                exponent = -1j * (m * theta_grid - n * zeta_grid)\n                integrand = B_on_grid * np.exp(exponent)\n                integral = np.sum(integrand * weights_grid)\n                B_hat_matrix[i, j] = integral / (4 * np.pi**2)\n\n        num_sum_sq_off_qs = 0.0\n        num_sum_sq_total_ac = 0.0\n        for i, m in enumerate(m_vals):\n            for j, n in enumerate(n_vals):\n                val_sq = np.abs(B_hat_matrix[i, j])**2\n                if (m, n) == (0, 0):\n                    continue\n                num_sum_sq_total_ac += val_sq\n                if (m, n) not in qs_modes:\n                    num_sum_sq_off_qs += val_sq\n\n        M_qs_hat = num_sum_sq_off_qs / num_sum_sq_total_ac if num_sum_sq_total_ac != 0 else 0.0\n        \n        qs_metric_error = np.abs(M_qs_hat - M_qs_analytic)\n        \n        diff_matrix = B_hat_matrix - B_analytic_matrix\n        norm_diff_sq = np.sum(np.abs(diff_matrix)**2)\n        coeff_error = np.sqrt(norm_diff_sq) / norm_B_analytic if norm_B_analytic != 0 else 0.0\n        \n        return qs_metric_error, coeff_error\n\n    final_results = []\n    gl_qs_errors = []\n    u_qs_errors = []\n\n    for n_theta, n_zeta in test_cases:\n        err_gl, coeff_err_gl = compute_errors(n_theta, n_zeta, 'gauss')\n        err_u, coeff_err_u = compute_errors(n_theta, n_zeta, 'uniform')\n        \n        final_results.extend([err_gl, err_u, coeff_err_gl, coeff_err_u])\n        gl_qs_errors.append(err_gl)\n        u_qs_errors.append(err_u)\n\n    avg_err_gl = np.mean(gl_qs_errors)\n    avg_err_u = np.mean(u_qs_errors)\n    recommendation = 1 if avg_err_gl  avg_err_u else 0\n    final_results.append(recommendation)\n\n    print(f\"[{','.join(f'{x:.10g}' for x in final_results)}]\")\n\nsolve()\n```"
        }
    ]
}