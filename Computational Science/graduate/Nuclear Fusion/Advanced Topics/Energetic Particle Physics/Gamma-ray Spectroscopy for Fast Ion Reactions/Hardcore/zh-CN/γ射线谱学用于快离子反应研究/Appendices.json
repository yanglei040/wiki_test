{
    "hands_on_practices": [
        {
            "introduction": "在分析任何诊断测量数据之前，一个关键的初始步骤是精确了解我们的仪器正在观测等离子体的哪个区域。本练习将指导您完成一个基础但至关重要的计算任务：确定探测器视线与托卡马克等离子体中特定感兴趣区域的几何相交情况。通过解决这个问题 ，您将掌握为伽马射线能谱诊断构建“正向模型”所需的计算几何技能。",
            "id": "3700995",
            "problem": "托卡马克的极向截面在欧几里得平面中被建模，采用简化为二维笛卡尔坐标系的柱坐标，其中径向坐标为 $R$（水平轴），垂直坐标为 $Z$（垂直轴）。假设环向对称。针对快离子反应的伽马射线视线测量由一个准直探测器执行，其视线 (LOS) 被建模为一条半线，从探测器位置 $(R_{\\mathrm{d}}, Z_{\\mathrm{d}})$ 开始，并以与正 $R$ 轴逆时针方向夹角为 $\\alpha$（单位为弧度）的角度向前延伸。对于 $t \\ge 0$，LOS 参数化是由下式给出的映射 $t \\mapsto (R(t), Z(t))$：\n$$\nR(t) = R_{\\mathrm{d}} + t \\cos \\alpha,\\quad Z(t) = Z_{\\mathrm{d}} + t \\sin \\alpha.\n$$\n来自快离子的伽马射线发射的等离子体感兴趣区域 (ROI) 被建模为一个以 $(R_0, Z_0)$ 为中心的环形椭圆（壳层），其边界由一个半轴为 $(a_{\\mathrm{out}}, b_{\\mathrm{out}})$ 的外椭圆和一个半轴为 $(a_{\\mathrm{in}}, b_{\\mathrm{in}})$ 的内椭圆界定，其中 $a_{\\mathrm{in}}  a_{\\mathrm{out}}$ 且 $b_{\\mathrm{in}}  b_{\\mathrm{out}}$。这些椭圆是轴对齐的，其方程为\n$$\n\\frac{(R - R_0)^2}{a^2} + \\frac{(Z - Z_0)^2}{b^2} = 1,\n$$\n其中，对于外边界，$(a,b)$ 为 $(a_{\\mathrm{out}}, b_{\\mathrm{out}})$；对于内边界，$(a,b)$ 为 $(a_{\\mathrm{in}}, b_{\\mathrm{in}})$。ROI 是指位于外椭圆内部且在内椭圆外部的点集。\n\n任务：\n- 从第一性原理出发，构建探测器坐标（由 $(R_{\\mathrm{d}}, Z_{\\mathrm{d}})$ 和 $\\alpha$ 定义）与沿 LOS 的等离子体坐标之间的映射关系，该关系是路径参数 $t \\ge 0$ 的函数。\n- 利用此映射，确定 LOS 与 ROI 的总相交长度。如果对于 $t \\ge 0$，LOS 以多个不相交的线段穿过 ROI，则将所有这些线段的长度相加。如果 LOS 与之相切，则相交长度为零。如果 LOS 未与 ROI 相交，则相交长度为零。最终长度以米为单位表示，并四舍五入到六位小数。\n\n您可以使用的基本假设：\n- 极向平面中的欧几里得几何。\n- 椭圆的定义为满足 $\\frac{(R - R_0)^2}{a^2} + \\frac{(Z - Z_0)^2}{b^2} = 1$ 的点的轨迹。\n- 上文定义的 LOS 参数方程。\n- 探测器仅沿前向半线 $t \\ge 0$ 进行测量。\n\n角度单位要求：\n- 所有角度 $\\alpha$ 均以弧度为单位，并且必须按弧度处理。\n\n输出格式要求：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个用方括号括起来的逗号分隔列表（例如 $[x_1,x_2,\\dots]$），其中每个条目是一个浮点数，表示以米为单位的总相交长度，四舍五入到六位小数。\n\n测试套件：\n使用以下五个测试用例。在所有情况下，ROI 参数如下：\n- 中心 $(R_0, Z_0) = (\\,1.7,\\;0.0\\,)$，\n- 外半轴 $(a_{\\mathrm{out}}, b_{\\mathrm{out}}) = (\\,0.6,\\;1.02\\,)$，\n- 内半轴 $(a_{\\mathrm{in}}, b_{\\mathrm{in}}) = (\\,0.3,\\;0.51\\,)$。\n\n每个测试用例指定 $(R_{\\mathrm{d}}, Z_{\\mathrm{d}}, \\alpha)$：\n1. $(\\,2.5,\\;0.0,\\;\\pi\\,) = (\\,2.5,\\;0.0,\\;3.141592653589793\\,)$。\n2. $(\\,3.0,\\;1.02,\\;\\pi\\,) = (\\,3.0,\\;1.02,\\;3.141592653589793\\,)$。\n3. $(\\,3.0,\\;1.2,\\;\\pi\\,) = (\\,3.0,\\;1.2,\\;3.141592653589793\\,)$。\n4. $(\\,2.15,\\;0.0,\\;0\\,) = (\\,2.15,\\;0.0,\\;0.0\\,)$。\n5. $(\\,2.6,\\;0.4,\\;\\pi + \\pi/6\\,) = (\\,2.6,\\;0.4,\\;3.665191429188092\\,)$。\n\n您的程序必须为每个测试用例计算穿过 ROI 的总 LOS 相交长度（以米为单位，四舍五入到六位小数），并打印单行 $[L_1,L_2,L_3,L_4,L_5]$，不含空格。",
            "solution": "该问题是适定的且有科学依据，它代表了实验聚变物理学中一种常见诊断技术的简化但有效的几何模型。我们可以从第一性原理出发，进行解的形式推导。\n\n目标是计算代表探测器视线 (LOS) 的半线与代表等离子体感兴趣区域 (ROI) 的环形椭圆区域的相交总长度。\n\n基本策略是首先确定 LOS 与单个实心椭圆的相交长度。由于 ROI 被定义为在外椭圆内部且在同心内椭圆外部的区域，因此与 ROI 的总相交长度可以通过计算与实心外椭圆的相交长度 ($L_{\\mathrm{out}}$) 减去与实心内椭圆的相交长度 ($L_{\\mathrm{in}}$) 来获得。这是有效的，因为两个椭圆是嵌套的，这意味着任何穿过内椭圆的 LOS 线段也必然穿过外椭圆。因此，总长度为 $L = L_{\\mathrm{out}} - L_{\\mathrm{in}}$。\n\n让我们推导 LOS 与单个实心椭圆相交的一般情况下的相交长度。\n\n对于 $t \\ge 0$，LOS 的参数化定义如下：\n$$\nR(t) = R_{\\mathrm{d}} + t \\cos \\alpha \\\\\nZ(t) = Z_{\\mathrm{d}} + t \\sin \\alpha\n$$\n其中 $(R_{\\mathrm{d}}, Z_{\\mathrm{d}})$ 是 LOS 的起点，$\\alpha$ 是其角度。\n\n一个中心在 $(R_0, Z_0)$、半轴为 $(a, b)$ 的通用轴对齐椭圆的方程是：\n$$\n\\frac{(R - R_0)^2}{a^2} + \\frac{(Z - Z_0)^2}{b^2} = 1\n$$\n\n为了找到交点，我们将 LOS 的参数方程代入椭圆方程：\n$$\n\\frac{((R_{\\mathrm{d}} + t \\cos \\alpha) - R_0)^2}{a^2} + \\frac{((Z_{\\mathrm{d}} + t \\sin \\alpha) - Z_0)^2}{b^2} = 1\n$$\n\n为简化起见，我们定义探测器相对于椭圆中心的起始位置：\n$R'_{\\mathrm{d}} = R_{\\mathrm{d}} - R_0$\n$Z'_{\\mathrm{d}} = Z_{\\mathrm{d}} - Z_0$\n\n并使用三角函数的简写：\n$c_{\\alpha} = \\cos \\alpha$\n$s_{\\alpha} = \\sin \\alpha$\n\n方程变为：\n$$\n\\frac{(R'_{\\mathrm{d}} + t c_{\\alpha})^2}{a^2} + \\frac{(Z'_{\\mathrm{d}} + t s_{\\alpha})^2}{b^2} = 1\n$$\n\n这是一个关于路径参数 $t$ 的二次方程。我们展开并按 $t$ 的幂次对项进行分组，得到标准形式 $At^2 + Bt + C = 0$：\n$$\nt^2 \\left( \\frac{c_{\\alpha}^2}{a^2} + \\frac{s_{\\alpha}^2}{b^2} \\right) + t \\left( \\frac{2 R'_{\\mathrm{d}} c_{\\alpha}}{a^2} + \\frac{2 Z'_{\\mathrm{d}} s_{\\alpha}}{b^2} \\right) + \\left( \\frac{(R'_{\\mathrm{d}})^2}{a^2} + \\frac{(Z'_{\\mathrm{d}})^2}{b^2} - 1 \\right) = 0\n$$\n\n系数 $A$、$B$ 和 $C$ 为：\n$$\nA = \\frac{c_{\\alpha}^2}{a^2} + \\frac{s_{\\alpha}^2}{b^2} = \\frac{b^2 c_{\\alpha}^2 + a^2 s_{\\alpha}^2}{a^2 b^2}\n$$\n$$\nB = \\frac{2 R'_{\\mathrm{d}} c_{\\alpha}}{a^2} + \\frac{2 Z'_{\\mathrm{d}} s_{\\alpha}}{b^2} = \\frac{2 (b^2 R'_{\\mathrm{d}} c_{\\alpha} + a^2 Z'_{\\mathrm{d}} s_{\\alpha})}{a^2 b^2}\n$$\n$$\nC = \\frac{(R'_{\\mathrm{d}})^2}{a^2} + \\frac{(Z'_{\\mathrm{d}})^2}{b^2} - 1 = \\frac{b^2 (R'_{\\mathrm{d}})^2 + a^2 (Z'_{\\mathrm{d}})^2 - a^2 b^2}{a^2 b^2}\n$$\n\n为简便起见，我们可以处理将原方程乘以 $a^2 b^2$ 后的方程，它对 $t$ 有相同的根。这个更简单的二次形式的系数是：\n$$\nA' = b^2 c_{\\alpha}^2 + a^2 s_{\\alpha}^2\n$$\n$$\nB' = 2 (b^2 R'_{\\mathrm{d}} c_{\\alpha} + a^2 Z'_{\\mathrm{d}} s_{\\alpha})\n$$\n$$\nC' = b^2 (R'_{\\mathrm{d}})^2 + a^2 (Z'_{\\mathrm{d}})^2 - a^2 b^2\n$$\n\n使用基于判别式 $\\Delta = (B')^2 - 4A'C'$ 的二次公式可以求得 $t$ 的解：\n$$\nt = \\frac{-B' \\pm \\sqrt{\\Delta}}{2A'}\n$$\n\n判别式的值决定了相交的性质：\n-   如果 $\\Delta  0$：不存在实数根。LOS 不与椭圆相交。相交长度为 $0$。\n-   如果 $\\Delta = 0$：存在一个实数根。LOS 与椭圆相切。相交长度为 $0$。\n-   如果 $\\Delta  0$：存在两个不同的实数根 $t_1$ 和 $t_2$。我们将其排序为 $t_1  t_2$。这些是整条直线（对于 $t \\in (-\\infty, \\infty)$）穿过椭圆边界处的 $t$ 值。LOS 在 $t \\in [t_1, t_2]$ 的区间内位于椭圆内部。\n\n对于整条直线，相交线段的总长度是 $t_2 - t_1$。然而，问题指定的是一个半线探测器，它仅在 $t \\ge 0$ 时敏感。因此，我们必须找到区间 $[t_1, t_2]$ 与区间 $[0, \\infty)$ 的交集。\n\n设根为 $t_1 = \\frac{-B' - \\sqrt{\\Delta}}{2A'}$ 和 $t_2 = \\frac{-B' + \\sqrt{\\Delta}}{2A'}$。\n确定半线相交长度的逻辑如下：\n1.  如果 $t_2  0$，两个交点都位于 LOS 的反向延伸线上（即 $t  0$）。有效相交长度为 $0$。\n2.  如果 $t_1  0$ 且 $t_2 \\ge 0$，则 LOS 的起点（$t=0$）位于椭圆内部。LOS 在 $t=t_2$ 处离开椭圆。有效相交区间为 $[0, t_2]$。长度为 $t_2$。\n3.  如果 $t_1 \\ge 0$，两个交点都位于 LOS 的前向路径上。探测器从椭圆外部开始，在 $t=t_1$ 处进入，在 $t=t_2$ 处离开。有效相交区间为 $[t_1, t_2]$。长度为 $t_2 - t_1$。\n\n此案例分析提供了单个实心椭圆的相交长度。为解决该问题，我们应用此过程两次：\n1.  使用外椭圆的参数 $(R_0, Z_0)$、$(a_{\\mathrm{out}}, b_{\\mathrm{out}})$ 计算 $L_{\\mathrm{out}}$。\n2.  使用内椭圆的参数 $(R_0, Z_0)$、$(a_{\\mathrm{in}}, b_{\\mathrm{in}})$ 计算 $L_{\\mathrm{in}}$。\n3.  最终结果是与环形区域的总相交长度 $L = L_{\\mathrm{out}} - L_{\\mathrm{in}}$。\n\n该算法将针对每个提供的测试用例进行实现。对于 $\\Delta = 0$ 附近的数值稳定性问题，将通过把任何微小的正或负判别式都视为零来处理，以确保相切线正确地产生零长度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_single_ellipse_length(ellipse_params, los_params):\n    \"\"\"\n    Calculates the intersection length of a half-line (LOS) with a single solid ellipse.\n\n    Args:\n        ellipse_params (tuple): (R0, Z0, a, b) for the ellipse.\n        los_params (tuple): (Rd, Zd, alpha) for the Line of Sight.\n\n    Returns:\n        float: The intersection length.\n    \"\"\"\n    R0, Z0, a, b = ellipse_params\n    Rd, Zd, alpha = los_params\n\n    cos_a = np.cos(alpha)\n    sin_a = np.sin(alpha)\n    \n    R_d_prime = Rd - R0\n    Z_d_prime = Zd - Z0\n\n    # Coefficients of the quadratic equation At^2 + Bt + C = 0\n    # The A coefficient is always positive for non-degenerate ellipses.\n    A = b**2 * cos_a**2 + a**2 * sin_a**2\n    B = 2 * (b**2 * R_d_prime * cos_a + a**2 * Z_d_prime * sin_a)\n    C = b**2 * R_d_prime**2 + a**2 * Z_d_prime**2 - a**2 * b**2\n\n    discriminant = B**2 - 4 * A * C\n\n    # No real intersection (misses) or one-point intersection (tangent).\n    # Use a small tolerance for floating-point comparisons.\n    if discriminant = 1e-12:\n        return 0.0\n\n    sqrt_discriminant = np.sqrt(discriminant)\n    \n    # Solutions for t where the full line intersects the ellipse\n    t1 = (-B - sqrt_discriminant) / (2 * A)\n    t2 = (-B + sqrt_discriminant) / (2 * A)\n\n    # We are only interested in the forward-looking half-line, t >= 0.\n    # The intersection interval is [t1, t2]. We intersect this with [0, infinity).\n    \n    # Case 1: Both intersection points are \"behind\" the detector (t  0).\n    if t2  1e-12:\n        return 0.0\n    \n    # Case 2: The detector is inside the ellipse.\n    # The LOS starts at t=0 and exits at t=t2.\n    if t1  0:\n        return t2\n    \n    # Case 3: The detector is outside the ellipse.\n    # The LOS enters at t=t1 and exits at t=t2.\n    return t2 - t1\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases and print results.\n    \"\"\"\n    # ROI parameters are constant for all test cases.\n    R0, Z0 = 1.7, 0.0\n    a_out, b_out = 0.6, 1.02\n    a_in, b_in = 0.3, 0.51\n    \n    outer_ellipse = (R0, Z0, a_out, b_out)\n    inner_ellipse = (R0, Z0, a_in, b_in)\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2.5, 0.0, np.pi),\n        (3.0, 1.02, np.pi),\n        (3.0, 1.2, np.pi),\n        (2.15, 0.0, 0.0),\n        (2.6, 0.4, np.pi + np.pi / 6.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        los_params = case\n        \n        # Calculate intersection length with the solid outer ellipse.\n        len_out = calculate_single_ellipse_length(outer_ellipse, los_params)\n        \n        # Calculate intersection length with the solid inner ellipse.\n        len_in = calculate_single_ellipse_length(inner_ellipse, los_params)\n        \n        # The length in the annular region is the difference.\n        total_length = len_out - len_in\n        results.append(total_length)\n\n    # Format the results into a single string as required.\n    # Each result is formatted to six decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "探测器测得的原始能谱数据并非等离子体中发生的核反应的直接反映，而是经过探测器响应函数“展宽”和“扭曲”后的结果。要提取有物理意义的源信息，我们必须解决一个逆问题。本练习将引导您推导并实现一种强大的迭代算法——最大似然期望最大化（MLEM）算法 ，该算法广泛用于从测量的能谱数据中“解谱”，以重建潜在的伽马射线源强度。",
            "id": "3700970",
            "problem": "一台部署在磁约束核聚变装置上的伽马射线谱仪测量由快离子反应产生的各能量仓内的计数。令$y_i$表示仓$i$中观测到的计数，$\\lambda_i$表示仓$i$中的期望计数。假设各仓之间服从独立的泊松统计，其中$$\\lambda_i = \\sum_{j=1}^{n} R_{ij} x_j + b_i,$$ 此处，$R_{ij}$是一个已知的探测器响应矩阵，它将$n$个反应通道强度$x_j$映射到$m$个能量仓期望值，而$b_i \\ge 0$是一个已知的本底期望值。目标是通过最大化泊松对数似然函数$$L(\\mathbf{x}) = \\sum_{i=1}^{m}\\left( y_i \\ln \\lambda_i - \\lambda_i \\right),$$来计算非负反应通道强度$x_j \\ge 0$的最大似然估计，其中$\\lambda_i$如上定义。\n\n从泊松分布计数的独立性及泊松概率质量函数的定义出发，推导在非负约束下表征$L(\\mathbf{x})$关于$\\mathbf{x}$的驻点的条件。仅使用基本原理，概述一个能收敛到最大似然解（其中对所有$j$都有$x_j \\ge 0$）的迭代算法，并解释该迭代如何保证$\\lambda_i  0$。当目标函数$L(\\mathbf{x})$的相对变化低于预设容差或达到最大迭代次数时，迭代必须终止。\n\n然后，实现所推导的迭代算法，并将其应用于以下测试集。在每个案例中，$R$是一个具有非负项的$m \\times n$实矩阵，$b$是一个具有非负项的$m$维向量，$y$是一个非负整数组成的$m$维向量。对所有$j$将$x_j$初始化为正值，并在迭代过程中强制$x_j \\ge 0$。使用$\\varepsilon = 10^{-8}$的固定容差和$N_{\\max} = 10000$次的最大迭代次数。使用$\\lambda_i \\leftarrow \\max(\\lambda_i, \\delta)$和一个小的$\\delta = 10^{-12}$来保证对数和除法运算中的严格正性。不需要物理单位；所有量都视为无量纲的期望计数。\n\n测试集：\n1. 理想路径（Happy path）（$m=3, n=2$）：\n$$\nR = \\begin{bmatrix}\n0.85  0.15 \\\\\n0.10  0.90 \\\\\n0.50  0.50\n\\end{bmatrix},\\quad\nb = \\begin{bmatrix}\n3 \\\\\n2 \\\\\n1\n\\end{bmatrix},\\quad\ny = \\begin{bmatrix}\n130 \\\\\n95 \\\\\n110\n\\end{bmatrix}.\n$$\n\n2. 零计数和稀疏响应（$m=4, n=3$）：\n$$\nR = \\begin{bmatrix}\n0.90  0.00  0.10 \\\\\n0.20  0.70  0.10 \\\\\n0.00  0.60  0.40 \\\\\n0.10  0.10  0.80\n\\end{bmatrix},\\quad\nb = \\begin{bmatrix}\n1 \\\\\n1 \\\\\n0 \\\\\n0\n\\end{bmatrix},\\quad\ny = \\begin{bmatrix}\n0 \\\\\n60 \\\\\n40 \\\\\n80\n\\end{bmatrix}.\n$$\n\n3. 近似共线列（$m=3, n=2$）：\n$$\nR = \\begin{bmatrix}\n0.60  0.59 \\\\\n0.40  0.41 \\\\\n0.50  0.50\n\\end{bmatrix},\\quad\nb = \\begin{bmatrix}\n0.50 \\\\\n0.50 \\\\\n0.50\n\\end{bmatrix},\\quad\ny = \\begin{bmatrix}\n100 \\\\\n90 \\\\\n95\n\\end{bmatrix}.\n$$\n\n4. 本底主导情况（$m=3, n=2$）：\n$$\nR = \\begin{bmatrix}\n0.30  0.70 \\\\\n0.60  0.40 \\\\\n0.20  0.80\n\\end{bmatrix},\\quad\nb = \\begin{bmatrix}\n150 \\\\\n120 \\\\\n130\n\\end{bmatrix},\\quad\ny = \\begin{bmatrix}\n152 \\\\\n123 \\\\\n135\n\\end{bmatrix}.\n$$\n\n你的程序必须实现你推导的迭代最大似然算法，并对每个测试用例按给定顺序，生成最终估计的向量$\\mathbf{x}$，形式为浮点数列表。要求的输出格式为单行，包含一个由逗号分隔的四个结果的列表，每个结果本身都是一个用方括号括起来的逗号分隔列表。例如，如果有两个测试用例，格式将是 $$[\\,[x_{1,1},x_{1,2}],\\,[x_{2,1},x_{2,2}]\\,].$$ 在本问题中，你的程序应只产生一行输出，其中包含按指定嵌套列表格式排列的四个结果。",
            "solution": "该问题要求推导并实现一种迭代算法，用以在给定伽马射线谱仪的观测计数$\\mathbf{y}$的情况下，求解非负反应通道强度$\\mathbf{x}$的最大似然估计（MLE）。\n\n### 1. 问题公式化与对数似然\n\n假设每个能量仓$i$中的观测计数$y_i$是独立的随机变量，服从期望计数为$\\lambda_i$的泊松分布。单个仓的概率质量函数为：\n$$ P(y_i|\\lambda_i) = \\frac{\\lambda_i^{y_i} e^{-\\lambda_i}}{y_i!} $$\n鉴于$m$个仓的独立性，在给定期望向量$\\mathbf{\\lambda} = [\\lambda_1, \\dots, \\lambda_m]$的条件下，观测到计数向量$\\mathbf{y} = [y_1, \\dots, y_m]$的总似然是各个概率的乘积：\n$$ \\mathcal{L}(\\mathbf{\\lambda}) = P(\\mathbf{y}|\\mathbf{\\lambda}) = \\prod_{i=1}^{m} \\frac{\\lambda_i^{y_i} e^{-\\lambda_i}}{y_i!} $$\n期望$\\lambda_i$被建模为未知反应通道强度$\\mathbf{x} = [x_1, \\dots, x_n]$的线性函数，加上一个已知的本底$\\mathbf{b} = [b_1, \\dots, b_m]$：\n$$ \\lambda_i(\\mathbf{x}) = \\sum_{j=1}^{n} R_{ij} x_j + b_i $$\n此处，$R_{ij}$是已知的探测器响应矩阵$\\mathbf{R}$的元素。\n\n为求得$\\mathbf{x}$的最大似然估计，最大化对数似然函数$L(\\mathbf{x}) = \\ln \\mathcal{L}(\\mathbf{\\lambda}(\\mathbf{x}))$更为方便。取对数并舍去项$\\sum_i \\ln(y_i!)$（该项相对于$\\mathbf{x}$是常数，不影响最大值的位置），我们得到问题中给出的目标函数：\n$$ L(\\mathbf{x}) = \\sum_{i=1}^{m} \\left( y_i \\ln \\lambda_i(\\mathbf{x}) - \\lambda_i(\\mathbf{x}) \\right) $$\n该优化问题是在非负约束$x_j \\ge 0$（对所有$j=1, \\dots, n$）下最大化$L(\\mathbf{x})$。\n\n### 2. 驻点条件的推导\n\n这是一个约束优化问题。Karush-Kuhn-Tucker (KKT) 条件为解的最优性提供了必要条件。要应用这些条件，我们首先需要对数似然函数关于$\\mathbf{x}$的每个分量$x_k$的梯度。\n\n$L(\\mathbf{x})$关于$x_k$的偏导数为：\n$$ \\frac{\\partial L}{\\partial x_k} = \\frac{\\partial}{\\partial x_k} \\sum_{i=1}^{m} \\left( y_i \\ln \\lambda_i - \\lambda_i \\right) = \\sum_{i=1}^{m} \\left( \\frac{y_i}{\\lambda_i} \\frac{\\partial \\lambda_i}{\\partial x_k} - \\frac{\\partial \\lambda_i}{\\partial x_k} \\right) $$\n根据$\\lambda_i$的定义，我们有$\\frac{\\partial \\lambda_i}{\\partial x_k} = R_{ik}$。将此代入梯度表达式，得到：\n$$ \\frac{\\partial L}{\\partial x_k} = \\sum_{i=1}^{m} \\left( \\frac{y_i}{\\lambda_i} - 1 \\right) R_{ik} $$\n在约束$x_k \\ge 0$下最大化$L(\\mathbf{x})$的KKT条件要求，在最优解$\\mathbf{x}^*$处，对每个$k \\in \\{1, \\dots, n\\}$满足：\n1.  原始可行性（Primal feasibility）：$x_k^* \\ge 0$。\n2.  驻定性/互补松弛性（Stationarity/Complementary Slackness）：$x_k^* \\cdot \\frac{\\partial L}{\\partial x_k}\\bigg|_{\\mathbf{x}=\\mathbf{x}^*} = 0$ 且 $\\frac{\\partial L}{\\partial x_k}\\bigg|_{\\mathbf{x}=\\mathbf{x}^*} \\le 0$。\n\n这对于最优解$\\mathbf{x}^*$意味着两种情况：\n- 如果 $x_k^*  0$，则梯度必须为零：$\\frac{\\partial L}{\\partial x_k}\\bigg|_{\\mathbf{x}=\\mathbf{x}^*} = \\sum_{i=1}^{m} R_{ik} \\left( \\frac{y_i}{\\lambda_i^*} - 1 \\right) = 0$。\n- 如果 $x_k^* = 0$，则梯度必须为非正：$\\frac{\\partial L}{\\partial x_k}\\bigg|_{\\mathbf{x}=\\mathbf{x}^*} = \\sum_{i=1}^{m} R_{ik} \\left( \\frac{y_i}{\\lambda_i^*} - 1 \\right) \\le 0$。\n\n这两个条件共同刻画了在非负约束下对数似然函数的驻点。\n\n### 3. 迭代算法的推导\n\n对于一个活跃分量（$x_k  0$），其驻点条件可以重写为：\n$$ \\sum_{i=1}^{m} R_{ik} = \\sum_{i=1}^{m} R_{ik} \\frac{y_i}{\\lambda_i} $$\n直接从这个非线性方程组中求解$\\mathbf{x}$通常是不可行的。然而，这种形式启发我们使用不动点迭代法。让我们在两边同乘以$x_k$并除以$\\sum_{i'=1}^{m} R_{i'k}$（假设此和为正，如果通道$k$至少对一个仓有贡献，则该假设成立）：\n$$ x_k = x_k \\frac{\\sum_{i=1}^{m} R_{ik} \\frac{y_i}{\\lambda_i}}{\\sum_{i'=1}^{m} R_{i'k}} $$\n这个方程启发了以下迭代更新规则，该规则被称为最大似然期望最大化（MLEM）算法（在光学领域也称为Richardson-Lucy算法）：\n$$ x_k^{(t+1)} = x_k^{(t)} \\frac{\\sum_{i=1}^{m} R_{ik} \\frac{y_i}{\\lambda_i^{(t)}}}{\\sum_{i'=1}^{m} R_{i'k}} $$\n其中$t$是迭代指数，且$\\lambda_i^{(t)} = \\sum_{j=1}^{n} R_{ij} x_j^{(t)} + b_i$。\n\n### 4. 算法属性\n\n- **非负性**：如果我们以$x_k^{(0)}  0$进行初始化，那么由于$y_i \\ge 0$、$R_{ij} \\ge 0$且$\\lambda_i^{(t)}$保持为正，乘法因子总是非负的。因此，对于所有$t$，$x_k^{(t+1)} \\ge 0$都成立，自然地满足了约束条件。\n\n- **收敛性**：MLEM算法已被证明在每次迭代中单调非减地增加对数似然函数，即$L(\\mathbf{x}^{(t+1)}) \\ge L(\\mathbf{x}^{(t)})$。由于泊松对数似然函数在可行集上是严格凹的，并且对于给定的$\\mathbf{y}$有上界，因此对数似然值的序列会收敛。该算法收敛于似然函数的唯一全局最大值。\n\n- **保证$\\lambda_i  0$**：期望计数为$\\lambda_i = \\sum_j R_{ij} x_j + b_i$。由于所有的$R_{ij}$、$x_j$和$b_i$都是非负的，$\\lambda_i$也总是非负的。为防止除以零或对零取对数（当$\\lambda_i$在计算上变为零时可能发生，例如，如果$b_i=0$且所有有贡献的$x_j$都被驱向零），我们通过设置一个下限来强制其严格为正：$\\lambda_i \\leftarrow \\max(\\lambda_i, \\delta)$，其中$\\delta$是一个小的正常数。这确保了数值稳定性。\n\n### 5. 待实现算法总结\n\n1.  **初始化**：\n    - 设置容差$\\varepsilon = 10^{-8}$，最大迭代次数$N_{\\max} = 10000$，以及下限值$\\delta = 10^{-12}$。\n    - 初始化迭代计数器$t=0$。\n    - 将强度初始化为正值，例如，对所有$j=1, \\dots, n$设置$x_j^{(0)} = 1$。\n    - 对每个$k$预先计算归一化向量$s_k = \\sum_{i=1}^{m} R_{ik}$。\n    - 将前一次的对数似然$L_{\\text{prev}}$初始化为一个非常小的数（例如，负无穷大）。\n\n2.  **迭代循环**：对$t=0, 1, 2, \\dots$重复循环，直到$N_{\\max}-1$：\n    a. 计算期望计数：$\\lambda_i^{(t)} = \\sum_{j=1}^{n} R_{ij} x_j^{(t)} + b_i$。\n    b. 应用下限：$\\lambda_i^{\\text{safe}} = \\max(\\lambda_i^{(t)}, \\delta)$。\n    c. 计算当前对数似然：$L_{\\text{current}} = \\sum_{i=1}^{m} \\left( y_i \\ln(\\lambda_i^{\\text{safe}}) - \\lambda_i^{\\text{safe}} \\right)$。处理$y_i=0$的情况，此时$y_i\\ln(\\cdot)=0$。\n    d. 检查收敛性：如果$\\left| L_{\\text{current}} - L_{\\text{prev}} \\right| / (\\left| L_{\\text{current}} \\right| + \\varepsilon)  \\varepsilon$，则终止循环。\n    e. 更新$L_{\\text{prev}} = L_{\\text{current}}$。\n    f. 计算更新因子：更新的核心是比率$y_i / \\lambda_i^{\\text{safe}}$。\n    g. 更新强度：\n       $$ x_k^{(t+1)} = x_k^{(t)} \\cdot \\frac{1}{s_k} \\sum_{i=1}^{m} R_{ik} \\frac{y_i}{\\lambda_i^{\\text{safe}}} $$\n       必须小心实现此步骤，以避免在任何$s_k=0$时出现除以零的错误。在这种情况下，$x_k$是不可观测的，不应被更新。对于给定的问题，所有的$s_k0$。\n\n3.  **输出**：返回最终估计的强度向量$\\mathbf{x}^{(t+1)}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the MLEM algorithm on the provided test suite.\n    \"\"\"\n\n    def solve_mlem(R, b, y, tol=1e-8, max_iter=10000, delta=1e-12):\n        \"\"\"\n        Implements the Maximum Likelihood Expectation-Maximization (MLEM) algorithm.\n\n        Args:\n            R (np.ndarray): Detector-response matrix (m x n).\n            b (np.ndarray): Background expectation vector (m,).\n            y (np.ndarray): Observed counts vector (m,).\n            tol (float): Relative tolerance for log-likelihood convergence.\n            max_iter (int): Maximum number of iterations.\n            delta (float): Small positive constant to ensure lambda > 0.\n\n        Returns:\n            np.ndarray: The estimated nonnegative reaction-channel intensities x (n,).\n        \"\"\"\n        m, n = R.shape\n        \n        # Initialize intensities x_j to 1.0 for all j\n        x = np.ones(n, dtype=float)\n\n        # Pre-calculate normalization factor for each channel k\n        s = R.sum(axis=0)\n        \n        # Guard against unobservable channels (s_k = 0)\n        s[s == 0] = 1.0\n\n        # Initialize log-likelihood for convergence check\n        l_prev = -np.inf\n\n        for _ in range(max_iter):\n            # Calculate expected counts (forward projection)\n            # lambda_i = sum_j(R_ij * x_j) + b_i\n            # In vector form: lambda = R @ x + b\n            lambda_exp = R @ x + b\n            \n            # Apply floor to ensure lambda is strictly positive\n            lambda_safe = np.maximum(lambda_exp, delta)\n\n            # Calculate the log-likelihood L(x) = sum(y * log(lambda) - lambda)\n            # We must handle y_i=0 case where y_i*log(lambda) is 0\n            log_lambda = np.log(lambda_safe)\n            l_current = np.sum(np.where(y > 0, y * log_lambda, 0) - lambda_safe)\n\n            # Check for convergence based on relative change in log-likelihood\n            if np.abs(l_current - l_prev) / (np.abs(l_current) + tol)  tol:\n                break\n            l_prev = l_current\n\n            # Calculate the update factor (back projection)\n            # c_k = sum_i(R_ik * y_i / lambda_i)\n            # In vector form: correction = R.T @ (y / lambda)\n            ratio = y / lambda_safe\n            correction_factor = R.T @ ratio\n            \n            # Apply multiplicative update\n            x = x * correction_factor / s\n\n        return x\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([[0.85, 0.15], [0.10, 0.90], [0.50, 0.50]]),\n            np.array([3, 2, 1]),\n            np.array([130, 95, 110])\n        ),\n        (\n            np.array([[0.90, 0.00, 0.10], [0.20, 0.70, 0.10], [0.00, 0.60, 0.40], [0.10, 0.10, 0.80]]),\n            np.array([1, 1, 0, 0]),\n            np.array([0, 60, 40, 80])\n        ),\n        (\n            np.array([[0.60, 0.59], [0.40, 0.41], [0.50, 0.50]]),\n            np.array([0.50, 0.50, 0.50]),\n            np.array([100, 90, 95])\n        ),\n        (\n            np.array([[0.30, 0.70], [0.60, 0.40], [0.20, 0.80]]),\n            np.array([150, 120, 130]),\n            np.array([152, 123, 135])\n        )\n    ]\n\n    results = []\n    for R, b, y in test_cases:\n        x_mle = solve_mlem(R, b, y)\n        results.append(x_mle.tolist())\n\n    # Format the results into the required string format\n    final_output = str(results).replace(\" \", \"\")\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在科学推断中，获得物理参数的最佳估计值（点估计）固然重要，但量化这些估计值的不确定性同样关键。贝叶斯推断为此提供了一个强大的框架，它能够将测量数据与我们的先验知识相结合，从而得到参数的完整后验概率分布。本练习将带您实践一个典型的贝叶斯分析流程 ，学习如何在一个简化的线性模型下，为快离子密度和各向异性等关键等离子体参数计算后验均值和可信区间。",
            "id": "3700982",
            "problem": "您的任务是为核聚变等离子体中快离子反应的伽马射线能谱分析实现一个贝叶斯推断程序。考虑一组沿视线的伽马射线计数测量，这些测量被建模为具有高期望计数的泊松过程。每个测量通道在已知的积分时间内观测计数，反应率通过对两个潜变量（快离子密度和各向异性参数）的线性化响应来近似。\n\n基本出发点和建模假设：\n- 通道 $i$ 中的计数，记为 $K_i$，遵循均值为 $\\lambda_i$ 的泊松分布，其中 $\\lambda_i = T_i \\,\\mu_i$，$T_i$ 是已知的积分时间（单位为 $\\mathrm{s}$），$\\mu_i$ 是计数率（单位为 $\\mathrm{s}^{-1}$）。\n- 对于足够大的计数，泊松分布可以近似为具有相同均值和方差的正态分布。\n- 围绕标称工作点的线性化响应模型为 $\\boldsymbol{\\mu} \\approx \\mathbf{H}\\,\\boldsymbol{\\theta} + \\mathbf{b}$，其中 $\\boldsymbol{\\theta} = [n_f,\\ a]^\\top$，$n_f$ 是快离子密度（单位为 $\\mathrm{m}^{-3}$），$a$ 是一个无量纲的各向异性参数，$\\mathbf{H}$ 是在标称点评估的偏导数灵敏度矩阵（第一列的单位为 $\\mathrm{s}^{-1}\\,\\mathrm{m}^{3}$，第二列的单位为 $\\mathrm{s}^{-1}$ 每单位 $a$），$\\mathbf{b}$ 是基线计数率向量（单位为 $\\mathrm{s}^{-1}$）。标称点的线性化偏移量被吸收到 $\\mathbf{b}$ 中。\n- 将观测速率 $\\mathbf{r}$ 定义为分量形式 $r_i = K_i/T_i$（单位为 $\\mathrm{s}^{-1}$）。在正态近似和线性化下，采用对角噪声协方差，其元素为 $\\sigma_i^2 \\approx K_i / T_i^2$，由观测计数计算得出。\n\n贝叶斯先验：\n- 假设 $\\boldsymbol{\\theta}$ 服从高斯先验，其均值为 $\\boldsymbol{\\mu}_0$，协方差为 $\\boldsymbol{\\Lambda}_0$（单位与 $n_f$ 和 $a$ 一致），非对角线元素为零。\n\n任务：\n- 使用上述假设，实现一个程序，用于计算给定数据下 $\\boldsymbol{\\theta}$ 的高斯后验分布，并返回后验均值以及 $n_f$ 和 $a$ 在置信水平 $\\alpha = 0.95$ 下的边际等尾置信区间。\n- 以 $\\mathrm{m}^{-3}$ 表示 $n_f$，将 $a$ 表示为无量纲值。不使用角度单位。所有数值均以浮点数形式输出，不带单位。不需要四舍五入到固定位数。\n- 使用以下包含三种情况的测试套件。在每种情况下，有 $N$ 个视角。请完全按照列出的参数提供。\n\n情况 A（良态，高计数区）：\n- 视角数：$N=3$。\n- 积分时间 $\\mathbf{T}$（单位 $\\mathrm{s}$）：$[\\,2.0,\\ 1.5,\\ 2.5\\,]$。\n- 观测计数 $\\mathbf{K}$：$[\\,7680,\\ 4530,\\ 11350\\,]$。\n- 灵敏度矩阵列：\n  - 第一列 $\\mathbf{S}$（单位 $\\mathrm{s}^{-1}$ 每 $\\mathrm{m}^{-3}$）：$[\\,1.1\\times 10^{-14},\\ 0.9\\times 10^{-14},\\ 1.3\\times 10^{-14}\\,]$。\n  - 第二列 $\\mathbf{A}$（单位 $\\mathrm{s}^{-1}$ 每单位 $a$）：$[\\,800.0,\\ -400.0,\\ 1200.0\\,]$。\n- 基线速率向量 $\\mathbf{b}$（单位 $\\mathrm{s}^{-1}$）：$[\\,200.0,\\ 200.0,\\ 200.0\\,]$。\n- 先验均值 $\\boldsymbol{\\mu}_0 = [\\,2.5\\times 10^{17},\\ 0.0\\,]^\\top$。\n- 先验标准差：$\\sigma_{n_f,0} = 0.8\\times 10^{17}$ 和 $\\sigma_{a,0} = 0.5$；先验协方差是具有这些方差的对角矩阵。\n\n情况 B（短积分时间，低计数区）：\n- 视角数：$N=3$。\n- 积分时间 $\\mathbf{T}$（单位 $\\mathrm{s}$）：$[\\,0.2,\\ 0.1,\\ 0.15\\,]$。\n- 观测计数 $\\mathbf{K}$：$[\\,768,\\ 302,\\ 681\\,]$。\n- 灵敏度矩阵列：\n  - 第一列 $\\mathbf{S}$（单位 $\\mathrm{s}^{-1}$ 每 $\\mathrm{m}^{-3}$）：$[\\,1.1\\times 10^{-14},\\ 0.9\\times 10^{-14},\\ 1.3\\times 10^{-14}\\,]$。\n  - 第二列 $\\mathbf{A}$（单位 $\\mathrm{s}^{-1}$ 每单位 $a$）：$[\\,800.0,\\ -400.0,\\ 1200.0\\,]$。\n- 基线速率向量 $\\mathbf{b}$（单位 $\\mathrm{s}^{-1}$）：$[\\,200.0,\\ 200.0,\\ 200.0\\,]$。\n- 先验均值 $\\boldsymbol{\\mu}_0 = [\\,2.5\\times 10^{17},\\ 0.0\\,]^\\top$。\n- 先验标准差：$\\sigma_{n_f,0} = 0.8\\times 10^{17}$ 和 $\\sigma_{a,0} = 0.5$；先验协方差是对角的。\n\n情况 C（近共线性灵敏度，可辨识性压力测试）：\n- 视角数：$N=3$。\n- 积分时间 $\\mathbf{T}$（单位 $\\mathrm{s}$）：$[\\,1.0,\\ 1.2,\\ 0.8\\,]$。\n- 观测计数 $\\mathbf{K}$：$[\\,6150,\\ 11700,\\ 10680\\,]$。\n- 灵敏度矩阵列：\n  - 第一列 $\\mathbf{S}$（单位 $\\mathrm{s}^{-1}$ 每 $\\mathrm{m}^{-3}$）：$[\\,1.0\\times 10^{-14},\\ 1.6\\times 10^{-14},\\ 2.2\\times 10^{-14}\\,]$。\n  - 定义一个比例常数 $\\alpha = 3.0\\times 10^{18}$ 并设置第二列 $\\mathbf{A} = \\alpha\\,\\mathbf{S}$（单位 $\\mathrm{s}^{-1}$ 每单位 $a$），因此 $\\mathbf{A} = [\\,3.0\\times 10^{4},\\ 4.8\\times 10^{4},\\ 6.6\\times 10^{4}\\,]$。\n- 基线速率向量 $\\mathbf{b}$（单位 $\\mathrm{s}^{-1}$）：$[\\,150.0,\\ 150.0,\\ 150.0\\,]$。\n- 先验均值 $\\boldsymbol{\\mu}_0 = [\\,2.5\\times 10^{17},\\ 0.0\\,]^\\top$。\n- 先验标准差：$\\sigma_{n_f,0} = 0.8\\times 10^{17}$ 和 $\\sigma_{a,0} = 0.5$；先验协方差是对角的。\n\n算法要求：\n- 从 $\\mathbf{K}$ 和 $\\mathbf{T}$ 构造 $\\mathbf{r}$，即 $r_i = K_i/T_i$。\n- 构造 $\\mathbf{r}$ 的对角协方差，其元素为 $\\sigma_i^2 = K_i/T_i^2$。\n- 通过将 $\\mathbf{S}$ 和 $\\mathbf{A}$ 作为列拼接，形成 $N\\times 2$ 矩阵 $\\mathbf{H}$，并使用 $\\mathbf{b}$ 通过计算 $\\mathbf{y} = \\mathbf{r} - \\mathbf{b}$ 来平移 $\\mathbf{r}$ 的均值。\n- 将高斯似然与高斯先验结合，以获得 $\\boldsymbol{\\theta}$ 及其协方差的高斯后验。\n- 从边际后验方差中，计算每个分量在置信水平 $\\alpha = 0.95$ 下的对称等尾置信区间。\n\n最终输出格式：\n- 对于每种情况，输出一个包含六个浮点数的列表，顺序如下：$[\\ \\text{mean}(n_f),\\ \\text{lower}_{0.95}(n_f),\\ \\text{upper}_{0.95}(n_f),\\ \\text{mean}(a),\\ \\text{lower}_{0.95}(a),\\ \\text{upper}_{0.95}(a)\\ ]$。\n- 您的程序应生成单行输出，其中包含情况 A、B 和 C 的结果，形式为一个由这三个列表组成的逗号分隔列表，并用方括号括起来（例如，$[[…],[…],[…]]$）。",
            "solution": "在对其组成部分进行彻底审查后，该问题被认定是有效的。它具有科学依据，提法恰当，是客观的，并包含了推导出唯一解所需的所有必要信息。问题的核心是将贝叶斯推断应用于一个带有高斯噪声和高斯先验的线性化物理模型，这是数据分析中的一种标准技术。\n\n目标是推断一个二维参数向量 $\\boldsymbol{\\theta} = [n_f, a]^\\top$ 的后验分布，其中 $n_f$ 是快离子密度，$a$ 是一个各向异性参数。该推断基于一组伽马射线计数测量。\n\n首先，我们形式化统计模型。问题陈述，通道 $i$ 中的观测计数 $K_i$ 服从泊松分布，对于大计数，该分布可以近似为正态分布。通道 $i$ 中的观测速率为 $r_i = K_i / T_i$，其中 $T_i$ 是积分时间。该速率的均值为 $\\mu_i$，其方差为 $\\sigma_i^2 = \\text{Var}(K_i/T_i) = \\text{Var}(K_i)/T_i^2$。对于泊松分布，$\\text{Var}(K_i) = \\mathbb{E}[K_i] = \\lambda_i = T_i \\mu_i$。使用观测计数 $K_i$ 作为 $\\lambda_i$ 的估计，观测速率 $r_i$ 的方差近似为 $\\sigma_i^2 \\approx K_i / T_i^2$。\n\n因此，观测速率集合 $\\mathbf{r} = [r_1, \\dots, r_N]^\\top$ 可以用一个多元正态分布来建模，其均值向量为 $\\boldsymbol{\\mu}$，对角协方差矩阵为 $\\mathbf{C}$，对角元素为 $C_{ii} = \\sigma_i^2$。\n真实速率 $\\boldsymbol{\\mu}$ 与参数 $\\boldsymbol{\\theta}$ 之间的关系由线性化模型给出：\n$$\n\\boldsymbol{\\mu} \\approx \\mathbf{H}\\boldsymbol{\\theta} + \\mathbf{b}\n$$\n其中 $\\mathbf{H}$ 是 $N \\times 2$ 的灵敏度矩阵，$\\mathbf{b}$ 是基线速率向量。\n可用于推断的数据是向量 $\\mathbf{y} = \\mathbf{r} - \\mathbf{b}$，根据模型，它与 $\\boldsymbol{\\theta}$ 的关系如下：\n$$\n\\mathbf{y} \\sim \\mathcal{N}(\\mathbf{H}\\boldsymbol{\\theta}, \\mathbf{C})\n$$\n这构成了给定数据 $\\mathbf{y}$ 时 $\\boldsymbol{\\theta}$ 的似然函数。其概率密度函数为：\n$$\np(\\mathbf{y} | \\boldsymbol{\\theta}) \\propto \\exp\\left(-\\frac{1}{2} (\\mathbf{y} - \\mathbf{H}\\boldsymbol{\\theta})^\\top \\mathbf{C}^{-1} (\\mathbf{y} - \\mathbf{H}\\boldsymbol{\\theta})\\right)\n$$\n关于 $\\boldsymbol{\\theta}$ 的先验知识也建模为高斯分布：\n$$\np(\\boldsymbol{\\theta}) \\sim \\mathcal{N}(\\boldsymbol{\\mu}_0, \\boldsymbol{\\Lambda}_0)\n$$\n其中 $\\boldsymbol{\\mu}_0$ 是先验均值，$\\boldsymbol{\\Lambda}_0$ 是先验协方差矩阵。其概率密度为：\n$$\np(\\boldsymbol{\\theta}) \\propto \\exp\\left(-\\frac{1}{2} (\\boldsymbol{\\theta} - \\boldsymbol{\\mu}_0)^\\top \\boldsymbol{\\Lambda}_0^{-1} (\\boldsymbol{\\theta} - \\boldsymbol{\\mu}_0)\\right)\n$$\n根据贝叶斯定理，后验概率分布 $p(\\boldsymbol{\\theta} | \\mathbf{y})$ 与似然和先验的乘积成正比：\n$$\np(\\boldsymbol{\\theta} | \\mathbf{y}) \\propto p(\\mathbf{y} | \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta})\n$$\n由于两个高斯分布的乘积是另一个高斯分布，后验分布也将是高斯分布：$p(\\boldsymbol{\\theta} | \\mathbf{y}) \\sim \\mathcal{N}(\\boldsymbol{\\mu}_p, \\boldsymbol{\\Lambda}_p)$。后验密度的指数是似然和先验指数的和（忽略常数项）：\n$$\n-\\frac{1}{2} \\left( (\\mathbf{y} - \\mathbf{H}\\boldsymbol{\\theta})^\\top \\mathbf{C}^{-1} (\\mathbf{y} - \\mathbf{H}\\boldsymbol{\\theta}) + (\\boldsymbol{\\theta} - \\boldsymbol{\\mu}_0)^\\top \\boldsymbol{\\Lambda}_0^{-1} (\\boldsymbol{\\theta} - \\boldsymbol{\\mu}_0) \\right)\n$$\n通过展开二次型并对 $\\boldsymbol{\\theta}$ 进行配方，可以推导出后验均值 $\\boldsymbol{\\mu}_p$ 和后验协方差 $\\boldsymbol{\\Lambda}_p$。对于此贝叶斯线性模型，标准结果是：\n$$\n\\boldsymbol{\\Lambda}_p^{-1} = \\mathbf{H}^\\top \\mathbf{C}^{-1} \\mathbf{H} + \\boldsymbol{\\Lambda}_0^{-1}\n$$\n$$\n\\boldsymbol{\\mu}_p = \\boldsymbol{\\Lambda}_p (\\mathbf{H}^\\top \\mathbf{C}^{-1} \\mathbf{y} + \\boldsymbol{\\Lambda}_0^{-1} \\boldsymbol{\\mu}_0)\n$$\n这里，$\\boldsymbol{\\Lambda}_p^{-1}$ 是后验精度矩阵，它是似然精度（$\\mathbf{H}^\\top \\mathbf{C}^{-1} \\mathbf{H}$）和先验精度（$\\boldsymbol{\\Lambda}_0^{-1}$）的和。后验协方差通过对此矩阵求逆得到：$\\boldsymbol{\\Lambda}_p = (\\boldsymbol{\\Lambda}_p^{-1})^{-1}$。\n\n在情况 C 中，$\\mathbf{H}$ 的列是共线的，使得矩阵 $\\mathbf{H}^\\top \\mathbf{C}^{-1} \\mathbf{H}$ 是奇异的。纯粹基于似然的推断将会失败。然而，加上正定的先验精度 $\\boldsymbol{\\Lambda}_0^{-1}$ 对问题进行了正则化，确保后验精度 $\\boldsymbol{\\Lambda}_p^{-1}$ 是可逆的，从而使后验分布是良定义的。\n\n一旦计算出后验均值向量 $\\boldsymbol{\\mu}_p$ 和协方差矩阵 $\\boldsymbol{\\Lambda}_p$，每个参数 $\\theta_j$（其中 $j \\in \\{1, 2\\}$）的边际分布是一个均值为 $(\\boldsymbol{\\mu}_p)_j$、方差为 $(\\boldsymbol{\\Lambda}_p)_{jj}$ 的高斯分布。设 $\\mu_{p,j}$ 为参数 $j$ 的后验均值，$\\sigma_{p,j} = \\sqrt{(\\boldsymbol{\\Lambda}_p)_{jj}}$ 为其后验标准差。\n\n$\\theta_j$ 的 $100(1-\\delta)\\%$ 等尾置信区间由下式给出：\n$$\n[\\mu_{p,j} - z_{\\delta/2} \\sigma_{p,j}, \\mu_{p,j} + z_{\\delta/2} \\sigma_{p,j}]\n$$\n其中 $z_{\\delta/2}$ 是标准正态分布的上 $\\delta/2$ 临界值。对于指定的置信水平 $\\alpha=0.95$，我们有 $\\delta = 0.05$，因此需要 $z_{0.025}$。该值为 $\\Phi^{-1}(1-0.025) = \\Phi^{-1}(0.975) \\approx 1.959964$。\n\n每个测试用例的算法如下：\n1.  构建向量 $\\mathbf{T}$ 和 $\\mathbf{K}$。\n2.  计算观测速率 $\\mathbf{r}$，其元素为 $r_i = K_i / T_i$。\n3.  计算平移后的数据向量 $\\mathbf{y} = \\mathbf{r} - \\mathbf{b}$。\n4.  构建对角数据协方差矩阵 $\\mathbf{C}$，其对角元素为 $C_{ii} = K_i / T_i^2$，以及它的逆矩阵 $\\mathbf{C}^{-1}$，其对角元素为 $T_i^2 / K_i$。\n5.  通过拼接列向量 $\\mathbf{S}$ 和 $\\mathbf{A}$ 来构建灵敏度矩阵 $\\mathbf{H}$。\n6.  从给定的先验标准差构建先验均值向量 $\\boldsymbol{\\mu}_0$ 和对角先验协方差矩阵 $\\boldsymbol{\\Lambda}_0$（方差是标准差的平方）。计算其逆矩阵 $\\boldsymbol{\\Lambda}_0^{-1}$。\n7.  计算后验精度矩阵 $\\boldsymbol{\\Lambda}_p^{-1} = \\mathbf{H}^\\top \\mathbf{C}^{-1} \\mathbf{H} + \\boldsymbol{\\Lambda}_0^{-1}$。\n8.  将其求逆以获得后验协方差矩阵 $\\boldsymbol{\\Lambda}_p = (\\boldsymbol{\\Lambda}_p^{-1})^{-1}$。\n9.  计算后验均值向量 $\\boldsymbol{\\mu}_p = \\boldsymbol{\\Lambda}_p (\\mathbf{H}^\\top \\mathbf{C}^{-1} \\mathbf{y} + \\boldsymbol{\\Lambda}_0^{-1} \\boldsymbol{\\mu}_0)$。\n10. 从 $\\boldsymbol{\\mu}_p$ 中提取 $n_f$ 和 $a$ 的后验均值。\n11. 从 $\\boldsymbol{\\Lambda}_p$ 的对角线提取后验方差并计算标准差。\n12. 使用 $z_{0.025}$ 临界值计算两个参数的 $95\\%$ 置信区间的下界和上界。\n13. 将所需的六个浮点数组装成一个列表，用于最终输出。\n此过程应用于提供的三个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final results.\n    \"\"\"\n\n    # Define the credibility level and the corresponding z-score.\n    alpha = 0.95\n    z_score = norm.ppf(1 - (1 - alpha) / 2)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: well-conditioned, high-count regime\n        {\n            \"T\": np.array([2.0, 1.5, 2.5]),\n            \"K\": np.array([7680, 4530, 11350]),\n            \"S\": np.array([1.1e-14, 0.9e-14, 1.3e-14]),\n            \"A\": np.array([800.0, -400.0, 1200.0]),\n            \"b\": np.array([200.0, 200.0, 200.0]),\n            \"mu0\": np.array([2.5e17, 0.0]),\n            \"sigma0\": np.array([0.8e17, 0.5]),\n        },\n        # Case B: short integration times, lower-count regime\n        {\n            \"T\": np.array([0.2, 0.1, 0.15]),\n            \"K\": np.array([768, 302, 681]),\n            \"S\": np.array([1.1e-14, 0.9e-14, 1.3e-14]),\n            \"A\": np.array([800.0, -400.0, 1200.0]),\n            \"b\": np.array([200.0, 200.0, 200.0]),\n            \"mu0\": np.array([2.5e17, 0.0]),\n            \"sigma0\": np.array([0.8e17, 0.5]),\n        },\n        # Case C: nearly colinear sensitivities, identifiability stress test\n        {\n            \"T\": np.array([1.0, 1.2, 0.8]),\n            \"K\": np.array([6150, 11700, 10680]),\n            \"S\": np.array([1.0e-14, 1.6e-14, 2.2e-14]),\n            \"A\": 3.0e18 * np.array([1.0e-14, 1.6e-14, 2.2e-14]),\n            \"b\": np.array([150.0, 150.0, 150.0]),\n            \"mu0\": np.array([2.5e17, 0.0]),\n            \"sigma0\": np.array([0.8e17, 0.5]),\n        },\n    ]\n\n    results = []\n    for case_data in test_cases:\n        # Pass data to the core computation function\n        result = compute_posterior(case_data, z_score)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Using str(list) automatically adds spaces which are not desired.\n    # A manual join is better.\n    final_output_str = \"[\" + \",\".join([str(r) for r in results]) + \"]\"\n    print(final_output_str.replace(\" \", \"\"))\n\n\ndef compute_posterior(data, z_score):\n    \"\"\"\n    Computes the posterior mean and credible intervals for a given case.\n    \n    Args:\n        data (dict): A dictionary containing all the parameters for a single case.\n        z_score (float): The critical value for the credible interval calculation.\n        \n    Returns:\n        list: A list of 6 floats: [mean_nf, lower_nf, upper_nf, mean_a, lower_a, upper_a].\n    \"\"\"\n    T = data[\"T\"]\n    K = data[\"K\"]\n    S = data[\"S\"]\n    A = data[\"A\"]\n    b = data[\"b\"]\n    mu0 = data[\"mu0\"]\n    sigma0 = data[\"sigma0\"]\n\n    # 1. Construct observed rate vector r and shifted data vector y\n    r = K / T\n    y = r - b\n\n    # 2. Construct diagonal data covariance matrix C and its inverse C_inv\n    # C_ii = K_i / T_i^2\n    # C_inv_ii = T_i^2 / K_i\n    C_inv_diag = (T**2) / K\n    C_inv = np.diag(C_inv_diag)\n\n    # 3. Construct sensitivity matrix H\n    H = np.column_stack((S, A))\n    \n    # 4. Construct prior covariance matrix Lambda0 and its inverse Lambda0_inv\n    Lambda0 = np.diag(sigma0**2)\n    Lambda0_inv = np.diag(1 / (sigma0**2))\n    \n    # 5. Compute posterior precision matrix Lambda_p_inv\n    # Lambda_p_inv = H^T * C_inv * H + Lambda0_inv\n    Lambda_p_inv = H.T @ C_inv @ H + Lambda0_inv\n    \n    # 6. Compute posterior covariance matrix Lambda_p\n    Lambda_p = np.linalg.inv(Lambda_p_inv)\n    \n    # 7. Compute posterior mean vector mu_p\n    # mu_p = Lambda_p * (H^T * C_inv * y + Lambda0_inv * mu0)\n    term1 = H.T @ C_inv @ y\n    term2 = Lambda0_inv @ mu0\n    mu_p = Lambda_p @ (term1 + term2)\n    \n    # 8. Extract posterior means and standard deviations\n    mean_nf, mean_a = mu_p[0], mu_p[1]\n    std_nf = np.sqrt(Lambda_p[0, 0])\n    std_a = np.sqrt(Lambda_p[1, 1])\n    \n    # 9. Compute credible intervals\n    lower_nf = mean_nf - z_score * std_nf\n    upper_nf = mean_nf + z_score * std_nf\n    lower_a = mean_a - z_score * std_a\n    upper_a = mean_a + z_score * std_a\n    \n    return [mean_nf, lower_nf, upper_nf, mean_a, lower_a, upper_a]\n\nsolve()\n```"
        }
    ]
}