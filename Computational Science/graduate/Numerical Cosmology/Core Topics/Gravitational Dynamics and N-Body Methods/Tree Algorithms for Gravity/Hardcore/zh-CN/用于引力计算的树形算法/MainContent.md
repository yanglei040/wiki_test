## 引言
在众多科学与工程领域，从天体物理学到等离子体物理学，精确模拟大量粒子间的[长程相互作用](@entry_id:140725)是理解复杂系统演化的核心。一个典型的例子是求解[牛顿引力](@entry_id:159796)下的[N体问题](@entry_id:142540)，其直接计算所有粒子对相互作用的复杂度高达$O(N^2)$。当粒子数N达到数百万乃至数十亿时，这种计算成本变得无法承受。为了攻克这一挑战，研究者们开发了多种高效的[近似算法](@entry_id:139835)。其中，树算法（Tree Algorithms）因其巧妙的物理思想和出色的计算效率，已成为处理此类长程相互作用问题最重要的[范式](@entry_id:161181)之一。

本文旨在系统性地介绍用于[引力](@entry_id:175476)计算的树算法。我们将首先在“原理与机制”一章中，深入剖析其核心思想：如何利用[多极展开](@entry_id:144850)来近似远距离相互作用，并借助八叉[树[数据结](@entry_id:272011)构](@entry_id:262134)进行高效的空间组织，重点阐述经典的[Barnes-Hut算法](@entry_id:147108)。随后，在“应用与交叉学科联系”一章中，我们将探讨该算法在[现代宇宙学](@entry_id:752086)模拟中的前沿应用，以及它如何被推广至[流体力学](@entry_id:136788)、等离子体物理乃至数据科学等多个领域。最后，“动手实践”部分将通过具体练习，帮助读者巩固关键概念。通过这趟旅程，读者将全面掌握树算法的理论基础、实践技巧及其跨学科的强大生命力。

## 原理与机制

本章在前一章介绍的背景之上，将深入探讨用于[引力](@entry_id:175476)计算的树算法的核心原理与机制。我们将从[引力](@entry_id:175476)[多体问题](@entry_id:138087)固有的计算挑战出发，系统地构建一个近似解的框架。这个框架的核心是两个概念的结合：用多极展开来近似远距离相互作用，以及用分层树结构来高效地组织粒子。我们将详细阐述经典的 Barnes-Hut 算法，并探讨在真实的[宇宙学模拟](@entry_id:747928)中必须解决的关键实际问题，例如[宇宙膨胀](@entry_id:161474)、[引力软化](@entry_id:146273)和周期性边界条件。最后，我们将展望更高级的算法思想，包括如何更精确地保持物理守恒律，以及向着更高效率的[快速多极子方法](@entry_id:140932)（FMM）迈进。

### [引力](@entry_id:175476)多体问题的计算挑战

在[牛顿引力](@entry_id:159796)的框架下，一个由 $N$ 个点质量粒子组成的[自引力系统](@entry_id:155831)的演化，本质上是一个多体问题。假设第 $i$ 个粒子的质量为 $m_i$，其在[笛卡尔坐标系](@entry_id:169789)中的位置为 $\mathbf{r}_i$。根据牛顿的[万有引力](@entry_id:157534)定律和[叠加原理](@entry_id:144649)，作用在粒子 $i$ 上的总[引力](@entry_id:175476)是其他所有粒子对其[引力](@entry_id:175476)的矢量和。根据[牛顿第二定律](@entry_id:274217) $\mathbf{F}_i = m_i \mathbf{a}_i$，粒子 $i$ 的矢量加速度 $\mathbf{a}_i$ 可以表示为：

$$
\mathbf{a}_i = -G \sum_{j \neq i} m_j \frac{\mathbf{r}_i - \mathbf{r}_j}{\left|\mathbf{r}_i - \mathbf{r}_j\right|^3}
$$

其中 $G$ 是[引力常数](@entry_id:262704)。这个表达式精确地描述了系统中任意一个粒子的运动状态。要通过[数值积分](@entry_id:136578)来模拟整个系统的演化，我们需要在每个时间步都计算出所有 $N$ 个粒子的加速度。

这种**直接求和（direct summation）**方法虽然精确，但计算成本极其高昂。对于每个粒子，我们都需要计算它与其余 $N-1$ 个粒子之间的相互作用。表面上看，这需要 $N \times (N-1)$ 次力计算。然而，我们可以利用牛顿第三定律（$\mathbf{F}_{ij} = -\mathbf{F}_{ji}$）来优化。一旦我们计算了粒子 $j$ 对粒子 $i$ 的作用力，粒子 $i$ 对粒子 $j$ 的作用力也就随之确定，无需重复计算。因此，我们只需要计算系统中所有唯一的、无序的粒子对 $\{i, j\}$ 之间的相互作用。这样的粒子对总数由组[合数](@entry_id:263553)给出：

$$
\binom{N}{2} = \frac{N(N-1)}{2} = \frac{1}{2}N^2 - \frac{1}{2}N
$$

对于较大的 $N$，这个数字约等于 $\frac{1}{2}N^2$。在计算复杂度的分析中，我们关注的是当 $N$ 趋于无穷时，计算量随 $N$ 的增长趋势。因此，我们说直接求和法的计算复杂度为 $O(N^2)$。

在天体物理学和宇宙学中，模拟的粒子数 $N$ 往往非常巨大，从数百万到数千亿不等。一个 $O(N^2)$ 的算法在这种情况下是完全不可行的。例如，当 $N$ 增加10倍时，计算时间会增加100倍。正是这种巨大的计算挑战，催生了各种[近似算法](@entry_id:139835)，而树算法是其中最成功和应用最广泛的一类。

### 分层思想：用多极近似替代远距离粒[子群](@entry_id:146164)

树算法的核心思想非常直观：当一个粒子团簇距离我们足够远时，我们无需关心其内部的[精细结构](@entry_id:140861)，可以将其近似为一个单一的等效“粒子”。这个等效粒子的[引力](@entry_id:175476)效应由该团簇的整体属性（如总质量、[质心](@entry_id:265015)位置等）决定。这个物理直觉的数学基础是**[多极展开](@entry_id:144850)（multipole expansion）**。

考虑一个有界[质量分布](@entry_id:158451) $\rho(\mathbf{r}')$，其完全包含在以原点为中心、半径为 $R$ 的球内。在球外的任意场点 $\mathbf{r}$（即 $|\mathbf{r}| > R$），[引力势](@entry_id:160378) $\phi(\mathbf{r})$ 可以通过对格林函数 $|\mathbf{r} - \mathbf{r}'|^{-1}$ 进行泰勒展开来得到。当 $|\mathbf{r}'| < |\mathbf{r}|$ 时，这个展开收敛，其结果就是[引力势](@entry_id:160378)的[多极展开](@entry_id:144850)：

$$
\phi(\mathbf{r}) = \phi_{\text{monopole}} + \phi_{\text{dipole}} + \phi_{\text{quadrupole}} + \dots
$$

展开的前几项具有明确的物理意义 ：

- **[单极矩](@entry_id:267768)（Monopole）**: 这是零阶项，它将整个[质量分布](@entry_id:158451)近似为集中在[质心](@entry_id:265015)的一个点质量。
  $$
  \phi_{\text{monopole}}(\mathbf{r}) = -\frac{G M}{r}
  $$
  其中 $M = \int \rho(\mathbf{r}') \, d^3\mathbf{r}'$ 是总质量，$r=|\mathbf{r}|$。这是最简单也是最重要的近似。

- **偶极矩（Dipole）**: 一阶项与偶极矩 $\mathbf{p} = \int \rho(\mathbf{r}') \, \mathbf{r}' \, d^3\mathbf{r}'$ 相关。然而，如果我们选择质量分布的**[质心](@entry_id:265015)（center of mass）**作为展开的原点，那么根据定义，偶极矩 $\mathbf{p}$ 将为零。因此，在以质心为中心的展开中，偶极矩项消失，这极大地简化了计算。

- **四极矩（Quadrupole）**: 二阶项描述了质量分布偏离球对称的程度。使用对称、无迹的[四极矩张量](@entry_id:269661) $Q_{ij} = \int \rho(\mathbf{r}') (3 r'_i r'_j - |\mathbf{r}'|^2 \delta_{ij}) \, d^3\mathbf{r}'$（其中 $\delta_{ij}$ 是克罗内克符号），四极势可以写为：
  $$
  \phi_{\text{quadrupole}}(\mathbf{r}) = -\frac{G}{2} \frac{Q_{kl} r_k r_l}{r^5}
  $$
  这里我们使用了爱因斯坦求和约定。

将这些项合并，引力势到四极矩阶的近似为：
$$
\phi(\mathbf{r}) \approx -G \frac{M}{r} - \frac{G}{2} \frac{Q_{kl} r_k r_l}{r^5}
$$
这个展开式仅在场点位于[质量分布](@entry_id:158451)之外（即 $r > R$）时收敛。

在数值模拟中，我们最终需要的是加速度 $\mathbf{a} = -\nabla \phi$。通过对上述势函数求梯度，我们可以得到由[单极矩](@entry_id:267768)和[四极矩](@entry_id:157717)产生的加速度 。令 $\mathbf{r}$ 为从[质心](@entry_id:265015)[指向场](@entry_id:195269)点的矢量，其分量为 $r_i$，模为 $r=|\mathbf{r}|$。加速度的第 $i$ 个分量 $a_i$ 为：

$$
a_i = -\frac{\partial \phi}{\partial r_i} \approx -G M \frac{r_i}{r^3} + G \left( \frac{Q_{ij} r_j}{r^5} - \frac{5}{2} \frac{(Q_{kl} r_k r_l) r_i}{r^7} \right)
$$

第一项是熟悉的点质量[引力](@entry_id:175476)加速度。第二项是[四极矩](@entry_id:157717)修正，它包含了两个部分：一个与[四极张量](@entry_id:276086)和位置矢量的直接耦合有关，另一个则与[四极张量](@entry_id:276086)在位置矢量方向上的投影有关。这个公式为我们提供了一个具体的计算方案：对于一个遥远的粒子团簇，我们可以计算它的总质量 $M$ 和[四极矩张量](@entry_id:269661) $Q_{ij}$，然后用这个公式来近似它产生的[引力](@entry_id:175476)加速度，从而避免了对团簇内每个粒子进行单独计算。

### [空间分解](@entry_id:755142)：八叉[树[数据结](@entry_id:272011)构](@entry_id:262134)

为了系统地应用多极近似，我们需要一种能将三维空间中的粒子进行分层组织的[数据结构](@entry_id:262134)。在三维空间中，**[八叉树](@entry_id:144811)（octree）**是实现这一目标最自然和最常用的选择。

[八叉树](@entry_id:144811)是一种递归的空间划分结构。其构建过程如下 ：
1.  首先，确定一个足够大的立方体，称为**根节点（root node）**，它能包围系统中的所有粒子。
2.  如果一个节点（立方体单元）包含的粒子数超过某个预设的阈值 $n_{\text{leaf}}$（例如 $n_{\text{leaf}}=1$），则该节点被视为内部节点。我们将这个立方体沿三个坐标轴的中点平面切分，得到八个大小相等的子立方体，称为**子节点（children）**。然后，将原节点内的所有粒子根据其空间位置重新分配到这八个子节点中。
3.  如果一个节点包含的粒子数不大于 $n_{\text{leaf}}$，则它是一个**[叶节点](@entry_id:266134)（leaf node）**，不再进行划分。
4.  对所有新生成的内部子节点重复步骤2和3，直到所有粒子都位于叶节点中。

通过这个过程，我们得到一个树状结构，其中每个节点都对应着空间中的一个立方体区域。每个节点都可以存储其所包含粒[子群](@entry_id:146164)的[物理信息](@entry_id:152556)，例如总质量 $M$、质心位置 $\mathbf{r}_{\text{cm}}$，以及用于[高阶近似](@entry_id:262792)的[四极矩张量](@entry_id:269661) $Q_{ij}$。

值得注意的是，[八叉树](@entry_id:144811)的几何划分是基于节点的**几何中心** $\mathbf{c}$ 和边长 $s$ 的，而用于[多极展开](@entry_id:144850)的物理量（如[质心](@entry_id:265015)）是根据节点内粒子质量[分布](@entry_id:182848)计算的。这两者通常不重合。

树的最终形态在很大程度上取决于根节点的选择方式。如果根节点是预先固定的（例如，在一个周期性边界的模拟盒子中），那么对于给定的[粒子分布](@entry_id:158657)，无论粒子以何种顺序插入树中，最终生成的树结构都是唯一的。然而，在某些实现中，根节点是动态“生长”的：从包含第一个粒子的一个小盒子开始，当新插入的粒子落在盒子外时，就将盒子扩大（通常是边长加倍并移动中心），直到它能容纳所有粒子。在这种**在线生长根（online growing root）**策略下，粒子的插入顺序会影响根节点的最终大小和中心位置，进而改变整个树的结构，包括其深度和平衡性 。

### Barnes-Hut 算法：结合树与多极展开

Barnes-Hut（BH）算法巧妙地将[八叉树](@entry_id:144811)结构与[多极展开](@entry_id:144850)结合起来，形成了一个高效的[引力](@entry_id:175476)计算方案。其核心流程如下：
1.  **建树（Tree Construction）**：为当前时间步的所有粒子构建一棵[八叉树](@entry_id:144811)。
2.  **计算节点属性（Property Calculation）**：从叶节点开始，自底向上遍历树。对于每个父节点，其物理属性（如总质量、质心位置）可以通过聚合其所有子节点的属性来计算。
3.  **力计算（Force Calculation）**：为系统中的每一个粒子计算加速度。这是算法的关键步骤。对于给定的一个目标粒子，我们从[八叉树](@entry_id:144811)的根节点开始进行一次**树遍历（tree traversal）**。

在树遍历过程中，对于当前访问的节点（设其边长为 $s$，与目标粒子的距离为 $d$），我们需要做一个决策：是将其作为一个整体（使用其多极展开）来计算[引力](@entry_id:175476)，还是需要“打开”它，深入到其子节点以获得更精确的计算？这个决策由**多极展开可接受判据（Multipole Acceptance Criterion, MAC）**或**打开判据（opening criterion）**决定。

经典的 BH 算法使用一个简单的几何判据 ：
$$
\frac{s}{d}  \theta
$$
其中 $\theta$ 是一个用户定义的[无量纲参数](@entry_id:169335)，称为**打开角（opening angle）**。
- 如果条件满足，说明该节点相对其距离而言足够“小”，可以安全地使用其[多极展开](@entry_id:144850)（例如，到[四极矩](@entry_id:157717)阶）来计算它对目标粒子的[引力](@entry_id:175476)，然后停止对该分支的深入遍历。
- 如果条件不满足，说明该节点太大或太近，其内部结构不可忽略。此时，我们需要递归地访问该节点的八个子节点，并对每个子节点重复此判据。
- 如果遍历到达一个叶节点，则直接计算叶节点内的粒子与目标粒子之间的[引力](@entry_id:175476)。

通过这种方式，每个粒子都与近处的粒子进行精确的直接计算，而与远处的大量粒子则通过与少数几个高级别树节点的近似计算来完成。这大大减少了计算量。对于一个相对均匀的[粒子分布](@entry_id:158657)，每个粒子的力计算需要遍历树的深度约为 $O(\log N)$，因此 BH 算法的总计算复杂度为 $O(N \log N)$，远优于直接求和的 $O(N^2)$。

值得注意的是，经典的 $s/d  \theta$ 判据是纯几何的，它没有考虑节点的质量或内部结构。这意味着，一个大质量节点和一个小质量节点，只要它们的 $s/d$ 值相同，就会被同等对待。这可能导致在高质量（高密度）区域的力计算误差较大。因此，一些更先进的**基于误差的判据**被提出来。例如，我们可以估计被忽略的最高阶多极矩（如单极近似中被忽略的[四极矩](@entry_id:157717)）对加速度的贡献，其量级约为 $G M s^2 / d^4$。通过要求这个估计误差小于某个容忍度，我们可以实现一个对质量和距离都敏感的自适应判据。这种判据倾向于对近处或大质量的节点使用更严格的条件（即更小的有效 $\theta$），而在远处或小质量的节点上放宽条件，从而在整个模拟区域内实现更均匀的力[误差控制](@entry_id:169753) 。

### 实际应用中的关键问题

将理想化的树算法应用于真实的[宇宙学模拟](@entry_id:747928)，还需要解决一系列关键的实际问题。

#### 宇宙学背景：[共动坐标系](@entry_id:266800)下的[运动方程](@entry_id:170720)

[宇宙学模拟](@entry_id:747928)并非在静态空间中进行，而是在一个根据广义相对论描述的[膨胀宇宙](@entry_id:161442)背景下。对于次[引力](@entry_id:175476)主导的非相对论性物质，我们可以使用一个非常有效的牛顿近似。我们引入**[共动坐标系](@entry_id:266800)（comoving coordinates）** $\mathbf{x}$，它与**物理[坐标系](@entry_id:156346)（physical coordinates）** $\mathbf{r}$ 通过宇宙**尺度因子（scale factor）** $a(t)$ 联系：$\mathbf{r}(t) = a(t) \mathbf{x}(t)$。尺度因子描述了宇宙的整[体膨胀](@entry_id:144241)。

粒子的运动被分解为两部分：随[宇宙膨胀](@entry_id:161474)的“哈勃流”，以及偏离哈勃流的**[本动速度](@entry_id:157964)（peculiar velocity）** $\mathbf{u}$。[本动速度](@entry_id:157964)定义为 $\mathbf{u} = a \dot{\mathbf{x}}$（其中 $\dot{\mathbf{x}}$ 是共动位置对时间的导数）。

从物理[坐标系](@entry_id:156346)下的牛顿第二定律出发，经过[坐标变换](@entry_id:172727)，我们可以推导出在[共动坐标系](@entry_id:266800)下描述粒子运动的[方程组](@entry_id:193238) ：
$$
\dot{\mathbf{x}} = \frac{\mathbf{u}}{a}
$$
$$
\dot{\mathbf{u}} + H \mathbf{u} = -\frac{1}{a} \nabla_{\mathbf{x}} \phi
$$
其中 $H(t) = \dot{a}(t)/a(t)$ 是**哈勃参数**，描述宇宙的膨胀速率。第二式中的 $H\mathbf{u}$ 项被称为**哈勃阻尼（Hubble drag）**，它描述了宇宙膨胀对[本动速度](@entry_id:157964)的“稀释”效应。$\phi(\mathbf{x}, t)$ 是**本动[引力势](@entry_id:160378)**，它由物质[分布](@entry_id:182848)的**[密度涨落](@entry_id:143540)**（即局部密度与宇宙平均密度的偏差）产生。

这个本动[引力势](@entry_id:160378) $\phi$ 满足一个修正的泊松方程，即**[共动泊松方程](@entry_id:747518)**：
$$
\nabla_{\mathbf{x}}^2 \phi = 4\pi G a^2 (\rho(\mathbf{x}, t) - \bar{\rho}(t))
$$
其中 $\rho(\mathbf{x}, t)$ 是物理密度，$\bar{\rho}(t)$ 是宇宙的平均物理密度。这个方程的源是[密度扰动](@entry_id:159546) $\rho - \bar{\rho}$。N-body 模拟实际上就是求解这套[方程组](@entry_id:193238)。树算法被用来在每个时间步高效地计算右侧的[引力场](@entry_id:169425) $-\nabla_{\mathbf{x}}\phi$。

#### [引力软化](@entry_id:146273)：处理近距离奇异性

在[数值模拟](@entry_id:137087)中，粒子被处理为点质量，这导致牛顿引力在距离 $r \to 0$ 时出现 $1/r^2$ 的奇异性。在真实的物理系统中（如[暗物质晕](@entry_id:147523)），物质是连续分布的，不会出现无限大的力。如果直接使用点质量模型，两个粒子偶然的近距离相遇会产生巨大的、非物理的加速度，导致它们被剧烈地散射出去。这种**[二体弛豫](@entry_id:756252)（two-body relaxation）**过程在模拟[无碰撞系统](@entry_id:158088)（如暗物质）时是一种数值噪音，必须被抑制。

**[引力软化](@entry_id:146273)（Gravitational softening）**正是解决这一问题的技术。其核心思想是用一个在 $r=0$ 处有限的光滑内核来替代点质量的[奇异势](@entry_id:754921)。这等效于将每个点质量粒子“模糊”成一个有一定尺寸的质量云 。

两种常见的软化方案是：

1.  **Plummer 软化**：这是最经典的方法之一。它将牛顿势 $-Gm/r$ 替换为：
    $$
    \Phi_{\text{P}}(r) = -\frac{G m}{\sqrt{r^2 + \epsilon^2}}
    $$
    其中 $\epsilon$ 是**[软化长度](@entry_id:755011)（softening length）**。这个势在 $r=0$ 处是有限值 $-Gm/\epsilon$，对应的力在 $r \to 0$ 时与 $r$ 成正比（类似于一个均匀密度球体内部的力），从而避免了奇异性。Plummer 软化的一个缺点是，即使在远大于 $\epsilon$ 的距离上，其产生的力也与牛顿引力有微小的偏差，只有在 $r/\epsilon \to \infty$ 时才渐近趋于牛顿引力。

2.  **样条软化（Spline softening）**：为了克服 Plummer 软化的远场偏差问题，现代模拟中常使用具有**紧致支撑（compact support）**的样条内核。在这种方案中，[引力](@entry_id:175476)相互作用只在小于某个半径 $h$ 的范围内被修改，而在 $r \ge h$ 的区域，势和力与[牛顿引力](@entry_id:159796)**完全相同**。在 $r  h$ 的区域内，势函数被构造成一个[分段多项式](@entry_id:634113)（例如[三次样条](@entry_id:140033)），并保证在衔接点 $r=h$ 处，势函数和它的导数（即力）都是连续的。这确保了从软化区域到牛顿区域的平滑过渡。样条软化的这一特性对于树算法尤其有利，因为它保证了只要一个树节点与目标粒子的距离足够远（大于 $h$），其[多极矩](@entry_id:191120)的计算就完全不受软化影响，从而得到更准确的远场力 。

#### [周期性边界条件](@entry_id:147809)

为了模拟一个具有[统计均匀性](@entry_id:136481)的无限大宇宙中的一小块[代表性](@entry_id:204613)区域，[宇宙学模拟](@entry_id:747928)几乎总是采用**[周期性边界条件](@entry_id:147809)（Periodic Boundary Conditions, PBC）**。这意味着模拟盒子在三个维度上被无限地复制和拼接。因此，计算一个粒子受到的[引力](@entry_id:175476)时，原则上需要考虑主盒子内所有其他粒子，以及所有无限多个镜像盒子中所有粒子的[引力](@entry_id:175476)。

直接对 $1/r^2$ 的[引力](@entry_id:175476)进行无限求和会导致发散。这个问题的物理解决方案与共动方程中的思想一致：宇宙的整体膨胀是由均匀的背景密度驱动的，而结构的形成只取决于密度的**涨落**。因此，我们通过在计算中减去宇宙的平均密度（相当于引入一个均匀的负密度背景来中和），使得[引力](@entry_id:175476)求和变得收敛。在傅里叶空间中，这对应于将[波数](@entry_id:172452)为零（$\mathbf{k}=0$）的模式（代表平均密度）的贡献设为零 。

在实践中，有几种标准方法来处理周期性[引力](@entry_id:175476)：
- **[Ewald 求和](@entry_id:142359)法**：将长程的 $1/r$ 势分解为一个在[实空间](@entry_id:754128)快速收敛的短程[部分和](@entry_id:162077)一个在倒易空间（傅里叶空间）快速收敛的长程部分。短程部分可以在主盒子内用类似于树算法的方法计算，而长程部分通过对倒易晶格的求和来完成。
- **粒子-网格（Particle-Mesh, PM）法**：将粒子质量分配到一个规则的网格上，使用[快速傅里叶变换](@entry_id:143432)（FFT）将密度[场变换](@entry_id:265108)到傅里叶空间，在那里应用周期性的格林函数（即乘以 $1/k^2$）来求解[泊松方程](@entry_id:143763)，然后再用[FFT逆变换](@entry_id:749305)回实空间得到力和势。FFT的性质天然地处理了周期性。
- **TreePM [混合算法](@entry_id:171959)**：这是一种结合了树算法和PM算法优点的混合方案。它将[引力](@entry_id:175476)分解为短程和长程两部分。短程部分（变化剧烈，需要高空间分辨率）用树算法在实空间计算，而长程部分（平滑，空间分辨率要求低）则用PM算法在网格上计算。这种方法兼顾了效率和精度，是目前大规模[宇宙学模拟](@entry_id:747928)的标准技术之一 。

### 高级主题与算法展望

#### 牛顿第三定律的执行与动量守恒

一个微妙但重要的问题是，标准的 Barnes-Hut 算法在近似力的计算中并不严格遵守[牛顿第三定律](@entry_id:166652)。考虑粒子 $i$ 和粒子 $j$ 以及它们所在的单元 $C_i$ 和 $C_j$。在计算 $i$ 受到的力时，算法可能会接受 $C_j$ 作为一个整体；而在计算 $j$ 受到的力时，算法可能会“打开”$C_i$。这导致近似力 $\mathbf{F}_{i \leftarrow j}^{\text{approx}}$ 不等于 $-\mathbf{F}_{j \leftarrow i}^{\text{approx}}$。

这种力的不对称性会导致整个系统的总线性动量不守恒，在长时间的模拟中可能出现明显的**动量漂移**。为了解决这个问题，可以采用**相互作用（mutual interaction）**方案。其思想是建立一个对称的、可接受的**单元-单元（cell-cell）**相互作用列表。对于列表中的每一对单元 $(A, B)$，只计算一次它们之间的相互作用力（例如，$\mathbf{F}_{A \leftarrow B}$），然后将这个力施加给 $A$，同时将它的相反力 $-\mathbf{F}_{A \leftarrow B}$ 施加给 $B$。通过这种方式，力的反对称性在近似层面被强制执行，从而保证了[动量守恒](@entry_id:149964)（在[浮点误差](@entry_id:173912)范围内）。

然而，这种对称方案也带来了新的计算挑战。生成对称的相互作用列表以及在并行计算中处理跨越不同处理器边界的单元对，都需要额外的簿记和同步/[通信开销](@entry_id:636355)。这可能会增加算法的复杂性并限制其在超[大规模并行计算](@entry_id:268183)中的[强扩展性](@entry_id:172096) 。

#### 超越 Barnes-Hut：[快速多极子方法](@entry_id:140932)简介

虽然 Barnes-Hut 算法的 $O(N \log N)$ 复杂度已经非常高效，但存在一种更为复杂的树算法——**[快速多极子方法](@entry_id:140932)（Fast Multipole Method, FMM）**，它在特定条件下可以达到理论上最优的 $O(N)$ 复杂度。

BH 算法和 FMM 的核心区别在于它们处理[远场](@entry_id:269288)相互作用的方式 ：

- **相互作用模式**：BH 是**单元-粒子（cell-to-particle）**模式。它直接在每个目标粒子的位置计算源单元的[多极展开](@entry_id:144850)。而 FMM 是一种**单元-单元（cell-to-cell）**模式。它引入了一个关键的**多极-局域（Multipole-to-Local, M2L）**转换操作。该操作能将一个遥远源单元的**多极展开**（描述其内部质量产生的外部场）转换成一个目标单元的**局域展开**（描述其外部质量在其内部产生的场）。

- **信息流**：FMM 的信息流更为复杂。它包含一个“向上传递”过程，在树的每一层聚合[多极矩](@entry_id:191120)；一个横向的 M2L 转换过程，在分离良好的单元之间传递[引力](@entry_id:175476)信息；以及一个“向下传递”过程，将局域展开从父节点传递到子节点，最终在[叶节点](@entry_id:266134)处作用于粒子。

- **[误差控制](@entry_id:169753)**：BH 的误差由经验性的打开角 $\theta$ 控制。而 FMM 的误差由展开的阶数 $p$ 控制，这提供了严格的、可解析的[误差界](@entry_id:139888)限。通过选择足够大的 $p$，FMM 可以达到任意指定的精度。

当[粒子分布](@entry_id:158657)足够均匀（保证树的平衡性和每个单元的相互作用列表大小有界）且展开阶数 $p$ 固定时，FMM 的计算复杂度可以达到 $O(N)$。这意味着计算每个粒子的力的平均成本是一个与 $N$ 无关的常数。尽管其实现复杂度和计算常数因子通常远大于 BH 算法，但 FMM 代表了 N-body 算法在精度控制和[渐近效率](@entry_id:168529)方面的顶峰 。