{
    "hands_on_practices": [
        {
            "introduction": "Barnes-Hut 算法的核心思想在于，将遥远的一组粒子近似为一个质点（即单极子）来简化计算。本练习将通过一个具体的例子，定量地审视这一近似。你将为一个简单的粒子系统分别计算精确的引力以及单极子近似下的引力，从而亲手衡量近似所带来的误差，并理解它与系统几何构型的关系，为后续理解张角判据打下基础。",
            "id": "3501662",
            "problem": "考虑在共动代码单位下的牛顿引力，其中引力常数 $G=1$。一个模拟 Barnes–Hut (BH) 树中单个遥远单元的简单结构包含一个位于原点、质量为 $m_{0}$ 的目标粒子，以及两个质量分别为 $m_{1}=1$ 和 $m_{2}=1$ 的源粒子，它们的位置是 $\\boldsymbol{r}_{1}=(10,1,0)$ 和 $\\boldsymbol{r}_{2}=(10,-1,0)$。忽略任何宇宙学膨胀因子或周期性镜像，并将相互作用视为三维欧几里得空间中的纯牛顿相互作用。\n\n从牛顿万有引力定律和质心的定义出发，依次完成以下任务：\n\n1. 计算两个源粒子对目标粒子施加的精确引力矢量 $\\boldsymbol{F}_{\\text{exact}}$。\n\n2. 仅使用单极矩项，通过一个 BH 树单元来近似两个源粒子的贡献：将这两个粒子替换为位于其质心位置 $\\boldsymbol{R}_{\\text{cm}}$、质量等于其总质量 $M$ 的单个点质量。计算作用在目标粒子上的近似力矢量 $\\boldsymbol{F}_{\\text{mono}}$。\n\n3. 使用你的结果，计算单极矩近似的相对误差，定义为\n$$\n\\varepsilon \\equiv \\frac{\\left\\lvert \\boldsymbol{F}_{\\text{exact}}-\\boldsymbol{F}_{\\text{mono}}\\right\\rvert}{\\left\\lvert \\boldsymbol{F}_{\\text{exact}}\\right\\rvert}.\n$$\n\n为了与 BH 张角判据建立联系，将有效单元尺寸定义为包含两个源粒子的最小轴对齐正方形的边长 $s$，并令 $d=\\lvert \\boldsymbol{R}_{\\text{cm}}\\rvert$。报告你与此结构关联的张角 $\\theta \\equiv s/d$，并将 $\\varepsilon$ 的数值解释为在该 $\\theta$ 和此几何构型下实现的相对误差。\n\n作为你的最终答案，仅提供 $\\varepsilon$ 的数值，表示为无量纲小数，并四舍五入到四位有效数字。",
            "solution": "该问题已经过验证，并被确定为牛顿力学中一个有效、适定的问题，可直接应用于宇宙学中数值算法的分析。该问题是自洽的、有科学依据且无歧义的。因此，我们可以进行正式求解。\n\n由源粒子 $j$（质量为 $m_j$，位置为 $\\boldsymbol{r}_j$）对粒子 $i$（质量为 $m_i$，位置为 $\\boldsymbol{r}_i$）施加的引力 $\\boldsymbol{F}_{ji}$ 由牛顿万有引力定律给出：\n$$\n\\boldsymbol{F}_{ji} = G \\frac{m_j m_i}{\\left\\lvert\\boldsymbol{r}_j - \\boldsymbol{r}_i\\right\\rvert^3} (\\boldsymbol{r}_j - \\boldsymbol{r}_i)\n$$\n在本问题中，引力常数 $G=1$。目标粒子质量为 $m_0$，位于原点，因此其位置矢量为 $\\boldsymbol{r}_0 = (0,0,0)$。两个源粒子的质量分别为 $m_1=1$ 和 $m_2=1$，位置分别为 $\\boldsymbol{r}_1 = (10,1,0)$ 和 $\\boldsymbol{r}_2 = (10,-1,0)$。\n\n**1. 精确引力**\n\n作用在目标粒子上的总精确引力 $\\boldsymbol{F}_{\\text{exact}}$ 是来自每个源粒子的单个力的矢量和：\n$$\n\\boldsymbol{F}_{\\text{exact}} = \\boldsymbol{F}_{10} + \\boldsymbol{F}_{20}\n$$\n其中 $\\boldsymbol{F}_{10}$ 是粒子 1 对粒子 0 的力，$\\boldsymbol{F}_{20}$ 是粒子 2 对粒子 0 的力。\n\n我们计算各个力矢量：\n从粒子 1 指向粒子 0 的矢量是 $\\boldsymbol{r}_0 - \\boldsymbol{r}_1 = -\\boldsymbol{r}_1$，但作用在粒子 0 上的力指向粒子 1，所以我们使用矢量 $\\boldsymbol{r}_1 - \\boldsymbol{r}_0 = \\boldsymbol{r}_1$。\n$$\n\\boldsymbol{F}_{10} = G \\frac{m_1 m_0}{\\left\\lvert\\boldsymbol{r}_1 - \\boldsymbol{r}_0\\right\\rvert^3} (\\boldsymbol{r}_1 - \\boldsymbol{r}_0) = (1) \\frac{(1) m_0}{\\left\\lvert\\boldsymbol{r}_1\\right\\rvert^3} \\boldsymbol{r}_1\n$$\n$\\boldsymbol{r}_1$ 的模的平方是 $\\left\\lvert\\boldsymbol{r}_1\\right\\rvert^2 = 10^2 + 1^2 + 0^2 = 101$。因此，$\\left\\lvert\\boldsymbol{r}_1\\right\\rvert = \\sqrt{101}$。\n$$\n\\boldsymbol{F}_{10} = \\frac{m_0}{(\\sqrt{101})^3} (10,1,0) = \\frac{m_0}{101\\sqrt{101}} (10,1,0)\n$$\n类似地，对于粒子 2：\n$$\n\\boldsymbol{F}_{20} = G \\frac{m_2 m_0}{\\left\\lvert\\boldsymbol{r}_2 - \\boldsymbol{r}_0\\right\\rvert^3} (\\boldsymbol{r}_2 - \\boldsymbol{r}_0) = (1) \\frac{(1) m_0}{\\left\\lvert\\boldsymbol{r}_2\\right\\rvert^3} \\boldsymbol{r}_2\n$$\n$\\boldsymbol{r}_2$ 的模的平方是 $\\left\\lvert\\boldsymbol{r}_2\\right\\rvert^2 = 10^2 + (-1)^2 + 0^2 = 101$。因此，$\\left\\lvert\\boldsymbol{r}_2\\right\\rvert = \\sqrt{101}$。\n$$\n\\boldsymbol{F}_{20} = \\frac{m_0}{(\\sqrt{101})^3} (10,-1,0) = \\frac{m_0}{101\\sqrt{101}} (10,-1,0)\n$$\n总的精确力是其和：\n$$\n\\boldsymbol{F}_{\\text{exact}} = \\boldsymbol{F}_{10} + \\boldsymbol{F}_{20} = \\frac{m_0}{101\\sqrt{101}} \\left[ (10,1,0) + (10,-1,0) \\right] = \\frac{m_0}{101\\sqrt{101}} (20,0,0)\n$$\n所以，$\\boldsymbol{F}_{\\text{exact}} = \\left(\\frac{20m_0}{101\\sqrt{101}}, 0, 0\\right)$。\n\n**2. 单极矩近似力**\n\n在单极矩近似中，两个源粒子被一个位于其质心 $\\boldsymbol{R}_{\\text{cm}}$ 的单个点质量 $M$ 所取代。\n总质量为 $M = m_1 + m_2 = 1 + 1 = 2$。\n质心位置为：\n$$\n\\boldsymbol{R}_{\\text{cm}} = \\frac{m_1\\boldsymbol{r}_1 + m_2\\boldsymbol{r}_2}{m_1+m_2} = \\frac{(1)(10,1,0) + (1)(10,-1,0)}{2} = \\frac{(10+10, 1-1, 0+0)}{2} = \\frac{(20,0,0)}{2} = (10,0,0)\n$$\n近似力 $\\boldsymbol{F}_{\\text{mono}}$ 是这个单一点质量对目标粒子施加的力：\n$$\n\\boldsymbol{F}_{\\text{mono}} = G \\frac{M m_0}{\\left\\lvert\\boldsymbol{R}_{\\text{cm}} - \\boldsymbol{r}_0\\right\\rvert^3} (\\boldsymbol{R}_{\\text{cm}} - \\boldsymbol{r}_0) = (1) \\frac{(2)m_0}{\\left\\lvert\\boldsymbol{R}_{\\text{cm}}\\right\\rvert^3} \\boldsymbol{R}_{\\text{cm}}\n$$\n$\\boldsymbol{R}_{\\text{cm}}$ 的模为 $\\left\\lvert\\boldsymbol{R}_{\\text{cm}}\\right\\rvert = \\sqrt{10^2+0^2+0^2} = 10$。\n$$\n\\boldsymbol{F}_{\\text{mono}} = \\frac{2m_0}{10^3} (10,0,0) = \\frac{20m_0}{1000} (1,0,0) = \\frac{m_0}{50} (1,0,0) = \\left(\\frac{m_0}{50}, 0, 0\\right)\n$$\n\n**3. 相对误差**\n\n相对误差 $\\varepsilon$ 定义为 $\\varepsilon \\equiv \\frac{\\left\\lvert \\boldsymbol{F}_{\\text{exact}}-\\boldsymbol{F}_{\\text{mono}}\\right\\rvert}{\\left\\lvert \\boldsymbol{F}_{\\text{exact}}\\right\\rvert}$。\n\n首先，我们求出差矢量：\n$$\n\\boldsymbol{F}_{\\text{exact}} - \\boldsymbol{F}_{\\text{mono}} = \\left(\\frac{20m_0}{101\\sqrt{101}} - \\frac{m_0}{50}\\right) (1,0,0) = m_0 \\left(\\frac{20}{101\\sqrt{101}} - \\frac{1}{50}\\right) (1,0,0)\n$$\n该矢量的模为：\n$$\n\\left\\lvert \\boldsymbol{F}_{\\text{exact}}-\\boldsymbol{F}_{\\text{mono}}\\right\\rvert = \\left\\lvert m_0 \\left(\\frac{20}{101\\sqrt{101}} - \\frac{1}{50}\\right) \\right\\rvert = m_0 \\left\\lvert \\frac{20 \\cdot 50 - 101\\sqrt{101}}{50 \\cdot 101\\sqrt{101}} \\right\\rvert\n$$\n我们注意到 $101\\sqrt{101} = \\sqrt{101^3} = \\sqrt{1030301} \\approx 1015.04$，而 $20 \\cdot 50 = 1000$。因此，绝对值内的项是负的。\n$$\n\\left\\lvert \\boldsymbol{F}_{\\text{exact}}-\\boldsymbol{F}_{\\text{mono}}\\right\\rvert = m_0 \\left(\\frac{1}{50} - \\frac{20}{101\\sqrt{101}}\\right)\n$$\n精确力的模为：\n$$\n\\left\\lvert \\boldsymbol{F}_{\\text{exact}}\\right\\rvert = \\left\\lvert \\frac{20m_0}{101\\sqrt{101}} (1,0,0) \\right\\rvert = \\frac{20m_0}{101\\sqrt{101}}\n$$\n现在我们计算比率。因子 $m_0$ 被消掉了。\n$$\n\\varepsilon = \\frac{m_0 \\left(\\frac{1}{50} - \\frac{20}{101\\sqrt{101}}\\right)}{\\frac{20m_0}{101\\sqrt{101}}} = \\frac{\\frac{1}{50}}{\\frac{20}{101\\sqrt{101}}} - 1 = \\frac{101\\sqrt{101}}{50 \\cdot 20} - 1 = \\frac{101\\sqrt{101}}{1000} - 1\n$$\n我们现在计算数值：\n$$\n\\varepsilon = \\frac{101\\sqrt{101}}{1000} - 1 \\approx \\frac{101 \\times 10.0498756}{1000} - 1 \\approx \\frac{1015.0374377}{1000} - 1 = 1.0150374377 - 1 = 0.0150374377\n$$\n四舍五入到四位有效数字，我们得到 $\\varepsilon \\approx 0.01504$。\n\n为了解释这个结果，我们计算张角 $\\theta=s/d$。源粒子位于 $(10,1,0)$ 和 $(10,-1,0)$。包含它们的最小轴对齐盒子的尺寸为 $\\Delta x=10-10=0$，$\\Delta y=1-(-1)=2$，$\\Delta z=0-0=0$。单元尺寸 $s$ 是最小边界正方形的边长，即这些尺寸的最大值：$s = \\max(0,2,0) = 2$。从原点到质心的距离是 $d = |\\boldsymbol{R}_{\\text{cm}}| = 10$。\n张角为 $\\theta = s/d = 2/10 = 0.2$。计算出的 $\\varepsilon \\approx 1.5\\%$ 是对此特定几何构型应用单极矩近似时产生的相对力误差，该构型对应的张角为 $\\theta=0.2$。对于 Barnes-Hut 张角判据的常见选择（例如 $\\theta_{\\text{crit}}  0.5$），这是一个典型的精度水平。\n最终要求的答案是 $\\varepsilon$ 的数值。",
            "answer": "$$\n\\boxed{0.01504}\n$$"
        },
        {
            "introduction": "在理解了单极子近似的概念后，本练习将模拟 Barnes-Hut 算法的心脏——树遍历（tree walk）过程。给定一个预先定义的小型八叉树和一个目标粒子，你将手动应用张角判据来决定是使用节点的单极子近似，还是需要深入树的下一层以获得更精确的计算。这个练习将复杂的递归逻辑具体化，使抽象的力计算过程变得清晰可循。",
            "id": "3501671",
            "problem": "在一个以无量纲代码单位演化的无碰撞引力系统中，考虑使用 Barnes–Hut (BH) 树近似法计算一个目标测试粒子上的引力加速度。引力常数为 $G=1$。计算域是一个边长为 $8$ 的立方体，每个维度的坐标范围为 $[0,8]$。根节点（单元）的几何中心位于 $(4,4,4)$，边长为 $w_0=8$，并被细分为 $8$ 个边长为 $4$ 的八分象限，其几何中心分别位于通常的 $(2,2,2)$、$(6,2,2)$、$(2,6,2)$、$(6,6,2)$、$(2,2,6)$、$(6,2,6)$、$(2,6,6)$、$(6,6,6)$。八叉树是通过递归地细分任何被占据的节点来构建的，直到每个叶节点最多包含 $1$ 个粒子。\n\n该 $N$ 体系统包含以下粒子，其位置为 $\\mathbf{r}_i$，质量为 $m_i$：\n- 一个粒子位于 $(7,1,1)$，质量 $m=2$，在以 $(6,2,2)$ 为中心的八分象限内。\n- 一个粒子位于 $(1,7,1)$，质量 $m=3$，在以 $(2,6,2)$ 为中心的八分象限内。\n- 一个粒子位于 $(1,1,7)$，质量 $m=4$，在以 $(2,2,6)$ 为中心的八分象限内。\n- 三个粒子在以 $(6,6,6)$ 为中心、边长为 $4$ 的八分象限内形成一个紧凑的群组，它们分别位于 $(5.5,5.5,5.5)$（质量 $m=1$）、$(6.5,6.0,6.0)$（质量 $m=1.5$）和 $(6.0,6.5,6.0)$（质量 $m=2$）。这个八分象限被进一步细分，直到这三个粒子每个都单独存在于一个叶节点中。\n\n一个目标测试粒子（不包括在上述六个粒子中）位于 $\\mathbf{r}_{\\mathrm{t}}=(1,1,1)$。使用标准的 Barnes–Hut 张角判据，如果一个边长为 $w$、质心位置为 $\\mathbf{R}_{\\mathrm{com}}$ 的内部节点满足\n$$\n\\frac{w}{|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{R}_{\\mathrm{com}}|} \\le \\theta,\n$$\n张角 $\\theta=0.5$，则接受该节点。如果一个内部节点不被接受，则下降到其子节点。如果到达一个不包含目标的叶节点，则计算其粒子的直接贡献。对于任何被接受的内部节点，将其贡献近似为一个位于其质心的单极子，其总质量等于其组成粒子的质量之和。忽略任何自相互作用；不使用引力软化。\n\n从牛顿引力定律和上述树遍历规则出发，遍历树以计算目标上的总引力加速度，方法是将被接受的节点单极子贡献和直接的叶节点相互作用相加。使用 $G=1$，并将最终的加速度矢量表示为代码单位下的行矩阵 $\\begin{pmatrix}a_x  a_y  a_z\\end{pmatrix}$。将最终数值答案四舍五入到四位有效数字。不涉及角度。",
            "solution": "题目要求使用 Barnes-Hut (BH) 树近似法计算目标测试粒子上的引力加速度。我将首先验证问题陈述，如果有效，则进行完整解答。\n\n### 第 1 步：提取已知条件\n- **引力常数：** $G=1$。\n- **计算域：** 边长为 $L=8$ 的立方体，每个维度的坐标范围在 $[0,8]$ 内。\n- **根节点：** 几何中心位于 $(4,4,4)$，边长 $w_0=8$。\n- **八叉树构建：** 递归细分被占据的节点，直到每个叶节点最多包含 $1$ 个粒子。\n- **粒子数据：**\n  - 粒子 1：$\\mathbf{r}_1=(7,1,1)$，$m_1=2$。\n  - 粒子 2：$\\mathbf{r}_2=(1,7,1)$，$m_2=3$。\n  - 粒子 3：$\\mathbf{r}_3=(1,1,7)$，$m_3=4$。\n  - 粒子 4：$\\mathbf{r}_4=(5.5,5.5,5.5)$，$m_4=1$。\n  - 粒子 5：$\\mathbf{r}_5=(6.5,6.0,6.0)$，$m_5=1.5$。\n  - 粒子 6：$\\mathbf{r}_6=(6.0,6.5,6.0)$，$m_6=2$。\n- **目标粒子：** 位置 $\\mathbf{r}_{\\mathrm{t}}=(1,1,1)$。\n- **BH 张角判据：** 如果一个边长为 $w$、质心为 $\\mathbf{R}_{\\mathrm{com}}$ 的内部节点满足 $\\frac{w}{|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{R}_{\\mathrm{com}}|} \\le \\theta$，则接受该节点，其中张角 $\\theta=0.5$。\n- **相互作用规则：**\n  - 如果一个节点被接受，其贡献等同于一个位于其质心 $\\mathbf{R}_{\\mathrm{com}}$、总质量为 $M$ 的单极子。\n  - 如果一个内部节点不被接受，则下降到其子节点。\n  - 如果到达一个叶节点，计算其粒子的直接贡献。\n- **物理：** 不使用引力软化。\n- **输出要求：** 将最终加速度矢量表示为 $\\begin{pmatrix}a_x  a_y  a_z\\end{pmatrix}$，各分量四舍五入至四位有效数字。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题在科学上基于牛顿力学和计算物理学，特别是用于 N 体模拟的成熟的 Barnes-Hut 算法。其设定通过精确的数值和清晰、明确的规则进行了客观描述。所有必要的数据（粒子质量和位置、域几何形状、BH 参数 $\\theta$）均已提供。该问题是自洽、一致且适定的，通过确定性地应用给定规则，可以得到一个唯一且可验证的解。没有矛盾、事实错误或不可行的条件。\n\n### 第 3 步：结论与行动\n问题被认为是有效的。将推导完整解。\n\n位于位置 $\\mathbf{R}$、质量为 $M$ 的源对位于 $\\mathbf{r}_{\\mathrm{t}}$ 的目标粒子施加的引力加速度 $\\mathbf{a}$ 遵循牛顿引力定律。当 $G=1$ 时，其表达式为：\n$$\n\\mathbf{a} = \\frac{M (\\mathbf{R} - \\mathbf{r}_{\\mathrm{t}})}{|\\mathbf{R} - \\mathbf{r}_{\\mathrm{t}}|^3}\n$$\n总加速度是由 BH 树遍历确定的所有节点贡献的矢量和。目标粒子位于 $\\mathbf{r}_{\\mathrm{t}}=(1,1,1)$。\n\n遍历从八叉树的根节点开始。\n\n**根节点分析：**\n根节点包含整个域，边长为 $w_0=8$。它包含所有 $N=6$ 个粒子。我们必须首先确定此节点是否可以近似为一个单极子。\n系统总质量：\n$M_{\\mathrm{root}} = \\sum_{i=1}^{6} m_i = 2+3+4+1+1.5+2 = 13.5$。\n质心 $\\mathbf{R}_{\\mathrm{root}}$ 为：\n$\\mathbf{R}_{\\mathrm{root}} = \\frac{1}{M_{\\mathrm{root}}} \\sum_{i=1}^{6} m_i \\mathbf{r}_i$\n$\\sum m_i \\mathbf{r}_i = 2(7,1,1) + 3(1,7,1) + 4(1,1,7) + 1(5.5,5.5,5.5) + 1.5(6.5,6,6) + 2(6,6.5,6)$\n$= (14,2,2) + (3,21,3) + (4,4,28) + (5.5,5.5,5.5) + (9.75,9,9) + (12,13,12)$\n$= (48.25, 54.5, 59.5)$\n$\\mathbf{R}_{\\mathrm{root}} = \\frac{1}{13.5}(48.25, 54.5, 59.5) \\approx (3.574, 4.037, 4.407)$。\n从目标到根节点质心的距离是：\n$|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{R}_{\\mathrm{root}}| = |(1,1,1) - (3.574, 4.037, 4.407)| = |(-2.574, -3.037, -3.407)|$\n$= \\sqrt{(-2.574)^2 + (-3.037)^2 + (-3.407)^2} \\approx \\sqrt{6.626 + 9.223 + 11.608} = \\sqrt{27.457} \\approx 5.240$。\n应用张角判据：\n$\\frac{w_0}{|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{R}_{\\mathrm{root}}|} = \\frac{8}{5.240} \\approx 1.527$。\n由于 $1.527  \\theta=0.5$，根节点不被接受。我们必须下降到其子节点，即边长为 $w=4$ 的 $8$ 个八分象限。我们只考虑四个被占据的八分象限。\n\n**根节点的子节点（$w=4$ 的八分象限）：**\n\n1.  **包含 P1 的节点：** 此节点对应于八分象限 $[4,8]\\times[0,4]\\times[0,4]$，仅包含位于 $\\mathbf{r}_1=(7,1,1)$、质量为 $m_1=2$ 的粒子 P1。该节点的质心为 $\\mathbf{R}_{\\mathrm{com}}=\\mathbf{r}_1$，总质量为 $M=m_1$。\n    距离为 $|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{r}_1| = \\sqrt{(1-7)^2+(1-1)^2+(1-1)^2} = \\sqrt{(-6)^2} = 6$。\n    判据检查：$\\frac{w}{|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{r}_1|} = \\frac{4}{6} \\approx 0.667  0.5$。此节点不被接受。我们必须打开它。\n    此节点的子节点是一个边长为 $w'=2$ 的更小单元，仅包含 P1。\n    子节点的判据检查：$\\frac{w'}{|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{r}_1|} = \\frac{2}{6} \\approx 0.333 \\le 0.5$。此节点被接受。其贡献是位于 $\\mathbf{r}_1$、质量为 $m_1$ 的单极子，即直接相互作用。\n    $\\mathbf{a}_1 = \\frac{m_1(\\mathbf{r}_1-\\mathbf{r}_{\\mathrm{t}})}{|\\mathbf{r}_1-\\mathbf{r}_{\\mathrm{t}}|^3} = \\frac{2((7,1,1)-(1,1,1))}{6^3} = \\frac{2(6,0,0)}{216} = (\\frac{12}{216}, 0, 0) = (\\frac{1}{18}, 0, 0)$。\n\n2.  **包含 P2 的节点：** 此节点对应于八分象限 $[0,4]\\times[4,8]\\times[0,4]$，仅包含位于 $\\mathbf{r}_2=(1,7,1)$、质量为 $m_2=3$ 的粒子 P2。质心为 $\\mathbf{r}_2$。\n    距离为 $|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{r}_2| = \\sqrt{(1-1)^2+(1-7)^2+(1-1)^2} = \\sqrt{(-6)^2} = 6$。\n    判据检查：$\\frac{w}{|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{r}_2|} = \\frac{4}{6}  0.5$。不接受。下降到边长为 $w'=2$ 的子节点。\n    子节点的判据检查：$\\frac{w'}{|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{r}_2|} = \\frac{2}{6} \\le 0.5$。接受。\n    $\\mathbf{a}_2 = \\frac{m_2(\\mathbf{r}_2-\\mathbf{r}_{\\mathrm{t}})}{|\\mathbf{r}_2-\\mathbf{r}_{\\mathrm{t}}|^3} = \\frac{3((1,7,1)-(1,1,1))}{6^3} = \\frac{3(0,6,0)}{216} = (0, \\frac{18}{216}, 0) = (0, \\frac{1}{12}, 0)$。\n\n3.  **包含 P3 的节点：** 此节点对应于八分象限 $[0,4]\\times[0,4]\\times[4,8]$，仅包含位于 $\\mathbf{r}_3=(1,1,7)$、质量为 $m_3=4$ 的粒子 P3。质心为 $\\mathbf{r}_3$。\n    距离为 $|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{r}_3| = \\sqrt{(1-1)^2+(1-1)^2+(1-7)^2} = \\sqrt{(-6)^2} = 6$。\n    判据检查：$\\frac{w}{|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{r}_3|} = \\frac{4}{6}  0.5$。不接受。下降到边长为 $w'=2$ 的子节点。\n    子节点的判据检查：$\\frac{w'}{|\\mathbf{r}_{\\mathrm{t}}-\\mathbf{r}_3|} = \\frac{2}{6} \\le 0.5$。接受。\n    $\\mathbf{a}_3 = \\frac{m_3(\\mathbf{r}_3-\\mathbf{r}_{\\mathrm{t}})}{|\\mathbf{r}_3-\\mathbf{r}_{\\mathrm{t}}|^3} = \\frac{4((1,1,7)-(1,1,1))}{6^3} = \\frac{4(0,0,6)}{216} = (0, 0, \\frac{24}{216}) = (0, 0, \\frac{1}{9})$。\n\n4.  **包含群组（P4, P5, P6）的节点：** 此内部节点对应于八分象限 $[4,8]\\times[4,8]\\times[4,8]$，边长为 $w=4$。它包含三个粒子。\n    总质量：$M_{\\mathrm{grp}} = m_4+m_5+m_6 = 1+1.5+2 = 4.5$。\n    质心 $\\mathbf{R}_{\\mathrm{grp}} = \\frac{1}{M_{\\mathrm{grp}}}(m_4\\mathbf{r}_4+m_5\\mathbf{r}_5+m_6\\mathbf{r}_6)$。\n    $m_4\\mathbf{r}_4+m_5\\mathbf{r}_5+m_6\\mathbf{r}_6 = 1(5.5,5.5,5.5) + 1.5(6.5,6.0,6.0) + 2(6.0,6.5,6.0)$\n    $= (5.5,5.5,5.5) + (9.75,9.0,9.0) + (12.0,13.0,12.0) = (27.25, 27.5, 26.5)$。\n    $\\mathbf{R}_{\\mathrm{grp}} = \\frac{1}{4.5}(27.25, 27.5, 26.5) = (\\frac{109}{18}, \\frac{55}{9}, \\frac{53}{9}) \\approx (6.0556, 6.1111, 5.8889)$。\n    位移矢量和距离为：\n    $\\mathbf{d}_{\\mathrm{grp}} = \\mathbf{R}_{\\mathrm{grp}} - \\mathbf{r}_{\\mathrm{t}} = (\\frac{109}{18}-1, \\frac{55}{9}-1, \\frac{53}{9}-1) = (\\frac{91}{18}, \\frac{46}{9}, \\frac{44}{9}) \\approx (5.0556, 5.1111, 4.8889)$。\n    $|\\mathbf{d}_{\\mathrm{grp}}| = \\sqrt{(\\frac{91}{18})^2 + (\\frac{46}{9})^2 + (\\frac{44}{9})^2} = \\sqrt{25.5586 + 26.1235 + 23.9012} \\approx \\sqrt{75.5833} \\approx 8.6939$。\n    判据检查：$\\frac{w}{|\\mathbf{d}_{\\mathrm{grp}}|} = \\frac{4}{8.6939} \\approx 0.4601 \\le 0.5$。\n    判据满足。此节点被接受并被视为一个单极子。\n    $\\mathbf{a}_{\\mathrm{grp}} = \\frac{M_{\\mathrm{grp}}\\mathbf{d}_{\\mathrm{grp}}}{|\\mathbf{d}_{\\mathrm{grp}}|^3} = \\frac{4.5}{(8.6939)^3}(5.0556, 5.1111, 4.8889)$。\n    $|\\mathbf{d}_{\\mathrm{grp}}|^3 \\approx 657.07$。\n    $\\mathbf{a}_{\\mathrm{grp}} \\approx \\frac{4.5}{657.07}(5.0556, 5.1111, 4.8889) \\approx 0.0068485 (5.0556, 5.1111, 4.8889)$。\n    $\\mathbf{a}_{\\mathrm{grp}} \\approx (0.034621, 0.034999, 0.033480)$。\n\n**总加速度：**\n总加速度是各个贡献的总和：\n$\\mathbf{a}_{\\mathrm{total}} = \\mathbf{a}_1 + \\mathbf{a}_2 + \\mathbf{a}_3 + \\mathbf{a}_{\\mathrm{grp}}$。\n$\\mathbf{a}_1 = (\\frac{1}{18}, 0, 0) \\approx (0.055556, 0, 0)$。\n$\\mathbf{a}_2 = (0, \\frac{1}{12}, 0) \\approx (0, 0.083333, 0)$。\n$\\mathbf{a}_3 = (0, 0, \\frac{1}{9}) \\approx (0, 0, 0.111111)$。\n将各分量相加：\n$a_x = \\frac{1}{18} + 0.034621 \\approx 0.055556 + 0.034621 = 0.090177$。\n$a_y = \\frac{1}{12} + 0.034999 \\approx 0.083333 + 0.034999 = 0.118332$。\n$a_z = \\frac{1}{9} + 0.033480 \\approx 0.111111 + 0.033480 = 0.144591$。\n总加速度矢量约为 $(0.090177, 0.118332, 0.144591)$。\n\n将每个分量四舍五入到四位有效数字：\n$a_x \\approx 0.09018$。\n$a_y \\approx 0.1183$。\n$a_z \\approx 0.1446$。\n最终结果按要求以行矩阵形式呈现。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.09018  0.1183  0.1446 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "树算法的理论加速优势，只有在尊重现代计算机体系结构的精巧实现下才能完全发挥。本练习将探讨一个关键的性能优化技术：使用空间填充曲线来增强数据局部性。通过实现莫顿编码（Morton coding）方案，你将学习如何将三维粒子数据映射到能保持空间邻近性的一维数组中，这是实现高效树构建和矢量化力计算的关键一步。",
            "id": "3501689",
            "problem": "考虑 $N$ 个质点，其位置为 $\\mathbf{x}_i \\in \\mathbb{R}^3$，$i \\in \\{0,1,\\dots,N-1\\}$，这些质点旨在用于一个遵循 Barnes–Hut 范式的引力树码 (gravitational tree code)。通过对叶节点施加一种能保持空间局部性的一维排序，可以加速八叉树 (octree) 的构建。在数值宇宙学中，一个常见的选择是由 64 位莫顿码 (Morton codes) 引导的 Z 序 (Z-ordering)。该方法通过交错其坐标的定点整数表示的比特位，将每个三维点映射到一个唯一的整数键。从牛顿引力定律的定义以及作为 Barnes–Hut 基础的分层多极点近似出发，推导为何需要对空间中的点进行保持局部性的一维排序，并说明这是对连续叶节点块进行高效遍历和矢量化计算的先决条件。\n\n您必须设计并实现一个完整的程序，对每个指定的测试用例，以科学上合理且数值上一致的方式执行以下步骤：\n\n1. 定义点集 $\\{\\mathbf{x}_i\\}$ 的包围立方体，方法是令 $\\mathbf{m} = (\\min_i x_{i,0}, \\min_i x_{i,1}, \\min_i x_{i,2})$，$\\mathbf{M} = (\\max_i x_{i,0}, \\max_i x_{i,1}, \\max_i x_{i,2})$，以及 $L = \\max(M_0 - m_0, M_1 - m_1, M_2 - m_2)$。该立方体为 $[\\mathbf{m}, \\mathbf{m} + L \\mathbf{1}]$，其中 $\\mathbf{1}$ 是全一向量。通过 $u_{i,k} = \\dfrac{x_{i,k} - m_k}{L}$（对于 $k \\in \\{0,1,2\\}$）将每个位置归一化到单位立方体，并约定，等于 $1$ 的值将被替换为双精度浮点数中严格小于 $1$ 的最大可表示数，以避免在定点量化中发生溢出。\n\n2. 通过 $q_{i,k} = \\left\\lfloor u_{i,k} \\cdot 2^{21} \\right\\rfloor$ 将每个归一化坐标量化为一个 21 位无符号整数，使得 $q_{i,k} \\in \\{0,1,\\dots,2^{21}-1\\}$。交错 $(q_{i,0},q_{i,1},q_{i,2})$ 的比特位，形成一个 64 位莫顿码 $c_i \\in \\{0,1,\\dots,2^{64}-1\\}$，其中 $c_i$ 的最低有效位由 $q_{i,0}$、$q_{i,1}$ 和 $q_{i,2}$ 的最低有效位按顺序占据，后续比特平面依此类推。对于 $c_i$ 中的相同值使用稳定排序（对于相等的莫顿码，保留其原始索引顺序）。\n\n3. 按 $c_i$ 升序对粒子进行排序，以定义八叉树的叶节点顺序。报告一个置换 $\\pi$，使得 $c_{\\pi(0)} \\le c_{\\pi(1)} \\le \\dots \\le c_{\\pi(N-1)}$。\n\n4. 为了估计在连续叶节点上操作的矢量化内核的预期收益，计算比率\n$$\nR = \\frac{\\dfrac{1}{N-1}\\sum_{j=0}^{N-2} \\lVert \\mathbf{x}_{\\pi(j+1)} - \\mathbf{x}_{\\pi(j)} \\rVert_2}{\\dfrac{1}{N-1}\\sum_{j=0}^{N-2} \\lVert \\mathbf{x}_{j+1} - \\mathbf{x}_{j} \\rVert_2},\n$$\n该比率是无量纲的。分子衡量了在莫顿排序后的顺序中，连续粒子间的平均空间分离度；分母衡量了在原始输入顺序中，连续粒子间的平均分离度。一个更小的 $R$ 值表示排序后的顺序具有更紧密的空间局部性，因此，对连续内存段进行矢量化处理的预期效率更高。\n\n对于每个测试用例，程序必须产生三个输出：排序后的完整原始索引列表 $\\left[\\pi(0),\\pi(1),\\dots,\\pi(N-1)\\right]$；前 8 个排序后的莫顿码 $\\left[c_{\\pi(0)},c_{\\pi(1)},\\dots,\\pi(N-1)\\right]$（如果 $N8$ 则更少）；以及浮点数值 $R$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个形式为 $\\left[ \\text{排序后的索引}, \\text{前8个莫顿码}, R \\right]$ 的列表。所有浮点量都必须打印为原始十进制数。由于 $R$ 是无量纲的，而莫顿码是整数，因此不需要物理单位。\n\n测试套件：\n- 测试用例 A（一般情况）：$N=16$，位置\n$\\left[\n(0.1,0.1,0.1),(0.9,0.1,0.1),(0.1,0.9,0.1),(0.9,0.9,0.1),\n(0.1,0.1,0.9),(0.9,0.1,0.9),(0.1,0.9,0.9),(0.9,0.9,0.9),\n(0.5,0.5,0.5),(0.51,0.5,0.5),(0.5,0.51,0.5),(0.5,0.5,0.51),\n(0.2,0.8,0.2),(0.8,0.2,0.8),(0.2,0.2,0.8),(0.8,0.8,0.2)\n\\right]$。\n- 测试用例 B（聚类和混合尺度）：$N=16$，位置\n$\\left[\n(0.02,0.03,0.01),(0.05,0.02,0.04),(0.03,0.04,0.02),(0.04,0.06,0.03),\n(0.95,0.96,0.97),(0.97,0.95,0.96),(0.96,0.97,0.95),(0.98,0.99,0.97),\n(0.52,0.51,0.53),(0.49,0.5,0.48),(0.6,0.6,0.6),(0.4,0.4,0.4),\n(0.2,0.2,0.2),(0.8,0.8,0.8),(0.75,0.78,0.76),(0.25,0.28,0.26)\n\\right]$。\n- 测试用例 C（边界和近边界值）：$N=16$，位置\n$\\left[\n(0.0,0.0,0.0),(1.0,1.0,1.0),(10^{-12},0.0,0.0),(1.0-10^{-12},1.0-10^{-12},1.0-10^{-12}),\n(0.0,1.0,0.0),(1.0,0.0,1.0),(0.0,1.0,1.0),(1.0,0.0,0.0),\n(0.5,0.0,1.0),(0.0,0.5,1.0),(1.0,0.5,0.0),(0.5,1.0,0.0),\n(0.333333333,0.666666667,0.333333333),(0.666666667,0.333333333,0.666666667),\n(0.25,0.75,0.25),(0.75,0.25,0.75)\n\\right]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为\n$\\left[ \\left[ \\text{排序后的索引}_A, \\text{前8个莫顿码}_A, R_A \\right], \\left[ \\text{排序后的索引}_B, \\text{前8个莫顿码}_B, R_B \\right], \\left[ \\text{排序后的索引}_C, \\text{前8个莫顿码}_C, R_C \\right] \\right]$，\n其中下标表示测试用例。所有列表都必须使用字面上的方括号和逗号，所有整数和浮点数都必须以其规范的十进制形式打印。角度单位不适用于此问题，且不涉及百分比。",
            "solution": "该问题要求推导在 $N$ 体模拟中需要保持局部性排序的原因，并实现一种使用莫顿码生成这种排序的算法。\n\n### 理论推导：从牛顿引力到莫顿排序\n\n模拟 $N$ 个质点之间引力相互作用的根本挑战在于计算复杂性。一个质量为 $m_i$、位置为 $\\mathbf{x}_i \\in \\mathbb{R}^3$ 的质点所受到的来自所有其他质量为 $m_j$、位置为 $\\mathbf{x}_j$ 的质点的引力 $\\mathbf{F}_i$ 由牛顿万有引力定律给出：\n$$\n\\mathbf{F}_i = \\sum_{j=0, j \\neq i}^{N-1} G m_i m_j \\frac{\\mathbf{x}_j - \\mathbf{x}_i}{\\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert^3}\n$$\n其中 $G$ 是引力常数。对所有 $N$ 个粒子直接求和这些成对的力需要大约 $N^2$ 次计算，导致算法复杂度为 $O(N^2)$。对于现代数值宇宙学中使用的大量粒子（$N$ 通常为 $10^6$ 到 $10^{12}$），这是计算上难以处理的。\n\n为了克服这个问题，人们采用了像 Barnes–Hut 算法这样的近似方法。Barnes–Hut 算法通过使用树形数据结构（在三维中通常是八叉树）对模拟区域进行分层结构化，将复杂度降低到 $O(N \\log N)$。空间被递归地细分为八个立方体子单元（八分体），直到每个叶单元最多包含一个粒子。\n\nBarnes-Hut 算法的核心原理是通过将整个遥远的粒子簇视为位于其质心的单个质点来近似计算其引力。单个粒子 $p$ 的力计算涉及从根节点开始遍历八叉树。对于遇到的每个节点（单元）$C$，根据多极点接受准则 (multipole acceptance criterion, MAC) 作出决策。一种常见的形式是基于角度的准则：\n$$\n\\frac{s}{d}  \\theta\n$$\n其中 $s$ 是单元 $C$ 的边长， $d$ 是粒子 $p$ 到 $C$ 质心的距离，$\\theta$ 是用户定义的精度参数（通常 $0  \\theta  1$）。如果不等式成立，则该单元足够远，其对 $p$ 的力的贡献可以使用低阶多极点展开（最简单的情况下是单极点，即质心）来近似。如果不等式不成立，则该单元太近，无法进行精确近似，遍历将递归地进入其子单元。\n\n虽然这种分层方法显著减少了力的计算次数，但它引入了与内存访问模式相关的新的性能挑战。每个粒子的树遍历是数据依赖且不规则的。现代计算机架构通过矢量化操作（SIMD，单指令多数据）和利用数据局部性以最小化缓存未命中来实现峰值性能。粒子在内存中任意或随机的存储顺序意味着顺序处理的粒子在空间上不太可能接近。因此，当以矢量化方式处理一小组粒子时，它们各自的力计算很可能需要遍历八叉树中的不同路径。这种分歧阻碍了有效的矢量化，并导致缓存利用率低下，因为树数据结构的不同部分会为每个粒子加载到缓存中。\n\n正是在这里，保持粒子局部性的一维排序变得至关重要。其目标是重新排序粒子数组，使得在数组中相邻的粒子在三维空间中也很可能相邻。这个属性可以通过使用空间填充曲线来实现，空间填充曲线提供了从高维空间（$\\mathbb{R}^3$）到一维空间（$\\mathbb{R}$）的连续映射。生成 Z 序曲线 (Z-order curve) 的莫顿码是一种常见且有效的选择。它是通过交错粒子坐标的整数表示的比特位来构建的。\n\n根据粒子的莫顿码进行排序具有深远的性能影响：\n1.  **高效的树构建**：已排序的粒子列表可用于高效地构建八叉树，通常时间复杂度为线性时间，这是利用了同一八叉树节点内的粒子具有共同的高位比特前缀这一事实。\n2.  **增强的数据局部性**：当主粒子数组按莫顿码排序时，访问一个粒子的数据会将其空间上邻近的邻居预取到 CPU 缓存中，从而显著减少内存延迟。\n3.  **启用矢量化**：最关键的是，莫顿排序数组中的一个连续粒子块在空间上往往是局部的。在为该块计算力时，该块中的所有粒子很可能对相同的遥远树节点满足 MAC（$\\frac{s}{d}  \\theta$）。这允许进行矢量化树遍历，其中单个 SIMD 指令可以评估多个粒子相对于单个节点的 MAC，并且随后的力计算也可以被矢量化。这恢复了利用现代处理器全部能力的可能性。\n\n总而言之，推导过程如下：牛顿引力的 $O(N^2)$ 复杂度使得 $O(N \\log N)$ 的 Barnes–Hut 近似成为必要。Barnes–Hut 的性能受到树遍历期间不规则内存访问的限制。保持局部性的排序（例如莫顿排序）重构了主数据数组，使内存布局与空间邻近性对齐。这种对齐是实现高效缓存使用以及最关键的力计算矢量化的先决条件，而后者对于高性能 $N$ 体模拟至关重要。\n\n### 算法实现\n\n程序将实现指定的流程来计算莫顿码并衡量由此带来的数据局部性改善。\n\n1.  **归一化**：对于给定的 $N$ 个位置集合 $\\{\\mathbf{x}_i\\}$，我们首先计算最小包围立方体。它由角点 $\\mathbf{m} = (\\min_i x_{i,0}, \\min_i x_{i,1}, \\min_i x_{i,2})$ 和边长 $L = \\max_k (\\max_i x_{i,k} - \\min_i x_{i,k})$ 定义。然后通过变换 $u_{i,k} = (x_{i,k} - m_k) / L$ 将每个位置 $\\mathbf{x}_i$ 归一化到单位立方体 $[0, 1)^3$。任何恰好等于 $1.0$ 的归一化坐标值都将被替换为严格小于 $1.0$ 的最大双精度浮点数，以防止在随后的量化步骤中发生溢出。\n\n2.  **量化**：每个归一化坐标 $u_{i,k} \\in [0, 1)$ 使用公式 $q_{i,k} = \\lfloor u_{i,k} \\cdot 2^{21} \\rfloor$ 量化为 21 位无符号整数 $q_{i,k}$。这将连续坐标映射到从 $0$ 到 $2^{21}-1$ 的离散整数网格。\n\n3.  **莫顿码生成**：对于每个粒子 $i$，通过交错其三个 21 位量化坐标 $(q_{i,0}, q_{i,1}, q_{i,2})$ 的比特位来生成一个 64 位莫顿码 $c_i$。生成的莫顿码的比特模式将是 $...b_{2,k}b_{1,k}b_{0,k}...b_{2,0}b_{1,0}b_{0,0}$，其中 $b_{j,k}$ 是坐标 $q_{i,j}$ 的第 $k$ 位。此操作对 $k$ 从 $0$ 到 $20$ 执行。\n\n4.  **排序**：根据计算出的莫顿码 $c_i$ 的升序对原始粒子索引进行稳定排序。这产生了置换数组 $\\pi$，其中 $c_{\\pi(0)} \\le c_{\\pi(1)} \\le \\dots \\le c_{\\pi(N-1)}$。\n\n5.  **局部性比率计算**：为了量化空间局部性的改善，计算比率 $R$：\n    $$\n    R = \\frac{\\frac{1}{N-1}\\sum_{j=0}^{N-2} \\lVert \\mathbf{x}_{\\pi(j+1)} - \\mathbf{x}_{\\pi(j)} \\rVert_2}{\\frac{1}{N-1}\\sum_{j=0}^{N-2} \\lVert \\mathbf{x}_{j+1} - \\mathbf{x}_{j} \\rVert_2}\n    $$\n    该比率比较了莫顿排序顺序中连续粒子之间的平均欧几里得距离（分子）与原始输入顺序中的平均欧几里得距离（分母）。$R  1$ 的值表示莫顿排序成功地将粒子在内存中更紧密地组合在一起，这预示着计算性能有潜在的提升。程序将为每个提供的测试用例计算置换 $\\pi$、前 8 个排序后的莫顿码以及比率 $R$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    test_cases = [\n        # Test Case A (general case)\n        np.array([\n            (0.1, 0.1, 0.1), (0.9, 0.1, 0.1), (0.1, 0.9, 0.1), (0.9, 0.9, 0.1),\n            (0.1, 0.1, 0.9), (0.9, 0.1, 0.9), (0.1, 0.9, 0.9), (0.9, 0.9, 0.9),\n            (0.5, 0.5, 0.5), (0.51, 0.5, 0.5), (0.5, 0.51, 0.5), (0.5, 0.5, 0.51),\n            (0.2, 0.8, 0.2), (0.8, 0.2, 0.8), (0.2, 0.2, 0.8), (0.8, 0.8, 0.2)\n        ]),\n        # Test Case B (clustered and mixed scales)\n        np.array([\n            (0.02, 0.03, 0.01), (0.05, 0.02, 0.04), (0.03, 0.04, 0.02), (0.04, 0.06, 0.03),\n            (0.95, 0.96, 0.97), (0.97, 0.95, 0.96), (0.96, 0.97, 0.95), (0.98, 0.99, 0.97),\n            (0.52, 0.51, 0.53), (0.49, 0.5, 0.48), (0.6, 0.6, 0.6), (0.4, 0.4, 0.4),\n            (0.2, 0.2, 0.2), (0.8, 0.8, 0.8), (0.75, 0.78, 0.76), (0.25, 0.28, 0.26)\n        ]),\n        # Test Case C (boundary and near-boundary values)\n        np.array([\n            (0.0, 0.0, 0.0), (1.0, 1.0, 1.0), (1e-12, 0.0, 0.0), (1.0 - 1e-12, 1.0 - 1e-12, 1.0 - 1e-12),\n            (0.0, 1.0, 0.0), (1.0, 0.0, 1.0), (0.0, 1.0, 1.0), (1.0, 0.0, 0.0),\n            (0.5, 0.0, 1.0), (0.0, 0.5, 1.0), (1.0, 0.5, 0.0), (0.5, 1.0, 0.0),\n            (0.333333333, 0.666666667, 0.333333333), (0.666666667, 0.333333333, 0.666666667),\n            (0.25, 0.75, 0.25), (0.75, 0.25, 0.75)\n        ])\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_particles(case)\n        results.append(result)\n\n    # Format the final output string according to the problem specification.\n    # str(list) produces the required format '[item1, item2, ...]'\n    formatted_case_results = [f\"[{str(pi.tolist())}, {str(codes.tolist())}, {r}]\" for pi, codes, r in results]\n    final_output_str = f\"[{','.join(formatted_case_results)}]\"\n    print(final_output_str)\n\n\ndef get_morton_code(quantized_coords):\n    \"\"\"\n    Computes the 64-bit Morton code for a 3D point with 21-bit integer coordinates.\n    \"\"\"\n    q0, q1, q2 = quantized_coords\n    code = np.uint64(0)\n    for i in range(21):\n        # Extract i-th bit from each coordinate\n        b0 = (q0 >> i)  1\n        b1 = (q1 >> i)  1\n        b2 = (q2 >> i)  1\n        \n        # Interleave bits into the code. The bit pattern becomes ...q2_i q1_i q0_i...\n        code |= np.uint64(b0)  np.uint64(3 * i + 0)\n        code |= np.uint64(b1)  np.uint64(3 * i + 1)\n        code |= np.uint64(b2)  np.uint64(3 * i + 2)\n    return code\n\n\ndef process_particles(positions):\n    \"\"\"\n    Performs the full Morton ordering and analysis pipeline for a set of particle positions.\n    \"\"\"\n    N = len(positions)\n    \n    # 1. Define bounding cube and normalize positions\n    m = np.min(positions, axis=0)\n    M = np.max(positions, axis=0)\n    L = np.max(M - m)\n    if L == 0: L = 1.0 # Avoid division by zero if all points are identical\n    \n    normalized_pos = (positions - m) / L\n    \n    # Handle the edge case where a normalized coordinate is exactly 1.0\n    # Replace it with the largest representable double-precision number less than 1.0\n    val_at_1 = np.nextafter(1.0, 0.0)\n    normalized_pos[normalized_pos >= 1.0] = val_at_1\n\n    # 2. Quantize normalized coordinates to 21-bit unsigned integers\n    scale_factor = 2**21\n    quantized_pos = np.floor(normalized_pos * scale_factor).astype(np.uint64)\n    \n    # 3. Compute Morton codes for all particles\n    morton_codes = np.array([get_morton_code(q_pos) for q_pos in quantized_pos], dtype=np.uint64)\n    \n    # 4. Sort particles by Morton code to get the permutation pi\n    # Use a stable sort to handle ties deterministically, as required.\n    pi = np.argsort(morton_codes, kind='stable')\n    sorted_morton_codes = morton_codes[pi]\n    \n    # 5. Compute the locality ratio R\n    if N > 1:\n        sorted_positions = positions[pi]\n        \n        # Numerator: average successive distance in sorted order\n        diff_sorted = sorted_positions[1:] - sorted_positions[:-1]\n        sum_dist_sorted = np.sum(np.linalg.norm(diff_sorted, axis=1))\n        \n        # Denominator: average successive distance in original order\n        diff_original = positions[1:] - positions[:-1]\n        sum_dist_original = np.sum(np.linalg.norm(diff_original, axis=1))\n        \n        if sum_dist_original == 0:\n            # This can happen if all points are at the same location or N=2 and points are same.\n            R = 1.0 if sum_dist_sorted == 0 else np.inf\n        else:\n            R = sum_dist_sorted / sum_dist_original\n    else:\n        R = 1.0 # Or undefined, but 1.0 is a neutral choice.\n        \n    # Prepare outputs\n    sorted_indices = pi\n    first_8_codes = sorted_morton_codes[:8]\n    \n    return sorted_indices, first_8_codes, R\n\nsolve()\n```"
        }
    ]
}