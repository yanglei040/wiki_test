{
    "hands_on_practices": [
        {
            "introduction": "理论与实践相结合是掌握数值方法的关键。本章提供了一系列动手实践，旨在加深您对粒子-网格（PM）引力求解器核心概念的理解。第一个练习将引导您剖析PM求解器中最核心的组成部分：离散泊松求解器。通过从第一性原理推导连续介质和离散格林函数，您将量化用有限差分法近似拉普拉斯算子所引入的内在误差，并亲自揭示这种离散化方法如何导致依赖于方向的系统性偏差（即各向异性）()。",
            "id": "3481169",
            "problem": "您需要为粒子-网格（PM）引力求解器构建一个谱诊断工具，并将其实现为一个完整的、可运行的程序。目标是推导、实现并评估一个相对误差度量，用于比较不同傅里叶模式方向下，连续谱格林函数与离散PM格林函数的差异。请从牛顿引力和离散化的第一性原理出发，不要预先假设任何目标公式。\n\n从物理空间中的基本牛顿泊松方程开始，该方程给出了质量密度场与其势之间的关系：\n$$\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi G \\rho(\\mathbf{x}),$$\n其中 $\\phi(\\mathbf{x})$ 是引力势，$\\rho(\\mathbf{x})$ 是质量密度，$G$ 是引力常数。利用周期性边界条件下空间傅里叶变换的性质，得到连接 $\\phi(\\mathbf{k})$ 和 $\\rho(\\mathbf{k})$ 的连续傅里叶空间关系。然后，通过在间距为 $\\Delta x$ 的均匀立方网格上对拉普拉斯算子应用二阶中心差分近似，并施加周期性边界条件，来构建其离散对应部分，以获得拉普拉斯算子的离散傅里叶空间表示。利用这些，推导出一个立方域中傅里叶空间下的连续格林函数和离散粒子-网格（PM）格林函数。\n\n定义一个无量纲谱诊断量，用于测量傅里叶模式 $\\mathbf{k}$ 下离散PM格林函数与连续格林函数之间的相对误差：\n$$\\varepsilon(\\mathbf{k}) = \\frac{G_{\\mathrm{PM}}(\\mathbf{k})}{G(\\mathbf{k})} - 1,$$\n其中 $G(\\mathbf{k})$ 是连续格林函数，$G_{\\mathrm{PM}}(\\mathbf{k})$ 是离散PM格林函数。您的诊断工具应能揭示由离散算子引入的各向异性，通过量化那些具有相同连续谱模长但分量在各轴上分布不同的 $\\mathbf{k}$ 的误差。\n\n考虑一个边长为 $L$ 的立方周期性盒子，该盒子在均匀的 $N\\times N\\times N$ 网格上采样。网格间距为 $\\Delta x = L/N$。在周期性边界条件下，允许的傅里叶模式满足 $k_i = \\frac{2\\pi n_i}{L}$，其中整数 $n_i$ 在适当的范围内。引力常数 $G$ 应取其在国际单位制（SI）中的值，$G = 6.67430\\times 10^{-11}$ in $\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$，但您设计的诊断工具必须是无量纲且与单位无关的。此问题中的所有答案都必须以无量纲数的形式报告。\n\n实现一个程序，该程序：\n- 如上所述，从第一性原理推导必要的傅里叶空间算子，并构建诊断量 $\\varepsilon(\\mathbf{k})$。\n- 对下面定义的测试套件中的每个指定测试用例计算 $\\varepsilon(\\mathbf{k})$。\n- 生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。\n\n使用以下固定的域和分辨率：\n- 盒子长度 $L = 100$ 百万秒差距，其中 $1$ 百万秒差距 $= 3.085677581491367\\times 10^{22}$ 米；请在内部将 $L$ 转换为米。\n- 网格大小 $N = 128$。\n\n使用以下整数波指数三元组 $(n_x,n_y,n_z)$ 的测试套件，它们通过 $k_i = \\frac{2\\pi n_i}{L}$ 定义傅里叶模式分量：\n1. $(n_x,n_y,n_z) = (1,0,0)$，一个低频轴对齐模式。\n2. $(n_x,n_y,n_z) = (3,0,0)$，一个用于方向比较的轴对齐模式。\n3. $(n_x,n_y,n_z) = (2,2,1)$，一个与 $(3,0,0)$ 具有相同连续谱 $k^2$ 的混合方向模式。\n4. $(n_x,n_y,n_z) = (10,0,0)$，一个接近奈奎斯特范围的较高频率轴对齐模式。\n5. $(n_x,n_y,n_z) = (8,6,0)$，一个与 $(10,0,0)$ 具有相同连续谱 $k^2$ 的混合方向模式。\n6. $(n_x,n_y,n_z) = (64,0,0)$，一个奈奎斯特轴对齐模式。\n7. $(n_x,n_y,n_z) = (64,64,64)$，一个奈奎斯特体对角线模式。\n\n对于每个测试用例，将诊断量 $\\varepsilon(\\mathbf{k})$ 计算为一个浮点数。最终程序输出必须是单行，包含七个结果的列表，格式完全如下：\n$$[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4,\\varepsilon_5,\\varepsilon_6,\\varepsilon_7],$$\n无单位，并以无量纲十进制数表示。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$\\texttt{[result1,result2,result3]}$）。",
            "solution": "用户要求推导并实现一个谱诊断工具，用于测量粒子-网格（PM）引力求解器的误差。首先验证问题陈述，发现其在科学上是合理、适定且完整的。我们现在开始求解，从第一性原理推导必要的表达式。\n\n起点是牛顿泊松方程，它关联了引力势 $\\phi(\\mathbf{x})$ 与质量密度分布 $\\rho(\\mathbf{x})$：\n$$\n\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi G \\rho(\\mathbf{x})\n$$\n其中 $G$ 是引力常数。我们考虑一个边长为 $L$ 且具有周期性边界条件的立方域。在这样的域中，任何行为良好的函数都可以用傅里叶级数表示。设 $\\phi_{\\mathbf{k}}$ 和 $\\rho_{\\mathbf{k}}$ 分别是势场和密度场对应于波矢量 $\\mathbf{k}$ 的傅里叶级数系数。波矢量是离散的，由 $\\mathbf{k} = (k_x, k_y, k_z) = (\\frac{2\\pi n_x}{L}, \\frac{2\\pi n_y}{L}, \\frac{2\\pi n_z}{L})$ 给出，其中 $(n_x, n_y, n_z)$ 是整数索引。\n\n拉普拉斯算子 $\\nabla^2$ 在傅里叶空间中的作用等效于乘以 $-|\\mathbf{k}|^2 = -k^2$。将此应用于泊松方程，将实空间中的偏微分方程转换为傅里叶空间中针对每个模式 $\\mathbf{k}$ 的代数方程：\n$$\n-k^2 \\phi_{\\mathbf{k}} = 4\\pi G \\rho_{\\mathbf{k}}\n$$\n这个方程定义了连续谱极限下的关系。我们可以解出势的系数 $\\phi_{\\mathbf{k}}$：\n$$\n\\phi_{\\mathbf{k}} = \\left( -\\frac{4\\pi G}{k^2} \\right) \\rho_{\\mathbf{k}}\n$$\n括号中的项是傅里叶空间中的连续格林函数，我们将其表示为 $G(\\mathbf{k})$。它充当给定模式下密度和势之间的传递函数。\n$$\nG(\\mathbf{k}) = -\\frac{4\\pi G}{k^2} \\quad \\text{其中} \\quad k^2 = |\\mathbf{k}|^2 = k_x^2 + k_y^2 + k_z^2.\n$$\n\n接下来，我们考虑离散系统。该域在均匀的 $N \\times N \\times N$ 网格上采样，网格间距为 $\\Delta x = L/N$。连续的拉普拉斯算子 $\\nabla^2$ 使用二阶精确的有限差分格式进行近似。在由 $(i,j,l)$ 索引的网格点上，拉普拉斯算子的中心差分近似为：\n$$\n(\\nabla^2_{\\mathrm{PM}}\\phi)_{i,j,l} = \\frac{\\phi_{i+1,j,l} - 2\\phi_{i,j,l} + \\phi_{i-1,j,l}}{(\\Delta x)^2} + \\frac{\\phi_{i,j+1,l} - 2\\phi_{i,j,l} + \\phi_{i,j-1,l}}{(\\Delta x)^2} + \\frac{\\phi_{i,j,l+1} - 2\\phi_{i,j,l} + \\phi_{i,j,l-1}}{(\\Delta x)^2}\n$$\n为了找到该离散算子的傅里叶空间表示，我们考察它对傅里叶基函数 $e^{i\\mathbf{k} \\cdot \\mathbf{x}}$ 的作用，其中 $\\mathbf{x}_{i,j,l} = (i\\Delta x, j\\Delta x, l\\Delta x)$。离散拉普拉斯算子 $x$ 分量的作用是：\n$$\n\\frac{e^{ik_x(i+1)\\Delta x} - 2e^{ik_xi\\Delta x} + e^{ik_x(i-1)\\Delta x}}{(\\Delta x)^2} = \\frac{e^{ik_xi\\Delta x} (e^{ik_x\\Delta x} - 2 + e^{-ik_x\\Delta x})}{(\\Delta x)^2} = \\frac{e^{ik_xi\\Delta x} (2\\cos(k_x\\Delta x) - 2)}{(\\Delta x)^2}\n$$\n使用半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$，上式可简化为：\n$$\n- \\frac{4\\sin^2(k_x\\Delta x/2)}{(\\Delta x)^2} e^{ik_xi\\Delta x}\n$$\n将所有三个空间维度的贡献相加，离散拉普拉斯算子在傅里叶空间中充当一个乘法因子，我们将其表示为 $-k^2_{\\mathrm{eff}}(\\mathbf{k})$：\n$$\n-k^2_{\\mathrm{eff}}(\\mathbf{k}) = -\\frac{4}{(\\Delta x)^2} \\left[ \\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_z \\Delta x}{2}\\right) \\right]\n$$\n因此，傅里叶空间中的离散泊松方程为：\n$$\n-k^2_{\\mathrm{eff}}(\\mathbf{k}) \\phi_{\\mathbf{k}} = 4\\pi G \\rho_{\\mathbf{k}}\n$$\n这给出了势的离散粒子-网格（PM）格林函数：\n$$\nG_{\\mathrm{PM}}(\\mathbf{k}) = -\\frac{4\\pi G}{k^2_{\\mathrm{eff}}(\\mathbf{k})}\n$$\n诊断量 $\\varepsilon(\\mathbf{k})$ 测量离散格林函数与连续格林函数之间的相对误差：\n$$\n\\varepsilon(\\mathbf{k}) = \\frac{G_{\\mathrm{PM}}(\\mathbf{k})}{G(\\mathbf{k})} - 1 = \\frac{-4\\pi G / k^2_{\\mathrm{eff}}(\\mathbf{k})}{-4\\pi G / k^2} - 1 = \\frac{k^2}{k^2_{\\mathrm{eff}}(\\mathbf{k})} - 1\n$$\n请注意，因子 $4\\pi G$ 被抵消，使得该诊断量与引力常数的值和单位无关。\n\n为了实现这个公式，我们将 $k^2$ 和 $k^2_{\\mathrm{eff}}(\\mathbf{k})$ 用整数波指数 $(n_x, n_y, n_z)$ 和网格大小 $N$ 来表示。\n我们有 $k_i = \\frac{2\\pi n_i}{L}$ 和 $\\Delta x = L/N$。因此，正弦函数的参数变为 $k_i \\Delta x / 2 = (\\frac{2\\pi n_i}{L})(\\frac{L}{N}) / 2 = \\frac{\\pi n_i}{N}$。\n连续谱波数平方为：\n$$\nk^2 = \\left(\\frac{2\\pi}{L}\\right)^2 (n_x^2 + n_y^2 + n_z^2)\n$$\n有效离散波数平方为：\n$$\nk^2_{\\mathrm{eff}}(\\mathbf{k}) = \\frac{4}{(\\Delta x)^2} \\sum_{j \\in \\{x,y,z\\}} \\sin^2\\left(\\frac{\\pi n_j}{N}\\right) = \\frac{4}{(L/N)^2} \\sum_{j \\in \\{x,y,z\\}} \\sin^2\\left(\\frac{\\pi n_j}{N}\\right) = \\frac{4N^2}{L^2} \\sum_{j \\in \\{x,y,z\\}} \\sin^2\\left(\\frac{\\pi n_j}{N}\\right)\n$$\n将这些代入 $\\varepsilon(\\mathbf{k})$ 的表达式中：\n$$\n\\varepsilon(\\mathbf{k}) = \\frac{\\left(\\frac{2\\pi}{L}\\right)^2 (n_x^2 + n_y^2 + n_z^2)}{\\frac{4N^2}{L^2} \\sum_{j} \\sin^2\\left(\\frac{\\pi n_j}{N}\\right)} - 1 = \\frac{\\frac{4\\pi^2}{L^2}}{\\frac{4N^2}{L^2}} \\frac{n_x^2 + n_y^2 + n_z^2}{\\sum_{j} \\sin^2\\left(\\frac{\\pi n_j}{N}\\right)} - 1\n$$\n盒子大小 $L$ 被抵消，得到最终要实现的无量纲公式：\n$$\n\\varepsilon(n_x, n_y, n_z) = \\frac{\\pi^2}{N^2} \\frac{n_x^2 + n_y^2 + n_z^2}{\\sin^2\\left(\\frac{\\pi n_x}{N}\\right) + \\sin^2\\left(\\frac{\\pi n_y}{N}\\right) + \\sin^2\\left(\\frac{\\pi n_z}{N}\\right)} - 1\n$$\n该公式表明，相对误差仅取决于整数波指数 $(n_x, n_y, n_z)$ 和网格分辨率 $N$。误差是正的，因为对于 $x>0$，有 $\\sin(x) < x$，这意味着 $k^2_{\\mathrm{eff}}(\\mathbf{k}) < k^2$。这意味着离散算子系统性地低估了拉普拉斯算子的量值，从而导致计算出的引力偏弱。误差对 $\\mathbf{k}$ 方向的依赖性（即对 $n_x, n_y, n_z$ 之间数值分配的依赖）源于正弦函数的非线性特性，这导致了误差的各向异性。问题中对具有相同 $n_x^2 + n_y^2 + n_z^2$ 值但分量不同的模式进行比较，将突显这种各向异性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes a spectral diagnostic for a Particle-Mesh (PM) gravity solver.\n\n    The function calculates the relative error between the continuum and discrete\n    Green's functions in Fourier space for a set of specified wave modes.\n    \"\"\"\n\n    # Define physical constants and simulation parameters as specified in the problem.\n    # Note: L, G, and MPC_TO_M are provided for context and completeness of the\n    # physical setup, but the derived diagnostic epsilon is dimensionless and\n    # independent of these values, as shown in the derivation.\n    G_si = 6.67430e-11  # m^3 kg^-1 s^-2\n    MPC_TO_M = 3.085677581491367e22 # meters per megaparsec\n    L_mpc = 100.0  # Megaparsecs\n    L_m = L_mpc * MPC_TO_M # meters\n    N = 128  # Grid size (N x N x N)\n\n    # Test suite of integer wave-index triplets (nx, ny, nz)\n    test_cases = [\n        (1, 0, 0),    # Low-frequency axis-aligned mode\n        (3, 0, 0),    # Axis-aligned mode\n        (2, 2, 1),    # Mixed-orientation mode with same continuum k^2 as (3,0,0)\n        (10, 0, 0),   # Higher-frequency axis-aligned mode\n        (8, 6, 0),    # Mixed-orientation mode with same continuum k^2 as (10,0,0)\n        (64, 0, 0),   # Nyquist axis-aligned mode\n        (64, 64, 64)  # Nyquist body-diagonal mode\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        nx, ny, nz = case\n        \n        # The diagnostic epsilon(k) is given by the formula:\n        # epsilon = (k^2 / k_eff^2) - 1\n        # where k is the continuum wavenumber and k_eff is the effective\n        # wavenumber from the finite-difference operator.\n        #\n        # k^2 = (2*pi/L)^2 * (nx^2 + ny^2 + nz^2)\n        # k_eff^2 = (2*N/L)^2 * (sin(pi*nx/N)^2 + sin(pi*ny/N)^2 + sin(pi*nz/N)^2)\n        #\n        # The ratio k^2 / k_eff^2 simplifies to:\n        # (pi/N)^2 * (nx^2 + ny^2 + nz^2) / (sin(pi*nx/N)^2 + ...)\n        # This final form is independent of L and G.\n\n        # Numerator part related to continuum k^2\n        n_squared = float(nx**2 + ny**2 + nz**2)\n        \n        # Denominator part related to discrete k_eff^2\n        # Handle the k=0 case to avoid division by zero, although not in test suite.\n        if n_squared == 0:\n            # The k=0 mode (DC component) has an infinite Green's function\n            # and the error is undefined. We assign NaN or handle as per convention.\n            # Here, we can skip it, but the test cases avoid n=(0,0,0).\n            epsilon = np.nan\n        else:\n            sum_sin_squared = (\n                np.sin(np.pi * nx / N)**2 +\n                np.sin(np.pi * ny / N)**2 +\n                np.sin(np.pi * nz / N)**2\n            )\n            \n            # The factor (pi/N)^2 comes from the ratio of k^2 and k_eff^2 prefactors\n            factor = (np.pi / N)**2\n            \n            epsilon = factor * n_squared / sum_sin_squared - 1.0\n\n        results.append(epsilon)\n\n    # Final print statement in the exact required format.\n    # Example format: [result1,result2,result3]\n    # We use a high-precision format for the floating point numbers.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在上一个练习的基础上，我们现在将分析范围从孤立的求解器核心扩展到整个PM计算流程。实际的PM模拟不仅涉及求解泊松方程，还包括将粒子质量分配到网格上，以及将计算出的力插值回粒子位置。这个练习  要求您分析一个单一傅里叶模式在完整的PM管线（包括质量分配、泊松求解、梯度计算和力插值）下的响应。通过这个过程，您将理解不同的分配窗口函数（如“云在单元”CIC和“三角形云”TSC）如何与离散算子相结合，共同决定了最终计算出的力的振幅和相位，从而揭示了PM方法中信号处理的本质。",
            "id": "3481164",
            "problem": "要求您为一个周期性盒子中的单一傅里叶模式密度衬度实现一个完全自洽的一维粒子-网格（PM）引力求解器响应测试。其目标是，对于两种不同的粒子-网格插值核：云中单元（CIC）和三角形云（TSC），从第一性原理计算 PM 管线所产生的力场的期望振幅和相位。该测试是纯线性的、一维的，且所有量均为无量纲。\n\n基本设置：\n- 考虑一个长度为 $L$ 的周期性域，将其离散化为 $N$ 个大小为 $\\Delta = L/N$ 的等间距网格单元。\n- 输入密度衬度为单一模式\n$$\n\\delta(x) = A \\cos(k x),\n$$\n模式 $k = 2\\pi m / L$，其中模式指数 $m \\in \\{0,1,\\dots,N/2\\}$ 为整数，振幅 $A$ 无量纲。角度必须以弧度处理。\n\nPM 管线假设（所有步骤均为标准步骤，且必须用作您推导的基本基础）：\n1. 质量分配和力插值使用相同的对称粒子-网格插值核进行，其傅里叶空间窗口为 $W_p(k)$。对于一维空间，使用\n   - 云中单元 (CIC)：$W_{\\mathrm{CIC}}(k) = \\mathrm{sinc}\\!\\left(\\frac{k\\Delta}{2}\\right)^{2}$，\n   - 三角形云 (TSC)：$W_{\\mathrm{TSC}}(k) = \\mathrm{sinc}\\!\\left(\\frac{k\\Delta}{2}\\right)^{3}$，\n   其中 $\\mathrm{sinc}(x) \\equiv \\frac{\\sin x}{x}$，且按照惯例 $\\mathrm{sinc}(0)=1$。\n   进入往返过程（沉积到网格上，然后将力插值回粒子位置）的有效窗口是 $W_p(k)^2$。\n\n2. 网格上的引力势遵循带有标准二阶有限差分拉普拉斯算子的离散泊松方程。在傅里叶空间中，波数 $k$ 的离散拉普拉斯算子特征值为\n$$\n\\hat{\\nabla}^2(k) = -K^2(k), \\quad K^2(k) = \\left(\\frac{2}{\\Delta}\\right)^2 \\sin^2\\!\\left(\\frac{k\\Delta}{2}\\right).\n$$\n在单位制中，背景密度和引力常数被缩放，使得泊松方程为 $\\nabla^2 \\phi = \\delta$（无量纲）。\n\n3. 网格上的力由势通过中心差分梯度计算得出。在傅里叶空间中，离散梯度符号为\n$$\n\\widehat{\\partial_x}(k) = i\\,\\frac{\\sin(k\\Delta)}{\\Delta}.\n$$\n\n4. 从输入 $\\delta(x)$ 到粒子位置上的力的总 PM 响应是以下各项的复合：质量分配窗口、离散泊松求解器、离散梯度和力插值窗口。假设不执行分配窗口的反卷积。\n\n待计算的目标量：\n- 对于每个测试用例，当输入密度衬度为 $\\delta(x) = A \\cos(kx)$ 时，计算上述 PM 管线产生的期望力场响应 $F(x)$。\n- 对于每种插值核（CIC 和 TSC），报告标量振幅 $B$ 和相位 $\\varphi$，使得产生的力可以写为\n$$\nF(x) = B \\cos(kx + \\varphi).\n$$\n- 相位 $\\varphi$ 必须以弧度报告。对于振幅实际上为零的退化情况（例如，$k=0$ 或恰好在奈奎斯特波数处），将相位设置为 $0$。\n\n要求：\n- 使用上述管线和基本定义，推导期望振幅 $B$ 和相位 $\\varphi$ 作为 $A$、$k$、$N$、$L$ 以及插值核选择（CIC 或 TSC）的函数的解析表达式。您的程序必须实现这些推导出的表达式，以计算 $B$ 和 $\\varphi$ 的数值。\n- 所有量均为无量纲。角度必须以弧度为单位。\n\n测试套件：\n使用以下五个测试用例，每个用例由一个元组 $(N, L, A, m)$ 指定：\n1. $(64, 1.0, 0.05, 5)$\n2. $(64, 1.0, 0.001, 1)$\n3. $(64, 1.0, 0.08, 0)$\n4. $(64, 1.0, 0.05, 32)$\n5. $(64, 1.0, 0.05, 31)$\n\n输出规格：\n- 您的程序应生成单行输出，其中包含一个 Python 风格的列表，该列表包含五个子列表，每个子列表对应一个测试用例，顺序与上文相同。\n- 每个子列表必须按此顺序包含四个浮点数：$[B_{\\mathrm{CIC}}, \\varphi_{\\mathrm{CIC}}, B_{\\mathrm{TSC}}, \\varphi_{\\mathrm{TSC}}]$，其中振幅的单位与归一化所隐含的任意力单位相同，相位以弧度为单位。\n- 如果由于数值或精确原因，振幅实际上为零，则将相位设置为 $0$。\n- 最终输出必须是严格的单行形式\n\"[ [B_CIC,phi_CIC,B_TSC,phi_TSC], [ ... ], ... ]\"\n不含任何额外文本。\n\n您的任务：\n- 根据所述基本定义，推导在 PM 管线下的单模式输入的 $B$ 和 $\\varphi$ 的解析表达式，明确地考虑质量分配和力插值窗口、离散泊松算子以及离散梯度算子。\n- 在一个程序中实现推导出的表达式，该程序评估测试套件并以指定的格式打印结果。",
            "solution": "检查用户问题的有效性。提取所有给定条件，并根据指定标准对问题进行评估。\n\n### 步骤 1：提取给定条件\n-   **域和离散化**：一个长度为 $L$ 的一维周期性域，包含 $N$ 个大小为 $\\Delta = L/N$ 的网格单元。\n-   **输入密度衬度**：$\\delta(x) = A \\cos(k x)$，波数 $k = 2\\pi m / L$，其中模式指数 $m \\in \\{0,1,\\dots,N/2\\}$ 为整数。\n-   **PM 管线算子（傅里叶空间）**：\n    1.  **质量分配/力插值窗口**：$W_{\\mathrm{CIC}}(k) = \\mathrm{sinc}^2(\\frac{k\\Delta}{2})$ 和 $W_{\\mathrm{TSC}}(k) = \\mathrm{sinc}^3(\\frac{k\\Delta}{2})$，其中 $\\mathrm{sinc}(z) \\equiv (\\sin z)/z$。有效的往返窗口为 $W_p(k)^2$。\n    2.  **离散泊松方程**：$\\nabla^2 \\phi = \\delta$，其离散拉普拉斯算子由其傅里叶符号 $\\hat{\\nabla}^2(k) = -K^2(k)$ 定义，其中 $K^2(k) = \\left(\\frac{2}{\\Delta}\\right)^2 \\sin^2(\\frac{k\\Delta}{2})$。\n    3.  **离散梯度算子**：力由势通过中心差分计算，其傅里叶符号为 $\\widehat{\\partial_x}(k) = i\\,\\frac{\\sin(k\\Delta)}{\\Delta}$。\n-   **目标量**：对于每种核（CIC、TSC），确定所得力场的振幅 $B$ 和相位 $\\varphi$，表示为 $F(x) = B \\cos(kx + \\varphi)$。\n-   **特殊条件**：如果振幅 $B$ 为零，则相位 $\\varphi$ 必须设置为零。所有计算必须对角度使用弧度。\n-   **测试套件**：由 $(N, L, A, m)$ 定义的五个用例：$(64, 1.0, 0.05, 5)$、$(64, 1.0, 0.001, 1)$、$(64, 1.0, 0.08, 0)$、$(64, 1.0, 0.05, 32)$、$(64, 1.0, 0.05, 31)$。\n\n### 步骤 2：使用提取的给定条件进行验证\n-   **科学依据**：该问题基于计算宇宙学和等离子体物理学中使用的标准粒子-网格（PM）方法。指定的离散算子和窗口函数是标准的、正确的，并且在该领域被广泛使用。该设置在科学上是合理的。\n-   **适定性**：该问题在数学上是适定的。它提供了所有必要的函数、参数和明确的目标。预计每个案例的振幅和相位都有唯一解。\n-   **客观性**：问题以精确、客观和技术性的语言陈述，没有任何主观性或歧义。\n\n### 步骤 3：结论与行动\n该问题是适定的、有科学依据且内部一致。这是一个有效的形式化问题。将提供完整解决方案。\n\n### PM 响应函数的推导\n\n目标是确定输入密度衬度 $\\delta(x)$ 在通过 PM 管线的各个阶段后产生的力 $F(x)$。由于所有阶段都是线性操作，在傅里叶空间中工作最为有效。令 $\\mathcal{F}[f(x)] = \\hat{f}(k)$ 表示傅里叶变换。\n\n输入密度衬度为 $\\delta(x) = A \\cos(kx)$。使用欧拉公式，我们可以将其写为 $\\delta(x) = \\frac{A}{2} (e^{ikx} + e^{-ikx})$。$\\delta(x)$ 的傅里eyer变换仅在波数 $k' = k$ 和 $k' = -k$ 处有非零分量。PM 管线充当线性滤波器，将传递函数 $T(k')$ 应用于每个傅里叶模式。\n\n将输入密度衬度 $\\hat{\\delta}(k')$ 与粒子上的最终力 $\\hat{F}(k')$ 相关联的总传递函数 $T(k')$ 是管线每一步算子的复合。\n\n1.  **质量分配**：将连续粒子密度 $\\delta(x)$ 分配到网格上。在傅里叶空间中，这对应于将密度的傅里叶变换乘以分配窗口函数 $W_p(k')$。网格密度为 $\\hat{\\delta}_{\\text{grid}}(k') = W_p(k') \\hat{\\delta}(k')$。\n\n2.  **泊松求解**：网格上的势 $\\hat{\\phi}(k')$ 通过求解离散泊松方程 $\\hat{\\nabla}^2(k')\\hat{\\phi}(k')=\\hat{\\delta}_{\\text{grid}}(k')$ 得到。\n    $$\n    \\hat{\\phi}(k') = \\frac{\\hat{\\delta}_{\\text{grid}}(k')}{\\hat{\\nabla}^2(k')} = \\frac{W_p(k') \\hat{\\delta}(k')}{-K^2(k')}\n    $$\n\n3.  **梯度计算**：网格上的力 $F_{\\text{grid}}(x)$ 是势的负梯度，即 $F_{\\text{grid}}(x) = -\\partial_x \\phi(x)$。在傅里叶空间中，这表示为 $\\hat{F}_{\\text{grid}}(k') = - \\widehat{\\partial_x}(k') \\hat{\\phi}(k')$。\n    $$\n    \\hat{F}_{\\text{grid}}(k') = - \\left( i \\frac{\\sin(k'\\Delta)}{\\Delta} \\right) \\hat{\\phi}(k') = - \\left( i \\frac{\\sin(k'\\Delta)}{\\Delta} \\right) \\frac{W_p(k') \\hat{\\delta}(k')}{-K^2(k')} = i \\frac{\\sin(k'\\Delta)}{\\Delta K^2(k')} W_p(k') \\hat{\\delta}(k')\n    $$\n\n4.  **力插值**：将力从网格插值回粒子位置。这等效于乘以插值窗口 $W_p(k')$（与分配窗口相同）。\n    $$\n    \\hat{F}(k') = W_p(k') \\hat{F}_{\\text{grid}}(k') = i \\frac{W_p(k')^2 \\sin(k'\\Delta)}{\\Delta K^2(k')} \\hat{\\delta}(k')\n    $$\n\n总传递函数为 $T(k') = \\hat{F}(k')/\\hat{\\delta}(k')$。代入 $K^2(k')$ 的表达式：\n$$\nT(k') = i W_p(k')^2 \\frac{\\sin(k'\\Delta)}{\\Delta \\left(\\frac{2}{\\Delta}\\right)^2 \\sin^2(\\frac{k'\\Delta}{2})}\n$$\n使用恒等式 $\\sin(k'\\Delta) = 2\\sin(k'\\Delta/2)\\cos(k'\\Delta/2)$，我们简化表达式：\n$$\nT(k') = i W_p(k')^2 \\frac{2\\sin(k'\\Delta/2)\\cos(k'\\Delta/2)}{\\frac{4}{\\Delta}\\sin^2(\\frac{k'\\Delta}{2})} = i W_p(k')^2 \\frac{\\Delta}{2} \\cot\\left(\\frac{k'\\Delta}{2}\\right)\n$$\n这个传递函数 $T(k')$ 是纯虚数。余切函数是奇函数，窗口函数 $W_p(k')$ 是偶函数，所以 $T(k')$ 是一个奇函数：$T(-k') = -T(k')$。\n\n现在，我们将此传递函数应用于输入信号 $\\delta(x) = \\frac{A}{2} (e^{ikx} + e^{-ikx})$。产生的力 $F(x)$ 是傅里叶逆变换：\n$$\nF(x) = \\frac{A}{2} \\left[ T(k) e^{ikx} + T(-k) e^{-ikx} \\right] = \\frac{A}{2} \\left[ T(k) e^{ikx} - T(k) e^{-ikx} \\right]\n$$\n$$\nF(x) = \\frac{A}{2} T(k) (e^{ikx} - e^{-ikx}) = \\frac{A}{2} T(k) (2i\\sin(kx)) = i A T(k) \\sin(kx)\n$$\n代入 $T(k)$ 的表达式：\n$$\nF(x) = i A \\left[ i W_p(k)^2 \\frac{\\Delta}{2} \\cot\\left(\\frac{k\\Delta}{2}\\right) \\right] \\sin(kx) = -A W_p(k)^2 \\frac{\\Delta}{2} \\cot\\left(\\frac{k\\Delta}{2}\\right) \\sin(kx)\n$$\n我们需要将其表示为 $F(x) = B \\cos(kx + \\varphi)$ 的形式。让我们分析一下 $S(k) = W_p(k)^2 \\frac{\\Delta}{2} \\cot\\left(\\frac{k\\Delta}{2}\\right)$ 这一项。波数为 $k=2\\pi m/L$，单元尺寸为 $\\Delta=L/N$，所以余切函数的参数是 $k\\Delta/2 = \\pi m/N$。对于 $m \\in \\{1, \\dots, N/2-1\\}$，该参数在区间 $(0, \\pi/2)$ 内，其中余切函数为正。$W_p(k)^2$ 也为正。因此，对于这些模式，$S(k) > 0$。\n\n假设 $A>0$：\n$F(x) = -A S(k) \\sin(kx)$。由于 $A S(k) > 0$，我们可以使用恒等式 $-\\sin(z) = \\cos(z+\\pi/2)$ 来写出：\n$$\nF(x) = A S(k) \\cos(kx + \\pi/2)\n$$\n将此与 $F(x) = B \\cos(kx + \\varphi)$ 比较，我们发现振幅 $B = A S(k)$ 和相位 $\\varphi = \\pi/2$。\n\n如果 $A < 0$：\n$F(x) = -A S(k) \\sin(kx) = |A| S(k) \\sin(kx)$。使用恒等式 $\\sin(z) = \\cos(z-\\pi/2)$：\n$$\nF(x) = |A| S(k) \\cos(kx - \\pi/2)\n$$\n振幅为 $B = |A| S(k)$，相位为 $\\varphi = -\\pi/2$。\n通常情况下，$B=|A|S(k)$ 且 $\\varphi = \\mathrm{sign}(A) \\cdot \\pi/2$。\n\n### 特殊情况\n-   **模式 $m=0$ ($k=0$)**：这对应于均匀的密度偏移。根据对称性，力必须为零。离散梯度算子符号 $\\widehat{\\partial_x}(k) = i \\sin(k\\Delta)/\\Delta$ 在 $k=0$ 时为零。因此，传递函数 $T(0)=0$，产生的力为零。所以，对于 $m=0$，$B=0$ 且 $\\varphi=0$。\n-   **奈奎斯特模式 $m=N/2$ ($k=\\pi/\\Delta$)**：对于此模式，离散梯度中正弦函数的参数为 $k\\Delta = \\pi$。因此，$\\widehat{\\partial_x}(\\pi/\\Delta) = i \\sin(\\pi)/\\Delta = 0$。传递函数再次为零，$T(\\pi/\\Delta)=0$，力消失。所以，对于 $m=N/2$，$B=0$ 且 $\\varphi=0$。\n\n### 最终公式\n对于给定的测试用例 $(N, L, A, m)$:\n如果 $m=0$ 或 $m=N/2$，则对于两种核，$B=0, \\varphi=0$。\n否则，对于 $m \\in \\{1, \\dots, N/2-1\\}$:\n三角函数的参数是 $z = k\\Delta/2 = \\pi m/N$。\n振幅为 $B = |A| \\left[ W_p(k)^2 \\frac{L}{2N} \\cot(z) \\right]$。\n相位为 $\\varphi = \\mathrm{sign}(A) \\cdot \\pi/2$（如果 $A=0$ 则为 $0$）。\n窗口函数为 $W_{\\mathrm{CIC}}(k) = \\mathrm{sinc}^2(z)$ 和 $W_{\\mathrm{TSC}}(k) = \\mathrm{sinc}^3(z)$。该公式需要 $W_p(k)^2$。\n因此，对于 CIC：\n$$\nB_{\\mathrm{CIC}} = |A| \\left(\\mathrm{sinc}^2\\left(\\frac{\\pi m}{N}\\right)\\right)^2 \\frac{L}{2N} \\cot\\left(\\frac{\\pi m}{N}\\right) = |A| \\mathrm{sinc}^4\\left(\\frac{\\pi m}{N}\\right) \\frac{L}{2N} \\cot\\left(\\frac{\\pi m}{N}\\right)\n$$\n对于 TSC：\n$$\nB_{\\mathrm{TSC}} = |A| \\left(\\mathrm{sinc}^3\\left(\\frac{\\pi m}{N}\\right)\\right)^2 \\frac{L}{2N} \\cot\\left(\\frac{\\pi m}{N}\\right) = |A| \\mathrm{sinc}^6\\left(\\frac{\\pi m}{N}\\right) \\frac{L}{2N} \\cot\\left(\\frac{\\pi m}{N}\\right)\n$$\n两种核的相位均为 $\\varphi_{\\mathrm{CIC}} = \\varphi_{\\mathrm{TSC}} = \\mathrm{sign}(A) \\cdot \\pi/2$。\n\n$\\mathrm{sinc}$ 函数定义为 $\\mathrm{sinc}(z) = \\sin(z)/z$。为了实现，使用像 `numpy.sinc(x)` 这样的库函数很方便，它计算 $\\sin(\\pi x)/(\\pi x)$ 并正确处理 $x=0$ 的情况。当 $x=m/N$ 时，它直接计算 $\\mathrm{sinc}(\\pi m/N)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the amplitude and phase of the force response for a single-mode\n    density perturbation in a 1D particle-mesh gravity solver.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (N, L, A, m)\n    test_cases = [\n        (64, 1.0, 0.05, 5),\n        (64, 1.0, 0.001, 1),\n        (64, 1.0, 0.08, 0),\n        (64, 1.0, 0.05, 32),\n        (64, 1.0, 0.05, 31),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, L, A, m = case\n        \n        # Per the derivation, the force is zero for the DC mode (m=0)\n        # and the Nyquist mode (m=N/2) due to the discrete gradient operator being zero.\n        # Also, if amplitude A is zero, the force is zero.\n        if m == 0 or m == N / 2 or A == 0.0:\n            B_cic, phi_cic = 0.0, 0.0\n            B_tsc, phi_tsc = 0.0, 0.0\n            results.append([B_cic, phi_cic, B_tsc, phi_tsc])\n            continue\n\n        # Wavenumber k and cell size Delta are implicitly used via the argument z.\n        # z = k * Delta / 2 = (2*pi*m/L) * (L/N) / 2 = pi * m / N\n        z = np.pi * float(m) / float(N)\n\n        # The sinc function is defined as sinc(x) = sin(x)/x.\n        # numpy.sinc(x) computes sin(pi*x)/(pi*x).\n        # Our argument to sinc is z = pi * m / N.\n        # To use numpy.sinc, we need an argument `arg` such that pi*arg = z.\n        # So arg = z/pi = m/N.\n        sinc_val = np.sinc(float(m) / float(N))\n\n        # W_p(k)^2 factor in the amplitude expression.\n        # For CIC, p=2 in the sinc exponent, so we need (sinc^2)^2 = sinc^4\n        # For TSC, p=3 in the sinc exponent, so we need (sinc^3)^2 = sinc^6\n        W2_cic = sinc_val**4\n        W2_tsc = sinc_val**6\n\n        # Common part of the amplitude formula: |A| * (Delta/2) * cot(z)\n        # Delta = L/N\n        cot_z = 1.0 / np.tan(z)\n        common_factor = abs(A) * (L / (2.0 * N)) * cot_z\n\n        # Calculate amplitudes\n        B_cic = common_factor * W2_cic\n        B_tsc = common_factor * W2_tsc\n\n        # Calculate phase\n        # From the derivation F(x) ~ -A * sin(kx).\n        # If A > 0, F(x) ~ -sin(kx) = cos(kx + pi/2), so phi = pi/2.\n        # If A  0, F(x) ~ sin(kx) = cos(kx - pi/2), so phi = -pi/2.\n        # np.sign(A) handles this.\n        phi = np.sign(A) * np.pi / 2.0\n        \n        results.append([B_cic, phi, B_tsc, phi])\n\n    # Final print statement in the exact required format.\n    # The format string uses list comprehension to format each sublist.\n    print(f\"[{','.join(str(res).replace(' ', '') for res in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "除了由离散算子引入的误差外，将连续密度场采样到离散网格上还会带来另一个关键的数值效应：混叠（aliasing）。高频信息可能会被错误地“折叠”到低频区域，从而污染我们对宇宙大尺度结构功率谱等关键物理量的测量。这个实践练习  设计了一个直接的数值实验，让您亲手构造一个仅包含高频模式的密度场，然后观察在粗糙网格上采样时，这些高频信号如何“泄漏”并伪装成低频功率。您还将实现并评估如“交错采样”（interlacing）等先进技术，以直观地了解它们抑制混叠伪影的有效性。",
            "id": "3481176",
            "problem": "考虑一个边长为 $L$ 的三维周期性立方体域，其中填充着一个均值为零的标量密度对比度场 $\\delta(\\boldsymbol{x})$。在粒子-网格（particle-mesh）引力求解器中，通常使用快速傅里叶变换（FFT）在尺寸为 $N \\times N \\times N$ 的规则网格上估计傅里叶模 $\\tilde{\\delta}(\\boldsymbol{k})$。在网格上的离散采样会引入混叠（aliasing）：波数大小 $k$ 大于奈奎斯特波数 $k_{\\rm Ny}$ 的傅里叶模会泄露到测得的 $k \\le k_{\\rm Ny}$ 的模中。交错采样（Interlacing）和窗函数补偿是缓解此类混叠的标准技术。您的任务是通过构建一个已知的、仅包含 $k > k_{\\rm Ny}$ 模式的限带高频场（对于给定的粗糙网格），然后测量在不同缓解选项下泄漏到 $k \\le k_{\\rm Ny}$ 的伪功率（spurious power），从而量化混叠效应。\n\n需要使用的基本原理和定义：\n- 牛顿粒子-网格求解器通过“存放”（deposition）过程在网格上估计密度对比度 $\\delta(\\boldsymbol{x})$，并使用 FFT 求解泊松方程。但在此问题中，您仅需关注由采样定理和傅里叶性质决定的采样和谱估计方面。\n- 对于每维有 $N$ 个点且间距为 $\\Delta x$ 的网格，其奈奎斯特波数为 $k_{\\rm Ny} = \\pi/\\Delta x = \\pi N/L$。\n- 对一个在每维大小为 $N$ 的网格上采样的实周期场进行三维离散傅里叶变换（DFT），会产生在离散波数 $\\boldsymbol{k}_{\\boldsymbol{n}} = \\frac{2\\pi}{L}(n_x, n_y, n_z)$ 处的傅里叶系数 $\\tilde{\\delta}(\\boldsymbol{k}_{\\boldsymbol{n}})$，其中整数索引 $n_i \\in \\{-N/2,\\dots,N/2-1\\}$。\n- 交错采样（Interlacing）：构建两个采样网格，一个在标准网格上，另一个偏移了 $\\boldsymbol{a}=(\\Delta x/2,\\Delta x/2,\\Delta x/2)$。对两者进行傅里叶变换，将偏移后的变换乘以 $\\exp(i\\boldsymbol{k}\\cdot\\boldsymbol{a})$ 进行相位重置，然后将它们平均，以抑制奇数阶混叠镜像。\n- Cloud-In-Cell (CIC) 窗函数补偿：CIC 存放核的傅里叶空间窗函数为 $W_{\\rm CIC}(\\boldsymbol{k}) = \\prod_{i\\in\\{x,y,z\\}} \\left[\\mathrm{sinc}\\left(\\frac{k_i\\Delta x}{2}\\right)\\right]^2$，其中 $\\mathrm{sinc}(u)=\\sin(u)/u$（当 $u\\neq 0$）且 $\\mathrm{sinc}(0)=1$。反卷积操作是将测得的傅里叶振幅除以 $W_{\\rm CIC}(\\boldsymbol{k})$。\n\n您的程序必须严格按照以下步骤进行，仅使用上述基本原理、定义以及离散采样和傅里叶分析的一般原则。三角函数内的角度以弧度为单位。\n\n1. 在一个尺寸为 $M \\times M \\times M$ 的网格上构建一个高分辨率的周期性零均值高斯随机场实现，其中 $M=mN$，$m$ 是一个整数放大因子。高分辨率网格和粗糙网格的 $L$ 固定且相同。首先，在实空间中抽取独立的高斯样本，然后进行傅里叶变换得到 $\\tilde{\\delta}_{\\rm HR}(\\boldsymbol{k})$。在傅里叶空间中应用一个锐截止带通滤波器，仅保留波数大小 $k$ 在区间 $(k_{\\rm Ny}^{(N)}, \\alpha\\,k_{\\rm Ny}^{(N)}]$ 内的模式，其中 $k_{\\rm Ny}^{(N)}=\\pi N/L$ 是粗糙网格的奈奎斯特波数，$\\alpha$ 是一个选择的因子，使得 $\\alpha\\,k_{\\rm Ny}^{(N)} \\le k_{\\rm Ny}^{(M)}=\\pi M/L$。进行逆变换得到实空间场 $\\delta_{\\rm HR}(\\boldsymbol{x})$，然后重新缩放，使其方差为 1，均值为 0。\n\n2. 用两种方式在粗糙网格上对高分辨率场进行采样：\n   - 标准采样：在粗糙网格节点 $\\boldsymbol{x}_{\\boldsymbol{j}}$（间距为 $\\Delta x=L/N$）处，令 $\\delta_{0}(\\boldsymbol{x}_{\\boldsymbol{j}}) = \\delta_{\\rm HR}(\\boldsymbol{x}_{\\boldsymbol{j}})$。这对应于从高分辨率网格的每个维度上每 $m$ 个单元取一个。\n   - 半单元偏移采样：令 $\\delta_{s}(\\boldsymbol{x}_{\\boldsymbol{j}}) = \\delta_{\\rm HR}(\\boldsymbol{x}_{\\boldsymbol{j}}+\\boldsymbol{a})$，其中偏移量 $\\boldsymbol{a}=(\\Delta x/2,\\Delta x/2,\\Delta x/2)$。通过在每个维度上选择偏移了 $m/2$ 个高分辨率单元的每 $m$ 个单元来实现，并采用周期性环绕处理。\n\n3. 计算粗糙网格上的离散傅里叶变换 $\\tilde{\\delta}_{0}(\\boldsymbol{k})$ 和 $\\tilde{\\delta}_{s}(\\boldsymbol{k})$。如果启用交错采样，则构成交错估计\n   $$\\tilde{\\delta}_{\\rm int}(\\boldsymbol{k}) = \\frac{1}{2}\\left[\\tilde{\\delta}_{0}(\\boldsymbol{k}) + e^{i\\boldsymbol{k}\\cdot\\boldsymbol{a}}\\,\\tilde{\\delta}_{s}(\\boldsymbol{k})\\right],$$\n   否则，设置 $\\tilde{\\delta}_{\\rm int}(\\boldsymbol{k})=\\tilde{\\delta}_{0}(\\boldsymbol{k})$。\n\n4. 如果启用 CIC 窗函数反卷积，则将傅里叶振幅除以如上定义的 $W_{\\rm CIC}(\\boldsymbol{k})$，约定跳过对 $\\boldsymbol{k}=\\boldsymbol{0}$ 处 $W_{\\rm CIC}(\\boldsymbol{k})$ 的除法。\n\n5. 使用所选的交错采样和反卷积组合，估算粗糙网格上的球平均功率谱 $P(\\boldsymbol{k}) = |\\tilde{\\delta}(\\boldsymbol{k})|^{2}/N^{6}$。由于构建的场的真实低波数成分根据设计恒为零，因此对于 $k \\le k_{\\rm Ny}^{(N)}$，测得的任何功率都是纯粹的伪影。计算泄露度量 $\\Delta P$，定义为在波数 $k$ 严格介于 $0$ 和 $\\frac{1}{2}k_{\\rm Ny}^{(N)}$ 之间的所有模式上的平均功率：\n   $$\\Delta P = \\mathrm{mean}\\left\\{P(\\boldsymbol{k}) \\mid 0  \\lVert \\boldsymbol{k} \\rVert \\le \\frac{1}{2}k_{\\rm Ny}^{(N)} \\right\\}.$$\n   将 $\\Delta P$ 作为此测试用例的最终结果。\n\n对于以下每个测试用例，计算无量纲浮点数 $\\Delta P$：\n1. $N=24, m=4, \\alpha=1.5$, 交错 = False, 反卷积 = False\n2. $N=24, m=4, \\alpha=1.5$, 交错 = True, 反卷积 = False\n3. $N=24, m=4, \\alpha=1.5$, 交错 = False, 反卷积 = True\n4. $N=24, m=4, \\alpha=1.5$, 交错 = True, 反卷积 = True\n5. $N=16, m=4, \\alpha=1.2$, 交错 = True, 反卷积 = True\n\n域大小固定为 $L=1.0$，随机种子固定为 42。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的 5 个结果的列表，格式如下： `[result1,result2,result3,result4,result5]`。",
            "solution": "该问题要求我们量化在离散网格上对标量场进行谱分析时产生的混叠效应，这是数值宇宙学中粒子-网格（PM）求解器的一个常见问题。我们将构建一个特定的测试案例：一个高频、限带的随机场，其设计使其在低波数处没有功率。当这个场在粗糙网格上采样时，在低波数处测得的任何功率都纯粹是混叠产生的伪影。我们将计算在不同缓解策略下（即交错采样和窗函数反卷积）这种泄露的度量。\n\n该过程按以下步骤实现：\n\n1.  **构建高分辨率、限带场**\n    我们首先定义一个计算域，即边长为 $L=1$ 的周期性立方体。在一个尺寸为 $M \\times M \\times M$ 的高分辨率网格上（其中 $M=mN$，$N$ 为粗糙网格尺寸，$m$ 为整数放大因子），我们生成一个零均值高斯随机场的实现。这通过向 $M^3$ 网格的每个单元填充一个从标准正态分布中抽取的独立样本来完成。然后，我们对这个实值场进行三维快速傅里叶变换（FFT），得到其在高分辨率 k 空间网格上的傅里叶系数 $\\tilde{\\delta}_{\\rm HR}(\\boldsymbol{k}_{\\rm HR})$。\n\n    为了创建测试信号，我们在傅里叶空间中应用一个锐截止带通滤波器。该滤波器会消除所有模式，除了那些波数大小 $k = \\lVert\\boldsymbol{k}\\rVert$ 位于区间 $(k_{\\rm Ny}^{(N)}, \\alpha k_{\\rm Ny}^{(N)}]$ 内的模式。这里，$k_{\\rm Ny}^{(N)} = \\pi N/L$ 是目标粗糙网格的奈奎斯特波数，而 $\\alpha$ 是一个给定的因子，满足 $\\alpha \\le m$ 以确保该频带位于高分辨率网格的可表示范围内。所有在该频带之外的傅里叶系数都被设置为零。\n\n    然后，将这个经过滤波的谱通过逆傅里叶变换转换回实空间，得到场 $\\delta_{\\rm HR}(\\boldsymbol{x})$。根据构造，该场相对于粗糙网格是限带于高频的。最后，我们通过减去场的空间平均值来强制其均值为零，并将其归一化至单位方差。这为我们的混叠实验提供了一个定义明确的输入信号。\n\n2.  **在粗糙网格上采样**\n    接着，将高分辨率场 $\\delta_{\\rm HR}(\\boldsymbol{x})$ 采样到一个尺寸为 $N \\times N \\times N$ 的粗糙网格上。使用两种采样方法：\n    -   **标准采样**：通过在每个维度上每隔 $m$ 个格点取一个 $\\delta_{\\rm HR}$ 的值来获得粗糙网格场 $\\delta_0$。这对应于直接点采样，或者从粒子角度看，是最近邻网格点（NGP）分配。\n    -   **偏移采样**：为了应用交错采样技术，构建第二个网格 $\\delta_s$。它是从 $\\delta_{\\rm HR}$ 的一个版本中采样得到的，该版本已被一个向量 $\\boldsymbol{a} = (\\Delta x/2, \\Delta x/2, \\Delta x/2)$ 偏移，其中 $\\Delta x = L/N$ 是粗糙网格的间距。这通过首先将高分辨率网格在每个维度上周期性地移动 $m/2$ 个单元，然后像之前一样进行降采样来实现。\n\n3.  **傅里叶变换与交错采样**\n    我们使用 FFT 计算两个粗糙网格场 $\\tilde{\\delta}_{0}(\\boldsymbol{k})$ 和 $\\tilde{\\delta}_{s}(\\boldsymbol{k})$ 的离散傅里叶变换。如果禁用交错采样，最终的谱估计就是 $\\tilde{\\delta}(\\boldsymbol{k}) = \\tilde{\\delta}_{0}(\\boldsymbol{k})$。\n\n    如果启用交错采样，我们则组合这两个变换。根据傅里叶位移定理，实空间中 $\\boldsymbol{a}$ 的位移对应于傅里叶空间中乘以 $e^{-i\\boldsymbol{k}\\cdot\\boldsymbol{a}}$。为了对齐两个谱，我们将偏移场的变换 $\\tilde{\\delta}_{s}(\\boldsymbol{k})$ 乘以 $e^{i\\boldsymbol{k}\\cdot\\boldsymbol{a}}$ 以抵消空间位移在傅里叶空间中的影响。交错估计即为标准变换和重定相位后的偏移变换的平均值：\n    $$ \\tilde{\\delta}_{\\rm int}(\\boldsymbol{k}) = \\frac{1}{2}\\left[\\tilde{\\delta}_{0}(\\boldsymbol{k}) + e^{i\\boldsymbol{k}\\cdot\\boldsymbol{a}}\\,\\tilde{\\delta}_{s}(\\boldsymbol{k})\\right] $$\n    这个平均过程可以抵消主阶混叠项，这些项来自奈奎斯特频率奇数倍附近的频带，并且在这两个样本中具有相反的相位。\n\n4.  **窗函数反卷积**\n    在 PM 方法中，粒子不是点，而是被“存放”到网格上，这等效于与一个核（或窗函数）进行卷积。这会平滑密度场并抑制高波数处的功率。为了校正这一点，需要在傅里叶空间中通过除以窗函数的傅里叶变换来进行反卷积。问题指定应用 Cloud-In-Cell (CIC) 方案的反卷积，尽管我们的采样是点状的。CIC 窗函数在傅里叶空间中的形式是：\n    $$ W_{\\rm CIC}(\\boldsymbol{k}) = \\prod_{i\\in\\{x,y,z\\}} \\left[\\mathrm{sinc}\\left(\\frac{k_i\\Delta x}{2}\\right)\\right]^2 $$\n    其中 $\\mathrm{sinc}(u) \\equiv \\sin(u)/u$。如果启用反卷积，每个傅里叶模 $\\tilde{\\delta}(\\boldsymbol{k})$（对于 $\\boldsymbol{k} \\neq \\boldsymbol{0}$）都将被除以 $W_{\\rm CIC}(\\boldsymbol{k})$。此操作会提升高 $k$ 处的功率，以抵消假定的存放方案所带来的平滑效应。\n\n5.  **量化混叠泄露**\n    在经过可选的交错采样和反卷积步骤后，我们得到了最终的谱估计 $\\tilde{\\delta}(\\boldsymbol{k})$。由此，我们计算粗糙网格上的功率谱，其定义如下：\n    $$ P(\\boldsymbol{k}) = \\frac{|\\tilde{\\delta}(\\boldsymbol{k})|^2}{N^6} $$\n    由于原始连续场 $\\delta_{\\rm HR}(\\boldsymbol{x})$ 被构造成在 $k \\le k_{\\rm Ny}^{(N)}$ 范围内功率为零，因此在粗糙网格估计中，此范围内的任何功率 $P(\\boldsymbol{k})$ 都是高频混叠的直接结果。为了量化这一点，我们计算泄露度量 $\\Delta P$，定义为在波数 $k$ 严格介于 $0$ 和粗糙网格奈奎斯特频率一半之间的所有模式上的平均功率：\n    $$ \\Delta P = \\mathrm{mean}\\left\\{P(\\boldsymbol{k}) \\mid 0  \\lVert \\boldsymbol{k} \\rVert \\le \\frac{1}{2}k_{\\rm Ny}^{(N)} \\right\\} $$\n    这个度量为每种缓解技术组合提供了一个单一的值，代表了混叠泄露到谱的低波数部分的严重程度。整个流程将对每个测试用例执行，以获得最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (N, m, alpha, interlace, deconvolve)\n        (24, 4, 1.5, False, False),\n        (24, 4, 1.5, True, False),\n        (24, 4, 1.5, False, True),\n        (24, 4, 1.5, True, True),\n        (16, 4, 1.2, True, True),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_p = compute_leakage(*case)\n        results.append(delta_p)\n\n    # Final print statement in the exact required format.\n    # The problem asks for dimensionless floats. Scientific notation is appropriate.\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\ndef compute_leakage(N, m, alpha, interlace, deconvolve, L=1.0, seed=42):\n    \"\"\"\n    Computes the aliasing leakage metric Delta P for a given set of parameters.\n    \n    Args:\n        N (int): Coarse grid size per dimension.\n        m (int): Upscale factor for the high-resolution grid.\n        alpha (float): High-frequency band upper factor.\n        interlace (bool): Flag to enable interlacing.\n        deconvolve (bool): Flag to enable CIC deconvolution.\n        L (float): Side length of the periodic cubic domain.\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        float: The computed leakage metric Delta P.\n    \"\"\"\n    # === Step 1: Construct high-resolution, band-limited field ===\n    M = N * m\n    rng = np.random.default_rng(seed)\n    \n    # Generate a GRF in real space and transform to Fourier space\n    delta_hr_real = rng.standard_normal(size=(M, M, M))\n    delta_hr_fourier = np.fft.fftn(delta_hr_real) # Use fftn for complex result\n\n    # Define k-vectors for the high-resolution M-grid\n    k_freq_M = np.fft.fftfreq(M, d=L / M)\n    kx_M, ky_M, kz_M = np.meshgrid(k_freq_M, k_freq_M, k_freq_M, indexing='ij')\n    \n    k_mag_M = 2 * np.pi * np.sqrt(kx_M**2 + ky_M**2 + kz_M**2)\n    \n    # Apply a sharp band-pass filter\n    k_ny_N = np.pi * N / L\n    filter_mask = (k_mag_M > k_ny_N)  (k_mag_M = alpha * k_ny_N)\n    delta_hr_fourier_filtered = delta_hr_fourier * filter_mask\n\n    # Inverse transform and normalize the real-space field\n    delta_hr_filtered_real = np.fft.ifftn(delta_hr_fourier_filtered).real\n    delta_hr_filtered_real -= np.mean(delta_hr_filtered_real)\n    std_dev = np.std(delta_hr_filtered_real)\n    if std_dev > 0:\n        delta_hr_filtered_real /= std_dev\n\n    # === Step 2: Sample the HR field on the coarse grid ===\n    # Standard sampling (downsampling)\n    delta_0 = delta_hr_filtered_real[::m, ::m, ::m]\n    \n    # Shifted sampling for interlacing\n    if interlace:\n        shift_amount = m // 2\n        delta_hr_shifted = np.roll(delta_hr_filtered_real, shift=(shift_amount, shift_amount, shift_amount), axis=(0, 1, 2))\n        delta_s = delta_hr_shifted[::m, ::m, ::m]\n\n    # === Step 3: Compute DFTs and apply interlacing ===\n    tilde_delta_0 = np.fft.fftn(delta_0)\n    \n    if interlace:\n        tilde_delta_s = np.fft.fftn(delta_s)\n        \n        # Define k-vectors for the coarse N-grid to compute phase factor\n        k_freq_N = np.fft.fftfreq(N, d=L/N)\n        kx_N, ky_N, kz_N = np.meshgrid(k_freq_N, k_freq_N, k_freq_N, indexing='ij')\n        \n        delta_x = L / N\n        k_dot_a = 2 * np.pi * (kx_N + ky_N + kz_N) * (delta_x / 2.0)\n        phase_factor = np.exp(1j * k_dot_a)\n        \n        tilde_delta_final = 0.5 * (tilde_delta_0 + phase_factor * tilde_delta_s)\n    else:\n        tilde_delta_final = tilde_delta_0\n        \n    # === Step 4: Apply CIC window deconvolution ===\n    if deconvolve:\n        # Use integer frequency indices for robust sinc calculation\n        ix, iy, iz = np.meshgrid(np.fft.fftfreq(N), np.fft.fftfreq(N), np.fft.fftfreq(N), indexing='ij')\n        \n        # Suppress RuntimeWarning for division by zero in sinc\n        with np.errstate(divide='ignore', invalid='ignore'):\n            W_cic = (np.sinc(ix) * np.sinc(iy) * np.sinc(iz))**2\n        W_cic[0,0,0] = 1.0 # Correct sinc(0)=1\n        \n        # Deconvolution: divide by W_cic, skipping k=0\n        mask_k_ne_0 = ~((ix==0)  (iy==0)  (iz==0))\n        \n        # Regularize to prevent division by zero for Nyquist modes where sinc is zero\n        denominator = W_cic[mask_k_ne_0]\n        denominator[denominator == 0] = 1e-30\n        \n        tilde_delta_final[mask_k_ne_0] /= denominator\n\n    # === Step 5: Estimate Power Spectrum and Leakage Metric ===\n    # Power spectrum as defined in the problem\n    P_k = np.abs(tilde_delta_final)**2 / N**6\n    \n    # Calculate k-magnitudes on the coarse grid to define leakage region\n    if not 'kx_N' in locals():\n        k_freq_N = np.fft.fftfreq(N, d=L/N)\n        kx_N, ky_N, kz_N = np.meshgrid(k_freq_N, k_freq_N, k_freq_N, indexing='ij')\n\n    k_mag_N = 2 * np.pi * np.sqrt(kx_N**2 + ky_N**2 + kz_N**2)\n    \n    # Define leakage region and compute the metric\n    leakage_mask = (k_mag_N > 0)  (k_mag_N = 0.5 * k_ny_N)\n    \n    if np.any(leakage_mask):\n        delta_P = np.mean(P_k[leakage_mask])\n    else:\n        delta_P = 0.0\n\n    return delta_P\n\nif __name__ == \"__main__\":\n    # This block is not executed in the target environment but useful for local testing\n    solve()\n```"
        }
    ]
}