{
    "hands_on_practices": [
        {
            "introduction": "The one-dimensional harmonic oscillator serves as an essential theoretical laboratory for analyzing the properties of numerical integrators. This exercise  guides you through an analytical derivation of the modified frequency produced by the leapfrog scheme. By completing this, you will gain insight into why symplectic integrators like leapfrog exhibit excellent long-term energy stability; they exactly conserve a \"shadow\" Hamiltonian, which results in a bounded phase error (a frequency shift) rather than a secular drift in energy.",
            "id": "3501415",
            "problem": "In cosmological $N$-body computations, symplectic splitting integrators such as the Kick–Drift–Kick (KDK) leapfrog are used to advance trajectories under time-independent forces. As a linear testbed relevant to small oscillations near gravitational potential minima, consider a one-dimensional harmonic oscillator with Hamiltonian $H(x,p)=\\frac{1}{2}\\left(p^{2}+\\omega^{2}x^{2}\\right)$, where the mass has been normalized to $m=1$, $x$ is the comoving coordinate, $p$ is the canonical momentum, and $\\omega0$ is the exact angular frequency. The equation of motion is $\\ddot{x}+\\omega^{2}x=0$ and the continuous-time flow generated by $H$ is a phase-space rotation of angle $\\omega t$.\n\nLet the timestep be $h0$. The KDK leapfrog consists of a momentum \"kick\" over a half-step driven by the gradient of the potential, a position \"drift\" over a full step driven by the kinetic term, and a final momentum \"kick\" over a half-step. Starting from the fundamental laws defining $H$, the canonical equations, and the KDK composition, derive the single-step linear update mapping $(x_{n},p_{n})\\mapsto(x_{n+1},p_{n+1})$ and analyze its eigenvalues to infer the angle of the corresponding phase-space rotation. The discrete map exactly preserves a modified (shadow) Hamiltonian that is quadratic and generates a harmonic rotation at a modified angular frequency $\\tilde{\\omega}$ that depends on $h$ and $\\omega$.\n\nCompute the closed-form analytic expression for the modified angular frequency $\\tilde{\\omega}$ implied by the KDK leapfrog’s modified Hamiltonian, expressed purely in terms of $h$ and $\\omega$. Briefly compare $\\tilde{\\omega}$ to the exact $\\omega$ in the small-$h$ limit in your derivation, but for the final answer provide only the analytic expression for $\\tilde{\\omega}$. No numerical rounding is required, and you should not include any units in the final answer.",
            "solution": "The problem statement is rigorously validated and found to be valid. It is scientifically grounded in Hamiltonian mechanics and numerical integration theory, well-posed, objective, and internally consistent. We may therefore proceed with the derivation.\n\nThe system is a one-dimensional harmonic oscillator with mass $m=1$, described by the Hamiltonian $H(x,p) = T(p) + V(x)$, where the kinetic energy is $T(p) = \\frac{1}{2}p^2$ and the potential energy is $V(x) = \\frac{1}{2}\\omega^2 x^2$. Hamilton's canonical equations of motion are:\n$$\n\\dot{x} = \\frac{\\partial H}{\\partial p} = p\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial x} = -\\omega^2 x\n$$\n\nThe Kick-Drift-Kick (KDK) leapfrog integrator is a second-order symplectic splitting method that approximates the exact time evolution operator $\\exp(h\\mathcal{L}_H)$ by a composition of operators for the kinetic and potential parts, where $\\mathcal{L}_H = \\{ \\cdot, H \\}$ is the Poisson bracket operator. The KDK scheme for a timestep $h$ is given by the composition:\n$$\n\\Phi_h = \\Phi_V^{h/2} \\circ \\Phi_T^{h} \\circ \\Phi_V^{h/2}\n$$\nHere, $\\Phi_V^{\\Delta t}$ represents evolving the system under only the potential part $V(x)$ for a time $\\Delta t$, and $\\Phi_T^{\\Delta t}$ represents evolving it under only the kinetic part $T(p)$ for a time $\\Delta t$.\n\nLet us derive the map for each component.\n1.  **Kick step ($\\Phi_V^{\\Delta t}$)**: Evolution under $V(x)$ follows the equations $\\dot{x}=0$ and $\\dot{p}=-\\frac{\\partial V}{\\partial x} = -\\omega^2 x$. Since $x$ is constant during this step, the update from $(x, p)$ to $(x', p')$ over a time interval $\\Delta t$ is:\n    $$\n    x' = x\n    $$\n    $$\n    p' = p - (\\omega^2 x) \\Delta t\n    $$\n\n2.  **Drift step ($\\Phi_T^{\\Delta t}$)**: Evolution under $T(p)$ follows the equations $\\dot{x}=\\frac{\\partial T}{\\partial p} = p$ and $\\dot{p}=0$. Since $p$ is constant during this step, the update from $(x, p)$ to $(x', p')$ over a time interval $\\Delta t$ is:\n    $$\n    x' = x + p \\Delta t\n    $$\n    $$\n    p' = p\n    $$\n\nNow, we compose these steps to build the full KDK integrator map from $(x_n, p_n)$ to $(x_{n+1}, p_{n+1})$ over a timestep $h$.\n\n**First Kick (half-step, $\\Delta t = h/2$)**:\nLet the intermediate state be $(x_\\text{mid1}, p_\\text{mid1})$.\n$$\nx_\\text{mid1} = x_n\n$$\n$$\np_\\text{mid1} = p_n - \\frac{h}{2}\\omega^2 x_n\n$$\n\n**Drift (full step, $\\Delta t = h$)**:\nLet the next intermediate state be $(x_\\text{mid2}, p_\\text{mid2})$. We apply the drift to $(x_\\text{mid1}, p_\\text{mid1})$.\n$$\nx_\\text{mid2} = x_\\text{mid1} + h \\cdot p_\\text{mid1} = x_n + h\\left(p_n - \\frac{h}{2}\\omega^2 x_n\\right) = \\left(1 - \\frac{h^2\\omega^2}{2}\\right)x_n + h p_n\n$$\n$$\np_\\text{mid2} = p_\\text{mid1} = p_n - \\frac{h}{2}\\omega^2 x_n\n$$\n\n**Second Kick (half-step, $\\Delta t = h/2$)**:\nThe final state $(x_{n+1}, p_{n+1})$ is found by applying the kick to $(x_\\text{mid2}, p_\\text{mid2})$.\n$$\nx_{n+1} = x_\\text{mid2} = \\left(1 - \\frac{h^2\\omega^2}{2}\\right)x_n + h p_n\n$$\n$$\np_{n+1} = p_\\text{mid2} - \\frac{h}{2}\\omega^2 x_\\text{mid2} = \\left(p_n - \\frac{h}{2}\\omega^2 x_n\\right) - \\frac{h}{2}\\omega^2 \\left[ \\left(1 - \\frac{h^2\\omega^2}{2}\\right)x_n + h p_n \\right]\n$$\nExpanding the expression for $p_{n+1}$:\n$$\np_{n+1} = p_n - \\frac{h\\omega^2}{2}x_n - \\frac{h\\omega^2}{2}\\left(1 - \\frac{h^2\\omega^2}{2}\\right)x_n - \\frac{h^2\\omega^2}{2}p_n\n$$\n$$\np_{n+1} = \\left(1 - \\frac{h^2\\omega^2}{2}\\right)p_n - \\left[\\frac{h\\omega^2}{2} + \\frac{h\\omega^2}{2} - \\frac{h^3\\omega^4}{4}\\right]x_n\n$$\n$$\np_{n+1} = \\left(1 - \\frac{h^2\\omega^2}{2}\\right)p_n - \\left(h\\omega^2 - \\frac{h^3\\omega^4}{4}\\right)x_n\n$$\n$$\np_{n+1} = -\\omega^2 h\\left(1 - \\frac{h^2\\omega^2}{4}\\right)x_n + \\left(1 - \\frac{h^2\\omega^2}{2}\\right)p_n\n$$\n\nThe single-step linear update can be written in matrix form as $\\begin{pmatrix} x_{n+1} \\\\ p_{n+1} \\end{pmatrix} = M \\begin{pmatrix} x_n \\\\ p_n \\end{pmatrix}$, where the transfer matrix $M$ is:\n$$\nM = \\begin{pmatrix}\n1 - \\frac{h^2\\omega^2}{2}  h \\\\\n-\\omega^2 h\\left(1 - \\frac{h^2\\omega^2}{4}\\right)  1 - \\frac{h^2\\omega^2}{2}\n\\end{pmatrix}\n$$\nThis discrete map corresponds to a rotation in phase space by some angle $\\theta = \\tilde{\\omega}h$, where $\\tilde{\\omega}$ is the modified angular frequency we seek. The eigenvalues of a $2 \\times 2$ rotation matrix are $e^{\\pm i\\theta}$. The trace of such a matrix is $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$. Thus, we can find the angle by calculating the trace of the transfer matrix $M$.\n$$\n\\text{Tr}(M) = \\left(1 - \\frac{h^2\\omega^2}{2}\\right) + \\left(1 - \\frac{h^2\\omega^2}{2}\\right) = 2 - h^2\\omega^2\n$$\nEquating this to the trace of a rotation matrix yields:\n$$\n2\\cos(\\tilde{\\omega}h) = 2 - h^2\\omega^2\n$$\n$$\n\\cos(\\tilde{\\omega}h) = 1 - \\frac{h^2\\omega^2}{2}\n$$\nThe problem is now to solve for $\\tilde{\\omega}$.\n$$\n\\tilde{\\omega}h = \\arccos\\left(1 - \\frac{h^2\\omega^2}{2}\\right)\n$$\nThis expression can be simplified using the trigonometric identity $\\cos(2\\alpha) = 1 - 2\\sin^2(\\alpha)$. Let $\\tilde{\\omega}h = 2\\alpha$. Then $\\cos(2\\alpha) = 1 - \\frac{h^2\\omega^2}{2}$. Comparing this with the identity gives:\n$$\n2\\sin^2(\\alpha) = \\frac{h^2\\omega^2}{2} \\implies \\sin^2(\\alpha) = \\frac{h^2\\omega^2}{4}\n$$\nFor a stable integration ($h\\omega  2$), we can take the principal root:\n$$\n\\sin(\\alpha) = \\frac{h\\omega}{2} \\implies \\alpha = \\arcsin\\left(\\frac{h\\omega}{2}\\right)\n$$\nSubstituting back $\\alpha = \\frac{\\tilde{\\omega}h}{2}$:\n$$\n\\frac{\\tilde{\\omega}h}{2} = \\arcsin\\left(\\frac{h\\omega}{2}\\right)\n$$\nSolving for $\\tilde{\\omega}$:\n$$\n\\tilde{\\omega} = \\frac{2}{h}\\arcsin\\left(\\frac{h\\omega}{2}\\right)\n$$\nThis is the closed-form analytic expression for the modified angular frequency.\n\nTo compare $\\tilde{\\omega}$ with $\\omega$ in the small-$h$ limit, we use the Taylor series expansion for $\\arcsin(z) = z + \\frac{z^3}{6} + O(z^5)$ with $z = \\frac{h\\omega}{2}$:\n$$\n\\tilde{\\omega} = \\frac{2}{h}\\left[ \\left(\\frac{h\\omega}{2}\\right) + \\frac{1}{6}\\left(\\frac{h\\omega}{2}\\right)^3 + O(h^5) \\right]\n$$\n$$\n\\tilde{\\omega} = \\frac{2}{h}\\left[ \\frac{h\\omega}{2} + \\frac{h^3\\omega^3}{48} + O(h^5) \\right]\n$$\n$$\n\\tilde{\\omega} = \\omega + \\frac{h^2\\omega^3}{24} + O(h^4) = \\omega\\left(1 + \\frac{h^2\\omega^2}{24} + O(h^4)\\right)\n$$\nAs $h \\to 0$, the modified frequency $\\tilde{\\omega}$ converges to the true frequency $\\omega$. The leading-order error term $\\frac{h^2\\omega^3}{24}$ is positive, indicating that the numerical oscillator has a slightly higher frequency (period shortening), which is a known characteristic of the leapfrog integrator. The error scales as $h^2$, consistent with the method being second-order accurate.",
            "answer": "$$\\boxed{\\frac{2}{h}\\arcsin\\left(\\frac{h\\omega}{2}\\right)}$$"
        },
        {
            "introduction": "Moving from an idealized model to a practical cosmological simulation requires addressing specific implementation details. Since the leapfrog scheme operates on a staggered time grid, a common challenge is initializing the integration when positions and velocities are provided at the same initial instant. This practice  demonstrates how to construct the necessary \"initial half-kick\" to compute the momentum at the first half-timestep, a crucial procedure for preserving the method's overall second-order accuracy.",
            "id": "3501379",
            "problem": "Consider a collisionless nonrelativistic particle evolving in a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) universe with scale factor $a(t)$. Work in comoving coordinates $\\boldsymbol{x}(t)$ and assume the gravitational potential $\\phi(\\boldsymbol{x}, t)$ is the peculiar potential that solves the comoving Poisson equation and varies smoothly in time. Use the per-unit-mass Lagrangian $L = a(t)^{2} |\\dot{\\boldsymbol{x}}|^{2} / 2 - \\phi(\\boldsymbol{x}, t)$ so that the canonical momentum is $\\boldsymbol{p} = a(t)^{2} \\dot{\\boldsymbol{x}}$. The associated Hamiltonian is $H(\\boldsymbol{x}, \\boldsymbol{p}, t) = |\\boldsymbol{p}|^{2} / \\left(2 a(t)^{2}\\right) + \\phi(\\boldsymbol{x}, t)$, and Hamilton’s equations give $\\dot{\\boldsymbol{x}} = \\boldsymbol{p}/a(t)^{2}$ and $\\dot{\\boldsymbol{p}} = - \\nabla_{\\boldsymbol{x}} \\phi(\\boldsymbol{x}, t)$.\n\nYou plan to integrate the equations of motion using a time-symmetric leapfrog integrator in the kick–drift–kick form with a uniform cosmic time step $\\Delta t$. At the initial time $t_{0}$ you are given the comoving position $\\boldsymbol{x}(t_{0})$ and comoving velocity $\\boldsymbol{v}(t_{0}) = \\dot{\\boldsymbol{x}}(t_{0})$, but the leapfrog scheme requires a momentum at a half time step, $\\boldsymbol{p}^{1/2}$ located at $t_{0} + \\Delta t/2$, to start. Construct an initial half-kick that produces $\\boldsymbol{p}^{1/2}$ from the given data without degrading the second-order accuracy of the leapfrog scheme. Your construction must start from the fundamental definitions and equations given above and must justify why the resulting initialization is second-order accurate.\n\nExpress your final answer as a single closed-form analytic expression for $\\boldsymbol{p}^{1/2}$ in terms of $a(t_{0})$, $\\boldsymbol{v}(t_{0})$, $\\nabla_{\\boldsymbol{x}} \\phi(\\boldsymbol{x}(t_{0}), t_{0})$, and $\\Delta t$.",
            "solution": "The problem requires the construction of an initial condition for the canonical momentum, $\\boldsymbol{p}^{1/2}$, evaluated at a half time step $t_{1/2} = t_{0} + \\Delta t/2$, given the comoving position $\\boldsymbol{x}_{0} = \\boldsymbol{x}(t_0)$ and comoving velocity $\\boldsymbol{v}_{0} = \\dot{\\boldsymbol{x}}(t_0)$ at the initial time $t_{0}$. This initialization is for a time-symmetric leapfrog integrator and must not degrade its inherent second-order accuracy.\n\nFirst, we establish the relationship between the given initial velocity $\\boldsymbol{v}(t_0)$ and the initial canonical momentum $\\boldsymbol{p}(t_0)$. The problem defines the canonical momentum as $\\boldsymbol{p} = a(t)^{2} \\dot{\\boldsymbol{x}}$, where $\\dot{\\boldsymbol{x}} = \\boldsymbol{v}$ is the comoving velocity. Therefore, at the initial time $t_0$, the canonical momentum is:\n$$\n\\boldsymbol{p}(t_0) = a(t_0)^{2} \\boldsymbol{v}(t_0)\n$$\nThe leapfrog integrator in its standard, memory-efficient form, requires phase space variables to be known on a staggered time grid: positions $\\boldsymbol{x}_{n}$ at integer time steps $t_n = t_0 + n \\Delta t$, and momenta $\\boldsymbol{p}_{n+1/2}$ at half-integer time steps $t_{n+1/2} = t_0 + (n+1/2) \\Delta t$. The initial conditions $(\\boldsymbol{x}(t_0), \\boldsymbol{v}(t_0))$ are synchronized at the same time $t_0$. To start the leapfrog integration loop, we must generate a momentum at a half-step, $\\boldsymbol{p}^{1/2} = \\boldsymbol{p}(t_0 + \\Delta t/2)$, from the state at $t_0$.\n\nThe evolution of the canonical momentum is governed by Hamilton's equation, as provided in the problem statement:\n$$\n\\dot{\\boldsymbol{p}} = \\frac{d\\boldsymbol{p}}{dt} = - \\nabla_{\\boldsymbol{x}} \\phi(\\boldsymbol{x}, t)\n$$\nTo find the momentum at time $t_0 + \\Delta t/2$, we can formally integrate this equation of motion from $t_0$ to $t_0 + \\Delta t/2$:\n$$\n\\boldsymbol{p}(t_0 + \\Delta t/2) = \\boldsymbol{p}(t_0) + \\int_{t_0}^{t_0 + \\Delta t/2} \\dot{\\boldsymbol{p}}(t) dt = \\boldsymbol{p}(t_0) - \\int_{t_0}^{t_0 + \\Delta t/2} \\nabla_{\\boldsymbol{x}} \\phi(\\boldsymbol{x}(t), t) dt\n$$\nThis relation is exact. However, the integral cannot be evaluated exactly because the trajectory $\\boldsymbol{x}(t)$ for $t \\in (t_0, t_0 + \\Delta t/2]$ is not known a priori. We must therefore approximate the integral. This step is what the problem refers to as the \"initial half-kick\".\n\nThe leapfrog method achieves second-order accuracy, meaning its global error over a fixed integration interval scales as $\\mathcal{O}((\\Delta t)^2)$. To ensure that the initialization does not degrade this accuracy, the error introduced in this first step must be of an order that is consistent with the overall scheme. Specifically, the error introduced in $\\boldsymbol{p}^{1/2}$ must not be of order $\\mathcal{O}(\\Delta t)$, as this would dominate the global error and reduce the method to first order. The initialization error must be $\\mathcal{O}((\\Delta t)^2)$ or higher.\n\nLet us analyze the error of a simple approximation for the integral. We can approximate the integrand $\\nabla_{\\boldsymbol{x}} \\phi(\\boldsymbol{x}(t), t)$ by its value at the beginning of the integration interval, $t_0$. This corresponds to a first-order Euler step (or the left-endpoint rectangle rule for numerical integration) over the interval of length $\\Delta t / 2$:\n$$\n\\int_{t_0}^{t_0 + \\Delta t/2} \\nabla_{\\boldsymbol{x}} \\phi(\\boldsymbol{x}(t), t) dt \\approx \\left(\\frac{\\Delta t}{2}\\right) \\nabla_{\\boldsymbol{x}} \\phi(\\boldsymbol{x}(t_0), t_0)\n$$\nThe local truncation error of this approximation for the integral is of order $\\mathcal{O}((\\Delta t)^2)$. Substituting this approximation into the exact relation yields our expression for $\\boldsymbol{p}^{1/2}$:\n$$\n\\boldsymbol{p}^{1/2} \\approx \\boldsymbol{p}(t_0) - \\frac{\\Delta t}{2} \\nabla_{\\boldsymbol{x}} \\phi(\\boldsymbol{x}(t_0), t_0)\n$$\nThe error in this computed $\\boldsymbol{p}^{1/2}$ relative to the true value $\\boldsymbol{p}(t_0 + \\Delta t/2)$ is of order $\\mathcal{O}((\\Delta t)^2)$. This initial error in a canonical variable leads to an initial error in the Hamiltonian (or any shadow Hamiltonian) of order $\\mathcal{O}((\\Delta t)^2)$. This is consistent with the global error of a second-order integrator, which accumulates to $\\mathcal{O}((\\Delta t)^2)$ over a fixed time. Thus, an initialization step with a local error of $\\mathcal{O}((\\Delta t)^2)$ does not degrade the overall second-order accuracy of the leapfrog scheme. This procedure is standard for starting staggered-time-step integrators.\n\nFinally, we express the result in terms of the quantities specified in the problem statement: $a(t_{0})$, $\\boldsymbol{v}(t_{0})$, $\\nabla_{\\boldsymbol{x}} \\phi(\\boldsymbol{x}(t_{0}), t_{0})$, and $\\Delta t$. Substituting $\\boldsymbol{p}(t_0) = a(t_0)^{2} \\boldsymbol{v}(t_0)$ into our expression for $\\boldsymbol{p}^{1/2}$ gives the final answer.\n$$\n\\boldsymbol{p}^{1/2} = a(t_0)^{2} \\boldsymbol{v}(t_0) - \\frac{\\Delta t}{2} \\nabla_{\\boldsymbol{x}} \\phi(\\boldsymbol{x}(t_0), t_0)\n$$\nThis is the desired closed-form analytic expression for the initial half-step momentum.",
            "answer": "$$\n\\boxed{a(t_{0})^{2} \\boldsymbol{v}(t_{0}) - \\frac{\\Delta t}{2} \\nabla_{\\boldsymbol{x}} \\phi(\\boldsymbol{x}(t_{0}), t_{0})}\n$$"
        },
        {
            "introduction": "One of the most profound and useful properties of the leapfrog integrator is its time-reversibility, meaning that in exact arithmetic, integrating forward and then backward perfectly recovers the initial state. This numerical experiment  allows you to witness this symmetry directly within an $N$-body simulation. More importantly, it challenges you to quantify how this theoretical property is broken by the practical limitations of finite-precision arithmetic, revealing the unavoidable accumulation of floating-point roundoff error.",
            "id": "3501446",
            "problem": "You are to implement a numerical experiment that probes time-reversibility of the time-centered leapfrog in kick-drift-kick ordering for an $N$-body system in three spatial dimensions. The experiment is framed in the language of numerical cosmology, where the independent variable is the scale factor $a$, and time steps are taken in increments $\\Delta a$. For the purposes of this test, you will evolve a self-gravitating $N$-body system in comoving coordinates with code units where $G=1$ and all particle masses are equal, but without explicit dependence on $a$ in the force law, so that the force per unit mass depends only on comoving positions. The goal is to isolate the effect of floating-point roundoff on time-reversibility of the leapfrog map.\n\nStarting from the fundamental base of Newton’s second law and the definition of velocity as the derivative of position with respect to the independent variable, you must:\n\n- Represent $N$ particles with positions $\\boldsymbol{x}_i \\in \\mathbb{R}^3$ and velocities $\\boldsymbol{v}_i = d\\boldsymbol{x}_i/da$, for $i = 1,\\dots,N$, at a fiducial initial scale factor $a_0$.\n- Use pairwise additive forces derived from a Plummer-softened Newtonian potential with softening length $\\varepsilon$, equal particle masses $m_i = 1/N$, and gravitational constant $G=1$. The force on particle $i$ is the sum over $j \\ne i$ of the contributions\n$$\n\\boldsymbol{a}_{ij} = - G m_j \\frac{\\boldsymbol{x}_i - \\boldsymbol{x}_j}{\\left(\\lVert \\boldsymbol{x}_i - \\boldsymbol{x}_j\\rVert^2 + \\varepsilon^2\\right)^{3/2}},\n$$\nso that the acceleration of particle $i$ is $\\boldsymbol{a}_i = \\sum_{j \\ne i} \\boldsymbol{a}_{ij}$.\n- Advance the system using the standard time-centered leapfrog integrator in kick-drift-kick (KDK) ordering with fixed step $\\Delta a$. You must evolve forward $N_{\\text{step}}$ steps from $(\\{\\boldsymbol{x}_i^{(0)}\\}, \\{\\boldsymbol{v}_i^{(0)}\\})$ to $(\\{\\boldsymbol{x}_i^{(f)}\\}, \\{\\boldsymbol{v}_i^{(f)}\\})$ using step $+\\Delta a$, and then evolve backward the same number of steps using step $-\\Delta a$ starting from $(\\{\\boldsymbol{x}_i^{(f)}\\}, \\{\\boldsymbol{v}_i^{(f)}\\})$, to obtain $(\\{\\boldsymbol{x}_i^{(b)}\\}, \\{\\boldsymbol{v}_i^{(b)}\\})$.\n- Measure the phase-space mismatch as a single scalar given by the root-mean-square norm\n$$\nE = \\sqrt{\\frac{1}{3N}\\sum_{i=1}^N \\left( \\lVert \\boldsymbol{x}_i^{(b)} - \\boldsymbol{x}_i^{(0)} \\rVert^2 + \\lVert \\boldsymbol{v}_i^{(b)} - \\boldsymbol{v}_i^{(0)} \\rVert^2 \\right)}.\n$$\nReport $E$ as a dimensionless decimal number.\n\nYou must repeat the experiment under two distinct floating-point precisions:\n- Binary $64$ (double precision).\n- Binary $128$ (quadruple precision). If true quadruple precision is not available on your platform, use the widest extended precision supported by your language and runtime as a stand-in for binary $128$.\n\nUse a randomized initial snapshot with a fixed seed so that the experiment is reproducible. Initialize positions $\\boldsymbol{x}_i$ by drawing each component from a uniform distribution on $[-1/2, 1/2]$ and velocities $\\boldsymbol{v}_i$ by drawing each component from a uniform distribution on $[-v_0, v_0]$, then subtract the center-of-mass velocity so that $\\sum_i \\boldsymbol{v}_i = \\boldsymbol{0}$. Use $v_0$ small enough to avoid excessively large displacements in a single step. Use Plummer softening with $\\varepsilon  0$ to prevent numerical singularities. All quantities are dimensionless.\n\nTest suite:\n- Fix the number of particles to $N = 12$, softening to $\\varepsilon = 10^{-3}$, and velocity scale to $v_0 = 5 \\times 10^{-2}$.\n- For each of the following $(N_{\\text{step}}, \\Delta a)$ pairs, perform the forward-backward experiment and compute the mismatch $E$ under both precisions:\n    - $(N_{\\text{step}}, \\Delta a) = (1, 10^{-3})$.\n    - $(N_{\\text{step}}, \\Delta a) = (50, 2 \\times 10^{-3})$.\n    - $(N_{\\text{step}}, \\Delta a) = (200, 5 \\times 10^{-4})$.\n    - $(N_{\\text{step}}, \\Delta a) = (500, 2 \\times 10^{-4})$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, one per test case, each inner list containing four numbers in the order $[N_{\\text{step}}, \\Delta a, E_{\\text{double}}, E_{\\text{extended}}]$, all as decimal numbers. For example, an output with two test cases should look like $[[n_1,\\Delta a_1,e_{1,d},e_{1,x}],[n_2,\\Delta a_2,e_{2,d},e_{2,x}]]$. The required output must be exactly one line, with no additional text.\n\nExpress all answers as dimensionless decimal numbers. Angles are not used. The outputs must be deterministic given the specified seed, and must adhere to the above format.",
            "solution": "We begin from Newton’s second law, which for particle $i$ reads $d^2 \\boldsymbol{x}_i / dt^2 = \\boldsymbol{a}_i(\\{\\boldsymbol{x}\\})$, where $\\boldsymbol{a}_i$ is determined by the sum of pairwise gravitational forces. In our experiment the independent variable is the scale factor $a$, and we define the velocity with respect to $a$ as $\\boldsymbol{v}_i = d\\boldsymbol{x}_i/da$. Treating $a$ as the evolution parameter and taking the force to be independent of $a$ isolates the effect of the discrete time-stepping and floating-point arithmetic on time-reversibility. The pairwise softened force for particles with equal masses $m_j = 1/N$ and $G=1$ is\n$$\n\\boldsymbol{a}_{ij} = - \\frac{1}{N} \\frac{\\boldsymbol{x}_i - \\boldsymbol{x}_j}{\\left(\\lVert \\boldsymbol{x}_i - \\boldsymbol{x}_j\\rVert^2 + \\varepsilon^2\\right)^{3/2}},\n$$\nso that $\\boldsymbol{a}_i = \\sum_{j \\ne i} \\boldsymbol{a}_{ij}$. The Plummer softening length $\\varepsilon$ prevents singular forces at small separations by replacing $r^{-3}$ with $(r^2 + \\varepsilon^2)^{-3/2}$, which is a commonly used, well-tested regularization in $N$-body calculations.\n\nWe discretize the evolution in the scale factor $a$ using the time-centered leapfrog scheme in kick-drift-kick (KDK) order. Let $\\Delta a$ be the fixed step. The scheme updates positions and velocities over one full step by first applying a half-kick to velocities using accelerations at the current positions, then drifting positions using the updated velocities over the full step, then applying a second half-kick using accelerations at the new positions. Denote the state at step index $n$ by $(\\{\\boldsymbol{x}_i^{(n)}\\}, \\{\\boldsymbol{v}_i^{(n)}\\})$. Although there are equivalent formulations with velocities staggered by half-steps, the KDK composition can be written as a symmetric map that is exactly time-reversible in exact arithmetic: composing the map at step $+\\Delta a$ with the map at step $-\\Delta a$ yields the identity map,\n$$\n\\mathcal{M}_{-\\Delta a} \\circ \\mathcal{M}_{+\\Delta a} = \\mathcal{I},\n$$\nbecause the sequence of sub-steps (half-kick, drift, half-kick) is symmetrically undone (half-kick with opposite sign, drift with opposite sign, half-kick with opposite sign). This symmetry follows from the separability of the Hamiltonian into kinetic and potential parts and underpins the symplectic and reversible nature of leapfrog.\n\nHowever, on a floating-point machine, arithmetic is rounded to a finite mantissa. In IEEE $754$ binary $64$ (double precision), the unit roundoff is approximately $u_{64} \\approx 2^{-53} \\approx 1.11 \\times 10^{-16}$, while in binary $128$ (quadruple precision) the unit roundoff is approximately $u_{128} \\approx 2^{-113} \\approx 9.63 \\times 10^{-35}$. Each floating-point addition and multiplication introduces a relative error of order the unit roundoff in exact arithmetic. Over $N_{\\text{step}}$ steps, the accumulation of roundoff errors behaves approximately as a random walk when errors are uncorrelated, leading to a root-mean-square growth with $\\sqrt{N_{\\text{step}}}$ in the number of roundoff events. Moreover, the magnitude of arithmetic operands (e.g., products $\\Delta a \\, \\boldsymbol{a}_i$) sets the scale of the absolute rounding. Consequently, we expect the measured phase-space mismatch $E$ after a forward-backward evolution to scale roughly like\n$$\nE \\sim C \\, \\sqrt{N_{\\text{step}}} \\, u \\, S(\\Delta a, \\{\\boldsymbol{x}\\}, \\{\\boldsymbol{v}\\}),\n$$\nwhere $C$ is a constant capturing the average number of rounding operations per step and $S$ is a scale derived from the state and step size. Importantly, $E$ reflects only floating-point non-invertibility of the map, not the truncation error of the leapfrog integrator, because the backward run uses the negative step $-\\Delta a$ and exactly the same discrete map, which would perfectly invert in exact arithmetic.\n\nAlgorithmic design for the experiment:\n1. Initialize a reproducible random snapshot with a fixed seed. Draw each component of the initial positions $\\boldsymbol{x}_i^{(0)}$ uniformly from $[-1/2, 1/2]$ and each component of the initial velocities $\\boldsymbol{v}_i^{(0)}$ uniformly from $[-v_0, v_0]$, then subtract the mean velocity so that $\\sum_i \\boldsymbol{v}_i^{(0)} = \\boldsymbol{0}$. Adopt $v_0 = 5 \\times 10^{-2}$ and softening $\\varepsilon = 10^{-3}$ in dimensionless code units.\n2. Implement an $O(N^2)$ vectorized computation of accelerations $\\boldsymbol{a}_i$ using the softened force law. For each pair $(i,j)$ with $i \\ne j$, accumulate $-(1/N) \\, \\boldsymbol{r}_{ij} / (r_{ij}^2 + \\varepsilon^2)^{3/2}$ with $\\boldsymbol{r}_{ij} = \\boldsymbol{x}_i - \\boldsymbol{x}_j$.\n3. Implement the KDK integrator with fixed step $\\Delta a$ as a composition of half-kick, drift, and half-kick, re-evaluating accelerations at the appropriate positions. To ensure exact compositional symmetry at the discrete level, implement the backward evolution by calling the same KDK routine with step $-\\Delta a$ starting from the forward-evolved state.\n4. For each test case $(N_{\\text{step}}, \\Delta a)$, run the forward-backward evolution under both precisions (binary $64$ and binary $128$ if available, or the widest extended precision), and compute the phase-space mismatch $E$ defined by\n$$\nE = \\sqrt{\\frac{1}{3N}\\sum_{i=1}^N \\left( \\lVert \\boldsymbol{x}_i^{(b)} - \\boldsymbol{x}_i^{(0)} \\rVert^2 + \\lVert \\boldsymbol{v}_i^{(b)} - \\boldsymbol{v}_i^{(0)} \\rVert^2 \\right)}.\n$$\n5. Aggregate the results for all test cases into the required single-line output format: a list of lists, each inner list containing $[N_{\\text{step}}, \\Delta a, E_{\\text{double}}, E_{\\text{extended}}]$.\n\nExpected qualitative behavior:\n- $E_{\\text{double}}$ should increase with $N_{\\text{step}}$ when the total number of arithmetic operations increases, approximately like $\\sqrt{N_{\\text{step}}}$, with a proportionality depending on $\\Delta a$ and the dynamical scales of the snapshot.\n- $E_{\\text{extended}}$ should be significantly smaller than $E_{\\text{double}}$ if the wider precision has a much smaller unit roundoff, though on some platforms the extended precision may be equal to double precision; in that case $E_{\\text{extended}} \\approx E_{\\text{double}}$.\n- For test cases with similar total evolution span $N_{\\text{step}} \\Delta a$ but different $N_{\\text{step}}$ and $\\Delta a$, the forward-backward mismatch is dominated by roundoff, not by truncation, so increasing $N_{\\text{step}}$ at fixed $N_{\\text{step}} \\Delta a$ should increase $E$.\n\nAll reported quantities are dimensionless decimals, and no angle units are used. The program’s output is fully determined by the specified seed and parameters.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_accelerations(x, mass, eps, dtype):\n    \"\"\"\n    Compute Plummer-softened gravitational accelerations for N particles in 3D.\n    x: (N,3) positions, dtype\n    mass: (N,) masses, dtype\n    eps: scalar softening, dtype\n    dtype: numpy dtype to use for computation\n    Returns: (N,3) accelerations, dtype\n    \"\"\"\n    # Ensure dtype\n    x = x.astype(dtype, copy=False)\n    mass = mass.astype(dtype, copy=False)\n    N = x.shape[0]\n    # Pairwise displacement r_ij = x_i - x_j\n    rij = x[:, None, :] - x[None, :, :]  # (N,N,3)\n    # Squared distances with softening\n    r2 = np.sum(rij * rij, axis=2) + dtype(eps) * dtype(eps)  # (N,N)\n    # Avoid self-interaction by setting diagonal to infinity so inv_r3 - 0\n    # Work on a copy to not modify original distances elsewhere\n    r2 = r2.copy()\n    # Set diagonal to infinity for safe invert\n    inf = np.array(np.inf, dtype=dtype)\n    idx = np.arange(N)\n    r2[idx, idx] = inf\n    # Compute inverse r^3: 1 / (r2 * sqrt(r2))\n    # Use dtype-aware operations\n    inv_r = 1.0 / np.sqrt(r2)\n    inv_r3 = inv_r * inv_r * inv_r  # (N,N)\n    # Weight by source masses m_j\n    w = inv_r3 * mass[None, :]  # (N,N)\n    # Acceleration: a_i = - sum_j w_ij * rij_ij\n    a = -np.sum(rij * w[:, :, None], axis=1)\n    return a\n\ndef leapfrog_kdk(x0, v0, mass, eps, nsteps, da, dtype):\n    \"\"\"\n    Kick-Drift-Kick leapfrog integrator for step da, nsteps steps.\n    x0, v0: (N,3) arrays, dtype\n    mass: (N,) array, dtype\n    eps: scalar softening, dtype\n    da: scalar step, dtype\n    dtype: numpy dtype\n    Returns: (xf, vf) after nsteps\n    \"\"\"\n    x = x0.astype(dtype, copy=True)\n    v = v0.astype(dtype, copy=True)\n    da = dtype(da)\n    half = dtype(0.5)\n    # Initial half-kick\n    a = compute_accelerations(x, mass, eps, dtype)\n    v += half * da * a\n    # Loop over steps\n    for i in range(nsteps):\n        # Drift\n        x += da * v\n        # Compute new accelerations at new positions\n        a = compute_accelerations(x, mass, eps, dtype)\n        # Full kick except last step which will be finished by the final half-kick\n        if i != nsteps - 1:\n            v += da * a\n    # Final half-kick\n    v += half * da * a\n    return x, v\n\ndef forward_backward_mismatch(x0_f64, v0_f64, masses_f64, eps, nsteps, da, dtype):\n    \"\"\"\n    Perform forward-backward integration and compute phase-space mismatch E.\n    Inputs in float64 for reproducibility of initial state; cast to dtype internally.\n    dtype: np.float64 or np.longdouble\n    Returns: mismatch E as Python float\n    \"\"\"\n    # Cast initial conditions to target dtype\n    x0 = x0_f64.astype(dtype, copy=True)\n    v0 = v0_f64.astype(dtype, copy=True)\n    masses = masses_f64.astype(dtype, copy=True)\n    # Forward integrate\n    xf, vf = leapfrog_kdk(x0, v0, masses, eps, nsteps, da, dtype)\n    # Backward integrate from forward state with negative step\n    xb, vb = leapfrog_kdk(xf, vf, masses, eps, nsteps, -da, dtype)\n    # Compute RMS phase-space mismatch\n    dx = xb - x0\n    dv = vb - v0\n    # Sum of squared differences over all components\n    num = np.sum(dx * dx) + np.sum(dv * dv)\n    denom = x0.size  # number of position components = 3N\n    E = np.sqrt(num / (denom))\n    # Convert to Python float for printing\n    return float(E)\n\ndef solve():\n    # Fixed random seed for reproducibility\n    rng = np.random.default_rng(seed=42)\n    # Problem parameters\n    N = 12\n    eps = 1e-3\n    v0 = 5e-2\n    # Initial positions and velocities in float64\n    x0 = rng.uniform(-0.5, 0.5, size=(N, 3)).astype(np.float64)\n    v0_arr = rng.uniform(-v0, v0, size=(N, 3)).astype(np.float64)\n    # Zero center-of-mass velocity\n    v0_arr -= np.mean(v0_arr, axis=0, keepdims=True)\n    masses = np.full(N, 1.0 / N, dtype=np.float64)\n    # Test suite: list of (N_steps, da)\n    test_cases = [\n        (1, 1e-3),\n        (50, 2e-3),\n        (200, 5e-4),\n        (500, 2e-4),\n    ]\n    results = []\n    for nsteps, da in test_cases:\n        # Double precision\n        E_double = forward_backward_mismatch(x0, v0_arr, masses, eps, nsteps, da, np.float64)\n        # Extended precision (longdouble)\n        E_ext = forward_backward_mismatch(x0, v0_arr, masses, eps, nsteps, da, np.longdouble)\n        results.append([nsteps, da, E_double, E_ext])\n    # Print in the exact required format: single line, list of lists\n    print(str(results).replace(\" \", \"\"))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}