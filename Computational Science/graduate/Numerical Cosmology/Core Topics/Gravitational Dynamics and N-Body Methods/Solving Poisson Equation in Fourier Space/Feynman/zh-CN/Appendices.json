{
    "hands_on_practices": [
        {
            "introduction": "掌握一种数值技术的第一步，是将其应用于一个已知精确解的案例。本练习将指导你构建一个粒子-网格（PM）求解器，并利用高斯密度分布——宇宙学结构建模中的一个基本构件——的解析解来验证该求解器。这个端到端的实践将巩固你对理论推导、代码实现和误差分析的理解。",
            "id": "3489960",
            "problem": "考虑在数值宇宙学中使用的亚视界、非相对论极限下，膨胀宇宙中的牛顿引力势。在共动坐标系中，该势满足一个泊松方程。从基本定律和核心定义出发：牛顿泊松方程、具有明确约定的三维傅里叶变换对以及球对称性。具体来说，使用以下被认为是经过充分检验的公式和事实的基本陈述：\n- 共动引力势的泊松方程为 $\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi G a^2 \\bar{\\rho}\\, \\delta(\\mathbf{x})$，其中 $G$ 是引力常数，$a$ 是尺度因子，$\\bar{\\rho}$ 是平均物质密度，$\\delta(\\mathbf{x})$ 是无量纲的超密度场。\n- 三维傅里叶变换的约定是 $\\tilde{f}(\\mathbf{k}) = \\int d^3x\\, f(\\mathbf{x})\\, e^{-i \\mathbf{k}\\cdot\\mathbf{x}}$，其逆变换为 $f(\\mathbf{x}) = \\frac{1}{(2\\pi)^3} \\int d^3k\\, \\tilde{f}(\\mathbf{k})\\, e^{i \\mathbf{k}\\cdot\\mathbf{x}}$。\n- 球对称性意味着对于任何球对称函数 $f(\\mathbf{x}) = f(r)$（其中 $r = \\|\\mathbf{x}\\|$），其傅里叶变换仅依赖于 $k = \\|\\mathbf{k}\\|$。\n\n给定一个球对称的高斯超密度 $\\delta(\\mathbf{x}) = \\delta_0 \\exp\\!\\left(-\\frac{r^2}{2\\sigma^2}\\right)$，其中 $\\delta_0$ 是一个常数振幅，$\\sigma$ 是一个常数宽度。您的任务是：\n- 使用所述的傅里叶变换约定和泊松方程，从第一性原理推导傅里叶空间势 $\\tilde{\\phi}(\\mathbf{k})$ 的解析表达式。除上述基本陈述外，不要使用任何捷径公式。\n- 利用球对称性和球坐标系下的泊松方程，为给定的高斯超密度推导由 $F_r(r) = -\\frac{d\\phi}{dr}$ 解析预测的实空间径向力分布 $F_r(r)$，并用初等函数和误差函数表示。推导必须从泊松方程的球坐标形式开始，并进行适当的积分。不要提供中间的捷径结果；请给出完整的推导过程。\n- 使用快速傅里叶变换 (FFT) 实现一个数值粒子-网格 (PM) 傅里叶空间求解器，在一个周期性立方体域上求解泊松方程，并以谱方法计算力场。快速傅里叶变换 (FFT) 被定义为傅里叶变换的离散对应物，它将空间样本映射到离散波数。粒子-网格 (PM) 是指在周期性边界条件下通过谱方法在网格上求解场。使用与上述连续变换一致的约定：离散波数为 $\\mathbf{k} = (k_x,k_y,k_z)$，其中 $k_i = 2\\pi n_i/L$，$n_i$ 是由离散 FFT 频率网格确定的整数，$L$ 是盒子的大小。\n\n所有量都必须使用代码单位：设 $G=1$、$a=1$ 和 $\\bar{\\rho}=1$，长度以任意单位度量，使得 $L$ 和 $\\sigma$ 单位相同，且 $\\delta_0$ 无量纲。在这些单位中，泊松方程变为 $\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi\\, \\delta(\\mathbf{x})$。\n\n数值求解器的算法要求：\n- 将边长为 $L$ 的立方体域离散到一个 $N\\times N\\times N$ 点的均匀网格上，网格间距为 $dx = L/N$。\n- 在以原点为中心的坐标的网格点上对 $\\delta(\\mathbf{x})$进行采样，即对于整数索引 $j$，$x_j = (j - N/2) dx$，$y_j = (j - N/2) dx$，$z_j = (j - N/2) dx$。\n- 用三维 FFT 计算 $\\tilde{\\delta}(\\mathbf{k})$。\n- 通过将 $\\tilde{\\delta}(\\mathbf{k})$ 乘以与泊松方程和所述变换约定一致的傅里叶空间格林函数来求解 $\\tilde{\\phi}(\\mathbf{k})$。通过设置 $\\tilde{\\phi}(\\mathbf{0})=0$ 来小心处理 $\\mathbf{k}=\\mathbf{0}$ 模式以避免除零错误，这固定了任意的势偏移且不影响力。\n- 通过 $\\tilde{F}_i(\\mathbf{k}) = -i k_i \\tilde{\\phi}(\\mathbf{k})$ 计算谱力分量，并对每个分量进行逆 FFT 以获得 $F_x(\\mathbf{x})$、$F_y(\\mathbf{x})$ 和 $F_z(\\mathbf{x})$。\n- 将力投影到径向方向以获得 $F_r(\\mathbf{x}) = \\frac{\\mathbf{F}(\\mathbf{x}) \\cdot \\mathbf{x}}{\\|\\mathbf{x}\\|}$（对于 $\\|\\mathbf{x}\\|>0$），并定义 $F_r(\\mathbf{0})=0$。\n\n精度比较协议：\n- 将数值 PM 力 $F_r^{\\text{PM}}(\\mathbf{x})$ 与先前推导的解析径向力 $F_r(r)$ 进行比较。\n- 将比较限制在 $r \\le L/4$ 的网格点上，以最小化周期性镜像污染，并从相对误差计算中排除 $r=0$ 点。\n- 将每个比较点的相对误差定义为 $\\epsilon(\\mathbf{x}) = \\frac{|F_r^{\\text{PM}}(\\mathbf{x}) - F_r^{\\text{analytic}}(r)|}{\\max(|F_r^{\\text{analytic}}(r)|, \\varepsilon)}$，其中 $\\varepsilon$ 是一个小的正阈值，根据最大解析力的大小进行缩放以防止除以接近零的数；在内部选择 $\\varepsilon$ 作为比较区域内最大 $|F_r^{\\text{analytic}}|$ 的一个固定分数。\n\n测试套件和要求的输出：\n- 使用以下参数集来测试不同的情况，包括一般情况、符号反转（欠密度）、宽分布和接近网格分辨率的宽度。每个测试用例是一个元组 $(N, L, \\sigma, \\delta_0)$：\n  1. $(N=64, L=1.0, \\sigma=0.05, \\delta_0=0.01)$。\n  2. $(N=64, L=1.0, \\sigma=0.05, \\delta_0=-0.01)$。\n  3. $(N=128, L=1.0, \\sigma=0.15, \\delta_0=0.02)$。\n  4. $(N=64, L=1.0, \\sigma=L/N, \\delta_0=0.01)$。\n- 对于每个测试用例，计算一个等于指定比较区域内最大相对误差的浮点数。以不带任何单位的小数形式表示此浮点数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其顺序与测试用例相同（例如，$ [r_1,r_2,r_3,r_4] $）。\n\n确保科学真实性：您的推导必须从所述的基本定义和定律开始，并且您的数值实现必须在周期性边界条件下一致地应用傅里叶空间方法。问题陈述中不允许超出这些基本陈述的任何中间捷径公式。所有数学实体，包括符号、变量、函数、算子和数字，都必须在本问题陈述中以美元符号括起来的 LaTeX 表示法书写。",
            "solution": "该问题要求针对给定的质量分布推导引力势和力的解析解，实现一个数值傅里叶空间粒子-网格 (PM) 求解器来计算相同的量，并比较结果以验证数值方法。分析在共动坐标系和代码单位（$G=1$，$a=1$，$\\bar{\\rho}=1$）下进行，此时奇特引力势 $\\phi$ 的泊松方程为 $\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi \\delta(\\mathbf{x})$。\n\n### 第1部分：傅里叶空间势 $\\tilde{\\phi}(\\mathbf{k})$ 的解析推导\n\n我们从指定单位下的泊松方程开始：\n$$ \\nabla^2 \\phi(\\mathbf{x}) = 4\\pi \\delta(\\mathbf{x}) $$\n为了在傅里叶空间中求解此方程，我们将三维傅里叶变换（定义为 $\\tilde{f}(\\mathbf{k}) = \\int d^3x\\, f(\\mathbf{x})\\, e^{-i \\mathbf{k}\\cdot\\mathbf{x}}$）应用于方程两边。\n\n拉普拉斯算子 $\\nabla^2$ 的傅里叶变换可以通过考虑其对平面波 $e^{i\\mathbf{k}\\cdot\\mathbf{x}}$ 的作用来找到。\n$$ \\nabla^2 e^{i\\mathbf{k}\\cdot\\mathbf{x}} = \\nabla \\cdot (i\\mathbf{k} e^{i\\mathbf{k}\\cdot\\mathbf{x}}) = i\\mathbf{k} \\cdot i\\mathbf{k} e^{i\\mathbf{k}\\cdot\\mathbf{x}} = -\\|\\mathbf{k}\\|^2 e^{i\\mathbf{k}\\cdot\\mathbf{x}} = -k^2 e^{i\\mathbf{k}\\cdot\\mathbf{x}} $$\n根据卷积定理，或更直接地使用傅里叶变换的导数性质，函数 $\\phi(\\mathbf{x})$ 的拉普拉斯变换是：\n$$ \\mathcal{F}[\\nabla^2 \\phi(\\mathbf{x})] = -k^2 \\tilde{\\phi}(\\mathbf{k}) $$\n将傅里叶变换应用于整个泊松方程得到：\n$$ -k^2 \\tilde{\\phi}(\\mathbf{k}) = 4\\pi \\tilde{\\delta}(\\mathbf{k}) $$\n求解 $k \\neq 0$ 时的傅里叶空间势 $\\tilde{\\phi}(\\mathbf{k})$ 得到：\n$$ \\tilde{\\phi}(\\mathbf{k}) = -\\frac{4\\pi}{k^2} \\tilde{\\delta}(\\mathbf{k}) $$\n接下来，我们必须求出给定的球对称高斯超密度 $\\delta(\\mathbf{x}) = \\delta_0 \\exp(-r^2 / (2\\sigma^2))$ 的傅里叶变换，其中 $r^2 = x^2+y^2+z^2$。\n$$ \\tilde{\\delta}(\\mathbf{k}) = \\int d^3x\\, \\delta_0 e^{-r^2/(2\\sigma^2)} e^{-i \\mathbf{k}\\cdot\\mathbf{x}} $$\n由于高斯函数和指数项在笛卡尔坐标系中的可分离性，三维积分变成了三个一维积分的乘积：\n$$ \\tilde{\\delta}(\\mathbf{k}) = \\delta_0 \\left( \\int_{-\\infty}^{\\infty} dx\\, e^{-x^2/(2\\sigma^2)} e^{-ik_x x} \\right) \\left( \\int_{-\\infty}^{\\infty} dy\\, e^{-y^2/(2\\sigma^2)} e^{-ik_y y} \\right) \\left( \\int_{-\\infty}^{\\infty} dz\\, e^{-z^2/(2\\sigma^2)} e^{-ik_z z} \\right) $$\n每个积分都是一个标准的高斯函数的傅里叶变换。对于一个通用的一维高斯函数 $e^{-ax^2}$，其变换为 $\\int_{-\\infty}^{\\infty} dx\\, e^{-ax^2} e^{-ikx} = \\sqrt{\\pi/a} e^{-k^2/(4a)}$。\n在我们的例子中，$a = 1/(2\\sigma^2)$，所以关于 $x$ 的积分是：\n$$ \\int_{-\\infty}^{\\infty} dx\\, e^{-x^2/(2\\sigma^2)} e^{-ik_x x} = \\sqrt{2\\pi\\sigma^2} e^{-k_x^2 \\sigma^2/2} $$\n将三个维度（$x$、$y$、$z$）的结果相乘得到：\n$$ \\tilde{\\delta}(\\mathbf{k}) = \\delta_0 (2\\pi\\sigma^2)^{3/2} e^{-(k_x^2+k_y^2+k_z^2)\\sigma^2/2} = \\delta_0 (2\\pi\\sigma^2)^{3/2} e^{-k^2\\sigma^2/2} $$\n将此结果代入 $\\tilde{\\phi}(\\mathbf{k})$ 的表达式，得到傅里叶空间势的最终解析表达式：\n$$ \\tilde{\\phi}(\\mathbf{k}) = -\\frac{4\\pi}{k^2} \\delta_0 (2\\pi\\sigma^2)^{3/2} e^{-k^2\\sigma^2/2} $$\n\n### 第2部分：实空间径向力 $F_r(r)$ 的解析推导\n\n对于球对称系统，泊松方程 $\\nabla^2\\phi = 4\\pi\\delta$ 得以简化。在球坐标系中，一个仅依赖于半径 $r$ 的函数 $\\phi(r)$ 的拉普拉斯算子是 $\\nabla^2 \\phi(r) = \\frac{1}{r^2} \\frac{d}{dr}\\left(r^2 \\frac{d\\phi}{dr}\\right)$。方程变为：\n$$ \\frac{1}{r^2} \\frac{d}{dr}\\left(r^2 \\frac{d\\phi}{dr}\\right) = 4\\pi \\delta(r) = 4\\pi \\delta_0 e^{-r^2/(2\\sigma^2)} $$\n我们可以对这个方程进行积分来求力。首先，乘以 $r^2$ 并从 $0$ 积分到半径 $r$：\n$$ \\int_0^r \\frac{d}{dr'}\\left(r'^2 \\frac{d\\phi}{dr'}\\right) dr' = \\int_0^r 4\\pi \\delta_0 r'^2 e^{-r'^2/(2\\sigma^2)} dr' $$\n左侧计算结果为 $r^2 \\frac{d\\phi}{dr}$（假设引力场 $-\\frac{d\\phi}{dr}$ 在 $r=0$ 处是有限的）。\n径向力定义为 $F_r(r) = -\\frac{d\\phi}{dr}$。因此，我们可以写出：\n$$ -r^2 F_r(r) = 4\\pi \\delta_0 \\int_0^r r'^2 e^{-r'^2/(2\\sigma^2)} dr' $$\n$$ F_r(r) = -\\frac{4\\pi \\delta_0}{r^2} \\int_0^r r'^2 e^{-r'^2/(2\\sigma^2)} dr' $$\n剩下的任务是计算这个积分。这可以通过分部积分法完成，$\\int u dv = uv - \\int v du$。\n设 $u=r'$ 和 $dv = r' e^{-r'^2/(2\\sigma^2)} dr'$。那么 $du=dr'$ 且 $v = -\\sigma^2 e^{-r'^2/(2\\sigma^2)}$。\n\\begin{align*}\n\\int_0^r r'^2 e^{-r'^2/(2\\sigma^2)} dr' = \\left[ -r' \\sigma^2 e^{-r'^2/(2\\sigma^2)} \\right]_0^r - \\int_0^r (-\\sigma^2 e^{-r'^2/(2\\sigma^2)}) dr' \\\\\n= -r \\sigma^2 e^{-r^2/(2\\sigma^2)} + \\sigma^2 \\int_0^r e^{-r'^2/(2\\sigma^2)} dr'\n\\end{align*}\n积分 $\\int_0^r e^{-r'^2/(2\\sigma^2)} dr'$ 与误差函数相关，$\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}}\\int_0^z e^{-t^2} dt$。\n设 $t = r'/(\\sqrt{2}\\sigma)$，则 $r' = \\sqrt{2}\\sigma t$ 且 $dr' = \\sqrt{2}\\sigma dt$。积分上限变为 $r/(\\sqrt{2}\\sigma)$。\n$$ \\int_0^r e^{-r'^2/(2\\sigma^2)} dr' = \\int_0^{r/(\\sqrt{2}\\sigma)} e^{-t^2} (\\sqrt{2}\\sigma dt) = \\sqrt{2}\\sigma \\frac{\\sqrt{\\pi}}{2} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) = \\sigma \\sqrt{\\frac{\\pi}{2}} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) $$\n将此代回，完整的积分为：\n$$ \\int_0^r r'^2 e^{-r'^2/(2\\sigma^2)} dr' = \\sigma^3 \\sqrt{\\frac{\\pi}{2}} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) - r \\sigma^2 e^{-r^2/(2\\sigma^2)} $$\n最后，将此代入 $F_r(r)$ 的表达式中：\n$$ F_r(r) = -\\frac{4\\pi \\delta_0}{r^2} \\left[ \\sigma^3 \\sqrt{\\frac{\\pi}{2}} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) - r \\sigma^2 e^{-r^2/(2\\sigma^2)} \\right] $$\n$$ F_r(r) = -4\\pi \\delta_0 \\left[ \\frac{\\sigma^3}{r^2} \\sqrt{\\frac{\\pi}{2}} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) - \\frac{\\sigma^2}{r} e^{-r^2/(2\\sigma^2)} \\right] $$\n这是径向力的解析表达式。注意当 $r \\to 0$ 时，$F_r(r) \\to -\\frac{4\\pi\\delta_0}{3}r \\to 0$。\n\n### 第3部分：数值方法（粒子-网格求解器）\n\n数值解是使用谱粒子-网格 (PM) 方法在周期性立方网格上找到的。算法流程如下：\n\n1.  **网格离散化**：将边长为 $L$ 的域离散化为 $N \\times N \\times N$ 的网格。网格间距为 $dx=L/N$。我们定义一个中心化坐标的网格 $(x_i, y_j, z_k)$，其中对于 $i \\in \\{0, \\dots, N-1\\}$，$x_i = (i - N/2)dx$，对于 $y$ 和 $z$ 也类似。\n\n2.  **密度场**：在每个网格点上对连续高斯超密度 $\\delta(\\mathbf{x})$进行采样，以创建离散密度场 $\\delta_{ijk} = \\delta(x_i, y_j, z_k)$。\n\n3.  **正向傅里叶变换**：使用快速傅里叶变换 (FFT) 将离散密度场变换到傅里叶空间：$\\tilde{\\delta}_{\\mathbf{k}} = \\mathcal{F}[\\delta_{ijk}]$。\n\n4.  **在傅里叶空间中求解**：使用泊松方程在傅里叶空间中的代数形式。离散波数由 $k_i = 2\\pi n_i/L$ 给出，其中 $n_i$ 是由 FFT 算法提供的整数频率。我们构建一个波数向量 $\\mathbf{k}$ 及其模平方 $k^2 = k_x^2+k_y^2+k_z^2$ 的网格。然后计算傅里叶空间势：\n    $$ \\tilde{\\phi}_{\\mathbf{k}} = -\\frac{4\\pi}{k^2} \\tilde{\\delta}_{\\mathbf{k}} $$\n    $\\mathbf{k}=\\mathbf{0}$ ($k^2=0$) 模式对应于平均势。通过手动设置 $\\tilde{\\phi}(\\mathbf{0}) = 0$ 来避免除零错误。这将平均势设置为零，不影响力的计算，因为力取决于势的梯度。\n\n5.  **谱力计算**：使用谱导数性质 $\\mathcal{F}[-\\nabla\\phi] = -i\\mathbf{k}\\tilde{\\phi}(\\mathbf{k})$，在傅里叶空间中计算力分量 $\\mathbf{F} = -\\nabla\\phi$：\n    $$ \\tilde{F}_{x,\\mathbf{k}} = -i k_x \\tilde{\\phi}_{\\mathbf{k}}, \\quad \\tilde{F}_{y,\\mathbf{k}} = -i k_y \\tilde{\\phi}_{\\mathbf{k}}, \\quad \\tilde{F}_{z,\\mathbf{k}} = -i k_z \\tilde{\\phi}_{\\mathbf{k}} $$\n\n6.  **逆傅里叶变换**：通过对其傅里叶空间对应物应用逆 FFT，恢复实空间中的力分量 $F_x, F_y, F_z$。对于实数输入场，得到的力场必须是实数；任何小的虚部都是由数值浮点误差引起的，应被丢弃。\n\n7.  **径向力投影**：通过将矢量力场 $\\mathbf{F}(\\mathbf{x})$ 投影到径向方向向量 $\\mathbf{x}$ 上，计算每个网格点 $(\\mathbf{x})$ 处的最终数值径向力：\n    $$ F_r^{\\text{PM}}(\\mathbf{x}) = \\frac{\\mathbf{F}(\\mathbf{x}) \\cdot \\mathbf{x}}{\\|\\mathbf{x}\\|} \\quad \\text{for } \\|\\mathbf{x}\\|>0, \\quad \\text{and } F_r^{\\text{PM}}(\\mathbf{0})=0 $$\n\n### 第4部分：比较与误差度量\n\n通过将其输出 $F_r^{\\text{PM}}(\\mathbf{x})$ 与在相同网格点上求值的解析解 $F_r^{\\text{analytic}}(r)$ 进行比较，来评估数值 PM 求解器的准确性。比较范围被限制在盒子的内部区域 $r \\le L/4$，以最小化基于 FFT 方法固有的周期性镜像污染。$r=0$ 点被排除在外。每个点上的相对误差 $\\epsilon(\\mathbf{x})$ 计算如下：\n$$ \\epsilon(\\mathbf{x}) = \\frac{|F_r^{\\text{PM}}(\\mathbf{x}) - F_r^{\\text{analytic}}(r)|}{\\max(|F_r^{\\text{analytic}}(r)|, \\varepsilon)} $$\n其中 $\\varepsilon$ 是一个小的正则化常数，选择为最大解析力大小的一个分数，以防止在解析力接近零的地方除以小数。每个测试用例最终报告的度量是在比较区域内发现的最大相对误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    def solve_poisson_pm(N, L, sigma, delta_0):\n        \"\"\"\n        Solves the Poisson equation for a Gaussian density profile using a PM method\n        and compares the resulting force field to the analytical solution.\n    \n        Args:\n            N (int): Number of grid points per dimension.\n            L (float): Side length of the cubic domain.\n            sigma (float): Width of the Gaussian overdensity.\n            delta_0 (float): Amplitude of the Gaussian overdensity.\n    \n        Returns:\n            float: The maximum relative error between numerical and analytical force.\n        \"\"\"\n        # 1. Grid and Coordinate Setup\n        dx = L / N\n        # Create coordinates centered at the origin, as specified in the problem.\n        coords = (np.arange(N) - N / 2) * dx\n        xx, yy, zz = np.meshgrid(coords, coords, coords, indexing='ij')\n        r = np.sqrt(xx**2 + yy**2 + zz**2)\n    \n        # 2. Sample Density Field\n        delta_grid = delta_0 * np.exp(-r**2 / (2 * sigma**2))\n    \n        # 3. Fourier-space solution\n        # 3a. Wavenumbers (k-vectors)\n        k_vals = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n        kx, ky, kz = np.meshgrid(k_vals, k_vals, k_vals, indexing='ij')\n        k_squared = kx**2 + ky**2 + kz**2\n    \n        # Avoid division by zero for the k=0 mode.\n        # The value is arbitrary as phi_k[0,0,0] will be set to 0 later.\n        if N > 0:\n            k_squared[0, 0, 0] = 1.0\n    \n        # 3b. FFT of density\n        delta_k = np.fft.fftn(delta_grid)\n    \n        # 3c. Solve for potential in k-space: phi_k = -4 * pi * delta_k / k^2\n        phi_k = -4 * np.pi * delta_k / k_squared\n        \n        # 3d. Set DC mode of potential to zero (fixes arbitrary offset)\n        if N > 0:\n            phi_k[0, 0, 0] = 0.0\n    \n        # 4. Compute Force Field\n        # 4a. Force components in k-space: F_i = -i * k_i * phi\n        Fx_k = -1j * kx * phi_k\n        Fy_k = -1j * ky * phi_k\n        Fz_k = -1j * kz * phi_k\n    \n        # 4b. Inverse FFT to get real-space force components\n        # The result of ifftn should be real; take the real part to discard\n        # machine-precision imaginary noise.\n        Fx = np.fft.ifftn(Fx_k).real\n        Fy = np.fft.ifftn(Fy_k).real\n        Fz = np.fft.ifftn(Fz_k).real\n    \n        # 5. Compute Numerical Radial Force\n        # F_r = (F . r) / |r|. Use np.divide to handle r=0 safely.\n        Fr_pm = np.divide(Fx * xx + Fy * yy + Fz * zz, r, out=np.zeros_like(r), where=(r != 0))\n    \n        # 6. Compute Analytical Radial Force\n        # The limit of F_r(r) as r->0 is 0. Handle r=0 separately.\n        Fr_analytic = np.zeros_like(r)\n        non_zero_r_mask = r > 0\n        r_nz = r[non_zero_r_mask]\n    \n        term1 = (sigma**3 / r_nz**2) * np.sqrt(np.pi / 2.0) * erf(r_nz / (np.sqrt(2.0) * sigma))\n        term2 = (sigma**2 / r_nz) * np.exp(-r_nz**2 / (2.0 * sigma**2))\n        \n        Fr_analytic[non_zero_r_mask] = -4.0 * np.pi * delta_0 * (term1 - term2)\n    \n        # 7. Compare and Compute Maximum Relative Error\n        # Define comparison region: r = L/4 and r > 0\n        mask = (r = L / 4)  (r > 0)\n        \n        if not np.any(mask):\n            return 0.0  # No points in comparison region\n    \n        # Calculate the small threshold epsilon to regularize division\n        analytic_force_in_mask = np.abs(Fr_analytic[mask])\n        if analytic_force_in_mask.size == 0:\n             return 0.0\n        \n        max_abs_analytic_force = np.max(analytic_force_in_mask)\n\n        # Handle case where force is zero everywhere (e.g. delta_0 = 0)\n        if max_abs_analytic_force == 0:\n            # If PM force is also zero, error is 0. Otherwise it's infinite.\n            # We expect PM force to be near zero.\n            return np.max(np.abs(Fr_pm[mask]))\n\n        epsilon_threshold = max_abs_analytic_force * 1e-9\n    \n        # Compute relative error\n        numerator = np.abs(Fr_pm[mask] - Fr_analytic[mask])\n        denominator = np.maximum(analytic_force_in_mask, epsilon_threshold)\n        \n        relative_error = numerator / denominator\n        max_relative_error = np.max(relative_error)\n        \n        return max_relative_error\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, sigma, delta_0)\n        (64, 1.0, 0.05, 0.01),      # General case\n        (64, 1.0, 0.05, -0.01),     # Underdensity\n        (128, 1.0, 0.15, 0.02),     # Broad profile\n        (64, 1.0, 1.0 / 64, 0.01),  # Near-grid-resolution width\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, sigma, delta_0 = case\n        error = solve_poisson_pm(N, L, sigma, delta_0)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "既然我们已经有了一个可以计算谱方法引力场的求解器，一个关键问题随之而来：为什么不直接计算引力势，然后用简单的有限差分法来求引力场呢？本练习将直接比较谱方法计算的梯度与有限差分梯度，量化它们之间的差异，并揭示谱方法在精度上的优越性，尤其是在处理高频模式时。",
            "id": "3490043",
            "problem": "您需要在一个周期性立方晶格上，评估从密度对比度场 $\\delta(\\mathbf{x})$ 计算引力加速度场 $\\mathbf{g}(\\mathbf{x})$ 的两种数值上不同但解析上等价的路径之间的一致性。该计算遵循协动、无量纲单位下的牛顿泊松方程。控制方程为泊松方程\n$$\n\\nabla^2 \\Phi(\\mathbf{x}) \\;=\\; \\delta(\\mathbf{x}),\n$$\n该方程定义在边长为 $L$ 的周期性区域上，其中 $\\Phi(\\mathbf{x})$ 是引力势，$\\mathbf{g}(\\mathbf{x}) = -\\nabla \\Phi(\\mathbf{x})$ 是引力加速度。假设 $\\int \\delta(\\mathbf{x})\\,d^3x = 0$，因此势的零模被设为零。所有量都是无量纲和无单位的。角度以弧度为单位。\n\n您将在一个具有 $N \\times N \\times N$ 个节点和周期性边界条件的均匀网格上实现这两种路径：\n\n- 路径 A（谱方法梯度）：使用离散傅里叶变换 (DFT) 在傅里叶空间中求解泊松方程。如果 $\\tilde{f}(\\mathbf{k})$ 表示 $f(\\mathbf{x})$ 的 DFT，并且 $\\mathbf{k}=(k_x,k_y,k_z)$ 是与 DFT 频率指数相关的角波矢，则非零模式的解为\n$$\n\\tilde{\\Phi}(\\mathbf{k}) \\;=\\; -\\,\\frac{\\tilde{\\delta}(\\mathbf{k})}{k_x^2 + k_y^2 + k_z^2}.\n$$\n设置 $\\tilde{\\Phi}(\\mathbf{0})=0$。然后通过谱方法梯度的逆 DFT 计算引力加速度：\n$$\n\\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\;=\\; \\mathcal{F}^{-1}\\!\\left[ -\\,i\\,\\mathbf{k}\\,\\tilde{\\Phi}(\\mathbf{k}) \\right].\n$$\n\n- 路径 B（有限差分梯度）：使用与上述相同的 $\\tilde{\\Phi}(\\mathbf{k})$，通过逆 DFT 计算 $\\Phi(\\mathbf{x})$，然后使用具有周期性边界的二阶精度中心有限差分来近似梯度。网格间距为 $\\Delta x = L/N$，单位向量为 $\\hat{e}_j$，分量 $j \\in \\{x,y,z\\}$ 为\n$$\ng_{\\mathrm{fd},j}(\\mathbf{x}) \\;=\\; -\\,\\frac{ \\Phi(\\mathbf{x}+\\Delta x\\,\\hat{e}_j) \\;-\\; \\Phi(\\mathbf{x}-\\Delta x\\,\\hat{e}_j) }{ 2\\,\\Delta x }.\n$$\n\n通过相对均方根范数量化两种路径之间的差异\n$$\n\\varepsilon \\;=\\; \\frac{ \\left\\langle \\| \\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) - \\mathbf{g}_{\\mathrm{fd}}(\\mathbf{x}) \\|^2 \\right\\rangle^{1/2} }{ \\left\\langle \\| \\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\|^2 \\right\\rangle^{1/2} },\n$$\n其中 $\\langle \\cdot \\rangle$ 表示对所有网格点的平均，$\\|\\cdot\\|$ 是分量空间中的欧几里得范数。\n\n使用与酉逆 DFT 归一化一致的标准 DFT 频率到波数映射。如果 $\\nu$ 表示单位长度内的循环频率（周期数/单位长度），则角波数为 $k = 2\\pi \\nu$。在 DFT 网格上构建 $\\mathbf{k}$ 时，请严格使用此映射，并注意零模。\n\n您的程序必须实现以下测试套件，为每个案例构建 $\\delta(\\mathbf{x})$，计算 $\\varepsilon$，并报告结果。所有场都位于网格节点上，其位置为 $x_j = j\\,\\Delta x$, $y_j = j\\,\\Delta x$, $z_j = j\\,\\Delta x$，其中 $j \\in \\{0,\\dots,N-1\\}$。\n\n测试套件：\n\n- 案例 $1$（单个低频平面波）：$N=32$, $L=1$, $\\delta(\\mathbf{x}) = \\cos\\big(2\\pi\\,(x + 2y + 3z)\\big)$。\n\n- 案例 $2$（带相位的各向异性模式之和）：$N=48$, $L=1$,\n$$\n\\delta(\\mathbf{x}) \\;=\\; \\sum_{m=1}^{4} A_m \\cos\\!\\Big(2\\pi\\,(\\mathbf{n}_m \\cdot \\mathbf{x}) + \\varphi_m\\Big),\n$$\n其中振幅 $A_1=0.5$, $A_2=0.7$, $A_3=0.9$, $A_4=0.4$，整数向量 $\\mathbf{n}_1=(3,0,0)$, $\\mathbf{n}_2=(0,5,0)$, $\\mathbf{n}_3=(0,0,7)$, $\\mathbf{n}_4=(2,3,1)$，以及相位 $\\varphi_1=0.1$, $\\varphi_2=-0.3$, $\\varphi_3=0.5$, $\\varphi_4=1.1$。\n\n- 案例 $3$（沿一个轴接近奈奎斯特频率）：$N=32$, $L=1$, $\\delta(\\mathbf{x}) = \\cos\\big(2\\pi\\,(15x)\\big)$。\n\n- 案例 $4$（离轴高各向异性）：$N=64$, $L=1$, $\\delta(\\mathbf{x}) = \\cos\\big(2\\pi\\,(30y + z)\\big)$。\n\n实现约束和输出规范：\n\n- 使用离散傅里叶变换，该变换与快速傅里叶变换 (FFT) 对一致，其逆变换通过 $1/N^3$ 进行归一化，以便 Parseval 定理在标准数值因子下成立。使用 $k=2\\pi \\nu$ 从 DFT 频率构建 $\\mathbf{k}$。\n\n- 对于每个案例，计算如上定义的 $\\varepsilon$。您的程序应生成单行输出，其中包含四个结果，格式为方括号内的逗号分隔列表，每个浮点数四舍五入到8位小数，并以十进制表示法（而非科学记数法）表示，按案例1到4的顺序排列。例如：$\\big[0.00001234,0.05670000,0.12340000,0.98765000\\big]$。\n\n- 无需用户输入。程序必须是确定性的。\n\n- 所有量都是无量纲的，因此无需报告物理单位。",
            "solution": "我们从边长为 $L$ 的周期性区域上的无量纲化单位下的牛顿泊松方程开始：\n$$\n\\nabla^2 \\Phi(\\mathbf{x}) \\;=\\; \\delta(\\mathbf{x}),\n$$\n并定义引力加速度为 $\\mathbf{g}(\\mathbf{x}) = -\\nabla \\Phi(\\mathbf{x})$。在周期性区域上，在傅里叶空间中工作很方便。用 $\\mathcal{F}$ 表示离散傅里叶变换 (DFT)，用 $\\mathcal{F}^{-1}$ 表示其逆变换。设 $\\tilde{f}(\\mathbf{k})$ 为 $f(\\mathbf{x})$ 的 DFT，其中傅里叶空间网格标签 $\\mathbf{k}=(k_x,k_y,k_z)$ 是通过 $k=2\\pi \\nu$ 从 DFT 循环频率 $\\nu$ 构建的。DFT 的导数性质与连续情况下的性质类似：$\\mathcal{F}\\!\\left[\\partial_j f\\right]= i k_j \\tilde{f}$ 和 $\\mathcal{F}\\!\\left[\\nabla^2 f\\right]= - (k_x^2+k_y^2+k_z^2)\\,\\tilde{f}$。因此，对于所有非零波矢，\n$$\n\\tilde{\\Phi}(\\mathbf{k}) \\;=\\; -\\frac{\\tilde{\\delta}(\\mathbf{k})}{k_x^2 + k_y^2 + k_z^2}, \\quad \\tilde{\\Phi}(\\mathbf{0}) = 0,\n$$\n谱方法梯度的加速度为\n$$\n\\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\;=\\; \\mathcal{F}^{-1}\\!\\left[ -\\,i\\,\\mathbf{k}\\,\\tilde{\\Phi}(\\mathbf{k}) \\right].\n$$\n对于在网格上表示的模式，该路径在谱方法上是精确的，误差仅来自浮点舍入。\n\n或者，我们通过 $\\Phi(\\mathbf{x})=\\mathcal{F}^{-1}[\\tilde{\\Phi}(\\mathbf{k})]$ 在实空间中计算势，并使用具有周期性边界条件的中心有限差分算子来近似梯度，\n$$\n\\left(\\nabla \\Phi\\right)_j(\\mathbf{x}) \\;\\approx\\; \\frac{\\Phi(\\mathbf{x}+\\Delta x\\,\\hat{e}_j) - \\Phi(\\mathbf{x}-\\Delta x\\,\\hat{e}_j)}{2\\,\\Delta x}, \\qquad \\Delta x = \\frac{L}{N}.\n$$\n因此，\n$$\n\\mathbf{g}_{\\mathrm{fd}}(\\mathbf{x}) \\;=\\; -\\,\\left( D_x \\Phi(\\mathbf{x}),\\, D_y \\Phi(\\mathbf{x}),\\, D_z \\Phi(\\mathbf{x}) \\right),\n$$\n每个分量都通过中心差分格式计算。中心有限差分是导数的二阶精度近似，因此对于足够平滑的场，局部截断误差的尺度为 $\\mathcal{O}(\\Delta x^2)$。然而，有限差分导数的离散色散不同于谱方法导数，这引入了一个依赖于波数的确定性差异。\n\n为了量化这种差异，我们使用相对均方根 (RMS) 范数\n$$\n\\varepsilon \\;=\\; \\frac{ \\left\\langle \\| \\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) - \\mathbf{g}_{\\mathrm{fd}}(\\mathbf{x}) \\|^2 \\right\\rangle^{1/2} }{ \\left\\langle \\| \\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\|^2 \\right\\rangle^{1/2} }.\n$$\n这个无量纲度量在 $\\delta(\\mathbf{x})$ 的均匀缩放下是不变的，并直接比较了这两种路径。\n\n为了获得解析上的洞察，考虑单个平面波密度场 $\\delta(\\mathbf{x})=\\cos(\\mathbf{k}_0\\cdot\\mathbf{x})$，其中 $\\mathbf{k}_0=(k_{0x},k_{0y},k_{0z})$ 等于一个网格可分辨的角波矢向量。势为 $\\Phi(\\mathbf{x})=-\\cos(\\mathbf{k}_0\\cdot\\mathbf{x})/\\|\\mathbf{k}_0\\|^2$。谱方法梯度为\n$$\n\\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\;=\\; -\\,\\nabla \\Phi(\\mathbf{x}) \\;=\\; -\\,\\frac{\\mathbf{k}_0}{\\|\\mathbf{k}_0\\|^2}\\,\\sin(\\mathbf{k}_0\\cdot\\mathbf{x}).\n$$\n应用于平面波的沿分量 $j$ 的中心有限差分导数引入了符号 $\\frac{\\sin(k_{0j}\\Delta x)}{\\Delta x}$ 来代替谱方法因子 $k_{0j}$。因此，\n$$\ng_{\\mathrm{fd},j}(\\mathbf{x}) \\;=\\; -\\,\\frac{\\sin(k_{0j}\\Delta x)}{\\Delta x\\,\\|\\mathbf{k}_0\\|^2}\\,\\sin(\\mathbf{k}_0\\cdot\\mathbf{x})\n\\;=\\; \\left(\\frac{\\sin(k_{0j}\\Delta x)}{k_{0j}\\Delta x}\\right)\\,g_{\\mathrm{spec},j}(\\mathbf{x}),\n$$\n约定如果 $k_{0j}=0$，则该因子等于 $1$。因此，对于每个分量，\n$$\n\\frac{g_{\\mathrm{fd},j}}{g_{\\mathrm{spec},j}} \\;=\\; \\operatorname{sinc}\\!\\left(\\frac{k_{0j}\\Delta x}{\\pi}\\right) \\;=\\; \\frac{\\sin(k_{0j}\\Delta x)}{k_{0j}\\Delta x},\n$$\nRMS 中的向量差异通过这些分量因子取决于 $\\mathbf{k}_0$ 的方向。对于小的 $\\| \\mathbf{k}_0\\|\\Delta x$，泰勒级数 $\\sin(\\xi)/\\xi = 1 - \\xi^2/6 + \\mathcal{O}(\\xi^4)$ 表明相对误差的尺度为 $\\mathcal{O}(\\Delta x^2)$。接近奈奎斯特波数时，$k\\Delta x \\to \\pi$，该比率接近 $0$，差异接近单位量级。\n\n每个测试案例的算法设计：\n\n- 构建间距为 $\\Delta x = L/N$ 且节点坐标为 $x_j=j\\Delta x$, $y_j=j\\Delta x$, $z_j=j\\Delta x$（其中 $j\\in\\{0,\\dots,N-1\\}$）的 $N \\times N \\times N$ 网格。\n\n- 根据案例定义构建 $\\delta(\\mathbf{x})$。对于整数模式向量 $\\mathbf{n}$，角波数为 $\\mathbf{k}_0 = 2\\pi\\,\\mathbf{n}/L$，因此 $\\delta(\\mathbf{x})=\\cos(\\mathbf{k}_0\\cdot\\mathbf{x}+\\varphi)$。\n\n- 通过 DFT 计算 $\\tilde{\\delta}(\\mathbf{k})$。从 DFT 循环频率 $\\nu$（沿每个轴由 $k=2\\pi\\nu$ 映射）构建数组 $k_x$, $k_y$, $k_z$，并将它们广播到三维傅里叶网格。\n\n- 对于所有非零波矢，计算 $\\tilde{\\Phi}(\\mathbf{k}) = -\\tilde{\\delta}(\\mathbf{k})/(k_x^2+k_y^2+k_z^2)$，并将零模设置为零。在实践中，将零指数处的分母设置为 $+\\infty$，以便除法结果为零。\n\n- 路径 A：通过对 $ -i\\,k_j\\,\\tilde{\\Phi}(\\mathbf{k})$ 的每个分量进行逆变换来计算 $\\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x})$。\n\n- 路径 B：通过对 $\\tilde{\\Phi}(\\mathbf{k})$ 进行逆 DFT 计算 $\\Phi(\\mathbf{x})$，然后使用周期性移位计算中心有限差分以获得 $\\mathbf{g}_{\\mathrm{fd}}(\\mathbf{x})=-\\nabla \\Phi(\\mathbf{x})$。\n\n- 计算 $\\varepsilon$，即上面定义的 RMS 范数之比。分子是差分向量 $\\mathbf{g}_{\\mathrm{spec}}-\\mathbf{g}_{\\mathrm{fd}}$ 的欧几里得范数平方在所有网格节点上的平均值的平方根，分母是 $\\mathbf{g}_{\\mathrm{spec}}$ 的 RMS 范数。\n\n测试套件涵盖了几个机制：一个低频各向异性模式，其中 $\\varepsilon$ 应该很小且尺度为 $\\mathcal{O}(\\Delta x^2)$；一个带相位的模式和，用于测试线性叠加和各向异性；一个接近奈奎斯特频率的模式，其中中心有限差分导数相对于谱方法导数被强烈衰减，导致大的 $\\varepsilon$；以及一个离轴高各向异性情况，其中不同分量经历不同的离散符号。程序实现此流程并按要求顺序打印四个 $\\varepsilon$ 值，每个值四舍五入到 $8$ 位小数，作为一个用方括号括起来的逗号分隔列表。",
            "answer": "```python\nimport numpy as np\n\ndef construct_k_arrays(N, L):\n    # Construct angular wavenumbers k = 2*pi*nu for each axis using DFT frequencies.\n    dx = L / N\n    # np.fft.fftfreq returns frequencies in cycles per unit length; d=dx ensures correct scaling.\n    freq = np.fft.fftfreq(N, d=dx)  # cycles per unit length\n    k1d = 2.0 * np.pi * freq        # angular wavenumbers\n    kx = k1d[:, None, None]\n    ky = k1d[None, :, None]\n    kz = k1d[None, None, :]\n    return kx, ky, kz\n\ndef spectral_poisson_phi(delta, L):\n    N = delta.shape[0]\n    # Forward FFT to Fourier space\n    delta_k = np.fft.fftn(delta)\n    # Construct k arrays\n    kx, ky, kz = construct_k_arrays(N, L)\n    k2 = kx**2 + ky**2 + kz**2\n    # Avoid division by zero at the zero mode by setting denominator to inf there\n    k2_safe = k2.copy()\n    k2_safe[0, 0, 0] = np.inf\n    phi_k = - delta_k / k2_safe\n    return phi_k, (kx, ky, kz)\n\ndef spectral_gradient_from_phi_k(phi_k, k_arrays):\n    kx, ky, kz = k_arrays\n    # Compute spectral gradient components and inverse FFT to real space\n    gx = np.fft.ifftn(-1j * kx * phi_k).real\n    gy = np.fft.ifftn(-1j * ky * phi_k).real\n    gz = np.fft.ifftn(-1j * kz * phi_k).real\n    return gx, gy, gz\n\ndef finite_difference_gradient_from_phi(phi, L):\n    N = phi.shape[0]\n    dx = L / N\n    # Centered differences with periodic boundaries\n    dphidx = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2.0 * dx)\n    dphidy = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * dx)\n    dphidz = (np.roll(phi, -1, axis=2) - np.roll(phi, 1, axis=2)) / (2.0 * dx)\n    # Acceleration g = -grad Phi\n    gx = -dphidx\n    gy = -dphidy\n    gz = -dphidz\n    return gx, gy, gz\n\ndef relative_rms_error(g_spec, g_fd):\n    gx_s, gy_s, gz_s = g_spec\n    gx_f, gy_f, gz_f = g_fd\n    # Compute RMS norms\n    diff_sq = (gx_s - gx_f)**2 + (gy_s - gy_f)**2 + (gz_s - gz_f)**2\n    spec_sq = gx_s**2 + gy_s**2 + gz_s**2\n    # Avoid division by zero in pathological cases by adding tiny epsilon, though spec_sq should be >0 for nontrivial fields\n    num = np.sqrt(np.mean(diff_sq))\n    den = np.sqrt(np.mean(spec_sq))\n    # If den is zero (shouldn't happen with our test cases), define error as 0.0 to keep determinism\n    if den == 0.0:\n        return 0.0\n    return float(num / den)\n\ndef build_delta_case(case_id):\n    # Returns N, L, delta(x)\n    if case_id == 1:\n        N, L = 32, 1.0\n        # delta = cos(2*pi*(1*x + 2*y + 3*z))\n        x = np.arange(N) * (L / N)\n        X, Y, Z = np.meshgrid(x, x, x, indexing='ij')\n        delta = np.cos(2.0 * np.pi * (1.0 * X + 2.0 * Y + 3.0 * Z))\n        return N, L, delta\n    elif case_id == 2:\n        N, L = 48, 1.0\n        # Sum of modes with amplitudes and phases\n        amps = [0.5, 0.7, 0.9, 0.4]\n        ns = [(3, 0, 0), (0, 5, 0), (0, 0, 7), (2, 3, 1)]\n        phases = [0.1, -0.3, 0.5, 1.1]  # radians\n        x = np.arange(N) * (L / N)\n        X, Y, Z = np.meshgrid(x, x, x, indexing='ij')\n        delta = np.zeros((N, N, N), dtype=np.float64)\n        for A, (nx, ny, nz), phi in zip(amps, ns, phases):\n            arg = 2.0 * np.pi * (nx * X + ny * Y + nz * Z) + phi\n            delta += A * np.cos(arg)\n        return N, L, delta\n    elif case_id == 3:\n        N, L = 32, 1.0\n        # Near-Nyquist along x: delta = cos(2*pi*(15*x))\n        x = np.arange(N) * (L / N)\n        X, Y, Z = np.meshgrid(x, x, x, indexing='ij')\n        delta = np.cos(2.0 * np.pi * (15.0 * X))\n        return N, L, delta\n    elif case_id == 4:\n        N, L = 64, 1.0\n        # Off-axis high anisotropy: delta = cos(2*pi*(30*y + 1*z))\n        x = np.arange(N) * (L / N)\n        X, Y, Z = np.meshgrid(x, x, x, indexing='ij')\n        delta = np.cos(2.0 * np.pi * (30.0 * Y + 1.0 * Z))\n        return N, L, delta\n    else:\n        raise ValueError(\"Unknown case id\")\n\ndef compute_case_error(case_id):\n    N, L, delta = build_delta_case(case_id)\n    # Solve Poisson in Fourier space\n    phi_k, k_arrays = spectral_poisson_phi(delta, L)\n    # Route A: spectral gradient\n    g_spec = spectral_gradient_from_phi_k(phi_k, k_arrays)\n    # Route B: finite difference gradient\n    phi = np.fft.ifftn(phi_k).real\n    g_fd = finite_difference_gradient_from_phi(phi, L)\n    # Relative RMS error\n    err = relative_rms_error(g_spec, g_fd)\n    return err\n\ndef format_float_list(values, decimals=8):\n    # Format list of floats to fixed decimal places without scientific notation\n    fmt = f\"{{:.{decimals}f}}\"\n    return \"[\" + \",\".join(fmt.format(v) for v in values) + \"]\"\n\ndef solve():\n    test_cases = [1, 2, 3, 4]\n    results = []\n    for cid in test_cases:\n        err = compute_case_error(cid)\n        results.append(err)\n    print(format_float_list(results, decimals=8))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "真实的模拟常常需要处理估算量。最后的这个练习探讨了宇宙学中的一个实际挑战：估算的平均密度误差对泊松方程解的影响。通过分析这种误差如何传播，以及不同的算法选择如何减轻其影响，本练习将帮助你理解如何构建能够应对物理输入不确定性的、更稳健的数值求解器。",
            "id": "3490042",
            "problem": "考虑一个边长为 $L$、具有 $N \\times N \\times N$ 个均匀网格点的三维周期性立方体区域。设物质密度场为 $\\rho(\\mathbf{x}) = \\bar{\\rho}\\left(1 + \\delta_{\\text{true}}(\\mathbf{x})\\right)$，其中 $\\bar{\\rho}$ 是真实的全局平均密度，$\\delta_{\\text{true}}(\\mathbf{x})$ 是由两个余弦模式定义的合成过密度场。在数值宇宙学中，共动坐标系中的牛顿势 $\\Phi(\\mathbf{x})$ 由泊松方程确定\n$$\n\\nabla^2 \\Phi(\\mathbf{x}) = 4 \\pi G a^2 \\bar{\\rho}\\, \\delta(\\mathbf{x}),\n$$\n其中 $G$ 是引力常数，$a$ 是尺度因子，$\\delta(\\mathbf{x})$ 是定义为 $\\delta(\\mathbf{x}) = \\left(\\rho(\\mathbf{x}) - \\bar{\\rho}\\right)/\\bar{\\rho}$ 的无量纲过密度。在本问题中，使用代码单位，并设 $4 \\pi G a^2 = 1$ 和 $\\bar{\\rho}$ 为无量纲量。傅里叶空间（快速傅里叶变换，FFT）解强制施加周期性边界条件，它源于泊松方程的空间傅里叶变换：\n$$\n-k^2 \\,\\hat{\\Phi}(\\mathbf{k}) = \\bar{\\rho}\\, \\hat{\\delta}(\\mathbf{k}),\n$$\n对于所有非零波矢 $\\mathbf{k}$ 成立，其中帽子符号表示傅里叶变换，$k = \\|\\mathbf{k}\\|$。零模 $k=0$ 没有唯一解，它对应于 $\\Phi(\\mathbf{x})$ 的一个常数偏移，这对由梯度导出的力没有物理意义。在实践中，数值求解器设置 $\\hat{\\Phi}(\\mathbf{0}) = 0$。\n\n一个稳健的实现必须通过 $\\delta(\\mathbf{x}) = (\\rho(\\mathbf{x}) - \\bar{\\rho}_{\\text{used}})/\\bar{\\rho}_{\\text{used}}$ 来计算 $\\delta(\\mathbf{x})$，其中 $\\bar{\\rho}_{\\text{used}}$ 是求解器使用的平均密度值。假设求解器可能使用一个带有微小相对误差 $\\epsilon$ 的估计平均值 $\\bar{\\rho}_{\\text{est}} = \\bar{\\rho} (1 + \\epsilon)$，而不是真实的平均值 $\\bar{\\rho}$。考虑两种算法处理方式：\n1. 一致性处理：在计算 $\\delta(\\mathbf{x})$ 和缩放傅里叶空间中的源项时，使用相同的 $\\bar{\\rho}_{\\text{used}} = \\bar{\\rho}_{\\text{est}}$。\n2. 非一致性处理：在傅里叶空间中缩放源项时使用 $\\bar{\\rho}_{\\text{used}} = \\bar{\\rho}$，但在计算 $\\delta(\\mathbf{x})$ 时使用 $\\bar{\\rho}_{\\text{est}}$。\n\n从上述基本定义出发，推导一个在周期性网格上求解泊松方程的傅里叶空间求解器。然后，通过数值方法演示 $\\bar{\\rho}_{\\text{used}}$ 的选择以及构建 $\\delta(\\mathbf{x})$ 和缩放源项之间的一致性如何影响解。具体来说，为每个测试用例量化以下三个诊断量：\n- 实空间势的相对 $\\ell_2$ 误差，定义为\n$$\n\\text{err}_{\\Phi} \\equiv \\frac{\\|\\Phi_{\\text{case}} - \\Phi_{\\text{baseline}}\\|_2}{\\|\\Phi_{\\text{baseline}}\\|_2},\n$$\n其中基线情况使用 $\\epsilon=0$ 和一致性处理。\n- 傅里叶空间源项 $\\hat{S}(\\mathbf{k}) = \\bar{\\rho}_{\\text{used}}\\, \\hat{\\delta}(\\mathbf{k})$ 的零模大小与基线源项中存在的最强非零模大小之比，\n$$\nr_{0} \\equiv \\frac{\\left|\\hat{S}_{\\text{case}}(\\mathbf{0})\\right|}{\\max_{\\mathbf{k}\\neq \\mathbf{0}} \\left|\\hat{S}_{\\text{baseline}}(\\mathbf{k})\\right|}.\n$$\n- 实空间势的平均值之差，\n$$\n\\Delta \\bar{\\Phi} \\equiv \\langle \\Phi_{\\text{case}} \\rangle - \\langle \\Phi_{\\text{baseline}} \\rangle,\n$$\n其中尖括号表示空间平均。\n\n使用以下合成过密度、网格和区域规范来构建 $\\delta_{\\text{true}}(\\mathbf{x})$ 和 $\\rho(\\mathbf{x})$：\n- 区域大小：$L = 1$（无量纲）。\n- 网格分辨率：每个维度 $N = 32$ 个点。\n- 真实平均密度：$\\bar{\\rho} = 1$（无量纲）。\n- 过密度场：\n$$\n\\delta_{\\text{true}}(\\mathbf{x}) = A_1 \\cos\\left(2\\pi n_1 \\frac{x}{L}\\right) + A_2 \\cos\\left(2\\pi \\left(n_2 \\frac{y}{L} + n_3 \\frac{z}{L}\\right)\\right),\n$$\n振幅为 $A_1 = 0.2$、$A_2 = 0.1$，整数模指数为 $(n_1, n_2, n_3) = (2, 3, 2)$。\n\n通过为所有 $\\mathbf{k}\\neq \\mathbf{0}$ 计算 $\\hat{\\Phi}(\\mathbf{k}) = -\\hat{S}(\\mathbf{k})/k^2$ 并设置 $\\hat{\\Phi}(\\mathbf{0}) = 0$ 来实现傅里叶空间泊松求解器。然后变换回实空间以获得 $\\Phi(\\mathbf{x})$。\n\n测试套件：\n为以下五个测试用例评估三个诊断量 $\\left[\\text{err}_{\\Phi}, r_{0}, \\Delta \\bar{\\Phi}\\right]$，每个用例由 $(\\epsilon, \\text{consistent})$ 指定：\n1. $(0.0,\\ \\text{True})$。\n2. $(10^{-3},\\ \\text{True})$。\n3. $(10^{-3},\\ \\text{False})$。\n4. $(-0.05,\\ \\text{False})$。\n5. $(0.1,\\ \\text{False})$。\n\n在所选的代码单位中，所有量都是无量纲的。您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表被方括号括起来，其中每个测试用例的结果本身也是一个逗号分隔的列表，并被方括号括起来。例如，输出格式必须为\n$$\n[[r_{1,1},r_{1,2},r_{1,3}],\\,[r_{2,1},r_{2,2},r_{2,3}],\\,\\dots\\,],\n$$\n该行中任何地方都不能有空格。每个 $r_{i,j}$ 都必须是浮点数。",
            "solution": "该问题是有效的。它在科学上基于牛顿引力原理和求解偏微分方程（特别是在宇宙学背景下的泊松方程）的数值方法。问题设定良好，所有必要的参数、定义和边界条件都已明确说明。语言客观且无歧义。该问题代表了计算物理学中一个标准的、尽管是简化的练习。\n\n下面是求解的推导和步骤。\n\n### 1. 理论框架\n\n**a. 泊松方程及其傅里叶解：**\n问题从共动坐标系中的牛顿势 $\\Phi(\\mathbf{x})$ 的泊松方程开始：\n$$ \\nabla^2 \\Phi(\\mathbf{x}) = 4 \\pi G a^2 \\bar{\\rho}\\, \\delta(\\mathbf{x}) $$\n我们被要求在代码单位中工作，其中常数前置因子 $4 \\pi G a^2 = 1$。真实的过密度为 $\\delta_{\\text{true}}(\\mathbf{x}) = (\\rho(\\mathbf{x}) - \\bar{\\rho})/\\bar{\\rho}$，其中 $\\rho(\\mathbf{x})$ 是真实的物质密度场，$\\bar{\\rho}$ 是其真实平均值。方程简化为：\n$$ \\nabla^2 \\Phi(\\mathbf{x}) = \\bar{\\rho}\\, \\delta(\\mathbf{x}) $$\n对于周期性区域，使用傅里叶变换可以最有效地求解此方程。函数 $f(\\mathbf{x})$ 的傅里葉變換記為 $\\hat{f}(\\mathbf{k})$。拉普拉斯算子 $\\nabla^2$ 在傅里叶空间中变为乘以 $-k^2$，其中 $k = \\|\\mathbf{k}\\|$ 是波矢 $\\mathbf{k}$ 的大小。对泊松方程应用傅里叶变换得到：\n$$ -k^2 \\hat{\\Phi}(\\mathbf{k}) = \\widehat{(\\bar{\\rho}\\,\\delta)}(\\mathbf{k}) $$\n假设 $\\bar{\\rho}$ 是一个常数，我们将傅里叶空间中的源项定义为 $\\hat{S}(\\mathbf{k}) = \\bar{\\rho} \\, \\hat{\\delta}(\\mathbf{k})$。方程变为：\n$$ -k^2 \\hat{\\Phi}(\\mathbf{k}) = \\hat{S}(\\mathbf{k}) $$\n对于任何非零波矢 $\\mathbf{k} \\neq \\mathbf{0}$，我们可以解出傅里叶空间中的势：\n$$ \\hat{\\Phi}(\\mathbf{k}) = - \\frac{\\hat{S}(\\mathbf{k})}{k^2} $$\n$\\mathbf{k}=\\mathbf{0}$ 的情况对应于直流分量或空间平均值。对于 $k=0$，方程变为 $0 = \\hat{S}(\\mathbf{0})$。如果源项的平均值 $\\hat{S}(\\mathbf{0})$ 非零，则方程不自洽。如果 $\\hat{S}(\\mathbf{0})=0$，则 $\\hat{\\Phi}(\\mathbf{0})$ 是不确定的。这种不确定性对应于可以在势 $\\Phi(\\mathbf{x})$ 上加上一个任意常数的自由度，这不影响从其梯度 $\\mathbf{g} = -\\nabla\\Phi$ 导出的物理力。按照规定，标准的数值实践是通过设置 $\\hat{\\Phi}(\\mathbf{0}) = 0$ 来解决这个不确定性。\n\n**b. 网格与离散化：**\n我们在一个边长为 $L$ 的立方体内的 $N \\times N \\times N$ 离散网格上操作。\n- 实空间坐标：$\\mathbf{x}_{ijk} = (i \\frac{L}{N}, j \\frac{L}{N}, k \\frac{L}{N})$，其中 $i,j,k \\in \\{0, ..., N-1\\}$。\n- 傅里叶空间波矢：对应的波矢由 $\\mathbf{k}_{lmn} = (2\\pi \\frac{l}{L}, 2\\pi \\frac{m}{L}, 2\\pi \\frac{n}{L})$ 给出，其中 $l,m,n$ 是由 `numpy.fft.fftfreq` 提供的整数频率。\n\n**c. 过密度计算与算法处理：**\n真实的密度场由 $\\rho(\\mathbf{x}) = \\bar{\\rho}(1 + \\delta_{\\text{true}}(\\mathbf{x}))$ 给出。数值求解器可能会使用一个估计的平均密度 $\\bar{\\rho}_{\\text{est}} = \\bar{\\rho}(1+\\epsilon)$。求解器计算出的过密度场则为：\n$$ \\delta_{\\text{case}}(\\mathbf{x}) = \\frac{\\rho(\\mathbf{x}) - \\bar{\\rho}_{\\text{est}}}{\\bar{\\rho}_{\\text{est}}} = \\frac{\\bar{\\rho}(1+\\delta_{\\text{true}}(\\mathbf{x})) - \\bar{\\rho}(1+\\epsilon)}{\\bar{\\rho}(1+\\epsilon)} = \\frac{\\delta_{\\text{true}}(\\mathbf{x}) - \\epsilon}{1+\\epsilon} $$\n进行傅里叶变换，并注意到常数 $C$ 的变换为 $C N^3 \\delta_{\\mathbf{k}, \\mathbf{0}}$（其中 $\\delta_{\\mathbf{k}, \\mathbf{0}}$ 是克罗内克δ函数）：\n$$ \\hat{\\delta}_{\\text{case}}(\\mathbf{k}) = \\frac{\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) - \\epsilon N^3 \\delta_{\\mathbf{k}, \\mathbf{0}}}{1+\\epsilon} $$\n问题为源项 $\\hat{S}(\\mathbf{k})$ 定义了两种处理方式：\n1.  **一致性处理**：$\\bar{\\rho}_{\\text{used}} = \\bar{\\rho}_{\\text{est}}$。源项为 $\\hat{S}_{\\text{cons}}(\\mathbf{k}) = \\bar{\\rho}_{\\text{est}} \\hat{\\delta}_{\\text{case}}(\\mathbf{k}) = \\bar{\\rho}(1+\\epsilon) \\frac{\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) - \\epsilon N^3 \\delta_{\\mathbf{k}, \\mathbf{0}}}{1+\\epsilon} = \\bar{\\rho}(\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) - \\epsilon N^3 \\delta_{\\mathbf{k}, \\mathbf{0}})$。\n2.  **非一致性处理**：$\\bar{\\rho}_{\\text{used}} = \\bar{\\rho}$。源项为 $\\hat{S}_{\\text{incons}}(\\mathbf{k}) = \\bar{\\rho} \\hat{\\delta}_{\\text{case}}(\\mathbf{k}) = \\bar{\\rho} \\frac{\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) - \\epsilon N^3 \\delta_{\\mathbf{k}, \\mathbf{0}}}{1+\\epsilon}$。\n\n**d. 诊断量分析：**\n基线情况对应于 $\\epsilon=0$，此时 $\\bar{\\rho}_{\\text{est}} = \\bar{\\rho}$ 且处理方式是一致的。在这种情况下，$\\delta_{\\text{case}}=\\delta_{\\text{true}}$ 且 $\\hat{S}_{\\text{baseline}}(\\mathbf{k}) = \\bar{\\rho}\\hat{\\delta}_{\\text{true}}(\\mathbf{k})$。由于 $\\delta_{\\text{true}}$ 是余弦函数的和，其空间平均值为零，所以 $\\hat{\\delta}_{\\text{true}}(\\mathbf{0})=0$ 因而 $\\hat{S}_{\\text{baseline}}(\\mathbf{0})=0$。\n\n-   **平均势差 $\\Delta \\bar{\\Phi}$**：任意场 $\\Phi(\\mathbf{x})$ 在离散网格上的空间平均值为 $\\langle\\Phi\\rangle = \\frac{1}{N^3}\\sum_\\mathbf{x} \\Phi(\\mathbf{x})$。根据离散傅里叶变换的性质，$\\sum_\\mathbf{x} \\Phi(\\mathbf{x}) = \\hat{\\Phi}(\\mathbf{0})$。因此，$\\langle\\Phi\\rangle = \\hat{\\Phi}(\\mathbf{0})/N^3$。由于问题明确要求对所有情况（基线和其他情况）都设置 $\\hat{\\Phi}(\\mathbf{0}) = 0$，因此每种情况的平均势都将为零。所以，$\\Delta \\bar{\\Phi} \\equiv \\langle \\Phi_{\\text{case}} \\rangle - \\langle \\Phi_{\\text{baseline}} \\rangle = 0 - 0 = 0$ 对于所有测试用例均成立。\n\n-   **相对误差 $\\text{err}_{\\Phi}$**：\n    -   **一致性处理**：对于 $\\mathbf{k} \\neq \\mathbf{0}$，$\\hat{S}_{\\text{cons}}(\\mathbf{k}) = \\bar{\\rho}\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) = \\hat{S}_{\\text{baseline}}(\\mathbf{k})$。对于 $\\mathbf{k}=\\mathbf{0}$，$\\hat{S}_{\\text{cons}}(\\mathbf{0}) = -\\bar{\\rho}\\epsilon N^3 \\neq 0$。势 $\\hat{\\Phi}$ 是通过除以 $-k^2$（对于 $\\mathbf{k} \\neq \\mathbf{0}$）并将 $\\mathbf{k}=\\mathbf{0}$ 分量设为零得到的。由于对于所有 $\\mathbf{k} \\neq \\mathbf{0}$，源项都匹配，并且 $\\hat{\\Phi}_{\\text{cons}}(\\mathbf{0})$ 和 $\\hat{\\Phi}_{\\text{baseline}}(\\mathbf{0})$ 都被设置为零，我们有 $\\hat{\\Phi}_{\\text{cons}}(\\mathbf{k}) = \\hat{\\Phi}_{\\text{baseline}}(\\mathbf{k})$ 对于所有 $\\mathbf{k}$ 都成立。因此，$\\Phi_{\\text{cons}}(\\mathbf{x}) = \\Phi_{\\text{baseline}}(\\mathbf{x})$，误差 $\\text{err}_{\\Phi}$ 精确为 $0$。\n    -   **非一致性处理**：对于 $\\mathbf{k} \\neq \\mathbf{0}$，$\\hat{S}_{\\text{incons}}(\\mathbf{k}) = \\frac{\\bar{\\rho}}{1+\\epsilon} \\hat{\\delta}_{\\text{true}}(\\mathbf{k}) = \\frac{1}{1+\\epsilon} \\hat{S}_{\\text{baseline}}(\\mathbf{k})$。这导致 $\\hat{\\Phi}_{\\text{incons}}(\\mathbf{k}) = \\frac{1}{1+\\epsilon} \\hat{\\Phi}_{\\text{baseline}}(\\mathbf{k})$ 对于 $\\mathbf{k} \\neq \\mathbf{0}$ 成立。由于两个直流分量都为零，我们有 $\\hat{\\Phi}_{\\text{incons}}(\\mathbf{k}) = \\frac{1}{1+\\epsilon} \\hat{\\Phi}_{\\text{baseline}}(\\mathbf{k})$ 对于所有 $\\mathbf{k}$ 都成立。根据傅里葉逆變換的線性性質，$\\Phi_{\\text{incons}}(\\mathbf{x}) = \\frac{1}{1+\\epsilon} \\Phi_{\\text{baseline}}(\\mathbf{x})$。于是误差为：\n        $$ \\text{err}_{\\Phi} = \\frac{\\|\\Phi_{\\text{incons}} - \\Phi_{\\text{baseline}}\\|_2}{\\|\\Phi_{\\text{baseline}}\\|_2} = \\frac{\\|\\left(\\frac{1}{1+\\epsilon} - 1\\right)\\Phi_{\\text{baseline}}\\|_2}{\\|\\Phi_{\\text{baseline}}\\|_2} = \\left|\\frac{-\\epsilon}{1+\\epsilon}\\right| = \\frac{|\\epsilon|}{|1+\\epsilon|} $$\n\n-   **源项零模比率 $r_0$**：分母是 $\\max_{\\mathbf{k}\\neq \\mathbf{0}} |\\hat{S}_{\\text{baseline}}(\\mathbf{k})|$。基线源项是 $\\bar{\\rho}\\hat{\\delta}_{\\text{true}}(\\mathbf{k})$。场 $\\delta_{\\text{true}}$ 由两个振幅为 $A_1=0.2$ 和 $A_2=0.1$ 的余弦模组成。在大小为 $N^3$ 的网格上，$A_i \\cos(\\dots)$ 的离散傅里叶变换（DFT）的峰值大小为 $A_i N^3 / 2$。最大值将来自较大的振幅 $A_1$。因此，$\\max_{\\mathbf{k}\\neq \\mathbf{0}} |\\hat{S}_{\\text{baseline}}(\\mathbf{k})| = \\bar{\\rho} A_1 N^3 / 2$。\n    -   **一致性处理**：分子是 $|\\hat{S}_{\\text{cons}}(\\mathbf{0})| = |-\\bar{\\rho}\\epsilon N^3| = \\bar{\\rho}|\\epsilon|N^3$。比率为 $r_0 = \\frac{\\bar{\\rho}|\\epsilon|N^3}{\\bar{\\rho} A_1 N^3/2} = \\frac{2|\\epsilon|}{A_1}$。\n    -   **非一致性处理**：分子是 $|\\hat{S}_{\\text{incons}}(\\mathbf{0})| = |\\frac{-\\bar{\\rho}\\epsilon N^3}{1+\\epsilon}|$。比率为 $r_0 = \\frac{|\\frac{-\\bar{\\rho}\\epsilon N^3}{1+\\epsilon}|}{\\bar{\\rho} A_1 N^3/2} = \\frac{2|\\epsilon|}{|1+\\epsilon|A_1}$。\n\n### 2. 实现策略\n\n数值实现将按以下步骤进行：\n1.  **设置**：定义物理和网格参数（$L, N, \\bar{\\rho}$ 等），并创建实空间网格坐标 $(x,y,z)$ 和傅里叶空间波矢网格 $(k_x, k_y, k_z)$。为所有模式计算波数平方 $k^2 = k_x^2+k_y^2+k_z^2$。\n2.  **真实场**：在实空间网格上构建真实密度场 $\\rho(\\mathbf{x}) = \\bar{\\rho}(1+\\delta_{\\text{true}}(\\mathbf{x}))$。\n3.  **基线计算**：计算基线情况（$\\epsilon=0$，一致性处理）的解。这包括：\n    a. 计算 $\\delta_{\\text{baseline}}(\\mathbf{x}) = (\\rho(\\mathbf{x}) - \\bar{\\rho})/\\bar{\\rho}$。\n    b. 对其进行FFT以获得 $\\hat{\\delta}_{\\text{baseline}}(\\mathbf{k})$。\n    c. 构造源项 $\\hat{S}_{\\text{baseline}}(\\mathbf{k}) = \\bar{\\rho}\\hat{\\delta}_{\\text{baseline}}(\\mathbf{k})$。\n    d. 通过除以 $-k^2$（避免 $k=0$）并设置 $\\hat{\\Phi}_{\\text{baseline}}(0,0,0) = 0$ 来求解 $\\hat{\\Phi}_{\\text{baseline}}(\\mathbf{k})$。\n    e. 变换回实空间以获得 $\\Phi_{\\text{baseline}}(\\mathbf{x})$。\n    f. 存储 $\\|\\Phi_{\\text{baseline}}\\|_2$ 和 $\\max_{\\mathbf{k}\\neq 0} |\\hat{S}_{\\text{baseline}}(\\mathbf{k})|$ 以供后续诊断使用。\n4.  **测试用例循环**：遍历五个测试用例。对于每种情况：\n    a. 定义 $\\epsilon$ 和一致性标志。\n    b. 计算 $\\bar{\\rho}_{\\text{est}} = \\bar{\\rho}(1+\\epsilon)$。\n    c. 计算 $\\delta_{\\text{case}}(\\mathbf{x}) = (\\rho(\\mathbf{x}) - \\bar{\\rho}_{\\text{est}})/\\bar{\\rho}_{\\text{est}}$。\n    d. 计算其FFT，$\\hat{\\delta}_{\\text{case}}(\\mathbf{k})$。\n    e. 使用适当的平均密度（一致性处理用 $\\bar{\\rho}_{\\text{est}}$，非一致性处理用 $\\bar{\\rho}$）构建源项 $\\hat{S}_{\\text{case}}(\\mathbf{k})$。\n    f. 求解 $\\hat{\\Phi}_{\\text{case}}(\\mathbf{k})$ 并变换回实空间以获得 $\\Phi_{\\text{case}}(\\mathbf{x})$，使用与基线相同的方法。\n    g. 使用存储的基线量计算三个诊断量 $\\text{err}_{\\Phi}$、$r_0$ 和 $\\Delta\\bar{\\Phi}$。\n5.  **输出**：将收集到的结果格式化为指定的字符串格式。\n\n这个结构化的过程确保了每一步都正确执行，并且平均密度估计与求解器逻辑之间的相互作用能够按照问题陈述被精确建模。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves Poisson's equation in Fourier space for a synthetic density field\n    and analyzes the effect of mean density estimation errors.\n    \"\"\"\n\n    # 1. Problem Definition\n    # Domain and Grid\n    L = 1.0  # Domain side length\n    N = 32   # Grid points per dimension\n\n    # Physics Parameters (in code units)\n    rho_bar_true = 1.0  # True mean density\n    # 4 * pi * G * a^2 is set to 1\n\n    # Synthetic Overdensity Field Parameters\n    A1 = 0.2\n    A2 = 0.1\n    n1, n2, n3 = 2, 3, 2\n    \n    # Test Suite\n    test_cases = [\n        (0.0, True),      # 1. Baseline\n        (1e-3, True),     # 2. Consistent\n        (1e-3, False),    # 3. Inconsistent\n        (-0.05, False),   # 4. Inconsistent\n        (0.1, False)      # 5. Inconsistent\n    ]\n\n    # 2. Grid and Field Setup\n    # Real-space grid coordinates\n    grid_1d = np.linspace(0.0, L, N, endpoint=False)\n    x, y, z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n    # True overdensity field\n    delta_true = A1 * np.cos(2 * np.pi * n1 * x / L) + \\\n                 A2 * np.cos(2 * np.pi * (n2 * y / L + n3 * z / L))\n\n    # True density field\n    rho = rho_bar_true * (1.0 + delta_true)\n\n    # Fourier-space wavenumbers\n    k_1d = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_1d, k_1d, k_1d, indexing='ij')\n    k_squared = kx**2 + ky**2 + kz**2\n    \n    # We will need to set k=0 element to a non-zero value to avoid division by zero.\n    # The result at this k-vector is set to 0 manually anyway.\n    # A more robust way is to use a `where` clause in the division.\n    k_squared[0, 0, 0] = 1.0 \n    \n    # 3. Poisson Solver Function\n    def poisson_solve(density_field, rho_bar_for_delta, rho_bar_for_source):\n        \"\"\"\n        Solves Poisson's equation for a given density field and mean density choices.\n        \n        Returns:\n            Phi (np.ndarray): Real-space potential.\n            S_hat (np.ndarray): Fourier-space source term.\n        \"\"\"\n        # Compute overdensity delta\n        delta = (density_field - rho_bar_for_delta) / rho_bar_for_delta\n        \n        # FFT of overdensity\n        delta_hat = np.fft.fftn(delta)\n        \n        # Construct Fourier-space source term S_hat\n        S_hat = rho_bar_for_source * delta_hat\n        \n        # Solve for potential in Fourier space\n        Phi_hat = -S_hat / k_squared\n        \n        # Set the k=0 mode (mean potential) to zero\n        Phi_hat[0, 0, 0] = 0.0\n        \n        # Inverse FFT to get potential in real space\n        Phi = np.fft.ifftn(Phi_hat).real\n        \n        return Phi, S_hat\n\n    # 4. Baseline Calculation (Case 1)\n    phi_baseline, s_hat_baseline = poisson_solve(rho, rho_bar_true, rho_bar_true)\n    norm_phi_baseline = np.linalg.norm(phi_baseline)\n    \n    # Find max of |S_hat_baseline(k)| for k != 0\n    s_hat_baseline_mag = np.abs(s_hat_baseline)\n    s_hat_baseline_mag_k0 = s_hat_baseline_mag[0, 0, 0]\n    s_hat_baseline_mag[0, 0, 0] = 0.0 # Temporarily zero out the k=0 mode\n    max_s_baseline_nonzero = np.max(s_hat_baseline_mag)\n    s_hat_baseline_mag[0, 0, 0] = s_hat_baseline_mag_k0 # Restore original value\n    \n    # Handle the case where the baseline field is zero (all modes are zero)\n    if max_s_baseline_nonzero == 0:\n        max_s_baseline_nonzero = 1.0 # Avoid division by zero for r0\n\n    # 5. Loop Through Test Cases and Compute Diagnostics\n    results = []\n    for epsilon, is_consistent in test_cases:\n        rho_bar_est = rho_bar_true * (1.0 + epsilon)\n        \n        if is_consistent:\n            rho_bar_for_delta = rho_bar_est\n            rho_bar_for_source = rho_bar_est\n        else: # Inconsistent\n            rho_bar_for_delta = rho_bar_est\n            rho_bar_for_source = rho_bar_true\n        \n        # Solve for the current test case\n        phi_case, s_hat_case = poisson_solve(rho, rho_bar_for_delta, rho_bar_for_source)\n        \n        # Calculate diagnostics\n        \n        # err_Phi: Relative l2 error in the potential\n        if norm_phi_baseline > 0:\n            err_phi = np.linalg.norm(phi_case - phi_baseline) / norm_phi_baseline\n        else:\n            err_phi = np.linalg.norm(phi_case) # If baseline is zero, use absolute norm\n\n        # r0: Ratio of the k=0 source mode to the max non-zero baseline mode\n        r0 = np.abs(s_hat_case[0, 0, 0]) / max_s_baseline_nonzero\n        \n        # Delta_Phi_bar: Difference in the mean potential\n        delta_phi_bar = np.mean(phi_case) - np.mean(phi_baseline)\n        \n        results.append([err_phi, r0, delta_phi_bar])\n\n    # 6. Format and Print Output\n    # Format: [[r1,r2,r3],[r4,r5,r6],...] with no spaces\n    output_str = \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```"
        }
    ]
}