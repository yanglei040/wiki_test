{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of building confidence in any numerical solver is to validate it against a case with a known analytical solution. This first practice guides you through this essential verification process using a spherically symmetric Gaussian overdensity, a classic and physically intuitive test case. You will perform the analytical derivation for the gravitational force from first principles and then implement a complete Particle-Mesh (PM) solver to compute the force numerically, allowing you to directly quantify your code's accuracy and understand the interplay between periodic numerical solutions and infinite-domain analytic ones .",
            "id": "3489960",
            "problem": "Consider the Newtonian gravitational potential in an expanding universe under the sub-horizon, non-relativistic limit used in numerical cosmology. In comoving coordinates, the potential satisfies a Poisson equation. Start from the fundamental laws and core definitions: the Newtonian Poisson equation, the three-dimensional Fourier transform pair with a clearly stated convention, and spherical symmetry. Specifically, use the following base statements, which are considered well-tested formulas and facts:\n- The Poisson equation for the comoving gravitational potential is $\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi G a^2 \\bar{\\rho}\\, \\delta(\\mathbf{x})$, where $G$ is the gravitational constant, $a$ is the scale factor, $\\bar{\\rho}$ is the mean matter density, and $\\delta(\\mathbf{x})$ is the dimensionless overdensity field.\n- The three-dimensional Fourier transform convention is $\\tilde{f}(\\mathbf{k}) = \\int d^3x\\, f(\\mathbf{x})\\, e^{-i \\mathbf{k}\\cdot\\mathbf{x}}$ and the inverse is $f(\\mathbf{x}) = \\frac{1}{(2\\pi)^3} \\int d^3k\\, \\tilde{f}(\\mathbf{k})\\, e^{i \\mathbf{k}\\cdot\\mathbf{x}}$.\n- Spherical symmetry implies that for any spherically symmetric function $f(\\mathbf{x}) = f(r)$ with $r = \\|\\mathbf{x}\\|$, its Fourier transform depends only on $k = \\|\\mathbf{k}\\|$.\n\nYou are given a spherically symmetric Gaussian overdensity $\\delta(\\mathbf{x}) = \\delta_0 \\exp\\!\\left(-\\frac{r^2}{2\\sigma^2}\\right)$, where $\\delta_0$ is a constant amplitude and $\\sigma$ is a constant width. Your tasks are:\n- Derive from first principles the analytical expression for the Fourier-space potential $\\tilde{\\phi}(\\mathbf{k})$ using the stated Fourier transform convention and the Poisson equation. Do not use any shortcut formulas beyond the base statements listed above.\n- Using spherical symmetry and the Poisson equation in spherical coordinates, derive the real-space radial force profile $F_r(r)$ predicted analytically by $F_r(r) = -\\frac{d\\phi}{dr}$ for the given Gaussian overdensity, expressed in terms of elementary functions and the error function. The derivation must start from the spherical form of the Poisson equation and integrate appropriately. Do not provide intermediate shortcut results; present a complete derivation.\n- Implement a numerical Particle-Mesh (PM) Fourier-space solver using the Fast Fourier Transform (FFT) to solve the Poisson equation on a periodic cubic domain and compute the force field spectrally. Fast Fourier Transform (FFT) is defined as the discrete counterpart of the Fourier transform that maps spatial samples to discrete wavenumbers. Particle-Mesh (PM) refers to solving fields on a mesh via spectral methods under periodic boundary conditions. Use the convention consistent with the continuous transform stated above: the discrete wave numbers are $\\mathbf{k} = (k_x,k_y,k_z)$ with $k_i = 2\\pi n_i/L$, where $n_i$ are integers determined by the discrete FFT frequency grid and $L$ is the box size.\n\nAll quantities must be in code units: set $G=1$, $a=1$, and $\\bar{\\rho}=1$, with lengths measured in arbitrary units such that $L$ and $\\sigma$ are in the same units, and $\\delta_0$ is dimensionless. In these units, the Poisson equation becomes $\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi\\, \\delta(\\mathbf{x})$.\n\nAlgorithmic requirements for the numerical solver:\n- Discretize the cubic domain of side length $L$ onto a uniform grid of $N\\times N\\times N$ points, with grid spacing $dx = L/N$.\n- Sample $\\delta(\\mathbf{x})$ on the grid points with coordinates centered at the origin, i.e., $x_j = \\left(j - \\frac{N}{2}\\right) dx$, $y_j = \\left(j - \\frac{N}{2}\\right) dx$, $z_j = \\left(j - \\frac{N}{2}\\right) dx$ for integer indices $j$.\n- Compute $\\tilde{\\delta}(\\mathbf{k})$ with a three-dimensional FFT.\n- Solve for $\\tilde{\\phi}(\\mathbf{k})$ by multiplying $\\tilde{\\delta}(\\mathbf{k})$ by the Fourier-space Green’s function consistent with the Poisson equation and the stated transform convention. Handle the $\\mathbf{k}=\\mathbf{0}$ mode carefully to avoid division by zero by setting $\\tilde{\\phi}(\\mathbf{0})=0$, which fixes the arbitrary potential offset and leaves forces unaffected.\n- Compute the spectral force components by $\\tilde{F}_i(\\mathbf{k}) = -i k_i \\tilde{\\phi}(\\mathbf{k})$ and inverse FFT each component to obtain $F_x(\\mathbf{x})$, $F_y(\\mathbf{x})$, $F_z(\\mathbf{x})$.\n- Project the force onto the radial direction to obtain $F_r(\\mathbf{x}) = \\frac{\\mathbf{F}(\\mathbf{x}) \\cdot \\mathbf{x}}{\\|\\mathbf{x}\\|}$ for $\\|\\mathbf{x}\\|>0$, and define $F_r(\\mathbf{0})=0$.\n\nComparison protocol for accuracy:\n- Compare the numerical PM force $F_r(\\mathbf{x})$ against the analytical radial force $F_r(r)$ derived earlier.\n- Restrict the comparison to grid points with $r \\le L/4$ to minimize periodic-image contamination and exclude the point $r=0$ from the relative error computation.\n- Define the relative error at each comparison point as $\\epsilon(\\mathbf{x}) = \\frac{|F_r^{\\text{PM}}(\\mathbf{x}) - F_r^{\\text{analytic}}(r)|}{\\max(|F_r^{\\text{analytic}}(r)|, \\varepsilon)}$, where $\\varepsilon$ is a small positive threshold scaled to the maximum analytic force magnitude to prevent division by nearly zero; choose $\\varepsilon$ internally as a fixed fraction of the maximum $|F_r^{\\text{analytic}}|$ in the comparison region.\n\nTest suite and required output:\n- Use the following parameter sets to exercise different regimes, including the general case, sign reversal (underdensity), broad profile, and near-grid-resolution width. Each test case is a tuple $(N, L, \\sigma, \\delta_0)$:\n  1. $(N=64, L=1.0, \\sigma=0.05, \\delta_0=0.01)$.\n  2. $(N=64, L=1.0, \\sigma=0.05, \\delta_0=-0.01)$.\n  3. $(N=128, L=1.0, \\sigma=0.15, \\delta_0=0.02)$.\n  4. $(N=64, L=1.0, \\sigma=L/N, \\delta_0=0.01)$.\n- For each test case, compute a single float equal to the maximum relative error over the specified comparison region. Express this float in decimal form without any unit.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases (e.g., $[r_1,r_2,r_3,r_4]$).\n\nEnsure scientific realism: your derivations must begin from the stated base definitions and laws, and your numerical implementation must consistently apply the Fourier-space method under periodic boundary conditions. No intermediate shortcut formulas beyond those base statements are permitted in the problem statement. All mathematical entities, including symbols, variables, functions, operators, and numbers, must be written in LaTeX notation enclosed in dollar signs within this problem statement.",
            "solution": "The problem requires the derivation of analytical solutions for the gravitational potential and force for a given mass distribution, the implementation of a numerical Fourier-space Particle-Mesh (PM) solver to compute the same quantities, and a comparison of the results to validate the numerical method. The analysis is performed in comoving coordinates under code units ($G=1$, $a=1$, $\\bar{\\rho}=1$), for which the Poisson equation for the peculiar gravitational potential $\\phi$ is $\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi \\delta(\\mathbf{x})$.\n\n### Part 1: Analytical Derivation of Fourier-Space Potential $\\tilde{\\phi}(\\mathbf{k})$\n\nWe begin with the Poisson equation in the specified units:\n$$ \\nabla^2 \\phi(\\mathbf{x}) = 4\\pi \\delta(\\mathbf{x}) $$\nTo solve this equation in Fourier space, we apply the three-dimensional Fourier transform, defined as $\\tilde{f}(\\mathbf{k}) = \\int d^3x\\, f(\\mathbf{x})\\, e^{-i \\mathbf{k}\\cdot\\mathbf{x}}$, to both sides.\n\nThe Fourier transform of the Laplacian operator, $\\nabla^2$, is found by considering its effect on a plane wave $e^{i\\mathbf{k}\\cdot\\mathbf{x}}$.\n$$ \\nabla^2 e^{i\\mathbf{k}\\cdot\\mathbf{x}} = \\nabla \\cdot (i\\mathbf{k} e^{i\\mathbf{k}\\cdot\\mathbf{x}}) = i\\mathbf{k} \\cdot i\\mathbf{k} e^{i\\mathbf{k}\\cdot\\mathbf{x}} = -\\|\\mathbf{k}\\|^2 e^{i\\mathbf{k}\\cdot\\mathbf{x}} = -k^2 e^{i\\mathbf{k}\\cdot\\mathbf{x}} $$\nBy the convolution theorem, or more directly using the derivative property of Fourier transforms, the transform of the Laplacian of a function $\\phi(\\mathbf{x})$ is:\n$$ \\mathcal{F}[\\nabla^2 \\phi(\\mathbf{x})] = -k^2 \\tilde{\\phi}(\\mathbf{k}) $$\nApplying the Fourier transform to the entire Poisson equation yields:\n$$ -k^2 \\tilde{\\phi}(\\mathbf{k}) = 4\\pi \\tilde{\\delta}(\\mathbf{k}) $$\nSolving for the Fourier-space potential $\\tilde{\\phi}(\\mathbf{k})$ for $k \\neq 0$ gives:\n$$ \\tilde{\\phi}(\\mathbf{k}) = -\\frac{4\\pi}{k^2} \\tilde{\\delta}(\\mathbf{k}) $$\nNext, we must find the Fourier transform of the given spherically symmetric Gaussian overdensity, $\\delta(\\mathbf{x}) = \\delta_0 \\exp(-r^2 / (2\\sigma^2))$, where $r^2 = x^2+y^2+z^2$.\n$$ \\tilde{\\delta}(\\mathbf{k}) = \\int d^3x\\, \\delta_0 e^{-r^2/(2\\sigma^2)} e^{-i \\mathbf{k}\\cdot\\mathbf{x}} $$\nDue to the separability of the Gaussian and the exponential term in Cartesian coordinates, the 3D integral becomes a product of three 1D integrals:\n$$ \\tilde{\\delta}(\\mathbf{k}) = \\delta_0 \\left( \\int_{-\\infty}^{\\infty} dx\\, e^{-x^2/(2\\sigma^2)} e^{-ik_x x} \\right) \\left( \\int_{-\\infty}^{\\infty} dy\\, e^{-y^2/(2\\sigma^2)} e^{-ik_y y} \\right) \\left( \\int_{-\\infty}^{\\infty} dz\\, e^{-z^2/(2\\sigma^2)} e^{-ik_z z} \\right) $$\nEach integral is a standard Fourier transform of a Gaussian function. For a general 1D Gaussian $e^{-ax^2}$, the transform is $\\int_{-\\infty}^{\\infty} dx\\, e^{-ax^2} e^{-ikx} = \\sqrt{\\pi/a} e^{-k^2/(4a)}$.\nIn our case, $a = 1/(2\\sigma^2)$, so the integral with respect to $x$ is:\n$$ \\int_{-\\infty}^{\\infty} dx\\, e^{-x^2/(2\\sigma^2)} e^{-ik_x x} = \\sqrt{2\\pi\\sigma^2} e^{-k_x^2 \\sigma^2/2} $$\nMultiplying the results for the three dimensions ($x$, $y$, $z$) gives:\n$$ \\tilde{\\delta}(\\mathbf{k}) = \\delta_0 (2\\pi\\sigma^2)^{3/2} e^{-(k_x^2+k_y^2+k_z^2)\\sigma^2/2} = \\delta_0 (2\\pi\\sigma^2)^{3/2} e^{-k^2\\sigma^2/2} $$\nSubstituting this into the expression for $\\tilde{\\phi}(\\mathbf{k})$ yields the final analytical expression for the Fourier-space potential:\n$$ \\tilde{\\phi}(\\mathbf{k}) = -\\frac{4\\pi}{k^2} \\delta_0 (2\\pi\\sigma^2)^{3/2} e^{-k^2\\sigma^2/2} $$\n\n### Part 2: Analytical Derivation of Real-Space Radial Force $F_r(r)$\n\nFor a spherically symmetric system, the Poisson equation $\\nabla^2\\phi = 4\\pi\\delta$ simplifies. In spherical coordinates, the Laplacian of a function $\\phi(r)$ that depends only on the radius $r$ is $\\nabla^2 \\phi(r) = \\frac{1}{r^2} \\frac{d}{dr}\\left(r^2 \\frac{d\\phi}{dr}\\right)$. The equation becomes:\n$$ \\frac{1}{r^2} \\frac{d}{dr}\\left(r^2 \\frac{d\\phi}{dr}\\right) = 4\\pi \\delta(r) = 4\\pi \\delta_0 e^{-r^2/(2\\sigma^2)} $$\nWe can integrate this equation to find the force. First, multiply by $r^2$ and integrate from $0$ to a radius $r$:\n$$ \\int_0^r \\frac{d}{dr'}\\left(r'^2 \\frac{d\\phi}{dr'}\\right) dr' = \\int_0^r 4\\pi \\delta_0 r'^2 e^{-r'^2/(2\\sigma^2)} dr' $$\nThe left side evaluates to $r^2 \\frac{d\\phi}{dr}$ (assuming the gravitational field $-\\frac{d\\phi}{dr}$ is finite at $r=0$).\nThe radial force is defined as $F_r(r) = -\\frac{d\\phi}{dr}$. Thus, we can write:\n$$ -r^2 F_r(r) = 4\\pi \\delta_0 \\int_0^r r'^2 e^{-r'^2/(2\\sigma^2)} dr' $$\n$$ F_r(r) = -\\frac{4\\pi \\delta_0}{r^2} \\int_0^r r'^2 e^{-r'^2/(2\\sigma^2)} dr' $$\nThe remaining task is to evaluate the integral. This can be done using integration by parts, $\\int u dv = uv - \\int v du$.\nLet $u=r'$ and $dv = r' e^{-r'^2/(2\\sigma^2)} dr'$. Then $du=dr'$ and $v = -\\sigma^2 e^{-r'^2/(2\\sigma^2)}$.\n\\begin{align*}\n\\int_0^r r'^2 e^{-r'^2/(2\\sigma^2)} dr' &= \\left[ -r' \\sigma^2 e^{-r'^2/(2\\sigma^2)} \\right]_0^r - \\int_0^r (-\\sigma^2 e^{-r'^2/(2\\sigma^2)}) dr' \\\\\n&= -r \\sigma^2 e^{-r^2/(2\\sigma^2)} + \\sigma^2 \\int_0^r e^{-r'^2/(2\\sigma^2)} dr'\n\\end{align*}\nThe integral $\\int_0^r e^{-r'^2/(2\\sigma^2)} dr'$ is related to the error function, $\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}}\\int_0^z e^{-t^2} dt$.\nLet $t = r'/(\\sqrt{2}\\sigma)$, so $r' = \\sqrt{2}\\sigma t$ and $dr' = \\sqrt{2}\\sigma dt$. The integration limit becomes $r/(\\sqrt{2}\\sigma)$.\n$$ \\int_0^r e^{-r'^2/(2\\sigma^2)} dr' = \\int_0^{r/(\\sqrt{2}\\sigma)} e^{-t^2} (\\sqrt{2}\\sigma dt) = \\sqrt{2}\\sigma \\frac{\\sqrt{\\pi}}{2} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) = \\sigma \\sqrt{\\frac{\\pi}{2}} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) $$\nSubstituting this back, the full integral is:\n$$ \\int_0^r r'^2 e^{-r'^2/(2\\sigma^2)} dr' = \\sigma^3 \\sqrt{\\frac{\\pi}{2}} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) - r \\sigma^2 e^{-r^2/(2\\sigma^2)} $$\nFinally, substituting this into the expression for $F_r(r)$:\n$$ F_r(r) = -\\frac{4\\pi \\delta_0}{r^2} \\left[ \\sigma^3 \\sqrt{\\frac{\\pi}{2}} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) - r \\sigma^2 e^{-r^2/(2\\sigma^2)} \\right] $$\n$$ F_r(r) = -4\\pi \\delta_0 \\left[ \\frac{\\sigma^3}{r^2} \\sqrt{\\frac{\\pi}{2}} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) - \\frac{\\sigma^2}{r} e^{-r^2/(2\\sigma^2)} \\right] $$\nThis is the analytical expression for the radial force. Note that as $r \\to 0$, $F_r(r) \\to -\\frac{4\\pi\\delta_0}{3}r \\to 0$.\n\n### Part 3: Numerical Method (Particle-Mesh Solver)\n\nThe numerical solution is found using a spectral Particle-Mesh (PM) method on a periodic cubic grid. The algorithm proceeds as follows:\n\n1.  **Grid Discretization**: The domain of side length $L$ is discretized into an $N \\times N \\times N$ grid. The grid spacing is $dx=L/N$. We define a grid of centered coordinates $(x_i, y_j, z_k)$ where $x_i = (i - N/2)dx$ for $i \\in \\{0, \\dots, N-1\\}$, and similarly for $y$ and $z$.\n\n2.  **Density Field**: The continuous Gaussian overdensity $\\delta(\\mathbf{x})$ is sampled at each grid point to create the discrete density field $\\delta_{ijk} = \\delta(x_i, y_j, z_k)$.\n\n3.  **Forward Fourier Transform**: The discrete density field is transformed to Fourier space using the Fast Fourier Transform (FFT): $\\tilde{\\delta}_{\\mathbf{k}} = \\mathcal{F}[\\delta_{ijk}]$.\n\n4.  **Solve in Fourier Space**: The algebraic form of the Poisson equation in Fourier space is used. The discrete wavenumbers are given by $k_i = 2\\pi n_i/L$, where $n_i$ are the integer frequencies provided by the FFT algorithm. We construct a grid of wavenumber vectors $\\mathbf{k}$ and their squared magnitudes $k^2 = k_x^2+k_y^2+k_z^2$. The Fourier-space potential is then computed:\n    $$ \\tilde{\\phi}_{\\mathbf{k}} = -\\frac{4\\pi}{k^2} \\tilde{\\delta}_{\\mathbf{k}} $$\n    The mode $\\mathbf{k}=\\mathbf{0}$ ($k^2=0$) corresponds to the mean potential. Division by zero is avoided by manually setting $\\tilde{\\phi}(\\mathbf{0}) = 0$. This sets the mean potential to zero, which does not affect the forces, as they depend on the gradient of the potential.\n\n5.  **Spectral Force Calculation**: The force components $\\mathbf{F} = -\\nabla\\phi$ are computed in Fourier space using the spectral derivative property, $\\mathcal{F}[-\\nabla\\phi] = -i\\mathbf{k}\\tilde{\\phi}(\\mathbf{k})$:\n    $$ \\tilde{F}_{x,\\mathbf{k}} = -i k_x \\tilde{\\phi}_{\\mathbf{k}}, \\quad \\tilde{F}_{y,\\mathbf{k}} = -i k_y \\tilde{\\phi}_{\\mathbf{k}}, \\quad \\tilde{F}_{z,\\mathbf{k}} = -i k_z \\tilde{\\phi}_{\\mathbf{k}} $$\n\n6.  **Inverse Fourier Transform**: The force components in real space, $F_x, F_y, F_z$, are recovered by applying the inverse FFT to their Fourier-space counterparts. For a real input field, the resulting force fields must be real; any small imaginary component is due to numerical floating-point errors and is discarded.\n\n7.  **Radial Force Projection**: The final numerical radial force at each grid point $(\\mathbf{x})$ is computed by projecting the vector force field $\\mathbf{F}(\\mathbf{x})$ onto the radial direction vector $\\mathbf{x}$:\n    $$ F_r^{\\text{PM}}(\\mathbf{x}) = \\frac{\\mathbf{F}(\\mathbf{x}) \\cdot \\mathbf{x}}{\\|\\mathbf{x}\\|} \\quad \\text{for } \\|\\mathbf{x}\\|>0, \\quad \\text{and } F_r^{\\text{PM}}(\\mathbf{0})=0 $$\n\n### Part 4: Comparison and Error Metric\n\nThe accuracy of the numerical PM solver is assessed by comparing its output, $F_r^{\\text{PM}}(\\mathbf{x})$, to the derived analytical solution, $F_r^{\\text{analytic}}(r)$, evaluated at the same grid points. The comparison is restricted to the inner region of the box, $r \\le L/4$, to minimize contamination from periodic images inherent in the FFT-based method. The point $r=0$ is excluded. The relative error $\\epsilon(\\mathbf{x})$ at each point is computed as:\n$$ \\epsilon(\\mathbf{x}) = \\frac{|F_r^{\\text{PM}}(\\mathbf{x}) - F_r^{\\text{analytic}}(r)|}{\\max(|F_r^{\\text{analytic}}(r)|, \\varepsilon)} $$\nwhere $\\varepsilon$ is a small regularization constant, chosen as a fraction of the maximum analytical force magnitude, to prevent division by small numbers where the analytical force is close to zero. The final reported metric for each test case is the maximum relative error found within the comparison region.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    def solve_poisson_pm(N, L, sigma, delta_0):\n        \"\"\"\n        Solves the Poisson equation for a Gaussian density profile using a PM method\n        and compares the resulting force field to the analytical solution.\n    \n        Args:\n            N (int): Number of grid points per dimension.\n            L (float): Side length of the cubic domain.\n            sigma (float): Width of the Gaussian overdensity.\n            delta_0 (float): Amplitude of the Gaussian overdensity.\n    \n        Returns:\n            float: The maximum relative error between numerical and analytical force.\n        \"\"\"\n        # 1. Grid and Coordinate Setup\n        dx = L / N\n        # Create coordinates centered at the origin, as specified in the problem.\n        coords = (np.arange(N) - N / 2) * dx\n        xx, yy, zz = np.meshgrid(coords, coords, coords, indexing='ij')\n        r = np.sqrt(xx**2 + yy**2 + zz**2)\n    \n        # 2. Sample Density Field\n        delta_grid = delta_0 * np.exp(-r**2 / (2 * sigma**2))\n    \n        # 3. Fourier-space solution\n        # 3a. Wavenumbers (k-vectors)\n        k_vals = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n        kx, ky, kz = np.meshgrid(k_vals, k_vals, k_vals, indexing='ij')\n        k_squared = kx**2 + ky**2 + kz**2\n    \n        # Avoid division by zero for the k=0 mode.\n        # The value is arbitrary as phi_k[0,0,0] will be set to 0 later.\n        if N > 0:\n            k_squared[0, 0, 0] = 1.0\n    \n        # 3b. FFT of density\n        delta_k = np.fft.fftn(delta_grid)\n    \n        # 3c. Solve for potential in k-space: phi_k = -4 * pi * delta_k / k^2\n        phi_k = -4 * np.pi * delta_k / k_squared\n        \n        # 3d. Set DC mode of potential to zero (fixes arbitrary offset)\n        if N > 0:\n            phi_k[0, 0, 0] = 0.0\n    \n        # 4. Compute Force Field\n        # 4a. Force components in k-space: F_i = -i * k_i * phi\n        Fx_k = -1j * kx * phi_k\n        Fy_k = -1j * ky * phi_k\n        Fz_k = -1j * kz * phi_k\n    \n        # 4b. Inverse FFT to get real-space force components\n        # The result of ifftn should be real; take the real part to discard\n        # machine-precision imaginary noise.\n        Fx = np.fft.ifftn(Fx_k).real\n        Fy = np.fft.ifftn(Fy_k).real\n        Fz = np.fft.ifftn(Fz_k).real\n    \n        # 5. Compute Numerical Radial Force\n        # F_r = (F . r) / |r|. Use np.divide to handle r=0 safely.\n        Fr_pm = np.divide(Fx * xx + Fy * yy + Fz * zz, r, out=np.zeros_like(r), where=(r != 0))\n    \n        # 6. Compute Analytical Radial Force\n        # The limit of F_r(r) as r->0 is 0. Handle r=0 separately.\n        Fr_analytic = np.zeros_like(r)\n        non_zero_r_mask = r > 0\n        r_nz = r[non_zero_r_mask]\n    \n        term1 = (sigma**3 / r_nz**2) * np.sqrt(np.pi / 2.0) * erf(r_nz / (np.sqrt(2.0) * sigma))\n        term2 = (sigma**2 / r_nz) * np.exp(-r_nz**2 / (2.0 * sigma**2))\n        \n        Fr_analytic[non_zero_r_mask] = -4.0 * np.pi * delta_0 * (term1 - term2)\n    \n        # 7. Compare and Compute Maximum Relative Error\n        # Define comparison region: r <= L/4 and r > 0\n        mask = (r <= L / 4) & (r > 0)\n        \n        if not np.any(mask):\n            return 0.0  # No points in comparison region\n    \n        # Calculate the small threshold epsilon to regularize division\n        analytic_force_in_mask = np.abs(Fr_analytic[mask])\n        if analytic_force_in_mask.size == 0:\n             return 0.0\n        \n        max_abs_analytic_force = np.max(analytic_force_in_mask)\n\n        # Handle case where force is zero everywhere (e.g. delta_0 = 0)\n        if max_abs_analytic_force == 0:\n            # If PM force is also zero, error is 0. Otherwise it's infinite.\n            # We expect PM force to be near zero.\n            return np.max(np.abs(Fr_pm[mask]))\n\n        epsilon_threshold = max_abs_analytic_force * 1e-9\n    \n        # Compute relative error\n        numerator = np.abs(Fr_pm[mask] - Fr_analytic[mask])\n        denominator = np.maximum(analytic_force_in_mask, epsilon_threshold)\n        \n        relative_error = numerator / denominator\n        max_relative_error = np.max(relative_error)\n        \n        return max_relative_error\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, sigma, delta_0)\n        (64, 1.0, 0.05, 0.01),      # General case\n        (64, 1.0, 0.05, -0.01),     # Underdensity\n        (128, 1.0, 0.15, 0.02),     # Broad profile\n        (64, 1.0, 1.0 / 64, 0.01),  # Near-grid-resolution width\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, sigma, delta_0 = case\n        error = solve_poisson_pm(N, L, sigma, delta_0)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Once the gravitational potential $\\Phi$ is computed, the physical quantity of interest is often the gravitational acceleration, or force, $\\mathbf{g} = -\\nabla \\Phi$. This seemingly straightforward gradient calculation presents a choice in numerical implementation: should the derivative be computed in Fourier space alongside the potential, or in real space using finite differences on the resulting potential field? This exercise  directly compares these two routes, providing a clear, quantitative measure of the discrepancy and a deeper understanding of the wavenumber-dependent errors inherent in finite-difference approximations versus the precision of a purely spectral approach.",
            "id": "3490043",
            "problem": "You are to evaluate, on a periodic cubic lattice, the consistency between two numerically distinct but analytically equivalent routes to compute the gravitational acceleration field $\\,\\mathbf{g}(\\mathbf{x})\\,$ from a density contrast field $\\,\\delta(\\mathbf{x})\\,$ under the Newtonian Poisson equation in comoving, dimensionless units. The governing equation is the Poisson equation\n$$\n\\nabla^2 \\Phi(\\mathbf{x}) \\;=\\; \\delta(\\mathbf{x}),\n$$\non a periodic domain of side length $\\,L\\,$, where $\\,\\Phi(\\mathbf{x})\\,$ is the gravitational potential and $\\,\\mathbf{g}(\\mathbf{x}) = -\\nabla \\Phi(\\mathbf{x})\\,$ is the gravitational acceleration. Assume $\\,\\int \\delta(\\mathbf{x})\\,d^3x = 0\\,$, so that the zero mode of the potential is set to zero. All quantities are nondimensional and unitless. Angles are measured in radians.\n\nYou will implement both routes on a uniform grid with $\\,N \\times N \\times N\\,$ nodes and periodic boundary conditions:\n\n- Route A (spectral gradient): Solve the Poisson equation in Fourier space using the Discrete Fourier Transform (DFT). If $\\,\\tilde{f}(\\mathbf{k})\\,$ denotes the DFT of $\\,f(\\mathbf{x})\\,$, and $\\,\\mathbf{k}=(k_x,k_y,k_z)\\,$ is the angular wavevector associated with DFT frequency indices, the solution for nonzero modes is\n$$\n\\tilde{\\Phi}(\\mathbf{k}) \\;=\\; -\\,\\frac{\\tilde{\\delta}(\\mathbf{k})}{k_x^2 + k_y^2 + k_z^2}.\n$$\nSet $\\,\\tilde{\\Phi}(\\mathbf{0})=0\\,$. Then compute the gravitational acceleration via the inverse DFT of the spectral gradient:\n$$\n\\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\;=\\; \\mathcal{F}^{-1}\\!\\left[ -\\,i\\,\\mathbf{k}\\,\\tilde{\\Phi}(\\mathbf{k}) \\right].\n$$\n\n- Route B (finite-difference gradient): Using the same $\\,\\tilde{\\Phi}(\\mathbf{k})\\,$ as above, compute $\\,\\Phi(\\mathbf{x})\\,$ by inverse DFT and then approximate the gradient by second-order accurate centered finite differences with periodic boundaries. With grid spacing $\\,\\Delta x = L/N\\,$ and unit vectors $\\,\\hat{e}_j\\,$, the component $\\,j \\in \\{x,y,z\\}\\,$ is\n$$\ng_{\\mathrm{fd},j}(\\mathbf{x}) \\;=\\; -\\,\\frac{ \\Phi(\\mathbf{x}+\\Delta x\\,\\hat{e}_j) \\;-\\; \\Phi(\\mathbf{x}-\\Delta x\\,\\hat{e}_j) }{ 2\\,\\Delta x }.\n$$\n\nQuantify the discrepancy between the two routes by the relative root-mean-square norm\n$$\n\\varepsilon \\;=\\; \\frac{ \\left\\langle \\| \\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) - \\mathbf{g}_{\\mathrm{fd}}(\\mathbf{x}) \\|^2 \\right\\rangle^{1/2} }{ \\left\\langle \\| \\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\|^2 \\right\\rangle^{1/2} },\n$$\nwhere $\\,\\langle \\cdot \\rangle\\,$ denotes the average over all grid points and $\\,\\|\\cdot\\|\\,$ is the Euclidean norm in component space.\n\nUse the standard DFT frequency-to-wavenumber mapping consistent with a unitary inverse-DFT normalization. If $\\,\\nu\\,$ denotes the cyclic frequency in cycles per unit length, then the angular wavenumber is $\\,k = 2\\pi \\nu\\,$. Use exactly this mapping for constructing $\\,\\mathbf{k}\\,$ on the DFT grid, and be careful at the zero mode.\n\nYour program must implement the following test suite, construct $\\,\\delta(\\mathbf{x})\\,$ for each case, compute $\\,\\varepsilon\\,$, and report the results. All fields live on the grid nodes at positions $\\,x_j = j\\,\\Delta x\\,$, $\\,y_j = j\\,\\Delta x\\,$, $\\,z_j = j\\,\\Delta x\\,$ with $\\,j \\in \\{0,\\dots,N-1\\}\\,$.\n\nTest suite:\n\n- Case $\\,1\\,$ (single low-frequency plane wave): $\\,N=32\\,$, $\\,L=1\\,$, $\\,\\delta(\\mathbf{x}) = \\cos\\big(2\\pi\\,(1\\,x + 2\\,y + 3\\,z)\\big)\\,$.\n\n- Case $\\,2\\,$ (sum of anisotropic modes with phases): $\\,N=48\\,$, $\\,L=1\\,$, \n$$\n\\delta(\\mathbf{x}) \\;=\\; \\sum_{m=1}^{4} A_m \\cos\\!\\Big(2\\pi\\,(\\mathbf{n}_m \\cdot \\mathbf{x}) + \\varphi_m\\Big),\n$$\nwith amplitudes $\\,A_1=0.5\\,$, $\\,A_2=0.7\\,$, $\\,A_3=0.9\\,$, $\\,A_4=0.4\\,$, integer vectors $\\,\\mathbf{n}_1=(3,0,0)\\,$, $\\,\\mathbf{n}_2=(0,5,0)\\,$, $\\,\\mathbf{n}_3=(0,0,7)\\,$, $\\,\\mathbf{n}_4=(2,3,1)\\,$, and phases $\\,\\varphi_1=0.1\\,$, $\\,\\varphi_2=-0.3\\,$, $\\,\\varphi_3=0.5\\,$, $\\,\\varphi_4=1.1\\,$.\n\n- Case $\\,3\\,$ (near-Nyquist along one axis): $\\,N=32\\,$, $\\,L=1\\,$, $\\,\\delta(\\mathbf{x}) = \\cos\\big(2\\pi\\,(15\\,x)\\big)\\,$.\n\n- Case $\\,4\\,$ (off-axis high anisotropy): $\\,N=64\\,$, $\\,L=1\\,$, $\\,\\delta(\\mathbf{x}) = \\cos\\big(2\\pi\\,(30\\,y + 1\\,z)\\big)\\,$.\n\nImplementation constraints and output specification:\n\n- Use the Discrete Fourier Transform consistent with a Fast Fourier Transform (FFT) pair whose inverse transform is normalized by $\\,1/N^3\\,$ so that Parseval’s theorem holds with standard numerical factors. Construct $\\,\\mathbf{k}\\,$ from the DFT frequencies using $\\,k=2\\pi \\nu\\,$.\n\n- For each case, compute $\\,\\varepsilon\\,$ as defined above. Your program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets, with each float rounded to $8$ decimal places and expressed in decimal notation (not scientific notation), in the order of Cases $\\,1\\,$ through $\\,4\\,$. For example: $\\,\\big[0.00001234,0.05670000,0.12340000,0.98765000\\big]\\,$.\n\n- No user input is required. The program must be deterministic.\n\n- All quantities are dimensionless, so no physical units need to be reported.",
            "solution": "We start from the Newtonian Poisson equation in nondimensionalized units on a periodic domain of side length $\\,L\\,$:\n$$\n\\nabla^2 \\Phi(\\mathbf{x}) \\;=\\; \\delta(\\mathbf{x}),\n$$\nand define the gravitational acceleration as $\\,\\mathbf{g}(\\mathbf{x}) = -\\nabla \\Phi(\\mathbf{x})\\,$. On a periodic domain, it is convenient to work in Fourier space. Denote by $\\,\\mathcal{F}\\,$ the Discrete Fourier Transform (DFT) and by $\\,\\mathcal{F}^{-1}\\,$ its inverse. Let $\\,\\tilde{f}(\\mathbf{k})\\,$ be the DFT of $\\,f(\\mathbf{x})\\,$, where the Fourier-space grid labels $\\,\\mathbf{k}=(k_x,k_y,k_z)\\,$ are constructed from the DFT cyclic frequencies $\\,\\nu\\,$ via $\\,k=2\\pi \\nu\\,$. The DFT derivative property mirrors the continuous one: $\\,\\mathcal{F}\\!\\left[\\partial_j f\\right]= i k_j \\tilde{f}\\,$ and $\\,\\mathcal{F}\\!\\left[\\nabla^2 f\\right]= - (k_x^2+k_y^2+k_z^2)\\,\\tilde{f}\\,$. Therefore, for all nonzero wavevectors,\n$$\n\\tilde{\\Phi}(\\mathbf{k}) \\;=\\; -\\frac{\\tilde{\\delta}(\\mathbf{k})}{k_x^2 + k_y^2 + k_z^2}, \\quad \\tilde{\\Phi}(\\mathbf{0}) = 0,\n$$\nand the spectral-gradient acceleration is\n$$\n\\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\;=\\; \\mathcal{F}^{-1}\\!\\left[ -\\,i\\,\\mathbf{k}\\,\\tilde{\\Phi}(\\mathbf{k}) \\right].\n$$\nThis route is spectrally exact for modes represented on the grid, up to floating-point roundoff.\n\nAlternatively, we compute the potential in real space via $\\,\\Phi(\\mathbf{x})=\\mathcal{F}^{-1}[\\tilde{\\Phi}(\\mathbf{k})]\\,$ and approximate the gradient by the centered finite-difference operator with periodic boundary conditions,\n$$\n\\left(\\nabla \\Phi\\right)_j(\\mathbf{x}) \\;\\approx\\; \\frac{\\Phi(\\mathbf{x}+\\Delta x\\,\\hat{e}_j) - \\Phi(\\mathbf{x}-\\Delta x\\,\\hat{e}_j)}{2\\,\\Delta x}, \\qquad \\Delta x = \\frac{L}{N}.\n$$\nThus,\n$$\n\\mathbf{g}_{\\mathrm{fd}}(\\mathbf{x}) \\;=\\; -\\,\\left( D_x \\Phi(\\mathbf{x}),\\, D_y \\Phi(\\mathbf{x}),\\, D_z \\Phi(\\mathbf{x}) \\right),\n$$\nwith each component computed by the centered stencil. The centered finite difference is a second-order accurate approximation to the derivative, so the local truncation error scales as $\\,\\mathcal{O}(\\Delta x^2)\\,$ for sufficiently smooth fields. However, the discrete dispersion of the finite-difference derivative differs from the spectral derivative, introducing a deterministic discrepancy that depends on wavenumber.\n\nTo quantify the discrepancy, we use the relative root-mean-square (RMS) norm\n$$\n\\varepsilon \\;=\\; \\frac{ \\left\\langle \\| \\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) - \\mathbf{g}_{\\mathrm{fd}}(\\mathbf{x}) \\|^2 \\right\\rangle^{1/2} }{ \\left\\langle \\| \\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\|^2 \\right\\rangle^{1/2} }.\n$$\nThis dimensionless metric is invariant under uniform rescaling of $\\,\\delta(\\mathbf{x})\\,$ and directly compares the two routes.\n\nFor analytical insight, consider a single plane-wave density field $\\,\\delta(\\mathbf{x})=\\cos(\\mathbf{k}_0\\cdot\\mathbf{x})\\,$ with $\\,\\mathbf{k}_0=(k_{0x},k_{0y},k_{0z})\\,$ equal to a grid-resolved angular wavenumber vector. The potential is $\\,\\Phi(\\mathbf{x})=-\\cos(\\mathbf{k}_0\\cdot\\mathbf{x})/\\|\\mathbf{k}_0\\|^2\\,$. The spectral gradient is\n$$\n\\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\;=\\; -\\,\\nabla \\Phi(\\mathbf{x}) \\;=\\; -\\,\\frac{\\mathbf{k}_0}{\\|\\mathbf{k}_0\\|^2}\\,\\sin(\\mathbf{k}_0\\cdot\\mathbf{x}).\n$$\nThe centered finite-difference derivative along component $\\,j\\,$ applied to a plane wave introduces the symbol $\\,\\frac{\\sin(k_{0j}\\Delta x)}{\\Delta x}\\,$ in place of the spectral factor $\\,k_{0j}\\,$. Therefore,\n$$\ng_{\\mathrm{fd},j}(\\mathbf{x}) \\;=\\; -\\,\\frac{\\sin(k_{0j}\\Delta x)}{\\Delta x\\,\\|\\mathbf{k}_0\\|^2}\\,\\sin(\\mathbf{k}_0\\cdot\\mathbf{x})\n\\;=\\; \\left(\\frac{\\sin(k_{0j}\\Delta x)}{k_{0j}\\Delta x}\\right)\\,g_{\\mathrm{spec},j}(\\mathbf{x}),\n$$\nwith the convention that the factor equals $\\,1\\,$ if $\\,k_{0j}=0\\,$. Thus, for each component,\n$$\n\\frac{g_{\\mathrm{fd},j}}{g_{\\mathrm{spec},j}} \\;=\\; \\operatorname{sinc}\\!\\left(\\frac{k_{0j}\\Delta x}{\\pi}\\right) \\;=\\; \\frac{\\sin(k_{0j}\\Delta x)}{k_{0j}\\Delta x},\n$$\nand the vector discrepancy in RMS depends on the orientation of $\\,\\mathbf{k}_0\\,$ through these component-wise factors. For small $\\,\\|\\mathbf{k}_0\\|\\Delta x\\,$, the Taylor series $\\,\\sin(\\xi)/\\xi = 1 - \\xi^2/6 + \\mathcal{O}(\\xi^4)\\,$ shows that the relative error scales as $\\,\\mathcal{O}(\\Delta x^2)\\,$. Near the Nyquist wavenumber, $\\,k\\Delta x \\to \\pi\\,$, the ratio approaches $\\,0\\,$ and the discrepancy approaches order unity.\n\nAlgorithmic design for each test case:\n\n- Construct the $\\,N \\times N \\times N\\,$ grid with spacing $\\,\\Delta x = L/N\\,$ and node coordinates $\\,x_j=j\\Delta x\\,$, $\\,y_j=j\\Delta x\\,$, $\\,z_j=j\\Delta x\\,$ for $\\,j\\in\\{0,\\dots,N-1\\}\\,$.\n\n- Build $\\,\\delta(\\mathbf{x})\\,$ according to the case definition. For integer mode vectors $\\,\\mathbf{n}\\,$, the angular wavenumber is $\\,\\mathbf{k}_0 = 2\\pi\\,\\mathbf{n}/L\\,$, so $\\,\\delta(\\mathbf{x})=\\cos(\\mathbf{k}_0\\cdot\\mathbf{x}+\\varphi)\\,$.\n\n- Compute $\\,\\tilde{\\delta}(\\mathbf{k})\\,$ via the DFT. Construct arrays $\\,k_x\\,$, $\\,k_y\\,$, $\\,k_z\\,$ from the DFT cyclic frequencies $\\,\\nu\\,$ mapped by $\\,k=2\\pi\\nu\\,$ along each axis and broadcast them to the three-dimensional Fourier grid.\n\n- Compute $\\,\\tilde{\\Phi}(\\mathbf{k}) = -\\tilde{\\delta}(\\mathbf{k})/(k_x^2+k_y^2+k_z^2)\\,$ for all nonzero wavevectors and set the zero mode to zero. In practice, set the denominator at the zero index to $+\\infty$ so that the division yields zero.\n\n- Route A: compute $\\,\\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x})\\,$ by inverse transforming each component of $\\, -i\\,k_j\\,\\tilde{\\Phi}(\\mathbf{k})\\,$.\n\n- Route B: compute $\\,\\Phi(\\mathbf{x})\\,$ by inverse DFT of $\\,\\tilde{\\Phi}(\\mathbf{k})\\,$, then compute centered finite differences with periodic shifts to obtain $\\,\\mathbf{g}_{\\mathrm{fd}}(\\mathbf{x})=-\\nabla \\Phi(\\mathbf{x})\\,$.\n\n- Compute $\\,\\varepsilon\\,$ as the ratio of RMS norms defined above. The numerator is the square root of the mean over all grid nodes of the squared Euclidean norm of the difference vector $\\,\\mathbf{g}_{\\mathrm{spec}}-\\mathbf{g}_{\\mathrm{fd}}\\,$, and the denominator is the RMS norm of $\\,\\mathbf{g}_{\\mathrm{spec}}\\,$.\n\nThe test suite exercises several regimes: a low-frequency anisotropic mode where $\\,\\varepsilon\\,$ should be small and scale as $\\,\\mathcal{O}(\\Delta x^2)\\,$, a sum of modes with phases to test linear superposition and anisotropy, a near-Nyquist mode where the centered finite-difference derivative is strongly damped relative to the spectral derivative leading to a large $\\,\\varepsilon\\,$, and an off-axis high-anisotropy case where different components experience different discrete symbols. The program implements this pipeline and prints the four $\\,\\varepsilon\\,$ values, each rounded to $\\,8\\,$ decimal places, as a single bracketed, comma-separated list in the requested order.",
            "answer": "```python\nimport numpy as np\n\ndef construct_k_arrays(N, L):\n    # Construct angular wavenumbers k = 2*pi*nu for each axis using DFT frequencies.\n    dx = L / N\n    # np.fft.fftfreq returns frequencies in cycles per unit length; d=dx ensures correct scaling.\n    freq = np.fft.fftfreq(N, d=dx)  # cycles per unit length\n    k1d = 2.0 * np.pi * freq        # angular wavenumbers\n    kx = k1d[:, None, None]\n    ky = k1d[None, :, None]\n    kz = k1d[None, None, :]\n    return kx, ky, kz\n\ndef spectral_poisson_phi(delta, L):\n    N = delta.shape[0]\n    # Forward FFT to Fourier space\n    delta_k = np.fft.fftn(delta)\n    # Construct k arrays\n    kx, ky, kz = construct_k_arrays(N, L)\n    k2 = kx**2 + ky**2 + kz**2\n    # Avoid division by zero at the zero mode by setting denominator to inf there\n    k2_safe = k2.copy()\n    k2_safe[0, 0, 0] = np.inf\n    phi_k = - delta_k / k2_safe\n    return phi_k, (kx, ky, kz)\n\ndef spectral_gradient_from_phi_k(phi_k, k_arrays):\n    kx, ky, kz = k_arrays\n    # Compute spectral gradient components and inverse FFT to real space\n    gx = np.fft.ifftn(-1j * kx * phi_k).real\n    gy = np.fft.ifftn(-1j * ky * phi_k).real\n    gz = np.fft.ifftn(-1j * kz * phi_k).real\n    return gx, gy, gz\n\ndef finite_difference_gradient_from_phi(phi, L):\n    N = phi.shape[0]\n    dx = L / N\n    # Centered differences with periodic boundaries\n    dphidx = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2.0 * dx)\n    dphidy = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * dx)\n    dphidz = (np.roll(phi, -1, axis=2) - np.roll(phi, 1, axis=2)) / (2.0 * dx)\n    # Acceleration g = -grad Phi\n    gx = -dphidx\n    gy = -dphidy\n    gz = -dphidz\n    return gx, gy, gz\n\ndef relative_rms_error(g_spec, g_fd):\n    gx_s, gy_s, gz_s = g_spec\n    gx_f, gy_f, gz_f = g_fd\n    # Compute RMS norms\n    diff_sq = (gx_s - gx_f)**2 + (gy_s - gy_f)**2 + (gz_s - gz_f)**2\n    spec_sq = gx_s**2 + gy_s**2 + gz_s**2\n    # Avoid division by zero in pathological cases by adding tiny epsilon, though spec_sq should be >0 for nontrivial fields\n    num = np.sqrt(np.mean(diff_sq))\n    den = np.sqrt(np.mean(spec_sq))\n    # If den is zero (shouldn't happen with our test cases), define error as 0.0 to keep determinism\n    if den == 0.0:\n        return 0.0\n    return float(num / den)\n\ndef build_delta_case(case_id):\n    # Returns N, L, delta(x)\n    if case_id == 1:\n        N, L = 32, 1.0\n        # delta = cos(2*pi*(1*x + 2*y + 3*z))\n        x = np.arange(N) * (L / N)\n        X, Y, Z = np.meshgrid(x, x, x, indexing='ij')\n        delta = np.cos(2.0 * np.pi * (1.0 * X + 2.0 * Y + 3.0 * Z))\n        return N, L, delta\n    elif case_id == 2:\n        N, L = 48, 1.0\n        # Sum of modes with amplitudes and phases\n        amps = [0.5, 0.7, 0.9, 0.4]\n        ns = [(3, 0, 0), (0, 5, 0), (0, 0, 7), (2, 3, 1)]\n        phases = [0.1, -0.3, 0.5, 1.1]  # radians\n        x = np.arange(N) * (L / N)\n        X, Y, Z = np.meshgrid(x, x, x, indexing='ij')\n        delta = np.zeros((N, N, N), dtype=np.float64)\n        for A, (nx, ny, nz), phi in zip(amps, ns, phases):\n            arg = 2.0 * np.pi * (nx * X + ny * Y + nz * Z) + phi\n            delta += A * np.cos(arg)\n        return N, L, delta\n    elif case_id == 3:\n        N, L = 32, 1.0\n        # Near-Nyquist along x: delta = cos(2*pi*(15*x))\n        x = np.arange(N) * (L / N)\n        X, Y, Z = np.meshgrid(x, x, x, indexing='ij')\n        delta = np.cos(2.0 * np.pi * (15.0 * X))\n        return N, L, delta\n    elif case_id == 4:\n        N, L = 64, 1.0\n        # Off-axis high anisotropy: delta = cos(2*pi*(30*y + 1*z))\n        x = np.arange(N) * (L / N)\n        X, Y, Z = np.meshgrid(x, x, x, indexing='ij')\n        delta = np.cos(2.0 * np.pi * (30.0 * Y + 1.0 * Z))\n        return N, L, delta\n    else:\n        raise ValueError(\"Unknown case id\")\n\ndef compute_case_error(case_id):\n    N, L, delta = build_delta_case(case_id)\n    # Solve Poisson in Fourier space\n    phi_k, k_arrays = spectral_poisson_phi(delta, L)\n    # Route A: spectral gradient\n    g_spec = spectral_gradient_from_phi_k(phi_k, k_arrays)\n    # Route B: finite difference gradient\n    phi = np.fft.ifftn(phi_k).real\n    g_fd = finite_difference_gradient_from_phi(phi, L)\n    # Relative RMS error\n    err = relative_rms_error(g_spec, g_fd)\n    return err\n\ndef format_float_list(values, decimals=8):\n    # Format list of floats to fixed decimal places without scientific notation\n    fmt = f\"{{:.{decimals}f}}\"\n    return \"[\" + \",\".join(fmt.format(v) for v in values) + \"]\"\n\ndef solve():\n    test_cases = [1, 2, 3, 4]\n    results = []\n    for cid in test_cases:\n        err = compute_case_error(cid)\n        results.append(err)\n    print(format_float_list(results, decimals=8))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Moving from idealized tests to more practical scenarios, this exercise addresses a subtle but critical aspect of real N-body simulations: the handling of the mean background density, $\\bar{\\rho}$. The definition of the overdensity, $\\delta = (\\rho - \\bar{\\rho})/\\bar{\\rho}$, hinges on this value, which may not be known perfectly. This practice  demonstrates how a small error in the assumed mean density can propagate into the final potential field, and it highlights the importance of maintaining consistency in your numerical scheme to avoid unphysical results related to the treatment of the $k=0$ mode.",
            "id": "3490042",
            "problem": "Consider a three-dimensional periodic cubic domain of side length $L$ with a uniform grid of $N \\times N \\times N$ points. Let the matter density field be $\\rho(\\mathbf{x}) = \\bar{\\rho}\\left(1 + \\delta_{\\text{true}}(\\mathbf{x})\\right)$, where $\\bar{\\rho}$ is the true global mean density and $\\delta_{\\text{true}}(\\mathbf{x})$ is a synthetic overdensity field defined by two cosine modes. In numerical cosmology, the Newtonian potential $\\Phi(\\mathbf{x})$ in comoving coordinates is determined by the Poisson equation\n$$\n\\nabla^2 \\Phi(\\mathbf{x}) = 4 \\pi G a^2 \\bar{\\rho}\\, \\delta(\\mathbf{x}),\n$$\nwhere $G$ is the gravitational constant, $a$ is the scale factor, and $\\delta(\\mathbf{x})$ is the dimensionless overdensity defined as $\\delta(\\mathbf{x}) = \\left(\\rho(\\mathbf{x}) - \\bar{\\rho}\\right)/\\bar{\\rho}$. In this problem, work in code units with $4 \\pi G a^2 = 1$ and $\\bar{\\rho}$ dimensionless. The Fourier-space (Fast Fourier Transform (FFT)) solution enforces periodic boundary conditions and stems from the spatial Fourier transform of the Poisson equation:\n$$\n-k^2 \\,\\hat{\\Phi}(\\mathbf{k}) = \\bar{\\rho}\\, \\hat{\\delta}(\\mathbf{k}),\n$$\nfor all nonzero wave vectors $\\mathbf{k}$, where hats denote Fourier transforms, and $k = \\|\\mathbf{k}\\|$. The zero mode $k=0$ has no unique solution and corresponds to a constant offset of $\\Phi(\\mathbf{x})$ that is physically irrelevant for forces derived from gradients. In practice, numerical solvers set $\\hat{\\Phi}(\\mathbf{0}) = 0$.\n\nA robust implementation must compute $\\delta(\\mathbf{x})$ via $\\delta(\\mathbf{x}) = (\\rho(\\mathbf{x}) - \\bar{\\rho}_{\\text{used}})/\\bar{\\rho}_{\\text{used}}$, where $\\bar{\\rho}_{\\text{used}}$ is the mean-density value used by the solver. Suppose the solver may use an estimated mean $\\bar{\\rho}_{\\text{est}} = \\bar{\\rho} (1 + \\epsilon)$ with a small fractional error $\\epsilon$ instead of the true mean $\\bar{\\rho}$. Consider two algorithmic treatments:\n1. Consistent: use the same $\\bar{\\rho}_{\\text{used}} = \\bar{\\rho}_{\\text{est}}$ both to compute $\\delta(\\mathbf{x})$ and to scale the source term in the Poisson equation in Fourier space.\n2. Inconsistent: use $\\bar{\\rho}_{\\text{used}} = \\bar{\\rho}$ to scale the source term in Fourier space, but compute $\\delta(\\mathbf{x})$ using $\\bar{\\rho}_{\\text{est}}$.\n\nStarting from the above fundamental definitions, derive a Fourier-space solver for the Poisson equation on the periodic grid. Then, demonstrate numerically how the choice of $\\bar{\\rho}_{\\text{used}}$ and the consistency between constructing $\\delta(\\mathbf{x})$ and scaling the source term affect the solution. In particular, quantify the following three diagnostics for each test case:\n- The relative $\\ell_2$ error in the real-space potential, defined as\n$$\n\\text{err}_{\\Phi} \\equiv \\frac{\\|\\Phi_{\\text{case}} - \\Phi_{\\text{baseline}}\\|_2}{\\|\\Phi_{\\text{baseline}}\\|_2},\n$$\nwhere the baseline uses $\\epsilon=0$ and the consistent treatment.\n- The ratio of the magnitude of the zero-mode of the Fourier-space source $\\hat{S}(\\mathbf{k}) = \\bar{\\rho}_{\\text{used}}\\, \\hat{\\delta}(\\mathbf{k})$ to the magnitude at the strongest nonzero mode present in the baseline source,\n$$\nr_{0} \\equiv \\frac{\\left|\\hat{S}_{\\text{case}}(\\mathbf{0})\\right|}{\\max_{\\mathbf{k}\\neq \\mathbf{0}} \\left|\\hat{S}_{\\text{baseline}}(\\mathbf{k})\\right|}.\n$$\n- The difference in the mean of the real-space potential,\n$$\n\\Delta \\bar{\\Phi} \\equiv \\langle \\Phi_{\\text{case}} \\rangle - \\langle \\Phi_{\\text{baseline}} \\rangle,\n$$\nwhere angle brackets denote the spatial average.\n\nUse the following synthetic overdensity, grid, and domain specifications to construct $\\delta_{\\text{true}}(\\mathbf{x})$ and $\\rho(\\mathbf{x})$:\n- Domain size: $L = 1$ (dimensionless).\n- Grid resolution: $N = 32$ points per dimension.\n- True mean density: $\\bar{\\rho} = 1$ (dimensionless).\n- Overdensity field:\n$$\n\\delta_{\\text{true}}(\\mathbf{x}) = A_1 \\cos\\left(2\\pi n_1 \\frac{x}{L}\\right) + A_2 \\cos\\left(2\\pi \\left(n_2 \\frac{y}{L} + n_3 \\frac{z}{L}\\right)\\right),\n$$\nwith amplitudes $A_1 = 0.2$, $A_2 = 0.1$ and integer mode indices $(n_1, n_2, n_3) = (2, 3, 2)$.\n\nImplement the Fourier-space Poisson solver by computing $\\hat{\\Phi}(\\mathbf{k}) = -\\hat{S}(\\mathbf{k})/k^2$ for all $\\mathbf{k}\\neq \\mathbf{0}$ and setting $\\hat{\\Phi}(\\mathbf{0}) = 0$. Transform back to real space to obtain $\\Phi(\\mathbf{x})$.\n\nTest Suite:\nEvaluate the three diagnostics $\\left[\\text{err}_{\\Phi}, r_{0}, \\Delta \\bar{\\Phi}\\right]$ for the following five test cases, each specified by $(\\epsilon, \\text{consistent})$:\n1. $(0.0,\\ \\text{True})$.\n2. $(10^{-3},\\ \\text{True})$.\n3. $(10^{-3},\\ \\text{False})$.\n4. $(-0.05,\\ \\text{False})$.\n5. $(0.1,\\ \\text{False})$.\n\nAll quantities are dimensionless in the chosen code units. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a comma-separated list enclosed in square brackets. For example, the output format must be\n$$\n[\\,[r_{1,1},r_{1,2},r_{1,3}],\\,[r_{2,1},r_{2,2},r_{2,3}],\\,\\dots\\,],\n$$\nwith no spaces anywhere in the line. Each $r_{i,j}$ must be a floating-point number.",
            "solution": "### 1. Theoretical Framework\n\n**a. The Poisson Equation and its Fourier Solution:**\nThe problem starts with the Poisson equation for the Newtonian potential $\\Phi(\\mathbf{x})$ in comoving coordinates:\n$$ \\nabla^2 \\Phi(\\mathbf{x}) = 4 \\pi G a^2 \\bar{\\rho}\\, \\delta(\\mathbf{x}) $$\nWe are given to work in code units where the constant prefactor $4 \\pi G a^2 = 1$. The true overdensity is $\\delta_{\\text{true}}(\\mathbf{x}) = (\\rho(\\mathbf{x}) - \\bar{\\rho})/\\bar{\\rho}$, where $\\rho(\\mathbf{x})$ is the true matter density field and $\\bar{\\rho}$ is its true mean. The equation simplifies to:\n$$ \\nabla^2 \\Phi(\\mathbf{x}) = \\bar{\\rho}\\, \\delta(\\mathbf{x}) $$\nFor a periodic domain, this equation is most efficiently solved using the Fourier transform. The Fourier transform of a function $f(\\mathbf{x})$ is denoted $\\hat{f}(\\mathbf{k})$. The Laplacian operator $\\nabla^2$ becomes multiplication by $-k^2$ in Fourier space, where $k = \\|\\mathbf{k}\\|$ is the magnitude of the wave vector $\\mathbf{k}$. Applying the Fourier transform to the Poisson equation yields:\n$$ -k^2 \\hat{\\Phi}(\\mathbf{k}) = \\widehat{(\\bar{\\rho}\\,\\delta)}(\\mathbf{k}) $$\nAssuming $\\bar{\\rho}$ is a constant, we define the source term in Fourier space as $\\hat{S}(\\mathbf{k}) = \\bar{\\rho} \\, \\hat{\\delta}(\\mathbf{k})$. The equation becomes:\n$$ -k^2 \\hat{\\Phi}(\\mathbf{k}) = \\hat{S}(\\mathbf{k}) $$\nFor any non-zero wave vector $\\mathbf{k} \\neq \\mathbf{0}$, we can solve for the potential in Fourier space:\n$$ \\hat{\\Phi}(\\mathbf{k}) = - \\frac{\\hat{S}(\\mathbf{k})}{k^2} $$\nThe case $\\mathbf{k}=\\mathbf{0}$ corresponds to the DC component or spatial mean. For $k=0$, the equation becomes $0 = \\hat{S}(\\mathbf{0})$. If the mean of the source term $\\hat{S}(\\mathbf{0})$ is non-zero, the equation is inconsistent. If $\\hat{S}(\\mathbf{0})=0$, then $\\hat{\\Phi}(\\mathbf{0})$ is undetermined. This ambiguity corresponds to the freedom to add an arbitrary constant to the potential $\\Phi(\\mathbf{x})$, which does not affect physical forces derived from its gradient, $\\mathbf{g} = -\\nabla\\Phi$. As specified, the standard numerical practice is to fix this ambiguity by setting $\\hat{\\Phi}(\\mathbf{0}) = 0$.\n\n**b. Grid and Discretization:**\nWe operate on a discrete grid of $N \\times N \\times N$ points in a cube of side length $L$.\n- Real space coordinates: $\\mathbf{x}_{ijk} = (i \\frac{L}{N}, j \\frac{L}{N}, k \\frac{L}{N})$ for $i,j,k \\in \\{0, ..., N-1\\}$.\n- Fourier space wave vectors: The corresponding wave vectors are given by $\\mathbf{k}_{lmn} = (2\\pi \\frac{l}{L}, 2\\pi \\frac{m}{L}, 2\\pi \\frac{n}{L})$, where $l,m,n$ are integer frequencies provided by `numpy.fft.fftfreq`.\n\n**c. Overdensity Calculation and Algorithmic Treatments:**\nThe true density field is given by $\\rho(\\mathbf{x}) = \\bar{\\rho}(1 + \\delta_{\\text{true}}(\\mathbf{x}))$. A numerical solver might use an estimated mean density $\\bar{\\rho}_{\\text{est}} = \\bar{\\rho}(1+\\epsilon)$. The overdensity field computed by the solver is then:\n$$ \\delta_{\\text{case}}(\\mathbf{x}) = \\frac{\\rho(\\mathbf{x}) - \\bar{\\rho}_{\\text{est}}}{\\bar{\\rho}_{\\text{est}}} = \\frac{\\bar{\\rho}(1+\\delta_{\\text{true}}(\\mathbf{x})) - \\bar{\\rho}(1+\\epsilon)}{\\bar{\\rho}(1+\\epsilon)} = \\frac{\\delta_{\\text{true}}(\\mathbf{x}) - \\epsilon}{1+\\epsilon} $$\nTaking the Fourier transform, and noting that the transform of a constant $C$ is $C N^3 \\delta_{\\mathbf{k}, \\mathbf{0}}$ (where $\\delta_{\\mathbf{k}, \\mathbf{0}}$ is the Kronecker delta):\n$$ \\hat{\\delta}_{\\text{case}}(\\mathbf{k}) = \\frac{\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) - \\epsilon N^3 \\delta_{\\mathbf{k}, \\mathbf{0}}}{1+\\epsilon} $$\nThe problem defines two treatments for the source term $\\hat{S}(\\mathbf{k})$:\n1.  **Consistent**: $\\bar{\\rho}_{\\text{used}} = \\bar{\\rho}_{\\text{est}}$. The source term is $\\hat{S}_{\\text{cons}}(\\mathbf{k}) = \\bar{\\rho}_{\\text{est}} \\hat{\\delta}_{\\text{case}}(\\mathbf{k}) = \\bar{\\rho}(1+\\epsilon) \\frac{\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) - \\epsilon N^3 \\delta_{\\mathbf{k}, \\mathbf{0}}}{1+\\epsilon} = \\bar{\\rho}(\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) - \\epsilon N^3 \\delta_{\\mathbf{k}, \\mathbf{0}})$.\n2.  **Inconsistent**: $\\bar{\\rho}_{\\text{used}} = \\bar{\\rho}$. The source term is $\\hat{S}_{\\text{incons}}(\\mathbf{k}) = \\bar{\\rho} \\hat{\\delta}_{\\text{case}}(\\mathbf{k}) = \\bar{\\rho} \\frac{\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) - \\epsilon N^3 \\delta_{\\mathbf{k}, \\mathbf{0}}}{1+\\epsilon}$.\n\n**d. Analysis of Diagnostics:**\nThe baseline case corresponds to $\\epsilon=0$, where $\\bar{\\rho}_{\\text{est}} = \\bar{\\rho}$ and the treatment is consistent. In this case, $\\delta_{\\text{case}}=\\delta_{\\text{true}}$ and $\\hat{S}_{\\text{baseline}}(\\mathbf{k}) = \\bar{\\rho}\\hat{\\delta}_{\\text{true}}(\\mathbf{k})$. Since $\\delta_{\\text{true}}$ is a sum of cosines, its spatial average is zero, so $\\hat{\\delta}_{\\text{true}}(\\mathbf{0})=0$ and thus $\\hat{S}_{\\text{baseline}}(\\mathbf{0})=0$.\n\n-   **Mean Potential Difference $\\Delta \\bar{\\Phi}$**: The spatial average of any field $\\Phi(\\mathbf{x})$ on the discrete grid is $\\langle\\Phi\\rangle = \\frac{1}{N^3}\\sum_\\mathbf{x} \\Phi(\\mathbf{x})$. Due to the properties of the Discrete Fourier Transform, $\\sum_\\mathbf{x} \\Phi(\\mathbf{x}) = \\hat{\\Phi}(\\mathbf{0})$. Thus, $\\langle\\Phi\\rangle = \\hat{\\Phi}(\\mathbf{0})/N^3$. As the problem explicitly requires setting $\\hat{\\Phi}(\\mathbf{0}) = 0$ for all cases (baseline and others), the mean potential will be zero for every case. Therefore, $\\Delta \\bar{\\Phi} \\equiv \\langle \\Phi_{\\text{case}} \\rangle - \\langle \\Phi_{\\text{baseline}} \\rangle = 0 - 0 = 0$ for all test cases.\n\n-   **Relative Error $\\text{err}_{\\Phi}$**:\n    -   **Consistent Treatment**: For $\\mathbf{k} \\neq \\mathbf{0}$, $\\hat{S}_{\\text{cons}}(\\mathbf{k}) = \\bar{\\rho}\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) = \\hat{S}_{\\text{baseline}}(\\mathbf{k})$. For $\\mathbf{k}=\\mathbf{0}$, $\\hat{S}_{\\text{cons}}(\\mathbf{0}) = -\\bar{\\rho}\\epsilon N^3 \\neq 0$. The potential $\\hat{\\Phi}$ is obtained by dividing by $-k^2$ for $\\mathbf{k} \\neq \\mathbf{0}$ and setting the $\\mathbf{k}=\\mathbf{0}$ component to zero. Since the source terms match for all $\\mathbf{k} \\neq \\mathbf{0}$, and both $\\hat{\\Phi}_{\\text{cons}}(\\mathbf{0})$ and $\\hat{\\Phi}_{\\text{baseline}}(\\mathbf{0})$ are set to zero, we have $\\hat{\\Phi}_{\\text{cons}}(\\mathbf{k}) = \\hat{\\Phi}_{\\text{baseline}}(\\mathbf{k})$ for all $\\mathbf{k}$. Consequently, $\\Phi_{\\text{cons}}(\\mathbf{x}) = \\Phi_{\\text{baseline}}(\\mathbf{x})$, and the error $\\text{err}_{\\Phi}$ is exactly $0$.\n    -   **Inconsistent Treatment**: For $\\mathbf{k} \\neq \\mathbf{0}$, $\\hat{S}_{\\text{incons}}(\\mathbf{k}) = \\frac{\\bar{\\rho}}{1+\\epsilon} \\hat{\\delta}_{\\text{true}}(\\mathbf{k}) = \\frac{1}{1+\\epsilon} \\hat{S}_{\\text{baseline}}(\\mathbf{k})$. This leads to $\\hat{\\Phi}_{\\text{incons}}(\\mathbf{k}) = \\frac{1}{1+\\epsilon} \\hat{\\Phi}_{\\text{baseline}}(\\mathbf{k})$ for $\\mathbf{k} \\neq \\mathbf{0}$. With both DC components being zero, we have $\\hat{\\Phi}_{\\text{incons}}(\\mathbf{k}) = \\frac{1}{1+\\epsilon} \\hat{\\Phi}_{\\text{baseline}}(\\mathbf{k})$ for all $\\mathbf{k}$. By linearity of the inverse Fourier transform, $\\Phi_{\\text{incons}}(\\mathbf{x}) = \\frac{1}{1+\\epsilon} \\Phi_{\\text{baseline}}(\\mathbf{x})$. The error is then:\n        $$ \\text{err}_{\\Phi} = \\frac{\\|\\Phi_{\\text{incons}} - \\Phi_{\\text{baseline}}\\|_2}{\\|\\Phi_{\\text{baseline}}\\|_2} = \\frac{\\|\\left(\\frac{1}{1+\\epsilon} - 1\\right)\\Phi_{\\text{baseline}}\\|_2}{\\|\\Phi_{\\text{baseline}}\\|_2} = \\left|\\frac{-\\epsilon}{1+\\epsilon}\\right| = \\frac{|\\epsilon|}{|1+\\epsilon|} $$\n\n-   **Source Zero-Mode Ratio $r_0$**: The denominator is $\\max_{\\mathbf{k}\\neq \\mathbf{0}} |\\hat{S}_{\\text{baseline}}(\\mathbf{k})|$. The baseline source is $\\bar{\\rho}\\hat{\\delta}_{\\text{true}}(\\mathbf{k})$. The field $\\delta_{\\text{true}}$ is composed of two cosine modes with amplitudes $A_1=0.2$ and $A_2=0.1$. The DFT of $A_i \\cos(\\dots)$ on a grid of size $N^3$ has peaks of magnitude $A_i N^3 / 2$. The maximum magnitude will come from the larger amplitude $A_1$. Thus, $\\max_{\\mathbf{k}\\neq \\mathbf{0}} |\\hat{S}_{\\text{baseline}}(\\mathbf{k})| = \\bar{\\rho} A_1 N^3 / 2$.\n    -   **Consistent Treatment**: The numerator is $|\\hat{S}_{\\text{cons}}(\\mathbf{0})| = |-\\bar{\\rho}\\epsilon N^3| = \\bar{\\rho}|\\epsilon|N^3$. The ratio is $r_0 = \\frac{\\bar{\\rho}|\\epsilon|N^3}{\\bar{\\rho} A_1 N^3/2} = \\frac{2|\\epsilon|}{A_1}$.\n    -   **Inconsistent Treatment**: The numerator is $|\\hat{S}_{\\text{incons}}(\\mathbf{0})| = |\\frac{-\\bar{\\rho}\\epsilon N^3}{1+\\epsilon}|$. The ratio is $r_0 = \\frac{|\\frac{-\\bar{\\rho}\\epsilon N^3}{1+\\epsilon}|}{\\bar{\\rho} A_1 N^3/2} = \\frac{2|\\epsilon|}{|1+\\epsilon|A_1}$.\n\n### 2. Implementation Strategy\n\nThe numerical implementation will proceed as follows:\n1.  **Setup**: Define the physical and grid parameters ($L, N, \\bar{\\rho}$, etc.) and create the real-space grid coordinates $(x,y,z)$ and Fourier-space wave-vector grid $(k_x, k_y, k_z)$. Compute the squared wavenumber $k^2 = k_x^2+k_y^2+k_z^2$ for all modes.\n2.  **True Field**: Construct the true density field $\\rho(\\mathbf{x}) = \\bar{\\rho}(1+\\delta_{\\text{true}}(\\mathbf{x}))$ on the real-space grid.\n3.  **Baseline Calculation**: Compute the solution for the baseline case ($\\epsilon=0$, consistent). This involves:\n    a. Calculating $\\delta_{\\text{baseline}}(\\mathbf{x}) = (\\rho(\\mathbf{x}) - \\bar{\\rho})/\\bar{\\rho}$.\n    b. Taking its FFT to get $\\hat{\\delta}_{\\text{baseline}}(\\mathbf{k})$.\n    c. Forming the source $\\hat{S}_{\\text{baseline}}(\\mathbf{k}) = \\bar{\\rho}\\hat{\\delta}_{\\text{baseline}}(\\mathbf{k})$.\n    d. Solving for $\\hat{\\Phi}_{\\text{baseline}}(\\mathbf{k})$ by dividing by $-k^2$ (avoiding $k=0$) and setting $\\hat{\\Phi}_{\\text{baseline}}(0,0,0) = 0$.\n    e. Transforming back to get $\\Phi_{\\text{baseline}}(\\mathbf{x})$.\n    f. Storing $\\|\\Phi_{\\text{baseline}}\\|_2$ and $\\max_{\\mathbf{k}\\neq 0} |\\hat{S}_{\\text{baseline}}(\\mathbf{k})|$ for later use in diagnostics.\n4.  **Test Case Loop**: Iterate through the five test cases. For each case:\n    a. Define $\\epsilon$ and the consistency flag.\n    b. Compute $\\bar{\\rho}_{\\text{est}} = \\bar{\\rho}(1+\\epsilon)$.\n    c. Compute $\\delta_{\\text{case}}(\\mathbf{x}) = (\\rho(\\mathbf{x}) - \\bar{\\rho}_{\\text{est}})/\\bar{\\rho}_{\\text{est}}$.\n    d. Compute its FFT, $\\hat{\\delta}_{\\text{case}}(\\mathbf{k})$.\n    e. Construct the source term $\\hat{S}_{\\text{case}}(\\mathbf{k})$ using the appropriate mean density ($\\bar{\\rho}_{\\text{est}}$ for consistent, $\\bar{\\rho}$ for inconsistent).\n    f. Solve for $\\hat{\\Phi}_{\\text{case}}(\\mathbf{k})$ and transform back to get $\\Phi_{\\text{case}}(\\mathbf{x})$, using the same method as for the baseline.\n    g. Calculate the three diagnostics, $\\text{err}_{\\Phi}$, $r_0$, and $\\Delta\\bar{\\Phi}$, using the stored baseline quantities.\n5.  **Output**: Format the collected results into the specified string format.\n\nThis structured process ensures that each step is performed correctly and that the interactions between the mean density estimation and the solver logic are accurately modeled as per the problem statement.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves Poisson's equation in Fourier space for a synthetic density field\n    and analyzes the effect of mean density estimation errors.\n    \"\"\"\n\n    # 1. Problem Definition\n    # Domain and Grid\n    L = 1.0  # Domain side length\n    N = 32   # Grid points per dimension\n\n    # Physics Parameters (in code units)\n    rho_bar_true = 1.0  # True mean density\n    # 4 * pi * G * a^2 is set to 1\n\n    # Synthetic Overdensity Field Parameters\n    A1 = 0.2\n    A2 = 0.1\n    n1, n2, n3 = 2, 3, 2\n    \n    # Test Suite\n    test_cases = [\n        (0.0, True),      # 1. Baseline\n        (1e-3, True),     # 2. Consistent\n        (1e-3, False),    # 3. Inconsistent\n        (-0.05, False),   # 4. Inconsistent\n        (0.1, False)      # 5. Inconsistent\n    ]\n\n    # 2. Grid and Field Setup\n    # Real-space grid coordinates\n    grid_1d = np.linspace(0.0, L, N, endpoint=False)\n    x, y, z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n    # True overdensity field\n    delta_true = A1 * np.cos(2 * np.pi * n1 * x / L) + \\\n                 A2 * np.cos(2 * np.pi * (n2 * y / L + n3 * z / L))\n\n    # True density field\n    rho = rho_bar_true * (1.0 + delta_true)\n\n    # Fourier-space wavenumbers\n    k_1d = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_1d, k_1d, k_1d, indexing='ij')\n    k_squared = kx**2 + ky**2 + kz**2\n    \n    # We will need to set k=0 element to a non-zero value to avoid division by zero.\n    # The result at this k-vector is set to 0 manually anyway.\n    # A more robust way is to use a `where` clause in the division.\n    k_squared[0, 0, 0] = 1.0 \n    \n    # 3. Poisson Solver Function\n    def poisson_solve(density_field, rho_bar_for_delta, rho_bar_for_source):\n        \"\"\"\n        Solves Poisson's equation for a given density field and mean density choices.\n        \n        Returns:\n            Phi (np.ndarray): Real-space potential.\n            S_hat (np.ndarray): Fourier-space source term.\n        \"\"\"\n        # Compute overdensity delta\n        delta = (density_field - rho_bar_for_delta) / rho_bar_for_delta\n        \n        # FFT of overdensity\n        delta_hat = np.fft.fftn(delta)\n        \n        # Construct Fourier-space source term S_hat\n        S_hat = rho_bar_for_source * delta_hat\n        \n        # Solve for potential in Fourier space\n        Phi_hat = -S_hat / k_squared\n        \n        # Set the k=0 mode (mean potential) to zero\n        Phi_hat[0, 0, 0] = 0.0\n        \n        # Inverse FFT to get potential in real space\n        Phi = np.fft.ifftn(Phi_hat).real\n        \n        return Phi, S_hat\n\n    # 4. Baseline Calculation (Case 1)\n    phi_baseline, s_hat_baseline = poisson_solve(rho, rho_bar_true, rho_bar_true)\n    norm_phi_baseline = np.linalg.norm(phi_baseline)\n    \n    # Find max of |S_hat_baseline(k)| for k != 0\n    s_hat_baseline_mag = np.abs(s_hat_baseline)\n    s_hat_baseline_mag_k0 = s_hat_baseline_mag[0, 0, 0]\n    s_hat_baseline_mag[0, 0, 0] = 0.0 # Temporarily zero out the k=0 mode\n    max_s_baseline_nonzero = np.max(s_hat_baseline_mag)\n    s_hat_baseline_mag[0, 0, 0] = s_hat_baseline_mag_k0 # Restore original value\n    \n    # Handle the case where the baseline field is zero (all modes are zero)\n    if max_s_baseline_nonzero == 0:\n        max_s_baseline_nonzero = 1.0 # Avoid division by zero for r0\n\n    # 5. Loop Through Test Cases and Compute Diagnostics\n    results = []\n    for epsilon, is_consistent in test_cases:\n        rho_bar_est = rho_bar_true * (1.0 + epsilon)\n        \n        if is_consistent:\n            rho_bar_for_delta = rho_bar_est\n            rho_bar_for_source = rho_bar_est\n        else: # Inconsistent\n            rho_bar_for_delta = rho_bar_est\n            rho_bar_for_source = rho_bar_true\n        \n        # Solve for the current test case\n        phi_case, s_hat_case = poisson_solve(rho, rho_bar_for_delta, rho_bar_for_source)\n        \n        # Calculate diagnostics\n        \n        # err_Phi: Relative l2 error in the potential\n        if norm_phi_baseline > 0:\n            err_phi = np.linalg.norm(phi_case - phi_baseline) / norm_phi_baseline\n        else:\n            err_phi = np.linalg.norm(phi_case) # If baseline is zero, use absolute norm\n\n        # r0: Ratio of the k=0 source mode to the max non-zero baseline mode\n        r0 = np.abs(s_hat_case[0, 0, 0]) / max_s_baseline_nonzero\n        \n        # Delta_Phi_bar: Difference in the mean potential\n        delta_phi_bar = np.mean(phi_case) - np.mean(phi_baseline)\n        \n        results.append([err_phi, r0, delta_phi_bar])\n\n    # 6. Format and Print Output\n    # Format: [[r1,r2,r3],[r4,r5,r6],...] with no spaces\n    output_str = \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```"
        }
    ]
}