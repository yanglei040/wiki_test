{
    "hands_on_practices": [
        {
            "introduction": "在宇宙学模拟分析中，正确处理周期性边界条件（Periodic Boundary Conditions, PBC）是至关重要的一步。最小镜像约定（minimum image convention）的实现若有偏差，可能导致晕识别的灾难性失败。本练习  通过一个精心设计的测试用例，旨在隔离并检验您对PBC逻辑的实现，揭示链接长度这一关键参数如何决定一个跨越盒子边界的晕是被正确识别，还是被错误地分裂。",
            "id": "3474763",
            "problem": "给定一个边长为 $L=1$ 的立方、周期性模拟盒子（无量纲单位，因此所有位置和距离都以盒子长度为单位表示）。考虑使用朋友的朋友 (FoF) 算法进行晕结构寻找，该算法定义如下：对于一组位置为 $\\{\\mathbf{x}_i\\}$ 的粒子，如果两个粒子 $i$ 和 $j$ 之间的间隔 $d_{ij}$ 小于或等于一个选定的连接长度 $l_\\mathrm{link}$，则用一条边将它们连接起来。FoF 晕是生成图的连通分量。在周期性边界条件下，必须使用最小镜像约定计算距离：对于每个笛卡尔分量，使用位移 $\\delta_\\alpha = \\Delta_\\alpha - L \\cdot \\mathrm{round}(\\Delta_\\alpha / L)$，其中 $\\Delta_\\alpha$ 是该分量上的原始差值，然后使用欧几里得范数 $d_{ij} = \\sqrt{\\delta_x^2 + \\delta_y^2 + \\delta_z^2}$。\n\n构建一个确定性测试，其中一个物理晕结构跨越盒子边界，并分析 $l_\\mathrm{link}$ 的选择如何决定粒子是正确地回绕并连接，还是会发生虚假连接。使用以下固定的粒子位置集：\n- 跨边界物理晕 $H_1$：六个粒子，位于\n  $(x,y,z) \\in \\{(0.98,0.5,0.5),(0.985,0.5,0.5),(0.99,0.5,0.5),(0.01,0.5,0.5),(0.015,0.5,0.5),(0.02,0.5,0.5)\\}$。\n  该晕在物理上沿 $x$ 方向跨越周期性边界是连续的。\n- 独立的晕 $H_2$ 和 $H_3$：分别各有三个粒子，位于\n  $(x,y,z) \\in \\{(0.34,0.5,0.5),(0.35,0.5,0.5),(0.36,0.5,0.5)\\}$ 和\n  $(x,y,z) \\in \\{(0.64,0.5,0.5),(0.65,0.5,0.5),(0.66,0.5,0.5)\\}$。\n\n如上所述，实现一个带有周期性边界条件的朋友的朋友晕结构寻找器，使用闭球规则（即，如果 $d_{ij} \\le l_\\mathrm{link}$ 则连接）。对于以下连接长度 $l_\\mathrm{link}$ 的测试套件，计算算法恢复的晕（连通分量）的数量：\n1. $l_\\mathrm{link} = 0.004$。\n2. $l_\\mathrm{link} = 0.010$。\n3. $l_\\mathrm{link} = 0.025$。\n4. $l_\\mathrm{link} = 0.280$。\n\n你的程序必须：\n- 使用最小镜像约定在周期性边界条件下计算 $d_{ij}$。\n- 通过连接 $d_{ij} \\le l_\\mathrm{link}$ 的粒子对来构建 FoF 图。\n- 返回测试套件中每个 $l_\\mathrm{link}$ 的连通分量计数。\n\n以无量纲单位作答（所有长度均以 $L=1$ 为单位）。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与测试套件一致（例如，“[result1,result2,result3,result4]”）。每种情况的输出必须是表示找到的晕数量的整数。该测试套件包括一般情况、$l_\\mathrm{link}$ 的边界条件，以及一个边缘情况，其中 $l_\\mathrm{link}$ 等于导致跨周期性回绕发生虚假合并的最小晕间距。",
            "solution": "该问题要求在一个立方、周期性模拟盒子内，对一组指定的粒子实现并应用朋友的朋友 (FoF) 晕结构寻找算法。目标是确定该算法在一系列不同的连接长度 $l_\\mathrm{link}$ 下识别出的晕的数量。该解决方案基于周期性距离计算和图聚类原理。\n\n1.  **周期性边界条件与最小镜像约定 (MIC)**\n\n在计算宇宙学中，模拟通常采用具有周期性边界条件 (PBC) 的有限体积（通常是立方体）来表示一个统计上均匀和各向同性的宇宙，从而避免虚假的边界效应。在 PBC 下，一个粒子从盒子的一个面离开时，会立即从对面的面重新进入。这需要一种特殊的距离度量。标准的欧几里得距离是不够的，因为它无法识别出盒子相对两侧的两个粒子在物理上可能很近。\n\n正确的方法是最小镜像约定 (MIC)。对于一个边长为 $L$ 的立方盒子，两个位于位置 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$ 的粒子之间的距离计算如下。首先，计算原始位移矢量：$\\mathbf{\\Delta} = \\mathbf{x}_i - \\mathbf{x}_j$。然后调整该矢量的每个分量 $\\Delta_\\alpha$（其中 $\\alpha \\in \\{x, y, z\\}$），以找到其在周期性空间中的最短表示：\n$$\n\\delta_\\alpha = \\Delta_\\alpha - L \\cdot \\mathrm{round}\\left(\\frac{\\Delta_\\alpha}{L}\\right)\n$$\n`round` 函数将其参数映射到最近的整数。此操作有效地检查了“跨越边界”的距离是否更短。最终的 MIC 距离 $d_{ij}$ 是这个修正后的位移矢量 $\\mathbf{\\delta}$ 的标准欧几里得范数：\n$$\nd_{ij} = \\sqrt{\\delta_x^2 + \\delta_y^2 + \\delta_z^2}\n$$\n对于本问题，盒子边长指定为 $L=1$。\n\n2.  **朋友的朋友 (FoF) 算法**\n\nFoF 算法是一种广泛用于识别粒子模拟中引力束缚结构（晕）的方法。它是一种单链接层次聚类，可以用图论优雅地描述：\n-   **顶点**：模拟中的每个粒子都被视为图中的一个顶点。\n-   **边**：如果任意两个顶点 $i$ 和 $j$ 之间的间隔 $d_{ij}$（使用 MIC 计算）小于或等于预定义的连接长度 $l_\\mathrm{link}$，则在它们之间创建一条无向边。即，如果 $d_{ij} \\le l_\\mathrm{link}$，则存在一条边。\n-   **晕**：FoF 晕就是最终生成图的连通分量。连通分量是一组顶点，其中集合内的任意两个顶点之间都存在路径，并且该集合中的任何顶点都未与集合外的任何顶点相连。\n\n3.  **算法实现与测试用例分析**\n\n实现遵循一个清晰的流程。对于每个给定的 $l_\\mathrm{link}$，我们分析问题中定义的 $N=12$ 个粒子的连通性。\na.  构建一个 $N \\times N$ 的邻接矩阵来表示图。\nb.  对于每一对唯一的粒子 $(i, j)$，使用 $L=1$ 的 MIC 计算距离 $d_{ij}$。\nc.  如果 $d_{ij} \\le l_\\mathrm{link}$，则在邻接矩阵中记录一条边。\nd.  然后在该矩阵上运行连通分量算法，以计算不相交子图的数量，这对应于晕的数量。\n\n该粒子集旨在测试算法的行为，特别是其对周期性边界的处理以及对 $l_\\mathrm{link}$ 的敏感性。该集合包含三个预设的物理晕：$H_1$、$H_2$ 和 $H_3$。\n-   **晕内间距**：形成 $H_1$ 的粒子在 $x$ 方向上形成一条跨越周期性边界的链，最大连接距离为 $d=0.02$（在 $x=0.99$ 和 $x=0.01$ 之间）。$H_2$ 和 $H_3$ 中的粒子形成简单的链，连接距离为 $d=0.01$。\n-   **晕间间距**：晕 $H_2$ 和 $H_3$ 之间的最小距离为 $d=0.28$。$H_1$ 与任何其他晕之间的最小距离为 $d=0.32$。\n\n我们现在分析具体的测试用例：\n\n-   **用例 1：$l_\\mathrm{link} = 0.004$**\n    这个连接长度小于整个数据集中最小的连续粒子间距 ($0.005$)。因此，任何粒子对之间都不会形成连接。12 个粒子中的每一个都是孤立的，并被计为它自己的一个晕。\n    结果：$12$ 个晕。\n\n-   **用例 2：$l_\\mathrm{link} = 0.010$**\n    这个长度足以连接间距高达 $0.01$ 的粒子。\n    -   在 $H_1$ 中，间距为 $0.005$ 的连接形成了，但关键的周期性连接 $0.02$ 未能被桥接 ($0.02 > 0.010$)。这将预期的 $H_1$ 晕分裂成两个独立的组：一组粒子位于 $x \\in \\{0.98, 0.985, 0.99\\}$，另一组位于 $x \\in \\{0.01, 0.015, 0.02\\}$。因此 $H_1$ 被解析为 $2$ 个晕。\n    -   在 $H_2$ 和 $H_3$ 中，粒子间距均为 $0.01$。由于 $0.01 \\le l_\\mathrm{link}$，每个组中的粒子都成功连接，为每个组形成一个晕。\n    总晕数为 $2$ (来自 $H_1$) $+ 1$ (来自 $H_2$) $+ 1$ (来自 $H_3$) $= 4$。\n\n-   **用例 3：$l_\\mathrm{link} = 0.025$**\n    这个长度现在足够大，可以桥接预期晕内部所有“物理”连接。\n    -   在 $H_1$ 中，周期性连接 $0.02$ 现在被桥接了 ($0.02 \\le 0.025$)。所有 $6$ 个粒子都连接成一个单独的晕。\n    -   $H_2$ 和 $H_3$ 各自像之前一样形成一个单独的晕。\n    -   最小的晕间间距是 $0.28$，大于 $l_\\mathrm{link}$，因此不同晕之间没有发生虚假合并。这个用例正确地识别出了 $3$ 个物理上独立的群组。\n    总晕数为 $1 + 1 + 1 = 3$。\n\n-   **用例 4：$l_\\mathrm{link} = 0.280$**\n    这个连接长度是故意选择得足够大，以引起灾难性的虚假合并。\n    -   与 $l_\\mathrm{link} = 0.025$ 时一样，$H_1, H_2, H_3$ 各自内部的所有粒子都被连接起来，因此每个晕最初都形成一个单独的群组。\n    -   然而，$H_2$ 和 $H_3$ 之间的最小距离恰好是 $0.28$（在 $x=0.36$ 和 $x=0.64$ 的粒子之间）。由于 $0.28 \\le 0.280$，算法将这两个本应独立的晕连接起来，将它们合并成一个大的虚假物体。\n    -   $H_1$ 保持独立，因为它到任何其他粒子的最小距离 ($0.32$) 大于 $l_\\mathrm{link}$。\n    总晕数为 $1$ (来自 $H_1$) $+ 1$ (来自合并的 $H_2 \\cup H_3$) $= 2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse.csgraph import connected_components\n\ndef solve():\n    \"\"\"\n    Implements a Friends-of-Friends (FoF) halo finder with periodic boundary\n    conditions and tests it on a predefined particle set and suite of\n    linking lengths.\n    \"\"\"\n    \n    # Define the physical parameters and particle positions from the problem statement.\n    L = 1.0\n    particles = np.array([\n        # H1: Across-edge physical halo (6 particles)\n        [0.98, 0.5, 0.5], [0.985, 0.5, 0.5], [0.99, 0.5, 0.5],\n        [0.01, 0.5, 0.5], [0.015, 0.5, 0.5], [0.02, 0.5, 0.5],\n        # H2: Distinct halo (3 particles)\n        [0.34, 0.5, 0.5], [0.35, 0.5, 0.5], [0.36, 0.5, 0.5],\n        # H3: Distinct halo (3 particles)\n        [0.64, 0.5, 0.5], [0.65, 0.5, 0.5], [0.66, 0.5, 0.5]\n    ])\n    num_particles = particles.shape[0]\n\n    # The problem specifies a test suite of linking lengths.\n    # This corresponds to the `test_cases` in the provided boilerplate.\n    test_cases = [0.004, 0.010, 0.025, 0.280]\n\n    results = []\n\n    def pbc_distance(pos1, pos2, box_size):\n        \"\"\"\n        Computes the Euclidean distance between two points in a periodic box\n        using the Minimum Image Convention (MIC).\n        \n        Args:\n            pos1 (np.ndarray): Position vector of the first particle.\n            pos2 (np.ndarray): Position vector of the second particle.\n            box_size (float): The side length of the cubic periodic box.\n            \n        Returns:\n            float: The MIC distance between the two particles.\n        \"\"\"\n        delta = pos1 - pos2\n        # Apply minimum image convention to each component of the vector\n        delta_mic = delta - box_size * np.round(delta / box_size)\n        return np.linalg.norm(delta_mic)\n\n    # Iterate through each linking length in the test suite\n    for l_link in test_cases:\n        # 1. Build the adjacency matrix for the graph of particles.\n        # An edge exists if the distance between two particles is = l_link.\n        adj_matrix = np.zeros((num_particles, num_particles), dtype=int)\n        for i in range(num_particles):\n            for j in range(i + 1, num_particles):\n                dist = pbc_distance(particles[i], particles[j], L)\n                if dist = l_link:\n                    adj_matrix[i, j] = 1\n                    adj_matrix[j, i] = 1\n        \n        # 2. Find the number of connected components in the graph.\n        # Each component corresponds to one FoF halo.\n        # We use scipy's optimized function for this standard graph problem.\n        n_halos, _ = connected_components(\n            csgraph=adj_matrix, \n            directed=False, \n            return_labels=True\n        )\n        results.append(n_halos)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在识别出所有粒子“朋友”对（即图的边）之后，下一个挑战便是如何高效地将这些连接关系划分成独立的晕（即图的连通分量）。不相交集并（Disjoint-Set Union, DSU）算法，也常被称为并查集（Union-Find），为解决此类图聚类问题提供了一个极其优雅且高效的方案。在此练习  中，您将亲手实现带有路径压缩和按秩合并优化的DSU算法，并深入理解其接近常数的摊销时间复杂度的理论基础，这对于计算科学家而言是一项核心技能。",
            "id": "3474741",
            "problem": "给定一个立方的周期性区域和一组粒子位置，代表了宇宙学 $N$ 体模拟的一个快照。通过连接周期性欧几里得距离小于或等于一个连接长度 $\\ell$ 的两个粒子 $i$ 和 $j$，构建一个友邻算法（Friends-of-Friends, FoF）图。连接长度定义为 $\\ell = b \\, L \\, N^{-1/3}$，其中 $L$ 是立方盒子的边长，$N$ 是粒子数量，$b$ 是一个无量纲的连接参数，用于缩放平均粒子间距。任务是设计并实现一个带按秩合并和路径压缩的不相交集并查集（Disjoint-Set Union, DSU；也称为 union-find）算法，以合并所有 FoF 边，并在 FoF 图中识别不相交的暗物质晕成分，并分析其均摊时间复杂度。该图是无向的，并且必须使用最小镜像约定来遵守周期性边界条件。\n\n基本原理：\n- 带最小镜像约定的周期性欧几里得距离：对于两个位置 $\\mathbf{x}_i, \\mathbf{x}_j \\in [0,L)^3$，定义位移 $\\Delta \\mathbf{x} = \\mathbf{x}_j - \\mathbf{x}_i$。最小镜像位移是 $\\Delta \\mathbf{x}' = \\Delta \\mathbf{x} - L \\, \\mathrm{round}(\\Delta \\mathbf{x} / L)$，逐分量应用，周期性欧几里得距离为 $d_{ij} = \\|\\Delta \\mathbf{x}'\\|_2$。\n- 友邻算法（FoF）定义：如果 $d_{ij} \\leq \\ell$，则在 $i$ 和 $j$ 之间放置一条边。\n- 带按秩合并和路径压缩的不相交集并查集（DSU；union-find）操作。\n\n你的程序必须：\n- 实现一个带按秩合并和路径压缩的 DSU。\n- 根据给定的位置和连接参数，使用最小镜像周期性距离构建 FoF 边集。\n- 使用 DSU 合并边，以产生不相交的暗物质晕成分。\n- 对于每个测试用例，输出边数 $E$、暗物质晕数（连通分量数）$H$ 以及按降序排列的暗物质晕大小列表。\n\n解决方案中需解决的分析要求：\n- 从 DSU 定义和 Tarjan 的均摊界出发，分析为什么在 $N$ 个顶点中合并 $E$ 条边，使用按秩合并和路径压缩的均摊时间复杂度为 $O(N \\alpha(N) + E)$，其中 $\\alpha(N)$ 是反阿克曼函数，$E$ 是 FoF 边的数量。分析必须基于基本原理，并避免使用未从基本定义推导出的简化公式。\n\n不使用角度单位。输出中不需要物理单位，因为最终答案是计数和大小。\n\n测试套件：\n- Case $\\mathbf{A}$（通用覆盖，多个小晕，重复项）：\n    - $L = 1.0$, $N = 10$, $b = 0.25$,\n    - 位置（每个坐标在 $[0, L)$ 内）：\n      $\\{(0.10,0.10,0.10),(0.15,0.12,0.09),(0.11,0.08,0.12),(0.80,0.80,0.80),(0.81,0.79,0.82),(0.78,0.82,0.81),(0.50,0.50,0.50),(0.50,0.50,0.500001),(0.30,0.70,0.20),(0.05,0.95,0.95)\\}$。\n- Case $\\mathbf{B}$（边界条件：无边）：\n    - $L = 1.0$, $N = 5$, $b = 0.05$,\n    - 位置：\n      $\\{(0.00,0.00,0.00),(0.50,0.50,0.50),(0.90,0.10,0.10),(0.10,0.90,0.10),(0.10,0.10,0.90)\\}$。\n- Case $\\mathbf{C}$（所有粒子通过邻居链相连）：\n    - $L = 1.0$, $N = 8$, $b = 0.30$,\n    - 位置：\n      $\\{(0.00,0.50,0.50),(0.10,0.50,0.50),(0.20,0.50,0.50),(0.30,0.50,0.50),(0.40,0.50,0.50),(0.50,0.50,0.50),(0.60,0.50,0.50),(0.70,0.50,0.50)\\}$。\n- Case $\\mathbf{D}$（周期性环绕连接产生两个晕）：\n    - $L = 1.0$, $N = 4$, $b = 0.25$,\n    - 位置：\n      $\\{(0.99,0.50,0.50),(0.01,0.50,0.50),(0.50,0.99,0.50),(0.50,0.01,0.50)\\}$。\n\n最终输出格式：\n- 你的程序应生成一行输出，包含用方括号括起来的逗号分隔的结果列表（例如，$[result_1,result_2,result_3,result_4]$）。\n- 每个 $result_k$（对于测试用例 $k$）必须是 $[E,H,S]$ 形式的列表，其中 $E$ 是边的整数数量，$H$ 是暗物质晕的整数数量，$S$ 是按降序排列的成分大小的整数列表。",
            "solution": "经评估，用户提供的问题是有效的。它在计算宇宙学和算法设计领域有坚实的科学基础，问题陈述清晰，包含所有必要的定义和数据，并以客观、正式的语言表述。因此，我们可以着手提供完整的解决方案。\n\n该问题要求实现友邻算法（FoF）暗物质晕寻找算法。这涉及三个主要阶段：\n$1$. 通过识别所有周期性欧几里得距离小于或等于指定连接长度 $\\ell$ 的粒子对，来构建 FoF 图。\n$2$. 利用一个带按秩合并和路径压缩的不相交集并查集（DSU）数据结构，高效地找出该图的连通分量，这些分量即代表暗物质晕。\n$3$. 分析基于 DSU 的合并过程的均摊时间复杂度。\n\n### 第 1 部分：算法框架\n\n#### 1.1 周期性距离和连接长度\n\n模拟区域是一个边长为 $L$ 的立方盒子，具有周期性边界条件。对于区域 $[0,L)^3$ 中的任意两个粒子，其位置向量为 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$，位移向量为 $\\Delta \\mathbf{x} = \\mathbf{x}_j - \\mathbf{x}_i$。周期性边界条件通过最小镜像约定来处理，这确保我们总是考虑两个粒子之间可能的最短距离，包括环绕后的镜像。粒子 $j$ 相对于粒子 $i$ 的最近镜像的位移向量，对每个维度 $k \\in \\{x, y, z\\}$ 逐分量计算：\n$$\n\\Delta x'_k = \\Delta x_k - L \\cdot \\mathrm{round}\\left(\\frac{\\Delta x_k}{L}\\right)\n$$\n函数 $\\mathrm{round}(v)$ 将 $v$ 四舍五入到最近的整数。然后，周期性欧几里得距离的平方是：\n$$\nd_{ij}^2 = \\|\\Delta \\mathbf{x}'\\|_2^2 = (\\Delta x'_x)^2 + (\\Delta x'_y)^2 + (\\Delta x'_z)^2\n$$\n如果两个粒子 $i$ 和 $j$ 的分离距离小于或等于连接长度 $\\ell$，则它们被认为是“友邻”，并在 FoF 图中它们之间放置一条边。连接长度是相对于平均粒子间距定义的：\n$$\n\\ell = b \\cdot L \\cdot N^{-1/3}\n$$\n其中 $N$ 是粒子总数，$b$ 是一个无量纲的连接参数。为避免计算成本高昂的平方根运算，我们比较距离的平方：如果 $d_{ij}^2 \\leq \\ell^2$，则存在一条边。构建边集需要检查所有唯一的粒子对，这是一个 $O(N^2)$ 的操作。\n\n#### 1.2 带优化的不相交集并查集（DSU）\n\nDSU 数据结构非常适合确定图的连通分量。它维护一个不相交集的集合，支持两个主要操作：\n- **`find(i)`**：返回包含元素 $i$ 的集合的唯一标识符（根）。\n- **`union(i, j)`**：合并包含元素 $i$ 和 $j$ 的两个集合。\n\n为了在均摊基础上实现接近常数时间的性能，采用了两种启发式方法：\n\n$1$. **路径压缩（Path Compression）**：在执行 `find(i)` 操作期间，找到集合的根之后，会再次遍历从 $i$ 到根的路径。此路径上的每个节点的父指针都会被更新，以直接指向根。这极大地扁平化了树结构，加快了后续对该路径中元素的 `find` 操作。\n\n$2$. **按秩合并（Union by Rank）**：每个集合的根都与一个 `rank` 相关联，该 `rank` 是以此节点为根的树的高度的上界。在执行 `union(i, j)` 操作时，具有较低秩的树的根会被附加为具有较高秩的树的根的子节点。如果秩相等，则任意选择一个作为新根，并将其秩增加一。这种启发式方法可以防止树变得不必要地高和不平衡。\n\n整个过程如下：\n1. 用 $N$ 个粒子初始化 DSU 结构，每个粒子最初都属于自己的集合。\n2. 对于预先计算的 FoF 边列表中的每条边 $(i, j)$，调用 `union(i, j)`。\n3. 处理完所有边后，剩余的不相交集对应于暗物质晕。暗物质晕的数量是不同根的数量，每个暗物质晕的大小是追溯到给定根的粒子数。\n\n### 第 2 部分：均摊时间复杂度分析\n\n我们分析在 $N$ 个元素上执行一系列 DSU 操作的时间复杂度，该序列包括 $N$ 次 `Make-Set` 操作以初始化结构，以及随后 $M$ 次混合的 `Find` 和 `Union` 操作。在此问题的背景下，我们合并 $E$ 条边，这对应于 $E$ 次 `Union` 操作。每次 `Union` 操作涉及两次 `Find` 操作。因此，操作总数 $M$ 与 $E$ 成正比。\n\n该分析由 Robert Tarjan 首创，依赖于一个增长极其缓慢的函数——反阿克曼函数，记作 $\\alpha(N)$。阿克曼函数 $A(m, n)$ 定义如下：\n$$\nA(m, n) = \\begin{cases}\nn+1  \\text{if } m=0 \\\\\nA(m-1, 1)  \\text{if } m0 \\text{ and } n=0 \\\\\nA(m-1, A(m, n-1))  \\text{if } m0 \\text{ and } n0\n\\end{cases}\n$$\n反阿克曼函数 $\\alpha(N)$ 定义为使得 $A(k,k)$ 相对于 $N$ 增长最快的值 $k$。对于物理世界中任何可以想象的输入大小 $N$，$\\alpha(N)  5$。\n\n一个操作的均摊成本是其实际成本加上在数据结构状态上定义的势函数 $\\Phi$ 的变化。该分析的威力在于证明了 `Find` 操作虽然偶尔会很昂贵，但它们会使势 $\\Phi$ 减少，其减少量在长期内“支付”了它们的成本。\n\nTarjan 分析的一个关键见解是，一个由 $N$ 次 `Make-Set` 操作和 $M$ 次 `Find`/`Union` 操作组成的序列的总成本上界为 $O(M\\alpha(N) + N)$。\n\n我们被要求证明合并过程的特定形式 $O(E + N\\alpha(N))$。我们可以将分析框架如下：\n1.  **初始化**：创建 $N$ 个不相交集需要 $O(N)$ 时间。\n2.  **合并边**：我们执行 $E$ 次 `Union` 操作。单个 `Union(i, j)` 操作包括 `Find(i)`、`Find(j)` 和一个常数时间的父指针修改（链接）。因此，总成本主要由 $2E$ 次 `Find` 操作和链接操作决定。\n\n让我们考虑所有操作的总工作量。每次 `Union` 的链接成本为 $O(1)$，为总复杂度贡献一个 $O(E)$ 项。剩余的成本来自 `Find` 操作期间遍历父指针。路径压缩使这一点变得复杂，因为后续对同一路径的 `Find` 操作会变得更便宜。\n\n均摊分析可以通过将成本“分摊”到操作或节点上来构建。得出 $O(E + N\\alpha(N))$ 界限的一种方法是考虑由路径压缩引起的父指针修改总数。在对 $N$ 个元素的任何 `Find` 操作序列中，此类修改的总数上界为 $O(N\\alpha(N))$。这代表了扁平化树的总“投资”。\n\n$2E$ 次 `Find` 调用中的每一次都遍历一条到根的路径。我们可以核算此遍历的成本。从节点 $u$ 到其父节点 $p(u)$ 的每一步都可以通过每次 `Find` 操作的常数“费用”或通过路径压缩积累的“信用”来支付。在考虑了由 $O(N\\alpha(N))$ 路径压缩预算支付的工作后，所有 $2E$ 次 `Find` 调用中遍历所有路径的总成本与 `Find` 调用的数量本身成正比，即 $O(E)$。\n\n将这些部分组合起来：\n- $N$ 次初始 `Make-Set` 调用的成本：$O(N)$。\n- `Union` 调用中 $E$ 次常数时间链接操作的成本：$O(E)$。\n- 所有 `Find` 调用期间指针遍历的总成本，将路径压缩工作分摊到节点上：$O(N\\alpha(N))$。\n- 未被路径压缩覆盖的额外遍历成本：$O(E)$。\n\n将这些相加，总复杂度为 $O(N + E + N\\alpha(N))$。由于在任何非平凡图中，为了连通性 $E \\ge N-1$，或者我们感兴趣的是 $E$ 很重要的情况，这通常被简化。特定的形式 $O(E + N\\alpha(N))$ 正确地捕捉了成本与边数大致呈线性关系，外加一个几乎与顶点数呈线性关系的项，反映了路径压缩的总工作。这种形式正确地将迭代边的成本（$E$）与对集合的结构性工作（$N\\alpha(N)$）分离开来。请注意，此处实现的*整个暗物质晕寻找算法*的总复杂度由 $O(N^2)$ 的寻边步骤主导；$O(E + N\\alpha(N))$ 分析仅适用于基于 DSU 的合并部分，正如问题所要求的那样。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass DSU:\n    \"\"\"A Disjoint-Set Union (DSU) data structure with Union by Rank and Path Compression.\"\"\"\n    def __init__(self, n):\n        \"\"\"\n        Initializes the DSU with n elements.\n        Each element is its own parent, and all ranks are initially 0.\n        \"\"\"\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, i):\n        \"\"\"\n        Finds the representative (root) of the set containing element i,\n        with path compression.\n        \"\"\"\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        \"\"\"\n        Merges the sets containing elements i and j, using union by rank.\n        Returns True if a merge occurred, False otherwise.\n        \"\"\"\n        root_i = self.find(i)\n        root_j = self.find(j)\n\n        if root_i != root_j:\n            if self.rank[root_i]  self.rank[root_j]:\n                self.parent[root_i] = root_j\n            elif self.rank[root_i] > self.rank[root_j]:\n                self.parent[root_j] = root_i\n            else:\n                self.parent[root_j] = root_i\n                self.rank[root_i] += 1\n            return True\n        return False\n\ndef find_halos(L, N, b, positions):\n    \"\"\"\n    Identifies halos in a particle distribution using the Friends-of-Friends (FoF)\n    algorithm with a DSU data structure.\n\n    Args:\n        L (float): The side length of the cubic, periodic box.\n        N (int): The number of particles.\n        b (float): The dimensionless linking parameter.\n        positions (np.ndarray): An (N, 3) array of particle positions.\n\n    Returns:\n        list: A list containing [E, H, S], where E is the number of edges,\n              H is the number of halos, and S is a list of halo sizes sorted\n              in descending order.\n    \"\"\"\n    if N == 0:\n        return [0, 0, []]\n\n    # Calculate squared linking length\n    linking_length = b * L * (N ** (-1.0/3.0))\n    l_sq = linking_length ** 2\n\n    # Build the FoF edge list\n    edges = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            delta = positions[j] - positions[i]\n            # Apply minimal-image convention for periodic boundary conditions\n            delta -= L * np.round(delta / L)\n            dist_sq = np.sum(delta**2)\n\n            if dist_sq = l_sq:\n                edges.append((i, j))\n    \n    num_edges = len(edges)\n\n    # Use DSU to find connected components (halos)\n    dsu = DSU(N)\n    for u, v in edges:\n        dsu.union(u, v)\n\n    # Count halos and their sizes\n    halo_sizes = {}\n    for i in range(N):\n        root = dsu.find(i)\n        halo_sizes[root] = halo_sizes.get(root, 0) + 1\n\n    num_halos = len(halo_sizes)\n    sorted_sizes = sorted(halo_sizes.values(), reverse=True)\n\n    return [num_edges, num_halos, sorted_sizes]\n\ndef solve():\n    \"\"\"\n    Solves the provided test cases and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'L': 1.0, 'N': 10, 'b': 0.25,\n         'positions': np.array([\n             (0.10, 0.10, 0.10), (0.15, 0.12, 0.09), (0.11, 0.08, 0.12),\n             (0.80, 0.80, 0.80), (0.81, 0.79, 0.82), (0.78, 0.82, 0.81),\n             (0.50, 0.50, 0.50), (0.50, 0.50, 0.500001),\n             (0.30, 0.70, 0.20), (0.05, 0.95, 0.95)])},\n        # Case B\n        {'L': 1.0, 'N': 5, 'b': 0.05,\n         'positions': np.array([\n             (0.00, 0.00, 0.00), (0.50, 0.50, 0.50), (0.90, 0.10, 0.10),\n             (0.10, 0.90, 0.10), (0.10, 0.10, 0.90)])},\n        # Case C\n        {'L': 1.0, 'N': 8, 'b': 0.30,\n         'positions': np.array([\n             (0.00, 0.50, 0.50), (0.10, 0.50, 0.50), (0.20, 0.50, 0.50),\n             (0.30, 0.50, 0.50), (0.40, 0.50, 0.50), (0.50, 0.50, 0.50),\n             (0.60, 0.50, 0.50), (0.70, 0.50, 0.50)])},\n        # Case D\n        {'L': 1.0, 'N': 4, 'b': 0.25,\n         'positions': np.array([\n             (0.99, 0.50, 0.50), (0.01, 0.50, 0.50),\n             (0.50, 0.99, 0.50), (0.50, 0.01, 0.50)])}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_halos(case['L'], case['N'], case['b'], case['positions'])\n        results.append(str(result).replace(\" \", \"\"))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的宇宙学模拟包含数十亿乃至更多的粒子，这使得串行算法不切实际，并行计算成为必然选择。本练习  将引导您探索区域分解（domain decomposition），一种并行化FoF算法的基础策略。通过实现并将一个朴素的并行方法与采用“幽灵区”（ghost zones）等正确方法进行比较，您将获得解决分布式计算难题的实践经验，并学会在大规模数据集上确保结果的全局正确性。",
            "id": "3474759",
            "problem": "您的任务是为数值宇宙学中的“朋友的朋友”（Friends-of-Friends, FoF）算法实现并分析并行化策略。考虑一个边长为 $L = 1$ 的立方模拟盒，其在所有三个维度上都具有周期性边界条件。盒中有 $N$ 个粒子，其位置为 $\\mathbf{x}_i \\in [0,1)^3$，其中 $i \\in \\{0,1,\\dots,N-1\\}$。“朋友的朋友”（FoF）算法在这些粒子上定义了一个无向图，如果周期性欧几里得距离 $d_{\\mathrm{PBC}}(\\mathbf{x}_i,\\mathbf{x}_j) \\leq \\ell$，则存在一条边 $\\{i,j\\}$。一个晕（halo）是该图的一个连通分量。连接长度（linking length）$\\ell$ 根据第一性原理定义为 $\\ell = b \\, \\bar{n}^{-1/3}$，其中平均数密度 $\\bar{n} = N / L^3$。因此，当 $L=1$ 时，可得 $\\ell = b \\, N^{-1/3}$。\n\n该模拟盒沿 $x$ 轴被分解为 $p$ 个等宽的板状子域（slab subdomains），其中子域 $s$ 覆盖 $x \\in [s/p,(s+1)/p)$ 的范围，$s \\in \\{0,1,\\dots,p-1\\}$。该分解是周期性的，因此子域 $p-1$ 与子域 $0$ 相邻。您必须实现三种并行化策略，并将它们与全局正确的 FoF 结果进行比较：\n- 策略 $\\mathrm{Global}$：使用周期性距离 $d_{\\mathrm{PBC}}$ 构建包含所有 $N$ 个粒子的完整 FoF 图，并将连通分量的数量计算为晕的数量。\n- 策略 $\\mathrm{Naive}$：按子域划分粒子，并在每个子域内独立构建 FoF 图，仅使用 $x$ 坐标位于该子域区间的粒子。将所有子域的连通分量数量相加作为总数。不考虑跨子域的连接。\n- 策略 $\\mathrm{Ghost}$：对于每个子域 $s$，包含其所有本地粒子。此外，还包括来自两个相邻子域的鬼粒子（ghost particles），这些鬼粒子的 $x$ 坐标在周期性 $x$ 轴度量下，与子域边界 $x = s/p$ 和 $x = (s+1)/p$ 的距离在厚度 $\\ell$ 之内。在每个子域内，在本地粒子和鬼粒子的并集中构建边，但只记录至少涉及一个该子域本地粒子的边，这样所有子域 $s$ 的边集合的并集就能恢复跨边界的连接。然后，使用所有子域记录的边的并集，在 $N$ 个原始粒子上计算连通分量的数量，作为晕的数量。\n- 策略 $\\mathrm{Merge}$：如“朴素”策略一样，在每个子域内独立运行本地 FoF 以获得子域内的边。然后，对于每对相邻的子域 $(s, (s+1) \\bmod p)$（包括 $(p-1, 0)$），为任何满足 $d_{\\mathrm{PBC}}(\\mathbf{x}_i,\\mathbf{x}_j) \\leq \\ell$ 的粒子对 $(i,j)$（其中 $i$ 在子域 $s$ 中，$j$ 在子域 $(s+1) \\bmod p$ 中）添加跨边界的边。使用子域内边和跨边界边的并集，在 $N$ 个原始粒子上计算连通分量的数量，作为晕的数量。\n\n所有距离必须使用周期性欧几里得度量计算：对于 $\\Delta \\mathbf{x} = \\mathbf{x}_i - \\mathbf{x}_j$，定义分量方向上的周期性位移 $\\Delta \\mathbf{x}_{\\mathrm{PBC}} = \\Delta \\mathbf{x} - \\mathrm{round}(\\Delta \\mathbf{x})$，以及 $d_{\\mathrm{PBC}}(\\mathbf{x}_i,\\mathbf{x}_j) = \\|\\Delta \\mathbf{x}_{\\mathrm{PBC}}\\|_2$。在左闭右开的区间约定下，坐标为 $x$ 的粒子所属的子域为 $s = \\lfloor x \\, p \\rfloor$。\n\n您的程序必须为下面的每个测试用例，计算上述四种策略下的晕数量，并输出一行聚合所有测试用例结果的内容。要求的最终输出格式为单行，包含一个列表的列表，无空格。其中每个内部列表的形式为 $[\\mathrm{Global},\\mathrm{Naive},\\mathrm{Ghost},\\mathrm{Merge}]$，对应一个测试用例，例如 $[[g_1,n_1,gh_1,m_1],[g_2,n_2,gh_2,m_2],\\dots]$。\n\n在此问题中，您必须使用无量纲单位，其中 $L=1$，所有坐标和连接长度 $\\ell$ 均以相同单位表示。不涉及角度。唯一的输出是整数。\n\n根据以下测试套件实现程序，该套件旨在探测正确性、边界处理和周期性环绕：\n\n- 测试用例 1（理想情况，分离良好的晕包含在子域内）：\n    - $N = 8$, $b = 0.30$, $p = 2$。\n    - 粒子位置 $\\mathbf{x}_i$：\n        - $\\mathbf{x}_0 = (0.20, 0.20, 0.20)$,\n        - $\\mathbf{x}_1 = (0.22, 0.20, 0.20)$,\n        - $\\mathbf{x}_2 = (0.20, 0.22, 0.20)$,\n        - $\\mathbf{x}_3 = (0.20, 0.20, 0.22)$,\n        - $\\mathbf{x}_4 = (0.70, 0.70, 0.70)$,\n        - $\\mathbf{x}_5 = (0.72, 0.70, 0.70)$,\n        - $\\mathbf{x}_6 = (0.70, 0.72, 0.70)$,\n        - $\\mathbf{x}_7 = (0.70, 0.70, 0.72)$。\n- 测试用例 2（相邻子域之间的边界穿越）：\n    - $N = 10$, $b = 0.28$, $p = 3$。\n    - 粒子位置 $\\mathbf{x}_i$：\n        - $\\mathbf{x}_0 = (0.322, 0.200, 0.200)$,\n        - $\\mathbf{x}_1 = (0.345, 0.205, 0.200)$,\n        - $\\mathbf{x}_2 = (0.332, 0.220, 0.200)$,\n        - $\\mathbf{x}_3 = (0.318, 0.205, 0.220)$,\n        - $\\mathbf{x}_4 = (0.349, 0.220, 0.220)$,\n        - $\\mathbf{x}_5 = (0.550, 0.600, 0.600)$,\n        - $\\mathbf{x}_6 = (0.560, 0.600, 0.600)$,\n        - $\\mathbf{x}_7 = (0.550, 0.610, 0.600)$,\n        - $\\mathbf{x}_8 = (0.550, 0.600, 0.610)$,\n        - $\\mathbf{x}_9 = (0.560, 0.610, 0.610)$。\n- 测试用例 3（周期性环绕和跨边界的传递性连接）：\n    - $N = 12$, $b = 0.25$, $p = 4$。\n    - 粒子位置 $\\mathbf{x}_i$：\n        - $\\mathbf{x}_0 = (0.990, 0.300, 0.300)$,\n        - $\\mathbf{x}_1 = (0.010, 0.300, 0.300)$,\n        - $\\mathbf{x}_2 = (0.985, 0.305, 0.300)$,\n        - $\\mathbf{x}_3 = (0.015, 0.295, 0.300)$,\n        - $\\mathbf{x}_4 = (0.990, 0.310, 0.295)$,\n        - $\\mathbf{x}_5 = (0.010, 0.290, 0.305)$,\n        - $\\mathbf{x}_6 = (0.240, 0.800, 0.800)$,\n        - $\\mathbf{x}_7 = (0.290, 0.800, 0.800)$,\n        - $\\mathbf{x}_8 = (0.340, 0.800, 0.800)$,\n        - $\\mathbf{x}_9 = (0.390, 0.800, 0.800)$,\n        - $\\mathbf{x}_{10} = (0.440, 0.800, 0.800)$,\n        - $\\mathbf{x}_{11} = (0.490, 0.800, 0.800)$。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表，该列表封装在方括号中且不含空格。列表中的每个元素对应一个测试用例，本身是一个包含四个整数的列表，格式为 $[\\mathrm{Global},\\mathrm{Naive},\\mathrm{Ghost},\\mathrm{Merge}]$。例如：$[[2,2,2,2],[2,3,2,2],[2,4,2,2]]$。",
            "solution": "用户提供了一个问题，要求在周期性宇宙学模拟盒中，为“朋友的朋友”（FoF）晕寻找算法实现并比较四种并行化策略。\n\n### 第一步：提取已知信息\n\n- **模拟盒**：立方体，边长 $L = 1$，在所有三个维度上具有周期性边界条件（PBC）。\n- **粒子**：$N$ 个粒子，位置为 $\\mathbf{x}_i \\in [0,1)^3$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$。\n- **FoF 算法**：粒子上的一个无向图。如果周期性欧几里得距离 $d_{\\mathrm{PBC}}(\\mathbf{x}_i, \\mathbf{x}_j) \\leq \\ell$，则存在一条边 $\\{i,j\\}$。一个晕是该图的一个连通分量。\n- **连接长度**：$\\ell = b \\, \\bar{n}^{-1/3}$，其中 $\\bar{n} = N/L^3$。当 $L=1$ 时，简化为 $\\ell = b \\, N^{-1/3}$。\n- **域分解**：模拟盒沿 $x$ 轴被划分为 $p$ 个等宽的板状子域。子域 $s \\in \\{0, 1, \\dots, p-1\\}$ 覆盖 $x \\in [s/p, (s+1)/p)$。分解是周期性的。\n- **粒子到子域的分配**：$x$ 坐标为 $x$ 的粒子位于子域 $s = \\lfloor x \\cdot p \\rfloor$。\n- **周期性距离度量**：对于 $\\Delta \\mathbf{x} = \\mathbf{x}_i - \\mathbf{x}_j$，分量上的周期性位移为 $\\Delta \\mathbf{x}_{\\mathrm{PBC}} = \\Delta \\mathbf{x} - \\mathrm{round}(\\Delta \\mathbf{x})$。距离为 $d_{\\mathrm{PBC}}(\\mathbf{x}_i, \\mathbf{x}_j) = \\|\\Delta \\mathbf{x}_{\\mathrm{PBC}}\\|_2$。\n- **要实现的策略**：\n    1.  **全局（Global）**：在所有 $N$ 个粒子上使用 $d_{\\mathrm{PBC}}$ 构建完整的 FoF 图。\n    2.  **朴素（Naive）**：在每个子域内独立进行 FoF，然后将晕计数相加。无跨子域连接。\n    3.  **鬼粒子（Ghost）**：对于每个子域 $s$，考虑本地粒子加上来自相邻子域边界 $\\ell$ 距离内的鬼粒子。构建涉及至少一个本地粒子的边集。在所有此类边集的并集上计算全局图的连通分量。\n    4.  **合并（Merge）**：在每个子域内运行本地 FoF。然后，显式地在相邻子域之间添加跨界边。在生成的全局图上计算连通分量。\n- **输出格式**：单行包含一个列表的列表，无空格。每个内部列表为 $[\\mathrm{Global}, \\mathrm{Naive}, \\mathrm{Ghost}, \\mathrm{Merge}]$，对应一个测试用例。例如：`[[g1,n1,gh1,m1],[g2,n2,gh2,m2],...]`。\n- **测试用例**：\n    1.  $N = 8$, $b = 0.30$, $p = 2$。提供了粒子位置 $\\mathbf{x}_0, \\dots, \\mathbf{x}_7$。\n    2.  $N = 10$, $b = 0.28$, $p = 3$。提供了粒子位置 $\\mathbf{x}_0, \\dots, \\mathbf{x}_9$。\n    3.  $N = 12$, $b = 0.25$, $p = 4$。提供了粒子位置 $\\mathbf{x}_0, \\dots, \\mathbf{x}_{11}$。\n\n### 第二步：使用提取的已知信息进行验证\n\n- **科学上合理**：该问题设置在数值宇宙学（天体物理学的一个子领域）的背景下。“朋友的朋友”（FoF）算法是 N 体模拟中识别暗物质晕的标准、广泛使用的方法。周期性边界条件、连接长度、域分解和鬼粒子区（ghost zones）等概念都是计算物理和并行科学计算中的基本和标准概念。该问题牢固地植根于已建立的科学和计算原理。\n- **问题定义良好**：该问题在数学上和算法上都有良好的定义。输入（粒子位置、参数）已给出。四种策略中每种图的构建规则都已足够精确，可以实现。所需输出——图的连通分量数——是一个可以唯一确定的量。\n- **客观性**：问题陈述是形式化和定量的。它没有任何主观性、观点或非科学性主张。所有定义都是精确的。\n- **缺陷清单**：\n    1.  **科学/事实不健全**：无。物理学和计算机科学基础是合理的。\n    2.  **非形式化/不相关**：问题高度形式化，与所述主题直接相关。\n    3.  **不完整/矛盾的设置**：提供了所有必要的数据和定义。四种策略的定义各不相同且内部一致。例如，“鬼粒子”策略中“只记录涉及至少一个本地粒子的边”的规则防止了在简单的边列表中，同一个跨界连接被两个相邻子域同时生成，尽管对于基于 DSU 的方法，这种区别对正确性来说不那么关键。“合并”策略也被明确指定为一个两阶段过程。没有矛盾。\n    4.  **不切实际/不可行**：粒子数量较小，使得问题对于一个测试套件来说在计算上是可行的，这在这种情况下是现实的。参数是合理的。\n    5.  **不适定/结构不良**：问题结构良好，对每个测试用例都有唯一、稳定的解。\n    6.  **伪深刻/琐碎**：问题并非琐碎。它需要仔细实现图算法、带周期性边界的几何计算以及域分解的逻辑。比较这四种策略在概念上是有意义的。\n    7.  **超出科学可验证性**：结果是可以通过计算验证的。\n\n### 第三步：结论与行动\n\n该问题是 **有效的**，因为它在科学上是合理的，问题定义良好，客观，并且没有任何使其无效的缺陷。将提供一个解决方案。\n\n### 解决方案\n\n这个问题的核心是计算图中连通分量的数量。图的顶点是 $N$ 个粒子。边由邻近条件定义：如果两个粒子的距离不超过一个连接长度 $\\ell$，它们就是“朋友”（由一条边连接）。晕是这个友谊图的连通分量。我们将使用一个不相交集并查集（Disjoint Set Union, DSU）数据结构，也称为并查集（Union-Find）数据结构，来高效地计算这些分量。\n\n**基本概念**\n\n1.  **不相交集并查集 (DSU)**：此数据结构维护一个不相交集合的集合。它提供两个主要操作：`find(i)`，返回包含元素 `i` 的集合的标识符；以及 `union(i, j)`，合并包含元素 `i` 和 `j` 的集合。我们将实现一个 DSU 类，其中可以随时查询不相交集合的数量。最初，$N$ 个粒子中的每一个都在自己的集合中。对于找到的每一对朋友，我们执行一次 `union` 操作。最终的晕数是剩余的不相交集合的数量。\n\n2.  **周期性边界条件 (PBC)**：在一个边长为 $L=1$、坐标在 $[0,1)$ 的立方盒中，两个坐标差为 $\\Delta x = x_1 - x_2$ 的点之间的最短距离矢量分量 $\\Delta x_{\\mathrm{PBC}}$ 不仅仅是 $\\Delta x$，还要考虑“环绕”模拟盒的情况。所提供的公式 $\\Delta x_{\\mathrm{PBC}} = \\Delta x - \\mathrm{round}(\\Delta x)$ 正确地找到了这个最短矢量分量。总距离是该矢量的欧几里得范数：$d_{\\mathrm{PBC}} = \\sqrt{(\\Delta x_{\\mathrm{PBC}})^2 + (\\Delta y_{\\mathrm{PBC}})^2 + (\\Delta z_{\\mathrm{PBC}})^2}$。\n\n3.  **连接长度**：连接长度计算为 $\\ell = b \\cdot N^{-1/3}$，其中 $b$ 是一个无量纲参数（通常约为 0.2），而 $N^{-1/3}$ 与平均粒子间距成正比。\n\n**四种策略的实现**\n\n对于每种策略，我们将为给定的粒子分布计算晕的数量。“全局”策略作为基准真相，而“鬼粒子”和“合并”是旨在重现全局结果的并行化方案。“朴素”策略是一个简化的、不正确的并行方案，用于比较。\n\n1.  **`Global` 策略**：这是参考实现。\n    - 为所有 $N$ 个粒子初始化一个 DSU。\n    - 遍历所有唯一的粒子对 $(i, j)$，其中 $i  j$。\n    - 计算周期性距离 $d_{\\mathrm{PBC}}(\\mathbf{x}_i, \\mathbf{x}_j)$。\n    - 如果 $d_{\\mathrm{PBC}}(\\mathbf{x}_i, \\mathbf{x}_j) \\leq \\ell$，则调用 `dsu.union(i, j)`。\n    - 结果是 DSU 中最终的集合数量。\n\n2.  **`Naive` 策略**：此策略忽略所有跨子域边界的相互作用。\n    - 首先，根据粒子的 $x$ 坐标 $s_i = \\lfloor x_i \\cdot p \\rfloor$ 将粒子划分为 $p$ 个子域。\n    - 初始化总晕计数为零。\n    - 对于每个子域 $s=0, \\dots, p-1$：\n        - 设 $S_s$ 为此子域中粒子的索引集。\n        - 如果 $S_s$ 非空，则仅对这些粒子执行本地 FoF 分析。这可以通过为 $|S_s|$ 个粒子创建一个新的 DSU，找到它们的连通分量，并将计数添加到总数中来完成。\n    - 结果是所有子域的晕计数之和。当一个真正的晕被子域边界分割时，此方法会多计晕的数量。\n\n3.  **`Ghost` 策略**：这是一种更复杂的并行策略，使用鬼粒子区来正确处理跨界晕。\n    - 为所有 $N$ 个粒子初始化一个 DSU。\n    - 如前所述划分粒子到子域。\n    - 对于每个子域 $s=0, \\dots, p-1$：\n        - 识别其本地粒子集 $S_s$。\n        - 识别一个鬼粒子集 $G_s$。来自相邻子域的粒子 $j$ 如果其到 $s$ 的边界（$x=s/p$ 或 $x=(s+1)/p$）的周期性 $x$ 距离小于或等于 $\\ell$，则为 $s$ 的鬼粒子。\n        - 考虑组合粒子集 $C_s = S_s \\cup G_s$。\n        - 遍历 $C_s$ 中所有 $i  j$ 的对 $(i, j)$。\n        - 关键是，为满足问题约束并避免在实际并行系统中进行冗余工作，我们仅当对中至少有一个粒子属于本地集 $S_s$ 时才处理该对。\n        - 如果对 $(i, j)$ 满足此条件且 $d_{\\mathrm{PBC}}(\\mathbf{x}_i, \\mathbf{x}_j) \\leq \\ell$，则在*全局* DSU 上调用 `dsu.union(i, j)`。\n    - 结果是全局 DSU 中的最终集合数量。如果实现正确，这将与 `Global` 结果相匹配。\n\n4.  **`Merge` 策略**：这是另一种并行策略。它首先计算本地晕，然后在边界上合并它们。\n    - 为所有 $N$ 个粒子初始化一个 DSU。\n    - 将粒子划分到子域。\n    - **阶段 1 (本地 FoF)**：对于每个子域 $s$，遍历其所有本地粒子对 $(i, j)$。如果 $d_{\\mathrm{PBC}}(\\mathbf{x}_i, \\mathbf{x}_j) \\leq \\ell$，则调用 `dsu.union(i, j)`。\n    - **阶段 2 (合并)**：对于每个子域 $s=0, \\dots, p-1$，考虑它及其下一个邻居 $s_{\\mathrm{next}} = (s+1) \\pmod p$。遍历所有粒子对 $(i, j)$，其中 $i$ 在子域 $s$ 中，$j$ 在 $s_{\\mathrm{next}}$ 中。如果 $d_{\\mathrm{PBC}}(\\mathbf{x}_i, \\mathbf{x}_j) \\leq \\ell$，则调用 `dsu.union(i, j)`。\n    - 结果是全局 DSU 中的最终集合数量。这也应与 `Global` 结果相匹配。",
            "answer": "```python\nimport numpy as np\nimport math\n\nclass DSU:\n    \"\"\"Disjoint Set Union (Union-Find) data structure.\"\"\"\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.num_sets = n\n\n    def find(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            self.parent[root_j] = root_i\n            self.num_sets -= 1\n            return True\n        return False\n\ndef pbc_distance_sq(pos1, pos2, box_size=1.0):\n    \"\"\"Calculates the squared periodic Euclidean distance.\"\"\"\n    delta = pos1 - pos2\n    delta -= np.round(delta / box_size) * box_size\n    return np.sum(delta**2)\n\ndef strategy_global(N, positions, ell):\n    \"\"\"Global FoF strategy.\"\"\"\n    dsu = DSU(N)\n    ell_sq = ell**2\n    for i in range(N):\n        for j in range(i + 1, N):\n            if pbc_distance_sq(positions[i], positions[j]) = ell_sq:\n                dsu.union(i, j)\n    return dsu.num_sets\n\ndef strategy_naive(N, p, positions, ell):\n    \"\"\"Naive parallel FoF strategy.\"\"\"\n    ell_sq = ell**2\n    subdomain_particles = [[] for _ in range(p)]\n    for i in range(N):\n        s = math.floor(positions[i, 0] * p)\n        subdomain_particles[s].append(i)\n\n    total_halos = 0\n    for s in range(p):\n        particles_in_s = subdomain_particles[s]\n        k = len(particles_in_s)\n        if k == 0:\n            continue\n        \n        local_dsu = DSU(k)\n        # Map global particle index to local DSU index\n        global_to_local_map = {p_idx: i for i, p_idx in enumerate(particles_in_s)}\n\n        for i1_idx in range(k):\n            for i2_idx in range(i1_idx + 1, k):\n                p1 = particles_in_s[i1_idx]\n                p2 = particles_in_s[i2_idx]\n                if pbc_distance_sq(positions[p1], positions[p2]) = ell_sq:\n                    local_dsu.union(global_to_local_map[p1], global_to_local_map[p2])\n        total_halos += local_dsu.num_sets\n        \n    return total_halos\n\ndef strategy_ghost(N, p, positions, ell):\n    \"\"\"Ghost-zone based parallel FoF strategy.\"\"\"\n    dsu = DSU(N)\n    ell_sq = ell**2\n    \n    subdomain_particles = [[] for _ in range(p)]\n    for i in range(N):\n        s = math.floor(positions[i, 0] * p)\n        subdomain_particles[s].append(i)\n\n    for s in range(p):\n        local_particles_set = set(subdomain_particles[s])\n        \n        s_prev = (s - 1 + p) % p\n        s_next = (s + 1) % p\n        \n        left_boundary_x = s / p\n        right_boundary_x = (s + 1) / p\n        \n        ghost_particles_set = set()\n        \n        potential_ghosts = subdomain_particles[s_prev] + subdomain_particles[s_next]\n        for p_idx in potential_ghosts:\n            x_p = positions[p_idx, 0]\n            # Periodic distance to a point on a line\n            dist_left_x = abs(x_p - left_boundary_x)\n            pbc_dist_left_x = min(dist_left_x, 1.0 - dist_left_x)\n\n            dist_right_x = abs(x_p - right_boundary_x)\n            pbc_dist_right_x = min(dist_right_x, 1.0 - dist_right_x)\n\n            if pbc_dist_left_x = ell or pbc_dist_right_x = ell:\n                ghost_particles_set.add(p_idx)\n\n        combined_particles = list(local_particles_set.union(ghost_particles_set))\n        \n        k = len(combined_particles)\n        for i1_idx in range(k):\n            for i2_idx in range(i1_idx + 1, k):\n                p1 = combined_particles[i1_idx]\n                p2 = combined_particles[i2_idx]\n                \n                # Edge must involve at least one local particle\n                if p1 in local_particles_set or p2 in local_particles_set:\n                    if pbc_distance_sq(positions[p1], positions[p2]) = ell_sq:\n                        dsu.union(p1, p2)\n\n    return dsu.num_sets\n\n\ndef strategy_merge(N, p, positions, ell):\n    \"\"\"Merge-based parallel FoF strategy.\"\"\"\n    dsu = DSU(N)\n    ell_sq = ell**2\n    \n    subdomain_particles = [[] for _ in range(p)]\n    for i in range(N):\n        s = math.floor(positions[i, 0] * p)\n        subdomain_particles[s].append(i)\n\n    # Phase 1: Local FoF\n    for s in range(p):\n        particles_in_s = subdomain_particles[s]\n        k = len(particles_in_s)\n        for i1_idx in range(k):\n            for i2_idx in range(i1_idx + 1, k):\n                p1 = particles_in_s[i1_idx]\n                p2 = particles_in_s[i2_idx]\n                if pbc_distance_sq(positions[p1], positions[p2]) = ell_sq:\n                    dsu.union(p1, p2)\n\n    # Phase 2: Cross-boundary merge\n    for s in range(p):\n        s_next = (s + 1) % p\n        particles_s = subdomain_particles[s]\n        particles_s_next = subdomain_particles[s_next]\n        \n        for p1 in particles_s:\n            for p2 in particles_s_next:\n                if pbc_distance_sq(positions[p1], positions[p2]) = ell_sq:\n                    dsu.union(p1, p2)\n\n    return dsu.num_sets\n\n\ndef solve():\n    test_cases = [\n        # Test Case 1\n        {\n            \"N\": 8, \"b\": 0.30, \"p\": 2,\n            \"positions\": np.array([\n                [0.20, 0.20, 0.20], [0.22, 0.20, 0.20], [0.20, 0.22, 0.20], [0.20, 0.20, 0.22],\n                [0.70, 0.70, 0.70], [0.72, 0.70, 0.70], [0.70, 0.72, 0.70], [0.70, 0.70, 0.72]\n            ])\n        },\n        # Test Case 2\n        {\n            \"N\": 10, \"b\": 0.28, \"p\": 3,\n            \"positions\": np.array([\n                [0.322, 0.200, 0.200], [0.345, 0.205, 0.200], [0.332, 0.220, 0.200],\n                [0.318, 0.205, 0.220], [0.349, 0.220, 0.220], [0.550, 0.600, 0.600],\n                [0.560, 0.600, 0.600], [0.550, 0.610, 0.600], [0.550, 0.600, 0.610],\n                [0.560, 0.610, 0.610]\n            ])\n        },\n        # Test Case 3\n        {\n            \"N\": 12, \"b\": 0.25, \"p\": 4,\n            \"positions\": np.array([\n                [0.990, 0.300, 0.300], [0.010, 0.300, 0.300], [0.985, 0.305, 0.300],\n                [0.015, 0.295, 0.300], [0.990, 0.310, 0.295], [0.010, 0.290, 0.305],\n                [0.240, 0.800, 0.800], [0.290, 8.00e-01, 8.00e-01], [0.340, 0.800, 0.800],\n                [0.390, 0.800, 0.800], [0.440, 0.800, 0.800], [0.490, 0.800, 0.800]\n            ])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, b, p, positions = case[\"N\"], case[\"b\"], case[\"p\"], case[\"positions\"]\n        ell = b * (N ** (-1/3.0))\n        \n        num_global = strategy_global(N, positions, ell)\n        num_naive = strategy_naive(N, p, positions, ell)\n        num_ghost = strategy_ghost(N, p, positions, ell)\n        num_merge = strategy_merge(N, p, positions, ell)\n        \n        all_results.append([num_global, num_naive, num_ghost, num_merge])\n\n    # Format the final output string as per requirements\n    result_str = \",\".join(str(r).replace(\" \", \"\") for r in all_results)\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}