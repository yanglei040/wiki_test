{
    "hands_on_practices": [
        {
            "introduction": "识别引力束缚子结构最基本的方法之一是迭代解绑算法。该算法基于一个简单而强大的原则：相对于系统的质心，总能量为负的粒子因其动能不足以克服势阱而被引力束缚。此练习将指导您实现这一基础技术，通过迭代移除未束缚粒子并重新计算系统属性，来最终确定一个自洽的、引力束缚的粒子集合，这是理解和分析宇宙学模拟中结构形成的核心技能。",
            "id": "3476134",
            "problem": "给定一小组子晕候选体，每个候选体由宇宙标度因子为 $a$、哈勃参数为 $H(a)$ 时的粒子位置、物理速度和质量定义。您的任务是使用总比能判据实现一个解绑程序，以确定哪些粒子被引力束缚在其子晕候选体上，然后报告每个候选体的束缚粒子比例。\n\n该问题必须在膨胀宇宙中使用牛顿引力，并基于以下物理上一致的假设和定义，从第一性原理出发进行求解。\n\n- 粒子由其物理位置 $\\mathbf{x}_i$（单位：千秒差距）、物理速度 $\\mathbf{v}_i$（单位：千米每秒）和质量 $m_i$（单位：太阳质量）描述。\n- 哈勃参数 $H(a)$ 以千米每秒每百万秒差距为单位给出，用于通过减去哈勃流来计算本动速度。\n- 粒子 $i$ 的本动速度定义为 $\\mathbf{u}_i = \\mathbf{v}_i - H(a)\\,\\mathbf{x}_i^{\\mathrm{(Mpc)}}$，其中 $\\mathbf{x}_i^{\\mathrm{(Mpc)}}$ 是以百万秒差距为单位的位置，即 $\\mathbf{x}_i^{\\mathrm{(Mpc)}} = \\mathbf{x}_i^{\\mathrm{(kpc)}}/1000$。\n- 在任何一次迭代中，当前粒子集的整体本动速度由质量加权平均值定义：\n$$\n\\mathbf{u}_{\\mathrm{bulk}} = \\frac{\\sum_i m_i \\mathbf{u}_i}{\\sum_i m_i}.\n$$\n- 粒子 $i$ 相对于整体的比动能为：\n$$\nK_i = \\frac{1}{2}\\,\\|\\mathbf{u}_i - \\mathbf{u}_{\\mathrm{bulk}}\\|^2.\n$$\n- 粒子 $i$ 因当前集合中所有其他粒子而产生的比引力势能，使用长度为 $\\epsilon$（单位：千秒差距）的 Plummer 软化计算如下：\n$$\n\\phi_i = - G \\sum_{j \\neq i} \\frac{m_j}{\\sqrt{\\|\\mathbf{x}_i - \\mathbf{x}_j\\|^2 + \\epsilon^2}},\n$$\n其中引力常数需使用天体物理单位制下的值 $G = 4.300917270\\times 10^{-6}\\,(\\mathrm{km/s})^2\\,\\mathrm{kpc}/M_\\odot$。\n- 总比能为 $E_i = K_i + \\phi_i$。当且仅当 $E_i < 0$ 时，粒子被分类为束缚态。\n- 使用迭代解绑程序：从所有候选粒子开始，计算每个粒子的 $\\mathbf{u}_{\\mathrm{bulk}}$，然后是 $\\phi_i$ 和 $E_i$，移除所有 $E_i \\ge 0$ 的粒子，并重复此过程直到收敛（没有粒子被移除）或集合变空。最终的束缚集即为收敛后的集合。\n\n所有计算必须一致地使用所述单位，其中距离单位为千秒差距，速度单位为千米每秒，质量单位为太阳质量，$H(a)$ 单位为千米每秒每百万秒差距。本任务不涉及角度。最终答案必须以四舍五入到三位小数的小数浮点数形式报告。\n\n实现一个程序来评估以下测试套件。对于每种情况，位置以千秒差距为单位的向量列表 $[\\,[x,y,z],\\ldots\\,]$ 给出，速度以千米每秒为单位的向量列表 $[\\,[v_x,v_y,v_z],\\ldots\\,]$ 给出，质量以太阳质量为单位的列表 $[\\,m_0,\\ldots\\,]$ 给出。哈勃参数 $H(a)$ 的单位是千米每秒每百万秒差距，标度因子是 $a$，软化长度 $\\epsilon$ 的单位是千秒差距。\n\n- 情况 A（双体圆周轨道，理想路径）：\n    - $a = 1$，$H(a) = 70$。\n    - $\\epsilon = 0.05$。\n    - 位置（千秒差距）：$[\\,[-5,0,0],[5,0,0]\\,]$。\n    - 质量（太阳质量）：$[\\,10^9, 10^9\\,]$。\n    - 速度（千米每秒）：令 $d = 10$ 为以千秒差距为单位的间距，并定义本动圆周速度大小为 $v_c = \\sqrt{G m/(2d)}$，其中 $m = 10^9$。那么物理速度为\n      $$\n      \\mathbf{v}_0 = [\\, -0.35,\\, +v_c,\\, 0 \\,],\\quad \\mathbf{v}_1 = [\\, +0.35,\\,-v_c,\\, 0 \\,],\n      $$\n      其中哈勃流项 $\\pm 0.35$ 来自 $H(a)\\,x$，其中 $x=\\pm 0.005$ 百万秒差距。\n\n- 情况 B（一个中央大质量粒子带一个束缚卫星和一个非束缚卫星）：\n    - $a = 1$，$H(a) = 70$。\n    - $\\epsilon = 0.05$。\n    - 位置（千秒差距）：$[\\, [0,0,0],\\,[5,0,0],\\,[0,8,0]\\, ]$。\n    - 质量（太阳质量）：$[\\,10^{10},\\,5\\times 10^9,\\,5\\times 10^8\\,]$。\n    - 速度（千米每秒）：定义本动速度为 $[\\, [0,0,0],\\,[0,50,0],\\,[0,200,0]\\, ]$ 并加上哈勃流以获得物理速度。唯一非零的哈勃贡献是对于位于 $[\\,5,0,0\\,]$ 的粒子，其 $H(a)\\,x = 0.35$，得到\n      $$\n      \\mathbf{v}_0 = [\\,0,\\,0,\\,0\\,],\\quad \\mathbf{v}_1 = [\\,0.35,\\,50,\\,0\\,],\\quad \\mathbf{v}_2 = [\\,0,\\,200,\\,0\\,].\n      $$\n\n- 情况 C（单粒子边界情况）：\n    - $a = 1$，$H(a) = 70$。\n    - $\\epsilon = 0.05$。\n    - 位置（千秒差距）：$[\\, [0,0,0] \\,]$。\n    - 质量（太阳质量）：$[\\,10^9\\,]$。\n    - 速度（千米每秒）：$[\\, [0,0,0] \\,]$。\n\n- 情况 D（以质心为参考的临界非束缚双体）：\n    - $a = 1$，$H(a) = 70$。\n    - $\\epsilon = 0.05$。\n    - 位置（千秒差距）：$[\\, [0,0,0],\\,[20,0,0] \\,]$。\n    - 质量（太阳质量）：$[\\,10^9,\\,10^9\\,]$。\n    - 速度（千米每秒）：设置第一个粒子的本动速度为 $[\\,0,0,0\\,]$，第二个粒子的本动速度大小为\n      $$\n      v_b = \\sqrt{\\frac{8\\,G\\,m}{d}},\n      $$\n      其中 $m=10^9$，$d=20$ 千秒差距是间距，方向沿 $+y$。加上哈勃流以获得物理速度。因此\n      $$\n      \\mathbf{v}_0 = [\\,0,\\,0,\\,0\\,],\\quad \\mathbf{v}_1 = [\\,1.4,\\,v_b,\\,0\\,],\n      $$\n      因为 $x=0.02$ 百万秒差距给出 $H(a)\\,x = 1.4$。\n\n您的程序必须对每种情况应用迭代解绑程序，并输出束缚粒子比例，该比例定义为收敛后束缚粒子数与初始粒子数之比，以四舍五入到三位小数的小数形式表示。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[f_A,f_B,f_C,f_D]\"），格式需完全一致。\n\n所有数值工作必须使用上述单位。按指定顺序报告四种情况的四个束缚粒子比例。",
            "solution": "用户要求在宇宙学背景下，实现一种迭代解绑算法，以识别子晕候选体内的引力束缚粒子。对于每个候选体，必须计算束缚粒子相对于初始集合的比例。该问题是适定的，并且科学上基于应用于膨胀宇宙的牛顿力学原理，这在N体宇宙学模拟的分析中很常见。\n\n该方法的核心在于每个粒子的总比能。如果一个粒子的总能量为负，则认为它被引力束缚在一个系统上，这意味着它缺乏足够的动能来逃离系统的引力势阱。这个过程是迭代的，因为移除未束缚的粒子会改变系统的总质量和质心速度，这反过来又会影响剩余粒子的能量计算。\n\n对于每个子晕候选体，算法按以下步骤进行：\n\n1.  **初始化**：从完整的候选粒子集开始，每个粒子由其质量 $m_i$、物理位置 $\\mathbf{x}_i$ 和物理速度 $\\mathbf{v}_i$ 描述。记录初始粒子数 $N_{\\mathrm{initial}}$。确定宇宙学参数，即哈勃参数 $H(a)$ 和引力常数 $G = 4.300917270\\times 10^{-6}\\,(\\mathrm{km/s})^2\\,\\mathrm{kpc}/M_\\odot$。\n\n2.  **迭代解绑循环**：重复该过程，直到某次迭代中不再有粒子被移除，这表明系统已收敛到一个稳定的自束缚系统。\n\n    a.  **本动速度计算**：首先，必须从粒子的物理速度中移除宇宙膨胀（哈勃流）的影响，以获得它们的本动速度。粒子 $i$ 的本动速度 $\\mathbf{u}_i$ 是其相对于其所在位置哈勃流的运动，计算公式如下：\n        $$\n        \\mathbf{u}_i = \\mathbf{v}_i - H(a)\\,\\mathbf{x}_i^{\\mathrm{(Mpc)}}\n        $$\n        其中 $\\mathbf{x}_i^{\\mathrm{(Mpc)}}$ 是以百万秒差距（Mpc）表示的粒子位置矢量，通过从千秒差距（kpc）转换得到，即 $\\mathbf{x}_i^{\\mathrm{(Mpc)}} = \\mathbf{x}_i^{\\mathrm{(kpc)}} / 1000$。\n\n    b.  **整体速度计算**：确定当前粒子集的质心速度。这个“整体”本动速度作为计算动能的参考系。它是各个本动速度的质量加权平均值：\n        $$\n        \\mathbf{u}_{\\mathrm{bulk}} = \\frac{\\sum_i m_i \\mathbf{u}_i}{\\sum_i m_i}\n        $$\n        求和是对当前候选集中的所有粒子进行的。\n\n    c.  **比能计算**：对于每个粒子 $i$，其总比能 $E_i$（单位质量的能量）是其比动能 $K_i$ 和比势能 $\\phi_i$ 的和。\n        \n        i.  **比动能**：这是相对于系统整体运动的动能：\n            $$\n            K_i = \\frac{1}{2}\\,\\|\\mathbf{u}_i - \\mathbf{u}_{\\mathrm{bulk}}\\|^2\n            $$\n\n        ii. **比引力势能**：这是粒子 $i$ 由于当前集合中所有其他粒子 $j$ 的引力场而产生的势能。引入 Plummer 软化长度 $\\epsilon$ 以防止势能在小粒子间距处发散：\n            $$\n            \\phi_i = - G \\sum_{j \\neq i} \\frac{m_j}{\\sqrt{\\|\\mathbf{x}_i - \\mathbf{x}_j\\|^2 + \\epsilon^2}}\n            $$\n\n    d.  **束缚判据和粒子移除**：如果一个粒子 $i$ 的总比能为负，则它被分类为引力束缚态：\n        $$\n        E_i = K_i + \\phi_i < 0\n        $$\n        所有 $E_i \\ge 0$ 的粒子都被视为未束缚，并在下一次迭代中从集合中移除。\n\n3.  **终止和最终计算**：当一次迭代没有移除任何粒子，或者粒子集变为空时，循环终止。计算最终收敛集合中的粒子数 $N_{\\mathrm{final}}$。然后，候选体的束缚粒子比例计算为以下比率：\n    $$\n    f_{\\mathrm{bound}} = \\frac{N_{\\mathrm{final}}}{N_{\\mathrm{initial}}}\n    $$\n    该比例报告时需四舍五入到三位小数。对于单粒子系统，$\\mathbf{u}_{\\mathrm{bulk}} = \\mathbf{u}_0$，所以 $K_0=0$。势能求和 $\\phi_0$ 为空，所以 $\\phi_0=0$。因此 $E_0=0$，该粒子未束缚，导致束缚粒子比例为 $0$。\n\n这个基于物理动机的迭代算法将被应用于所提供的每个测试案例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the bound fraction of particles in four subhalo candidate test cases.\n    \"\"\"\n    G_ASTRO = 4.300917270e-6  # (km/s)^2 * kpc / M_sun\n\n    def calculate_bound_fraction(pos, vel, mass, H, epsilon):\n        \"\"\"\n        Performs the iterative unbinding procedure and returns the bound fraction.\n        \"\"\"\n        # Ensure inputs are numpy arrays\n        pos = np.array(pos, dtype=np.float64)\n        vel = np.array(vel, dtype=np.float64)\n        mass = np.array(mass, dtype=np.float64)\n        \n        if pos.ndim == 1: pos = pos.reshape(1, -1)\n        if vel.ndim == 1: vel = vel.reshape(1, -1)\n        if mass.ndim == 0: mass = mass.reshape(1)\n\n        initial_particle_count = len(mass)\n        if initial_particle_count == 0:\n            return 0.0\n\n        current_indices = np.arange(initial_particle_count)\n        \n        while True:\n            num_particles = len(current_indices)\n            if num_particles == 0:\n                break\n\n            current_pos = pos[current_indices]\n            current_vel = vel[current_indices]\n            current_mass = mass[current_indices]\n\n            # 1. Calculate peculiar velocities\n            pos_mpc = current_pos / 1000.0\n            hubble_flow = H * pos_mpc\n            peculiar_vel = current_vel - hubble_flow\n\n            # 2. Calculate bulk peculiar velocity\n            total_mass = np.sum(current_mass)\n            if total_mass == 0: # Should not happen with positive masses\n                break\n                \n            mass_vel_product = current_mass[:, np.newaxis] * peculiar_vel\n            bulk_vel = np.sum(mass_vel_product, axis=0) / total_mass\n            \n            # 3. Calculate specific energies\n            # Specific kinetic energy\n            rel_vel = peculiar_vel - bulk_vel\n            kinetic_energy = 0.5 * np.sum(rel_vel**2, axis=1)\n\n            # Specific potential energy\n            potential_energy = np.zeros(num_particles, dtype=np.float64)\n            for i in range(num_particles):\n                # Vectorized calculation for particle i's potential\n                # from all other particles j\n                delta_pos = current_pos[i] - current_pos\n                dist_sq = np.sum(delta_pos**2, axis=1)\n                \n                # Create a mask to exclude the i=j case and handle small mass particles\n                valid_j = np.ones(num_particles, dtype=bool)\n                valid_j[i] = False\n                \n                if np.any(valid_j):\n                    # Denominator of potential term, with softening\n                    denom = np.sqrt(dist_sq[valid_j] + epsilon**2)\n                    # Sum of potential contributions from all other particles\n                    potential_energy[i] = -G_ASTRO * np.sum(current_mass[valid_j] / denom)\n            \n            total_energy = kinetic_energy + potential_energy\n\n            # 4. Identify bound particles and create a new index list\n            bound_mask = total_energy < 0\n            new_indices = current_indices[bound_mask]\n\n            # 5. Check for convergence\n            if len(new_indices) == num_particles:\n                break  # Converged\n            \n            current_indices = new_indices\n            \n        final_particle_count = len(current_indices)\n        bound_fraction = final_particle_count / initial_particle_count\n        \n        return round(bound_fraction, 3)\n\n    # --- Test Cases ---\n\n    # Case A: Two-body circular orbit\n    d_a = 10.0\n    m_a = 1e9\n    v_c_a = np.sqrt(G_ASTRO * m_a / (2 * d_a))\n    vel_a = [\n        [-0.35, v_c_a, 0.0],\n        [0.35, -v_c_a, 0.0]\n    ]\n    case_a = (\n        [[-5.0, 0.0, 0.0], [5.0, 0.0, 0.0]],  # pos\n        vel_a,                                 # vel\n        [1e9, 1e9],                            # mass\n        70.0,                                  # H\n        0.05                                   # epsilon\n    )\n\n    # Case B: Central massive particle with one bound and one unbound satellite\n    case_b = (\n        [[0.0, 0.0, 0.0], [5.0, 0.0, 0.0], [0.0, 8.0, 0.0]], # pos\n        [[0.0, 0.0, 0.0], [0.35, 50.0, 0.0], [0.0, 200.0, 0.0]], # vel\n        [1e10, 5e9, 5e8],                      # mass\n        70.0,                                  # H\n        0.05                                   # epsilon\n    )\n\n    # Case C: Single particle boundary case\n    case_c = (\n        [[0.0, 0.0, 0.0]],                     # pos\n        [[0.0, 0.0, 0.0]],                     # vel\n        [1e9],                                 # mass\n        70.0,                                  # H\n        0.05                                   # epsilon\n    )\n\n    # Case D: Two-body borderline unbound\n    d_d = 20.0\n    m_d = 1e9\n    v_b_d = np.sqrt(8.0 * G_ASTRO * m_d / d_d)\n    vel_d = [\n        [0.0, 0.0, 0.0],\n        [1.4, v_b_d, 0.0]\n    ]\n    case_d = (\n        [[0.0, 0.0, 0.0], [20.0, 0.0, 0.0]],  # pos\n        vel_d,                                 # vel\n        [1e9, 1e9],                            # mass\n        70.0,                                  # H\n        0.05                                   # epsilon\n    )\n    \n    test_cases = [case_a, case_b, case_c, case_d]\n    results = [calculate_bound_fraction(*case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然能量判据是基础，但在真实的模拟数据中，它有时会被一些瞬态结构所误导，例如相空间焦散（caustics）。这些结构在空间上看起来是超密区，但并非真正的引力束缚系统。此练习将挑战您去构建一个更稳健的分类器，它不仅依赖于能量，还利用了角动量相干性等运动学信息，从而能够区分真正旋转或压力支持的束缚子结构和那些仅仅是粒子流交叉形成的伪结构。",
            "id": "3476093",
            "problem": "考虑一个用于评估在宇宙学模拟中识别引力束缚子结构之解绑算法的、综合性的且物理上一致的评估方法。任务是构建对抗性的相空间数据集，其中壳状的相空间焦散会产生模拟束缚子晕的视超密度，并评估一个依赖于比能符号和角动量相干性的解绑决策规则。所有计算必须使用有物理意义的单位，并且输出必须是可程序化验证的。\n\n从以下基本原理和定义开始：\n\n1. 牛顿引力。对于一个质量为 $m$ 的粒子在引力势 $\\Phi(\\mathbf{r})$ 中运动，其比（单位质量）总能量为\n$$\ne(\\mathbf{r},\\mathbf{v}) = \\tfrac{1}{2}\\|\\mathbf{v}\\|^{2} + \\Phi(\\mathbf{r})\n$$\n当且仅当 $e(\\mathbf{r},\\mathbf{v}) < 0$ 时，一个粒子被引力束缚于势源。\n\n2. 对于一个以总质量为 $M_{\\mathrm{sub}}$、标度半径为 $a$ 的 Plummer 球模型为模型的候选子结构，相对于候选子结构中心的位置 $\\mathbf{r}$ 处的引力势为\n$$\n\\Phi_{\\mathrm{Plummer}}(\\mathbf{r}) = -\\frac{G M_{\\mathrm{sub}}}{\\sqrt{\\|\\mathbf{r}\\|^{2} + a^{2}}},\n$$\n其中 $G$ 是引力常数。在半径 $r = \\|\\mathbf{r}\\|$ 处的逃逸速度为\n$$\nv_{\\mathrm{esc}}(r) = \\sqrt{-2\\,\\Phi_{\\mathrm{Plummer}}(r)} = \\sqrt{\\frac{2 G M_{\\mathrm{sub}}}{\\sqrt{r^{2}+a^{2}}}}.\n$$\n\n3. 角动量相干性。对于一个位置为 $\\mathbf{r}$、速度为 $\\mathbf{v}$（两者均相对于候选子结构的质心测量）的粒子，其比角动量矢量为\n$$\n\\mathbf{L} = \\mathbf{r} \\times \\mathbf{v}.\n$$\n对于 $\\|\\mathbf{L}\\| > 0$ 的粒子，定义单位角动量方向为 $\\widehat{\\mathbf{L}} = \\mathbf{L}/\\|\\mathbf{L}\\|$。对于一个包含 $N$ 个粒子的集合，其角动量相干性度量为\n$$\n\\kappa = \\left\\| \\frac{1}{N'} \\sum_{i=1}^{N'} \\widehat{\\mathbf{L}}_{i} \\right\\|,\n$$\n其中求和遍及 $N'$ 个 $\\|\\mathbf{L}\\|$ 不为零的粒子，且 $0 \\le \\kappa \\le 1$。大的 $\\kappa$ 值表示轨道平面对齐或净旋转，而小的 $\\kappa$ 值表示弥散或焦散壳典型的径向运动。\n\n评估候选子结构的算法：\n- 计算候选粒子的质心位置和速度。\n- 计算每个粒子相对于质心的比能 $e_{i} = \\tfrac{1}{2}\\|\\mathbf{v}_{i}\\|^{2} + \\Phi_{\\mathrm{Plummer}}(\\mathbf{r}_{i})$。\n- 计算束缚分数 $f_{\\mathrm{bound}}$，即 $e_{i} < 0$ 的粒子所占的比例。\n- 计算角动量相干性度量 $\\kappa$。\n- 当且仅当 $f_{\\mathrm{bound}} \\ge \\tau_{E}$ 和 $\\kappa \\ge \\tau_{L}$ 同时满足时，将候选子结构分类为束缚态，其中 $\\tau_{E}$ 和 $\\tau_{L}$ 是决策阈值。\n\n综合数据构建：\n- 束缚子晕的粒子从标度半径为 $a$ 的 Plummer 空间分布中抽取，其速度可以是切向相干的（以产生高 $\\kappa$）或各向同性的（以产生低 $\\kappa$），速度大小设为局部逃逸速度 $v_{\\mathrm{esc}}(r)$ 的一个固定比例，以确保 $e<0$。\n- 焦散壳粒子在半径为 $R_{\\mathrm{shell}}$ 的薄球壳中抽取，具有较小的径向速度（呈高斯分布且离散度小）以模仿相空间焦散；在较大的 $R_{\\mathrm{shell}}$ 处，它们相对于建模的小子晕的比能主要为正。\n\n单位和常数：\n- 位置必须以千秒差距（kpc）为单位。\n- 速度必须以千米/秒（km/s）为单位。\n- 质量必须以太阳质量（$M_{\\odot}$）为单位。\n- 使用引力常数 $G = 4.302\\times10^{-6}$，单位为 $\\mathrm{kpc}\\,M_{\\odot}^{-1}\\,(\\mathrm{km}/\\mathrm{s})^{2}$。\n\n测试套件：\n您的程序必须使用上述模型确定性地生成四个测试用例，并对每个用例评估解绑算法。为保证可复现性，请使用固定的伪随机种子。测试套件必须包括以下参数集：\n\n- 测试用例 1（理想情况，旋转的束缚子晕）：\n  - $G = 4.302\\times10^{-6}$。\n  - $M_{\\mathrm{sub}} = 10^{9}\\,M_{\\odot}$。\n  - $a = 1\\,\\mathrm{kpc}$。\n  - 粒子数 $N = 600$。\n  - 切向速度分数为 $v_{\\mathrm{esc}}(r)$ 的 $f_{v} = 0.4$，围绕固定轴对齐以产生大的 $\\kappa$。\n  - 阈值 $\\tau_{E} = 0.5$, $\\tau_{L} = 0.3$。\n  - 基准标签：束缚。\n\n- 测试用例 2（模拟超密度的对抗性焦散壳）：\n  - $G = 4.302\\times10^{-6}$。\n  - $M_{\\mathrm{sub}} = 10^{8}\\,M_{\\odot}$。\n  - $a = 1\\,\\mathrm{kpc}$。\n  - 壳半径 $R_{\\mathrm{shell}} = 50\\,\\mathrm{kpc}$，壳厚度标准差 $\\sigma_{R} = 0.5\\,\\mathrm{kpc}$。\n  - 粒子数 $N = 800$。\n  - 径向速度弥散 $\\sigma_{v} = 5\\,\\mathrm{km}/\\mathrm{s}$，中心为 0，以模拟焦散。\n  - 阈值 $\\tau_{E} = 0.5$, $\\tau_{L} = 0.3$。\n  - 基准标签：非束缚。\n\n- 测试用例 3（边界混合：子晕加焦散壳）：\n  - $G = 4.302\\times10^{-6}$。\n  - 子晕：$M_{\\mathrm{sub}} = 6\\times10^{8}\\,M_{\\odot}$，$a = 0.8\\,\\mathrm{kpc}$，$N_{\\mathrm{sub}} = 300$，切向速度分数 $f_{v} = 0.5$。\n  - 壳：$R_{\\mathrm{shell}} = 20\\,\\mathrm{kpc}$，$\\sigma_{R} = 0.3\\,\\mathrm{kpc}$，$N_{\\mathrm{shell}} = 220$，$\\sigma_{v} = 4\\,\\mathrm{km}/\\mathrm{s}$。\n  - 阈值 $\\tau_{E} = 0.55$, $\\tau_{L} = 0.25$。\n  - 基准标签：束缚。\n\n- 测试用例 4（边缘情况：角动量相干性低的各向同性束缚子晕）：\n  - $G = 4.302\\times10^{-6}$。\n  - $M_{\\mathrm{sub}} = 8\\times10^{8}\\,M_{\\odot}$。\n  - $a = 0.7\\,\\mathrm{kpc}$。\n  - 粒子数 $N = 500$。\n  - 各向同性的速度方向，速度分数为 $v_{\\mathrm{esc}}(r)$ 的 $f_{v} = 0.4$，以确保 $e<0$ 但抑制 $\\kappa$。\n  - 阈值 $\\tau_{E} = 0.6$, $\\tau_{L} = 0.4$。\n  - 基准标签：束缚。\n\n程序行为要求：\n- 精确按照描述实现上述数据生成和解绑算法。\n- 对每个测试用例，计算算法的分类结果并与基准标签进行比较。\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个元素都是一个布尔值，表示该测试用例的算法分类是否与基准真相匹配（例如，$\\left[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True}\\right]$）。\n- 如果内部使用了角度，应以弧度处理，但输出是无量纲的布尔值。所有内部计算必须统一使用指定的位置、速度、质量和 $G$ 的单位。",
            "solution": "该问题是有效的。其前提在科学上是合理的，基于牛顿力学和计算宇宙学的标准实践。所给出的模型、常数和算法定义明确，足以构建一个唯一的、可验证的解决方案。\n\n问题的核心是实现一个确定性模拟和一个分类算法。该模拟生成四个不同的粒子相空间数据测试用例，分别代表简化的天体物理场景：一个旋转的束缚子结构、一个由焦散壳产生的伪超密度、两者的混合体，以及一个各向同性（由压力支持）的束缚子结构。然后，算法分析每个数据集，将其分类为引力束缚或非束缚。\n\n对于每个测试用例，解决方案分为两个主要阶段：数据生成和分类。使用单个固定的伪随机数生成器种子确保所有测试用例的可复现性。所有计算都严格遵守指定的单位：位置使用千秒差距（$kpc$），速度使用千米/秒（$km/s$），质量使用太阳质量（$M_{\\odot}$），引力常数 $G = 4.302\\times10^{-6}\\, \\mathrm{kpc}\\,M_{\\odot}^{-1}\\,(\\mathrm{km}/\\mathrm{s})^{2}$。\n\n### 数据生成\n\n粒子坐标（位置 $\\mathbf{r}$ 和速度 $\\mathbf{v}$）的生成遵循所述模型。\n\n1.  **Plummer 球模型（束缚子晕）：**\n    *   **位置：** 粒子位置从 Plummer 密度剖面 $\\rho(r) \\propto (1 + (r/a)^2)^{-5/2}$ 中采样，其中 $a$ 是标度半径。这是通过对径向累积质量分布函数 $M(<r)$ 进行逆变换采样来实现的。\n    *   **速度：**\n        *   **旋转（相干）：** 对于测试用例 1 和 3，生成切向速度。速度大小设置为局部逃逸速度的 $f_v$ 倍，$v = f_v v_{\\mathrm{esc}}(r)$，其中 $f_v < 1$ 确保粒子能量为负（即束缚态）。速度方向垂直于位置矢量和固定的旋转轴（例如 $\\hat{z}$ 轴），以产生高角动量相干性 $\\kappa$。\n        *   **各向同性：** 对于测试用例 4，速度方向是随机的。速度大小同样设置为 $v = f_v v_{\\mathrm{esc}}(r)$ 以确保粒子是束缚的，但随机方向会使净角动量矢量接近于零，从而产生低 $\\kappa$ 值。\n\n2.  **焦散壳模型：**\n    *   **位置：** 粒子半径从以 $R_{\\mathrm{shell}}$ 为中心、标准差为 $\\sigma_R$ 的高斯分布中抽取，方向随机。这会在空间中创建一个薄球壳。\n    *   **速度：** 粒子被赋予较小的、以零为中心呈高斯分布的径向速度。这种运动模式模仿了从外部掉入的物质在轨道远心点附近速度变慢并转向时形成的焦散。由于它们离中心很远，它们的引力势能 $\\Phi_{\\mathrm{Plummer}}$ 接近于零，而它们具有非零的动能，因此它们的总比能 $e$ 通常为正。\n\n3.  **混合模型（测试用例 3）：**\n    *   此用例通过合并一个束缚子晕粒子集和一个焦散壳粒子集来创建。位置和速度是独立生成的，然后简单地组合成一个单一的数据集。\n\n### 分类算法\n\n对于每个生成的粒子数据集，执行以下步骤：\n\n1.  **变换到质心参考系：** 计算所有粒子的质心位置 $\\mathbf{r}_{\\mathrm{cm}}$ 和质心速度 $\\mathbf{v}_{\\mathrm{cm}}$，然后将所有粒子的位置和速度变换到此参考系中：$\\mathbf{r}'_i = \\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}$ 和 $\\mathbf{v}'_i = \\mathbf{v}_i - \\mathbf{v}_{\\mathrm{cm}}$。\n\n2.  **计算比能：** 对于每个粒子，使用其质心参考系中的坐标 $\\mathbf{r}'_i$ 和 $\\mathbf{v}'_i$ 计算其比能：\n    $$\n    e_i = \\frac{1}{2} \\|\\mathbf{v}'_i\\|^2 - \\frac{G M_{\\mathrm{sub}}}{\\sqrt{\\|\\mathbf{r}'_i\\|^2 + a^2}}\n    $$\n    其中 $M_{\\mathrm{sub}}$ 和 $a$ 是用于评估的子晕模型的参数。\n\n3.  **计算束缚分数 $f_{\\mathrm{bound}}$：** 这是能量为负的粒子数与总粒子数的比率：$f_{\\mathrm{bound}} = (\\text{count of } e_i < 0) / N$。\n\n4.  **计算角动量相干性 $\\kappa$：** 对于每个粒子，计算其比角动量 $\\mathbf{L}_i = \\mathbf{r}'_i \\times \\mathbf{v}'_i$。只考虑那些 $\\|\\mathbf{L}_i\\| > 0$ 的粒子，计算它们的单位角动量矢量 $\\hat{\\mathbf{L}}_i$ 的矢量平均值，并取其范数。\n\n5.  **应用决策规则：** 将计算出的 $f_{\\mathrm{bound}}$ 和 $\\kappa$ 与每个测试用例指定的阈值 $\\tau_E$ 和 $\\tau_L$ 进行比较。如果 $f_{\\mathrm{bound}} \\ge \\tau_E$ 并且 $\\kappa \\ge \\tau_L$，则将该结构分类为束缚态（True），否则为非束缚态（False）。\n\n6.  **验证：** 将算法的分类结果与每个测试用例的基准真相标签进行比较，并记录布尔值 `True`（匹配）或 `False`（不匹配）。\n\n最终输出是一个包含四个布尔值的列表，每个布尔值对应于每个测试用例的验证结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the unbinding algorithm.\n    It generates four specified test cases of particle phase-space data\n    and evaluates a classification algorithm against them.\n    \"\"\"\n    \n    # Use a single, fixed pseudorandom number generator for reproducibility.\n    RNG = np.random.default_rng(12345)\n\n    # Physical constant in specified units.\n    G = 4.302e-6  # kpc * M_sun^-1 * (km/s)^2\n\n    def _generate_random_unit_vectors(n_points, dim=3):\n        \"\"\"Generates n_points random unit vectors in dim dimensions.\"\"\"\n        vecs = RNG.normal(size=(n_points, dim))\n        mags = np.linalg.norm(vecs, axis=1, keepdims=True)\n        # Avoid division by zero for zero-magnitude vectors (highly improbable).\n        mags[mags == 0] = 1.0\n        return vecs / mags\n\n    def _generate_plummer_positions(N, a):\n        \"\"\"Generates N particle positions from a Plummer distribution.\"\"\"\n        u = RNG.uniform(size=N)\n        u = np.clip(u, 1e-12, 1.0 - 1e-12)\n        radii = a / np.sqrt(u**(-2./3.) - 1.)\n        unit_vecs = _generate_random_unit_vectors(N)\n        return radii[:, np.newaxis] * unit_vecs\n\n    def _generate_rotating_velocities(positions, M_sub, a, f_v):\n        \"\"\"Generates tangentially coherent velocities.\"\"\"\n        radii = np.linalg.norm(positions, axis=1)\n        v_esc = np.sqrt(2 * G * M_sub / np.sqrt(radii**2 + a**2))\n        speeds = f_v * v_esc\n        \n        rot_axis = np.array([0., 0., 1.])\n        tangent_vecs = np.cross(rot_axis, positions)\n        tangent_mags = np.linalg.norm(tangent_vecs, axis=1, keepdims=True)\n\n        zero_mag_mask = (tangent_mags < 1e-9).flatten()\n        tangent_mags[zero_mag_mask] = 1.0\n        tangent_vecs[zero_mag_mask] = np.array([1., 0., 0.])\n        \n        unit_tangents = tangent_vecs / tangent_mags\n        return speeds[:, np.newaxis] * unit_tangents\n\n    def _generate_isotropic_velocities(positions, M_sub, a, f_v):\n        \"\"\"Generates isotropic velocities.\"\"\"\n        radii = np.linalg.norm(positions, axis=1)\n        v_esc = np.sqrt(2 * G * M_sub / np.sqrt(radii**2 + a**2))\n        speeds = f_v * v_esc\n        unit_vecs = _generate_random_unit_vectors(positions.shape[0])\n        return speeds[:, np.newaxis] * unit_vecs\n\n    def _generate_shell_positions(N, R_shell, sigma_R):\n        \"\"\"Generates N particle positions in a thin spherical shell.\"\"\"\n        radii = RNG.normal(loc=R_shell, scale=sigma_R, size=N)\n        radii = np.abs(radii)\n        unit_vecs = _generate_random_unit_vectors(N)\n        return radii[:, np.newaxis] * unit_vecs\n\n    def _generate_shell_velocities(positions, sigma_v):\n        \"\"\"Generates small radial velocities for shell particles.\"\"\"\n        N = positions.shape[0]\n        radial_speeds = RNG.normal(loc=0., scale=sigma_v, size=N)\n        \n        pos_mags = np.linalg.norm(positions, axis=1, keepdims=True)\n        pos_mags[pos_mags == 0] = 1.0\n        unit_vectors = positions / pos_mags\n        return radial_speeds[:, np.newaxis] * unit_vectors\n    \n    def _classify_structure(positions, velocities, M_sub, a, tau_E, tau_L):\n        \"\"\"\n        Applies the unbinding algorithm to classify the particle system.\n        \"\"\"\n        com_pos = np.mean(positions, axis=0)\n        com_vel = np.mean(velocities, axis=0)\n        rel_pos = positions - com_pos\n        rel_vel = velocities - com_vel\n\n        r_mag = np.linalg.norm(rel_pos, axis=1)\n        v_sq = np.sum(rel_vel**2, axis=1)\n        phi = -G * M_sub / np.sqrt(r_mag**2 + a**2)\n        energies = 0.5 * v_sq + phi\n        \n        f_bound = np.sum(energies < 0) / len(positions)\n\n        L = np.cross(rel_pos, rel_vel)\n        L_mag = np.linalg.norm(L, axis=1)\n        \n        valid_L_mask = L_mag > 1e-12\n        N_prime = np.sum(valid_L_mask)\n        \n        if N_prime == 0:\n            kappa = 0.0\n        else:\n            L_hat = L[valid_L_mask] / L_mag[valid_L_mask, np.newaxis]\n            mean_L_hat = np.mean(L_hat, axis=0)\n            kappa = np.linalg.norm(mean_L_hat)\n            \n        is_classified_as_bound = (f_bound >= tau_E) and (kappa >= tau_L)\n        return is_classified_as_bound\n\n    test_cases = [\n        # Case 1: Happy path, rotating bound subhalo\n        {\n            \"type\": \"subhalo\", \"M_sub\": 1e9, \"a\": 1.0, \"N\": 600, \n            \"vel_type\": \"rotating\", \"f_v\": 0.4,\n            \"tau_E\": 0.5, \"tau_L\": 0.3, \"ground_truth\": True\n        },\n        # Case 2: Adversarial caustic shell\n        {\n            \"type\": \"shell\", \"M_sub\": 1e8, \"a\": 1.0, \"N\": 800, \n            \"R_shell\": 50.0, \"sigma_R\": 0.5, \"sigma_v\": 5.0,\n            \"tau_E\": 0.5, \"tau_L\": 0.3, \"ground_truth\": False\n        },\n        # Case 3: Mixed subhalo and shell\n        {\n            \"type\": \"mixed\", \n            \"M_sub\": 6e8, \"a\": 0.8, \"N_sub\": 300, \"f_v\": 0.5,\n            \"R_shell\": 20.0, \"sigma_R\": 0.3, \"N_shell\": 220, \"sigma_v\": 4.0,\n            \"tau_E\": 0.55, \"tau_L\": 0.25, \"ground_truth\": True\n        },\n        # Case 4: Isotropic bound subhalo\n        {\n            \"type\": \"subhalo\", \"M_sub\": 8e8, \"a\": 0.7, \"N\": 500,\n            \"vel_type\": \"isotropic\", \"f_v\": 0.4,\n            \"tau_E\": 0.6, \"tau_L\": 0.4, \"ground_truth\": True\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"type\"] == \"subhalo\":\n            positions = _generate_plummer_positions(case[\"N\"], case[\"a\"])\n            if case[\"vel_type\"] == \"rotating\":\n                velocities = _generate_rotating_velocities(\n                    positions, case[\"M_sub\"], case[\"a\"], case[\"f_v\"])\n            else: # isotropic\n                velocities = _generate_isotropic_velocities(\n                    positions, case[\"M_sub\"], case[\"a\"], case[\"f_v\"])\n        \n        elif case[\"type\"] == \"shell\":\n            positions = _generate_shell_positions(case[\"N\"], case[\"R_shell\"], case[\"sigma_R\"])\n            velocities = _generate_shell_velocities(positions, case[\"sigma_v\"])\n\n        elif case[\"type\"] == \"mixed\":\n            pos_sub = _generate_plummer_positions(case[\"N_sub\"], case[\"a\"])\n            vel_sub = _generate_rotating_velocities(pos_sub, case[\"M_sub\"], case[\"a\"], case[\"f_v\"])\n            pos_shell = _generate_shell_positions(case[\"N_shell\"], case[\"R_shell\"], case[\"sigma_R\"])\n            vel_shell = _generate_shell_velocities(pos_shell, case[\"sigma_v\"])\n            positions = np.vstack([pos_sub, pos_shell])\n            velocities = np.vstack([vel_sub, vel_shell])\n\n        classification = _classify_structure(\n            positions, velocities, case[\"M_sub\"], case[\"a\"], case[\"tau_E\"], case[\"tau_L\"])\n        \n        results.append(classification == case[\"ground_truth\"])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "简单的瞬时能量判据 $E \\lt 0$ 隐含了一个关键假设：系统的引力势是静态的，因此能量是守恒的。然而，在星系并合等剧烈变化的动态环境中，来自外部的潮汐力会使势场随时间演化，能量不再守恒。这个高级练习将揭示瞬时判据的局限性，并引入轨道积分作为一种更精确的、评估粒子长期稳定性的方法，从而让您深入理解在真实宇宙的动态过程中定义“束缚”的复杂性。",
            "id": "3476096",
            "problem": "给定一个快速并合环境中候选子暗晕周围示踪粒子的快照。目标是量化基于比能的瞬时成员份属判据与在一个动力学时标上演化积分的成员份属判据的差异，并总结在六维（6D）相空间中不一致之处发生在哪里。在子暗暈的静止参考系中进行计算，将其内部势场处理为 Plummer 球模型，并用一个恒定的无迹潮汐张量来近似外部宿主星系的影响。\n\n从以下基本原理出发，设计并实现一个完整的程序来执行所需的计算：\n1. 牛顿第二定律：$m \\, d^2 \\boldsymbol{r} / dt^2 = \\boldsymbol{F}$，其中 $m$ 是粒子质量，$t$ 是时间，$\\boldsymbol{r}$ 是位置，$\\boldsymbol{F}$ 是总力。\n2. Plummer 模型中的引力势能：$U(r) = - G M / \\sqrt{r^2 + a^2}$，其中 $G$ 是牛顿引力常数，$M$ 是子暗晕质量，$a$ 是尺度半径，$r = \\lVert \\boldsymbol{r} \\rVert$。\n3. Plummer 模型中的加速度：$\\boldsymbol{a}_{\\mathrm{sub}}(\\boldsymbol{r}) = - G M \\boldsymbol{r} / (r^2 + a^2)^{3/2}$。\n4. 由恒定潮汐张量建模的外部潮汐加速度：$\\boldsymbol{a}_{\\mathrm{tide}}(\\boldsymbol{r}) = \\mathbf{T} \\, \\boldsymbol{r}$，其中 $\\mathbf{T}$ 是一个满足 $\\mathrm{Tr}(\\mathbf{T}) = 0$ 的对称张量。\n5. 相对于子暗晕的瞬时比能：$E = K + U = \\frac{1}{2} \\lVert \\boldsymbol{v} \\rVert^2 + U(r)$，其中 $\\boldsymbol{v}$ 是速度。\n6. 一个粒子是瞬时束缚的，当且仅当 $E < 0$。\n7. 在一个动力学时标 $t_{\\mathrm{dyn}}$ 内进行轨道积分，该时标在子暗晕尺度半径 $a$ 处定义为\n$$\nt_{\\mathrm{dyn}} = 2 \\pi \\sqrt{\\frac{a^3}{G M(<a)}}\n$$\n其中 $M(<a) = M / (2\\sqrt{2})$ 是 Plummer 模型中半径 $a$ 内的质量。积分必须使用 Velocity-Verlet 算法，时间步长 $\\Delta t = t_{\\mathrm{dyn}} / N_{\\mathrm{step}}$，其中 $N_{\\mathrm{step}} = 512$。\n8. 一个粒子是轨道积分束缚的，当且仅当它在从 $t=0$ 到 $t=t_{\\mathrm{dyn}}$ 的整个积分路径上始终保持瞬时束缚（即在每个时间步上都有 $E_t < 0$）。\n\n定义和计算以下指标：\n- $f_{\\mathrm{disc}}$：差异粒子（瞬时束缚但非轨道积分束缚）与总粒子数的比例。\n- $r_{\\mathrm{disc}}$：差异粒子初始位置半径的平均值。\n- $v_{\\mathrm{disc}}$：差异粒子初始速度大小的平均值。\n- $\\mathrm{RMS}_{6\\mathrm{D}}$：差异粒子在归一化 6D 相空间中的均方根位置。粒子位置通过除以子暗晕尺度半径 $a$ 进行归一化，速度通过除以尺度半径处的逃逸速度 $v_{\\mathrm{esc}}(a) = \\sqrt{\\sqrt{2} G M / a}$ 进行归一化。\n$$\n\\mathrm{RMS}_{6\\mathrm{D}} = \\sqrt{\\frac{1}{6 N_{\\mathrm{disc}}} \\sum_{i=1}^{N_{\\mathrm{disc}}} \\left( \\sum_{j=1}^3 \\left( \\frac{x_{ij}}{a} \\right)^2 + \\sum_{j=1}^3 \\left( \\frac{v_{ij}}{v_{\\mathrm{esc}}(a)} \\right)^2 \\right)}\n$$\n对四种不同的测试用例重复此过程。所有用例共享 $G = 4.30091\\times 10^{-6}$ kpc (km/s)$^2$/M$_\\odot$。潮汐张量为 $\\mathbf{T} = \\mathrm{diag}(-T_0, -T_0, 2T_0)$。\n\n测试用例：\n1. $M=1.0\\times10^9\\, \\mathrm{M}_\\odot$, $a=0.5\\,\\mathrm{kpc}$, $T_0=100.0\\,(\\mathrm{Gyr})^{-2}$\n   - 粒子：`[([0.4, 0.0, 0.0], [30.0, 0.0, 0.0]), ([1.2, 0.2, 0.0], [90.0, -20.0, 10.0]), ([0.1, -0.3, 0.2], [10.0, 15.0, 5.0]), ([1.5, 0.0, 0.0], [120.0, 0.0, 0.0]), ([0.8, 0.8, 0.0], [-40.0, 30.0, 0.0])]`\n2. $M=1.0\\times10^9\\, \\mathrm{M}_\\odot$, $a=0.5\\,\\mathrm{kpc}$, $T_0=2000.0\\,(\\mathrm{Gyr})^{-2}$\n   - 粒子：`[([1.0, 0.0, 0.0], [85.0, 0.0, 0.0]), ([0.9, 0.9, 0.0], [60.0, -90.0, 0.0]), ([0.2, 0.0, 0.7], [20.0, 10.0, -20.0]), ([1.5, 1.5, 0.0], [70.0, 70.0, 0.0]), ([0.4, -0.1, 0.0], [30.0, 50.0, 0.0])]`\n3. $M=5.0\\times10^8\\, \\mathrm{M}_\\odot$, $a=0.3\\,\\mathrm{kpc}$, $T_0=0.0\\,(\\mathrm{Gyr})^{-2}$\n   - 粒子：`[([0.1, 0.1, 0.0], [5.0, 5.0, 0.0]), ([0.5, 0.0, 0.0], [80.0, 0.0, 0.0]), ([0.9, 0.0, 0.0], [60.0, 60.0, 0.0]), ([1.2, 0.0, 0.0], [30.0, 90.0, 0.0]), ([0.05, 0.0, 0.0], [20.0, 0.0, 0.0]), ([2.0, 0.0, 0.0], [150.0, 0.0, 0.0])]`\n4. $M=1.0\\times10^9\\, \\mathrm{M}_\\odot$, $a=0.5\\,\\mathrm{kpc}$, $T_0=8000.0\\,(\\mathrm{Gyr})^{-2}$\n   - 粒子：`[([0.3, 0.0, 0.0], [50.0, 0.0, 0.0]), ([0.7, 0.7, 0.7], [0.0, 30.0, -10.0]), ([1.0, 0.0, 1.0], [0.0, 0.0, 80.0]), ([0.5, 1.5, 0.0], [40.0, 40.0, 0.0]), ([2.0, 0.0, 0.0], [0.0, 200.0, 0.0])]`\n\n您的输出必须是包含 16 个浮点数的单行，四舍五入到四位小数，格式为 `[f_1, r_1, v_1, rms_1, f_2, r_2, v_2, rms_2, ...]`，其中 `f_i, r_i, v_i, rms_i` 是第 $i$ 个测试用例的指标。所有内部计算必须使用一致的单位（kpc, km/s, M$_\\odot$）。$T_0$ 单位需转换为 (km/s/kpc)$^2$：$1 \\mathrm{Gyr}^{-2} = (0.9778 \\mathrm{km/s/kpc})^2$。",
            "solution": "用户提供了一个计算天体物理学领域中有效且定义明确的问题。任务是比较两种用于确定粒子是否引力束缚于子暗晕的不同判据，并量化它们之间的不一致性。该问题在科学上基于牛顿动力学，并使用了标准的模型和数值技术。所有参数、常数和评估指标都得到了清晰客观的定义。\n\n下文基于所提供的基本原理，逐步阐述解决方案。\n\n### 1. 物理和动力学框架\n\n问题设置在候选子暗晕的静止参考系中。一个位置为 $\\boldsymbol{r}$、速度为 $\\boldsymbol{v}$ 的示踪粒子的运动由牛顿第二定律决定，其中总加速度 $\\boldsymbol{a}(\\boldsymbol{r})$ 是子暗晕的内部加速度和宿主暗晕潮汐场的外部加速度之和。\n\n子暗暈的引力场被建模为质量为 $M$、尺度半径为 $a$ 的 Plummer 球模型。一个距离子暗暈中心 $r = \\lVert \\boldsymbol{r} \\rVert$ 的粒子的引力势能 $U(r)$ 为：\n$$\nU(r) = - \\frac{G M}{\\sqrt{r^2 + a^2}}\n$$\n其中 $G$ 是引力常数。相应的加速度是势的负梯度，$\\boldsymbol{a}_{\\mathrm{sub}}(\\boldsymbol{r}) = -\\nabla U(r)$，即：\n$$\n\\boldsymbol{a}_{\\mathrm{sub}}(\\boldsymbol{r}) = - \\frac{G M \\boldsymbol{r}}{(r^2 + a^2)^{3/2}}\n$$\n外部潮汐场由一个恒定的、对称的、无迹的潮汐张量 $\\mathbf{T}$ 近似，其导致的潮汐加速度为：\n$$\n\\boldsymbol{a}_{\\mathrm{tide}}(\\boldsymbol{r}) = \\mathbf{T} \\boldsymbol{r}\n$$\n对于指定的测试用例，$\\mathbf{T}$ 是对角矩阵：$\\mathbf{T} = \\mathrm{diag}(-T_0, -T_0, 2T_0)$。决定粒子运动的总加速度为：\n$$\n\\boldsymbol{a}(\\boldsymbol{r}) = \\boldsymbol{a}_{\\mathrm{sub}}(\\boldsymbol{r}) + \\boldsymbol{a}_{\\mathrm{tide}}(\\boldsymbol{r})\n$$\n\n### 2. 成员份属判据\n\n问题的核心是比较两种成员份属判据。\n\n**瞬时成员份属：** 如果一个粒子相对于子暗晕的比能为负，则认为它是瞬时束缚的。比能 $E$ 是比动能 $K$ 和势能 $U$ 的和：\n$$\nE = K + U = \\frac{1}{2} \\lVert \\boldsymbol{v} \\rVert^2 - \\frac{G M}{\\sqrt{\\lVert \\boldsymbol{r} \\rVert^2 + a^2}}\n$$\n因此，如果 $E < 0$，则粒子是瞬时束缚的。该判据只考虑粒子在单个时间瞬间的状态。\n\n**轨道积分成员份属：** 这是一个更严格的判据。如果一个粒子在一个特征时标内保持束缚，则认为它是束缚的。问题将此时标定义为一个动力学时标 $t_{\\mathrm{dyn}}$，在子暗晕的尺度半径 $a$ 处计算：\n$$\nt_{\\mathrm{dyn}} = 2 \\pi \\sqrt{\\frac{a^3}{G M(<a)}}\n$$\n其中 $M(<a)$ 是 Plummer 模型在半径 $a$ 内包含的质量。对于 Plummer 球，$M(r < a) = M / (2\\sqrt{2})$。粒子的轨道通过数值积分其在总加速度场 $\\boldsymbol{a}(\\boldsymbol{r})$ 中的运动来计算。使用时间步长为 $\\Delta t = t_{\\mathrm{dyn}} / N_{\\mathrm{step}}$ 的 Velocity-Verlet 算法。在积分过程中的每个时间步，都会计算粒子的瞬时比能 $E_t$。如果对于所有 $t \\in [0, t_{\\mathrm{dyn}}]$ 都有 $E_t < 0$，则该粒子被分类为轨道积分束缚。\n\n### 3. 指标计算\n\n对于每个测试用例，将分析粒子集以找到“差异”粒子，即那些瞬时束缚但非轨道积分束缚的粒子。然后计算四个指标：\n\n-   **$f_{\\mathrm{disc}}$**：差异粒子数与总粒子数之比。\n-   **$r_{\\mathrm{disc}}$**：差异粒子在 $t=0$ 时的平均径向距离。\n-   **$v_{\\mathrm{disc}}$**：差异粒子在 $t=0$ 时的平均速度大小。\n-   **$\\mathrm{RMS}_{6\\mathrm{D}}$**：差异粒子在归一化相空间中的均方根位置。这个指标衡量了差异粒子在子暗晕的特征尺度下的相空间体积中的分布情况。\n\n### 4. 数值实现\n\n解决方案将对每个测试用例执行以下步骤：\n\n1.  **设置参数：** 从用例中读取 $M, a, T_0$ 和粒子初始条件。将 $T_0$ 的单位从 $(\\mathrm{Gyr})^{-2}$ 转换为 $(\\mathrm{km/s/kpc})^2$，使用转换因子 $(0.9778)^2$。\n2.  **计算常数：** 计算 $t_{\\mathrm{dyn}}$, $\\Delta t$ 和 $v_{\\mathrm{esc}}(a)$。\n3.  **遍历粒子：** 对每个粒子：\n    a.  计算其初始能量 $E_0$。如果 $E_0 \\ge 0$，则它不是瞬时束缚的，可以忽略。\n    b.  如果 $E_0 < 0$，则使用 Velocity-Verlet 算法积分其轨道，总时长为 $t_{\\mathrm{dyn}}$。\n    c.  在每个积分步骤后，计算瞬时能量 $E_t$。如果任何时候 $E_t \\ge 0$，则停止积分，并将该粒子标记为差异粒子。\n    d.  如果粒子在整个积分过程中都保持 $E_t < 0$，则它同时是瞬时束缚和轨道积分束缚的，不是差异粒子。\n4.  **计算指标：** 在识别出所有差异粒子后，计算 $f_{\\mathrm{disc}}, r_{\\mathrm{disc}}, v_{\\mathrm{disc}}$ 和 $\\mathrm{RMS}_{6\\mathrm{D}}$。如果不存在差异粒子，则所有指标均为 0。\n5.  **汇总结果：** 将所有测试用例的 16 个结果（4 个用例 $\\times$ 4 个指标）收集到一个列表中，并按要求格式化输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing instantaneous vs. orbit-integrated subhalo membership.\n    \"\"\"\n    G = 4.30091e-6  # kpc (km/s)^2 / M_sun\n    N_STEP = 512\n    GYR_TO_KM_S_KPC = 0.9778\n    T_CONV_FACTOR = GYR_TO_KM_S_KPC**2\n\n    test_cases_data = [\n        {\n            \"M\": 1.0e9, \"a\": 0.5, \"T0\": 100.0,\n            \"particles\": [\n                (np.array([0.4, 0.0, 0.0]), np.array([30.0, 0.0, 0.0])),\n                (np.array([1.2, 0.2, 0.0]), np.array([90.0, -20.0, 10.0])),\n                (np.array([0.1, -0.3, 0.2]), np.array([10.0, 15.0, 5.0])),\n                (np.array([1.5, 0.0, 0.0]), np.array([120.0, 0.0, 0.0])),\n                (np.array([0.8, 0.8, 0.0]), np.array([-40.0, 30.0, 0.0])),\n            ]\n        },\n        {\n            \"M\": 1.0e9, \"a\": 0.5, \"T0\": 2000.0,\n            \"particles\": [\n                (np.array([1.0, 0.0, 0.0]), np.array([85.0, 0.0, 0.0])),\n                (np.array([0.9, 0.9, 0.0]), np.array([60.0, -90.0, 0.0])),\n                (np.array([0.2, 0.0, 0.7]), np.array([20.0, 10.0, -20.0])),\n                (np.array([1.5, 1.5, 0.0]), np.array([70.0, 70.0, 0.0])),\n                (np.array([0.4, -0.1, 0.0]), np.array([30.0, 50.0, 0.0])),\n            ]\n        },\n        {\n            \"M\": 5.0e8, \"a\": 0.3, \"T0\": 0.0,\n            \"particles\": [\n                (np.array([0.1, 0.1, 0.0]), np.array([5.0, 5.0, 0.0])),\n                (np.array([0.5, 0.0, 0.0]), np.array([80.0, 0.0, 0.0])),\n                (np.array([0.9, 0.0, 0.0]), np.array([60.0, 60.0, 0.0])),\n                (np.array([1.2, 0.0, 0.0]), np.array([30.0, 90.0, 0.0])),\n                (np.array([0.05, 0.0, 0.0]), np.array([20.0, 0.0, 0.0])),\n                (np.array([2.0, 0.0, 0.0]), np.array([150.0, 0.0, 0.0])),\n            ]\n        },\n        {\n            \"M\": 1.0e9, \"a\": 0.5, \"T0\": 8000.0,\n            \"particles\": [\n                (np.array([0.3, 0.0, 0.0]), np.array([50.0, 0.0, 0.0])),\n                (np.array([0.7, 0.7, 0.7]), np.array([0.0, 30.0, -10.0])),\n                (np.array([1.0, 0.0, 1.0]), np.array([0.0, 0.0, 80.0])),\n                (np.array([0.5, 1.5, 0.0]), np.array([40.0, 40.0, 0.0])),\n                (np.array([2.0, 0.0, 0.0]), np.array([0.0, 200.0, 0.0])),\n            ]\n        }\n    ]\n\n    def specific_energy(pos, vel, M, a):\n        r_norm = np.linalg.norm(pos)\n        v_norm = np.linalg.norm(vel)\n        potential_energy = -G * M / np.sqrt(r_norm**2 + a**2)\n        kinetic_energy = 0.5 * v_norm**2\n        return kinetic_energy + potential_energy\n\n    def total_acceleration(pos, M, a, T_diag_conv):\n        r_norm = np.linalg.norm(pos)\n        r_sq = r_norm**2\n        denom = (r_sq + a**2)**1.5\n        acc_sub = -G * M * pos / denom\n        acc_tide = T_diag_conv * pos\n        return acc_sub + acc_tide\n\n    results = []\n    for case in test_cases_data:\n        M, a, T0 = case[\"M\"], case[\"a\"], case[\"T0\"]\n        particles = case[\"particles\"]\n        T_diag_conv = np.array([-T0, -T0, 2 * T0]) * T_CONV_FACTOR\n\n        M_lt_a = M / (2 * np.sqrt(2))\n        t_dyn = 2 * np.pi * np.sqrt(a**3 / (G * M_lt_a))\n        dt = t_dyn / N_STEP\n        v_esc_a = np.sqrt(np.sqrt(2) * G * M / a)\n\n        discrepant_particles = []\n\n        for pos0, vel0 in particles:\n            E0 = specific_energy(pos0, vel0, M, a)\n            is_inst_bound = E0 < 0\n            \n            if not is_inst_bound:\n                continue\n\n            is_orbit_bound = True\n            \n            pos = np.copy(pos0)\n            vel = np.copy(vel0)\n            acc = total_acceleration(pos, M, a, T_diag_conv)\n\n            for _ in range(N_STEP):\n                pos = pos + vel * dt + 0.5 * acc * dt**2\n                acc_new = total_acceleration(pos, M, a, T_diag_conv)\n                vel = vel + 0.5 * (acc + acc_new) * dt\n                acc = acc_new\n\n                E_t = specific_energy(pos, vel, M, a)\n                if E_t >= 0:\n                    is_orbit_bound = False\n                    break\n            \n            if is_inst_bound and not is_orbit_bound:\n                discrepant_particles.append((pos0, vel0))\n        \n        n_total = len(particles)\n        n_disc = len(discrepant_particles)\n\n        if n_disc == 0:\n            f_disc, r_disc_mean, v_disc_mean, rms_6d = 0.0, 0.0, 0.0, 0.0\n        else:\n            f_disc = n_disc / n_total\n\n            initial_radii = [np.linalg.norm(p[0]) for p in discrepant_particles]\n            initial_speeds = [np.linalg.norm(p[1]) for p in discrepant_particles]\n\n            r_disc_mean = np.mean(initial_radii)\n            v_disc_mean = np.mean(initial_speeds)\n\n            sum_sq_std_coords = 0.0\n            for p_pos, p_vel in discrepant_particles:\n                std_pos = p_pos / a\n                std_vel = p_vel / v_esc_a\n                sum_sq_std_coords += np.sum(std_pos**2) + np.sum(std_vel**2)\n            \n            rms_6d = np.sqrt(sum_sq_std_coords / (6 * n_disc))\n\n        results.extend([f_disc, r_disc_mean, v_disc_mean, rms_6d])\n    \n    formatted_results = [f\"{x:.4f}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}