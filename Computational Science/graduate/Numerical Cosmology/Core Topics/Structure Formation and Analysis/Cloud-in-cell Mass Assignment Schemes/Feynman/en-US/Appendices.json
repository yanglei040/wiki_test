{
    "hands_on_practices": [
        {
            "introduction": "This exercise establishes the foundational properties of the Cloud-in-Cell (CIC) scheme in Fourier space. By deriving the one-dimensional window function, $W_{1\\mathrm{D}}(k)$, and its low-$k$ expansion, you will quantify the intrinsic smoothing effect of CIC. This analytical practice is crucial for understanding how the scheme impacts large-scale cosmological modes and provides a concrete definition for its effective smoothing length, $R_{\\mathrm{eff}}$ .",
            "id": "3466986",
            "problem": "In particle-mesh methods for cosmological $N$-body simulations, the Cloud-In-Cell (CIC) mass assignment scheme distributes each particle’s mass linearly among the two nearest grid points in one spatial dimension. Let the grid spacing be $\\Delta$ and define the one-dimensional normalized real-space assignment kernel for Cloud-In-Cell (CIC) as\n$$\nK_{\\mathrm{CIC}}(x) \\equiv \n\\begin{cases}\n\\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right),  |x| \\le \\Delta, \\\\\n0,  |x| > \\Delta,\n\\end{cases}\n$$\nwhich satisfies $\\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\mathrm{d}x = 1$. Consider a continuous density field $\\rho(x)$ and its grid-assigned counterpart obtained by convolution\n$$\n\\rho_{\\mathrm{grid}}(x) = \\int_{-\\infty}^{\\infty} \\rho(x')\\,K_{\\mathrm{CIC}}(x-x')\\,\\mathrm{d}x'.\n$$\nIn Fourier space, the assignment multiplies the true field transform by a window function $W_{1\\mathrm{D}}(k)$ defined by the Fourier transform\n$$\nW_{1\\mathrm{D}}(k) \\equiv \\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\exp(-\\mathrm{i} k x)\\,\\mathrm{d}x.\n$$\n\nStarting from the above definitions and without invoking any pre-tabulated Fourier pairs or specialized mass-assignment formulas, derive $W_{1\\mathrm{D}}(k)$ and obtain its small-$k$ expansion up to and including the $k^2$ term. Then, define the leading effective smoothing length $R_{\\mathrm{eff}}$ as the unique positive quantity such that\n$$\nW_{1\\mathrm{D}}(k) = 1 - \\frac{(k R_{\\mathrm{eff}})^2}{2} + \\mathcal{O}(k^4) \\quad\\text{for } k \\to 0,\n$$\nand express $R_{\\mathrm{eff}}$ in terms of $\\Delta$ only. Your final answer must be a single closed-form analytic expression for $R_{\\mathrm{eff}}$ in terms of $\\Delta$. Do not include any units in your final answer and do not report the series remainder symbol $\\mathcal{O}(k^4)$ in the final answer.",
            "solution": "The problem statement is critically evaluated according to the specified validation procedure.\n\n### Step 1: Extract Givens\n- The one-dimensional normalized real-space assignment kernel for Cloud-In-Cell (CIC) is given by:\n$$\nK_{\\mathrm{CIC}}(x) \\equiv \n\\begin{cases}\n\\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right),  |x| \\le \\Delta, \\\\\n0,  |x| > \\Delta,\n\\end{cases}\n$$\n- The kernel is normalized such that $\\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\mathrm{d}x = 1$.\n- The grid-assigned density field is related to the continuous field by convolution: $\\rho_{\\mathrm{grid}}(x) = \\int_{-\\infty}^{\\infty} \\rho(x')\\,K_{\\mathrm{CIC}}(x-x')\\,\\mathrm{d}x'$.\n- The Fourier space window function $W_{1\\mathrm{D}}(k)$ is the Fourier transform of the kernel:\n$$\nW_{1\\mathrm{D}}(k) \\equiv \\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\exp(-\\mathrm{i} k x)\\,\\mathrm{d}x.\n$$\n- The small-$k$ behavior of $W_{1\\mathrm{D}}(k)$ defines the effective smoothing length $R_{\\mathrm{eff}}$:\n$$\nW_{1\\mathrm{D}}(k) = 1 - \\frac{(k R_{\\mathrm{eff}})^2}{2} + \\mathcal{O}(k^4) \\quad\\text{for } k \\to 0,\n$$\nwhere $R_{\\mathrm{eff}}$ is a unique positive quantity.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed for validity:\n- **Scientifically Grounded**: The problem is based on standard, well-established concepts and methods in computational cosmology, specifically the particle-mesh N-body simulation technique. The CIC assignment scheme and its Fourier representation are fundamental components of this field.\n- **Well-Posed**: The problem is clearly stated with all necessary definitions and constraints. The objective is a specific derivation and the calculation of a well-defined quantity, for which a unique solution exists.\n- **Objective**: The language is precise, formal, and free of any subjective or ambiguous terminology.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a standard mathematical physics derivation within a specified context. The solution will be provided as requested.\n\nThe first step is to derive the analytical form of the window function $W_{1\\mathrm{D}}(k)$ by computing the Fourier transform of the kernel $K_{\\mathrm{CIC}}(x)$.\nStarting from the definition:\n$$\nW_{1\\mathrm{D}}(k) = \\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\exp(-\\mathrm{i} k x)\\,\\mathrm{d}x.\n$$\nWe substitute the piecewise definition of $K_{\\mathrm{CIC}}(x)$. The kernel is non-zero only for $|x| \\le \\Delta$, so the integration limits become $[-\\Delta, \\Delta]$:\n$$\nW_{1\\mathrm{D}}(k) = \\int_{-\\Delta}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)\\,\\exp(-\\mathrm{i} k x)\\,\\mathrm{d}x.\n$$\nUsing Euler's formula, $\\exp(-\\mathrm{i} k x) = \\cos(kx) - \\mathrm{i}\\sin(kx)$, we can split the integral:\n$$\nW_{1\\mathrm{D}}(k) = \\int_{-\\Delta}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)\\,\\cos(k x)\\,\\mathrm{d}x - \\mathrm{i} \\int_{-\\Delta}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)\\,\\sin(k x)\\,\\mathrm{d}x.\n$$\nThe function $\\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)$ is an even function of $x$. The function $\\sin(kx)$ is an odd function of $x$. The product of an even and an odd function is odd. The integral of an odd function over a symmetric interval $[-\\Delta, \\Delta]$ is zero. Therefore, the imaginary part of the integral vanishes.\nThe remaining integrand is the product of two even functions, which is even. We can simplify the real part of the integral:\n$$\nW_{1\\mathrm{D}}(k) = 2 \\int_{0}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)\\,\\cos(k x)\\,\\mathrm{d}x.\n$$\nFor $x \\ge 0$, $|x| = x$, so the expression becomes:\n$$\nW_{1\\mathrm{D}}(k) = \\frac{2}{\\Delta} \\int_{0}^{\\Delta} \\left(1 - \\frac{x}{\\Delta}\\right)\\,\\cos(k x)\\,\\mathrm{d}x.\n$$\nThis integral can be solved using integration by parts, $\\int u\\,\\mathrm{d}v = uv - \\int v\\,\\mathrm{d}u$. Let $u = 1 - \\frac{x}{\\Delta}$ and $\\mathrm{d}v = \\cos(kx)\\,\\mathrm{d}x$. This implies $\\mathrm{d}u = -\\frac{1}{\\Delta}\\,\\mathrm{d}x$ and $v = \\frac{1}{k}\\sin(kx)$.\n$$\n\\int_{0}^{\\Delta} \\left(1 - \\frac{x}{\\Delta}\\right)\\,\\cos(k x)\\,\\mathrm{d}x = \\left[\\left(1 - \\frac{x}{\\Delta}\\right)\\frac{\\sin(kx)}{k}\\right]_{0}^{\\Delta} - \\int_{0}^{\\Delta} \\frac{\\sin(kx)}{k} \\left(-\\frac{1}{\\Delta}\\right)\\,\\mathrm{d}x.\n$$\nThe first term evaluates to zero at both limits: at $x=\\Delta$, the factor $(1 - \\frac{\\Delta}{\\Delta}) = 0$, and at $x=0$, the factor $\\sin(0) = 0$.\nThe expression simplifies to:\n$$\n\\frac{1}{k\\Delta} \\int_{0}^{\\Delta} \\sin(kx)\\,\\mathrm{d}x = \\frac{1}{k\\Delta} \\left[-\\frac{\\cos(kx)}{k}\\right]_{0}^{\\Delta} = \\frac{1}{k^2\\Delta} \\left(-\\cos(k\\Delta) - (-\\cos(0))\\right) = \\frac{1 - \\cos(k\\Delta)}{k^2\\Delta}.\n$$\nSubstituting this back into the expression for $W_{1\\mathrm{D}}(k)$:\n$$\nW_{1\\mathrm{D}}(k) = \\frac{2}{\\Delta} \\left(\\frac{1 - \\cos(k\\Delta)}{k^2\\Delta}\\right) = \\frac{2(1 - \\cos(k\\Delta))}{(k\\Delta)^2}.\n$$\nNext, we find the small-$k$ expansion of $W_{1\\mathrm{D}}(k)$. We use the Taylor series for the cosine function around $0$:\n$$\n\\cos(y) = 1 - \\frac{y^2}{2!} + \\frac{y^4}{4!} - \\mathcal{O}(y^6).\n$$\nLet $y = k\\Delta$. Then for small $k$, $y$ is small.\n$$\n1 - \\cos(k\\Delta) = 1 - \\left(1 - \\frac{(k\\Delta)^2}{2} + \\frac{(k\\Delta)^4}{24} - \\dots\\right) = \\frac{(k\\Delta)^2}{2} - \\frac{(k\\Delta)^4}{24} + \\mathcal{O}(k^6).\n$$\nSubstituting this into the expression for $W_{1\\mathrm{D}}(k)$:\n$$\nW_{1\\mathrm{D}}(k) = \\frac{2}{(k\\Delta)^2} \\left[ \\frac{(k\\Delta)^2}{2} - \\frac{(k\\Delta)^4}{24} + \\mathcal{O}(k^6) \\right].\n$$\nDistributing the pre-factor gives the expansion up to the $k^2$ term:\n$$\nW_{1\\mathrm{D}}(k) = 1 - \\frac{2(k\\Delta)^4}{24(k\\Delta)^2} + \\mathcal{O}(k^4) = 1 - \\frac{(k\\Delta)^2}{12} + \\mathcal{O}(k^4).\n$$\nFinally, we compare this derived expansion with the form given in the problem statement, which defines the effective smoothing length $R_{\\mathrm{eff}}$:\n$$\nW_{1\\mathrm{D}}(k) = 1 - \\frac{(k R_{\\mathrm{eff}})^2}{2} + \\mathcal{O}(k^4).\n$$\nBy equating the coefficients of the $k^2$ term from both expressions, we have:\n$$\n\\frac{(k R_{\\mathrm{eff}})^2}{2} = \\frac{(k\\Delta)^2}{12}.\n$$\n$$\n\\frac{k^2 R_{\\mathrm{eff}}^2}{2} = \\frac{k^2 \\Delta^2}{12}.\n$$\nFor $k \\neq 0$, we can divide by $k^2$:\n$$\nR_{\\mathrm{eff}}^2 = \\frac{2\\Delta^2}{12} = \\frac{\\Delta^2}{6}.\n$$\nThe problem states that $R_{\\mathrm{eff}}$ is a positive quantity. Taking the positive square root of both sides gives the desired expression for $R_{\\mathrm{eff}}$:\n$$\nR_{\\mathrm{eff}} = \\sqrt{\\frac{\\Delta^2}{6}} = \\frac{\\Delta}{\\sqrt{6}}.\n$$\nThis is the closed-form analytic expression for the effective smoothing length in terms of the grid spacing $\\Delta$.",
            "answer": "$$\\boxed{\\frac{\\Delta}{\\sqrt{6}}}$$"
        },
        {
            "introduction": "Moving from analytical theory to numerical simulation, this practice confronts one of the key artifacts of any grid-based assignment: the loss of continuous translational invariance. You will implement a Particle-Mesh (PM) pipeline to measure the spurious self-force a particle experiences due to its interaction with the grid, an artifact known as the \"eggbox\" effect. This experiment directly reveals the grid-induced force anisotropy that is fundamental to understanding the limitations of PM methods at small scales .",
            "id": "3466963",
            "problem": "You are tasked with designing and implementing a numerical experiment to isolate and quantify spurious anisotropic forces introduced by the Cloud-in-Cell (CIC) mass assignment scheme in a Particle-Mesh (PM) gravitational solver. The investigation focuses on the so-called “eggbox” imprint: grid-induced anisotropy that appears even when evolving an otherwise uniform configuration. You must build the algorithm from first principles and produce a complete, runnable program that computes the spurious force experienced by a single particle due to its own Cloud-in-Cell deposition on a periodic mesh, and then measures how the resulting speed increment scales with grid spacing and integration timestep. All quantities are dimensionless; do not include any physical units in the output.\n\nBegin from the following context-appropriate foundations.\n\n- The Particle-Mesh (PM) method approximates the solution to the gravitational potential by depositing particle mass onto a regular mesh, solving the Poisson equation for the potential on that mesh, computing the force field as the negative gradient of the potential on the mesh, and interpolating the force back to particle positions.\n- The gravitational potential obeys the Poisson equation in a periodic box,\n  $$\\nabla^2 \\Phi(\\mathbf{x}) = 4\\pi G\\left[\\rho(\\mathbf{x}) - \\bar{\\rho}\\right],$$\n  where $G$ is the gravitational constant, $\\rho(\\mathbf{x})$ is the mass density, and $\\bar{\\rho}$ is its spatial mean. In a periodic domain, the Fourier transform of the Laplacian is diagonal, and the mean component at $\\mathbf{k}=\\mathbf{0}$ must be set to zero to avoid divergence.\n- The Cloud-in-Cell (CIC) mass assignment in $d=2$ dimensions uses a separable triangular kernel. For a particle at position $(x,y)$ with grid spacing $\\Delta$, let $g_x = x/\\Delta$ and $g_y = y/\\Delta$, $i_0 = \\lfloor g_x \\rfloor$, $j_0 = \\lfloor g_y \\rfloor$, $f_x = g_x - i_0$, and $f_y = g_y - j_0$. Then the four surrounding mesh nodes $(i_0,j_0)$, $(i_0+1,j_0)$, $(i_0,j_0+1)$, and $(i_0+1,j_0+1)$ receive mass fractions with weights\n  $$w_{x,0} = 1 - f_x,\\quad w_{x,1} = f_x,\\quad w_{y,0} = 1 - f_y,\\quad w_{y,1} = f_y,$$\n  and the mass per cell area is obtained by dividing by $\\Delta^2$. The same weights are used to interpolate the mesh force back to the particle position. Define the box size as $L$ and the number of mesh cells per dimension as $N$, so that $\\Delta = L/N$.\n- The Poisson equation is solved in Fourier space. Let $\\tilde{\\rho}(\\mathbf{k})$ be the discrete Fourier transform of the density. Use the discrete effective wave number associated with the second-order finite-difference Laplacian,\n  $$k_{\\mathrm{eff}}^2(\\mathbf{k}) = \\left(\\frac{2}{\\Delta}\\right)^2\\left[\\sin^2\\left(\\frac{k_x \\Delta}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta}{2}\\right)\\right],$$\n  where the discrete wave numbers are $k_x = 2\\pi n_x / L$ and $k_y = 2\\pi n_y / L$ for integers $n_x, n_y \\in \\{0,1,\\dots,N-1\\}$ with periodic ordering. The potential in Fourier space is\n  $$\\tilde{\\Phi}(\\mathbf{k}) = -\\frac{4\\pi G\\, \\tilde{\\rho}(\\mathbf{k})}{k_{\\mathrm{eff}}^2(\\mathbf{k})},$$\n  with $\\tilde{\\Phi}(\\mathbf{0}) = 0$. Transform back to real space to obtain $\\Phi(\\mathbf{x})$.\n- The mesh force is computed by second-order central finite differences,\n  $$F_x(i,j) = -\\frac{\\Phi(i+1,j) - \\Phi(i-1,j)}{2\\Delta},\\qquad F_y(i,j) = -\\frac{\\Phi(i,j+1) - \\Phi(i,j-1)}{2\\Delta},$$\n  with periodic indexing. The particle feels the interpolated force\n  $$\\mathbf{F}_p = \\sum_{a\\in\\{0,1\\}}\\sum_{b\\in\\{0,1\\}} \\left[w_{x,a} w_{y,b}\\right]\\, \\mathbf{F}(i_0+a, j_0+b).$$\n- The velocity update (“kick”) is computed over one timestep by\n  $$\\Delta \\mathbf{v} = \\mathbf{F}_p\\, \\Delta t,$$\n  starting from zero initial velocity.\n\nYou must implement the above pipeline for a single particle in a $2$-D periodic square of side $L = 1$, with particle mass $m = 1$ and gravitational constant $G = 1$. The density must be mean-subtracted, i.e., use $\\rho(\\mathbf{x}) - \\bar{\\rho}$ when solving the Poisson equation. Use the discrete effective wave number $k_{\\mathrm{eff}}^2(\\mathbf{k})$ defined above and compute the gradient in real space by finite differences. The force interpolation must use CIC weights identical to the mass assignment. The particle is placed near the box center at $(x,y) = (L/2 + \\delta_x, L/2 + \\delta_y)$, where $(\\delta_x, \\delta_y)$ are specified offsets within one cell.\n\nTask: For each test case, compute the magnitude of the spurious force $||\\mathbf{F}_p||$ and the resulting speed increment $||\\Delta \\mathbf{v}||$ after a single kick. Report these two floats per test case to expose anisotropy and scaling. The anisotropy (“eggbox” imprint) is revealed by comparing $||\\mathbf{F}_p||$ for axis-aligned versus diagonal sub-cell offsets. The scaling with grid spacing $\\Delta$ is revealed by comparing results across different $N$, and the scaling with timestep $\\Delta t$ is revealed by comparing results across different $\\Delta t$.\n\nTest Suite:\n- Case $1$: $N=32$, $\\Delta t = 0.01$, axis offset $(\\delta_x,\\delta_y) = (\\Delta/4, 0)$.\n- Case $2$: $N=32$, $\\Delta t = 0.01$, diagonal offset $(\\delta_x,\\delta_y) = (\\Delta/4, \\Delta/4)$.\n- Case $3$: $N=16$, $\\Delta t = 0.01$, diagonal offset $(\\delta_x,\\delta_y) = (\\Delta/4, \\Delta/4)$.\n- Case $4$: $N=32$, $\\Delta t = 0.005$, diagonal offset $(\\delta_x,\\delta_y) = (\\Delta/4, \\Delta/4)$.\n- Case $5$: $N=32$, $\\Delta t = 0.01$, cell-center offset $(\\delta_x,\\delta_y) = (0, 0)$.\n\nFor each test case $i$, compute $s_i = \\left\\lVert \\mathbf{F}_p \\right\\rVert$ and $u_i = \\left\\lVert \\Delta \\mathbf{v} \\right\\rVert$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$$[s_1,u_1,s_2,u_2,s_3,u_3,s_4,u_4,s_5,u_5].$$\n\nAll computations and outputs are dimensionless real numbers. Angles do not appear. Express all final outputs as floating-point numbers. No percentages appear anywhere. The program must be self-contained and require no external input.",
            "solution": "The user-provided problem has been validated and found to be scientifically sound, well-posed, and self-contained. The task is to implement a numerical experiment to measure the spurious, grid-induced anisotropic forces generated by the Cloud-in-Cell (CIC) mass assignment scheme in a $2$-dimensional Particle-Mesh (PM) gravitational simulation. The algorithm will be constructed from first principles as specified.\n\nThe core of the PM method involves four steps:\n1.  Assigning mass from particles to a discrete mesh to define a density field $\\rho$.\n2.  Solving the Poisson equation $\\nabla^2 \\Phi = 4\\pi G (\\rho - \\bar{\\rho})$ on the mesh to find the gravitational potential $\\Phi$.\n3.  Computing the force field $\\mathbf{F}$ on the mesh as the negative gradient of the potential, $\\mathbf{F} = -\\nabla \\Phi$.\n4.  Interpolating the force from the mesh back to the particle positions to update their velocities.\n\nThis procedure will be implemented for a single particle of mass $m=1$ in a periodic square box of side length $L=1$, with the gravitational constant $G=1$. The goal is to compute the magnitude of the spurious self-force $||\\mathbf{F}_p||$ and the resulting speed increment $||\\Delta\\mathbf{v}||$ for several configurations.\n\nThe procedural steps are as follows:\n\n1.  **System Discretization and Particle Placement**\n    The simulation domain is a periodic square of size $L \\times L$ with $L=1$. This domain is discretized into a uniform grid of $N \\times N$ cells, resulting in a grid spacing of $\\Delta = L/N$. For each test case, specified by $N$, a time step $\\Delta t$, and a sub-cell offset $(\\delta_x, \\delta_y)$, a single particle of mass $m=1$ is placed at position $\\mathbf{p} = (x,y) = (L/2 + \\delta_x, L/2 + \\delta_y)$.\n\n2.  **Mass Assignment: Cloud-in-Cell (CIC)**\n    The particle's mass $m$ is distributed onto the $N \\times N$ grid to create a mass density field $\\rho_{ij}$. The CIC scheme distributes the mass to the four nearest grid nodes. Let the particle's position be $(x,y)$. Its continuous grid coordinates are $(g_x, g_y) = (x/\\Delta, y/\\Delta)$. The integer part of these coordinates identifies the lower-left corner of the cell containing the particle: $(i_0, j_0) = (\\lfloor g_x \\rfloor, \\lfloor g_y \\rfloor)$. The fractional parts, $(f_x, f_y) = (g_x - i_0, g_y - j_0)$, determine the weights for bilinear interpolation. The weights are $w_{x,0} = 1 - f_x$, $w_{x,1} = f_x$, $w_{y,0} = 1 - f_y$, and $w_{y,1} = f_y$. The mass $m$ is assigned to the four surrounding nodes $(i_0+a, j_0+b)$ for $a,b \\in \\{0, 1\\}$ according to the product of weights $w_{x,a}w_{y,b}$. The grid density at node $(i,j)$ is this assigned mass divided by the cell area $\\Delta^2$. Taking into account periodic boundary conditions, the density at node $(i,j)=( (i_0+a)\\%N, (j_0+b)\\%N )$ is incremented by $m \\cdot w_{x,a} w_{y,b} / \\Delta^2$.\n\n3.  **Solving the Poisson Equation in Fourier Space**\n    The Poisson equation, $\\nabla^2 \\Phi(\\mathbf{x}) = 4\\pi G\\left[\\rho(\\mathbf{x}) - \\bar{\\rho}\\right]$, is most efficiently solved in Fourier space where the Laplacian operator $\\nabla^2$ becomes a simple multiplication.\n    First, the real-space density grid $\\rho_{ij}$ is transformed into Fourier space using the 2D Discrete Fourier Transform (DFT), yielding $\\tilde{\\rho}(\\mathbf{k})$. The term $\\rho(\\mathbf{x}) - \\bar{\\rho}$ is handled by setting the $\\mathbf{k}=\\mathbf{0}$ (DC) component of the potential to zero, i.e., $\\tilde{\\Phi}(\\mathbf{0}) = 0$.\n    The discrete wave vectors are $\\mathbf{k} = (k_x, k_y)$, with components $k_x = 2\\pi n_x/L$ and $k_y = 2\\pi n_y/L$ for integers $n_x, n_y$. The problem specifies using a second-order finite-difference approximation for the Laplacian, whose Fourier representation is the effective squared wave number:\n    $$k_{\\mathrm{eff}}^2(\\mathbf{k}) = \\left(\\frac{2}{\\Delta}\\right)^2\\left[\\sin^2\\left(\\frac{k_x \\Delta}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta}{2}\\right)\\right]$$\n    The potential in Fourier space is then calculated as:\n    $$\\tilde{\\Phi}(\\mathbf{k}) = -\\frac{4\\pi G\\, \\tilde{\\rho}(\\mathbf{k})}{k_{\\mathrm{eff}}^2(\\mathbf{k})}$$\n    This is computed for all $\\mathbf{k} \\neq \\mathbf{0}$. For $\\mathbf{k} = \\mathbf{0}$, we set $\\tilde{\\Phi}(\\mathbf{0}) = 0$. Finally, the real-space potential $\\Phi_{ij}$ is recovered by applying the inverse 2D DFT to $\\tilde{\\Phi}(\\mathbf{k})$.\n\n4.  **Force Calculation on the Grid**\n    The gravitational force field on the grid, $\\mathbf{F}_{ij} = (F_{x,ij}, F_{y,ij})$, is computed as the negative gradient of the potential, $\\mathbf{F} = -\\nabla\\Phi$. This is approximated using a second-order central finite difference scheme on the potential grid $\\Phi_{ij}$:\n    $$F_x(i,j) = -\\frac{\\Phi(i+1,j) - \\Phi(i-1,j)}{2\\Delta}$$\n    $$F_y(i,j) = -\\frac{\\Phi(i,j+1) - \\Phi(i,j-1)}{2\\Delta}$$\n    Periodic boundary conditions are applied to the indices $(i,j)$.\n\n5.  **Force Interpolation and Velocity Update**\n    The force at the particle's exact position $\\mathbf{p}$ is interpolated from the grid forces at the four surrounding nodes, using the same CIC weights derived in the mass assignment step:\n    $$\\mathbf{F}_p = \\sum_{a\\in\\{0,1\\}}\\sum_{b\\in\\{0,1\\}} \\left[w_{x,a} w_{y,b}\\right]\\, \\mathbf{F}((i_0+a)\\%N, (j_0+b)\\%N)$$\n    In an ideal, perfectly isotropic system, a single particle in an empty box should experience zero self-force. Any non-zero force $\\mathbf{F}_p$ is a numerical artifact. We quantify this spurious force by its magnitude, $s = ||\\mathbf{F}_p|| = \\sqrt{F_{p,x}^2 + F_{p,y}^2}$.\n    The velocity of the particle, starting from rest, is updated with a single \"kick\" over a timestep $\\Delta t$:\n    $$\\Delta \\mathbf{v} = \\mathbf{F}_p\\, \\Delta t$$\n    The magnitude of this velocity increment is $u = ||\\Delta \\mathbf{v}|| = ||\\mathbf{F}_p|| \\Delta t = s \\cdot \\Delta t$.\n\nFor each test case, we compute and report the pair of values $(s, u)$. The case with zero offset $(\\delta_x, \\delta_y) = (0,0)$ places the particle exactly on a grid node, which by symmetry must result in zero net force, serving as a critical sanity check for the implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment for all test cases.\n    \"\"\"\n\n    def compute_spurious_force(N, dt, delta_offset):\n        \"\"\"\n        Computes the spurious force and speed increment for a single particle.\n\n        Args:\n            N (int): Number of grid cells per dimension.\n            dt (float): Timestep for the velocity kick.\n            delta_offset (tuple): Particle offset (delta_x, delta_y) from the box center.\n\n        Returns:\n            tuple: A tuple containing the force magnitude (s) and speed increment (u).\n        \"\"\"\n        # 1. System Definition and Discretization\n        L = 1.0\n        G = 1.0\n        m = 1.0\n        delta = L / N\n        \n        delta_x, delta_y = delta_offset\n        \n        # Particle position\n        x = L / 2.0 + delta_x\n        y = L / 2.0 + delta_y\n\n        # 2. Mass Assignment (CIC)\n        rho_grid = np.zeros((N, N), dtype=np.float64)\n        \n        g_x = x / delta\n        g_y = y / delta\n        \n        i_0 = int(g_x)\n        j_0 = int(g_y)\n        \n        f_x = g_x - i_0\n        f_y = g_y - j_0\n        \n        weights_x = [1.0 - f_x, f_x]\n        weights_y = [1.0 - f_y, f_y]\n        \n        # Distribute mass to 4 nearest grid nodes\n        for b in range(2):\n            for a in range(2):\n                node_i = (i_0 + a) % N\n                node_j = (j_0 + b) % N\n                mass_fraction = m * weights_x[a] * weights_y[b]\n                rho_grid[node_j, node_i] += mass_fraction / (delta**2)\n\n        # 3. Solve Poisson Equation in Fourier Space\n        rho_k = np.fft.fft2(rho_grid)\n        \n        # Wave numbers\n        k_vals = 2.0 * np.pi * np.fft.fftfreq(N, d=delta)\n        KX, KY = np.meshgrid(k_vals, k_vals)\n\n        # Effective k^2 for finite difference Laplacian\n        k_eff_sq = (2.0 / delta)**2 * (np.sin(KX * delta / 2.0)**2 + np.sin(KY * delta / 2.0)**2)\n        \n        # Avoid division by zero at k=0\n        # The potential at k=0 will be set to 0 anyway.\n        k_eff_sq[0, 0] = 1.0  \n\n        # Potential in Fourier space\n        phi_k = -4.0 * np.pi * G * rho_k / k_eff_sq\n        \n        # Set k=0 mode of potential to zero (enforces mean density subtraction)\n        phi_k[0, 0] = 0.0\n\n        # Potential in real space\n        phi_grid = np.fft.ifft2(phi_k).real\n\n        # 4. Force Calculation on the Grid\n        # Using np.roll for periodic boundary conditions\n        Fx_grid = - (np.roll(phi_grid, -1, axis=1) - np.roll(phi_grid, 1, axis=1)) / (2.0 * delta)\n        Fy_grid = - (np.roll(phi_grid, -1, axis=0) - np.roll(phi_grid, 1, axis=0)) / (2.0 * delta)\n\n        # 5. Force Interpolation (CIC)\n        Fp_x = 0.0\n        Fp_y = 0.0\n        \n        for b in range(2):\n            for a in range(2):\n                node_i = (i_0 + a) % N\n                node_j = (j_0 + b) % N\n                weight = weights_x[a] * weights_y[b]\n                Fp_x += Fx_grid[node_j, node_i] * weight\n                Fp_y += Fy_grid[node_j, node_i] * weight\n\n        # Calculate final quantities\n        s = np.sqrt(Fp_x**2 + Fp_y**2)\n        u = s * dt\n        \n        return s, u\n\n    # Define the test cases from the problem statement.\n    test_params = [\n        {'N': 32, 'dt': 0.01, 'offset_frac': (1/4, 0)},\n        {'N': 32, 'dt': 0.01, 'offset_frac': (1/4, 1/4)},\n        {'N': 16, 'dt': 0.01, 'offset_frac': (1/4, 1/4)},\n        {'N': 32, 'dt': 0.005, 'offset_frac': (1/4, 1/4)},\n        {'N': 32, 'dt': 0.01, 'offset_frac': (0, 0)},\n    ]\n\n    results = []\n    for params in test_params:\n        N = params['N']\n        dt = params['dt']\n        delta = 1.0 / N\n        offset_frac_x, offset_frac_y = params['offset_frac']\n        delta_offset = (offset_frac_x * delta, offset_frac_y * delta)\n        \n        s, u = compute_spurious_force(N, dt, delta_offset)\n        results.extend([s, u])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After analyzing the CIC scheme's smoothing properties and its grid-scale artifacts, the final step is to develop methods for correction. This exercise guides you through deriving and implementing a powerful technique to improve the accuracy of a PM solver by jointly correcting for two distinct sources of error in Fourier space. You will construct a deconvolution filter that simultaneously inverts the CIC smoothing window and corrects for the anisotropy of the finite-difference Laplacian, demonstrating a dramatic improvement in the accuracy of the recovered gravitational force .",
            "id": "3466943",
            "problem": "You are tasked with deriving and implementing a joint deconvolution in Fourier space that corrects both the Cloud-In-Cell (CIC) mass assignment window and the anisotropy introduced by the standard second-order discrete Laplacian on a uniform grid. The context is a periodic cubic domain and plane-wave density modes, which are used to test isotropy and accuracy of the recovered gravitational force. The goal is to show, from first principles, how to construct a multiplicative correction in Fourier space that maps the naive discrete solution back to the continuum target, and to validate the improvement in isotropy across differently oriented wave vectors.\n\nStart from the following fundamental base:\n- The Cloud-In-Cell (CIC) scheme is a linear mass assignment kernel. In Fourier space, the assigned density amplitude is multiplied by a window function $W_{\\mathrm{CIC}}(\\boldsymbol{k})$, which for a uniform cubic grid with spacing $\\Delta x$ factorizes as\n$$\nW_{\\mathrm{CIC}}(\\boldsymbol{k}) \\;=\\; \\prod_{i\\in\\{x,y,z\\}} \\left[ \\mathrm{sinc}\\!\\left(\\frac{k_i \\,\\Delta x}{2}\\right) \\right]^2,\n\\quad \\mathrm{sinc}(z)\\equiv\\frac{\\sin z}{z},\n$$\nwith $k_i$ the Cartesian components of the angular wave vector $\\boldsymbol{k}$ in radians per unit length. The $\\mathrm{sinc}$ function is evaluated at $z=0$ by continuity (i.e., $1$).\n- The second-order central difference discrete Laplacian on a grid of spacing $\\Delta x$ has the plane-wave eigenvalue\n$$\n\\tilde{k}^2(\\boldsymbol{k}) \\;=\\; \\frac{2}{\\Delta x^2}\\sum_{i\\in\\{x,y,z\\}} \\left[1 - \\cos\\!\\left(k_i \\,\\Delta x\\right)\\right],\n$$\nso that $-\\nabla_{\\mathrm{disc}}^2 e^{i\\boldsymbol{k}\\cdot\\boldsymbol{x}} \\;=\\; \\tilde{k}^2(\\boldsymbol{k}) \\, e^{i\\boldsymbol{k}\\cdot\\boldsymbol{x}}$.\n- In the continuum, Poisson’s equation for a density contrast field $\\delta(\\boldsymbol{x})$ reduces in Fourier space to\n$$\n\\phi(\\boldsymbol{k}) \\;=\\; -\\frac{\\delta(\\boldsymbol{k})}{k^2}, \\qquad k^2 \\equiv \\boldsymbol{k}\\cdot\\boldsymbol{k},\n$$\nand the gravitational force is\n$$\n\\boldsymbol{f}(\\boldsymbol{k}) \\;=\\; -i\\,\\boldsymbol{k}\\,\\phi(\\boldsymbol{k}) \\;=\\; i\\,\\frac{\\boldsymbol{k}}{k^2}\\,\\delta(\\boldsymbol{k}),\n$$\nin dimensionless units.\n\nYour tasks:\n1. Using only the facts above, derive a Fourier-space multiplicative deconvolution $D(\\boldsymbol{k})$ that, when applied to the naive discrete Fourier-space potential obtained from CIC-assigned density and the discrete Laplacian, yields the continuum target potential for each nonzero mode. Explicitly, your $D(\\boldsymbol{k})$ must jointly correct the CIC window $W_{\\mathrm{CIC}}(\\boldsymbol{k})$ and the discrete Laplacian eigenvalue $\\tilde{k}^2(\\boldsymbol{k})$.\n2. Implement a complete program that:\n   - Constructs a periodic cubic grid of size $N\\times N\\times N$ with $N=32$ and box side length $L=1$ (so $\\Delta x = L/N$).\n   - For each test case, builds a plane-wave density field $\\delta(\\boldsymbol{x}) = \\cos(\\boldsymbol{k}\\cdot\\boldsymbol{x})$ with $\\boldsymbol{k} = \\frac{2\\pi}{L}(m_x,m_y,m_z)$ using specified integer triplets $(m_x,m_y,m_z)$.\n   - Computes the Fast Fourier Transform (FFT) of $\\delta(\\boldsymbol{x})$ and applies CIC assignment by multiplying each Fourier mode by $W_{\\mathrm{CIC}}(\\boldsymbol{k})$.\n   - Solves the naive discrete Poisson equation in Fourier space using the discrete Laplacian eigenvalue to obtain $\\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = -\\delta_{\\mathrm{CIC}}(\\boldsymbol{k})/\\tilde{k}^2(\\boldsymbol{k})$ for all nonzero modes, and zero for the zero mode.\n   - Forms the naive force $\\boldsymbol{f}_{\\mathrm{naive}}(\\boldsymbol{k}) = -i\\,\\boldsymbol{k}\\,\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$, transforms it back to real space, and computes the continuum target force $\\boldsymbol{f}_{\\mathrm{true}}(\\boldsymbol{x}) = -\\frac{\\boldsymbol{k}}{k^2}\\sin(\\boldsymbol{k}\\cdot\\boldsymbol{x})$.\n   - Applies your derived joint deconvolution $D(\\boldsymbol{k})$ to $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$ to obtain $\\phi_{\\mathrm{corr}}(\\boldsymbol{k})$, builds the corrected force $\\boldsymbol{f}_{\\mathrm{corr}}(\\boldsymbol{k}) = -i\\,\\boldsymbol{k}\\,\\phi_{\\mathrm{corr}}(\\boldsymbol{k})$, and evaluates it in real space.\n   - For each test case, computes two dimensionless floats: the relative root-mean-square error of the naive force\n     $$\n     \\varepsilon_{\\mathrm{naive}} \\;=\\; \\frac{\\left\\lVert \\boldsymbol{f}_{\\mathrm{naive}} - \\boldsymbol{f}_{\\mathrm{true}} \\right\\rVert_{L^2}}{\\left\\lVert \\boldsymbol{f}_{\\mathrm{true}} \\right\\rVert_{L^2}},\n     $$\n     and the relative root-mean-square error of the corrected force\n     $$\n     \\varepsilon_{\\mathrm{corr}} \\;=\\; \\frac{\\left\\lVert \\boldsymbol{f}_{\\mathrm{corr}} - \\boldsymbol{f}_{\\mathrm{true}} \\right\\rVert_{L^2}}{\\left\\lVert \\boldsymbol{f}_{\\mathrm{true}} \\right\\rVert_{L^2}}.\n     $$\n     Here $\\left\\lVert \\cdot \\right\\rVert_{L^2}$ denotes the root-mean-square over the grid, i.e., the square root of the mean of the squared Euclidean norm of the vector field at grid points.\n3. Use dimensionless units throughout and ensure all trigonometric functions use radians.\n4. Test Suite:\n   - Use the following integer mode triplets $(m_x,m_y,m_z)$ to probe different orientations and scales:\n     - $(1,0,0)$: Long-wavelength axis-aligned mode (happy path).\n     - $(3,0,0)$: Intermediate axis-aligned mode.\n     - $(3,5,2)$: Off-axis oblique mode.\n     - $(15,0,0)$: Near-Nyquist axis-aligned mode (boundary).\n     - $(15,14,0)$: Near-Nyquist off-axis mode (edge case).\n     - $(9,9,9)$: Diagonal mode probing isotropy.\n5. Final Output Format:\n   - Your program should produce a single line of output containing the results as a comma-separated list of bracketed pairs with no spaces, each pair being $[\\varepsilon_{\\mathrm{naive}},\\varepsilon_{\\mathrm{corr}}]$ in scientific notation with six digits after the decimal point, for the test cases in the order listed above. For example: $[[1.234567e-03,4.567890e-05],[\\dots],[\\dots],\\dots]$.\n\nYour derivation and implementation should be strictly based on the fundamentals given above and should not rely on any shortcuts or pre-specified correction formulas. Demonstrate clearly why your deconvolution works and how it improves isotropy across the provided test modes. The program must be self-contained and require no input, external files, or network access. Use dimensionless units and radians throughout.",
            "solution": "The user has provided a well-defined problem in the domain of numerical cosmology. All necessary physical and mathematical definitions are supplied, the objectives are clear, and the problem is scientifically grounded in standard computational physics techniques. The problem is therefore deemed valid.\n\n### Derivation of the Joint Deconvolution Factor\n\nThe goal is to find a multiplicative correction factor $D(\\boldsymbol{k})$ in Fourier space that transforms the naively-computed gravitational potential, $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$, into the true continuum potential, $\\phi_{\\mathrm{true}}(\\boldsymbol{k})$.\n\nLet $\\delta(\\boldsymbol{x})$ be the true continuum density contrast field. Its Fourier transform is $\\delta(\\boldsymbol{k})$. In the context of a numerical simulation on a grid, this field is first assigned to the grid cells. The problem states that we model this using the Cloud-In-Cell (CIC) assignment scheme, which acts as a linear filter. In Fourier space, the density on the grid, $\\delta_{\\mathrm{CIC}}(\\boldsymbol{k})$, is related to the true density by the CIC window function, $W_{\\mathrm{CIC}}(\\boldsymbol{k})$:\n$$\n\\delta_{\\mathrm{CIC}}(\\boldsymbol{k}) = W_{\\mathrm{CIC}}(\\boldsymbol{k}) \\, \\delta(\\boldsymbol{k})\n$$\nwhere\n$$\nW_{\\mathrm{CIC}}(\\boldsymbol{k}) \\;=\\; \\prod_{i\\in\\{x,y,z\\}} \\left[ \\mathrm{sinc}\\!\\left(\\frac{k_i \\,\\Delta x}{2}\\right) \\right]^2,\n\\quad \\mathrm{sinc}(z)\\equiv\\frac{\\sin z}{z}\n$$\nHere, $k_i$ are the components of the wave vector $\\boldsymbol{k}$ and $\\Delta x$ is the grid spacing. This window function accounts for the smoothing effect of the CIC assignment.\n\nNext, the discrete Poisson equation is solved. The continuum Poisson equation in Fourier space is $\\nabla^2 \\phi = \\delta$ (in appropriate units), which becomes $-k^2 \\phi(\\boldsymbol{k}) = \\delta(\\boldsymbol{k})$. The naive discrete approach replaces the continuum Laplacian operator eigenvalue, $-k^2 = -(\\boldsymbol{k}\\cdot\\boldsymbol{k})$, with the eigenvalue of the second-order finite-difference Laplacian, $-\\tilde{k}^2(\\boldsymbol{k})$, where:\n$$\n\\tilde{k}^2(\\boldsymbol{k}) \\;=\\; \\frac{2}{\\Delta x^2}\\sum_{i\\in\\{x,y,z\\}} \\left[1 - \\cos\\!\\left(k_i \\,\\Delta x\\right)\\right]\n$$\nThe naive discrete solver therefore calculates a potential $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$ by solving $-\\tilde{k}^2(\\boldsymbol{k}) \\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = \\delta_{\\mathrm{CIC}}(\\boldsymbol{k})$. For any mode where $\\tilde{k}^2(\\boldsymbol{k}) \\neq 0$, the naive potential is:\n$$\n\\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = -\\frac{\\delta_{\\mathrm{CIC}}(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})}\n$$\nSubstituting the expression for $\\delta_{\\mathrm{CIC}}(\\boldsymbol{k})$, we get:\n$$\n\\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = -\\frac{W_{\\mathrm{CIC}}(\\boldsymbol{k}) \\, \\delta(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})}\n$$\nThis expression reveals the two sources of error in the naive solution: the CIC window function $W_{\\mathrm{CIC}}(\\boldsymbol{k})$ in the numerator, and the discrete Laplacian eigenvalue $\\tilde{k}^2(\\boldsymbol{k})$ in the denominator.\n\nThe target solution is the continuum potential, $\\phi_{\\mathrm{true}}(\\boldsymbol{k})$, defined by the continuum Poisson equation:\n$$\n\\phi_{\\mathrm{true}}(\\boldsymbol{k}) = -\\frac{\\delta(\\boldsymbol{k})}{k^2}\n$$\nwhere $k^2 = \\boldsymbol{k}\\cdot\\boldsymbol{k}$ is the squared magnitude of the continuum wave vector.\n\nWe seek a deconvolution factor $D(\\boldsymbol{k})$ such that applying it to the naive potential yields the true potential:\n$$\n\\phi_{\\mathrm{corr}}(\\boldsymbol{k}) = D(\\boldsymbol{k}) \\, \\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = \\phi_{\\mathrm{true}}(\\boldsymbol{k})\n$$\nSubstituting the expressions for $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$ and $\\phi_{\\mathrm{true}}(\\boldsymbol{k})$:\n$$\nD(\\boldsymbol{k}) \\left( -\\frac{W_{\\mathrm{CIC}}(\\boldsymbol{k}) \\, \\delta(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})} \\right) = -\\frac{\\delta(\\boldsymbol{k})}{k^2}\n$$\nFor any mode $\\boldsymbol{k}$ where $\\delta(\\boldsymbol{k}) \\neq 0$, we can cancel $-\\delta(\\boldsymbol{k})$ from both sides:\n$$\nD(\\boldsymbol{k}) \\frac{W_{\\mathrm{CIC}}(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})} = \\frac{1}{k^2}\n$$\nSolving for $D(\\boldsymbol{k})$, we arrive at the joint deconvolution factor:\n$$\nD(\\boldsymbol{k}) = \\frac{\\tilde{k}^2(\\boldsymbol{k})}{k^2 \\, W_{\\mathrm{CIC}}(\\boldsymbol{k})}\n$$\nThis factor must be applied multiplicatively to the naive potential $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$ for every non-zero mode $\\boldsymbol{k}$ (i.e., where $k^2 \\neq 0$). For the $\\boldsymbol{k}=\\boldsymbol{0}$ mode (the DC component), both $k^2$ and $\\tilde{k}^2$ are zero, and the potential is typically set to zero as it represents an arbitrary constant offset. The deconvolution factor $D(\\boldsymbol{k})$ simultaneously corrects for both systematic errors:\n1.  The term $1/W_{\\mathrm{CIC}}(\\boldsymbol{k})$ \"deconvolves\" or inverts the smoothing effect of the CIC mass assignment.\n2.  The term $\\tilde{k}^2(\\boldsymbol{k})/k^2$ corrects the anisotropic and inaccurate response of the discrete Laplacian, replacing it with the isotropic continuum operator.\n\nThe corrected potential is thus:\n$$\n\\phi_{\\mathrm{corr}}(\\boldsymbol{k}) = D(\\boldsymbol{k}) \\, \\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = \\left( \\frac{\\tilde{k}^2(\\boldsymbol{k})}{k^2 \\, W_{\\mathrm{CIC}}(\\boldsymbol{k})} \\right) \\left( -\\frac{W_{\\mathrm{CIC}}(\\boldsymbol{k}) \\, \\delta(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})} \\right) = -\\frac{\\delta(\\boldsymbol{k})}{k^2} = \\phi_{\\mathrm{true}}(\\boldsymbol{k})\n$$\nThis confirms the validity of the derived deconvolution factor. The implementation will compute this factor for all relevant Fourier modes and apply it to obtain a corrected force field, which is expected to be significantly more accurate and isotropic than the naive result.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies a joint deconvolution in Fourier space to correct\n    for CIC mass assignment and discrete Laplacian anisotropy in a numerical\n    cosmology context.\n    \"\"\"\n    # 1. Setup Grid and Parameters\n    N = 32  # Grid size\n    L = 1.0  # Box side length\n    dx = L / N  # Grid spacing\n\n    # Real space grid coordinates\n    grid_1d = np.arange(N) * dx\n    xx, yy, zz = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n    # Fourier space wave vectors (angular frequencies)\n    k_freq = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    kx, ky, kz = np.meshgrid(k_freq, k_freq, k_freq, indexing='ij')\n\n    # 2. Pre-compute Fourier-space kernels\n\n    # Mask for the k=0 mode\n    k_is_zero = (kx == 0)  (ky == 0)  (kz == 0)\n    non_zero_k = ~k_is_zero\n    \n    # Continuum Laplacian eigenvalue (squared magnitude of wave vector)\n    k_squared = kx**2 + ky**2 + kz**2\n\n    # Discrete Laplacian eigenvalue\n    tilde_k_squared = (2.0 / dx**2) * ( (1 - np.cos(kx * dx)) +\n                                       (1 - np.cos(ky * dx)) +\n                                       (1 - np.cos(kz * dx)) )\n\n    # CIC window function W_CIC(k).\n    # The problem defines sinc(z) = sin(z)/z.\n    # numpy.sinc(x) computes sin(pi*x)/(pi*x).\n    # To compute sin(z)/z, we can use np.sinc(z/pi).\n    # The argument to our sinc is z = k_i * dx / 2.\n    # So the argument to np.sinc is (k_i * dx / 2) / pi = k_i * dx / (2*pi).\n    sinc_arg_x = kx * dx / (2.0 * np.pi)\n    sinc_arg_y = ky * dx / (2.0 * np.pi)\n    sinc_arg_z = kz * dx / (2.0 * np.pi)\n    W_cic = (np.sinc(sinc_arg_x) * np.sinc(sinc_arg_y) * np.sinc(sinc_arg_z))**2\n    \n    # Joint deconvolution factor D(k)\n    # D(k) = tilde_k^2 / (k^2 * W_cic)\n    D_k = np.ones_like(kx, dtype=float) # Initialize to 1\n    # Compute only for non-zero k to avoid division by zero\n    D_k[non_zero_k] = np.divide(tilde_k_squared[non_zero_k],\n                                W_cic[non_zero_k] * k_squared[non_zero_k])\n    \n    # Test suite\n    test_cases = [\n        (1, 0, 0),\n        (3, 0, 0),\n        (3, 5, 2),\n        (15, 0, 0),\n        (15, 14, 0),\n        (9, 9, 9),\n    ]\n\n    results = []\n\n    for m_vec in test_cases:\n        # 3. Define the wave for the current test case\n        k0_vec = (2 * np.pi / L) * np.array(m_vec)\n        k0_sq = np.sum(k0_vec**2)\n\n        # 4. Generate density field and its Fourier transform\n        # delta(x) = cos(k_0 . x)\n        delta_x = np.cos(k0_vec[0] * xx + k0_vec[1] * yy + k0_vec[2] * zz)\n        delta_k = np.fft.fftn(delta_x)\n\n        # Apply CIC window effect\n        delta_cic_k = delta_k * W_cic\n\n        # 5. Naive Solution\n        # phi_naive(k) = -delta_cic(k) / tilde_k^2\n        phi_naive_k = np.zeros_like(delta_k, dtype=complex)\n        phi_naive_k[non_zero_k] = -delta_cic_k[non_zero_k] / tilde_k_squared[non_zero_k]\n        \n        # f_naive(k) = -i * k * phi_naive(k)\n        f_naive_k_x = -1j * kx * phi_naive_k\n        f_naive_k_y = -1j * ky * phi_naive_k\n        f_naive_k_z = -1j * kz * phi_naive_k\n\n        # Transform naive force back to real space\n        f_naive_x = np.real(np.fft.ifftn(f_naive_k_x))\n        f_naive_y = np.real(np.fft.ifftn(f_naive_k_y))\n        f_naive_z = np.real(np.fft.ifftn(f_naive_k_z))\n        f_naive = np.stack([f_naive_x, f_naive_y, f_naive_z])\n        \n        # 6. Corrected Solution\n        # phi_corr(k) = D(k) * phi_naive(k)\n        phi_corr_k = D_k * phi_naive_k\n        \n        # f_corr(k) = -i * k * phi_corr(k)\n        f_corr_k_x = -1j * kx * phi_corr_k\n        f_corr_k_y = -1j * ky * phi_corr_k\n        f_corr_k_z = -1j * kz * phi_corr_k\n\n        # Transform corrected force back to real space\n        f_corr_x = np.real(np.fft.ifftn(f_corr_k_x))\n        f_corr_y = np.real(np.fft.ifftn(f_corr_k_y))\n        f_corr_z = np.real(np.fft.ifftn(f_corr_k_z))\n        f_corr = np.stack([f_corr_x, f_corr_y, f_corr_z])\n\n        # 7. True (Continuum) Solution\n        # f_true(x) = -(k_0 / k_0^2) * sin(k_0 . x)\n        sin_term = np.sin(k0_vec[0] * xx + k0_vec[1] * yy + k0_vec[2] * zz)\n        # Avoid division by zero if k0_sq is zero (not the case here)\n        factor = -1.0 / k0_sq if k0_sq  0 else 0.0\n        f_true_x = k0_vec[0] * factor * sin_term\n        f_true_y = k0_vec[1] * factor * sin_term\n        f_true_z = k0_vec[2] * factor * sin_term\n        f_true = np.stack([f_true_x, f_true_y, f_true_z])\n\n        # 8. Compute Errors\n        # L2-norm is sqrt of mean of squared magnitudes\n        norm_true_sq = np.mean(np.sum(f_true**2, axis=0))\n        \n        diff_naive_sq = np.mean(np.sum((f_naive - f_true)**2, axis=0))\n        err_naive = np.sqrt(diff_naive_sq / norm_true_sq)\n        \n        diff_corr_sq = np.mean(np.sum((f_corr - f_true)**2, axis=0))\n        err_corr = np.sqrt(diff_corr_sq / norm_true_sq)\n        \n        results.append([err_naive, err_corr])\n\n    # 9. Format and Print Output\n    output_str = '[' + ','.join([f'[{r[0]:.6e},{r[1]:.6e}]' for r in results]) + ']'\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}