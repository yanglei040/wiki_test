{
    "hands_on_practices": [
        {
            "introduction": "泽尔多维奇近似的普适时间演化由线性增长因子 $D(a)$ 描述。本练习将指导您直接从控制宇宙学微扰的基本方程出发，推导并数值计算这个关键函数。成功完成此练习，意味着您将能够为任何给定的 $\\Lambda$CDM 宇宙计算出决定结构形成步伐的“主时钟”。",
            "id": "3500913",
            "problem": "考虑在数值宇宙学中使用泽尔多维奇近似 (Zel'dovich approximation)，其中共动位移场与密度微扰的线性增长因子 $D(a)$ 成正比，$a$ 表示宇宙尺度因子。从适用于空间平坦的ΛCDM（Λ-冷暗物质）宇宙学的第一性原理出发，推导并实现归一化线性增长因子 $D(a)$ 的数值计算，步骤如下。\n\n从由弗里德曼方程描述的背景动力学（适用于空间平坦宇宙）、物质密度标度关系以及线性微扰增长方程开始：\n- 哈勃参数 $H(a)$ 满足 $H^{2}(a) = H_{0}^{2}\\left[\\Omega_{m0} a^{-3} + \\Omega_{\\Lambda 0}\\right]$，其中 $\\Omega_{\\Lambda 0} = 1 - \\Omega_{m0}$。\n- 物质密度遵循 $\\rho_{m}(a) = \\rho_{m0} a^{-3}$。\n- 线性增长因子 $D(a)$ 根据关于宇宙时 $t$ 的二阶常微分方程演化：\n$$\\frac{d^{2}D}{dt^{2}} + 2 H(a) \\frac{dD}{dt} - 4\\pi G \\rho_{m}(a) D = 0.$$\n\n您的任务是：\n1. 通过将微分方程从对时间 $t$ 的导数转换为对尺度因子 $a$ 的导数，找出一个衰减模解，并通过降阶法构造增长模解，从而推导出增长模解 $D(a)$ 的积分表示（不计总体的乘法常数）。\n2. 使用推导出的积分表示，实现一个数值算法来计算无量纲的归一化增长因子 $\\tilde{D}(a)$，使得 $\\tilde{D}(1) = 1$。您必须通过使用无量纲哈勃函数 $E(a) \\equiv H(a)/H_{0}$ 来明确避免对 $H_{0}$（今日哈勃常数）绝对值的任何依赖。\n3. 通过以科学合理的方式处理当 $a' \\to 0$ 时的可积奇异行为，确保在积分下限附近的数值稳健性。\n\n本问题中的所有量均为无量纲，因此最终答案中不出现物理单位。不涉及角度。最终的数值输出必须是无量纲的浮点数。\n\n测试套件：\n为以下参数集 $(\\Omega_{m0}, a)$ 计算 $\\tilde{D}(a)$：\n- $(0.3, 0.5)$\n- $(0.3, 1.0)$\n- $(0.3, 2.0)$\n- $(1.0, 0.1)$\n- $(1.0, 1.0)$\n- $(1.0, 2.0)$\n- $(0.99, 0.01)$\n- $(0.01, 0.5)$\n\n您必须实现一个程序，为每个测试用例评估 $\\tilde{D}(a)$，并生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,...]”）。列表中的每个元素都必须是浮点数。\n\n您的程序必须是独立自足的，不需要输入，并使用数值稳定的求积方法。最终答案应为浮点数且无量纲。",
            "solution": "用户提供的问题被评估为**有效**。这是一个科学上合理、适定且完整的物理宇宙学问题，既需要解析推导也需要数值实现。问题陈述基于标准的ΛCDM宇宙学模型，并要求使用成熟的数学技术计算一个基本量——线性增长因子。\n\n### 线性增长因子的推导\n\n目标是找到线性微扰增长方程的增长模解，并实现其数值计算。推导过程分四步：变换微分方程，确定一个已知解，通过降阶法构造第二个解，以及构建一个适合数值计算的、归一化的无量纲表达式。\n\n#### 步骤1：控制方程的变换\n线性增长因子 $D$ 的演化由关于宇宙时 $t$ 的二阶常微分方程（ODE）描述：\n$$\n\\frac{d^{2}D}{dt^{2}} + 2 H(a) \\frac{dD}{dt} - 4\\pi G \\rho_{m}(a) D = 0.\n$$\n此处，$a$ 是宇宙尺度因子，$H(a) = \\dot{a}/a$ 是哈勃参数，$G$ 是引力常数，$\\rho_m(a)$ 是背景物质密度。为求解此方程，我们将自变量从 $t$ 变换为 $a$。使用链式法则，时间导数变为：\n$$\n\\frac{d}{dt} = \\frac{da}{dt} \\frac{d}{da} = \\dot{a} \\frac{d}{da} = a H(a) \\frac{d}{da}.\n$$\n$$\n\\frac{d^2}{dt^2} = (aH) \\frac{d}{da} \\left( aH \\frac{d}{da} \\right) = aH \\left( H + a \\frac{dH}{da} \\right) \\frac{d}{da} + (aH)^2 \\frac{d^2}{da^2}.\n$$\n将这些代入ODE中得到：\n$$\n(aH)^2 \\frac{d^2D}{da^2} + \\left( aH^2 + a^2 H \\frac{dH}{da} \\right) \\frac{dD}{da} + 2H(a) \\left( aH \\frac{dD}{da} \\right) - 4\\pi G \\rho_m(a) D = 0.\n$$\n化简后得到：\n$$\n\\frac{d^2D}{da^2} + \\left( \\frac{1}{a} + \\frac{1}{H} \\frac{dH}{da} + \\frac{2}{a} \\right) \\frac{dD}{da} - \\frac{4\\pi G \\rho_m(a)}{a^2 H(a)^2} D = 0.\n$$\n对于平坦的ΛCDM宇宙，弗里德曼方程为 $H^2(a) = H_0^2 \\left[ \\Omega_{m0} a^{-3} + (1-\\Omega_{m0}) \\right]$。此外，今日的临界密度为 $\\rho_{c0} = 3H_0^2 / (8\\pi G)$，且 $\\rho_m(a) = \\rho_{m0} a^{-3} = \\Omega_{m0} \\rho_{c0} a^{-3}$。利用这些关系，$D$ 的系数变为：\n$$\n\\frac{4\\pi G \\rho_m(a)}{a^2 H(a)^2} = \\frac{4\\pi G (\\Omega_{m0} \\frac{3H_0^2}{8\\pi G} a^{-3})}{a^2 H(a)^2} = \\frac{3}{2a^2} \\frac{H_0^2 \\Omega_{m0} a^{-3}}{H(a)^2} = \\frac{3}{2a^2} \\Omega_m(a),\n$$\n其中 $\\Omega_m(a) = \\frac{\\Omega_{m0} a^{-3}}{H(a)^2/H_0^2}$ 是尺度因子为 $a$ 时的物质密度参数。变换后的ODE为：\n$$\n\\frac{d^2D}{da^2} + \\left( \\frac{3}{a} + \\frac{1}{H}\\frac{dH}{da} \\right) \\frac{dD}{da} - \\frac{3}{2a^2} \\Omega_m(a) D = 0.\n$$\n\n#### 步骤2：通过降阶法求解\n这是一个二阶线性齐次常微分方程。如果已知一个解 $D_1(a)$，则可以使用降阶法找到第二个线性无关的解 $D_2(a)$。原始时间ODE的一个已知解是衰减模，可以证明其为 $D_1(t) \\propto H(a(t))$。我们来验证 $D_1(a) = H(a)$ 是一个解。在推导的思考过程中，我们已经发现这确实是一个解。\n\n有了一个解 $D_1(a) = H(a)$，第二个解由以下公式给出：\n$$\nD_2(a) = D_1(a) \\int^a \\frac{W(a')}{D_1(a')^2} da',\n$$\n其中朗斯基行列式 (Wronskian) $W(a')$ 满足阿贝尔恒等式 (Abel's identity)。对于形式为 $y'' + P(x)y' + Q(x)y = 0$ 的ODE，朗斯基行列式为 $W(x) \\propto \\exp(-\\int P(x) dx)$。在我们的例子中，$P(a) = \\frac{3}{a} + \\frac{1}{H}\\frac{dH}{da}$。\n$$\n\\int P(a) da = \\int \\left( \\frac{3}{a} + \\frac{H'(a)}{H(a)} \\right) da = 3\\ln(a) + \\ln(H(a)) = \\ln(a^3 H(a)).\n$$\n所以，朗斯基行列式为 $W(a) \\propto \\exp(-\\ln(a^3 H(a))) = \\frac{1}{a^3 H(a)}$。将 $D_1 = H$ 和朗斯基行列式代入 $D_2$ 的公式中：\n$$\nD_2(a) \\propto H(a) \\int_0^a \\frac{1/(a'^3 H(a'))}{H(a')^2} da' = H(a) \\int_0^a \\frac{da'}{a'^3 H(a')^3}.\n$$\n通解是衰减模（$D_1 \\propto H(a)$）和增长模（$D_2$）的线性组合。因此，增长模解为：\n$$\nD_+(a) = C \\cdot H(a) \\int_0^a \\frac{da'}{a'^3 H(a')^3},\n$$\n其中 $C$ 是一个任意常数。\n\n#### 步骤3：数值公式\n为了实现数值解，我们将表达式变为无量纲且独立于 $H_0$。我们定义无量纲哈勃函数 $E(a) = H(a)/H_0 = \\sqrt{\\Omega_{m0} a^{-3} + (1-\\Omega_{m0})}$。将 $H(a) = H_0 E(a)$ 代入 $D_+(a)$ 的表达式中：\n$$\nD_+(a) = C \\cdot (H_0 E(a)) \\int_0^a \\frac{da'}{a'^3 (H_0 E(a'))^3} = C \\frac{H_0}{H_0^3} E(a) \\int_0^a \\frac{da'}{a'^3 E(a')^3}.\n$$\n$H_0$ 的因子可以被吸收到一个新的常数中，从而得到一个未归一化的增长因子 $D_{un}(a)$：\n$$\nD_{un}(a) = E(a) \\int_0^a \\frac{da'}{a'^3 E(a')^3}.\n$$\n问题要求一个归一化的增长因子 $\\tilde{D}(a)$，使得 $\\tilde{D}(1)=1$。这通过将未归一化的函数除以其在 $a=1$ 处的值来实现：\n$$\n\\tilde{D}(a) = \\frac{D_{un}(a)}{D_{un}(1)} = \\frac{E(a) \\int_0^a \\frac{da'}{a'^3 E(a')^3}}{E(1) \\int_0^1 \\frac{da'}{a'^3 E(a')^3}}.\n$$\n这是需要计算的最终表达式。\n\n#### 步骤4：处理小尺度因子下的被积函数\n问题要求处理 $a' \\to 0$ 附近的可积奇异行为。被积函数为 $I(a') = 1/(a'^3 E(a')^3)$。对非常小的 $a'$ 直接计算此式可能导致数值溢出，因为 $E(a') \\propto a'^{-3/2}$，会导致诸如 $a'^{-9/2}$ 的项。为创建一个数值稳定的形式，我们重写被积函数：\n$$\nE(a')^2 = \\Omega_{m0} a'^{-3} + \\Omega_{\\Lambda 0} = a'^{-3}(\\Omega_{m0} + \\Omega_{\\Lambda 0} a'^3).\n$$\n所以，$E(a')^3 = a'^{-9/2}(\\Omega_{m0} + \\Omega_{\\Lambda 0} a'^3)^{3/2}$。被积函数变为：\n$$\nI(a') = \\frac{1}{a'^3 \\left[ a'^{-9/2}(\\Omega_{m0} + \\Omega_{\\Lambda 0} a'^3)^{3/2} \\right]} = \\frac{a'^{-3} a'^{9/2}}{(\\Omega_{m0} + \\Omega_{\\Lambda 0} a'^3)^{3/2}} = \\frac{a'^{3/2}}{(\\Omega_{m0} + \\Omega_{\\Lambda 0} a'^3)^{3/2}}.\n$$\n这个重写的形式在数值上是稳健的。当 $a' \\to 0$ 时，分子趋于 $0$，分母趋于 $\\Omega_{m0}^{3/2}$（对于 $\\Omega_{m0} > 0$），因此被积函数本身趋于 $0$。这避免了任何浮点数溢出问题，并允许从积分下限 $0$ 开始进行稳定的数值求积。对于 $\\Omega_{m0}=1$ 的特殊情况，$\\tilde{D}(a)$ 的表达式在解析上简化为 $\\tilde{D}(a)=a$。这为数值实现提供了一个有价值的交叉检验。\n\n数值解将使用Python中的 `scipy.integrate.quad` 函数进行高精度求积来实现。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Derives and computes the normalized linear growth factor D(a) for a flat\n    LambdaCDM cosmology.\n    \"\"\"\n\n    # Test cases: tuples of (Omega_m0, scale_factor_a)\n    test_cases = [\n        (0.3, 0.5),\n        (0.3, 1.0),\n        (0.3, 2.0),\n        (1.0, 0.1),\n        (1.0, 1.0),\n        (1.0, 2.0),\n        (0.99, 0.01),\n        (0.01, 0.5),\n    ]\n\n    results = []\n    for omega_m0, a in test_cases:\n        result = calculate_growth_factor(omega_m0, a)\n        results.append(result)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\n\ndef calculate_growth_factor(omega_m0, a):\n    \"\"\"\n    Calculates the normalized growth factor D_tilde(a) such that D_tilde(1) = 1.\n\n    Args:\n        omega_m0 (float): Matter density parameter today.\n        a (float): The cosmic scale factor.\n\n    Returns:\n        float: The value of the normalized growth factor D_tilde(a).\n    \"\"\"\n\n    # For the Einstein-de Sitter case (omega_m0 = 1), the growth factor is\n    # analytically known to be D(a) propto a. After normalization D(1)=1,\n    # we get D_tilde(a) = a. This is more accurate than numerical integration.\n    if np.isclose(omega_m0, 1.0):\n        return a\n\n    omega_l0 = 1.0 - omega_m0\n\n    # The integrand is rewritten for numerical stability near a_prime -> 0.\n    # Original form: 1 / (a_prime**3 * E(a_prime)**3)\n    # Stable form: a_prime**(3/2) / (omega_m0 + omega_l0 * a_prime**3)**(3/2)\n    def integrand(a_prime, om0, ol0):\n        if a_prime == 0:\n            return 0.0\n        numerator = a_prime**1.5\n        denominator = (om0 + ol0 * a_prime**3)**1.5\n        return numerator / denominator\n\n    # Dimensionless Hubble parameter E(a) = H(a)/H0\n    def E_func(a_val, om0, ol0):\n        if a_val == 0:\n            return np.inf\n        return np.sqrt(om0 * a_val**-3 + ol0)\n\n    # Numerator part of the D_tilde(a) expression\n    # D_un_num = E(a) * integral from 0 to a\n    integral_num, err_num = quad(integrand, 0, a, args=(omega_m0, omega_l0))\n    D_un_num = E_func(a, omega_m0, omega_l0) * integral_num\n    \n    # Denominator part of the D_tilde(a) expression (for normalization)\n    # D_un_den = E(1) * integral from 0 to 1\n    integral_den, err_den = quad(integrand, 0, 1.0, args=(omega_m0, omega_l0))\n    # E(1) = sqrt(omega_m0 + omega_l0) = sqrt(1) = 1\n    D_un_den = 1.0 * integral_den \n                                \n    # Handle the case where the denominator might be zero (though unlikely for omega_m0 > 0)\n    if D_un_den == 0:\n        # This case suggests no growth, physically corresponds to omega_m0=0.\n        return 0.0 \n\n    return D_un_num / D_un_den\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "泽尔多维奇近似的预测能力在于其能够精确定位引力坍缩的时刻，即所谓的壳层穿越或焦散面形成。本练习揭示了初始密度场性质（编码于形变张量的特征值中）与第一批结构形成时的宇宙尺度因子之间的优美联系。这一原理是理解宇宙网如何涌现的基石。",
            "id": "3500966",
            "problem": "考虑一个在 Einstein–de Sitter (EdS) 宇宙中演化的无压、自引力的冷暗物质 (CDM) 流体。在 Zel'dovich 近似中，每个由其拉格朗日坐标 $\\boldsymbol{q}$ 标记的流体元都遵循由共动映射 $\\boldsymbol{x}(\\boldsymbol{q},a) = \\boldsymbol{q} + D(a)\\,\\boldsymbol{s}(\\boldsymbol{q})$ 给出的轨迹，其中 $a$ 是宇宙学尺度因子，$D(a)$ 是线性增长因子，$\\boldsymbol{s}(\\boldsymbol{q})$ 是一个无旋位移场。设局域 (对称) 形变张量为 $d_{ij}(\\boldsymbol{q}) \\equiv \\partial s_i / \\partial q_j$，其真实本征值为 $\\{\\lambda_1,\\lambda_2,\\lambda_3\\}$，按 $\\lambda_1 \\le \\lambda_2 \\le \\lambda_3  0$ 的顺序排列。仅使用共动坐标系中的质量守恒以及首次壳层穿越 (焦散) 发生在拉格朗日到欧拉的映射变为奇异的时刻这一事实，确定首次焦散形成时的尺度因子 $a_{\\rm sc}$，并用本征值 $\\{\\lambda_i\\}$ 表示。假设在 Einstein–de Sitter 宇宙中，线性增长因子满足 $D(a) \\propto a$ 且被归一化以使得 $D(1)=1$。你的最终答案必须是 $a_{\\rm sc}$ 的一个单一闭式解析表达式，用 $\\lambda_1$, $\\lambda_2$ 和 $\\lambda_3$ 表示 (无单位)。",
            "solution": "问题要求解在 Einstein-de Sitter 宇宙中，对于一个无压流体，在 Zel'dovich 近似下首次焦散（或壳层穿越）发生时的尺度因子 $a_{\\rm sc}$。\n\n出发点是 Zel'dovich 近似，它提供了一个从流体元的初始 (拉格朗日) 共动坐标 $\\boldsymbol{q}$ 到稍后时刻（由尺度因子 $a$ 参数化）的欧拉共动坐标 $\\boldsymbol{x}$ 的映射。该映射表示为：\n$$\n\\boldsymbol{x}(\\boldsymbol{q}, a) = \\boldsymbol{q} + D(a)\\,\\boldsymbol{s}(\\boldsymbol{q})\n$$\n此处，$D(a)$ 是线性增长因子，描述了线性密度扰动的时间演化，$\\boldsymbol{s}(\\boldsymbol{q})$ 是与时间无关的位移场。\n\n当初始时不同的流体元在同一空间位置相遇时，就会发生焦散或壳层穿越。在数学上，这对应于从拉格朗日坐标到欧拉坐标的映射变为奇异的点。该映射的奇异性由其雅可比矩阵 $J_{ij}$ 决定。当且仅当雅可比矩阵的行列式为零时，该映射是奇异的。\n\n雅可比矩阵的分量由 $J_{ij} = \\frac{\\partial x_i}{\\partial q_j}$ 给出。使用给定的映射，我们计算其偏导数：\n$$\nJ_{ij}(\\boldsymbol{q}, a) = \\frac{\\partial}{\\partial q_j} \\left( q_i + D(a)\\,s_i(\\boldsymbol{q}) \\right)\n$$\n第一项的导数是克罗内克 δ 符号，$\\frac{\\partial q_i}{\\partial q_j} = \\delta_{ij}$。第二项涉及位移场的导数。问题将局域形变张量定义为 $d_{ij}(\\boldsymbol{q}) \\equiv \\frac{\\partial s_i}{\\partial q_j}$。因此，雅可比矩阵变为：\n$$\nJ_{ij}(\\boldsymbol{q}, a) = \\delta_{ij} + D(a)\\,d_{ij}(\\boldsymbol{q})\n$$\n用矩阵表示法，这可以写成：\n$$\n\\boldsymbol{J} = \\boldsymbol{I} + D(a)\\,\\boldsymbol{d}\n$$\n其中 $\\boldsymbol{I}$ 是 $3 \\times 3$ 单位矩阵，$\\boldsymbol{d}$ 是形变张量矩阵。\n\n壳层穿越的条件是映射变为奇异，即 $\\det(\\boldsymbol{J}) = 0$。\n$$\n\\det(\\boldsymbol{I} + D(a)\\,\\boldsymbol{d}) = 0\n$$\n为计算此行列式，我们考虑所涉及矩阵的本征值。问题指出形变张量 $\\boldsymbol{d}$ 是一个具有本征值 $\\{\\lambda_1, \\lambda_2, \\lambda_3\\}$ 的实对称矩阵。设 $\\boldsymbol{v}_1, \\boldsymbol{v}_2, \\boldsymbol{v}_3$ 是相应的标准正交本征向量。对于 $\\boldsymbol{d}$ 的任意一个本征值为 $\\lambda_k$ 的本征向量 $\\boldsymbol{v}_k$，我们有 $\\boldsymbol{d}\\boldsymbol{v}_k = \\lambda_k \\boldsymbol{v}_k$。\n\n我们可以通过将雅可比矩阵 $\\boldsymbol{J}$ 作用于 $\\boldsymbol{d}$ 的本征向量来找到 $\\boldsymbol{J}$ 的本征值：\n$$\n\\boldsymbol{J}\\boldsymbol{v}_k = (\\boldsymbol{I} + D(a)\\,\\boldsymbol{d})\\boldsymbol{v}_k = \\boldsymbol{I}\\boldsymbol{v}_k + D(a)\\,\\boldsymbol{d}\\boldsymbol{v}_k = \\boldsymbol{v}_k + D(a)\\lambda_k\\boldsymbol{v}_k = (1 + D(a)\\lambda_k)\\boldsymbol{v}_k\n$$\n这表明 $\\boldsymbol{d}$ 的本征向量也是 $\\boldsymbol{J}$ 的本征向量，并且 $\\boldsymbol{J}$ 的本征值为 $\\{1+D(a)\\lambda_1, 1+D(a)\\lambda_2, 1+D(a)\\lambda_3\\}$。\n\n矩阵的行列式是其本征值的乘积。因此，雅可比矩阵的行列式为：\n$$\n\\det(\\boldsymbol{J}) = \\prod_{k=1}^{3} (1 + D(a)\\lambda_k) = (1 + D(a)\\lambda_1)(1 + D(a)\\lambda_2)(1 + D(a)\\lambda_3)\n$$\n壳层穿越条件 $\\det(\\boldsymbol{J}) = 0$ 在且仅在至少有一个因子为零时满足：\n$$\n1 + D(a)\\lambda_k = 0 \\quad \\text{for some } k \\in \\{1, 2, 3\\}\n$$\n这给出了壳层穿越发生时增长因子所需满足的条件：\n$$\nD(a) = -\\frac{1}{\\lambda_k}\n$$\n问题明确指出所有本征值均为负：$\\lambda_1 \\le \\lambda_2 \\le \\lambda_3  0$。这确保了 $-1/\\lambda_k$ 的值均为正。由于宇宙从早期（小 $a$）的光滑状态开始，并向结构形成方向演化，增长因子 $D(a)$ 是 $a$ 的一个单调递增函数，从 $a \\approx 0$ 时的 $D(a) \\approx 0$ 开始。*首次*壳层穿越对应于满足该条件的最小尺度因子 $a$。这又对应于发生奇异时 $D(a)$ 的最小正值。我们必须找到 $D(a)$ 可能取值中的最小值：\n$$\nD(a_{\\rm sc}) = \\min \\left\\{ -\\frac{1}{\\lambda_1}, -\\frac{1}{\\lambda_2}, -\\frac{1}{\\lambda_3} \\right\\}\n$$\n根据排序 $\\lambda_1 \\le \\lambda_2 \\le \\lambda_3  0$，我们有：\n$$\n-\\lambda_1 \\ge -\\lambda_2 \\ge -\\lambda_3  0\n$$\n对这些正数取倒数会反转不等号：\n$$\n\\frac{1}{-\\lambda_1} \\le \\frac{1}{-\\lambda_2} \\le \\frac{1}{-\\lambda_3}\n$$\n这等价于：\n$$\n-\\frac{1}{\\lambda_1} \\le -\\frac{1}{\\lambda_2} \\le -\\frac{1}{\\lambda_3}\n$$\n因此最小值为 $-1/\\lambda_1$。首次壳层穿越发生在增长因子达到这个值时：\n$$\nD(a_{\\rm sc}) = -\\frac{1}{\\lambda_1}\n$$\n这在物理上对应于沿着最负本征值（最快压缩的主轴）方向的塌缩。\n\n最后，我们使用 Einstein-de Sitter (EdS) 宇宙中增长因子的具体形式。问题指出 $D(a) \\propto a$ 且被归一化以使得 $D(1)=1$。设 $D(a) = C \\cdot a$，其中 $C$ 为某个常数。归一化条件给出 $D(1) = C \\cdot 1 = 1$，所以 $C=1$。因此，对于 EdS 宇宙，增长因子就是 $D(a) = a$。\n\n将此代入我们关于首次焦散的条件中，得到：\n$$\na_{\\rm sc} = -\\frac{1}{\\lambda_1}\n$$\n这就是首次壳层穿越事件发生时的尺度因子。",
            "answer": "$$\\boxed{-\\frac{1}{\\lambda_1}}$$"
        },
        {
            "introduction": "将理论转化为计算机模拟需要仔细考虑数值方法，因为其精度会深刻影响物理结果。本练习深入探讨了这一关键方面，通过比较有限差分法和谱方法在计算位移场梯度时的性能。理解这些差异对于准确预测壳层穿越时间以及构建稳健的宇宙学模拟至关重要。",
            "id": "3500950",
            "problem": "考虑在空间周期性域中，冷暗物质的一维Zel'dovich近似。拉格朗日坐标用 $q$ 表示，欧拉坐标用 $x$ 表示，线性增长因子用 $D$ 表示。Zel'dovich映射由基本关系 $x(q, D) = q + D \\, s(q)$ 给出，其中 $s(q)$ 是一个周期为 $L$ 的可微周期性位移场。共动密度遵循质量守恒定律，该映射的一维雅可比式为 $J(q, D) = \\partial x / \\partial q = 1 + D \\, s'(q)$。在此近似下，首次壳层穿越（即首次出现多流现象）发生在满足至少一个 $q$ 使得 $J(q, D) = 0$ 的最早正值 $D$ 处。等效地，如果 $m_{\\min} = \\min_q s'(q)$，且 $m_{\\min}  0$，那么最早的坍缩因子为 $D_{\\mathrm{c}} = - 1 / m_{\\min}$。\n\n你需要构建一个完整的程序，比较离散网格上 $s'(q)$ 的两种数值梯度估计器，并量化它们对预测的 $D_{\\mathrm{c}}$ 的影响：\n- 一个在间距为 $\\Delta q$ 的均匀周期性网格上的二阶中心有限差分估计器，\n- 一个使用通过快速傅里叶变换（FFT）实现的离散傅里叶变换（DFT）的谱方法估计器（快速傅里叶变换（FFT），离散傅里叶变换（DFT）），其导数通过在傅里叶空间中将模系数乘以 $\\mathrm{i} k$ 并变换回位形空间来计算。\n\n使用一个长度为 $L = 2\\pi$ 的严格一维周期性域，并将 $s(q)$ 构建为正弦模的有限和，\n$$\ns(q) = \\sum_{j=1}^{M} A_j \\, \\sin\\!\\big(m_j \\, q + \\phi_j\\big),\n$$\n其中 $m_j$ 是整数模数，$A_j$ 是实数振幅，$\\phi_j$ 是实数相位。假设在 $[0, L)$ 上具有周期性边界条件，并且所有 $m_j$ 都满足离散采样约束 $m_j  N/2$，其中 $N$ 是网格点数。\n\n你的程序必须实现以下步骤：\n1. 对于给定的参数集 $\\{N, \\{(m_j, A_j, \\phi_j)\\}_{j=1}^{M}\\}$, 构建一个均匀网格 $q_n = n \\, \\Delta q$（其中 $n = 0, 1, \\dots, N-1$ 且 $\\Delta q = L/N$），计算 $s(q_n)$，并在网格点上计算 $s'(q)$ 的两种数值近似：\n   - 有限差分：$s'_{\\mathrm{FD}}(q_n) \\approx \\big(s(q_{n+1}) - s(q_{n-1})\\big) / \\big(2 \\Delta q\\big)$，使用周期性索引。\n   - 谱方法：计算离散傅里叶变换（DFT）$\\hat{s}_k$，乘以 $\\mathrm{i} k$（其中 $k = 2\\pi \\, \\nu$，$\\nu$ 是与间距 $\\Delta q$ 一致的傅里叶频率），然后进行逆 DFT 得到 $s'_{\\mathrm{SP}}(q_n)$。\n2. 计算数值壳层穿越预测值 $D_{\\mathrm{c,FD}} = -1 / \\min_n s'_{\\mathrm{FD}}(q_n)$ 和 $D_{\\mathrm{c,SP}} = -1 / \\min_n s'_{\\mathrm{SP}}(q_n)$，前提是各自的最小值严格为负。\n3. 通过在一个大小为 $N_{\\mathrm{ref}} = 16384$ 的密集网格上计算精确导数\n$$\ns'(q) = \\sum_{j=1}^{M} A_j \\, m_j \\, \\cos\\!\\big(m_j \\, q + \\phi_j\\big)\n$$\n来计算一个高精度参考估计值 $D_{\\mathrm{c,ref}}$，该网格覆盖 $[0, L)$，如果最小值严格为负，则取 $D_{\\mathrm{c,ref}} = -1 / \\min s'(q)$。\n4. 对于每组参数，输出两个误差度量：\n   - 有限差分预测的相对误差，$E_{\\mathrm{FD}} = \\big|D_{\\mathrm{c,FD}} - D_{\\mathrm{c,ref}}\\big| / D_{\\mathrm{c,ref}}$。\n   - 谱方法预测的相对误差，$E_{\\mathrm{SP}} = \\big|D_{\\mathrm{c,SP}} - D_{\\mathrm{c,ref}}\\big| / D_{\\mathrm{c,ref}}$。\n如果任何方法得到的 $s'(q)$ 的最小值为非负数（因此没有预测到壳层穿越），则将相应的误差定义为浮点数 $\\mathrm{nan}$。\n\n所有量都是无量纲的。相位的角度单位为弧度。\n\n测试套件。你的程序必须运行以下参数集：\n- 情况 1（单模，中等分辨率）：$N = 128$, $M = 1$, $(m_1, A_1, \\phi_1) = (4, 0.2, 0.3)$。\n- 情况 2（接近紫外端的单模，较粗分辨率）：$N = 64$, $M = 1$, $(m_1, A_1, \\phi_1) = (20, 0.1, -0.5)$。\n- 情况 3（双模组合，中等分辨率）：$N = 96$, $M = 2$, $(m_1, A_1, \\phi_1) = (3, 0.15, 0.1)$ 和 $(m_2, A_2, \\phi_2) = (7, 0.1, -1.0)$。\n- 情况 4（单模，小振幅，较高分辨率）：$N = 128$, $M = 1$, $(m_1, A_1, \\phi_1) = (10, 0.01, 1.2)$。\n\n最终输出格式。你的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序如下\n$$\n[E_{\\mathrm{FD}}^{(1)}, E_{\\mathrm{SP}}^{(1)}, E_{\\mathrm{FD}}^{(2)}, E_{\\mathrm{SP}}^{(2)}, E_{\\mathrm{FD}}^{(3)}, E_{\\mathrm{SP}}^{(3)}, E_{\\mathrm{FD}}^{(4)}, E_{\\mathrm{SP}}^{(4)}],\n$$\n其中上标表示测试用例的索引。每个浮点数必须以科学记数法打印，并有 $8$ 位有效数字（例如，$1.2345678\\mathrm{e}{-4}$）。不应打印其他任何文本。所有计算必须由你的程序如上所述以数值方式完成；不允许外部输入。",
            "solution": "所提出的问题是有效的。它在科学上基于宇宙结构形成的原理，特别是Zel'dovich近似，并提出了一个定义明确的数值任务，即比较两种计算空间导数的标准方法（有限差分和谱方法）的准确性。所有必要的参数、公式和评估标准都已提供，构成了一个自洽且可解的问题。\n\n求解过程首先根据物理和数值规定构建位移场及其导数，然后计算坍缩时间，最后为每个测试用例评估指定的误差度量。\n\n问题的核心在于Zel'dovich近似，它描述了膨胀宇宙中粒子轨迹的初始演化。在由线性增长因子 $D$ 指定的时间，粒子的位置 $x$ 由其初始（拉格朗日）位置 $q$ 加上一个位移给出。该映射为 $x(q, D) = q + D \\, s(q)$，其中 $s(q)$ 是位移场。在一个长度为 $L$ 的一维周期性域中，我们给定 $s(q)$ 的具体形式为正弦模的和：\n$$\ns(q) = \\sum_{j=1}^{M} A_j \\, \\sin(m_j \\, q + \\phi_j)\n$$\n这里，$A_j$ 是振幅，$m_j$ 是适用于长度为 $L=2\\pi$ 的域的整数波数，$\\phi_j$ 是相移。\n\n第一个引力坍缩结构（称为壳层穿越或焦散）的形成，发生在具有不同初始位置的粒子相互追赶时。在数学上，这对应于从 $q$到 $x$ 的映射的雅可比式变为零。雅可比式为 $J(q, D) = \\frac{\\partial x}{\\partial q} = 1 + D \\, s'(q)$。令 $J(q,D)=0$ 得到 $D = -1/s'(q)$。首次壳层穿越发生在满足此条件的最小正值 $D$ 处。这对应于 $s'(q)$ 最负的位置 $q$。如果我们定义 $m_{\\min} = \\min_q s'(q)$，则坍缩的临界增长因子为 $D_{\\mathrm{c}} = -1/m_{\\min}$，前提是 $m_{\\min}  0$。任务是使用对 $s'(q)$ 的不同数值估计来计算 $D_{\\mathrm{c}}$，并比较它们的准确性。\n\n位移场的解析导数是精确已知的：\n$$\ns'(q) = \\frac{d s}{d q} = \\sum_{j=1}^{M} A_j \\, m_j \\, \\cos(m_j \\, q + \\phi_j)\n$$\n此表达式用于生成高精度的参考值 $D_{\\mathrm{c,ref}}$。\n\n我们在一个均匀的离散网格 $q_n = n \\Delta q$（其中 $n = 0, 1, \\dots, N-1$，网格间距 $\\Delta q = L/N = 2\\pi/N$）上计算这些场。\n\n第一种数值方法是二阶中心有限差分格式。导数 $s'(q_n)$ 近似为：\n$$\ns'_{\\mathrm{FD}}(q_n) = \\frac{s(q_{n+1}) - s(q_{n-1})}{2 \\Delta q}\n$$\n索引是周期性处理的，即 $q_{N} \\equiv q_0$ 和 $q_{-1} \\equiv q_{N-1}$。这种方法是局部的，其截断误差随网格间距的变化尺度为 $\\mathcal{O}((\\Delta q)^2)$。对于相对于网格间距具有高频内容的函数，其精度预计会下降。\n\n第二种数值方法是谱方法或伪谱方法，它利用快速傅里叶变换（FFT）。其过程如下：\n1.  计算采样场 $s(q_n)$ 的离散傅里叶变换（DFT）以获得其在傅里叶空间中的系数 $\\hat{s}_k$。\n$$\n\\hat{s}_k = \\sum_{n=0}^{N-1} s(q_n) e^{-2\\pi i k n / N}\n$$\n2.  傅里叶变换的微分定理指出，实空间中的微分等价于傅里叶空间中乘以 $\\mathrm{i}k_{\\nu}$，其中 $k_{\\nu}$ 是角波数。对于我们的网格，离散角波数由 $k_{\\nu} = 2\\pi \\nu$ 给出，其中 $\\nu$ 是来自 `scipy.fft.fftfreq(N, d=dq)` 的空间频率。这将产生离散整数波数 $k \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$（对于偶数 $N$）。\n3.  导数的傅里叶系数 $\\widehat{s'}_k$ 通过以下方式计算：\n$$\n\\widehat{s'}_k = \\mathrm{i} k_{\\nu} \\hat{s}_k\n$$\n4.  通过对 $\\widehat{s'}_k$ 应用逆 DFT，可以恢复实空间中的导数 $s'_{\\mathrm{SP}}(q_n)$。\n$$\ns'_{\\mathrm{SP}}(q_n) = \\frac{1}{N} \\sum_{k=0}^{N-1} \\widehat{s'}_k e^{2\\pi i k n / N}\n$$\n对于由有限数量的正弦模组成的函数，只要其波数 $m_j$ 都小于网格的奈奎斯特频率（即 $|m_j|  N/2$），如此问题陈述所保证，这种谱方法就能计算出达到机器精度的导数。它在网格点上实际上是精确的。\n\n对于每种方法（FD、SP）和参考计算（REF），找到相应导数的最小值 $m_{\\min}$。如果 $m_{\\min}  0$，坍缩因子计算为 $D_{\\mathrm{c}} = -1/m_{\\min}$。如果 $m_{\\min} \\ge 0$，则该方法没有预测到坍缩，问题规定结果应为 `nan`。\n\n最后，计算有限差分和谱方法预测的相对误差 $E_{\\mathrm{FD}}$ 和 $E_{\\mathrm{SP}}$，相对于高精度参考值 $D_{\\mathrm{c,ref}}$：\n$$\nE_{\\mathrm{FD}} = \\frac{|D_{\\mathrm{c,FD}} - D_{\\mathrm{c,ref}}|}{D_{\\mathrm{c,ref}}} \\quad \\text{和} \\quad E_{\\mathrm{SP}} = \\frac{|D_{\\mathrm{c,SP}} - D_{\\mathrm{c,ref}}|}{D_{\\mathrm{c,ref}}}\n$$\n如果任何方法产生非物理的（非负）最小导数值，相应的误差定义为 `nan`。\n\n每个测试用例的总体算法是：\n1.  定义参数 $N$ 和模式集 $\\{(m_j, A_j, \\phi_j)\\}$。\n2.  构建网格 $q_n$ 并计算位移场 $s(q_n)$。\n3.  使用周期性中心差分计算 $s'_{\\mathrm{FD}}(q_n)$。\n4.  使用基于 FFT 的谱方法计算 $s'_{\\mathrm{SP}}(q_n)$。\n5.  构建高分辨率网格 $q_{\\mathrm{ref}}$ 并计算精确的解析导数 $s'(q_{\\mathrm{ref}})$。\n6.  找到每个导数数组的最小值。\n7.  计算 $D_{\\mathrm{c,FD}}$, $D_{\\mathrm{c,SP}}$, 和 $D_{\\mathrm{c,ref}}$。\n8.  计算并返回相对误差 $E_{\\mathrm{FD}}$ 和 $E_{\\mathrm{SP}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef compute_errors(N, modes, L=2.0 * np.pi, N_ref=16384):\n    \"\"\"\n    Computes numerical derivatives and their errors for a given parameter set.\n    \n    Args:\n        N (int): Number of grid points.\n        modes (list of tuples): List of mode parameters (m_j, A_j, phi_j).\n        L (float): Length of the periodic domain.\n        N_ref (int): Number of grid points for the reference calculation.\n        \n    Returns:\n        tuple: A pair of floats (E_fd, E_sp) representing the relative errors.\n    \"\"\"\n    # 1. Construct the grid and evaluate s(q)\n    dq = L / N\n    q = np.arange(N) * dq\n    \n    s_q = np.zeros(N)\n    for m, A, phi in modes:\n        s_q += A * np.sin(m * q + phi)\n\n    # 2. Compute finite-difference derivative\n    s_plus_1 = np.roll(s_q, -1)\n    s_minus_1 = np.roll(s_q, 1)\n    s_prime_fd = (s_plus_1 - s_minus_1) / (2.0 * dq)\n\n    # 3. Compute spectral derivative\n    s_hat = fft.fft(s_q)\n    # Wavenumbers for a domain of length L\n    k_nu = fft.fftfreq(N, d=dq) * 2.0 * np.pi\n    s_prime_hat = 1j * k_nu * s_hat\n    s_prime_sp = fft.ifft(s_prime_hat).real\n\n    # 4. Compute high-accuracy reference derivative\n    dq_ref = L / N_ref\n    q_ref = np.arange(N_ref) * dq_ref\n    \n    s_prime_ref_analytic = np.zeros(N_ref)\n    for m, A, phi in modes:\n        s_prime_ref_analytic += A * m * np.cos(m * q_ref + phi)\n\n    # 5. Compute the minimum of each derivative\n    min_s_prime_fd = np.min(s_prime_fd)\n    min_s_prime_sp = np.min(s_prime_sp)\n    min_s_prime_ref = np.min(s_prime_ref_analytic)\n\n    # 6. Compute collapse factors D_c\n    Dc_fd = -1.0 / min_s_prime_fd if min_s_prime_fd  0 else np.nan\n    Dc_sp = -1.0 / min_s_prime_sp if min_s_prime_sp  0 else np.nan\n    Dc_ref = -1.0 / min_s_prime_ref if min_s_prime_ref  0 else np.nan\n    \n    # 7. Compute relative errors\n    # np.nan propagates correctly through these arithmetic operations\n    E_fd = np.abs(Dc_fd - Dc_ref) / Dc_ref\n    E_sp = np.abs(Dc_sp - Dc_ref) / Dc_ref\n    \n    return E_fd, E_sp\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 128, 'modes': [(4, 0.2, 0.3)]},  # Case 1\n        {'N': 64,  'modes': [(20, 0.1, -0.5)]}, # Case 2\n        {'N': 96,  'modes': [(3, 0.15, 0.1), (7, 0.1, -1.0)]}, # Case 3\n        {'N': 128, 'modes': [(10, 0.01, 1.2)]}, # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        modes = case['modes']\n        \n        # Ensure modes satisfy the Nyquist criterion\n        for m, _, _ in modes:\n            if not m  N / 2:\n                raise ValueError(f\"Mode m={m} violates Nyquist criterion for N={N}\")\n\n        E_fd, E_sp = compute_errors(N, modes)\n        results.extend([E_fd, E_sp])\n\n    # Final print statement in the exact required format.\n    # The format specifier \"{:.7e}\" yields 8 significant digits (1 before decimal, 7 after).\n    formatted_results = [f\"{r:.8e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}