{
    "hands_on_practices": [
        {
            "introduction": "Before estimating cosmological statistics, we must first master the discrete Fourier space imposed by a finite simulation box and grid. This exercise grounds the abstract concepts of Fourier analysis in a concrete numerical setting . By calculating the fundamental frequency $k_f$ and Nyquist frequency $k_{\\mathrm{Ny}}$, and then explicitly counting the number of independent modes within a spherical shell, you will build a foundational understanding of how continuous theoretical predictions are connected to discrete numerical data.",
            "id": "3481934",
            "problem": "Consider a statistically homogeneous scalar field sampled on a discrete uniform grid of size $N^3$ inside a periodic cubic box of side length $L$. The discrete Fourier transform is taken over this box, so the allowed wavevectors are those compatible with the periodic boundary conditions. For a grid that will be used to estimate the power spectrum, assume the input field is real-valued, and therefore the Fourier transform exhibits Hermitian symmetry. The binning for the spherically averaged power spectrum uses spherical shells in wavevector space.\n\nStarting from first principles of sampling a continuous field onto a discrete lattice and the definition of the discrete Fourier representation in a periodic domain, determine the highest resolvable wavenumber (the Nyquist frequency) $k_{\\mathrm{Ny}}$ for the one-dimensional axis of the grid. Then, for the purpose of power spectrum estimation from a real field, adopt the standard convention of counting only independent Fourier modes by selecting a half of the three-dimensional wavevector lattice using the lexicographic rule: include modes with $m_{z} > 0$, or $m_{z} = 0$ and $m_{y} > 0$, or $m_{z} = 0$, $m_{y} = 0$, and $m_x \\geq 0$, where $\\boldsymbol{m} = (m_{x}, m_{y}, m_{z})$ are the integer indices of the discrete wavevectors.\n\nWork with the specific parameters $N = 16$ and $L = 2\\pi$ so that the fundamental frequency is $k_{f} = 2\\pi/L$. Consider the spherical shell in wavevector magnitude centered at $k = \\sqrt{5}\\,k_{f}$ with width $\\Delta k = 0.1\\,k_{f}$, and enumerate the set of integer index triples $\\boldsymbol{m}$ whose wavevector magnitudes fall inside this shell. Using the independent-mode counting convention above, return the total number of independent modes $N_{\\mathrm{modes}}$ within this shell.\n\nExpress $k_{\\mathrm{Ny}}$ in units of the fundamental frequency $k_{f}$, and provide $N_{\\mathrm{modes}}$ as a dimensionless integer. The final answer must be presented as a two-entry row matrix containing $k_{\\mathrm{Ny}}/k_{f}$ and $N_{\\mathrm{modes}}$.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It is a standard exercise in numerical cosmology involving the analysis of discrete Fourier modes on a grid. All necessary information is provided.\n\nThe problem asks for two quantities: the Nyquist frequency $k_{\\mathrm{Ny}}$ in units of the fundamental frequency $k_f$, and the number of independent Fourier modes $N_{\\mathrm{modes}}$ within a specified spherical shell in wavevector space.\n\nFirst, we determine the Nyquist frequency. A discrete uniform grid of size $N^3$ in a cubic box of side length $L$ has a grid spacing of $\\Delta x = L/N$. According to the Nyquist-Shannon sampling theorem, the shortest wavelength that can be represented on this grid is twice the grid spacing, $\\lambda_{\\mathrm{min}} = 2\\Delta x$. The Nyquist frequency is the wavenumber corresponding to this minimum wavelength:\n$$k_{\\mathrm{Ny}} = \\frac{2\\pi}{\\lambda_{\\mathrm{min}}} = \\frac{2\\pi}{2\\Delta x} = \\frac{\\pi}{\\Delta x}$$\nSubstituting $\\Delta x = L/N$, we get:\n$$k_{\\mathrm{Ny}} = \\frac{\\pi N}{L}$$\nThe fundamental frequency (wavenumber) $k_f$ for a periodic box of side $L$ is determined by the largest possible wavelength, which is $L$. Thus:\n$$k_f = \\frac{2\\pi}{L}$$\nThe ratio of the Nyquist frequency to the fundamental frequency is:\n$$\\frac{k_{\\mathrm{Ny}}}{k_f} = \\frac{\\pi N / L}{2\\pi / L} = \\frac{N}{2}$$\nGiven the grid size parameter $N=16$, this ratio is:\n$$\\frac{k_{\\mathrm{Ny}}}{k_f} = \\frac{16}{2} = 8$$\n\nNext, we count the number of independent modes, $N_{\\mathrm{modes}}$, in the specified shell. The allowed wavevectors $\\boldsymbol{k}$ in a periodic cubic box are given by:\n$$\\boldsymbol{k} = \\frac{2\\pi}{L} \\boldsymbol{m} = k_f \\boldsymbol{m}$$\nwhere $\\boldsymbol{m} = (m_x, m_y, m_z)$ is a vector of integer indices. For the specific parameters $L = 2\\pi$, the fundamental frequency is:\n$$k_f = \\frac{2\\pi}{2\\pi} = 1$$\nThis simplifies the wavevector to $\\boldsymbol{k} = \\boldsymbol{m}$. The magnitude of the wavevector is therefore $|\\boldsymbol{k}| = \\sqrt{m_x^2 + m_y^2 + m_z^2}$. The integer indices $m_i$ for each dimension are limited by the grid resolution. The wavenumbers for a discrete grid are typically considered in the range $[-k_{\\mathrm{Ny}}, k_{\\mathrm{Ny}}]$. In terms of integer indices, this corresponds to $|m_i k_f| \\le k_{\\mathrm{Ny}}$, which means $|m_i| \\le k_{\\mathrm{Ny}}/k_f = N/2$. For $N=16$, the indices must satisfy $|m_i| \\le 8$.\n\nThe problem specifies a spherical shell centered at $k = \\sqrt{5}\\,k_f$ with a width of $\\Delta k = 0.1\\,k_f$. With $k_f=1$, the shell is centered at $k=\\sqrt{5}$ with width $\\Delta k = 0.1$. The wavenumbers inside this shell satisfy the inequality:\n$$\\sqrt{5} - \\frac{0.1}{2} \\le |\\boldsymbol{k}| \\le \\sqrt{5} + \\frac{0.1}{2}$$\n$$ \\sqrt{5} - 0.05 \\le \\sqrt{m_x^2 + m_y^2 + m_z^2} \\le \\sqrt{5} + 0.05 $$\nSquaring the terms to work with the sum of squares gives:\n$$ (\\sqrt{5} - 0.05)^2 \\le m_x^2 + m_y^2 + m_z^2 \\le (\\sqrt{5} + 0.05)^2 $$\nNumerically evaluating the bounds:\n$$ (2.2360679... - 0.05)^2 \\le m_x^2 + m_y^2 + m_z^2 \\le (2.2360679... + 0.05)^2 $$\n$$ (2.1860679...)^2 \\le m_x^2 + m_y^2 + m_z^2 \\le (2.2860679...)^2 $$\n$$ 4.77887... \\le m_x^2 + m_y^2 + m_z^2 \\le 5.22607... $$\nSince $m_x$, $m_y$, and $m_z$ are integers, their sum of squares must also be an integer. The only integer within the interval $[4.77887..., 5.22607...]$ is $5$. Therefore, we must find all integer triples $(m_x, m_y, m_z)$ such that:\n$$ m_x^2 + m_y^2 + m_z^2 = 5 $$\nThe only way to write $5$ as a sum of three integer squares is $5 = 2^2 + 1^2 + 0^2$. Thus, the absolute values of the components $(|m_x|, |m_y|, |m_z|)$ must be a permutation of $(2, 1, 0)$. All indices satisfy $|m_i| \\le 2$, which is well within the required range $|m_i| \\le 8$.\n\nWe now list all possible integer triples $\\boldsymbol{m}$ and apply the given lexicographic rule for counting independent modes. The rule is to include a mode $\\boldsymbol{m}$ if:\n1. $m_z > 0$, or\n2. $m_z = 0$ and $m_y > 0$, or\n3. $m_z = 0$, $m_y = 0$, and $m_x \\geq 0$.\n\nLet us count the modes satisfying these conditions.\n\nCondition 1: $m_z > 0$.\nThe triples must have $m_z^2+m_y^2+m_x^2=5$.\nIf $m_z = 1$, then $m_x^2 + m_y^2 = 4$. Solutions are permutations of $(\\pm 2, 0)$.\nThe modes are $(2, 0, 1)$, $(-2, 0, 1)$, $(0, 2, 1)$, $(0, -2, 1)$. This gives $4$ modes.\nIf $m_z = 2$, then $m_x^2 + m_y^2 = 1$. Solutions are permutations of $(\\pm 1, 0)$.\nThe modes are $(1, 0, 2)$, $(-1, 0, 2)$, $(0, 1, 2)$, $(0, -1, 2)$. This gives $4$ modes.\nTotal modes from Condition 1: $4 + 4 = 8$.\n\nCondition 2: $m_z = 0$ and $m_y > 0$.\nIf $m_z = 0$, then $m_x^2 + m_y^2 = 5$. The integer solutions for $(|m_x|,|m_y|)$ are permutations of $(2, 1)$.\nWe need $m_y > 0$, so $m_y$ can be $1$ or $2$.\nIf $m_y = 1$, then $m_x^2 = 4$, so $m_x = \\pm 2$. This gives modes $(2, 1, 0)$ and $(-2, 1, 0)$.\nIf $m_y = 2$, then $m_x^2 = 1$, so $m_x = \\pm 1$. This gives modes $(1, 2, 0)$ and $(-1, 2, 0)$.\nTotal modes from Condition 2: $2 + 2 = 4$.\n\nCondition 3: $m_z = 0$, $m_y = 0$, and $m_x \\geq 0$.\nIf $m_z=0$ and $m_y=0$, then $m_x^2=5$. This equation has no integer solutions for $m_x$.\nTotal modes from Condition 3: $0$.\n\nThe total number of independent modes, $N_{\\mathrm{modes}}$, is the sum of the counts from these three mutually exclusive conditions:\n$$ N_{\\mathrm{modes}} = 8 + 4 + 0 = 12 $$\n\nThe final answer consists of $k_{\\mathrm{Ny}}/k_f$ and $N_{\\mathrm{modes}}$.\n$k_{\\mathrm{Ny}}/k_f = 8$.\n$N_{\\mathrm{modes}} = 12$.\nThe result is to be presented as a two-entry row matrix.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n8 & 12\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Cosmological density fields are typically traced by discrete objects like galaxies or dark matter halos, not a perfectly continuous fluid. This inherent discreteness introduces a \"shot noise\" term that contaminates the measurement of clustering statistics and must be accurately subtracted. This practice guides you through the first-principles derivation and implementation of shot noise corrections for both the power spectrum and bispectrum, accounting for the common practice of applying weights to the tracers .",
            "id": "3481941",
            "problem": "Consider a discrete, weighted set of objects located at positions $\\{\\mathbf{x}_i\\}_{i=1}^N$ with strictly nonnegative scalar weights $\\{w_i\\}_{i=1}^N$. Define the weighted number density field as $n_w(\\mathbf{x})=\\sum_{i=1}^{N} w_i \\,\\delta_{\\mathrm{D}}(\\mathbf{x}-\\mathbf{x}_i)$, where $\\delta_{\\mathrm{D}}$ denotes the Dirac delta function. Let $S_1=\\sum_{i=1}^{N} w_i$ be the total weight and consider the normalized weighted field $f(\\mathbf{x})=n_w(\\mathbf{x})/S_1$. For wavevectors $\\mathbf{k}$, define the Fourier transform $f(\\mathbf{k})=\\int d^3\\mathbf{x}\\, f(\\mathbf{x}) e^{-i\\mathbf{k}\\cdot\\mathbf{x}}$ and the corresponding estimators for the power spectrum and bispectrum at nonzero wavevectors: $P(\\mathbf{k})=\\langle f(\\mathbf{k}) f(-\\mathbf{k}) \\rangle$ and $B(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)=\\langle f(\\mathbf{k}_1) f(\\mathbf{k}_2) f(\\mathbf{k}_3) \\rangle$ subject to the closure condition $\\mathbf{k}_1+\\mathbf{k}_2+\\mathbf{k}_3=\\mathbf{0}$.\n\nStarting from the definition of $f(\\mathbf{k})$ and assuming a statistically homogeneous Poisson point process for the sampling of the discrete field with arbitrary but fixed nonnegative weights $\\{w_i\\}$, derive from first principles the effective shot noise contributions to the power spectrum and bispectrum estimators. Your derivation must identify the index-contraction terms responsible for the shot noise and express the shot noise in terms of the sums $S_r=\\sum_{i=1}^N w_i^r$ for $r=1,2,3$, together with the underlying clustering contributions. Then, implement a program that, given a list of weights and a triplet of underlying power spectrum values $(P(k_1),P(k_2),P(k_3))$ for a closed triangle of wavevectors, computes:\n- the effective shot noise for the power spectrum, denoted $P_{\\mathrm{shot}}$, and\n- the bispectrum shot noise broken into the two-index contraction term, denoted $B_{\\mathrm{shot},2}$, and the three-index contraction term, denoted $B_{\\mathrm{shot},3}$, as well as their sum $B_{\\mathrm{shot}}=B_{\\mathrm{shot},2}+B_{\\mathrm{shot},3}$.\n\nAll quantities are to be treated as dimensionless scalars; no physical units or angles are required.\n\nYour program must evaluate the following test suite of parameter sets, each specified by a tuple consisting of a weight list and a triplet of power spectrum values $(P(k_1),P(k_2),P(k_3))$:\n1. Weights $[1.0,0.5,2.0,1.5]$, Powers $(10.0,12.0,8.0)$.\n2. Weights $[3.0]$, Powers $(5.0,5.0,5.0)$.\n3. Weights consisting of one hundred entries equal to $1.0$, Powers $(0.2,0.3,0.4)$.\n4. Weights $[0.0,0.0,1.0,4.0,0.0,2.0]$, Powers $(1.0,2.0,3.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a comma-separated list enclosed in square brackets in the order $[P_{\\mathrm{shot}},B_{\\mathrm{shot},2},B_{\\mathrm{shot},3},B_{\\mathrm{shot}}]$. For example, the output format must be of the form $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],\\ldots]$ with no spaces.",
            "solution": "The user has requested a derivation of the shot noise contributions to the power spectrum and bispectrum for a weighted Poisson point process, followed by a computational implementation.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- A discrete, weighted set of $N$ objects at positions $\\{\\mathbf{x}_i\\}_{i=1}^{N}$.\n- Strictly nonnegative scalar weights $\\{w_i\\}_{i=1}^{N}$.\n- Weighted number density field: $n_w(\\mathbf{x})=\\sum_{i=1}^{N} w_i \\,\\delta_{\\mathrm{D}}(\\mathbf{x}-\\mathbf{x}_i)$.\n- Total weight: $S_1=\\sum_{i=1}^{N} w_i$.\n- Normalized weighted field: $f(\\mathbf{x})=n_w(\\mathbf{x})/S_1$.\n- Fourier transform: $f(\\mathbf{k})=\\int d^3\\mathbf{x}\\, f(\\mathbf{x}) e^{-i\\mathbf{k}\\cdot\\mathbf{x}}$.\n- Power spectrum estimator: $P(\\mathbf{k}) = \\langle f(\\mathbf{k}) f(-\\mathbf{k}) \\rangle$ for $\\mathbf{k} \\neq \\mathbf{0}$.\n- Bispectrum estimator: $B(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)=\\langle f(\\mathbf{k}_1) f(\\mathbf{k}_2) f(\\mathbf{k}_3) \\rangle$ for nonzero wavevectors with closure $\\mathbf{k}_1+\\mathbf{k}_2+\\mathbf{k}_3=\\mathbf{0}$.\n- Assumption: Statistically homogeneous Poisson point process for the sampling of positions $\\{\\mathbf{x}_i\\}$.\n- Task: Derive effective shot noise contributions to the power spectrum and bispectrum from first principles, expressing them in terms of $S_r=\\sum_{i=1}^{N} w_i^r$ for $r=1,2,3$, and the underlying clustering power spectrum $P(k)$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is a standard, well-defined exercise in theoretical cosmology and large-scale structure statistics.\n- **Scientifically Grounded:** The problem is based on fundamental principles of statistical field theory as applied to cosmological density fields. The concepts of power spectrum, bispectrum, and shot noise are central to the field.\n- **Well-Posed:** The problem provides all necessary definitions and assumptions to derive a unique solution. The quantities to be calculated are clearly defined.\n- **Objective:** The problem is stated in precise mathematical and physical language, free of ambiguity or subjective claims.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n### First-Principles Derivation\n\nThe derivation begins with the Fourier transform of the normalized weighted field, $f(\\mathbf{x})$. Substituting the definition of $f(\\mathbf{x})$ into the Fourier integral gives:\n$$\nf(\\mathbf{k}) = \\int d^3\\mathbf{x} \\frac{1}{S_1} \\left(\\sum_{i=1}^{N} w_i \\delta_{\\mathrm{D}}(\\mathbf{x}-\\mathbf{x}_i)\\right) e^{-i\\mathbf{k}\\cdot\\mathbf{x}} = \\frac{1}{S_1} \\sum_{i=1}^{N} w_i e^{-i\\mathbf{k}\\cdot\\mathbf{x}_i}\n$$\nThis expression is the discrete Fourier transform for the weighted point set, which forms the basis for the estimators. The expectation value $\\langle \\cdot \\rangle$ denotes an ensemble average over many realizations of the Poisson point process. The key property of a Poisson process is that the positions of the objects are uncorrelated.\n\n**Power Spectrum Shot Noise**\nThe power spectrum estimator is defined as $P(\\mathbf{k}) = \\langle f(\\mathbf{k}) f(-\\mathbf{k}) \\rangle$. Substituting the expression for $f(\\mathbf{k})$:\n$$\nP(\\mathbf{k}) = \\left\\langle \\left( \\frac{1}{S_1} \\sum_{i=1}^{N} w_i e^{-i\\mathbf{k}\\cdot\\mathbf{x}_i} \\right) \\left( \\frac{1}{S_1} \\sum_{j=1}^{N} w_j e^{i\\mathbf{k}\\cdot\\mathbf{x}_j} \\right) \\right\\rangle = \\frac{1}{S_1^2} \\left\\langle \\sum_{i,j=1}^{N} w_i w_j e^{-i\\mathbf{k}\\cdot(\\mathbf{x}_i - \\mathbf{x}_j)} \\right\\rangle\n$$\nThe sum over indices $i$ and $j$ can be split into two cases: terms where $i=j$ and terms where $i \\neq j$.\n$$\nP(\\mathbf{k}) = \\frac{1}{S_1^2} \\left\\langle \\sum_{i=j} w_i w_j e^{-i\\mathbf{k}\\cdot(\\mathbf{x}_i - \\mathbf{x}_j)} + \\sum_{i \\neq j} w_i w_j e^{-i\\mathbf{k}\\cdot(\\mathbf{x}_i - \\mathbf{x}_j)} \\right\\rangle\n$$\nThe first term, arising from the index contraction $i=j$, is the \"self-counting\" or shot noise term. Since $\\mathbf{x}_i - \\mathbf{x}_j = \\mathbf{0}$ for $i=j$, the exponential becomes $e^0 = 1$. This term is independent of the object positions and thus the ensemble average has no effect on it.\n$$\n\\text{Term for } i=j : \\quad \\frac{1}{S_1^2} \\sum_{i=1}^{N} w_i^2 = \\frac{S_2}{S_1^2}\n$$\nThis is the effective shot noise contribution to the power spectrum, $P_{\\mathrm{shot}}$. It is a constant offset, independent of the wavevector $\\mathbf{k}$.\n\nThe second term, for $i \\neq j$, represents the correlation between distinct objects. The ensemble average of this term yields the underlying clustering power spectrum, $P_{\\text{true}}(k)$, which depends on the magnitude $k=|\\mathbf{k}|$ for a statistically isotropic universe.\n$$\n\\text{Term for } i \\neq j : \\quad \\frac{1}{S_1^2} \\left\\langle \\sum_{i \\neq j} w_i w_j e^{-i\\mathbf{k}\\cdot(\\mathbf{x}_i - \\mathbf{x}_j)} \\right\\rangle = P_{\\text{true}}(k)\n$$\nThus, the total measured power spectrum is the sum of the true signal and the shot noise: $P(k) = P_{\\text{true}}(k) + P_{\\mathrm{shot}}$. The problem asks for the shot noise contribution itself.\n$$\nP_{\\mathrm{shot}} = \\frac{S_2}{S_1^2}\n$$\nwhere $S_r = \\sum_{i=1}^{N} w_i^r$.\n\n**Bispectrum Shot Noise**\nThe bispectrum estimator is $B(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)=\\langle f(\\mathbf{k}_1) f(\\mathbf{k}_2) f(\\mathbf{k}_3) \\rangle$ for a closed triangle of wavevectors $\\mathbf{k}_1+\\mathbf{k}_2+\\mathbf{k}_3=\\mathbf{0}$. We substitute the expression for $f(\\mathbf{k})$:\n$$\nB(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3) = \\frac{1}{S_1^3} \\left\\langle \\sum_{i,j,l=1}^{N} w_i w_j w_l e^{-i(\\mathbf{k}_1\\cdot\\mathbf{x}_i + \\mathbf{k}_2\\cdot\\mathbf{x}_j + \\mathbf{k}_3\\cdot\\mathbf{x}_l)} \\right\\rangle\n$$\nThe triple sum is decomposed based on index contractions.\n$1.$ **All indices distinct ($i \\neq j, j \\neq l, i \\neq l$):** This term corresponds to the intrinsic three-point correlation of the underlying density field, the true bispectrum $B_{\\text{true}}(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)$.\n\n$2.$ **Three indices equal ($i = j = l$):** This represents the three-index contraction term.\n$$\n\\text{Term for } i=j=l : \\quad \\frac{1}{S_1^3} \\left\\langle \\sum_{i=1}^{N} w_i^3 e^{-i(\\mathbf{k}_1+\\mathbf{k}_2+\\mathbf{k}_3)\\cdot\\mathbf{x}_i} \\right\\rangle\n$$\nDue to the closure condition $\\mathbf{k}_1+\\mathbf{k}_2+\\mathbf{k}_3=\\mathbf{0}$, the exponential becomes $e^0=1$. This term is constant and its ensemble average is trivial.\n$$\nB_{\\mathrm{shot},3} = \\frac{1}{S_1^3} \\sum_{i=1}^{N} w_i^3 = \\frac{S_3}{S_1^3}\n$$\n\n$3.$ **Two indices equal ($i=j \\neq l$, and its permutations):** This is the two-index contraction term. Let's consider the case $i=j \\neq l$:\n$$\n\\text{Term for } i=j \\neq l : \\quad \\frac{1}{S_1^3} \\left\\langle \\sum_{i \\neq l} w_i^2 w_l e^{-i(\\mathbf{k}_1+\\mathbf{k}_2)\\cdot\\mathbf{x}_i - i\\mathbf{k}_3\\cdot\\mathbf{x}_l} \\right\\rangle\n$$\nUsing the closure condition, $\\mathbf{k}_1+\\mathbf{k}_2 = -\\mathbf{k}_3$, this becomes:\n$$\n\\frac{1}{S_1^3} \\left\\langle \\sum_{i \\neq l} w_i^2 w_l e^{i\\mathbf{k}_3\\cdot(\\mathbf{x}_i - \\mathbf{x}_l)} \\right\\rangle\n$$\nThis expression is related to the cross-power spectrum between a field weighted by $w^2$ and a field weighted by $w$. Assuming the weights are independent of position (a consequence of the problem setup), this cross-spectrum is proportional to the underlying auto-power spectrum of the density field, $P_{\\text{true}}(k_3)$. The prefactor can be derived by matching terms, giving $\\frac{S_2 S_1}{S_1^3} P_{\\text{true}}(k_3) = \\frac{S_2}{S_1^2} P_{\\text{true}}(k_3)$. The problem provides the underlying power spectrum values, denoted $P(k)$. Therefore, this part of the shot noise is $\\frac{S_2}{S_1^2} P(k_3) = P_{\\mathrm{shot}} P(k_3)$.\nThe full two-index contraction term, $B_{\\mathrm{shot},2}$, is the sum of the three permutations ($i=j \\neq l$, $i=l \\neq j$, $j=l \\neq i$), leading to:\n$$\nB_{\\mathrm{shot},2} = \\frac{S_2}{S_1^2}P(k_1) + \\frac{S_2}{S_1^2}P(k_2) + \\frac{S_2}{S_1^2}P(k_3) = \\frac{S_2}{S_1^2} \\left[ P(k_1) + P(k_2) + P(k_3) \\right]\n$$\n\n**Summary of Formulas**\nThe shot noise components to be computed are:\n- Power Spectrum Shot Noise: $P_{\\mathrm{shot}} = \\frac{S_2}{S_1^2}$\n- Bispectrum Two-Index Shot Noise: $B_{\\mathrm{shot},2} = P_{\\mathrm{shot}} \\left( P(k_1) + P(k_2) + P(k_3) \\right)$\n- Bispectrum Three-Index Shot Noise: $B_{\\mathrm{shot},3} = \\frac{S_3}{S_1^3}$\n- Total Bispectrum Shot Noise: $B_{\\mathrm{shot}} = B_{\\mathrm{shot},2} + B_{\\mathrm{shot},3}$\n\nwhere $S_r = \\sum_{i=1}^{N} w_i^r$ for $r \\in \\{1, 2, 3\\}$. These formulae are now implemented.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating shot noise contributions for the power spectrum\n    and bispectrum for given sets of weights and underlying power spectrum values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General weights\n        ([1.0, 0.5, 2.0, 1.5], (10.0, 12.0, 8.0)),\n        # Case 2: Single object\n        ([3.0], (5.0, 5.0, 5.0)),\n        # Case 3: Uniform weights\n        ([1.0] * 100, (0.2, 0.3, 0.4)),\n        # Case 4: Weights including zeros\n        ([0.0, 0.0, 1.0, 4.0, 0.0, 2.0], (1.0, 2.0, 3.0)),\n    ]\n\n    all_results = []\n    for weights, powers in test_cases:\n        # Use numpy for efficient array operations.\n        # Ensure weights are float64 for precision.\n        w = np.array(weights, dtype=np.float64)\n\n        # Calculate the sums S_r = sum(w_i^r) for r=1, 2, 3.\n        S1 = np.sum(w)\n        \n        # Handle the edge case where all weights are zero.\n        # In this scenario, the field is identically zero, so all estimators\n        # and their shot noise contributions are zero.\n        if S1 == 0.0:\n            P_shot = 0.0\n            B_shot_2 = 0.0\n            B_shot_3 = 0.0\n            B_shot = 0.0\n        else:\n            S2 = np.sum(w**2)\n            S3 = np.sum(w**3)\n            \n            # Calculate the power spectrum shot noise term.\n            # P_shot = S2 / S1^2\n            P_shot = S2 / (S1**2)\n            \n            # Calculate the two-index contraction term for the bispectrum shot noise.\n            # B_shot,2 = P_shot * (P(k1) + P(k2) + P(k3))\n            P_sum = sum(powers)\n            B_shot_2 = P_shot * P_sum\n            \n            # Calculate the three-index contraction term for the bispectrum shot noise.\n            # B_shot,3 = S3 / S1^3\n            B_shot_3 = S3 / (S1**3)\n            \n            # Calculate the total bispectrum shot noise.\n            B_shot = B_shot_2 + B_shot_3\n        \n        # Store the results for the current test case.\n        all_results.append([P_shot, B_shot_2, B_shot_3, B_shot])\n\n    # Format the output string precisely as required, with no spaces.\n    # The output is a string representation of a list of lists.\n    output_parts = []\n    for res in all_results:\n        # Each inner list is formatted as \"[a,b,c,d]\"\n        output_parts.append(f\"[{','.join(map(str, res))}]\")\n    \n    # The final output is a concatenation of the inner lists,\n    # separated by commas, and enclosed in brackets.\n    final_output = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "While the universe is statistically isotropic on large scales, this symmetry is broken in observational data due to redshift-space distortions (RSD), where peculiar velocities alter the apparent positions of galaxies along the line of sight. This exercise introduces the standard method for analyzing this anisotropy: decomposing the power spectrum into multipole moments $P_\\ell(k)$ using a projection onto Legendre polynomials . You will implement a numerically precise estimator for these multipoles, developing a core skill for interpreting the rich information encoded in modern galaxy surveys.",
            "id": "3481959",
            "problem": "Consider a statistically homogeneous discrete field in redshift space with line of sight unit vector $\\hat{\\boldsymbol{n}}$ and Fourier modes $\\boldsymbol{k}$ sampled from a cubic periodic volume. The discrete Fourier amplitudes of the field are denoted by $\\delta_s(\\boldsymbol{k})$. The redshift-space power spectrum is anisotropic; it depends on the magnitude $k=\\lVert \\boldsymbol{k}\\rVert$ and on the cosine of the angle $\\mu=\\hat{\\boldsymbol{k}}\\cdot\\hat{\\boldsymbol{n}}$. The multipole expansion seeks coefficients $P_\\ell(k)$ such that the angular dependence of the power spectrum can be represented on the interval $\\mu\\in[-1,1]$ by a series in the Legendre polynomials $L_\\ell(\\mu)$.\n\nStarting from well-tested physical modelling of linear redshift-space distortions, assume the theoretical form of the anisotropic redshift-space power spectrum is given by the Kaiser model $P_s(k,\\mu)=(b+f\\,\\mu^2)^2\\,P_m(k)$, where $b$ is the linear bias parameter, $f$ is the linear growth rate, and $P_m(k)$ is an isotropic matter power spectrum model. Use the isotropic matter power spectrum shape $P_m(k)=A\\,k^{n_s}\\exp\\!\\left[-(k/k_c)^2\\right]$ with amplitude $A$, spectral index $n_s$, and characteristic cutoff $k_c$.\n\nYour task is to construct a numerical estimator for the multipole coefficients $P_\\ell(k)$ for $\\ell\\in\\{0,2,4\\}$ that is consistent with discrete sampling of $\\mu$. The estimator must:\n- Use the orthogonality of Legendre polynomials on $\\mu\\in[-1,1]$ to project the anisotropic power $P_s(k,\\mu)$ onto the multipole basis.\n- Replace the continuous integral over $\\mu$ by a discrete quadrature rule that is appropriate for functions expanded in Legendre polynomials. You must explicitly use nodes and weights that correspond to an integration scheme adapted to the polynomial basis on $[-1,1]$.\n- Treat $k$ as a fixed value per test case (that is, $k$-binning is degenerate to a single $k$ per case), and perform the angular projection over $\\mu$ only. Explain how, in a general discrete setting, binning in $\\mu$ is performed, and justify the choice of quadrature here as an adaptation to $\\mu$.\n\nUse the following test suite of parameter values. For each test case, compute the three multipoles $P_0(k)$, $P_2(k)$, and $P_4(k)$ as floating-point numbers:\n\n- Test Case 1 (general anisotropy, \"happy path\"):\n  - $A=1.5$, $n_s=1.0$, $k_c=0.7$, $b=2.0$, $f=0.8$, $k=0.1$.\n- Test Case 2 (isotropic limit in redshift space):\n  - $A=0.9$, $n_s=0.5$, $k_c=0.5$, $b=1.5$, $f=0.0$, $k=0.2$.\n- Test Case 3 (boundary in $k$-space):\n  - $A=1.0$, $n_s=1.5$, $k_c=0.8$, $b=1.0$, $f=1.0$, $k=0.0$.\n- Test Case 4 (strong anisotropy):\n  - $A=2.0$, $n_s=1.2$, $k_c=0.6$, $b=1.0$, $f=2.0$, $k=0.3$.\n\nAll quantities are dimensionless for this exercise. Angles are implicit through $\\mu$ and need not be separately specified.\n\nYour program must:\n- Implement a Legendre-adapted quadrature over $\\mu\\in[-1,1]$ to approximate the multipole projections of $P_s(k,\\mu)$ for the given $k$ in each test case, using a sufficient number of quadrature nodes to integrate polynomial angular dependence accurately.\n- For each test case, output the three multipole values $[P_0,P_2,P_4]$ as floats.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes its own three-element list in order. For example, the output should look like:\n\"[[P0_1,P2_1,P4_1],[P0_2,P2_2,P4_2],[P0_3,P2_3,P4_3],[P0_4,P2_4,P4_4]]\"",
            "solution": "The problem requires the construction of a numerical estimator for the multipole coefficients of the anisotropic redshift-space power spectrum, as described by the Kaiser model. This task involves projecting the model power spectrum onto a basis of Legendre polynomials.\n\nFirst, we establish the theoretical foundation. The power spectrum $P_s(k,\\mu)$ is a function of the Fourier mode's magnitude $k = \\lVert\\boldsymbol{k}\\rVert$ and the cosine of the angle between the mode vector and the line of sight, $\\mu = \\hat{\\boldsymbol{k}}\\cdot\\hat{\\boldsymbol{n}}$. Its multipole expansion is given by:\n$$\nP_s(k,\\mu) = \\sum_{\\ell=0}^{\\infty} P_\\ell(k) L_\\ell(\\mu)\n$$\nwhere $L_\\ell(\\mu)$ are the Legendre polynomials and $P_\\ell(k)$ are the multipole coefficients we seek to estimate.\n\nThe Legendre polynomials form an orthogonal basis on the interval $\\mu \\in [-1, 1]$, with the orthogonality relation:\n$$\n\\int_{-1}^{1} L_\\ell(\\mu) L_{\\ell'}(\\mu) d\\mu = \\frac{2}{2\\ell+1} \\delta_{\\ell\\ell'}\n$$\nwhere $\\delta_{\\ell\\ell'}$ is the Kronecker delta. This property allows us to isolate a specific coefficient $P_\\ell(k)$ by multiplying the expansion by $L_\\ell(\\mu)$ and integrating over $\\mu$:\n$$\n\\int_{-1}^{1} P_s(k,\\mu) L_\\ell(\\mu) d\\mu = \\int_{-1}^{1} \\left(\\sum_{\\ell'=0}^{\\infty} P_{\\ell'}(k) L_{\\ell'}(\\mu)\\right) L_\\ell(\\mu) d\\mu = P_\\ell(k) \\frac{2}{2\\ell+1}\n$$\nRearranging for $P_\\ell(k)$ gives the exact projection formula:\n$$\nP_\\ell(k) = \\frac{2\\ell+1}{2} \\int_{-1}^{1} P_s(k,\\mu) L_\\ell(\\mu) d\\mu\n$$\nThe problem supplies the theoretical model for $P_s(k,\\mu)$, known as the Kaiser model, which we substitute into this formula:\n$$\nP_s(k,\\mu) = (b+f\\,\\mu^2)^2 P_m(k)\n$$\nwhere $b$ is the linear bias, $f$ is the linear growth rate, and $P_m(k) = A\\,k^{n_s}\\exp\\!\\left[-(k/k_c)^2\\right]$ is the isotropic matter power spectrum. Since $P_m(k)$, $b$, and $f$ do not depend on $\\mu$, we can factor them out of the integral where appropriate:\n$$\nP_\\ell(k) = P_m(k) \\left[ \\frac{2\\ell+1}{2} \\int_{-1}^{1} (b+f\\,\\mu^2)^2 L_\\ell(\\mu) d\\mu \\right]\n$$\nThis is the integral we must compute. The problem specifies that we must use a numerical estimator. In a typical application with discrete data from a simulation or survey, one does not have access to the continuous function $P_s(k,\\mu)$. Instead, one has a discrete set of Fourier modes. The power spectrum is estimated by binning these modes in shells of $k$ and wedges of $\\mu$, then averaging the power $|\\delta_s(\\boldsymbol{k})|^2$ within each bin to get estimates $\\hat{P}(k_i, \\mu_j)$. The integral would then be approximated by a discrete sum over these $\\mu$-bins, such as a Riemann sum: $P_\\ell(k_i) \\approx \\frac{2\\ell+1}{2} \\sum_j \\hat{P}(k_i, \\mu_j) L_\\ell(\\mu_j) \\Delta\\mu_j$.\n\nHowever, in this problem, we are given the analytic form of $P_s(k,\\mu)$. Therefore, we can use a more sophisticated and accurate numerical integration technique than simple binning. The problem's requirement for a quadrature rule \"adapted to the polynomial basis on $[-1,1]$\" points directly to Gauss-Legendre quadrature. This method approximates the integral of a function $g(\\mu)$ as a weighted sum:\n$$\n\\int_{-1}^{1} g(\\mu) d\\mu \\approx \\sum_{i=1}^{N} w_i g(\\mu_i)\n$$\nwhere $\\mu_i$ are the $N$ roots (nodes) of the Legendre polynomial $L_N(\\mu)$ and $w_i$ are the corresponding weights. An $N$-point Gauss-Legendre quadrature is exact for any polynomial of degree up to $2N-1$.\n\nTo select an appropriate number of nodes $N$, we must determine the degree of the polynomial being integrated. The integrand is $(b+f\\mu^2)^2 L_\\ell(\\mu)$. The term $(b+f\\mu^2)^2 = b^2 + 2bf\\mu^2 + f^2\\mu^4$ is a polynomial in $\\mu$ of degree $4$. The Legendre polynomials for $\\ell=0,2,4$ are $L_0(\\mu)=1$ (degree $0$), $L_2(\\mu) = \\frac{1}{2}(3\\mu^2-1)$ (degree $2$), and $L_4(\\mu) = \\frac{1}{8}(35\\mu^4-30\\mu^2+3)$ (degree $4$). The highest degree of the integrand occurs for $\\ell=4$, which is $($degree $4$ polynomial in $\\mu) \\times ($degree $4$ polynomial in $\\mu)$, resulting in a polynomial of degree $8$.\nTo integrate a polynomial of degree $8$ exactly, we require $2N-1 \\ge 8$, which implies $2N \\ge 9$, so $N \\ge 4.5$. The smallest integer value is $N=5$. Thus, a $5$-point Gauss-Legendre quadrature will yield a numerically exact result (up to machine precision) for all required multipoles $\\ell=0, 2, 4$.\n\nOur numerical estimator for the multipoles is therefore:\n$$\nP_\\ell(k) \\approx P_m(k) \\left[ \\frac{2\\ell+1}{2} \\sum_{i=1}^{5} w_i (b+f\\mu_i^2)^2 L_\\ell(\\mu_i) \\right]\n$$\nwhere $(\\mu_i, w_i)$ are the nodes and weights for $5$-point Gauss-Legendre quadrature.\n\nWe proceed by implementing this formula for each test case.\nFor Test Case 3, where $k=0.0$, we must be careful. The matter power spectrum is $P_m(k) = A\\,k^{n_s}\\exp\\!\\left[-(k/k_c)^2\\right]$. With $n_s=1.5 > 0$, the term $k^{n_s}$ evaluates to $0$ at $k=0$. Therefore, $P_m(0)=0$, which in turn means all multipoles $P_\\ell(0)$ will be zero.\n\nFor Test Case 2, where $f=0.0$, the power spectrum becomes isotropic: $P_s(k,\\mu) = b^2 P_m(k)$. The integral simplifies. For $\\ell=0$, $P_0(k) = \\frac{1}{2} \\int_{-1}^1 b^2 P_m(k) L_0(\\mu) d\\mu = \\frac{b^2 P_m(k)}{2} \\int_{-1}^1 d\\mu = b^2 P_m(k)$. For any $\\ell > 0$, the integral $\\int_{-1}^1 L_\\ell(\\mu) d\\mu$ is zero due to orthogonality with $L_0(\\mu)=1$, so $P_2(k)=P_4(k)=0$. Our numerical estimator should reproduce this result.",
            "answer": "```python\nimport numpy as np\nimport scipy.special\n\ndef solve():\n    \"\"\"\n    Calculates the redshift-space power spectrum multipoles P_0, P_2, P_4\n    for a set of cosmological parameters using the Kaiser model and\n    Gauss-Legendre quadrature for the angular projection.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (A, n_s, k_c, b, f, k)\n        (1.5, 1.0, 0.7, 2.0, 0.8, 0.1), # Test Case 1\n        (0.9, 0.5, 0.5, 1.5, 0.0, 0.2), # Test Case 2\n        (1.0, 1.5, 0.8, 1.0, 1.0, 0.0), # Test Case 3\n        (2.0, 1.2, 0.6, 1.0, 2.0, 0.3), # Test Case 4\n    ]\n\n    all_results = []\n    \n    # The integrand's angular part is a polynomial of degree up to 8.\n    # A 5-point Gauss-Legendre quadrature is exact for polynomials of degree\n    # up to 2*5 - 1 = 9, so it is sufficient.\n    N_QUAD = 5\n    mu_nodes, weights = scipy.special.roots_legendre(N_QUAD)\n\n    # Define Legendre polynomials for l=0, 2, 4\n    def L0(mu):\n        return 1.0\n\n    def L2(mu):\n        return 0.5 * (3 * mu**2 - 1)\n\n    def L4(mu):\n        return (1.0/8.0) * (35 * mu**4 - 30 * mu**2 + 3)\n\n    legendre_funcs = {0: L0, 2: L2, 4: L4}\n\n    for case in test_cases:\n        A, n_s, k_c, b, f, k = case\n        \n        # Calculate the matter power spectrum P_m(k)\n        # Handle the special case k=0. If n_s > 0, k^n_s is 0.\n        if k == 0.0:\n            if n_s > 0:\n                p_m_k = 0.0\n            elif n_s == 0:\n                # exp(-0) = 1, k^0 = 1\n                p_m_k = A\n            else:\n                 # This case is not in the test suite, but would be a singularity.\n                p_m_k = np.inf\n        else:\n            p_m_k = A * k**n_s * np.exp(-(k / k_c)**2)\n        \n        # If P_m(k) is zero, all multipoles are zero.\n        if p_m_k == 0.0:\n            all_results.append([0.0, 0.0, 0.0])\n            continue\n\n        case_results = []\n        for l in [0, 2, 4]:\n            # Numerical integration using Gauss-Legendre quadrature\n            integral_sum = 0.0\n            for i in range(N_QUAD):\n                mu = mu_nodes[i]\n                w = weights[i]\n                \n                # Integrand is (b + f*mu^2)^2 * L_l(mu)\n                angular_part = (b + f * mu**2)**2\n                legendre_val = legendre_funcs[l](mu)\n                \n                integral_sum += w * angular_part * legendre_val\n\n            # Full multipole formula: P_l(k) = (2l+1)/2 * integral * P_m(k)\n            prefactor = (2 * l + 1) / 2.0\n            p_l_k = prefactor * p_m_k * integral_sum\n            case_results.append(p_l_k)\n            \n        all_results.append(case_results)\n\n    # Format the final output string exactly as required\n    # e.g., \"[[r1,r2,r3],[r4,r5,r6]]\"\n    output_str = \"[\" + \",\".join([f\"[{c[0]},{c[1]},{c[2]}]\" for c in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}