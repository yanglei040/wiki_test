{
    "hands_on_practices": [
        {
            "introduction": "构建一个模拟星表的第一步，是在一个给定的宇宙学体积内填充像暗物质晕这样的天体。这些天体的丰度由晕质量函数描述，它给出了单位质量区间的数密度。这个练习  提供了将理论上的连续分布（质量函数）转化为离散天体的期望数这一基本步骤的实践。它还介绍了泊松取样噪声的概念，这是这类星表中最基本的方差来源。",
            "id": "3477518",
            "problem": "在数值宇宙学中构建模拟暗晕星表的过去光锥时，考虑一个体积为 $\\Delta V$ 的薄共动壳层，在该壳层内暗晕总体是统计上均匀的。微分暗晕质量函数由函数 $dn/dM$ 指定，其定义为每单位质量区间的共动数密度。假设质量大于阈值质量 $M_{\\min}$ 的暗晕以单位选择概率被包含在内，而质量低于 $M_{\\min}$ 的暗暈则被排除。此壳层中的暗暈质量函数可用以下形式建模\n$$\n\\frac{dn}{dM} \\;=\\; A\\,\\left(\\frac{M}{M_{\\star}}\\right)^{-1} \\exp\\!\\left(-\\frac{M}{M_{\\star}}\\right)\\,\\frac{1}{M_{\\star}} \\quad ,\n$$\n其中 $A$ 是一个单位为 $\\mathrm{Mpc}^{-3}$ 的常数振幅，$M_{\\star}$ 是一个特征质量。给定以下壳层和模型参数：\n$$\n\\Delta V \\;=\\; 1.00 \\times 10^{8}\\,\\mathrm{Mpc}^{3} \\quad , \\quad A \\;=\\; 3.00 \\times 10^{-6}\\,\\mathrm{Mpc}^{-3} \\quad , \\quad M_{\\star} \\;=\\; 1.00 \\times 10^{13}\\,\\mathrm{M}_{\\odot} \\quad , \\quad M_{\\min} \\;=\\; 1.00 \\times 10^{13}\\,\\mathrm{M}_{\\odot} \\; .\n$$\n仅使用体积内计数的​​基本定义和暗晕抽样的泊松点过程假设，计算：\n1. 壳层中质量大于 $M_{\\min}$ 的暗晕的期望数。\n2. 该数量的泊松抽样方差。\n\n将最终答案表示为 $(\\text{期望数}, \\text{泊松方差})$ 顺序的两个数字，不带单位。将您的答案四舍五入到四位有效数字。",
            "solution": "该问题要求计算共动体积壳层内暗物质晕总体的两个量：质量大于最小质量的暗晕的期望数，以及该数量的泊松抽样方差。解题过程将分两部分进行，分别处理这两个需要计算的量。\n\n首先，我们计算暗晕的期望数，记作 $N_{\\mathrm{exp}}$。体积 $\\Delta V$ 内物体的期望数的基本定义是它们的共动数密度 $n$ 与体积本身的乘积。\n$$\nN_{\\mathrm{exp}} = n \\times \\Delta V\n$$\n质量大于阈值质量 $M_{\\min}$ 的暗晕的共动数密度 $n$ 是通过对微分暗晕质量函数 $\\frac{dn}{dM}$ 在所有相关质量上积分得到的。由于质量低于 $M_{\\min}$ 的暗晕被排除（即选择概率为零），而质量高于 $M_{\\min}$ 的暗暈以单位概率被包含，因此积分范围是从 $M_{\\min}$到无穷大。\n$$\nn(M  M_{\\min}) = \\int_{M_{\\min}}^{\\infty} \\frac{dn}{dM} \\, dM\n$$\n题目给出了微分暗晕质量函数的函数形式：\n$$\n\\frac{dn}{dM} = A \\left(\\frac{M}{M_{\\star}}\\right)^{-1} \\exp\\left(-\\frac{M}{M_{\\star}}\\right) \\frac{1}{M_{\\star}}\n$$\n将此形式代入 $n$ 的积分中：\n$$\nn = \\int_{M_{\\min}}^{\\infty} A \\left(\\frac{M}{M_{\\star}}\\right)^{-1} \\exp\\left(-\\frac{M}{M_{\\star}}\\right) \\frac{1}{M_{\\star}} \\, dM\n$$\n我们可以化简积分内的表达式：\n$$\nn = A \\int_{M_{\\min}}^{\\infty} \\frac{M_{\\star}}{M} \\exp\\left(-\\frac{M}{M_{\\star}}\\right) \\frac{1}{M_{\\star}} \\, dM = A \\int_{M_{\\min}}^{\\infty} \\frac{1}{M} \\exp\\left(-\\frac{M}{M_{\\star}}\\right) \\, dM\n$$\n为了解此积分，我们进行换元。令 $u = \\frac{M}{M_{\\star}}$。则 $M = u M_{\\star}$ 且 $dM = M_{\\star} du$。积分的上下限也随之改变：当 $M = M_{\\min}$ 时，$u = \\frac{M_{\\min}}{M_{\\star}}$；当 $M \\to \\infty$ 时，$u \\to \\infty$。积分变为：\n$$\nn = A \\int_{M_{\\min}/M_{\\star}}^{\\infty} \\frac{1}{u M_{\\star}} \\exp(-u) \\, (M_{\\star} du) = A \\int_{M_{\\min}/M_{\\star}}^{\\infty} \\frac{\\exp(-u)}{u} \\, du\n$$\n该积分是第一指数积分函数 $E_1(x)$ 的定义，定义为：\n$$\nE_1(x) = \\int_{x}^{\\infty} \\frac{\\exp(-t)}{t} \\, dt\n$$\n因此，数密度由下式给出：\n$$\nn = A \\, E_1\\left(\\frac{M_{\\min}}{M_{\\star}}\\right)\n$$\n现在，我们可以通过乘以体积 $\\Delta V$ 来求出暗晕的期望数 $N_{\\mathrm{exp}}$：\n$$\nN_{\\mathrm{exp}} = A \\, E_1\\left(\\frac{M_{\\min}}{M_{\\star}}\\right) \\, \\Delta V\n$$\n我们被给予了以下参数值：\n$$\n\\Delta V = 1.00 \\times 10^{8}\\,\\mathrm{Mpc}^{3} \\quad , \\quad A = 3.00 \\times 10^{-6}\\,\\mathrm{Mpc}^{-3} \\quad , \\quad M_{\\star} = 1.00 \\times 10^{13}\\,\\mathrm{M}_{\\odot} \\quad , \\quad M_{\\min} = 1.00 \\times 10^{13}\\,\\mathrm{M}_{\\odot}\n$$\n最小质量与特征质量之比为：\n$$\n\\frac{M_{\\min}}{M_{\\star}} = \\frac{1.00 \\times 10^{13}\\,\\mathrm{M}_{\\odot}}{1.00 \\times 10^{13}\\,\\mathrm{M}_{\\odot}} = 1\n$$\n将数值代入 $N_{\\mathrm{exp}}$ 的表达式中：\n$$\nN_{\\mathrm{exp}} = (3.00 \\times 10^{-6}\\,\\mathrm{Mpc}^{-3}) \\times E_1(1) \\times (1.00 \\times 10^{8}\\,\\mathrm{Mpc}^{3})\n$$\n$$\nN_{\\mathrm{exp}} = 3.00 \\times 1.00 \\times 10^{-6} \\times 10^{8} \\times E_1(1) = 300 \\, E_1(1)\n$$\n指数积分函数在 $1$ 处的值是一个标准的数学常数，$E_1(1) \\approx 0.219383934$。\n$$\nN_{\\mathrm{exp}} \\approx 300 \\times 0.219383934 \\approx 65.81518\n$$\n四舍五入到四位有效数字，我们得到：\n$$\nN_{\\mathrm{exp}} \\approx 65.82\n$$\n其次，我们计算暗暈数量的泊松抽样方差。题目明确指出，我们应假设暗晕抽样遵循泊松点过程。一个服从均值（期望值）为 $\\lambda$ 的泊松分布的随机变量 $K$ 的一个基本性质是其方差也等于 $\\lambda$。也就是说，如果 $K \\sim \\mathrm{Poisson}(\\lambda)$，那么 $E[K] = \\lambda$ 且 $\\mathrm{Var}(K) = \\lambda$。\n在本题中，体积 $\\Delta V$ 内的暗暈数量 $N$ 被假定为一个泊松随机变量。其期望值为 $E[N] = N_{\\mathrm{exp}}$。因此，其方差为：\n$$\n\\mathrm{Var}(N) = E[N] = N_{\\mathrm{exp}}\n$$\n使用我们刚刚计算出的 $N_{\\mathrm{exp}}$ 的值：\n$$\n\\mathrm{Var}(N) \\approx 65.81518\n$$\n四舍五入到四位有效数字，方差为：\n$$\n\\mathrm{Var}(N) \\approx 65.82\n$$\n所要求的答案是数对 $(\\text{期望数}, \\text{泊松方差})$。两个值都约等于 $65.82$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n65.82  65.82\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "宇宙学模拟在离散的时间点上产生快照。要构建一个连续的过去光锥，则需要在这些快照之间对星系的位置和速度进行插值。这个实践  深入探讨了光锥构建中的一个关键技术细节，迫使我们直面处理演化坐标系所带来的挑战，并量化由此产生的插值误差。它突出了计算成本（快照间距）与模拟保真度之间的权衡。",
            "id": "3477498",
            "problem": "您的任务是设计并评估一个快照插值方案，用于在空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙学模型中构建过去光锥并生成模拟星系表。目标是确保在光锥交点处，通过插值得到的星系位置和速度满足指定的容差，并根据经验量化误差预算，将其表示为红移中快照间距以及选择共动坐标与物理坐标进行插值的函数。您的程序必须仅从下文给出的基本定义出发，实现以下内容。\n\n考虑一个平坦宇宙，其物质密度参数为 $\\Omega_{\\mathrm{m}}$，暗能量密度参数为 $\\Omega_{\\Lambda} = 1 - \\Omega_{\\mathrm{m}}$，当今哈勃参数为 $H_0$，光速为 $c$。哈勃膨胀率作为红移 $z$ 的函数为\n$$\nH(z) = H_0 \\sqrt{\\Omega_{\\mathrm{m}}(1+z)^3 + \\Omega_{\\Lambda}}.\n$$\n共动径向距离为\n$$\n\\chi(z) = \\frac{c}{H_0} \\int_{0}^{z} \\frac{dz'}{\\sqrt{\\Omega_{\\mathrm{m}}(1+z')^3 + \\Omega_{\\Lambda}}}.\n$$\n宇宙时与红移的关系为\n$$\n\\frac{dt}{dz} = -\\frac{1}{(1+z) H(z)}.\n$$\n假设沿 x 轴正方向进行径向一维运动。令 $a(z) = \\frac{1}{1+z}$ 表示标度因子。设每个星系在物理坐标系中的本动速度为常数，等于 $u_{\\mathrm{p}}$（单位为 $\\mathrm{km/s}$）。设共动坐标为 $x(z)$（单位为 $\\mathrm{Mpc}$）。从 $u = a \\, dx/dt$ 可知，一个恒定的 $u_{\\mathrm{p}}$ 意味着\n$$\n\\frac{dx}{dt} = \\frac{u_{\\mathrm{p}}}{a(z)},\n$$\n因此，使用 $\\frac{dz}{dt} = -(1+z) H(z)$，可得\n$$\n\\frac{dx}{dz} = - \\frac{u_{\\mathrm{p}}}{H(z)} \\cdot \\left(\\frac{\\mathrm{Mpc/Gyr}}{\\mathrm{km/s}}\\right),\n$$\n当 $H(z)$ 以 $\\mathrm{Gyr}^{-1}$ 表示，并且 $u_{\\mathrm{p}}$ 也一致地转换为 $\\mathrm{Mpc/Gyr}$ 时。因此，对于一个在 $z_{\\max}$ 处具有初始条件 $x(z_{\\max}) = x_0$ 和恒定 $u_{\\mathrm{p}}$ 的星系，其精确的共动轨迹为\n$$\nx(z) = x_0 - u_{\\mathrm{p}}^{(\\mathrm{Mpc/Gyr})} \\int_{z_{\\max}}^{z} \\frac{dz'}{H(z')},\n$$\n其中 $u_{\\mathrm{p}}^{(\\mathrm{Mpc/Gyr})}$ 是将 $u_{\\mathrm{p}}$ 转换为 $\\mathrm{Mpc/Gyr}$ 后的值。\n\n定义位于原点的观测者的过去光锥，其条件是事件 $(x,z)$ 位于光锥上，当且仅当 $x(z) = \\chi(z)$。对于一个给定星系，其精确的穿越红移 $z_\\star$ 是下式的唯一根\n$$\nf(z) = x(z) - \\chi(z) = 0,\n$$\n对于 $z \\in [0, z_{\\max}]$。\n\n数值插值问题：您拥有在离散红移 $z_k = z_{\\max} - k \\, \\Delta z$（对于整数 $k \\ge 0$ 直到 $z$ 达到 0）处的模拟快照。对于一个目标星系，将其在快照处的精确值表示为 $x_k = x(z_k)$、$t_k = t(z_k)$、$a_k = a(z_k)$、$r_k = a_k x_k$、$u_k = u_{\\mathrm{p}}$（恒定）以及 $v_{c,k} = dx/dt \\big|_{z_k} = u_{\\mathrm{p}}/a_k$（单位为 $\\mathrm{Mpc/Gyr}$）。考虑在包含 $z_\\star$ 的区间 $[z_i, z_{i+1}]$ 上的两种时间线性插值方案：\n\n方案 C（共动空间插值）：在时间 $t$ 上对 $x(t)$ 和 $v_c(t)=dx/dt$ 在 $(t_i, x_i, v_{c,i})$ 和 $(t_{i+1}, x_{i+1}, v_{c,i+1})$ 之间进行线性插值，然后从\n$$\nx_{\\mathrm{lin}}(t(\\hat{z})) - \\chi(\\hat{z}) = 0,\n$$\n中求解估计的穿越红移 $\\hat{z}$，并通过\n$$\n\\hat{u} = a(\\hat{z}) \\, v_{c,\\mathrm{lin}}(t(\\hat{z})),\n$$\n来估计穿越点处的物理本动速度，并将其转换为 $\\mathrm{km/s}$。\n\n方案 P（物理空间插值）：在时间 $t$ 上对 $r(t)=a x$ 和 $u(t)$ 在 $(t_i, r_i, u_i)$ 和 $(t_{i+1}, r_{i+1}, u_{i+1})$ 之间进行线性插值，然后从\n$$\n\\frac{r_{\\mathrm{lin}}(t(\\hat{z}))}{a(\\hat{z})} - \\chi(\\hat{z}) = 0,\n$$\n中求解估计的穿越红移 $\\hat{z}$，并通过\n$$\n\\hat{u} = u_{\\mathrm{lin}}(t(\\hat{z})).\n$$\n来估计穿越点处的物理本动速度。\n\n您必须为每个星系和每种方案计算精确的穿越红移 $z_\\star$ 和估计的穿越红移 $\\hat{z}$。将光锥位置误差量化为绝对共动径向误差\n$$\n\\Delta \\chi = \\left| \\chi(\\hat{z}) - \\chi(z_\\star) \\right| \\quad \\text{单位：} \\ \\mathrm{Mpc},\n$$\n速度误差量化为\n$$\n\\Delta u = \\left| \\hat{u} - u_{\\mathrm{p}} \\right| \\quad \\text{单位：} \\ \\mathrm{km/s}.\n$$\n对于每种方案和快照间距，通过计算所有星系的误差最大值来汇总误差。\n\n您的程序应使用的科学和数值设置：\n- 宇宙学：$\\Omega_{\\mathrm{m}} = 0.3$，$\\Omega_{\\Lambda} = 0.7$，$H_0 = 70 \\ \\mathrm{km \\, s^{-1} \\, Mpc^{-1}}$，$c = 299792.458 \\ \\mathrm{km/s}$。\n- 红移范围：$z_{\\max} = 2$，$z_{\\min} = 0$。\n- 在 $z_{\\max}$ 处的星系集合：四个星系的 $(x_0, u_{\\mathrm{p}})$ 分别为 $(50, 200)$、$(100, 400)$、$(150, 800)$ 和 $(200, 1200)$，其中 $x_0$ 单位为 $\\mathrm{Mpc}$，$u_{\\mathrm{p}}$ 单位为 $\\mathrm{km/s}$，所有星系均径向向外运动。\n- 插值方案：方案 C（共动）和方案 P（物理），如上定义。\n- 快照间距：$\\Delta z \\in \\{0.5, 0.2, 0.1, 0.05\\}$。\n- 用于评估但不必直接打印的容差：位置容差 $\\tau_{\\chi} = 0.1 \\ \\mathrm{Mpc}$ 和速度容差 $\\tau_{u} = 10 \\ \\mathrm{km/s}$；您的程序应计算误差，但最终输出不是布尔值的通过/失败，而是数值误差的大小。\n\n测试套件和要求的输出：\n- 定义八个测试用例，顺序如下\n  $$\n  (\\Delta z, \\text{scheme}) \\in \\{(0.5, \\text{C}), (0.5, \\text{P}), (0.2, \\text{C}), (0.2, \\text{P}), (0.1, \\text{C}), (0.1, \\text{P}), (0.05, \\text{C}), (0.05, \\text{P})\\}.\n  $$\n- 对于每个测试用例，汇总四个星系的结果并返回两个浮点数：最大 $\\Delta \\chi$（单位 $\\mathrm{Mpc}$）和最大 $\\Delta u$（单位 $\\mathrm{km/s}$），每个均四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n  $$\n  [\\max \\Delta \\chi_{1}, \\max \\Delta u_{1}, \\max \\Delta \\chi_{2}, \\max \\Delta u_{2}, \\ldots, \\max \\Delta \\chi_{8}, \\max \\Delta u_{8}],\n  $$\n  其中索引按上述指定的确切顺序遍历八个测试用例。距离单位必须是 $\\mathrm{Mpc}$，速度单位必须是 $\\mathrm{km/s}$，两者均四舍五入到六位小数。\n\n您的实现必须仅依赖于给定的定义和积分，在需要进行时间积分时，以 $\\mathrm{Gyr}^{-1}$ 为单位计算 $H(z)$，在内部使用精确常数进行一致的单位转换，并通过在每种方案的包围快照区间上使用稳健的求根方法来求解光锥穿越点。不允许使用外部数据或输入；所有值必须在程序内部定义。",
            "solution": "用户提供了一个有效且定义明确的数值宇宙学问题。任务是实现并评估两种用于构建光锥的、基于快照的插值方案。本解决方案将从问题陈述中阐明的基础原理出发，逐步进行推导和算法设计。\n\n### 1. 宇宙学框架与基本量\n\n该问题设定在一个空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙中，由标准宇宙学参数控制：物质密度 $\\Omega_{\\mathrm{m}} = 0.3$，暗能量密度 $\\Omega_{\\Lambda} = 0.7$，以及当今哈勃参数 $H_0 = 70 \\ \\mathrm{km \\, s^{-1} \\, Mpc^{-1}}$。光速为 $c = 299792.458 \\ \\mathrm{km/s}$。\n\n问题的核心涉及依赖于红移的量的计算。为保持一致性，尤其是在涉及时间的数值积分中，我们将所有相关量转换为基于百万秒差距 (Mpc) 和十亿年 (Gyr) 的单位系统。\n\n从 $\\mathrm{km/s}$ 到 $\\mathrm{Mpc/Gyr}$ 的转换因子推导如下：\n$$\n1 \\frac{\\mathrm{km}}{\\mathrm{s}} = \\frac{1 \\ \\mathrm{km}}{1 \\ \\mathrm{s}} \\times \\frac{1 \\ \\mathrm{Mpc}}{3.08567758 \\times 10^{19} \\ \\mathrm{km}} \\times \\frac{3.15576 \\times 10^{16} \\ \\mathrm{s}}{1 \\ \\mathrm{Gyr}} \\approx 1.02269 \\times 10^{-3} \\frac{\\mathrm{Mpc}}{\\mathrm{Gyr}}\n$$\n使用这个因子，我们可以将 $H_0$ 表示为 $\\mathrm{Gyr}^{-1}$ 单位：\n$$\nH_0 = 70 \\ \\mathrm{km \\, s^{-1} \\, Mpc^{-1}} \\times (1.02269 \\times 10^{-3} \\ \\mathrm{Mpc \\, Gyr^{-1}} / \\mathrm{km \\, s^{-1}}) \\approx 0.071588 \\ \\mathrm{Gyr}^{-1}\n$$\n于是，红移 $z$ 处的哈勃参数为：\n$$\nH(z) = H_0 \\sqrt{\\Omega_{\\mathrm{m}}(1+z)^3 + \\Omega_{\\Lambda}}\n$$\n其中 $H(z)$ 以 $\\mathrm{Gyr}^{-1}$ 单位计算。\n\n从位于 $z=0$ 的观测者到红移为 $z$ 的物体的共动径向距离 $\\chi(z)$ 由以下积分给出：\n$$\n\\chi(z) = \\frac{c}{H_0} \\int_{0}^{z} \\frac{dz'}{\\sqrt{\\Omega_{\\mathrm{m}}(1+z')^3 + \\Omega_{\\Lambda}}}\n$$\n该积分通过数值方法计算。前置因子 $c/H_0$ 给出以 Mpc 为单位的距离。\n\n宇宙时 $t$ 和红移 $z$ 之间的关系是微分的：\n$$\n\\frac{dt}{dz} = -\\frac{1}{(1+z) H(z)}\n$$\n为了求得给定红移下的宇宙时 $t(z)$，我们对此关系进行积分。为方便起见，我们定义一个参考时间 $t(z_{\\max})=0$，得到：\n$$\nt(z) = \\int_{z_{\\max}}^{z} \\frac{-dz'}{(1+z') H(z')} = \\int_{z}^{z_{\\max}} \\frac{dz'}{(1+z') H(z')}\n$$\n该积分也通过数值方法计算。\n\n### 2. 精确的星系轨迹与光锥穿越\n\n假设一个星系具有恒定的物理本动速度 $u_{\\mathrm{p}}$。其共动坐标 $x(z)$ 的演化遵循：\n$$\nx(z) = x_0 - u_{\\mathrm{p}}^{(\\mathrm{Mpc/Gyr})} \\int_{z_{\\max}}^{z} \\frac{dz'}{H(z')} = x_0 + u_{\\mathrm{p}}^{(\\mathrm{Mpc/Gyr})} \\int_{z}^{z_{\\max}} \\frac{dz'}{H(z')}\n$$\n其中 $x_0$ 是在 $z_{\\max}=2$ 处的共动位置，$u_{\\mathrm{p}}^{(\\mathrm{Mpc/Gyr})}$ 是转换为 $\\mathrm{Mpc/Gyr}$ 单位的本动速度。\n\n过去光锥定义为时空事件 $(x, z)$ 的集合，其中到观测者的共动距离等于事件的径向共动坐标：$x = \\chi(z)$。对于一个给定星系，其精确的光锥穿越红移 $z_\\star$ 是方程的唯一根：\n$$\nf(z) = x(z) - \\chi(z) = 0\n$$\n函数 $f(z)$ 是严格单调的，因为它是一个关于 $z$ 的减函数（$x(z)$）与一个关于 $z$ 的增函数（$\\chi(z)$）之差。在 $z=0$ 时，$x(0)  0$ 且 $\\chi(0)=0$，所以 $f(0)  0$。在 $z=z_{\\max}$ 时，$x(z_{\\max})$ 是一个较小的初始位置，而 $\\chi(z_{\\max})$ 较大，所以 $f(z_{\\max})  0$。这保证了在 $(0, z_{\\max})$ 区间内存在唯一的根 $z_\\star$。我们可以在一个包围根的区间上，使用像 Brent-Dekker 方法（`brentq`）这样的数值求根算法来找到这个根。\n\n### 3. 插值方案与误差估计\n\n问题的核心是利用离散模拟快照的数据来近似光锥穿越点。快照在红移 $z_k = z_{\\max} - k \\Delta z$ 处可用。对于一个星系，我们首先通过寻找 $f(z_k) = x(z_k) - \\chi(z_k)$ 符号改变的位置，来确定包围真实穿越点 $z_\\star$ 的快照区间 $[z_{i+1}, z_i]$。\n\n在这个包围区间内，我们应用两种时间 $t$ 的线性插值方案之一。对于一个量 $Q(t)$，其线性插值函数为：\n$$\nQ_{\\mathrm{lin}}(t) = Q_i + (Q_{i+1} - Q_i) \\frac{t - t_i}{t_{i+1} - t_i}\n$$\n其中 $(t_i, Q_i)$ 和 $(t_{i+1}, Q_{i+1})$ 是在包围快照处的值。\n\n**方案 C（共动空间插值）：**\n1.  **位置：** 对共动位置 $x(t)$ 进行线性插值。通过求解以下方程找到估计的穿越红移 $\\hat{z}$：\n    $$\n    x_{\\mathrm{lin}}(t(\\hat{z})) - \\chi(\\hat{z}) = 0\n    $$\n2.  **速度：** 对共动速度 $v_c(t) = dx/dt = u_{\\mathrm{p}}/a(t)$ 进行线性插值。估计的物理本动速度为：\n    $$\n    \\hat{u} = a(\\hat{z}) \\, v_{c,\\mathrm{lin}}(t(\\hat{z}))\n    $$\n    由于 $v_c$ 并非真正随 $t$ 线性变化，该方案会引入速度误差。\n\n**方案 P（物理空间插值）：**\n1.  **位置：** 对物理位置 $r(t) = a(t)x(t)$ 进行线性插值。通过求解以下方程找到估计的穿越红移 $\\hat{z}$：\n    $$\n    \\frac{r_{\\mathrm{lin}}(t(\\hat{z}))}{a(\\hat{z})} - \\chi(\\hat{z}) = 0\n    $$\n2.  **速度：** 对物理速度 $u(t) = u_{\\mathrm{p}}$ 进行线性插值。由于根据假设 $u_{\\mathrm{p}}$ 是恒定的，所以 $u_i = u_{i+1} = u_{\\mathrm{p}}$。因此线性插值函数是常数：\n    $$\n    \\hat{u} = u_{\\mathrm{lin}}(t(\\hat{z})) = u_{\\mathrm{p}}\n    $$\n    因此，对于该方案，速度误差 $\\Delta u$ 在解析上为零。\n\n在两种方案中，求解 $\\hat{z}$ 都需要数值求根器，因为方程涉及非线性函数 $t(z)$、$a(z)$ 和 $\\chi(z)$。包围区间 $[z_{i+1}, z_i]$ 对于寻找 $\\hat{z}$ 仍然有效。\n\n最后，误差被量化为：\n-   位置误差：$\\Delta \\chi = | \\chi(\\hat{z}) - \\chi(z_\\star) |$，单位 Mpc。\n-   速度误差：$\\Delta u = | \\hat{u} - u_{\\mathrm{p}} |$，单位 km/s。\n\n对于每个测试用例（一对 $\\Delta z$ 和方案），计算并报告四个指定星系中的最大误差。\n\n### 4. 算法实现\n\n该实现将宇宙学计算封装在一个类中，以管理参数并缓存计算成本高昂的积分结果，从而提高性能。主逻辑遍历指定的测试用例。对于每个用例，它遍历所有星系，执行以下步骤，并汇总最大误差：\n1.  定义宇宙学模型和星系属性。\n2.  为给定的 $\\Delta z$ 生成快照红移。\n3.  对每个星系，确定精确的穿越红移 $z_\\star$ 和包围它的快照区间 $[z_{i+1}, z_i]$。\n4.  收集在快照 $z_i$ 和 $z_{i+1}$ 处所需的数据（$t, x, a, r, v_c, u$）。\n5.  应用指定的插值方案（C 或 P）来定义新的穿越红移方程。\n6.  使用求根器求解估计的穿越红移 $\\hat{z}$。\n7.  根据所选方案计算估计的速度 $\\hat{u}$。\n8.  计算误差 $\\Delta \\chi$ 和 $\\Delta u$，并更新当前测试用例的最大值。\n最终结果按照要求格式化为单个字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the lightcone interpolation problem.\n    \"\"\"\n\n    class Cosmology:\n        \"\"\"\n        Encapsulates cosmological parameters and functions.\n        Uses caching for expensive integral calculations.\n        \"\"\"\n        def __init__(self, omega_m, omega_l, h0_kms_mpc, c_kms, z_max):\n            self.OMEGA_M = omega_m\n            self.OMEGA_L = omega_l\n            self.H0_KMS_MPC = h0_kms_mpc\n            self.C_KMS = c_kms\n            self.Z_MAX = z_max\n\n            # Unit Conversion Constants\n            # 1 Gyr in seconds based on 365.25 days/year\n            SEC_PER_GYR = 1e9 * 365.25 * 24 * 3600\n            # 1 Mpc in km\n            KM_PER_MPC = 3.08567758149e19\n            \n            # Conversion factor from km/s to Mpc/Gyr\n            self.MPC_GYR_PER_KM_S = SEC_PER_GYR / KM_PER_MPC\n            \n            # H0 in Gyr^-1\n            self.H0_PER_GYR = self.H0_KMS_MPC * self.MPC_GYR_PER_KM_S\n            \n            # Speed of light in Mpc/Gyr\n            self.C_MPC_GYR = self.C_KMS * self.MPC_GYR_PER_KM_S\n            \n            # Comoving distance prefactor c/H0 in Mpc\n            self.C_OVER_H0_MPC = self.C_KMS / self.H0_KMS_MPC\n\n            self._cache = {}\n\n        def E_z(self, z):\n            return np.sqrt(self.OMEGA_M * (1 + z)**3 + self.OMEGA_L)\n\n        def H_z_gyr(self, z):\n            return self.H0_PER_GYR * self.E_z(z)\n\n        def chi_z(self, z):\n            if ('chi', z) in self._cache:\n                return self._cache[('chi', z)]\n            if z == 0:\n                return 0.0\n            \n            integrand = lambda zp: 1.0 / self.E_z(zp)\n            result, _ = quad(integrand, 0, z)\n            val = self.C_OVER_H0_MPC * result\n            self._cache[('chi', z)] = val\n            return val\n\n        def t_z(self, z):\n            if ('t', z) in self._cache:\n                return self._cache[('t', z)]\n            if z == self.Z_MAX:\n                return 0.0\n            \n            integrand = lambda zp: 1.0 / ((1 + zp) * self.H_z_gyr(zp))\n            result, _ = quad(integrand, z, self.Z_MAX)\n            self._cache[('t', z)] = result\n            return result\n\n        def integral_one_over_H(self, z_lower, z_upper):\n            key = ('int_1/H', z_lower, z_upper)\n            if key in self._cache:\n                return self._cache[key]\n            \n            integrand = lambda zp: 1.0 / self.H_z_gyr(zp)\n            result, _ = quad(integrand, z_lower, z_upper)\n            self._cache[key] = result\n            return result\n    \n    class Galaxy:\n        def __init__(self, cosmo, x0, u_p_kms):\n            self.cosmo = cosmo\n            self.x0 = x0  # Mpc at z_max\n            self.u_p_kms = u_p_kms  # km/s\n            self.u_p_mpcgyr = u_p_kms * cosmo.MPC_GYR_PER_KM_S\n            self._cache_x = {}\n\n        def x_z(self, z):\n            if z in self._cache_x:\n                return self._cache_x[z]\n            if z == self.cosmo.Z_MAX:\n                return self.x0\n            \n            integral_val = self.cosmo.integral_one_over_H(z, self.cosmo.Z_MAX)\n            val = self.x0 + self.u_p_mpcgyr * integral_val\n            self._cache_x[z] = val\n            return val\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.5, 'C'), (0.5, 'P'),\n        (0.2, 'C'), (0.2, 'P'),\n        (0.1, 'C'), (0.1, 'P'),\n        (0.05, 'C'), (0.05, 'P'),\n    ]\n\n    # Initialize Cosmology\n    cosmo = Cosmology(omega_m=0.3, omega_l=0.7, h0_kms_mpc=70.0, c_kms=299792.458, z_max=2.0)\n\n    # Initialize Galaxies\n    galaxy_params = [(50, 200), (100, 400), (150, 800), (200, 1200)]\n    galaxies = [Galaxy(cosmo, x0, u_p) for x0, u_p in galaxy_params]\n    \n    final_results = []\n\n    for delta_z, scheme in test_cases:\n        max_delta_chi = 0.0\n        max_delta_u = 0.0\n\n        num_snaps = int(np.ceil(cosmo.Z_MAX / delta_z)) + 1\n        snapshot_redshifts = np.linspace(cosmo.Z_MAX, 0, num_snaps)\n\n        for gal in galaxies:\n            f_exact = lambda z: gal.x_z(z) - cosmo.chi_z(z)\n            \n            # Find bracketing interval\n            f_vals = np.array([f_exact(z) for z in snapshot_redshifts])\n            \n            # Sign change indicates interval containing the root\n            signs = np.sign(f_vals)\n            sign_changes = np.where(np.diff(signs))[0]\n            \n            if len(sign_changes) == 0:\n                # Should not happen for the given parameters\n                continue\n            \n            idx_upper = sign_changes[0]\n            z_upper = snapshot_redshifts[idx_upper]     # z_i\n            z_lower = snapshot_redshifts[idx_upper + 1] # z_{i+1}\n\n            # 1. Find exact crossing z_star\n            z_star = brentq(f_exact, z_lower, z_upper)\n            chi_star = cosmo.chi_z(z_star)\n\n            # 2. Prepare snapshot data for interpolation\n            t_upper = cosmo.t_z(z_upper)\n            t_lower = cosmo.t_z(z_lower)\n            delta_t_snap = t_lower - t_upper\n\n            # 3. Interpolation and solving for z_hat\n            z_hat = 0.0\n            u_hat_kms = 0.0\n\n            if scheme == 'C':\n                x_upper = gal.x_z(z_upper)\n                x_lower = gal.x_z(z_lower)\n                \n                def g_c(z):\n                    tz = cosmo.t_z(z)\n                    x_lin_t = x_upper + (x_lower - x_upper) * (tz - t_upper) / delta_t_snap\n                    return x_lin_t - cosmo.chi_z(z)\n                \n                z_hat = brentq(g_c, z_lower, z_upper)\n                \n                a_upper, a_lower, a_hat = 1/(1+z_upper), 1/(1+z_lower), 1/(1+z_hat)\n                v_c_upper = gal.u_p_mpcgyr / a_upper\n                v_c_lower = gal.u_p_mpcgyr / a_lower\n                t_hat = cosmo.t_z(z_hat)\n                \n                v_c_lin_hat = v_c_upper + (v_c_lower - v_c_upper) * (t_hat - t_upper) / delta_t_snap\n                u_hat_mpcgyr = a_hat * v_c_lin_hat\n                u_hat_kms = u_hat_mpcgyr / cosmo.MPC_GYR_PER_KM_S\n\n            elif scheme == 'P':\n                a_upper, a_lower = 1/(1+z_upper), 1/(1+z_lower)\n                x_upper, x_lower = gal.x_z(z_upper), gal.x_z(z_lower)\n                r_upper, r_lower = a_upper * x_upper, a_lower * x_lower\n\n                def g_p(z):\n                    tz = cosmo.t_z(z)\n                    az = 1.0 / (1.0 + z)\n                    r_lin_t = r_upper + (r_lower - r_upper) * (tz - t_upper) / delta_t_snap\n                    return (r_lin_t / az) - cosmo.chi_z(z)\n                \n                z_hat = brentq(g_p, z_lower, z_upper)\n                u_hat_kms = gal.u_p_kms\n\n            # 4. Calculate errors\n            chi_hat = cosmo.chi_z(z_hat)\n            delta_chi = abs(chi_hat - chi_star)\n            delta_u = abs(u_hat_kms - gal.u_p_kms)\n\n            # 5. Update max errors\n            max_delta_chi = max(max_delta_chi, delta_chi)\n            max_delta_u = max(max_delta_u, delta_u)\n\n        final_results.append(f\"{max_delta_chi:.6f}\")\n        final_results.append(f\"{max_delta_u:.6f}\")\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "模拟星表的最终目的之一是促进理论模型与观测数据之间的比较。这种比较通常在统计学框架下完成，通过一个恰当考虑了不同测量区间之间相关性（通过协方差矩阵）的 $\\chi^2$ 统计量来量化拟合优度。这项练习  为宇宙学中的现代统计数据分析提供了至关重要的训练，涵盖了 $\\chi^2$ 似然的构建，以及使用从有限数量的模拟中估计出的协方差矩阵时的微妙之处，包括必要的 Hartlap 修正。",
            "id": "3477572",
            "problem": "将从巡天光锥中测量的星系分箱汇总统计量与模拟星表生成器的预测进行比较。根据中心极限定理，该分箱汇总向量可以很好地用一个多元正态分布来近似，其均值等于模拟预测值，协方差则从一组独立的模拟光锥实现中估计。这种设定在数值宇宙学中很常见，用于评估模拟星表与数据的拟合优度。你的任务是实现一个程序，给定几个数据和模拟汇总向量的测试用例，以及它们从模拟星表中估计出的完整协方差矩阵，该程序需要构建一个从多元高斯对数似然导出的标量拟合优度诊断量，在适当时使用偏差校正的逆协方差，并返回原假设下的相关尾部概率和一个在指定显著性水平上接受或拒绝的布尔决策。\n\n从以下有效基础出发：用于分箱汇总统计量的多元正态分布、协方差矩阵的性质以及自由度的统计定义。不要使用本说明中提供给你的任何快捷公式；相反，应在你的解决方案中从第一性原理推导出必要的表达式。你的算法必须：\n- 对每个测试用例使用完整的协方差矩阵。\n- 稳健地求协方差的逆。如果协方差在数值上不是正定的，则通过添加一个小的对角脊来正则化它，直到获得稳定的Cholesky分解。如果经过合理尝试后无法获得Cholesky分解，则退而使用Moore–Penrose伪逆。\n- 当协方差是从有限数量的独立模拟（$N_s$）中估计得出时，如果 $N_s  n_b + 2$（其中 $n_b$ 是分箱数），则使用Hartlap校正来对逆协方差进行去偏。具体来说，如果适用，将样本协方差的逆乘以因子 $\\alpha = \\dfrac{N_s - n_b - 2}{N_s - 1}$；否则，不应用此校正，并依赖于上述的正则化逆矩阵。\n- 计算由多元高斯对数似然所蕴含的标量诊断量，以及在模拟是正确的原假设下的相应上尾概率（生存函数）。在此比较中，由于模拟预测被视为固定的，因此使用分箱数 $n_b$ 作为自由度。\n- 使用 $0.05$ 的显著性水平来决定拟合是否可接受。当上尾概率大于或等于 $0.05$ 时，报告一个布尔值 $True$，否则报告 $False$。\n\n测试套件规范：\n对于每个测试用例，巡天数据的分箱汇总向量 $\\boldsymbol{d}$ 和模拟预测 $\\boldsymbol{m}$ 都有 $n_b = 6$ 个分箱。完整的协方差 $\\boldsymbol{C}$ 通过一个相关模型和分箱方差来指定。定义一个每个分箱标准差的向量 $\\boldsymbol{s}$ 和一个相关系数 $\\rho$，并构建\n$$\nC_{ij} = \\rho^{|i-j|} s_i s_j \\quad \\text{for } i,j \\in \\{1,\\dots,6\\}.\n$$\n这会产生一个具有指数衰减相关性的对称协方差。对于每个测试用例，$N_s$ 表示用于估计协方差的独立模拟光锥的数量。最终输出的无量纲诊断量不需要汇总统计量的单位，但作为背景信息，这些值可能对应于以 $h/\\mathrm{Mpc}$ 为单位的波数分箱中的功率谱单极矩，单位为 $(\\mathrm{Mpc}/h)^3$。程序不需要使用物理单位。\n\n提供以下四个测试用例：\n- 情况A（理想情况，良态协方差和大量模拟）：\n  - $N_s = 500$\n  - $\\boldsymbol{s} = [50, 45, 40, 38, 35, 33]$\n  - $\\rho = 0.35$\n  - $\\boldsymbol{d} = [1000, 850, 720, 600, 500, 420]$\n  - $\\boldsymbol{m} = [980, 860, 710, 610, 510, 430]$\n- 情况B（边界条件，近奇异协方差且模拟数量太少无法使用Hartlap校正）：\n  - $N_s = 8$\n  - $\\boldsymbol{s} = [30, 30, 30, 30, 30, 30]$\n  - $\\rho = 0.99$\n  - $\\boldsymbol{d} = [500, 480, 470, 460, 450, 440]$\n  - $\\boldsymbol{m} = [520, 500, 490, 480, 470, 460]$\n- 情况C（边缘情况，完美拟合）：\n  - $N_s = 300$\n  - $\\boldsymbol{s} = [20, 18, 17, 16, 15, 14]$\n  - $\\rho = 0.20$\n  - $\\boldsymbol{d} = [600, 550, 510, 480, 450, 420]$\n  - $\\boldsymbol{m} = [600, 550, 510, 480, 450, 420]$\n- 情况D（拟合不佳，残差大）：\n  - $N_s = 100$\n  - $\\boldsymbol{s} = [25, 25, 25, 25, 25, 25]$\n  - $\\rho = 0.10$\n  - $\\boldsymbol{d} = [800, 820, 790, 810, 780, 805]$\n  - $\\boldsymbol{m} = [700, 940, 710, 900, 670, 935]$\n\n你的程序应按顺序处理这四个情况。对于每个情况，计算：\n- 来自多元高斯对数似然的标量诊断量。\n- 自由度 $n_b$。\n- 原假设下的上尾概率。\n- 在 $0.05$ 显著性水平下的布尔决策。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含四个情况的结果列表。每个情况的结果必须是按 $[\\text{诊断量}, \\text{dof}, \\text{p值}, \\text{布尔值}]$ 顺序排列的四个值的列表。浮点数应四舍五入到六位小数，整数自由度应为精确值，布尔值应为 $True$ 或 $False$。例如，输出必须如下所示：\n$[[x_1, \\text{dof}, p_1, b_1],[x_2, \\text{dof}, p_2, b_2],[x_3, \\text{dof}, p_3, b_3],[x_4, \\text{dof}, p_4, b_4]]$\n其中 $x_i$ 和 $p_i$ 是四舍五入到六位小数的浮点数，$\\text{dof}$ 是整数 $6$，$b_i$ 是布尔值。",
            "solution": "该问题要求实现一个统计检验，以评估观测数据向量与模型预测之间的拟合优度，这是宇宙学数据分析中的一项常见任务。\n\n首先，我们建立理论框架。在多元正态假设下，一个 $n_b$ 维数据向量 $\\boldsymbol{d}$ 的概率密度函数（PDF），其均值向量为 $\\boldsymbol{\\mu}$，协方差矩阵为 $\\boldsymbol{C}$，由下式给出：\n$$\nP(\\boldsymbol{d} | \\boldsymbol{\\mu}, \\boldsymbol{C}) = \\frac{1}{(2\\pi)^{n_b/2} \\det(\\boldsymbol{C})^{1/2}} \\exp\\left( -\\frac{1}{2} (\\boldsymbol{d}-\\boldsymbol{\\mu})^T \\boldsymbol{C}^{-1} (\\boldsymbol{d}-\\boldsymbol{\\mu}) \\right)\n$$\n因此，对数似然 $\\mathcal{L} = \\ln P$ 为：\n$$\n\\mathcal{L}(\\boldsymbol{\\mu}, \\boldsymbol{C} | \\boldsymbol{d}) = -\\frac{n_b}{2} \\ln(2\\pi) - \\frac{1}{2} \\ln(\\det(\\boldsymbol{C})) - \\frac{1}{2} (\\boldsymbol{d}-\\boldsymbol{\\mu})^T \\boldsymbol{C}^{-1} (\\boldsymbol{d}-\\boldsymbol{\\mu})\n$$\n在拟合优度检验中，我们关心的是数据 $\\boldsymbol{d}$ 与模型符合的程度，模型为均值提供了一个固定的预测值 $\\boldsymbol{\\mu} = \\boldsymbol{m}$。似然函数指数中的项量化了数据与模型之间的平方距离，并由逆协方差加权。这种二次型是马氏距离的平方，它定义了卡方（$\\chi^2$）统计量：\n$$\n\\chi^2 = (\\boldsymbol{d}-\\boldsymbol{m})^T \\boldsymbol{C}^{-1} (\\boldsymbol{d}-\\boldsymbol{m})\n$$\n这个 $\\chi^2$ 值就是所需的标量诊断量。在原假设（即数据 $\\boldsymbol{d}$ 是从分布 $\\mathcal{N}(\\boldsymbol{m}, \\boldsymbol{C})$ 中随机实现的一个样本）下，$\\chi^2$ 统计量服从自由度为 $n_b$ 的卡方分布。自由度的数量等于数据向量的维度 $n_b$，因为均值向量 $\\boldsymbol{m}$ 是模型的固定预测，而不是根据数据 $\\boldsymbol{d}$ 拟合得出的。对于本问题，$n_b=6$。\n\n协方差矩阵 $\\boldsymbol{C}$ 本身是从 $N_s$ 个模拟实现的有限样本中估计的。样本协方差矩阵是真实协方差的无偏估计量，但其逆 $(\\hat{\\boldsymbol{C}})^{-1}$ 是真实逆矩阵 $\\boldsymbol{C}^{-1}$ 的有偏估计量。为了校正这种偏差，Anderson (1963) 和 Hartlap, Simon  Schneider (2007) 指出，样本协方差矩阵的逆应通过一个因子 $\\alpha$ 进行重缩放。该校正适用于样本数量 $N_s$ 大于数据分箱数 $n_b$ 加二的情况，即 $N_s  n_b + 2$。无偏的精度矩阵 $\\boldsymbol{\\Psi} = \\boldsymbol{C}^{-1}$ 随后估计为：\n$$\n\\hat{\\boldsymbol{\\Psi}}_{\\text{debiased}} = \\alpha (\\hat{\\boldsymbol{C}})^{-1} = \\left(\\frac{N_s - n_b - 2}{N_s - 1}\\right) (\\hat{\\boldsymbol{C}})^{-1}\n$$\n如果不满足条件 $N_s  n_b + 2$，则不应用此校正，我们使用（有偏的）逆矩阵 $(\\hat{\\boldsymbol{C}})^{-1}$。\n\n每个测试用例的算法流程如下：\n1.  使用指定模型构建 $n_b \\times n_b$ 的协方差矩阵 $\\boldsymbol{C}$：$C_{ij} = \\rho^{|i-j|} s_i s_j$，其中 $i, j \\in \\{0, 1, \\dots, 5\\}$。\n2.  计算逆协方差矩阵 $\\boldsymbol{C}^{-1}$。此步骤需要稳健的数值方法。主要方法是使用Cholesky分解来检验正定性。如果失败，说明该矩阵在数值上不是正定的。然后我们通过添加一个小的对角分量 $\\epsilon\\boldsymbol{I}$（其中 $\\boldsymbol{I}$ 是单位矩阵）来对其进行正则化。我们迭代地增加 $\\epsilon$（例如，从 $10^{-12}$ 开始，每次乘以10），直到正则化后的矩阵 $\\boldsymbol{C} + \\epsilon\\boldsymbol{I}$ 的Cholesky分解成功。如果此正则化过程在合理次数的尝试后仍然失败，我们退而计算Moore-Penrose伪逆 $\\boldsymbol{C}^{+}$ 作为有效逆矩阵。\n3.  如果 $N_s  n_b + 2$，则对计算出的逆矩阵应用Hartlap校正因子 $\\alpha$。令最终的精度矩阵为 $\\boldsymbol{\\Psi}_{final}$。\n4.  计算 $\\chi^2$ 统计量：$\\chi^2 = (\\boldsymbol{d}-\\boldsymbol{m})^T \\boldsymbol{\\Psi}_{final} (\\boldsymbol{d}-\\boldsymbol{m})$。\n5.  确定p值，即 $\\chi^2$ 统计量在自由度为 $dof = n_b = 6$ 的卡方分布下的上尾概率。这由生存函数给出，$p = SF(\\chi^2 | dof)$。\n6.  将p值与显著性水平 $\\alpha_{sig} = 0.05$ 进行比较。如果 $p \\geq 0.05$，则模型不被拒绝，结果为 $True$。否则，模型被拒绝，结果为 $False$。\n\n将此流程应用于所提供的四个测试用例中的每一个，从而得出所需的一组诊断值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the goodness-of-fit problem for the provided test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A (happy path, well-conditioned covariance and many mocks)\n        {\n            \"d\": np.array([1000, 850, 720, 600, 500, 420]),\n            \"m\": np.array([980, 860, 710, 610, 510, 430]),\n            \"s\": np.array([50, 45, 40, 38, 35, 33]),\n            \"rho\": 0.35,\n            \"N_s\": 500\n        },\n        # Case B (boundary condition, nearly singular covariance and too few mocks for Hartlap)\n        {\n            \"d\": np.array([500, 480, 470, 460, 450, 440]),\n            \"m\": np.array([520, 500, 490, 480, 470, 460]),\n            \"s\": np.array([30, 30, 30, 30, 30, 30]),\n            \"rho\": 0.99,\n            \"N_s\": 8\n        },\n        # Case C (edge case, perfect fit)\n        {\n            \"d\": np.array([600, 550, 510, 480, 450, 420]),\n            \"m\": np.array([600, 550, 510, 480, 450, 420]),\n            \"s\": np.array([20, 18, 17, 16, 15, 14]),\n            \"rho\": 0.20,\n            \"N_s\": 300\n        },\n        # Case D (poor fit, large residuals)\n        {\n            \"d\": np.array([800, 820, 790, 810, 780, 805]),\n            \"m\": np.array([700, 940, 710, 900, 670, 935]),\n            \"s\": np.array([25, 25, 25, 25, 25, 25]),\n            \"rho\": 0.10,\n            \"N_s\": 100\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_goodness_of_fit(**case)\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    formatted_results = []\n    for res_list in results:\n        chi2_val, dof, p_val, decision = res_list\n        formatted_list = f\"[{chi2_val:.6f},{dof},{p_val:.6f},{str(decision)}]\"\n        formatted_results.append(formatted_list)\n        \n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    # Python's bool `True` needs to be lowercase `true` for some interpreters\n    final_output_string = final_output_string.replace('True', 'true').replace('False', 'false')\n    print(final_output_string)\n\ndef construct_covariance(s, rho, n_b):\n    \"\"\"\n    Constructs the covariance matrix from standard deviations and a correlation model.\n    \"\"\"\n    C = np.zeros((n_b, n_b))\n    for i in range(n_b):\n        for j in range(n_b):\n            C[i, j] = (rho**abs(i - j)) * s[i] * s[j]\n    return C\n\ndef robust_inverse(C):\n    \"\"\"\n    Computes a robust inverse of a matrix, handling non-positive-definite cases.\n    \"\"\"\n    n_b = C.shape[0]\n    # First, attempt a Cholesky decomposition to check for positive-definiteness.\n    try:\n        np.linalg.cholesky(C)\n        # If the matrix is positive-definite, a standard inverse is safe and efficient.\n        return np.linalg.inv(C)\n    except np.linalg.LinAlgError:\n        # The matrix is not numerically positive-definite.\n        # Fallback 1: Add a small diagonal ridge and re-attempt Cholesky.\n        eps = 1e-12\n        for _ in range(15):  # Limit the number of regularization attempts\n            try:\n                C_reg = C + eps * np.identity(n_b)\n                np.linalg.cholesky(C_reg)\n                # If Cholesky succeeds, the regularized matrix is PD. Invert it.\n                return np.linalg.inv(C_reg)\n            except np.linalg.LinAlgError:\n                # Increase epsilon and try again.\n                eps *= 10\n        \n        # Fallback 2: If regularization repeatedly fails, use the Moore-Penrose pseudoinverse.\n        return np.linalg.pinv(C)\n\ndef compute_goodness_of_fit(d, m, s, rho, N_s, n_b=6, significance_level=0.05):\n    \"\"\"\n    Computes the goodness-of-fit diagnostics for a single case.\n    \"\"\"\n    # 1. Construct the covariance matrix\n    C = construct_covariance(s, rho, n_b)\n\n    # 2. Compute the robust inverse of the covariance matrix\n    C_inv = robust_inverse(C)\n\n    # 3. Apply the Hartlap correction to debias the inverse if applicable\n    if N_s > n_b + 2:\n        hartlap_factor = (N_s - n_b - 2) / (N_s - 1)\n        # The final precision matrix is the debiased inverse\n        precision_matrix = hartlap_factor * C_inv\n    else:\n        # If not applicable, use the computed inverse as is\n        precision_matrix = C_inv\n\n    # 4. Compute the chi-squared statistic\n    delta_v = d - m\n    chi_squared_val = delta_v.T @ precision_matrix @ delta_v\n    \n    # 5. Compute the degrees of freedom and the p-value\n    dof = n_b\n    p_value = chi2.sf(chi_squared_val, dof)\n\n    # 6. Make the acceptance/rejection decision\n    is_acceptable = p_value >= significance_level\n\n    return [chi_squared_val, dof, p_value, is_acceptable]\n\n# Execute the main function, correcting boolean string representation\ntry:\n    original_bool_repr = np.bool_.__repr__\n    np.bool_.__repr__ = lambda self: str(self).lower()\n    solve()\nfinally:\n    np.bool_.__repr__ = original_bool_repr\n```"
        }
    ]
}