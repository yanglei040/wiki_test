{
    "hands_on_practices": [
        {
            "introduction": "To truly master numerical hydrodynamics, one must first understand the exact solution that approximate methods aim to capture. This foundational exercise challenges you to implement an exact Riemann solver for the 1D Euler equations from first principles . By deriving and solving the non-linear equations for the intermediate 'star' region, you will gain a deep, analytical understanding of the wave structure—shocks, rarefactions, and contact discontinuities—that governs the evolution of ideal fluids.",
            "id": "3484431",
            "problem": "Implement an exact Riemann solver for the one-dimensional Euler equations of an ideal gas, appropriate for use in high-resolution Godunov-type methods in numerical cosmology. You must work from first principles of conservation laws and self-similarity. The Riemann problem consists of two constant states, left and right, separated by a discontinuity at position $x = 0$ at time $t = 0$. For an ideal gas, the pressure $p$, mass density $\\rho$, and velocity $u$ are related by the ideal gas equation of state with ratio of specific heats $\\gamma$. The one-dimensional Euler equations express conservation of mass, momentum, and energy. Assume piecewise constant initial data with left state $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}})$ for $x  0$ and right state $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}})$ for $x  0$, with constant $\\gamma  1$. All quantities are in a consistent, dimensionless unit system (no physical units required), and you must ensure positivity of density and pressure in all intermediate states of your computation.\n\nStarting from conservation across shocks (Rankine–Hugoniot conditions) and self-similar rarefaction wave relations derived from the Euler equations and the ideal gas law, derive the scalar non-linear equation whose unique root gives the intermediate (star region) pressure $p_\\star$. Then derive the associated star-region velocity $u_\\star$. Your solver must be robust for both shock and rarefaction waves on either side, and it must correctly sample the self-similar solution at a given similarity coordinate $\\xi = x/t$. For this problem, you must evaluate the density $\\rho(\\xi)$ at $\\xi = 0$.\n\nYour program must:\n- Given $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}})$, $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}})$, and $\\gamma$, compute the exact star-region pressure $p_\\star$ and velocity $u_\\star$ by solving the non-linear equation implied by conservation and self-similarity.\n- From the full wave-pattern classification (shock or rarefaction on each side), sample the exact self-similar solution at $\\xi = 0$ and return the density $\\rho(\\xi=0)$.\n- Use a numerically stable and convergent root-finding approach that does not assume a particular wave pattern in advance. Robustly handle both strong shocks and rarefactions, as well as nearly equal left and right states.\n\nTest suite:\nProvide results for the following four independent test cases, all in dimensionless code units:\n- Case $1$ (Sod-type): $\\gamma = 1.4$, $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (1.0, 0.0, 1.0)$, $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (0.125, 0.0, 0.1)$.\n- Case $2$ (Lax-type): $\\gamma = 1.4$, $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (0.445, 0.698, 3.528)$, $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (0.5, 0.0, 0.571)$.\n- Case $3$ (strong shock): $\\gamma = 1.4$, $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (1.0, 0.0, 1000.0)$, $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (1.0, 0.0, 0.01)$.\n- Case $4$ (near-equilibrium moving contact): $\\gamma = 1.4$, $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (1.0, 0.1, 1.0)$, $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (1.0, 0.1, 1.0)$.\n\nFor each case, output three floats: the star pressure $p_\\star$, the star velocity $u_\\star$, and the sampled density at $\\xi = 0$, denoted $\\rho(\\xi=0)$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered sequentially by case and within each case by $(p_\\star, u_\\star, \\rho(\\xi=0))$. For example, your output must have the form\n$[\\;p_{\\star,1},u_{\\star,1},\\rho_1(0),\\;p_{\\star,2},u_{\\star,2},\\rho_2(0),\\;p_{\\star,3},u_{\\star,3},\\rho_3(0),\\;p_{\\star,4},u_{\\star,4},\\rho_4(0)\\;]$.\n\nNotes:\n- You must not hard-code any of the target values for $p_\\star$, $u_\\star$, or $\\rho(\\xi=0)$. They must be computed from the stated first-principles relations.\n- Ensure your algorithm correctly selects shock versus rarefaction branches and remains robust for strong discontinuities.",
            "solution": "The user-provided problem is a well-posed and standard task in computational fluid dynamics: the implementation of an exact Riemann solver for the one-dimensional Euler equations with an ideal gas equation of state. The problem is scientifically grounded, free of contradictions, and provides all necessary information for a unique solution. Therefore, it is deemed valid.\n\nThe solution to the Riemann problem is self-similar, meaning it depends only on the similarity coordinate $\\xi = x/t$. The structure consists of two outer states (Left, $\\mathrm{L}$, and Right, $\\mathrm{R}$) separated by an inner pattern of three waves: a left-going wave, a contact discontinuity, and a right-going wave. The regions between the waves are constant states, known as the \"star\" regions ($\\star_{\\mathrm{L}}$ and $\\star_{\\mathrm{R}}$).\n\nAcross the central contact discontinuity, which moves with velocity $u_\\star$, both pressure and velocity are continuous: $p_{\\star \\mathrm{L}} = p_{\\star \\mathrm{R}} = p_\\star$ and $u_{\\star \\mathrm{L}} = u_{\\star \\mathrm{R}} = u_\\star$. The density, however, is generally discontinuous. The left and right waves can be either shock waves or rarefaction waves, depending on whether the star pressure $p_\\star$ is greater or less than the pressure in the adjacent outer state.\n\nThe core of the problem is to find the two unknown quantities, $p_\\star$ and $u_\\star$. This is achieved by relating the star state to each of the initial states through the appropriate wave relations (Rankine-Hugoniot for shocks, isentropic relations for rarefactions) and enforcing the equality of pressure and velocity in the star region.\n\nThis procedure leads to two separate equations for $u_\\star$ as a function of $p_\\star$, one derived from the left state and one from the right:\n$u_\\star = u_{\\mathrm{L}} \\pm f_{\\mathrm{L}}(p_\\star, \\rho_{\\mathrm{L}}, p_{\\mathrm{L}})$\n$u_\\star = u_{\\mathrm{R}} \\mp f_{\\mathrm{R}}(p_\\star, \\rho_{\\mathrm{R}}, p_{\\mathrm{R}})$\n\nA robust formulation is to define a function $f_k(p, \\rho_k, p_k, \\gamma)$ that represents the change in fluid velocity across the wave connecting state $k$ to the star region, where $k \\in \\{\\mathrm{L, R}\\}$. Equating the two expressions for $u_\\star$ yields a single non-linear scalar equation for $p_\\star$:\n$$W(p_\\star) \\equiv f_\\mathrm{L}(p_\\star) + f_\\mathrm{R}(p_\\star) + u_\\mathrm{R} - u_\\mathrm{L} = 0$$\nThe function $f_k$ has two distinct forms.\n\n**1. Shock Wave ($p_\\star > p_k$)**: The Rankine-Hugoniot jump conditions yield:\n$$f_k(p_\\star) = (p_\\star - p_k) \\left[ \\frac{2 / ((\\gamma+1)\\rho_k)}{p_\\star + \\frac{\\gamma-1}{\\gamma+1}p_k} \\right]^{1/2}$$\n\n**2. Rarefaction Wave ($p_\\star \\le p_k$)**: The isentropic relations and Riemann invariants give:\n$$f_k(p_\\star) = \\frac{2 a_k}{\\gamma-1} \\left[ \\left(\\frac{p_\\star}{p_k}\\right)^{\\frac{\\gamma-1}{2\\gamma}} - 1 \\right]$$\nwhere $a_k = \\sqrt{\\gamma p_k / \\rho_k}$ is the sound speed in state $k$.\n\nThe function $W(p)$ is monotonic and concave, making it suitable for solution via Newton-Raphson iteration. The iterative step is $p_{n+1} = p_n - W(p_n) / W'(p_n)$, where $W'(p) = f'_\\mathrm{L}(p) + f'_\\mathrm{R}(p)$. The derivatives $f'_k(p)$ are:\n- For a shock: $f'_k(p) = \\left(1 - \\frac{p-p_k}{2(B_k+p)}\\right) \\left( \\frac{A_k}{p+B_k} \\right)^{1/2}$, with $A_k=\\frac{2}{(\\gamma+1)\\rho_k}$ and $B_k=\\frac{\\gamma-1}{\\gamma+1}p_k$.\n- For a rarefaction: $f'_k(p) = \\frac{1}{\\rho_k a_k} \\left(\\frac{p}{p_k}\\right)^{-\\frac{\\gamma+1}{2\\gamma}}$.\n\nOnce $p_\\star$ is found, the star velocity $u_\\star$ is calculated by averaging the expressions from both sides:\n$$u_\\star = \\frac{1}{2}(u_\\mathrm{L} + u_\\mathrm{R}) + \\frac{1}{2}(f_\\mathrm{R}(p_\\star) - f_\\mathrm{L}(p_\\star))$$\n\nThe final step is to sample the solution at $\\xi = x/t = 0$ to find the density $\\rho(\\xi=0)$. This requires identifying which region of the self-similar solution pattern contains the point $\\xi=0$. The regions are delimited by the speeds of the various waves. The logic is as follows:\n- The contact discontinuity moves at speed $u_\\star$.\n- If $\\xi=0  u_\\star$, the sampling point is to the left of the contact discontinuity. The state depends on the left wave structure (shock or rarefaction) and its speed(s).\n- If $\\xi=0  u_\\star$, the sampling point is to the right of the contact. The state depends on the right wave.\n- If $\\xi=0 = u_\\star$, the point lies on the contact, where density is discontinuous. The problem is resolved by the limiting behavior: the region is determined by whether we approach from $\\xi  u_\\star$ or $\\xi  u_\\star$. The adopted convention is that $\\xi  u_\\star$ corresponds to the left-side solution structure.\n\nThe wave speeds required are:\n- **Shock speed**: $S_k = u_k \\mp \\sqrt{\\frac{(\\gamma+1)p_\\star + (\\gamma-1)p_k}{2\\rho_k}}$ ($-$ for left wave, $+$ for right).\n- **Rarefaction head speed**: $S_{Hk} = u_k \\mp a_k$.\n- **Rarefaction tail speed**: $S_{Tk} = u_\\star \\mp a_{\\star k}$, where $a_{\\star k} = \\sqrt{\\gamma p_\\star / \\rho_{\\star k}}$.\n- The density in the star region, $\\rho_{\\star k}$, is needed for $a_{\\star k}$ and depends on the wave type:\n    - Shock: $\\rho_{\\star k} = \\rho_k \\frac{p_\\star/p_k + (\\gamma-1)/(\\gamma+1)}{(\\gamma-1)/(\\gamma+1) \\cdot p_\\star/p_k + 1}$\n    - Rarefaction: $\\rho_{\\star k} = \\rho_k (p_\\star/p_k)^{1/\\gamma}$\n\nIf the sampling point $\\xi=0$ falls within a rarefaction fan, the density must be computed from the continuous solution inside the fan. For the left fan ($1$-family), $\\xi = u-a$ and the Riemann invariant $u + \\frac{2a}{\\gamma-1} = \\text{const}$ holds. For $\\xi=0$, we find the local sound speed $a$ and then the density $\\rho = \\rho_\\mathrm{L} (a/a_\\mathrm{L})^{2/(\\gamma-1)}$. A similar logic applies to the right fan.\n\nThe following implementation encapsulates this logic in a robust program.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Riemann solver on the specified test cases\n    and print the results in the required format.\n    \"\"\"\n    \n    # Small tolerance for floating point comparisons and to prevent division by zero.\n    TOL = 1e-9\n\n    def wave_function(p, rho_k, p_k, gamma):\n        \"\"\"\n        Computes the velocity contribution function f_k(p) for either a shock or rarefaction wave.\n        p: pressure to evaluate at (p_star).\n        rho_k, p_k: density and pressure in the initial state k (L or R).\n        gamma: ratio of specific heats.\n        \"\"\"\n        if p_k = 0 or rho_k = 0:\n            raise ValueError(\"Pressure and density must be positive.\")\n        \n        a_k = np.sqrt(gamma * p_k / rho_k)\n\n        if p  p_k:  # Shock wave\n            A_k = 2.0 / ((gamma + 1.0) * rho_k)\n            B_k = (gamma - 1.0) / (gamma + 1.0) * p_k\n            return (p - p_k) * np.sqrt(A_k / (p + B_k))\n\n        else:  # Rarefaction wave\n            g1 = (gamma - 1.0) / (2.0 * gamma)\n            return (2.0 * a_k / (gamma - 1.0)) * ((p / p_k)**g1 - 1.0)\n\n    def wave_function_derivative(p, rho_k, p_k, gamma):\n        \"\"\"\n        Computes the derivative f'_k(p) for the Newton-Raphson solver.\n        \"\"\"\n        if p_k = 0 or rho_k = 0 or p = 0:\n            raise ValueError(\"Pressure and density must be positive.\")\n            \n        a_k = np.sqrt(gamma * p_k / rho_k)\n\n        if p  p_k: # Shock wave\n            A_k = 2.0 / ((gamma + 1.0) * rho_k)\n            B_k = (gamma - 1.0) / (gamma + 1.0) * p_k\n            \n            term1 = np.sqrt(A_k / (p + B_k))\n            term2 = (p - p_k) / (2.0 * (p + B_k))\n            return term1 * (1.0 - term2)\n            \n        else: # Rarefaction wave\n            g1 = -(gamma + 1.0) / (2.0 * gamma)\n            return (1.0 / (rho_k * a_k)) * (p / p_k)**g1\n\n    def solve_for_star_pressure(state_L, state_R, gamma):\n        \"\"\"\n        Solves for the star pressure p_star using Newton-Raphson iteration.\n        The function to solve is W(p) = f_L(p) + f_R(p) + u_R - u_L = 0.\n        \"\"\"\n        rho_L, u_L, p_L = state_L\n        rho_R, u_R, p_R = state_R\n        \n        def pressure_func(p):\n            return wave_function(p, rho_L, p_L, gamma) + wave_function(p, rho_R, p_R, gamma) + (u_R - u_L)\n\n        def pressure_func_deriv(p):\n            return wave_function_derivative(p, rho_L, p_L, gamma) + wave_function_derivative(p, rho_R, p_R, gamma)\n\n        p_guess = 0.5 * (p_L + p_R)\n        p_star = max(TOL, p_guess)\n        \n        max_iter = 20\n        for _ in range(max_iter):\n            f_val = pressure_func(p_star)\n            df_val = pressure_func_deriv(p_star)\n            \n            dp = f_val / df_val if abs(df_val)  TOL else 0.0\n            p_star -= dp\n            \n            p_star = max(TOL, p_star)\n\n            if abs(dp)  TOL * p_star or abs(dp)  TOL:\n                break\n\n        return p_star\n\n    def solve_riemann_and_sample(gamma, state_L, state_R):\n        \"\"\"\n        Solves the Riemann problem and samples the solution at xi=0.\n        Returns (p_star, u_star, rho_at_xi_0).\n        \"\"\"\n        rho_L, u_L, p_L = state_L\n        rho_R, u_R, p_R = state_R\n        \n        if abs(rho_L - rho_R)  TOL and abs(u_L - u_R)  TOL and abs(p_L - p_R)  TOL:\n           return (p_L, u_L, rho_L)\n        \n        p_star = solve_for_star_pressure(state_L, state_R, gamma)\n\n        fL = wave_function(p_star, rho_L, p_L, gamma)\n        fR = wave_function(p_star, rho_R, p_R, gamma)\n        u_star = 0.5 * (u_L + u_R) + 0.5 * (fR - fL)\n\n        xi = 0.0\n        rho_at_xi_0 = 0.0\n\n        g1 = (gamma - 1.0) / (gamma + 1.0)\n        g3 = 2.0 / (gamma - 1.0)\n        g4 = 2.0 / (gamma + 1.0)\n\n        if xi  u_star:\n            if p_star  p_L:\n                S_L = u_L - np.sqrt(((gamma + 1.0) * p_star + (gamma - 1.0) * p_L) / (2.0 * rho_L))\n                if xi  S_L:\n                    rho_at_xi_0 = rho_L\n                else:\n                    rho_star_L = rho_L * (p_star / p_L + g1) / (g1 * p_star / p_L + 1.0)\n                    rho_at_xi_0 = rho_star_L\n            else:\n                a_L = np.sqrt(gamma * p_L / rho_L)\n                S_HL = u_L - a_L\n                if xi  S_HL:\n                    rho_at_xi_0 = rho_L\n                else:\n                    rho_star_L = rho_L * (p_star / p_L)**(1.0 / gamma)\n                    a_star_L = np.sqrt(gamma * p_star / rho_star_L)\n                    S_TL = u_star - a_star_L\n                    if xi  S_TL:\n                        rho_at_xi_0 = rho_star_L\n                    else:\n                        rho_fan = rho_L * (g4 + g1 * (u_L - xi) / a_L)**g3\n                        rho_at_xi_0 = rho_fan\n        else:\n            if p_star  p_R:\n                S_R = u_R + np.sqrt(((gamma + 1.0) * p_star + (gamma - 1.0) * p_R) / (2.0 * rho_R))\n                if xi  S_R:\n                    rho_at_xi_0 = rho_R\n                else:\n                    rho_star_R = rho_R * (p_star / p_R + g1) / (g1 * p_star / p_R + 1.0)\n                    rho_at_xi_0 = rho_star_R\n            else:\n                a_R = np.sqrt(gamma * p_R / rho_R)\n                S_HR = u_R + a_R\n                if xi  S_HR:\n                    rho_at_xi_0 = rho_R\n                else:\n                    rho_star_R = rho_R * (p_star / p_R)**(1.0 / gamma)\n                    a_star_R = np.sqrt(gamma * p_star / rho_star_R)\n                    S_TR = u_star + a_star_R\n                    if xi  S_TR:\n                        rho_at_xi_0 = rho_star_R\n                    else:\n                        rho_fan = rho_R * (g4 - g1 * (u_R - xi) / a_R)**g3\n                        rho_at_xi_0 = rho_fan\n\n        return p_star, u_star, rho_at_xi_0\n\n    test_cases = [\n        {'gamma': 1.4, 'state_L': (1.0, 0.0, 1.0), 'state_R': (0.125, 0.0, 0.1)},\n        {'gamma': 1.4, 'state_L': (0.445, 0.698, 3.528), 'state_R': (0.5, 0.0, 0.571)},\n        {'gamma': 1.4, 'state_L': (1.0, 0.0, 1000.0), 'state_R': (1.0, 0.0, 0.01)},\n        {'gamma': 1.4, 'state_L': (1.0, 0.1, 1.0), 'state_R': (1.0, 0.1, 1.0)}\n    ]\n\n    results = []\n    for case in test_cases:\n        p_star, u_star, rho_at_0 = solve_riemann_and_sample(case['gamma'], case['state_L'], case['state_R'])\n        results.extend([p_star, u_star, rho_at_0])\n\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While exact solvers provide invaluable insight, practical astrophysical codes rely on approximate Riemann solvers for their efficiency and broader applicability. This practice moves from theory to application by focusing on the robust Harten-Lax-van Leer-Einfeldt (HLLE) solver . You will implement the HLLE scheme and confront a critical real-world challenge: ensuring the physical admissibility of the solution by designing a procedure to preserve the positivity of density and pressure, a property not automatically guaranteed by approximate methods.",
            "id": "3484392",
            "problem": "You are asked to implement, analyze, and test a positivity-preserving primitive recovery procedure for the Harten–Lax–van Leer–Einfeldt (HLLE) approximate Riemann solver within the ideal hydrodynamics system commonly used in numerical cosmology. Work in one spatial dimension with nondimensional units. Consider the ideal hydrodynamics Euler equations written in conservative form, with conserved state vector $U = (\\rho, m, E)$, where $\\rho$ is mass density, $m$ is momentum density, and $E$ is total energy density, and flux $F(U)$ defined consistently with the ideal gas law. The equation of state is given by the ideal gas relation with adiabatic index $\\gamma$, where pressure $p$ and internal energy density $e$ satisfy $p = (\\gamma - 1) e$, and $E = e + \\tfrac{1}{2} \\rho u^{2}$ with $u = m/\\rho$. The admissible set is defined by the positivity conditions $\\rho  0$ and $p  0$.\n\nStarting only from the conservation laws, the ideal gas equation of state, and characteristic information encoded by wave speeds, derive the expression for the intermediate HLLE state $U^{\\star}$ at a single interface given left and right primitive states $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}})$ and $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}})$ and a fixed adiabatic index $\\gamma$. Use characteristic speeds determined by the fluid velocities and sound speeds, where the sound speed $c$ satisfies $c = \\sqrt{\\gamma p / \\rho}$. From the derived $U^{\\star}$, design and implement a primitive recovery procedure to obtain $(\\rho^{\\star}, u^{\\star}, p^{\\star})$. If the recovered state violates admissibility, apply a minimal positivity fix that keeps the velocity $u^{\\star}$ unchanged, clamps the density to a positive floor $\\rho_{\\mathrm{floor}}$, and sets the internal energy to match a positive floor pressure $p_{\\mathrm{floor}}$ via the ideal gas law. Explicitly, if either $\\rho^{\\star} \\le \\rho_{\\mathrm{floor}}$ or $p^{\\star} \\le p_{\\mathrm{floor}}$, set $\\rho^{\\star}_{\\mathrm{fixed}} = \\max(\\rho^{\\star}, \\rho_{\\mathrm{floor}})$, keep $u^{\\star}_{\\mathrm{fixed}} = u^{\\star}$, and set $E^{\\star}_{\\mathrm{fixed}} = \\tfrac{1}{2} \\rho^{\\star}_{\\mathrm{fixed}} (u^{\\star}_{\\mathrm{fixed}})^{2} + p_{\\mathrm{fixed}}/(\\gamma - 1)$ with $p_{\\mathrm{fixed}} = \\max(p^{\\star}, p_{\\mathrm{floor}})$. Your implementation should exactly follow this fix.\n\nYour program must implement the following steps for each test case:\n- Given $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}})$, $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}})$, $\\gamma$, $\\rho_{\\mathrm{floor}}$, and $p_{\\mathrm{floor}}$, construct left and right conserved states using $E = p/(\\gamma - 1) + \\tfrac{1}{2} \\rho u^{2}$ and fluxes consistent with the Euler equations and the ideal gas law.\n- Compute characteristic speeds using $u$ and $c = \\sqrt{\\gamma p / \\rho}$ and then derive the HLLE intermediate conserved state $U^{\\star}$ from left and right states and fluxes.\n- Recover primitives $(\\rho^{\\star}, u^{\\star}, p^{\\star})$ from $U^{\\star}$ using the ideal gas law.\n- Check admissibility ($\\rho^{\\star}  0$ and $p^{\\star}  0$). If violated, apply the positivity fix described above, obtaining $p_{\\mathrm{fixed}}$.\n- Return, for each test case, a list with three elements: a boolean indicating whether the recovered state before fixing is admissible, the raw recovered pressure $p^{\\star}$ as a float, and the fixed pressure $p_{\\mathrm{fixed}}$ as a float.\n\nAll quantities are nondimensional, so no physical unit conversions are required. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a three-element list in the order described above. For example, produce a line of the form $[\\,[\\mathrm{bool}, p^{\\star}, p_{\\mathrm{fixed}}],\\ldots\\,]$.\n\nUse the following test suite, designed to probe a variety of regimes relevant to numerical cosmology hydrodynamics:\n- Test case $1$ (classic shock tube):\n  - $\\gamma = 1.4$, $\\rho_{\\mathrm{floor}} = 10^{-12}$, $p_{\\mathrm{floor}} = 10^{-12}$,\n  - $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (1.0, 0.0, 1.0)$,\n  - $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (0.125, 0.0, 0.1)$.\n- Test case $2$ (near-vacuum with strong advection):\n  - $\\gamma = 1.4$, $\\rho_{\\mathrm{floor}} = 10^{-12}$, $p_{\\mathrm{floor}} = 10^{-12}$,\n  - $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (10^{-3}, 0.0, 10^{-6})$,\n  - $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (10^{-6}, 10.0, 10^{-8})$.\n- Test case $3$ (strong blast wave):\n  - $\\gamma = 1.4$, $\\rho_{\\mathrm{floor}} = 10^{-12}$, $p_{\\mathrm{floor}} = 10^{-12}$,\n  - $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (1.0, 0.0, 1000.0)$,\n  - $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (1.0, 0.0, 0.01)$.\n- Test case $4$ (head-on supersonic collision):\n  - $\\gamma = 1.4$, $\\rho_{\\mathrm{floor}} = 10^{-12}$, $p_{\\mathrm{floor}} = 10^{-12}$,\n  - $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (1.0, 20.0, 1.0)$,\n  - $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (1.0, -20.0, 1.0)$.\n\nYour program should produce exactly one line of output of the form $[[b_{1},p^{\\star}_{1},p_{\\mathrm{fixed},1}],[b_{2},p^{\\star}_{2},p_{\\mathrm{fixed},2}],[b_{3},p^{\\star}_{3},p_{\\mathrm{fixed},3}],[b_{4},p^{\\star}_{4},p_{\\mathrm{fixed},4}]]$, where $b_{i}$ is a boolean, and $p^{\\star}_{i}$ and $p_{\\mathrm{fixed},i}$ are floats.",
            "solution": "The user has provided a well-posed and scientifically sound problem in the field of numerical hydrodynamics. The task is to derive and implement a positivity-preserving Harten–Lax–van Leer–Einfeldt (HLLE) approximate Riemann solver for the one-dimensional ideal Euler equations. The solution will be presented in two parts: first, a principled derivation of the necessary equations, and second, an implementation of the resulting algorithm.\n\n### 1. Governing Equations and State Vectors\n\nThe one-dimensional ideal hydrodynamics are governed by the Euler equations, which express the conservation of mass, momentum, and energy. In conservative form, these are written as:\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0\n$$\nwhere $t$ is time, $x$ is the spatial coordinate, $U$ is the vector of conserved state variables, and $F(U)$ is the vector of corresponding fluxes.\n\nThe conserved state vector $U$ is defined as:\n$$\nU = \\begin{pmatrix} \\rho \\\\ \\rho u \\\\ E \\end{pmatrix}\n$$\nHere, $\\rho$ is the mass density, $u$ is the fluid velocity, and $m = \\rho u$ is the momentum density. $E$ is the total energy density, which is the sum of the internal energy density $e$ and the kinetic energy density:\n$$\nE = e + \\frac{1}{2}\\rho u^2\n$$\nThe flux vector $F(U)$ is given by:\n$$\nF(U) = \\begin{pmatrix} \\rho u \\\\ \\rho u^2 + p \\\\ (E+p)u \\end{pmatrix}\n$$\nwhere $p$ is the fluid pressure.\n\nThe system is closed by an equation of state (EoS). For an ideal gas, the pressure is related to the internal energy density by:\n$$\np = (\\gamma - 1)e\n$$\nwhere $\\gamma$ is the adiabatic index, a constant. From this, we can express the total energy density $E$ in terms of primitive variables $(\\rho, u, p)$:\n$$\nE = \\frac{p}{\\gamma-1} + \\frac{1}{2}\\rho u^2\n$$\n\n### 2. The HLLE Approximate Riemann Solver\n\nThe HLLE scheme provides an approximate solution to the Riemann problem, which is an initial value problem with two constant states, a left state $U_L$ and a right state $U_R$, separated by a discontinuity at $x=0$. The HLLE approximation assumes a simple wave structure consisting of the original left and right states separated by a single intermediate state, denoted $U^{\\star}$. This structure is bounded by two waves propagating away from the initial discontinuity with speeds $S_L$ and $S_R$.\n\nThe intermediate state $U^{\\star}$ is derived by applying the integral form of the conservation law over the region $[S_L t, S_R t]$ at time $t$. The integral conservation law is:\n$$\n\\frac{d}{dt} \\int_{x_a}^{x_b} U(x,t) dx = F(U(x_a,t)) - F(U(x_b,t))\n$$\nApplying this to the expanding region defined by the wave speeds, we set $x_a = S_L t$ and $x_b = S_R t$. The left-hand side becomes:\n$$\n\\frac{d}{dt} \\int_{S_L t}^{S_R t} U(x,t) dx = \\frac{d}{dt} \\left( t \\int_{S_L}^{S_R} U(\\xi,1) d\\xi \\right) = \\int_{S_L}^{S_R} U(\\xi,1) d\\xi\n$$\nwhere we used the self-similar variable $\\xi = x/t$. Within the HLLE approximation, the state in the region $(S_L, S_R)$ is the constant state $U^{\\star}$. The integral thus evaluates to $(S_R - S_L)U^{\\star}$.\nThe right-hand side, evaluated at the boundaries of the fan, is $F(U_L) - F(U_R)$ (assuming $S_L  0  S_R$). More generally, the fluxes entering and exiting the region are related to the states just outside the fan, which are $U_L$ and $U_R$. By applying the Rankine-Hugoniot conditions at the boundaries $S_L$ and $S_R$, we find the flux balance to be $F_L - F_R$. Equating the terms and rearranging for $U^{\\star}$ yields:\n$$\n(S_R - S_L) U^{\\star} = S_R U_R - S_L U_L + F_L - F_R\n$$\n$$\nU^{\\star} = \\frac{S_R U_R - S_L U_L + F_L - F_R}{S_R - S_L}\n$$\nwhere $U_L$, $U_R$ are the conserved states and $F_L = F(U_L)$, $F_R = F(U_R)$ are the corresponding fluxes.\n\n### 3. Wave Speed Estimation\n\nThe signal velocities $S_L$ and $S_R$ must bound the propagation speeds of all waves in the true Riemann solution. The characteristic wave speeds of the Euler equations are the eigenvalues of the flux Jacobian matrix $\\partial F / \\partial U$, which are $\\lambda_1 = u-c$, $\\lambda_2 = u$, and $\\lambda_3 = u+c$. The sound speed $c$ is given by $c = \\sqrt{\\gamma p / \\rho}$.\nA common and robust choice for the signal velocities, which we adopt here, is to take the minimum and maximum of these characteristic speeds across the left and right states:\n$$\nS_L = \\min(\\lambda_{1,L}, \\lambda_{1,R}) = \\min(u_L - c_L, u_R - c_R)\n$$\n$$\nS_R = \\max(\\lambda_{3,L}, \\lambda_{3,R}) = \\max(u_L + c_L, u_R + c_R)\n$$\n\n### 4. Primitive Variable Recovery and Positivity Preservation\n\nOnce the intermediate conserved state $U^{\\star} = (\\rho^{\\star}, m^{\\star}, E^{\\star})^T$ is computed, we must recover the primitive variables $(\\rho^{\\star}, u^{\\star}, p^{\\star})$ to check for physical admissibility and for use in subsequent time steps. The recovery formulas are derived by inverting the definitions of the conserved variables:\n$$\n\\rho^{\\star} = \\rho^{\\star}\n$$\n$$\nu^{\\star} = \\frac{m^{\\star}}{\\rho^{\\star}}\n$$\n$$\np^{\\star} = (\\gamma - 1) \\left( E^{\\star} - \\frac{1}{2} \\rho^{\\star} (u^{\\star})^2 \\right) = (\\gamma - 1) \\left( E^{\\star} - \\frac{(m^{\\star})^2}{2\\rho^{\\star}} \\right)\n$$\nAn admissible physical state must have positive density and pressure, i.e., $\\rho  0$ and $p  0$. The HLLE solver, being an average, does not guarantee that the recovered state $(\\rho^{\\star}, p^{\\star})$ will be in the admissible set. Specifically, strong rarefactions or large velocity differences can lead to $p^{\\star} \\le 0$.\n\nTo ensure positivity, a fix is applied when the recovered state is found to be non-physical. The problem specifies a precise trigger and procedure for this fix.\n- **Trigger**: The fix is applied if $\\rho^{\\star} \\le \\rho_{\\mathrm{floor}}$ or $p^{\\star} \\le p_{\\mathrm{floor}}$, where $\\rho_{\\mathrm{floor}}$ and $p_{\\mathrm{floor}}$ are small positive constants.\n- **Procedure**: If the trigger condition is met, a fixed pressure $p_{\\mathrm{fixed}}$ is computed. The problem specifies maintaining the recovered velocity $u^{\\star}$ and clamping the density and pressure to their floor values if they fall below. The fixed pressure is defined as:\n$$\np_{\\mathrm{fixed}} = \\max(p^{\\star}, p_{\\mathrm{floor}})\n$$\nIf the trigger condition is not met, the state is considered valid for the purposes of the fix, and we set $p_{\\mathrm{fixed}} = p^{\\star}$. The boolean admissibility check remains strictly based on $\\rho^{\\star} > 0$ and $p^{\\star} > 0$.\n\n### 5. Algorithmic Steps\n\nFor each test case with given left $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}})$ and right $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}})$ states, along with parameters $\\gamma$, $\\rho_{\\mathrm{floor}}$, and $p_{\\mathrm{floor}}$, the algorithm proceeds as follows:\n\n1.  **Compute Left/Right States**: For both the left ($L$) and right ($R$) states, calculate the conserved state vector $U$ and the flux vector $F$ from the primitive variables. Also compute the sound speed $c$.\n2.  **Estimate Wave Speeds**: Calculate $S_L$ and $S_R$ using the formulas from Section 3.\n3.  **Compute HLLE Intermediate State**: Calculate the conserved intermediate state $U^{\\star}$ using the HLLE formula from Section 2.\n4.  **Recover Primitive Variables**: From $U^{\\star} = (\\rho^{\\star}_{cons}, m^{\\star}_{cons}, E^{\\star}_{cons})$, compute the primitive variables $\\rho^{\\star}$, $u^{\\star}$, and $p^{\\star}$.\n5.  **Check Admissibility and Apply Fix**:\n    - Determine the admissibility boolean: `is_admissible = (rho_star  0.0) and (p_star  0.0)`.\n    - Check the trigger condition for the fix: `needs_fix = (rho_star = rho_floor) or (p_star = p_floor)`.\n    - Compute the final pressure $p_{\\mathrm{fixed}}$. If `needs_fix` is true, $p_{\\mathrm{fixed}} = \\max(p^{\\star}, p_{\\mathrm{floor}})$; otherwise, $p_{\\mathrm{fixed}} = p^{\\star}$.\n6.  **Return Results**: For each test case, return the list containing the admissibility boolean, the raw recovered pressure $p^{\\star}$, and the final pressure after a potential fix, $p_{\\mathrm{fixed}}$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests a positivity-preserving HLLE approximate Riemann solver \n    for 1D ideal hydrodynamics, as specified in the problem statement.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (classic shock tube)\n        {\n            \"gamma\": 1.4, \"rho_floor\": 1e-12, \"p_floor\": 1e-12,\n            \"left\": {\"rho\": 1.0, \"u\": 0.0, \"p\": 1.0},\n            \"right\": {\"rho\": 0.125, \"u\": 0.0, \"p\": 0.1},\n        },\n        # Test case 2 (near-vacuum with strong advection)\n        {\n            \"gamma\": 1.4, \"rho_floor\": 1e-12, \"p_floor\": 1e-12,\n            \"left\": {\"rho\": 1e-3, \"u\": 0.0, \"p\": 1e-6},\n            \"right\": {\"rho\": 1e-6, \"u\": 10.0, \"p\": 1e-8},\n        },\n        # Test case 3 (strong blast wave)\n        {\n            \"gamma\": 1.4, \"rho_floor\": 1e-12, \"p_floor\": 1e-12,\n            \"left\": {\"rho\": 1.0, \"u\": 0.0, \"p\": 1000.0},\n            \"right\": {\"rho\": 1.0, \"u\": 0.0, \"p\": 0.01},\n        },\n        # Test case 4 (head-on supersonic collision)\n        {\n            \"gamma\": 1.4, \"rho_floor\": 1e-12, \"p_floor\": 1e-12,\n            \"left\": {\"rho\": 1.0, \"u\": 20.0, \"p\": 1.0},\n            \"right\": {\"rho\": 1.0, \"u\": -20.0, \"p\": 1.0},\n        },\n    ]\n\n    def get_state_and_flux(prims, gamma):\n        \"\"\"Computes conserved state, flux, and sound speed from primitives.\"\"\"\n        rho, u, p = prims[\"rho\"], prims[\"u\"], prims[\"p\"]\n        \n        # Prevent division by zero for sound speed calculation if rho is non-positive\n        if rho = 0 or p = 0:\n             c = 0.0\n        else:\n             c = np.sqrt(gamma * p / rho)\n\n        m = rho * u\n        E = p / (gamma - 1.0) + 0.5 * rho * u**2\n        \n        U = np.array([rho, m, E])\n        F = np.array([m, m * u + p, (E + p) * u])\n        \n        return U, F, c\n\n    results = []\n    for case in test_cases:\n        gamma = case[\"gamma\"]\n        rho_floor = case[\"rho_floor\"]\n        p_floor = case[\"p_floor\"]\n\n        # 1. Construct left and right states and fluxes\n        U_l, F_l, c_l = get_state_and_flux(case[\"left\"], gamma)\n        U_r, F_r, c_r = get_state_and_flux(case[\"right\"], gamma)\n        \n        u_l = case[\"left\"][\"u\"]\n        u_r = case[\"right\"][\"u\"]\n\n        # 2. Compute characteristic wave speeds\n        s_l = min(u_l - c_l, u_r - c_r)\n        s_r = max(u_l + c_l, u_r + c_r)\n\n        # 3. Compute HLLE intermediate conserved state U_star\n        if s_r - s_l == 0:\n            # This case implies U_L = U_R, so U_star is just U_L.\n            # Avoids division by zero, though unlikely with these tests.\n            U_star = U_l\n        else:\n            U_star = (s_r * U_r - s_l * U_l + F_l - F_r) / (s_r - s_l)\n        \n        rho_star_cons, m_star_cons, E_star_cons = U_star\n\n        # 4. Recover primitive variables from U_star\n        if rho_star_cons = 0:\n            # Unrecoverable state, density is non-positive\n            rho_star = rho_star_cons\n            u_star = 0.0\n            p_star = -1.0 # Clearly inadmissible\n        else:\n            rho_star = rho_star_cons\n            u_star = m_star_cons / rho_star\n            p_star = (gamma - 1.0) * (E_star_cons - 0.5 * rho_star * u_star**2)\n        \n        # 5. Check admissibility and apply positivity fix to pressure\n        is_admissible = (rho_star  0.0) and (p_star  0.0)\n\n        needs_fix = (rho_star = rho_floor) or (p_star = p_floor)\n\n        if needs_fix:\n            p_fixed = max(p_star, p_floor)\n        else:\n            p_fixed = p_star\n            \n        # 6. Store result\n        bool_str = str(is_admissible)\n        result_str = f\"[{bool_str},{p_star},{p_fixed}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The power of the Godunov framework lies in its extensibility to more complex physical systems relevant to cosmology. This exercise demonstrates how to adapt the Riemann solver to a two-fluid model incorporating cosmic rays alongside the thermal gas . By implementing an HLL solver for this augmented system, you will not only practice generalizing the numerical machinery but also verify a key physical prediction: how the 'softer' equation of state from cosmic rays modifies the structure of accretion shocks.",
            "id": "3484383",
            "problem": "Consider the One-Dimensional (1D) ideal hydrodynamics equations extended to include a Cosmic Ray (CR) fluid as a second, co-moving, adiabatic component. The classical Euler system in conservation form is augmented by a separate conservation equation for the CR energy. Assume both the thermal gas and the CR fluid are ideal, characterized by constant adiabatic indices $ \\gamma_{\\rm g} $ and $ \\gamma_{\\rm cr} $ respectively, and move with a single bulk velocity $ u $. The conservative state vector is\n$$\n\\mathbf{U} = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\nE_{\\rm tot} \\\\\nE_{\\rm cr}\n\\end{bmatrix},\n$$\nwhere $ \\rho $ is the mass density, $ \\rho u $ is the momentum density, $ E_{\\rm tot} $ is the total energy density of the gas plus the CR energy plus kinetic energy, and $ E_{\\rm cr} $ is the CR energy density. The thermal gas pressure $ p_{\\rm g} $ and CR pressure $ p_{\\rm cr} $ follow\n$$\np_{\\rm g} = (\\gamma_{\\rm g}-1)\\left( E_{\\rm tot} - E_{\\rm cr} - \\tfrac{1}{2}\\rho u^2 \\right), \\quad p_{\\rm cr} = (\\gamma_{\\rm cr}-1) E_{\\rm cr},\n$$\nand the total pressure is\n$$\np_{\\rm tot} = p_{\\rm g} + p_{\\rm cr}.\n$$\nThe corresponding flux vector $ \\mathbf{F}(\\mathbf{U}) $ for this two-fluid system (neglecting CR diffusion or streaming and any explicit source terms) is\n$$\n\\mathbf{F}(\\mathbf{U}) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p_{\\rm tot} \\\\\n(E_{\\rm tot} + p_{\\rm tot}) u \\\\\n(E_{\\rm cr} + p_{\\rm cr}) u\n\\end{bmatrix}.\n$$\nIn a Godunov-type method the Riemann problem between left and right states $ \\mathbf{U}_{\\rm L} $ and $ \\mathbf{U}_{\\rm R} $ is solved to obtain inter-cell fluxes. In the Harten-Lax-van Leer (HLL) approximate Riemann solver, one requires bounding wave speeds $ S_{\\rm L} $ and $ S_{\\rm R} $ that bracket all characteristics. For an acoustic estimate in the two-fluid mixture, use the composite sound speed\n$$\nc = \\sqrt{\\frac{\\gamma_{\\rm g} p_{\\rm g} + \\gamma_{\\rm cr} p_{\\rm cr}}{\\rho}},\n$$\ncomputed separately on the left and right states. The HLL intermediate state $ \\mathbf{U}_\\star $ at the interface is then used to approximate the post-shock state in the Riemann fan when $ S_{\\rm L}  0  S_{\\rm R} $.\n\nTask: Starting only from the conservation-law formulation above and the definition of the composite sound speed, derive and implement an HLL Riemann solver for this two-fluid system. Your program must:\n- Compute primitive variables $ \\rho $, $ u $, $ p_{\\rm g} $, $ p_{\\rm cr} $ from the conservative variables $ \\mathbf{U} $ and adiabatic indices $ \\gamma_{\\rm g} $, $ \\gamma_{\\rm cr} $.\n- Compute left and right fluxes $ \\mathbf{F}_{\\rm L} $, $ \\mathbf{F}_{\\rm R} $.\n- Compute $ S_{\\rm L} $ and $ S_{\\rm R} $ using $ u \\pm c $ on both sides.\n- Construct the HLL intermediate state $ \\mathbf{U}_\\star $ between $ S_{\\rm L} $ and $ S_{\\rm R} $.\n- Use $ \\rho_\\star $ as the approximate post-shock density at the interface, and define the compression ratio $ r = \\rho_\\star / \\rho_{\\rm up} $ with $ \\rho_{\\rm up} $ taken from the physical upstream side (here the left state, since inflow is from the left).\n\nVerification of CR-modified shock structure: For a high-Mach inflow (representing a one-dimensional accretion shock in cosmology), Cosmic Rays (CRs) soften the effective equation of state, increasing the compression ratio compared to pure gas. In the strong-shock limit, a useful diagnostic is the effective adiabatic index,\n$$\n\\gamma_{\\rm eff} = \\frac{\\gamma_{\\rm g} p_{\\rm g,up} + \\gamma_{\\rm cr} p_{\\rm cr,up}}{p_{\\rm g,up} + p_{\\rm cr,up}},\n$$\nand the corresponding compression ratio,\n$$\nr_{\\rm ss} = \\frac{\\gamma_{\\rm eff}+1}{\\gamma_{\\rm eff}-1}.\n$$\nAlthough the exact two-fluid shock is not strictly a single-polytrope, for sufficiently large Mach numbers this quantity should approximate the HLL interface compression ratio.\n\nUnits: Use dimensionless code units for all quantities. Do not convert units; report pure numbers.\n\nAngle units: Not applicable.\n\nPercentages: Any fractional CR content must be specified as a decimal between $ 0 $ and $ 1 $.\n\nTest Suite: Use the following adiabatic indices and left/right states to define four Riemann problems plus a near-sonic edge case. In each case, construct conservative variables from the given primitives via $ E_{\\rm cr} = p_{\\rm cr}/(\\gamma_{\\rm cr}-1) $ and $ E_{\\rm tot} = p_{\\rm g}/(\\gamma_{\\rm g}-1) + E_{\\rm cr} + \\tfrac{1}{2}\\rho u^2 $.\n\n- Adiabatic indices: $ \\gamma_{\\rm g} = 5/3 $, $ \\gamma_{\\rm cr} = 4/3 $.\n\n- Case $ 1 $ (baseline, pure gas, moderate Mach inflow):\n  Left (upstream): $ \\rho_{\\rm L} = 1.0 $, $ u_{\\rm L} = -3.0 $, $ p_{{\\rm g},\\rm L} = 1.0 $, $ p_{{\\rm cr},\\rm L} = 0.0 $.\n  Right (ambient): $ \\rho_{\\rm R} = 1.0 $, $ u_{\\rm R} = 0.0 $, $ p_{{\\rm g},\\rm R} = 1.0 $, $ p_{{\\rm cr},\\rm R} = 0.0 $.\n\n- Case $ 2 $ (CR-modified, moderate Mach, upstream CR fraction $ 0.3 $ of total pressure):\n  Left (upstream): $ \\rho_{\\rm L} = 1.0 $, $ u_{\\rm L} = -3.0 $, $ p_{{\\rm tot},\\rm L} = 1.0 $ with $ p_{{\\rm cr},\\rm L} = 0.3 $, $ p_{{\\rm g},\\rm L} = 0.7 $.\n  Right (ambient): $ \\rho_{\\rm R} = 1.0 $, $ u_{\\rm R} = 0.0 $, $ p_{{\\rm g},\\rm R} = 1.0 $, $ p_{{\\rm cr},\\rm R} = 0.0 $.\n\n- Case $ 3 $ (CR-modified, strong-shock inflow, upstream CR fraction $ 0.5 $):\n  Left (upstream): $ \\rho_{\\rm L} = 1.0 $, $ u_{\\rm L} = -30.0 $, $ p_{{\\rm tot},\\rm L} = 1.0 $ with $ p_{{\\rm cr},\\rm L} = 0.5 $, $ p_{{\\rm g},\\rm L} = 0.5 $.\n  Right (ambient): $ \\rho_{\\rm R} = 1.0 $, $ u_{\\rm R} = 0.0 $, $ p_{{\\rm g},\\rm R} = 1.0 $, $ p_{{\\rm cr},\\rm R} = 0.0 $.\n\n- Case $ 4 $ (CR-dominated, strong-shock inflow, upstream CR fraction $ 0.9 $):\n  Left (upstream): $ \\rho_{\\rm L} = 1.0 $, $ u_{\\rm L} = -30.0 $, $ p_{{\\rm tot},\\rm L} = 1.0 $ with $ p_{{\\rm cr},\\rm L} = 0.9 $, $ p_{{\\rm g},\\rm L} = 0.1 $.\n  Right (ambient): $ \\rho_{\\rm R} = 1.0 $, $ u_{\\rm R} = 0.0 $, $ p_{{\\rm g},\\rm R} = 1.0 $, $ p_{{\\rm cr},\\rm R} = 0.0 $.\n\n- Case $ 5 $ (near-sonic inflow, upstream CR fraction $ 0.5 $):\n  Left (upstream): $ \\rho_{\\rm L} = 1.0 $, $ u_{\\rm L} = -1.0 $, $ p_{{\\rm tot},\\rm L} = 1.0 $ with $ p_{{\\rm cr},\\rm L} = 0.5 $, $ p_{{\\rm g},\\rm L} = 0.5 $.\n  Right (ambient): $ \\rho_{\\rm R} = 1.0 $, $ u_{\\rm R} = 0.0 $, $ p_{{\\rm g},\\rm R} = 1.0 $, $ p_{{\\rm cr},\\rm R} = 0.0 $.\n\nRequired Outputs:\n- For Case $ 1 $, compute $ r_{\\rm pure} = \\rho_\\star/\\rho_{\\rm L} $ in pure gas.\n- For Case $ 2 $, compute $ r_{\\rm cr} = \\rho_\\star/\\rho_{\\rm L} $ with upstream CR fraction $ 0.3 $.\n- Compute $ \\Delta r = r_{\\rm cr} - r_{\\rm pure} $.\n- For Case $ 3 $, compute $ r_{\\rm strong} = \\rho_\\star/\\rho_{\\rm L} $ and the strong-shock diagnostic $ r_{\\rm ss} $ using $ \\gamma_{\\rm eff} $ from the upstream state; report the absolute error $ |r_{\\rm strong} - r_{\\rm ss}| $.\n- For Case $ 4 $, compute $ r_{\\rm cr,0.9} = \\rho_\\star/\\rho_{\\rm L} $.\n- For Case $ 5 $, compute $ r_{\\rm near} = \\rho_\\star/\\rho_{\\rm L} $.\n- Also report a boolean $ b_{\\rm mono} $ that is $ \\mathrm{True} $ if $ r_{\\rm cr}  r_{\\rm pure} $ and $ r_{\\rm cr,0.9} \\ge r_{\\rm cr} $, and $ \\mathrm{False} $ otherwise.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the exact order\n$$\n[ r_{\\rm pure}, r_{\\rm cr}, \\Delta r, |r_{\\rm strong} - r_{\\rm ss}|, r_{\\rm cr,0.9}, r_{\\rm near}, b_{\\rm mono} ].\n$$\nAll entries must be printed as Python-native types (floats and a boolean), with no units and no additional text.",
            "solution": "The problem presented is valid. It is a well-posed computational physics problem grounded in the established principles of ideal magnetohydrodynamics, specifically the extension of the Euler equations to a two-fluid system composed of a thermal gas and cosmic rays (CRs). The formulation is self-contained, providing the complete system of conservation laws, constitutive relations, and a clear set of instructions for implementing an Harten-Lax-van Leer (HLL) approximate Riemann solver. The test cases and required outputs are unambiguous and designed to probe a key physical effect: the influence of the CR pressure component on shock compression.\n\nThe solution proceeds by first detailing the conversion between primitive and conservative variables, then deriving the HLL solver for the specified two-fluid system, and finally applying this solver to the test cases.\n\nThe state of the fluid is described by the vector of conservative variables:\n$$\n\\mathbf{U} = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\nE_{\\rm tot} \\\\\nE_{\\rm cr}\n\\end{bmatrix}\n$$\nwhere $\\rho$ is the mass density, $u$ is the bulk velocity, $E_{\\rm tot}$ is the total energy density, and $E_{\\rm cr}$ is the CR energy density. The system is closed by the equations of state for the thermal gas pressure $p_{\\rm g}$ and CR pressure $p_{\\rm cr}$:\n$$\np_{\\rm g} = (\\gamma_{\\rm g}-1)\\left( E_{\\rm tot} - E_{\\rm cr} - \\tfrac{1}{2}\\rho u^2 \\right)\n$$\n$$\np_{\\rm cr} = (\\gamma_{\\rm cr}-1) E_{\\rm cr}\n$$\nHere, $\\gamma_{\\rm g}$ and $\\gamma_{\\rm cr}$ are the constant adiabatic indices for the gas and CRs, respectively. The total pressure is $p_{\\rm tot} = p_{\\rm g} + p_{\\rm cr}$.\n\nTo implement the numerical solver, we require functions to convert between the conservative variables $\\mathbf{U} = [\\rho, \\rho u, E_{\\rm tot}, E_{\\rm cr}]^T$ and the primitive variables $\\mathbf{W} = [\\rho, u, p_{\\rm g}, p_{\\rm cr}]^T$.\n\nConversion from conservative to primitive variables:\nGiven $\\mathbf{U}$, the primitive variables are found as follows:\n- Mass density: $\\rho = \\mathbf{U}_1$\n- Velocity: $u = (\\rho u) / \\rho = \\mathbf{U}_2 / \\mathbf{U}_1$\n- CR energy density: $E_{\\rm cr} = \\mathbf{U}_4$\n- CR pressure: $p_{\\rm cr} = (\\gamma_{\\rm cr}-1) E_{\\rm cr}$\n- Gas pressure: $p_{\\rm g} = (\\gamma_{\\rm g}-1) ( E_{\\rm tot} - E_{\\rm cr} - \\frac{1}{2}\\rho u^2 ) = (\\gamma_{\\rm g}-1) ( \\mathbf{U}_3 - \\mathbf{U}_4 - \\frac{1}{2} \\frac{\\mathbf{U}_2^2}{\\mathbf{U}_1} )$\n\nConversion from primitive to conservative variables:\nGiven $\\mathbf{W}$, the conservative variables are constructed as:\n- Mass density: $\\rho$\n- Momentum density: $\\rho u$\n- CR energy density: $E_{\\rm cr} = p_{\\rm cr} / (\\gamma_{\\rm cr}-1)$\n- Total energy density: $E_{\\rm tot} = \\frac{p_{\\rm g}}{\\gamma_{\\rm g}-1} + E_{\\rm cr} + \\frac{1}{2}\\rho u^2$\n\nThe one-dimensional two-fluid hydrodynamics equations are a system of hyperbolic conservation laws of the form $\\partial_t \\mathbf{U} + \\partial_x \\mathbf{F}(\\mathbf{U}) = \\mathbf{0}$, with the flux vector $\\mathbf{F}(\\mathbf{U})$ given by:\n$$\n\\mathbf{F}(\\mathbf{U}) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p_{\\rm tot} \\\\\n(E_{\\rm tot} + p_{\\rm tot}) u \\\\\n(E_{\\rm cr} + p_{\\rm cr}) u\n\\end{bmatrix}\n$$\nThe HLL Riemann solver approximates the solution to the Riemann problem, defined by a left state $\\mathbf{U}_{\\rm L}$ and a right state $\\mathbf{U}_{\\rm R}$, with a three-wave structure: a left-propagating wave with speed $S_{\\rm L}$, a right-propagating wave with speed $S_{\\rm R}$, and a single constant intermediate state $\\mathbf{U}_\\star$ between them. The algorithm proceeds as follows:\n\n1.  For the given left and right primitive states $(\\rho_{\\rm L}, u_{\\rm L}, p_{{\\rm g},\\rm L}, p_{{\\rm cr},\\rm L})$ and $(\\rho_{\\rm R}, u_{\\rm R}, p_{{\\rm g},\\rm R}, p_{{\\rm cr},\\rm R})$, construct the corresponding conservative state vectors $\\mathbf{U}_{\\rm L}$ and $\\mathbf{U}_{\\rm R}$.\n\n2.  Calculate the composite sound speeds for the left and right states:\n    $$\n    c_{\\rm L} = \\sqrt{\\frac{\\gamma_{\\rm g} p_{{\\rm g},\\rm L} + \\gamma_{\\rm cr} p_{{\\rm cr},\\rm L}}{\\rho_{\\rm L}}}, \\quad c_{\\rm R} = \\sqrt{\\frac{\\gamma_{\\rm g} p_{{\\rm g},\\rm R} + \\gamma_{\\rm cr} p_{{\\rm cr},\\rm R}}{\\rho_{\\rm R}}}\n    $$\n\n3.  Estimate the bounding signal velocities $S_{\\rm L}$ and $S_{\\rm R}$. A standard estimate (Davis-Yee) is used:\n    $$\n    S_{\\rm L} = \\min(u_{\\rm L} - c_{\\rm L}, u_{\\rm R} - c_{\\rm R})\n    $$\n    $$\n    S_{\\rm R} = \\max(u_{\\rm L} + c_{\\rm L}, u_{\\rm R} + c_{\\rm R})\n    $$\n\n4.  Construct the flux vectors $\\mathbf{F}_{\\rm L} = \\mathbf{F}(\\mathbf{U}_{\\rm L})$ and $\\mathbf{F}_{\\rm R} = \\mathbf{F}(\\mathbf{U}_{\\rm R})$ using the primitive variables from each state.\n\n5.  The HLL intermediate state $\\mathbf{U}_\\star$ is derived from the integral form of the conservation laws over the region $[S_{\\rm L}t, S_{\\rm R}t]$ at time $t$. This yields the expression:\n    $$\n    \\mathbf{U}_\\star = \\frac{S_{\\rm R} \\mathbf{U}_{\\rm R} - S_{\\rm L} \\mathbf{U}_{\\rm L} - (\\mathbf{F}_{\\rm R} - \\mathbf{F}_{\\rm L})}{S_{\\rm R} - S_{\\rm L}}\n    $$\n    This formula provides the state in the region between the fastest and slowest waves. The problem specifies that inflow is from the left, making the left state the upstream state. The task is to compute the compression ratio $r = \\rho_\\star / \\rho_{\\rm L}$, where $\\rho_\\star$ is the first component of $\\mathbf{U}_\\star$.\n\n6.  For the strong-shock test case, the numerical compression ratio $r_{\\rm strong} = \\rho_{\\star} / \\rho_{\\rm L}$ is compared to the analytical Rankine-Hugoniot prediction for a single fluid with an effective adiabatic index $\\gamma_{\\rm eff}$. This index is calculated from the upstream (left) state pressures:\n    $$\n    \\gamma_{\\rm eff} = \\frac{\\gamma_{\\rm g} p_{\\rm g,L} + \\gamma_{\\rm cr} p_{\\rm cr,L}}{p_{\\rm g,L} + p_{\\rm cr,L}}\n    $$\n    The strong-shock compression ratio is then:\n    $$\n    r_{\\rm ss} = \\frac{\\gamma_{\\rm eff}+1}{\\gamma_{\\rm eff}-1}\n    $$\n    This provides a verification of the physical behavior of the two-fluid system in the high Mach number limit.\n\nThese steps are implemented for each of the five test cases provided. The calculations involve converting initial primitive variables to conservative states, applying the HLL solver a single time for each Riemann problem to find the intermediate density $\\rho_\\star$, and then calculating the required output metrics. The boolean $b_{\\rm mono}$ is evaluated based on the results from Cases $1$, $2$, and $4$ to check for the expected monotonic increase in shock compression with increasing CR pressure fraction.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-fluid (gas + cosmic ray) Riemann problems using an HLL solver.\n    \"\"\"\n\n    # Adiabatic indices\n    gamma_g = 5.0 / 3.0\n    gamma_cr = 4.0 / 3.0\n\n    # Define test cases in terms of primitive variables (rho, u, p_g, p_cr)\n    # Left state | Right state\n    test_cases = [\n        # Case 1: Pure gas, moderate Mach inflow\n        {'L': (1.0, -3.0, 1.0, 0.0), 'R': (1.0, 0.0, 1.0, 0.0)},\n        # Case 2: CR-modified, moderate Mach, upstream CR frac 0.3\n        {'L': (1.0, -3.0, 0.7, 0.3), 'R': (1.0, 0.0, 1.0, 0.0)},\n        # Case 3: CR-modified, strong-shock inflow, upstream CR frac 0.5\n        {'L': (1.0, -30.0, 0.5, 0.5), 'R': (1.0, 0.0, 1.0, 0.0)},\n        # Case 4: CR-dominated, strong-shock inflow, upstream CR frac 0.9\n        {'L': (1.0, -30.0, 0.1, 0.9), 'R': (1.0, 0.0, 1.0, 0.0)},\n        # Case 5: Near-sonic inflow, upstream CR frac 0.5\n        {'L': (1.0, -1.0, 0.5, 0.5), 'R': (1.0, 0.0, 1.0, 0.0)},\n    ]\n\n    def prim_to_cons(rho, u, p_g, p_cr, gamma_g, gamma_cr):\n        \"\"\"Converts primitive variables to conservative variables.\"\"\"\n        mom = rho * u\n        E_cr = p_cr / (gamma_cr - 1.0)\n        E_g_int = p_g / (gamma_g - 1.0)\n        E_kin = 0.5 * rho * u**2\n        E_tot = E_g_int + E_cr + E_kin\n        return np.array([rho, mom, E_tot, E_cr])\n\n    def get_flux(rho, u, p_g, p_cr, E_tot, E_cr, gamma_cr):\n        \"\"\"Computes the flux vector from primitive and conservative variables.\"\"\"\n        p_tot = p_g + p_cr\n        flux = np.zeros(4)\n        flux[0] = rho * u\n        flux[1] = rho * u**2 + p_tot\n        flux[2] = (E_tot + p_tot) * u\n        flux[3] = (E_cr + p_cr) * u\n        return flux\n\n    def get_sound_speed(rho, p_g, p_cr, gamma_g, gamma_cr):\n        \"\"\"Computes the composite sound speed.\"\"\"\n        if rho = 0:\n            return 0.0\n        numerator = gamma_g * p_g + gamma_cr * p_cr\n        if numerator  0:\n            return 0.0  # Physically unrealistic pressure\n        return np.sqrt(numerator / rho)\n\n    def hll_solver(case, gamma_g, gamma_cr):\n        \"\"\"\n        Computes the intermediate-state density rho_star using the HLL solver.\n        \"\"\"\n        rho_L, u_L, pg_L, pcr_L = case['L']\n        rho_R, u_R, pg_R, pcr_R = case['R']\n\n        # Convert to conservative variables\n        U_L = prim_to_cons(rho_L, u_L, pg_L, pcr_L, gamma_g, gamma_cr)\n        U_R = prim_to_cons(rho_R, u_R, pg_R, pcr_R, gamma_g, gamma_cr)\n\n        E_tot_L, E_cr_L = U_L[2], U_L[3]\n        E_tot_R, E_cr_R = U_R[2], U_R[3]\n        \n        # Compute fluxes\n        F_L = get_flux(rho_L, u_L, pg_L, pcr_L, E_tot_L, E_cr_L, gamma_cr)\n        F_R = get_flux(rho_R, u_R, pg_R, pcr_R, E_tot_R, E_cr_R, gamma_cr)\n\n        # Compute sound speeds\n        c_L = get_sound_speed(rho_L, pg_L, pcr_L, gamma_g, gamma_cr)\n        c_R = get_sound_speed(rho_R, pg_R, pcr_R, gamma_g, gamma_cr)\n\n        # Estimate wave speeds (Davis-Yee)\n        S_L = min(u_L - c_L, u_R - c_R)\n        S_R = max(u_L + c_L, u_R + c_R)\n        \n        if S_R - S_L == 0.0:\n            # Degenerate case, should not happen with these test problems\n            # Can happen if c=0 and uL=uR, but then U_L=U_R and F_L=F_R\n            # U_star would be U_L\n            U_star = U_L\n        else:\n            # Construct HLL intermediate state\n            U_star = (S_R * U_R - S_L * U_L - (F_R - F_L)) / (S_R - S_L)\n\n        rho_star = U_star[0]\n        return rho_star\n\n    results_dict = {}\n\n    # Case 1: Pure gas\n    rho_star_1 = hll_solver(test_cases[0], gamma_g, gamma_cr)\n    r_pure = rho_star_1 / test_cases[0]['L'][0]\n    results_dict['r_pure'] = r_pure\n\n    # Case 2: CR-modified\n    rho_star_2 = hll_solver(test_cases[1], gamma_g, gamma_cr)\n    r_cr = rho_star_2 / test_cases[1]['L'][0]\n    results_dict['r_cr'] = r_cr\n\n    # Delta r\n    delta_r = r_cr - r_pure\n    results_dict['delta_r'] = delta_r\n\n    # Case 3: Strong-shock\n    rho_star_3 = hll_solver(test_cases[2], gamma_g, gamma_cr)\n    r_strong = rho_star_3 / test_cases[2]['L'][0]\n    \n    # Strong-shock diagnostic\n    pg_up = test_cases[2]['L'][2]\n    pcr_up = test_cases[2]['L'][3]\n    gamma_eff = (gamma_g * pg_up + gamma_cr * pcr_up) / (pg_up + pcr_up)\n    r_ss = (gamma_eff + 1.0) / (gamma_eff - 1.0)\n    abs_error_strong_shock = abs(r_strong - r_ss)\n    results_dict['abs_error_strong_shock'] = abs_error_strong_shock\n\n    # Case 4: CR-dominated strong-shock\n    rho_star_4 = hll_solver(test_cases[3], gamma_g, gamma_cr)\n    r_cr_0_9 = rho_star_4 / test_cases[3]['L'][0]\n    results_dict['r_cr_0.9'] = r_cr_0_9\n\n    # Case 5: Near-sonic\n    rho_star_5 = hll_solver(test_cases[4], gamma_g, gamma_cr)\n    r_near = rho_star_5 / test_cases[4]['L'][0]\n    results_dict['r_near'] = r_near\n    \n    # Monotonicity boolean\n    b_mono = (r_cr > r_pure) and (r_cr_0_9 >= r_cr)\n    results_dict['b_mono'] = b_mono\n\n    # Final output formatting\n    final_output = [\n        results_dict['r_pure'],\n        results_dict['r_cr'],\n        results_dict['delta_r'],\n        results_dict['abs_error_strong_shock'],\n        results_dict['r_cr_0.9'],\n        results_dict['r_near'],\n        results_dict['b_mono']\n    ]\n\n    print(f\"[{','.join(map(str, final_output))}]\")\n\nsolve()\n```"
        }
    ]
}