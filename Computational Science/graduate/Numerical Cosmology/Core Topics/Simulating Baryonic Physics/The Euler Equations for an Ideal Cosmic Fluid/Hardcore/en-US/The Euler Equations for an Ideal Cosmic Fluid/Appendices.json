{
    "hands_on_practices": [
        {
            "introduction": "Finite-volume hydrodynamics codes evolve a system by updating cell-averaged conserved quantities like mass, momentum, and energy densities ($\\rho$, $m$, $E$). However, calculating the fluxes between cells and understanding the physical state of the fluid requires primitive variables like velocity $u$ and pressure $P$. This exercise  provides hands-on practice with the fundamental conversion from a conserved state vector to its corresponding primitive variables, a critical operation performed millions of times in any cosmological simulation.",
            "id": "3495179",
            "problem": "Consider a local finite-volume cell in a cosmological hydrodynamics simulation of an ideal cosmic fluid, advanced in physical time over a sufficiently small interval that Hubble expansion source terms can be neglected for the purpose of reconstructing primitive variables. The state is represented by the conserved variables mass density $\\rho$, momentum density $m$, and total energy density $E$, together with a constant adiabatic index $\\gamma$ appropriate for a monatomic ideal gas. You are provided the following physically plausible values at a given epoch: $\\rho = 1.0 \\times 10^{-24}\\ \\mathrm{g\\,cm^{-3}}$, $m = 3.0 \\times 10^{-17}\\ \\mathrm{g\\,cm^{-2}\\,s^{-1}}$, $E = 1.45 \\times 10^{-9}\\ \\mathrm{erg\\,cm^{-3}}$, and $\\gamma = 5/3$.\n\nStarting from the fundamental definitions in compressible fluid dynamics and thermodynamics suitable for the Euler equations:\n- Momentum density equals mass density times bulk velocity.\n- Total energy density equals the sum of internal energy density and kinetic energy density.\n- An ideal-gas closure relates pressure to internal energy density.\n- The adiabatic sound speed arises from small, isentropic compressions.\n\nDerive expressions for the bulk velocity $u$, internal energy density $e$, pressure $P$, and adiabatic sound speed $c_s$ in terms of the conserved variables $(\\rho, m, E)$ and $\\gamma$. Then evaluate these expressions using the provided numerical values. Finally, assess the physical admissibility of the state by checking the positivity of pressure through the condition $P > 0$.\n\nExpress $u$ and $c_s$ in $\\mathrm{cm\\,s^{-1}}$, and $e$ and $P$ in $\\mathrm{erg\\,cm^{-3}}$. Round your final numerical values for $(u, e, P, c_s)$ to four significant figures. The final answer must contain only the quartet $(u, e, P, c_s)$ presented together.",
            "solution": "**Derivation of Primitive Variables**\nThe goal is to express the primitive variables $(u, e, P, c_s)$ in terms of the conserved variables $(\\rho, m, E)$ and the constant $\\gamma$. The given definitions are:\n1.  Momentum density: $m = \\rho u$\n2.  Total energy density: $E = e + E_k = e + \\frac{1}{2}\\rho u^2$\n3.  Ideal-gas closure: $P = (\\gamma - 1)e$\n4.  Adiabatic sound speed: $c_s^2 = \\frac{\\gamma P}{\\rho}$\n\nFrom these, we derive the expressions for the primitive variables:\n1.  **Bulk Velocity ($u$)**:\n    From the definition of momentum density, $m = \\rho u$. Solving for the velocity $u$ gives:\n    $$u = \\frac{m}{\\rho}$$\n\n2.  **Internal Energy Density ($e$)**:\n    The total energy density is $E = e + E_k$. The kinetic energy density is $E_k = \\frac{1}{2}\\rho u^2$. We can substitute the expression for $u$ into the expression for $E_k$:\n    $$E_k = \\frac{1}{2}\\rho \\left(\\frac{m}{\\rho}\\right)^2 = \\frac{1}{2}\\rho \\frac{m^2}{\\rho^2} = \\frac{m^2}{2\\rho}$$\n    Now, we can solve for the internal energy density $e$ from the total energy definition:\n    $$e = E - E_k = E - \\frac{m^2}{2\\rho}$$\n\n3.  **Pressure ($P$)**:\n    The ideal-gas closure relates pressure to internal energy density: $P = (\\gamma - 1)e$. Substituting the derived expression for $e$:\n    $$P = (\\gamma - 1)\\left(E - \\frac{m^2}{2\\rho}\\right)$$\n\n4.  **Adiabatic Sound Speed ($c_s$)**:\n    The square of the sound speed is given by $c_s^2 = \\frac{\\gamma P}{\\rho}$. Substituting the expression for $P$:\n    $$c_s^2 = \\frac{\\gamma}{\\rho} \\left[(\\gamma - 1)\\left(E - \\frac{m^2}{2\\rho}\\right)\\right] = \\frac{\\gamma(\\gamma-1)}{\\rho}\\left(E - \\frac{m^2}{2\\rho}\\right)$$\n    Taking the square root gives $c_s$:\n    $$c_s = \\sqrt{\\frac{\\gamma(\\gamma-1)}{\\rho}\\left(E - \\frac{m^2}{2\\rho}\\right)}$$\n\n**Numerical Evaluation**\nWe now substitute the provided numerical values into these derived expressions.\n- Given:\n  - $\\rho = 1.0 \\times 10^{-24}\\ \\mathrm{g\\,cm^{-3}}$\n  - $m = 3.0 \\times 10^{-17}\\ \\mathrm{g\\,cm^{-2}\\,s^{-1}}$\n  - $E = 1.45 \\times 10^{-9}\\ \\mathrm{erg\\,cm^{-3}}$\n  - $\\gamma = 5/3$\n\n1.  **Calculate $u$**:\n    $$u = \\frac{3.0 \\times 10^{-17}\\ \\mathrm{g\\,cm^{-2}\\,s^{-1}}}{1.0 \\times 10^{-24}\\ \\mathrm{g\\,cm^{-3}}} = 3.0 \\times 10^7\\ \\mathrm{cm\\,s^{-1}}$$\n    To four significant figures, this is $3.000 \\times 10^7\\ \\mathrm{cm\\,s^{-1}}$.\n\n2.  **Calculate $e$**:\n    First, calculate the kinetic energy density $E_k$:\n    $$E_k = \\frac{m^2}{2\\rho} = \\frac{(3.0 \\times 10^{-17}\\ \\mathrm{g\\,cm^{-2}\\,s^{-1}})^2}{2(1.0 \\times 10^{-24}\\ \\mathrm{g\\,cm^{-3}})} = \\frac{9.0 \\times 10^{-34}\\ \\mathrm{g^2\\,cm^{-4}\\,s^{-2}}}{2.0 \\times 10^{-24}\\ \\mathrm{g\\,cm^{-3}}} = 4.5 \\times 10^{-10}\\ \\mathrm{g\\,cm^{-1}\\,s^{-2}}$$\n    Since $1\\ \\mathrm{erg} = 1\\ \\mathrm{g\\,cm^2\\,s^{-2}}$, then $1\\ \\mathrm{erg\\,cm^{-3}} = 1\\ \\mathrm{g\\,cm^{-1}\\,s^{-2}}$.\n    $$E_k = 4.5 \\times 10^{-10}\\ \\mathrm{erg\\,cm^{-3}}$$\n    Now, calculate $e$:\n    $$e = E - E_k = 1.45 \\times 10^{-9} - 4.5 \\times 10^{-10} = 1.45 \\times 10^{-9} - 0.45 \\times 10^{-9}$$\n    $$e = 1.0 \\times 10^{-9}\\ \\mathrm{erg\\,cm^{-3}}$$\n    To four significant figures, this is $1.000 \\times 10^{-9}\\ \\mathrm{erg\\,cm^{-3}}$.\n\n3.  **Calculate $P$ and Assess Admissibility**:\n    $$P = (\\gamma - 1)e = \\left(\\frac{5}{3} - 1\\right)(1.0 \\times 10^{-9}\\ \\mathrm{erg\\,cm^{-3}}) = \\frac{2}{3} \\times 10^{-9}\\ \\mathrm{erg\\,cm^{-3}}$$\n    $$P \\approx 6.6666... \\times 10^{-10}\\ \\mathrm{erg\\,cm^{-3}}$$\n    The required condition for physical admissibility is $P > 0$. Since $P \\approx 6.667 \\times 10^{-10} > 0$, the state is physically admissible. This is equivalent to the condition that the total energy density must exceed the kinetic energy density, $E > E_k$, which is true: $1.45 \\times 10^{-9} > 4.5 \\times 10^{-10}$.\n    Rounding to four significant figures, $P \\approx 6.667 \\times 10^{-10}\\ \\mathrm{erg\\,cm^{-3}}$.\n\n4.  **Calculate $c_s$**:\n    $$c_s = \\sqrt{\\frac{\\gamma P}{\\rho}} = \\sqrt{\\frac{(5/3)(\\frac{2}{3} \\times 10^{-9}\\ \\mathrm{erg\\,cm^{-3}})}{1.0 \\times 10^{-24}\\ \\mathrm{g\\,cm^{-3}}}}$$\n    $$c_s = \\sqrt{\\frac{\\frac{10}{9} \\times 10^{-9}}{1.0 \\times 10^{-24}}} = \\sqrt{\\frac{10}{9} \\times 10^{15}}\\ \\mathrm{cm\\,s^{-1}}$$\n    $$c_s = \\sqrt{\\frac{100}{9} \\times 10^{14}}\\ \\mathrm{cm\\,s^{-1}} = \\frac{10}{3} \\times 10^7\\ \\mathrm{cm\\,s^{-1}} \\approx 3.3333... \\times 10^7\\ \\mathrm{cm\\,s^{-1}}$$\n    Rounding to four significant figures, $c_s \\approx 3.333 \\times 10^7\\ \\mathrm{cm\\,s^{-1}}$.\n\nThe final evaluated quartet $(u, e, P, c_s)$, rounded to four significant figures, is:\n$u = 3.000 \\times 10^7\\ \\mathrm{cm\\,s^{-1}}$\n$e = 1.000 \\times 10^{-9}\\ \\mathrm{erg\\,cm^{-3}}$\n$P = 6.667 \\times 10^{-10}\\ \\mathrm{erg\\,cm^{-3}}$\n$c_s = 3.333 \\times 10^7\\ \\mathrm{cm\\,s^{-1}}$",
            "answer": "$$\\boxed{\\begin{pmatrix} 3.000 \\times 10^7  1.000 \\times 10^{-9}  6.667 \\times 10^{-10}  3.333 \\times 10^7 \\end{pmatrix}}$$"
        },
        {
            "introduction": "While the algebraic conversion from conserved to primitive variables seems straightforward, it is numerically fragile in the extreme environments of cosmic voids. As density approaches zero, calculating the internal energy by subtracting the large kinetic energy from the large total energy can lead to catastrophic cancellation and unphysical negative pressures. This exercise  tackles this ubiquitous challenge by implementing a \"positivity-preserving\" recovery scheme, a crucial technique that enforces physical admissibility by applying density and pressure floors.",
            "id": "3495161",
            "problem": "Consider a one-dimensional ideal cosmic fluid in comoving coordinates, modeled by the Euler equations for a compressible gas with a gamma-law Equation of State (EOS). The primitive variables are the comoving mass density $\\rho$, the peculiar velocity $u$, and the thermal pressure $P$. The conserved variables are defined by $D=\\rho$, $S=\\rho u$, and $E$, the total comoving energy density, which includes internal and kinetic contributions. The gamma-law EOS for an ideal gas states $P=(\\gamma-1)U$, where $U$ is the internal energy density and $\\gamma$ is the adiabatic index. In the Euler system, the conserved total energy density satisfies $E=U+\\frac{1}{2}\\rho u^2$.\n\nIn numerical cosmology, near-vacuum regions can form due to cosmic void expansion, often characterized by an extreme negative density contrast $\\delta\\to -1$, where $\\delta$ is defined as $\\delta = (\\rho - \\bar{\\rho})/\\bar{\\rho}$ and $\\bar{\\rho}$ is the background density. In such regimes, robust recovery of primitive variables from conserved variables must ensure $\\rho0$ and $P0$, despite extreme round-off and cancellation in $E - \\frac{1}{2}\\rho u^2$.\n\nStarting from the fundamental definitions above and the gamma-law EOS for an ideal gas, derive a positivity-preserving primitive-variable recovery mapping from conserved variables $(D,S,E)$ to primitives $(\\rho,u,P)$ that guarantees strictly positive $\\rho$ and $P$ even when numerical artifacts make the internal energy $U$ nonpositive. Work in dimensionless code units: set $\\bar{\\rho}=1$ and treat all quantities as dimensionless. Assume a one-dimensional flow and adopt an adiabatic index $\\gamma = 5/3$. Let the density floor be $\\rho_{\\min}=10^{-12}$ and the pressure floor be $P_{\\min}=10^{-12}$.\n\nYour program must implement the following recovery logic, justified by your derivation:\n- Compute $\\rho = \\max(D,\\rho_{\\min})$.\n- Compute $u = S/\\rho$.\n- Compute the kinetic energy density $K = \\frac{1}{2}\\rho u^2$ and the internal energy density candidate $U^\\ast = E - K$.\n- If $U^\\ast \\le \\frac{P_{\\min}}{\\gamma-1}$, replace $U^\\ast$ by $U = \\frac{P_{\\min}}{\\gamma-1}$ and reset $E$ to $E = U + K$; otherwise set $U=U^\\ast$.\n- Compute $P = (\\gamma-1)U$.\n\nUse the background density $\\bar{\\rho}=1$ to construct conserved variables $D$, $S$, and $E$ for a given density contrast $\\delta$, velocity $u$, and internal specific energy $e$ (internal energy per unit mass), via:\n- $\\rho_{\\mathrm{input}} = \\bar{\\rho}(1+\\delta)$,\n- $D = \\rho_{\\mathrm{input}}$,\n- $S = D \\, u$,\n- $E = D \\, e + \\frac{1}{2} D \\, u^2$.\n\nNote that due to severe cancellation at extreme voids, $e$ may be zero or slightly negative, representing plausible numerical artifacts in near-vacuum machine precision regimes; the recovery should remain robust and ensure $P0$.\n\nTest Suite:\nImplement and evaluate the recovery on the following five test cases, each provided as a tuple $(\\delta, u, e)$:\n1. $(\\delta, u, e) = (-0.9, 0.0, 10^{-6})$.\n2. $(\\delta, u, e) = (-1 + 10^{-12}, 0.0, 10^{-24})$.\n3. $(\\delta, u, e) = (-0.999999999999, 10^{-3}, 10^{-30})$.\n4. $(\\delta, u, e) = (-0.99, 10.0, 0.0)$.\n5. $(\\delta, u, e) = (-0.999, 1.0, -10^{-16})$.\n\nAll quantities are dimensionless. For each case, construct $(D,S,E)$ as above, recover $(\\rho,u,P)$ using the positivity-preserving mapping, and verify strict positivity of $\\rho$ and $P$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result should be a boolean indicating whether both recovered $\\rho$ and $P$ are strictly positive for the corresponding test case, in the order listed above, e.g., \"[true,true,false,...]\".",
            "solution": "We consider an ideal cosmic fluid in comoving coordinates, with primitive variables $(\\rho,u,P)$ and conserved variables $(D,S,E)$. The gamma-law Equation of State (EOS) is $P=(\\gamma-1)U$ with internal energy density $U$. The total energy density is $E=U+\\frac{1}{2}\\rho u^2$. The fluid is one-dimensional, and the adiabatic index is $\\gamma=5/3$.\n\nThe fundamental base is the Euler system's definitions and the gamma-law EOS. We aim to recover $(\\rho,u,P)$ from the conserved $(D,S,E)$ while ensuring positivity in near-vacuum, where $\\delta\\to -1$. In cosmology, the density contrast $\\delta$ is $\\delta=(\\rho-\\bar{\\rho})/\\bar{\\rho}$, so given $\\bar{\\rho}=1$ in code units, the input density is $\\rho_{\\mathrm{input}}=1+\\delta$. Constructing conserved variables for a test with given $(\\delta,u,e)$, where $e$ is the internal energy per unit mass, follows:\n$$\nD=\\rho_{\\mathrm{input}},\\quad S=D\\,u,\\quad E=D\\,e+\\frac{1}{2}D\\,u^2.\n$$\n\nThe primitive recovery from $(D,S,E)$ is derived by inverting the definitions:\n1. From mass conservation, the primitive density is $D=\\rho$. However, in near-vacuum regions, numerical round-off or model floors are used to avoid nonphysical zero or negative density. Therefore, impose a density floor:\n$$\n\\rho = \\max(D,\\rho_{\\min}),\n$$\nwith $\\rho_{\\min}=10^{-12}$ in code units. This ensures strict positivity $\\rho0$.\n2. The velocity recovers from momentum:\n$$\nu = \\frac{S}{\\rho}.\n$$\nThis uses the floored $\\rho$ to avoid division by zero. Note $S$ is conserved, so if $\\rho$ is increased by the floor, $u$ is reduced accordingly, which is consistent with conserving $S$.\n3. The kinetic energy density is defined from primitives:\n$$\nK = \\frac{1}{2}\\rho u^2.\n$$\n4. The internal energy density candidate is the difference between total energy density and kinetic energy:\n$$\nU^\\ast = E - K.\n$$\nIn extreme voids with $\\delta\\to -1$, $D$ can be very small and $E$ can be nearly equal to $K$, so $U^\\ast$ may be nonpositive due to cancellation or round-off, especially if the provided $e$ is zero or slightly negative as a plausible numerical artifact. To ensure nonnegative and strictly positive pressure, enforce a pressure floor $P_{\\min}=10^{-12}$ and its corresponding internal energy floor:\n$$\nU_{\\min} = \\frac{P_{\\min}}{\\gamma-1}.\n$$\nThe positivity-preserving rule is:\n$$\nU = \\begin{cases}\nU^\\ast,  \\text{if } U^\\ast  U_{\\min},\\\\\nU_{\\min},  \\text{otherwise}.\n\\end{cases}\n$$\nIf the floor is applied, reset the total energy to be consistent,\n$$\nE \\leftarrow U + K,\n$$\nso the conserved energy remains a valid sum of internal and kinetic components post-fix.\n5. Finally, recover pressure via the gamma-law EOS:\n$$\nP = (\\gamma-1)U.\n$$\n\nThis mapping guarantees $\\rho0$ by construction via the density floor and $P0$ via the pressure floor. It is a standard positivity-preserving primitive recovery used in numerical cosmology and computational fluid dynamics under extreme low-density conditions.\n\nAlgorithmic design integrating principles:\n- Inputs are $(\\delta,u,e)$ for each test. Using $\\bar{\\rho}=1$, set $D=1+\\delta$, $S=D\\,u$, and $E=D\\,e+\\frac{1}{2}D\\,u^2$.\n- Apply the recovery mapping:\n  - Compute $\\rho=\\max(D,\\rho_{\\min})$.\n  - Compute $u=S/\\rho$.\n  - Compute $K=\\frac{1}{2}\\rho u^2$.\n  - Compute $U^\\ast=E-K$.\n  - If $U^\\ast\\le U_{\\min}$, set $U=U_{\\min}$ and reset $E=U+K$, else set $U=U^\\ast$.\n  - Compute $P=(\\gamma-1)U$.\n- Validate positivity by checking $(\\rho0)$ and $(P0)$ strictly.\n- Aggregate the positivity checks as booleans for the test suite.\n\nTest suite coverage rationale:\n- Case 1 uses a strong void but not extreme, zero velocity, and small internal energy, a \"happy path\" with positive $U^\\ast$.\n- Case 2 probes $\\delta$ very close to $-1$ with minuscule internal energy, relying on floors.\n- Case 3 combines extreme $\\delta$ with small nonzero velocity, testing cancellation in $E-K$.\n- Case 4 sets $e=0$ and large $u$ relative to density, so $E=K$ and the pressure floor must activate.\n- Case 5 introduces a slight negative $e$, a realistic numerical artifact, ensuring the floor rectifies $U^\\ast\\le 0$.\n\nOutput specification:\nProduce a single line: a comma-separated list enclosed in square brackets of five booleans, each indicating whether both recovered $\\rho$ and $P$ are strictly positive for the corresponding test case, ordered as listed.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef recover_primitives(D, S, E, gamma, rho_floor, P_floor):\n    \"\"\"\n    Positivity-preserving primitive-variable recovery for 1D gamma-law ideal gas.\n    Inputs:\n        D: conserved density (dimensionless)\n        S: conserved momentum density (dimensionless)\n        E: conserved total energy density (dimensionless)\n        gamma: adiabatic index\n        rho_floor: minimum allowed density\n        P_floor: minimum allowed pressure\n    Returns:\n        rho: recovered density (0)\n        u: recovered velocity\n        P: recovered pressure (0)\n    \"\"\"\n    # Density floor\n    rho = max(D, rho_floor)\n\n    # Velocity from momentum and floored density\n    # If rho is extremely small, this keeps u finite given S.\n    u = S / rho\n\n    # Kinetic energy density\n    K = 0.5 * rho * u * u\n\n    # Internal energy candidate\n    U_star = E - K\n\n    # Internal energy floor corresponding to pressure floor\n    U_min = P_floor / (gamma - 1.0)\n\n    if not np.isfinite(U_star) or U_star = U_min:\n        U = U_min\n        # Reset E to keep consistency E = U + K\n        E = U + K\n    else:\n        U = U_star\n\n    # Pressure from EOS\n    P = (gamma - 1.0) * U\n\n    return rho, u, P\n\ndef construct_conserved(delta, u, e, rho_bg=1.0):\n    \"\"\"\n    Construct conserved variables from (delta, u, e) in code units with rho_bg = 1.\n    D = rho_input = rho_bg * (1 + delta)\n    S = D * u\n    E = D * e + 0.5 * D * u^2\n    \"\"\"\n    D = rho_bg * (1.0 + delta)\n    S = D * u\n    E = D * e + 0.5 * D * u * u\n    return D, S, E\n\ndef solve():\n    # Constants in code units\n    gamma = 5.0 / 3.0\n    rho_floor = 1e-12\n    P_floor = 1e-12\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (delta, u, e)\n    test_cases = [\n        (-0.9, 0.0, 1e-6),\n        (-1.0 + 1e-12, 0.0, 1e-24),\n        (-0.999999999999, 1e-3, 1e-30),\n        (-0.99, 10.0, 0.0),\n        (-0.999, 1.0, -1e-16),\n    ]\n\n    results = []\n    for delta, u, e in test_cases:\n        D, S, E = construct_conserved(delta, u, e, rho_bg=1.0)\n        rho, u_rec, P = recover_primitives(D, S, E, gamma, rho_floor, P_floor)\n        # Check strict positivity\n        ok = (rho  0.0) and (P  0.0) and np.isfinite(rho) and np.isfinite(P)\n        results.append(ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The dynamics of a cosmic fluid are shaped not only by hydrodynamic forces but also by source terms arising from the expansion of the universe. This exercise  isolates the most important of these: the \"Hubble drag\" term, which damps peculiar velocities over cosmic time. By implementing and comparing an explicit and an implicit numerical integrator for this stiff ordinary differential equation, you will gain critical insights into the trade-offs between accuracy, stability, and computational cost that are central to designing modern cosmological codes.",
            "id": "3495167",
            "problem": "Consider an ideal, compressible cosmic fluid evolving in a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) background in comoving coordinates. In this setting, the Euler momentum equation contains a source term due to Hubble expansion that damps peculiar velocities. Neglecting spatial gradients and all non-source physics, the velocity $\\,\\mathbf{v}(t)\\,$ obeys a linear ordinary differential equation (ODE) of the form\n$$\n\\frac{d\\mathbf{v}}{dt} \\;=\\; -\\frac{\\dot{a}(t)}{a(t)}\\,\\mathbf{v}(t),\n$$\nwhere $\\,a(t)\\,$ is the cosmological scale factor and $\\,\\dot{a}(t) \\equiv \\frac{da}{dt}\\,$. Define the Hubble parameter $\\,H(t) \\equiv \\frac{\\dot{a}(t)}{a(t)}\\,$. For a matter-dominated Universe with $\\,a(t) \\propto t^{2/3}\\,$, one has $\\,H(t) = \\frac{2}{3t}\\,$.\n\nYour task is to implement a staggered-in-time source-term integrator for the damping term $\\, -(\\dot{a}/a)\\mathbf{v}\\,$ and compare a Strang-splitting-style staggered integrator against an Implicit–Explicit (IMEX) integrator for accuracy and stability in high-Mach-number flows. For numerical cosmology, Mach number $\\,\\mathcal{M}\\,$ is defined by $\\,\\mathcal{M} \\equiv \\frac{\\|\\mathbf{v}\\|}{c_s}\\,$, where $\\,c_s\\,$ is the sound speed. In this problem, use $\\,c_s = 1\\,\\mathrm{m/s}\\,$ and express velocities in $\\,\\mathrm{m/s}\\,$ and times in $\\,\\mathrm{s}\\,$.\n\nStarting from the fundamental base that the Euler momentum equation in comoving coordinates acquires a damping term proportional to $\\,H(t)\\,$ due to cosmological expansion, derive an algorithmic approach to integrate the source ODE for $\\,\\mathbf{v}(t)\\,$ over a time interval $[t_0, t_{\\mathrm{end}}]$ using a time step $\\,\\Delta t = (t_{\\mathrm{end}}-t_0)/N\\,$, where $\\,N\\,$ is the number of uniform steps. Implement the following two integrators:\n\n1. A Strang-splitting-style staggered-in-time explicit midpoint update for the source term, which evaluates $\\,H(t)\\,$ at staggered times within each step to achieve second-order temporal centering. Within each step from $\\,t_n\\,$ to $\\,t_{n+1} = t_n + \\Delta t\\,$, update\n$$\n\\mathbf{v}_{n+1} \\approx \\mathbf{v}_n - \\Delta t \\, H\\!\\left(t_n + \\frac{\\Delta t}{2}\\right)\\, \\mathbf{v}_n.\n$$\n\n2. An Implicit–Explicit (IMEX) backward-Euler update for the source term, which treats the source implicitly at the end of the step,\n$$\n\\mathbf{v}_{n+1} = \\frac{\\mathbf{v}_n}{1 + \\Delta t \\, H(t_{n+1})}.\n$$\n\nFor validation, use the matter-dominated cosmology $\\,a(t) = \\left(\\frac{t}{t_0}\\right)^{2/3}\\,$ with $\\,t_0 > 0\\,$, for which the exact solution of the source-term ODE is\n$$\n\\mathbf{v}(t) = \\mathbf{v}(t_0)\\,\\frac{a(t_0)}{a(t)} \\;=\\; \\mathbf{v}(t_0)\\,\\left(\\frac{t_0}{t}\\right)^{2/3}.\n$$\n\nDefine the following measurable quantities for each integrator over the entire interval:\n\n- The relative error at $\\,t_{\\mathrm{end}}\\,$, computed as\n$$\n\\mathrm{err} = \\frac{\\|\\mathbf{v}_{\\mathrm{num}}(t_{\\mathrm{end}}) - \\mathbf{v}_{\\mathrm{exact}}(t_{\\mathrm{end}})\\|}{\\|\\mathbf{v}_{\\mathrm{exact}}(t_{\\mathrm{end}})\\|},\n$$\nwhere $\\,\\mathbf{v}_{\\mathrm{num}}\\,$ is the numerically integrated velocity and $\\,\\mathbf{v}_{\\mathrm{exact}}\\,$ is the analytic solution above.\n\n- A stability flag, defined as follows. Let $\\,v_n\\,$ be the magnitude of velocity at step $\\,n\\,$. The integration is deemed numerically stable if:\n  - All $\\,v_n\\,$ remain finite for $\\,n=1,\\dots,N\\,$.\n  - The sign of the velocity does not change (for a positive initial velocity).\n  - The sequence $\\,|v_n|\\,$ is monotonically non-increasing (within a tolerance of $\\,10^{-12}\\,$) over the steps, reflecting the physical damping expected from $\\,H(t)  0\\,$.\n\nImplement both integrators for scalar velocity $\\,v(t)\\,$ with the initial velocity set by the Mach number $\\,\\mathcal{M}\\,$ via $\\,v(t_0) = \\mathcal{M}\\,c_s\\,$, and compare their performance on the following test suite of parameters:\n\n- Case A (happy path): $\\,\\mathcal{M} = 2\\,$, $\\,t_0 = 1\\,\\mathrm{s}\\,$, $\\,t_{\\mathrm{end}} = 10\\,\\mathrm{s}\\,$, $\\,N = 100\\,$.\n- Case B (high Mach, moderately large step): $\\,\\mathcal{M} = 50\\,$, $\\,t_0 = 1\\,\\mathrm{s}\\,$, $\\,t_{\\mathrm{end}} = 10\\,\\mathrm{s}\\,$, $\\,N = 10\\,$.\n- Case C (high Mach, single large step to probe stability limits): $\\,\\mathcal{M} = 100\\,$, $\\,t_0 = 1\\,\\mathrm{s}\\,$, $\\,t_{\\mathrm{end}} = 9\\,\\mathrm{s}\\,$, $\\,N = 1\\,$.\n\nYour program should compute, for each case, the tuple $[\\mathrm{err}_{\\mathrm{Strang}}, \\mathrm{err}_{\\mathrm{IMEX}}, \\mathrm{stable}_{\\mathrm{Strang}}, \\mathrm{stable}_{\\mathrm{IMEX}}]$ and aggregate the three tuples into a single line of output. The final output must be a single Python list of lists printed on one line, exactly in the format\n$$\n[[e_{A,S},e_{A,I},s_{A,S},s_{A,I}],[e_{B,S},e_{B,I},s_{B,S},s_{B,I}],[e_{C,S},e_{C,I},s_{C,S},s_{C,I}]],\n$$\nwith floating-point errors and boolean stability flags.",
            "solution": "The problem requires the implementation and comparison of two numerical integrators for the ordinary differential equation (ODE) governing the decay of peculiar velocities due to Hubble expansion in a simplified cosmological model. The ODE is given as:\n$$\n\\frac{d\\mathbf{v}}{dt} = -H(t)\\mathbf{v}(t)\n$$\nwhere $\\mathbf{v}(t)$ is the peculiar velocity and $H(t)$ is the Hubble parameter. For the specified matter-dominated universe, $H(t) = \\frac{2}{3t}$. The problem simplifies to a scalar velocity $v(t)$, so the governing equation is:\n$$\n\\frac{dv}{dt} = -\\frac{2}{3t}v(t)\n$$\nThis is a linear, first-order ODE. The initial condition is given at time $t_0$ as $v(t_0) = \\mathcal{M}c_s$, where the sound speed $c_s = 1\\,\\mathrm{m/s}$.\n\nBefore detailing the numerical schemes, we establish the ground truth by using the provided analytical solution, which can be derived by separating variables and integrating:\n$$\n\\int_{v(t_0)}^{v(t)} \\frac{dv'}{v'} = -\\int_{t_0}^{t} \\frac{2}{3t'} dt' \\implies \\ln\\left(\\frac{v(t)}{v(t_0)}\\right) = -\\frac{2}{3}\\ln\\left(\\frac{t}{t_0}\\right)\n$$\nExponentiating both sides yields the exact solution:\n$$\nv_{\\mathrm{exact}}(t) = v(t_0)\\left(\\frac{t_0}{t}\\right)^{2/3}\n$$\nThis solution will be used to compute the error of the numerical methods. Since $t  t_0  0$, the term $(t_0/t)^{2/3}$ is always less than $1$, confirming that the velocity is a monotonically decreasing function of time, as expected from a damping term.\n\nThe core of the problem is to implement and analyze two numerical schemes over a time interval $[t_0, t_{\\mathrm{end}}]$ divided into $N$ uniform steps of size $\\Delta t = (t_{\\mathrm{end}}-t_0)/N$.\n\n1.  **Strang-splitting-style Staggered Midpoint Integrator**\n\nThis is an explicit, second-order accurate scheme. The update rule for a step from $t_n$ to $t_{n+1} = t_n + \\Delta t$ is:\n$$\nv_{n+1} = v_n - \\Delta t H\\left(t_n + \\frac{\\Delta t}{2}\\right) v_n = v_n \\left(1 - \\Delta t H\\left(t_n + \\frac{\\Delta t}{2}\\right)\\right)\n$$\nThe amplification factor for this method is $g_{\\mathrm{Strang}} = 1 - \\Delta t H(t_n + \\Delta t/2)$. This is an explicit method because $v_{n+1}$ is computed directly from the known value $v_n$. Explicit methods are often subject to a stability constraint on the time step $\\Delta t$. For the physical process of damping, we expect the velocity to remain positive (if it starts positive) and decrease in magnitude. This requires the amplification factor to be in the range $0 \\le g_{\\mathrm{Strang}}  1$. The condition $g_{\\mathrm{Strang}} \\ge 0$ implies:\n$$\n1 - \\Delta t H\\left(t_n + \\frac{\\Delta t}{2}\\right) \\ge 0 \\implies \\Delta t \\le \\frac{1}{H\\left(t_n + \\frac{\\Delta t}{2}\\right)}\n$$\nIf $\\Delta t$ is too large, this condition can be violated, leading to $g_{\\mathrm{Strang}}  0$. This causes the velocity to change sign, an unphysical \"overshoot\" that violates the problem's stability criteria.\n\n2.  **Implicit-Explicit (IMEX) Backward-Euler Integrator**\n\nThis scheme treats the stiff damping term implicitly. The update rule is derived from the backward-Euler formulation:\n$$\n\\frac{v_{n+1} - v_n}{\\Delta t} = -H(t_{n+1}) v_{n+1}\n$$\nRearranging to solve for $v_{n+1}$ gives:\n$$\nv_{n+1}(1 + \\Delta t H(t_{n+1})) = v_n \\implies v_{n+1} = \\frac{v_n}{1 + \\Delta t H(t_{n+1})}\n$$\nThe amplification factor is $g_{\\mathrm{IMEX}} = \\frac{1}{1 + \\Delta t H(t_{n+1})}$. Since $H(t) > 0$ and $\\Delta t > 0$ for our problem, the denominator is always greater than $1$. Consequently, $0  g_{\\mathrm{IMEX}}  1$ for any choice of $\\Delta t  0$. This property, known as unconditional stability or A-stability for this type of problem, guarantees that the numerical solution will always be finite, preserve the sign of the velocity, and exhibit monotonic decay, regardless of the time step size. This makes implicit methods highly robust for stiff ODEs, such as those with strong damping terms.\n\nThe algorithmic implementation will proceed as follows for each test case:\nFirst, initialize $v_0 = \\mathcal{M}c_s$ at $t_0$. Then, for each integrator, loop $N$ times. In each step $n$:\n- Calculate the current time $t_n = t_0 + n\\Delta t$.\n- Apply the respective update rule to find $v_{n+1}$ from $v_n$.\n- Store all intermediate velocities $v_0, v_1, \\dots, v_N$.\n\nAfter the final step, we compute the required metrics:\n- **Relative Error**: The final numerical velocity $v_{\\mathrm{num}}(t_{\\mathrm{end}}) = v_N$ is compared to the exact solution $v_{\\mathrm{exact}}(t_{\\mathrm{end}})$.\n$$\n\\mathrm{err} = \\frac{|v_N - v_{\\mathrm{exact}}(t_{\\mathrm{end}})|}{|v_{\\mathrm{exact}}(t_{\\mathrm{end}})|}\n$$\n- **Stability Flag**: The stored sequence of velocities $(v_n)_{n=0}^N$ is checked against three conditions: all values are finite; all values are non-negative (since $v_0  0$); and the sequence is monotonically non-increasing, i.e., $v_{n+1} - v_n \\le \\epsilon$ for a small tolerance $\\epsilon = 10^{-12}$. If all three conditions hold, the integration is flagged as stable.\n\nThe test cases are designed to probe the behavior of these integrators. Case A is a standard scenario with a small time step. Case B uses a larger time step and higher Mach number, pushing the limits of the explicit scheme. Case C uses a single, very large time step, which is expected to cause the explicit scheme to fail the stability L-test while the implicit scheme remains stable, albeit potentially inaccurate.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Implements and compares two numerical integrators for the cosmological\n    Hubble damping ODE, calculating their error and stability.\n    \"\"\"\n    \n    # Define physical constants and model parameters\n    c_s = 1.0  # Sound speed in m/s\n\n    # Define the test cases\n    # Each tuple is (Mach number, t_start, t_end, num_steps)\n    test_cases = [\n        # Case A: Happy path\n        (2.0, 1.0, 10.0, 100),\n        # Case B: High Mach, moderately large step\n        (50.0, 1.0, 10.0, 10),\n        # Case C: High Mach, single large step\n        (100.0, 1.0, 9.0, 1),\n    ]\n\n    # Hubble parameter for a matter-dominated universe\n    def H(t):\n        if t = 0:\n            return np.inf\n        return 2.0 / (3.0 * t)\n\n    # Exact analytical solution for the velocity\n    def v_exact(t, v0, t0):\n        if t = 0: return np.nan\n        return v0 * (t0 / t)**(2.0/3.0)\n\n    def check_stability(velocities):\n        \"\"\"\n        Checks if a sequence of velocities is stable according to the problem criteria.\n        \n        Args:\n            velocities (np.ndarray): The history of velocity values.\n        \n        Returns:\n            bool: True if stable, False otherwise.\n        \"\"\"\n        velocities = np.array(velocities)\n        \n        # 1. All v_n remain finite\n        is_finite = np.all(np.isfinite(velocities))\n        if not is_finite:\n            return False\n            \n        # 2. Sign of velocity does not change (non-negative for v0  0)\n        is_non_negative = np.all(velocities = 0.0)\n        if not is_non_negative:\n            return False\n\n        # 3. Sequence |v_n| is monotonically non-increasing (tolerance 10^-12)\n        # Since we check for non-negativity, |v_n| = v_n.\n        # We check if v[n+1] = v[n] + tol for all n.\n        # This is equivalent to v[n+1] - v[n] = tol.\n        diffs = np.diff(velocities)\n        is_non_increasing = np.all(diffs = 1e-12)\n        if not is_non_increasing:\n            return False\n\n        return True\n\n    def run_integrator(integrator_type, M, t0, t_end, N):\n        \"\"\"\n        Runs a single integration and returns final velocity and all steps.\n        \n        Args:\n            integrator_type (str): 'strang' or 'imex'.\n            M (float): Mach number.\n            t0 (float): Start time.\n            t_end (float): End time.\n            N (int): Number of steps.\n            \n        Returns:\n            tuple: (final_velocity, velocity_history)\n        \"\"\"\n        v0 = M * c_s\n        dt = (t_end - t0) / N\n        \n        v = v0\n        v_history = [v0]\n        \n        for n in range(N):\n            t_n = t0 + n * dt\n            if integrator_type == 'strang':\n                t_mid = t_n + dt / 2.0\n                v = v * (1.0 - dt * H(t_mid))\n            elif integrator_type == 'imex':\n                t_n1 = t_n + dt\n                v = v / (1.0 + dt * H(t_n1))\n            else:\n                raise ValueError(\"Unknown integrator type\")\n            v_history.append(v)\n            \n        return v, v_history\n\n\n    all_results = []\n\n    for case in test_cases:\n        M, t0, t_end, N = case\n        \n        v0 = M * c_s\n        v_exact_final = v_exact(t_end, v0, t0)\n        \n        # Run Strang-style integrator\n        v_num_strang, v_hist_strang = run_integrator('strang', M, t0, t_end, N)\n        err_strang = np.abs(v_num_strang - v_exact_final) / np.abs(v_exact_final)\n        stable_strang = check_stability(v_hist_strang)\n\n        # Run IMEX integrator\n        v_num_imex, v_hist_imex = run_integrator('imex', M, t0, t_end, N)\n        err_imex = np.abs(v_num_imex - v_exact_final) / np.abs(v_exact_final)\n        stable_imex = check_stability(v_hist_imex)\n        \n        all_results.append([err_strang, err_imex, stable_strang, stable_imex])\n\n    # Final print statement in the exact required format.\n    # The format requires no spaces between list elements.\n    print(str(all_results).replace(\" \", \"\").replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\nsolve()\n```"
        }
    ]
}