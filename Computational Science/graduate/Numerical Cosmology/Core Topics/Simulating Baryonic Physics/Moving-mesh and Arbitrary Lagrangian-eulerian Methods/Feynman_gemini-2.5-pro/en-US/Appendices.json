{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any robust moving-mesh code is the strict enforcement of the Geometric Conservation Law (GCL). This principle ensures that the numerical discretization correctly accounts for the change in cell volume due to mesh motion, thereby preventing the creation of spurious mass, momentum, or energy from the geometry itself. This practice guides you through the implementation and verification of the GCL, demonstrating its critical role by showing how a failure to satisfy it prevents the code from preserving even a simple uniform fluid state .",
            "id": "3480236",
            "problem": "Consider a two-dimensional moving-mesh finite-volume discretization suitable for Arbitrary Lagrangian-Eulerian (ALE) methods in numerical cosmology. Each computational cell is a simple polygon with vertices $\\{(x_i,y_i)\\}_{i=0}^{N_v-1}$ ordered counterclockwise. The mesh moves with a prescribed mesh velocity field $\\mathbf{w}(x,y)$ that may vary spatially, and the fluid velocity $\\mathbf{v}$ is taken to be $\\mathbf{0}$ for the purposes of this diagnostic. Let $V$ denote the cell area. For each face $f$ of the polygon, let $A_f$ denote the face measure (edge length in two dimensions) and let $\\mathbf{n}_f$ be the outward unit normal. The face-centered normal mesh velocity is denoted by $(\\mathbf{w}\\cdot\\mathbf{n})_f$.\n\nThe discrete Geometric Conservation Law (GCL) per cell requires that the face-normal mesh motion be consistent with the rate of change of the cell volume (area in two dimensions). Specifically, the law states that\n$$\n\\sum_{f} A_f\\,(\\mathbf{w}\\cdot\\mathbf{n})_f \\;=\\; \\frac{dV}{dt}.\n$$\nIn ALE finite-volume form for a passive scalar $u$ obeying the conservation law $\\partial_t u + \\nabla\\cdot(u\\,\\mathbf{v})=0$, the moving-mesh semi-discrete update for the cell average $u$ is\n$$\n\\frac{d}{dt}\\left(V u\\right) + \\sum_{f} A_f\\, u\\,(\\mathbf{v}-\\mathbf{w})\\cdot\\mathbf{n}_f \\;=\\; 0.\n$$\nA uniform solution $u=\\text{const.}$ must remain invariant under arbitrary mesh motion if and only if the discrete GCL holds exactly.\n\nTasks to implement:\n- Derive from fundamental geometric identities an algorithm to compute the cell area $V$ and its time derivative $dV/dt$ using only the vertex positions $\\{(x_i,y_i)\\}$ and vertex velocities $\\{(w^x_i,w^y_i)\\}$.\n- For the given test suite, compute the uncorrected face-normal sum $S=\\sum_f A_f(\\mathbf{w}\\cdot\\mathbf{n})_f$ and the GCL residual $R=S-\\frac{dV}{dt}$ for each cell.\n- Enforce the discrete GCL per cell exactly by applying the minimum-norm uniform per-face additive correction to $(\\mathbf{w}\\cdot\\mathbf{n})_f$ such that the corrected sum equals $\\frac{dV}{dt}$.\n- Using the ALE finite-volume update for $u$ with $\\mathbf{v}=\\mathbf{0}$, compute the one-step update $u(t+\\Delta t)$ for a uniform $u$ both before and after enforcing the GCL, and construct diagnostics that detect drift from the uniform solution. Report whether the corrected update preserves uniformity within a strict tolerance.\n- All quantities are to be treated in dimensionless code units. Express the final diagnostic booleans exactly as True or False.\n\nTest suite specification (each test case provides vertices, vertex velocities, face-centered normal mesh velocities, and the time step):\n- Case $1$ (happy path: uniform translation, zero area change):\n  - Vertices: $\\{(0,0),(1,0),(1,1),(0,1)\\}$.\n  - Vertex velocities (each vertex): $(0.5,-0.3)$.\n  - Face-centered mesh velocity: constant $(0.5,-0.3)$ at all face centers, used to form $(\\mathbf{w}\\cdot\\mathbf{n})_f$.\n  - Time step: $\\Delta t = 0.1$.\n- Case $2$ (expanding square, inconsistent face data to trigger GCL correction):\n  - Vertices: $\\{(0,0),(1,0),(1,1),(0,1)\\}$.\n  - Vertex velocities: $(0.2\\,x_i,\\,0.2\\,y_i)$ at each vertex $(x_i,y_i)$.\n  - Face-centered mesh velocity: $(0.15\\,x_c,\\,0.15\\,y_c)$ at each face center $(x_c,y_c)$, used to form $(\\mathbf{w}\\cdot\\mathbf{n})_f$.\n  - Time step: $\\Delta t = 0.1$.\n- Case $3$ (shear motion on a skew quadrilateral, add deterministic face inconsistency):\n  - Vertices: $\\{(0,0),(2,0),(2.2,1.2),(-0.1,1.0)\\}$.\n  - Vertex velocities: $(0.3\\,y_i,\\,0)$ at each vertex $(x_i,y_i)$.\n  - Face-centered mesh velocity: $(0.3\\,y_c,\\,0)$ at each face center $(x_c,y_c)$, then add a deterministic offset of $0.01\\times f$ directly to $(\\mathbf{w}\\cdot\\mathbf{n})_f$ for face index $f$ in cyclic order.\n  - Time step: $\\Delta t = 0.1$.\n- Case $4$ (slender rectangle, near-degenerate geometry, top-face inconsistency):\n  - Vertices: $\\{(0,0),(5,0),(5,0.05),(0,0.05)\\}$.\n  - Vertex velocities: $(0,0.01)$ at vertices $(0,0)$ and $(0,0.05)$, and $(0,0.02)$ at vertices $(5,0)$ and $(5,0.05)$.\n  - Face-centered mesh velocity: take the arithmetic average of the two endpoint vertex velocities and project onto $\\mathbf{n}_f$ to obtain $(\\mathbf{w}\\cdot\\mathbf{n})_f$, then subtract $0.003$ from $(\\mathbf{w}\\cdot\\mathbf{n})_f$ on the top face only.\n  - Time step: $\\Delta t = 0.1$.\n\nDiagnostics and answer specification:\n- For each case, compute the corrected GCL residual and the corrected uniform-solution drift after one time step. Declare two booleans per case:\n  - $gcl\\_ok$: True if $\\left|\\sum_f A_f(\\mathbf{w}\\cdot\\mathbf{n})_f^{\\text{corr}} - \\frac{dV}{dt}\\right| \\le \\varepsilon$.\n  - $uniform\\_ok$: True if $\\left|u(t+\\Delta t) - u(t)\\right| \\le \\varepsilon$ after correction, with $u(t)=1$.\n- Use the strict tolerance $\\varepsilon = 10^{-12}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the two-entry list $[gcl\\_ok,uniform\\_ok]$ for the corresponding test case (e.g., $[[\\text{True},\\text{True}],[\\text{True},\\text{True}],\\dots]$).",
            "solution": "The problem requires an implementation and verification of the Geometric Conservation Law (GCL) for a two-dimensional moving-mesh finite-volume scheme. The GCL is a fundamental requirement for any numerical scheme on a time-dependent domain, ensuring that the discrete operators correctly account for the change in cell volumes due to mesh motion. A failure to satisfy the GCL can lead to spurious source terms, which, for instance, prevent the scheme from preserving a simple constant solution.\n\nFirst, we derive the necessary geometric and kinematic quantities for a polygonal cell from its vertex positions $\\{(x_i, y_i)\\}_{i=0}^{N_v-1}$ and vertex velocities $\\{(w^x_i, w^y_i)\\}_{i=0}^{N_v-1}$. The vertices are ordered counter-clockwise.\n\nThe area of the cell, denoted by $V$, can be computed using the shoelace formula:\n$$\nV = \\frac{1}{2} \\sum_{i=0}^{N_v-1} (x_i y_{i+1} - x_{i+1} y_i)\n$$\nwhere indices are taken modulo $N_v$. To find the time derivative of the area, $\\frac{dV}{dt}$, we differentiate this expression with respect to time, treating the vertex coordinates as functions of time, with $\\frac{dx_i}{dt} = w^x_i$ and $\\frac{dy_i}{dt} = w^y_i$. Applying the product rule for differentiation yields:\n$$\n\\frac{dV}{dt} = \\frac{1}{2} \\sum_{i=0}^{N_v-1} \\left( \\frac{dx_i}{dt} y_{i+1} + x_i \\frac{dy_{i+1}}{dt} - \\frac{dx_{i+1}}{dt} y_i - x_{i+1} \\frac{dy_i}{dt} \\right)\n$$\nSubstituting the vertex velocities gives:\n$$\n\\frac{dV}{dt} = \\frac{1}{2} \\sum_{i=0}^{N_v-1} (w^x_i y_{i+1} + x_i w^y_{i+1} - w^x_{i+1} y_i - x_{i+1} w^y_i)\n$$\nThis expression can be rearranged by collecting terms associated with each vertex velocity component $(w^x_i, w^y_i)$. This leads to a more computationally convenient form:\n$$\n\\frac{dV}{dt} = \\frac{1}{2} \\sum_{i=0}^{N_v-1} \\left[ w^x_i (y_{i+1} - y_{i-1}) + w^y_i (x_{i-1} - x_{i+1}) \\right]\n$$\nThis formula provides the exact rate of change of the cell area based solely on instantaneous vertex positions and velocities.\n\nThe discrete GCL is given by:\n$$\n\\sum_{f} A_f (\\mathbf{w} \\cdot \\mathbf{n})_f = \\frac{dV}{dt}\n$$\nHere, the sum is over the faces $f$ of the cell. For a face $f_i$ connecting vertex $i$ to vertex $i+1$, $A_{f_i}$ is its length and $\\mathbf{n}_{f_i}$ is the outward unit normal. The length is $A_{f_i} = \\sqrt{(x_{i+1}-x_i)^2 + (y_{i+1}-y_i)^2}$. For a counter-clockwise ordering of vertices, the outward unit normal is $\\mathbf{n}_{f_i} = \\frac{1}{A_{f_i}}(y_{i+1}-y_i, -(x_{i+1}-x_i))$. The term $(\\mathbf{w} \\cdot \\mathbf{n})_f$ is the face-normal mesh velocity, which is defined in distinct ways for each test case.\n\nThe problem states that the face-centered mesh velocities may be inconsistent with the vertex motions, leading to a violation of the GCL. We quantify this violation with the GCL residual, $R$:\n$$\nR = S - \\frac{dV}{dt}\n$$\nwhere $S = \\sum_f A_f (\\mathbf{w} \\cdot \\mathbf{n})_f$ is the uncorrected sum of face-normal velocity fluxes.\n\nTo enforce the GCL, we apply a uniform additive correction, $\\delta$, to each face-normal velocity $(\\mathbf{w} \\cdot \\mathbf{n})_f$. The corrected velocity is $(\\mathbf{w} \\cdot \\mathbf{n})_f^{\\text{corr}} = (\\mathbf{w} \\cdot \\mathbf{n})_f + \\delta$. The corrected sum $S^{\\text{corr}}$ is required to equal $\\frac{dV}{dt}$:\n$$\nS^{\\text{corr}} = \\sum_f A_f ((\\mathbf{w} \\cdot \\mathbf{n})_f + \\delta) = S + \\delta \\sum_f A_f = \\frac{dV}{dt}\n$$\nSolving for $\\delta$ gives the minimum-norm correction:\n$$\n\\delta = \\frac{\\frac{dV}{dt} - S}{\\sum_f A_f} = -\\frac{R}{L}\n$$\nwhere $L = \\sum_f A_f$ is the perimeter of the cell.\n\nThe significance of the GCL is demonstrated by its effect on preserving a uniform state. The problem gives the semi-discrete ALE update for a passive scalar $u$:\n$$\n\\frac{d}{dt}(V u) + \\sum_{f} A_f u (\\mathbf{v} - \\mathbf{w}) \\cdot \\mathbf{n}_f = 0\n$$\nWith the fluid velocity $\\mathbf{v}=\\mathbf{0}$ and a spatially uniform scalar $u$, we can write:\n$$\n\\frac{d(Vu)}{dt} - u \\sum_f A_f (\\mathbf{w} \\cdot \\mathbf{n})_f = 0\n$$\nExpanding the time derivative using the product rule, $u\\frac{dV}{dt} + V\\frac{du}{dt}$, we get:\n$$\nu\\frac{dV}{dt} + V\\frac{du}{dt} - u S = 0 \\quad \\implies \\quad V\\frac{du}{dt} = u(S - \\frac{dV}{dt}) = u R\n$$\nThis yields the rate of change of the uniform state:\n$$\n\\frac{du}{dt} = \\frac{R}{V} u\n$$\nClearly, if the GCL is satisfied ($R=0$), then $\\frac{du}{dt}=0$ and the uniform state is preserved. If $R \\ne 0$, the solution will spuriously drift.\n\nFor the numerical test, we use a first-order forward Euler time step of size $\\Delta t$:\n$$\nu(t+\\Delta t) \\approx u(t) + \\Delta t \\frac{du}{dt} = u(t) \\left(1 + \\frac{R \\Delta t}{V}\\right)\n$$\nWe compute the corrected GCL residual $R^{\\text{corr}} = S^{\\text{corr}} - \\frac{dV}{dt}$ and the corresponding updated scalar value $u(t+\\Delta t)$. By construction, $R^{\\text{corr}}$ will be zero up to floating-point error. The diagnostic `gcl_ok` checks if $|R^{\\text{corr}}| \\le \\varepsilon$, and `uniform_ok` checks if $|u(t+\\Delta t) - u(t)| \\le \\varepsilon$ for an initial state $u(t)=1$ and tolerance $\\varepsilon=10^{-12}$. For all test cases, the implemented correction ensures these conditions are met.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases and print the results.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"id\": 1,\n            \"vertices\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"vertex_vels_rule\": lambda p: np.array([0.5, -0.3]),\n            \"face_vel_rule\": lambda pc, n, A, f_idx, vw1, vw2: np.dot(np.array([0.5, -0.3]), n),\n            \"dt\": 0.1\n        },\n        {\n            \"id\": 2,\n            \"vertices\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"vertex_vels_rule\": lambda p: 0.2 * p,\n            \"face_vel_rule\": lambda pc, n, A, f_idx, vw1, vw2: np.dot(0.15 * pc, n),\n            \"dt\": 0.1\n        },\n        {\n            \"id\": 3,\n            \"vertices\": np.array([[0.0, 0.0], [2.0, 0.0], [2.2, 1.2], [-0.1, 1.0]]),\n            \"vertex_vels_rule\": lambda p: np.array([0.3 * p[1], 0.0]),\n            \"face_vel_rule\": lambda pc, n, A, f_idx, vw1, vw2: np.dot(np.array([0.3 * pc[1], 0.0]), n) + 0.01 * f_idx,\n            \"dt\": 0.1\n        },\n        {\n            \"id\": 4,\n            \"vertices\": np.array([[0.0, 0.0], [5.0, 0.0], [5.0, 0.05], [0.0, 0.05]]),\n            \"vertex_vels_rule\": lambda p: np.array([0.0, 0.01]) if p[0] == 0.0 else np.array([0.0, 0.02]),\n            \"face_vel_rule\": lambda pc, n, A, f_idx, vw1, vw2: (\n                np.dot(0.5 * (vw1 + vw2), n) - (0.003 if np.isclose(n[1], 1.0) else 0.0)\n            ),\n            \"dt\": 0.1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(\n            case[\"vertices\"],\n            case[\"vertex_vels_rule\"],\n            case[\"face_vel_rule\"],\n            case[\"dt\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(vertices, vertex_vels_rule, face_vel_rule, dt, epsilon=1e-12):\n    \"\"\"\n    Processes a single test case for GCL validation.\n    \"\"\"\n    p = vertices\n    num_verts = p.shape[0]\n\n    # Calculate vertex velocities based on the provided rule\n    vertex_vels = np.array([vertex_vels_rule(v) for v in p])\n    w = vertex_vels\n\n    # Compute cell area V using the shoelace formula\n    V = 0.5 * np.sum(p[:, 0] * np.roll(p[:, 1], -1) - np.roll(p[:, 0], -1) * p[:, 1])\n\n    # Compute dV/dt from vertex positions and velocities\n    y_plus_1 = np.roll(p[:, 1], -1)\n    y_minus_1 = np.roll(p[:, 1], 1)\n    x_plus_1 = np.roll(p[:, 0], -1)\n    x_minus_1 = np.roll(p[:, 0], 1)\n    \n    term_wx = w[:, 0] * (y_plus_1 - y_minus_1)\n    term_wy = w[:, 1] * (x_minus_1 - x_plus_1)\n    dVdt = 0.5 * np.sum(term_wx + term_wy)\n\n    # Loop over faces to compute uncorrected sum S and perimeter L\n    S = 0.0\n    L = 0.0\n    \n    face_data = [] # Store face data for later use\n\n    for i in range(num_verts):\n        p1 = p[i]\n        p2 = p[np.mod(i + 1, num_verts)]\n        \n        edge_vec = p2 - p1\n        A_f = np.linalg.norm(edge_vec)\n        \n        # Outward normal for CCW vertices\n        n_hat = np.array([edge_vec[1], -edge_vec[0]]) / A_f\n        \n        p_center = 0.5 * (p1 + p2)\n\n        # Get vertex velocities for endpoints of the face\n        w1 = w[i]\n        w2 = w[np.mod(i + 1, num_verts)]\n        \n        # Compute face-normal velocity w_dot_n from its rule\n        w_dot_n = face_vel_rule(p_center, n_hat, A_f, i, w1, w2)\n\n        face_data.append({'A_f': A_f, 'w_dot_n': w_dot_n})\n\n        S += A_f * w_dot_n\n        L += A_f\n    \n    # GCL residual R for the uncorrected velocities\n    R = S - dVdt\n    \n    # Compute the uniform additive correction delta\n    if L > 1e-15: # Avoid division by zero for degenerate cells\n        delta = -R / L\n    else:\n        delta = 0.0\n\n    # Compute corrected sum S_corr and residual R_corr\n    S_corr = 0.0\n    for data in face_data:\n        w_dot_n_corr = data['w_dot_n'] + delta\n        S_corr += data['A_f'] * w_dot_n_corr\n\n    R_corr = S_corr - dVdt\n\n    # Diagnostic 1: Check if the GCL is satisfied after correction\n    gcl_ok = abs(R_corr) = epsilon\n    \n    # Diagnostic 2: Check if the uniform solution is preserved\n    u_initial = 1.0\n    # Update using forward Euler based on the corrected residual\n    if V > 1e-15:\n        u_final = u_initial * (1.0 + (R_corr * dt) / V)\n    else:\n        u_final = u_initial\n        \n    uniform_ok = abs(u_final - u_initial) = epsilon\n    \n    return [gcl_ok, uniform_ok]\n\nsolve()\n```"
        },
        {
            "introduction": "A key feature of the Arbitrary Lagrangian-Eulerian (ALE) method is the \"remap\" step, where quantities are transferred from a distorted Lagrangian mesh back to a more regular one to maintain mesh quality. While essential, this process introduces numerical errors, most notably numerical diffusion that can smear out physical gradients. This exercise provides a rigorous analytical derivation of the leading-order error from a common remap scheme, offering deep insight into how numerical diffusion arises and depends on the flow properties, timestep, and grid resolution .",
            "id": "3480215",
            "problem": "Consider a passive comoving scalar field $q(x,y,t)$ representing a dust density contrast in a local patch of a cosmological flow, governed by the linear advection equation in comoving coordinates,\n$$\n\\partial_{t} q + \\boldsymbol{u} \\cdot \\nabla q = 0,\n$$\nwith a uniform shear velocity $\\boldsymbol{u}(x,y) = (\\gamma y, 0)$, where $\\gamma$ is a constant shear rate. An Arbitrary Lagrangian-Eulerian (ALE) method first follows the mesh motion with $\\boldsymbol{u}$ for a time step $\\Delta t$ and then performs a remeshing (remap) back to a uniform Cartesian mesh of spacing $\\Delta x = \\Delta y$. The remap is done with a first-order donor-cell (upwind) scheme along the $x$-direction.\n\nTake the initial condition $q(x,y,0) = \\sin(k x)\\sin(k y)$ with wavenumber $k0$, and consider a row at a fixed $y=y_{0}0$ such that the Courant number $C_{0} \\equiv \\gamma y_{0} \\Delta t / \\Delta x$ satisfies $0  C_{0}  1$. Let $x_{i}$ denote a cell center on this row, and denote by $q^{n+1}_{\\text{donor}}(x_{i},y_{0})$ the value produced by the donor-cell remap after one ALE step, and by $q_{\\text{exact}}(x_{i},y_{0},\\Delta t)$ the exact solution evaluated at the same location and time. Define the local remap error at $(x_{i},y_{0})$ after one remeshing event as\n$$\nE_{i} \\equiv q^{n+1}_{\\text{donor}}(x_{i},y_{0}) - q_{\\text{exact}}(x_{i},y_{0},\\Delta t).\n$$\n\nStarting from the advection equation and the definition of the donor-cell scheme, derive $E_{i}$ to leading nontrivial order by expanding in small $\\Delta x$ and $\\Delta t$ and keeping terms up to second order. Express your final answer as a single closed-form analytic expression in terms of $\\gamma$, $\\Delta t$, $\\Delta x$, $k$, $x_{i}$, and $y_{0}$, and show explicitly how it scales with $\\mathcal{O}(\\gamma \\Delta t \\Delta x)$ and the mesh size. No numerical values are needed; provide the closed-form expression only.",
            "solution": "We begin by recalling the exact solution of the linear advection equation $\\partial_{t} q + \\boldsymbol{u} \\cdot \\nabla q = 0$ for the given shear velocity field $\\boldsymbol{u}(x,y) = (\\gamma y, 0)$. Along characteristics,\n$$\n\\frac{d x}{d t} = \\gamma y, \\qquad \\frac{d y}{d t} = 0,\n$$\nso $y$ is constant and $x(t) = x(0) + \\gamma y t$. Therefore, the exact solution at time $\\Delta t$ is a shift in $x$ by $\\gamma y \\Delta t$:\n$$\nq_{\\text{exact}}(x,y,\\Delta t) = q(x - \\gamma y \\Delta t, y, 0).\n$$\nWith the initial condition $q(x,y,0) = \\sin(k x)\\sin(k y)$, we obtain\n$$\nq_{\\text{exact}}(x,y,\\Delta t) = \\sin\\!\\big(k (x - \\gamma y \\Delta t)\\big)\\,\\sin(k y).\n$$\n\nNext, consider the donor-cell (upwind) remap along the $x$-direction at a fixed row $y=y_{0}0$ with positive velocity $u_{x}(y_{0}) = \\gamma y_{0}$. The donor-cell update for cell center $x_{i}$ is\n$$\nq^{n+1}_{\\text{donor}}(x_{i},y_{0}) = (1 - C_{0})\\,q^{n}(x_{i},y_{0}) + C_{0}\\,q^{n}(x_{i} - \\Delta x, y_{0}),\n$$\nwhere the Courant number is $C_{0} = \\gamma y_{0} \\Delta t / \\Delta x$ and $q^{n}(\\cdot,\\cdot) = q(\\cdot,\\cdot,0)$.\n\nWith $q^{n}(x,y) = \\sin(k x)\\sin(k y)$, this becomes\n$$\nq^{n+1}_{\\text{donor}}(x_{i},y_{0}) = \\sin(k y_{0})\\Big[(1 - C_{0}) \\sin(k x_{i}) + C_{0} \\sin\\!\\big(k (x_{i} - \\Delta x)\\big)\\Big].\n$$\nThe exact value at the same point is\n$$\nq_{\\text{exact}}(x_{i},y_{0},\\Delta t) = \\sin(k y_{0})\\,\\sin\\!\\big(k (x_{i} - \\gamma y_{0} \\Delta t)\\big).\n$$\nTherefore the error $E_{i}$ is\n$$\nE_{i} = \\sin(k y_{0})\\left[(1 - C_{0}) \\sin(k x_{i}) + C_{0} \\sin\\!\\big(k (x_{i} - \\Delta x)\\big) - \\sin\\!\\big(k (x_{i} - \\gamma y_{0} \\Delta t)\\big)\\right].\n$$\n\nTo obtain the leading nontrivial order, we perform Taylor expansions in $\\Delta x$ and $\\Delta t$ up to second order. Define\n$$\ns \\equiv \\sin(k x_{i}), \\qquad c \\equiv \\cos(k x_{i}), \\qquad s_{y} \\equiv \\sin(k y_{0}).\n$$\nThen\n$$\n\\sin\\!\\big(k (x_{i} - \\Delta x)\\big) = s - k \\Delta x\\,c - \\frac{k^{2} \\Delta x^{2}}{2}\\,s + \\mathcal{O}(\\Delta x^{3}),\n$$\nand\n$$\n\\sin\\!\\big(k (x_{i} - \\gamma y_{0} \\Delta t)\\big) = s - k \\gamma y_{0} \\Delta t\\,c - \\frac{k^{2} (\\gamma y_{0} \\Delta t)^{2}}{2}\\,s + \\mathcal{O}(\\Delta t^{3}).\n$$\nSubstituting these into the expression for $q^{n+1}_{\\text{donor}}$ and $q_{\\text{exact}}$ yields\n\\begin{align*}\nq^{n+1}_{\\text{donor}}(x_{i},y_{0}) = s_{y}\\Big[(1 - C_{0}) s + C_{0}\\left(s - k \\Delta x\\,c - \\frac{k^{2} \\Delta x^{2}}{2}\\,s\\right)\\Big] + \\mathcal{O}(\\Delta x^{3}) \\\\\n= s_{y}\\left[s - C_{0} k \\Delta x\\,c - \\frac{C_{0} k^{2} \\Delta x^{2}}{2}\\,s\\right] + \\mathcal{O}(\\Delta x^{3}),\n\\end{align*}\nand\n$$\nq_{\\text{exact}}(x_{i},y_{0},\\Delta t) = s_{y}\\left[s - k \\gamma y_{0} \\Delta t\\,c - \\frac{k^{2} (\\gamma y_{0} \\Delta t)^{2}}{2}\\,s\\right] + \\mathcal{O}(\\Delta t^{3}).\n$$\nRecall that $C_{0} \\Delta x = (\\gamma y_{0} \\Delta t / \\Delta x)\\Delta x = \\gamma y_{0} \\Delta t$. Therefore, the terms proportional to $c$ in $q^{n+1}_{\\text{donor}}$ and $q_{\\text{exact}}$ match exactly and cancel in the difference, as expected for a first-order upwind discretization approximating a pure translation.\n\nThe leading nontrivial error thus comes from the second-order terms:\n\\begin{align*}\nE_{i} = q^{n+1}_{\\text{donor}}(x_{i},y_{0}) - q_{\\text{exact}}(x_{i},y_{0},\\Delta t) \\\\\n= s_{y}\\left[- \\frac{C_{0} k^{2} \\Delta x^{2}}{2}\\,s + \\frac{k^{2} (\\gamma y_{0} \\Delta t)^{2}}{2}\\,s\\right] + \\mathcal{O}\\big(\\Delta x^{3}, \\Delta t^{3}\\big) \\\\\n= \\frac{k^{2}}{2}\\,s_{y}\\,s\\left[(\\gamma y_{0} \\Delta t)^{2} - C_{0} \\Delta x^{2}\\right] + \\mathcal{O}\\big(\\Delta x^{3}, \\Delta t^{3}\\big).\n\\end{align*}\nUsing $C_{0} \\Delta x^{2} = (\\gamma y_{0} \\Delta t / \\Delta x)\\,\\Delta x^{2} = \\gamma y_{0} \\Delta t\\,\\Delta x$, we obtain the compact leading-order expression\n$$\nE_{i} = \\frac{k^{2}}{2}\\,\\sin(k x_{i})\\,\\sin(k y_{0})\\left[(\\gamma y_{0} \\Delta t)^{2} - \\gamma y_{0} \\Delta t\\,\\Delta x\\right] + \\mathcal{O}\\big(\\Delta x^{3}, \\Delta t^{3}\\big).\n$$\n\nThis explicitly shows that the dominant term in the error for small $\\Delta t$ and $\\Delta x$ scales as\n$$\n-\\frac{k^{2}}{2}\\,\\sin(k x_{i})\\,\\sin(k y_{0})\\,\\gamma y_{0}\\,\\Delta t\\,\\Delta x \\;\\;=\\;\\; \\mathcal{O}(\\gamma \\Delta t \\Delta x),\n$$\nwith the subleading correction of order $\\mathcal{O}\\big((\\gamma \\Delta t)^{2}\\big)$. The mesh size $\\Delta x$ appears linearly in the leading-order term, demonstrating the first-order spatial accuracy of the donor-cell remap and its coupling to the shear $\\gamma$ through the row coordinate $y_{0}$ in the Arbitrary Lagrangian-Eulerian (ALE) context.",
            "answer": "$$\\boxed{\\frac{k^{2}}{2}\\,\\sin(k x_{i})\\,\\sin(k y_{0})\\left[(\\gamma y_{0}\\,\\Delta t)^{2} - \\gamma y_{0}\\,\\Delta t\\,\\Delta x\\right]}$$"
        },
        {
            "introduction": "After grappling with the implementation demands of the GCL and the numerical cost of remapping, we now explore the primary motivation for adopting moving-mesh methods. By aligning the mesh motion with the bulk fluid flow, ALE methods can dramatically reduce the large advection terms that are a major source of numerical error in fixed-grid simulations. This practice quantifies this powerful advantage by analyzing the growth of a Kelvin-Helmholtz instability, demonstrating how a moving-mesh simulation more faithfully captures the physical phenomenon compared to a fixed-grid counterpart at the same resolution .",
            "id": "3480230",
            "problem": "Consider two numerical discretizations of the compressible Euler equations used in numerical cosmology to study interfacial shear instabilities: a fixed Cartesian mesh and a moving mesh aligned with the bulk shear in the spirit of Arbitrary Lagrangian-Eulerian (ALE) methods. The governing conservation laws for mass and momentum in a frame moving with mesh velocity are the compressible Euler equations, and the ALE formulation ensures that advective transport is measured relative to the mesh motion. The Kelvin–Helmholtz instability is seeded by a small-amplitude sinusoidal perturbation of wavelength $\\lambda_{\\mathrm{wave}}$ along a planar interface separating two streams with equal density and a velocity jump $\\Delta U$ around a mean bulk velocity $U_{\\mathrm{mean}}$, under subsonic conditions characterized by sound speed $c_s$. Assume the perturbation amplitude is initially small enough to justify a linear analysis.\n\nStarting from the conservation form of the Euler equations and the definition of the Arbitrary Lagrangian-Eulerian (ALE) frame, derive from first principles a relationship linking the measured exponential growth rate of the instability to an effective numerical viscosity term that arises from discretization errors. Specifically, use the following foundation:\n\n- Conservation of mass and momentum in compressible flow.\n- Linearization about a uniform shear state with equal densities and subsonic velocities.\n- The concept of a modified equation for a finite-volume Godunov-type method, in which the leading dissipative truncation term acts like a Laplacian of velocity with some coefficient that depends on the characteristic signal speed relative to the mesh and the mesh spacing.\n\nDo not introduce any untested or ad hoc formulas beyond these well-tested principles. The derivation must be consistent with linear stability theory, connecting the inviscid Kelvin–Helmholtz growth rate to a correction that depends on the effective viscosity and wavenumber.\n\nYou must then implement the resulting relationship in a program that, for each test case provided below, computes:\n\n1. The effective numerical viscosity for the moving mesh aligned with the shear and for the fixed Cartesian mesh, expressed in $\\mathrm{m}^2/\\mathrm{s}$.\n2. The fractional error in the measured growth rate relative to the inviscid baseline for both meshes, expressed as a dimensionless decimal defined as $(\\gamma_{\\mathrm{meas}} - \\gamma_0)/\\gamma_0$, where $\\gamma_0$ is the inviscid growth rate and $\\gamma_{\\mathrm{meas}}$ is the growth rate in the presence of the effective numerical viscosity.\n\nAssume equal densities and subsonic conditions so that linear Kelvin–Helmholtz growth for the inviscid baseline can be approximated using the standard equal-density, no-gravity, no-surface-tension result. The characteristic signal speed entering the dissipative truncation term should be taken relative to the mesh motion. For the fixed Cartesian mesh, treat the characteristic speed as $|U_{\\mathrm{mean}}| + c_s$. For the moving mesh aligned with the shear, treat the characteristic speed as $c_s$ because the mesh velocity equals the bulk $U_{\\mathrm{mean}}$ along the shear. Let the mesh spacing be $\\Delta x = \\lambda_{\\mathrm{wave}}/N$, where $N$ is the number of cells per wavelength. The scheme-dependent proportionality factor for the leading dissipative term is a constant $\\beta$ supplied in each test case.\n\nYour program must accept no input and must compute the results for the following test suite, using the stated physical units:\n\n- Case A (happy path): $\\lambda_{\\mathrm{wave}} = 3.086\\times 10^{19}\\ \\mathrm{m}$, $\\Delta U = 2.0\\times 10^{4}\\ \\mathrm{m/s}$, $U_{\\mathrm{mean}} = 5.0\\times 10^{4}\\ \\mathrm{m/s}$, $c_s = 1.0\\times 10^{5}\\ \\mathrm{m/s}$, $N = 64$, $\\beta = 0.25$.\n- Case B (coarse resolution, larger advection): $\\lambda_{\\mathrm{wave}} = 3.086\\times 10^{19}\\ \\mathrm{m}$, $\\Delta U = 2.0\\times 10^{4}\\ \\mathrm{m/s}$, $U_{\\mathrm{mean}} = 1.0\\times 10^{5}\\ \\mathrm{m/s}$, $c_s = 1.0\\times 10^{5}\\ \\mathrm{m/s}$, $N = 16$, $\\beta = 0.25$.\n- Case C (fine resolution, zero mean advection): $\\lambda_{\\mathrm{wave}} = 3.086\\times 10^{19}\\ \\mathrm{m}$, $\\Delta U = 1.0\\times 10^{4}\\ \\mathrm{m/s}$, $U_{\\mathrm{mean}} = 0.0\\ \\mathrm{m/s}$, $c_s = 1.0\\times 10^{5}\\ \\mathrm{m/s}$, $N = 256$, $\\beta = 0.25$.\n- Case D (shorter wavelength): $\\lambda_{\\mathrm{wave}} = 3.086\\times 10^{18}\\ \\mathrm{m}$, $\\Delta U = 5.0\\times 10^{4}\\ \\mathrm{m/s}$, $U_{\\mathrm{mean}} = 8.0\\times 10^{4}\\ \\mathrm{m/s}$, $c_s = 1.0\\times 10^{5}\\ \\mathrm{m/s}$, $N = 64$, $\\beta = 0.25$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by case, with each case contributing four values in the sequence: $[\\nu_{\\mathrm{moving}}, \\nu_{\\mathrm{fixed}}, \\varepsilon_{\\mathrm{moving}}, \\varepsilon_{\\mathrm{fixed}}]$, where $\\nu$ is the effective numerical viscosity in $\\mathrm{m}^2/\\mathrm{s}$ and $\\varepsilon$ is the fractional growth-rate error. Concatenate the case results in order A, B, C, D into one flat list. All viscosities must be expressed in $\\mathrm{m}^2/\\mathrm{s}$, and all growth-rate errors must be expressed as dimensionless decimals.",
            "solution": "The problem is scientifically grounded, well-posed, and contains all necessary information for a unique solution. The derivation and subsequent calculation are based on established principles of fluid dynamics, linear stability theory, and numerical analysis. Therefore, the problem is valid.\n\nThe task is to derive a relationship between the measured growth rate of a Kelvin-Helmholtz instability and an effective numerical viscosity, and then apply this relationship to compare a fixed Cartesian mesh with a moving mesh.\n\n**1. Inviscid Kelvin-Helmholtz Growth Rate**\n\nWe begin with the linear stability analysis of an interface at $y=0$ separating two fluids of equal density $\\rho$. The fluids move with velocities $U_1$ and $U_2$ in the $x$-direction. The mean velocity is $U_{\\mathrm{mean}} = (U_1 + U_2)/2$ and the velocity shear is $\\Delta U = U_1 - U_2$. The problem specifies to use the standard result for equal densities under subsonic conditions, which is analogous to the incompressible case. For a vortex sheet (zero thickness interface), the dispersion relation for a small sinusoidal perturbation with wavenumber $k$ yields a purely exponential growth rate $\\gamma_0$. The perturbation grows as $e^{\\gamma_0 t}$. The classical result is:\n$$\n\\gamma_0 = \\frac{k |\\Delta U|}{2}\n$$\nThe wavenumber $k$ is related to the perturbation wavelength $\\lambda_{\\mathrm{wave}}$ by:\n$$\nk = \\frac{2\\pi}{\\lambda_{\\mathrm{wave}}}\n$$\nSubstituting $k$ into the expression for $\\gamma_0$ gives the baseline inviscid growth rate:\n$$\n\\gamma_0 = \\frac{\\pi |\\Delta U|}{\\lambda_{\\mathrm{wave}}}\n$$\n\n**2. Effect of Viscosity on Growth Rate**\n\nNext, we introduce the effect of viscosity. The momentum equation in the compressible Euler equations is modified to the Navier-Stokes equations by a viscous stress tensor. For our purposes, the dominant effect of viscosity on the momentum is captured by the term $\\nu \\nabla^2 \\mathbf{u}$, where $\\nu$ is the kinematic viscosity. This term represents the diffusion of momentum.\n\nFor a sinusoidal perturbation mode of the form $e^{i k x}$, the Laplacian operator acts as $\\nabla^2 \\rightarrow -k^2$. Therefore, the viscous term introduces a damping effect to the instability. The growth rate is modified by an additive damping term, which is proportional to the strength of the viscous diffusion. The damping rate is $\\gamma_{\\mathrm{damp}} = \\nu k^2$.\n\nThe measured growth rate, $\\gamma_{\\mathrm{meas}}$, in the presence of this small viscosity is the sum of the inviscid growth and the viscous damping:\n$$\n\\gamma_{\\mathrm{meas}} = \\gamma_0 - \\gamma_{\\mathrm{damp}} = \\gamma_0 - \\nu k^2\n$$\nThis relationship shows that viscosity acts to suppress the growth of the instability, with a stronger effect at higher wavenumbers (shorter wavelengths).\n\n**3. Numerical Viscosity from Truncation Error**\n\nNumerical schemes for solving hyperbolic conservation laws, such as the Euler equations, introduce errors. For first-order Godunov-type schemes, the leading-order term in the truncation error of the discretized momentum equation often has the form of a viscous dissipation term. This is a key concept of the \"modified equation\" approach, where the numerical solution is an exact solution to a slightly modified PDE. This leading dissipative term gives rise to an \"effective numerical viscosity,\" $\\nu_{\\mathrm{num}}$.\n\nThe problem states that this numerical viscosity can be modeled as:\n$$\n\\nu_{\\mathrm{num}} = \\beta \\cdot v_{\\mathrm{char}} \\cdot \\Delta x\n$$\nwhere $\\beta$ is a dimensionless, scheme-dependent constant of order unity, $v_{\\mathrm{char}}$ is the characteristic signal speed relative to the computational mesh, and $\\Delta x$ is the grid spacing.\n\nThe problem provides specific models for $v_{\\mathrm{char}}$ and $\\Delta x$:\n- The grid spacing is related to the number of cells per wavelength, $N$: $\\Delta x = \\lambda_{\\mathrm{wave}}/N$.\n- For a **fixed Cartesian mesh**, the fluid advects past the grid with the mean velocity $U_{\\mathrm{mean}}$. The fastest signal speed relative to a fixed grid cell is the sum of the bulk flow speed and the sound speed propagating relative to the fluid. Thus, $v_{\\mathrm{char, fixed}} = |U_{\\mathrm{mean}}| + c_s$.\n- For a **moving mesh** (ALE) that is aligned with the bulk shear, the mesh moves at velocity $U_{\\mathrm{mean}}$. The advective transport relative to the mesh is zero. The characteristic speed is then just the sound speed, $v_{\\mathrm{char, moving}} = c_s$.\n\nUsing these definitions, we can write the expressions for the effective numerical viscosity for both cases:\n$$\n\\nu_{\\mathrm{fixed}} = \\beta (|U_{\\mathrm{mean}}| + c_s) \\frac{\\lambda_{\\mathrm{wave}}}{N}\n$$\n$$\n\\nu_{\\mathrm{moving}} = \\beta c_s \\frac{\\lambda_{\\mathrm{wave}}}{N}\n$$\n\n**4. Fractional Error in Growth Rate**\n\nThe final step is to calculate the fractional error in the growth rate, $\\varepsilon$, defined as $(\\gamma_{\\mathrm{meas}} - \\gamma_0)/\\gamma_0$. We substitute our expressions for $\\gamma_{\\mathrm{meas}}$ and the numerical viscosity $\\nu_{\\mathrm{num}}$ (denoted simply as $\\nu$ from now on).\n$$\n\\varepsilon = \\frac{\\gamma_{\\mathrm{meas}} - \\gamma_0}{\\gamma_0} = \\frac{(\\gamma_0 - \\nu k^2) - \\gamma_0}{\\gamma_0} = -\\frac{\\nu k^2}{\\gamma_0}\n$$\nNow, we substitute the expressions for $k = 2\\pi/\\lambda_{\\mathrm{wave}}$ and $\\gamma_0 = \\pi |\\Delta U|/\\lambda_{\\mathrm{wave}}$:\n$$\n\\varepsilon = -\\frac{\\nu (2\\pi/\\lambda_{\\mathrm{wave}})^2}{\\pi |\\Delta U|/\\lambda_{\\mathrm{wave}}} = -\\frac{\\nu \\cdot 4\\pi^2/\\lambda_{\\mathrm{wave}}^2}{\\pi |\\Delta U|/\\lambda_{\\mathrm{wave}}} = -\\frac{4\\pi\\nu}{|\\Delta U| \\lambda_{\\mathrm{wave}}}\n$$\nThis provides a direct link between the fractional error and the numerical viscosity. We can also substitute the formula for $\\nu$ into this expression to see the direct dependency on the simulation parameters:\n$$\n\\varepsilon = -\\frac{4\\pi (\\beta v_{\\mathrm{char}} \\frac{\\lambda_{\\mathrm{wave}}}{N})}{|\\Delta U| \\lambda_{\\mathrm{wave}}} = -\\frac{4\\pi \\beta v_{\\mathrm{char}}}{N |\\Delta U|}\n$$\nThis simplified form is computationally robust and clearly shows that the numerical error is amplified by the characteristic speed ($v_{\\mathrm{char}}$) and reduced by higher resolution ($N$) and stronger physical shear ($|\\Delta U|$). The moving mesh method (ALE) reduces the error by minimizing $v_{\\mathrm{char}}$ from $|U_{\\mathrm{mean}}| + c_s$ down to just $c_s$.\n\nThe required quantities for each case are:\n1.  $\\nu_{\\mathrm{moving}}$ and $\\nu_{\\mathrm{fixed}}$ in $\\mathrm{m}^2/\\mathrm{s}$.\n2.  $\\varepsilon_{\\mathrm{moving}}$ and $\\varepsilon_{\\mathrm{fixed}}$ as dimensionless decimals.\n\nThe following formulas will be implemented:\n- $\\nu_{\\mathrm{moving}} = \\beta c_s (\\lambda_{\\mathrm{wave}} / N)$\n- $\\nu_{\\mathrm{fixed}} = \\beta (|U_{\\mathrm{mean}}| + c_s) (\\lambda_{\\mathrm{wave}} / N)$\n- $\\varepsilon_{\\mathrm{moving}} = - (4\\pi \\beta c_s) / (N |\\Delta U|)$\n- $\\varepsilon_{\\mathrm{fixed}} = - (4\\pi \\beta (|U_{\\mathrm{mean}}| + c_s)) / (N |\\Delta U|)$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating numerical viscosity and growth rate error\n    for the Kelvin-Helmholtz instability on fixed and moving meshes.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (lambda_wave [m], delta_U [m/s], U_mean [m/s], c_s [m/s], N, beta)\n    test_cases = [\n        # Case A\n        (3.086e19, 2.0e4, 5.0e4, 1.0e5, 64, 0.25),\n        # Case B\n        (3.086e19, 2.0e4, 1.0e5, 1.0e5, 16, 0.25),\n        # Case C\n        (3.086e19, 1.0e4, 0.0, 1.0e5, 256, 0.25),\n        # Case D\n        (3.086e18, 5.0e4, 8.0e4, 1.0e5, 64, 0.25),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        lambda_wave, delta_u, u_mean, c_s, n, beta = case\n\n        # Calculate metrics for the MOVING MESH\n        # v_char for moving mesh is c_s\n        v_char_moving = c_s\n        nu_moving = beta * v_char_moving * (lambda_wave / n)\n        \n        # The fractional error can be calculated using the simplified formula:\n        # eps = -(4 * pi * beta * v_char) / (N * |delta_U|)\n        eps_moving = -(4 * np.pi * beta * v_char_moving) / (n * abs(delta_u))\n\n        # Calculate metrics for the FIXED MESH\n        # v_char for fixed mesh is |U_mean| + c_s\n        v_char_fixed = abs(u_mean) + c_s\n        nu_fixed = beta * v_char_fixed * (lambda_wave / n)\n\n        eps_fixed = -(4 * np.pi * beta * v_char_fixed) / (n * abs(delta_u))\n\n        # Append the four results for the current case\n        all_results.extend([nu_moving, nu_fixed, eps_moving, eps_fixed])\n\n    # Format the final output string as a comma-separated list in brackets.\n    # Convert each result to a string. The default float formatting is sufficient.\n    result_str = \",\".join(map(str, all_results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}