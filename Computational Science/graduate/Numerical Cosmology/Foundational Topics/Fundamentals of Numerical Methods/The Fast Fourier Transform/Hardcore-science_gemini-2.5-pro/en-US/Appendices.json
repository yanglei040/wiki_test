{
    "hands_on_practices": [
        {
            "introduction": "In numerical cosmology, the density contrast field $\\delta(\\mathbf{x})$ is real-valued. This fundamental property imposes a special structure on its Fourier transform known as Hermitian symmetry, $\\tilde{\\delta}(\\mathbf{k}) = \\tilde{\\delta}^*(-\\mathbf{k})$, which makes nearly half of the complex Fourier coefficients redundant. This hands-on exercise () walks you through the essential task of implementing a memory-efficient storage layout that exploits this symmetry, a crucial skill for handling the massive datasets generated in modern cosmological simulations.",
            "id": "3495399",
            "problem": "You are implementing a three-dimensional discrete Fourier transform for a real scalar field in a periodic cosmological volume. Let the real field be sampled on a uniform Cartesian grid of size $N_x \\times N_y \\times N_z$, with periodic boundary conditions in each dimension. Consider the discrete Fourier transform that maps the real-space samples $f[n_x, n_y, n_z]$ to complex Fourier coefficients $F[k_x, k_y, k_z]$. The fundamental base for this task is as follows: (i) the standard definition of the discrete Fourier transform on a finite periodic grid, (ii) the property that the Fourier transform of a real-valued field satisfies Hermitian symmetry, namely $F(-\\boldsymbol{k}) = F(\\boldsymbol{k})^\\ast$, and (iii) the standard index wrapping induced by periodicity, where discrete wave indices are defined modulo $N_d$ along dimension $d \\in \\{x,y,z\\}$.\n\nYour task is to specify a storage layout and an index mapping for a real-to-complex three-dimensional fast Fourier transform (Fast Fourier Transform (FFT)) that excludes redundant negative frequencies while preserving Hermitian symmetry, using the following precise requirements derived from the above fundamentals:\n\n- Storage layout: Use a compact half-spectrum along the $z$-axis that stores only the nonnegative $z$-frequencies. The stored complex array must have shape $(N_x, N_y, \\lfloor N_z/2 \\rfloor + 1)$, where the indices $(i,j,k)$ correspond to wrapped discrete wave indices $(\\tilde{k}_x, \\tilde{k}_y, \\tilde{k}_z)$ defined by\n  $$\\tilde{k}_x(i) = \\begin{cases}\n  i, & 0 \\le i \\le \\lfloor N_x/2 \\rfloor \\\\\n  i - N_x, & \\lfloor N_x/2 \\rfloor < i \\le N_x - 1\n  \\end{cases},\\quad\n  \\tilde{k}_y(j) = \\begin{cases}\n  j, & 0 \\le j \\le \\lfloor N_y/2 \\rfloor \\\\\n  j - N_y, & \\lfloor N_y/2 \\rfloor < j \\le N_y - 1\n  \\end{cases},\\quad\n  \\tilde{k}_z(k) = k,$$\n  with $i \\in \\{0,\\dots,N_x-1\\}$, $j \\in \\{0,\\dots,N_y-1\\}$, and $k \\in \\{0,\\dots,\\lfloor N_z/2 \\rfloor\\}$. The excluded coefficients correspond to negative $z$-frequencies $k_z \\in \\{-\\lfloor N_z/2 \\rfloor,\\dots,-1\\}$, which are redundant by Hermitian symmetry.\n\n- Index mapping: You must implement the bidirectional mapping between storage indices $(i,j,k)$ and wrapped wave indices $(\\tilde{k}_x,\\tilde{k}_y,\\tilde{k}_z)$ as above, together with the conjugate-partner relation implied by Hermitian symmetry. Specifically, given a stored index $(i,j,k)$ representing the mode $(\\tilde{k}_x,\\tilde{k}_y,\\tilde{k}_z)$, its Hermitian-conjugate partner corresponds to the mode $(-\\tilde{k}_x,-\\tilde{k}_y,-\\tilde{k}_z)$, which would map to the storage index\n  $$(i',j',k') = \\left(({-\\tilde{k}_x}) \\bmod N_x,\\ ({-\\tilde{k}_y}) \\bmod N_y,\\ ({-\\tilde{k}_z}) \\bmod N_z\\right).$$\n  This conjugate partner is stored in the compact layout if and only if $k' \\in \\{0,\\dots,\\lfloor N_z/2 \\rfloor\\}$. Modes with $k \\in \\{0\\}$ and, when $N_z$ is even, $k \\in \\{N_z/2\\}$ have their conjugate partner within the stored set; for other $k$, the conjugate partner is not stored. A mode is self-conjugate if its stored index equals that of its conjugate partner; this occurs exactly when each component equals its own negative modulo its size, namely when $i \\in \\{0\\}$ and, if $N_x$ is even, possibly $i \\in \\{N_x/2\\}$; similarly for $j$; and for $k \\in \\{0\\}$ and, if $N_z$ is even, possibly $k \\in \\{N_z/2\\}$.\n\n- Memory layout: Use contiguous row-major ordering with $k$ as the fastest-varying index, then $j$, then $i$. The flat memory index of a stored coefficient $(i,j,k)$ must be\n  $$\\mathrm{flat}(i,j,k) = i \\cdot \\left(N_y \\cdot \\left(\\left\\lfloor \\frac{N_z}{2} \\right\\rfloor + 1\\right)\\right) + j \\cdot \\left(\\left\\lfloor \\frac{N_z}{2} \\right\\rfloor + 1\\right) + k.$$\n\nImplement a program that defines the above storage layout and mapping, and then computes, for a given set of test cases, the following five quantities per test case:\n\n- The total number of stored modes, which must equal $N_x \\cdot N_y \\cdot \\left(\\left\\lfloor N_z/2 \\right\\rfloor + 1\\right)$.\n- The number of self-conjugate stored modes determined by the Hermitian condition and the stored set.\n- The flat memory index of a specified sample wrapped wave index $(\\hat{k}_x,\\hat{k}_y,\\hat{k}_z)$ if it is representable in the stored set; if not representable, return the integer $-1$.\n- The count of stored modes whose Hermitian-conjugate partner also lies within the stored set.\n- A boolean indicating whether, for every stored index $(i,j,k)$, mapping to $(\\tilde{k}_x,\\tilde{k}_y,\\tilde{k}_z)$ and back returns the original $(i,j,k)$.\n\nYour program must use the following test suite:\n\n- Test case $1$: $N_x=4$, $N_y=3$, $N_z=6$, with sample wrapped wave index $(\\hat{k}_x,\\hat{k}_y,\\hat{k}_z)=(-1,1,2)$.\n- Test case $2$: $N_x=5$, $N_y=5$, $N_z=5$, with sample wrapped wave index $(\\hat{k}_x,\\hat{k}_y,\\hat{k}_z)=(2,-2,1)$.\n- Test case $3$: $N_x=2$, $N_y=2$, $N_z=2$, with sample wrapped wave index $(\\hat{k}_x,\\hat{k}_y,\\hat{k}_z)=(1,1,1)$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The results must be emitted in the order of the test cases, and for each test case, emit the five quantities in the exact order described above. For example, the overall output must have the form\n$[\\dots]$\nwith a total of $5 \\times 3$ entries. No units are involved, and all angles, if any appear, must be understood to be in radians. All numeric answers must be emitted as plain integers or booleans in the printed list.",
            "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded, well-posed, objective, and contains all necessary information to derive a unique solution. The problem requires the implementation of a specific storage and indexing scheme for a three-dimensional real-to-complex Fast Fourier Transform (FFT) used in numerical cosmology, followed by the computation of five specific quantities for a given set of parameters.\n\nThe solution proceeds by systematically deriving the method to calculate each of the five required quantities. The grid dimensions are denoted by $N_x$, $N_y$, and $N_z$. The compact storage array utilizes a reduced dimension along the $z$-axis, $N_z' = \\lfloor N_z/2 \\rfloor + 1$. Its shape is $(N_x, N_y, N_z')$.\n\n**1. Total Number of Stored Modes**\n\nThe total number of stored complex Fourier coefficients is simply the number of elements in the compact storage array. This is the product of its dimensions:\n$$ \\text{Total Modes} = N_x \\cdot N_y \\cdot \\left(\\left\\lfloor \\frac{N_z}{2} \\right\\rfloor + 1\\right) $$\nThis quantity represents the memory footprint of the Fourier-space field, optimized by exploiting Hermitian symmetry.\n\n**2. Number of Self-Conjugate Stored Modes**\n\nA mode with wave vector $\\boldsymbol{\\tilde{k}} = (\\tilde{k}_x, \\tilde{k}_y, \\tilde{k}_z)$ is self-conjugate if it is its own Hermitian conjugate partner, i.e., if $\\boldsymbol{\\tilde{k}} = -\\boldsymbol{\\tilde{k}}$ under the periodic wrapping. This is equivalent to the storage index $(i,j,k)$ being identical to the storage index of the partner mode $(i',j',k')$. This condition, $(i,j,k) = (i',j',k')$, must hold for each dimension independently.\n\nFor a dimension $d \\in \\{x,y,z\\}$ of size $N_d$, the wrapped wave number $\\tilde{k}_d$ must satisfy $\\tilde{k}_d = -\\tilde{k}_d \\pmod{N_d}$, which simplifies to $2\\tilde{k}_d \\equiv 0 \\pmod{N_d}$. The solutions for the storage index along dimension $d$ are:\n- Index $0$, which corresponds to $\\tilde{k}_d=0$.\n- If $N_d$ is even, index $N_d/2$, which corresponds to the Nyquist frequency $\\tilde{k}_d=N_d/2$.\n\nThe number of self-conjugate indices for each dimension $d$ is $S_d = 2$ if $N_d$ is even, and $S_d = 1$ if $N_d$ is odd. This can be written as $S_d = 1 + (1 - N_d \\pmod{2})$.\n\nFor the $z$-axis, the stored indices $k$ are restricted to $\\{0, \\dots, \\lfloor N_z/2 \\rfloor\\}$. The self-conjugate solutions $k=0$ and (if $N_z$ is even) $k=N_z/2$ both fall within this stored range.\nThe total number of self-conjugate modes is the product of the counts for each dimension:\n$$ \\text{Self-Conjugate Modes} = S_x \\cdot S_y \\cdot S_z = \\left(1 + (1 - N_x \\pmod{2})\\right) \\cdot \\left(1 + (1 - N_y \\pmod{2})\\right) \\cdot \\left(1 + (1 - N_z \\pmod{2})\\right) $$\n\n**3. Flat Memory Index of a Sample Mode**\n\nGiven a sample wrapped wave index $(\\hat{k}_x, \\hat{k}_y, \\hat{k}_z)$, we must first determine if it is represented in the compact storage array. The storage scheme explicitly includes only non-negative $z$-frequencies. Therefore, a mode is stored if and only if its $z$-wave number $\\hat{k}_z$ is in the range $[0, \\lfloor N_z/2 \\rfloor]$. If $\\hat{k}_z$ is outside this range, the mode is not stored, and the value to be returned is $-1$.\n\nIf the mode is potentially stored, we must map the wave numbers $(\\hat{k}_x, \\hat{k}_y, \\hat{k}_z)$ back to storage indices $(i,j,k)$.\nThe mapping from wave number $\\tilde{k}_d$ to storage index $i_d$ is given by the modulo operation: $i_d = \\tilde{k}_d \\pmod{N_d}$.\nThus, the storage indices are calculated as:\n$$ i = \\hat{k}_x \\pmod{N_x} $$\n$$ j = \\hat{k}_y \\pmod{N_y} $$\n$$ k = \\hat{k}_z $$\nWith the indices $(i,j,k)$ determined, the flat memory index is computed using the provided row-major formula, where $k$ is the fastest-varying index:\n$$ \\mathrm{flat}(i,j,k) = i \\cdot \\left(N_y \\cdot \\left(\\left\\lfloor \\frac{N_z}{2} \\right\\rfloor + 1\\right)\\right) + j \\cdot \\left(\\left\\lfloor \\frac{N_z}{2} \\right\\rfloor + 1\\right) + k $$\n\n**4. Count of Stored Modes with a Stored Conjugate Partner**\n\nFor a stored mode with index $(i,j,k)$, we determine the index of its Hermitian conjugate partner, $(i',j',k')$.\nThe partner mode has wave vector $(-\\tilde{k}_x, -\\tilde{k}_y, -\\tilde{k}_z)$. The corresponding storage index is\n$k' = (-\\tilde{k}_z) \\pmod{N_z} = (-k) \\pmod{N_z}$, since $\\tilde{k}_z = k$.\nThe partner is stored in the compact array if its $z$-index $k'$ falls within the stored range: $0 \\le k' \\le \\lfloor N_z/2 \\rfloor$.\n\nWe analyze this condition on $k \\in \\{0, \\dots, \\lfloor N_z/2 \\rfloor\\}$:\n- If $k=0$: $k' = (-0) \\pmod{N_z} = 0$. Since $0$ is always in the stored range, all modes with $k=0$ have their partner stored. There are $N_x \\cdot N_y$ such modes.\n- If $k>0$: $k' = N_z - k$. The condition becomes $N_z - k \\le \\lfloor N_z/2 \\rfloor$, which implies $k \\ge N_z - \\lfloor N_z/2 \\rfloor$.\n    - If $N_z$ is even, let $N_z=2m$. The stored range for $k$ is $[0, m]$. The condition is $k \\ge 2m - m = m$. The only solution for $k>0$ in the stored range is $k=m=N_z/2$. Thus, all modes with $k=N_z/2$ also have stored partners. There are $N_x \\cdot N_y$ such modes.\n    - If $N_z$ is odd, let $N_z=2m+1$. The stored range for $k$ is $[0, m]$. The condition is $k \\ge (2m+1) - m = m+1$. There is no $k$ in the stored range that satisfies this.\n\nIn summary, the partner is stored only for modes on the $k=0$ plane, and additionally on the $k=N_z/2$ plane if $N_z$ is even. The total count is:\n$$ \\text{Count} = \\begin{cases} N_x \\cdot N_y & \\text{if } N_z \\text{ is odd} \\\\ 2 \\cdot N_x \\cdot N_y & \\text{if } N_z \\text{ is even} \\end{cases} $$\nThis can be written as $(1 + (1 - N_z \\pmod 2)) \\cdot N_x \\cdot N_y$.\n\n**5. Bidirectional Index Mapping Verification**\n\nThis task requires verifying that the mapping from a storage index $(i,j,k)$ to its wave vector $(\\tilde{k}_x, \\tilde{k}_y, \\tilde{k}_z)$ and back to a storage index $(i',j',k')$ is an identity transformation, i.e., $(i,j,k) = (i',j',k')$.\nThe forward map is given by the problem's definition of $\\tilde{k}_d(i_d)$. The backward map is $i_d' = \\tilde{k}_d \\pmod{N_d}$.\nFor any dimension $d$ and index $i \\in \\{0, \\dots, N_d-1\\}$:\n- If $0 \\le i \\le \\lfloor N_d/2 \\rfloor$, then $\\tilde{k}_d(i) = i$, and $i \\pmod{N_d} = i$.\n- If $\\lfloor N_d/2 \\rfloor < i \\le N_d-1$, then $\\tilde{k}_d(i) = i - N_d$, and $(i - N_d) \\pmod{N_d} = i$.\nIn both cases, the index maps back to itself. This holds for dimensions $x$ and $y$. For the $z$ dimension, the mapping is trivial since $\\tilde{k}_z=k$. Therefore, the bidirectional mapping is always an identity map for any valid indices and grid sizes. The result of this check will be `True` for all test cases. The implementation will perform this check algorithmically to be rigorous.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the formatted output.\n    \"\"\"\n    test_cases = [\n        (4, 3, 6, (-1, 1, 2)),\n        (5, 5, 5, (2, -2, 1)),\n        (2, 2, 2, (1, 1, 1)),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        Nx, Ny, Nz, sample_k_vec = case\n        results = calculate_metrics(Nx, Ny, Nz, sample_k_vec)\n        all_results.extend(results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef calculate_metrics(Nx, Ny, Nz, sample_k_vec):\n    \"\"\"\n    Computes the five required quantities for a given test case.\n    \n    Args:\n        Nx (int): Grid size in x-dimension.\n        Ny (int): Grid size in y-dimension.\n        Nz (int): Grid size in z-dimension.\n        sample_k_vec (tuple): A sample wrapped wave index (kx, ky, kz).\n\n    Returns:\n        tuple: A tuple containing the five computed quantities in order.\n    \"\"\"\n    Nz_prime = Nz // 2 + 1\n\n    # 1. Total number of stored modes\n    total_modes = Nx * Ny * Nz_prime\n\n    # 2. Number of self-conjugate stored modes\n    # A mode is self-conjugate if its wave number k_d satisfies k_d = -k_d mod N_d.\n    # This is true for k_d=0 and, if N_d is even, k_d=N_d/2.\n    sx = 2 if Nx % 2 == 0 else 1\n    sy = 2 if Ny % 2 == 0 else 1\n    sz = 2 if Nz % 2 == 0 else 1\n    self_conjugate_modes = sx * sy * sz\n\n    # 3. Flat memory index of a specified sample wrapped wave index\n    k_hat_x, k_hat_y, k_hat_z = sample_k_vec\n    flat_index = -1\n    # Check if the z-frequency is in the stored half-spectrum\n    if 0 <= k_hat_z < Nz_prime:\n        i = k_hat_x % Nx\n        j = k_hat_y % Ny\n        k = k_hat_z\n        \n        # This check confirms that the given sample_k_vec corresponds to the\n        # canonical wave vectors generated from our storage indices.\n        if (k_tilde(i, Nx) == k_hat_x and k_tilde(j, Ny) == k_hat_y and k == k_hat_z):\n            flat_index = i * (Ny * Nz_prime) + j * Nz_prime + k\n\n    # 4. Count of stored modes whose Hermitian-conjugate partner also lies within the stored set\n    # Partner is stored if its k' index is in [0, Nz_prime-1].\n    # This only happens for modes with k=0 and, if Nz is even, k=Nz/2.\n    num_planes_with_stored_partners = 2 if Nz % 2 == 0 else 1\n    modes_with_stored_partner = num_planes_with_stored_partners * Nx * Ny\n\n    # 5. Boolean indicating if the index mapping is bijective\n    is_bijective = True\n    # This loop programmatically verifies the identity, though it's true by construction.\n    for i_loop in range(Nx):\n        for j_loop in range(Ny):\n            # The z-axis mapping is a trivial identity and does not need a loop.\n            kx_tilde_val = k_tilde(i_loop, Nx)\n            ky_tilde_val = k_tilde(j_loop, Ny)\n            \n            i_back = kx_tilde_val % Nx\n            j_back = ky_tilde_val % Ny\n            \n            if i_loop != i_back or j_loop != j_back:\n                is_bijective = False\n                break\n        if not is_bijective:\n            break\n            \n    return total_modes, self_conjugate_modes, int(flat_index), modes_with_stored_partner, is_bijective\n\ndef k_tilde(idx, N):\n    \"\"\"\n    Maps a storage index `idx` to its corresponding wrapped wave number for a dimension of size `N`.\n    \"\"\"\n    if idx <= N // 2:\n        return idx\n    else:\n        return idx - N\n\nsolve()\n```"
        },
        {
            "introduction": "When a continuous field is represented on a discrete grid, a fundamental numerical artifact known as aliasing can arise, where power from high-frequency modes masquerades as power at lower frequencies. This exercise () provides a practical laboratory for exploring this effect, which is particularly important in cosmology where non-linear gravitational evolution constantly generates small-scale power that can contaminate large-scale measurements. You will deliberately create aliased signals and test the effectiveness of common mitigation techniques.",
            "id": "3495462",
            "problem": "You are tasked with constructing and analyzing synthetic three-dimensional density fields in a periodic cubic domain using the Fast Fourier Transform (FFT). The goal is to demonstrate and quantify aliasing when deliberately exciting Fourier modes above the Nyquist wavenumber and to measure how interlacing and the two-thirds de-aliasing rule affect the recovered power spectrum and bispectrum.\n\nBegin from the following foundational base:\n- Sampling and aliasing: A periodic cubic domain of side length $L$ sampled on a uniform cubic grid of size $N \\times N \\times N$ has grid spacing $\\Delta x = L/N$ and Nyquist wavenumber $k_{\\mathrm{Ny}} = \\pi / \\Delta x$. When a continuous field contains Fourier components with wavenumber magnitude $|\\mathbf{k}| > k_{\\mathrm{Ny}}$, uniform sampling produces aliasing, and those components fold back into the discrete spectrum as lower-wavenumber components.\n- Discrete Fourier Transform: The Discrete Fourier Transform converts a sampled field $\\delta(\\mathbf{x})$ into complex coefficients $\\tilde{\\delta}(\\mathbf{k})$ at discrete wavevectors $\\mathbf{k} = (2\\pi/L) \\mathbf{n}$ where $\\mathbf{n}$ is a triplet of signed integers. In practice, uniform scaling by the voxel volume $(\\Delta x)^3$ provides coefficients with consistent physical scaling across resolutions.\n- Statistical spectra definitions: The power spectrum $P(\\mathbf{k})$ is defined as the quadratic average of $|\\tilde{\\delta}(\\mathbf{k})|^2$, and the bispectrum $B(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)$ quantifies third-order mode coupling for triads satisfying $\\mathbf{k}_1+\\mathbf{k}_2+\\mathbf{k}_3=\\mathbf{0}$.\n\nYour program must construct, process, and analyze fields according to the following instructions:\n1. Geometry and sampling:\n   - Use a periodic cube of side length $L$ and a uniform grid of size $N \\times N \\times N$. All quantities are dimensionless (no physical units).\n   - Define a continuous base field $f(\\mathbf{x})$ as a sum of two plane waves with integer index vectors $(n_x,n_y,n_z)$ such that at least one component in each wave satisfies $|n_i| > N/2$ to ensure $|\\mathbf{k}| > k_{\\mathrm{Ny}}$.\n   - Define the synthetic density field as $\\delta(\\mathbf{x}) = f(\\mathbf{x}) + \\beta f(\\mathbf{x})^2$, where $\\beta$ is a given dimensionless nonlinearity parameter.\n2. Processing methods:\n   - Plain sampling: Sample $\\delta(\\mathbf{x})$ on the grid with no additional processing and compute its FFT to obtain $\\tilde{\\delta}(\\mathbf{k})$.\n   - Interlacing: Compute two samples of $\\delta(\\mathbf{x})$ on grids offset by half a cell in each axis, i.e., at $\\mathbf{x}$ and at $\\mathbf{x} + (\\Delta x/2,\\Delta x/2,\\Delta x/2)$, average these two sampled fields in real space, and then compute the FFT of the averaged field.\n   - Two-thirds de-aliasing rule: After computing the FFT of the plainly sampled field, set to zero any mode whose integer index component satisfies $|n_i| > N/3$ in any axis, leaving all others unchanged.\n3. Spectral measurements:\n   - Let $\\mathbf{k} = (2\\pi/L)\\mathbf{n}$ denote the discrete wavevector corresponding to an integer index triplet $\\mathbf{n} = (n_x,n_y,n_z)$.\n   - For each specified test case, evaluate and report the following quantities:\n     - Recovered discrete power values $P(\\mathbf{k}_{\\mathrm{v}}) = |\\tilde{\\delta}(\\mathbf{k}_{\\mathrm{v}})|^2$ at a specified single target mode vector $\\mathbf{k}_{\\mathrm{v}}$ that corresponds to an aliased low-wavenumber image of an excited high-wavenumber mode.\n     - Recovered bispectrum magnitude $|B(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)| = |\\tilde{\\delta}(\\mathbf{k}_1)\\tilde{\\delta}(\\mathbf{k}_2)\\tilde{\\delta}(\\mathbf{k}_3)|$ for a specified single closed triad $(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)$ with $\\mathbf{k}_1+\\mathbf{k}_2+\\mathbf{k}_3=\\mathbf{0}$, chosen to probe alias-driven mode coupling.\n   - Use the same consistent FFT normalization across all methods by multiplying the computed complex FFT by $(\\Delta x)^3 = (L/N)^3$ before forming any products.\n4. Test suite:\n   - Case $1$: $N=32$, $L=1$, two excited modes with integer index vectors $(20,0,0)$ and $(0,22,0)$, equal amplitudes in $f(\\mathbf{x})$, nonlinearity $\\beta=0.3$. Measure:\n     - Power at $\\mathbf{n}_{\\mathrm{v}}=(12,0,0)$.\n     - Bispectrum triad $(\\mathbf{n}_1,\\mathbf{n}_2,\\mathbf{n}_3) = (12,0,0)$, $(0,10,0)$, $(-12,-10,0)$.\n   - Case $2$: $N=24$, $L=1$, modes $(14,0,0)$ and $(0,14,0)$, $\\beta=0.5$. Measure:\n     - Power at $\\mathbf{n}_{\\mathrm{v}}=(10,0,0)$.\n     - Bispectrum triad $(10,0,0)$, $(0,10,0)$, $(-10,-10,0)$.\n   - Case $3$: $N=16$, $L=1$, modes $(13,0,0)$ and $(0,9,0)$, $\\beta=0.4$. Measure:\n     - Power at $\\mathbf{n}_{\\mathrm{v}}=(3,0,0)$.\n     - Bispectrum triad $(3,0,0)$, $(0,7,0)$, $(-3,-7,0)$.\n5. Output specification:\n   - For each case, compute and return six values in the following order: $P(\\mathbf{k}_{\\mathrm{v}})$ with plain sampling, $P(\\mathbf{k}_{\\mathrm{v}})$ with interlacing, $P(\\mathbf{k}_{\\mathrm{v}})$ with the two-thirds de-aliasing rule, $|B(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)|$ with plain sampling, $|B(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)|$ with interlacing, and $|B(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)|$ with the two-thirds de-aliasing rule.\n   - All reported quantities must be dimensionless floats.\n   - Your program should produce a single line of output containing the results as a comma-separated list of three lists (one per test case) enclosed in square brackets, for example, $[\\,[r_1,r_2,r_3,r_4,r_5,r_6],\\,[\\dots],\\,[\\dots]\\,]$.\n\nEnsure scientific realism and internal consistency in your implementation. The program must be self-contained and must not require any user input. The implementation must adhere to the specified environment and library constraints. The final numerical answers must be deterministically computed from the provided test suite.",
            "solution": "The user has provided a problem that is scientifically grounded, well-posed, objective, and internally consistent. It describes a standard numerical experiment in cosmology and physics concerning aliasing effects in Fourier analysis. All parameters and procedures are specified, allowing for a deterministic and verifiable solution. Therefore, the problem is deemed valid.\n\nThe core of this problem is to investigate numerical aliasing in the context of non-linear field evolution on a discrete grid, a ubiquitous issue in computational sciences, particularly in numerical cosmology for simulating the large-scale structure of the universe. We are given a continuous, one-dimensional density field $\\delta(\\mathbf{x})$ in a three-dimensional periodic box of side length $L$, which is then sampled on a uniform cubic grid of size $N \\times N \\times N$.\n\nThe foundational elements are defined as follows:\n- The grid spacing is $\\Delta x = L/N$.\n- The grid point coordinates are $\\mathbf{x}_{\\mathbf{j}} = (j_x, j_y, j_z)\\Delta x$, where $j_x, j_y, j_z \\in \\{0, 1, \\dots, N-1\\}$.\n- In Fourier space, the corresponding discrete wavevectors are $\\mathbf{k}_{\\mathbf{n}} = (2\\pi/L)(n_x, n_y, n_z)$, where $n_x, n_y, n_z$ are integers.\n- The Nyquist wavenumber, which defines the highest frequency representable on the grid without aliasing, is $k_{\\mathrm{Ny}} = \\pi/\\Delta x$. In terms of integer indices $\\mathbf{n}$, this corresponds to the condition $|n_i| \\le N/2$ for each component $i \\in \\{x,y,z\\}$.\n\nThe synthetic field is constructed from a base field $f(\\mathbf{x})$ composed of two plane waves. To ensure the field is real-valued, we use cosine functions. Assuming unit amplitudes as is standard when not otherwise specified, the base field is:\n$$f(\\mathbf{x}) = \\cos(\\mathbf{k}_a \\cdot \\mathbf{x}) + \\cos(\\mathbf{k}_b \\cdot \\mathbf{x})$$\nHere, $\\mathbf{k}_a = (2\\pi/L)\\mathbf{n}_a$ and $\\mathbf{k}_b = (2\\pi/L)\\mathbf{n}_b$ are the wavevectors of the two initial modes, with integer vectors $\\mathbf{n}_a$ and $\\mathbf{n}_b$ chosen such that at least one component $|n_i| > N/2$. This deliberately introduces frequencies above the Nyquist limit.\n\nA non-linear component is introduced via a quadratic term, resulting in the full density field:\n$$\\delta(\\mathbf{x}) = f(\\mathbf{x}) + \\beta f(\\mathbf{x})^2$$\nwhere $\\beta$ is a non-linearity parameter. The quadratic term $f(\\mathbf{x})^2$ generates new Fourier modes corresponding to harmonics and combinations of the initial wavevectors, such as $2\\mathbf{k}_a$, $2\\mathbf{k}_b$, $\\mathbf{k}_a+\\mathbf{k}_b$, and $\\mathbf{k}_a-\\mathbf{k}_b$.\n\nWhen this continuous field $\\delta(\\mathbf{x})$ is sampled on the discrete grid, any Fourier mode $\\mathbf{k}_{\\mathbf{n}}$ with $|n_i| > N/2$ for any component $i$ is aliased. It is incorrectly represented as a lower-wavenumber mode $\\mathbf{k}_{\\mathbf{n}'}$ within the principal range $|n'_i| \\le N/2$. The aliased index $n'_i$ is related to the true index $n_i$ by $n'_i = n_i - N \\cdot \\text{round}(n_i/N)$. For the modes in this problem, where $N/2 < |n_i| \\le N$, this simplifies to $n'_i = n_i - N \\cdot \\text{sign}(n_i)$.\n\nThe discrete Fourier transform (DFT) of the sampled field $\\delta(\\mathbf{x}_{\\mathbf{j}})$ is computed and normalized to approximate the continuous Fourier transform:\n$$\\tilde{\\delta}(\\mathbf{k}_{\\mathbf{n}}) = (\\Delta x)^3 \\sum_{\\mathbf{j}} \\delta(\\mathbf{x}_{\\mathbf{j}}) e^{-i \\mathbf{k}_{\\mathbf{n}} \\cdot \\mathbf{x}_{\\mathbf{j}}}$$\nThe factor $(\\Delta x)^3 = (L/N)^3$ ensures the resulting Fourier coefficients $\\tilde{\\delta}(\\mathbf{k})$ have consistent physical dimensions (volume, in this dimensionless setup) regardless of the grid resolution $N$.\n\nWe evaluate three processing methods to handle or observe the aliasing:\n1.  **Plain Sampling**: The field $\\delta(\\mathbf{x})$ is sampled at the grid points $\\mathbf{x}_{\\mathbf{j}}$ and its DFT is computed directly. This method is expected to show the most severe aliasing effects.\n2.  **Interlacing**: This is a simple anti-aliasing technique. Two fields are generated: one sampled on the primary grid, $\\delta(\\mathbf{x}_{\\mathbf{j}})$, and another on a grid shifted by half a cell, $\\delta(\\mathbf{x}_{\\mathbf{j}} + \\frac{1}{2}\\boldsymbol{\\Delta x})$. These two sampled fields are averaged in real space before the DFT is taken. The averaging acts as a low-pass filter, which should suppress high-frequency modes and thus reduce aliasing.\n3.  **Two-Thirds De-aliasing Rule**: This method applies a sharp filter in Fourier space. After computing the DFT of the plainly sampled field, all Fourier coefficients $\\tilde{\\delta}(\\mathbf{k}_{\\mathbf{n}})$ are set to zero if any component of their integer index vector $\\mathbf{n}=(n_x,n_y,n_z)$ exceeds a threshold, i.e., if $|n_x| > N/3$ or $|n_y| > N/3$ or $|n_z| > N/3$. This procedure is intended to remove aliased power originating from quadratic interactions but as applied here, it acts as a post-facto filter on an already aliased spectrum.\n\nFinally, we measure two key statistical quantities to quantify the impact of aliasing:\n- The recovered power spectrum at a specific aliased wavevector $\\mathbf{k}_{\\mathrm{v}}$: $P(\\mathbf{k}_{\\mathrm{v}}) = |\\tilde{\\delta}(\\mathbf{k}_{\\mathrm{v}})|^2$. This measures the spurious power that appears at a low wavenumber due to the aliasing of a high-wavenumber mode.\n- The recovered bispectrum magnitude for a specific closed triad $(\\mathbf{k}_1, \\mathbf{k}_2, \\mathbf{k}_3)$ where $\\mathbf{k}_1+\\mathbf{k}_2+\\mathbf{k}_3 = \\mathbf{0}$: $|B(\\mathbf{k}_1, \\mathbf{k}_2, \\mathbf{k}_3)| = |\\tilde{\\delta}(\\mathbf{k}_1)\\tilde{\\delta}(\\mathbf{k}_2)\\tilde{\\delta}(\\mathbf{k}_3)|$. This probes spurious three-point correlations generated by the aliasing of fundamental and coupled modes.\n\nThe implementation proceeds by constructing these fields and calculating the spectra for each specified test case, mapping the integer mode indices $\\mathbf{n}$ to the appropriate array indices for the DFT output, and then reporting the six requested quantities per case. For a real-valued field $\\delta(\\mathbf{x})$, the DFT satisfies the Hermitian symmetry $\\tilde{\\delta}(\\mathbf{k}_{\\mathbf{n}}) = \\tilde{\\delta}^{*}(-\\mathbf{k}_{\\mathbf{n}})$, which implies $P(\\mathbf{k}_{\\mathbf{n}}) = P(-\\mathbf{k}_{\\mathbf{n}})$. This is relevant as the aliased modes might appear at negative indices while the measurement is requested at positive ones.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes synthetic 3D density fields to demonstrate and quantify\n    aliasing effects using the Fast Fourier Transform (FFT).\n    \"\"\"\n\n    test_cases = [\n        # Case 1: N=32, L=1, modes (20,0,0), (0,22,0), beta=0.3\n        # Power at (12,0,0), Bispectrum at ((12,0,0), (0,10,0), (-12,-10,0))\n        {\n            \"N\": 32, \"L\": 1.0, \"n_a\": (20, 0, 0), \"n_b\": (0, 22, 0), \"beta\": 0.3,\n            \"n_v\": (12, 0, 0),\n            \"n_b_triad\": ((12, 0, 0), (0, 10, 0), (-12, -10, 0))\n        },\n        # Case 2: N=24, L=1, modes (14,0,0), (0,14,0), beta=0.5\n        # Power at (10,0,0), Bispectrum at ((10,0,0), (0,10,0), (-10,-10,0))\n        {\n            \"N\": 24, \"L\": 1.0, \"n_a\": (14, 0, 0), \"n_b\": (0, 14, 0), \"beta\": 0.5,\n            \"n_v\": (10, 0, 0),\n            \"n_b_triad\": ((10, 0, 0), (0, 10, 0), (-10, -10, 0))\n        },\n        # Case 3: N=16, L=1, modes (13,0,0), (0,9,0), beta=0.4\n        # Power at (3,0,0), Bispectrum at ((3,0,0), (0,7,0), (-3,-7,0))\n        {\n            \"N\": 16, \"L\": 1.0, \"n_a\": (13, 0, 0), \"n_b\": (0, 9, 0), \"beta\": 0.4,\n            \"n_v\": (3, 0, 0),\n            \"n_b_triad\": ((3, 0, 0), (0, 7, 0), (-3, -7, 0))\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        L = case[\"L\"]\n        n_a = np.array(case[\"n_a\"])\n        n_b = np.array(case[\"n_b\"])\n        beta = case[\"beta\"]\n        n_v = case[\"n_v\"]\n        n_b_triad = [np.array(n) for n in case[\"n_b_triad\"]]\n\n        delta_x = L / N\n        voxel_volume = delta_x**3\n\n        # 1. Geometry and Field Definition\n        j = np.arange(N)\n        # Primary grid\n        x = j * delta_x\n        xx, yy, zz = np.meshgrid(x, x, x, indexing='ij')\n\n        # Shifted grid for interlacing\n        x_shifted = (j + 0.5) * delta_x\n        xx_s, yy_s, zz_s = np.meshgrid(x_shifted, x_shifted, x_shifted, indexing='ij')\n\n        k_a = (2 * np.pi / L) * n_a\n        k_b = (2 * np.pi / L) * n_b\n\n        def calculate_field(c_xx, c_yy, c_zz):\n            f_x = (np.cos(k_a[0]*c_xx + k_a[1]*c_yy + k_a[2]*c_zz) +\n                   np.cos(k_b[0]*c_xx + k_b[1]*c_yy + k_b[2]*c_zz))\n            return f_x + beta * f_x**2\n\n        # 2. Processing Methods\n        # Plain sampling\n        delta_plain = calculate_field(xx, yy, zz)\n        fft_plain = np.fft.fftn(delta_plain) * voxel_volume\n        \n        # Interlacing\n        delta_shifted = calculate_field(xx_s, yy_s, zz_s)\n        delta_interlaced = 0.5 * (delta_plain + delta_shifted)\n        fft_interlaced = np.fft.fftn(delta_interlaced) * voxel_volume\n\n        # Two-thirds de-aliasing rule\n        fft_2_3 = fft_plain.copy()\n        freq_indices = np.fft.fftfreq(N, d=1.0) * N\n        nx, ny, nz = np.meshgrid(freq_indices, freq_indices, freq_indices, indexing='ij')\n        \n        k_max_2_3 = N / 3.0\n        mask = (np.abs(nx) > k_max_2_3) | (np.abs(ny) > k_max_2_3) | (np.abs(nz) > k_max_2_3)\n        fft_2_3[mask] = 0.0\n\n        # Helper to get value at a specific mode vector n\n        def get_val(fft_grid, n_vec):\n            indices = tuple(int(i % N) for i in n_vec)\n            return fft_grid[indices]\n\n        # 3. Spectral Measurements\n        case_results = []\n        fft_methods = [fft_plain, fft_interlaced, fft_2_3]\n        \n        # Power spectrum values\n        for fft in fft_methods:\n            power = np.abs(get_val(fft, n_v))**2\n            case_results.append(power)\n        \n        # Bispectrum values\n        n1, n2, n3 = n_b_triad\n        for fft in fft_methods:\n            bispectrum = np.abs(get_val(fft, n1) * get_val(fft, n2) * get_val(fft, n3))\n            case_results.append(bispectrum)\n        \n        all_results.append(case_results)\n\n    # 5. Output Specification\n    # Convert lists to strings in the required format\n    inner_lists = [f\"[{','.join(f'{v:.10e}' for v in res)}]\" for res in all_results]\n    print(f\"[{','.join(inner_lists)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Analyzing real galaxy surveys requires accounting for complex survey geometries (masks) and optimizing the signal from galaxies with varying number densities. The Feldman-Kaiser-Peacock (FKP) weighting scheme is a standard method for this optimization. This practice () leverages the convolution theorem to demonstrate how to efficiently compute the Fourier-space \"window function\" of a survey using the FFT, showing how the mask and weights combine to affect the final cosmological measurements.",
            "id": "3495391",
            "problem": "You are given a dimensionless, periodic, cubic domain discretized on a regular grid. The objective is to develop a Fast Fourier Transform (FFT) based approach to compute the convolution in Fourier space of a survey mask with a Feldman-Kaiser-Peacock (FKP) weight and to quantitatively test how this optimal weighting modifies the effective window in wave number space. All quantities in this problem are dimensionless, and no physical units are involved. Angles do not appear and need not be specified.\n\nStarting from the fundamental base of the discrete Fourier transform and the convolution theorem, derive an algorithm that, for a given real-space survey mask and space-dependent mean number density, constructs the effective window in wave number space when FKP weighting is applied. The only facts you may assume are the well-tested definitions of the discrete Fourier transform on a periodic domain and the convolution theorem for discrete circular convolution.\n\nLet the domain be a periodic cube of side length $L$ sampled on an $N \\times N \\times N$ grid, with $L$ and $N$ dimensionless. Let the survey mask $M(\\mathbf{x})$ be a binary field, $M(\\mathbf{x}) \\in \\{0,1\\}$, and let the mean number density $\\bar{n}(\\mathbf{x})$ be nonnegative and spatially varying. The Feldman-Kaiser-Peacock (FKP) weight is defined up to a constant of proportionality, and for algorithmic specificity you must set\n$$\nw(\\mathbf{x}) = \\frac{1}{1 + \\bar{n}(\\mathbf{x}) P_0},\n$$\nwhere $P_0$ is a fixed, nonnegative, dimensionless constant.\n\nYour tasks are:\n- Using only the definition of the discrete Fourier transform and discrete circular convolution, derive the relationship connecting the Fourier transform of a real-space product to a convolution in Fourier space, and justify using an FFT to compute the effective window in wave number space.\n- Implement an algorithm that constructs the effective window in wave number space for both the unweighted survey mask and the FKP-weighted survey mask. Define the “effective window” as the discrete Fourier transform of the corresponding real-space field.\n- Quantify the modification induced by optimal weighting by spherically averaging the window power over wave number shells. For each case, compute two scalar diagnostics:\n  1. A “low-$k$” ratio $R_{\\mathrm{low}}$, equal to the sum over the low-$k$ shell of the weighted window power divided by the corresponding sum for the unweighted window power.\n  2. A “high-$k$” ratio $R_{\\mathrm{high}}$, defined analogously over a high-$k$ shell.\n\nDomain and numerical specifications:\n- Use $N = 32$ and $L = 1$.\n- Construct the survey mask $M(\\mathbf{x})$ as a sphere of radius $r_0 = 0.25 L$ centered at $\\mathbf{c} = (0.3 L, 0.4 L, 0.6 L)$; set $M(\\mathbf{x}) = 1$ inside the sphere and $M(\\mathbf{x}) = 0$ outside.\n- For wave numbers, use the standard discrete wave number grid consistent with a discrete Fourier transform on a periodic domain of side length $L$. Let the Nyquist wave number be $k_{\\mathrm{Ny}}$, and define the low-$k$ shell as $0 \\le k \\le 0.2\\,k_{\\mathrm{Ny}}$ and the high-$k$ shell as $0.6\\,k_{\\mathrm{Ny}} \\le k \\le 0.8\\,k_{\\mathrm{Ny}}$.\n\nTest suite:\nCompute the pair $(R_{\\mathrm{low}}, R_{\\mathrm{high}})$ for each of the following parameter sets, which together test a general case, spatial variation, and boundary conditions:\n- Case $1$: $\\bar{n}(\\mathbf{x}) = n_0$ with $n_0 = 1$, and $P_0 = 100$.\n- Case $2$: $\\bar{n}(\\mathbf{x}) = n_0 \\left[1 + \\alpha \\left(\\frac{x}{L} - \\frac{1}{2}\\right)\\right]$ with $n_0 = 1$ and $\\alpha = 0.8$, clipped below by $0.1$ to ensure nonnegativity; $P_0 = 100$.\n- Case $3$: $\\bar{n}(\\mathbf{x}) = n_0$ with $n_0 = 1$, and $P_0 = 0$.\n- Case $4$: $\\bar{n}(\\mathbf{x}) = n_0 \\left[1 + \\alpha \\left(\\frac{x}{L} - \\frac{1}{2}\\right)\\right]$ with $n_0 = 1$ and $\\alpha = 0.8$, clipped below by $0.1$; $P_0 = 10^5$.\n\nAnswer specification:\n- For each case, compute $R_{\\mathrm{low}}$ and $R_{\\mathrm{high}}$ as defined above. These are dimensionless floats.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[R_{\\mathrm{low}}^{(1)}, R_{\\mathrm{high}}^{(1)}, R_{\\mathrm{low}}^{(2)}, R_{\\mathrm{high}}^{(2)}, R_{\\mathrm{low}}^{(3)}, R_{\\mathrm{high}}^{(3)}, R_{\\mathrm{low}}^{(4)}, R_{\\mathrm{high}}^{(4)}]$, where the superscripts indicate the case index.",
            "solution": "The problem requires the development and implementation of an algorithm to quantify the effect of Feldman-Kaiser-Peacock (FKP) weighting on a survey window function in Fourier space. This involves deriving the relevant mathematical relationship from first principles and then computing specific diagnostics for a set of test cases.\n\n### Step 1: Theoretical Foundation - The Discrete Convolution Theorem\n\nThe foundation of this analysis is the relationship between multiplication in real space and convolution in Fourier space. We begin by defining the three-dimensional discrete Fourier transform (DFT) and its inverse for a function $f(\\mathbf{x})$ sampled on a periodic cubic grid of $N \\times N \\times N$ points with side length $L$. The grid points are denoted by $\\mathbf{x}_j$ and the corresponding discrete wave vectors by $\\mathbf{k}_m$.\n\nThe forward DFT, which transforms a real-space function $f(\\mathbf{x})$ to its Fourier-space representation $\\tilde{f}(\\mathbf{k})$, is defined as:\n$$\n\\tilde{f}(\\mathbf{k}_m) = \\sum_{j=0}^{N^3-1} f(\\mathbf{x}_j) e^{-i \\mathbf{k}_m \\cdot \\mathbf{x}_j}\n$$\nThe inverse DFT, which transforms back from Fourier to real space, is:\n$$\nf(\\mathbf{x}_j) = \\frac{1}{N^3} \\sum_{m=0}^{N^3-1} \\tilde{f}(\\mathbf{k}_m) e^{i \\mathbf{k}_m \\cdot \\mathbf{x}_j}\n$$\nThis normalization convention is consistent with typical numerical implementations, such as in the `numpy` library, where the factor of $1/N^3$ is applied during the inverse transform.\n\nThe problem concerns the Fourier transform of a product of two functions. Let us consider two real-space fields, $f(\\mathbf{x})$ and $g(\\mathbf{x})$, and their product $h(\\mathbf{x}) = f(\\mathbf{x}) g(\\mathbf{x})$. The Fourier transform of $h(\\mathbf{x})$ is, by definition:\n$$\n\\tilde{h}(\\mathbf{k}) = \\sum_{\\mathbf{x}} h(\\mathbf{x}) e^{-i \\mathbf{k} \\cdot \\mathbf{x}} = \\sum_{\\mathbf{x}} f(\\mathbf{x}) g(\\mathbf{x}) e^{-i \\mathbf{k} \\cdot \\mathbf{x}}\n$$\nwhere the summation runs over all $N^3$ grid points $\\mathbf{x}_j$. To proceed, we substitute the inverse DFT expression for $f(\\mathbf{x})$:\n$$\n\\tilde{h}(\\mathbf{k}) = \\sum_{\\mathbf{x}} \\left( \\frac{1}{N^3} \\sum_{\\mathbf{k'}} \\tilde{f}(\\mathbf{k'}) e^{i \\mathbf{k'} \\cdot \\mathbf{x}} \\right) g(\\mathbf{x}) e^{-i \\mathbf{k} \\cdot \\mathbf{x}}\n$$\nBy rearranging the order of summation, we can group terms:\n$$\n\\tilde{h}(\\mathbf{k}) = \\frac{1}{N^3} \\sum_{\\mathbf{k'}} \\tilde{f}(\\mathbf{k'}) \\left( \\sum_{\\mathbf{x}} g(\\mathbf{x}) e^{-i (\\mathbf{k} - \\mathbf{k'}) \\cdot \\mathbf{x}} \\right)\n$$\nThe term in the parenthesis is precisely the definition of the DFT of $g(\\mathbf{x})$ evaluated at the wave vector $\\mathbf{k} - \\mathbf{k'}$, i.e., $\\tilde{g}(\\mathbf{k} - \\mathbf{k'})$. This substitution yields the discrete convolution theorem:\n$$\n\\tilde{h}(\\mathbf{k}) \\equiv \\mathcal{F}[f \\cdot g](\\mathbf{k}) = \\frac{1}{N^3} \\sum_{\\mathbf{k'}} \\tilde{f}(\\mathbf{k'}) \\tilde{g}(\\mathbf{k} - \\mathbf{k'}) = \\frac{1}{N^3} (\\tilde{f} * \\tilde{g})(\\mathbf{k})\n$$\nThis theorem states that the Fourier transform of a product of two functions is proportional to the discrete circular convolution of their individual Fourier transforms.\n\n### Step 2: Algorithmic Strategy and Justification\n\nThe problem defines the \"effective window\" as the Fourier transform of the corresponding real-space field.\nFor the unweighted case, the field is the survey mask $M(\\mathbf{x})$, so the effective window is $\\tilde{M}(\\mathbf{k}) = \\mathcal{F}[M(\\mathbf{x})]$.\nFor the FKP-weighted case, the real-space field is the product of the mask $M(\\mathbf{x})$ and the FKP weight $w(\\mathbf{x})$, which we denote as $W_{FKP}(\\mathbf{x}) = M(\\mathbf{x})w(\\mathbf{x})$. The effective window is its Fourier transform, $\\tilde{W}_{FKP}(\\mathbf{k}) = \\mathcal{F}[W_{FKP}(\\mathbf{x})]$.\n\nAccording to the convolution theorem, $\\tilde{W}_{FKP}(\\mathbf{k})$ is proportional to the convolution $(\\tilde{M} * \\tilde{w})(\\mathbf{k})$. A direct computation of this convolution sum in Fourier space would involve a nested loop over all modes, an operation with computational complexity $O((N^3)^2) = O(N^6)$, which is computationally prohibitive for typical grid sizes.\n\nA vastly more efficient strategy is to perform the operation in the domain where it is simpler. The product $W_{FKP}(\\mathbf{x}) = M(\\mathbf{x})w(\\mathbf{x})$ is a simple element-wise multiplication in real space, with complexity $O(N^3)$. Following this, we can compute the Fourier transform $\\mathcal{F}[W_{FKP}(\\mathbf{x})]$ using the Fast Fourier Transform (FFT) algorithm. The FFT computes the DFT with a much lower complexity of $O(N^3 \\log N)$. This two-step process—multiplication in real space followed by an FFT—is the standard and most efficient method for computing the Fourier transform of a product, and its use is the central justification for an FFT-based approach.\n\n### Step 3: Implementation Details\n\nThe algorithm proceeds as follows:\n\n1.  **Grid Generation**: A cubic grid of size $N \\times N \\times N$ with $N=32$ is defined over a periodic domain of side length $L=1$. The real-space coordinates for each grid point $(i, j, k)$ are $\\mathbf{x} = (i L/N, j L/N, k L/N)$ for $i,j,k \\in \\{0, ..., N-1\\}$. The corresponding wave-vector grid is constructed using the standard definition for discrete transforms. For each dimension, the wave numbers are given by $k_u = 2\\pi m_u / L$, where $m_u$ are integers spanning $[ -N/2, N/2 - 1 ]$. These are conveniently generated using `numpy.fft.fftfreq`.\n\n2.  **Real-Space Field Construction**:\n    *   **Survey Mask $M(\\mathbf{x})$**: A 3D array is created. Each element is set to $1$ if its coordinate $\\mathbf{x}$ satisfies $|\\mathbf{x} - \\mathbf{c}| \\le r_0$, where $\\mathbf{c} = (0.3L, 0.4L, 0.6L)$ and $r_0=0.25L$. Otherwise, the element is set to $0$.\n    *   **Mean Density $\\bar{n}(\\mathbf{x})$ and FKP Weight $w(\\mathbf{x})$**: For each test case, the fields for the mean number density $\\bar{n}(\\mathbf{x})$ and the FKP weight $w(\\mathbf{x}) = (1 + \\bar{n}(\\mathbf{x}) P_0)^{-1}$ are constructed on the grid according to the specified formulas.\n    *   **Window Functions**: The unweighted window is simply $M(\\mathbf{x})$, and the FKP-weighted window is the product $W_{FKP}(\\mathbf{x}) = M(\\mathbf{x}) w(\\mathbf{x})$.\n\n3.  **Fourier Transform and Power**: The FFT algorithm (`numpy.fft.fftn`) is applied to obtain the Fourier-space representations $\\tilde{M}(\\mathbf{k})$ and $\\tilde{W}_{FKP}(\\mathbf{k})$. The corresponding window power fields are computed as the squared magnitude of these complex fields: $P_M(\\mathbf{k}) = |\\tilde{M}(\\mathbf{k})|^2$ and $P_W(\\mathbf{k}) = |\\tilde{W}_{FKP}(\\mathbf{k})|^2$.\n\n4.  **Diagnostic Computation**:\n    *   **Wave Number Shells**: The magnitude of each wave vector, $k = |\\mathbf{k}| = \\sqrt{k_x^2 + k_y^2 + k_z^2}$, is computed for all points on the Fourier grid. The Nyquist wave number is $k_{\\mathrm{Ny}} = \\pi N / L$. The shells are defined by:\n        *   Low-$k$: $0 \\le k \\le 0.2\\,k_{\\mathrm{Ny}}$\n        *   High-$k$: $0.6\\,k_{\\mathrm{Ny}} \\le k \\le 0.8\\,k_{\\mathrm{Ny}}$\n    *   **Power Summation**: The total power for the unweighted and weighted windows is summed over all grid points $\\mathbf{k}$ that fall within each shell.\n        *   $S_{\\mathrm{low}, M} = \\sum_{k \\in \\text{low-k}} P_M(\\mathbf{k})$ and $S_{\\mathrm{low}, W} = \\sum_{k \\in \\text{low-k}} P_W(\\mathbf{k})$\n        *   $S_{\\mathrm{high}, M} = \\sum_{k \\in \\text{high-k}} P_M(\\mathbf{k})$ and $S_{\\mathrm{high}, W} = \\sum_{k \\in \\text{high-k}} P_W(\\mathbf{k})$\n    *   **Ratios**: The final diagnostic ratios are computed as:\n        *   $R_{\\mathrm{low}} = S_{\\mathrm{low}, W} / S_{\\mathrm{low}, M}$\n        *   $R_{\\mathrm{high}} = S_{\\mathrm{high}, W} / S_{\\mathrm{high}, M}$\n\nThis procedure is repeated for each of the four specified test cases to produce the final results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the modification of a survey window function by FKP weighting.\n\n    The algorithm proceeds as follows:\n    1.  Sets up the 3D real-space and Fourier-space grids.\n    2.  Constructs the unweighted survey mask M(x), a sphere.\n    3.  Computes the Fourier power spectrum of M(x), denoted P_M(k).\n    4.  Defines the k-space shells (low-k and high-k) and sums P_M(k) within them.\n    5.  Iterates through four test cases, each with different FKP parameters.\n        a.  Constructs the FKP weight w(x) for the current case.\n        b.  Creates the weighted window W_fkp(x) = M(x) * w(x).\n        c.  Computes the Fourier power spectrum of W_fkp(x), denoted P_W(k).\n        d.  Sums P_W(k) within the k-space shells.\n        e.  Calculates the ratios R_low and R_high as specified.\n    6.  Formats and prints the collected results.\n    \"\"\"\n    # Domain and numerical specifications\n    N = 32\n    L = 1.0\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1: Constant n_bar, P0 = 100\n        {'n0': 1.0, 'alpha': 0.0, 'P0': 100.0},\n        # Case 2: Spatially varying n_bar, P0 = 100\n        {'n0': 1.0, 'alpha': 0.8, 'P0': 100.0},\n        # Case 3: Constant n_bar, P0 = 0 (no weighting)\n        {'n0': 1.0, 'alpha': 0.0, 'P0': 0.0},\n        # Case 4: Spatially varying n_bar, large P0\n        {'n0': 1.0, 'alpha': 0.8, 'P0': 100000.0},\n    ]\n\n    # Step 1: Grid Setup\n    grid_coords_1d = np.arange(N, dtype=float) * (L / N)\n    x, y, z = np.meshgrid(grid_coords_1d, grid_coords_1d, grid_coords_1d, indexing='ij')\n\n    # Step 2: Construct Survey Mask M(x)\n    r0 = 0.25 * L\n    center = np.array([0.3 * L, 0.4 * L, 0.6 * L])\n    dist_sq = (x - center[0])**2 + (y - center[1])**2 + (z - center[2])**2\n    M = (dist_sq <= r0**2).astype(float)\n    \n    # Step 3: Compute unweighted window power\n    M_k = np.fft.fftn(M)\n    P_M_k = np.abs(M_k)**2\n\n    # Step 4: Define k-space grid and shells for analysis\n    k_vals_1d = 2.0 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_vals_1d, k_vals_1d, k_vals_1d, indexing='ij')\n    k_mag = np.sqrt(kx**2 + ky**2 + kz**2)\n    \n    k_nyquist = np.pi * N / L\n    \n    low_k_mask = (k_mag >= 0.0) & (k_mag <= 0.2 * k_nyquist)\n    high_k_mask = (k_mag >= 0.6 * k_nyquist) & (k_mag <= 0.8 * k_nyquist)\n\n    # Sum of unweighted power in shells\n    S_low_M = np.sum(P_M_k[low_k_mask])\n    S_high_M = np.sum(P_M_k[high_k_mask])\n    \n    results = []\n    \n    # Step 5: Iterate through test cases\n    for case in test_cases:\n        n0 = case['n0']\n        alpha = case['alpha']\n        P0 = case['P0']\n        \n        # Step 5a: Construct FKP weight w(x)\n        if alpha == 0.0:\n            n_bar = np.full((N, N, N), n0, dtype=float)\n        else:\n            # The calculation depends on the x-coordinate grid\n            n_bar_val = n0 * (1.0 + alpha * (x / L - 0.5))\n            n_bar = np.maximum(0.1, n_bar_val)\n        \n        w = 1.0 / (1.0 + n_bar * P0)\n        \n        # Step 5b: Create weighted mask W_fkp(x)\n        W_fkp = M * w\n        \n        # Step 5c: Compute FKP-weighted window power\n        W_fkp_k = np.fft.fftn(W_fkp)\n        P_W_k = np.abs(W_fkp_k)**2\n        \n        # Step 5d: Sum of weighted power in shells\n        S_low_W = np.sum(P_W_k[low_k_mask])\n        S_high_W = np.sum(P_W_k[high_k_mask])\n        \n        # Step 5e: Calculate ratios. Denominators are non-zero for a spherical mask.\n        R_low = S_low_W / S_low_M\n        R_high = S_high_W / S_high_M\n        \n        results.extend([R_low, R_high])\n\n    # Step 6: Format and print results\n    print(f\"[{','.join(f'{r:.6g}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}