{
    "hands_on_practices": [
        {
            "introduction": "In numerical cosmology, preserving the geometric structure of phase space over billions of years of simulated time is paramount. This exercise provides a direct, hands-on comparison between a structure-preserving symplectic integrator and a general-purpose, non-symplectic method. By tracking the conservation of energy and an adiabatic invariant in a toy galactic model , you will empirically verify the superior long-term fidelity of symplectic schemes, a cornerstone of modern N-body simulations.",
            "id": "3493173",
            "problem": "Consider the long-time numerical integration of a two-dimensional toy model for a barred dark matter halo in a rotating frame. The system is modeled by a Hamiltonian that is autonomous in the rotating frame, with canonical coordinates $q = (x,y)$ and momenta $p = (p_x,p_y)$, given by\n$$\nH(q,p) \\equiv \\frac{1}{2}\\left(p_x^2 + p_y^2\\right) + \\frac{1}{2}\\left(\\omega_x^2 x^2 + \\omega_y^2 y^2\\right) - \\Omega \\left( x p_y - y p_x \\right),\n$$\nwhere $\\omega_x$ and $\\omega_y$ are the characteristic frequencies of an anisotropic harmonic background (representing a triaxial or barred deformation) and $\\Omega$ is the constant pattern speed of the bar. The equations of motion are the Hamilton equations $\\dot{q} = \\partial H/\\partial p$ and $\\dot{p} = -\\partial H/\\partial q$. The quantity $H$ is the Jacobi integral in the rotating frame and is exactly conserved by the continuous dynamics.\n\nA central goal in numerical cosmology is to preserve long-time structure (phase-space volume and invariants) when integrating Hamiltonian systems. Symplectic integrators are designed to preserve the symplectic structure and, by backward error analysis, exactly conserve a modified Hamiltonian, while generic non-symplectic integrators do not. In near-integrable regimes, one also monitors adiabatic invariants such as action-like quantities. For the model above, define the action-like diagnostics\n$$\nJ_x(t) \\equiv \\frac{\\frac{1}{2}p_x(t)^2 + \\frac{1}{2}\\omega_x^2 x(t)^2}{\\omega_x}, \\quad\nJ_y(t) \\equiv \\frac{\\frac{1}{2}p_y(t)^2 + \\frac{1}{2}\\omega_y^2 y(t)^2}{\\omega_y},\n$$\nwhich are exact invariants of the uncoupled isotropic case when $\\Omega = 0$ and $\\omega_x = \\omega_y$. In the general rotating, anisotropic setting, $J_x$ and $J_y$ are not exact invariants, but serve as adiabatic diagnostics of numerical fidelity.\n\nTask. Write a complete, runnable program that:\n- Implements two integrators for the above Hamiltonian: \n  1) a second-order symmetric Strang splitting symplectic method obtained by splitting $H = T + U + G$ with \n  $T(p) = \\frac{1}{2}(p_x^2 + p_y^2)$, $U(q) = \\frac{1}{2}(\\omega_x^2 x^2 + \\omega_y^2 y^2)$, and $G(q,p) = -\\Omega (x p_y - y p_x)$; and \n  2) a standard explicit fourth-order Runge–Kutta method applied to the full Hamilton equations.\n- Uses the following fixed initial condition shared by all test cases: $x(0) = 1.0$, $y(0) = 0.2$, $p_x(0) = 0.0$, $p_y(0) = 0.9$ (dimensionless).\n- For each numerical trajectory, computes two scalar error diagnostics over the full integration time interval $[0,T]$:\n  1) the maximum relative deviation of the Jacobi integral,\n  $$\n  \\epsilon_H \\equiv \\max_{0 \\le t \\le T} \\frac{\\left| H(t) - H(0) \\right|}{\\left| H(0) \\right| + 10^{-12}},\n  $$\n  and \n  2) the relative root-mean-square deviation of the sum of actions $J_x + J_y$,\n  $$\n  \\epsilon_J \\equiv \\left[ \\frac{1}{N+1}\\sum_{n=0}^{N} \\left( \\frac{J_x(t_n) + J_y(t_n) - \\left[J_x(0) + J_y(0)\\right]}{\\left|J_x(0) + J_y(0)\\right| + 10^{-12}} \\right)^2 \\right]^{1/2},\n  $$\n  where $t_n = n \\,\\Delta t$ and $N = \\lfloor T/\\Delta t \\rfloor$.\n- Integration is performed with a fixed time step $\\Delta t$ without adaptive control and all quantities are dimensionless.\n\nIntegrator specification. The Strang splitting symplectic method must be built from the exact flows of $T$, $U$, and $G$:\n- $T$-flow over $\\tau$: $q \\mapsto q + p\\,\\tau$, $p \\mapsto p$.\n- $U$-flow over $\\tau$: $q \\mapsto q$, $p \\mapsto p - \\nabla U(q)\\,\\tau$, with $\\nabla U(q) = (\\omega_x^2 x, \\omega_y^2 y)$.\n- $G$-flow over $\\tau$: this flow corresponds to a rotation. The coordinate vector $q$ is rotated by an angle $-\\Omega\\tau$ and the momentum vector $p$ is rotated by an angle $+\\Omega\\tau$. With the rotation matrix defined as $R(\\theta) = \\begin{pmatrix}\\cos\\theta & \\sin\\theta \\\\ -\\sin\\theta & \\cos\\theta \\end{pmatrix}$, the transformations are $q \\mapsto R(\\Omega \\tau)\\,q$ and $p \\mapsto R(-\\Omega \\tau)\\,p$.\nOne time step $\\Delta t$ of the symmetric second-order method must be the composition $U(\\Delta t/2) \\circ G(\\Delta t/2) \\circ T(\\Delta t) \\circ G(\\Delta t/2) \\circ U(\\Delta t/2)$.\n\nRunge–Kutta specification. The fourth-order Runge–Kutta method must be applied to the full Hamilton equations with\n$$\n\\dot{x} = p_x + \\Omega y, \\quad \\dot{y} = p_y - \\Omega x, \\quad\n\\dot{p}_x = -\\omega_x^2 x + \\Omega p_y, \\quad \\dot{p}_y = -\\omega_y^2 y - \\Omega p_x.\n$$\n\nTest suite. Your program must run the following six test cases, each defined by the tuple $(\\text{method}, \\omega_x, \\omega_y, \\Omega, T, \\Delta t)$:\n- Case $1$: $(\\text{S2},\\, 1.0,\\, 1.2,\\, 0.3,\\, 1000.0,\\, 0.05)$.\n- Case $2$: $(\\text{RK4},\\, 1.0,\\, 1.2,\\, 0.3,\\, 1000.0,\\, 0.05)$.\n- Case $3$: $(\\text{S2},\\, 1.0,\\, 1.2,\\, 0.3,\\, 1000.0,\\, 0.20)$.\n- Case $4$: $(\\text{RK4},\\, 1.0,\\, 1.2,\\, 0.3,\\, 1000.0,\\, 0.20)$.\n- Case $5$: $(\\text{S2},\\, 1.0,\\, 1.0,\\, 0.0,\\, 1000.0,\\, 0.05)$.\n- Case $6$: $(\\text{RK4},\\, 1.0,\\, 1.0,\\, 0.0,\\, 1000.0,\\, 0.05)$.\n\nOutput. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case in the order above, append the two floats $(\\epsilon_H, \\epsilon_J)$, so the final output contains $12$ numbers in the order\n$$\n[\\epsilon_H^{(1)},\\epsilon_J^{(1)}, \\epsilon_H^{(2)},\\epsilon_J^{(2)}, \\ldots, \\epsilon_H^{(6)},\\epsilon_J^{(6)}].\n$$\n\nNotes.\n- All quantities are dimensionless, so no physical units are required.\n- Angles are assumed to be in radians.\n- The program must be self-contained, must not read any input, and must not access external files or the network.",
            "solution": "The user requests a program to solve the equations of motion for a two-dimensional Hamiltonian system, a toy model relevant to galactic dynamics, using two different numerical integrators: a second-order symplectic Strang splitting method (S2) and a standard fourth-order Runge-Kutta method (RK4). The objective is to compare their performance in conserving system invariants over long integration times.\n\nThe state of the system is described by the canonical coordinates $q = (x, y)$ and momenta $p = (p_x, p_y)$. All quantities are dimensionless. The state vector can be represented as a $4$-dimensional vector $z(t) = (x(t), y(t), p_x(t), p_y(t))$. The dynamics are governed by the Hamiltonian:\n$$\nH(q,p) = \\frac{1}{2}\\left(p_x^2 + p_y^2\\right) + \\frac{1}{2}\\left(\\omega_x^2 x^2 + \\omega_y^2 y^2\\right) - \\Omega \\left( x p_y - y p_x \\right)\n$$\nThis Hamiltonian is the Jacobi integral of the system in a frame rotating with constant pattern speed $\\Omega$. The parameters $\\omega_x$ and $\\omega_y$ are characteristic frequencies of a background potential. The equations of motion are Hamilton's equations, $\\dot{z} = \\mathbf{J} \\nabla H$, where $\\mathbf{J}$ is the standard symplectic matrix.\n\nThe solution involves implementing the two specified numerical integrators and two diagnostic error metrics, $\\epsilon_H$ and $\\epsilon_J$.\n\n**1. Symplectic Integrator: Second-Order Strang Splitting (S2)**\n\nSymplectic integrators are a class of geometric numerical methods designed to preserve the symplectic structure of Hamiltonian systems. This property ensures the conservation of phase-space volume and leads to excellent long-term stability, particularly the bounded error of an exactly conserved \"shadow\" Hamiltonian.\n\nThe problem specifies a splitting of the Hamiltonian into three parts, $H = T + U + G$, where:\n- $T(p) = \\frac{1}{2}(p_x^2 + p_y^2)$: The kinetic energy.\n- $U(q) = \\frac{1}{2}(\\omega_x^2 x^2 + \\omega_y^2 y^2)$: The potential energy from the anisotropic harmonic oscillator.\n- $G(q,p) = -\\Omega (x p_y - y p_x)$: The term arising from the Coriolis force in the rotating frame.\n\nEach of these sub-Hamiltonians generates a flow that can be integrated exactly. A single time step of size $\\Delta t$ is constructed by composing these exact flows. The specified symmetric Strang splitting composition is:\n$$\n\\Phi_{\\Delta t}^{\\text{S2}} = \\phi_U(\\Delta t/2) \\circ \\phi_G(\\Delta t/2) \\circ \\phi_T(\\Delta t) \\circ \\phi_G(\\Delta t/2) \\circ \\phi_U(\\Delta t/2)\n$$\nwhere $\\phi_K(\\tau)$ denotes the exact flow of the subsystem with Hamiltonian $K$ over a time interval $\\tau$. The individual flows are:\n-   **Flow $\\phi_T(\\tau)$:** The solution to $\\dot{q} = \\partial T/\\partial p = p$ and $\\dot{p} = -\\partial T/\\partial q = 0$. This is a free-particle drift: $q(t_0+\\tau) = q(t_0) + p(t_0)\\tau$, $p(t_0+\\tau) = p(t_0)$.\n-   **Flow $\\phi_U(\\tau)$:** The solution to $\\dot{q} = 0$ and $\\dot{p} = -\\nabla U(q)$. This is an impulse: $q(t_0+\\tau) = q(t_0)$, $p(t_0+\\tau) = p(t_0) - \\nabla U(q(t_0))\\tau$, where $\\nabla U(q) = (\\omega_x^2 x, \\omega_y^2 y)$.\n-   **Flow $\\phi_G(\\tau)$:** The solution to Hamilton's equations for $H=G$. This corresponds to a simultaneous rotation of the coordinate vector $q$ and momentum vector $p$. The coordinate vector $q$ is rotated by an angle $-\\Omega\\tau$, while the momentum vector $p$ is rotated by an angle $+\\Omega\\tau$.\n\nThe implementation combines these transformations in the specified sequence to advance the state vector $z$ by one time step $\\Delta t$.\n\n**2. Non-Symplectic Integrator: Fourth-Order Runge-Kutta (RK4)**\n\nThe explicit fourth-order Runge-Kutta method is a widely used, general-purpose solver for systems of ordinary differential equations of the form $\\dot{z} = f(t, z)$. For this problem, the function $f$ is derived from the full Hamilton's equations:\n$$\nf(z) = \\begin{pmatrix} \\dot{x} \\\\ \\dot{y} \\\\ \\dot{p}_x \\\\ \\dot{p}_y \\end{pmatrix} = \\begin{pmatrix} p_x + \\Omega y \\\\ p_y - \\Omega x \\\\ -\\omega_x^2 x + \\Omega p_y \\\\ -\\omega_y^2 y - \\Omega p_x \\end{pmatrix}\n$$\nA single step from $z_n$ to $z_{n+1}$ over time step $\\Delta t$ is calculated as:\n$$\n\\begin{align*}\nk_1 &= f(z_n) \\\\\nk_2 &= f(z_n + \\frac{\\Delta t}{2} k_1) \\\\\nk_3 &= f(z_n + \\frac{\\Delta t}{2} k_2) \\\\\nk_4 &= f(z_n + \\Delta t k_3) \\\\\nz_{n+1} &= z_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n$$\nWhile highly accurate for a given step size, RK4 does not preserve the symplectic structure and typically leads to secular drift in the energy and other conserved quantities over long integrations.\n\n**3. Diagnostics and Main Loop**\n\nFor each test case, the program initializes the state vector to $z(0) = (1.0, 0.2, 0.0, 0.9)$. It then runs the integration from $t=0$ to $t=T$ with a fixed step $\\Delta t$. During the simulation, the values of the Hamiltonian $H(t)$ and the sum of actions $J_x(t) + J_y(t)$ are stored at each time step $t_n = n \\Delta t$ for $n = 0, \\ldots, N$, where $N = \\lfloor T/\\Delta t \\rfloor$.\n\nAfter the integration is complete, two error metrics are computed:\n-   The maximum relative deviation of the Jacobi integral, $\\epsilon_H$, quantifies the conservation of the system's energy-like invariant.\n-   The relative root-mean-square deviation of the sum of actions, $\\epsilon_J$, measures the preservation of an adiabatic invariant, which is exactly conserved only in a simplified, uncoupled version of the system.\n\nThe code is structured to loop through the six specified test cases, run the corresponding simulation for each, calculate the two diagnostics, and collect the results for final output. The NumPy library is used for efficient vector and array operations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef hamiltonian(z, wx2, wy2, Omega):\n    \"\"\"Computes the Hamiltonian H(q,p).\"\"\"\n    x, y, px, py = z\n    T = 0.5 * (px**2 + py**2)\n    U = 0.5 * (wx2 * x**2 + wy2 * y**2)\n    G = -Omega * (x * py - y * px)\n    return T + U + G\n\ndef actions(z, wx, wy):\n    \"\"\"Computes the action-like diagnostics J_x and J_y.\"\"\"\n    x, y, px, py = z\n    # Add a small epsilon to denominators to avoid division by zero if wx or wy is 0\n    eps = 1e-16\n    jx = (0.5 * px**2 + 0.5 * wx**2 * x**2) / (wx + eps)\n    jy = (0.5 * py**2 + 0.5 * wy**2 * y**2) / (wy + eps)\n    return jx, jy\n\n# --- S2 Integrator Components ---\ndef flow_T(z, dt):\n    \"\"\"Exact flow for H=T(p).\"\"\"\n    x, y, px, py = z\n    x_new = x + px * dt\n    y_new = y + py * dt\n    return np.array([x_new, y_new, px, py])\n\ndef flow_U(z, wx2, wy2, dt):\n    \"\"\"Exact flow for H=U(q).\"\"\"\n    x, y, px, py = z\n    px_new = px - wx2 * x * dt\n    py_new = py - wy2 * y * dt\n    return np.array([x, y, px_new, py_new])\n\ndef flow_G(z, Omega, dt):\n    \"\"\"Exact flow for H=G(q,p).\"\"\"\n    x, y, px, py = z\n    \n    # Rotation for q by angle -Omega*dt\n    theta_q = -Omega * dt\n    cq, sq = np.cos(theta_q), np.sin(theta_q)\n    x_new = cq * x - sq * y\n    y_new = sq * x + cq * y\n    \n    # Rotation for p by angle +Omega*dt\n    theta_p = Omega * dt\n    cp, sp = np.cos(theta_p), np.sin(theta_p)\n    px_new = cp * px - sp * py\n    py_new = sp * px + cp * py\n\n    return np.array([x_new, y_new, px_new, py_new])\n\ndef s2_step(z, wx2, wy2, Omega, dt):\n    \"\"\"One step of the second-order Strang splitting integrator.\"\"\"\n    dt_half = 0.5 * dt\n    z_new = flow_U(z, wx2, wy2, dt_half)\n    z_new = flow_G(z_new, Omega, dt_half)\n    z_new = flow_T(z_new, dt)\n    z_new = flow_G(z_new, Omega, dt_half)\n    z_new = flow_U(z_new, wx2, wy2, dt_half)\n    return z_new\n\n# --- RK4 Integrator Components ---\ndef rk4_derivatives(z, wx2, wy2, Omega):\n    \"\"\"Computes the time derivative of the state vector for RK4.\"\"\"\n    x, y, px, py = z\n    dx_dt = px + Omega * y\n    dy_dt = py - Omega * x\n    dpx_dt = -wx2 * x + Omega * py\n    dpy_dt = -wy2 * y - Omega * px\n    return np.array([dx_dt, dy_dt, dpx_dt, dpy_dt])\n\ndef rk4_step(z, wx2, wy2, Omega, dt):\n    \"\"\"One step of the fourth-order Runge-Kutta integrator.\"\"\"\n    k1 = rk4_derivatives(z, wx2, wy2, Omega)\n    k2 = rk4_derivatives(z + 0.5 * dt * k1, wx2, wy2, Omega)\n    k3 = rk4_derivatives(z + 0.5 * dt * k2, wx2, wy2, Omega)\n    k4 = rk4_derivatives(z + dt * k3, wx2, wy2, Omega)\n    return z + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef run_simulation(method, wx, wy, Omega, T, dt, initial_state):\n    \"\"\"Runs a full simulation for a given method and parameters.\"\"\"\n    z = initial_state.copy()\n    wx2, wy2 = wx**2, wy**2\n    \n    num_steps = int(T / dt)\n    \n    # Store history for diagnostics\n    H_history = np.zeros(num_steps + 1)\n    J_sum_history = np.zeros(num_steps + 1)\n\n    # Initial values at t=0\n    H_history[0] = hamiltonian(z, wx2, wy2, Omega)\n    jx, jy = actions(z, wx, wy)\n    J_sum_history[0] = jx + jy\n\n    # Integration loop\n    for i in range(num_steps):\n        if method == 'S2':\n            z = s2_step(z, wx2, wy2, Omega, dt)\n        elif method == 'RK4':\n            z = rk4_step(z, wx2, wy2, Omega, dt)\n        \n        H_history[i + 1] = hamiltonian(z, wx2, wy2, Omega)\n        jx, jy = actions(z, wx, wy)\n        J_sum_history[i + 1] = jx + jy\n\n    # Calculate diagnostics\n    H0 = H_history[0]\n    J_sum0 = J_sum_history[0]\n    \n    # Epsilon H\n    eps_H_num = np.abs(H_history - H0)\n    eps_H_den = np.abs(H0) + 1e-12\n    epsilon_H = np.max(eps_H_num / eps_H_den)\n\n    # Epsilon J\n    eps_J_num = J_sum_history - J_sum0\n    eps_J_den = np.abs(J_sum0) + 1e-12\n    sq_rel_dev = (eps_J_num / eps_J_den)**2\n    epsilon_J = np.sqrt(np.mean(sq_rel_dev))\n    \n    return epsilon_H, epsilon_J\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (method, omega_x, omega_y, Omega, T, dt)\n        ('S2', 1.0, 1.2, 0.3, 1000.0, 0.05),\n        ('RK4', 1.0, 1.2, 0.3, 1000.0, 0.05),\n        ('S2', 1.0, 1.2, 0.3, 1000.0, 0.20),\n        ('RK4', 1.0, 1.2, 0.3, 1000.0, 0.20),\n        ('S2', 1.0, 1.0, 0.0, 1000.0, 0.05),\n        ('RK4', 1.0, 1.0, 0.0, 1000.0, 0.05),\n    ]\n\n    initial_state = np.array([1.0, 0.2, 0.0, 0.9])\n    \n    results = []\n    for case in test_cases:\n        method, wx, wy, Omega, T, dt = case\n        eps_H, eps_J = run_simulation(method, wx, wy, Omega, T, dt, initial_state)\n        results.append(eps_H)\n        results.append(eps_J)\n\n    # Final print statement in the exact required format.\n    # Using 'g' format for clean representation of small and regular numbers.\n    print(f\"[{','.join(f'{r:.7g}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having observed the practical benefits of symplectic integration, we now turn to a more fundamental question: how can we rigorously test if a given numerical map is truly symplectic? This practice guides you through implementing a direct numerical diagnostic based on the defining mathematical property of symplecticity, $J^{\\top} S J = S$. By numerically approximating the Jacobian of an integrator's one-step map , you will create a powerful tool to verify the geometric properties of your code and distinguish between genuinely symplectic methods and those that are not.",
            "id": "3493143",
            "problem": "Design and implement a program that numerically diagnoses the symplecticity of a discrete-time map generated by an $N$-body Hamiltonian integrator used in numerical cosmology. The diagnostic must evaluate the deviation from the canonical symplectic condition by computing the quantity $J^{\\top} S J - S$, where $J$ is the Jacobian of the one-step map of the integrator and $S$ is the canonical symplectic form. The program must report a scalar deviation per test case by taking a matrix norm of $J^{\\top} S J - S$ and aggregating this norm over an ensemble of random phase-space states.\n\nUse this context-appropriate fundamental base:\n- Hamiltonian mechanics in canonical form for positions $q$ and momenta $p$, with $dq/dt = \\partial H / \\partial p$ and $dp/dt = -\\partial H / \\partial q$.\n- For $N$ bodies with dimensionless parameters, use the gravitational Hamiltonian with Plummer softening: $H(q,p) = \\sum_{i=1}^{N} \\frac{\\|p_i\\|^2}{2 m_i} - \\sum_{1 \\le i < j \\le N} \\frac{G m_i m_j}{\\sqrt{\\|q_i - q_j\\|^2 + \\epsilon_s^2}}$.\n- The canonical symplectic form in block matrix representation on phase space coordinates $x = (q,p)$ is $S = \\begin{pmatrix} 0 & I \\\\ -I & 0 \\end{pmatrix}$, where $I$ is the identity matrix of size equal to the dimension of $q$ (positions).\n- A map is symplectic if and only if its Jacobian $J$ satisfies $J^{\\top} S J = S$.\n\nThe program must do the following:\n1. Construct a dimensionless $N$-body system with $G = 1$ and $m_i = 1$ for all $i$, working in $2$ spatial dimensions. All quantities are unitless and no physical units are required.\n2. Implement two one-step integrators for the Hamiltonian system:\n   - A time-reversible, second-order symplectic scheme (velocity Verlet/leapfrog).\n   - A standard explicit fourth-order Runge–Kutta method.\n3. For a given integrator, timestep $h$, and random state $x = (q,p)$, approximate the Jacobian $J$ of the one-step map by central finite differences. Use a fixed perturbation $10^{-7}$ along each canonical coordinate in $x$ to compute the columns of $J$.\n4. Compute the canonical symplecticity deviation for the step map at that state as the Frobenius norm $\\|J^{\\top} S J - S\\|_F$.\n5. Generate an ensemble of random states for each test case:\n   - Positions $q_i$ are drawn uniformly in the square $[-1,1]^2$.\n   - Momenta $p_i$ are drawn uniformly in $[-0.5,0.5]^2$.\n   - For $N \\ge 2$, enforce a minimum pairwise separation of $\\delta = 0.2$ by rejection sampling, to avoid near-singular configurations.\n   - Use Plummer softening $\\epsilon_s = 0.01$ in the gravitational potential.\n6. For each test case, compute the symplecticity deviation for each random state and report the median of these deviations as the test case’s result.\n\nDesign for coverage:\n- Use the following test suite of parameter values that exercises different conditions, including a nominal case, larger timesteps, and a boundary case of a free particle ($N = 1$):\n  - Case $1$: integrator type $=$ leapfrog, $N = 3$, $h = 0.005$, number of states $M = 4$, random seed $= 42$.\n  - Case $2$: integrator type $=$ leapfrog, $N = 3$, $h = 0.1$, number of states $M = 4$, random seed $= 43$.\n  - Case $3$: integrator type $=$ leapfrog, $N = 3$, $h = 0.3$, number of states $M = 4$, random seed $= 44$.\n  - Case $4$: integrator type $=$ Runge–Kutta $4$, $N = 3$, $h = 0.005$, number of states $M = 4$, random seed $= 45$.\n  - Case $5$: integrator type $=$ Runge–Kutta $4$, $N = 3$, $h = 0.1$, number of states $M = 4$, random seed $= 46$.\n  - Case $6$: integrator type $=$ Runge–Kutta $4$, $N = 3$, $h = 0.3$, number of states $M = 4$, random seed $= 47$.\n  - Case $7$: integrator type $=$ leapfrog, $N = 1$, $h = 0.3$, number of states $M = 4$, random seed $= 48$.\n  - Case $8$: integrator type $=$ Runge–Kutta $4$, $N = 1$, $h = 0.3$, number of states $M = 4$, random seed $= 49$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets and ordered exactly as the test suite above (for example, $[r_1,r_2,\\dots,r_8]$), where each $r_k$ is the median Frobenius norm of $J^{\\top} S J - S$ over the $M$ random states for the $k$-th test case. All results must be reported as floating-point numbers without any units.",
            "solution": "The problem requires the design and implementation of a numerical diagnostic to assess the symplecticity of discrete-time maps generated by N-body Hamiltonian integrators. This involves evaluating the preservation of the canonical symplectic structure, a fundamental geometric property of Hamiltonian dynamics.\n\n\nFirst, we establish the theoretical framework. An $N$-body system in $D$ spatial dimensions is described in phase space by a state vector $x = (q, p)$, where $q = (q_1, \\dots, q_N)$ are the generalized positions and $p = (p_1, \\dots, p_N)$ are the conjugate momenta. The total dimension of the phase space is $2DN$. For this problem, we consider $D=2$ spatial dimensions, so the phase space has dimension $4N$. The dynamics are governed by a Hamiltonian function $H(q,p)$. The equations of motion are Hamilton's canonical equations:\n$$\n\\frac{dq_i}{dt} = \\frac{\\partial H}{\\partial p_i}, \\quad \\frac{dp_i}{dt} = -\\frac{\\partial H}{\\partial q_i}\n$$\nThe problem specifies a dimensionless gravitational Hamiltonian with Plummer softening $\\epsilon_s$ for $N$ bodies, with gravitational constant $G=1$ and particle masses $m_i=1$:\n$$\nH(q,p) = \\sum_{i=1}^{N} \\frac{\\|p_i\\|^2}{2} - \\sum_{1 \\le i < j \\le N} \\frac{1}{\\sqrt{\\|q_i - q_j\\|^2 + \\epsilon_s^2}}\n$$\nThe time evolution of the system over a time interval $h$ is described by the flow map $\\phi_h$, such that $x(t+h) = \\phi_h(x(t))$. A numerical integrator provides an approximation to this map, which we denote as the one-step map $\\Phi_h$. A key property of the exact flow $\\phi_h$ is that it is a symplectic transformation. This means its Jacobian matrix, $J = D\\phi_h$, satisfies the symplectic condition:\n$$\nJ^{\\top} S J = S\n$$\nHere, $S$ is the canonical symplectic form, a block matrix defined on the phase space coordinates $x=(q,p)$ as:\n$$\nS = \\begin{pmatrix} 0 & I \\\\ -I & 0 \\end{pmatrix}\n$$\nwhere $I$ is the $2N \\times 2N$ identity matrix and $0$ is the $2N \\times 2N$ zero matrix. An integrator is called symplectic if its one-step map $\\Phi_h$ is also a symplectic transformation. Such integrators are crucial for long-term simulations, as in numerical cosmology, because they conserve a \"shadow\" Hamiltonian, leading to excellent long-term energy stability and preservation of phase space volume.\n\nThe task is to diagnose this property for two different integrators:\n\n1.  **Leapfrog (Velocity Verlet)**: This is a second-order, time-reversible integrator, well-known to be symplectic. Its one-step map $\\Phi_h^{\\text{LF}}$ is given by the sequence:\n    \n    $p_{n+1/2} = p_n + a(q_n) \\frac{h}{2}$\n    \n    $q_{n+1} = q_n + p_{n+1/2} h$\n    \n    $p_{n+1} = p_{n+1/2} + a(q_{n+1}) \\frac{h}{2}$\n    \n    where $a(q) = -\\nabla_q V(q)$ is the acceleration derived from the potential energy $V(q)$. Because this map is symplectic, its exact Jacobian should satisfy the symplectic condition.\n\n2.  **Explicit Fourth-Order Runge–Kutta (RK4)**: This is a general-purpose, high-order integrator. For an autonomous system $\\dot{x} = f(x)$, the one-step map $\\Phi_h^{\\text{RK4}}$ is:\n    \n    $k_1 = f(x_n)$\n    \n    $k_2 = f(x_n + \\frac{h}{2} k_1)$\n    \n    $k_3 = f(x_n + \\frac{h}{2} k_2)$\n    \n    $k_4 = f(x_n + h k_3)$\n    \n    $x_{n+1} = x_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)$\n    \n    where $f(x) = f(q,p) = (\\dot{q}, \\dot{p}) = (\\partial H/\\partial p, -\\partial H/\\partial q) = (p, a(q))$. In general, the RK4 map is not symplectic, and thus provides a point of contrast.\n\nThe diagnostic protocol is as follows. For a given integrator's one-step map $\\Phi_h$ and a state $x$ in phase space, we first compute the Jacobian matrix $J = D\\Phi_h(x)$. Since an analytical derivation of $J$ is cumbersome, we approximate it numerically using central finite differences. The $j$-th column of $J$ is approximated as:\n$$\nJ_{\\cdot, j} \\approx \\frac{\\Phi_h(x + \\delta e_j) - \\Phi_h(x - \\delta e_j)}{2\\delta}\n$$\nwhere $e_j$ is the $j$-th canonical basis vector and $\\delta = 10^{-7}$ is the specified small perturbation.\n\nWith the numerical Jacobian $J$ computed, we evaluate the deviation from the symplectic condition by forming the matrix $\\Delta = J^{\\top} S J - S$. For a perfect symplectic map and an exact Jacobian, $\\Delta$ would be the zero matrix. For a non-symplectic map or an approximate Jacobian, $\\Delta$ will be non-zero. The magnitude of this deviation is quantified by a scalar value, the Frobenius norm:\n$$\n\\|\\Delta\\|_F = \\sqrt{\\sum_{i,j} |\\Delta_{ij}|^2}\n$$\nThe deviation can be state-dependent. To obtain a representative measure for a given set of parameters (integrator type, $N$, $h$), an ensemble of $M$ random phase-space states is generated. For each state, the deviation norm is calculated. The final reported value for a test case is the median of these $M$ norms. The median is a robust statistical measure, less sensitive to potential outliers than the mean. The initial states are generated by drawing positions $q_i$ and momenta $p_i$ from uniform distributions, with a rejection sampling step to enforce a minimum particle separation $\\delta=0.2$ for $N \\ge 2$, avoiding near-singularities in the force calculation.\n\nFor the symplectic Leapfrog integrator, the theoretical map is exactly symplectic. The measured deviation is therefore expected to be small, primarily arising from floating-point arithmetic and the approximation error in the finite-difference Jacobian calculation. Conversely, for the non-symplectic RK4 integrator, the deviation is intrinsic to the method and is expected to be significantly larger and dependent on the timestep $h$. The special case of $N=1$ (a free particle) serves as a valuable sanity check, as the motion is trivial ($p(t) = \\text{const}, q(t) = q_0 + p_0 t$) and both integrators yield the exact, symplectic solution, predicting a near-zero deviation for both.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the symplecticity diagnostics for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # (integrator_type, N, h, M, seed)\n        ('leapfrog', 3, 0.005, 4, 42),\n        ('leapfrog', 3, 0.1, 4, 43),\n        ('leapfrog', 3, 0.3, 4, 44),\n        ('rk4', 3, 0.005, 4, 45),\n        ('rk4', 3, 0.1, 4, 46),\n        ('rk4', 3, 0.3, 4, 47),\n        ('leapfrog', 1, 0.3, 4, 48),\n        ('rk4', 1, 0.3, 4, 49),\n    ]\n\n    G = 1.0\n    EPSILON_S = 0.01\n    FINITE_DIFF_PERT = 1e-7\n    MIN_SEP = 0.2\n\n    def get_acceleration(q, n_particles):\n        \"\"\"\n        Calculates the acceleration of N particles.\n        q has shape (n_particles, 2).\n        Returns acceleration of shape (n_particles, 2).\n        \"\"\"\n        if n_particles <= 1:\n            return np.zeros_like(q)\n\n        # Vectorized calculation of pairwise forces\n        # q shape: (N, D) -> (1, N, D) and (N, 1, D)\n        # diff shape: (N, N, D) where diff[i, j, :] is q[j] - q[i]\n        diff = q[None, :, :] - q[:, None, :]\n\n        # dist_sq shape: (N, N) where dist_sq[i, j] is ||q[j] - q[i]||^2\n        dist_sq = np.sum(diff**2, axis=-1)\n\n        # inv_r3 shape: (N, N) where inv_r3[i, j] = (dist_sq[i, j] + eps^2)^(-3/2)\n        # We use mass=1 and G=1. Force on i from j is - (q_i - q_j) / r^3\n        # accel on i is sum_j (q_j-q_i)/r^3\n        with np.errstate(divide='ignore', invalid='ignore'):\n            inv_r3 = (dist_sq + EPSILON_S**2)**(-1.5)\n        np.fill_diagonal(inv_r3, 0.0) # No self-force\n\n        # accel[i,:] = sum_j (q_j-q_i)*inv_r3[i,j]\n        # diff is qj-qi, so we need to sum over axis 1 (j)\n        accel = np.sum(diff * inv_r3[:, :, None], axis=1) * G\n        \n        return accel\n\n    def leapfrog_step(x, h, n_particles):\n        \"\"\"\n        Performs one step of the velocity Verlet/leapfrog integrator.\n        x is a flat array of shape (4*n_particles,).\n        \"\"\"\n        dim = 2 * n_particles\n        q0 = x[:dim].reshape((n_particles, 2))\n        p0 = x[dim:].reshape((n_particles, 2))\n\n        a0 = get_acceleration(q0, n_particles)\n        p_half = p0 + a0 * h / 2.0\n        q1 = q0 + p_half * h\n        a1 = get_acceleration(q1, n_particles)\n        p1 = p_half + a1 * h / 2.0\n        \n        return np.concatenate((q1.flatten(), p1.flatten()))\n\n    def rk4_step(x, h, n_particles):\n        \"\"\"\n        Performs one step of the RK4 integrator.\n        x is a flat array of shape (4*n_particles,).\n        \"\"\"\n        dim = 2 * n_particles\n\n        def f(state_vec):\n            q_vec = state_vec[:dim].reshape((n_particles, 2))\n            p_vec = state_vec[dim:].reshape((n_particles, 2))\n            \n            dq_dt = p_vec\n            dp_dt = get_acceleration(q_vec, n_particles)\n            \n            return np.concatenate((dq_dt.flatten(), dp_dt.flatten()))\n\n        k1 = f(x)\n        k2 = f(x + 0.5 * h * k1)\n        k3 = f(x + 0.5 * h * k2)\n        k4 = f(x + h * k3)\n        \n        x_next = x + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n        return x_next\n\n    def generate_random_state(rng, n_particles, min_sep):\n        \"\"\"\n        Generates a single random state (q, p) with rejection sampling for q.\n        \"\"\"\n        dim_pos = 2 * n_particles\n        q_flat = np.zeros(dim_pos)\n\n        if n_particles >= 2:\n            while True:\n                q = rng.uniform(-1.0, 1.0, size=(n_particles, 2))\n                \n                # Check pairwise separation\n                diff = q[None, :, :] - q[:, None, :]\n                dist_sq = np.sum(diff**2, axis=-1)\n                np.fill_diagonal(dist_sq, np.inf)\n                \n                if np.sqrt(np.min(dist_sq)) > min_sep:\n                    q_flat = q.flatten()\n                    break\n        else: # n_particles == 1\n            q = rng.uniform(-1.0, 1.0, size=(n_particles, 2))\n            q_flat = q.flatten()\n\n        p = rng.uniform(-0.5, 0.5, size=(n_particles, 2))\n        p_flat = p.flatten()\n\n        return np.concatenate((q_flat, p_flat))\n\n    def compute_jacobian(one_step_map, x, h, n_particles, pert):\n        \"\"\"\n        Computes the Jacobian of the one-step map using central finite differences.\n        \"\"\"\n        phase_space_dim = 4 * n_particles\n        jacobian = np.zeros((phase_space_dim, phase_space_dim))\n        \n        for j in range(phase_space_dim):\n            e_j = np.zeros(phase_space_dim)\n            e_j[j] = 1.0\n            \n            x_plus = x + pert * e_j\n            x_minus = x - pert * e_j\n            \n            map_plus = one_step_map(x_plus, h, n_particles)\n            map_minus = one_step_map(x_minus, h, n_particles)\n\n            jacobian[:, j] = (map_plus - map_minus) / (2 * pert)\n            \n        return jacobian\n\n    results = []\n    integrators = {'leapfrog': leapfrog_step, 'rk4': rk4_step}\n\n    for case in test_cases:\n        integrator_type, N, h, M, seed = case\n        \n        rng = np.random.default_rng(seed)\n        one_step_map = integrators[integrator_type]\n        \n        phase_space_dim = 4 * N\n        pos_dim = 2 * N\n        \n        # Construct the symplectic matrix S\n        I = np.identity(pos_dim)\n        Z = np.zeros((pos_dim, pos_dim))\n        S = np.block([[Z, I], [-I, Z]])\n        \n        deviations = []\n        for _ in range(M):\n            # 1. Generate a random state\n            x0 = generate_random_state(rng, N, MIN_SEP)\n            \n            # 2. Compute the Jacobian at this state\n            J = compute_jacobian(one_step_map, x0, h, N, FINITE_DIFF_PERT)\n            \n            # 3. Compute the deviation matrix and its norm\n            deviation_matrix = J.T @ S @ J - S\n            deviation_norm = np.linalg.norm(deviation_matrix, 'fro')\n            deviations.append(deviation_norm)\n            \n        # 4. Report the median deviation for the test case\n        median_deviation = np.median(deviations)\n        results.append(median_deviation)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Applying symplectic methods to cosmology introduces the complication of an explicitly time-dependent Hamiltonian, driven by the expansion of the universe via the scale factor $a(t)$. This necessitates careful choices in the integrator design, as the standard arguments for symplecticity do not straightforwardly apply. This exercise  explores the practical consequences of these choices by comparing different leapfrog orderings (KDK vs. DKD) and methods for handling $a(t)$, revealing their impact on phase accuracy in a non-autonomous system.",
            "id": "3493161",
            "problem": "Consider a one-dimensional non-autonomous Hamiltonian system relevant to numerical cosmology in comoving coordinates, with Hamiltonian $H(\\mathbf{q},\\mathbf{p},a(t))$ specialized to one spatial degree of freedom. Let the Hamiltonian be separable as $H(q,p,a(t)) = T(p) + S(a(t)) V(q)$, where $T(p) = \\frac{1}{2} p^2$, $V(q) = \\frac{1}{2} \\omega_0^2 q^2$, and $S(a(t)) = a(t)^{-3}$. The canonical equations of motion are $q' = \\partial H/\\partial p = p$ and $p' = -\\partial H/\\partial q = -S(a(t)) \\omega_0^2 q$, where primes denote derivatives with respect to cosmic time $t$. The scale factor $a(t)$ follows the Friedmann equation for a spatially flat Universe with matter and cosmological constant, given by $a'(t) = H_0 a(t) \\sqrt{\\Omega_m a(t)^{-3} + \\Omega_\\Lambda}$, where $H_0$ is the Hubble parameter at the present epoch and $\\Omega_m + \\Omega_\\Lambda = 1$.\n\nThis problem asks you to compare the Kick-Drift-Kick (KDK) and Drift-Kick-Drift (DKD) leapfrog orderings for this non-autonomous Hamiltonian and to characterize the differences in phase error arising from two strategies for obtaining $a(t)$: (i) on-the-fly evolution using a first-order explicit scheme synchronized with the leapfrog substeps, and (ii) tabulated $a(t)$ obtained by a high-accuracy numerical solution to the Friedmann equation, interpolated at the required times. You must implement both integrators and both $a(t)$ strategies, and then quantify the phase error relative to a high-accuracy reference solution for the $(q(t),p(t))$ dynamics that uses the tabulated $a(t)$ in a high-order ordinary differential equation solver.\n\nFundamental base:\n- Hamilton's equations for separable $H(q,p,a(t))$ yield $q' = p$ and $p' = -S(a(t)) \\omega_0^2 q$.\n- The Friedmann equation in a flat Universe gives $a'(t) = H_0 a(t) \\sqrt{\\Omega_m a(t)^{-3} + \\Omega_\\Lambda}$ with $\\Omega_\\Lambda = 1 - \\Omega_m$.\n- The symplectic leapfrog integrator can be ordered as Drift-Kick-Drift (DKD) (drift half step, kick full step, drift half step) or Kick-Drift-Kick (KDK) (kick half step, drift full step, kick half step). For time-dependent $S(a(t))$, DKD evaluates the kick at mid-step time $t + h/2$ while KDK uses endpoint times $t$ and $t + h$, where $h$ is the time step.\n\nDefinitions and units:\n- Use dimensionless units with $H_0 = 1$, so time $t$ is measured in units of $H_0^{-1}$.\n- Angles must be reported in radians.\n- Let the instantaneous effective frequency be $\\omega_{\\mathrm{eff}}(t) = \\omega_0 \\sqrt{S(a(t))} = \\omega_0 a(t)^{-3/2}$. Define the instantaneous angle variable at time $t$ as $\\theta(t) = \\operatorname{atan2}(\\omega_{\\mathrm{eff}}(t) q(t), p(t))$, in radians.\n\nIntegrator specifications:\n- DKD with tabulated $a(t)$ for step size $h$:\n  1. Compute $q_{\\mathrm{half}} = q_n + p_n \\, h/2$ at time $t_n + h/2$.\n  2. Evaluate $a_{\\mathrm{mid}} = a(t_n + h/2)$ from the tabulation. Apply the kick: $p_{n+1} = p_n - \\omega_0^2 S(a_{\\mathrm{mid}}) q_{\\mathrm{half}} h$.\n  3. Complete the drift: $q_{n+1} = q_{\\mathrm{half}} + p_{n+1} \\, h/2$. Advance time $t_{n+1} = t_n + h$.\n- KDK with tabulated $a(t)$ for step size $h$:\n  1. Evaluate $a_n = a(t_n)$ and apply half kick: $p_{\\mathrm{half}} = p_n - \\omega_0^2 S(a_n) q_n \\, h/2$.\n  2. Drift full step: $q_{n+1} = q_n + p_{\\mathrm{half}} h$, advance time $t_{n+1} = t_n + h$.\n  3. Evaluate $a_{n+1} = a(t_{n+1})$ and apply final half kick: $p_{n+1} = p_{\\mathrm{half}} - \\omega_0^2 S(a_{n+1}) q_{n+1} \\, h/2$.\n- DKD with on-the-fly $a(t)$ using explicit first-order evolution synchronized with substeps:\n  1. Compute $q_{\\mathrm{half}} = q_n + p_n \\, h/2$.\n  2. Update $a_{\\mathrm{half}} = a_n + (h/2) f(a_n)$ where $f(a) = a \\sqrt{\\Omega_m a^{-3} + \\Omega_\\Lambda}$.\n  3. Apply kick with $a_{\\mathrm{half}}$: $p_{n+1} = p_n - \\omega_0^2 S(a_{\\mathrm{half}}) q_{\\mathrm{half}} h$.\n  4. Complete drift: $q_{n+1} = q_{\\mathrm{half}} + p_{n+1} \\, h/2$.\n  5. Update $a_{n+1} = a_{\\mathrm{half}} + (h/2) f(a_{\\mathrm{half}})$.\n- KDK with on-the-fly $a(t)$ using explicit first-order evolution synchronized with substeps:\n  1. Apply half kick at $a_n$: $p_{\\mathrm{half}} = p_n - \\omega_0^2 S(a_n) q_n \\, h/2$.\n  2. Drift full step: $q_{n+1} = q_n + p_{\\mathrm{half}} h$.\n  3. Update $a_{n+1} = a_n + h f(a_n)$.\n  4. Apply final half kick at $a_{n+1}$: $p_{n+1} = p_{\\mathrm{half}} - \\omega_0^2 S(a_{n+1}) q_{n+1} \\, h/2$.\n\nReference solution:\n- Obtain a high-accuracy tabulated $a(t)$ by solving $a'(t) = a(t) \\sqrt{\\Omega_m a(t)^{-3} + \\Omega_\\Lambda}$ with $H_0 = 1$, using a high-order ordinary differential equation solver with tight tolerances over the interval $[t_0, t_{\\mathrm{end}}]$.\n- With this tabulated $a(t)$, compute a high-accuracy reference solution for $(q(t),p(t))$ by solving the system $q'(t) = p(t)$ and $p'(t) = -\\omega_0^2 a(t)^{-3} q(t)$ with tight tolerances. Use the same $t_0$ and $t_{\\mathrm{end}}$ and initial conditions $(q_0,p_0)$.\n\nPhase error metric:\n- For each integrator and $a(t)$ strategy, compute the final angle $\\theta_{\\mathrm{num}}(t_{\\mathrm{end}})$ using the appropriate $a(t_{\\mathrm{end}})$ (the evolved $a$ for on-the-fly, and the tabulated $a(t_{\\mathrm{end}})$ for tabulated).\n- Compute the reference angle $\\theta_{\\mathrm{ref}}(t_{\\mathrm{end}})$ using the reference $(q,p)$ and the tabulated $a(t_{\\mathrm{end}})$.\n- Report the absolute, $2\\pi$-wrapped difference $\\Delta \\theta = \\left| \\mathrm{wrap}\\left(\\theta_{\\mathrm{num}} - \\theta_{\\mathrm{ref}}\\right) \\right|$ where $\\mathrm{wrap}(\\phi) = ((\\phi + \\pi) \\bmod 2\\pi) - \\pi$, in radians.\n\nTest suite:\nFor each test case, set $\\omega_0 = 1.0$, $H_0 = 1$, $t_0 = 0.0$, and $\\Omega_\\Lambda = 1 - \\Omega_m$. The program must compute, for each case, the four phase errors\n$[\\Delta \\theta_{\\mathrm{DKD,on-fly}}, \\Delta \\theta_{\\mathrm{KDK,on-fly}}, \\Delta \\theta_{\\mathrm{DKD,tab}}, \\Delta \\theta_{\\mathrm{KDK,tab}}]$.\nUse the following test cases, with time in $H_0^{-1}$ and angles in radians:\n- Case $1$: $(h, t_{\\mathrm{end}}, a_0, q_0, p_0, \\Omega_m) = (0.02, 2.0, 0.5, 1.0, 0.0, 0.3)$.\n- Case $2$: $(h, t_{\\mathrm{end}}, a_0, q_0, p_0, \\Omega_m) = (0.05, 2.0, 0.5, 1.0, 0.0, 0.3)$.\n- Case $3$: $(h, t_{\\mathrm{end}}, a_0, q_0, p_0, \\Omega_m) = (0.02, 2.0, 0.1, 1.0, 0.0, 0.3)$.\n- Case $4$: $(h, t_{\\mathrm{end}}, a_0, q_0, p_0, \\Omega_m) = (0.02, 1.0, 0.5, 0.7, 0.2, 0.3)$.\n\nFinal output format:\nYour program should produce a single line of output containing the phase error results ordered by the test cases, each case contributing the four values in the order $[\\Delta \\theta_{\\mathrm{DKD,on-fly}}, \\Delta \\theta_{\\mathrm{KDK,on-fly}}, \\Delta \\theta_{\\mathrm{DKD,tab}}, \\Delta \\theta_{\\mathrm{KDK,tab}}]$, aggregated into a single comma-separated list enclosed in square brackets. For example, the final output must look like $[r_{1,1},r_{1,2},r_{1,3},r_{1,4},r_{2,1},\\dots,r_{4,4}]$ where each $r_{i,j}$ is a floating-point number in radians.",
            "solution": "The problem requires a comparison of four numerical integration schemes for a one-dimensional non-autonomous Hamiltonian system, a model relevant to numerical cosmology. The Hamiltonian is specified as $H(q,p,a(t)) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega_0^2 a(t)^{-3} q^2$, representing a harmonic oscillator with a time-varying potential strength governed by the cosmological scale factor $a(t)$. The evolution of $a(t)$ is determined by the Friedmann equation for a flat Universe containing matter and a cosmological constant. The comparison focuses on two variants of the second-order symplectic leapfrog integrator, Kick-Drift-Kick (KDK) and Drift-Kick-Drift (DKD), each implemented with two different strategies for handling the time-dependent scale factor $a(t)$: first, using a pre-computed high-accuracy table for $a(t)$, and second, evolving $a(t)$ \"on-the-fly\" concurrently with the phase space variables $(q,p)$. The primary metric for comparison is the phase error at the end of the integration.\n\nFirst, a high-accuracy reference solution is indispensable for quantifying the errors of the approximate numerical schemes. This \"ground truth\" is established in a two-step process using a high-order adaptive ordinary differential equation (ODE) solver, specifically the Dormand-Prince 8(5,3) method (`DOP853`) as implemented in `scipy.integrate.solve_ivp`, with stringent error tolerances (e.g., $10^{-13}$). The first step is to solve the Friedmann equation, $a'(t) = H_0 a(t) \\sqrt{\\Omega_m a(t)^{-3} + \\Omega_\\Lambda}$ with $\\Omega_m + \\Omega_\\Lambda = 1$ and $H_0=1$, from an initial time $t_0$ and scale factor $a_0$ to a final time $t_{\\mathrm{end}}$. This yields a continuous representation of the scale factor, $a_{\\mathrm{ref}}(t)$. In the second step, this reference function $a_{\\mathrm{ref}}(t)$ is used to solve the canonical equations of motion for the oscillator:\n$$\nq'(t) = \\frac{\\partial H}{\\partial p} = p(t)\n$$\n$$\np'(t) = -\\frac{\\partial H}{\\partial q} = -\\omega_0^2 a(t)^{-3} q(t)\n$$\nThis yields the reference trajectory $(q_{\\mathrm{ref}}(t), p_{\\mathrm{ref}}(t))$. The final state $(q_{\\mathrm{ref}}(t_{\\mathrm{end}}), p_{\\mathrm{ref}}(t_{\\mathrm{end}}))$ and the corresponding scale factor $a_{\\mathrm{ref}}(t_{\\mathrm{end}})$ serve as the benchmark for all comparisons.\n\nThe core of the problem lies in implementing and comparing four leapfrog-based schemes. The leapfrog integrator is a geometric integrator, specifically a symplectic one for autonomous Hamiltonian systems, known for its excellent long-term energy and phase conservation properties. For a non-autonomous separable Hamiltonian $H=T(p)+V(q,t)$, the evolution over a time step $h$ is formally $\\exp(h(\\hat{T} + \\hat{V}))\\approx \\exp(h\\hat{T}/2)\\exp(h\\hat{V})\\exp(h\\hat{T}/2)$ for DKD, or $\\exp(h\\hat{V}/2)\\exp(h\\hat{T})\\exp(h\\hat{V}/2)$ for KDK, where $\\hat{T}$ and $\\hat{V}$ are the Liouville operators for the kinetic and potential parts. The `Drift` operation corresponds to evolution under $T(p)$, and `Kick` corresponds to evolution under $V(q,t)$.\n\nThe specifications for the four methods are as follows:\n1.  **DKD with tabulated $a(t)$**: This scheme uses the pre-computed high-accuracy $a_{\\mathrm{ref}}(t)$. For a step from $t_n$ to $t_{n+1}=t_n+h$, the DKD integrator performs a half-step drift, a full-step kick, and another half-step drift. Its time symmetry suggests evaluating the time-dependent term at the midpoint, $t_{n+1/2} = t_n + h/2$.\n    $$\n    q_{n+1/2} = q_n + p_n \\frac{h}{2} \\quad (\\text{Drift})\n    $$\n    $$\n    p_{n+1} = p_n - \\omega_0^2 a(t_{n+1/2})^{-3} q_{n+1/2} h \\quad (\\text{Kick})\n    $$\n    $$\n    q_{n+1} = q_{n+1/2} + p_{n+1} \\frac{h}{2} \\quad (\\text{Drift})\n    $$\n2.  **KDK with tabulated $a(t)$**: This scheme also uses $a_{\\mathrm{ref}}(t)$. The KDK ordering involves a half-step kick, a full-step drift, and a final half-step kick. This requires evaluating the potential at the beginning and end of the time step.\n    $$\n    p_{n+1/2} = p_n - \\omega_0^2 a(t_n)^{-3} q_n \\frac{h}{2} \\quad (\\text{Kick})\n    $$\n    $$\n    q_{n+1} = q_n + p_{n+1/2} h \\quad (\\text{Drift})\n    $$\n    $$\n    p_{n+1} = p_{n+1/2} - \\omega_0^2 a(t_{n+1})^{-3} q_{n+1} \\frac{h}{2} \\quad (\\text{Kick})\n    $$\n3.  **DKD with on-the-fly $a(t)$**: Here, $a(t)$ is not pre-computed but evolved alongside $(q,p)$. The problem specifies a synchronized, second-order leapfrog-like update for $a(t)$.\n    - First half drift for $(q,p)$: $q_{n+1/2} = q_n + p_n h/2$.\n    - First half step for $a$: $a_{n+1/2} = a_n + (h/2) \\, a'(a_n)$.\n    - Full kick for $(q,p)$ using $a_{n+1/2}$: $p_{n+1} = p_n - \\omega_0^2 a_{n+1/2}^{-3} q_{n+1/2} h$.\n    - Second half drift for $(q,p)$: $q_{n+1} = q_{n+1/2} + p_{n+1} h/2$.\n    - Second half step for $a$: $a_{n+1} = a_{n+1/2} + (h/2) \\, a'(a_{n+1/2})$.\n    This method couples a second-order integrator for $(q,p,a)$, which should exhibit good stability.\n4.  **KDK with on-the-fly $a(t)$**: In this variant, the update for $a(t)$ is a simple first-order forward Euler step: $a_{n+1} = a_n + h \\, a'(a_n)$. This update is not time-symmetric and is of a lower order than the KDK integrator for $(q,p)$, introducing an additional, and likely dominant, source of error and instability. The full procedure is:\n    - First half kick for $(q,p)$ using $a_n$: $p_{n+1/2} = p_n - \\omega_0^2 a_n^{-3} q_n h/2$.\n    - Full drift for $q$: $q_{n+1} = q_n + p_{n+1/2} h$.\n    - Full Euler step for $a$: $a_{n+1} = a_n + h \\, a'(a_n)$.\n    - Second half kick for $(q,p)$ using $a_{n+1}$: $p_{n+1} = p_{n+1/2} - \\omega_0^2 a_{n+1}^{-3} q_{n+1} h/2$.\n\nThe performance of these schemes is evaluated by the phase error. For an oscillator, the state can be described by an amplitude and a phase. We define an instantaneous effective frequency $\\omega_{\\mathrm{eff}}(t) = \\omega_0 a(t)^{-3/2}$ and a corresponding angle variable $\\theta(t) = \\operatorname{atan2}(\\omega_{\\mathrm{eff}}(t) q(t), p(t))$. The error is the absolute difference between the final angle from a numerical scheme, $\\theta_{\\mathrm{num}}(t_{\\mathrm{end}})$, and the reference angle, $\\theta_{\\mathrm{ref}}(t_{\\mathrm{end}})$. This difference is wrapped to the interval $[-\\pi, \\pi]$ to represent the shortest angle between the two final phase vectors: $\\Delta \\theta = \\left| \\mathrm{wrap}\\left(\\theta_{\\mathrm{num}} - \\theta_{\\mathrm{ref}}\\right) \\right|$, where $\\mathrm{wrap}(\\phi) = ((\\phi + \\pi) \\bmod 2\\pi) - \\pi$. For the on-the-fly methods, $\\omega_{\\mathrm{eff}}$ is computed using the value of $a(t_{\\mathrm{end}})$ evolved by that scheme, whereas for the tabulated methods, the reference value $a_{\\mathrm{ref}}(t_{\\mathrm{end}})$ is used.\n\nThe overall algorithm proceeds by iterating through the specified test cases. For each case, the parameters $(h, t_{\\mathrm{end}}, a_0, q_0, p_0, \\Omega_m)$ are used to generate the reference solution. Then, each of the four integrators is run over the time interval $[t_0, t_{\\mathrm{end}}]$. The final phase error for each is calculated and stored. The final output aggregates these errors into a single list.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    \"\"\"\n    \n    # -- Test cases as specified in the problem --\n    test_cases = [\n        (0.02, 2.0, 0.5, 1.0, 0.0, 0.3),  # Case 1\n        (0.05, 2.0, 0.5, 1.0, 0.0, 0.3),  # Case 2\n        (0.02, 2.0, 0.1, 1.0, 0.0, 0.3),  # Case 3\n        (0.02, 1.0, 0.5, 0.7, 0.2, 0.3),  # Case 4\n    ]\n\n    # -- Global constants --\n    omega0 = 1.0\n    H0 = 1.0\n    t0 = 0.0\n    \n    # -- Helper Functions --\n\n    def wrap_angle(phi):\n        \"\"\"Wraps an angle to the interval [-pi, pi].\"\"\"\n        return (phi + np.pi) % (2 * np.pi) - np.pi\n\n    def f_a_ode(t, a_vec, H0, Om_m, Om_L):\n        \"\"\"ODE for the scale factor a(t) for solve_ivp.\"\"\"\n        a = a_vec[0]\n        return [H0 * a * np.sqrt(Om_m * a**(-3) + Om_L)]\n    \n    def f_a_prime(a, H0, Om_m, Om_L):\n        \"\"\"Derivative of a(t) for on-the-fly integrators.\"\"\"\n        return H0 * a * np.sqrt(Om_m * a**(-3) + Om_L)\n    \n    def f_qp_ode(t, y, omega0, a_func):\n        \"\"\"ODE system for (q,p) for solve_ivp.\"\"\"\n        q, p = y\n        a_val = a_func(t)[0]\n        dq_dt = p\n        dp_dt = -omega0**2 * a_val**(-3) * q\n        return [dq_dt, dp_dt]\n\n    # -- Integrator Implementations --\n\n    def dkd_on_fly(h, t_end, a0, q0, p0, H0, omega0, Om_m, Om_L):\n        t, a, q, p = t0, a0, q0, p0\n        num_steps = int(round((t_end - t0) / h))\n        h_actual = (t_end - t0) / num_steps\n        \n        for _ in range(num_steps):\n            q_half = q + p * h_actual / 2.0\n            a_half = a + (h_actual / 2.0) * f_a_prime(a, H0, Om_m, Om_L)\n            p_new = p - omega0**2 * a_half**(-3) * q_half * h_actual\n            q_new = q_half + p_new * h_actual / 2.0\n            a_new = a_half + (h_actual / 2.0) * f_a_prime(a_half, H0, Om_m, Om_L)\n            a, q, p = a_new, q_new, p_new\n        return q, p, a\n\n    def kdk_on_fly(h, t_end, a0, q0, p0, H0, omega0, Om_m, Om_L):\n        t, a, q, p = t0, a0, q0, p0\n        num_steps = int(round((t_end - t0) / h))\n        h_actual = (t_end - t0) / num_steps\n\n        for _ in range(num_steps):\n            p_half = p - (h_actual / 2.0) * omega0**2 * a**(-3) * q\n            q_new = q + h_actual * p_half\n            a_new = a + h_actual * f_a_prime(a, H0, Om_m, Om_L)\n            p_new = p_half - (h_actual / 2.0) * omega0**2 * a_new**(-3) * q_new\n            a, q, p = a_new, q_new, p_new\n        return q, p, a\n\n    def dkd_tabulated(h, t_end, q0, p0, omega0, a_func):\n        t, q, p = t0, q0, p0\n        num_steps = int(round((t_end - t0) / h))\n        h_actual = (t_end - t0) / num_steps\n\n        for _ in range(num_steps):\n            t_mid = t + h_actual / 2.0\n            q_half = q + p * h_actual / 2.0\n            a_mid = a_func(t_mid)\n            p_new = p - omega0**2 * a_mid**(-3) * q_half * h_actual\n            q_new = q_half + p_new * h_actual / 2.0\n            q, p = q_new, p_new\n            t += h_actual\n        return q, p\n\n    def kdk_tabulated(h, t_end, q0, p0, omega0, a_func):\n        t, q, p = t0, q0, p0\n        num_steps = int(round((t_end - t0) / h))\n        h_actual = (t_end - t0) / num_steps\n        \n        for _ in range(num_steps):\n            a_start = a_func(t)\n            p_half = p - (h_actual / 2.0) * omega0**2 * a_start**(-3) * q\n            q_new = q + h_actual * p_half\n            t_next = t + h_actual\n            a_end_step = a_func(t_next)\n            p_new = p_half - (h_actual / 2.0) * omega0**2 * a_end_step**(-3) * q_new\n            q, p = q_new, p_new\n            t = t_next\n        return q, p\n\n    results = []\n    TOL = 1e-13\n\n    for case in test_cases:\n        h, t_end, a0, q0, p0, Om_m = case\n        Om_L = 1.0 - Om_m\n\n        # 1. Generate high-accuracy reference solution\n        sol_a = solve_ivp(\n            f_a_ode, [t0, t_end], [a0], args=(H0, Om_m, Om_L),\n            dense_output=True, method='DOP853', rtol=TOL, atol=TOL\n        )\n        a_ref_func_ivp = sol_a.sol\n        \n        # Create a simple interpolator for leapfrog versions\n        t_dense = np.linspace(t0, t_end, 2000)\n        a_dense = a_ref_func_ivp(t_dense)[0]\n        a_ref_func_interp = interp1d(t_dense, a_dense, kind='cubic', fill_value=\"extrapolate\")\n\n        sol_qp_ref = solve_ivp(\n            f_qp_ode, [t0, t_end], [q0, p0], args=(omega0, a_ref_func_ivp),\n            dense_output=True, method='DOP853', rtol=TOL, atol=TOL\n        )\n        q_ref_end, p_ref_end = sol_qp_ref.y[:, -1]\n        a_ref_end = a_ref_func_ivp(t_end)[0]\n        \n        omega_eff_ref = omega0 * a_ref_end**(-1.5)\n        theta_ref = np.arctan2(omega_eff_ref * q_ref_end, p_ref_end)\n\n        # 2. Run numerical schemes and compute errors\n        # The output order must be [DKD-fly, KDK-fly, DKD-tab, KDK-tab]\n\n        # DKD, on-the-fly\n        q_dkd_fly, p_dkd_fly, a_dkd_fly = dkd_on_fly(h, t_end, a0, q0, p0, H0, omega0, Om_m, Om_L)\n        omega_eff_dkd_fly = omega0 * a_dkd_fly**(-1.5)\n        theta_dkd_fly = np.arctan2(omega_eff_dkd_fly * q_dkd_fly, p_dkd_fly)\n        error_dkd_fly = abs(wrap_angle(theta_dkd_fly - theta_ref))\n        results.append(error_dkd_fly)\n\n        # KDK, on-the-fly\n        q_kdk_fly, p_kdk_fly, a_kdk_fly = kdk_on_fly(h, t_end, a0, q0, p0, H0, omega0, Om_m, Om_L)\n        omega_eff_kdk_fly = omega0 * a_kdk_fly**(-1.5)\n        theta_kdk_fly = np.arctan2(omega_eff_kdk_fly * q_kdk_fly, p_kdk_fly)\n        error_kdk_fly = abs(wrap_angle(theta_kdk_fly - theta_ref))\n        results.append(error_kdk_fly)\n\n        # DKD, tabulated\n        q_dkd_tab, p_dkd_tab = dkd_tabulated(h, t_end, q0, p0, omega0, a_ref_func_interp)\n        omega_eff_dkd_tab = omega0 * a_ref_end**(-1.5)\n        theta_dkd_tab = np.arctan2(omega_eff_dkd_tab * q_dkd_tab, p_dkd_tab)\n        error_dkd_tab = abs(wrap_angle(theta_dkd_tab - theta_ref))\n        results.append(error_dkd_tab)\n        \n        # KDK, tabulated\n        q_kdk_tab, p_kdk_tab = kdk_tabulated(h, t_end, q0, p0, omega0, a_ref_func_interp)\n        omega_eff_kdk_tab = omega0 * a_ref_end**(-1.5)\n        theta_kdk_tab = np.arctan2(omega_eff_kdk_tab * q_kdk_tab, p_kdk_tab)\n        error_kdk_tab = abs(wrap_angle(theta_kdk_tab - theta_ref))\n        results.append(error_kdk_tab)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}