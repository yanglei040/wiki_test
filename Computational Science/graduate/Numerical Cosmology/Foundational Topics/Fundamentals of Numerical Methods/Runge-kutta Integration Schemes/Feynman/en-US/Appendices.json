{
    "hands_on_practices": [
        {
            "introduction": "The classical fourth-order Runge-Kutta (RK4) method is renowned for its balance of accuracy and efficiency. However, for long-duration cosmological simulations, even the small local errors of a high-order method can accumulate into significant systematic drift. This exercise uses the powerful technique of backward error analysis to derive the 'modified equation'—the differential equation that the RK4 scheme *exactly* solves—allowing you to precisely quantify the long-term bias in a key cosmological observable, the number of e-folds . Mastering this analysis provides deep insight into the systematic errors inherent in numerical integration.",
            "id": "3484645",
            "problem": "Consider a spatially flat Lambda Cold Dark Matter (ΛCDM) cosmology with scale factor $a(t)$ obeying the Friedmann equation in the form $\\dot{a}(t)=H(a)\\,a(t)$, where $H(a)=H_{0}\\sqrt{\\Omega_{m}a^{-3}+\\Omega_{\\Lambda}}$, $H_{0}>0$ is the present Hubble parameter, $\\Omega_{m}\\ge 0$ is the matter density parameter, and $\\Omega_{\\Lambda}\\ge 0$ is the cosmological constant density parameter. Let the e-fold variable be $N(t)=\\ln a(t)$, so that $\\dot{N}(t)=H(a(t))$. Consider advancing $a(t)$ in cosmic time $t$ using the classical fourth-order Runge-Kutta (RK4) method with a uniform step size $h>0$.\n\nFocus on a late-time interval of duration sufficient to accumulate $\\Delta N=10$ e-folds during which the cosmological constant dominates, in the sense that $\\Omega_{m}\\exp(-3N)\\ll \\Omega_{\\Lambda}$ throughout the interval. In this regime, take $H(a)\\approx H_{\\Lambda}$ with $H_{\\Lambda}=H_{0}\\sqrt{\\Omega_{\\Lambda}}$ constant, so the evolution is effectively $\\dot{a}=H_{\\Lambda}\\,a$.\n\nStarting from first principles, carry out a backward error analysis for the RK4 method applied to the scalar linear ordinary differential equation $\\dot{y}=\\lambda\\,y$ with constant $\\lambda$, and determine the leading nonvanishing correction term in the modified equation (the autonomous differential equation whose exact flow matches one RK4 step) up to order $h^{4}$. Specialize your result to $\\lambda=H_{\\Lambda}$, translate the modified equation into the drift in $N(t)=\\ln a(t)$, and use it to obtain the leading-order long-time bias in the accumulated e-folds over the interval where the true solution undergoes exactly $\\Delta N=10$ e-folds. Conclude with a closed-form expression for the leading-order bias $\\Delta N_{\\mathrm{bias}}=N_{\\mathrm{RK4}}-10$ as a function of $h$, $H_{0}$, and $\\Omega_{\\Lambda}$.\n\nExpress your final result as a single closed-form analytical expression in terms of $h$, $H_{0}$, and $\\Omega_{\\Lambda}$. Do not include units. No numerical rounding is required.",
            "solution": "The user wants to find the leading-order bias in the accumulated e-folds when numerically integrating the Friedmann equation in a cosmological constant-dominated regime using the RK4 method. This requires a backward error analysis.\n\n### Step 1: Problem Validation\n\nI will first extract the givens and validate the problem statement.\n\n**Givens:**\n1.  **Cosmology**: Spatially flat Lambda Cold Dark Matter (ΛCDM) model.\n2.  **Equation of Motion**: The scale factor $a(t)$ evolves according to the Friedmann equation $\\dot{a}(t)=H(a)\\,a(t)$.\n3.  **Hubble Parameter**: $H(a)=H_{0}\\sqrt{\\Omega_{m}a^{-3}+\\Omega_{\\Lambda}}$, with parameters $H_{0}>0$, $\\Omega_{m}\\ge 0$, and $\\Omega_{\\Lambda}\\ge 0$. Since the cosmology is flat, $\\Omega_m + \\Omega_\\Lambda = 1$.\n4.  **E-fold Variable**: $N(t)=\\ln a(t)$, which implies $\\dot{N}(t)=H(a(t))$.\n5.  **Numerical Method**: Classical fourth-order Runge-Kutta (RK4) with uniform step size $h>0$.\n6.  **Physical Regime**: Late-time evolution where the cosmological constant dominates, i.e., $\\Omega_{m}\\exp(-3N)\\ll \\Omega_{\\Lambda}$.\n7.  **Approximation**: In this regime, the Hubble parameter is approximated as constant, $H(a)\\approx H_{\\Lambda}$, where $H_{\\Lambda}=H_{0}\\sqrt{\\Omega_{\\Lambda}}$.\n8.  **Effective ODE**: The evolution of the scale factor is described by the linear ordinary differential equation (ODE) $\\dot{a}=H_{\\Lambda}\\,a$.\n9.  **Task 1**: Perform a backward error analysis for the generic scalar linear ODE $\\dot{y}=\\lambda\\,y$ with constant $\\lambda$.\n10. **Task 2**: Determine the leading nonvanishing correction term in the modified equation up to order $h^{4}$.\n11. **Task 3**: Specialize the result to the cosmological case by setting $\\lambda=H_{\\Lambda}$.\n12. **Task 4**: Translate the modified equation for $a(t)$ into a modified evolution equation for $N(t)$.\n13. **Task 5**: Calculate the leading-order long-time bias $\\Delta N_{\\mathrm{bias}}=N_{\\mathrm{RK4}}-10$ over an interval where the true solution accumulates exactly $\\Delta N=10$ e-folds.\n14. **Final Result**: The bias should be a closed-form expression in terms of $h$, $H_{0}$, and $\\Omega_{\\Lambda}$.\n\n**Validation Verdict:**\nThe problem is scientifically grounded, being based on the standard ΛCDM model and standard numerical analysis techniques (backward error analysis of RK4). The approximation of a constant Hubble parameter in the late, $\\Omega_\\Lambda$-dominated universe is a standard and valid simplification. The problem is well-posed, with a clear objective and a structured path to the solution. The language is precise and objective. All necessary information is provided, and there are no internal contradictions. The problem is a valid theoretical exercise in numerical cosmology. Therefore, I will proceed with the solution.\n\n### Step 2: Backward Error Analysis of RK4 for $\\dot{y} = \\lambda y$\n\nThe problem requires a backward error analysis starting from first principles for the ODE $\\dot{y}=\\lambda y$. A single step of the classical RK4 method from $y_n = y(t_n)$ to $y_{n+1} = y(t_n+h)$ is given by\n$$y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$\nwhere the stages $k_i$ for the function $f(y)=\\lambda y$ are:\n$$k_1 = f(y_n) = \\lambda y_n$$\n$$k_2 = f(y_n + \\frac{h}{2}k_1) = \\lambda(y_n + \\frac{h}{2}\\lambda y_n) = \\lambda y_n (1 + \\frac{h\\lambda}{2})$$\n$$k_3 = f(y_n + \\frac{h}{2}k_2) = \\lambda(y_n + \\frac{h}{2}\\lambda y_n(1 + \\frac{h\\lambda}{2})) = \\lambda y_n (1 + \\frac{h\\lambda}{2} + \\frac{h^2\\lambda^2}{4})$$\n$$k_4 = f(y_n + hk_3) = \\lambda(y_n + h\\lambda y_n(1 + \\frac{h\\lambda}{2} + \\frac{h^2\\lambda^2}{4})) = \\lambda y_n (1 + h\\lambda + \\frac{h^2\\lambda^2}{2} + \\frac{h^3\\lambda^3}{4})$$\nSubstituting these into the RK4 formula:\n$$y_{n+1} = y_n + \\frac{h\\lambda y_n}{6} \\left[ 1 + 2(1+\\frac{h\\lambda}{2}) + 2(1+\\frac{h\\lambda}{2}+\\frac{h^2\\lambda^2}{4}) + (1+h\\lambda+\\frac{h^2\\lambda^2}{2}+\\frac{h^3\\lambda^3}{4}) \\right]$$\nCombining terms by powers of $h\\lambda$:\n$$y_{n+1} = y_n + \\frac{h\\lambda y_n}{6} \\left[ (1+2+2+1) + (1+1+1)h\\lambda + (\\frac{1}{2}+\\frac{1}{2})h^2\\lambda^2 + \\frac{1}{4}h^3\\lambda^3 \\right]$$\n$$y_{n+1} = y_n + \\frac{h\\lambda y_n}{6} \\left[ 6 + 3h\\lambda + h^2\\lambda^2 + \\frac{1}{4}h^3\\lambda^3 \\right]$$\n$$y_{n+1} = y_n + \\left( h\\lambda + \\frac{(h\\lambda)^2}{2} + \\frac{(h\\lambda)^3}{6} + \\frac{(h\\lambda)^4}{24} \\right) y_n$$\nSo, the one-step update is $y_{n+1} = R(h\\lambda) y_n$, where $R(z)$ is the stability function of the RK4 method:\n$$R(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}$$\nThis expression is the Taylor series of $\\exp(z)$ truncated at the $z^4$ term.\n\nBackward error analysis seeks a modified differential equation, $\\dot{\\tilde{y}} = \\tilde{f}(\\tilde{y})$, whose exact solution after one step $h$ coincides with the numerical solution. For our linear problem, we assume a modified equation of the form $\\dot{\\tilde{y}} = \\tilde{\\lambda}\\tilde{y}$. The exact solution to this equation is $\\tilde{y}(t+h) = \\exp(h\\tilde{\\lambda})\\tilde{y}(t)$.\nEquating the exact flow of the modified equation with the numerical one-step map, we get:\n$$\\exp(h\\tilde{\\lambda}) = R(h\\lambda) = 1 + h\\lambda + \\frac{(h\\lambda)^2}{2} + \\frac{(h\\lambda)^3}{6} + \\frac{(h\\lambda)^4}{24}$$\nTo find $\\tilde{\\lambda}$, we take the natural logarithm of both sides:\n$$h\\tilde{\\lambda} = \\ln\\left(1 + h\\lambda + \\frac{(h\\lambda)^2}{2} + \\frac{(h\\lambda)^3}{6} + \\frac{(h\\lambda)^4}{24}\\right)$$\nThe expression inside the logarithm can be related to $\\exp(h\\lambda)$:\n$$\\exp(h\\lambda) = 1 + h\\lambda + \\frac{(h\\lambda)^2}{2} + \\frac{(h\\lambda)^3}{6} + \\frac{(h\\lambda)^4}{24} + \\frac{(h\\lambda)^5}{120} + \\mathcal{O}(h^6)$$\nSo, $R(h\\lambda) = \\exp(h\\lambda) - \\frac{(h\\lambda)^5}{120} + \\mathcal{O}(h^6)$.\nSubstituting this into the equation for $h\\tilde{\\lambda}$:\n$$h\\tilde{\\lambda} = \\ln\\left(\\exp(h\\lambda) - \\frac{(h\\lambda)^5}{120} + \\mathcal{O}(h^6)\\right) = \\ln\\left(\\exp(h\\lambda)\\left[1 - \\exp(-h\\lambda)\\frac{(h\\lambda)^5}{120} + \\mathcal{O}(h^6)\\right]\\right)$$\n$$h\\tilde{\\lambda} = h\\lambda + \\ln\\left(1 - \\exp(-h\\lambda)\\frac{(h\\lambda)^5}{120} + \\mathcal{O}(h^6)\\right)$$\nUsing the Taylor series $\\ln(1-u) = -u - \\frac{u^2}{2} - \\dots$, and keeping only the leading term in $h$:\n$$h\\tilde{\\lambda} \\approx h\\lambda - \\exp(-h\\lambda)\\frac{(h\\lambda)^5}{120}$$\nFor the leading order correction, we can approximate $\\exp(-h\\lambda) \\approx 1$.\n$$h\\tilde{\\lambda} \\approx h\\lambda - \\frac{(h\\lambda)^5}{120}$$\nDividing by $h$, we find the modified rate $\\tilde{\\lambda}$:\n$$\\tilde{\\lambda} = \\lambda - \\frac{\\lambda^5 h^4}{120} + \\mathcal{O}(h^5)$$\nThe modified equation is therefore:\n$$\\dot{\\tilde{y}} = \\left(\\lambda - \\frac{\\lambda^5 h^4}{120}\\right)\\tilde{y}$$\nThe leading nonvanishing correction term in the modified equation is $-\\frac{\\lambda^5 h^4}{120}\\tilde{y}$. This is of order $h^4$, as expected for a fourth-order method.\n\n### Step 3: Application to the Cosmological Problem\n\nIn the $\\Omega_\\Lambda$-dominated regime, the equation for the scale factor is $\\dot{a} = H_\\Lambda a$. This matches the form $\\dot{y} = \\lambda y$ with the identifications $y \\to a$ and $\\lambda \\to H_\\Lambda = H_0\\sqrt{\\Omega_\\Lambda}$.\nThe modified equation for the scale factor, denoted $a_{\\text{mod}}$, is:\n$$\\dot{a}_{\\text{mod}} = \\left(H_\\Lambda - \\frac{H_\\Lambda^5 h^4}{120}\\right)a_{\\text{mod}}$$\nThe numerical solution $a_{\\text{RK4}}$ is shadowed by $a_{\\text{mod}}$.\n\n### Step 4: bias in Accumulated E-folds\n\nThe number of e-folds is $N(t) = \\ln a(t)$. The rate of change of e-folds is $\\dot{N}(t) = \\dot{a}(t)/a(t)$.\nFor the true solution, the rate is constant:\n$$\\dot{N}_{\\text{true}} = \\frac{\\dot{a}}{a} = H_\\Lambda$$\nFor the numerical solution, as described by the modified equation, the effective rate is also constant:\n$$\\dot{N}_{\\text{RK4}} = \\frac{\\dot{a}_{\\text{mod}}}{a_{\\text{mod}}} = H_\\Lambda - \\frac{H_\\Lambda^5 h^4}{120}$$\nThe problem considers an interval of cosmic time, $T=t_f-t_i$, over which the true solution accumulates exactly $\\Delta N = 10$ e-folds. This defines the duration of the integration:\n$$\\Delta N_{\\text{true}} = \\int_{t_i}^{t_f} \\dot{N}_{\\text{true}} dt = H_\\Lambda T = 10$$\n$$T = \\frac{10}{H_\\Lambda}$$\nOver this same time interval $T$, the accumulated e-folds for the numerical solution are:\n$$\\Delta N_{\\text{RK4}} = \\int_{t_i}^{t_f} \\dot{N}_{\\text{RK4}} dt = \\left(H_\\Lambda - \\frac{H_\\Lambda^5 h^4}{120}\\right)T$$\nSubstituting $T = 10/H_\\Lambda$:\n$$\\Delta N_{\\text{RK4}} = \\left(H_\\Lambda - \\frac{H_\\Lambda^5 h^4}{120}\\right)\\frac{10}{H_\\Lambda} = 10\\left(1 - \\frac{H_\\Lambda^4 h^4}{120}\\right) = 10 - \\frac{10 H_\\Lambda^4 h^4}{120} = 10 - \\frac{H_\\Lambda^4 h^4}{12}$$\nThe leading-order bias is defined as $\\Delta N_{\\text{bias}} = \\Delta N_{\\text{RK4}} - 10$.\n$$\\Delta N_{\\text{bias}} = \\left(10 - \\frac{H_\\Lambda^4 h^4}{12}\\right) - 10 = -\\frac{H_\\Lambda^4 h^4}{12}$$\n\n### Step 5: Final Expression\n\nThe final step is to express the bias in terms of the given parameters $h$, $H_0$, and $\\Omega_\\Lambda$. We substitute $H_\\Lambda = H_0 \\sqrt{\\Omega_\\Lambda}$:\n$$H_\\Lambda^4 = \\left(H_0 \\sqrt{\\Omega_\\Lambda}\\right)^4 = H_0^4 (\\Omega_\\Lambda^{1/2})^4 = H_0^4 \\Omega_\\Lambda^2$$\nSubstituting this into the expression for the bias:\n$$\\Delta N_{\\text{bias}} = -\\frac{(H_0^4 \\Omega_\\Lambda^2) h^4}{12} = -\\frac{H_0^4 \\Omega_\\Lambda^2 h^4}{12}$$\nThis is the final closed-form expression for the leading-order bias. The negative sign indicates that the RK4 method, in this application, tends to systematically underestimate the number of e-folds over a fixed time interval compared to the true solution's rate of expansion.\nThe analysis confirms that the RK4 method exhibits a leading-order bias of order $h^4$, consistent with its status as a fourth-order accurate integrator.",
            "answer": "$$\\boxed{-\\frac{H_0^4 \\Omega_\\Lambda^2 h^4}{12}}$$"
        },
        {
            "introduction": "While general-purpose Runge-Kutta methods are widely applicable, their performance can often be dramatically improved by tailoring them to the specific mathematical structure of the problem at hand. This practice challenges you to integrate the equations of motion for a relativistic particle in a de Sitter universe, a cornerstone scenario in inflationary cosmology. By comparing standard integrators against a custom-designed scheme that leverages an auxiliary variable transformation, you will discover how analytical insight can lead to a method that preserves the exact solution, a powerful demonstration of problem-specific scheme design .",
            "id": "3484668",
            "problem": "Consider a spatially flat Friedmann–Lemaître–Robertson–Walker spacetime written in conformal coordinates with line element $ds^2 = a(\\eta)^2 \\left(-d\\eta^2 + d\\mathbf{x}^2\\right)$, where $\\eta$ is the conformal time and $a(\\eta)$ is the scale factor. In de Sitter spacetime, the scale factor in conformal time is $a(\\eta) = -\\dfrac{1}{H \\eta}$ with constant Hubble parameter $H&gt;0$ and $\\eta &lt; 0$. Work in geometrized units with the speed of light set to $c=1$ so that all quantities are dimensionless in the code; do not print any units.\n\nA freely propagating relativistic particle of rest mass $m \\ge 0$ moving in one spatial dimension with comoving position $x(\\eta)$ has a conserved comoving momentum $q$ satisfying $q = a(\\eta) p_{\\mathrm{phys}}(\\eta)$, where $p_{\\mathrm{phys}}(\\eta)$ is the physical momentum. Using the relativistic energy–momentum relation, the equations of motion in conformal time can be cast as the first-order ordinary differential equation system\n$$\n\\frac{dx}{d\\eta} = \\frac{q}{\\sqrt{m^2 a(\\eta)^2 + q^2}}, \\qquad \\frac{dq}{d\\eta} = 0,\n$$\nwith initial data $x(\\eta_0) = x_0$ and $q(\\eta_0) = q_0 \\ne 0$, where $\\eta_0 &lt; 0$.\n\nYour task is to construct three Runge–Kutta integration schemes for this system and rigorously test exact-solution-preservation properties that arise specifically for $a(\\eta) = -\\dfrac{1}{H\\eta}$ via appropriate stage design:\n\n- Scheme A (Explicit Midpoint, second order): Apply the classical explicit midpoint Runge–Kutta method (also known as second-order Runge–Kutta) with step size $h &gt; 0$ to the system for $(x,q)$, treating $q$ as a dynamic variable governed by $\\dfrac{dq}{d\\eta} = 0$.\n\n- Scheme B (Classical Explicit Runge–Kutta of order four): Apply the standard four-stage method with Butcher weights $b = \\left[\\dfrac{1}{6}, \\dfrac{1}{3}, \\dfrac{1}{3}, \\dfrac{1}{6}\\right]$ and abscissae $c = [0, \\tfrac{1}{2}, \\tfrac{1}{2}, 1]$ to the system for $(x,q)$, with step size $h$.\n\n- Scheme C (Stage-designed exact-preserving Runge–Kutta via auxiliary variable): Introduce the auxiliary variable $y(\\eta) := q^2 \\eta^2 + \\mu^2$, where $\\mu := \\dfrac{m}{H}$. Observe that $y(\\eta)$ satisfies a scalar first-order ordinary differential equation that depends only on time, namely $\\dfrac{dy}{d\\eta} = 2 q^2 \\eta$. Construct a three-stage explicit Runge–Kutta method whose weights coincide with Simpson’s quadrature rule, that is, stage abscissae $c = [0, \\tfrac{1}{2}, 1]$ and weights $b = \\left[\\dfrac{1}{6}, \\dfrac{2}{3}, \\dfrac{1}{6}\\right]$, and apply it to $\\dfrac{dy}{d\\eta} = 2 q^2 \\eta$ so that the update of $y$ over one step is an exact quadrature for $y'$ because $y'$ is a polynomial of degree $1$ in $\\eta$. Then couple this with the exact algebraic relation\n$$\nx(\\eta) = x(\\eta_n) - \\frac{1}{q}\\left(\\sqrt{y(\\eta)} - \\sqrt{y(\\eta_n)}\\right)\n$$\nover each step from $\\eta_n$ to $\\eta_{n+1} = \\eta_n + h$, so that the method advances $x$ by\n$$\nx_{n+1} = x_n - \\frac{1}{q}\\left(\\sqrt{y_{n+1}} - \\sqrt{y_n}\\right),\n$$\nwith $q$ constant under all three schemes by virtue of $\\dfrac{dq}{d\\eta}=0$. This stage design should preserve the exact solution for $x(\\eta)$ for any step size $h$ (up to floating-point roundoff), specific to the de Sitter scale factor $a(\\eta)=-\\dfrac{1}{H\\eta}$.\n\nFrom the fundamental base consisting of the metric definition and conservation of comoving momentum in a homogeneous isotropic background, one can derive a closed-form exact solution $x(\\eta)$ for de Sitter spacetime. Use that exact solution to compute the absolute error at the final time for each scheme.\n\nImplement a single program that, for the following test suite, advances the solution from $\\eta=\\eta_0$ to $\\eta=\\eta_1$ (with $\\eta_0 &lt; \\eta_1 &lt; 0$; use positive $h$ and adapt the last step to land exactly on $\\eta_1$), and reports, for each test case, a list of three floating-point numbers equal to the absolute errors in $x(\\eta_1)$ produced by Scheme A, Scheme B, and Scheme C, respectively. The comoving momentum $q(\\eta)$ must be updated as a dynamic variable via $\\dfrac{dq}{d\\eta}=0$ inside each Runge–Kutta method (which should preserve it exactly). All computations are to be carried out in the dimensionless geometrized unit system; do not print any units.\n\nTest suite parameters, to be used verbatim:\n\n- Case 1 (happy path relativistic): $H = 1.0$, $m = 1.0$, $q_0 = 2.0$, $x_0 = 0.3$, $\\eta_0 = -1.0$, $\\eta_1 = -0.1$, $h = 0.05$.\n\n- Case 2 (ultra-relativistic and near $\\eta \\to 0^-$): $H = 1.0$, $m = 10^{-4}$, $q_0 = 1.0$, $x_0 = -0.2$, $\\eta_0 = -1.0$, $\\eta_1 = -10^{-2}$, $h = 0.01$.\n\n- Case 3 (non-relativistic heavy particle): $H = 0.5$, $m = 10.0$, $q_0 = 0.2$, $x_0 = 1.0$, $\\eta_0 = -2.0$, $\\eta_1 = -0.5$, $h = 0.1$.\n\n- Case 4 (massless with negative momentum): $H = 1.0$, $m = 0.0$, $q_0 = -3.0$, $x_0 = 0.0$, $\\eta_0 = -1.5$, $\\eta_1 = -0.5$, $h = 0.1$.\n\nFinal output format requirement: Your program should produce a single line of output containing the results as a comma-separated list of lists, each inner list holding the three errors for one test case, all enclosed in square brackets, for example, $[[e_{1A},e_{1B},e_{1C}],[e_{2A},e_{2B},e_{2C}],\\dots]$. Each $e_{ij}$ must be a floating-point number.",
            "solution": "The problem requires the construction and validation of three distinct Runge-Kutta integration schemes for solving the equations of motion of a relativistic particle in a de Sitter universe. The core of the task is to analyze their accuracy by comparing their results to a known exact analytical solution, with a particular focus on a custom-designed scheme (Scheme C) that is expected to be exact up to machine precision.\n\nFirst, the physical and mathematical validity of the model must be established. The spacetime is a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) model with the line element $ds^2 = a(\\eta)^2(-d\\eta^2 + d\\mathbf{x}^2)$. For a de Sitter universe, the scale factor is specified as $a(\\eta) = -1/(H\\eta)$, where $H > 0$ is the constant Hubble parameter and $\\eta < 0$ is the conformal time. The equations of motion for a particle of rest mass $m$ are given as a first-order system for its comoving position $x(\\eta)$ and conserved comoving momentum $q(\\eta)$:\n$$\n\\frac{dx}{d\\eta} = \\frac{q}{\\sqrt{m^2 a(\\eta)^2 + q^2}}, \\qquad \\frac{dq}{d\\eta} = 0\n$$\nThese equations are standard in cosmology. The first arises from the relation between comoving velocity $d\\mathbf{x}/d\\eta$ and the ratio of physical momentum to physical energy, $\\mathbf{p}_{\\text{phys}}/E_{\\text{phys}}$, combined with the relativistic energy-momentum relation $E_{\\text{phys}}^2 = p_{\\text{phys}}^2 + m^2$ (with $c=1$) and the redshift of momentum $p_{\\text{phys}} = q/a$. The second equation, $dq/d\\eta=0$, expresses the conservation of comoving momentum for a free particle in a homogeneous and isotropic background. The system is a well-posed initial value problem.\n\nTo quantify the error of the numerical schemes, we must first derive the exact analytical solution for $x(\\eta)$. Since $q$ is constant, we can directly integrate the equation for $x$. Substituting the de Sitter scale factor $a(\\eta) = -1/(H\\eta)$ into the ODE for $x$ yields:\n$$\n\\frac{dx}{d\\eta} = \\frac{q}{\\sqrt{q^2 + m^2 / (H^2 \\eta^2)}} = \\frac{q}{\\sqrt{(q^2 \\eta^2 + m^2/H^2)/\\eta^2}}\n$$\nGiven that $\\eta < 0$, we have $\\sqrt{\\eta^2} = -\\eta$. The expression simplifies to:\n$$\n\\frac{dx}{d\\eta} = \\frac{-q\\eta}{\\sqrt{q^2 \\eta^2 + (m/H)^2}}\n$$\nIntegrating this equation from an initial time $\\eta_0$ with position $x_0 = x(\\eta_0)$ to a later time $\\eta$ gives the change in position:\n$$\nx(\\eta) - x(\\eta_0) = \\int_{\\eta_0}^{\\eta} \\frac{-q\\eta'}{\\sqrt{q^2 (\\eta')^2 + (m/H)^2}} d\\eta'\n$$\nThis integral can be solved exactly, for instance, with the substitution $u = q^2 (\\eta')^2 + (m/H)^2$, which leads to $du = 2q^2 \\eta' d\\eta'$. The result of the definite integral is:\n$$\nx(\\eta) - x(\\eta_0) = \\left[ -\\frac{1}{q} \\sqrt{q^2 (\\eta')^2 + (m/H)^2} \\right]_{\\eta_0}^{\\eta}\n$$\nThis provides the exact solution for the comoving position at any time $\\eta$:\n$$\nx(\\eta) = x(\\eta_0) - \\frac{1}{q} \\left( \\sqrt{q^2 \\eta^2 + (m/H)^2} - \\sqrt{q^2 \\eta_0^2 + (m/H)^2} \\right)\n$$\nThis formula will be used as the ground truth to compute the absolute error $|x_{\\text{numerical}}(\\eta_1) - x_{\\text{exact}}(\\eta_1)|$ for each scheme at the final time $\\eta_1$.\n\nThe numerical integration proceeds from $\\eta_0$ to $\\eta_1 > \\eta_0$ with a base step size $h > 0$. To land precisely on $\\eta_1$, the final step size is adapted to $h_{\\text{final}} = \\eta_1 - \\eta_{\\text{current}}$. We define the state vector as $\\mathbf{S} = [x, q]^T$ and the right-hand side of the ODE system as $\\mathbf{F}(\\mathbf{S}, \\eta)$. Since $dq/d\\eta = 0$, the $q$ component of $\\mathbf{S}$ will remain constant for any valid numerical integrator.\n\nScheme A is the explicit midpoint method, a second-order Runge-Kutta scheme. A single step from $\\eta_n$ to $\\eta_{n+1} = \\eta_n + h$ is computed as:\n$$\n\\mathbf{k}_1 = \\mathbf{F}(\\mathbf{S}_n, \\eta_n) \\\\\n\\mathbf{k}_2 = \\mathbf{F}(\\mathbf{S}_n + \\frac{h}{2}\\mathbf{k}_1, \\eta_n + \\frac{h}{2}) \\\\\n\\mathbf{S}_{n+1} = \\mathbf{S}_n + h \\mathbf{k}_2\n$$\n\nScheme B is the classical fourth-order explicit Runge-Kutta method. Its update rule for a single step is:\n$$\n\\mathbf{k}_1 = \\mathbf{F}(\\mathbf{S}_n, \\eta_n) \\\\\n\\mathbf{k}_2 = \\mathbf{F}(\\mathbf{S}_n + \\frac{h}{2}\\mathbf{k}_1, \\eta_n + \\frac{h}{2}) \\\\\n\\mathbf{k}_3 = \\mathbf{F}(\\mathbf{S}_n + \\frac{h}{2}\\mathbf{k}_2, \\eta_n + \\frac{h}{2}) \\\\\n\\mathbf{k}_4 = \\mathbf{F}(\\mathbf{S}_n + h\\mathbf{k}_3, \\eta_n + h) \\\\\n\\mathbf{S}_{n+1} = \\mathbf{S}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n\nScheme C is a specialized method designed to leverage the problem's structure. It introduces an auxiliary variable $y(\\eta) := q^2 \\eta^2 + \\mu^2$, where $\\mu := m/H$. Differentiating $y(\\eta)$ with respect to $\\eta$ yields a much simpler ODE that depends only on time:\n$$\n\\frac{dy}{d\\eta} = 2q^2\\eta\n$$\nThe scheme integrates this equation using a $3$-stage explicit Runge-Kutta method whose Butcher weights $b = [1/6, 2/3, 1/6]$ and abscissae $c = [0, 1/2, 1]$ correspond to Simpson's quadrature rule. For an ODE of the form $y' = f(\\eta)$, an RK step is equivalent to a quadrature evaluation: $y_{n+1} = y_n + h \\sum_i b_i f(\\eta_n + c_i h)$. Simpson's rule is known to be exact for polynomials of degree up to $3$. Since the right-hand side $2q^2\\eta$ is a polynomial of degree $1$ in $\\eta$, this numerical quadrature is exact. Consequently, the value $y_{n+1}$ computed by the scheme is precisely $y(\\eta_{n+1})$, up to floating-point error. The update for $x$ is then performed using an exact algebraic relation derived from the analytical solution:\n$$\nx_{n+1} = x_n - \\frac{1}{q}\\left(\\sqrt{y_{n+1}} - \\sqrt{y_n}\\right)\n$$\nSince both the update for $y(\\eta)$ and the subsequent calculation of $x(\\eta)$ are exact, Scheme C is expected to preserve the exact solution for any step size $h$, with errors only arising from floating-point arithmetic.\n\nThe final implementation calculates the absolute error for each scheme across the provided test suite and formats the output as a list of lists.",
            "answer": "```python\nimport numpy as np\n\ndef get_ode_rhs_func(H, m):\n    \"\"\"\n    Returns the function F(state, eta) for the ODE system d(x,q)/d(eta).\n    \"\"\"\n    def F(state, eta):\n        _x, q = state\n        # The problem statement ensures eta < 0, so eta != 0.\n        a_sq = 1.0 / (H**2 * eta**2)\n        denominator = np.sqrt(m**2 * a_sq + q**2)\n        \n        # Handle the case where the denominator might be zero if q=0 and m=0.\n        # Problem statement says q0 != 0, so q is never 0.\n        dxdeta = q / denominator\n        dqdeta = 0.0\n        \n        return np.array([dxdeta, dqdeta])\n    return F\n\ndef solve_scheme_A(params):\n    \"\"\"\n    Solves the ODE system using Scheme A (Explicit Midpoint / RK2).\n    \"\"\"\n    H, m, q0, x0, eta0, eta1, h = params\n    \n    F = get_ode_rhs_func(H, m)\n    \n    state = np.array([x0, q0], dtype=np.float64)\n    eta = eta0\n    \n    while not np.isclose(eta, eta1):\n        h_step = min(h, eta1 - eta)\n        if h_step < 1e-15:  # Avoid negligible steps due to floating point arithmetic\n            break\n\n        k1 = F(state, eta)\n        mid_state = state + 0.5 * h_step * k1\n        mid_eta = eta + 0.5 * h_step\n        \n        k2 = F(mid_state, mid_eta)\n        \n        state = state + h_step * k2\n        eta += h_step\n        \n    return state[0]\n\ndef solve_scheme_B(params):\n    \"\"\"\n    Solves the ODE system using Scheme B (Classical RK4).\n    \"\"\"\n    H, m, q0, x0, eta0, eta1, h = params\n\n    F = get_ode_rhs_func(H, m)\n    \n    state = np.array([x0, q0], dtype=np.float64)\n    eta = eta0\n    \n    while not np.isclose(eta, eta1):\n        h_step = min(h, eta1 - eta)\n        if h_step < 1e-15:\n            break\n            \n        k1 = F(state, eta)\n        k2 = F(state + 0.5 * h_step * k1, eta + 0.5 * h_step)\n        k3 = F(state + 0.5 * h_step * k2, eta + 0.5 * h_step)\n        k4 = F(state + h_step * k3, eta + h_step)\n        \n        state = state + (h_step / 6.0) * (k1 + 2.0*k2 + 2.0*k3 + k4)\n        eta += h_step\n        \n    return state[0]\n\ndef solve_scheme_C(params):\n    \"\"\"\n    Solves the ODE system using Scheme C (Exact-preserving method).\n    \"\"\"\n    H, m, q0, x0, eta0, eta1, h = params\n    \n    q = q0\n    mu_sq = (m / H)**2\n    \n    # State is (x, y) where y = q^2*eta^2 + mu^2\n    y = mu_sq + q**2 * eta0**2\n    x = x0\n    eta = eta0\n\n    def F_y(eta_val, q_val):\n        return 2.0 * q_val**2 * eta_val\n\n    while not np.isclose(eta, eta1):\n        h_step = min(h, eta1 - eta)\n        if h_step < 1e-15:\n            break\n        \n        # Simpson's rule RK method for y(eta)\n        k1_y = F_y(eta, q)\n        k2_y = F_y(eta + 0.5 * h_step, q)\n        k3_y = F_y(eta + h_step, q)\n        \n        # Weights are b = [1/6, 2/3, 1/6]. Note 2/3 = 4/6.\n        y_next = y + (h_step / 6.0) * (k1_y + 4.0 * k2_y + k3_y)\n        \n        # Exact algebraic update for x\n        x_next = x - (1.0 / q) * (np.sqrt(y_next) - np.sqrt(y))\n        \n        x = x_next\n        y = y_next\n        eta += h_step\n        \n    return x\n\ndef get_exact_x(params, final_eta):\n    \"\"\"\n    Calculates the exact solution for x at a given final time.\n    \"\"\"\n    H, m, q0, x0, eta0, _, _ = params\n    \n    mu_sq = (m / H)**2\n    \n    y_final = mu_sq + q0**2 * final_eta**2\n    y_initial = mu_sq + q0**2 * eta0**2\n    \n    delta_x = - (1.0 / q0) * (np.sqrt(y_final) - np.sqrt(y_initial))\n    \n    return x0 + delta_x\n\ndef solve():\n    test_cases = [\n        # (H,     m,    q0,   x0,   eta0,  eta1,     h)\n        (1.0,   1.0,   2.0,  0.3, -1.0, -0.1,    0.05),\n        (1.0, 1e-4,  1.0, -0.2, -1.0, -1e-2,   0.01),\n        (0.5,  10.0,  0.2,  1.0, -2.0, -0.5,    0.1),\n        (1.0,   0.0,  -3.0,  0.0, -1.5, -0.5,    0.1),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        _, _, _, _, _, eta1, _ = case\n        \n        x_exact_final = get_exact_x(case, eta1)\n        \n        x_final_A = solve_scheme_A(case)\n        x_final_B = solve_scheme_B(case)\n        x_final_C = solve_scheme_C(case)\n        \n        error_A = abs(x_final_A - x_exact_final)\n        error_B = abs(x_final_B - x_exact_final)\n        error_C = abs(x_final_C - x_exact_final)\n        \n        all_results.append([error_A, error_B, error_C])\n        \n    inner_formatted_results = []\n    for res_list in all_results:\n        inner_str = f\"[{','.join(str(err) for err in res_list)}]\"\n        inner_formatted_results.append(inner_str)\n    \n    final_output_string = f\"[{','.join(inner_formatted_results)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Many physical systems, particularly in General Relativity, are described by a system of differential equations coupled with algebraic constraints that must be satisfied at all times. Standard numerical integrators often cause the solution to drift away from this 'constraint manifold,' yielding unphysical results. This hands-on practice addresses this critical issue by exploring methods to enforce the Friedmann constraint, $H^2 = \\frac{8\\pi G}{3}\\rho$, when integrating the cosmological evolution equations . You will implement and compare both post-step projection and the more sophisticated stage-constrained RK method, gaining essential skills for building robust and physically consistent numerical simulations.",
            "id": "3484652",
            "problem": "Consider a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) cosmological model evolving under General Relativity (GR), with a perfect fluid of constant equation of state parameter $w$, defined by the relation $p = w \\rho$ between the pressure $p$ and energy density $\\rho$. The Hubble parameter $H$ is defined by $H = \\dot{a}/a$, where $a$ is the cosmological scale factor. In this context, the dynamical evolution is governed by two ordinary differential equations derived from the Einstein field equations specialized to FLRW symmetry and conservation of stress-energy:\n- The Raychaudhuri equation: $\\dot{H} = -4 \\pi G \\left( \\rho + p \\right)$.\n- The continuity equation: $\\dot{\\rho} = -3 H \\left( \\rho + p \\right)$.\nFor a constant equation of state parameter $w$, these reduce to:\n$\\dot{H} = -4 \\pi G (1+w) \\rho$ and $\\dot{\\rho} = -3 (1+w) H \\rho$.\nThese equations imply the Friedmann constraint for spatial flatness and vanishing cosmological constant:\n$H^2 = \\dfrac{8\\pi G}{3} \\rho$,\nwhich we denote by the holonomic constraint $g(H,\\rho) = H^2 - \\alpha \\rho = 0$ with $\\alpha := \\dfrac{8\\pi G}{3}$.\n\nThe numerical task is to design explicit Runge–Kutta (RK) time integration schemes that aim to preserve the constraint numerically over stepping from $t=0$ to a final time $t=T$, starting from initial data that satisfies the constraint. Two approaches should be implemented and compared:\n- A stage-constrained RK scheme that augments one component of the system via discrete Lagrange multipliers coupled to the RK stages to enforce that each stage respects the constraint in the sense of a vanishing stage-wise constraint derivative.\n- A post-step projection scheme that performs a standard RK step and then projects the result back onto the constraint manifold $g(H,\\rho)=0$ at the end of each step.\n\nStarting from the fundamental base consisting of the Raychaudhuri and continuity equations stated above, along with the Friedmann constraint $H^2 = \\dfrac{8\\pi G}{3} \\rho$, derive from first principles a discrete Lagrange multiplier enforcement strategy appropriate for explicit Runge–Kutta methods. Your design must ensure that, at each RK stage, the instantaneous constraint drift $d g / dt$ computed from the stage values is identically zero, by modifying only the $\\dot{\\rho}$ component with a stage-specific discrete Lagrange multiplier. Implement both the stage-constrained scheme and the post-step projection scheme using the classical $4$-stage, order-$4$ Runge–Kutta method, and compare their effectiveness in preserving the constraint.\n\nIn all computations, use units where the speed of light satisfies $c=1$. The gravitational constant $G$ should be treated as a positive constant and set numerically as specified in the test suite. The diagnostic to be reported is the maximum relative constraint residual over all step endpoints,\n$r = \\max_{n} \\dfrac{\\left| H_n^2 - \\alpha \\rho_n \\right|}{\\left| H_n^2 \\right| + \\left| \\alpha \\rho_n \\right|}$,\nwhich is dimensionless and therefore requires no physical units in the final answer. Here, $H_n$ and $\\rho_n$ are the numerical values at the end of step $n$, and $\\alpha = \\dfrac{8\\pi G}{3}$.\n\nYour program must implement both schemes and report, for each test case, a list of three floating-point numbers corresponding to:\n$[$maximum relative constraint residual for stage-constrained RK$, $maximum relative constraint residual for post-step projection RK$, $maximum relative constraint residual for plain RK without constraints$]$.\n\nTest suite:\n- Case A (happy path, dust fluid): $w=0$, $G=1$, $H_0=1$, $T=1$, $N=50$ steps.\n- Case B (radiation, coarser step): $w=1/3$, $G=1$, $H_0=1$, $T=1$, $N=20$ steps.\n- Case C (large initial expansion rate): $w=0$, $G=1$, $H_0=10$, $T=0.1$, $N=100$ steps.\n- Case D (near-boundary small expansion rate): $w=0$, $G=1$, $H_0=10^{-3}$, $T=1$, $N=100$ steps.\n\nIn all cases, initialize $\\rho_0$ from the constraint using $\\rho_0 = \\dfrac{H_0^2}{\\alpha}$, and integrate forward using the specified number of steps. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one sub-list per test case in the order A, B, C, D. For example, the output format should look like $[[x_A,y_A,z_A],[x_B,y_B,z_B],[x_C,y_C,z_C],[x_D,y_D,z_D]]$, where each $x,y,z$ is a floating-point number.",
            "solution": "The problem is valid. It is scientifically sound, self-contained, and well-posed, describing a standard numerical exercise in computational cosmology. We will proceed with the derivation and implementation of the specified numerical schemes.\n\nThe dynamical system under consideration describes the evolution of a flat FLRW universe with a perfect fluid. The state of the system is given by the vector $y(t) = [H(t), \\rho(t)]^T$, where $H$ is the Hubble parameter and $\\rho$ is the energy density. The evolution is governed by the following system of ordinary differential equations (ODEs):\n$$\n\\dot{H} = -4 \\pi G (1+w) \\rho =: f_H(H, \\rho)\n$$\n$$\n\\dot{\\rho} = -3 (1+w) H \\rho =: f_\\rho(H, \\rho)\n$$\nwhere $w$ is the constant equation of state parameter and $G$ is the gravitational constant.\n\nThis system of ODEs possesses a holonomic constraint, an algebraic relation that must be satisfied by the state variables at all times. This is the Friedmann equation for a flat universe:\n$$\ng(H, \\rho) = H^2 - \\alpha \\rho = 0\n$$\nwhere $\\alpha := \\dfrac{8\\pi G}{3}$. The analytical solution of the ODEs starting from an initial state $(H_0, \\rho_0)$ that satisfies $g(H_0, \\rho_0) = 0$ will satisfy $g(H(t), \\rho(t)) = 0$ for all subsequent times $t > 0$. This can be verified by computing the time derivative of the constraint:\n$$\n\\frac{dg}{dt} = \\frac{\\partial g}{\\partial H}\\dot{H} + \\frac{\\partial g}{\\partial \\rho}\\dot{\\rho} = (2H)f_H + (-\\alpha)f_\\rho\n$$\nSubstituting the expressions for $f_H$, $f_\\rho$, and $\\alpha$:\n$$\n\\frac{dg}{dt} = 2H(-4 \\pi G (1+w) \\rho) - \\left(\\frac{8\\pi G}{3}\\right)(-3 (1+w) H \\rho) = -8\\pi G (1+w) H \\rho + 8\\pi G (1+w) H \\rho = 0\n$$\nThis confirms that the constraint manifold $g=0$ is an invariant manifold of the flow. However, standard numerical integrators like the Runge-Kutta method introduce discretization errors at each step, causing the numerical solution to drift away from this manifold. The task is to implement and compare three schemes in their ability to manage this constraint violation. The base integrator for all schemes is the classical $4$-stage, $4^{th}$-order Runge-Kutta (RK4) method.\n\nLet $y_n = [H_n, \\rho_n]^T$ be the numerical solution at time $t_n$, which is assumed to satisfy the constraint, i.e., $g(y_n)=0$. A single step computes the solution $y_{n+1}$ at time $t_{n+1} = t_n + \\Delta t$.\n\n**1. Plain RK4 Scheme (Baseline)**\nThis is the standard, uncorrected application of the RK4 algorithm to the ODE system $\\dot{y} = f(y)$.\n$$\nk_1 = f(y_n) \\\\\nk_2 = f(y_n + \\frac{\\Delta t}{2} k_1) \\\\\nk_3 = f(y_n + \\frac{\\Delta t}{2} k_2) \\\\\nk_4 = f(y_n + \\Delta t k_3) \\\\\ny_{n+1} = y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n$$\nThe resulting state $y_{n+1}$ will generally not satisfy the constraint, i.e., $g(y_{n+1}) \\neq 0$. This scheme serves as a baseline to measure the constraint violation growth.\n\n**2. Post-Step Projection RK4 Scheme**\nThis method consists of two parts: an evolution step and a projection step.\nFirst, a provisional state $\\tilde{y}_{n+1}$ is computed using the plain RK4 step described above.\n$$\n\\tilde{y}_{n+1} = y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n$$\nThis provisional state $[\\tilde{H}_{n+1}, \\tilde{\\rho}_{n+1}]^T$ will not lie on the constraint manifold. Second, this state is projected back onto the manifold $g=0$ to obtain the final state $y_{n+1}$. We employ a simple and direct projection: we retain the computed value for the Hubble parameter, $\\tilde{H}_{n+1}$, and correct the density $\\rho$ to satisfy the constraint.\n$$\nH_{n+1} = \\tilde{H}_{n+1} \\\\\n\\rho_{n+1} = \\frac{H_{n+1}^2}{\\alpha}\n$$\nThis ensures that $g(y_{n+1}) = H_{n+1}^2 - \\alpha\\rho_{n+1} = 0$ by construction, up to machine floating-point precision.\n\n**3. Stage-Constrained RK4 Scheme**\nThis scheme modifies the dynamics within the RK stages to actively damp constraint violations. The problem specifies modifying only the $\\dot{\\rho}$ component of the RHS vector field $f=[f_H, f_\\rho]^T$ to ensure the stage-wise constraint derivative is zero.\n\nAt each RK stage $i$, we compute a state value $Y_i = [H^{(i)}, \\rho^{(i)}]^T$. The goal is to define a modified RHS, $\\tilde{f}^{(i)}$, such that the constraint derivative, evaluated using this modified RHS at the stage values, vanishes:\n$$\n\\left.\\frac{dg}{dt}\\right|_{\\text{stage }i} = \\nabla g(Y_i) \\cdot \\tilde{f}^{(i)}(Y_i) = 0\n$$\nThe RHS is modified by adding a stage-specific Lagrange multiplier $\\lambda_i$ only to the $\\rho$ component:\n$$\n\\tilde{f}^{(i)}(Y_i) = [f_H(Y_i), f_\\rho(Y_i) + \\lambda_i]^T\n$$\nThe condition becomes:\n$$\n\\frac{\\partial g}{\\partial H}(Y_i) \\cdot f_H(Y_i) + \\frac{\\partial g}{\\partial \\rho}(Y_i) \\cdot (f_\\rho(Y_i) + \\lambda_i) = 0\n$$\nSubstituting $\\frac{\\partial g}{\\partial H} = 2H$ and $\\frac{\\partial g}{\\partial \\rho} = -\\alpha$, we get:\n$$\n2H^{(i)} f_H(Y_i) - \\alpha (f_\\rho(Y_i) + \\lambda_i) = 0\n$$\nSolving for the Lagrange multiplier $\\lambda_i$:\n$$\n\\lambda_i = \\frac{2H^{(i)} f_H(Y_i) - \\alpha f_\\rho(Y_i)}{\\alpha}\n$$\nThe numerator is precisely the uncorrected constraint drift rate $\\nabla g(Y_i) \\cdot f(Y_i)$. The modified RHS for the $\\rho$ component is therefore $\\tilde{f}_\\rho(Y_i) = f_\\rho(Y_i) + \\lambda_i = \\frac{2H^{(i)}}{\\alpha} f_H(Y_i)$.\n\nThe RK4 algorithm is then modified as follows:\nLet $y_n = [H_n, \\rho_n]^T$ be the state at $t_n$.\n\n- **Stage 1**: The stage value is $Y_1 = y_n$. Since $y_n$ satisfies the constraint, the uncorrected drift $\\nabla g(y_n) \\cdot f(y_n) = 0$. Thus, $\\lambda_1 = 0$. The first slope is calculated with the original RHS:\n$k_1 = f(y_n)$.\n\n- **Stage 2**: The stage value is $Y_2 = y_n + \\frac{\\Delta t}{2} k_1$. In general, $g(Y_2) \\neq 0$. We compute the modified slope $k_2$:\n$H^{(2)}, \\rho^{(2)} = Y_2$\n$f_H(Y_2) = -4\\pi G(1+w)\\rho^{(2)}$\n$f_\\rho(Y_2) = -3(1+w)H^{(2)}\\rho^{(2)}$\n$\\lambda_2 = (2H^{(2)}f_H(Y_2) - \\alpha f_\\rho(Y_2)) / \\alpha$\n$k_2 = [f_H(Y_2), f_\\rho(Y_2) + \\lambda_2]^T$.\n\n- **Stage 3**: The stage value is $Y_3 = y_n + \\frac{\\Delta t}{2} k_2$. We compute the modified slope $k_3$ using the same procedure:\n$Y_3 = [H^{(3)}, \\rho^{(3)}]^T$\n$\\lambda_3 = (2H^{(3)}f_H(Y_3) - \\alpha f_\\rho(Y_3)) / \\alpha$\n$k_3 = [f_H(Y_3), f_\\rho(Y_3) + \\lambda_3]^T$.\n\n- **Stage 4**: The stage value is $Y_4 = y_n + \\Delta t k_3$. We compute the modified slope $k_4$:\n$Y_4 = [H^{(4)}, \\rho^{(4)}]^T$\n$\\lambda_4 = (2H^{(4)}f_H(Y_4) - \\alpha f_\\rho(Y_4)) / \\alpha$\n$k_4 = [f_H(Y_4), f_\\rho(Y_4) + \\lambda_4]^T$.\n\n- **Final update**: The new state is assembled from the computed slopes:\n$y_{n+1} = y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)$.\n\nThis scheme does not guarantee $g(y_{n+1}) = 0$ exactly, but it is constructed to reduce the growth of the constraint violation compared to the plain RK4 method. The performance of all three schemes is evaluated by computing the maximum relative constraint residual over the entire integration period for the given test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path, dust fluid)\n        {'w': 0.0, 'G': 1.0, 'H0': 1.0, 'T': 1.0, 'N': 50},\n        # Case B (radiation, coarser step)\n        {'w': 1.0/3.0, 'G': 1.0, 'H0': 1.0, 'T': 1.0, 'N': 20},\n        # Case C (large initial expansion rate)\n        {'w': 0.0, 'G': 1.0, 'H0': 10.0, 'T': 0.1, 'N': 100},\n        # Case D (near-boundary small expansion rate)\n        {'w': 0.0, 'G': 1.0, 'H0': 1e-3, 'T': 1.0, 'N': 100},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        results = run_case(params)\n        all_results.append(results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef run_case(params):\n    \"\"\"\n    Runs the simulation for a single test case using all three schemes.\n    \n    Args:\n        params (dict): A dictionary containing the parameters for the case.\n        \n    Returns:\n        list: A list of three floats corresponding to the max relative constraint\n              residuals for stage-constrained, projection, and plain RK schemes.\n    \"\"\"\n    w = params['w']\n    G = params['G']\n    H0 = params['H0']\n    T = params['T']\n    N = params['N']\n\n    alpha = 8.0 * np.pi * G / 3.0\n    rho0 = H0**2 / alpha\n    dt = T / N\n\n    y_plain = np.array([H0, rho0], dtype=np.float64)\n    y_proj = np.array([H0, rho0], dtype=np.float64)\n    y_stage = np.array([H0, rho0], dtype=np.float64)\n\n    max_res_plain = 0.0\n    max_res_proj = 0.0\n    max_res_stage = 0.0\n\n    # RHS of the ODE system\n    def rhs(y, w_val, G_val):\n        H, rho = y\n        H_dot = -4.0 * np.pi * G_val * (1.0 + w_val) * rho\n        rho_dot = -3.0 * (1.0 + w_val) * H * rho\n        return np.array([H_dot, rho_dot], dtype=np.float64)\n\n    # Plain RK4 step\n    def rk4_step_plain(y_n, w_val, G_val, dt_val):\n        k1 = rhs(y_n, w_val, G_val)\n        k2 = rhs(y_n + dt_val / 2.0 * k1, w_val, G_val)\n        k3 = rhs(y_n + dt_val / 2.0 * k2, w_val, G_val)\n        k4 = rhs(y_n + dt_val * k3, w_val, G_val)\n        return y_n + dt_val / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    # Post-step projection RK4 step\n    def rk4_step_projection(y_n, w_val, G_val, dt_val, alpha_val):\n        y_tilde = rk4_step_plain(y_n, w_val, G_val, dt_val)\n        H_next = y_tilde[0]\n        rho_next = H_next**2 / alpha_val\n        return np.array([H_next, rho_next], dtype=np.float64)\n\n    # Stage-constrained RK4 step\n    def rk4_step_stage_constrained(y_n, w_val, G_val, dt_val, alpha_val):\n        \n        def modified_rhs_at_stage(y_stage, w_v, G_v, a_v):\n            H, rho = y_stage\n            fH = -4.0 * np.pi * G_v * (1.0 + w_v) * rho\n            frho = -3.0 * (1.0 + w_v) * H * rho\n            # Constraint derivative with unmodified RHS\n            dgdt_unmod = 2.0 * H * fH - a_v * frho\n            # Lagrange multiplier correction\n            lambda_correction = dgdt_unmod / a_v\n            return np.array([fH, frho + lambda_correction], dtype=np.float64)\n\n        # Stage 1: Correction is zero as y_n is on the constraint manifold\n        k1 = rhs(y_n, w_val, G_val)\n        \n        # Stage 2\n        y2 = y_n + dt_val / 2.0 * k1\n        k2 = modified_rhs_at_stage(y2, w_val, G_val, alpha_val)\n\n        # Stage 3\n        y3 = y_n + dt_val / 2.0 * k2\n        k3 = modified_rhs_at_stage(y3, w_val, G_val, alpha_val)\n\n        # Stage 4\n        y4 = y_n + dt_val * k3\n        k4 = modified_rhs_at_stage(y4, w_val, G_val, alpha_val)\n        \n        return y_n + dt_val / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    for _ in range(N):\n        y_plain = rk4_step_plain(y_plain, w, G, dt)\n        y_proj = rk4_step_projection(y_proj, w, G, dt, alpha)\n        y_stage = rk4_step_stage_constrained(y_stage, w, G, dt, alpha)\n\n        for scheme_idx, y_current in enumerate([y_stage, y_proj, y_plain]):\n            H_n, rho_n = y_current\n            numerator = abs(H_n**2 - alpha * rho_n)\n            denominator = abs(H_n**2) + abs(alpha * rho_n)\n            \n            if denominator == 0.0:\n                residual = 0.0\n            else:\n                residual = numerator / denominator\n\n            if scheme_idx == 0:\n                max_res_stage = max(max_res_stage, residual)\n            elif scheme_idx == 1:\n                max_res_proj = max(max_res_proj, residual)\n            else:\n                max_res_plain = max(max_res_plain, residual)\n\n    return [max_res_stage, max_res_proj, max_res_plain]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}