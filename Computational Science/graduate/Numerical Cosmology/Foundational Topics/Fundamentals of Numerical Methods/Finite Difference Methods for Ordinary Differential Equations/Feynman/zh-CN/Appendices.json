{
    "hands_on_practices": [
        {
            "introduction": "在数值工作中，一个至关重要的步骤是验证所实现的代码是否达到了其理论精度阶。本练习将指导您构建一个“测试工具”，用于测量应用于简化版 Friedmann 方程的常见方法的观测收敛阶。这不仅能帮助您建立对代码实现的信心，还能培养必要的验证技能。",
            "id": "3471890",
            "problem": "你需要构建一个完整、可运行的程序，该程序实现一个测试工具，用于测量有限差分时间积分方法在网格加密下求解一个源于宇宙学的常微分方程时所观测到的精度阶。从一个空间平坦、物质主导的爱因斯坦-德西特宇宙的弗里德曼方程开始，该方程得出的标度因子 $a(t)$ 满足 $H(a) = H_0 a^{-3/2}$，并且在宇宙时 $t$ 下，满足 $da/dt = a H(a)$。引入无量纲时间 $\\tau = H_0 t$，使演化方程简化为\n$$\n\\frac{da}{d\\tau} = a^{-1/2}。\n$$\n该方程有精确解\n$$\na(\\tau) = \\left(\\frac{2}{3}\\,\\tau\\right)^{2/3}，\n$$\n该解可通过分离变量法得到，其中大爆炸发生在 $\\tau = 0$。为避免 $\\tau = 0$ 处的奇点，从一个严格为正的起始时间 $\\tau_0  0$ 开始积分，其初始条件 $a(\\tau_0)$ 与精确解一致。\n\n你的程序必须实现一个有限差分时间步进工具，对于每个指定的方法和加密级别，该工具将无量纲的弗里德曼常微分方程从 $\\tau_0$ 积分到 $\\tau_f$，并计算最终时刻的全局误差。利用此误差通过加密级别间的理查森式比较来估计观测阶。具体来说，给定一个由索引 $k$ 标记的加密序列，其特征步长为 $h_k$，构建误差 $E_k = \\lvert a_k(\\tau_f) - a(\\tau_f)\\rvert$，其中 $a_k(\\tau_f)$ 是在加密级别 $k$ 下 $\\tau_f$ 处的数值解。对于均匀减半加密，两个连续级别之间的观测阶为\n$$\np_{\\mathrm{obs}} = \\log_2\\!\\left(\\frac{E_k}{E_{k+1}}\\right)。\n$$\n当步长约束或自适应性导致 $h$ 在区间内发生非均匀变化时，对通过减半参考参数生成的序列应用相同的公式，并将 $p_{\\mathrm{obs}}$ 解释为一个可能偏离标称阶的经验估计。\n\n实现以下单步法：\n- 标称阶为 $p=2$ 的显式中点法。\n- 标称阶为 $p=4$ 的经典龙格-库塔法。\n\n对于受约束或自适应步进，基于哈勃时间建立一个源于宇宙学的步长上限模型。在无量纲变量中，哈勃时间为 $H(\\tau)^{-1} = a(\\tau)^{3/2}$。施加一个逐点步长约束\n$$\nh(\\tau) \\le \\eta\\,a(\\tau)^{3/2}，\n$$\n其中 $\\eta  0$ 是一个固定常数，同时尝试在不同加密级别间将参考步长 $h_{\\mathrm{ref}}$ 减半。在积分器内部使用 $h(\\tau) = \\min\\!\\big(h_{\\mathrm{ref}},\\,\\eta\\,a(\\tau)^{3/2}\\big)$，并通过在必要时缩短最后一步来强制最后一步恰好落在 $\\tau_f$ 上。\n\n使用以下参数值的测试套件，其设计旨在检验理想路径、高阶情况以及受约束/自适应场景：\n- 所有测试共享的宇宙学区间和初始条件：$\\tau_0 = 0.1$，$\\tau_f = 1.0$，其中 $a(\\tau_0) = \\left(\\frac{2}{3}\\,\\tau_0\\right)^{2/3}$。\n- 测试用例 #1（理想路径，二阶）：在均匀网格上使用显式中点法，加密级别为 $\\{N_0, 2N_0, 4N_0\\}$，其中 $N_0 = 50$ 且 $h_k = (\\tau_f - \\tau_0)/N_k$。\n- 测试用例 #2（理想路径，四阶）：在均匀网格上使用经典龙格-库塔法，加密级别为 $\\{N_0, 2N_0, 4N_0\\}$，其中 $N_0 = 20$ 且 $h_k = (\\tau_f - \\tau_0)/N_k$。\n- 测试用例 #3（约束下的差异）：使用经典龙格-库塔法，步长受约束 $h(\\tau) = \\min\\!\\big(h_{\\mathrm{ref}},\\,\\eta\\,a(\\tau)^{3/2}\\big)$，加密级别为 $h_{\\mathrm{ref}} \\in \\{h_0, h_0/2, h_0/4\\}$，其中 $h_0 = 0.05$ 且 $\\eta = 0.1$。\n\n对于每个测试用例，仅计算最后两个加密级别之间的观测阶 $p_{\\mathrm{obs}}$（即，对于均匀网格测试，在 $\\{2N_0, 4N_0\\}$ 之间；对于受约束测试，在 $\\{h_0/2, h_0/4\\}$ 之间）。你的程序应生成单行输出，其中包含三个观测阶，形式为用方括号括起来的逗号分隔列表，例如 `\"[p_1,p_2,p_3]\"`。这些值必须以浮点数形式打印。所有量都是无量纲的，因此不需要物理单位，也不涉及角度。不使用百分比；任何比率都应表示为小数。",
            "solution": "该问题要求构建一个数值测试工具，以测量有限差分法应用于一个简化的宇宙学常微分方程（ODE）时观测到的精度阶。该问题是有效的，因为它具有科学依据，即基于弗里德曼方程，在数学上是适定的，并且其实现所需的所有规格都已完整且明确地提供。\n\n其物理基础是针对空间平坦、物质主导宇宙的弗里德曼方程，其中哈勃参数 $H$ 对标度因子 $a$ 的依赖关系为 $H(a) = H_0 a^{-3/2}$。标度因子在宇宙时 $t$ 中的演化由 ODE $\\frac{da}{dt} = a H(a)$ 给出。通过引入无量纲时间 $\\tau = H_0 t$，该方程简化为：\n$$\n\\frac{da}{d\\tau} = a^{-1/2}\n$$\n这个 ODE 描述了在此简化模型中宇宙的膨胀。初始值取在时间 $\\tau_0 = 0.1$ 处，以避免在 $\\tau=0$ 处的“大爆炸”奇点。该方程可以通过分离变量法解析求解，得到标度因子的精确解：\n$$\na(\\tau) = \\left(\\frac{2}{3}\\,\\tau\\right)^{2/3}\n$$\n程序将从初始时间 $\\tau_0 = 0.1$ 积分到最终时间 $\\tau_f = 1.0$。初始条件 $a(\\tau_0)$ 被设置为与精确解一致，即 $a(\\tau_0) = (\\frac{2}{3}\\tau_0)^{2/3}$。\n\n任务的核心是使用两种单步有限差分法对该初值问题（IVP）进行数值求解，并分析其精度。一个通用的单步法通过在离散时间点 $t_n = t_0 + n h$ 产生一系列值 $y_n \\approx y(t_n)$ 来逼近 IVP $y'(t) = f(t, y(t))$ 的解 $y(t)$。指定的两种方法是：\n\n1.  **显式中点法**：这是一种二阶龙格-库塔法（$p=2$）。从时间 $\\tau_n$ 的 $a_n$ 到时间 $\\tau_{n+1} = \\tau_n + h$ 的 $a_{n+1}$ 的更新规则是：\n    $$\n    \\begin{align*}\n    k_1 = f(\\tau_n, a_n) \\\\\n    k_2 = f\\left(\\tau_n + \\frac{h}{2}, a_n + \\frac{h}{2} k_1\\right) \\\\\n    a_{n+1} = a_n + h k_2\n    \\end{align*}\n    $$\n    其中 $f(\\tau, a) = a^{-1/2}$。\n\n2.  **经典龙格-库塔法（RK4）**：这是一种四阶方法（$p=4$）。其更新规则是：\n    $$\n    \\begin{align*}\n    k_1 = f(\\tau_n, a_n) \\\\\n    k_2 = f\\left(\\tau_n + \\frac{h}{2}, a_n + \\frac{h}{2} k_1\\right) \\\\\n    k_3 = f\\left(\\tau_n + \\frac{h}{2}, a_n + \\frac{h}{2} k_2\\right) \\\\\n    k_4 = f\\left(\\tau_n + h, a_n + h k_3\\right) \\\\\n    a_{n+1} = a_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n    \\end{align*}\n    $$\n\n这些方法的精度通过最终时刻的**全局误差**来量化，即 $E = |a_{\\text{numerical}}(\\tau_f) - a_{\\text{exact}}(\\tau_f)|$。对于一个阶为 $p$ 的方法，误差预计会按 $E \\propto h^p$ 的比例缩放，其中 $h$ 是特征步长。通过计算一系列加密步长的误差，我们可以估计方法的**观测精度阶**，$p_{\\text{obs}}$。对于两个连续的加密，其误差分别为 $E_k$ 和 $E_{k+1}$，且步长减半（$h_{k+1} = h_k/2$），观测阶由理查森式比较给出：\n$$\np_{\\text{obs}} = \\log_2\\left(\\frac{E_k}{E_{k+1}}\\right)\n$$\n\n该实现将测试三种场景：\n- **测试用例 1**：使用显式中点法，采用均匀步长 $h_k = (\\tau_f - \\tau_0) / N_k$，网格点序列为 $N_k = \\{50, 100, 200\\}$。预期的观测阶接近 $p=2$。\n- **测试用例 2**：使用经典 RK4 方法，采用均匀步长 $h_k = (\\tau_f - \\tau_0) / N_k$，网格点序列为 $N_k = \\{20, 40, 80\\}$。预期的观测阶接近 $p=4$。\n- **测试用例 3**：使用经典 RK4 方法，采用可变的、受约束的步长。这模拟了宇宙学模拟中的一种常见做法，即时间步长受系统动力学时标（此处为哈勃时间 $H^{-1} = a^{3/2}$）的限制。在每个点 $(\\tau, a)$ 的步长 $h$ 由以下公式确定：\n$$\nh(\\tau) = \\min\\!\\big(h_{\\mathrm{ref}},\\,\\eta\\,a(\\tau)^{3/2}\\big)\n$$\n其中 $\\eta = 0.1$ 是一个安全因子。通过将参考步长减半来实现加密，即 $h_{\\mathrm{ref}} \\in \\{0.05, 0.025, 0.0125\\}$。由于步长不均匀且依赖于解的路径，观测阶可能偏离标称阶 4。积分器逻辑通过在必要时缩短最后一步来确保最后一步恰好落在 $\\tau_f$ 上。\n\n对于这三个测试用例中的每一个，程序将使用最后两个加密级别的误差来计算观测阶。结果将是这三个计算出的阶数的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a test harness to measure the observed order of accuracy for\n    finite difference time-integration methods on a simplified Friedmann ODE.\n    \"\"\"\n    \n    # --- Problem Definition ---\n    # Global parameters, ODE, and its exact solution\n    TAU_0 = 0.1\n    TAU_F = 1.0\n\n    def ode_rhs(tau, a):\n        \"\"\" The right-hand side of the ODE: da/d(tau) = a**(-1/2) \"\"\"\n        return a**(-0.5)\n\n    def exact_solution(tau):\n        \"\"\" The exact analytical solution: a(tau) = (2/3 * tau)**(2/3) \"\"\"\n        return (2.0/3.0 * tau)**(2.0/3.0)\n\n    A_0 = exact_solution(TAU_0)\n    A_F_EXACT = exact_solution(TAU_F)\n\n    # --- Numerical Method Steppers ---\n    def step_midpoint(f, t, y, h):\n        \"\"\"\n        Performs a single step using the explicit midpoint method (p=2).\n        \"\"\"\n        k1 = f(t, y)\n        y_mid = y + 0.5 * h * k1\n        k2 = f(t + 0.5 * h, y_mid)\n        return y + h * k2\n        \n    def step_rk4(f, t, y, h):\n        \"\"\"\n        Performs a single step using the classical Runge-Kutta method (p=4).\n        \"\"\"\n        k1 = f(t, y)\n        k2 = f(t + 0.5 * h, y + 0.5 * h * k1)\n        k3 = f(t + 0.5 * h, y + 0.5 * h * k2)\n        k4 = f(t + h, y + h * k3)\n        return y + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    # --- Generic Integration Driver ---\n    def integrate(stepper, step_logic_func):\n        \"\"\"\n        Integrates the ODE from TAU_0 to TAU_F using a given stepper and\n        step-size logic. The final step is adjusted to land exactly on TAU_F.\n        \"\"\"\n        t = TAU_0\n        a = A_0\n        \n        while not np.isclose(t, TAU_F):\n            h = step_logic_func(t, a)\n            \n            # Ensure the final step lands exactly on the final time\n            if t + h > TAU_F:\n                h = TAU_F - t\n            \n            a = stepper(ode_rhs, t, a, h)\n            t += h\n            \n        return a\n\n    # --- Test Harness ---\n    results = []\n    \n    # Test Case #1: Explicit Midpoint, Uniform Grid\n    case1_errors = []\n    case1_N0 = 50\n    case1_refinements = [case1_N0, 2 * case1_N0, 4 * case1_N0]\n    for N in case1_refinements:\n        h_uniform = (TAU_F - TAU_0) / N\n        step_logic = lambda t, a: h_uniform\n        a_final = integrate(step_midpoint, step_logic)\n        case1_errors.append(abs(a_final - A_F_EXACT))\n    \n    p_obs1 = np.log2(case1_errors[1] / case1_errors[2])\n    results.append(p_obs1)\n\n    # Test Case #2: Classical RK4, Uniform Grid\n    case2_errors = []\n    case2_N0 = 20\n    case2_refinements = [case2_N0, 2 * case2_N0, 4 * case2_N0]\n    for N in case2_refinements:\n        h_uniform = (TAU_F - TAU_0) / N\n        step_logic = lambda t, a: h_uniform\n        a_final = integrate(step_rk4, step_logic)\n        case2_errors.append(abs(a_final - A_F_EXACT))\n        \n    p_obs2 = np.log2(case2_errors[1] / case2_errors[2])\n    results.append(p_obs2)\n\n    # Test Case #3: Classical RK4, Constrained Step Size\n    case3_errors = []\n    case3_h0 = 0.05\n    case3_eta = 0.1\n    case3_refinements = [case3_h0, case3_h0 / 2.0, case3_h0 / 4.0]\n    for h_ref in case3_refinements:\n        # The lambda captures h_ref and case3_eta from the enclosing scope\n        step_logic = lambda t, a: min(h_ref, case3_eta * a**1.5)\n        a_final = integrate(step_rk4, step_logic)\n        case3_errors.append(abs(a_final - A_F_EXACT))\n    \n    p_obs3 = np.log2(case3_errors[1] / case3_errors[2])\n    results.append(p_obs3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多物理量，如能量密度，必须保持非负性，然而显式有限差分格式可能会违反这一物理约束。本练习探讨了这一问题，并要求您推导出保证“正定性”的步长限制，从而确保数值解的物理实在性。通过将其应用于一个衰变暗物质模型，您将学会如何调整数值方法以尊重其背后的物理原理。",
            "id": "3471815",
            "problem": "考虑一个在空间均匀的 Friedmann–Lemaître–Robertson–Walker 背景中，由包含衰变汇的协变能量守恒推导出的、用于描述衰变暗物质能量密度的常微分方程，该方程由下式给出\n$$\n\\frac{d\\rho}{dt} = -3\\,H(t)\\,\\rho(t) - \\Gamma\\,\\rho(t),\n$$\n其中 $H(t)$ 是哈勃膨胀率，$\\Gamma \\ge 0$ 是一个恒定的衰变率。定义组合率\n$$\n\\Lambda(t) \\equiv 3\\,H(t) + \\Gamma,\n$$\n使得方程变为线性和齐次的，\n$$\n\\frac{d\\rho}{dt} = -\\Lambda(t)\\,\\rho(t).\n$$\n您需要构建保正性的显式有限差分更新格式，并推导保证数值解非负性的步长限制。\n\n您的任务是：\n\n- 从守恒定律和 $H(t)$ 的定义出发，形式上论证模型 $\\frac{d\\rho}{dt} = -3\\,H(t)\\,\\rho(t) - \\Gamma \\rho(t)$，以及线性形式 $\\frac{d\\rho}{dt} = -\\Lambda(t)\\,\\rho(t)$（其中 $\\Lambda(t) \\ge 0$）的合理性。\n- 对下列每种显式时间离散化方法，构建 $\\rho_{n+1}$ 的单步更新格式，并推导出以 $\\Lambda(t)$ 的上界表示的充分步长限制，该限制能保证在所需的前序值为非负时，$\\rho_{n+1} \\ge 0$：\n  - 前向 Euler 法（单步显式方法）。\n  - 二阶两级强稳定性保持 Runge–Kutta 法（SSP Runge–Kutta, second order）。\n  - 二阶两步 Adams–Bashforth 法（显式多步法），假设第一步使用前向 Euler 法并在其自身的保正性条件下计算。\n  您的推导必须从方法的定义更新式开始，并且只使用涉及 $\\Lambda(t)$ 和 $\\Lambda(t)$ 在一个步长上的界的不等式。不要假设 $\\Lambda(t)$ 在一个步长内是常数；您可以使用任何满足 $\\Lambda(t) \\le \\ell$ 在目标区间上的界 $\\ell$。\n- 实现一个程序，该程序：\n  - 对于下方的每个测试用例，通过使用您推导出的条件所隐含的上确界 $\\lambda_{\\max} \\equiv \\sup_{t \\in [t_0, t_0+T]} \\Lambda(t)$，为每种方法计算一个在整个积分区间上足以保持正性的统一时间步长 $\\Delta t_{\\max}$。\n  - 使用步长 $\\Delta t = 0.99\\,\\Delta t_{\\max}$，从 $\\rho(t_0) = \\rho_0$ 开始，在 $[t_0, t_0+T]$ 上对该方程进行数值积分，并验证所有离散密度值均保持非负。\n  - 为每个测试用例报告一个列表，其中包含三个以 $\\mathrm{Gyr}$ 为单位的步长界限，随后是三个布尔值，指示相应的数值积分是否在所有网格点上都保持非负。\n- 单位与格式：\n  - 时间 $t$ 的单位必须是 $\\mathrm{Gyr}$，哈勃率 $H$ 的单位必须是 $\\mathrm{Gyr}^{-1}$，衰变率 $\\Gamma$ 的单位必须是 $\\mathrm{Gyr}^{-1}$，报告的步长单位也必须是 $\\mathrm{Gyr}$。\n  - 不使用角度。\n  - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身是对应一个测试用例的列表，顺序如下所述。\n\n测试套件（请精确使用以下三个用例）：\n- 用例 1（恒定膨胀）：$H(t) = H_0$，其中 $H_0 = 0.07\\,\\mathrm{Gyr}^{-1}$，$\\Gamma = 0.01\\,\\mathrm{Gyr}^{-1}$，$t_0 = 0.0\\,\\mathrm{Gyr}$，$T = 10.0\\,\\mathrm{Gyr}$，$\\rho_0 = 1.0$。\n- 用例 2（物质主导标度）：$H(t) = \\dfrac{2}{3\\,t}$，$\\Gamma = 0.2\\,\\mathrm{Gyr}^{-1}$，$t_0 = 1.0\\,\\mathrm{Gyr}$，$T = 5.0\\,\\mathrm{Gyr}$，$\\rho_0 = 1.0$。\n- 用例 3（辐射主导标度）：$H(t) = \\dfrac{1}{2\\,t}$，$\\Gamma = 0.0\\,\\mathrm{Gyr}^{-1}$，$t_0 = 0.5\\,\\mathrm{Gyr}$，$T = 0.5\\,\\mathrm{Gyr}$，$\\rho_0 = 1.0$。\n\n最终输出格式：\n- 程序必须打印单行，其中包含一个含三个元素的列表，每个元素对应一个测试用例。每个元素必须是包含六个条目的列表，顺序为 $[\\Delta t_{\\max}^{\\mathrm{FE}}, \\Delta t_{\\max}^{\\mathrm{SSP2}}, \\Delta t_{\\max}^{\\mathrm{AB2}}, \\mathrm{pos}_{\\mathrm{FE}}, \\mathrm{pos}_{\\mathrm{SSP2}}, \\mathrm{pos}_{\\mathrm{AB2}}]$，其中每个 $\\Delta t_{\\max}$ 是一个以 $\\mathrm{Gyr}$ 为单位的浮点数，每个 $\\mathrm{pos}$ 是一个布尔值。",
            "solution": "该问题经评估有效，因其具有科学依据、数学上适定、客观且完整。我们开始进行解答。\n\n### 控制方程的论证\n\n用于描述衰变暗物质能量密度 $\\rho(t)$ 的控制常微分方程（ODE）可以在宇宙学背景下从广义相对论的原理推导出来。其出发点是能量-动量张量 $T^{\\mu\\nu}$ 的协变守恒，在存在能量-动量汇/源 $J^\\nu$ 的情况下，表示为 $\\nabla_\\mu T^{\\mu\\nu} = J^\\nu$。\n\n对于理想流体，能量-动量张量为 $T^{\\mu\\nu} = (\\rho+p)u^\\mu u^\\nu + p g^{\\mu\\nu}$，其中 $\\rho$ 是能量密度，$p$ 是压强，$u^\\mu$ 是流体的四维速度，$g^{\\mu\\nu}$ 是度规张量。在一个空间均匀且各向同性的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙中，并在一个共动参考系中（其中 $u^\\mu = (1, 0, 0, 0)$），守恒定律的时间分量（$\\nu=0$）简化为流体方程：\n$$\n\\dot{\\rho} + 3H(t)(\\rho+p) = J^0,\n$$\n其中点号表示对宇宙时 $t$ 的导数，$H(t) \\equiv \\dot{a}(t)/a(t)$ 是哈勃膨胀率，而 $a(t)$ 是宇宙的标度因子。\n\n该问题考虑的是暗物质，它被建模为一种非相对论性物质。对于此类物质，其组成粒子的动能远小于其静止质量能，这意味着压强与能量密度相比可以忽略不计，即 $p \\ll \\rho$。因此，我们采用标准近似 $p=0$。\n\n暗物质粒子衰变为其他粒子（例如，辐射）的过程充当了暗物质能量密度的汇。对此过程的一个常见唯象模型假设能量损失率与能量密度本身成正比。这由一个汇项 $J^0 = -\\Gamma\\rho$ 表示，其中 $\\Gamma \\ge 0$ 是恒定的衰变率。\n\n将 $p=0$ 和 $J^0 = -\\Gamma\\rho$ 代入流体方程，得到：\n$$\n\\dot{\\rho} + 3H(t)\\rho = -\\Gamma\\rho.\n$$\n整理该方程即可得到问题陈述中提供的 ODE：\n$$\n\\frac{d\\rho}{dt} = -3H(t)\\rho(t) - \\Gamma\\rho(t).\n$$\n通过定义组合率 $\\Lambda(t) \\equiv 3H(t) + \\Gamma$，方程呈现出简单的线性齐次形式：\n$$\n\\frac{d\\rho}{dt} = -\\Lambda(t)\\rho(t).\n$$\n对于一个膨胀的宇宙，标度因子 $a(t)$ 是非递减的，因此哈勃率 $H(t) = \\dot{a}/a$ 是非负的。由于给定的衰变率 $\\Gamma \\ge 0$，组合率 $\\Lambda(t) = 3H(t) + \\Gamma$ 保证对所有 $t$ 都是非负的。因此，如果初始密度 $\\rho(t_0)$ 非负，则精确解 $\\rho(t) = \\rho(t_0) \\exp(-\\int_{t_0}^t \\Lambda(\\tau)d\\tau)$ 总是非负的。\n\n### 保正性步长限制的推导\n\n我们为三种显式数值方法推导充分的步长限制，以确保在假设前序步骤值为非负的前提下，数值解 $\\rho_n$ 在所有时间步长上都保持非负。设 $\\ell$ 为组合率的任意上界，即在积分区间 $[t_0, t_0+T]$ 上有 $\\Lambda(t) \\le \\ell$。\n\n#### 前向 Euler (FE) 法\n这是一种单步显式方法。对于方程 $\\dot{\\rho} = f(t, \\rho)$，其更新规则为 $\\rho_{n+1} = \\rho_n + \\Delta t f(t_n, \\rho_n)$。代入 $f(t_n, \\rho_n) = -\\Lambda(t_n)\\rho_n$，我们得到：\n$$\n\\rho_{n+1} = \\rho_n + \\Delta t (-\\Lambda(t_n)\\rho_n) = \\rho_n(1 - \\Delta t \\Lambda(t_n)).\n$$\n为确保在 $\\rho_n \\ge 0$ 的条件下有 $\\rho_{n+1} \\ge 0$，我们需要 $\\rho_n$ 的系数为非负：\n$$\n1 - \\Delta t \\Lambda(t_n) \\ge 0 \\implies \\Delta t \\Lambda(t_n) \\le 1.\n$$\n为了使统一的步长 $\\Delta t$ 在每一步都能保持正性，该条件必须对所有 $n$ 成立。一个充分条件是 $\\Delta t \\cdot \\sup_t \\Lambda(t) \\le 1$。使用界 $\\ell$，步长必须满足：\n$$\n\\Delta t \\le \\frac{1}{\\ell}.\n$$\n\n#### 两级强稳定性保持 Runge–Kutta (SSP2) 法\n二阶两级 SSP Runge-Kutta 法 (SSP$2$) 的结构是类前向 Euler 步的凸组合。对于 $\\dot{\\rho} = f(t, \\rho)$，更新过程如下：\n\\begin{align*}\n\\rho^{(1)} = \\rho_n + \\Delta t f(t_n, \\rho_n) \\\\\n\\rho_{n+1} = \\frac{1}{2}\\rho_n + \\frac{1}{2}\\left(\\rho^{(1)} + \\Delta t f(t_n+\\Delta t, \\rho^{(1)})\\right)\n\\end{align*}\n代入 $f(t, \\rho) = -\\Lambda(t)\\rho$：\n\\begin{align*}\n\\rho^{(1)} = \\rho_n - \\Delta t \\Lambda(t_n)\\rho_n = \\rho_n(1 - \\Delta t \\Lambda(t_n)) \\\\\n\\rho_{n+1} = \\frac{1}{2}\\rho_n + \\frac{1}{2}\\left(\\rho^{(1)} - \\Delta t \\Lambda(t_{n+1})\\rho^{(1)}\\right) = \\frac{1}{2}\\rho_n + \\frac{1}{2}\\rho^{(1)}(1 - \\Delta t \\Lambda(t_{n+1}))\n\\end{align*}\n假设 $\\rho_n \\ge 0$，我们要找到一个关于 $\\Delta t$ 的条件来保证 $\\rho_{n+1} \\ge 0$。\n1.  为使中间阶段的值 $\\rho^{(1)}$ 非负，我们需要 $1 - \\Delta t \\Lambda(t_n) \\ge 0$。\n2.  在 $\\rho^{(1)} \\ge 0$ 和 $\\rho_n \\ge 0$ 的情况下，为使 $\\rho_{n+1}$（两项之和）非负，$\\rho^{(1)}$ 的系数为非负即可成为一个充分条件：$1 - \\Delta t \\Lambda(t_{n+1}) \\ge 0$。\n如果对于步长区间 $[t_n, t_{n+1}]$ 内的所有 $t$ 都满足 $\\Delta t \\Lambda(t) \\le 1$，那么这两个条件都能满足。因此，一个保证正性的统一的步长限制是：\n$$\n\\Delta t \\le \\frac{1}{\\ell}.\n$$\n\n#### 两步 Adams–Bashforth (AB2) 法\n二阶两步 Adams-Bashforth 法 (AB$2$) 是一种显式线性多步法。其更新规则是：\n$$\n\\rho_{n+1} = \\rho_n + \\frac{\\Delta t}{2} \\left( 3f(t_n, \\rho_n) - f(t_{n-1}, \\rho_{n-1}) \\right).\n$$\n代入 $f(t, \\rho) = -\\Lambda(t)\\rho$，我们有：\n$$\n\\rho_{n+1} = \\rho_n + \\frac{\\Delta t}{2} \\left( -3\\Lambda(t_n)\\rho_n + \\Lambda(t_{n-1})\\rho_{n-1} \\right).\n$$\n通过将 $\\rho_n$ 和 $\\rho_{n-1}$ 的项分组重新整理，得到：\n$$\n\\rho_{n+1} = \\rho_n \\left( 1 - \\frac{3}{2}\\Delta t \\Lambda(t_n) \\right) + \\rho_{n-1} \\left( \\frac{1}{2}\\Delta t \\Lambda(t_{n-1}) \\right).\n$$\n假设前序值为非负：$\\rho_n \\ge 0$ 和 $\\rho_{n-1} \\ge 0$。由于 $\\Delta t  0$ 和 $\\Lambda(t) \\ge 0$，涉及 $\\rho_{n-1}$ 的第二项显然是非负的。为确保 $\\rho_{n+1} \\ge 0$，一个充分条件是 $\\rho_n$ 的系数也为非负：\n$$\n1 - \\frac{3}{2}\\Delta t \\Lambda(t_n) \\ge 0 \\implies \\Delta t \\Lambda(t_n) \\le \\frac{2}{3}.\n$$\n此两步法的第一步必须用单步法（指定为前向 Euler 法）计算。FE 步的保正性要求 $\\Delta t \\Lambda(t_0) \\le 1$。由于 $\\frac{2}{3}  1$，AB$2$ 的条件更严格，如果对所有步都强制执行此条件，将自动满足启动步的保正性要求。在整个积分过程中保证正性的一个统一的步长限制是：\n$$\n\\Delta t \\le \\frac{2}{3\\ell}.\n$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes positivity-preserving step-size limits for three numerical methods\n    and verifies that the solutions remain non-negative when integrated with these step sizes.\n    \"\"\"\n    test_cases = [\n        {\n            \"H_func\": lambda t: 0.07,\n            \"Gamma\": 0.01,\n            \"t0\": 0.0,\n            \"T\": 10.0,\n            \"rho0\": 1.0,\n        },\n        {\n            \"H_func\": lambda t: 2.0 / (3.0 * t),\n            \"Gamma\": 0.2,\n            \"t0\": 1.0,\n            \"T\": 5.0,\n            \"rho0\": 1.0,\n        },\n        {\n            \"H_func\": lambda t: 1.0 / (2.0 * t),\n            \"Gamma\": 0.0,\n            \"t0\": 0.5,\n            \"T\": 0.5,\n            \"rho0\": 1.0,\n        },\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        H_func = case[\"H_func\"]\n        Gamma = case[\"Gamma\"]\n        t0 = case[\"t0\"]\n        T = case[\"T\"]\n        rho0 = case[\"rho0\"]\n\n        Lambda_func = lambda t: 3.0 * H_func(t) + Gamma\n        \n        # For the given H(t) functions, Lambda(t) is monotonically non-increasing on t > 0.\n        # The integration intervals are [t0, t0+T] where t0 > 0 or t0=0 and H is constant.\n        # Thus, the supremum of Lambda(t) occurs at t = t0.\n        lambda_max = Lambda_func(t0)\n\n        # Calculate maximum step sizes based on derived positivity conditions\n        dt_max_fe = 1.0 / lambda_max\n        dt_max_ssp2 = 1.0 / lambda_max\n        dt_max_ab2 = (2.0 / 3.0) / lambda_max\n\n        case_results = [dt_max_fe, dt_max_ssp2, dt_max_ab2]\n\n        # --- Run simulations for each method ---\n        # The factor 0.99 is used to ensure the step size is strictly within the bound.\n        # A small negative tolerance is used for the positivity check to account for floating-point inaccuracies.\n        fp_tol = -1e-15\n\n        # Method 1: Forward Euler\n        dt = 0.99 * dt_max_fe\n        num_steps = int(np.ceil(T / dt))\n        t_grid = t0 + np.arange(num_steps + 1) * dt\n        rho = np.zeros(num_steps + 1)\n        rho[0] = rho0\n        for n in range(num_steps):\n            rho[n+1] = rho[n] * (1.0 - dt * Lambda_func(t_grid[n]))\n        pos_fe = np.all(rho >= fp_tol)\n        case_results.append(pos_fe)\n\n        # Method 2: SSP Runge-Kutta 2\n        dt = 0.99 * dt_max_ssp2\n        num_steps = int(np.ceil(T / dt))\n        t_grid = t0 + np.arange(num_steps + 1) * dt\n        rho = np.zeros(num_steps + 1)\n        rho[0] = rho0\n        for n in range(num_steps):\n            rho_stage1 = rho[n] * (1.0 - dt * Lambda_func(t_grid[n]))\n            rho[n+1] = 0.5 * rho[n] + 0.5 * rho_stage1 * (1.0 - dt * Lambda_func(t_grid[n+1]))\n        pos_ssp2 = np.all(rho >= fp_tol)\n        case_results.append(pos_ssp2)\n\n        # Method 3: Adams-Bashforth 2\n        dt = 0.99 * dt_max_ab2\n        num_steps = int(np.ceil(T / dt))\n        t_grid = t0 + np.arange(num_steps + 1) * dt\n        rho = np.zeros(num_steps + 1)\n        rho[0] = rho0\n        \n        # At least two points (t0, t1) are needed for the AB2 formula.\n        if num_steps > 0:\n            # Startup step using Forward Euler for rho at t1\n            rho[1] = rho[0] * (1.0 - dt * Lambda_func(t_grid[0]))\n            \n            # Main AB2 loop for subsequent steps\n            for n in range(1, num_steps):\n                f_n = -Lambda_func(t_grid[n]) * rho[n]\n                f_n_minus_1 = -Lambda_func(t_grid[n-1]) * rho[n-1]\n                rho[n+1] = rho[n] + (dt / 2.0) * (3.0 * f_n - f_n_minus_1)\n        \n        pos_ab2 = np.all(rho >= fp_tol)\n        case_results.append(pos_ab2)\n        \n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists. The standard `str` representation\n    # for lists in Python is used, which includes spaces after commas and capitalized booleans.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个常见的误解是，步长越小结果就越精确。本练习深入探讨了数学近似带来的截断误差与有限精度计算引起的舍入误差之间的实际权衡。您将通过推导最小化总误差的最佳步长，揭示数值微分的基本限制，并理解为何无限小的步长并不可取。",
            "id": "3471898",
            "problem": "在数值宇宙学中，诸如标度因子 $a(t)$、哈勃膨胀率 $H(t)$ 或距离测量 $D(t)$ 等光滑宇宙学可观测量的一阶导数，通常使用有限差分法由常微分方程求得。设 $y(t)$ 表示任意一个在固定历元 $t$ 附近二阶连续可微且存在更高阶导数的光滑可观测量。考虑一阶导数的中心差分估计量，\n$$\nD_{c}(h;t) \\equiv \\frac{y(t+h)-y(t-h)}{2h},\n$$\n该计算在遵循电气和电子工程师协会 (IEEE) $754$ 标准的浮点运算中进行，采用四舍五入到最近值的方式，单位舍入误差为 $\\varepsilon$。\n\n从适用于该情境的基本原理出发，即光滑函数的泰勒展开和对于每个基本运算的标准浮点舍入模型 $\\mathrm{fl}(z)=z(1+\\delta)$（其中 $|\\delta|\\leq \\varepsilon$），完成以下任务：\n\n- 推导 $D_{c}(h;t)$ 的主阶截断误差，将其表示为 $h$ 和 $y(t)$ 的导数的函数。\n- 通过对浮点舍入在减法 $y(t+h)-y(t-h)$ 上的影响进行建模，量化当 $h$ 非常小时产生的相消误差，并得出一个最坏情况绝对误差界，以揭示其与 $h$ 和 $y(t)$ 的标度关系。\n- 将这些误差贡献合并成一个单一的主阶最坏情况绝对误差模型 $E(h)$，并通过最小化 $E(h)$（相对于 $h$）来确定平衡截断误差和相消误差的最优步长 $h^{\\star}$。\n\n最后，提出一种补偿差分策略，该策略利用浮点减法的无误差变换来减弱减法 $y(t+h)-y(t-h)$ 中的相消误差，并定性解释这如何改变误差模型中舍入项对 $h$ 的依赖关系。您的推导必须保持通用性，不要代入宇宙学参数的具体数值。\n\n将您的最终答案表示为最优步长 $h^{\\star}$ 的闭式解析表达式，用 $\\varepsilon$、$y(t)$ 和 $y(t)$ 的适当导数表示。最终答案不需要数值近似或舍入。",
            "solution": "该问题要求对使用中心差分公式计算光滑函数 $y(t)$ 一阶导数所涉及的误差进行深入分析，\n$$\nD_{c}(h;t) = \\frac{y(t+h)-y(t-h)}{2h},\n$$\n并确定使总误差最小化的最优步长 $h^{\\star}$。分析涉及两个主要的误差来源：有限差分近似固有的截断误差和源于浮点运算的舍入误差。\n\n### 步骤 1：截断误差的推导\n\n截断误差 $E_{\\text{trunc}}(h)$ 是在假设精确运算的情况下，用有限差分公式近似真实导数 $y'(t)$ 时产生的误差。它可以通过函数 $y(t)$ 在点 $t$ 附近的泰勒展开来推导。由于假设 $y(t)$ 充分可微，我们可以写出 $y(t+h)$ 和 $y(t-h)$ 的泰勒级数：\n\n$$\ny(t+h) = y(t) + h y'(t) + \\frac{h^2}{2!} y''(t) + \\frac{h^3}{3!} y'''(t) + \\frac{h^4}{4!} y^{(4)}(t) + O(h^5)\n$$\n$$\ny(t-h) = y(t) - h y'(t) + \\frac{h^2}{2!} y''(t) - \\frac{h^3}{3!} y'''(t) + \\frac{h^4}{4!} y^{(4)}(t) - O(h^5)\n$$\n\n从第一个展开式中减去第二个展开式，消除了 $h$ 的偶次幂项：\n$$\ny(t+h) - y(t-h) = 2h y'(t) + \\frac{2h^3}{3!} y'''(t) + O(h^5)\n$$\n$$\ny(t+h) - y(t-h) = 2h y'(t) + \\frac{h^3}{3} y'''(t) + O(h^5)\n$$\n\n现在，我们除以 $2h$ 得到中心差分估计量的表达式：\n$$\n\\frac{y(t+h) - y(t-h)}{2h} = y'(t) + \\frac{h^2}{6} y'''(t) + O(h^4)\n$$\n\n截断误差是估计值与真实值之间的差：\n$$\nE_{\\text{trunc}}(h) = D_{c}(h;t) - y'(t) = \\frac{h^2}{6} y'''(t) + O(h^4)\n$$\n\n主阶截断误差是该级数的第一项，它与步长的平方 $h^2$ 成标度关系。其大小由下式给出：\n$$\n|E_{\\text{trunc}}(h)| \\approx \\frac{h^2}{6} |y'''(t)|\n$$\n\n### 步骤 2：舍入误差的量化\n\n舍入误差源于浮点运算的有限精度。对一个值 $z$ 进行单次浮点运算的标准模型是 $\\mathrm{fl}(z) = z(1+\\delta)$，其中 $|\\delta| \\leq \\varepsilon$ 且 $\\varepsilon$ 是单位舍入误差。\n\n$D_{c}(h;t)$ 的计算涉及求值 $y(t+h)$ 和 $y(t-h)$，将它们相减，然后除以 $2h$。让我们分析分子中的误差，这是关键步骤。函数值的浮点表示为：\n$$\n\\tilde{y}_{+} = \\mathrm{fl}(y(t+h)) = y(t+h)(1+\\delta_1)\n$$\n$$\n\\tilde{y}_{-} = \\mathrm{fl}(y(t-h)) = y(t-h)(1+\\delta_2)\n$$\n其中 $|\\delta_1|, |\\delta_2| \\leq \\varepsilon$。为简单起见，我们假设 $y$ 的求值只产生一次舍入误差。\n\n然后在浮点运算中执行减法：\n$$\n\\mathrm{fl}(\\tilde{y}_{+} - \\tilde{y}_{-}) = (\\tilde{y}_{+} - \\tilde{y}_{-})(1+\\delta_3)\n$$\n其中 $|\\delta_3| \\leq \\varepsilon$。\n\n分子中的绝对舍入误差是计算值与真实值 $y(t+h)-y(t-h)$ 之间的差。计算出的分子是：\n$$\n(y(t+h)(1+\\delta_1) - y(t-h)(1+\\delta_2))(1+\\delta_3)\n$$\n展开此式并只保留 $\\delta_i$ 的一阶项，得到：\n$$\n(y(t+h) - y(t-h)) + (y(t+h)-y(t-h))\\delta_3 + y(t+h)\\delta_1 - y(t-h)\\delta_2\n$$\n分子中的误差大约是 $(y(t+h)-y(t-h))\\delta_3 + y(t+h)\\delta_1 - y(t-h)\\delta_2$。\n当 $h$ 很小时，$y(t+h) \\approx y(t-h) \\approx y(t)$，且差值 $y(t+h)-y(t-h) \\approx 2hy'(t)$ 很小。这就是灾难性相消的条件。$y(t\\pm h)$ 计算值的绝对误差约为 $\\varepsilon |y(t)|$。当这两个几乎相等的数相减时，它们的绝对误差大致相加。分子误差的主要部分来自遗传误差：$y(t+h)\\delta_1 - y(t-h)\\delta_2$。\n\n分子绝对误差的最坏情况界是：\n$$\n|E_{\\text{num}}| \\le |y(t+h)\\delta_1| + |y(t-h)\\delta_2| \\approx \\varepsilon |y(t+h)| + \\varepsilon |y(t-h)|\n$$\n对于小 $h$，这大约是 $2\\varepsilon|y(t)|$。\n\n$D_c(h;t)$ 的总舍入误差是这个分子误差除以分母 $2h$（假设分母的计算误差可忽略不计）。\n$$\n|E_{\\text{round}}(h)| \\approx \\frac{2\\varepsilon|y(t)|}{2h} = \\frac{\\varepsilon|y(t)|}{h}\n$$\n当 $h$ 变小时，此误差项增大，这是灾难性相消的标志。\n\n### 步骤 3：最优步长\n\n总绝对误差 $E(h)$ 是主阶截断误差和舍入误差大小之和：\n$$\nE(h) \\approx |E_{\\text{trunc}}(h)| + |E_{\\text{round}}(h)| = \\frac{h^2}{6} |y'''(t)| + \\frac{\\varepsilon|y(t)|}{h}\n$$\n为了找到使该总误差最小化的最优步长 $h^{\\star}$，我们对 $E(h)$ 关于 $h$ 求导，并令结果为零，假设 $y(t)$ 和 $y'''(t)$ 均不为零。\n$$\n\\frac{dE}{dh} = \\frac{2h}{6} |y'''(t)| - \\frac{\\varepsilon|y(t)|}{h^2} = \\frac{h}{3} |y'''(t)| - \\frac{\\varepsilon|y(t)|}{h^2}\n$$\n令 $\\frac{dE}{dh} = 0$：\n$$\n\\frac{h^{\\star}}{3} |y'''(t)| = \\frac{\\varepsilon|y(t)|}{(h^{\\star})^2}\n$$\n解出 $h^{\\star}$：\n$$\n(h^{\\star})^3 = \\frac{3\\varepsilon|y(t)|}{|y'''(t)|}\n$$\n$$\nh^{\\star} = \\left(\\frac{3\\varepsilon|y(t)|}{|y'''(t)|}\\right)^{1/3}\n$$\n这个表达式给出了平衡递减的截断误差和递增的舍入误差的最优步长。\n\n### 步骤 4：补偿差分策略\n\n标准中心差分公式中的灾难性相消是因为当 $h$ 很小时，减法 $\\mathrm{fl}(y(t+h)) - \\mathrm{fl}(y(t-h))$ 会损失显著的相对精度。补偿差分策略可以减弱这一特定的误差来源。\n\n提议的策略是对浮点减法使用无误差变换 (EFT)，例如 Ogita、Rump 和 Oishi 提出的 `TwoDiff` 算法。给定两个浮点数 $x$ 和 $y$，这种算法会计算出一对浮点数 $(s, e)$，使得 $s = \\mathrm{fl}(x-y)$，并且关键的是，$s+e=x-y$ 精确成立（除非发生上溢/下溢）。变量 $e$ 捕获了主减法操作产生的舍入误差。\n\n通过将此 EFT 应用于分子减法，我们实际上是在以更高的精度计算 $\\mathrm{fl}(y(t+h)) - \\mathrm{fl}(y(t-h))$ 的值（例如，表示为一对数 $(s,e)$ 的双精度数）。这个过程有效地消除了由减法操作本身引入的舍入误差。\n\n然而，这并不能消除所有的舍入误差。从 $y(t+h)$ 和 $y(t-h)$ 的初始浮点求值中遗传的误差仍然存在。补偿后分子中的误差现在主要由 $(\\mathrm{fl}(y(t+h)) - \\mathrm{fl}(y(t-h))) - (y(t+h) - y(t-h)) = y(t+h)\\delta_1 - y(t-h)\\delta_2$ 决定。除以 $2h$，补偿方案中的舍入误差为：\n$$\nE_{\\text{round}}^{\\text{comp}}(h) \\approx \\frac{y(t+h)\\delta_1 - y(t-h)\\delta_2}{2h}\n$$\n像之前一样展开这些项，得到：\n$$\nE_{\\text{round}}^{\\text{comp}}(h) \\approx \\frac{y(t)(\\delta_1 - \\delta_2)}{2h} + \\frac{y'(t)(\\delta_1 + \\delta_2)}{2} + O(h)\n$$\n定性地看，由于一种被称为“良性相消”的现象，舍入误差对 $h$ 的依赖关系发生了变化。当在两个非常接近的点 $t+h$ 和 $t-h$ 处求值光滑函数 $y$ 时，其计算路径几乎完全相同。这可能导致高度相关的舍入误差，即 $\\delta_1 \\approx \\delta_2$。因此，差值 $\\delta_1 - \\delta_2$ 远小于 $\\varepsilon$。这种良性相消抑制了有问题的 $O(1/h)$ 项。于是，主导的舍入误差项变为展开式中的下一项，该项相对于 $h$ 近似为常数：\n$$\n|E_{\\text{round}}^{\\text{comp}}(h)| \\approx \\left|\\frac{y'(t)(\\delta_1 + \\delta_2)}{2}\\right| \\le \\frac{|y'(t)|(2\\varepsilon)}{2} = \\varepsilon|y'(t)|\n$$\n因此，补偿差分策略通过利用 EFT 和光滑函数舍入误差的相关性，定性地将舍入误差的标度关系从 $O(\\varepsilon/h)$ 改变为 $O(\\varepsilon)$。这使得在总误差被舍入效应主导之前，可以使用小得多的步长 $h$，从而得到更精确的导数估计。",
            "answer": "$$\n\\boxed{\\left(\\frac{3\\varepsilon|y(t)|}{|y'''(t)|}\\right)^{1/3}}\n$$"
        }
    ]
}