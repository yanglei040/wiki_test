{
    "hands_on_practices": [
        {
            "introduction": "The coordinates we use to describe spacetime are a choice, not a physical reality. This exercise  directly tackles the consequences of this 'gauge freedom' in cosmology by having you implement the machinery of gauge transformations. By numerically adding arbitrary, unphysical gauge modes to a set of cosmological perturbations, you will verify that the truly physical quantities—the Bardeen potentials $\\Phi$ and $\\Psi$—remain unchanged, providing a concrete demonstration of gauge invariance.",
            "id": "3473419",
            "problem": "Implement a self-contained program that, for linear scalar cosmological perturbations in Fourier space, constructs and applies a projector that isolates and removes pure-gauge scalar contributions generated by a time shift $\\alpha$ and a scalar spatial shift $\\beta$, both functions of conformal time. Use first principles of gauge transformations of linear perturbations about a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) background in conformal time to derive the necessary transformation rules and the gauge-invariant combinations. The background expansion is quantified by the conformal Hubble rate $\\mathcal{H} \\equiv a'/a$, where $a$ is the scale factor and a prime denotes a derivative with respect to conformal time. Work in the standard scalar decomposition of the perturbed metric with scalar potentials $\\phi$, $\\psi$, $B$, and $E$ in Fourier space, and assume adiabatic matter with constant equation-of-state parameter $w$ so that the background energy density $\\rho$ obeys the continuity relation $\\rho' = -3 \\mathcal{H} (1+w)\\rho$.\n\nYour program must:\n- Construct, for each Fourier mode, the pure-gauge contributions to the metric potentials and to the density contrast $\\delta \\equiv \\delta\\rho/\\rho$ as driven by $\\alpha$ and $\\beta$ and their conformal time derivatives, consistent with the linearized coordinate transformation at first order in perturbations.\n- Apply this projector to generate a contaminated set of fields by adding the pure-gauge pieces to a supplied baseline \"physical\" configuration.\n- Compute the two gauge-invariant Bardeen potentials $\\Phi$ and $\\Psi$ from the contaminated fields and from the cleaned fields (obtained by removing the projected gauge pieces), using only combinations that are exactly gauge-invariant at linear order.\n- Verify numerically that removing the pure-gauge contributions changes the gauge-dependent fields but leaves $\\Phi$ and $\\Psi$ unchanged to within a strict numerical tolerance, and that the corrected density contrast $\\delta$ equals the baseline physical $\\delta$ after removing its pure-gauge piece.\n\nAll quantities are to be treated as dimensionless and expressed in conformal time units. No physical-unit conversion is required. Angles do not appear, so no angle unit is required. Percentages do not appear.\n\nTest suite and required inputs:\nFor each test case, you are given arrays over Fourier modes for wavenumber $k$, conformal Hubble rate $\\mathcal{H}$ (constant within each test), equation-of-state parameter $w$, baseline physical fields $\\phi_{\\mathrm{phys}}$, $\\psi_{\\mathrm{phys}}$, $B_{\\mathrm{phys}}$, $E_{\\mathrm{phys}}$, their conformal-time derivatives $B'_{\\mathrm{phys}}$, $E'_{\\mathrm{phys}}$, $E''_{\\mathrm{phys}}$, the baseline physical density contrast $\\delta_{\\mathrm{phys}}$, and the gauge generators and their derivatives $\\alpha$, $\\alpha'$, $\\beta$, $\\beta'$, $\\beta''$. Use these to build contaminated fields by adding the pure-gauge pieces determined by the linearized transformation.\n\nImplement the three test cases below exactly as stated inside your program (no input required):\n\n- Test A (general mixed gauge, three modes):\n  - $k = [\\,0.25,\\,0.5,\\,1.0\\,]$\n  - $\\mathcal{H} = 0.2$, $w = 0$\n  - $\\alpha = [\\,0.1,\\,-0.05,\\,0.02\\,]$, $\\alpha' = [\\,0.01,\\,0.02,\\,-0.03\\,]$\n  - $\\beta = [\\,0.3,\\,-0.1,\\,0.05\\,]$, $\\beta' = [\\,0.02,\\,-0.01,\\,0.04\\,]$, $\\beta'' = [\\,-0.005,\\,0.003,\\,-0.002\\,]$\n  - $\\phi_{\\mathrm{phys}} = [\\,0.01,\\,-0.02,\\,0.03\\,]$, $\\psi_{\\mathrm{phys}} = [\\,-0.005,\\,0.004,\\,-0.002\\,]$\n  - $B_{\\mathrm{phys}} = [\\,0.02,\\,0.01,\\,-0.01\\,]$, $E_{\\mathrm{phys}} = [\\,0.015,\\,-0.01,\\,0.005\\,]$\n  - $B'_{\\mathrm{phys}} = [\\,0.001,\\,-0.002,\\,0.003\\,]$, $E'_{\\mathrm{phys}} = [\\,0.002,\\,0.001,\\,-0.0015\\,]$, $E''_{\\mathrm{phys}} = [\\,-0.0005,\\,0.0003,\\,0.0002\\,]$\n  - $\\delta_{\\mathrm{phys}} = [\\,0.1,\\,-0.2,\\,0.05\\,]$\n\n- Test B ($\\alpha$-only gauge with a super-horizon mode, two modes):\n  - $k = [\\,0.0,\\,0.7\\,]$\n  - $\\mathcal{H} = 0.1$, $w = 1/3$\n  - $\\alpha = [\\,-0.03,\\,0.04\\,]$, $\\alpha' = [\\,0.002,\\,-0.001\\,]$\n  - $\\beta = [\\,0.0,\\,0.0\\,]$, $\\beta' = [\\,0.0,\\,0.0\\,]$, $\\beta'' = [\\,0.0,\\,0.0\\,]$\n  - $\\phi_{\\mathrm{phys}} = [\\,-0.02,\\,0.01\\,]$, $\\psi_{\\mathrm{phys}} = [\\,0.003,\\,-0.004\\,]$\n  - $B_{\\mathrm{phys}} = [\\,0.0,\\,-0.005\\,]$, $E_{\\mathrm{phys}} = [\\,0.0,\\,0.002\\,]$\n  - $B'_{\\mathrm{phys}} = [\\,0.0,\\,0.0004\\,]$, $E'_{\\mathrm{phys}} = [\\,0.0,\\,-0.0003\\,]$, $E''_{\\mathrm{phys}} = [\\,0.0,\\,0.00005\\,]$\n  - $\\delta_{\\mathrm{phys}} = [\\,0.02,\\,-0.03\\,]$\n\n- Test C ($\\beta$-only gauge at high $k$, three modes):\n  - $k = [\\,3.0,\\,5.0,\\,7.0\\,]$\n  - $\\mathcal{H} = 0.05$, $w = 0$\n  - $\\alpha = [\\,0.0,\\,0.0,\\,0.0\\,]$, $\\alpha' = [\\,0.0,\\,0.0,\\,0.0\\,]$\n  - $\\beta = [\\,0.02,\\,-0.015,\\,0.01\\,]$, $\\beta' = [\\,-0.003,\\,0.002,\\,-0.001\\,]$, $\\beta'' = [\\,0.0004,\\,-0.0003,\\,0.0002\\,]$\n  - $\\phi_{\\mathrm{phys}} = [\\,0.005,\\,-0.004,\\,0.003\\,]$, $\\psi_{\\mathrm{phys}} = [\\,-0.001,\\,0.0015,\\,-0.0012\\,]$\n  - $B_{\\mathrm{phys}} = [\\,0.001,\\,-0.002,\\,0.0025\\,]$, $E_{\\mathrm{phys}} = [\\,0.0005,\\,-0.0007,\\,0.0009\\,]$\n  - $B'_{\\mathrm{phys}} = [\\,-0.0002,\\,0.0001,\\,-0.00015\\,]$, $E'_{\\mathrm{phys}} = [\\,0.0003,\\,-0.00025,\\,0.0002\\,]$, $E''_{\\mathrm{phys}} = [\\,-0.00005,\\,0.00004,\\,-0.00003\\,]$\n  - $\\delta_{\\mathrm{phys}} = [\\,-0.01,\\,0.015,\\,-0.02\\,]$\n\nVerification and output:\n- For each test, compute the Bardeen potentials $\\Phi$ and $\\Psi$ from the contaminated fields and from the cleaned fields. Declare each invariant check as true if the maximum absolute difference across modes is less than $10^{-12}$, and false otherwise.\n- For each test, compute the maximum absolute error across modes between the corrected density contrast (after removing its pure-gauge contribution) and the baseline $\\delta_{\\mathrm{phys}}$.\n\nFinal output format:\nYour program should produce a single line of output containing a list of results for the three test cases, where each test case contributes a three-element list of the form $[\\,\\text{phi\\_invariant},\\,\\text{psi\\_invariant},\\,\\text{delta\\_max\\_abs\\_error}\\,]$. The booleans must be lowercase literals and the float must be printed in standard decimal notation. For example: $[[\\text{true},\\text{true},0.0],[\\text{true},\\text{true},0.0],[\\text{true},\\text{true},0.0]]$.",
            "solution": "The problem requires the implementation and verification of gauge transformations for linear scalar perturbations in cosmology. The framework is a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) universe, described in conformal time $\\eta$. All calculations are performed in Fourier space, where quantities are functions of conformal time $\\eta$ and wavenumber $k$.\n\nFirst, we establish the theoretical foundation. The line element for scalar metric perturbations can be written in a general gauge as:\n$$ds^2 = a^2(\\eta) \\left[ -(1+2\\phi)d\\eta^2 - 2B_i d\\eta dx^i + \\left((1-2\\psi)\\delta_{ij} + 2E_{;ij}\\right)dx^i dx^j \\right]$$\nIn Fourier space, for a mode with wavevector $\\mathbf{k}$, the spatial vector $B_i$ and the spatial tensor $E_{;ij}$ are represented by their scalar potentials $B$ and $E$ as $B_i \\rightarrow i k_i B$ and $E_{;ij} \\rightarrow -k_i k_j E$. This yields four scalar perturbation potentials: $\\phi(\\eta, k)$, $\\psi(\\eta, k)$, $B(\\eta, k)$, and $E(\\eta, k)$.\n\nA gauge transformation corresponds to an infinitesimal coordinate transformation, $\\tilde{x}^\\mu = x^\\mu + \\xi^\\mu$. For scalar perturbations, this is defined by a time-shift function $\\alpha(\\eta)$ and a spatial-shift scalar potential $\\beta(\\eta)$, such that $\\xi^0 = \\alpha(\\eta)$ and $\\xi^i = \\nabla^i \\beta(\\eta)$. At first order in perturbations, the metric potentials transform as follows:\n$$ \\tilde{\\phi} = \\phi - \\alpha' - \\mathcal{H}\\alpha $$\n$$ \\tilde{\\psi} = \\psi + \\mathcal{H}\\alpha $$\n$$ \\tilde{B} = B + \\alpha - \\beta' $$\n$$ \\tilde{E} = E - \\beta $$\nHere, a prime denotes a derivative with respect to conformal time (e.g., $\\alpha' = d\\alpha/d\\eta$), and $\\mathcal{H} \\equiv a'/a$ is the conformal Hubble rate.\n\nThe fractional energy density perturbation, or density contrast, $\\delta \\equiv \\delta\\rho/\\rho$, is a perturbation of a background scalar field $\\rho$. It transforms as $\\tilde{\\delta} = \\delta - \\xi^0(\\rho'/\\rho)$. Using the background continuity equation $\\rho' = -3\\mathcal{H}(1+w)\\rho$ for a fluid with a constant equation-of-state parameter $w$, the transformation rule for $\\delta$ is:\n$$ \\tilde{\\delta} = \\delta + 3\\mathcal{H}(1+w)\\alpha $$\n\nWhile the individual potentials are gauge-dependent, specific combinations, known as Bardeen potentials, are gauge-invariant. These potentials, $\\Phi$ and $\\Psi$, represent the metric potentials in the longitudinal (or conformal Newtonian) gauge, where $B$ and $E$ are set to zero. They are defined in a general gauge as:\n$$ \\Psi \\equiv \\psi - \\mathcal{H}(B - E') $$\n$$ \\Phi \\equiv \\phi + (B - E')' + \\mathcal{H}(B - E') = \\phi + (B' - E'') + \\mathcal{H}(B - E') $$\n\nWe must verify that these definitions are indeed gauge-invariant. Let's analyze the transformation of the term $S \\equiv B - E'$:\n$$ \\tilde{S} = \\tilde{B} - \\tilde{E}' = (B + \\alpha - \\beta') - (E - \\beta)' = B + \\alpha - \\beta' - E' + \\beta' = (B - E') + \\alpha = S + \\alpha $$\nThe derivative of $S$ transforms as $\\tilde{S}' = (S + \\alpha)' = S' + \\alpha'$.\nNow, substituting these into the definitions of the transformed Bardeen potentials:\n$$ \\tilde{\\Psi} = \\tilde{\\psi} - \\mathcal{H}\\tilde{S} = (\\psi + \\mathcal{H}\\alpha) - \\mathcal{H}(S+\\alpha) = \\psi + \\mathcal{H}\\alpha - \\mathcal{H}S - \\mathcal{H}\\alpha = \\psi - \\mathcal{H}S = \\Psi $$\n$$ \\tilde{\\Phi} = \\tilde{\\phi} + \\tilde{S}' + \\mathcal{H}\\tilde{S} = (\\phi - \\alpha' - \\mathcal{H}\\alpha) + (S' + \\alpha') + \\mathcal{H}(S+\\alpha) = \\phi - \\alpha' - \\mathcal{H}\\alpha + S' + \\alpha' + \\mathcal{H}S + \\mathcal{H}\\alpha = \\phi + S' + \\mathcal{H}S = \\Phi $$\nThe invariance is confirmed.\n\nThe program will implement this theoretical framework. The core algorithm is as follows:\n1.  For each test case, take the provided baseline \"physical\" fields ($\\phi_{\\mathrm{phys}}$, $\\psi_{\\mathrm{phys}}$, etc.) and gauge generators ($\\alpha$, $\\beta$, and their derivatives).\n2.  Calculate the pure-gauge contributions to each field. These act as a projection operator onto the pure-gauge sector of the perturbation space.\n    - $\\phi_{\\text{gauge}} = - (\\alpha' + \\mathcal{H}\\alpha)$\n    - $\\psi_{\\text{gauge}} = \\mathcal{H}\\alpha$\n    - $B_{\\text{gauge}} = \\alpha - \\beta'$\n    - $E_{\\text{gauge}} = -\\beta$\n    - $\\delta_{\\text{gauge}} = +3\\mathcal{H}(1+w)\\alpha$\n3.  Generate the \"contaminated\" fields by adding the gauge contributions to the physical fields (e.g., $\\phi_{\\text{cont}} = \\phi_{\\text{phys}} + \\phi_{\\text{gauge}}$).\n4.  Calculate the necessary derivatives of the contaminated fields using the provided derivatives of the physical fields and gauge generators. For example, $B'_{\\text{cont}} = (B_{\\text{phys}} + B_{\\text{gauge}})' = B'_{\\text{phys}} + \\alpha' - \\beta''$ and $E''_{\\text{cont}} = (E_{\\text{phys}} + E_{\\text{gauge}})'' = E''_{\\text{phys}} - \\beta''$.\n5.  Compute the Bardeen potentials $\\Phi$ and $\\Psi$ for both the physical set of fields and the contaminated set.\n6.  Numerically verify that $\\Phi_{\\text{cont}} \\approx \\Phi_{\\text{phys}}$ and $\\Psi_{\\text{cont}} \\approx \\Psi_{\\text{phys}}$ to within a tolerance of $10^{-12}$.\n7.  Clean the contaminated density contrast by subtracting its gauge part: $\\delta_{\\text{cleaned}} = \\delta_{\\text{cont}} - \\delta_{\\text{gauge}}$.\n8.  Calculate and report the maximum absolute error between the cleaned density contrast and the original physical density contrast, $||\\delta_{\\text{cleaned}} - \\delta_{\\text{phys}}||_\\infty$.\nThe calculations are performed in a vectorized manner over the given arrays of Fourier modes $k$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for cosmological gauge transformations.\n    \"\"\"\n    \n    test_cases = [\n        # Test A: General mixed gauge, three modes\n        {\n            \"k\": np.array([0.25, 0.5, 1.0]),\n            \"H_conf\": 0.2, \"w\": 0.0,\n            \"alpha\": np.array([0.1, -0.05, 0.02]), \"alpha_prime\": np.array([0.01, 0.02, -0.03]),\n            \"beta\": np.array([0.3, -0.1, 0.05]), \"beta_prime\": np.array([0.02, -0.01, 0.04]), \"beta_pprime\": np.array([-0.005, 0.003, -0.002]),\n            \"phi_phys\": np.array([0.01, -0.02, 0.03]), \"psi_phys\": np.array([-0.005, 0.004, -0.002]),\n            \"B_phys\": np.array([0.02, 0.01, -0.01]), \"E_phys\": np.array([0.015, -0.01, 0.005]),\n            \"B_prime_phys\": np.array([0.001, -0.002, 0.003]), \"E_prime_phys\": np.array([0.002, 0.001, -0.0015]), \"E_pprime_phys\": np.array([-0.0005, 0.0003, 0.0002]),\n            \"delta_phys\": np.array([0.1, -0.2, 0.05])\n        },\n        # Test B: alpha-only gauge with a super-horizon mode, two modes\n        {\n            \"k\": np.array([0.0, 0.7]),\n            \"H_conf\": 0.1, \"w\": 1/3,\n            \"alpha\": np.array([-0.03, 0.04]), \"alpha_prime\": np.array([0.002, -0.001]),\n            \"beta\": np.array([0.0, 0.0]), \"beta_prime\": np.array([0.0, 0.0]), \"beta_pprime\": np.array([0.0, 0.0]),\n            \"phi_phys\": np.array([-0.02, 0.01]), \"psi_phys\": np.array([0.003, -0.004]),\n            \"B_phys\": np.array([0.0, -0.005]), \"E_phys\": np.array([0.0, 0.002]),\n            \"B_prime_phys\": np.array([0.0, 0.0004]), \"E_prime_phys\": np.array([0.0, -0.0003]), \"E_pprime_phys\": np.array([0.0, 0.00005]),\n            \"delta_phys\": np.array([0.02, -0.03])\n        },\n        # Test C: beta-only gauge at high k, three modes\n        {\n            \"k\": np.array([3.0, 5.0, 7.0]),\n            \"H_conf\": 0.05, \"w\": 0.0,\n            \"alpha\": np.array([0.0, 0.0, 0.0]), \"alpha_prime\": np.array([0.0, 0.0, 0.0]),\n            \"beta\": np.array([0.02, -0.015, 0.01]), \"beta_prime\": np.array([-0.003, 0.002, -0.001]), \"beta_pprime\": np.array([0.0004, -0.0003, 0.0002]),\n            \"phi_phys\": np.array([0.005, -0.004, 0.003]), \"psi_phys\": np.array([-0.001, 0.0015, -0.0012]),\n            \"B_phys\": np.array([0.001, -0.002, 0.0025]), \"E_phys\": np.array([0.0005, -0.0007, 0.0009]),\n            \"B_prime_phys\": np.array([-0.0002, 0.0001, -0.00015]), \"E_prime_phys\": np.array([0.0003, -0.00025, 0.0002]), \"E_pprime_phys\": np.array([-0.00005, 0.00004, -0.00003]),\n            \"delta_phys\": np.array([-0.01, 0.015, -0.02])\n        }\n    ]\n\n    final_results = []\n    for case in test_cases:\n        result = run_test_case(case)\n        final_results.append(result)\n\n    # Format the final output string exactly as required\n    result_strings = [\n        f\"[{str(r[0]).lower()},{str(r[1]).lower()},{r[2]}]\" for r in final_results\n    ]\n    print(f\"[{','.join(result_strings)}]\")\n\ndef compute_bardeen_potentials(phi, psi, B, B_prime, E_prime, E_pprime, H_conf):\n    \"\"\"\n    Computes the gauge-invariant Bardeen potentials Phi and Psi.\n    \"\"\"\n    S = B - E_prime\n    S_prime = B_prime - E_pprime\n    \n    Psi = psi - H_conf * S\n    Phi = phi + S_prime + H_conf * S\n    \n    return Phi, Psi\n\ndef run_test_case(params):\n    \"\"\"\n    Processes a single test case.\n    \"\"\"\n    H_conf = params[\"H_conf\"]\n    w = params[\"w\"]\n\n    # Gauge generators\n    alpha = params[\"alpha\"]\n    alpha_prime = params[\"alpha_prime\"]\n    beta = params[\"beta\"]\n    beta_prime = params[\"beta_prime\"]\n    beta_pprime = params[\"beta_pprime\"]\n\n    # Physical fields\n    phi_phys = params[\"phi_phys\"]\n    psi_phys = params[\"psi_phys\"]\n    B_phys = params[\"B_phys\"]\n    E_phys = params[\"E_phys\"]\n    B_prime_phys = params[\"B_prime_phys\"]\n    E_prime_phys = params[\"E_prime_phys\"]\n    E_pprime_phys = params[\"E_pprime_phys\"]\n    delta_phys = params[\"delta_phys\"]\n\n    # 1. Compute Bardeen potentials for physical fields\n    Phi_phys, Psi_phys = compute_bardeen_potentials(\n        phi_phys, psi_phys, B_phys, B_prime_phys, E_prime_phys, E_pprime_phys, H_conf\n    )\n\n    # 2. Compute pure-gauge contributions\n    phi_gauge = - (alpha_prime + H_conf * alpha)\n    psi_gauge = H_conf * alpha\n    B_gauge = alpha - beta_prime\n    E_gauge = -beta\n    delta_gauge = 3 * H_conf * (1 + w) * alpha\n\n    # 3. Create contaminated fields\n    phi_cont = phi_phys + phi_gauge\n    psi_cont = psi_phys + psi_gauge\n    B_cont = B_phys + B_gauge\n    E_cont = E_phys + E_gauge\n    delta_cont = delta_phys + delta_gauge\n\n    # 4. Compute derivatives of contaminated fields\n    B_prime_cont = B_prime_phys + alpha_prime - beta_pprime\n    E_prime_cont = E_prime_phys - beta_prime\n    E_pprime_cont = E_pprime_phys - beta_pprime\n    \n    # 5. Compute Bardeen potentials for contaminated fields\n    Phi_cont, Psi_cont = compute_bardeen_potentials(\n        phi_cont, psi_cont, B_cont, B_prime_cont, E_prime_cont, E_pprime_cont, H_conf\n    )\n\n    # 6. Verify invariance\n    tolerance = 1e-12\n    phi_invariant = np.allclose(Phi_phys, Phi_cont, atol=tolerance, rtol=0)\n    psi_invariant = np.allclose(Psi_phys, Psi_cont, atol=tolerance, rtol=0)\n    \n    # 7. Verify density contrast cleaning\n    delta_cleaned = delta_cont - delta_gauge\n    delta_max_abs_error = np.max(np.abs(delta_cleaned - delta_phys))\n    \n    return [phi_invariant, psi_invariant, delta_max_abs_error]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "While some gauge choices simplify the Einstein equations, they often leave behind unphysical 'residual' gauge modes that can contaminate physical results. This practice  focuses on the widely used synchronous gauge and challenges you to construct the gauge-invariant comoving density contrast, $\\Delta$, from the gauge-dependent density and velocity perturbations. This skill is crucial for extracting physical information from numerical simulations performed in this gauge, especially on large, superhorizon scales.",
            "id": "3473450",
            "problem": "You are given the task to design and implement Fourier-space gauge mode projectors for scalar cosmological perturbations that remove residual synchronous gauge modes and recover a gauge-invariant comoving density contrast on large scales. Work in a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) background with linear scalar perturbations and a single perfect fluid with constant equation-of-state parameter $w$. Consider a fixed time slice so that all quantities depend only on Fourier wavevector magnitude $k \\equiv \\lvert \\mathbf{k} \\rvert$.\n\nUse the following foundational statements as your starting point:\n- Under an infinitesimal scalar gauge transformation generated by a time shift parameter $\\alpha(\\mathbf{k})$, at first order in perturbations and in Fourier space, the synchronous gauge residual freedom acts on the matter variables as:\n  - $\\delta \\rightarrow \\delta + 3 (1+w)\\, \\mathcal{H}\\, \\alpha$,\n  - $\\theta \\rightarrow \\theta - k^{2} \\alpha$,\n  where $\\delta(\\mathbf{k})$ is the density contrast, $\\theta(\\mathbf{k})$ is the velocity divergence, and $\\mathcal{H}$ is the conformal Hubble parameter. This residual freedom arises because synchronous gauge does not uniquely fix the time slicing.\n- Define the velocity divergence by $\\theta(\\mathbf{k}) \\equiv k^{2} v(\\mathbf{k})$, where $v$ is the velocity potential.\n- The comoving density contrast is a gauge-invariant quantity (in the sense of Bardeen’s construction of gauge-invariant variables) that can be expressed as a linear functional of $\\delta$ and $\\theta$. You must derive its form from the transformation rules above.\n\nYour tasks:\n1. Derive, from first principles using the stated transformation laws, a Fourier-space linear functional $p(\\mathbf{k})$ acting on the pair $(\\delta(\\mathbf{k}), \\theta(\\mathbf{k}))$ such that:\n   - The functional annihilates any pure residual synchronous gauge mode generated by an arbitrary $\\alpha(\\mathbf{k})$, i.e., it yields zero when applied to $(3(1+w)\\mathcal{H}\\alpha, -k^{2}\\alpha)$.\n   - The functional recovers the gauge-invariant comoving density contrast, denoted by $\\Delta(\\mathbf{k})$, when applied to general $(\\delta(\\mathbf{k}), \\theta(\\mathbf{k}))$.\n2. Implement this functional as a projector in code that takes $(\\delta, \\theta, \\mathcal{H}, w, k)$ and returns the scalar $\\Delta$. Also implement a contamination operator that adds a pure residual synchronous gauge mode of amplitude $\\alpha$ to $(\\delta, \\theta)$ via the transformation rules above.\n3. Demonstrate, with a reproducible numerical test suite, that:\n   - The projector output $\\Delta$ is invariant under addition of any residual synchronous gauge mode, for multiple values of $k$ and $\\alpha$.\n   - On large scales (small $k$), the recovered $\\Delta$ matches the underlying physical density contrast used to generate the test data, even when the synchronous-gauge input $(\\delta, \\theta)$ is heavily contaminated by a large gauge mode.\n\nNumerical specifications:\n- Work with dimensionless quantities at a fixed time where $\\mathcal{H}$ is a specified constant. No physical unit conversion is required.\n- The program must be self-contained and run without external input.\n- Use an absolute tolerance of $10^{-12}$ when comparing floating-point equality for invariance tests.\n\nTest suite to implement and evaluate:\n- Case 1 (baseline computation): $(\\delta, \\theta, \\mathcal{H}, w, k) = (0.1, -10^{-4}, 100, 0, 10^{-2})$. Return the computed $\\Delta$ as a floating-point number.\n- Case 2 (invariance under gauge contamination): Start from the Case 1 physical pair and contaminate it with gauge amplitude $\\alpha = 0.5$ to obtain $(\\delta', \\theta') = (\\delta + 3(1+w)\\mathcal{H}\\alpha, \\theta - k^{2}\\alpha)$. Return a boolean indicating whether the projector output on $(\\delta', \\theta')$ equals the projector output on $(\\delta, \\theta)$ within the specified tolerance.\n- Case 3 (large-scale recovery): $(\\delta_{\\text{phys}}, \\theta_{\\text{phys}}, \\mathcal{H}, w, k, \\alpha) = (0.7, 0.0, 100, 0, 10^{-5}, 300)$. Construct contaminated inputs $(\\delta', \\theta')$ as above and return a boolean indicating whether the projector output equals $0.7$ within the specified tolerance.\n- Case 4 (extreme super-horizon stability): $(\\delta_{\\text{phys}}, \\theta_{\\text{phys}}, \\mathcal{H}, w, k, \\alpha) = (0.3, 0.0, 100, 0, 10^{-8}, 10^{6})$. Construct contaminated inputs and return a boolean indicating whether the projector output equals $0.3$ within the specified tolerance.\n\nFinal output format:\n- Your program should produce a single line of output containing the results of Cases 1–4 as a comma-separated list enclosed in square brackets, i.e., $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$, where $\\text{result}_1$ is a float and $\\text{result}_2$, $\\text{result}_3$, and $\\text{result}_4$ are booleans.",
            "solution": "The user has provided a problem in the field of numerical cosmology, specifically concerning gauge choices and the construction of gauge-invariant variables for linear scalar perturbations.\n\n### Problem Validation\n\nFirst, I will validate the problem statement according to the specified criteria.\n\n**Step 1: Extract Givens**\n-   **Physical System**: A spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) background with a single perfect fluid.\n-   **Fluid Property**: Constant equation-of-state parameter $w$.\n-   **Perturbation Type**: Linear scalar perturbations.\n-   **Domain**: Fourier space at a fixed time, where quantities depend only on wavenumber $k \\equiv |\\mathbf{k}|$.\n-   **Gauge Transformation Rules**: For a residual synchronous gauge transformation generated by $\\alpha(\\mathbf{k})$:\n    -   Density contrast: $\\delta \\rightarrow \\delta + 3 (1+w)\\, \\mathcal{H}\\, \\alpha$.\n    -   Velocity divergence: $\\theta \\rightarrow \\theta - k^{2} \\alpha$.\n-   **Definitions**:\n    -   $\\delta(\\mathbf{k})$: density contrast.\n    -   $\\theta(\\mathbf{k})$: velocity divergence.\n    -   $\\mathcal{H}$: conformal Hubble parameter.\n    -   $\\theta(\\mathbf{k}) \\equiv k^{2} v(\\mathbf{k})$, where $v$ is the velocity potential.\n-   **Objective**: Derive and implement a linear functional $p(\\mathbf{k})$ that acts on $(\\delta, \\theta)$ to produce the gauge-invariant comoving density contrast, $\\Delta(\\mathbf{k})$.\n-   **Conditions for the Functional**:\n    1.  It must annihilate pure residual synchronous gauge modes, i.e., $p(3(1+w)\\mathcal{H}\\alpha, -k^{2}\\alpha) = 0$.\n    2.  It recovers $\\Delta(\\mathbf{k})$ when applied to a general pair $(\\delta(\\mathbf{k}), \\theta(\\mathbf{k}))$.\n-   **Numerical Specifications**:\n    -   Dimensionless quantities, fixed time with constant $\\mathcal{H}$.\n    -   Absolute tolerance for floating-point comparisons: $10^{-12}$.\n-   **Test Suite**:\n    1.  **Case 1**: $(\\delta, \\theta, \\mathcal{H}, w, k) = (0.1, -10^{-4}, 100, 0, 10^{-2})$. Compute $\\Delta$.\n    2.  **Case 2**: Use Case 1 values and contaminate with $\\alpha = 0.5$. Test for invariance of $\\Delta$.\n    3.  **Case 3**: $(\\delta_{\\text{phys}}, \\theta_{\\text{phys}}, \\mathcal{H}, w, k, \\alpha) = (0.7, 0.0, 100, 0, 10^{-5}, 300)$. Test if recovered $\\Delta$ equals $0.7$.\n    4.  **Case 4**: $(\\delta_{\\text{phys}}, \\theta_{\\text{phys}}, \\mathcal{H}, w, k, \\alpha) = (0.3, 0.0, 100, 0, 10^{-8}, 10^{6})$. Test if recovered $\\Delta$ equals $0.3$.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The problem is set within the standard, well-established framework of cosmological perturbation theory. The gauge transformation laws for $\\delta$ and $\\theta$ in synchronous gauge are canonical results (see, e.g., Ma & Bertschinger, ApJ 455, 7, 1995). The construction of gauge-invariant variables like the comoving density contrast is a fundamental technique in this field. The problem is scientifically sound.\n-   **Well-Posedness**: The problem is well-posed. The task is to find a linear functional based on specific invariance conditions. These conditions are sufficient to uniquely determine the functional. All required parameters for the numerical tests are provided. A unique and meaningful solution exists.\n-   **Objectivity**: The problem is stated in precise, objective language common to physics and mathematics. All terms are standard and well-defined.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is a standard, non-trivial exercise in theoretical cosmology that is well-defined and factually correct. I will proceed with the solution.\n\n### Derivation of the Gauge-Invariant Functional\n\nThe goal is to find a linear functional, let's call it $p$, that combines the gauge-dependent quantities $\\delta(\\mathbf{k})$ and $\\theta(\\mathbf{k})$ into a gauge-invariant quantity, the comoving density contrast $\\Delta(\\mathbf{k})$. A linear functional of $(\\delta, \\theta)$ will have the general form:\n$$\n\\Delta(\\mathbf{k}) = A(\\mathbf{k}) \\delta(\\mathbf{k}) + B(\\mathbf{k}) \\theta(\\mathbf{k})\n$$\nwhere $A(\\mathbf{k})$ and $B(\\mathbf{k})$ are coefficients that can depend on the wavenumber $k$ and background quantities like $\\mathcal{H}$ and $w$. Since we are in an isotropic background, these coefficients will only depend on the magnitude $k=|\\mathbf{k}|$.\n\nThe core requirement is that $\\Delta(k)$ must be invariant under the specified residual synchronous gauge transformation. Let's denote the transformed quantities as $\\delta'$ and $\\theta'$:\n$$ \\delta' = \\delta + 3(1+w)\\mathcal{H}\\alpha $$\n$$ \\theta' = \\theta - k^2\\alpha $$\nThe gauge-invariant quantity $\\Delta$ calculated with the transformed variables, $\\Delta'$, must be equal to the one calculated with the original variables, $\\Delta$.\n$$\n\\Delta' = A(k)\\delta' + B(k)\\theta'\n$$\nSubstituting the transformation rules:\n$$\n\\Delta' = A(k) \\left( \\delta + 3(1+w)\\mathcal{H}\\alpha \\right) + B(k) \\left( \\theta - k^2\\alpha \\right)\n$$\nRearranging the terms:\n$$\n\\Delta' = \\left( A(k)\\delta + B(k)\\theta \\right) + \\left[ A(k) \\cdot 3(1+w)\\mathcal{H} - B(k) \\cdot k^2 \\right] \\alpha\n$$\nThe first term is simply the original $\\Delta$. For $\\Delta' = \\Delta$ to hold for any arbitrary gauge transformation parameter $\\alpha(k) \\neq 0$, the coefficient of $\\alpha(k)$ must vanish identically:\n$$\n3(1+w)\\mathcal{H} A(k) - k^2 B(k) = 0\n$$\nThis equation provides a relationship between the coefficients $A(k)$ and $B(k)$:\n$$\nB(k) = \\frac{3(1+w)\\mathcal{H}}{k^2} A(k)\n$$\nSubstituting this back into the expression for $\\Delta$:\n$$\n\\Delta(k) = A(k) \\delta + \\left( \\frac{3(1+w)\\mathcal{H}}{k^2} A(k) \\right) \\theta = A(k) \\left( \\delta + \\frac{3(1+w)\\mathcal{H}}{k^2} \\theta \\right)\n$$\nThe overall normalization factor $A(k)$ is fixed by the physical definition of the comoving density contrast. The comoving density contrast is defined as the density perturbation in the reference frame comoving with the fluid. In this frame, the fluid's peculiar velocity, and thus its divergence $\\theta$, is zero by definition.\nWe can find the required gauge transformation parameter $\\alpha$ to transform from our initial synchronous gauge to this comoving gauge. The condition is that the new velocity divergence $\\theta'$ must be zero:\n$$\n\\theta' = \\theta - k^2 \\alpha = 0 \\implies \\alpha = \\frac{\\theta}{k^2}\n$$\nIn this new comoving frame, the density contrast $\\delta'$ is, by definition, the comoving density contrast $\\Delta$. Let's calculate its value:\n$$\n\\Delta = \\delta' = \\delta + 3(1+w)\\mathcal{H}\\alpha = \\delta + 3(1+w)\\mathcal{H} \\frac{\\theta}{k^2}\n$$\nComparing this result with our derived form $\\Delta(k) = A(k) \\left( \\delta + \\frac{3(1+w)\\mathcal{H}}{k^2} \\theta \\right)$, we can identify the normalization factor as $A(k) = 1$.\n\nTherefore, the gauge-invariant comoving density contrast is given by the functional:\n$$\n\\Delta(k) = \\delta(k) + \\frac{3(1+w)\\mathcal{H}}{k^2} \\theta(k)\n$$\nThis is the required projector functional $p(k)$.\n\nLet's verify that it annihilates a pure gauge mode $(\\delta_g, \\theta_g) = (3(1+w)\\mathcal{H}\\alpha, -k^2\\alpha)$:\n$$\np(\\delta_g, \\theta_g) = \\delta_g + \\frac{3(1+w)\\mathcal{H}}{k^2} \\theta_g = \\left(3(1+w)\\mathcal{H}\\alpha\\right) + \\frac{3(1+w)\\mathcal{H}}{k^2} \\left(-k^2\\alpha\\right)\n$$\n$$\n= 3(1+w)\\mathcal{H}\\alpha - 3(1+w)\\mathcal{H}\\alpha = 0\n$$\nThe condition is satisfied. The derivation is complete and correct.\n\n### Implementation and Numerical Demonstration\n\nThe implementation will consist of two primary functions: one to apply the derived projector and another to apply the gauge contamination. These will be used to run the specified test suite.\n\n1.  **Projector Function**: `projector(delta, theta, H, w, k)` will calculate $\\Delta = \\delta + \\frac{3(1+w)\\mathcal{H}}{k^2}\\theta$.\n2.  **Contamination Function**: `contaminate(delta, theta, H, w, k, alpha)` will calculate $(\\delta', \\theta') = (\\delta + 3(1+w)\\mathcal{H}\\alpha, \\theta - k^2\\alpha)$.\n3.  **Test Suite**: The main routine will execute the four test cases described in the problem statement, comparing floating-point numbers with an absolute tolerance of $10^{-12}$. The test cases verify the direct computation, the invariance property, and the accuracy of recovery on large scales where synchronous gauge modes can be large. The challenges posed by cases 3 and 4, which involve the subtraction of very large numbers (a potential source of catastrophic cancellation), are correctly handled by the analytical formula.\nThe final program implements this logic and prints the results in the required format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements Fourier-space gauge mode projectors for scalar\n    cosmological perturbations and runs a numerical test suite.\n    \"\"\"\n\n    TOLERANCE = 1e-12\n\n    def projector(delta, theta, H, w, k):\n        \"\"\"\n        Applies a projector to recover the gauge-invariant comoving density contrast.\n        \n        The formula is Delta = delta + 3 * (1+w) * H / k^2 * theta.\n        \n        Args:\n            delta (float): The synchronous gauge density contrast.\n            theta (float): The synchronous gauge velocity divergence.\n            H (float): The conformal Hubble parameter.\n            w (float): The equation-of-state parameter of the fluid.\n            k (float): The magnitude of the Fourier wavevector.\n            \n        Returns:\n            float: The gauge-invariant comoving density contrast Delta.\n        \"\"\"\n        if k == 0:\n            # For k=0, the expression is ill-defined. In physical scenarios,\n            # for growing modes on superhorizon scales, theta is proportional to k^2,\n            # so the ratio is finite. Test cases here have k > 0.\n            raise ValueError(\"Wavenumber k cannot be zero.\")\n        return delta + 3.0 * (1.0 + w) * H / (k**2) * theta\n\n    def contaminate(delta, theta, H, w, k, alpha):\n        \"\"\"\n        Adds a pure residual synchronous gauge mode to a set of perturbations.\n        \n        The transformations are:\n        delta' = delta + 3 * (1+w) * H * alpha\n        theta' = theta - k^2 * alpha\n        \n        Args:\n            delta (float): The initial density contrast.\n            theta (float): The initial velocity divergence.\n            H (float): The conformal Hubble parameter.\n            w (float): The equation-of-state parameter.\n            k (float): The magnitude of the Fourier wavevector.\n            alpha (float): The amplitude of the gauge mode.\n            \n        Returns:\n            tuple[float, float]: The contaminated (delta', theta') pair.\n        \"\"\"\n        delta_prime = delta + 3.0 * (1.0 + w) * H * alpha\n        theta_prime = theta - k**2 * alpha\n        return delta_prime, theta_prime\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Baseline computation\n        {'type': 'baseline', 'params': {'delta': 0.1, 'theta': -1e-4, 'H': 100.0, 'w': 0.0, 'k': 1e-2}},\n        \n        # Case 2: Invariance under gauge contamination\n        {'type': 'invariance', 'params': {'delta': 0.1, 'theta': -1e-4, 'H': 100.0, 'w': 0.0, 'k': 1e-2, 'alpha': 0.5}},\n        \n        # Case 3: Large-scale recovery\n        {'type': 'recovery', 'params': {'delta_phys': 0.7, 'theta_phys': 0.0, 'H': 100.0, 'w': 0.0, 'k': 1e-5, 'alpha': 300.0, 'target': 0.7}},\n        \n        # Case 4: Extreme super-horizon stability\n        {'type': 'recovery', 'params': {'delta_phys': 0.3, 'theta_phys': 0.0, 'H': 100.0, 'w': 0.0, 'k': 1e-8, 'alpha': 1e6, 'target': 0.3}}\n    ]\n\n    results = []\n    for case in test_cases:\n        case_type = case['type']\n        params = case['params']\n        \n        if case_type == 'baseline':\n            # Main logic to calculate the result for one case goes here.\n            delta_val = projector(params['delta'], params['theta'], params['H'], params['w'], params['k'])\n            results.append(delta_val)\n            \n        elif case_type == 'invariance':\n            # Calculate projector output on original pair\n            delta_orig = projector(params['delta'], params['theta'], params['H'], params['w'], params['k'])\n            \n            # Contaminate the pair\n            delta_c, theta_c = contaminate(\n                params['delta'], params['theta'], params['H'], params['w'], params['k'], params['alpha']\n            )\n            \n            # Calculate projector output on contaminated pair\n            delta_cont = projector(delta_c, theta_c, params['H'], params['w'], params['k'])\n            \n            # Check for equality within tolerance\n            is_invariant = np.abs(delta_orig - delta_cont) = TOLERANCE\n            results.append(is_invariant)\n            \n        elif case_type == 'recovery':\n            # Construct contaminated inputs from the physical ones\n            delta_c, theta_c = contaminate(\n                params['delta_phys'], params['theta_phys'], params['H'], params['w'], params['k'], params['alpha']\n            )\n            \n            # Apply projector to recover the physical value\n            delta_recovered = projector(delta_c, theta_c, params['H'], params['w'], params['k'])\n            \n            # Check if recovered value matches the target\n            is_recovered = np.abs(delta_recovered - params['target']) = TOLERANCE\n            results.append(is_recovered)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A physical law that holds in the continuous world of theory can be broken by the discrete nature of computation. This numerical experiment  explores this crucial idea using the constraint $\\Phi = \\Psi$, which holds in the absence of anisotropic stress. By evolving two fields that represent $\\Phi$ and $\\Psi$ with different numerical schemes—one highly accurate (spectral) and one more diffusive (finite-difference)—you will quantify how discretization error can manifest as a violation of a fundamental gauge-invariant relationship.",
            "id": "3473448",
            "problem": "You are asked to design and implement a numerical experiment in which the preservation of gauge invariance is quantified by comparing two distinct spatial discretizations for evolving a gauge-invariant scalar potential. The experiment should be rooted in a fundamental cosmology principle: in the absence of anisotropic stress, the two Bardeen potentials are equal. The goal is to compute the difference between two numerically evolved fields that are supposed to remain equal in the continuum limit and use this to assess how discretization choices can spuriously break gauge invariance.\n\nFoundational base and objective:\n- In linear cosmological perturbation theory on a spatially flat Friedman–Lemaître–Robertson–Walker background, the gauge-invariant Bardeen potentials, the scalar gravitational potentials usually denoted by $\\Phi$ and $\\Psi$, satisfy the traceless part of the Einstein field equations. In the absence of anisotropic stress, $\\sigma = 0$, the constraint enforces $\\Phi - \\Psi = 0$ for all times.\n- To isolate the numerical effect of different spatial discretizations, model the evolution of a single gauge-invariant scalar field $U(x,\\eta)$ that both $\\Phi$ and $\\Psi$ are constrained to equal when $\\sigma = 0$. Use a linear conservative transport Partial Differential Equation (PDE), $\\partial_\\eta U + c\\,\\partial_x U = 0$, on a one-dimensional periodic domain. This PDE preserves the shape of $U$ and is compatible with the idea that both $\\Phi$ and $\\Psi$ obey identical linear dynamics when $\\sigma = 0$, hence the exact solution implies $\\Phi(x,\\eta) - \\Psi(x,\\eta) = 0$ for all $\\eta$.\n- Numerically, evolve $U$ twice from identical initial data: once using a finite-difference spatial derivative and once using a spectral derivative. Identify $\\Phi$ with the spectral evolution and $\\Psi$ with the finite-difference evolution so that any nonzero $\\Phi - \\Psi$ is purely numerical, serving as a measure of discrete gauge-invariance violation.\n\nMathematical and algorithmic setup:\n- Consider a one-dimensional periodic interval $x \\in [0,L)$ discretized into $N$ uniform points with grid spacing $\\Delta x = L/N$.\n- Use the advection PDE $\\partial_\\eta U + c\\,\\partial_x U = 0$ with constant advection speed $c$ over dimensionless time $\\eta \\in [0,T]$.\n- Initialize with a single Fourier mode $U(x,0) = A \\cos(k_m x)$, where $k_m = \\frac{2\\pi m}{L}$, amplitude $A$, and integer mode number $m$.\n- Evolve the PDE with the method-of-lines and a Fourth-Order Runge–Kutta (RK4) time integrator:\n  - For the finite-difference spatial discretization, use a first-order upwind derivative: if $c \\ge 0$, $\\partial_x U \\approx \\frac{U_i - U_{i-1}}{\\Delta x}$; if $c  0$, $\\partial_x U \\approx \\frac{U_{i+1} - U_i}{\\Delta x}$. Impose periodic boundary conditions by indexing modulo $N$.\n  - For the spectral spatial discretization, compute $\\partial_x U$ via the Fast Fourier Transform (FFT): for discrete frequencies $k_n = \\frac{2\\pi n}{L}$ with $n \\in \\{-\\lfloor N/2 \\rfloor,\\ldots,\\lfloor (N-1)/2 \\rfloor\\}$, use $\\mathcal{F}\\{\\partial_x U\\}(k_n) = i k_n \\mathcal{F}\\{U\\}(k_n)$, then invert the FFT to obtain $\\partial_x U$ in real space. Impose periodic boundary conditions naturally via the Fourier basis.\n- Let $\\Phi(x,\\eta)$ be the field evolved using the spectral derivative and $\\Psi(x,\\eta)$ be the field evolved using the finite-difference derivative. Define the numerical gauge-invariance violation at final time $T$ as the Root Mean Square (RMS) difference\n$$\nE = \\left( \\frac{1}{N} \\sum_{i=0}^{N-1} \\left[\\Phi(x_i,T) - \\Psi(x_i,T)\\right]^2 \\right)^{1/2}.\n$$\nAll quantities are dimensionless.\n\nTask:\n- Implement a program that performs the above numerical experiment for a set of test cases and outputs the RMS difference $E$ for each case, thereby quantifying how well each discretization preserves the equality $\\Phi - \\Psi = 0$ implied by $\\sigma = 0$.\n- Use the CFL-type prescription for the time step: choose $\\Delta \\eta = \\text{CFL} \\times \\Delta x / |c|$ per test. The RK4 time step must subdivide the total time $T$ into an integer number of steps $n_{\\text{steps}}$, i.e., $\\Delta \\eta = T / n_{\\text{steps}}$.\n\nTest suite:\n- Provide results for the following four test cases, which together assess general behavior, coarse resolution, high-frequency content, and short-time evolution. For each case, compute the RMS difference $E$ at time $T$.\n  - Case $1$ (happy path):\n    - $N = 128$, $L = 2\\pi$, $c = +1$, $A = 10^{-3}$, $m = 3$, $T = 1$, $\\text{CFL} = 0.5$.\n  - Case $2$ (coarse grid near-CFL):\n    - $N = 16$, $L = 2\\pi$, $c = +1$, $A = 10^{-3}$, $m = 3$, $T = 1$, $\\text{CFL} = 0.95$.\n  - Case $3$ (negative advection and higher mode number):\n    - $N = 64$, $L = 2\\pi$, $c = -1$, $A = 10^{-3}$, $m = 16$, $T = 1$, $\\text{CFL} = 0.5$.\n  - Case $4$ (fine grid, short-time, low mode number):\n    - $N = 256$, $L = 2\\pi$, $c = +1$, $A = 10^{-3}$, $m = 1$, $T = 0.1$, $\\text{CFL} = 0.2$.\n\nFinal output format:\n- Your program should produce a single line of output containing the RMS differences $E$ for all four test cases as a comma-separated list enclosed in square brackets, for example, $\\left[ e_1, e_2, e_3, e_4 \\right]$ where each $e_j$ is a floating-point number. No other text should be printed.\n- All quantities are dimensionless; do not include any physical units. Angles (implicitly appearing in trigonometric functions) are in radians. Express the outputs as raw decimal floating-point values.",
            "solution": "We begin from a principle in linear cosmological perturbation theory: the gauge-invariant Bardeen potentials $\\Phi$ and $\\Psi$ in a spatially flat Friedman–Lemaître–Robertson–Walker universe satisfy the traceless part of the Einstein field equations. When anisotropic stress $\\sigma = 0$, the constraint implies $\\Phi - \\Psi = 0$ at all times. This is a statement of gauge invariance: the two gauge-invariant variables coincide in the absence of sources of anisotropy.\n\nTo isolate numerical effects, we consider a linear conservative transport Partial Differential Equation (PDE) that evolves a single scalar field $U(x,\\eta)$ under\n$$\n\\partial_\\eta U + c\\,\\partial_x U = 0,\n$$\non a periodic domain $x \\in [0,L)$ and time interval $\\eta \\in [0,T]$. This choice has three features relevant to the numerical experiment:\n- It is linear and supports exact transport of Fourier modes, allowing controlled initial data and a known behavior under exact dynamics.\n- It models the case in which both $\\Phi$ and $\\Psi$ obey identical evolution when $\\sigma = 0$, so the continuum result is $\\Phi - \\Psi = 0$ at all times provided both start from identical initial conditions.\n- Any numerical discrepancy at later times between the two fields must be due to discretization choices and not physics, allowing us to quantify the impact of finite-difference versus spectral derivatives on preserving the equality.\n\nWe discretize the spatial domain with $N$ points, spacing $\\Delta x = L/N$, and impose periodic boundary conditions. We initialize with a single Fourier mode\n$$\nU(x,0) = A \\cos(k_m x), \\quad \\text{where } k_m = \\frac{2\\pi m}{L},\n$$\nand $A$ and $m$ are given constants. We evolve $U$ using the method of lines and a Fourth-Order Runge–Kutta (RK4) time integrator, with a time step $\\Delta \\eta$ chosen via a Courant–Friedrichs–Lewy (CFL)-type prescription $\\Delta \\eta = \\text{CFL} \\times \\Delta x / |c|$. To ensure the final time $T$ is reached exactly, we set the number of steps $n_{\\text{steps}} = \\lceil T / \\Delta \\eta \\rceil$ and then define the RK4 step size as $\\Delta \\eta = T / n_{\\text{steps}}$.\n\nWe perform two evolutions:\n- Spectral derivative (identifying the result as $\\Phi$): compute $\\partial_x U$ using the Fast Fourier Transform (FFT). For discrete wave numbers $k_n = \\frac{2\\pi n}{L}$ with $n \\in \\{ -\\lfloor N/2 \\rfloor,\\dots,\\lfloor (N-1)/2 \\rfloor \\}$ mapped via the standard discrete Fourier transform frequency layout, the derivative in Fourier space is\n$$\n\\widehat{\\partial_x U}(k_n) = i \\, k_n \\, \\widehat{U}(k_n),\n$$\nand inversion via the inverse FFT brings the derivative to real space. This approach is spectrally accurate for sufficiently smooth periodic functions, and the linear advection problem does not require nonlinear de-aliasing corrections.\n- Finite-difference derivative (identifying the result as $\\Psi$): use a first-order upwind scheme appropriate for advection to approximate $\\partial_x U$ as\n$$\n\\partial_x U(x_i) \\approx \n\\begin{cases}\n\\frac{U_i - U_{i-1}}{\\Delta x},  c \\ge 0, \\\\\n\\frac{U_{i+1} - U_i}{\\Delta x},  c  0,\n\\end{cases}\n$$\nwith indices modulo $N$ to enforce periodicity. First-order upwinding introduces numerical diffusion but is stable for Courant numbers up to $1$.\n\nFor both discretizations, we then integrate in time via RK4. Denoting by $\\mathcal{D}_x$ the discrete derivative operator, the semi-discrete ordinary differential equation is\n$$\n\\frac{d\\mathbf{U}}{d\\eta} = -c \\, \\mathcal{D}_x \\mathbf{U},\n$$\nwhere $\\mathbf{U}$ is the vector of grid values. RK4 computes updates using four intermediate slopes:\n$$\n\\begin{aligned}\nk_1 = f(\\mathbf{U}), \\\\\nk_2 = f\\left(\\mathbf{U} + \\frac{\\Delta \\eta}{2} k_1\\right), \\\\\nk_3 = f\\left(\\mathbf{U} + \\frac{\\Delta \\eta}{2} k_2\\right), \\\\\nk_4 = f\\left(\\mathbf{U} + \\Delta \\eta \\, k_3\\right),\n\\end{aligned}\n$$\nwith $f(\\mathbf{U}) = -c \\, \\mathcal{D}_x \\mathbf{U}$, and the update\n$$\n\\mathbf{U} \\leftarrow \\mathbf{U} + \\frac{\\Delta \\eta}{6} (k_1 + 2k_2 + 2k_3 + k_4).\n$$\n\nAfter evolving to time $T$, we obtain $\\Phi(x_i,T)$ from the spectral method and $\\Psi(x_i,T)$ from the finite-difference method. Because the continuum solution under $\\sigma = 0$ is $\\Phi - \\Psi = 0$, any nonzero difference reflects numerical violations of gauge invariance. We quantify this with the Root Mean Square (RMS) error\n$$\nE = \\left( \\frac{1}{N} \\sum_{i=0}^{N-1} \\left[\\Phi(x_i,T) - \\Psi(x_i,T)\\right]^2 \\right)^{1/2}.\n$$\n\nThe test suite includes four cases:\n- Case $1$: $N = 128$, $L = 2\\pi$, $c = +1$, $A = 10^{-3}$, $m = 3$, $T = 1$, $\\text{CFL} = 0.5$. This is a moderately resolved scenario with a safe time step, expected to show small RMS difference since the spectral method is highly accurate and the finite-difference method introduces modest diffusion.\n- Case $2$: $N = 16$, $L = 2\\pi$, $c = +1$, $A = 10^{-3}$, $m = 3$, $T = 1$, $\\text{CFL} = 0.95$. The coarse grid and near-CFL time step increase numerical diffusion and dispersion for the finite-difference method, so the RMS difference should be larger.\n- Case $3$: $N = 64$, $L = 2\\pi$, $c = -1$, $A = 10^{-3}$, $m = 16$, $T = 1$, $\\text{CFL} = 0.5$. The negative advection speed engages the other upwind stencil, and the relatively high mode number tests resolution and numerical dispersion; the spectral derivative remains very accurate, so the RMS difference captures the finite-difference limitations.\n- Case $4$: $N = 256$, $L = 2\\pi$, $c = +1$, $A = 10^{-3}$, $m = 1$, $T = 0.1$, $\\text{CFL} = 0.2$. Fine grid and short evolution minimize both methods’ errors, leading to a very small RMS difference.\n\nAlgorithm design:\n- Construct the grid and initial condition $U(x,0) = A \\cos(k_m x)$.\n- Implement two derivative operators: upwind finite difference and FFT-based spectral derivative.\n- Implement RK4 time stepping with the chosen CFL-based time step adjusted to exactly reach $T$.\n- Evolve the system twice (spectral and finite difference), then compute RMS difference $E$ for each test case.\n- Aggregate the $E$ values into a single list printed as one line in the required format.\n\nScientific realism and interpretation:\n- The use of a conservative linear transport PDE with identical initial conditions for $\\Phi$ and $\\Psi$ adheres to the physical constraint that, with $\\sigma = 0$, these gauge-invariant potentials are equal. Numerical differences purely reflect discretization-induced violations of the exact equality.\n- The finite-difference scheme’s numerical diffusion and dispersion, especially on coarse grids or near the CFL limit, lead to deviations from the spectral solution. The FFT approach provides a proxy for the continuum derivative in a periodic, smooth setting, thus acting as a high-accuracy reference.\n- The RMS metric $E$ is a quantifiable scalar that tests preservation of gauge invariance under different numerical parameters and discretization strategies.\n\nThe final program prints the list of $E$ values for the four cases in the specified single-line format. All variables are dimensionless, angles in radians, and no units are required. Each $E$ is a floating-point number.",
            "answer": "```python\nimport numpy as np\n\ndef rk4_evolve(u0, deriv_func, c, dt, nsteps):\n    \"\"\"\n    Evolve u in time using RK4 for du/dt = -c * D_x(u),\n    where deriv_func(u) returns D_x(u).\n    \"\"\"\n    u = u0.copy()\n    for _ in range(nsteps):\n        k1 = -c * deriv_func(u)\n        k2 = -c * deriv_func(u + 0.5 * dt * k1)\n        k3 = -c * deriv_func(u + 0.5 * dt * k2)\n        k4 = -c * deriv_func(u + dt * k3)\n        u = u + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n    return u\n\ndef fd_upwind_derivative(dx, c):\n    \"\"\"\n    Return a function that computes the upwind finite-difference derivative\n    for periodic data u on a uniform grid with spacing dx and advection speed c.\n    \"\"\"\n    if c >= 0:\n        def deriv(u):\n            return (u - np.roll(u, 1)) / dx\n    else:\n        def deriv(u):\n            return (np.roll(u, -1) - u) / dx\n    return deriv\n\ndef spectral_derivative(L, N):\n    \"\"\"\n    Return a function that computes the spectral derivative for periodic data u on\n    [0, L) with N points using FFT: d/dx u = IFFT(i*k * FFT(u)).\n    \"\"\"\n    # Wave numbers via FFT frequency layout\n    kfreq = np.fft.fftfreq(N, d=L / N)  # cycles per unit length\n    k = 2.0 * np.pi * kfreq             # radians per unit length\n    ik = 1j * k\n\n    def deriv(u):\n        uhat = np.fft.fft(u)\n        duhat = ik * uhat\n        du = np.fft.ifft(duhat).real\n        return du\n\n    return deriv\n\ndef initialize_field(N, L, A, m):\n    x = np.linspace(0.0, L, N, endpoint=False)\n    k_m = 2.0 * np.pi * m / L\n    return A * np.cos(k_m * x)\n\ndef run_case(N, L, c, A, m, T, CFL):\n    dx = L / N\n    # CFL-based dt, adjust to hit T exactly\n    dt_cfl = CFL * dx / (abs(c) if abs(c) > 0 else 1.0)\n    nsteps = max(1, int(np.ceil(T / dt_cfl)))\n    dt = T / nsteps\n\n    u0 = initialize_field(N, L, A, m)\n\n    # Spectral evolution -> Phi\n    spec_deriv = spectral_derivative(L, N)\n    phi_T = rk4_evolve(u0, spec_deriv, c, dt, nsteps)\n\n    # Finite-difference evolution -> Psi\n    fd_deriv = fd_upwind_derivative(dx, c)\n    psi_T = rk4_evolve(u0, fd_deriv, c, dt, nsteps)\n\n    # RMS difference E\n    diff = phi_T - psi_T\n    E = np.sqrt(np.mean(diff**2))\n    return float(E)\n\ndef solve():\n    # Define the test cases as (N, L, c, A, m, T, CFL)\n    test_cases = [\n        (128, 2.0 * np.pi,  1.0, 1e-3,  3, 1.0, 0.5),   # Case 1: happy path\n        ( 16, 2.0 * np.pi,  1.0, 1e-3,  3, 1.0, 0.95),  # Case 2: coarse grid near-CFL\n        ( 64, 2.0 * np.pi, -1.0, 1e-3, 16, 1.0, 0.5),   # Case 3: negative advection, higher mode\n        (256, 2.0 * np.pi,  1.0, 1e-3,  1, 0.1, 0.2),   # Case 4: fine grid, short time\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, c, A, m, T, CFL = case\n        E = run_case(N, L, c, A, m, T, CFL)\n        results.append(E)\n\n    # Print in the exact required format: single line with comma-separated values in []\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}