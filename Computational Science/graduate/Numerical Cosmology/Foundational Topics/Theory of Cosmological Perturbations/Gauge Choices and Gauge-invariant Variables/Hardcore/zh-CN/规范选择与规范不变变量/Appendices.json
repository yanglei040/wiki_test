{
    "hands_on_practices": [
        {
            "introduction": "规范不变性是宇宙学微扰理论的基石，它确保了我们描述的物理实在独立于我们选择的坐标系。本练习提供了一个直接的、动手实践的机会来验证这一原理，您将为度规势实现规范变换法则，并确认巴丁势 $\\Phi$ 和 $\\Psi$ 确实保持不变。通过这个实践，您将能够巩固对理论框架的信心，并掌握处理宇宙学场量的基本编程技能。",
            "id": "3473419",
            "problem": "实现一个独立的程序，该程序针对傅里叶空间中的线性标量宇宙学微扰，构建并应用一个投影算子，以分离并移除由时间平移 $\\alpha$ 和标量空间平移 $\\beta$（两者均为共形时间的函数）产生的纯规范标量贡献。利用关于空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 背景下线性微扰的规范变换的第一性原理，推导必要的变换规则和规范不变组合。背景膨胀由共形哈勃率 $\\mathcal{H} \\equiv a'/a$ 来量化，其中 $a$ 是标度因子，撇号表示对共形时间的导数。在傅里叶空间中，使用带有标量势 $\\phi$、$\\psi$、$B$ 和 $E$ 的微扰度规的标准标量分解进行计算，并假设物质为绝热物质，其状态方程参数 $w$ 为常数，因此背景能量密度 $\\rho$ 遵循连续性关系 $\\rho' = -3 \\mathcal{H} (1+w)\\rho$。\n\n您的程序必须：\n- 为每个傅里叶模式，构建由 $\\alpha$ 和 $\\beta$ 及其共形时间导数驱动的、对度规势和密度对比 $\\delta \\equiv \\delta\\rho/\\rho$ 的纯规范贡献，并确保其与微扰一阶的线性化坐标变换一致。\n- 应用此投影算子，通过将纯规范部分添加到一个提供的基准“物理”构型中，生成一个受污染的场集。\n- 从受污染的场和清理后的场（通过移除投影的规范部分获得）中计算两个规范不变的 Bardeen 势 $\\Phi$ 和 $\\Psi$，仅使用在线性阶上严格规范不变的组合。\n- 数值上验证移除纯规范贡献会改变规范依赖的场，但在严格的数值容差内保持 $\\Phi$ 和 $\\Psi$ 不变，并且修正后的密度对比 $\\delta$ 在移除其纯规范部分后等于基准物理 $\\delta$。\n\n所有量均被视为无量纲，并以共形时间单位表示。无需进行物理单位转换。不出现角度，因此无需角度单位。不出现百分比。\n\n测试套件和所需输入：\n对于每个测试用例，您将获得关于傅里叶模式的数组，包括波数 $k$、共形哈勃率 $\\mathcal{H}$（在每个测试中为常数）、状态方程参数 $w$、基准物理场 $\\phi_{\\mathrm{phys}}$、$\\psi_{\\mathrm{phys}}$、$B_{\\mathrm{phys}}$、$E_{\\mathrm{phys}}$ 及其共形时间导数 $B'_{\\mathrm{phys}}$、$E'_{\\mathrm{phys}}$、$E''_{\\mathrm{phys}}$、基准物理密度对比 $\\delta_{\\mathrm{phys}}$，以及规范生成元及其导数 $\\alpha$、$\\alpha'$、$\\beta$、$\\beta'$、$\\beta''$。使用这些量，通过添加由线性化变换确定的纯规范部分来构建受污染的场。\n\n在您的程序内部完全按照下述方式实现三个测试用例（无需输入）：\n\n- 测试 A（通用混合规范，三个模式）：\n  - $k = [\\,0.25,\\,0.5,\\,1.0\\,]$\n  - $\\mathcal{H} = 0.2$, $w = 0$\n  - $\\alpha = [\\,0.1,\\,-0.05,\\,0.02\\,]$, $\\alpha' = [\\,0.01,\\,0.02,\\,-0.03\\,]$\n  - $\\beta = [\\,0.3,\\,-0.1,\\,0.05\\,]$, $\\beta' = [\\,0.02,\\,-0.01,\\,0.04\\,]$, $\\beta'' = [\\,-0.005,\\,0.003,\\,-0.002\\,]$\n  - $\\phi_{\\mathrm{phys}} = [\\,0.01,\\,-0.02,\\,0.03\\,]$, $\\psi_{\\mathrm{phys}} = [\\,-0.005,\\,0.004,\\,-0.002\\,]$\n  - $B_{\\mathrm{phys}} = [\\,0.02,\\,0.01,\\,-0.01\\,]$, $E_{\\mathrm{phys}} = [\\,0.015,\\,-0.01,\\,0.005\\,]$\n  - $B'_{\\mathrm{phys}} = [\\,0.001,\\,-0.002,\\,0.003\\,]$, $E'_{\\mathrm{phys}} = [\\,0.002,\\,0.001,\\,-0.0015\\,]$, $E''_{\\mathrm{phys}} = [\\,-0.0005,\\,0.0003,\\,0.0002\\,]$\n  - $\\delta_{\\mathrm{phys}} = [\\,0.1,\\,-0.2,\\,0.05\\,]$\n\n- 测试 B（仅 $\\alpha$ 规范，含超视界模式，两个模式）：\n  - $k = [\\,0.0,\\,0.7\\,]$\n  - $\\mathcal{H} = 0.1$, $w = 1/3$\n  - $\\alpha = [\\,-0.03,\\,0.04\\,]$, $\\alpha' = [\\,0.002,\\,-0.001\\,]$\n  - $\\beta = [\\,0.0,\\,0.0\\,]$, $\\beta' = [\\,0.0,\\,0.0\\,]$, $\\beta'' = [\\,0.0,\\,0.0\\,]$\n  - $\\phi_{\\mathrm{phys}} = [\\,-0.02,\\,0.01\\,]$, $\\psi_{\\mathrm{phys}} = [\\,0.003,\\,-0.004\\,]$\n  - $B_{\\mathrm{phys}} = [\\,0.0,\\,-0.005\\,]$, $E_{\\mathrm{phys}} = [\\,0.0,\\,0.002\\,]$\n  - $B'_{\\mathrm{phys}} = [\\,0.0,\\,0.0004\\,]$, $E'_{\\mathrm{phys}} = [\\,0.0,\\,-0.0003\\,]$, $E''_{\\mathrm{phys}} = [\\,0.0,\\,0.00005\\,]$\n  - $\\delta_{\\mathrm{phys}} = [\\,0.02,\\,-0.03\\,]$\n\n- 测试 C（仅 $\\beta$ 规范，高 $k$ 值，三个模式）：\n  - $k = [\\,3.0,\\,5.0,\\,7.0\\,]$\n  - $\\mathcal{H} = 0.05$, $w = 0$\n  - $\\alpha = [\\,0.0,\\,0.0,\\,0.0\\,]$, $\\alpha' = [\\,0.0,\\,0.0,\\,0.0\\,]$\n  - $\\beta = [\\,0.02,\\,-0.015,\\,0.01\\,]$, $\\beta' = [\\,-0.003,\\,0.002,\\,-0.001\\,]$, $\\beta'' = [\\,0.0004,\\,-0.0003,\\,0.0002\\,]$\n  - $\\phi_{\\mathrm{phys}} = [\\,0.005,\\,-0.004,\\,0.003\\,]$, $\\psi_{\\mathrm{phys}} = [\\,-0.001,\\,0.0015,\\,-0.0012\\,]$\n  - $B_{\\mathrm{phys}} = [\\,0.001,\\,-0.002,\\,0.0025\\,]$, $E_{\\mathrm{phys}} = [\\,0.0005,\\,-0.0007,\\,0.0009\\,]$\n  - $B'_{\\mathrm{phys}} = [\\,-0.0002,\\,0.0001,\\,-0.00015\\,]$, $E'_{\\mathrm{phys}} = [\\,0.0003,\\,-0.00025,\\,0.0002\\,]$, $E''_{\\mathrm{phys}} = [\\,-0.00005,\\,0.00004,\\,-0.00003\\,]$\n  - $\\delta_{\\mathrm{phys}} = [\\,-0.01,\\,0.015,\\,-0.02\\,]$\n\n验证与输出：\n- 对于每个测试，从受污染的场和清理后的场中计算 Bardeen 势 $\\Phi$ 和 $\\Psi$。如果所有模式中的最大绝对差小于 $10^{-12}$，则声明每个不变性检查为 true，否则为 false。\n- 对于每个测试，计算修正后的密度对比（移除其纯规范贡献后）与基准 $\\delta_{\\mathrm{phys}}$ 之间在所有模式上的最大绝对误差。\n\n最终输出格式：\n您的程序应生成单行输出，包含三个测试用例的结果列表，其中每个测试用例贡献一个形式为 $[\\,\\text{phi\\_invariant},\\,\\text{psi\\_invariant},\\,\\text{delta\\_max\\_abs\\_error}\\,]$ 的三元素列表。布尔值必须是小写字面量，浮点数必须以标准十进制表示法打印。例如：$[[\\text{true},\\text{true},0.0],[\\text{true},\\text{true},0.0],[\\text{true},\\text{true},0.0]]$。",
            "solution": "该问题要求实现并验证宇宙学中线性标量微扰的规范变换。其框架是一个空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙，以共形时间 $\\tau$ 描述。所有计算都在傅里叶空间中进行，其中各量是共形时间 $\\tau$ 和波数 $k$ 的函数。\n\n首先，我们建立理论基础。标量度规微扰的线元在通用规范下可以写为：\n$$ds^2 = a^2(\\tau) \\left[ -(1+2\\phi)d\\tau^2 - 2B_i d\\tau dx^i + \\left((1-2\\psi)\\delta_{ij} + 2E_{;ij}\\right)dx^i dx^j \\right]$$\n在傅里叶空间中，对于一个波矢为 $\\mathbf{k}$ 的模式，空间向量 $B_i$ 和空间张量 $E_{;ij}$ 通过其标量势 $B$ 和 $E$ 表示为 $B_i \\rightarrow i k_i B$ 和 $E_{;ij} \\rightarrow -k_i k_j E$。这产生了四个标量微扰势：$\\phi(\\tau, k)$、$\\psi(\\tau, k)$、$B(\\tau, k)$ 和 $E(\\tau, k)$。\n\n规范变换对应于一个无穷小坐标变换。对于标量微扰，这由一个时间平移函数 $\\alpha(\\tau)$ 和一个空间平移标量势 $\\beta(\\tau)$ 定义，使得 $\\tilde{\\tau} = \\tau - \\alpha(\\tau)$ 和 $\\tilde{x}^i = x^i - \\nabla^i \\beta(\\tau)$。在一阶微扰下，度规势的变换如下：\n$$ \\tilde{\\phi} = \\phi - \\alpha' - \\mathcal{H}\\alpha $$\n$$ \\tilde{\\psi} = \\psi + \\mathcal{H}\\alpha $$\n$$ \\tilde{B} = B + \\alpha - \\beta' $$\n$$ \\tilde{E} = E - \\beta $$\n此处，撇号表示对共形时间求导（例如 $\\alpha' = d\\alpha/d\\tau$），而 $\\mathcal{H} \\equiv a'/a$ 是共形哈勃率。\n\n分数能量密度微扰，或称密度对比，$\\delta \\equiv \\delta\\rho/\\rho$，是背景标量场 $\\rho$ 的一个微扰。它的变换规则是 $\\tilde{\\delta} = \\delta + (\\rho'/\\rho)\\alpha$。对于具有恒定状态方程参数 $w$ 的流体，使用背景连续性方程 $\\rho' = -3\\mathcal{H}(1+w)\\rho$，$\\delta$ 的变换规则为：\n$$ \\tilde{\\delta} = \\delta - 3\\mathcal{H}(1+w)\\alpha $$\n\n虽然单个势是规范依赖的，但被称为 Bardeen 势的特定组合是规范不变的。这些势 $\\Phi$ 和 $\\Psi$ 代表了纵向（或共形牛顿）规范中的度规势，在该规范中 $B$ 和 $E$ 被设为零。它们在通用规范中定义为：\n$$ \\Psi \\equiv \\psi - \\mathcal{H}(B - E') $$\n$$ \\Phi \\equiv \\phi + (B - E')' + \\mathcal{H}(B - E') = \\phi + (B' - E'') + \\mathcal{H}(B - E') $$\n\n我们必须验证这些定义确实是规范不变的。让我们分析项 $S \\equiv B - E'$ 的变换：\n$$ \\tilde{S} = \\tilde{B} - \\tilde{E}' = (B + \\alpha - \\beta') - (E - \\beta)' = B + \\alpha - \\beta' - E' + \\beta' = (B - E') + \\alpha = S + \\alpha $$\n$S$ 的导数变换为 $\\tilde{S}' = (S + \\alpha)' = S' + \\alpha'$。\n现在，将这些代入变换后的 Bardeen 势的定义中：\n$$ \\tilde{\\Psi} = \\tilde{\\psi} - \\mathcal{H}\\tilde{S} = (\\psi + \\mathcal{H}\\alpha) - \\mathcal{H}(S+\\alpha) = \\psi + \\mathcal{H}\\alpha - \\mathcal{H}S - \\mathcal{H}\\alpha = \\psi - \\mathcal{H}S = \\Psi $$\n$$ \\tilde{\\Phi} = \\tilde{\\phi} + \\tilde{S}' + \\mathcal{H}\\tilde{S} = (\\phi - \\alpha' - \\mathcal{H}\\alpha) + (S' + \\alpha') + \\mathcal{H}(S+\\alpha) = \\phi - \\alpha' - \\mathcal{H}\\alpha + S' + \\alpha' + \\mathcal{H}S + \\mathcal{H}\\alpha = \\phi + S' + \\mathcal{H}S = \\Phi $$\n不变性得到证实。\n\n程序将实现这一理论框架。核心算法如下：\n1.  对于每个测试用例，获取提供的基准“物理”场（$\\phi_{\\mathrm{phys}}$、$\\psi_{\\mathrm{phys}}$ 等）和规范生成元（$\\alpha$、$\\beta$ 及其导数）。\n2.  计算每个场的纯规范贡献。这些贡献作为投影算子，投影到微扰空间的纯规范部分。\n    - $\\phi_{\\text{gauge}} = - (\\alpha' + \\mathcal{H}\\alpha)$\n    - $\\psi_{\\text{gauge}} = \\mathcal{H}\\alpha$\n    - $B_{\\text{gauge}} = \\alpha - \\beta'$\n    - $E_{\\text{gauge}} = -\\beta$\n    - $\\delta_{\\text{gauge}} = -3\\mathcal{H}(1+w)\\alpha$\n3.  通过将规范贡献添加到物理场中来生成“受污染”的场（例如 $\\phi_{\\text{cont}} = \\phi_{\\text{phys}} + \\phi_{\\text{gauge}}$）。\n4.  使用提供的物理场和规范生成元的导数，计算受污染场的必要导数。例如，$B'_{\\text{cont}} = (B_{\\text{phys}} + B_{\\text{gauge}})' = B'_{\\text{phys}} + \\alpha' - \\beta''$ 以及 $E''_{\\text{cont}} = (E_{\\text{phys}} + E_{\\text{gauge}})'' = E''_{\\text{phys}} - \\beta''$。\n5.  为物理场集和受污染场集计算 Bardeen 势 $\\Phi$ 和 $\\Psi$。\n6.  数值上验证 $\\Phi_{\\text{cont}} \\approx \\Phi_{\\text{phys}}$ 和 $\\Psi_{\\text{cont}} \\approx \\Psi_{\\text{phys}}$，容差为 $10^{-12}$。\n7.  通过减去其规范部分来清理受污染的密度对比：$\\delta_{\\text{cleaned}} = \\delta_{\\text{cont}} - \\delta_{\\text{gauge}}$。\n8.  计算并报告清理后的密度对比与原始物理密度对比之间的最大绝对误差 $||\\delta_{\\text{cleaned}} - \\delta_{\\text{phys}}||_\\infty$。\n计算以矢量化方式对给定的傅里叶模式 $k$ 数组进行。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for cosmological gauge transformations.\n    \"\"\"\n    \n    test_cases = [\n        # Test A: General mixed gauge, three modes\n        {\n            \"k\": np.array([0.25, 0.5, 1.0]),\n            \"H_conf\": 0.2, \"w\": 0.0,\n            \"alpha\": np.array([0.1, -0.05, 0.02]), \"alpha_prime\": np.array([0.01, 0.02, -0.03]),\n            \"beta\": np.array([0.3, -0.1, 0.05]), \"beta_prime\": np.array([0.02, -0.01, 0.04]), \"beta_pprime\": np.array([-0.005, 0.003, -0.002]),\n            \"phi_phys\": np.array([0.01, -0.02, 0.03]), \"psi_phys\": np.array([-0.005, 0.004, -0.002]),\n            \"B_phys\": np.array([0.02, 0.01, -0.01]), \"E_phys\": np.array([0.015, -0.01, 0.005]),\n            \"B_prime_phys\": np.array([0.001, -0.002, 0.003]), \"E_prime_phys\": np.array([0.002, 0.001, -0.0015]), \"E_pprime_phys\": np.array([-0.0005, 0.0003, 0.0002]),\n            \"delta_phys\": np.array([0.1, -0.2, 0.05])\n        },\n        # Test B: alpha-only gauge with a super-horizon mode, two modes\n        {\n            \"k\": np.array([0.0, 0.7]),\n            \"H_conf\": 0.1, \"w\": 1/3,\n            \"alpha\": np.array([-0.03, 0.04]), \"alpha_prime\": np.array([0.002, -0.001]),\n            \"beta\": np.array([0.0, 0.0]), \"beta_prime\": np.array([0.0, 0.0]), \"beta_pprime\": np.array([0.0, 0.0]),\n            \"phi_phys\": np.array([-0.02, 0.01]), \"psi_phys\": np.array([0.003, -0.004]),\n            \"B_phys\": np.array([0.0, -0.005]), \"E_phys\": np.array([0.0, 0.002]),\n            \"B_prime_phys\": np.array([0.0, 0.0004]), \"E_prime_phys\": np.array([0.0, -0.0003]), \"E_pprime_phys\": np.array([0.0, 0.00005]),\n            \"delta_phys\": np.array([0.02, -0.03])\n        },\n        # Test C: beta-only gauge at high k, three modes\n        {\n            \"k\": np.array([3.0, 5.0, 7.0]),\n            \"H_conf\": 0.05, \"w\": 0.0,\n            \"alpha\": np.array([0.0, 0.0, 0.0]), \"alpha_prime\": np.array([0.0, 0.0, 0.0]),\n            \"beta\": np.array([0.02, -0.015, 0.01]), \"beta_prime\": np.array([-0.003, 0.002, -0.001]), \"beta_pprime\": np.array([0.0004, -0.0003, 0.0002]),\n            \"phi_phys\": np.array([0.005, -0.004, 0.003]), \"psi_phys\": np.array([-0.001, 0.0015, -0.0012]),\n            \"B_phys\": np.array([0.001, -0.002, 0.0025]), \"E_phys\": np.array([0.0005, -0.0007, 0.0009]),\n            \"B_prime_phys\": np.array([-0.0002, 0.0001, -0.00015]), \"E_prime_phys\": np.array([0.0003, -0.00025, 0.0002]), \"E_pprime_phys\": np.array([-0.00005, 0.00004, -0.00003]),\n            \"delta_phys\": np.array([-0.01, 0.015, -0.02])\n        }\n    ]\n\n    final_results = []\n    for case in test_cases:\n        result = run_test_case(case)\n        final_results.append(result)\n\n    # Format the final output string exactly as required\n    result_strings = [\n        f\"[{str(r[0]).lower()},{str(r[1]).lower()},{r[2]}]\" for r in final_results\n    ]\n    print(f\"[{','.join(result_strings)}]\")\n\ndef compute_bardeen_potentials(phi, psi, B, B_prime, E_prime, E_pprime, H_conf):\n    \"\"\"\n    Computes the gauge-invariant Bardeen potentials Phi and Psi.\n    \"\"\"\n    S = B - E_prime\n    S_prime = B_prime - E_pprime\n    \n    Psi = psi - H_conf * S\n    Phi = phi + S_prime + H_conf * S\n    \n    return Phi, Psi\n\ndef run_test_case(params):\n    \"\"\"\n    Processes a single test case.\n    \"\"\"\n    H_conf = params[\"H_conf\"]\n    w = params[\"w\"]\n\n    # Gauge generators\n    alpha = params[\"alpha\"]\n    alpha_prime = params[\"alpha_prime\"]\n    beta = params[\"beta\"]\n    beta_prime = params[\"beta_prime\"]\n    beta_pprime = params[\"beta_pprime\"]\n\n    # Physical fields\n    phi_phys = params[\"phi_phys\"]\n    psi_phys = params[\"psi_phys\"]\n    B_phys = params[\"B_phys\"]\n    E_phys = params[\"E_phys\"]\n    B_prime_phys = params[\"B_prime_phys\"]\n    E_prime_phys = params[\"E_prime_phys\"]\n    E_pprime_phys = params[\"E_pprime_phys\"]\n    delta_phys = params[\"delta_phys\"]\n\n    # 1. Compute Bardeen potentials for physical fields\n    Phi_phys, Psi_phys = compute_bardeen_potentials(\n        phi_phys, psi_phys, B_phys, B_prime_phys, E_prime_phys, E_pprime_phys, H_conf\n    )\n\n    # 2. Compute pure-gauge contributions\n    phi_gauge = - (alpha_prime + H_conf * alpha)\n    psi_gauge = H_conf * alpha\n    B_gauge = alpha - beta_prime\n    E_gauge = -beta\n    delta_gauge = -3 * H_conf * (1 + w) * alpha\n\n    # 3. Create contaminated fields\n    phi_cont = phi_phys + phi_gauge\n    psi_cont = psi_phys + psi_gauge\n    B_cont = B_phys + B_gauge\n    E_cont = E_phys + E_gauge\n    delta_cont = delta_phys + delta_gauge\n\n    # 4. Compute derivatives of contaminated fields\n    B_prime_cont = B_prime_phys + alpha_prime - beta_pprime\n    E_prime_cont = E_prime_phys - beta_prime\n    E_pprime_cont = E_pprime_phys - beta_pprime\n    \n    # 5. Compute Bardeen potentials for contaminated fields\n    Phi_cont, Psi_cont = compute_bardeen_potentials(\n        phi_cont, psi_cont, B_cont, B_prime_cont, E_prime_cont, E_pprime_cont, H_conf\n    )\n\n    # 6. Verify invariance\n    tolerance = 1e-12\n    phi_invariant = np.allclose(Phi_phys, Phi_cont, atol=tolerance, rtol=0)\n    psi_invariant = np.allclose(Psi_phys, Psi_cont, atol=tolerance, rtol=0)\n    \n    # 7. Verify density contrast cleaning\n    delta_cleaned = delta_cont - delta_gauge\n    delta_max_abs_error = np.max(np.abs(delta_cleaned - delta_phys))\n    \n    return [phi_invariant, psi_invariant, delta_max_abs_error]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "虽然某些规范选择（如同步规范）在计算上很方便，但它们可能并非唯一，从而导致“残余规范模式”的出现。本练习聚焦于广泛使用的同步规范，并要求您构建一个对解释大尺度结构数据至关重要的规范不变量——共动密度衬度 $\\Delta$。通过投影掉非物理的规范模式，您将获得处理实际宇宙学模拟中常见的规范模糊性的实践经验。",
            "id": "3473450",
            "problem": "您的任务是设计并实现傅里叶空间中的规范模式投影算符，用于标量宇宙学微扰，以消除残余的同步规范模式，并在大尺度上恢复规范不变的共动密度差。研究背景为一个空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 背景，其中包含线性标量微扰和一种具有恒定状态方程参数 $w$ 的单一理想流体。考虑一个固定的时间切片，因此所有物理量仅依赖于傅里叶波矢量的模 $k \\equiv \\lvert \\mathbf{k} \\rvert$。\n\n请使用以下基本陈述作为您的出发点：\n- 在一个由时间偏移参数 $\\alpha(\\mathbf{k})$ 生成的无穷小标量规范变换下，在微扰的一阶和傅里叶空间中，同步规范的残余自由度对物质变量的作用如下：\n  - $\\delta \\rightarrow \\delta + 3 (1+w)\\, \\mathcal{H}\\, \\alpha$,\n  - $\\theta \\rightarrow \\theta - k^{2} \\alpha$,\n  其中 $\\delta(\\mathbf{k})$ 是密度差，$\\theta(\\mathbf{k})$ 是速度散度，$\\mathcal{H}$ 是共形哈勃参数。这种残余自由度的出现是因为同步规范没有唯一地固定时间切片。\n- 通过 $\\theta(\\mathbf{k}) \\equiv k^{2} v(\\mathbf{k})$ 定义速度散度，其中 $v$ 是速度势。\n- 共动密度差是一个规范不变的量（在 Bardeen 构建规范不变量的意义上），可以表示为 $\\delta$ 和 $\\theta$ 的线性泛函。您必须从上述变换规则中推导出它的形式。\n\n您的任务：\n1. 从第一性原理出发，使用给定的变换定律，推导一个作用于物理量对 $(\\delta(\\mathbf{k}), \\theta(\\mathbf{k}))$ 的傅里叶空间线性泛函 $p(\\mathbf{k})$，使得：\n   - 该泛函能够湮灭由任意 $\\alpha(\\mathbf{k})$ 生成的任何纯残余同步规范模式，即当它作用于 $(3(1+w)\\mathcal{H}\\alpha, -k^{2}\\alpha)$ 时，结果为零。\n   - 当该泛函作用于一般的 $(\\delta(\\mathbf{k}), \\theta(\\mathbf{k}))$ 时，它能恢复规范不变的共动密度差，记为 $\\Delta(\\mathbf{k})$。\n2. 将此泛函实现为一个代码中的投影算符，它接受 $(\\delta, \\theta, \\mathcal{H}, w, k)$ 作为输入并返回标量 $\\Delta$。同时，实现一个污染算符，通过上述变换规则，将一个振幅为 $\\alpha$ 的纯残余同步规范模式添加到 $(\\delta, \\theta)$ 中。\n3. 通过一个可复现的数值测试套件来证明：\n   - 对于多组 $k$ 和 $\\alpha$ 的值，投影算符的输出 $\\Delta$ 在加上任何残余同步规范模式后保持不变。\n   - 在大尺度（小 $k$）上，即使同步规范输入 $(\\delta, \\theta)$ 被一个大的规范模式严重污染，恢复出的 $\\Delta$ 仍与用于生成测试数据的底层物理密度差相匹配。\n\n数值规格：\n- 在固定时间下处理无量纲的量，其中 $\\mathcal{H}$ 是一个指定的常数。不需要进行物理单位转换。\n- 程序必须是自包含的，并且无需外部输入即可运行。\n- 在比较浮点数相等性以进行不变性测试时，使用 $10^{-12}$ 的绝对容差。\n\n需要实现和评估的测试套件：\n- 案例1（基线计算）：$(\\delta, \\theta, \\mathcal{H}, w, k) = (0.1, -10^{-4}, 100, 0, 10^{-2})$。以浮点数形式返回计算出的 $\\Delta$。\n- 案例2（规范污染下的不变性）：从案例1的物理量对开始，并用规范振幅 $\\alpha = 0.5$ 对其进行污染，以获得 $(\\delta', \\theta') = (\\delta + 3(1+w)\\mathcal{H}\\alpha, \\theta - k^{2}\\alpha)$。返回一个布尔值，指示在指定容差内，作用于 $(\\delta', \\theta')$ 的投影算符输出是否等于作用于 $(\\delta, \\theta)$ 的投影算符输出。\n- 案例3（大尺度恢复）：$(\\delta_{\\text{phys}}, \\theta_{\\text{phys}}, \\mathcal{H}, w, k, \\alpha) = (0.7, 0.0, 100, 0, 10^{-5}, 300)$。如上构造受污染的输入 $(\\delta', \\theta')$，并返回一个布尔值，指示在指定容差内，投影算符的输出是否等于 $0.7$。\n- 案例4（极端超视界稳定性）：$(\\delta_{\\text{phys}}, \\theta_{\\text{phys}}, \\mathcal{H}, w, k, \\alpha) = (0.3, 0.0, 100, 0, 10^{-8}, 10^{6})$。构造受污染的输入，并返回一个布尔值，指示在指定容差内，投影算符的输出是否等于 $0.3$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含案例1-4的结果，格式为一个用方括号括起来的逗号分隔列表，即 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$，其中 $\\text{result}_1$ 是一个浮点数，而 $\\text{result}_2$、$\\text{result}_3$ 和 $\\text{result}_4$ 是布尔值。",
            "solution": "用户提供了一个数值宇宙学领域的问题，具体涉及规范选择以及为线性标量微扰构建规范不变量。\n\n### 问题验证\n\n首先，我将根据指定标准验证问题陈述。\n\n**步骤1：提取已知条件**\n-   **物理系统**：一个空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 背景，其中包含单一理想流体。\n-   **流体性质**：恒定的状态方程参数 $w$。\n-   **微扰类型**：线性标量微扰。\n-   **域**：固定时间的傅里叶空间，其中物理量仅依赖于波数 $k \\equiv |\\mathbf{k}|$。\n-   **规范变换规则**：对于由 $\\alpha(\\mathbf{k})$ 生成的残余同步规范变换：\n    -   密度差：$\\delta \\rightarrow \\delta + 3 (1+w)\\, \\mathcal{H}\\, \\alpha$。\n    -   速度散度：$\\theta \\rightarrow \\theta - k^{2} \\alpha$。\n-   **定义**：\n    -   $\\delta(\\mathbf{k})$：密度差。\n    -   $\\theta(\\mathbf{k})$：速度散度。\n    -   $\\mathcal{H}$：共形哈勃参数。\n    -   $\\theta(\\mathbf{k}) \\equiv k^{2} v(\\mathbf{k})$，其中 $v$ 是速度势。\n-   **目标**：推导并实现一个作用于 $(\\delta, \\theta)$ 的线性泛函 $p(\\mathbf{k})$，以产生规范不变的共动密度差 $\\Delta(\\mathbf{k})$。\n-   **泛函的条件**：\n    1.  它必须湮灭纯残余同步规范模式，即 $p(3(1+w)\\mathcal{H}\\alpha, -k^{2}\\alpha) = 0$。\n    2.  当作用于一般的物理量对 $(\\delta(\\mathbf{k}), \\theta(\\mathbf{k}))$ 时，它能恢复 $\\Delta(\\mathbf{k})$。\n-   **数值规格**：\n    -   无量纲量，固定时间下 $\\mathcal{H}$ 为常数。\n    -   浮点数比较的绝对容差：$10^{-12}$。\n-   **测试套件**：\n    1.  **案例1**：$(\\delta, \\theta, \\mathcal{H}, w, k) = (0.1, -10^{-4}, 100, 0, 10^{-2})$。计算 $\\Delta$。\n    2.  **案例2**：使用案例1的值，并用 $\\alpha = 0.5$ 进行污染。测试 $\\Delta$ 的不变性。\n    3.  **案例3**：$(\\delta_{\\text{phys}}, \\theta_{\\text{phys}}, \\mathcal{H}, w, k, \\alpha) = (0.7, 0.0, 100, 0, 10^{-5}, 300)$。测试恢复出的 $\\Delta$ 是否等于 $0.7$。\n    4.  **案例4**：$(\\delta_{\\text{phys}}, \\theta_{\\text{phys}}, \\mathcal{H}, w, k, \\alpha) = (0.3, 0.0, 100, 0, 10^{-8}, 10^{6})$。测试恢复出的 $\\Delta$ 是否等于 $0.3$。\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题设定在宇宙学微扰理论的标准、完善的框架内。同步规范中 $\\delta$ 和 $\\theta$ 的规范变换定律是经典结果（例如，参见 Ma  Bertschinger, ApJ 455, 7, 1995）。构建像共动密度差这样的规范不变量是该领域的一项基本技术。该问题在科学上是合理的。\n-   **适定性**：该问题是适定的。任务是基于特定的不变性条件找到一个线性泛函。这些条件足以唯一确定该泛函。数值测试所需的所有参数都已提供。存在唯一且有意义的解。\n-   **客观性**：该问题以物理学和数学中常见的精确、客观的语言陈述。所有术语都是标准的且定义明确。\n\n**步骤3：结论与行动**\n该问题是有效的。这是理论宇宙学中一个标准的、非平凡的练习，其定义明确且事实正确。我将继续进行解答。\n\n### 规范不变泛函的推导\n\n目标是找到一个线性泛函，我们称之为 $p$，它将依赖于规范的量 $\\delta(\\mathbf{k})$ 和 $\\theta(\\mathbf{k})$ 组合成一个不依赖于规范的量，即共动密度差 $\\Delta(\\mathbf{k})$。$(\\delta, \\theta)$ 的线性泛函的一般形式为：\n$$\n\\Delta(\\mathbf{k}) = A(\\mathbf{k}) \\delta(\\mathbf{k}) + B(\\mathbf{k}) \\theta(\\mathbf{k})\n$$\n其中 $A(\\mathbf{k})$ 和 $B(\\mathbf{k})$ 是可以依赖于波数 $k$ 和背景量（如 $\\mathcal{H}$ 和 $w$）的系数。由于我们处于一个各向同性的背景中，这些系数将只依赖于模 $k=|\\mathbf{k}|$。\n\n核心要求是 $\\Delta(k)$ 必须在指定的残余同步规范变换下保持不变。让我们将变换后的量表示为 $\\delta'$ 和 $\\theta'$：\n$$ \\delta' = \\delta + 3(1+w)\\mathcal{H}\\alpha $$\n$$ \\theta' = \\theta - k^2\\alpha $$\n用变换后的变量计算出的规范不变量 $\\Delta'$ 必须等于用原始变量计算出的 $\\Delta$。\n$$\n\\Delta' = A(k)\\delta' + B(k)\\theta'\n$$\n代入变换规则：\n$$\n\\Delta' = A(k) \\left( \\delta + 3(1+w)\\mathcal{H}\\alpha \\right) + B(k) \\left( \\theta - k^2\\alpha \\right)\n$$\n重新整理各项：\n$$\n\\Delta' = \\left( A(k)\\delta + B(k)\\theta \\right) + \\left[ A(k) \\cdot 3(1+w)\\mathcal{H} - B(k) \\cdot k^2 \\right] \\alpha\n$$\n第一项就是原始的 $\\Delta$。为了使 $\\Delta' = \\Delta$ 对任何任意的规范变换参数 $\\alpha(k) \\neq 0$ 都成立，$\\alpha(k)$ 的系数必须恒等于零：\n$$\n3(1+w)\\mathcal{H} A(k) - k^2 B(k) = 0\n$$\n这个方程给出了系数 $A(k)$ 和 $B(k)$ 之间的一个关系：\n$$\nB(k) = \\frac{3(1+w)\\mathcal{H}}{k^2} A(k)\n$$\n将其代入 $\\Delta$ 的表达式中：\n$$\n\\Delta(k) = A(k) \\delta + \\left( \\frac{3(1+w)\\mathcal{H}}{k^2} A(k) \\right) \\theta = A(k) \\left( \\delta + \\frac{3(1+w)\\mathcal{H}}{k^2} \\theta \\right)\n$$\n总的归一化因子 $A(k)$ 由共动密度差的物理定义确定。共动密度差被定义为在与流体共动的参考系中的密度微扰。在此参考系中，根据定义，流体的本动速度及其散度 $\\theta$ 为零。\n我们可以找到所需的规范变换参数 $\\alpha$，以从我们初始的同步规范变换到这个共动规范。条件是新的速度散度 $\\theta'$ 必须为零：\n$$\n\\theta' = \\theta - k^2 \\alpha = 0 \\implies \\alpha = \\frac{\\theta}{k^2}\n$$\n在这个新的共动参考系中，密度差 $\\delta'$ 根据定义就是共动密度差 $\\Delta$。让我们计算它的值：\n$$\n\\Delta = \\delta' = \\delta + 3(1+w)\\mathcal{H}\\alpha = \\delta + 3(1+w)\\mathcal{H} \\frac{\\theta}{k^2}\n$$\n将此结果与我们推导的形式 $\\Delta(k) = A(k) \\left( \\delta + \\frac{3(1+w)\\mathcal{H}}{k^2} \\theta \\right)$ 进行比较，我们可以确定归一化因子为 $A(k) = 1$。\n\n因此，规范不变的共动密度差由以下泛函给出：\n$$\n\\Delta(k) = \\delta(k) + \\frac{3(1+w)\\mathcal{H}}{k^2} \\theta(k)\n$$\n这就是所要求的投影泛函 $p(k)$。\n\n让我们验证它是否能湮灭一个纯规范模式 $(\\delta_g, \\theta_g) = (3(1+w)\\mathcal{H}\\alpha, -k^2\\alpha)$：\n$$\np(\\delta_g, \\theta_g) = \\delta_g + \\frac{3(1+w)\\mathcal{H}}{k^2} \\theta_g = \\left(3(1+w)\\mathcal{H}\\alpha\\right) + \\frac{3(1+w)\\mathcal{H}}{k^2} \\left(-k^2\\alpha\\right)\n$$\n$$\n= 3(1+w)\\mathcal{H}\\alpha - 3(1+w)\\mathcal{H}\\alpha = 0\n$$\n条件得到满足。推导完成且正确。\n\n### 实现与数值演示\n\n该实现将包括两个主要函数：一个用于应用推导出的投影算符，另一个用于应用规范污染。这些将用于运行指定的测试套件。\n\n1.  **投影函数**：`projector(delta, theta, H, w, k)` 将计算 $\\Delta = \\delta + \\frac{3(1+w)\\mathcal{H}}{k^2}\\theta$。\n2.  **污染函数**：`contaminate(delta, theta, H, w, k, alpha)` 将计算 $(\\delta', \\theta') = (\\delta + 3(1+w)\\mathcal{H}\\alpha, \\theta - k^2\\alpha)$。\n3.  **测试套件**：主程序将执行问题陈述中描述的四个测试案例，使用 $10^{-12}$ 的绝对容差比较浮点数。这些测试案例验证了直接计算、不变性属性以及在大尺度上恢复的准确性，在这些尺度上同步规范模式可能很大。案例3和4带来的挑战，即涉及非常大的数字相减（可能是灾难性抵消的来源），被解析公式正确处理。\n最终的程序实现了这一逻辑，并以要求的格式打印结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements Fourier-space gauge mode projectors for scalar\n    cosmological perturbations and runs a numerical test suite.\n    \"\"\"\n\n    TOLERANCE = 1e-12\n\n    def projector(delta, theta, H, w, k):\n        \"\"\"\n        Applies a projector to recover the gauge-invariant comoving density contrast.\n        \n        The formula is Delta = delta + 3 * (1+w) * H / k^2 * theta.\n        \n        Args:\n            delta (float): The synchronous gauge density contrast.\n            theta (float): The synchronous gauge velocity divergence.\n            H (float): The conformal Hubble parameter.\n            w (float): The equation-of-state parameter of the fluid.\n            k (float): The magnitude of the Fourier wavevector.\n            \n        Returns:\n            float: The gauge-invariant comoving density contrast Delta.\n        \"\"\"\n        if k == 0:\n            # For k=0, the expression is ill-defined. In physical scenarios,\n            # for growing modes on superhorizon scales, theta is proportional to k^2,\n            # so the ratio is finite. Test cases here have k > 0.\n            raise ValueError(\"Wavenumber k cannot be zero.\")\n        return delta + 3.0 * (1.0 + w) * H / (k**2) * theta\n\n    def contaminate(delta, theta, H, w, k, alpha):\n        \"\"\"\n        Adds a pure residual synchronous gauge mode to a set of perturbations.\n        \n        The transformations are:\n        delta' = delta + 3 * (1+w) * H * alpha\n        theta' = theta - k^2 * alpha\n        \n        Args:\n            delta (float): The initial density contrast.\n            theta (float): The initial velocity divergence.\n            H (float): The conformal Hubble parameter.\n            w (float): The equation-of-state parameter.\n            k (float): The magnitude of the Fourier wavevector.\n            alpha (float): The amplitude of the gauge mode.\n            \n        Returns:\n            tuple[float, float]: The contaminated (delta', theta') pair.\n        \"\"\"\n        delta_prime = delta + 3.0 * (1.0 + w) * H * alpha\n        theta_prime = theta - k**2 * alpha\n        return delta_prime, theta_prime\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Baseline computation\n        {'type': 'baseline', 'params': {'delta': 0.1, 'theta': -1e-4, 'H': 100.0, 'w': 0.0, 'k': 1e-2}},\n        \n        # Case 2: Invariance under gauge contamination\n        {'type': 'invariance', 'params': {'delta': 0.1, 'theta': -1e-4, 'H': 100.0, 'w': 0.0, 'k': 1e-2, 'alpha': 0.5}},\n        \n        # Case 3: Large-scale recovery\n        {'type': 'recovery', 'params': {'delta_phys': 0.7, 'theta_phys': 0.0, 'H': 100.0, 'w': 0.0, 'k': 1e-5, 'alpha': 300.0, 'target': 0.7}},\n        \n        # Case 4: Extreme super-horizon stability\n        {'type': 'recovery', 'params': {'delta_phys': 0.3, 'theta_phys': 0.0, 'H': 100.0, 'w': 0.0, 'k': 1e-8, 'alpha': 1e6, 'target': 0.3}}\n    ]\n\n    results = []\n    for case in test_cases:\n        case_type = case['type']\n        params = case['params']\n        \n        if case_type == 'baseline':\n            # Main logic to calculate the result for one case goes here.\n            delta_val = projector(params['delta'], params['theta'], params['H'], params['w'], params['k'])\n            results.append(delta_val)\n            \n        elif case_type == 'invariance':\n            # Calculate projector output on original pair\n            delta_orig = projector(params['delta'], params['theta'], params['H'], params['w'], params['k'])\n            \n            # Contaminate the pair\n            delta_c, theta_c = contaminate(\n                params['delta'], params['theta'], params['H'], params['w'], params['k'], params['alpha']\n            )\n            \n            # Calculate projector output on contaminated pair\n            delta_cont = projector(delta_c, theta_c, params['H'], params['w'], params['k'])\n            \n            # Check for equality within tolerance\n            is_invariant = np.abs(delta_orig - delta_cont) = TOLERANCE\n            results.append(is_invariant)\n            \n        elif case_type == 'recovery':\n            # Construct contaminated inputs from the physical ones\n            delta_c, theta_c = contaminate(\n                params['delta_phys'], params['theta_phys'], params['H'], params['w'], params['k'], params['alpha']\n            )\n            \n            # Apply projector to recover the physical value\n            delta_recovered = projector(delta_c, theta_c, params['H'], params['w'], params['k'])\n            \n            # Check if recovered value matches the target\n            is_recovered = np.abs(delta_recovered - params['target']) = TOLERANCE\n            results.append(is_recovered)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在从定义不变量转向维持动态演化中的规范条件时，挑战也随之升级。在数值模拟中，规范选择不仅仅是理论上的设定，它们通常作为演化方程或“驱动项”来实现，并且必须保持稳定。这项高级实践将引导您探索一种动态规范固定方案，并利用爱因斯坦约束方程的违背程度作为强大的诊断工具，来评估规范选择对物理演化的稳定性和影响。",
            "id": "3473430",
            "problem": "要求您设计并实现一个数值实验，用于研究在广义相对论（GR）中模拟谐和规范的规范驱动机制，当应用于线性标量宇宙学微扰时的稳定性。背景是一个空间平坦的、充满无压尘埃（爱因斯坦-德西特模型）的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙。所有量都以无量纲单位表示，所有时间导数都是相对于共形时间 $\\eta$ 的导数。共形哈勃参数定义为 $\\mathcal{H}(\\eta) = a'(\\eta)/a(\\eta)$，其中 $a(\\eta)$ 是标度因子，而 $'$ 表示 $\\mathrm{d}/\\mathrm{d}\\eta$。对于爱因斯坦-德西特宇宙，$a(\\eta)$ 可取为 $a(\\eta) = (\\eta/\\eta_0)^2$，因此 $\\mathcal{H}(\\eta) = 2/\\eta$。\n\n考虑用标量势 $\\phi(\\eta)$、$\\psi(\\eta)$、$B(\\eta)$ 和 $E(\\eta)$ 以及规范不变的 Bardeen 势表示的标量微扰度规\n$$\n\\Phi(\\eta) = \\phi(\\eta) + \\mathcal{H}(\\eta)\\left[B(\\eta) - E'(\\eta)\\right] + \\left[B(\\eta) - E'(\\eta)\\right]', \\quad\n\\Psi(\\eta) = \\psi(\\eta) - \\mathcal{H}(\\eta)\\left[B(\\eta) - E'(\\eta)\\right].\n$$\n对于各向异性应力为零的无压尘埃，您可以取 $\\Phi(\\eta) = \\Psi(\\eta)$。\n\n引入时间规范函数 $\\xi^0(\\eta)$ 并定义规范组合\n$$\ng(\\eta) \\equiv B(\\eta) - E'(\\eta).\n$$\n在由 $\\xi^0(\\eta)$ 生成的时间规范变换下，$g(\\eta)$ 变换为 $g(\\eta) \\to g(\\eta) + \\xi^0(\\eta)$，而度规的时间-时间分量势变换为\n$$\n\\phi(\\eta) \\to \\phi(\\eta) - \\mathcal{H}(\\eta)\\,\\xi^0(\\eta) - \\xi^{0'}(\\eta).\n$$\n通过阻尼驱动振子方程为 $\\xi^0(\\eta)$ 建立一个受谐和规范启发的驱动器\n$$\n\\xi^{0''}(\\eta) + \\gamma\\,\\mathcal{H}(\\eta)\\,\\xi^{0'}(\\eta) + \\Omega^2\\,\\xi^0(\\eta) = -\\lambda\\,g(\\eta),\n$$\n其中 $\\gamma$、$\\Omega$ 和 $\\lambda$ 是常数参数。将 $g(\\eta)$ 视为 $g_0(\\eta) + \\xi^0(\\eta)$ 的和，其中 $g_0(\\eta)$ 是由初始 $(B(\\eta), E(\\eta))$ 选择给出的预设规范剖面。\n\n通过规范耦合的物质守恒方程，演化密度对比 $\\delta(\\eta)$ 的一个具有共动波数 $k$ 的傅里叶模式\n$$\n\\delta''(\\eta) + \\mathcal{H}(\\eta)\\,\\delta'(\\eta) = k^2\\,\\phi(\\eta),\n$$\n其中 $\\phi(\\eta)$ 是瞬时的（依赖于规范的）时间-时间度规微扰，通过一个选定的规范不变目标势 $\\Phi_{\\mathrm{tar}}(\\eta)$ 和当前的规范组合 $g(\\eta)$ 计算得出\n$$\n\\phi(\\eta) = \\Phi_{\\mathrm{tar}}(\\eta) - \\mathcal{H}(\\eta)\\,g(\\eta) - g'(\\eta).\n$$\n\n监控该模式的爱因斯坦能量约束残差，\n$$\n\\mathcal{R}(\\eta) \\equiv k^2\\,\\Phi(\\eta) + 3\\,\\mathcal{H}(\\eta)\\left[\\Phi'(\\eta) + \\mathcal{H}(\\eta)\\,\\Psi(\\eta)\\right] - 4\\pi G\\,a^2(\\eta)\\,\\rho(\\eta)\\,\\delta(\\eta),\n$$\n但使用爱因斯坦-德西特关系 $4 \\pi G\\,a^2\\,\\rho = \\tfrac{3}{2}\\,\\mathcal{H}^2$。假设目标是无各向异性应力的尘埃，因此 $\\Psi(\\eta) = \\Phi(\\eta) = \\Phi_{\\mathrm{tar}}(\\eta)$。为分离规范效应，选择一个恒定的目标势 $\\Phi_{\\mathrm{tar}}(\\eta) = \\Phi_0$ 以及非平凡的规范剖面 $E(\\eta)$ 和 $g_0(\\eta)$。\n\n您必须：\n- 将区间 $[\\eta_i,\\eta_f]$ 均匀离散化，并使用稳定的显式方法对 $\\delta(\\eta)$ 和 $\\xi^0(\\eta)$ 的耦合系统进行积分。使用与 $\\eta_i$ 处的能量约束一致的 $\\delta(\\eta)$ 初始条件，即\n$$\n\\delta(\\eta_i) = \\frac{2}{3}\\,\\Phi_0\\left(3 + \\frac{k^2}{\\mathcal{H}^2(\\eta_i)}\\right), \\quad\n\\delta'(\\eta_i) = \\frac{k^2\\,\\Phi_0}{3}\\,\\eta_i,\n$$\n并初始化 $\\xi^0(\\eta_i) = 0$，$\\xi^{0'}(\\eta_i) = 0$。\n- 生成一个光滑的规范种子 $E(\\eta)$ 和一个光滑的规范剖面 $g_0(\\eta)$，并通过 $B(\\eta) = g_0(\\eta) + E'(\\eta)$ 构建 $B(\\eta)$，使得 $g(\\eta) = g_0(\\eta) + \\xi^0(\\eta)$。\n- 计算整个网格上的约束残差 $\\mathcal{R}(\\eta)$，并报告无量纲的 $L^2$归一化残差\n$$\n\\mathcal{N} \\equiv \\sqrt{\\frac{\\int_{\\eta_i}^{\\eta_f} \\mathcal{R}^2(\\eta)\\,\\mathrm{d}\\eta}{\\int_{\\eta_i}^{\\eta_f} \\left[\\tfrac{3}{2}\\,\\mathcal{H}^2(\\eta)\\,\\delta(\\eta)\\right]^2\\,\\mathrm{d}\\eta}}.\n$$\n\n您的程序必须解决三个具有不同波数和规范驱动器强度的指定测试用例，并以方括号括起来的逗号分隔列表形式，单行输出三个得到的 $\\mathcal{N}$ 值。所有量都是无量纲的；将每个 $\\mathcal{N}$ 报告为浮点数。\n\n测试套件：\n- 案例 A (基线，无驱动器)：$k = 0.01$，$\\Phi_0 = 10^{-5}$，$\\eta_i = 1.0$，$\\eta_f = 10.0$，$\\gamma = 0.0$，$\\Omega = 0.0$，$\\lambda = 0.0$，$E(\\eta) = A_E \\sin(\\omega_E \\eta)$，其中 $A_E = 0.05$，$\\omega_E = 0.8$，以及 $g_0(\\eta) = b_{\\mathrm{amp}} \\sin(\\beta \\eta)$，其中 $b_{\\mathrm{amp}} = 0.1$，$\\beta = 0.4$。\n- 案例 B (弱驱动器)：$k = 0.1$，$\\Phi_0 = 10^{-5}$，$\\eta_i = 1.0$，$\\eta_f = 10.0$，$\\gamma = 1.0$，$\\Omega = 0.5$，$\\lambda = 0.5$，$A_E = 0.05$，$\\omega_E = 0.8$，$b_{\\mathrm{amp}} = 0.1$，$\\beta = 0.4$。\n- 案例 C (强驱动器)：$k = 1.0$，$\\Phi_0 = 10^{-5}$，$\\eta_i = 1.0$，$\\eta_f = 10.0$，$\\gamma = 3.0$，$\\Omega = 1.2$，$\\lambda = 5.0$，$A_E = 0.05$，$\\omega_E = 0.8$，$b_{\\mathrm{amp}} = 0.1$，$\\beta = 0.4$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表的结果（例如，“[result_A,result_B,result_C]”），其中每个结果是相应测试用例计算出的 $\\mathcal{N}$。不允许有其他输出文本。",
            "solution": "该问题要求对一个受谐和规范启发的、用于标量宇宙学微扰的驱动机制的稳定性和有效性进行数值研究。背景设定为一个爱因斯坦-德西特宇宙。任务是演化一个关于物质密度对比和规范驱动函数的耦合常微分方程（ODE）组，然后量化爱因斯坦能量约束的违反程度，以此作为残余规范赝象的度量。\n\n该问题在科学上是适定的，并基于标准的宇宙学微扰理论。所有方程、定义和参数均已提供，构成一个完整的初值问题。因此，该问题是有效的，我们可以着手求解。\n\n问题的核心是求解一个由两个耦合的二阶线性常微分方程组成的系统。为了数值稳定性和清晰性，我们首先将此系统转换为一个由四个一阶常微分方程组成的系统。设状态向量为 $Y(\\eta) = \\begin{bmatrix} \\delta(\\eta)  \\delta'(\\eta)  \\xi^0(\\eta)  \\xi^{0'}(\\eta) \\end{bmatrix}^T$。我们分别将其分量表示为 $y_0, y_1, y_2, y_3$。该一阶常微分方程组 $Y'(\\eta) = F(\\eta, Y)$ 为：\n$$\n\\begin{cases}\ny_0' = y_1 \\\\\ny_1' = -\\mathcal{H}(\\eta) y_1 + k^2 \\phi(\\eta) \\\\\ny_2' = y_3 \\\\\ny_3' = -\\gamma \\mathcal{H}(\\eta) y_3 - (\\Omega^2 + \\lambda) y_2 - \\lambda g_0(\\eta)\n\\end{cases}\n$$\n此处，$\\mathcal{H}(\\eta) = 2/\\eta$ 是爱因斯坦-德西特宇宙中的共形哈勃参数。量 $g_0(\\eta)$ 和 $\\phi(\\eta)$ 是时间和状态变量的函数。\n\n初始规范剖面 $g_0(\\eta)$ 由 $g_0(\\eta) = b_{\\mathrm{amp}} \\sin(\\beta \\eta)$ 给出。其导数为 $g_0'(\\eta) = \\beta b_{\\mathrm{amp}} \\cos(\\beta \\eta)$。\n\n依赖于规范的度规势 $\\phi(\\eta)$ 连接了这两个子系统。其定义为：\n$$\n\\phi(\\eta) = \\Phi_{\\mathrm{tar}}(\\eta) - \\mathcal{H}(\\eta) g(\\eta) - g'(\\eta)\n$$\n其中 $\\Phi_{\\mathrm{tar}}(\\eta) = \\Phi_0$ 是一个常数，总的规范组合 $g(\\eta)$ 及其导数 $g'(\\eta)$ 由下式给出：\n$$\ng(\\eta) = g_0(\\eta) + \\xi^0(\\eta) = g_0(\\eta) + y_2(\\eta)\n$$\n$$\ng'(\\eta) = g_0'(\\eta) + \\xi^{0'}(\\eta) = g_0'(\\eta) + y_3(\\eta)\n$$\n将这些代入 $\\phi(\\eta)$ 的表达式中：\n$$\n\\phi(\\eta) = \\Phi_0 - \\mathcal{H}(\\eta) \\left[ g_0(\\eta) + y_2(\\eta) \\right] - \\left[ g_0'(\\eta) + y_3(\\eta) \\right]\n$$\n然后将这个 $\\phi(\\eta)$ 的表达式代入 $y_1'$ 的方程中，从而完全定义了该耦合系统。请注意，关于 $(y_2, y_3)$ 的子系统独立于 $(y_0, y_1)$，而 $(y_0, y_1)$ 的演化则由 $(y_2, y_3)$ 的解驱动。\n\n该系统将在区间 $\\eta \\in [\\eta_i, \\eta_f]$ 上求解。在 $\\eta = \\eta_i$ 处的初始条件为：\n-   $\\delta(\\eta_i) = y_0(\\eta_i) = \\frac{2}{3}\\,\\Phi_0\\left(3 + \\frac{k^2}{\\mathcal{H}^2(\\eta_i)}\\right)$，其中 $\\mathcal{H}(\\eta_i) = 2/\\eta_i$。\n-   $\\delta'(\\eta_i) = y_1(\\eta_i) = \\frac{k^2\\,\\Phi_0}{3}\\,\\eta_i$。\n-   $\\xi^0(\\eta_i) = y_2(\\eta_i) = 0$。\n-   $\\xi^{0'}(\\eta_i) = y_3(\\eta_i) = 0$。\n\n我们将使用四阶 Runge-Kutta (RK4) 方法在覆盖 $[\\eta_i, \\eta_f]$ 的精细网格上对此系统进行积分。这种显式方法适用于此非刚性系统。\n\n在获得 $\\delta(\\eta)$ 的数值解后，我们计算爱因斯坦能量约束残差 $\\mathcal{R}(\\eta)$。问题指定在残差公式中使用目标势 $\\Phi(\\eta) = \\Psi(\\eta) = \\Phi_{\\mathrm{tar}}(\\eta) = \\Phi_0$。由于 $\\Phi_0$ 是常数，其导数 $\\Phi'(\\eta)$ 为零。残差简化为：\n$$\n\\mathcal{R}(\\eta) = k^2\\,\\Phi_0 + 3\\,\\mathcal{H}(\\eta)\\left[0 + \\mathcal{H}(\\eta)\\,\\Phi_0\\right] - \\frac{3}{2}\\,\\mathcal{H}^2(\\eta)\\,\\delta(\\eta)\n$$\n$$\n\\mathcal{R}(\\eta) = \\left(k^2 + 3\\,\\mathcal{H}^2(\\eta)\\right)\\Phi_0 - \\frac{3}{2}\\,\\mathcal{H}^2(\\eta)\\,\\delta(\\eta)\n$$\n这个残差 $\\mathcal{R}(\\eta)$ 量化了数值演化出的、依赖于规范的 $\\delta(\\eta)$ 在多大程度上未能满足能量约束，而如果规范不变势保持完全恒定，该约束本应成立。非零残差表示存在非物理的规范模式。\n\n最后，我们为每个测试用例计算无量纲的 $L^2$归一化残差 $\\mathcal{N}$：\n$$\n\\mathcal{N} \\equiv \\sqrt{\\frac{\\int_{\\eta_i}^{\\eta_f} \\mathcal{R}^2(\\eta)\\,\\mathrm{d}\\eta}{\\int_{\\eta_i}^{\\eta_f} \\left[\\frac{3}{2}\\,\\mathcal{H}^2(\\eta)\\,\\delta(\\eta)\\right]^2\\,\\mathrm{d}\\eta}}\n$$\n积分将使用 Simpson 法则根据解的离散数据点进行数值计算，该方法为光滑函数提供了高阶近似。\n\n该实现将包含一个主函数，该函数会遍历三个指定的测试用例。对于每个用例，它将：\n1.  设置参数（$k, \\Phi_0, \\gamma, \\Omega, \\lambda$ 等）。\n2.  计算状态向量 $Y(\\eta_i)$ 的初始条件。\n3.  执行从 $\\eta_i$ 到 $\\eta_f$ 的 RK4 积分，以找到每个网格点上的 $Y(\\eta)$。\n4.  使用存储的 $\\delta(\\eta)$ 解来计算整个网格上的残差 $\\mathcal{R}(\\eta)$。\n5.  数值积分 $\\mathcal{R}^2(\\eta)$ 和 $[\\frac{3}{2}\\mathcal{H}^2(\\eta)\\delta(\\eta)]^2$ 以找到归一化值 $\\mathcal{N}$。\n三个案例得到的 $\\mathcal{N}$ 值将被收集并格式化为所需的输出字符串。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef solve():\n    \"\"\"\n    Main function to solve the numerical cosmology problem for the given test cases.\n    \"\"\"\n\n    test_cases = {\n        'A': {\n            'k': 0.01, 'Phi0': 1e-5, 'eta_i': 1.0, 'eta_f': 10.0,\n            'gamma': 0.0, 'Omega': 0.0, 'lambda_': 0.0,\n            'A_E': 0.05, 'omega_E': 0.8, 'b_amp': 0.1, 'beta': 0.4\n        },\n        'B': {\n            'k': 0.1, 'Phi0': 1e-5, 'eta_i': 1.0, 'eta_f': 10.0,\n            'gamma': 1.0, 'Omega': 0.5, 'lambda_': 0.5,\n            'A_E': 0.05, 'omega_E': 0.8, 'b_amp': 0.1, 'beta': 0.4\n        },\n        'C': {\n            'k': 1.0, 'Phi0': 1e-5, 'eta_i': 1.0, 'eta_f': 10.0,\n            'gamma': 3.0, 'Omega': 1.2, 'lambda_': 5.0,\n            'A_E': 0.05, 'omega_E': 0.8, 'b_amp': 0.1, 'beta': 0.4\n        }\n    }\n\n    results = []\n    for case_name in ['A', 'B', 'C']:\n        params = test_cases[case_name]\n        result_N = run_case(**params)\n        results.append(f\"{result_N:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_case(k, Phi0, eta_i, eta_f, gamma, Omega, lambda_, A_E, omega_E, b_amp, beta):\n    \"\"\"\n    Runs a single simulation case.\n    \"\"\"\n    num_steps = 20000\n    eta_grid = np.linspace(eta_i, eta_f, num_steps)\n    h = eta_grid[1] - eta_grid[0]\n\n    # Helper functions\n    H_conf = lambda eta: 2.0 / eta\n    g0 = lambda eta: b_amp * np.sin(beta * eta)\n    g0_prime = lambda eta: beta * b_amp * np.cos(beta * eta)\n\n    # Initial conditions\n    H_i = H_conf(eta_i)\n    y0_init = (2.0 / 3.0) * Phi0 * (3.0 + k**2 / H_i**2)\n    y1_init = (k**2 * Phi0 / 3.0) * eta_i\n    y2_init = 0.0\n    y3_init = 0.0\n    \n    Y = np.zeros((num_steps, 4))\n    Y[0] = [y0_init, y1_init, y2_init, y3_init]\n\n    # ODE system definition\n    def F(eta, y_vec, params):\n        delta, delta_prime, xi0, xi0_prime = y_vec\n        k_p, Phi0_p, gamma_p, Omega_p, lambda_p_p, b_amp_p, beta_p = params\n        \n        # Helper values at current eta\n        H = H_conf(eta)\n        g0_val = g0(eta)\n        g0_prime_val = g0_prime(eta)\n\n        # Gauge-dependent potential phi\n        phi = Phi0_p - H * (g0_val + xi0) - (g0_prime_val + xi0_prime)\n\n        # Derivatives\n        d_delta_dt = delta_prime\n        d_delta_prime_dt = -H * delta_prime + k_p**2 * phi\n        d_xi0_dt = xi0_prime\n        d_xi0_prime_dt = -gamma_p * H * xi0_prime - (Omega_p**2 + lambda_p_p) * xi0 - lambda_p_p * g0_val\n        \n        return np.array([d_delta_dt, d_delta_prime_dt, d_xi0_dt, d_xi0_prime_dt])\n\n    ode_params = (k, Phi0, gamma, Omega, lambda_, b_amp, beta)\n\n    # RK4 Integration\n    for i in range(num_steps - 1):\n        eta_n = eta_grid[i]\n        Y_n = Y[i]\n        \n        k1 = h * F(eta_n, Y_n, ode_params)\n        k2 = h * F(eta_n + 0.5 * h, Y_n + 0.5 * k1, ode_params)\n        k3 = h * F(eta_n + 0.5 * h, Y_n + 0.5 * k2, ode_params)\n        k4 = h * F(eta_n + h, Y_n + k3, ode_params)\n        \n        Y[i+1] = Y_n + (k1 + 2*k2 + 2*k3 + k4) / 6.0\n\n    # Post-processing: Calculate residual R and norm N\n    delta_sol = Y[:, 0]\n    H_grid = H_conf(eta_grid)\n    \n    # Calculate Residual R\n    R_grid = (k**2 + 3 * H_grid**2) * Phi0 - (3.0 / 2.0) * H_grid**2 * delta_sol\n\n    # Calculate normalization term\n    norm_term_integrand = ((3.0 / 2.0) * H_grid**2 * delta_sol)**2\n    \n    # Numerically integrate using Simpson's rule\n    int_R_sq = simpson(R_grid**2, x=eta_grid)\n    int_norm_term = simpson(norm_term_integrand, x=eta_grid)\n\n    # Avoid division by zero if the normalization integral is tiny\n    if int_norm_term  1e-30:\n        return 0.0\n\n    N_val = np.sqrt(int_R_sq / int_norm_term)\n    \n    return N_val\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}