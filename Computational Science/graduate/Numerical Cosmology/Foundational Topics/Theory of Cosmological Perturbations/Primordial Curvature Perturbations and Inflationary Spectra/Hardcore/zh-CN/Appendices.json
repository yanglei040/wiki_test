{
    "hands_on_practices": [
        {
            "introduction": "掌握原初曲率扰动的第一步是理解其在暴胀时期的动力学演化。本练习的核心是数值求解 Mukhanov-Sasaki 方程，这是描述量子涨落在时变背景下演化的基本工具。通过这个实践，您将模拟单个傅里叶模式 $\\mathcal{R}_k$ 从视界内到视界外的完整过程，直观地验证标准绝热情形下超视界扰动的守恒性，并探索非绝热效应对其演化的影响。",
            "id": "3482626",
            "problem": "你的任务是构建一个数值实验，以演化在暴胀期间穿越视界时的共动曲率微扰模式 $ {\\cal R}_k $，此演化过程针对两种情景：绝热单场情景和受双场启发的轻度非绝热情景。目标是使用一个能够捕捉视界穿越附近及之后主导物理过程的、科学上合理的玩具模型，来量化 $ {\\cal R}_k $ 守恒的偏离程度，并将其表示为共动波数 $ k $ 的函数。\n\n使用以下基本框架：\n\n- 对于在共形时间 $ \\eta $ 下的正则归一化变量 $ u_k = z \\, {\\cal R}_k $，其在准德西特背景下的 Mukhanov–Sasaki 方程为\n$$\nu_k'' + \\left(c_s^2 k^2 - \\frac{z''}{z}\\right) u_k = 0 ,\n$$\n其中撇号表示对 $ \\eta $ 的微分。对于慢滚参数 $ \\epsilon \\ll 1 $ 和哈勃率 $ H $ 均为常数的正则单场慢滚暴胀，我们采用 $ c_s = 1 $，并且当 $ \\eta  0 $ 时，$ a(\\eta) = -\\frac{1}{H \\eta} $。在约化普朗克单位（约化普朗克质量等于1）下，令\n$$\nz(\\eta) = a(\\eta) \\sqrt{2 \\epsilon}, \\quad \\text{所以} \\quad \\frac{z''}{z} = \\frac{2}{\\eta^2}.\n$$\n\n- 在视界深处（$ k |\\eta| \\gg 1 $），将模式初始化在 Bunch–Davies 真空中：\n$$\nu_k(\\eta_i) \\approx \\frac{e^{-i k \\eta_i}}{\\sqrt{2 k}}, \\quad u_k'(\\eta_i) \\approx -i k \\, u_k(\\eta_i),\n$$\n在一个满足 $ k |\\eta_i| \\gg 1 $ 的合适的早期初始共形时间 $ \\eta_i $ 处。\n\n- 视界穿越发生在 $ k = a H $ 时，对于我们采用的背景，这发生在 $ \\eta_\\text{cross} = -\\frac{1}{k} $。\n\n- 对于绝热情况，使用齐次的 Mukhanov–Sasaki 方程演化 $ u_k $，计算 $ {\\cal R}_k = u_k / z $，并量化从视界穿越时刻 $ \\eta_\\text{cross} $ 到视界穿越后的一个固定晚期时刻 $ \\eta_\\text{late} $ 之间振幅的分数变化：\n$$\n\\Delta_{\\text{ad}}(k) = \\frac{\\left|{\\cal R}_k(\\eta_\\text{late})\\right| - \\left|{\\cal R}_k(\\eta_\\text{cross})\\right|}{\\left|{\\cal R}_k(\\eta_\\text{cross})\\right|}.\n$$\n\n- 对于轻度非绝热情况，模拟一个由场空间中恒定转向率引起的、从等曲率到曲率的微小超视界转移。在按上述方法计算出 $ \\left|{\\cal R}_k(\\eta_\\text{cross})\\right| $ 后，假设在视界穿越时存在一个等曲率振幅 $ S_k(N_\\text{cross}) = \\sigma \\left|{\\cal R}_k(\\eta_\\text{cross})\\right| $，其中 $ \\sigma \\ll 1 $ 是一个小比率。设 $ N $ 为 e-folds 数，使用标准的超视界唯象耦合\n$$\n\\frac{d {\\cal R}_k}{dN} \\approx 2 \\Theta \\, S_k, \\quad \\frac{d S_k}{dN} \\approx -\\mu \\, S_k ,\n$$\n其中 $ \\Theta $ 是恒定的转向率（以哈勃率为单位），而 $ \\mu > 0 $ 是熵衰减率。在从 $ \\eta_\\text{cross} $ 到 $ \\eta_\\text{late} $ 的 $ \\Delta N $ 个 e-folds 期间，这会在振幅上产生一个附加的变化\n$$\n\\delta {\\cal R}_k \\approx \\frac{2 \\Theta}{\\mu} S_k(N_\\text{cross}) \\left(1 - e^{-\\mu \\Delta N}\\right),\n$$\n对于所采用的背景，有 $ \\Delta N = \\ln\\left(\\frac{a(\\eta_\\text{late})}{a(\\eta_\\text{cross})}\\right) = \\ln\\left(\\frac{|\\eta_\\text{cross}|}{|\\eta_\\text{late}|}\\right) $。将非绝热情况的分数偏差定义为\n$$\n\\Delta_{\\text{nonad}}(k) = \\frac{\\left(\\left|{\\cal R}_k(\\eta_\\text{late})\\right| + \\delta {\\cal R}_k\\right) - \\left|{\\cal R}_k(\\eta_\\text{cross})\\right|}{\\left|{\\cal R}_k(\\eta_\\text{cross})\\right|}.\n$$\n\n数值与建模说明：\n\n- 完全在约化普朗克单位下进行计算，并设 $ H = 1 $，因此所有量都是无量纲的。\n- 使用 $ \\epsilon = 0.01 $、 $ \\Theta = 0.01 $、 $ \\mu = 0.2 $、 $ \\sigma = 0.05 $。\n- 对于下面测试套件中的每个共动波数 $ k $，将 Mukhanov–Sasaki 方程从 $ \\eta_i = -\\frac{50}{k} $ 积分到 $ \\eta_\\text{cross} = -\\frac{1}{k} $，然后继续积分到 $ \\eta_\\text{late} = -10^{-3} $。在 $ \\eta_i $ 处使用上面给出的初始条件。按上述定义计算 $ \\Delta_{\\text{ad}}(k) $ 和 $ \\Delta_{\\text{nonad}}(k) $。\n- 如果出现任何角度，都必须以弧度为单位。然而，要求的输出是无量纲浮点数；最终答案中不需要物理单位。\n\n测试套件：\n\n- 使用 $ k \\in \\{0.05, 0.5, 5.0, 50.0\\} $，这将探测晚期穿越、典型穿越和早期穿越，覆盖了非常小的 $ k $ 处的边界和非常大的 $ k $ 处的边缘情况。\n\n最终输出规格：\n\n- 你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序如下\n$$\n[\\Delta_{\\text{ad}}(0.05), \\Delta_{\\text{nonad}}(0.05), \\Delta_{\\text{ad}}(0.5), \\Delta_{\\text{nonad}}(0.5), \\Delta_{\\text{ad}}(5.0), \\Delta_{\\text{nonad}}(5.0), \\Delta_{\\text{ad}}(50.0), \\Delta_{\\text{nonad}}(50.0)]。\n$$\n每个条目必须是一个浮点数。",
            "solution": "用户提供了一个有效且适定的数值宇宙学问题。该问题在科学上基于标准的暴胀微扰理论，并提供了一整套完整的方程、参数和数值计算指令。任务是计算共动曲率微扰 $\\mathcal{R}_k$ 在一系列共动波数 $k$ 下的分数变化，这需要在两种情景下进行：标准的绝热演化和一个唯象的非绝热情况。\n\n解决此问题的算法设计如下：\n\n首先，我们处理正则归一化变量 $u_k = z \\mathcal{R}_k$ 的演化。其动力学由 Mukhanov-Sasaki 方程决定，对于给定的准德西特背景，该方程简化为关于共形时间 $\\eta$ 的一个二阶线性常微分方程（ODE）：\n$$\nu_k'' + \\left(k^2 - \\frac{2}{\\eta^2}\\right) u_k = 0\n$$\n这里，撇号表示对 $\\eta$ 的微分。变量 $u_k(\\eta)$ 是一个复数。为了数值求解该方程，我们将 $u_k$分解为其​​实部和虚部，$u_k(\\eta) = u_{k,R}(\\eta) + i u_{k,I}(\\eta)$。由于该常微分方程的系数是实数，其实部和虚部是解耦的，并且各自独立地满足同一个常微分方程：\n$$\nu_{k,R}'' + \\left(k^2 - \\frac{2}{\\eta^2}\\right) u_{k,R} = 0\n$$\n$$\nu_{k,I}'' + \\left(k^2 - \\frac{2}{\\eta^2}\\right) u_{k,I} = 0\n$$\n为了进行数值积分，这些二阶常微分方程中的每一个都被转换成一个由两个一阶常微分方程组成的系统。对于满足该方程的一个通用实函数 $y(\\eta)$，我们定义一个状态向量 $\\mathbf{y}(\\eta) = [y(\\eta), y'(\\eta)]^T$。那么，一阶常微分方程组为：\n$$\n\\frac{d\\mathbf{y}}{d\\eta} = \\begin{bmatrix} y' \\\\ y'' \\end{bmatrix} = \\begin{bmatrix} y' \\\\ -\\left(k^2 - \\frac{2}{\\eta^2}\\right) y \\end{bmatrix}\n$$\n该问题指定在视界深处的初始时间 $\\eta_i = -50/k$ 设置 Bunch-Davies 初始条件。此条件对应于 $k|\\eta_i| = 50 \\gg 1$。初始状态由下式给出：\n$$\nu_k(\\eta_i) = \\frac{e^{-i k \\eta_i}}{\\sqrt{2 k}} = \\frac{e^{i 50}}{\\sqrt{2 k}}, \\quad u_k'(\\eta_i) = -i k u_k(\\eta_i)\n$$\n将它们分解为实部和虚部，为两个常微分方程组提供了初始条件：\n$$\nu_{k,R}(\\eta_i) = \\frac{\\cos(50)}{\\sqrt{2k}}, \\quad u_{k,R}'(\\eta_i) = \\frac{k\\sin(50)}{\\sqrt{2k}}\n$$\n$$\nu_{k,I}(\\eta_i) = \\frac{\\sin(50)}{\\sqrt{2k}}, \\quad u_{k,I}'(\\eta_i) = -\\frac{k\\cos(50)}{\\sqrt{2k}}\n$$\n对于测试套件中的每个波数 $k$，我们将这两个系统从 $\\eta_i = -50/k$ 积分到一个晚期时间 $\\eta_{\\text{late}} = -10^{-3}$，对于所有指定的 $k$ 而言，该时间点都远在视界穿越之后。数值积分使用高精度的自适应步长求解器执行，具体为 `scipy.integrate.solve_ivp`。我们要求解器在两个特定点上提供解：视界穿越点 $\\eta_{\\text{cross}} = -1/k$ 和最终时间 $\\eta_{\\text{late}}$。\n\n根据 $u_{k,R}$ 和 $u_{k,I}$ 的数值解，我们在 $\\eta_{\\text{cross}}$ 和 $\\eta_{\\text{late}}$ 时刻重构复数模式函数 $u_k$ 及其模 $|u_k| = \\sqrt{u_{k,R}^2 + u_{k,I}^2}$。\n\n然后通过其定义 $\\mathcal{R}_k = u_k / z$ 来恢复共动曲率微扰 $\\mathcal{R}_k$。泵浦场 $z(\\eta)$ 由 $z(\\eta) = a(\\eta)\\sqrt{2\\epsilon} = -\\frac{\\sqrt{2\\epsilon}}{H\\eta}$ 给出。当 $H=1$ 时，其模为 $|z(\\eta)| = \\frac{\\sqrt{2\\epsilon}}{|\\eta|}$。因此，曲率微扰的模为 $|\\mathcal{R}_k(\\eta)| = |u_k(\\eta)| / |z(\\eta)|$。\n\n在计算出 $|\\mathcal{R}_k(\\eta_{\\text{cross}})|$ 和 $|\\mathcal{R}_k(\\eta_{\\text{late}})|$ 后，我们计算绝热情况下的分数变化：\n$$\n\\Delta_{\\text{ad}}(k) = \\frac{|\\mathcal{R}_k(\\eta_{\\text{late}})| - |\\mathcal{R}_k(\\eta_{\\text{cross}})|}{|\\mathcal{R}_k(\\eta_{\\text{cross}})|}\n$$\n对于非绝热情况，一个超视界贡献 $\\delta \\mathcal{R}_k$ 被加到 $\\mathcal{R}_k$ 的振幅上。这个贡献模拟了从等曲率模式的转移，并按如下方式计算：\n$$\n\\delta{\\cal R}_k = \\frac{2 \\Theta \\sigma}{\\mu} |\\mathcal{R}_k(\\eta_{\\text{cross}})| \\left(1 - e^{-\\mu \\Delta N}\\right)\n$$\n其中，视界穿越和晚期时间之间的 e-folds 数为 $\\Delta N = \\ln(|\\eta_{\\text{cross}}|/|\\eta_{\\text{late}}|) = \\ln(\\frac{1/k}{10^{-3}}) = \\ln(1000/k)$。给定的参数为 $\\Theta=0.01$、$\\sigma=0.05$ 和 $\\mu=0.2$。然后，非绝热情况的分数偏差定义为：\n$$\n\\Delta_{\\text{nonad}}(k) = \\frac{\\left(|\\mathcal{R}_k(\\eta_{\\text{late}})| + \\delta \\mathcal{R}_k\\right) - |\\mathcal{R}_k(\\eta_{\\text{cross}})|}{|\\mathcal{R}_k(\\eta_{\\text{cross}})|} = \\Delta_{\\text{ad}}(k) + \\frac{\\delta \\mathcal{R}_k}{|\\mathcal{R}_k(\\eta_{\\text{cross}})|}\n$$\n第二项简化为 $\\frac{2 \\Theta \\sigma}{\\mu} (1 - e^{-\\mu \\Delta N})$。\n\n此过程系统地应用于测试套件 $\\{0.05, 0.5, 5.0, 50.0\\}$ 中的每个 $k$ 值，并将得到的 $\\Delta_{\\text{ad}}(k)$ 和 $\\Delta_{\\text{nonad}}(k)$ 值收集并格式化为指定的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the fractional change in the comoving curvature perturbation R_k\n    for both adiabatic and non-adiabatic scenarios across a range of wavenumbers k.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (epsilon, Theta, mu, sigma, H, wavenumbers)\n        (0.01, 0.01, 0.2, 0.05, 1.0, [0.05, 0.5, 5.0, 50.0])\n    ]\n\n    for case in test_cases:\n        epsilon, Theta, mu, sigma, H, k_values = case\n        \n        results = []\n\n        # Pre-compute constants to optimize the loop\n        sqrt_2_epsilon = np.sqrt(2.0 * epsilon)\n        cos50 = np.cos(50.0)\n        sin50 = np.sin(50.0)\n        non_ad_coeff = (2.0 * Theta * sigma) / mu\n\n        def mukhanov_sasaki_system(eta, y, k):\n            \"\"\"\n            Defines the system of first-order ODEs for the Mukhanov-Sasaki equation.\n            y[0] = u_k, y[1] = u_k'\n            The equation is u_k'' + (k^2 - 2/eta^2) * u_k = 0\n            \"\"\"\n            potential = k**2 - 2.0 / eta**2\n            return [y[1], -potential * y[0]]\n\n        for k in k_values:\n            # 1. Define integration and evaluation time points\n            eta_i = -50.0 / k\n            eta_cross = -1.0 / k\n            eta_late = -1.0e-3\n            \n            # 2. Set up initial conditions based on the Bunch-Davies vacuum approximation\n            # The normalization factor 1/sqrt(2k)\n            norm = 1.0 / np.sqrt(2.0 * k)\n            \n            # Real part of u_k and its derivative\n            uR_i = cos50 * norm\n            uR_prime_i = k * sin50 * norm\n            y0_R = [uR_i, uR_prime_i]\n\n            # Imaginary part of u_k and its derivative\n            uI_i = sin50 * norm\n            uI_prime_i = -k * cos50 * norm\n            y0_I = [uI_i, uI_prime_i]\n\n            # 3. Points in time where the solution is to be evaluated\n            t_eval_points = [eta_cross, eta_late]\n\n            # 4. Numerically integrate the ODE for both real and imaginary parts\n            sol_R = solve_ivp(\n                fun=mukhanov_sasaki_system,\n                t_span=(eta_i, eta_late),\n                y0=y0_R,\n                t_eval=t_eval_points,\n                args=(k,),\n                method='RK45',\n                rtol=1e-12,\n                atol=1e-12\n            )\n\n            sol_I = solve_ivp(\n                fun=mukhanov_sasaki_system,\n                t_span=(eta_i, eta_late),\n                y0=y0_I,\n                t_eval=t_eval_points,\n                args=(k,),\n                method='RK45',\n                rtol=1e-12,\n                atol=1e-12\n            )\n\n            # 5. Extract the solutions at eta_cross and eta_late\n            uR_at_eval_points = sol_R.y[0]\n            uI_at_eval_points = sol_I.y[0]\n\n            # 6. Reconstruct the magnitude of u_k\n            u_mag_cross = np.sqrt(uR_at_eval_points[0]**2 + uI_at_eval_points[0]**2)\n            u_mag_late = np.sqrt(uR_at_eval_points[1]**2 + uI_at_eval_points[1]**2)\n\n            # 7. Calculate the magnitude of R_k = u_k / z\n            # |z(eta)| = sqrt(2*epsilon) / |eta| since H=1\n            z_mag_cross = sqrt_2_epsilon / abs(eta_cross)\n            z_mag_late = sqrt_2_epsilon / abs(eta_late)\n            \n            R_k_mag_cross = u_mag_cross / z_mag_cross\n            R_k_mag_late = u_mag_late / z_mag_late\n            \n            # 8. Compute the fractional change for the adiabatic case\n            delta_ad = (R_k_mag_late - R_k_mag_cross) / R_k_mag_cross\n            results.append(delta_ad)\n\n            # 9. Compute the fractional change for the non-adiabatic case\n            # The number of e-folds between horizon crossing and late time\n            delta_N = np.log(abs(eta_cross) / abs(eta_late))\n            \n            # The super-horizon contribution to R_k, normalized by |R_k(cross)|\n            non_ad_term = non_ad_coeff * (1.0 - np.exp(-mu * delta_N))\n            \n            delta_nonad = delta_ad + non_ad_term\n            results.append(delta_nonad)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了单个模式的基本演化后，下一步是确保数值模拟的可靠性。本练习聚焦于一个关键的实际问题：为了在最终计算的功率谱中达到预设的精度，我们必须在多早的亚视界区域（即 $k/(aH)$ 多大时）设置 Bunch-Davies 真空初始条件？通过进行收敛性测试，您将学会如何量化和控制由初始条件选择引入的数值误差，这是进行任何精确宇宙学计算的基础。",
            "id": "3482615",
            "problem": "要求您量化和校准当 Mukhanov–Sasaki 模函数在有限的亚视界比率 $X_0 \\equiv k/(aH)$ 而非在精确的无限亚视界极限下初始化时，数值计算原始曲率功率谱所产生的精度损失。您的任务是编写一个完整的、可运行的程序，该程序针对由 $z''/z(\\tau)$ 给定的一族指定的背景动力学，确定能使 $P_{\\mathcal{R}}(k)$ 相对于使用一个大得多的 $X_{\\mathrm{ref}}$ 计算出的高保真度参考值的相对误差小于 $0.001$ 的最小 $X_0$。\n\n基本方程和模型假设：\n- 原始曲率扰动模由满足 Mukhanov–Sasaki 方程的 $v_k(\\tau)$ 定义\n$$\nv_k''(\\tau) + \\Big(k^2 - \\frac{z''(\\tau)}{z(\\tau)}\\Big) v_k(\\tau) = 0,\n$$\n其中 $'$ 表示对共形时间 $\\tau$ 的导数。\n- 曲率扰动为 $ \\mathcal{R}_k(\\tau) = v_k(\\tau)/z(\\tau)$，其在冻结时的功率谱为\n$$\nP_{\\mathcal{R}}(k) = \\frac{k^3}{2\\pi^2} \\left| \\mathcal{R}_k(\\tau_{\\mathrm{end}}) \\right|^2.\n$$\n- 亚视界 Bunch–Davies 初始条件施加于一个有限的 $\\tau_0$ 处，在该处 $X_0 \\equiv k/(aH)$ 有一个指定值。在深亚视界机制下，初始条件为\n$$\nv_k(\\tau_0) = \\frac{e^{-i k \\tau_0}}{\\sqrt{2k}}, \\quad v_k'(\\tau_0) = -i \\sqrt{\\frac{k}{2}} e^{-i k \\tau_0}.\n$$\n- 我们采用将约化普朗克质量、光速和哈勃常数尺度均设为1的单位制：$M_{\\mathrm{Pl}} = c = \\hbar = H_0 = 1$。程序中的所有量都是无量纲的。\n- 我们假设一个恒定的早期第一慢滚参数 $\\epsilon_0 \\in (0,1)$，以及对于恒定的 $\\epsilon_0$，共形时间到哈勃穿越的映射为\n$$\naH = -\\frac{1}{(1-\\epsilon_0)\\,\\tau}, \\quad \\Rightarrow \\quad \\frac{k}{aH} = -k(1-\\epsilon_0)\\,\\tau.\n$$\n因此，对应于目标 $X_0$ 的初始化时间是\n$$\n\\tau_0 = -\\frac{X_0}{(1-\\epsilon_0)\\,k}.\n$$\n我们在晚期时间 $\\tau_{\\mathrm{end}}$ 处评估谱，此时 $X_{\\mathrm{end}} \\equiv k/(aH) = 10^{-3}$，即，\n$$\n\\tau_{\\mathrm{end}} = -\\frac{X_{\\mathrm{end}}}{(1-\\epsilon_0)\\,k}.\n$$\n\n背景设定：\n- 定义一个具有恒定 $\\epsilon_0$ 的基准背景，对于该背景\n$$\na(\\tau) \\propto (-\\tau)^{p}, \\quad p \\equiv -\\frac{1}{1-\\epsilon_0}.\n$$\n- 定义\n$$\nz(\\tau) = (-\\tau)^{p}\\,\\Big(1 + g_b(\\tau)\\Big),\n$$\n其中特征函数 $g_b(\\tau)$ 是一个在 $\\ln(-\\tau)$ 中局域的、呈对数正态分布形状的鼓包，\n$$\ng_b(\\tau) = A \\exp\\!\\left[-\\frac{1}{2}\\left(\\frac{s(\\tau)}{\\sigma}\\right)^2\\right], \\quad s(\\tau) \\equiv \\ln\\!\\left(\\frac{-\\tau}{\\tau_f}\\right),\n$$\n振幅为 $A$，宽度为 $\\sigma$。该特征的中心位于 $\\tau_f \\equiv 1/k$，以使该特征处于模 $k$ 的视界穿越附近。\n- 对于此 $z(\\tau)$，可以证明\n$$\n\\frac{z''}{z}(\\tau) = \\frac{1}{\\tau^2}\\left[ p(p-1) + \\frac{g_b}{1+g_b}\\left(\\frac{s^2}{\\sigma^4} - \\frac{1-s}{\\sigma^2} - \\frac{2 p s}{\\sigma^2}\\right) \\right],\n$$\n其中 $g_b = g_b(\\tau)$ 且 $s = s(\\tau)$。当 $A=0$ 时，此式简化为 $\\frac{z''}{z} = \\frac{p(p-1)}{\\tau^2}$。\n\n数值任务：\n- 对于下述每个测试案例，您必须：\n  1. 通过从 $\\tau_{\\mathrm{ref}} = -X_{\\mathrm{ref}}/[(1-\\epsilon_0)k]$（其中 $X_{\\mathrm{ref}} = 2000$）积分到 $\\tau_{\\mathrm{end}}$，计算一个高保真度参考值 $P_{\\mathcal{R}}^{\\mathrm{ref}}(k)$。\n  2. 对于一组候选初始化比率 $X_0 \\in \\{5, 10, 20, 50, 100, 200, 500, 1000\\}$，计算 $P_{\\mathcal{R}}(k; X_0)$ 和相对误差\n     $$\n     \\Delta(X_0) \\equiv \\left| \\frac{P_{\\mathcal{R}}(k; X_0) - P_{\\mathcal{R}}^{\\mathrm{ref}}(k)}{P_{\\mathcal{R}}^{\\mathrm{ref}}(k)} \\right|.\n     $$\n  3. 确定满足 $\\Delta(X_0)  0.001$ 的最小 $X_0$。如果没有候选值满足该标准，则为该测试案例返回 $-1$。\n\n科学依据：\n- 从 Mukhanov–Sasaki 方程、曲率扰动及其功率的定义、亚视界 Bunch–Davies 初始条件，以及对于恒定 $\\epsilon_0$ 的 $\\tau$ 和 $k/(aH)$ 之间的映射出发。\n- 不要使用目标捷径；按所给出的形式对二阶方程进行积分。\n- 本问题中不涉及角度。\n- 如前所述，程序中的所有量都是无量纲的。\n\n测试套件：\n为以下四个测试案例提供结果，在所有案例中，特征中心均位于 $\\tau_f = 1/k$：\n1. 案例1（基准线，理想路径）：$\\epsilon_0 = 0.01$, $A = 0.0$, $\\sigma = 0.5$, $k = 0.1$。\n2. 案例2（视界穿越附近的中等强度特征）：$\\epsilon_0 = 0.01$, $A = 0.5$, $\\sigma = 0.3$, $k = 0.1$。\n3. 案例3（较大的慢滚参数）：$\\epsilon_0 = 0.10$, $A = 0.0$, $\\sigma = 0.5$, $k = 1.0$。\n4. 案例4（尖锐特征和长波模）：$\\epsilon_0 = 0.01$, $A = 0.8$, $\\sigma = 0.1$, $k = 0.01$。\n\n精度和输出：\n- 您的程序必须使用一个鲁棒的数值常微分方程求解器，并设置足够严格的容差，以解析动力学过程并生成一个可信的参考基准。\n- 您的程序应生成单行输出，其中包含按上述顺序列出的每个测试案例的最小 $X_0$，格式为用方括号括起来的逗号分隔列表（例如，“[x1,x2,x3,x4]”）。每个条目必须是候选集中的一个整数，或者如果没有任何候选值满足 $0.001$ 的要求，则为 $-1$。",
            "solution": "用户提供的问题陈述已经过分析并被确定为**有效**。这是一个在数值宇宙学领域内适定的、有科学依据的问题，没有矛盾、歧义或不成立的前提。其任务是编写一个程序，量化因在有限的亚视界尺度而非渐近过去初始化模函数演化而导致的原始功率谱中的数值误差。\n\n该解决方案将通过以下步骤实现：\n1.  **定义计算框架**：将设计一个名为 `PrimordialSpectrumCalculator` 的类，用以封装单个宇宙学模型的参数和物理过程。该类将包含计算势能项 $z''/z$、背景函数 $z(\\tau)$ 以及求解 Mukhanov-Sasaki 方程以求出给定初始化尺度下的功率谱的方法。\n2.  **实现物理模型**：\n    *   将求解复值的 Mukhanov-Sasaki 方程 $v_k'' + (k^2 - z''/z)v_k = 0$。这个二阶常微分方程 (ODE) 会被转换为一个关于状态向量 $Y = [v_k, v_k']$ 的一阶常微分方程组。\n    *   项 $z''/z(\\tau)$ 将完全按照问题陈述中的规定实现，它依赖于慢滚参数 $\\epsilon_0$ 和特征参数 $A$ 和 $\\sigma$。\n    *   $v_k(\\tau_0)$ 和 $v_k'(\\tau_0)$ 的 Bunch-Davies 初始条件将应用于起始共形时间 $\\tau_0$。\n3.  **数值积分**：\n    *   将使用 `scipy.integrate.solve_ivp` 函数进行数值积分。选择一个高阶方法 (`DOP853`) 并配合严格的相对和绝对容差 ($10^{-12}$)，以确保 ODE 求解器本身的数值精度与所研究的误差源（有限的初始化时间）相比可以忽略不计。\n    *   对于给定的一组模型参数 ($\\epsilon_0, A, \\sigma, k$) 和一个初始化比率 $X_0 = k/(aH)|_0$，模函数 $v_k$ 将从 $\\tau_0 = -X_0/((1-\\epsilon_0)k)$ 演化到晚期时间 $\\tau_{\\mathrm{end}} = -X_{\\mathrm{end}}/((1-\\epsilon_0)k)$，其中 $X_{\\mathrm{end}} = 10^{-3}$。\n4.  **功率谱计算**：\n    *   在最终时间 $\\tau_{\\mathrm{end}}$，从 ODE 解中提取 $v_k(\\tau_{\\mathrm{end}})$ 的值。\n    *   使用提供的公式计算函数 $z(\\tau_{\\mathrm{end}})$。\n    *   计算曲率扰动 $\\mathcal{R}_k(\\tau_{\\mathrm{end}}) = v_k(\\tau_{\\mathrm{end}})/z(\\tau_{\\mathrm{end}})$。\n    *   然后计算功率谱为 $P_{\\mathcal{R}}(k) = \\frac{k^3}{2\\pi^2} |\\mathcal{R}_k(\\tau_{\\mathrm{end}})|^2$。\n5.  **误差分析与搜索**：\n    *   对于四个测试案例中的每一个，通过将初始化比率设置为一个大值 $X_{\\mathrm{ref}} = 2000$ 来计算一个高保真度的参考功率谱 $P_{\\mathcal{R}}^{\\mathrm{ref}}$。\n    *   程序随后遍历候选初始化比率的排序列表 $X_0 \\in \\{5, 10, 20, 50, 100, 200, 500, 1000\\}$。\n    *   对于每个候选 $X_0$，计算功率谱 $P_{\\mathcal{R}}(k; X_0)$ 并评估相对误差 $\\Delta(X_0) = |(P_{\\mathcal{R}}(k; X_0) - P_{\\mathcal{R}}^{\\mathrm{ref}})/P_{\\mathcal{R}}^{\\mathrm{ref}}|$。\n    *   将候选集中第一个（因此也是最小的）满足 $\\Delta(X_0)  0.001$ 的 $X_0$ 值记录为该测试案例的结果。\n    *   如果没有候选 $X_0$ 满足精度要求，则记录数值 $-1$。\n6.  **生成输出**：将四个测试案例的最终结果编译成一个单一字符串，其格式为指定的用方括号括起来的逗号分隔整数列表。\n\n该实现将被结构化在单个 `solve()` 函数内，以确保其自包含并遵守指定的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n\n    class PrimordialSpectrumCalculator:\n        \"\"\"\n        A class to encapsulate the physics and numerical methods for computing\n        the primordial power spectrum for a given cosmological model.\n        \"\"\"\n        def __init__(self, epsilon_0, A, sigma, k):\n            self.epsilon_0 = float(epsilon_0)\n            self.A = float(A)\n            self.sigma = float(sigma)\n            self.k = float(k)\n\n            # Derived parameters from the model\n            self.p = -1.0 / (1.0 - self.epsilon_0)\n            self.tau_f = 1.0 / self.k\n            self.X_end = 1e-3\n            self.tau_end = -self.X_end / ((1.0 - self.epsilon_0) * self.k)\n\n        def _zpp_over_z(self, tau):\n            \"\"\"Computes the z''/z term in the Mukhanov-Sasaki equation.\"\"\"\n            if self.A == 0.0:\n                return (self.p * (self.p - 1.0)) / (tau**2)\n\n            s = np.log(-tau / self.tau_f)\n            g_b = self.A * np.exp(-0.5 * (s / self.sigma)**2)\n            \n            term1 = self.p * (self.p - 1.0)\n            \n            # This term can be zero if g_b is zero (as tau -> -inf)\n            if g_b  1e-100: # Practically zero\n                 g_ratio_term = 0.0\n            else:\n                g_ratio = g_b / (1.0 + g_b)\n                bracket_term = (s**2 / self.sigma**4) - ((1.0 - s) / self.sigma**2) - (2.0 * self.p * s / self.sigma**2)\n                g_ratio_term = g_ratio * bracket_term\n            \n            potential = (1.0 / tau**2) * (term1 + g_ratio_term)\n            return potential\n\n        def _z_func(self, tau):\n            \"\"\"Computes the value of the background function z(tau).\"\"\"\n            if self.A == 0.0:\n                return (-tau)**self.p\n\n            s = np.log(-tau / self.tau_f)\n            g_b = self.A * np.exp(-0.5 * (s / self.sigma)**2)\n            return (-tau)**self.p * (1.0 + g_b)\n\n        def _ode_system(self, tau, y):\n            \"\"\"The system of first-order ODEs for [v, v'].\"\"\"\n            v, v_prime = y\n            potential_val = self._zpp_over_z(tau)\n            \n            # v'' = -(k^2 - z''/z) * v\n            dv_prime_dtau = -(self.k**2 - potential_val) * v\n            dv_dtau = v_prime\n            \n            return np.array([dv_dtau, dv_prime_dtau], dtype=complex)\n\n        def compute_power_spectrum(self, X_0):\n            \"\"\"\n            Solves the Mukhanov-Sasaki equation and computes the power spectrum\n            for a given initialization ratio X_0.\n            \"\"\"\n            tau_0 = -X_0 / ((1.0 - self.epsilon_0) * self.k)\n            \n            # Bunch-Davies initial conditions for the mode function\n            v0 = np.exp(-1j * self.k * tau_0) / np.sqrt(2.0 * self.k)\n            v0_prime = -1j * np.sqrt(self.k / 2.0) * np.exp(-1j * self.k * tau_0)\n            y0 = np.array([v0, v0_prime], dtype=complex)\n\n            t_span = [tau_0, self.tau_end]\n            \n            # Use a robust, high-precision ODE solver\n            sol = solve_ivp(\n                self._ode_system,\n                t_span,\n                y0,\n                method='DOP853',\n                rtol=1e-12,\n                atol=1e-12\n            )\n\n            # Extract final value of the mode function\n            v_end = sol.y[0, -1]\n            \n            z_at_end = self._z_func(self.tau_end)\n            \n            R_k_end = v_end / z_at_end\n            P_R = (self.k**3) / (2.0 * np.pi**2) * np.abs(R_k_end)**2\n            \n            return P_R\n            \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (epsilon_0, A, sigma, k)\n        (0.01, 0.0, 0.5, 0.1),   # Case 1\n        (0.01, 0.5, 0.3, 0.1),   # Case 2\n        (0.10, 0.0, 0.5, 1.0),   # Case 3\n        (0.01, 0.8, 0.1, 0.01),  # Case 4\n    ]\n\n    # Constants for the numerical task\n    X_ref = 2000.0\n    candidate_X0s = [5, 10, 20, 50, 100, 200, 500, 1000]\n    error_threshold = 0.001\n    \n    results = []\n    for case in test_cases:\n        epsilon_0, A, sigma, k = case\n        calculator = PrimordialSpectrumCalculator(epsilon_0, A, sigma, k)\n\n        # 1. Compute the high-fidelity reference value\n        p_r_ref = calculator.compute_power_spectrum(X_ref)\n\n        # 2. Search for the minimal X_0 that satisfies the error criterion\n        min_X0 = -1\n        for X0_candidate in candidate_X0s:\n            p_r_candidate = calculator.compute_power_spectrum(float(X0_candidate))\n            \n            if p_r_ref == 0:\n                # This case is physically unlikely and indicates a potential issue,\n                # but we handle it robustly.\n                error = np.inf if p_r_candidate != 0 else 0.0\n            else:\n                error = np.abs((p_r_candidate - p_r_ref) / p_r_ref)\n\n            if error  error_threshold:\n                min_X0 = X0_candidate\n                break\n        \n        results.append(min_X0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "拥有了可靠的数值模拟工具后，我们可以转向更高级的分析。本练习将功率谱中的振荡特征视为在对数波数空间中的一个“信号”。借鉴 Nyquist-Shannon 采样定理等信号处理理论，您将探索离散采样可能导致的混叠（aliasing）等失真问题，并学习如何设计和应用抗混叠滤波器来确保数值结果的保真度，这对于从观测数据中搜寻精细特征至关重要。",
            "id": "3482622",
            "problem": "你的任务是设计并实现一个完整、可运行的程序，用于量化和减轻在对原初曲率功率谱进行采样时产生的离散化伪影。请完全在对数波数变量下进行工作，并将该问题视为在对数域上的一个信号处理练习。你的程序必须遵循以下数学上精确的规范。\n\n考虑由以下振荡拟设建模的原初共动曲率微扰功率谱\n$$\nP_{\\mathcal{R}}(k) \\;=\\; A_s \\left(\\frac{k}{k_\\star}\\right)^{n_s-1}\\,\\Big[1 + A_{\\mathrm{osc}}\\;\\sin\\big(\\omega\\,\\ln(k/k_\\star) + \\phi\\big)\\Big],\n$$\n其中，$A_s$ 是振幅，$n_s$ 是标量倾斜，$k_\\star$ 是枢轴尺度，$A_{\\mathrm{osc}}$ 是振荡振幅，$\\omega$ 是对数频率，$\\phi$ 是相位。在你计算中的所有角度都必须以弧度为单位。除了波数（你必须以逆百万秒差距为单位处理）之外，所有输入和输出都应视为无量纲的；然而，程序的输出将是无量纲的诊断指标。\n\n你的推理和实现必须基于以下基本原理和经过充分检验的事实：\n- 在慢滚暴胀中，无量纲原初曲率功率谱 $P_{\\mathcal{R}}(k)$ 近似为幂律形式，其中由特征引入的微小偏离可以被建模为 $\\ln k$ 中的振荡。\n- Nyquist–Shannon 采样定理指出，一个最大角频率为 $\\Omega_{\\max}$（单位为弧度/单位自变量）的带限信号，能够且仅当 $\\Omega_{\\max} \\le \\pi/\\Delta$ 时，才能从间距为 $\\Delta$ 的均匀采样中完全恢复。\n- 在均匀采样坐标系中的离散时间线性滤波，通常通过使用有限脉冲响应滤波器来实现，该滤波器近似理想的低通响应，以便在抽取操作之前减轻混叠效应。\n\n你必须完全在对数变量 $x = \\ln k$ 中工作，这样振荡因子就具有 $\\sin(\\omega x + \\phi)$ 的形式，其中角频率 $\\omega$ 的单位是弧度/单位$x$。令 $x_{\\min} = \\ln k_{\\min}$ 和 $x_{\\max} = \\ln k_{\\max}$。设精细参考网格以间距 $\\Delta x_{\\mathrm{ref}}$ 均匀采样，而粗糙网格则针对几个测试用例以间距 $\\Delta x$ 均匀采样。\n\n你的任务：\n1. 在区间 $[x_{\\min}, x_{\\max}]$ 上，以间距 $\\Delta x_{\\mathrm{ref}}$ 在精细均匀网格上定义参考谱。这将定义一个高保真的“基准”$P_{\\mathcal{R}}^{\\mathrm{ref}}(x)$，它在点 $x_i = x_{\\min} + i\\,\\Delta x_{\\mathrm{ref}}$（$i$为整数）上进行采样。\n2. 通过整数因子 $r = \\Delta x / \\Delta x_{\\mathrm{ref}}$ 进行均匀抽取来模拟粗糙采样。为评估离散化效应，在一个精细网格子集上构建两种重构：\n   - 一种原始的“抽取-插值”重构 $P_{\\mathcal{R}}^{\\mathrm{raw}}(x)$：通过从精细参考中每隔 $r$ 个点取一个样本，然后执行分段线性插值，将其重构回定义域的一个精细子集上，以便进行逐点比较。\n   - 一种抗混叠重构 $P_{\\mathcal{R}}^{\\mathrm{aa}}(x)$：首先应用一个通带受限于角截止频率 $\\Omega_c = \\pi/\\Delta x$（为确保可实现性而略微减小）的低通线性卷积滤波器，然后以因子 $r$ 进行抽取，最后线性插值回同一个精细子集上。\n3. 在两种情况下，都使用相对均方根误差来量化重构误差\n$$\n\\varepsilon = \\left(\\frac{\\sum_j\\big(P_{\\mathcal{R}}^{\\mathrm{rec}}(x_j) - P_{\\mathcal{R}}^{\\mathrm{ref}}(x_j)\\big)^2}{\\sum_j \\big(P_{\\mathcal{R}}^{\\mathrm{ref}}(x_j)\\big)^2}\\right)^{1/2},\n$$\n其中求和是在定义了重构的精细网格子集上进行的。\n4. 对每种粗糙采样，使用 $x$ 域中的 Nyquist–Shannon 条件来估计混叠。设粗糙网格的奈奎斯特角频率为 $\\Omega_N = \\pi/\\Delta x$。通过检查是否 $\\omega > \\Omega_N$ 来预测是否会发生混叠。此外，报告预期的混叠角频率\n$$\n\\omega_{\\mathrm{alias}} = \\frac{1}{\\Delta x}\\,\\min\\Big(\\big(\\omega\\,\\Delta x \\bmod 2\\pi\\big),\\;2\\pi - \\big(\\omega\\,\\Delta x \\bmod 2\\pi\\big)\\Big),\n$$\n该频率位于区间 $[0,\\Omega_N]$ 内，并且当 $\\omega \\le \\Omega_N$ 时与 $\\omega$ 一致。\n5. 通过在固定 $\\omega$ 时改变 $\\Delta x$ 来执行收敛性测试，并通过在固定 $\\Delta x$ 时改变 $\\omega$ 来执行可分辨性测试。通过比较使用和不使用预滤波的相对均方根误差，来展示抗混叠滤波的好处，并报告由下式定义的改进因子：\n$$\n\\mathcal{I} = \\frac{\\varepsilon_{\\mathrm{raw}}}{\\varepsilon_{\\mathrm{aa}}}.\n$$\n\n谱和网格的参数规范：\n- 使用 $A_s = 2.1\\times 10^{-9}$，$n_s = 0.965$，$k_\\star = 0.05$（单位为逆百万秒差距），$A_{\\mathrm{osc}} = 0.1$，以及 $\\phi = 0$。\n- 使用 $k_{\\min} = 10^{-4}$ 和 $k_{\\max} = 1$（单位为逆百万秒差距）。所有角度量均以弧度为单位。\n- 使用精细参考间距 $\\Delta x_{\\mathrm{ref}} = 0.001$。\n- 从粗糙到精细的重构使用线性插值。\n- 对于抗混叠滤波，使用一个以 Hamming 窗设计的 $x$ 域有限脉冲响应低通滤波器。相对于精细网格奈奎斯特频率的归一化截止频率必须是 $0.9/r$，滤波器长度必须为 $8r+1$ 阶。在抽取前以零相位形式应用滤波器。\n\n测试套件：\n为以下测试用例集实现上述任务，其中每个用例是一个对 $(\\omega, \\Delta x)$，$\\omega$ 的单位为弧度/单位x，$\\Delta x$ 的单位为x：\n- 用例 1 (理想情况，可分辨): $(\\omega, \\Delta x) = (30.0, 0.05)$。\n- 用例 2 (强混叠): $(\\omega, \\Delta x) = (80.0, 0.05)$。\n- 用例 3 (奈奎斯特边界): $(\\omega, \\Delta x) = \\left(\\pi/0.05,\\;0.05\\right)$。\n- 用例 4 (收敛采样): $(\\omega, \\Delta x) = (80.0, 0.01)$。\n\n对于每种情况，你的程序必须按顺序生成一个包含以下五个条目的列表：\n- 原始“抽取-插值”重构的相对均方根误差（无量纲浮点数）。\n- 基于 Nyquist–Shannon 条件的混叠布尔预测（如果 $\\omega > \\pi/\\Delta x$ 则为 True，否则为 False）。\n- 预测的混叠角频率 $\\omega_{\\mathrm{alias}}$，单位为弧度/单位x（浮点数）。\n- 抗混叠重构的相对均方根误差（无量纲浮点数）。\n- 改进因子 $\\mathcal{I}$（无量纲浮点数）。\n\n最终输出格式：\n你的程序必须生成一行输出，其中包含所有四个测试用例的结果，格式为一个由方括号括起来的、无空格的、逗号分隔的案例列表的列表。每个浮点数必须四舍五入到六位小数。例如，格式应为：\n$[ [a_{11},a_{12},a_{13},a_{14},a_{15}],[a_{21},a_{22},a_{23},a_{24},a_{25}],[a_{31},a_{32},a_{33},a_{34},a_{35}],[a_{41},a_{42},a_{43},a_{44},a_{45}] ]$\n但打印时不带空格。角度单位为弧度，误差和改进因子为无量纲。程序不得要求任何输入，必须能独立运行。\n\n注意：请确保最终打印列表中的所有浮点值都四舍五入到六位小数，并严格遵守指定的抗混叠预滤波器设计和重构程序，以保证可测试性和可复现性。",
            "solution": "该问题要求设计并实现一个数值程序，用于在对原初曲率功率谱进行采样时，分析并减轻离散化伪影。分析将在对数波数域中进行，并将其视为一个信号处理问题。任务的核心是比较一种朴素的“抽取-插值”方法和一种更复杂的抗混叠滤波方法，并使用特定指标来量化结果。\n\n解决方案的结构如下：\n首先，我们建立计算域并生成一个高分辨率的参考信号。其次，我们模拟两种不同的粗糙采样和重构方法。第三，我们为每种方法计算指定的误差指标和混叠诊断。最后，我们对指定的测试用例执行此过程。\n\n**1. 参考信号生成**\n\n原初功率谱由以下拟设给出：\n$$\nP_{\\mathcal{R}}(k) = A_s \\left(\\frac{k}{k_\\star}\\right)^{n_s-1}\\,\\Big[1 + A_{\\mathrm{osc}}\\;\\sin\\big(\\omega\\,\\ln(k/k_\\star) + \\phi\\big)\\Big]\n$$\n我们在对数波数变量 $x = \\ln k$ 中工作。谱作为 $x$ 的函数变为：\n$$\nP_{\\mathcal{R}}(x) = A_s \\exp((n_s-1)(x - x_\\star))\\,\\Big[1 + A_{\\mathrm{osc}}\\;\\sin\\big(\\omega\\,(x - x_\\star) + \\phi\\big)\\Big]\n$$\n其中 $x_\\star = \\ln k_\\star$。参数 $A_s = 2.1\\times 10^{-9}$，$n_s = 0.965$，$k_\\star = 0.05$，$A_{\\mathrm{osc}} = 0.1$ 和 $\\phi = 0$ 是给定的常数。\n\n在区间 $[x_{\\min}, x_{\\max}] = [\\ln(10^{-4}), \\ln(1)]$ 上构建一个精细、均匀的 $x$ 参考网格。网格间距为 $\\Delta x_{\\mathrm{ref}} = 0.001$。设此网格为 $\\{x_i\\}$，其中 $x_i = x_{\\min} + i\\,\\Delta x_{\\mathrm{ref}}$。通过在此精细网格上的每个点 $x_i$ 处计算函数 $P_{\\mathcal{R}}(x)$ 的值，来计算参考谱 $P_{\\mathcal{R}}^{\\mathrm{ref}}(x_i)$。这个离散信号作为我们的基准真相。\n\n**2. 粗糙采样与重构**\n\n对于给定的粗糙网格间距 $\\Delta x$，我们定义一个整数抽取因子 $r = \\Delta x / \\Delta x_{\\mathrm{ref}}$。粗糙网格 $\\{x_j^{\\mathrm{coarse}}\\}$ 是通过从精细网格中每隔 $r$ 个点取一个样本获得的。然后我们模拟两种重构方法。为了便于比较，所有重构都在一个公共的精细网格子集上执行，该子集跨越了由粗糙网格的第一个和最后一个点定义的区间。\n\n**a. 原始重构**\n\n原始粗糙信号 $P_{\\mathcal{R}}^{\\mathrm{coarse,raw}}$ 是通过简单地以因子 $r$ 抽取参考信号 $P_{\\mathcal{R}}^{\\mathrm{ref}}$ 得到的。然后，通过对粗糙样本 $(x_j^{\\mathrm{coarse}}, P_{\\mathcal{R}}^{\\mathrm{coarse,raw}}(x_j^{\\mathrm{coarse}}))$ 应用分段线性插值，在精细网格子集的点上评估谱，从而生成重构信号 $P_{\\mathcal{R}}^{\\mathrm{raw}}(x)$。\n\n**b. 抗混叠重构**\n\n这种方法首先在抽取前对高分辨率信号 $P_{\\mathcal{R}}^{\\mathrm{ref}}$ 进行预滤波，以减轻混叠。Nyquist-Shannon 定理指出，为了在以间距 $\\Delta x$ 采样时避免混叠，信号的角频率不得大于奈奎斯特频率 $\\Omega_N = \\pi/\\Delta x$。因此，我们对 $P_{\\mathcal{R}}^{\\mathrm{ref}}$ 应用一个截止频率等于或低于 $\\Omega_N$ 的低通滤波器。\n\n根据问题规范，我们使用 Hamming 窗设计一个长度为 $8r+1$ 的有限脉冲响应（FIR）滤波器。滤波器的截止频率被设定为略低于粗糙网格的奈奎斯特频率，以考虑滤波器的过渡带。相对于精细网格的奈奎斯特频率（$1 / (2\\Delta x_{\\mathrm{ref}})$）的归一化截止频率被指定为 $0.9/r$。这对应于角频率截止点 $\\Omega_c = \\frac{0.9}{r} \\frac{\\pi}{\\Delta x_{\\mathrm{ref}}} = \\frac{0.9\\pi}{\\Delta x}$。\n\n该滤波器以零相位配置应用，以避免引入相位失真。这通过对信号进行一次前向和一次后向滤波来实现。然后将得到的滤波信号以因子 $r$ 进行抽取，以产生抗混叠的粗糙信号 $P_{\\mathcal{R}}^{\\mathrm{coarse,aa}}$。最后，使用分段线性插值，在与原始情况相同的精细网格子集上重构抗混叠信号 $P_{\\mathcal{R}}^{\\mathrm{aa}}(x)$。\n\n**3. 分析与量化**\n\n对于每种重构，其准确性通过相对均方根误差（$\\varepsilon$）进行量化：\n$$\n\\varepsilon = \\left(\\frac{\\sum_j\\big(P_{\\mathcal{R}}^{\\mathrm{rec}}(x_j) - P_{\\mathcal{R}}^{\\mathrm{ref}}(x_j)\\big)^2}{\\sum_j \\big(P_{\\mathcal{R}}^{\\mathrm{ref}}(x_j)\\big)^2}\\right)^{1/2}\n$$\n其中求和是在精细网格比较子集中的点上进行的。我们分别计算原始重构和抗混叠重构的 $\\varepsilon_{\\mathrm{raw}}$ 和 $\\varepsilon_{\\mathrm{aa}}$。\n\n我们还执行混叠的诊断分析。根据 Nyquist-Shannon 准则，如果信号的最高角频率 $\\omega$ 超过粗糙网格的奈奎斯特频率 $\\Omega_N = \\pi/\\Delta x$，则会发生混叠。我们报告一个布尔值，指示是否 $\\omega > \\Omega_N$。\n\n当确实发生混叠时（$\\omega > \\Omega_N$），原始频率分量会“折叠”到主频率范围 $[0, \\Omega_N]$ 内的一个较低频率。预测的混叠角频率 $\\omega_{\\mathrm{alias}}$ 使用以下公式计算：\n$$\n\\omega_{\\mathrm{alias}} = \\frac{1}{\\Delta x}\\,\\min\\Big(\\big(\\omega\\,\\Delta x \\bmod 2\\pi\\big),\\;2\\pi - \\big(\\omega\\,\\Delta x \\bmod 2\\pi\\big)\\Big)\n$$\n最后，抗混叠滤波器的有效性通过改进因子 $\\mathcal{I} = \\varepsilon_{\\mathrm{raw}}/\\varepsilon_{\\mathrm{aa}}$ 来衡量。\n\n算法通过遍历测试套件中的每个 $(\\omega, \\Delta x)$ 对，执行上述所有步骤，并汇编五个指定的输出值：$\\varepsilon_{\\mathrm{raw}}$、混叠预测（布尔值）、$\\omega_{\\mathrm{alias}}$、$\\varepsilon_{\\mathrm{aa}}$ 和 $\\mathcal{I}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    # Parameter specification for the spectrum and grids\n    A_s = 2.1e-9\n    n_s = 0.965\n    k_star = 0.05\n    A_osc = 0.1\n    phi = 0.0\n    k_min = 1e-4\n    k_max = 1.0\n    dx_ref = 0.001\n\n    # Test suite\n    test_cases = [\n        (30.0, 0.05),\n        (80.0, 0.05),\n        (np.pi / 0.05, 0.05),\n        (80.0, 0.01)\n    ]\n\n    # --- Helper Functions ---\n\n    def P_R_log(x, omega, As, ns, kstar, Aosc, p):\n        \"\"\"\n        Calculates the power spectrum P_R as a function of logarithmic wavenumber x.\n        \"\"\"\n        k = np.exp(x)\n        x_star = np.log(kstar)\n        power_law_term = As * np.exp((ns - 1) * (x - x_star))\n        oscillation_term = 1 + Aosc * np.sin(omega * (x - x_star) + p)\n        return power_law_term * oscillation_term\n\n    def calculate_rr_mse(y_recon, y_ref):\n        \"\"\"\n        Calculates the relative root-mean-square error.\n        \"\"\"\n        numerator = np.sum((y_recon - y_ref)**2)\n        denominator = np.sum(y_ref**2)\n        if denominator == 0:\n            return 0.0\n        return np.sqrt(numerator / denominator)\n\n    def process_case(omega, dx):\n        \"\"\"\n        Processes a single test case (omega, dx) and returns the required metrics.\n        \"\"\"\n        # 1. Setup grids\n        x_min = np.log(k_min)\n        x_max = np.log(k_max)\n        x_fine = np.arange(x_min, x_max, dx_ref)\n        \n        r = int(round(dx / dx_ref))\n        if not np.isclose(r * dx_ref, dx):\n            raise ValueError(\"dx must be an integer multiple of dx_ref\")\n        \n        # 2. Generate reference spectrum\n        P_ref = P_R_log(x_fine, omega, A_s, n_s, k_star, A_osc, phi)\n        \n        # Define coarse grid and the subset of the fine grid for comparison\n        x_coarse = x_fine[::r]\n        # Make sure the subset for comparison does not go past the last coarse point\n        if x_fine[-1] > x_coarse[-1]:\n             end_index = np.where(x_fine >= x_coarse[-1])[0][0] + 1\n             subset_indices = np.arange(0, end_index)\n        else:\n             subset_indices = np.arange(len(x_fine))\n\n        x_fine_subset = x_fine[subset_indices]\n        P_ref_subset = P_ref[subset_indices]\n        \n        # 3. Raw reconstruction\n        P_coarse_raw = P_ref[::r]\n        if len(x_coarse) > len(P_coarse_raw):\n             x_coarse = x_coarse[:len(P_coarse_raw)]\n\n        P_raw_recon = np.interp(x_fine_subset, x_coarse, P_coarse_raw)\n        err_raw = calculate_rr_mse(P_raw_recon, P_ref_subset)\n        \n        # 4. Anti-aliased reconstruction\n        num_taps = 8 * r + 1\n        normalized_cutoff = 0.9 / r\n        fir_coeffs = signal.firwin(num_taps, cutoff=normalized_cutoff, window='hamming')\n\n        P_filtered = signal.filtfilt(fir_coeffs, 1.0, P_ref)\n        \n        P_coarse_aa = P_filtered[::r]\n        P_aa_recon = np.interp(x_fine_subset, x_coarse, P_coarse_aa)\n        err_aa = calculate_rr_mse(P_aa_recon, P_ref_subset)\n        \n        # 5. Aliasing analysis\n        Omega_N = np.pi / dx\n        alias_prediction = omega > Omega_N\n        \n        mod_val = (omega * dx) % (2 * np.pi)\n        w_alias = (1 / dx) * min(mod_val, 2 * np.pi - mod_val)\n        \n        # 6. Improvement factor\n        if err_aa > 1e-15: # Avoid division by a very small number\n            improvement = err_raw / err_aa\n        else:\n            improvement = np.inf if err_raw > 1e-15 else 1.0\n            \n        return [err_raw, alias_prediction, w_alias, err_aa, improvement]\n\n    # --- Main Execution Logic ---\n    all_results = []\n    for omega_case, dx_case in test_cases:\n        case_result = process_case(omega_case, dx_case)\n        all_results.append(case_result)\n\n    # Format the final output string as per the strict requirements\n    case_strings = []\n    for res in all_results:\n        # res = [err_raw, alias_pred, w_alias, err_aa, improvement]\n        str_res_list = [\n            f\"{res[0]:.6f}\",\n            str(res[1]),\n            f\"{res[2]:.6f}\",\n            f\"{res[3]:.6f}\",\n            f\"{res[4]:.6f}\"\n        ]\n        case_strings.append(f\"[{','.join(str_res_list)}]\")\n    \n    final_output_string = f\"[{','.join(case_strings)}]\"\n    # Python's default representation for True/False is \"True\" and \"False\".\n    # Problem spec: \"True\" or \"False\", not \"true\" or \"false\"\n    # Python `str(bool)` does this correctly.\n    # Problem spec: no spaces. Python `','.join(...)` does this correctly.\n    print(final_output_string.replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}