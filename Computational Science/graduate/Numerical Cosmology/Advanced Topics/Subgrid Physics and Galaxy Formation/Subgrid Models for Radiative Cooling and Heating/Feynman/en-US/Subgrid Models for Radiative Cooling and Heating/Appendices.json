{
    "hands_on_practices": [
        {
            "introduction": "To build robust subgrid models, we must first understand the fundamental physics they represent. This first practice exercise explores the core concept of thermal equilibrium in the diffuse Intergalactic Medium (IGM). You will derive and solve the balance equation between photoheating from the cosmic UV background and radiative cooling, discovering a key property of the resulting temperature-density relation .",
            "id": "3491059",
            "problem": "Consider an optically thin, spatially uniform parcel of the low-density Intergalactic Medium (IGM) under Photoionization Equilibrium (PIE). Let the total hydrogen number density be $n$ (in $\\mathrm{cm}^{-3}$), the neutral hydrogen number density be $n_\\mathrm{HI}$ (in $\\mathrm{cm}^{-3}$), the electron number density be $n_e$ (in $\\mathrm{cm}^{-3}$), the proton number density be $n_p$ (in $\\mathrm{cm}^{-3}$), and the metallicity be $Z$ (expressed as a fraction of the solar metallicity). Assume pure hydrogen for ionization balance and a simple subgrid cooling parameterization that includes a primordial term and a metal-line term.\n\nFundamental energy balance requires that the volumetric cooling equals the volumetric heating. Beginning from first principles, set the radiative cooling per unit volume equal to the photoheating per unit volume. Assume hydrogen is the only ionized species for ionization balance, with electrons provided by hydrogen ionization, and that the gas is optically thin so that each ionization deposits an average excess energy. The target of this problem is to compute the equilibrium temperature $T_\\mathrm{eq}$ (in $\\mathrm{K}$) satisfying energy balance and to discuss its dependence on $n$ under PIE.\n\nStart from the following base:\n- Radiative cooling per unit volume is $n_e n_\\mathrm{H} \\Lambda(T,Z)$, where $n_\\mathrm{H}$ is the total hydrogen number density and $\\Lambda(T,Z)$ (in $\\mathrm{erg}\\,\\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}$) is the cooling function.\n- Photoheating per unit volume is $n_\\mathrm{HI} \\Gamma \\langle E \\rangle$, where $\\Gamma$ (in $\\mathrm{s}^{-1}$) is the hydrogen photoionization rate and $\\langle E \\rangle$ (in $\\mathrm{erg}$) is the mean excess energy deposited per photoionization.\n- Photoionization equilibrium (PIE) gives $\\Gamma n_\\mathrm{HI} = \\alpha_\\mathrm{A}(T)\\, n_e n_p$, where $\\alpha_\\mathrm{A}(T)$ is the Case A recombination coefficient (in $\\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}$).\n\nUsing these bases, derive a self-consistent scalar equation for $T_\\mathrm{eq}$, and implement it numerically. For the purposes of this problem, adopt the following scientifically plausible and widely used parameterizations:\n- The Case A recombination coefficient for hydrogen:\n$$\n\\alpha_\\mathrm{A}(T) = 4.2\\times10^{-13}\\left(\\frac{T}{10^{4}\\,\\mathrm{K}}\\right)^{-0.7}\\ \\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}.\n$$\n- A subgrid cooling function composed of a primordial hydrogen term and a metal-line term:\n$$\n\\Lambda(T,Z) = \\Lambda_{0}\\left(\\frac{T}{10^{4}\\,\\mathrm{K}}\\right)^{a} + Z\\, \\Lambda_{Z,0}\\left(\\frac{T}{10^{4}\\,\\mathrm{K}}\\right)^{b},\n$$\nwith constants $\\Lambda_{0} = 1.2\\times10^{-24}\\ \\mathrm{erg}\\,\\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}$, $a = 0.3$, $\\Lambda_{Z,0} = 3.0\\times10^{-24}\\ \\mathrm{erg}\\,\\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}$, and $b = -0.2$. Here $Z$ is a dimensionless metallicity relative to solar (e.g., $Z=0.1$ means one tenth solar).\n\nAssume $n_e \\approx n_p \\approx n_\\mathrm{H}$ for the low-density, highly ionized IGM. Derive the equilibrium condition and solve for $T_\\mathrm{eq}$ numerically.\n\nYour program must:\n- Convert the photoheating excess energy $\\langle E \\rangle$ from electron-volts to $\\mathrm{erg}$ using $1\\,\\mathrm{eV} = 1.602176634\\times10^{-12}\\,\\mathrm{erg}$.\n- Solve for $T_\\mathrm{eq}$ (in $\\mathrm{K}$) by finding the root of a scalar function of $T$ derived from the energy balance and PIE, on the interval $[3000\\,\\mathrm{K},\\,30000\\,\\mathrm{K}]$. If a test case requires a wider bracket to find a root, you may expand the upper bound up to $100000\\,\\mathrm{K}$.\n- Express each computed equilibrium temperature in $\\mathrm{K}$ as a float.\n\nDiscuss within your solution the dependence of $T_\\mathrm{eq}$ on $n$ implied by the derivation under PIE.\n\nTest Suite:\nUse the following parameter sets for $(n, Z, \\Gamma, \\langle E \\rangle)$, with $n$ in $\\mathrm{cm}^{-3}$, $Z$ dimensionless (relative to solar), $\\Gamma$ in $\\mathrm{s}^{-1}$, and $\\langle E \\rangle$ in $\\mathrm{eV}$.\n1. $(10^{-5},\\ 0.0,\\ 10^{-12},\\ 2.0)$\n2. $(10^{-4},\\ 0.0,\\ 10^{-12},\\ 2.0)$\n3. $(10^{-5},\\ 0.1,\\ 10^{-12},\\ 2.0)$\n4. $(10^{-5},\\ 0.0,\\ 10^{-12},\\ 4.0)$\n5. $(10^{-7},\\ 0.0,\\ 10^{-13},\\ 2.0)$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[T_1,T_2,T_3,T_4,T_5]$), where each $T_i$ is the equilibrium temperature in $\\mathrm{K}$ for the $i$-th test case.",
            "solution": "The problem requires the derivation and numerical solution of the equilibrium temperature, $T_\\mathrm{eq}$, for a parcel of the Intergalactic Medium (IGM) under photoionization equilibrium (PIE). The solution must be derived from first principles as outlined in the problem statement.\n\nThe fundamental principle governing the thermal state of the gas is energy balance. In equilibrium, the total volumetric heating rate, $\\mathcal{H}$ (in units of $\\mathrm{erg}\\,\\mathrm{s}^{-1}\\,\\mathrm{cm}^{-3}$), must equal the total volumetric cooling rate, $\\mathcal{C}$ (in the same units).\n$$\n\\mathcal{H} = \\mathcal{C}\n$$\nThe problem provides expressions for these rates. The photoheating rate per unit volume is given by:\n$$\n\\mathcal{H} = n_\\mathrm{HI} \\Gamma \\langle E \\rangle\n$$\nwhere $n_\\mathrm{HI}$ is the number density of neutral hydrogen, $\\Gamma$ is the photoionization rate, and $\\langle E \\rangle$ is the mean excess energy deposited into the gas per photoionization.\n\nThe radiative cooling rate per unit volume is given by:\n$$\n\\mathcal{C} = n_e n_\\mathrm{H} \\Lambda(T,Z)\n$$\nwhere $n_e$ is the electron number density, $n_\\mathrm{H}$ is the total hydrogen number density (which we will denote as $n$), and $\\Lambda(T,Z)$ is the temperature- and metallicity-dependent cooling function.\n\nSetting the heating and cooling rates equal yields the thermal balance equation:\n$$\nn_\\mathrm{HI} \\Gamma \\langle E \\rangle = n_e n \\Lambda(T_\\mathrm{eq}, Z)\n$$\nThis equation contains multiple density terms ($n_\\mathrm{HI}$, $n_e$, $n$). To simplify it, we must invoke the second condition provided: photoionization equilibrium (PIE). PIE dictates that the rate of photoionizations equals the rate of recombinations. For a pure hydrogen gas, this is expressed as:\n$$\n\\Gamma n_\\mathrm{HI} = \\alpha_\\mathrm{A}(T) n_e n_p\n$$\nwhere $\\alpha_\\mathrm{A}(T)$ is the Case A recombination coefficient and $n_p$ is the proton number density.\n\nWe can now substitute the expression for $\\Gamma n_\\mathrm{HI}$ from the PIE equation into the thermal balance equation. This is a critical step that links the ionization state to the thermal state.\n$$\n\\left( \\alpha_\\mathrm{A}(T_\\mathrm{eq}) n_e n_p \\right) \\langle E \\rangle = n_e n \\Lambda(T_\\mathrm{eq}, Z)\n$$\nThe problem states that for the low-density, highly ionized IGM, we can make the approximation that the gas is almost fully ionized. This implies that the electron and proton densities are approximately equal to the total hydrogen density:\n$$\nn_e \\approx n_p \\approx n_\\mathrm{H} = n\n$$\nSubstituting these approximations into the equation gives:\n$$\n\\alpha_\\mathrm{A}(T_\\mathrm{eq}) (n) (n) \\langle E \\rangle = (n) (n) \\Lambda(T_\\mathrm{eq}, Z)\n$$\nThis simplifies to:\n$$\nn^2 \\alpha_\\mathrm{A}(T_\\mathrm{eq}) \\langle E \\rangle = n^2 \\Lambda(T_\\mathrm{eq}, Z)\n$$\nA crucial result emerges from this derivation. The factor of $n^2$ appears on both sides of the equation and can be canceled out, provided $n \\neq 0$.\n$$\n\\alpha_\\mathrm{A}(T_\\mathrm{eq}) \\langle E \\rangle = \\Lambda(T_\\mathrm{eq}, Z)\n$$\nThis final equation defines the equilibrium temperature $T_\\mathrm{eq}$. It is a scalar equation in a single variable, $T_\\mathrm{eq}$.\n\nAn important physical insight arises from this result: **under the specified conditions of PIE in an optically thin medium, the equilibrium temperature $T_\\mathrm{eq}$ is independent of the gas density $n$**. This occurs because both the dominant heating mechanism (photoheating) and the dominant cooling mechanism (which includes collisional excitation and recombination cooling, both two-body processes) scale with the square of the density ($n^2$), as their rates depend on the product of the densities of the interacting particles (e.g., $n_e n_p$). When balancing these two rates, the density dependence cancels out. The equilibrium temperature is thus determined solely by the balance between the energy input per recombination event (related to $\\langle E \\rangle$, the energy from the ionizing radiation field) and the energy radiated per unit of a \"cooling coefficient\" that also depends on recombinations and collisions, encapsulated in $\\Lambda(T,Z)/\\alpha_A(T)$.\n\nTo solve for $T_\\mathrm{eq}$ numerically, we define a function $f(T)$ whose root is the equilibrium temperature.\n$$\nf(T) = \\Lambda(T, Z) - \\alpha_\\mathrm{A}(T) \\langle E \\rangle = 0\n$$\nWe must substitute the given parameterizations for $\\Lambda(T, Z)$ and $\\alpha_\\mathrm{A}(T)$:\n$$\n\\Lambda(T,Z) = \\Lambda_{0}\\left(\\frac{T}{10^{4}\\,\\mathrm{K}}\\right)^{a} + Z\\, \\Lambda_{Z,0}\\left(\\frac{T}{10^{4}\\,\\mathrm{K}}\\right)^{b}\n$$\n$$\n\\alpha_\\mathrm{A}(T) = 4.2\\times10^{-13}\\left(\\frac{T}{10^{4}\\,\\mathrm{K}}\\right)^{-0.7}\\ \\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}\n$$\nThe constants are given as $\\Lambda_{0} = 1.2\\times10^{-24}\\ \\mathrm{erg}\\,\\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}$, $a = 0.3$, $\\Lambda_{Z,0} = 3.0\\times10^{-24}\\ \\mathrm{erg}\\,\\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}$, and $b = -0.2$. Let's denote $T_0 = 10^4\\,\\mathrm{K}$ and $\\alpha_{A,0} = 4.2\\times10^{-13}\\,\\mathrm{cm}^{3}\\,\\mathrm{s}^{-1}$. The equation for the root-finding algorithm becomes:\n$$\nf(T) = \\left[ \\Lambda_{0} \\left(\\frac{T}{T_0}\\right)^{a} + Z \\Lambda_{Z,0} \\left(\\frac{T}{T_0}\\right)^{b} \\right] - \\left[ \\alpha_{A,0} \\left(\\frac{T}{T_0}\\right)^{-0.7} \\right] \\langle E \\rangle_{\\mathrm{erg}} = 0\n$$\nThe energy $\\langle E \\rangle$ is given in electron-volts ($\\mathrm{eV}$) and must be converted to ergs using the provided conversion factor $1\\,\\mathrm{eV} = 1.602176634\\times10^{-12}\\,\\mathrm{erg}$.\n\nFor each test case, the values of $Z$ and $\\langle E \\rangle$ are inserted into this equation, which is then solved numerically for $T = T_\\mathrm{eq}$ within the specified temperature interval $[3000\\,\\mathrm{K}, 30000\\,\\mathrm{K}]$. The parameters $n$ and $\\Gamma$ from the test suite, while essential for defining the physical scenario, do not enter the final algebraic equation for $T_\\mathrm{eq}$, reinforcing the conclusion that the equilibrium temperature is independent of density and the ionization rate under these assumptions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Solves for the equilibrium temperature of an IGM parcel for multiple test cases.\n    \"\"\"\n    \n    # Define physical and numerical constants from the problem statement.\n    Lambda_0 = 1.2e-24  # erg cm^3 s^-1\n    a = 0.3             # dimensionless power-law index\n    Lambda_Z0 = 3.0e-24 # erg cm^3 s^-1\n    b = -0.2            # dimensionless power-law index\n    alpha_A0 = 4.2e-13  # cm^3 s^-1\n    alpha_power = -0.7  # dimensionless power-law index for recombination\n    T0 = 1.0e4          # K, reference temperature\n    eV_to_erg = 1.602176634e-12 # erg/eV\n\n    # Define the search interval for the root finder.\n    T_min = 3000.0  # K\n    T_max = 30000.0 # K\n    \n    # Test cases parameters: (n_H [cm^-3], Z [solar], Gamma [s^-1], E_mean [eV])\n    # Note: n_H and Gamma are not used in the final equation for T_eq,\n    # as they cancel out under the assumption of photoionization equilibrium.\n    test_cases = [\n        (1e-5, 0.0, 1e-12, 2.0),\n        (1e-4, 0.0, 1e-12, 2.0),\n        (1e-5, 0.1, 1e-12, 2.0),\n        (1e-5, 0.0, 1e-12, 4.0),\n        (1e-7, 0.0, 1e-13, 2.0),\n    ]\n\n    def equilibrium_function(T, Z, E_erg):\n        \"\"\"\n        The scalar function f(T) = Lambda(T, Z) - alpha_A(T) * E whose root is T_eq.\n        \n        Args:\n            T (float): Temperature in Kelvin.\n            Z (float): Metallicity relative to solar.\n            E_erg (float): Mean excess energy per photoionization in ergs.\n            \n        Returns:\n            float: Value of the function f(T).\n        \"\"\"\n        T_norm = T / T0\n        \n        # Cooling function Lambda(T, Z)\n        lambda_val = Lambda_0 * (T_norm**a) + Z * Lambda_Z0 * (T_norm**b)\n        \n        # Recombination coefficient alpha_A(T)\n        alpha_val = alpha_A0 * (T_norm**alpha_power)\n        \n        heating_term = alpha_val * E_erg\n        \n        return lambda_val - heating_term\n\n    results = []\n    for case in test_cases:\n        _, Z, _, E_eV = case\n        \n        # Convert mean energy from eV to ergs for consistency.\n        E_erg = E_eV * eV_to_erg\n        \n        # Arguments to pass to the equilibrium function (Z and E_erg).\n        args = (Z, E_erg)\n\n        try:\n            # Use the Brent's method root finder on the interval [T_min, T_max].\n            # The problem allows extending T_max up to 100000 K if needed,\n            # but the standard interval works for these cases.\n            T_eq = optimize.brentq(equilibrium_function, T_min, T_max, args=args)\n            results.append(T_eq)\n        except ValueError:\n            # Handle cases where the root is not bracketed in the initial range.\n            # Try the extended range as per the problem description.\n            try:\n                T_eq = optimize.brentq(equilibrium_function, T_min, 100000.0, args=args)\n                results.append(T_eq)\n            except ValueError:\n                # If still failing, append a marker for an unresolved case.\n                results.append(np.nan)\n\n    # Format the results into the required string format.\n    # The map(str, ...) is used to handle floating point numbers correctly.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "In practice, complex physical functions like the radiative cooling rate $\\Lambda(T,Z)$ are too computationally expensive to calculate from first principles at every step. Instead, simulations rely on pre-computed tables and interpolation. This exercise delves into the crucial numerical task of choosing an appropriate interpolation scheme to maintain accuracy, comparing a standard bilinear method with a log-linear approach that is often better suited for functions spanning many orders of magnitude .",
            "id": "3491056",
            "problem": "Consider a two-dimensional tabulated cooling function relevant to subgrid models for radiative cooling and heating in numerical cosmology. Let $T$ denote temperature in Kelvin and $Z$ denote a dimensionless metallicity (relative to solar metallicity). Define the base-$10$ logarithmic coordinates $u = \\log_{10} T$ and $v = \\log_{10} Z$. You are given a smooth analytic test function for the radiative cooling coefficient, $\\Lambda(T,Z)$, constructed to be strictly positive and to exhibit structured variation across the domain:\n$$\n\\Lambda(T,Z) = 10^{-27}\\,T^{1/2} \\;+\\; 2\\times 10^{-23}\\, Z \\,\\exp\\!\\left(-\\frac{(\\log_{10} T - 5.5)^2}{0.4^2}\\right) \\;+\\; 10^{-24}\\, Z^{1/2}\\,\\exp\\!\\left(-\\frac{(\\log_{10} T - 6.7)^2}{0.6^2}\\right).\n$$\nThe computational domain is specified by $T \\in [10^4, 10^8]$ (in Kelvin) and $Z \\in [10^{-3}, 2]$ (dimensionless). Consequently, $u \\in [4, 8]$ and $v \\in [\\log_{10}(10^{-3}), \\log_{10}(2)] = [-3, \\log_{10} 2]$.\n\nYou must compare two interpolation schemes defined on a rectilinear grid in the $(u,v)$-plane:\n\n- Scheme A (bilinear in $(u,v)$ on $\\Lambda$): Given a grid of nodes $(u_i, v_j)$, compute $\\Lambda_{ij} = \\Lambda(10^{u_i}, 10^{v_j})$ and use standard bilinear interpolation in $(u,v)$ directly on $\\Lambda$ to approximate $\\Lambda$ at query points $(u^*, v^*)$.\n- Scheme B (log-linear in $(u,v)$ on $\\log_{10}\\Lambda$): Using the same grid of nodes $(u_i, v_j)$, compute $L_{ij} = \\log_{10}\\Lambda(10^{u_i}, 10^{v_j})$ and use standard bilinear interpolation in $(u,v)$ on $L$ to approximate $L(u^*, v^*)$. The approximation to $\\Lambda$ at $(u^*, v^*)$ is then $\\hat{\\Lambda}(u^*, v^*) = 10^{\\,\\widehat{L}(u^*, v^*)}$.\n\nFor each scheme, define the relative error at a query point $(u^*, v^*)$ by\n$$\n\\varepsilon(u^*, v^*) \\;=\\; \\frac{\\left|\\hat{\\Lambda}(u^*, v^*) \\;-\\; \\Lambda\\big(10^{u^*}, 10^{v^*}\\big)\\right|}{\\Lambda\\big(10^{u^*}, 10^{v^*}\\big)}.\n$$\nThe objective is to compute the maximum relative error over a specified dense query mesh $\\mathcal{Q}$, uniformly covering $[4,8]\\times[-3,\\log_{10}2]$ in $(u,v)$, with $256$ evenly spaced points in $u$ and $256$ evenly spaced points in $v$.\n\nFundamental base you must use:\n- The definition of base-$10$ logarithms $u = \\log_{10} T$ and $v = \\log_{10} Z$.\n- The definition of bilinear interpolation on a rectangular grid.\n- The definition of relative error as a dimensionless ratio.\n- The function $\\Lambda(T,Z)$ provided above and the domain constraints.\n\nYour task is to implement a program that, for each specified grid resolution, constructs a uniform grid in $(u,v)$, populates it with exact values from $\\Lambda$, performs Scheme A and Scheme B interpolation over the dense query mesh, and reports the maximum relative error for each scheme.\n\nTest suite:\n- Case $1$: $(N_T, N_Z) = (16, 16)$, where $N_T$ and $N_Z$ denote the number of grid nodes along $u$ and $v$, respectively.\n- Case $2$: $(N_T, N_Z) = (8, 8)$.\n- Case $3$: $(N_T, N_Z) = (64, 8)$.\n- Case $4$: $(N_T, N_Z) = (32, 64)$.\n\nFor each case, the grid nodes $(u_i)$ are uniformly spaced over $[4,8]$ with $N_T$ points, and $(v_j)$ are uniformly spaced over $[-3, \\log_{10} 2]$ with $N_Z$ points. The query mesh $\\mathcal{Q}$ is fixed to $256 \\times 256$ points uniformly spanning the same $(u,v)$ domain.\n\nOutput specification:\n- The final output must be dimensionless maximum relative errors for each case and each scheme, aggregated into a single line in the form of a list of lists: for each case, the pair $[\\varepsilon_{\\max}^{\\text{A}}, \\varepsilon_{\\max}^{\\text{B}}]$, where $\\varepsilon_{\\max}^{\\text{A}}$ and $\\varepsilon_{\\max}^{\\text{B}}$ are the maximum relative errors for Scheme A and Scheme B, respectively, computed over $\\mathcal{Q}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example: $[[e_{11},e_{12}],[e_{21},e_{22}],\\dots]$, where each $e_{ij}$ is a floating-point number.\n\nAll reported quantities are dimensionless; no physical units must appear in the output. Angles are not involved. Percentages must not be used; report ratios as decimal numbers. Your program must be fully self-contained, take no input, and print only the single required line.",
            "solution": "The objective is to compare a bilinear interpolation scheme and a log-linear interpolation scheme for a given two-dimensional cosmological cooling function, $\\Lambda(T,Z)$, where $T$ is temperature and $Z$ is metallicity. The comparison is based on the maximum relative error of each scheme over a dense query mesh. The interpolation is performed in a logarithmic coordinate system $(u, v)$, where $u = \\log_{10} T$ and $v = \\log_{10} Z$.\n\nThe cooling function is given by:\n$$\n\\Lambda(T,Z) = 10^{-27}\\,T^{1/2} \\;+\\; 2\\times 10^{-23}\\, Z \\,\\exp\\!\\left(-\\frac{(\\log_{10} T - 5.5)^2}{0.4^2}\\right) \\;+\\; 10^{-24}\\, Z^{1/2}\\,\\exp\\!\\left(-\\frac{(\\log_{10} T - 6.7)^2}{0.6^2}\\right)\n$$\nFor computational purposes, we express this function in terms of the logarithmic coordinates $u$ and $v$ by substituting $T = 10^u$ and $Z = 10^v$:\n$$\n\\Lambda(10^u, 10^v) = 10^{-27} \\cdot 10^{0.5u} + 2 \\times 10^{-23} \\cdot 10^v \\cdot \\exp\\left(-\\frac{(u - 5.5)^2}{0.16}\\right) + 10^{-24} \\cdot 10^{0.5v} \\cdot \\exp\\left(-\\frac{(u - 6.7)^2}{0.36}\\right)\n$$\nThis function is evaluated over the domain $u \\in [4, 8]$ and $v \\in [-3, \\log_{10} 2]$.\n\nThe numerical procedure for each test case, specified by a grid resolution $(N_T, N_Z)$, is as follows:\n\nFirst, we define the computational grids:\n1.  A tabulation grid, on which the function is sampled to build the interpolator. The grid points are uniformly spaced arrays $u_i$ of size $N_T$ over $[4, 8]$ and $v_j$ of size $N_Z$ over $[-3, \\log_{10} 2]$.\n2.  A dense query mesh $\\mathcal{Q}$, fixed at a resolution of $256 \\times 256$ points, uniformly covering the same $(u,v)$ domain. This mesh is used to evaluate the accuracy of the interpolation.\n\nNext, we compute the exact values of the cooling function, $\\Lambda_{\\text{true}} = \\Lambda(10^u, 10^v)$, on every point of the $256 \\times 256$ query mesh. These values serve as the ground truth for calculating the relative error.\n\nFor each interpolation scheme, we then perform the following steps:\n\n**Scheme A: Bilinear Interpolation on $\\Lambda$**\n1.  The cooling function $\\Lambda(u, v)$ is evaluated at each node $(u_i,v_j)$ of the $(N_T, N_Z)$ tabulation grid, creating a data table $\\Lambda_{ij}$.\n2.  A bivariate linear interpolator, $\\hat{\\Lambda}_A(u, v)$, is constructed from the grid points $(u_i, v_j)$ and the corresponding values $\\Lambda_{ij}$. This is a standard bilinear interpolation.\n3.  The interpolator $\\hat{\\Lambda}_A(u, v)$ is evaluated at every point on the dense query mesh to obtain the interpolated values, $\\hat{\\Lambda}_A^{\\text{query}}$.\n4.  The relative error $\\varepsilon_A$ is computed at each point of the query mesh using the formula $\\varepsilon = |\\hat{\\Lambda} - \\Lambda_{\\text{true}}| / \\Lambda_{\\text{true}}$.\n5.  The maximum value of this error over the entire query mesh, $\\varepsilon_{\\max}^{\\text{A}}$, is recorded.\n\n**Scheme B: Log-Linear Interpolation (Bilinear on $\\log_{10}\\Lambda$)**\n1.  The base-$10$ logarithm of the cooling function, $L(u, v) = \\log_{10}(\\Lambda(u, v))$, is evaluated at each node $(u_i,v_j)$ of the tabulation grid, creating a data table $L_{ij}$. The function $\\Lambda$ is strictly positive over its domain, so its logarithm is always well-defined.\n2.  A bivariate linear interpolator, $\\hat{L}(u, v)$, is constructed from the grid points $(u_i, v_j)$ and the corresponding logarithmic values $L_{ij}$.\n3.  The interpolator $\\hat{L}(u, v)$ is evaluated at every point on the dense query mesh to obtain the interpolated logarithmic values, $\\hat{L}^{\\text{query}}$.\n4.  The interpolated cooling function values are recovered by the inverse-logarithm transformation: $\\hat{\\Lambda}_B^{\\text{query}} = 10^{\\hat{L}^{\\text{query}}}$.\n5.  The relative error $\\varepsilon_B$ is computed similarly: $\\varepsilon_B = |\\hat{\\Lambda}_B^{\\text{query}} - \\Lambda_{\\text{true}}| / \\Lambda_{\\text{true}}$.\n6.  The maximum value of this error over the query mesh, $\\varepsilon_{\\max}^{\\text{B}}$, is recorded.\n\nThis process is repeated for each of the four specified $(N_T, N_Z)$ test cases. The final result is an aggregation of the pairs $[\\varepsilon_{\\max}^{\\text{A}}, \\varepsilon_{\\max}^{\\text{B}}]$ for each case. The implementation utilizes `numpy` for array-based computations and `scipy.interpolate.RegularGridInterpolator` to perform the bilinear interpolations efficiently.",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Computes and compares the maximum relative errors for two interpolation schemes\n    on a cosmological cooling function.\n    \"\"\"\n\n    # Test suite: grid resolutions (N_T, N_Z)\n    test_cases = [\n        (16, 16),\n        (8, 8),\n        (64, 8),\n        (32, 64)\n    ]\n\n    # Define the computational domain in logarithmic coordinates (u, v)\n    u_min, u_max = 4.0, 8.0\n    v_min, v_max = -3.0, np.log10(2.0)\n\n    # Define the dense query mesh resolution\n    N_query = 256\n\n    def lambda_uv(u, v):\n        \"\"\"\n        Computes the cooling function Lambda in terms of log-coordinates u and v.\n        u = log10(T), v = log10(Z)\n        T = 10**u, Z = 10**v\n        \"\"\"\n        # Ensure input are numpy arrays for vectorization\n        u = np.asarray(u)\n        v = np.asarray(v)\n\n        # Term 1: Proportional to T^(1/2)\n        term1 = 1e-27 * 10**(0.5 * u)\n        \n        # Term 2: Gaussian peak in T at log10(T)=5.5, linear in Z\n        term2 = 2e-23 * 10**v * np.exp(-(u - 5.5)**2 / (0.4**2))\n        \n        # Term 3: Gaussian peak in T at log10(T)=6.7, proportional to Z^(1/2)\n        term3 = 1e-24 * 10**(0.5 * v) * np.exp(-(u - 6.7)**2 / (0.6**2))\n        \n        return term1 + term2 + term3\n\n    # Create the dense query mesh\n    u_query_pts = np.linspace(u_min, u_max, N_query)\n    v_query_pts = np.linspace(v_min, v_max, N_query)\n    U_query, V_query = np.meshgrid(u_query_pts, v_query_pts, indexing='ij')\n\n    # Calculate exact values of Lambda on the query mesh (ground truth)\n    lambda_true = lambda_uv(U_query, V_query)\n\n    # Prepare query points for the interpolator\n    query_points = np.stack((U_query.ravel(), V_query.ravel()), axis=-1)\n\n    all_results = []\n\n    for N_T, N_Z in test_cases:\n        # 1. Define the tabulation grid\n        u_grid = np.linspace(u_min, u_max, N_T)\n        v_grid = np.linspace(v_min, v_max, N_Z)\n\n        # 2. Scheme A: Bilinear interpolation on Lambda\n        U_grid, V_grid = np.meshgrid(u_grid, v_grid, indexing='ij')\n        lambda_table = lambda_uv(U_grid, V_grid)\n        \n        # Create and apply the interpolator for Scheme A\n        interpolator_A = RegularGridInterpolator((u_grid, v_grid), lambda_table, method='linear', bounds_error=False, fill_value=None)\n        lambda_hat_A = interpolator_A(query_points).reshape(N_query, N_query)\n        \n        # Calculate maximum relative error for Scheme A\n        error_A = np.abs(lambda_hat_A - lambda_true) / lambda_true\n        max_error_A = np.max(error_A)\n\n        # 3. Scheme B: Bilinear interpolation on log10(Lambda)\n        L_table = np.log10(lambda_table)\n        \n        # Create and apply the interpolator for Scheme B\n        interpolator_B = RegularGridInterpolator((u_grid, v_grid), L_table, method='linear', bounds_error=False, fill_value=None)\n        L_hat = interpolator_B(query_points).reshape(N_query, N_query)\n        \n        # Convert back from log-space\n        lambda_hat_B = 10**L_hat\n        \n        # Calculate maximum relative error for Scheme B\n        error_B = np.abs(lambda_hat_B - lambda_true) / lambda_true\n        max_error_B = np.max(error_B)\n\n        all_results.append([max_error_A, max_error_B])\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The internal energy and the ionization state of gas are deeply intertwined through the equation of state. This final practice is a theoretical exercise that highlights the importance of maintaining numerical self-consistency when updating these coupled quantities within a simulation. By analytically deriving the temperature error that arises from a naive update scheme, you will gain a critical appreciation for the subtle details that ensure a simulation code is both stable and accurate .",
            "id": "3491083",
            "problem": "Consider a single computational cell in a cosmological hydrodynamics simulation whose subgrid model advances radiative cooling, heating, and primordial hydrogen chemistry over an operator-split substep of duration $\\Delta t$. The gas is pure hydrogen with mass density $\\rho$, adiabatic index $\\gamma$, and obeys an ideal-gas equation of state (EOS). Let $m_p$ be the proton mass and $k_B$ the Boltzmann constant. The thermal state is represented by the specific internal energy $u$ (energy per unit mass), and the ionization state by the hydrogen ionized fraction $x$, defined as the ratio of ionized hydrogen number density to total hydrogen number density. The mean molecular weight in units of $m_p$ is $\\mu(x)$.\n\nAt the beginning of the substep $(t^n)$, the state is $(u^n, x^n)$. The subgrid model performs an operator-split explicit update in which:\n- The specific internal energy is advanced using a net specific heating/cooling rate $\\dot{u}^n$ evaluated at the beginning of the step, so that $u^{n+1} = u^n + \\Delta t\\, \\dot{u}^n$.\n- The ionized fraction is advanced by forward Euler using a photoionization rate $\\Gamma$ (per atom) and a case-B recombination coefficient $\\alpha_B$ (assumed constant over the step), with the hydrogen number density $n_H = \\rho/m_p$, according to\n$$\nx^{n+1} = x^n + \\Delta t\\left[ \\Gamma\\left(1 - x^n\\right) - \\alpha_B\\, n_H\\, \\left(x^n\\right)^2 \\right].\n$$\n\nAssume the ideal-gas EOS for internal energy relates $u$ and temperature $T$ by\n$$\nu = \\frac{k_B}{(\\gamma - 1)\\, \\mu\\, m_p}\\, T,\n$$\nwith $\\mu(x)$ for pure hydrogen given by\n$$\n\\mu(x) = \\frac{1}{1 + x}.\n$$\n\nAfter advancing $(u, x)$, consider two possible ways to obtain the temperature at $t^{n+1}$:\n- A naive conversion that uses the old mean molecular weight $\\mu^n \\equiv \\mu(x^n)$:\n$$\nT_{\\mathrm{naive}}^{n+1} = \\frac{(\\gamma - 1)\\, \\mu^n\\, m_p}{k_B}\\, u^{n+1}.\n$$\n- A consistent conversion that uses the updated mean molecular weight $\\mu^{n+1} \\equiv \\mu(x^{n+1})$:\n$$\nT_{\\mathrm{cons}}^{n+1} = \\frac{(\\gamma - 1)\\, \\mu^{n+1}\\, m_p}{k_B}\\, u^{n+1}.\n$$\n\nDefine the temperature error introduced by the naive procedure as $\\Delta T \\equiv T_{\\mathrm{naive}}^{n+1} - T_{\\mathrm{cons}}^{n+1}$. Starting from the fundamental definitions and laws given above, and without invoking any unintroduced shortcut formulas, derive an exact closed-form analytic expression for $\\Delta T$ after this single substep, expressed solely in terms of the symbols $\\rho$, $\\gamma$, $m_p$, $k_B$, $u^n$, $\\dot{u}^n$, $\\Delta t$, $x^n$, $\\Gamma$, and $\\alpha_B$. Express your final result as a single simplified algebraic expression. The quantity $\\Delta T$ is to be interpreted in Kelvin, but do not include units in the final boxed expression. No numerical evaluation is required.",
            "solution": "The objective is to derive an exact closed-form analytic expression for the temperature error, $\\Delta T \\equiv T_{\\mathrm{naive}}^{n+1} - T_{\\mathrm{cons}}^{n+1}$, after a single subgrid substep. The final expression must be in terms of the given fundamental quantities: $\\rho$, $\\gamma$, $m_p$, $k_B$, $u^n$, $\\dot{u}^n$, $\\Delta t$, $x^n$, $\\Gamma$, and $\\alpha_B$.\n\nWe begin with the definition of the temperature error, $\\Delta T$:\n$$\n\\Delta T = T_{\\mathrm{naive}}^{n+1} - T_{\\mathrm{cons}}^{n+1}\n$$\nThe problem provides the expressions for the naively and consistently calculated temperatures at time $t^{n+1}$:\n$$\nT_{\\mathrm{naive}}^{n+1} = \\frac{(\\gamma - 1)\\, \\mu^n\\, m_p}{k_B}\\, u^{n+1}\n$$\n$$\nT_{\\mathrm{cons}}^{n+1} = \\frac{(\\gamma - 1)\\, \\mu^{n+1}\\, m_p}{k_B}\\, u^{n+1}\n$$\nwhere $\\mu^n \\equiv \\mu(x^n)$ and $\\mu^{n+1} \\equiv \\mu(x^{n+1})$.\n\nSubstituting these expressions into the definition of $\\Delta T$ yields:\n$$\n\\Delta T = \\frac{(\\gamma - 1)\\, \\mu^n\\, m_p}{k_B}\\, u^{n+1} - \\frac{(\\gamma - 1)\\, \\mu^{n+1}\\, m_p}{k_B}\\, u^{n+1}\n$$\nWe can factor out the common terms to simplify this expression:\n$$\n\\Delta T = \\frac{(\\gamma - 1)\\, m_p}{k_B}\\, u^{n+1} \\left( \\mu^n - \\mu^{n+1} \\right)\n$$\nNext, we express the difference in mean molecular weight, $\\mu^n - \\mu^{n+1}$, using the provided definition, $\\mu(x) = \\frac{1}{1 + x}$:\n$$\n\\mu^n - \\mu^{n+1} = \\frac{1}{1 + x^n} - \\frac{1}{1 + x^{n+1}}\n$$\nPlacing the terms over a common denominator:\n$$\n\\mu^n - \\mu^{n+1} = \\frac{(1 + x^{n+1}) - (1 + x^n)}{(1 + x^n)(1 + x^{n+1})} = \\frac{x^{n+1} - x^n}{(1 + x^n)(1 + x^{n+1})}\n$$\nNow, we substitute this result back into our expression for $\\Delta T$:\n$$\n\\Delta T = \\frac{(\\gamma - 1)\\, m_p}{k_B}\\, u^{n+1} \\left( \\frac{x^{n+1} - x^n}{(1 + x^n)(1 + x^{n+1})} \\right)\n$$\nTo make this expression explicit in terms of quantities at time $t^n$, we must substitute the given update schemes. The specific internal energy $u$ is advanced as:\n$$\nu^{n+1} = u^n + \\Delta t\\, \\dot{u}^n\n$$\nThe ionized fraction $x$ is advanced as:\n$$\nx^{n+1} = x^n + \\Delta t\\left[ \\Gamma\\left(1 - x^n\\right) - \\alpha_B\\, n_H\\, \\left(x^n\\right)^2 \\right]\n$$\nFrom this, the change in the ionized fraction over the substep is:\n$$\nx^{n+1} - x^n = \\Delta t\\left[ \\Gamma\\left(1 - x^n\\right) - \\alpha_B\\, n_H\\, \\left(x^n\\right)^2 \\right]\n$$\nThe problem states that the total hydrogen number density is $n_H = \\rho/m_p$. Substituting this into the expressions for $x^{n+1}$ and $x^{n+1}-x^n$:\n$$\nx^{n+1} - x^n = \\Delta t\\left[ \\Gamma\\left(1 - x^n\\right) - \\alpha_B\\, \\frac{\\rho}{m_p}\\, \\left(x^n\\right)^2 \\right]\n$$\nAnd consequently,\n$$\nx^{n+1} = x^n + \\Delta t\\left[ \\Gamma\\left(1 - x^n\\right) - \\alpha_B\\, \\frac{\\rho}{m_p}\\, \\left(x^n\\right)^2 \\right]\n$$\nWe now have all the necessary components to write the final expression for $\\Delta T$. We substitute the expressions for $u^{n+1}$, $x^{n+1} - x^n$, and $x^{n+1}$ into our equation for $\\Delta T$:\n$$\n\\Delta T = \\frac{(\\gamma - 1)\\, m_p}{k_B} (u^n + \\Delta t\\, \\dot{u}^n) \\frac{\\Delta t\\left[ \\Gamma\\left(1 - x^n\\right) - \\alpha_B\\, \\frac{\\rho}{m_p}\\, \\left(x^n\\right)^2 \\right]}{(1 + x^n)\\left(1 + x^n + \\Delta t\\left[ \\Gamma\\left(1 - x^n\\right) - \\alpha_B\\, \\frac{\\rho}{m_p}\\, \\left(x^n\\right)^2 \\right]\\right)}\n$$\nThis expression is a single algebraic fraction and is exclusively in terms of the allowed symbols $\\rho$, $\\gamma$, $m_p$, $k_B$, $u^n$, $\\dot{u}^n$, $\\Delta t$, $x^n$, $\\Gamma$, and $\\alpha_B$. This is the final, exact, closed-form analytic expression for the temperature error.",
            "answer": "$$\n\\boxed{\\frac{(\\gamma - 1) m_p \\Delta t (u^n + \\Delta t \\dot{u}^n) \\left[ \\Gamma(1 - x^n) - \\alpha_B \\frac{\\rho}{m_p} (x^n)^2 \\right]}{k_B (1 + x^n) \\left( 1 + x^n + \\Delta t \\left[ \\Gamma(1 - x^n) - \\alpha_B \\frac{\\rho}{m_p} (x^n)^2 \\right] \\right)}}\n$$"
        }
    ]
}