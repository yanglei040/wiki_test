{
    "hands_on_practices": [
        {
            "introduction": "完整地演化一个标量场的动态运动方程，在计算上可能是非常苛刻的。本练习介绍了一个关键的简化方法——准静态近似，它使得数值宇宙学中的许多问题变得易于处理。通过一次“信封背面”式的标度分析，您将推导出该近似成立的物理条件，从而为何时应用它提供基础性理解。",
            "id": "3476463",
            "problem": "在包含例如 chameleon 和 Vainshtein 效应等屏蔽机制的修正引力的大尺度结构模拟中，次视界尺度上的标量场方程同时包含时间导数和空间导数。一种常见的数值策略是准静态近似，它忽略了标量微扰的二阶时间导数（相较于其空间拉普拉斯项）。为了从第一性原理评估此近似的有效性，考虑一个标量微扰 $\\delta \\phi(\\boldsymbol{x}, t)$ 在一个空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 背景上随时间演化，其标度因子为 $a(t)$，哈勃率为 $H(t) \\equiv \\dot{a}/a$。设小标量涨落的有效传播速度为一个正常数 $c_s$（不一定等于光速），并定义诊断量\n$$\n\\epsilon \\equiv \\frac{\\left| \\partial_t^2 \\delta \\phi \\right|}{\\left| c_s^2 \\nabla^2 \\delta \\phi \\right|}.\n$$\n假设以下具有物理动机且被广泛使用的数量级估计：\n- 微扰由波数为 $k$ 的单个共动傅里叶模式主导，因此在物理坐标中，拉普拉斯算子的标度关系为 $\\nabla^2 \\delta \\phi \\sim -\\left(k/a\\right)^2 \\delta \\phi$。\n- 在屏蔽区域内（在 chameleon 和 Vainshtein 两种机制下），场会绝热地追踪一个缓慢演化的极小值，使其长期时间变化在特征时标 $T \\sim H^{-1}$ 上跟随宇宙学背景，从而得到 $\\partial_t^2 \\delta \\phi \\sim \\delta \\phi / T^2$。\n- 在所研究的尺度和时间间隔内，有效传播速度 $c_s$ 被视为常数。\n\n仅从这些假设和上述定义出发，推导出一个用 $a$、$H$、$c_s$ 和 $k$ 表示的关于 $\\epsilon$ 的闭式解析表达式，并尽可能地进行简化。然后，用文字陈述在何种条件下准静态近似是有效的。将你关于 $\\epsilon$ 的最终答案表示为一个单一的符号化无量纲表达式，无需进行数值计算，也无需单位。",
            "solution": "问题要求推导诊断量 $\\epsilon$ 的表达式，并随后阐述在宇宙学标量场动力学中准静态近似的有效性条件。推导将从给定的定义和一组有物理动机的标度假设出发。\n\n诊断量 $\\epsilon$ 被定义为标量场运动方程中二阶时间导数项与空间拉普拉斯项的量值之比：\n$$\n\\epsilon \\equiv \\frac{\\left| \\partial_t^2 \\delta \\phi \\right|}{\\left| c_s^2 \\nabla^2 \\delta \\phi \\right|}\n$$\n此处，$\\delta \\phi(\\boldsymbol{x}, t)$ 是标量场微扰，$c_s$ 是其有效传播速度，$\\partial_t$ 代表对宇宙时间 $t$ 的偏导数，$\\nabla^2$ 是物理坐标中的拉普拉斯算子。\n\n我们被给予三个数量级估计来估算分子和分母。\n\n首先，我们来估算分子 $|\\partial_t^2 \\delta \\phi|$。问题陈述，场的时间变化在特征时标 $T \\sim H^{-1}$ 上跟随宇宙学背景，其中 $H(t)$ 是哈勃率。这导致二阶时间导数的标度关系为：\n$$\n\\partial_t^2 \\delta \\phi \\sim \\frac{\\delta \\phi}{T^2}\n$$\n将 $T \\sim H^{-1}$ 代入此关系式，得到：\n$$\n\\partial_t^2 \\delta \\phi \\sim \\frac{\\delta \\phi}{(H^{-1})^2} \\sim H^2 \\delta \\phi\n$$\n取其量值，并注意到 $H^2$ 是非负的，我们得到：\n$$\n\\left| \\partial_t^2 \\delta \\phi \\right| \\sim H^2 |\\delta \\phi|\n$$\n\n接下来，我们来估算分母 $|c_s^2 \\nabla^2 \\delta \\phi|$。问题提供了两个相关假设。首先，标量微扰由波数为 $k$ 的单个共动傅里叶模式主导。在物理坐标中，这对应于物理波数 $k_{\\text{phys}} = k/a(t)$，其中 $a(t)$ 是标度因子。拉普拉斯算子作用在此类模式上的标度关系为：\n$$\n\\nabla^2 \\delta \\phi \\sim -\\left(\\frac{k}{a}\\right)^2 \\delta \\phi\n$$\n第二个假设是传播速度 $c_s$ 是一个正常数。因此我们可以写出：\n$$\nc_s^2 \\nabla^2 \\delta \\phi \\sim -c_s^2 \\left(\\frac{k}{a}\\right)^2 \\delta \\phi\n$$\n取其量值，得到：\n$$\n\\left| c_s^2 \\nabla^2 \\delta \\phi \\right| \\sim \\left| -c_s^2 \\left(\\frac{k}{a}\\right)^2 \\delta \\phi \\right|\n$$\n由于 $c_s^2$、$k^2$ 和 $a^2$ 都是非负的，这可以简化为：\n$$\n\\left| c_s^2 \\nabla^2 \\delta \\phi \\right| \\sim c_s^2 \\left(\\frac{k}{a}\\right)^2 |\\delta \\phi|\n$$\n\n现在，我们可以将分子和分母的这些标度关系代回到 $\\epsilon$ 的定义中：\n$$\n\\epsilon \\sim \\frac{H^2 |\\delta \\phi|}{c_s^2 \\left(\\frac{k}{a}\\right)^2 |\\delta \\phi|}\n$$\n假设微扰是非平庸的（$\\delta \\phi \\neq 0$），$|\\delta \\phi|$ 因子可以被消去：\n$$\n\\epsilon \\sim \\frac{H^2}{c_s^2 \\frac{k^2}{a^2}}\n$$\n这个表达式可以通过重新整理各项来简化：\n$$\n\\epsilon \\sim \\frac{a^2 H^2}{c_s^2 k^2}\n$$\n这可以更紧凑地写成一个无量纲比值的平方：\n$$\n\\epsilon \\sim \\left(\\frac{aH}{c_s k}\\right)^2\n$$\n这就是题目所要求的，用给定物理量表示的 $\\epsilon$ 的闭式解析表达式。\n\n任务的第二部分是陈述准静态近似有效的条件。该近似在于忽略 $\\partial_t^2 \\delta \\phi$ 项（相对于 $c_s^2 \\nabla^2 \\delta \\phi$ 项）。这在数学上等价于它们的量值之比 $\\epsilon$ 远小于 1 的条件：\n$$\n\\epsilon \\ll 1\n$$\n代入我们推导出的 $\\epsilon$ 表达式，我们得到条件：\n$$\n\\left(\\frac{aH}{c_s k}\\right)^2 \\ll 1\n$$\n由于括号中的项是正量之比，这等价于：\n$$\n\\frac{aH}{c_s k} \\ll 1\n$$\n用文字表述，准静态近似的有效性条件是无量纲量 $(aH)/(c_s k)$ 必须远小于1。\n\n这个条件有清晰的物理诠释。量 $H^{-1}$ 是哈勃时间，代表宇宙膨胀的特征时标。量 $a/k$ 代表微扰模式的物理长度尺度（不计一个 $2\\pi$ 因子）。标量场传播过这个长度尺度所需的时间是 $\\tau_{\\text{prop}} \\sim (a/k)/c_s = a/(c_s k)$。条件 $aH/(c_s k) \\ll 1$ 可以改写为 $H \\ll c_s k/a$，或者 $H^{-1} \\gg a/(c_s k)$。这意味着宇宙膨胀时标（$H^{-1}$）必须远长于标量场微扰的动力学时标（$a/(c_s k)$）。当此条件成立时，标量场可以快速地调整以适应背景时空的缓慢、绝热的变化，从而证明了“准静态”描述的合理性。等价地，微扰的物理尺度 $\\sim a/k$ 必须远小于标量场的有效声视界 $c_s/H$。",
            "answer": "$$\\boxed{\\left(\\frac{aH}{c_s k}\\right)^{2}}$$"
        },
        {
            "introduction": "在建立了准静态近似的有效性之后，我们剩下的任务是求解一个非线性椭圆偏微分方程。本练习将指导您实现牛顿-高斯-赛德尔（Newton-Gauss-Seidel）弛豫法，这是一种处理此类方程的稳健数值技术。掌握这种方法对于在宇宙学背景下模拟诸如变色龙效应等筛选机制至关重要。",
            "id": "3476441",
            "problem": "考虑一个与修正引力模型（例如数值宇宙学中的变色龙机制）中的屏蔽机制相关的非线性椭圆标量场方程。在一个用各坐标方向上间距为 $\\Delta x$ 的均匀网格离散化的立方体域上，标量场 $\\phi$ 遵循以下形式的椭圆方程\n$$\n\\nabla^2 \\phi = S(\\phi, \\rho),\n$$\n其中非线性源项为\n$$\nS(\\phi, \\rho) = V_{,\\phi}(\\phi) + \\frac{\\beta \\rho}{M_{\\rm pl}},\n$$\n$V_{,\\phi}(\\phi)$ 是势 $V(\\phi)$ 对 $\\phi$ 的导数，$\\rho$ 是物质密度，$\\beta$ 是无量纲耦合常数，$M_{\\rm pl}$ 是普朗克质量（记为 $M_{\\rm pl}$）。为解决此问题，使用以下多项式势导数\n$$\nV_{,\\phi}(\\phi) = m^2 \\phi + \\lambda \\phi^3,\n$$\n其中参数 $m^2  0$ 且 $\\lambda \\ge 0$，并在域的所有边界点上施加齐次狄利克雷边界条件 $\\phi=0$。\n\n你的任务是：\n\n- 使用二阶中心有限差分，从第一性原理出发，推导网格内部椭圆方程的离散形式。在三维空间中使用标准的6点格式，并定义一个在解处等于零的局部残差方程 $F_{i,j,k}(\\phi)$。\n- 从局部残差方程的牛顿线性化出发，推导一个逐点的牛顿-高斯-赛德尔更新，该更新使用局部雅可比 $F'_{i,j,k}(\\phi)$ 来更新每个网格点上的场。更新应通过一个因子 $\\omega \\in (0,1]$ 进行阻尼以增强稳定性。\n- 实现一个求解器，该求解器执行字典序高斯-赛德尔扫描，在每个内部网格点上应用牛顿更新，直到满足停止准则。使用内部点上残差的最大范数 $\\|F\\|_{\\infty}$ 作为收敛度量，当 $\\|F\\|_{\\infty} \\le \\varepsilon$ 或达到指定的最大迭代次数后停止。\n\n所有量都应在无量纲代码单位中处理。程序必须根据离散化一致地定义残差及其导数，强制执行边界条件，并应用阻尼牛顿-高斯-赛德尔更新。\n\n测试套件规范：\n\n实现您的程序以运行以下三个测试用例，每个用例由一组参数元组 $(N, \\Delta x, m^2, \\lambda, \\beta, M_{\\rm pl}, \\rho\\text{configuration}, \\phi_{\\rm init}, \\phi_{\\rm b}, \\omega, \\varepsilon, N_{\\rm max})$ 定义，其中：\n- $N$ 是每个维度的网格点数（域为 $N \\times N \\times N$），\n- $\\Delta x$ 是网格间距，\n- $m^2$、$\\lambda$、$\\beta$、$M_{\\rm pl}$ 是 $S(\\phi,\\rho)$ 中的常数，\n- $\\rho\\text{configuration}$ 指定如何在网格上初始化 $\\rho$，\n- $\\phi_{\\rm init}$ 是 $\\phi$ 的内部均匀初始值，\n- $\\phi_{\\rm b}$ 是 $\\phi$ 的边界值（狄利克雷），\n- $\\omega$ 是阻尼因子，\n- $\\varepsilon$ 是收敛容差，\n- $N_{\\rm max}$ 是最大高斯-赛德尔扫描次数。\n\n使用以下用例：\n1. 用例 A（带均匀物质的非线性源）：$(N=12, \\Delta x=1, m^2=0.5, \\lambda=0.1, \\beta=0.2, M_{\\rm pl}=1, \\rho\\text{uniform}=1, \\phi_{\\rm init}=0, \\phi_{\\rm b}=0, \\omega=0.8, \\varepsilon=10^{-10}, N_{\\rm max}=800)$。\n2. 用例 B（无物质的线性源，平凡解）：$(N=12, \\Delta x=1, m^2=1.0, \\lambda=0.0, \\beta=0.0, M_{\\rm pl}=1, \\rho\\text{uniform}=0, \\phi_{\\rm init}=0, \\phi_{\\rm b}=0, \\omega=1.0, \\varepsilon=10^{-12}, N_{\\rm max}=50)$。\n3. 用例 C（带局域物质峰值的非线性源）：$(N=10, \\Delta x=1, m^2=1.0, \\lambda=0.5, \\beta=1.0, M_{\\rm pl}=1, \\rho\\text{point}=10 \\text{ 在中心网格点，其余为零}, \\phi_{\\rm init}=0, \\phi_{\\rm b}=0, \\omega=0.5, \\varepsilon=10^{-9}, N_{\\rm max}=1000)$。\n\n对于每个用例，在求解器终止后，计算并记录内部点上 $\\|F\\|_{\\infty}$ 的最终值。您的程序应生成单行输出，其中包含三个结果，格式为方括号内以逗号分隔的列表，顺序为 [用例 A 结果, 用例 B 结果, 用例 C 结果]。每个结果必须是浮点数。\n\n您的程序必须完全自包含，产生确定性结果而无需任何用户输入，并在标准约束内运行。实现必须使用 Python 语言并遵循最终答案部分中的规范。",
            "solution": "本问题要求推导并实现一个数值求解器，用于求解一个非线性椭圆偏微分方程。该方程出现在修正引力理论的背景下，特别是在采用如变色龙效应等屏蔽机制的理论中。问题的核心是使用牛顿-高斯-赛德尔松弛法在离散的立方体网格上求解此方程。\n\n该问题陈述已经过验证，被认为是具有科学依据、适定且客观的。它提供了所有必要的参数，并基于数值分析和物理学的既定原理，给出了一套明确的任务。\n\n### 第1部分：椭圆方程的离散化\n\n标量场 $\\phi$ 的控制方程如下：\n$$\n\\nabla^2 \\phi = S(\\phi, \\rho)\n$$\n其中源项 $S(\\phi, \\rho)$ 定义为：\n$$\nS(\\phi, \\rho) = V_{,\\phi}(\\phi) + \\frac{\\beta \\rho}{M_{\\rm pl}} = m^2 \\phi + \\lambda \\phi^3 + \\frac{\\beta \\rho}{M_{\\rm pl}}\n$$\n我们的任务是在间距为 $\\Delta x$ 的均匀立方体网格上离散化此方程。拉普拉斯算子 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2} + \\frac{\\partial^2}{\\partial z^2}$，在每个内部网格点 $(i, j, k)$ 处使用二阶中心有限差分格式进行近似。例如，关于坐标 $x$ 的二阶偏导数近似为：\n$$\n\\frac{\\partial^2 \\phi}{\\partial x^2}\\bigg|_{i,j,k} \\approx \\frac{\\phi_{i+1,j,k} - 2\\phi_{i,j,k} + \\phi_{i-1,j,k}}{(\\Delta x)^2}\n$$\n其中 $\\phi_{i,j,k} = \\phi(i\\Delta x, j\\Delta x, k\\Delta x)$。将其扩展到三维，得到拉普拉斯算子的标准6点格式：\n$$\n\\nabla^2 \\phi \\bigg|_{i,j,k} \\approx \\frac{\\phi_{i+1,j,k} + \\phi_{i-1,j,k} + \\phi_{i,j+1,k} + \\phi_{i,j-1,k} + \\phi_{i,k+1,j} + \\phi_{i,k-1,j} - 6\\phi_{i,j,k}}{(\\Delta x)^2}\n$$\n将此离散形式代入原始偏微分方程，我们得到在每个内部点 $(i, j, k)$ 的离散化方程：\n$$\n\\frac{1}{(\\Delta x)^2} \\left( \\sum_{\\text{neighbors}} \\phi_{\\text{neighbor}} - 6\\phi_{i,j,k} \\right) = m^2 \\phi_{i,j,k} + \\lambda \\phi_{i,j,k}^3 + \\frac{\\beta \\rho_{i,j,k}}{M_{\\rm pl}}\n$$\n其中求和项是对点 $(i,j,k)$ 的六个最近邻点进行的。\n\n问题要求定义一个局部残差方程 $F_{i,j,k}(\\phi) = 0$。这可以通过将方程的所有项移到一边来实现：\n$$\nF_{i,j,k}(\\phi) \\equiv \\frac{1}{(\\Delta x)^2} \\left( \\sum_{\\text{neighbors}} \\phi - 6\\phi_{i,j,k} \\right) - \\left( m^2 \\phi_{i,j,k} + \\lambda \\phi_{i,j,k}^3 + \\frac{\\beta \\rho_{i,j,k}}{M_{\\rm pl}} \\right) = 0\n$$\n对于离散场 $\\phi$ 成为一个解，此方程必须在每个内部网格点上都成立。\n\n### 第2部分：牛顿-高斯-赛德尔更新的推导\n\n牛顿-高斯-赛德尔法是求解非线性方程组的一种迭代技术。它将牛顿法分别应用于系统中的每个方程，一次更新一个变量，同时将所有其他变量视为固定值。对于我们的问题，这意味着在单个点上为变量 $\\phi_{i,j,k}$ 求解 $F_{i,j,k}(\\phi) = 0$，并假设所有邻近点上的 $\\phi$ 值是已知的。\n\n用于寻找函数 $f(x)=0$ 根的牛顿法提供了一个迭代更新式：\n$$\nx_{\\text{new}} = x_{\\text{old}} - \\frac{f(x_{\\text{old}})}{f'(x_{\\text{old}})}\n$$\n在我们的背景下，变量是 $\\phi_{i,j,k}$，函数是 $F_{i,j,k}$。所需的导数是“局部雅可比”，即 $F_{i,j,k}$ 对 $\\phi_{i,j,k}$ 的偏导数：\n$$\nF'_{i,j,k}(\\phi) \\equiv \\frac{\\partial F_{i,j,k}}{\\partial \\phi_{i,j,k}}\n$$\n我们从 $F_{i,j,k}$ 的表达式计算这个导数：\n$$\nF'_{i,j,k}(\\phi) = \\frac{\\partial}{\\partial \\phi_{i,j,k}} \\left[ \\frac{1}{(\\Delta x)^2} \\left( \\sum_{\\text{neighbors}} \\phi - 6\\phi_{i,j,k} \\right) - m^2 \\phi_{i,j,k} - \\lambda \\phi_{i,j,k}^3 - \\frac{\\beta \\rho_{i,j,k}}{M_{\\rm pl}} \\right]\n$$\n在此偏微分中，邻近点上的 $\\phi$ 值被视为常数。因此，我们得到：\n$$\nF'_{i,j,k}(\\phi) = -\\frac{6}{(\\Delta x)^2} - m^2 - 3\\lambda \\phi_{i,j,k}^2\n$$\n对 $\\phi_{i,j,k}$ 的牛顿更新由下式给出：\n$$\n\\phi^{\\text{update}}_{i,j,k} = \\phi^{\\text{old}}_{i,j,k} - \\frac{F_{i,j,k}(\\phi^{\\text{old}})}{F'_{i,j,k}(\\phi^{\\text{old}})}\n$$\n为提高稳定性，此更新通过一个因子 $\\omega \\in (0, 1]$ 进行阻尼。新值 $\\phi^{\\text{new}}_{i,j,k}$ 是旧值和完整牛顿更新的加权平均：\n$$\n\\phi^{\\text{new}}_{i,j,k} = (1-\\omega)\\phi^{\\text{old}}_{i,j,k} + \\omega \\cdot \\phi^{\\text{update}}_{i,j,k}\n$$\n代入更新的表达式，我们得到：\n$$\n\\phi^{\\text{new}}_{i,j,k} = (1-\\omega)\\phi^{\\text{old}}_{i,j,k} + \\omega \\left( \\phi^{\\text{old}}_{i,j,k} - \\frac{F_{i,j,k}(\\phi^{\\text{old}})}{F'_{i,j,k}(\\phi^{\\text{old}})} \\right)\n$$\n这可简化为阻尼牛顿更新法则：\n$$\n\\phi^{\\text{new}}_{i,j,k} = \\phi^{\\text{old}}_{i,j,k} - \\omega \\frac{F_{i,j,k}(\\phi^{\\text{old}})}{F'_{i,j,k}(\\phi^{\\text{old}})}\n$$\n在高斯-赛德尔格式中，当我们遍历网格点时（例如，按字典序），新计算出的 $\\phi$ 值会立即用于同一迭代中后续点的残差计算，从而导致更快的收敛。\n\n### 第3部分：算法实现\n\n求解器实现如下：\n1.  **初始化**：对于每个测试用例，创建一个大小为 $N \\times N \\times N$ 的三维网格用于 $\\phi$。边界单元被设置为狄利克雷值 $\\phi_{\\rm b}$，内部单元被设置为初始猜测值 $\\phi_{\\rm init}$。同时创建并根据测试用例规范（均匀或点源）填充相应的物质密度 $\\rho$ 网格。\n\n2.  **迭代求解器**：求解器执行一系列高斯-赛德尔扫描，最多进行 $N_{\\rm max}$ 次迭代。\n    - 在每次扫描中，代码按字典序遍历所有内部网格点 $(i, j, k)$（每个索引从 $1$ 到 $N-2$）。\n    - 在每个点上，使用网格上当前的 $\\phi$ 值计算局部残差 $F_{i,j,k}$。由于这是高斯-赛德尔扫描，当前扫描中已访问过的点的 $\\phi$ 值将是已更新的值。\n    - 跟踪扫描期间遇到的残差的最大绝对值 $\\|F\\|_{\\infty}$。\n    - 计算局部雅可比导数 $F'_{i,j,k}$。\n    - 使用上面推导的阻尼牛顿-高斯-赛德尔公式更新 $\\phi_{i,j,k}$ 的值。\n    - 每次完整扫描后，将计算出的 $\\|F\\|_{\\infty}$ 与容差 $\\varepsilon$ 进行比较。如果 $\\|F\\|_{\\infty} \\le \\varepsilon$，则迭代过程终止。\n\n3.  **最终结果**：在终止时（无论是通过收敛还是达到 $N_{\\rm max}$ 次迭代），使用 $\\phi$ 场的最终状态，对所有内部点执行一次最终的、精确的最大残差范数 $\\|F\\|_{\\infty}$ 计算。该值为测试用例报告的结果。这确保了报告的度量标准一致地反映了最终解的质量。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(N, dx, m2, lam, beta, M_pl, rho_config, phi_init, phi_b, omega, epsilon, N_max):\n    \"\"\"\n    Solves the nonlinear elliptic scalar field equation using a Newton-Gauss-Seidel method.\n\n    Args:\n        N (int): Number of grid points per dimension.\n        dx (float): Grid spacing.\n        m2 (float): Mass term squared for the potential.\n        lam (float): Self-interaction coupling for the potential.\n        beta (float): Coupling constant to matter.\n        M_pl (float): Planck mass.\n        rho_config (tuple): Specifies the matter density configuration.\n        phi_init (float): Initial value for the scalar field in the interior.\n        phi_b (float): Boundary value for the scalar field (Dirichlet).\n        omega (float): Damping factor for the Newton update.\n        epsilon (float): Convergence tolerance for the residual norm.\n        N_max (int): Maximum number of iterations.\n\n    Returns:\n        float: The final maximum norm of the residual, ||F||_infinity.\n    \"\"\"\n    # Initialize the scalar field grid\n    phi = np.full((N, N, N), phi_b, dtype=np.float64)\n    phi[1:-1, 1:-1, 1:-1] = phi_init\n\n    # Initialize the matter density grid\n    rho = np.zeros((N, N, N), dtype=np.float64)\n    if rho_config[0] == 'uniform':\n        rho[1:-1, 1:-1, 1:-1] = rho_config[1]\n    elif rho_config[0] == 'point':\n        center = N // 2\n        rho[center, center, center] = rho_config[1]\n\n    dx2 = dx * dx\n    \n    # --- Iterative Solver Loop ---\n    for _ in range(N_max):\n        max_residual_sweep = 0.0\n        \n        # Lexicographic Gauss-Seidel sweep over interior points\n        for i in range(1, N - 1):\n            for j in range(1, N - 1):\n                for k in range(1, N - 1):\n                    # Current value of phi at the grid point\n                    phi_ijk = phi[i, j, k]\n                    \n                    # Sum of phi over nearest neighbors\n                    sum_neighbors = (phi[i+1, j, k] + phi[i-1, j, k] +\n                                     phi[i, j+1, k] + phi[i, j-1, k] +\n                                     phi[i, j, k-1] + phi[i, j, k+1])\n\n                    # Calculate the local residual F_ijk\n                    laplacian_term = (sum_neighbors - 6.0 * phi_ijk) / dx2\n                    source_term = m2 * phi_ijk + lam * phi_ijk**3 + beta * rho[i, j, k] / M_pl\n                    residual = laplacian_term - source_term\n                    \n                    max_residual_sweep = max(max_residual_sweep, abs(residual))\n\n                    # Calculate the local Jacobian derivative F'_ijk\n                    residual_prime = -6.0 / dx2 - m2 - 3.0 * lam * phi_ijk**2\n                    \n                    # Apply the damped Newton-Gauss-Seidel update\n                    # Avoid division by zero, although F'_ijk is always negative for m^20, lambda=0\n                    if abs(residual_prime)  1e-15:\n                        phi[i, j, k] -= omega * residual / residual_prime\n        \n        # Check for convergence\n        if max_residual_sweep = epsilon:\n            break\n            \n    # --- Final Residual Calculation ---\n    # After the loop terminates, compute the final residual norm on the static solution grid.\n    final_max_residual = 0.0\n    for i in range(1, N - 1):\n        for j in range(1, N - 1):\n            for k in range(1, N - 1):\n                phi_ijk = phi[i, j, k]\n                sum_neighbors = (phi[i+1, j, k] + phi[i-1, j, k] +\n                                 phi[i, j+1, k] + phi[i, j-1, k] +\n                                 phi[i, j, k-1] + phi[i, j, k+1])\n                \n                laplacian_term = (sum_neighbors - 6.0 * phi_ijk) / dx2\n                source_term = m2 * phi_ijk + lam * phi_ijk**3 + beta * rho[i, j, k] / M_pl\n                residual = laplacian_term - source_term\n                final_max_residual = max(final_max_residual, abs(residual))\n\n    return final_max_residual\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # (N, dx, m^2, lambda, beta, M_pl, rho_config, phi_init, phi_b, omega, epsilon, N_max)\n    test_cases = [\n        (12, 1.0, 0.5, 0.1, 0.2, 1.0, ('uniform', 1.0), 0.0, 0.0, 0.8, 1e-10, 800), # Case A\n        (12, 1.0, 1.0, 0.0, 0.0, 1.0, ('uniform', 0.0), 0.0, 0.0, 1.0, 1e-12, 50), # Case B\n        (10, 1.0, 1.0, 0.5, 1.0, 1.0, ('point', 10.0), 0.0, 0.0, 0.5, 1e-9, 1000)  # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        N, dx, m2, lam, beta, M_pl, rho_conf, phi_init, phi_b, omega, eps, n_max = case\n        final_residual = run_simulation(N, dx, m2, lam, beta, M_pl, rho_conf, phi_init, phi_b, omega, eps, n_max)\n        results.append(final_residual)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "编写一个复杂的数值求解器只是第一步；验证其正确性是一项至关重要且常常充满挑战的任务。本练习介绍了强大的“人造解方法”（Method of Manufactured Solutions, MMS），这是一种严格的技术，用于确认您的代码实现是否达到了其理论上的精度阶。这项实践将培养您在代码验证方面的技能，这是开发可靠科学软件的必要组成部分。",
            "id": "3476431",
            "problem": "你的任务是为周期性、静态、空间二维设定下的变色龙筛选方程设计并验证一个人造解。目标方程是准静态变色龙场方程\n$$\n\\nabla^2 \\phi(\\mathbf{x}) \\;=\\; \\frac{\\partial V(\\phi)}{\\partial \\phi} \\;+\\; \\frac{\\beta}{M_{\\rm Pl}} \\,\\rho(\\mathbf{x}),\n$$\n其中 $\\,\\phi\\,$ 是标量场，$\\,V(\\phi)\\,$ 是其势，$\\,\\rho(\\mathbf{x})\\,$ 是物质密度，$\\,\\beta\\,$ 是一个耦合常数，而 $\\,M_{\\rm Pl}\\,$ 是约化普朗克质量。在一个方形周期性域 $[0,2\\pi]\\times[0,2\\pi]$ 中工作，假设使用无量纲单位，并设置 $\\,\\beta = 1\\,$ 和 $\\,M_{\\rm Pl} = 1\\,$. 你将使用人造解方法，以获得一个与所选的 $\\,\\phi(\\mathbf{x})\\,$ 和 $\\,V(\\phi)\\,$ 一致的闭式解析密度 $\\,\\rho(\\mathbf{x})\\,$，然后为该方程算子的离散化设计严格的精度阶测试。\n\n从以下基本基础开始：\n- 在二维空间中，拉普拉斯算子的定义是 $\\nabla^2 \\phi = \\partial_{xx} \\phi + \\partial_{yy} \\phi$。\n- 人造解方法规定选择解析场，并通过代入控制方程来计算其隐含的源项。\n- 在均匀网格上，中心差分五点模板在周期性边界条件下为拉普拉斯算子提供了一个二阶有限差分近似。\n\n你的任务是：\n1. 选择标量势为逆幂次变色龙势\n$$\nV(\\phi) \\;=\\; \\Lambda^{4+n}\\,\\phi^{-n},\n$$\n其中 $\\,\\Lambda = 1\\,$ 且 $\\,n = 2\\,$，因此\n$$\n\\frac{\\partial V}{\\partial \\phi}(\\phi) \\;=\\; -\\,n\\,\\Lambda^{4+n}\\,\\phi^{-n-1} \\;=\\; -\\,2\\,\\phi^{-3}.\n$$\n2. 选择人造标量场\n$$\n\\phi(x,y) \\;=\\; \\phi_0 \\;+\\; A \\cos(k x)\\cos(\\ell y),\n$$\n其中常数 $\\,\\phi_0  A  0\\,$，整数 $\\,k \\ge 1\\,$, $\\,\\ell \\ge 1\\,$, 确保 $\\,\\phi(x,y)  0\\,$ 在各处均成立。使用上述变色龙方程，其中 $\\,\\beta=M_{\\rm Pl}=1\\,$, 推导出相关的解析密度\n$$\n\\rho_{\\rm exact}(x,y) \\;=\\; \\nabla^2 \\phi(x,y) \\;-\\; \\frac{\\partial V}{\\partial \\phi} \\big(\\phi(x,y)\\big).\n$$\n3. 在一个带有周期性边界条件和网格间距 $\\,h = 2\\pi/N\\,$ 的均匀 $\\,N\\times N\\,$ 网格上，使用二阶、五点中心差分模板对拉普拉斯算子进行离散化。将数值密度定义为\n$$\n\\rho_{\\rm num} \\;=\\; \\left(\\nabla^2_h \\phi\\right) \\;-\\; \\frac{\\partial V}{\\partial \\phi}(\\phi),\n$$\n其中 $\\,\\nabla^2_h\\,$ 是离散拉普拉斯算子，$\\,\\phi\\,$ 在网格节点上进行精确求值。定义在所有网格节点上求值的逐点误差场 $\\,E = \\rho_{\\rm num} - \\rho_{\\rm exact}\\,$。使用离散均方根误差\n$$\n\\|E\\|_{2} \\;=\\; \\sqrt{\\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} E_{ij}^2}\n$$\n和离散最大范数误差\n$$\n\\|E\\|_{\\infty} \\;=\\; \\max_{i,j} |E_{ij}|.\n$$\n4. 对于一对网格 $\\,N_{\\rm c}\\,$ 和 $\\,N_{\\rm f}=2 N_{\\rm c}\\,$，其网格间距分别为 $\\,h_{\\rm c}\\,$ 和 $\\,h_{\\rm f}\\,$，计算每个范数的观测精度阶如下\n$$\np_2 \\;=\\; \\frac{\\ln\\big(\\|E\\|_{2,{\\rm c}} / \\|E\\|_{2,{\\rm f}}\\big)}{\\ln\\big(h_{\\rm c}/h_{\\rm f}\\big)}, \n\\qquad\np_\\infty \\;=\\; \\frac{\\ln\\big(\\|E\\|_{\\infty,{\\rm c}} / \\|E\\|_{\\infty,{\\rm f}}\\big)}{\\ln\\big(h_{\\rm c}/h_{\\rm f}\\big)}.\n$$\n\n使用上述选择，实现一个程序来执行以下测试套件：\n- 测试 A (边缘情况：恒定场筛选): 设置 $\\,N=32\\,$, $\\,\\phi_0 = 2.0\\,$, $\\,A=0.0\\,$, $\\,k=2\\,$, $\\,\\ell=3\\,$. 将此情况下的离散最大范数误差 $\\,\\|E\\|_{\\infty}\\,$作为浮点数报告。\n- 测试 B (收敛性，理想路径): 设置 $\\,\\phi_0 = 2.0\\,$, $\\,A=0.1\\,$, $\\,k=2\\,$, $\\,\\ell=3\\,$. 计算网格对 $\\,\\big(N_{\\rm c},N_{\\rm f}\\big)\\in\\{(16,32),(32,64),(64,128)\\}\\,$ 的观测精度阶 $\\,p_2\\,$ 和 $\\,p_\\infty\\,$, 并作为浮点数报告。\n\n你的程序必须：\n- 全程使用无量纲单位；不需要物理单位。\n- 在均匀网格上精确实现周期性边界条件。\n- 对于所有测试，根据解析表达式在网格节点上逐点计算 $\\,\\phi(x,y)\\,$ 和 $\\,\\frac{\\partial V}{\\partial \\phi}(\\phi)\\,$。\n- 按以下顺序将输出聚合到一行中：\n  $$\n  \\big[\\,\\|E\\|_{\\infty}\\text{ (Test A)},\\; p_2(16\\!\\to\\!32),\\; p_\\infty(16\\!\\to\\!32),\\; p_2(32\\!\\to\\!64),\\; p_\\infty(32\\!\\to\\!64),\\; p_2(64\\!\\to\\!128),\\; p_\\infty(64\\!\\to\\!128)\\,\\big].\n  $$\n- 你的程序应生成单行输出，其中包含用方括号括起来并以逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5,result6,result7]”）。\n\n所有数学实体，包括符号和数字，在你的推导和选择中都必须作为数学量来对待。你必须确保对于所选参数，$\\,\\phi(x,y)\\,$ 在整个域上保持严格为正，从而使势及其导数有良好定义。",
            "solution": "该问题要求使用人造解方法，为二维静态变色龙场方程的数值离散化设计并实现一个验证测试。该验证过程通过为一个选定的解析场推导精确源项，然后将此精确源项与使用有限差分近似计算出的数值源项进行比较。\n\n### 问题公式化与解析解\n\n控制方程是在二维周期性域 $[0,2\\pi]\\times[0,2\\pi]$ 上的准静态变色龙场方程。在指定的常数 $\\beta=1$ 和 $M_{\\rm Pl}=1$ 下，方程为：\n$$\n\\nabla^2 \\phi(x,y) = \\frac{\\partial V(\\phi)}{\\partial \\phi} + \\rho(x,y)\n$$\n其中 $\\phi(x,y)$ 是标量场，$V(\\phi)$ 是其势，而 $\\rho(x,y)$ 是物质密度。人造解方法涉及为 $\\phi$ 和 $V(\\phi)$ 选择解析形式，然后重新排列方程以定义一个与这些选择一致的精确源项 $\\rho_{\\rm exact}(x,y)$。\n\n势被选择为逆幂律形式：\n$$\nV(\\phi) = \\Lambda^{4+n}\\,\\phi^{-n}\n$$\n当参数 $\\Lambda=1$ 和 $n=2$ 时，该式简化为 $V(\\phi) = \\phi^{-2}$。其关于 $\\phi$ 的导数则为：\n$$\n\\frac{\\partial V}{\\partial \\phi}(\\phi) = -2\\,\\phi^{-3}\n$$\n人造标量场被选择为：\n$$\n\\phi(x,y) = \\phi_0 + A \\cos(k x)\\cos(\\ell y)\n$$\n参数被约束为 $\\phi_0  A  0$ 且 $k, \\ell$ 为非零整数，这确保了 $\\phi(x,y)$ 在整个域上严格为正，从而避免了 $V(\\phi)$ 及其导数中的奇异点。\n\n为了找到精确源项 $\\rho_{\\rm exact}(x,y)$，我们首先计算解析拉普拉斯算子 $\\nabla^2 \\phi = \\partial_{xx}\\phi + \\partial_{yy}\\phi$。偏导数是：\n$$\n\\begin{aligned}\n\\partial_x \\phi = -A k \\sin(k x)\\cos(\\ell y)  \\implies \\quad \\partial_{xx} \\phi = -A k^2 \\cos(k x)\\cos(\\ell y) \\\\\n\\partial_y \\phi = -A \\ell \\cos(k x)\\sin(\\ell y)  \\implies \\quad \\partial_{yy} \\phi = -A \\ell^2 \\cos(k x)\\cos(\\ell y)\n\\end{aligned}\n$$\n将二阶偏导数相加得到拉普拉斯算子：\n$$\n\\nabla^2 \\phi(x,y) = -A (k^2+\\ell^2) \\cos(k x)\\cos(\\ell y)\n$$\n重新排列控制方程以求解密度，我们得到精确的人造源项：\n$$\n\\rho_{\\rm exact}(x,y) = \\nabla^2 \\phi(x,y) - \\frac{\\partial V}{\\partial \\phi}\\big(\\phi(x,y)\\big)\n$$\n代入推导出的表达式可得：\n$$\n\\rho_{\\rm exact}(x,y) = -A (k^2+\\ell^2) \\cos(k x)\\cos(\\ell y) + 2 \\big(\\phi_0 + A \\cos(k x)\\cos(\\ell y)\\big)^{-3}\n$$\n\n### 数值离散化与误差分析\n\n验证测试涉及在网格间距为 $h = 2\\pi/N$ 的均匀 $N \\times N$ 网格上对算子进行离散化。网格节点位于 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。拉普拉斯算子 $\\nabla^2$ 使用二阶五点中心差分模板进行近似，记作 $\\nabla^2_h$。对于在网格上求值的场 $\\phi$（即 $\\phi_{ij} = \\phi(x_i, y_j)$），离散拉普拉斯算子为：\n$$\n(\\nabla^2_h \\phi)_{ij} = \\frac{\\phi_{i+1,j} - 2\\phi_{ij} + \\phi_{i-1,j}}{h^2} + \\frac{\\phi_{i,j+1} - 2\\phi_{ij} + \\phi_{i,j-1}}{h^2}\n$$\n通过对索引取模 $N$ 来强制实施周期性边界条件。\n\n数值源项 $\\rho_{\\rm num}$ 在每个网格节点上使用离散拉普拉斯算子以及 $\\phi$ 及其势导数的精确解析形式计算：\n$$\n(\\rho_{\\rm num})_{ij} = (\\nabla^2_h \\phi)_{ij} - \\frac{\\partial V}{\\partial \\phi}(\\phi_{ij})\n$$\n逐点误差场 $E$ 是数值源项与精确源项之差，$E_{ij} = (\\rho_{\\rm num})_{ij} - (\\rho_{\\rm exact})_{ij}$。代入定义，我们发现势项被消掉了：\n$$\nE_{ij} = \\left( (\\nabla^2_h \\phi)_{ij} - \\frac{\\partial V}{\\partial \\phi}(\\phi_{ij}) \\right) - \\left( \\nabla^2 \\phi(x_i, y_j) - \\frac{\\partial V}{\\partial \\phi}(\\phi_{ij}) \\right) = (\\nabla^2_h \\phi)_{ij} - \\nabla^2 \\phi(x_i, y_j)\n$$\n因此，误差场 $E$ 正是有限差分拉普拉斯算子的截断误差。对于一个二阶模板，该误差预计将按 $O(h^2)$ 的比例缩放。\n\n为了量化收敛性，我们使用两种离散误差范数：均方根范数 ($\\|E\\|_{2}$) 和最大范数 ($\\|E\\|_{\\infty}$):\n$$\n\\|E\\|_{2} = \\sqrt{\\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} E_{ij}^2}, \\qquad \\|E\\|_{\\infty} = \\max_{i,j} |E_{ij}|\n$$\n给定在粗网格（$N_c$，间距 $h_c$）和细网格（$N_f=2N_c$，间距 $h_f=h_c/2$）上计算的误差，观测到的精度阶 $p$ 计算如下：\n$$\np = \\frac{\\ln\\big(\\|E\\|_{c} / \\|E\\|_{f}\\big)}{\\ln\\big(h_{c}/h_{f}\\big)} = \\frac{\\ln\\big(\\|E\\|_{c} / \\|E\\|_{f}\\big)}{\\ln(2)}\n$$\n对于一个正确的二阶实现，我们期望 $p_2 \\approx 2$ 和 $p_\\infty \\approx 2$。\n\n### 实现策略\n\n该解法通过使用 `numpy` 库的 Python 程序实现。\n1.  定义一个函数 `calculate_errors`，用于对给定的一组参数 $(N, \\phi_0, A, k, \\ell)$ 执行核心计算。\n2.  在此函数内部，使用 `numpy.meshgrid` 生成一个二维网格。\n3.  在每个网格节点上计算解析场 $\\phi(x,y)$ 和 $\\rho_{\\rm exact}(x,y)$。\n4.  使用 `numpy.roll` 高效处理周期性边界条件，从而计算离散拉普拉斯算子 $\\nabla^2_h \\phi$。\n5.  计算数值源 $\\rho_{\\rm num}$ 和误差场 $E$。\n6.  该函数返回误差场的 $\\|E\\|_2$ 和 $\\|E\\|_\\infty$ 范数。\n7.  主脚本 `solve()` 组织执行指定的测试：\n    - **测试 A:** 调用 `calculate_errors` 并设置 $A=0$ 以验证 $\\phi$ 为常数的平凡情况。在这种情况下，解析拉普拉斯算子为零，离散拉普拉斯算子也应为零（在机器精度范围内），从而导致接近零的误差。\n    - **测试 B:** 对一系列加密的网格分辨率（$N=16, 32, 64, 128$）调用 `calculate_errors`。然后使用得到的误差范数计算每个加密步骤的观测精度阶 $p_2$ 和 $p_\\infty$。\n8.  收集最终结果并按指定格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_errors(N, phi0, A, k, l):\n    \"\"\"\n    Calculates the error between the numerical and exact source terms for the\n    chameleon equation using a manufactured solution.\n\n    Args:\n        N (int): Grid resolution (N x N).\n        phi0 (float): Constant background of the scalar field.\n        A (float): Amplitude of the scalar field perturbation.\n        k (int): Wavenumber in the x-direction.\n        l (int): Wavenumber in the y-direction.\n\n    Returns:\n        tuple: A tuple containing the L2-norm and L-infinity norm of the error.\n    \"\"\"\n    # 1. Grid setup\n    h = 2.0 * np.pi / N\n    # Create 1D coordinate arrays for an N-point grid from 0 to 2*pi - h\n    grid_coords = np.arange(N) * h\n    # Create 2D grid\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n\n    # 2. Evaluate analytical fields on the grid\n    cos_kx = np.cos(k * xx)\n    cos_ly = np.cos(l * yy)\n    phi_grid = phi0 + A * cos_kx * cos_ly\n    \n    # Analytical Laplacian: lap(phi) = -A * (k^2 + l^2) * cos(kx) * cos(ly)\n    lap_phi_exact_grid = -A * (k**2 + l**2) * cos_kx * cos_ly\n    \n    # Potential derivative term: dV/dphi = -2 * phi^(-3)\n    dv_dphi_grid = -2.0 * np.power(phi_grid, -3)\n    \n    # Exact source term: rho_exact = lap(phi) - dV/dphi\n    rho_exact_grid = lap_phi_exact_grid - dv_dphi_grid\n\n    # 3. Compute numerical source term\n    # Discrete Laplacian using a 5-point stencil with periodic boundary conditions.\n    # axis=1 corresponds to x-direction (indices i), axis=0 to y-direction (indices j)\n    phi_ip1 = np.roll(phi_grid, -1, axis=1)  # phi_{i+1, j}\n    phi_im1 = np.roll(phi_grid,  1, axis=1)  # phi_{i-1, j}\n    phi_jp1 = np.roll(phi_grid, -1, axis=0)  # phi_{i, j+1}\n    phi_jm1 = np.roll(phi_grid,  1, axis=0)  # phi_{i, j-1}\n\n    d2phi_dx2_num = (phi_ip1 - 2.0 * phi_grid + phi_im1) / (h**2)\n    d2phi_dy2_num = (phi_jp1 - 2.0 * phi_grid + phi_jm1) / (h**2)\n    lap_phi_num_grid = d2phi_dx2_num + d2phi_dy2_num\n    \n    # Numerical source term: rho_num = lap_h(phi) - dV/dphi\n    rho_num_grid = lap_phi_num_grid - dv_dphi_grid\n    \n    # 4. Calculate error field and norms\n    error_grid = rho_num_grid - rho_exact_grid\n    \n    e_inf = np.max(np.abs(error_grid))\n    e_2 = np.sqrt(np.mean(error_grid**2))\n    \n    return e_2, e_inf\n\ndef solve():\n    \"\"\"\n    Main function to run the specified tests and print the results.\n    \"\"\"\n    results = []\n    \n    # Test A: Constant field edge case\n    params_A = {'N': 32, 'phi0': 2.0, 'A': 0.0, 'k': 2, 'l': 3}\n    _, e_inf_A = calculate_errors(**params_A)\n    results.append(e_inf_A)\n    \n    # Test B: Convergence test\n    params_B = {'phi0': 2.0, 'A': 0.1, 'k': 2, 'l': 3}\n    grid_pairs = [(16, 32), (32, 64), (64, 128)]\n    all_Ns = sorted(list(set(sum(grid_pairs, ()))))\n    \n    error_data = {}\n    for N in all_Ns:\n        e2, einf = calculate_errors(N, **params_B)\n        error_data[N] = {'e2': e2, 'einf': einf}\n        \n    log2 = np.log(2.0)\n    for Nc, Nf in grid_pairs:\n        # h_c / h_f = (2*pi/Nc) / (2*pi/Nf) = Nf / Nc = 2\n        # So log(h_c/h_f) = log(2)\n        \n        e2_c = error_data[Nc]['e2']\n        einf_c = error_data[Nc]['einf']\n        e2_f = error_data[Nf]['e2']\n        einf_f = error_data[Nf]['einf']\n        \n        # Order of accuracy p = log(Error_coarse / Error_fine) / log(2)\n        p2 = np.log(e2_c / e2_f) / log2 if e2_f > 0 else 0.0\n        p_inf = np.log(einf_c / einf_f) / log2 if einf_f > 0 else 0.0\n        \n        results.append(p2)\n        results.append(p_inf)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}