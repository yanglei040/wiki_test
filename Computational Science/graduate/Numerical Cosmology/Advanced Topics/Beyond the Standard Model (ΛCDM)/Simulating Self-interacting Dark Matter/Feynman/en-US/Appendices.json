{
    "hands_on_practices": [
        {
            "introduction": "Before a single line of simulation code is run, a crucial translation must occur: physical constants and parameters must be converted into the internal, often dimensionless, \"code units\" of the simulation. This process is fundamental to ensuring numerical stability and consistency. This first practice  provides a direct exercise in the dimensional analysis required to convert a physically-motivated SIDM cross-section from standard astrophysical units into a value appropriate for a typical N-body code.",
            "id": "3488395",
            "problem": "In numerical cosmology simulations of Self-Interacting Dark Matter (SIDM), the scattering probability often depends on the cross-section per unit mass, denoted by $(\\sigma/m)$, which has dimensions of area per mass. Consider a code whose internal unit system uses a base length unit of $1$ kiloparsec ($\\mathrm{kpc}$), a base mass unit of $1 \\times 10^{10}$ solar masses ($\\mathrm{M}_{\\odot}$), and a base velocity unit of $1$ kilometer per second ($\\mathrm{km/s}$). A commonly used physical value for SIDM is $(\\sigma/m) = 1\\ \\mathrm{cm}^{2}\\ \\mathrm{g}^{-1}$.\n\nStarting from dimensional analysis and the core definition that $(\\sigma/m)$ has units of $L^{2}M^{-1}$, derive the conversion from the physical value $(\\sigma/m) = 1\\ \\mathrm{cm}^{2}\\ \\mathrm{g}^{-1}$ to the code units implied by the given base units. Use the well-established constants $1\\ \\mathrm{kpc} = 3.085677581 \\times 10^{21}\\ \\mathrm{cm}$ and $1\\ \\mathrm{M}_{\\odot} = 1.98847 \\times 10^{33}\\ \\mathrm{g}$, and treat the code-unit $(\\sigma/m)$ as the dimensionless ratio of the physical $(\\sigma/m)$ to the code unit for $L^{2}M^{-1}$, which is $L_{0}^{2}/M_{0}$ with $L_{0} = 1\\ \\mathrm{kpc}$ and $M_{0} = 1 \\times 10^{10}\\ \\mathrm{M}_{\\odot}$.\n\nCompute the corresponding code value of $(\\sigma/m)$ for use in simulations. Express your final answer as a dimensionless number, and round your result to five significant figures.",
            "solution": "The problem requires the conversion of the physical value for the self-interacting dark matter cross-section per unit mass, $(\\sigma/m)$, from physical units to the internal, dimensionless units of a numerical simulation code. This is a standard procedure in computational physics and astrophysics, ensuring that the equations of motion are solved in a consistent and numerically stable manner.\n\nThe quantity of interest is the cross-section per unit mass, which we denote as $(\\sigma/m)$. Its physical dimensions are area per mass, which can be written as $L^{2}M^{-1}$, where $L$ represents length and $M$ represents mass.\n\nThe physical value is given as $(\\sigma/m)_{\\text{phys}} = 1\\ \\mathrm{cm}^2\\ \\mathrm{g}^{-1}$.\n\nThe simulation code's internal unit system is defined by a set of base units. For this problem, the relevant base units are:\n- The base unit of length, $L_0 = 1\\ \\mathrm{kpc}$.\n- The base unit of mass, $M_0 = 1 \\times 10^{10}\\ \\mathrm{M}_{\\odot}$.\n(Note: The provided base velocity unit, $V_0 = 1\\ \\mathrm{km/s}$, is not required for this specific conversion as the dimensions of $(\\sigma/m)$ only involve length and mass.)\n\nFrom these base units, we can construct the code's internal unit for the quantity $(\\sigma/m)$, which we will denote as $(\\sigma/m)_{\\text{code\\_unit}}$. This unit is derived from the dimensions $L^2M^{-1}$:\n$$ (\\sigma/m)_{\\text{code\\_unit}} = \\frac{L_0^2}{M_0} = \\frac{(1\\ \\mathrm{kpc})^2}{1 \\times 10^{10}\\ \\mathrm{M}_{\\odot}} $$\n\nThe problem defines the dimensionless code value, which we denote as $(\\sigma/m)_{\\text{code}}$, as the ratio of the physical value to the code's base unit for that quantity.\n$$ (\\sigma/m)_{\\text{code}} = \\frac{(\\sigma/m)_{\\text{phys}}}{(\\sigma/m)_{\\text{code\\_unit}}} $$\n\nSubstituting the expressions for the physical value and the code unit gives:\n$$ (\\sigma/m)_{\\text{code}} = \\frac{1\\ \\mathrm{cm}^2\\ \\mathrm{g}^{-1}}{\\frac{(1\\ \\mathrm{kpc})^2}{1 \\times 10^{10}\\ \\mathrm{M}_{\\odot}}} = \\frac{(1\\ \\mathrm{cm}^2\\ \\mathrm{g}^{-1}) \\cdot (1 \\times 10^{10}\\ \\mathrm{M}_{\\odot})}{(1\\ \\mathrm{kpc})^2} $$\n\nTo evaluate this expression and ensure it is dimensionless, we must convert all units to a consistent system, for instance, by expressing $\\mathrm{kpc}$ in $\\mathrm{cm}$ and $\\mathrm{M}_{\\odot}$ in $\\mathrm{g}$. The problem provides the necessary conversion factors:\n- $1\\ \\mathrm{kpc} = 3.085677581 \\times 10^{21}\\ \\mathrm{cm}$\n- $1\\ \\mathrm{M}_{\\odot} = 1.98847 \\times 10^{33}\\ \\mathrm{g}$\n\nWe substitute these conversion factors into our expression for $(\\sigma/m)_{\\text{code}}$:\n$$ (\\sigma/m)_{\\text{code}} = \\frac{(1\\ \\mathrm{cm}^2 \\cdot \\mathrm{g}^{-1}) \\cdot (1 \\times 10^{10} \\cdot (1.98847 \\times 10^{33}\\ \\mathrm{g}))}{(3.085677581 \\times 10^{21}\\ \\mathrm{cm})^2} $$\n\nLet us now simplify the expression. First, evaluate the numerator:\n$$ \\text{Numerator} = 1 \\cdot (1 \\times 10^{10}) \\cdot (1.98847 \\times 10^{33})\\ \\mathrm{cm}^2 = 1.98847 \\times 10^{43}\\ \\mathrm{cm}^2 $$\nNext, evaluate the denominator:\n$$ \\text{Denominator} = (3.085677581 \\times 10^{21})^2\\ \\mathrm{cm}^2 = (3.085677581)^2 \\times 10^{42}\\ \\mathrm{cm}^2 $$\n$$ \\text{Denominator} \\approx 9.521406856 \\times 10^{42}\\ \\mathrm{cm}^2 $$\n\nNow, we compute the ratio. The units of $\\mathrm{cm}^2$ in the numerator and denominator cancel, as expected, yielding a dimensionless number.\n$$ (\\sigma/m)_{\\text{code}} = \\frac{1.98847 \\times 10^{43}}{9.521406856 \\times 10^{42}} = \\frac{1.98847}{9.521406856} \\times 10 $$\n$$ (\\sigma/m)_{\\text{code}} \\approx 0.2088425178 \\times 10 $$\n$$ (\\sigma/m)_{\\text{code}} \\approx 2.088425178 $$\n\nThe problem requires the final answer to be rounded to five significant figures. The first five significant figures are $2.0884$. The sixth digit is $2$, which is less than $5$, so we round down.\n$$ (\\sigma/m)_{\\text{code}} \\approx 2.0884 $$\n\nThus, the physical value of $(\\sigma/m) = 1\\ \\mathrm{cm}^{2}\\ \\mathrm{g}^{-1}$ corresponds to a dimensionless value of approximately $2.0884$ in the specified code units.",
            "answer": "$$\\boxed{2.0884}$$"
        },
        {
            "introduction": "At the heart of any SIDM simulation is the algorithm that governs how dark matter particles interact. This exercise  moves from abstract concepts to concrete implementation, guiding you through the construction of a pairwise Monte Carlo scattering scheme. You will learn how to connect the continuous physics of collision rates, derived from kinetic theory, to a discrete, probabilistic model using a kernel-based density estimate, a technique at the frontier of modern cosmological simulations.",
            "id": "3488392",
            "problem": "You are to design and implement a statistically consistent scattering module for Self-Interacting Dark Matter (SIDM) within a minimal Three-Dimensional N-body framework using a Monte Carlo approach. The goal is to derive, justify, and implement a per-pair scattering probability for a single timestep based on kinetic theory and a kernel density estimate.\n\nUse the following fundamental base and definitions:\n- The instantaneous collision rate for a particle moving through a background with number density is proportional to the product of cross section and relative speed. For a mass-based description, the collision rate for a particle with velocity relative to a local mass density is proportional to the cross section per unit mass and the local mass density.\n- The local mass density at the position of a particle can be estimated with Smoothed Particle Hydrodynamics (SPH) using a kernel function that integrates to unity over volume.\n- The cubic spline kernel in three spatial dimensions is normalized and compactly supported; its value is a function of the dimensionless separation $q = r/h$, where $r$ is the pair separation and $h$ is the smoothing length.\n\nTask:\n1. Starting from kinetic theory and the definition of a kernel-based density estimate, derive a mathematically consistent expression for the expected number of collisions contributed by a single neighbor in a timestep. From this, derive a per-pair probability for at most one scattering event in the timestep that is symmetric in the pair label and valid in the small-probability limit.\n2. Specify and implement the Three-Dimensional cubic spline kernel $W(r,h)$, where $r$ is the separation and $h$ is the smoothing length, with the following piecewise definition:\n   - Let $q = r/h$.\n   - For $0 \\le q \\le 1$, $$W(r,h) = \\frac{1}{\\pi h^3}\\left(1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3\\right).$$\n   - For $1  q \\le 2$, $$W(r,h) = \\frac{1}{\\pi h^3}\\left(\\frac{1}{4}(2 - q)^3\\right).$$\n   - For $q  2$, $$W(r,h) = 0.$$\n3. Implement a Monte Carlo scheme that, for each unordered particle pair $(i,j)$:\n   - Computes the separation $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$ and the relative speed $v_{ij} = \\lVert \\mathbf{v}_i - \\mathbf{v}_j \\rVert$.\n   - Evaluates $W(r_{ij}, h)$ and sets the pairwise probability for at least one scattering within the timestep as the union of low-probability independent events contributed by each particle in the pair.\n   - Ensures all per-substep pairwise probabilities remain bounded by a user-specified small value to maintain the small-probability regime. If the maximum pairwise probability across all pairs in the full timestep exceeds this bound, uniformly substep the timestep into $N_{\\text{sub}}$ equal parts such that the per-substep pairwise probabilities do not exceed the bound. Use independent Bernoulli trials per substep and per pair.\n4. Scientific units, implementation constraints, and numerical consistency:\n   - Use International System of Units (SI units) throughout:\n     - Mass in kilograms ($\\mathrm{kg}$).\n     - Position in meters ($\\mathrm{m}$).\n     - Velocity in meters per second ($\\mathrm{m/s}$).\n     - Smoothing length in meters ($\\mathrm{m}$).\n     - Time in seconds ($\\mathrm{s}$).\n     - Cross section per unit mass in square meters per kilogram ($\\mathrm{m^2/kg}$).\n   - The kernel $W(r,h)$ has units of inverse volume ($\\mathrm{m^{-3}}$). The per-pair probability must be dimensionless.\n   - Random sampling must be deterministic for testing; fix the pseudo-random seed to a constant value.\n5. Program requirements:\n   - Implement the above in a single program without external inputs.\n   - For each test case, compute the total number of scattering events realized across all unordered pairs in the timestep, using the substepping scheme if needed. Express the result as an integer for each test case.\n\nTest suite:\n- All test cases use the same particle set except where specified. There are $N=8$ particles with equal masses $m_i = 2.0 \\times 10^{38}\\ \\mathrm{kg}$, smoothing length $h = 1.5 \\times 10^{20}\\ \\mathrm{m}$, and positions\n  $$\\mathbf{r}_0 = (0,0,0),\\quad \\mathbf{r}_1 = (2.0\\times 10^{20},0,0),\\quad \\mathbf{r}_2 = (-1.0\\times 10^{20},1.0\\times 10^{20},0),$$\n  $$\\mathbf{r}_3 = (0,-2.0\\times 10^{20},1.0\\times 10^{20}),\\quad \\mathbf{r}_4 = (3.0\\times 10^{20},1.0\\times 10^{20},-1.0\\times 10^{20}),$$\n  $$\\mathbf{r}_5 = (-2.0\\times 10^{20},-2.0\\times 10^{20},0),\\quad \\mathbf{r}_6 = (1.0\\times 10^{20},-1.0\\times 10^{20},2.0\\times 10^{20}),$$\n  $$\\mathbf{r}_7 = (-1.0\\times 10^{19},2.0\\times 10^{20},-1.0\\times 10^{20}).$$\n- For Test Cases 1–3, velocities are\n  $$\\mathbf{v}_0 = (1.0\\times 10^{5},0,0),\\quad \\mathbf{v}_1 = (-5.0\\times 10^{4},2.0\\times 10^{4},0),\\quad \\mathbf{v}_2 = (2.0\\times 10^{5},-1.0\\times 10^{5},5.0\\times 10^{4}),$$\n  $$\\mathbf{v}_3 = (0,-8.0\\times 10^{4},1.0\\times 10^{5}),\\quad \\mathbf{v}_4 = (-1.0\\times 10^{5},3.0\\times 10^{4},-2.0\\times 10^{4}),$$\n  $$\\mathbf{v}_5 = (5.0\\times 10^{4},-1.0\\times 10^{5},0),\\quad \\mathbf{v}_6 = (0,1.0\\times 10^{5},-1.0\\times 10^{5}),$$\n  $$\\mathbf{v}_7 = (1.0\\times 10^{4},-2.0\\times 10^{4},3.0\\times 10^{4}).$$\n- Test Case 1 (happy path): cross section per mass $\\sigma/m = 0.1\\ \\mathrm{m^2/kg}$, timestep $\\Delta t = 3.154\\times 10^{13}\\ \\mathrm{s}$ (one megayear), probability cap per substep $p_{\\max} = 0.1$.\n- Test Case 2 (boundary: no scattering): cross section per mass $\\sigma/m = 0.0\\ \\mathrm{m^2/kg}$, timestep $\\Delta t = 3.154\\times 10^{13}\\ \\mathrm{s}$, same $p_{\\max}$, same positions and velocities as Test Case 1.\n- Test Case 3 (edge: large probabilities requiring substepping): cross section per mass $\\sigma/m = 1.0\\ \\mathrm{m^2/kg}$, timestep $\\Delta t = 1.577\\times 10^{16}\\ \\mathrm{s}$ (five hundred megayears), same $p_{\\max}$, same positions and velocities as Test Case 1.\n- Test Case 4 (edge: zero relative speeds): same as Test Case 1 except all velocities are identical, $\\mathbf{v}_i = (0,0,0)$ for all $i$, ensuring $v_{ij} = 0$ for all pairs.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Test Cases 1–4. For example, the output must look like\n  $$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4],$$\nwhere each $\\text{result}_k$ is an integer equal to the total number of realized scattering events in the corresponding test case.",
            "solution": "We begin with the physical picture that Self-Interacting Dark Matter (SIDM) particles undergo rare elastic scatterings characterized by a cross section per unit mass, denoted by $\\sigma/m$ with units $\\mathrm{m^2/kg}$. In a discretized N-body representation, macroparticles with masses $\\{m_i\\}$ and velocities $\\{\\mathbf{v}_i\\}$ serve as samples of the underlying continuous distribution. To connect discrete particles to continuous fields, we adopt a Smoothed Particle Hydrodynamics (SPH) kernel $W(r,h)$, which in three dimensions has units $\\mathrm{m^{-3}}$, is normalized to integrate to unity, and is compactly supported with cutoff radius $2h$.\n\nPrinciple-based derivation:\n1. The instantaneous collision rate for a particle moving through a background with mass density $\\rho$ is given, up to the proportionality defined by the cross section per mass, by\n   $$\\Gamma \\propto \\frac{\\sigma}{m}\\,\\rho\\,v,$$\n   where $v$ is a representative relative speed. In our discrete setting, the local mass density at the position of particle $i$ is estimated via the kernel density estimate\n   $$\\rho_i = \\sum_{j} m_j\\,W(|\\mathbf{r}_i - \\mathbf{r}_j|,h).$$\n   This density estimate has the correct units because $m_j$ is in $\\mathrm{kg}$ and $W$ is in $\\mathrm{m^{-3}}$.\n\n2. The expected number of collisions experienced by particle $i$ in a small timestep $\\Delta t$ due to the contribution of a single neighbor $j$ is proportional to the neighbor’s mass contribution to the local density, evaluated with the relative speed between particles $i$ and $j$. Thus, the expected number of collisions contributed by $j$ to $i$ in $\\Delta t$ is\n   $$\\lambda_{ij} = \\frac{\\sigma}{m}\\,m_j\\,v_{ij}\\,W(|\\mathbf{r}_i - \\mathbf{r}_j|,h)\\,\\Delta t.$$\n   The quantity $\\lambda_{ij}$ is dimensionless: $\\sigma/m$ is $\\mathrm{m^2/kg}$, $m_j$ is $\\mathrm{kg}$, $v_{ij}$ is $\\mathrm{m/s}$, $W$ is $\\mathrm{m^{-3}}$, and $\\Delta t$ is $\\mathrm{s}$, so the product has units $\\mathrm{m^2/kg}\\cdot \\mathrm{kg}\\cdot \\mathrm{m/s}\\cdot \\mathrm{m^{-3}}\\cdot \\mathrm{s} = \\mathrm{m^0} = 1.$\n\n3. In the small-probability regime, scattering events are rare and can be modeled as independent Bernoulli trials per pair. When considering unordered pairs $(i,j)$, we must avoid double counting. The event “$i$ scatters due to $j$” has probability approximately $\\lambda_{ij}$, and the event “$j$ scatters due to $i$” has probability approximately $\\lambda_{ji}$. In the small-probability limit, the union probability that at least one scattering occurs in the pair is\n   $$P_{\\text{pair}} \\approx \\lambda_{ij} + \\lambda_{ji},$$\n   since the overlap probability $\\lambda_{ij}\\lambda_{ji}$ is negligible when both $\\lambda_{ij} \\ll 1$ and $\\lambda_{ji} \\ll 1$. This construction treats the pair symmetrically.\n\n4. Ensuring small per-substep probabilities:\n   - To maintain the validity of the independent rare-event approximation, we impose a cap $p_{\\max}$ on the per-substep pairwise probability. Given a full-step pair probability $P_{\\text{pair}}$, we choose a number of substeps\n     $$N_{\\text{sub}} = \\max\\left(1,\\left\\lceil \\frac{\\max_{\\text{pairs}} P_{\\text{pair}}}{p_{\\max}} \\right\\rceil\\right),$$\n     and run $N_{\\text{sub}}$ identical substeps, each with per-substep probability\n     $$p_{\\text{sub}} = \\frac{P_{\\text{pair}}}{N_{\\text{sub}}},$$\n     ensuring $p_{\\text{sub}} \\le p_{\\max} \\ll 1$. Over $N_{\\text{sub}}$ substeps, the expected number of pair events remains $P_{\\text{pair}}$, while each substep keeps the Bernoulli approximation controlled.\n\nAlgorithmic design:\n- Inputs are masses $\\{m_i\\}$, positions $\\{\\mathbf{r}_i\\}$, velocities $\\{\\mathbf{v}_i\\}$, smoothing length $h$, cross section per mass $\\sigma/m$, timestep $\\Delta t$, and probability cap $p_{\\max}$, all in SI units.\n- Implement the Three-Dimensional cubic spline kernel:\n  - Define $q = r/h$.\n  - For $0 \\le q \\le 1$, $W(r,h) = \\frac{1}{\\pi h^3}\\left(1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3\\right)$.\n  - For $1  q \\le 2$, $W(r,h) = \\frac{1}{\\pi h^3}\\left(\\frac{1}{4}(2 - q)^3\\right)$.\n  - For $q  2$, $W(r,h) = 0$.\n- For each unordered pair $(i,j)$ with $i  j$:\n  - Compute $r_{ij}$ and $v_{ij}$.\n  - Evaluate $W_{ij} = W(r_{ij},h)$.\n  - If $W_{ij} = 0$ or $v_{ij} = 0$, set $P_{\\text{pair}} = 0$.\n  - Else compute $\\lambda_{ij} = \\frac{\\sigma}{m} m_j v_{ij} W_{ij} \\Delta t$ and $\\lambda_{ji} = \\frac{\\sigma}{m} m_i v_{ij} W_{ij} \\Delta t$, then set $P_{\\text{pair}} = \\lambda_{ij} + \\lambda_{ji}$.\n- Compute $N_{\\text{sub}}$ using the cap $p_{\\max}$ and the maximum $P_{\\text{pair}}$ across all pairs. Run $N_{\\text{sub}}$ substeps; in each substep, for each pair perform a Bernoulli trial with probability $p_{\\text{sub}} = P_{\\text{pair}}/N_{\\text{sub}}$. Count the number of successes across all pairs and all substeps as the total number of scattering events.\n- Use a fixed pseudo-random seed to ensure deterministic outputs.\n\nTest suite coverage:\n- Test Case 1 verifies the happy path where probabilities are small and nonzero with astrophysically plausible parameters.\n- Test Case 2 sets $\\sigma/m = 0$ to enforce zero probability by physics, yielding zero scattering events.\n- Test Case 3 scales $\\sigma/m$ and $\\Delta t$ to force some $P_{\\text{pair}}$ values above the cap, validating substepping and yielding a larger number of events.\n- Test Case 4 sets all velocities equal, enforcing $v_{ij} = 0$ for all pairs, and thus zero events.\n\nOutput:\n- The program aggregates the integer counts for Test Cases 1–4 into a single list and prints one line in the format $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef cubic_spline_kernel(r: float, h: float) - float:\n    \"\"\"\n    Three-Dimensional cubic spline SPH kernel W(r,h) with compact support 2h.\n    Parameters:\n        r: separation in meters\n        h: smoothing length in meters\n    Returns:\n        W: kernel value in m^{-3}\n    \"\"\"\n    if h = 0.0:\n        raise ValueError(\"Smoothing length h must be positive.\")\n    q = r / h\n    inv_pi_h3 = 1.0 / (np.pi * h**3)\n    if q  0:\n        return 0.0\n    if q = 1.0:\n        return inv_pi_h3 * (1.0 - 1.5 * q**2 + 0.75 * q**3)\n    elif q = 2.0:\n        return inv_pi_h3 * (0.25 * (2.0 - q)**3)\n    else:\n        return 0.0\n\ndef pairwise_probabilities(masses, positions, velocities, h, sigma_over_m, dt):\n    \"\"\"\n    Compute per-pair probabilities P_pair for at least one scattering event\n    in a full timestep dt, using the union of low-probability contributions\n    from i due to j and j due to i.\n\n    Parameters:\n        masses: array of shape (N,) in kg\n        positions: array of shape (N,3) in m\n        velocities: array of shape (N,3) in m/s\n        h: smoothing length in m\n        sigma_over_m: cross section per mass in m^2/kg\n        dt: timestep in s\n    Returns:\n        probs: list of per-pair probabilities for unordered pairs (ij)\n    \"\"\"\n    N = len(masses)\n    probs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            # Separation and relative speed\n            rij = np.linalg.norm(positions[i] - positions[j])\n            vij = np.linalg.norm(velocities[i] - velocities[j])\n            Wij = cubic_spline_kernel(rij, h)\n            if Wij = 0.0 or vij = 0.0 or sigma_over_m = 0.0:\n                probs.append(0.0)\n                continue\n            # Expected counts contributed by each direction\n            lam_ij = sigma_over_m * masses[j] * vij * Wij * dt\n            lam_ji = sigma_over_m * masses[i] * vij * Wij * dt\n            # Small-probability union approximation\n            P_pair = lam_ij + lam_ji\n            # Numerical safety: clamp to [0, 1]\n            if P_pair  0.0:\n                P_pair = 0.0\n            elif P_pair  1.0:\n                # In practice, substepping will handle large values; clamp here for numerical stability.\n                P_pair = 1.0\n            probs.append(P_pair)\n    return probs\n\ndef scatter_count(masses, positions, velocities, h, sigma_over_m, dt, p_max=0.1, seed=42):\n    \"\"\"\n    Perform Monte Carlo scattering across all unordered pairs in a single (possibly substepped) timestep.\n\n    Parameters:\n        masses, positions, velocities: arrays as above\n        h: smoothing length in m\n        sigma_over_m: cross section per mass in m^2/kg\n        dt: timestep in s\n        p_max: maximum per-substep pair probability (dimensionless)\n        seed: RNG seed for determinism\n    Returns:\n        total_scatter_events: integer count of realized scattering events across all pairs and substeps\n    \"\"\"\n    # Compute full-step per-pair probabilities\n    pair_probs = pairwise_probabilities(masses, positions, velocities, h, sigma_over_m, dt)\n    max_p = max(pair_probs) if pair_probs else 0.0\n    # Determine number of substeps to enforce p_sub = p_max\n    if p_max = 0.0:\n        # If p_max is non-positive, default to 1 substep (no cap enforcement)\n        n_sub = 1\n    else:\n        n_sub = int(np.ceil(max_p / p_max)) if max_p  p_max else 1\n    # Prepare RNG\n    rng = np.random.default_rng(seed)\n    total_events = 0\n    if n_sub = 0:\n        n_sub = 1\n    # Run substeps\n    for _ in range(n_sub):\n        for p in pair_probs:\n            p_sub = p / n_sub\n            if p_sub = 0.0:\n                continue\n            # Bernoulli trial\n            u = rng.random()\n            if u  p_sub:\n                total_events += 1\n    return int(total_events)\n\ndef solve():\n    # Define constants and particle set\n    # Common masses (kg)\n    m_val = 2.0e38\n    masses = np.array([m_val] * 8, dtype=float)\n    # Common smoothing length (m)\n    h = 1.5e20\n    # Positions (m)\n    positions = np.array([\n        [0.0, 0.0, 0.0],\n        [2.0e20, 0.0, 0.0],\n        [-1.0e20, 1.0e20, 0.0],\n        [0.0, -2.0e20, 1.0e20],\n        [3.0e20, 1.0e20, -1.0e20],\n        [-2.0e20, -2.0e20, 0.0],\n        [1.0e20, -1.0e20, 2.0e20],\n        [-1.0e19, 2.0e20, -1.0e20],\n    ], dtype=float)\n    # Baseline velocities (m/s)\n    velocities_baseline = np.array([\n        [1.0e5, 0.0, 0.0],\n        [-5.0e4, 2.0e4, 0.0],\n        [2.0e5, -1.0e5, 5.0e4],\n        [0.0, -8.0e4, 1.0e5],\n        [-1.0e5, 3.0e4, -2.0e4],\n        [5.0e4, -1.0e5, 0.0],\n        [0.0, 1.0e5, -1.0e5],\n        [1.0e4, -2.0e4, 3.0e4],\n    ], dtype=float)\n    # Zero velocities for Test Case 4\n    velocities_zero = np.zeros_like(velocities_baseline)\n\n    # Time constants\n    one_megayear_s = 3.154e13  # s\n    five_hundred_megayear_s = 1.577e16  # s\n\n    # Probability cap per substep\n    p_max = 0.1\n\n    # Define the test cases as tuples:\n    # (masses, positions, velocities, h, sigma_over_m, dt, p_max, seed)\n    test_cases = [\n        # Test Case 1: happy path\n        (masses, positions, velocities_baseline, h, 0.1, one_megayear_s, p_max, 42),\n        # Test Case 2: boundary, zero cross section\n        (masses, positions, velocities_baseline, h, 0.0, one_megayear_s, p_max, 42),\n        # Test Case 3: edge, large probabilities requiring substepping\n        (masses, positions, velocities_baseline, h, 1.0, five_hundred_megayear_s, p_max, 42),\n        # Test Case 4: edge, zero relative speeds\n        (masses, positions, velocities_zero, h, 0.1, one_megayear_s, p_max, 42),\n    ]\n\n    results = []\n    for case in test_cases:\n        masses_c, positions_c, velocities_c, h_c, sigma_over_m_c, dt_c, p_max_c, seed_c = case\n        count = scatter_count(\n            masses=masses_c,\n            positions=positions_c,\n            velocities=velocities_c,\n            h=h_c,\n            sigma_over_m=sigma_over_m_c,\n            dt=dt_c,\n            p_max=p_max_c,\n            seed=seed_c\n        )\n        results.append(count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "A simulation that runs without crashing is not necessarily a correct one. The final and most critical stage of numerical modeling is validation: ensuring that the results reflect the intended physics, not limitations of the algorithm. This capstone exercise  challenges you to design a controlled experiment to distinguish genuine physical core formation in SIDM from spurious numerical artifacts, a key skill for any computational astrophysicist seeking to make credible scientific claims.",
            "id": "3488375",
            "problem": "You are asked to design and implement a self-contained numerical experiment to calibrate the gravitational force-softening length $\\epsilon$ and the integrator time-step $\\Delta t$ in a minimal particle simulation, so that you can distinguish algorithmic core formation (a numerical artifact) from physical core formation due to Self-Interacting Dark Matter (SIDM). Cold Dark Matter (CDM) denotes collisionless dark matter. Self-Interacting Dark Matter (SIDM) denotes elastic, isotropic, short-range scattering between dark matter particles, modeled here through a probabilistic Monte Carlo collision operator. The goal is to identify the combinations of $\\epsilon$ and $\\Delta t$ for which CDM twins show no spurious core formation while SIDM twins show physical core formation, given fixed halo and interaction parameters.\n\nYour simulation must be built from the following fundamental base:\n- Newtonian gravity with spherical symmetry: the gravitational acceleration of a particle at radius $r$ due to the enclosed mass $M_{\\mathrm{enc}}(r)$ obeys $\\boldsymbol{a}(r) = -\\frac{G M_{\\mathrm{enc}}(r)}{(r^2 + \\epsilon^2)^{3/2}}\\boldsymbol{r}$, where $\\boldsymbol{r}$ is the position vector and $G$ is the gravitational constant.\n- Leapfrog integration (a symplectic method) for time evolution: update velocities by half-step kicks under gravity, then positions by a drift, then velocities by a second half-step kick.\n- A spherically symmetric equilibrium reference halo following the Hernquist density profile; draw initial particle positions from the cumulative mass $M(r) = M_{\\mathrm{tot}}\\frac{r^2}{(r + a)^2}$ truncated at a finite $r_{\\max}$, with $a$ the scale radius.\n- Circular-orbit initialization for tangential speeds at radius $r$ using softened circular speed $v_{\\mathrm{circ}}(r) = \\sqrt{\\frac{G M_{\\mathrm{enc}}(r) r}{r^2 + \\epsilon_{\\mathrm{phys}}^2}}$ with a fixed small physical softening $\\epsilon_{\\mathrm{phys}}$ for the initial condition only.\n- Self-interaction scattering implemented as elastic, isotropic two-body collisions between particles chosen probabilistically with rate $\\Gamma \\approx \\rho(\\sigma/m)v_{\\mathrm{rel}}$, where $\\rho$ is the local mass density, $\\sigma/m$ is the cross-section per unit mass, and $v_{\\mathrm{rel}}$ is a characteristic relative speed. Collisions conserve kinetic energy and momentum in the center-of-mass frame, and reorient the relative velocity vector isotropically.\n\nScientific and numerical realism constraints:\n- Adopt code units $G = 1$, $M_{\\mathrm{tot}} = 1$, and $a = 1$. Radii and times are dimensionless in these units. You must fix the random seed to ensure determinism.\n- Use $N$ equal-mass particles distributed from the Hernquist cumulative distribution truncated at $r_{\\max}$. For each particle, store full three-dimensional position $\\boldsymbol{x}$ and velocity $\\boldsymbol{v}$.\n- Compute $M_{\\mathrm{enc}}(r)$ at each time-step from the instantaneous particle radii by counting the number of particles with radius smaller than $r$ and multiplying by the particle mass. Use the softened central force as given above.\n- SIDM scattering must be implemented on spherical shells (radial bins) by:\n  1. Estimating local shell density $\\rho$ from particle counts and shell volume $\\frac{4\\pi}{3}(r_2^3 - r_1^3)$.\n  2. Estimating a characteristic speed per shell from the velocity dispersion.\n  3. For each particle, drawing a Bernoulli trial with probability $p = \\min\\left(p_{\\max}, \\rho(\\sigma/m)\\max\\left(v_{\\mathrm{disp}}, \\lVert\\boldsymbol{v}\\rVert\\right)\\Delta t \\right)$, and if successful, pairing it with a random partner in the same shell and performing an elastic, isotropic scattering in the center-of-mass frame.\n\nCalibration criteria in terms of core formation:\n- Define the core diagnostic radius $r_{\\mathrm{core}}$ and compute the central mass density $\\rho_{\\mathrm{c}}$ as the total mass within $r \\le r_{\\mathrm{core}}$ divided by the sphere volume $\\frac{4\\pi}{3}r_{\\mathrm{core}}^3$.\n- For each twin run (CDM and SIDM) from the same initial conditions, evolve to a fixed final time $T$ and compute the ratio $f \\equiv \\rho_{\\mathrm{c,final}}/\\rho_{\\mathrm{c,initial}}$.\n- A parameter pair $(\\epsilon, \\Delta t)$ passes the calibration if and only if all of the following are true:\n  1. The CDM twin maintains central density within tolerance: $f_{\\mathrm{CDM}} \\ge f_{\\min}$.\n  2. The SIDM twin shows physical core formation relative to CDM: $f_{\\mathrm{SIDM}} \\le f_{\\mathrm{phys}}$ and $f_{\\mathrm{SIDM}} \\le f_{\\mathrm{CDM}} - \\delta$.\n  3. The time-step respects a dynamical-time stability condition: $\\Delta t \\le \\alpha t_{\\mathrm{dyn}}$, with $t_{\\mathrm{dyn}} \\equiv \\sqrt{\\frac{r_{\\mathrm{core}}^3}{G M_{\\mathrm{enc}}(r_{\\mathrm{core}})}}$ evaluated from the initial state and $\\alpha$ a fixed stability factor much smaller than $1$.\n\nImplementation specifications:\n- Use $N = 800$, $r_{\\max} = 3$, $T = 1.5$, $\\epsilon_{\\mathrm{phys}} = 0.01$ (only for initial circular speed), number of radial bins $N_{\\mathrm{bins}} = 40$, and cross-section per unit mass $(\\sigma/m) = 2.0$ in code units. Use $p_{\\max} = 0.3$ to limit per-step collision probability.\n- Use $r_{\\mathrm{core}} = 0.1$, $f_{\\min} = 0.85$, $f_{\\mathrm{phys}} = 0.70$, $\\delta = 0.10$, and $\\alpha = 0.10$.\n- Random seed must be fixed at $42$.\n\nTest suite:\n- Evaluate the following four test cases (each is a pair $(\\epsilon, \\Delta t)$):\n  1. $(0.02, 0.002)$: a \"happy path\" candidate expected to pass.\n  2. $(0.20, 0.002)$: a large softening length expected to fail due to algorithmic core formation in CDM.\n  3. $(0.02, 0.020)$: a large time-step expected to fail due to violation of the dynamical-time stability condition.\n  4. $(0.05, 0.005)$: a moderately softened, moderately small time-step candidate expected to pass.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Each result must be a boolean (\"True\" or \"False\") indicating whether the corresponding $(\\epsilon, \\Delta t)$ pair passes the calibration according to the three criteria above. No other text should be printed.",
            "solution": "The user has provided a problem that requires the design and implementation of a numerical experiment in computational cosmology. The goal is to determine valid numerical parameters ($\\epsilon$, $\\Delta t$) for distinguishing physical core formation in Self-Interacting Dark Matter (SIDM) halos from numerical artifacts in Cold Dark Matter (CDM) halos.\n\n### Step 1: Extract Givens\n\nThe problem statement provides the following definitions, parameters, and conditions:\n\n**Physical Model:**\n- **Gravitational Acceleration:** The acceleration on a particle at position $\\boldsymbol{r}$ is given by $\\boldsymbol{a}(r) = -\\dfrac{G\\,M_{\\mathrm{enc}}(r)}{\\left(r^2 + \\epsilon^2\\right)^{3/2}}\\,\\boldsymbol{r}$, where $M_{\\mathrm{enc}}(r)$ is the mass enclosed within radius $r$.\n- **Time Integration:** Leapfrog (Kick-Drift-Kick) symplectic integrator.\n- **Initial Halo Model:** Spherically symmetric Hernquist profile with cumulative mass function $M(r) = M_{\\mathrm{tot}}\\dfrac{r^2}{\\left(r + a\\right)^2}$, truncated at $r_{\\max}$.\n- **Initial Velocities:** Circular orbits with speed $v_{\\mathrm{circ}}(r) = \\sqrt{\\dfrac{G\\,M_{\\mathrm{enc}}(r)\\\\,r}{r^2 + \\epsilon_{\\mathrm{phys}}^2}}$, using a small physical softening $\\epsilon_{\\mathrm{phys}}$.\n- **SIDM Model:** Elastic, isotropic two-body scattering implemented via a Monte Carlo method in radial shells. The collision rate is $\\Gamma \\approx \\rho\\,(\\sigma/m)\\,v_{\\mathrm{rel}}$. The per-particle collision probability in a time-step $\\Delta t$ is $p = \\min\\left(p_{\\max},\\, \\rho\\,(\\sigma/m)\\,\\max\\left(v_{\\mathrm{disp}}, \\lVert\\boldsymbol{v}\\rVert\\right)\\,\\Delta t \\right)$.\n\n**Numerical Parameters and Constants:**\n- **Code Units:** $G = 1$, $M_{\\mathrm{tot}} = 1$, $a = 1$.\n- **Random Seed:** $42$.\n- **Particle Count:** $N = 800$.\n- **Truncation Radius:** $r_{\\max} = 3$.\n- **Total Simulation Time:** $T = 1.5$.\n- **Initial Velocity Softening:** $\\epsilon_{\\mathrm{phys}} = 0.01$.\n- **SIDM Radial Bins:** $N_{\\mathrm{bins}} = 40$.\n- **Cross-Section per Unit Mass:** $(\\sigma/m) = 2.0$.\n- **Maximum Collision Probability:** $p_{\\max} = 0.3$.\n\n**Calibration Criteria and Thresholds:**\n- **Core Radius:** $r_{\\mathrm{core}} = 0.1$.\n- **Central Density Metric:** $f \\equiv \\rho_{\\mathrm{c,final}}/\\rho_{\\mathrm{c,initial}}$, where $\\rho_{\\mathrm{c}}$ is the mass density within $r_{\\mathrm{core}}$.\n- **Condition 1 (CDM Stability):** $f_{\\mathrm{CDM}} \\ge f_{\\min}$, with $f_{\\min} = 0.85$.\n- **Condition 2 (SIDM Core Formation):** $f_{\\mathrm{SIDM}} \\le f_{\\mathrm{phys}}$ and $f_{\\mathrm{SIDM}} \\le f_{\\mathrm{CDM}} - \\delta$, with $f_{\\mathrm{phys}} = 0.70$ and $\\delta = 0.10$.\n- **Condition 3 (Time-Step Stability):** $\\Delta t \\le \\alpha\\, t_{\\mathrm{dyn}}$, where $t_{\\mathrm{dyn}} \\equiv \\sqrt{\\dfrac{r_{\\mathrm{core}}^3}{G\\,M_{\\mathrm{enc}}(r_{\\mathrm{core}})}}$ is the initial dynamical time at the core radius, and $\\alpha = 0.10$.\nA parameter pair $(\\epsilon, \\Delta t)$ is deemed valid if and only if all three conditions are met.\n\n**Test Cases:**\n1. $(\\epsilon, \\Delta t) = (0.02, 0.002)$\n2. $(\\epsilon, \\Delta t) = (0.20, 0.002)$\n3. $(\\epsilon, \\Delta t) = (0.02, 0.020)$\n4. $(\\epsilon, \\Delta t) = (0.05, 0.005)$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to a rigorous validation check.\n\n-   **Scientific Grounding:** The problem is firmly rooted in standard practices of numerical cosmology. It deals with N-body simulations, gravitational dynamics, and widely accepted models for dark matter (CDM and SIDM). The use of a softened gravitational force, a leapfrog integrator, a Hernquist initial profile, and a Monte Carlo method for SIDM collisions are all standard techniques in the field. The calibration goal—distinguishing physical from numerical effects—is a critical aspect of validating such simulations. The problem is scientifically sound.\n-   **Well-Posedness:** The problem is specified with a comprehensive set of parameters, equations, and explicit criteria. Initial conditions are fully described, and the evolution algorithm is detailed. The mandatory use of a fixed random seed ensures that all stochastic elements (initial particle sampling, SIDM collisions) are deterministic, guaranteeing a unique solution for each test case.\n-   **Objectivity:** The problem is formulated using precise, quantitative, and unbiased language. All definitions and criteria are mathematical, removing any room for subjective interpretation.\n-   **Completeness and Consistency:** All necessary information to build and run the simulation is provided. There are no missing parameters or contradictory requirements. The use of a separate softening length $\\epsilon_{\\mathrm{phys}}$ for initial conditions versus the numerical softening $\\epsilon$ for the evolution is a standard and valid technique. The force law, while a simplification for a spherically symmetric system, is self-consistent and clearly defined.\n-   **Feasibility:** The simulation involves $N=800$ particles, which is a small-scale problem for modern computers. A single run with $T=1.5$ and $\\Delta t=0.002$ involves $750$ steps. The computational complexity per step is dominated by the sorting of particles for the enclosed mass calculation ($O(N \\log N)$), which is efficient. The entire test suite is computationally feasible within a short time frame.\n-   **Other Flaws:** The problem is not trivial, tautological, or pseudo-profound. It requires the implementation of a non-trivial physics simulation and addresses a genuine challenge in computational astrophysics. All aspects are scientifically verifiable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-posed, scientifically grounded, and feasible numerical experiment. I will now proceed with the solution.\n\n### Principle-Based Design of the Solution\n\nThe solution will be a self-contained Python program that implements the specified numerical experiment. The design is broken down into modular functions, each corresponding to a key physical or algorithmic component.\n\n1.  **Initial Conditions:** The `generate_initial_conditions` function sets up the particle distribution.\n    -   **Positions:** Particle radii $r$ are sampled by inverting the Hernquist cumulative mass function, $M(r) = M_{tot}\\frac{r^2}{(r+a)^2}$. A set of $N$ uniform random deviates $u \\in [0, M(r_{\\max})/M_{\\mathrm{tot}}]$ is generated, and the corresponding radii are found via the inverse transform $r = a\\frac{\\sqrt{u}}{1-\\sqrt{u}}$. These radii are combined with random isotropic direction vectors to create the $3\\mathrm{D}$ position vectors $\\boldsymbol{x}$.\n    -   **Velocities:** For each particle at radius $r$, a tangential velocity is assigned to approximate a circular orbit. The speed is calculated using the specified softened circular velocity formula, $v_{\\mathrm{circ}}(r) = \\sqrt{\\dfrac{G\\,M_{\\mathrm{enc}}(r)\\\\,r}{r^2 + \\epsilon_{\\mathrm{phys}}^2}}$, where $M_{\\mathrm{enc}}(r)$ is the analytic Hernquist enclosed mass. The velocity vector $\\boldsymbol{v}$ is constructed to be orthogonal to the position vector $\\boldsymbol{x}$.\n\n2.  **Gravitational Dynamics:**\n    -   **Acceleration:** The `get_acceleration` function computes the gravitational acceleration for all particles. As per the problem, the force is spherically symmetric. First, all particles are sorted by their radial distance from the origin. The enclosed mass $M_{\\mathrm{enc}}(r_i)$ for the $i$-th particle in the sorted list is simply $i$ times the mass of a single particle. The acceleration vector is then calculated using the provided formula $\\boldsymbol{a}(r) = -\\dfrac{G\\,M_{\\mathrm{enc}}(r)}{\\left(r^2 + \\epsilon^2\\right)^{3/2}}\\,\\boldsymbol{r}$.\n    -   **Time Integration:** A `run_simulation` function evolves the system forward in time. It employs the Velocity Verlet algorithm, a form of the Leapfrog integrator, as it cleanly separates kicks and drifts:\n        1.  $\\boldsymbol{v} \\leftarrow \\boldsymbol{v} + \\boldsymbol{a}(\\boldsymbol{x}) \\frac{\\Delta t}{2}$ (Half-step kick)\n        2.  $\\boldsymbol{x} \\leftarrow \\boldsymbol{x} + \\boldsymbol{v} \\Delta t$ (Full-step drift)\n        3.  (SIDM scattering is applied here if active)\n        4.  $\\boldsymbol{a}_{\\mathrm{new}} \\leftarrow \\boldsymbol{a}(\\boldsymbol{x}_{\\mathrm{new}})$\n        5.  $\\boldsymbol{v} \\leftarrow \\boldsymbol{v} + \\boldsymbol{a}_{\\mathrm{new}} \\frac{\\Delta t}{2}$ (Second half-step kick)\n\n3.  **Self-Interaction Model (SIDM):**\n    -   The `scatter` function implements the Monte Carlo collisions. It is called once per time-step, after the drift.\n    -   **Binning:** Particles are assigned to one of $N_{\\mathrm{bins}}$ spherical shells based on their radius.\n    -   **Collision Probability:** For each shell, the local mass density $\\rho$ and velocity dispersion $v_{\\mathrm{disp}}$ are calculated. Then, for each particle in that shell, a collision probability $p$ is computed.\n    -   **Pairing and Scattering:** All particles for which a random draw is less than their respective probability $p$ are marked as candidates for collision. These candidates within each shell are randomly shuffled and paired. For each pair, an elastic, isotropic collision is performed by transforming to the center-of-mass frame, re-orienting the relative velocity vector to a random direction while conserving its magnitude, and transforming back to the lab frame.\n\n4.  **Calibration and Analysis:**\n    -   The main `solve` function orchestrates the entire experiment. It first generates the single set of initial conditions that will be used for all runs, ensuring a fair comparison.\n    -   It pre-calculates the initial core density $\\rho_{\\mathrm{c,initial}}$ and the dynamical time $t_{\\mathrm{dyn}}$ for the stability check.\n    -   It then iterates through each $(\\epsilon, \\Delta t)$ test case. For each case, it performs the three required checks:\n        1.  The time-step stability condition is checked against the pre-calculated $t_{\\mathrm{dyn}}$.\n        2.  A CDM simulation (no scattering) is run to obtain $f_{\\mathrm{CDM}}$.\n        3.  An SIDM simulation (with scattering) is run from the same initial conditions to obtain $f_{\\mathrm{SIDM}}$.\n    -   The boolean outcomes of the three calibration criteria are combined with a logical AND to determine if the parameter pair passes. The final list of boolean results is printed in the required format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_initial_conditions(N, M_tot, a, r_max, eps_phys, G, seed):\n    \"\"\"Generates Hernquist halo initial conditions.\"\"\"\n    np.random.seed(seed)\n    m_p = M_tot / N\n\n    # Generate positions\n    u_max = r_max**2 / (r_max + a)**2\n    u_samples = np.random.uniform(0, u_max, N)\n    r_samples = a * np.sqrt(u_samples) / (1 - np.sqrt(u_samples))\n\n    # Isotropic directions\n    pos_dir = np.random.randn(N, 3)\n    pos_dir /= np.linalg.norm(pos_dir, axis=1)[:, np.newaxis]\n    pos = r_samples[:, np.newaxis] * pos_dir\n\n    # Generate velocities\n    # Analytic enclosed mass M(r) = M_tot * r^2 / (r+a)^2\n    m_enc_analytic = M_tot * r_samples**2 / (r_samples + a)**2\n    v_circ_mag = np.sqrt(G * m_enc_analytic * r_samples / (r_samples**2 + eps_phys**2))\n\n    # Velocity vectors perpendicular to position vectors\n    rand_vecs = np.random.randn(N, 3)\n    # Ensure they're not parallel to position vectors\n    cross_prods = np.cross(pos, rand_vecs)\n    cross_prod_norms = np.linalg.norm(cross_prods, axis=1)\n    \n    # In case any random vector is parallel, re-generate it\n    for i in np.where(cross_prod_norms == 0)[0]:\n        while True:\n            new_rand_vec = np.random.randn(3)\n            new_cross_prod = np.cross(pos[i], new_rand_vec)\n            if np.linalg.norm(new_cross_prod)  0:\n                cross_prods[i] = new_cross_prod\n                break\n    \n    vel_dir = cross_prods / np.linalg.norm(cross_prods, axis=1)[:, np.newaxis]\n    vel = v_circ_mag[:, np.newaxis] * vel_dir\n    \n    return pos, vel\n\ndef get_acceleration(pos, N, m_p, G, eps):\n    \"\"\"Calculates gravitational acceleration based on enclosed mass.\"\"\"\n    radii = np.linalg.norm(pos, axis=1)\n    \n    # Sort particles by radius to compute enclosed mass\n    sort_indices = np.argsort(radii)\n    unsort_indices = np.argsort(sort_indices)\n    \n    # Enclosed mass for particle i (in sorted list) is i * m_p\n    m_enc_sorted = (np.arange(N)) * m_p\n    \n    sorted_radii = radii[sort_indices]\n    \n    # Prevent division by zero at the center\n    # The force is zero at r=0 anyway because M_enc=0\n    safe_radii = sorted_radii**2 + eps**2\n    \n    # Force formula: F = - G * M_enc * r_vec / (r^2 + eps^2)^(3/2)\n    # Accel = F/m. Problem statement seems to assume M_enc is total mass inside,\n    # and force is applied to each particle.\n    accel_factor_sorted = -G * m_enc_sorted / (safe_radii**1.5)\n    \n    sorted_pos = pos[sort_indices]\n    # accel factor must be applied to pos vector components\n    accel_sorted = sorted_pos * accel_factor_sorted[:, np.newaxis]\n    \n    accel = accel_sorted[unsort_indices]\n    return accel\n\ndef scatter(pos, vel, N, m_p, sigma_m, dt, r_max, n_bins, p_max):\n    \"\"\"Performs SIDM scattering on half-step velocities.\"\"\"\n    radii = np.linalg.norm(pos, axis=1)\n    vel_norms = np.linalg.norm(vel, axis=1)\n    \n    bins = np.linspace(0, r_max, n_bins + 1)\n    bin_indices = np.digitize(radii, bins)\n    \n    vel_out = vel.copy()\n\n    unique_bins = np.unique(bin_indices)\n    \n    for bin_k in unique_bins:\n        if bin_k == 0 or bin_k  n_bins: continue # Out of bounds\n        \n        in_bin_mask = (bin_indices == bin_k)\n        particles_in_bin_indices = np.where(in_bin_mask)[0]\n        \n        n_in_bin = len(particles_in_bin_indices)\n        if n_in_bin  2: continue\n\n        r_lower, r_upper = bins[bin_k-1], bins[bin_k]\n        shell_volume = (4.0/3.0) * np.pi * (r_upper**3 - r_lower**3)\n        density = (n_in_bin * m_p) / shell_volume\n        \n        vel_in_bin = vel[in_bin_mask]\n        vel_dispersion = np.sqrt(np.mean(np.sum(vel_in_bin**2, axis=1)))\n\n        # Calculate collision probability for each particle in the bin\n        max_vel_metric = np.maximum(vel_dispersion, vel_norms[in_bin_mask])\n        prob = density * sigma_m * max_vel_metric * dt\n        prob = np.minimum(prob, p_max)\n        \n        # Select candidates for collision\n        rand_draws = np.random.rand(n_in_bin)\n        collision_candidates = particles_in_bin_indices[rand_draws  prob]\n        \n        # Pair them up\n        np.random.shuffle(collision_candidates)\n        num_pairs = len(collision_candidates) // 2\n\n        for i in range(num_pairs):\n            idx1 = collision_candidates[2*i]\n            idx2 = collision_candidates[2*i+1]\n            \n            v1 = vel_out[idx1]\n            v2 = vel_out[idx2]\n\n            v_cm = 0.5 * (v1 + v2)\n            v_rel = v1 - v2\n            v_rel_mag = np.linalg.norm(v_rel)\n\n            # Isotropic scattering: new random direction for v_rel\n            new_dir = np.random.randn(3)\n            new_dir /= np.linalg.norm(new_dir)\n            \n            v_rel_new = v_rel_mag * new_dir\n            \n            vel_out[idx1] = v_cm + 0.5 * v_rel_new\n            vel_out[idx2] = v_cm - 0.5 * v_rel_new\n            \n    return vel_out\n\ndef calculate_rho_c(pos, m_p, r_core):\n    \"\"\"Calculates central density within r_core.\"\"\"\n    radii = np.linalg.norm(pos, axis=1)\n    mass_in_core = np.sum(radii = r_core) * m_p\n    volume_core = (4.0/3.0) * np.pi * r_core**3\n    if volume_core == 0: return 0.0\n    return mass_in_core / volume_core\n\ndef run_simulation(pos0, vel0, N, m_p, G, eps, dt, T, is_sidm, sigma_m, r_max, n_bins, p_max):\n    \"\"\"Runs a full N-body simulation.\"\"\"\n    pos = pos0.copy()\n    vel = vel0.copy()\n    \n    n_steps = int(round(T/dt))\n    \n    accel = get_acceleration(pos, N, m_p, G, eps)\n\n    for _ in range(n_steps):\n        vel_half = vel + accel * dt / 2.0\n        pos += vel_half * dt\n        \n        if is_sidm:\n            vel_half = scatter(pos, vel_half, N, m_p, sigma_m, dt, r_max, n_bins, p_max)\n        \n        accel = get_acceleration(pos, N, m_p, G, eps)\n        vel = vel_half + accel * dt / 2.0\n        \n    return pos\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.02, 0.002),\n        (0.20, 0.002),\n        (0.02, 0.020),\n        (0.05, 0.005),\n    ]\n\n    # Global constants\n    N = 800\n    M_tot = 1.0\n    a = 1.0\n    r_max = 3.0\n    T = 1.5\n    eps_phys = 0.01\n    n_bins = 40\n    sigma_m = 2.0\n    p_max = 0.3\n    G = 1.0\n    r_core = 0.1\n    f_min = 0.85\n    f_phys = 0.70\n    delta = 0.10\n    alpha = 0.10\n    seed = 42\n\n    m_p = M_tot / N\n\n    # Generate ICs once for all runs\n    pos0, vel0 = generate_initial_conditions(N, M_tot, a, r_max, eps_phys, G, seed)\n    \n    # Calculate initial values for criteria\n    rho_c_initial = calculate_rho_c(pos0, m_p, r_core)\n\n    m_enc_initial_rcore = np.sum(np.linalg.norm(pos0, axis=1) = r_core) * m_p\n    \n    if m_enc_initial_rcore  0:\n        t_dyn_initial = np.sqrt(r_core**3 / (G * m_enc_initial_rcore))\n    else:\n        t_dyn_initial = np.inf\n\n    results = []\n    for eps, dt in test_cases:\n        # Criterion 3: Time-step stability\n        cond3 = (dt = alpha * t_dyn_initial)\n\n        # Run CDM simulation\n        pos_final_cdm = run_simulation(pos0, vel0, N, m_p, G, eps, dt, T, False, sigma_m, r_max, n_bins, p_max)\n        rho_c_final_cdm = calculate_rho_c(pos_final_cdm, m_p, r_core)\n        f_cdm = rho_c_final_cdm / rho_c_initial if rho_c_initial  0 else 0\n        \n        # Criterion 1: CDM stability\n        cond1 = (f_cdm = f_min)\n        \n        # Run SIDM simulation\n        pos_final_sidm = run_simulation(pos0, vel0, N, m_p, G, eps, dt, T, True, sigma_m, r_max, n_bins, p_max)\n        rho_c_final_sidm = calculate_rho_c(pos_final_sidm, m_p, r_core)\n        f_sidm = rho_c_final_sidm / rho_c_initial if rho_c_initial  0 else 0\n\n        # Criterion 2: SIDM core formation\n        cond2 = (f_sidm = f_phys) and (f_sidm = f_cdm - delta)\n        \n        results.append(cond1 and cond2 and cond3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}