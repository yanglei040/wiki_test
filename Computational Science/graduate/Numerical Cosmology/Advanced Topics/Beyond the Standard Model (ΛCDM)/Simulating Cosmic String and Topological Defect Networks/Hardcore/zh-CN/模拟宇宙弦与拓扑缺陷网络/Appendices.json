{
    "hands_on_practices": [
        {
            "introduction": "在为任何显式时间演化方案编写代码之前，理解其稳定性约束至关重要。此练习引导您通过冯·诺依曼稳定性分析，为阿贝尔-希格斯模型在三维晶格上的模拟推导基本的Courant–Friedrichs–Lewy (CFL) 条件。掌握此条件是确保数值模拟不会因不稳定的误差增长而发散的第一步，也是设置稳定且高效模拟参数的基础 ()。",
            "id": "3487032",
            "problem": "在宇宙弦和拓扑缺陷网络的数值宇宙学模拟中，阿贝尔-希格斯模型使用显式时间积分在三维立方网格上进行演化。考虑在线性化场动力学的自然单位制中的主要（双曲）部分，其中相对论信号速度等于 $c=1$。在时间规范下，为了分析离散化的传播和稳定性，标量（希格斯）场或空间规范分量的微小涨落都由一个形如 $u_{tt} = \\nabla^{2} u$ 的线性类波动方程所控制。该演化采用时间上交错的蛙跳格式实现：在所有三个空间方向上间距为 $\\Delta x$ 的均匀立方网格上，场 $u$ 存储在整数时间层 $t^{n} = n\\,\\Delta t$ 上，而其共轭动量（或速度）存储在半整数时间层 $t^{n+1/2} = \\left(n+\\frac{1}{2}\\right)\\Delta t$ 上。空间算子通过二阶中心有限差分拉普拉斯算子进行离散化\n$$\n\\nabla^{2}_{d} u_{i,j,k} = \\frac{u_{i+1,j,k} - 2 u_{i,j,k} + u_{i-1,j,k}}{\\Delta x^{2}} + \\frac{u_{i,j+1,k} - 2 u_{i,j,k} + u_{i,j-1,k}}{\\Delta x^{2}} + \\frac{u_{i,j,k+1} - 2 u_{i,j,k} + u_{i,j,k-1}}{\\Delta x^{2}} \\, ,\n$$\n并且当仅用 $u$ 表示时，时间更新具有标准的二阶中心形式\n$$\nu^{n+1}_{i,j,k} - 2\\,u^{n}_{i,j,k} + u^{n-1}_{i,j,k} = \\Delta t^{2}\\,\\nabla^{2}_{d} u^{n}_{i,j,k} \\, .\n$$\n使用应用于上述三维空间离散格式的 von Neumann（傅里叶）稳定性分析，在 $c=1$ 的假设下，导出以比率 $\\sigma \\equiv \\Delta t / \\Delta x$ 表示的 Courant–Friedrichs–Lewy (CFL) 条件。取确保所有网格傅里叶模式稳定性的最严格界限。然后，假设安全因子 $s = \\frac{1}{2}$ 以减轻缺陷核心和高曲率区域附近的数值病态，请提供：\n1) 该三维格式的 CFL 条件所蕴含的容许比率 $\\Delta t / \\Delta x$ 的精确上确界，以及\n2) 相应的保守安全选择 $s \\times (\\Delta t / \\Delta x)_{\\text{max}}$。\n将这两者均报告为精确的解析表达式。无需四舍五入，且这些量是无量纲的。你的最终答案必须以不带单位的精确表达式给出。",
            "solution": "该问题要求推导应用于三维线性波动方程 $u_{tt} = \\nabla^{2} u$ 的二阶有限差分格式的 Courant–Friedrichs–Lewy (CFL) 稳定性条件。指定的方法是 von Neumann（或傅里叶）稳定性分析。\n\n离散格式由下式给出：\n$$\n\\frac{u^{n+1}_{i,j,k} - 2\\,u^{n}_{i,j,k} + u^{n-1}_{i,j,k}}{\\Delta t^{2}} = \\nabla^{2}_{d} u^{n}_{i,j,k}\n$$\n其中 $\\Delta t$ 是时间步长， $u^{n}_{i,j,k}$ 表示场 $u$ 在时间 $t^n = n\\,\\Delta t$ 和空间网格点 $(i\\,\\Delta x, j\\,\\Delta x, k\\,\\Delta x)$ 处的值。离散拉普拉斯算子 $\\nabla^{2}_{d}$ 定义为：\n$$\n\\nabla^{2}_{d} u_{i,j,k} = \\frac{u_{i+1,j,k} - 2 u_{i,j,k} + u_{i-1,j,k}}{\\Delta x^{2}} + \\frac{u_{i,j+1,k} - 2 u_{i,j,k} + u_{i,j-1,k}}{\\Delta x^{2}} + \\frac{u_{i,j,k+1} - 2 u_{i,j,k} + u_{i,j,k-1}}{\\Delta x^{2}}\n$$\n在 von Neumann 分析中，我们考察单个傅里叶模式在网格上的行为。我们提出一个形式如下的解：\n$$\nu^{n}_{i,j,k} = G^{n}(\\vec{k}) \\exp\\left[i(k_x i \\Delta x + k_y j \\Delta x + k_z k \\Delta x)\\right]\n$$\n其中 $\\vec{k} = (k_x, k_y, k_z)$ 是模式的波矢，$i$ 是虚数单位，而 $G(\\vec{k})$ 是每个时间步的放大因子。为使格式稳定，放大因子的模必须对所有可能的波矢 $\\vec{k}$ 满足 $|G(\\vec{k})| \\le 1$。\n\n首先，我们将离散拉普拉斯算子 $\\nabla^{2}_{d}$ 应用于该傅里叶模式。考虑 $x$ 方向的项：\n\\begin{align*}\n\\frac{u^{n}_{i+1,j,k} - 2 u^{n}_{i,j,k} + u^{n}_{i-1,j,k}}{\\Delta x^{2}} = \\frac{G^n}{\\Delta x^2} \\left( \\exp[i(k_x(i+1)\\Delta x + \\dots)] - 2\\exp[i(k_x i\\Delta x + \\dots)] + \\exp[i(k_x(i-1)\\Delta x + \\dots)] \\right) \\\\\n= \\frac{u^{n}_{i,j,k}}{\\Delta x^2} \\left( \\exp[i k_x \\Delta x] - 2 + \\exp[-i k_x \\Delta x] \\right) \\\\\n= \\frac{u^{n}_{i,j,k}}{\\Delta x^2} \\left( 2 \\cos(k_x \\Delta x) - 2 \\right) \\\\\n= -\\frac{2 u^{n}_{i,j,k}}{\\Delta x^2} \\left( 1 - \\cos(k_x \\Delta x) \\right)\n\\end{align*}\n使用半角恒等式 $1 - \\cos(\\theta) = 2 \\sin^2(\\theta/2)$，上式变为：\n$$\n-\\frac{4 u^{n}_{i,j,k}}{\\Delta x^2} \\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right)\n$$\n将此应用于所有三个空间方向，完整的离散拉普拉斯算子作用于傅里叶模式的结果是：\n$$\n\\nabla^{2}_{d} u^{n}_{i,j,k} = -\\frac{4 u^{n}_{i,j,k}}{\\Delta x^2} \\left[ \\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_z \\Delta x}{2}\\right) \\right]\n$$\n现在，我们将傅里叶模式的拟设代入完全离散化的波动方程：\n$$\n\\frac{G^{n+1} - 2G^n + G^{n-1}}{G^n} \\frac{u^{n}_{i,j,k}}{\\Delta t^2} = \\frac{\\nabla^{2}_{d} u^{n}_{i,j,k}}{u^{n}_{i,j,k}} u^{n}_{i,j,k}\n$$\n两边同除以 $u^{n}_{i,j,k}$ 并乘以 $\\Delta t^2$ 和 $G^n$，我们得到：\n$$\nG^{n+1} - 2G^n + G^{n-1} = \\Delta t^2 \\left( -\\frac{4 G^n}{\\Delta x^2} \\left[ \\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_z \\Delta x}{2}\\right) \\right] \\right)\n$$\n两边同除以 $G^{n-1}$ 得到放大因子 $G$ 的特征方程：\n$$\nG^2 - 2G + 1 = -4 G \\frac{\\Delta t^2}{\\Delta x^2} \\left[ \\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_z \\Delta x}{2}\\right) \\right]\n$$\n令 $\\sigma = \\Delta t / \\Delta x$ 为 Courant 数，并定义项 $S_k$：\n$$\nS_k = \\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_z \\Delta x}{2}\\right)\n$$\n该特征方程是关于 $G$ 的二次方程：\n$$\nG^2 - 2(1 - 2\\sigma^2 S_k)G + 1 = 0\n$$\n其根由 $G = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$ 给出：\n$$\nG = (1 - 2\\sigma^2 S_k) \\pm \\sqrt{(1 - 2\\sigma^2 S_k)^2 - 1}\n$$\n为了保证稳定性，我们要求 $|G| \\le 1$。如果判别式为正，即 $(1 - 2\\sigma^2 S_k)^2 > 1$，则根为实数，且其中一个根的模将大于 $1$，导致不稳定。因此，为了稳定性，判别式必须为非正数：\n$$\n(1 - 2\\sigma^2 S_k)^2 - 1 \\le 0 \\implies (1 - 2\\sigma^2 S_k)^2 \\le 1\n$$\n这等价于：\n$$\n-1 \\le 1 - 2\\sigma^2 S_k \\le 1\n$$\n右侧不等式 $1 - 2\\sigma^2 S_k \\le 1$ 意味着 $-2\\sigma^2 S_k \\le 0$，因为 $\\sigma^2 \\ge 0$ 且 $S_k \\ge 0$，所以此式恒成立。\n左侧不等式给出了稳定性条件：\n$$\n-1 \\le 1 - 2\\sigma^2 S_k \\implies 2\\sigma^2 S_k \\le 2 \\implies \\sigma^2 S_k \\le 1\n$$\n当此条件成立时，根是形如 $G = A \\pm i B$ 的共轭复数，其模的平方为 $|G|^2 = A^2+B^2 = (1 - 2\\sigma^2 S_k)^2 + (1-(1 - 2\\sigma^2 S_k)^2) = 1$。因此 $|G|=1$，这对应于一个稳定的、非耗散的格式。\n\n为确保对所有可能的模式都稳定，此条件必须对 $S_k$ 的最大可能值成立。网格波矢 $k_x, k_y, k_z$ 定义在第一布里渊区内，通常为 $-\\frac{\\pi}{\\Delta x} \\le k_{x,y,z} \\le \\frac{\\pi}{\\Delta x}$。因此，平方正弦函数的自变量，例如 $\\frac{k_x \\Delta x}{2}$，其范围为 $-\\frac{\\pi}{2}$ 到 $\\frac{\\pi}{2}$。函数 $\\sin^2(\\theta)$ 在 $\\theta = \\pm \\frac{\\pi}{2}$ 时取得最大值，其值为 $1$。$S_k$ 的最大值在每一项都取最大值时达到，这对应于最高频率的“棋盘”模式（例如，$k_x = k_y = k_z = \\pi/\\Delta x$）：\n$$\nS_{k, \\text{max}} = \\sin^2\\left(\\frac{\\pi}{2}\\right) + \\sin^2\\left(\\frac{\\pi}{2}\\right) + \\sin^2\\left(\\frac{\\pi}{2}\\right) = 1 + 1 + 1 = 3\n$$\n将此最大值代入稳定性条件，得到对 $\\sigma$ 最严格的约束：\n$$\n\\sigma^2 S_{k, \\text{max}} \\le 1 \\implies 3\\sigma^2 \\le 1 \\implies \\sigma^2 \\le \\frac{1}{3}\n$$\n由于 $\\sigma = \\Delta t/\\Delta x \\ge 0$，我们有：\n$$\n\\sigma \\le \\frac{1}{\\sqrt{3}}\n$$\n这就是该格式在三维空间中的 CFL 条件。\n\n1) 容许比率 $\\Delta t / \\Delta x$ 的精确上确界是此不等式允许的最大值：\n$$\n\\left(\\frac{\\Delta t}{\\Delta x}\\right)_{\\text{max}} = \\frac{1}{\\sqrt{3}}\n$$\n2) 保守的安全选择通过将此上确界乘以给定的安全因子 $s = \\frac{1}{2}$ 来计算：\n$$\ns \\times \\left(\\frac{\\Delta t}{\\Delta x}\\right)_{\\text{max}} = \\frac{1}{2} \\times \\frac{1}{\\sqrt{3}} = \\frac{1}{2\\sqrt{3}}\n$$\n如要求，两个量都是无量纲的。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{\\sqrt{3}} & \\frac{1}{2\\sqrt{3}} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "编写数值代码后，我们必须验证其输出的正确性，这是计算科学中的一个核心实践。本练习将指导您实现一个收敛性测试，通过将一个简单的蛙跳格式（leapfrog scheme）的数值解与已知的解析解进行比较，来衡量代码的精度阶。完成此练习将使您掌握验证代码实现是否与其理论设计相符的关键技能 ()。",
            "id": "3486951",
            "problem": "设计并实现一个自洽的数值收敛性测试，用于在共形规范下 Nambu–Goto 系统中的直线行进弦解，使用一维线性波动方程作为简化的世界面动力学。目标是通过测量相对于解析行波解的观测收敛率，来验证标准显式二阶有限差分格式的形式精度阶。所有角度必须以弧度为单位进行解释，所有量均为无量纲。\n\n从以下已建立的基础开始。张力为 $\\mu$ 的弦的 Nambu–Goto 作用量由 $S = -\\mu \\int d^{2}\\xi \\, \\sqrt{-\\gamma}$ 给出，其中 $\\gamma$ 是诱导世界面度规的行列式。在共形规范中，直弦的横向自由度满足线性波动方程\n$$\n\\partial_{tt} x(\\sigma, t) - \\partial_{\\sigma \\sigma} x(\\sigma, t) = 0,\n$$\n其中波以单位速度传播。在周期性定义域 $\\sigma \\in [0, 2\\pi)$ 上的一个右行模的精确解为\n$$\nx(\\sigma, t) = A \\sin\\!\\big(k(\\sigma - t)\\big),\n$$\n其中 $A$ 为振幅，$k$ 为整数波数。在 $t=0$ 时的初始条件是 $x(\\sigma, 0) = A \\sin(k \\sigma)$ 和 $\\partial_t x(\\sigma, 0) = -A k \\cos(k \\sigma)$。\n\n实现以下数值方法和收敛性评估：\n- 用 $N$ 个均匀点离散化空间域，网格间距为 $\\Delta \\sigma = 2\\pi/N$，并采用周期性边界条件。\n- 使用 Courant–Friedrichs–Lewy (CFL) 数 $\\mathcal{C} = \\Delta t/\\Delta \\sigma$（其中 $\\mathcal{C} \\le 1$），并设置 $\\Delta t = \\mathcal{C} \\Delta \\sigma$。\n- 在时间上使用空间二阶中心有限差分和波动方程的显式蛙跳格式进行演化：\n  - 使用运动方程 $\\partial_{tt} x = \\partial_{\\sigma \\sigma} x$ 通过二阶精确的泰勒展开构建第一个时间层：\n    $$\n    x^{1} = x^{0} + \\Delta t \\, v^{0} + \\tfrac{1}{2}\\Delta t^{2} \\, \\partial_{\\sigma \\sigma} x^{0},\n    $$\n    其中 $x^{0}$ 是初始场，$v^{0} = \\partial_t x(\\sigma,0)$。\n  - 对于后续步骤，使用\n    $$\n    x^{n+1}_i = 2 x^{n}_i - x^{n-1}_i + \\mathcal{C}^{2} \\left(x^{n}_{i+1} - 2 x^{n}_i + x^{n}_{i-1}\\right),\n    $$\n    其中索引采用周期性处理。\n- 演化到最终时间 $T$。如果 $T / \\Delta t$ 不是整数，则取整数步数 $n_{\\mathrm{steps}} = \\mathrm{round}(T/\\Delta t)$，并在 $t_{\\mathrm{final}} = n_{\\mathrm{steps}} \\Delta t$ 与解析解进行比较。\n- 在最终时间测量相对 $\\ell^{2}$ 误差，\n  $$\n  E(N) = \\frac{\\left(\\sum_{i=0}^{N-1} \\left[x^{\\mathrm{num}}(\\sigma_i,t_{\\mathrm{final}}) - x^{\\mathrm{exact}}(\\sigma_i,t_{\\mathrm{final}})\\right]^{2} \\Delta \\sigma \\right)^{1/2}}{\\left(\\sum_{i=0}^{N-1} \\left[x^{\\mathrm{exact}}(\\sigma_i,t_{\\mathrm{final}})\\right]^{2} \\Delta \\sigma \\right)^{1/2}},\n  $$\n  其中 $\\sigma_i = i \\, \\Delta \\sigma$。\n- 对于一组固定的 $\\mathcal{C}$ 和三个分辨率 $N, 2N, 4N$，通过以下公式估算观测精度阶：\n  $$\n  p_{12} = \\frac{\\log\\!\\big(E(N)/E(2N)\\big)}{\\log(2)}, \\quad\n  p_{23} = \\frac{\\log\\!\\big(E(2N)/E(4N)\\big)}{\\log(2)}, \\quad\n  p = \\tfrac{1}{2}\\left(p_{12} + p_{23}\\right).\n  $$\n\n实现一个程序，执行上述过程，并为以下测试套件返回测得的精度阶 $p$。每个测试用例指定一组三个分辨率和参数 $(\\mathcal{C}, A, k, T)$：\n- 测试用例 1（理想情况）：$N \\in \\{64, 128, 256\\}$，$\\mathcal{C} = 0.90$，$A = 0.10$，$k = 3$，$T = 1.00$。\n- 测试用例 2（短波长边界情况）：$N \\in \\{128, 256, 512\\}$，$\\mathcal{C} = 0.90$，$A = 0.10$，$k = 16$，$T = 1.00$。\n- 测试用例 3（接近 CFL 边界情况）：$N \\in \\{32, 64, 128\\}$，$\\mathcal{C} = 0.99$，$A = 0.10$，$k = 3$，$T = 1.00$。\n\n你的程序必须：\n- 为每个测试用例计算如上定义的观测阶 $p$。\n- 生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的三个结果列表，例如 $[p_{1},p_{2},p_{3}]$。每个值必须是十进制表示的浮点数。\n\n角度必须以弧度为单位。所有输出都是无单位的实数。最终的数值输出必须是浮点数。程序不得要求任何用户输入或外部文件。",
            "solution": "该问题是适定的，代表了数值分析应用于计算物理学的一个标准练习。它要求对一维线性波动方程的二阶有限差分格式进行收敛性测试，该方程在共形规范下作为 Nambu-Goto 形式主义中直宇宙弦动力学的模型。\n\n控制横向位移 $x(\\sigma, t)$ 的偏微分方程 (PDE) 是线性波动方程：\n$$\n\\frac{\\partial^2 x}{\\partial t^2} - \\frac{\\partial^2 x}{\\partial \\sigma^2} = 0\n$$\n该域在空间坐标 $\\sigma$ 上是周期性的，其中 $\\sigma \\in [0, 2\\pi)$。问题指定了一个精确的行波解，一个振幅为 $A$、整数波数为 $k$ 的右行模：\n$$\nx_{\\mathrm{exact}}(\\sigma, t) = A \\sin(k(\\sigma - t))\n$$\n由此，我们导出时间 $t=0$ 时的初始条件：\n$$\nx(\\sigma, 0) = x^0(\\sigma) = A \\sin(k \\sigma)\n$$\n$$\n\\frac{\\partial x}{\\partial t}(\\sigma, 0) = v^0(\\sigma) = -A k \\cos(k \\sigma)\n$$\n\n为了数值求解该系统，我们离散化时空域。空间域 $[0, 2\\pi)$ 被离散化为 $N$ 个均匀网格点 $\\sigma_i = i \\Delta \\sigma$（$i=0, 1, \\dots, N-1$），其中网格间距为 $\\Delta \\sigma = 2\\pi/N$。时间以 $\\Delta t$ 为步长进行离散化，使得 $t^n = n \\Delta t$。时间步长通过 Courant–Friedrichs–Lewy (CFL) 数 $\\mathcal{C} = \\Delta t / \\Delta \\sigma$ 与空间步长相关联。为保证显式格式的稳定性，我们要求 $\\mathcal{C} \\le 1$。在网格点 $(\\sigma_i, t^n)$ 处的数值解记为 $x_i^n$。\n\n指定的数值方法是显式二阶蛙跳格式。二阶偏导数使用中心有限差分进行近似：\n$$\n\\frac{\\partial^2 x}{\\partial t^2}\\bigg|_i^n \\approx \\frac{x_i^{n+1} - 2x_i^n + x_i^{n-1}}{(\\Delta t)^2}\n$$\n$$\n\\frac{\\partial^2 x}{\\partial \\sigma^2}\\bigg|_i^n \\approx \\frac{x_{i+1}^n - 2x_i^n + x_{i-1}^n}{(\\Delta \\sigma)^2}\n$$\n将这些代入波动方程并对 $x_i^{n+1}$ 进行整理，得到 $n \\ge 1$ 的更新规则：\n$$\nx_i^{n+1} = 2x_i^n - x_i^{n-1} + \\left(\\frac{\\Delta t}{\\Delta \\sigma}\\right)^2 (x_{i+1}^n - 2x_i^n + x_{i-1}^n)\n$$\n$$\nx_i^{n+1} = 2x_i^n - x_i^{n-1} + \\mathcal{C}^2 (x_{i+1}^n - 2x_i^n + x_{i-1}^n)\n$$\n索引 $i+1$ 和 $i-1$ 按周期性处理，例如 $x_{N}^n = x_0^n$ 和 $x_{-1}^n = x_{N-1}^n$。\n\n该格式是一个三层方法，需要前两个时间步（$n$ 和 $n-1$）的数据来计算下一个时间步（$n+1$）。这给第一个时间步带来了问题，因为我们只有 $t=0$（第 $n=0$ 层）的初始数据。我们必须使用另一种至少是二阶精度的方法来构建 $t^1 = \\Delta t$ 时的解，以保持格式的整体精度。使用围绕 $t=0$ 的时间二阶泰勒展开：\n$$\nx(\\sigma, \\Delta t) \\approx x(\\sigma, 0) + \\Delta t \\frac{\\partial x}{\\partial t}(\\sigma, 0) + \\frac{(\\Delta t)^2}{2} \\frac{\\partial^2 x}{\\partial t^2}(\\sigma, 0)\n$$\n利用运动方程本身 $\\partial_{tt}x = \\partial_{\\sigma\\sigma}x$，我们可以用空间导数替换时间导数：\n$$\nx_i^1 \\approx x_i^0 + \\Delta t \\, v_i^0 + \\frac{(\\Delta t)^2}{2} \\frac{\\partial^2 x}{\\partial \\sigma^2}\\bigg|_i^0\n$$\n离散化空间导数得到第一个时间步的公式：\n$$\nx_i^1 = x_i^0 + \\Delta t \\, v_i^0 + \\frac{(\\Delta t)^2}{2} \\left( \\frac{x_{i+1}^0 - 2x_i^0 + x_{i-1}^0}{(\\Delta \\sigma)^2} \\right) = x_i^0 + \\Delta t \\, v_i^0 + \\frac{\\mathcal{C}^2}{2} (x_{i+1}^0 - 2x_i^0 + x_{i-1}^0)\n$$\n模拟过程为：设置 $x^0$ 和 $v^0$，使用上述公式计算 $x^1$，然后对主蛙跳更新规则进行所需步数 $n_{\\mathrm{steps}} = \\mathrm{round}(T/\\Delta t)$ 的迭代。\n\n为了评估精度，我们将最终的数值解 $x^{\\mathrm{num}}(\\sigma_i, t_{\\mathrm{final}})$ 与精确解 $x^{\\mathrm{exact}}(\\sigma_i, t_{\\mathrm{final}})$ 在最终时间 $t_{\\mathrm{final}} = n_{\\mathrm{steps}} \\Delta t$ 进行比较。误差由离散相对 $\\ell^2$ 范数来量化：\n$$\nE(N) = \\frac{\\|\\boldsymbol{x}^{\\mathrm{num}} - \\boldsymbol{x}^{\\mathrm{exact}}\\|_{\\ell^2}}{\\|\\boldsymbol{x}^{\\mathrm{exact}}\\|_{\\ell^2}} = \\frac{\\left(\\sum_{i=0}^{N-1} (x_i^{\\mathrm{num}} - x_i^{\\mathrm{exact}})^2 \\Delta \\sigma \\right)^{1/2}}{\\left(\\sum_{i=0}^{N-1} (x_i^{\\mathrm{exact}})^2 \\Delta \\sigma \\right)^{1/2}}\n$$\n对于一个 $p$ 阶数值方法，误差预计会随网格间距按 $E \\propto (\\Delta \\sigma)^p$ 的规律缩放。由于 $\\Delta \\sigma \\propto 1/N$，我们有 $E(N) \\propto N^{-p}$。如果我们以两种分辨率 $N_1$ 和 $N_2$ 运行模拟，其误差之比为：\n$$\n\\frac{E(N_1)}{E(N_2)} \\approx \\frac{C N_1^{-p}}{C N_2^{-p}} = \\left(\\frac{N_2}{N_1}\\right)^p\n$$\n求解 $p$ 可得 $p \\approx \\log(E(N_1)/E(N_2))/\\log(N_2/N_1)$。对于 $N_2 = 2N_1$ 的特殊情况，这简化为：\n$$\np \\approx \\frac{\\log(E(N)/E(2N))}{\\log(2)}\n$$\n问题要求为两对分辨率 $(N, 2N)$ 和 $(2N, 4N)$ 计算这个量，然后对结果进行平均，以获得对观测精度阶 $p$ 的更稳健的估计。由于有限差分格式在空间和时间上都是二阶的，我们期望观测到的阶数 $p$ 接近于 $2$。\n\n该实现将包含一个主函数，对于每个测试用例，该函数将组织在分辨率 $N, 2N$ 和 $4N$ 下的三次数值模拟。它将收集相应的误差 $E(N)$、$E(2N)$ 和 $E(4N)$，然后计算最终的平均精度阶 $p$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, C, A, k, T):\n    \"\"\"\n    Performs a single simulation of the 1D wave equation and returns the relative l2 error.\n\n    Args:\n        N (int): Number of spatial grid points.\n        C (float): Courant-Friedrichs-Lewy (CFL) number.\n        A (float): Amplitude of the initial wave.\n        k (int): Wavenumber of the initial wave.\n        T (float): Target final time.\n\n    Returns:\n        float: The relative l2 error at the final time.\n    \"\"\"\n    # 1. Setup Grid and Parameters\n    ds = 2.0 * np.pi / N\n    dt = C * ds\n    \n    # Calculate number of steps and the final time\n    n_steps = int(round(T / dt))\n    t_final = n_steps * dt\n\n    sigma = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n    # 2. Initial Conditions\n    x0 = A * np.sin(k * sigma)\n    v0 = -A * k * np.cos(k * sigma)\n\n    # 3. First Time Step (using Taylor expansion)\n    # The term d2x/ds2 is approximated with a centered finite difference.\n    # np.roll is used for periodic boundary conditions.\n    d2x_ds2_0 = (np.roll(x0, -1) - 2 * x0 + np.roll(x0, 1)) / (ds**2)\n    x1 = x0 + dt * v0 + 0.5 * dt**2 * d2x_ds2_0\n\n    # 4. Time Evolution (Leapfrog)\n    x_prev = x0\n    x_curr = x1\n    C_squared = C**2\n    for _ in range(1, n_steps):\n        # The stencil for the second spatial derivative\n        laplacian_curr = np.roll(x_curr, -1) - 2 * x_curr + np.roll(x_curr, 1)\n        \n        # Leapfrog update rule\n        x_next = 2 * x_curr - x_prev + C_squared * laplacian_curr\n        \n        # Update for next iteration\n        x_prev = x_curr\n        x_curr = x_next\n    \n    # x_curr is now the numerical solution at t_final\n    x_num = x_curr\n\n    # 5. Error Calculation\n    x_exact = A * np.sin(k * (sigma - t_final))\n\n    # Calculate numerator of the relative l2 error\n    error_norm = np.sqrt(np.sum((x_num - x_exact)**2 * ds))\n    \n    # Calculate denominator of the relative l2 error\n    exact_norm = np.sqrt(np.sum(x_exact**2 * ds))\n\n    # Avoid division by zero if the exact solution is zero everywhere\n    if exact_norm == 0.0:\n        return 0.0 if error_norm == 0.0 else np.inf\n\n    return error_norm / exact_norm\n\ndef calculate_convergence_order(N_tuple, C, A, k, T):\n    \"\"\"\n    Calculates the observed order of accuracy for a given set of parameters.\n\n    Args:\n        N_tuple (tuple): A triplet of resolutions (N, 2N, 4N).\n        C (float): CFL number.\n        A (float): Amplitude.\n        k (int): Wavenumber.\n        T (float): Final time.\n\n    Returns:\n        float: The averaged observed order of accuracy p.\n    \"\"\"\n    N1, N2, N3 = N_tuple\n\n    # Run simulations for the three resolutions\n    E1 = run_simulation(N1, C, A, k, T)\n    E2 = run_simulation(N2, C, A, k, T)\n    E3 = run_simulation(N3, C, A, k, T)\n\n    # Prevent log(0) or division by zero errors\n    if E1 == 0 or E2 == 0 or E3 == 0:\n        return np.nan\n\n    # Calculate convergence orders\n    p12 = np.log(E1 / E2) / np.log(2)\n    p23 = np.log(E2 / E3) / np.log(2)\n\n    # Average the two estimates\n    p_avg = 0.5 * (p12 + p23)\n    \n    return p_avg\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # ((Resolutions), (C, A, k, T))\n        ((64, 128, 256), (0.90, 0.10, 3, 1.00)),   # Test case 1\n        ((128, 256, 512), (0.90, 0.10, 16, 1.00)),  # Test case 2\n        ((32, 64, 128), (0.99, 0.10, 3, 1.00)),    # Test case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        N_tuple, params = case\n        C, A, k, T = params\n        \n        # Main logic to calculate the result for one case goes here.\n        p = calculate_convergence_order(N_tuple, C, A, k, T)\n        results.append(p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在验证了基本数值方案后，我们可以着手解决更完整的物理模型。本练习将带您进入南部-后藤（Nambu-Goto）弦的有效模型，这是一个在研究宇宙弦网络动力学时广泛使用的框架。您将学习如何使用左右行波矢量（mover fields）$\\mathbf{a}'$ 和 $\\mathbf{b}'$ 来简化波动方程并巧妙地处理规范约束，这是现代弦模拟中的一种强大技术 ()。",
            "id": "3487046",
            "problem": "考虑一个在平坦闵可夫斯基时空中，由共形时间规范下的 Nambu–Goto (NG) 作用量描述的相对论性弦，其中世界面坐标被选择为使得时间坐标等于实验室时间。在此规范下，弦的空间嵌入是函数 $\\mathbf{x}(\\sigma,t) \\in \\mathbb{R}^3$，其中 $\\sigma$ 是沿弦的周期性坐标。正交归一规范约束为\n$$\n\\dot{\\mathbf{x}}(\\sigma,t)\\cdot \\mathbf{x}'(\\sigma,t)=0,\\quad \\|\\dot{\\mathbf{x}}(\\sigma,t)\\|^2+\\|\\mathbf{x}'(\\sigma,t)\\|^2=1,\n$$\n其中上标点和撇号分别表示对 $t$ 和 $\\sigma$ 的偏导数。在这些单位制中，光速 $c=1$，所有量均为无量纲。\n\n在这些条件下，NG 运动方程简化为 $\\mathbf{x}(\\sigma,t)$ 的线性波动方程，\n$$\n\\frac{\\partial^2 \\mathbf{x}}{\\partial t^2}-\\frac{\\partial^2 \\mathbf{x}}{\\partial \\sigma^2}=0,\n$$\n并辅以上述规范约束。为方便起见，定义左行和右行单位矢量场\n$$\n\\mathbf{a}'(\\sigma,t)=\\mathbf{x}'(\\sigma,t)-\\dot{\\mathbf{x}}(\\sigma,t),\\qquad \\mathbf{b}'(\\sigma,t)=\\mathbf{x}'(\\sigma,t)+\\dot{\\mathbf{x}}(\\sigma,t),\n$$\n它们满足平流方程\n$$\n\\partial_t \\mathbf{a}'+\\partial_\\sigma \\mathbf{a}'=0,\\qquad \\partial_t \\mathbf{b}'-\\partial_\\sigma \\mathbf{b}'=0,\n$$\n以及单位范数条件 $\\|\\mathbf{a}'\\|=\\|\\mathbf{b}'\\|=1$。由此，可以恢复\n$$\n\\mathbf{x}'=\\frac{1}{2}(\\mathbf{a}'+\\mathbf{b}'),\\qquad \\dot{\\mathbf{x}}=\\frac{1}{2}(\\mathbf{b}'-\\mathbf{a}').\n$$\n\n任务。构建一个完备的、二阶精度的时域有限差分格式，该格式在 $\\sigma$ 的周期性一维网格上使用一致的时间步长推进离散场 $\\mathbf{a}'$ 和 $\\mathbf{b}'$，使得：\n- 更新在空间和时间上均为二阶精度，\n- 通过设计，在每个网格点上，正交归一规范约束都保持在舍入误差范围内，\n- 通过适当选择 Courant–Friedrichs–Lewy (CFL) 数，使弦上波的数值色散最小化。\n\n为实现此目标，请实施以下设计，每一步都从第一性原理出发进行论证：\n1. 对 $\\mathbf{a}'$ 和 $\\mathbf{b}'$ 使用精确的平流形式，分别对波速为 $+1$ 和 $-1$ 的线性平流采用二阶格式。设 $\\Delta \\sigma$ 为网格间距，$\\Delta t$ 为时间步长，Courant 数为 $\\lambda=\\Delta t/\\Delta \\sigma$。该格式必须在 $|\\lambda|\\le 1$ 时稳定，并在 $\\lambda=1$ 时简化为精确平移（因此非色散）。\n2. 在每次更新后，于每个网格点上将单位范数条件 $\\|\\mathbf{a}'\\|=\\|\\mathbf{b}'\\|=1$ 强制到机器精度，从而保持 $\\mathbf{x}'$ 和 $\\dot{\\mathbf{x}}$ 的正交归一规范约束。\n3. 通过 $\\mathbf{x}'=(\\mathbf{a}'+\\mathbf{b}')/2$ 和 $\\dot{\\mathbf{x}}=(\\mathbf{b}'-\\mathbf{a}')/2$ 从 $\\mathbf{a}'$ 和 $\\mathbf{b}'$ 恢复 $\\mathbf{x}'$ 和 $\\dot{\\mathbf{x}}$。使用二阶精度的时间积分器（例如梯形法则），在 $\\sigma$ 的周期性边界条件下，从 $\\dot{\\mathbf{x}}$ 更新 $\\mathbf{x}$。\n4. 在 $\\mathbf{a}'$ 和 $\\mathbf{b}'$ 上使用单个傅里叶模式初始化一个周期性弦，使其在 $t=0$ 时精确满足约束条件：\n   $$\n   \\mathbf{a}'(\\sigma,0)=\\big(\\cos(m\\sigma),\\ \\sin(m\\sigma),\\ 0\\big),\\qquad\n   \\mathbf{b}'(\\sigma,0)=\\big(\\cos(m\\sigma),\\ -\\sin(m\\sigma),\\ 0\\big),\n   $$\n   其中 $m$ 为整数波数，域长度 $L=2\\pi$，$\\sigma\\in[0,L)$ 被均匀离散化。\n5. 通过在周期性边界条件和零均值位置下沿 $\\sigma$ 积分 $\\mathbf{x}'(\\sigma,0)$ 来构建初始的 $\\mathbf{x}(\\sigma,0)$。\n\n你的程序必须运行三个具有不同参数 $(N,m,\\lambda,\\text{steps})$ 的独立测试用例，其中 $N$ 是网格点数，$\\text{steps}$ 是时间步数。对于每个测试用例，模拟直到时间 $T=\\text{steps}\\times \\Delta t$，并计算以下四个诊断指标：\n- $E_{\\text{orth}}=\\max_i |\\dot{\\mathbf{x}}_i\\cdot \\mathbf{x}'_i|$，\n- $E_{\\text{norm}}=\\max_i \\big|\\|\\dot{\\mathbf{x}}_i\\|^2+\\|\\mathbf{x}'_i\\|^2-1\\big|$，\n- $E_{\\text{phase}}=\\big|\\Delta \\phi_{\\text{num}}-(-mT)\\big|$，其中 $\\Delta \\phi_{\\text{num}}$ 是在 $t=0$ 和 $t=T$ 之间测得的 $\\mathbf{a}'$ 的 y 分量的第 $m$ 个傅里叶模式的相移；以弧度报告相位，\n- $E_{\\text{closure}}=\\left\\|\\sum_i \\mathbf{x}'_i\\,\\Delta \\sigma\\right\\|$，在最终时刻离散环的周期性闭合误差。\n\n所有四个诊断指标必须作为浮点数返回。为最小化弦上波的数值色散，请确保你的一个测试用例使用 $\\lambda=1$。\n\n测试套件。使用以下三个测试用例：\n- 用例 A (理想路径，非色散)：$N=128$，$m=3$，$\\lambda=1$，$\\text{steps}=64$。\n- 用例 B (亚 Courant 条件，色散)：$N=128$，$m=5$，$\\lambda=0.8$，$\\text{steps}=40$。\n- 用例 C (粗网格，精确平移)：$N=16$，$m=2$，$\\lambda=1$，$\\text{steps}=16$。\n\n对于每个用例，设置 $L=2\\pi$，$\\Delta \\sigma=L/N$，$\\Delta t=\\lambda \\Delta \\sigma$，并使用周期性边界条件。角度必须以弧度为单位。除上述无量纲选择外，没有其他物理单位。\n\n最终输出格式。你的程序应生成单行输出，其中包含按以下顺序排列的 12 个浮点数结果：\n$$\n[E_{\\text{orth}}^{(A)},E_{\\text{norm}}^{(A)},E_{\\text{phase}}^{(A)},E_{\\text{closure}}^{(A)},E_{\\text{orth}}^{(B)},E_{\\text{norm}}^{(B)},E_{\\text{phase}}^{(B)},E_{\\text{closure}}^{(B)},E_{\\text{orth}}^{(C)},E_{\\text{norm}}^{(C)},E_{\\text{phase}}^{(C)},E_{\\text{closure}}^{(C)}],\n$$\n四舍五入到合理的有效位数，并以逗号分隔列表的形式打印，括在方括号中，符合示例模式 $[r_1,r_2,\\ldots,r_{12}]$。",
            "solution": "用户的请求是一个适定的数值物理问题，要求在共形规范下实现相对论性 Nambu-Goto 弦的时域有限差分 (FDTD) 模拟。该问题在科学上是合理的，包含了所有必要信息，并指定了一套明确的任务和交付成果。因此，该问题是**有效的**。\n\n解决方案涉及构建一个数值格式，该格式基于给定的方程和初始条件，随时间演化弦的构型。问题的核心在于两个辅助矢量场——左行场 $\\mathbf{a}'(\\sigma,t)$ 和右行场 $\\mathbf{b}'(\\sigma,t)$——的演化，它们将底层物理简化为一对平流方程。\n\n以下是所需算法的逐步设计，遵循问题陈述中概述的原则。\n\n### 1. 二阶平流格式\n\n弦的演化由右行场 $\\mathbf{a}'$ 和左行场 $\\mathbf{b}'$ 的平流控制。它们的控制方程是：\n$$\n\\frac{\\partial \\mathbf{a}'}{\\partial t} + \\frac{\\partial \\mathbf{a}'}{\\partial \\sigma} = 0 \\quad (\\text{波速 } c=+1)\n$$\n$$\n\\frac{\\partial \\mathbf{b}'}{\\partial t} - \\frac{\\partial \\mathbf{b}'}{\\partial \\sigma} = 0 \\quad (\\text{波速 } c=-1)\n$$\n这些是形式为 $\\partial_t \\mathbf{u} + c \\partial_\\sigma \\mathbf{u} = 0$ 的线性平流方程。我们需要一个在时间 ($\\Delta t$) 和空间 ($\\Delta \\sigma$) 上均为二阶精度，并且在 Courant 数 $\\lambda = \\Delta t/\\Delta \\sigma = 1$ 时变为精确解的数值格式。Lax-Wendroff 格式满足这些标准。\n\n为推导该格式，我们将 $\\mathbf{u}(\\sigma, t+\\Delta t)$ 进行二阶泰勒展开：\n$$\n\\mathbf{u}(\\sigma, t+\\Delta t) \\approx \\mathbf{u}(\\sigma, t) + \\Delta t \\frac{\\partial \\mathbf{u}}{\\partial t} + \\frac{(\\Delta t)^2}{2} \\frac{\\partial^2 \\mathbf{u}}{\\partial t^2}\n$$\n使用平流方程，我们可以用空间导数表示时间导数：\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} = -c \\frac{\\partial \\mathbf{u}}{\\partial \\sigma}\n$$\n$$\n\\frac{\\partial^2 \\mathbf{u}}{\\partial t^2} = \\frac{\\partial}{\\partial t}\\left(-c \\frac{\\partial \\mathbf{u}}{\\partial \\sigma}\\right) = -c \\frac{\\partial}{\\partial \\sigma}\\left(\\frac{\\partial \\mathbf{u}}{\\partial t}\\right) = -c \\frac{\\partial}{\\partial \\sigma}\\left(-c \\frac{\\partial \\mathbf{u}}{\\partial \\sigma}\\right) = c^2 \\frac{\\partial^2 \\mathbf{u}}{\\partial \\sigma^2}\n$$\n将这些代入泰勒展开式得到：\n$$\n\\mathbf{u}(\\sigma, t+\\Delta t) \\approx \\mathbf{u}(\\sigma, t) - c\\Delta t \\frac{\\partial \\mathbf{u}}{\\partial \\sigma} + \\frac{c^2(\\Delta t)^2}{2} \\frac{\\partial^2 \\mathbf{u}}{\\partial \\sigma^2}\n$$\n我们使用二阶中心差分来离散化空间导数。对于网格函数 $\\mathbf{u}_i^n \\approx \\mathbf{u}(i\\Delta\\sigma, n\\Delta t)$：\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial \\sigma} \\approx \\frac{\\mathbf{u}_{i+1}^n - \\mathbf{u}_{i-1}^n}{2\\Delta\\sigma}\n$$\n$$\n\\frac{\\partial^2 \\mathbf{u}}{\\partial \\sigma^2} \\approx \\frac{\\mathbf{u}_{i+1}^n - 2\\mathbf{u}_i^n + \\mathbf{u}_{i-1}^n}{(\\Delta \\sigma)^2}\n$$\n令 $\\nu = c\\lambda = c\\Delta t/\\Delta\\sigma$，更新规则变为：\n$$\n\\mathbf{u}_i^{n+1} = \\mathbf{u}_i^n - \\frac{\\nu}{2}(\\mathbf{u}_{i+1}^n - \\mathbf{u}_{i-1}^n) + \\frac{\\nu^2}{2}(\\mathbf{u}_{i+1}^n - 2\\mathbf{u}_i^n + \\mathbf{u}_{i-1}^n)\n$$\n对于周期性边界条件，索引 $i\\pm1$ 使用模运算处理，这可以通过 `numpy.roll` 高效实现。\n- 对 $\\mathbf{a}'$，$c=+1$，所以我们使用 $\\nu = \\lambda$。\n- 对 $\\mathbf{b}'$，$c=-1$，所以我们使用 $\\nu = -\\lambda$。\n\n当 $\\lambda=1$ 时，对于 $\\mathbf{a}'$ ($\\nu=1$)，格式简化为 $\\mathbf{u}_i^{n+1} = \\mathbf{u}_{i-1}^n$，即向右精确平移。对于 $\\mathbf{b}'$ ($\\nu=-1$)，它简化为 $\\mathbf{u}_i^{n+1} = \\mathbf{u}_{i+1}^n$，即向左精确平移。在 CFL 极限下的这种非色散特性是一个关键要求。\n\n### 2. 保持规范约束\n\n正交归一规范约束为：\n$$\n\\dot{\\mathbf{x}}\\cdot \\mathbf{x}'=0, \\qquad \\|\\dot{\\mathbf{x}}\\|^2+\\|\\mathbf{x}'\\|^2=1\n$$\n用移动场表示，这些约束等价于确保 $\\|\\mathbf{a}'\\|=1$ 和 $\\|\\mathbf{b}'\\|=1$。\n$$\n\\dot{\\mathbf{x}}\\cdot \\mathbf{x}' = \\frac{1}{4}(\\mathbf{b}'-\\mathbf{a}')\\cdot(\\mathbf{a}'+\\mathbf{b}') = \\frac{1}{4}(\\|\\mathbf{b}'\\|^2 - \\|\\mathbf{a}'\\|^2)\n$$\n$$\n\\|\\dot{\\mathbf{x}}\\|^2+\\|\\mathbf{x}'\\|^2 = \\frac{1}{4}\\|\\mathbf{b}'-\\mathbf{a}'\\|^2 + \\frac{1}{4}\\|\\mathbf{a}'+\\mathbf{b}'\\|^2 = \\frac{1}{2}(\\|\\mathbf{a}'\\|^2 + \\|\\mathbf{b}'\\|^2)\n$$\nLax-Wendroff 格式本身不保持矢量的范数。因此，在每次对 $\\mathbf{a}'$ 和 $\\mathbf{b}'$ 进行时间步更新后，我们必须在每个网格点 $i$ 显式地将它们重新归一化：\n$$\n(\\mathbf{a}'_i)_{\\text{renormalized}} = \\frac{\\mathbf{a}'_i}{\\|\\mathbf{a}'_i\\|}, \\qquad (\\mathbf{b}'_i)_{\\text{renormalized}} = \\frac{\\mathbf{b}'_i}{\\|\\mathbf{b}'_i\\|}\n$$\n这个过程将单位范数条件强制到机器精度，从而通过设计确保规范约束得到满足。\n\n### 3. 恢复并积分弦位置 $\\mathbf{x}$\n\n在每个时间步 $n+1$，演化并重新归一化 $\\mathbf{a}'^{n+1}$ 和 $\\mathbf{b}'^{n+1}$ 后，我们恢复弦的切向量和速度向量：\n$$\n\\mathbf{x}'^{n+1} = \\frac{1}{2}(\\mathbf{a}'^{n+1} + \\mathbf{b}'^{n+1}), \\qquad \\dot{\\mathbf{x}}^{n+1} = \\frac{1}{2}(\\mathbf{b}'^{n+1} - \\mathbf{a}'^{n+1})\n$$\n要更新弦的位置 $\\mathbf{x}$，我们必须对 $\\dot{\\mathbf{x}}$ 进行时间积分。问题建议使用梯形法则，这是一种二阶精度的方法：\n$$\n\\mathbf{x}^{n+1} = \\mathbf{x}^n + \\frac{\\Delta t}{2}(\\dot{\\mathbf{x}}^n + \\dot{\\mathbf{x}}^{n+1})\n$$\n这需要存储前一个时间步的速度向量 $\\dot{\\mathbf{x}}^n$。\n\n### 4. 移动场的初始条件\n\n初始条件在离散网格 $\\sigma_i = i\\Delta\\sigma$（其中 $i \\in \\{0, \\dots, N-1\\}$ 且 $\\Delta\\sigma = L/N = 2\\pi/N$）上指定：\n$$\n\\mathbf{a}'_i(t=0) = (\\cos(m\\sigma_i), \\sin(m\\sigma_i), 0)\n$$\n$$\n\\mathbf{b}'_i(t=0) = (\\cos(m\\sigma_i), -\\sin(m\\sigma_i), 0)\n$$\n其中 $m$ 是一个整数波数。这些初始场已经满足单位范数条件，因为对所有 $i$ 都有 $\\|\\mathbf{a}'_i(0)\\|=\\|\\mathbf{b}'_i(0)\\|=1$。\n\n### 5. 初始弦位置 $\\mathbf{x}(\\sigma,0)$\n\n为了找到初始位置 $\\mathbf{x}(\\sigma,0)$，我们必须在周期性和零均值约束下对初始切向量 $\\mathbf{x}'(\\sigma,0)$ 进行积分。\n首先，我们找到 $\\mathbf{x}'(\\sigma,0)$：\n$$\n\\mathbf{x}'(\\sigma,0) = \\frac{1}{2}(\\mathbf{a}'(\\sigma,0) + \\mathbf{b}'(\\sigma,0)) = (\\cos(m\\sigma), 0, 0)\n$$\n对 $\\mathbf{x}'(\\sigma,0)$ 关于 $\\sigma$ 进行积分以获得 $\\mathbf{x}(\\sigma,0)$，最好在傅里叶空间中进行，这样可以自然地处理周期性边界条件和零均值约束。过程如下：\n1.  计算离散场 $\\mathbf{x}'_i(0)$ 的离散傅里叶变换 (DFT)。\n2.  在傅里叶空间中，积分对应于除以 $ik_{\\text{eff}}$，其中 $k_{\\text{eff}}$ 是每个模式的有效波数。$k=0$（直流）模式代表均值，被设为零以满足零均值约束。\n3.  对结果进行逆离散傅里叶变换 (IDFT)，以获得实空间中的 $\\mathbf{x}_i(0)$。\n这将得到解析解 $\\mathbf{x}(\\sigma_i,0) = (\\frac{1}{m}\\sin(m\\sigma_i), 0, 0)$（在离散化误差范围内），满足所有要求。\n\n### 诊断指标\n\n模拟运行指定的步数后，计算四个诊断量：\n- $E_{\\text{orth}}$ 和 $E_{\\text{norm}}$ 衡量规范约束的保持情况。由于显式的重新归一化步骤，这些误差应接近机器精度。\n- $E_{\\text{closure}}$ 衡量弦环未能闭合的程度，对于一致的数值积分，这个值应该很小。它计算为环上所有切向量之和的范数：$\\|\\sum_i \\mathbf{x}'_i \\Delta\\sigma\\|$。\n- $E_{\\text{phase}}$ 衡量数值色散。$\\mathbf{a}'_y$ 的第 $m$ 个模式在时间 $T$ 内的解析相移是 $-mT$。我们通过在每个时间步累积第 $m$ 个傅里叶模式的相位变化来测量数值相移 $\\Delta\\phi_{\\text{num}}$。这避免了相位缠绕问题。误差则为 $|\\Delta\\phi_{\\text{num}} - (-mT)|$。对于 $\\lambda=1$ 的非色散情况，此误差应接近于零。\n\n这个综合设计提供了一种稳健且精确的方法来解决所提出的问题。",
            "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef run_simulation(N, m, lambda_cfl, steps):\n    \"\"\"\n    Runs a single simulation of a relativistic string.\n\n    Args:\n        N (int): Number of grid points.\n        m (int): Wavenumber for the initial condition.\n        lambda_cfl (float): Courant number (dt/ds).\n        steps (int): Number of time steps to simulate.\n\n    Returns:\n        tuple: A tuple containing the four diagnostic metrics:\n               (E_orth, E_norm, E_phase, E_closure).\n    \"\"\"\n    # 1. Setup grid and parameters\n    L = 2.0 * np.pi\n    delta_sigma = L / N\n    delta_t = lambda_cfl * delta_sigma\n    T = steps * delta_t\n    sigma_grid = np.linspace(0, L, N, endpoint=False)\n\n    # 2. Initial conditions\n    # Initialize a' and b' (mover fields)\n    a_prime = np.zeros((N, 3))\n    b_prime = np.zeros((N, 3))\n    a_prime[:, 0] = np.cos(m * sigma_grid)\n    a_prime[:, 1] = np.sin(m * sigma_grid)\n    b_prime[:, 0] = np.cos(m * sigma_grid)\n    b_prime[:, 1] = -np.sin(m * sigma_grid)\n\n    # Initialize x' and x_dot from a' and b'\n    x_prime = 0.5 * (a_prime + b_prime)\n    x_dot = 0.5 * (b_prime - a_prime)\n\n    # Initialize x by integrating x' in Fourier space\n    # This correctly handles periodic BCs and zero-mean constraint\n    k_freq = fft.fftfreq(N, d=delta_sigma)\n    k_wavenum = 2 * np.pi * k_freq\n    \n    x_prime_fft = fft.fft(x_prime, axis=0)\n    x_fft = np.zeros_like(x_prime_fft, dtype=np.complex128)\n    \n    # Integrate by dividing by i*k, handling k=0 separately\n    nonzero_k_mask = k_wavenum != 0\n    # Add new axis to broadcast k_wavenum over the 3 vector components\n    k_broadcast = k_wavenum[nonzero_k_mask, np.newaxis]\n    x_fft[nonzero_k_mask] = x_prime_fft[nonzero_k_mask] / (1j * k_broadcast)\n    \n    x = fft.ifft(x_fft, axis=0).real\n\n    # 3. Phase calculation setup\n    total_phase_shift = 0.0\n    # Get the m-th Fourier component of the y-component of a_prime\n    ay_fft_m_old = fft.fft(a_prime[:, 1])[m]\n\n    # 4. Time evolution loop\n    for _ in range(steps):\n        # Store previous state for trapezoidal rule\n        x_dot_old = x_dot\n\n        # Evolve a' (c=+1) using Lax-Wendroff\n        nu_a = lambda_cfl\n        a_prime_rolled_p1 = np.roll(a_prime, -1, axis=0) # i+1\n        a_prime_rolled_m1 = np.roll(a_prime, 1, axis=0)  # i-1\n        a_prime_new = (a_prime \n                       - 0.5 * nu_a * (a_prime_rolled_p1 - a_prime_rolled_m1)\n                       + 0.5 * nu_a**2 * (a_prime_rolled_p1 - 2 * a_prime + a_prime_rolled_m1))\n\n        # Evolve b' (c=-1) using Lax-Wendroff\n        nu_b = -lambda_cfl\n        b_prime_rolled_p1 = np.roll(b_prime, -1, axis=0) # i+1\n        b_prime_rolled_m1 = np.roll(b_prime, 1, axis=0)  # i-1\n        b_prime_new = (b_prime\n                       - 0.5 * nu_b * (b_prime_rolled_p1 - b_prime_rolled_m1)\n                       + 0.5 * nu_b**2 * (b_prime_rolled_p1 - 2 * b_prime + b_prime_rolled_m1))\n        \n        # Enforce unit-norm constraint by re-normalizing\n        norm_a = np.linalg.norm(a_prime_new, axis=1, keepdims=True)\n        a_prime = a_prime_new / norm_a\n        norm_b = np.linalg.norm(b_prime_new, axis=1, keepdims=True)\n        b_prime = b_prime_new / norm_b\n\n        # Update physical fields x' and x_dot\n        x_prime = 0.5 * (a_prime + b_prime)\n        x_dot = 0.5 * (b_prime - a_prime)\n\n        # Update position x using trapezoidal rule\n        x = x + 0.5 * delta_t * (x_dot_old + x_dot)\n        \n        # Accumulate phase shift for diagnostic\n        ay_fft_m_new = fft.fft(a_prime[:, 1])[m]\n        # Calculate phase increment from one step to the next\n        phase_increment = np.angle(ay_fft_m_new * np.conj(ay_fft_m_old))\n        total_phase_shift += phase_increment\n        ay_fft_m_old = ay_fft_m_new\n\n    # 5. Compute final diagnostics\n    # Orthogonality error\n    E_orth = np.max(np.abs(np.sum(x_dot * x_prime, axis=1)))\n\n    # Normalization error\n    norm_sq_sum = np.sum(x_dot**2, axis=1) + np.sum(x_prime**2, axis=1)\n    E_norm = np.max(np.abs(norm_sq_sum - 1.0))\n\n    # Phase error\n    analytical_phase_shift = -m * T\n    E_phase = np.abs(total_phase_shift - analytical_phase_shift)\n\n    # Closure error\n    closure_vector = np.sum(x_prime, axis=0) * delta_sigma\n    E_closure = np.linalg.norm(closure_vector)\n\n    return E_orth, E_norm, E_phase, E_closure\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path, non-dispersive)\n        (128, 3, 1.0, 64),\n        # Case B (sub-Courant, dispersive)\n        (128, 5, 0.8, 40),\n        # Case C (coarse grid, exact shift)\n        (16, 2, 1.0, 16),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        N, m, lambda_cfl, steps = case_params\n        case_results = run_simulation(N, m, lambda_cfl, steps)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    # The format string ensures a reasonable number of digits are displayed.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}