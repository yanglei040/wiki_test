{
    "hands_on_practices": [
        {
            "introduction": "Fisher矩阵的计算依赖于理论模型（或可观测向量 $\\boldsymbol{\\mu}$）对其参数 $\\boldsymbol{\\theta}$ 的精确导数。本练习旨在通过数值方法（特别是中心差分法）来解决这一基础问题。通过从第一性原理推导截断误差和舍入误差之间的权衡，你将学习如何选择最佳步长，这是确保Fisher预报结果可靠性的关键一步。",
            "id": "3472421",
            "problem": "你的任务是构建一个独立的数值工作流，用于计算宇宙学可观测量向量的参数导数，以用于费雪信息矩阵预测。目标是从第一性原理出发，设计一种中心差分策略来估计参数梯度，量化主要的截断误差和舍入误差，并为有限差分选择一个能平衡这些误差的最优步长。\n\n定义可观测量向量 $\\boldsymbol{\\mu}(\\boldsymbol{\\theta}) \\in \\mathbb{R}^m$，其参数为 $\\boldsymbol{\\theta} = (\\theta_1,\\theta_2)$ 如下。对于一组固定的波数 $\\{k_j\\}_{j=1}^m$（单位为 $h/\\mathrm{Mpc}$），固定的物质密度参数 $\\Omega_m = 0.315$，以及固定的哈勃参数 $h=0.674$，令\n$$\n\\mu_j(\\boldsymbol{\\theta}) = \\exp(\\theta_1)\\left(\\frac{k_j}{k_0}\\right)^{\\theta_2} T^2(k_j;\\Omega_m,h), \\quad j=1,\\dots,m,\n$$\n其中 $k_0 = 0.05\\,h/\\mathrm{Mpc}$ 且 $T(k;\\Omega_m,h)$ 是 Bardeen-Bond-Kaiser-Szalay (BBKS) 传递函数，表示为 $q = k/\\Gamma$ 的函数，其中 $\\Gamma = \\Omega_m h$，定义为\n$$\nT(q) = \\frac{\\ln(1 + 2.34\\,q)}{2.34\\,q} \\left[1 + 3.89\\,q + (16.1\\,q)^2 + (5.46\\,q)^3 + (6.71\\,q)^4\\right]^{-1/4}.\n$$\n你应将 $\\boldsymbol{\\mu}(\\boldsymbol{\\theta})$ 视为 $m$ 个箱 (bin) 中功率谱振幅的预测向量，并将计算其参数梯度分量 $\\partial_i \\boldsymbol{\\mu}$，以用于费雪信息预测。\n\n从数值分析和浮点运算的核心概念出发，且不引入任何快捷公式，你必须从第一性原理推导出：\n- 对 $\\boldsymbol{\\mu}$ 的每个分量关于 $\\theta_i$ 的方向导数的中心差分估计量，使用大小为 $h_i$ 的对称步长。\n- 此导数估计中主要截断误差和主要舍入误差的渐近模型，该模型通过泰勒展开和标准浮点误差模型得到。你必须表达这些误差贡献如何作为 $h_i$ 和目标函数适当导数的函数进行缩放。\n- 为每个参数方向选择一个平衡截断误差和舍入误差的有原则的最优步长 $h_i$，以及一个鲁棒的聚合规则，用于从分量估计中为每个参数获得单个 $h_i$。\n\n在一个程序中实现你的策略，该程序：\n1. 使用中心差分计算在给定 $\\boldsymbol{\\theta}$ 处的梯度向量 $\\partial_1 \\boldsymbol{\\mu}$ 和 $\\partial_2 \\boldsymbol{\\mu}$。\n2. 通过最小化派生的复合误差模型来选择步长 $h_1$ 和 $h_2$，该模型使用可从 $\\boldsymbol{\\mu}$ 及其局部行为获得的量，并以鲁棒的方式将分量最优步长聚合成每个参数的单个步长。\n3. 为了验证，仅基于定义的 $\\boldsymbol{\\mu}(\\boldsymbol{\\theta})$ 使用微积分计算参考的“解析”梯度 $\\partial_1 \\boldsymbol{\\mu}$ 和 $\\partial_2 \\boldsymbol{\\mu}$。\n4. 报告每个参数在 $m$ 个分量上中心差分梯度与解析梯度之间的最大绝对差异。\n\n使用以下参数值和波数箱的测试套件：\n- 波数箱为 $k_j \\in \\{0.02, 0.07, 0.15, 0.25\\}$，单位为 $h/\\mathrm{Mpc}$，其中 $m=4$。\n- 测试用例 1：$\\theta_1 = \\ln(2.1\\times 10^{-9})$，$\\theta_2 = 0.965$。\n- 测试用例 2：$\\theta_1 = \\ln(1.0\\times 10^{-12})$，$\\theta_2 = 0.900$。\n- 测试用例 3：$\\theta_1 = \\ln(1.0\\times 10^{-8})$，$\\theta_2 = 1.100$。\n\n你的程序必须生成单行输出，其中包含所有测试用例的结果，格式为方括号内的逗号分隔列表。每个测试用例的结果本身是一个包含四个浮点数的列表，顺序为 $[h_1, h_2, e_1, e_2]$，其中 $h_i$表示为参数 $\\theta_i$ 选择的最优步长，$e_i$ 表示参数 $\\theta_i$ 在 $m$ 个分量上中心差分梯度与解析梯度之间的最大绝对误差。例如，最终打印的行应如下所示\n$$\n[\\,[h_{1}^{(1)},h_{2}^{(1)},e_{1}^{(1)},e_{2}^{(1)}],[h_{1}^{(2)},h_{2}^{(2)},e_{1}^{(2)},e_{2}^{(2)}],[h_{1}^{(3)},h_{2}^{(3)},e_{1}^{(3)},e_{2}^{(3)}]\\,].\n$$\n本问题不使用角度。所有涉及单位的物理量已在说明中指定，所有输出均为无量纲浮点数。",
            "solution": "所述问题具有科学依据，是适定且自洽的。它提出了一个在物理宇宙学背景下标准的、尽管详细的数值分析任务。所有必要的函数、参数和测试条件都已明确定义，不存在内部矛盾、事实错误或模糊之处。因此，该问题被认为是有效的，并将提供解答。\n\n任务是计算宇宙学可观测量 $\\boldsymbol{\\mu}(\\boldsymbol{\\theta})$ 的参数梯度，并通过从第一性原理推导误差模型来确定有限差分方法的最优步长。\n\n设目标函数为 $f(x)$。我们希望计算其导数 $f'(x)$。我们首先调用 $f(x)$ 在点 $x_0$ 附近的泰勒级数展开：\n$$ f(x_0 + h) = f(x_0) + h f'(x_0) + \\frac{h^2}{2!} f''(x_0) + \\frac{h^3}{3!} f'''(x_0) + O(h^4) $$\n$$ f(x_0 - h) = f(x_0) - h f'(x_0) + \\frac{h^2}{2!} f''(x_0) - \\frac{h^3}{3!} f'''(x_0) + O(h^4) $$\n第一个展开式减去第二个展开式得到：\n$$ f(x_0 + h) - f(x_0 - h) = 2h f'(x_0) + \\frac{2h^3}{6} f'''(x_0) + O(h^5) $$\n重新整理以求解导数 $f'(x_0)$：\n$$ f'(x_0) = \\frac{f(x_0 + h) - f(x_0 - h)}{2h} - \\frac{h^2}{6} f'''(x_0) + O(h^4) $$\n右边的第一项是一阶导数的中心差分公式，我们将其表示为 $D_h[f](x_0)$。第二项 $-\\frac{h^2}{6} f'''(x_0)$ 是该近似的主阶截断误差。因此，截断误差的大小为：\n$$ \\epsilon_{\\text{trunc}}(h) = \\left| D_h[f](x_0) - f'(x_0) \\right| \\approx \\frac{h^2}{6} |f'''(x_0)| $$\n此误差源于用有限阶多项式近似真实函数，并按 $O(h^2)$ 缩放。\n\n第二个误差来源是舍入误差，它源于浮点运算的有限精度。设 $\\tilde{f}(x)$ 表示 $f(x)$ 的机器可表示值。浮点表示的一个标准模型是 $\\tilde{f}(x) = f(x)(1+\\delta)$，其中 $|\\delta| \\le \\epsilon_{\\text{mach}}$，而 $\\epsilon_{\\text{mach}}$ 是机器ε (machine epsilon)，即满足 $1 + \\epsilon_{\\text{mach}} \\neq 1$ 的最小浮点数。\n\n计算出的数值导数不是 $D_h[f](x_0)$，而是 $\\tilde{D}_h[f](x_0)$：\n$$ \\tilde{D}_h[f](x_0) = \\frac{\\tilde{f}(x_0 + h) - \\tilde{f}(x_0 - h)}{2h} = \\frac{f(x_0 + h)(1+\\delta_1) - f(x_0 - h)(1+\\delta_2)}{2h} $$\n其中 $|\\delta_1|, |\\delta_2| \\le \\epsilon_{\\text{mach}}$。展开此表达式得到：\n$$ \\tilde{D}_h[f](x_0) = \\frac{f(x_0 + h) - f(x_0 - h)}{2h} + \\frac{f(x_0 + h)\\delta_1 - f(x_0 - h)\\delta_2}{2h} $$\n第二项是舍入误差。在最坏情况下，其大小由以下公式界定：\n$$ \\epsilon_{\\text{round}}(h) \\approx \\frac{|f(x_0 + h)|\\epsilon_{\\text{mach}} + |f(x_0 - h)|\\epsilon_{\\text{mach}}}{2h} $$\n对于一个小的步长 $h$，我们可以近似 $f(x_0 \\pm h) \\approx f(x_0)$。因此，舍入误差为：\n$$ \\epsilon_{\\text{round}}(h) \\approx \\frac{2|f(x_0)|\\epsilon_{\\text{mach}}}{2h} = \\frac{|f(x_0)|\\epsilon_{\\text{mach}}}{h} $$\n此误差按 $O(1/h)$ 缩放，并随着步长 $h$ 的减小而增大。\n\n总数值误差 $\\epsilon_{\\text{total}}(h)$ 是截断误差和舍入误差大小之和：\n$$ \\epsilon_{\\text{total}}(h) \\approx \\epsilon_{\\text{trunc}}(h) + \\epsilon_{\\text{round}}(h) = \\frac{h^2}{6} |f'''(x_0)| + \\frac{|f(x_0)|\\epsilon_{\\text{mach}}}{h} $$\n为了找到最小化此总误差的最优步长 $h_{\\text{opt}}$，我们将 $\\epsilon_{\\text{total}}(h)$ 对 $h$求导，并令结果为零：\n$$ \\frac{d\\epsilon_{\\text{total}}}{dh} = \\frac{2h}{6} |f'''(x_0)| - \\frac{|f(x_0)|\\epsilon_{\\text{mach}}}{h^2} = 0 $$\n$$ \\frac{h}{3} |f'''(x_0)| = \\frac{|f(x_0)|\\epsilon_{\\text{mach}}}{h^2} $$\n解出 $h$ 得到最优步长：\n$$ h_{\\text{opt}} = \\left( \\frac{3 |f(x_0)| \\epsilon_{\\text{mach}}}{|f'''(x_0)|} \\right)^{1/3} $$\n\n现在我们将这个框架应用于问题的可观测量向量 $\\boldsymbol{\\mu}(\\boldsymbol{\\theta})$，其中 $f(\\theta_i)$ 对应于分量 $\\mu_j(\\boldsymbol{\\theta})$ 对参数 $\\theta_i$ 的导数。参数 $\\theta_i$ 和分量 $j$ 的最优步长为：\n$$ h_{i,j}^{\\text{opt}} = \\left( \\frac{3 |\\mu_j(\\boldsymbol{\\theta})| \\epsilon_{\\text{mach}}}{|\\partial_i^3 \\mu_j(\\boldsymbol{\\theta})|} \\right)^{1/3} $$\n\n$\\mu_j(\\boldsymbol{\\theta})$ 的函数形式为 $\\mu_j(\\boldsymbol{\\theta}) = \\exp(\\theta_1)\\left(\\frac{k_j}{k_0}\\right)^{\\theta_2} T^2(k_j)$。我们必须计算三阶偏导数。\n\n对于 $\\theta_1$：\n其依赖关系在于 $\\exp(\\theta_1)$。因此，每次对 $\\theta_1$ 求偏导都只是将函数乘以1。\n$$ \\partial_1 \\mu_j(\\boldsymbol{\\theta}) = \\mu_j(\\boldsymbol{\\theta}), \\quad \\partial_1^2 \\mu_j(\\boldsymbol{\\theta}) = \\mu_j(\\boldsymbol{\\theta}), \\quad \\partial_1^3 \\mu_j(\\boldsymbol{\\theta}) = \\mu_j(\\boldsymbol{\\theta}) $$\n将此代入最优步长公式中：\n$$ h_{1,j}^{\\text{opt}} = \\left( \\frac{3 |\\mu_j(\\boldsymbol{\\theta})| \\epsilon_{\\text{mach}}}{|\\mu_j(\\boldsymbol{\\theta})|} \\right)^{1/3} = (3 \\epsilon_{\\text{mach}})^{1/3} $$\n此步长与分量 $j$ 无关。因此，一个单一的最优步长 $h_1 = (3 \\epsilon_{\\text{mach}})^{1/3}$ 可用于所有分量。\n\n对于 $\\theta_2$：\n其依赖关系在于 $C^{\\theta_2}$，其中 $C = k_j/k_0$。 $C^x$ 的导数是 $(\\ln C) C^x$。\n$$ \\partial_2 \\mu_j(\\boldsymbol{\\theta}) = \\mu_j(\\boldsymbol{\\theta}) \\ln\\left(\\frac{k_j}{k_0}\\right) $$\n$$ \\partial_2^2 \\mu_j(\\boldsymbol{\\theta}) = \\mu_j(\\boldsymbol{\\theta}) \\left[\\ln\\left(\\frac{k_j}{k_0}\\right)\\right]^2 $$\n$$ \\partial_2^3 \\mu_j(\\boldsymbol{\\theta}) = \\mu_j(\\boldsymbol{\\theta}) \\left[\\ln\\left(\\frac{k_j}{k_0}\\right)\\right]^3 $$\n代入最优步长公式中：\n$$ h_{2,j}^{\\text{opt}} = \\left( \\frac{3 |\\mu_j(\\boldsymbol{\\theta})| \\epsilon_{\\text{mach}}}{|\\mu_j(\\boldsymbol{\\theta}) [\\ln(k_j/k_0)]^3|} \\right)^{1/3} = \\frac{(3 \\epsilon_{\\text{mach}})^{1/3}}{|\\ln(k_j/k_0)|} $$\n此步长 $h_{2,j}^{\\text{opt}}$ 通过波数 $k_j$ 依赖于分量 $j$。由于问题要求参数 $\\theta_2$ 只有一个步长 $h_2$，我们必须聚合分量最优步长 $\\{h_{2,j}^{\\text{opt}}\\}_{j=1}^m$。一个对异常值不敏感的鲁棒聚合规则是中位数。对于给定的 $m=4$ 个分量的问题，排序后值 $\\{s_1, s_2, s_3, s_4\\}$ 的中位数是 $(s_2+s_3)/2$。\n\n为了验证，我们需要解析梯度。如上所述：\n- 关于 $\\theta_1$ 的解析梯度是 $\\partial_1 \\boldsymbol{\\mu} = \\boldsymbol{\\mu}$。\n- 关于 $\\theta_2$ 的解析梯度具有分量 $(\\partial_2 \\boldsymbol{\\mu})_j = \\mu_j(\\boldsymbol{\\theta}) \\ln(k_j/k_0)$。\n\n实现计划如下：\n1. 对于每个测试用例，定义参数 $\\boldsymbol{\\theta}$ 和常数。\n2. 实现 BBKS 传递函数 $T(k)$ 和可观测量向量 $\\boldsymbol{\\mu}(\\boldsymbol{\\theta})$。\n3. 计算最优步长 $h_1 = (3\\epsilon_{\\text{mach}})^{1/3}$。\n4. 对于每个分量 $j$，计算 $h_{2,j}^{\\text{opt}}$，然后找到这些值的中位数以确定 $h_2$。\n5. 使用确定的步长 $h_1$ 和 $h_2$，通过中心差分公式计算数值导数 $\\partial_1 \\boldsymbol{\\mu}$ 和 $\\partial_2 \\boldsymbol{\\mu}$。\n6. 使用精确表达式计算解析导数 $\\partial_1 \\boldsymbol{\\mu}$ 和 $\\partial_2 \\boldsymbol{\\mu}$。\n7. 对每个参数 $i \\in \\{1,2\\}$，计算最大绝对误差 $e_i = \\max_j |(\\partial_i \\boldsymbol{\\mu})_{\\text{num},j} - (\\partial_i \\boldsymbol{\\mu})_{\\text{an},j}|$。\n8. 按要求为每个测试用例整理并格式化结果 $[h_1, h_2, e_1, e_2]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes parameter derivatives for a cosmological observable using a\n    central-difference scheme with an optimally chosen step size, and\n    validates the result against an analytic derivative.\n    \"\"\"\n\n    # Fixed cosmological and model parameters\n    OMEGA_M = 0.315\n    H_PARAM = 0.674\n    K0 = 0.05  # in h/Mpc\n\n    # Wavenumber bins\n    K_VALUES = np.array([0.02, 0.07, 0.15, 0.25])  # in h/Mpc\n    \n    # Machine epsilon for double precision floating-point numbers\n    EPS_MACH = np.finfo(float).eps\n\n    # Test cases for theta = [theta1, theta2]\n    test_cases = [\n        (np.log(2.1e-9), 0.965),\n        (np.log(1.0e-12), 0.900),\n        (np.log(1.0e-8), 1.100),\n    ]\n\n    def bbks_transfer(k, omega_m, h):\n        \"\"\"\n        Computes the Bardeen-Bond-Kaiser-Szalay (BBKS) transfer function.\n        \"\"\"\n        gamma = omega_m * h\n        q = k / gamma\n        \n        # Handle the case q=0 to avoid division by zero, T(q->0) -> 1\n        if np.isscalar(q):\n            if q == 0: return 1.0\n        else:\n            q[q == 0] = 1e-9 # Avoid division by zero, small q approx is fine\n\n        log_term = np.log(1 + 2.34 * q) / (2.34 * q)\n        poly_term = (\n            1 + 3.89 * q + (16.1 * q)**2 + (5.46 * q)**3 + (6.71 * q)**4\n        )**(-0.25)\n        return log_term * poly_term\n\n    def mu_vector(theta, k_vals, omega_m, h, k0):\n        \"\"\"\n        Computes the observable vector mu(theta).\n        \"\"\"\n        theta1, theta2 = theta\n        t_sq = bbks_transfer(k_vals, omega_m, h)**2\n        return np.exp(theta1) * (k_vals / k0)**theta2 * t_sq\n\n    results = []\n    \n    for theta_val in test_cases:\n        theta1, theta2 = theta_val\n\n        # 1. Determine optimal step sizes h1 and h2\n        \n        # For theta1, the optimal step size is constant\n        h1 = (3 * EPS_MACH)**(1/3)\n\n        # For theta2, the optimal step size depends on k_j. We aggregate using the median.\n        log_k_ratios = np.log(K_VALUES / K0)\n        # Handle case where k_j = k0 -> ln(1) = 0 -> division by zero\n        # In this problem, k_j is never equal to k0.\n        h2_j_optimal = h1 / np.abs(log_k_ratios)\n        \n        # Median for m=4 components is the average of the two central elements\n        sorted_h2_j = np.sort(h2_j_optimal)\n        h2 = (sorted_h2_j[1] + sorted_h2_j[2]) / 2.0\n\n        # 2. Compute numerical gradients using central differences\n        \n        # Gradient w.r.t. theta1\n        theta1_plus = (theta1 + h1, theta2)\n        theta1_minus = (theta1 - h1, theta2)\n        mu_plus1 = mu_vector(theta1_plus, K_VALUES, OMEGA_M, H_PARAM, K0)\n        mu_minus1 = mu_vector(theta1_minus, K_VALUES, OMEGA_M, H_PARAM, K0)\n        grad1_num = (mu_plus1 - mu_minus1) / (2 * h1)\n        \n        # Gradient w.r.t. theta2\n        theta2_plus = (theta1, theta2 + h2)\n        theta2_minus = (theta1, theta2 - h2)\n        mu_plus2 = mu_vector(theta2_plus, K_VALUES, OMEGA_M, H_PARAM, K0)\n        mu_minus2 = mu_vector(theta2_minus, K_VALUES, OMEGA_M, H_PARAM, K0)\n        grad2_num = (mu_plus2 - mu_minus2) / (2 * h2)\n\n        # 3. Compute analytic gradients for validation\n        mu_at_theta = mu_vector(theta_val, K_VALUES, OMEGA_M, H_PARAM, K0)\n        \n        # d/d(theta1) [exp(theta1) * f(theta2)] = exp(theta1) * f(theta2) = mu\n        grad1_an = mu_at_theta\n        \n        # d/d(theta2) [C * a^theta2] = C * a^theta2 * ln(a) = mu * ln(a)\n        grad2_an = mu_at_theta * log_k_ratios\n\n        # 4. Compute maximum absolute errors\n        e1 = np.max(np.abs(grad1_num - grad1_an))\n        e2 = np.max(np.abs(grad2_num - grad2_an))\n\n        results.append([h1, h2, e1, e2])\n\n    # Final print statement in the exact required format\n    # Using a nested list comprehension and repr() for floating point precision\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在宇宙学中，我们通常更关心由模型参数导出的物理量，而不是参数本身。本练习将演示如何使用Fisher矩阵（或其逆矩阵，即协方差矩阵）来传播参数约束，从而得到衍生量的误差。你将通过计算暗能量状态方程 $w(z)$ 的约束，并确定其约束最强的“枢轴红移”（pivot redshift），来掌握这一核心应用。",
            "id": "3472326",
            "problem": "一个第IV阶段光谱星系红移巡天对Chevallier–Polarski–Linder (CPL) 模型中的暗能量状态方程参数进行了约束，其中状态方程写作 $w(z)=w_0+w_a\\,z/(1+z)$。在似然函数的最大值附近，假设参数矢量 $\\boldsymbol{\\theta}=(w_0,w_a)$ 的后验概率分布可以很好地用高斯分布来近似。对应于 $(w_0,w_a)$ 的费雪信息矩阵经测量为\n$$\n\\mathbf{F} \\;=\\; \\begin{pmatrix}\n100 & 40 \\\\\n40 & 30\n\\end{pmatrix}.\n$$\n从费雪信息矩阵的定义和似然函数的高斯近似出发，通过将 $w(z)$ 视为 $(w_0,w_a)$ 的函数，推导如何将在给定红移 $z$ 处来自 $(w_0,w_a)$ 的约束传播到导出量 $w(z)$。然后，在不假设任何预先推导的枢轴公式的情况下，解析地确定使 $w(z)$ 的预报 $1\\sigma$ 方差最小化的红移 $z_\\star$。最后，使用上述费雪矩阵计算 $z_\\star$。将 $z_\\star$ 的最终数值答案四舍五入到四位有效数字。",
            "solution": "问题要求我们首先推导将Chevallier–Polarski–Linder (CPL) 参数 $\\boldsymbol{\\theta}=(w_0, w_a)$ 上的约束传播到导出量 $w(z)$ 的方法，然后找到使 $w(z)$ 的方差最小化的红移 $z_\\star$。\n\n问题陈述，在似然函数 $\\mathcal{L}$ 的最大值附近，参数 $\\boldsymbol{\\theta}$ 的后验概率分布可以很好地用高斯分布来近似。这样一个似然函数的对数可以表示为：\n$$\n\\ln \\mathcal{L}(\\boldsymbol{\\theta}) \\approx \\text{const} - \\frac{1}{2} \\sum_{i,j} (\\theta_i - \\hat{\\theta}_i) F_{ij} (\\theta_j - \\hat{\\theta}_j)\n$$\n其中 $\\hat{\\boldsymbol{\\theta}}$ 是参数的最大似然估计，$\\mathbf{F}$ 是费雪信息矩阵。费雪矩阵的元素由 $F_{ij} = -\\left\\langle \\frac{\\partial^2 \\ln \\mathcal{L}}{\\partial \\theta_i \\partial \\theta_j} \\right\\rangle$ 给出。似然函数的这种高斯形式意味着参数的协方差矩阵 $\\mathbf{C}$ 是费雪矩阵的逆：\n$$\n\\mathbf{C} = \\mathbf{F}^{-1}\n$$\n协方差矩阵的元素为 $C_{ij} = \\text{cov}(\\theta_i, \\theta_j)$，其对角线元素为方差，$C_{ii} = \\sigma^2_{\\theta_i}$。\n\n暗能量状态方程的CPL模型由下式给出：\n$$\nw(z) = w_0 + w_a \\frac{z}{1+z}\n$$\n这是一个导出量，是参数 $w_0$ 和 $w_a$ 的函数。我们希望找到 $w(z)$ 的方差，记为 $\\sigma^2_{w(z)}$。对于一个普适的导出量 $Q(\\boldsymbol{\\theta})$，其方差可以使用标准的不确定性传播公式求得：\n$$\n\\sigma_Q^2 = \\sum_{i,j} \\frac{\\partial Q}{\\partial \\theta_i} \\frac{\\partial Q}{\\partial \\theta_j} C_{ij}\n$$\n在我们的例子中，参数是 $\\theta_1 = w_0$ 和 $\\theta_2 = w_a$。导出量是 $Q = w(z)$。我们首先计算 $w(z)$ 对各参数的偏导数：\n$$\n\\frac{\\partial w(z)}{\\partial w_0} = 1\n$$\n$$\n\\frac{\\partial w(z)}{\\partial w_a} = \\frac{z}{1+z}\n$$\n设 $(w_0, w_a)$ 的协方差矩阵记为：\n$$\n\\mathbf{C} = \\begin{pmatrix} C_{00}  C_{0a} \\\\ C_{0a}  C_{aa} \\end{pmatrix} = \\begin{pmatrix} \\sigma^2_{w_0}  \\text{cov}(w_0, w_a) \\\\ \\text{cov}(w_0, w_a)  \\sigma^2_{w_a} \\end{pmatrix}\n$$\n将偏导数代入误差传播公式，我们得到 $w(z)$ 的方差：\n$$\n\\sigma^2_{w(z)} = \\left(\\frac{\\partial w}{\\partial w_0}\\right)^2 C_{00} + \\left(\\frac{\\partial w}{\\partial w_a}\\right)^2 C_{aa} + 2 \\left(\\frac{\\partial w}{\\partial w_0}\\right) \\left(\\frac{\\partial w}{\\partial w_a}\\right) C_{0a}\n$$\n$$\n\\sigma^2_{w(z)} = (1)^2 C_{00} + \\left(\\frac{z}{1+z}\\right)^2 C_{aa} + 2(1)\\left(\\frac{z}{1+z}\\right) C_{0a}\n$$\n这个表达式给出了传播到 $w(z)$ 上的 $1\\sigma$ 方差，作为红移 $z$ 的函数。\n\n接下来，我们必须找到使 $\\sigma^2_{w(z)}$ 最小化的红移 $z_\\star$。为此，我们将 $\\sigma^2_{w(z)}$ 对 $z$ 求导，并令结果为零。项 $\\frac{z}{1+z}$ 对 $z$ 的导数是：\n$$\n\\frac{d}{dz}\\left(\\frac{z}{1+z}\\right) = \\frac{(1)(1+z) - (z)(1)}{(1+z)^2} = \\frac{1}{(1+z)^2}\n$$\n现在，对 $\\sigma^2_{w(z)}$ 求导：\n$$\n\\frac{d}{dz}\\sigma^2_{w(z)} = \\frac{d}{dz} \\left[ C_{00} + C_{aa}\\left(\\frac{z}{1+z}\\right)^2 + 2C_{0a}\\left(\\frac{z}{1+z}\\right) \\right]\n$$\n$$\n\\frac{d}{dz}\\sigma^2_{w(z)} = 2C_{aa}\\left(\\frac{z}{1+z}\\right) \\frac{d}{dz}\\left(\\frac{z}{1+z}\\right) + 2C_{0a}\\frac{d}{dz}\\left(\\frac{z}{1+z}\\right)\n$$\n$$\n\\frac{d}{dz}\\sigma^2_{w(z)} = \\left[ 2C_{aa}\\left(\\frac{z}{1+z}\\right) + 2C_{0a} \\right] \\frac{1}{(1+z)^2}\n$$\n将导数设为零以求在 $z=z_\\star$ 处的极值：\n$$\n\\left[ 2C_{aa}\\left(\\frac{z_\\star}{1+z_\\star}\\right) + 2C_{0a} \\right] \\frac{1}{(1+z_\\star)^2} = 0\n$$\n因为 $z_\\star \\ge 0$，项 $\\frac{1}{(1+z_\\star)^2}$ 不为零。因此，方括号中的项必须为零：\n$$\nC_{aa}\\left(\\frac{z_\\star}{1+z_\\star}\\right) + C_{0a} = 0\n$$\n$$\n\\frac{z_\\star}{1+z_\\star} = -\\frac{C_{0a}}{C_{aa}}\n$$\n为确认这是一个最小值，我们可以检查二阶导数。在 $z_\\star$ 处的二阶导数是 $\\frac{d^2\\sigma^2_{w(z)}}{dz^2}\\big|_{z=z_\\star} = \\frac{2 C_{aa}}{(1+z_\\star)^4}$。因为协方差矩阵必须是正定的，其对角线元素为正，所以 $C_{aa} = \\sigma^2_{w_a} > 0$。因此，二阶导数为正，确认了这是一个最小值。\n\n求解 $z_\\star$：\n$$\nz_\\star = -\\frac{C_{0a}}{C_{aa}}(1+z_\\star) \\implies z_\\star = -\\frac{C_{0a}}{C_{aa}} - \\frac{C_{0a}}{C_{aa}}z_\\star\n$$\n$$\nz_\\star\\left(1 + \\frac{C_{0a}}{C_{aa}}\\right) = -\\frac{C_{0a}}{C_{aa}} \\implies z_\\star\\left(\\frac{C_{aa} + C_{0a}}{C_{aa}}\\right) = -\\frac{C_{0a}}{C_{aa}}\n$$\n$$\nz_\\star = -\\frac{C_{0a}}{C_{aa} + C_{0a}}\n$$\n这是使 $w(z)$ 的方差最小化的红移 $z_\\star$ 的解析表达式。\n\n最后，我们使用给定的费雪矩阵计算 $z_\\star$：\n$$\n\\mathbf{F} = \\begin{pmatrix} 100  40 \\\\ 40  30 \\end{pmatrix}\n$$\n首先，我们计算协方差矩阵 $\\mathbf{C} = \\mathbf{F}^{-1}$。$\\mathbf{F}$ 的行列式是：\n$$\n\\det(\\mathbf{F}) = (100)(30) - (40)(40) = 3000 - 1600 = 1400\n$$\n一个 $2 \\times 2$ 矩阵 $\\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$ 的逆是 $\\frac{1}{ad-bc}\\begin{pmatrix} d  -b \\\\ -c  a \\end{pmatrix}$。因此：\n$$\n\\mathbf{C} = \\frac{1}{1400} \\begin{pmatrix} 30  -40 \\\\ -40  100 \\end{pmatrix}\n$$\n协方差矩阵的分量是：\n$C_{0a} = \\text{cov}(w_0, w_a) = -\\frac{40}{1400} = -\\frac{4}{140} = -\\frac{1}{35}$\n$C_{aa} = \\sigma^2_{w_a} = \\frac{100}{1400} = \\frac{10}{140} = \\frac{1}{14}$\n\n现在我们将这些值代入 $\\frac{z_\\star}{1+z_\\star}$ 的表达式中：\n$$\n\\frac{z_\\star}{1+z_\\star} = -\\frac{C_{0a}}{C_{aa}} = -\\frac{-1/35}{1/14} = \\frac{1}{35} \\times 14 = \\frac{14}{35} = \\frac{2}{5}\n$$\n求解 $z_\\star$：\n$$\n5z_\\star = 2(1+z_\\star) = 2 + 2z_\\star\n$$\n$$\n3z_\\star = 2 \\implies z_\\star = \\frac{2}{3}\n$$\n问题要求一个数值答案，四舍五入到四位有效数字。\n$$\nz_\\star = \\frac{2}{3} \\approx 0.666666...\n$$\n四舍五入到四位有效数字得到 $z_\\star = 0.6667$。",
            "answer": "$$\n\\boxed{0.6667}\n$$"
        },
        {
            "introduction": "实际的宇宙学调查通常比理想化的教科书模型更复杂，数据协方差矩阵中包含了各种物理效应。本练习将探讨一个重要的例子：超样本协方差（Super-Sample Covariance, SSC），它源于小尺度模式与大尺度背景涨落的耦合。你将学习如何将SSC项整合到总协方差矩阵中，并量化它对参数约束的“退化”效应，这是对现代大尺度结构分析进行精确预报的一项高级技能。",
            "id": "3472458",
            "problem": "你的任务是为一个有限立方体积内的物质功率谱的简单模型实现一个费雪信息矩阵的数值预报，同时通过一个拍频耦合项来引入超样本协方差修正。目标是量化功率谱参数的费雪信息矩阵如何随着盒子大小和长波长模式方差的变化而退化。\n\n考虑一个边长为 $L$（单位为 $\\mathrm{Mpc}/h$）的立方巡天体积，其中包含波数为 $k$（单位为 $h/\\mathrm{Mpc}$）的模式。假设基准物质功率谱被建模为幂律形式\n$$\nP(k;\\theta) = A \\left(\\frac{k}{k_0}\\right)^n,\n$$\n其参数为 $\\theta = (A, n)$，其中 $A$ 是振幅（单位为 $(\\mathrm{Mpc}/h)^3$），$n$ 是谱指数（无量纲），$k_0$ 是一个固定的枢轴尺度（单位为 $h/\\mathrm{Mpc}$）。假设在 $k$ 分箱中的频带功率估计 $P(k_i)$ 服从高斯似然。参数 $(A,n)$ 的费雪信息矩阵由标准的基于平均频带功率 $P(k_i;\\theta)$ 的敏感度及其协方差的高斯似然公式定义。\n\n频带功率的协方差有两个贡献：一个来自有限体积中模式计数的高斯项，以及一个来自与长波长背景密度涨落的拍频耦合的超样本协方差项。在有限盒子体积 $V = L^3$ 中，第 $i$ 个分箱的高斯协方差由模式计数方差给出：\n$$\n\\mathrm{Cov}_\\mathrm{G}[P(k_i),P(k_j)] = \\delta_{ij} \\frac{2\\,P(k_i;\\theta)^2}{N_i},\n$$\n其中 $N_i$ 是分箱 $i$ 中的傅里叶模式数量，近似为\n$$\nN_i = \\frac{V}{(2\\pi)^3} \\int_{\\text{bin }i} \\mathrm{d}^3k \\approx \\frac{V}{(2\\pi)^3} 4\\pi k_i^2 \\Delta k,\n$$\n其中 $\\Delta k$ 是分箱宽度，$k_i$ 是分箱中心。\n\n超样本协方差源于小尺度模式与在不同实现中涨落的大尺度背景过密 $\\delta_b$ 的耦合。在独立宇宙近似中，取至 $\\delta_b$ 的线性阶，小尺度功率的响应写作\n$$\n\\frac{\\partial \\ln P(k;\\theta)}{\\partial \\delta_b} = \\mathcal{R}(k;\\theta),\n$$\n其中 $\\mathcal{R}(k;\\theta)$ 包含一个增长项和一个依赖于功率谱对数斜率的膨胀项。将 $\\delta_b$ 视为一个高斯随机变量，其方差等于盒子内长波长模式的方差，\n$$\n\\sigma_L^2 = \\frac{1}{2\\pi^2} \\int_0^{k_\\mathrm{f}} q^2 P(q;\\theta)\\,\\mathrm{d}q, \\quad k_\\mathrm{f} \\equiv \\frac{2\\pi}{L}.\n$$\n使用独立宇宙框架和线性理论，增长响应系数是一个常数 $C_\\mathrm{g}$，而膨胀项的贡献为 $-(1/3)\\,\\partial \\ln P / \\partial \\ln k$。对于幂律模型，导出作为谱指数 $n$ 和常数 $C_\\mathrm{g}$ 的函数的显式响应 $\\mathcal{R}(k;\\theta)$。\n\n根据以上假设，推导并实现总协方差。总协方差是高斯项和一个拍频耦合超样本项之和，该超样本项由对 $\\delta_b$ 的功率响应和 $\\sigma_L^2$ 构造，且在频带指数上是秩为1的。然后，在两种情况下计算参数 $(A,n)$ 的费雪信息矩阵：包含超样本协方差和不包含超样本协方差。在两种情况下都通过对费雪矩阵求逆来计算边缘化参数不确定度。将 $(A,n)$ 的边缘化不确定度的退化因子报告为包含超样本协方差的不确定度与不包含超样本协方差的不确定度之比。\n\n在你的实现中使用以下固定值和定义：\n- 基准参数 $A = 1000$ （单位 $(\\mathrm{Mpc}/h)^3$），$n = -1.5$ （无量纲）。\n- 枢轴尺度 $k_0 = 0.1$ （单位 $h/\\mathrm{Mpc}$）。\n- 分箱范围 $k \\in [k_\\mathrm{min},k_\\mathrm{max}]$，其中 $k_\\mathrm{min} = 0.05$，$k_\\mathrm{max} = 0.25$ （单位 $h/\\mathrm{Mpc}$），使用 $N_\\mathrm{bins} = 20$ 个等宽分箱，即 $\\Delta k = (k_\\mathrm{max}-k_\\mathrm{min})/N_\\mathrm{bins}$。\n- 对于独立宇宙增长响应系数，使用 $C_\\mathrm{g} = 47/21$ （无量纲）。\n\n为了评估费雪矩阵如何随盒子大小 $L$ 和长波长模式方差 $\\sigma_L^2$ 退化，实现一个缩放因子 $s$ 来乘以 $\\sigma_L^2$，即用 $s\\,\\sigma_L^2$ 替代 $\\sigma_L^2$。对于每个测试用例，计算 $A$ 和 $n$ 的退化因子，定义如下：\n$$\nD_A(L,s) = \\frac{\\sigma_A^\\mathrm{SSC}(L,s)}{\\sigma_A^\\mathrm{G}(L)}, \\quad D_n(L,s) = \\frac{\\sigma_n^\\mathrm{SSC}(L,s)}{\\sigma_n^\\mathrm{G}(L)},\n$$\n其中 $\\sigma_\\alpha^\\mathrm{SSC}$ 是包含超样本协方差时参数 $\\alpha$ 的边缘化不确定度，而 $\\sigma_\\alpha^\\mathrm{G}$ 是仅包含高斯协方差时的边缘化不确定度。\n\n设计你的程序以评估以下 $(L,s)$ 值的测试套件的退化因子：\n- 测试 1: $(L,s) = (1000, 1.0)$。\n- 测试 2: $(L,s) = (2000, 1.0)$。\n- 测试 3: $(L,s) = (250, 1.0)$。\n- 测试 4: $(L,s) = (500, 0.0)$。\n- 测试 5: $(L,s) = (500, 5.0)$。\n\n所有长度单位必须是 $\\mathrm{Mpc}/h$，所有波数单位必须是 $h/\\mathrm{Mpc}$。最终输出 $D_A$ 和 $D_n$ 是无量纲的，并且必须表示为小数。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且本身是一个按 $[D_A,D_n]$ 顺序排列的双元素列表。例如，\n$$\n[\\,[D_A^{(1)},D_n^{(1)}],\\,[D_A^{(2)},D_n^{(2)}],\\,\\dots\\,]\n$$\n包含按上述顺序排列的五个测试用例。",
            "solution": "问题陈述被评估为有效，因为它具有科学依据、良定、客观，并包含得出唯一解所需的所有必要信息。所提出的概念和模型，如费雪信息矩阵、高斯和超样本协方差，以及独立宇宙近似，都是宇宙学数据分析和预报的标准组成部分。因此，我们可以进行形式化的求解。\n\n目标是计算由于超样本协方差（SSC）导致的幂律物质功率谱模型的参数约束的退化。这种退化通过包含和不包含SSC项时的边缘化参数不确定度的比率来量化。\n\n### 1. 模型和分箱准备工作\n基准物质功率谱是一个幂律模型：\n$$\nP(k;\\theta) = A \\left(\\frac{k}{k_0}\\right)^n\n$$\n其中参数为 $\\theta = (A, n)$。基准值为 $A = 1000 \\, (\\mathrm{Mpc}/h)^3$ 和 $n = -1.5$，枢轴尺度为 $k_0 = 0.1 \\, h/\\mathrm{Mpc}$。\n\n分析在 $k \\in [k_\\mathrm{min}, k_\\mathrm{max}]$ 范围内的 $N_\\mathrm{bins} = 20$ 个离散波数分箱上进行，其中 $k_\\mathrm{min} = 0.05 \\, h/\\mathrm{Mpc}$，$k_\\mathrm{max} = 0.25 \\, h/\\mathrm{Mpc}$。分箱是等宽的，宽度为 $\\Delta k = (k_\\mathrm{max} - k_\\mathrm{min}) / N_\\mathrm{bins}$。第 $i$ 个分箱的中心记为 $k_i$，其中 $i \\in \\{0, 1, \\dots, N_\\mathrm{bins}-1\\}$。基准频带功率的向量记为 $\\mathbf{P}$，其分量为 $P_i = P(k_i;\\theta)$。\n\n### 2. 频带功率的协方差矩阵\n总协方差矩阵是一个高斯项和一个超样本协方差项之和：$\\mathbf{C} = \\mathbf{C}_\\mathrm{G} + \\mathbf{C}_\\mathrm{SSC}$。\n\n#### 2.1. 高斯协方差\n频带功率的高斯协方差是对角的，源于巡天体积 $V=L^3$ 中每个分箱内有限的模式数量。\n$$\n\\mathrm{Cov}_\\mathrm{G}[P(k_i), P(k_j)] = \\delta_{ij} \\frac{2 P(k_i)^2}{N_i}\n$$\n分箱 $i$ 中的模式数 $N_i$ 近似为：\n$$\nN_i = \\frac{V}{(2\\pi)^3} (4\\pi k_i^2 \\Delta k) = \\frac{L^3 k_i^2 \\Delta k}{2\\pi^2}\n$$\n因此，高斯协方差矩阵的对角元素为：\n$$\n(\\mathbf{C}_\\mathrm{G})_{ii} = \\frac{4\\pi^2 P(k_i)^2}{L^3 k_i^2 \\Delta k}\n$$\n\n#### 2.2. 超样本协方差\nSSC项源于小尺度模式与长波长背景密度涨落 $\\delta_b$ 的耦合。功率谱对此涨落的响应由下式给出：\n$$\n\\frac{\\partial \\ln P(k)}{\\partial \\delta_b} = \\mathcal{R}(k; n) = C_\\mathrm{g} - \\frac{1}{3}\\frac{\\partial \\ln P}{\\partial \\ln k}\n$$\n对于幂律模型 $P(k) \\propto k^n$，对数导数为 $\\partial \\ln P / \\partial \\ln k = n$。给定增长响应系数 $C_\\mathrm{g} = 47/21$，该响应变得与 $k$ 无关：\n$$\n\\mathcal{R}(n) = \\frac{47}{21} - \\frac{n}{3}\n$$\nSSC矩阵元素由感生功率谱涨落的协方差给出：\n$$\n\\mathrm{Cov}_\\mathrm{SSC}[P(k_i), P(k_j)] = \\langle \\Delta P(k_i) \\Delta P(k_j) \\rangle = \\langle \\left(P(k_i)\\mathcal{R}(k_i)\\delta_b\\right) \\left(P(k_j)\\mathcal{R}(k_j)\\delta_b\\right) \\rangle\n$$\n这可简化为：\n$$\n(\\mathbf{C}_\\mathrm{SSC})_{ij} = P(k_i) P(k_j) \\mathcal{R}(n)^2 \\langle \\delta_b^2 \\rangle\n$$\n方差 $\\langle \\delta_b^2 \\rangle$ 是波数 $q  k_\\mathrm{f} = 2\\pi/L$ 的长波长模式的方差。问题指定了一个外部缩放因子 $s$，因此我们使用 $\\langle \\delta_b^2 \\rangle = s\\sigma_L^2$，其中：\n$$\n\\sigma_L^2 = \\frac{1}{2\\pi^2} \\int_0^{k_\\mathrm{f}} q^2 P(q) \\,dq = \\frac{A}{2\\pi^2 k_0^n} \\int_0^{k_\\mathrm{f}} q^{2+n} \\,dq\n$$\n对于 $n+3 > 0$，该积分的计算结果为：\n$$\n\\sigma_L^2 = \\frac{A}{2\\pi^2 k_0^n} \\frac{k_\\mathrm{f}^{3+n}}{3+n} = \\frac{A}{(3+n) k_0^n} \\frac{(2\\pi)^{1+n}}{L^{3+n}}\n$$\n我们的基准值 $n = -1.5$ 满足此条件。SSC矩阵是一个秩为1的矩阵：\n$$\n\\mathbf{C}_\\mathrm{SSC} = s \\sigma_L^2 \\mathcal{R}(n)^2 (\\mathbf{P} \\mathbf{P}^T)\n$$\n其中 $\\mathbf{P}$ 是频带功率 $P(k_i)$ 的列向量。\n\n### 3. 费雪信息矩阵\n对于高斯似然，参数 $\\theta_\\alpha, \\theta_\\beta$ 的费雪矩阵为：\n$$\nF_{\\alpha\\beta} = \\left(\\frac{\\partial \\mathbf{P}}{\\partial \\theta_\\alpha}\\right)^T \\mathbf{C}^{-1} \\left(\\frac{\\partial \\mathbf{P}}{\\partial \\theta_\\beta}\\right)\n$$\n功率谱相对于参数 $\\theta = (A, n)$ 所需的导数为：\n$$\n\\frac{\\partial P(k)}{\\partial A} = \\frac{P(k)}{A}, \\quad \\frac{\\partial P(k)}{\\partial n} = P(k) \\ln\\left(\\frac{k}{k_0}\\right)\n$$\n这些导数在每个分箱中心 $k_i$ 处求值后，构成了向量，我们将其记为 $\\mathbf{d}_A$ 和 $\\mathbf{d}_n$。\n\n#### 3.1. 纯高斯费雪矩阵 ($F^\\mathrm{G}$)\n当只考虑高斯协方差时，$\\mathbf{C} = \\mathbf{C}_\\mathrm{G}$。由于 $\\mathbf{C}_\\mathrm{G}$ 是对角矩阵，其逆矩阵的计算是平凡的，费雪矩阵元素为：\n$$\nF^\\mathrm{G}_{\\alpha\\beta} = \\sum_i \\frac{1}{(\\mathbf{C}_\\mathrm{G})_{ii}} \\frac{\\partial P(k_i)}{\\partial \\theta_\\alpha} \\frac{\\partial P(k_i)}{\\partial \\theta_\\beta}\n$$\n\n#### 3.2. 总费雪矩阵 ($F^\\mathrm{SSC}$)\n总协方差矩阵为 $\\mathbf{C} = \\mathbf{C}_\\mathrm{G} + \\mathbf{v}\\mathbf{v}^T$，其中向量 $\\mathbf{v}$ 定义为 $\\mathbf{v} = \\sqrt{s\\sigma_L^2} \\mathcal{R}(n) \\mathbf{P}$。该矩阵的逆可以使用Sherman-Morrison公式高效地求出：\n$$\n\\mathbf{C}^{-1} = (\\mathbf{C}_\\mathrm{G} + \\mathbf{v}\\mathbf{v}^T)^{-1} = \\mathbf{C}_\\mathrm{G}^{-1} - \\frac{\\mathbf{C}_\\mathrm{G}^{-1} \\mathbf{v} \\mathbf{v}^T \\mathbf{C}_\\mathrm{G}^{-1}}{1 + \\mathbf{v}^T \\mathbf{C}_\\mathrm{G}^{-1} \\mathbf{v}}\n$$\n将此代入费雪矩阵的定义，得到：\n$$\nF^\\mathrm{SSC}_{\\alpha\\beta} = \\mathbf{d}_\\alpha^T \\mathbf{C}^{-1} \\mathbf{d}_\\beta = F^\\mathrm{G}_{\\alpha\\beta} - \\frac{(\\mathbf{d}_\\alpha^T \\mathbf{C}_\\mathrm{G}^{-1} \\mathbf{v}) (\\mathbf{v}^T \\mathbf{C}_\\mathrm{G}^{-1} \\mathbf{d}_\\beta)}{1 + \\mathbf{v}^T \\mathbf{C}_\\mathrm{G}^{-1} \\mathbf{v}}\n$$\n这个表达式允许通过先计算纯高斯矩阵，然后减去由SSC引起的秩-1更新项，来高效地计算总费雪矩阵。\n\n### 4. 参数不确定度和退化\n参数的协方差矩阵是费雪矩阵的逆，即 $\\mathbf{C}_\\theta = \\mathbf{F}^{-1}$。参数 $\\theta_\\alpha$ 的边缘化不确定度是 $\\mathbf{C}_\\theta$ 相应对角元素的平方根：\n$$\n\\sigma_\\alpha = \\sqrt{(\\mathbf{F}^{-1})_{\\alpha\\alpha}}\n$$\n对于我们参数为 $(A,n)$ 的 $2 \\times 2$ 情况，边缘化不确定度为：\n$$\n\\sigma_A = \\sqrt{\\frac{F_{nn}}{\\det(\\mathbf{F})}}, \\quad \\sigma_n = \\sqrt{\\frac{F_{AA}}{\\det(\\mathbf{F})}}\n$$\n我们分别计算纯高斯情况（使用 $\\mathbf{F}^\\mathrm{G}$ 得到 $\\sigma_A^\\mathrm{G}, \\sigma_n^\\mathrm{G}$）和总协方差情况（使用 $\\mathbf{F}^\\mathrm{SSC}$ 得到 $\\sigma_A^\\mathrm{SSC}, \\sigma_n^\\mathrm{SSC}$）下的这些不确定度。\n\n退化因子是这些不确定度的比率：\n$$\nD_A = \\frac{\\sigma_A^\\mathrm{SSC}}{\\sigma_A^\\mathrm{G}}, \\quad D_n = \\frac{\\sigma_n^\\mathrm{SSC}}{\\sigma_n^\\mathrm{G}}\n$$\n以下算法为指定的测试用例实现了这一计算。请注意，对于 $s=0$ 的情况，SSC项消失，$\\mathbf{F}^\\mathrm{SSC} = \\mathbf{F}^\\mathrm{G}$，退化因子恰好为 $1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Fisher matrix degradation factors for a power spectrum model.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement.\n    test_cases = [\n        # (L in Mpc/h, s dimensionless)\n        (1000.0, 1.0),\n        (2000.0, 1.0),\n        (250.0, 1.0),\n        (500.0, 0.0),\n        (500.0, 5.0),\n    ]\n\n    def compute_degradation(L_val, s_val):\n        \"\"\"\n        Calculates degradation factors D_A and D_n for a given L and s.\n        \n        Args:\n            L_val (float): Side length of the cubic survey volume in Mpc/h.\n            s_val (float): Scaling factor for the super-sample covariance.\n            \n        Returns:\n            list: A list containing the degradation factors [D_A, D_n].\n        \"\"\"\n        # Fiducial parameters and constants\n        fiducial_A = 1000.0  # (Mpc/h)^3\n        fiducial_n = -1.5     # dimensionless\n        pivot_scale_k0 = 0.1 # h/Mpc\n        \n        # Binning setup\n        k_min = 0.05         # h/Mpc\n        k_max = 0.25         # h/Mpc\n        num_bins = 20\n        \n        # Growth response coefficient\n        Cg = 47.0 / 21.0\n\n        # Discretize k-space\n        delta_k = (k_max - k_min) / num_bins\n        k_bins = k_min + (np.arange(num_bins) + 0.5) * delta_k\n\n        # Calculate fiducial power spectrum at bin centers\n        P_k = fiducial_A * (k_bins / pivot_scale_k0)**fiducial_n\n\n        # Calculate derivatives of P(k) w.r.t. parameters A and n\n        dPdA = P_k / fiducial_A\n        dPdn = P_k * np.log(k_bins / pivot_scale_k0)\n        # Shape (num_bins, 2)\n        derivatives = np.vstack((dPdA, dPdn)).T\n\n        # --- Gaussian Covariance and Fisher Matrix ---\n        \n        V = L_val**3\n        # Number of modes per bin\n        N_modes = V * k_bins**2 * delta_k / (2.0 * np.pi**2)\n        \n        # Diagonal of the Gaussian covariance matrix\n        cov_G_diag = 2.0 * P_k**2 / N_modes\n        inv_cov_G_diag = 1.0 / cov_G_diag\n        \n        # Compute Gaussian-only Fisher matrix F_G\n        # F_G_alpha_beta = sum_i (d_alpha * C_G_inv * d_beta)\n        F_G = derivatives.T @ np.diag(inv_cov_G_diag) @ derivatives\n\n        # Invert F_G to get parameter covariance and uncertainties\n        C_param_G = np.linalg.inv(F_G)\n        sigma_A_G = np.sqrt(C_param_G[0, 0])\n        sigma_n_G = np.sqrt(C_param_G[1, 1])\n\n        # Handle the s=0 case, where degradation is 1 by definition\n        if s_val == 0.0:\n            return [1.0, 1.0]\n\n        # --- Super-Sample Covariance and Total Fisher Matrix ---\n\n        # Calculate variance of long-wavelength modes (sigma_L^2)\n        k_f = 2.0 * np.pi / L_val\n        # The integral part is solved analytically\n        sigma_L_sq = (fiducial_A / (2.0 * np.pi**2 * pivot_scale_k0**fiducial_n)) \\\n                     * (k_f**(3.0 + fiducial_n) / (3.0 + fiducial_n))\n\n        # Calculate power spectrum response R(n)\n        R_n = Cg - fiducial_n / 3.0\n        \n        # Construct the vector 'v' for the Sherman-Morrison formula\n        # v = sqrt(s * sigma_L^2) * R(n) * P(k)\n        v_vec = np.sqrt(s_val * sigma_L_sq) * R_n * P_k\n\n        # Apply Sherman-Morrison formula for F_SSC\n        # Numerator term: (d_alpha^T C_G_inv v)\n        g_T_v = derivatives.T @ (inv_cov_G_diag * v_vec)\n        \n        # Denominator term: 1 + v^T C_G_inv v\n        denom = 1.0 + np.sum(v_vec * inv_cov_G_diag * v_vec)\n        \n        # The rank-1 update matrix for the Fisher matrix\n        F_update = np.outer(g_T_v, g_T_v) / denom\n        \n        # Total Fisher matrix with SSC\n        F_SSC = F_G - F_update\n        \n        # Invert F_SSC to get parameter covariance and uncertainties\n        C_param_SSC = np.linalg.inv(F_SSC)\n        sigma_A_SSC = np.sqrt(C_param_SSC[0, 0])\n        sigma_n_SSC = np.sqrt(C_param_SSC[1, 1])\n\n        # Compute degradation factors\n        D_A = sigma_A_SSC / sigma_A_G\n        D_n = sigma_n_SSC / sigma_n_G\n\n        return [D_A, D_n]\n\n    results = []\n    for case in test_cases:\n        L, s = case\n        degradation_factors = compute_degradation(L, s)\n        results.append(degradation_factors)\n\n    # Format the final output string exactly as specified.\n    # e.g., [[D_A1,D_n1],[D_A2,D_n2],...]\n    formatted_results = [f\"[{da},{dn}]\" for da, dn in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}