{
    "hands_on_practices": [
        {
            "introduction": "在求解包含多种物理过程（如辐射转移和化学反应）的复杂系统时，算符分裂是一种强大而常见的技术。这种方法将一个复杂的演化算符分解为一系列更简单的、可独立求解的算符，但这种分解会引入与各算符的对易性相关的误差。本实践将引导你通过Baker-Campbell-Hausdorff (BCH) 展开式，从理论上量化一阶Lie-Trotter分裂和二阶Strang分裂的误差，从而深入理解这些基础数值算法的精度和收敛阶。",
            "id": "3469637",
            "problem": "考虑一个由宇宙学辐射转移和化学耦合产生的自治线性系统，其算子形式写为 $$\\frac{d\\mathbf{x}}{dt} = \\left(\\mathcal{L}_\\mathrm{RT} + \\mathcal{L}_\\mathrm{chem}\\right)\\mathbf{x},$$ 其中 $$\\mathcal{L}_\\mathrm{RT}$$ 表示辐射转移算子，$$\\mathcal{L}_\\mathrm{chem}$$ 表示化学算子。在单区、线性化设置中，将 $$\\mathcal{L}_\\mathrm{RT}$$ 和 $$\\mathcal{L}_\\mathrm{chem}$$ 表示为作用于有限维状态向量 $$\\mathbf{x} \\in \\mathbb{R}^n$$ 的常数矩阵 $$A$$ 和 $$B$$。在一个时间步长 $$\\Delta t$$ 内的精确单步传播子是 $$\\exp\\!\\left(\\Delta t\\,(A+B)\\right)$$。两种常见的算子分裂方案是：Lie–Trotter 分裂，它应用 $$\\exp(\\Delta t\\,A)$$ 后再应用 $$\\exp(\\Delta t\\,B)$$；以及 Strang 分裂，它先应用 $$\\exp\\!\\left(\\tfrac{\\Delta t}{2}A\\right)$$，然后是 $$\\exp(\\Delta t\\,B)$$，最后是 $$\\exp\\!\\left(\\tfrac{\\Delta t}{2}A\\right)$$。Baker–Campbell–Hausdorff (BCH) 展开通过诸如 $$[A,B] \\equiv AB - BA$$ 的对易子将这些分裂传播子与精确传播子联系起来。\n\n你的任务是使用 BCH 框架量化算子分裂误差，并通过对一系列 $$\\Delta t$$ 值进行扫描来验证预测的时间步长标度关系。对于下面的每个测试用例，你必须：\n- 计算对易子 $$[A,B]$$ 及其矩阵二范数 $$\\lVert [A,B] \\rVert_2$$。\n- 对于给定的一组时间步长 $$\\{\\Delta t_i\\}$$，计算 Lie–Trotter 和 Strang 分裂相对于精确传播子的算子范数误差，定义为 $$\\epsilon_\\mathrm{Lie}(\\Delta t_i) = \\left\\lVert \\exp\\!\\left(\\Delta t_i(A+B)\\right) - \\exp\\!\\left(\\Delta t_i A\\right)\\exp\\!\\left(\\Delta t_i B\\right)\\right\\rVert_2$$ 和 $$\\epsilon_\\mathrm{Str}(\\Delta t_i) = \\left\\lVert \\exp\\!\\left(\\Delta t_i(A+B)\\right) - \\exp\\!\\left(\\tfrac{\\Delta t_i}{2} A\\right)\\exp\\!\\left(\\Delta t_i B\\right)\\exp\\!\\left(\\tfrac{\\Delta t_i}{2} A\\right)\\right\\rVert_2$$。\n- 通过对每种分裂方案在时间步长扫描范围内对 $$\\log \\epsilon$$ 与 $$\\log \\Delta t$$ 进行最小二乘拟合，来估计经验标度指数 $$p_\\mathrm{Lie}$$ 和 $$p_\\mathrm{Str}$$。如果误差在整个扫描范围内在数值上为零（例如，如果 $$[A,B] = 0$$），则将相应的指数定义为 $$0.0$$。\n- 仅对于 Lie–Trotter 分裂，在最小时间步长处计算系数 $$k_\\mathrm{Lie}$$，定义为 $$k_\\mathrm{Lie} = \\epsilon_\\mathrm{Lie}(\\Delta t_\\mathrm{min})\\big/\\left(\\Delta t_\\mathrm{min}^2 \\,\\lVert [A,B] \\rVert_2\\right)$$，并在 $$\\lVert [A,B] \\rVert_2 = 0$$ 时，将 $$k_\\mathrm{Lie}$$ 设为 $$0.0$$。\n\n对所有算子范数使用矩阵二范数。将所有量视为无量纲。缩写 BCH 指代 Baker–Campbell–Hausdorff，RT 指代 Radiative Transfer（辐射转移）。\n\n测试套件：\n- 用例 1（对易算子，边界条件）：$$A = \\begin{pmatrix}-0.1  0 \\\\ 0  -0.5\\end{pmatrix}, \\quad B = \\begin{pmatrix}-0.2  0 \\\\ 0  -0.3\\end{pmatrix}.$$\n- 用例 2（非对易，中等耦合）：$$A = \\begin{pmatrix}-1.0  5.0 \\\\ 0.0  -0.5\\end{pmatrix}, \\quad B = \\begin{pmatrix}-0.3  0.0 \\\\ 2.0  -2.0\\end{pmatrix}.$$\n- 用例 3（非对易，刚性耦合）：$$A = \\begin{pmatrix}-50.0  100.0 \\\\ 0.0  -30.0\\end{pmatrix}, \\quad B = \\begin{pmatrix}-2.0  -40.0 \\\\ 0.0  -1.0\\end{pmatrix}.$$\n\n使用时间步长扫描 $$\\Delta t \\in \\{10^{-5},\\,2\\times 10^{-5},\\,5\\times 10^{-5},\\,10^{-4},\\,2\\times 10^{-4},\\,5\\times 10^{-4},\\,10^{-3}\\}$$.\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含一个用方括号括起来的、以逗号分隔的列表形式的结果。该列表必须按顺序包含每个测试用例的测得的 Lie–Trotter 分裂标度指数 $$p_\\mathrm{Lie}$$、测得的 Strang 分裂标度指数 $$p_\\mathrm{Str}$$，以及在 $$\\Delta t_\\mathrm{min}$$ 处的系数 $$k_\\mathrm{Lie}$$。例如，输出必须采用 $$[p_{\\mathrm{Lie},1},p_{\\mathrm{Str},1},k_{\\mathrm{Lie},1},p_{\\mathrm{Lie},2},p_{\\mathrm{Str},2},k_{\\mathrm{Lie},2},p_{\\mathrm{Lie},3},p_{\\mathrm{Str},3},k_{\\mathrm{Lie},3}]$$ 的形式。\n\n你的实现必须是一个完整、可运行的程序。",
            "solution": "用户希望验证问题陈述，如果有效，则提供一个完整的解决方案。\n\n### 第 1 步：提取已知条件\n- **控制方程**：该系统由线性常微分方程 (ODE) $\\frac{d\\mathbf{x}}{dt} = \\left(\\mathcal{L}_\\mathrm{RT} + \\mathcal{L}_\\mathrm{chem}\\right)\\mathbf{x}$ 描述。\n- **算子表示**：在一个简化的单区模型中，算子由常数矩阵表示：$\\mathcal{L}_\\mathrm{RT} \\to A$ 和 $\\mathcal{L}_\\mathrm{chem} \\to B$。状态向量为 $\\mathbf{x} \\in \\mathbb{R}^n$。\n- **精确传播子**：在一个时间步长 $\\Delta t$ 内的精确演化算子是 $P_\\mathrm{exact}(\\Delta t) = \\exp\\!\\left(\\Delta t(A+B)\\right)$。\n- **Lie–Trotter 分裂**：一阶近似传播子是 $P_\\mathrm{Lie}(\\Delta t) = \\exp(\\Delta t A)\\exp(\\Delta t B)$。\n- **Strang 分裂**：二阶近似传播子是 $P_\\mathrm{Str}(\\Delta t) = \\exp\\!\\left(\\tfrac{\\Delta t}{2} A\\right)\\exp(\\Delta t B)\\exp\\!\\left(\\tfrac{\\Delta t}{2} A\\right)$。\n- **要计算的量**：\n    1.  **对易子及其范数**：$[A,B] \\equiv AB - BA$ 及其矩阵二范数 $\\lVert [A,B] \\rVert_2$。\n    2.  **分裂误差**：\n        - Lie–Trotter 误差：$\\epsilon_\\mathrm{Lie}(\\Delta t_i) = \\left\\lVert P_\\mathrm{exact}(\\Delta t_i) - P_\\mathrm{Lie}(\\Delta t_i) \\right\\rVert_2$。\n        - Strang 误差：$\\epsilon_\\mathrm{Str}(\\Delta t_i) = \\left\\lVert P_\\mathrm{exact}(\\Delta t_i) - P_\\mathrm{Str}(\\Delta t_i) \\right\\rVert_2$。\n    3.  **标度指数**：$p_\\mathrm{Lie}$ 和 $p_\\mathrm{Str}$，通过对 $\\log \\epsilon$ 与 $\\log \\Delta t$ 进行最小二乘拟合的斜率来估计。如果误差在数值上为零，则指数定义为 $0.0$。\n    4.  **Lie–Trotter 系数**：$k_\\mathrm{Lie} = \\epsilon_\\mathrm{Lie}(\\Delta t_\\mathrm{min})\\big/\\left(\\Delta t_\\mathrm{min}^2 \\,\\lVert [A,B] \\rVert_2\\right)$。如果 $\\lVert [A,B] \\rVert_2 = 0$，则 $k_\\mathrm{Lie} = 0.0$。\n- **范数**：所有范数均为矩阵二范数 ($\\lVert \\cdot \\rVert_2$)。\n- **时间步长**：$\\Delta t \\in \\{10^{-5},\\,2\\times 10^{-5},\\,5\\times 10^{-5},\\,10^{-4},\\,2\\times 10^{-4},\\,5\\times 10^{-4},\\,10^{-3}\\}$。\n- **测试用例**：\n    - 用例 1：$A = \\begin{pmatrix}-0.1  0 \\\\ 0  -0.5\\end{pmatrix}, B = \\begin{pmatrix}-0.2  0 \\\\ 0  -0.3\\end{pmatrix}$。\n    - 用例 2：$A = \\begin{pmatrix}-1.0  5.0 \\\\ 0.0  -0.5\\end{pmatrix}, B = \\begin{pmatrix}-0.3  0.0 \\\\ 2.0  -2.0\\end{pmatrix}$。\n    - 用例 3：$A = \\begin{pmatrix}-50.0  100.0 \\\\ 0.0  -30.0\\end{pmatrix}, B = \\begin{pmatrix}-2.0  -40.0 \\\\ 0.0  -1.0\\end{pmatrix}$。\n- **输出格式**：表示为逗号分隔的结果列表的单行：$[p_{\\mathrm{Lie},1}, p_{\\mathrm{Str},1}, k_{\\mathrm{Lie},1}, \\dots]$。\n\n### 第 2 步：使用提取的已知条件进行验证\n对问题进行严格验证。\n1.  **科学依据**：该问题根植于常微分方程数值分析这一成熟领域。算子分裂方法（Lie–Trotter、Strang）是解决复杂系统的标准技术，这些系统的动力学可以分解为多个可独立求解的部分。使用 Baker–Campbell–Hausdorff (BCH) 公式分析分裂误差是该理论的基石。对于非对易算子，预测的误差标度关系 $\\epsilon_\\mathrm{Lie} \\propto (\\Delta t)^2$ 和 $\\epsilon_\\mathrm{Str} \\propto (\\Delta t)^3$ 是基本结果。该问题建立了一个标准的数值实验来验证这些理论预测。它在科学上是合理的。\n2.  **适定的**：该问题是适定的。所有矩阵、时间步长以及待计算量的公式都已明确提供。计算涉及标准的矩阵运算（乘法、加法）、矩阵指数和矩阵范数，所有这些都会产生唯一且明确定义的结果。通过最小二乘拟合来估计标度指数的过程也是一个标准的确定性过程。特殊情况，如对易子为零时，已用明确的规则处理，确保没有歧义。\n3.  **客观性**：该问题使用精确无歧义的数学语言陈述，不含主观或基于意见的内容。\n\n该问题没有表现出问题验证清单中列出的任何缺陷（例如，科学上不合理、不完整、矛盾、不可行）。因此，它被认为是有效的。\n\n### 第 3 步：结论和行动\n该问题是**有效的**。将提供一个解决方案。\n\n### 基于原理的设计\n该解决方案是一个数值实验，旨在验证算子分裂方法的理论误差特性。其理论基础是 Baker–Campbell–Hausdorff (BCH) 公式，该公式用 $X$、$Y$ 及其嵌套对易子给出了 $\\log(\\exp(X)\\exp(Y))$ 的表达式。\n\n对于 Lie–Trotter 分裂，BCH 公式意味着：\n$$ \\exp(\\Delta t A)\\exp(\\Delta t B) = \\exp\\left(\\Delta t(A+B) + \\frac{(\\Delta t)^2}{2}[A,B] + \\mathcal{O}((\\Delta t)^3)\\right) $$\n因此，近似传播子和精确传播子之间的差异是：\n$$ P_\\mathrm{Lie}(\\Delta t) - P_\\mathrm{exact}(\\Delta t) \\approx \\frac{(\\Delta t)^2}{2}[A,B] $$\n对于小的 $\\Delta t$。取范数，我们得到主阶误差：\n$$ \\epsilon_\\mathrm{Lie}(\\Delta t) = \\lVert P_\\mathrm{Lie}(\\Delta t) - P_\\mathrm{exact}(\\Delta t) \\rVert_2 \\approx \\frac{(\\Delta t)^2}{2} \\lVert [A,B] \\rVert_2 $$\n这预测误差与时间步长成二次方关系，因此 $p_\\mathrm{Lie} \\approx 2$。它还预测系数 $k_\\mathrm{Lie} = \\epsilon_\\mathrm{Lie}/(\\Delta t^2 \\lVert [A,B] \\rVert_2)$ 应该近似为 $0.5$。\n\n对于 Strang 分裂，对称组合导致 $(\\Delta t)^2$ 误差项的抵消。主误差项是 $(\\Delta t)^3$ 阶，并涉及更高阶的对易子：\n$$ P_\\mathrm{Str}(\\Delta t) - P_\\mathrm{exact}(\\Delta t) = C_1 (\\Delta t)^3 [B,[B,A]] + C_2 (\\Delta t)^3 [A,[A,B]] + \\mathcal{O}((\\Delta t)^4) $$\n其中 $C_1$ 和 $C_2$ 是常数。这预测误差与时间步长成三次方关系，因此 $p_\\mathrm{Str} \\approx 3$。\n\n如果算子对易，即 $[A,B]=0$，那么所有更高阶的对易子也为零。在这种情况下，$\\exp(\\Delta t A)\\exp(\\Delta t B) = \\exp(\\Delta t(A+B))$，两种分裂方案都变得精确。误差 $\\epsilon_\\mathrm{Lie}$ 和 $\\epsilon_\\mathrm{Str}$ 为零，并且根据问题要求，标度指数定义为 $0.0$。\n\n算法将系统地实现这些计算：\n1.  对于每个测试用例，定义矩阵 $A$ 和 $B$。\n2.  计算对易子 $[A,B]$ 及其二范数。这能立即确定是对易情况还是非对易情况。\n3.  一个循环遍历规定的时间步长集合 $\\{\\Delta t_i\\}$。在每次迭代中：\n    a. 计算精确传播子 $P_\\mathrm{exact} = \\exp(\\Delta t (A+B))$。\n    b. 根据其定义计算近似传播子 $P_\\mathrm{Lie}$ 和 $P_\\mathrm{Str}$。\n    c. 计算并存储差值的二范数 $\\epsilon_\\mathrm{Lie}$ 和 $\\epsilon_\\mathrm{Str}$。\n4.  循环结束后，使用收集到的误差数据来寻找标度指数。对误差的对数与时间步长的对数应用线性最小二乘拟合。所得直线的斜率对应于标度指数。这等效于拟合幂律 $\\epsilon = C(\\Delta t)^p$。\n5.  最后，在最小时间步长 $\\Delta t_\\mathrm{min}$ 处，使用其定义计算系数 $k_\\mathrm{Lie}$。将此值与 $0.5$ 的理论预测进行比较。\n6.  对数值上为零的对易子或误差的特殊条件按规定处理。\n\n该实现将依赖于 `numpy` 来处理矩阵对象和操作，并依赖于 `scipy.linalg.expm` 来计算矩阵指数，这是一个适用于此任务的稳健而准确的算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes operator-splitting errors and validates time-step scalings for three test cases,\n    as specified in the problem statement.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.array([[-0.1, 0.0], [0.0, -0.5]]),\n            \"B\": np.array([[-0.2, 0.0], [0.0, -0.3]]),\n        },\n        {\n            \"A\": np.array([[-1.0, 5.0], [0.0, -0.5]]),\n            \"B\": np.array([[-0.3, 0.0], [2.0, -2.0]]),\n        },\n        {\n            \"A\": np.array([[-50.0, 100.0], [0.0, -30.0]]),\n            \"B\": np.array([[-2.0, -40.0], [0.0, -1.0]]),\n        }\n    ]\n\n    # Define the time-step sweep. All quantities are treated as dimensionless.\n    delta_t_sweep = np.array([1e-5, 2e-5, 5e-5, 1e-4, 2e-4, 5e-4, 1e-3])\n    log_dts = np.log(delta_t_sweep)\n\n    results = []\n    \n    # A small tolerance for floating point comparisons to zero.\n    ZERO_TOLERANCE = 1e-15\n\n    for case in test_cases:\n        A = case[\"A\"]\n        B = case[\"B\"]\n        \n        # 1. Compute the commutator [A,B] and its matrix two-norm.\n        commutator = A @ B - B @ A\n        norm_commutator = np.linalg.norm(commutator, 2)\n        \n        errors_lie = []\n        errors_str = []\n        \n        # 2. Compute operator-norm errors for the sweep of time steps.\n        for dt in delta_t_sweep:\n            # Exact propagator\n            P_exact = expm(dt * (A + B))\n            \n            # Lie-Trotter propagator and error\n            # Propagator is exp(dt*A)exp(dt*B) as per the error formula\n            P_lie = expm(dt * A) @ expm(dt * B)\n            err_lie = np.linalg.norm(P_exact - P_lie, 2)\n            errors_lie.append(err_lie)\n            \n            # Strang propagator and error\n            P_str = expm(0.5 * dt * A) @ expm(dt * B) @ expm(0.5 * dt * A)\n            err_str = np.linalg.norm(P_exact - P_str, 2)\n            errors_str.append(err_str)\n            \n        errors_lie = np.array(errors_lie)\n        errors_str = np.array(errors_str)\n\n        # 3. Estimate empirical scaling exponents p_Lie and p_Str.\n        \n        # Lie-Trotter exponent p_lie\n        if np.all(errors_lie  ZERO_TOLERANCE):\n            p_lie = 0.0\n        else:\n            # Filter out non-positive errors to avoid log errors\n            valid_indices = errors_lie > ZERO_TOLERANCE\n            # Perform least-squares fit on log-log data; slope is the exponent\n            p_lie, _ = np.polyfit(log_dts[valid_indices], np.log(errors_lie[valid_indices]), 1)\n            \n        # Strang exponent p_str\n        if np.all(errors_str  ZERO_TOLERANCE):\n            p_str = 0.0\n        else:\n            valid_indices = errors_str > ZERO_TOLERANCE\n            p_str, _ = np.polyfit(log_dts[valid_indices], np.log(errors_str[valid_indices]), 1)\n            \n        # 4. Compute the coefficient k_Lie.\n        if norm_commutator  ZERO_TOLERANCE:\n            k_lie = 0.0\n        else:\n            dt_min = delta_t_sweep[0]\n            err_lie_min = errors_lie[0]\n            k_lie = err_lie_min / (dt_min**2 * norm_commutator)\n            \n        results.extend([p_lie, p_str, k_lie])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "高效且稳定的时间积分是数值模拟的核心，尤其是在宇宙学辐射转移中，物理过程发生在多个迥异的时间尺度上。为了确保数值解的稳定性和准确性，时间步长必须由最快的物理过程所限制，例如光子的传播（CFL条件）、宇宙学红移、吸收以及化学反应。本实践要求你从基本原理出发，推导出一个综合的、自适应的时间步长约束，这对于开发能够准确捕捉复杂动态演化的鲁棒模拟代码至关重要。",
            "id": "3469642",
            "problem": "你的任务是，在宇宙膨胀背景下，为宇宙学辐射转移和电离动力学的显式更新推导并实现一个类似 Courant–Friedrichs–Lewy (CFL) 的自适应时间步长约束。推导必须从膨胀宇宙中辐射的基本平衡和运动学定义、双曲平流的显式数值稳定性要求以及一阶动力学速率方程出发。\n\n从以下基础出发：\n- 在哈勃膨胀率 $H(t)$ 下，一个空间均匀、各向同性的膨胀宇宙中，针对比强度 $I(\\nu)$ 的宇宙学辐射转移方程，用共动空间坐标和频率平流表示为：\n$$\n\\frac{\\partial I}{\\partial t} + c\\,\\mathbf{n}\\cdot\\nabla I - H\\,\\nu\\,\\frac{\\partial I}{\\partial \\nu} = - c\\,\\kappa\\, I + j,\n$$\n其中 $c$ 是光速，$\\kappa$ 是单位为 $\\mathrm{m}^{-1}$ 的吸收系数，$j$ 是发射率，$H$ 是单位为 $\\mathrm{s}^{-1}$ 的哈勃参数。就本问题而言，你将考虑一个用于输运和化学子步骤的显式时间积分器，该积分器受稳定性和精度约束。\n- 标量氢电离分数 $x(t)$ 服从一个一阶速率方程：\n$$\n\\frac{dx}{dt} = \\Gamma\\,(1 - x) - \\alpha_{\\mathrm{B}}\\,n_e\\,x,\n$$\n其中 $\\Gamma$ 是单位为 $\\mathrm{s}^{-1}$ 的光致电离率，$\\alpha_{\\mathrm{B}}$ 是单位为 $\\mathrm{m}^3\\,\\mathrm{s}^{-1}$ 的B类复合系数，$n_e$ 是单位为 $\\mathrm{m}^{-3}$ 的电子数密度。在单一物种电离近似下，取 $n_e \\approx x\\,n_{\\mathrm{H}}$，其中 $n_{\\mathrm{H}}$ 是总氢数密度。\n\n从这些基础出发，推导一个复合的显式时间步长约束，该约束同时强制满足以下条件：\n- 在均匀网格尺寸 $\\Delta x$ 上的空间平流光行约束，即特征线在一步内穿越不超过一个网格的要求。\n- 由宇宙学红移在均匀频率箱宽度 $\\Delta \\nu$ 上引起的频率空间平流约束。\n- 一个由 $-c\\,\\kappa\\,I$ 项引起的吸收致强度变化约束，限制每步中 $I$ 的分数减量。\n- 一个由动力学速率方程决定的电离分数变化约束，限制每步中 $x$ 的分数变化。\n\n从第一性原理出发，用参数 $\\Delta x$、$\\Delta \\nu$、$\\nu$、$H$、$\\kappa$、$c$、$x$、$n_{\\mathrm{H}}$、$\\Gamma$ 和 $\\alpha_{\\mathrm{B}}$，以及用户指定的稳定/精度分数 $C_x$、$C_\\nu$、$\\varepsilon_I$ 和 $\\varepsilon_x$ 来推导每个约束。这些分数分别限制了空间和频率平流的 Courant 数，以及每步中强度和电离分数允许的分数变化。通过取各单个约束的最小值，将它们组合成一个单一的建议时间步长 $\\Delta t_{\\mathrm{prop}}$。\n\n使用带有嵌入式两半步误差估计器的显式前向欧拉方法，为电离更新实现一个自适应步长接受程序：\n- 给定一个候选步长 $\\Delta t$，计算一个全步更新 $x_{\\mathrm{full}} = x + \\Delta t\\,f(x)$，其中 $f(x) = \\Gamma\\,(1-x) - \\alpha_{\\mathrm{B}}\\,n_{\\mathrm{H}}\\,x^2$。\n- 计算一个两半步估计 $x_{\\mathrm{half}} = x + \\frac{\\Delta t}{2}\\,f(x)$，然后 $x_{\\mathrm{two}} = x_{\\mathrm{half}} + \\frac{\\Delta t}{2}\\,f(x_{\\mathrm{half}})$。\n- 估计局部误差 $e = |x_{\\mathrm{full}} - x_{\\mathrm{two}}|$，如果 $e \\le \\mathrm{tol}_x$ 则接受该步长，否则根据一个与 $(\\mathrm{tol}_x/e)^{1/2}$ 成比例的类比例-积分规则减小 $\\Delta t$ 并重试，此过程受合理的安全因子和迭代次数限制。\n- 在试算更新中强制施加物理边界 $0 \\le x \\le 1$。\n\n数值和输出要求：\n- 所有输出必须以秒为单位表示，并四舍五入到最接近的整数秒。\n- 你的程序必须生成单行输出，其中包含接受的时间步长（每个测试用例一个），格式为用方括号括起来的逗号分隔列表（例如 $[t_1,t_2,t_3,t_4]$）。\n- 不允许用户输入；所有参数均在下方指定。\n\n为以下测试参数套件实现上述过程，以测试不同的物理机制。请精确使用所述的常数和参数。\n\n- 测试用例 1 (一般情况)：\n  - $\\Delta x = 3.086\\times 10^{19}\\,\\mathrm{m}$, $\\Delta \\nu = 1.0\\times 10^{14}\\,\\mathrm{Hz}$, $\\nu = 3.0\\times 10^{15}\\,\\mathrm{Hz}$,\n  - $H = 1.0\\times 10^{-17}\\,\\mathrm{s}^{-1}$, $\\kappa = 1.3\\times 10^{-19}\\,\\mathrm{m}^{-1}$,\n  - $n_{\\mathrm{H}} = 200.0\\,\\mathrm{m}^{-3}$, $\\Gamma = 1.0\\times 10^{-12}\\,\\mathrm{s}^{-1}$, $\\alpha_{\\mathrm{B}} = 2.6\\times 10^{-19}\\,\\mathrm{m}^3\\,\\mathrm{s}^{-1}$,\n  - $x_0 = 0.10$, $C_x = 0.90$, $C_\\nu = 0.90$, $\\varepsilon_I = 0.02$, $\\varepsilon_x = 0.01$, $\\mathrm{tol}_x = 1.0\\times 10^{-4}$。\n- 测试用例 2 (小空间网格边界)：\n  - $\\Delta x = 1.0\\times 10^{16}\\,\\mathrm{m}$, $\\Delta \\nu = 1.0\\times 10^{14}\\,\\mathrm{Hz}$, $\\nu = 3.0\\times 10^{15}\\,\\mathrm{Hz}$,\n  - $H = 1.0\\times 10^{-17}\\,\\mathrm{s}^{-1}$, $\\kappa = 1.3\\times 10^{-19}\\,\\mathrm{m}^{-1}$,\n  - $n_{\\mathrm{H}} = 200.0\\,\\mathrm{m}^{-3}$, $\\Gamma = 5.0\\times 10^{-13}\\,\\mathrm{s}^{-1}$, $\\alpha_{\\mathrm{B}} = 2.6\\times 10^{-19}\\,\\mathrm{m}^3\\,\\mathrm{s}^{-1}$,\n  - $x_0 = 0.50$, $C_x = 0.90$, $C_\\nu = 0.90$, $\\varepsilon_I = 0.02$, $\\varepsilon_x = 0.02$, $\\mathrm{tol}_x = 1.0\\times 10^{-5}$。\n- 测试用例 3 (强吸收边情况)：\n  - $\\Delta x = 3.086\\times 10^{19}\\,\\mathrm{m}$, $\\Delta \\nu = 1.0\\times 10^{14}\\,\\mathrm{Hz}$, $\\nu = 3.0\\times 10^{15}\\,\\mathrm{Hz}$,\n  - $H = 1.0\\times 10^{-17}\\,\\mathrm{s}^{-1}$, $\\kappa = 1.0\\times 10^{-16}\\,\\mathrm{m}^{-1}$,\n  - $n_{\\mathrm{H}} = 200.0\\,\\mathrm{m}^{-3}$, $\\Gamma = 1.0\\times 10^{-13}\\,\\mathrm{s}^{-1}$, $\\alpha_{\\mathrm{B}} = 2.6\\times 10^{-19}\\,\\mathrm{m}^3\\,\\mathrm{s}^{-1}$,\n  - $x_0 = 0.01$, $C_x = 0.90$, $C_\\nu = 0.90$, $\\varepsilon_I = 0.01$, $\\varepsilon_x = 0.005$, $\\mathrm{tol}_x = 1.0\\times 10^{-6}$。\n- 测试用例 4 (宇宙学红移主导)：\n  - $\\Delta x = 3.086\\times 10^{22}\\,\\mathrm{m}$, $\\Delta \\nu = 1.0\\times 10^{9}\\,\\mathrm{Hz}$, $\\nu = 3.0\\times 10^{15}\\,\\mathrm{Hz}$,\n  - $H = 5.0\\times 10^{-16}\\,\\mathrm{s}^{-1}$, $\\kappa = 1.3\\times 10^{-19}\\,\\mathrm{m}^{-1}$,\n  - $n_{\\mathrm{H}} = 200.0\\,\\mathrm{m}^{-3}$, $\\Gamma = 1.0\\times 10^{-14}\\,\\mathrm{s}^{-1}$, $\\alpha_{\\mathrm{B}} = 2.6\\times 10^{-19}\\,\\mathrm{m}^3\\,\\mathrm{s}^{-1}$,\n  - $x_0 = 0.90$, $C_x = 0.90$, $C_\\nu = 0.90$, $\\varepsilon_I = 0.02$, $\\varepsilon_x = 0.01$, $\\mathrm{tol}_x = 1.0\\times 10^{-4}$。\n\n附加要求：\n- 使用 $c = 2.99792458\\times 10^{8}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 程序必须用 Python 编写，并按指定格式精确打印一行输出，其中包含上述用例的接受时间步长（以秒为单位，四舍五入到最接近的整数）。",
            "solution": "该问题要求为求解宇宙学辐射转移方程和电离动力学耦合的显式数值方案，推导并实现一个复合时间步长约束。推导必须从每个物理过程（空间平流、频率空间平流（宇宙学红移）、吸收、化学反应）的第一性原理出发。随后，此时间步长将用作电离更新的自适应步长控制算法的初始猜测值。\n\n推导过程通过分析控制方程的每一项，并为显式前向欧拉时间步进法建立确保数值稳定性和精度的条件。这些单独的时间步长约束（记为 $\\Delta t_i$）随后被组合起来，以找到最严格的限制。\n\n提供的控制方程是：\n1.  比强度 $I(\\nu, t)$ 的宇宙学辐射转移方程（RTE）：\n    $$\n    \\frac{\\partial I}{\\partial t} + c\\,\\mathbf{n}\\cdot\\nabla I - H\\,\\nu\\,\\frac{\\partial I}{\\partial \\nu} = - c\\,\\kappa\\, I + j\n    $$\n2.  电离分数 $x(t)$ 的速率方程：\n    $$\n    \\frac{dx}{dt} = \\Gamma\\,(1 - x) - \\alpha_{\\mathrm{B}}\\,n_H\\,x^2\n    $$\n    使用近似 $n_e \\approx x\\,n_{\\mathrm{H}}$。代入后得到显式速率函数 $f(x) = \\frac{dx}{dt} = \\Gamma(1-x) - \\alpha_{\\mathrm{B}} n_{\\mathrm{H}} x^2$。\n\n我们现在将从这些方程中推导所需的四个时间步长约束。\n\n**1. 空间平流约束 (Courant-Friedrichs-Lewy 条件)**\n\nRTE 中的 $c\\,\\mathbf{n}\\cdot\\nabla I$ 项代表光子以光速 $c$ 进行的空间输运。对于在尺寸为 $\\Delta x$ 的均匀网格上的一维显式有限差分格式，必须满足 Courant-Friedrichs-Lewy (CFL) 条件以确保数值稳定性。该原则要求数值依赖域必须包含物理依赖域。在平流的背景下，这意味着信息（此处为光子）在单个时间步长 $\\Delta t$ 内传播的距离不能超过一个网格单元。这表示为：\n$$\nc \\Delta t \\le \\Delta x\n$$\n问题引入了一个用户指定的 Courant 数 $C_x \\in (0, 1]$ 作为安全因子。因此，约束条件是：\n$$\nc \\Delta t \\le C_x \\Delta x\n$$\n对 $\\Delta t$ 求解，得到空间平流时间步长限制 $\\Delta t_x$：\n$$\n\\Delta t_x = C_x \\frac{\\Delta x}{c}\n$$\n\n**2. 频率空间平流约束 (红移)**\n\nRTE 中的 $-H\\,\\nu\\,\\frac{\\partial I}{\\partial \\nu}$ 项描述了由于宇宙哈勃膨胀导致光子在频率空间中的平流。该平流的“速度”为 $v_\\nu = \\frac{d\\nu}{dt} = -H\\nu$。与空间 CFL 条件类似，对于在频率箱宽度为 $\\Delta \\nu$ 的频率网格上的显式格式，光子频率在时间步长 $\\Delta t$ 内的变化不能大于频率箱的宽度。频率变化的幅度为 $|\\Delta \\nu_{\\text{adv}}| = |v_\\nu| \\Delta t = H\\nu\\Delta t$。稳定性条件为：\n$$\nH\\nu\\Delta t \\le \\Delta \\nu\n$$\n引入频率空间 Courant 数 $C_\\nu$ 作为安全因子，我们有：\n$$\nH\\nu\\Delta t \\le C_\\nu \\Delta \\nu\n$$\n对 $\\Delta t$ 求解，得到频率平流时间步长限制 $\\Delta t_\\nu$：\n$$\n\\Delta t_\\nu = C_\\nu \\frac{\\Delta \\nu}{H \\nu}\n$$\n\n**3. 吸收致强度变化约束**\n\nRTE 右侧的 $-c\\,\\kappa\\,I$ 项是代表光子吸收的汇项。仅由吸收引起的强度时间演化为 $\\frac{\\partial I}{\\partial t} = -c\\,\\kappa\\,I$。一个显式前向欧拉更新步为 $I^{n+1} = I^n - \\Delta t (c\\kappa I^n)$。问题要求将强度的分数变化 $\\frac{|I^{n+1} - I^n|}{I^n}$ 限制在一个用户指定的容差 $\\varepsilon_I$ 内。\n$$\n\\frac{|I^n - \\Delta t c\\kappa I^n - I^n|}{I^n} = \\frac{|-\\Delta t c\\kappa I^n|}{I^n} = c\\kappa\\Delta t \\le \\varepsilon_I\n$$\n这直接给出了吸收时间步长限制 $\\Delta t_I$：\n$$\n\\Delta t_I = \\frac{\\varepsilon_I}{c \\kappa}\n$$\n这个条件确保强度不会因为吸收而在单步内发生大的分数变化，这对精度至关重要。\n\n**4. 电离分数变化约束**\n\n电离分数 $x$ 的演化由常微分方程 (ODE) $\\frac{dx}{dt} = f(x)$ 控制，其中 $f(x) = \\Gamma(1-x) - \\alpha_{\\mathrm{B}} n_{\\mathrm{H}} x^2$。与吸收约束类似，我们必须将每步 $x$ 的分数变化限制在一个指定的精度参数 $\\varepsilon_x$ 内。在一步 $\\Delta t$ 内 $x$ 的变化近似为 $\\Delta x_{\\text{change}} \\approx \\Delta t \\left|\\frac{dx}{dt}\\right|$。分数变化为 $\\frac{|\\Delta x_{\\text{change}}|}{x}$。\n$$\n\\frac{\\Delta t \\left| f(x) \\right|}{x} \\le \\varepsilon_x\n$$\n对 $\\Delta t$ 求解，得到化学时间步长限制，我们将其记为 $\\Delta t_{\\text{chem}}$：\n$$\n\\Delta t_{\\text{chem}} = \\frac{\\varepsilon_x x}{\\left| f(x) \\right|} = \\frac{\\varepsilon_x x}{\\left|\\Gamma(1-x) - \\alpha_{\\mathrm{B}} n_{\\mathrm{H}} x^2\\right|}\n$$\n如果系统接近平衡，分母 $|f(x)|$ 趋近于 0，$\\Delta t_{\\text{chem}}$ 会变得非常大。这在物理上是合理的，因为在平衡附近，变化的时间尺度很长。\n\n**复合时间步长和自适应控制**\n\n为确保所有物理过程的稳定性和精度，总的建議时间步长 $\\Delta t_{\\mathrm{prop}}$ 必须是各单个约束的最小值：\n$$\n\\Delta t_{\\mathrm{prop}} = \\min(\\Delta t_x, \\Delta t_\\nu, \\Delta t_I, \\Delta t_{\\text{chem}})\n$$\n这个 $\\Delta t_{\\mathrm{prop}}$ 作为电离 ODE 自适应时间步进方案的初始猜测。问题指定了一个基于单个前向欧拉步和两个半步的嵌入式误差估计器。\n给定当前状态 $x_n$ 和一个候选时间步长 $\\Delta t$：\n1.  计算一个全步更新：$x_{\\text{full}} = x_n + \\Delta t \\, f(x_n)$。\n2.  计算一个两步更新：$x_{\\text{half}} = x_n + \\frac{\\Delta t}{2} f(x_n)$，然后是 $x_{\\text{two}} = x_{\\text{half}} + \\frac{\\Delta t}{2} f(x_{\\text{half}})$。\n3.  试算解必须保持在物理边界 $[0, 1]$ 内。\n4.  局部截断误差估计为 $e = |x_{\\text{full}} - x_{\\text{two}}|$。对于此方法，精度较低的解（$x_{\\text{full}}$）的误差阶为 $\\mathcal{O}(\\Delta t^2)$。\n5.  如果 $e \\le \\mathrm{tol}_x$，则接受该步长，其中 $\\mathrm{tol}_x$ 是给定的容差。\n6.  如果被拒绝，则使用嵌入式 Runge-Kutta 方法的标准控制律计算一个新的、更小的时间步长 $\\Delta t_{\\text{new}}$，其目标是使 $e_{\\text{new}} \\approx \\mathrm{tol}_x$：\n    $$\n    \\Delta t_{\\text{new}} = S \\cdot \\Delta t_{\\text{old}} \\left( \\frac{\\mathrm{tol}_x}{e} \\right)^{1/p}\n    $$\n    其中 $p=2$ 是误差估计器的阶，$S$ 是一个安全因子（例如 $S=0.9$）。使用 $\\Delta t_{\\text{new}}$ 重复此过程，直到步长被接受。最终接受的时间步长即为给定测试用例的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements an adaptive time-step constraint for cosmological\n    radiative transfer and ionization kinetics.\n    \"\"\"\n    # Universal constant\n    C_LIGHT = 2.99792458e8  # Speed of light in m/s\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (general case)\n        {'dx': 3.086e19, 'dnu': 1.0e14, 'nu': 3.0e15, 'H': 1.0e-17, 'kappa': 1.3e-19,\n         'nH': 200.0, 'Gamma': 1.0e-12, 'alphaB': 2.6e-19, 'x0': 0.10,\n         'Cx': 0.90, 'Cnu': 0.90, 'eps_I': 0.02, 'eps_x': 0.01, 'tol_x': 1.0e-4},\n        # Test Case 2 (small spatial cell boundary)\n        {'dx': 1.0e16, 'dnu': 1.0e14, 'nu': 3.0e15, 'H': 1.0e-17, 'kappa': 1.3e-19,\n         'nH': 200.0, 'Gamma': 5.0e-13, 'alphaB': 2.6e-19, 'x0': 0.50,\n         'Cx': 0.90, 'Cnu': 0.90, 'eps_I': 0.02, 'eps_x': 0.02, 'tol_x': 1.0e-5},\n        # Test Case 3 (strong absorption edge case)\n        {'dx': 3.086e19, 'dnu': 1.0e14, 'nu': 3.0e15, 'H': 1.0e-17, 'kappa': 1.0e-16,\n         'nH': 200.0, 'Gamma': 1.0e-13, 'alphaB': 2.6e-19, 'x0': 0.01,\n         'Cx': 0.90, 'Cnu': 0.90, 'eps_I': 0.01, 'eps_x': 0.005, 'tol_x': 1.0e-6},\n        # Test Case 4 (cosmological redshift dominated)\n        {'dx': 3.086e22, 'dnu': 1.0e9, 'nu': 3.0e15, 'H': 5.0e-16, 'kappa': 1.3e-19,\n         'nH': 200.0, 'Gamma': 1.0e-14, 'alphaB': 2.6e-19, 'x0': 0.90,\n         'Cx': 0.90, 'Cnu': 0.90, 'eps_I': 0.02, 'eps_x': 0.01, 'tol_x': 1.0e-4},\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        # --- Part 1: Calculate the composite proposed time-step ---\n\n        # Spatial advection constraint (CFL)\n        dt_x = params['Cx'] * params['dx'] / C_LIGHT\n\n        # Frequency-space advection constraint (Redshift)\n        denom_nu = params['H'] * params['nu']\n        dt_nu = (params['Cnu'] * params['dnu'] / denom_nu) if denom_nu > 0 else np.inf\n\n        # Absorption constraint\n        denom_I = C_LIGHT * params['kappa']\n        dt_I = (params['eps_I'] / denom_I) if denom_I > 0 else np.inf\n\n        # Define the ionization rate function f(x) = dx/dt\n        def f_chem(x, p):\n            ion_term = p['Gamma'] * (1.0 - x)\n            recomb_term = p['alphaB'] * p['nH'] * x**2\n            return ion_term - recomb_term\n\n        # Chemistry constraint\n        rate_at_x0 = f_chem(params['x0'], params)\n        if abs(rate_at_x0)  np.finfo(float).eps:\n            dt_chem = np.inf\n        else:\n            dt_chem = params['eps_x'] * params['x0'] / abs(rate_at_x0)\n        \n        # Composite proposed time-step is the minimum of all constraints\n        dt_prop = min(dt_x, dt_nu, dt_I, dt_chem)\n\n        # --- Part 2: Adaptive step acceptance for ionization update ---\n        \n        dt_current = dt_prop\n        accepted_dt = None\n        \n        # Parameters for adaptive control\n        max_iterations = 50\n        safety_factor = 0.9 \n        # The exponent in the update rule is 1/p, where p=2 for this scheme.\n        power = 0.5 \n\n        for _ in range(max_iterations):\n            f = lambda x: f_chem(x, params)\n            \n            # Compute full-step update (Euler method)\n            x_full = params['x0'] + dt_current * f(params['x0'])\n            x_full = np.clip(x_full, 0.0, 1.0) # Enforce physical bounds\n            \n            # Compute two half-step update (embedded method)\n            x_half = params['x0'] + (dt_current / 2.0) * f(params['x0'])\n            x_half = np.clip(x_half, 0.0, 1.0) # Enforce physical bounds\n            \n            x_two = x_half + (dt_current / 2.0) * f(x_half)\n            x_two = np.clip(x_two, 0.0, 1.0) # Enforce physical bounds\n            \n            # Estimate local error\n            error = abs(x_full - x_two)\n            \n            # Acceptance criterion\n            if error = params['tol_x']:\n                accepted_dt = dt_current\n                break\n            \n            # Step rejection and update of dt\n            # If error is zero, the step should be accepted.\n            # Add a small epsilon to denominator for robustness in case error is tiny.\n            if error > 0:\n                dt_current = safety_factor * dt_current * (params['tol_x'] / error)**power\n            else:\n                # Should not happen as error=0 implies acceptance, but as a failsafe\n                # If the error is truly zero, the step is perfect. We can increase it. \n                # Capping the increase to avoid runaway.\n                dt_current *= 2.0 \n\n        if accepted_dt is None:\n            # If the loop finishes without acceptance (unlikely for this problem),\n            # we use the last computed time step as a failsafe.\n            accepted_dt = dt_current\n            \n        # Round the accepted time step to the nearest integer second.\n        # (int(x + 0.5) for positive x rounds half up)\n        results.append(int(accepted_dt + 0.5))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现代宇宙学模拟广泛采用自适应网格加密 (AMR) 技术，以在感兴趣的区域（如高密度结构）集中计算资源。在不同分辨率的网格之间传递信息时，一个核心要求是必须严格保证物理量的守恒，例如光子数。本实践将指导你实现一个守恒的重映算法，通过在粗网格单元内进行分段线性重构并使用斜率限制器，来确保在网格加密和粗化操作中光子总数保持不变，这是确保模拟结果物理真实性的基石。",
            "id": "3469649",
            "problem": "考虑一维周期性区域中宇宙学辐射转移的矩量方程。设辐射场由其单位长度的矩量表示：辐射能量密度 $E$、辐射通量 $F$ 和光子数密度 $N$。对于每个宽度为 $\\Delta x$、中心位置为 $x_i$ 的网格单元 $i$，将单元平均矩量定义为 $M_i = (E_i, F_i, N_i)$，其中 $E_i$、$F_i$ 和 $N_i$ 是该单元上的平均值。自适应网格加密（AMR）操作在粗网格和细网格之间映射矩量。您的任务是为矩量向量 $M = (E, F, N)$ 实现一个在 AMR 加密和粗化操作中保守的重映照算法，并证明光子数的 $L^1$ 范数守恒到机器精度。\n\n基本原理：\n- 光子数矩量 $N$ 是比辐射强度 $I_\\nu$ 的零阶角频率矩，$N = \\int \\int (I_\\nu / h\\nu)\\,\\mathrm{d}\\Omega\\,\\mathrm{d}\\nu$，在物理真实场景中为非负值。\n- 在网格重映照下一个量的守恒性通过操作前后其体积积分的相等来证明。\n- 空间域上非负标量场 $N(x)$ 的 $L^1$ 范数为 $\\|N\\|_1 = \\int |N(x)|\\,\\mathrm{d}x = \\int N(x)\\,\\mathrm{d}x$。\n\n算法要求：\n1. 实现一个长度为 $L$ 的一维周期性区域，将其离散化为 $n$ 个宽度为 $\\Delta x = L/n$ 的粗网格单元，粗单元中心为 $x_i = (i+1/2)\\Delta x$，其中 $i$ 为整数。\n2. 为 AMR 定义一个加密因子 $r \\in \\mathbb{N}$。加密操作将每个粗单元映射为 $r$ 个宽度为 $\\Delta x_f = \\Delta x/r$ 的子细单元，子单元的中点位于父单元内部。\n3. 加密必须在每个粗单元内对每个矩量分量使用分段线性重构：\n   - 对于每个粗单元 $i$，重构 $m(x) = a_i + s_i (x - x_i)$，其中 $a_i$ 是该矩量的粗单元平均值，$s_i$ 是一个受限的斜率。\n   - 使用带有周期性邻居的 MinMod 限制器来估计斜率，以防止伪振荡：$s_i = \\operatorname{minmod}\\big((a_i - a_{i-1})/\\Delta x,(a_{i+1} - a_i)/\\Delta x\\big)$，其中如果 $uv \\le 0$，则 $\\operatorname{minmod}(u,v)$ 等于 $0$，否则等于 $\\operatorname{sign}(u)\\min(|u|,|v|)$。\n   - 对于光子数密度 $N$，通过限制 $|s_i| \\le a_i / \\delta_{\\max}$ 来在加密过程中强制保持正定性，其中 $\\delta_{\\max}$ 是任何子单元中点与 $x_i$ 的最大绝对偏移量；这确保了对于父单元内所有子单元中点的偏移量 $\\delta$，都有 $a_i + s_i \\delta \\ge 0$。\n   - 将线性重构在其子单元中点处的值赋给每个子细单元。对于线性函数，中点法则对于子单元积分是精确的，从而确保了在加密过程中父单元平均值的守恒性。\n4. 粗化必须通过体积加权平均将子细单元的矩量映射回粗单元的矩量。对于大小相等的子单元，这简化为每个父单元内子单元值的算术平均值。\n5. 数值上证明，光子数的 $L^1$ 范数（定义为积分 $\\sum_i N_i \\Delta x$）在经历一次加密后粗化的操作后，在机器精度范围内是守恒的。\n\n科学真实性：\n- 将区域视为周期性的。\n- 确保所有粗单元的 $N_i \\ge 0$；正定性应通过所选的限制器在加密过程中得以保持。\n\n您的程序必须实现上述操作，并为每个测试用例输出执行加密后粗化操作前后积分光子数的绝对差。将每个差值表示为代表光子数量的浮点数。不涉及角度。程序必须生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，“[result1,result2,result3]”）。\n\n测试套件：\n- 测试 1 (均匀场，理想路径): $L = 1.0$, $n = 8$, $r = 2$, 粗单元矩量初始化为对所有 $i$ 都有 $E_i = 10.0$, $F_i = 0.5$, $N_i = 3.0$。\n- 测试 2 (平滑非均匀，周期性): $L = 2.0$, $n = 16$, $r = 4$, 使用 $x_i = (i+1/2)\\Delta x$ 初始化粗单元矩量：\n  - $E_i = 2.0 + 0.1 \\cos(4\\pi x_i / L)$,\n  - $F_i = 0.05 \\sin(2\\pi x_i / L)$,\n  - $N_i = 1.0 + 0.2 \\sin(2\\pi x_i / L)$.\n- 测试 3 (包含极端数量级和零的边界情况): $L = 1.0$, $n = 4$, $r = 3$, 粗单元矩量为：对所有 $i$ 都有 $E_i = 1.0$，对所有 $i$ 都有 $F_i = 0.0$，以及 $N = [10^{-300}, 10^{5}, 2.0, 0.0]$。\n- 测试 4 (强梯度，正定性压力测试): $L = 1.0$, $n = 10$, $r = 5$, 粗单元矩量初始化为 $E_i = 1.0 + 0.01 i$，$F_i = 0.3 i (-1)^i$，以及 $N_i = i^2$，其中 $i = 0,1,\\dots,9$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试 1 到测试 4 的光子数绝对 $L^1$ 差异，格式为用方括号括起来的逗号分隔列表，单位为光子数，例如，“[d1,d2,d3,d4]”。",
            "solution": "问题陈述要求在一个经历自适应网格加密（AMR）的一维周期性网格上，实现并验证一个用于辐射矩量向量的保守重映照算法。核心任务是证明总光子数（由光子数密度 $N$ 的 $L^1$ 范数表示）在经历一个网格加密后粗化的循环后，能够保持到机器精度的守恒。\n\n守恒原理在以连续性方程表达的物理定律的数值解中至关重要。如果在计算域内没有源、汇或穿过域边界的通量，总积分量保持恒定，则该数值格式是保守的。对于AMR，这意味着一个父单元中的总量必须等于其加密后所有子单元中的总量之和，粗化过程反之亦然。所提出的算法在构造上被设计为完全保守的。\n\n设一维周期性区域的长度为 $L$，离散化为 $n$ 个粗网格单元。每个粗单元 $i$ (对于 $i \\in \\{0, \\dots, n-1\\}$) 的宽度为 $\\Delta x = L/n$，其中心位于 $x_i = (i+1/2)\\Delta x$。系统的状态由单元平均矩量向量 $M_i = (E_i, F_i, N_i)$ 描述。域内的总光子数，由于 $N \\ge 0$，等同于 $N$ 的 $L^1$ 范数，由 $\\sum_{i=0}^{n-1} N_i \\Delta x$ 给出。\n\nAMR 操作定义如下：\n\n**1. 加密（从粗到细的映射）**\n\n加密过程用 $r$ 个更小的、等宽的子单元替换单个粗父单元，其中 $r$ 是加密因子。每个子单元的宽度为 $\\Delta x_f = \\Delta x / r$。为了在保持守恒的同时为这些新的细单元赋值，在每个父单元内执行数据的子网格重构。\n\n- **分段线性重构**：对于每个矩量分量（例如 $E、F$ 或 $N$），在每个粗单元 $i$ 内重构一个线性函数 $m(x)$。选择此函数，使其在单元上的平均值等于已知的粗单元平均值 $a_i$。重构的形式为 $m(x) = a_i + s_i (x - x_i)$，其中 $s_i$ 是一个精心选择的斜率。将 $m(x)$ 在单元 $i$ 上从 $x_i - \\Delta x/2$ 到 $x_i + \\Delta x/2$ 进行积分，可以确认其平均值为 $a_i$，因为奇函数项 $s_i(x-x_i)$ 的积分为零。\n\n- **斜率限制**：朴素的斜率计算可能会在陡峭梯度附近引入伪振荡（Gibbs phenomenon）。为防止这种情况，采用了斜率限制器。问题指定了 MinMod 限制器，这是确保单调性的标准选择。斜率 $s_i$ 通过比较后向和前向差分斜率来计算：\n$$s_i = \\operatorname{minmod}\\left(\\frac{a_i - a_{i-1}}{\\Delta x}, \\frac{a_{i+1} - a_i}{\\Delta x}\\right)$$\n邻居 $a_{i-1}$ 和 $a_{i+1}$ 使用周期性边界条件确定。如果两个参数符号相同，$\\operatorname{minmod}(u,v)$ 函数返回绝对值较小的参数，否则返回零。这种选择会在局部极值点处使重构变得平坦，从而防止过冲和下冲。\n\n- **正定性保持**：光子数密度 $N$ 是一个物理上的非负量。如果斜率 $s_i$ 过大，线性重构 $N(x) = N_i + s_i(x - x_i)$ 可能会在单元边缘产生负值。为了强制保持正定性，$N$ 分量的斜率大小会受到进一步约束。重构值在所有细单元中点处必须为非负。细单元中点与其父单元中心的最大距离为 $\\delta_{\\max}$。对于一个有 $r$ 个子单元的父单元，此距离为 $\\delta_{\\max} = \\frac{\\Delta x}{2}(1 - 1/r)$。在单元内所有评估点上 $N(x) \\ge 0$ 的条件意味着 $|s_i| \\le N_i / \\delta_{\\max}$。此界限在通过 MinMod 限制器计算出斜率 $s_i$ 后应用。\n\n- **细单元赋值**：问题规定，赋给子细单元的值是在该子单元中点处评估的线性重构值。线性函数的一个关键特性是，区间中点处的值完全等于该函数在该区间上的平均值。因此，该赋值方法在重构剖面下能为每个细单元精确计算其单元平均值。对 $r$ 个子单元的总光子数求和得到 $\\sum_{j=0}^{r-1} N^{\\text{fine}}_{ij} \\Delta x_f = \\sum_{j=0}^{r-1} [N_i + s_i(x_{ij} - x_i)] \\Delta x_f = r N_i \\Delta x_f + s_i \\Delta x_f \\sum_{j=0}^{r-1} (x_{ij} - x_i)$。由于子单元的对称放置，偏移量之和 $\\sum (x_{ij} - x_i)$ 为零。因此，子单元中的总光子数为 $r N_i \\Delta x_f = r N_i (\\Delta x / r) = N_i \\Delta x$，这恰好是父单元的光子数。因此，加密步骤是完全保守的。\n\n**2. 粗化（从细到粗的映射）**\n\n粗化是加密的逆操作。它将 $r$ 个子单元的值映射回单个父单元。守恒原理规定，粗化后的值必须是子单元值的体积加权平均值。由于所有子单元的宽度 $\\Delta x_f$ 相同，这简化为算术平均值：\n$$a_i^{\\text{coarse}} = \\frac{1}{r} \\sum_{j=0}^{r-1} a_{ij}^{\\text{fine}}$$\n新的粗单元中的总量为 $a_i^{\\text{coarse}} \\Delta x = (\\frac{1}{r} \\sum_{j=0}^{r-1} a_{ij}^{\\text{fine}}) (r \\Delta x_f) = \\sum_{j=0}^{r-1} a_{ij}^{\\text{fine}} \\Delta x_f$，这正是细单元中量的总和。因此，粗化步骤也是完全保守的。\n\n**3. 守恒性验证**\n\n由于加密和粗化操作在数学上都被设计为完全保守的，因此对初始数据集执行一个加密后粗化的循环应该能精确地返回原始数据集。程序将计算此循环前的总光子数 $I_{\\text{initial}} = \\sum (N_i \\Delta x)$ 和循环后的总光子数 $I_{\\text{final}} = \\sum (N'_i \\Delta x)$。绝对差 $|I_{\\text{initial}} - I_{\\text{final}}|$ 在浮点算术精度范围内应为零。所实现的代码将为几个测试用例计算此差异，以数值方式证明这一守恒性质。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the AMR remapping simulation for all test cases.\n    \"\"\"\n\n    def minmod(u, v):\n        \"\"\"\n        Calculates the MinMod function.\n        Returns the argument with the smallest absolute value if signs are the same,\n        otherwise returns 0.\n        \"\"\"\n        if u * v = 0:\n            return 0.0\n        elif abs(u)  abs(v):\n            return u\n        else:\n            return v\n\n    def remap(coarse_moments, L, n, r):\n        \"\"\"\n        Performs a full refinement-then-coarsening cycle.\n        \n        Args:\n            coarse_moments (np.array): Array of shape (n, 3) for (E, F, N).\n            L (float): Domain length.\n            n (int): Number of coarse cells.\n            r (int): Refinement factor.\n\n        Returns:\n            np.array: The new coarse moments array of shape (n, 3) after the cycle.\n        \"\"\"\n        \n        # --- Refinement Step ---\n        dx = L / n\n        dx_f = dx / r\n        num_fine_cells = n * r\n        fine_moments = np.zeros((num_fine_cells, 3))\n        \n        # Max offset for positivity constraint on N\n        # This is max(|x_fine_midpoint - x_coarse_midpoint|)\n        # delta_max is 0 if r=1, but problem constraints ensure r>1\n        delta_max = (dx / 2.0) * (1.0 - 1.0 / r) if r > 1 else 0.0\n\n        # Process each moment component (E, F, N)\n        for k in range(3):\n            moment_component = coarse_moments[:, k]\n            \n            for i in range(n):\n                # Periodic boundary conditions for neighbors\n                i_prev = (i - 1 + n) % n\n                i_next = (i + 1) % n\n                \n                a_i = moment_component[i]\n                a_prev = moment_component[i_prev]\n                a_next = moment_component[i_next]\n\n                # Calculate slope with MinMod limiter\n                s_i = minmod((a_i - a_prev) / dx, (a_next - a_i) / dx)\n\n                # Enforce positivity for the N component (k=2)\n                if k == 2 and a_i > 0 and delta_max > 0:\n                    max_slope_mag = a_i / delta_max\n                    s_i = np.sign(s_i) * min(abs(s_i), max_slope_mag)\n                elif k == 2 and a_i == 0:\n                    s_i = 0.0\n\n                # Assign values to the r fine child cells\n                for j in range(r):\n                    # Offset of fine cell midpoint from coarse cell midpoint\n                    offset = dx * ((j + 0.5) / r - 0.5)\n                    fine_val = a_i + s_i * offset\n                    \n                    fine_idx = i * r + j\n                    fine_moments[fine_idx, k] = fine_val\n\n        # --- Coarsening Step ---\n        coarsened_moments = np.zeros((n, 3))\n        for i in range(n):\n            # The children of coarse cell i are in the slice [i*r : (i+1)*r]\n            start_idx = i * r\n            end_idx = (i + 1) * r\n            \n            # Average the fine cell values to get the new coarse cell value\n            for k in range(3):\n                coarsened_moments[i, k] = np.mean(fine_moments[start_idx:end_idx, k])\n                \n        return coarsened_moments\n\n\n    test_cases = [\n        {\n            \"L\": 1.0, \"n\": 8, \"r\": 2,\n            \"moments\": np.array([[10.0, 0.5, 3.0] for _ in range(8)])\n        },\n        {\n            \"L\": 2.0, \"n\": 16, \"r\": 4,\n            \"init_func\": lambda x, L: [\n                2.0 + 0.1 * np.cos(4 * np.pi * x / L),\n                0.05 * np.sin(2 * np.pi * x / L),\n                1.0 + 0.2 * np.sin(2 * np.pi * x / L)\n            ]\n        },\n        {\n            \"L\": 1.0, \"n\": 4, \"r\": 3,\n            \"moments\": np.array([\n                [1.0, 0.0, 1e-300],\n                [1.0, 0.0, 1e5],\n                [1.0, 0.0, 2.0],\n                [1.0, 0.0, 0.0]\n            ])\n        },\n        {\n            \"L\": 1.0, \"n\": 10, \"r\": 5,\n            \"moments\": np.array([\n                [1.0 + 0.01 * i, 0.3 * i * ((-1)**i), float(i**2)]\n                for i in range(10)\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        n = case[\"n\"]\n        r = case[\"r\"]\n        dx = L / n\n        \n        if \"moments\" in case:\n            initial_moments = case[\"moments\"]\n        else:\n            # Initialize moments from function\n            x_centers = (np.arange(n) + 0.5) * dx\n            initial_moments = np.array([case[\"init_func\"](x, L) for x in x_centers])\n\n        # Get initial photon number density vector N\n        N_initial = initial_moments[:, 2]\n        \n        # Calculate total initial photon number (L1 norm of N)\n        total_N_initial = np.sum(N_initial) * dx\n\n        # Perform the remapping cycle\n        final_moments = remap(initial_moments, L, n, r)\n        \n        # Get final photon number density vector N\n        N_final = final_moments[:, 2]\n        \n        # Calculate total final photon number\n        total_N_final = np.sum(N_final) * dx\n        \n        # Calculate the absolute difference to check for conservation\n        abs_difference = abs(total_N_initial - total_N_final)\n        results.append(abs_difference)\n    \n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}