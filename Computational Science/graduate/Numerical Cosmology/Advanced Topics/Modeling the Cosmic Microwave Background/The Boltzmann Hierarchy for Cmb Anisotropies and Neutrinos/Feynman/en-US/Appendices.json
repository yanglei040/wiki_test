{
    "hands_on_practices": [
        {
            "introduction": "The collisionless Boltzmann hierarchy is a cornerstone of modern cosmology, describing the evolution of perturbations in the early universe. Before tackling the full, coupled system that includes gravity, it is essential to master the dynamics of free-streaming particles. This exercise explores the fundamental evolution of massless particle perturbations governed by the source-free Boltzmann hierarchy, whose exact analytical solution is given by spherical Bessel functions. By implementing a truncated numerical solver and validating it against this exact solution, you will build foundational coding skills and gain intuition for how perturbations propagate and how different numerical closure schemes introduce errors .",
            "id": "3493623",
            "problem": "Consider the collisionless Boltzmann hierarchy for massless species relevant to Cosmic Microwave Background (CMB) anisotropies and relic neutrinos in Fourier space, expanded in Legendre multipoles. Let $k$ be the comoving wavenumber and $\\eta$ the conformal time, and define the dimensionless time variable $x \\equiv k\\eta$. Denote by $F_\\ell(x)$ the Legendre multipoles of the phase-space brightness perturbation for a single, freely streaming, massless species in the absence of gravitational driving and collisions. The exact, source-free hierarchy in terms of $x$ is a coupled chain of first-order ordinary differential equations,\n$$\n\\frac{d F_\\ell}{dx} = \\frac{1}{2\\ell+1}\\left[\\ell\\,F_{\\ell-1} - (\\ell+1)\\,F_{\\ell+1}\\right],\n$$\nfor all non-negative integers $\\ell$, with regular initial behavior as $x \\to 0$ corresponding to an initially isotropic perturbation. In the radiation-dominated (RD) era, the scale factor obeys $a(\\eta)\\propto \\eta$, while in the matter-dominated (MD) era, $a(\\eta)\\propto \\eta^2$. In the absence of gravitational driving, the dynamics of $F_\\ell$ depends only on $x$ and not on the background expansion history. The homogeneous analytic solution is expressible in terms of spherical Bessel functions.\n\nYour task is to construct and validate a truncated numerical solver for this hierarchy that keeps only the first three multipoles ($\\ell \\le 2$) and closes the system with an asymptotic free-streaming closure at $\\ell=3$:\n$$\nF_3(x) \\approx \\frac{3}{x}\\,F_2(x).\n$$\nThe initial condition corresponds to an initially isotropic perturbation with unit monopole and vanishing higher multipoles in the $x\\to 0$ limit, implemented by starting at a small but finite $x_0$ with regular initial data consistent with isotropy. Use $x_0 = 10^{-6}$.\n\nImplement the following steps:\n- Integrate the truncated system for $F_0(x)$, $F_1(x)$, and $F_2(x)$ from $x=x_0$ to a specified $x=x_{\\mathrm{end}}$ for each test case.\n- For each $x_{\\mathrm{end}}$, compute the analytic homogeneous free-streaming solution for $\\ell \\in \\{0,1,2\\}$ in terms of spherical Bessel functions, normalized to match the same initial monopole amplitude.\n- For each $\\ell \\in \\{0,1,2\\}$, compute the relative deviation\n$$\n\\epsilon_\\ell(x_{\\mathrm{end}}) \\equiv \\frac{\\left|F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}}) - F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|}{\\max\\left(\\left|F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|, 10^{-14}\\right)}.\n$$\n- Report, for each test case, the maximum deviation over $\\ell \\in \\{0,1,2\\}$:\n$$\n\\epsilon_{\\max}(x_{\\mathrm{end}}) \\equiv \\max\\{\\epsilon_0(x_{\\mathrm{end}}), \\epsilon_1(x_{\\mathrm{end}}), \\epsilon_2(x_{\\mathrm{end}})\\}.\n$$\n\nTest suite:\n- Radiation-dominated era (RD), $x_{\\mathrm{end}} = 10^{-3}$.\n- Radiation-dominated era (RD), $x_{\\mathrm{end}} = 1$.\n- Radiation-dominated era (RD), $x_{\\mathrm{end}} = 20$.\n- Matter-dominated era (MD), $x_{\\mathrm{end}} = 10^{-3}$.\n- Matter-dominated era (MD), $x_{\\mathrm{end}} = 1$.\n- Matter-dominated era (MD), $x_{\\mathrm{end}} = 20$.\n\nNotes and requirements:\n- Use the homogeneous free-streaming analytic solution in terms of spherical Bessel functions as the reference for validation. Because gravitational driving is neglected, the relationship between the hierarchy and $x$ is identical in both the radiation-dominated and matter-dominated eras; the two eras enter only through the interpretation of $x$ with respect to $\\eta$ and $a(\\eta)$, not the $x$-evolution of the hierarchy.\n- Ensure the numerical initial data at $x_0 = 10^{-6}$ are regular and consistent with an initially isotropic perturbation with unit monopole amplitude and vanishing dipole and quadrupole in the $x\\to 0$ limit.\n- Angles do not appear explicitly; no angle unit is needed.\n- All quantities are dimensionless; no physical unit conversion is required.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5,r_6]$), where each $r_i$ is the value of $\\epsilon_{\\max}(x_{\\mathrm{end}})$ for the corresponding test case in the order specified above. Each $r_i$ must be printed as a floating-point number in scientific notation with exactly $8$ significant digits.",
            "solution": "The user wants to solve a problem from numerical cosmology concerning the Boltzmann hierarchy.\n\n### Problem Validation\n\n**Step 1: Extracted Givens**\n- **System**: Collisionless Boltzmann hierarchy for massless species.\n- **Variables and Definitions**: Comoving wavenumber $k$, conformal time $\\eta$, dimensionless time $x \\equiv k\\eta$.\n- **Perturbation Multipoles**: $F_\\ell(x)$, Legendre multipoles of the phase-space brightness perturbation.\n- **Hierarchy Equation**: $\\frac{d F_\\ell}{dx} = \\frac{1}{2\\ell+1}\\left[\\ell\\,F_{\\ell-1} - (\\ell+1)\\,F_{\\ell+1}\\right]$ for non-negative integers $\\ell$.\n- **Initial Conditions**: Regular initial behavior as $x \\to 0$ for an initially isotropic perturbation with unit monopole amplitude.\n- **Numerical Truncation**: Solve for $\\ell \\le 2$, i.e., for $F_0(x)$, $F_1(x)$, and $F_2(x)$.\n- **Closure Relation**: The system is closed at $\\ell=3$ using the approximation $F_3(x) \\approx \\frac{3}{x}\\,F_2(x)$.\n- **Numerical Integration Start**: $x_0 = 10^{-6}$, with regular initial data.\n- **Analytic Solution**: The exact homogeneous solution is given in terms of spherical Bessel functions, $j_\\ell(x)$.\n- **Error Metrics**:\n  - Relative deviation: $\\epsilon_\\ell(x_{\\mathrm{end}}) \\equiv \\frac{\\left|F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}}) - F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|}{\\max\\left(\\left|F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|, 10^{-14}\\right)}$.\n  - Maximum deviation: $\\epsilon_{\\max}(x_{\\mathrm{end}}) \\equiv \\max\\{\\epsilon_0(x_{\\mathrm{end}}), \\epsilon_1(x_{\\mathrm{end}}), \\epsilon_2(x_{\\mathrm{end}})\\}$.\n- **Test Cases**:\n    1. Radiation-dominated (RD), $x_{\\mathrm{end}} = 10^{-3}$.\n    2. Radiation-dominated (RD), $x_{\\mathrm{end}} = 1$.\n    3. Radiation-dominated (RD), $x_{\\mathrm{end}} = 20$.\n    4. Matter-dominated (MD), $x_{\\mathrm{end}} = 10^{-3}$.\n    5. Matter-dominated (MD), $x_{\\mathrm{end}} = 1$.\n    6. Matter-dominated (MD), $x_{\\mathrm{end}} = 20$.\n- **Auxiliary Information**: The evolution of $F_\\ell(x)$ depends only on $x$, not on the background expansion history (RD or MD).\n\n**Step 2: Validation of Givens**\n- **Scientific Grounding**: The problem is scientifically sound. The Boltzmann hierarchy is a fundamental tool in physical cosmology for studying the evolution of perturbations. The equation provided is the correct one for free-streaming massless particles. The use of spherical Bessel functions as the analytic solution for an initially isotropic perturbation is also correct. The task of testing a numerical truncation and closure scheme against an analytic solution is a standard and valid exercise in computational physics.\n- **Well-Posedness**: The problem is well-posed. It provides a system of ordinary differential equations (ODEs), a specific closure relation that makes the truncated system solvable, and a well-defined initial condition. The objective—to calculate a specific error metric—is unambiguous.\n- **Completeness and Consistency**: The problem is self-contained.\n  - The initial condition, while stated descriptively (\"regular initial behavior...\"), can be uniquely determined. For an initial condition $F_\\ell(0) = \\delta_{\\ell 0}$, the analytic solution is $F_\\ell(x) = j_\\ell(x)$. Thus, the numerical initial data at the small starting value $x_0 = 10^{-6}$ should be set to $F_\\ell(x_0) = j_\\ell(x_0)$ for $\\ell \\in \\{0, 1, 2\\}$.\n  - The problem specifies test cases for both RD and MD eras but also explicitly states that the dynamics of $F_\\ell(x)$ are identical in both scenarios. This implies that the results for test cases with the same $x_{\\mathrm{end}}$ will be identical (i.e., case 1=4, 2=5, 3=6). This is not a contradiction but a redundancy that tests the understanding of the underlying physics.\n  - The provided closure relation, $F_3(x) \\approx \\frac{3}{x}F_2(x)$, is a defining feature of the numerical scheme to be tested. While it may not be a highly accurate physical approximation, its validity is not a prerequisite for the problem itself, which is to quantify the error introduced by this specific approximation.\n\n**Step 3: Verdict and Action**\nThe problem is valid. I will proceed with the solution.\n\n### Solution Design\n\nThe core of the problem is to solve a truncated system of ordinary differential equations and compare the result to a known analytic solution.\n\n**1. The Truncated System of ODEs**\nWe are solving for the vector of perturbations $\\vec{F}(x) = [F_0(x), F_1(x), F_2(x)]^T$. The hierarchy equations for $\\ell=0, 1, 2$ are:\n$$\n\\frac{d F_0}{dx} = \\frac{1}{1}\\left[0 \\cdot F_{-1} - (0+1)F_1\\right] = -F_1\n$$\n$$\n\\frac{d F_1}{dx} = \\frac{1}{2(1)+1}\\left[1 \\cdot F_0 - (1+1)F_2\\right] = \\frac{1}{3}(F_0 - 2F_2)\n$$\n$$\n\\frac{d F_2}{dx} = \\frac{1}{2(2)+1}\\left[2 \\cdot F_1 - (2+1)F_3\\right] = \\frac{1}{5}(2F_1 - 3F_3)\n$$\nThe system is closed using the provided relation $F_3(x) = \\frac{3}{x}F_2(x)$. Substituting this into the equation for $F_2$ gives:\n$$\n\\frac{d F_2}{dx} = \\frac{1}{5}\\left(2F_1 - 3 \\cdot \\frac{3}{x}F_2\\right) = \\frac{2}{5}F_1 - \\frac{9}{5x}F_2\n$$\nThis results in the following linear system of first-order ODEs:\n$$\n\\frac{d}{dx}\n\\begin{pmatrix} F_0 \\\\ F_1 \\\\ F_2 \\end{pmatrix}\n=\n\\begin{pmatrix}\n0  -1  0 \\\\\n1/3  0  -2/3 \\\\\n0  2/5  -9/(5x)\n\\end{pmatrix}\n\\begin{pmatrix} F_0 \\\\ F_1 \\\\ F_2 \\end{pmatrix}\n$$\n\n**2. Initial Conditions**\nThe problem states that the initial perturbation is isotropic with a unit monopole, i.e., $F_\\ell(x \\to 0) = \\delta_{\\ell 0}$. The analytic solution to the full hierarchy with this initial condition is $F_\\ell(x) = j_\\ell(x)$, where $j_\\ell(x)$ is the spherical Bessel function of the first kind. To start the numerical integration at $x_0 = 10^{-6}$, we set the initial state vector to the values of the analytic solution at that point:\n$$\n\\vec{F}(x_0) = \\begin{pmatrix} F_0(x_0) \\\\ F_1(x_0) \\\\ F_2(x_0) \\end{pmatrix} = \\begin{pmatrix} j_0(x_0) \\\\ j_1(x_0) \\\\ j_2(x_0) \\end{pmatrix}\n$$\n\n**3. Numerical Integration**\nThe system of ODEs will be integrated numerically from $x_0 = 10^{-6}$ to each specified $x_{\\mathrm{end}} \\in \\{10^{-3}, 1, 20\\}$. We will use a high-precision adaptive step-size solver, such as the one provided by `scipy.integrate.solve_ivp`, to ensure that the error is dominated by the closure approximation itself, not by numerical integration inaccuracies. We set stringent relative and absolute tolerances (e.g., $10^{-12}$ and $10^{-14}$).\n\n**4. Analytic Reference and Error Calculation**\nFor each $x_{\\mathrm{end}}$, the numerical solution $F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}})$ is compared against the analytic solution $F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}}) = j_\\ell(x_{\\mathrm{end}})$. The relative deviation $\\epsilon_\\ell(x_{\\mathrm{end}})$ is computed for each $\\ell \\in \\{0,1,2\\}$ using the provided formula:\n$$\n\\epsilon_\\ell(x_{\\mathrm{end}}) = \\frac{\\left|F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}}) - j_\\ell(x_{\\mathrm{end}})\\right|}{\\max\\left(\\left|j_\\ell(x_{\\mathrm{end}})\\right|, 10^{-14}\\right)}\n$$\nThe final result for each test case is the maximum of these deviations, $\\epsilon_{\\max}(x_{\\mathrm{end}}) = \\max_{ \\ell \\in \\{0,1,2\\}} \\epsilon_\\ell(x_{\\mathrm{end}})$.\n\n**5. Handling of Test Cases**\nAs established during validation, the distinction between RD and MD eras is irrelevant for the calculation of $F_\\ell(x)$. Therefore, the calculations for $x_{\\mathrm{end}} = 10^{-3}$, $x_{\\mathrm{end}} = 1$, and $x_{\\mathrm{end}} = 20$ are performed once, and the results are duplicated for the corresponding RD and MD test cases in the final output. The final list of results will have $6$ entries.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Solves the truncated Boltzmann hierarchy and computes the maximum relative\n    deviation from the analytic solution for a set of test cases.\n    \"\"\"\n    # Define constants from the problem statement.\n    x0 = 1.0e-6\n    floor_val = 1.0e-14\n\n    # Define the test cases. Note that the distinction between RD and MD eras is\n    # irrelevant for the computation of F_l(x), as the hierarchy's evolution\n    # only depends on the dimensionless variable x.\n    x_end_values_unique = [1.0e-3, 1.0, 20.0]\n    test_cases_x_end = [1.0e-3, 1.0, 20.0] * 2 # RD cases followed by MD cases\n\n    def boltzmann_hierarchy_truncated(x, F):\n        \"\"\"\n        Defines the system of ODEs for the truncated Boltzmann hierarchy.\n        \n        Args:\n            x (float): The dimensionless time variable k*eta.\n            F (np.ndarray): The state vector [F0, F1, F2].\n        \n        Returns:\n            list: The derivatives [dF0/dx, dF1/dx, dF2/dx].\n        \"\"\"\n        F0, F1, F2 = F\n        \n        # Equation for F_0: d_x F_0 = -F_1\n        dF0_dx = -F1\n        \n        # Equation for F_1: d_x F_1 = (1/3)*(F_0 - 2*F_2)\n        dF1_dx = F0 / 3.0 - (2.0 / 3.0) * F2\n        \n        # Equation for F_2 with closure F_3 = (3/x)*F_2:\n        # d_x F_2 = (1/5)*(2*F_1 - 3*F_3) = (2/5)*F_1 - (9/5x)*F_2\n        if x == 0:\n            # This case should not be reached since we start at x0  0.\n            # The small-x limit of dF2/dx is 0.\n            dF2_dx = 0.0\n        else:\n            dF2_dx = (2.0 / 5.0) * F1 - (9.0 / (5.0 * x)) * F2\n            \n        return [dF0_dx, dF1_dx, dF2_dx]\n\n    # Store results for unique x_end values to avoid redundant computations.\n    unique_results = {}\n\n    for x_end in x_end_values_unique:\n        # Set initial conditions using the analytic solution at x0.\n        # F_l(x0) = j_l(x0) for l=0,1,2.\n        F_initial = spherical_jn([0, 1, 2], x0)\n\n        # Numerically integrate the system of ODEs.\n        # Use high-precision tolerances to isolate the error from the closure.\n        sol = solve_ivp(\n            fun=boltzmann_hierarchy_truncated,\n            t_span=[x0, x_end],\n            y0=F_initial,\n            t_eval=[x_end],\n            method='LSODA',  # Good for potentially stiff problems like this.\n            rtol=1e-12,\n            atol=1e-14\n        )\n        # Numerical solution at x_end\n        F_num = sol.y.flatten()\n\n        # Analytic solution at x_end is j_l(x_end)\n        F_ana = spherical_jn([0, 1, 2], x_end)\n\n        # Compute the relative deviation for each multipole l={0,1,2}.\n        numerator = np.abs(F_num - F_ana)\n        denominator = np.maximum(np.abs(F_ana), floor_val)\n        epsilons = numerator / denominator\n        \n        # Find the maximum deviation for this test case.\n        epsilon_max = np.max(epsilons)\n        unique_results[x_end] = epsilon_max\n\n    # Assemble the final list of results in the specified order.\n    results = [unique_results[x] for x in test_cases_x_end]\n\n    # Format the output as specified: a list of floats in scientific\n    # notation with 8 significant digits.\n    formatted_results = [f\"{r:.8e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "While massless species provide a simplified starting point, a realistic cosmological model must account for massive neutrinos, which transition from relativistic to non-relativistic behavior as the universe expands. This transition profoundly impacts their contribution to the background energy density and pressure, altering the expansion history and the growth of structure. This practice focuses on the numerical evaluation of momentum-space integrals weighted by the Fermi-Dirac distribution, which are necessary to compute these macroscopic properties. You will learn to construct a specialized Gaussian quadrature rule from first principles, a powerful technique for accurately and efficiently handling the complex integrals that arise in the study of massive relic particles .",
            "id": "3493584",
            "problem": "Consider massive neutrinos in the linear regime of Cosmic Microwave Background (CMB) anisotropies and the Boltzmann hierarchy. In the absence of collisions, the Liouville equation implies that the unperturbed phase-space distribution function is conserved along geodesics. For a species of neutrinos with a Fermi-Dirac equilibrium distribution and zero chemical potential, the comoving momentum $q$ is constant, while the comoving energy is $\\epsilon(a,q) = \\sqrt{q^2 + a^2 m_\\nu^2}$, where $a$ is the scale factor and $m_\\nu$ is the neutrino mass. If one nondimensionalizes the comoving momentum using the present-day neutrino temperature as $q \\rightarrow q/T_{\\nu,0}$, then the dimensionless quantity $y \\equiv a m_\\nu / T_{\\nu,0}$ controls the relativistic-to-non-relativistic transition. The background energy density and pressure of the neutrino species can be written as integrals over comoving momentum with the Fermi-Dirac factor. In dimensionless form, define the following moments:\n$$\n\\rho_\\nu(y) \\propto \\int_0^\\infty \\frac{q^2 \\sqrt{q^2 + y^2}}{e^{q} + 1} \\, dq, \\qquad\nP_\\nu(y) \\propto \\int_0^\\infty \\frac{q^4}{3 \\sqrt{q^2 + y^2}} \\frac{1}{e^{q} + 1} \\, dq,\n$$\nand the corresponding equation of state parameter $w_\\nu(y) \\equiv P_\\nu(y)/\\rho_\\nu(y)$. The proportionality factors are constant with respect to $q$ and $y$ and can be ignored for the purpose of this numerical exercise; the goal is to compute the dimensionless integrals themselves.\n\nYour task is to design and implement a numerical strategy to evaluate integrals of the form\n$$\nI_h(y) \\equiv \\int_0^\\infty \\frac{h(q,y)}{e^{q} + 1} \\, dq\n$$\nfor smooth functions $h(q,y)$ that depend on the comoving momentum $q$ and the parameter $y$, with particular focus on the transition regime where $y$ is neither extremely small nor extremely large. Construct a Gaussian quadrature specialized to the semi-infinite interval $[0,\\infty)$ by discretizing the comoving momentum $q$ and building quadrature nodes and weights that yield accurate integrals across the relativistic transition. The construction must be derived from first principles: start from the phase-space integrals for $\\rho_\\nu(y)$ and $P_\\nu(y)$, and systematically transform the integral into a form amenable to Gaussian quadrature on $[0,\\infty)$ without assuming any pre-existing specialized rule for Fermi-Dirac integrals. Explicitly justify the choice of orthogonal polynomials and the weight function used in the quadrature.\n\nImplement a program that:\n- Constructs Gaussian quadrature nodes and weights on $[0,\\infty)$ appropriate to a choice of weight function, and uses them to approximate the integrals defining $\\rho_\\nu(y)$ and $P_\\nu(y)$ for given $y$.\n- Computes a high-accuracy reference value of the same integrals using adaptive numerical integration on $[0,\\infty)$.\n- Reports the quadrature approximations for $\\rho_\\nu(y)$, $P_\\nu(y)$, and $w_\\nu(y)$, together with the relative errors of $\\rho_\\nu(y)$ and $P_\\nu(y)$ with respect to the reference.\n\nAll quantities are dimensionless, so no physical units are required.\n\nTest Suite:\nProvide results for the following test cases $(y,N)$, where $y$ is the dimensionless mass parameter and $N$ is the number of Gaussian quadrature points:\n1. $(y,N) = (0.0, 12)$ to probe the strictly relativistic limit.\n2. $(y,N) = (0.5, 16)$ as a mildly relativistic case.\n3. $(y,N) = (1.0, 24)$ as a \"happy path\" near the transition.\n4. $(y,N) = (10.0, 12)$ as a moderately non-relativistic case with fewer nodes to test robustness.\n5. $(y,N) = (50.0, 48)$ to probe the deep non-relativistic limit with more nodes.\n\nFor each case, compute:\n- The Gaussian quadrature approximation to $\\rho_\\nu(y)$,\n- The Gaussian quadrature approximation to $P_\\nu(y)$,\n- The Gaussian quadrature approximation to $w_\\nu(y)$,\n- The relative error of $\\rho_\\nu(y)$ with respect to the adaptive reference, expressed as a decimal,\n- The relative error of $P_\\nu(y)$ with respect to the adaptive reference, expressed as a decimal.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case reported as a list in the order $[\\rho_\\nu(y),P_\\nu(y),w_\\nu(y),\\text{rel\\_err\\_}\\rho_\\nu(y),\\text{rel\\_err\\_}P_\\nu(y)]$. For example, for two cases the output would be formatted as:\n$$\n\\text{[}[r_1,p_1,w_1,e_{\\rho,1},e_{p,1}],[r_2,p_2,w_2,e_{\\rho,2},e_{p,2}]\\text{]}.\n$$\nYour program must implement all computations internally and must not read any external input.",
            "solution": "The user-provided problem is valid. It is scientifically grounded in the physics of massive neutrinos within the standard cosmological model, is well-posed with a clear objective and sufficient data, and uses precise, objective language. The task is to develop and implement a numerical method for evaluating specific integrals that arise in this context, which is a non-trivial but feasible problem in computational physics.\n\n### Principle-Based Solution Design\n\nThe core of the problem is the numerical evaluation of integrals of the form:\n$$\nI_h(y) = \\int_0^\\infty \\frac{h(q,y)}{e^{q} + 1} \\, dq\n$$\nwhere $h(q,y)$ represents functions related to the energy density and pressure of a massive neutrino species. Specifically, for the energy density $\\rho_\\nu(y)$ and pressure $P_\\nu(y)$, the functions are:\n$$\nh_\\rho(q,y) = q^2 \\sqrt{q^2 + y^2}\n$$\n$$\nh_P(q,y) = \\frac{q^4}{3 \\sqrt{q^2 + y^2}}\n$$\nThe factor $1 / (e^q + 1)$ is the Fermi-Dirac distribution factor. The goal is to construct a Gaussian quadrature rule to evaluate these integrals accurately.\n\n#### 1. Choice of Quadrature Scheme\n\nA standard Gaussian quadrature method, such as Gauss-Legendre, is defined on a finite interval (typically $[-1, 1]$) and is not directly applicable to the semi-infinite interval $[0, \\infty)$ of our integral. While a change of variables could map $[0, \\infty)$ to a finite interval, this often introduces new numerical challenges or results in an integrand that is not well-approximated by a low-order polynomial.\n\nA more effective strategy is to use a Gaussian quadrature rule designed for the interval $[0, \\infty)$. The general form of a Gaussian quadrature approximates an integral as a weighted sum:\n$$\n\\int_a^b W(q) f(q) \\, dq \\approx \\sum_{i=1}^{N} w_i f(q_i)\n$$\nwhere $W(q)$ is a fixed weight function, $q_i$ are the quadrature nodes (or points), and $w_i$ are the corresponding weights. The key is to select a suitable $W(q)$ from our integrand.\n\nOur integral can be rewritten by factoring out the standard weight function for Gauss-Laguerre quadrature, $W(q) = e^{-q}$:\n$$\nI_h(y) = \\int_0^\\infty e^{-q} \\left( \\frac{e^q}{e^q + 1} h(q,y) \\right) \\, dq\n$$\nWe identify the function to be approximated by the quadrature rule as:\n$$\nf(q; y) = \\frac{e^q}{e^q + 1} h(q,y) = \\frac{1}{1 + e^{-q}} h(q,y)\n$$\nThe second form, using $e^{-q}$, is preferable for numerical stability, as it avoids overflow for large values of $q$.\n\nThe choice of $W(q) = e^{-q}$ is well-justified. It isolates the dominant exponential decay of the Fermi-Dirac factor for large $q$ into a standard weight function. The associated orthogonal polynomials are the Laguerre polynomials, $L_n(q)$, and the resulting quadrature is the Gauss-Laguerre quadrature. For this method to be efficient, the function $f(q;y)$ must be well-approximated by a polynomial in $q$. For both $\\rho_\\nu$ and $P_\\nu$, the function $h(q,y)$ behaves as a power of $q$ for large $q$ (specifically $q^3$), and the factor $1/(1+e^{-q})$ smoothly approaches $1$. Thus, $f(q;y)$ is a smooth function amenable to polynomial approximation.\n\n#### 2. Construction of the Gauss-Laguerre Quadrature Rule\n\nThe problem requires constructing the quadrature rule from first principles. The nodes $q_i$ of an $N$-point Gauss-Laguerre quadrature are the roots of the $N$-th degree Laguerre polynomial, $L_N(q)$. The nodes and weights can be determined efficiently and stably using the Golub-Welsch algorithm, which connects the problem to the eigensystem of a specific symmetric tridiagonal matrix known as the Jacobi matrix.\n\nThe monic Laguerre polynomials, $\\hat{L}_n(q)$, satisfy the three-term recurrence relation:\n$$\n\\hat{L}_{n+1}(q) = (q - \\alpha_n) \\hat{L}_n(q) - \\beta_n \\hat{L}_{n-1}(q)\n$$\nwith recurrence coefficients:\n$$\n\\alpha_n = 2n + 1, \\qquad \\beta_n = n^2\n$$\nThe corresponding $N \\times N$ Jacobi matrix, $J_N$, is constructed with these coefficients:\n$$\nJ_N = \\begin{pmatrix}\n\\alpha_0  \\sqrt{\\beta_1}  0  \\dots  0 \\\\\n\\sqrt{\\beta_1}  \\alpha_1  \\sqrt{\\beta_2}  \\dots  0 \\\\\n0  \\sqrt{\\beta_2}  \\alpha_2  \\ddots  \\vdots \\\\\n\\vdots   \\ddots  \\ddots  \\sqrt{\\beta_{N-1}} \\\\\n0  \\dots  \\dots  \\sqrt{\\beta_{N-1}}  \\alpha_{N-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1  1  0  \\dots  0 \\\\\n1  3  2  \\dots  0 \\\\\n0  2  5  \\ddots  \\vdots \\\\\n\\vdots   \\ddots  \\ddots  N-1 \\\\\n0  \\dots  \\dots  N-1  2N-1\n\\end{pmatrix}\n$$\nThe eigenvalues of this matrix $J_N$ are the quadrature nodes $\\{q_i\\}_{i=1}^N$. The corresponding weights $\\{w_i\\}_{i=1}^N$ are given by the squared first components of the normalized eigenvectors. The integral of the weight function is $\\int_0^\\infty e^{-q} dq = 1$, which simplifies the weight calculation.\n\nThe algorithmic procedure is as follows:\n1.  For a given number of points $N$, construct the $N \\times N$ Jacobi matrix $J_N$.\n2.  Solve the eigenvalue problem for $J_N$ to obtain eigenvalues (nodes $q_i$) and the corresponding normalized eigenvectors $\\mathbf{v}_i$.\n3.  The weights are $w_i = (\\mathbf{v}_i)_1^2$, where $(\\mathbf{v}_i)_1$ is the first component of the eigenvector $\\mathbf{v}_i$.\n\n#### 3. Numerical Implementation and Evaluation\n\nWith the nodes $q_i$ and weights $w_i$ constructed, the integrals for energy density and pressure are approximated as:\n$$\n\\rho_\\nu(y) \\approx \\sum_{i=1}^N w_i f_\\rho(q_i, y) = \\sum_{i=1}^N w_i \\frac{1}{1+e^{-q_i}} \\left( q_i^2 \\sqrt{q_i^2 + y^2} \\right)\n$$\n$$\nP_\\nu(y) \\approx \\sum_{i=1}^N w_i f_P(q_i, y) = \\sum_{i=1}^N w_i \\frac{1}{1+e^{-q_i}} \\left( \\frac{q_i^4}{3 \\sqrt{q_i^2 + y^2}} \\right)\n$$\nSpecial care is taken for the case $y=0$ in the pressure integral to avoid division by zero. In this limit, $\\sqrt{q^2+y^2} \\to q$, so $h_P(q,0) \\to q^3/3$.\n\nTo assess the accuracy of this custom quadrature, we compute a high-accuracy reference value for each integral using an adaptive quadrature routine, specifically `scipy.integrate.quad`, applied to the original integral form $\\int_0^\\infty g(q,y) dq$. The relative error is then calculated as:\n$$\n\\text{rel\\_err} = \\left| \\frac{I_{\\text{approx}} - I_{\\text{ref}}}{I_{\\text{ref}}} \\right|\n$$\nThe equation of state parameter is computed directly from the approximated density and pressure: $w_\\nu(y) = P_\\nu(y) / \\rho_\\nu(y)$.\n\nThis comprehensive approach allows for the robust and accurate calculation of the required neutrino moment integrals across the full range of physical regimes, from highly relativistic ($y \\ll 1$) to non-relativistic ($y \\gg 1$).",
            "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the neutrino integral problem by constructing a Gauss-Laguerre quadrature rule,\n    evaluating the integrals for given test cases, and comparing with a high-accuracy reference.\n    \"\"\"\n\n    test_cases = [\n        (0.0, 12),\n        (0.5, 16),\n        (1.0, 24),\n        (10.0, 12),\n        (50.0, 48),\n    ]\n\n    results = []\n    for y, N in test_cases:\n        # Step 1: Construct Gauss-Laguerre quadrature nodes and weights\n        # using the Golub-Welsch algorithm on the Jacobi matrix.\n        \n        # Coefficients for the three-term recurrence of monic Laguerre polynomials:\n        # alpha_n = 2n + 1, beta_n = n^2\n        alpha = np.arange(1, 2 * N, 2, dtype=float)\n        beta_sqrt = np.arange(1, N, dtype=float)\n\n        # Construct the symmetric tridiagonal Jacobi matrix\n        J = np.diag(alpha) + np.diag(beta_sqrt, k=1) + np.diag(beta_sqrt, k=-1)\n\n        # Solve the eigenvalue problem for the Jacobi matrix.\n        # Eigenvalues are the quadrature nodes.\n        # Weights are the squared first components of the normalized eigenvectors.\n        nodes, evecs = np.linalg.eigh(J)\n        weights = evecs[0, :]**2\n        \n        # Step 2: Define the integrands for density and pressure\n        \n        # Functions h(q,y) from the problem statement\n        def h_rho(q, y_val):\n            return q**2 * np.sqrt(q**2 + y_val**2)\n\n        def h_P(q, y_val):\n            if y_val == 0.0:\n                # For y=0, sqrt(q^2+y^2) = q. The integrand h_P becomes q^3/3.\n                # This correctly handles the limit q-0.\n                return q**3 / 3.0\n            else:\n                return q**4 / (3.0 * np.sqrt(q**2 + y_val**2))\n\n        # Functions f(q,y) = h(q,y) / (1 + exp(-q)) for Gauss-Laguerre quadrature\n        def f_rho(q, y_val):\n            return h_rho(q, y_val) / (1.0 + np.exp(-q))\n\n        def f_P(q, y_val):\n            return h_P(q, y_val) / (1.0 + np.exp(-q))\n        \n        # Step 3: Compute approximations using the constructed quadrature rule\n        rho_approx = np.sum(weights * f_rho(nodes, y))\n        p_approx = np.sum(weights * f_P(nodes, y))\n\n        if rho_approx != 0:\n            w_approx = p_approx / rho_approx\n        else:\n            w_approx = 0.0 # Should not happen as integrand is positive\n\n        # Step 4: Compute high-accuracy reference values using adaptive quadrature\n        \n        # Full integrands g(q,y) = h(q,y) / (exp(q) + 1)\n        def g_rho(q, y_val):\n            return h_rho(q, y_val) / (np.exp(q) + 1.0)\n        \n        def g_P(q, y_val):\n            return h_P(q, y_val) / (np.exp(q) + 1.0)\n\n        rho_ref, _ = integrate.quad(g_rho, 0, np.inf, args=(y,))\n        p_ref, _ = integrate.quad(g_P, 0, np.inf, args=(y,))\n        \n        # Step 5: Calculate relative errors\n        if rho_ref != 0:\n            rel_err_rho = np.abs((rho_approx - rho_ref) / rho_ref)\n        else:\n            rel_err_rho = 0.0 if rho_approx == 0.0 else np.inf\n\n        if p_ref != 0:\n            rel_err_p = np.abs((p_approx - p_ref) / p_ref)\n        else:\n            rel_err_p = 0.0 if p_approx == 0.0 else np.inf\n\n        results.append([\n            rho_approx,\n            p_approx,\n            w_approx,\n            rel_err_rho,\n            rel_err_p\n        ])\n\n    # Final print statement in the exact required format.\n    # We construct the string representation manually to ensure no spaces within sub-lists.\n    formatted_results = []\n    for res_list in results:\n        # Format each sublist to a string like \"[item1,item2,...]\"\n        formatted_sublist = f\"[{','.join(f'{item:.15g}' for item in res_list)}]\"\n        formatted_results.append(formatted_sublist)\n    \n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Numerical solutions to the Boltzmann hierarchy are invariably approximations, requiring truncation at a finite multipole $\\ell_{\\max}$. This choice is not merely a numerical detail but has direct and measurable physical consequences. This advanced exercise demonstrates how an unphysical closure relation can generate spurious anisotropic stress, which in turn artificially alters the gravitational potentials $\\phi$ and $\\psi$ and the gravitational slip between them. By first proving this effect analytically and then designing a numerical experiment to detect it, you will develop a deep understanding of the critical link between numerical implementation choices and the physical integrity of a cosmological simulation .",
            "id": "3493570",
            "problem": "Consider linear scalar perturbations in a spatially flat Friedmann–Lemaître–Robertson–Walker universe in the Newtonian gauge with line element $ds^2 = a^2(\\tau)\\left\\{-(1+2\\psi)d\\tau^2 + (1-2\\phi)d\\mathbf{x}^2\\right\\}$, where $a(\\tau)$ is the scale factor and $\\tau$ is conformal time. Focus on collisionless, massless neutrinos as the only matter component, and consider one Fourier mode with comoving wavenumber $k$. The perturbation of the phase-space distribution function of the neutrinos is expanded in Legendre multipoles, forming a Boltzmann hierarchy $F_\\ell(\\tau)$ for $\\ell = 0,1,2,\\dots$. The relevant relations include: the linearized Einstein equations in Fourier space for the Newtonian-gauge potentials $\\phi$ and $\\psi$, the definition of anisotropic stress from the Boltzmann multipoles, and the collisionless Boltzmann hierarchy for massless species. Use the following foundational facts as the starting point:\n- In radiation domination, the conformal Hubble rate satisfies $H(\\tau) \\equiv a'(\\tau)/a(\\tau) = 1/\\tau$ and the background Friedmann equation implies $8\\pi G a^2 \\rho = 3H^2$.\n- The Newtonian-gauge Einstein equations (constraints) in Fourier space are\n$$\nk^2 \\psi + 3 H \\left(\\psi' + H \\phi\\right) = -4\\pi G a^2 \\delta \\rho,\\quad\nk^2 \\left(\\psi' + H \\phi\\right) = 4\\pi G a^2 (\\rho + P) \\theta,\\quad\nk^2(\\phi - \\psi) = 12\\pi G a^2 \\sum_s (\\rho_s + P_s) \\sigma_s,\n$$\nwhere primes denote $d/d\\tau$, $\\delta \\rho$ is the energy density perturbation, $\\theta$ is the velocity divergence, and $\\sigma_s$ is the anisotropic stress for species $s$. For a massless species, $(\\rho+P)=\\frac{4}{3}\\rho$.\n- For collisionless massless neutrinos, the standard identification with brightness multipoles holds: $\\delta_\\nu = F_0$, $\\theta_\\nu = \\frac{3k}{4}F_1$, $\\sigma_\\nu = \\frac{1}{2}F_2$, and for $\\ell \\ge 3$ the collisionless evolution is free-streaming.\n- The collisionless Boltzmann hierarchy for massless species’ multipoles is\n$$\nF_0' = -k F_1 - 4\\phi',\\quad\nF_1' = k\\left(\\frac{F_0}{3} - \\frac{2F_2}{3}\\right) + k\\psi,\\quad\nF_2' = k\\left(\\frac{2F_1}{5} - \\frac{3F_3}{5}\\right),\\quad\nF_\\ell' = \\frac{k}{2\\ell+1}\\left[\\ell F_{\\ell-1} - (\\ell+1)F_{\\ell+1}\\right]\\ \\text{for}\\ \\ell\\ge 3.\n$$\n\nYour tasks are:\n1. Prove that truncation of the Boltzmann hierarchy at a finite multipole $\\ell_{\\max}$ with an inappropriate closure for $F_{\\ell_{\\max}+1}$ generically produces spurious anisotropic stress (via an incorrect $F_2$), and thereby causes a nonphysical difference between $\\phi$ and $\\psi$ that feeds back onto the dynamics. Your proof must start from the fundamental equations stated above and proceed by logical steps that do not assume any shortcut formulas not derived in your reasoning. You must make a scientifically realistic approximation choice to carry the proof to a clear mathematical statement, and you must state exactly which regime your approximation applies to.\n2. Design a numerical test to detect contamination of the metric evolution from an inappropriate closure. The test must be implementable as a program and should produce a quantifiable diagnostic. Build the test on a neutrino-only radiation background $a(\\tau) \\propto \\tau$ and work in the subhorizon, quasi-static regime where $k \\gg H(\\tau)$ and the term $3H(\\psi' + H\\phi)$ is negligible in the Poisson-like equation. The detection should be based on comparing the gravitational slip parameter $\\eta(\\tau) \\equiv \\frac{\\phi(\\tau)-\\psi(\\tau)}{\\psi(\\tau)}$ obtained with a physically motivated free-streaming closure versus a naive closure. The physically motivated closure may be taken in the asymptotic free-streaming form $F_{\\ell_{\\max}+1} \\approx \\frac{2\\ell_{\\max}+1}{k\\tau}F_{\\ell_{\\max}}$, while the naive closure sets $F_{\\ell_{\\max}+1}=0$.\n3. Implement the test as a complete runnable program that integrates the Boltzmann hierarchy for a single Fourier mode and computes the final-time slip $\\eta(\\tau_f)$ under both closures, declares contamination detected if the absolute difference exceeds a specified threshold, and outputs a boolean per test case. Use the quasi-static subhorizon approximations\n$$\n\\psi(\\tau) \\approx -\\frac{3}{2}\\frac{H^2(\\tau)}{k^2}F_0(\\tau),\\quad\n\\phi(\\tau) \\approx \\psi(\\tau) + \\frac{6H^2(\\tau)}{k^2}\\sigma_\\nu(\\tau) = \\psi(\\tau) + \\frac{3H^2(\\tau)}{k^2}F_2(\\tau),\n$$\nand enforce the hierarchy’s coupling to $\\phi'$ self-consistently by eliminating $\\phi'$ in favor of time derivatives of $F_0$ and $F_2$.\n\nDefine the initial multipoles at $\\tau=\\tau_i$ as $F_0(\\tau_i)=10^{-5}$ and $F_\\ell(\\tau_i)=0$ for $\\ell\\ge 1$. You must treat all quantities as dimensionless and state explicitly any approximations you use. Your program must use the following test suite, covering a happy-path case, a truncation-stress edge case, and a high-resolution boundary case:\n\n- Test case 1 (happy path): $\\ell_{\\max}=7$, $k=3.0$, $\\tau_i=20.0$, $\\tau_f=120.0$, threshold $=10^{-3}$.\n- Test case 2 (edge case, aggressive truncation): $\\ell_{\\max}=3$, $k=3.0$, $\\tau_i=20.0$, $\\tau_f=120.0$, threshold $=10^{-2}$.\n- Test case 3 (boundary case, high multipole resolution): $\\ell_{\\max}=25$, $k=3.0$, $\\tau_i=20.0$, $\\tau_f=120.0$, threshold $=10^{-5}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, \"[True,False,True]\". Each element is a boolean indicating whether contamination was detected for the corresponding test case when comparing the naive closure to the physically motivated closure. All outputs are dimensionless. No angles or percentages are involved; do not include any units in the output.",
            "solution": "The user-provided problem has been analyzed and is determined to be valid. It is scientifically grounded in the principles of cosmological perturbation theory, is mathematically well-posed with a complete and consistent set of equations and conditions, and is objective in its formulation. The problem addresses a relevant and non-trivial topic in numerical cosmology—the impact of truncation errors in the Boltzmann hierarchy.\n\n### Part 1: Proof of Spurious Anisotropic Stress from Truncation\n\nThe objective is to prove that truncating the Boltzmann hierarchy at a finite multipole $\\ell_{\\max}$ with an improper closure for $F_{\\ell_{\\max}+1}$ generates a non-physical anisotropic stress, which in turn creates an artificial difference between the gravitational potentials $\\phi$ and $\\psi$.\n\n1.  **Relation between Metric Potentials and Anisotropic Stress:**\n    The starting point is the Einstein equation relating the gravitational slip, $\\phi-\\psi$, to the anisotropic stress, $\\sigma_s$. For a single species of massless neutrinos, this is:\n    $$k^2(\\phi - \\psi) = 12\\pi G a^2 (\\rho_\\nu + P_\\nu) \\sigma_\\nu$$\n    For a massless species (radiation), the equation of state is $P_\\nu = \\frac{1}{3}\\rho_\\nu$, so $\\rho_\\nu + P_\\nu = \\frac{4}{3}\\rho_\\nu$. The equation becomes:\n    $$k^2(\\phi - \\psi) = 12\\pi G a^2 \\left(\\frac{4}{3}\\rho_\\nu\\right) \\sigma_\\nu = 16\\pi G a^2 \\rho_\\nu \\sigma_\\nu$$\n    From the background Friedmann equation in a radiation-dominated universe, we have $3H^2 = 8\\pi G a^2 \\rho_\\nu$. Substituting this into the previous equation gives:\n    $$k^2(\\phi - \\psi) = 2 \\cdot (8\\pi G a^2 \\rho_\\nu) \\sigma_\\nu = 2 \\cdot (3H^2) \\sigma_\\nu = 6H^2 \\sigma_\\nu$$\n    The problem defines the neutrino anisotropic stress multipole as $\\sigma_\\nu = \\frac{1}{2}F_2$. Substituting this yields the direct relationship:\n    $$k^2(\\phi - \\psi) = 3H^2 F_2 \\implies \\phi - \\psi = \\frac{3H^2}{k^2} F_2$$\n    This equation demonstrates that any error in the computation of the quadrupole moment $F_2$ will directly and proportionally create a non-physical difference between $\\phi$ and $\\psi$.\n\n2.  **Propagation of Truncation Error down the Hierarchy:**\n    The evolution of the Boltzmann multipoles for $\\ell \\ge 2$ is governed by the collisionless Boltzmann hierarchy:\n    $$F_2' = k\\left(\\frac{2F_1}{5} - \\frac{3F_3}{5}\\right)$$\n    $$F_\\ell' = \\frac{k}{2\\ell+1}\\left[\\ell F_{\\ell-1} - (\\ell+1)F_{\\ell+1}\\right] \\quad \\text{for}\\ \\ell\\ge 3$$\n    To solve this system numerically, it must be truncated at some finite $\\ell_{\\max}$. The equation for $F_{\\ell_{\\max}}$ is:\n    $$F_{\\ell_{\\max}}' = \\frac{k}{2\\ell_{\\max}+1}\\left[\\ell_{\\max} F_{\\ell_{\\max}-1} - (\\ell_{\\max}+1)F_{\\ell_{\\max}+1}\\right]$$\n    This equation requires a closure relation for $F_{\\ell_{\\max}+1}$. A naive but incorrect closure is to set $F_{\\ell_{\\max}+1} = 0$.\n\n3.  **Analysis in the Free-Streaming Regime:**\n    The proof is most clearly demonstrated in the subhorizon, free-streaming regime ($k\\tau \\gg 1$), where perturbations propagate relativistically. In this regime, the true physical solution for the multipoles $F_\\ell$ is non-zero and typically decays oscillatorily (akin to spherical Bessel functions, $F_\\ell \\sim j_\\ell(k\\tau)$). Crucially, if $F_{\\ell_{\\max}}$ is non-zero, then $F_{\\ell_{\\max}+1}$ is also generically non-zero.\n\n4.  **Error Cascade:**\n    Let $\\tilde{F}_\\ell$ be the numerically computed multipoles using the naive closure $\\tilde{F}_{\\ell_{\\max}+1} = 0$, and let $F_\\ell$ be the true physical solution.\n    The evolution of the computed $\\tilde{F}_{\\ell_{\\max}}$ becomes:\n    $$\\tilde{F}_{\\ell_{\\max}}' = \\frac{k \\ell_{\\max}}{2\\ell_{\\max}+1}\\tilde{F}_{\\ell_{\\max}-1}$$\n    The error in the derivative, $\\Delta F_{\\ell_{\\max}}' = \\tilde{F}_{\\ell_{\\max}}' - F_{\\ell_{\\max}}'$, is found by subtracting the true evolution equation from the truncated one:\n    $$\\Delta F_{\\ell_{\\max}}' \\approx \\frac{k(\\ell_{\\max}+1)}{2\\ell_{\\max}+1} F_{\\ell_{\\max}+1}$$\n    where we have assumed that errors in lower multipoles are initially small, i.e., $\\tilde{F}_{\\ell_{\\max}-1} \\approx F_{\\ell_{\\max}-1}$. Since $F_{\\ell_{\\max}+1} \\neq 0$ physically, the naive closure introduces an error source term $\\Delta F_{\\ell_{\\max}}'$. This error propagates downwards through the hierarchy. The equation for any lower multipole $\\ell-1$ is $F_{\\ell-1}' = \\frac{k}{2\\ell-1}\\left[(\\ell-1)F_{\\ell-2} - \\ell F_\\ell\\right]$, which shows that the error $\\Delta F_{\\ell_{\\max}}$ will source an error $\\Delta F_{\\ell_{\\max}-1}'$, which in turn sources an error in $\\Delta F_{\\ell_{\\max}-2}'$, and so on. This cascade of errors inevitably reaches $F_3$, creating an error $\\Delta F_3$.\n\n5.  **Conclusion:**\n    The error $\\Delta F_3$ feeds into the evolution of the quadrupole:\n    $$\\Delta F_2' = \\tilde{F}_2' - F_2' = k\\left(-\\frac{3}{5}\\Delta F_3\\right)$$\n    This creates an error $\\Delta F_2$ that accumulates over time. This spurious $\\tilde{F}_2 = F_2 + \\Delta F_2$ directly generates a spurious anisotropic stress $\\tilde{\\sigma}_\\nu = \\frac{1}{2}\\tilde{F}_2$. As shown in step 1, this results in a non-physical gravitational slip:\n    $$(\\phi - \\psi)_{\\text{spurious}} = \\frac{3H^2}{k^2} \\tilde{F}_2 \\neq \\frac{3H^2}{k^2} F_2 = (\\phi - \\psi)_{\\text{physical}}$$\n    This completes the proof. The inappropriate closure $F_{\\ell_{\\max}+1}=0$ introduces a systematic error that contaminates the entire hierarchy, culminating in a physically incorrect evolution of the metric potentials.\n\n### Part 2: Design of a Numerical Test\n\nThe numerical test is designed to quantify the contamination described above by comparing results from two different closure schemes for the Boltzmann hierarchy.\n\n1.  **System of ODEs:** The core of the test is the numerical integration of the system of $\\ell_{\\max}+1$ coupled first-order ODEs for the multipole vector $\\vec{F}(\\tau) = [F_0, F_1, \\dots, F_{\\ell_{\\max}}]^T$.\n2.  **Equations of Motion:** The derivatives $F_\\ell' = dF_\\ell/d\\tau$ are given by the Boltzmann hierarchy. The equations for $F_0'$ and $F_1'$ are modified to include the gravitational source terms $\\phi'$ and $\\psi$, calculated self-consistently under the quasi-static subhorizon approximation ($k \\gg H(\\tau)$).\n    -   Potentials: $\\psi(\\tau) = -\\frac{3}{2}\\frac{H^2(\\tau)}{k^2}F_0(\\tau)$ and $\\phi(\\tau) = \\psi(\\tau) + \\frac{3H^2(\\tau)}{k^2}F_2(\\tau)$, with $H(\\tau)=1/\\tau$.\n    -   Term $F_0'$: The term $\\phi'$ in the $F_0'$ equation is eliminated algebraically by differentiating the expression for $\\phi(\\tau)$ and substituting it back into the $F_0'$ equation. This results in an equation for $F_0'$ that depends on $F_0, F_1, F_2, F_3$.\n    -   Term $F_1'$: The potential $\\psi$ is substituted directly into the equation for $F_1'$.\n    -   Hierarchy: The remaining equations for $F_\\ell'$ ($\\ell \\ge 2$) are used as given.\n\n3.  **Closure Schemes:** The system is integrated twice, each time with a different closure for $F_{\\ell_{\\max}+1}$:\n    -   **Naive Closure:** $F_{\\ell_{\\max}+1}(\\tau) = 0$. This is expected to produce contamination.\n    -   **Physically Motivated Closure:** $F_{\\ell_{\\max}+1}(\\tau) \\approx \\frac{2\\ell_{\\max}+1}{k\\tau}F_{\\ell_{\\max}}(\\tau)$. This is an asymptotic approximation valid in the free-streaming limit ($k\\tau \\gg \\ell_{\\max}$) and serves as a more accurate physical reference.\n\n4.  **Diagnostic and Detection:** The diagnostic is the gravitational slip parameter, $\\eta(\\tau) = \\frac{\\phi(\\tau)-\\psi(\\tau)}{\\psi(\\tau)}$. Using the quasi-static approximations:\n    $$\\eta(\\tau) = \\frac{(3H^2/k^2) F_2(\\tau)}{-(3H^2/2k^2) F_0(\\tau)} = -2\\frac{F_2(\\tau)}{F_0(\\tau)}$$\n    The test proceeds as follows:\n    a. Integrate the ODE system from $\\tau_i$ to $\\tau_f$ with initial conditions $F_0(\\tau_i)=10^{-5}$ and $F_{\\ell\\ge1}(\\tau_i)=0$. Do this for both the naive and physical closures to obtain the final state vectors $\\vec{F}_{\\text{naive}}(\\tau_f)$ and $\\vec{F}_{\\text{phys}}(\\tau_f)$.\n    b. Calculate the final slip parameter for both cases: $\\eta_{\\text{naive}}(\\tau_f) = -2 \\frac{F_{2, \\text{naive}}(\\tau_f)}{F_{0, \\text{naive}}(\\tau_f)}$ and $\\eta_{\\text{phys}}(\\tau_f) = -2 \\frac{F_{2, \\text{phys}}(\\tau_f)}{F_{0, \\text{phys}}(\\tau_f)}$.\n    c. Compute the absolute difference $\\Delta\\eta = |\\eta_{\\text{naive}} - \\eta_{\\text{phys}}|$.\n    d. Contamination is detected if $\\Delta\\eta$ exceeds the specified threshold for the test case.\n\n### Part 3: Implementation Strategy\n\nThe numerical test is implemented as a Python program.\n-   **ODE Solver:** The `scipy.integrate.solve_ivp` function is used for its robustness and adaptive step-sizing, which is suitable for the potentially stiff or oscillatory behavior of the Boltzmann hierarchy.\n-   **Derivatives Function:** A function, `derivatives(tau, F, k, lmax, closure_type)`, is defined to compute the vector of time derivatives $\\vec{F}'$.\n    - It takes the current time `tau`, the state vector `F`, wavenumber `k`, truncation level `lmax`, and a string specifying the `closure_type`.\n    - It implements the logic to select the closure for $F_{\\ell_{\\max}+1}$.\n    - It computes each $F_\\ell'$ according to the hierarchy equations and the self-consistent quasi-static approximations. The logic is structured to correctly handle the special forms for $\\ell=0, 1, 2$ and the general form for $\\ell \\ge 3$.\n-   **Main Loop:** A main function iterates through the predefined test cases. For each case, it initializes the system, runs the solver twice (once for each closure), computes the contamination diagnostic $\\Delta\\eta$, and compares it to the threshold to produce a boolean result. The final output is formatted as a list of these boolean values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef derivatives(tau, F, k, lmax, closure_type):\n    \"\"\"\n    Computes the time derivative of the Boltzmann hierarchy multipoles F_l.\n\n    Args:\n        tau (float): Conformal time.\n        F (np.ndarray): State vector of multipoles [F_0, F_1, ..., F_lmax].\n        k (float): Comoving wavenumber.\n        lmax (int): Maximum multipole moment in the hierarchy.\n        closure_type (str): Either 'naive' or 'phys' for the closure scheme.\n\n    Returns:\n        np.ndarray: The vector of derivatives dF/dtau.\n    \"\"\"\n    dF = np.zeros(lmax + 1)\n\n    # A helper to get F_l, applying the closure rule for l  lmax.\n    # This simplifies the loops and makes the logic clear.\n    def get_F(l):\n        if l = lmax:\n            return F[l]\n        elif l == lmax + 1:\n            if closure_type == 'naive':\n                return 0.0\n            elif closure_type == 'phys':\n                # Physically motivated free-streaming closure\n                return (2 * lmax + 1) / (k * tau) * F[lmax]\n            else:\n                raise ValueError(\"Unknown closure_type\")\n        else:\n            # For l  lmax + 1, we assume the contribution is zero.\n            # This is implicitly part of the truncation scheme.\n            return 0.0\n\n    # The problem specifies test cases with lmax = 3, so F[0]..F[3] exist.\n    F0, F1, F2, F3 = get_F(0), get_F(1), get_F(2), get_F(3)\n\n    # --- F_0' Equation ---\n    # This is the most complex due to the self-consistent treatment of phi'.\n    # F_0'(1 - 6/(k^2*tau^2)) = -k*F_1 - 12/(k^2*tau^3)*F_0 - 12/(k^2*tau^2)*F_2' + 24/(k^2*tau^3)*F_2\n    # We substitute F_2' = k*(2/5*F_1 - 3/5*F_3)\n    F2_prime = k * (2.0 / 5.0 * F1 - 3.0 / 5.0 * F3)\n    \n    # Pre-computation for clarity\n    k_tau_sq = (k * tau)**2\n    k_sq_tau_cubed = k**2 * tau**3\n    \n    f0_factor = 1.0 - 6.0 / k_tau_sq\n    rhs_f0 = -k * F1 - (12.0 / k_sq_tau_cubed) * F0 \\\n             + (24.0 / k_sq_tau_cubed) * F2 \\\n             - (12.0 / k_tau_sq) * F2_prime\n    dF[0] = rhs_f0 / f0_factor\n\n    # --- F_1' Equation ---\n    # F_1' = k*(F_0/3 - 2*F_2/3) + k*psi, with psi = -1.5/(k^2*tau^2)*F_0\n    psi = -1.5 / k_tau_sq * F0\n    dF[1] = k * (F0 / 3.0 - 2.0 / 3.0 * F2) + k * psi\n\n    # --- F_2' and higher Hierarchy ---\n    # F_2'\n    dF[2] = F2_prime\n\n    # F_l' for l in [3, lmax]\n    for l in range(3, lmax + 1):\n        F_l_minus_1 = get_F(l - 1)\n        F_l_plus_1 = get_F(l + 1)\n        dF[l] = (k / (2 * l + 1.0)) * (l * F_l_minus_1 - (l + 1) * F_l_plus_1)\n\n    return dF\n\n\ndef run_test_case(lmax, k, tau_i, tau_f, threshold):\n    \"\"\"\n    Runs the numerical test for a single case.\n    \"\"\"\n    # Initial conditions\n    y0 = np.zeros(lmax + 1)\n    y0[0] = 1e-5\n\n    # Integration parameters for solve_ivp\n    integration_params = {\n        't_span': [tau_i, tau_f],\n        'y0': y0,\n        'method': 'RK45', # Standard choice\n        'rtol': 1e-9,\n        'atol': 1e-12\n    }\n\n    # Solve with naive closure\n    sol_naive = solve_ivp(derivatives, args=(k, lmax, 'naive'), **integration_params)\n    F_naive_final = sol_naive.y[:, -1]\n\n    # Solve with physical closure\n    sol_phys = solve_ivp(derivatives, args=(k, lmax, 'phys'), **integration_params)\n    F_phys_final = sol_phys.y[:, -1]\n\n    # Calculate slip parameter eta = -2 * F_2 / F_0\n    # Guard against division by zero, although F_0 should be stable.\n    if F_naive_final[0] == 0 or F_phys_final[0] == 0:\n        # This case indicates a numerical failure, should not happen.\n        return False\n        \n    eta_naive = -2.0 * F_naive_final[2] / F_naive_final[0]\n    eta_phys = -2.0 * F_phys_final[2] / F_phys_final[0]\n\n    # Detect contamination\n    delta_eta = abs(eta_naive - eta_phys)\n    return delta_eta  threshold\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (l_max, k, tau_i, tau_f, threshold)\n        (7, 3.0, 20.0, 120.0, 1e-3),\n        (3, 3.0, 20.0, 120.0, 1e-2),\n        (25, 3.0, 20.0, 120.0, 1e-5),\n    ]\n\n    results = []\n    for case in test_cases:\n        lmax, k, tau_i, tau_f, threshold = case\n        result = run_test_case(lmax, k, tau_i, tau_f, threshold)\n        results.append(result)\n\n    # Format output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}