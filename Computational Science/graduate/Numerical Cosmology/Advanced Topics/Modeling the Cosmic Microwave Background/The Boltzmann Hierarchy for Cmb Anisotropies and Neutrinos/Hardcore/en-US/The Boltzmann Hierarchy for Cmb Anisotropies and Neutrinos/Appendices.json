{
    "hands_on_practices": [
        {
            "introduction": "Mastering numerical cosmology begins with the fundamentals. This first practice serves as a crucial validation step, guiding you to implement a basic numerical solver for the collisionless Boltzmann hierarchy. By comparing your numerical results for the first few multipoles against their known analytic solutions in the free-streaming limit, you will gain firsthand experience with the source and magnitude of errors introduced by truncating the infinite hierarchy of equations .",
            "id": "3493623",
            "problem": "Consider the collisionless Boltzmann hierarchy for massless species relevant to Cosmic Microwave Background (CMB) anisotropies and relic neutrinos in Fourier space, expanded in Legendre multipoles. Let $k$ be the comoving wavenumber and $\\tau$ the conformal time, and define the dimensionless time variable $x \\equiv k\\tau$. Denote by $F_\\ell(x)$ the Legendre multipoles of the phase-space brightness perturbation for a single, freely streaming, massless species in the absence of gravitational driving and collisions. The exact, source-free hierarchy in terms of $x$ is a coupled chain of first-order ordinary differential equations,\n$$\n\\frac{d F_\\ell}{dx} = \\frac{1}{2\\ell+1}\\left[\\ell\\,F_{\\ell-1} - (\\ell+1)\\,F_{\\ell+1}\\right],\n$$\nfor all non-negative integers $\\ell$, with regular initial behavior as $x \\to 0$ corresponding to an initially isotropic perturbation. In the radiation-dominated (RD) era, the scale factor obeys $a(\\tau)\\propto \\tau$, while in the matter-dominated (MD) era, $a(\\tau)\\propto \\tau^2$. In the absence of gravitational driving, the dynamics of $F_\\ell$ depends only on $x$ and not on the background expansion history. The homogeneous analytic solution is expressible in terms of spherical Bessel functions.\n\nYour task is to construct and validate a truncated numerical solver for this hierarchy that keeps only the first three multipoles ($\\ell \\le 2$) and closes the system with an asymptotic free-streaming closure at $\\ell=3$:\n$$\nF_3(x) \\approx \\frac{3}{x}\\,F_2(x).\n$$\nThe initial condition corresponds to an initially isotropic perturbation with unit monopole and vanishing higher multipoles in the $x\\to 0$ limit, implemented by starting at a small but finite $x_0$ with regular initial data consistent with isotropy. Use $x_0 = 10^{-6}$.\n\nImplement the following steps:\n- Integrate the truncated system for $F_0(x)$, $F_1(x)$, and $F_2(x)$ from $x=x_0$ to a specified $x=x_{\\mathrm{end}}$ for each test case.\n- For each $x_{\\mathrm{end}}$, compute the analytic homogeneous free-streaming solution for $\\ell \\in \\{0,1,2\\}$ in terms of spherical Bessel functions, normalized to match the same initial monopole amplitude.\n- For each $\\ell \\in \\{0,1,2\\}$, compute the relative deviation\n$$\n\\epsilon_\\ell(x_{\\mathrm{end}}) \\equiv \\frac{\\left|F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}}) - F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|}{\\max\\left(\\left|F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|, 10^{-14}\\right)}.\n$$\n- Report, for each test case, the maximum deviation over $\\ell \\in \\{0,1,2\\}$:\n$$\n\\epsilon_{\\max}(x_{\\mathrm{end}}) \\equiv \\max\\{\\epsilon_0(x_{\\mathrm{end}}), \\epsilon_1(x_{\\mathrm{end}}), \\epsilon_2(x_{\\mathrm{end}})\\}.\n$$\n\nTest suite:\n- Radiation-dominated era (RD), $x_{\\mathrm{end}} = 10^{-3}$.\n- Radiation-dominated era (RD), $x_{\\mathrm{end}} = 1$.\n- Radiation-dominated era (RD), $x_{\\mathrm{end}} = 20$.\n- Matter-dominated era (MD), $x_{\\mathrm{end}} = 10^{-3}$.\n- Matter-dominated era (MD), $x_{\\mathrm{end}} = 1$.\n- Matter-dominated era (MD), $x_{\\mathrm{end}} = 20$.\n\nNotes and requirements:\n- Use the homogeneous free-streaming analytic solution in terms of spherical Bessel functions as the reference for validation. Because gravitational driving is neglected, the relationship between the hierarchy and $x$ is identical in both the radiation-dominated and matter-dominated eras; the two eras enter only through the interpretation of $x$ with respect to $\\tau$ and $a(\\tau)$, not the $x$-evolution of the hierarchy.\n- Ensure the numerical initial data at $x_0 = 10^{-6}$ are regular and consistent with an initially isotropic perturbation with unit monopole amplitude and vanishing dipole and quadrupole in the $x\\to 0$ limit.\n- Angles do not appear explicitly; no angle unit is needed.\n- All quantities are dimensionless; no physical unit conversion is required.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5,r_6]$), where each $r_i$ is the value of $\\epsilon_{\\max}(x_{\\mathrm{end}})$ for the corresponding test case in the order specified above. Each $r_i$ must be printed as a floating-point number in scientific notation with exactly $8$ significant digits.",
            "solution": "The user wants to solve a problem from numerical cosmology concerning the Boltzmann hierarchy.\n\n### Problem Validation\n\n**Step 1: Extracted Givens**\n- **System**: Collisionless Boltzmann hierarchy for massless species.\n- **Variables and Definitions**: Comoving wavenumber $k$, conformal time $\\tau$, dimensionless time $x \\equiv k\\tau$.\n- **Perturbation Multipoles**: $F_\\ell(x)$, Legendre multipoles of the phase-space brightness perturbation.\n- **Hierarchy Equation**: $\\frac{d F_\\ell}{dx} = \\frac{1}{2\\ell+1}\\left[\\ell\\,F_{\\ell-1} - (\\ell+1)\\,F_{\\ell+1}\\right]$ for non-negative integers $\\ell$.\n- **Initial Conditions**: Regular initial behavior as $x \\to 0$ for an initially isotropic perturbation with unit monopole amplitude.\n- **Numerical Truncation**: Solve for $\\ell \\le 2$, i.e., for $F_0(x)$, $F_1(x)$, and $F_2(x)$.\n- **Closure Relation**: The system is closed at $\\ell=3$ using the approximation $F_3(x) \\approx \\frac{3}{x}\\,F_2(x)$.\n- **Numerical Integration Start**: $x_0 = 10^{-6}$, with regular initial data.\n- **Analytic Solution**: The exact homogeneous solution is given in terms of spherical Bessel functions, $j_\\ell(x)$.\n- **Error Metrics**:\n  - Relative deviation: $\\epsilon_\\ell(x_{\\mathrm{end}}) \\equiv \\frac{\\left|F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}}) - F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|}{\\max\\left(\\left|F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|, 10^{-14}\\right)}$.\n  - Maximum deviation: $\\epsilon_{\\max}(x_{\\mathrm{end}}) \\equiv \\max\\{\\epsilon_0(x_{\\mathrm{end}}), \\epsilon_1(x_{\\mathrm{end}}), \\epsilon_2(x_{\\mathrm{end}})\\}$.\n- **Test Cases**:\n    1. Radiation-dominated (RD), $x_{\\mathrm{end}} = 10^{-3}$.\n    2. Radiation-dominated (RD), $x_{\\mathrm{end}} = 1$.\n    3. Radiation-dominated (RD), $x_{\\mathrm{end}} = 20$.\n    4. Matter-dominated (MD), $x_{\\mathrm{end}} = 10^{-3}$.\n    5. Matter-dominated (MD), $x_{\\mathrm{end}} = 1$.\n    6. Matter-dominated (MD), $x_{\\mathrm{end}} = 20$.\n- **Auxiliary Information**: The evolution of $F_\\ell(x)$ depends only on $x$, not on the background expansion history (RD or MD).\n\n**Step 2: Validation of Givens**\n- **Scientific Grounding**: The problem is scientifically sound. The Boltzmann hierarchy is a fundamental tool in physical cosmology for studying the evolution of perturbations. The equation provided is the correct one for free-streaming massless particles. The use of spherical Bessel functions as the analytic solution for an initially isotropic perturbation is also correct. The task of testing a numerical truncation and closure scheme against an analytic solution is a standard and valid exercise in computational physics.\n- **Well-Posedness**: The problem is well-posed. It provides a system of ordinary differential equations (ODEs), a specific closure relation that makes the truncated system solvable, and a well-defined initial condition. The objective—to calculate a specific error metric—is unambiguous.\n- **Completeness and Consistency**: The problem is self-contained.\n  - The initial condition, while stated descriptively (\"regular initial behavior...\"), can be uniquely determined. For an initial condition $F_\\ell(0) = \\delta_{\\ell 0}$, the analytic solution is $F_\\ell(x) = j_\\ell(x)$. Thus, the numerical initial data at the small starting value $x_0 = 10^{-6}$ should be set to $F_\\ell(x_0) = j_\\ell(x_0)$ for $\\ell \\in \\{0, 1, 2\\}$.\n  - The problem specifies test cases for both RD and MD eras but also explicitly states that the dynamics of $F_\\ell(x)$ are identical in both scenarios. This implies that the results for test cases with the same $x_{\\mathrm{end}}$ will be identical (i.e., case 1=4, 2=5, 3=6). This is not a contradiction but a redundancy that tests the understanding of the underlying physics.\n  - The provided closure relation, $F_3(x) \\approx \\frac{3}{x}F_2(x)$, is a defining feature of the numerical scheme to be tested. While it may not be a highly accurate physical approximation, its validity is not a prerequisite for the problem itself, which is to quantify the error introduced by this specific approximation.\n\n**Step 3: Verdict and Action**\nThe problem is valid. I will proceed with the solution.\n\n### Solution Design\n\nThe core of the problem is to solve a truncated system of ordinary differential equations and compare the result to a known analytic solution.\n\n**1. The Truncated System of ODEs**\nWe are solving for the vector of perturbations $\\vec{F}(x) = [F_0(x), F_1(x), F_2(x)]^T$. The hierarchy equations for $\\ell=0, 1, 2$ are:\n$$\n\\frac{d F_0}{dx} = \\frac{1}{1}\\left[0 \\cdot F_{-1} - (0+1)F_1\\right] = -F_1\n$$\n$$\n\\frac{d F_1}{dx} = \\frac{1}{2(1)+1}\\left[1 \\cdot F_0 - (1+1)F_2\\right] = \\frac{1}{3}(F_0 - 2F_2)\n$$\n$$\n\\frac{d F_2}{dx} = \\frac{1}{2(2)+1}\\left[2 \\cdot F_1 - (2+1)F_3\\right] = \\frac{1}{5}(2F_1 - 3F_3)\n$$\nThe system is closed using the provided relation $F_3(x) = \\frac{3}{x}F_2(x)$. Substituting this into the equation for $F_2$ gives:\n$$\n\\frac{d F_2}{dx} = \\frac{1}{5}\\left(2F_1 - 3 \\cdot \\frac{3}{x}F_2\\right) = \\frac{2}{5}F_1 - \\frac{9}{5x}F_2\n$$\nThis results in the following linear system of first-order ODEs:\n$$\n\\frac{d}{dx}\n\\begin{pmatrix} F_0 \\\\ F_1 \\\\ F_2 \\end{pmatrix}\n=\n\\begin{pmatrix}\n0 & -1 & 0 \\\\\n1/3 & 0 & -2/3 \\\\\n0 & 2/5 & -9/(5x)\n\\end{pmatrix}\n\\begin{pmatrix} F_0 \\\\ F_1 \\\\ F_2 \\end{pmatrix}\n$$\n\n**2. Initial Conditions**\nThe problem states that the initial perturbation is isotropic with a unit monopole, i.e., $F_\\ell(x \\to 0) = \\delta_{\\ell 0}$. The analytic solution to the full hierarchy with this initial condition is $F_\\ell(x) = j_\\ell(x)$, where $j_\\ell(x)$ is the spherical Bessel function of the first kind. To start the numerical integration at $x_0 = 10^{-6}$, we set the initial state vector to the values of the analytic solution at that point:\n$$\n\\vec{F}(x_0) = \\begin{pmatrix} F_0(x_0) \\\\ F_1(x_0) \\\\ F_2(x_0) \\end{pmatrix} = \\begin{pmatrix} j_0(x_0) \\\\ j_1(x_0) \\\\ j_2(x_0) \\end{pmatrix}\n$$\n\n**3. Numerical Integration**\nThe system of ODEs will be integrated numerically from $x_0 = 10^{-6}$ to each specified $x_{\\mathrm{end}} \\in \\{10^{-3}, 1, 20\\}$. We will use a high-precision adaptive step-size solver, such as the one provided by `scipy.integrate.solve_ivp`, to ensure that the error is dominated by the closure approximation itself, not by numerical integration inaccuracies. We set stringent relative and absolute tolerances (e.g., $10^{-12}$ and $10^{-14}$).\n\n**4. Analytic Reference and Error Calculation**\nFor each $x_{\\mathrm{end}}$, the numerical solution $F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}})$ is compared against the analytic solution $F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}}) = j_\\ell(x_{\\mathrm{end}})$. The relative deviation $\\epsilon_\\ell(x_{\\mathrm{end}})$ is computed for each $\\ell \\in \\{0,1,2\\}$ using the provided formula:\n$$\n\\epsilon_\\ell(x_{\\mathrm{end}}) = \\frac{\\left|F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}}) - j_\\ell(x_{\\mathrm{end}})\\right|}{\\max\\left(\\left|j_\\ell(x_{\\mathrm{end}})\\right|, 10^{-14}\\right)}\n$$\nThe final result for each test case is the maximum of these deviations, $\\epsilon_{\\max}(x_{\\mathrm{end}}) = \\max_{ \\ell \\in \\{0,1,2\\}} \\epsilon_\\ell(x_{\\mathrm{end}})$.\n\n**5. Handling of Test Cases**\nAs established during validation, the distinction between RD and MD eras is irrelevant for the calculation of $F_\\ell(x)$. Therefore, the calculations for $x_{\\mathrm{end}} = 10^{-3}$, $x_{\\mathrm{end}} = 1$, and $x_{\\mathrm{end}} = 20$ are performed once, and the results are duplicated for the corresponding RD and MD test cases in the final output. The final list of results will have $6$ entries.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Solves the truncated Boltzmann hierarchy and computes the maximum relative\n    deviation from the analytic solution for a set of test cases.\n    \"\"\"\n    # Define constants from the problem statement.\n    x0 = 1.0e-6\n    floor_val = 1.0e-14\n\n    # Define the test cases. Note that the distinction between RD and MD eras is\n    # irrelevant for the computation of F_l(x), as the hierarchy's evolution\n    # only depends on the dimensionless variable x.\n    x_end_values_unique = [1.0e-3, 1.0, 20.0]\n    test_cases_x_end = [1.0e-3, 1.0, 20.0] * 2 # RD cases followed by MD cases\n\n    def boltzmann_hierarchy_truncated(x, F):\n        \"\"\"\n        Defines the system of ODEs for the truncated Boltzmann hierarchy.\n        \n        Args:\n            x (float): The dimensionless time variable k*tau.\n            F (np.ndarray): The state vector [F0, F1, F2].\n        \n        Returns:\n            list: The derivatives [dF0/dx, dF1/dx, dF2/dx].\n        \"\"\"\n        F0, F1, F2 = F\n        \n        # Equation for F_0: d_x F_0 = -F_1\n        dF0_dx = -F1\n        \n        # Equation for F_1: d_x F_1 = (1/3)*(F_0 - 2*F_2)\n        dF1_dx = F0 / 3.0 - (2.0 / 3.0) * F2\n        \n        # Equation for F_2 with closure F_3 = (3/x)*F_2:\n        # d_x F_2 = (1/5)*(2*F_1 - 3*F_3) = (2/5)*F_1 - (9/5x)*F_2\n        if x == 0:\n            # This case should not be reached since we start at x0 > 0.\n            # The small-x limit of dF2/dx is 0.\n            dF2_dx = 0.0\n        else:\n            dF2_dx = (2.0 / 5.0) * F1 - (9.0 / (5.0 * x)) * F2\n            \n        return [dF0_dx, dF1_dx, dF2_dx]\n\n    # Store results for unique x_end values to avoid redundant computations.\n    unique_results = {}\n\n    for x_end in x_end_values_unique:\n        # Set initial conditions using the analytic solution at x0.\n        # F_l(x0) = j_l(x0) for l=0,1,2.\n        F_initial = spherical_jn([0, 1, 2], x0)\n\n        # Numerically integrate the system of ODEs.\n        # Use high-precision tolerances to isolate the error from the closure.\n        sol = solve_ivp(\n            fun=boltzmann_hierarchy_truncated,\n            t_span=[x0, x_end],\n            y0=F_initial,\n            t_eval=[x_end],\n            method='LSODA',  # Good for potentially stiff problems like this.\n            rtol=1e-12,\n            atol=1e-14\n        )\n        # Numerical solution at x_end\n        F_num = sol.y.flatten()\n\n        # Analytic solution at x_end is j_l(x_end)\n        F_ana = spherical_jn([0, 1, 2], x_end)\n\n        # Compute the relative deviation for each multipole l={0,1,2}.\n        numerator = np.abs(F_num - F_ana)\n        denominator = np.maximum(np.abs(F_ana), floor_val)\n        epsilons = numerator / denominator\n        \n        # Find the maximum deviation for this test case.\n        epsilon_max = np.max(epsilons)\n        unique_results[x_end] = epsilon_max\n\n    # Assemble the final list of results in the specified order.\n    results = [unique_results[x] for x in test_cases_x_end]\n\n    # Format the output as specified: a list of floats in scientific\n    # notation with 8 significant digits.\n    formatted_results = [f\"{r:.8e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the foundational solver, we now address a key question in numerical implementation: how can we improve accuracy? This exercise challenges you to compare a naive truncation scheme with a more sophisticated \"closure relation\" derived from the physical properties of free-streaming particles. By quantifying the error introduced by different closures, you will learn a practical and essential technique for managing truncation errors in modern Boltzmann codes .",
            "id": "3493597",
            "problem": "Consider the linearized collisionless Boltzmann equation for massless species perturbations in a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) background, as applied to the Cosmic Microwave Background (CMB) anisotropies and cosmological neutrinos. In Fourier space, for a single comoving wavenumber $k$, the angular dependence of the brightness perturbation can be expanded in Legendre multipoles $\\Theta_\\ell(\\tau)$, where $\\tau$ is conformal time. The collisionless free-streaming part of the Boltzmann hierarchy is a system of coupled first-order ordinary differential equations (ODEs) of the form\n$$\n\\frac{d\\Theta_\\ell}{d\\tau} = \\frac{k}{2\\ell+1}\\left[\\ell\\,\\Theta_{\\ell-1} - (\\ell+1)\\,\\Theta_{\\ell+1}\\right],\n$$\nfor $\\ell \\ge 1$, with the monopole obeying\n$$\n\\frac{d\\Theta_0}{d\\tau} = -k\\,\\Theta_1.\n$$\nThis hierarchy must be truncated at some maximum multipole $\\ell_{\\max}$ in numerical practice, which requires a closure condition to eliminate dependence on $\\Theta_{\\ell_{\\max}+1}$ in the equation for $\\Theta_{\\ell_{\\max}}$. Two widely used closures are: $(i)$ zeroing the tail multipoles, and $(ii)$ extrapolating the next multipole using the known free-streaming recurrence properties of the hierarchy. Truncation and closure introduce numerical errors that can bias derived angular power spectra, especially at high multipoles. Your task is to quantify the impact of different closure schemes on a toy angular power $C_\\ell$ constructed from the evolved multipoles at a fixed final conformal time $\\tau_f$, for several test configurations.\n\nStarting from the collisionless Boltzmann hierarchy above and the definitions of the Legendre multipoles, design and implement a program that:\n- Integrates the truncated hierarchy from $\\tau = 0$ to a specified $\\tau_f$ with initial conditions $\\Theta_0(0) = 1$ and $\\Theta_\\ell(0) = 0$ for all $\\ell \\ge 1$.\n- Applies two closure schemes at $\\ell_{\\max}$ during integration:\n  $1$) Zero-tail closure: set $\\Theta_{\\ell_{\\max}+1} = 0$ when evaluating $d\\Theta_{\\ell_{\\max}}/d\\tau$.\n  $2$) Free-streaming recurrence closure: approximate $\\Theta_{\\ell_{\\max}+1}$ during evolution using the angular recurrence implied by collisionless free-streaming.\n- Computes a dimensionless toy angular power proxy $C_\\ell = \\Theta_\\ell(\\tau_f)^2$ for $\\ell$ in a specified high-$\\ell$ window $[\\ell_1,\\ell_2]$.\n- Evaluates, for each closure scheme, a dimensionless windowed error metric\n$$\n\\mathcal{E} = \\frac{\\sum_{\\ell=\\ell_1}^{\\ell_2} \\left| C_\\ell^{\\text{approx}} - C_\\ell^{\\text{exact}} \\right|}{\\sum_{\\ell=\\ell_1}^{\\ell_2} C_\\ell^{\\text{exact}}},\n$$\nwhere $C_\\ell^{\\text{exact}}$ is obtained from the known collisionless free-streaming solution of the hierarchy. If the denominator is numerically zero, use a small positive regularization to avoid division by zero. All quantities in this problem are dimensionless.\n\nUse a robust ODE integrator with appropriate tolerances to resolve the evolution up to the specified $\\tau_f$ for each test case. Implement both closures and compute the error metric for each.\n\nTest Suite:\nProvide results for the following four test cases, each specified by $(k,\\tau_f,\\ell_{\\max},\\ell_1,\\ell_2)$:\n- Case $1$: $(k=\\;1,\\;\\tau_f=\\;10,\\;\\ell_{\\max}=\\;8,\\;\\ell_1=\\;6,\\;\\ell_2=\\;8)$.\n- Case $2$: $(k=\\;1,\\;\\tau_f=\\;30,\\;\\ell_{\\max}=\\;12,\\;\\ell_1=\\;10,\\;\\ell_2=\\;12)$.\n- Case $3$: $(k=\\;1,\\;\\tau_f=\\;60,\\;\\ell_{\\max}=\\;20,\\;\\ell_1=\\;18,\\;\\ell_2=\\;20)$.\n- Case $4$: $(k=\\;1,\\;\\tau_f=\\;8,\\;\\ell_{\\max}=\\;8,\\;\\ell_1=\\;7,\\;\\ell_2=\\;8)$.\n\nFinal Output Specification:\nYour program should produce a single line of output containing the error metrics for all test cases and both closure schemes, concatenated in order, as a comma-separated list enclosed in square brackets. The ordering must be $[\\mathcal{E}_{\\text{Z2, Case 1}},\\mathcal{E}_{\\text{REC, Case 1}},\\mathcal{E}_{\\text{Z2, Case 2}},\\mathcal{E}_{\\text{REC, Case 2}},\\mathcal{E}_{\\text{Z2, Case 3}},\\mathcal{E}_{\\text{REC, Case 3}},\\mathcal{E}_{\\text{Z2, Case 4}},\\mathcal{E}_{\\text{REC, Case 4}}]$, where \"Z2\" denotes the zero-tail closure and \"REC\" denotes the free-streaming recurrence closure. Express all numbers as decimal floats. The output must be dimensionless and printed in exactly this format.",
            "solution": "The user wants me to solve a numerical cosmology problem that compares two different closure schemes for the truncated Boltzmann hierarchy.\n\n### Problem Validation\nThe problem is scientifically sound, well-posed, and objective. It asks to solve a standard system of ODEs from physical cosmology (the collisionless Boltzmann hierarchy) with specified initial conditions. The core task is to implement and compare two different numerical closure schemes against a known analytical solution, which is a standard validation technique in computational physics.\n-   **Equations**: The provided hierarchy equations are correct for free-streaming massless particles.\n-   **Initial Conditions**: The initial condition $\\Theta_0(0)=1, \\Theta_{\\ell>0}(0)=0$ is standard for an initially isotropic perturbation and correctly corresponds to the analytical solution $\\Theta_\\ell(\\tau) = j_\\ell(k\\tau)$, where $j_\\ell$ are the spherical Bessel functions.\n-   **Closures**: The two closure schemes—\"zero-tail\" ($\\Theta_{\\ell_{\\max}+1} = 0$) and \"free-streaming recurrence\"—are well-defined. The recurrence closure is derived from the properties of the analytical solution (spherical Bessel functions), making it a physically motivated and more accurate choice to compare against.\n-   **Error Metric**: The windowed error metric $\\mathcal{E}$ is a clear, quantitative way to compare the accuracy of the power spectra proxies $C_\\ell = \\Theta_\\ell^2$ produced by each scheme.\n-   **Test Cases**: The test cases are specific and cover different regimes of evolution time ($\\tau_f$) and truncation level ($\\ell_{\\max}$), allowing for a meaningful comparison.\n\nThe problem is valid and can be solved as stated.\n\n### Solution Path\n\nThe problem asks us to solve a system of coupled first-order ordinary differential equations (ODEs) that describe the evolution of massless particle perturbations (like photons or neutrinos) in the early universe, known as the collisionless Boltzmann hierarchy. We will compare two numerical truncation schemes against the known exact analytical solution.\n\n**1. The Boltzmann Hierarchy and its Analytical Solution**\n\nThe evolution of the Legendre multipoles of the brightness perturbation, $\\Theta_\\ell(\\tau)$, is governed by the hierarchy:\n$$\n\\frac{d\\Theta_0}{d\\tau} = -k\\,\\Theta_1\n$$\n$$\n\\frac{d\\Theta_\\ell}{d\\tau} = \\frac{k}{2\\ell+1}\\left[\\ell\\,\\Theta_{\\ell-1} - (\\ell+1)\\,\\Theta_{\\ell+1}\\right], \\quad \\text{for } \\ell \\ge 1\n$$\nwhere $k$ is the comoving wavenumber and $\\tau$ is conformal time. The given initial conditions are $\\Theta_0(0) = 1$ and $\\Theta_\\ell(0) = 0$ for $\\ell \\ge 1$. This corresponds to an initially isotropic perturbation.\n\nThis system of ODEs has a known exact analytical solution given by the spherical Bessel functions of the first kind, $j_\\ell(x)$:\n$$\n\\Theta_\\ell^{\\text{exact}}(\\tau) = j_\\ell(k\\tau)\n$$\nThis exact solution will serve as our \"ground truth\" for calculating the error of the numerical approximations. The spherical Bessel functions can be computed using standard scientific libraries.\n\n**2. Numerical Integration and Truncation**\n\nIn practice, the infinite hierarchy must be truncated at some maximum multipole, $\\ell_{\\max}$. We solve numerically for the state vector $Y(\\tau) = [\\Theta_0(\\tau), \\Theta_1(\\tau), \\dots, \\Theta_{\\ell_{\\max}}(\\tau)]$. The equation for the last multipole, $\\Theta_{\\ell_{\\max}}$, depends on $\\Theta_{\\ell_{\\max}+1}$, which is outside our truncated system. This requires a \"closure\" assumption to approximate $\\Theta_{\\ell_{\\max}+1}$. We will implement two such schemes.\n\nThe ODE system will be integrated from $\\tau=0$ to $\\tau_f$ using a robust numerical solver, specifically `scipy.integrate.solve_ivp`, which is well-suited for such problems.\n\n**3. Closure Schemes**\n\nThe core of the problem lies in implementing the two different closure rules for the final equation in the hierarchy, at $\\ell = \\ell_{\\max}$:\n\n**a) Zero-Tail Closure (Z2)**:\nThis is the simplest approach. We assume that all multipoles beyond $\\ell_{\\max}$ are negligible:\n$$\n\\Theta_{\\ell_{\\max}+1}(\\tau) = 0\n$$\nSubstituting this into the general hierarchy equation for $\\ell = \\ell_{\\max}$ gives:\n$$\n\\frac{d\\Theta_{\\ell_{\\max}}}{d\\tau} = \\frac{k}{2\\ell_{\\max}+1}\\left[\\ell_{\\max}\\,\\Theta_{\\ell_{\\max}-1} - (\\ell_{\\max}+1)\\cdot 0\\right] = \\frac{k\\ell_{\\max}}{2\\ell_{\\max}+1}\\Theta_{\\ell_{\\max}-1}\n$$\n\n**b) Free-Streaming Recurrence Closure (REC)**:\nThis more sophisticated closure uses the known properties of the exact solution. The spherical Bessel functions obey the recurrence relation:\n$$\nj_{\\ell+1}(x) = \\frac{2\\ell+1}{x}j_\\ell(x) - j_{\\ell-1}(x)\n$$\nWe use this to approximate $\\Theta_{\\ell_{\\max}+1}$ in terms of multipoles within our system:\n$$\n\\Theta_{\\ell_{\\max}+1}(\\tau) \\approx \\frac{2\\ell_{\\max}+1}{k\\tau}\\Theta_{\\ell_{\\max}}(\\tau) - \\Theta_{\\ell_{\\max}-1}(\\tau)\n$$\nSubstituting this into the ODE for $\\ell = \\ell_{\\max}$ and simplifying, we obtain the evolution equation for the REC closure:\n$$\n\\frac{d\\Theta_{\\ell_{\\max}}}{d\\tau} = k\\Theta_{\\ell_{\\max}-1} - \\frac{\\ell_{\\max}+1}{\\tau}\\Theta_{\\ell_{\\max}}\n$$\nA computational issue arises at $\\tau=0$ due to the $1/\\tau$ term. We handle this by analyzing the limit. For $\\tau \\to 0$, the limiting value of the derivative is found to be $0$ for $\\ell_{\\max} > 1$ and $k/3$ for $\\ell_{\\max}=1$. Our implementation will explicitly handle the case where $\\tau$ is close to zero to avoid division by zero.\n\n**4. Error Metric Calculation**\n\nFor each test case and closure scheme, we integrate the hierarchy to get the approximate multipoles, $\\Theta_\\ell^{\\text{approx}}(\\tau_f)$. We then compute the toy power spectrum proxy, $C_\\ell^{\\text{approx}} = (\\Theta_\\ell^{\\text{approx}}(\\tau_f))^2$. The exact power spectrum, $C_\\ell^{\\text{exact}}$, is computed using the analytical solution: $C_\\ell^{\\text{exact}} = (j_\\ell(k\\tau_f))^2$.\n\nThe dimensionless windowed error metric, $\\mathcal{E}$, is then calculated over a specified range $[\\ell_1, \\ell_2]$:\n$$\n\\mathcal{E} = \\frac{\\sum_{\\ell=\\ell_1}^{\\ell_2} \\left| C_\\ell^{\\text{approx}} - C_\\ell^{\\text{exact}} \\right|}{\\sum_{\\ell=\\ell_1}^{\\ell_2} C_\\ell^{\\text{exact}}}\n$$\nA small regularization constant is added to the denominator to prevent division by zero in cases where the exact power is numerically zero over the window.\n\n**5. Algorithm Summary**\n\nThe overall algorithm is as follows:\n1.  For each test case $(k, \\tau_f, \\ell_{\\max}, \\ell_1, \\ell_2)$:\n    a. Define the initial conditions vector $Y_0$ of length $\\ell_{\\max}+1$.\n    b. Compute the exact solution $C_\\ell^{\\text{exact}}$ for $\\ell \\in [\\ell_1, \\ell_2]$ using spherical Bessel functions. Calculate the denominator for the error metric.\n    c. Integrate the ODE system from $\\tau=0$ to $\\tau_f$ using the Z2 closure. Compute $C_\\ell^{\\text{approx, Z2}}$ and the error $\\mathcal{E}_{\\text{Z2}}$.\n    d. Integrate the ODE system from $\\tau=0$ to $\\tau_f$ using the REC closure. Compute $C_\\ell^{\\text{approx, REC}}$ and the error $\\mathcal{E}_{\\text{REC}}$.\n    e. Store $\\mathcal{E}_{\\text{Z2}}$ and $\\mathcal{E}_{\\text{REC}}$.\n2.  Concatenate all computed error metrics into a single list and print in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn\nfrom scipy.integrate import solve_ivp\n\ndef boltzmann_hierarchy(tau, y, k, lmax, closure):\n    \"\"\"\n    RHS of the Boltzmann hierarchy ODE system.\n    y is the state vector [Theta_0, Theta_1, ..., Theta_lmax].\n    \"\"\"\n    dydt = np.zeros_like(y)\n    \n    # Monopole equation (l=0)\n    # d(Theta_0)/d(tau) = -k * Theta_1\n    if lmax >= 1:\n        dydt[0] = -k * y[1]\n    \n    # Dipole to lmax-1 (l=1 to lmax-1)\n    # d(Theta_l)/d(tau) = k/(2l+1) * [l*Theta_{l-1} - (l+1)*Theta_{l+1}]\n    for l in range(1, lmax):\n        dydt[l] = k / (2 * l + 1) * (l * y[l-1] - (l + 1) * y[l+1])\n        \n    # Top of the hierarchy (l=lmax)\n    if lmax >= 1:\n        if closure == 'Z2':\n            # Zero-tail closure: Theta_{lmax+1} = 0\n            # d(Theta_lmax)/d(tau) = k*lmax / (2*lmax+1) * Theta_{lmax-1}\n            dydt[lmax] = k * lmax / (2 * lmax + 1) * y[lmax - 1]\n        elif closure == 'REC':\n            # Recurrence closure:\n            # d(Theta_lmax)/d(tau) = k*Theta_{lmax-1} - (lmax+1)/tau * Theta_{lmax}\n            # Handle tau=0 singularity.\n            if tau  1e-12: # Check for tau being numerically zero\n                if lmax == 1:\n                    # For lmax=1, d(Theta_1)/d(tau) -> k/3 * Theta_0 at tau=0\n                    dydt[lmax] = k / 3.0 * y[0]\n                else:\n                    # For lmax > 1, d(Theta_lmax)/d(tau) -> 0 at tau=0\n                    dydt[lmax] = 0.0\n            else:\n                dydt[lmax] = k * y[lmax - 1] - (lmax + 1) / tau * y[lmax]\n    \n    return dydt\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute error metrics.\n    \"\"\"\n    test_cases = [\n        (1.0, 10.0, 8, 6, 8),\n        (1.0, 30.0, 12, 10, 12),\n        (1.0, 60.0, 20, 18, 20),\n        (1.0, 8.0, 8, 7, 8),\n    ]\n\n    results = []\n    \n    # Use a robust ODE solver with strict tolerances for accuracy\n    solver_method = 'Radau'\n    atol = 1e-10\n    rtol = 1e-10\n    regularization_eps = 1e-30\n\n    for k, tau_f, lmax, l1, l2 in test_cases:\n        # Initial conditions: Theta_0(0) = 1, Theta_l(0) = 0 for l>0\n        y0 = np.zeros(lmax + 1)\n        y0[0] = 1.0\n        \n        # Integration time span\n        t_span = [0, tau_f]\n        \n        # 1. Compute exact solution for the error metric denominator\n        ls = np.arange(l1, l2 + 1)\n        thetas_exact = spherical_jn(ls, k * tau_f)\n        Cls_exact = thetas_exact**2\n        \n        denominator = np.sum(Cls_exact)\n        if denominator  regularization_eps:\n            denominator = regularization_eps\n\n        # 2. Run with Zero-tail (Z2) closure\n        sol_z2 = solve_ivp(\n            boltzmann_hierarchy, t_span, y0,\n            method=solver_method, args=(k, lmax, 'Z2'),\n            atol=atol, rtol=rtol\n        )\n        thetas_z2_final = sol_z2.y[:, -1]\n        \n        Cls_approx_z2 = thetas_z2_final[l1:l2 + 1]**2\n        numerator_z2 = np.sum(np.abs(Cls_approx_z2 - Cls_exact))\n        error_z2 = numerator_z2 / denominator\n        results.append(error_z2)\n\n        # 3. Run with Recurrence (REC) closure\n        sol_rec = solve_ivp(\n            boltzmann_hierarchy, t_span, y0,\n            method=solver_method, args=(k, lmax, 'REC'),\n            atol=atol, rtol=rtol\n        )\n        thetas_rec_final = sol_rec.y[:, -1]\n        \n        Cls_approx_rec = thetas_rec_final[l1:l2 + 1]**2\n        numerator_rec = np.sum(np.abs(Cls_approx_rec - Cls_exact))\n        error_rec = numerator_rec / denominator\n        results.append(error_rec)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice bridges the gap between numerical methods and their profound physical implications. You will investigate how numerical inaccuracies, specifically those arising from poor closure choices, can generate a spurious anisotropic stress. This exercise demonstrates that the choice of numerical scheme has direct, observable consequences on the spacetime metric itself by creating an artificial difference between the gravitational potentials $\\phi$ and $\\psi$, highlighting why precision is paramount in cosmological simulations .",
            "id": "3493570",
            "problem": "Consider linear scalar perturbations in a spatially flat Friedmann–Lemaître–Robertson–Walker universe in the Newtonian gauge with line element $ds^2 = a^2(\\tau)\\left\\{-(1+2\\psi)d\\tau^2 + (1-2\\phi)d\\mathbf{x}^2\\right\\}$, where $a(\\tau)$ is the scale factor and $\\tau$ is conformal time. Focus on collisionless, massless neutrinos as the only matter component, and consider one Fourier mode with comoving wavenumber $k$. The perturbation of the phase-space distribution function of the neutrinos is expanded in Legendre multipoles, forming a Boltzmann hierarchy $F_\\ell(\\tau)$ for $\\ell = 0,1,2,\\dots$. The relevant relations include: the linearized Einstein equations in Fourier space for the Newtonian-gauge potentials $\\phi$ and $\\psi$, the definition of anisotropic stress from the Boltzmann multipoles, and the collisionless Boltzmann hierarchy for massless species. Use the following foundational facts as the starting point:\n- In radiation domination, the conformal Hubble rate satisfies $H(\\tau) \\equiv a'(\\tau)/a(\\tau) = 1/\\tau$ and the background Friedmann equation implies $8\\pi G a^2 \\rho = 3H^2$.\n- The Newtonian-gauge Einstein equations (constraints) in Fourier space are\n$$\nk^2 \\psi + 3 H \\left(\\psi' + H \\phi\\right) = -4\\pi G a^2 \\delta \\rho,\\quad\nk^2 \\left(\\psi' + H \\phi\\right) = 4\\pi G a^2 (\\rho + P) \\theta,\\quad\nk^2(\\phi - \\psi) = 12\\pi G a^2 \\sum_s (\\rho_s + P_s) \\sigma_s,\n$$\nwhere primes denote $d/d\\tau$, $\\delta \\rho$ is the energy density perturbation, $\\theta$ is the velocity divergence, and $\\sigma_s$ is the anisotropic stress for species $s$. For a massless species, $(\\rho+P)=\\frac{4}{3}\\rho$.\n- For collisionless massless neutrinos, the standard identification with brightness multipoles holds: $\\delta_\\nu = F_0$, $\\theta_\\nu = \\frac{3k}{4}F_1$, $\\sigma_\\nu = \\frac{1}{2}F_2$, and for $\\ell \\ge 3$ the collisionless evolution is free-streaming.\n- The collisionless Boltzmann hierarchy for massless species’ multipoles is\n$$\nF_0' = -k F_1 - 4\\phi',\\quad\nF_1' = k\\left(\\frac{F_0}{3} - \\frac{2F_2}{3}\\right) + k\\psi,\\quad\nF_2' = k\\left(\\frac{2F_1}{5} - \\frac{3F_3}{5}\\right),\\quad\nF_\\ell' = \\frac{k}{2\\ell+1}\\left[\\ell F_{\\ell-1} - (\\ell+1)F_{\\ell+1}\\right]\\ \\text{for}\\ \\ell\\ge 3.\n$$\n\nYour tasks are:\n1. Prove that truncation of the Boltzmann hierarchy at a finite multipole $l_{\\max}$ with an inappropriate closure for $F_{l_{\\max}+1}$ generically produces spurious anisotropic stress (via an incorrect $F_2$), and thereby causes a nonphysical difference between $\\phi$ and $\\psi$ that feeds back onto the dynamics. Your proof must start from the fundamental equations stated above and proceed by logical steps that do not assume any shortcut formulas not derived in your reasoning. You must make a scientifically realistic approximation choice to carry the proof to a clear mathematical statement, and you must state exactly which regime your approximation applies to.\n2. Design a numerical test to detect contamination of the metric evolution from an inappropriate closure. The test must be implementable as a program and should produce a quantifiable diagnostic. Build the test on a neutrino-only radiation background $a(\\tau) \\propto \\tau$ and work in the subhorizon, quasi-static regime where $k \\gg H(\\tau)$ and the term $3H(\\psi' + H\\phi)$ is negligible in the Poisson-like equation. The detection should be based on comparing the gravitational slip parameter $\\eta(\\tau) \\equiv \\frac{\\phi(\\tau)-\\psi(\\tau)}{\\psi(\\tau)}$ obtained with a physically motivated free-streaming closure versus a naive closure. The physically motivated closure may be taken in the asymptotic free-streaming form $F_{l_{\\max}+1} \\approx \\frac{2l_{\\max}+1}{k\\tau}F_{l_{\\max}}$, while the naive closure sets $F_{l_{\\max}+1}=0$.\n3. Implement the test as a complete runnable program that integrates the Boltzmann hierarchy for a single Fourier mode and computes the final-time slip $\\eta(\\tau_f)$ under both closures, declares contamination detected if the absolute difference exceeds a specified threshold, and outputs a boolean per test case. Use the quasi-static subhorizon approximations\n$$\n\\psi(\\tau) \\approx -\\frac{3}{2}\\frac{H^2(\\tau)}{k^2}F_0(\\tau),\\quad\n\\phi(\\tau) \\approx \\psi(\\tau) + \\frac{6H^2(\\tau)}{k^2}\\sigma_\\nu(\\tau) = \\psi(\\tau) + \\frac{3H^2(\\tau)}{k^2}F_2(\\tau),\n$$\nand enforce the hierarchy’s coupling to $\\phi'$ self-consistently by eliminating $\\phi'$ in favor of time derivatives of $F_0$ and $F_2$.\n\nDefine the initial multipoles at $\\tau=\\tau_i$ as $F_0(\\tau_i)=10^{-5}$ and $F_\\ell(\\tau_i)=0$ for $\\ell\\ge 1$. You must treat all quantities as dimensionless and state explicitly any approximations you use. Your program must use the following test suite, covering a happy-path case, a truncation-stress edge case, and a high-resolution boundary case:\n\n- Test case 1 (happy path): $l_{\\max}=7$, $k=3.0$, $\\tau_i=20.0$, $\\tau_f=120.0$, threshold $=10^{-3}$.\n- Test case 2 (edge case, aggressive truncation): $l_{\\max}=3$, $k=3.0$, $\\tau_i=20.0$, $\\tau_f=120.0$, threshold $=10^{-2}$.\n- Test case 3 (boundary case, high multipole resolution): $l_{\\max}=25$, $k=3.0$, $\\tau_i=20.0$, $\\tau_f=120.0$, threshold $=10^{-5}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, \"[True,False,True]\". Each element is a boolean indicating whether contamination was detected for the corresponding test case when comparing the naive closure to the physically motivated closure. All outputs are dimensionless. No angles or percentages are involved; do not include any units in the output.",
            "solution": "The user-provided problem has been analyzed and is determined to be valid. It is scientifically grounded in the principles of cosmological perturbation theory, is mathematically well-posed with a complete and consistent set of equations and conditions, and is objective in its formulation. The problem addresses a relevant and non-trivial topic in numerical cosmology—the impact of truncation errors in the Boltzmann hierarchy.\n\n### Part 1: Proof of Spurious Anisotropic Stress from Truncation\n\nThe objective is to prove that truncating the Boltzmann hierarchy at a finite multipole $\\ell_{\\max}$ with an improper closure for $F_{\\ell_{\\max}+1}$ generates a non-physical anisotropic stress, which in turn creates an artificial difference between the gravitational potentials $\\phi$ and $\\psi$.\n\n1.  **Relation between Metric Potentials and Anisotropic Stress:**\n    The starting point is the Einstein equation relating the gravitational slip, $\\phi-\\psi$, to the anisotropic stress, $\\sigma_s$. For a single species of massless neutrinos, this is:\n    $$k^2(\\phi - \\psi) = 12\\pi G a^2 (\\rho_\\nu + P_\\nu) \\sigma_\\nu$$\n    For a massless species (radiation), the equation of state is $P_\\nu = \\frac{1}{3}\\rho_\\nu$, so $\\rho_\\nu + P_\\nu = \\frac{4}{3}\\rho_\\nu$. The equation becomes:\n    $$k^2(\\phi - \\psi) = 12\\pi G a^2 \\left(\\frac{4}{3}\\rho_\\nu\\right) \\sigma_\\nu = 16\\pi G a^2 \\rho_\\nu \\sigma_\\nu$$\n    From the background Friedmann equation in a radiation-dominated universe, we have $3H^2 = 8\\pi G a^2 \\rho_\\nu$. Substituting this into the previous equation gives:\n    $$k^2(\\phi - \\psi) = 2 \\cdot (8\\pi G a^2 \\rho_\\nu) \\sigma_\\nu = 2 \\cdot (3H^2) \\sigma_\\nu = 6H^2 \\sigma_\\nu$$\n    The problem defines the neutrino anisotropic stress multipole as $\\sigma_\\nu = \\frac{1}{2}F_2$. Substituting this yields the direct relationship:\n    $$k^2(\\phi - \\psi) = 3H^2 F_2 \\implies \\phi - \\psi = \\frac{3H^2}{k^2} F_2$$\n    This equation demonstrates that any error in the computation of the quadrupole moment $F_2$ will directly and proportionally create a non-physical difference between $\\phi$ and $\\psi$.\n\n2.  **Propagation of Truncation Error down the Hierarchy:**\n    The evolution of the Boltzmann multipoles for $\\ell \\ge 2$ is governed by the collisionless Boltzmann hierarchy:\n    $$F_2' = k\\left(\\frac{2F_1}{5} - \\frac{3F_3}{5}\\right)$$\n    $$F_\\ell' = \\frac{k}{2\\ell+1}\\left[\\ell F_{\\ell-1} - (\\ell+1)F_{\\ell+1}\\right] \\quad \\text{for}\\ \\ell\\ge 3$$\n    To solve this system numerically, it must be truncated at some finite $\\ell_{\\max}$. The equation for $F_{\\ell_{\\max}}$ is:\n    $$F_{\\ell_{\\max}}' = \\frac{k}{2\\ell_{\\max}+1}\\left[\\ell_{\\max} F_{\\ell_{\\max}-1} - (\\ell_{\\max}+1)F_{\\ell_{\\max}+1}\\right]$$\n    This equation requires a closure relation for $F_{\\ell_{\\max}+1}$. A naive but incorrect closure is to set $F_{\\ell_{\\max}+1} = 0$.\n\n3.  **Analysis in the Free-Streaming Regime:**\n    The proof is most clearly demonstrated in the subhorizon, free-streaming regime ($k\\tau \\gg 1$), where perturbations propagate relativistically. In this regime, the true physical solution for the multipoles $F_\\ell$ is non-zero and typically decays oscillatorily (akin to spherical Bessel functions, $F_\\ell \\sim j_\\ell(k\\tau)$). Crucially, if $F_{\\ell_{\\max}}$ is non-zero, then $F_{\\ell_{\\max}+1}$ is also generically non-zero.\n\n4.  **Error Cascade:**\n    Let $\\tilde{F}_\\ell$ be the numerically computed multipoles using the naive closure $\\tilde{F}_{\\ell_{\\max}+1} = 0$, and let $F_\\ell$ be the true physical solution.\n    The evolution of the computed $\\tilde{F}_{\\ell_{\\max}}$ becomes:\n    $$\\tilde{F}_{\\ell_{\\max}}' = \\frac{k \\ell_{\\max}}{2\\ell_{\\max}+1}\\tilde{F}_{\\ell_{\\max}-1}$$\n    The error in the derivative, $\\Delta F_{\\ell_{\\max}}' = \\tilde{F}_{\\ell_{\\max}}' - F_{\\ell_{\\max}}'$, is found by subtracting the true evolution equation from the truncated one:\n    $$\\Delta F_{\\ell_{\\max}}' \\approx \\frac{k(\\ell_{\\max}+1)}{2\\ell_{\\max}+1} F_{\\ell_{\\max}+1}$$\n    where we have assumed that errors in lower multipoles are initially small, i.e., $\\tilde{F}_{\\ell_{\\max}-1} \\approx F_{\\ell_{\\max}-1}$. Since $F_{\\ell_{\\max}+1} \\neq 0$ physically, the naive closure introduces an error source term $\\Delta F_{\\ell_{\\max}}'$. This error propagates downwards through the hierarchy. The equation for any lower multipole $\\ell-1$ is $F_{\\ell-1}' = \\frac{k}{2\\ell-1}\\left[(\\ell-1)F_{\\ell-2} - \\ell F_\\ell\\right]$, which shows that the error $\\Delta F_{\\ell_{\\max}}$ will source an error $\\Delta F_{\\ell_{\\max}-1}'$, which in turn sources an error in $\\Delta F_{\\ell_{\\max}-2}'$, and so on. This cascade of errors inevitably reaches $F_3$, creating an error $\\Delta F_3$.\n\n5.  **Conclusion:**\n    The error $\\Delta F_3$ feeds into the evolution of the quadrupole:\n    $$\\Delta F_2' = \\tilde{F}_2' - F_2' = k\\left(-\\frac{3}{5}\\Delta F_3\\right)$$\n    This creates an error $\\Delta F_2$ that accumulates over time. This spurious $\\tilde{F}_2 = F_2 + \\Delta F_2$ directly generates a spurious anisotropic stress $\\tilde{\\sigma}_\\nu = \\frac{1}{2}\\tilde{F}_2$. As shown in step 1, this results in a non-physical gravitational slip:\n    $$(\\phi - \\psi)_{\\text{spurious}} = \\frac{3H^2}{k^2} \\tilde{F}_2 \\neq \\frac{3H^2}{k^2} F_2 = (\\phi - \\psi)_{\\text{physical}}$$\n    This completes the proof. The inappropriate closure $F_{\\ell_{\\max}+1}=0$ introduces a systematic error that contaminates the entire hierarchy, culminating in a physically incorrect evolution of the metric potentials.\n\n### Part 2: Design of a Numerical Test\n\nThe numerical test is designed to quantify the contamination described above by comparing results from two different closure schemes for the Boltzmann hierarchy.\n\n1.  **System of ODEs:** The core of the test is the numerical integration of the system of $\\ell_{\\max}+1$ coupled first-order ODEs for the multipole vector $\\vec{F}(\\tau) = [F_0, F_1, \\dots, F_{\\ell_{\\max}}]^T$.\n2.  **Equations of Motion:** The derivatives $F_\\ell' = dF_\\ell/d\\tau$ are given by the Boltzmann hierarchy. The equations for $F_0'$ and $F_1'$ are modified to include the gravitational source terms $\\phi'$ and $\\psi$, calculated self-consistently under the quasi-static subhorizon approximation ($k \\gg H$).\n    -   Potentials: $\\psi(\\tau) = -\\frac{3}{2}\\frac{H^2(\\tau)}{k^2}F_0(\\tau)$ and $\\phi(\\tau) = \\psi(\\tau) + \\frac{3H^2(\\tau)}{k^2}F_2(\\tau)$, with $H(\\tau)=1/\\tau$.\n    -   Term $F_0'$: The term $\\phi'$ in the $F_0'$ equation is eliminated algebraically by differentiating the expression for $\\phi(\\tau)$ and substituting it back into the $F_0'$ equation. This results in an equation for $F_0'$ that depends on $F_0, F_1, F_2, F_3$.\n    -   Term $F_1'$: The potential $\\psi$ is substituted directly into the equation for $F_1'$.\n    -   Hierarchy: The remaining equations for $F_\\ell'$ ($\\ell \\ge 2$) are used as given.\n\n3.  **Closure Schemes:** The system is integrated twice, each time with a different closure for $F_{\\ell_{\\max}+1}$:\n    -   **Naive Closure:** $F_{\\ell_{\\max}+1}(\\tau) = 0$. This is expected to produce contamination.\n    -   **Physically Motivated Closure:** $F_{\\ell_{\\max}+1}(\\tau) \\approx \\frac{2\\ell_{\\max}+1}{k\\tau}F_{\\ell_{\\max}}(\\tau)$. This is an asymptotic approximation valid in the free-streaming limit ($k\\tau \\gg \\ell_{\\max}$) and serves as a more accurate physical reference.\n\n4.  **Diagnostic and Detection:** The diagnostic is the gravitational slip parameter, $\\eta(\\tau) = \\frac{\\phi(\\tau)-\\psi(\\tau)}{\\psi(\\tau)}$. Using the quasi-static approximations:\n    $$\\eta(\\tau) = \\frac{(3H^2/k^2) F_2(\\tau)}{-(3H^2/2k^2) F_0(\\tau)} = -2\\frac{F_2(\\tau)}{F_0(\\tau)}$$\n    The test proceeds as follows:\n    a. Integrate the ODE system from $\\tau_i$ to $\\tau_f$ with initial conditions $F_0(\\tau_i)=10^{-5}$ and $F_{\\ell\\ge1}(\\tau_i)=0$. Do this for both the naive and physical closures to obtain the final state vectors $\\vec{F}_{\\text{naive}}(\\tau_f)$ and $\\vec{F}_{\\text{phys}}(\\tau_f)$.\n    b. Calculate the final slip parameter for both cases: $\\eta_{\\text{naive}}(\\tau_f) = -2 \\frac{F_{2, \\text{naive}}(\\tau_f)}{F_{0, \\text{naive}}(\\tau_f)}$ and $\\eta_{\\text{phys}}(\\tau_f) = -2 \\frac{F_{2, \\text{phys}}(\\tau_f)}{F_{0, \\text{phys}}(\\tau_f)}$.\n    c. Compute the absolute difference $\\Delta\\eta = |\\eta_{\\text{naive}} - \\eta_{\\text{phys}}|$.\n    d. Contamination is detected if $\\Delta\\eta$ exceeds the specified threshold for the test case.\n\n### Part 3: Implementation Strategy\n\nThe numerical test is implemented as a Python program.\n-   **ODE Solver:** The `scipy.integrate.solve_ivp` function is used for its robustness and adaptive step-sizing, which is suitable for the potentially stiff or oscillatory behavior of the Boltzmann hierarchy.\n-   **Derivatives Function:** A function, `derivatives(tau, F, k, lmax, closure_type)`, is defined to compute the vector of time derivatives $\\vec{F}'$.\n    - It takes the current time `tau`, the state vector `F`, wavenumber `k`, truncation level `lmax`, and a string specifying the `closure_type`.\n    - It implements the logic to select the closure for $F_{\\ell_{\\max}+1}$.\n    - It computes each $F_\\ell'$ according to the hierarchy equations and the self-consistent quasi-static approximations. The logic is structured to correctly handle the special forms for $\\ell=0, 1, 2$ and the general form for $\\ell \\ge 3$.\n-   **Main Loop:** A main function iterates through the predefined test cases. For each case, it initializes the system, runs the solver twice (once for each closure), computes the contamination diagnostic $\\Delta\\eta$, and compares it to the threshold to produce a boolean result. The final output is formatted as a list of these boolean values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef derivatives(tau, F, k, lmax, closure_type):\n    \"\"\"\n    Computes the time derivative of the Boltzmann hierarchy multipoles F_l.\n\n    Args:\n        tau (float): Conformal time.\n        F (np.ndarray): State vector of multipoles [F_0, F_1, ..., F_lmax].\n        k (float): Comoving wavenumber.\n        lmax (int): Maximum multipole moment in the hierarchy.\n        closure_type (str): Either 'naive' or 'phys' for the closure scheme.\n\n    Returns:\n        np.ndarray: The vector of derivatives dF/dtau.\n    \"\"\"\n    dF = np.zeros(lmax + 1)\n\n    # A helper to get F_l, applying the closure rule for l > lmax.\n    # This simplifies the loops and makes the logic clear.\n    def get_F(l):\n        if l = lmax:\n            return F[l]\n        elif l == lmax + 1:\n            if closure_type == 'naive':\n                return 0.0\n            elif closure_type == 'phys':\n                # Physically motivated free-streaming closure\n                if tau == 0: return 0.0 # Avoid division by zero at start\n                return (2 * lmax + 1) / (k * tau) * F[lmax]\n            else:\n                raise ValueError(\"Unknown closure_type\")\n        else:\n            # For l > lmax + 1, we assume the contribution is zero.\n            # This is implicitly part of the truncation scheme.\n            return 0.0\n\n    # The problem specifies test cases with lmax >= 3, so F[0]..F[3] exist.\n    F0, F1, F2, F3 = get_F(0), get_F(1), get_F(2), get_F(3)\n\n    # --- F_0' Equation ---\n    # This is the most complex due to the self-consistent treatment of phi'.\n    # F_0'(1 - 6/(k^2*tau^2)) = -k*F_1 - 12/(k^2*tau^3)*(F_0 - 2*F_2) - 12/(k^2*tau^2)*F_2'\n    # We substitute F_2' = k*(2/5*F_1 - 3/5*F_3)\n    F2_prime = k * (2.0 / 5.0 * F1 - 3.0 / 5.0 * F3)\n    \n    # Pre-computation for clarity\n    k_tau_sq = (k * tau)**2\n    k_sq_tau_cubed = k**2 * tau**3\n    \n    f0_factor = 1.0 - 6.0 / k_tau_sq\n    rhs_f0 = -k * F1 - (12.0 / k_sq_tau_cubed) * (F0 - 2.0 * F2) \\\n             - (12.0 / k_tau_sq) * F2_prime\n             \n    # Avoid division by zero if factor is close to zero\n    if abs(f0_factor)  1e-12:\n        dF[0] = 0 # Or handle more gracefully; this indicates breakdown of approximation\n    else:\n        dF[0] = rhs_f0 / f0_factor\n\n    # --- F_1' Equation ---\n    # F_1' = k*(F_0/3 - 2*F_2/3) + k*psi, with psi = -1.5/(k^2*tau^2)*F_0\n    psi = -1.5 / k_tau_sq * F0\n    dF[1] = k * (F0 / 3.0 - 2.0 / 3.0 * F2) + k * psi\n\n    # --- F_2' and higher Hierarchy ---\n    # F_2'\n    dF[2] = F2_prime\n\n    # F_l' for l in [3, lmax]\n    for l in range(3, lmax + 1):\n        F_l_minus_1 = get_F(l - 1)\n        F_l_plus_1 = get_F(l + 1)\n        dF[l] = (k / (2 * l + 1.0)) * (l * F_l_minus_1 - (l + 1) * F_l_plus_1)\n\n    return dF\n\n\ndef run_test_case(lmax, k, tau_i, tau_f, threshold):\n    \"\"\"\n    Runs the numerical test for a single case.\n    \"\"\"\n    # Initial conditions\n    y0 = np.zeros(lmax + 1)\n    y0[0] = 1e-5\n\n    # Integration parameters for solve_ivp\n    integration_params = {\n        't_span': [tau_i, tau_f],\n        'y0': y0,\n        'method': 'RK45', # Standard choice\n        'rtol': 1e-9,\n        'atol': 1e-12\n    }\n\n    # Solve with naive closure\n    sol_naive = solve_ivp(derivatives, args=(k, lmax, 'naive'), **integration_params)\n    F_naive_final = sol_naive.y[:, -1]\n\n    # Solve with physical closure\n    sol_phys = solve_ivp(derivatives, args=(k, lmax, 'phys'), **integration_params)\n    F_phys_final = sol_phys.y[:, -1]\n\n    # Calculate slip parameter eta = -2 * F_2 / F_0\n    # Guard against division by zero, although F_0 should be stable.\n    if abs(F_naive_final[0])  1e-20 or abs(F_phys_final[0])  1e-20:\n        # This case indicates a numerical failure, should not happen.\n        return False\n        \n    eta_naive = -2.0 * F_naive_final[2] / F_naive_final[0]\n    eta_phys = -2.0 * F_phys_final[2] / F_phys_final[0]\n\n    # Detect contamination\n    delta_eta = abs(eta_naive - eta_phys)\n    return delta_eta > threshold\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (l_max, k, tau_i, tau_f, threshold)\n        (7, 3.0, 20.0, 120.0, 1e-3),\n        (3, 3.0, 20.0, 120.0, 1e-2),\n        (25, 3.0, 20.0, 120.0, 1e-5),\n    ]\n\n    results = []\n    for case in test_cases:\n        lmax, k, tau_i, tau_f, threshold = case\n        result = run_test_case(lmax, k, tau_i, tau_f, threshold)\n        results.append(str(result))\n\n    # Format output as specified\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}