{
    "hands_on_practices": [
        {
            "introduction": "This practice guides you through the fundamental calculation connecting early-universe physics to the observable Cosmic Microwave Background (CMB) E-mode power spectrum, $C_{\\ell}^{EE}$. By implementing a simplified line-of-sight integral, you will numerically compute the $C_{\\ell}^{EE}$ spectrum from a set of cosmological and physical parameters. This exercise provides a direct, hands-on understanding of how primordial fluctuations, modulated by the physics of recombination and photon free-streaming, manifest as angular correlations in the CMB polarization field .",
            "id": "3467172",
            "problem": "You are asked to design and implement a complete, self-contained numerical program that computes the Cosmic Microwave Background (CMB) $E$-mode polarization angular power spectrum $C_{\\ell}^{EE}$ for scalar initial conditions using the line-of-sight integration method. Your implementation must start from a clear, principle-based foundation without using any pre-packaged CMB solvers. The computation must be framed in purely mathematical terms, with physically consistent but simplified ingredients so that the program does not depend on external data or codes. The scenario must be scientifically realistic and self-consistent.\n\nBegin from the following fundamental base:\n\n- The CMB polarization arises from Thomson scattering, whose differential cross-section depends on the incident radiation field anisotropy. A local quadrupole anisotropy in the photon distribution generates linear polarization, described by the Stokes parameters $Q$ and $U$.\n- Linear perturbation theory of the photon distribution is encoded in the Boltzmann equation. Under scalar initial conditions, the polarization field on the sky can be decomposed into gradient-like and curl-like components, referred to as $E$-mode and $B$-mode, respectively. In the absence of tensor perturbations and lensing, the scalar initial conditions produce only $E$-modes.\n- The line-of-sight formalism expresses multipole moments of the radiation field as integrals over conformal time of source terms multiplied by spherical Bessel functions, reflecting free streaming of photons from the last scattering surface to the observer.\n\nYour algorithm must proceed by:\n\n1. Defining a physically motivated but numerically tractable visibility function to model last scattering as a finite-width process:\n   - Use a normalized Gaussian visibility function $g(\\eta)$ centered at a recombination conformal time $\\,\\eta_{\\star}\\,$ with width $\\,\\sigma_{\\eta}\\,$, satisfying $\\int g(\\eta) \\, d\\eta = 1$. Here and throughout, conformal times must be in megaparsecs (Mpc).\n2. Modeling the polarization source amplitude as a scale-dependent factor $Q(k)$ that captures the efficiency of polarization generation and microphysical damping:\n   - Use $Q(k) = q_{0}\\,\\exp\\!\\big( - (k/k_{d})^{m} \\big)$ with $k$ in inverse megaparsecs $\\,\\mathrm{Mpc}^{-1}\\,$, $q_{0}$ a dimensionless efficiency factor, $k_{d}$ a damping scale, and $m$ a positive integer exponent. All wavenumbers must be in $\\,\\mathrm{Mpc}^{-1}\\,$.\n3. Implementing the line-of-sight integral for the $E$-mode transfer function, discretized in conformal time:\n   - Let $D(\\eta) = \\eta_{0} - \\eta$ with $\\eta_{0}$ the conformal time today, in $\\,\\mathrm{Mpc}\\,$.\n   - Define a transfer function $\\Delta_{\\ell}^{E}(k)$ through an integral over $\\eta$ of a source $S_{E}(k,\\eta)$ times a spherical Bessel function $j_{\\ell}(k D(\\eta))$.\n   - In this simplified model, set $S_{E}(k,\\eta) = Q(k)\\,g(\\eta)$ so that $\\Delta_{\\ell}^{E}(k)$ reduces to a convolution of $j_{\\ell}$ with $g(\\eta)$ weighted by $Q(k)$.\n4. Computing the angular power spectrum $C_{\\ell}^{EE}$ by integrating over wavenumber with the primordial curvature power spectrum $P_{\\mathcal{R}}(k)$:\n   - Use $P_{\\mathcal{R}}(k) = A_{s}\\,(k/k_{0})^{n_{s} - 1}$, where $A_{s}$ is the scalar amplitude, $n_{s}$ is the spectral index, and $k_{0}$ is a pivot scale. All wavenumbers are in $\\,\\mathrm{Mpc}^{-1}\\,$.\n   - Discretize the $k$-integral in $\\ln k$ and compute $C_{\\ell}^{EE}$ via an integral of $P_{\\mathcal{R}}(k)\\big(\\Delta_{\\ell}^{E}(k)\\big)^{2}$.\n\nScientific and numerical requirements:\n\n- Units:\n  - Conformal time $\\,\\eta\\,$ and $\\eta_{0}$ must be specified in $\\,\\mathrm{Mpc}\\,$.\n  - Wavenumber $\\,k\\,$ must be specified in $\\,\\mathrm{Mpc}^{-1}\\,$.\n  - Angles are implicit in the arguments to spherical Bessel functions $j_{\\ell}(\\cdot)$ and are dimensionless in radians.\n  - The final $C_{\\ell}^{EE}$ values must be reported as unitless floats (no units attached), since the normalization is set by $P_{\\mathcal{R}}(k)$ in this simplified model.\n- Numerical integration:\n  - Discretize $\\eta$ over a symmetric interval around $\\,\\eta_{\\star}\\,$ that captures the width $\\,\\sigma_{\\eta}\\,$ (for example, several $\\,\\sigma_{\\eta}\\,$ on either side).\n  - Discretize $k$ logarithmically over a physically reasonable range $[k_{\\min}, k_{\\max}]$ sufficient to capture the support of $j_{\\ell}(kD)$ for the chosen multipoles.\n  - Use numerically stable and convergent quadratures (for example, trapezoidal rule) for both $\\eta$ and $\\ln k$ integrals.\n- Scalar initial conditions:\n  - Restrict to scalar initial conditions without gravitational lensing or tensor modes; $B$-mode polarization is neglected.\n\nValidation requirement:\n\n- Although a full validation against a public Boltzmann solver such as the Cosmic Linear Anisotropy Solving System (CLASS) is beyond the scope of this self-contained program, include a diagnostic that compares the finite-width recombination result to the instantaneous recombination limit, modeled by replacing $g(\\eta)$ by a Dirac delta at $\\,\\eta_{\\star}\\,$. Construct the corresponding reference $C_{\\ell}^{EE,\\mathrm{inst}}$ using $\\,\\Delta_{\\ell}^{E,\\mathrm{inst}}(k) = Q(k)\\,j_{\\ell}(k D(\\eta_{\\star}))\\,$. Report a boolean indicating whether the correlation between the two $C_{\\ell}^{EE}$ arrays for a small $\\,\\sigma_{\\eta}\\,$ exceeds a chosen threshold, signifying consistency with the instantaneous limit.\n\nTest suite:\n\nImplement the program to compute and report results for the following parameter sets. Each test case must produce a list of floats corresponding to $C_{\\ell}^{EE}$ for the specified multipoles:\n\n- Test Case $\\,1\\,$ (happy path):\n  - $\\eta_{0} = 14000\\,\\mathrm{Mpc}$, $\\eta_{\\star} = 280\\,\\mathrm{Mpc}$, $\\sigma_{\\eta} = 18\\,\\mathrm{Mpc}$, $q_{0} = 0.17$, $k_{d} = 0.14\\,\\mathrm{Mpc}^{-1}$, $m = 2$, $A_{s} = 2.1\\times 10^{-9}$, $n_{s} = 0.965$, $k_{0} = 0.05\\,\\mathrm{Mpc}^{-1}$, multipoles $\\ell \\in \\{2, 10, 100, 500\\}$, $k$-range $[10^{-4}, 2]\\,\\mathrm{Mpc}^{-1}$.\n- Test Case $\\,2\\,$ (near-instantaneous recombination boundary):\n  - $\\eta_{0} = 14000\\,\\mathrm{Mpc}$, $\\eta_{\\star} = 280\\,\\mathrm{Mpc}$, $\\sigma_{\\eta} = 2\\,\\mathrm{Mpc}$, $q_{0} = 0.17$, $k_{d} = 0.35\\,\\mathrm{Mpc}^{-1}$, $m = 2$, $A_{s} = 2.1\\times 10^{-9}$, $n_{s} = 0.965$, $k_{0} = 0.05\\,\\mathrm{Mpc}^{-1}$, multipoles $\\ell \\in \\{20, 80, 200\\}$, $k$-range $[10^{-4}, 2]\\,\\mathrm{Mpc}^{-1}$.\n- Test Case $\\,3\\,$ (edge case: spectral index change):\n  - $\\eta_{0} = 14000\\,\\mathrm{Mpc}$, $\\eta_{\\star} = 280\\,\\mathrm{Mpc}$, $\\sigma_{\\eta} = 18\\,\\mathrm{Mpc}$, $q_{0} = 0.17$, $k_{d} = 0.14\\,\\mathrm{Mpc}^{-1}$, $m = 2$, $A_{s} = 2.1\\times 10^{-9}$, $n_{s} = 1.0$, $k_{0} = 0.05\\,\\mathrm{Mpc}^{-1}$, multipoles $\\ell \\in \\{2\\}$, $k$-range $[10^{-4}, 2]\\,\\mathrm{Mpc}^{-1}$.\n- Validation diagnostic (boolean):\n  - Using Test Case $\\,2\\,$ parameters, compute both the finite-width result and the instantaneous reference result as described above for the same set of $\\ell$ values. Report a boolean indicating whether the Pearson correlation coefficient between the two $C_{\\ell}^{EE}$ arrays exceeds $\\,0.995\\,$ and the ratio of their means lies within $[0.8,\\,1.2]$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The first three entries must be the lists of $C_{\\ell}^{EE}$ values for Test Cases $\\,1\\,$, $\\,2\\,$, and $\\,3\\,$, respectively. The fourth entry must be the validation diagnostic boolean. For example, the output must have the form\n  - $[\\,[c_{1,\\ell_{1}}, c_{1,\\ell_{2}}, \\dots],\\,[c_{2,\\ell_{1}}, c_{2,\\ell_{2}}, \\dots],\\,[c_{3,\\ell_{1}}, \\dots],\\,\\mathrm{true}\\,]$\n  - The floats must be printed without units.",
            "solution": "The problem statement has been critically validated and is deemed valid. It is scientifically grounded in the principles of physical cosmology, mathematically well-posed, and all provided parameters and functional forms are self-consistent and physically realistic for a simplified model. The task is to implement a numerical calculation of the CMB $E$-mode polarization angular power spectrum, $C_{\\ell}^{EE}$, from first principles using the line-of-sight integration method.\n\nThe theoretical foundation of the calculation rests on expressing the angular power spectrum $C_{\\ell}^{EE}$ as an integral over contributions from all Fourier modes of primordial fluctuations. The contribution of each mode with wavenumber $k$ is weighted by the primordial power spectrum $P_{\\mathcal{R}}(k)$ and modulated by a transfer function $\\Delta_{\\ell}^{E}(k)$, which encodes the evolution of perturbations from the early universe until today. The formula is:\n$$\nC_{\\ell}^{EE} = \\int_{0}^{\\infty} P_{\\mathcal{R}}(k) \\left( \\Delta_{\\ell}^{E}(k) \\right)^2 \\frac{dk}{k}\n$$\nThe integral is performed over the logarithm of the wavenumber $k$, which is standard for cosmological power spectra.\n\nThe primordial power spectrum, $P_{\\mathcal{R}}(k)$, describes the amplitude of initial scalar curvature perturbations and is modeled as a simple power law, consistent with inflationary theory:\n$$\nP_{\\mathcal{R}}(k) = A_{s} \\left( \\frac{k}{k_{0}} \\right)^{n_{s} - 1}\n$$\nHere, $A_{s}$ is the scalar amplitude, $n_{s}$ is the scalar spectral index measuring the scale dependence, and $k_{0}$ is an arbitrary pivot scale.\n\nThe $E$-mode transfer function, $\\Delta_{\\ell}^{E}(k)$, quantifies how a single primordial Fourier mode of wavenumber $k$ contributes to the observed polarization anisotropy at an angular multipole $\\ell$. It is given by the line-of-sight integral, which projects the polarization source term $S_{E}(k, \\eta)$ from each point in cosmic history (parametrized by conformal time $\\eta$) to the observer today (at $\\eta_{0}$):\n$$\n\\Delta_{\\ell}^{E}(k) = \\int_{0}^{\\eta_{0}} S_{E}(k, \\eta) j_{\\ell}\\big(k(\\eta_{0} - \\eta)\\big) d\\eta\n$$\nThe function $j_{\\ell}(x)$ is the spherical Bessel function of order $\\ell$, which arises from the decomposition of plane waves into spherical harmonics. The argument $k(\\eta_{0} - \\eta)$ represents the product of the wavenumber and the comoving distance from the source at time $\\eta$ to the observer.\n\nThe problem provides simplified, physically motivated models for the source term $S_{E}(k, \\eta)$:\n$$\nS_{E}(k, \\eta) = Q(k) g(\\eta)\n$$\nThis factorization separates the time dependence from the scale dependence.\n\n$1$. The visibility function, $g(\\eta)$, models the process of recombination, during which photons last scattered off free electrons. It is modeled as a normalized Gaussian function centered at the conformal time of recombination, $\\eta_{\\star}$, with a characteristic width $\\sigma_{\\eta}$:\n$$\ng(\\eta) = \\frac{1}{\\sigma_{\\eta}\\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\eta - \\eta_{\\star})^2}{2\\sigma_{\\eta}^2}\\right)\n$$\nThis function acts as a temporal window, ensuring that polarization is generated only during the finite interval of recombination.\n\n$2$. The source amplitude, $Q(k)$, models the efficiency of polarization generation and microphysical damping effects. It is given by:\n$$\nQ(k) = q_{0}\\,\\exp\\left( - (k/k_{d})^{m} \\right)\n$$\nwhere $q_{0}$ is a dimensionless efficiency factor. The exponential term models the suppression of anisotropies on small scales (large $k$) due to photon diffusion, an effect known as Silk damping, with $k_{d}$ being the characteristic damping scale and $m$ a positive integer.\n\nCombining these elements, the transfer function becomes:\n$$\n\\Delta_{\\ell}^{E}(k) = Q(k) \\int_{0}^{\\eta_{0}} g(\\eta) j_{\\ell}\\big(k(\\eta_{0} - \\eta)\\big) d\\eta\n$$\n\nThe algorithmic approach to computing $C_{\\ell}^{EE}$ proceeds by discretizing and numerically evaluating the nested integrals.\n\n**Step 1: Numerical Integration Grids**\n-   A logarithmic grid in wavenumber, $k_j$, is established over the range $[k_{\\min}, k_{\\max}]$, suitable for the wide dynamic range and power-law nature of the spectra. The integration variable becomes $\\ln k$.\n-   A linear grid in conformal time, $\\eta_i$, is established over a symmetric interval around $\\eta_{\\star}$ (e.g., $[\\eta_{\\star} - 6\\sigma_{\\eta}, \\eta_{\\star} + 6\\sigma_{\\eta}]$) to fully capture the support of the Gaussian visibility function.\n\n**Step 2: Computing the Transfer Function $\\Delta_{\\ell}^{E}(k_j)$**\nFor each multipole $\\ell$ and each wavenumber $k_j$ on the grid, the integral over $\\eta$ is computed numerically using the trapezoidal rule:\n$$\n\\int g(\\eta) j_{\\ell}\\big(k_j(\\eta_{0} - \\eta)\\big) d\\eta \\approx \\sum_{i} \\frac{g(\\eta_{i+1})j_{\\ell,i+1} + g(\\eta_i)j_{\\ell,i}}{2} (\\eta_{i+1} - \\eta_i)\n$$\nwhere $j_{\\ell,i} = j_{\\ell}\\big(k_j(\\eta_0 - \\eta_i)\\big)$. This value, when multiplied by $Q(k_j)$, gives $\\Delta_{\\ell}^{E}(k_j)$.\n\n**Step 3: Computing the Angular Power Spectrum $C_{\\ell}^{EE}$**\nWith the transfer function values $\\Delta_{\\ell}^{E}(k_j)$ computed for all $k_j$ on the grid, the final integral for $C_{\\ell}^{EE}$ is evaluated, again using the trapezoidal rule over the logarithmic $k$-grid:\n$$\nC_{\\ell}^{EE} \\approx \\sum_{j} \\frac{F(k_{j+1}) + F(k_j)}{2} (\\ln k_{j+1} - \\ln k_j)\n$$\nwhere the integrand is $F(k) = P_{\\mathcal{R}}(k) \\left( \\Delta_{\\ell}^{E}(k) \\right)^2$. This process is repeated for each $\\ell$ in the specified set of multipoles.\n\n**Step 4: Validation via the Instantaneous Recombination Limit**\nA crucial validation step involves comparing the result to the idealized limit of instantaneous recombination, where $\\sigma_{\\eta} \\to 0$. In this limit, the visibility function $g(\\eta)$ approaches a Dirac delta function, $g(\\eta) \\to \\delta(\\eta - \\eta_{\\star})$. The integral for the transfer function becomes trivial:\n$$\n\\Delta_{\\ell}^{E, \\mathrm{inst}}(k) = Q(k) \\int_{0}^{\\eta_{0}} \\delta(\\eta - \\eta_{\\star}) j_{\\ell}\\big(k(\\eta_{0} - \\eta)\\big) d\\eta = Q(k) j_{\\ell}\\big(k(\\eta_{0} - \\eta_{\\star})\\big)\n$$\nThe corresponding power spectrum, $C_{\\ell}^{EE, \\mathrm{inst}}$, is computed using this simplified transfer function. For a small but finite $\\sigma_{\\eta}$, the full numerical result should closely track this instantaneous approximation. The correlation and mean ratio between the two computed spectra serve as a powerful diagnostic for the correctness of the implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn\n\ndef compute_cl_ee(\n    multipoles, eta0, eta_star, sigma_eta, q0, kd, m, As, ns, k0, k_range,\n    num_k_pts=500, num_eta_pts=200, eta_width_factor=6.0\n):\n    \"\"\"\n    Computes the C_l^EE power spectrum for a finite-width recombination.\n\n    Args:\n        multipoles (list): List of multipole moments l to compute.\n        eta0, eta_star, sigma_eta (float): Cosmological time parameters in Mpc.\n        q0, kd, m (float): Parameters for the polarization source amplitude Q(k).\n        As, ns, k0 (float): Parameters for the primordial power spectrum P_R(k).\n        k_range (list): [k_min, k_max] for the wavenumber integration in Mpc^-1.\n        num_k_pts (int): Number of points for the log-spaced k-grid.\n        num_eta_pts (int): Number of points for the linear eta-grid.\n        eta_width_factor (float): The eta-grid spans eta_star +/- factor * sigma_eta.\n\n    Returns:\n        list: A list of C_l^EE values for the given multipoles.\n    \"\"\"\n    # 1. Define numerical integration grids\n    k_grid = np.logspace(np.log10(k_range[0]), np.log10(k_range[1]), num_k_pts)\n    eta_min = eta_star - eta_width_factor * sigma_eta\n    eta_max = eta_star + eta_width_factor * sigma_eta\n    eta_grid = np.linspace(eta_min, eta_max, num_eta_pts)\n\n    # 2. Evaluate physics functions on their respective grids\n    # Primordial power spectrum P_R(k)\n    P_R_k = As * (k_grid / k0)**(ns - 1)\n    # Polarization source amplitude Q(k)\n    Q_k = q0 * np.exp(-(k_grid / kd)**m)\n    # Normalized Gaussian visibility function g(eta)\n    g_eta = (1.0 / (sigma_eta * np.sqrt(2 * np.pi))) * \\\n            np.exp(-0.5 * ((eta_grid - eta_star) / sigma_eta)**2)\n\n    # 3. Compute the E-mode transfer functions Delta_l^E(k)\n    delta_matrix = np.zeros((len(multipoles), num_k_pts))\n    comoving_dist_from_source = eta0 - eta_grid\n\n    for j, l_val in enumerate(multipoles):\n        for i, k_val in enumerate(k_grid):\n            # Evaluate j_l(k * (eta0 - eta)) on the eta grid\n            bessel_arg = k_val * comoving_dist_from_source\n            j_l_values = spherical_jn(l_val, bessel_arg)\n            \n            # Integrand for the eta-integral\n            integrand_eta = g_eta * j_l_values\n            \n            # Perform integral numerically using the trapezoidal rule\n            integral_val = np.trapz(integrand_eta, eta_grid)\n            \n            delta_matrix[j, i] = Q_k[i] * integral_val\n\n    # 4. Compute the angular power spectrum C_l^EE\n    # Integrand for the k-integral: P_R(k) * (Delta_l^E(k))^2\n    k_integrand = P_R_k[np.newaxis, :] * (delta_matrix**2)\n    \n    # Perform integral over ln(k) using trapezoidal rule\n    log_k_grid = np.log(k_grid)\n    cl_ee_array = np.trapz(k_integrand, log_k_grid, axis=1)\n    \n    return cl_ee_array.tolist()\n\n\ndef compute_cl_ee_instantaneous(\n    multipoles, eta0, eta_star, q0, kd, m, As, ns, k0, k_range, num_k_pts=500\n):\n    \"\"\"\n    Computes the C_l^EE power spectrum for instantaneous recombination.\n\n    Args:\n        (Same as compute_cl_ee, but without sigma_eta and related parameters)\n\n    Returns:\n        np.array: An array of C_l^EE values.\n    \"\"\"\n    # 1. Define numerical integration grid for k\n    k_grid = np.logspace(np.log10(k_range[0]), np.log10(k_range[1]), num_k_pts)\n\n    # 2. Evaluate physics functions on the k-grid\n    P_R_k = As * (k_grid / k0)**(ns - 1)\n    Q_k = q0 * np.exp(-(k_grid / kd)**m)\n\n    # 3. Compute the transfer functions Delta_l^E,inst(k)\n    delta_inst_matrix = np.zeros((len(multipoles), num_k_pts))\n    comoving_dist_recomb = eta0 - eta_star\n    \n    bessel_arg = k_grid * comoving_dist_recomb\n    for j, l_val in enumerate(multipoles):\n        j_l_values = spherical_jn(l_val, bessel_arg)\n        delta_inst_matrix[j, :] = Q_k * j_l_values\n        \n    # 4. Compute C_l^EE,inst\n    k_integrand = P_R_k[np.newaxis, :] * (delta_inst_matrix**2)\n    log_k_grid = np.log(k_grid)\n    cl_ee_inst_array = np.trapz(k_integrand, log_k_grid, axis=1)\n\n    return cl_ee_inst_array\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: Happy path\n        {\n            \"eta0\": 14000.0, \"eta_star\": 280.0, \"sigma_eta\": 18.0,\n            \"q0\": 0.17, \"kd\": 0.14, \"m\": 2, \"As\": 2.1e-9, \"ns\": 0.965, \"k0\": 0.05,\n            \"multipoles\": [2, 10, 100, 500], \"k_range\": [1e-4, 2.0]\n        },\n        # Test Case 2: Near-instantaneous recombination\n        {\n            \"eta0\": 14000.0, \"eta_star\": 280.0, \"sigma_eta\": 2.0,\n            \"q0\": 0.17, \"kd\": 0.35, \"m\": 2, \"As\": 2.1e-9, \"ns\": 0.965, \"k0\": 0.05,\n            \"multipoles\": [20, 80, 200], \"k_range\": [1e-4, 2.0]\n        },\n        # Test Case 3: Edge case (scale-invariant spectrum)\n        {\n            \"eta0\": 14000.0, \"eta_star\": 280.0, \"sigma_eta\": 18.0,\n            \"q0\": 0.17, \"kd\": 0.14, \"m\": 2, \"As\": 2.1e-9, \"ns\": 1.0, \"k0\": 0.05,\n            \"multipoles\": [2], \"k_range\": [1e-4, 2.0]\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        cls = compute_cl_ee(**params)\n        results.append(cls)\n\n    # Perform the validation diagnostic using parameters from Test Case 2\n    validation_params = test_cases[1]\n    cls_finite = np.array(compute_cl_ee(**validation_params))\n    \n    params_inst = {\n        key: val for key, val in validation_params.items() if key != 'sigma_eta'\n    }\n    cls_inst = compute_cl_ee_instantaneous(**params_inst)\n\n    # Compute Pearson correlation coefficient\n    # r = cov(X, Y) / (std(X) * std(Y))\n    corr_matrix = np.corrcoef(cls_finite, cls_inst)\n    correlation = corr_matrix[0, 1] if corr_matrix.shape == (2,2) else 1.0\n    \n    # Compute ratio of means\n    mean_ratio = np.mean(cls_finite) / np.mean(cls_inst) if np.mean(cls_inst) != 0 else 0\n\n    validation_bool = (correlation > 0.995) and (0.8 < mean_ratio < 1.2)\n    results.append(validation_bool)\n    \n    # Format the final output string\n    result_strs = []\n    for item in results:\n        if isinstance(item, bool):\n            result_strs.append(str(item).lower())\n        else:\n            result_strs.append(str(item))\n            \n    print(f\"[{','.join(result_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world CMB observations are made with instruments that have finite resolution, pixelating the sky into a discrete map. This practice explores how such pixelization affects the measured signal by deriving and applying the HEALPix pixel window function, $W_{\\ell}$. You will quantify the attenuation of power at small angular scales, a critical step in accurately comparing theoretical models to observational data and understanding the limits of a given experiment .",
            "id": "3467223",
            "problem": "You are tasked with writing a complete, runnable program that analyzes how map pixelization in Hierarchical Equal Area isoLatitude Pixelation (HEALPix) affects the recovery of Cosmic Microwave Background (CMB) E-mode and B-mode polarization angular power spectra. Your program must implement the following, starting from fundamental definitions and facts, without relying on precomputed pixel window functions.\n\nBegin with the definition that a pixelized map is equivalent to convolving the underlying sky with a kernel that averages the field over the pixelâ€™s footprint. In HEALPix, pixels are equal-area, and a physically reasonable approximation for the pixel convolution kernel is an azimuthally symmetric spherical cap of equal area. Let the pixelization resolution be defined by $N_{\\text{side}}$. The total number of pixels is $N_{\\text{pix}} = 12 N_{\\text{side}}^{2}$, and the pixel area is $A_{\\text{pix}} = 4\\pi / N_{\\text{pix}} = \\pi/(3 N_{\\text{side}}^{2})$. For an equal-area spherical cap, define $\\mu \\equiv \\cos \\theta_{\\text{pix}}$ via $2\\pi(1-\\mu) = A_{\\text{pix}}$ so that $\\mu = 1 - 1/(6 N_{\\text{side}}^{2})$. Angles must be handled in radians.\n\nFrom first principles, the spherical harmonic representation of a convolution with an azimuthally symmetric kernel multiplies the angular power spectrum by the square of a kernel window function. For an equal-area spherical cap approximation, the scalar window function $W_{\\ell}$ is the average of the Legendre polynomial over the cap. Starting from the normalized average over the cap and using the fact that the spherical harmonics couple to the Legendre polynomials for azimuthally symmetric kernels, derive the expression for $W_{\\ell}$ in terms of an integral of $P_{\\ell}(\\cos \\theta)$ over the cap. Do not assume any shortcut formula; the derivation must start from the area-normalized integral definition for the cap average. You may use standard properties of Legendre polynomials, including orthogonality and definite integrals, as fundamental tools.\n\nAdopt the widely used HEALPix bandlimit for sampling such that the Nyquist multipole is $\\ell_{\\text{Ny}} = 3 N_{\\text{side}} - 1$. For CMB polarization, restrict all sums to $\\ell \\geq 2$ because polarization is defined only for $\\ell \\geq 2$. Compute $W_{\\ell}$ for all integer multipoles $\\ell$ with $2 \\leq \\ell \\leq \\ell_{\\text{Ny}}$, and assume that the same pixel window function applies to both E-mode and B-mode fields under the equal-area spherical cap approximation.\n\nTo quantify impact, use synthetic but physically plausible baseline angular power spectra for E-mode and B-mode as functions of $\\ell$:\n- $C_{\\ell}^{EE} = A_{E} \\left(\\dfrac{\\ell + 0.5}{50}\\right)^{\\alpha_{E}} \\exp\\left[-\\ell(\\ell+1)\\sigma^{2}\\right]$,\n- $C_{\\ell}^{BB} = A_{B} \\left(\\dfrac{\\ell + 0.5}{50}\\right)^{\\alpha_{B}} \\exp\\left[-\\ell(\\ell+1)\\sigma^{2}\\right]$,\nwhere $A_{E}$ and $A_{B}$ are amplitudes expressed in microkelvin squared, $\\alpha_{E}$ and $\\alpha_{B}$ are spectral tilts, and $\\sigma$ is a small angular damping scale in radians. The observed spectra after pixelization are $C_{\\ell, \\text{obs}}^{EE} = C_{\\ell}^{EE} W_{\\ell}^{2}$ and $C_{\\ell, \\text{obs}}^{BB} = C_{\\ell}^{BB} W_{\\ell}^{2}$.\n\nFor each test case, compute the following metrics up to $\\ell_{\\text{Ny}}$:\n1. The power-weighted mean fractional suppression for E-mode, defined as $S_{E} = \\dfrac{\\sum_{\\ell=2}^{\\ell_{\\text{Ny}}} C_{\\ell}^{EE} \\left(1 - W_{\\ell}^{2}\\right)}{\\sum_{\\ell=2}^{\\ell_{\\text{Ny}}} C_{\\ell}^{EE}}$.\n2. The power-weighted mean fractional suppression for B-mode, defined as $S_{B} = \\dfrac{\\sum_{\\ell=2}^{\\ell_{\\text{Ny}}} C_{\\ell}^{BB} \\left(1 - W_{\\ell}^{2}\\right)}{\\sum_{\\ell=2}^{\\ell_{\\text{Ny}}} C_{\\ell}^{BB}}$.\n3. The smallest multipole $\\ell_{\\tfrac{1}{2}} \\in [2, \\ell_{\\text{Ny}}]$ such that $W_{\\ell}^{2} \\leq 0.5$. If no such multipole exists within the band, return $-1$ for this metric.\n4. The unweighted root-mean-square attenuation $R = \\sqrt{\\dfrac{1}{(\\ell_{\\text{Ny}}-1)} \\sum_{\\ell=2}^{\\ell_{\\text{Ny}}} \\left(1 - W_{\\ell}^{2}\\right)^{2}}$.\n\nYour program must implement these computations without any user input, using the following test suite of parameter sets:\n- Case $1$: $N_{\\text{side}} = 8$, $A_{E} = 1.0$ (microkelvin squared), $\\alpha_{E} = 1.0$, $A_{B} = 0.05$ (microkelvin squared), $\\alpha_{B} = 0.2$, $\\sigma = 0.005$ (radians).\n- Case $2$: $N_{\\text{side}} = 32$, $A_{E} = 1.2$ (microkelvin squared), $\\alpha_{E} = 0.8$, $A_{B} = 0.08$ (microkelvin squared), $\\alpha_{B} = 0.4$, $\\sigma = 0.004$ (radians).\n- Case $3$: $N_{\\text{side}} = 1$, $A_{E} = 0.9$ (microkelvin squared), $\\alpha_{E} = 2.0$, $A_{B} = 0.9$ (microkelvin squared), $\\alpha_{B} = 2.0$, $\\sigma = 0.010$ (radians).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of the four metrics in the order specified above. For example, an output for three cases must look like:\n$[[S_{E}^{(1)},S_{B}^{(1)},\\ell_{\\tfrac{1}{2}}^{(1)},R^{(1)}],[S_{E}^{(2)},S_{B}^{(2)},\\ell_{\\tfrac{1}{2}}^{(2)},R^{(2)}],[S_{E}^{(3)},S_{B}^{(3)},\\ell_{\\tfrac{1}{2}}^{(3)},R^{(3)}]]$.\nAll angles in your calculations must be in radians. All ratios are dimensionless and need no units; amplitudes for $C_{\\ell}$ are specified in microkelvin squared but cancel in the ratios $S_{E}$ and $S_{B}$. Ensure scientific realism and numerical stability in your implementation.",
            "solution": "The problem is valid. It is scientifically grounded in the principles of Cosmic Microwave Background (CMB) data analysis, specifically the treatment of pixelization effects on angular power spectra. All parameters, definitions, and required computations are specified in a self-contained and consistent manner, rendering the problem well-posed and objective.\n\nThe solution proceeds in two main parts: first, a derivation of the HEALPix pixel window function from first principles, and second, the algorithmic implementation for calculating the specified metrics.\n\n### 1. Derivation of the Pixel Window Function $W_{\\ell}$\n\nThe problem states that the effect of pixelization can be approximated by a convolution of the sky signal with an azimuthally symmetric kernel representing the average over a pixel. For HEALPix, a suitable approximation is a spherical cap of the same area as a single pixel.\n\nThe HEALPix resolution is given by the parameter $N_{\\text{side}}$. The total number of pixels on the sphere is $N_{\\text{pix}} = 12 N_{\\text{side}}^{2}$. The area of a single pixel is therefore $A_{\\text{pix}} = \\frac{4\\pi}{N_{\\text{pix}}} = \\frac{\\pi}{3 N_{\\text{side}}^{2}}$.\n\nA spherical cap centered on the north pole extending to a polar angle $\\theta_{\\text{pix}}$ has an area given by $A_{\\text{cap}} = \\int_{0}^{2\\pi} d\\phi \\int_{0}^{\\theta_{\\text{pix}}} \\sin\\theta \\, d\\theta = 2\\pi(1 - \\cos\\theta_{\\text{pix}})$.\nEquating this to the pixel area $A_{\\text{pix}}$ and defining $\\mu \\equiv \\cos\\theta_{\\text{pix}}$, we have:\n$$2\\pi(1 - \\mu) = \\frac{\\pi}{3 N_{\\text{side}}^{2}}$$\n$$1 - \\mu = \\frac{1}{6 N_{\\text{side}}^{2}} \\implies \\mu = 1 - \\frac{1}{6 N_{\\text{side}}^{2}}$$\n\nThe pixel window function, $W_{\\ell}$, is the coefficient of the expansion of the pixel shape in Legendre polynomials. For an azimuthally symmetric kernel, this simplifies to the average of the Legendre polynomial $P_{\\ell}(\\cos\\theta)$ over the area of the kernel.\n$$W_{\\ell} = \\langle P_{\\ell}(\\cos\\theta) \\rangle_{\\text{cap}} = \\frac{1}{A_{\\text{pix}}} \\int_{\\text{cap}} P_{\\ell}(\\cos\\theta) \\, dA$$\nSubstituting the area element $dA = \\sin\\theta \\, d\\theta \\, d\\phi$ and integrating over the cap gives:\n$$W_{\\ell} = \\frac{1}{2\\pi(1-\\mu)} \\int_{0}^{2\\pi} d\\phi \\int_{0}^{\\theta_{\\text{pix}}} P_{\\ell}(\\cos\\theta) \\sin\\theta \\, d\\theta$$\nSince $P_{\\ell}(\\cos\\theta)$ is independent of $\\phi$, the integral over $\\phi$ yields $2\\pi$.\n$$W_{\\ell} = \\frac{1}{1-\\mu} \\int_{0}^{\\theta_{\\text{pix}}} P_{\\ell}(\\cos\\theta) \\sin\\theta \\, d\\theta$$\nWe perform a change of variable to $x = \\cos\\theta$, for which $dx = -\\sin\\theta \\, d\\theta$. The integration limits change from $\\theta=0$ to $\\theta=\\theta_{\\text{pix}}$ to $x=1$ to $x=\\mu$.\n$$W_{\\ell} = \\frac{1}{1-\\mu} \\int_{1}^{\\mu} P_{\\ell}(x) (-dx) = \\frac{1}{1-\\mu} \\int_{\\mu}^{1} P_{\\ell}(x) \\, dx$$\nTo evaluate the integral, we use the following standard identity for Legendre polynomials, valid for $\\ell \\ge 1$:\n$$\\int P_{\\ell}(x) \\, dx = \\frac{1}{2\\ell+1} (P_{\\ell+1}(x) - P_{\\ell-1}(x))$$\nApplying the definite integral from $\\mu$ to $1$:\n$$\\int_{\\mu}^{1} P_{\\ell}(x) \\, dx = \\frac{1}{2\\ell+1} [P_{\\ell+1}(x) - P_{\\ell-1}(x)]_{\\mu}^{1}$$\nUsing the property that $P_{n}(1) = 1$ for any integer $n \\geq 0$:\n$$[P_{\\ell+1}(x) - P_{\\ell-1}(x)]_{\\mu}^{1} = (P_{\\ell+1}(1) - P_{\\ell-1}(1)) - (P_{\\ell+1}(\\mu) - P_{\\ell-1}(\\mu)) = (1 - 1) - (P_{\\ell+1}(\\mu) - P_{\\ell-1}(\\mu)) = P_{\\ell-1}(\\mu) - P_{\\ell+1}(\\mu)$$\nSubstituting this result back into the expression for $W_{\\ell}$, we obtain the final formula for $\\ell \\ge 1$:\n$$W_{\\ell} = \\frac{P_{\\ell-1}(\\mu) - P_{\\ell+1}(\\mu)}{(2\\ell+1)(1-\\mu)}$$\nThis expression is used for all multipoles $\\ell \\geq 2$ as required by the problem.\n\n### 2. Power Spectra and Metrics\n\nThe intrinsic E-mode and B-mode power spectra are given by the parametric forms:\n$$C_{\\ell}^{EE} = A_{E} \\left(\\frac{\\ell + 0.5}{50}\\right)^{\\alpha_{E}} \\exp\\left[-\\ell(\\ell+1)\\sigma^{2}\\right]$$\n$$C_{\\ell}^{BB} = A_{B} \\left(\\frac{\\ell + 0.5}{50}\\right)^{\\alpha_{B}} \\exp\\left[-\\ell(\\ell+1)\\sigma^{2}\\right]$$\nThe pixelization effect attenuates the power spectrum, so the observed spectrum is $C_{\\ell, \\text{obs}} = C_{\\ell} W_{\\ell}^{2}$. The computations are performed over the multipole range $2 \\le \\ell \\le \\ell_{\\text{Ny}}$, where the Nyquist multipole is $\\ell_{\\text{Ny}} = 3 N_{\\text{side}} - 1$.\n\nThe impact of this attenuation is quantified using four metrics:\n1.  **E-mode fractional suppression ($S_E$)**: The power-weighted average of the fractional power loss, $1 - W_{\\ell}^2$.\n    $$S_{E} = \\frac{\\sum_{\\ell=2}^{\\ell_{\\text{Ny}}} C_{\\ell}^{EE} \\left(1 - W_{\\ell}^{2}\\right)}{\\sum_{\\ell=2}^{\\ell_{\\text{Ny}}} C_{\\ell}^{EE}}$$\n2.  **B-mode fractional suppression ($S_B$)**: The same metric for the B-mode spectrum.\n    $$S_{B} = \\frac{\\sum_{\\ell=2}^{\\ell_{\\text{Ny}}} C_{\\ell}^{BB} \\left(1 - W_{\\ell}^{2}\\right)}{\\sum_{\\ell=2}^{\\ell_{\\text{Ny}}} C_{\\ell}^{BB}}$$\n3.  **Half-power multipole ($\\ell_{\\tfrac{1}{2}}$)**: The smallest multipole $\\ell \\ge 2$ where the power attenuation factor $W_{\\ell}^2$ drops to $0.5$ or less. If this does not occur within the range $[2, \\ell_{\\text{Ny}}]$, the value is $-1$.\n4.  **RMS attenuation ($R$)**: The unweighted root-mean-square of the fractional power loss, measuring the typical magnitude of attenuation across the multipole range.\n    $$R = \\sqrt{\\frac{1}{\\ell_{\\text{Ny}}-1} \\sum_{\\ell=2}^{\\ell_{\\text{Ny}}} (1 - W_{\\ell}^{2})^{2}}$$\n\n### 3. Algorithmic Implementation\n\nFor each test case, the algorithm proceeds as follows:\n1.  Input parameters ($N_{\\text{side}}, A_E, \\alpha_E, A_B, \\alpha_B, \\sigma$) are defined.\n2.  The derived constants $\\ell_{\\text{Ny}} = 3 N_{\\text{side}} - 1$ and $\\mu = 1 - 1/(6 N_{\\text{side}}^2)$ are calculated.\n3.  An array of multipoles $\\ell$ is created, spanning from $2$ to $\\ell_{\\text{Ny}}$.\n4.  The Legendre polynomials $P_n(\\mu)$ are computed for all necessary orders $n$ from $0$ up to $\\ell_{\\text{Ny}} + 1$. This is efficiently done using `scipy.special.lpn`.\n5.  Using the derived formula, the pixel window function values $W_{\\ell}$ are computed for each $\\ell$ in the range. The quantity $W_{\\ell}^2$ is stored.\n6.  The intrinsic power spectra $C_{\\ell}^{EE}$ and $C_{\\ell}^{BB}$ are computed for each $\\ell$.\n7.  The four metrics ($S_E, S_B, \\ell_{\\tfrac{1}{2}}, R$) are calculated using vectorized `numpy` operations for summations and element-wise computations. For $\\ell_{\\tfrac{1}{2}}$, a search is performed to find the first multipole satisfying the condition.\n8.  The calculated metrics for each case are collected and formatted into the required output string.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import lpn\n\ndef solve():\n    \"\"\"\n    Computes CMB polarization power spectra suppression due to HEALPix pixelization.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N_side\": 8, \"A_E\": 1.0, \"alpha_E\": 1.0,\n            \"A_B\": 0.05, \"alpha_B\": 0.2, \"sigma\": 0.005\n        },\n        {\n            \"N_side\": 32, \"A_E\": 1.2, \"alpha_E\": 0.8,\n            \"A_B\": 0.08, \"alpha_B\": 0.4, \"sigma\": 0.004\n        },\n        {\n            \"N_side\": 1, \"A_E\": 0.9, \"alpha_E\": 2.0,\n            \"A_B\": 0.9, \"alpha_B\": 2.0, \"sigma\": 0.010\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        N_side = params[\"N_side\"]\n        A_E = params[\"A_E\"]\n        alpha_E = params[\"alpha_E\"]\n        A_B = params[\"A_B\"]\n        alpha_B = params[\"alpha_B\"]\n        sigma = params[\"sigma\"]\n\n        # Calculate derived constants\n        l_ny = 3 * N_side - 1\n        mu = 1.0 - 1.0 / (6.0 * N_side**2)\n        one_minus_mu = 1.0 / (6.0 * N_side**2)\n\n        # Generate multipole range, ensuring non-empty range\n        if l_ny < 2:\n            # Handle edge case where the Nyquist multipole is too low.\n            # Metrics are ill-defined as summations are empty.\n            # Based on problem check, this won't happen for the given test cases.\n            # But for robustness, we can define a result.\n            # Per problem spec, we can assume l_ny >= 2.\n            pass\n\n        ells = np.arange(2, l_ny + 1)\n\n        # Compute Legendre polynomials P_n(mu) up to order l_ny + 1\n        # lpn returns a tuple (polynomials, derivatives)\n        p_l_mu, _ = lpn(l_ny + 1, mu)\n\n        # Compute pixel window function W_ell\n        # W_l = (P_{l-1}(mu) - P_{l+1}(mu)) / ((2l+1)*(1-mu))\n        p_lm1 = p_l_mu[ells - 1]\n        p_lp1 = p_l_mu[ells + 1]\n        \n        # W_0 is 1. W_ell for ell >= 1.\n        w_ell = (p_lm1 - p_lp1) / ((2 * ells + 1) * one_minus_mu)\n        w_ell_sq = w_ell**2\n\n        # Compute intrinsic power spectra\n        c_ell_factor = ((ells + 0.5) / 50.0)\n        c_ell_exp = np.exp(-ells * (ells + 1) * sigma**2)\n        \n        c_ell_ee = A_E * (c_ell_factor**alpha_E) * c_ell_exp\n        c_ell_bb = A_B * (c_ell_factor**alpha_B) * c_ell_exp\n\n        # Metric 1: S_E\n        s_e_numerator = np.sum(c_ell_ee * (1.0 - w_ell_sq))\n        s_e_denominator = np.sum(c_ell_ee)\n        s_e = s_e_numerator / s_e_denominator if s_e_denominator != 0 else 0.0\n\n        # Metric 2: S_B\n        s_b_numerator = np.sum(c_ell_bb * (1.0 - w_ell_sq))\n        s_b_denominator = np.sum(c_ell_bb)\n        s_b = s_b_numerator / s_b_denominator if s_b_denominator != 0 else 0.0\n\n        # Metric 3: l_1/2\n        l_half_candidates = ells[w_ell_sq <= 0.5]\n        if l_half_candidates.size > 0:\n            l_half = l_half_candidates[0]\n        else:\n            l_half = -1\n            \n        # Metric 4: R\n        if l_ny > 1:\n            r_val = np.sqrt(np.mean((1.0 - w_ell_sq)**2))\n        else: # Handles l_ny = 2 case, where denominator is 1. Mean over 1 element.\n            r_val = np.sqrt(np.sum((1.0 - w_ell_sq)**2) / 1.0)\n            \n        all_results.append([s_e, s_b, int(l_half), r_val])\n\n    # Final print statement in the exact required format.\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "One of the most significant challenges in CMB polarization analysis is the inability to observe the full sky, which leads to E-B mixing. This practice delves into this problem by framing it in the language of linear algebra, where you will investigate how a finite observational patch makes it impossible to perfectly distinguish E-modes from B-modes. By analyzing the properties of the E-to-B leakage operator, you will quantify the number of \"ambiguous modes\" that are fundamentally unrecoverable, providing deep insight into a key systematic in the search for primordial gravitational waves .",
            "id": "3467210",
            "problem": "Consider a flat-sky discretization of Cosmic Microwave Background (CMB) linear polarization over a finite pixelized patch. Let the grid have $N_x$ by $N_y$ pixels with unit spacing. Let $f[i,j]$ denote a scalar field at integer pixel coordinates $0 \\leq i < N_x$, $0 \\leq j < N_y$. Define discrete second-derivative operators using zero extension outside the grid:\n- $D_{xx} f[i,j] = f[i+1,j] - 2 f[i,j] + f[i-1,j]$ with the convention that $f$ evaluated outside the grid is $0$,\n- $D_{yy} f[i,j] = f[i,j+1] - 2 f[i,j] + f[i,j-1]$ with the same convention,\n- $D_{xy} f[i,j] = \\dfrac{1}{4}\\left(f[i+1,j+1] - f[i+1,j-1] - f[i-1,j+1] + f[i-1,j-1]\\right)$ with the same convention.\n\nDefine two linear maps from a scalar potential to Stokes parameters $(Q,U)$ at each pixel:\n- The $E$-mode map produces\n$$Q_E = D_{xx}\\,\\phi_E - D_{yy}\\,\\phi_E,\\quad U_E = 2\\,D_{xy}\\,\\phi_E.$$\n- The $B$-mode map produces\n$$Q_B = -2\\,D_{xy}\\,\\phi_B,\\quad U_B = D_{xx}\\,\\phi_B - D_{yy}\\,\\phi_B.$$\n\nLet $\\mathcal{M}$ be a binary mask selecting a finite patch (a set of pixels). The masked polarization data vector concatenates $Q$ and $U$ values only at masked pixels, yielding a $2N_{\\text{mask}}$-dimensional observation space, where $N_{\\text{mask}}$ is the number of masked pixels. Let $M_E$ and $M_B$ be the matrix representations (with respect to the canonical bases) of the linear maps $\\phi_E \\mapsto (Q_E,U_E)$ and $\\phi_B \\mapsto (Q_B,U_B)$ restricted to masked pixels. Thus $M_E$ and $M_B$ are real matrices of size $2N_{\\text{mask}} \\times (N_x N_y)$.\n\nWe define the subspaces $S = \\mathrm{range}(M_E) \\subset \\mathbb{R}^{2N_{\\text{mask}}}$ and $T = \\mathrm{range}(M_B) \\subset \\mathbb{R}^{2N_{\\text{mask}}}$. The space of pure-$B$ polarization modes is $T \\cap S^{\\perp}$ with respect to the standard Euclidean inner product on the masked observation space. The quantity of interest is the dimension of the pure-$B$ space, which is the number of linearly independent masked $B$-mode polarization patterns orthogonal to all masked $E$-mode patterns.\n\nTask: Implement a program that, for each specified patch geometry (mask) on a grid, constructs $M_E$ and $M_B$ using the definitions above, computes orthonormal bases for $S$ and $T$ using Singular Value Decomposition (SVD), and outputs the dimension of $T \\cap S^{\\perp}$ for each test case. Use a numerically robust rank decision rule based on singular values to determine:\n- the dimension of $S$ and $T$, and\n- the rank of the cross-gram matrix between bases of $S$ and $T$.\n\nYou must not assume periodicity; use the zero-extension boundary convention described above. All computations are non-dimensional, and no physical units are involved.\n\nTest Suite (each case defines $(N_x,N_y)$ and the mask geometry):\n1. Case 1 (full square): $N_x = 8$, $N_y = 8$, mask includes all pixels.\n2. Case 2 (thin rectangle): $N_x = 12$, $N_y = 4$, mask includes all pixels.\n3. Case 3 (L-shape): $N_x = 10$, $N_y = 10$, mask includes pixels with $(i \\le 4)$ or $(j \\le 4)$ (zero-indexed), i.e., the union of a vertical and horizontal bar.\n4. Case 4 (discrete disk): $N_x = 11$, $N_y = 11$, mask includes all pixels with $(i - c_x)^2 + (j - c_y)^2 \\le r^2$ where $c_x = 5$, $c_y = 5$, $r = 5$.\n5. Case 5 (tiny patch): $N_x = 3$, $N_y = 3$, mask includes all pixels.\n\nAlgorithmic Requirements:\n- Construct the linear operators $D_{xx}$, $D_{yy}$, $D_{xy}$ as matrices on $\\mathbb{R}^{N_x N_y}$ consistent with the zero-extension rule.\n- Assemble $M_E$ and $M_B$ by stacking rows corresponding to $Q$ and $U$ at masked pixels.\n- Compute orthonormal bases $U_E$ and $U_B$ for $S$ and $T$ from the SVDs of $M_E$ and $M_B$ by retaining left singular vectors corresponding to singular values above a numerical tolerance.\n- Compute the cross-gram matrix $C = U_E^\\top U_B$ and determine its numerical rank.\n- Return the dimension of $T \\cap S^{\\perp}$ as an integer for each case.\n\nNumerical Tolerances:\n- For a matrix $A$ with singular values $\\sigma_1 \\ge \\sigma_2 \\ge \\dots$, define its numerical rank as the count of $\\sigma_k$ satisfying $\\sigma_k > \\max\\{ \\varepsilon_{\\text{abs}}, \\varepsilon_{\\text{rel}} \\,\\sigma_1 \\}$ with $\\varepsilon_{\\text{abs}} = 10^{-10}$ and $\\varepsilon_{\\text{rel}} = 10^{-9}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the five cases above. For example, an output of the form $[n_1,n_2,n_3,n_4,n_5]$ where each $n_k$ is the integer dimension of the pure-$B$ space for case $k$.",
            "solution": "The central task is to determine the dimension of the pure-$B$ mode subspace for a set of discretely sampled Cosmic Microwave Background (CMB) polarization maps. This subspace, denoted $T \\cap S^{\\perp}$, consists of all masked $B$-mode polarization patterns that are orthogonal to every possible masked $E$-mode pattern. Its dimension quantifies the number of unique $B$-mode signals that cannot be produced by the leakage of $E$-modes due to incomplete sky coverage, a phenomenon known as E-B mixing. The problem is thus a well-defined exercise in numerical linear algebra, predicated on the principles of CMB polarization analysis.\n\nThe solution proceeds through a sequence of logical and algorithmic steps, from the abstract definition of the problem to a concrete numerical result.\n\nFirst, we formalize the spaces and the quantity of interest. The set of all possible $E$-mode patterns on the masked grid forms a subspace $S = \\mathrm{range}(M_E) \\subset \\mathbb{R}^{2N_{\\text{mask}}}$, where $M_E$ is the linear operator mapping an $E$-mode potential $\\phi_E$ to the masked Stokes parameters $(Q_E, U_E)$. Similarly, the $B$-mode patterns form a subspace $T = \\mathrm{range}(M_B) \\subset \\mathbb{R}^{2N_{\\text{mask}}}$. We seek to compute $\\mathrm{dim}(T \\cap S^{\\perp})$.\n\nLet $U_E$ and $U_B$ be matrices whose columns form orthonormal bases for the subspaces $S$ and $T$, respectively. The number of columns in $U_E$ is $r_E = \\mathrm{dim}(S) = \\mathrm{rank}(M_E)$, and the number of columns in $U_B$ is $r_B = \\mathrm{dim}(T) = \\mathrm{rank}(M_B)$. Any vector $v \\in T$ can be expressed as a linear combination of the basis vectors of $T$: $v = U_B c$ for some coefficient vector $c \\in \\mathbb{R}^{r_B}$. For this vector $v$ to belong to the orthogonal complement of $S$, denoted $S^{\\perp}$, it must be orthogonal to all basis vectors of $S$. This condition is expressed as $U_E^\\top v = 0$. Substituting the expression for $v$, we obtain the condition on the coefficient vector $c$:\n$$\nU_E^\\top (U_B c) = (U_E^\\top U_B)c = 0\n$$\nLet $C = U_E^\\top U_B$ be the cross-gram matrix of inner products between the basis vectors of $S$ and $T$. The condition simplifies to $C c = 0$. This means that the coefficient vectors $c$ corresponding to modes in $T \\cap S^{\\perp}$ must lie in the null space (kernel) of $C$, i.e., $c \\in \\ker(C)$.\nSince the columns of $U_B$ are orthonormal, the mapping from $c$ to $U_B c$ is an isometry. Therefore, the dimension of the space of pure-$B$ modes is equal to the dimension of the null space of $C$:\n$$\n\\mathrm{dim}(T \\cap S^{\\perp}) = \\mathrm{dim}(\\ker(C))\n$$\nBy the rank-nullity theorem applied to the linear map represented by $C: \\mathbb{R}^{r_B} \\to \\mathbb{R}^{r_E}$, we have:\n$$\n\\mathrm{dim}(\\ker(C)) + \\mathrm{rank}(C) = \\mathrm{dim}(\\mathbb{R}^{r_B}) = r_B\n$$\nThus, the dimension of the pure-$B$ space is given by:\n$$\n\\mathrm{dim}(T \\cap S^{\\perp}) = r_B - \\mathrm{rank}(C) = \\mathrm{rank}(M_B) - \\mathrm{rank}(U_E^\\top U_B)\n$$\n\nThe algorithm to compute this dimension is as follows:\n1.  **Discretization and Operator Construction**: For a grid of size $N_x \\times N_y$, we vectorize any scalar field $f[i,j]$ into a vector in $\\mathbb{R}^{N_{\\text{pix}}}$ where $N_{\\text{pix}} = N_x N_y$. We use a row-major ordering, where the 1D index is $k = i \\cdot N_y + j$ for a pixel at $(i,j)$. The discrete differential operators $D_{xx}$, $D_{yy}$, and $D_{xy}$ are constructed as $N_{\\text{pix}} \\times N_{\\text{pix}}$ matrices. The definition of each operator, including the zero-extension boundary condition, determines the non-zero entries of its matrix representation. For example, the action of $D_{xx}$ on a pixel $(i,j)$ involves its neighbors $(i\\pm 1, j)$. This translates to setting entries in the $k$-th row of the matrix $D_{xx}$ at columns $k$ (for the $-2f[i,j]$ term) and $k \\pm N_y$ (for the $f[i \\pm 1, j]$ terms), with care taken at the boundaries where neighbors would be off-grid.\n\n2.  **Observation Matrix Assembly**: The linear maps from potentials to masked Stokes parameters, $M_E$ and $M_B$, are constructed. These are matrices of size $(2N_{\\text{mask}}) \\times N_{\\text{pix}}$. $M_E$ is formed by vertically stacking two blocks: the first block contains the rows of the operator $D_{xx} - D_{yy}$ corresponding to the $Q$ measurements at the $N_{\\text{mask}}$ masked pixels, and the second block contains the rows of $2D_{xy}$ for the $U$ measurements. $M_B$ is constructed analogously from the operators $-2D_{xy}$ and $D_{xx} - D_{yy}$.\n\n3.  **Orthonormal Basis Computation**: The orthonormal bases $U_E$ and $U_B$ for the ranges of $M_E$ and $M_B$ are found using the Singular Value Decomposition (SVD). For a matrix $M$, its SVD is $M = U\\Sigma V^\\top$. The columns of $U$ (the left singular vectors) corresponding to non-zero singular values in $\\Sigma$ form an orthonormal basis for $\\mathrm{range}(M)$.\n\n4.  **Numerical Rank**: In finite-precision arithmetic, we use a numerical criterion to decide if a singular value is effectively non-zero. The numerical rank of a matrix is the number of its singular values $\\sigma_k$ that satisfy $\\sigma_k > \\max\\{ \\varepsilon_{\\text{abs}}, \\varepsilon_{\\text{rel}} \\,\\sigma_1 \\}$, where $\\sigma_1$ is the largest singular value, $\\varepsilon_{\\text{abs}} = 10^{-10}$, and $\\varepsilon_{\\text{rel}} = 10^{-9}$. This rule is used to determine $r_E = \\mathrm{rank}(M_E)$, $r_B = \\mathrm{rank}(M_B)$, and finally $r_C = \\mathrm{rank}(C)$.\n\n5.  **Final Calculation**: Once the orthonormal bases $U_E$ (a $2N_{\\text{mask}} \\times r_E$ matrix) and $U_B$ (a $2N_{\\text{mask}} \\times r_B$ matrix) are determined, the cross-gram matrix $C = U_E^\\top U_B$ is computed. Its numerical rank, $r_C$, is found via SVD. The final answer for each test case is the integer $\\mathrm{dim}(T \\cap S^{\\perp}) = r_B - r_C$. This procedure is systematically applied to each specified grid geometry and mask.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the E/B mode separation problem for all specified test cases.\n    \"\"\"\n    \n    # Numerical tolerances for rank determination\n    eps_abs = 1e-10\n    eps_rel = 1e-9\n\n    test_cases = [\n        {'name': 'Case 1 (full square)', 'Nx': 8, 'Ny': 8, 'mask_type': 'full'},\n        {'name': 'Case 2 (thin rectangle)', 'Nx': 12, 'Ny': 4, 'mask_type': 'full'},\n        {'name': 'Case 3 (L-shape)', 'Nx': 10, 'Ny': 10, 'mask_type': 'L-shape'},\n        {'name': 'Case 4 (discrete disk)', 'Nx': 11, 'Ny': 11, 'mask_type': 'disk'},\n        {'name': 'Case 5 (tiny patch)', 'Nx': 3, 'Ny': 3, 'mask_type': 'full'},\n    ]\n\n    results = []\n\n    def get_numerical_rank(s, eps_abs, eps_rel):\n        \"\"\"Computes the numerical rank from a list of singular values.\"\"\"\n        if s.size == 0:\n            return 0\n        s_max = s[0]\n        # s_max can be 0 for a zero matrix.\n        if s_max < eps_abs: # Effectively zero matrix\n            return 0\n        tolerance = max(eps_abs, eps_rel * s_max)\n        return np.sum(s > tolerance)\n\n    def create_derivative_matrices(Nx, Ny):\n        \"\"\"Creates matrix representations of D_xx, D_yy, D_xy operators.\"\"\"\n        N_pix = Nx * Ny\n        D_xx = np.zeros((N_pix, N_pix), dtype=np.float64)\n        D_yy = np.zeros((N_pix, N_pix), dtype=np.float64)\n        D_xy = np.zeros((N_pix, N_pix), dtype=np.float64)\n\n        for i in range(Nx):\n            for j in range(Ny):\n                k = i * Ny + j\n                \n                # D_xx: f[i+1,j] - 2f[i,j] + f[i-1,j]\n                D_xx[k, k] = -2.0\n                if i > 0:\n                    D_xx[k, k - Ny] = 1.0\n                if i < Nx - 1:\n                    D_xx[k, k + Ny] = 1.0\n\n                # D_yy: f[i,j+1] - 2f[i,j] + f[i,j-1]\n                D_yy[k, k] = -2.0\n                if j > 0:\n                    D_yy[k, k - 1] = 1.0\n                if j < Ny - 1:\n                    D_yy[k, k + 1] = 1.0\n                    \n                # D_xy: 1/4 * (f[i+1,j+1] - f[i+1,j-1] - f[i-1,j+1] + f[i-1,j-1])\n                if i < Nx - 1 and j < Ny - 1:\n                    D_xy[k, k + Ny + 1] = 0.25\n                if i < Nx - 1 and j > 0:\n                    D_xy[k, k + Ny - 1] = -0.25\n                if i > 0 and j < Ny - 1:\n                    D_xy[k, k - Ny + 1] = -0.25\n                if i > 0 and j > 0:\n                    D_xy[k, k - Ny - 1] = 0.25\n                    \n        return D_xx, D_yy, D_xy\n\n    for case in test_cases:\n        Nx, Ny = case['Nx'], case['Ny']\n        \n        # Define mask for each case\n        if case['mask_type'] == 'full':\n            mask = np.ones((Nx, Ny), dtype=bool)\n        elif case['mask_type'] == 'L-shape':\n            mask = np.zeros((Nx, Ny), dtype=bool)\n            for i in range(Nx):\n                for j in range(Ny):\n                    if i <= 4 or j <= 4:\n                        mask[i, j] = True\n        elif case['mask_type'] == 'disk':\n            mask = np.zeros((Nx, Ny), dtype=bool)\n            cx, cy, r = 5.0, 5.0, 5.0\n            for i in range(Nx):\n                for j in range(Ny):\n                    if (i - cx)**2 + (j - cy)**2 <= r**2:\n                        mask[i, j] = True\n        \n        N_pix = Nx * Ny\n        masked_indices = np.where(mask.flatten())[0]\n        N_mask = len(masked_indices)\n\n        if N_mask == 0:\n            results.append(0)\n            continue\n\n        D_xx, D_yy, D_xy = create_derivative_matrices(Nx, Ny)\n        \n        # Assemble E-mode and B-mode operators\n        L1 = D_xx - D_yy\n        L2 = 2 * D_xy\n\n        # Construct masked observation matrices M_E and M_B\n        Q_rows_E = L1[masked_indices, :]\n        U_rows_E = L2[masked_indices, :]\n        M_E = np.vstack([Q_rows_E, U_rows_E])\n\n        Q_rows_B = -L2[masked_indices, :]\n        U_rows_B = L1[masked_indices, :]\n        M_B = np.vstack([Q_rows_B, U_rows_B])\n\n        # Compute orthonormal basis for S = range(M_E) via SVD\n        U_svd_E, s_E, _ = np.linalg.svd(M_E, full_matrices=False)\n        rank_E = get_numerical_rank(s_E, eps_abs, eps_rel)\n        U_E = U_svd_E[:, :rank_E]\n        \n        # Compute orthonormal basis for T = range(M_B) via SVD\n        U_svd_B, s_B, _ = np.linalg.svd(M_B, full_matrices=False)\n        rank_B = get_numerical_rank(s_B, eps_abs, eps_rel)\n        U_B = U_svd_B[:, :rank_B]\n        \n        # Compute rank of cross-gram matrix C = U_E^T @ U_B\n        if rank_E == 0 or rank_B == 0:\n            rank_C = 0\n        else:\n            C = U_E.T @ U_B\n            s_C = np.linalg.svd(C, compute_uv=False)\n            rank_C = get_numerical_rank(s_C, eps_abs, eps_rel)\n\n        # Dimension of pure-B space is rank(M_B) - rank(C)\n        dim_pure_B = rank_B - rank_C\n        results.append(dim_pure_B)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}