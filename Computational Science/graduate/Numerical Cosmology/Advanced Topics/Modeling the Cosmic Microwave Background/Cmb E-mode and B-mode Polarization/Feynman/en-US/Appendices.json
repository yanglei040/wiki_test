{
    "hands_on_practices": [
        {
            "introduction": "The Cosmic Microwave Background (CMB) E-mode power spectrum, $C_{\\ell}^{EE}$, is a cornerstone prediction of modern cosmology, encoding a wealth of information about the early universe. This spectrum is not arbitrary; it arises directly from primordial scalar density perturbations that evolved through the plasma epoch. This exercise guides you through the process of computing the $C_{\\ell}^{EE}$ spectrum from first principles using the line-of-sight (LOS) integral formalism . By implementing this calculation numerically, you will build a foundational understanding of how initial conditions translate into observable anisotropies, moving beyond \"black-box\" Boltzmann solvers to see the physical connections directly.",
            "id": "3467172",
            "problem": "You are asked to design and implement a complete, self-contained numerical program that computes the Cosmic Microwave Background (CMB) $E$-mode polarization angular power spectrum $C_{\\ell}^{EE}$ for scalar initial conditions using the line-of-sight integration method. Your implementation must start from a clear, principle-based foundation without using any pre-packaged CMB solvers. The computation must be framed in purely mathematical terms, with physically consistent but simplified ingredients so that the program does not depend on external data or codes. The scenario must be scientifically realistic and self-consistent.\n\nBegin from the following fundamental base:\n\n- The CMB polarization arises from Thomson scattering, whose differential cross-section depends on the incident radiation field anisotropy. A local quadrupole anisotropy in the photon distribution generates linear polarization, described by the Stokes parameters $Q$ and $U$.\n- Linear perturbation theory of the photon distribution is encoded in the Boltzmann equation. Under scalar initial conditions, the polarization field on the sky can be decomposed into gradient-like and curl-like components, referred to as $E$-mode and $B$-mode, respectively. In the absence of tensor perturbations and lensing, the scalar initial conditions produce only $E$-modes.\n- The line-of-sight formalism expresses multipole moments of the radiation field as integrals over conformal time of source terms multiplied by spherical Bessel functions, reflecting free streaming of photons from the last scattering surface to the observer.\n\nYour algorithm must proceed by:\n\n1. Defining a physically motivated but numerically tractable visibility function to model last scattering as a finite-width process:\n   - Use a normalized Gaussian visibility function $g(\\eta)$ centered at a recombination conformal time $\\,\\eta_{\\star}\\,$ with width $\\,\\sigma_{\\eta}\\,$, satisfying $\\int g(\\eta) \\, d\\eta = 1$. Here and throughout, conformal times must be in megaparsecs (Mpc).\n2. Modeling the polarization source amplitude as a scale-dependent factor $Q(k)$ that captures the efficiency of polarization generation and microphysical damping:\n   - Use $Q(k) = q_{0}\\,\\exp\\!\\big( - (k/k_{d})^{m} \\big)$ with $k$ in inverse megaparsecs $\\,\\mathrm{Mpc}^{-1}\\,$, $q_{0}$ a dimensionless efficiency factor, $k_{d}$ a damping scale, and $m$ a positive integer exponent. All wavenumbers must be in $\\,\\mathrm{Mpc}^{-1}\\,$.\n3. Implementing the line-of-sight integral for the $E$-mode transfer function, discretized in conformal time:\n   - Let $D(\\eta) = \\eta_{0} - \\eta$ with $\\eta_{0}$ the conformal time today, in $\\,\\mathrm{Mpc}\\,$.\n   - Define a transfer function $\\Delta_{\\ell}^{E}(k)$ through an integral over $\\eta$ of a source $S_{E}(k,\\eta)$ times a spherical Bessel function $j_{\\ell}(k D(\\eta))$.\n   - In this simplified model, set $S_{E}(k,\\eta) = Q(k)\\,g(\\eta)$ so that $\\Delta_{\\ell}^{E}(k)$ reduces to a convolution of $j_{\\ell}$ with $g(\\eta)$ weighted by $Q(k)$.\n4. Computing the angular power spectrum $C_{\\ell}^{EE}$ by integrating over wavenumber with the primordial curvature power spectrum $P_{\\mathcal{R}}(k)$:\n   - Use $P_{\\mathcal{R}}(k) = A_{s}\\,(k/k_{0})^{n_{s} - 1}$, where $A_{s}$ is the scalar amplitude, $n_{s}$ is the spectral index, and $k_{0}$ is a pivot scale. All wavenumbers are in $\\,\\mathrm{Mpc}^{-1}\\,$.\n   - Discretize the $k$-integral in $\\ln k$ and compute $C_{\\ell}^{EE}$ via an integral of $P_{\\mathcal{R}}(k)\\big(\\Delta_{\\ell}^{E}(k)\\big)^{2}$.\n\nScientific and numerical requirements:\n\n- Units:\n  - Conformal time $\\,\\eta\\,$ and $\\eta_{0}$ must be specified in $\\,\\mathrm{Mpc}\\,$.\n  - Wavenumber $\\,k\\,$ must be specified in $\\,\\mathrm{Mpc}^{-1}\\,$.\n  - Angles are implicit in the arguments to spherical Bessel functions $j_{\\ell}(\\cdot)$ and are dimensionless in radians.\n  - The final $C_{\\ell}^{EE}$ values must be reported as unitless floats (no units attached), since the normalization is set by $P_{\\mathcal{R}}(k)$ in this simplified model.\n- Numerical integration:\n  - Discretize $\\eta$ over a symmetric interval around $\\,\\eta_{\\star}\\,$ that captures the width $\\,\\sigma_{\\eta}\\,$ (for example, several $\\,\\sigma_{\\eta}\\,$ on either side).\n  - Discretize $k$ logarithmically over a physically reasonable range $[k_{\\min}, k_{\\max}]$ sufficient to capture the support of $j_{\\ell}(kD)$ for the chosen multipoles.\n  - Use numerically stable and convergent quadratures (for example, trapezoidal rule) for both $\\eta$ and $\\ln k$ integrals.\n- Scalar initial conditions:\n  - Restrict to scalar initial conditions without gravitational lensing or tensor modes; $B$-mode polarization is neglected.\n\nValidation requirement:\n\n- Although a full validation against a public Boltzmann solver such as the Cosmic Linear Anisotropy Solving System (CLASS) is beyond the scope of this self-contained program, include a diagnostic that compares the finite-width recombination result to the instantaneous recombination limit, modeled by replacing $g(\\eta)$ by a Dirac delta at $\\,\\eta_{\\star}\\,$. Construct the corresponding reference $C_{\\ell}^{EE,\\mathrm{inst}}$ using $\\,\\Delta_{\\ell}^{E,\\mathrm{inst}}(k) = Q(k)\\,j_{\\ell}(k D(\\eta_{\\star}))\\,$. Report a boolean indicating whether the correlation between the two $C_{\\ell}^{EE}$ arrays for a small $\\,\\sigma_{\\eta}\\,$ exceeds a chosen threshold, signifying consistency with the instantaneous limit.\n\nTest suite:\n\nImplement the program to compute and report results for the following parameter sets. Each test case must produce a list of floats corresponding to $C_{\\ell}^{EE}$ for the specified multipoles:\n\n- Test Case $\\,1\\,$ (happy path):\n  - $\\eta_{0} = 14000\\,\\mathrm{Mpc}$, $\\eta_{\\star} = 280\\,\\mathrm{Mpc}$, $\\sigma_{\\eta} = 18\\,\\mathrm{Mpc}$, $q_{0} = 0.17$, $k_{d} = 0.14\\,\\mathrm{Mpc}^{-1}$, $m = 2$, $A_{s} = 2.1\\times 10^{-9}$, $n_{s} = 0.965$, $k_{0} = 0.05\\,\\mathrm{Mpc}^{-1}$, multipoles $\\ell \\in \\{2, 10, 100, 500\\}$, $k$-range $[10^{-4}, 2]\\,\\mathrm{Mpc}^{-1}$.\n- Test Case $\\,2\\,$ (near-instantaneous recombination boundary):\n  - $\\eta_{0} = 14000\\,\\mathrm{Mpc}$, $\\eta_{\\star} = 280\\,\\mathrm{Mpc}$, $\\sigma_{\\eta} = 2\\,\\mathrm{Mpc}$, $q_{0} = 0.17$, $k_{d} = 0.35\\,\\mathrm{Mpc}^{-1}$, $m = 2$, $A_{s} = 2.1\\times 10^{-9}$, $n_{s} = 0.965$, $k_{0} = 0.05\\,\\mathrm{Mpc}^{-1}$, multipoles $\\ell \\in \\{20, 80, 200\\}$, $k$-range $[10^{-4}, 2]\\,\\mathrm{Mpc}^{-1}$.\n- Test Case $\\,3\\,$ (edge case: spectral index change):\n  - $\\eta_{0} = 14000\\,\\mathrm{Mpc}$, $\\eta_{\\star} = 280\\,\\mathrm{Mpc}$, $\\sigma_{\\eta} = 18\\,\\mathrm{Mpc}$, $q_{0} = 0.17$, $k_{d} = 0.14\\,\\mathrm{Mpc}^{-1}$, $m = 2$, $A_{s} = 2.1\\times 10^{-9}$, $n_{s} = 1.0$, $k_{0} = 0.05\\,\\mathrm{Mpc}^{-1}$, multipoles $\\ell \\in \\{2\\}$, $k$-range $[10^{-4}, 2]\\,\\mathrm{Mpc}^{-1}$.\n- Validation diagnostic (boolean):\n  - Using Test Case $\\,2\\,$ parameters, compute both the finite-width result and the instantaneous reference result as described above for the same set of $\\ell$ values. Report a boolean indicating whether the Pearson correlation coefficient between the two $C_{\\ell}^{EE}$ arrays exceeds $\\,0.995\\,$ and the ratio of their means lies within $[0.8,\\,1.2]$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The first three entries must be the lists of $C_{\\ell}^{EE}$ values for Test Cases $\\,1\\,$, $\\,2\\,$, and $\\,3\\,$, respectively. The fourth entry must be the validation diagnostic boolean. For example, the output must have the form\n  - $[\\,[c_{1,\\ell_{1}}, c_{1,\\ell_{2}}, \\dots],\\,[c_{2,\\ell_{1}}, c_{2,\\ell_{2}}, \\dots],\\,[c_{3,\\ell_{1}}, \\dots],\\,\\mathrm{true}\\,]$\n  - The floats must be printed without units.",
            "solution": "The problem statement has been critically validated and is deemed valid. It is scientifically grounded in the principles of physical cosmology, mathematically well-posed, and all provided parameters and functional forms are self-consistent and physically realistic for a simplified model. The task is to implement a numerical calculation of the CMB $E$-mode polarization angular power spectrum, $C_{\\ell}^{EE}$, from first principles using the line-of-sight integration method.\n\nThe theoretical foundation of the calculation rests on expressing the angular power spectrum $C_{\\ell}^{EE}$ as an integral over contributions from all Fourier modes of primordial fluctuations. The contribution of each mode with wavenumber $k$ is weighted by the primordial power spectrum $P_{\\mathcal{R}}(k)$ and modulated by a transfer function $\\Delta_{\\ell}^{E}(k)$, which encodes the evolution of perturbations from the early universe until today. The formula is:\n$$\nC_{\\ell}^{EE} = \\int_{0}^{\\infty} P_{\\mathcal{R}}(k) \\left( \\Delta_{\\ell}^{E}(k) \\right)^2 \\frac{dk}{k}\n$$\nThe integral is performed over the logarithm of the wavenumber $k$, which is standard for cosmological power spectra.\n\nThe primordial power spectrum, $P_{\\mathcal{R}}(k)$, describes the amplitude of initial scalar curvature perturbations and is modeled as a simple power law, consistent with inflationary theory:\n$$\nP_{\\mathcal{R}}(k) = A_{s} \\left( \\frac{k}{k_{0}} \\right)^{n_{s} - 1}\n$$\nHere, $A_{s}$ is the scalar amplitude, $n_{s}$ is the scalar spectral index measuring the scale dependence, and $k_{0}$ is an arbitrary pivot scale.\n\nThe $E$-mode transfer function, $\\Delta_{\\ell}^{E}(k)$, quantifies how a single primordial Fourier mode of wavenumber $k$ contributes to the observed polarization anisotropy at an angular multipole $\\ell$. It is given by the line-of-sight integral, which projects the polarization source term $S_{E}(k, \\eta)$ from each point in cosmic history (parametrized by conformal time $\\eta$) to the observer today (at $\\eta_{0}$):\n$$\n\\Delta_{\\ell}^{E}(k) = \\int_{0}^{\\eta_{0}} S_{E}(k, \\eta) j_{\\ell}\\big(k(\\eta_{0} - \\eta)\\big) d\\eta\n$$\nThe function $j_{\\ell}(x)$ is the spherical Bessel function of order $\\ell$, which arises from the decomposition of plane waves into spherical harmonics. The argument $k(\\eta_{0} - \\eta)$ represents the product of the wavenumber and the comoving distance from the source at time $\\eta$ to the observer.\n\nThe problem provides simplified, physically motivated models for the source term $S_{E}(k, \\eta)$:\n$$\nS_{E}(k, \\eta) = Q(k) g(\\eta)\n$$\nThis factorization separates the time dependence from the scale dependence.\n\n$1$. The visibility function, $g(\\eta)$, models the process of recombination, during which photons last scattered off free electrons. It is modeled as a normalized Gaussian function centered at the conformal time of recombination, $\\eta_{\\star}$, with a characteristic width $\\sigma_{\\eta}$:\n$$\ng(\\eta) = \\frac{1}{\\sigma_{\\eta}\\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\eta - \\eta_{\\star})^2}{2\\sigma_{\\eta}^2}\\right)\n$$\nThis function acts as a temporal window, ensuring that polarization is generated only during the finite interval of recombination.\n\n$2$. The source amplitude, $Q(k)$, models the efficiency of polarization generation and microphysical damping effects. It is given by:\n$$\nQ(k) = q_{0}\\,\\exp\\left( - (k/k_{d})^{m} \\right)\n$$\nwhere $q_{0}$ is a dimensionless efficiency factor. The exponential term models the suppression of anisotropies on small scales (large $k$) due to photon diffusion, an effect known as Silk damping, with $k_{d}$ being the characteristic damping scale and $m$ a positive integer.\n\nCombining these elements, the transfer function becomes:\n$$\n\\Delta_{\\ell}^{E}(k) = Q(k) \\int_{0}^{\\eta_{0}} g(\\eta) j_{\\ell}\\big(k(\\eta_{0} - \\eta)\\big) d\\eta\n$$\n\nThe algorithmic approach to computing $C_{\\ell}^{EE}$ proceeds by discretizing and numerically evaluating the nested integrals.\n\n**Step 1: Numerical Integration Grids**\n-   A logarithmic grid in wavenumber, $k_j$, is established over the range $[k_{\\min}, k_{\\max}]$, suitable for the wide dynamic range and power-law nature of the spectra. The integration variable becomes $\\ln k$.\n-   A linear grid in conformal time, $\\eta_i$, is established over a symmetric interval around $\\eta_{\\star}$ (e.g., $[\\eta_{\\star} - 6\\sigma_{\\eta}, \\eta_{\\star} + 6\\sigma_{\\eta}]$) to fully capture the support of the Gaussian visibility function.\n\n**Step 2: Computing the Transfer Function $\\Delta_{\\ell}^{E}(k_j)$**\nFor each multipole $\\ell$ and each wavenumber $k_j$ on the grid, the integral over $\\eta$ is computed numerically using the trapezoidal rule:\n$$\n\\int g(\\eta) j_{\\ell}\\big(k_j(\\eta_{0} - \\eta)\\big) d\\eta \\approx \\sum_{i} \\frac{g(\\eta_{i+1})j_{\\ell,i+1} + g(\\eta_i)j_{\\ell,i}}{2} (\\eta_{i+1} - \\eta_i)\n$$\nwhere $j_{\\ell,i} = j_{\\ell}\\big(k_j(\\eta_0 - \\eta_i)\\big)$. This value, when multiplied by $Q(k_j)$, gives $\\Delta_{\\ell}^{E}(k_j)$.\n\n**Step 3: Computing the Angular Power Spectrum $C_{\\ell}^{EE}$**\nWith the transfer function values $\\Delta_{\\ell}^{E}(k_j)$ computed for all $k_j$ on the grid, the final integral for $C_{\\ell}^{EE}$ is evaluated, again using the trapezoidal rule over the logarithmic $k$-grid:\n$$\nC_{\\ell}^{EE} \\approx \\sum_{j} \\frac{F(k_{j+1}) + F(k_j)}{2} (\\ln k_{j+1} - \\ln k_j)\n$$\nwhere the integrand is $F(k) = P_{\\mathcal{R}}(k) \\left( \\Delta_{\\ell}^{E}(k) \\right)^2$. This process is repeated for each $\\ell$ in the specified set of multipoles.\n\n**Step 4: Validation via the Instantaneous Recombination Limit**\nA crucial validation step involves comparing the result to the idealized limit of instantaneous recombination, where $\\sigma_{\\eta} \\to 0$. In this limit, the visibility function $g(\\eta)$ approaches a Dirac delta function, $g(\\eta) \\to \\delta(\\eta - \\eta_{\\star})$. The integral for the transfer function becomes trivial:\n$$\n\\Delta_{\\ell}^{E, \\mathrm{inst}}(k) = Q(k) \\int_{0}^{\\eta_{0}} \\delta(\\eta - \\eta_{\\star}) j_{\\ell}\\big(k(\\eta_{0} - \\eta)\\big) d\\eta = Q(k) j_{\\ell}\\big(k(\\eta_{0} - \\eta_{\\star})\\big)\n$$\nThe corresponding power spectrum, $C_{\\ell}^{EE, \\mathrm{inst}}$, is computed using this simplified transfer function. For a small but finite $\\sigma_{\\eta}$, the full numerical result should closely track this instantaneous approximation. The correlation and mean ratio between the two computed spectra serve as a powerful diagnostic for the correctness of the implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn\n\ndef compute_cl_ee(\n    multipoles, eta0, eta_star, sigma_eta, q0, kd, m, As, ns, k0, k_range,\n    num_k_pts=500, num_eta_pts=200, eta_width_factor=6.0\n):\n    \"\"\"\n    Computes the C_l^EE power spectrum for a finite-width recombination.\n\n    Args:\n        multipoles (list): List of multipole moments l to compute.\n        eta0, eta_star, sigma_eta (float): Cosmological time parameters in Mpc.\n        q0, kd, m (float): Parameters for the polarization source amplitude Q(k).\n        As, ns, k0 (float): Parameters for the primordial power spectrum P_R(k).\n        k_range (list): [k_min, k_max] for the wavenumber integration in Mpc^-1.\n        num_k_pts (int): Number of points for the log-spaced k-grid.\n        num_eta_pts (int): Number of points for the linear eta-grid.\n        eta_width_factor (float): The eta-grid spans eta_star +/- factor * sigma_eta.\n\n    Returns:\n        list: A list of C_l^EE values for the given multipoles.\n    \"\"\"\n    # 1. Define numerical integration grids\n    k_grid = np.logspace(np.log10(k_range[0]), np.log10(k_range[1]), num_k_pts)\n    eta_min = eta_star - eta_width_factor * sigma_eta\n    eta_max = eta_star + eta_width_factor * sigma_eta\n    eta_grid = np.linspace(eta_min, eta_max, num_eta_pts)\n\n    # 2. Evaluate physics functions on their respective grids\n    # Primordial power spectrum P_R(k)\n    P_R_k = As * (k_grid / k0)**(ns - 1)\n    # Polarization source amplitude Q(k)\n    Q_k = q0 * np.exp(-(k_grid / kd)**m)\n    # Normalized Gaussian visibility function g(eta)\n    g_eta = (1.0 / (sigma_eta * np.sqrt(2 * np.pi))) * \\\n            np.exp(-0.5 * ((eta_grid - eta_star) / sigma_eta)**2)\n\n    # 3. Compute the E-mode transfer functions Delta_l^E(k)\n    delta_matrix = np.zeros((len(multipoles), num_k_pts))\n    comoving_dist_from_source = eta0 - eta_grid\n\n    for j, l_val in enumerate(multipoles):\n        for i, k_val in enumerate(k_grid):\n            # Evaluate j_l(k * (eta0 - eta)) on the eta grid\n            bessel_arg = k_val * comoving_dist_from_source\n            j_l_values = spherical_jn(l_val, bessel_arg)\n            \n            # Integrand for the eta-integral\n            integrand_eta = g_eta * j_l_values\n            \n            # Perform integral numerically using the trapezoidal rule\n            integral_val = np.trapz(integrand_eta, eta_grid)\n            \n            delta_matrix[j, i] = Q_k[i] * integral_val\n\n    # 4. Compute the angular power spectrum C_l^EE\n    # Integrand for the k-integral: P_R(k) * (Delta_l^E(k))^2\n    k_integrand = P_R_k[np.newaxis, :] * (delta_matrix**2)\n    \n    # Perform integral over ln(k) using trapezoidal rule\n    log_k_grid = np.log(k_grid)\n    cl_ee_array = np.trapz(k_integrand, log_k_grid, axis=1)\n    \n    return cl_ee_array.tolist()\n\n\ndef compute_cl_ee_instantaneous(\n    multipoles, eta0, eta_star, q0, kd, m, As, ns, k0, k_range, num_k_pts=500\n):\n    \"\"\"\n    Computes the C_l^EE power spectrum for instantaneous recombination.\n\n    Args:\n        (Same as compute_cl_ee, but without sigma_eta and related parameters)\n\n    Returns:\n        np.array: An array of C_l^EE values.\n    \"\"\"\n    # 1. Define numerical integration grid for k\n    k_grid = np.logspace(np.log10(k_range[0]), np.log10(k_range[1]), num_k_pts)\n\n    # 2. Evaluate physics functions on the k-grid\n    P_R_k = As * (k_grid / k0)**(ns - 1)\n    Q_k = q0 * np.exp(-(k_grid / kd)**m)\n\n    # 3. Compute the transfer functions Delta_l^E,inst(k)\n    delta_inst_matrix = np.zeros((len(multipoles), num_k_pts))\n    comoving_dist_recomb = eta0 - eta_star\n    \n    bessel_arg = k_grid * comoving_dist_recomb\n    for j, l_val in enumerate(multipoles):\n        j_l_values = spherical_jn(l_val, bessel_arg)\n        delta_inst_matrix[j, :] = Q_k * j_l_values\n        \n    # 4. Compute C_l^EE,inst\n    k_integrand = P_R_k[np.newaxis, :] * (delta_inst_matrix**2)\n    log_k_grid = np.log(k_grid)\n    cl_ee_inst_array = np.trapz(k_integrand, log_k_grid, axis=1)\n\n    return cl_ee_inst_array\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: Happy path\n        {\n            \"eta0\": 14000.0, \"eta_star\": 280.0, \"sigma_eta\": 18.0,\n            \"q0\": 0.17, \"kd\": 0.14, \"m\": 2, \"As\": 2.1e-9, \"ns\": 0.965, \"k0\": 0.05,\n            \"multipoles\": [2, 10, 100, 500], \"k_range\": [1e-4, 2.0]\n        },\n        # Test Case 2: Near-instantaneous recombination\n        {\n            \"eta0\": 14000.0, \"eta_star\": 280.0, \"sigma_eta\": 2.0,\n            \"q0\": 0.17, \"kd\": 0.35, \"m\": 2, \"As\": 2.1e-9, \"ns\": 0.965, \"k0\": 0.05,\n            \"multipoles\": [20, 80, 200], \"k_range\": [1e-4, 2.0]\n        },\n        # Test Case 3: Edge case (scale-invariant spectrum)\n        {\n            \"eta0\": 14000.0, \"eta_star\": 280.0, \"sigma_eta\": 18.0,\n            \"q0\": 0.17, \"kd\": 0.14, \"m\": 2, \"As\": 2.1e-9, \"ns\": 1.0, \"k0\": 0.05,\n            \"multipoles\": [2], \"k_range\": [1e-4, 2.0]\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        cls = compute_cl_ee(**params)\n        results.append(cls)\n\n    # Perform the validation diagnostic using parameters from Test Case 2\n    validation_params = test_cases[1]\n    cls_finite = np.array(compute_cl_ee(**validation_params))\n    \n    params_inst = {\n        key: val for key, val in validation_params.items() if key != 'sigma_eta'\n    }\n    cls_inst = compute_cl_ee_instantaneous(**params_inst)\n\n    # Compute Pearson correlation coefficient\n    # r = cov(X, Y) / (std(X) * std(Y))\n    corr_matrix = np.corrcoef(cls_finite, cls_inst)\n    correlation = corr_matrix[0, 1] if corr_matrix.shape == (2,2) else 1.0\n    \n    # Compute ratio of means\n    mean_ratio = np.mean(cls_finite) / np.mean(cls_inst) if np.mean(cls_inst) != 0 else 0\n\n    validation_bool = (correlation > 0.995) and (0.8  mean_ratio  1.2)\n    results.append(validation_bool)\n    \n    # Format the final output string\n    result_strs = []\n    for item in results:\n        if isinstance(item, bool):\n            result_strs.append(str(item).lower())\n        else:\n            result_strs.append(str(item))\n            \n    print(f\"[{','.join(result_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A fundamental challenge in CMB polarization analysis is the clean separation of E-modes and B-modes. While these components are perfectly orthogonal on the full sky, any real-world observation is restricted to a finite patch, which inevitably breaks this orthogonality. This exercise tackles the critical problem of E-to-B leakage, a major source of contamination for searches of faint primordial B-modes . You will use the tools of numerical linear algebra to investigate how the geometry of an observational patch creates \"ambiguous modes\" and quantify the subspace of \"pure B-modes\" that are immune to this mixing, a crucial concept for designing and interpreting data from modern CMB experiments.",
            "id": "3467210",
            "problem": "Consider a flat-sky discretization of Cosmic Microwave Background (CMB) linear polarization over a finite pixelized patch. Let the grid have $N_x$ by $N_y$ pixels with unit spacing. Let $f[i,j]$ denote a scalar field at integer pixel coordinates $0 \\le i lt; N_x$, $0 \\le j lt; N_y$. Define discrete second-derivative operators using zero extension outside the grid:\n- $D_{xx} f[i,j] = f[i+1,j] - 2 f[i,j] + f[i-1,j]$ with the convention that $f$ evaluated outside the grid is $0$,\n- $D_{yy} f[i,j] = f[i,j+1] - 2 f[i,j] + f[i,j-1]$ with the same convention,\n- $D_{xy} f[i,j] = \\dfrac{1}{4}\\left(f[i+1,j+1] - f[i+1,j-1] - f[i-1,j+1] + f[i-1,j-1]\\right)$ with the same convention.\n\nDefine two linear maps from a scalar potential to Stokes parameters $(Q,U)$ at each pixel:\n- The $E$-mode map produces\n$$Q_E = D_{xx}\\,\\phi_E - D_{yy}\\,\\phi_E,\\quad U_E = 2\\,D_{xy}\\,\\phi_E.$$\n- The $B$-mode map produces\n$$Q_B = -2\\,D_{xy}\\,\\phi_B,\\quad U_B = D_{xx}\\,\\phi_B - D_{yy}\\,\\phi_B.$$\n\nLet $\\mathcal{M}$ be a binary mask selecting a finite patch (a set of pixels). The masked polarization data vector concatenates $Q$ and $U$ values only at masked pixels, yielding a $2N_{\\text{mask}}$-dimensional observation space, where $N_{\\text{mask}}$ is the number of masked pixels. Let $M_E$ and $M_B$ be the matrix representations (with respect to the canonical bases) of the linear maps $\\phi_E \\mapsto (Q_E,U_E)$ and $\\phi_B \\mapsto (Q_B,U_B)$ restricted to masked pixels. Thus $M_E$ and $M_B$ are real matrices of size $2N_{\\text{mask}} \\times (N_x N_y)$.\n\nWe define the subspaces $S = \\mathrm{range}(M_E) \\subset \\mathbb{R}^{2N_{\\text{mask}}}$ and $T = \\mathrm{range}(M_B) \\subset \\mathbb{R}^{2N_{\\text{mask}}}$. The space of pure-$B$ polarization modes is $T \\cap S^{\\perp}$ with respect to the standard Euclidean inner product on the masked observation space. The quantity of interest is the dimension of the pure-$B$ space, which is the number of linearly independent masked $B$-mode polarization patterns orthogonal to all masked $E$-mode patterns.\n\nTask: Implement a program that, for each specified patch geometry (mask) on a grid, constructs $M_E$ and $M_B$ using the definitions above, computes orthonormal bases for $S$ and $T$ using Singular Value Decomposition (SVD), and outputs the dimension of $T \\cap S^{\\perp}$ for each test case. Use a numerically robust rank decision rule based on singular values to determine:\n- the dimension of $S$ and $T$, and\n- the rank of the cross-gram matrix between bases of $S$ and $T$.\n\nYou must not assume periodicity; use the zero-extension boundary convention described above. All computations are non-dimensional, and no physical units are involved.\n\nTest Suite (each case defines $(N_x,N_y)$ and the mask geometry):\n1. Case 1 (full square): $N_x = 8$, $N_y = 8$, mask includes all pixels.\n2. Case 2 (thin rectangle): $N_x = 12$, $N_y = 4$, mask includes all pixels.\n3. Case 3 (L-shape): $N_x = 10$, $N_y = 10$, mask includes pixels with $(i \\le 4)$ or $(j \\le 4)$ (zero-indexed), i.e., the union of a vertical and horizontal bar.\n4. Case 4 (discrete disk): $N_x = 11$, $N_y = 11$, mask includes all pixels with $(i - c_x)^2 + (j - c_y)^2 \\le r^2$ where $c_x = 5$, $c_y = 5$, $r = 5$.\n5. Case 5 (tiny patch): $N_x = 3$, $N_y = 3$, mask includes all pixels.\n\nAlgorithmic Requirements:\n- Construct the linear operators $D_{xx}$, $D_{yy}$, $D_{xy}$ as matrices on $\\mathbb{R}^{N_x N_y}$ consistent with the zero-extension rule.\n- Assemble $M_E$ and $M_B$ by stacking rows corresponding to $Q$ and $U$ at masked pixels.\n- Compute orthonormal bases $U_E$ and $U_B$ for $S$ and $T$ from the SVDs of $M_E$ and $M_B$ by retaining left singular vectors corresponding to singular values above a numerical tolerance.\n- Compute the cross-gram matrix $C = U_E^\\top U_B$ and determine its numerical rank.\n- Return the dimension of $T \\cap S^{\\perp}$ as an integer for each case.\n\nNumerical Tolerances:\n- For a matrix $A$ with singular values $\\sigma_1 \\ge \\sigma_2 \\ge \\dots$, define its numerical rank as the count of $\\sigma_k$ satisfying $\\sigma_k  \\max\\{ \\varepsilon_{\\text{abs}}, \\varepsilon_{\\text{rel}} \\,\\sigma_1 \\}$ with $\\varepsilon_{\\text{abs}} = 10^{-10}$ and $\\varepsilon_{\\text{rel}} = 10^{-9}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the five cases above. For example, an output of the form $[n_1,n_2,n_3,n_4,n_5]$ where each $n_k$ is the integer dimension of the pure-$B$ space for case $k$.",
            "solution": "The central task is to determine the dimension of the pure-$B$ mode subspace for a set of discretely sampled Cosmic Microwave Background (CMB) polarization maps. This subspace, denoted $T \\cap S^{\\perp}$, consists of all masked $B$-mode polarization patterns that are orthogonal to every possible masked $E$-mode pattern. Its dimension quantifies the number of unique $B$-mode signals that cannot be produced by the leakage of $E$-modes due to incomplete sky coverage, a phenomenon known as E-B mixing. The problem is thus a well-defined exercise in numerical linear algebra, predicated on the principles of CMB polarization analysis.\n\nThe solution proceeds through a sequence of logical and algorithmic steps, from the abstract definition of the problem to a concrete numerical result.\n\nFirst, we formalize the spaces and the quantity of interest. The set of all possible $E$-mode patterns on the masked grid forms a subspace $S = \\mathrm{range}(M_E) \\subset \\mathbb{R}^{2N_{\\text{mask}}}$, where $M_E$ is the linear operator mapping an $E$-mode potential $\\phi_E$ to the masked Stokes parameters $(Q_E, U_E)$. Similarly, the $B$-mode patterns form a subspace $T = \\mathrm{range}(M_B) \\subset \\mathbb{R}^{2N_{\\text{mask}}}$. We seek to compute $\\mathrm{dim}(T \\cap S^{\\perp})$.\n\nLet $U_E$ and $U_B$ be matrices whose columns form orthonormal bases for the subspaces $S$ and $T$, respectively. The number of columns in $U_E$ is $r_E = \\mathrm{dim}(S) = \\mathrm{rank}(M_E)$, and the number of columns in $U_B$ is $r_B = \\mathrm{dim}(T) = \\mathrm{rank}(M_B)$. Any vector $v \\in T$ can be expressed as a linear combination of the basis vectors of $T$: $v = U_B c$ for some coefficient vector $c \\in \\mathbb{R}^{r_B}$. For this vector $v$ to belong to the orthogonal complement of $S$, denoted $S^{\\perp}$, it must be orthogonal to all basis vectors of $S$. This condition is expressed as $U_E^\\top v = 0$. Substituting the expression for $v$, we obtain the condition on the coefficient vector $c$:\n$$\nU_E^\\top (U_B c) = (U_E^\\top U_B)c = 0\n$$\nLet $C = U_E^\\top U_B$ be the cross-gram matrix of inner products between the basis vectors of $S$ and $T$. The condition simplifies to $C c = 0$. This means that the coefficient vectors $c$ corresponding to modes in $T \\cap S^{\\perp}$ must lie in the null space (kernel) of $C$, i.e., $c \\in \\ker(C)$.\nSince the columns of $U_B$ are orthonormal, the mapping from $c$ to $U_B c$ is an isometry. Therefore, the dimension of the space of pure-$B$ modes is equal to the dimension of the null space of $C$:\n$$\n\\mathrm{dim}(T \\cap S^{\\perp}) = \\mathrm{dim}(\\ker(C))\n$$\nBy the rank-nullity theorem applied to the linear map represented by $C: \\mathbb{R}^{r_B} \\to \\mathbb{R}^{r_E}$, we have:\n$$\n\\mathrm{dim}(\\ker(C)) + \\mathrm{rank}(C) = \\mathrm{dim}(\\mathbb{R}^{r_B}) = r_B\n$$\nThus, the dimension of the pure-$B$ space is given by:\n$$\n\\mathrm{dim}(T \\cap S^{\\perp}) = r_B - \\mathrm{rank}(C) = \\mathrm{rank}(M_B) - \\mathrm{rank}(U_E^\\top U_B)\n$$\n\nThe algorithm to compute this dimension is as follows:\n1.  **Discretization and Operator Construction**: For a grid of size $N_x \\times N_y$, we vectorize any scalar field $f[i,j]$ into a vector in $\\mathbb{R}^{N_{\\text{pix}}}$ where $N_{\\text{pix}} = N_x N_y$. We use a row-major ordering, where the 1D index is $k = i \\cdot N_y + j$ for a pixel at $(i,j)$. The discrete differential operators $D_{xx}$, $D_{yy}$, and $D_{xy}$ are constructed as $N_{\\text{pix}} \\times N_{\\text{pix}}$ matrices. The definition of each operator, including the zero-extension boundary condition, determines the non-zero entries of its matrix representation. For example, the action of $D_{xx}$ on a pixel $(i,j)$ involves its neighbors $(i\\pm 1, j)$. This translates to setting entries in the $k$-th row of the matrix $D_{xx}$ at columns $k$ (for the $-2f[i,j]$ term) and $k \\pm N_y$ (for the $f[i \\pm 1, j]$ terms), with care taken at the boundaries where neighbors would be off-grid.\n\n2.  **Observation Matrix Assembly**: The linear maps from potentials to masked Stokes parameters, $M_E$ and $M_B$, are constructed. These are matrices of size $(2N_{\\text{mask}}) \\times N_{\\text{pix}}$. $M_E$ is formed by vertically stacking two blocks: the first block contains the rows of the operator $D_{xx} - D_{yy}$ corresponding to the $Q$ measurements at the $N_{\\text{mask}}$ masked pixels, and the second block contains the rows of $2D_{xy}$ for the $U$ measurements. $M_B$ is constructed analogously from the operators $-2D_{xy}$ and $D_{xx} - D_{yy}$.\n\n3.  **Orthonormal Basis Computation**: The orthonormal bases $U_E$ and $U_B$ for the ranges of $M_E$ and $M_B$ are found using the Singular Value Decomposition (SVD). For a matrix $M$, its SVD is $M = U\\Sigma V^\\top$. The columns of $U$ (the left singular vectors) corresponding to non-zero singular values in $\\Sigma$ form an orthonormal basis for $\\mathrm{range}(M)$.\n\n4.  **Numerical Rank**: In finite-precision arithmetic, we use a numerical criterion to decide if a singular value is effectively non-zero. The numerical rank of a matrix is the number of its singular values $\\sigma_k$ that satisfy $\\sigma_k  \\max\\{ \\varepsilon_{\\text{abs}}, \\varepsilon_{\\text{rel}} \\,\\sigma_1 \\}$, where $\\sigma_1$ is the largest singular value, $\\varepsilon_{\\text{abs}} = 10^{-10}$, and $\\varepsilon_{\\text{rel}} = 10^{-9}$. This rule is used to determine $r_E = \\mathrm{rank}(M_E)$, $r_B = \\mathrm{rank}(M_B)$, and finally $r_C = \\mathrm{rank}(C)$.\n\n5.  **Final Calculation**: Once the orthonormal bases $U_E$ (a $2N_{\\text{mask}} \\times r_E$ matrix) and $U_B$ (a $2N_{\\text{mask}} \\times r_B$ matrix) are determined, the cross-gram matrix $C = U_E^\\top U_B$ is computed. Its numerical rank, $r_C$, is found via SVD. The final answer for each test case is the integer $\\mathrm{dim}(T \\cap S^{\\perp}) = r_B - r_C$. This procedure is systematically applied to each specified grid geometry and mask.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the E/B mode separation problem for all specified test cases.\n    \"\"\"\n    \n    # Numerical tolerances for rank determination\n    eps_abs = 1e-10\n    eps_rel = 1e-9\n\n    test_cases = [\n        {'name': 'Case 1 (full square)', 'Nx': 8, 'Ny': 8, 'mask_type': 'full'},\n        {'name': 'Case 2 (thin rectangle)', 'Nx': 12, 'Ny': 4, 'mask_type': 'full'},\n        {'name': 'Case 3 (L-shape)', 'Nx': 10, 'Ny': 10, 'mask_type': 'L-shape'},\n        {'name': 'Case 4 (discrete disk)', 'Nx': 11, 'Ny': 11, 'mask_type': 'disk'},\n        {'name': 'Case 5 (tiny patch)', 'Nx': 3, 'Ny': 3, 'mask_type': 'full'},\n    ]\n\n    results = []\n\n    def get_numerical_rank(s, eps_abs, eps_rel):\n        \"\"\"Computes the numerical rank from a list of singular values.\"\"\"\n        if s.size == 0:\n            return 0\n        s_max = s[0]\n        # s_max can be 0 for a zero matrix.\n        if s_max  eps_abs: # Effectively zero matrix\n            return 0\n        tolerance = max(eps_abs, eps_rel * s_max)\n        return np.sum(s > tolerance)\n\n    def create_derivative_matrices(Nx, Ny):\n        \"\"\"Creates matrix representations of D_xx, D_yy, D_xy operators.\"\"\"\n        N_pix = Nx * Ny\n        D_xx = np.zeros((N_pix, N_pix), dtype=np.float64)\n        D_yy = np.zeros((N_pix, N_pix), dtype=np.float64)\n        D_xy = np.zeros((N_pix, N_pix), dtype=np.float64)\n\n        for i in range(Nx):\n            for j in range(Ny):\n                k = i * Ny + j\n                \n                # D_xx: f[i+1,j] - 2f[i,j] + f[i-1,j]\n                D_xx[k, k] = -2.0\n                if i > 0:\n                    D_xx[k, k - Ny] = 1.0\n                if i  Nx - 1:\n                    D_xx[k, k + Ny] = 1.0\n\n                # D_yy: f[i,j+1] - 2f[i,j] + f[i,j-1]\n                D_yy[k, k] = -2.0\n                if j > 0:\n                    D_yy[k, k - 1] = 1.0\n                if j  Ny - 1:\n                    D_yy[k, k + 1] = 1.0\n                    \n                # D_xy: 1/4 * (f[i+1,j+1] - f[i+1,j-1] - f[i-1,j+1] + f[i-1,j-1])\n                if i  Nx - 1 and j  Ny - 1:\n                    D_xy[k, k + Ny + 1] = 0.25\n                if i  Nx - 1 and j > 0:\n                    D_xy[k, k + Ny - 1] = -0.25\n                if i > 0 and j  Ny - 1:\n                    D_xy[k, k - Ny + 1] = -0.25\n                if i > 0 and j > 0:\n                    D_xy[k, k - Ny - 1] = 0.25\n                    \n        return D_xx, D_yy, D_xy\n\n    for case in test_cases:\n        Nx, Ny = case['Nx'], case['Ny']\n        \n        # Define mask for each case\n        if case['mask_type'] == 'full':\n            mask = np.ones((Nx, Ny), dtype=bool)\n        elif case['mask_type'] == 'L-shape':\n            mask = np.zeros((Nx, Ny), dtype=bool)\n            for i in range(Nx):\n                for j in range(Ny):\n                    if i = 4 or j = 4:\n                        mask[i, j] = True\n        elif case['mask_type'] == 'disk':\n            mask = np.zeros((Nx, Ny), dtype=bool)\n            cx, cy, r = 5.0, 5.0, 5.0\n            for i in range(Nx):\n                for j in range(Ny):\n                    if (i - cx)**2 + (j - cy)**2 = r**2:\n                        mask[i, j] = True\n        \n        N_pix = Nx * Ny\n        masked_indices = np.where(mask.flatten())[0]\n        N_mask = len(masked_indices)\n\n        if N_mask == 0:\n            results.append(0)\n            continue\n\n        D_xx, D_yy, D_xy = create_derivative_matrices(Nx, Ny)\n        \n        # Assemble E-mode and B-mode operators\n        L1 = D_xx - D_yy\n        L2 = 2 * D_xy\n\n        # Construct masked observation matrices M_E and M_B\n        Q_rows_E = L1[masked_indices, :]\n        U_rows_E = L2[masked_indices, :]\n        M_E = np.vstack([Q_rows_E, U_rows_E])\n\n        Q_rows_B = -L2[masked_indices, :]\n        U_rows_B = L1[masked_indices, :]\n        M_B = np.vstack([Q_rows_B, U_rows_B])\n\n        # Compute orthonormal basis for S = range(M_E) via SVD\n        U_svd_E, s_E, _ = np.linalg.svd(M_E, full_matrices=False)\n        rank_E = get_numerical_rank(s_E, eps_abs, eps_rel)\n        U_E = U_svd_E[:, :rank_E]\n        \n        # Compute orthonormal basis for T = range(M_B) via SVD\n        U_svd_B, s_B, _ = np.linalg.svd(M_B, full_matrices=False)\n        rank_B = get_numerical_rank(s_B, eps_abs, eps_rel)\n        U_B = U_svd_B[:, :rank_B]\n        \n        # Compute rank of cross-gram matrix C = U_E^T @ U_B\n        if rank_E == 0 or rank_B == 0:\n            rank_C = 0\n        else:\n            C = U_E.T @ U_B\n            s_C = np.linalg.svd(C, compute_uv=False)\n            rank_C = get_numerical_rank(s_C, eps_abs, eps_rel)\n\n        # Dimension of pure-B space is rank(M_B) - rank(C)\n        dim_pure_B = rank_B - rank_C\n        results.append(dim_pure_B)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In robust scientific computing, verifying that a code produces the \"right\" answer is as important as verifying that it doesn't produce the \"wrong\" one. The standard cosmological model predicts that primordial scalar perturbations generate only E-mode polarization, providing a powerful \"null test\": a correct code should produce zero B-modes from a scalar-only input. This practice demonstrates how to design such a test by introducing a hypothetical anisotropic scattering kernel that deliberately breaks the underlying physical symmetries of Thomson scattering . By confirming that your code generates spurious B-modes only when this artificial anisotropy is active, you can build confidence in your implementation and gain deeper insight into the physical origins of E/B polarization.",
            "id": "3478286",
            "problem": "Consider a flat-sky model for the Cosmic Microwave Background (CMB) polarization in numerical cosmology, focusing on line-of-sight (LOS) integration. In the standard isotropic Thomson scattering, scalar perturbations generate only Electric-type (E) polarization modes and no Magnetic-type (B) modes. To diagnose numerical code correctness, we will introduce a toy anisotropic scattering kernel with a preferred direction that deliberately breaks azimuthal symmetry and can generate spurious B-modes through LOS integration.\n\nYou must implement a complete program that constructs a baseline pure E-mode polarization pattern from a single plane-wave scalar perturbation on a square angular patch, and then applies a LOS-integrated anisotropic kernel that induces a uniform polarization rotation depending on the misalignment between the plane-wave direction and the preferred direction. From this rotated pattern, you must compute the E and B modes and quantify the spurious B-mode generation.\n\nThe program must adhere to the following specifications:\n\n- Use the flat-sky approximation on a square angular patch of side length $L$ in radians discretized on an $N \\times N$ grid. Angles must be in radians.\n- Start from a single-mode scalar perturbation that generates a baseline pure E-mode polarization pattern. Construct the baseline Stokes parameters $Q(\\boldsymbol{\\theta})$ and $U(\\boldsymbol{\\theta})$ maps from a Fourier-space E-mode field with nonzero amplitude only at a single wavevector $\\boldsymbol{k}_0$ and its negative $-\\boldsymbol{k}_0$ so that the real-space maps are real. The resulting baseline must be E-only (i.e., B-mode vanishes up to numerical precision).\n- Introduce a toy anisotropic scattering kernel that produces a uniform Stokes rotation by an angle $\\alpha$ across the map, defined by an LOS integral of a normalized visibility function with a preferred direction dependence. The visibility function along LOS comoving distance $0 \\le \\chi \\le 1$ is a normalized Gaussian\n$$\ng(\\chi) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\left(-\\frac{(\\chi-\\chi_\\star)^2}{2\\sigma^2}\\right),\n$$\nwith center $\\chi_\\star = 0.5$ and width $\\sigma  0$. The anisotropy parameter $\\varepsilon$ controls the kernel strength, and the preferred direction makes an angle $\\varphi_p$ with respect to the $x$-axis. Let the plane-wave mode direction be $\\varphi_k$. The uniform rotation angle is\n$$\n\\alpha = \\varepsilon\\,\\left(\\int_{0}^{1} g(\\chi)\\,d\\chi\\right)\\,\\sin\\left(2(\\varphi_k-\\varphi_p)\\right).\n$$\n- After computing $\\alpha$ via numerical LOS integration (not by analytic evaluation), apply the uniform polarization rotation to the baseline $Q$ and $U$ maps to obtain rotated maps $Q'(\\boldsymbol{\\theta})$ and $U'(\\boldsymbol{\\theta})$.\n- Compute the Fourier-space E and B modes from the rotated maps using the standard flat-sky E/B decomposition from the Stokes parameters $Q$ and $U$ (do not hard-code target results; implement the correct transform definitions implied by the flat-sky relations between Fourier-space Stokes parameters and the E/B scalar fields).\n- Compute the total Fourier-space power in E and B,\n$$\nP_E = \\sum_{\\boldsymbol{k}} \\left|E(\\boldsymbol{k})\\right|^2,\\quad P_B = \\sum_{\\boldsymbol{k}} \\left|B(\\boldsymbol{k})\\right|^2,\n$$\nand report the spurious B-mode power fraction\n$$\nR = \\frac{P_B}{P_E}.\n$$\n\nYou must use the following fixed numerical setup unless specified otherwise by the test suite:\n- Patch side length $L = 1.0$ (radians).\n- Grid size $N = 64$.\n- Baseline E-mode amplitude $A = 1.0$ (dimensionless).\n- Single nonzero Fourier mode indices $(k_{x,\\text{ind}}, k_{y,\\text{ind}}) = (4, 0)$, giving $\\varphi_k = 0$.\n\nImplement a LOS numerical integration over $\\chi \\in [0,1]$ using a sufficiently fine one-dimensional grid to evaluate $\\int_0^1 g(\\chi)\\,d\\chi$.\n\nTest Suite:\nFor each test case, compute the spurious B-mode fraction $R$ as a float. Use the following parameter sets $(\\varepsilon, \\varphi_p, \\sigma)$:\n- Case $1$: $(0.0, \\pi/4, 0.05)$ — isotropic baseline, expected to yield $R$ near $0$.\n- Case $2$: $(0.05, \\pi/4, 0.05)$ — small anisotropy misaligned by $45^\\circ$.\n- Case $3$: $(0.2, \\pi/4, 0.05)$ — stronger anisotropy misaligned by $45^\\circ$.\n- Case $4$: $(0.2, 0.0, 0.05)$ — preferred direction parallel to the mode direction, symmetry should suppress rotation and yield $R$ near $0$.\n- Case $5$: $(0.2, \\pi/8, 10^{-3})$ — narrow visibility to test LOS integration stability with a nontrivial misalignment.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is the computed spurious B-mode fraction $R$ for the corresponding test case, expressed as a float (dimensionless). No other text should be printed.",
            "solution": "We begin from the physical basis that in isotropic Thomson scattering, scalar perturbations produce polarization patterns with vanishing Magnetic-type (B) modes due to parity and azimuthal symmetry, while Electric-type (E) modes are nonzero. The Stokes parameters $Q$ and $U$ describe linear polarization on the sky. On the flat sky, it is standard to decompose the polarization into scalar E and B fields in Fourier space via linear combinations of the Fourier transforms $\\tilde{Q}(\\boldsymbol{k})$ and $\\tilde{U}(\\boldsymbol{k})$ with angular dependence on the wavevector direction $\\varphi_{\\boldsymbol{k}}$. The algorithmic goal is to construct a controlled baseline pure E-mode map and then apply a toy anisotropic kernel that induces a uniform rotation of the Stokes field, which mixes E into B. This provides a diagnostic: isotropic cases yield $B \\approx 0$, while anisotropy yields $B \\neq 0$ in proportion to the control parameters.\n\nStep-by-step derivation and algorithmic design:\n\n1. Flat-sky setup and Fourier conventions:\n   - Consider a square angular patch of side length $L$ in radians, discretized on an $N \\times N$ grid. Denote real-space angular coordinates by $\\boldsymbol{\\theta} = (\\theta_x, \\theta_y)$ and Fourier-space wavevectors by $\\boldsymbol{k} = (k_x, k_y)$ with angle $\\varphi_{\\boldsymbol{k}} = \\arctan2(k_y, k_x)$.\n   - Use Discrete Fourier Transforms to convert between real-space maps $Q(\\boldsymbol{\\theta}), U(\\boldsymbol{\\theta})$ and their Fourier transforms $\\tilde{Q}(\\boldsymbol{k}), \\tilde{U}(\\boldsymbol{k})$. For a real map, Fourier modes must satisfy Hermitian symmetry, i.e., $\\tilde{F}(-\\boldsymbol{k}) = \\tilde{F}(\\boldsymbol{k})^\\ast$ for any field $\\tilde{F}$.\n\n2. Construct a baseline pure E-mode field:\n   - Choose a single nonzero Fourier mode at indices $(k_{x,\\text{ind}}, k_{y,\\text{ind}}) = (4, 0)$ and its conjugate counterpart at $(-4, 0)$ to make real maps. Assign an E-mode amplitude $A  0$ distributed symmetrically so that the sum of the pair yields a cosine in real space.\n   - For a pure E-mode in Fourier space, the Stokes parameters at each $\\boldsymbol{k}$ are given by\n     $$\n     \\tilde{Q}(\\boldsymbol{k}) = \\tilde{E}(\\boldsymbol{k}) \\cos\\left(2\\varphi_{\\boldsymbol{k}}\\right), \\quad\n     \\tilde{U}(\\boldsymbol{k}) = \\tilde{E}(\\boldsymbol{k}) \\sin\\left(2\\varphi_{\\boldsymbol{k}}\\right),\n     $$\n     with $\\tilde{B}(\\boldsymbol{k}) = 0$. By constructing $\\tilde{E}(\\boldsymbol{k})$ only at $\\pm \\boldsymbol{k}_0$ and zero elsewhere, inverse transforming yields real-space $Q(\\boldsymbol{\\theta})$ and $U(\\boldsymbol{\\theta})$ maps with vanishing B when decomposed back to E/B, up to numerical precision.\n\n3. Define the toy anisotropic scattering kernel and LOS integral:\n   - The anisotropic kernel introduces a preferred direction at angle $\\varphi_p$ and produces a uniform rotation of the polarization by angle $\\alpha$ derived from an LOS integral over a normalized Gaussian visibility function:\n     $$\n     g(\\chi) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\left(-\\frac{(\\chi-\\chi_\\star)^2}{2\\sigma^2}\\right), \\quad \\chi_\\star = 0.5,\\quad \\sigma  0,\\quad 0 \\le \\chi \\le 1.\n     $$\n     The kernel strength is controlled by $\\varepsilon$, and the relative misalignment between the plane-wave direction and the preferred direction is $\\Delta = \\varphi_k - \\varphi_p$, where $\\varphi_k$ is the angle of the nonzero mode $\\boldsymbol{k}_0$.\n   - The rotation angle is modeled as\n     $$\n     \\alpha = \\varepsilon \\left(\\int_{0}^{1} g(\\chi)\\,d\\chi\\right) \\sin(2\\Delta),\n     $$\n     which vanishes for $\\Delta = 0$ or $\\Delta = \\pi/2$, capturing symmetry cases where the anisotropy does not generate a net rotation. The integral must be computed numerically using a sufficiently fine grid to ensure stability.\n\n4. Polarization rotation and E/B mixing:\n   - Under a rotation of the polarization reference frame by angle $\\alpha$, the Stokes parameters transform as\n     $$\n     Q'(\\boldsymbol{\\theta}) = Q(\\boldsymbol{\\theta})\\cos(2\\alpha) - U(\\boldsymbol{\\theta})\\sin(2\\alpha), \\quad\n     U'(\\boldsymbol{\\theta}) = Q(\\boldsymbol{\\theta})\\sin(2\\alpha) + U(\\boldsymbol{\\theta})\\cos(2\\alpha).\n     $$\n     In Fourier space, the flat-sky E/B decomposition relates $(\\tilde{Q}, \\tilde{U})$ to $(\\tilde{E}, \\tilde{B})$ via angular factors depending on $\\varphi_{\\boldsymbol{k}}$. Implement these standard relations to compute $\\tilde{E}(\\boldsymbol{k})$ and $\\tilde{B}(\\boldsymbol{k})$ from $\\tilde{Q}'(\\boldsymbol{k})$ and $\\tilde{U}'(\\boldsymbol{k})$.\n   - Starting from a pure E-mode with $\\tilde{B} = 0$, a uniform rotation by $\\alpha$ mixes E into B. One can show that, mode by mode,\n     $$\n     \\tilde{E}'(\\boldsymbol{k}) = \\tilde{E}(\\boldsymbol{k})\\cos(2\\alpha),\\quad\n     \\tilde{B}'(\\boldsymbol{k}) = -\\tilde{E}(\\boldsymbol{k})\\sin(2\\alpha),\n     $$\n     and thus for a single mode the power ratio is\n     $$\n     R = \\frac{P_B}{P_E} = \\frac{\\sum_{\\boldsymbol{k}}|\\tilde{B}'(\\boldsymbol{k})|^2}{\\sum_{\\boldsymbol{k}}|\\tilde{E}'(\\boldsymbol{k})|^2} = \\tan^2(2\\alpha).\n     $$\n     In the numerical scheme using the discrete transform and summation over all modes, numerical precision and finite-grid effects may introduce small deviations, but the qualitative scaling remains.\n\n5. Numerical implementation details:\n   - Generate the Fourier-space grid wavevectors from the discrete frequencies $\\left(\\frac{2\\pi n_x}{L}, \\frac{2\\pi n_y}{L}\\right)$ using $n_x, n_y \\in \\mathbb{Z}$ from the $N$-point Fast Fourier Transform (FFT) frequency conventions.\n   - Build $\\tilde{E}(\\boldsymbol{k})$ with nonzero entries only at $(k_{x,\\text{ind}}, k_{y,\\text{ind}})$ and its Hermitian counterpart, ensuring $\\tilde{Q}$ and $\\tilde{U}$ inherit Hermitian symmetry so that the inverse FFT yields real $Q$ and $U$.\n   - Compute the LOS integral $\\int_0^1 g(\\chi)\\,d\\chi$ numerically using Simpson’s rule on a finely sampled $\\chi$ grid; evaluate $\\alpha$; rotate $Q$ and $U$; transform back to Fourier space; compute $\\tilde{E}$ and $\\tilde{B}$; then compute $P_E$ and $P_B$ and finally $R$.\n\n6. Test suite coverage and boundary cases:\n   - Case $1$ validates the isotropic baseline ($\\varepsilon = 0$), which should yield $R \\approx 0$.\n   - Cases $2$ and $3$ explore increasing anisotropy with $\\varphi_p = \\pi/4$, yielding nonzero $R$ that grows with $\\varepsilon$.\n   - Case $4$ sets $\\varphi_p = 0$, parallel to $\\varphi_k = 0$, so $\\Delta = 0$ and the symmetry suppresses rotation: $R \\approx 0$ despite nonzero $\\varepsilon$.\n   - Case $5$ uses a very narrow visibility ($\\sigma = 10^{-3}$) and $\\varphi_p = \\pi/8$ to test LOS integration stability and nontrivial misalignment.\n\nThe program must output a single line with a list of the five computed $R$ values in the exact format $[r_1,r_2,r_3,r_4,r_5]$ with no additional text.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef build_pure_E_qu(N, L, amplitude, kx_ind, ky_ind):\n    \"\"\"\n    Construct baseline pure E-mode Stokes Q and U maps on an NxN grid with side length L (radians),\n    using a single Fourier mode at indices (kx_ind, ky_ind) and its Hermitian counterpart.\n    \"\"\"\n    # Fourier-space wave numbers\n    kx = (2.0 * np.pi) * np.fft.fftfreq(N, d=L / N)\n    ky = (2.0 * np.pi) * np.fft.fftfreq(N, d=L / N)\n    KX, KY = np.meshgrid(kx, ky, indexing='xy')\n    # Angle of each wavevector\n    phi = np.arctan2(KY, KX)\n    # Handle k=0 angle gracefully\n    phi[np.isnan(phi)] = 0.0\n\n    # Initialize Fourier-space E field and ensure Hermitian symmetry\n    E_k = np.zeros((N, N), dtype=np.complex128)\n\n    # Positive index\n    pos = (ky_ind % N, kx_ind % N)\n    # Negative (Hermitian counterpart) index\n    neg = ((-ky_ind) % N, (-kx_ind) % N)\n\n    if pos == neg:\n        # If the mode is its own counterpart (only possible if both indices are 0, which we avoid),\n        # assign full amplitude to avoid double-counting.\n        E_k[pos] = amplitude\n    else:\n        # Split amplitude equally to produce a real cosine in real space\n        E_k[pos] = amplitude / 2.0\n        E_k[neg] = amplitude / 2.0\n\n    # Build Q_k and U_k from E_k using flat-sky relations for a pure E-mode\n    Q_k = E_k * np.cos(2.0 * phi)\n    U_k = E_k * np.sin(2.0 * phi)\n\n    # Inverse FFT to get real-space maps\n    Q = np.fft.ifft2(Q_k).real\n    U = np.fft.ifft2(U_k).real\n\n    return Q, U, KX, KY, phi\n\ndef rotate_stokes(Q, U, alpha):\n    \"\"\"\n    Apply uniform polarization rotation by angle alpha (radians) to Stokes Q, U.\n    Rotation acts as (Q', U') = R(2 alpha) (Q, U).\n    \"\"\"\n    ca = np.cos(2.0 * alpha)\n    sa = np.sin(2.0 * alpha)\n    Qp = Q * ca - U * sa\n    Up = Q * sa + U * ca\n    return Qp, Up\n\ndef eb_from_qu(Q, U, KX, KY):\n    \"\"\"\n    Compute Fourier-space E and B modes from Stokes Q and U maps via flat-sky relations.\n    \"\"\"\n    # Forward FFTs\n    Q_k = np.fft.fft2(Q)\n    U_k = np.fft.fft2(U)\n\n    # Wavevector angle\n    phi = np.arctan2(KY, KX)\n    phi[np.isnan(phi)] = 0.0\n\n    # E(k) and B(k) in Fourier space\n    E_k = Q_k * np.cos(2.0 * phi) + U_k * np.sin(2.0 * phi)\n    B_k = -Q_k * np.sin(2.0 * phi) + U_k * np.cos(2.0 * phi)\n    return E_k, B_k\n\ndef visibility_integral(sigma, chi_star=0.5, n_steps=4097):\n    \"\"\"\n    Numerically evaluate the integral of a normalized Gaussian visibility g(chi)\n    over chi in [0, 1] using Simpson's rule.\n    g(chi) = (1 / (sqrt(2*pi)*sigma)) * exp( - (chi - chi_star)^2 / (2*sigma^2) )\n    \"\"\"\n    chi = np.linspace(0.0, 1.0, n_steps)\n    g = (1.0 / (np.sqrt(2.0 * np.pi) * sigma)) * np.exp(-0.5 * ((chi - chi_star) / sigma) ** 2)\n    integral = simpson(g, chi)\n    return integral\n\ndef spurious_B_fraction(N, L, amplitude, kx_ind, ky_ind, epsilon, phi_p, sigma):\n    \"\"\"\n    Compute the spurious B-mode power fraction R = P_B / P_E for given anisotropy parameters.\n    \"\"\"\n    # Build baseline pure E-mode Stokes maps\n    Q, U, KX, KY, phi_grid = build_pure_E_qu(N, L, amplitude, kx_ind, ky_ind)\n\n    # Determine the angle of the single mode k0\n    kx0 = (2.0 * np.pi) * (kx_ind / L)\n    ky0 = (2.0 * np.pi) * (ky_ind / L)\n    phi_k = np.arctan2(ky0, kx0)\n\n    # LOS integral (normalized Gaussian visibility over [0,1])\n    G = visibility_integral(sigma=sigma, chi_star=0.5, n_steps=4097)\n\n    # Rotation angle alpha from anisotropic kernel\n    delta = phi_k - phi_p\n    alpha = epsilon * G * np.sin(2.0 * delta)\n\n    # Rotate Stokes parameters\n    Qp, Up = rotate_stokes(Q, U, alpha)\n\n    # Compute E and B modes after rotation\n    E_k, B_k = eb_from_qu(Qp, Up, KX, KY)\n\n    # Compute power sums (exclude k=0 if desired; here we include all modes uniformly)\n    P_E = np.sum(np.abs(E_k) ** 2)\n    P_B = np.sum(np.abs(B_k) ** 2)\n\n    # Avoid divide-by-zero: if P_E is tiny due to numerical issues, handle gracefully\n    if P_E == 0.0:\n        return 0.0\n    R = (P_B / P_E).real  # ratio is real-valued\n    return float(R)\n\ndef solve():\n    # Fixed grid and baseline parameters per problem statement\n    N = 64\n    L = 1.0  # radians\n    amplitude = 1.0\n    kx_ind, ky_ind = 4, 0  # single nonzero mode --> phi_k = 0\n\n    # Define the test cases (epsilon, phi_p, sigma)\n    test_cases = [\n        (0.0, np.pi / 4.0, 0.05),         # Case 1\n        (0.05, np.pi / 4.0, 0.05),        # Case 2\n        (0.2, np.pi / 4.0, 0.05),         # Case 3\n        (0.2, 0.0, 0.05),                 # Case 4\n        (0.2, np.pi / 8.0, 1e-3),         # Case 5\n    ]\n\n    results = []\n    for epsilon, phi_p, sigma in test_cases:\n        r = spurious_B_fraction(N, L, amplitude, kx_ind, ky_ind, epsilon, phi_p, sigma)\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}