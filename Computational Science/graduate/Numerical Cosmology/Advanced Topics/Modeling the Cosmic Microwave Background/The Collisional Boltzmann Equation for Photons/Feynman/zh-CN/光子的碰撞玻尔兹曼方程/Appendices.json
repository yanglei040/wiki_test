{
    "hands_on_practices": [
        {
            "introduction": "在深入研究完整的光子玻尔兹曼方程之前，我们首先通过一个简化的模型来掌握核心的数值方法。这个练习  采用了一个“弛豫时间”碰撞算符，它能有效地模拟光子各向异性如何随时间衰减。通过使用简单的向前欧拉法对该模型进行数值演化，并将其结果与精确的解析解进行比较，你将学习到验证数值代码正确性的基本工作流程，这是所有计算物理学的基础。",
            "id": "3493968",
            "problem": "考虑一个空间均匀介质中光子角分布的碰撞玻尔兹曼方程。设光子分布由 $f(\\mu,t)$ 表示，其中 $\\mu \\in [-1,1]$ 是光子传播方向与一个固定轴之间夹角的余弦，而 $t$ 是一个无量纲时间。假设光子散射由一个具有时变速率 $\\nu(t) \\ge 0$ 的各向同性弛豫时间碰撞算子表示，因此其演化由下式给出：\n$$\n\\frac{\\partial f(\\mu,t)}{\\partial t} = \\mathcal{C}[f](\\mu,t), \\quad \\mathcal{C}[f](\\mu,t) = -\\nu(t)\\left(f(\\mu,t) - \\langle f \\rangle(t)\\right),\n$$\n其中角平均 $\\langle f \\rangle(t)$ 定义为在 $\\mu$ 上的均匀角平均值，\n$$\n\\langle f \\rangle(t) = \\frac{1}{2}\\int_{-1}^{1} f(\\mu,t)\\, d\\mu.\n$$\n这个各向同性弛豫算子是紧耦合机制下 Thomson 散射的一个科学上有效的玩具模型，它能保持角平均并阻尼各向异性，在数值宇宙学中被广泛用于数值方案的验证。\n\n您的任务是使用显式前向欧拉时间积分器在一个离散角网格上对 $f(\\mu,t)$ 进行数值演化，并使用此玩具模型中的精确解来验证演化过程。请遵循以下要求：\n\n- 将 $[-1,1]$ 上的 $\\mu$ 均匀离散化为 $N$ 个区间。将这些网格点记为 $\\{\\mu_i\\}_{i=1}^N$。\n- 使用一个无量纲各向异性分布进行初始化：\n$$\nf(\\mu,0) = A + \\alpha\\, \\mu + \\beta\\, P_2(\\mu),\n$$\n其中 $A$、$\\alpha$ 和 $\\beta$ 是实常数，而 $P_2(\\mu) = \\frac{1}{2}\\left(3\\mu^2 - 1\\right)$ 是二阶勒让德多项式。\n- 使用下式对离散分布 $f_i^n \\approx f(\\mu_i,t_n)$（其中 $t_n = n\\, \\Delta t$）进行演化：\n$$\nf_i^{n+1} = f_i^n + \\Delta t\\left(-\\nu(t_n)\\left[f_i^n - \\overline{f}^n\\right]\\right),\n$$\n其中 $\\overline{f}^n = \\frac{1}{N}\\sum_{j=1}^{N} f_j^n$ 是离散角值的算术平均值。这种选择能在更新过程中精确地保持离散平均值。\n- 为了验证，此碰撞算子的精确连续时间解具有守恒的平均值，且其与平均值的偏差呈指数衰减，由积分速率控制。具体来说，如果 $\\delta f(\\mu,t) = f(\\mu,t) - \\langle f \\rangle(t)$ 且 $\\mathcal{I}(t) = \\int_0^t \\nu(s)\\, ds$，那么\n$$\n\\delta f(\\mu,t) = \\delta f(\\mu,0)\\, e^{-\\mathcal{I}(t)}, \\quad f(\\mu,t) = \\langle f \\rangle(0) + \\delta f(\\mu,0)\\, e^{-\\mathcal{I}(t)}.\n$$\n- 在您的实现中，通过将 $\\langle f \\rangle(0)$ 替换为 $t=0$ 时的离散算术平均值，并对每个给定的 $\\nu(t)$ 规范使用 $\\mathcal{I}(T)$ 的相应闭式形式，来计算离散精确解。\n\n计算下面每个测试用例在最终时间 $T$ 的数值解，并报告数值解与离散精确解在整个角网格上的最大绝对误差，即：\n$$\n\\epsilon_{\\max} = \\max_{i \\in \\{1,\\ldots,N\\}} \\left| f_i^{\\mathrm{num}}(T) - f_i^{\\mathrm{exact}}(T) \\right|.\n$$\n所有量均为无量纲；不需要物理单位。\n\n请用 Python 语言实现该程序，严格遵守最终答案规范中描述的执行环境。您的程序必须硬编码以下参数值测试套件，并生成单行输出，其中包含所有测试用例的误差，形式为方括号括起来的逗号分隔列表。\n\n测试套件：\n1. 案例 1（常规验证，平滑衰减）：$N=200$，$\\Delta t=10^{-3}$，$T=1.0$，$A=1.0$，$\\alpha=0.07$，$\\beta=-0.11$，$\\nu(t)=1.3$ 为常数。\n2. 案例 2（分段速率，散射开始）：$N=50$，$\\Delta t=10^{-2}$，$T=1.0$，$A=1.0$，$\\alpha=0.2$，$\\beta=0.05$，当 $0 \\le t < t_0$ 时 $\\nu(t)=0$，当 $t \\ge t_0$ 时 $\\nu(t)=0.8$，其中 $t_0=0.6$。\n3. 案例 3（衰减光深速率）：$N=120$，$\\Delta t=5\\times 10^{-3}$，$T=2.0$，$A=1.0$，$\\alpha=-0.15$，$\\beta=0.25$，$\\nu(t)=\\nu_0 e^{-\\lambda t}$，其中 $\\nu_0=1.5$ 且 $\\lambda=1.0$。\n4. 案例 4（接近显式欧拉法的稳定性边界）：$N=80$，$\\Delta t=1.9$，$T=3.8$，$A=1.0$，$\\alpha=0.5$，$\\beta=-0.4$，$\\nu(t)=1.0$ 为常数。\n5. 案例 5（无碰撞极限）：$N=30$，$\\Delta t=2\\times 10^{-2}$，$T=0.4$，$A=1.0$，$\\alpha=-0.3$，$\\beta=0.1$，$\\nu(t)=0$ 为常数。\n\n您的程序应生成单行输出，其中包含结果，形式为方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是相应测试用例的 $\\epsilon_{\\max}$ 值，表示为浮点数。",
            "solution": "本问题的解决方案在于实现一个显式前向欧拉时间积分器来数值求解给定的弛豫时间玻尔兹曼方程。首先，根据初始条件 $f(\\mu,0) = A + \\alpha\\mu + \\beta P_2(\\mu)$ 在离散的角度网格上设置光子分布的初始状态。接着，通过一个时间循环来演化该分布。在每一步中，计算当前分布的角平均值 $\\overline{f}^n$，然后应用前向欧拉更新规则：$f_i^{n+1} = f_i^n - \\Delta t \\cdot \\nu(t_n) (f_i^n - \\overline{f}^n)$。演化完成后，根据问题中提供的解析解公式 $f(\\mu,t) = \\langle f \\rangle(0) + \\delta f(\\mu,0) e^{-\\mathcal{I}(t)}$ 计算在最终时间 $T$ 的精确解。这需要计算初始平均值 $\\langle f \\rangle(0)$ 和每个测试用例对应的积分速率 $\\mathcal{I}(T)$。最后，通过计算数值解与精确解在所有网格点上的最大绝对差来评估数值方法的误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the collisional Boltzmann equation for the given test cases and\n    computes the maximum absolute error against the exact solution.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: general validation, smooth decay\n        {\n            'N': 200, 'dt': 1e-3, 'T': 1.0, 'A': 1.0, 'alpha': 0.07, 'beta': -0.11,\n            'nu': lambda t: 1.3,\n            'I_T': 1.3 * 1.0\n        },\n        # Case 2: piecewise rate, onset of scattering\n        {\n            'N': 50, 'dt': 1e-2, 'T': 1.0, 'A': 1.0, 'alpha': 0.2, 'beta': 0.05,\n            'nu': lambda t, t0=0.6: 0.8 if t >= t0 else 0.0,\n            'I_T': 0.8 * (1.0 - 0.6)\n        },\n        # Case 3: decaying optical depth rate\n        {\n            'N': 120, 'dt': 5e-3, 'T': 2.0, 'A': 1.0, 'alpha': -0.15, 'beta': 0.25,\n            'nu': lambda t, nu0=1.5, lam=1.0: nu0 * np.exp(-lam * t),\n            'I_T': (1.5 / 1.0) * (1.0 - np.exp(-1.0 * 2.0))\n        },\n        # Case 4: near stability boundary for explicit Euler\n        {\n            'N': 80, 'dt': 1.9, 'T': 3.8, 'A': 1.0, 'alpha': 0.5, 'beta': -0.4,\n            'nu': lambda t: 1.0,\n            'I_T': 1.0 * 3.8\n        },\n        # Case 5: collisionless limit\n        {\n            'N': 30, 'dt': 2e-2, 'T': 0.4, 'A': 1.0, 'alpha': -0.3, 'beta': 0.1,\n            'nu': lambda t: 0.0,\n            'I_T': 0.0\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Unpack parameters\n        N, dt, T = case['N'], case['dt'], case['T']\n        A, alpha, beta = case['A'], case['alpha'], case['beta']\n        nu, I_T = case['nu'], case['I_T']\n\n        # 1. Setup grid and initial condition\n        mu_grid = np.linspace(-1.0, 1.0, N)\n        P2_mu = 0.5 * (3 * mu_grid**2 - 1)\n        f_initial = A + alpha * mu_grid + beta * P2_mu\n        \n        # 2. Numerical evolution using Forward Euler\n        f_num = f_initial.copy()\n        \n        # Determine the number of time steps\n        num_steps = int(round(T / dt))\n        \n        for n in range(num_steps):\n            t_n = n * dt\n            \n            # Calculate discrete mean\n            f_bar_n = np.mean(f_num)\n            \n            # Get scattering rate at current time\n            nu_t = nu(t_n)\n            \n            # Apply forward Euler update\n            f_num = f_num - dt * nu_t * (f_num - f_bar_n)\n            \n        # f_num now holds the numerical solution at time T\n        \n        # 3. Compute the exact solution\n        \n        # Initial discrete mean\n        f_bar_0 = np.mean(f_initial)\n        \n        # Initial deviation from the mean\n        delta_f_0 = f_initial - f_bar_0\n        \n        # Exact solution at time T\n        f_exact = f_bar_0 + delta_f_0 * np.exp(-I_T)\n        \n        # 4. Calculate maximum absolute error\n        max_error = np.max(np.abs(f_num - f_exact))\n        results.append(max_error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个数值方案的可靠性不仅取决于它能否复现解析解，还取决于它是否能遵守底层的物理守恒律。本练习  引导你分析一个更具结构性的模型碰撞算符，并从解析上推导它对光子分布的零阶和一阶角动量的影响。然后，你将使用高精度的高斯-勒让德求积法来数值验证你的推导，从而深刻理解如何确保数值实现能够精确地保持或以可预测的方式改变物理量。",
            "id": "3494037",
            "problem": "考虑光子在均匀介质中经历固定频率的弹性角散射的碰撞玻尔兹曼方程，其中没有频率变化，也没有空间梯度。仅关注角度依赖性。设比强度为标量场 $I(\\mu)$，其中 $\\mu \\in [-1,1]$ 表示与固定轴夹角的余弦。碰撞算符作为一个带有相函数核的角度重分布。在本问题中，您将通过数值积分验证零阶角矩的守恒性，并为一个参数化的相函数族推导并检验一阶角矩。\n\n从碰撞玻尔兹曼方程的定义和汤姆孙极限下弹性散射的性质出发，考虑以下模型碰撞算符：\n$$\n\\mathcal{C}[I](\\mu) \\equiv - I(\\mu) + \\int_{-1}^{1} K(\\mu,\\mu')\\, I(\\mu')\\, d\\mu',\n$$\n其中核 $K(\\mu,\\mu')$ 是一个归一化的弹性散射相函数。对于本练习，采用以下函数族：\n$$\nK(\\mu,\\mu') = \\frac{s}{2}\\,\\bigl(1 + c\\,\\mu\\,\\mu'\\bigr),\n$$\n其中参数 $s \\in \\mathbb{R}$ 和 $c \\in \\mathbb{R}$ 满足 $c \\in [-1,1]$，以确保当 $s \\ge 0$ 时核的非负性。参数 $s$ 缩放核的大小，对于一个正确归一化的散射核，$s$ 等于 $1$。参数 $c$ 控制各向异性程度；$c = 0$ 对应于各向同性散射。\n\n定义任意函数 $g(\\mu)$ 的前两个角矩为：\n$$\nJ[g] \\equiv \\int_{-1}^{1} g(\\mu)\\, d\\mu, \\quad S[g] \\equiv \\int_{-1}^{1} \\mu\\, g(\\mu)\\, d\\mu.\n$$\n\n你的任务是：\n- 从弹性角散射的基本结构和 $K(\\mu,\\mu')$ 的定义出发，推导 $\\mathcal{C}[I](\\mu)$ 的零阶和一阶角矩关于 $J[I]$、$S[I]$、$s$ 和 $c$ 的表达式。\n- 设计一个使用高斯-勒让德节点的数值积分方法来近似 $[-1,1]$ 上的积分，其中 $N$ 为正整数。使用足够大的 $N$，以使积分误差相对于指定的容差可以忽略不计。\n- 实现一个程序，对于下述每个测试用例，该程序构造 $I(\\mu)$，使用给定的 $K(\\mu,\\mu')$ 计算 $\\mathcal{C}[I](\\mu)$，计算 $J[\\mathcal{C}[I]]$ 和 $S[\\mathcal{C}[I]]$ 的离散近似值，并检验：\n  1. 零阶矩是否在容差 $\\epsilon$ 内满足守恒性，当 $s=1$ 时解释为 $|J[\\mathcal{C}[I]]| \\le \\epsilon \\max(1,|J[I]|)$，而当 $s \\ne 1$ 时不一定如此。\n  2. $\\mathcal{C}[I]$ 的一阶矩是否在容差 $\\epsilon$ 内与您推导的解析表达式相匹配，解释为 $|S[\\mathcal{C}[I]] - S_{\\mathrm{pred}}| \\le \\epsilon \\max(1,|S[I]|)$，其中 $S_{\\mathrm{pred}}$ 是您推导的一阶矩预测值。\n\n使用以下测试套件，它涵盖了一个通用情况、一个中等各向异性情况以及一个未正确归一化的核的边界情况：\n- 测试用例 1（各向同性核，混合多极矩）：\n  - 参数：$s = 1$, $c = 0$。\n  - 强度：$I(\\mu) = 1 + 0.5\\,\\mu - 0.3\\,P_2(\\mu)$，其中 $P_2(\\mu) = (3\\mu^2 - 1)/2$ 是2阶勒让德多项式。\n- 测试用例 2（各向异性核，平滑的各向异性强度）：\n  - 参数：$s = 1$, $c = 0.6$。\n  - 强度：$I(\\mu) = \\exp(0.7\\,\\mu) + 0.2\\,\\mu$。\n- 测试用例 3（边界情况：未正确归一化的核）：\n  - 参数：$s = 0.97$, $c = 0.2$。\n  - 强度：$I(\\mu) = 1 - \\mu + \\mu^2$。\n\n数值要求：\n- 使用 $N \\ge 128$ 个点的高斯-勒让德积分来近似所有在 $\\mu \\in [-1,1]$ 上的积分。\n- 对所有检验使用容差 $\\epsilon = 10^{-10}$。\n\n输出规格：\n- 对于每个测试用例，生成一个布尔值，指示零阶矩检验和一阶矩检验是否都根据上述标准通过。因此，一个测试用例的结果是这两个检验的逻辑合取。\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 `[True,False,True]`。\n\n本问题中不需要物理单位。所有角度都通过无量纲的余弦变量 $\\mu$ 表示，因此不需要角度单位。\n\n你的程序必须是一个完整的、可运行的程序，能够执行所有计算并以所描述的精确格式打印最终结果。",
            "solution": "所提出的问题是数学物理学中一个适定性良好的练习，涉及辐射转移的玻尔兹曼方程框架内一个简化碰撞算符的性质。它具有科学依据，内部一致，并包含了获得唯一解所需的所有信息。因此，我们将按照要求进行推导和数值验证。\n\n研究的核心对象是碰撞算符 $\\mathcal{C}[I](\\mu)$，其为比强度 $I(\\mu)$ 而定义，其中 $\\mu \\in [-1, 1]$ 是与固定轴夹角的余弦。该算符由以下公式给出：\n$$\n\\mathcal{C}[I](\\mu) \\equiv - I(\\mu) + \\int_{-1}^{1} K(\\mu,\\mu')\\, I(\\mu')\\, d\\mu'\n$$\n代表弹性散射相函数的核由以下参数族给出：\n$$\nK(\\mu,\\mu') = \\frac{s}{2}\\,\\bigl(1 + c\\,\\mu\\,\\mu'\\bigr)\n$$\n其中 $s$ 和 $c$ 是实数参数。函数 $g(\\mu)$ 的角矩定义为零阶矩 $J[g] \\equiv \\int_{-1}^{1} g(\\mu)\\, d\\mu$ 和一阶矩 $S[g] \\equiv \\int_{-1}^{1} \\mu\\, g(\\mu)\\, d\\mu$。我们的首要任务是推导碰撞算符对这些矩的影响。\n\n**矩性质的解析推导**\n\n**1. 零阶矩 $J[\\mathcal{C}[I]]$**\n\n我们通过对 $\\mathcal{C}[I](\\mu)$ 在 $\\mu \\in [-1, 1]$ 上积分来计算零阶矩：\n$$\nJ[\\mathcal{C}[I]] = \\int_{-1}^{1} \\mathcal{C}[I](\\mu)\\, d\\mu = \\int_{-1}^{1} \\left( - I(\\mu) + \\int_{-1}^{1} K(\\mu,\\mu')\\, I(\\mu')\\, d\\mu' \\right) d\\mu\n$$\n根据积分的线性性质，此表达式分为两项：\n$$\nJ[\\mathcal{C}[I]] = - \\int_{-1}^{1} I(\\mu)\\, d\\mu + \\int_{-1}^{1} \\int_{-1}^{1} K(\\mu,\\mu')\\, I(\\mu')\\, d\\mu'\\, d\\mu\n$$\n第一项根据定义为 $-J[I]$。对于第二项，由于被积函数是良态的，我们应用富比尼定理来交换积分顺序：\n$$\n\\int_{-1}^{1} I(\\mu') \\left( \\int_{-1}^{1} K(\\mu,\\mu')\\, d\\mu \\right) d\\mu'\n$$\n内部积分，即将核投影到零阶勒让德多项式上，计算结果为：\n$$\n\\int_{-1}^{1} K(\\mu,\\mu')\\, d\\mu = \\int_{-1}^{1} \\frac{s}{2}\\,(1 + c\\,\\mu\\,\\mu')\\, d\\mu = \\frac{s}{2} \\left[ \\int_{-1}^{1} 1\\, d\\mu + c\\,\\mu' \\int_{-1}^{1} \\mu\\, d\\mu \\right]\n$$\n定积分为 $\\int_{-1}^{1} d\\mu = [\\mu]_{-1}^{1} = 2$，并且由于被积函数的奇对称性，$\\int_{-1}^{1} \\mu\\, d\\mu = [\\frac{\\mu^2}{2}]_{-1}^{1} = 0$。因此，内部积分简化为 $\\frac{s}{2} (2 + 0) = s$。\n将此结果代回，二重积分变为 $s \\int_{-1}^{1} I(\\mu')\\, d\\mu' = s\\,J[I]$。\n最后，合并各项得到碰撞算符零阶矩的解析表达式：\n$$\nJ[\\mathcal{C}[I]] = -J[I] + s\\,J[I] = (s-1)J[I]\n$$\n这个结果证实了，对于一个缩放因子 $s=1$ 的正确归一化的核，零阶矩是守恒的（$J[\\mathcal{C}[I]] = 0$），这对应于弹性散射中粒子数的守恒。\n\n**2. 一阶矩 $S[\\mathcal{C}[I]]$**\n\n遵循相同的步骤，我们通过对 $\\mu\\,\\mathcal{C}[I](\\mu)$ 在 $\\mu \\in [-1, 1]$ 上积分来计算一阶矩：\n$$\nS[\\mathcal{C}[I]] = \\int_{-1}^{1} \\mu\\,\\mathcal{C}[I](\\mu)\\, d\\mu = \\int_{-1}^{1} \\mu \\left( - I(\\mu) + \\int_{-1}^{1} K(\\mu,\\mu')\\, I(\\mu')\\, d\\mu' \\right) d\\mu\n$$\n分离各项并对二重积分交换积分顺序，得到：\n$$\nS[\\mathcal{C}[I]] = - \\int_{-1}^{1} \\mu\\,I(\\mu)\\, d\\mu + \\int_{-1}^{1} I(\\mu') \\left( \\int_{-1}^{1} \\mu\\,K(\\mu,\\mu')\\, d\\mu \\right) d\\mu'\n$$\n第一项是 $-S[I]$。第二项的内部积分为：\n$$\n\\int_{-1}^{1} \\mu\\,K(\\mu,\\mu')\\, d\\mu = \\int_{-1}^{1} \\mu\\,\\frac{s}{2}\\,(1 + c\\,\\mu\\,\\mu')\\, d\\mu = \\frac{s}{2} \\left[ \\int_{-1}^{1} \\mu\\, d\\mu + c\\,\\mu' \\int_{-1}^{1} \\mu^2\\, d\\mu \\right]\n$$\n如前所述，$\\int_{-1}^{1} \\mu\\, d\\mu = 0$。另一个积分的计算结果为 $\\int_{-1}^{1} \\mu^2\\, d\\mu = [\\frac{\\mu^3}{3}]_{-1}^{1} = \\frac{2}{3}$。\n因此，内部积分变为 $\\frac{s}{2} (0 + c\\,\\mu' \\frac{2}{3}) = \\frac{sc}{3}\\mu'$。\n代入此结果，二重积分变为 $\\int_{-1}^{1} I(\\mu') (\\frac{sc}{3}\\mu')\\, d\\mu' = \\frac{sc}{3} \\int_{-1}^{1} \\mu'\\,I(\\mu')\\, d\\mu' = \\frac{sc}{3}S[I]$。\n合并各项，得到预测的一阶矩 $S_{\\mathrm{pred}}$：\n$$\nS[\\mathcal{C}[I]] = -S[I] + \\frac{sc}{3}S[I] = \\left(\\frac{sc}{3}-1\\right)S[I] \\equiv S_{\\mathrm{pred}}\n$$\n\n**数值验证方法论**\n\n为了验证这些解析公式，我们采用高精度数值积分。$N$ 点高斯-勒让德积分是对方程 $[-1, 1]$ 上的函数进行积分的理想方法，其近似为 $\\int_{-1}^{1} f(\\mu)\\,d\\mu \\approx \\sum_{i=1}^{N} w_i f(\\mu_i)$，其中 $\\mu_i$ 是节点， $w_i$ 是权重。选择 $N \\ge 128$ 可确保积分误差相对于指定的容差 $\\epsilon = 10^{-10}$ 可以忽略不计。\n\n数值算法如下：\n1.  生成一组 $N$ 个高斯-勒让德节点 $\\mu_i$ 和权重 $w_i$。\n2.  对于给定的测试用例（$s$、$c$、$I(\\mu)$），在每个节点上计算强度 $I_i = I(\\mu_i)$。\n3.  计算初始强度场矩的数值近似值：\n    $$ J_{\\text{num}}[I] = \\sum_{i=1}^{N} w_i I_i \\quad \\text{和} \\quad S_{\\text{num}}[I] = \\sum_{i=1}^{N} w_i \\mu_i I_i $$\n4.  在每个节点上计算碰撞算符 $\\mathcal{C}[I](\\mu_i)$。一个关键的洞见是，$\\mathcal{C}[I]$ 中的积分可以用 $I$ 的矩来表示，从而避免了代价高昂的数值二重积分。从我们的推导中可知，$\\int_{-1}^{1} K(\\mu_i, \\mu') I(\\mu') d\\mu' = \\frac{s}{2} (J[I] + c\\mu_i S[I])$。因此，离散化的碰撞算符可以高效地计算为：\n    $$ \\mathcal{C}[I](\\mu_i) \\approx -I_i + \\frac{s}{2} (J_{\\text{num}}[I] + c\\mu_i S_{\\text{num}}[I]) $$\n5.  计算所得离散场 $\\mathcal{C}[I](\\mu_i)$ 的数值矩：\n    $$ J_{\\text{num}}[\\mathcal{C}[I]] = \\sum_{i=1}^{N} w_i \\mathcal{C}[I](\\mu_i) \\quad \\text{和} \\quad S_{\\text{num}}[\\mathcal{C}[I]] = \\sum_{i=1}^{N} w_i \\mu_i \\mathcal{C}[I](\\mu_i) $$\n6.  最后，通过将数值结果与解析预测进行比较来执行两次检验：\n    -   **零阶矩检验：** $|J_{\\text{num}}[\\mathcal{C}[I]] - (s-1)J_{\\text{num}}[I]| \\le \\epsilon \\max(1, |J_{\\text{num}}[I]|)$。这是对我们推导的第一个公式的通用检验。对于 $s=1$，它正确地简化为问题中指定的守恒检验 $|J_{\\text{num}}[\\mathcal{C}[I]]| \\le \\epsilon \\max(1, |J_{\\text{num}}[I]|)$。\n    -   **一阶矩检验：** $|S_{\\text{num}}[\\mathcal{C}[I]] - (\\frac{sc}{3}-1)S_{\\text{num}}[I]| \\le \\epsilon \\max(1, |S_{\\text{num}}[I]|)$。这直接测试了我们推导的第二个公式 $S_{\\mathrm{pred}}$。\n\n每个测试用例的结果是这些检验的通过/失败状态的逻辑合取。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Validates the conservation of the zeroth angular moment and checks the\n    derived first angular moment for a model collisional Boltzmann operator.\n    \"\"\"\n    # Numerical parameters specified in the problem\n    N = 128\n    epsilon = 1e-10\n\n    # Define the Legendre polynomial P_2(mu) for Test Case 1\n    def p2(mu):\n        return (3 * mu**2 - 1) / 2.0\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (s, c, intensity_function)\n    test_cases = [\n        (1.0, 0.0, lambda mu: 1.0 + 0.5 * mu - 0.3 * p2(mu)),\n        (1.0, 0.6, lambda mu: np.exp(0.7 * mu) + 0.2 * mu),\n        (0.97, 0.2, lambda mu: 1.0 - mu + mu**2),\n    ]\n\n    results = []\n\n    # Generate Gauss-Legendre nodes and weights for the interval [-1, 1]\n    mu_nodes, w_nodes = roots_legendre(N)\n\n    for s, c, I_func in test_cases:\n        # Step 1: Evaluate the intensity function I(mu) at each node\n        I_vals = I_func(mu_nodes)\n\n        # Step 2: Numerically compute the zeroth and first moments of I(mu)\n        # J[I] = integral(I(mu) dmu)\n        J_I_num = np.sum(w_nodes * I_vals)\n        # S[I] = integral(mu * I(mu) dmu)\n        S_I_num = np.sum(w_nodes * mu_nodes * I_vals)\n\n        # Step 3: Evaluate the collision operator C[I](mu) at each node.\n        # The integral part of C[I] can be expressed in terms of J[I] and S[I]:\n        # integral(K(mu, mu')*I(mu') dmu') = s/2 * (J[I] + c*mu*S[I])\n        integral_term_vals = (s / 2.0) * (J_I_num + c * mu_nodes * S_I_num)\n        C_I_vals = -I_vals + integral_term_vals\n\n        # Step 4: Numerically compute the moments of C[I](mu)\n        # J[C[I]] = integral(C[I](mu) dmu)\n        J_C_I_num = np.sum(w_nodes * C_I_vals)\n        # S[C[I]] = integral(mu * C[I](mu) dmu)\n        S_C_I_num = np.sum(w_nodes * mu_nodes * C_I_vals)\n        \n        # Step 5: Perform the two required checks against analytical predictions.\n\n        # Check 1: Zeroth moment.\n        # Analytical prediction: J[C[I]] = (s - 1) * J[I]\n        J_C_I_pred = (s - 1.0) * J_I_num\n        # For s=1, this simplifies to J[C[I]]=0 (conservation).\n        # We check if the numerical result matches the prediction within tolerance.\n        check1_passed = np.abs(J_C_I_num - J_C_I_pred) = epsilon * max(1.0, np.abs(J_I_num))\n        \n        # Check 2: First moment.\n        # Analytical prediction: S[C[I]] = (s*c/3 - 1) * S[I]\n        S_C_I_pred = (s * c / 3.0 - 1.0) * S_I_num\n        # We check if the numerical result matches the prediction within tolerance.\n        check2_passed = np.abs(S_C_I_num - S_C_I_pred) = epsilon * max(1.0, np.abs(S_I_num))\n        \n        # The result for the test case is the logical AND of both checks.\n        results.append(check1_passed and check2_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在前两个练习的基础上，我们现在准备处理宇宙学中实际的物理过程：汤姆孙散射。这个实践  要求你从汤姆孙散射的微分截面这一第一性原理出发，推导出轴对称系统下的散射核。你的核心任务是将其离散化，并编写代码来严格检验这个离散化的算符是否仍然保持了原始物理过程的关键不变性，如归一性、对称性和光子数守恒。这个练习是连接理论物理与高性能计算宇宙学代码开发的关键一步。",
            "id": "3493982",
            "problem": "考虑在空间均匀的设定下，光子通过与静止电子发生弹性汤姆孙散射的碰撞玻尔兹曼方程，该方程描述了光子相空间分布函数 $f(\\mathbf{x}, \\mathbf{p}, t)$。忽略空间梯度和度规效应，因此演化完全由碰撞算符决定。得到的常微分方程为 $\\partial_t f(\\hat{\\mathbf{n}}, \\nu, t) = C[f](\\hat{\\mathbf{n}}, \\nu, t)$，其中 $\\hat{\\mathbf{n}}$ 表示光子传播方向的单位矢量，$\\nu$ 表示无量纲光子频率（在此被视为一个参数，因为汤姆孙散射在领头阶上不改变光子能量）。汤姆孙微分截面由经过充分检验的公式 $\\frac{d\\sigma}{d\\Omega} = \\frac{3\\sigma_\\mathrm{T}}{16\\pi}\\left(1+\\cos^2\\theta\\right)$ 给出，其中 $\\theta$ 是入射方向和出射方向之间的散射角，$\\sigma_\\mathrm{T}$ 是汤姆孙截面。对于静止电子，相应的碰撞算符在保持光子数守恒的同时，将光子在不同方向上重新分布。在一个无量纲系统中进行计算，其中整体碰撞率由单个参数 $\\nu$ 捕捉，将电子数密度、汤姆孙截面和光速吸收到一个单一的率中，使得 $C[f]$ 具有如下结构：$C[f](\\hat{\\mathbf{n}}) = \\nu\\left(-f(\\hat{\\mathbf{n}}) + \\int d\\Omega'\\, K(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}')\\, f(\\hat{\\mathbf{n}}')\\right)$，其中归一化核 $K$ 源自汤姆孙相函数。\n\n从这些基本要素出发，并假设系统关于一个固定轴具有轴对称性，因此 $f$ 仅依赖于极角的余弦 $\\mu = \\cos\\theta \\in [-1, 1]$，推导在入射方向的方位角上平均后的碰撞核 $K$ 的轴对称形式。证明核的归一化性质意味着，对于各向同性的 $f$，散射入项在入射立体角上的积分等于散射出项，并且对于任意 $f$，光子数 $\\int d\\Omega\\, f$ 在碰撞算符作用下是守恒的。使用具有 $N$ 个节点的 Gauss–Legendre 求积法对关于 $\\mu$ 的轴对称积分进行离散化，并实现离散碰撞算符 $C_i = \\nu\\left(-f_i + \\sum_{j=1}^{N} w_j\\, S(\\mu_i, \\mu_j)\\, f_j\\right)$，其中 $\\{\\mu_i, w_i\\}$ 是区间 $[-1,1]$ 上的求积节点和权重，而 $S(\\mu_i, \\mu_j)$ 是您推导出的方位角平均的轴对称汤姆孙核。您的实现应基于第一性原理进行数值稳定的构造，并且不得假设任何非物理的捷径。\n\n您必须编写一个单一的自包含程序，该程序构造离散核，应用碰撞算符，并执行不变量检验以测试数值精度。具体来说，对于给定的测试套件，计算以下残差：\n- 核归一化残差 $r_\\mathrm{norm}(N) = \\max_i \\left| \\sum_{j=1}^{N} w_j\\, S(\\mu_i, \\mu_j) - 1 \\right|$。\n- 各向同性不动点残差 $r_\\mathrm{iso}(N, A) = \\max_i \\left| C_i[f \\equiv A] \\right|$，对于常数 $f(\\mu) \\equiv A$。\n- 光子数守恒残差 $r_\\mathrm{num}(N) = \\left| \\sum_{i=1}^{N} w_i\\, C_i[f] \\right|$，对于一个指定的非各向同性 $f$。\n- 核对称性残差 $r_\\mathrm{sym}(N) = \\max_{i,j} \\left| S(\\mu_i, \\mu_j) - S(\\mu_j, \\mu_i) \\right|$。\n\n使用以下测试套件参数：\n- 情况 1：$N = 8$，计算 $r_\\mathrm{norm}(N)$。\n- 情况 2：$N = 32$，$A = 1.3$，计算 $r_\\mathrm{iso}(N, A)$。\n- 情况 3：$N = 32$，非各向同性 $f(\\mu) = 1 + 0.2\\, \\mu + 0.1\\, P_2(\\mu)$，其中 $P_2(\\mu) = \\frac{3\\mu^2 - 1}{2}$，计算 $r_\\mathrm{num}(N)$。\n- 情况 4：$N = 16$，计算 $r_\\mathrm{sym}(N)$。\n\n所有量均为无量纲；不需要物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为 $[r_\\mathrm{norm}(8), r_\\mathrm{iso}(32, 1.3), r_\\mathrm{num}(32), r_\\mathrm{sym}(16)]$。每个条目必须是一个实数（浮点数）。输出格式必须是与模板 $[r_1,r_2,r_3,r_4]$ 完全匹配的单行。",
            "solution": "该问题要求推导、离散化并实现用于空间均匀、轴对称系统中弹性汤姆孙散射的碰撞玻尔兹曼算符。求解过程包括以下几个步骤：推导轴对称核，验证其基本性质，进行数值离散化，以及实现数值测试。\n\n### 1. 轴对称散射核的推导\n\n光子相空间分布函数 $f$ 在汤姆孙散射下的演化由碰撞玻尔兹曼方程给出，在指定假设下，该方程简化为 $\\partial_t f(\\hat{\\mathbf{n}}) = C[f](\\hat{\\mathbf{n}})$。碰撞算符 $C[f]$ 如下：\n$$\nC[f](\\hat{\\mathbf{n}}) = \\nu\\left(-f(\\hat{\\mathbf{n}}) + \\int_{4\\pi} d\\Omega'\\, K(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}')\\, f(\\hat{\\mathbf{n}}')\\right)\n$$\n这里，$\\hat{\\mathbf{n}}$ 和 $\\hat{\\mathbf{n}}'$ 分别是出射和入射光子方向的单位矢量。参数 $\\nu$ 是总散射率。项 $- \\nu f(\\hat{\\mathbf{n}})$ 表示从方向 $\\hat{\\mathbf{n}}$ 散射出去的光子，而积分项表示从所有其他方向 $\\hat{\\mathbf{n}}'$ 散射入 $\\hat{\\mathbf{n}}$ 的光子。\n\n散射核 $K$ 由微分截面 $\\frac{d\\sigma}{d\\Omega} = \\frac{3\\sigma_\\mathrm{T}}{16\\pi}\\left(1+\\cos^2\\Theta\\right)$ 推导而来，其中 $\\Theta$ 是 $\\hat{\\mathbf{n}}$ 和 $\\hat{\\mathbf{n}}'$ 之间的散射角，即 $\\cos\\Theta = \\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}'$。核 $K$ 是归一化的散射相函数，由 $K(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}') = \\frac{1}{\\sigma_\\mathrm{T}}\\frac{d\\sigma}{d\\Omega} = \\frac{3}{16\\pi}\\left(1+(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}')^2\\right)$ 给出。核的归一化满足 $\\int_{4\\pi} K(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}') d\\Omega' = 1$。\n\n问题指定了轴对称性，意味着 $f$ 仅依赖于 $\\mu = \\cos\\theta$，其中 $\\theta$ 是相对于一个固定轴（比如 $\\hat{\\mathbf{z}}$ 轴）的极角。因此，$f(\\hat{\\mathbf{n}}) = f(\\mu)$。为了得到适用于 $f(\\mu)$ 的碰撞算符，我们在方位角上进行平均。设 $\\hat{\\mathbf{n}}$ 的极角为 $\\theta$（因此 $\\mu=\\cos\\theta$），方位角为 $\\phi$。设 $\\hat{\\mathbf{n}}'$ 的极角为 $\\theta'$（因此 $\\mu'=\\cos\\theta'$），方位角为 $\\phi'$。\n点积为 $\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}' = \\mu\\mu' + \\sqrt{1-\\mu^2}\\sqrt{1-\\mu'^2}\\cos(\\phi-\\phi')$。\n\n增益项变为 $\\int_{-1}^{1} d\\mu' \\int_{0}^{2\\pi} d\\phi' K(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}') f(\\mu')$。根据轴对称性，所得算符必须与 $\\phi$ 无关。我们可以通过对相对方位角 $\\Delta\\phi = \\phi - \\phi'$ 进行积分来定义一个轴对称核 $S(\\mu, \\mu')$：\n$$\nS(\\mu, \\mu') = \\int_{0}^{2\\pi} K(\\hat{\\mathbf{n}}\\cdot\\hat{\\mathbf{n}}') d\\phi' = \\int_{0}^{2\\pi} \\frac{3}{16\\pi}\\left(1+\\left(\\mu\\mu' + \\sqrt{(1-\\mu^2)(1-\\mu'^2)}\\cos(\\Delta\\phi)\\right)^2\\right) d(\\Delta\\phi)\n$$\n展开平方并逐项积分，我们利用 $\\int_0^{2\\pi} \\cos(\\Delta\\phi) d(\\Delta\\phi) = 0$ 和 $\\int_0^{2\\pi} \\cos^2(\\Delta\\phi) d(\\Delta\\phi) = \\pi$ 这两个事实：\n$$\nS(\\mu, \\mu') = \\frac{3}{16\\pi} \\left[ \\int_0^{2\\pi} \\left(1 + (\\mu\\mu')^2\\right) d(\\Delta\\phi) + (1-\\mu^2)(1-\\mu'^2) \\int_0^{2\\pi} \\cos^2(\\Delta\\phi) d(\\Delta\\phi) \\right]\n$$\n$$\nS(\\mu, \\mu') = \\frac{3}{16\\pi} \\left[ 2\\pi(1 + \\mu^2\\mu'^2) + \\pi(1-\\mu^2)(1-\\mu'^2) \\right]\n$$\n简化此表达式可得到轴对称核的最终形式：\n$$\nS(\\mu, \\mu') = \\frac{3}{16} \\left[ 2(1 + \\mu^2\\mu'^2) + (1-\\mu^2)(1-\\mu'^2) \\right] = \\frac{3}{16} \\left( 3 - \\mu^2 - \\mu'^2 + 3\\mu^2\\mu'^2 \\right)\n$$\n轴对称玻尔兹曼方程则为：\n$$\n\\partial_t f(\\mu) = C[f](\\mu) = \\nu\\left(-f(\\mu) + \\int_{-1}^{1} f(\\mu') S(\\mu, \\mu') d\\mu' \\right)\n$$\n\n### 2. 基本性质的验证\n\n推导出的核和碰撞算符必须满足关键的物理原理。\n\n**核归一化与各向同性不动点**：为了使散射成为一个重新分布过程，从一个给定方向散射到任何其他方向的总概率必须为1。对于轴对称核，这等价于 $\\int_{-1}^{1} S(\\mu, \\mu') d\\mu' = 1$。我们来验证这一点：\n$$\n\\int_{-1}^{1} \\frac{3}{16} \\left( 3 - \\mu^2 - \\mu'^2 + 3\\mu^2\\mu'^2 \\right) d\\mu' = \\frac{3}{16} \\int_{-1}^{1} \\left( (3-\\mu^2) + \\mu'^2(3\\mu^2 - 1) \\right) d\\mu'\n$$\n$$\n= \\frac{3}{16} \\left[ (3-\\mu^2)\\mu' + (3\\mu^2-1)\\frac{\\mu'^3}{3} \\right]_{-1}^{1} = \\frac{3}{16} \\left[ 2(3-\\mu^2) + \\frac{2}{3}(3\\mu^2-1) \\right]\n$$\n$$\n= \\frac{3}{16} \\left[ 6 - 2\\mu^2 + 2\\mu^2 - \\frac{2}{3} \\right] = \\frac{3}{16} \\left( \\frac{18-2}{3} \\right) = \\frac{3}{16} \\frac{16}{3} = 1\n$$\n该归一化确保了如果分布是各向同性的，即 $f(\\mu) = A$（一个常数），则碰撞算符为零：\n$C[f=A] = \\nu(-A + \\int_{-1}^{1} A S(\\mu, \\mu') d\\mu') = \\nu(-A + A \\int_{-1}^{1} S(\\mu, \\mu') d\\mu') = \\nu(-A+A) = 0$。这证实了各向同性光子场是碰撞算符的一个稳态（不动点）。\n\n**核对称性与光子数守恒**：系统中的总光子数正比于 $\\mathcal{N} = \\int d\\Omega f = 2\\pi \\int_{-1}^{1} f(\\mu) d\\mu$。对于弹性散射，该数量必须守恒，即 $\\frac{d\\mathcal{N}}{dt} = 0$。这要求 $\\int_{-1}^{1} C[f](\\mu) d\\mu = 0$。\n$$\n\\int_{-1}^{1} C[f](\\mu) d\\mu = \\nu \\int_{-1}^{1} \\left(-f(\\mu) + \\int_{-1}^{1} f(\\mu') S(\\mu, \\mu') d\\mu' \\right) d\\mu\n$$\n$$\n= \\nu \\left( -\\int_{-1}^{1} f(\\mu) d\\mu + \\int_{-1}^{1} d\\mu \\int_{-1}^{1} d\\mu' S(\\mu, \\mu') f(\\mu') \\right)\n$$\n通过观察可知，核 $S(\\mu, \\mu') = \\frac{3}{16} (3 - \\mu^2 - \\mu'^2 + 3\\mu^2\\mu'^2)$ 在交换 $\\mu$ 和 $\\mu'$ 时是对称的，即 $S(\\mu, \\mu') = S(\\mu', \\mu)$。利用此对称性，我们可以在二重积分中交换积分变量并交换积分次序（Fubini 定理）：\n$$\n\\int_{-1}^{1} d\\mu' f(\\mu') \\left( \\int_{-1}^{1} S(\\mu, \\mu') d\\mu \\right) = \\int_{-1}^{1} d\\mu' f(\\mu') \\left( \\int_{-1}^{1} S(\\mu', \\mu) d\\mu \\right) = \\int_{-1}^{1} f(\\mu') \\cdot 1 \\, d\\mu'\n$$\n由于归一化性质，括号中的项值为 1。因此增益项积分等于 $\\int_{-1}^{1} f(\\mu') d\\mu'$，这正好抵消了损失项的积分。因此，对于任何任意（可积）函数 $f(\\mu)$，都有 $\\int_{-1}^{1} C[f](\\mu) d\\mu = 0$，证实了光子数守恒。\n\n### 3. 数值离散化与实现\n\n积分算符使用 Gauss-Legendre 求积法进行离散化。区间 $[-1, 1]$ 被离散化为一组 $N$ 个节点 $\\{\\mu_i\\}$ 及相应的权重 $\\{w_i\\}$。函数 $g(\\mu)$ 的积分近似为 $\\int_{-1}^{1} g(\\mu) d\\mu \\approx \\sum_{j=1}^{N} w_j g(\\mu_j)$。\n将此应用于碰撞算符，在节点 $\\mu_i$ 处求值：\n$$\nC[f](\\mu_i) \\equiv C_i = \\nu\\left(-f(\\mu_i) + \\sum_{j=1}^{N} w_j S(\\mu_i, \\mu_j) f(\\mu_j)\\right)\n$$\n这就是要实现的离散算符。核 $S(\\mu_i, \\mu_j)$ 成为一个 $N \\times N$ 矩阵 $S_{ij}$。\n\n待计算的残差是上述推导的解析性质的数值检验：\n- $r_\\mathrm{norm}(N)$: 检验核的归一化。它测量离散和 $\\sum_j w_j S_{ij}$ 与解析值 1 的最大偏差。\n- $r_\\mathrm{iso}(N, A)$: 检验各向同性不动点性质。它计算对于一个常数输入 $f_i = A$，离散算符 $C_i$ 的最大幅值。解析上该值为零；数值上它将与 $r_\\mathrm{norm}$ 成正比。\n- $r_\\mathrm{num}(N)$: 检验光子数守恒。它计算求积和 $\\sum_i w_i C_i$，该和近似于 $\\int C[f](\\mu) d\\mu$。此值应接近于零。\n- $r_\\mathrm{sym}(N)$: 检验核的对称性。它测量 $|S_{ij} - S_{ji}|$ 的最大差值，该值应在浮点精度范围内为零。\n\n实现过程将构造求积节点和权重，建立核矩阵 $S_{ij}$，然后为指定的测试用例计算这四个残差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef S_kernel(mu_i, mu_j):\n    \"\"\"\n    Calculates the azimuth-averaged axisymmetric Thomson scattering kernel S(mu, mu').\n\n    Args:\n        mu_i: Cosine of the outgoing polar angle(s). Can be a scalar or a broadcastable array.\n        mu_j: Cosine of the incident polar angle(s). Can be a scalar or a broadcastable array.\n\n    Returns:\n        The kernel value(s).\n    \"\"\"\n    mu_i_sq = np.square(mu_i)\n    mu_j_sq = np.square(mu_j)\n    return (3.0 / 16.0) * (3.0 - mu_i_sq - mu_j_sq + 3.0 * mu_i_sq * mu_j_sq)\n\ndef solve():\n    \"\"\"\n    Derives, discretizes, and tests the collisional Boltzmann operator for Thomson scattering.\n    \"\"\"\n    # All quantities are dimensionless. The scattering rate nu is set to 1.0.\n    nu = 1.0\n    results = []\n\n    # Case 1: Compute the kernel normalization residual r_norm(N) for N=8.\n    N1 = 8\n    mu1, w1 = roots_legendre(N1)\n    # Construct the kernel matrix S_ij = S(mu_i, mu_j).\n    # mu1[:, None] ensures that mu_i and mu_j broadcast correctly to form an NxN matrix.\n    S1 = S_kernel(mu1[:, None], mu1)\n    # The sum sum_j w_j S_ij is a matrix-vector product S @ w.\n    norm_check_vector = S1 @ w1\n    # The residual measures the deviation from the analytical result of 1.\n    r_norm = np.max(np.abs(norm_check_vector - 1.0))\n    results.append(r_norm)\n\n    # Case 2: Compute the isotropic fixed-point residual r_iso(N, A) for N=32, A=1.3.\n    N2 = 32\n    A = 1.3\n    mu2, w2 = roots_legendre(N2)\n    S2 = S_kernel(mu2[:, None], mu2)\n    # Create an isotropic distribution function f(mu) = A.\n    f_iso = np.full_like(mu2, A)\n    # Apply the discrete collision operator: C_i = nu * (-f_i + sum_j w_j S_ij f_j)\n    # The sum is evaluated as a matrix-vector product: S @ (w * f)\n    C_iso = nu * (-f_iso + S2 @ (w2 * f_iso))\n    # The residual is the maximum magnitude of the resulting operator.\n    r_iso = np.max(np.abs(C_iso))\n    results.append(r_iso)\n\n    # Case 3: Compute the photon number conservation residual r_num(N) for N=32.\n    N3 = 32\n    mu3, w3 = roots_legendre(N3)\n    S3 = S_kernel(mu3[:, None], mu3)\n    # Define the anisotropic distribution f(mu) = 1 + 0.2*mu + 0.1*P_2(mu).\n    P2_mu3 = 0.5 * (3 * np.square(mu3) - 1.0)\n    f_aniso = 1.0 + 0.2 * mu3 + 0.1 * P2_mu3\n    # Apply the collision operator.\n    C_aniso = nu * (-f_aniso + S3 @ (w3 * f_aniso))\n    # The residual is the magnitude of the quadrature integral of the operator,\n    # which approximates integral(C[f] dmu) and should be zero.\n    r_num = np.abs(np.dot(w3, C_aniso))\n    results.append(r_num)\n\n    # Case 4: Compute the kernel symmetry residual r_sym(N) for N=16.\n    N4 = 16\n    mu4, _ = roots_legendre(N4)\n    S4 = S_kernel(mu4[:, None], mu4)\n    # The residual is the maximum absolute difference between S_ij and S_ji.\n    r_sym = np.max(np.abs(S4 - S4.T))\n    results.append(r_sym)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}