{
    "hands_on_practices": [
        {
            "introduction": "在计算宇宙微波背景辐射（CMB）的各向异性时，视线积分是其核心。在将我们的数值积分器应用于复杂的物理源函数之前，我们必须首先验证其基本准确性。本练习  将使用一些具有解析解的简化源函数来构建一个基准测试，这使我们能够量化求积方法的精度，从而建立对代码的信心。这是任何科学计算代码开发中的基本步骤。",
            "id": "3478222",
            "problem": "考虑宇宙微波背景 (CMB; Cosmic Microwave Background) 温度和偏振多极矩的视线表示法。在视线方法中，对于给定的波数 $\\,k\\,$ 和多极矩指数 $\\,\\ell\\,$, 多极矩转移函数 $\\,\\Theta_\\ell(k)\\,$ 表示为一个关于共形时间 $\\,\\eta\\,$ 的积分,\n$$\n\\Theta_\\ell(k) \\;=\\; \\int_{0}^{\\eta_0} S(k,\\eta)\\, j_\\ell\\!\\left(k\\,(\\eta_0-\\eta)\\right)\\, d\\eta,\n$$\n其中 $\\,\\eta_0\\,$ 是当今的共形时间，$\\,S(k,\\eta)\\,$ 是一个解析源项，而 $\\,j_\\ell(x)\\,$ 是 $\\,\\ell\\,$ 阶第一类球贝塞尔函数。\n\n从上述在数值宇宙学中广泛使用且经过充分检验的视线积分公式以及分布和特殊函数的标准性质出发，实现一个基准测试来评估振荡积分的准确性。该基准测试应建立在解析源 $\\,S(k,\\eta)\\,$ 的基础上，对于这些源，该积分要么具有闭式表达式，要么可以简化为已知的球贝塞尔函数变换。目标是通过与已知结果的比对来验证数值收敛性，并为振荡性逐渐增强的积分和具有尖锐峰值的源量化其准确性。\n\n您必须实现以下解析源及相关的期望值：\n\n1. 一个在 $\\,\\eta\\in[0,\\eta_0]\\,$ 上具有恒定振幅 $\\,C\\,$ 的均匀源 $\\,S_U(k,\\eta) = C\\,$。对于 $\\,\\ell=0\\,$，在进行变量替换 $\\,x=k(\\eta_0-\\eta)\\,$ 后，积分简化为 $\\,j_0(x)=\\sin(x)/x\\,$ 的一个已知积分：\n$$\n\\Theta_0^{U}(k) \\;=\\; \\frac{C}{k}\\,\\int_{0}^{k\\eta_0} j_0(x)\\,dx \\;=\\; \\frac{C}{k}\\,\\mathrm{Si}(k\\eta_0),\n$$\n其中 $\\,\\mathrm{Si}(x) = \\int_0^x \\frac{\\sin t}{t}\\,dt\\,$ 是正弦积分。使用此闭式形式来计算期望值。\n\n2. 一个近似于狄拉克δ分布的窄高斯源，\n$$\nS_G(k,\\eta) \\;=\\; \\frac{A}{\\sqrt{2\\pi}\\,\\sigma}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right),\n$$\n其振幅为 $\\,A\\,$，中心为 $\\,\\eta_s\\,$，宽度为 $\\,\\sigma\\,$。当 $\\,\\sigma\\to 0\\,$ 且 $\\,\\eta_s\\in(0,\\eta_0)\\,$ 时，根据磨光函数近似狄拉克δ函数的标准性质，积分收敛到\n$$\n\\Theta_\\ell^{G}(k) \\;\\to\\; A\\, j_\\ell\\!\\left(k(\\eta_0-\\eta_s)\\right),\n$$\n\n3. 一个近似于狄拉克δ分布导数的高斯函数导数源，\n$$\nS_{G'}(k,\\eta) \\;=\\; B\\,\\frac{d}{d\\eta}\\!\\left[\\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right)\\right]\n\\;=\\; -\\,B\\,\\frac{\\eta-\\eta_s}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right),\n$$\n其振幅为 $\\,B\\,$。使用分布恒等式 $\\,\\int \\delta'(\\eta-\\eta_s) f(\\eta)\\,d\\eta = -f'(\\eta_s)\\,$ 和链式法则 $\\,\\frac{d}{d\\eta} j_\\ell(k(\\eta_0-\\eta))=-k\\,j_\\ell'(k(\\eta_0-\\eta))\\,$, 当 $\\,\\sigma\\to 0\\,$ 时，积分收敛到\n$$\n\\Theta_\\ell^{G'}(k) \\;\\to\\; B\\,k\\, j_\\ell'\\!\\left(k(\\eta_0-\\eta_s)\\right),\n$$\n其中 $\\,j_\\ell'(x)\\,$ 表示球贝塞尔函数对其自变量的导数。\n\n实现一个程序，该程序：\n- 使用视线积分的直接求积法，对上述源的 $\\,\\Theta_\\ell(k)\\,$ 进行数值计算。\n- 按照规定计算相应的解析或渐近期望值。\n- 报告由以下公式定义的相对误差\n$$\n\\epsilon_{\\mathrm{rel}} \\;=\\; \\frac{\\left|\\Theta_\\ell^{\\mathrm{num}}(k) - \\Theta_\\ell^{\\mathrm{exp}}(k)\\right|}{\\max\\!\\left(\\left|\\Theta_\\ell^{\\mathrm{exp}}(k)\\right|,\\,10^{-12}\\right)}.\n$$\n\n所有变量均为无量纲；不需要物理单位。如有角度，应以弧度为单位处理。\n\n您的测试套件必须包含以下参数集，以检验不同的情况：\n- 均匀源，理想情况：$\\,(\\ell=0,\\,k=15.0,\\,\\eta_0=2.0,\\,C=1.0)\\,$。\n- 均匀源，强振荡情况：$\\,(\\ell=0,\\,k=80.0,\\,\\eta_0=1.5,\\,C=0.7)\\,$。\n- 高斯源，趋近狄拉克δ（中等窄度）：$\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.2)\\,$。\n- 高斯源，趋近狄拉克δ（更窄）：$\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.1)\\,$。\n- 高斯源，趋近狄拉克δ（非常窄）：$\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.05)\\,$。\n- 高斯函数导数源，趋近 $\\,\\delta'\\,$（中等窄度）：$\\,(\\ell=3,\\,k=20.0,\\,\\eta_0=1.2,\\,B=0.8,\\,\\eta_s=0.6,\\,\\sigma=0.2)\\,$。\n- 高斯函数导数源，趋近 $\\,\\delta'\\,$（更窄）：$\\,(\\ell=3,\\,k=20.0,\\,\\eta_0=1.2,\\,B=0.8,\\,\\eta_s=0.6,\\,\\sigma=0.1)\\,$。\n- 边界附近的高斯源，以测试截断效应：$\\,(\\ell=0,\\,k=30.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.1,\\,\\sigma=0.05)\\,$。\n\n您的程序应生成单行输出，其中包含按上述顺序列出的八个相对误差，形式为用方括号括起来的逗号分隔列表（例如，“[e1,e2,e3,e4,e5,e6,e7,e8]”）。",
            "solution": "用户希望验证并解决一个来自数值宇宙学的问题。\n\n### 第一步：提取已知信息\n\n问题提供了以下定义、公式和数据：\n\n1.  **视线积分：**\n    $$\n    \\Theta_\\ell(k) \\;=\\; \\int_{0}^{\\eta_0} S(k,\\eta)\\, j_\\ell\\!\\left(k\\,(\\eta_0-\\eta)\\right)\\, d\\eta\n    $$\n2.  **均匀源 $\\,S_U\\,$ 和期望值 $\\,\\Theta_0^U\\,$：**\n    -   源：$\\,S_U(k,\\eta) = C\\,$ for $\\,\\eta\\in[0,\\eta_0]\\,$。\n    -   $\\,\\ell=0\\,$ 时的期望值：$\\,\\Theta_0^{U}(k) = \\frac{C}{k}\\,\\mathrm{Si}(k\\eta_0)\\,$, 其中 $\\,\\mathrm{Si}(x) = \\int_0^x \\frac{\\sin t}{t}\\,dt\\,$。\n\n3.  **高斯源 $\\,S_G\\,$ 和渐近值 $\\,\\Theta_\\ell^G\\,$：**\n    -   源：$\\,S_G(k,\\eta) = \\frac{A}{\\sqrt{2\\pi}\\,\\sigma}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right)\\,$。\n    -   $\\,\\sigma\\to 0\\,$ 时的渐近值：$\\,\\Theta_\\ell^{G}(k) \\to A\\, j_\\ell\\!\\left(k(\\eta_0-\\eta_s)\\right)\\,$。\n\n4.  **高斯函数导数源 $\\,S_{G'}\\,$ 和渐近值 $\\,\\Theta_\\ell^{G'}\\,$：**\n    -   源：$\\,S_{G'}(k,\\eta) = -\\,B\\,\\frac{\\eta-\\eta_s}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right)\\,$。\n    -   $\\,\\sigma\\to 0\\,$ 时的渐近值：$\\,\\Theta_\\ell^{G'}(k) \\to B\\,k\\, j_\\ell'\\!\\left(k(\\eta_0-\\eta_s)\\right)\\,$。\n\n5.  **相对误差定义：**\n    $$\n    \\epsilon_{\\mathrm{rel}} \\;=\\; \\frac{\\left|\\Theta_\\ell^{\\mathrm{num}}(k) - \\Theta_\\ell^{\\mathrm{exp}}(k)\\right|}{\\max\\!\\left(\\left|\\Theta_\\ell^{\\mathrm{exp}}(k)\\right|,\\,10^{-12}\\right)}\n    $$\n\n6.  **测试用例（共8个）：**\n    -   用例 1 (均匀源): $\\,(\\ell=0,\\,k=15.0,\\,\\eta_0=2.0,\\,C=1.0)\\,$\n    -   用例 2 (均匀源): $\\,(\\ell=0,\\,k=80.0,\\,\\eta_0=1.5,\\,C=0.7)\\,$\n    -   用例 3 (高斯源): $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.2)\\,$\n    -   用例 4 (高斯源): $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.1)\\,$\n    -   用例 5 (高斯源): $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.05)\\,$\n    -   用例 6 (高斯函数导数源): $\\,(\\ell=3,\\,k=20.0,\\,\\eta_0=1.2,\\,B=0.8,\\,\\eta_s=0.6,\\,\\sigma=0.2)\\,$\n    -   用例 7 (高斯函数导数源): $\\,(\\ell=3,\\,k=20.0,\\,\\eta_0=1.2,\\,B=0.8,\\,\\eta_s=0.6,\\,\\sigma=0.1)\\,$\n    -   用例 8 (高斯源): $\\,(\\ell=0,\\,k=30.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.1,\\,\\sigma=0.05)\\,$\n\n### 第二步：使用提取的已知信息进行验证\n\n对问题进行严格的验证检查：\n\n-   **科学依据：**该问题基于视线积分方法，这是现代数值宇宙学中计算CMB各向异性的基石。$\\,\\Theta_\\ell(k)\\,$ 的积分形式是标准的。使用解析源函数为数值代码创建基准测试是计算科学中常见且有效的做法。给出的具体解析和渐近极限是正确的：\n    -   $\\,j_0(x)\\,$ 的积分确实是正弦积分 $\\,\\mathrm{Si}(x)\\,$。\n    -   窄高斯函数可作为狄拉克δ分布 $\\,\\delta(\\eta-\\eta_s)\\,$ 的标准近似（磨光函数），而极限 $\\,\\sigma \\to 0\\,$ 正确地恢复了δ函数的筛选性质。\n    -   窄高斯函数的导数近似于狄拉克δ函数的导数 $\\,\\delta'(\\eta-\\eta_s)\\,$，给出的结果正确地使用了积分性质 $\\,\\int f(x)\\delta'(x-x_s)dx = -f'(x_s)\\,$。\n    其数学和物理基础是可靠的。\n\n-   **适定性：**该问题是适定的。它要求将一个数值计算值与一个定义明确的解析或渐近表达式进行比较。两次计算所需的所有参数都已为八个测试用例中的每一个明确提供。相对误差的定义明确无误，并包含了防止除以零或极小数的保障措施，这是一个结构良好的数值问题的标志。\n\n-   **客观性：**问题陈述完全客观，以精确的数学和物理语言表达。它没有歧愈、主观看法或意见。\n\n基于此分析，该问题没有表现出验证标准中列出的任何缺陷。它在科学上是可靠的、形式上是明确的、完整的和客观的。\n\n### 第三步：结论与行动\n\n问题是**有效的**。将提供一个解决方案。\n\n目标是为几个测试用例数值计算视线积分 $\\,\\Theta_\\ell(k)\\,$，并通过计算相对误差，将结果与相应的解析或渐近公式进行比较。这可作为一个基准测试，用于评估处理CMB物理学中遇到的各类振荡和尖峰函数的数值积分技术的准确性。\n\n解决方案的核心是一种数值求积算法。标准科学计算库中的 `scipy.integrate.quad` 函数是一个合适的选择，它实现了一种自适应求积方案，能够处理各种各样的被积函数，包括这里涉及的振荡函数。对于每个测试用例，解决方案包括以下步骤：定义被积函数，执行数值积分，计算期望值，以及计算相对误差。\n\n首先，我们为三个源项 $\\,S_U(k,\\eta)\\,$, $\\,S_G(k,\\eta)\\,$ 和 $\\,S_{G'}(k,\\eta)\\,$ 定义Python函数，直接转录它们的数学定义。\n\n对于数值计算 $\\,\\Theta_\\ell^{\\mathrm{num}}(k)\\,$，我们构造被积函数，即相应源函数 $\\,S(k,\\eta)\\,$ 和球贝塞尔函数 $\\,j_\\ell(k(\\eta_0-\\eta))\\,$ 的乘积。`scipy.special.spherical_jn` 函数提供了 $\\,j_\\ell(x)\\,$ 的值。然后，我们将此被积函数及积分限 $\\,[0, \\eta_0]\\,$ 传递给 `scipy.integrate.quad`。对于强振荡情况（用例2，其中 $\\,k\\eta_0=120\\,$），审慎的做法是增加 `quad` 的 `limit` 参数，以允许使用更多的子区间来精确地解析振荡。\n\n接下来，我们实现用于计算期望值 $\\,\\Theta_\\ell^{\\mathrm{exp}}(k)\\,$ 的函数。\n1.  对于 $\\,\\ell=0\\,$ 的均匀源，期望值 $\\,\\Theta_0^U(k)\\,$ 使用由 `scipy.special.sici` 提供的正弦积分函数计算，该函数返回一个包含正弦和余弦积分的元组；我们使用第一个元素。\n2.  对于高斯源，渐近值 $\\,\\Theta_\\ell^G(k)\\,$ 通过在自变量 $\\,k(\\eta_0-\\eta_s)\\,$ 处对 `scipy.special.spherical_jn` 求值来计算。如测试用例3、4和5所示，随着宽度 $\\,\\sigma\\,$ 的减小，该近似的准确性会提高。测试用例8通过将高斯源的峰值置于积分边界附近来探讨截断的影响。\n3.  对于高斯函数导数源，渐近值 $\\,\\Theta_\\ell^{G'}(k)\\,$ 需要球贝塞尔函数的导数 $\\,j_\\ell'(x)\\,$。通过调用 `scipy.special.spherical_jn` 并附带可选参数 `derivative=True`，可以方便地获得此导数。\n\n最后，对于每个测试用例，使用数值结果 $\\,\\Theta_\\ell^{\\mathrm{num}}(k)\\,$ 和期望值 $\\,\\Theta_\\ell^{\\mathrm{exp}}(k)\\,$，根据指定的公式计算相对误差 $\\,\\epsilon_{\\mathrm{rel}}\\,$。如果 $\\,\\Theta_\\ell^{\\mathrm{exp}}(k)\\,$ 接近于零，分母中的 `max` 函数可以防止数值不稳定性。所有八个用例的计算误差被收集并格式化为所需的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import sici, spherical_jn\n\ndef solve():\n    \"\"\"\n    Numerically evaluates the CMB line-of-sight integral for various analytic\n    source functions and computes the relative error against known\n    analytic or asymptotic solutions.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Uniform source, happy path\n        {'type': 'U', 'params': {'ell': 0, 'k': 15.0, 'eta0': 2.0, 'C': 1.0}},\n        # 2. Uniform source, strongly oscillatory\n        {'type': 'U', 'params': {'ell': 0, 'k': 80.0, 'eta0': 1.5, 'C': 0.7}},\n        # 3. Gaussian source, moderately narrow\n        {'type': 'G', 'params': {'ell': 2, 'k': 25.0, 'eta0': 1.0, 'A': 1.0, 'eta_s': 0.5, 'sigma': 0.2}},\n        # 4. Gaussian source, narrower\n        {'type': 'G', 'params': {'ell': 2, 'k': 25.0, 'eta0': 1.0, 'A': 1.0, 'eta_s': 0.5, 'sigma': 0.1}},\n        # 5. Gaussian source, very narrow\n        {'type': 'G', 'params': {'ell': 2, 'k': 25.0, 'eta0': 1.0, 'A': 1.0, 'eta_s': 0.5, 'sigma': 0.05}},\n        # 6. Derivative-of-Gaussian source, moderately narrow\n        {'type': 'Gp', 'params': {'ell': 3, 'k': 20.0, 'eta0': 1.2, 'B': 0.8, 'eta_s': 0.6, 'sigma': 0.2}},\n        # 7. Derivative-of-Gaussian source, narrower\n        {'type': 'Gp', 'params': {'ell': 3, 'k': 20.0, 'eta0': 1.2, 'B': 0.8, 'eta_s': 0.6, 'sigma': 0.1}},\n        # 8. Gaussian source, near boundary\n        {'type': 'G', 'params': {'ell': 0, 'k': 30.0, 'eta0': 1.0, 'A': 1.0, 'eta_s': 0.1, 'sigma': 0.05}},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        p = case['params']\n        \n        # 1. Set up the integrand for numerical integration\n        integrand = None\n        if case['type'] == 'U':\n            ell, k, eta0, C = p['ell'], p['k'], p['eta0'], p['C']\n            source_func = lambda eta: C\n            integrand = lambda eta: source_func(eta) * spherical_jn(ell, k * (eta0 - eta))\n        \n        elif case['type'] == 'G':\n            ell, k, eta0, A, eta_s, sigma = p['ell'], p['k'], p['eta0'], p['A'], p['eta_s'], p['sigma']\n            norm = 1.0 / (np.sqrt(2 * np.pi) * sigma)\n            source_func = lambda eta: A * norm * np.exp(-(eta - eta_s)**2 / (2 * sigma**2))\n            integrand = lambda eta: source_func(eta) * spherical_jn(ell, k * (eta0 - eta))\n        \n        elif case['type'] == 'Gp':\n            ell, k, eta0, B, eta_s, sigma = p['ell'], p['k'], p['eta0'], p['B'], p['eta_s'], p['sigma']\n            norm_cubed = 1.0 / (np.sqrt(2 * np.pi) * sigma**3)\n            source_func = lambda eta: -B * (eta - eta_s) * norm_cubed * np.exp(-(eta - eta_s)**2 / (2 * sigma**2))\n            integrand = lambda eta: source_func(eta) * spherical_jn(ell, k * (eta0 - eta))\n\n        # 2. Perform the numerical integration\n        # For the highly oscillatory case, increase the subdivision limit\n        quad_limit = 50\n        if case['type'] == 'U' and p['k'] * p['eta0'] > 100:\n            quad_limit = 200\n        \n        theta_num = quad(integrand, 0, p['eta0'], limit=quad_limit)[0]\n\n        # 3. Calculate the expected (analytic or asymptotic) value\n        theta_exp = 0.0\n        if case['type'] == 'U':\n            k, eta0, C = p['k'], p['eta0'], p['C']\n            # The formula is specified for ell=0\n            if p['ell'] == 0:\n                theta_exp = C / k * sici(k * eta0)[0]\n        \n        elif case['type'] == 'G':\n            ell, k, eta0, A, eta_s = p['ell'], p['k'], p['eta0'], p['A'], p['eta_s']\n            theta_exp = A * spherical_jn(ell, k * (eta0 - eta_s))\n        \n        elif case['type'] == 'Gp':\n            ell, k, eta0, B, eta_s = p['ell'], p['k'], p['eta0'], p['B'], p['eta_s']\n            theta_exp = B * k * spherical_jn(ell, k * (eta0 - eta_s), derivative=True)\n            \n        # 4. Calculate the relative error\n        denominator = np.max([np.abs(theta_exp), 1e-12])\n        rel_err = np.abs(theta_num - theta_exp) / denominator\n        results.append(rel_err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "由于球贝塞尔函数 $j_\\ell(x)$ 的高频振荡特性，直接对视线积分进行数值计算可能极具挑战性。本练习  探索了一种强大的技术——分部积分法（IBP），以提高数值稳定性。通过将导数从振荡的贝塞尔函数转移到更平滑的源函数上，我们可以将问题转化为一种更易于数值求积方法处理的形式，从而掌握开发稳健高效的CMB代码的关键技能。",
            "id": "3478268",
            "problem": "您的任务是为宇宙微波背景（CMB, Cosmic Microwave Background）温度和极化计算中使用的视线投影，开发并验证一种数值分部积分方案。目标是将导数从振荡的球贝塞尔函数转移到源函数上，以获得更好的数值稳定性。您的工作必须从宇宙学和应用数学中基本且广为接受的基础出发，并且不得假定任何未经证实或临时的公式。\n\n需要使用的基本依据是：\n- 光子玻尔兹曼级联可以转化为多极矩传递函数的视线积分表示。该表示将多极矩传递函数表达为一个积分，积分内容为源函数乘以一个球贝塞尔函数，其自变量是波数和共形时间差的乘积，积分变量为共形时间。\n- 球贝塞尔函数 $j_\\ell(x)$ 是在球坐标下分离亥姆霍兹方程变量时出现的标准特殊函数，并且是球贝塞尔微分方程的解。众所周知，其在大自变量和高阶数下的振荡性质会在直接数值积分中引起数值挑战。\n\n您的任务如下：\n1. 对于一个通用的多极矩 $\\ell$ 和波数 $k$，在视线积分中，通过对共形时间进行分部积分，推导出一个数学上严谨的方案，将导数从球贝塞尔因子转移到源函数 $S_X(k,\\eta)$ 上。推导必须从标准的视线积分表达式开始，并且只使用球贝塞尔函数的性质和基本微积分。您不得引入任何未被这些基础所证明的快捷公式。清晰地识别出所有出现的边界项，并解释为何保留它们。\n2. 设计并实现一个数值算法，用于评估以下两者：\n   - 使用直接数值积分计算的原始（直接）视线积分。\n   - 您通过分部积分重构的公式，使用源函数的导数以及从您的推导中得到的球贝塞尔函数的反导数。\n3. 构建一个受物理启发的无量纲源函数模型 $S_X(k,\\eta)$，该模型能模拟复合时期的尖锐特征，同时保持光滑（连续可微），以确保其导数存在。使用以下形式：\n   - 一个以共形时间 $\\eta_{\\mathrm{rec}}$ 为中心、宽度为 $\\sigma_{\\mathrm{rec}}$ 的复合峰，并带有角频率与 $k$ 成正比的振荡声学调制：\n     $$S_{\\mathrm{rec}}(k,\\eta) = A_{\\mathrm{rec}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{rec}})^2}{2\\sigma_{\\mathrm{rec}}^2}\\right] \\cos\\!\\left(\\alpha(k)\\,(\\eta-\\eta_{\\mathrm{rec}})\\right),$$\n     其中 $\\alpha(k)$ 通过一个恒定的声速 $c_s$ 与 $k$ 成正比。\n   - 一个以 $\\eta_{\\mathrm{isw}}$ 为中心、宽度为 $\\sigma_{\\mathrm{isw}}$ 的宽阔的类积分Sachs–Wolfe晚期贡献：\n     $$S_{\\mathrm{isw}}(\\eta) = A_{\\mathrm{isw}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{isw}})^2}{2\\sigma_{\\mathrm{isw}}^2}\\right].$$\n   - 总源函数是两项之和 $S_X(k,\\eta) = S_{\\mathrm{rec}}(k,\\eta) + S_{\\mathrm{isw}}(\\eta)$。\n   提供 $\\partial S_X/\\partial \\eta$ 的解析表达式，并在您的分部积分方案中使用它们。所有三角函数参数必须以弧度为单位。\n4. 通过将当前共形时间归一化为 $\\eta_0=1$ 并将积分起始时间设为 $\\eta_i=0$，在无量纲单位下实现计算。根据您的方案酌情使用变量替换 $x=k(\\eta_0-\\eta)$。不需要物理单位；所有量均为无量纲。\n5. 根据直接积分和分部积分结果之间的相对差异来定义数值稳定性。对于给定的一对输出 $I_{\\mathrm{direct}}$ 和 $I_{\\mathrm{IBP}}$，将相对差异定义为\n   $$\\delta = \\frac{\\lvert I_{\\mathrm{IBP}} - I_{\\mathrm{direct}} \\rvert}{\\max\\left(\\lvert I_{\\mathrm{direct}} \\rvert, \\epsilon\\right)},$$\n   其中 $\\epsilon$ 是一个小的正数，以避免除以零，您必须明确指定它。\n6. 使用您的实现，为以下测试套件评估相对差异 $\\delta$，该套件涵盖了一般行为和尖锐特征的边缘情况：\n   - 测试用例1（正常路径）：$\\ell=50$, $k=80$, $\\sigma_{\\mathrm{rec}}=0.02$, 阈值 $\\tau=5\\times 10^{-3}$。\n   - 测试用例2（更高多极矩和更尖锐特征）：$\\ell=150$, $k=220$, $\\sigma_{\\mathrm{rec}}=0.01$, 阈值 $\\tau=10^{-2}$。\n   - 测试用例3（边缘情况，非常尖锐的复合峰）：$\\ell=300$, $k=300$, $\\sigma_{\\mathrm{rec}}=0.005$, 阈值 $\\tau=2\\times 10^{-2}$。\n   使用固定参数 $A_{\\mathrm{rec}}=1$, $A_{\\mathrm{isw}}=0.2$, $\\eta_{\\mathrm{rec}}=0.3$, $\\eta_{\\mathrm{isw}}=0.8$, $\\sigma_{\\mathrm{isw}}=0.2$, $c_s=0.5$, $\\eta_0=1$, $\\eta_i=0$, 以及 $\\epsilon=10^{-15}$。\n7. 对每个测试用例，返回一个布尔值来表示稳定性，定义为 $\\delta  \\tau$。\n8. 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3]”）。条目必须是上述三个测试用例的三个布尔值，并按给定顺序排列。\n\n您的最终答案必须是一个完整的、可运行的Python程序，该程序执行计算并以指定格式打印结果。角度必须以弧度为单位，所有量均为无量纲。",
            "solution": "用户提供了一个来自数值宇宙学领域的问题，要求我推导、实现并测试一个用于计算宇宙微波背景（CMB）视线积分的分部积分（IBP）方案。该问题在科学上是合理的、适定的，并且所有必要的参数和定义都已提供。因此，我将着手提供一个完整的解决方案。\n\n该解决方案包括三个主要阶段：\n1.  视线积分的分部积分公式的数学推导。\n2.  源函数及其导数的解析定义。\n3.  设计一个数值算法来计算直接积分并与IBP公式进行比较。\n\n### 1. 分部积分方案的数学推导\n\n一个通用的CMB多极矩传递函数 $\\Delta_\\ell(k)$ 的基本视线积分由下式给出：\n$$ \\Delta_\\ell(k) = \\int_{\\eta_i}^{\\eta_0} S_X(k, \\eta) j_\\ell(k(\\eta_0 - \\eta)) \\, d\\eta $$\n这里，$S_X(k, \\eta)$ 是给定波数 $k$ 在共形时间 $\\eta$ 处的源函数，$j_\\ell$ 是 $\\ell$ 阶球贝塞尔函数，积分从初始时间 $\\eta_i$ 到当前时间 $\\eta_0$。问题指定了无量纲单位，其中 $\\eta_i = 0$ 且 $\\eta_0 = 1$。因此积分为：\n$$ \\Delta_\\ell(k) = \\int_{0}^{1} S_X(k, \\eta) j_\\ell(k(1 - \\eta)) \\, d\\eta $$\n目标是使用分部积分法 $\\int u \\, dv = [uv] - \\int v \\, du$ 来重构此积分，以便将等效的“微分”从振荡的贝塞尔函数转移到更平滑的源函数上。\n\n我们按如下方式选择各部分：\n-   $u(\\eta) = S_X(k, \\eta)$\n-   $dv = j_\\ell(k(1 - \\eta)) \\, d\\eta$\n\n由此，$u$ 的导数是直接的：\n-   $du = \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} \\, d\\eta$\n\n为了找到 $v(\\eta)$，我们必须对 $dv$ 进行积分。让我们进行变量替换 $y = k(1 - \\eta)$，这意味着 $d\\eta = -dy/k$。\n$$ v(\\eta) = \\int j_\\ell(k(1 - \\eta)) \\, d\\eta = \\int j_\\ell(y) \\left(-\\frac{dy}{k}\\right) = -\\frac{1}{k} \\int j_\\ell(y) \\, dy $$\n我们将球贝塞尔函数的反导数 $J_\\ell^{(-1)}(x)$ 定义为从 $0$ 到 $x$ 的定积分：\n$$ J_\\ell^{(-1)}(x) \\equiv \\int_0^x j_\\ell(y) \\, dy $$\n选择这个下限是一种简化边界项的约定，因为 $J_\\ell^{(-1)}(0) = 0$。根据这个定义，$v(\\eta)$ 变为：\n$$ v(\\eta) = -\\frac{1}{k} J_\\ell^{(-1)}(k(1 - \\eta)) $$\n现在，我们应用分部积分公式：\n$$ \\Delta_\\ell(k) = \\left[ u(\\eta)v(\\eta) \\right]_0^1 - \\int_0^1 v(\\eta) du(\\eta) $$\n$$ \\Delta_\\ell(k) = \\left[ S_X(k, \\eta) \\left(-\\frac{1}{k} J_\\ell^{(-1)}(k(1 - \\eta))\\right) \\right]_0^1 - \\int_0^1 \\left(-\\frac{1}{k} J_\\ell^{(-1)}(k(1 - \\eta))\\right) \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} \\, d\\eta $$\n让我们评估边界项部分，问题要求我们保留它：\n$$ \\left[ \\dots \\right]_0^1 = \\left( S_X(k, 1) \\left(-\\frac{1}{k} J_\\ell^{(-1)}(0)\\right) \\right) - \\left( S_X(k, 0) \\left(-\\frac{1}{k} J_\\ell^{(-1)}(k(1-0))\\right) \\right) $$\n使用我们的定义 $J_\\ell^{(-1)}(0) = 0$，第一部分消失：\n$$ \\left[ \\dots \\right]_0^1 = 0 - \\left( -\\frac{S_X(k, 0)}{k} J_\\ell^{(-1)}(k) \\right) = \\frac{S_X(k, 0)}{k} J_\\ell^{(-1)}(k) $$\n积分项简化为：\n$$ \\frac{1}{k} \\int_0^1 \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} J_\\ell^{(-1)}(k(1 - \\eta)) \\, d\\eta $$\n将边界项和积分项结合起来，得到最终的分部积分公式：\n$$ \\Delta_\\ell(k)_{\\text{IBP}} = \\frac{S_X(k, 0)}{k} \\int_0^k j_\\ell(y) \\, dy + \\frac{1}{k} \\int_0^1 \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} \\left( \\int_0^{k(1-\\eta)} j_\\ell(y) \\, dy \\right) d\\eta $$\n这就是要实现的严谨方案。它用一个涉及其反导数 $J_\\ell^{(-1)}$ 和源函数导数 $\\partial S_X/\\partial \\eta$ 的积分，替代了高度振荡的 $j_\\ell$ 的积分。\n\n### 2. 源函数及其导数\n\n问题定义了一个受物理启发的源函数 $S_X(k, \\eta)$，它是复合项 $S_{\\mathrm{rec}}(k,\\eta)$ 和晚期积分Sachs-Wolfe（ISW）项 $S_{\\mathrm{isw}}(\\eta)$ 的和：\n$$ S_X(k,\\eta) = S_{\\mathrm{rec}}(k,\\eta) + S_{\\mathrm{isw}}(\\eta) $$\n其中\n$$ S_{\\mathrm{rec}}(k,\\eta) = A_{\\mathrm{rec}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{rec}})^2}{2\\sigma_{\\mathrm{rec}}^2}\\right] \\cos\\!\\left(k c_s (\\eta-\\eta_{\\mathrm{rec}})\\right) $$\n$$ S_{\\mathrm{isw}}(\\eta) = A_{\\mathrm{isw}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{isw}})^2}{2\\sigma_{\\mathrm{isw}}^2}\\right] $$\nIBP方案所需的导数 $\\partial S_X / \\partial \\eta$ 通过对每一项求导得到。\nISW项的导数是：\n$$ \\frac{\\partial S_{\\mathrm{isw}}}{\\partial \\eta} = A_{\\mathrm{isw}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{isw}})^2}{2\\sigma_{\\mathrm{isw}}^2}\\right] \\cdot \\left( -\\frac{2(\\eta-\\eta_{\\mathrm{isw}})}{2\\sigma_{\\mathrm{isw}}^2} \\right) = -A_{\\mathrm{isw}} \\frac{(\\eta-\\eta_{\\mathrm{isw}})}{\\sigma_{\\mathrm{isw}}^2} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{isw}})^2}{2\\sigma_{\\mathrm{isw}}^2}\\right] $$\n复合项的导数需要使用乘法法则：\n$$ \\frac{\\partial S_{\\mathrm{rec}}}{\\partial \\eta} = \\frac{\\partial}{\\partial\\eta} \\left( A_{\\mathrm{rec}} \\exp\\left[\\dots\\right] \\cos\\left[\\dots\\right] \\right) $$\n$$ = A_{\\mathrm{rec}} \\left\\{ \\left( -\\frac{\\eta-\\eta_{\\mathrm{rec}}}{\\sigma_{\\mathrm{rec}}^2} \\exp[\\dots] \\right) \\cos[\\dots] + \\exp[\\dots] \\left( -k c_s \\sin[\\dots] \\right) \\right\\} $$\n$$ = -A_{\\mathrm{rec}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{rec}})^2}{2\\sigma_{\\mathrm{rec}}^2}\\right] \\left[ \\frac{\\eta-\\eta_{\\mathrm{rec}}}{\\sigma_{\\mathrm{rec}}^2} \\cos(k c_s (\\eta-\\eta_{\\mathrm{rec}})) + k c_s \\sin(k c_s (\\eta-\\eta_{\\mathrm{rec}})) \\right] $$\n这些关于 $S_X(k, \\eta)$ 和 $\\partial S_X(k,\\eta)/\\partial\\eta$ 的解析表达式将在数值代码中实现。\n\n### 3. 数值实现和稳定性测试\n\nIBP方案的数值稳定性验证将通过将其结果 $I_{\\mathrm{IBP}}$ 与原始积分的直接数值计算结果 $I_{\\mathrm{direct}}$进行比较来执行。\n\n**直接方法：**\n该积分使用标准的数值积分程序（`scipy.integrate.quad`）直接计算：\n$$ I_{\\mathrm{direct}} = \\int_0^1 S_X(k, \\eta) j_\\ell(k(1-\\eta)) \\, d\\eta $$\n\n**分部积分（IBP）方法：**\nIBP公式涉及嵌套积分。外层积分是关于 $\\eta$ 的，对于每个评估点 $\\eta$，都需要计算一个内层积分来找到贝塞尔函数反导数 $J_\\ell^{(-1)}$ 的值。\n$$ I_{\\mathrm{IBP}} = \\text{BoundaryTerm} + \\text{IntegralTerm} $$\n$$ \\text{BoundaryTerm} = \\frac{S_X(k, 0)}{k} J_\\ell^{(-1)}(k) = \\frac{S_X(k, 0)}{k} \\int_0^k j_\\ell(y) \\, dy $$\n$$ \\text{IntegralTerm} = \\frac{1}{k} \\int_0^1 \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} J_\\ell^{(-1)}(k(1 - \\eta)) \\, d\\eta = \\frac{1}{k} \\int_0^1 \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} \\left( \\int_0^{k(1 - \\eta)} j_\\ell(y) \\, dy \\right) d\\eta $$\n内层和外层积分都将使用 `scipy.integrate.quad` 计算。球贝塞尔函数 $j_\\ell(x)$ 将使用 `scipy.special.spherical_jn` 进行评估。\n\n**稳定性度量：**\n数值稳定性由两种方法之间的相对差异 $\\delta$ 来量化：\n$$ \\delta = \\frac{\\lvert I_{\\mathrm{IBP}} - I_{\\mathrm{direct}} \\rvert}{\\max\\left(\\lvert I_{\\mathrm{direct}} \\rvert, \\epsilon\\right)} $$\n使用一个小的常数 $\\epsilon = 10^{-15}$ 来防止除以零。如果计算出的 $\\delta$ 小于给定的阈值 $\\tau$，则认为一个测试用例是“稳定的”。此过程将对问题中指定的所有测试用例重复进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests an integration-by-parts (IBP) scheme for\n    CMB line-of-sight integrals.\n    \"\"\"\n    \n    # Define fixed parameters from the problem statement.\n    A_rec = 1.0\n    A_isw = 0.2\n    eta_rec = 0.3\n    eta_isw = 0.8\n    sigma_isw = 0.2\n    c_s = 0.5\n    eta0 = 1.0\n    eta_i = 0.0\n    epsilon = 1e-15\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'l': 50, 'k': 80, 'sigma_rec': 0.02, 'tau': 5e-3},\n        {'l': 150, 'k': 220, 'sigma_rec': 0.01, 'tau': 1e-2},\n        {'l': 300, 'k': 300, 'sigma_rec': 0.005, 'tau': 2e-2},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        l = case['l']\n        k = case['k']\n        sigma_rec = case['sigma_rec']\n        tau = case['tau']\n        \n        # 1. Define the source function and its derivative\n        def source_function(eta, k_val, sigma_rec_val):\n            # Recombination part\n            eta_diff_rec = eta - eta_rec\n            exp_rec = np.exp(-eta_diff_rec**2 / (2 * sigma_rec_val**2))\n            cos_rec = np.cos(k_val * c_s * eta_diff_rec)\n            s_rec = A_rec * exp_rec * cos_rec\n            \n            # ISW part\n            eta_diff_isw = eta - eta_isw\n            exp_isw = np.exp(-eta_diff_isw**2 / (2 * sigma_isw**2))\n            s_isw = A_isw * exp_isw\n            \n            return s_rec + s_isw\n\n        def source_derivative(eta, k_val, sigma_rec_val):\n            # Derivative of recombination part\n            eta_diff_rec = eta - eta_rec\n            exp_rec = np.exp(-eta_diff_rec**2 / (2 * sigma_rec_val**2))\n            \n            term1_rec = (eta_diff_rec / sigma_rec_val**2) * np.cos(k_val * c_s * eta_diff_rec)\n            term2_rec = (k_val * c_s) * np.sin(k_val * c_s * eta_diff_rec)\n            ds_rec_deta = -A_rec * exp_rec * (term1_rec + term2_rec)\n            \n            # Derivative of ISW part\n            eta_diff_isw = eta - eta_isw\n            ds_isw_deta = -A_isw * (eta_diff_isw / sigma_isw**2) * np.exp(-eta_diff_isw**2 / (2 * sigma_isw**2))\n            \n            return ds_rec_deta + ds_isw_deta\n            \n        S_X = lambda eta: source_function(eta, k, sigma_rec)\n        dS_X_deta = lambda eta: source_derivative(eta, k, sigma_rec)\n\n        # 2. Compute the direct integral\n        integrand_direct = lambda eta: S_X(eta) * spherical_jn(l, k * (eta0 - eta))\n        I_direct, _ = quad(integrand_direct, eta_i, eta0, limit=200)\n        \n        # 3. Compute the IBP integral\n        \n        # Helper function for the antiderivative of j_l(x)\n        # Using a cache dictionary for memoization to speed up nested integration,\n        # although quad's adaptive nature means it's not guaranteed to hit the same point.\n        j_antideriv_cache = {}\n        def j_antiderivative(x_max, ell):\n            if (x_max, ell) in j_antideriv_cache:\n                return j_antideriv_cache[(x_max, ell)]\n            if x_max == 0:\n                return 0.0\n            \n            # The integrand for the antiderivative\n            integrand = lambda y: spherical_jn(ell, y)\n            \n            # Numerical integration to get the antiderivative\n            # Use stricter tolerance for the inner integral for better accuracy\n            result, _ = quad(integrand, 0, x_max, limit=200, epsabs=1.49e-10, epsrel=1.49e-10)\n            j_antideriv_cache[(x_max, ell)] = result\n            return result\n        \n        # Boundary term\n        s0 = S_X(eta_i)\n        boundary_term = (s0 / k) * j_antiderivative(k, l) if k != 0 else 0\n        \n        # Integral term\n        integrand_ibp = lambda eta: dS_X_deta(eta) * j_antiderivative(k * (eta0 - eta), l)\n        \n        integral_term, _ = quad(integrand_ibp, eta_i, eta0, limit=200)\n        integral_term /= k\n\n        I_ibp = boundary_term + integral_term\n        \n        # 4. Calculate relative difference and determine stability\n        diff = abs(I_ibp - I_direct)\n        norm = max(abs(I_direct), epsilon)\n        delta = diff / norm\n        \n        is_stable = delta  tau\n        results.append(is_stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r for r in results]))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "即使算法正确，计算机浮点运算的有限精度也可能导致严重误差，尤其是在计算大量正负项之和的问题中。本练习  直面“灾难性相消”问题，即两个几乎相等的大数相减会导致相对精度的巨大损失。通过构建一个具有极端相消干涉的场景，本练习揭示了求和算法的简单改变如何决定了结果是正确还是纯粹的数值噪音，为我们上了关于数值计算素养的宝贵一课。",
            "id": "3478223",
            "problem": "你需要设计并实现一个数值实验，用于探究在计算宇宙微波背景（CMB）温度和偏振转移函数时所用的视线积分中的有效数字损失问题。其目标是量化累加策略对一个振荡的、由数值抵消主导的离散视线积分的影响，并证明补偿求和可以恢复那些在其他情况下会丢失的有效数字。程序必须是完全确定性的，并且不需要任何输入。\n\n从 CMB 转移函数的标准视线积分表示开始，在无量纲变量下，它可以写作\n$$\n\\Delta_{\\ell}^{X}(k) \\;=\\; \\int_{0}^{\\eta_0} S_X(k,\\eta)\\, j_{\\ell}\\!\\big(k(\\eta_0-\\eta)\\big)\\,\\mathrm{d}\\eta,\n$$\n其中 $\\Delta_{\\ell}^{X}(k)$ 是多极矩为 $\\ell$ 和傅里叶波数为 $k$ 的转移函数，$S_X(k,\\eta)$ 是一个有效源函数，$j_{\\ell}(\\cdot)$ 是第一类球贝塞尔函数，$\\eta$ 是共形时间，$\\eta_0$ 是当前的共形时间。假设使用无量纲单位，其中 $\\eta_0=1$，所有角度均为弧度，且不进行物理单位转换。\n\n你将不使用一个物理的 $S_X(k,\\eta)$；而是构造一个可控的、由抵消主导的、无量纲的示意源函数\n$$\nS_X(k,\\eta) \\;=\\; A_1 \\exp\\!\\Big(-\\frac{(\\eta-\\eta_a)^2}{2\\sigma^2}\\Big)\\cos\\!\\big(\\omega(\\eta-\\eta_a)\\big)\\;-\\;A_2 \\exp\\!\\Big(-\\frac{(\\eta-\\eta_b)^2}{2\\sigma^2}\\Big)\\cos\\!\\big(\\omega(\\eta-\\eta_b)\\big),\n$$\n其中 $A_1$、$A_2$、$\\eta_a$、$\\eta_b$、$\\sigma$ 和 $\\omega$ 为常数。用 $[0,\\eta_0]$ 上的 $N$ 个点，通过均匀黎曼和来近似该积分，\n$$\n\\Delta_{\\ell}^{X}(k) \\;\\approx\\; \\sum_{i=0}^{N-1} S_X\\!\\big(k,\\eta_i\\big)\\, j_{\\ell}\\!\\big(k(\\eta_0-\\eta_i)\\big)\\,\\Delta\\eta,\\quad \\eta_i = \\frac{i}{N-1}\\eta_0,\\quad \\Delta\\eta = \\frac{\\eta_0}{N-1}.\n$$\n\n实现并比较以下三种离散求和的累加策略：\n- 朴素双精度累加：以 $\\eta_i$ 的自然顺序，使用标准双精度（即 $\\texttt{float64}$）进行求和累加。\n- 混合精度累加：将每一项转换为单精度 $\\texttt{float32}$，并以 $\\eta_i$ 的自然顺序在 $\\texttt{float32}$ 中累加；为报告结果，将最终累加器转换回 $\\texttt{float64}$。\n- 补偿双精度累加（Kahan 求和）：以 $\\eta_i$ 的自然顺序，在 $\\texttt{float64}$ 中执行补偿求和。\n\n定义一个稳健的参考和，旨在通过按绝对值从小到大对各项进行排序，然后对排序后的序列应用补偿求和，来减少 $\\texttt{float64}$ 算术中数值抵消的影响。使用这个表示为 $S_{\\mathrm{ref}}$ 的参考值来评估数值误差。\n\n对于每种累加方法，定义其归一化误差\n$$\nE \\;=\\; \\frac{\\big|\\;S_{\\mathrm{acc}} - S_{\\mathrm{ref}}\\;\\big|}{\\sum_{i=0}^{N-1} \\big|t_i\\big|},\\quad t_i \\;=\\; S_X\\!\\big(k,\\eta_i\\big)\\, j_{\\ell}\\!\\big(k(\\eta_0-\\eta_i)\\big)\\,\\Delta\\eta,\n$$\n其中 $S_{\\mathrm{acc}}$ 是待测方法产生的累加和。此归一化方法衡量了相对于被积函数总变差所损失的有效数字，并且即使当 $S_{\\mathrm{ref}}$ 因相消干涉而接近于零时，它仍然有意义。\n\n实现你的程序来评估以下四个测试案例的误差。所有参数都是无量纲的。\n- 案例 1（强振荡与强抵消）：$\\ell=20$，$k=180.0$，$N=40000$，$\\eta_0=1.0$，$A_1=1.0$，$A_2=1.0$，\\,$\\eta_a=0.5$，\\,$\\eta_b=0.52$，\\,$\\sigma=0.01$，\\,$\\omega=1200.0$。\n- 案例 2（具有尖锐特征的单极）：$\\ell=0$，$k=250.0$，$N=30000$，$\\eta_0=1.0$，$A_1=1.0$，$A_2=1.0$，\\,$\\eta_a=0.6$，\\,$\\eta_b=0.601$，\\,$\\sigma=0.002$，\\,$\\omega=2000.0$。\n- 案例 3（振幅几乎相等导致的极端抵消）：$\\ell=50$，$k=400.0$，$N=50000$，$\\eta_0=1.0$，$A_1=1.0$，$A_2=0.999999$，\\,$\\eta_a=0.3$，\\,$\\eta_b=0.3005$，\\,$\\sigma=0.003$，\\,$\\omega=2500.0$。\n- 案例 4（温和振荡与有限抵消，类边界情况）：$\\ell=2$，$k=50.0$，$N=1000$，$\\eta_0=1.0$，$A_1=1.0$，$A_2=0.8$，\\,$\\eta_a=0.4$，\\,$\\eta_b=0.45$，\\,$\\sigma=0.02$，\\,$\\omega=100.0$。\n\n你的程序必须：\n- 按照规定为每个案例构造离散项 $t_i$。\n- 通过按绝对值对 $t_i$ 排序并对排序后的序列应用补偿求和来计算 $S_{\\mathrm{ref}}$。\n- 计算三种累加策略相对于 $S_{\\mathrm{ref}}$ 的归一化误差 $E$。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。结果必须按测试案例排序，每个案例包含三个数字，顺序为 $(E_{\\text{naive}},E_{\\text{mixed}},E_{\\text{Kahan}})$。具体来说，输出必须具有以下形式\n$$\n\\big[ E_{\\text{naive}}^{(1)}, E_{\\text{mixed}}^{(1)}, E_{\\text{Kahan}}^{(1)}, E_{\\text{naive}}^{(2)}, E_{\\text{mixed}}^{(2)}, E_{\\text{Kahan}}^{(2)}, E_{\\text{naive}}^{(3)}, E_{\\text{mixed}}^{(3)}, E_{\\text{Kahan}}^{(3)}, E_{\\text{naive}}^{(4)}, E_{\\text{mixed}}^{(4)}, E_{\\text{Kahan}}^{(4)} \\big].\n$$\n将每个数字格式化为包含 $12$ 位有效数字的科学记数法（例如，使用类似 $a\\times 10^{b}$ 的格式，渲染为 $a\\texttt{e}b$）。不应打印任何其他文本。\n\n所有计算都必须在无量纲单位下进行，所有角度都以弧度为单位。最终输出是无单位的纯数字。你的代码必须完全自包含，仅使用指定的库，并且不需要用户输入。",
            "solution": "用户提供的问题是一个有效且适定的数值实验。它在科学上植根于数值分析的原理及其在宇宙学计算中的应用，特别是宇宙微波背景（CMB）的视线积分。该问题是客观、自包含的，所有参数和方法都经过了足够严格的定义，从而能够得出一个唯一的、可验证的解。该实验旨在探究科学计算中的一个关键问题：浮点运算中因灾难性抵消而导致的有效数字损失。\n\n对于四个指定的测试案例，解决方案的实现遵循了一个结构化的数值流程。问题的核心是近似一个连续的振荡积分，并分析由不同求和技术产生的数值误差。\n\n首先，使用包含 $N$ 个点的均匀黎曼和将连续视线积分\n$$\n\\Delta_{\\ell}^{X}(k) \\;=\\; \\int_{0}^{\\eta_0} S_X(k,\\eta)\\, j_{\\ell}\\!\\big(k(\\eta_0-\\eta)\\big)\\,\\mathrm{d}\\eta,\n$$\n进行离散化。积分区间为 $[0, \\eta_0]$，其中 $\\eta_0=1.0$。离散点为 $\\eta_i = i \\cdot \\eta_0 / (N-1)$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$，步长为 $\\Delta\\eta = \\eta_0 / (N-1)$。这将积分转换为对离散项 $t_i$ 的有限求和：\n$$\n\\Delta_{\\ell}^{X}(k) \\;\\approx\\; \\sum_{i=0}^{N-1} t_i, \\quad \\text{其中} \\quad t_i \\;=\\; S_X\\!\\big(k,\\eta_i\\big)\\, j_{\\ell}\\!\\big(k(\\eta_0-\\eta_i)\\big)\\,\\Delta\\eta.\n$$\n所有计算都使用双精度浮点数（`float64`）执行，除非求和方法明确要求不同的精度。\n\n源函数 $S_X(k,\\eta)$ 是一个特制的“示意模型”，旨在创造严重数值抵消的条件：\n$$\nS_X(k,\\eta) \\;=\\; A_1 \\exp\\!\\Big(-\\frac{(\\eta-\\eta_a)^2}{2\\sigma^2}\\Big)\\cos\\!\\big(\\omega(\\eta-\\eta_a)\\big)\\;-\\;A_2 \\exp\\!\\Big(-\\frac{(\\eta-\\eta_b)^2}{2\\sigma^2}\\Big)\\cos\\!\\big(\\omega(\\eta-\\eta_b)\\big).\n$$\n它由两个几乎相同、快速振荡的高斯轮廓峰组成。当 $A_1 \\approx A_2$ 且位于 $\\eta_a$ 和 $\\eta_b$ 的峰值很接近时，它们的相减会得到一个比各自单项小很多数量级的值，这是灾难性抵消的典型场景。第一类球贝塞尔函数 $j_{\\ell}(x)$ 在自变量 $x = k(\\eta_0 - \\eta)$ 很大时也呈高度振荡，这加剧了数值计算的挑战。使用 `scipy.special.spherical_jn` 函数进行其计算。\n\n为了量化浮点误差的影响，实现并比较了三种求和策略：\n1.  **朴素双精度累加**：使用 `numpy.sum` 提供的标准 `float64` 累加器，按自然顺序对项 $t_i$ 进行求和。这种方法容易出现舍入误差，尤其是在将一个小数加到一个很大的累加和上时。\n2.  **混合精度累加**：首先将每个 `float64` 项 $t_i$ 转换为单精度（`float32`）。然后使用 `float32` 累加器执行求和。最终的和再转换回 `float64`。`float32` 减小的尾数位数预计会加剧精度损失。\n3.  **补偿双精度累加（Kahan 求和）**：该算法被实现用于减轻舍入误差。它维护一个运行中的补偿变量 $c$，用于跟踪每次加法中“丢失”的低位部分。在每一步中，一个项 $x$ 被加到和 $S$ 中，误差计算为 $c = ( (S_{\\mathrm{old}} + x) - S_{\\mathrm{old}}) - x$。在下一步中，这个误差会从下一个项中减去，然后再将其加到总和中，从而有效地重新注入丢失的精度。\n\n一个高保真度的参考和 $S_{\\mathrm{ref}}$ 对误差分析至关重要。它的计算方法是，首先按绝对值从小到大对项 $t_i$ 进行排序。这确保了数量级较小的项被首先相加，从而最大限度地减少了当它们最终被加到较大的累加和上时所损失的精度。排序后，对这个有序序列应用 Kahan 求和，提供一个高度准确的结果，作为本数值实验的“基准真相”。\n\n每种累加策略的性能通过一个归一化误差度量 $E$ 进行评估：\n$$\nE \\;=\\; \\frac{\\big|\\;S_{\\mathrm{acc}} - S_{\\mathrm{ref}}\\;\\big|}{\\sum_{i=0}^{N-1} \\big|t_i\\big|}.\n$$\n这里，$S_{\\mathrm{acc}}$ 是三种待测方法之一得到的和。分母 $\\sum |t_i|$ 代表所有项的绝对值之和，它近似于抵消发生前求和过程中的总“活动量”或变差。这种归一化方法是稳健的：它提供了一个有意义的度量，用于衡量丢失的有效数字的比例，并且如果真实和 $S_{\\mathrm{ref}}$ 恰好接近于零，它也能避免除以零的问题。\n\n程序遍历四个指定的测试案例，每个案例都有不同的参数，旨在探究不同的振荡和抵消机制。对于每个案例，它会计算项 $t_i$、参考和 $S_{\\mathrm{ref}}$、三个累加和（$S_{\\text{naive}}, S_{\\text{mixed}}, S_{\\text{Kahan}}$），以及最后对应的归一化误差（$E_{\\text{naive}}, E_{\\text{mixed}}, E_{\\text{Kahan}}$）。这些误差被收集并按要求格式化为单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment on summation strategies\n    for a cancellation-dominated line-of-sight integral.\n    \"\"\"\n\n    def kahan_sum(arr: np.ndarray) - np.float64:\n        \"\"\"\n        Performs Kahan compensated summation on a numpy array of float64.\n        \"\"\"\n        s_sum = np.float64(0.0)\n        c = np.float64(0.0)\n        for x in arr:\n            y = np.float64(x - c)\n            t = np.float64(s_sum + y)\n            c = np.float64((t - s_sum) - y)\n            s_sum = t\n        return s_sum\n\n    def source_function(eta: np.ndarray, A1: float, A2: float, eta_a: float, eta_b: float, sigma: float, omega: float) - np.ndarray:\n        \"\"\"\n        Computes the toy source function S_X(k, eta).\n        \"\"\"\n        term1 = A1 * np.exp(-((eta - eta_a)**2) / (2 * sigma**2)) * np.cos(omega * (eta - eta_a))\n        term2 = A2 * np.exp(-((eta - eta_b)**2) / (2 * sigma**2)) * np.cos(omega * (eta - eta_b))\n        return term1 - term2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: strong oscillations and cancellation\n        {'ell': 20, 'k': 180.0, 'N': 40000, 'eta_0': 1.0, 'A1': 1.0, 'A2': 1.0, 'eta_a': 0.5, 'eta_b': 0.52, 'sigma': 0.01, 'omega': 1200.0},\n        # Case 2: monopole with sharp features\n        {'ell': 0, 'k': 250.0, 'N': 30000, 'eta_0': 1.0, 'A1': 1.0, 'A2': 1.0, 'eta_a': 0.6, 'eta_b': 0.601, 'sigma': 0.002, 'omega': 2000.0},\n        # Case 3: extreme cancellation with near-equal amplitudes\n        {'ell': 50, 'k': 400.0, 'N': 50000, 'eta_0': 1.0, 'A1': 1.0, 'A2': 0.999999, 'eta_a': 0.3, 'eta_b': 0.3005, 'sigma': 0.003, 'omega': 2500.0},\n        # Case 4: mild oscillation and limited cancellation\n        {'ell': 2, 'k': 50.0, 'N': 1000, 'eta_0': 1.0, 'A1': 1.0, 'A2': 0.8, 'eta_a': 0.4, 'eta_b': 0.45, 'sigma': 0.02, 'omega': 100.0},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack parameters\n        l, k, N = case['ell'], case['k'], case['N']\n        eta_0, A1, A2 = case['eta_0'], case['A1'], case['A2']\n        eta_a, eta_b = case['eta_a'], case['eta_b']\n        sigma, omega = case['sigma'], case['omega']\n        \n        # Create conformal time grid\n        eta = np.linspace(0.0, eta_0, N, dtype=np.float64, endpoint=True)\n        delta_eta = eta_0 / (N - 1)\n        \n        # Calculate the terms t_i of the Riemann sum\n        s_vals = source_function(eta, A1, A2, eta_a,eta_b, sigma, omega)\n        bessel_args = k * (eta_0 - eta)\n        bessel_vals = spherical_jn(l, bessel_args)\n        terms = (s_vals * bessel_vals * delta_eta).astype(np.float64)\n\n        # 1. COMPUTE REFERENCE SUM (S_ref)\n        # Sort terms by absolute value and apply Kahan summation\n        sorted_indices = np.argsort(np.abs(terms))\n        sorted_terms = terms[sorted_indices]\n        s_ref = kahan_sum(sorted_terms)\n\n        # 2. COMPUTE NORMALIZATION FACTOR\n        # Sum of absolute values of terms. Naive sum is fine for this.\n        sum_abs_terms = np.sum(np.abs(terms))\n\n        if sum_abs_terms == 0.0:\n            e_naive, e_mixed, e_kahan = 0.0, 0.0, 0.0\n        else:\n            # 3. COMPUTE SUMS WITH DIFFERENT STRATEGIES\n\n            # Naive double-precision sum\n            s_naive = np.sum(terms)\n\n            # Mixed-precision sum\n            terms_f32 = terms.astype(np.float32)\n            s_mixed_f32 = np.sum(terms_f32)\n            s_mixed = np.float64(s_mixed_f32)\n\n            # Compensated double-precision sum (Kahan)\n            s_kahan = kahan_sum(terms)\n            \n            # 4. COMPUTE NORMALIZED ERRORS\n            e_naive = np.abs(s_naive - s_ref) / sum_abs_terms\n            e_mixed = np.abs(s_mixed - s_ref) / sum_abs_terms\n            e_kahan = np.abs(s_kahan - s_ref) / sum_abs_terms\n        \n        results.extend([e_naive, e_mixed, e_kahan])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.11e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}