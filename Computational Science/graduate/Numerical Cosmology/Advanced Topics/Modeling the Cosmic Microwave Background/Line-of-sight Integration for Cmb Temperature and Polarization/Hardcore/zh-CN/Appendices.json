{
    "hands_on_practices": [
        {
            "introduction": "在处理复杂的物理源函数之前，验证我们的数值积分器能够正确处理振荡函数至关重要。这个实践练习使用了一些简单的解析源函数，其对应的视线积分具有已知的解析解。通过将我们的数值结果与这些精确解进行比较，我们可以为积分程序的准确性建立基准，并理解其在不同振荡和源函数形态下的表现。",
            "id": "3478222",
            "problem": "考虑温度和极化多极矩的宇宙微波背景（CMB; Cosmic Microwave Background）视线表示法。在视线法中，对于给定的波数 $\\,k\\,$ 和多极矩指数 $\\,\\ell\\,$，多极矩传递函数 $\\,\\Theta_\\ell(k)\\,$ 表示为共形时间 $\\,\\eta\\,$ 的积分，\n$$\n\\Theta_\\ell(k) \\;=\\; \\int_{0}^{\\eta_0} S(k,\\eta)\\, j_\\ell\\!\\left(k\\,(\\eta_0-\\eta)\\right)\\, d\\eta,\n$$\n其中 $\\,\\eta_0\\,$ 是当今的共形时间，$\\,S(k,\\eta)\\,$ 是一个解析源项，$\\,j_\\ell(x)\\,$ 是 $\\,\\ell\\,$ 阶第一类球贝塞尔函数。\n\n从上述在数值宇宙学中广泛使用且经过充分检验的视线积分公式，以及分布和特殊函数的标准性质出发，实现一个基准测试来评估振荡积分的准确性。该基准测试应建立在解析源 $\\,S(k,\\eta)\\,$ 的基础上，对于这些源，积分要么具有闭式表达式，要么可以简化为球贝塞尔函数的已知变换。目标是根据已知结果验证数值收敛性，并为逐渐增强的振荡积分和尖锐峰值源量化准确性。\n\n您必须实现以下解析源及相关的期望值：\n\n1.  一个均匀源 $\\,S_U(k,\\eta) = C\\,$，在 $\\,\\eta\\in[0,\\eta_0]\\,$ 上具有恒定振幅 $\\,C\\,$。对于 $\\,\\ell=0\\,$，在进行变量替换 $\\,x=k(\\eta_0-\\eta)\\,$ 后，积分简化为一个已知的 $\\,j_0(x)=\\sin(x)/x\\,$ 的积分：\n$$\n\\Theta_0^{U}(k) \\;=\\; \\frac{C}{k}\\,\\int_{0}^{k\\eta_0} j_0(x)\\,dx \\;=\\; \\frac{C}{k}\\,\\mathrm{Si}(k\\eta_0),\n$$\n其中 $\\,\\mathrm{Si}(x) = \\int_0^x \\frac{\\sin t}{t}\\,dt\\,$ 是正弦积分。使用此闭式形式计算期望值。\n\n2.  一个近似于狄拉克-德尔塔分布的窄高斯源，\n$$\nS_G(k,\\eta) \\;=\\; \\frac{A}{\\sqrt{2\\pi}\\,\\sigma}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right),\n$$\n其振幅为 $\\,A\\,$，中心为 $\\,\\eta_s\\,$，宽度为 $\\,\\sigma\\,$。当 $\\,\\sigma\\to 0\\,$ 且 $\\,\\eta_s\\in(0,\\eta_0)\\,$ 时，根据柔化子近似狄拉克-德尔塔分布的标准性质，积分收敛于\n$$\n\\Theta_\\ell^{G}(k) \\;\\to\\; A\\, j_\\ell\\!\\left(k(\\eta_0-\\eta_s)\\right),\n$$\n\n3.  一个近似于狄拉克-德尔塔分布导数的高斯导数源，\n$$\nS_{G'}(k,\\eta) \\;=\\; B\\,\\frac{d}{d\\eta}\\!\\left[\\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right)\\right]\n\\;=\\; -\\,B\\,\\frac{\\eta-\\eta_s}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right),\n$$\n其振幅为 $\\,B\\,$。使用分布恒等式 $\\,\\int \\delta'(\\eta-\\eta_s) f(\\eta)\\,d\\eta = -f'(\\eta_s)\\,$ 和链式法则 $\\,\\frac{d}{d\\eta} j_\\ell(k(\\eta_0-\\eta))=-k\\,j_\\ell'(k(\\eta_0-\\eta))\\,$, 当 $\\,\\sigma\\to 0\\,$ 时，积分收敛于\n$$\n\\Theta_\\ell^{G'}(k) \\;\\to\\; B\\,k\\, j_\\ell'\\!\\left(k(\\eta_0-\\eta_s)\\right),\n$$\n其中 $\\,j_\\ell'(x)\\,$ 表示球贝塞尔函数对其自变量的导数。\n\n实现一个程序，该程序：\n- 使用视线积分的直接求积法，对上述源数值计算 $\\,\\Theta_\\ell(k)\\,$。\n- 按规定计算相应的解析或渐近期望值。\n- 报告由下式定义的相对误差\n$$\n\\epsilon_{\\mathrm{rel}} \\;=\\; \\frac{\\left|\\Theta_\\ell^{\\mathrm{num}}(k) - \\Theta_\\ell^{\\mathrm{exp}}(k)\\right|}{\\max\\!\\left(\\left|\\Theta_\\ell^{\\mathrm{exp}}(k)\\right|,\\,10^{-12}\\right)}.\n$$\n\n所有变量都是无量纲的；不需要物理单位。如果涉及角度，应以弧度处理。\n\n您的测试套件必须包含以下参数集以测试不同的情况：\n- 均匀源，理想情况： $\\,(\\ell=0,\\,k=15.0,\\,\\eta_0=2.0,\\,C=1.0)\\,$。\n- 均匀源，强振荡： $\\,(\\ell=0,\\,k=80.0,\\,\\eta_0=1.5,\\,C=0.7)\\,$。\n- 高斯源，趋近于狄拉克-德尔塔（中等窄度）： $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.2)\\,$。\n- 高斯源，趋近于狄拉克-德尔塔（更窄）： $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.1)\\,$。\n- 高斯源，趋近于狄拉克-德尔塔（非常窄）： $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.05)\\,$。\n- 高斯导数源，趋近于 $\\,\\delta'\\,$（中等窄度）： $\\,(\\ell=3,\\,k=20.0,\\,\\eta_0=1.2,\\,B=0.8,\\,\\eta_s=0.6,\\,\\sigma=0.2)\\,$。\n- 高斯导数源，趋近于 $\\,\\delta'\\,$（更窄）： $\\,(\\ell=3,\\,k=20.0,\\,\\eta_0=1.2,\\,B=0.8,\\,\\eta_s=0.6,\\,\\sigma=0.1)\\,$。\n- 边界附近的高斯源，以测试截断效应： $\\,(\\ell=0,\\,k=30.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.1,\\,\\sigma=0.05)\\,$。\n\n您的程序应生成单行输出，其中包含上述八个相对误差，按所列顺序排列，格式为方括号内以逗号分隔的列表（例如，“[e1,e2,e3,e4,e5,e6,e7,e8]”）。",
            "solution": "用户希望验证并解决一个来自数值宇宙学的问题。\n\n### 步骤 1：提取给定信息\n\n问题提供了以下定义、公式和数据：\n\n1.  **视线积分：**\n    $$\n    \\Theta_\\ell(k) \\;=\\; \\int_{0}^{\\eta_0} S(k,\\eta)\\, j_\\ell\\!\\left(k\\,(\\eta_0-\\eta)\\right)\\, d\\eta\n    $$\n2.  **均匀源 $\\,S_U\\,$ 及期望值 $\\,\\Theta_0^U\\,$：**\n    -   源： $\\,S_U(k,\\eta) = C\\,$，对于 $\\,\\eta\\in[0,\\eta_0]\\,$。\n    -   $\\,\\ell=0\\,$ 时的期望值： $\\,\\Theta_0^{U}(k) = \\frac{C}{k}\\,\\mathrm{Si}(k\\eta_0)\\,$，其中 $\\,\\mathrm{Si}(x) = \\int_0^x \\frac{\\sin t}{t}\\,dt\\,$。\n\n3.  **高斯源 $\\,S_G\\,$ 及渐近值 $\\,\\Theta_\\ell^G\\,$：**\n    -   源： $\\,S_G(k,\\eta) = \\frac{A}{\\sqrt{2\\pi}\\,\\sigma}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right)\\,$。\n    -   $\\,\\sigma\\to 0\\,$ 时的渐近值： $\\,\\Theta_\\ell^{G}(k) \\to A\\, j_\\ell\\!\\left(k(\\eta_0-\\eta_s)\\right)\\,$。\n\n4.  **高斯导数源 $\\,S_{G'}\\,$ 及渐近值 $\\,\\Theta_\\ell^{G'}\\,$：**\n    -   源： $\\,S_{G'}(k,\\eta) = -\\,B\\,\\frac{\\eta-\\eta_s}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right)\\,$。\n    -   $\\,\\sigma\\to 0\\,$ 时的渐近值： $\\,\\Theta_\\ell^{G'}(k) \\to B\\,k\\, j_\\ell'\\!\\left(k(\\eta_0-\\eta_s)\\right)\\,$。\n\n5.  **相对误差定义：**\n    $$\n    \\epsilon_{\\mathrm{rel}} \\;=\\; \\frac{\\left|\\Theta_\\ell^{\\mathrm{num}}(k) - \\Theta_\\ell^{\\mathrm{exp}}(k)\\right|}{\\max\\!\\left(\\left|\\Theta_\\ell^{\\mathrm{exp}}(k)\\right|,\\,10^{-12}\\right)}\n    $$\n\n6.  **测试用例（共8个）：**\n    -   用例 1 (均匀源): $\\,(\\ell=0,\\,k=15.0,\\,\\eta_0=2.0,\\,C=1.0)\\,$\n    -   用例 2 (均匀源): $\\,(\\ell=0,\\,k=80.0,\\,\\eta_0=1.5,\\,C=0.7)\\,$\n    -   用例 3 (高斯源): $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.2)\\,$\n    -   用例 4 (高斯源): $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.1)\\,$\n    -   用例 5 (高斯源): $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.05)\\,$\n    -   用例 6 (高斯导数源): $\\,(\\ell=3,\\,k=20.0,\\,\\eta_0=1.2,\\,B=0.8,\\,\\eta_s=0.6,\\,\\sigma=0.2)\\,$\n    -   用例 7 (高斯导数源): $\\,(\\ell=3,\\,k=20.0,\\,\\eta_0=1.2,\\,B=0.8,\\,\\eta_s=0.6,\\,\\sigma=0.1)\\,$\n    -   用例 8 (高斯源): $\\,(\\ell=0,\\,k=30.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.1,\\,\\sigma=0.05)\\,$\n\n### 步骤 2：使用提取的给定信息进行验证\n\n对问题进行严格的验证检查：\n\n-   **科学依据：** 该问题基于视线积分法，这是现代数值宇宙学计算CMB各向异性的基石。$\\,\\Theta_\\ell(k)\\,$ 的积分形式是标准的。在计算科学中，使用解析源函数为数值代码创建基准是一种常见且有效的方法。给出的具体解析和渐近极限是正确的：\n    -   $\\,j_0(x)\\,$ 的积分确实是正弦积分 $\\,\\mathrm{Si}(x)\\,$。\n    -   窄高斯函数可作为狄拉克-德尔塔分布 $\\,\\delta(\\eta-\\eta_s)\\,$ 的标准近似（柔化子），$\\,\\sigma \\to 0\\,$ 的极限正确地恢复了德尔塔函数的筛选性质。\n    -   窄高斯的导数近似于狄拉克-德尔塔的导数 $\\,\\delta'(\\eta-\\eta_s)\\,$，并且所述结果正确地使用了积分性质 $\\,\\int f(x)\\delta'(x-x_s)dx = -f'(x_s)\\,$。其数学和物理基础是可靠的。\n\n-   **适定性：** 该问题是适定的。它要求将数值计算结果与一个明确定义的解析或渐近表达式进行比较。八个测试用例中的每一个都明确提供了两种计算所需的所有参数。相对误差的定义明确无误，并包含防止除以零或极小数的保护措施，这是一个结构良好的数值问题的标志。\n\n-   **客观性：** 问题陈述完全客观，用精确的数学和物理语言表达。它没有歧义、主观论断或观点。\n\n基于此分析，该问题没有表现出验证标准中列出的任何缺陷。它在科学上是可靠的，形式上是明确的，完整的和客观的。\n\n### 步骤 3：结论与行动\n\n问题有效。将提供一个解决方案。\n\n目标是数值计算视线积分 $\\,\\Theta_\\ell(k)\\,$，并通过计算相对误差将结果与相应的解析或渐近公式进行比较。这可作为评估数值积分技术在处理CMB物理学中遇到的振荡函数和尖峰函数时的准确性的基准。\n\n解决方案的核心是数值求积算法。标准科学库中的一个合适选择是 `scipy.integrate.quad` 函数，它实现了一种自适应求积方案，能够处理各种各样的被积函数，包括这里涉及的振荡函数。对于每个测试用例，解决方案涉及以下步骤：定义被积函数，执行数值积分，计算期望值，以及计算相对误差。\n\n首先，我们为三个源项 $\\,S_U(k,\\eta)\\,$、$\\,S_G(k,\\eta)\\,$ 和 $\\,S_{G'}(k,\\eta)\\,$ 定义Python函数，直接转录它们的数学定义。\n\n对于数值计算 $\\,\\Theta_\\ell^{\\mathrm{num}}(k)\\,$，我们构建被积函数，即相应源函数 $\\,S(k,\\eta)\\,$ 与球贝塞尔函数 $\\,j_\\ell(k(\\eta_0-\\eta))\\,$ 的乘积。`scipy.special.spherical_jn` 函数提供了 $\\,j_\\ell(x)\\,$ 的值。然后我们将此被积函数连同积分限 $\\,[0, \\eta_0]\\,$ 传递给 `scipy.integrate.quad`。对于强振荡情况（用例2，其中 $\\,k\\eta_0=120\\,$），审慎的做法是增加 `quad` 的 `limit` 参数，以允许更多的子区间来精确解析振荡。\n\n接下来，我们实现计算期望值 $\\,\\Theta_\\ell^{\\mathrm{exp}}(k)\\,$ 的函数。\n1.  对于 $\\,\\ell=0\\,$ 的均匀源，期望值 $\\,\\Theta_0^U(k)\\,$ 是使用 `scipy.special.sici` 提供的正弦积分函数计算的，该函数返回一个包含正弦和余弦积分的元组；我们使用第一个元素。\n2.  对于高斯源，渐近值 $\\,\\Theta_\\ell^G(k)\\,$ 是通过在自变量 $\\,k(\\eta_0-\\eta_s)\\,$ 处求值 `scipy.special.spherical_jn` 来计算的。正如测试用例3、4和5所示，随着宽度 $\\,\\sigma\\,$ 的减小，该近似的准确性提高。测试用例8通过将高斯源的峰值置于积分边界附近来探究其截断效应的影响。\n3.  对于高斯导数源，渐近值 $\\,\\Theta_\\ell^{G'}(k)\\,$ 需要球贝塞尔函数的导数 $\\,j_\\ell'(x)\\,$。通过使用可选参数 `derivative=True` 调用 `scipy.special.spherical_jn` 可以方便地获得此导数。\n\n最后，对于每个测试用例，使用数值结果 $\\,\\Theta_\\ell^{\\mathrm{num}}(k)\\,$ 和期望值 $\\,\\Theta_\\ell^{\\mathrm{exp}}(k)\\,$ 根据指定公式计算相对误差 $\\,\\epsilon_{\\mathrm{rel}}\\,$。分母中的 `max` 函数可以防止当 $\\,\\Theta_\\ell^{\\mathrm{exp}}(k)\\,$ 接近零时出现数值不稳定性。将所有八个情况计算出的误差收集起来，并格式化为所需的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import sici, spherical_jn\n\ndef solve():\n    \"\"\"\n    Numerically evaluates the CMB line-of-sight integral for various analytic\n    source functions and computes the relative error against known\n    analytic or asymptotic solutions.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Uniform source, happy path\n        {'type': 'U', 'params': {'ell': 0, 'k': 15.0, 'eta0': 2.0, 'C': 1.0}},\n        # 2. Uniform source, strongly oscillatory\n        {'type': 'U', 'params': {'ell': 0, 'k': 80.0, 'eta0': 1.5, 'C': 0.7}},\n        # 3. Gaussian source, moderately narrow\n        {'type': 'G', 'params': {'ell': 2, 'k': 25.0, 'eta0': 1.0, 'A': 1.0, 'eta_s': 0.5, 'sigma': 0.2}},\n        # 4. Gaussian source, narrower\n        {'type': 'G', 'params': {'ell': 2, 'k': 25.0, 'eta0': 1.0, 'A': 1.0, 'eta_s': 0.5, 'sigma': 0.1}},\n        # 5. Gaussian source, very narrow\n        {'type': 'G', 'params': {'ell': 2, 'k': 25.0, 'eta0': 1.0, 'A': 1.0, 'eta_s': 0.5, 'sigma': 0.05}},\n        # 6. Derivative-of-Gaussian source, moderately narrow\n        {'type': 'Gp', 'params': {'ell': 3, 'k': 20.0, 'eta0': 1.2, 'B': 0.8, 'eta_s': 0.6, 'sigma': 0.2}},\n        # 7. Derivative-of-Gaussian source, narrower\n        {'type': 'Gp', 'params': {'ell': 3, 'k': 20.0, 'eta0': 1.2, 'B': 0.8, 'eta_s': 0.6, 'sigma': 0.1}},\n        # 8. Gaussian source, near boundary\n        {'type': 'G', 'params': {'ell': 0, 'k': 30.0, 'eta0': 1.0, 'A': 1.0, 'eta_s': 0.1, 'sigma': 0.05}},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        p = case['params']\n        \n        # 1. Set up the integrand for numerical integration\n        integrand = None\n        if case['type'] == 'U':\n            ell, k, eta0, C = p['ell'], p['k'], p['eta0'], p['C']\n            source_func = lambda eta: C\n            integrand = lambda eta: source_func(eta) * spherical_jn(ell, k * (eta0 - eta))\n        \n        elif case['type'] == 'G':\n            ell, k, eta0, A, eta_s, sigma = p['ell'], p['k'], p['eta0'], p['A'], p['eta_s'], p['sigma']\n            norm = 1.0 / (np.sqrt(2 * np.pi) * sigma)\n            source_func = lambda eta: A * norm * np.exp(-(eta - eta_s)**2 / (2 * sigma**2))\n            integrand = lambda eta: source_func(eta) * spherical_jn(ell, k * (eta0 - eta))\n        \n        elif case['type'] == 'Gp':\n            ell, k, eta0, B, eta_s, sigma = p['ell'], p['k'], p['eta0'], p['B'], p['eta_s'], p['sigma']\n            norm_cubed = 1.0 / (np.sqrt(2 * np.pi) * sigma**3)\n            source_func = lambda eta: -B * (eta - eta_s) * norm_cubed * np.exp(-(eta - eta_s)**2 / (2 * sigma**2))\n            integrand = lambda eta: source_func(eta) * spherical_jn(ell, k * (eta0 - eta))\n\n        # 2. Perform the numerical integration\n        # For the highly oscillatory case, increase the subdivision limit\n        quad_limit = 50\n        if case['type'] == 'U' and p['k'] * p['eta0'] > 100:\n            quad_limit = 200\n        \n        theta_num = quad(integrand, 0, p['eta0'], limit=quad_limit)[0]\n\n        # 3. Calculate the expected (analytic or asymptotic) value\n        theta_exp = 0.0\n        if case['type'] == 'U':\n            k, eta0, C = p['k'], p['eta0'], p['C']\n            # The formula is specified for ell=0\n            if p['ell'] == 0:\n                theta_exp = C / k * sici(k * eta0)[0]\n        \n        elif case['type'] == 'G':\n            ell, k, eta0, A, eta_s = p['ell'], p['k'], p['eta0'], p['A'], p['eta_s']\n            theta_exp = A * spherical_jn(ell, k * (eta0 - eta_s))\n        \n        elif case['type'] == 'Gp':\n            ell, k, eta0, B, eta_s = p['ell'], p['k'], p['eta0'], p['B'], p['eta_s']\n            theta_exp = B * k * spherical_jn(ell, k * (eta0 - eta_s), derivative=True)\n            \n        # 4. Calculate the relative error\n        denominator = np.max([np.abs(theta_exp), 1e-12])\n        rel_err = np.abs(theta_num - theta_exp) / denominator\n        results.append(rel_err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "直接对高度振荡的被积函数进行积分可能效率低下且数值不稳定，尤其是在高多极矩 $\\ell$ 和高波数 $k$ 的情况下。本练习介绍了一种更先进的数值技术——分部积分法（IBP），通过将被积函数中的导数从振荡的球贝塞尔函数转移到变化较平缓的源函数上，从而改善收敛性和稳定性。你将亲自推导分部积分公式，并使用一个模拟宇宙复合时期尖锐特征的源函数来检验该方法的有效性。",
            "id": "3478268",
            "problem": "您的任务是为宇宙微波背景（CMB）温度和偏振计算中使用的视线投影开发并验证一种数值分部积分方案。目标是将导数从振荡的球贝塞尔函数转移到源函数上，以提高数值稳定性。您的工作必须从宇宙学和应用数学中公认的基础理论出发，不得假设任何未经证实或临时拼凑的公式。\n\n需要使用的基本依据是：\n- 光子玻尔兹曼方程层次可以转化为多极矩传递函数的视线积分表示。该表示将多极矩传递函数表示为一个积分，积分内容为源函数乘以球贝塞尔函数，其变量是波数与共形时间差的乘积，积分变量为共形时间。\n- 球贝塞尔函数 $j_\\ell(x)$ 是在球坐标系下分离亥姆霍兹方程变量时出现的标准特殊函数，并且是球贝塞尔微分方程的一个解。众所周知，其在大宗量和高阶数下的振荡特性会在直接求积中导致数值计算上的挑战。\n\n您的任务是：\n1. 对于一个通用的多极矩 $\\ell$ 和波数 $k$，通过对共形时间进行分部积分，推导出一个数学上严谨的方案，该方案将视线积分中球贝塞尔函数因子的导数转移到源函数 $S_X(k,\\eta)$ 上。推导必须从标准的视线积分表达式开始，且仅使用球贝塞尔函数的性质和基本微积分。您不得引入任何未被这些基础所证明的简化公式。清晰地指出所有出现的边界项，并解释为何要保留它们。\n2. 设计并实现一个数值算法，该算法能同时计算以下两者：\n   - 使用直接求积法计算的原始（直接）视线积分。\n   - 您通过分部积分重构的公式，其中使用源函数的导数以及从您的推导中得到的球贝塞尔函数的反导数。\n3. 构建一个受物理启发、无量纲的源函数模型 $S_X(k,\\eta)$，该模型能模拟复合时期（recombination）的尖锐特征，同时保持光滑（连续可微），以确保其导数存在。使用以下形式：\n   - 一个以共形时间 $\\eta_{\\mathrm{rec}}$ 为中心、窄宽度为 $\\sigma_{\\mathrm{rec}}$ 的复合峰，并带有角频率与 $k$ 成正比的声学振荡调制：\n     $$S_{\\mathrm{rec}}(k,\\eta) = A_{\\mathrm{rec}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{rec}})^2}{2\\sigma_{\\mathrm{rec}}^2}\\right] \\cos\\!\\left(\\alpha(k)\\,(\\eta-\\eta_{\\mathrm{rec}})\\right),$$\n     其中 $\\alpha(k)$ 通过一个恒定的声速 $c_s$ 与 $k$ 成正比。\n   - 一个以 $\\eta_{\\mathrm{isw}}$ 为中心、宽度为 $\\sigma_{\\mathrm{isw}}$ 的宽阔的类积分Sachs–Wolfe效应晚期贡献：\n     $$S_{\\mathrm{isw}}(\\eta) = A_{\\mathrm{isw}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{isw}})^2}{2\\sigma_{\\mathrm{isw}}^2}\\right].$$\n   - 总源函数是两者之和 $S_X(k,\\eta) = S_{\\mathrm{rec}}(k,\\eta) + S_{\\mathrm{isw}}(\\eta)$。\n   提供 $\\partial S_X/\\partial \\eta$ 的解析表达式，并在您的分部积分方案中使用它们。所有三角函数参数必须使用弧度制。\n4. 通过将当前共形时间归一化为 $\\eta_0=1$ 并将积分起始时间设为 $\\eta_i=0$，以无量纲单位实现计算。根据您的方案酌情使用变量替换 $x=k(\\eta_0-\\eta)$。不需要物理单位；所有量均为无量纲。\n5. 根据直接积分和分部积分结果之间的相对差异来定义数值稳定性。对于给定的一对输出 $I_{\\mathrm{direct}}$ 和 $I_{\\mathrm{IBP}}$，相对差异定义为\n   $$\\delta = \\frac{\\lvert I_{\\mathrm{IBP}} - I_{\\mathrm{direct}} \\rvert}{\\max\\left(\\lvert I_{\\mathrm{direct}} \\rvert, \\epsilon\\right)},$$\n   其中 $\\epsilon$ 是一个小的正数以避免除以零，您必须明确指定其值。\n6. 使用您的实现，对以下测试套件评估相对差异 $\\delta$，该套件涵盖了一般行为和尖锐特征的边缘情况：\n   - 测试用例 1 (正常路径): $\\ell=50$, $k=80$, $\\sigma_{\\mathrm{rec}}=0.02$, 阈值 $\\tau=5\\times10^{-3}$。\n   - 测试用例 2 (更高多极矩和更尖锐特征): $\\ell=150$, $k=220$, $\\sigma_{\\mathrm{rec}}=0.01$, 阈值 $\\tau=10^{-2}$。\n   - 测试用例 3 (边缘情况，非常尖锐的复合峰): $\\ell=300$, $k=300$, $\\sigma_{\\mathrm{rec}}=0.005$, 阈值 $\\tau=2\\times10^{-2}$。\n   使用固定参数 $A_{\\mathrm{rec}}=1$, $A_{\\mathrm{isw}}=0.2$, $\\eta_{\\mathrm{rec}}=0.3$, $\\eta_{\\mathrm{isw}}=0.8$, $\\sigma_{\\mathrm{isw}}=0.2$, $c_s=0.5$, $\\eta_0=1$, $\\eta_i=0$, 以及 $\\epsilon=10^{-15}$。\n7. 对每个测试用例，返回一个布尔值以指示其稳定性，稳定性定义为 $\\delta  \\tau$。\n8. 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[$\\text{result1},\\text{result2},\\text{result3}$]”）。列表中的条目必须是上述三个测试用例的三个布尔值，并按给定顺序排列。\n\n您的最终答案必须是一个完整的、可运行的 Python 程序，该程序执行计算并按指定格式打印结果。角度必须使用弧度制，所有量均为无量纲。",
            "solution": "用户提供了一个来自数值宇宙学领域的问题，要求我推导、实现并测试一种用于计算宇宙微波背景（CMB）视线积分的分部积分（IBP）方案。该问题在科学上是合理的，定义明确，并且提供了所有必要的参数和定义。因此，我将着手提供一个完整的解决方案。\n\n解决方案包括三个主要阶段：\n1.  视线积分的分部积分公式的数学推导。\n2.  源函数及其导数的解析定义。\n3.  设计一个数值算法来计算直接积分与IBP公式的结果，并进行比较。\n\n### 1. 分部积分方案的数学推导\n\n一个通用的CMB多极矩传递函数 $\\Delta_\\ell(k)$ 的基本视线积分由下式给出：\n$$ \\Delta_\\ell(k) = \\int_{\\eta_i}^{\\eta_0} S_X(k, \\eta) j_\\ell(k(\\eta_0 - \\eta)) \\, d\\eta $$\n这里，$S_X(k, \\eta)$ 是给定波数 $k$ 在共形时间 $\\eta$ 的源函数，$j_\\ell$ 是 $\\ell$ 阶球贝塞尔函数，积分范围从初始时间 $\\eta_i$ 到当前时间 $\\eta_0$。问题指定了无量纲单位，其中 $\\eta_i = 0$ 且 $\\eta_0 = 1$。因此积分为：\n$$ \\Delta_\\ell(k) = \\int_{0}^{1} S_X(k, \\eta) j_\\ell(k(1 - \\eta)) \\, d\\eta $$\n目标是使用分部积分法 $\\int u \\, dv = [uv] - \\int v \\, du$ 来重构此积分，以便将有效的“微分”从振荡的贝塞尔函数转移到更平滑的源函数上。\n\n我们选择分部如下：\n-   $u(\\eta) = S_X(k, \\eta)$\n-   $dv = j_\\ell(k(1 - \\eta)) \\, d\\eta$\n\n由此， $u$ 的导数是显而易见的：\n-   $du = \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} \\, d\\eta$\n\n为了找到 $v(\\eta)$，我们必须对 $dv$ 进行积分。我们进行变量替换，令 $y = k(1 - \\eta)$，这意味着 $d\\eta = -dy/k$。\n$$ v(\\eta) = \\int j_\\ell(k(1 - \\eta)) \\, d\\eta = \\int j_\\ell(y) \\left(-\\frac{dy}{k}\\right) = -\\frac{1}{k} \\int j_\\ell(y) \\, dy $$\n我们将球贝塞尔函数的反导数 $J_\\ell^{(-1)}(x)$ 定义为从 $0$ 到 $x$ 的定积分：\n$$ J_\\ell^{(-1)}(x) \\equiv \\int_0^x j_\\ell(y) \\, dy $$\n选择这个下限是一种惯例，可以简化边界项，因为 $J_\\ell^{(-1)}(0) = 0$。根据这个定义，$v(\\eta)$ 变为：\n$$ v(\\eta) = -\\frac{1}{k} J_\\ell^{(-1)}(k(1 - \\eta)) $$\n现在，我们应用分部积分公式：\n$$ \\Delta_\\ell(k) = \\left[ u(\\eta)v(\\eta) \\right]_0^1 - \\int_0^1 v(\\eta) du(\\eta) $$\n$$ \\Delta_\\ell(k) = \\left[ S_X(k, \\eta) \\left(-\\frac{1}{k} J_\\ell^{(-1)}(k(1 - \\eta))\\right) \\right]_0^1 - \\int_0^1 \\left(-\\frac{1}{k} J_\\ell^{(-1)}(k(1 - \\eta))\\right) \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} \\, d\\eta $$\n让我们来计算边界项部分，问题要求我们保留它：\n$$ \\left[ \\dots \\right]_0^1 = \\left( S_X(k, 1) \\left(-\\frac{1}{k} J_\\ell^{(-1)}(0)\\right) \\right) - \\left( S_X(k, 0) \\left(-\\frac{1}{k} J_\\ell^{(-1)}(k(1-0))\\right) \\right) $$\n使用我们的定义 $J_\\ell^{(-1)}(0) = 0$，第一部分消失：\n$$ \\left[ \\dots \\right]_0^1 = 0 - \\left( -\\frac{S_X(k, 0)}{k} J_\\ell^{(-1)}(k) \\right) = \\frac{S_X(k, 0)}{k} J_\\ell^{(-1)}(k) $$\n积分项简化为：\n$$ \\frac{1}{k} \\int_0^1 \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} J_\\ell^{(-1)}(k(1 - \\eta)) \\, d\\eta $$\n将边界项和积分项结合起来，得到最终的分部积分公式：\n$$ \\Delta_\\ell(k)_{\\text{IBP}} = \\frac{S_X(k, 0)}{k} \\int_0^k j_\\ell(y) \\, dy + \\frac{1}{k} \\int_0^1 \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} \\left( \\int_0^{k(1-\\eta)} j_\\ell(y) \\, dy \\right) d\\eta $$\n这就是将要实现的严谨方案。它用一个涉及源函数导数 $\\partial S_X/\\partial \\eta$ 和球贝塞尔函数反导数 $J_\\ell^{(-1)}$ 的积分，替代了原来对高度振荡的 $j_\\ell$ 的积分。\n\n### 2. 源函数及其导数\n\n问题将一个受物理启发的源函数 $S_X(k, \\eta)$ 定义为一个复合项 $S_{\\mathrm{rec}}(k,\\eta)$ 和一个晚期积分Sachs-Wolfe（ISW）项 $S_{\\mathrm{isw}}(\\eta)$ 之和：\n$$ S_X(k,\\eta) = S_{\\mathrm{rec}}(k,\\eta) + S_{\\mathrm{isw}}(\\eta) $$\n其中\n$$ S_{\\mathrm{rec}}(k,\\eta) = A_{\\mathrm{rec}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{rec}})^2}{2\\sigma_{\\mathrm{rec}}^2}\\right] \\cos\\!\\left(k c_s (\\eta-\\eta_{\\mathrm{rec}})\\right) $$\n$$ S_{\\mathrm{isw}}(\\eta) = A_{\\mathrm{isw}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{isw}})^2}{2\\sigma_{\\mathrm{isw}}^2}\\right] $$\nIBP方案所需的导数 $\\partial S_X / \\partial \\eta$ 通过对每一项求导得到。\nISW项的导数是：\n$$ \\frac{\\partial S_{\\mathrm{isw}}}{\\partial \\eta} = A_{\\mathrm{isw}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{isw}})^2}{2\\sigma_{\\mathrm{isw}}^2}\\right] \\cdot \\left( -\\frac{2(\\eta-\\eta_{\\mathrm{isw}})}{2\\sigma_{\\mathrm{isw}}^2} \\right) = -A_{\\mathrm{isw}} \\frac{(\\eta-\\eta_{\\mathrm{isw}})}{\\sigma_{\\mathrm{isw}}^2} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{isw}})^2}{2\\sigma_{\\mathrm{isw}}^2}\\right] $$\n复合项的导数需要使用乘法法则：\n$$ \\frac{\\partial S_{\\mathrm{rec}}}{\\partial \\eta} = \\frac{\\partial}{\\partial\\eta} \\left( A_{\\mathrm{rec}} \\exp\\left[\\dots\\right] \\cos\\left[\\dots\\right] \\right) $$\n$$ = A_{\\mathrm{rec}} \\left\\{ \\left( -\\frac{\\eta-\\eta_{\\mathrm{rec}}}{\\sigma_{\\mathrm{rec}}^2} \\exp[\\dots] \\right) \\cos[\\dots] + \\exp[\\dots] \\left( -k c_s \\sin[\\dots] \\right) \\right\\} $$\n$$ = -A_{\\mathrm{rec}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{rec}})^2}{2\\sigma_{\\mathrm{rec}}^2}\\right] \\left[ \\frac{\\eta-\\eta_{\\mathrm{rec}}}{\\sigma_{\\mathrm{rec}}^2} \\cos(k c_s (\\eta-\\eta_{\\mathrm{rec}})) + k c_s \\sin(k c_s (\\eta-\\eta_{\\mathrm{rec}})) \\right] $$\n这些 $S_X(k, \\eta)$ 和 $\\partial S_X(k,\\eta)/\\partial\\eta$ 的解析表达式将在数值代码中实现。\n\n### 3. 数值实现与稳定性测试\n\nIBP方案的数值稳定性验证将通过将其结果 $I_{\\mathrm{IBP}}$ 与原始积分的直接数值计算结果 $I_{\\mathrm{direct}}$ 进行比较来完成。\n\n**直接法：**\n使用标准的数值求积例程（`scipy.integrate.quad`）直接计算积分：\n$$ I_{\\mathrm{direct}} = \\int_0^1 S_X(k, \\eta) j_\\ell(k(1-\\eta)) \\, d\\eta $$\n\n**分部积分法（IBP）：**\nIBP公式涉及嵌套积分。外层积分变量是 $\\eta$，对于每个 $\\eta$ 的求值点，都需要计算一个内层积分来得到贝塞尔函数反导数 $J_\\ell^{(-1)}$ 的值。\n$$ I_{\\mathrm{IBP}} = \\text{BoundaryTerm} + \\text{IntegralTerm} $$\n$$ \\text{BoundaryTerm} = \\frac{S_X(k, 0)}{k} J_\\ell^{(-1)}(k) = \\frac{S_X(k, 0)}{k} \\int_0^k j_\\ell(y) \\, dy $$\n$$ \\text{IntegralTerm} = \\frac{1}{k} \\int_0^1 \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} J_\\ell^{(-1)}(k(1 - \\eta)) \\, d\\eta = \\frac{1}{k} \\int_0^1 \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} \\left( \\int_0^{k(1 - \\eta)} j_\\ell(y) \\, dy \\right) d\\eta $$\n内层和外层积分都将使用 `scipy.integrate.quad` 来计算。球贝塞尔函数 $j_\\ell(x)$ 将使用 `scipy.special.spherical_jn` 来求值。\n\n**稳定性度量：**\n数值稳定性由两种方法之间的相对差异 $\\delta$ 来量化：\n$$ \\delta = \\frac{\\lvert I_{\\mathrm{IBP}} - I_{\\mathrm{direct}} \\rvert}{\\max\\left(\\lvert I_{\\mathrm{direct}} \\rvert, \\epsilon\\right)} $$\n使用一个小的常数 $\\epsilon = 10^{-15}$ 来防止除以零。如果计算出的 $\\delta$ 小于给定的阈值 $\\tau$，则认为该测试用例是“稳定的”。此过程将对问题中指定的所有测试用例重复进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests an integration-by-parts (IBP) scheme for\n    CMB line-of-sight integrals.\n    \"\"\"\n    \n    # Define fixed parameters from the problem statement.\n    A_rec = 1.0\n    A_isw = 0.2\n    eta_rec = 0.3\n    eta_isw = 0.8\n    sigma_isw = 0.2\n    c_s = 0.5\n    eta0 = 1.0\n    eta_i = 0.0\n    epsilon = 1e-15\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'l': 50, 'k': 80, 'sigma_rec': 0.02, 'tau': 5e-3},\n        {'l': 150, 'k': 220, 'sigma_rec': 0.01, 'tau': 1e-2},\n        {'l': 300, 'k': 300, 'sigma_rec': 0.005, 'tau': 2e-2},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        l = case['l']\n        k = case['k']\n        sigma_rec = case['sigma_rec']\n        tau = case['tau']\n        \n        # 1. Define the source function and its derivative\n        def source_function(eta, k_val, sigma_rec_val):\n            # Recombination part\n            eta_diff_rec = eta - eta_rec\n            exp_rec = np.exp(-eta_diff_rec**2 / (2 * sigma_rec_val**2))\n            cos_rec = np.cos(k_val * c_s * eta_diff_rec)\n            s_rec = A_rec * exp_rec * cos_rec\n            \n            # ISW part\n            eta_diff_isw = eta - eta_isw\n            exp_isw = np.exp(-eta_diff_isw**2 / (2 * sigma_isw**2))\n            s_isw = A_isw * exp_isw\n            \n            return s_rec + s_isw\n\n        def source_derivative(eta, k_val, sigma_rec_val):\n            # Derivative of recombination part\n            eta_diff_rec = eta - eta_rec\n            exp_rec = np.exp(-eta_diff_rec**2 / (2 * sigma_rec_val**2))\n            \n            term1_rec = (eta_diff_rec / sigma_rec_val**2) * np.cos(k_val * c_s * eta_diff_rec)\n            term2_rec = (k_val * c_s) * np.sin(k_val * c_s * eta_diff_rec)\n            ds_rec_deta = -A_rec * exp_rec * (term1_rec + term2_rec)\n            \n            # Derivative of ISW part\n            eta_diff_isw = eta - eta_isw\n            ds_isw_deta = -A_isw * (eta_diff_isw / sigma_isw**2) * np.exp(-eta_diff_isw**2 / (2 * sigma_isw**2))\n            \n            return ds_rec_deta + ds_isw_deta\n            \n        S_X = lambda eta: source_function(eta, k, sigma_rec)\n        dS_X_deta = lambda eta: source_derivative(eta, k, sigma_rec)\n\n        # 2. Compute the direct integral\n        integrand_direct = lambda eta: S_X(eta) * spherical_jn(l, k * (eta0 - eta))\n        I_direct, _ = quad(integrand_direct, eta_i, eta0, limit=200)\n        \n        # 3. Compute the IBP integral\n        \n        # Helper function for the antiderivative of j_l(x)\n        # Using a cache dictionary for memoization to speed up nested integration,\n        # although quad's adaptive nature means it's not guaranteed to hit the same point.\n        j_antideriv_cache = {}\n        def j_antiderivative(x_max, ell):\n            if (x_max, ell) in j_antideriv_cache:\n                return j_antideriv_cache[(x_max, ell)]\n            if x_max == 0:\n                return 0.0\n            \n            # The integrand for the antiderivative\n            integrand = lambda y: spherical_jn(ell, y)\n            \n            # Numerical integration to get the antiderivative\n            # Use stricter tolerance for the inner integral for better accuracy\n            result, _ = quad(integrand, 0, x_max, limit=200, epsabs=1.49e-10, epsrel=1.49e-10)\n            j_antideriv_cache[(x_max, ell)] = result\n            return result\n        \n        # Boundary term\n        s0 = S_X(eta_i)\n        boundary_term = (s0 / k) * j_antiderivative(k, l) if k != 0 else 0\n        \n        # Integral term\n        integrand_ibp = lambda eta: dS_X_deta(eta) * j_antiderivative(k * (eta0 - eta), l)\n        \n        integral_term, _ = quad(integrand_ibp, eta_i, eta0, limit=200)\n        integral_term /= k\n\n        I_ibp = boundary_term + integral_term\n        \n        # 4. Calculate relative difference and determine stability\n        diff = abs(I_ibp - I_direct)\n        norm = max(abs(I_direct), epsilon)\n        delta = diff / norm\n        \n        is_stable = delta  tau\n        results.append(is_stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r for r in results]))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在验证了积分算法的准确性和稳定性之后，我们将注意力转向其在宇宙微波背景辐射（CMB）极化分析中的物理应用。标准宇宙学模型预测，标量微扰仅产生E模极化，而不会产生B模。本练习将展示如何利用这一物理原理作为强大的代码诊断工具，通过构建一个会产生B模的非各向同性散射玩具模型，来检验你的代码是否能够正确地捕捉或避免这类系统误差。",
            "id": "3478286",
            "problem": "考虑数值宇宙学中宇宙微波背景（CMB）偏振的平直天区模型，重点关注视线（LOS）积分。在标准的各向同性汤姆孙散射中，标量微扰只产生电型（E）偏振模式，而不产生磁型（B）偏振模式。为了诊断数值代码的正确性，我们将引入一个带有优选方向的玩具各向异性散射核，它会故意破坏方位对称性，并通过视线积分产生伪B模式。\n\n您必须实现一个完整的程序，该程序从一个方形角斑块上的单一平面波标量微扰构建一个基准纯E模式偏振图样，然后应用一个经过视线积分的各向异性核，该核会根据平面波方向和优选方向之间的偏离程度引发一个均匀的偏振旋转。您必须根据这个旋转后的图样，计算E模式和B模式，并量化伪B模式的产生。\n\n该程序必须遵守以下规范：\n\n- 在一个边长为 $L$ 弧度的方形角斑块上使用平直天区近似，该斑块在一个 $N \\times N$ 的网格上进行离散化。角度必须以弧度为单位。\n- 从一个产生基准纯E模式偏振图样的单模标量微扰开始。从一个傅里叶空间E模式场构建基准斯托克斯参数 $Q(\\boldsymbol{\\theta})$ 和 $U(\\boldsymbol{\\theta})$ 图，该E模式场的非零振幅仅存在于单个波矢 $\\boldsymbol{k}_0$ 及其负值 $-\\boldsymbol{k}_0$ 处，以确保实空间图是实数。最终的基准必须是纯E模式（即B模式在数值精度范围内为零）。\n- 引入一个玩具各向异性散射核，它在整个图上产生一个角度为 $\\alpha$ 的均匀斯托克斯旋转。这个旋转由一个具有优选方向依赖性的归一化可见度函数的视线积分定义。沿视线共动距离 $0 \\le \\chi \\le 1$ 的可见度函数是一个归一化高斯函数\n$$\ng(\\chi) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\left(-\\frac{(\\chi-\\chi_\\star)^2}{2\\sigma^2}\\right),\n$$\n其中心为 $\\chi_\\star = 0.5$，宽度为 $\\sigma  0$。各向异性参数 $\\varepsilon$ 控制核的强度，优选方向与x轴的夹角为 $\\varphi_p$。设平面波模式的方向为 $\\varphi_k$。均匀旋转角为\n$$\n\\alpha = \\varepsilon\\,\\left(\\int_{0}^{1} g(\\chi)\\,d\\chi\\right)\\,\\sin\\left(2(\\varphi_k-\\varphi_p)\\right).\n$$\n- 通过数值视线积分（而非解析计算）计算出 $\\alpha$ 后，将均匀偏振旋转应用于基准 $Q$ 和 $U$ 图，以获得旋转后的图 $Q'(\\boldsymbol{\\theta})$ 和 $U'(\\boldsymbol{\\theta})$。\n- 使用标准的平直天区E/B分解，从旋转后的斯托克斯参数 $Q$ 和 $U$ 图计算傅里叶空间的E模式和B模式（不要硬编码目标结果；应实现由傅里叶空间斯托克斯参数和E/B标量场之间的平直天区关系所隐含的正确变换定义）。\n- 计算E模式和B模式在傅里叶空间中的总功率，\n$$\nP_E = \\sum_{\\boldsymbol{k}} \\left|E(\\boldsymbol{k})\\right|^2,\\quad P_B = \\sum_{\\boldsymbol{k}} \\left|B(\\boldsymbol{k})\\right|^2,\n$$\n并报告伪B模式功率分数\n$$\nR = \\frac{P_B}{P_E}.\n$$\n\n除非测试套件另有规定，否则您必须使用以下固定的数值设置：\n- 斑块边长 $L = 1.0$ (弧度)。\n- 网格大小 $N = 64$。\n- 基准E模式振幅 $A = 1.0$ (无量纲)。\n- 单个非零傅里叶模式指数 $(k_{x,\\text{ind}}, k_{y,\\text{ind}}) = (4, 0)$，得到 $\\varphi_k = 0$。\n\n使用一个足够精细的一维网格，实现对 $\\chi \\in [0,1]$ 的视线数值积分，以计算 $\\int_0^1 g(\\chi)\\,d\\chi$。\n\n测试套件：\n对于每个测试用例，计算伪B模式分数 $R$（浮点数）。使用以下参数集 $(\\varepsilon, \\varphi_p, \\sigma)$:\n- 情况 1: $(0.0, \\pi/4, 0.05)$ — 各向同性基准，预期产生接近 $0$ 的 $R$。\n- 情况 2: $(0.05, \\pi/4, 0.05)$ — 小各向异性，偏离 $45^\\circ$。\n- 情况 3: $(0.2, \\pi/4, 0.05)$ — 更强的各向异性，偏离 $45^\\circ$。\n- 情况 4: $(0.2, 0.0, 0.05)$ — 优选方向与模式方向平行，对称性应抑制旋转并产生接近 $0$ 的 $R$。\n- 情况 5: $(0.2, \\pi/8, 10^{-3})$ — 窄可见度函数，用于在非平凡的偏离情况下测试视线积分的稳定性。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是相应测试用例计算出的伪B模式分数 $R$，表示为浮点数（无量纲）。不应打印任何其他文本。",
            "solution": "我们从这样一个物理基础出发：在各向同性汤姆孙散射中，由于宇称和方位对称性，标量微扰产生的偏振图样具有为零的磁型（B）模式，而电型（E）模式则不为零。斯托克斯参数 $Q$ 和 $U$ 描述天空中的线性偏振。在平直天区上，标准做法是在傅里叶空间中，通过傅里叶变换 $\\tilde{Q}(\\boldsymbol{k})$ 和 $\\tilde{U}(\\boldsymbol{k})$ 的线性组合将偏振分解为标量E场和B场，这种组合具有对波矢方向 $\\varphi_{\\boldsymbol{k}}$ 的角度依赖性。算法的目标是构建一个受控的基准纯E模式图，然后应用一个玩具各向异性核，该核会引发斯托克斯场的均匀旋转，从而将E模式混入B模式。这提供了一种诊断方法：各向同性的情况产生 $B \\approx 0$，而各向异性的情况则产生与控制参数成比例的 $B \\neq 0$。\n\n分步推导和算法设计：\n\n1. 平直天区设置和傅里叶约定：\n   - 考虑一个边长为 $L$ 弧度的方形角斑块，在 $N \\times N$ 网格上离散化。用 $\\boldsymbol{\\theta} = (\\theta_x, \\theta_y)$ 表示实空间角坐标，用 $\\boldsymbol{k} = (k_x, k_y)$ 表示傅里叶空间波矢，其角度为 $\\varphi_{\\boldsymbol{k}} = \\arctan2(k_y, k_x)$。\n   - 使用离散傅里叶变换在实空间图 $Q(\\boldsymbol{\\theta}), U(\\boldsymbol{\\theta})$ 和其傅里叶变换 $\\tilde{Q}(\\boldsymbol{k}), \\tilde{U}(\\boldsymbol{k})$ 之间进行转换。对于实数图，傅里叶模式必须满足厄米对称性，即对于任何场 $\\tilde{F}$，都有 $\\tilde{F}(-\\boldsymbol{k}) = \\tilde{F}(\\boldsymbol{k})^\\ast$。\n\n2. 构建基准纯E模式场：\n   - 选择在指数 $(k_{x,\\text{ind}}, k_{y,\\text{ind}}) = (4, 0)$ 处的单个非零傅里叶模式及其在 $(-4, 0)$ 处的共轭对应项，以生成实数图。分配一个对称分布的E模式振幅 $A  0$，使得这对模式之和在实空间中产生一个余弦函数。\n   - 对于傅里叶空间中的纯E模式，每个 $\\boldsymbol{k}$ 处的斯托克斯参数由下式给出\n     $$\n     \\tilde{Q}(\\boldsymbol{k}) = \\tilde{E}(\\boldsymbol{k}) \\cos\\left(2\\varphi_{\\boldsymbol{k}}\\right), \\quad\n     \\tilde{U}(\\boldsymbol{k}) = \\tilde{E}(\\boldsymbol{k}) \\sin\\left(2\\varphi_{\\boldsymbol{k}}\\right),\n     $$\n     其中 $\\tilde{B}(\\boldsymbol{k}) = 0$。通过仅在 $\\pm \\boldsymbol{k}_0$ 处构造 $\\tilde{E}(\\boldsymbol{k})$ 并在其他地方设为零，逆变换会产生实空间图 $Q(\\boldsymbol{\\theta})$ 和 $U(\\boldsymbol{\\theta})$，当它们被分解回E/B模式时，B模式在数值精度范围内为零。\n\n3. 定义玩具各向异性散射核和视线积分：\n   - 各向异性核引入一个角度为 $\\varphi_p$ 的优选方向，并通过对归一化高斯可见度函数的视线积分产生一个角度为 $\\alpha$ 的均匀偏振旋转：\n     $$\n     g(\\chi) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\left(-\\frac{(\\chi-\\chi_\\star)^2}{2\\sigma^2}\\right), \\quad \\chi_\\star = 0.5,\\quad \\sigma  0,\\quad 0 \\le \\chi \\le 1.\n     $$\n     核强度由 $\\varepsilon$ 控制，平面波方向和优选方向之间的相对偏离为 $\\Delta = \\varphi_k - \\varphi_p$，其中 $\\varphi_k$ 是非零模式 $\\boldsymbol{k}_0$ 的角度。\n   - 旋转角建模为\n     $$\n     \\alpha = \\varepsilon \\left(\\int_{0}^{1} g(\\chi)\\,d\\chi\\right) \\sin(2\\Delta),\n     $$\n     当 $\\Delta = 0$ 或 $\\Delta = \\pi/2$ 时，该值为零，这捕捉了各向异性不产生净旋转的对称情况。该积分必须使用足够精细的网格进行数值计算，以确保稳定性。\n\n4. 偏振旋转和E/B混合：\n   - 在偏振参考系旋转角度 $\\alpha$ 的情况下，斯托克斯参数变换如下\n     $$\n     Q'(\\boldsymbol{\\theta}) = Q(\\boldsymbol{\\theta})\\cos(2\\alpha) - U(\\boldsymbol{\\theta})\\sin(2\\alpha), \\quad\n     U'(\\boldsymbol{\\theta}) = Q(\\boldsymbol{\\theta})\\sin(2\\alpha) + U(\\boldsymbol{\\theta})\\cos(2\\alpha).\n     $$\n     在傅里叶空间中，平直天区E/B分解通过依赖于 $\\varphi_{\\boldsymbol{k}}$ 的角度因子将 $(\\tilde{Q}, \\tilde{U})$ 与 $(\\tilde{E}, \\tilde{B})$ 联系起来。实现这些标准关系，以从 $\\tilde{Q}'(\\boldsymbol{k})$ 和 $\\tilde{U}'(\\boldsymbol{k})$ 计算 $\\tilde{E}(\\boldsymbol{k})$ 和 $\\tilde{B}(\\boldsymbol{k})$。\n   - 从 $\\tilde{B} = 0$ 的纯E模式开始，一个角度为 $\\alpha$ 的均匀旋转会将E模式混入B模式。可以逐个模式地证明，\n     $$\n     \\tilde{E}'(\\boldsymbol{k}) = \\tilde{E}(\\boldsymbol{k})\\cos(2\\alpha),\\quad\n     \\tilde{B}'(\\boldsymbol{k}) = -\\tilde{E}(\\boldsymbol{k})\\sin(2\\alpha),\n     $$\n     因此对于单个模式，功率比为\n     $$\n     R = \\frac{P_B}{P_E} = \\frac{\\sum_{\\boldsymbol{k}}|\\tilde{B}'(\\boldsymbol{k})|^2}{\\sum_{\\boldsymbol{k}}|\\tilde{E}'(\\boldsymbol{k})|^2} = \\tan^2(2\\alpha).\n     $$\n     在使用离散变换和对所有模式求和的数值方案中，数值精度和有限网格效应可能会引入微小偏差，但定性标度关系保持不变。\n\n5. 数值实现细节：\n   - 根据 $N$ 点快速傅里叶变换（FFT）的频率约定，使用 $n_x, n_y \\in \\mathbb{Z}$ 从离散频率 $\\left(\\frac{2\\pi n_x}{L}, \\frac{2\\pi n_y}{L}\\right)$ 生成傅里叶空间网格波矢。\n   - 构造 $\\tilde{E}(\\boldsymbol{k})$，使其非零项仅存在于 $(k_{x,\\text{ind}}, k_{y,\\text{ind}})$ 及其厄米共轭对应项处，确保 $\\tilde{Q}$ 和 $\\tilde{U}$ 继承厄米对称性，从而使逆FFT产生实数的 $Q$ 和 $U$。\n   - 在一个精细采样的 $\\chi$ 网格上使用辛普森法则数值计算视线积分 $\\int_0^1 g(\\chi)\\,d\\chi$；求出 $\\alpha$；旋转 $Q$ 和 $U$；变换回傅里叶空间；计算 $\\tilde{E}$ 和 $\\tilde{B}$；然后计算 $P_E$ 和 $P_B$，最后计算 $R$。\n\n6. 测试套件覆盖范围和边界情况：\n   - 情况1验证各向同性基准（$\\varepsilon = 0$），其应产生 $R \\approx 0$。\n   - 情况2和3探究了 $\\varphi_p = \\pi/4$ 时随各向异性增加的情况，产生随 $\\varepsilon$ 增长的非零 $R$。\n   - 情况4设置 $\\varphi_p = 0$，与 $\\varphi_k = 0$ 平行，因此 $\\Delta = 0$，对称性抑制了旋转：尽管 $\\varepsilon$ 非零，但 $R \\approx 0$。\n   - 情况5使用一个非常窄的可见度函数（$\\sigma = 10^{-3}$）和 $\\varphi_p = \\pi/8$ 来测试视线积分的稳定性和非平凡的偏离情况。\n\n程序必须以精确格式 $[r_1,r_2,r_3,r_4,r_5]$ 输出一行包含五个计算出的 $R$ 值的列表，不得包含任何其他文本。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef build_pure_E_qu(N, L, amplitude, kx_ind, ky_ind):\n    \"\"\"\n    Construct baseline pure E-mode Stokes Q and U maps on an NxN grid with side length L (radians),\n    using a single Fourier mode at indices (kx_ind, ky_ind) and its Hermitian counterpart.\n    \"\"\"\n    # Fourier-space wave numbers\n    kx = (2.0 * np.pi) * np.fft.fftfreq(N, d=L / N)\n    ky = (2.0 * np.pi) * np.fft.fftfreq(N, d=L / N)\n    KX, KY = np.meshgrid(kx, ky, indexing='xy')\n    # Angle of each wavevector\n    phi = np.arctan2(KY, KX)\n    # Handle k=0 angle gracefully\n    phi[np.isnan(phi)] = 0.0\n\n    # Initialize Fourier-space E field and ensure Hermitian symmetry\n    E_k = np.zeros((N, N), dtype=np.complex128)\n\n    # Positive index\n    pos = (ky_ind % N, kx_ind % N)\n    # Negative (Hermitian counterpart) index\n    neg = ((-ky_ind) % N, (-kx_ind) % N)\n\n    if pos == neg:\n        # If the mode is its own counterpart (only possible if both indices are 0, which we avoid),\n        # assign full amplitude to avoid double-counting.\n        E_k[pos] = amplitude\n    else:\n        # Split amplitude equally to produce a real cosine in real space\n        E_k[pos] = amplitude / 2.0\n        E_k[neg] = amplitude / 2.0\n\n    # Build Q_k and U_k from E_k using flat-sky relations for a pure E-mode\n    Q_k = E_k * np.cos(2.0 * phi)\n    U_k = E_k * np.sin(2.0 * phi)\n\n    # Inverse FFT to get real-space maps\n    Q = np.fft.ifft2(Q_k).real\n    U = np.fft.ifft2(U_k).real\n\n    return Q, U, KX, KY, phi\n\ndef rotate_stokes(Q, U, alpha):\n    \"\"\"\n    Apply uniform polarization rotation by angle alpha (radians) to Stokes Q, U.\n    Rotation acts as (Q', U') = R(2 alpha) (Q, U).\n    \"\"\"\n    ca = np.cos(2.0 * alpha)\n    sa = np.sin(2.0 * alpha)\n    Qp = Q * ca - U * sa\n    Up = Q * sa + U * ca\n    return Qp, Up\n\ndef eb_from_qu(Q, U, KX, KY):\n    \"\"\"\n    Compute Fourier-space E and B modes from Stokes Q and U maps via flat-sky relations.\n    \"\"\"\n    # Forward FFTs\n    Q_k = np.fft.fft2(Q)\n    U_k = np.fft.fft2(U)\n\n    # Wavevector angle\n    phi = np.arctan2(KY, KX)\n    phi[np.isnan(phi)] = 0.0\n\n    # E(k) and B(k) in Fourier space\n    E_k = Q_k * np.cos(2.0 * phi) + U_k * np.sin(2.0 * phi)\n    B_k = -Q_k * np.sin(2.0 * phi) + U_k * np.cos(2.0 * phi)\n    return E_k, B_k\n\ndef visibility_integral(sigma, chi_star=0.5, n_steps=4097):\n    \"\"\"\n    Numerically evaluate the integral of a normalized Gaussian visibility g(chi)\n    over chi in [0, 1] using Simpson's rule.\n    g(chi) = (1 / (sqrt(2*pi)*sigma)) * exp( - (chi - chi_star)^2 / (2*sigma^2) )\n    \"\"\"\n    chi = np.linspace(0.0, 1.0, n_steps)\n    g = (1.0 / (np.sqrt(2.0 * np.pi) * sigma)) * np.exp(-0.5 * ((chi - chi_star) / sigma) ** 2)\n    integral = simpson(g, chi)\n    return integral\n\ndef spurious_B_fraction(N, L, amplitude, kx_ind, ky_ind, epsilon, phi_p, sigma):\n    \"\"\"\n    Compute the spurious B-mode power fraction R = P_B / P_E for given anisotropy parameters.\n    \"\"\"\n    # Build baseline pure E-mode Stokes maps\n    Q, U, KX, KY, phi_grid = build_pure_E_qu(N, L, amplitude, kx_ind, ky_ind)\n\n    # Determine the angle of the single mode k0\n    kx0 = (2.0 * np.pi) * (kx_ind / L)\n    ky0 = (2.0 * np.pi) * (ky_ind / L)\n    phi_k = np.arctan2(ky0, kx0)\n\n    # LOS integral (normalized Gaussian visibility over [0,1])\n    G = visibility_integral(sigma=sigma, chi_star=0.5, n_steps=4097)\n\n    # Rotation angle alpha from anisotropic kernel\n    delta = phi_k - phi_p\n    alpha = epsilon * G * np.sin(2.0 * delta)\n\n    # Rotate Stokes parameters\n    Qp, Up = rotate_stokes(Q, U, alpha)\n\n    # Compute E and B modes after rotation\n    E_k, B_k = eb_from_qu(Qp, Up, KX, KY)\n\n    # Compute power sums (exclude k=0 if desired; here we include all modes uniformly)\n    P_E = np.sum(np.abs(E_k) ** 2)\n    P_B = np.sum(np.abs(B_k) ** 2)\n\n    # Avoid divide-by-zero: if P_E is tiny due to numerical issues, handle gracefully\n    if P_E == 0.0:\n        return 0.0\n    R = (P_B / P_E).real  # ratio is real-valued\n    return float(R)\n\ndef solve():\n    # Fixed grid and baseline parameters per problem statement\n    N = 64\n    L = 1.0  # radians\n    amplitude = 1.0\n    kx_ind, ky_ind = 4, 0  # single nonzero mode -> phi_k = 0\n\n    # Define the test cases (epsilon, phi_p, sigma)\n    test_cases = [\n        (0.0, np.pi / 4.0, 0.05),         # Case 1\n        (0.05, np.pi / 4.0, 0.05),        # Case 2\n        (0.2, np.pi / 4.0, 0.05),         # Case 3\n        (0.2, 0.0, 0.05),                 # Case 4\n        (0.2, np.pi / 8.0, 1e-3),         # Case 5\n    ]\n\n    results = []\n    for epsilon, phi_p, sigma in test_cases:\n        r = spurious_B_fraction(N, L, amplitude, kx_ind, ky_ind, epsilon, phi_p, sigma)\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}