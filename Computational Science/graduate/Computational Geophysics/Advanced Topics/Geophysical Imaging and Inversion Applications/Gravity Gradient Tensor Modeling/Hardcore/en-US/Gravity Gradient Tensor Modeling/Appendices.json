{
    "hands_on_practices": [
        {
            "introduction": "The first step in computational geophysics is often building a model from fundamental principles. This exercise tackles the forward problem: calculating the gravity gradient tensor from a known, arbitrary density distribution. It employs a direct numerical approach, discretizing a volumetric source into a grid of point masses and approximating the derivatives of the gravitational potential using finite difference stencils. This practice builds foundational skills for potential field modeling and provides practical experience with numerical differentiation and boundary conditions, which are essential tools in computational science. ",
            "id": "3602058",
            "problem": "You are to implement a numerical model for the gravity gradient tensor based on first principles for three test cases. Use Newtonian gravitation to model the gravitational potential of volumetric density anomalies discretized on a uniform Cartesian grid. The gravity gradient tensor is to be obtained by numerical differentiation of the potential using finite differences. Your program must output quantitative results for each test case in specified physical units and format.\n\nFundamental base. Start from the Newtonian gravitational potential generated by a density distribution. For a mass density field $\\rho(\\mathbf{r}')$ in three-dimensional space, the gravitational potential $\\Phi(\\mathbf{r})$ at position $\\mathbf{r}$ is\n$$\n\\Phi(\\mathbf{r}) = G \\int_{\\mathbb{R}^3} \\frac{\\rho(\\mathbf{r}')}{\\|\\mathbf{r} - \\mathbf{r}'\\|} \\, dV',\n$$\nwhere $G$ is the gravitational constant. The gravity gradient tensor $\\mathbf{T}$ is defined as the Hessian of the potential,\n$$\nT_{ij}(\\mathbf{r}) = \\frac{\\partial^2 \\Phi(\\mathbf{r})}{\\partial x_i \\, \\partial x_j},\n$$\nfor Cartesian coordinates $\\{x_1,x_2,x_3\\} \\equiv \\{x,y,z\\}$.\n\nDiscretization strategy. Discretize the density field by uniform voxels of edge length $h$ on an odd-sized grid with $N$ nodes per axis. Represent the mass distribution as a collection of point masses at voxel centers. For a uniform density anomaly with density $\\rho$ and voxel volume $h^3$, each occupied voxel has mass $m = \\rho h^3$. Approximate the potential at a point $\\mathbf{r}$ by a Riemann sum\n$$\n\\Phi(\\mathbf{r}) \\approx G \\sum_{n=1}^{M} \\frac{m}{\\|\\mathbf{r} - \\mathbf{r}_n\\|},\n$$\nwhere $\\{\\mathbf{r}_n\\}_{n=1}^M$ are the centers of the occupied voxels.\n\nNumerical differentiation. Approximate second derivatives of $\\Phi$ at grid nodes using second-order accurate finite differences with grid spacing $h$:\n\n- For a pure second derivative along $x$ at an interior node,\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x^2} \\bigg|_{i,j,k} \\approx \\frac{\\Phi_{i+1,j,k} - 2\\Phi_{i,j,k} + \\Phi_{i-1,j,k}}{h^2}.\n$$\n\n- For a mixed derivative at an interior node, for example $\\partial^2 \\Phi / \\partial x \\partial y$,\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x \\partial y} \\bigg|_{i,j,k} \\approx \\frac{\\Phi_{i+1,j+1,k} - \\Phi_{i+1,j-1,k} - \\Phi_{i-1,j+1,k} + \\Phi_{i-1,j-1,k}}{4h^2}.\n$$\n\n- At a boundary node where a central stencil is not available, use a second-order accurate one-sided stencil for the pure second derivative. For example, at the top boundary along $z$ with backward differences,\n$$\n\\frac{\\partial^2 \\Phi}{\\partial z^2} \\bigg|_{i,j,K} \\approx \\frac{2\\Phi_{i,j,K} - 5\\Phi_{i,j,K-1} + 4\\Phi_{i,j,K-2} - \\Phi_{i,j,K-3}}{h^2}.\n$$\n\nCoordinate system and grid. Use a cubic grid with $N$ odd so that the origin is at the central node. Let indices $i,j,k \\in \\{0,1,\\dots,N-1\\}$. The physical coordinates of node $(i,j,k)$ are\n$$\nx_i = \\left(i - \\frac{N-1}{2}\\right) h, \\quad y_j = \\left(j - \\frac{N-1}{2}\\right) h, \\quad z_k = \\left(k - \\frac{N-1}{2}\\right) h.\n$$\n\nPhysical constants and units. Use the gravitational constant $G = 6.67430 \\times 10^{-11}$ in $\\mathrm{m}^3 \\, \\mathrm{kg}^{-1} \\, \\mathrm{s}^{-2}$. Use density $\\rho$ in $\\mathrm{kg} \\, \\mathrm{m}^{-3}$, lengths in $\\mathrm{m}$. Express gravity gradient tensor components in Eötvös, where $1$ Eötvös $= 10^{-9} \\, \\mathrm{s}^{-2}$. Your program must output each requested tensor component in Eötvös, rounded to six decimal places.\n\nTest suite and required outputs. Use $N = 33$ and $h = 100$ $\\mathrm{m}$ for all cases. Use uniform density $\\rho = 2670$ $\\mathrm{kg} \\, \\mathrm{m}^{-3}$ for all anomalies. Define the anomaly voxels by selecting all voxel centers whose coordinates lie within the specified axis-aligned bounds (inclusive).\n\n- Test case $1$ (interior central differences and trace constraint): A single uniform cube anomaly of side length $600$ $\\mathrm{m}$ centered at the origin, i.e., occupied voxel centers with $x \\in [-300,300]$ $\\mathrm{m}$, $y \\in [-300,300]$ $\\mathrm{m}$, $z \\in [-300,300]$ $\\mathrm{m}$. Evaluate at the node with coordinates $(x,y,z) = (0,0,500)$ $\\mathrm{m}$. Compute the pure second derivatives to form the trace $S = T_{xx} + T_{yy} + T_{zz}$ at that point. Output $S$ in Eötvös, rounded to six decimal places.\n\n- Test case $2$ (mixed derivative symmetry): Two equal uniform cube anomalies, each of side length $400$ $\\mathrm{m}$, centered at $(x,y,z) = (-600,0,0)$ $\\mathrm{m}$ and $(x,y,z) = (600,0,0)$ $\\mathrm{m}$. That is, occupied voxel centers for the left cube have $x \\in [-800,-400]$ $\\mathrm{m}$, $y \\in [-200,200]$ $\\mathrm{m}$, $z \\in [-200,200]$ $\\mathrm{m}$, and for the right cube have $x \\in [400,800]$ $\\mathrm{m}$ with the same $y$ and $z$ bounds. Evaluate at the origin $(0,0,0)$ $\\mathrm{m}$. Compute the mixed derivative $T_{xy}$ at that point using central differences. Output $T_{xy}$ in Eötvös, rounded to six decimal places.\n\n- Test case $3$ (boundary one-sided stencil): A single uniform cube anomaly of side length $400$ $\\mathrm{m}$ centered at $(x,y,z) = (0,0,-700)$ $\\mathrm{m}$, i.e., occupied voxel centers with $x \\in [-200,200]$ $\\mathrm{m}$, $y \\in [-200,200]$ $\\mathrm{m}$, $z \\in [-900,-500]$ $\\mathrm{m}$. Evaluate at the top boundary node $(x,y,z) = (0,0,1600)$ $\\mathrm{m}$. Compute $T_{zz}$ using the second-order accurate one-sided backward stencil. Output $T_{zz}$ in Eötvös, rounded to six decimal places.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[S_{\\text{case 1}}, T_{xy,\\text{case 2}}, T_{zz,\\text{case 3}}]$, for example, \"[1.234567,0.000001,-0.123456]\". All three numbers must be in Eötvös and rounded to six decimal places, with no spaces in the list.",
            "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically grounded in Newtonian physics, mathematically well-posed, objective, and self-contained. The provided parameters and test cases are consistent and allow for a unique, meaningful solution. We may therefore proceed with the development of the computational model.\n\nThe task is to implement a numerical model to calculate components of the gravity gradient tensor, $\\mathbf{T}$, for three distinct mass anomaly configurations. The model is based on first principles of Newtonian gravitation, employing discretization and numerical differentiation.\n\n**1. Foundational Principle: Gravitational Potential**\n\nThe gravitational potential $\\Phi$ at a position $\\mathbf{r}$ due to a continuous mass density distribution $\\rho(\\mathbf{r}')$ is given by the volume integral:\n$$\n\\Phi(\\mathbf{r}) = G \\int_{\\mathbb{R}^3} \\frac{\\rho(\\mathbf{r}')}{\\|\\mathbf{r} - \\mathbf{r}'\\|} \\, dV'\n$$\nwhere $G = 6.67430 \\times 10^{-11} \\, \\mathrm{m}^3 \\, \\mathrm{kg}^{-1} \\, \\mathrm{s}^{-2}$ is the gravitational constant.\n\n**2. Discretization Strategy**\n\nTo facilitate numerical computation, we model the continuous density anomaly as a collection of discrete point masses. The source volume is discretized into a uniform grid of voxels, each of side length $h = 100 \\, \\mathrm{m}$. For a uniform density anomaly $\\rho = 2670 \\, \\mathrm{kg} \\, \\mathrm{m}^{-3}$, each voxel is represented by a point mass $m = \\rho h^3$ located at its geometric center. The integral for the potential is thus approximated by a Riemann sum:\n$$\n\\Phi(\\mathbf{r}) \\approx G \\sum_{n=1}^{M} \\frac{m}{\\|\\mathbf{r} - \\mathbf{r}_n\\|}\n$$\nHere, $\\{\\mathbf{r}_n\\}_{n=1}^M$ are the coordinate vectors of the centers of the $M$ voxels comprising the density anomaly. The evaluation points $\\mathbf{r}$ for the potential are distinct from all mass locations $\\mathbf{r}_n$, thereby avoiding singularities.\n\n**3. Gravity Gradient Tensor via Numerical Differentiation**\n\nThe gravity gradient tensor, $\\mathbf{T}$, is the Hessian of the potential, with components $T_{ij}(\\mathbf{r}) = \\frac{\\partial^2 \\Phi(\\mathbf{r})}{\\partial x_i \\, \\partial x_j}$. We approximate these second derivatives using finite difference formulas on the computational grid. The problem specifies second-order accurate stencils.\n\n**4. Implementation for Test Cases**\n\nA computational grid with $N=33$ nodes per axis and spacing $h=100 \\, \\mathrm{m}$ is established. The coordinates are centered at the origin, with the physical coordinate of a node with index $k \\in \\{0, \\dots, N-1\\}$ along any axis being $(k - \\frac{N-1}{2})h = (k - 16)h$.\n\nFor each test case, the following procedure is executed:\n1.  Identify the set of voxel center coordinates $\\{\\mathbf{r}_n\\}$ that satisfy the given geometric bounds for the anomaly.\n2.  Define the required stencil points around the specified evaluation point $\\mathbf{r}_{\\text{eval}}$.\n3.  Calculate the gravitational potential $\\Phi$ at each of these stencil points using the discretized formula.\n4.  Apply the appropriate finite difference formula to compute the required tensor component(s).\n5.  Convert the result from SI units ($\\mathrm{s}^{-2}$) to Eötvös ($1 \\text{ Eötvös} = 10^{-9} \\, \\mathrm{s}^{-2}$) by multiplying by $10^9$.\n\n**Test Case 1: Trace at an Interior Point**\n-   **Anomaly:** A single cube defined by voxel centers with coordinates $x, y, z \\in [-300, 300] \\, \\mathrm{m}$.\n-   **Evaluation Point:** $\\mathbf{r}_{\\text{eval}} = (0, 0, 500) \\, \\mathrm{m}$. This is an interior node of the computational grid.\n-   **Task:** Compute the trace $S = T_{xx} + T_{yy} + T_{zz}$.\n-   **Methodology:** The pure second derivatives are computed using the second-order central difference stencil:\n    $$\n    T_{xx}(\\mathbf{r}) \\approx \\frac{\\Phi(x+h, y, z) - 2\\Phi(x, y, z) + \\Phi(x-h, y, z)}{h^2}\n    $$\n    Analogous formulas are used for $T_{yy}$ and $T_{zz}$. Nine potential calculations are required for the three stencils (some points are shared). The evaluation point is outside the mass distribution, where the potential satisfies Laplace's equation, $\\nabla^2 \\Phi = T_{xx} + T_{yy} + T_{zz} = 0$. The computed numerical trace $S$ is therefore expected to be a small value, representing the error of the numerical approximation.\n\n**Test Case 2: Mixed Derivative at the Origin**\n-   **Anomaly:** Two cubes, one with $x \\in [-800, -400] \\, \\mathrm{m}$ and another with $x \\in [400, 800] \\, \\mathrm{m}$, both with $y, z \\in [-200, 200] \\, \\mathrm{m}$.\n-   **Evaluation Point:** $\\mathbf{r}_{\\text{eval}} = (0, 0, 0) \\, \\mathrm{m}$.\n-   **Task:** Compute the mixed derivative $T_{xy}$.\n-   **Methodology:** The mixed derivative is computed using the second-order central difference stencil:\n    $$\n    T_{xy}(\\mathbf{r}) \\approx \\frac{\\Phi(x+h, y+h, z) - \\Phi(x+h, y-h, z) - \\Phi(x-h, y+h, z) + \\Phi(x-h, y-h, z)}{4h^2}\n    $$\n    The mass distribution is symmetric with respect to the $x-z$ plane (i.e., at $y=0$). This symmetry implies that $\\Phi(x, y, z) = \\Phi(x, -y, z)$, and therefore $\\frac{\\partial \\Phi}{\\partial y}$ must be zero everywhere on the $x-z$ plane. Consequently, $T_{xy} = \\frac{\\partial}{\\partial x}(\\frac{\\partial \\Phi}{\\partial y})$ must also be zero at the origin. The numerical result is expected to be close to zero, limited by floating-point precision.\n\n**Test Case 3: Pure Derivative at a Boundary**\n-   **Anomaly:** A single cube defined by $x, y \\in [-200, 200] \\, \\mathrm{m}$ and $z \\in [-900, -500] \\, \\mathrm{m}$.\n-   **Evaluation Point:** $\\mathbf{r}_{\\text{eval}} = (0, 0, 1600) \\, \\mathrm{m}$. This coordinate corresponds to the node with index $k=32$, which is the top boundary of the grid ($k_{\\text{max}} = N-1 = 32$).\n-   **Task:** Compute $T_{zz}$.\n-   **Methodology:** Since a forward difference point is not available within the grid, the specified second-order accurate one-sided backward difference formula must be used:\n    $$\n    T_{zz}(\\mathbf{r}) \\approx \\frac{2\\Phi(x, y, z) - 5\\Phi(x, y, z-h) + 4\\Phi(x, y, z-2h) - \\Phi(x, y, z-3h)}{h^2}\n    $$\n    This requires calculating the potential at the evaluation point itself and three points below it along the $z$-axis.\n\nThe final implementation encapsulates these steps into a program that computes and outputs the three requested values in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes gravity gradient tensor components for three test cases.\n    \"\"\"\n    # Physical constants and parameters\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    RHO = 2670.0      # kg m^-3\n    N = 33            # Grid nodes per axis\n    H = 100.0         # m, grid spacing / voxel edge length\n    MASS = RHO * H**3 # kg, mass of a single voxel\n    EOTVOS_CONVERSION = 1e9\n\n    def get_mass_locations(case_params):\n        \"\"\"\n        Generates the coordinates of voxel centers for a given anomaly definition.\n        \n        Args:\n            case_params (list of tuples): Each tuple contains (min_coord, max_coord)\n                                          for x, y, z axes respectively.\n        \n        Returns:\n            np.ndarray: An (M, 3) array of mass point coordinates.\n        \"\"\"\n        all_mass_locs = []\n        for x_bounds, y_bounds, z_bounds in case_params:\n            x_coords = np.arange(x_bounds[0], x_bounds[1] + 1, H)\n            y_coords = np.arange(y_bounds[0], y_bounds[1] + 1, H)\n            z_coords = np.arange(z_bounds[0], z_bounds[1] + 1, H)\n            \n            xx, yy, zz = np.meshgrid(x_coords, y_coords, z_coords, indexing='ij')\n            mass_locs = np.vstack([xx.ravel(), yy.ravel(), zz.ravel()]).T\n            all_mass_locs.append(mass_locs)\n        \n        if not all_mass_locs:\n            return np.empty((0, 3))\n        \n        return np.vstack(all_mass_locs)\n\n    def compute_potential(eval_point, mass_locations):\n        \"\"\"\n        Calculates the gravitational potential at a single evaluation point.\n        \n        Args:\n            eval_point (tuple or np.ndarray): The (x, y, z) coordinate for evaluation.\n            mass_locations (np.ndarray): An (M, 3) array of mass point coordinates.\n\n        Returns:\n            float: The gravitational potential in SI units (m^2 s^-2).\n        \"\"\"\n        if mass_locations.shape[0] == 0:\n            return 0.0\n\n        eval_point = np.array(eval_point)\n        diffs = eval_point - mass_locations\n        distances = np.linalg.norm(diffs, axis=1)\n        \n        # The problem is set up to avoid singularities (distances  0)\n        potential_contribs = MASS / distances\n        total_potential = G * np.sum(potential_contribs)\n        return total_potential\n\n    results = []\n\n    # --- Test Case 1: Trace S at (0, 0, 500) m ---\n    case1_params = [((-300.0, 300.0), (-300.0, 300.0), (-300.0, 300.0))]\n    mass_locs_1 = get_mass_locations(case1_params)\n    r_eval_1 = (0.0, 0.0, 500.0)\n    \n    phi_center = compute_potential(r_eval_1, mass_locs_1)\n    \n    # T_xx\n    phi_xp1 = compute_potential((r_eval_1[0] + H, r_eval_1[1], r_eval_1[2]), mass_locs_1)\n    phi_xm1 = compute_potential((r_eval_1[0] - H, r_eval_1[1], r_eval_1[2]), mass_locs_1)\n    T_xx = (phi_xp1 - 2 * phi_center + phi_xm1) / (H**2)\n    \n    # T_yy\n    phi_yp1 = compute_potential((r_eval_1[0], r_eval_1[1] + H, r_eval_1[2]), mass_locs_1)\n    phi_ym1 = compute_potential((r_eval_1[0], r_eval_1[1] - H, r_eval_1[2]), mass_locs_1)\n    T_yy = (phi_yp1 - 2 * phi_center + phi_ym1) / (H**2)\n    \n    # T_zz\n    phi_zp1 = compute_potential((r_eval_1[0], r_eval_1[1], r_eval_1[2] + H), mass_locs_1)\n    phi_zm1 = compute_potential((r_eval_1[0], r_eval_1[1], r_eval_1[2] - H), mass_locs_1)\n    T_zz = (phi_zp1 - 2 * phi_center + phi_zm1) / (H**2)\n    \n    S_case1 = T_xx + T_yy + T_zz\n    results.append(S_case1 * EOTVOS_CONVERSION)\n\n    # --- Test Case 2: T_xy at (0, 0, 0) m ---\n    case2_params = [\n        ((-800.0, -400.0), (-200.0, 200.0), (-200.0, 200.0)),\n        ((400.0, 800.0), (-200.0, 200.0), (-200.0, 200.0))\n    ]\n    mass_locs_2 = get_mass_locations(case2_params)\n    r_eval_2 = (0.0, 0.0, 0.0)\n    \n    phi_xp1_yp1 = compute_potential((r_eval_2[0] + H, r_eval_2[1] + H, r_eval_2[2]), mass_locs_2)\n    phi_xp1_ym1 = compute_potential((r_eval_2[0] + H, r_eval_2[1] - H, r_eval_2[2]), mass_locs_2)\n    phi_xm1_yp1 = compute_potential((r_eval_2[0] - H, r_eval_2[1] + H, r_eval_2[2]), mass_locs_2)\n    phi_xm1_ym1 = compute_potential((r_eval_2[0] - H, r_eval_2[1] - H, r_eval_2[2]), mass_locs_2)\n    \n    T_xy_case2 = (phi_xp1_yp1 - phi_xp1_ym1 - phi_xm1_yp1 + phi_xm1_ym1) / (4 * H**2)\n    results.append(T_xy_case2 * EOTVOS_CONVERSION)\n\n    # --- Test Case 3: T_zz at (0, 0, 1600) m ---\n    case3_params = [((-200.0, 200.0), (-200.0, 200.0), (-900.0, -500.0))]\n    mass_locs_3 = get_mass_locations(case3_params)\n    r_eval_3 = (0.0, 0.0, 1600.0)\n    \n    phi_k = compute_potential(r_eval_3, mass_locs_3)\n    phi_km1 = compute_potential((r_eval_3[0], r_eval_3[1], r_eval_3[2] - H), mass_locs_3)\n    phi_km2 = compute_potential((r_eval_3[0], r_eval_3[1], r_eval_3[2] - 2 * H), mass_locs_3)\n    phi_km3 = compute_potential((r_eval_3[0], r_eval_3[1], r_eval_3[2] - 3 * H), mass_locs_3)\n    \n    T_zz_case3 = (2 * phi_k - 5 * phi_km1 + 4 * phi_km2 - phi_km3) / (H**2)\n    results.append(T_zz_case3 * EOTVOS_CONVERSION)\n\n    # Final print statement in the exact required format.\n    # The format string \"{:.6f}\" handles rounding to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After computing the gravity gradient tensor, the next challenge is interpretation. This exercise explores a powerful method for source characterization by leveraging tensor invariants—scalar quantities like $I_2$ and the determinant $I_3$ that are independent of the measurement coordinate system. These invariants act as unique \"fingerprints\" for different types of geologic structures. This practice moves beyond simple computation to automated analysis, demonstrating how to classify anomaly geometries by implementing a decision-tree based on these rotationally invariant properties. ",
            "id": "3602059",
            "problem": "You are to write a complete, self-contained program that computes invariant combinations of the Gravity Gradient Tensor (GGT) to classify canonical anomaly geometries. Start from the Newtonian gravitational potential and the definition of the Gravity Gradient Tensor, derive and implement models for the tensor for several geometries, compute the invariants, and then classify the geometry based on these invariants.\n\nScientific and mathematical base to use:\n- Newtonian gravitational potential: $$\\Phi(\\mathbf{x}) = G \\int \\frac{\\rho(\\mathbf{x}')}{\\|\\mathbf{x} - \\mathbf{x}'\\|} \\, dV',$$ where $G$ is the gravitational constant, $\\rho$ is mass density, and $\\mathbf{x}$ is the observation point.\n- Gravity Gradient Tensor (GGT): $$T_{ij}(\\mathbf{x}) = \\frac{\\partial^2 \\Phi(\\mathbf{x})}{\\partial x_i \\partial x_j}.$$\n- Invariants: $$I_2 = \\tfrac{1}{2}\\left[(\\operatorname{tr} T)^2 - \\operatorname{tr}(T^2)\\right], \\quad I_3 = \\det T.$$\n\nTasks:\n1. Using the above fundamental definitions, derive and implement the GGT $T$ for each of the following canonical geometries at a specified observation point:\n   - A point mass at the origin with mass $m$.\n   - An infinite straight line mass aligned with the $y$-axis having linear density $\\lambda$.\n   - An infinite plane sheet at $z=0$ with surface density $\\sigma$.\n   - A homogeneous solid sphere with density $\\rho$ and radius $a$, at a point either inside or outside the sphere.\n\n2. For each geometry and parameter set provided in the test suite, compute the tensor $T$ at the given observation point $\\mathbf{x}$, then compute the invariants $I_2$ and $I_3$, the trace $\\operatorname{tr} T$, and the Frobenius norm scale $$s = \\sqrt{\\operatorname{tr}(T^2)}.$$\n\n3. Classify the geometry based on the following decision rule using the invariants. Use absolute and relative thresholds that are dimensionally consistent:\n   - Define $$\\varepsilon = 10^{-30} \\, \\mathrm{s}^{-2}, \\quad t = \\frac{|\\operatorname{tr} T|}{s + \\delta}, \\quad d = \\frac{|I_3|}{(s + \\delta)^3},$$ where $\\delta = 10^{-300}$ is a guard to avoid division by zero when $s=0$. The unit for $s$ is $\\mathrm{s}^{-2}$, so $\\varepsilon$ shares this unit. The ratios $t$ and $d$ are dimensionless.\n   - Decision rule:\n     - If $s \\le \\varepsilon$, classify as $0$ (sheet-like or effectively zero-gradient region).\n     - Else if $t \\le 10^{-12}$ and $d \\le 10^{-12}$, classify as $1$ (line-like, with one zero eigenvalue and zero determinant).\n     - Else if $t \\le 10^{-12}$ and $I_3 > 0$ and $I_2  0$, classify as $2$ (point-like, compact source observed in a source-free region with zero trace and positive determinant).\n     - Else if $t > 10^{-12}$ and $I_3  0$, classify as $3$ (volume-interior region, for example inside a homogeneous sphere).\n     - Else, classify as $2$.\n\nPhysical constants and units:\n- Use $$G = 6.67430 \\times 10^{-11} \\, \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}.$$\n- All distances are in $\\mathrm{m}$, masses in $\\mathrm{kg}$, densities in $\\mathrm{kg/m^3}$, linear densities in $\\mathrm{kg/m}$, surface densities in $\\mathrm{kg/m^2}$. The Gravity Gradient Tensor components $T_{ij}$ must be computed in $\\mathrm{s}^{-2}$.\n\nTest suite:\nCompute and classify the following five cases:\n- Case $1$: Point mass at the origin with $$m = 5 \\times 10^{12} \\, \\mathrm{kg}, \\quad \\mathbf{x} = (100, 0, 0) \\, \\mathrm{m}.$$\n- Case $2$: Infinite line mass along the $y$-axis with $$\\lambda = 1 \\times 10^{9} \\, \\mathrm{kg/m}, \\quad \\mathbf{x} = (50, 0, 50) \\, \\mathrm{m}.$$\n- Case $3$: Infinite plane sheet at $z=0$ with $$\\sigma = 3.0 \\times 10^{3} \\, \\mathrm{kg/m^2}, \\quad \\mathbf{x} = (0, 0, 100) \\, \\mathrm{m}.$$\n- Case $4$: Homogeneous sphere with $$\\rho = 2.5 \\times 10^{3} \\, \\mathrm{kg/m^3}, \\quad a = 50 \\, \\mathrm{m}, \\quad \\mathbf{x} = (10, 0, 0) \\, \\mathrm{m} \\text{ (inside)}.$$\n- Case $5$: Same sphere as Case $4$ observed outside at $$\\mathbf{x} = (200, 0, 0) \\, \\mathrm{m}.$$\n\nFinal output format:\nYour program should produce a single line of output containing the integer classification codes for the five cases as a comma-separated list enclosed in square brackets, for example, $$[c_1,c_2,c_3,c_4,c_5],$$ where each $c_i$ is an integer produced by the decision rule above.",
            "solution": "The problem requires the development of a computational method to classify canonical mass geometries based on invariants of the Gravity Gradient Tensor (GGT). This involves deriving the GGT for several idealized mass distributions, implementing these models numerically, and then applying a specific decision tree based on the tensor invariants.\n\nThe fundamental principles are the Newtonian gravitational potential and the definition of the GGT. The potential $\\Phi$ at an observation point $\\mathbf{x}$ due to a mass distribution with density $\\rho$ is given by\n$$\\Phi(\\mathbf{x}) = G \\int \\frac{\\rho(\\mathbf{x}')}{\\|\\mathbf{x} - \\mathbf{x}'\\|} \\, dV'$$\nwhere $G$ is the gravitational constant, and the integration is over the volume of the source. The GGT, denoted by $T$, is a symmetric tensor whose components $T_{ij}$ are the second partial derivatives of the potential:\n$$T_{ij}(\\mathbf{x}) = \\frac{\\partial^2 \\Phi(\\mathbf{x})}{\\partial x_i \\partial x_j}$$\nThe trace of the GGT, $\\operatorname{tr}(T) = \\sum_i T_{ii}$, is related to the local mass density via Poisson's equation for gravity, $\\nabla^2 \\Phi = -4\\pi G \\rho$. Therefore, $\\operatorname{tr}(T) = -4\\pi G \\rho(\\mathbf{x})$. In a source-free region where $\\rho(\\mathbf{x})=0$, the trace of the GGT is zero.\n\nThe solution proceeds in two stages: first, deriving the GGT for each specified geometry, and second, implementing the classification algorithm using these tensor models.\n\n**1. Derivation of the Gravity Gradient Tensor Models**\n\nLet the observation point be $\\mathbf{r} = (x, y, z)$. The GGT components are derived from the potential $\\Phi$ for each geometry.\n\n**A. Point Mass at the Origin**\nFor a point mass $m$ at the origin, the potential at position $\\mathbf{r}$ (with magnitude $r = \\|\\mathbf{r}\\| = \\sqrt{x^2+y^2+z^2}$) is $\\Phi(r) = Gm/r$. The GGT components $T_{ij}$ are found by taking second derivatives:\n$$T_{ij} = \\frac{\\partial^2}{\\partial x_i \\partial x_j} \\left(\\frac{Gm}{r}\\right) = Gm \\left( \\frac{3x_i x_j}{r^5} - \\frac{\\delta_{ij}}{r^3} \\right)$$\nwhere $\\delta_{ij}$ is the Kronecker delta. In matrix form, this is:\n$$ T = \\frac{Gm}{r^5} \\begin{pmatrix} 3x^2 - r^2  3xy  3xz \\\\ 3xy  3y^2 - r^2  3yz \\\\ 3xz  3yz  3z^2 - r^2 \\end{pmatrix} $$\nThe trace is $\\operatorname{tr}(T) = \\frac{Gm}{r^5} (3(x^2+y^2+z^2) - 3r^2) = 0$, as expected in a source-free region.\n\n**B. Infinite Line Mass**\nFor an infinite line mass with linear density $\\lambda$ aligned with the $y$-axis, the potential at a point $(x, y, z)$ depends only on the perpendicular distance $R = \\sqrt{x^2+z^2}$ from the line. The potential for attractive gravity is logarithmic, $\\Phi(R) \\propto \\ln(1/R)$. We can use $\\Phi(R) = -2G\\lambda \\ln(R)$, as the GGT is independent of any additive constant.\nThe GGT components are calculated by differentiating $\\Phi = -G\\lambda \\ln(x^2+z^2)$.\n$$T_{xx} = \\frac{\\partial^2 \\Phi}{\\partial x^2} = -2G\\lambda \\frac{\\partial}{\\partial x}\\left(\\frac{x}{x^2+z^2}\\right) = 2G\\lambda \\frac{x^2-z^2}{(x^2+z^2)^2}$$\n$$T_{zz} = \\frac{\\partial^2 \\Phi}{\\partial z^2} = 2G\\lambda \\frac{z^2-x^2}{(x^2+z^2)^2}$$\n$$T_{xz} = \\frac{\\partial^2 \\Phi}{\\partial x \\partial z} = -2G\\lambda \\frac{\\partial}{\\partial z}\\left(\\frac{x}{x^2+z^2}\\right) = 4G\\lambda \\frac{xz}{(x^2+z^2)^2}$$\nAll other components, including $T_{yy}$ and those involving derivatives with respect to $y$, are zero. The resulting tensor is:\n$$ T = \\frac{2G\\lambda}{(x^2+z^2)^2} \\begin{pmatrix} x^2 - z^2  0  2xz \\\\ 0  0  0 \\\\ 2xz  0  z^2 - x^2 \\end{pmatrix} $$\nThe trace and determinant are both zero.\n\n**C. Infinite Planar Sheet**\nFor an infinite sheet of mass with surface density $\\sigma$ in the $z=0$ plane, the gravitational field is uniform and directed along the $z$-axis: $\\mathbf{g} = \\nabla \\Phi = -2\\pi G \\sigma \\operatorname{sgn}(z) \\hat{\\mathbf{z}}$. Since the field $\\mathbf{g}$ is constant for any $z \\neq 0$, its gradient is zero.\n$$ T_{ij} = \\frac{\\partial g_i}{\\partial x_j} = 0 $$\nThus, the GGT is the zero matrix for any observation point not on the sheet itself.\n\n**D. Homogeneous Solid Sphere**\nFor a sphere of radius $a$ and constant density $\\rho$, we have two cases.\n- **Outside the sphere ($r > a$)**: By Newton's shell theorem, the sphere acts as a point mass $M = \\frac{4}{3}\\pi a^3 \\rho$ located at the origin. The GGT is therefore identical to the point mass case, with $m$ replaced by $M$.\n- **Inside the sphere ($r  a$)**: The potential is $\\Phi(r) = \\frac{2\\pi G \\rho}{3}(3a^2 - r^2)$.\nThe second derivatives are straightforward to compute:\n$$T_{xx} = \\frac{\\partial^2 \\Phi}{\\partial x^2} = \\frac{\\partial}{\\partial x}\\left(-\\frac{4\\pi G \\rho}{3}x\\right) = -\\frac{4\\pi G \\rho}{3}$$\nSimilarly, $T_{yy} = T_{zz} = -\\frac{4\\pi G \\rho}{3}$. The off-diagonal components are zero. The GGT is a scalar multiple of the identity matrix $I$:\n$$ T = -\\frac{4\\pi G \\rho}{3} I $$\nThe trace is $\\operatorname{tr}(T) = -4\\pi G \\rho$, which is consistent with Poisson's equation for a point inside the mass distribution.\n\n**2. Classification Algorithm**\n\nThe classification is performed using a decision tree based on several computed quantities:\n- The trace $\\operatorname{tr}(T)$.\n- The Frobenius norm scale $s = \\sqrt{\\operatorname{tr}(T^2)}$.\n- The invariants $I_2 = \\frac{1}{2}\\left[(\\operatorname{tr} T)^2 - \\operatorname{tr}(T^2)\\right]$ and $I_3 = \\det T$.\n- The dimensionless ratios $t = \\frac{|\\operatorname{tr} T|}{s + \\delta}$ and $d = \\frac{|I_3|}{(s + \\delta)^3}$, with a small guard $\\delta=10^{-300}$.\n\nThe classification rules are applied sequentially:\n1.  If $s \\le 10^{-30} \\, \\mathrm{s}^{-2}$: Classify as $0$ (sheet or zero-gradient).\n2.  Else if $t \\le 10^{-12}$ and $d \\le 10^{-12}$: Classify as $1$ (line-like).\n3.  Else if $t \\le 10^{-12}$, $I_3 > 0$, and $I_2  0$: Classify as $2$ (point-like).\n4.  Else if $t > 10^{-12}$ and $I_3  0$: Classify as $3$ (volume-interior).\n5.  Else: Classify as $2$.\n\n**Application to Test Cases**\n\n- **Case 1 (Point Mass)**: $m = 5 \\times 10^{12} \\, \\mathrm{kg}$, $\\mathbf{x}=(100, 0, 0)\\,\\mathrm{m}$. The tensor is diagonal with eigenvalues proportional to $(2, -1, -1)$. This leads to $\\operatorname{tr}(T)=0$ ($t=0$), $I_3 > 0$, and $I_2  0$. The value of $d$ is non-negligible. The rules lead to classification code $2$.\n- **Case 2 (Line Mass)**: $\\lambda = 1 \\times 10^{9} \\, \\mathrm{kg/m}$, $\\mathbf{x}=(50, 0, 50)\\,\\mathrm{m}$. The tensor has a zero row and column, leading to $\\operatorname{tr}(T)=0$ and $I_3=0$. Thus, $t=0$ and $d=0$. The rules lead to classification code $1$.\n- **Case 3 (Plane Sheet)**: $\\sigma = 3.0 \\times 10^{3} \\, \\mathrm{kg/m^2}$, $\\mathbf{x}=(0, 0, 100)\\,\\mathrm{m}$. The GGT is the zero matrix. $s=0$, so the first rule applies. The classification is $0$.\n- **Case 4 (Sphere Inside)**: $\\rho = 2.5 \\times 10^{3} \\, \\mathrm{kg/m^3}$, $a=50\\,\\mathrm{m}$, $\\mathbf{x}=(10, 0, 0)\\,\\mathrm{m}$. The tensor is a negative multiple of the identity matrix. $\\operatorname{tr}(T)$ is non-zero, making $t > 10^{-12}$. $I_3$ is negative. The rules lead to classification code $3$.\n- **Case 5 (Sphere Outside)**: Same sphere, $\\mathbf{x}=(200, 0, 0)\\,\\mathrm{m}$. The observation point is outside, so the sphere behaves as a point mass. The analysis is identical to Case $1$. The classification is $2$.\n\nThe final sequence of classification codes is $[2, 1, 0, 3, 2]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes invariant combinations of the Gravity Gradient Tensor (GGT)\n    to classify canonical anomaly geometries for a given set of test cases.\n    \"\"\"\n    G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2\n    \n    # Classification parameters\n    EPSILON = 1e-30\n    DELTA = 1e-300\n    T_THRESH = 1e-12\n    D_THRESH = 1e-12\n\n    def compute_ggt_point(m, x_obs):\n        \"\"\"Computes GGT for a point mass at the origin.\"\"\"\n        r = np.linalg.norm(x_obs)\n        if r == 0:\n            return np.full((3, 3), np.inf)\n        \n        r_inv3 = 1.0 / r**3\n        r_inv5 = 1.0 / r**5\n        \n        T = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                delta_ij = 1 if i == j else 0\n                T[i, j] = G * m * (3 * x_obs[i] * x_obs[j] * r_inv5 - delta_ij * r_inv3)\n        return T\n\n    def compute_ggt_line(lambda_val, x_obs):\n        \"\"\"Computes GGT for an infinite line mass along the y-axis.\"\"\"\n        x, _, z = x_obs\n        R2 = x**2 + z**2\n        if R2 == 0:\n            return np.full((3, 3), np.inf)\n\n        factor = 2 * G * lambda_val / (R2**2)\n        T = np.zeros((3, 3))\n        T[0, 0] = factor * (x**2 - z**2)\n        T[0, 2] = T[2, 0] = factor * (2 * x * z)\n        T[2, 2] = factor * (z**2 - x**2)\n        return T\n\n    def compute_ggt_sheet(sigma, x_obs):\n        \"\"\"Computes GGT for an infinite plane sheet at z=0.\"\"\"\n        # GGT is zero everywhere off the plane\n        return np.zeros((3, 3))\n\n    def compute_ggt_sphere(rho, a, x_obs):\n        \"\"\"Computes GGT for a homogeneous sphere.\"\"\"\n        r = np.linalg.norm(x_obs)\n        if r > a:  # Outside sphere\n            M = (4.0 / 3.0) * np.pi * (a**3) * rho\n            return compute_ggt_point(M, x_obs)\n        else:  # Inside sphere\n            factor = -4.0 * np.pi * G * rho / 3.0\n            return factor * np.identity(3)\n\n    test_cases = [\n        {'type': 'point', 'params': {'m': 5e12}, 'x_obs': np.array([100.0, 0.0, 0.0])},\n        {'type': 'line', 'params': {'lambda_val': 1e9}, 'x_obs': np.array([50.0, 0.0, 50.0])},\n        {'type': 'sheet', 'params': {'sigma': 3e3}, 'x_obs': np.array([0.0, 0.0, 100.0])},\n        {'type': 'sphere', 'params': {'rho': 2.5e3, 'a': 50.0}, 'x_obs': np.array([10.0, 0.0, 0.0])},\n        {'type': 'sphere', 'params': {'rho': 2.5e3, 'a': 50.0}, 'x_obs': np.array([200.0, 0.0, 0.0])},\n    ]\n\n    results = []\n    for case in test_cases:\n        T = np.zeros((3, 3))\n        if case['type'] == 'point':\n            T = compute_ggt_point(case['params']['m'], case['x_obs'])\n        elif case['type'] == 'line':\n            T = compute_ggt_line(case['params']['lambda_val'], case['x_obs'])\n        elif case['type'] == 'sheet':\n            T = compute_ggt_sheet(case['params']['sigma'], case['x_obs'])\n        elif case['type'] == 'sphere':\n            T = compute_ggt_sphere(case['params']['rho'], case['params']['a'], case['x_obs'])\n\n        # Compute invariants and classification parameters\n        tr_T = np.trace(T)\n        T_squared = T @ T\n        tr_T_squared = np.trace(T_squared)\n        \n        s = np.sqrt(tr_T_squared)\n        \n        # Invariants I2 and I3\n        I2 = 0.5 * (tr_T**2 - tr_T_squared)\n        I3 = np.linalg.det(T)\n        \n        # Dimensionless ratios t and d\n        t = np.abs(tr_T) / (s + DELTA)\n        d = np.abs(I3) / ((s + DELTA)**3)\n        \n        # Apply decision rule\n        classification = 0\n        if s = EPSILON:\n            classification = 0\n        elif t = T_THRESH and d = D_THRESH:\n            classification = 1\n        elif t = T_THRESH and I3 > 0 and I2  0:\n            classification = 2\n        elif t > T_THRESH and I3  0:\n            classification = 3\n        else:\n            classification = 2\n            \n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate goal in many geophysical surveys is to invert measured field data to determine unknown source properties. This exercise introduces the inverse problem for gravity gradiometry and explores a critical aspect of real-world applications: uncertainty. It formulates the problem as a linear system $\\mathbf{d} = G \\mathbf{A} \\mathbf{m}$ and uses least-squares inversion to estimate the source masses $\\mathbf{m}$, investigating how systematic errors in the gravitational constant $G$ propagate through the inversion. This practice provides hands-on experience with linear inversion and highlights the importance of designing calibration protocols to improve the reliability of results. ",
            "id": "3602043",
            "problem": "You are tasked with modeling and inverting the gravity gradient tensor for point-mass configurations, and quantifying how uncertainty in the gravitational constant propagates through the inversion. You must begin from a fundamental physical base and proceed to a numerical implementation that produces specified outputs. The fundamental base is the Newtonian gravitational potential and the definition of the gravity gradient tensor. All derivations and reasoning must be performed from this base without using any shortcut formulas. Physical units must be explicitly stated and maintained consistently: mass in kilograms, positions in meters, and gravity gradient components in inverse seconds squared. Angles do not appear in this problem. Your program must produce results for the provided test suite and print all results as floats in a single, comma-separated list enclosed in square brackets.\n\nStarting point for derivation:\n- The Newtonian gravitational potential for a point mass is $\\Phi(\\mathbf{x}) = \\dfrac{G m}{\\|\\mathbf{x}\\|}$, where $G$ is the gravitational constant, $m$ is the mass, and $\\mathbf{x}$ is the position vector measured relative to the mass.\n- The gravity gradient tensor (GGT) $T_{ij}(\\mathbf{x})$ is defined by $T_{ij}(\\mathbf{x}) = \\dfrac{\\partial^2 \\Phi(\\mathbf{x})}{\\partial x_i \\partial x_j}$, where $i$ and $j$ denote Cartesian components.\n- The observable considered here is the $T_{zz}$ component at given observation points.\n\nTasks:\n- Derive the gravity gradient tensor $T_{ij}(\\mathbf{x})$ for a single point mass solely from $\\Phi(\\mathbf{x}) = \\dfrac{G m}{\\|\\mathbf{x}\\|}$ and the definition $T_{ij}(\\mathbf{x}) = \\dfrac{\\partial^2 \\Phi(\\mathbf{x})}{\\partial x_i \\partial x_j}$, expressing the result in terms of $G$, $m$, and geometry.\n- Show that the $T_{zz}$ component for $N$ point masses at a set of observation points can be written as a linear model $\\mathbf{d} = G \\mathbf{A} \\mathbf{m}$, where $\\mathbf{d}$ is the vector of $T_{zz}$ observations, $\\mathbf{m}$ is the vector of masses, and $\\mathbf{A}$ is a geometry-dependent matrix whose entries depend on the relative positions between masses and observation points.\n- Derive, under noise-free conditions and full-column rank of $\\mathbf{A}$, how a multiplicative uncertainty in $G$ propagates through a linear least-squares inversion for $\\mathbf{m}$, making explicit the scaling relationship between the estimated masses and the true masses.\n- Propose a calibration protocol that uses known reference masses at known positions to estimate an effective scale factor for $G$ (and instrument scale) by minimizing the discrepancy between predicted and measured $T_{zz}$ data in the least-squares sense. Provide a closed-form expression for the best-fit scale factor under the linear model.\n\nImplementation requirements:\n- Implement a forward model for the $T_{zz}$ component at each observation point due to each point mass, constructed directly from the derived gravity gradient tensor for a point mass. Use no approximations beyond double-precision arithmetic.\n- Implement linear least-squares inversion to estimate the masses from the data, using the assumed $G$ in the forward operator. The inversion must use deterministic algorithms available in the specified language environment. For underdetermined or ill-conditioned cases, use the minimum-norm least-squares solution.\n- Implement the proposed calibration protocol for $G$ using the known reference mass configuration by solving for the best-fit scalar scale factor that maps predicted data to measured data, and then form the calibrated gravitational constant.\n\nUnits:\n- Masses must be in kilograms ($\\mathrm{kg}$).\n- Positions must be in meters ($\\mathrm{m}$).\n- Gravity gradient $T_{zz}$ must be in inverse seconds squared ($\\mathrm{s}^{-2}$).\n- The outputs are dimensionless floats.\n\nTest suite:\n- In all cases, $G_{\\text{assumed}} = 6.67430 \\times 10^{-11}$, and $G_{\\text{true}} = G_{\\text{assumed}} \\times (1 + \\delta)$ with $\\delta = 5 \\times 10^{-5}$.\n- Use the following three test cases, each defined by mass positions, observation positions, true masses, and noise level. In all cases, use kilogram for mass and meter for positions, and compute $T_{zz}$ in $\\mathrm{s}^{-2}$.\n\nCase $1$ (well-conditioned, noise-free):\n- Mass positions: $(-0.5, 0, 0)$ and $(+0.5, 0, 0)$.\n- Observation positions: $(0, 0, 1)$, $(0.5, 0, 1)$, $(-0.5, 0, 1)$, $(0, 0.5, 1)$.\n- True masses: $(10, 10)$.\n- Noise standard deviation: $0$.\n\nCase $2$ (well-conditioned, with noise):\n- Mass positions: $(-0.5, 0, 0)$ and $(+0.5, 0, 0)$.\n- Observation positions: $(0, 0, 1)$, $(0.5, 0, 1)$, $(-0.5, 0, 1)$, $(0, 0.5, 1)$.\n- True masses: $(10, 10)$.\n- Noise standard deviation: $2.0 \\times 10^{-12}$. Use a deterministic seed of $42$ for the Gaussian noise generator.\n\nCase $3$ (ill-conditioned geometry, noise-free):\n- Mass positions: $(-0.001, 0, 0)$ and $(+0.001, 0, 0)$.\n- Observation positions: $(0, 0, 1)$, $(0, 0, 1.5)$, $(0, 0, 2)$.\n- True masses: $(10, 10)$.\n- Noise standard deviation: $0$.\n\nFor each case, perform:\n- Forward modeling of $\\mathbf{d}$ using $G_{\\text{true}}$ and the true masses.\n- Linear least-squares inversion for $\\hat{\\mathbf{m}}$ using $G_{\\text{assumed}}$, returning the minimum-norm estimate when necessary.\n- Compute the mass-total relative error $e_m = \\dfrac{\\sum_j \\hat{m}_j - \\sum_j m_j}{\\sum_j m_j}$.\n- Compute the calibration scale factor $s$ that minimizes $\\| s \\mathbf{p} - \\mathbf{d} \\|_2$, with $\\mathbf{p} = G_{\\text{assumed}} \\mathbf{A} \\mathbf{m}$ built from the known reference masses and positions and $G_{\\text{assumed}}$. Form $\\hat{G} = s \\, G_{\\text{assumed}}$, and compute the gravitational constant relative error $e_G = \\dfrac{\\hat{G} - G_{\\text{true}}}{G_{\\text{true}}}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[e_{m,1}, e_{G,1}, e_{m,2}, e_{G,2}, e_{m,3}, e_{G,3}]$, where indices denote the test case number. For example, print the results like $[r_1,r_2,r_3,r_4,r_5,r_6]$.",
            "solution": "The problem is valid as it is scientifically grounded in Newtonian physics, well-posed with a clear objective, and provides all necessary information for a unique solution.\n\n**Problem Validation**\n\n**Step 1: Extract Givens**\n- **Fundamental Physics:**\n    - Newtonian gravitational potential for a point mass: $\\Phi(\\mathbf{x}) = \\dfrac{G m}{\\|\\mathbf{x}\\|}$.\n    - Gravity Gradient Tensor (GGT) definition: $T_{ij}(\\mathbf{x}) = \\dfrac{\\partial^2 \\Phi(\\mathbf{x})}{\\partial x_i \\partial x_j}$.\n    - The observable is the $T_{zz}$ component of the GGT.\n- **Physical Constants:**\n    - Assumed gravitational constant: $G_{\\text{assumed}} = 6.67430 \\times 10^{-11} \\, \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$.\n    - True gravitational constant: $G_{\\text{true}} = G_{\\text{assumed}} \\times (1 + \\delta)$, with $\\delta = 5 \\times 10^{-5}$.\n- **Units:**\n    - Mass: kilograms ($\\mathrm{kg}$).\n    - Position: meters ($\\mathrm{m}$).\n    - Gravity gradient: inverse seconds squared ($\\mathrm{s}^{-2}$).\n- **Tasks:**\n    1. Derive the GGT $T_{ij}(\\mathbf{x})$ for a single point mass.\n    2. Show the linear model form $\\mathbf{d} = G \\mathbf{A} \\mathbf{m}$ for $T_{zz}$ observations.\n    3. Derive the propagation of multiplicative uncertainty in $G$ through least-squares inversion.\n    4. Propose a calibration protocol and derive the closed-form expression for the scale factor.\n- **Test Cases:**\n    - **Case 1 (well-conditioned, noise-free):**\n        - Mass positions: $[(-0.5, 0, 0), (0.5, 0, 0)] \\, \\mathrm{m}$.\n        - Observation positions: $[(0, 0, 1), (0.5, 0, 1), (-0.5, 0, 1), (0, 0.5, 1)] \\, \\mathrm{m}$.\n        - True masses: $[10, 10] \\, \\mathrm{kg}$.\n        - Noise standard deviation: $0 \\, \\mathrm{s}^{-2}$.\n    - **Case 2 (well-conditioned, with noise):**\n        - Same geometry and masses as Case 1.\n        - Noise standard deviation: $2.0 \\times 10^{-12} \\, \\mathrm{s}^{-2}$.\n        - Noise generator seed: $42$.\n    - **Case 3 (ill-conditioned, noise-free):**\n        - Mass positions: $[(-0.001, 0, 0), (0.001, 0, 0)] \\, \\mathrm{m}$.\n        - Observation positions: $[(0, 0, 1), (0, 0, 1.5), (0, 0, 2)] \\, \\mathrm{m}$.\n        - True masses: $[10, 10] \\, \\mathrm{kg}$.\n        - Noise standard deviation: $0 \\, \\mathrm{s}^{-2}$.\n- **Required Outputs:**\n    - For each case, compute the mass-total relative error $e_m = \\dfrac{\\sum_j \\hat{m}_j - \\sum_j m_j}{\\sum_j m_j}$.\n    - For each case, compute the gravitational constant relative error $e_G = \\dfrac{\\hat{G} - G_{\\text{true}}}{G_{\\text{true}}}$.\n    - The final output must be a single line: $[e_{m,1}, e_{G,1}, e_{m,2}, e_{G,2}, e_{m,3}, e_{G,3}]$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is based on Newtonian mechanics and potential theory, which are fundamental principles of physics. The concepts of gravity gradients and their inversion are standard practice in geophysics and geodesy. All aspects are scientifically sound.\n- **Well-Posed:** The problem provides clear objectives, all necessary data, and well-defined test cases. The tasks are structured to lead to a unique and meaningful numerical solution.\n- **Objective:** The problem statement is expressed in precise, quantitative, and unbiased language, free from subjective claims.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n**Derivations and Algorithmic Design**\n\n**1. Derivation of the Gravity Gradient Tensor for a Point Mass**\n\nThe gravitational potential $\\Phi$ at a position $\\mathbf{x} = (x_1, x_2, x_3)$ relative to a point mass $m$ at the origin is given by:\n$$ \\Phi(\\mathbf{x}) = \\frac{G m}{\\|\\mathbf{x}\\|} = Gm(x_1^2 + x_2^2 + x_3^2)^{-1/2} $$\nLet $R = \\|\\mathbf{x}\\| = (x_1^2 + x_2^2 + x_3^2)^{1/2}$. The components of the gravity vector $\\mathbf{g} = \\nabla \\Phi$ are the first partial derivatives of the potential:\n$$ \\frac{\\partial \\Phi}{\\partial x_j} = Gm \\frac{\\partial}{\\partial x_j} (R^{-1}) = Gm (-1)R^{-2} \\frac{\\partial R}{\\partial x_j} $$\nSince $\\frac{\\partial R}{\\partial x_j} = \\frac{x_j}{R}$, we have:\n$$ \\frac{\\partial \\Phi}{\\partial x_j} = -Gm \\frac{x_j}{R^3} $$\nThe gravity gradient tensor $T_{ij}$ is the matrix of second partial derivatives, $T_{ij} = \\frac{\\partial^2 \\Phi}{\\partial x_i \\partial x_j}$. Applying the quotient rule or product rule:\n$$ T_{ij}(\\mathbf{x}) = \\frac{\\partial}{\\partial x_i} \\left( -Gm \\frac{x_j}{R^3} \\right) = -Gm \\left[ \\frac{-\\delta_{ij} R^3 - x_j (-3R^{-4} \\frac{\\partial R}{\\partial x_i})}{R^0} \\right] $$\nThis seems complex. Let's use the product rule on $\\frac{\\partial}{\\partial x_i}(-Gm x_j R^{-3})$\n$$ T_{ij}(\\mathbf{x}) = -Gm \\left[ \\frac{\\partial x_j}{\\partial x_i} R^{-3} + x_j \\frac{\\partial R^{-3}}{\\partial x_i} \\right] = -Gm \\left[ \\delta_{ij} R^{-3} + x_j (-3 R^{-4} \\frac{x_i}{R}) \\right] = Gm \\frac{3x_i x_j - \\delta_{ij} R^2}{R^5} $$\nThe specific component required is $T_{zz}$, which corresponds to $i=j=3$. Let $\\mathbf{x} = (x, y, z)$, so $R^2 = x^2+y^2+z^2$:\n$$ T_{zz}(\\mathbf{x}) = Gm \\frac{3z^2 - \\delta_{33} R^2}{R^5} = Gm \\frac{3z^2 - R^2}{R^5} $$\n\n**2. Formulation of the Linear Model**\n\nFor a system of $N$ point masses $m_k$ at positions $\\mathbf{q}_k$ and $M$ observation points at positions $\\mathbf{p}_l$, the total potential at $\\mathbf{p}_l$ is the sum of potentials from each mass:\n$$ \\Phi(\\mathbf{p}_l) = \\sum_{k=1}^{N} \\frac{G m_k}{\\|\\mathbf{p}_l - \\mathbf{q}_k\\|} $$\nDue to the linearity of differentiation, the total GGT is also a sum:\n$$ T_{zz}(\\mathbf{p}_l) = \\sum_{k=1}^{N} T_{zz,k}(\\mathbf{p}_l - \\mathbf{q}_k) $$\nLet $\\mathbf{r}_{lk} = \\mathbf{p}_l - \\mathbf{q}_k = (x_{lk}, y_{lk}, z_{lk})$ be the relative position vector. Let $R_{lk} = \\|\\mathbf{r}_{lk}\\|$. The contribution of mass $m_k$ to the $T_{zz}$ measurement at $\\mathbf{p}_l$ is:\n$$ T_{zz,k} = Gm_k \\frac{3z_{lk}^2 - R_{lk}^2}{R_{lk}^5} $$\nLet $d_l = T_{zz}(\\mathbf{p}_l)$ be the $l$-th observation. We can write:\n$$ d_l = G \\sum_{k=1}^{N} m_k \\left( \\frac{3z_{lk}^2 - R_{lk}^2}{R_{lk}^5} \\right) $$\nThis expression is linear in the masses $m_k$. We can define a geometry matrix $\\mathbf{A}$ with entries $A_{lk} = \\frac{3z_{lk}^2 - R_{lk}^2}{R_{lk}^5}$. The system of equations for all $M$ observations can then be written in matrix form:\n$$ \\mathbf{d} = G \\mathbf{A} \\mathbf{m} $$\nwhere $\\mathbf{d}$ is the $M \\times 1$ vector of observations, $\\mathbf{A}$ is the $M \\times N$ geometry matrix, and $\\mathbf{m}$ is the $N \\times 1$ vector of unknown masses.\n\n**3. Propagation of Uncertainty in $G$**\n\nWe are given \"true\" data synthesized with $G_{\\text{true}}$: $\\mathbf{d} = G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{true}}$. We perform a least-squares inversion to estimate the masses $\\hat{\\mathbf{m}}$ using a potentially incorrect $G_{\\text{assumed}}$. The model for inversion is $\\mathbf{d} = (G_{\\text{assumed}} \\mathbf{A}) \\hat{\\mathbf{m}}$.\nThe linear least-squares solution $\\hat{\\mathbf{m}}$ minimizes $\\| \\mathbf{d} - G_{\\text{assumed}} \\mathbf{A} \\hat{\\mathbf{m}} \\|_2^2$. The solution is given by:\n$$ \\hat{\\mathbf{m}} = (G_{\\text{assumed}} \\mathbf{A})^{+} \\mathbf{d} $$\nwhere $(\\cdot)^{+}$ denotes the Moore-Penrose pseudoinverse. Substituting the expression for $\\mathbf{d}$:\n$$ \\hat{\\mathbf{m}} = (G_{\\text{assumed}} \\mathbf{A})^{+} (G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{true}}) $$\nUsing the property $(c\\mathbf{X})^{+} = c^{-1} \\mathbf{X}^{+}$ for a scalar $c \\neq 0$:\n$$ \\hat{\\mathbf{m}} = \\frac{1}{G_{\\text{assumed}}} \\mathbf{A}^{+} (G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{true}}) = \\frac{G_{\\text{true}}}{G_{\\text{assumed}}} (\\mathbf{A}^{+} \\mathbf{A}) \\mathbf{m}_{\\text{true}} $$\nFor a matrix $\\mathbf{A}$ with full column rank, $\\mathbf{A}^{+}\\mathbf{A} = \\mathbf{I}$, the identity matrix. In this case, the relationship is a simple scaling:\n$$ \\hat{\\mathbf{m}} = \\frac{G_{\\text{true}}}{G_{\\text{assumed}}} \\mathbf{m}_{\\text{true}} $$\nThis demonstrates that a multiplicative error in $G$ directly propagates as a multiplicative error in the estimated masses. Even in the rank-deficient case, $\\mathbf{A}^{+}\\mathbf{A}$ is a projection onto the row space of $\\mathbf{A}$. If $\\mathbf{m}_{\\text{true}}$ lies entirely within this space (as is the case in this problem's setup), the relationship holds.\n\n**4. Calibration Protocol**\n\nThe goal is to find a scalar correction factor $s$ that best aligns the predicted data $\\mathbf{p}$ with the measured data $\\mathbf{d}$. The prediction is based on known reference masses $\\mathbf{m}_{\\text{ref}}$ and the assumed constant $G_{\\text{assumed}}$: $\\mathbf{p} = G_{\\text{assumed}} \\mathbf{A} \\mathbf{m}_{\\text{ref}}$. The measured data is $\\mathbf{d}$. We seek to minimize the squared L2-norm of the residual:\n$$ E(s) = \\| s \\mathbf{p} - \\mathbf{d} \\|_2^2 = (s \\mathbf{p} - \\mathbf{d})^T (s \\mathbf{p} - \\mathbf{d}) = s^2 (\\mathbf{p}^T \\mathbf{p}) - 2s (\\mathbf{p}^T \\mathbf{d}) + \\mathbf{d}^T \\mathbf{d} $$\nTo find the optimal $s$, we set the derivative of $E(s)$ with respect to $s$ to zero:\n$$ \\frac{dE}{ds} = 2s (\\mathbf{p}^T \\mathbf{p}) - 2 (\\mathbf{p}^T \\mathbf{d}) = 0 $$\nSolving for $s$ yields the closed-form expression:\n$$ s = \\frac{\\mathbf{p}^T \\mathbf{d}}{\\mathbf{p}^T \\mathbf{p}} = \\frac{\\langle \\mathbf{p}, \\mathbf{d} \\rangle}{\\| \\mathbf{p} \\|_2^2} $$\nThe calibrated gravitational constant is then $\\hat{G} = s \\cdot G_{\\text{assumed}}$. In a noise-free scenario where $\\mathbf{d} = G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{ref}}$, we have $\\mathbf{d} = (G_{\\text{true}}/G_{\\text{assumed}}) \\mathbf{p}$. Substituting this into the equation for $s$ yields $s = G_{\\text{true}}/G_{\\text{assumed}}$, and thus $\\hat{G} = G_{\\text{true}}$, showing the calibration perfectly corrects for the error in $G$.\n\n**Implementation Plan**\nThe numerical solution will follow these steps for each test case:\n1.  Define the geometry (mass and observation positions) and true masses $\\mathbf{m}_{\\text{true}}$.\n2.  Construct the $M \\times N$ geometry matrix $\\mathbf{A}$ where each element $A_{lk}$ is computed as $\\frac{3z_{lk}^2 - R_{lk}^2}{R_{lk}^5}$.\n3.  Synthesize the \"measured\" data vector $\\mathbf{d}$ using $\\mathbf{d} = G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{true}}$. For Case 2, add Gaussian noise with the specified standard deviation and seed.\n4.  Perform the least-squares inversion by solving $\\mathbf{d} = (G_{\\text{assumed}} \\mathbf{A}) \\hat{\\mathbf{m}}$ for $\\hat{\\mathbf{m}}$. This is done using `numpy.linalg.lstsq`, which correctly handles both well-conditioned and ill-conditioned systems by providing the minimum-norm solution.\n5.  Calculate the mass-total relative error $e_m = (\\sum \\hat{m}_j - \\sum m_j) / (\\sum m_j)$.\n6.  Perform the calibration. Calculate the predicted data vector $\\mathbf{p} = G_{\\text{assumed}} \\mathbf{A} \\mathbf{m}_{\\text{true}}$. Compute the scale factor $s$ using the derived formula $s = (\\mathbf{p} \\cdot \\mathbf{d}) / (\\mathbf{p} \\cdot \\mathbf{p})$.\n7.  Calculate the calibrated $\\hat{G} = s \\cdot G_{\\text{assumed}}$ and the corresponding relative error $e_G = (\\hat{G} - G_{\\text{true}}) / G_{\\text{true}}$.\n8.  Collect the six resulting error values ($e_m, e_G$ for each of the three cases) and format them into the required string output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravity gradient tensor modeling and inversion problem\n    for three test cases.\n    \"\"\"\n    # Define physical constants\n    G_assumed = 6.67430e-11  # m^3 kg^-1 s^-2\n    delta = 5e-5\n    G_true = G_assumed * (1 + delta)\n\n    # Define test suite\n    test_cases = [\n        {\n            \"name\": \"Case 1 (well-conditioned, noise-free)\",\n            \"mass_positions\": np.array([[-0.5, 0, 0], [0.5, 0, 0]]),\n            \"obs_positions\": np.array([(0, 0, 1), (0.5, 0, 1), (-0.5, 0, 1), (0, 0.5, 1)]),\n            \"true_masses\": np.array([10.0, 10.0]),\n            \"noise_std\": 0.0,\n        },\n        {\n            \"name\": \"Case 2 (well-conditioned, with noise)\",\n            \"mass_positions\": np.array([[-0.5, 0, 0], [0.5, 0, 0]]),\n            \"obs_positions\": np.array([(0, 0, 1), (0.5, 0, 1), (-0.5, 0, 1), (0, 0.5, 1)]),\n            \"true_masses\": np.array([10.0, 10.0]),\n            \"noise_std\": 2.0e-12,\n        },\n        {\n            \"name\": \"Case 3 (ill-conditioned, noise-free)\",\n            \"mass_positions\": np.array([[-0.001, 0, 0], [0.001, 0, 0]]),\n            \"obs_positions\": np.array([(0, 0, 1), (0, 0, 1.5), (0, 0, 2)]),\n            \"true_masses\": np.array([10.0, 10.0]),\n            \"noise_std\": 0.0,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        mass_pos = case[\"mass_positions\"]\n        obs_pos = case[\"obs_positions\"]\n        m_true = case[\"true_masses\"]\n        noise_std = case[\"noise_std\"]\n\n        num_obs = obs_pos.shape[0]\n        num_masses = mass_pos.shape[0]\n\n        # 1. Construct the geometry matrix A\n        A = np.zeros((num_obs, num_masses))\n        for l in range(num_obs):\n            for k in range(num_masses):\n                r_vec = obs_pos[l, :] - mass_pos[k, :]\n                R_sq = np.dot(r_vec, r_vec)\n                R = np.sqrt(R_sq)\n                z = r_vec[2]\n                A[l, k] = (3 * z**2 - R_sq) / (R**5)\n\n        # 2. Forward model the \"measured\" data vector d\n        d_true = G_true * (A @ m_true)\n        if noise_std > 0:\n            rng = np.random.default_rng(42)  # Seed for reproducibility\n            noise = rng.normal(0, noise_std, size=d_true.shape)\n            d = d_true + noise\n        else:\n            d = d_true\n\n        # 3. Perform linear least-squares inversion for m_hat\n        forward_operator = G_assumed * A\n        m_hat, _, _, _ = np.linalg.lstsq(forward_operator, d, rcond=None)\n\n        # 4. Compute the mass-total relative error e_m\n        sum_m_hat = np.sum(m_hat)\n        sum_m_true = np.sum(m_true)\n        e_m = (sum_m_hat - sum_m_true) / sum_m_true\n        results.append(e_m)\n\n        # 5. Perform calibration to find G_hat\n        # Use true masses as reference masses for calibration\n        p = G_assumed * (A @ m_true)\n        \n        # Calculate the scale factor s\n        s = np.dot(p, d) / np.dot(p, p)\n        \n        G_hat = s * G_assumed\n        \n        # 6. Compute the G relative error e_G\n        e_G = (G_hat - G_true) / G_true\n        results.append(e_G)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}