{
    "hands_on_practices": [
        {
            "introduction": "将物理定律转化为可执行的计算模型是计算地球物理学的核心。本练习将指导您从零开始，通过将密度异常体离散化为体元，并对产生的引力位应用有限差分法，来构建一个重力梯度张量的正演模型。这项实践旨在通过一个具体的编码任务，巩固您对数值微分和离散化策略的理解，这是后续更复杂建模和反演工作的基础。",
            "id": "3602058",
            "problem": "你需要基于第一性原理，为三个测试用例实现一个重力梯度张量的数值模型。使用牛顿引力来模拟在均匀笛卡尔网格上离散化的体密度异常的引力势。重力梯度张量将通过使用有限差分对引力势进行数值微分来获得。你的程序必须以指定的物理单位和格式为每个测试用例输出定量结果。\n\n基本原理。从由密度分布产生的牛顿引力势开始。对于三维空间中的质量密度场 $\\rho(\\mathbf{r}')$，在位置 $\\mathbf{r}$ 处的引力势 $\\Phi(\\mathbf{r})$ 为\n$$\n\\Phi(\\mathbf{r}) = G \\int_{\\mathbb{R}^3} \\frac{\\rho(\\mathbf{r}')}{\\|\\mathbf{r} - \\mathbf{r}'\\|} \\, dV',\n$$\n其中 $G$ 是引力常数。重力梯度张量 $\\mathbf{T}$ 定义为引力势的Hessian矩阵，\n$$\nT_{ij}(\\mathbf{r}) = \\frac{\\partial^2 \\Phi(\\mathbf{r})}{\\partial x_i \\, \\partial x_j},\n$$\n对于笛卡尔坐标 $\\{x_1,x_2,x_3\\} \\equiv \\{x,y,z\\}$。\n\n离散化策略。在一个每轴有 $N$ 个节点的奇数尺寸网格上，使用边长为 $h$ 的均匀体素对密度场进行离散化。将质量分布表示为位于体素中心的点质量集合。对于密度为 $\\rho$、体素体积为 $h^3$ 的均匀密度异常，每个被占据的体素质量为 $m = \\rho h^3$。通过黎曼和来近似点 $\\mathbf{r}$ 处的引力势\n$$\n\\Phi(\\mathbf{r}) \\approx G \\sum_{n=1}^{M} \\frac{m}{\\|\\mathbf{r} - \\mathbf{r}_n\\|},\n$$\n其中 $\\{\\mathbf{r}_n\\}_{n=1}^M$ 是被占据体素的中心。\n\n数值微分。使用网格间距为 $h$ 的二阶精度有限差分来近似网格节点上 $\\Phi$ 的二阶导数：\n\n- 对于内部节点上沿 $x$ 轴的纯二阶导数，\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x^2} \\bigg|_{i,j,k} \\approx \\frac{\\Phi_{i+1,j,k} - 2\\Phi_{i,j,k} + \\Phi_{i-1,j,k}}{h^2}.\n$$\n\n- 对于内部节点上的混合导数，例如 $\\partial^2 \\Phi / \\partial x \\partial y$，\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x \\partial y} \\bigg|_{i,j,k} \\approx \\frac{\\Phi_{i+1,j+1,k} - \\Phi_{i+1,j-1,k} - \\Phi_{i-1,j+1,k} + \\Phi_{i-1,j-1,k}}{4h^2}.\n$$\n\n- 在无法使用中心差分格式的边界节点上，对纯二阶导数使用二阶精度的单边差分格式。例如，在沿 $z$ 轴的顶部边界使用后向差分，\n$$\n\\frac{\\partial^2 \\Phi}{\\partial z^2} \\bigg|_{i,j,K} \\approx \\frac{2\\Phi_{i,j,K} - 5\\Phi_{i,j,K-1} + 4\\Phi_{i,j,K-2} - \\Phi_{i,j,K-3}}{h^2}.\n$$\n\n坐标系与网格。使用一个立方网格，其中 $N$ 为奇数，以使原点位于中心节点。设索引 $i,j,k \\in \\{0,1,\\dots,N-1\\}$。节点 $(i,j,k)$ 的物理坐标为\n$$\nx_i = \\left(i - \\frac{N-1}{2}\\right) h, \\quad y_j = \\left(j - \\frac{N-1}{2}\\right) h, \\quad z_k = \\left(k - \\frac{N-1}{2}\\right) h.\n$$\n\n物理常数与单位。使用引力常数 $G = 6.67430 \\times 10^{-11}$，单位为 $\\mathrm{m}^3 \\, \\mathrm{kg}^{-1} \\, \\mathrm{s}^{-2}$。密度 $\\rho$ 的单位为 $\\mathrm{kg} \\, \\mathrm{m}^{-3}$，长度单位为 $\\mathrm{m}$。以厄缶（Eötvös）为单位表示重力梯度张量的分量，其中 $1$ 厄缶 $= 10^{-9} \\, \\mathrm{s}^{-2}$。你的程序必须以厄缶为单位输出每个请求的张量分量，并四舍五入到六位小数。\n\n测试套件与要求输出。所有用例均使用 $N = 33$ 和 $h = 100$ $\\mathrm{m}$。所有异常体均使用均匀密度 $\\rho = 2670$ $\\mathrm{kg} \\, \\mathrm{m}^{-3}$。通过选择所有坐标位于指定坐标轴对齐边界（含边界）内的体素中心来定义异常体素。\n\n- 测试用例 1 (内部中心差分与迹约束)：一个边长为 $600$ $\\mathrm{m}$ 的单一均匀立方体异常，以原点为中心，即被占据的体素中心满足 $x \\in [-300,300]$ $\\mathrm{m}$，$y \\in [-300,300]$ $\\mathrm{m}$，$z \\in [-300,300]$ $\\mathrm{m}$。在坐标为 $(x,y,z) = (0,0,500)$ $\\mathrm{m}$ 的节点处进行评估。计算纯二阶导数以构成该点的迹 $S = T_{xx} + T_{yy} + T_{zz}$。以厄缶为单位输出 $S$，四舍五入到六位小数。\n\n- 测试用例 2 (混合导数对称性)：两个大小相同的均匀立方体异常，每个边长为 $400$ $\\mathrm{m}$，分别以 $(x,y,z) = (-600,0,0)$ $\\mathrm{m}$ 和 $(x,y,z) = (600,0,0)$ $\\mathrm{m}$ 为中心。即，左侧立方体被占据的体素中心满足 $x \\in [-800,-400]$ $\\mathrm{m}$，$y \\in [-200,200]$ $\\mathrm{m}$，$z \\in [-200,200]$ $\\mathrm{m}$；右侧立方体满足 $x \\in [400,800]$ $\\mathrm{m}$，其 $y$ 和 $z$ 边界相同。在原点 $(0,0,0)$ $\\mathrm{m}$ 处进行评估。使用中心差分计算该点的混合导数 $T_{xy}$。以厄缶为单位输出 $T_{xy}$，四舍五入到六位小数。\n\n- 测试用例 3 (边界单边差分格式)：一个边长为 $400$ $\\mathrm{m}$ 的单一均匀立方体异常，以 $(x,y,z) = (0,0,-700)$ $\\mathrm{m}$ 为中心，即被占据的体素中心满足 $x \\in [-200,200]$ $\\mathrm{m}$，$y \\in [-200,200]$ $\\mathrm{m}$，$z \\in [-900,-500]$ $\\mathrm{m}$。在顶部边界节点 $(x,y,z) = (0,0,1600)$ $\\mathrm{m}$ 处进行评估。使用二阶精度的单边后向差分格式计算 $T_{zz}$。以厄缶为单位输出 $T_{zz}$，四舍五入到六位小数。\n\n最终输出格式。你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，顺序为 $[S_{\\text{case 1}}, T_{xy,\\text{case 2}}, T_{zz,\\text{case 3}}]$，例如，\"[1.234567,0.000001,-0.123456]\"。所有三个数字都必须以厄缶为单位，四舍五入到六位小数，列表中无空格。",
            "solution": "问题陈述已经过严格验证，并被确定为有效。它以牛顿物理学为科学基础，在数学上是适定的、客观且自洽的。所提供的参数和测试用例是一致的，能够导出一个唯一且有意义的解。因此，我们可以着手开发计算模型。\n\n任务是实现一个数值模型，用于计算三种不同质量异常配置下的重力梯度张量 $\\mathbf{T}$ 的分量。该模型基于牛顿引力的第一性原理，并采用离散化和数值微分方法。\n\n**1.基本原理：引力势**\n\n由连续质量密度分布 $\\rho(\\mathbf{r}')$ 在位置 $\\mathbf{r}$ 处产生的引力势 $\\Phi$ 由以下体积分给出：\n$$\n\\Phi(\\mathbf{r}) = G \\int_{\\mathbb{R}^3} \\frac{\\rho(\\mathbf{r}')}{\\|\\mathbf{r} - \\mathbf{r}'\\|} \\, dV'\n$$\n其中 $G = 6.67430 \\times 10^{-11} \\, \\mathrm{m}^3 \\, \\mathrm{kg}^{-1} \\, \\mathrm{s}^{-2}$ 是引力常数。\n\n**2.离散化策略**\n\n为便于数值计算，我们将连续密度异常建模为离散点质量的集合。源体积被离散化为一个由体素组成的均匀网格，每个体素的边长为 $h = 100 \\, \\mathrm{m}$。对于均匀密度异常 $\\rho = 2670 \\, \\mathrm{kg} \\, \\mathrm{m}^{-3}$，每个体素由一个位于其几何中心的点质量 $m = \\rho h^3$ 表示。因此，引力势的积分可用黎曼和近似：\n$$\n\\Phi(\\mathbf{r}) \\approx G \\sum_{n=1}^{M} \\frac{m}{\\|\\mathbf{r} - \\mathbf{r}_n\\|}\n$$\n此处，$\\{\\mathbf{r}_n\\}_{n=1}^M$ 是构成密度异常的 $M$ 个体素中心的坐标向量。引力势的求值点 $\\mathbf{r}$ 与所有质量点位置 $\\mathbf{r}_n$ 均不相同，从而避免了奇点。\n\n**3.通过数值微分计算重力梯度张量**\n\n重力梯度张量 $\\mathbf{T}$ 是引力势的Hessian矩阵，其分量为 $T_{ij}(\\mathbf{r}) = \\frac{\\partial^2 \\Phi(\\mathbf{r})}{\\partial x_i \\, \\partial x_j}$。我们使用计算网格上的有限差分公式来近似这些二阶导数。问题指定了二阶精度的差分格式。\n\n**4.测试用例的实现**\n\n建立一个每轴有 $N=33$ 个节点、间距为 $h=100 \\, \\mathrm{m}$ 的计算网格。坐标以原点为中心，任意轴上索引为 $k \\in \\{0, \\dots, N-1\\}$ 的节点的物理坐标为 $(k - \\frac{N-1}{2})h = (k - 16)h$。\n\n对于每个测试用例，执行以下步骤：\n1.  识别满足给定异常体几何边界条件的体素中心坐标集合 $\\{\\mathbf{r}_n\\}$。\n2.  在指定的求值点 $\\mathbf{r}_{\\text{eval}}$ 周围定义所需的差分格式点。\n3.  使用离散化公式计算这些差分格式点上各自的引力势 $\\Phi$。\n4.  应用适当的有限差分公式来计算所需的张量分量。\n5.  将结果从国际单位制（$\\mathrm{s}^{-2}$）通过乘以 $10^9$ 转换为厄缶（$1 \\text{ Eötvös} = 10^{-9} \\, \\mathrm{s}^{-2}$）。\n\n**测试用例1：内部点的迹**\n-   **异常体：** 一个由体素中心定义的立方体，其坐标满足 $x, y, z \\in [-300, 300] \\, \\mathrm{m}$。\n-   **求值点：** $\\mathbf{r}_{\\text{eval}} = (0, 0, 500) \\, \\mathrm{m}$。这是计算网格的一个内部节点。\n-   **任务：** 计算迹 $S = T_{xx} + T_{yy} + T_{zz}$。\n-   **方法：** 使用二阶中心差分格式计算纯二阶导数：\n    $$\n    T_{xx}(\\mathbf{r}) \\approx \\frac{\\Phi(x+h, y, z) - 2\\Phi(x, y, z) + \\Phi(x-h, y, z)}{h^2}\n    $$\n    $T_{yy}$ 和 $T_{zz}$ 使用类似的公式。三个差分格式共需要九次引力势计算（部分点是共享的）。求值点位于质量分布之外，在该区域引力势满足Laplace方程，即 $\\nabla^2 \\Phi = T_{xx} + T_{yy} + T_{zz} = 0$。因此，计算出的数值迹 $S$ 预计会是一个很小的值，代表了数值近似的误差。\n\n**测试用例2：原点处的混合导数**\n-   **异常体：** 两个立方体，一个满足 $x \\in [-800, -400] \\, \\mathrm{m}$，另一个满足 $x \\in [400, 800] \\, \\mathrm{m}$，两者都满足 $y, z \\in [-200, 200] \\, \\mathrm{m}$。\n-   **求值点：** $\\mathbf{r}_{\\text{eval}} = (0, 0, 0) \\, \\mathrm{m}$。\n-   **任务：** 计算混合导数 $T_{xy}$。\n-   **方法：** 使用二阶中心差分格式计算混合导数：\n    $$\n    T_{xy}(\\mathbf{r}) \\approx \\frac{\\Phi(x+h, y+h, z) - \\Phi(x+h, y-h, z) - \\Phi(x-h, y+h, z) + \\Phi(x-h, y-h, z)}{4h^2}\n    $$\n    质量分布关于 $x-z$ 平面（即 $y=0$）对称。这种对称性意味着 $\\Phi(x, y, z) = \\Phi(x, -y, z)$，因此在 $x-z$ 平面上任意一点的 $\\frac{\\partial \\Phi}{\\partial y}$ 都必须为零。所以，$T_{xy} = \\frac{\\partial}{\\partial x}(\\frac{\\partial \\Phi}{\\partial y})$ 在原点也必须为零。受浮点精度限制，数值结果预计会接近于零。\n\n**测试用例3：边界处的纯导数**\n-   **异常体：** 一个由 $x, y \\in [-200, 200] \\, \\mathrm{m}$ 和 $z \\in [-900, -500] \\, \\mathrm{m}$ 定义的立方体。\n-   **求值点：** $\\mathbf{r}_{\\text{eval}} = (0, 0, 1600) \\, \\mathrm{m}$。该坐标对应索引为 $k=32$ 的节点，即网格的顶部边界（$k_{\\text{max}} = N-1 = 32$）。\n-   **任务：** 计算 $T_{zz}$。\n-   **方法：** 由于网格内没有可用的前向差分点，必须使用指定的二阶精度单边后向差分公式：\n    $$\n    T_{zz}(\\mathbf{r}) \\approx \\frac{2\\Phi(x, y, z) - 5\\Phi(x, y, z-h) + 4\\Phi(x, y, z-2h) - \\Phi(x, y, z-3h)}{h^2}\n    $$\n    这需要计算求值点本身以及其下方沿 $z$ 轴的三个点的引力势。\n\n最终的实现将这些步骤封装到一个程序中，该程序计算并按指定格式输出三个所要求的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes gravity gradient tensor components for three test cases.\n    \"\"\"\n    # Physical constants and parameters\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    RHO = 2670.0      # kg m^-3\n    N = 33            # Grid nodes per axis\n    H = 100.0         # m, grid spacing / voxel edge length\n    MASS = RHO * H**3 # kg, mass of a single voxel\n    EOTVOS_CONVERSION = 1e9\n\n    def get_mass_locations(case_params):\n        \"\"\"\n        Generates the coordinates of voxel centers for a given anomaly definition.\n        \n        Args:\n            case_params (list of tuples): Each tuple contains (min_coord, max_coord)\n                                          for x, y, z axes respectively.\n        \n        Returns:\n            np.ndarray: An (M, 3) array of mass point coordinates.\n        \"\"\"\n        all_mass_locs = []\n        for x_bounds, y_bounds, z_bounds in case_params:\n            x_coords = np.arange(x_bounds[0], x_bounds[1] + 1, H)\n            y_coords = np.arange(y_bounds[0], y_bounds[1] + 1, H)\n            z_coords = np.arange(z_bounds[0], z_bounds[1] + 1, H)\n            \n            xx, yy, zz = np.meshgrid(x_coords, y_coords, z_coords, indexing='ij')\n            mass_locs = np.vstack([xx.ravel(), yy.ravel(), zz.ravel()]).T\n            all_mass_locs.append(mass_locs)\n        \n        if not all_mass_locs:\n            return np.empty((0, 3))\n        \n        return np.vstack(all_mass_locs)\n\n    def compute_potential(eval_point, mass_locations):\n        \"\"\"\n        Calculates the gravitational potential at a single evaluation point.\n        \n        Args:\n            eval_point (tuple or np.ndarray): The (x, y, z) coordinate for evaluation.\n            mass_locations (np.ndarray): An (M, 3) array of mass point coordinates.\n\n        Returns:\n            float: The gravitational potential in SI units (m^2 s^-2).\n        \"\"\"\n        if mass_locations.shape[0] == 0:\n            return 0.0\n\n        eval_point = np.array(eval_point)\n        diffs = eval_point - mass_locations\n        distances = np.linalg.norm(diffs, axis=1)\n        \n        # The problem is set up to avoid singularities (distances > 0)\n        potential_contribs = MASS / distances\n        total_potential = G * np.sum(potential_contribs)\n        return total_potential\n\n    results = []\n\n    # --- Test Case 1: Trace S at (0, 0, 500) m ---\n    case1_params = [((-300.0, 300.0), (-300.0, 300.0), (-300.0, 300.0))]\n    mass_locs_1 = get_mass_locations(case1_params)\n    r_eval_1 = (0.0, 0.0, 500.0)\n    \n    phi_center = compute_potential(r_eval_1, mass_locs_1)\n    \n    # T_xx\n    phi_xp1 = compute_potential((r_eval_1[0] + H, r_eval_1[1], r_eval_1[2]), mass_locs_1)\n    phi_xm1 = compute_potential((r_eval_1[0] - H, r_eval_1[1], r_eval_1[2]), mass_locs_1)\n    T_xx = (phi_xp1 - 2 * phi_center + phi_xm1) / (H**2)\n    \n    # T_yy\n    phi_yp1 = compute_potential((r_eval_1[0], r_eval_1[1] + H, r_eval_1[2]), mass_locs_1)\n    phi_ym1 = compute_potential((r_eval_1[0], r_eval_1[1] - H, r_eval_1[2]), mass_locs_1)\n    T_yy = (phi_yp1 - 2 * phi_center + phi_ym1) / (H**2)\n    \n    # T_zz\n    phi_zp1 = compute_potential((r_eval_1[0], r_eval_1[1], r_eval_1[2] + H), mass_locs_1)\n    phi_zm1 = compute_potential((r_eval_1[0], r_eval_1[1], r_eval_1[2] - H), mass_locs_1)\n    T_zz = (phi_zp1 - 2 * phi_center + phi_zm1) / (H**2)\n    \n    S_case1 = T_xx + T_yy + T_zz\n    results.append(S_case1 * EOTVOS_CONVERSION)\n\n    # --- Test Case 2: T_xy at (0, 0, 0) m ---\n    case2_params = [\n        ((-800.0, -400.0), (-200.0, 200.0), (-200.0, 200.0)),\n        ((400.0, 800.0), (-200.0, 200.0), (-200.0, 200.0))\n    ]\n    mass_locs_2 = get_mass_locations(case2_params)\n    r_eval_2 = (0.0, 0.0, 0.0)\n    \n    phi_xp1_yp1 = compute_potential((r_eval_2[0] + H, r_eval_2[1] + H, r_eval_2[2]), mass_locs_2)\n    phi_xp1_ym1 = compute_potential((r_eval_2[0] + H, r_eval_2[1] - H, r_eval_2[2]), mass_locs_2)\n    phi_xm1_yp1 = compute_potential((r_eval_2[0] - H, r_eval_2[1] + H, r_eval_2[2]), mass_locs_2)\n    phi_xm1_ym1 = compute_potential((r_eval_2[0] - H, r_eval_2[1] - H, r_eval_2[2]), mass_locs_2)\n    \n    T_xy_case2 = (phi_xp1_yp1 - phi_xp1_ym1 - phi_xm1_yp1 + phi_xm1_ym1) / (4 * H**2)\n    results.append(T_xy_case2 * EOTVOS_CONVERSION)\n\n    # --- Test Case 3: T_zz at (0, 0, 1600) m ---\n    case3_params = [((-200.0, 200.0), (-200.0, 200.0), (-900.0, -500.0))]\n    mass_locs_3 = get_mass_locations(case3_params)\n    r_eval_3 = (0.0, 0.0, 1600.0)\n    \n    phi_k = compute_potential(r_eval_3, mass_locs_3)\n    phi_km1 = compute_potential((r_eval_3[0], r_eval_3[1], r_eval_3[2] - H), mass_locs_3)\n    phi_km2 = compute_potential((r_eval_3[0], r_eval_3[1], r_eval_3[2] - 2 * H), mass_locs_3)\n    phi_km3 = compute_potential((r_eval_3[0], r_eval_3[1], r_eval_3[2] - 3 * H), mass_locs_3)\n    \n    T_zz_case3 = (2 * phi_k - 5 * phi_km1 + 4 * phi_km2 - phi_km3) / (H**2)\n    results.append(T_zz_case3 * EOTVOS_CONVERSION)\n\n    # Final print statement in the exact required format.\n    # The format string \"{:.6f}\" handles rounding to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何构建正演模型后，下一步自然是利用它进行反演——即从观测数据中估计模型参数。本练习探讨如何为点源质量建立并求解一个线性反演问题，更重要的是，它将揭示不确定性（如此处引力常数 $G$ 的不确定性）如何影响反演结果，以及如何设计校准方案来修正这些系统性偏差。这项实践将理论与地球物理勘探中的实际挑战联系起来。",
            "id": "3602043",
            "problem": "您的任务是为点质量配置建立重力梯度张量模型并进行反演，并量化引力常数的不确定性如何通过反演过程传播。您必须从基础物理出发，并进行数值实现，以产生指定的输出。基础物理是牛顿引力势和重力梯度张量的定义。所有推导和推理都必须在此基础上进行，不得使用任何简化公式。物理单位必须明确说明并保持一致：质量以千克为单位，位置以米为单位，重力梯度分量以平方秒分之一为单位。本问题不涉及角度。您的程序必须为提供的测试套件生成结果，并将所有结果以浮点数形式打印在一个由方括号括起来的、逗号分隔的列表中。\n\n推导的起点：\n- 点质量的牛顿引力势为 $U(\\mathbf{x}) = \\dfrac{G m}{\\|\\mathbf{x}\\|}$，其中 $G$ 是引力常数，$m$ 是质量，$\\mathbf{x}$ 是相对于质量测量的位置矢量。\n- 重力梯度张量 (GGT) $T_{ij}(\\mathbf{x})$ 定义为 $T_{ij}(\\mathbf{x}) = \\dfrac{\\partial^2 U(\\mathbf{x})}{\\partial x_i \\partial x_j}$，其中 $i$ 和 $j$ 表示笛卡尔分量。\n- 此处考虑的可观测量是在给定观测点上的 $T_{zz}$ 分量。\n\n任务：\n- 仅从 $U(\\mathbf{x}) = \\dfrac{G m}{\\|\\mathbf{x}\\|}$ 和定义 $T_{ij}(\\mathbf{x}) = \\dfrac{\\partial^2 U(\\mathbf{x})}{\\partial x_i \\partial x_j}$ 推导出单个点质量的重力梯度张量 $T_{ij}(\\mathbf{x})$，并用 $G$、$m$ 和几何形状表示结果。\n- 证明对于一组观测点上的 $N$ 个点质量，$T_{zz}$ 分量可以写成线性模型 $\\mathbf{d} = G \\mathbf{A} \\mathbf{m}$，其中 $\\mathbf{d}$ 是 $T_{zz}$ 观测值的矢量，$\\mathbf{m}$ 是质量矢量，$\\mathbf{A}$ 是一个依赖于几何形状的矩阵，其元素取决于质量与观测点之间的相对位置。\n- 在无噪声条件且 $\\mathbf{A}$ 为满列秩的情况下，推导 $G$ 中的乘性不确定性如何通过对 $\\mathbf{m}$ 的线性最小二乘反演传播，明确估计质量与真实质量之间的比例关系。\n- 提出一个校准协议，该协议使用已知位置的已知参考质量，通过最小化预测和测量的 $T_{zz}$ 数据在最小二乘意义上的差异，来估计 $G$（和仪器尺度）的有效比例因子。为线性模型下的最佳拟合比例因子提供一个闭式表达式。\n\n实现要求：\n- 直接根据推导出的点质量重力梯度张量，为每个观测点处由每个点质量引起的 $T_{zz}$ 分量实现一个正演模型。除了双精度算术外，不使用任何近似。\n- 实现线性最小二乘反演，以从数据中估计质量，在正演算子中使用假定的 $G$。反演必须使用指定语言环境中可用的确定性算法。对于欠定或病态情况，请使用最小范数最小二乘解。\n- 通过求解使预测数据映射到测量数据的最佳拟合标量比例因子，为已知参考质量配置实现所提出的 $G$ 校准协议，然后形成校准后的引力常数。\n\n单位：\n- 质量必须以千克 ($\\mathrm{kg}$) 为单位。\n- 位置必须以米 ($\\mathrm{m}$) 为单位。\n- 重力梯度 $T_{zz}$ 必须以平方秒分之一 ($\\mathrm{s}^{-2}$) 为单位。\n- 输出是无量纲的浮点数。\n\n测试套件：\n- 在所有情况下，$G_{\\text{assumed}} = 6.67430 \\times 10^{-11}$，且 $G_{\\text{true}} = G_{\\text{assumed}} \\times (1 + \\delta)$，其中 $\\delta = 5 \\times 10^{-5}$。\n- 使用以下三个测试用例，每个用例由质量位置、观测位置、真实质量和噪声水平定义。在所有情况下，质量使用千克，位置使用米，并以 $\\mathrm{s}^{-2}$ 计算 $T_{zz}$。\n\n用例 $1$（良态，无噪声）：\n- 质量位置：$(-0.5, 0, 0)$ 和 $(+0.5, 0, 0)$。\n- 观测位置：$(0, 0, 1)$、$(0.5, 0, 1)$、$(-0.5, 0, 1)$、$(0, 0.5, 1)$。\n- 真实质量：$(10, 10)$。\n- 噪声标准差：$0$。\n\n用例 $2$（良态，有噪声）：\n- 质量位置：$(-0.5, 0, 0)$ 和 $(+0.5, 0, 0)$。\n- 观测位置：$(0, 0, 1)$、$(0.5, 0, 1)$、$(-0.5, 0, 1)$、$(0, 0.5, 1)$。\n- 真实质量：$(10, 10)$。\n- 噪声标准差：$2.0 \\times 10^{-12}$。为高斯噪声生成器使用确定性种子 $42$。\n\n用例 $3$（病态几何，无噪声）：\n- 质量位置：$(-0.001, 0, 0)$ 和 $(+0.001, 0, 0)$。\n- 观测位置：$(0, 0, 1)$、$(0, 0, 1.5)$、$(0, 0, 2)$。\n- 真实质量：$(10, 10)$。\n- 噪声标准差：$0$。\n\n对每个用例，执行：\n- 使用 $G_{\\text{true}}$ 和真实质量对 $\\mathbf{d}$ 进行正演建模。\n- 使用 $G_{\\text{assumed}}$ 对 $\\hat{\\mathbf{m}}$ 进行线性最小二乘反演，必要时返回最小范数估计。\n- 计算总质量相对误差 $e_m = \\dfrac{\\sum_j \\hat{m}_j - \\sum_j m_j}{\\sum_j m_j}$。\n- 计算校准比例因子 $s$，该因子最小化 $\\| s \\mathbf{p} - \\mathbf{d} \\|_2$，其中 $\\mathbf{p} = G_{\\text{assumed}} \\mathbf{A} \\mathbf{m}$ 是由已知参考质量和位置以及 $G_{\\text{assumed}}$ 构建的。形成 $\\hat{G} = s \\, G_{\\text{assumed}}$，并计算引力常数相对误差 $e_G = \\dfrac{\\hat{G} - G_{\\text{true}}}{G_{\\text{true}}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表形式的结果，并用方括号括起来，顺序为 $[e_{m,1}, e_{G,1}, e_{m,2}, e_{G,2}, e_{m,3}, e_{G,3}]$，其中下标表示测试用例编号。例如，像这样打印结果 $[r_1,r_2,r_3,r_4,r_5,r_6]$。",
            "solution": "该问题是有效的，因为它在科学上基于牛顿物理学，目标明确且适定，并为获得唯一解提供了所有必要信息。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n- **基础物理学：**\n    - 点质量的牛顿引力势：$U(\\mathbf{x}) = \\dfrac{G m}{\\|\\mathbf{x}\\|}$。\n    - 重力梯度张量 (GGT) 定义：$T_{ij}(\\mathbf{x}) = \\dfrac{\\partial^2 U(\\mathbf{x})}{\\partial x_i \\partial x_j}$。\n    - 可观测量是GGT的 $T_{zz}$ 分量。\n- **物理常数：**\n    - 假定引力常数：$G_{\\text{assumed}} = 6.67430 \\times 10^{-11} \\, \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$。\n    - 真实引力常数：$G_{\\text{true}} = G_{\\text{assumed}} \\times (1 + \\delta)$，其中 $\\delta = 5 \\times 10^{-5}$。\n- **单位：**\n    - 质量：千克 ($\\mathrm{kg}$)。\n    - 位置：米 ($\\mathrm{m}$)。\n    - 重力梯度：平方秒分之一 ($\\mathrm{s}^{-2}$)。\n- **任务：**\n    1. 推导单个点质量的GGT $T_{ij}(\\mathbf{x})$。\n    2. 证明 $T_{zz}$ 观测的线性模型形式为 $\\mathbf{d} = G \\mathbf{A} \\mathbf{m}$。\n    3. 推导 $G$ 中的乘性不确定性如何通过最小二乘反演传播。\n    4. 提出一个校准协议并推导比例因子的闭式表达式。\n- **测试用例：**\n    - **用例1（良态，无噪声）：**\n        - 质量位置：$[(-0.5, 0, 0), (0.5, 0, 0)] \\, \\mathrm{m}$。\n        - 观测位置：$[(0, 0, 1), (0.5, 0, 1), (-0.5, 0, 1), (0, 0.5, 1)] \\, \\mathrm{m}$。\n        - 真实质量：$[10, 10] \\, \\mathrm{kg}$。\n        - 噪声标准差：$0 \\, \\mathrm{s}^{-2}$。\n    - **用例2（良态，有噪声）：**\n        - 几何形状和质量与用例1相同。\n        - 噪声标准差：$2.0 \\times 10^{-12} \\, \\mathrm{s}^{-2}$。\n        - 噪声生成器种子：$42$。\n    - **用例3（病态，无噪声）：**\n        - 质量位置：$[(-0.001, 0, 0), (0.001, 0, 0)] \\, \\mathrm{m}$。\n        - 观测位置：$[(0, 0, 1), (0, 0, 1.5), (0, 0, 2)] \\, \\mathrm{m}$。\n        - 真实质量：$[10, 10] \\, \\mathrm{kg}$。\n        - 噪声标准差：$0 \\, \\mathrm{s}^{-2}$。\n- **要求的输出：**\n    - 对于每个用例，计算总质量相对误差 $e_m = \\dfrac{\\sum_j \\hat{m}_j - \\sum_j m_j}{\\sum_j m_j}$。\n    - 对于每个用例，计算引力常数相对误差 $e_G = \\dfrac{\\hat{G} - G_{\\text{true}}}{G_{\\text{true}}}$。\n    - 最终输出必须是单行：$[e_{m,1}, e_{G,1}, e_{m,2}, e_{G,2}, e_{m,3}, e_{G,3}]$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学基础：** 该问题基于牛顿力学和势论，这些是物理学的基本原理。重力梯度及其反演的概念是地球物理学和大地测量学中的标准实践。所有方面在科学上都是合理的。\n- **适定性：** 该问题提供了明确的目标、所有必要的数据和明确定义的测试用例。任务的结构旨在引导出一个唯一的、有意义的数值解。\n- **客观性：** 问题陈述使用精确、定量和无偏见的语言，没有主观性断言。\n\n**步骤3：结论与行动**\n问题是有效的。将提供完整的解决方案。\n\n**推导与算法设计**\n\n**1. 单个点质量的重力梯度张量推导**\n\n相对于位于原点的点质量 $m$，在位置 $\\mathbf{x} = (x_1, x_2, x_3)$ 处的引力势 $U$ 由下式给出：\n$$ U(\\mathbf{x}) = \\frac{G m}{\\|\\mathbf{x}\\|} = Gm(x_1^2 + x_2^2 + x_3^2)^{-1/2} $$\n设 $R = \\|\\mathbf{x}\\| = (x_1^2 + x_2^2 + x_3^2)^{1/2}$。引力矢量 $\\mathbf{g} = \\nabla U$ 的分量是势的一阶偏导数：\n$$ \\frac{\\partial U}{\\partial x_j} = Gm \\frac{\\partial}{\\partial x_j} (R^{-1}) = Gm (-1)R^{-2} \\frac{\\partial R}{\\partial x_j} $$\n因为 $\\frac{\\partial R}{\\partial x_j} = \\frac{x_j}{R}$，我们有：\n$$ \\frac{\\partial U}{\\partial x_j} = -Gm \\frac{x_j}{R^3} $$\n重力梯度张量 $T_{ij}$ 是二阶偏导数矩阵，$T_{ij} = \\frac{\\partial^2 U}{\\partial x_i \\partial x_j}$。应用商法则或乘积法则：\n$$ T_{ij}(\\mathbf{x}) = \\frac{\\partial}{\\partial x_i} \\left( -Gm \\frac{x_j}{R^3} \\right) = -Gm \\left[ \\frac{\\delta_{ij} R^3 - x_j (3R^2 \\frac{\\partial R}{\\partial x_i})}{R^6} \\right] $$\n其中 $\\delta_{ij}$ 是克罗内克δ。代入 $\\frac{\\partial R}{\\partial x_i} = \\frac{x_i}{R}$：\n$$ T_{ij}(\\mathbf{x}) = -Gm \\left[ \\frac{\\delta_{ij} R^3 - 3x_j R x_i}{R^6} \\right] = Gm \\frac{3x_i x_j - \\delta_{ij} R^2}{R^5} $$\n所需的分量是 $T_{zz}$，对应于 $i=j=3$。设 $\\mathbf{x} = (x, y, z)$，因此 $R^2 = x^2+y^2+z^2$：\n$$ T_{zz}(\\mathbf{x}) = Gm \\frac{3z^2 - \\delta_{33} R^2}{R^5} = Gm \\frac{3z^2 - R^2}{R^5} $$\n\n**2. 线性模型的建立**\n\n对于一个由位于位置 $\\mathbf{q}_k$ 的 $N$ 个点质量 $m_k$ 和位于位置 $\\mathbf{p}_l$ 的 $M$ 个观测点组成的系统，在 $\\mathbf{p}_l$ 处的总势是来自每个质量的势之和：\n$$ U(\\mathbf{p}_l) = \\sum_{k=1}^{N} \\frac{G m_k}{\\|\\mathbf{p}_l - \\mathbf{q}_k\\|} $$\n由于微分的线性性质，总的GGT也是一个和：\n$$ T_{zz}(\\mathbf{p}_l) = \\sum_{k=1}^{N} T_{zz,k}(\\mathbf{p}_l - \\mathbf{q}_k) $$\n设 $\\mathbf{r}_{lk} = \\mathbf{p}_l - \\mathbf{q}_k = (x_{lk}, y_{lk}, z_{lk})$ 为相对位置矢量。设 $R_{lk} = \\|\\mathbf{r}_{lk}\\|$。质量 $m_k$ 对 $\\mathbf{p}_l$ 处 $T_{zz}$ 测量的贡献是：\n$$ T_{zz,k} = Gm_k \\frac{3z_{lk}^2 - R_{lk}^2}{R_{lk}^5} $$\n设 $d_l = T_{zz}(\\mathbf{p}_l)$ 是第 $l$ 个观测值。我们可以写出：\n$$ d_l = G \\sum_{k=1}^{N} m_k \\left( \\frac{3z_{lk}^2 - R_{lk}^2}{R_{lk}^5} \\right) $$\n该表达式对于质量 $m_k$ 是线性的。我们可以定义一个几何矩阵 $\\mathbf{A}$，其元素为 $A_{lk} = \\frac{3z_{lk}^2 - R_{lk}^2}{R_{lk}^5}$。所有 $M$ 个观测的方程组可以写成矩阵形式：\n$$ \\mathbf{d} = G \\mathbf{A} \\mathbf{m} $$\n其中 $\\mathbf{d}$ 是 $M \\times 1$ 的观测矢量，$\\mathbf{A}$ 是 $M \\times N$ 的几何矩阵，$\\mathbf{m}$ 是 $N \\times 1$ 的未知质量矢量。\n\n**3. $G$ 中不确定性的传播**\n\n我们得到用 $G_{\\text{true}}$ 合成的“真实”数据：$\\mathbf{d} = G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{true}}$。我们使用一个可能不正确的 $G_{\\text{assumed}}$ 进行最小二乘反演以估计质量 $\\hat{\\mathbf{m}}$。反演模型是 $\\mathbf{d} = (G_{\\text{assumed}} \\mathbf{A}) \\hat{\\mathbf{m}}$。\n线性最小二乘解 $\\hat{\\mathbf{m}}$ 最小化 $\\| \\mathbf{d} - G_{\\text{assumed}} \\mathbf{A} \\hat{\\mathbf{m}} \\|_2^2$。解由下式给出：\n$$ \\hat{\\mathbf{m}} = (G_{\\text{assumed}} \\mathbf{A})^{+} \\mathbf{d} $$\n其中 $(\\cdot)^{+}$ 表示 Moore-Penrose伪逆。代入 $\\mathbf{d}$ 的表达式：\n$$ \\hat{\\mathbf{m}} = (G_{\\text{assumed}} \\mathbf{A})^{+} (G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{true}}) $$\n对于标量 $c \\neq 0$，使用属性 $(c\\mathbf{X})^{+} = c^{-1} \\mathbf{X}^{+}$：\n$$ \\hat{\\mathbf{m}} = \\frac{1}{G_{\\text{assumed}}} \\mathbf{A}^{+} (G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{true}}) = \\frac{G_{\\text{true}}}{G_{\\text{assumed}}} (\\mathbf{A}^{+} \\mathbf{A}) \\mathbf{m}_{\\text{true}} $$\n对于一个满列秩矩阵 $\\mathbf{A}$，$\\mathbf{A}^{+}\\mathbf{A} = \\mathbf{I}$，即单位矩阵。在这种情况下，关系是一个简单的缩放：\n$$ \\hat{\\mathbf{m}} = \\frac{G_{\\text{true}}}{G_{\\text{assumed}}} \\mathbf{m}_{\\text{true}} $$\n这表明 $G$ 中的乘性误差直接作为乘性误差传播到估计的质量中。即使在秩亏的情况下，$\\mathbf{A}^{+}\\mathbf{A}$ 是到 $\\mathbf{A}$ 的行空间的投影。如果 $\\mathbf{m}_{\\text{true}}$ 完全位于这个空间内（如此问题设置中的情况），该关系仍然成立。\n\n**4. 校准协议**\n\n目标是找到一个标量校正因子 $s$，使预测数据 $\\mathbf{p}$ 与测量数据 $\\mathbf{d}$ 最佳对齐。预测基于已知的参考质量 $\\mathbf{m}_{\\text{ref}}$ 和假定的常数 $G_{\\text{assumed}}$：$\\mathbf{p} = G_{\\text{assumed}} \\mathbf{A} \\mathbf{m}_{\\text{ref}}$。测量数据为 $\\mathbf{d}$。我们寻求最小化残差的L2范数平方：\n$$ E(s) = \\| s \\mathbf{p} - \\mathbf{d} \\|_2^2 = (s \\mathbf{p} - \\mathbf{d})^T (s \\mathbf{p} - \\mathbf{d}) = s^2 (\\mathbf{p}^T \\mathbf{p}) - 2s (\\mathbf{p}^T \\mathbf{d}) + \\mathbf{d}^T \\mathbf{d} $$\n为了找到最优的 $s$，我们将 $E(s)$ 对 $s$ 的导数设为零：\n$$ \\frac{dE}{ds} = 2s (\\mathbf{p}^T \\mathbf{p}) - 2 (\\mathbf{p}^T \\mathbf{d}) = 0 $$\n解出 $s$ 得到闭式表达式：\n$$ s = \\frac{\\mathbf{p}^T \\mathbf{d}}{\\mathbf{p}^T \\mathbf{p}} = \\frac{\\langle \\mathbf{p}, \\mathbf{d} \\rangle}{\\| \\mathbf{p} \\|_2^2} $$\n校准后的引力常数则为 $\\hat{G} = s \\cdot G_{\\text{assumed}}$。在无噪声情景下，$\\mathbf{d} = G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{ref}}$，我们有 $\\mathbf{d} = (G_{\\text{true}}/G_{\\text{assumed}}) \\mathbf{p}$。将此代入 $s$ 的方程，得到 $s = G_{\\text{true}}/G_{\\text{assumed}}$，因此 $\\hat{G} = G_{\\text{true}}$，表明校准完美地纠正了 $G$ 中的误差。\n\n**实施计划**\n对于每个测试用例，数值解将遵循以下步骤：\n1.  定义几何形状（质量和观测位置）和真实质量 $\\mathbf{m}_{\\text{true}}$。\n2.  构建 $M \\times N$ 的几何矩阵 $\\mathbf{A}$，其中每个元素 $A_{lk}$ 计算为 $\\frac{3z_{lk}^2 - R_{lk}^2}{R_{lk}^5}$。\n3.  使用 $\\mathbf{d} = G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{true}}$ 合成“测量”数据矢量 $\\mathbf{d}$。对于用例2，添加具有指定标准差和种子的\n高斯噪声。\n4.  通过求解 $\\mathbf{d} = (G_{\\text{assumed}} \\mathbf{A}) \\hat{\\mathbf{m}}$ 来进行最小二乘反演，求解 $\\hat{\\mathbf{m}}$。这通过 `numpy.linalg.lstsq` 完成，它通过提供最小范数解来正确处理良态和病态系统。\n5.  计算总质量相对误差 $e_m = (\\sum \\hat{m}_j - \\sum m_j) / (\\sum m_j)$。\n6.  进行校准。计算预测数据矢量 $\\mathbf{p} = G_{\\text{assumed}} \\mathbf{A} \\mathbf{m}_{\\text{true}}$。使用推导的公式 $s = (\\mathbf{p} \\cdot \\mathbf{d}) / (\\mathbf{p} \\cdot \\mathbf{p})$ 计算比例因子 $s$。\n7.  计算校准后的 $\\hat{G} = s \\cdot G_{\\text{assumed}}$ 和相应的相对误差 $e_G = (\\hat{G} - G_{\\text{true}}) / G_{\\text{true}}$。\n8.  收集六个结果误差值（三个用例中的每一个的 $e_m, e_G$），并将它们格式化为所需的字符串输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravity gradient tensor modeling and inversion problem\n    for three test cases.\n    \"\"\"\n    # Define physical constants\n    G_assumed = 6.67430e-11  # m^3 kg^-1 s^-2\n    delta = 5e-5\n    G_true = G_assumed * (1 + delta)\n\n    # Define test suite\n    test_cases = [\n        {\n            \"name\": \"Case 1 (well-conditioned, noise-free)\",\n            \"mass_positions\": np.array([[-0.5, 0, 0], [0.5, 0, 0]]),\n            \"obs_positions\": np.array([(0, 0, 1), (0.5, 0, 1), (-0.5, 0, 1), (0, 0.5, 1)]),\n            \"true_masses\": np.array([10.0, 10.0]),\n            \"noise_std\": 0.0,\n        },\n        {\n            \"name\": \"Case 2 (well-conditioned, with noise)\",\n            \"mass_positions\": np.array([[-0.5, 0, 0], [0.5, 0, 0]]),\n            \"obs_positions\": np.array([(0, 0, 1), (0.5, 0, 1), (-0.5, 0, 1), (0, 0.5, 1)]),\n            \"true_masses\": np.array([10.0, 10.0]),\n            \"noise_std\": 2.0e-12,\n        },\n        {\n            \"name\": \"Case 3 (ill-conditioned, noise-free)\",\n            \"mass_positions\": np.array([[-0.001, 0, 0], [0.001, 0, 0]]),\n            \"obs_positions\": np.array([(0, 0, 1), (0, 0, 1.5), (0, 0, 2)]),\n            \"true_masses\": np.array([10.0, 10.0]),\n            \"noise_std\": 0.0,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        mass_pos = case[\"mass_positions\"]\n        obs_pos = case[\"obs_positions\"]\n        m_true = case[\"true_masses\"]\n        noise_std = case[\"noise_std\"]\n\n        num_obs = obs_pos.shape[0]\n        num_masses = mass_pos.shape[0]\n\n        # 1. Construct the geometry matrix A\n        A = np.zeros((num_obs, num_masses))\n        for l in range(num_obs):\n            for k in range(num_masses):\n                r_vec = obs_pos[l, :] - mass_pos[k, :]\n                R_sq = np.dot(r_vec, r_vec)\n                R = np.sqrt(R_sq)\n                z = r_vec[2]\n                A[l, k] = (3 * z**2 - R_sq) / (R**5)\n\n        # 2. Forward model the \"measured\" data vector d\n        d_true = G_true * (A @ m_true)\n        if noise_std > 0:\n            rng = np.random.default_rng(42)  # Seed for reproducibility\n            noise = rng.normal(0, noise_std, size=d_true.shape)\n            d = d_true + noise\n        else:\n            d = d_true\n\n        # 3. Perform linear least-squares inversion for m_hat\n        forward_operator = G_assumed * A\n        m_hat, _, _, _ = np.linalg.lstsq(forward_operator, d, rcond=None)\n\n        # 4. Compute the mass-total relative error e_m\n        sum_m_hat = np.sum(m_hat)\n        sum_m_true = np.sum(m_true)\n        e_m = (sum_m_hat - sum_m_true) / sum_m_true\n        results.append(e_m)\n\n        # 5. Perform calibration to find G_hat\n        # Use true masses as reference masses for calibration\n        p = G_assumed * (A @ m_true)\n        \n        # Calculate the scale factor s\n        s = np.dot(p, d) / np.dot(p, p)\n        \n        G_hat = s * G_assumed\n        \n        # 6. Compute the G relative error e_G\n        e_G = (G_hat - G_true) / G_true\n        results.append(e_G)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了进行参数估计，重力梯度张量模型还可用于对地质源进行定性表征。本练习引入了张量不变量的概念，它们是重力梯度张量在坐标系旋转下保持不变的内在属性。您将通过实现一个分类方案，来区分不同几何形状的源（如点状、线状和球状体），从而实践一种强大的自动化解释技术。",
            "id": "3602059",
            "problem": "您需要编写一个完整、独立的程序，通过计算重力梯度张量 (GGT) 的不变量组合来对典型异常几何形状进行分类。从牛顿引力势和重力梯度张量的定义出发，推导并实现几种几何形状的张量模型，计算不变量，然后基于这些不变量对几何形状进行分类。\n\n使用的科学和数学基础：\n- 牛顿引力势：$$U(\\mathbf{x}) = G \\int \\frac{\\rho(\\mathbf{x}')}{\\|\\mathbf{x} - \\mathbf{x}'\\|} \\, dV',$$ 其中 $G$ 是引力常数，$\\rho$ 是质量密度，$\\mathbf{x}$ 是观测点。\n- 重力梯度张量 (GGT)：$$T_{ij}(\\mathbf{x}) = \\frac{\\partial^2 U(\\mathbf{x})}{\\partial x_i \\partial x_j}.$$\n- 不变量：$$I_2 = \\tfrac{1}{2}\\left[(\\operatorname{tr} T)^2 - \\operatorname{tr}(T^2)\\right], \\quad I_3 = \\det T.$$\n\n任务：\n1. 使用上述基本定义，针对以下每种典型几何形状，在指定的观测点推导并实现 GGT $T$：\n   - 位于原点、质量为 $m$ 的点质量。\n   - 沿 $y$ 轴分布、线密度为 $\\lambda$ 的无限长直线质量。\n   - 位于 $z=0$、面密度为 $\\sigma$ 的无限大平面薄片。\n   - 密度为 $\\rho$、半径为 $a$ 的均匀实心球体，观测点位于球体内或球体外。\n\n2. 对于测试套件中提供的每种几何形状和参数集，在给定的观测点 $\\mathbf{x}$ 计算张量 $T$，然后计算不变量 $I_2$ 和 $I_3$、迹 $\\operatorname{tr} T$ 以及 Frobenius 范数尺度 $$s = \\sqrt{\\operatorname{tr}(T^2)}.$$\n\n3. 使用以下基于不变量的决策规则对几何形状进行分类。使用量纲一致的绝对和相对阈值：\n   - 定义 $$\\varepsilon = 10^{-30} \\, \\mathrm{s}^{-2}, \\quad t = \\frac{|\\operatorname{tr} T|}{s + \\delta}, \\quad d = \\frac{|I_3|}{(s + \\delta)^3},$$ 其中 $\\,\\delta = 10^{-300}\\,$ 是一个保护值，用于在 $s=0$ 时避免除以零。$s$ 的单位是 $\\mathrm{s}^{-2}$，因此 $\\varepsilon$ 与其单位相同。比率 $t$ 和 $d$ 是无量纲的。\n   - 决策规则：\n     - 如果 $s \\le \\varepsilon$，分类为 $0$（片状或有效零梯度区域）。\n     - 否则，如果 $t \\le 10^{-12}$ 且 $d \\le 10^{-12}$，分类为 $1$（线状，有一个零特征值和零行列式）。\n     - 否则，如果 $t \\le 10^{-12}$ 且 $I_3 > 0$ 且 $I_2  0$，分类为 $2$（点状，在无源区域观测到的紧凑源，具有零迹和正行列式）。\n     - 否则，如果 $t  10^{-12}$ 且 $I_3  0$，分类为 $3$（体内部区域，例如均匀球体内部）。\n     - 否则，分类为 $2$。\n\n物理常数和单位：\n- 使用 $$G = 6.67430 \\times 10^{-11} \\, \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}.$$\n- 所有距离单位为 $\\mathrm{m}$，质量单位为 $\\mathrm{kg}$，密度单位为 $\\mathrm{kg/m^3}$，线密度单位为 $\\mathrm{kg/m}$，面密度单位为 $\\mathrm{kg/m^2}$。重力梯度张量分量 $T_{ij}$ 必须以 $\\mathrm{s}^{-2}$ 为单位进行计算。\n\n测试套件：\n计算并分类以下五个情况：\n- 情况 $1$：位于原点的点质量，$$m = 5 \\times 10^{12} \\, \\mathrm{kg}, \\quad \\mathbf{x} = (100, 0, 0) \\, \\mathrm{m}.$$\n- 情况 $2$：沿 $y$ 轴的无限长线质量，$$\\lambda = 1 \\times 10^{9} \\, \\mathrm{kg/m}, \\quad \\mathbf{x} = (50, 0, 50) \\, \\mathrm{m}.$$\n- 情况 $3$：位于 $z=0$ 的无限大平面薄片，$$\\sigma = 3.0 \\times 10^{3} \\, \\mathrm{kg/m^2}, \\quad \\mathbf{x} = (0, 0, 100) \\, \\mathrm{m}.$$\n- 情况 $4$：均匀球体，$$\\rho = 2.5 \\times 10^{3} \\, \\mathrm{kg/m^3}, \\quad a = 50 \\, \\mathrm{m}, \\quad \\mathbf{x} = (10, 0, 0) \\, \\mathrm{m} \\text{ (内部)}.$$\n- 情况 $5$：与情况 $4$ 相同的球体，在外部观测，$$\\mathbf{x} = (200, 0, 0) \\, \\mathrm{m}.$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个情况的整数分类代码，格式为方括号括起来的逗号分隔列表，例如 $$[c_1,c_2,c_3,c_4,c_5],$$ 其中每个 $c_i$ 是由上述决策规则生成的整数。",
            "solution": "该问题要求开发一种计算方法，以基于重力梯度张量 (GGT) 的不变量对典型质量几何形状进行分类。这涉及为几种理想化的质量分布推导 GGT，对这些模型进行数值实现，然后应用基于张量不变量的特定决策树。\n\n基本原理是牛顿引力势和 GGT 的定义。由密度为 $\\rho$ 的质量分布在观测点 $\\mathbf{x}$ 产生的势 $U$ 由下式给出：\n$$U(\\mathbf{x}) = G \\int \\frac{\\rho(\\mathbf{x}')}{\\|\\mathbf{x} - \\mathbf{x}'\\|} \\, dV'$$\n其中 $G$ 是引力常数，积分遍及源的体积。GGT，用 $T$ 表示，是一个对称张量，其分量 $T_{ij}$ 是势的二阶偏导数：\n$$T_{ij}(\\mathbf{x}) = \\frac{\\partial^2 U(\\mathbf{x})}{\\partial x_i \\partial x_j}$$\nGGT 的迹 $\\operatorname{tr}(T) = \\sum_i T_{ii}$ 通过引力泊松方程 $\\nabla^2 U = 4\\pi G \\rho$ 与局部质量密度相关。因此，$\\operatorname{tr}(T) = 4\\pi G \\rho(\\mathbf{x})$。在 $\\rho(\\mathbf{x})=0$ 的无源区域，GGT 的迹为零。\n\n解决方案分两个阶段进行：首先，为每种指定的几何形状推导 GGT；其次，使用这些张量模型实现分类算法。\n\n**1. 重力梯度张量模型的推导**\n\n设观测点为 $\\mathbf{r} = (x, y, z)$。GGT 分量由每种几何形状的势 $U$ 推导而来。\n\n**A. 位于原点的点质量**\n对于位于原点的点质量 $m$，在位置 $\\mathbf{r}$（其大小为 $r = \\|\\mathbf{r}\\| = \\sqrt{x^2+y^2+z^2}$）的势为 $U(r) = Gm/r$。GGT 分量 $T_{ij}$ 通过求二阶导数得到：\n$$T_{ij} = \\frac{\\partial^2}{\\partial x_i \\partial x_j} \\left(\\frac{Gm}{r}\\right) = Gm \\left( \\frac{3x_i x_j}{r^5} - \\frac{\\delta_{ij}}{r^3} \\right)$$\n其中 $\\delta_{ij}$ 是克罗内克 δ。其矩阵形式为：\n$$ T = \\frac{Gm}{r^5} \\begin{pmatrix} 3x^2 - r^2  3xy  3xz \\\\ 3xy  3y^2 - r^2  3yz \\\\ 3xz  3yz  3z^2 - r^2 \\end{pmatrix} $$\n迹为 $\\operatorname{tr}(T) = \\frac{Gm}{r^5} (3(x^2+y^2+z^2) - 3r^2) = 0$，这与无源区域的预期相符。\n\n**B. 无限长线质量**\n对于沿 $y$ 轴分布、线密度为 $\\lambda$ 的无限长线质量，其引力场在垂直于线的平面上呈二维径向分布。标准的引力势（对应吸引力）为 $U(R) = 2G\\lambda \\ln(R) + C$，其中 $R=\\sqrt{x^2+z^2}$。GGT分量通过对 $U = G\\lambda \\ln(x^2+z^2)$ 进行微分计算得出。\n$$T_{xx} = \\frac{\\partial^2 U}{\\partial x^2} = 2G\\lambda \\frac{z^2-x^2}{(x^2+z^2)^2}$$\n$$T_{zz} = \\frac{\\partial^2 U}{\\partial z^2} = 2G\\lambda \\frac{x^2-z^2}{(x^2+z^2)^2}$$\n$$T_{xz} = \\frac{\\partial^2 U}{\\partial x \\partial z} = -4G\\lambda \\frac{xz}{(x^2+z^2)^2}$$\n所有其他分量，包括 $T_{yy}$ 和涉及对 $y$ 求导的分量，均为零。得到的张量为：\n$$ T = \\frac{2G\\lambda}{(x^2+z^2)^2} \\begin{pmatrix} z^2 - x^2  0  -2xz \\\\ 0  0  0 \\\\ -2xz  0  x^2 - z^2 \\end{pmatrix} $$\n迹和行列式均为零。\n\n**C. 无限大平面薄片**\n对于位于 $z=0$ 平面、面密度为 $\\sigma$ 的无限大质量薄片，引力场是均匀的，并沿 $z$ 轴方向：$\\mathbf{g} = -2\\pi G \\sigma \\operatorname{sgn}(z) \\hat{\\mathbf{z}}$（对于吸引力）。由于对于任何 $z \\neq 0$，场 $\\mathbf{g}=-\\nabla U$ 都是恒定的，其梯度为零。\n$$ T_{ij} = -\\frac{\\partial g_i}{\\partial x_j} = 0 $$\n因此，对于不在薄片本身的任何观测点，GGT 都是零矩阵。\n\n**D. 均匀实心球体**\n对于半径为 $a$、密度恒为 $\\rho$ 的球体，我们有两种情况。\n- **球体外部 ($r > a$)**：根据牛顿球壳定理，该球体可视为位于原点的点质量 $M = \\frac{4}{3}\\pi a^3 \\rho$。因此，GGT 与点质量情况相同，只是用 $M$ 替换了 $m$。\n- **球体内部 ($r  a$)**：势为 $U(r) = -\\frac{2\\pi G \\rho}{3}(r^2-3a^2)$。\n二阶导数很容易计算：\n$$T_{xx} = \\frac{\\partial^2 U}{\\partial x^2} = \\frac{\\partial}{\\partial x}\\left(-\\frac{4\\pi G \\rho}{3}x\\right) = -\\frac{4\\pi G \\rho}{3}$$\n类似地，$T_{yy} = T_{zz} = -\\frac{4\\pi G \\rho}{3}$。非对角分量为零。GGT 是单位矩阵 $I$ 的标量倍数：\n$$ T = -\\frac{4\\pi G \\rho}{3} I $$\n其迹为 $\\operatorname{tr}(T) = -4\\pi G \\rho$，这与质量分布内部一点的泊松方程（使用位势 $U$ 而非势 $\\Phi$）一致。\n\n**2. 分类算法**\n\n分类是使用基于几个计算量的决策树来执行的：\n- 迹 $\\operatorname{tr}(T)$。\n- Frobenius 范数尺度 $s = \\sqrt{\\operatorname{tr}(T^2)}$。\n- 不变量 $I_2 = \\frac{1}{2}\\left[(\\operatorname{tr} T)^2 - \\operatorname{tr}(T^2)\\right]$ 和 $I_3 = \\det T$。\n- 无量纲比率 $t = \\frac{|\\operatorname{tr} T|}{s + \\delta}$ 和 $d = \\frac{|I_3|}{(s + \\delta)^3}$，其中有一个小的保护值 $\\delta=10^{-300}$。\n\n分类规则依次应用：\n1.  如果 $s \\le 10^{-30} \\, \\mathrm{s}^{-2}$：分类为 $0$（片状或零梯度）。\n2.  否则，如果 $t \\le 10^{-12}$ 且 $d \\le 10^{-12}$：分类为 $1$（线状）。\n3.  否则，如果 $t \\le 10^{-12}$，$I_3 > 0$ 且 $I_2  0$：分类为 $2$（点状）。\n4.  否则，如果 $t  10^{-12}$ 且 $I_3  0$：分类为 $3$（体内部）。\n5.  否则：分类为 $2$。\n\n**测试案例应用**\n\n- **情况 1 (点质量)**：$m = 5 \\times 10^{12} \\, \\mathrm{kg}$，$\\mathbf{x}=(100, 0, 0)\\,\\mathrm{m}$。张量是对角的，其特征值与 $(2, -1, -1)$ 成比例。这导致 $\\operatorname{tr}(T)=0$ ($t \\approx 0$)，$I_3 > 0$ 且 $I_2  0$。$d$ 的值不可忽略。规则导致分类代码为 $2$。\n- **情况 2 (线质量)**：$\\lambda = 1 \\times 10^{9} \\, \\mathrm{kg/m}$，$\\mathbf{x}=(50, 0, 50)\\,\\mathrm{m}$。张量有一个零行和一个零列，导致 $\\operatorname{tr}(T)=0$ 和 $I_3=0$。因此，$t \\approx 0$ 且 $d \\approx 0$。规则导致分类代码为 $1$。\n- **情况 3 (平面薄片)**：$\\sigma = 3.0 \\times 10^{3} \\, \\mathrm{kg/m^2}$，$\\mathbf{x}=(0, 0, 100)\\,\\mathrm{m}$。GGT 是零矩阵。$s=0$，因此应用第一条规则。分类为 $0$。\n- **情况 4 (球体内部)**：$\\rho = 2.5 \\times 10^{3} \\, \\mathrm{kg/m^3}$，$a=50\\,\\mathrm{m}$，$\\mathbf{x}=(10, 0, 0)\\,\\mathrm{m}$。张量是单位矩阵的负数倍。$\\operatorname{tr}(T)$ 非零，使得 $t > 10^{-12}$。$I_3$ 为负。规则导致分类代码为 $3$。\n- **情况 5 (球体外部)**：相同的球体，$\\mathbf{x}=(200, 0, 0)\\,\\mathrm{m}$。观测点在外部，所以球体的行为像一个点质量。分析与情况 1 相同。分类为 $2$。\n\n最终的分类代码序列是 $[2, 1, 0, 3, 2]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes invariant combinations of the Gravity Gradient Tensor (GGT)\n    to classify canonical anomaly geometries for a given set of test cases.\n    \"\"\"\n    G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2\n    \n    # Classification parameters\n    EPSILON = 1e-30\n    DELTA = 1e-300\n    T_THRESH = 1e-12\n    D_THRESH = 1e-12\n\n    def compute_ggt_point(m, x_obs):\n        \"\"\"Computes GGT for a point mass at the origin.\"\"\"\n        r = np.linalg.norm(x_obs)\n        if r == 0:\n            return np.full((3, 3), np.inf)\n        \n        r_inv3 = 1.0 / r**3\n        r_inv5 = 1.0 / r**5\n        \n        T = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                delta_ij = 1 if i == j else 0\n                T[i, j] = G * m * (3 * x_obs[i] * x_obs[j] * r_inv5 - delta_ij * r_inv3)\n        return T\n\n    def compute_ggt_line(lambda_val, x_obs):\n        \"\"\"Computes GGT for an infinite line mass along the y-axis.\"\"\"\n        x, _, z = x_obs\n        R2 = x**2 + z**2\n        if R2 == 0:\n            return np.full((3, 3), np.inf)\n\n        factor = 2 * G * lambda_val / (R2**2)\n        T = np.zeros((3, 3))\n        T[0, 0] = factor * (z**2 - x**2)\n        T[0, 2] = T[2, 0] = factor * (-2 * x * z)\n        T[2, 2] = factor * (x**2 - z**2)\n        return T\n\n    def compute_ggt_sheet(sigma, x_obs):\n        \"\"\"Computes GGT for an infinite plane sheet at z=0.\"\"\"\n        # GGT is zero everywhere off the plane\n        return np.zeros((3, 3))\n\n    def compute_ggt_sphere(rho, a, x_obs):\n        \"\"\"Computes GGT for a homogeneous sphere.\"\"\"\n        r = np.linalg.norm(x_obs)\n        if r > a:  # Outside sphere\n            M = (4.0 / 3.0) * np.pi * (a**3) * rho\n            return compute_ggt_point(M, x_obs)\n        else:  # Inside sphere\n            factor = -4.0 * np.pi * G * rho / 3.0\n            return factor * np.identity(3)\n\n    test_cases = [\n        {'type': 'point', 'params': {'m': 5e12}, 'x_obs': np.array([100.0, 0.0, 0.0])},\n        {'type': 'line', 'params': {'lambda_val': 1e9}, 'x_obs': np.array([50.0, 0.0, 50.0])},\n        {'type': 'sheet', 'params': {'sigma': 3e3}, 'x_obs': np.array([0.0, 0.0, 100.0])},\n        {'type': 'sphere', 'params': {'rho': 2.5e3, 'a': 50.0}, 'x_obs': np.array([10.0, 0.0, 0.0])},\n        {'type': 'sphere', 'params': {'rho': 2.5e3, 'a': 50.0}, 'x_obs': np.array([200.0, 0.0, 0.0])},\n    ]\n\n    results = []\n    for case in test_cases:\n        T = np.zeros((3, 3))\n        if case['type'] == 'point':\n            T = compute_ggt_point(case['params']['m'], case['x_obs'])\n        elif case['type'] == 'line':\n            T = compute_ggt_line(case['params']['lambda_val'], case['x_obs'])\n        elif case['type'] == 'sheet':\n            T = compute_ggt_sheet(case['params']['sigma'], case['x_obs'])\n        elif case['type'] == 'sphere':\n            T = compute_ggt_sphere(case['params']['rho'], case['params']['a'], case['x_obs'])\n\n        # Compute invariants and classification parameters\n        tr_T = np.trace(T)\n        T_squared = T @ T\n        tr_T_squared = np.trace(T_squared)\n        \n        s = np.sqrt(tr_T_squared)\n        \n        # Invariants I2 and I3\n        I2 = 0.5 * (tr_T**2 - tr_T_squared)\n        I3 = np.linalg.det(T)\n        \n        # Dimensionless ratios t and d\n        t = np.abs(tr_T) / (s + DELTA)\n        d = np.abs(I3) / ((s + DELTA)**3)\n        \n        # Apply decision rule\n        classification = 0\n        if s = EPSILON:\n            classification = 0\n        elif t = T_THRESH and d = D_THRESH:\n            classification = 1\n        elif t = T_THRESH and I3 > 0 and I2  0:\n            classification = 2\n        elif t > T_THRESH and I3  0:\n            classification = 3\n        else:\n            classification = 2\n            \n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}