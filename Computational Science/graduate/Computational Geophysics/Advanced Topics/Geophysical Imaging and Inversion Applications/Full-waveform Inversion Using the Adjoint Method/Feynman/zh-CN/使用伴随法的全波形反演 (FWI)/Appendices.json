{
    "hands_on_practices": [
        {
            "introduction": "在我们进行数据反演之前，我们必须能够准确、稳定地进行模拟。本练习聚焦于数值波仿真的基石：稳定性条件。理解并推导Courant–Friedrichs–Lewy (CFL) 条件是一项基本技能，它可以防止数值不稳定性，确保我们的正向和伴随模拟都能产生有意义的结果。",
            "id": "3598910",
            "problem": "考虑常密度声学全波形反演（FWI），其中正向和伴随波场通过二维声波方程传播。设压力场表示为 $p(x,z,t)$，并考虑一个在均匀但可能各向异性的笛卡尔网格上离散化的矩形计算域，其在水平和垂直方向上的间距分别为 $\\Delta x$ 和 $\\Delta z$，并具有均匀的时间步长 $\\Delta t$。声波方程为\n$$\\frac{\\partial^{2} p}{\\partial t^{2}}(x,z,t) = v(x,z)^{2} \\nabla^{2} p(x,z,t) + s(x,z,t),$$\n其中 $v(x,z)$ 是空间变化的波速，$s(x,z,t)$ 是源项。在伴随状态 FWI 中，正向传播和伴随反向传播都需要稳定的时间步进，以确保目标函数有明确定义的梯度。\n\n从上述连续偏微分方程出发，在给定的网格上仅使用空间和时间的二阶中心差分，推导将网格节点 $(i,j)$ 和时间索引 $n$ 处的 $p_{i,j}^{n}$推进到 $p_{i,j}^{n+1}$ 的显式离散更新公式，该公式用时间索引 $n$ 处相邻空间节点的 $p$ 值和前一时间层 $p_{i,j}^{n-1}$ 来表示。然后，对常数 $v(x,z) = v_{\\max}$ 的齐次情况 $s(x,z,t)=0$ 进行傅里叶（von Neumann）稳定性分析，以获得用 $v_{\\max}$、$\\Delta t$、$\\Delta x$ 和 $\\Delta z$ 表示的 Courant–Friedrichs–Lewy (CFL) 稳定性条件。\n\n最后，根据生产 FWI 工作流程中使用的以下物理上真实的建模参数，评估最大稳定时间步长：$v_{\\max} = 3600 \\,\\text{m/s}$，$\\Delta x = 7.5 \\,\\text{m}$，$\\Delta z = 10 \\,\\text{m}$。报告以秒为单位的最大允许 $\\Delta t$，四舍五入到四位有效数字。最终答案以秒表示。",
            "solution": "该问题提法明确，具有科学依据，并提供了获得唯一解所需的所有信息。我们首先对给定的偏微分方程进行离散化，然后进行稳定性分析以找出对时间步长的约束，最后根据给定的参数评估此约束。\n\n连续的二维声波方程由下式给出：\n$$\n\\frac{\\partial^{2} p}{\\partial t^{2}}(x,z,t) = v(x,z)^{2} \\nabla^{2} p(x,z,t) + s(x,z,t)\n$$\n其中 $\\nabla^{2} = \\frac{\\partial^{2}}{\\partial x^{2}} + \\frac{\\partial^{2}}{\\partial z^{2}}$。\n\n首先，我们推导显式离散更新公式。我们在具有点 $(x_i, z_j, t_n) = (i\\Delta x, j\\Delta z, n\\Delta t)$ 的网格上，对偏导数使用二阶中心差分近似。该点的压力表示为 $p_{i,j}^{n}$。\n\n二阶时间导数近似为：\n$$\n\\frac{\\partial^{2} p}{\\partial t^{2}} \\bigg|_{i,j,n} \\approx \\frac{p_{i,j}^{n+1} - 2 p_{i,j}^{n} + p_{i,j}^{n-1}}{\\Delta t^2}\n$$\n\n二阶空间导数近似为：\n$$\n\\frac{\\partial^{2} p}{\\partial x^{2}} \\bigg|_{i,j,n} \\approx \\frac{p_{i+1,j}^{n} - 2 p_{i,j}^{n} + p_{i-1,j}^{n}}{\\Delta x^2}\n$$\n$$\n\\frac{\\partial^{2} p}{\\partial z^{2}} \\bigg|_{i,j,n} \\approx \\frac{p_{i,j+1}^{n} - 2 p_{i,j}^{n} + p_{i,j-1}^{n}}{\\Delta z^2}\n$$\n\n将这些近似值代入网格点 $(i,j)$ 和时间层 $n$ 的波动方程，并令 $v_{i,j} = v(x_i, z_j)$ 和 $s_{i,j}^n = s(x_i, z_j, t_n)$，我们得到：\n$$\n\\frac{p_{i,j}^{n+1} - 2 p_{i,j}^{n} + p_{i,j}^{n-1}}{\\Delta t^2} = v_{i,j}^{2} \\left( \\frac{p_{i+1,j}^{n} - 2 p_{i,j}^{n} + p_{i-1,j}^{n}}{\\Delta x^2} + \\frac{p_{i,j+1}^{n} - 2 p_{i,j}^{n} + p_{i,j-1}^{n}}{\\Delta z^2} \\right) + s_{i,j}^n\n$$\n为了找到 $p_{i,j}^{n+1}$ 的显式更新公式，我们重新整理方程：\n$$\np_{i,j}^{n+1} = 2 p_{i,j}^{n} - p_{i,j}^{n-1} + (v_{i,j} \\Delta t)^{2} \\left( \\frac{p_{i+1,j}^{n} - 2 p_{i,j}^{n} + p_{i-1,j}^{n}}{\\Delta x^2} + \\frac{p_{i,j+1}^{n} - 2 p_{i,j}^{n} + p_{i,j-1}^{n}}{\\Delta z^2} \\right) + \\Delta t^2 s_{i,j}^n\n$$\n这就是所要求的离散更新公式。\n\n接下来，我们对常数波速（$v(x,z) = v_{\\max}$）的齐次情况（$s(x,z,t)=0$）进行傅里叶（von Neumann）稳定性分析。离散方程简化为：\n$$\np_{i,j}^{n+1} = 2 p_{i,j}^{n} - p_{i,j}^{n-1} + (v_{\\max} \\Delta t)^{2} \\left( \\frac{p_{i+1,j}^{n} - 2 p_{i,j}^{n} + p_{i-1,j}^{n}}{\\Delta x^2} + \\frac{p_{i,j+1}^{n} - 2 p_{i,j}^{n} + p_{i,j-1}^{n}}{\\Delta z^2} \\right)\n$$\n我们考虑一个形如下式的单傅里叶模式解：\n$$\np_{i,j}^{n} = G^{n} \\exp(I (k_x i \\Delta x + k_z j \\Delta z))\n$$\n其中 $G$ 是放大因子，$k_x$ 和 $k_z$ 分别是 $x$ 和 $z$ 方向的波数，$I = \\sqrt{-1}$。为了使格式稳定，放大因子的模必须对所有波数都满足 $|G| \\leq 1$。\n\n将傅里叶模式代入齐次离散方程，并除以 $p_{i,j}^{n-1} = G^{n-1} \\exp(I(k_x i \\Delta x + k_z j \\Delta z))$，得到关于 $G$ 的方程：\n$$\nG^2 = 2G - 1 + G \\frac{(v_{\\max} \\Delta t)^2}{\\Delta x^2} \\left[ \\exp(I k_x \\Delta x) - 2 + \\exp(-I k_x \\Delta x) \\right] + G \\frac{(v_{\\max} \\Delta t)^2}{\\Delta z^2} \\left[ \\exp(I k_z \\Delta z) - 2 + \\exp(-I k_z \\Delta z) \\right]\n$$\n使用恒等式 $\\exp(I\\theta) + \\exp(-I\\theta) = 2\\cos(\\theta)$，方括号中的项变为 $2\\cos(k_x\\Delta x) - 2 = -2(1-\\cos(k_x\\Delta x))$ 和 $2\\cos(k_z\\Delta z) - 2 = -2(1-\\cos(k_z\\Delta z))$。再使用半角恒等式 $1-\\cos(\\theta) = 2\\sin^2(\\theta/2)$，这些项分别简化为 $-4\\sin^2(k_x\\Delta x/2)$ 和 $-4\\sin^2(k_z\\Delta z/2)$。\n\n将这些代回，得到：\n$$\nG^2 = 2G - 1 - 4G(v_{\\max} \\Delta t)^2 \\left[ \\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_z\\Delta z/2)}{\\Delta z^2} \\right]\n$$\n将其重新整理成关于 $G$ 的标准二次型 $aG^2+bG+c=0$：\n$$\nG^2 - 2G \\left( 1 - 2(v_{\\max} \\Delta t)^2 \\left[ \\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_z\\Delta z/2)}{\\Delta z^2} \\right] \\right) + 1 = 0\n$$\n这是一个形如 $G^2 - 2\\alpha G + 1 = 0$ 的二次方程，其中\n$$\n\\alpha = 1 - 2(v_{\\max} \\Delta t)^2 \\left[ \\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_z\\Delta z/2)}{\\Delta z^2} \\right]\n$$\n根为 $G = \\alpha \\pm \\sqrt{\\alpha^2-1}$。为了使稳定性条件 $|G| \\leq 1$ 成立，根必须是复数或位于单位圆上，这要求平方根下的项为非正数，即 $\\alpha^2 - 1 \\leq 0$。这等价于 $|\\alpha| \\leq 1$。\n\n条件 $\\alpha \\leq 1$ 总是满足的，因为从 1 中减去的项是非负量的和。稳定性的关键条件来自 $\\alpha \\geq -1$：\n$$\n1 - 2(v_{\\max} \\Delta t)^2 \\left[ \\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_z\\Delta z/2)}{\\Delta z^2} \\right] \\geq -1\n$$\n$$\n2 \\geq 2(v_{\\max} \\Delta t)^2 \\left[ \\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_z\\Delta z/2)}{\\Delta z^2} \\right]\n$$\n$$\n(v_{\\max} \\Delta t)^2 \\left[ \\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_z\\Delta z/2)}{\\Delta z^2} \\right] \\leq 1\n$$\n该不等式必须对所有波数 $k_x$ 和 $k_z$ 成立。对 $\\Delta t$ 最严格的约束发生在方括号中的项最大化时。这发生在 $\\sin^2(k_x\\Delta x/2)=1$ 和 $\\sin^2(k_z\\Delta z/2)=1$ 时，这对应于网格上可分辨的最高频率（奈奎斯特频率，$k_x = \\pi/\\Delta x$ 和 $k_z = \\pi/\\Delta z$）。\n因此，方括号项的最大值为 $\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta z^2}$。\n\n稳定性条件变为：\n$$\n(v_{\\max} \\Delta t)^2 \\left( \\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta z^2} \\right) \\leq 1\n$$\n取平方根，我们得到 Courant–Friedrichs–Lewy (CFL) 稳定性条件：\n$$\n\\Delta t \\leq \\frac{1}{v_{\\max} \\sqrt{\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta z^2}}}\n$$\n\n最后，我们根据给定的参数评估最大稳定时间步长 $\\Delta t_{\\max}$：$v_{\\max} = 3600 \\,\\text{m/s}$，$\\Delta x = 7.5 \\,\\text{m}$，以及 $\\Delta z = 10 \\,\\text{m}$。\n$$\n\\Delta t_{\\max} = \\frac{1}{3600 \\sqrt{\\frac{1}{7.5^2} + \\frac{1}{10^2}}}\n$$\n我们计算平方根下的项：\n$$\n\\frac{1}{7.5^2} + \\frac{1}{10^2} = \\frac{1}{56.25} + \\frac{1}{100} = \\frac{16}{900} + \\frac{9}{900} = \\frac{25}{900} = \\frac{1}{36}\n$$\n平方根为：\n$$\n\\sqrt{\\frac{1}{36}} = \\frac{1}{6}\n$$\n将此代回 $\\Delta t_{\\max}$ 的表达式中：\n$$\n\\Delta t_{\\max} = \\frac{1}{3600 \\times \\frac{1}{6}} = \\frac{6}{3600} = \\frac{1}{600} \\,\\text{s}\n$$\n以小数形式表示，这是 $\\Delta t_{\\max} = 0.001666... \\,\\text{s}$。四舍五入到四位有效数字，我们得到：\n$$\n\\Delta t_{\\max} \\approx 0.001667 \\,\\text{s}\n$$",
            "answer": "$$\\boxed{0.001667}$$"
        },
        {
            "introduction": "伴随状态法为计算失配函数梯度提供了一种优雅的方法，然而，“优雅”并不意味着“易于正确实现”。本练习将引导您完成验证代码实现的基本过程。一个不正确的梯度将导致反演走向歧途，产生无意义的结果。通过执行梯度测试（或称点积测试），您可以确信您的伴随状态机制工作正常，这是在运行任何实际反演之前不可或缺的一步。",
            "id": "3598829",
            "problem": "您的任务是使用一维空间中的伴随法，为全波形反演（FWI）设计并验证一个合成基准测试。其目标是检验梯度和赫斯向量积的正确性，并展示反演相对于已知真实数据的收敛性。所有量必须根据计算地球物理学的第一性原理进行定义和实现，所有数学实体必须使用 LaTeX 符号表示。\n\n其物理基础是一维声波方程，描述了在波速 $c(x)$ 随空间变化的介质中，标量质点位移场 $u(x,t)$ 的行为。该方程通过慢度平方 $m(x) = 1/c(x)^2$ 表示：\n$$\nm(x)\\,\\frac{\\partial^2 u(x,t)}{\\partial t^2} - \\frac{\\partial^2 u(x,t)}{\\partial x^2} = s(x,t),\n$$\n其中 $s(x,t)$ 是一个给定的源项。观测算子是在一组有限的接收点位置 $\\{x_r\\}$ 进行采样，提供数据 $u(x_r,t)$，其目标函数定义为模拟数据与观测数据之间的最小二乘拟合差：\n$$\nJ(m) = \\frac{1}{2}\\sum_{r}\\int_{0}^{T}\\left(u(x_r,t;m) - d_r(t)\\right)^2 \\,\\mathrm{d}t,\n$$\n其中 $d_r(t)$ 是由真实模型 $m^\\star(x)$ 生成的观测数据， $T$ 是记录时长。\n\n针对此目标函数，使用相同的波算子的伴随状态法引入了伴随场 $\\lambda(x,t)$，它满足伴随偏微分方程\n$$\nm(x)\\,\\frac{\\partial^2 \\lambda(x,t)}{\\partial t^2} - \\frac{\\partial^2 \\lambda(x,t)}{\\partial x^2} = \\sum_{r}\\delta(x-x_r)\\,\\left(u(x_r,t;m)-d_r(t)\\right),\n$$\n在 $t = T$ 和 $t = 0$ 处具有齐次终端条件。在这些条件下，目标函数相对于 $m(x)$ 的梯度为\n$$\n\\frac{\\delta J}{\\delta m}(x) = -\\int_{0}^{T}\\frac{\\partial^2 u(x,t)}{\\partial t^2}\\,\\lambda(x,t)\\,\\mathrm{d}t.\n$$\n\n您的程序必须在间距为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀空间网格上离散化上述方程，使用与 Courant–Friedrichs–Lewy 条件一致的蛙跳格式。离散拉普拉斯算子必须通过二阶中心差分算子实现。为了科学一致性，您必须施加固定值边界条件 $u(0,t)=0$ 和 $u(L,t)=0$。源项 $s(x,t)$ 必须是一个中心频率为 $f_0$、位于指定震源位置 $x_s$ 的带限雷克子波。接收器必须放置在远离边界的指定位置 $\\{x_r\\}$。所有长度单位必须是米，所有时间单位必须是秒。拟合差 $J(m)$ 是无量纲的。\n\n您必须针对由已知真实模型 $m^\\star(x)$ 生成的合成数据执行三项验证任务：\n\n1. 通过方向导数一致性进行梯度测试。对于一个非平凡的扰动方向 $p(x)$，针对一系列递减的步长 $\\epsilon$，验证以下恒等式\n$$\n\\frac{J(m+\\epsilon p)-J(m)}{\\epsilon} \\approx \\int_{0}^{L}\\frac{\\delta J}{\\delta m}(x)\\,p(x)\\,\\mathrm{d}x,\n$$\n报告测试序列中的最大相对差异，以及该差异是否随 $\\epsilon$ 单调递减。\n\n2. 通过二阶泰勒余项进行赫斯向量测试。对于一个扰动方向 $v(x)$，定义有限差分赫斯向量标量\n$$\nv^\\top H(m)v \\approx \\int_{0}^{L} v(x)\\,\\frac{\\frac{\\delta J}{\\delta m}(x;m+\\epsilon v)-\\frac{\\delta J}{\\delta m}(x;m-\\epsilon v)}{2\\epsilon}\\,\\mathrm{d}x,\n$$\n并测试二阶泰勒模型\n$$\nJ(m+\\epsilon v) \\approx J(m) + \\epsilon\\,\\int_{0}^{L}\\frac{\\delta J}{\\delta m}(x)\\,v(x)\\,\\mathrm{d}x + \\frac{1}{2}\\epsilon^2\\,v^\\top H(m)v.\n$$\n计算在所使用的最小 $\\epsilon$ 值下此近似的相对误差。\n\n3. 反演收敛性。从一个初始模型 $m_0(x)$ 开始，运行一个基于梯度的迭代更新，该更新采用满足 Armijo 条件的回溯线搜索来减小 $J(m)$，迭代固定次数。在梯度上使用一个简单的平滑预条件子来稳定更新。报告迭代后 $J(m_{\\text{final}})/J(m_0)$ 的比率。\n\n您必须实现一个自包含的测试套件，其中包含三个案例，每个案例都由具有物理意义的参数完全指定。答案必须是无量纲的布尔值，根据此处提供的接受阈值指示通过或失败：\n\n- 梯度测试接受标准：在最小 $\\epsilon$ 处的最大相对差异不得超过 $0.10$，并且差异必须在测试的 $\\epsilon$ 值上单调递减。\n- 赫斯测试接受标准：在最小 $\\epsilon$ 处的二阶泰勒模型的相对误差不得超过 $0.25$。\n- 反演收敛接受标准：最终的拟合差比率必须小于或等于特定案例的阈值。\n\n所有答案必须汇总为单行，形式为用方括号括起来的逗号分隔列表。每个案例的结果必须是形式为 $[\\text{gradient\\_pass},\\text{hessian\\_pass},\\text{convergence\\_pass}]$ 的三个布尔值的列表。\n\n测试套件规格：\n\n- 案例 1（理想路径）：域长度 $L=1000\\,\\mathrm{m}$，网格点数 $N_x=201$，震源位置 $x_s=200\\,\\mathrm{m}$，雷克子波频率 $f_0=10\\,\\mathrm{Hz}$，记录时长 $T=1.0\\,\\mathrm{s}$。真实波速剖面 $c^\\star(x)$ 是一个双层模型：当 $x  500\\,\\mathrm{m}$ 时 $c^\\star(x)=2000\\,\\mathrm{m/s}$，否则 $c^\\star(x)=2500\\,\\mathrm{m/s}$。初始模型 $c_0(x)=2200\\,\\mathrm{m/s}$（处处）。接收点位置为 $x_r=\\{600,700,800\\}\\,\\mathrm{m}$。收敛阈值：如果 $J(m_{\\text{final}})/J(m_0)\\le 0.60$，则报告通过。\n- 案例 2（接近 Courant 边界）：域长度 $L=500\\,\\mathrm{m}$，网格点数 $N_x=101$，震源位置 $x_s=100\\,\\mathrm{m}$，雷克子波频率 $f_0=15\\,\\mathrm{Hz}$，记录时长 $T=0.6\\,\\mathrm{s}$。真实波速剖面 $c^\\star(x)$ 是线性的：$c^\\star(x)=2200+600x/L\\,\\mathrm{m/s}$。初始模型 $c_0(x)=2300\\,\\mathrm{m/s}$（处处）。接收点位置为 $x_r=\\{300,400\\}\\,\\mathrm{m}$。选择 $\\Delta t$ 为最大速度下稳定性极限的 $0.99$ 倍。收敛阈值：如果 $J(m_{\\text{final}})/J(m_0)\\le 0.70$，则报告通过。\n- 案例 3（低对比度异常）：域长度 $L=800\\,\\mathrm{m}$，网格点数 $N_x=161$，震源位置 $x_s=150\\,\\mathrm{m}$，雷克子波频率 $f_0=12\\,\\mathrm{Hz}$，记录时长 $T=0.8\\,\\mathrm{s}$。真实波速剖面 $c^\\star(x)=2500+100\\exp\\left(-\\frac{(x-500)^2}{2\\cdot 50^2}\\right)\\,\\mathrm{m/s}$。初始模型 $c_0(x)=2500\\,\\mathrm{m/s}$（处处）。接收点位置为 $x_r=\\{450,550,650\\}\\,\\mathrm{m}$。收敛阈值：如果 $J(m_{\\text{final}})/J(m_0)\\le 0.85$，则报告通过。\n\n此问题不涉及角度单位。所有报告的布尔值都是无量纲的。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如，使用 Python 布尔字面量：“[[true,true,true],[true,true,false],[true,true,true]]”。",
            "solution": "用户为设计和验证一维全波形反演 (FWI) 基准测试提供了一个定义明确且科学严谨的问题陈述。根据所有指定标准，该问题是有效的。\n\n-   **科学基础**：该问题建立在标准的一维声波方程、最小二乘目标函数以及用于梯度计算的伴随状态法之上。这些是计算地球物理学中基本且正确的原理。\n-   **适定性**：该问题被完全指定，为三个不同的测试用例提供了所有必要的物理参数、模型定义和数值设置。验证任务（梯度测试、赫斯向量测试和反演收敛）是验证数值优化代码的标准和客观程序。\n-   **客观性与完整性**：该问题以精确、无歧义的语言陈述。所有约束、边界条件、源定义和接受阈值都已明确给出，没有主观解释的余地。完整实现所需的所有参数都已提供。\n\n该问题没有矛盾，物理上合理，并且计算上可行。因此，我将着手提供一个完整的解决方案。\n\n该解决方案涉及几个关键组成部分：\n1.  **波方程求解器**：一个用于一维声波方程 $m(x)\\,\\frac{\\partial^2 u}{\\partial t^2} - \\frac{\\partial^2 u}{\\partial x^2} = s(x,t)$ 的时域有限差分 (FDTD) 求解器。空间导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 使用二阶精确的中心差分，时间步进使用二阶蛙跳格式。其更新器由下式给出：\n    $$\n    u_i^{j+1} = 2u_i^j - u_i^{j-1} + \\frac{(\\Delta t)^2}{m_i} \\left( \\frac{u_{i+1}^j - 2u_i^j + u_{i-1}^j}{(\\Delta x)^2} + s_i^j \\right)\n    $$\n    其中 $i$ 是空间索引， $j$ 是时间索引。强制执行固定边界条件 $u(0,t)=0$ 和 $u(L,t)=0$。\n\n2.  **伴随求解器**：伴随波方程 $m(x)\\,\\frac{\\partial^2 \\lambda}{\\partial t^2} - \\frac{\\partial^2 \\lambda}{\\partial x^2} = \\sum_{r}\\delta(x-x_r)\\,(u(x_r,t)-d_r(t))$ 在时间上向后求解。其数值格式与正演求解器相同，但从 $t=T$ 步进到 $t=0$，并采用零终端条件 $\\lambda(x,T)=0$ 和 $\\frac{\\partial \\lambda}{\\partial t}(x,T)=0$。源项是在接收点位置注入的数据残差。\n\n3.  **目标函数与梯度**：目标函数 $J(m)$ 是残差的离散平方和：\n    $$\n    J(m) = \\frac{1}{2}\\sum_{r}\\sum_{j=0}^{N_t-1} \\left(u(x_r, t_j; m) - d_r(t_j)\\right)^2 \\Delta t\n    $$\n    梯度通过将正演波场和伴随波场互相关来计算，根据所提供的公式：\n    $$\n    \\frac{\\delta J}{\\delta m}(x_i) = -\\sum_{j=0}^{N_t-1} \\left(\\frac{u_i^{j+1} - 2u_i^j + u_i^{j-1}}{(\\Delta t)^2}\\right)\\,\\lambda_i^j\\,\\Delta t\n    $$\n    这需要存储整个正演波场 $u(x,t)$。\n\n4.  **验证测试**：\n    -   **梯度测试**：通过将基于伴随的方向导数与有限差分近似进行比较，来验证梯度计算。泰勒展开 $J(m+\\epsilon p) = J(m) + \\epsilon \\langle \\nabla J, p \\rangle + \\mathcal{O}(\\epsilon^2)$ 意味着当 $\\epsilon \\to 0$ 时，$(\\frac{J(m+\\epsilon p)-J(m)}{\\epsilon}) / \\langle \\nabla J, p \\rangle \\to 1$。我们通过检查相对差异对于一系列 $\\epsilon$ 是否单调递减来测试二阶收敛性。\n    -   **赫斯向量测试**：通过测试目标函数的二阶泰勒展开来验证梯度的一致性。赫斯向量积 $H v$ 通过梯度上的中心差分来近似：$\\frac{\\nabla J(m+\\epsilon v) - \\nabla J(m-\\epsilon v)}{2\\epsilon}$。然后，该测试会检查近似的相对误差：$J(m+\\epsilon v) \\approx J(m) + \\epsilon \\langle \\nabla J, v \\rangle + \\frac{1}{2} \\epsilon^2 \\langle v, H v \\rangle$。\n    -   **反演测试**：执行一个简单的梯度下降优化，迭代固定次数。更新方向由预处理后的负梯度给出。使用回溯线搜索来找到一个满足 Armijo 条件的合适步长 $\\alpha_k$，以确保目标函数有足够的下降。模型通过 $m_{k+1} = m_k - \\alpha_k P \\nabla J(m_k)$ 进行更新，其中 $P$ 是一个平滑预条件子（高斯滤波器）。\n\n这些组件被封装在一个类结构中，以简洁地处理每个测试用例的参数和方法。最终的脚本执行三个指定的测试用例，并按要求格式化布尔型的通过/失败结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import gaussian_filter1d\n\n# Define global constants for inversion\nARMIJO_C1 = 1e-4\nARMIJO_TAU = 0.5\nINVERSION_ITERATIONS = 10\nGRADIENT_TEST_EPSILONS = [1e-4, 1e-5, 1e-6, 1e-7]\nHESSIAN_TEST_EPSILON = 1e-5\n\nclass FWI1DBenchmark:\n    \"\"\"\n    Encapsulates the 1D FWI problem setup and validation tests.\n    \"\"\"\n    def __init__(self, L, Nx, T, f0, xs_pos, xr_pos, c_true_func, c_init_func, cfl_factor=0.5):\n        # Spatial grid\n        self.L = L\n        self.Nx = Nx\n        self.x = np.linspace(0, L, Nx, dtype=np.float64)\n        self.dx = self.x[1] - self.x[0]\n\n        # Velocity and slowness models\n        self.c_true = c_true_func(self.x)\n        self.m_true = 1.0 / self.c_true**2\n        self.c_init = c_init_func(self.x)\n        self.m_init = 1.0 / self.c_init**2\n\n        # Time grid (CFL condition)\n        c_max = np.max([np.max(self.c_true), np.max(self.c_init)])\n        self.dt = cfl_factor * self.dx / c_max\n        self.T = T\n        self.Nt = int(T / self.dt)\n        self.t = np.arange(self.Nt) * self.dt\n\n        # Source wavelet\n        self.f0 = f0\n        self.src_idx = np.argmin(np.abs(self.x - xs_pos))\n        self.source_wavelet = self._create_ricker()\n\n        # Receiver setup\n        self.rec_indices = [np.argmin(np.abs(self.x - pos)) for pos in xr_pos]\n\n        # Generate \"observed\" data from the true model\n        self.d_obs, _ = self._wave_solver(self.m_true, store_full_field=False)\n\n    def _create_ricker(self):\n        t0 = 1.2 / self.f0  # Shift to ensure wavelet peak is not at t=0\n        arg = (np.pi * self.f0 * (self.t - t0))**2\n        return (1.0 - 2.0 * arg) * np.exp(-arg)\n\n    def _wave_solver(self, m, store_full_field=True):\n        u_prev = np.zeros(self.Nx, dtype=np.float64)\n        u_curr = np.zeros(self.Nx, dtype=np.float64)\n        m_inv_dt2 = (self.dt**2) / m\n\n        rec_data = np.zeros((len(self.rec_indices), self.Nt), dtype=np.float64)\n        full_field = np.zeros((self.Nx, self.Nt), dtype=np.float64) if store_full_field else None\n\n        for j in range(self.Nt):\n            laplacian = np.zeros(self.Nx, dtype=np.float64)\n            laplacian[1:-1] = (u_curr[2:] - 2*u_curr[1:-1] + u_curr[:-2]) / self.dx**2\n            \n            source_term = np.zeros(self.Nx, dtype=np.float64)\n            source_term[self.src_idx] = self.source_wavelet[j]\n\n            u_next = 2*u_curr - u_prev + m_inv_dt2 * (laplacian + source_term)\n            u_next[0] = 0.0\n            u_next[-1] = 0.0\n\n            u_prev, u_curr = u_curr, u_next\n\n            rec_data[:, j] = u_curr[self.rec_indices]\n            if store_full_field:\n                full_field[:, j] = u_curr\n        \n        return rec_data, full_field\n\n    def _adjoint_solver(self, m, residual):\n        lambda_prev = np.zeros(self.Nx, dtype=np.float64)\n        lambda_curr = np.zeros(self.Nx, dtype=np.float64)\n        m_inv_dt2 = (self.dt**2) / m\n\n        adj_src_grid = np.zeros((self.Nx, self.Nt), dtype=np.float64)\n        for i, rec_idx in enumerate(self.rec_indices):\n            adj_src_grid[rec_idx, :] = residual[i, :]\n\n        full_adjoint_field = np.zeros((self.Nx, self.Nt), dtype=np.float64)\n\n        for j in range(self.Nt - 1, -1, -1):\n            laplacian = np.zeros(self.Nx, dtype=np.float64)\n            laplacian[1:-1] = (lambda_curr[2:] - 2*lambda_curr[1:-1] + lambda_curr[:-2]) / self.dx**2\n            \n            lambda_next = 2*lambda_curr - lambda_prev + m_inv_dt2 * (laplacian + adj_src_grid[:, j])\n            lambda_next[0] = 0.0\n            lambda_next[-1] = 0.0\n\n            lambda_prev, lambda_curr = lambda_curr, lambda_next\n            full_adjoint_field[:, j] = lambda_curr\n            \n        return full_adjoint_field\n\n    def _compute_objective(self, m):\n        sim_data, _ = self._wave_solver(m, store_full_field=False)\n        residual = sim_data - self.d_obs\n        return 0.5 * np.sum(residual**2) * self.dt\n\n    def _compute_gradient(self, m):\n        sim_data, u_full = self._wave_solver(m, store_full_field=True)\n        residual = sim_data - self.d_obs\n        lambda_full = self._adjoint_solver(m, residual)\n\n        u_tt = np.zeros_like(u_full)\n        u_tt[:, 1:-1] = (u_full[:, 2:] - 2*u_full[:, 1:-1] + u_full[:, :-2]) / self.dt**2\n        \n        grad = -np.sum(u_tt * lambda_full, axis=1) * self.dt\n        return grad\n\n    def run_gradient_test(self):\n        m = self.m_init\n        p = np.random.randn(self.Nx)\n        p = gaussian_filter1d(p, sigma=2.0)\n        p[0] = p[-1] = 0.0\n        p /= np.linalg.norm(p)\n\n        grad_m = self._compute_gradient(m)\n        grad_dot_p = np.sum(grad_m * p) * self.dx\n\n        discrepancies = []\n        J_m = self._compute_objective(m)\n        \n        for eps in GRADIENT_TEST_EPSILONS:\n            J_m_eps_p = self._compute_objective(m + eps * p)\n            fd_dot_prod = (J_m_eps_p - J_m) / eps\n            if abs(grad_dot_p) > 1e-15:\n                discrepancy = np.abs(fd_dot_prod - grad_dot_p) / np.abs(grad_dot_p)\n                discrepancies.append(discrepancy)\n        \n        if len(discrepancies)  2: return False\n\n        monotonic = all(discrepancies[i] > discrepancies[i+1] for i in range(len(discrepancies)-1))\n        pass_test = monotonic and (discrepancies[-1]  0.10)\n        return pass_test\n\n    def run_hessian_test(self):\n        m = self.m_init\n        eps = HESSIAN_TEST_EPSILON\n        \n        v = np.random.randn(self.Nx)\n        v = gaussian_filter1d(v, sigma=2.0)\n        v[0] = v[-1] = 0.0\n        v /= np.linalg.norm(v)\n\n        J_m = self._compute_objective(m)\n        grad_m = self._compute_gradient(m)\n        T1 = eps * np.sum(grad_m * v) * self.dx\n\n        grad_plus = self._compute_gradient(m + eps * v)\n        grad_minus = self._compute_gradient(m - eps * v)\n        Hv = (grad_plus - grad_minus) / (2 * eps)\n        vHv = np.sum(v * Hv) * self.dx\n        T2 = 0.5 * eps**2 * vHv\n\n        J_approx = J_m + T1 + T2\n        J_true = self._compute_objective(m + eps * v)\n        \n        denominator = np.abs(J_true)\n        if denominator  1e-15: return np.abs(J_true - J_approx)  1e-15\n\n        relative_error = np.abs(J_true - J_approx) / denominator\n        return relative_error  0.25\n\n    def run_inversion_test(self, conv_threshold):\n        m = self.m_init.copy()\n        J_initial = self._compute_objective(m)\n        if J_initial  1e-15: return True\n\n        for _ in range(INVERSION_ITERATIONS):\n            grad = self._compute_gradient(m)\n            search_dir = -gaussian_filter1d(grad, sigma=1.0)\n            search_dir[0] = search_dir[-1] = 0.0\n\n            alpha = 1.0\n            J_current = self._compute_objective(m)\n            grad_dot_s = np.sum(grad * search_dir) * self.dx\n            \n            for _ in range(10): # Max backtracking steps\n                if self._compute_objective(m + alpha * search_dir) = J_current + ARMIJO_C1 * alpha * grad_dot_s:\n                    break\n                alpha *= ARMIJO_TAU\n            else: # Line search failed\n                break\n            \n            m += alpha * search_dir\n        \n        J_final = self._compute_objective(m)\n        return (J_final / J_initial) = conv_threshold\n\ndef solve():\n    np.random.seed(0)\n\n    test_specs = [\n        { # Case 1: Happy path\n            \"L\": 1000.0, \"Nx\": 201, \"T\": 1.0, \"f0\": 10.0, \"xs_pos\": 200.0,\n            \"xr_pos\": [600.0, 700.0, 800.0],\n            \"c_true_func\": lambda x: np.where(x  500.0, 2000.0, 2500.0),\n            \"c_init_func\": lambda x: np.full_like(x, 2200.0),\n            \"cfl_factor\": 0.5, \"conv_thresh\": 0.60\n        },\n        { # Case 2: Near-Courant boundary\n            \"L\": 500.0, \"Nx\": 101, \"T\": 0.6, \"f0\": 15.0, \"xs_pos\": 100.0,\n            \"xr_pos\": [300.0, 400.0],\n            \"c_true_func\": lambda x: 2200.0 + 600.0 * x / 500.0,\n            \"c_init_func\": lambda x: np.full_like(x, 2300.0),\n            \"cfl_factor\": 0.99, \"conv_thresh\": 0.70\n        },\n        { # Case 3: Low-contrast anomaly\n            \"L\": 800.0, \"Nx\": 161, \"T\": 0.8, \"f0\": 12.0, \"xs_pos\": 150.0,\n            \"xr_pos\": [450.0, 550.0, 650.0],\n            \"c_true_func\": lambda x: 2500.0 + 100.0 * np.exp(-(x-500.0)**2 / (2 * 50.0**2)),\n            \"c_init_func\": lambda x: np.full_like(x, 2500.0),\n            \"cfl_factor\": 0.5, \"conv_thresh\": 0.85\n        }\n    ]\n\n    all_results = []\n    for spec in test_specs:\n        benchmark = FWI1DBenchmark(\n            L=spec[\"L\"], Nx=spec[\"Nx\"], T=spec[\"T\"], f0=spec[\"f0\"],\n            xs_pos=spec[\"xs_pos\"], xr_pos=spec[\"xr_pos\"],\n            c_true_func=spec[\"c_true_func\"], c_init_func=spec[\"c_init_func\"],\n            cfl_factor=spec[\"cfl_factor\"]\n        )\n        \n        grad_pass = benchmark.run_gradient_test()\n        hess_pass = benchmark.run_hessian_test()\n        conv_pass = benchmark.run_inversion_test(spec[\"conv_thresh\"])\n        \n        all_results.append([grad_pass, hess_pass, conv_pass])\n\n    output_str = \",\".join([f'[{\",\".join(map(lambda b: str(b).lower(), res))}]' for res in all_results])\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "真实的地震数据常常被非高斯噪声和异常值（例如地面滚动或仪器尖峰）污染，而标准的最小二乘（$L_2$）失配函数对这些异常值可能过于敏感。本练习探讨如何通过为噪声采用不同的统计假设，使全波形反演 (FWI) 更加稳健。通过为学生t ($t$-distribution) 分布推导伴随源，您将学习到失配函数的选择如何直接影响梯度，以及稳健统计学如何能自动降低异常值的权重，这项技能对于将FWI应用于具有挑战性的含噪数据集至关重要。",
            "id": "3598874",
            "problem": "考虑全波形反演（FWI），其中正演波场算子通过偏微分方程（如声波方程）将模型参数 $m$ 映射到接收点位置的预测数据 $d_{\\mathrm{pred}}(t)$。在伴随状态法中，通过求解一个伴随波方程来获得关于 $m$ 的梯度，该方程由接收点处的伴随源驱动，而伴随源取决于误差泛函关于 $d_{\\mathrm{pred}}(t)$ 的导数。假设数据噪声被建模为自由度为 $\\nu$、尺度参数为 $\\sigma$ 的学生t分布，并令残差为 $r(t) = d_{\\mathrm{pred}}(t) - d_{\\mathrm{obs}}(t)$，其中 $d_{\\mathrm{obs}}(t)$ 是观测数据。使用负对数似然公式作为误差。在迭代重加权最小二乘（IRLS）方法中，每个样本的权重函数定义为 $w(t) = \\dfrac{\\nu + 1}{\\nu + r(t)^2/\\sigma^2}$。\n\n任务：\n1. 从独立样本的学生t负对数似然出发，推导在接收点位置计算梯度时必须注入到伴随波方程中的伴随源时间序列 $s_{\\mathrm{adj}}(t)$ 的表达式。您的推导必须从基于似然的误差构建和链式法则的第一性原理出发，并将结果与上面提供的 IRLS 权重 $w(t)$ 联系起来。不要假设一个预先已知的伴随源公式；请推导它。\n2. 将推导出的伴随源与高斯噪声（最小二乘）的情况进行对比。将单个样本的影响函数定义为误差关于 $d_{\\mathrm{pred}}(t)$ 的导数，并分析其对于学生t分布和高斯噪声两种情况下对 $r(t)$ 的依赖性。根据影响函数在 $|r(t)|$ 增大时的有界性或增长性，解释其对离群值的稳健性。\n3. 实现一个程序，该程序为每个测试用例计算：\n   - 每个时间样本的 IRLS 权重 $w(t)$。\n   - 使用您推导的公式计算学生t伴随源时间序列 $s_{\\mathrm{adj}}^{\\mathrm{t}}(t)$。\n   - 从高斯噪声建模中获得的最小二乘伴随源 $s_{\\mathrm{adj}}^{\\mathrm{ls}}(t)$。\n   - 离群值抑制因子 $\\mathrm{SF}$，定义为在最大绝对残差的时间索引 $t_{\\mathrm{out}}$ 处，学生t情况与最小二乘情况的绝对伴随源振幅之比：\n     $$\\mathrm{SF} = \\dfrac{\\left|s_{\\mathrm{adj}}^{\\mathrm{t}}(t_{\\mathrm{out}})\\right|}{\\left|s_{\\mathrm{adj}}^{\\mathrm{ls}}(t_{\\mathrm{out}})\\right|}.$$\n     如果 $\\left|s_{\\mathrm{adj}}^{\\mathrm{ls}}(t_{\\mathrm{out}})\\right| = 0$，按约定定义 $\\mathrm{SF} = 1.0$。\n   - 全局范数比 $\\mathrm{NR}$，定义为学生t和最小二乘伴随源时间序列的欧几里得范数（平方和的平方根）之比：\n     $$\\mathrm{NR} = \\dfrac{\\left\\|s_{\\mathrm{adj}}^{\\mathrm{t}}\\right\\|_2}{\\left\\|s_{\\mathrm{adj}}^{\\mathrm{ls}}\\right\\|_2}.$$\n     如果 $\\left\\|s_{\\mathrm{adj}}^{\\mathrm{ls}}\\right\\|_2 = 0$，按约定定义 $\\mathrm{NR} = 1.0$。\n4. 程序应使用以下测试套件，其中所有残差都是无量纲的，且时间采样是均匀的：\n   - 测试用例 1：$\\nu = 3$，$\\sigma = 1.0$， $r(t) = [0.1, -0.2, 0.3, 5.0, -0.1]$。\n   - 测试用例 2：$\\nu = 1$，$\\sigma = 1.0$， $r(t) = [0.0, 0.0, 10.0, 0.0]$。\n   - 测试用例 3：$\\nu = 100$，$\\sigma = 1.0$， $r(t) = [0.5, -0.5, 3.0]$。\n   - 测试用例 4：$\\nu = 3$，$\\sigma = 1.0$， $r(t) = [0.0, 0.0]$。\n5. 对于每个测试用例，将 $\\mathrm{SF}$ 和 $\\mathrm{NR}$ 计算为实数（浮点数）。您的程序应生成一行输出，其中包含一个逗号分隔的列表形式的结果，该列表用方括号括起来，顺序为 $[\\mathrm{SF}_1, \\mathrm{NR}_1, \\mathrm{SF}_2, \\mathrm{NR}_2, \\mathrm{SF}_3, \\mathrm{NR}_3, \\mathrm{SF}_4, \\mathrm{NR}_4]$。\n\n由于残差是无量纲且归一化的，因此不需要物理单位。不涉及角度。\n\n您的最终答案必须是一个完整的、可运行的程序，该程序执行上述计算并生成指定的确切输出格式。",
            "solution": "该问题被评估为有效，它在计算地球物理学和统计优化方面具有科学依据，是适定的，并且内部一致。我们继续提供完整解答。\n\n按照要求，解答分为两部分。首先是理论推导和分析，然后是连接到最终计算代码的实现细节。\n\n**1. 学生t似然的伴随源推导**\n\n在全波形反演（FWI）中，用于梯度计算的伴随状态法需要一个伴随源项，该项是误差泛函 $\\mathcal{J}$ 关于预测数据 $d_{\\mathrm{pred}}(t)$ 的导数。我们已知误差是数据的负对数似然，假设噪声服从学生t分布。\n\n一个服从自由度为 $\\nu$、尺度参数为 $\\sigma$ 的学生t分布的随机变量 $x$ 的概率密度函数（PDF）由下式给出：\n$$\np(x | \\nu, \\sigma) = \\frac{\\Gamma\\left(\\frac{\\nu+1}{2}\\right)}{\\Gamma\\left(\\frac{\\nu}{2}\\right)\\sqrt{\\nu\\pi}\\sigma} \\left(1 + \\frac{x^2}{\\nu\\sigma^2}\\right)^{-\\frac{\\nu+1}{2}}\n$$\n其中 $\\Gamma$ 是伽马函数。\n\n我们将每个离散时间样本 $t$ 处的噪声建模为该分布的一个独立实现，其中变量 $x$ 是残差 $r(t) = d_{\\mathrm{pred}}(t) - d_{\\mathrm{obs}}(t)$。所有时间样本的总似然是各个概率的乘积，对数似然是其和：\n$$\n\\log \\mathcal{L} = \\sum_t \\log p(r(t) | \\nu, \\sigma)\n$$\n误差泛函 $\\mathcal{J}$ 是负对数似然：\n$$\n\\mathcal{J} = -\\log \\mathcal{L} = -\\sum_t \\left[ \\log(C) - \\frac{\\nu+1}{2} \\log\\left(1 + \\frac{r(t)^2}{\\nu\\sigma^2}\\right) \\right]\n$$\n其中 $C$ 是归一化常数，它不依赖于模型参数 $m$（通过 $d_{\\mathrm{pred}}(t)$ 和 $r(t)$）。在计算梯度时，这个常数项会消失。因此，我们考虑误差泛函：\n$$\n\\mathcal{J} = \\frac{\\nu+1}{2} \\sum_t \\log\\left(1 + \\frac{r(t)^2}{\\nu\\sigma^2}\\right)\n$$\n在特定时间 $t$ 的伴随源，记为 $s_{\\mathrm{adj}}(t)$，是 $\\mathcal{J}$ 关于相应预测数据样本 $d_{\\mathrm{pred}}(t)$ 的导数。由于求和是针对独立样本的，导数仅作用于该特定时间的项：\n$$\ns_{\\mathrm{adj}}^{\\mathrm{t}}(t) = \\frac{\\partial \\mathcal{J}}{\\partial d_{\\mathrm{pred}}(t)} = \\frac{\\partial}{\\partial d_{\\mathrm{pred}}(t)} \\left[ \\frac{\\nu+1}{2} \\log\\left(1 + \\frac{r(t)^2}{\\nu\\sigma^2}\\right) \\right]\n$$\n使用链式法则，并注意到 $\\frac{\\partial r(t)}{\\partial d_{\\mathrm{pred}}(t)} = \\frac{\\partial}{\\partial d_{\\mathrm{pred}}(t)} (d_{\\mathrm{pred}}(t) - d_{\\mathrm{obs}}(t)) = 1$，我们得到：\n$$\ns_{\\mathrm{adj}}^{\\mathrm{t}}(t) = \\frac{\\nu+1}{2} \\cdot \\frac{1}{1 + \\frac{r(t)^2}{\\nu\\sigma^2}} \\cdot \\frac{\\partial}{\\partial r(t)}\\left( \\frac{r(t)^2}{\\nu\\sigma^2} \\right) \\cdot \\frac{\\partial r(t)}{\\partial d_{\\mathrm{pred}}(t)}\n$$\n$$\ns_{\\mathrm{adj}}^{\\mathrm{t}}(t) = \\frac{\\nu+1}{2} \\cdot \\frac{1}{\\frac{\\nu\\sigma^2 + r(t)^2}{\\nu\\sigma^2}} \\cdot \\frac{2r(t)}{\\nu\\sigma^2} \\cdot 1\n$$\n化简该表达式得到学生t误差的伴随源：\n$$\ns_{\\mathrm{adj}}^{\\mathrm{t}}(t) = \\frac{(\\nu+1)r(t)}{\\nu\\sigma^2 + r(t)^2}\n$$\n问题提供了迭代重加权最小二乘（IRLS）的权重函数 $w(t) = \\dfrac{\\nu + 1}{\\nu + r(t)^2/\\sigma^2}$。我们可以用 $w(t)$ 来表示我们推导出的伴随源：\n$$\ns_{\\mathrm{adj}}^{\\mathrm{t}}(t) = \\frac{(\\nu+1)r(t)}{\\nu\\sigma^2 + r(t)^2} = \\frac{1}{\\sigma^2} \\cdot \\frac{(\\nu+1)r(t)}{\\nu + r(t)^2/\\sigma^2} = \\frac{w(t)r(t)}{\\sigma^2}\n$$\n这种关系表明，伴随源是经过函数 $w(t)$ 加权（并由 $1/\\sigma^2$ 缩放）的残差 $r(t)$。权重 $w(t)$ 对于小残差值较大，并随着残差大小的增加而减小，这就是其稳健性的机制。\n\n**2. 与高斯噪声（最小二乘）的比较及稳健性分析**\n\n对于标准最小二乘（L2）误差，假设噪声服从零均值的高斯分布。误差泛函与残差平方和成正比：\n$$\n\\mathcal{J}_{\\mathrm{ls}} = \\frac{1}{2} \\sum_t r(t)^2\n$$\n相应的伴随源 $s_{\\mathrm{adj}}^{\\mathrm{ls}}(t)$ 是它关于 $d_{\\mathrm{pred}}(t)$ 的导数：\n$$\ns_{\\mathrm{adj}}^{\\mathrm{ls}}(t) = \\frac{\\partial \\mathcal{J}_{\\mathrm{ls}}}{\\partial d_{\\mathrm{pred}}(t)} = \\frac{\\partial}{\\partial d_{\\mathrm{pred}}(t)} \\left( \\frac{1}{2}r(t)^2 \\right) = r(t) \\cdot \\frac{\\partial r(t)}{\\partial d_{\\mathrm{pred}}(t)} = r(t)\n$$\n因此，对于最小二乘情况，伴随源就是残差本身。\n\n问题将影响函数 $\\psi(r(t))$ 定义为误差关于数据样本的导数，这恰好就是伴随源。\n-   **高斯/最小二乘影响函数：** $\\psi_{\\mathrm{ls}}(r(t)) = s_{\\mathrm{adj}}^{\\mathrm{ls}}(t) = r(t)$。\n-   **学生t影响函数：** $\\psi_{\\mathrm{t}}(r(t)) = s_{\\mathrm{adj}}^{\\mathrm{t}}(t) = \\frac{(\\nu+1)r(t)}{\\nu\\sigma^2 + r(t)^2}$。\n\n**稳健性分析：**\n对离群值的稳健性是通过考察当残差大小 $|r(t)|$ 变得很大时影响函数的行为来分析的。\n\n-   对于**高斯**情况，$\\psi_{\\mathrm{ls}}(r(t))$ 是 $r(t)$ 的一个线性函数。它是**无界的**：当 $|r(t)| \\to \\infty$ 时， $|\\psi_{\\mathrm{ls}}(r(t))| \\to \\infty$。这意味着一个大的残差（一个离群值）会对梯度施加一个成比例的大影响，可能破坏模型更新并使反演不稳定。\n\n-   对于**学生t**情况，影响函数是**有界的**。要看到这一点，我们考察它在大残差时的极限：\n    $$\n    \\lim_{|r(t)| \\to \\infty} |\\psi_{\\mathrm{t}}(r(t))| = \\lim_{|r(t)| \\to \\infty} \\left|\\frac{(\\nu+1)r(t)}{\\nu\\sigma^2 + r(t)^2}\\right| = \\lim_{|r(t)| \\to \\infty} \\frac{(\\nu+1)|r(t)|}{r(t)^2} = \\lim_{|r(t)| \\to \\infty} \\frac{\\nu+1}{|r(t)|} = 0\n    $$\n    学生t分布的影响函数最初随 $|r(t)|$ 增长，但对于非常大的残差，它会衰减至零。这一特性使得该方法具有稳健性：离群值被自动降低权重，它们对梯度的影响被抑制。对于小的 $\\nu$（例如，对于柯西分布 $\\nu=1$），这种抑制作用非常强。当 $\\nu \\to \\infty$ 时，学生t分布趋近于高斯分布，其影响函数 $\\psi_{\\mathrm{t}}(r(t)) \\to r(t)/\\sigma^2$，这恢复了最小二乘情况的线性行为（相差一个缩放因子）。\n\n**3. 实现公式**\n\n程序将为每个测试用例实现以下计算：\n-   **学生t伴随源：** $s_{\\mathrm{adj}}^{\\mathrm{t}}(t) = \\frac{(\\nu+1)r(t)}{\\nu\\sigma^2 + r(t)^2}$\n-   **最小二乘伴随源：** $s_{\\mathrm{adj}}^{\\mathrm{ls}}(t) = r(t)$\n-   **离群值抑制因子（SF）：** $\\mathrm{SF} = \\dfrac{\\left|s_{\\mathrm{adj}}^{\\mathrm{t}}(t_{\\mathrm{out}})\\right|}{\\left|s_{\\mathrm{adj}}^{\\mathrm{ls}}(t_{\\mathrm{out}})\\right|}$，其中 $t_{\\mathrm{out}}$ 是最大绝对残差的索引。如果分母为 $0$，则 $\\mathrm{SF}=1.0$。\n-   **全局范数比（NR）：** $\\mathrm{NR} = \\dfrac{\\left\\|s_{\\mathrm{adj}}^{\\mathrm{t}}\\right\\|_2}{\\left\\|s_{\\mathrm{adj}}^{\\mathrm{ls}}\\right\\|_2}$，其中 $\\|\\cdot\\|_2$ 是欧几里得（$L_2$）范数。如果分母为 $0$，则 $\\mathrm{NR}=1.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required or permitted.\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating outlier suppression factors (SF) and\n    norm ratios (NR) for several test cases comparing Student-t and\n    Least-Squares adjoint sources in Full-Waveform Inversion.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (nu, sigma, r)\n        (3, 1.0, [0.1, -0.2, 0.3, 5.0, -0.1]),\n        (1, 1.0, [0.0, 0.0, 10.0, 0.0]),\n        (100, 1.0, [0.5, -0.5, 3.0]),\n        (3, 1.0, [0.0, 0.0]),\n    ]\n\n    results = []\n    for nu, sigma, r_list in test_cases:\n        # Convert residual list to a numpy array for vectorized operations.\n        r = np.array(r_list, dtype=np.float64)\n\n        # --- Calculate Adjoint Sources ---\n        # Least-squares adjoint source is simply the residual.\n        s_adj_ls = r\n\n        # Student-t adjoint source, using the derived formula.\n        numerator_t = (nu + 1) * r\n        denominator_t = nu * sigma**2 + r**2\n        # Handle division by zero for cases where r[i] might be zero,\n        # though the denominator is only zero if nu=0 and r=0, not an issue here.\n        s_adj_t = numerator_t / denominator_t\n        \n        # --- Calculate Outlier Suppression Factor (SF) ---\n        # Find the index of the largest absolute residual.\n        if r.size == 0 or np.all(r == 0):\n            # Handle case with no residuals or all-zero residuals\n            t_outlier_idx = 0\n            s_adj_ls_at_outlier = 0.0\n        else:\n            t_outlier_idx = np.argmax(np.abs(r))\n            s_adj_ls_at_outlier = s_adj_ls[t_outlier_idx]\n        \n        s_adj_t_at_outlier = s_adj_t[t_outlier_idx]\n\n        # Compute SF with the special convention for zero denominator.\n        if np.abs(s_adj_ls_at_outlier) == 0.0:\n            sf = 1.0\n        else:\n            sf = np.abs(s_adj_t_at_outlier) / np.abs(s_adj_ls_at_outlier)\n        \n        results.append(sf)\n\n        # --- Calculate Global Norm Ratio (NR) ---\n        # Compute the L2 norm (Euclidean norm) of both adjoint source time series.\n        norm_ls = np.linalg.norm(s_adj_ls)\n        norm_t = np.linalg.norm(s_adj_t)\n\n        # Compute NR with the special convention for zero denominator.\n        if norm_ls == 0.0:\n            nr = 1.0\n        else:\n            nr = norm_t / norm_ls\n\n        results.append(nr)\n\n    # Final print statement in the exact required format.\n    # The format [SF1,NR1,SF2,NR2,...] is achieved by flattening the results list.\n    print(f\"[{','.join(f'{x:.7f}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}