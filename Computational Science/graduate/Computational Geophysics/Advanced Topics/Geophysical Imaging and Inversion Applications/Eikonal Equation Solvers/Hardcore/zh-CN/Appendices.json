{
    "hands_on_practices": [
        {
            "introduction": "第一个实践练习将聚焦于任何基于网格的程函方程求解器的基本计算单元：单节点更新。在构建一个能够遍历整个区域的完整求解器之前，您必须首先掌握如何利用已知邻近点的信息来计算一个点的走时。本练习  将引导您推导并实现经典的上风格式有限差分公式，并强调了基于局部波前几何形状来区分单边（线性）更新和双边（二次）更新的关键。",
            "id": "3588075",
            "problem": "考虑由程函方程 (Eikonal equation) 控制的各向同性初至波地震走时。在二维空间中，该方程指出走时场的空间梯度的欧几里得范数等于局部慢度：$$\\lVert \\nabla T(x,y) \\rVert = s(x,y).$$ 在计算地球物理学中，可以使用在均匀间距的笛卡尔网格上采用单边、迎风有限差分的单调、因果离散化方法来构建局部单节点更新。设二维笛卡尔网格间距是均匀的，即 $$\\Delta x = \\Delta y = h>0$$，并假设我们仅使用左侧和下方的已接受邻居节点 $$a = T_{i-1,j}$$ 和 $$b = T_{i,j-1}$$ 以及局部慢度 $$s_{i,j} > 0$$ 来更新单个网格节点 $$T_{i,j}$$。该更新必须与程函方程的 Godunov 型迎风离散化方案一致，该方案能保持单调性和因果性，并且不得违反物理约束。\n\n从基本关系 $$\\lVert \\nabla T \\rVert = s$$ 和慢度定义 $$s = 1/v$$（其中 $$v$$ 是波速）出发，推导一个用于 $$T_{i,j}$$ 的离散、分段一致的局部更新公式，该公式使用 $$a, b, s_{i,j}, h$$，并确保更新遵循解的迎风特性。在一个程序中实现这个单节点更新，并将其应用于以下测试组。所有走时必须以秒为单位报告，所有给定的间距必须以米为单位，慢度值必须以秒/米为单位。\n\n该测试组包含五个参数集，每个参数集指定为 $$\\left(h, s_{i,j}, a, b\\right)$$:\n- 测试 1 (平衡邻居，预期双向贡献): $$\\left(10,\\,0.1,\\,0,\\,0\\right).$$\n- 测试 2 (强单向主导，预期线性更新): $$\\left(10,\\,0.2,\\,0,\\,5\\right).$$\n- 测试 3 (一般情况，双向贡献): $$\\left(1,\\,3,\\,3,\\,4\\right).$$\n- 测试 4 (分支阈值处的边界情况): $$\\left(1,\\,2,\\,1,\\,3\\right).$$\n- 测试 5 (邻居值近乎相等，慢度小): $$\\left(0.5,\\,0.01,\\,10,\\,10\\right).$$\n\n您的程序必须使用从第一性原理推导出的单节点更新方法，计算这些参数集的五个更新值 $$T_{i,j}$$（单位为秒），并将它们打印为单行，形式为方括号内包含的逗号分隔列表。每个值必须四舍五入到八位小数，例如 $$[t_1,t_2,t_3,t_4,t_5]$$ 其中 $$t_k$$ 的单位为秒。",
            "solution": "经评估，该问题陈述是有效的。它在科学上基于波传播物理学和偏微分方程的数值分析。该问题是适定的、客观的，并包含推导所要求的程函方程局部更新公式并将其应用于给定测试用例所需的所有信息。未发现矛盾、歧义或事实错误。\n\n走时 $T_{i,j}$ 的单节点更新公式的推导从二维程函方程开始：\n$$\n\\lVert \\nabla T(x,y) \\rVert^2 = \\left(\\frac{\\partial T}{\\partial x}\\right)^2 + \\left(\\frac{\\partial T}{\\partial y}\\right)^2 = s(x,y)^2\n$$\n此处，$T(x,y)$ 是走时场，$s(x,y)$ 是慢度（速度的倒数）。问题要求在均匀间距 $h = \\Delta x = \\Delta y$ 的笛卡尔网格上使用单调且因果的迎风有限差分格式。我们使用已知的、已接受的来自左邻居 $a = T_{i-1,j}$ 和下邻居 $b = T_{i,j-1}$ 的走时来更新节点 $T_{i,j}$。对于在局部 $ij$ 坐标系第一象限传播的波，该格式的迎风性质意味着偏导数应使用后向差分来近似：\n$$\n\\frac{\\partial T}{\\partial x} \\approx \\frac{T_{i,j} - T_{i-1,j}}{h} = \\frac{T_{i,j} - a}{h}\n$$\n$$\n\\frac{\\partial T}{\\partial y} \\approx \\frac{T_{i,j} - T_{i,j-1}}{h} = \\frac{T_{i,j} - b}{h}\n$$\n因果性原理规定，一个节点的走时不能小于其任何上游邻居节点的走时。因此，任何有效的解都必须满足 $T_{i,j} \\ge a$ 和 $T_{i,j} \\ge b$。\n\n一个稳健的 Godunov 型程函方程格式通过使用 $\\max$ 算子来考虑信息流动的方向，对于这种特定的迎风配置，该格式变为：\n$$\n\\left(\\max\\left(\\frac{T_{i,j} - a}{h}, 0\\right)\\right)^2 + \\left(\\max\\left(\\frac{T_{i,j} - b}{h}, 0\\right)\\right)^2 = s_{i,j}^2\n$$\n令 $T = T_{i,j}$ 且 $s = s_{i,j}$。为求解 $T$，我们必须根据邻居节点的贡献考虑两种情况。\n\n情况 1：邻居节点 $a$ 和 $b$ 都对更新有贡献。\n这种情况对应于波前从对角线方向到达。我们假设解 $T$ 将大于 $a$ 和 $b$。在这种情况下，$T-a>0$ 且 $T-b>0$，因此 $\\max$ 算子是多余的，方程简化为：\n$$\n\\left(\\frac{T - a}{h}\\right)^2 + \\left(\\frac{T - b}{h}\\right)^2 = s^2\n$$\n展开此方程得到一个关于 $T$ 的二次方程：\n$$\n(T-a)^2 + (T-b)^2 = (sh)^2\n$$\n$$\nT^2 - 2aT + a^2 + T^2 - 2bT + b^2 - (sh)^2 = 0\n$$\n$$\n2T^2 - 2(a+b)T + (a^2+b^2-(sh)^2) = 0\n$$\n使用二次公式 $T = \\frac{-B \\pm \\sqrt{B^2 - 4AC}}{2A}$，其中 $A=2$，$B=-2(a+b)$，$C=a^2+b^2-(sh)^2$，我们求得解。我们必须选择较大的根以满足因果性 ($T > a, T > b$)：\n$$\nT = \\frac{2(a+b) + \\sqrt{4(a+b)^2 - 8(a^2+b^2-(sh)^2)}}{4}\n$$\n$$\nT = \\frac{a+b + \\sqrt{(a+b)^2 - 2(a^2+b^2-(sh)^2)}}{2}\n$$\n$$\nT = \\frac{a+b + \\sqrt{2(sh)^2 - (a-b)^2}}{2}\n$$\n这个公式是在 $T > \\max(a, b)$ 的假设下推导的，只有当其结果实际满足此条件时，它才是自洽的。设 $t_{max} = \\max(a, b)$。条件 $T \\ge t_{max}$ 当且仅当以下不等式成立时才成立：\n$$\n\\frac{a+b + \\sqrt{2(sh)^2 - (a-b)^2}}{2} \\ge \\max(a, b)\n$$\n这个不等式简化为 $\\sqrt{2(sh)^2 - (a-b)^2} \\ge |a-b|$，两边平方（因为两边都非负，所以是允许的）后得到 $2(sh)^2 - (a-b)^2 \\ge (a-b)^2$，最终得到：\n$$\n|a-b| \\le sh\n$$\n\n情况 2：只有一个邻居节点对更新有贡献。\n当条件 $|a-b| \\le sh$ 不满足时，即 $|a-b| > sh$ 时，会发生这种情况。这在物理上意味着波前几乎平行于其中一个网格轴到达。二次公式不再满足因果性，这意味着我们最初的假设之一，即 $T-a>0$ 或 $T-b>0$，在组合更新的背景下必定是错误的。在 Godunov 格式中的正确解释是，更新由具有最小走时的邻居主导，我们称之为 $t_{min} = \\min(a, b)$。另一个邻居 $t_{max} = \\max(a,b)$ 的贡献为零。离散化的程函方程退化为一维形式：\n$$\n\\left(\\frac{T - t_{min}}{h}\\right)^2 = s^2\n$$\n求解 $T$（并选择满足因果性的根 $T > t_{min}$）得到一个简单的线性更新：\n$$\nT = t_{min} + sh\n$$\n这个线性更新与条件 $|a-b| > sh$ 是一致的，因为它产生的解 $T$ 满足 $T - t_{max} = t_{min} + sh - t_{max} = sh - (t_{max}-t_{min}) = sh - |a-b|  0$，从而验证了 $\\max\\left(\\frac{T-t_{max}}{h}, 0\\right)=0$ 的假设。\n\n分段一致更新公式总结：\n给定输入 $h, s, a, b$，更新后的走时 $T$ 计算如下：\n1. 如果 $|a - b| \\ge sh$，则更新是一维的：\n   $$\n   T = \\min(a, b) + sh\n   $$\n2. 如果 $|a - b|  sh$，则更新是二维的：\n   $$\n   T = \\frac{a+b + \\sqrt{2(sh)^2 - (a-b)^2}}{2}\n   $$\n注意，在边界 $|a-b| = sh$ 处，两个公式产生相同的结果，确保了一致性。\n\n将使用这个推导出的算法应用于测试组。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies a single-node upwind finite-difference update for the\n    Eikonal equation to a suite of test cases.\n    \"\"\"\n    \n    # The test suite consists of five parameter sets, each specified as\n    # (h, s_ij, a, b).\n    # h: grid spacing in meters\n    # s_ij: local slowness in seconds/meter\n    # a: traveltime at neighbor (i-1,j) in seconds\n    # b: traveltime at neighbor (i,j-1) in seconds\n    test_cases = [\n        # (h, s_ij, a, b)\n        (10, 0.1, 0, 0),    # Test 1: balanced neighbors, two-direction contribution\n        (10, 0.2, 0, 5),    # Test 2: strong one-direction dominance, linear update\n        (1, 3, 3, 4),       # Test 3: general case, two-direction contribution\n        (1, 2, 1, 3),       # Test 4: boundary case at the branch threshold\n        (0.5, 0.01, 10, 10),# Test 5: nearly equal neighbors, small slowness\n    ]\n\n    results = []\n    \n    def calculate_traveltime_update(h, s, a, b):\n        \"\"\"\n        Calculates the updated traveltime T_ij for a single node using a\n        piecewise-consistent upwind finite difference scheme.\n\n        The scheme is derived from the Godunov-type discretization of the\n        Eikonal equation:\n        (max((T-a)/h, 0))^2 + (max((T-b)/h, 0))^2 = s^2\n\n        Args:\n            h (float): Grid spacing.\n            s (float): Local slowness.\n            a (float): Traveltime at neighbor T_{i-1,j}.\n            b (float): Traveltime at neighbor T_{i,j-1}.\n\n        Returns:\n            float: The updated traveltime T_{i,j}.\n        \"\"\"\n        sh = s * h\n        \n        # The choice between the 1D and 2D update depends on whether the\n        # wavefront is better approximated as planar along a grid axis or\n        # arriving from a diagonal direction. This is determined by comparing\n        # the traveltime difference between neighbors to the time it takes\n        # for a wave to travel one grid cell.\n        if np.abs(a - b) = sh:\n            # Case 1: 1D (linear) update.\n            # The update is dominated by the neighbor with the smaller traveltime.\n            # This corresponds to a wavefront arriving nearly parallel to an axis.\n            # Formula: T = min(a,b) + s*h\n            t_min = min(a, b)\n            t_new = t_min + sh\n        else:\n            # Case 2: 2D (quadratic) update.\n            # Both neighbors contribute. This corresponds to a wavefront arriving\n            # from a more diagonal direction.\n            # Formula: T = (a+b + sqrt(2*(s*h)^2 - (a-b)^2))/2\n            discriminant = 2 * (sh**2) - (a - b)**2\n            # The discriminant is guaranteed to be non-negative due to the\n            # condition |a-b|  sh.\n            t_new = (a + b + np.sqrt(discriminant)) / 2\n            \n        return t_new\n\n    for case in test_cases:\n        h_val, s_val, a_val, b_val = case\n        updated_t = calculate_traveltime_update(h_val, s_val, a_val, b_val)\n        # Format the result to eight decimal places as specified.\n        results.append(f\"{updated_t:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了单节点更新规则后，下一步是将其组织成一个完整且高效的、遵循因果律的算法。本实践练习  将介绍快速行进法（Fast Marching Method, FMM），这是一种强大的类Dijkstra算法，它通过从震源向外传播信息来确保网格更新的正确顺序。您将从头开始实现一个完整的多震源FMM求解器，并分析不同震源如何根据初至波走时将区域划分为类似Voronoi图的单元。",
            "id": "3588118",
            "problem": "您的任务是设计并实现一个数值求解器，用于求解各向同性程函方程，以计算均匀二维笛卡尔网格上的多源走时场，并识别出定义域中各个点源依赖区域的类 Voronoi 划分。此任务的基础是高频极限下的几何光学，其中沿曲线的走时是可加的，且射线使走时取极值。这导出了各向同性程函方程的 Hamilton–Jacobi 形式。问题必须在矩形网格上以纯数学方式求解，并为所有物理量指定明确的物理单位。\n\n起点与定义。考虑一个有界矩形域，该域在两个方向上都以间距 $h$ 的均匀网格进行离散化。设 $v(x,y)$ 表示定义域上的一个各向同性速度场，其值为严格正且有界，单位为米/秒。对于一个有限的点源集合 $\\{x_s^{(i)}\\}_{i=1}^M$，多源走时 $T(x,y)$ 满足程函方程\n$$\n\\lvert \\nabla T(x,y) \\rvert \\;=\\; \\frac{1}{v(x,y)} \\quad \\text{in the domain,}\n$$\n边界条件为 Dirichlet 条件 $T(x_s^{(i)}) = 0$，适用于所有源 $i \\in \\{1,\\dots,M\\}$。源 $i$ 的依赖域（类 Voronoi 单元）是指在所有源中，由源 $i$ 实现最小到达时间的点的集合。\n\n算法要求。您必须从第一性原理出发，为程函方程推导出一个迎风、单调的离散化格式，该格式适用于类似 Dijkstra 的接受顺序（即，一种基于递增走时的单遍方法）。您的求解器必须：\n- 仅使用局部迎风信息，根据已接受的邻居节点来更新网格节点的走时。\n- 通过始终从最小优先队列中接受当前最小的试探走时来保证因果性。\n- 通过将所有源节点的走时初始化为零，并传播一个标签场来识别每个已接受节点所依赖的源，从而正确处理多个源。如果两个或多个源在某个节点处产生的走时在很小的容差范围内完全相等，则通过选择最小的源索引来确定性地决胜。\n- 在网格上使用四邻域连接。\n- 当 $v$ 的单位是米/秒，网格坐标的单位是米时，生成的走时 $T$ 的单位应为秒。\n\n您的程序必须实现该求解器，并为以下测试套件生成答案。在所有情况下，定义域均为 $[0,1]\\times[0,1]$ 米，通过 $N \\times N$ 个网格点进行离散化，其中 $N=101$，因此网格间距为 $h = 1/(N-1)$ 米。网格点坐标位于 $(x_i,y_j) = (i h, j h)$，其中整数 $i,j \\in \\{0,\\dots,N-1\\}$。所有角度（如有）必须以弧度为单位，但该问题中未明确出现角度。\n\n测试套件：\n1. 恒定速度、单源精度。设 $v(x,y) \\equiv 2.0$ 米/秒。在 $(x_s,y_s) = (0.25,0.5)$ 米处放置一个单源，定位在最近的网格点上。计算数值走时场 $T_{\\text{num}}$。对于此恒定速度情况，解析解为 $T_{\\text{ana}}(x,y) = \\sqrt{(x-x_s)^2 + (y-y_s)^2} / 2.0$ 秒。计算最大绝对误差 $E_{\\infty} = \\max_{i,j} \\lvert T_{\\text{num}}(x_i,y_j) - T_{\\text{ana}}(x_i,y_j) \\rvert$（单位：秒）。\n2. 恒定速度、双源划分平衡性。设 $v(x,y) \\equiv 2.0$ 米/秒。在 $(x_s^{(1)},y_s^{(1)}) = (0.10,0.50)$ 米和 $(x_s^{(2)},y_s^{(2)}) = (0.90,0.50)$ 米处放置两个源，每个都定位在最近的网格点上。计算标签场 $\\ell(x_i,y_j) \\in \\{0,1\\}$，该场识别出在每个网格点上产生最小到达时间的源，其中平局则倾向于最小索引。计算标记为 $\\ell=0$ 的网格点比例 $f_0$。报告绝对偏差 $\\lvert f_0 - 0.5 \\rvert$（一个无量綱的小数）。\n3. 非均匀速度下划分的尺度不变性。设基准速度场为 $v(x,y) = 2.0$ 米/秒，但在以 $(0.35,0.50)$ 米为中心、半径为 $0.15$ 米的圆盘内部区域，$v(x,y) = 0.5$ 米/秒。在 $(x_s^{(1)},y_s^{(1)}) = (0.10,0.50)$ 米和 $(x_s^{(2)},y_s^{(2)}) = (0.90,0.50)$ 米处放置两个源，每个都定位在最近的网格点上。计算基准速度 $v$ 对应的标签场 $\\ell_{\\text{base}}$。然后定义一个缩放后的速度场 $v'(x,y) = \\alpha v(x,y)$，其中 $\\alpha = 3.7$（无量纲），并计算 $v'$ 下的标签场 $\\ell_{\\text{scaled}}$。报告一个布尔值，指示 $\\ell_{\\text{base}}$ 和 $\\ell_{\\text{scaled}}$ 在所有网格点上是否完全相同。\n\n最终输出格式。您的程序必须生成单行输出，其中包含三个测试用例的结果，格式为方括号括起来的逗号分隔列表，顺序如下：$[E_{\\infty}, \\lvert f_0 - 0.5 \\rvert, \\text{label\\_invariance}]$。第一个数字 $E_{\\infty}$ 必须以秒为单位表示并四舍五入到六位小数，第二个数字 $\\lvert f_0 - 0.5 \\rvert$ 必须四舍五入到六位小数，第三个值必须是字面布尔标记 True 或 False。例如，输出格式必须类似于 $[0.003127,0.000000,True]$。",
            "solution": "在笛卡尔网格上计算多源走时场的问题，是求解程函方程的经典应用，而程函方程是几何光学和计算地球物理学的基石。解决方案要求推导一个数值格式，并实现一个遵循因果性的高效求解器。\n\n控制方程是各向同性程函方程：\n$$\n|\\nabla T(x,y)| = \\frac{1}{v(x,y)} = s(x,y)\n$$\n这里，$T(x,y)$ 是走时场（单位：秒），$v(x,y)$ 是波速（单位：米/秒），$s(x,y)$ 是慢度（单位：秒/米）。该方程是一个 Hamilton-Jacobi 类型的非线性偏微分方程。边界条件由一组源 $\\{x_s^{(i)}\\}$ 给出，为 $T(x_s^{(i)}) = 0$。多源走时场是来自任意源的最小到达时间，$T(x,y) = \\min_i T_i(x,y)$，其中 $T_i$ 是从源 $i$ 出发的走时。\n\n核心物理原理是因果性：某一点的走时只能由走时更小的点确定。这启发了一种计算顺序，即信息从源向外传播，很像 Huygens 原理。快速行进法（Fast Marching Method, FMM）就是为此设计的。它是一种基于网格的算法，使用类似 Dijkstra 的方法在单遍计算中求解程函方程。网格点被分为三类：\n1.  **已接受（Accepted 或 Frozen）**：已计算出最终走时的点。\n2.  **试探（Trial 或 Narrow Band）**：与已接受点集相邻的点，已为其计算出试探走时。这些点是待接受的候选点。\n3.  **未访问（Unseen 或 Far Away）**：所有其他点，其走时被初始化为无穷大。\n\nFMM 算法维护一个由试探点组成的最小优先队列，这些点按其试探走时排序。算法的流程是：重复地接受具有最小走时的试探点，将其移至已接受集合，然后更新其未访问或试探邻居的走时。\n\n为了推导更新规则，我们在间距为 $h$ 的均匀网格上对程函方程进行离散化。为保证稳定性和遵循因果性，必须采用迎风、一阶有限差分格式。在网格点 $(i,j)$ 处，梯度平方 $|\\nabla T|^2 = (\\partial T/\\partial x)^2 + (\\partial T/\\partial y)^2$ 近似为：\n$$\n\\left(\\max\\left( \\frac{T_{i,j}-T_{i-1,j}}{h}, \\frac{T_{i,j}-T_{i+1,j}}{-h}, 0 \\right)\\right)^2 + \\left(\\max\\left( \\frac{T_{i,j}-T_{i,j-1}}{h}, \\frac{T_{i,j}-T_{i,j+1}}{-h}, 0 \\right)\\right)^2 = s_{i,j}^2\n$$\n在 FMM 中，当我们更新 $T_{i,j}$ 时，我们只使用来自走时更小的、已接受邻居的信息。令 $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $T_y = \\min(T_{i,j-1}, T_{i,j+1})$ 分别为 $x$ 和 $y$ 方向上已接受邻居中的最小走时。由于我们预期 $T_{i,j}$ 会比其已接受邻居的走时更大，方程简化为：\n$$\n\\left(\\frac{T_{i,j}-T_x}{h}\\right)^2 + \\left(\\frac{T_{i,j}-T_y}{h}\\right)^2 = s_{i,j}^2\n$$\n这是一个关于新时间 $T = T_{i,j}$ 的二次方程：$aT^2 + bT + c = 0$，其中 $a=2$，$b=-2(T_x+T_y)$，$c=T_x^2+T_y^2-(hs_{i,j})^2$。取较大的根（对应于向外传播）可得：\n$$\nT = \\frac{T_x+T_y+\\sqrt{2(hs_{i,j})^2 - (T_x-T_y)^2}}{2}\n$$\n只有当波前从涉及两个坐标轴的方向到达时，这种二维更新才具有物理意义。一个简单而稳健的条件是将一维更新时间与较远邻居的走时进行比较。令 $T_1 = \\min(T_x, T_y)$ 且 $T_2 = \\max(T_x, T_y)$。如果波前纯粹从 $T_1$ 的方向传播，更新将是 $T = T_1 + hs_{i,j}$。如果这个一维更新后的时间小于或等于 $T_2$，这意味着来自 $T_2$ 邻居的特征线没有到达点 $(i,j)$，因此一维更新是合适的。因此，更新规则如下：\n1.  如果只有一个方向（例如 $x$ 方向）的邻居被接受，使用一维更新：$T = T_x + hs_{i,j}$。\n2.  如果两个方向的邻居都已被接受，令 $T_1=\\min(T_x, T_y)$ 和 $T_2=\\max(T_x, T_y)$。\n    - 如果 $T_2 - T_1 \\ge hs_{i,j}$，使用一维更新：$T = T_1 + hs_{i,j}$。\n    - 否则，使用上述的二维二次方程解。\n\n为了处理多个源并确定类 Voronoi 划分，我们修改 FMM 以跟踪每个传播波前的来源。我们用所有源位置来初始化优先队列，每个源的走时都为零。优先队列中的项变为 `(time, source_index, i, j)` 形式的元组。Python 的 `heapq` 库在处理此类元组时，会首先按时间排序，然后使用 `source_index` 作为决胜条件。这优雅且正确地实现了指定的决胜规则。当一个节点被接受时，它的走时及其对特定源的依赖关系（即其标签）被同时最终确定。已接受节点的标签随后在其邻居节点的更新步骤中被传播出去。这种集成方法通过一次高效的单遍计算，即可计算出最小走时场和源依赖划分。\n\n测试用例验证了三个关键方面：\n1.  **精度**：在恒定速度介质中与解析解进行比较，以检查数值格式的正确性和收敛阶。\n2.  **划分**：在恒定速度介质中的对称双源问题测试了多源逻辑和决胜规则。由于对称性，定义域应几乎被平分，任何偏差都源于离散网格和确定性的决胜规则。\n3.  **不变性**：程函方程具有尺度对称性。如果慢度场按常数比例缩放，$s'(x,y) = s(x,y)/\\alpha$，则走时也按相同比例缩放，$T'(x,y) = T(x,y)/\\alpha$。然而，作为最小走时路径的射线路径保持不变。因此，基于初至波时间的类 Voronoi 划分对于 $v(x,y)$ 和 $v'(x,y) = \\alpha v(x,y)$ 应该是完全相同的。此测试验证了解的一个基本物理性质。",
            "answer": "```python\nimport numpy as np\nimport heapq\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the eikonal solver.\n    \"\"\"\n\n    def run_fmm_solver(N, h, speed_field, sources_coords):\n        \"\"\"\n        Solves the isotropic eikonal equation for multiple sources on a 2D grid\n        using the Fast Marching Method (FMM).\n\n        Args:\n            N (int): Grid dimension (N x N).\n            h (float): Grid spacing in meters.\n            speed_field (np.ndarray): N x N array of wave speeds (m/s).\n            sources_coords (list): A list of (x, y) tuples for source locations in meters.\n\n        Returns:\n            tuple: A tuple containing:\n                - times (np.ndarray): N x N array of first-arrival travel times (s).\n                - labels (np.ndarray): N x N array of source indices for the first arrival.\n        \"\"\"\n        # State constants for grid points\n        ACCEPTED = 0\n        TRIAL = 1\n        UNSEEN = 2\n\n        # Initialize data structures\n        times = np.full((N, N), np.inf, dtype=np.float64)\n        labels = np.full((N, N), -1, dtype=np.int32)\n        states = np.full((N, N), UNSEEN, dtype=np.int8)\n        pq = []  # Min-priority queue\n\n        slowness_field = 1.0 / speed_field\n\n        # Initialize sources in the priority queue\n        for label_idx, (sx, sy) in enumerate(sources_coords):\n            i_s = int(round(sx / h))\n            j_s = int(round(sy / h))\n            \n            i_s = np.clip(i_s, 0, N - 1)\n            j_s = np.clip(j_s, 0, N - 1)\n\n            # In case multiple sources map to the same grid point, the one with the\n            # smaller index will be processed first due to tie-breaking in the heap.\n            if times[i_s, j_s]  0.0:\n                times[i_s, j_s] = 0.0\n                states[i_s, j_s] = TRIAL\n                heapq.heappush(pq, (0.0, label_idx, i_s, j_s))\n\n        # Main FMM loop\n        while pq:\n            time, label, i, j = heapq.heappop(pq)\n\n            if states[i, j] == ACCEPTED:\n                continue\n            \n            states[i, j] = ACCEPTED\n            labels[i, j] = label\n\n            # Propagate information to neighbors\n            for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                # Check boundary conditions and if neighbor is already accepted\n                if not (0 = ni  N and 0 = nj  N) or states[ni, nj] == ACCEPTED:\n                    continue\n\n                # Find minimum times of accepted neighbors in x and y directions\n                t_x_min = np.inf\n                if ni  0 and states[ni - 1, nj] == ACCEPTED:\n                    t_x_min = min(t_x_min, times[ni - 1, nj])\n                if ni  N - 1 and states[ni + 1, nj] == ACCEPTED:\n                    t_x_min = min(t_x_min, times[ni + 1, nj])\n                \n                t_y_min = np.inf\n                if nj  0 and states[ni, nj - 1] == ACCEPTED:\n                    t_y_min = min(t_y_min, times[ni, nj - 1])\n                if nj  N - 1 and states[ni, nj + 1] == ACCEPTED:\n                    t_y_min = min(t_y_min, times[ni, nj + 1])\n                \n                # Calculate time update based on available neighbors\n                hs = h * slowness_field[ni, nj]\n                t_new = np.inf\n\n                if t_x_min != np.inf and t_y_min != np.inf:\n                    t1, t2 = (t_x_min, t_y_min) if t_x_min  t_y_min else (t_y_min, t_x_min)\n                    if (t2 - t1)  hs:\n                        radicand = 2.0 * hs**2 - (t1 - t2)**2\n                        t_new = (t1 + t2 + math.sqrt(radicand)) / 2.0\n                    else:\n                        t_new = t1 + hs\n                elif t_x_min != np.inf:\n                    t_new = t_x_min + hs\n                elif t_y_min != np.inf:\n                    t_new = t_y_min + hs\n                \n                # If a shorter path to the neighbor is found, update it and push to queue\n                if t_new  times[ni, nj]:\n                    times[ni, nj] = t_new\n                    states[ni, nj] = TRIAL\n                    heapq.heappush(pq, (t_new, label, ni, nj))\n\n        return times, labels\n\n    N = 101\n    h = 1.0 / (N - 1)\n    results = []\n\n    # --- Test Case 1: Constant-speed, single source accuracy ---\n    v1 = 2.0\n    speed_field_1 = np.full((N, N), v1)\n    source_1_coord = (0.25, 0.5)\n    sources_1 = [source_1_coord]\n    \n    t_num_1, _ = run_fmm_solver(N, h, speed_field_1, sources_1)\n    \n    x_coords = np.linspace(0, 1, N)\n    y_coords = np.linspace(0, 1, N)\n    xx, yy = np.meshgrid(x_coords, y_coords, indexing='ij')\n    \n    t_ana_1 = np.sqrt((xx - source_1_coord[0])**2 + (yy - source_1_coord[1])**2) / v1\n    \n    e_inf = np.max(np.abs(t_num_1 - t_ana_1))\n    results.append(round(e_inf, 6))\n\n    # --- Test Case 2: Constant-speed, two sources partition balance ---\n    v2 = 2.0\n    speed_field_2 = np.full((N, N), v2)\n    sources_2 = [(0.10, 0.50), (0.90, 0.50)]\n    \n    _, labels_2 = run_fmm_solver(N, h, speed_field_2, sources_2)\n    \n    f0 = np.sum(labels_2 == 0) / (N * N)\n    dev_f0 = abs(f0 - 0.5)\n    results.append(round(dev_f0, 6))\n\n    # --- Test Case 3: Heterogeneous-speed scaling invariance of partition ---\n    v_bg = 2.0\n    v_slow = 0.5\n    disk_center = (0.35, 0.50)\n    disk_radius = 0.15\n    \n    speed_field_3_base = np.full((N, N), v_bg)\n    is_in_disk = (xx - disk_center[0])**2 + (yy - disk_center[1])**2 = disk_radius**2\n    speed_field_3_base[is_in_disk] = v_slow\n    \n    sources_3 = [(0.10, 0.50), (0.90, 0.50)]\n    \n    _, labels_base = run_fmm_solver(N, h, speed_field_3_base, sources_3)\n    \n    alpha = 3.7\n    speed_field_3_scaled = alpha * speed_field_3_base\n    _, labels_scaled = run_fmm_solver(N, h, speed_field_3_scaled, sources_3)\n    \n    label_invariance = np.array_equal(labels_base, labels_scaled)\n    results.append(label_invariance)\n\n    # Format and print final output\n    print(f\"[{results[0]},{results[1]},{results[2]}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的地球物理问题常常涉及复杂的地质构造，这些构造会成为波传播的障碍。最后一个实践练习  将您的FMM求解器扩展到处理此类情景，其中波必须围绕不可穿透的空洞区域发生绕射。通过整合这些拓扑约束，您将模拟“阴影区”的形成，并量化由此产生的走时延迟，从而深入理解对地震成像和解释至关重要的绕射现象。",
            "id": "3588086",
            "problem": "考虑二维空间中的各向同性初至波走时，它由程函方程控制。对于定义在域 $\\Omega \\subset \\mathbb{R}^2$ 上的标量走时场 $T(\\mathbf{x})$ 和速度场 $v(\\mathbf{x})$，该方程为\n$$\n\\lvert \\nabla T(\\mathbf{x}) \\rvert = \\frac{1}{v(\\mathbf{x})} \\quad \\text{for } \\mathbf{x} \\in \\Omega,\n$$\n在点源 $\\mathbf{x}_s \\in \\Omega$ 处，具有狄利克雷边界条件 $T(\\mathbf{x}_s)=0$。设子集 $\\mathcal{H} \\subset \\Omega$ 表示不可穿透的空洞（孔洞），并定义计算域 $D = \\Omega \\setminus \\mathcal{H}$。走时 $T(\\mathbf{x})$ 仅在 $D$ 上有定义，且特征线不能穿过 $\\partial \\mathcal{H}$。您将研究 $\\mathcal{H}$ 的拓扑结构如何产生阴影区，这些阴影区通过相对于均匀无障碍情况下的额外走时来进行量化。\n\n您必须实现一个基于迎风因果传播的求解器，该求解器与快速行进法（FMM）一致，使用网格间距为 $\\Delta x = \\Delta y = h$ 的均匀笛卡尔网格和四点模板，以计算 $D$ 上 $T(\\mathbf{x})$ 的近似值。从物理走时遵循最小化慢度路径积分的路径这一基本变分原理出发，并结合程函方程的定义，推导出一个严格迎风的局部更新公式，该公式在网格点上与梯度范数的单调离散化一致，并尊重因果性。不允许在孔洞内部进行更新；这些位置被排除在 $D$ 之外。\n\n定义均匀速度 $v(\\mathbf{x}) \\equiv v_0$（单位：米/秒）和方形域 $\\Omega = [0,L]\\times[0,L]$（单位：米）。使用位于 $\\mathbf{x}_s=(x_s,y_s)$ 的点源，其 $T(\\mathbf{x}_s)=0$。设探测点 $\\mathbf{x}_p=(x_p,y_p)$ 用于量化走时延迟。\n\n为量化孔洞造成的阴影效应，对于任意网格点 $\\mathbf{x}$，定义无障碍均匀基线\n$$\nT_{\\mathrm{free}}(\\mathbf{x}) = \\frac{\\|\\mathbf{x}-\\mathbf{x}_s\\|_2}{v_0},\n$$\n如果连接 $\\mathbf{x}_s$ 和 $\\mathbf{x}$ 的线段与 $\\mathcal{H}$ 中任何孔洞的内部相交，则称该网格点为视线受阻。对于给定的阈值 $\\delta$（单位：秒），定义阴影集\n$$\nS_{\\mathrm{shadow}} = \\left\\{ \\mathbf{x} \\in D \\,:\\, \\text{视线受阻且 } T(\\mathbf{x}) - T_{\\mathrm{free}}(\\mathbf{x}) \\ge \\delta \\text{ 且 } T(\\mathbf{x}) \\text{ 是有限的} \\right\\}。\n$$\n设阴影面积分数为 $S_{\\mathrm{shadow}}$ 中网格点的数量与 $D$ 中网格点数量之比。\n\n实现以下测试套件，所有距离单位为米，时间单位为秒：\n\n- 所有测试通用的网格和源参数：\n  - $L = 1000$， $h=10$，因此有 $N_x=N_y=101$ 个网格点，坐标为 $x_i=i\\,h$, $y_j=j\\,h$，其中整数 $i,j \\in \\{0,1,\\ldots,100\\}$。\n  - $v_0 = 2000\\,\\mathrm{m/s}$，因此慢度为 $1/v_0$ s/m。\n  - 源点位于 $\\mathbf{x}_s=(100,500)$，即网格索引 $(i_s,j_s)=(10,50)$。\n  - 探测点位于 $\\mathbf{x}_p=(800,500)$，即网格索引 $(i_p,j_p)=(80,50)$。\n  - 阈值 $\\delta=0.01$（秒）。\n\n- 测试用例 $1$（单个有限障碍物导致绕行但仍可达）：一个矩形孔洞 $\\mathcal{H}_1 = [450,550]\\times[400,600]$。\n\n- 测试用例 $2$（无障碍物基线）：$\\mathcal{H}_2 = \\varnothing$。\n\n- 测试用例 $3$（隔离墙造成不可达区域）：一个横跨整个域高度的垂直矩形孔洞，$\\mathcal{H}_3 = [450,550]\\times[0,1000]$。\n\n对于每个测试用例 $k \\in \\{1,2,3\\}$，计算：\n- 探测点的延迟（单位：秒），定义为 $D_k = T_k(\\mathbf{x}_p) - T_{\\mathrm{free}}(\\mathbf{x}_p)$，其中 $T_k$ 是测试 $k$ 的计算场。如果 $\\mathbf{x}_p$ 在测试 $k$ 中不可达，则使用 $+\\infty$ 表示 $T_k(\\mathbf{x}_p)$，此时 $D_k=+\\infty$。\n- 阴影面积分数 $F^{\\mathrm{shadow}}_k$，如上定义（无单位小数）。\n- 不可达分数 $F^{\\mathrm{unreach}}_k$，定义为 $D$ 中 $T_k$ 非有限的网格点数与 $D$ 中总网格点数之比（无单位小数）。\n\n所有时间必须以秒为单位表示，所有分数必须以 $[0,1]$ 区间内的小数表示。本问题不使用角度单位。\n\n您的程序必须生成单行输出，其中包含按以下确切格式聚合为列表的列表的结果（无空格）：\n- 输出必须是\n$$\n\\big[ [D_1, F^{\\mathrm{shadow}}_1, F^{\\mathrm{unreach}}_1], [D_2, F^{\\mathrm{shadow}}_2, F^{\\mathrm{unreach}}_2], [D_3, F^{\\mathrm{shadow}}_3, F^{\\mathrm{unreach}}_3] \\big],\n$$\n使用标准浮点字符串表示法打印为单行，括号和逗号与所示完全一致，不含任何其他文本。例如：\n$[[0.0123,0.045,0.0],[0.0,0.0,0.0],[inf,0.12,0.49]]$。\n\n您的实现必须是自包含的，且不得读取任何输入。套件中每个测试的答案必须是一个浮点数三元组。最终程序必须遵守指定的执行环境。",
            "solution": "所提出的问题是有效的，因为它在科学上基于波传播原理，在数学上是适定的，并且具有客观、明确的参数。我现在将进行完整的解答。\n\n该问题要求计算二维介质中包含不可穿透空洞的初至波走时。该物理过程由程函方程控制，这是一个非线性一阶偏微分方程。\n\n程函方程由下式给出\n$$\n\\lvert \\nabla T(\\mathbf{x}) \\rvert = s(\\mathbf{x}),\n$$\n其中 $T(\\mathbf{x})$ 是走时场，$s(\\mathbf{x}) = 1/v(\\mathbf{x})$ 是慢度（速度的倒数）。在此问题中，介质是均匀的，速度为 $v_0$，因此慢度 $s$ 是一个常数，$s=1/v_0$。在二维笛卡尔坐标系中，该方程展开为：\n$$\n\\left( \\frac{\\partial T}{\\partial x} \\right)^2 + \\left( \\frac{\\partial T}{\\partial y} \\right)^2 = s^2.\n$$\n这个方程是一个静态哈密顿-雅可比方程。它通过在源点 $\\mathbf{x}_s$ 处的边界条件 $T(\\mathbf{x}_s) = 0$ 来求解。解 $T(\\mathbf{x})$ 表示从 $\\mathbf{x}_s$ 到域中任意点 $\\mathbf{x}$ 的最短传播时间。\n\n我们的任务是在均匀笛卡尔网格上数值求解此方程，网格间距为 $h=\\Delta x = \\Delta y$。求解方法必须与快速行进法（FMM）一致，该方法尊重波传播的因果性。FMM 通过从源点向外系统地构造解来求解方程。该方法的核心是一个局部更新规则，用于根据其已计算的“迎风”邻居点的时间来更新网格点的走时。\n\n**迎风有限差分格式的推导**\n\n因果性原理规定，网格点 $(i,j)$ 处的走时 $T$ 只能依赖于走时更小的邻居点。我们使用一阶单边迎风差分来近似偏导数。梯度范数平方的迎风格式为：\n$$\n\\left( \\max\\left( D^{-x}_{i,j}T, -D^{+x}_{i,j}T, 0 \\right) \\right)^2 + \\left( \\max\\left( D^{-y}_{i,j}T, -D^{+y}_{i,j}T, 0 \\right) \\right)^2 = s^2,\n$$\n其中 $D^{-x}_{i,j}T = (T_{i,j} - T_{i-1,j})/h$， $D^{+x}_{i,j}T = (T_{i+1,j} - T_{i,j})/h$，依此类推。在 FMM 的背景下，当我们计算时间 $T_{i,j}$ 时，我们只使用那些已经被最终确定（接受）的邻居点的值。设 $x$ 和 $y$ 方向上已接受的最小邻居点时间分别为 $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $T_y = \\min(T_{i,j-1}, T_{i,j+1})$。未知时间 $T \\equiv T_{i,j}$ 的离散程函方程变为：\n$$\n(\\max(0, T - T_x))^2 + (\\max(0, T - T_y))^2 = (sh)^2.\n$$\n假设 $T  T_x$ 且 $T  T_y$，这简化为关于 $T$ 的二次方程：\n$$\n(T - T_x)^2 + (T - T_y)^2 = (sh)^2.\n$$\n展开此式得到 $2T^2 - 2T(T_x + T_y) + (T_x^2 + T_y^2 - (sh)^2) = 0$。对 $T$ 求解并取有物理意义的较大根，得到：\n$$\nT_{quad} = \\frac{T_x + T_y + \\sqrt{2(sh)^2 - (T_x - T_y)^2}}{2}.\n$$\n此解仅在判别式为非负时有效，即 $2(sh)^2 \\ge (T_x - T_y)^2$，或 $|T_x - T_y| \\le \\sqrt{2}sh$。在许多实现中，使用了一个更简单的准则 $|T_x - T_y| \\le sh$，这对应于检查 $T_{quad}$ 是否大于 $T_x$ 和 $T_y$。如果不满足此条件，则意味着波主要从一个方向到达。此时更新应仅基于具有最小时间的邻居点，例如 $T_{min} = \\min(T_x, T_y)$。更新规则退化为一维程函方程 $(T - T_{min})^2 = (sh)^2$，给出 $T = T_{min} + sh$。\n\n因此，完整的局部求解器如下：\n1. 识别已接受的最小邻居点时间 $T_x$ 和 $T_y$。\n2. 如果只有一个是有限的（例如 $T_x$），则更新为 $T = T_x + sh$。\n3. 如果两者都是有限的，检查判别式 $2(sh)^2 - (T_x - T_y)^2$ 是否为非负。\n   a. 如果是，则更新为 $T = \\frac{1}{2}(T_x + T_y + \\sqrt{2(sh)^2 - (T_x - T_y)^2})$。\n   b. 如果否，则更新为 $T = \\min(T_x, T_y) + sh$。\n\n**快速行进法（FMM）算法**\n\nFMM 是一种基于网格的算法，类似于用于在图上寻找最短路径的 Dijkstra 算法。它将网格点分为三类：\n- **ALIVE（存活）**：走时已最终确定的点。\n- **TRIAL（试验）**：ALIVE 点的邻居，其暂定走时已被计算。这些是下一个 ALIVE 点的候选点。\n- **FAR（遥远）**：所有其他点，其走时初始化为无穷大。\n\n算法流程如下：\n1.  **初始化**：\n    - 走时数组 $T$ 初始化为 $\\infty$，但源点处 $T(\\mathbf{x}_s) = 0$。\n    - 所有点的状态均为 `FAR`。\n    - 创建一个最小优先队列（最小堆）来存储 `TRIAL` 点，按其暂定走时排序。\n    - 将源点 $\\mathbf{x}_s$ 以时间 0 添加到优先队列中，并将其状态设置为 `TRIAL`。\n\n2.  **行进循环**：当优先队列不为空时：\n    a. 从队列中提取具有最小走时的点 $\\mathbf{x}_{min}$。\n    b. 如果其状态已经是 `ALIVE`，则忽略它并继续（这处理了单个点的多个、递减的时间估计被添加到队列中的情况）。\n    c. 将 $\\mathbf{x}_{min}$ 的状态设置为 `ALIVE`。其时间现已最终确定。\n    d. 对于 $\\mathbf{x}_{min}$ 的每个邻居点 $\\mathbf{x}_n$：\n        i.  如果 $\\mathbf{x}_n$ 在孔洞内或已经是 `ALIVE` 状态，则忽略它。\n        ii. 使用上述局部求解器，根据其 `ALIVE` 邻居计算 $\\mathbf{x}_n$ 的新暂定时间。\n        iii. 如果这个新时间小于当前为 $\\mathbf{x}_n$ 存储的时间，则将 $T(\\mathbf{x}_n)$ 更新为新时间，将 $\\mathbf{x}_n$ 的状态设置为 `TRIAL`，并将（新时间, $\\mathbf{x}_n$）添加到优先队列中。\n\n当队列为空时，循环终止。此时，计算域 $D = \\Omega \\setminus \\mathcal{H}$ 中所有可达点的正确初至波走时都已计算完毕。与源点不连通区域中的点将保持其初始走时 $\\infty$。\n\n**指标计算**\n\n对于每个测试用例，在计算走时场 $T_k$ 后，我们计算所需的指标：\n- **延迟 $D_k$**：探测点处的计算时间 $T_k(\\mathbf{x}_p)$ 与直线传播时间 $T_{\\mathrm{free}}(\\mathbf{x}_p) = \\|\\mathbf{x}_p - \\mathbf{x}_s\\|_2/v_0$ 之间的差值。如果 $T_k(\\mathbf{x}_p)$ 为 $\\infty$，则 $D_k$ 为 $\\infty$。\n- **不可达分数 $F^{\\mathrm{unreach}}_k$**：计算域 $D$ 中 $T_k = \\infty$ 的点数除以 $D$ 中的总点数。\n- **阴影面积分数 $F^{\\mathrm{shadow}}_k$**：阴影集 $S_{\\mathrm{shadow}}$ 中的点数除以 $D$ 中的总点数。一个点 $\\mathbf{x}$ 位于 $S_{\\mathrm{shadow}}$ 中，需满足三个条件：\n    1.  其走时 $T_k(\\mathbf{x})$ 是有限的。\n    2.  走时延迟 $T_k(\\mathbf{x}) - T_{\\mathrm{free}}(\\mathbf{x})$ 至少为 $\\delta$。\n    3.  从 $\\mathbf{x}_s$ 到 $\\mathbf{x}$ 的直线路径被孔洞阻挡。这个视线检查使用稳健的线段-矩形相交测试（例如 Liang-Barsky 算法）来执行，该测试确定线段是否与任何孔洞矩形的内部相交。\n实现将遵循这些原则来解决三个指定的测试用例。",
            "answer": "```python\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Solves the eikonal equation for three test cases using the Fast Marching Method,\n    and computes travel-time delay, shadow fraction, and unreachable fraction.\n    \"\"\"\n    # Define common parameters\n    L = 1000.0\n    h = 10.0\n    v0 = 2000.0\n    source_pos = (100.0, 500.0)\n    probe_pos = (800.0, 500.0)\n    delta = 0.01\n\n    slowness = 1.0 / v0\n    sh = slowness * h\n    sh_sq = sh**2\n\n    nx = int(L / h) + 1\n    ny = int(L / h) + 1\n    source_idx = (int(source_pos[0] / h), int(source_pos[1] / h))\n    probe_idx = (int(probe_pos[0] / h), int(probe_pos[1] / h))\n\n    # Pre-calculate coordinate and free-space travel time grids\n    x_coords = np.arange(nx) * h\n    y_coords = np.arange(ny) * h\n    grid_x, grid_y = np.meshgrid(x_coords, y_coords, indexing='ij')\n    \n    dist_from_source = np.sqrt((grid_x - source_pos[0])**2 + (grid_y - source_pos[1])**2)\n    T_free_grid = dist_from_source / v0\n\n    # Define test cases with hole geometries\n    test_cases = [\n        {'rects': [[450.0, 550.0, 400.0, 600.0]]}, # Case 1\n        {'rects': []},                            # Case 2\n        {'rects': [[450.0, 550.0, 0.0, 1000.0]]}   # Case 3\n    ]\n\n    # FMM states\n    FAR, TRIAL, ALIVE = 0, 1, 2\n\n    def get_hole_mask(rects):\n        mask = np.zeros((nx, ny), dtype=bool)\n        if not rects:\n            return mask\n        for rect in rects:\n            x_min, x_max, y_min, y_max = rect\n            mask |= (grid_x = x_min)  (grid_x = x_max)  (grid_y = y_min)  (grid_y = y_max)\n        return mask\n\n    def solve_eikonal_fmm(hole_mask):\n        times = np.full((nx, ny), np.inf, dtype=np.float64)\n        states = np.full((nx, ny), FAR, dtype=np.uint8)\n        \n        times[source_idx] = 0.0\n        pq = [(0.0, source_idx[0], source_idx[1])]\n        states[source_idx] = TRIAL\n\n        while pq:\n            time, ix, iy = heapq.heappop(pq)\n            \n            if states[ix, iy] == ALIVE:\n                continue\n            \n            states[ix, iy] = ALIVE\n            \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx_ix, nx_iy = ix + dx, iy + dy\n                \n                if not (0 = nx_ix  nx and 0 = nx_iy  ny and not hole_mask[nx_ix, nx_iy]):\n                    continue\n                \n                if states[nx_ix, nx_iy] == ALIVE:\n                    continue\n\n                t_x_neighbors = []\n                if nx_ix  0 and states[nx_ix - 1, nx_iy] == ALIVE: t_x_neighbors.append(times[nx_ix - 1, nx_iy])\n                if nx_ix  nx - 1 and states[nx_ix + 1, nx_iy] == ALIVE: t_x_neighbors.append(times[nx_ix + 1, nx_iy])\n\n                t_y_neighbors = []\n                if nx_iy  0 and states[nx_ix, nx_iy - 1] == ALIVE: t_y_neighbors.append(times[nx_ix, nx_iy - 1])\n                if nx_iy  ny - 1 and states[nx_ix, nx_iy + 1] == ALIVE: t_y_neighbors.append(times[nx_ix, nx_iy + 1])\n                \n                t_x = min(t_x_neighbors) if t_x_neighbors else np.inf\n                t_y = min(t_y_neighbors) if t_y_neighbors else np.inf\n                \n                new_time = np.inf\n                if t_x != np.inf and t_y != np.inf:\n                    discriminant = 2 * sh_sq - (t_x - t_y)**2\n                    if discriminant = 0:\n                        new_time = (t_x + t_y + np.sqrt(discriminant)) / 2.0\n                    else:\n                        new_time = min(t_x, t_y) + sh\n                elif t_x != np.inf:\n                    new_time = t_x + sh\n                elif t_y != np.inf:\n                    new_time = t_y + sh\n                \n                if new_time  times[nx_ix, nx_iy]:\n                    times[nx_ix, nx_iy] = new_time\n                    states[nx_ix, nx_iy] = TRIAL\n                    heapq.heappush(pq, (new_time, nx_ix, nx_iy))\n                    \n        return times\n\n    def is_los_blocked(ix, iy, rects):\n        if not rects:\n            return False\n        x_s, y_s = source_pos\n        x_p, y_p = ix * h, iy * h\n        \n        for rect in rects:\n            x_min, x_max, y_min, y_max = rect\n            dx, dy = x_p - x_s, y_p - y_s\n            \n            t_near, t_far = 0.0, 1.0\n            slabs = [ (x_s, dx, x_min, x_max), (y_s, dy, y_min, y_max) ]\n            \n            intersect = True\n            for p, d, slab_min, slab_max in slabs:\n                if abs(d)  1e-9: # Parallel to slab\n                    if not (slab_min  p  slab_max):\n                        intersect = False\n                        break\n                else:\n                    t1 = (slab_min - p) / d\n                    t2 = (slab_max - p) / d\n                    if t1  t2: t1, t2 = t2, t1\n                    t_near = max(t_near, t1)\n                    t_far = min(t_far, t2)\n                \n            if intersect and t_near  t_far:\n                return True\n        return False\n\n    final_results = []\n    for case in test_cases:\n        rects = case['rects']\n        hole_mask = get_hole_mask(rects)\n        \n        computed_times = solve_eikonal_fmm(hole_mask)\n        \n        # 1. Delay at probe\n        T_probe = computed_times[probe_idx]\n        T_free_probe = T_free_grid[probe_idx]\n        delay = T_probe - T_free_probe\n\n        # 2. Fractions\n        domain_mask = ~hole_mask\n        num_domain_points = np.sum(domain_mask)\n\n        unreachable_mask = domain_mask  (computed_times == np.inf)\n        num_unreachable = np.sum(unreachable_mask)\n        frac_unreachable = num_unreachable / num_domain_points if num_domain_points  0 else 0.0\n\n        delay_grid = computed_times - T_free_grid\n        \n        shadow_count = 0\n        domain_indices = np.argwhere(domain_mask)\n        for ix, iy in domain_indices:\n            if np.isfinite(computed_times[ix, iy]) and delay_grid[ix, iy] = delta:\n                if is_los_blocked(ix, iy, rects):\n                    shadow_count += 1\n        \n        frac_shadow = shadow_count / num_domain_points if num_domain_points  0 else 0.0\n        \n        final_results.append([delay, frac_shadow, frac_unreachable])\n        \n    # Format output string\n    result_strings = []\n    for res in final_results:\n        d, fs, fu = res\n        d_str = str(d).lower()\n        result_strings.append(f\"[{d_str},{fs},{fu}]\")\n        \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}