{
    "hands_on_practices": [
        {
            "introduction": "At the heart of any grid-based eikonal solver lies the local update rule, which computes the travel time at a single grid node based on its neighbors. This exercise challenges you to derive and implement this fundamental component from the first principles of an upwind finite-difference scheme. Mastering this piecewise-consistent update is the essential first step toward building complete and robust eikonal solvers. ",
            "id": "3588075",
            "problem": "Consider isotropic first-arrival seismic traveltime governed by the Eikonal equation, which in two spatial dimensions states that the Euclidean magnitude of the spatial gradient of the traveltime field equals the local slowness: $$\\lVert \\nabla T(x,y) \\rVert = s(x,y).$$ In computational geophysics, a monotone, causal discretization using one-sided, upwind finite differences on a Cartesian grid with uniform spacing can be used to construct local single-node updates. Let the two-dimensional Cartesian grid spacing be uniform with $$\\Delta x = \\Delta y = h>0$$ and assume we are updating a single grid node $T_{i,j}$ using only the left and bottom accepted neighbors $a = T_{i-1,j}$ and $b = T_{i,j-1}$ together with the local slowness $s_{i,j} > 0.$ The update must be consistent with a Godunov-type upwind discretization of the Eikonal equation that preserves monotonicity and causality and must not violate physical constraints.\n\nStarting from the foundational relation $\\lVert \\nabla T \\rVert = s$ and the definition of slowness $s = 1/v$ where $v$ is wave speed, derive a discrete, piecewise-consistent local update formula for $T_{i,j}$ that uses $a, b, s_{i,j}, h$, ensuring that the update respects the upwind character of the solution. Implement this single-node update in a program and apply it to the following test suite. All traveltimes must be reported in seconds, and all given spacings must be in meters, and slowness values must be in seconds per meter.\n\nThe test suite consists of five parameter sets, each specified as $(h, s_{i,j}, a, b)$:\n- Test 1 (balanced neighbors, two-direction contribution expected): $(10, 0.1, 0, 0).$\n- Test 2 (strong one-direction dominance, linear update expected): $(10, 0.2, 0, 5).$\n- Test 3 (general case, two-direction contribution): $(1, 3, 3, 4).$\n- Test 4 (boundary case at the branch threshold): $(1, 2, 1, 3).$\n- Test 5 (nearly equal neighbors, small slowness): $(0.5, 0.01, 10, 10).$\n\nYour program must compute the five updated values $T_{i,j}$ in seconds for these parameter sets using a single-node update derived from first principles and print them as a single line containing a comma-separated list enclosed in square brackets. Each value must be rounded to eight decimal places, for example $[t_1, t_2, t_3, t_4, t_5]$ with $t_k$ in seconds.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the physics of wave propagation and the numerical analysis of partial differential equations. The problem is well-posed, objective, and contains all necessary information to derive the requested local update formula for the Eikonal equation and apply it to the given test cases. No contradictions, ambiguities, or factual errors were found.\n\nThe derivation of the single-node update formula for the traveltime $T_{i,j}$ proceeds from the 2D Eikonal equation:\n$$\n\\lVert \\nabla T(x,y) \\rVert^2 = \\left(\\frac{\\partial T}{\\partial x}\\right)^2 + \\left(\\frac{\\partial T}{\\partial y}\\right)^2 = s(x,y)^2\n$$\nHere, $T(x,y)$ is the traveltime field and $s(x,y)$ is the slowness (reciprocal of velocity). The problem requires a monotone and causal upwind finite difference scheme on a Cartesian grid with uniform spacing $h = \\Delta x = \\Delta y$. We are updating the node $T_{i,j}$ using known, accepted traveltimes from the left neighbor, $a = T_{i-1,j}$, and the bottom neighbor, $b = T_{i,j-1}$. The upwind nature of the scheme, for a wave propagating into the first quadrant of the local $ij$-system, implies that the partial derivatives should be approximated using backward differences:\n$$\n\\frac{\\partial T}{\\partial x} \\approx \\frac{T_{i,j} - T_{i-1,j}}{h} = \\frac{T_{i,j} - a}{h}\n$$\n$$\n\\frac{\\partial T}{\\partial y} \\approx \\frac{T_{i,j} - T_{i,j-1}}{h} = \\frac{T_{i,j} - b}{h}\n$$\nThe causality principle dictates that the traveltime at a node cannot be less than the traveltime at any of its upwind neighbors. Thus, any valid solution must satisfy $T_{i,j} \\ge a$ and $T_{i,j} \\ge b$.\n\nA robust Godunov-type scheme for the Eikonal equation accounts for the direction of information flow by using $\\max$ operators, which for this specific upwind configuration becomes:\n$$\n\\left(\\max\\left(\\frac{T_{i,j} - a}{h}, 0\\right)\\right)^2 + \\left(\\max\\left(\\frac{T_{i,j} - b}{h}, 0\\right)\\right)^2 = s_{i,j}^2\n$$\nLet $T = T_{i,j}$ and $s = s_{i,j}$. To solve for $T$, we must consider two cases based on the contributions of the neighbors.\n\nCase 1: Both neighbors $a$ and $b$ contribute to the update.\nThis scenario corresponds to a wavefront arriving from a diagonal direction. We assume that the solution $T$ will be greater than both $a$ and $b$. In this case, $T-a>0$ and $T-b>0$, so the $\\max$ operators are redundant, and the equation simplifies to:\n$$\n\\left(\\frac{T - a}{h}\\right)^2 + \\left(\\frac{T - b}{h}\\right)^2 = s^2\n$$\nExpanding this equation gives a quadratic equation for $T$:\n$$\n(T-a)^2 + (T-b)^2 = (sh)^2\n$$\n$$\nT^2 - 2aT + a^2 + T^2 - 2bT + b^2 - (sh)^2 = 0\n$$\n$$\n2T^2 - 2(a+b)T + (a^2+b^2-(sh)^2) = 0\n$$\nUsing the quadratic formula $T = \\frac{-B \\pm \\sqrt{B^2 - 4AC}}{2A}$ with $A=2$, $B=-2(a+b)$, and $C=a^2+b^2-(sh)^2$, we find the solution. We must choose the larger root to satisfy causality ($T > a, T > b$):\n$$\nT = \\frac{2(a+b) + \\sqrt{4(a+b)^2 - 8(a^2+b^2-(sh)^2)}}{4}\n$$\n$$\nT = \\frac{a+b + \\sqrt{(a+b)^2 - 2(a^2+b^2-(sh)^2)}}{2}\n$$\n$$\nT = \\frac{a+b + \\sqrt{2(sh)^2 - (a-b)^2}}{2}\n$$\nThis formula, derived under the assumption that $T > \\max(a, b)$, is only self-consistent if its result actually satisfies this condition. Let $t_{\\max} = \\max(a, b)$. The condition $T \\ge t_{\\max}$ holds if and only if:\n$$\n\\frac{a+b + \\sqrt{2(sh)^2 - (a-b)^2}}{2} \\ge \\max(a, b)\n$$\nThis inequality simplifies to $\\sqrt{2(sh)^2 - (a-b)^2} \\ge |a-b|$, which after squaring both sides (permissible as both are non-negative) yields $2(sh)^2 - (a-b)^2 \\ge (a-b)^2$, and finally:\n$$\n|a-b| \\le sh\n$$\n\nCase 2: Only one neighbor contributes to the update.\nThis scenario occurs when the condition $|a-b| \\le sh$ is violated, i.e., $|a-b| > sh$. This physically signifies that the wavefront is arriving nearly parallel to one of the grid axes. The quadratic formula is no longer causal, implying that one of our initial assumptions, $T-a>0$ or $T-b>0$, must be incorrect in the context of the combined update. The correct interpretation in a Godunov scheme is that the update is dominated by the neighbor with the minimum traveltime, let's call it $t_{\\min} = \\min(a, b)$. The contribution from the other neighbor, $t_{\\max} = \\max(a,b)$ is zero. The discretized Eikonal equation degenerates to a one-dimensional form:\n$$\n\\left(\\frac{T - t_{\\min}}{h}\\right)^2 = s^2\n$$\nSolving for $T$ (and selecting the causal root $T > t_{\\min}$) gives a simple linear update:\n$$\nT = t_{\\min} + sh\n$$\nThis linear update is consistent with the condition $|a-b| > sh$, as it produces a solution $T$ such that $T - t_{\\max} = t_{\\min} + sh - t_{\\max} = sh - (t_{\\max}-t_{\\min}) = sh - |a-b|  0$, validating the $\\max\\left(\\frac{T-t_{\\max}}{h}, 0\\right)=0$ assumption.\n\nSummary of the piecewise-consistent update formula:\nGiven inputs $h, s, a, b$, the updated traveltime $T$ is calculated as follows:\n1. If $|a - b| \\ge sh$, the update is one-dimensional:\n   $$\n   T = \\min(a, b) + sh\n   $$\n2. If $|a - b|  sh$, the update is two-dimensional:\n   $$\n   T = \\frac{a+b + \\sqrt{2(sh)^2 - (a-b)^2}}{2}\n   $$\nNote that at the boundary $|a-b| = sh$, both formulas yield the same result, ensuring consistency.\n\nApplication to the test suite will proceed using this derived algorithm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies a single-node upwind finite-difference update for the\n    Eikonal equation to a suite of test cases.\n    \"\"\"\n    \n    # The test suite consists of five parameter sets, each specified as\n    # (h, s_ij, a, b).\n    # h: grid spacing in meters\n    # s_ij: local slowness in seconds/meter\n    # a: traveltime at neighbor (i-1,j) in seconds\n    # b: traveltime at neighbor (i,j-1) in seconds\n    test_cases = [\n        # (h, s_ij, a, b)\n        (10, 0.1, 0, 0),    # Test 1: balanced neighbors, two-direction contribution\n        (10, 0.2, 0, 5),    # Test 2: strong one-direction dominance, linear update\n        (1, 3, 3, 4),       # Test 3: general case, two-direction contribution\n        (1, 2, 1, 3),       # Test 4: boundary case at the branch threshold\n        (0.5, 0.01, 10, 10),# Test 5: nearly equal neighbors, small slowness\n    ]\n\n    results = []\n    \n    def calculate_traveltime_update(h, s, a, b):\n        \"\"\"\n        Calculates the updated traveltime T_ij for a single node using a\n        piecewise-consistent upwind finite difference scheme.\n\n        The scheme is derived from the Godunov-type discretization of the\n        Eikonal equation:\n        (max((T-a)/h, 0))^2 + (max((T-b)/h, 0))^2 = s^2\n\n        Args:\n            h (float): Grid spacing.\n            s (float): Local slowness.\n            a (float): Traveltime at neighbor T_{i-1,j}.\n            b (float): Traveltime at neighbor T_{i,j-1}.\n\n        Returns:\n            float: The updated traveltime T_{i,j}.\n        \"\"\"\n        sh = s * h\n        \n        # The choice between the 1D and 2D update depends on whether the\n        # wavefront is better approximated as planar along a grid axis or\n        # arriving from a diagonal direction. This is determined by comparing\n        # the traveltime difference between neighbors to the time it takes\n        # for a wave to travel one grid cell.\n        if np.abs(a - b) >= sh:\n            # Case 1: 1D (linear) update.\n            # The update is dominated by the neighbor with the smaller traveltime.\n            # This corresponds to a wavefront arriving nearly parallel to an axis.\n            # Formula: T = min(a,b) + s*h\n            t_min = min(a, b)\n            t_new = t_min + sh\n        else:\n            # Case 2: 2D (quadratic) update.\n            # Both neighbors contribute. This corresponds to a wavefront arriving\n            # from a more diagonal direction.\n            # Formula: T = (a+b + sqrt(2*(s*h)^2 - (a-b)^2))/2\n            discriminant = 2 * (sh**2) - (a - b)**2\n            # The discriminant is guaranteed to be non-negative due to the\n            # condition |a-b|  sh.\n            t_new = (a + b + np.sqrt(discriminant)) / 2\n            \n        return t_new\n\n    for case in test_cases:\n        h_val, s_val, a_val, b_val = case\n        updated_t = calculate_traveltime_update(h_val, s_val, a_val, b_val)\n        # Format the result to eight decimal places as specified.\n        results.append(f\"{updated_t:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building upon the local update rule, we now construct a complete and efficient solver using the Fast Marching Method (FMM). FMM uses a priority queue to systematically advance the wavefront in a single pass, making it a powerful tool for computing first-arrival travel times. This practice will guide you through implementing a full FMM solver capable of handling multiple sources, a common scenario in seismology, and identifying the resulting domains of dependence. ",
            "id": "3588118",
            "problem": "You are asked to design and implement a numerical solver for the isotropic eikonal equation to compute a multi-source travel-time field on a uniform two-dimensional Cartesian grid and to identify the Voronoi-like partition of the domain into regions of dependence of each point source. The foundational base for this task is geometric optics in the high-frequency limit, where traveltime along a curve is additive and rays extremize traveltime. This leads to the Hamilton–Jacobi form of the isotropic eikonal equation. The problem must be solved in purely mathematical terms on a rectangular grid, with clear physical units specified for all quantities.\n\nStarting point and definitions. Consider a bounded rectangular domain discretized on a uniform grid with spacing $h$ in both directions. Let $v(x,y)$ denote an isotropic speed field that is strictly positive and bounded on the domain, with units meters per second. For a finite set of point sources $\\{x_s^{(i)}\\}_{i=1}^M$, the multi-source traveltime $T(x,y)$ satisfies the eikonal equation\n$$\n\\lvert \\nabla T(x,y) \\rvert \\;=\\; \\frac{1}{v(x,y)} \\quad \\text{in the domain,}\n$$\nwith Dirichlet boundary conditions $T(x_s^{(i)}) = 0$ for all sources $i \\in \\{1,\\dots,M\\}$. The domain of dependence (Voronoi-like cell) for a source $i$ is the set of points where $i$ realizes the minimum arrival time among all sources.\n\nAlgorithmic requirements. You must derive from first principles an upwind, monotone discretization for the eikonal equation suitable for a Dijkstra-like acceptance ordering (that is, a single-pass method based on increasing traveltimes). Your solver must:\n- Use only local upwind information to update a grid node’s traveltime from already accepted neighbors.\n- Guarantee causality by always accepting the currently smallest tentative traveltime from a min-priority queue.\n- Correctly handle multiple sources by initializing all source nodes with zero traveltime and propagating a label field that identifies which source each accepted node depends on. In case two or more sources produce exactly equal traveltimes at a node to within a small tolerance, break ties deterministically by selecting the smallest source index.\n- Use four-neighbor connectivity on the grid.\n- Produce traveltimes $T$ in seconds, when $v$ is in meters per second and the grid coordinates are in meters.\n\nYour program must implement the solver and produce answers for the following test suite. In all cases, the domain is $[0,1]\\times[0,1]$ meters, discretized by $N \\times N$ grid points with $N=101$, so that the grid spacing is $h = 1/(N-1)$ meters. Grid point coordinates are located at $(x_i,y_j) = (i h, j h)$ for integers $i,j \\in \\{0,\\dots,N-1\\}$. All angles, if any, must be in radians, but angles do not explicitly appear in this problem.\n\nTest suite:\n1. Constant-speed, single source accuracy. Let $v(x,y) \\equiv 2.0$ meters per second. Place a single source at $(x_s,y_s) = (0.25,0.5)$ meters, located on the nearest grid point. Compute the numerical traveltime field $T_{\\text{num}}$. For this constant-speed case, the analytic solution is $T_{\\text{ana}}(x,y) = \\sqrt{(x-x_s)^2 + (y-y_s)^2} / 2.0$ seconds. Compute the maximum absolute error $E_{\\infty} = \\max_{i,j} \\lvert T_{\\text{num}}(x_i,y_j) - T_{\\text{ana}}(x_i,y_j) \\rvert$ in seconds.\n2. Constant-speed, two sources partition balance. Let $v(x,y) \\equiv 2.0$ meters per second. Place two sources at $(x_s^{(1)},y_s^{(1)}) = (0.10,0.50)$ meters and $(x_s^{(2)},y_s^{(2)}) = (0.90,0.50)$ meters, each on the nearest grid point. Compute the label field $\\ell(x_i,y_j) \\in \\{0,1\\}$ that identifies which source yields the minimum arrival time at each grid point, with ties broken toward the smallest index. Compute the fraction $f_0$ of grid points labeled $\\ell=0$. Report the absolute deviation $\\lvert f_0 - 0.5 \\rvert$ as a dimensionless decimal.\n3. Heterogeneous-speed scaling invariance of partition. Let the baseline speed field be $v(x,y) = 2.0$ meters per second everywhere except inside the disk of radius $0.15$ meters centered at $(0.35,0.50)$ meters where $v(x,y) = 0.5$ meters per second. Place two sources at $(x_s^{(1)},y_s^{(1)}) = (0.10,0.50)$ meters and $(x_s^{(2)},y_s^{(2)}) = (0.90,0.50)$ meters, each on the nearest grid point. Compute the label field $\\ell_{\\text{base}}$ for the baseline $v$. Then define a scaled speed field $v'(x,y) = \\alpha v(x,y)$ with $\\alpha = 3.7$ (dimensionless), and compute the label field $\\ell_{\\text{scaled}}$ under $v'$. Report a boolean indicating whether $\\ell_{\\text{base}}$ and $\\ell_{\\text{scaled}}$ are exactly identical on all grid points.\n\nFinal output format. Your program must produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets and in the following order: $[E_{\\infty}, \\lvert f_0 - 0.5 \\rvert, \\text{label\\_invariance}]$. The first number $E_{\\infty}$ must be expressed in seconds and rounded to six decimal places, the second number $\\lvert f_0 - 0.5 \\rvert$ must be rounded to six decimal places, and the third value must be the literal boolean token True or False. For example, the output format must look like $[0.003127,0.000000,True]$.",
            "solution": "The problem of computing a multi-source travel-time field on a Cartesian grid is a classic application of solving the eikonal equation, a cornerstone of geometric optics and computational geophysics. The solution requires deriving a numerical scheme and implementing an efficient solver that respects causality.\n\nThe governing equation is the isotropic eikonal equation:\n$$\n|\\nabla T(x,y)| = \\frac{1}{v(x,y)} = s(x,y)\n$$\nHere, $T(x,y)$ is the travel-time field in seconds, $v(x,y)$ is the wave propagation speed in meters per second, and $s(x,y)$ is the slowness in seconds per meter. The equation is a non-linear partial differential equation of the Hamilton-Jacobi type. The boundary conditions are given by $T(x_s^{(i)}) = 0$ for a set of sources $\\{x_s^{(i)}\\}$. The multi-source travel-time field is the minimum arrival time from any source, $T(x,y) = \\min_i T_i(x,y)$, where $T_i$ is the travel time from source $i$.\n\nThe core physical principle is causality: the travel time at a point can only be determined by points with smaller travel times. This suggests an ordering in the computation, propagating information outward from the sources, much like Huygens' principle. The Fast Marching Method (FMM) is designed for this. It is a grid-based algorithm that uses a Dijkstra-like approach to solve the eikonal equation in a single pass. Grid points are categorized into three sets:\n1.  **Accepted (or Frozen)**: Points for which the final travel time has been computed.\n2.  **Trial (or Narrow Band)**: Points adjacent to the Accepted set, for which a tentative travel time has been computed. These are candidates for acceptance.\n3.  **Unseen (or Far Away)**: All other points, with travel times initialized to infinity.\n\nThe FMM algorithm maintains a min-priority queue of the Trial points, ordered by their tentative travel times. The algorithm proceeds by repeatedly accepting the Trial point with the minimum travel time, moving it to the Accepted set, and then updating the travel times of its Unseen or Trial neighbors.\n\nTo derive the update rule, we discretize the eikonal equation on a uniform grid with spacing $h$. An upwind, first-order finite difference scheme is necessary to ensure stability and respect for causality. At a grid point $(i,j)$, the squared gradient $|\\nabla T|^2 = (\\partial T/\\partial x)^2 + (\\partial T/\\partial y)^2$ is approximated as:\n$$\n\\left(\\max\\left( \\frac{T_{i,j}-T_{i-1,j}}{h}, \\frac{T_{i,j}-T_{i+1,j}}{-h}, 0 \\right)\\right)^2 + \\left(\\max\\left( \\frac{T_{i,j}-T_{i,j-1}}{h}, \\frac{T_{i,j}-T_{i,j+1}}{-h}, 0 \\right)\\right)^2 = s_{i,j}^2\n$$\nIn the FMM, when we update $T_{i,j}$, we only use information from already Accepted neighbors, which have smaller travel times. Let $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ and $T_y = \\min(T_{i,j-1}, T_{i,j+1})$ be the minimum travel times among the Accepted neighbors in the $x$ and $y$ directions, respectively. Since we expect $T_{i,j}$ to be larger than its accepted neighbors, the equation simplifies to:\n$$\n\\left(\\frac{T_{i,j}-T_x}{h}\\right)^2 + \\left(\\frac{T_{i,j}-T_y}{h}\\right)^2 = s_{i,j}^2\n$$\nThis is a quadratic equation for the new time $T = T_{i,j}$: $aT^2 + bT + c = 0$, with $a=2, b=-2(T_x+T_y), c=T_x^2+T_y^2-(hs_{i,j})^2$. Taking the larger root (which corresponds to outward propagation) gives:\n$$\nT = \\frac{T_x+T_y+\\sqrt{2(hs_{i,j})^2 - (T_x-T_y)^2}}{2}\n$$\nThis two-dimensional update is only physically meaningful if the wavefront arrives from a direction that involves both axes. A simple and robust condition is to compare the one-dimensional update time with the travel time of the farther neighbor. Let $T_1 = \\min(T_x, T_y)$ and $T_2 = \\max(T_x, T_y)$. If the wavefront propagates purely from the direction of $T_1$, the update would be $T = T_1 + hs_{i,j}$. If this 1D-updated time is less than or equal to $T_2$, it implies the characteristic from the $T_2$ neighbor does not reach the point $(i,j)$, so the 1D update is appropriate. Thus, the update rule is:\n1.  If only one neighbor (e.g., in $x$) is accepted, use the 1D update: $T = T_x + hs_{i,j}$.\n2.  If neighbors in both directions are accepted, let $T_1=\\min(T_x, T_y)$ and $T_2=\\max(T_x, T_y)$.\n    - If $T_2 - T_1 \\ge hs_{i,j}$, use the 1D update: $T = T_1 + hs_{i,j}$.\n    - Otherwise, use the 2D quadratic solution above.\n\nTo handle multiple sources and determine the Voronoi-like partition, we modify the FMM to track the source of each propagating wavefront. We initialize the priority queue with all source locations, each with zero travel time. The items in the priority queue become tuples of the form `(time, source_index, i, j)`. Python's `heapq` library, when used on such tuples, will sort by time first, and then by `source_index` as a tie-breaker. This elegantly and correctly implements the specified tie-breaking rule. When a node is accepted, its travel time and its dependency on a specific source (its label) are finalized simultaneously. The label of the accepted node is then propagated to its neighbors during their update step. This integrated approach computes the minimum travel-time field and the source-dependency partition in a single, efficient pass.\n\nThe test cases verify three key aspects:\n1.  **Accuracy**: Comparison against an analytical solution in a constant-velocity medium checks the correctness and convergence order of the numerical scheme.\n2.  **Partitioning**: A symmetric two-source problem in a constant-velocity medium tests the multi-source logic and the tie-breaking rule. Due to symmetry, the domain should be split nearly in half, with any deviation arising from the discrete grid and the deterministic tie-breaking rule.\n3.  **Invariance**: The eikonal equation possesses a scaling symmetry. If the slowness field is scaled by a constant, $s'(x,y) = s(x,y)/\\alpha$, the travel times are also scaled, $T'(x,y) = T(x,y)/\\alpha$. However, the ray paths, which are paths of minimum travel time, remain invariant. Consequently, the Voronoi-like partition of the domain based on first-arrival times should be identical for $v(x,y)$ and $v'(x,y) = \\alpha v(x,y)$. This test validates a fundamental physical property of the solution.",
            "answer": "```python\nimport numpy as np\nimport heapq\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the eikonal solver.\n    \"\"\"\n\n    def run_fmm_solver(N, h, speed_field, sources_coords):\n        \"\"\"\n        Solves the isotropic eikonal equation for multiple sources on a 2D grid\n        using the Fast Marching Method (FMM).\n\n        Args:\n            N (int): Grid dimension (N x N).\n            h (float): Grid spacing in meters.\n            speed_field (np.ndarray): N x N array of wave speeds (m/s).\n            sources_coords (list): A list of (x, y) tuples for source locations in meters.\n\n        Returns:\n            tuple: A tuple containing:\n                - times (np.ndarray): N x N array of first-arrival travel times (s).\n                - labels (np.ndarray): N x N array of source indices for the first arrival.\n        \"\"\"\n        # State constants for grid points\n        ACCEPTED = 0\n        TRIAL = 1\n        UNSEEN = 2\n\n        # Initialize data structures\n        times = np.full((N, N), np.inf, dtype=np.float64)\n        labels = np.full((N, N), -1, dtype=np.int32)\n        states = np.full((N, N), UNSEEN, dtype=np.int8)\n        pq = []  # Min-priority queue\n\n        slowness_field = 1.0 / speed_field\n\n        # Initialize sources in the priority queue\n        for label_idx, (sx, sy) in enumerate(sources_coords):\n            i_s = int(round(sx / h))\n            j_s = int(round(sy / h))\n            \n            i_s = np.clip(i_s, 0, N - 1)\n            j_s = np.clip(j_s, 0, N - 1)\n\n            # In case multiple sources map to the same grid point, the one with the\n            # smaller index will be processed first due to tie-breaking in the heap.\n            if times[i_s, j_s] > 0.0:\n                times[i_s, j_s] = 0.0\n                states[i_s, j_s] = TRIAL\n                heapq.heappush(pq, (0.0, label_idx, i_s, j_s))\n\n        # Main FMM loop\n        while pq:\n            time, label, i, j = heapq.heappop(pq)\n\n            if states[i, j] == ACCEPTED:\n                continue\n            \n            states[i, j] = ACCEPTED\n            labels[i, j] = label\n\n            # Propagate information to neighbors\n            for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                # Check boundary conditions and if neighbor is already accepted\n                if not (0 = ni  N and 0 = nj  N) or states[ni, nj] == ACCEPTED:\n                    continue\n\n                # Find minimum times of accepted neighbors in x and y directions\n                t_x_min = np.inf\n                if ni > 0 and states[ni - 1, nj] == ACCEPTED:\n                    t_x_min = min(t_x_min, times[ni - 1, nj])\n                if ni  N - 1 and states[ni + 1, nj] == ACCEPTED:\n                    t_x_min = min(t_x_min, times[ni + 1, nj])\n                \n                t_y_min = np.inf\n                if nj > 0 and states[ni, nj - 1] == ACCEPTED:\n                    t_y_min = min(t_y_min, times[ni, nj - 1])\n                if nj  N - 1 and states[ni, nj + 1] == ACCEPTED:\n                    t_y_min = min(t_y_min, times[ni, nj + 1])\n                \n                # Calculate time update based on available neighbors\n                hs = h * slowness_field[ni, nj]\n                t_new = np.inf\n\n                if t_x_min != np.inf and t_y_min != np.inf:\n                    t1, t2 = (t_x_min, t_y_min) if t_x_min  t_y_min else (t_y_min, t_x_min)\n                    if (t2 - t1)  hs:\n                        radicand = 2.0 * hs**2 - (t1 - t2)**2\n                        t_new = (t1 + t2 + math.sqrt(radicand)) / 2.0\n                    else:\n                        t_new = t1 + hs\n                elif t_x_min != np.inf:\n                    t_new = t_x_min + hs\n                elif t_y_min != np.inf:\n                    t_new = t_y_min + hs\n                \n                # If a shorter path to the neighbor is found, update it and push to queue\n                if t_new  times[ni, nj]:\n                    times[ni, nj] = t_new\n                    states[ni, nj] = TRIAL\n                    heapq.heappush(pq, (t_new, label, ni, nj))\n\n        return times, labels\n\n    N = 101\n    h = 1.0 / (N - 1)\n    results = []\n\n    # --- Test Case 1: Constant-speed, single source accuracy ---\n    v1 = 2.0\n    speed_field_1 = np.full((N, N), v1)\n    source_1_coord = (0.25, 0.5)\n    sources_1 = [source_1_coord]\n    \n    t_num_1, _ = run_fmm_solver(N, h, speed_field_1, sources_1)\n    \n    x_coords = np.linspace(0, 1, N)\n    y_coords = np.linspace(0, 1, N)\n    xx, yy = np.meshgrid(x_coords, y_coords, indexing='ij')\n    \n    t_ana_1 = np.sqrt((xx - source_1_coord[0])**2 + (yy - source_1_coord[1])**2) / v1\n    \n    e_inf = np.max(np.abs(t_num_1 - t_ana_1))\n    results.append(round(e_inf, 6))\n\n    # --- Test Case 2: Constant-speed, two sources partition balance ---\n    v2 = 2.0\n    speed_field_2 = np.full((N, N), v2)\n    sources_2 = [(0.10, 0.50), (0.90, 0.50)]\n    \n    _, labels_2 = run_fmm_solver(N, h, speed_field_2, sources_2)\n    \n    f0 = np.sum(labels_2 == 0) / (N * N)\n    dev_f0 = abs(f0 - 0.5)\n    results.append(round(dev_f0, 6))\n\n    # --- Test Case 3: Heterogeneous-speed scaling invariance of partition ---\n    v_bg = 2.0\n    v_slow = 0.5\n    disk_center = (0.35, 0.50)\n    disk_radius = 0.15\n    \n    speed_field_3_base = np.full((N, N), v_bg)\n    is_in_disk = (xx - disk_center[0])**2 + (yy - disk_center[1])**2 = disk_radius**2\n    speed_field_3_base[is_in_disk] = v_slow\n    \n    sources_3 = [(0.10, 0.50), (0.90, 0.50)]\n    \n    _, labels_base = run_fmm_solver(N, h, speed_field_3_base, sources_3)\n    \n    alpha = 3.7\n    speed_field_3_scaled = alpha * speed_field_3_base\n    _, labels_scaled = run_fmm_solver(N, h, speed_field_3_scaled, sources_3)\n    \n    label_invariance = np.array_equal(labels_base, labels_scaled)\n    results.append(label_invariance)\n\n    # Format and print final output\n    print(f\"[{results[0]},{results[1]},{results[2]}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real geological media are often anisotropic, meaning wave speed depends on the direction of propagation. This practice ventures into this more complex and realistic physical scenario by adapting the eikonal equation for anisotropic media. You will implement a solution using the Fast Sweeping Method (FSM), an efficient iterative alternative to FMM, providing a broader perspective on the numerical techniques available for these challenging problems. ",
            "id": "3588033",
            "problem": "Consider a two-dimensional anisotropic medium whose wave propagation is governed by the eikonal partial differential equation, derived from Fermat's principle of stationary travel time and an induced Riemannian metric. The anisotropy is specified by a symmetric positive definite matrix $A \\in \\mathbb{R}^{2 \\times 2}$ given by $A = \\operatorname{diag}(a_{x}^{-2}, a_{y}^{-2})$, where $a_{x}  0$ and $a_{y}  0$ are directional speed parameters along the $x$- and $y$-axes, respectively. The source is a point located at the origin $(0,0)$, with prescribed travel time $T(0,0) = 0$. Assume $A$ is spatially constant.\n\nStarting from the fundamental base of Fermat's principle and the definition of an induced Riemannian length, implement a solver that computes the travel time field $T(x,y)$ by solving the anisotropic eikonal equation associated with the metric defined by $A$. Use an upwind finite-difference discretization on a uniform Cartesian grid and a Gauss–Seidel style Fast Sweeping algorithm to enforce causality. The computational domain is the square $[-L_{x}, L_{x}] \\times [-L_{y}, L_{y}]$ with $L_{x} = L_{y} = 1$ (unitless), discretized by $N_{x} \\times N_{y}$ grid points, equally spaced with spacings $\\Delta x = \\frac{2 L_{x}}{N_{x} - 1}$ and $\\Delta y = \\frac{2 L_{y}}{N_{y} - 1}$ (unitless). Place the source at the central grid node.\n\nYour program must:\n- Derive from first principles the consistent anisotropic eikonal equation for $T(x,y)$ induced by the metric $A$ and use it to construct a monotone upwind discretization suitable for Fast Sweeping on a uniform grid.\n- Compute the numerical travel time field $T_{h}$ over the grid for each test case defined below.\n- Verify, for each test case, two properties:\n  1. The numerical travel times $T_{h}$ closely match the theoretical anisotropic travel time $T_{\\text{exact}}(x,y)$ implied by the constant diagonal anisotropy characterized by the speeds $v_{x} = a_{x}$ and $v_{y} = a_{y}$, across the domain excluding the source node. Quantify the agreement by the maximum pointwise relative error, and require it to be less than $\\epsilon = 2 \\times 10^{-2}$ (unitless).\n  2. The wavefront shape is consistent with the directional speeds in the sense that, along the coordinate axes, the effective speed estimated as $\\frac{|x|}{T_{h}(x,0)}$ for the $x$-axis and $\\frac{|y|}{T_{h}(0,y)}$ for the $y$-axis at several sample points is within an absolute tolerance $\\delta = 5 \\times 10^{-2}$ (unitless) of $a_{x}$ and $a_{y}$, respectively.\n\nDesign the Fast Sweeping update so that at each grid node $(i,j)$, the local update respects upwind causality from its immediate axis-aligned neighbors and solves the corresponding local quadratic relation implied by the anisotropic eikonal. Use four directional sweeps (e.g., $(i\\uparrow, j\\uparrow)$, $(i\\uparrow, j\\downarrow)$, $(i\\downarrow, j\\uparrow)$, $(i\\downarrow, j\\downarrow)$) repeatedly until convergence to a tolerance of $10^{-10}$ or a maximum of $1000$ full sweep cycles is reached.\n\nImplement the following test suite, where each case provides $(a_{x}, a_{y}, N_{x}, N_{y})$:\n- Case $1$ (happy path, isotropic): $(1, 1, 101, 101)$.\n- Case $2$ (moderate anisotropy): $(2, 1, 101, 101)$.\n- Case $3$ (moderate anisotropy, swapped): $(1, 3, 101, 101)$.\n- Case $4$ (edge case, strong anisotropy contrast): $(0.25, 2, 101, 101)$.\n\nFor each case, compute the two verifications described above and return a single boolean result indicating whether both verifications passed. Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, for example, $[r_{1}, r_{2}, r_{3}, r_{4}]$, where each $r_{k} \\in \\{\\text{True}, \\text{False}\\}$ is the boolean result for case $k$. All quantities are unitless, and angles do not appear in the computations.",
            "solution": "The supplied problem requires the implementation of a numerical solver for the two-dimensional anisotropic eikonal equation on a Cartesian grid. The solution must be derived from first principles, implemented using a Fast Sweeping Method, and validated against analytical properties.\n\n### 1. Theoretical Foundation and Governing Equation\n\nThe problem is rooted in Fermat's principle, which states that the travel time of a wave between two points corresponds to a path of stationary time. In an anisotropic medium, the wave speed depends on the direction of propagation. This behavior can be described using a Riemannian metric. The problem provides a metric tensor in the form of a symmetric positive definite matrix $A = \\operatorname{diag}(a_{x}^{-2}, a_{y}^{-2})$, where $a_x  0$ and $a_y  0$ are constants representing speeds along the principal axes. The differential element of travel time $dT$ for a path element $d\\mathbf{x} = (dx, dy)$ is given by the Riemannian length element $dT = \\sqrt{d\\mathbf{x}^T A d\\mathbf{x}}$.\n\nThe eikonal equation is a partial differential equation (PDE) for the travel time field $T(x,y)$. For a metric tensor $g_{ij}$, the general form of the eikonal equation is $g^{ij} \\frac{\\partial T}{\\partial x^i} \\frac{\\partial T}{\\partial x^j} = 1$. The matrix $g^{ij}$ is the inverse of the metric tensor $g_{ij}$. In this problem, $g_{ij}$ corresponds to the given matrix $A$. The inverse matrix is $A^{-1} = \\operatorname{diag}(a_x^2, a_y^2)$.\n\nSubstituting $A^{-1}$ into the general form, we obtain the specific anisotropic eikonal equation for this problem:\n$$ a_x^2 \\left(\\frac{\\partial T}{\\partial x}\\right)^2 + a_y^2 \\left(\\frac{\\partial T}{\\partial y}\\right)^2 = 1 $$\nThis equation relates the gradient of the travel time field, $\\nabla T = (\\frac{\\partial T}{\\partial x}, \\frac{\\partial T}{\\partial y})$, to the directional speeds defined by $a_x$ and $a_y$.\n\nFor a spatially constant medium with a point source at the origin, ($T(0,0)=0$), an exact analytical solution exists. By applying the coordinate transformation $\\tilde{x} = x/a_x$ and $\\tilde{y} = y/a_y$, the eikonal equation transforms into the standard isotropic eikonal equation:\n$$ a_x^2 \\left(\\frac{\\partial T}{\\partial \\tilde{x}}\\frac{1}{a_x}\\right)^2 + a_y^2 \\left(\\frac{\\partial T}{\\partial \\tilde{y}}\\frac{1}{a_y}\\right)^2 = 1 \\implies \\left(\\frac{\\partial T}{\\partial \\tilde{x}}\\right)^2 + \\left(\\frac{\\partial T}{\\partial \\tilde{y}}\\right)^2 = 1 $$\nThe solution to this isotropic equation for a point source at the origin is the Euclidean distance in the transformed coordinates, $T(\\tilde{x}, \\tilde{y}) = \\sqrt{\\tilde{x}^2 + \\tilde{y}^2}$. Transforming back to the original coordinates $(x,y)$ gives the exact solution:\n$$ T_{\\text{exact}}(x,y) = \\sqrt{\\left(\\frac{x}{a_x}\\right)^2 + \\left(\\frac{y}{a_y}\\right)^2} $$\nThis analytical solution will be used to verify the accuracy of the numerical solver. The level sets of $T_{\\text{exact}}$ (wavefronts) are ellipses.\n\n### 2. Numerical Discretization and Algorithm Design\n\nTo solve the eikonal equation numerically, we use an upwind finite-difference scheme on a uniform grid with spacings $\\Delta x$ and $\\Delta y$. The upwind nature is essential to respect causality, where information (travel time) propagates outwards from the source.\n\nAt a grid node $(i,j)$, the partial derivatives are approximated using one-sided differences involving the neighbors with the smallest travel times. Let $T_{i,j}$ be the unknown travel time at node $(i,j)$, and let $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ and $T_y = \\min(T_{i,j-1}, T_{i,j+1})$ be the minimum travel times of its neighbors along each axis. The discretized eikonal equation becomes:\n$$ a_x^2 \\left(\\frac{T_{i,j} - T_x}{\\Delta x}\\right)^2_+ + a_y^2 \\left(\\frac{T_{i,j} - T_y}{\\Delta y}\\right)^2_+ = 1 $$\nwhere $(z)_+ = \\max(z,0)^2$ ensures that only upwind information (from smaller to larger time) is used. This leads to a quadratic equation for a candidate update $t \\equiv T_{i,j}$:\n$$ \\frac{a_x^2}{\\Delta x^2}(t - T_x)^2 + \\frac{a_y^2}{\\Delta y^2}(t - T_y)^2 = 1 $$\nLetting $C_x = (a_x/\\Delta x)^2$ and $C_y = (a_y/\\Delta y)^2$, this can be written as:\n$$ (C_x + C_y)t^2 - 2(C_x T_x + C_y T_y)t + (C_x T_x^2 + C_y T_y^2 - 1) = 0 $$\nThis is a standard quadratic equation of the form $At^2+Bt+C=0$. The physically meaningful solution must be greater than the neighbor times, so we take the larger root, $t = \\frac{-B + \\sqrt{B^2-4AC}}{2A}$.\n\nA robust update procedure considers that the characteristic ray might arrive from only one direction. The update rule at node $(i,j)$ is therefore:\n1.  Determine neighbor times $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ and $T_y = \\min(T_{i,j-1}, T_{i,j+1})$. If a neighbor is not yet updated, its time is treated as infinite. If both neighbors for an axis are unavailable, $T_x$ or $T_y$ is infinite.\n2.  If only one neighbor (e.g., $T_x$) has a finite time, the update is purely one-dimensional: $t_{cand} = T_x + \\Delta x/a_x$.\n3.  If both $T_x$ and $T_y$ are finite, first attempt a two-dimensional update by solving the quadratic equation. A valid real solution $t_{2D}$ must satisfy the causality condition $t_{2D} > \\max(T_x, T_y)$.\n4.  If the 2D update is not valid (no real solution or causality violation), the update degenerates to a 1D problem. The candidate time is the minimum of the two possible 1D updates: $t_{cand} = \\min(T_x + \\Delta x/a_x, T_y + \\Delta y/a_y)$.\n5.  The final new time at node $(i,j)$ is the minimum of its current value and the computed candidate time, $T_{i,j} \\leftarrow \\min(T_{i,j}, t_{cand})$.\n\nThe **Fast Sweeping Method (FSM)** is an iterative algorithm that efficiently propagates information across the grid. It consists of repeatedly applying the local update rule while sweeping through the grid in four alternating directions:\n1.  $i$ increasing, $j$ increasing: $(i=0 \\dots N_x-1, j=0 \\dots N_y-1)$\n2.  $i$ decreasing, $j$ increasing: $(i=N_x-1 \\dots 0, j=0 \\dots N_y-1)$\n3.  $i$ decreasing, $j$ decreasing: $(i=N_x-1 \\dots 0, j=N_y-1 \\dots 0)$\n4.  $i$ increasing, $j$ decreasing: $(i=0 \\dots N_x-1, j=N_y-1 \\dots 0)$\nThis Gauss-Seidel-like iteration, where updates use the most recent values available, ensures that causality is enforced over the whole domain. The iterations continue until the maximum change in the travel time field between full cycles of four sweeps falls below a convergence tolerance ($10^{-10}$), or a maximum number of iterations ($1000$) is reached.\n\n### 3. Verification of the Numerical Solution\n\nThe validity of the computed travel time field $T_h$ is assessed with two checks for each test case.\n1.  **Accuracy vs. Exact Solution**: The maximum pointwise relative error between the numerical solution $T_h$ and the analytical solution $T_{\\text{exact}}$ is computed over all grid points, excluding the source point where $T=0$. This error must be less than the tolerance $\\epsilon = 2 \\times 10^{-2}$.\n    $$ \\max_{(x,y) \\neq (0,0)} \\frac{|T_h(x,y) - T_{\\text{exact}}(x,y)|}{|T_{\\text{exact}}(x,y)|}  \\epsilon $$\n2.  **Wavefront Shape and Speed Consistency**: The effective propagation speed is estimated along the principal axes. For several sample points along the $x$-axis, the value $|x|/T_h(x,0)$ is computed and must be close to the prescribed speed $a_x$. Similarly, along the $y$-axis, $|y|/T_h(0,y)$ must be close to $a_y$. The absolute difference must be within a tolerance $\\delta = 5 \\times 10^{-2}$.\n\nA test case is considered successful if and only if both verification conditions are met.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(ax, ay, Nx, Ny):\n    \"\"\"\n    Solves the anisotropic eikonal equation for a given case and verifies the solution.\n    \"\"\"\n    # --- 1. Setup ---\n    Lx, Ly = 1.0, 1.0\n    max_iter = 1000\n    conv_tol = 1e-10\n    err_tol = 2e-2\n    speed_tol = 5e-2\n\n    # Grid parameters\n    dx = 2 * Lx / (Nx - 1)\n    dy = 2 * Ly / (Ny - 1)\n    x = np.linspace(-Lx, Lx, Nx)\n    y = np.linspace(-Ly, Ly, Ny)\n    ix_src = (Nx - 1) // 2\n    iy_src = (Ny - 1) // 2\n\n    # Initialize travel time field T\n    T = np.full((Ny, Nx), np.inf)\n    T[iy_src, ix_src] = 0.0\n\n    # Constants for the quadratic solver\n    Cx = (ax / dx)**2\n    Cy = (ay / dy)**2\n    \n    # --- 2. Fast Sweeping Method ---\n    for _ in range(max_iter):\n        T_old = T.copy()\n\n        # Four directional sweeps\n        sweep_orders = [\n            (range(Ny), range(Nx)),                      # i ->, j ->\n            (range(Ny), range(Nx - 1, -1, -1)),          # i -, j ->\n            (range(Ny - 1, -1, -1), range(Nx - 1, -1, -1)), # i -, j -\n            (range(Ny - 1, -1, -1), range(Nx))           # i ->, j -\n        ]\n\n        for j_order, i_order in sweep_orders:\n            for j in j_order:\n                for i in i_order:\n                    if i == ix_src and j == iy_src:\n                        continue\n\n                    # Get upwind neighbors using the Gauss-Seidel approach\n                    tx_min = np.inf\n                    if i > 0: tx_min = min(tx_min, T[j, i - 1])\n                    if i  Nx - 1: tx_min = min(tx_min, T[j, i + 1])\n                    \n                    ty_min = np.inf\n                    if j > 0: ty_min = min(ty_min, T[j - 1, i])\n                    if j  Ny - 1: ty_min = min(ty_min, T[j + 1, i])\n\n                    # If no valid neighbors, continue\n                    if tx_min == np.inf and ty_min == np.inf:\n                        continue\n\n                    # Handle 1D cases (one neighbor is at infinity)\n                    if tx_min == np.inf:\n                        t_cand = ty_min + dy / ay\n                        T[j, i] = min(T[j, i], t_cand)\n                        continue\n                    if ty_min == np.inf:\n                        t_cand = tx_min + dx / ax\n                        T[j, i] = min(T[j, i], t_cand)\n                        continue\n                    \n                    # Try 2D update\n                    t_cand = np.inf\n                    A_q = Cx + Cy\n                    B_q = -2 * (Cx * tx_min + Cy * ty_min)\n                    C_q = Cx * tx_min**2 + Cy * ty_min**2 - 1\n                    \n                    disc = B_q**2 - 4 * A_q * C_q\n                    \n                    if disc >= 0:\n                        t_2d = (-B_q + np.sqrt(disc)) / (2 * A_q)\n                        if t_2d > max(tx_min, ty_min):\n                            t_cand = t_2d\n                    \n                    # If 2D update failed, fall back to 1D\n                    if t_cand == np.inf:\n                        t_x_1d = tx_min + dx / ax\n                        t_y_1d = ty_min + dy / ay\n                        t_cand = min(t_x_1d, t_y_1d)\n\n                    T[j, i] = min(T[j, i], t_cand)\n\n        # Check for convergence\n        max_change = np.max(np.abs(T - T_old))\n        if max_change  conv_tol:\n            break\n\n    # --- 3. Verification ---\n    # Verification 1: Accuracy against exact solution\n    X, Y = np.meshgrid(x, y)\n    T_exact = np.sqrt((X / ax)**2 + (Y / ay)**2)\n    \n    mask = np.ones_like(T_exact, dtype=bool)\n    mask[iy_src, ix_src] = False\n    \n    rel_err = np.max(np.abs(T[mask] - T_exact[mask]) / T_exact[mask])\n    verif1_passed = rel_err  err_tol\n\n    # Verification 2: Effective speed along axes\n    verif2_passed = True\n    \n    # Sample points along x-axis\n    sample_displacements_x = np.unique(np.round(np.linspace(0.25, 1.0, 4) * ix_src).astype(int))\n    for offset in sample_displacements_x:\n        if offset == 0: continue\n        # Positive x\n        ix_pos = ix_src + offset\n        vx_eff_pos = np.abs(x[ix_pos]) / T[iy_src, ix_pos]\n        if np.abs(vx_eff_pos - ax) >= speed_tol:\n            verif2_passed = False; break\n        # Negative x\n        ix_neg = ix_src - offset\n        vx_eff_neg = np.abs(x[ix_neg]) / T[iy_src, ix_neg]\n        if np.abs(vx_eff_neg - ax) >= speed_tol:\n            verif2_passed = False; break\n    if not verif2_passed: return False\n\n    # Sample points along y-axis\n    sample_displacements_y = np.unique(np.round(np.linspace(0.25, 1.0, 4) * iy_src).astype(int))\n    for offset in sample_displacements_y:\n        if offset == 0: continue\n        # Positive y\n        iy_pos = iy_src + offset\n        vy_eff_pos = np.abs(y[iy_pos]) / T[iy_pos, ix_src]\n        if np.abs(vy_eff_pos - ay) >= speed_tol:\n            verif2_passed = False; break\n        # Negative y\n        iy_neg = iy_src - offset\n        vy_eff_neg = np.abs(y[iy_neg]) / T[iy_neg, ix_src]\n        if np.abs(vy_eff_neg - ay) >= speed_tol:\n            verif2_passed = False; break\n    if not verif2_passed: return False\n\n    return verif1_passed and verif2_passed\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (1.0, 1.0, 101, 101),\n        (2.0, 1.0, 101, 101),\n        (1.0, 3.0, 101, 101),\n        (0.25, 2.0, 101, 101),\n    ]\n\n    results = []\n    for case in test_cases:\n        ax, ay, Nx, Ny = case\n        result = run_case(ax, ay, Nx, Ny)\n        results.append(str(result))\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}