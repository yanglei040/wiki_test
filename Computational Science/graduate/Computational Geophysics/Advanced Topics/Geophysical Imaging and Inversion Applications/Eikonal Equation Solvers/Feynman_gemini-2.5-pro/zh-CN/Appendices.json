{
    "hands_on_practices": [
        {
            "introduction": "本次实践通过关注基本的局部更新规则，为所有基于网格的程函方程求解器奠定了基础。通过从第一性原理推导单个网格节点的更新公式，您将深入理解迎风有限差分格式如何捕捉波前传播的物理过程。这个练习  将阐明代表平面波前的单边更新与代表弯曲波前的双边更新之间的关键区别。",
            "id": "3588080",
            "problem": "考虑二维各向同性介质中的初至地震波走时，其中走时场 $T(x,y)$ 满足程函方程 $|\\nabla T| = s(x,y)$，慢度 $s(x,y) = 1/v(x,y)$。在间距为 $h$ 的均匀笛卡尔网格上，使用与 Godunov 通量一致的单调一阶迎风有限差分格式，根据已接受的邻居节点值来更新未知节点 $(i,j)$。假设在 $(i,j)$ 处，对更新有贡献的仅有的已接受邻居节点位于两个正交方向（例如，西向和南向），其走时分别为 $a$ 和 $b$，其中 $a \\le b$。假设在包含 $(i,j)$ 的单元内，$s$ 是已知且恒定的。\n \n从连续程函方程和单调迎风格式出发（不使用任何预先推导的更新公式），推导在 $(i,j)$ 处进行局部更新的标量代数方程，并求解该方程以获得更新后的 $T$ 关于 $a$、$b$、$h$ 和 $s$ 的显式表达式。明确指出在何种条件下，该更新简化为仅依赖于最小邻居节点值的单边表达式。\n\n然后，使用以下符合物理实际的参数计算更新后的 $T$：\n- 邻居节点走时：$a = 0.100 \\ \\mathrm{s}$ 和 $b = 0.120 \\ \\mathrm{s}$。\n- 网格间距：$h = 10 \\ \\mathrm{m}$。\n- 恒定速度：$v = 2000 \\ \\mathrm{m \\ s}^{-1}$（因此 $s = 1/v$）。\n\n将最终更新的 $T$ 以秒为单位表示，并将答案四舍五入到四位有效数字。仅报告计算出的更新后的 $T$。",
            "solution": "该问题要求推导由程函方程控制的走时 $T$ 的有限差分更新公式，在特定条件下的解，以及一次数值计算。该问题是适定的且在科学上是合理的，值得给出完整解答。\n\n二维程函方程由下式给出：\n$$|\\nabla T|^2 = s^2(x,y)$$\n其中 $T(x,y)$ 是走时场，$s(x,y)$ 是慢度场。在笛卡尔坐标系中，该方程展开为：\n$$\\left(\\frac{\\partial T}{\\partial x}\\right)^2 + \\left(\\frac{\\partial T}{\\partial y}\\right)^2 = s^2$$\n\n我们需要在间距为 $h$ 的均匀笛卡尔网格上使用一阶迎风有限差分格式。迎风格式仅使用走时值较小的节点来近似梯度分量，这遵循了信息传播的方向（因果性）。\n\n设 $T$ 为节点 $(i,j)$ 处的未知走时。问题陈述更新来自两个已接受的正交邻居节点，不失一般性，我们可以将其标记为西边邻居 $(i-1,j)$ 和南边邻居 $(i,j-1)$。它们的走时给定为 $a$ 和 $b$，且 $a \\le b$。设 $T_{i-1,j} = a$ 和 $T_{i,j-1} = b$。要进行更新，新的走时 $T$ 必须大于其已知邻居节点的走时，即 $T>a$ 和 $T>b$。\n\n假设波前从南轴和西轴之间的方向到达（双边更新），那么两个邻居节点都有贡献。在 $(i,j)$ 处的偏导数使用一阶后向差分近似：\n$$\\frac{\\partial T}{\\partial x} \\approx \\frac{T - T_{i-1,j}}{h} = \\frac{T-a}{h}$$\n$$\\frac{\\partial T}{\\partial y} \\approx \\frac{T - T_{i,j-1}}{h} = \\frac{T-b}{h}$$\n将这些近似代入程函方程，得到节点 $(i,j)$ 处更新的标量代数方程：\n$$\\left(\\frac{T-a}{h}\\right)^2 + \\left(\\frac{T-b}{h}\\right)^2 = s^2$$\n这可以重写为：\n$$(T-a)^2 + (T-b)^2 = (sh)^2$$\n\n为了求解 $T$，我们展开方程：\n$$T^2 - 2aT + a^2 + T^2 - 2bT + b^2 = (sh)^2$$\n$$2T^2 - 2(a+b)T + (a^2+b^2 - (sh)^2) = 0$$\n这是一个关于 $T$ 的二次方程，形式为 $CT^2+DT+E=0$，其系数为 $C=2$，$D=-2(a+b)$，以及 $E=a^2+b^2-(sh)^2$。应用二次方程求根公式 $T = \\frac{-D \\pm \\sqrt{D^2-4CE}}{2C}$：\n$$T = \\frac{2(a+b) \\pm \\sqrt{4(a+b)^2 - 8(a^2+b^2 - (sh)^2)}}{4}$$\n$$T = \\frac{a+b}{2} \\pm \\frac{\\sqrt{(a+b)^2 - 2(a^2+b^2 - (sh)^2)}}{2}$$\n$$T = \\frac{a+b}{2} \\pm \\frac{\\sqrt{a^2+2ab+b^2 - 2a^2-2b^2 + 2(sh)^2}}{2}$$\n$$T = \\frac{a+b}{2} \\pm \\frac{\\sqrt{2(sh)^2 - (a^2-2ab+b^2)}}{2}$$\n$$T = \\frac{a+b}{2} \\pm \\frac{\\sqrt{2(sh)^2 - (b-a)^2}}{2}$$\n由于更新后的时间 $T$ 必须大于邻居节点的时间 $a$ 和 $b$，我们选择正根：\n$$T = \\frac{a+b + \\sqrt{2(sh)^2 - (b-a)^2}}{2}$$\n此公式仅在判别式为非负时有效，即 $2(sh)^2 \\ge (b-a)^2$，或 $|b-a| \\le \\sqrt{2} sh$。\n\n更严格地说，一阶 Godunov 型格式是基于在可能的更新方案之间进行选择。一般的离散方程是：\n$$(\\max(0, \\frac{T-a}{h}))^2 + (\\max(0, \\frac{T-b}{h}))^2 = s^2$$\n我们假设 $a \\le b$。更新需要 $T > a$。出现两种情况：\n1. 更新是双边的（$T>b$）：这导致了上面推导的二次方程和解。如果得到的 $T$ 确实大于 $b$，则该情况是自洽的。这引出条件：\n    $$\\frac{a+b + \\sqrt{2(sh)^2 - (b-a)^2}}{2} > b$$\n    $$\\sqrt{2(sh)^2 - (b-a)^2} > b-a$$\n    两边平方（如果 $b-a \\ge 0$ 且平方根内的项为非负，则此操作有效）得到：\n    $$2(sh)^2 - (b-a)^2 > (b-a)^2 \\implies 2(sh)^2 > 2(b-a)^2 \\implies sh > b-a$$\n2. 更新是单边的（$a  T \\le b$）：在这种情况下，$\\max(0, \\frac{T-b}{h})=0$。计算模板实际上降维到沿走时为 $a$ 的邻居节点所在轴的一维。离散方程变为：\n    $$\\left(\\frac{T-a}{h}\\right)^2 = s^2 \\implies T-a = sh \\implies T = a+sh$$\n    如果得到的 $T$ 确实小于或等于 $b$，则该情况是自洽的：\n    $$a+sh \\le b \\implies sh \\le b-a$$\n\n因此，更新简化为仅依赖于最小邻居节点（$a$）的单边表达式的条件是 $b-a \\ge sh$。\n\n现在，我们使用给定的参数计算更新后的 $T$：\n- 邻居节点走时：$a = 0.100 \\ \\mathrm{s}$，$b = 0.120 \\ \\mathrm{s}$。\n- 网格间距：$h = 10 \\ \\mathrm{m}$。\n- 速度：$v = 2000 \\ \\mathrm{m \\ s^{-1}}$。\n\n首先，我们计算所需的量：\n- 慢度：$s = \\frac{1}{v} = \\frac{1}{2000} \\ \\mathrm{s \\ m^{-1}} = 0.0005 \\ \\mathrm{s \\ m^{-1}}$。\n- 穿过一个网格单元的时间：$sh = (0.0005 \\ \\mathrm{s \\ m^{-1}}) \\times (10 \\ \\mathrm{m}) = 0.005 \\ \\mathrm{s}$。\n- 邻居节点走时差：$b-a = 0.120 \\ \\mathrm{s} - 0.100 \\ \\mathrm{s} = 0.020 \\ \\mathrm{s}$。\n\n接下来，我们检查条件以确定使用哪个更新公式：\n$b-a \\ge sh$ 是否成立？\n$$0.020 \\ \\mathrm{s} \\ge 0.005 \\ \\mathrm{s}$$\n该条件满足。这意味着更新是单边的，波前实际上仅从最近的邻居节点的方向到达。\n\n我们使用单边更新公式：\n$$T = a + sh$$\n$$T = 0.100 \\ \\mathrm{s} + 0.005 \\ \\mathrm{s} = 0.105 \\ \\mathrm{s}$$\n\n问题要求答案四舍五入到四位有效数字。\n$$T = 0.1050 \\ \\mathrm{s}$$\n这是最终更新的走时。",
            "answer": "$$\\boxed{0.1050}$$"
        },
        {
            "introduction": "在局部更新逻辑的基础上，本次实践将指导您使用快速行进法（Fast Marching Method, FMM）构建一个完整且高效的程函方程求解器。您将实现一个类 Dijkstra 算法，从多个震源向外传播走时，并确保每一步都遵循因果关系。这个练习  展示了一个强大的实际应用：计算来自多个震源的初至波场，这会基于“获胜”的波前自然地对区域进行类似 Voronoi 图的划分。",
            "id": "3588118",
            "problem": "要求您设计并实现一个数值求解器，用于求解各向同性程函方程，以在均匀的二维笛卡尔网格上计算多源走时场，并识别出定义域中每个点源的依赖区域所形成的类 Voronoi 划分。此任务的基础是在高频极限下的几何光学，其中沿曲线的走时是可加的，并且射线使走时取极值。这导出了各向同性程函方程的 Hamilton-Jacobi 形式。该问题必须在矩形网格上以纯数学方式求解，并为所有量明确指定物理单位。\n\n出发点和定义。考虑一个有界矩形域，在两个方向上均以间距 $h$ 的均匀网格进行离散化。设 $v(x,y)$ 表示定义域上严格为正且有界的各向同性速度场，单位为米/秒。对于一个有限点源集 $\\{x_s^{(i)}\\}_{i=1}^M$，多源走时 $T(x,y)$ 满足程函方程\n$$\n\\lvert \\nabla T(x,y) \\rvert \\;=\\; \\frac{1}{v(x,y)} \\quad \\text{在定义域内，}\n$$\n并满足 Dirichlet 边界条件 $T(x_s^{(i)}) = 0$，适用于所有源 $i \\in \\{1,\\dots,M\\}$。源 $i$ 的依赖域（类 Voronoi 单元）是所有源中由源 $i$ 实现最小到达时间的点的集合。\n\n算法要求。您必须从第一性原理推导出一个适用于类 Dijkstra 接受顺序（即基于走时递增的单遍方法）的程函方程的迎风、单调离散化方案。您的求解器必须：\n- 仅使用局部迎风信息，从已被接受的邻居节点更新网格节点的走时。\n- 通过始终从最小优先队列中接受当前最小的试探走时来保证因果性。\n- 通过将所有源节点的走时初始化为零，并传播一个标签场来识别每个被接受节点所依赖的源，从而正确处理多源问题。如果两个或多个源在某个节点处产生的走时在很小的容差范围内完全相等，则通过选择最小的源索引来确定性地打破平局。\n- 在网格上使用四邻域连通。\n- 当 $v$ 的单位为米/秒，网格坐标单位为米时，产生以秒为单位的走时 $T$。\n\n您的程序必须实现该求解器并为以下测试套件生成答案。在所有情况下，定义域均为 $[0,1]\\times[0,1]$ 米，由 $N \\times N$ 个网格点离散化，其中 $N=101$，因此网格间距为 $h = 1/(N-1)$ 米。网格点坐标位于 $(x_i,y_j) = (i h, j h)$，其中整数 $i,j \\in \\{0,\\dots,N-1\\}$。所有角度（如有）必须以弧度为单位，但该问题中并未明确出现角度。\n\n测试套件：\n1. 恒定速度、单源准确性。设 $v(x,y) \\equiv 2.0$ 米/秒。在 $(x_s,y_s) = (0.25,0.5)$ 米处放置一个单源，位于最近的网格点上。计算数值走时场 $T_{\\text{num}}$。对于此恒定速度情况，解析解为 $T_{\\text{ana}}(x,y) = \\sqrt{(x-x_s)^2 + (y-y_s)^2} / 2.0$ 秒。计算最大绝对误差 $E_{\\infty} = \\max_{i,j} \\lvert T_{\\text{num}}(x_i,y_j) - T_{\\text{ana}}(x_i,y_j) \\rvert$，单位为秒。\n2. 恒定速度、双源划分平衡性。设 $v(x,y) \\equiv 2.0$ 米/秒。在 $(x_s^{(1)},y_s^{(1)}) = (0.10,0.50)$ 米和 $(x_s^{(2)},y_s^{(2)}) = (0.90,0.50)$ 米处放置两个源，每个源都位于最近的网格点上。计算标签场 $\\ell(x_i,y_j) \\in \\{0,1\\}$，该场标识在每个网格点上产生最小到达时间的源，平局时倾向于最小索引。计算标记为 $\\ell=0$ 的网格点所占的比例 $f_0$。报告绝对偏差 $\\lvert f_0 - 0.5 \\rvert$，结果为无量纲小数。\n3. 非均匀速度下划分的尺度不变性。设基准速度场为 $v(x,y) = 2.0$ 米/秒，但在以 $(0.35,0.50)$ 米为中心、半径为 $0.15$ 米的圆盘内部，$v(x,y) = 0.5$ 米/秒。在 $(x_s^{(1)},y_s^{(1)}) = (0.10,0.50)$ 米和 $(x_s^{(2)},y_s^{(2)}) = (0.90,0.50)$ 米处放置两个源，每个源都位于最近的网格点上。计算基准速度场 $v$ 的标签场 $\\ell_{\\text{base}}$。然后定义一个缩放后的速度场 $v'(x,y) = \\alpha v(x,y)$，其中 $\\alpha = 3.7$（无量纲），并计算 $v'$ 下的标签场 $\\ell_{\\text{scaled}}$。报告一个布尔值，指示 $\\ell_{\\text{base}}$ 和 $\\ell_{\\text{scaled}}$ 在所有网格点上是否完全相同。\n\n最终输出格式。您的程序必须生成单行输出，其中包含三个测试用例的结果，格式为方括号括起来的逗号分隔列表，顺序如下：$[E_{\\infty}, \\lvert f_0 - 0.5 \\rvert, \\text{label\\_invariance}]$。第一个数字 $E_{\\infty}$ 必须以秒为单位表示，并四舍五入到六位小数；第二个数字 $\\lvert f_0 - 0.5 \\rvert$ 必须四舍五入到六位小数；第三个值必须是字面布尔标记 True 或 False。例如，输出格式必须类似于 $[0.003127,0.000000,True]$。",
            "solution": "在笛卡尔网格上计算多源走时场的问题是求解程函方程的经典应用，程函方程是几何光学和计算地球物理学的基石。解决方案需要推导数值格式并实现一个遵循因果性的高效求解器。\n\n控制方程是各向同性程函方程：\n$$\n|\\nabla T(x,y)| = \\frac{1}{v(x,y)} = s(x,y)\n$$\n此处，$T(x,y)$ 是以秒为单位的走时场，$v(x,y)$ 是以米/秒为单位的波传播速度，$s(x,y)$ 是以秒/米为单位的慢度。该方程是一个 Hamilton-Jacobi 类型的非线性偏微分方程。边界条件由 $T(x_s^{(i)}) = 0$ 给出，适用于一组源 $\\{x_s^{(i)}\\}$。多源走时场是来自任一源的最小到达时间，即 $T(x,y) = \\min_i T_i(x,y)$，其中 $T_i$ 是来自源 $i$ 的走时。\n\n核心的物理原理是因果性：某一点的走时只能由走时更小的点确定。这提示计算中需要有一个顺序，即信息从源点向外传播，很像惠更斯原理。快速行进法（Fast Marching Method, FMM）就是为此设计的。它是一种基于网格的算法，采用类 Dijkstra 方法在单遍扫描中求解程函方程。网格点被分为三类：\n1.  **已接受（Accepted 或 Frozen）**：已计算出最终走时的点。\n2.  **试探（Trial 或 Narrow Band）**：邻近已接受点集的点，已为其计算出试探走时。这些点是待接受的候选点。\n3.  **未见（Unseen 或 Far Away）**：所有其他点，其走时被初始化为无穷大。\n\nFMM 算法维护一个由试探点组成的最小优先队列，这些点按其试探走时排序。算法通过重复以下步骤进行：接受具有最小走时的试探点，将其移至已接受集合，然后更新其未见或试探邻居的走时。\n\n为推导更新规则，我们在间距为 $h$ 的均匀网格上离散化程函方程。为了保证稳定性和遵循因果性，必须采用迎风、一阶有限差分格式。在网格点 $(i,j)$ 处，梯度平方 $|\\nabla T|^2 = (\\partial T/\\partial x)^2 + (\\partial T/\\partial y)^2$ 近似为：\n$$\n\\left(\\max\\left( \\frac{T_{i,j}-T_{i-1,j}}{h}, \\frac{T_{i,j}-T_{i+1,j}}{-h}, 0 \\right)\\right)^2 + \\left(\\max\\left( \\frac{T_{i,j}-T_{i,j-1}}{h}, \\frac{T_{i,j}-T_{i,j+1}}{-h}, 0 \\right)\\right)^2 = s_{i,j}^2\n$$\n在 FMM 中，当我们更新 $T_{i,j}$ 时，我们只使用来自走时更小的、已被接受的邻居的信息。设 $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $T_y = \\min(T_{i,j-1}, T_{i,j+1})$ 分别为 $x$ 和 $y$ 方向上已接受邻居的最小走时。由于我们预期 $T_{i,j}$ 会大于其已接受的邻居，方程简化为：\n$$\n\\left(\\frac{T_{i,j}-T_x}{h}\\right)^2 + \\left(\\frac{T_{i,j}-T_y}{h}\\right)^2 = s_{i,j}^2\n$$\n这是一个关于新时间 $T = T_{i,j}$ 的二次方程：$aT^2 + bT + c = 0$，其中 $a=2$，$b=-2(T_x+T_y)$，$c=T_x^2+T_y^2-(hs_{i,j})^2$。取较大的根（对应于向外传播）可得：\n$$\nT = \\frac{T_x+T_y+\\sqrt{2(hs_{i,j})^2 - (T_x-T_y)^2}}{2}\n$$\n仅当波前从涉及两个坐标轴的方向到达时，这种二维更新才具有物理意义。一个简单而稳健的条件是将一维更新时间与较远邻居的走时进行比较。设 $T_1 = \\min(T_x, T_y)$ 和 $T_2 = \\max(T_x, T_y)$。如果波前纯粹从 $T_1$ 的方向传播，则更新应为 $T = T_1 + hs_{i,j}$。如果这个一维更新后的时间小于或等于 $T_2$，则意味着来自 $T_2$ 邻居的特征线没有到达点 $(i,j)$，因此一维更新是合适的。因此，更新规则如下：\n1.  如果只有一个方向（例如 $x$ 方向）的邻居被接受，使用一维更新：$T = T_x + hs_{i,j}$。\n2.  如果两个方向都有已接受的邻居，设 $T_1=\\min(T_x, T_y)$ 和 $T_2=\\max(T_x, T_y)$。\n    - 如果 $T_2 - T_1 \\ge hs_{i,j}$，使用一维更新：$T = T_1 + hs_{i,j}$。\n    - 否则，使用上述的二维二次方程解。\n\n为了处理多源问题并确定类 Voronoi 划分，我们修改 FMM 来追踪每个传播波前的来源。我们将所有源位置初始化到优先队列中，每个源的走时都为零。优先队列中的项目变为 `(time, source_index, i, j)` 形式的元组。Python 的 `heapq` 库在处理此类元组时，会首先按时间排序，然后使用 `source_index` 作为平局决胜规则。这优雅且正确地实现了指定的平局打破规则。当一个节点被接受时，其走时和它对特定源的依赖关系（其标签）会同时被最终确定。然后，在邻居节点的更新步骤中，已接受节点的标签会传播给它们。这种集成方法可以在单次高效的传递中计算出最小走时场和源依赖划分。\n\n测试用例验证了三个关键方面：\n1.  **准确性**：在恒速介质中与解析解进行比较，以检验数值格式的正确性和收敛阶。\n2.  **划分**：在恒速介质中的对称双源问题测试了多源逻辑和平局打破规则。由于对称性，定义域应几乎被平分为两半，任何偏差都源于离散网格和确定性的平局打破规则。\n3.  **不变性**：程函方程具有尺度对称性。如果慢度场按常数缩放，$s'(x,y) = s(x,y)/\\alpha$，则走时也同样被缩放，$T'(x,y) = T(x,y)/\\alpha$。然而，作为最小走时路径的射线路径保持不变。因此，基于初至时间的定义域的类 Voronoi 划分对于 $v(x,y)$ 和 $v'(x,y) = \\alpha v(x,y)$ 应该是相同的。此测试验证了解的一个基本物理性质。",
            "answer": "```python\nimport numpy as np\nimport heapq\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the eikonal solver.\n    \"\"\"\n\n    def run_fmm_solver(N, h, speed_field, sources_coords):\n        \"\"\"\n        Solves the isotropic eikonal equation for multiple sources on a 2D grid\n        using the Fast Marching Method (FMM).\n\n        Args:\n            N (int): Grid dimension (N x N).\n            h (float): Grid spacing in meters.\n            speed_field (np.ndarray): N x N array of wave speeds (m/s).\n            sources_coords (list): A list of (x, y) tuples for source locations in meters.\n\n        Returns:\n            tuple: A tuple containing:\n                - times (np.ndarray): N x N array of first-arrival travel times (s).\n                - labels (np.ndarray): N x N array of source indices for the first arrival.\n        \"\"\"\n        # State constants for grid points\n        ACCEPTED = 0\n        TRIAL = 1\n        UNSEEN = 2\n\n        # Initialize data structures\n        times = np.full((N, N), np.inf, dtype=np.float64)\n        labels = np.full((N, N), -1, dtype=np.int32)\n        states = np.full((N, N), UNSEEN, dtype=np.int8)\n        pq = []  # Min-priority queue\n\n        slowness_field = 1.0 / speed_field\n\n        # Initialize sources in the priority queue\n        for label_idx, (sx, sy) in enumerate(sources_coords):\n            i_s = int(round(sx / h))\n            j_s = int(round(sy / h))\n            \n            i_s = np.clip(i_s, 0, N - 1)\n            j_s = np.clip(j_s, 0, N - 1)\n\n            # In case multiple sources map to the same grid point, the one with the\n            # smaller index will be processed first due to tie-breaking in the heap.\n            if times[i_s, j_s] > 0.0:\n                times[i_s, j_s] = 0.0\n                states[i_s, j_s] = TRIAL\n                heapq.heappush(pq, (0.0, label_idx, i_s, j_s))\n\n        # Main FMM loop\n        while pq:\n            time, label, i, j = heapq.heappop(pq)\n\n            if states[i, j] == ACCEPTED:\n                continue\n            \n            states[i, j] = ACCEPTED\n            labels[i, j] = label\n\n            # Propagate information to neighbors\n            for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                # Check boundary conditions and if neighbor is already accepted\n                if not (0 = ni  N and 0 = nj  N) or states[ni, nj] == ACCEPTED:\n                    continue\n\n                # Find minimum times of accepted neighbors in x and y directions\n                t_x_min = np.inf\n                if ni > 0 and states[ni - 1, nj] == ACCEPTED:\n                    t_x_min = min(t_x_min, times[ni - 1, nj])\n                if ni  N - 1 and states[ni + 1, nj] == ACCEPTED:\n                    t_x_min = min(t_x_min, times[ni + 1, nj])\n                \n                t_y_min = np.inf\n                if nj > 0 and states[ni, nj - 1] == ACCEPTED:\n                    t_y_min = min(t_y_min, times[ni, nj - 1])\n                if nj  N - 1 and states[ni, nj + 1] == ACCEPTED:\n                    t_y_min = min(t_y_min, times[ni, nj + 1])\n                \n                # Calculate time update based on available neighbors\n                hs = h * slowness_field[ni, nj]\n                t_new = np.inf\n\n                if t_x_min != np.inf and t_y_min != np.inf:\n                    t1, t2 = (t_x_min, t_y_min) if t_x_min = t_y_min else (t_y_min, t_x_min)\n                    if (t2 - t1)  hs:\n                        radicand = 2.0 * hs**2 - (t1 - t2)**2\n                        t_new = (t1 + t2 + math.sqrt(radicand)) / 2.0\n                    else:\n                        t_new = t1 + hs\n                elif t_x_min != np.inf:\n                    t_new = t_x_min + hs\n                elif t_y_min != np.inf:\n                    t_new = t_y_min + hs\n                \n                # If a shorter path to the neighbor is found, update it and push to queue\n                if t_new  times[ni, nj]:\n                    times[ni, nj] = t_new\n                    states[ni, nj] = TRIAL\n                    heapq.heappush(pq, (t_new, label, ni, nj))\n\n        return times, labels\n\n    N = 101\n    h = 1.0 / (N - 1)\n    results = []\n\n    # --- Test Case 1: Constant-speed, single source accuracy ---\n    v1 = 2.0\n    speed_field_1 = np.full((N, N), v1)\n    source_1_coord = (0.25, 0.5)\n    sources_1 = [source_1_coord]\n    \n    t_num_1, _ = run_fmm_solver(N, h, speed_field_1, sources_1)\n    \n    x_coords = np.linspace(0, 1, N)\n    y_coords = np.linspace(0, 1, N)\n    xx, yy = np.meshgrid(x_coords, y_coords, indexing='ij')\n    \n    t_ana_1 = np.sqrt((xx - source_1_coord[0])**2 + (yy - source_1_coord[1])**2) / v1\n    \n    e_inf = np.max(np.abs(t_num_1 - t_ana_1))\n    results.append(round(e_inf, 6))\n\n    # --- Test Case 2: Constant-speed, two sources partition balance ---\n    v2 = 2.0\n    speed_field_2 = np.full((N, N), v2)\n    sources_2 = [(0.10, 0.50), (0.90, 0.50)]\n    \n    _, labels_2 = run_fmm_solver(N, h, speed_field_2, sources_2)\n    \n    f0 = np.sum(labels_2 == 0) / (N * N)\n    dev_f0 = abs(f0 - 0.5)\n    results.append(round(dev_f0, 6))\n\n    # --- Test Case 3: Heterogeneous-speed scaling invariance of partition ---\n    v_bg = 2.0\n    v_slow = 0.5\n    disk_center = (0.35, 0.50)\n    disk_radius = 0.15\n    \n    speed_field_3_base = np.full((N, N), v_bg)\n    is_in_disk = (xx - disk_center[0])**2 + (yy - disk_center[1])**2 = disk_radius**2\n    speed_field_3_base[is_in_disk] = v_slow\n    \n    sources_3 = [(0.10, 0.50), (0.90, 0.50)]\n    \n    _, labels_base = run_fmm_solver(N, h, speed_field_3_base, sources_3)\n    \n    alpha = 3.7\n    speed_field_3_scaled = alpha * speed_field_3_base\n    _, labels_scaled = run_fmm_solver(N, h, speed_field_3_scaled, sources_3)\n    \n    label_invariance = np.array_equal(labels_base, labels_scaled)\n    results.append(label_invariance)\n\n    # Format and print final output\n    print(f\"[{results[0]},{results[1]},{results[2]}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这最后一个实践要求您通过在计算域中引入不可穿透的障碍物或“空洞”，来调整您的求解器以处理复杂的地质情景。这项任务需要修改快速行进算法以考虑这些拓扑约束，从而允许波在其周围发生衍射。通过这个练习 ，您将探索并量化重要的物理现象，如阴影区和走时延迟，从而弥合数值方法与其在现实地球物理模型中应用之间的差距。",
            "id": "3588086",
            "problem": "考虑在二维空间中由程函方程控制的各向同性初至走时，对于一个域 $\\Omega \\subset \\mathbb{R}^2$ 上的标量走时场 $T(\\mathbf{x})$ 和速度场 $v(\\mathbf{x})$，该方程表示为\n$$\n\\lvert \\nabla T(\\mathbf{x}) \\rvert = \\frac{1}{v(\\mathbf{x})} \\quad \\text{for } \\mathbf{x} \\in \\Omega,\n$$\n在点源 $\\mathbf{x}_s \\in \\Omega$ 处有狄利克雷边界条件 $T(\\mathbf{x}_s)=0$。设一个子集 $\\mathcal{H} \\subset \\Omega$ 代表不可渗透的空洞（孔洞），并定义计算域 $D = \\Omega \\setminus \\mathcal{H}$。走时 $T(\\mathbf{x})$ 仅在 $D$ 上定义，并且特征线不能穿过 $\\partial \\mathcal{H}$。您将研究 $\\mathcal{H}$ 的拓扑结构如何产生阴影区域，这些区域通过相对于均匀无障碍情况的额外走时来量化。\n\n您必须实现一个基于与快速行进法（Fast Marching Method, FMM）一致的迎风因果传播的求解器，使用网格间距为 $\\Delta x = \\Delta y = h$ 的均匀笛卡尔网格和四点模板，以计算 $T(\\mathbf{x})$ 在 $D$ 上的近似值。从物理走时遵循最小化慢度路径积分的路径的基本变分原理，以及程函方程的定义出发。推导出一个网格点上的严格迎风局部更新，该更新与梯度范数的单调离散化一致，并遵守因果性。不允许在孔洞内部进行更新；这些位置被排除在 $D$ 之外。\n\n定义一个均匀速度 $v(\\mathbf{x}) \\equiv v_0$（单位：米/秒）和一个正方形域 $\\Omega = [0,L]\\times[0,L]$（单位：米）。使用一个点源 $\\mathbf{x}_s=(x_s,y_s)$，其 $T(\\mathbf{x}_s)=0$。设一个探测点 $\\mathbf{x}_p=(x_p,y_p)$ 用于量化走时延迟。\n\n为量化由孔洞引起的阴影效应，对于任何网格点 $\\mathbf{x}$，定义无障碍均匀基线\n$$\nT_{\\mathrm{free}}(\\mathbf{x}) = \\frac{\\|\\mathbf{x}-\\mathbf{x}_s\\|_2}{v_0},\n$$\n并称一个网格点为视线被阻挡，如果连接 $\\mathbf{x}_s$ 和 $\\mathbf{x}$ 的线段与 $\\mathcal{H}$ 中任何孔洞的内部相交。对于给定的阈值 $\\delta$（单位：秒），定义阴影集\n$$\nS_{\\mathrm{shadow}} = \\left\\{ \\mathbf{x} \\in D \\,:\\, \\text{视线被阻挡且 } T(\\mathbf{x}) - T_{\\mathrm{free}}(\\mathbf{x}) \\ge \\delta \\text{ 且 } T(\\mathbf{x}) \\text{ 是有限的} \\right\\}.\n$$\n设阴影面积分数为 $S_{\\mathrm{shadow}}$ 中网格点的数量与 $D$ 中网格点的数量之比。\n\n实现以下测试套件，所有距离单位为米，时间单位为秒：\n\n- 所有测试共用的网格和源参数：\n  - $L = 1000$， $h=10$，因此有 $N_x=N_y=101$ 个网格点，其坐标为 $x_i=i\\,h$, $y_j=j\\,h$，其中整数 $i,j \\in \\{0,1,\\ldots,100\\}$。\n  - $v_0 = 2000\\,\\mathrm{m/s}$，因此慢度为 $1/v_0$（单位：$\\mathrm{s/m}$）。\n  - 源位于 $\\mathbf{x}_s=(100,500)$，即网格索引 $(i_s,j_s)=(10,50)$。\n  - 探测点位于 $\\mathbf{x}_p=(800,500)$，即网格索引 $(i_p,j_p)=(80,50)$。\n  - 阈值 $\\delta=0.01$ (秒)。\n\n- 测试用例 1（单个有限障碍物导致绕行但仍可达）：一个矩形孔洞 $\\mathcal{H}_1 = [450,550]\\times[400,600]$。\n\n- 测试用例 2（无障碍物基线）：$\\mathcal{H}_2 = \\varnothing$。\n\n- 测试用例 3（造成不可达区域的隔离墙）：一个横跨域高度的垂直矩形孔洞，$\\mathcal{H}_3 = [450,550]\\times[0,1000]$。\n\n对于每个测试用例 $k \\in \\{1,2,3\\}$，计算：\n- 探测点处的延迟（单位：秒），定义为 $D_k = T_k(\\mathbf{x}_p) - T_{\\mathrm{free}}(\\mathbf{x}_p)$，其中 $T_k$ 是为测试 $k$ 计算的场。如果在测试 $k$ 中 $\\mathbf{x}_p$ 不可达，则对 $T_k(\\mathbf{x}_p)$ 使用 $+\\infty$，因此 $D_k=+\\infty$。\n- 如上定义的阴影面积分数 $F^{\\mathrm{shadow}}_k$（无量纲小数）。\n- 不可达分数 $F^{\\mathrm{unreach}}_k$，定义为 $D$ 中 $T_k$ 不是有限值的网格点数与 $D$ 中总网格点数之比（无量纲小数）。\n\n所有时间必须以秒表示，所有分数必须以 $[0,1]$ 范围内的十进制小数表示。本问题不使用角度单位。\n\n您的程序必须生成单行输出，其中包含按以下确切格式聚合为列表的列表的结果（无空格）：\n- 输出必须是\n$$\n\\big[ [D_1, F^{\\mathrm{shadow}}_1, F^{\\mathrm{unreach}}_1], [D_2, F^{\\mathrm{shadow}}_2, F^{\\mathrm{unreach}}_2], [D_3, F^{\\mathrm{shadow}}_3, F^{\\mathrm{unreach}}_3] \\big],\n$$\n使用标准浮点字符串表示法打印为单行，括号和逗号与所示完全相同，无其他文本。例如：\n$[[0.0123,0.045,0.0],[0.0,0.0,0.0],[inf,0.12,0.49]]$。\n\n您的实现必须是自包含的，并且不得读取任何输入。套件中每个测试的答案必须是一个浮点数三元组。最终程序必须遵守指定的执行环境。",
            "solution": "所提出的问题是有效的，因为它在科学上基于波传播的原理，在数学上是适定的，并用客观、无歧义的参数进行了规定。我现在将着手提供一个完整的解决方案。\n\n该问题要求计算包含不可渗透空洞的二维介质中的初至走时。该物理过程由程函方程控制，这是一个非线性一阶偏微分方程。\n\n程函方程由下式给出\n$$\n\\lvert \\nabla T(\\mathbf{x}) \\rvert = s(\\mathbf{x}),\n$$\n其中 $T(\\mathbf{x})$ 是走时场，$s(\\mathbf{x}) = 1/v(\\mathbf{x})$ 是慢度（速度的倒数）。在本问题中，介质是均匀的，速度为 $v_0$，因此慢度 $s$ 是一个常数，$s=1/v_0$。在二维笛卡尔坐标系中，此方程展开为：\n$$\n\\left( \\frac{\\partial T}{\\partial x} \\right)^2 + \\left( \\frac{\\partial T}{\\partial y} \\right)^2 = s^2.\n$$\n该方程是一个静态 Hamilton-Jacobi 方程。它通过在源点 $\\mathbf{x}_s$ 处的边界条件 $T(\\mathbf{x}_s) = 0$ 来求解。解 $T(\\mathbf{x})$ 表示从 $\\mathbf{x}_s$ 到域中任意点 $\\mathbf{x}$ 的最短传播时间。\n\n我们的任务是在一个间距为 $h=\\Delta x = \\Delta y$ 的均匀笛卡尔网格上数值求解此方程。求解方法必须与快速行进法（FMM）一致，该方法尊重波传播的因果性。FMM通过从源点向外系统地构建解来求解方程。该方法的核心是一个局部更新规则，用于根据一个网格点已经计算出的“迎风”邻居的走时来更新该点的走时。\n\n**迎风有限差分格式的推导**\n\n因果性原理规定，网格点 $(i,j)$ 处的走时 $T$ 只能依赖于走时较小的邻居。我们使用一阶、单边迎风差分来近似偏导数。梯度范数平方的迎风格式为：\n$$\n\\left( \\max\\left( D^{-x}_{i,j}T, -D^{+x}_{i,j}T, 0 \\right) \\right)^2 + \\left( \\max\\left( D^{-y}_{i,j}T, -D^{+y}_{i,j}T, 0 \\right) \\right)^2 = s^2,\n$$\n其中 $D^{-x}_{i,j}T = (T_{i,j} - T_{i-1,j})/h$， $D^{+x}_{i,j}T = (T_{i+1,j} - T_{i,j})/h$，依此类推。在FMM的背景下，当我们计算时间 $T_{i,j}$ 时，我们只使用已经最终确定（接受）的邻居值。设 $x$ 和 $y$ 方向上已接受的最小邻居时间分别为 $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $T_y = \\min(T_{i,j-1}, T_{i,j+1})$。对于未知时间 $T \\equiv T_{i,j}$ 的离散程函方程变为：\n$$\n(\\max(0, T - T_x))^2 + (\\max(0, T - T_y))^2 = (sh)^2.\n$$\n假设 $T > T_x$ 且 $T > T_y$，这简化为一个关于 $T$ 的二次方程：\n$$\n(T - T_x)^2 + (T - T_y)^2 = (sh)^2.\n$$\n展开此式得到 $2T^2 - 2T(T_x + T_y) + (T_x^2 + T_y^2 - (sh)^2) = 0$。求解 $T$ 并取物理上有意义的较大根，得到：\n$$\nT_{quad} = \\frac{T_x + T_y + \\sqrt{2(sh)^2 - (T_x - T_y)^2}}{2}.\n$$\n此解仅在判别式非负时有效，即 $2(sh)^2 \\ge (T_x - T_y)^2$，或 $|T_x - T_y| \\le \\sqrt{2}sh$。在许多实现中，使用一个更简单的标准 $|T_x - T_y| \\le sh$，这对应于检查 $T_{quad}$ 是否大于 $T_x$ 和 $T_y$。如果此条件不满足，则意味着波主要从一个方向到达。此时更新应仅基于时间最小的邻居，设为 $T_{min} = \\min(T_x, T_y)$。更新规则退化为一维程函方程 $(T - T_{min})^2 = (sh)^2$，这给出 $T = T_{min} + sh$。\n\n因此，完整的局部求解器如下：\n1. 确定已接受的最小邻居时间 $T_x$ 和 $T_y$。\n2. 如果只有一个是有限的（例如 $T_x$），更新为 $T = T_x + sh$。\n3. 如果两者都是有限的，检查判别式 $2(sh)^2 - (T_x - T_y)^2$ 是否非负。\n   a. 如果是，更新为 $T = \\frac{1}{2}(T_x + T_y + \\sqrt{2(sh)^2 - (T_x - T_y)^2})$。\n   b. 如果否，更新为 $T = \\min(T_x, T_y) + sh$。\n\n**快速行进法（FMM）算法**\n\nFMM是一种基于网格的算法，类似于用于在图上寻找最短路径的Dijkstra算法。它将网格点分为三类：\n- **ALIVE**（激活）：其走时已最终确定的点。\n- **TRIAL**（尝试）：ALIVE点的邻居，已为其计算出暂定走时。这些是下一个ALIVE点的候选点。\n- **FAR**（遥远）：所有其他点，其走时初始化为无穷大。\n\n算法过程如下：\n1.  **初始化**：\n    - 走时数组 $T$ 初始化为 $\\infty$，除了源点 $T(\\mathbf{x}_s) = 0$。\n    - 所有点的状态为 `FAR`。\n    - 创建一个最小优先队列（最小堆）来存储 `TRIAL` 点，按其暂定走时排序。\n    - 将源点 $\\mathbf{x}_s$ 以时间 $0$ 添加到优先队列，并将其状态设置为 `TRIAL`。\n\n2.  **行进循环**：当优先队列不为空时：\n    a. 从队列中提取具有最小走时的点 $\\mathbf{x}_{min}$。\n    b. 如果其状态已经是 `ALIVE`，则忽略它并继续（这处理了单个点的多个递减时间估计被添加到队列的情况）。\n    c. 将 $\\mathbf{x}_{min}$ 的状态设置为 `ALIVE`。它的时间现在是最终的。\n    d. 对于 $\\mathbf{x}_{min}$ 的每个邻居 $\\mathbf{x}_n$：\n        i.  如果 $\\mathbf{x}_n$ 在孔洞内或是 `ALIVE` 状态，则忽略它。\n        ii. 使用上述局部求解器，根据其 `ALIVE` 邻居为 $\\mathbf{x}_n$ 计算一个新的暂定时间。\n        iii. 如果这个新时间小于当前为 $\\mathbf{x}_n$ 存储的时间，则将 $T(\\mathbf{x}_n)$ 更新为新时间，将 $\\mathbf{x}_n$ 的状态设置为 `TRIAL`，并将 $(\\text{新时间}, \\mathbf{x}_n)$ 添加到优先队列。\n\n循环在队列为空时终止。此时，域 $D = \\Omega \\setminus \\mathcal{H}$ 中所有可达的点都将有其正确的初至走时。与源不连通的区域中的点将保留其初始走时 $\\infty$。\n\n**度量指标的计算**\n\n对于每个测试用例，在计算走时场 $T_k$ 之后，我们计算所需的度量指标：\n- **延迟 $D_k$**：探测点处的计算时间 $T_k(\\mathbf{x}_p)$ 与直线传播时间 $T_{\\mathrm{free}}(\\mathbf{x}_p) = \\|\\mathbf{x}_p - \\mathbf{x}_s\\|_2/v_0$ 之间的差值。如果 $T_k(\\mathbf{x}_p)$ 是 $\\infty$，则 $D_k$ 是 $\\infty$。\n- **不可达分数 $F^{\\mathrm{unreach}}_k$**：计算域 $D$ 中 $T_k = \\infty$ 的点数除以 $D$ 中的总点数。\n- **阴影面积分数 $F^{\\mathrm{shadow}}_k$**：阴影集 $S_{\\mathrm{shadow}}$ 中的点数除以 $D$ 中的总点数。一个点 $\\mathbf{x}$ 属于 $S_{\\mathrm{shadow}}$ 如果它满足三个条件：\n    1.  其走时 $T_k(\\mathbf{x})$ 是有限的。\n    2.  走时延迟 $T_k(\\mathbf{x}) - T_{\\mathrm{free}}(\\mathbf{x})$ 至少为 $\\delta$。\n    3.  从 $\\mathbf{x}_s$ 到 $\\mathbf{x}$ 的直线路径被孔洞阻挡。这个视线检查使用一个鲁棒的线段-矩形相交测试（例如，Liang-Barsky 算法）来执行，该测试确定线段是否与任何孔洞矩形的内部相交。\n实现将遵循这些原则来解决三个指定的测试用例。",
            "answer": "```python\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Solves the eikonal equation for three test cases using the Fast Marching Method,\n    and computes travel-time delay, shadow fraction, and unreachable fraction.\n    \"\"\"\n    # Define common parameters\n    L = 1000.0\n    h = 10.0\n    v0 = 2000.0\n    source_pos = (100.0, 500.0)\n    probe_pos = (800.0, 500.0)\n    delta = 0.01\n\n    slowness = 1.0 / v0\n    sh = slowness * h\n    sh_sq = sh**2\n\n    nx = int(L / h) + 1\n    ny = int(L / h) + 1\n    source_idx = (int(source_pos[0] / h), int(source_pos[1] / h))\n    probe_idx = (int(probe_pos[0] / h), int(probe_pos[1] / h))\n\n    # Pre-calculate coordinate and free-space travel time grids\n    x_coords = np.arange(nx) * h\n    y_coords = np.arange(ny) * h\n    grid_x, grid_y = np.meshgrid(x_coords, y_coords, indexing='ij')\n    \n    dist_from_source = np.sqrt((grid_x - source_pos[0])**2 + (grid_y - source_pos[1])**2)\n    T_free_grid = dist_from_source / v0\n\n    # Define test cases with hole geometries\n    test_cases = [\n        {'rects': [[450.0, 550.0, 400.0, 600.0]]}, # Case 1\n        {'rects': []},                            # Case 2\n        {'rects': [[450.0, 550.0, 0.0, 1000.0]]}   # Case 3\n    ]\n\n    # FMM states\n    FAR, TRIAL, ALIVE = 0, 1, 2\n\n    def get_hole_mask(rects):\n        mask = np.zeros((nx, ny), dtype=bool)\n        if not rects:\n            return mask\n        for rect in rects:\n            x_min, x_max, y_min, y_max = rect\n            mask |= (grid_x >= x_min)  (grid_x = x_max)  (grid_y >= y_min)  (grid_y = y_max)\n        return mask\n\n    def solve_eikonal_fmm(hole_mask):\n        times = np.full((nx, ny), np.inf, dtype=np.float64)\n        states = np.full((nx, ny), FAR, dtype=np.uint8)\n        \n        times[source_idx] = 0.0\n        pq = [(0.0, source_idx[0], source_idx[1])]\n        states[source_idx] = TRIAL\n\n        while pq:\n            time, ix, iy = heapq.heappop(pq)\n            \n            if states[ix, iy] == ALIVE:\n                continue\n            \n            states[ix, iy] = ALIVE\n            \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx_ix, nx_iy = ix + dx, iy + dy\n                \n                if not (0 = nx_ix  nx and 0 = nx_iy  ny and not hole_mask[nx_ix, nx_iy]):\n                    continue\n                \n                if states[nx_ix, nx_iy] == ALIVE:\n                    continue\n\n                t_x_neighbors = []\n                if nx_ix > 0 and states[nx_ix - 1, nx_iy] == ALIVE: t_x_neighbors.append(times[nx_ix - 1, nx_iy])\n                if nx_ix  nx - 1 and states[nx_ix + 1, nx_iy] == ALIVE: t_x_neighbors.append(times[nx_ix + 1, nx_iy])\n\n                t_y_neighbors = []\n                if nx_iy > 0 and states[nx_ix, nx_iy - 1] == ALIVE: t_y_neighbors.append(times[nx_ix, nx_iy - 1])\n                if nx_iy  ny - 1 and states[nx_ix, nx_iy + 1] == ALIVE: t_y_neighbors.append(times[nx_ix, nx_iy + 1])\n                \n                t_x = min(t_x_neighbors) if t_x_neighbors else np.inf\n                t_y = min(t_y_neighbors) if t_y_neighbors else np.inf\n                \n                new_time = np.inf\n                if t_x != np.inf and t_y != np.inf:\n                    discriminant = 2 * sh_sq - (t_x - t_y)**2\n                    if discriminant >= 0:\n                        new_time = (t_x + t_y + np.sqrt(discriminant)) / 2.0\n                    else:\n                        new_time = min(t_x, t_y) + sh\n                elif t_x != np.inf:\n                    new_time = t_x + sh\n                elif t_y != np.inf:\n                    new_time = t_y + sh\n                \n                if new_time  times[nx_ix, nx_iy]:\n                    times[nx_ix, nx_iy] = new_time\n                    states[nx_ix, nx_iy] = TRIAL\n                    heapq.heappush(pq, (new_time, nx_ix, nx_iy))\n                    \n        return times\n\n    def is_los_blocked(ix, iy, rects):\n        if not rects:\n            return False\n        x_s, y_s = source_pos\n        x_p, y_p = ix * h, iy * h\n        \n        for rect in rects:\n            x_min, x_max, y_min, y_max = rect\n            dx, dy = x_p - x_s, y_p - y_s\n            \n            t_near, t_far = 0.0, 1.0\n            slabs = [ (x_s, dx, x_min, x_max), (y_s, dy, y_min, y_max) ]\n            \n            intersect = True\n            for p, d, slab_min, slab_max in slabs:\n                if abs(d)  1e-9: # Parallel to slab\n                    if not (slab_min  p  slab_max):\n                        intersect = False\n                        break\n                else:\n                    t1 = (slab_min - p) / d\n                    t2 = (slab_max - p) / d\n                    if t1 > t2: t1, t2 = t2, t1\n                    t_near = max(t_near, t1)\n                    t_far = min(t_far, t2)\n                \n            if intersect and t_near  t_far:\n                return True\n        return False\n\n    final_results = []\n    for case in test_cases:\n        rects = case['rects']\n        hole_mask = get_hole_mask(rects)\n        \n        computed_times = solve_eikonal_fmm(hole_mask)\n        \n        # 1. Delay at probe\n        T_probe = computed_times[probe_idx]\n        T_free_probe = T_free_grid[probe_idx]\n        delay = T_probe - T_free_probe\n\n        # 2. Fractions\n        domain_mask = ~hole_mask\n        num_domain_points = np.sum(domain_mask)\n\n        unreachable_mask = domain_mask  (computed_times == np.inf)\n        num_unreachable = np.sum(unreachable_mask)\n        frac_unreachable = num_unreachable / num_domain_points if num_domain_points > 0 else 0.0\n\n        delay_grid = computed_times - T_free_grid\n        \n        shadow_count = 0\n        domain_indices = np.argwhere(domain_mask)\n        for ix, iy in domain_indices:\n            if np.isfinite(computed_times[ix, iy]) and delay_grid[ix, iy] >= delta:\n                if is_los_blocked(ix, iy, rects):\n                    shadow_count += 1\n        \n        frac_shadow = shadow_count / num_domain_points if num_domain_points > 0 else 0.0\n        \n        final_results.append([delay, frac_shadow, frac_unreachable])\n        \n    # Format output string\n    result_strings = []\n    for res in final_results:\n        d, fs, fu = res\n        d_str = str(d).lower()\n        result_strings.append(f\"[{d_str},{fs},{fu}]\")\n        \n    print(f\"[[{','.join(result_strings)}]]\")\n\nsolve()\n```"
        }
    ]
}