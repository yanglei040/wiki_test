{
    "hands_on_practices": [
        {
            "introduction": "To understand the challenge of cycle-skipping, we begin by analyzing the geometry of the standard least-squares ($L^2$) misfit functional in its simplest form. This foundational exercise () strips the problem down to its essentials: the interaction between two time-shifted wavelets. By deriving the exact minimizer and characterizing the region of convexity, you will gain a precise mathematical understanding of the so-called \"half-wavelength\" criterion that governs whether local optimization methods can succeed or fail.",
            "id": "3610613",
            "problem": "In the context of Full-waveform inversion (FWI), consider a single-source, single-receiver trace in continuous time modeled as a Ricker wavelet. Let the source signature be the Ricker wavelet \n$$\nr(t) \\;=\\; \\bigl(1 - 2 \\pi^{2} f_{0}^{2} t^{2}\\bigr)\\,\\exp\\!\\bigl(-\\pi^{2} f_{0}^{2} t^{2}\\bigr),\n$$\nwith central frequency $f_{0}$. Two observed traces are modeled as time-shifted copies of the same signature, \n$$\ns(t) \\,=\\, r\\!\\bigl(t - t_{p1}\\bigr), \n\\qquad\nd(t) \\,=\\, r\\!\\bigl(t - t_{p2}\\bigr),\n$$\nwhere $t_{p1}$ and $t_{p2}$ are the peak times of the two wavelets. Introduce a scalar time-shift parameter $\\tau \\in \\mathbb{R}$ applied to $s(t)$ and define the squared $L^{2}$ norm misfit functional\n$$\nJ(\\tau) \\;=\\; \\tfrac{1}{2}\\,\\int_{-\\infty}^{\\infty} \\Bigl[s\\!\\bigl(t - \\tau\\bigr) \\;-\\; d(t)\\Bigr]^{2}\\, \\mathrm{d}t.\n$$\nAssume noiseless data and that all integrals converge absolutely.\n\nTasks:\n$1.$ Using only the definitions of inner product and cross-correlation, derive the exact minimizer $\\tau^{\\ast}$ of $J(\\tau)$ in terms of $t_{p1}$ and $t_{p2}$. Express $\\tau^{\\ast}$ in seconds.\n\n$2.$ Define the convex basin of $J(\\tau)$ with respect to $\\tau$ as the largest connected open interval around $\\tau^{\\ast}$ on which the second derivative $J^{\\prime\\prime}(\\tau)$ is strictly positive. Using a narrowband approximation tied to the central frequency $f_{0}$—specifically, that the normalized autocorrelation of a narrowband pulse locally behaves like $\\cos\\!\\bigl(2\\pi f_{0}\\,\\delta\\bigr)$ in the time-lag $\\delta$—derive the half-width $\\delta_{c}$ of this convex basin and report the dimensionless ratio $\\delta_{c}/T_{0}$, where the central period $T_{0}$ is $T_{0} \\,=\\, 1/f_{0}$.\n\nProvide your final answer as two entries: the closed-form expression for $\\tau^{\\ast}$, and the exact fraction for $\\delta_{c}/T_{0}$. No rounding is required. If a unit is implied, use seconds for time, and report the basin size as a pure fraction of $T_{0}$ (unitless). Angles, where applicable, must be in radians.",
            "solution": "The problem is evaluated as scientifically sound, well-posed, objective, and self-contained. It presents a standard, albeit simplified, scenario in computational geophysics for studying the properties of the misfit functional in Full-Waveform Inversion (FWI). The tasks are clear and the provided information is sufficient for a rigorous mathematical derivation.\n\nThe solution is presented in two parts, corresponding to the two tasks in the problem statement.\n\n### Part 1: Derivation of the Minimizer $\\tau^{\\ast}$\n\nThe objective is to find the value of $\\tau$, denoted $\\tau^{\\ast}$, that minimizes the squared $L^{2}$ norm misfit functional $J(\\tau)$. The functional is defined as:\n$$\nJ(\\tau) \\;=\\; \\tfrac{1}{2}\\,\\int_{-\\infty}^{\\infty} \\Bigl[s\\!\\bigl(t - \\tau\\bigr) \\;-\\; d(t)\\Bigr]^{2}\\, \\mathrm{d}t\n$$\nTo find the minimizer, we first expand the squared term inside the integral:\n$$\nJ(\\tau) \\;=\\; \\tfrac{1}{2}\\,\\int_{-\\infty}^{\\infty} \\left( s^{2}(t - \\tau) \\;-\\; 2 s(t - \\tau) d(t) \\;+\\; d^{2}(t) \\right) \\mathrm{d}t\n$$\nWe can separate this into three terms:\n$$\nJ(\\tau) \\;=\\; \\tfrac{1}{2} \\left( \\int_{-\\infty}^{\\infty} s^{2}(t - \\tau) \\mathrm{d}t \\;-\\; 2 \\int_{-\\infty}^{\\infty} s(t - \\tau) d(t) \\mathrm{d}t \\;+\\; \\int_{-\\infty}^{\\infty} d^{2}(t) \\mathrm{d}t \\right)\n$$\nThe first and third terms represent the energy of the signals $s(t)$ and $d(t)$, respectively. The energy of a signal is invariant under a time shift. The signals $s(t)$ and $d(t)$ are defined as $s(t) = r(t - t_{p1})$ and $d(t) = r(t - t_{p2})$, which are both time-shifted versions of the same Ricker wavelet $r(t)$. Therefore, their energies are equal:\n$$\n\\int_{-\\infty}^{\\infty} s^{2}(t - \\tau) \\mathrm{d}t = \\int_{-\\infty}^{\\infty} s^{2}(u) \\mathrm{d}u = \\int_{-\\infty}^{\\infty} r^{2}(v) \\mathrm{d}v\n$$\n$$\n\\int_{-\\infty}^{\\infty} d^{2}(t) \\mathrm{d}t = \\int_{-\\infty}^{\\infty} r^{2}(v) \\mathrm{d}v\n$$\nLet $E_{r} = \\int_{-\\infty}^{\\infty} r^{2}(t) \\mathrm{d}t$ be the energy of the Ricker wavelet. The first and third terms are both equal to $E_{r}$.\n\nThe second term involves the cross-correlation of the two signals. The cross-correlation of two real signals $f(t)$ and $g(t)$ is often defined as $(f \\star g)(\\tau) = \\int_{-\\infty}^{\\infty} f(t) g(t+\\tau) \\mathrm{d}t$. The integral in our expression is $\\int_{-\\infty}^{\\infty} s(t - \\tau) d(t) \\mathrm{d}t$. Let's make a substitution $u = t - \\tau$, so $t = u + \\tau$ and $\\mathrm{d}t = \\mathrm{d}u$. The integral becomes:\n$$\n\\int_{-\\infty}^{\\infty} s(u) d(u+\\tau) \\mathrm{d}u \\;=\\; C_{sd}(\\tau)\n$$\nThis is the cross-correlation of $s(t)$ and $d(t)$ at a lag $\\tau$. The functional $J(\\tau)$ can thus be written as:\n$$\nJ(\\tau) \\;=\\; \\tfrac{1}{2} \\left( E_{r} \\;-\\; 2 C_{sd}(\\tau) \\;+\\; E_{r} \\right) \\;=\\; E_{r} - C_{sd}(\\tau)\n$$\nTo minimize $J(\\tau)$, we must maximize the cross-correlation term $C_{sd}(\\tau)$. Let's express this in terms of the fundamental wavelet $r(t)$:\n$$\nC_{sd}(\\tau) = \\int_{-\\infty}^{\\infty} s(t) d(t+\\tau) \\mathrm{d}t = \\int_{-\\infty}^{\\infty} r(t - t_{p1}) r(t + \\tau - t_{p2}) \\mathrm{d}t\n$$\nLet's perform another change of variables, $v = t - t_{p1}$, so $t = v + t_{p1}$ and $\\mathrm{d}t = \\mathrm{d}v$.\n$$\nC_{sd}(\\tau) = \\int_{-\\infty}^{\\infty} r(v) r(v + t_{p1} + \\tau - t_{p2}) \\mathrm{d}v\n$$\nThis expression is the autocorrelation of the Ricker wavelet, $C_{rr}(\\delta) = \\int_{-\\infty}^{\\infty} r(v) r(v+\\delta) \\mathrm{d}v$, evaluated at the specific time lag $\\delta = \\tau + t_{p1} - t_{p2}$.\n$$\nC_{sd}(\\tau) = C_{rr}(\\tau + t_{p1} - t_{p2})\n$$\nBy the properties of autocorrelation (a specific case of the Cauchy-Schwarz inequality), the autocorrelation function of any real signal has its maximum value at zero lag, i.e., $C_{rr}(\\delta) \\le C_{rr}(0)$ for all $\\delta$. The maximum of $C_{sd}(\\tau)$ therefore occurs when the argument of $C_{rr}$ is zero.\n$$\n\\tau^{\\ast} + t_{p1} - t_{p2} = 0\n$$\nSolving for the optimal time shift $\\tau^{\\ast}$ gives:\n$$\n\\tau^{\\ast} = t_{p2} - t_{p1}\n$$\nThis is the exact minimizer of the functional $J(\\tau)$. The unit for $\\tau^{\\ast}$ is seconds, as it is the difference between two time measurements.\n\n### Part 2: Derivation of the Convex Basin Half-Width $\\delta_{c}$\n\nThe convex basin of $J(\\tau)$ around its minimizer $\\tau^{\\ast}$ is defined as the largest connected open interval where the second derivative $J''(\\tau)$ is strictly positive. Let us define a new variable $\\delta = \\tau - \\tau^{\\ast}$, which represents the time shift relative to the optimal alignment. The functional $J(\\tau)$ can be expressed in terms of $\\delta$:\n$$\nJ(\\tau) = J(\\tau^{\\ast} + \\delta) = E_{r} - C_{rr}(\\delta)\n$$\nWe compute the first and second derivatives of $J$ with respect to $\\tau$, which are equivalent to the derivatives with respect to $\\delta$:\n$$\nJ'(\\tau) = \\frac{\\mathrm{d}}{\\mathrm{d}\\delta} \\left[ E_{r} - C_{rr}(\\delta) \\right] = -C'_{rr}(\\delta)\n$$\n$$\nJ''(\\tau) = \\frac{\\mathrm{d}^{2}}{\\mathrm{d}\\delta^{2}} \\left[ E_{r} - C_{rr}(\\delta) \\right] = -C''_{rr}(\\delta)\n$$\nThe condition for convexity is $J''(\\tau) > 0$, which translates to:\n$$\n-C''_{rr}(\\delta) > 0 \\quad \\implies \\quad C''_{rr}(\\delta) < 0\n$$\nThe problem specifies using a narrowband approximation, where the normalized autocorrelation function locally behaves like a cosine function at the central frequency $f_{0}$:\n$$\nA(\\delta) = \\frac{C_{rr}(\\delta)}{C_{rr}(0)} \\approx \\cos(2\\pi f_{0} \\delta)\n$$\nwhere $C_{rr}(0) = E_r$ is the maximum value of the autocorrelation. Thus, we approximate $C_{rr}(\\delta)$ as:\n$$\nC_{rr}(\\delta) \\approx C_{rr}(0) \\cos(2\\pi f_{0} \\delta)\n$$\nNow, we compute the second derivative of this approximate form:\n$$\nC'_{rr}(\\delta) \\approx -C_{rr}(0) (2\\pi f_{0}) \\sin(2\\pi f_{0} \\delta)\n$$\n$$\nC''_{rr}(\\delta) \\approx -C_{rr}(0) (2\\pi f_{0})^{2} \\cos(2\\pi f_{0} \\delta)\n$$\nSubstituting this into our convexity condition $C''_{rr}(\\delta) < 0$:\n$$\n-C_{rr}(0) (2\\pi f_{0})^{2} \\cos(2\\pi f_{0} \\delta) < 0\n$$\nSince the energy $C_{rr}(0)$ is positive and $(2\\pi f_{0})^{2}$ is positive, this inequality simplifies to:\n$$\n-\\cos(2\\pi f_{0} \\delta) < 0 \\quad \\implies \\quad \\cos(2\\pi f_{0} \\delta) > 0\n$$\nWe need to find the largest connected open interval for $\\delta$ around $\\delta=0$ that satisfies this condition. The cosine function is positive when its argument lies strictly between $-\\pi/2$ and $\\pi/2$.\n$$\n-\\frac{\\pi}{2} < 2\\pi f_{0} \\delta < \\frac{\\pi}{2}\n$$\nDividing by $2\\pi f_{0}$ (since $f_0 > 0$), we obtain the interval for $\\delta$:\n$$\n-\\frac{1}{4f_{0}} < \\delta < \\frac{1}{4f_{0}}\n$$\nThis interval is the convex basin around the minimizer. The half-width of this interval, $\\delta_{c}$, is:\n$$\n\\delta_{c} = \\frac{1}{4f_{0}}\n$$\nThe problem asks for the dimensionless ratio $\\delta_{c}/T_{0}$, where the central period $T_{0} = 1/f_{0}$.\n$$\n\\frac{\\delta_{c}}{T_{0}} = \\frac{1/(4f_{0})}{1/f_{0}} = \\frac{1}{4}\n$$\nThis ratio represents the size of the \"attraction basin\" for local optimization methods relative to the signal's dominant period. If the initial time shift error is within this basin (i.e., $|\\tau - \\tau^{\\ast}| < \\delta_c$), the functional is convex and optimization will converge to the correct minimum.\n\nThe final answer consists of the expression for $\\tau^{\\ast}$ and the value of the ratio $\\delta_{c}/T_{0}$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} t_{p2} - t_{p1} & \\frac{1}{4} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Moving from pure theory to a practical simulation, this exercise () allows you to witness the cycle-skipping phenomenon in a concrete geophysical scenario. You will implement a gradient-descent inversion for a simple 1D layered model and observe how a high-frequency source can trap the optimization in a spurious local minimum. This hands-on task demonstrates the critical role of the source frequency content and illustrates why multi-scale strategies, which start with low frequencies, are a cornerstone of modern FWI workflows.",
            "id": "3610639",
            "problem": "Consider a one-dimensional, two-layer, constant-density, acoustic, normal-incidence setting with a single planar reflector at the interface between the top and bottom layers. Let the top-layer thickness be $h$ (in meters), the true top-layer velocity be $v_{1}^{\\mathrm{true}}$ (in meters per second), and the bottom-layer velocity be $v_{2}$ (in meters per second). Assume a known source signature given by a Ricker wavelet $s(t)$ of central frequency $f_{0}$ (in Hertz), with time $t$ in seconds. The forward model for the single-receiver trace at the surface is the convolutional, single-event trace\n$$\nd(t; v_{1}) = r\\, s\\bigl(t - \\tau(v_{1})\\bigr),\n$$\nwhere the normal-incidence reflection coefficient at the interface is\n$$\nr = \\frac{v_{2} - v_{1}^{\\mathrm{true}}}{v_{2} + v_{1}^{\\mathrm{true}}},\n$$\nand the two-way travel time through the top layer is\n$$\n\\tau(v_{1}) = \\frac{2h}{v_{1}}.\n$$\nTo focus purely on the kinematic mismatch responsible for cycle skipping, treat $r$ as fixed to its true value $r$ computed from $v_{1}^{\\mathrm{true}}$ and $v_{2}$ and do not vary $r$ with $v_{1}$.\n\nLet the observed data be $d_{\\mathrm{obs}}(t) = r\\, s\\bigl(t - \\tau(v_{1}^{\\mathrm{true}})\\bigr)$, discretized uniformly in time over $[0,T_{\\max}]$ with sampling interval $\\Delta t$. Define the Least Squares (L2) data misfit functional\n$$\nJ(v_{1}) = \\frac{1}{2}\\int_{0}^{T_{\\max}} \\bigl[d(t; v_{1}) - d_{\\mathrm{obs}}(t)\\bigr]^{2}\\, dt,\n$$\napproximated by the corresponding Riemann sum using $\\Delta t$.\n\nThe Ricker wavelet is the band-limited zero-phase wavelet\n$$\ns(t) = \\bigl(1 - 2\\alpha t^{2}\\bigr)\\, e^{-\\alpha t^{2}}, \\quad \\alpha = \\bigl(\\pi f_{0}\\bigr)^{2}.\n$$\n\nYour tasks are as follows, starting from fundamental definitions and without using any pre-derived inverse formulas:\n\n- Derive the analytical gradient of $J$ with respect to the travel time $\\tau$, i.e., $\\partial J/\\partial \\tau$, for the model $d(t; v_{1}) = r\\, s\\bigl(t - \\tau(v_{1})\\bigr)$ with fixed amplitude $r$. Then design a gradient-descent algorithm with backtracking Armijo line search in the variable $\\tau$ to minimize $J$; map the iterate back to $v_{1}$ using $v_{1} = 2h/\\tau$ after each update. Enforce the physically reasonable bounds $v_{1} \\in [v_{\\min}, v_{\\max}]$ by projecting $\\tau$ into $[\\tau_{\\min}, \\tau_{\\max}]$ with $\\tau_{\\min} = 2h/v_{\\max}$ and $\\tau_{\\max} = 2h/v_{\\min}$.\n- Implement the forward modeling, misfit evaluation, and gradient-descent minimization numerically using the provided parameters and units below.\n- Evaluate and interpret the emergence of spurious minima associated with cycle skipping by inspecting the misfit as a function of $v_{1}$ for a relatively higher central frequency, and demonstrate mitigation by repeating the analysis for a lower central frequency.\n\nUse the following parameter values and units consistently throughout:\n\n- Layer geometry and velocities: $h = 500$ m, $v_{1}^{\\mathrm{true}} = 2000$ m/s, $v_{2} = 2500$ m/s.\n- Sampling and time window: $\\Delta t = 0.001$ s, $T_{\\max} = 2.0$ s.\n- High central frequency for cycle-skipping analysis: $f_{0}^{\\mathrm{hi}} = 12.0$ Hz, with period $T_{0}^{\\mathrm{hi}} = 1/f_{0}^{\\mathrm{hi}}$.\n- Low central frequency for mitigation analysis: $f_{0}^{\\mathrm{lo}} = 3.0$ Hz, with period $T_{0}^{\\mathrm{lo}} = 1/f_{0}^{\\mathrm{lo}}$.\n- Velocity bounds for inversion: $v_{\\min} = 1400$ m/s, $v_{\\max} = 2600$ m/s.\n- Two distinct initial guesses for the inversion: $v_{1}^{(0,\\mathrm{near})} = 1900$ m/s and $v_{1}^{(0,\\mathrm{far})} = 1400$ m/s.\n\nTest suite and required outputs:\n\n1) Misfit at integer-cycle time shifts (high frequency). Define $v_{k} = \\dfrac{2h}{\\tau(v_{1}^{\\mathrm{true}}) + k T_{0}^{\\mathrm{hi}}}$ for $k \\in \\{0,1,2\\}$, where $\\tau(v_{1}^{\\mathrm{true}}) = 2h/v_{1}^{\\mathrm{true}}$. Compute $J(v_{k})$ using $f_{0}^{\\mathrm{hi}}$ and $d_{\\mathrm{obs}}(t)$ constructed with $f_{0}^{\\mathrm{hi}}$. Report the three floating-point values $J(v_{0}), J(v_{1}), J(v_{2})$.\n\n2) Path-dependent minimization (high frequency). Using the gradient-descent algorithm in $\\tau$ with backtracking Armijo line search and projection, minimize $J$ for $f_{0}^{\\mathrm{hi}}$ starting from the two initial guesses $v_{1}^{(0,\\mathrm{near})}$ and $v_{1}^{(0,\\mathrm{far})}$. Report the two final estimated velocities as floating-point values, $v_{1}^{\\ast,\\mathrm{near}}$ and $v_{1}^{\\ast,\\mathrm{far}}$, both in meters per second.\n\n3) Counting local minima to illustrate cycle skipping and its mitigation. Over the grid $v_{1} \\in [v_{\\min}, v_{\\max}]$ sampled uniformly at $1201$ points, count the number of strict local minima of $J(v_{1})$ for the high frequency $f_{0}^{\\mathrm{hi}}$ and for the low frequency $f_{0}^{\\mathrm{lo}}$. Report two booleans: one indicating whether the high-frequency misfit has more than one local minimum over the grid, and one indicating whether the low-frequency misfit has exactly one local minimum over the grid.\n\nNumerical and output requirements:\n\n- All calculations must use the units specified above; in particular, velocities in meters per second and time in seconds.\n- Round all floating-point outputs to six decimal places.\n- The final program output must be a single line containing a comma-separated list enclosed in square brackets of the form\n  $[J(v_{0}),J(v_{1}),J(v_{2}),v_{1}^{\\ast,\\mathrm{near}},v_{1}^{\\ast,\\mathrm{far}},\\text{has\\_multi\\_min\\_hi},\\text{has\\_single\\_min\\_lo}]$\n  where the first five entries are floats and the last two are booleans.\n- Your program must be self-contained and require no user input or external files. It must construct $d_{\\mathrm{obs}}(t)$ internally using the given parameters.",
            "solution": "The problem asks for an analysis of the cycle-skipping phenomenon in seismic full-waveform inversion (FWI) using a simplified one-dimensional acoustic model. This involves deriving and implementing a gradient-based optimization algorithm to minimize the data misfit and observing its behavior under different source frequency contents.\n\n### Problem Validation\n\nThe problem statement has been validated and is deemed **valid**.\n- **Scientific Grounding**: The problem is based on fundamental principles of wave propagation and inverse theory, specifically the convolutional model for seismograms, the L2-norm data misfit, and the concept of cycle skipping in FWI. All models, parameters, and concepts are standard in computational geophysics.\n- **Well-Posedness**: The tasks are clearly defined, with all necessary parameters provided. The objective is to implement a standard numerical optimization procedure and analyze its results in a well-defined context. The existence of local minima is the subject of study, not a flaw in the problem statement.\n- **Objectivity and Completeness**: The problem is presented using precise mathematical language and quantitative data. It is self-contained and free of ambiguity, subjective claims, or factual errors.\n\n### Mathematical Derivation and Algorithmic Design\n\n**1. Forward Model and Misfit Functional**\n\nThe forward model calculates the synthetic seismogram $d(t; v_1)$ for a given top-layer velocity $v_1$ and is defined as:\n$$\nd(t; v_{1}) = r\\, s\\bigl(t - \\tau(v_{1})\\bigr)\n$$\nwhere $s(t)$ is the Ricker wavelet source signature, $r$ is the fixed reflection coefficient, and $\\tau(v_1) = 2h/v_1$ is the two-way travel time. The observed data, $d_{\\mathrm{obs}}(t)$, corresponds to the true velocity $v_1^{\\mathrm{true}}$:\n$$\nd_{\\mathrm{obs}}(t) = r\\, s\\bigl(t - \\tau(v_{1}^{\\mathrm{true}})\\bigr)\n$$\nThe inversion aims to find the model parameter $v_1$ that minimizes the discrepancy between synthetic and observed data. This is quantified by the L2 data misfit functional $J(v_1)$, which we will treat as a function of the travel time $\\tau = \\tau(v_1)$:\n$$\nJ(\\tau) = \\frac{1}{2}\\int_{0}^{T_{\\max}} \\bigl[d(t; \\tau) - d_{\\mathrm{obs}}(t)\\bigr]^{2}\\, dt\n$$\n\n**2. Gradient of the Misfit Functional**\n\nTo employ a gradient-descent optimization algorithm, we must compute the gradient of $J$ with respect to the optimization variable, $\\tau$. Using the chain rule for functionals (a direct application of the Leibniz integral rule):\n$$\n\\frac{\\partial J}{\\partial \\tau} = \\frac{\\partial}{\\partial \\tau} \\left( \\frac{1}{2}\\int_{0}^{T_{\\max}} [d(t; \\tau) - d_{\\mathrm{obs}}(t)]^2 dt \\right) = \\int_{0}^{T_{\\max}} [d(t; \\tau) - d_{\\mathrm{obs}}(t)] \\frac{\\partial}{\\partial \\tau} [d(t; \\tau)] dt\n$$\nThe derivative of the forward model $d(t; \\tau) = r\\,s(t-\\tau)$ with respect to $\\tau$ is:\n$$\n\\frac{\\partial d(t; \\tau)}{\\partial \\tau} = r \\frac{\\partial}{\\partial \\tau} s(t-\\tau) = r \\cdot s'(t-\\tau) \\cdot \\frac{\\partial(t-\\tau)}{\\partial \\tau} = -r\\,s'(t-\\tau)\n$$\nwhere $s'(t)$ is the time derivative of the Ricker wavelet. Substituting this back gives the gradient expression:\n$$\n\\frac{\\partial J}{\\partial \\tau} = \\int_{0}^{T_{\\max}} \\underbrace{[d(t; \\tau) - d_{\\mathrm{obs}}(t)]}_{\\text{data residual}} \\cdot \\underbrace{[-r\\,s'(t - \\tau)]}_{\\text{adjoint source}} dt\n$$\nThis classic result shows that the gradient is the zero-lag cross-correlation of the data residual with the time derivative of the synthetic data (often termed the \"adjoint source\"). For numerical implementation, the integral is approximated by a discrete sum over time samples $t_i$:\n$$\n\\frac{\\partial J}{\\partial \\tau} \\approx \\sum_{i} [d(t_i; \\tau) - d_{\\mathrm{obs}}(t_i)] \\cdot [-r\\,s'(t_i - \\tau)] \\Delta t\n$$\n\n**3. Gradient-Descent Algorithm with Projection and Line Search**\n\nWe will implement a projected gradient-descent algorithm to minimize $J(\\tau)$. The algorithm iteratively updates the current estimate of $\\tau$ in the direction of the negative gradient.\n\nThe iterative update rule is:\n$$\n\\tau^{(k+1)} = \\mathrm{proj}_{[\\tau_{\\min}, \\tau_{\\max}]} \\left( \\tau^{(k)} - \\beta^{(k)} \\frac{\\partial J}{\\partial \\tau}\\bigg|_{\\tau^{(k)}} \\right)\n$$\nwhere:\n- $k$ is the iteration number.\n- $\\frac{\\partial J}{\\partial \\tau}\\big|_{\\tau^{(k)}}$ is the gradient evaluated at the current iterate $\\tau^{(k)}$.\n- $\\beta^{(k)}$ is the step length, determined by a backtracking Armijo line search.\n- $\\mathrm{proj}_{[\\tau_{\\min}, \\tau_{\\max}]}(\\cdot)$ is the projection operator that maps a value of $\\tau$ to the nearest point within the feasible interval $[\\tau_{\\min}, \\tau_{\\max}]$. This enforces the velocity constraints $v_1 \\in [v_{\\min}, v_{\\max}]$.\n\nThe backtracking Armijo line search for an appropriate step length $\\beta$ proceeds as follows: Starting with an initial guess $\\beta_0$, we iteratively reduce $\\beta$ by a factor $\\sigma \\in (0,1)$ until the sufficient decrease condition is met:\n$$\nJ(\\tau_{\\text{trial}}) \\le J(\\tau^{(k)}) - c \\beta \\left( \\frac{\\partial J}{\\partial \\tau}\\bigg|_{\\tau^{(k)}} \\right)^2\n$$\nwhere $\\tau_{\\text{trial}} = \\mathrm{proj}_{[\\tau_{\\min}, \\tau_{\\max}]} \\left( \\tau^{(k)} - \\beta \\frac{\\partial J}{\\partial \\tau}\\big|_{\\tau^{(k)}} \\right)$ is the trial iterate and $c \\in (0,1)$ is a control parameter (e.g., $c=10^{-4}$).\n\n### Analysis of Cycle Skipping\n\nCycle skipping occurs when the misfit functional $J(v_1)$ is non-convex, exhibiting multiple local minima. This happens when the initial model is \"more than half a wavelength\" away from the true model. The time shift error, $\\Delta \\tau = \\tau(v_{1}) - \\tau(v_1^{\\mathrm{true}})$, becomes comparable to or larger than the dominant period $T_0 = 1/f_0$ of the wavelet. Gradient-based methods can get trapped in these spurious local minima, failing to find the global minimum corresponding to the true model.\n\n- **High-Frequency Case ($f_{0}^{\\mathrm{hi}}$)**: The dominant period $T_0^{\\mathrm{hi}}$ is short. Small changes in velocity can lead to time shifts $\\Delta\\tau$ that are integer multiples of $T_0^{\\mathrm{hi}}$, creating multiple local minima within a reasonable velocity search range.\n- **Low-Frequency Case ($f_{0}^{\\mathrm{lo}}$)**: The dominant period $T_0^{\\mathrm{lo}}$ is long. The misfit functional becomes smoother and more convex-like over the same velocity search range, as a much larger velocity error is required to produce a cycle skip. This mitigates the problem, often leaving only a single minimum.\n\nThe numerical implementation will perform the three tasks specified:\n1.  Evaluate the misfit at velocities corresponding to integer cycle shifts for the high-frequency case to demonstrate the existence of local minima.\n2.  Run the gradient-descent minimizer from two different starting points (one near the true model, one far) to show path-dependent convergence.\n3.  Count the number of local minima in the misfit function over a grid of velocities for both high and low frequencies to explicitly demonstrate the effect of frequency on convexity.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D FWI cycle-skipping problem.\n    \"\"\"\n    \n    # ----------------------------------------------------------------------\n    # 1. PARAMETERS AND SETUP\n    # ----------------------------------------------------------------------\n    \n    # Physical and model parameters\n    H = 500.0  # Top-layer thickness in meters\n    V1_TRUE = 2000.0  # True top-layer velocity in m/s\n    V2 = 2500.0  # Bottom-layer velocity in m/s\n    \n    # Time sampling parameters\n    DT = 0.001  # Time sampling interval in seconds\n    T_MAX = 2.0  # Maximum recording time in seconds\n    \n    # Source frequency parameters\n    F0_HI = 12.0  # High central frequency in Hz\n    F0_LO = 3.0  # Low central frequency in Hz\n    \n    # Inversion parameters\n    V_MIN = 1400.0  # Minimum velocity bound in m/s\n    V_MAX = 2600.0  # Maximum velocity bound in m/s\n    V1_INIT_NEAR = 1900.0  # \"Near\" initial guess for inversion in m/s\n    V1_INIT_FAR = 1400.0  # \"Far\" initial guess for inversion in m/s\n\n    # Create the time axis for the seismograms\n    t_array = np.arange(0, T_MAX, DT)\n    \n    # Calculate the true reflection coefficient (held fixed throughout)\n    r_coeff = (V2 - V1_TRUE) / (V2 + V1_TRUE)\n\n    # ----------------------------------------------------------------------\n    # 2. CORE FUNCTIONS\n    # ----------------------------------------------------------------------\n\n    def ricker(t, f0):\n        \"\"\"Computes the Ricker wavelet s(t).\"\"\"\n        alpha = (np.pi * f0)**2\n        return (1.0 - 2.0 * alpha * t**2) * np.exp(-alpha * t**2)\n\n    def ricker_derivative(t, f0):\n        \"\"\"Computes the time derivative of the Ricker wavelet, s'(t).\"\"\"\n        alpha = (np.pi * f0)**2\n        return 2.0 * alpha * t * (2.0 * alpha * t**2 - 3.0) * np.exp(-alpha * t**2)\n\n    def forward_model(v1, h, r, t, f0):\n        \"\"\"Computes the synthetic data d(t; v1).\"\"\"\n        tau = 2.0 * h / v1\n        return r * ricker(t - tau, f0)\n\n    def misfit_functional(d_synth, d_obs, dt):\n        \"\"\"Computes the L2 misfit functional J.\"\"\"\n        return 0.5 * np.sum((d_synth - d_obs)**2) * dt\n\n    def gradient_tau(tau, d_obs, r, h, t, f0, dt):\n        \"\"\"Computes the gradient of J with respect to travel time tau.\"\"\"\n        v1 = 2.0 * h / tau\n        d_synth = forward_model(v1, h, r, t, f0)\n        residual = d_synth - d_obs\n        adjoint_source = -r * ricker_derivative(t - tau, f0)\n        return np.sum(residual * adjoint_source) * dt\n    \n    # ----------------------------------------------------------------------\n    # 3. TASK EXECUTION\n    # ----------------------------------------------------------------------\n\n    results = []\n\n    # --- Task 1: Misfit at integer-cycle time shifts (high frequency) ---\n    f0 = F0_HI\n    d_obs_hi = forward_model(V1_TRUE, H, r_coeff, t_array, f0)\n    tau_true = 2.0 * H / V1_TRUE\n    T0_hi = 1.0 / f0\n    \n    misfits_k = []\n    for k in range(3):\n        tau_k = tau_true + k * T0_hi\n        v_k = 2.0 * H / tau_k\n        d_k = forward_model(v_k, H, r_coeff, t_array, f0)\n        J_k = misfit_functional(d_k, d_obs_hi, DT)\n        misfits_k.append(J_k)\n    results.extend(misfits_k)\n\n    # --- Task 2: Path-dependent minimization (high frequency) ---\n    tau_min = 2.0 * H / V_MAX\n    tau_max = 2.0 * H / V_MIN\n\n    def minimize_J(v1_init, f0_in, d_obs_in):\n        \"\"\"Performs gradient descent with projection and Armijo line search.\"\"\"\n        tau = 2.0 * H / v1_init\n        \n        # Optimization parameters\n        max_iter = 100\n        grad_tol = 1e-9\n        beta_init = 1.0  # Initial step size guess for line search\n        c_armijo = 1e-4 # Armijo condition parameter\n        sigma_bt = 0.5   # Backtracking reduction factor\n        \n        for _ in range(max_iter):\n            grad_val = gradient_tau(tau, d_obs_in, r_coeff, H, t_array, f0_in, DT)\n            \n            if abs(grad_val) < grad_tol:\n                break\n            \n            # Backtracking line search\n            beta = beta_init\n            J_current = misfit_functional(forward_model(2.0 * H / tau, H, r_coeff, t_array, f0_in), d_obs_in, DT)\n            step_found = False\n            \n            while beta > 1e-12:\n                tau_trial = np.clip(tau - beta * grad_val, tau_min, tau_max)\n                J_trial = misfit_functional(forward_model(2.0 * H / tau_trial, H, r_coeff, t_array, f0_in), d_obs_in, DT)\n                \n                armijo_cond = J_current - c_armijo * beta * grad_val**2\n                if J_trial <= armijo_cond:\n                    tau = tau_trial\n                    step_found = True\n                    break\n                beta *= sigma_bt\n            \n            if not step_found:\n                break  # Stop if line search fails\n                \n        return 2.0 * H / tau\n\n    v_star_near = minimize_J(V1_INIT_NEAR, F0_HI, d_obs_hi)\n    v_star_far = minimize_J(V1_INIT_FAR, F0_HI, d_obs_hi)\n    results.extend([v_star_near, v_star_far])\n\n    # --- Task 3: Counting local minima ---\n    v1_grid = np.linspace(V_MIN, V_MAX, 1201)\n    \n    # High-frequency analysis\n    J_hi_values = np.array([misfit_functional(forward_model(v, H, r_coeff, t_array, F0_HI), d_obs_hi, DT) for v in v1_grid])\n    num_minima_hi = 0\n    for i in range(1, len(v1_grid) - 1):\n        if J_hi_values[i-1] > J_hi_values[i] and J_hi_values[i] < J_hi_values[i+1]:\n            num_minima_hi += 1\n    has_multi_min_hi = num_minima_hi > 1\n    results.append(has_multi_min_hi)\n    \n    # Low-frequency analysis\n    d_obs_lo = forward_model(V1_TRUE, H, r_coeff, t_array, F0_LO)\n    J_lo_values = np.array([misfit_functional(forward_model(v, H, r_coeff, t_array, F0_LO), d_obs_lo, DT) for v in v1_grid])\n    num_minima_lo = 0\n    for i in range(1, len(v1_grid) - 1):\n        if J_lo_values[i-1] > J_lo_values[i] and J_lo_values[i] < J_lo_values[i+1]:\n            num_minima_lo += 1\n    has_single_min_lo = num_minima_lo == 1\n    results.append(has_single_min_lo)\n\n    # ----------------------------------------------------------------------\n    # 4. FINAL OUTPUT\n    # ----------------------------------------------------------------------\n    \n    def format_value(v):\n        if isinstance(v, float):\n            return f\"{v:.6f}\"\n        return str(v)\n\n    formatted_results = [format_value(res) for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While multi-scale approaches are effective, they are not always sufficient, motivating the development of alternative misfit functionals with improved convexity. This practice () introduces the quadratic Wasserstein metric ($W_2$) from optimal transport theory, which compares the distribution of signal energy rather than pointwise amplitudes. By constructing specific \"adversarial\" examples, you will demonstrate how the $L^2$ misfit can be easily misled by phase shifts and polarity reversals, while the $W_2$ metric correctly identifies the direction towards the true model, highlighting its robustness against cycle-skipping.",
            "id": "3610593",
            "problem": "Consider one-dimensional acoustic Full Waveform Inversion (FWI) in a horizontally layered medium over a path of length $L$ meters. The recorded data are modeled as a delayed source wavelet. Let $v(x)$ denote the acoustic velocity, $s(x) = 1/v(x)$ the slowness, and the kinematic travel time for a path of length $L$ be $T = \\int_0^L s(x) \\, \\mathrm{d}x$. Assume a single dominant arrival is adequately represented by a Ricker wavelet $w(t)$ delayed by $T$ and scaled by an amplitude factor $A$. The observed data trace is $d_{\\mathrm{obs}}(t) = A_{\\mathrm{true}} \\, w(t - T_{\\mathrm{true}})$ from a true model with travel time $T_{\\mathrm{true}}$. A baseline inversion model yields $d_0(t) = A_0 \\, w(t - T_0)$ with travel time $T_0$ and amplitude $A_0$.\n\nDefine the conventional least-squares misfit functional\n$$\n\\Phi_{L_2}(m) = \\frac{1}{2} \\int_{0}^{T_{\\max}} \\left(d_{\\mathrm{pred}}(t; m) - d_{\\mathrm{obs}}(t)\\right)^2 \\, \\mathrm{d}t,\n$$\nwhich has units of wavelet amplitude squared times seconds, where $d_{\\mathrm{pred}}(t; m)$ denotes the predicted data for model parameters $m$, and $T_{\\max}$ is the time recording length.\n\nDefine the quadratic Wasserstein metric (denoted $W_2$) between the energy-normalized positive measures associated with the two traces. For a trace $d(t)$, define its nonnegative energy density $e(t) = d(t)^2 + \\epsilon$ with a small $0 < \\epsilon \\ll 1$ to avoid zero mass, and normalize to a probability density $\\mu(t) = e(t) / \\int_0^{T_{\\max}} e(t) \\, \\mathrm{d}t$. Let $\\nu(t)$ be the corresponding density for the observed trace. The cumulative distribution functions are $F(t) = \\int_0^t \\mu(\\tau) \\, \\mathrm{d}\\tau$ and $G(t) = \\int_0^t \\nu(\\tau) \\, \\mathrm{d}\\tau$. The quadratic Wasserstein metric is\n$$\n\\Phi_{W_2}(m) = \\left( \\int_0^1 \\left| F^{-1}(p) - G^{-1}(p) \\right|^2 \\, \\mathrm{d}p \\right)^{1/2},\n$$\nwhich has units of seconds.\n\nYou will construct adversarial model perturbations $\\delta m$ that increase the least-squares misfit $\\Phi_{L_2}$ yet decrease the Wasserstein metric $\\Phi_{W_2}$ relative to the baseline model. These adversarial perturbations exploit the phase sensitivity of $\\Phi_{L_2}$ and the mass-transport nature of $\\Phi_{W_2}$.\n\nFundamental base:\n\n- The acoustic wave equation in one dimension implies that small changes in slowness $s(x)$ modify the travel time $T = \\int_0^L s(x) \\, \\mathrm{d}x$ and thus shift the arrival time of the wavelet. This is a well-tested kinematic approximation for first arrivals and simple reflections.\n- The Ricker wavelet is defined by $w(t) = \\left(1 - 2 (\\pi f_0 t)^2\\right) \\exp\\left( - (\\pi f_0 t)^2 \\right)$, where $f_0$ is the central frequency in Hertz, producing a band-limited pulse commonly used in seismic modeling.\n- The least-squares misfit is pointwise and highly sensitive to phase and polarity differences, while the quadratic Wasserstein metric compares distributions by optimal transport, emphasizing the alignment of energy “mass” along the time axis and reducing sensitivity to polarity and amplitude scaling when measures are normalized.\n\nYou must implement a program that, for specified parameters, computes both $\\Phi_{L_2}$ and $\\Phi_{W_2}$ for the baseline and for each adversarial perturbation, and returns booleans indicating whether $\\Phi_{L_2}$ increased and $\\Phi_{W_2}$ decreased. All time quantities must be handled in seconds, all distances in meters, and all velocities in meters per second.\n\nUse the following recording and physical parameters:\n- Path length $L = 2000$ meters.\n- True velocity $v_{\\mathrm{true}} = 2200$ meters per second, so $T_{\\mathrm{true}} = L / v_{\\mathrm{true}}$ seconds.\n- Baseline slowness $s_0 = 1/v_{\\mathrm{true}} + 5 \\times 10^{-6}$ seconds per meter, implying $T_0 = \\int_0^L s_0 \\, \\mathrm{d}x$ seconds.\n- Baseline amplitude $A_0 = 1$.\n- Observed amplitude $A_{\\mathrm{true}} = 1$.\n- Central frequency $f_0 = 15$ Hertz.\n- Recording length $T_{\\max} = 2$ seconds and time sampling interval $\\Delta t = 0.001$ seconds.\n- Energy floor $\\epsilon = 10^{-12}$.\n\nConstruct three adversarial model perturbations, each producing a predicted trace $d_{\\mathrm{pred}}(t; m)$:\n1. Polarity reversal with exact time alignment: choose $\\delta s$ such that $T = T_{\\mathrm{true}}$ and $A = -1$.\n2. Amplitude overshoot with partial time alignment: choose $\\delta s$ such that $T = T_{\\mathrm{true}} + 0.005$ seconds and $A = 2$.\n3. Secondary arrival with partial time alignment: choose $\\delta s$ such that $T = T_{\\mathrm{true}} + 0.005$ seconds, $A = 1$, and add a weak secondary arrival of amplitude $B = 0.5$ at $T + 0.03$ seconds, so $d_{\\mathrm{pred}}(t; m) = A \\, w(t - T) + B \\, w\\left(t - (T + 0.03)\\right)$.\n\nFor each of the three perturbations above, compute the baseline misfits $\\Phi_{L_2}(m_0)$ and $\\Phi_{W_2}(m_0)$ and the perturbed misfits $\\Phi_{L_2}(m_0 + \\delta m)$ and $\\Phi_{W_2}(m_0 + \\delta m)$. Determine the boolean $b = (\\Phi_{L_2}(m_0 + \\delta m) > \\Phi_{L_2}(m_0)) \\wedge (\\Phi_{W_2}(m_0 + \\delta m) < \\Phi_{W_2}(m_0))$ for each case.\n\nTest Suite:\n- Case $1$: Polarity reversal with $T = T_{\\mathrm{true}}$ and $A = -1$.\n- Case $2$: Amplitude overshoot with $T = T_{\\mathrm{true}} + 0.005$ and $A = 2$.\n- Case $3$: Secondary arrival with $T = T_{\\mathrm{true}} + 0.005$, $A = 1$, and secondary amplitude $B = 0.5$ at $T + 0.03$.\n\nYour program should produce a single line of output containing the three boolean results as a comma-separated list enclosed in square brackets (for example, \"[True,False,True]\").",
            "solution": "The user-provided problem has been analyzed and is determined to be **valid**. It is scientifically grounded in the principles of computational geophysics, specifically Full-Waveform Inversion (FWI), and presents a well-posed, objective, and complete computational task. All parameters and definitions required for a unique solution are provided. We may therefore proceed with the solution.\n\nThe objective is to compare the behavior of two misfit functionals, the conventional least-squares ($L_2$) and the quadratic Wasserstein ($W_2$), under three specific \"adversarial\" data perturbations. These perturbations are designed to create scenarios where the $L_2$ misfit increases, indicating a worse model fit, while the $W_2$ misfit decreases, indicating an improved fit. This highlights the cycle-skipping problem inherent in the $L_2$ norm and the potential of the $W_2$ metric to mitigate it.\n\nFirst, we establish the computational framework. The simulation time runs from $t=0$ to $T_{\\max}=2$ seconds with a sampling interval of $\\Delta t = 0.001$ seconds. This defines a discrete time axis $t_k = k \\Delta t$ for $k = 0, 1, \\dots, \\lfloor(T_{\\max}-0)/\\Delta t\\rfloor - 1$.\n\nThe source signal is a Ricker wavelet with a central frequency of $f_0 = 15$ Hz, defined as:\n$$\nw(t) = \\left(1 - 2 (\\pi f_0 t)^2\\right) \\exp\\left( - (\\pi f_0 t)^2 \\right)\n$$\n\nNext, we define the various data traces used in the comparison.\nThe \"true\" or observed data, $d_{\\mathrm{obs}}(t)$, corresponds to a true model with a constant velocity $v_{\\mathrm{true}} = 2200$ m/s over a path of length $L = 2000$ m. The travel time is thus:\n$$\nT_{\\mathrm{true}} = \\frac{L}{v_{\\mathrm{true}}} = \\frac{2000}{2200} = \\frac{10}{11} \\approx 0.90909 \\text{ s}\n$$\nThe observed trace is then $d_{\\mathrm{obs}}(t) = A_{\\mathrm{true}} \\, w(t - T_{\\mathrm{true}})$ with amplitude $A_{\\mathrm{true}} = 1$.\n\nThe baseline model has a constant slowness $s_0 = 1/v_{\\mathrm{true}} + 5 \\times 10^{-6}$ s/m. Its corresponding travel time $T_0$ is:\n$$\nT_0 = L \\cdot s_0 = L \\left(\\frac{1}{v_{\\mathrm{true}}} + 5 \\times 10^{-6}\\right) = T_{\\mathrm{true}} + 2000 \\cdot (5 \\times 10^{-6}) = T_{\\mathrm{true}} + 0.01 \\text{ s} \\approx 0.91909 \\text{ s}\n$$\nThe baseline predicted trace is $d_0(t) = A_0 \\, w(t - T_0)$ with amplitude $A_0 = 1$.\n\nThe three adversarial predicted traces are constructed as specified:\n1.  Polarity reversal: $d_1(t) = -1 \\cdot w(t - T_{\\mathrm{true}})$\n2.  Amplitude overshoot: $d_2(t) = 2 \\cdot w(t - (T_{\\mathrm{true}} + 0.005))$\n3.  Secondary arrival: $d_3(t) = 1 \\cdot w(t - (T_{\\mathrm{true}} + 0.005)) + 0.5 \\cdot w(t - (T_{\\mathrm{true}} + 0.035))$\n\nWith the data traces defined, we outline the numerical computation of the misfit functionals.\n\nThe $L_2$ misfit, $\\Phi_{L_2}$, is computed by numerically integrating the squared pointwise difference between predicted and observed data. For discrete time series, this is approximated by a sum:\n$$\n\\Phi_{L_2}(m) \\approx \\frac{1}{2} \\sum_{k} \\left(d_{\\mathrm{pred}}(t_k) - d_{\\mathrm{obs}}(t_k)\\right)^2 \\Delta t\n$$\n\nThe quadratic Wasserstein misfit, $\\Phi_{W_2}$, requires several steps:\n1.  For a given trace $d(t)$, its non-negative energy density is defined as $e(t) = d(t)^2 + \\epsilon$, with a regularization term $\\epsilon = 10^{-12}$.\n2.  This energy density is normalized to form a probability density function (PDF) $\\mu(t) = e(t) / \\int_0^{T_{\\max}} e(\\tau) \\, \\mathrm{d}\\tau$. Let $\\mu(t)$ be the PDF for $d_{\\mathrm{pred}}(t)$ and $\\nu(t)$ be the PDF for $d_{\\mathrm{obs}}(t)$. The integral is computed numerically, for instance, using the trapezoidal rule.\n3.  The corresponding cumulative distribution functions (CDFs) are computed by numerically integrating the PDFs: $F(t) = \\int_0^t \\mu(\\tau) \\, \\mathrm{d}\\tau$ and $G(t) = \\int_0^t \\nu(\\tau) \\, \\mathrm{d}\\tau$. This is performed using a cumulative trapezoidal integration scheme.\n4.  The quantile functions (inverse CDFs), $F^{-1}(p)$ and $G^{-1}(p)$, are computed for a uniform grid of probability values $p \\in [0, 1]$. Since the discrete CDFs may not be strictly monotonic, we find the unique values in the CDF and use linear interpolation to find the time $t$ corresponding to each probability $p$.\n5.  Finally, the $W_2$ metric is calculated by integrating the squared difference of the quantile functions:\n$$\n\\Phi_{W_2}(m) = \\left( \\int_0^1 \\left( F^{-1}(p) - G^{-1}(p) \\right)^2 \\, \\mathrm{d}p \\right)^{1/2}\n$$\nThis integral is also computed numerically using the trapezoidal rule over the grid of probability values $p$.\n\nThe analysis proceeds by computing the baseline misfits, $\\Phi_{L_2}(m_0)$ and $\\Phi_{W_2}(m_0)$, from comparing $d_0(t)$ to $d_{\\mathrm{obs}}(t)$. Then, for each of the three perturbed traces $d_k(t)$, the corresponding misfits $\\Phi_{L_2}(m_k)$ and $\\Phi_{W_2}(m_k)$ are computed. For each case $k \\in \\{1, 2, 3\\}$, we evaluate the boolean condition:\n$$\nb_k = (\\Phi_{L_2}(m_k) > \\Phi_{L_2}(m_0)) \\land (\\Phi_{W_2}(m_k) < \\Phi_{W_2}(m_0))\n$$\nThe final output is the list of these three boolean results, $[b_1, b_2, b_3]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Computes and compares L2 and W2 misfits for FWI under adversarial perturbations.\n    \"\"\"\n    #\n    # 1. DEFINE CONSTANTS AND PARAMETERS FROM THE PROBLEM STATEMENT\n    #\n    L = 2000.0  # Path length in meters\n    v_true = 2200.0  # True velocity in m/s\n    A_true = 1.0  # True amplitude\n    f0 = 15.0  # Ricker wavelet central frequency in Hz\n    A0 = 1.0  # Baseline amplitude\n    s0_delta = 5.0e-6  # Slowness perturbation for baseline model in s/m\n    T_max = 2.0  # Recording length in seconds\n    dt = 0.001  # Time sampling interval in seconds\n    epsilon = 1.0e-12  # Energy floor for Wasserstein metric\n\n    #\n    # 2. CALCULATE DERIVED PARAMETERS AND SET UP TIME GRID\n    #\n    t = np.arange(0, T_max, dt)\n    s_true = 1.0 / v_true\n    T_true = L * s_true\n    s0 = s_true + s0_delta\n    T0 = L * s0\n\n    #\n    # 3. DEFINE HELPER FUNCTIONS FOR WAVELET AND MISFITS\n    #\n    def ricker_wavelet(t_shifted, f0_val):\n        \"\"\"Generates a Ricker wavelet for given time values and frequency.\"\"\"\n        a = (np.pi * f0_val * t_shifted)**2\n        return (1.0 - 2.0 * a) * np.exp(-a)\n\n    def l2_misfit(d_pred, d_obs, delta_t):\n        \"\"\"Computes the L2 misfit functional.\"\"\"\n        return 0.5 * np.sum((d_pred - d_obs)**2) * delta_t\n\n    def w2_misfit(d_pred, d_obs, time_axis, delta_t, eps):\n        \"\"\"Computes the quadratic Wasserstein metric between two traces.\"\"\"\n        \n        def get_quantile_function(d, t_ax, dt_val, eps_val):\n            # Calculate energy density with a small floor\n            e = d**2 + eps_val\n            \n            # Normalize to get a probability density function (PDF)\n            total_energy = np.trapz(e, t_ax)\n            mu = e / total_energy\n            \n            # Compute the Cumulative Distribution Function (CDF)\n            cdf = cumulative_trapezoid(mu, t_ax, initial=0.0)\n            \n            # The quantile function is the inverse of the CDF. We compute it by\n            # interpolating on a uniform probability grid. To handle potential\n            # plateaus in the CDF, we use only the unique CDF values for interpolation.\n            unique_cdf, unique_indices = np.unique(cdf, return_index=True)\n            unique_t = t_ax[unique_indices]\n            \n            p_grid = np.linspace(0.0, 1.0, len(t_ax))\n            quantile_func = np.interp(p_grid, unique_cdf, unique_t)\n            return quantile_func, p_grid\n\n        # Get quantile functions for both predicted and observed data\n        q_pred, p_grid = get_quantile_function(d_pred, time_axis, delta_t, eps)\n        q_obs, _ = get_quantile_function(d_obs, time_axis, delta_t, eps)\n\n        # Calculate the W2 metric by integrating the squared difference\n        # of the quantile functions\n        integrand = (q_pred - q_obs)**2\n        integral_val = np.trapz(integrand, p_grid)\n        \n        return np.sqrt(integral_val)\n\n    #\n    # 4. GENERATE OBSERVED AND BASELINE DATA TRACES\n    #\n    d_obs = A_true * ricker_wavelet(t - T_true, f0)\n    d0 = A0 * ricker_wavelet(t - T0, f0)\n\n    #\n    # 5. CALCULATE BASELINE MISFITS\n    #\n    phi_l2_base = l2_misfit(d0, d_obs, dt)\n    phi_w2_base = w2_misfit(d0, d_obs, t, dt, epsilon)\n    \n    results = []\n    \n    #\n    # 6. ANALYZE THE THREE ADVERSARIAL PERTURBATION CASES\n    #\n    \n    # Define test cases as a list of tuples (name, trace_generator_lambda)\n    perturbation_cases = [\n        # Case 1: Polarity reversal\n        lambda: -1.0 * ricker_wavelet(t - T_true, f0),\n\n        # Case 2: Amplitude overshoot\n        lambda: 2.0 * ricker_wavelet(t - (T_true + 0.005), f0),\n        \n        # Case 3: Secondary arrival\n        lambda: (1.0 * ricker_wavelet(t - (T_true + 0.005), f0) +\n                 0.5 * ricker_wavelet(t - (T_true + 0.005 + 0.03), f0))\n    ]\n\n    for gen_trace in perturbation_cases:\n        # Generate the perturbed trace\n        d_pert = gen_trace()\n\n        # Calculate perturbed misfits\n        phi_l2_pert = l2_misfit(d_pert, d_obs, dt)\n        phi_w2_pert = w2_misfit(d_pert, d_obs, t, dt, epsilon)\n        \n        # Determine if L2 misfit increased AND W2 misfit decreased\n        is_adversarial_success = (phi_l2_pert > phi_l2_base) and \\\n                                  (phi_w2_pert < phi_w2_base)\n        results.append(is_adversarial_success)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}