{
    "hands_on_practices": [
        {
            "introduction": "为了从根本上理解周期跳跃问题，我们首先对标准的平方$L^2$失配泛函进行基础分析。该练习将指导您通过理论计算，确定一个简化情况下全局最小值附近的精确凸性区域 。通过推导这个“吸引盆”的大小，您将清晰地、定量地理解为何当波形失配超过大约半个周期时，$L^2$范数容易陷入局部极小值。",
            "id": "3610613",
            "problem": "在全波形反演（FWI）的背景下，考虑一个由Ricker子波建模的连续时间单炮单检波器地震道。设震源子波为Ricker子波\n$$\nr(t) \\;=\\; \\bigl(1 - 2 \\pi^{2} f_{0}^{2} t^{2}\\bigr)\\,\\exp\\!\\bigl(-\\pi^{2} f_{0}^{2} t^{2}\\bigr),\n$$\n其中心频率为 $f_{0}$。两个观测到的地震道被建模为同一子波的时间平移副本，\n$$\ns(t) \\,=\\, r\\!\\bigl(t - t_{p1}\\bigr), \n\\qquad\nd(t) \\,=\\, r\\!\\bigl(t - t_{p2}\\bigr),\n$$\n其中 $t_{p1}$ 和 $t_{p2}$ 是两个子波的波峰时间。引入一个应用于 $s(t)$ 的标量时间偏移参数 $\\tau \\in \\mathbb{R}$，并定义平方$L^2$范数失配泛函\n$$\nJ(\\tau) \\;=\\; \\tfrac{1}{2}\\,\\int_{-\\infty}^{\\infty} \\Bigl[s\\!\\bigl(t - \\tau\\bigr) \\;-\\; d(t)\\Bigr]^{2}\\, \\mathrm{d}t.\n$$\n假设数据无噪声，且所有积分绝对收敛。\n\n任务：\n$1.$ 仅使用内积和互相关的定义，用 $t_{p1}$ 和 $t_{p2}$ 推导出 $J(\\tau)$ 的精确极小值点 $\\tau^{\\ast}$。以秒为单位表示 $\\tau^{\\ast}$。\n\n$2.$ 将 $J(\\tau)$ 关于 $\\tau$ 的凸盆定义为围绕 $\\tau^{\\ast}$ 的最大连通开区间，在该区间上二阶导数 $J''(\\tau)$ 严格为正。使用与中心频率 $f_0$ 相关的窄带近似——具体来说，即窄带脉冲的归一化自相关在时间延迟 $\\delta$ 上局部表现为 $\\cos\\!\\bigl(2\\pi f_{0}\\,\\delta\\bigr)$——推导出该凸盆的半宽度 $\\delta_c$，并给出无量纲比率 $\\delta_{c}/T_{0}$，其中中心周期 $T_{0}$ 为 $T_{0} \\,=\\, 1/f_{0}$。\n\n最终答案以两个条目的形式给出：$\\tau^{\\ast}$ 的闭式表达式，以及 $\\delta_{c}/T_{0}$ 的精确分数。无需四舍五入。如果涉及到单位，时间单位使用秒，并将盆地大小报告为 $T_{0}$ 的纯分数（无量纲）。角度（如适用）必须以弧度为单位。",
            "solution": "该问题被评估为科学上合理、适定、客观且自洽。它提出了一个计算地球物理学中研究全波形反演（FWI）残差泛函性质的标准（尽管简化了的）场景。任务清晰，所提供的信息足以进行严谨的数学推导。\n\n解答分为两部分，对应问题陈述中的两个任务。\n\n### 第1部分：极小值点 $\\tau^{\\ast}$ 的推导\n\n目标是找到使平方$L^2$范数失配泛函 $J(\\tau)$ 最小化的 $\\tau$ 值，记为 $\\tau^{\\ast}$。该泛函定义为：\n$$\nJ(\\tau) \\;=\\; \\tfrac{1}{2}\\,\\int_{-\\infty}^{\\infty} \\Bigl[s\\!\\bigl(t - \\tau\\bigr) \\;-\\; d(t)\\Bigr]^{2}\\, \\mathrm{d}t\n$$\n为求极小值点，我们首先展开积分内的平方项：\n$$\nJ(\\tau) \\;=\\; \\tfrac{1}{2}\\,\\int_{-\\infty}^{\\infty} \\left( s^{2}(t - \\tau) \\;-\\; 2 s(t - \\tau) d(t) \\;+\\; d^{2}(t) \\right) \\mathrm{d}t\n$$\n我们可以将其分为三项：\n$$\nJ(\\tau) \\;=\\; \\tfrac{1}{2} \\left( \\int_{-\\infty}^{\\infty} s^{2}(t - \\tau) \\mathrm{d}t \\;-\\; 2 \\int_{-\\infty}^{\\infty} s(t - \\tau) d(t) \\mathrm{d}t \\;+\\; \\int_{-\\infty}^{\\infty} d^{2}(t) \\mathrm{d}t \\right)\n$$\n第一项和第三项分别代表信号 $s(t)$ 和 $d(t)$ 的能量。信号的能量在时间平移下是不变的。信号 $s(t)$ 和 $d(t)$ 被定义为 $s(t) = r(t - t_{p1})$ 和 $d(t) = r(t - t_{p2})$，它们都是同一个Ricker子波 $r(t)$ 的时间平移版本。因此，它们的能量相等：\n$$\n\\int_{-\\infty}^{\\infty} s^{2}(t - \\tau) \\mathrm{d}t = \\int_{-\\infty}^{\\infty} s^{2}(u) \\mathrm{d}u = \\int_{-\\infty}^{\\infty} r^{2}(v) \\mathrm{d}v\n$$\n$$\n\\int_{-\\infty}^{\\infty} d^{2}(t) \\mathrm{d}t = \\int_{-\\infty}^{\\infty} r^{2}(v) \\mathrm{d}v\n$$\n设 $E_{r} = \\int_{-\\infty}^{\\infty} r^{2}(t) \\mathrm{d}t$ 为Ricker子波的能量。则第一项和第三项均等于 $E_{r}$。\n\n第二项涉及两个信号的互相关。两个实信号 $f(t)$ 和 $g(t)$ 的互相关通常定义为 $(f \\star g)(\\tau) = \\int_{-\\infty}^{\\infty} f(t) g(t+\\tau) \\mathrm{d}t$。我们表达式中的积分是 $\\int_{-\\infty}^{\\infty} s(t - \\tau) d(t) \\mathrm{d}t$。我们进行换元，令 $u = t - \\tau$，则 $t = u + \\tau$ 且 $\\mathrm{d}t = \\mathrm{d}u$。该积分变为：\n$$\n\\int_{-\\infty}^{\\infty} s(u) d(u+\\tau) \\mathrm{d}u \\;=\\; C_{sd}(\\tau)\n$$\n这是 $s(t)$ 和 $d(t)$ 在延迟为 $\\tau$ 时的互相关。因此，泛函 $J(\\tau)$ 可以写为：\n$$\nJ(\\tau) \\;=\\; \\tfrac{1}{2} \\left( E_{r} \\;-\\; 2 C_{sd}(\\tau) \\;+\\; E_{r} \\right) \\;=\\; E_{r} - C_{sd}(\\tau)\n$$\n为使 $J(\\tau)$ 最小化，我们必须使互相关项 $C_{sd}(\\tau)$ 最大化。让我们用基本子波 $r(t)$ 来表示它：\n$$\nC_{sd}(\\tau) = \\int_{-\\infty}^{\\infty} s(t) d(t+\\tau) \\mathrm{d}t = \\int_{-\\infty}^{\\infty} r(t - t_{p1}) r(t + \\tau - t_{p2}) \\mathrm{d}t\n$$\n我们再进行一次变量替换，令 $v = t - t_{p1}$，则 $t = v + t_{p1}$ 且 $\\mathrm{d}t = \\mathrm{d}v$。\n$$\nC_{sd}(\\tau) = \\int_{-\\infty}^{\\infty} r(v) r(v + t_{p1} + \\tau - t_{p2}) \\mathrm{d}v\n$$\n这个表达式是Ricker子波的自相关 $C_{rr}(\\delta) = \\int_{-\\infty}^{\\infty} r(v) r(v+\\delta) \\mathrm{d}v$ 在特定时间延迟 $\\delta = \\tau + t_{p1} - t_{p2}$ 处的值。\n$$\nC_{sd}(\\tau) = C_{rr}(\\tau + t_{p1} - t_{p2})\n$$\n根据自相关的性质（柯西-施瓦茨不等式的一个特例），任何实信号的自相关函数在零延迟处取得最大值，即对所有 $\\delta$ 都有 $C_{rr}(\\delta) \\le C_{rr}(0)$。因此，$C_{sd}(\\tau)$ 的最大值出现在 $C_{rr}$ 的自变量为零时。\n$$\n\\tau^{\\ast} + t_{p1} - t_{p2} = 0\n$$\n求解最优时间偏移 $\\tau^{\\ast}$ 可得：\n$$\n\\tau^{\\ast} = t_{p2} - t_{p1}\n$$\n这就是泛函 $J(\\tau)$ 的精确极小值点。$\\tau^{\\ast}$ 的单位是秒，因为它是两个时间测量值之差。\n\n### 第2部分：凸盆半宽度 $\\delta_{c}$ 的推导\n\n$J(\\tau)$ 在其极小值点 $\\tau^{\\ast}$ 周围的凸盆被定义为其二阶导数 $J''(\\tau)$ 严格为正的最大连通开区间。我们定义一个新变量 $\\delta = \\tau - \\tau^{\\ast}$，它表示相对于最佳对齐位置的时间偏移。泛函 $J(\\tau)$ 可以用 $\\delta$ 表示为：\n$$\nJ(\\tau) = J(\\tau^{\\ast} + \\delta) = E_{r} - C_{rr}(\\delta)\n$$\n我们计算 $J$ 关于 $\\tau$ 的一阶和二阶导数，这等价于关于 $\\delta$ 的导数：\n$$\nJ'(\\tau) = \\frac{\\mathrm{d}}{\\mathrm{d}\\delta} \\left[ E_{r} - C_{rr}(\\delta) \\right] = -C'_{rr}(\\delta)\n$$\n$$\nJ''(\\tau) = \\frac{\\mathrm{d}^{2}}{\\mathrm{d}\\delta^{2}} \\left[ E_{r} - C_{rr}(\\delta) \\right] = -C''_{rr}(\\delta)\n$$\n凸性的条件是 $J''(\\tau) > 0$，即：\n$$\n-C''_{rr}(\\delta) > 0 \\quad \\implies \\quad C''_{rr}(\\delta)  0\n$$\n问题指定使用窄带近似，其中归一化自相关函数在中心频率 $f_0$ 附近局部表现为余弦函数：\n$$\nA(\\delta) = \\frac{C_{rr}(\\delta)}{C_{rr}(0)} \\approx \\cos(2\\pi f_{0} \\delta)\n$$\n其中 $C_{rr}(0) = E_r$ 是自相关的最大值。因此，我们将 $C_{rr}(\\delta)$ 近似为：\n$$\nC_{rr}(\\delta) \\approx C_{rr}(0) \\cos(2\\pi f_{0} \\delta)\n$$\n现在，我们计算这个近似形式的二阶导数：\n$$\nC'_{rr}(\\delta) \\approx -C_{rr}(0) (2\\pi f_{0}) \\sin(2\\pi f_{0} \\delta)\n$$\n$$\nC''_{rr}(\\delta) \\approx -C_{rr}(0) (2\\pi f_{0})^{2} \\cos(2\\pi f_{0} \\delta)\n$$\n将此代入我们的凸性条件 $C''_{rr}(\\delta)  0$ 中：\n$$\n-C_{rr}(0) (2\\pi f_{0})^{2} \\cos(2\\pi f_{0} \\delta)  0\n$$\n由于能量 $C_{rr}(0)$ 为正，$(2\\pi f_{0})^{2}$ 也为正，该不等式简化为：\n$$\n-\\cos(2\\pi f_{0} \\delta)  0 \\quad \\implies \\quad \\cos(2\\pi f_{0} \\delta) > 0\n$$\n我们需要找到满足此条件的围绕 $\\delta=0$ 的最大连通开区间。余弦函数在其自变量严格介于 $-\\pi/2$ 和 $\\pi/2$ 之间时为正。\n$$\n-\\frac{\\pi}{2}  2\\pi f_{0} \\delta  \\frac{\\pi}{2}\n$$\n两边同除以 $2\\pi f_{0}$（因为 $f_0 > 0$），我们得到 $\\delta$ 的区间：\n$$\n-\\frac{1}{4f_{0}}  \\delta  \\frac{1}{4f_{0}}\n$$\n这个区间就是围绕极小值点的凸盆。该区间的半宽度 $\\delta_c$为：\n$$\n\\delta_{c} = \\frac{1}{4f_{0}}\n$$\n问题要求无量纲比率 $\\delta_{c}/T_{0}$，其中中心周期 $T_{0} = 1/f_{0}$。\n$$\n\\frac{\\delta_{c}}{T_{0}} = \\frac{1/(4f_{0})}{1/f_{0}} = \\frac{1}{4}\n$$\n这个比率表示局部优化方法的“吸引盆”相对于信号主周期的大小。如果初始时间偏移误差在该盆地内（即 $|\\tau - \\tau^{\\ast}|  \\delta_c$），则泛函是凸的，优化将收敛到正确的最小值。\n\n最终答案包括 $\\tau^{\\ast}$ 的表达式和比率 $\\delta_{c}/T_{0}$ 的值。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} t_{p2} - t_{p1} \\\\ \\frac{1}{4} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "基于前一个练习的理论洞察，我们现在转向计算环境，观察周期跳跃的实际表现。在这个动手编程练习中，您将实现一个简单的一维全波形反演，可视化非凸的失配泛函地貌，并见证梯度下降算法如何收敛到错误的解 。此外，您将探索一种基本的缓解策略，通过使用低频源子波来扩大吸引盆，从而证明该方法能显著改善反演问题的处理难度。",
            "id": "3610639",
            "problem": "考虑一个一维、双层、常密度、声波、正入射的背景，在顶层和底层之间的界面上有一个单一的平面反射体。设顶层厚度为 $h$（单位：米），真实顶层速度为 $v_{1}^{\\mathrm{true}}$（单位：米/秒），底层速度为 $v_{2}$（单位：米/秒）。假设已知震源子波为中心频率为 $f_{0}$（单位：赫兹）的Ricker子波 $s(t)$，其中时间 $t$ 的单位为秒。地表单个接收点记录的正演模型是卷积形式的单次反射事件道\n$$\nd(t; v_{1}) = r\\, s\\bigl(t - \\tau(v_{1})\\bigr),\n$$\n其中，界面处的正入射反射系数为\n$$\nr = \\frac{v_{2} - v_{1}^{\\mathrm{true}}}{v_{2} + v_{1}^{\\mathrm{true}}},\n$$\n而穿过顶层的双程旅行时为\n$$\n\\tau(v_{1}) = \\frac{2h}{v_{1}}.\n$$\n为了纯粹关注导致周期跳跃的运动学失配，将 $r$ 视为由 $v_{1}^{\\mathrm{true}}$ 和 $v_{2}$ 计算出的真实值，并固定不变，不使其随 $v_{1}$ 变化。\n\n设观测数据为 $d_{\\mathrm{obs}}(t) = r\\, s\\bigl(t - \\tau(v_{1}^{\\mathrm{true}})\\bigr)$，在 $[0,T_{\\max}]$ 区间内以采样间隔 $\\Delta t$ 在时间上均匀离散。定义最小二乘（$L^2$）数据拟合泛函\n$$\nJ(v_{1}) = \\frac{1}{2}\\int_{0}^{T_{\\max}} \\bigl[d(t; v_{1}) - d_{\\mathrm{obs}}(t)\\bigr]^{2}\\, dt,\n$$\n并使用 $\\Delta t$ 通过相应的黎曼和进行近似。\n\nRicker子波是带限零相位子波\n$$\ns(t) = \\bigl(1 - 2\\alpha t^{2}\\bigr)\\, e^{-\\alpha t^{2}}, \\quad \\alpha = \\bigl(\\pi f_{0}\\bigr)^{2}.\n$$\n\n您的任务如下，从基本定义出发，不使用任何预先推导的反演公式：\n\n- 对于模型 $d(t; v_{1}) = r\\, s\\bigl(t - \\tau(v_{1})\\bigr)$（其中振幅 $r$ 固定），推导 $J$ 相对于旅行时 $\\tau$ 的解析梯度，即 $\\partial J/\\partial \\tau$。然后，设计一个在变量 $\\tau$ 上使用回溯 Armijo 线搜索的梯度下降算法来最小化 $J$；每次更新后，使用 $v_{1} = 2h/\\tau$ 将迭代结果映射回 $v_{1}$。通过将 $\\tau$ 投影到 $[\\tau_{\\min}, \\tau_{\\max}]$ 区间（其中 $\\tau_{\\min} = 2h/v_{\\max}$ 和 $\\tau_{\\max} = 2h/v_{\\min}$），来施加物理上合理的边界 $v_{1} \\in [v_{\\min}, v_{\\max}]$。\n- 使用下面提供的参数和单位，数值上实现正演模拟、拟合差评估和梯度下降最小化。\n- 通过检查拟合差随 $v_{1}$ 变化的函数，在相对较高的中心频率下，评估并解释与周期跳跃相关的虚假极小值的出现，并通过对较低的中心频率重复分析来展示缓解效果。\n\n在整个过程中，请一致使用以下参数值和单位：\n\n- 地层几何与速度：$h = 500$ 米, $v_{1}^{\\mathrm{true}} = 2000$ 米/秒, $v_{2} = 2500$ 米/秒。\n- 采样与时间窗口：$\\Delta t = 0.001$ 秒, $T_{\\max} = 2.0$ 秒。\n- 用于周期跳跃分析的高中心频率：$f_{0}^{\\mathrm{hi}} = 12.0$ 赫兹，周期为 $T_{0}^{\\mathrm{hi}} = 1/f_{0}^{\\mathrm{hi}}$。\n- 用于缓解效果分析的低中心频率：$f_{0}^{\\mathrm{lo}} = 3.0$ 赫兹，周期为 $T_{0}^{\\mathrm{lo}} = 1/f_{0}^{\\mathrm{lo}}$。\n- 用于反演的速度边界：$v_{\\min} = 1400$ 米/秒, $v_{\\max} = 2600$ 米/秒。\n- 用于反演的两个不同初始猜测值：$v_{1}^{(0,\\mathrm{near})} = 1900$ 米/秒 和 $v_{1}^{(0,\\mathrm{far})} = 1400$ 米/秒。\n\n测试套件与要求输出：\n\n1) 整周期时移处的拟合差（高频）。定义 $v_{k} = \\dfrac{2h}{\\tau(v_{1}^{\\mathrm{true}}) + k T_{0}^{\\mathrm{hi}}}$，其中 $k \\in \\{0,1,2\\}$ 且 $\\tau(v_{1}^{\\mathrm{true}}) = 2h/v_{1}^{\\mathrm{true}}$。使用 $f_{0}^{\\mathrm{hi}}$ 以及用 $f_{0}^{\\mathrm{hi}}$ 构建的 $d_{\\mathrm{obs}}(t)$ 来计算 $J(v_{k})$。报告三个浮点数值 $J(v_{0}), J(v_{1}), J(v_{2})$。\n\n2) 路径依赖的最小化（高频）。使用在 $\\tau$ 上的带有回溯 Armijo 线搜索和投影的梯度下降算法，以 $f_{0}^{\\mathrm{hi}}$ 为频率，从两个初始猜测值 $v_{1}^{(0,\\mathrm{near})}$ 和 $v_{1}^{(0,\\mathrm{far})}$ 开始最小化 $J$。报告两个最终估计的速度浮点值，$v_{1}^{\\ast,\\mathrm{near}}$ 和 $v_{1}^{\\ast,\\mathrm{far}}$，单位均为米/秒。\n\n3) 统计局部极小值数量以说明周期跳跃及其缓解。在均匀采样的 $1201$ 个点的网格 $v_{1} \\in [v_{\\min}, v_{\\max}]$ 上，分别计算高频 $f_{0}^{\\mathrm{hi}}$ 和低频 $f_{0}^{\\mathrm{lo}}$ 下 $J(v_{1})$ 的严格局部极小值的数量。报告两个布尔值：一个表示高频拟合差在该网格上是否有多于一个局部极小值，另一个表示低频拟合差在该网格上是否恰好有一个局部极小值。\n\n数值与输出要求：\n\n- 所有计算必须使用上述指定的单位；特别是，速度单位为米/秒，时间单位为秒。\n- 将所有浮点输出四舍五入到六位小数。\n- 最终程序输出必须是单行，形式为方括号内以逗号分隔的列表：\n  $[J(v_{0}),J(v_{1}),J(v_{2}),v_{1}^{\\ast,\\mathrm{near}},v_{1}^{\\ast,\\mathrm{far}},\\text{has\\_multi\\_min\\_hi},\\text{has\\_single\\_min\\_lo}]$\n  其中前五项是浮点数，后两项是布尔值。\n- 您的程序必须是自包含的，不需要用户输入或外部文件。它必须使用给定的参数在内部构建 $d_{\\mathrm{obs}}(t)$。",
            "solution": "该问题要求使用一个简化的一维声波模型，分析地震全波形反演（FWI）中的周期跳跃现象。这涉及到推导和实现一个基于梯度的优化算法来最小化数据拟合差，并观察其在不同震源频率内容下的行为。\n\n### 问题验证\n\n问题陈述已经过验证，被认为是**有效的**。\n- **科学依据**：该问题基于波传播和反演理论的基本原理，特别是地震记录的卷积模型、$L^2$范数数据拟合差以及FWI中的周期跳跃概念。所有模型、参数和概念都是计算地球物理学中的标准内容。\n- **适定性**：任务定义清晰，并提供了所有必要的参数。目标是实现一个标准的数值优化程序，并在一个明确定义的背景下分析其结果。局部极小值的存在是研究的主题，而不是问题陈述中的缺陷。\n- **客观性与完整性**：问题使用精确的数学语言和量化数据来呈现。它是自包含的，没有歧义、主观陈述或事实错误。\n\n### 数学推导与算法设计\n\n**1. 正演模型与拟合泛函**\n\n正演模型为给定的顶层速度 $v_1$ 计算合成地震记录 $d(t; v_1)$，定义如下：\n$$\nd(t; v_{1}) = r\\, s\\bigl(t - \\tau(v_{1})\\bigr)\n$$\n其中 $s(t)$ 是Ricker子波震源信号，$r$ 是固定的反射系数，$\\tau(v_1) = 2h/v_1$ 是双程旅行时。观测数据 $d_{\\mathrm{obs}}(t)$ 对应于真实速度 $v_1^{\\mathrm{true}}$：\n$$\nd_{\\mathrm{obs}}(t) = r\\, s\\bigl(t - \\tau(v_{1}^{\\mathrm{true}})\\bigr)\n$$\n反演的目标是找到模型参数 $v_1$，以最小化合成数据和观测数据之间的差异。这由 $L^2$ 数据拟合泛函 $J(v_1)$ 来量化，我们将其视为旅行时 $\\tau = \\tau(v_1)$ 的函数：\n$$\nJ(\\tau) = \\frac{1}{2}\\int_{0}^{T_{\\max}} \\bigl[d(t; \\tau) - d_{\\mathrm{obs}}(t)\\bigr]^{2}\\, dt\n$$\n\n**2. 拟合泛函的梯度**\n\n为了使用梯度下降优化算法，我们必须计算 $J$ 相对于优化变量 $\\tau$ 的梯度。使用泛函的链式法则（Leibniz积分法则的直接应用）：\n$$\n\\frac{\\partial J}{\\partial \\tau} = \\frac{\\partial}{\\partial \\tau} \\left( \\frac{1}{2}\\int_{0}^{T_{\\max}} [d(t; \\tau) - d_{\\mathrm{obs}}(t)]^2 dt \\right) = \\int_{0}^{T_{\\max}} [d(t; \\tau) - d_{\\mathrm{obs}}(t)] \\frac{\\partial}{\\partial \\tau} [d(t; \\tau)] dt\n$$\n正演模型 $d(t; \\tau) = r\\,s(t-\\tau)$ 对 $\\tau$ 的导数为：\n$$\n\\frac{\\partial d(t; \\tau)}{\\partial \\tau} = r \\frac{\\partial}{\\partial \\tau} s(t-\\tau) = r \\cdot s'(t-\\tau) \\cdot \\frac{\\partial(t-\\tau)}{\\partial \\tau} = -r\\,s'(t-\\tau)\n$$\n其中 $s'(t)$ 是 Ricker 子波的时间导数。将其代回，得到梯度表达式：\n$$\n\\frac{\\partial J}{\\partial \\tau} = \\int_{0}^{T_{\\max}} \\underbrace{[d(t; \\tau) - d_{\\mathrm{obs}}(t)]}_{\\text{数据残差}} \\cdot \\underbrace{[-r\\,s'(t - \\tau)]}_{\\text{伴随源}} dt\n$$\n这个经典结果表明，梯度是数据残差与合成数据时间导数（通常称为“伴随源”）的零延迟互相关。对于数值实现，该积分通过对时间样本 $t_i$ 的离散求和来近似：\n$$\n\\frac{\\partial J}{\\partial \\tau} \\approx \\sum_{i} [d(t_i; \\tau) - d_{\\mathrm{obs}}(t_i)] \\cdot [-r\\,s'(t_i - \\tau)] \\Delta t\n$$\n\n**3. 带有投影和线搜索的梯度下降算法**\n\n我们将实现一个投影梯度下降算法来最小化 $J(\\tau)$。该算法在负梯度方向上迭代地更新当前对 $\\tau$ 的估计。\n\n迭代更新规则是：\n$$\n\\tau^{(k+1)} = \\mathrm{proj}_{[\\tau_{\\min}, \\tau_{\\max}]} \\left( \\tau^{(k)} - \\beta^{(k)} \\frac{\\partial J}{\\partial \\tau}\\bigg|_{\\tau^{(k)}} \\right)\n$$\n其中：\n- $k$ 是迭代次数。\n- $\\frac{\\partial J}{\\partial \\tau}\\big|_{\\tau^{(k)}}$ 是在当前迭代点 $\\tau^{(k)}$ 处计算的梯度。\n- $\\beta^{(k)}$ 是步长，由回溯 Armijo 线搜索确定。\n- $\\mathrm{proj}_{[\\tau_{\\min}, \\tau_{\\max}]}(\\cdot)$ 是投影算子，它将一个 $\\tau$ 值映射到可行区间 $[\\tau_{\\min}, \\tau_{\\max}]$ 内最近的点。这强制执行了速度约束 $v_1 \\in [v_{\\min}, v_{\\max}]$。\n\n用于寻找合适步长 $\\beta$ 的回溯 Armijo 线搜索过程如下：从一个初始猜测 $\\beta_0$ 开始，我们通过一个因子 $\\sigma \\in (0,1)$ 迭代地减小 $\\beta$，直到满足充分下降条件：\n$$\nJ(\\tau_{\\text{trial}}) \\le J(\\tau^{(k)}) - c \\beta \\left( \\frac{\\partial J}{\\partial \\tau}\\bigg|_{\\tau^{(k)}} \\right)^2\n$$\n其中 $\\tau_{\\text{trial}} = \\mathrm{proj}_{[\\tau_{\\min}, \\tau_{\\max}]} \\left( \\tau^{(k)} - \\beta \\frac{\\partial J}{\\partial \\tau}\\big|_{\\tau^{(k)}} \\right)$ 是试验迭代点，$c \\in (0,1)$ 是一个控制参数（例如，$c=10^{-4}$）。\n\n### 周期跳跃分析\n\n当拟合泛函 $J(v_1)$ 是非凸的，表现出多个局部极小值时，就会发生周期跳跃。当初始模型与真实模型的距离“超过半个波长”时，这种情况就会发生。时移误差 $\\Delta \\tau = \\tau(v_{1}) - \\tau(v_1^{\\mathrm{true}})$ 变得与子波的主周期 $T_0 = 1/f_0$ 相当或更大。基于梯度的算法可能会陷入这些虚假的局部极小值中，无法找到对应于真实模型的全局极小值。\n\n- **高频情况 ($f_{0}^{\\mathrm{hi}}$)**：主周期 $T_0^{\\mathrm{hi}}$ 很短。速度的微小变化可能导致时移 $\\Delta\\tau$ 是 $T_0^{\\mathrm{hi}}$ 的整数倍，从而在一个合理的速度搜索范围内产生多个局部极小值。\n- **低频情况 ($f_{0}^{\\mathrm{lo}}$)**：主周期 $T_0^{\\mathrm{lo}}$ 很长。在相同的速度搜索范围内，拟合泛函变得更平滑，更像凸函数，因为需要更大的速度误差才能产生周期跳跃。这缓解了问题，通常只留下一个极小值。\n\n数值实现将执行指定的三个任务：\n1.  评估高频情况下对应于整周期时移的速度处的拟合差，以证明局部极小值的存在。\n2.  从两个不同的起始点（一个靠近真实模型，一个远离）运行梯度下降最小化器，以显示路径依赖的收敛性。\n3.  在高频和低频情况下，在一个速度网格上统计拟合函数中局部极小值的数量，以明确展示频率对凸性的影响。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D FWI cycle-skipping problem.\n    \"\"\"\n    \n    # ----------------------------------------------------------------------\n    # 1. PARAMETERS AND SETUP\n    # ----------------------------------------------------------------------\n    \n    # Physical and model parameters\n    H = 500.0  # Top-layer thickness in meters\n    V1_TRUE = 2000.0  # True top-layer velocity in m/s\n    V2 = 2500.0  # Bottom-layer velocity in m/s\n    \n    # Time sampling parameters\n    DT = 0.001  # Time sampling interval in seconds\n    T_MAX = 2.0  # Maximum recording time in seconds\n    \n    # Source frequency parameters\n    F0_HI = 12.0  # High central frequency in Hz\n    F0_LO = 3.0  # Low central frequency in Hz\n    \n    # Inversion parameters\n    V_MIN = 1400.0  # Minimum velocity bound in m/s\n    V_MAX = 2600.0  # Maximum velocity bound in m/s\n    V1_INIT_NEAR = 1900.0  # \"Near\" initial guess for inversion in m/s\n    V1_INIT_FAR = 1400.0  # \"Far\" initial guess for inversion in m/s\n\n    # Create the time axis for the seismograms\n    t_array = np.arange(0, T_MAX, DT)\n    \n    # Calculate the true reflection coefficient (held fixed throughout)\n    r_coeff = (V2 - V1_TRUE) / (V2 + V1_TRUE)\n\n    # ----------------------------------------------------------------------\n    # 2. CORE FUNCTIONS\n    # ----------------------------------------------------------------------\n\n    def ricker(t, f0):\n        \"\"\"Computes the Ricker wavelet s(t).\"\"\"\n        alpha = (np.pi * f0)**2\n        return (1.0 - 2.0 * alpha * t**2) * np.exp(-alpha * t**2)\n\n    def ricker_derivative(t, f0):\n        \"\"\"Computes the time derivative of the Ricker wavelet, s'(t).\"\"\"\n        alpha = (np.pi * f0)**2\n        return 2.0 * alpha * t * (2.0 * alpha * t**2 - 3.0) * np.exp(-alpha * t**2)\n\n    def forward_model(v1, h, r, t, f0):\n        \"\"\"Computes the synthetic data d(t; v1).\"\"\"\n        tau = 2.0 * h / v1\n        return r * ricker(t - tau, f0)\n\n    def misfit_functional(d_synth, d_obs, dt):\n        \"\"\"Computes the L2 misfit functional J.\"\"\"\n        return 0.5 * np.sum((d_synth - d_obs)**2) * dt\n\n    def gradient_tau(tau, d_obs, r, h, t, f0, dt):\n        \"\"\"Computes the gradient of J with respect to travel time tau.\"\"\"\n        v1 = 2.0 * h / tau\n        d_synth = forward_model(v1, h, r, t, f0)\n        residual = d_synth - d_obs\n        adjoint_source = -r * ricker_derivative(t - tau, f0)\n        return np.sum(residual * adjoint_source) * dt\n    \n    # ----------------------------------------------------------------------\n    # 3. TASK EXECUTION\n    # ----------------------------------------------------------------------\n\n    results = []\n\n    # --- Task 1: Misfit at integer-cycle time shifts (high frequency) ---\n    f0 = F0_HI\n    d_obs_hi = forward_model(V1_TRUE, H, r_coeff, t_array, f0)\n    tau_true = 2.0 * H / V1_TRUE\n    T0_hi = 1.0 / f0\n    \n    misfits_k = []\n    for k in range(3):\n        tau_k = tau_true + k * T0_hi\n        v_k = 2.0 * H / tau_k\n        d_k = forward_model(v_k, H, r_coeff, t_array, f0)\n        J_k = misfit_functional(d_k, d_obs_hi, DT)\n        misfits_k.append(J_k)\n    results.extend(misfits_k)\n\n    # --- Task 2: Path-dependent minimization (high frequency) ---\n    tau_min = 2.0 * H / V_MAX\n    tau_max = 2.0 * H / V_MIN\n\n    def minimize_J(v1_init, f0_in, d_obs_in):\n        \"\"\"Performs gradient descent with projection and Armijo line search.\"\"\"\n        tau = 2.0 * H / v1_init\n        \n        # Optimization parameters\n        max_iter = 100\n        grad_tol = 1e-9\n        beta_init = 1.0  # Initial step size guess for line search\n        c_armijo = 1e-4 # Armijo condition parameter\n        sigma_bt = 0.5   # Backtracking reduction factor\n        \n        for _ in range(max_iter):\n            grad_val = gradient_tau(tau, d_obs_in, r_coeff, H, t_array, f0_in, DT)\n            \n            if abs(grad_val)  grad_tol:\n                break\n            \n            # Backtracking line search\n            beta = beta_init\n            J_current = misfit_functional(forward_model(2.0 * H / tau, H, r_coeff, t_array, f0_in), d_obs_in, DT)\n            step_found = False\n            \n            while beta > 1e-12:\n                tau_trial = np.clip(tau - beta * grad_val, tau_min, tau_max)\n                J_trial = misfit_functional(forward_model(2.0 * H / tau_trial, H, r_coeff, t_array, f0_in), d_obs_in, DT)\n                \n                armijo_cond = J_current - c_armijo * beta * grad_val**2\n                if J_trial = armijo_cond:\n                    tau = tau_trial\n                    step_found = True\n                    break\n                beta *= sigma_bt\n            \n            if not step_found:\n                break  # Stop if line search fails\n                \n        return 2.0 * H / tau\n\n    v_star_near = minimize_J(V1_INIT_NEAR, F0_HI, d_obs_hi)\n    v_star_far = minimize_J(V1_INIT_FAR, F0_HI, d_obs_hi)\n    results.extend([v_star_near, v_star_far])\n\n    # --- Task 3: Counting local minima ---\n    v1_grid = np.linspace(V_MIN, V_MAX, 1201)\n    \n    # High-frequency analysis\n    J_hi_values = np.array([misfit_functional(forward_model(v, H, r_coeff, t_array, F0_HI), d_obs_hi, DT) for v in v1_grid])\n    num_minima_hi = 0\n    for i in range(1, len(v1_grid) - 1):\n        if J_hi_values[i-1] > J_hi_values[i] and J_hi_values[i]  J_hi_values[i+1]:\n            num_minima_hi += 1\n    has_multi_min_hi = num_minima_hi > 1\n    results.append(has_multi_min_hi)\n    \n    # Low-frequency analysis\n    d_obs_lo = forward_model(V1_TRUE, H, r_coeff, t_array, F0_LO)\n    J_lo_values = np.array([misfit_functional(forward_model(v, H, r_coeff, t_array, F0_LO), d_obs_lo, DT) for v in v1_grid])\n    num_minima_lo = 0\n    for i in range(1, len(v1_grid) - 1):\n        if J_lo_values[i-1] > J_lo_values[i] and J_lo_values[i]  J_lo_values[i+1]:\n            num_minima_lo += 1\n    has_single_min_lo = num_minima_lo == 1\n    results.append(has_single_min_lo)\n\n    # ----------------------------------------------------------------------\n    # 4. FINAL OUTPUT\n    # ----------------------------------------------------------------------\n    \n    def format_value(v):\n        if isinstance(v, float):\n            return f\"{v:.6f}\"\n        return str(v)\n\n    formatted_results = [format_value(res) for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然多尺度方法是有效的，但研究人员也开发了对周期跳跃具有更强鲁棒性的替代失配泛函。本练习将介绍二次Wasserstein ($W_2$) 度量，这是一个源于最优传输理论的强大工具。通过一系列有针对性的数值实验，您将构建“对抗性”场景，以突显$L^2$范数的弱点，并展示$W_2$度量在处理相位和极性失配方面的卓越鲁棒性 。这一探索将为您深入理解为何基于最优传输的失配泛函是构建更凸、更可靠FWI目标函数的一个有前景的方向提供宝贵见解。",
            "id": "3610593",
            "problem": "考虑在长度为 $L$ 米的水平分层介质中的一维声学全波形反演（FWI）。记录的数据被建模为延迟的源子波。令 $v(x)$ 表示声速，$s(x) = 1/v(x)$ 表示慢度，长度为 $L$ 的路径的运动学走时为 $T = \\int_0^L s(x) \\, \\mathrm{d}x$。假设单个主导到时可以由一个延迟了 $T$ 并由振幅因子 $A$ 缩放的 Ricker 子波 $w(t)$ 充分表示。观测数据道是 $d_{\\mathrm{obs}}(t) = A_{\\mathrm{true}} \\, w(t - T_{\\mathrm{true}})$，来自一个真实模型，其走时为 $T_{\\mathrm{true}}$。一个基线反演模型产生 $d_0(t) = A_0 \\, w(t - T_0)$，其走时为 $T_0$，振幅为 $A_0$。\n\n定义常规的最小二乘($L^2$)失配泛函\n$$\n\\Phi_{L^2}(m) = \\frac{1}{2} \\int_{0}^{T_{\\max}} \\left(d_{\\mathrm{pred}}(t; m) - d_{\\mathrm{obs}}(t)\\right)^2 \\, \\mathrm{d}t,\n$$\n其单位为子波振幅的平方乘以秒，其中 $d_{\\mathrm{pred}}(t; m)$ 表示模型参数 $m$ 的预测数据，$T_{\\max}$ 是记录时间长度。\n\n定义两个道相关的能量归一化正测度之间的二次 Wasserstein 度量（记为 $W_2$）。对于一个道 $d(t)$，定义其非负能量密度 $e(t) = d(t)^2 + \\epsilon$，其中有一个小的 $0  \\epsilon \\ll 1$ 以避免零质量，并将其归一化为概率密度 $\\mu(t) = e(t) / \\int_0^{T_{\\max}} e(t) \\, \\mathrm{d}t$。令 $\\mu(t)$ 为预测道的相应密度，$\\nu(t)$ 为观测道的相应密度。累积分布函数为 $F(t) = \\int_0^t \\mu(\\tau) \\, \\mathrm{d}\\tau$ 和 $G(t) = \\int_0^t \\nu(\\tau) \\, \\mathrm{d}\\tau$。二次 Wasserstein 度量为\n$$\n\\Phi_{W_2}(m) = \\left( \\int_0^1 \\left| F^{-1}(p) - G^{-1}(p) \\right|^2 \\, \\mathrm{d}p \\right)^{1/2},\n$$\n其单位为秒。\n\n您将构建对抗性模型扰动 $\\delta m$，相对于基线模型，该扰动会增加最小二乘失配 $\\Phi_{L^2}$ 但减小 Wasserstein 度量 $\\Phi_{W_2}$。这些对抗性扰动利用了 $\\Phi_{L^2}$ 的相位敏感性和 $\\Phi_{W_2}$ 的质量传输特性。\n\n基本原理：\n\n- 一维声波方程意味着慢度 $s(x)$ 的微小变化会改变走时 $T = \\int_0^L s(x) \\, \\mathrm{d}x$，从而改变子波的到时。这是一个经过充分检验的、适用于初至波和简单反射的运动学近似。\n- Ricker子波定义为 $w(t) = \\left(1 - 2 (\\pi f_0 t)^2\\right) \\exp\\left( - (\\pi f_0 t)^2 \\right)$，其中 $f_0$ 是中心频率，单位为赫兹，它产生一个在地震建模中常用的带限脉冲。\n- 最小二乘失配是逐点的，对相位和极性差异高度敏感，而二次 Wasserstein 度量通过最优输运比较分布，强调能量“质量”沿时间轴的对齐，并在测度归一化后降低对极性和振幅缩放的敏感性。\n\n您必须实现一个程序，对于指定的参数，计算基线和每个对抗性扰动的 $\\Phi_{L^2}$ 和 $\\Phi_{W_2}$，并返回布尔值，指示 $\\Phi_{L^2}$ 是否增加以及 $\\Phi_{W_2}$ 是否减少。所有时间量必须以秒为单位处理，所有距离以米为单位，所有速度以米/秒为单位。\n\n使用以下记录和物理参数：\n- 路径长度 $L = 2000$ 米。\n- 真实速度 $v_{\\mathrm{true}} = 2200$ 米/秒，因此 $T_{\\mathrm{true}} = L / v_{\\mathrm{true}}$ 秒。\n- 基线慢度 $s_0 = 1/v_{\\mathrm{true}} + 5 \\times 10^{-6}$ 秒/米，意味着 $T_0 = \\int_0^L s_0 \\, \\mathrm{d}x$ 秒。\n- 基线振幅 $A_0 = 1$。\n- 观测振幅 $A_{\\mathrm{true}} = 1$。\n- 中心频率 $f_0 = 15$ 赫兹。\n- 记录长度 $T_{\\max} = 2$ 秒，时间采样间隔 $\\Delta t = 0.001$ 秒。\n- 能量下限 $\\epsilon = 10^{-12}$。\n\n构建三个对抗性模型扰动，每个扰动产生一个预测道 $d_{\\mathrm{pred}}(t; m)$:\n1. 精确时间对齐的极性反转：选择 $\\delta s$ 使得 $T = T_{\\mathrm{true}}$ 且 $A = -1$。\n2. 部分时间对齐的振幅过冲：选择 $\\delta s$ 使得 $T = T_{\\mathrm{true}} + 0.005$ 秒 且 $A = 2$。\n3. 部分时间对齐的次级到时：选择 $\\delta s$ 使得 $T = T_{\\mathrm{true}} + 0.005$ 秒，$A = 1$，并在 $T + 0.03$ 秒处添加一个振幅为 $B = 0.5$ 的弱次级到时，因此 $d_{\\mathrm{pred}}(t; m) = A \\, w(t - T) + B \\, w\\left(t - (T + 0.03)\\right)$。\n\n对于上述三个扰动中的每一个，计算基线失配 $\\Phi_{L^2}(m_0)$ 和 $\\Phi_{W_2}(m_0)$ 以及扰动后的失配 $\\Phi_{L^2}(m_0 + \\delta m)$ 和 $\\Phi_{W_2}(m_0 + \\delta m)$。对于每种情况，确定布尔值 $b = (\\Phi_{L^2}(m_0 + \\delta m) > \\Phi_{L^2}(m_0)) \\land (\\Phi_{W_2}(m_0 + \\delta m)  \\Phi_{W_2}(m_0))$。\n\n测试套件：\n- 情况 1：极性反转，$T = T_{\\mathrm{true}}$ 且 $A = -1$。\n- 情况 2：振幅过冲，$T = T_{\\mathrm{true}} + 0.005$ 且 $A = 2$。\n- 情况 3：次级到时，$T = T_{\\mathrm{true}} + 0.005$，$A = 1$，且次级振幅 $B = 0.5$ 在 $T + 0.03$ 处。\n\n您的程序应生成一行输出，其中包含三个布尔结果，形式为方括号括起来的逗号分隔列表（例如，“[True,False,True]”）。",
            "solution": "用户提供的问题已经过分析并被确定为**有效**。该问题在科学上基于计算地球物理学的原理，特别是全波形反演（FWI），并提出了一个适定、客观且完整的计算任务。唯一解所需的所有参数和定义均已提供。因此，我们可以着手解决。\n\n目标是比较两种失配泛函——常规最小二乘（$L^2$）和二次 Wasserstein（$W_2$）——在三种特定的“对抗性”数据扰动下的行为。这些扰动旨在创建这样一种情景：$L^2$ 失配增加，表明模型拟合更差，而 $W_2$ 失配减少，表明拟合有所改善。这突显了 $L^2$ 范数固有的周期跳跃问题以及 $W_2$ 度量缓解该问题的潜力。\n\n首先，我们建立计算框架。模拟时间从 $t=0$ 到 $T_{\\max}=2$ 秒，采样间隔为 $\\Delta t = 0.001$ 秒。这定义了一个离散时间轴 $t_k = k \\Delta t$，其中 $k = 0, 1, \\dots, \\lfloor(T_{\\max}-0)/\\Delta t\\rfloor - 1$。\n\n源信号是中心频率为 $f_0 = 15$ Hz的 Ricker 子波，定义为：\n$$\nw(t) = \\left(1 - 2 (\\pi f_0 t)^2\\right) \\exp\\left( - (\\pi f_0 t)^2 \\right)\n$$\n\n接下来，我们定义用于比较的各种数据道。\n“真实”或观测数据 $d_{\\mathrm{obs}}(t)$ 对应于一个真实模型，其在长度为 $L = 2000$ 米的路径上具有恒定速度 $v_{\\mathrm{true}} = 2200$ 米/秒。因此，走时为：\n$$\nT_{\\mathrm{true}} = \\frac{L}{v_{\\mathrm{true}}} = \\frac{2000}{2200} = \\frac{10}{11} \\approx 0.90909 \\text{ s}\n$$\n观测道为 $d_{\\mathrm{obs}}(t) = A_{\\mathrm{true}} \\, w(t - T_{\\mathrm{true}})$，振幅为 $A_{\\mathrm{true}} = 1$。\n\n基线模型具有恒定的慢度 $s_0 = 1/v_{\\mathrm{true}} + 5 \\times 10^{-6}$ 秒/米。其相应的走时 $T_0$ 为：\n$$\nT_0 = L \\cdot s_0 = L \\left(\\frac{1}{v_{\\mathrm{true}}} + 5 \\times 10^{-6}\\right) = T_{\\mathrm{true}} + 2000 \\cdot (5 \\times 10^{-6}) = T_{\\mathrm{true}} + 0.01 \\text{ s} \\approx 0.91909 \\text{ s}\n$$\n基线预测道为 $d_0(t) = A_0 \\, w(t - T_0)$，振幅为 $A_0 = 1$。\n\n三个对抗性预测道按规定构建：\n1.  极性反转：$d_1(t) = -1 \\cdot w(t - T_{\\mathrm{true}})$\n2.  振幅过冲：$d_2(t) = 2 \\cdot w(t - (T_{\\mathrm{true}} + 0.005))$\n3.  次级到时：$d_3(t) = 1 \\cdot w(t - (T_{\\mathrm{true}} + 0.005)) + 0.5 \\cdot w(t - (T_{\\mathrm{true}} + 0.035))$\n\n定义了数据道之后，我们概述失配泛函的数值计算方法。\n\n$L^2$ 失配 $\\Phi_{L^2}$ 通过数值积分预测数据和观测数据之间逐点差的平方来计算。对于离散时间序列，这通过求和来近似：\n$$\n\\Phi_{L^2}(m) \\approx \\frac{1}{2} \\sum_{k} \\left(d_{\\mathrm{pred}}(t_k) - d_{\\mathrm{obs}}(t_k)\\right)^2 \\Delta t\n$$\n\n二次 Wasserstein 失配 $\\Phi_{W_2}$ 需要几个步骤：\n1.  对于给定的道 $d(t)$，其非负能量密度定义为 $e(t) = d(t)^2 + \\epsilon$，其中正则化项 $\\epsilon = 10^{-12}$。\n2.  该能量密度被归一化以形成概率密度函数（PDF）$\\mu(t) = e(t) / \\int_0^{T_{\\max}} e(\\tau) \\, \\mathrm{d}\\tau$。令 $\\mu(t)$ 为 $d_{\\mathrm{pred}}(t)$ 的 PDF，$\\nu(t)$ 为 $d_{\\mathrm{obs}}(t)$ 的 PDF。该积分使用例如梯形法则进行数值计算。\n3.  通过对PDF进行数值积分来计算相应的累积分布函数（CDF）：$F(t) = \\int_0^t \\mu(\\tau) \\, \\mathrm{d}\\tau$ 和 $G(t) = \\int_0^t \\nu(\\tau) \\, \\mathrm{d}\\tau$。这通过累积梯形积分方案来执行。\n4.  对于均匀的概率值网格 $p \\in [0, 1]$，计算分位数函数（CDF的反函数）$F^{-1}(p)$ 和 $G^{-1}(p)$。由于离散的CDF可能不是严格单调的，我们找到CDF中的唯一值，并使用线性插值来找到对应于每个概率 $p$ 的时间 $t$。\n5.  最后，通过积分分位数函数的平方差来计算 $W_2$ 度量：\n$$\n\\Phi_{W_2}(m) = \\left( \\int_0^1 \\left( F^{-1}(p) - G^{-1}(p) \\right)^2 \\, \\mathrm{d}p \\right)^{1/2}\n$$\n该积分也通过在概率值 $p$ 的网格上使用梯形法则进行数值计算。\n\n分析过程如下：首先通过比较 $d_0(t)$ 和 $d_{\\mathrm{obs}}(t)$ 来计算基线失配 $\\Phi_{L^2}(m_0)$ 和 $\\Phi_{W_2}(m_0)$。然后，对于三个扰动道 $d_k(t)$ 中的每一个，计算相应的失配 $\\Phi_{L^2}(m_k)$ 和 $\\Phi_{W_2}(m_k)$。对于每种情况 $k \\in \\{1, 2, 3\\}$，我们评估布尔条件：\n$$\nb_k = (\\Phi_{L^2}(m_k) > \\Phi_{L^2}(m_0)) \\land (\\Phi_{W_2}(m_k)  \\Phi_{W_2}(m_0))\n$$\n最终输出是这三个布尔结果的列表，$[b_1, b_2, b_3]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Computes and compares L2 and W2 misfits for FWI under adversarial perturbations.\n    \"\"\"\n    #\n    # 1. DEFINE CONSTANTS AND PARAMETERS FROM THE PROBLEM STATEMENT\n    #\n    L = 2000.0  # Path length in meters\n    v_true = 2200.0  # True velocity in m/s\n    A_true = 1.0  # True amplitude\n    f0 = 15.0  # Ricker wavelet central frequency in Hz\n    A0 = 1.0  # Baseline amplitude\n    s0_delta = 5.0e-6  # Slowness perturbation for baseline model in s/m\n    T_max = 2.0  # Recording length in seconds\n    dt = 0.001  # Time sampling interval in seconds\n    epsilon = 1.0e-12  # Energy floor for Wasserstein metric\n\n    #\n    # 2. CALCULATE DERIVED PARAMETERS AND SET UP TIME GRID\n    #\n    t = np.arange(0, T_max, dt)\n    s_true = 1.0 / v_true\n    T_true = L * s_true\n    s0 = s_true + s0_delta\n    T0 = L * s0\n\n    #\n    # 3. DEFINE HELPER FUNCTIONS FOR WAVELET AND MISFITS\n    #\n    def ricker_wavelet(t_shifted, f0_val):\n        \"\"\"Generates a Ricker wavelet for given time values and frequency.\"\"\"\n        a = (np.pi * f0_val * t_shifted)**2\n        return (1.0 - 2.0 * a) * np.exp(-a)\n\n    def l2_misfit(d_pred, d_obs, delta_t):\n        \"\"\"Computes the L2 misfit functional.\"\"\"\n        return 0.5 * np.sum((d_pred - d_obs)**2) * delta_t\n\n    def w2_misfit(d_pred, d_obs, time_axis, delta_t, eps):\n        \"\"\"Computes the quadratic Wasserstein metric between two traces.\"\"\"\n        \n        def get_quantile_function(d, t_ax, dt_val, eps_val):\n            # Calculate energy density with a small floor\n            e = d**2 + eps_val\n            \n            # Normalize to get a probability density function (PDF)\n            total_energy = np.trapz(e, t_ax)\n            mu = e / total_energy\n            \n            # Compute the Cumulative Distribution Function (CDF)\n            cdf = cumulative_trapezoid(mu, t_ax, initial=0.0)\n            \n            # The quantile function is the inverse of the CDF. We compute it by\n            # interpolating on a uniform probability grid. To handle potential\n            # plateaus in the CDF, we use only the unique CDF values for interpolation.\n            unique_cdf, unique_indices = np.unique(cdf, return_index=True)\n            unique_t = t_ax[unique_indices]\n            \n            p_grid = np.linspace(0.0, 1.0, len(t_ax))\n            quantile_func = np.interp(p_grid, unique_cdf, unique_t)\n            return quantile_func, p_grid\n\n        # Get quantile functions for both predicted and observed data\n        q_pred, p_grid = get_quantile_function(d_pred, time_axis, delta_t, eps)\n        q_obs, _ = get_quantile_function(d_obs, time_axis, delta_t, eps)\n\n        # Calculate the W2 metric by integrating the squared difference\n        # of the quantile functions\n        integrand = (q_pred - q_obs)**2\n        integral_val = np.trapz(integrand, p_grid)\n        \n        return np.sqrt(integral_val)\n\n    #\n    # 4. GENERATE OBSERVED AND BASELINE DATA TRACES\n    #\n    d_obs = A_true * ricker_wavelet(t - T_true, f0)\n    d0 = A0 * ricker_wavelet(t - T0, f0)\n\n    #\n    # 5. CALCULATE BASELINE MISFITS\n    #\n    phi_l2_base = l2_misfit(d0, d_obs, dt)\n    phi_w2_base = w2_misfit(d0, d_obs, t, dt, epsilon)\n    \n    results = []\n    \n    #\n    # 6. ANALYZE THE THREE ADVERSARIAL PERTURBATION CASES\n    #\n    \n    # Define test cases as a list of tuples (name, trace_generator_lambda)\n    perturbation_cases = [\n        # Case 1: Polarity reversal\n        lambda: -1.0 * ricker_wavelet(t - T_true, f0),\n\n        # Case 2: Amplitude overshoot\n        lambda: 2.0 * ricker_wavelet(t - (T_true + 0.005), f0),\n        \n        # Case 3: Secondary arrival\n        lambda: (1.0 * ricker_wavelet(t - (T_true + 0.005), f0) +\n                 0.5 * ricker_wavelet(t - (T_true + 0.005 + 0.03), f0))\n    ]\n\n    for gen_trace in perturbation_cases:\n        # Generate the perturbed trace\n        d_pert = gen_trace()\n\n        # Calculate perturbed misfits\n        phi_l2_pert = l2_misfit(d_pert, d_obs, dt)\n        phi_w2_pert = w2_misfit(d_pert, d_obs, t, dt, epsilon)\n        \n        # Determine if L2 misfit increased AND W2 misfit decreased\n        is_adversarial_success = (phi_l2_pert > phi_l2_base) and \\\n                                  (phi_w2_pert  phi_w2_base)\n        results.append(is_adversarial_success)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}