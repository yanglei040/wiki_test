{
    "hands_on_practices": [
        {
            "introduction": "走时层析成像的第一步是将研究区域划分为像素网格，并将走时观测数据与每个像素的慢度（速度的倒数）联系起来。这个过程将一个复杂的物理问题转化为一个线性代数方程组 $\\mathbf{d} = \\mathbf{G}\\mathbf{m}$。本练习将引导您在一个简化的二维模型中，通过计算射线在每个单元格中的路径长度，亲手构建这个关键的灵敏度矩阵 $\\mathbf{G}$。通过这个实践，您将理解层析成像正演问题的基本构建方式，并能分析该矩阵系统的内在属性，这对于后续的反演至关重要。",
            "id": "3617796",
            "problem": "考虑一个二维（2D）方形区域，记为 $D = [0,2] \\times [0,2]$，单位为 $\\mathrm{km}$，该区域被划分为四个边长为 $1\\,\\mathrm{km}$ 的相等方形单元。用索引 $j \\in \\{1,2,3,4\\}$ 标记这些单元如下：$C_{1} = [0,1] \\times [0,1]$（左下）、$C_{2} = [1,2] \\times [0,1]$（右下）、$C_{3} = [0,1] \\times [1,2]$（左上）和 $C_{4} = [1,2] \\times [1,2]$（右上）。在走时层析成像的直射线、高频近似中，射线 $i$ 的走时 $t_{i}$ 由线积分 $t_{i} = \\int_{\\gamma_{i}} s(\\mathbf{x}) \\,\\mathrm{d}s$ 建模，其中 $s(\\mathbf{x})$ 是慢度，$\\gamma_{i}$ 是射线路径。当假定 $s(\\mathbf{x})$ 在各单元上是分段常数时，对于单元 $j$ 的未知慢度参数为 $m_{j}$，离散正演模型为 $t_{i} = \\sum_{j=1}^{4} G_{ij} m_{j}$，其中 $G_{ij}$ 等于射线 $i$ 在单元 $j$ 内的路径长度。\n\n观测到三条直射线，每条都由一个源点和一个接收点位置（单位均为 $\\mathrm{km}$）定义，并假定它们以直线段的形式穿过 $D$：\n\n- 射线1：源点位于 $(-0.2,\\,0.5)$，接收点位于 $(2.2,\\,0.5)$。\n- 射线2：源点位于 $(0.5,\\,-0.2)$，接收点位于 $(0.5,\\,2.2)$。\n- 射线3：源点位于 $(-0.2,\\,1.5)$，接收点位于 $(2.2,\\,1.5)$。\n\n假设射线不弯曲，并且只有它们在 $D$ 内部的线段对 $G$ 有贡献。利用每条射线与单元边界的几何相交，计算 $i \\in \\{1,2,3\\}$ 和 $j \\in \\{1,2,3,4\\}$ 时每个单元的路径长度，即矩阵元素 $G_{ij}$（单位 $\\mathrm{km}$）。然后显式地构建正规矩阵 $G^{T} G$（单位 $\\mathrm{km}^{2}$）。最后，计算 $G^{T} G$ 的行列式，并以 $\\mathrm{km}^{8}$ 为单位表示你的最终答案。提供精确值，无需四舍五入。",
            "solution": "该问题定义明确，具有科学依据，并包含所有必要信息以进行求解。任务是基于所提供的二维层析成像设置，计算几何矩阵 $G$、正规矩阵 $G^T G$ 及其行列式。\n\n区域是一个边长为 $D = [0,2] \\times [0,2]$ 的正方形，单位为 $\\mathrm{km}$。它被划分为四个边长为 $1\\,\\mathrm{km}$ 的相等方形单元：\n-   $C_{1} = [0,1] \\times [0,1]$ (左下)\n-   $C_{2} = [1,2] \\times [0,1]$ (右下)\n-   $C_{3} = [0,1] \\times [1,2]$ (左上)\n-   $C_{4} = [1,2] \\times [1,2]$ (右上)\n\n矩阵元素 $G_{ij}$ 表示射线 $i$ 在单元 $j$ 内的路径长度。我们为给定的三条射线计算这些长度。$G_{ij}$ 的单位将是 $\\mathrm{km}$。\n\n射线1：源点位于 $(-0.2, 0.5)$，接收点位于 $(2.2, 0.5)$。\n这条射线是一条由方程 $y=0.5$ 描述的水平直线段。我们考虑它与区域 $D$ 的交集，即 $x \\in [0,2]$ 的线段。\n-   与 $C_{1}$ 的交集：$y=0.5$ 的射线在 $C_{1}$ 的 $y$ 坐标范围 $[0,1]$ 内。它从 $x=0$ 到 $x=1$ 穿过该单元。路径长度为 $G_{11} = 1-0 = 1$。\n-   与 $C_{2}$ 的交集：$y=0.5$ 的射线在 $C_{2}$ 的 $y$ 坐标范围 $[0,1]$ 内。它从 $x=1$ 到 $x=2$ 穿过该单元。路径长度为 $G_{12} = 2-1 = 1$。\n-   与 $C_{3}$ 和 $C_{4}$ 的交集：$y=0.5$ 的射线在这些单元的 $y$ 坐标范围 $[1,2]$ 之外。因此，路径长度为 $G_{13} = 0$ 和 $G_{14} = 0$。\n矩阵 $G$ 的第一行是 $[1, 1, 0, 0]$。\n\n射线2：源点位于 $(0.5, -0.2)$，接收点位于 $(0.5, 2.2)$。\n这条射线是一条由方程 $x=0.5$ 描述的垂直直线段。我们考虑它与区域 $D$ 的交集，即 $y \\in [0,2]$ 的线段。\n-   与 $C_{1}$ 的交集：$x=0.5$ 的射线在 $C_{1}$ 的 $x$ 坐标范围 $[0,1]$ 内。它从 $y=0$ 到 $y=1$ 穿过该单元。路径长度为 $G_{21} = 1-0 = 1$。\n-   与 $C_{3}$ 的交集：$x=0.5$ 的射线在 $C_{3}$ 的 $x$ 坐标范围 $[0,1]$ 内。它从 $y=1$ 到 $y=2$ 穿过该单元。路径长度为 $G_{23} = 2-1 = 1$。\n-   与 $C_{2}$ 和 $C_{4}$ 的交集：$x=0.5$ 的射线在这些单元的 $x$ 坐标范围 $[1,2]$ 之外。因此，路径长度为 $G_{22} = 0$ 和 $G_{24} = 0$。\n矩阵 $G$ 的第二行是 $[1, 0, 1, 0]$。\n\n射线3：源点位于 $(-0.2, 1.5)$，接收点位于 $(2.2, 1.5)$。\n这条射线是一条由方程 $y=1.5$ 描述的水平直线段。我们考虑它与区域 $D$ 的交集，即 $x \\in [0,2]$ 的线段。\n-   与 $C_{3}$ 的交集：$y=1.5$ 的射线在 $C_{3}$ 的 $y$ 坐标范围 $[1,2]$ 内。它从 $x=0$ 到 $x=1$ 穿过该单元。路径长度为 $G_{33} = 1-0 = 1$。\n-   与 $C_{4}$ 的交集：$y=1.5$ 的射线在 $C_{4}$ 的 $y$ 坐标范围 $[1,2]$ 内。它从 $x=1$ 到 $x=2$ 穿过该单元。路径长度为 $G_{34} = 2-1 = 1$。\n-   与 $C_{1}$ 和 $C_{2}$ 的交集：$y=1.5$ 的射线在这些单元的 $y$ 坐标范围 $[0,1]$ 之外。因此，路径长度为 $G_{31} = 0$ 和 $G_{32} = 0$。\n矩阵 $G$ 的第三行是 $[0, 0, 1, 1]$。\n\n综合这些结果，几何矩阵 $G$ 是一个 $3 \\times 4$ 的矩阵，其元素的单位是 $\\mathrm{km}$：\n$$\nG = \\begin{pmatrix}\n1  & 1  & 0  & 0 \\\\\n1  & 0  & 1  & 0 \\\\\n0  & 0  & 1  & 1\n\\end{pmatrix}\n$$\n接下来，我们计算正规矩阵 $N = G^{T} G$。首先，$G$ 的转置矩阵是：\n$$\nG^{T} = \\begin{pmatrix}\n1  & 1  & 0 \\\\\n1  & 0  & 0 \\\\\n0  & 1  & 1 \\\\\n0  & 0  & 1\n\\end{pmatrix}\n$$\n现在，我们进行矩阵乘法 $N = G^{T} G$：\n$$\nN = \\begin{pmatrix}\n1  & 1  & 0 \\\\\n1  & 0  & 0 \\\\\n0  & 1  & 1 \\\\\n0  & 0  & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n1  & 1  & 0  & 0 \\\\\n1  & 0  & 1  & 0 \\\\\n0  & 0  & 1  & 1\n\\end{pmatrix}\n= \\begin{pmatrix}\n(1)(1)+(1)(1)+(0)(0)  & (1)(1)+(1)(0)+(0)(0)  & (1)(0)+(1)(1)+(0)(1)  & (1)(0)+(1)(0)+(0)(1) \\\\\n(1)(1)+(0)(1)+(0)(0)  & (1)(1)+(0)(0)+(0)(0)  & (1)(0)+(0)(1)+(0)(1)  & (1)(0)+(0)(0)+(0)(1) \\\\\n(0)(1)+(1)(1)+(1)(0)  & (0)(1)+(1)(0)+(1)(0)  & (0)(0)+(1)(1)+(1)(1)  & (0)(0)+(1)(0)+(1)(1) \\\\\n(0)(1)+(0)(1)+(1)(0)  & (0)(1)+(0)(0)+(1)(0)  & (0)(0)+(0)(1)+(1)(1)  & (0)(0)+(0)(0)+(1)(1)\n\\end{pmatrix}\n$$\n$$\nN = G^{T} G = \\begin{pmatrix}\n2  & 1  & 1  & 0 \\\\\n1  & 1  & 0  & 0 \\\\\n1  & 0  & 2  & 1 \\\\\n0  & 0  & 1  & 1\n\\end{pmatrix}\n$$\n该矩阵元素的单位是 $\\mathrm{km}^{2}$。\n\n最后，我们计算 $4 \\times 4$ 矩阵 $N = G^{T} G$ 的行列式。我们可以沿第四行使用代数余子式展开，因为它包含两个零元素。行列式由 $\\det(N) = \\sum_{j=1}^{4} (-1)^{4+j} N_{4j} M_{4j}$ 给出，其中 $M_{4j}$ 是对应于元素 $N_{4j}$ 的余子式。\n$$\n\\det(N) = 0 \\cdot C_{41} + 0 \\cdot C_{42} + N_{43} C_{43} + N_{44} C_{44}\n$$\n其中 $C_{ij}$ 是代数余子式。\n相关的代数余子式是 $C_{43}$ 和 $C_{44}$：\n$$\nC_{43} = (-1)^{4+3} \\det \\begin{pmatrix}\n2  & 1  & 0 \\\\\n1  & 1  & 0 \\\\\n1  & 0  & 1\n\\end{pmatrix} = (-1) \\left[ 0 - 0 + 1 \\cdot \\det \\begin{pmatrix} 2  & 1 \\\\ 1  & 1 \\end{pmatrix} \\right] = (-1)[(2)(1) - (1)(1)] = -1\n$$\n$$\nC_{44} = (-1)^{4+4} \\det \\begin{pmatrix}\n2  & 1  & 1 \\\\\n1  & 1  & 0 \\\\\n1  & 0  & 2\n\\end{pmatrix} = (+1) \\left[ 1 \\cdot \\det \\begin{pmatrix} 1  & 1 \\\\ 1  & 0 \\end{pmatrix} - 0 + 2 \\cdot \\det \\begin{pmatrix} 2  & 1 \\\\ 1  & 1 \\end{pmatrix} \\right] = [(1)(0)-(1)(1)] + 2[(2)(1)-(1)(1)] = -1 + 2(1) = 1\n$$\n将这些值代回行列式表达式中：\n$$\n\\det(N) = (1)(C_{43}) + (1)(C_{44}) = (1)(-1) + (1)(1) = -1 + 1 = 0\n$$\n另一种方法是使用行化简。\n$$\n\\det \\begin{pmatrix}\n2  & 1  & 1  & 0 \\\\\n1  & 1  & 0  & 0 \\\\\n1  & 0  & 2  & 1 \\\\\n0  & 0  & 1  & 1\n\\end{pmatrix}\n\\xrightarrow{R_1 \\leftrightarrow R_2}\n-\\det \\begin{pmatrix}\n1  & 1  & 0  & 0 \\\\\n2  & 1  & 1  & 0 \\\\\n1  & 0  & 2  & 1 \\\\\n0  & 0  & 1  & 1\n\\end{pmatrix}\n\\xrightarrow[R_3 \\to R_3-R_1]{R_2 \\to R_2-2R_1}\n-\\det \\begin{pmatrix}\n1  & 1  & 0  & 0 \\\\\n0  & -1  & 1  & 0 \\\\\n0  & -1  & 2  & 1 \\\\\n0  & 0  & 1  & 1\n\\end{pmatrix}\n\\xrightarrow{R_3 \\to R_3-R_2}\n-\\det \\begin{pmatrix}\n1  & 1  & 0  & 0 \\\\\n0  & -1  & 1  & 0 \\\\\n0  & 0  & 1  & 1 \\\\\n0  & 0  & 1  & 1\n\\end{pmatrix}\n$$\n由于有两行相同（第3行和第4行），行列式为 $0$。\n$G^{T} G$ 的行列式为 $0$。行列式的单位是 $(\\mathrm{km}^{2})^{4} = \\mathrm{km}^{8}$。\n其值为 $0 \\, \\mathrm{km}^{8}$。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "在实践中，我们构建的层析成像方程组 $\\mathbf{G}\\mathbf{m} = \\mathbf{d}$ 常常是病态或欠定的，这意味着微小的数据噪声可能导致模型解的巨大偏差，甚至无法求得唯一解。为了获得稳定且有物理意义的解，正则化方法是必不可少的。本练习将聚焦于应用最广泛的吉洪诺夫（Tikhonov）正则化技术，在一个小尺度问题中推导并计算正则化解。通过这个过程，您将深刻理解正则化参数 $\\lambda$ 如何调控模型分辨率（我们能看清多精细的结构）与解的方差（解对噪声的敏感度）之间的经典权衡关系。",
            "id": "3617733",
            "problem": "在走时层析成像中，沿射线的走时一阶扰动由慢度扰动的线积分给出，在网格单元上离散化后，这成为一个线性关系 $\\mathbf{d} \\approx \\mathbf{G}\\,\\mathbf{m}$，其中 $\\mathbf{d}$ 是无量纲的走时残差，$\\mathbf{m}$ 是无量纲的慢度扰动，$\\mathbf{G}$ 是无量纲的路径长度雅可比矩阵。考虑一个具有两条直射线的双单元模型，使得\n$$\n\\mathbf{G} = \\begin{pmatrix} 3  & 2 \\\\ 1  & 4 \\end{pmatrix}, \\quad \\mathbf{d} = \\begin{pmatrix} 5 \\\\ 9 \\end{pmatrix}.\n$$\n假设数据已被白化，因此数据噪声协方差是单位矩阵，并对模型范数应用吉洪诺夫阻尼。从基本原理推导作为目标函数 $J(\\mathbf{m}) = \\|\\mathbf{G}\\mathbf{m} - \\mathbf{d}\\|_{2}^{2} + \\lambda^{2} \\|\\mathbf{m}\\|_{2}^{2}$ 的最小化子的吉洪诺夫正则化最小二乘估计量 $\\widehat{\\mathbf{m}}(\\lambda)$，其中 $\\lambda$ 是一个无量纲的阻尼参数。计算当 $\\lambda = 0$、$\\lambda = 1$ 和 $\\lambda = 3$ 这些特定值时 $\\widehat{\\mathbf{m}}(\\lambda)$ 的值。\n\n定义并推导在单位数据协方差假设下的模型分辨率矩阵 $\\mathbf{R}(\\lambda)$ 和后验模型协方差 $\\mathbf{C}_{m}(\\lambda)$，并用 $\\lambda$ 解析地表示它们。使用这些表达式，对作为 $\\lambda$ 函数的分辨率和方差进行解析比较。\n\n最后，确定阻尼参数 $\\lambda$ 的值，使得分辨率矩阵的迹满足 $\\mathrm{tr}(\\mathbf{R}(\\lambda)) = 1.5$。将你的答案四舍五入到四位有效数字。以无量纲单位表示 $\\lambda$ 的最终值。",
            "solution": "该问题是有效的，因为它在科学上基于地球物理反演理论的原理，特别是吉洪诺夫正则化。问题是适定的，提供了所有必要的数据，并且没有矛盾或模糊之处。\n\n首先，我们通过最小化目标函数 $J(\\mathbf{m})$ 来推导吉洪诺夫正则化最小二乘估计量 $\\widehat{\\mathbf{m}}(\\lambda)$。目标函数为：\n$$J(\\mathbf{m}) = \\|\\mathbf{G}\\mathbf{m} - \\mathbf{d}\\|_{2}^{2} + \\lambda^{2} \\|\\mathbf{m}\\|_{2}^{2}$$\n用矩阵表示法，这可以写成：\n$$J(\\mathbf{m}) = (\\mathbf{G}\\mathbf{m} - \\mathbf{d})^T (\\mathbf{G}\\mathbf{m} - \\mathbf{d}) + \\lambda^{2} \\mathbf{m}^T \\mathbf{m}$$\n展开表达式：\n$$J(\\mathbf{m}) = \\mathbf{m}^T \\mathbf{G}^T \\mathbf{G}\\mathbf{m} - \\mathbf{m}^T \\mathbf{G}^T \\mathbf{d} - \\mathbf{d}^T \\mathbf{G}\\mathbf{m} + \\mathbf{d}^T \\mathbf{d} + \\lambda^{2} \\mathbf{m}^T \\mathbf{m}$$\n由于标量项 $\\mathbf{d}^T \\mathbf{G}\\mathbf{m}$ 等于其转置 $\\mathbf{m}^T \\mathbf{G}^T \\mathbf{d}$，我们可以合并各项：\n$$J(\\mathbf{m}) = \\mathbf{m}^T (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I}) \\mathbf{m} - 2 \\mathbf{m}^T \\mathbf{G}^T \\mathbf{d} + \\mathbf{d}^T \\mathbf{d}$$\n为了找到最小化 $J(\\mathbf{m})$ 的模型向量 $\\mathbf{m}$，我们计算 $J$ 关于 $\\mathbf{m}$ 的梯度，并将其设为零向量。\n$$\\nabla_{\\mathbf{m}} J(\\mathbf{m}) = 2(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})\\mathbf{m} - 2\\mathbf{G}^T \\mathbf{d}$$\n将梯度设为零，得到估计量 $\\widehat{\\mathbf{m}}$ 的正规方程：\n$$2(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})\\widehat{\\mathbf{m}} - 2\\mathbf{G}^T \\mathbf{d} = 0$$\n$$(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})\\widehat{\\mathbf{m}} = \\mathbf{G}^T \\mathbf{d}$$\n解出 $\\widehat{\\mathbf{m}}$ 即可得到吉洪诺夫正则化估计量：\n$$\\widehat{\\mathbf{m}}(\\lambda) = (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T \\mathbf{d}$$\n接下来，我们针对给定的矩阵和 $\\lambda$ 的特定值来计算该估计量。给定的矩阵是：\n$$\\mathbf{G} = \\begin{pmatrix} 3  & 2 \\\\ 1  & 4 \\end{pmatrix}, \\quad \\mathbf{d} = \\begin{pmatrix} 5 \\\\ 9 \\end{pmatrix}$$\n我们计算所需的矩阵乘积：\n$$\\mathbf{G}^T = \\begin{pmatrix} 3  & 1 \\\\ 2  & 4 \\end{pmatrix}$$\n$$\\mathbf{G}^T \\mathbf{G} = \\begin{pmatrix} 3  & 1 \\\\ 2  & 4 \\end{pmatrix} \\begin{pmatrix} 3  & 2 \\\\ 1  & 4 \\end{pmatrix} = \\begin{pmatrix} 10  & 10 \\\\ 10  & 20 \\end{pmatrix}$$\n$$\\mathbf{G}^T \\mathbf{d} = \\begin{pmatrix} 3  & 1 \\\\ 2  & 4 \\end{pmatrix} \\begin{pmatrix} 5 \\\\ 9 \\end{pmatrix} = \\begin{pmatrix} 24 \\\\ 46 \\end{pmatrix}$$\n$(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})$ 项为：\n$$\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I} = \\begin{pmatrix} 10+\\lambda^2  & 10 \\\\ 10  & 20+\\lambda^2 \\end{pmatrix}$$\n该矩阵的行列式为 $\\det(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I}) = (10+\\lambda^2)(20+\\lambda^2) - 100 = \\lambda^4 + 30\\lambda^2 + 100$。\n其逆矩阵是：\n$$(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} = \\frac{1}{\\lambda^4 + 30\\lambda^2 + 100} \\begin{pmatrix} 20+\\lambda^2  & -10 \\\\ -10  & 10+\\lambda^2 \\end{pmatrix}$$\n因此，估计量为：\n$$\\widehat{\\mathbf{m}}(\\lambda) = \\frac{1}{\\lambda^4 + 30\\lambda^2 + 100} \\begin{pmatrix} 20+\\lambda^2  & -10 \\\\ -10  & 10+\\lambda^2 \\end{pmatrix} \\begin{pmatrix} 24 \\\\ 46 \\end{pmatrix} = \\frac{1}{\\lambda^4 + 30\\lambda^2 + 100} \\begin{pmatrix} 20 + 24\\lambda^2 \\\\ 220 + 46\\lambda^2 \\end{pmatrix}$$\n当 $\\lambda=0$ 时：\n$\\widehat{\\mathbf{m}}(0) = \\frac{1}{100} \\begin{pmatrix} 20 \\\\ 220 \\end{pmatrix} = \\begin{pmatrix} 0.2 \\\\ 2.2 \\end{pmatrix}$。\n当 $\\lambda=1$ 时：\n$\\widehat{\\mathbf{m}}(1) = \\frac{1}{1^4 + 30(1)^2 + 100} \\begin{pmatrix} 20 + 24(1)^2 \\\\ 220 + 46(1)^2 \\end{pmatrix} = \\frac{1}{131} \\begin{pmatrix} 44 \\\\ 266 \\end{pmatrix}$。\n当 $\\lambda=3$ 时：\n$\\widehat{\\mathbf{m}}(3) = \\frac{1}{3^4 + 30(3)^2 + 100} \\begin{pmatrix} 20 + 24(3)^2 \\\\ 220 + 46(3)^2 \\end{pmatrix} = \\frac{1}{81 + 270 + 100} \\begin{pmatrix} 20 + 216 \\\\ 220 + 414 \\end{pmatrix} = \\frac{1}{451} \\begin{pmatrix} 236 \\\\ 634 \\end{pmatrix}$。\n\n模型分辨率矩阵 $\\mathbf{R}(\\lambda)$ 将估计模型与真实模型 $\\mathbf{m}_{\\text{true}}$ 联系起来。数据为 $\\mathbf{d} = \\mathbf{G}\\mathbf{m}_{\\text{true}} + \\mathbf{n}$，其中 $\\mathbf{n}$ 是数据噪声。将此代入估计量方程可得：\n$$\\widehat{\\mathbf{m}} = (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T (\\mathbf{G}\\mathbf{m}_{\\text{true}} + \\mathbf{n}) = [(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T \\mathbf{G}] \\mathbf{m}_{\\text{true}} + \\dots$$\n分辨率矩阵是左乘 $\\mathbf{m}_{\\text{true}}$ 的项：\n$$\\mathbf{R}(\\lambda) = (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T \\mathbf{G}$$\n后验模型协方差 $\\mathbf{C}_{m}(\\lambda)$ 描述了数据噪声如何传播到模型估计中。假设数据协方差 $\\mathbf{C}_d = \\mathbf{I}$，则估计量的协方差为：\n$$\\mathbf{C}_{m}(\\lambda) = \\mathbb{E}[(\\widehat{\\mathbf{m}} - \\mathbb{E}[\\widehat{\\mathbf{m}}])(\\widehat{\\mathbf{m}} - \\mathbb{E}[\\widehat{\\mathbf{m}}])^T] = [(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T] \\mathbf{C}_d [(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T]^T$$\n$$\\mathbf{C}_{m}(\\lambda) = (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T \\mathbf{G} (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1}$$\n当 $\\lambda \\to 0$ 时，$\\mathbf{R}(\\lambda) \\to \\mathbf{I}$（完美分辨率），且 $\\mathbf{C}_m(\\lambda) \\to (\\mathbf{G}^T\\mathbf{G})^{-1}$（最大方差）。当 $\\lambda \\to \\infty$ 时，$\\mathbf{R}(\\lambda) \\to \\mathbf{0}$（无分辨率），且 $\\mathbf{C}_m(\\lambda) \\to \\mathbf{0}$（零方差）。这展示了经典的权衡关系：增加 $\\lambda$ 会以牺牲分辨率为代价来降低模型方差。\n\n最后，我们确定使 $\\mathrm{tr}(\\mathbf{R}(\\lambda)) = 1.5$ 的 $\\lambda$ 值。首先，我们计算 $\\mathbf{R}(\\lambda)$ 的解析表达式：\n$$\\mathbf{R}(\\lambda) = \\frac{1}{\\lambda^4 + 30\\lambda^2 + 100} \\begin{pmatrix} 20+\\lambda^2  & -10 \\\\ -10  & 10+\\lambda^2 \\end{pmatrix} \\begin{pmatrix} 10  & 10 \\\\ 10  & 20 \\end{pmatrix}$$\n$$\\mathbf{R}(\\lambda) = \\frac{1}{\\lambda^4 + 30\\lambda^2 + 100} \\begin{pmatrix} 100 + 10\\lambda^2  & 10\\lambda^2 \\\\ 10\\lambda^2  & 100 + 20\\lambda^2 \\end{pmatrix}$$\n迹是主对角线元素的和：\n$$\\mathrm{tr}(\\mathbf{R}(\\lambda)) = \\frac{(100 + 10\\lambda^2) + (100 + 20\\lambda^2)}{\\lambda^4 + 30\\lambda^2 + 100} = \\frac{200 + 30\\lambda^2}{\\lambda^4 + 30\\lambda^2 + 100}$$\n我们令其等于 1.5（即 3/2）：\n$$\\frac{200 + 30\\lambda^2}{\\lambda^4 + 30\\lambda^2 + 100} = \\frac{3}{2}$$\n$$2(200 + 30\\lambda^2) = 3(\\lambda^4 + 30\\lambda^2 + 100)$$\n$$400 + 60\\lambda^2 = 3\\lambda^4 + 90\\lambda^2 + 300$$\n$$3\\lambda^4 + 30\\lambda^2 - 100 = 0$$\n令 $x = \\lambda^2$。该方程是关于 $x$ 的二次方程：$3x^2 + 30x - 100 = 0$。使用求根公式：\n$$x = \\frac{-30 \\pm \\sqrt{30^2 - 4(3)(-100)}}{2(3)} = \\frac{-30 \\pm \\sqrt{900 + 1200}}{6} = \\frac{-30 \\pm \\sqrt{2100}}{6}$$\n因为 $\\lambda$ 是一个实参数，所以 $\\lambda^2 = x$ 必须是非负的。我们取正根：\n$$\\lambda^2 = \\frac{-30 + \\sqrt{2100}}{6} = \\frac{-30 + 10\\sqrt{21}}{6} = \\frac{-15 + 5\\sqrt{21}}{3}$$\n$\\lambda$ 的值是该量的平方根。\n$$\\lambda = \\sqrt{\\frac{-15 + 5\\sqrt{21}}{3}}$$\n数值计算上，$\\sqrt{21} \\approx 4.582576$。\n$$\\lambda^2 \\approx \\frac{-15 + 5(4.582576)}{3} \\approx \\frac{7.91288}{3} \\approx 2.637626$$\n$$\\lambda \\approx \\sqrt{2.637626} \\approx 1.624077$$\n四舍五入到四位有效数字，我们得到 $\\lambda \\approx 1.624$。根据题目要求，该值是无量纲的。",
            "answer": "$$\\boxed{1.624}$$"
        },
        {
            "introduction": "线性的走时层析模型假设射线路径是固定的直线，但这在真实地球中并非如此——射线的弯曲路径本身就依赖于它所穿过的速度结构。这种依赖性使得问题变为非线性，需要更高级的迭代方法来求解。本练习将带领您进入非线性层析成像的世界，通过实现高斯-牛顿（Gauss-Newton）迭代算法来反演一个双层介质模型。您将模拟一个包含射线追踪和模型更新的完整反演流程，这极大地拉近了理论学习与实际地球物理应用之间的距离。",
            "id": "3617783",
            "problem": "您的任务是实现两次高斯-牛顿迭代，以估算在走时层析成像应用中使用的双层折射环境下的慢度对比。物理设置为水平分层介质，在深度 $h$ 处有一个单一的平面界面，顶层的慢度为 $s_1$，底层的慢度为 $s_2$。慢度是速度的倒数，单位是秒/米 (s/m)。射线在每个均匀层中分段线性传播，并在界面处根据斯涅尔定律 (Snell's law) 发生折射。所有震源都位于上层 ($z_s  h$)，所有接收器都位于下层 ($z_r  h$)，这确保了在界面处只有一次折射。程序将从一个均匀的初始模型 $s_2^{(0)} = s_1$ 开始，通过执行两次高斯-牛顿迭代来估算慢度对比 $\\delta s = s_2 - s_1$。推导中出现的角度应以弧度为单位。\n\n基本原理：\n- 费马原理 (Fermat’s principle)：走时遵循使走时保持平稳的路径。\n- 平面界面上的斯涅尔定律：水平慢度守恒，表示为 $s_1 \\sin \\theta_1 = s_2 \\sin \\theta_2$，其中 $\\theta_i$ 是第 $i$ 层中射线与界面法线的夹角。\n- 对于均匀层中的固定射线路径，走时是慢度乘以路径段长度的总和，$T = s_1 L_1 + s_2 L_2$，其中 $L_1$ 和 $L_2$ 分别是顶层和底层的路径长度。\n\n问题构建：\n1. 几何与路径参数化：\n   - 设界面为水平线 $z = h$。\n   - 对于位于 $(x_s, z_s)$ (其中 $z_s  h$) 的震源和位于 $(x_r, z_r)$ (其中 $z_r > h$) 的接收器，物理上可行的弯曲射线由两条直线段组成：从震源到顶层中的界面交点 $(x^\\star, h)$，以及从 $(x^\\star, h)$ 到下层中的接收器。\n   - 界面交点 $x^\\star$ 满足以几何形式表示的斯涅尔条件：\n     $$ s_1 \\frac{x^\\star - x_s}{\\sqrt{(x^\\star - x_s)^2 + (h - z_s)^2}} = s_2 \\frac{x_r - x^\\star}{\\sqrt{(x_r - x^\\star)^2 + (z_r - h)^2}}. $$\n   - 对于给定的 $s_1$ 和 $s_2$，射线段长度为\n     $$ L_1 = \\sqrt{(x^\\star - x_s)^2 + (h - z_s)^2}, \\quad L_2 = \\sqrt{(x_r - x^\\star)^2 + (z_r - h)^2}. $$\n   - 走时为 $T(s_2) = s_1 L_1(s_2) + s_2 L_2(s_2)$，其中 $L_1$ 和 $L_2$ 通过 $x^\\star$ 依赖于 $s_2$。\n\n2. 高斯-牛顿更新：\n   - 假设顶层慢度 $s_1$ 已知且固定（等于均匀初始慢度）。\n   - 设 $T_i^{\\text{obs}}$ 表示射线 $i$ 的观测走时，该走时由真实慢度 $s_2^{\\text{true}}$ 使用物理上正确的弯曲射线生成。设 $T_i^{(k)}$ 表示第 $k$ 次迭代时的预测走时，该走时使用与当前估计值 $s_2^{(k)}$ 对应的弯曲射线几何计算得出。\n   - 通过在每次迭代中将路径段长度视为相对于 $s_2$ 固定，围绕当前射线路径对走时进行线性化（路径重新计算在迭代之间执行）。射线 $i$ 的雅可比项为 $J_i^{(k)} = \\partial T_i / \\partial s_2 \\approx L_{2,i}^{(k)}$，其中 $L_{2,i}^{(k)}$ 是在 $s_2^{(k)}$ 处计算的底层路径长度。\n   - 设残差为 $r_i^{(k)} = T_i^{(k)} - T_i^{\\text{obs}}$。对于单一未知数 $s_2$ 的高斯-牛顿更新为\n     $$ \\Delta s_2^{(k)} = -\\frac{\\sum_i J_i^{(k)} r_i^{(k)}}{\\sum_i \\left(J_i^{(k)}\\right)^2}, \\quad s_2^{(k+1)} = s_2^{(k)} + \\Delta s_2^{(k)}. $$\n   - 从 $s_2^{(0)} = s_1$ 开始执行两次迭代，并报告慢度对比的最终估计值 $\\delta s^{(2)} = s_2^{(2)} - s_1$。\n\n单位：\n- 距离单位：米 (m)。\n- 慢度单位：秒/米 (s/m)。\n- 走时单位：秒 (s)。\n- 角度单位：弧度。\n\n输入数据（嵌入程序中）和测试套件：\n每个测试用例定义了几何结构和真实的底层慢度。对于每个测试用例，使用提供的震源-接收器对集合，以真实慢度 $s_2^{\\text{true}}$ 生成观测走时。然后如上所述应用两次高斯-牛顿迭代来估算 $\\delta s$。\n\n测试用例 1（通用“理想路径”）：\n- 初始均匀速度 $v_0 = 2000$ 米/秒。\n- 顶层慢度 $s_1 = 1 / v_0$。\n- 界面深度 $h = 500$ 米。\n- 水平间距 $x_r - x_s = 1000$ 米，其中 $x_s = 0$，$x_r = 1000$。\n- 真实底层速度 $v_2^{\\text{true}} = 3000$ 米/秒，因此 $s_2^{\\text{true}} = 1 / v_2^{\\text{true}}$。\n- 震源-接收器对：\n  - $(x_s, z_s) = (0, 100)$, $(x_r, z_r) = (1000, 600)$\n  - $(x_s, z_s) = (0, 300)$, $(x_r, z_r) = (1000, 800)$\n  - $(x_s, z_s) = (0, 450)$, $(x_r, z_r) = (1000, 1000)$\n  - $(x_s, z_s) = (0, 100)$, $(x_r, z_r) = (1000, 1000)$\n\n测试用例 2（速度近似相等的边界条件）：\n- 初始均匀速度 $v_0 = 2500$ 米/秒。\n- 顶层慢度 $s_1 = 1 / v_0$。\n- 界面深度 $h = 300$ 米。\n- 水平间距 $x_r - x_s = 500$ 米，其中 $x_s = 0$，$x_r = 500$。\n- 真实底层速度 $v_2^{\\text{true}} = 2600$ 米/秒，因此 $s_2^{\\text{true}} = 1 / v_2^{\\text{true}}$。\n- 震源-接收器对：\n  - $(x_s, z_s) = (0, 50)$, $(x_r, z_r) = (500, 400)$\n  - $(x_s, z_s) = (0, 100)$, $(x_r, z_r) = (500, 550)$\n  - $(x_s, z_s) = (0, 200)$, $(x_r, z_r) = (500, 600)$\n\n测试用例 3（高对比度边缘情况）：\n- 初始均匀速度 $v_0 = 1800$ 米/秒。\n- 顶层慢度 $s_1 = 1 / v_0$。\n- 界面深度 $h = 400$ 米。\n- 水平间距 $x_r - x_s = 800$ 米，其中 $x_s = 0$，$x_r = 800$。\n- 真实底层速度 $v_2^{\\text{true}} = 6000$ 米/秒，因此 $s_2^{\\text{true}} = 1 / v_2^{\\text{true}}$。\n- 震源-接收器对：\n  - $(x_s, z_s) = (0, 390)$, $(x_r, z_r) = (800, 600)$\n  - $(x_s, z_s) = (0, 100)$, $(x_r, z_r) = (800, 700)$\n  - $(x_s, z_s) = (0, 10)$, $(x_r, z_r) = (800, 900)$\n\n输出规范：\n- 您的程序应为每个测试用例计算两次高斯-牛顿迭代后的估算慢度对比 $\\delta s^{(2)} = s_2^{(2)} - s_1$，单位为秒/米 (s/m)。\n- 您的程序应生成单行输出，其中包含三个结果，以逗号分隔的列表形式并用方括号括起来，顺序为测试用例 1、测试用例 2 和测试用例 3。例如：`[result_case1,result_case2,result_case3]`。",
            "solution": "该问题要求实现一种地球物理反演算法，以估算地下层的慢度。该反演基于高斯-牛顿方法，利用穿过双层介质传播的地震射线的走时数据。该过程涉及两个主要部分：一个用于预测给定介质的走时的正演模型，以及一个用于更新介质属性以更好地匹配观测走时的反演算法。\n\n对问题陈述的验证证实了其科学上的合理性、适定性，并提供了构建唯一且可验证解所需的所有必要信息。射线传播的物理原理、斯涅尔定律以及高斯-牛顿优化的数学框架都是标准的，并且在该走时层析成像应用中得到了正确表述。\n\n**第一部分：正演问题 — 射线追踪与走时计算**\n\n正演问题包括为给定的速度（或慢度）模型计算从震源到接收器的地震射线的总走时。该模型由两个慢度分别为 $s_1$ 和 $s_2$ 的层定义，两层之间由深度 $z=h$ 处的水平界面隔开。震源位于 $(x_s, z_s)$ (其中 $z_s  h$)，接收器位于 $(x_r, z_r)$ (其中 $z_r  h$)。\n\n根据费马原理，射线遵循走时平稳的路径。对于分段均匀介质，此路径由每个层内的直线段组成，并在界面处发生折射。界面上的折射点 $(x^\\star, h)$ 由斯涅尔定律确定，该定律指出慢度矢量的水平分量在界面两侧是守恒的。从几何角度，这表示为：\n$$ s_1 \\sin\\theta_1 = s_2 \\sin\\theta_2 $$\n其中 $\\theta_1$ 和 $\\theta_2$ 分别是射线在第 1 层和第 2 层中与界面法线所成的角度。\n\n用射线路径的几何关系表示角度的正弦值，即可得到关于未知交点 $x^\\star$ 的方程：\n$$ s_1 \\frac{x^\\star - x_s}{\\sqrt{(x^\\star - x_s)^2 + (h - z_s)^2}} = s_2 \\frac{x_r - x^\\star}{\\sqrt{(x_r - x^\\star)^2 + (z_r - h)^2}} $$\n设 $L_1(x^\\star)$ 和 $L_2(x^\\star)$ 分别为顶层和底层的路径长度。该方程可以写成一个关于 $x^\\star$ 的函数，我们需要找到它的根：\n$$ f(x^\\star; s_1, s_2) = s_1 \\frac{x^\\star - x_s}{L_1(x^\\star)} - s_2 \\frac{x_r - x^\\star}{L_2(x^\\star)} = 0 $$\n这是一个关于 $x^\\star$ 的非线性方程。对于物理上真实的路径，$x^\\star$ 必须位于 $x_s$ 和 $x_r$ 之间。我们可以使用求根算法（如二分法或布伦特方法 (Brent's method)）在区间 $(x_s, x_r)$ 内数值求解 $x^\\star$。\n\n一旦为给定的慢度对 $(s_1, s_2)$ 确定了 $x^\\star$，就可以计算出路径段长度 $L_1$ 和 $L_2$，总走时 $T$ 则计算为在每个层中所花费时间的总和：\n$$ T(s_1, s_2) = s_1 L_1(x^\\star) + s_2 L_2(x^\\star) $$\n\n**第二部分：反演问题 — 高斯-牛顿反演**\n\n反演问题的目标是，在给定多个震源-接收器对（射线）$i=1, \\dots, N$ 的一组观测走时 $T_i^{\\text{obs}}$ 的情况下，求出未知的模型参数 $s_2$。顶层慢度 $s_1$ 假定为已知。这是一个非线性最小二乘问题，我们旨在最小化目标函数 $\\Phi(s_2)$：\n$$ \\Phi(s_2) = \\sum_{i=1}^{N} \\left( T_i(s_2) - T_i^{\\text{obs}} \\right)^2 $$\n高斯-牛顿法是解决此类问题的迭代过程。从一个初始猜测值 $s_2^{(0)}$ 开始，它生成一系列估计值 $s_2^{(k)}$，这些估计值逐步收敛到解。\n\n在每次迭代 $k$ 中，走时函数 $T_i(s_2)$ 在当前估计值 $s_2^{(k)}$ 周围进行线性化：\n$$ T_i(s_2) \\approx T_i(s_2^{(k)}) + J_i^{(k)} (s_2 - s_2^{(k)}) $$\n其中 $J_i^{(k)}$ 是雅可比矩阵（$T_i$ 关于 $s_2$ 的偏导数），在 $s_2^{(k)}$ 处求值。该问题基于费马原理指定了一个关键的简化，该原理指出走时相对于路径扰动是平稳的。这使我们可以通过忽略路径长度对 $s_2$ 的依赖性来近似求导：\n$$ J_i^{(k)} = \\frac{\\partial T_i}{\\partial s_2} \\bigg|_{s_2=s_2^{(k)}} = \\frac{\\partial}{\\partial s_2} (s_1 L_{1,i} + s_2 L_{2,i}) \\bigg|_{s_2=s_2^{(k)}} \\approx L_{2,i}^{(k)} $$\n这里，$L_{2,i}^{(k)}$ 是射线 $i$ 在第二层中的路径长度，使用与慢度估计值 $s_2^{(k)}$ 对应的射线路径计算得出。\n\n设模型更新量为 $\\Delta s_2^{(k)} = s_2 - s_2^{(k)}$，走时残差为 $r_i^{(k)} = T_i(s_2^{(k)}) - T_i^{\\text{obs}}$。将线性化表达式代入目标函数，我们要最小化：\n$$ \\Phi(\\Delta s_2^{(k)}) = \\sum_{i=1}^{N} \\left( J_i^{(k)} \\Delta s_2^{(k)} + r_i^{(k)} \\right)^2 $$\n为了找到最小值，我们对 $\\Delta s_2^{(k)}$求导并将结果设为零：\n$$ \\frac{d\\Phi}{d(\\Delta s_2^{(k)})} = 2 \\sum_{i=1}^{N} J_i^{(k)} \\left( J_i^{(k)} \\Delta s_2^{(k)} + r_i^{(k)} \\right) = 0 $$\n求解更新量 $\\Delta s_2^{(k)}$ 得到单个参数的标准高斯-牛顿更新公式：\n$$ \\Delta s_2^{(k)} = - \\frac{\\sum_{i=1}^{N} J_i^{(k)} r_i^{(k)}}{\\sum_{i=1}^{N} \\left(J_i^{(k)}\\right)^2} $$\n然后通过以下方式获得下一个慢度估计值：\n$$ s_2^{(k+1)} = s_2^{(k)} + \\Delta s_2^{(k)} $$\n\n**第三部分：算法实现**\n\n对于每个测试用例，总体算法流程如下：\n1. **初始化**：定义固定参数：$s_1$、$h$以及震源-接收器对集合。同时定义真实慢度 $s_2^{\\text{true}}$。\n2. **数据生成**：对于每个震源-接收器对 $i$，通过求解慢度为 $(s_1, s_2^{\\text{true}})$ 的正演问题来计算“观测”走时 $T_i^{\\text{obs}}$。这包括通过求解 $x_i^\\star$ 找到正确的射线路径，然后计算 $T_i$。\n3. **迭代反演**：\n    a. 从初始模型 $s_2^{(0)} = s_1$ 开始。\n    b. 执行两次迭代（$k=0$ 和 $k=1$）。在每次迭代中：\n        i. 初始化更新公式中分子和分母的求和：$\\sum J r = 0$ 和 $\\sum J^2 = 0$。\n        ii. 对于每条射线 $i=1, \\dots, N$：\n            - 使用当前慢度估计值 $(s_1, s_2^{(k)})$ 求解正演问题。这会得到预测走时 $T_i^{(k)}$ 和雅可比分量 $J_i^{(k)} = L_{2,i}^{(k)}$。\n            - 计算残差 $r_i^{(k)} = T_i^{(k)} - T_i^{\\text{obs}}$。\n            - 更新求和：$\\sum J r \\leftarrow \\sum J r + J_i^{(k)} r_i^{(k)}$ 和 $\\sum J^2 \\leftarrow \\sum J^2 + (J_i^{(k)})^2$。\n        iii. 计算慢度更新量 $\\Delta s_2^{(k)} = -(\\sum J r) / (\\sum J^2)$。\n        iv. 更新慢度估计值：$s_2^{(k+1)} = s_2^{(k)} + \\Delta s_2^{(k)}$。\n4. **最终结果**：两次迭代后，计算最终估算的慢度对比 $\\delta s^{(2)} = s_2^{(2)} - s_1$。\n\n将此过程应用于问题陈述中提供的三个测试用例中的每一个，以获得所需的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to run the Gauss-Newton tomography inversion for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"v0\": 2000.0,\n            \"h\": 500.0,\n            \"v2_true\": 3000.0,\n            \"pairs\": [\n                ((0, 100), (1000, 600)),\n                ((0, 300), (1000, 800)),\n                ((0, 450), (1000, 1000)),\n                ((0, 100), (1000, 1000)),\n            ],\n        },\n        {\n            \"v0\": 2500.0,\n            \"h\": 300.0,\n            \"v2_true\": 2600.0,\n            \"pairs\": [\n                ((0, 50), (500, 400)),\n                ((0, 100), (500, 550)),\n                ((0, 200), (500, 600)),\n            ],\n        },\n        {\n            \"v0\": 1800.0,\n            \"h\": 400.0,\n            \"v2_true\": 6000.0,\n            \"pairs\": [\n                ((0, 390), (800, 600)),\n                ((0, 100), (800, 700)),\n                ((0, 10), (800, 900)),\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_inversion_case(case)\n        results.append(f\"{result:.10e}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef _snell_function(x_star, s1, s2, xs, zs, xr, zr, h):\n    \"\"\"\n    The function f(x_star) = 0 that represents Snell's law geometrically.\n    The root of this function provides the interface crossing point.\n    \"\"\"\n    delta_z1 = h - zs\n    delta_z2 = zr - h\n    \n    term1_num = x_star - xs\n    term1_den = np.sqrt(term1_num**2 + delta_z1**2)\n    \n    term2_num = xr - x_star\n    term2_den = np.sqrt(term2_num**2 + delta_z2**2)\n    \n    # Avoid division by zero if x_star is exactly xs or xr\n    if term1_den == 0: term1 = 0\n    else: term1 = s1 * term1_num / term1_den\n    \n    if term2_den == 0: term2 = 0\n    else: term2 = s2 * term2_num / term2_den\n\n    return term1 - term2\n\ndef _find_x_star(s1, s2, xs, zs, xr, zr, h):\n    \"\"\"\n    Numerically solves for the interface crossing point x_star using Brent's method.\n    \"\"\"\n    # The crossing point must be between the source and receiver x-coordinates.\n    # A small buffer is added to avoid issues at the boundaries.\n    a = xs + 1e-9\n    b = xr - 1e-9\n    \n    try:\n        x_star = brentq(_snell_function, a, b, args=(s1, s2, xs, zs, xr, zr, h))\n    except ValueError:\n        # Should not happen for the given test cases, but good practice.\n        # This could occur if the function has the same sign at both ends of the interval.\n        return (xs + xr) / 2.0\n        \n    return x_star\n\ndef calculate_forward(s1, s2, source, receiver, h):\n    \"\"\"\n    Performs the forward calculation: finds the ray path and computes travel time.\n    Returns:\n        T (float): The total travel time.\n        L2 (float): The path length in the second layer (our Jacobian).\n    \"\"\"\n    xs, zs = source\n    xr, zr = receiver\n    \n    x_star = _find_x_star(s1, s2, xs, zs, xr, zr, h)\n    \n    l1 = np.sqrt((x_star - xs)**2 + (h - zs)**2)\n    l2 = np.sqrt((xr - x_star)**2 + (zr - h)**2)\n    \n    travel_time = s1 * l1 + s2 * l2\n    \n    return travel_time, l2\n    \ndef run_inversion_case(case_data):\n    \"\"\"\n    Runs the two-iteration Gauss-Newton inversion for a single test case.\n    \"\"\"\n    v0 = case_data[\"v0\"]\n    h = case_data[\"h\"]\n    v2_true = case_data[\"v2_true\"]\n    pairs = case_data[\"pairs\"]\n    \n    s1 = 1.0 / v0\n    s2_true = 1.0 / v2_true\n    \n    # 1. Generate \"observed\" data using the true model\n    observed_times = []\n    for source, receiver in pairs:\n        t_obs, _ = calculate_forward(s1, s2_true, source, receiver, h)\n        observed_times.append(t_obs)\n        \n    # 2. Perform two Gauss-Newton iterations\n    s2_k = s1  # Initial guess s2^(0) = s1\n    \n    for _ in range(2): # k = 0, 1\n        sum_Jr = 0.0\n        sum_JJ = 0.0\n        \n        for i, (source, receiver) in enumerate(pairs):\n            # Calculate predicted time and Jacobian for the current model s2_k\n            t_pred, jacobian_L2 = calculate_forward(s1, s2_k, source, receiver, h)\n            \n            # Get the corresponding observed time\n            t_obs = observed_times[i]\n            \n            # Calculate residual\n            residual = t_pred - t_obs\n            \n            # Accumulate sums for the normal equation\n            sum_Jr += jacobian_L2 * residual\n            sum_JJ += jacobian_L2**2\n            \n        # Calculate the model update\n        if sum_JJ == 0:\n            delta_s2 = 0.0 # Avoid division by zero\n        else:\n            delta_s2 = -sum_Jr / sum_JJ\n        \n        # Update the model\n        s2_k = s2_k + delta_s2\n        \n    # Final estimate after two iterations is s2_k (which is s2^(2))\n    s2_final = s2_k\n    \n    # 3. Calculate the final slowness contrast\n    delta_s_final = s2_final - s1\n    \n    return delta_s_final\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}