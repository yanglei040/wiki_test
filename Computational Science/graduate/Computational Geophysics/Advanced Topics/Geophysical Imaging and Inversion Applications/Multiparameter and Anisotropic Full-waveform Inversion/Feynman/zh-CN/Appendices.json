{
    "hands_on_practices": [
        {
            "introduction": "全波形反演（FWI）的成功依赖于其核心引擎——波动方程正演模拟的准确性。本练习将引导你分析各向异性声波方程的有限差分格式中一个关键的数值问题：数值频散。通过推导离散频散关系，你将学会如何量化由网格离散化引起的相速度误差，并确定保证模拟精度在可接受范围内的最大网格间距。",
            "id": "3611622",
            "problem": "考虑二维垂直横向各向同性 (VTI) 在椭圆各向异性极限下的情况，此时 Thomsen 参数满足 $\\delta = \\epsilon$。在此极限下，声学准压缩 (qP) 波场 $u(x,z,t)$ 由常系数各向异性声学波动方程控制：\n$$\n\\frac{\\partial^{2} u}{\\partial t^{2}} \\;=\\; v_{x}^{2}\\,\\frac{\\partial^{2} u}{\\partial x^{2}} \\;+\\; v_{z}^{2}\\,\\frac{\\partial^{2} u}{\\partial z^{2}},\n$$\n其中 $v_{z} = v_{P0}$ 是垂直相速度，$v_{x} = v_{P0}\\sqrt{1+2\\epsilon}$ 是水平相速度。该模型被广泛用于为多参数和各向异性全波形反演 (FWI) 设计波动方程求解器。\n\n你将使用时间和空间上的二阶中心有限差分，在网格间距为 $\\Delta x = \\Delta z = h$ 的均匀方形网格和均匀时间步长 $\\Delta t$ 上对该方程进行离散化。设时间步长 $\\Delta t$ 的选择使此格式的 Courant–Friedrichs–Lewy (CFL) 稳定性极限达到饱和。你需要：\n\n1. 将平面波拟设 $u = \\exp\\!\\big(i(k_{x} x + k_{z} z - \\omega t)\\big)$ 代入有限差分格式，推导离散色散关系。用 $r_{x} = v_{x}\\Delta t/h$、$r_{z} = v_{z}\\Delta t/h$、$\\kappa_{x} = k_{x} h/2$ 和 $\\kappa_{z} = k_{z} h/2$ 表示结果。\n\n2. 使用小波数展开（即 $|\\kappa_{x}| \\ll 1$，$|\\kappa_{z}| \\ll 1$），获得相对相速度误差 $e(\\theta)$ 的主阶表达式。其中传播角 $\\theta \\in [0,\\pi/2]$（弧度）由 $k_{x} = k\\cos\\theta$ 和 $k_{z} = k\\sin\\theta$ 定义，且 $k = \\sqrt{k_{x}^{2}+k_{z}^{2}}$。你的表达式必须明确显示出对 $h$、最大角频率 $\\omega_{\\max}$（等效于最大频率 $f_{\\max} = \\omega_{\\max}/(2\\pi)$）以及各向异性速度 $v_{x}$ 和 $v_{z}$ 的依赖关系。\n\n3. 对于二阶有限差分格式，在使 CFL 极限饱和的 $\\Delta t$ 选择下，确定最大允许网格间距 $h$，以保证在所有 $\\theta \\in [0,\\pi/2]$ 上的最坏情况相对相速度误差不超过预设容差 $\\tau$。提供一个关于 $f_{\\max}$、$v_{x}$、$v_{z}$ 和 $\\tau$ 的 $h$ 的闭式公式。\n\n最后，考虑以下设计参数\n- $v_{P0} = 2500$ m/s，\n- $\\epsilon = 0.2$（因此 $\\delta = \\epsilon$），\n- $f_{\\max} = 30$ Hz，\n- 容差 $\\tau = 0.01$，\n并计算最大允许网格间距 $h$ 的数值（以米为单位）。将你的答案四舍五入到四位有效数字。将最终的 $h$ 以米表示。",
            "solution": "我们从常系数各向异性声学波动方程开始\n$$\n\\frac{\\partial^{2} u}{\\partial t^{2}} \\;=\\; v_{x}^{2}\\,\\frac{\\partial^{2} u}{\\partial x^{2}} \\;+\\; v_{z}^{2}\\,\\frac{\\partial^{2} u}{\\partial z^{2}}.\n$$\n对于椭圆垂直横向各向同性 (VTI) 且 $\\delta = \\epsilon$ 的情况，水平和垂直相速度满足 $v_{x} = v_{P0}\\sqrt{1+2\\epsilon}$ 和 $v_{z} = v_{P0}$。\n\n我们在均匀方形网格 $\\Delta x = \\Delta z = h$ 和时间步长 $\\Delta t$ 上，使用时间和空间上的二阶中心差分进行离散化。在网格点 $(i,j)$ 和时间层 $n$ 的有限差分 (FD) 格式为\n$$\n\\frac{u_{i,j}^{n+1} - 2 u_{i,j}^{n} + u_{i,j}^{n-1}}{\\Delta t^{2}}\n\\;=\\;\nv_{x}^{2}\\,\\frac{u_{i+1,j}^{n} - 2 u_{i,j}^{n} + u_{i-1,j}^{n}}{h^{2}}\n\\;+\\;\nv_{z}^{2}\\,\\frac{u_{i,j+1}^{n} - 2 u_{i,j}^{n} + u_{i,j-1}^{n}}{h^{2}}.\n$$\n\n离散色散关系的推导。将平面波 $u_{i,j}^{n} = \\exp\\!\\big(i(k_{x} i h + k_{z} j h - \\omega n \\Delta t)\\big)$ 代入该格式。标准的代数运算得出\n$$\n\\frac{\\exp(-i\\omega\\Delta t) - 2 + \\exp(i\\omega\\Delta t)}{\\Delta t^{2}}\n\\;=\\;\nv_{x}^{2}\\,\\frac{\\exp(i k_{x} h) - 2 + \\exp(-i k_{x} h)}{h^{2}}\n\\;+\\;\nv_{z}^{2}\\,\\frac{\\exp(i k_{z} h) - 2 + \\exp(-i k_{z} h)}{h^{2}}.\n$$\n使用 $\\exp(i\\phi) - 2 + \\exp(-i\\phi) = -4 \\sin^{2}(\\phi/2)$，我们得到\n$$\n\\frac{-4 \\sin^{2}(\\omega \\Delta t/2)}{\\Delta t^{2}}\n\\;=\\;\nv_{x}^{2}\\,\\frac{-4 \\sin^{2}(k_{x} h/2)}{h^{2}}\n\\;+\\;\nv_{z}^{2}\\,\\frac{-4 \\sin^{2}(k_{z} h/2)}{h^{2}}.\n$$\n消去公因子 $-4$ 并定义 $r_{x} = v_{x}\\Delta t/h$，$r_{z} = v_{z}\\Delta t/h$，$\\kappa_{x} = k_{x} h/2$ 和 $\\kappa_{z} = k_{z} h/2$，离散色散关系为\n$$\n\\sin^{2}\\!\\left(\\frac{\\omega \\Delta t}{2}\\right)\n\\;=\\;\nr_{x}^{2}\\,\\sin^{2}(\\kappa_{x})\n\\;+\\;\nr_{z}^{2}\\,\\sin^{2}(\\kappa_{z}).\n$$\n\n小波数展开和相速度误差。对于小的 $|\\kappa_{x}|,|\\kappa_{z}|$，使用 $\\sin(\\xi) = \\xi - \\xi^{3}/6 + \\mathcal{O}(\\xi^{5})$ 来获得\n$$\n\\sin^{2}\\!\\left(\\frac{\\omega \\Delta t}{2}\\right)\n=\n\\left(\\frac{\\omega \\Delta t}{2}\\right)^{2}\n- \\frac{1}{3}\\left(\\frac{\\omega \\Delta t}{2}\\right)^{4}\n+ \\mathcal{O}\\!\\left((\\omega \\Delta t)^{6}\\right),\n$$\n$$\n\\sin^{2}(\\kappa_{x})\n=\n\\kappa_{x}^{2} - \\frac{\\kappa_{x}^{4}}{3} + \\mathcal{O}(\\kappa_{x}^{6}),\n\\qquad\n\\sin^{2}(\\kappa_{z})\n=\n\\kappa_{z}^{2} - \\frac{\\kappa_{z}^{4}}{3} + \\mathcal{O}(\\kappa_{z}^{6}).\n$$\n令 $k = \\sqrt{k_{x}^{2} + k_{z}^{2}}$ 并通过 $k_{x} = k \\cos\\theta$，$k_{z} = k \\sin\\theta$（其中 $\\theta \\in [0,\\pi/2]$）定义传播角 $\\theta$。定义\n$$\nA(\\theta) = v_{x}^{2}\\cos^{2}\\theta + v_{z}^{2}\\sin^{2}\\theta,\n\\qquad\nB(\\theta) = v_{x}^{2}\\cos^{4}\\theta + v_{z}^{2}\\sin^{4}\\theta.\n$$\n在展开的色散关系中匹配阶数，得到主阶频率校正\n$$\n\\omega^{2} = k^{2} A(\\theta) + \\delta(\\theta),\n\\qquad\n\\delta(\\theta) \\approx \\frac{\\Delta t^{2}}{12}\\,k^{4} A(\\theta)^{2} - \\frac{h^{2}}{12}\\,k^{4} B(\\theta),\n$$\n其中我们忽略了 $k$ 的高于四阶的项。数值相速度为 $c_{\\mathrm{num}}(\\theta) = \\omega/k$。将 $\\omega = k \\sqrt{A + \\delta/k^{2}}$ 对 $\\delta$ 展开到一阶，得到\n$$\nc_{\\mathrm{num}}(\\theta) \\approx \\sqrt{A(\\theta)}\\left[1 + \\frac{1}{2}\\frac{\\delta(\\theta)}{k^{2}A(\\theta)}\\right].\n$$\n因此，主阶相对相速度误差 $e(\\theta)$ 为\n$$\ne(\\theta) \\equiv \\frac{c_{\\mathrm{num}}(\\theta) - \\sqrt{A(\\theta)}}{\\sqrt{A(\\theta)}}\n\\;\\approx\\;\n\\frac{1}{24}\\,k^{2}\\left[\\Delta t^{2} A(\\theta) - \\frac{h^{2} B(\\theta)}{A(\\theta)}\\right].\n$$\n\nCFL 选择和关于角度的最坏情况误差。对于方形网格上的二阶格式，Courant–Friedrichs–Lewy (CFL) 稳定性极限为 $r_{x}^{2} + r_{z}^{2} \\leq 1$，即\n$$\n\\frac{v_{x}^{2}\\Delta t^{2}}{h^{2}} + \\frac{v_{z}^{2}\\Delta t^{2}}{h^{2}} \\;\\leq\\; 1\n\\;\\;\\Rightarrow\\;\\;\n\\Delta t^{2} = \\frac{h^{2}}{v_{x}^{2} + v_{z}^{2}}\n$$\n当使该界限饱和时。将此代入误差表达式得到\n$$\ne(\\theta) \\approx \\frac{1}{24}\\,k^{2} h^{2}\\left[\\frac{A(\\theta)}{v_{x}^{2} + v_{z}^{2}} - \\frac{B(\\theta)}{A(\\theta)}\\right].\n$$\n对于给定的角频率 $\\omega$（或频率 $f$），波数为 $k(\\theta) = \\omega/\\sqrt{A(\\theta)} = 2\\pi f/\\sqrt{A(\\theta)}$。因此，\n$$\ne(\\theta) \\approx \\frac{h^{2}}{24}\\left(\\frac{2\\pi f}{\\sqrt{A(\\theta)}}\\right)^{2}\n\\left[\\frac{A(\\theta)}{v_{x}^{2} + v_{z}^{2}} - \\frac{B(\\theta)}{A(\\theta)}\\right]\n=\n\\frac{h^{2}(2\\pi f)^{2}}{24}\\left[\\frac{1}{v_{x}^{2} + v_{z}^{2}} - \\frac{B(\\theta)}{A(\\theta)^{2}}\\right].\n$$\n定义 $S = v_{x}^{2} + v_{z}^{2}$ 和\n$$\nQ(\\theta) = \\frac{B(\\theta)}{A(\\theta)^{2}}\n=\n\\frac{v_{x}^{2}\\cos^{4}\\theta + v_{z}^{2}\\sin^{4}\\theta}{\\big(v_{x}^{2}\\cos^{2}\\theta + v_{z}^{2}\\sin^{2}\\theta\\big)^{2}}.\n$$\n则\n$$\ne(\\theta) \\approx \\frac{h^{2}(2\\pi f)^{2}}{24}\\,\\bigg[\\frac{1}{S} - Q(\\theta)\\bigg].\n$$\n为了保证在 $f = f_{\\max}$ 时，对于所有 $\\theta \\in [0,\\pi/2]$ 都有 $|e(\\theta)| \\le \\tau$，我们需要\n$$\n\\frac{h^{2}(2\\pi f_{\\max})^{2}}{24}\\,\\sup_{\\theta \\in [0,\\pi/2]}\\bigg|\\,\\frac{1}{S} - Q(\\theta)\\,\\bigg| \\;\\le\\; \\tau.\n$$\n剩下的就是计算 $D \\equiv \\sup_{\\theta} |\\,1/S - Q(\\theta)\\,|$。通过 $u = \\cos^{2}\\theta \\in [0,1]$ 进行参数化，因此\n$$\nA(u) = v_{x}^{2} u + v_{z}^{2} (1-u),\\qquad\nB(u) = v_{x}^{2} u^{2} + v_{z}^{2} (1-u)^{2},\\qquad\nQ(u) = \\frac{B(u)}{A(u)^{2}}.\n$$\n一个直接的导数检验表明，$Q(u)$ 在 $u = 1/2$ 处有一个唯一的内部临界点，其值为\n$$\nQ\\!\\left(\\tfrac{1}{2}\\right) = \\frac{1}{v_{x}^{2} + v_{z}^{2}} = \\frac{1}{S},\n$$\n和端点值 $Q(0) = 1/v_{z}^{2}$ 和 $Q(1) = 1/v_{x}^{2}$。因此，\n$$\n\\inf_{\\theta} Q(\\theta) = \\frac{1}{S},\n\\qquad\n\\sup_{\\theta} Q(\\theta) = \\frac{1}{\\min(v_{x}^{2},v_{z}^{2})}.\n$$\n假设 $v_{x} \\ge v_{z}$（对于正 $\\epsilon$ 的典型情况），我们有 $\\sup_{\\theta} Q(\\theta) = 1/v_{z}^{2}$。因此\n$$\n\\sup_{\\theta}\\bigg|\\,\\frac{1}{S} - Q(\\theta)\\,\\bigg|\n=\n\\max\\!\\left(\\frac{1}{S} - \\frac{1}{S},\\,\\frac{1}{v_{z}^{2}} - \\frac{1}{S}\\right)\n=\n\\frac{v_{x}^{2}}{v_{z}^{2}\\,S}.\n$$\n因此，最坏情况的界限在 $\\theta = \\pi/2$（垂直传播）处达到，且满足所有 $\\theta$ 的 $|e(\\theta)| \\le \\tau$ 的最大允许网格间距为\n$$\nh_{\\max}\n=\n\\sqrt{\\frac{24\\,\\tau}{(2\\pi f_{\\max})^{2}}\\,\\frac{1}{D}}\n=\n\\sqrt{\\frac{24\\,\\tau}{(2\\pi f_{\\max})^{2}}\\,\\frac{v_{z}^{2}\\,S}{v_{x}^{2}}}\n=\n\\sqrt{\\frac{24\\,\\tau\\,v_{z}^{2}\\,(v_{x}^{2}+v_{z}^{2})}{(2\\pi f_{\\max})^{2}\\,v_{x}^{2}}}.\n$$\n\n数值计算。根据给定的值 $v_{P0} = 2500$ m/s，$\\epsilon = 0.2$（因此 $\\delta=\\epsilon$），我们有\n$$\nv_{z} = v_{P0} = 2500,\\qquad\nv_{x} = v_{P0}\\sqrt{1+2\\epsilon} = 2500\\,\\sqrt{1.4},\n$$\n所以\n$$\nv_{z}^{2} = 6.25\\times 10^{6},\\qquad\nv_{x}^{2} = 1.4\\,v_{z}^{2} = 8.75\\times 10^{6},\\qquad\nS = v_{x}^{2} + v_{z}^{2} = 1.5\\times 10^{7}.\n$$\n当 $f_{\\max} = 30$ 且 $\\tau = 0.01$ 时，我们得到\n$$\nh_{\\max}\n=\n\\sqrt{\\frac{24\\,(0.01)\\,(6.25\\times 10^{6})\\,(1.5\\times 10^{7})}{\\big(2\\pi\\cdot 30\\big)^{2}\\,(8.75\\times 10^{6})}}\n=\n\\sqrt{\\frac{24\\,(0.01)\\,v_{z}^{2}\\,S}{(2\\pi f_{\\max})^{2}\\,v_{x}^{2}}}.\n$$\n计算平方根内的无量纲因子：\n$$\n\\frac{24\\,(0.01)}{(2\\pi\\cdot 30)^{2}}\\cdot \\frac{v_{z}^{2}\\,S}{v_{x}^{2}}\n=\n\\frac{0.24}{3600\\pi^{2}}\\cdot \\frac{(6.25\\times 10^{6})(1.5\\times 10^{7})}{8.75\\times 10^{6}}\n=\n\\frac{0.24}{3600\\pi^{2}}\\cdot \\frac{9.375\\times 10^{13}}{8.75\\times 10^{6}}\n=\n\\frac{0.24}{3600\\pi^{2}}\\cdot 1.071428571\\times 10^{7}.\n$$\n等效地，使用前面推导的紧凑表达式，\n$$\nh_{\\max}\n=\n\\sqrt{\\frac{24\\,\\tau}{(2\\pi f_{\\max})^{2}\\,D}}\n,\\quad\nD = \\frac{v_{x}^{2}}{v_{z}^{2}\\,S}\n=\n\\frac{8.75\\times 10^{6}}{(6.25\\times 10^{6})(1.5\\times 10^{7})}\n=\n9.333333333\\times 10^{-8}.\n$$\n因此\n$$\nh_{\\max} = \\sqrt{\\frac{0.24}{(2\\pi\\cdot 30)^{2}\\,(9.333333333\\times 10^{-8})}}\n=\n\\sqrt{\\frac{0.24}{3600\\pi^{2}\\cdot 9.333333333\\times 10^{-8}}}\n\\approx \\sqrt{72.372274}\n\\approx 8.507.\n$$\n四舍五入到四位有效数字并以米表示，最大允许网格间距是 $8.507$ 米。",
            "answer": "$$\\boxed{8.507}$$"
        },
        {
            "introduction": "在多参数FWI中，一个核心挑战是参数“串扰”（cross-talk），即不同地球物理参数的变化可能在数据中产生相似的响应，导致反演的非唯一性。本练习通过一个实际问题，让你亲手实践线性化灵敏度分析，以区分各向异性参数与采集几何误差的影响。你将推导并使用旅行时相对于Thomsen参数 $\\delta$ 和检波器深度的敏感度核函数（sensitivity kernels），从而理解如何诊断和量化这种常见的反演模糊性。",
            "id": "3611639",
            "problem": "考虑一个二维、均匀、具有弱各向异性的垂向横向各向同性（VTI）声学介质，其中一个震源位于深度 $z_s$，一组检波器位于深度 $z_r$。假设介质具有背景各向同性P波速度 $v_0$ 和单个Thomsen各向异性参数 $\\delta$（delta）。在高频（基于射线）近似下，震源和检波器之间的相位到时 $t$ 由沿射线路径的慢度线积分给出。对于直线射线运动学下的均匀介质，走时简化为路径长度按与角度相关的相速度进行缩放。\n\n使用VTI介质中P波相速度的弱各向异性近似，\n$$\nv(\\theta,\\delta) \\approx v_0 \\left(1 + A(\\theta)\\,\\delta\\right),\n$$\n其中 $\\theta$ 是射线与对称轴（垂直方向）之间的夹角，并且\n$$\nA(\\theta) = \\sin^2\\theta\\,\\cos^2\\theta = \\tfrac{1}{4}\\sin^2(2\\theta).\n$$\n设水平炮检距为 $x \\ge 0$，并记 $\\Delta x = x_r - x_s$ 和 $\\Delta z = z_r - z_s$。直线路径长度为\n$$\n\\ell = \\sqrt{(\\Delta x)^2 + (\\Delta z)^2},\n$$\n且与垂直方向的夹角为\n$$\n\\theta = \\arctan2\\left(|\\Delta x|,|\\Delta z|\\right).\n$$\n模型走时为\n$$\nt_{\\text{model}} = \\frac{\\ell_{\\text{model}}}{v(\\theta_{\\text{model}},\\delta_{\\text{model}})} = \\frac{\\ell_{\\text{model}}}{v_0\\left(1 + A(\\theta_{\\text{model}})\\,\\delta_{\\text{model}}\\right)}.\n$$\n真实走时为\n$$\nt_{\\text{true}} = \\frac{\\ell_{\\text{true}}}{v(\\theta_{\\text{true}},\\delta_{\\text{true}})} = \\frac{\\ell_{\\text{true}}}{v_0\\left(1 + A(\\theta_{\\text{true}})\\,\\delta_{\\text{true}}\\right)},\n$$\n其中，真实检波器深度包含一个几何误差 $\\Delta z_r$，使得 $z_{r,\\text{true}} = z_{r,\\text{model}} + \\Delta z_r$，而震源深度假设为已知且固定。可测量的相位残差为\n$$\n\\Delta t(x) = t_{\\text{true}}(x) - t_{\\text{model}}(x).\n$$\n\n任务是执行线性化灵敏度分析，将小的相位残差 $\\Delta t(x)$ 归因于各向异性与几何位置的误差。具体来说，围绕模型参数对残差进行线性化，并表示为\n$$\n\\Delta t(x) \\approx K_\\delta(x)\\,\\Delta\\delta + K_{\\text{geo}}(x)\\,\\Delta z_r,\n$$\n其中 $\\Delta\\delta = \\delta_{\\text{true}} - \\delta_{\\text{model}}$，$\\Delta z_r$ 是检波器深度误差。基于以上定义和链式法则，推导灵敏度核函数 $K_\\delta(x)$ 和 $K_{\\text{geo}}(x)$ 的表达式：\n- 各向异性核函数 $K_\\delta(x) = \\frac{\\partial t}{\\partial \\delta}\\big|_{\\text{model}}$ 必须从 $v(\\theta,\\delta)$ 对 $\\delta$ 的显式依赖关系中推导得出。\n- 几何核函数 $K_{\\text{geo}}(x) = \\frac{\\partial t}{\\partial z_r}\\big|_{\\text{model}}$ 必须同时包含通过 $\\ell$ 的路径长度灵敏度和通过 $\\theta$ 的由各向异性引起的角度灵敏度。您必须考虑以下导数\n$$\n\\frac{\\partial \\ell}{\\partial z_r} = \\frac{\\Delta z}{\\ell}, \\quad \\frac{\\partial \\theta}{\\partial z_r} = -\\frac{\\Delta x}{(\\Delta x)^2 + (\\Delta z)^2}, \\quad \\frac{\\partial A}{\\partial \\theta} = \\tfrac{1}{2}\\sin(4\\theta).\n$$\n角度使用弧度制。\n\n实现一个程序，该程序：\n1. 对于给定的一组炮检距 $x$，根据模型参数计算模型核函数 $K_\\delta(x)$ 和 $K_{\\text{geo}}(x)$。\n2. 使用真实参数 $(\\delta_{\\text{true}}, z_{r,\\text{true}})$ 和模型参数 $(\\delta_{\\text{model}}, z_{r,\\text{model}})$ 生成合成的“测量”相位残差 $\\Delta t(x)$。\n3. 使用由核函数和残差形成的线性系统，求解 $(\\Delta\\delta, \\Delta z_r)$ 的最小二乘估计。\n4. 对于每个测试用例，报告估计的各向异性误差 $\\Delta\\delta$（无量纲）、估计的检波器深度误差 $\\Delta z_r$（单位为米）以及测量残差与线性化重构之间的均方根残差（单位为秒）。\n\n所有距离单位必须是米，速度单位是米/秒，时间单位是秒，角度单位是弧度。所有输出均需使用指定单位并以十进制数表示。\n\n测试套件：\n- 情况 A（一般“理想”路径）：$v_0 = 3000$, $z_s = 0$, $z_{r,\\text{model}} = 1500$, $\\delta_{\\text{model}} = 0.07$, $\\delta_{\\text{true}} = 0.08$, $\\Delta z_{r,\\text{true}} = 4$，炮检距 $x \\in \\{200, 800, 1400, 2000\\}$。\n- 情况 B（仅几何误差）：$v_0 = 3000$, $z_s = 0$, $z_{r,\\text{model}} = 1200$, $\\delta_{\\text{model}} = 0.06$, $\\delta_{\\text{true}} = 0.06$, $\\Delta z_{r,\\text{true}} = 10$，炮检距 $x \\in \\{0, 500, 1000, 2000\\}$。\n- 情况 C（仅各向异性误差）：$v_0 = 2800$, $z_s = 0$, $z_{r,\\text{model}} = 1800$, $\\delta_{\\text{model}} = 0.05$, $\\delta_{\\text{true}} = 0.03$, $\\Delta z_{r,\\text{true}} = 0$，炮检距 $x \\in \\{300, 900, 1500, 2100\\}$。\n- 情况 D（边界情况覆盖：近垂直和近水平混合）：$v_0 = 3200$, $z_s = 0$, $z_{r,\\text{model}} = 1000$, $\\delta_{\\text{model}} = 0.05$, $\\delta_{\\text{true}} = 0.06$, $\\Delta z_{r,\\text{true}} = -5$，炮检距 $x \\in \\{0, 100, 1000, 4000\\}$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个形如 $[\\Delta\\delta_{\\text{est}}, \\Delta z_{r,\\text{est}}, \\text{rms}]$ 的内部列表。例如，输出格式必须与 $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]]$ 完全一致，其中均方根残差值以秒为单位，几何估计值以米为单位，均为十进制数。",
            "solution": "该问题是有效的，因为它在科学上基于各向异性介质中地震波传播的原理，在数学上是一个适定的线性最小二乘反演问题，并且在形式上是完整和一致的。我们将继续推导灵敏度核函数，然后构建一个数值解。\n\n目标是为线性化走时残差方程找到灵敏度核函数 $K_\\delta(x)$ 和 $K_{\\text{geo}}(x)$：\n$$\n\\Delta t(x) \\approx K_\\delta(x)\\,\\Delta\\delta + K_{\\text{geo}}(x)\\,\\Delta z_r\n$$\n该方程表示走时 $t$ 在背景模型状态 $(\\delta_{\\text{model}}, z_{r, \\text{model}})$ 附近关于参数 $\\delta$ 和 $z_r$ 的一阶泰勒展开。核函数是在此模型状态下求值的走时偏导数。\n\n走时 $t$ 由下式给出：\n$$\nt(\\ell, \\theta, \\delta) = \\frac{\\ell}{v(\\theta, \\delta)} = \\frac{\\ell}{v_0(1 + A(\\theta)\\delta)}\n$$\n其中 $\\ell = \\sqrt{(\\Delta x)^2 + (\\Delta z)^2}$ 和 $\\theta = \\arctan2(|\\Delta x|, |\\Delta z|)$ 都是检波器深度 $z_r$ 的函数（因为 $\\Delta z = z_r - z_s$），并且 $A(\\theta) = \\sin^2\\theta\\cos^2\\theta$。以下推导中的所有量都在模型状态下计算，因此为简洁起见，在最终表达式之前我们将省略“model”下标。\n\n**1. 各向异性核函数 $K_\\delta(x)$ 的推导**\n\n各向异性核函数是走时关于Thomsen参数 $\\delta$ 的偏导数。\n$$\nK_\\delta(x) = \\frac{\\partial t}{\\partial \\delta} = \\frac{\\partial}{\\partial \\delta} \\left[ \\frac{\\ell}{v_0(1 + A(\\theta)\\delta)} \\right]\n$$\n将 $\\ell$、$\\theta$ 和 $v_0$ 视为关于 $\\delta$ 的常数，我们应用链式法则：\n$$\n\\frac{\\partial t}{\\partial \\delta} = \\frac{\\ell}{v_0} \\cdot \\frac{\\partial}{\\partial \\delta} \\left( (1 + A(\\theta)\\delta)^{-1} \\right) = \\frac{\\ell}{v_0} \\left[ -1 \\cdot (1 + A(\\theta)\\delta)^{-2} \\cdot A(\\theta) \\right]\n$$\n$$\n\\frac{\\partial t}{\\partial \\delta} = -\\frac{\\ell A(\\theta)}{v_0(1 + A(\\theta)\\delta)^2}\n$$\n这个表达式可以方便地用模型走时 $t_{\\text{model}} = \\frac{\\ell_{\\text{model}}}{v_0(1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}})}$ 来表示。\n$$\nK_\\delta(x) = -\\left( \\frac{\\ell_{\\text{model}}}{v_0(1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}})} \\right) \\frac{A(\\theta_{\\text{model}})}{1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}}}\n$$\n因此，各向异性核函数的最终表达式为：\n$$\nK_\\delta(x) = -\\frac{t_{\\text{model}} A(\\theta_{\\text{model}})}{1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}}}\n$$\n\n**2. 几何核函数 $K_{\\text{geo}}(x)$ 的推导**\n\n几何核函数是走时关于检波器深度 $z_r$ 的偏导数。走时 $t$ 通过路径长度 $\\ell$ 和角度 $\\theta$ 同时依赖于 $z_r$。我们必须使用链式法则。\n$$\nK_{\\text{geo}}(x) = \\frac{\\partial t}{\\partial z_r} = \\frac{\\partial}{\\partial z_r} \\left( \\frac{\\ell}{v} \\right)\n$$\n使用商法则：\n$$\n\\frac{\\partial t}{\\partial z_r} = \\frac{1}{v} \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\ell}{v^2} \\frac{\\partial v}{\\partial z_r}\n$$\n速度 $v$ 对 $z_r$ 的导数也通过链式法则求得，因为 $v$ 通过 $\\theta$ 依赖于 $z_r$：\n$$\n\\frac{\\partial v}{\\partial z_r} = \\frac{\\partial v}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r}\n$$\n从 $v = v_0(1 + A(\\theta)\\delta)$，我们有：\n$$\n\\frac{\\partial v}{\\partial \\theta} = v_0 \\delta \\frac{\\partial A}{\\partial \\theta}\n$$\n将此代回可得：\n$$\n\\frac{\\partial v}{\\partial z_r} = v_0 \\delta \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r}\n$$\n现在我们将此代入 $\\frac{\\partial t}{\\partial z_r}$ 的表达式中：\n$$\n\\frac{\\partial t}{\\partial z_r} = \\frac{1}{v} \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\ell}{v^2} \\left( v_0 \\delta \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r} \\right)\n$$\n代入 $v = v_0(1 + A\\delta)$ 并提出公因式：\n$$\n\\frac{\\partial t}{\\partial z_r} = \\frac{1}{v} \\left( \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\ell v_0 \\delta}{v} \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r} \\right) = \\frac{1}{v} \\left( \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\ell \\delta}{1 + A\\delta} \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r} \\right)\n$$\n用模型走时 $t_{\\text{model}} = \\ell_{\\text{model}}/v_{\\text{model}}$ 来表示：\n$$\nK_{\\text{geo}}(x) = t_{\\text{model}} \\left( \\frac{1}{\\ell_{\\text{model}}} \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\delta_{\\text{model}}}{1 + A\\delta_{\\text{model}}} \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r} \\right) \\Bigg|_{\\text{model}}\n$$\n我们现在代入问题描述中提供的、在模型参数下求值的显式偏导数：\n- $\\frac{\\partial \\ell}{\\partial z_r} = \\frac{\\Delta z_{\\text{model}}}{\\ell_{\\text{model}}}$\n- $\\frac{\\partial \\theta}{\\partial z_r} = -\\frac{\\Delta x}{(\\Delta x)^2 + (\\Delta z_{\\text{model}})^2} = -\\frac{\\Delta x}{\\ell_{\\text{model}}^2}$\n- $\\frac{\\partial A}{\\partial \\theta} = \\frac{1}{2}\\sin(4\\theta_{\\text{model}})$\n\n将这些代入 $K_{\\text{geo}}(x)$ 的表达式中：\n$$\nK_{\\text{geo}}(x) = t_{\\text{model}} \\left[ \\frac{1}{\\ell_{\\text{model}}} \\left( \\frac{\\Delta z_{\\text{model}}}{\\ell_{\\text{model}}} \\right) - \\frac{\\delta_{\\text{model}}}{1 + A\\delta_{\\text{model}}} \\left( \\frac{1}{2}\\sin(4\\theta_{\\text{model}}) \\right) \\left( -\\frac{\\Delta x}{\\ell_{\\text{model}}^2} \\right) \\right]\n$$\n通过提出公因式 $\\frac{1}{\\ell_{\\text{model}}^2}$ 来简化表达式：\n$$\nK_{\\text{geo}}(x) = \\frac{t_{\\text{model}}}{\\ell_{\\text{model}}^2} \\left[ \\Delta z_{\\text{model}} + \\frac{\\delta_{\\text{model}} \\Delta x \\sin(4\\theta_{\\text{model}})}{2(1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}})} \\right]\n$$\n这是几何核函数的最终表达式。\n\n利用这些推导出的核函数，我们可以为一组 $N$ 个炮检距 $\\{x_i\\}$ 构建线性系统 $\\mathbf{G} \\mathbf{m} = \\mathbf{d}$：\n$$\n\\begin{pmatrix}\nK_\\delta(x_1) & K_{\\text{geo}}(x_1) \\\\\nK_\\delta(x_2) & K_{\\text{geo}}(x_2) \\\\\n\\vdots & \\vdots \\\\\nK_\\delta(x_N) & K_{\\text{geo}}(x_N)\n\\end{pmatrix}\n\\begin{pmatrix}\n\\Delta\\delta \\\\\n\\Delta z_r\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\Delta t(x_1) \\\\\n\\Delta t(x_2) \\\\\n\\vdots \\\\\n\\Delta t(x_N)\n\\end{pmatrix}\n$$\n该系统使用最小二乘算法求解模型扰动向量 $\\mathbf{m} = [\\Delta\\delta_{\\text{est}}, \\Delta z_{r,\\text{est}}]^T$。测量数据 $\\mathbf{d}$ 和线性化预测 $\\mathbf{G} \\mathbf{m}$ 之间的均方根（RMS）残差量化了线性近似的拟合优度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs linearized sensitivity analysis to estimate anisotropy and geometry errors\n    from seismic travel time residuals.\n    \"\"\"\n    test_cases = [\n        # Case A: general \"happy path\"\n        {\n            'v0': 3000.0, 'zs': 0.0, 'zr_model': 1500.0,\n            'delta_model': 0.07, 'delta_true': 0.08, 'dzr_true': 4.0,\n            'offsets': [200.0, 800.0, 1400.0, 2000.0]\n        },\n        # Case B: geometry-only error\n        {\n            'v0': 3000.0, 'zs': 0.0, 'zr_model': 1200.0,\n            'delta_model': 0.06, 'delta_true': 0.06, 'dzr_true': 10.0,\n            'offsets': [0.0, 500.0, 1000.0, 2000.0]\n        },\n        # Case C: anisotropy-only error\n        {\n            'v0': 2800.0, 'zs': 0.0, 'zr_model': 1800.0,\n            'delta_model': 0.05, 'delta_true': 0.03, 'dzr_true': 0.0,\n            'offsets': [300.0, 900.0, 1500.0, 2100.0]\n        },\n        # Case D: edge-case coverage\n        {\n            'v0': 3200.0, 'zs': 0.0, 'zr_model': 1000.0,\n            'delta_model': 0.05, 'delta_true': 0.06, 'dzr_true': -5.0,\n            'offsets': [0.0, 100.0, 1000.0, 4000.0]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        v0 = case['v0']\n        zs = case['zs']\n        zr_model = case['zr_model']\n        delta_model = case['delta_model']\n        delta_true = case['delta_true']\n        dzr_true = case['dzr_true'] \n        offsets = case['offsets']\n\n        dt_measured = []\n        G_matrix_rows = []\n\n        for x in offsets:\n            dx = x\n\n            # Modeled parameters\n            dz_model = zr_model - zs\n            ell_model = np.sqrt(dx**2 + dz_model**2)\n            # Handle zero path length, though unlikely with problem constraints\n            if ell_model == 0:\n                ell_model = 1e-9\n            \n            theta_model = np.arctan2(dx, dz_model)\n            A_model = 0.25 * (np.sin(2 * theta_model)**2)\n            v_model = v0 * (1 + A_model * delta_model)\n            t_model = ell_model / v_model\n\n            # True parameters and \"measured\" data\n            zr_true_val = zr_model + dzr_true\n            dz_true = zr_true_val - zs\n            ell_true = np.sqrt(dx**2 + dz_true**2)\n            if ell_true == 0:\n                ell_true = 1e-9\n\n            theta_true = np.arctan2(dx, dz_true)\n            A_true = 0.25 * (np.sin(2 * theta_true)**2)\n            v_true = v0 * (1 + A_true * delta_true)\n            t_true = ell_true / v_true\n\n            # Measured residual\n            dt = t_true - t_model\n            dt_measured.append(dt)\n\n            # --- Calculate sensitivity kernels at model parameters ---\n            \n            # Anisotropy kernel K_delta\n            K_delta = - (t_model * A_model) / (1 + A_model * delta_model)\n\n            # Geometry kernel K_geo\n            term1 = dz_model\n            term2_num = delta_model * dx * np.sin(4 * theta_model)\n            term2_den = 2 * (1 + A_model * delta_model)\n            \n            K_geo = (t_model / ell_model**2) * (term1 + term2_num / term2_den)\n\n            G_matrix_rows.append([K_delta, K_geo])\n        \n        # Assemble matrices and solve the linear system\n        G = np.array(G_matrix_rows)\n        d = np.array(dt_measured)\n\n        # Solve G * m = d for m = [delta_delta, delta_zr] using least squares\n        m, residuals_sum_sq, _, _ = np.linalg.lstsq(G, d, rcond=None)\n        \n        d_delta_est, d_zr_est = m[0], m[1]\n        \n        # Calculate RMS residual\n        d_recon = G @ m\n        rms_residual = np.sqrt(np.mean((d - d_recon)**2))\n        \n        all_results.append([d_delta_est, d_zr_est, rms_residual])\n\n    # Format output as a string representation of a list of lists.\n    formatted_results = []\n    for res in all_results:\n        formatted_res = f\"[{res[0]},{res[1]},{res[2]}]\"\n        formatted_results.append(formatted_res)\n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "我们解析复杂各向异性参数的能力，很大程度上取决于地震采集方案的设计。一个精心设计的观测系统能够最大化不同模型参数响应之间的差异，从而最小化参数串扰，这在数学上对应于确保敏感度矩阵具有良好的数值性质。本练习将让你扮演一个采集设计师的角色，任务是确定恢复正交各向异性（orthorhombic）介质参数所需的最优观测几何。通过构建并分析敏感度矩阵的条件数，你将学习如何通过优化方位角和偏移距的覆盖范围，来设计一个既能保证反演稳定性又经济高效的采集方案。",
            "id": "3611578",
            "problem": "给定一个正交各向异性介质中全波形反演 (FWI) 的线性化采集设计问题。其物理出发点是针对平面界面两侧小物性差异的一阶玻恩近似。在此近似下，散射波场与模型擾动呈线性关系，观测到的方位振幅随偏移距 (AVO) 变化的反射率可以表示为方位谐波的线性组合。正交各向异性对称性意味着平面P波反射率具有方位依赖性，可以表示为偶数阶方位谐波的截断级数。在小物性差异极限和中等入射角条件下，通常采用入射角和方位角基函数的可分离表示。目标是通过确保灵敏度矩阵可逆且良态，确定稳健恢复正交各向异性差异参数矢量所需的最小方位角和偏移距覆盖范围。\n\n数学设定：\n- 设入射角为 $\\theta$，方位角为 $\\phi$。\n- 设参数矢量 $\\mathbf{c} \\in \\mathbb{R}^{m}$ 表示投影到一组选定的辐射模式基上的刚度差异的线性组合。在特定点对 $(\\theta,\\phi)$ 处的预测线性化反射率样本是 $\\mathbf{c}$ 的线性函数。\n- 定义一组 $m$ 个基函数 $\\{b_{k}(\\theta,\\phi)\\}_{k=1}^{m}$。每个基函数都构建为一个入射角因子和一个方位谐波的乘积：\n  $$ b_{k}(\\theta,\\phi) = \\left[\\sin(\\theta)\\right]^{p_k} \\cdot t_k\\big(n_k \\phi\\big), $$\n  其中 $p_k \\in \\{0,2,4\\}$ 是一个整数次幂，$n_k \\in \\{0,2,4\\}$ 是一个方位谐波阶数，$t_k$ 是 $\\{\\cos, \\sin, 1\\}$之一，并约定对于常数方位项，$t_k(0) \\equiv 1$。\n- 将选定点对 $\\{(\\theta_i,\\phi_j)\\}$ 处的 $N$ 个测量值堆叠成一个数据矢量 $\\mathbf{r} \\in \\mathbb{R}^{N}$，并构建灵敏度（雅可比）矩阵 $\\mathbf{A} \\in \\mathbb{R}^{N \\times m}$，其元素为：\n  $$ A_{\\ell k} = b_{k}(\\theta_{\\ell}, \\phi_{\\ell}), \\quad \\ell=1,\\dots,N, \\ k=1,\\dots,m, $$\n  其中每一行对应一个唯一的采集点对。\n- $\\mathbf{c}$ 的可恢复性要求 $\\mathbf{A}$ 是列满秩的。稳健恢复进一步要求条件数 $\\kappa(\\mathbf{A}) = \\sigma_{\\max} / \\sigma_{\\min}$ 低于指定的阈值 $\\kappa_{\\max}$，其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 分别是 $\\mathbf{A}$ 的最大和最小奇异值。\n\n任务：\n- 对于下述每个测试用例，您将获得：\n  1. 一组候选方位角 $\\{\\phi\\}$（单位：度）。\n  2. 一组候选入射角 $\\{\\theta\\}$（单位：度）。\n  3. 一个基的规范，即定义 $b_k(\\theta,\\phi)$ 的元组列表 $(p_k, n_k, t_k)$。\n  4. 一个条件数阈值 $\\kappa_{\\max}$。\n- 您的程序必须搜索所有候选方位角和候选入射角的子集，以找到字典序最小的数对 $(N_{\\phi}, N_{\\theta})$（首先最小化 $N_{\\phi}$，然后最小化 $N_{\\theta}$），使得存在 $N_{\\phi}$ 个不同方位角和 $N_{\\theta}$ 个不同入射角的选择，满足以下条件：\n  1. 所得的设计矩阵 $\\mathbf{A}$ 具有列满秩 $m$。\n  2. 条件数满足 $\\kappa(\\mathbf{A}) \\le \\kappa_{\\max}$。\n  3. 测量总数 $N = N_{\\phi} \\cdot N_{\\theta}$ 至少为 $m$。\n- 如果多个子集达到相同的最小 $(N_{\\phi}, N_{\\theta})$，选择条件数最小的那个。\n- 如果不存在可行的子集，则对该测试用例输出布尔值 false。\n- 角度以度为单位提供；所有三角函数计算必须以弧度进行。最终答案中除角度外没有物理单位，最终输出是无量纲的。\n- 如果大于 $\\tau$ 的奇异值数量等于 $m$，则将 $\\mathbf{A}$ 视为满秩，其中：\n  $$ \\tau = 10^{-10}. $$\n\n输出格式：\n- 对于每个测试用例，如果不可行，则输出布尔值 false，否则输出一个列表 $[N_{\\phi}, N_{\\theta}, \\kappa_{\\star}]$，其中 $\\kappa_{\\star}$ 是在最小覆盖解决方案中达到的最小条件数，四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表。例如，三个测试用例的输出可能如下所示：\n  $$ [[3,2,12.345],[4,1,8.765],false] $$\n\n测试套件：\n- 测试用例 1 (单个角度阶数组，五个方位谐波)：\n  - 基项 $\\{(p_k, n_k, t_k)\\}_{k=1}^{5}$：\n    $$ \\{(2,0,\\mathrm{const}),\\ (2,2,\\cos),\\ (2,2,\\sin),\\ (2,4,\\cos),\\ (2,4,\\sin)\\}. $$\n    这对应于 $m=5$ 个未知数。\n  - 候选方位角（单位：度）：\n    $$ \\{10, 40, 70, 100, 130, 160\\}. $$\n  - 候选入射角（单位：度）：\n    $$ \\{15, 30, 45\\}. $$\n  - 阈值：\n    $$ \\kappa_{\\max} = 10^{3}. $$\n- 测试用例 2 (两个角度阶数组，四个方位谐波)：\n  - 基项 $\\{(p_k, n_k, t_k)\\}_{k=1}^{8}$：\n    $$ \\{(2,0,\\mathrm{const}),\\ (2,2,\\cos),\\ (2,2,\\sin),\\ (2,4,\\cos),\\ (4,0,\\mathrm{const}),\\ (4,2,\\cos),\\ (4,2,\\sin),\\ (4,4,\\cos)\\}. $$\n    这对应于 $m=8$ 个未知数。\n  - 候选方位角（单位：度）：\n    $$ \\{15, 45, 75, 105, 135, 165\\}. $$\n  - 候选入射角（单位：度）：\n    $$ \\{10, 20, 30, 40\\}. $$\n  - 阈值：\n    $$ \\kappa_{\\max} = 5 \\times 10^{3}. $$\n- 测试用例 3 (退化的方位角池以测试不可行性)：\n  - 基项与测试用例 2 相同（因此 $m=8$ 个未知数）。\n  - 候选方位角（单位：度）：\n    $$ \\{0, 90, 180, 270\\}. $$\n  - 候选入射角（单位：度）：\n    $$ \\{15, 35\\}. $$\n  - 阈值：\n    $$ \\kappa_{\\max} = 10^{3}. $$\n\n您的程序必须实现上述逻辑，以弧度执行所有三角函数计算，并生成单行输出，其中包含三个测试用例的结果，格式如前所述。不应读取额外的输入。返回类型必须是布尔值或指定的整数和浮点数列表。最终输出行应如下所示：\n- 一个包含三个元素的单个列表，每个元素对应一个测试用例，其中每个元素要么是 false，要么是一个三元素列表，包含最小计数和相应的最小条件数（四舍五入到三位小数）。",
            "solution": "首先对问题陈述进行严格的验证过程，以确保其科学和数学上的完整性。\n\n### 步骤 1：提取给定信息\n\n从问题陈述中逐字提取的给定信息如下：\n- **物理背景**：针对正交各向异性介质中全波形反演 (FWI) 的线性化采集设计，基于一阶玻恩近似。\n- **变量**：入射角 $\\theta$，方位角 $\\phi$。\n- **模型参数**：一个矢量 $\\mathbf{c} \\in \\mathbb{R}^{m}$，表示刚度差异。\n- **基函数**：一组 $m$ 个函数 $\\{b_{k}(\\theta,\\phi)\\}_{k=1}^{m}$，定义为：\n  $$ b_{k}(\\theta,\\phi) = \\left[\\sin(\\theta)\\right]^{p_k} \\cdot t_k\\big(n_k \\phi\\big) $$\n  其中 $p_k \\in \\{0,2,4\\}$，$n_k \\in \\{0,2,4\\}$，$t_k \\in \\{\\cos, \\sin, 1\\}$。对于 $n_k=0$，$t_k(0) \\equiv 1$ (记为 `const`)。\n- **灵敏度矩阵**：一个 $N \\times m$ 的矩阵 $\\mathbf{A}$，其元素为 $A_{\\ell k} = b_{k}(\\theta_{\\ell}, \\phi_{\\ell})$，其中 $N$ 是从选定点对 $(\\theta_{\\ell}, \\phi_{\\ell})$ 获得的测量总数。\n- **任务**：对于每个测试用例，找到字典序最小的数对 $(N_{\\phi}, N_{\\theta})$，分别代表不同方位角和入射角的数量，以实现对 $\\mathbf{c}$ 的稳健恢复。\n- **稳健恢复的约束条件**：\n  1. 测量总数 $N = N_{\\phi} \\cdot N_{\\theta}$ 必须至少为 $m$。\n  2. 灵敏度矩阵 $\\mathbf{A}$ 必须具有列满秩，等于 $m$。秩由大于容差 $\\tau = 10^{-10}$ 的奇异值数量确定。\n  3. 条件数 $\\kappa(\\mathbf{A}) = \\sigma_{\\max} / \\sigma_{\\min}$ 不得超过给定的阈值 $\\kappa_{\\max}$。\n- **优化目标**：\n  1. 首先最小化 $N_{\\phi}$，然后最小化 $N_{\\theta}$。\n  2. 如果多个子集产生相同的最小 $(N_{\\phi}, N_{\\theta})$，选择条件数最小的那个，记为 $\\kappa_{\\star}$。\n- **输出格式**：如果存在解，输出列表 $[N_{\\phi}, N_{\\theta}, \\kappa_{\\star}]$，其中 $\\kappa_{\\star}$ 四舍五入到三位小数。如果不存在解，输出布尔值 `false`。所有三角函数计算必须使用弧度。\n- **测试用例**：\n  - **案例 1**：$m=5$；基：$\\{(2,0,\\mathrm{const}),\\ (2,2,\\cos),\\ (2,2,\\sin),\\ (2,4,\\cos),\\ (2,4,\\sin)\\}$；候选 $\\phi$ (度): $\\{10, 40, 70, 100, 130, 160\\}$；候选 $\\theta$ (度): $\\{15, 30, 45\\}$；$\\kappa_{\\max} = 10^{3}$。\n  - **案例 2**：$m=8$；基：$\\{(2,0,\\mathrm{const}),\\ (2,2,\\cos),\\ (2,2,\\sin),\\ (2,4,\\cos),\\ (4,0,\\mathrm{const}),\\ (4,2,\\cos),\\ (4,2,\\sin),\\ (4,4,\\cos)\\}$；候选 $\\phi$ (度): $\\{15, 45, 75, 105, 135, 165\\}$；候选 $\\theta$ (度): $\\{10, 20, 30, 40\\}$；$\\kappa_{\\max} = 5 \\times 10^{3}$。\n  - **案例 3**：$m=8$；基与案例 2 相同；候选 $\\phi$ (度): $\\{0, 90, 180, 270\\}$；候选 $\\theta$ (度): $\\{15, 35\\}$；$\\kappa_{\\max} = 10^{3}$。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n根据指定标准对问题进行评估：\n- **科学依据充分**：该问题在计算地球物理学中有充分的依据。使用基函数表示方位变化的反射率、通过灵敏度矩阵构建线性反演问题，以及使用条件数分析进行采集设计，这些都是地震勘探和反演理论中的标准且成熟的做法。参数化与正交各向异性的近似（例如，与 Rüger 的工作相关）是一致的。\n- **适定性**：该问题是适定的。它定义了一个清晰的目标（字典序最小化 $(N_{\\phi}, N_{\\theta})$）和一组精确、可验证的约束条件（秩、条件数、测量次数）。搜索空间是有限的（给定候选角度和方位角的所有子集），这确保了优化过程要么能找到一个解，要么能证明解不存在。\n- **客观性**：该问题以客观、定量的术语陈述，没有任何模糊性或主观论断。所有参数、约束和目标都得到了正式定义。\n\n该问题没有表现出任何列出的缺陷（例如，科学上不健全、不完整、矛盾或含糊不清）。它提出了一个植根于有效科学原理的非平凡计算任务。\n\n### 步骤 3：结论与行动\n\n问题是**有效的**。将提供一个解决方案。\n\n### 基于原则的解决方案\n\n任务是解决一个用于实验设计的离散优化问题。目标是找到确保参数矢量 $\\mathbf{c}$ 能够被稳健确定的最小方位角数 $N_{\\phi}$ 和入射角数 $N_{\\theta}$。稳健性由灵敏度矩阵 $\\mathbf{A}$ 的秩和条件数来量化。\n\n**算法方法**\n问题要求找到字典序最小的数对 $(N_{\\phi}, N_{\\theta})$。这决定了特定的搜索顺序。我们必须从 $1$ 遍历到候选方位角的总数，来迭代 $N_{\\phi}$ 的可能值。对于每个 $N_{\\phi}$，我们再从 $1$ 遍历到候选角度的总数，来迭代 $N_{\\theta}$ 的可能值。根据定义，第一个产生有效设计的数对 $(N_{\\phi}, N_{\\theta})$ 就是字典序最小的。\n\n对于一个固定的数对 $(N_{\\phi}, N_{\\theta})$，我们必须检查是否存在任何来自候选池的 $N_{\\phi}$ 个方位角和 $N_{\\theta}$ 个角度的组合满足给定的约束。这包括以下步骤：\n1.  从候选方位角集合中生成所有包含 $N_{\\phi}$ 个方位角的组合。\n2.  从候选入射角集合中生成所有包含 $N_{\\theta}$ 个入射角的组合。\n3.  对于每个方位角子集和角度子集的配对，构建灵敏度矩阵 $\\mathbf{A}$ 并测试其有效性。\n\n**矩阵构建**\n灵敏度矩阵 $\\mathbf{A}$ 的维度为 $N \\times m$，其中 $N = N_{\\phi} \\cdot N_{\\theta}$，$m$ 是基函数的数量。$\\mathbf{A}$ 的每一行对应一个唯一的测量点对 $(\\theta_i, \\phi_j)$，其中 $\\theta_i$ 是一个选定的入射角，$\\phi_j$ 是一个选定的方位角。每一列对应一个基函数 $b_k(\\theta, \\phi)$。第 $\\ell$ 行、第 $k$ 列的元素是 $A_{\\ell k} = b_k(\\theta_{\\ell}, \\phi_{\\ell})$。在进行三角函数计算前，必须将角度从度转换为弧度。\n基函数 $b_{k}(\\theta, \\phi) = [\\sin(\\theta)]^{p_k} \\cdot t_k(n_k \\phi)$ 的实现方式是，将 $t_k$ 的文本标识符 `const`、`cos` 或 `sin` 映射到相应的数值函数：$f(\\alpha)=1$、$f(\\alpha)=\\cos(\\alpha)$ 或 $f(\\alpha)=\\sin(\\alpha)$。\n\n**稳定性与可逆性分析**\n通过线性系统 $\\mathbf{A}\\mathbf{c} \\approx \\mathbf{r}$ 从数据 $\\mathbf{r}$ 中恢复参数矢量 $\\mathbf{c}$ 的可行性取决于 $\\mathbf{A}$ 的属性。\n1.  **列满秩**：矩阵 $\\mathbf{A}$ 的秩必须为 $m$，才能在最小二乘意义下存在唯一解。我们使用奇异值分解 (SVD) 来确定数值秩。设 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_m$ 为 $\\mathbf{A}$ 的奇异值。秩是大于指定容差 $\\tau = 10^{-10}$ 的奇异值数量。如果此数量为 $m$，则矩阵被视为满秩。这要求 $N = N_{\\phi} \\cdot N_{\\theta} \\ge m$。\n2.  **条件数**：低的条件数确保解对于数据中的噪声是稳定的。条件数为 $\\kappa(\\mathbf{A}) = \\sigma_1 / \\sigma_m$。对于一个有效的设计，我们要求 $\\kappa(\\mathbf{A}) \\le \\kappa_{\\max}$。\n\n**优化与最终选择**\n总体流程如下：\n1.  从 $1$ 到 $|\\Phi_{cand}|$ 循环遍历 $N_{\\phi}$。\n2.  在内层，从 $1$到 $|\\Theta_{cand}|$ 循环遍历 $N_{\\theta}$。\n3.  跳过 $N_{\\phi} \\cdot N_{\\theta}  m$ 的数对 $(N_{\\phi}, N_{\\theta})$。\n4.  对于当前的 $(N_{\\phi}, N_{\\theta})$，为此尺寸初始化一个最小条件数 $\\kappa_{min\\_size} = \\infty$。\n5.  遍历所有 $N_{\\phi}$ 个方位角和 $N_{\\theta}$ 个角度的组合。对于每个组合：\n    a. 构建矩阵 $\\mathbf{A}$。\n    b. 计算其 SVD 并检查是否满秩。\n    c. 如果是满秩，计算条件数 $\\kappa$ 并检查是否 $\\kappa \\le \\kappa_{\\max}$。\n    d. 如果所有条件都满足, 更新 $\\kappa_{min\\_size} = \\min(\\kappa_{min\\_size}, \\kappa)$。\n6.  在检查完当前 $(N_{\\phi}, N_{\\theta})$ 的所有组合后，如果找到了一个有效的设计（即 $\\kappa_{min\\_size}  \\infty$），那么 $(N_{\\phi}, N_{\\theta})$ 就是字典序最小的解。最终结果是 $[N_{\\phi}, N_{\\theta}, \\kappa_{min\\_size}]$。该测试用例的搜索终止。\n7.  如果循环完成仍未找到任何有效设计，则对于给定的候选集，问题是不可行的，结果为 `false`。\n\n这种结构化搜索保证了能根据问题的标准找到最优设计。对于测试用例3，初步分析显示，所选的方位角 $\\{0, 90, 180, 270\\}$ 会导致矩阵 $\\mathbf{A}$ 的列变得线性相关（具体来说，任何涉及 $\\sin(2\\phi)$ 或 $\\sin(4\\phi)$ 的基项都会生成一个零列，而带 $\\cos(4\\phi)$ 的项将与常数项相同），从而无法达到满秩 $m=8$。因此，预期该情况是不可行的。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the acquisition design problem for all test cases.\n    \"\"\"\n    \n    # Define the trigonometric functions based on the string identifiers\n    trig_funcs = {\n        'const': lambda x: np.ones_like(x),\n        'cos': np.cos,\n        'sin': np.sin\n    }\n\n    # Rank determination threshold\n    RANK_TOLERANCE = 1e-10\n\n    test_cases = [\n        {\n            \"basis\": [(2, 0, 'const'), (2, 2, 'cos'), (2, 2, 'sin'), (2, 4, 'cos'), (2, 4, 'sin')],\n            \"phis_deg\": [10, 40, 70, 100, 130, 160],\n            \"thetas_deg\": [15, 30, 45],\n            \"kappa_max\": 1e3\n        },\n        {\n            \"basis\": [(2, 0, 'const'), (2, 2, 'cos'), (2, 2, 'sin'), (2, 4, 'cos'), \n                      (4, 0, 'const'), (4, 2, 'cos'), (4, 2, 'sin'), (4, 4, 'cos')],\n            \"phis_deg\": [15, 45, 75, 105, 135, 165],\n            \"thetas_deg\": [10, 20, 30, 40],\n            \"kappa_max\": 5e3\n        },\n        {\n            \"basis\": [(2, 0, 'const'), (2, 2, 'cos'), (2, 2, 'sin'), (2, 4, 'cos'), \n                      (4, 0, 'const'), (4, 2, 'cos'), (4, 2, 'sin'), (4, 4, 'cos')],\n            \"phis_deg\": [0, 90, 180, 270],\n            \"thetas_deg\": [15, 35],\n            \"kappa_max\": 1e3\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        basis_spec = case[\"basis\"]\n        candidate_phis_rad = np.deg2rad(case[\"phis_deg\"])\n        candidate_thetas_rad = np.deg2rad(case[\"thetas_deg\"])\n        kappa_max = case[\"kappa_max\"]\n        \n        m = len(basis_spec)\n        num_candidate_phis = len(candidate_phis_rad)\n        num_candidate_thetas = len(candidate_thetas_rad)\n\n        best_result_for_case = None\n        found_solution = False\n\n        for n_phi in range(1, num_candidate_phis + 1):\n            for n_theta in range(1, num_candidate_thetas + 1):\n                if n_phi * n_theta  m:\n                    continue\n\n                min_kappa_for_size = float('inf')\n                is_feasible_at_this_size = False\n\n                phi_subsets = itertools.combinations(candidate_phis_rad, n_phi)\n                for phi_subset in phi_subsets:\n                    theta_subsets = itertools.combinations(candidate_thetas_rad, n_theta)\n                    for theta_subset in theta_subsets:\n                        \n                        N = n_phi * n_theta\n                        A = np.zeros((N, m))\n                        \n                        measurement_pairs = list(itertools.product(theta_subset, phi_subset))\n\n                        for k, (p, n, t_str) in enumerate(basis_spec):\n                            t_func = trig_funcs[t_str]\n                            for i, (theta_val, phi_val) in enumerate(measurement_pairs):\n                                angle_factor = np.sin(theta_val)**p\n                                azim_factor = t_func(n * phi_val)\n                                A[i, k] = angle_factor * azim_factor\n                        \n                        try:\n                            s = np.linalg.svd(A, compute_uv=False)\n                        except np.linalg.LinAlgError:\n                            continue\n\n                        # Check for full rank\n                        rank = np.sum(s > RANK_TOLERANCE)\n                        if rank == m:\n                            # Check condition number\n                            # s is sorted, so s[m-1] is the smallest of the first m values.\n                            if s[m - 1] > 0:\n                                kappa = s[0] / s[m - 1]\n                                if kappa = kappa_max:\n                                    is_feasible_at_this_size = True\n                                    if kappa  min_kappa_for_size:\n                                        min_kappa_for_size = kappa\n                \n                if is_feasible_at_this_size:\n                    best_result_for_case = [n_phi, n_theta, min_kappa_for_size]\n                    found_solution = True\n                    break # Minimal n_theta found\n            \n            if found_solution:\n                break # Minimal n_phi found\n\n        if best_result_for_case:\n            all_results.append(best_result_for_case)\n        else:\n            all_results.append(False)\n\n    # Format the final output string exactly as specified\n    formatted_items = []\n    for res in all_results:\n        if isinstance(res, list):\n            # Use f-string formatting to ensure three decimal places\n            formatted_items.append(f\"[{res[0]},{res[1]},{res[2]:.3f}]\")\n        else: # boolean False\n            formatted_items.append(\"false\")\n    \n    final_output = f\"[{','.join(formatted_items)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}