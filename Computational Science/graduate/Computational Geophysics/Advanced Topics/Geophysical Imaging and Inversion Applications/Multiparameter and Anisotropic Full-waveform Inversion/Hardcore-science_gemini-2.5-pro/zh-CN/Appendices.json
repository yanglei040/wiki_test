{
    "hands_on_practices": [
        {
            "introduction": "全波形反演（FWI）的成功依赖于精确的波场模拟器。任何数值格式都会引入误差，其中最常见的误差之一是数值频散。本练习通过对一个简化的各向异性声波方程的有限差分格式进行分析，旨在让您掌握评估和控制数值频散的核心技能。通过推导离散频散关系并确定确保相位误差低于给定阈值的网格间距，您将学会如何在实践中平衡计算成本与模拟精度，这是进行任何有效波形反演工作的基础。",
            "id": "3611622",
            "problem": "考虑在 Thomsen 参数满足 $\\delta = \\epsilon$ 的椭圆各向异性极限下的二维垂直横向各向同性（VTI）。在此极限下，声学准压缩（qP）波场 $u(x,z,t)$ 由常系数各向异性声学波动方程控制\n$$\n\\frac{\\partial^{2} u}{\\partial t^{2}} \\;=\\; v_{x}^{2}\\,\\frac{\\partial^{2} u}{\\partial x^{2}} \\;+\\; v_{z}^{2}\\,\\frac{\\partial^{2} u}{\\partial z^{2}},\n$$\n其中 $v_{z} = v_{P0}$ 是垂向相速度，$v_{x} = v_{P0}\\sqrt{1+2\\epsilon}$ 是水平相速度。该模型被广泛用于为多参数和各向异性全波形反演（FWI）设计波动方程求解器。\n\n你将使用时间和空间上的二阶中心有限差分，在一个间距为 $\\Delta x = \\Delta z = h$ 的均匀方形网格和一个均匀时间步长 $\\Delta t$ 上对此方程进行离散化。设时间步长的选择使该格式达到 Courant–Friedrichs–Lewy (CFL) 稳定性极限。你需要：\n\n1. 将平面波拟设 $u = \\exp\\!\\big(i(k_{x} x + k_{z} z - \\omega t)\\big)$ 代入有限差分格式，推导出离散色散关系。用 $r_{x} = v_{x}\\Delta t/h$、$r_{z} = v_{z}\\Delta t/h$、$\\kappa_{x} = k_{x} h/2$ 和 $\\kappa_{z} = k_{z} h/2$ 表示结果。\n\n2. 使用小波数展开（即 $|\\kappa_{x}| \\ll 1$，$|\\kappa_{z}| \\ll 1$），获得相对相速度误差 $e(\\theta)$ 的主阶表达式，其中传播角 $\\theta \\in [0,\\pi/2]$（弧度）由 $k_{x} = k\\cos\\theta$ 和 $k_{z} = k\\sin\\theta$ 定义，且 $k = \\sqrt{k_{x}^{2}+k_{z}^{2}}$。你的表达式必须明确显示出对 $h$、最大角频率 $\\omega_{\\max}$（等效于最大频率 $f_{\\max} = \\omega_{\\max}/(2\\pi)$）以及各向异性速度 $v_{x}$ 和 $v_{z}$ 的依赖关系。\n\n3. 在二阶有限差分格式中，当 $\\Delta t$ 的选择达到 CFL 极限时，确定最大允许网格间距 $h$，以保证在所有 $\\theta \\in [0,\\pi/2]$ 上的最坏情况相对相速度误差不超过一个预设的容差 $\\tau$。提供一个关于 $f_{\\max}$、$v_{x}$、$v_{z}$ 和 $\\tau$ 的 $h$ 的闭式公式。\n\n最后，考虑以下设计参数\n- $v_{P0} = 2500$ m/s,\n- $\\epsilon = 0.2$ (因此 $\\delta = \\epsilon$),\n- $f_{\\max} = 30$ Hz,\n- 容差 $\\tau = 0.01$,\n并计算最大允许网格间距 $h$ 的数值（以米为单位）。将你的答案四舍五入到四位有效数字。以米为单位表示最终的 $h$。",
            "solution": "我们从常系数各向异性声学波动方程开始\n$$\n\\frac{\\partial^{2} u}{\\partial t^{2}} \\;=\\; v_{x}^{2}\\,\\frac{\\partial^{2} u}{\\partial x^{2}} \\;+\\; v_{z}^{2}\\,\\frac{\\partial^{2} u}{\\partial z^{2}}.\n$$\n对于 $\\delta = \\epsilon$ 的椭圆垂直横向各向同性（VTI），水平和垂向相速度满足 $v_{x} = v_{P0}\\sqrt{1+2\\epsilon}$ 和 $v_{z} = v_{P0}$。\n\n我们在均匀方形网格 $\\Delta x = \\Delta z = h$ 和时间步长 $\\Delta t$ 上，使用时间和空间上的二阶中心差分进行离散化。在网格点 $(i,j)$ 和时间层 $n$ 的有限差分（FD）格式为\n$$\n\\frac{u_{i,j}^{n+1} - 2 u_{i,j}^{n} + u_{i,j}^{n-1}}{\\Delta t^{2}}\n\\;=\\;\nv_{x}^{2}\\,\\frac{u_{i+1,j}^{n} - 2 u_{i,j}^{n} + u_{i-1,j}^{n}}{h^{2}}\n\\;+\\;\nv_{z}^{2}\\,\\frac{u_{i,j+1}^{n} - 2 u_{i,j}^{n} + u_{i,j-1}^{n}}{h^{2}}.\n$$\n\n离散色散关系的推导。将平面波 $u_{i,j}^{n} = \\exp\\!\\big(i(k_{x} i h + k_{z} j h - \\omega n \\Delta t)\\big)$ 代入格式中。标准的代数运算得到\n$$\n\\frac{\\exp(-i\\omega\\Delta t) - 2 + \\exp(i\\omega\\Delta t)}{\\Delta t^{2}}\n\\;=\\;\nv_{x}^{2}\\,\\frac{\\exp(i k_{x} h) - 2 + \\exp(-i k_{x} h)}{h^{2}}\n\\;+\\;\nv_{z}^{2}\\,\\frac{\\exp(i k_{z} h) - 2 + \\exp(-i k_{z} h)}{h^{2}}.\n$$\n使用 $\\exp(i\\phi) - 2 + \\exp(-i\\phi) = -4 \\sin^{2}(\\phi/2)$，我们得到\n$$\n\\frac{-4 \\sin^{2}(\\omega \\Delta t/2)}{\\Delta t^{2}}\n\\;=\\;\nv_{x}^{2}\\,\\frac{-4 \\sin^{2}(k_{x} h/2)}{h^{2}}\n\\;+\\;\nv_{z}^{2}\\,\\frac{-4 \\sin^{2}(k_{z} h/2)}{h^{2}}.\n$$\n消去公因子 $-4$ 并定义 $r_{x} = v_{x}\\Delta t/h$、$r_{z} = v_{z}\\Delta t/h$、$\\kappa_{x} = k_{x} h/2$ 和 $\\kappa_{z} = k_{z} h/2$，离散色散关系为\n$$\n\\sin^{2}\\!\\left(\\frac{\\omega \\Delta t}{2}\\right)\n\\;=\\;\nr_{x}^{2}\\,\\sin^{2}(\\kappa_{x})\n\\;+\\;\nr_{z}^{2}\\,\\sin^{2}(\\kappa_{z}).\n$$\n\n小波数展开和相速度误差。对于小的 $|\\kappa_{x}|,|\\kappa_{z}|$，使用 $\\sin(\\xi) = \\xi - \\xi^{3}/6 + \\mathcal{O}(\\xi^{5})$ 来获得\n$$\n\\sin^{2}\\!\\left(\\frac{\\omega \\Delta t}{2}\\right)\n=\n\\left(\\frac{\\omega \\Delta t}{2}\\right)^{2}\n- \\frac{1}{3}\\left(\\frac{\\omega \\Delta t}{2}\\right)^{4}\n+ \\mathcal{O}\\!\\left((\\omega \\Delta t)^{6}\\right),\n$$\n$$\n\\sin^{2}(\\kappa_{x})\n=\n\\kappa_{x}^{2} - \\frac{\\kappa_{x}^{4}}{3} + \\mathcal{O}(\\kappa_{x}^{6}),\n\\qquad\n\\sin^{2}(\\kappa_{z})\n=\n\\kappa_{z}^{2} - \\frac{\\kappa_{z}^{4}}{3} + \\mathcal{O}(\\kappa_{z}^{6}).\n$$\n设 $k = \\sqrt{k_{x}^{2} + k_{z}^{2}}$ 并通过 $k_{x} = k \\cos\\theta$，$k_{z} = k \\sin\\theta$ 定义传播角 $\\theta$，其中 $\\theta \\in [0,\\pi/2]$。定义\n$$\nA(\\theta) = v_{x}^{2}\\cos^{2}\\theta + v_{z}^{2}\\sin^{2}\\theta,\n\\qquad\nB(\\theta) = v_{x}^{2}\\cos^{4}\\theta + v_{z}^{2}\\sin^{4}\\theta.\n$$\n在展开的色散关系中匹配阶数，得到主阶频率校正\n$$\n\\omega^{2} = k^{2} A(\\theta) + \\delta(\\theta),\n\\qquad\n\\delta(\\theta) \\approx \\frac{\\Delta t^{2}}{12}\\,k^{4} A(\\theta)^{2} - \\frac{h^{2}}{12}\\,k^{4} B(\\theta),\n$$\n其中我们忽略了 $k$ 的高于四阶的项。数值相速度为 $c_{\\mathrm{num}}(\\theta) = \\omega/k$。将 $\\omega = k \\sqrt{A + \\delta/k^{2}}$ 对 $\\delta$ 展开到一阶，得到\n$$\nc_{\\mathrm{num}}(\\theta) \\approx \\sqrt{A(\\theta)}\\left[1 + \\frac{1}{2}\\frac{\\delta(\\theta)}{k^{2}A(\\theta)}\\right].\n$$\n因此，主阶相对相速度误差 $e(\\theta)$ 是\n$$\ne(\\theta) \\equiv \\frac{c_{\\mathrm{num}}(\\theta) - \\sqrt{A(\\theta)}}{\\sqrt{A(\\theta)}}\n\\;\\approx\\;\n\\frac{1}{24}\\,k^{2}\\left[\\Delta t^{2} A(\\theta) - \\frac{h^{2} B(\\theta)}{A(\\theta)}\\right].\n$$\n\nCFL 选择和在所有角度上的最坏情况误差。对于方形网格上的二阶格式，Courant–Friedrichs–Lewy (CFL) 稳定性极限为 $r_{x}^{2} + r_{z}^{2} \\leq 1$，即\n$$\n\\frac{v_{x}^{2}\\Delta t^{2}}{h^{2}} + \\frac{v_{z}^{2}\\Delta t^{2}}{h^{2}} \\;\\leq\\; 1\n\\;\\;\\Rightarrow\\;\\;\n\\Delta t^{2} = \\frac{h^{2}}{v_{x}^{2} + v_{z}^{2}}\n$$\n当达到该边界极限时。将此代入误差表达式得到\n$$\ne(\\theta) \\approx \\frac{1}{24}\\,k^{2} h^{2}\\left[\\frac{A(\\theta)}{v_{x}^{2} + v_{z}^{2}} - \\frac{B(\\theta)}{A(\\theta)}\\right].\n$$\n对于给定的角频率 $\\omega$（或频率 $f$），波数为 $k(\\theta) = \\omega/\\sqrt{A(\\theta)} = 2\\pi f/\\sqrt{A(\\theta)}$。因此，\n$$\ne(\\theta) \\approx \\frac{h^{2}}{24}\\left(\\frac{2\\pi f}{\\sqrt{A(\\theta)}}\\right)^{2}\n\\left[\\frac{A(\\theta)}{v_{x}^{2} + v_{z}^{2}} - \\frac{B(\\theta)}{A(\\theta)}\\right]\n=\n\\frac{h^{2}(2\\pi f)^{2}}{24}\\left[\\frac{1}{v_{x}^{2} + v_{z}^{2}} - \\frac{B(\\theta)}{A(\\theta)^{2}}\\right].\n$$\n定义 $S = v_{x}^{2} + v_{z}^{2}$ 和\n$$\nQ(\\theta) = \\frac{B(\\theta)}{A(\\theta)^{2}}\n=\n\\frac{v_{x}^{2}\\cos^{4}\\theta + v_{z}^{2}\\sin^{4}\\theta}{\\big(v_{x}^{2}\\cos^{2}\\theta + v_{z}^{2}\\sin^{2}\\theta\\big)^{2}}.\n$$\n那么\n$$\ne(\\theta) \\approx \\frac{h^{2}(2\\pi f)^{2}}{24}\\,\\bigg[\\frac{1}{S} - Q(\\theta)\\bigg].\n$$\n为保证在 $f = f_{\\max}$ 时，对所有 $\\theta \\in [0,\\pi/2]$ 都有 $|e(\\theta)| \\le \\tau$，我们需要\n$$\n\\frac{h^{2}(2\\pi f_{\\max})^{2}}{24}\\,\\sup_{\\theta \\in [0,\\pi/2]}\\bigg|\\,\\frac{1}{S} - Q(\\theta)\\,\\bigg| \\;\\le\\; \\tau.\n$$\n剩下需要计算 $D \\equiv \\sup_{\\theta} |\\,1/S - Q(\\theta)\\,|$。用 $u = \\cos^{2}\\theta \\in [0,1]$ 进行参数化，所以\n$$\nA(u) = v_{x}^{2} u + v_{z}^{2} (1-u),\\qquad\nB(u) = v_{x}^{2} u^{2} + v_{z}^{2} (1-u)^{2},\\qquad\nQ(u) = \\frac{B(u)}{A(u)^{2}}.\n$$\n一个直接的导数测试表明，$Q(u)$ 在 $u = 1/2$ 处有一个唯一的内部临界点，其值为\n$$\nQ\\!\\left(\\tfrac{1}{2}\\right) = \\frac{1}{v_{x}^{2} + v_{z}^{2}} = \\frac{1}{S},\n$$\n且端点值为 $Q(0) = 1/v_{z}^{2}$ 和 $Q(1) = 1/v_{x}^{2}$。因此，\n$$\n\\inf_{\\theta} Q(\\theta) = \\frac{1}{S},\n\\qquad\n\\sup_{\\theta} Q(\\theta) = \\frac{1}{\\min(v_{x}^{2},v_{z}^{2})}.\n$$\n假设 $v_{x} \\ge v_{z}$（对于正 $\\epsilon$ 而言这是典型情况），我们有 $\\sup_{\\theta} Q(\\theta) = 1/v_{z}^{2}$。因此\n$$\n\\sup_{\\theta}\\bigg|\\,\\frac{1}{S} - Q(\\theta)\\,\\bigg|\n=\n\\max\\!\\left(\\frac{1}{S} - \\frac{1}{S},\\,\\frac{1}{v_{z}^{2}} - \\frac{1}{S}\\right)\n=\n\\frac{v_{x}^{2}}{v_{z}^{2}\\,S}.\n$$\n因此，最坏情况的界在 $\\theta = \\pi/2$（垂向传播）时达到，满足对所有 $\\theta$ 都有 $|e(\\theta)| \\le \\tau$ 的最大允许网格间距为\n$$\nh_{\\max}\n=\n\\sqrt{\\frac{24\\,\\tau}{(2\\pi f_{\\max})^{2}}\\,\\frac{1}{D}}\n=\n\\sqrt{\\frac{24\\,\\tau}{(2\\pi f_{\\max})^{2}}\\,\\frac{v_{z}^{2}\\,S}{v_{x}^{2}}}\n=\n\\sqrt{\\frac{24\\,\\tau\\,v_{z}^{2}\\,(v_{x}^{2}+v_{z}^{2})}{(2\\pi f_{\\max})^{2}\\,v_{x}^{2}}}.\n$$\n\n数值计算。根据给定值 $v_{P0} = 2500$ m/s，$\\epsilon = 0.2$（所以 $\\delta=\\epsilon$），我们有\n$$\nv_{z} = v_{P0} = 2500,\\qquad\nv_{x} = v_{P0}\\sqrt{1+2\\epsilon} = 2500\\,\\sqrt{1.4},\n$$\n所以\n$$\nv_{z}^{2} = 6.25\\times 10^{6},\\qquad\nv_{x}^{2} = 1.4\\,v_{z}^{2} = 8.75\\times 10^{6},\\qquad\nS = v_{x}^{2} + v_{z}^{2} = 1.5\\times 10^{7}.\n$$\n当 $f_{\\max} = 30$ 且 $\\tau = 0.01$ 时，我们得到\n$$\nh_{\\max}\n=\n\\sqrt{\\frac{24\\,(0.01)\\,(6.25\\times 10^{6})\\,(1.5\\times 10^{7})}{\\big(2\\pi\\cdot 30\\big)^{2}\\,(8.75\\times 10^{6})}}\n=\n\\sqrt{\\frac{24\\,(0.01)\\,v_{z}^{2}\\,S}{(2\\pi f_{\\max})^{2}\\,v_{x}^{2}}}.\n$$\n计算平方根内的无量纲因子：\n$$\n\\frac{24\\,(0.01)}{(2\\pi\\cdot 30)^{2}}\\cdot \\frac{v_{z}^{2}\\,S}{v_{x}^{2}}\n=\n\\frac{0.24}{3600\\pi^{2}}\\cdot \\frac{(6.25\\times 10^{6})(1.5\\times 10^{7})}{8.75\\times 10^{6}}\n=\n\\frac{0.24}{3600\\pi^{2}}\\cdot \\frac{9.375\\times 10^{13}}{8.75\\times 10^{6}}\n=\n\\frac{0.24}{3600\\pi^{2}}\\cdot 1.071428571\\times 10^{7}.\n$$\n等效地，使用前面推导的简洁表达式，\n$$\nh_{\\max}\n=\n\\sqrt{\\frac{24\\,\\tau}{(2\\pi f_{\\max})^{2}\\,D}}\n,\\quad\nD = \\frac{v_{x}^{2}}{v_{z}^{2}\\,S}\n=\n\\frac{8.75\\times 10^{6}}{(6.25\\times 10^{6})(1.5\\times 10^{7})}\n=\n9.333333333\\times 10^{-8}.\n$$\n因此\n$$\nh_{\\max} = \\sqrt{\\frac{0.24}{(2\\pi\\cdot 30)^{2}\\,(9.333333333\\times 10^{-8})}}\n=\n\\sqrt{\\frac{0.24}{3600\\pi^{2}\\cdot 9.333333333\\times 10^{-8}}}\n\\approx \\sqrt{72.372274}\n\\approx 8.507.\n$$\n四舍五入到四位有效数字并以米表示，最大允许网格间距为 $8.507$ m。",
            "answer": "$$\\boxed{8.507}$$"
        },
        {
            "introduction": "在能够精确模拟波场之后，反演的下一步是理解数据（如此处的走时）对模型参数变化的敏感程度。本练习将您引入多参数反演的核心挑战——参数串扰，即不同参数变化对数据产生相似影响的现象。通过对一个简化的VTI介质模型进行线性化灵敏度分析，您将推导走时残差对各向异性参数 $\\delta$ 和检波器深度误差的敏感度核函数。这项实践使您能够直观地理解参数权衡的来源，并为设计能够区分不同参数影响的反演策略奠定基础。",
            "id": "3611639",
            "problem": "考虑一个二维、均匀、具有弱各向异性的垂直横向各向同性 (VTI) 声学介质，其中单个震源位于深度 $z_s$ 处，一组检波器位于深度 $z_r$ 处。假设该介质具有背景各向同性P波速度 $v_0$ 和单个Thomsen各向异性参数 $\\delta$ (delta)。在高频（基于射线的）近似下，震源和检波器之间的相位到时 $t$ 由慢度沿射线路径的线积分给出。对于直射线运动学下的均匀介质，走时简化为由角度相关的相速度进行的路径长度缩放。\n\n在VTI介质中，对P波相速度使用弱各向异性近似，\n$$\nv(\\theta,\\delta) \\approx v_0 \\left(1 + A(\\theta)\\,\\delta\\right),\n$$\n其中 $\\theta$ 是射线与对称轴（垂直方向）之间的夹角，且\n$$\nA(\\theta) = \\sin^2\\theta\\,\\cos^2\\theta = \\tfrac{1}{4}\\sin^2(2\\theta).\n$$\n设水平源-检波器偏移距为 $x \\ge 0$，并记 $\\Delta x = x_r - x_s$ 和 $\\Delta z = z_r - z_s$。直线路径长度为\n$$\n\\ell = \\sqrt{(\\Delta x)^2 + (\\Delta z)^2},\n$$\n且相对于垂直方向的角度为\n$$\n\\theta = \\arctan2\\left(|\\Delta x|,|\\Delta z|\\right).\n$$\n模型走时为\n$$\nt_{\\text{model}} = \\frac{\\ell_{\\text{model}}}{v(\\theta_{\\text{model}},\\delta_{\\text{model}})} = \\frac{\\ell_{\\text{model}}}{v_0\\left(1 + A(\\theta_{\\text{model}})\\,\\delta_{\\text{model}}\\right)}.\n$$\n真实走时为\n$$\nt_{\\text{true}} = \\frac{\\ell_{\\text{true}}}{v(\\theta_{\\text{true}},\\delta_{\\text{true}})} = \\frac{\\ell_{\\text{true}}}{v_0\\left(1 + A(\\theta_{\\text{true}})\\,\\delta_{\\text{true}}\\right)},\n$$\n其中，真实的检波器深度包含一个几何误差 $\\Delta z_r$，使得 $z_{r,\\text{true}} = z_{r,\\text{model}} + \\Delta z_r$，而震源深度假定为已知且固定。可测量的相位残差为\n$$\n\\Delta t(x) = t_{\\text{true}}(x) - t_{\\text{model}}(x).\n$$\n\n任务是执行线性化灵敏度分析，将小的相位残差 $\\Delta t(x)$ 归因于各向异性与几何中的误差。具体来说，将残差在模型参数周围线性化，并表示为\n$$\n\\Delta t(x) \\approx K_\\delta(x)\\,\\Delta\\delta + K_{\\text{geo}}(x)\\,\\Delta z_r,\n$$\n其中 $\\Delta\\delta = \\delta_{\\text{true}} - \\delta_{\\text{model}}$，$\\Delta z_r$ 是检波器深度误差。基于以上定义和链式法则推导灵敏度核 $K_\\delta(x)$ 和 $K_{\\text{geo}}(x)$ 的表达式：\n- 各向异性核 $K_\\delta(x) = \\frac{\\partial t}{\\partial \\delta}\\big|_{\\text{model}}$ 必须从 $v(\\theta,\\delta)$ 对 $\\delta$ 的显式依赖关系中推导得出。\n- 几何核 $K_{\\text{geo}}(x) = \\frac{\\partial t}{\\partial z_r}\\big|_{\\text{model}}$ 必须既包括通过 $\\ell$ 的路径长度灵敏度，又包括通过 $\\theta$ 的各向异性引起的角度灵敏度。您必须考虑以下导数\n$$\n\\frac{\\partial \\ell}{\\partial z_r} = \\frac{\\Delta z}{\\ell}, \\quad \\frac{\\partial \\theta}{\\partial z_r} = -\\frac{\\Delta x}{(\\Delta x)^2 + (\\Delta z)^2}, \\quad \\frac{\\partial A}{\\partial \\theta} = \\tfrac{1}{2}\\sin(4\\theta).\n$$\n角度使用弧度制。\n\n实现一个程序，该程序：\n1. 对于一组给定的偏移距 $x$，根据模型参数计算模型核 $K_\\delta(x)$ 和 $K_{\\text{geo}}(x)$。\n2. 使用真实参数 $(\\delta_{\\text{true}}, z_{r,\\text{true}})$ 和模型参数 $(\\delta_{\\text{model}}, z_{r,\\text{model}})$ 生成合成的“测量”相位残差 $\\Delta t(x)$。\n3. 使用由核和残差构成的线性系统，求解 $(\\Delta\\delta, \\Delta z_r)$ 的最小二乘估计。\n4. 对每个测试用例，报告估计的各向异性误差 $\\Delta\\delta$（无量纲）、估计的检波器深度误差 $\\Delta z_r$（单位为米）以及测量残差与线性化重建之间的均方根残差（单位为秒）。\n\n所有距离单位必须为米，速度单位为米/秒，时间单位为秒，角度单位为弧度。所有输出均以指定单位和小数形式表示。\n\n测试套件：\n- 案例A（一般“顺利”路径）：$v_0 = 3000$, $z_s = 0$, $z_{r,\\text{model}} = 1500$, $\\delta_{\\text{model}} = 0.07$, $\\delta_{\\text{true}} = 0.08$, $\\Delta z_{r,\\text{true}} = 4$, 偏移距 $x \\in \\{200, 800, 1400, 2000\\}$。\n- 案例B（仅几何误差）：$v_0 = 3000$, $z_s = 0$, $z_{r,\\text{model}} = 1200$, $\\delta_{\\text{model}} = 0.06$, $\\delta_{\\text{true}} = 0.06$, $\\Delta z_{r,\\text{true}} = 10$, 偏移距 $x \\in \\{0, 500, 1000, 2000\\}$。\n- 案例C（仅各向异性误差）：$v_0 = 2800$, $z_s = 0$, $z_{r,\\text{model}} = 1800$, $\\delta_{\\text{model}} = 0.05$, $\\delta_{\\text{true}} = 0.03$, $\\Delta z_{r,\\text{true}} = 0$, 偏移距 $x \\in \\{300, 900, 1500, 2100\\}$。\n- 案例D（边缘情况覆盖：近垂直和近水平混合）：$v_0 = 3200$, $z_s = 0$, $z_{r,\\text{model}} = 1000$, $\\delta_{\\text{model}} = 0.05$, $\\delta_{\\text{true}} = 0.06$, $\\Delta z_{r,\\text{true}} = -5$, 偏移距 $x \\in \\{0, 100, 1000, 4000\\}$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果，每个测试用例对应一个形式为 $[\\Delta\\delta_{\\text{est}}, \\Delta z_{r,\\text{est}}, \\text{rms}]$ 的内部列表。例如，输出格式必须与 $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]]$ 完全一致，其中均方根残差值以秒为单位的小数表示，几何估计值以米为单位的小数表示。",
            "solution": "目标是为线性化的走时残差方程寻找灵敏度核 $K_\\delta(x)$ 和 $K_{\\text{geo}}(x)$：\n$$\n\\Delta t(x) \\approx K_\\delta(x)\\,\\Delta\\delta + K_{\\text{geo}}(x)\\,\\Delta z_r\n$$\n该方程表示走时 $t$ 关于参数 $\\delta$ 和 $z_r$ 在背景模型状态 $(\\delta_{\\text{model}}, z_{r, \\text{model}})$ 附近的一阶泰勒展开。这些核是在此模型状态下评估的走时偏导数。\n\n走时 $t$ 由下式给出：\n$$\nt(\\ell, \\theta, \\delta) = \\frac{\\ell}{v(\\theta, \\delta)} = \\frac{\\ell}{v_0(1 + A(\\theta)\\delta)}\n$$\n其中 $\\ell = \\sqrt{(\\Delta x)^2 + (\\Delta z)^2}$ 和 $\\theta = \\arctan2(|\\Delta x|, |\\Delta z|)$ 是检波器深度 $z_r$ 的函数（因为 $\\Delta z = z_r - z_s$），且 $A(\\theta) = \\sin^2\\theta\\cos^2\\theta$。以下推导中的所有量都在模型状态下进行评估，因此为简洁起见，在最终表达式之前我们省略“model”下标。\n\n**1. 各向异性核 $K_\\delta(x)$ 的推导**\n\n各向异性核是走时相对于Thomsen参数 $\\delta$ 的偏导数。\n$$\nK_\\delta(x) = \\frac{\\partial t}{\\partial \\delta} = \\frac{\\partial}{\\partial \\delta} \\left[ \\frac{\\ell}{v_0(1 + A(\\theta)\\delta)} \\right]\n$$\n将 $\\ell$、$\\theta$ 和 $v_0$ 视为关于 $\\delta$ 的常数，我们应用链式法则：\n$$\n\\frac{\\partial t}{\\partial \\delta} = \\frac{\\ell}{v_0} \\cdot \\frac{\\partial}{\\partial \\delta} \\left( (1 + A(\\theta)\\delta)^{-1} \\right) = \\frac{\\ell}{v_0} \\left[ -1 \\cdot (1 + A(\\theta)\\delta)^{-2} \\cdot A(\\theta) \\right]\n$$\n$$\n\\frac{\\partial t}{\\partial \\delta} = -\\frac{\\ell A(\\theta)}{v_0(1 + A(\\theta)\\delta)^2}\n$$\n这个表达式可以方便地用模型走时 $t_{\\text{model}} = \\frac{\\ell_{\\text{model}}}{v_0(1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}})}$ 来表示。\n$$\nK_\\delta(x) = -\\left( \\frac{\\ell_{\\text{model}}}{v_0(1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}})} \\right) \\frac{A(\\theta_{\\text{model}})}{1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}}}\n$$\n因此，各向异性核的最终表达式为：\n$$\nK_\\delta(x) = -\\frac{t_{\\text{model}} A(\\theta_{\\text{model}})}{1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}}}\n$$\n\n**2. 几何核 $K_{\\text{geo}}(x)$ 的推导**\n\n几何核是走时相对于检波器深度 $z_r$ 的偏导数。走时 $t$ 通过路径长度 $\\ell$ 和角度 $\\theta$ 两者依赖于 $z_r$。我们必须使用链式法则。\n$$\nK_{\\text{geo}}(x) = \\frac{\\partial t}{\\partial z_r} = \\frac{\\partial}{\\partial z_r} \\left( \\frac{\\ell}{v} \\right)\n$$\n使用商法则：\n$$\n\\frac{\\partial t}{\\partial z_r} = \\frac{1}{v} \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\ell}{v^2} \\frac{\\partial v}{\\partial z_r}\n$$\n速度 $v$ 相对于 $z_r$ 的导数也通过链式法则求得，因为 $v$ 通过 $\\theta$ 依赖于 $z_r$：\n$$\n\\frac{\\partial v}{\\partial z_r} = \\frac{\\partial v}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r}\n$$\n从 $v = v_0(1 + A(\\theta)\\delta)$，我们有：\n$$\n\\frac{\\partial v}{\\partial \\theta} = v_0 \\delta \\frac{\\partial A}{\\partial \\theta}\n$$\n将此代回得到：\n$$\n\\frac{\\partial v}{\\partial z_r} = v_0 \\delta \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r}\n$$\n现在我们把这个代入 $\\frac{\\partial t}{\\partial z_r}$ 的表达式中：\n$$\n\\frac{\\partial t}{\\partial z_r} = \\frac{1}{v} \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\ell}{v^2} \\left( v_0 \\delta \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r} \\right)\n$$\n代入 $v = v_0(1 + A\\delta)$ 并提出公因子：\n$$\n\\frac{\\partial t}{\\partial z_r} = \\frac{1}{v} \\left( \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\ell v_0 \\delta}{v} \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r} \\right) = \\frac{1}{v} \\left( \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\ell \\delta}{1 + A\\delta} \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r} \\right)\n$$\n用模型走时 $t_{\\text{model}} = \\ell_{\\text{model}}/v_{\\text{model}}$ 来表示：\n$$\nK_{\\text{geo}}(x) = t_{\\text{model}} \\left( \\frac{1}{\\ell_{\\text{model}}} \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\delta_{\\text{model}}}{1 + A\\delta_{\\text{model}}} \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r} \\right) \\Bigg|_{\\text{model}}\n$$\n现在我们代入问题陈述中提供的、在模型参数下评估的显式偏导数：\n- $\\frac{\\partial \\ell}{\\partial z_r} = \\frac{\\Delta z_{\\text{model}}}{\\ell_{\\text{model}}}$\n- $\\frac{\\partial \\theta}{\\partial z_r} = -\\frac{\\Delta x}{(\\Delta x)^2 + (\\Delta z_{\\text{model}})^2} = -\\frac{\\Delta x}{\\ell_{\\text{model}}^2}$\n- $\\frac{\\partial A}{\\partial \\theta} = \\frac{1}{2}\\sin(4\\theta_{\\text{model}})$\n\n将这些代入 $K_{\\text{geo}}(x)$ 的表达式中：\n$$\nK_{\\text{geo}}(x) = t_{\\text{model}} \\left[ \\frac{1}{\\ell_{\\text{model}}} \\left( \\frac{\\Delta z_{\\text{model}}}{\\ell_{\\text{model}}} \\right) - \\frac{\\delta_{\\text{model}}}{1 + A\\delta_{\\text{model}}} \\left( \\frac{1}{2}\\sin(4\\theta_{\\text{model}}) \\right) \\left( -\\frac{\\Delta x}{\\ell_{\\text{model}}^2} \\right) \\right]\n$$\n通过提出因子 $\\frac{1}{\\ell_{\\text{model}}^2}$ 来简化表达式：\n$$\nK_{\\text{geo}}(x) = \\frac{t_{\\text{model}}}{\\ell_{\\text{model}}^2} \\left[ \\Delta z_{\\text{model}} + \\frac{\\delta_{\\text{model}} \\Delta x \\sin(4\\theta_{\\text{model}})}{2(1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}})} \\right]\n$$\n这是几何核的最终表达式。\n\n利用这些推导出的核，我们可以为一组 $N$ 个偏移距 $\\{x_i\\}$ 构建线性系统 $\\mathbf{G} \\mathbf{m} = \\mathbf{d}$：\n$$\n\\begin{pmatrix}\nK_\\delta(x_1) & K_{\\text{geo}}(x_1) \\\\\nK_\\delta(x_2) & K_{\\text{geo}}(x_2) \\\\\n\\vdots & \\vdots \\\\\nK_\\delta(x_N) & K_{\\text{geo}}(x_N)\n\\end{pmatrix}\n\\begin{pmatrix}\n\\Delta\\delta \\\\\n\\Delta z_r\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\Delta t(x_1) \\\\\n\\Delta t(x_2) \\\\\n\\vdots \\\\\n\\Delta t(x_N)\n\\end{pmatrix}\n$$\n该系统使用最小二乘算法求解模型扰动向量 $\\mathbf{m} = [\\Delta\\delta_{\\text{est}}, \\Delta z_{r,\\text{est}}]^T$。测量数据 $\\mathbf{d}$ 和线性化预测 $\\mathbf{G} \\mathbf{m}$ 之间的均方根 (RMS) 残差量化了线性近似的拟合优度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs linearized sensitivity analysis to estimate anisotropy and geometry errors\n    from seismic travel time residuals.\n    \"\"\"\n    test_cases = [\n        # Case A: general \"happy path\"\n        {\n            'v0': 3000.0, 'zs': 0.0, 'zr_model': 1500.0,\n            'delta_model': 0.07, 'delta_true': 0.08, 'dzr_true': 4.0,\n            'offsets': [200.0, 800.0, 1400.0, 2000.0]\n        },\n        # Case B: geometry-only error\n        {\n            'v0': 3000.0, 'zs': 0.0, 'zr_model': 1200.0,\n            'delta_model': 0.06, 'delta_true': 0.06, 'dzr_true': 10.0,\n            'offsets': [0.0, 500.0, 1000.0, 2000.0]\n        },\n        # Case C: anisotropy-only error\n        {\n            'v0': 2800.0, 'zs': 0.0, 'zr_model': 1800.0,\n            'delta_model': 0.05, 'delta_true': 0.03, 'dzr_true': 0.0,\n            'offsets': [300.0, 900.0, 1500.0, 2100.0]\n        },\n        # Case D: edge-case coverage\n        {\n            'v0': 3200.0, 'zs': 0.0, 'zr_model': 1000.0,\n            'delta_model': 0.05, 'delta_true': 0.06, 'dzr_true': -5.0,\n            'offsets': [0.0, 100.0, 1000.0, 4000.0]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        v0 = case['v0']\n        zs = case['zs']\n        zr_model = case['zr_model']\n        delta_model = case['delta_model']\n        delta_true = case['delta_true']\n        dzr_true = case['dzr_true'] \n        offsets = case['offsets']\n\n        dt_measured = []\n        G_matrix_rows = []\n\n        for x in offsets:\n            dx = x\n\n            # Modeled parameters\n            dz_model = zr_model - zs\n            ell_model = np.sqrt(dx**2 + dz_model**2)\n            # Handle zero path length, though unlikely with problem constraints\n            if ell_model == 0:\n                ell_model = 1e-9\n            \n            theta_model = np.arctan2(dx, dz_model)\n            A_model = 0.25 * (np.sin(2 * theta_model)**2)\n            v_model = v0 * (1 + A_model * delta_model)\n            t_model = ell_model / v_model\n\n            # True parameters and \"measured\" data\n            zr_true_val = zr_model + dzr_true\n            dz_true = zr_true_val - zs\n            ell_true = np.sqrt(dx**2 + dz_true**2)\n            if ell_true == 0:\n                ell_true = 1e-9\n\n            theta_true = np.arctan2(dx, dz_true)\n            A_true = 0.25 * (np.sin(2 * theta_true)**2)\n            v_true = v0 * (1 + A_true * delta_true)\n            t_true = ell_true / v_true\n\n            # Measured residual\n            dt = t_true - t_model\n            dt_measured.append(dt)\n\n            # --- Calculate sensitivity kernels at model parameters ---\n            \n            # Anisotropy kernel K_delta\n            K_delta = - (t_model * A_model) / (1 + A_model * delta_model)\n\n            # Geometry kernel K_geo\n            term1 = dz_model\n            term2_num = delta_model * dx * np.sin(4 * theta_model)\n            term2_den = 2 * (1 + A_model * delta_model)\n            \n            K_geo = (t_model / ell_model**2) * (term1 + term2_num / term2_den)\n\n            G_matrix_rows.append([K_delta, K_geo])\n        \n        # Assemble matrices and solve the linear system\n        G = np.array(G_matrix_rows)\n        d = np.array(dt_measured)\n\n        # Solve G * m = d for m = [delta_delta, delta_zr] using least squares\n        m, residuals_sum_sq, _, _ = np.linalg.lstsq(G, d, rcond=None)\n        \n        d_delta_est, d_zr_est = m[0], m[1]\n        \n        # Calculate RMS residual\n        d_recon = G @ m\n        rms_residual = np.sqrt(np.mean((d - d_recon)**2))\n        \n        all_results.append([d_delta_est, d_zr_est, rms_residual])\n\n    # Format output as a string representation of a list of lists.\n    formatted_results = []\n    for res in all_results:\n        formatted_res = f\"[{res[0]},{res[1]},{res[2]}]\"\n        formatted_results.append(formatted_res)\n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在前续练习的基础上，我们现在面临一个更高级的实际问题：如何设计地震采集方案，以最小化参数串扰并稳健地解析多个参数？本练习将带您进入针对正交各向异性介质的采集设计优化问题。您将学习到反演问题的可解性与灵敏度矩阵（雅可比矩阵）的性质（特别是其秩和条件数）直接相关。通过寻找能够产生一个良态灵敏度矩阵的最小化方位角和偏移距覆盖范围，这项实践将抽象的线性代数概念与具体的地球物理采集设计任务联系起来，展示了精心设计的数据采集对于成功实现多参数各向异性FWI至关重要。",
            "id": "3611578",
            "problem": "给定一个正交各向异性介质中全波形反演 (FWI) 的线性化采集设计问题。其物理起点是针对平面界面两侧小物性差异的一阶玻恩近似。在此近似下，散射波场与模型扰动呈线性关系，观测到的方位振幅随偏移距 (AVO) 变化的反射率可以表示为方位谐波的线性组合。正交各向异性对称性意味着平面P波反射率具有方位相关性，该相关性可以表示为一个偶次方位阶数的截断级数。在小物性差异极限和中等入射角条件下，通常采用入射角和方位角的基函数可分离表示。目标是通过确保灵敏度矩阵可逆且良态，来确定稳健地恢复正交各向异性物性差异参数矢量所需的最小方位角和偏移距覆盖。\n\n数学设定：\n- 设入射角为 $\\theta$，方位角为 $\\phi$。\n- 设参数矢量 $\\mathbf{c} \\in \\mathbb{R}^{m}$ 表示投影到一组选定的辐射模式基上的刚度差异的线性组合。在特定点对 $(\\theta,\\phi)$ 处的预测线性化反射率样本是 $\\mathbf{c}$ 的线性函数。\n- 定义一组 $m$ 个基函数 $\\{b_{k}(\\theta,\\phi)\\}_{k=1}^{m}$。每个基函数构造为入射角因子和方位谐波的乘积：\n  $$ b_{k}(\\theta,\\phi) = \\left[\\sin(\\theta)\\right]^{p_k} \\cdot t_k\\big(n_k \\phi\\big), $$\n  其中 $p_k \\in \\{0,2,4\\}$ 是一个整数次幂，$n_k \\in \\{0,2,4\\}$ 是一个方位谐波阶数，$t_k$ 是 $\\{\\cos, \\sin, 1\\}$ 之一，并约定对于常数方位项，$t_k(0) \\equiv 1$。\n- 将在选定点对 $\\{(\\theta_i,\\phi_j)\\}$ 处进行的 $N$ 次测量堆叠成一个数据矢量 $\\mathbf{r} \\in \\mathbb{R}^{N}$，并构造灵敏度（雅可比）矩阵 $\\mathbf{A} \\in \\mathbb{R}^{N \\times m}$，其元素为：\n  $$ A_{\\ell k} = b_{k}(\\theta_{\\ell}, \\phi_{\\ell}), \\quad \\ell=1,\\dots,N, \\ k=1,\\dots,m, $$\n  其中每一行对应一个唯一的采集点对。\n- $\\mathbf{c}$ 的可恢复性要求 $\\mathbf{A}$ 是满列秩的。稳健恢复进一步要求条件数 $\\kappa(\\mathbf{A}) = \\sigma_{\\max} / \\sigma_{\\min}$ 低于指定的阈值 $\\kappa_{\\max}$，其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 分别是 $\\mathbf{A}$ 的最大和最小奇异值。\n\n任务：\n- 对于下方的每个测试用例，您将获得：\n  1. 一组候选方位角 $\\{\\phi\\}$（单位：度）。\n  2. 一组候选入射角 $\\{\\theta\\}$（单位：度）。\n  3. 一个基的规约，即定义 $b_k(\\theta,\\phi)$ 的元组 $(p_k, n_k, t_k)$ 列表。\n  4. 一个条件数阈值 $\\kappa_{\\max}$。\n- 您的程序必须搜索候选方位角和候选入射角的所有子集，以找到字典序最小的对 $(N_{\\phi}, N_{\\theta})$（首先最小化 $N_{\\phi}$，然后最小化 $N_{\\theta}$），使得存在一个包含 $N_{\\phi}$ 个不同方位角和 $N_{\\theta}$ 个不同入射角的选择，满足以下条件：\n  1. 产生的设计矩阵 $\\mathbf{A}$ 具有满列秩 $m$。\n  2. 条件数满足 $\\kappa(\\mathbf{A}) \\le \\kappa_{\\max}$。\n  3. 总测量次数 $N = N_{\\phi} \\cdot N_{\\theta}$ 至少为 $m$。\n- 如果多个子集达到了相同的最小 $(N_{\\phi}, N_{\\theta})$，选择条件数最小的那个。\n- 如果不存在可行的子集，则对该测试用例输出布尔值 false。\n- 角度以度为单位提供；所有三角函数计算必须在弧度下进行。最终答案中除了角度外没有物理单位，最终输出是无量纲的。\n- 如果大于 $\\tau$ 的奇异值数量等于 $m$，则将 $\\mathbf{A}$ 视为满秩，其中：\n  $$ \\tau = 10^{-10}. $$\n\n输出格式：\n- 对每个测试用例，如果不可行则输出布尔值 false，否则输出一个列表 $[N_{\\phi}, N_{\\theta}, \\kappa_{\\star}]$，其中 $\\kappa_{\\star}$ 是在所有最小覆盖解中实现的最小条件数，四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表。例如，三个测试用例的输出可能如下所示：\n  $$ [[3,2,12.345],[4,1,8.765],false] $$\n\n测试套件：\n- 测试用例1（单角度阶数组，五项方位谐波）：\n  - 基项 $\\{(p_k, n_k, t_k)\\}_{k=1}^{5}$：\n    $$ \\{(2,0,\\mathrm{const}),\\ (2,2,\\cos),\\ (2,2,\\sin),\\ (2,4,\\cos),\\ (2,4,\\sin)\\}. $$\n    这对应于 $m=5$ 个未知数。\n  - 候选方位角（单位：度）：\n    $$ \\{10, 40, 70, 100, 130, 160\\}. $$\n  - 候选入射角（单位：度）：\n    $$ \\{15, 30, 45\\}. $$\n  - 阈值：\n    $$ \\kappa_{\\max} = 10^{3}. $$\n- 测试用例2（双角度阶数组，四项方位谐波）：\n  - 基项 $\\{(p_k, n_k, t_k)\\}_{k=1}^{8}$：\n    $$ \\{(2,0,\\mathrm{const}),\\ (2,2,\\cos),\\ (2,2,\\sin),\\ (2,4,\\cos),\\ (4,0,\\mathrm{const}),\\ (4,2,\\cos),\\ (4,2,\\sin),\\ (4,4,\\cos)\\}. $$\n    这对应于 $m=8$ 个未知数。\n  - 候选方位角（单位：度）：\n    $$ \\{15, 45, 75, 105, 135, 165\\}. $$\n  - 候选入射角（单位：度）：\n    $$ \\{10, 20, 30, 40\\}. $$\n  - 阈值：\n    $$ \\kappa_{\\max} = 5 \\times 10^{3}. $$\n- 测试用例3（用于测试不可行性的退化方位角池）：\n  - 基项与测试用例2相同（因此 $m=8$ 个未知数）。\n  - 候选方位角（单位：度）：\n    $$ \\{0, 90, 180, 270\\}. $$\n  - 候选入射角（单位：度）：\n    $$ \\{15, 35\\}. $$\n  - 阈值：\n    $$ \\kappa_{\\max} = 10^{3}. $$\n\n您的程序必须实现上述逻辑，以弧度执行所有三角函数计算，并生成单行输出，其中包含三个测试用例的结果，格式为前面描述的列表。不应读取任何额外输入。返回类型必须是布尔值或指定的整数和浮点数列表。最终输出行应如下所示：\n- 一个包含三个元素的列表，每个元素对应一个测试用例，其中每个元素要么是 false，要么是一个包含最小计数和相应最小条件数（四舍五入到三位小数）的三元素列表。",
            "solution": "该问题是一个离散优化问题，目标是寻找字典序最小的采集组合（即最小化方位角数量 $N_{\\phi}$，其次最小化入射角数量 $N_{\\theta}$），使得灵敏度矩阵 $\\mathbf{A}$ 满足稳健反演的条件。\n\n解题思路如下：\n1.  **系统性搜索**：按照字典序，从 $N_{\\phi}=1$ 开始，依次遍历所有可能的方位角数量。对于每个 $N_{\\phi}$，再从 $N_{\\theta}=1$ 开始遍历所有可能的入射角数量。\n2.  **组合生成**：对于每一对 $(N_{\\phi}, N_{\\theta})$，首先检查是否满足基本要求 $N_{\\phi} \\cdot N_{\\theta} \\ge m$（$m$ 为参数数量）。然后，生成所有从候选池中选取 $N_{\\phi}$ 个方位角和 $N_{\\theta}$ 个入射角的组合。\n3.  **矩阵构建与验证**：对于每一个角度和方位角的具体组合：\n    a.  构建 $N \\times m$ 的灵敏度矩阵 $\\mathbf{A}$，其中 $N = N_{\\phi} \\cdot N_{\\theta}$。矩阵的每个元素 $A_{\\ell k}$ 由给定的基函数 $b_k(\\theta_\\ell, \\phi_\\ell)$ 计算得出。注意将角度单位从度转换为弧度。\n    b.  使用奇异值分解（SVD）分析矩阵 $\\mathbf{A}$ 的性质。\n    c.  **秩检验**：计算大于数值容差 $\\tau = 10^{-10}$ 的奇异值数量。如果该数量等于 $m$，则矩阵为满列秩。\n    d.  **条件数检验**：如果矩阵满秩，计算其条件数 $\\kappa(\\mathbf{A}) = \\sigma_{\\max} / \\sigma_{\\min}$，并检验是否满足 $\\kappa(\\mathbf{A}) \\le \\kappa_{\\max}$。\n4.  **最优解选择**：\n    a.  在当前 $(N_{\\phi}, N_{\\theta})$ 尺寸下，如果找到了一个或多个满足所有条件的组合，记录下它们当中实现的最小条件数 $\\kappa_{\\star}$。\n    b.  由于我们是按字典序搜索 $(N_{\\phi}, N_{\\theta})$，第一个发现存在可行解的尺寸 $(N_{\\phi}, N_{\\theta})$ 就是最优尺寸。此时记录下该尺寸和对应的最小条件数 $\\kappa_{\\star}$，并终止搜索。\n5.  **处理不可行情况**：如果遍历所有可能的 $(N_{\\phi}, N_{\\theta})$ 组合后仍未找到可行解，则该问题无解，输出 `false`。\n\n该算法通过穷举搜索保证能找到满足所有约束的、字典序最小的采集方案。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the acquisition design problem for all test cases.\n    \"\"\"\n    \n    # Define the trigonometric functions based on the string identifiers\n    trig_funcs = {\n        'const': lambda x: np.ones_like(x),\n        'cos': np.cos,\n        'sin': np.sin\n    }\n\n    # Rank determination threshold\n    RANK_TOLERANCE = 1e-10\n\n    test_cases = [\n        {\n            \"basis\": [(2, 0, 'const'), (2, 2, 'cos'), (2, 2, 'sin'), (2, 4, 'cos'), (2, 4, 'sin')],\n            \"phis_deg\": [10, 40, 70, 100, 130, 160],\n            \"thetas_deg\": [15, 30, 45],\n            \"kappa_max\": 1e3\n        },\n        {\n            \"basis\": [(2, 0, 'const'), (2, 2, 'cos'), (2, 2, 'sin'), (2, 4, 'cos'), \n                      (4, 0, 'const'), (4, 2, 'cos'), (4, 2, 'sin'), (4, 4, 'cos')],\n            \"phis_deg\": [15, 45, 75, 105, 135, 165],\n            \"thetas_deg\": [10, 20, 30, 40],\n            \"kappa_max\": 5e3\n        },\n        {\n            \"basis\": [(2, 0, 'const'), (2, 2, 'cos'), (2, 2, 'sin'), (2, 4, 'cos'), \n                      (4, 0, 'const'), (4, 2, 'cos'), (4, 2, 'sin'), (4, 4, 'cos')],\n            \"phis_deg\": [0, 90, 180, 270],\n            \"thetas_deg\": [15, 35],\n            \"kappa_max\": 1e3\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        basis_spec = case[\"basis\"]\n        candidate_phis_rad = np.deg2rad(case[\"phis_deg\"])\n        candidate_thetas_rad = np.deg2rad(case[\"thetas_deg\"])\n        kappa_max = case[\"kappa_max\"]\n        \n        m = len(basis_spec)\n        num_candidate_phis = len(candidate_phis_rad)\n        num_candidate_thetas = len(candidate_thetas_rad)\n\n        best_result_for_case = None\n        found_solution = False\n\n        for n_phi in range(1, num_candidate_phis + 1):\n            for n_theta in range(1, num_candidate_thetas + 1):\n                if n_phi * n_theta  m:\n                    continue\n\n                min_kappa_for_size = float('inf')\n                is_feasible_at_this_size = False\n\n                phi_subsets = itertools.combinations(candidate_phis_rad, n_phi)\n                for phi_subset in phi_subsets:\n                    theta_subsets = itertools.combinations(candidate_thetas_rad, n_theta)\n                    for theta_subset in theta_subsets:\n                        \n                        N = n_phi * n_theta\n                        A = np.zeros((N, m))\n                        \n                        measurement_pairs = list(itertools.product(theta_subset, phi_subset))\n\n                        for k, (p, n, t_str) in enumerate(basis_spec):\n                            t_func = trig_funcs[t_str]\n                            for i, (theta_val, phi_val) in enumerate(measurement_pairs):\n                                angle_factor = np.sin(theta_val)**p\n                                azim_factor = t_func(n * phi_val)\n                                A[i, k] = angle_factor * azim_factor\n                        \n                        try:\n                            s = np.linalg.svd(A, compute_uv=False)\n                        except np.linalg.LinAlgError:\n                            continue\n\n                        # Check for full rank\n                        rank = np.sum(s > RANK_TOLERANCE)\n                        if rank == m:\n                            # Check condition number\n                            # s is sorted, so s[m-1] is the smallest of the first m values.\n                            if s[m - 1] > 0:\n                                kappa = s[0] / s[m - 1]\n                                if kappa = kappa_max:\n                                    is_feasible_at_this_size = True\n                                    if kappa  min_kappa_for_size:\n                                        min_kappa_for_size = kappa\n                \n                if is_feasible_at_this_size:\n                    best_result_for_case = [n_phi, n_theta, min_kappa_for_size]\n                    found_solution = True\n                    break # Minimal n_theta found\n            \n            if found_solution:\n                break # Minimal n_phi found\n\n        if best_result_for_case:\n            all_results.append(best_result_for_case)\n        else:\n            all_results.append(False)\n\n    # Format the final output string exactly as specified\n    formatted_items = []\n    for res in all_results:\n        if isinstance(res, list):\n            # Use f-string formatting to ensure three decimal places\n            formatted_items.append(f\"[{res[0]},{res[1]},{res[2]:.3f}]\")\n        else: # boolean False\n            formatted_items.append(\"false\")\n    \n    final_output = f\"[{','.join(formatted_items)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}