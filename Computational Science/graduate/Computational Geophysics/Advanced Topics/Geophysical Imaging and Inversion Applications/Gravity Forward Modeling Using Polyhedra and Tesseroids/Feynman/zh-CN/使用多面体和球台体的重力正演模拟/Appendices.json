{
    "hands_on_practices": [
        {
            "introduction": "编写复杂的数值代码需要严格的验证。第一个实践将演示一种基本的验证技术：我们将用球壳定理这一位场理论的基石，来检验我们的球楔体（tesseroid）模型。通过将一个球楔体在径向上压缩成一个薄球壳，我们可以将数值计算的重力结果与球壳定理的精确解析解进行直接比较，从而建立对我们代码实现的信心 。",
            "id": "3601790",
            "problem": "你需要实现一个完整的、可运行的程序，通过将一个球楔体（tesseroid）径向压缩以近似一个薄球壳，并将其数值计算出的重力加速度与球壳的解析解进行比较，从而验证一种针对该球楔体的重力正演模拟方法。该程序必须通过对牛顿万有引力定律在球楔体的纬度、经度和径向范围上进行体积分的直接数值计算，来计算位于球壳极轴上的观测点的重力加速度径向分量，然后量化其与球壳解析解之间的差异。\n\n请使用以下基本原理作为您的推导和算法的基础：牛顿万有引力定律指出，由密度为 $\\rho(\\mathbf{r}')$ 的质量分布在观测位置 $\\mathbf{r}$ 处产生的重力加速度 $\\mathbf{g}$，由对源坐标 $\\mathbf{r}'$ 的体积分给出。程序必须在球坐标系 $(r',\\theta',\\phi')$ 中实现该积分，其中 $\\theta'$ 是余纬，$\\phi'$ 是经度，并使用适当的雅可比因子。使用高斯求积（高斯-勒让德求积）来近似每个坐标维度上的积分。在整个过程中，请指明并使用国际单位制（SI）。\n\n定义一个在角度上完全覆盖球面，并在径向上受内半径 $R_1$ 和外半径 $R_2$ 界定的球楔体。通过使 $R_2 - R_1$ 变得很小，将球楔体径向压缩，使其近似为一个薄球壳。计算位于极轴（连接原点和北极的线）上的观测点的重力加速度径向分量 $g_r$，并与同心均匀密度球壳的解析解进行比较。您必须将所有重力加速度以 $\\mathrm{m/s^2}$ 表示。\n\n使用的常数和单位：\n- 引力常数 $G = 6.67430\\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$。\n- 密度 $\\rho = 3000\\,\\mathrm{kg/m^3}$。\n- 角度以弧度为单位。\n- 半径和长度以米为单位。\n- 重力加速度以 $\\mathrm{m/s^2}$ 为单位。\n\n解析参考解要求：\n- 使用均匀密度的球对称壳层的精确解析重力加速度来验证数值结果。解析解必须从第一性原理推导，并在您的代码中实现。它必须能正确处理 $r  R_1$、$R_1  r  R_2$ 和 $r > R_2$ 这几种情况。\n\n数值积分要求：\n- 在每个维度上实现高斯-勒让德求积，其中 $\\theta' \\in [0,\\pi]$、$\\phi' \\in [0,2\\pi]$ 和 $r' \\in [R_1,R_2]$ 的阶数 $N_\\theta$、$N_\\phi$ 和 $N_r$ 由用户指定。\n- 观测点位于半径为 $r$ 的极轴上，因此只需要径向分量 $g_r$。\n- 使用球坐标系中的球楔体体元，并将矢量场投影到极轴上以获得 $g_r$。\n\n设计一个包含四个测试用例的测试套件，用以探究收缩为壳层验证的不同方面。对于每个测试用例，报告一个标量差异值，按以下规定进行汇总：\n- 对于解析解大小不为零的情况，报告定义为 $|g_{\\mathrm{num}} - g_{\\mathrm{analytic}}| / |g_{\\mathrm{analytic}}|$ 的相对误差。\n- 对于解析解大小为零的情况，报告绝对误差 $|g_{\\mathrm{num}}|$。\n\n使用以下测试套件参数值：\n- 测试 1（壳层外的常规“理想路径”）：$R_1 = 6.371\\times 10^{6}\\,\\mathrm{m}$，$R_2 = R_1 + 1000\\,\\mathrm{m}$，$\\rho = 3000\\,\\mathrm{kg/m^3}$，观测半径 $r = R_2 + 10^{6}\\,\\mathrm{m}$，求积阶数 $N_\\theta = 64$，$N_\\phi = 64$，$N_r = 4$。\n- 测试 2（壳层更薄且在外部近边界处）：$R_1 = 6.371\\times 10^{6}\\,\\mathrm{m}$，$R_2 = R_1 + 10\\,\\mathrm{m}$，$\\rho = 3000\\,\\mathrm{kg/m^3}$，观测半径 $r = R_2 + 10\\,\\mathrm{m}$，求积阶数 $N_\\theta = 64$，$N_\\phi = 64$，$N_r = 2$。\n- 测试 3（壳层极薄且在内部）：$R_1 = 6.371\\times 10^{6}\\,\\mathrm{m}$，$R_2 = R_1 + 0.1\\,\\mathrm{m}$，$\\rho = 3000\\,\\mathrm{kg/m^3}$，观测半径 $r = R_1 - 10^{6}\\,\\mathrm{m}$，求积阶数 $N_\\theta = 64$，$N_\\phi = 64$，$N_r = 2$。\n- 测试 4（壳层厚度适中，在中等距离的外部）：$R_1 = 10^{6}\\,\\mathrm{m}$，$R_2 = R_1 + 50\\,\\mathrm{m}$，$\\rho = 3000\\,\\mathrm{kg/m^3}$，观测半径 $r = R_2 + 1\\,\\mathrm{m}$，求积阶数 $N_\\theta = 64$，$N_\\phi = 64$，$N_r = 4$。\n\n答案规范：\n- 输出必须是无量纲的差异值（根据上述指示，为相对误差或绝对误差），并以浮点数表示。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如：$\\texttt{[result1,result2,result3,result4]}$。",
            "solution": "我们从牛顿万有引力定律开始。对于位于源位置 $\\mathbf{r}'$ 的质量元和位于测试点 $\\mathbf{r}$ 的情况，微分重力加速度 $d\\mathbf{g}$ 为\n$$\nd\\mathbf{g}(\\mathbf{r}) = - G \\frac{\\rho(\\mathbf{r}')\\, dV' \\, (\\mathbf{r} - \\mathbf{r}')}{\\lVert \\mathbf{r} - \\mathbf{r}' \\rVert^3}.\n$$\n对质量分布进行积分可得\n$$\n\\mathbf{g}(\\mathbf{r}) = - G \\int_{V} \\rho(\\mathbf{r}') \\frac{\\mathbf{r} - \\mathbf{r}'}{\\lVert \\mathbf{r} - \\mathbf{r}' \\rVert^3} \\, dV'.\n$$\n我们在球坐标系 $\\left(r',\\theta',\\phi'\\right)$ 中对球楔体体积进行参数化，其雅可比行列式为 $dV' = r'^2 \\sin\\theta' \\, dr' \\, d\\theta' \\, d\\phi'$。该球楔体在角度上覆盖整个球面，其中 $\\theta' \\in [0,\\pi]$、$\\phi' \\in [0,2\\pi]$，径向上 $r' \\in [R_1,R_2]$。我们将观测点置于极轴上（北极方向），因此在笛卡尔坐标系中 $\\mathbf{r} = (0,0,r)$，径向单位矢量为 $\\hat{\\mathbf{e}}_r = (0,0,1)$。源元的笛卡尔坐标为 $\\mathbf{r}' = \\left(r' \\sin\\theta' \\cos\\phi',\\, r' \\sin\\theta' \\sin\\phi',\\, r' \\cos\\theta'\\right)$。\n\n被积函数投影到径向方向上变为\n$$\n\\left(\\mathbf{r} - \\mathbf{r}'\\right) \\cdot \\hat{\\mathbf{e}}_r = r - r' \\cos\\theta',\n$$\n且分离范数为\n$$\n\\lVert \\mathbf{r} - \\mathbf{r}' \\rVert = \\sqrt{r^2 + r'^2 - 2 r r' \\cos\\theta'}.\n$$\n因此，重力加速度的径向分量 $g_r$ 为\n$$\ng_r(r) = - G \\rho \\int_{R_1}^{R_2} \\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\frac{r'^2 \\sin\\theta' \\left(r - r' \\cos\\theta'\\right)}{\\left(r^2 + r'^2 - 2 r r' \\cos\\theta'\\right)^{3/2}} \\, d\\phi' \\, d\\theta' \\, dr'.\n$$\n根据对称性，对于极轴上的观测点，被积函数不依赖于 $\\phi'$，因此对 $\\phi'$ 的积分可简化为一个 $2\\pi$ 因子，但为了与类似球楔体的角度离散化保持一致，我们保留了在 $\\phi'$ 上的数值求积。\n\n我们使用高斯求积（高斯-勒让德）来近似每个积分。对于一个区间 $[a,b]$，高斯-勒让德求积提供了从 $[-1,1]$ 映射而来的节点 $\\{x_i\\}$ 和权重 $\\{w_i\\}$：\n$$\nx_i^{[a,b]} = \\frac{b-a}{2} x_i + \\frac{b+a}{2}, \\quad w_i^{[a,b]} = \\frac{b-a}{2} w_i.\n$$\n在 $r'$、$\\theta'$ 和 $\\phi'$ 上应用求积法， $g_r$ 的数值估计值变为\n$$\ng_r^{\\text{num}}(r) = - G \\rho \\sum_{i=1}^{N_r} \\sum_{j=1}^{N_\\theta} \\sum_{k=1}^{N_\\phi}\n\\frac{ \\left(r'^2_i \\sin\\theta'_j \\left(r - r'_i \\cos\\theta'_j\\right)\\right) \\, w^{[R_1,R_2]}_i \\, w^{[0,\\pi]}_j \\, w^{[0,2\\pi]}_k }\n{\\left(r^2 + r'^2_i - 2 r r'_i \\cos\\theta'_j\\right)^{3/2}}.\n$$\n这得出了极轴上的径向分量，单位为 $\\mathrm{m/s^2}$。\n\n对于解析验证，我们使用壳层定理和球对称性。对于内半径为 $R_1$、外半径为 $R_2$ 的均匀密度球对称壳层，其总质量为\n$$\nM = \\frac{4\\pi \\rho}{3} \\left(R_2^3 - R_1^3\\right).\n$$\n重力加速度为：\n- 在壳层外部 ($r > R_2$)，其引力场等同于位于原点的点质量所产生的引力场：\n$$\ng_r^{\\text{analytic}}(r) = - \\frac{G M}{r^2}.\n$$\n- 在空腔内部 ($r  R_1$)，包围的质量为零，因此\n$$\ng_r^{\\text{analytic}}(r) = 0.\n$$\n- 在壳层物质内部 ($R_1  r  R_2$)，只有被半径 $r$ 包围的质量有贡献：\n$$\nM_{\\text{enc}}(r) = \\frac{4\\pi \\rho}{3}\\left(r^3 - R_1^3\\right), \\quad\ng_r^{\\text{analytic}}(r) = - \\frac{G M_{\\text{enc}}(r)}{r^2} = - \\frac{4\\pi G \\rho}{3}\\left(r - \\frac{R_1^3}{r^2}\\right).\n$$\n我们的测试套件选择的观测半径避开了 $r$ 恰好等于壳层边界的奇异情况，并包含了外部和内部区域。\n\n误差度量：\n- 对于 $g_r^{\\text{analytic}} \\neq 0$ 的测试，我们计算相对误差\n$$\n\\epsilon_{\\text{rel}} = \\frac{\\left|g_r^{\\text{num}} - g_r^{\\text{analytic}}\\right|}{\\left|g_r^{\\text{analytic}}\\right|}.\n$$\n- 对于 $g_r^{\\text{analytic}} = 0$ 的测试，我们计算绝对误差\n$$\n\\epsilon_{\\text{abs}} = \\left|g_r^{\\text{num}}\\right|.\n$$\n\n算法设计：\n- 使用勒让德多项式的节点和权重实现高斯-勒让德求积；将它们映射到 $[0,\\pi]$ 用于 $\\theta'$，映射到 $[0,2\\pi]$ 用于 $\\phi'$，以及映射到 $[R_1,R_2]$ 用于 $r'$。\n- 为了计算效率，对 $\\theta'$ 的运算进行矢量化，并对求积权重求和。\n- 使用离散化积分和指定的求积阶数计算 $g_r^{\\text{num}}(r)$。\n- 使用适用于相应区域的壳层定理表达式计算 $g_r^{\\text{analytic}}(r)$。\n- 按指定顺序报告每个测试的差异。\n- 确保所有输入和输出均采用国际单位制（SI），角度以弧度为单位，加速度以 $\\mathrm{m/s^2}$ 为单位。\n\n该方法验证了当球楔体径向收缩时（即 $R_2 - R_1$ 很小），数值积分场在壳层内外均收敛于解析球壳解，从而证明了基于球楔体的正演模拟与经典球形解之间的一致性。",
            "answer": "```python\nimport numpy as np\n\n# Constants in SI units\nG = 6.67430e-11  # m^3 kg^-1 s^-2\n\ndef gauss_legendre_nodes_weights(a, b, n):\n    \"\"\"\n    Return Gauss-Legendre nodes and weights mapped from [-1,1] to [a,b].\n    \"\"\"\n    xi, wi = np.polynomial.legendre.leggauss(n)\n    # Map nodes to [a,b]\n    nodes = 0.5 * (b - a) * xi + 0.5 * (b + a)\n    # Scale weights to [a,b]\n    weights = 0.5 * (b - a) * wi\n    return nodes, weights\n\ndef shell_gravity_radial_numeric(r_obs, R1, R2, rho, n_theta, n_phi, n_r):\n    \"\"\"\n    Compute the radial component of gravitational acceleration at r_obs (on polar axis)\n    due to a spherically symmetric tesseroid (full angular coverage, radial [R1, R2])\n    using Gauss-Legendre quadrature in r', theta', phi'.\n    \"\"\"\n    # Quadrature in r', theta', phi'\n    r_nodes, r_weights = gauss_legendre_nodes_weights(R1, R2, n_r)\n    th_nodes, th_weights = gauss_legendre_nodes_weights(0.0, np.pi, n_theta)\n    ph_nodes, ph_weights = gauss_legendre_nodes_weights(0.0, 2.0*np.pi, n_phi)\n\n    # Precompute angular quantities\n    cos_th = np.cos(th_nodes)\n    sin_th = np.sin(th_nodes)\n\n    # Sum of phi weights for integrand independent of phi at polar axis\n    Wphi = np.sum(ph_weights)\n\n    # Accumulate integral\n    integral_sum = 0.0\n    for ri, wri in zip(r_nodes, r_weights):\n        # Denominator term |r - r'|^3 depends on theta\n        denom = (r_obs**2 + ri**2 - 2.0*r_obs*ri*cos_th)**1.5\n        # Kernel projected onto radial direction\n        kernel = (ri**2) * sin_th * (r_obs - ri * cos_th) / denom\n        # Weighted sum over theta and phi\n        theta_sum = np.sum(th_weights * kernel)\n        integral_sum += wri * Wphi * theta_sum\n\n    # Multiply by constants and sign\n    g_r = -G * rho * integral_sum\n    return g_r  # m/s^2\n\ndef shell_gravity_radial_analytic(r_obs, R1, R2, rho):\n    \"\"\"\n    Analytic radial gravitational acceleration for a spherically symmetric shell.\n    Handles regimes r  R1, R1  r  R2, r > R2.\n    \"\"\"\n    # Total mass of shell\n    M_total = (4.0 * np.pi * rho / 3.0) * (R2**3 - R1**3)\n    if r_obs  R1:\n        return 0.0\n    elif r_obs > R2:\n        return -G * M_total / (r_obs**2)\n    else:\n        # Within shell volume: only enclosed mass contributes\n        M_enc = (4.0 * np.pi * rho / 3.0) * (r_obs**3 - R1**3)\n        return -G * M_enc / (r_obs**2)\n\ndef discrepancy(g_num, g_analytic):\n    \"\"\"\n    Compute discrepancy: relative error if analytic != 0, else absolute error.\n    \"\"\"\n    if g_analytic != 0.0:\n        return abs((g_num - g_analytic) / g_analytic)\n    else:\n        return abs(g_num)\n\ndef solve():\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        # Test 1: happy path outside the shell\n        {\n            \"R1\": 6.371e6,\n            \"R2\": 6.371e6 + 1000.0,\n            \"rho\": 3000.0,\n            \"r_obs\": (6.371e6 + 1000.0) + 1.0e6,\n            \"n_theta\": 64,\n            \"n_phi\": 64,\n            \"n_r\": 4\n        },\n        # Test 2: near-boundary outside with thinner shell\n        {\n            \"R1\": 6.371e6,\n            \"R2\": 6.371e6 + 10.0,\n            \"rho\": 3000.0,\n            \"r_obs\": (6.371e6 + 10.0) + 10.0,\n            \"n_theta\": 64,\n            \"n_phi\": 64,\n            \"n_r\": 2\n        },\n        # Test 3: inside the shell with extremely thin shell\n        {\n            \"R1\": 6.371e6,\n            \"R2\": 6.371e6 + 0.1,\n            \"rho\": 3000.0,\n            \"r_obs\": 6.371e6 - 1.0e6,\n            \"n_theta\": 64,\n            \"n_phi\": 64,\n            \"n_r\": 2\n        },\n        # Test 4: moderately thin shell outside, mid-range distance\n        {\n            \"R1\": 1.0e6,\n            \"R2\": 1.0e6 + 50.0,\n            \"rho\": 3000.0,\n            \"r_obs\": (1.0e6 + 50.0) + 1.0,\n            \"n_theta\": 64,\n            \"n_phi\": 64,\n            \"n_r\": 4\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        R1 = case[\"R1\"]\n        R2 = case[\"R2\"]\n        rho = case[\"rho\"]\n        r_obs = case[\"r_obs\"]\n        n_theta = case[\"n_theta\"]\n        n_phi = case[\"n_phi\"]\n        n_r = case[\"n_r\"]\n\n        g_num = shell_gravity_radial_numeric(r_obs, R1, R2, rho, n_theta, n_phi, n_r)\n        g_ana = shell_gravity_radial_analytic(r_obs, R1, R2, rho)\n        err = discrepancy(g_num, g_ana)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一个正确的算法必须是稳健的，不仅能处理“理想”情景，还必须能应对具有挑战性的边缘情况。本练习专注于测试代码在退化几何（如零体积单元）以及观测点位于源质量边界（重力核函数在此处奇异）时的表现。成功通过这些测试  对于开发可靠、可用于生产的重力正演模拟软件至关重要。",
            "id": "3601751",
            "problem": "您的任务是为两类地球模型（矩形多面体和球楔体）实现并验证一个重力正演建模程序。该实现必须对退化的几何构型以及恰好位于面或边上的观测点具有鲁棒性。您的程序必须是一个完整的、可运行的程序，它能评估一组固定的测试用例，并将结果作为单行输出。\n\n您必须使用的基本原理是牛顿万有引力定律。对于一个密度恒定的物体，由占据区域 $V$、密度为 $\\rho$ 的质量分布在位置矢量为 $\\mathbf{r}_0$ 的观测点产生的引力加速度由以下公式给出\n$$\n\\mathbf{g}(\\mathbf{r}_0) \\;=\\; G \\, \\rho \\int\\!\\!\\!\\int\\!\\!\\!\\int_{V} \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\left\\lVert \\mathbf{r} - \\mathbf{r}_0 \\right\\rVert^{3}} \\, dV,\n$$\n其中 $G$ 是牛顿引力常数，$\\mathbf{r}$ 是源内的位置，而 $dV$ 是体积元。对于一个与笛卡尔坐标轴对齐的矩形棱柱，其边界为 $x \\in [x_{\\min}, x_{\\max}]$，$y \\in [y_{\\min}, y_{\\max}]$ 和 $z \\in [z_{\\min}, z_{\\max}]$，使用笛卡尔体积元 $dV = dx \\, dy \\, dz$。对于一个在球坐标系中由半径 $r \\in [r_1, r_2]$、余纬 $\\theta \\in [\\theta_1, \\theta_2]$（$\\theta = 0$ 在北极）和经度 $\\lambda \\in [\\lambda_1, \\lambda_2]$ 描述的球楔体，使用球坐标体积元 $dV = r^2 \\sin\\theta \\, dr \\, d\\theta \\, d\\lambda$。在所有情况下，取 $G = 6.67430 \\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$，并将引力加速度以 $\\mathrm{m/s^2}$ 表示。\n\n您的实现必须使用稳定且收敛的求积法对体积积分进行数值计算。您必须确保：\n- 如果几何单元的体积为零（例如，任何边界区间的长度为零），则对于任何观测点和有限密度，建模的引力加速度精确为 $\\mathbf{0}$。\n- 如果观测点位于单元的面或边上，建模的引力加速度保持有限。\n- 遵守对称性，因此因对称性而应抵消的分量在数值上应接近于零。\n\n为了使其具体且可测试，请实现两个正演建模程序：\n- 一个用于与笛卡尔坐标轴对齐的矩形棱柱（多面体的一种特例）的程序。该程序必须接受 $(x_{\\min}, x_{\\max}, y_{\\min}, y_{\\max}, z_{\\min}, z_{\\max})$、密度 $\\rho$ 以及观测点坐标 $(x_0, y_0, z_0)$，并且必须返回矢量 $\\mathbf{g}$。\n- 一个用于由 $(r_1, r_2, \\theta_1, \\theta_2, \\lambda_1, \\lambda_2)$ 定义的球楔体、密度 $\\rho$ 以及在球坐标中给出的观测点 $(r_0, \\theta_0, \\lambda_0)$ 的程序。该程序必须返回笛卡尔坐标系中的引力加速度矢量 $\\mathbf{g}$，以及其在观测位置的球坐标分量，即径向分量 $g_r$、余纬分量 $g_\\theta$ 和经度分量 $g_\\lambda$，这些分量是通过将 $\\mathbf{g}$ 投影到局部标准正交基 $\\{\\hat{\\mathbf{e}}_r, \\hat{\\mathbf{e}}_\\theta, \\hat{\\mathbf{e}}_\\lambda\\}$ 上形成的。\n\n角度必须以弧度为单位。所有距离必须以米为单位，密度以 $\\mathrm{kg/m^3}$ 为单位。您的数值积分必须在每个维度上使用至少六阶的高斯求积法，以确保对以下测试有足够的精度。\n\n设计并运行以下测试套件。对于每个案例，计算指定的检查并产生一个布尔值结果。所有与零的比较都必须在数值上进行解释，并使用您选择的严格公差，以反映双精度数值精度和建模信号的量级。\n\n测试套件：\n- 测试 $1$（零体积矩形多面体）：设 $x \\in [0, 1000] \\, \\mathrm{m}$，$y \\in [0, 1000] \\, \\mathrm{m}$，$z \\in [2000, 2000] \\, \\mathrm{m}$，密度 $\\rho = 2670 \\, \\mathrm{kg/m^3}$，观测点 $(x_0, y_0, z_0) = (100, 100, 0) \\, \\mathrm{m}$。预期结果：建模的 $\\mathbf{g}$ 的模等于 $0$（在数值公差范围内），即如果 $\\lVert \\mathbf{g} \\rVert$ 在数值上为零，则返回布尔值 true。\n- 测试 $2$（观测点位于矩形多面体面心）：设 $x \\in [-500, 500] \\, \\mathrm{m}$，$y \\in [-500, 500] \\, \\mathrm{m}$，$z \\in [0, 100] \\, \\mathrm{m}$，密度 $\\rho = 2670 \\, \\mathrm{kg/m^3}$，观测点 $(x_0, y_0, z_0) = (0, 0, 0) \\, \\mathrm{m}$。预期结果：根据对称性，$g_x$ 和 $g_y$ 在数值上为零，而 $g_z$ 是有限且严格为正；如果这些条件全部成立，则返回布尔值 true。\n- 测试 $3$（零体积球楔体）：设 $r \\in [6.371 \\times 10^{6}, 6.371 \\times 10^{6}] \\, \\mathrm{m}$，$\\theta \\in [\\frac{\\pi}{2} - 0.01, \\frac{\\pi}{2} + 0.01] \\, \\mathrm{rad}$，$\\lambda \\in [-0.01, 0.01] \\, \\mathrm{rad}$，密度 $\\rho = 3000 \\, \\mathrm{kg/m^3}$，观测点 $(r_0, \\theta_0, \\lambda_0) = (6.371 \\times 10^{6}, \\frac{\\pi}{2}, 0)$。预期结果：建模的 $\\mathbf{g}$ 的模等于 $0$（在数值公差范围内）；如果 $\\lVert \\mathbf{g} \\rVert$ 在数值上为零，则返回布尔值 true。\n- 测试 $4$（观测点位于球楔体角对称中心的内径向面上）：设 $r \\in [6.371 \\times 10^{6}, 6.371 \\times 10^{6} + 1000] \\, \\mathrm{m}$，$\\theta \\in [\\frac{\\pi}{2} - 0.01, \\frac{\\pi}{2} + 0.01] \\, \\mathrm{rad}$，$\\lambda \\in [-0.01, 0.01] \\, \\mathrm{rad}$，密度 $\\rho = 3000 \\, \\mathrm{kg/m^3}$，观测点 $(r_0, \\theta_0, \\lambda_0) = (6.371 \\times 10^{6}, \\frac{\\pi}{2}, 0)$。预期结果：由于角对称性，切向分量在数值上为零，径向分量 $g_r$ 是有限且严格为正；如果 $g_r > 0$ 并且切向模量 $\\sqrt{g_\\theta^2 + g_\\lambda^2}$ 相对于 $g_r$ 在数值上可以忽略不计，则返回布尔值 true。\n- 测试 $5$（观测点位于矩形多面体的面边上）：使用与测试 $2$ 中相同的矩形多面体，将观测点设置为 $(x_0, y_0, z_0) = (500, 0, 0) \\, \\mathrm{m}$（一个底面的边中点）。预期结果：根据关于平面 $y = 0$ 的对称性，$g_y$ 在数值上为零，$g_z$ 是有限且严格为正；如果这两个条件都成立，则返回布尔值 true。\n\n您的程序必须按顺序计算测试 $1$ 到 $5$ 的布尔值，并生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$。所有角度必须以弧度为单位，所有距离以米为单位。所有引力加速度必须以 $\\mathrm{m/s^2}$ 为单位进行评估和解释。不允许用户输入；所有参数均如上所述，并且必须硬编码在您的程序中。",
            "solution": "支配此问题的基本原理是牛顿万有引力定律。由占据体积 $V$、密度为常数 $\\rho$ 的连续质量分布在观测点 $\\mathbf{r}_0$ 产生的引力加速度矢量 $\\mathbf{g}$ 由以下体积积分给出：\n$$\n\\mathbf{g}(\\mathbf{r}_0) = G \\rho \\int_{V} \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\left\\lVert \\mathbf{r} - \\mathbf{r}_0 \\right\\rVert^{3}} \\, dV\n$$\n其中 $G$ 是引力常数 ($6.67430 \\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$)，$\\mathbf{r}$ 是体积 $V$ 内质量元的位置矢量。这个矢量积分通常通过分别计算每个笛卡尔分量 $(g_x, g_y, g_z)$ 的积分来求解。\n\n对于一些简单的几何形状，该积分可以解析求解，但对于复杂形状或通用算法，则需要使用数值方法。问题指定为此目的使用至少六阶的高斯求积法。高斯求积法通过在积分区间内特定点（节点）上函数值的加权和来近似定积分。一个 $N$ 点格式对于最高 $2N-1$ 次的多项式是精确的。\n\n对于一个箱形域上的三维积分，我们采用乘积法则，创建一个三维的求积点网格和权重的乘积。对于积分 $\\int_{c}^{d}\\int_{a}^{b}\\int_{u}^{v} f(x,y,z) \\,dx\\,dy\\,dz$，其近似值为：\n$$\n\\approx \\frac{v-u}{2}\\frac{b-a}{2}\\frac{d-c}{2} \\sum_{k}\\sum_{j}\\sum_{i} w_i w_j w_k f(x_i, y_j, z_k)\n$$\n其中 $(\\xi_i, w_i)$ 是 $[-1, 1]$ 上的标准高斯求积节点和权重，而 $x_i, y_j, z_k$ 是这些节点映射到它们各自积分区间上的点。\n\n该问题的一个关键方面是积分被积函数中的奇异性，当积分点 $\\mathbf{r}$ 与观测点 $\\mathbf{r}_0$ 重合时，分母为零，奇异性就会出现。虽然积分是收敛的，但在奇异点进行朴素的数值计算将会失败。问题要求对质量模型边界上的观测点进行鲁棒处理。使用偶数个点（例如 $N=6$）的高斯求积法是有利的，因为其节点对称分布，并且不包含区间的端点或中点。对于中心对称的几何形状和观测点，这有助于避免在奇异点进行直接求值。作为一种保障措施，我们的实现将检查一个求值点是否在数值上与观测点重合，如果是，则赋予其零贡献，这反映了在奇异点处无穷小体积的贡献本身也是无穷小的事实。\n\n**第 1 部分：矩形多面体（棱柱）**\n\n对于一个与笛卡尔坐标轴对齐的矩形棱柱，其定义为 $x \\in [x_{\\min}, x_{\\max}]$，$y \\in [y_{\\min}, y_{\\max}]$ 和 $z \\in [z_{\\min}, z_{\\max}]$，体积元为 $dV = dx\\,dy\\,dz$。观测点为 $\\mathbf{r}_0 = (x_0, y_0, z_0)$。加速度的 $x$ 分量，$g_x$，为：\n$$\ng_x(\\mathbf{r}_0) = G \\rho \\int_{z_{\\min}}^{z_{\\max}} \\int_{y_{\\min}}^{y_{\\max}} \\int_{x_{\\min}}^{x_{\\max}} \\frac{x-x_0}{\\left( (x-x_0)^2 + (y-y_0)^2 + (z-z_0)^2 \\right)^{3/2}} \\,dx\\,dy\\,dz\n$$\n$g_y$ 和 $g_z$ 分量是类似的。在每个维度上独立应用一个 $6$ 点高斯求积法。算法首先检查零体积情况（例如，$x_{\\min} = x_{\\max}$），并返回一个零矢量。否则，它将继续进行三重循环的求积求和。\n\n**第 2 部分：球楔体**\n\n球楔体是一个“球形棱柱”，在球坐标系中由半径 $r \\in [r_1, r_2]$、余纬 $\\theta \\in [\\theta_1, \\theta_2]$ 和经度 $\\lambda \\in [\\lambda_1, \\lambda_2]$ 定义。体积元为 $dV = r^2 \\sin\\theta \\,dr\\,d\\theta\\,d\\lambda$。矢量差 $\\mathbf{r} - \\mathbf{r}_0$ 的物理计算在通用坐标系中最为直接。为此，我们使用笛卡尔坐标系。积分点 $\\mathbf{r}(r, \\theta, \\lambda)$ 和观测点 $\\mathbf{r}_0(r_0, \\theta_0, \\lambda_0)$ 都被转换为笛卡尔坐标 $(x,y,z)$：\n$$\nx = r \\sin\\theta \\cos\\lambda, \\quad y = r \\sin\\theta \\sin\\lambda, \\quad z = r \\cos\\theta\n$$\n然后，使用关于 $r, \\theta, \\lambda$ 的三维高斯求积法，对每个笛卡尔加速度分量的积分进行数值计算。例如，$x$ 分量为：\n$$\ng_x(\\mathbf{r}_0) = G \\rho \\int_{r_1}^{r_2} \\int_{\\theta_1}^{\\theta_2} \\int_{\\lambda_1}^{\\lambda_2} \\frac{x(r, \\theta, \\lambda) - x_0}{\\left\\lVert \\mathbf{r}(r, \\theta, \\lambda) - \\mathbf{r}_0 \\right\\rVert^{3}} r^2 \\sin\\theta \\,d\\lambda\\,d\\theta\\,dr\n$$\n在计算出笛卡尔加速度矢量 $\\mathbf{g} = (g_x, g_y, g_z)$ 之后，将其投影到观测点的局部球坐标基矢量 $\\{\\hat{\\mathbf{e}}_r, \\hat{\\mathbf{e}}_\\theta, \\hat{\\mathbf{e}}_\\lambda\\}$ 上，以求得球坐标分量 $(g_r, g_\\theta, g_\\lambda)$。基矢量为：\n$$\n\\hat{\\mathbf{e}}_r = (\\sin\\theta_0 \\cos\\lambda_0, \\sin\\theta_0 \\sin\\lambda_0, \\cos\\theta_0) \\\\\n\\hat{\\mathbf{e}}_\\theta = (\\cos\\theta_0 \\cos\\lambda_0, \\cos\\theta_0 \\sin\\lambda_0, -\\sin\\theta_0) \\\\\n\\hat{\\mathbf{e}}_\\lambda = (-\\sin\\lambda_0, \\cos\\lambda_0, 0)\n$$\n然后，这些分量是 $g_r = \\mathbf{g} \\cdot \\hat{\\mathbf{e}}_r$，$g_\\theta = \\mathbf{g} \\cdot \\hat{\\mathbf{e}}_\\theta$ 和 $g_\\lambda = \\mathbf{g} \\cdot \\hat{\\mathbf{e}}_\\lambda$。\n\n这种双模型实现，通过仔细处理几何、坐标系和数值稳定性，可以验证指定的测试用例，这些用例探测了其在零体积、边界观测和对称性情况下的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for gravity forward modeling.\n    \"\"\"\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    N_QUAD = 6       # Order of Gaussian quadrature\n    ABS_TOL = 1e-15  # Absolute tolerance for checking against zero\n    REL_TOL = 1e-9   # Relative tolerance for symmetry checks\n\n    # Pre-calculate Gaussian quadrature nodes and weights for interval [-1, 1]\n    quad_nodes, quad_weights = roots_legendre(N_QUAD)\n\n    def gravity_polyhedron(bounds, rho, p_obs, n_quad):\n        \"\"\"\n        Calculates gravitational acceleration of a rectangular prism.\n\n        Args:\n            bounds (tuple): (xmin, xmax, ymin, ymax, zmin, zmax) in meters.\n            rho (float): Density in kg/m^3.\n            p_obs (tuple): Observation point (x0, y0, z0) in meters.\n            n_quad (int): Number of quadrature points per dimension.\n\n        Returns:\n            tuple: The gravitational acceleration vector (gx, gy, gz) in m/s^2.\n        \"\"\"\n        xmin, xmax, ymin, ymax, zmin, zmax = bounds\n        x0, y0, z0 = p_obs\n\n        # Zero volume check\n        if abs(xmax - xmin)  ABS_TOL or abs(ymax - ymin)  ABS_TOL or abs(zmax - zmin)  ABS_TOL:\n            return (0.0, 0.0, 0.0)\n\n        # Map nodes and weights to integration intervals\n        x_range, y_range, z_range = xmax - xmin, ymax - ymin, zmax - zmin\n        x_nodes = 0.5 * x_range * quad_nodes + 0.5 * (xmax + xmin)\n        y_nodes = 0.5 * y_range * quad_nodes + 0.5 * (ymax + ymin)\n        z_nodes = 0.5 * z_range * quad_nodes + 0.5 * (zmax + zmin)\n\n        g_vec = np.zeros(3)\n\n        for i in range(n_quad):\n            for j in range(n_quad):\n                for k in range(n_quad):\n                    x, y, z = x_nodes[i], y_nodes[j], z_nodes[k]\n                    \n                    dx, dy, dz = x - x0, y - y0, z - z0\n                    \n                    dist_sq = dx**2 + dy**2 + dz**2\n                    \n                    if dist_sq  ABS_TOL**2:\n                        continue \n                    \n                    inv_dist_cubed = dist_sq**(-1.5)\n                    \n                    w = quad_weights[i] * quad_weights[j] * quad_weights[k]\n                    g_vec[0] += w * dx * inv_dist_cubed\n                    g_vec[1] += w * dy * inv_dist_cubed\n                    g_vec[2] += w * dz * inv_dist_cubed\n        \n        # Scaling factor for integration\n        scale_factor = G * rho * (x_range / 2) * (y_range / 2) * (z_range / 2)\n        g_vec *= scale_factor\n        \n        return tuple(g_vec)\n\n    def sph_to_cart(r, theta, lamb):\n        \"\"\"Converts spherical to Cartesian coordinates.\"\"\"\n        sin_theta = np.sin(theta)\n        return (\n            r * sin_theta * np.cos(lamb),\n            r * sin_theta * np.sin(lamb),\n            r * np.cos(theta)\n        )\n\n    def gravity_tesseroid(bounds, rho, p_obs_sph, n_quad):\n        \"\"\"\n        Calculates gravitational acceleration of a tesseroid.\n        \n        Returns both Cartesian and local spherical components of gravity vector.\n        \"\"\"\n        r1, r2, t1, t2, l1, l2 = bounds\n        r0, t0, l0 = p_obs_sph\n\n        if abs(r2 - r1)  ABS_TOL or abs(t2 - t1)  ABS_TOL or abs(l2 - l1)  ABS_TOL:\n            return ((0.0, 0.0, 0.0), (0.0, 0.0, 0.0))\n\n        x0, y0, z0 = sph_to_cart(r0, t0, l0)\n\n        r_range, t_range, l_range = r2 - r1, t2 - t1, l2 - l1\n        r_nodes = 0.5 * r_range * quad_nodes + 0.5 * (r2 + r1)\n        t_nodes = 0.5 * t_range * quad_nodes + 0.5 * (t2 + t1)\n        l_nodes = 0.5 * l_range * quad_nodes + 0.5 * (l2 + l1)\n\n        g_vec_cart = np.zeros(3)\n\n        for i in range(n_quad):\n            for j in range(n_quad):\n                for k in range(n_quad):\n                    r, theta, lamb = r_nodes[i], t_nodes[j], l_nodes[k]\n                    x, y, z = sph_to_cart(r, theta, lamb)\n                    \n                    dx, dy, dz = x - x0, y - y0, z - z0\n                    dist_sq = dx**2 + dy**2 + dz**2\n                    \n                    if dist_sq  ABS_TOL**2:\n                        continue\n                    \n                    inv_dist_cubed = dist_sq**(-1.5)\n                    vol_element_factor = r**2 * np.sin(theta)\n                    w = quad_weights[i] * quad_weights[j] * quad_weights[k]\n                    \n                    g_vec_cart[0] += w * dx * inv_dist_cubed * vol_element_factor\n                    g_vec_cart[1] += w * dy * inv_dist_cubed * vol_element_factor\n                    g_vec_cart[2] += w * dz * inv_dist_cubed * vol_element_factor\n\n        scale_factor = G * rho * (r_range / 2) * (t_range / 2) * (l_range / 2)\n        g_vec_cart *= scale_factor\n        \n        # Project to spherical components at observation point\n        sin_t0, cos_t0 = np.sin(t0), np.cos(t0)\n        sin_l0, cos_l0 = np.sin(l0), np.cos(l0)\n        \n        e_r = np.array([sin_t0 * cos_l0, sin_t0 * sin_l0, cos_t0])\n        e_theta = np.array([cos_t0 * cos_l0, cos_t0 * sin_l0, -sin_t0])\n        e_lambda = np.array([-sin_l0, cos_l0, 0])\n        \n        g_r = np.dot(g_vec_cart, e_r)\n        g_theta = np.dot(g_vec_cart, e_theta)\n        g_lambda = np.dot(g_vec_cart, e_lambda)\n\n        return tuple(g_vec_cart), (g_r, g_theta, g_lambda)\n\n    results = []\n\n    # Test 1: Zero-volume rectangular polyhedron\n    g = gravity_polyhedron(bounds=(0, 1000, 0, 1000, 2000, 2000), rho=2670, p_obs=(100, 100, 0), n_quad=N_QUAD)\n    norm_g = np.linalg.norm(g)\n    results.append(norm_g  ABS_TOL)\n\n    # Test 2: Observation on a face center of a rectangular polyhedron\n    g = gravity_polyhedron(bounds=(-500, 500, -500, 500, 0, 100), rho=2670, p_obs=(0, 0, 0), n_quad=N_QUAD)\n    gx, gy, gz = g\n    results.append(abs(gx)  ABS_TOL and abs(gy)  ABS_TOL and gz > ABS_TOL)\n\n    # Test 3: Zero-volume tesseroid\n    g_cart, _ = gravity_tesseroid(bounds=(6.371e6, 6.371e6, np.pi/2 - 0.01, np.pi/2 + 0.01, -0.01, 0.01), rho=3000, p_obs_sph=(6.371e6, np.pi/2, 0), n_quad=N_QUAD)\n    norm_g_cart = np.linalg.norm(g_cart)\n    results.append(norm_g_cart  ABS_TOL)\n\n    # Test 4: Observation on an inner radial face at angular symmetry center of a tesseroid\n    _, g_sph = gravity_tesseroid(bounds=(6.371e6, 6.371e6 + 1000, np.pi/2 - 0.01, np.pi/2 + 0.01, -0.01, 0.01), rho=3000, p_obs_sph=(6.371e6, np.pi/2, 0), n_quad=N_QUAD)\n    gr, gtheta, glambda = g_sph\n    tangential_mag = np.sqrt(gtheta**2 + glambda**2)\n    results.append(gr > ABS_TOL and tangential_mag  REL_TOL * abs(gr))\n\n    # Test 5: Observation on a face edge of a rectangular polyhedron\n    g = gravity_polyhedron(bounds=(-500, 500, -500, 500, 0, 100), rho=2670, p_obs=(500, 0, 0), n_quad=N_QUAD)\n    _, gy, gz = g\n    results.append(abs(gy)  ABS_TOL and gz > ABS_TOL)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "高级数值模拟不仅在于计算出一个结果，更在于理解和量化近似的精度。最后一个实践介绍了一种强大的先验误差估计方法，用于我们基于体素（voxel）的重力计算。通过利用密度场的利普希茨常数 (Lipschitz constant) 和重力核函数的梯度，我们可以推导出一个严格的数值积分误差上界，为我们解的质量提供保证 。",
            "id": "3601769",
            "problem": "您需要实现一个完整的程序，该程序使用简单的基于体素的数值求积法，对三维质量分布进行计算，从而得到某一点的牛顿引力势，并通过调用密度的 Lipschitz 连续性界和核函数梯度的界来估计求积误差的上限。此问题的基本基础是由积分定义的牛顿引力势：\n$$\nV(\\mathbf{x}) \\;=\\; G \\int_{\\Omega} \\frac{\\rho(\\mathbf{y})}{\\lVert \\mathbf{x} - \\mathbf{y} \\rVert} \\, \\mathrm{d}^3\\mathbf{y},\n$$\n其中 $G$ 是引力常数，$\\rho$ 是质量密度，$\\mathbf{x}$ 是观测点，$\\Omega$ 是质量分布的支撑域。请使用国际单位制 (SI)：$G$ 的单位为 $\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$，空间坐标的单位为 $\\mathrm{m}$，质量密度的单位为 $\\mathrm{kg\\,m^{-3}}$，报告的引力势 $V(\\mathbf{x})$ 及其误差界的单位为 $\\mathrm{m^2\\,s^{-2}}$。\n\n您的数值求积必须使用体素（voxel）离散化：\n- 将域 $\\Omega$ 划分成不相交的体素 $V_j$（笛卡尔长方体或球坐标经度-余纬-半径的球楔体）。对于每个体素 $V_j$，使用体素质心 $\\mathbf{c}_j$ 处的值来近似被积函数，并用 $G \\, \\rho(\\mathbf{c}_j) \\, \\lVert \\mathbf{x} - \\mathbf{c}_j \\rVert^{-1} \\, \\mathrm{Vol}(V_j)$ 来近似积分贡献，其中 $\\mathrm{Vol}(V_j)$ 是体素的体积。\n\n为了估计绝对求积误差，假设：\n- 密度 $\\rho$ 是 Lipschitz 连续的，具有已知的全局 Lipschitz 常数 $L_\\rho$，即对于所有 $\\mathbf{y}, \\mathbf{z} \\in \\Omega$，都有 $\\lvert \\rho(\\mathbf{y}) - \\rho(\\mathbf{z}) \\rvert \\le L_\\rho \\lVert \\mathbf{y} - \\mathbf{z} \\rVert$。\n- 在 $\\Omega$ 上，密度有一个已知的全局上确界 $\\rho_{\\max}$。\n- 牛顿核函数 $K(\\mathbf{x},\\mathbf{y}) = G \\, \\lVert \\mathbf{x}-\\mathbf{y} \\rVert^{-1}$ 相对于 $\\mathbf{y}$ 的梯度由 $\\nabla_{\\mathbf{y}} K(\\mathbf{x},\\mathbf{y})$ 给出，其范数为 $\\lVert \\nabla_{\\mathbf{y}} K(\\mathbf{x},\\mathbf{y}) \\rVert = G \\, \\lVert \\mathbf{x}-\\mathbf{y} \\rVert^{-2}$。\n\n对于每个体素 $V_j$，令 $r_{\\max,j}$ 表示当 $\\mathbf{y} \\in V_j$ 时 $\\lVert \\mathbf{y} - \\mathbf{c}_j \\rVert$ 的一个上界（对于笛卡尔长方体，取 $r_{\\max,j}$ 为空间对角线长度的一半；对于球楔体，使用沿局部经度、余纬和径向的各半边长平方和的平方根）。令 $d_{\\min,j}$ 为从观测点 $\\mathbf{x}$ 到 $V_j$ 中任意点的最小距离的一个保守下界（您可以使用 $d_{\\min,j} = \\max(\\lVert \\mathbf{x}-\\mathbf{c}_j \\rVert - r_{\\max,j}, \\varepsilon)$，其中 $\\varepsilon$ 是一个小的正数以避免除以零，请注意当 $\\mathbf{x}$ 在 $V_j$ 之外时，这是一个保守估计）。使用这些界，定义\n$$\nK_{\\sup,j} \\;=\\; \\frac{G}{d_{\\min,j}}, \\qquad M_{K,j} \\;=\\; \\frac{G}{d_{\\min,j}^2}.\n$$\n那么，由体素 $V_j$ 贡献的绝对误差的界为\n$$\nE_j \\;\\le\\; \\mathrm{Vol}(V_j) \\, r_{\\max,j} \\, \\big( L_\\rho \\, K_{\\sup,j} \\;+\\; \\rho_{\\max} \\, M_{K,j} \\big),\n$$\n总误差界为\n$$\nE \\;=\\; \\sum_j E_j.\n$$\n\n使用密度函数\n$$\n\\rho(\\mathbf{y}) \\;=\\; \\rho_0 \\;+\\; A \\, \\sin(\\omega \\, y_x) \\, \\sin(\\omega \\, y_y) \\, \\sin(\\omega \\, y_z),\n$$\n其中 $\\mathbf{y} = (y_x, y_y, y_z)$，$\\rho_0$ 是基准密度，$A$ 是振幅，$\\omega$ 是空间角频率。对于此 $\\rho$，一个有效的全局上确界是 $\\rho_{\\max} = \\rho_0 + A$，一个有效的全局 Lipschitz 常数是 $L_\\rho = A \\, \\omega \\, \\sqrt{3}$。\n\n实现笛卡尔长方体体素和球楔体两种方式：\n- 笛卡尔长方体：将一个矩形域沿 $x, y, z$ 方向均匀划分为 $N_x \\times N_y \\times N_z$ 个体素。每个长方体 $V_j$ 的体积为 $\\mathrm{Vol}(V_j) = \\Delta x \\, \\Delta y \\, \\Delta z$，质心位于中心，且 $r_{\\max,j} = \\tfrac{1}{2}\\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}$。\n- 球楔体 (Tesseroids)：将一个由经度 $\\lambda \\in [\\lambda_{\\min}, \\lambda_{\\max}]$、余纬 $\\theta \\in [\\theta_{\\min}, \\theta_{\\max}]$ 和半径 $r \\in [r_{\\min}, r_{\\max}]$ 定义的球块，沿 $\\lambda$、$\\theta$（单位为弧度）和 $r$ 方向均匀划分为 $N_\\lambda \\times N_\\theta \\times N_r$ 个球楔体。对于每个球楔体，其体积近似为 $\\mathrm{Vol}(V_j) \\approx r_{\\mathrm{mid}}^2 \\, \\sin\\theta_{\\mathrm{mid}} \\, \\Delta\\lambda \\, \\Delta\\theta \\, \\Delta r$，质心位于 $(r_{\\mathrm{mid}}, \\theta_{\\mathrm{mid}}, \\lambda_{\\mathrm{mid}})$，使用 $x = r \\sin\\theta \\cos\\lambda, y = r \\sin\\theta \\sin\\lambda, z = r \\cos\\theta$ 将质心转换为笛卡尔坐标，并用 $\\tfrac{1}{2}\\sqrt{(r_{\\mathrm{mid}} \\sin\\theta_{\\mathrm{mid}} \\Delta\\lambda)^2 + (r_{\\mathrm{mid}} \\Delta\\theta)^2 + (\\Delta r)^2}$ 来近似 $r_{\\max,j}$。\n\n在计算中，角度必须以弧度为单位。如果参数以度为单位提供，则应在内部将其转换为弧度。\n\n使用以下常量：\n- 引力常数 $G = 6.67430 \\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$。\n- 密度参数：$\\rho_0 = 2000 \\, \\mathrm{kg\\,m^{-3}}$，$A = 500 \\, \\mathrm{kg\\,m^{-3}}$，$\\omega = \\frac{2\\pi}{1000} \\, \\mathrm{rad\\,m^{-1}}$。\n- 因此，$\\rho_{\\max} = 2500 \\, \\mathrm{kg\\,m^{-3}}$ 且 $L_\\rho = 500 \\cdot \\frac{2\\pi}{1000} \\cdot \\sqrt{3} \\, \\mathrm{kg\\,m^{-4}}$。\n\n您的程序必须为以下四个测试案例实现求积，并按末尾指定的精确格式生成所要求的输出。\n\n测试套件：\n- 案例 1 (笛卡尔长方体，理想情况)：$\\Omega = [0,1000] \\times [0,1000] \\times [0,1000]$ (单位 m)，$N_x = 10, N_y = 10, N_z = 10$，观测点 $\\mathbf{x} = (500, 500, 1500)$ (单位 m)。\n- 案例 2 (笛卡尔长方体，细化网格)：与案例 1 相同的 $\\Omega$，$N_x = 20, N_y = 20, N_z = 20$，观测点 $\\mathbf{x} = (500, 500, 1500)$ (单位 m)。\n- 案例 3 (笛卡尔长方体，近场边界情况)：与案例 1 相同的 $\\Omega$，$N_x = 10, N_y = 10, N_z = 10$，观测点 $\\mathbf{x} = (500, 500, 1010)$ (单位 m)。\n- 案例 4 (球楔体，近地表球块): 球块使用地球平均半径 $R_{\\mathrm{E}} = 6.371 \\times 10^{6} \\, \\mathrm{m}$，经度区间 $[0^\\circ, 0.5^\\circ]$，余纬区间 $[89.5^\\circ, 90.0^\\circ]$，径向区间 $[R_{\\mathrm{E}}, R_{\\mathrm{E}} + 1000]$ (单位 m)，球楔体数量 $N_\\lambda = 10, N_\\theta = 10, N_r = 10$。观测点位于经度 $0.25^\\circ$，余纬 $89.75^\\circ$，半径 $R_{\\mathrm{E}} + 2000 \\, \\mathrm{m}$。在内部将角度从度转换为弧度。\n\n输出规格：\n- 对于每个案例，计算基于体素的求积估计值 $V(\\mathbf{x})$ (单位 $\\mathrm{m}^2\\,\\mathrm{s}^{-2}$) 和总误差界 $E$ (单位 $\\mathrm{m}^2\\,\\mathrm{s}^{-2}$)。\n- 您的程序应生成单行输出，其中包含按案例顺序排列的结果列表。每个内部列表为 $[V,E]$，两个条目均为十进制浮点数。例如：$[[v_1,e_1],[v_2,e_2],[v_3,e_3],[v_4,e_4]]$。",
            "solution": "### 基于原则的解决方案设计\n\n问题的核心是对大量离散体积元素（体素）进行求和的数值实现。我将设计一个结构化程序，将两种不同体素几何形状的计算模块化。\n\n**1. 常量和共享函数：** 我将首先定义问题陈述中提供的所有物理和数学常量（$G, \\rho_0, A, \\omega, \\rho_{\\max}, L_\\rho$）。密度函数 $\\rho(\\mathbf{y})$ 将作为一个独立的函数来实现，它接受一个笛卡尔坐标向量。将定义一个小的常量 $\\varepsilon$ 用于正则化最小距离的计算。\n\n**2. 笛卡尔长方体计算 (`compute_cartesian`)：** 此函数将处理使用笛卡尔网格的情况。\n- **输入**：域边界 $(x_{\\min}, x_{\\max})$ 等，划分数量 $(N_x, N_y, N_z)$，以及观测点 $\\mathbf{x}_{\\text{obs}}$ 的笛卡尔坐标。\n- **初始化**：总势能 $V$ 和总误差界 $E$ 初始化为 $0$。\n- **体素参数**：边长 $(\\Delta x, \\Delta y, \\Delta z)$、体积 $\\mathrm{Vol}$ 和最大内部半径 $r_{\\max}$ 将被预先计算，因为对于均匀网格中的所有体素，它们都是恒定的。\n- **迭代**：代码将使用关于 $x, y, z$ 索引的三个嵌套循环遍历每个体素。\n- **单个体素计算**：在循环内部，对每个体素进行如下操作：\n    1. 计算体素质心 $\\mathbf{c}_j$ 的笛卡尔坐标。\n    2. 评估密度 $\\rho(\\mathbf{c}_j)$。\n    3. 计算欧几里得距离 $d_j = \\lVert \\mathbf{x}_{\\text{obs}} - \\mathbf{c}_j \\rVert$。\n    4. 计算势能贡献 $V_j = G \\cdot \\rho(\\mathbf{c}_j) \\cdot \\mathrm{Vol} / d_j$ 并加到总势能 $V$ 中。\n    5. 确定到体素的最小距离 $d_{\\min,j} = \\max(d_j - r_{\\max}, \\varepsilon)$。\n    6. 计算核函数界 $K_{\\sup,j} = G/d_{\\min,j}$ 及其梯度界 $M_{K,j} = G/d_{\\min,j}^2$。\n    7. 计算误差贡献 $E_j = \\mathrm{Vol} \\cdot r_{\\max} \\cdot (L_\\rho K_{\\sup,j} + \\rho_{\\max} M_{K,j})$ 并加到总误差界 $E$ 中。\n- **输出**：函数返回一个对 $[V, E]$。\n\n**3. 球楔体计算 (`compute_tesseroid`)：** 此函数将处理使用球楔体网格的情况。\n- **输入**：球坐标域边界 $(\\lambda_{\\min}, \\lambda_{\\max})$ 等，划分数量 $(N_\\lambda, N_\\theta, N_r)$，以及观测点 $\\mathbf{x}_{\\text{obs, sph}}$ 的球坐标。\n- **坐标转换**：所有输入角度都将从度转换为弧度。观测点的球坐标将转换为笛卡尔坐标 $\\mathbf{x}_{\\text{obs, cart}}$。\n- **初始化**：总势能 $V$ 和误差界 $E$ 设置为 $0$。\n- **体素参数**：计算均匀步长 $(\\Delta\\lambda, \\Delta\\theta, \\Delta r)$。\n- **迭代**：代码将使用关于 $\\lambda, \\theta, r$ 索引的三个嵌套循环遍历每个球楔体。\n- **单个体素计算**：在循环内部，对每个球楔体进行如下操作：\n    1. 确定质心的球坐标 $(\\lambda_{\\mathrm{mid}}, \\theta_{\\mathrm{mid}}, r_{\\mathrm{mid}})$。\n    2. 使用提供的公式计算近似体积 $\\mathrm{Vol}_j$ 和最大内部半径 $r_{\\max,j}$，这些公式依赖于质心的位置。\n    3. 将质心的球坐标转换为笛卡尔坐标 $\\mathbf{c}_j$。\n    4. 评估笛卡尔质心处的密度 $\\rho(\\mathbf{c}_j)$。\n    5. 计算距离 $d_j = \\lVert \\mathbf{x}_{\\text{obs, cart}} - \\mathbf{c}_j \\rVert$。\n    6. 将势能贡献 $V_j = G \\cdot \\rho(\\mathbf{c}_j) \\cdot \\mathrm{Vol}_j / d_j$ 添加到 $V$。\n    7. 类似于笛卡尔情况，计算最小距离 $d_{\\min,j} = \\max(d_j - r_{\\max,j}, \\varepsilon)$、核函数界 $K_{\\sup,j}$、$M_{K,j}$ 和误差贡献 $E_j$，并进行累加。\n- **输出**：函数返回一个对 $[V, E]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the gravitational potential and its error bound for a 3D mass\n    distribution using voxel-based numerical quadrature.\n    \"\"\"\n    #\n    # Step 1: Define Constants and Shared Functions\n    #\n    G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2\n    R_E = 6.371e6      # Earth mean radius in m\n\n    # Density function parameters\n    RHO_0 = 2000.0   # kg m^-3\n    A = 500.0        # kg m^-3\n    OMEGA = (2 * np.pi) / 1000.0  # rad m^-1\n\n    # Derived density bounds\n    RHO_MAX = RHO_0 + A\n    L_RHO = A * OMEGA * np.sqrt(3)\n\n    # Small epsilon to prevent division by zero\n    EPSILON = 1e-9\n\n    def rho(y):\n        \"\"\"Density function rho(y) in kg m^-3.\"\"\"\n        yx, yy, yz = y\n        return RHO_0 + A * np.sin(OMEGA * yx) * np.sin(OMEGA * yy) * np.sin(OMEGA * yz)\n\n    def spherical_to_cartesian(lon_rad, colat_rad, r):\n        \"\"\"Converts spherical coordinates (lon, colat, r) to Cartesian (x, y, z).\"\"\"\n        x = r * np.sin(colat_rad) * np.cos(lon_rad)\n        y = r * np.sin(colat_rad) * np.sin(lon_rad)\n        z = r * np.cos(colat_rad)\n        return np.array([x, y, z])\n\n    #\n    # Step 2: Implement Quadrature for Cartesian Cuboids\n    #\n    def compute_cartesian(domain, N, x_obs):\n        \"\"\"\n        Computes potential and error for a Cartesian grid.\n        \n        Args:\n            domain (dict): {'x': (min, max), 'y': (min, max), 'z': (min, max)}\n            N (tuple): (Nx, Ny, Nz) number of divisions\n            x_obs (np.ndarray): Observation point coordinates\n        \"\"\"\n        x_min, x_max = domain['x']\n        y_min, y_max = domain['y']\n        z_min, z_max = domain['z']\n        Nx, Ny, Nz = N\n\n        dx = (x_max - x_min) / Nx\n        dy = (y_max - y_min) / Ny\n        dz = (z_max - z_min) / Nz\n\n        vol = dx * dy * dz\n        r_max = 0.5 * np.sqrt(dx**2 + dy**2 + dz**2)\n\n        total_potential = 0.0\n        total_error = 0.0\n\n        for i in range(Nx):\n            cx = x_min + (i + 0.5) * dx\n            for j in range(Ny):\n                cy = y_min + (j + 0.5) * dy\n                for k in range(Nz):\n                    cz = z_min + (k + 0.5) * dz\n                    centroid = np.array([cx, cy, cz])\n                    \n                    # Potential calculation\n                    dist_to_centroid = np.linalg.norm(x_obs - centroid)\n                    total_potential += G * rho(centroid) * vol / dist_to_centroid\n\n                    # Error bound calculation\n                    d_min = max(dist_to_centroid - r_max, EPSILON)\n                    K_sup = G / d_min\n                    M_K = G / (d_min**2)\n                    \n                    error_contrib = vol * r_max * (L_RHO * K_sup + RHO_MAX * M_K)\n                    total_error += error_contrib\n        \n        return [total_potential, total_error]\n\n    #\n    # Step 3: Implement Quadrature for Tesseroids\n    #\n    def compute_tesseroid(domain_sph, N_sph, x_obs_sph):\n        \"\"\"\n        Computes potential and error for a tesseroid grid.\n        \n        Args:\n            domain_sph (dict): {'lon':(min,max),'colat':(min,max),'r':(min,max)} in deg/m\n            N_sph (tuple): (Nlon, Ntheta, Nr) number of divisions\n            x_obs_sph (tuple): Observation point (lon, colat, r) in deg/m\n        \"\"\"\n        # Convert degrees to radians\n        lon_min_rad = np.deg2rad(domain_sph['lon'][0])\n        lon_max_rad = np.deg2rad(domain_sph['lon'][1])\n        theta_min_rad = np.deg2rad(domain_sph['colat'][0])\n        theta_max_rad = np.deg2rad(domain_sph['colat'][1])\n        \n        r_min, r_max = domain_sph['r']\n        N_lon, N_theta, N_r = N_sph\n\n        x_obs_lon_rad = np.deg2rad(x_obs_sph[0])\n        x_obs_theta_rad = np.deg2rad(x_obs_sph[1])\n        x_obs_r = x_obs_sph[2]\n        x_obs_cart = spherical_to_cartesian(x_obs_lon_rad, x_obs_theta_rad, x_obs_r)\n\n        d_lon = (lon_max_rad - lon_min_rad) / N_lon\n        d_theta = (theta_max_rad - theta_min_rad) / N_theta\n        d_r = (r_max - r_min) / N_r\n\n        total_potential = 0.0\n        total_error = 0.0\n\n        for i in range(N_lon):\n            lon_mid = lon_min_rad + (i + 0.5) * d_lon\n            for j in range(N_theta):\n                theta_mid = theta_min_rad + (j + 0.5) * d_theta\n                for k in range(N_r):\n                    r_mid = r_min + (k + 0.5) * d_r\n                    \n                    # Tesseroid-specific geometry\n                    vol = r_mid**2 * np.sin(theta_mid) * d_lon * d_theta * d_r\n                    \n                    dx_local = r_mid * np.sin(theta_mid) * d_lon\n                    dy_local = r_mid * d_theta\n                    dz_local = d_r\n                    r_max_j = 0.5 * np.sqrt(dx_local**2 + dy_local**2 + dz_local**2)\n\n                    centroid_cart = spherical_to_cartesian(lon_mid, theta_mid, r_mid)\n\n                    # Potential calculation\n                    dist_to_centroid = np.linalg.norm(x_obs_cart - centroid_cart)\n                    total_potential += G * rho(centroid_cart) * vol / dist_to_centroid\n\n                    # Error bound calculation\n                    d_min = max(dist_to_centroid - r_max_j, EPSILON)\n                    K_sup = G / d_min\n                    M_K = G / (d_min**2)\n                    \n                    error_contrib = vol * r_max_j * (L_RHO * K_sup + RHO_MAX * M_K)\n                    total_error += error_contrib\n\n        return [total_potential, total_error]\n\n    #\n    # Step 4: Define and Run Test Cases\n    #\n    test_cases = [\n        {'type': 'cartesian', 'domain': {'x': (0, 1000), 'y': (0, 1000), 'z': (0, 1000)},\n         'N': (10, 10, 10), 'x_obs': np.array([500, 500, 1500])},\n        \n        {'type': 'cartesian', 'domain': {'x': (0, 1000), 'y': (0, 1000), 'z': (0, 1000)},\n         'N': (20, 20, 20), 'x_obs': np.array([500, 500, 1500])},\n        \n        {'type': 'cartesian', 'domain': {'x': (0, 1000), 'y': (0, 1000), 'z': (0, 1000)},\n         'N': (10, 10, 10), 'x_obs': np.array([500, 500, 1010])},\n        \n        {'type': 'tesseroid', 'domain_sph': {'lon': (0.0, 0.5), 'colat': (89.5, 90.0), 'r': (R_E, R_E + 1000)},\n         'N_sph': (10, 10, 10), 'x_obs_sph': (0.25, 89.75, R_E + 2000)},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'cartesian':\n            result = compute_cartesian(case['domain'], case['N'], case['x_obs'])\n        elif case['type'] == 'tesseroid':\n            result = compute_tesseroid(case['domain_sph'], case['N_sph'], case['x_obs_sph'])\n        results.append(result)\n\n    # Final print statement in the exact required format\n    inner_strings = [f\"[{v},{e}]\" for v, e in results]\n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```"
        }
    ]
}