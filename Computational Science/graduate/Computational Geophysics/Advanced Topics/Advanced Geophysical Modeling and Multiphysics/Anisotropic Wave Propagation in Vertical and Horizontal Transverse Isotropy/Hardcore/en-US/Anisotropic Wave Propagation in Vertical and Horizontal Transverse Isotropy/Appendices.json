{
    "hands_on_practices": [
        {
            "introduction": "The foundation of understanding wave propagation in any elastic medium, isotropic or anisotropic, is the Christoffel equation. This practice tasks you with building the Christoffel matrix from first principles for a VTI medium and solving its associated eigenproblem. More than just calculating the wave speeds (from the eigenvalues), this exercise focuses on interpreting the polarization vectors (the eigenvectors), revealing a key feature of anisotropy: the tilt of particle motion relative to the wave propagation direction. By classifying the quasi-P ($qP$) and quasi-SV ($qSV$) modes and quantifying their polarization tilt, you will gain a fundamental intuition for why these waves are designated as \"quasi\"-longitudinal and \"quasi\"-transverse .",
            "id": "3575984",
            "problem": "You are to implement a complete, self-contained program that, for a transversely isotropic elastic medium with a vertical symmetry axis (vertical transverse isotropy), computes the quasi-compressional (qP) and quasi-shear vertical (qSV) polarization vectors from first principles and reports how much these polarizations tilt relative to the phase normal as a function of the polar angle. Your derivation and implementation must begin from the linear elastodynamic equation and the constitutive relation of linear elasticity, and proceed through the plane-wave ansatz and the Christoffel formulation, without invoking pre-packaged shortcut formulas for anisotropic waves. The computational approach must be general and must determine the polarizations as eigenvectors of the Christoffel matrix constructed for the specified symmetry and propagation direction. The classification of modes must be done by logical, physics-based criteria rather than by assuming isotropic-like ordering.\n\nFundamental base:\n- Linear elastodynamics and Hooke’s law in index notation: The elastodynamic wave equation for small deformations in an elastic medium is given by $c_{ijkl} \\, \\partial_j \\partial_l u_k = \\rho \\, \\partial_t^2 u_i$, where $u_i$ is displacement, $\\rho$ is mass density, and $c_{ijkl}$ is the fourth-order stiffness tensor with the minor and major symmetries appropriate to linear elasticity.\n- Plane-wave ansatz: seek solutions of the form $u_i(\\mathbf{x},t) = A_i \\exp\\left(i \\omega \\left(t - \\mathbf{n} \\cdot \\mathbf{x} / v\\right)\\right)$, where $\\omega$ is angular frequency, $v$ is phase velocity, and $\\mathbf{n}$ is the unit phase-normal (direction of wavefront normal).\n- Christoffel formulation: substitution of the plane-wave ansatz yields the eigenproblem $\\Gamma_{ik} A_k = \\rho v^2 A_i$ with the Christoffel matrix $\\Gamma_{ik} = c_{ijkl} n_j n_l$.\n\nSetup and constraints:\n- The symmetry class is vertical transverse isotropy (VTI) with symmetry axis aligned with the $z$ axis. Use Voigt notation to parameterize the stiffness tensor by the independent components $\\{c_{11}, c_{33}, c_{44}, c_{66}, c_{13}\\}$ and enforce the VTI identity $c_{66} = \\left(c_{11} - c_{12}\\right)/2$, which determines $c_{12} = c_{11} - 2 c_{66}$.\n- Consider propagation restricted to the $x$–$z$ plane due to axisymmetry, with the unit phase-normal $\\mathbf{n}$ parametrized by the polar angle $\\theta$ measured from the $z$ axis (the symmetry axis). Use $\\mathbf{n}(\\theta) = \\left(\\sin \\theta, 0, \\cos \\theta\\right)$.\n- For each propagation direction, form the Christoffel matrix from first principles using the above definitions and solve the resulting $3 \\times 3$ eigenproblem to obtain three wave modes and their polarization vectors. Among these modes, identify the SH mode as the one whose polarization has the largest magnitude of the $y$ component; the remaining two modes are the qP and qSV. Among these remaining two, identify the qP mode as the mode whose polarization has the largest absolute inner product with the phase normal $\\mathbf{n}$; the other is the qSV mode.\n- For each mode of interest (qP and qSV), define the tilt angle $\\alpha$ relative to the phase normal as the acute angle in $[0, \\pi/2]$ between the unit polarization vector and $\\mathbf{n}$, given by $\\alpha = \\arccos\\left(\\left| \\hat{\\mathbf{a}} \\cdot \\mathbf{n} \\right|\\right)$, where $\\hat{\\mathbf{a}}$ is the unit polarization vector. Report tilt angles in degrees.\n\nAngle units and physical units:\n- Angles $\\theta$ are specified in degrees, and all tilt angles must be reported in degrees.\n- Stiffnesses $c_{ij}$ are in pascals (Pa) and density $\\rho$ is in kilograms per cubic meter (kg/m$^3$). The program will not directly output velocities, but the physics must be consistent dimensionally.\n\nTest suite:\nFor each test case, compute the qP and qSV tilt angles for the polar angles $\\theta \\in \\{0^\\circ, 30^\\circ, 60^\\circ, 90^\\circ\\}$.\n\n- Test Case 1 (Isotropic reference embedded in VTI form):\n  - $\\rho = 2500 \\ \\text{kg/m}^3$\n  - $c_{11} = 80 \\times 10^9 \\ \\text{Pa}$, $c_{33} = 80 \\times 10^9 \\ \\text{Pa}$, $c_{44} = 30 \\times 10^9 \\ \\text{Pa}$, $c_{66} = 30 \\times 10^9 \\ \\text{Pa}$, $c_{13} = 20 \\times 10^9 \\ \\text{Pa}$\n  - This corresponds to Lamé parameters $\\lambda = 20 \\times 10^9 \\ \\text{Pa}$ and $\\mu = 30 \\times 10^9 \\ \\text{Pa}$.\n\n- Test Case 2 (Weak VTI):\n  - $\\rho = 2400 \\ \\text{kg/m}^3$\n  - $c_{11} = 60 \\times 10^9 \\ \\text{Pa}$, $c_{33} = 55 \\times 10^9 \\ \\text{Pa}$, $c_{44} = 20 \\times 10^9 \\ \\text{Pa}$, $c_{66} = 25 \\times 10^9 \\ \\text{Pa}$, $c_{13} = 18 \\times 10^9 \\ \\text{Pa}$\n  - Enforce $c_{12} = c_{11} - 2 c_{66} = 10 \\times 10^9 \\ \\text{Pa}$.\n\n- Test Case 3 (Strong VTI):\n  - $\\rho = 2700 \\ \\text{kg/m}^3$\n  - $c_{11} = 100 \\times 10^9 \\ \\text{Pa}$, $c_{33} = 50 \\times 10^9 \\ \\text{Pa}$, $c_{44} = 15 \\times 10^9 \\ \\text{Pa}$, $c_{66} = 35 \\times 10^9 \\ \\text{Pa}$, $c_{13} = 12 \\times 10^9 \\ \\text{Pa}$\n  - Enforce $c_{12} = c_{11} - 2 c_{66} = 30 \\times 10^9 \\ \\text{Pa}$.\n\nRequired outputs:\n- For each test case, output two lists of floats (in degrees), each of length $4$ corresponding to $\\theta = [0, 30, 60, 90]$ degrees, rounded to six decimal places:\n  1. The list of qP tilt angles.\n  2. The list of qSV tilt angles.\n- Aggregate the results for all test cases into a single top-level list of length $3$, where each element is the pair of lists described above.\n- Final output format: Your program should produce a single line of output containing the nested list with no spaces, using comma-separated values and square brackets. For example, the overall structure must be like: [[[qP_case1],[qSV_case1]],[[qP_case2],[qSV_case2]],[[qP_case3],[qSV_case3]]], where each bracketed block contains the four rounded floats for the specified angles.\n\nConstraints and notes:\n- The program must be standalone and must not require any external input; it must compute and print the specified nested list for the three test cases as a single line.\n- The program must compute polarizations and tilt strictly by solving the Christoffel eigenproblem for each direction and classifying the modes as specified.\n- All angles supplied and reported must be in degrees. All reported floats must be rounded to six decimal places.",
            "solution": "The problem requires the calculation of quasi-compressional (qP) and quasi-shear vertical (qSV) wave polarization tilt angles in a transversely isotropic medium with a vertical axis of symmetry (VTI). The calculation must start from first principles of linear elasticity and be performed for several propagation directions and sets of elastic parameters.\n\n### Principle-Based Derivation and Algorithmic Design\n\n**1. Elastodynamic Wave Equation and the Plane-Wave Ansatz**\n\nThe fundamental governing equation for small-amplitude elastic waves in a continuous medium is the linear elastodynamic equation, which represents a balance of linear momentum. In index notation, it is:\n$$\n\\partial_j \\sigma_{ij} = \\rho \\, \\partial_t^2 u_i\n$$\nwhere $\\sigma_{ij}$ is the second-order stress tensor, $u_i$ is the displacement vector, $\\rho$ is the mass density, $t$ is time, and $\\partial_j$ denotes the partial derivative with respect to the spatial coordinate $x_j$. The summation convention over repeated indices is implied.\n\nThe stress tensor is related to the strain tensor $\\varepsilon_{kl} = \\frac{1}{2}(\\partial_l u_k + \\partial_k u_l)$ through the constitutive relation of linear elasticity, or Hooke's Law:\n$$\n\\sigma_{ij} = c_{ijkl} \\varepsilon_{kl}\n$$\nHere, $c_{ijkl}$ is the fourth-order stiffness tensor, which characterizes the elastic properties of the medium. Substituting the constitutive relation into the elastodynamic equation yields:\n$$\nc_{ijkl} \\, \\partial_j \\partial_l u_k = \\rho \\, \\partial_t^2 u_i\n$$\n\nWe seek plane-wave solutions, which describe waves with planar wavefronts. A plane-wave solution is expressed by the ansatz:\n$$\nu_i(\\mathbf{x},t) = A_i \\exp\\left(i \\omega \\left(t - \\frac{\\mathbf{n} \\cdot \\mathbf{x}}{v}\\right)\\right)\n$$\nwhere $A_i$ is the constant polarization vector defining the direction of particle motion, $\\omega$ is the angular frequency, $\\mathbf{n}$ is the unit vector normal to the wavefronts (the phase-normal), $v$ is the phase velocity, and $i = \\sqrt{-1}$.\n\n**2. The Christoffel Formulation**\n\nSubstituting the plane-wave ansatz into the elastodynamic equation involves taking derivatives of the exponential function:\n- $\\partial_l u_k = \\left(-\\frac{i\\omega}{v} n_l\\right) u_k$\n- $\\partial_j \\partial_l u_k = \\left(-\\frac{i\\omega}{v} n_j\\right) \\left(-\\frac{i\\omega}{v} n_l\\right) u_k = -\\frac{\\omega^2}{v^2} n_j n_l u_k$\n- $\\partial_t^2 u_i = (i\\omega)^2 u_i = -\\omega^2 u_i$\n\nSubstituting these derivatives into the elastodynamic equation gives:\n$$\nc_{ijkl} \\left(-\\frac{\\omega^2}{v^2} n_j n_l\\right) A_k \\exp(\\dots) = \\rho \\left(-\\omega^2\\right) A_i \\exp(\\dots)\n$$\nCanceling the common factor $-\\omega^2 \\exp(\\dots)$ and rearranging, we obtain the Christoffel equation, which is an algebraic eigenvalue problem:\n$$\n(c_{ijkl} n_j n_l) A_k = \\rho v^2 A_i\n$$\nThis can be written compactly as:\n$$\n\\Gamma_{ik} A_k = \\lambda A_i\n$$\nwhere $\\Gamma_{ik} = c_{ijkl} n_j n_l$ is the Christoffel matrix (or acoustic tensor), and the eigenvalues are $\\lambda = \\rho v^2$. For any given propagation direction $\\mathbf{n}$, this $3 \\times 3$ system yields three eigenvalues and three corresponding eigenvectors. The eigenvectors $A_i$ are the polarization vectors, and the eigenvalues determine the phase velocities of the three possible wave modes.\n\n**3. VTI Symmetry and Christoffel Matrix Construction**\n\nThe problem specifies a VTI medium with the symmetry axis aligned with the $z$-axis ($x_3$). The stiffness tensor for such a medium, expressed in $6 \\times 6$ Voigt matrix notation, is:\n$$\nC = \\begin{pmatrix}\nc_{11} & c_{12} & c_{13} & 0 & 0 & 0 \\\\\nc_{12} & c_{11} & c_{13} & 0 & 0 & 0 \\\\\nc_{13} & c_{13} & c_{33} & 0 & 0 & 0 \\\\\n0 & 0 & 0 & c_{44} & 0 & 0 \\\\\n0 & 0 & 0 & 0 & c_{44} & 0 \\\\\n0 & 0 & 0 & 0 & 0 & c_{66}\n\\end{pmatrix}\n$$\nwith the VTI-specific constraint $c_{12} = c_{11} - 2c_{66}$.\n\nDue to the axial symmetry, wave properties depend only on the polar angle $\\theta$ between the phase-normal $\\mathbf{n}$ and the symmetry axis ($z$-axis). We can thus restrict our analysis to propagation in the $x-z$ plane without loss of generality. The phase-normal vector is then $\\mathbf{n} = (\\sin\\theta, 0, \\cos\\theta)$.\n\nSubstituting the VTI stiffness components and $n_x=\\sin\\theta, n_y=0, n_z=\\cos\\theta$ into the general expression for $\\Gamma_{ik}$ yields the specific Christoffel matrix for this case:\n$$\n\\Gamma = \\begin{pmatrix}\nc_{11} \\sin^2\\theta + c_{44} \\cos^2\\theta & 0 & (c_{13}+c_{44}) \\sin\\theta \\cos\\theta \\\\\n0 & c_{66} \\sin^2\\theta + c_{44} \\cos^2\\theta & 0 \\\\\n(c_{13}+c_{44}) \\sin\\theta \\cos\\theta & 0 & c_{44} \\sin^2\\theta + c_{33} \\cos^2\\theta\n\\end{pmatrix}\n$$\nThis matrix is block-diagonal. The $(2,2)$ element of the matrix (in terms of block structure) corresponds to motion purely in the $y$-direction, decoupled from motions in the $x-z$ plane. This corresponds to the shear-horizontal (SH) wave. The remaining $2 \\times 2$ submatrix governs the coupled quasi-compressional (qP) and quasi-shear-vertical (qSV) waves, whose polarizations lie in the $x-z$ plane.\n\n**4. Mode Classification and Tilt Angle Calculation**\n\nFor each propagation direction $\\theta$, the algorithm is as follows:\n1.  **Construct $\\Gamma(\\theta)$**: Using the given elastic parameters and angle $\\theta$.\n2.  **Solve Eigenproblem**: Solve the eigenvalue problem $\\Gamma \\mathbf{A} = \\lambda \\mathbf{A}$. Since $\\Gamma$ is a real symmetric matrix, this yields three real eigenvalues and a set of three mutually orthogonal eigenvectors. We use a numerical library function (`numpy.linalg.eigh`) to obtain the eigenvalues and the corresponding normalized eigenvectors.\n3.  **Identify SH Mode**: The SH mode is characterized by polarization perpendicular to the $x-z$ plane. Its eigenvector is of the form $(0, c, 0)$, where $c$ is a normalization constant. We identify the SH mode by finding the eigenvector with the largest absolute value in its $y$-component.\n4.  **Identify qP and qSV Modes**: The remaining two eigenvectors correspond to the qP and qSV modes. The qP mode is \"quasi-longitudinal\", meaning its polarization vector is more closely aligned with the phase-normal $\\mathbf{n}$ than the qSV mode. The qSV mode is \"quasi-transverse\", with its polarization being more perpendicular to $\\mathbf{n}$. We formalize this by computing the absolute value of the dot product between each polarization vector and $\\mathbf{n}$. The mode with the larger absolute dot product is classified as qP, and the other is qSV.\n5.  **Compute Tilt Angle**: The tilt angle $\\alpha$ is the acute angle between a mode's polarization vector $\\hat{\\mathbf{a}}$ and the phase-normal $\\mathbf{n}$. It is computed using the formula:\n    $$\n    \\alpha = \\arccos(|\\hat{\\mathbf{a}} \\cdot \\mathbf{n}|)\n    $$\n    The result from `arccos` is in radians and must be converted to degrees for the final output. For the qP and qSV modes, since their polarization vectors are orthogonal and lie in the same plane as $\\mathbf{n}$, their tilt angles satisfy the relation $\\alpha_{\\text{qP}} + \\alpha_{\\text{qSV}} = 90^\\circ$. This serves as a valuable consistency check. For propagation along symmetry axes ($\\theta = 0^\\circ$ and $\\theta = 90^\\circ$), the waves are pure modes (P, SV, SH), resulting in tilt angles of $0^\\circ$ for qP and $90^\\circ$ for qSV. An isotropic medium (Test Case 1) also exhibits pure modes, meaning these tilt angles should hold for all propagation directions.\n\nThis detailed, first-principles-based procedure is implemented for each test case to compute the required tilt angles.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the computation for all test cases and print the final result.\n    \"\"\"\n    \n    # Test cases defined as (density, c11, c33, c44, c66, c13).\n    # Stiffnesses are in GPa; they will be scaled by 1e9 in the calculation function.\n    test_cases = [\n        # Test Case 1 (Isotropic reference)\n        (2500, 80e9, 80e9, 30e9, 30e9, 20e9),\n        # Test Case 2 (Weak VTI)\n        (2400, 60e9, 55e9, 20e9, 25e9, 18e9),\n        # Test Case 3 (Strong VTI)\n        (2700, 100e9, 50e9, 15e9, 35e9, 12e9),\n    ]\n\n    angles_deg = [0.0, 30.0, 60.0, 90.0]\n    \n    all_results = []\n    for params in test_cases:\n        qp_tilts, qsv_tilts = compute_tilts(params, angles_deg)\n        all_results.append((qp_tilts, qsv_tilts))\n\n    # Format the final output string to match the exact requirement:\n    # [[[qP_case1],[qSV_case1]],[[qP_case2],[qSV_case2]],[[qP_case3],[qSV_case3]]]\n    # with no spaces and 6 decimal places for each number.\n    case_strings = []\n    for qp_tilts, qsv_tilts in all_results:\n        # Format lists of floats to strings with 6 decimal places\n        qp_str = '[' + ','.join(f'{x:.6f}' for x in qp_tilts) + ']'\n        qsv_str = '[' + ','.join(f'{x:.6f}' for x in qsv_tilts) + ']'\n        case_strings.append(f'[{qp_str},{qsv_str}]')\n    \n    final_output = '[' + ','.join(case_strings) + ']'\n    print(final_output)\n\ndef compute_tilts(params, angles_deg):\n    \"\"\"\n    Computes qP and qSV tilt angles for a given VTI medium and a list of propagation angles.\n\n    Args:\n        params (tuple): A tuple containing material properties (rho, c11, c33, c44, c66, c13).\n        angles_deg (list): A list of polar angles in degrees.\n\n    Returns:\n        tuple: A tuple of two lists: (qP_tilt_angles, qSV_tilt_angles) in degrees.\n    \"\"\"\n    _rho, c11, c33, c44, c66, c13 = params\n    \n    qp_tilts_deg = []\n    qsv_tilts_deg = []\n\n    for theta_deg in angles_deg:\n        theta_rad = np.radians(theta_deg)\n        s = np.sin(theta_rad)\n        c = np.cos(theta_rad)\n        \n        # Phase normal vector n\n        n = np.array([s, 0, c])\n\n        # Construct the 3x3 Christoffel matrix Gamma for VTI media\n        Gamma = np.zeros((3, 3))\n        Gamma[0, 0] = c11 * s**2 + c44 * c**2\n        Gamma[1, 1] = c66 * s**2 + c44 * c**2\n        Gamma[2, 2] = c44 * s**2 + c33 * c**2\n        Gamma[0, 2] = (c13 + c44) * s * c\n        Gamma[2, 0] = Gamma[0, 2]\n        \n        # Solve the eigenproblem for the symmetric Christoffel matrix\n        # eigvecs[:, i] is the normalized eigenvector corresponding to eigvals[i]\n        _eigvals, eigvecs = np.linalg.eigh(Gamma)\n\n        # Classify modes\n        pol_vectors = [eigvecs[:, i] for i in range(3)]\n        \n        # 1. Identify SH mode (polarization with largest y-component)\n        sh_idx = np.argmax(np.abs(eigvecs[1, :]))\n\n        # 2. Identify qP and qSV modes from the remaining two\n        p_sv_indices = [i for i in range(3) if i != sh_idx]\n        \n        vec1 = pol_vectors[p_sv_indices[0]]\n        vec2 = pol_vectors[p_sv_indices[1]]\n        \n        dot_prod1 = np.abs(np.dot(vec1, n))\n        dot_prod2 = np.abs(np.dot(vec2, n))\n        \n        if dot_prod1 > dot_prod2:\n            # vec1 is qP, vec2 is qSV\n            cos_alpha_qp = dot_prod1\n            cos_alpha_qsv = dot_prod2\n        else:\n            # vec2 is qP, vec1 is qSV\n            cos_alpha_qp = dot_prod2\n            cos_alpha_qsv = dot_prod1\n            \n        # 3. Calculate tilt angles in degrees\n        # np.arccos can receive values slightly > 1.0 due to float precision, so we clip.\n        alpha_qp_rad = np.arccos(np.clip(cos_alpha_qp, -1.0, 1.0))\n        alpha_qsv_rad = np.arccos(np.clip(cos_alpha_qsv, -1.0, 1.0))\n        \n        qp_tilts_deg.append(np.degrees(alpha_qp_rad))\n        qsv_tilts_deg.append(np.degrees(alpha_qsv_rad))\n        \n    return qp_tilts_deg, qsv_tilts_deg\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "After mastering the calculation of direction-dependent phase velocities, the next logical step is to determine their effect on a crucial seismic observable: traveltime. This exercise challenges you to compute quasi-P wave traveltimes along a fixed, straight path through a layered medium, a common simplification in seismic modeling. You will work with the widely used Thomsen parameterization ($\\epsilon$, $\\delta$) and compare your anisotropic traveltime calculation against a simple isotropic reference model. This practice directly illustrates the kinematic errors that arise when anisotropy is ignored and provides a concrete measure of its impact on seismic data .",
            "id": "3576014",
            "problem": "You are tasked with deriving and implementing a computational method to evaluate quasi-compressional wave (qP) travel times in a horizontally layered, transversely isotropic medium with a vertical symmetry axis (Vertical Transverse Isotropy, VTI) and, for one designated case, a horizontal symmetry axis (Horizontal Transverse Isotropy, HTI). The goal is to integrate the anisotropic eikonal along a fixed straight source-to-receiver path, and to compare the resulting qP travel time against an isotropic prediction to quantify the timing difference driven by anisotropy.\n\nStart from the following fundamental base:\n- The plane-wave propagation in an elastic anisotropic medium is governed by the Christoffel equation, which for a given propagation direction with unit normal components $n_x$ and $n_z$ in the $x\\!-\\!z$ plane yields mode-dependent phase velocities via the eigenvalue problem of the Christoffel matrix. The quasi-compressional (qP) mode corresponds to the largest eigenvalue.\n- The eikonal integral for travel time along a prescribed path with differential arc length $\\mathrm{d}\\ell$ is $T = \\int s(\\theta)\\,\\mathrm{d}\\ell$, where $s(\\theta)$ is the direction-dependent phase slowness $s(\\theta) = 1/v_{\\text{phase}}(\\theta)$ and $\\theta$ is the angle between the propagation direction and the symmetry axis of the medium.\n- For a straight path through horizontally layered media with total receiver depth $Z_R$ and horizontal offset $X$, the path direction unit vector is $d = \\left(\\frac{X}{\\sqrt{X^2 + Z_R^2}},\\,\\frac{Z_R}{\\sqrt{X^2 + Z_R^2}}\\right)$, so the path length inside layer $i$ of thickness $h_i$ is $\\ell_i = h_i/d_z$, where $d_z$ is the vertical component of $d$. The anisotropic travel time is then $T_{\\text{aniso}} = \\sum_i \\ell_i\\,s_i(\\theta_i)$, while the isotropic prediction uses $s_i^{\\text{iso}} = 1/\\alpha_{0,i}$, with $\\alpha_{0,i}$ the vertical $P$-wave velocity in layer $i$, yielding $T_{\\text{iso}}=\\sum_i \\ell_i\\,s_i^{\\text{iso}}$.\n\nUse the following widely accepted parameterization in terms of Thomsen parameters for transversely isotropic media:\n- Let $\\alpha_0$ be the vertical $P$-wave velocity, $\\beta_0$ be the vertical $S$-wave velocity, $\\epsilon$ and $\\delta$ be Thomsen anisotropy parameters, and $\\rho$ be density. Define the stiffness-like quantities (mass-density scaled) for use in the Christoffel formulation:\n  $$C = \\rho\\,\\alpha_0^2,\\quad L = \\rho\\,\\beta_0^2,\\quad A = \\rho\\,\\alpha_0^2\\,(1 + 2\\epsilon),$$\n  and determine $F$ from $\\delta$ via\n  $$\\delta = \\frac{(F+L)^2 - (C - L)^2}{2\\,C\\,(C - L)}\\quad\\Rightarrow\\quad F = -L + \\sqrt{(C - L)^2 + 2\\,\\delta\\,C\\,(C - L)}.$$\nThese relations parameterize a Transversely Isotropic (TI) medium in the $x\\!-\\!z$ plane. For a VTI layer (symmetry axis along $z$), the propagation direction angle $\\theta$ is the angle to $z$; for an HTI layer (symmetry axis along $x$), $\\theta$ is the angle to $x$.\n\nYour implementation should:\n1. For each layer, compute the qP phase velocity $v_{\\text{phase}}(\\theta)$ by solving the Christoffel eigenproblem appropriate to the symmetry axis orientation (VTI or HTI) for propagation in the $x\\!-\\!z$ plane, using the defined quantities $A$, $C$, $L$, and $F$ and density $\\rho$.\n2. Compute the anisotropic travel time $T_{\\text{aniso}}$ along the fixed straight path by summing $s_i(\\theta_i)\\,\\ell_i$ across layers, where $\\ell_i = h_i/d_z$ and $s_i(\\theta_i) = 1/v_{\\text{phase},i}(\\theta_i)$.\n3. Compute the isotropic travel time $T_{\\text{iso}}$ along the same path using $s_i^{\\text{iso}} = 1/\\alpha_{0,i}$.\n4. Output the anisotropy-driven timing difference $\\Delta T = T_{\\text{aniso}} - T_{\\text{iso}}$.\n\nUse the following test suite, where all distances are in meters, velocities in meters per second, density in kilograms per cubic meter, angles in radians, and travel times in seconds:\n- Test 1 (single VTI layer, moderate anisotropy, oblique path):\n  - Layers: one VTI layer with $h_1 = 1000$, $\\rho_1 = 2500$, $\\alpha_{0,1} = 3000$, $\\beta_{0,1} = 1500$, $\\epsilon_1 = 0.20$, $\\delta_1 = 0.10$.\n  - Geometry: $X = 1000$, $Z_R = h_1$.\n- Test 2 (two VTI layers, small offset, modest anisotropy):\n  - Layers: \n    - Layer 1 (VTI): $h_1 = 800$, $\\rho_1 = 2400$, $\\alpha_{0,1} = 3200$, $\\beta_{0,1} = 1600$, $\\epsilon_1 = 0.15$, $\\delta_1 = 0.05$.\n    - Layer 2 (VTI): $h_2 = 1200$, $\\rho_2 = 2500$, $\\alpha_{0,2} = 3400$, $\\beta_{0,2} = 1700$, $\\epsilon_2 = 0.10$, $\\delta_2 = 0.02$.\n  - Geometry: $X = 500$, $Z_R = h_1 + h_2$.\n- Test 3 (near-isotropic VTI, oblique path; boundary check):\n  - Layers: one VTI layer with $h_1 = 1500$, $\\rho_1 = 2500$, $\\alpha_{0,1} = 3000$, $\\beta_{0,1} = 1500$, $\\epsilon_1 = 0.00$, $\\delta_1 = 0.00$.\n  - Geometry: $X = 1500$, $Z_R = h_1$.\n- Test 4 (mixed orientations: VTI over HTI, oblique path):\n  - Layers:\n    - Layer 1 (VTI): $h_1 = 800$, $\\rho_1 = 2600$, $\\alpha_{0,1} = 3300$, $\\beta_{0,1} = 1800$, $\\epsilon_1 = 0.25$, $\\delta_1 = 0.05$.\n    - Layer 2 (HTI): $h_2 = 1200$, $\\rho_2 = 2500$, $\\alpha_{0,2} = 3200$, $\\beta_{0,2} = 1700$, $\\epsilon_2 = 0.20$, $\\delta_2 = 0.10$.\n  - Geometry: $X = 2000$, $Z_R = h_1 + h_2$.\n- Test 5 (VTI, vertical path; boundary check):\n  - Layers:\n    - Layer 1 (VTI): $h_1 = 600$, $\\rho_1 = 2500$, $\\alpha_{0,1} = 3100$, $\\beta_{0,1} = 1600$, $\\epsilon_1 = 0.12$, $\\delta_1 = 0.04$.\n    - Layer 2 (VTI): $h_2 = 900$, $\\rho_2 = 2550$, $\\alpha_{0,2} = 3200$, $\\beta_{0,2} = 1650$, $\\epsilon_2 = 0.10$, $\\delta_2 = 0.05$.\n    - Layer 3 (VTI): $h_3 = 500$, $\\rho_3 = 2600$, $\\alpha_{0,3} = 3300$, $\\beta_{0,3} = 1700$, $\\epsilon_3 = 0.08$, $\\delta_3 = 0.03$.\n  - Geometry: $X = 0$, $Z_R = h_1 + h_2 + h_3$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is the timing difference $\\Delta T$ for a test case, rounded to six decimal places in seconds. For example, the output format must be like $[\\Delta T_1,\\Delta T_2,\\dots]$ with each $\\Delta T_i$ a decimal number in seconds.",
            "solution": "The core task involves computing the quasi-P (qP) wave travel time difference between an anisotropic model and its isotropic reference along a prescribed straight-line path through a layered medium. This requires the derivation and solution of the Christoffel equation for transversely isotropic (TI) media.\n\nFirst, we establish the theoretical framework. The travel time $T$ of a wave along a path $\\mathcal{L}$ is given by the eikonal integral:\n$$T = \\int_{\\mathcal{L}} s(\\mathbf{x}, \\mathbf{n}) \\, \\mathrm{d}\\ell$$\nwhere $s$ is the phase slowness, which is the reciprocal of the phase velocity $v_{\\text{phase}}$, and $\\mathrm{d}\\ell$ is the differential arc length. The slowness depends on the location $\\mathbf{x}$ and the propagation direction $\\mathbf{n}$. The problem simplifies this by assuming a horizontally-layered medium and a fixed straight-line path from a source at $(0, 0)$ to a receiver at $(X, Z_R)$. Within each layer $i$, the material properties are constant. The propagation direction is uniform along the entire path. The unit direction vector $\\mathbf{d}$ is:\n$$ \\mathbf{d} = (d_x, d_z) = \\left( \\frac{X}{\\sqrt{X^2 + Z_R^2}}, \\frac{Z_R}{\\sqrt{X^2 + Z_R^2}} \\right) $$\nThe path length $\\ell_i$ within a layer $i$ of thickness $h_i$ is $\\ell_i = h_i / d_z$. The total travel time is a sum over the layers:\n$$ T = \\sum_{i} \\ell_i s_i(\\mathbf{d}) = \\sum_{i} \\frac{h_i}{d_z} \\frac{1}{v_{\\text{phase}, i}(\\mathbf{d})} $$\n\nThe core of the problem is to determine the qP-wave phase velocity $v_{\\text{phase}, i}$ for each layer. This velocity is obtained by solving the eigenvalue problem for the Christoffel matrix $\\mathbf{\\Gamma}$:\n$$ (\\mathbf{\\Gamma} - \\lambda \\mathbf{I})\\mathbf{u} = \\mathbf{0} \\quad \\text{with} \\quad \\lambda = \\rho v_{\\text{phase}}^2 $$\nwhere $\\rho$ is the density, $\\mathbf{u}$ is the polarization vector, and $\\mathbf{I}$ is the identity matrix. For a TI medium with its symmetry axis aligned with the $z$-coordinate axis (VTI), and for wave propagation in the $x$-$z$ plane with direction vector $\\mathbf{n} = (\\sin\\theta, 0, \\cos\\theta)$, where $\\theta$ is the phase angle with respect to the symmetry ($z$) axis, the Christoffel matrix is given by:\n$$ \\mathbf{\\Gamma} = \\begin{pmatrix} C_{11}n_x^2 + C_{55}n_z^2 & 0 & (C_{13}+C_{55})n_x n_z \\\\ 0 & C_{66}n_x^2+C_{55}n_z^2 & 0 \\\\ (C_{13}+C_{55})n_x n_z & 0 & C_{55}n_x^2 + C_{33}n_z^2 \\end{pmatrix} $$\nThe problem provides a parameterization based on Thomsen's parameters $\\epsilon$ and $\\delta$, and vertical P- and S-wave velocities, $\\alpha_0$ and $\\beta_0$. The elastic stiffness constants $C_{ij}$ are related to the provided quantities $A, C, L, F$ as follows: $A = C_{11}$, $C = C_{33}$, $L = C_{55}$, and $F = C_{13}$. The problem uses mass-density scaled versions, which is correct for the formulation $\\lambda = \\rho v^2$. The problem does not require $C_{66}$ or $C_{12}$ as the SH-wave mode (the $(2,2)$ element) decouples and is not of interest.\n\nThe remaining $2 \\times 2$ submatrix governs the coupled qP and quasi-SV (qSV) waves. Its eigenvalues $\\lambda = \\rho v^2$ are found by solving the characteristic equation. The components are:\n$$ \\Gamma_{11} = A\\sin^2\\theta + L\\cos^2\\theta $$\n$$ \\Gamma_{33} = L\\sin^2\\theta + C\\cos^2\\theta $$\n$$ \\Gamma_{13} = (F+L)\\sin\\theta\\cos\\theta $$\nThe two eigenvalues are given by:\n$$ \\lambda_{\\text{qP,qSV}} = \\frac{1}{2} \\left[ (\\Gamma_{11} + \\Gamma_{33}) \\pm \\sqrt{(\\Gamma_{11} - \\Gamma_{33})^2 + 4\\Gamma_{13}^2} \\right] $$\nThe qP-wave corresponds to the larger velocity, hence the larger eigenvalue, which is obtained by taking the positive sign.\n$$ \\lambda_{\\text{qP}} = \\frac{1}{2} \\left[ (\\Gamma_{11} + \\Gamma_{33}) + \\sqrt{(\\Gamma_{11} - \\Gamma_{33})^2 + 4\\Gamma_{13}^2} \\right] $$\nThe qP phase velocity is then $v_{\\text{qP}}(\\theta) = \\sqrt{\\lambda_{\\text{qP}}/\\rho}$.\n\nFor each layer $i$, we perform the following steps:\n1.  Calculate the constant path direction vector components $d_x$ and $d_z$.\n2.  Determine the phase angle $\\theta_i$. The problem specifies two orientations:\n    -   **VTI (Vertical Transverse Isotropy)**: Symmetry axis is vertical ($z$). The angle $\\theta_i$ is between the propagation direction $\\mathbf{d}$ and the $z$-axis. Thus, $\\cos\\theta_i = d_z$ and $\\sin\\theta_i = d_x$.\n    -   **HTI (Horizontal Transverse Isotropy)**: Symmetry axis is horizontal ($x$). The angle $\\theta_i$ is between $\\mathbf{d}$ and the $x$-axis. Thus, $\\cos\\theta_i = d_x$ and $\\sin\\theta_i = d_z$.\n3.  Compute the stiffness-like quantities $C_i, L_i, A_i, F_i$ from the given Thomsen parameters ($\\alpha_{0,i}, \\beta_{0,i}, \\epsilon_i, \\delta_i$) and density $\\rho_i$.\n    $$ C_i = \\rho_i \\alpha_{0,i}^2 $$\n    $$ L_i = \\rho_i \\beta_{0,i}^2 $$\n    $$ A_i = \\rho_i \\alpha_{0,i}^2 (1 + 2\\epsilon_i) $$\n    $$ F_i = -L_i + \\sqrt{(C_i - L_i)^2 + 2\\delta_i C_i (C_i - L_i)} $$\n4.  Substitute these into the expressions for $\\Gamma_{11}, \\Gamma_{33}, \\Gamma_{13}$ to find $\\lambda_{\\text{qP},i}$.\n5.  Calculate the qP phase velocity $v_{\\text{qP},i} = \\sqrt{\\lambda_{\\text{qP},i}/\\rho_i}$.\n6.  The path length in the layer is $\\ell_i = h_i/d_z$. Note that for a vertical path ($X=0$), $d_z=1$ and $\\ell_i = h_i$. For this case, $\\theta_i=0$ for VTI layers, leading to $v_{\\text{qP},i}=\\alpha_{0,i}$ and $\\Delta T = 0$, as expected.\n7.  The anisotropic travel time for the layer is $T_{\\text{aniso},i} = \\ell_i / v_{\\text{qP},i}$.\n8.  The isotropic travel time for the layer is $T_{\\text{iso},i} = \\ell_i / \\alpha_{0,i}$.\n\nThe total times $T_{\\text{aniso}} = \\sum_i T_{\\text{aniso},i}$ and $T_{\\text{iso}} = \\sum_i T_{\\text{iso},i}$ are summed, and the difference $\\Delta T = T_{\\text{aniso}} - T_{\\text{iso}}$ is computed for each test case.\n\nThe computational implementation will encapsulate this logic, processing each test case by iterating through its layers, calculating the layer-specific travel time contributions, and summing them to find the total times and their final difference.\n\nSpecial cases provided as checks are:\n-   **Test 3 (Isotropic limit)**: With $\\epsilon_1=0.00$ and $\\delta_1=0.00$, we must have $A_1=C_1$ and $F_1=C_1-2L_1$. This results in $\\lambda_{\\text{qP},1}=C_1$, which means $v_{\\text{qP},1}=\\alpha_{0,1}$ for all angles. Consequently, $T_{\\text{aniso}} = T_{\\text{iso}}$ and $\\Delta T$ must be $0$.\n-   **Test 5 (Vertical incidence)**: With $X=0$, the path is vertical. For VTI layers, the propagation is along the symmetry axis ($\\theta=0$). This yields $v_{\\text{qP},i}=\\alpha_{0,i}$, so again, $T_{\\text{aniso}} = T_{\\text{iso}}$ and $\\Delta T$ must be $0$.\n\nThese checks confirm the correctness of the formulation and its implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the travel time difference between anisotropic and isotropic models\n    for qP-waves along a straight path in layered VTI/HTI media.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Structure: (geometry, layers_data)\n    # geometry: (X, Z_R)\n    # layers_data: list of (h, rho, alpha0, beta0, epsilon, delta, type_str)\n    test_cases = [\n        # Test 1\n        (\n            {\"X\": 1000, \"Z_R\": 1000},\n            [\n                {\"h\": 1000, \"rho\": 2500, \"alpha0\": 3000, \"beta0\": 1500, \"epsilon\": 0.20, \"delta\": 0.10, \"type\": \"VTI\"}\n            ]\n        ),\n        # Test 2\n        (\n            {\"X\": 500, \"Z_R\": 2000},\n            [\n                {\"h\": 800,  \"rho\": 2400, \"alpha0\": 3200, \"beta0\": 1600, \"epsilon\": 0.15, \"delta\": 0.05, \"type\": \"VTI\"},\n                {\"h\": 1200, \"rho\": 2500, \"alpha0\": 3400, \"beta0\": 1700, \"epsilon\": 0.10, \"delta\": 0.02, \"type\": \"VTI\"}\n            ]\n        ),\n        # Test 3\n        (\n            {\"X\": 1500, \"Z_R\": 1500},\n            [\n                {\"h\": 1500, \"rho\": 2500, \"alpha0\": 3000, \"beta0\": 1500, \"epsilon\": 0.00, \"delta\": 0.00, \"type\": \"VTI\"}\n            ]\n        ),\n        # Test 4\n        (\n            {\"X\": 2000, \"Z_R\": 2000},\n            [\n                {\"h\": 800,  \"rho\": 2600, \"alpha0\": 3300, \"beta0\": 1800, \"epsilon\": 0.25, \"delta\": 0.05, \"type\": \"VTI\"},\n                {\"h\": 1200, \"rho\": 2500, \"alpha0\": 3200, \"beta0\": 1700, \"epsilon\": 0.20, \"delta\": 0.10, \"type\": \"HTI\"}\n            ]\n        ),\n        # Test 5\n         (\n            {\"X\": 0, \"Z_R\": 2000},\n            [\n                {\"h\": 600, \"rho\": 2500, \"alpha0\": 3100, \"beta0\": 1600, \"epsilon\": 0.12, \"delta\": 0.04, \"type\": \"VTI\"},\n                {\"h\": 900, \"rho\": 2550, \"alpha0\": 3200, \"beta0\": 1650, \"epsilon\": 0.10, \"delta\": 0.05, \"type\": \"VTI\"},\n                {\"h\": 500, \"rho\": 2600, \"alpha0\": 3300, \"beta0\": 1700, \"epsilon\": 0.08, \"delta\": 0.03, \"type\": \"VTI\"}\n            ]\n        )\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        geometry, layers_data = case\n        X, Z_R = geometry[\"X\"], geometry[\"Z_R\"]\n\n        if X == 0 and Z_R == 0:\n            results.append(0.0)\n            continue\n        \n        path_length_total = np.sqrt(X**2 + Z_R**2)\n        \n        # Handle vertical path as a special case to avoid division by zero if X is used.\n        if path_length_total == 0:\n            results.append(0.0)\n            continue\n\n        d_x = X / path_length_total\n        d_z = Z_R / path_length_total\n\n        total_t_aniso = 0.0\n        total_t_iso = 0.0\n        \n        # For vertical path, dz=1, path_length_in_layer = h.\n        # For horizontal path, this model is ill-defined (h/dz -> inf).\n        # We assume Z_R > 0 for all cases as per problem description.\n        if d_z == 0:\n            # This case is not in the test suite, but would be a singularity.\n            # We can skip or raise an error. Here we assume non-horizontal paths.\n            results.append(np.nan) # Or handle as per a more detailed spec.\n            continue\n            \n        for layer in layers_data:\n            h = layer[\"h\"]\n            rho = layer[\"rho\"]\n            alpha0 = layer[\"alpha0\"]\n            beta0 = layer[\"beta0\"]\n            epsilon = layer[\"epsilon\"]\n            delta = layer[\"delta\"]\n            orientation = layer[\"type\"]\n\n            path_length_in_layer = h / d_z\n\n            # Isotropic Travel Time Contribution\n            total_t_iso += path_length_in_layer / alpha0\n\n            # Anisotropic Travel Time Contribution\n            if orientation == \"VTI\":  # Symmetry axis is z\n                cos_theta = d_z\n                sin_theta = d_x\n            elif orientation == \"HTI\":  # Symmetry axis is x\n                cos_theta = d_x\n                sin_theta = d_z\n            else:\n                raise ValueError(f\"Unknown orientation: {orientation}\")\n\n            # Calculate stiffness-like quantities\n            C = rho * alpha0**2\n            L = rho * beta0**2\n            A = rho * alpha0**2 * (1 + 2 * epsilon)\n            \n            F_term_sqrt = (C - L)**2 + 2 * delta * C * (C - L)\n            if F_term_sqrt < 0:\n                raise ValueError(\"Unphysical parameters: negative term in F calculation.\")\n            F = -L + np.sqrt(F_term_sqrt)\n\n            # Christoffel matrix components for qP-qSV\n            sin2_theta = sin_theta**2\n            cos2_theta = cos_theta**2\n\n            gamma_11 = A * sin2_theta + L * cos2_theta\n            gamma_33 = L * sin2_theta + C * cos2_theta\n            gamma_13 = (F + L) * sin_theta * cos_theta\n            \n            # Solve for qP eigenvalue\n            term1 = gamma_11 + gamma_33\n            sqrt_term = np.sqrt((gamma_11 - gamma_33)**2 + 4 * gamma_13**2)\n            \n            lambda_qp = 0.5 * (term1 + sqrt_term)\n            \n            # Calculate qP phase velocity\n            v_qp = np.sqrt(lambda_qp / rho)\n\n            total_t_aniso += path_length_in_layer / v_qp\n\n        delta_T = total_t_aniso - total_t_iso\n        results.append(delta_T)\n\n    # Format output as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While calculating traveltime along a predefined path is useful, a more powerful tool is to compute the entire first-arrival traveltime field from a source. This requires solving the anisotropic eikonal equation, a fundamental Hamilton-Jacobi equation in computational geophysics. In this advanced practice, you will implement the Fast Marching Method (FMM) to solve the eikonal equation for an elliptically anisotropic medium . By deriving the necessary upwind numerical scheme and comparing your results to an analytical solution, you will build a robust and efficient tool for traveltime tomography and seismic migration, bridging the gap between local velocity analysis and global wavefield modeling.",
            "id": "3575979",
            "problem": "You are asked to implement a complete numerical solver for anisotropic travel-time computation in two-dimensional computational geophysics at the advanced graduate level. You must work from first principles of high-frequency asymptotics and Hamilton–Jacobi theory, derive a monotone upwind discretization for the anisotropic eikonal equation induced by transverse isotropy, and code a Fast Marching Method (FMM) to compute first-arrival traveltimes. You will verify the computed traveltimes by comparison to anisotropic rays in homogeneous elliptical vertical and horizontal transverse isotropy.\n\nThe fundamental base is as follows. In high-frequency asymptotics of wave propagation, the traveltime field $T(\\mathbf{x})$ satisfies a Hamilton–Jacobi equation with Hamiltonian $H(\\mathbf{x},\\mathbf{p})$ derived from the dispersion relation. For acoustic quasi-compressional (qP) waves in a transversely isotropic medium, the geometric-optics eikonal in two spatial dimensions $\\mathbf{x}=(x,z)$ can be written in the form\n$$\nH(\\mathbf{x},\\mathbf{p}) \\;=\\; \\omega \\;-\\; C\\!\\left(\\hat{\\mathbf{p}}\\right)\\, \\lVert \\mathbf{p}\\rVert \\;=\\; 0,\n$$\nwhere $\\omega$ is angular frequency, $\\mathbf{p}=\\nabla T(\\mathbf{x})$ is the slowness covector, $\\hat{\\mathbf{p}} = \\mathbf{p}/\\lVert \\mathbf{p}\\rVert$ is the phase-direction unit vector, and $C(\\hat{\\mathbf{p}})$ is the qP phase velocity as a function of phase direction. For the purposes of this problem, restrict to homogeneous, elliptical transverse isotropy so that the qP phase velocity is directionally quadratic. Specifically, let the symmetry be vertical (vertical transverse isotropy (VTI)) or horizontal (horizontal transverse isotropy (HTI)), and for both cases specialize to the elliptical limit of the quasi-compressional phase velocity. In two dimensions, this implies\n$$\nC(\\hat{\\mathbf{p}}) \\;=\\; \\sqrt{ V_x^2\\, \\hat{p}_x^2 \\;+\\; V_z^2\\, \\hat{p}_z^2 },\n$$\nwith constant directional phase speeds $V_x$ and $V_z$ along the horizontal and vertical axes respectively. Setting $\\omega=1$ reduces the eikonal to\n$$\nC\\!\\left(\\frac{\\nabla T}{\\lVert \\nabla T\\rVert}\\right)\\, \\lVert \\nabla T\\rVert \\;=\\; 1,\n$$\nwhich, for the elliptical phase-velocity given above, is equivalent to the quadratic anisotropic eikonal\n$$\nV_x^2\\, T_x^2 \\;+\\; V_z^2\\, T_z^2 \\;=\\; 1,\n$$\nwhere $T_x=\\partial T/\\partial x$ and $T_z=\\partial T/\\partial z$. This is a convex Hamilton–Jacobi equation suitable for a monotone upwind discretization and a Fast Marching Method.\n\nYour tasks are:\n\n- Derive from the Hamilton–Jacobi equation a consistent, monotone, upwind, pointwise discretization on a Cartesian grid with spacing $\\Delta x$ and $\\Delta z$ suitable for use in a Fast Marching Method (FMM). You must start from the basic equation $V_x^2\\, T_x^2 + V_z^2\\, T_z^2 = 1$ and use one-sided upwind finite differences aligned with the causality of viscosity solutions. Do not assume any shortcut formulas a priori.\n- Implement an FMM to compute the traveltime field $T$ from a point source in a homogeneous elliptical VTI or HTI medium, using only accepted neighbors in the local update.\n- Compute anisotropic ray traveltimes in the same homogeneous media by solving the bicharacteristic equations for the same Hamiltonian and initial data. You may do this analytically for homogeneous elliptical transverse isotropy or by an equivalent consistent numerical characteristic integration. Express traveltimes in seconds (s), rounded only by the inherent floating-point arithmetic of your implementation.\n- Compare the FMM traveltimes to the anisotropic ray traveltimes at selected receiver locations, and return the maximum absolute discrepancy for each test case in seconds (s) as a floating-point number.\n\nUse the following test suite. In all cases, the computational domain is a rectangular Cartesian grid of size $N_x \\times N_z$ with uniform spacings $\\Delta x$ and $\\Delta z$ in meters (m). The point source is placed at the central grid index. Angles, where mentioned for description, are not required in the computation; the receivers are given directly by coordinates.\n\n- Test Case A (Happy path, VTI elliptical): Let $V_{p0} = 2000$ m/s and weak-anisotropy Thomsen parameters satisfy the elliptical condition for qP, so that $V_x = V_{p0}\\,\\sqrt{1+2\\epsilon}$ and $V_z = V_{p0}$ with $\\epsilon=\\delta=0.30$. Use $N_x=N_z=161$, $\\Delta x=\\Delta z=5$ m. Source at the central grid node. Compare traveltimes at three receivers with offsets relative to the source: $(x,z) = (300 \\text{ m}, 0 \\text{ m})$, $(x,z) = (300 \\text{ m}, 300 \\text{ m})$, and $(x,z) = (300 \\text{ m}, 200 \\text{ m})$. Your program must compute the maximum absolute difference between the FMM traveltime and the anisotropic ray traveltime over these three points, in seconds (s).\n- Test Case B (Boundary/isotropic limit): Let $V_x=V_z=V_{p0}=2500$ m/s, $N_x=N_z=101$, $\\Delta x=\\Delta z=5$ m. Source at the central grid node. Compare traveltimes at receiver $(x,z)=(200 \\text{ m},160 \\text{ m})$. Return the absolute difference between FMM and ray traveltimes in seconds (s).\n- Test Case C (HTI elliptical): Let $V_{p0}=2200$ m/s and $\\epsilon=\\delta=0.25$ in the elliptical qP limit but with horizontal symmetry axis, i.e., $V_x = V_{p0}$ and $V_z = V_{p0}\\,\\sqrt{1+2\\epsilon}$. Use $N_x=N_z=161$, $\\Delta x=\\Delta z=5$ m. Source at the central grid node. Compare traveltimes at two receivers $(x,z)=(200 \\text{ m}, 350 \\text{ m})$ and $(x,z)=(0 \\text{ m}, 300 \\text{ m})$. Return the maximum absolute difference between FMM and ray traveltimes in seconds (s).\n\nPhysical and numerical units:\n- All distances must be in meters (m).\n- All velocities must be in meters per second (m/s).\n- All traveltimes must be in seconds (s).\n- No angle units are required, since receiver coordinates are given explicitly; if you internally use angles, they must be in radians.\n\nFinal output specification:\n- Your program must produce a single line of output containing the results for Test Cases A, B, and C as a comma-separated list enclosed in square brackets, e.g., \"[$r_A$,$r_B$,$r_C$]\" where each $r$ is a floating-point number in seconds (s).\n- The results must be aggregated in the order A, B, C.\n- Each result must be a single floating-point number.\n\nDesign for coverage:\n- Test Case A exercises a general off-axis VTI elliptical anisotropy.\n- Test Case B checks the isotropic consistency limit and acts as a boundary condition sanity check.\n- Test Case C exercises HTI elliptical anisotropy with strong directional contrast and includes a near-vertical path.\n\nYour implementation must be self-contained and must not read input. The code must be a complete, runnable program.",
            "solution": "### 1. Problem Formulation\nThe traveltime $T(\\mathbf{x})$ of a high-frequency acoustic quasi-compressional (qP) wave in a two-dimensional homogeneous medium with elliptical transverse isotropy (VTI or HTI) is governed by the anisotropic eikonal equation:\n$$\nV_x^2 \\left(\\frac{\\partial T}{\\partial x}\\right)^2 + V_z^2 \\left(\\frac{\\partial T}{\\partial z}\\right)^2 = 1\n$$\nHere, $T_x = \\frac{\\partial T}{\\partial x}$ and $T_z = \\frac{\\partial T}{\\partial z}$ are the components of the slowness vector $\\mathbf{p}=\\nabla T$, and $V_x$ and $V_z$ are the constant phase velocities along the horizontal ($x$) and vertical ($z$) axes, respectively. This is a first-order, non-linear partial differential equation of Hamilton-Jacobi type.\n\n### 2. Analytical Solution for Homogeneous Media (Verification Benchmark)\nFor verification, we require the exact traveltime in a homogeneous medium. This can be derived from the characteristic (ray) equations. The Hamiltonian is $H(\\mathbf{p}) = \\sqrt{V_x^2 p_x^2 + V_z^2 p_z^2}$, and the ray path is governed by $\\frac{d\\mathbf{x}}{d\\tau} = \\mathbf{v}_g = \\nabla_{\\mathbf{p}}H$, where $\\mathbf{v}_g$ is the group velocity. The group velocity components are:\n$$\nv_{gx} = \\frac{\\partial H}{\\partial p_x} = \\frac{V_x^2 p_x}{\\sqrt{V_x^2 p_x^2 + V_z^2 p_z^2}}, \\quad v_{gz} = \\frac{\\partial H}{\\partial p_z} = \\frac{V_z^2 p_z}{\\sqrt{V_x^2 p_x^2 + V_z^2 p_z^2}}\n$$\nOn the manifold where traveltime is defined, the eikonal equation $V_x^2 p_x^2 + V_z^2 p_z^2 = 1$ holds. This implies the denominator in the group velocity expressions is $1$, so $v_{gx} = V_x^2 p_x$ and $v_{gz} = V_z^2 p_z$.\n\nIn a homogeneous medium, the slowness vector $\\mathbf{p}$ is constant along a ray, making the group velocity constant and the ray path a straight line. For a ray traveling from a source $(x_s, z_s)$ to a receiver $(x_r, z_r)$ in time $\\tau$, the displacement is $(\\Delta x, \\Delta z) = (x_r - x_s, z_r - z_s) = (v_{gx}\\tau, v_{gz}\\tau)$. We can express the slowness components in terms of the traveltime $\\tau$ and displacement:\n$$\np_x = \\frac{\\Delta x}{V_x^2 \\tau}, \\quad p_z = \\frac{\\Delta z}{V_z^2 \\tau}\n$$\nSubstituting these into the eikonal equation:\n$$\nV_x^2 \\left(\\frac{\\Delta x}{V_x^2 \\tau}\\right)^2 + V_z^2 \\left(\\frac{\\Delta z}{V_z^2 \\tau}\\right)^2 = 1\n$$\n$$\n\\frac{\\Delta x^2}{V_x^2 \\tau^2} + \\frac{\\Delta z^2}{V_z^2 \\tau^2} = 1\n$$\nSolving for the traveltime $\\tau$ yields the analytical solution:\n$$\n\\tau_{\\text{ray}} = \\sqrt{\\frac{\\Delta x^2}{V_x^2} + \\frac{\\Delta z^2}{V_z^2}}\n$$\nThis formula provides the exact first-arrival traveltime and will be used as the ground truth for verifying our numerical solution.\n\n### 3. Numerical Method: The Fast Marching Method (FMM)\nThe Fast Marching Method (FMM) is an efficient algorithm for solving the eikonal equation on a grid. It systematically computes the traveltime field by propagating the wavefront outwards from the source, mimicking Huygens' principle. The core of the FMM is a monotone upwind discretization of the PDE and a min-priority queue to manage the advancing wavefront.\n\n#### 3.1. Upwind Discretization of the Eikonal Equation\nWe discretize the domain on a Cartesian grid with spacings $\\Delta x$ and $\\Delta z$. Let $T_{i,j}$ be the unknown traveltime at grid node $(i,j)$. The upwind principle dictates that the solution at a point should only depend on neighbors with smaller traveltimes. In FMM, these are the `KNOWN` neighbors.\n\nAt a node $(i,j)$ being updated, we consider the minimum traveltimes from `KNOWN` neighbors in the $x$ and $z$ directions:\n$$\nt_x = \\min(T_{i-1,j}, T_{i+1,j})\n$$\n$$\nt_z = \\min(T_{i,j-1}, T_{i,j+1})\n$$\nwhere only `KNOWN` neighbors with finite times are considered in the `min` operation. The partial derivatives are approximated using one-sided differences pointing away from the direction of minimal time:\n$$\n|T_x| \\approx \\frac{T_{i,j} - t_x}{\\Delta x}, \\quad |T_z| \\approx \\frac{T_{i,j} - t_z}{\\Delta z}\n$$\nSubstituting these approximations into the eikonal equation gives a discrete version:\n$$\nV_x^2 \\left(\\frac{T_{i,j} - t_x}{\\Delta x}\\right)^2 + V_z^2 \\left(\\frac{T_{i,j} - t_z}{\\Delta z}\\right)^2 = 1\n$$\nThis is a quadratic equation for the unknown time $T_{i,j}$. Let $T \\equiv T_{i,j}$, $u_x = (V_x/\\Delta x)^2$, and $u_z = (V_z/\\Delta z)^2$. The equation is:\n$$\n(u_x + u_z)T^2 - 2(u_x t_x + u_z t_z)T + (u_x t_x^2 + u_z t_z^2 - 1) = 0\n$$\nSolving this quadratic equation gives a candidate traveltime for an update considering information from both axes (a 2D update).\n\n#### 3.2. Local Update Scheme: 1D vs. 2D Update\nA crucial aspect of the discretization is determining whether the characteristic reaching node $(i,j)$ comes from an axial direction (1D update) or a corner direction (2D update). This can be decided by a causality condition. Assume without loss of generality that $t_x \\le t_z$.\n1.  First, consider a purely 1D update from the $x$-direction. The traveltime would be $t'_{cand} = t_x + \\Delta x/V_x$.\n2.  If this candidate time is less than or equal to $t_z$, i.e., $t_x + \\Delta x/V_x \\le t_z$, it implies that the wavefront advancing from the $x$-neighbor reaches the node's line segment before the wavefront from the $z$-neighbor. The information from the $z$-neighbor is causally disconnected. Thus, the update is purely 1D, and the new time is $T_{i,j} = t_x + \\Delta x/V_x$.\n3.  A similar argument holds if $t_z < t_x$: if a 1D update $t_z + \\Delta z/V_z \\le t_x$, the time is $T_{i,j} = t_z + \\Delta z/V_z$.\n4.  If neither of these 1D conditions is met, the wavefront arrives from the corner between the $x$ and $z$ neighbors. The update is 2D, and the new time $T_{i,j}$ is the larger root of the quadratic equation derived above.\n\n#### 3.3. Algorithm Outline\nThe FMM algorithm proceeds as follows:\n1.  **Initialization**:\n    - Create a traveltime grid $T$, initialized to infinity, and a state grid `status`, initialized to `FAR`.\n    - Set the source node $(i_s, j_s)$ time to $T_{i_s,j_s}=0$ and its state to `KNOWN`.\n    - For each of the four axial neighbors of the source, calculate an initial time based on the analytical formula for small displacements (e.g., $T = \\Delta x/V_x$ for an $x$-neighbor). Set their state to `TRIAL` and add them to a min-priority queue (min-heap), ordered by traveltime.\n2.  **Main Loop**: While the priority queue is not empty:\n    - Extract the `TRIAL` node $(i,j)$ with the minimum traveltime.\n    - If its state is already `KNOWN`, discard it and continue. Otherwise, change its state to `KNOWN`.\n    - For each neighbor $(i',j')$ of $(i,j)$ that is not `KNOWN`:\n        - Calculate a new candidate time $T_{new}$ for $(i',j')$ using the local update scheme (Section 3.2), considering all `KNOWN` neighbors of $(i',j')$.\n        - If $T_{new}$ is less than the current time at $(i',j')$, update the time $T_{i',j'} = T_{new}$, change its state to `TRIAL`, and push it onto the priority queue.\n3.  **Termination**: The algorithm terminates when the priority queue is empty, at which point all reachable nodes have their correct first-arrival traveltimes.\n\n### 4. Implementation and Verification\nThe described FMM algorithm is implemented in Python using `numpy` for grid operations and `heapq` for the min-priority queue. For each test case, the FMM is run to compute the traveltime field $T$. The FMM-computed time at each specified receiver location, $T_{FMM}$, is then compared against the analytical ray traveltime, $\\tau_{\\text{ray}}$, calculated from the formula in Section 2. The maximum absolute difference $|T_{FMM} - \\tau_{\\text{ray}}|$ is reported for each test case as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\n# Global constants for FMM states\nFAR = 0\nTRIAL = 1\nKNOWN = 2\n\ndef solve_local_update(tx, tz, vx, vz, hx, hz):\n    \"\"\"\n    Computes the FMM update at a point based on neighbor times tx and tz.\n    This implements the logic for 1D vs 2D anisotropic updates.\n\n    Args:\n        tx (float): Minimum time from KNOWN neighbors in x-direction.\n        tz (float): Minimum time from KNOWN neighbors in z-direction.\n        vx (float): Velocity in x-direction.\n        vz (float): Velocity in z-direction.\n        hx (float): Grid spacing in x-direction.\n        hz (float): Grid spacing in z-direction.\n\n    Returns:\n        float: The updated traveltime.\n    \"\"\"\n    # Case 1: Only one neighbor is available (the other is inf).\n    # Update is purely 1D.\n    if np.isinf(tx):\n        return tz + hz / vz\n    if np.isinf(tz):\n        return tx + hx / vx\n\n    # Case 2: Both neighbors are available. Check for 1D update condition.\n    # Try a 1D update from the x-direction.\n    t_cand_x = tx + hx / vx\n    if t_cand_x <= tz:\n        return t_cand_x\n    \n    # Try a 1D update from the z-direction.\n    t_cand_z = tz + hz / vz\n    if t_cand_z <= tx:\n        return t_cand_z\n\n    # Case 3: Neither 1D condition met. A 2D update is required.\n    # Solve the quadratic equation: A*T^2 + B*T + C = 0.\n    ax_sq = (vx / hx)**2\n    az_sq = (vz / hz)**2\n    \n    A = ax_sq + az_sq\n    B = -2 * (ax_sq * tx + az_sq * tz)\n    C = ax_sq * tx**2 + az_sq * tz**2 - 1.0\n    \n    discriminant = B**2 - 4 * A * C\n    \n    # The causality conditions (1D checks) ensure discriminant is non-negative.\n    # A small negative value can occur due to floating point arithmetic.\n    if discriminant < 0:\n        return min(t_cand_x, t_cand_z)\n\n    # Return the larger, causally correct root\n    t_new = (-B + np.sqrt(discriminant)) / (2 * A)\n    return t_new\n\n\ndef fast_marching_method(nx, nz, hx, hz, src_idx, vx, vz):\n    \"\"\"\n    Computes the first-arrival traveltime field using the Fast Marching Method\n    for the anisotropic eikonal equation.\n\n    Args:\n        nx, nz (int): Grid dimensions.\n        hx, hz (float): Grid spacings.\n        src_idx (tuple): (ix, iz) indices of the source.\n        vx, vz (float): Anisotropic phase velocities.\n\n    Returns:\n        numpy.ndarray: The computed traveltime field.\n    \"\"\"\n    times = np.full((nx, nz), np.inf, dtype=np.float64)\n    states = np.full((nx, nz), FAR, dtype=np.int8)\n    \n    trial_heap = []\n\n    src_ix, src_iz = src_idx\n    times[src_ix, src_iz] = 0.0\n    states[src_ix, src_iz] = KNOWN\n    \n    # Initialize the source's immediate axial neighbors\n    for dx, dz in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        ix, iz = src_ix + dx, src_iz + dz\n        if 0 <= ix < nx and 0 <= iz < nz:\n            # For axial neighbors, group velocity equals phase velocity.\n            t_initial = np.sqrt( (dx * hx / vx)**2 + (dz * hz / vz)**2 )\n            times[ix, iz] = t_initial\n            states[ix, iz] = TRIAL\n            heapq.heappush(trial_heap, (t_initial, ix, iz))\n\n    # Main FMM loop\n    while trial_heap:\n        t_min, ix, iz = heapq.heappop(trial_heap)\n        \n        if states[ix, iz] == KNOWN:\n            continue\n        \n        states[ix, iz] = KNOWN\n\n        # Update neighbors of the newly KNOWN point\n        for dx, dz in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ix_nb, iz_nb = ix + dx, iz + dz\n            \n            if not (0 <= ix_nb < nx and 0 <= iz_nb < nz) or states[ix_nb, iz_nb] == KNOWN:\n                continue\n\n            # Find minimum time from KNOWN neighbors in each direction\n            tx_known = min(times[ix_nb - 1, iz_nb] if ix_nb > 0 and states[ix_nb - 1, iz_nb] == KNOWN else np.inf,\n                           times[ix_nb + 1, iz_nb] if ix_nb < nx - 1 and states[ix_nb + 1, iz_nb] == KNOWN else np.inf)\n\n            tz_known = min(times[ix_nb, iz_nb - 1] if iz_nb > 0 and states[ix_nb, iz_nb - 1] == KNOWN else np.inf,\n                           times[ix_nb, iz_nb + 1] if iz_nb < nz - 1 and states[ix_nb, iz_nb + 1] == KNOWN else np.inf)\n\n            if np.isinf(tx_known) and np.isinf(tz_known):\n                continue\n                \n            t_new = solve_local_update(tx_known, tz_known, vx, vz, hx, hz)\n\n            if t_new < times[ix_nb, iz_nb]:\n                times[ix_nb, iz_nb] = t_new\n                states[ix_nb, iz_nb] = TRIAL\n                heapq.heappush(trial_heap, (t_new, ix_nb, iz_nb))\n                \n    return times\n\ndef analytical_ray_time(dx, dz, vx, vz):\n    \"\"\"\n    Computes analytical traveltime in a homogeneous elliptical medium.\n    \"\"\"\n    return np.sqrt((dx / vx)**2 + (dz / vz)**2)\n\n\ndef run_test_case(params):\n    \"\"\"\n    Runs a single test case: computes FMM and analytical times and compares them.\n    \"\"\"\n    nx, nz = params['N']\n    hx, hz = params['d']\n    vp0, epsilon = params['vp0'], params['epsilon']\n    rcv_offsets = params['receivers']\n    anisotropy_type = params['type']\n    \n    # Calculate velocities\n    if anisotropy_type == 'VTI':\n        vx = vp0 * np.sqrt(1 + 2 * epsilon)\n        vz = vp0\n    elif anisotropy_type == 'HTI':\n        vx = vp0\n        vz = vp0 * np.sqrt(1 + 2 * epsilon)\n    else: # Isotropic\n        vx, vz = vp0, vp0\n\n    # Source at central grid node\n    src_idx = (nx // 2, nz // 2)\n\n    # Run FMM\n    fmm_times = fast_marching_method(nx, nz, hx, hz, src_idx, vx, vz)\n\n    # Compare at receiver locations\n    discrepancies = []\n    for rcv_off_x, rcv_off_z in rcv_offsets:\n        # Receiver grid index\n        rcv_ix = src_idx[0] + int(round(rcv_off_x / hx))\n        rcv_iz = src_idx[1] + int(round(rcv_off_z / hz))\n\n        # Get FMM time\n        t_fmm = fmm_times[rcv_ix, rcv_iz]\n\n        # Get analytical time\n        t_ray = analytical_ray_time(rcv_off_x, rcv_off_z, vx, vz)\n        \n        discrepancies.append(np.abs(t_fmm - t_ray))\n        \n    return max(discrepancies)\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run them, and print results.\n    \"\"\"\n    test_cases = [\n        { # Test Case A\n            'N': (161, 161), 'd': (5.0, 5.0), 'vp0': 2000.0, 'epsilon': 0.30,\n            'type': 'VTI',\n            'receivers': [(300.0, 0.0), (300.0, 300.0), (300.0, 200.0)]\n        },\n        { # Test Case B\n            'N': (101, 101), 'd': (5.0, 5.0), 'vp0': 2500.0, 'epsilon': 0.0,\n            'type': 'Isotropic', \n            'receivers': [(200.0, 160.0)]\n        },\n        { # Test Case C\n            'N': (161, 161), 'd': (5.0, 5.0), 'vp0': 2200.0, 'epsilon': 0.25,\n            'type': 'HTI',\n            'receivers': [(200.0, 350.0), (0.0, 300.0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(case)\n        results.append(result)\n        \n    # Python 3.8+ f-string formatting for float\n    print(f\"[{','.join(f'{r}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}