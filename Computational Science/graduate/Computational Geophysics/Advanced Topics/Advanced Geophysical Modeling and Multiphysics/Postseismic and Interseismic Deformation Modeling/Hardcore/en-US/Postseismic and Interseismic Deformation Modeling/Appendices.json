{
    "hands_on_practices": [
        {
            "introduction": "The Maxwell model provides a first-order approximation of the viscoelastic behavior of Earth's lower crust and upper mantle. Accurately simulating the process of stress relaxation following a sudden, earthquake-induced strain change is a foundational skill in postseismic deformation modeling. This exercise  guides you through deriving the governing equation for stress relaxation and implementing a high-accuracy spectral method to solve it, providing a robust tool for fundamental viscoelastic simulations.",
            "id": "3613099",
            "problem": "Consider one-dimensional viscoelastic stress relaxation in a homogeneous Maxwell bar subjected to an imposed step strain at time $t=0$. In postseismic deformation modeling, the Maxwell constitutive model connects the elastic spring and viscous dashpot in series, relevant to the lower crust and upper mantle rheology after a coseismic stress change. Let $E$ denote the elastic modulus in pascals, $\\eta$ denote the viscosity in pascal-seconds, and $\\varepsilon(t)$ denote the total strain. Define the stress as $\\sigma(t)$, which is spatially uniform in a one-dimensional bar and evolves over time according to the standard Maxwell model. The exact solution for stress relaxation following a step strain is known to be exponential in time, which you should use to verify numerical accuracy; do not assume any shortcut formulas in your implementation.\n\nStarting only from the fundamental definitions and laws of linear viscoelasticity for a Maxwell element in series, derive the governing ordinary differential equation for $\\sigma(t)$ under an imposed step strain $\\varepsilon(t)=\\varepsilon_0 H(t)$, where $H(t)$ is the Heaviside step function and $\\varepsilon_0$ is a constant. Then, implement a global spectral collocation method in time using Chebyshev-Gauss-Lobatto (CGL) points on the closed interval $[0,T]$ to solve the resulting initial value problem for $\\sigma(t)$, where $T0$ is a fixed final time in seconds. Use a Chebyshev differentiation matrix to approximate the time derivative, and enforce the initial condition at $t=0$ using a tau-enforcement row replacement so that the collocated solution satisfies the initial stress exactly at the $t=0$ node. Map the CGL points from $[-1,1]$ to $[0,T]$ using an affine transformation, and assemble and solve the resulting linear system for the stress values at the collocation points.\n\nScientific and numerical requirements:\n- Derive the Maxwell ordinary differential equation from the constitutive laws of the elastic spring and viscous dashpot in series. Express all formulas in terms of $E$, $\\eta$, $\\varepsilon(t)$, and $\\sigma(t)$.\n- Construct the Chebyshev-Gauss-Lobatto nodes $x_k=\\cos\\left(\\frac{\\pi k}{N-1}\\right)$ for $k=0,1,\\dots,N-1$, map them to time $t_k \\in [0,T]$ via $t_k = \\frac{T}{2}(x_k+1)$, and build the first-order Chebyshev differentiation matrix $D$ on $[-1,1]$ with the property that for $i\\neq j$, $D_{ij}$ is consistent with the exact derivative of the Lagrange interpolants at the CGL nodes. Use the affine scaling to obtain the time differentiation matrix $\\frac{2}{T}D$.\n- Form the linear system for the collocated unknowns $\\sigma(t_k)$, and impose the initial condition $\\sigma(0)$ by replacing the row of the system corresponding to $t=0$ with the identity row, setting the right-hand side to the prescribed initial stress.\n- Verify the numerical solution against the exact exponential solution by computing the maximum-norm error over the CGL nodes,\n$$\ne_\\infty(N) = \\max_{k} \\left|\\sigma_{\\text{num}}(t_k) - \\sigma_{\\text{exact}}(t_k)\\right|,\n$$\nwith stress in pascals. Assess spectral convergence by evaluating the empirical base factor of exponential decay $a$ between two consecutive discretizations $N_1N_2$ via\n$$\na \\approx \\left(\\frac{e_\\infty(N_2)}{e_\\infty(N_1)}\\right)^{\\frac{1}{N_2 - N_1}},\n$$\nwhich is unitless.\n\nUnits:\n- Elastic modulus $E$ in pascals ($\\mathrm{Pa}$).\n- Viscosity $\\eta$ in pascal-seconds ($\\mathrm{Pa\\cdot s}$).\n- Strain $\\varepsilon_0$ is dimensionless.\n- Time $t$ and $T$ in seconds ($\\mathrm{s}$).\n- Stress $\\sigma$ and errors $e_\\infty(N)$ in pascals ($\\mathrm{Pa}$).\n\nYour implementation must be a complete, runnable program. It must compute the numerical solution for several discretization sizes $N$ and compare it to the exact solution, reporting the error and the empirical exponential convergence factor.\n\nTest suite:\n- Use the following three test cases, each evaluated at discretization sizes $N \\in \\{8,16,32,64\\}$.\n    1. Case A (happy path): $E = 3.0\\times 10^{10}\\ \\mathrm{Pa}$, $\\eta = 3.0\\times 10^{18}\\ \\mathrm{Pa\\cdot s}$, $\\varepsilon_0 = 1.0\\times 10^{-5}$, $T=1.0\\times 10^{7}\\ \\mathrm{s}$.\n    2. Case B (fast relaxation, edge): $E = 3.0\\times 10^{10}\\ \\mathrm{Pa}$, $\\eta = 3.0\\times 10^{16}\\ \\mathrm{Pa\\cdot s}$, $\\varepsilon_0 = 1.0\\times 10^{-5}$, $T=1.0\\times 10^{7}\\ \\mathrm{s}$.\n    3. Case C (slow relaxation, boundary): $E = 3.0\\times 10^{10}\\ \\mathrm{Pa}$, $\\eta = 3.0\\times 10^{20}\\ \\mathrm{Pa\\cdot s}$, $\\varepsilon_0 = 1.0\\times 10^{-5}$, $T=1.0\\times 10^{7}\\ \\mathrm{s}$.\n\nFor each case, compute the maximum-norm errors $e_\\infty(N)$ for the four values of $N$ and the empirical spectral decay base factor $a$ using $N_1=32$ and $N_2=64$. The final output must be a single line containing a Python list with three inner lists, one per test case, where each inner list is\n$$\n[\\ e_\\infty(8),\\ e_\\infty(16),\\ e_\\infty(32),\\ e_\\infty(64),\\ a\\ ],\n$$\nwith all entries as floating-point numbers. All $e_\\infty(N)$ must be expressed in pascals and $a$ is unitless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[[...],[...],[...]]\").",
            "solution": "The problem requires the derivation and numerical solution of the stress relaxation equation for a one-dimensional Maxwell viscoelastic material subjected to a step strain. This will be accomplished using a global spectral collocation method.\n\n### 1. Derivation of the Governing Equation and Exact Solution\n\nA Maxwell element consists of a purely elastic spring and a purely viscous dashpot connected in series. Under an applied stress $\\sigma(t)$, both elements experience the same stress, and the total strain $\\varepsilon(t)$ is the sum of the elastic strain $\\varepsilon_e(t)$ and the viscous strain $\\varepsilon_v(t)$.\n\nThe constitutive relations are:\n1.  Total strain sum: $\\varepsilon(t) = \\varepsilon_e(t) + \\varepsilon_v(t)$\n2.  Hooke's Law for the spring: $\\sigma(t) = E \\varepsilon_e(t)$, where $E$ is the elastic modulus.\n3.  Newton's Law for the dashpot: $\\sigma(t) = \\eta \\dot{\\varepsilon}_v(t)$, where $\\eta$ is the viscosity and $\\dot{\\varepsilon}_v$ is the viscous strain rate.\n\nTo derive the governing ordinary differential equation (ODE) for $\\sigma(t)$, we differentiate the total strain equation with respect to time $t$:\n$$\n\\frac{d\\varepsilon}{dt} = \\frac{d\\varepsilon_e}{dt} + \\frac{d\\varepsilon_v}{dt}\n$$\nFrom the constitutive laws, we can express the strain rates in terms of the stress $\\sigma(t)$:\n-   $\\dot{\\varepsilon}_e(t) = \\frac{1}{E} \\frac{d\\sigma}{dt}$\n-   $\\dot{\\varepsilon}_v(t) = \\frac{1}{\\eta} \\sigma(t)$\n\nSubstituting these into the differentiated strain equation yields the Maxwell model's differential form:\n$$\n\\frac{d\\varepsilon}{dt} = \\frac{1}{E} \\frac{d\\sigma}{dt} + \\frac{1}{\\eta} \\sigma(t)\n$$\nThis equation relates the total strain rate $\\dot{\\varepsilon}(t)$ to the stress $\\sigma(t)$ and its rate of change $\\dot{\\sigma}(t)$.\n\nThe problem specifies an imposed step strain $\\varepsilon(t) = \\varepsilon_0 H(t)$, where $\\varepsilon_0$ is a constant strain magnitude and $H(t)$ is the Heaviside step function. At the moment of the step, $t=0$, the strain is applied instantaneously. The viscous dashpot cannot respond instantaneously, so the initial viscous strain $\\varepsilon_v(0^+) = 0$. Therefore, all initial strain is stored elastically: $\\varepsilon_e(0^+) = \\varepsilon_0$. This results in an initial stress:\n$$\n\\sigma(0) = \\sigma(0^+) = E \\varepsilon_e(0^+) = E\\varepsilon_0\n$$\nFor all times $t  0$, the strain is constant, $\\varepsilon(t) = \\varepsilon_0$, so its time derivative is zero, $\\dot{\\varepsilon}(t) = 0$. The governing ODE for $t0$ simplifies to:\n$$\n0 = \\frac{1}{E} \\frac{d\\sigma}{dt} + \\frac{1}{\\eta} \\sigma(t) \\quad \\implies \\quad \\frac{d\\sigma}{dt} + \\frac{E}{\\eta} \\sigma(t) = 0\n$$\nThis is a first-order linear homogeneous ODE. We define the Maxwell relaxation time as $\\tau = \\eta/E$. The ODE for stress relaxation is then:\n$$\n\\frac{d\\sigma}{dt} + \\frac{1}{\\tau} \\sigma(t) = 0, \\quad \\text{with initial condition} \\quad \\sigma(0) = E\\varepsilon_0\n$$\nThe exact solution to this initial value problem is found by separation of variables or by using the standard solution for exponential decay:\n$$\n\\sigma_{\\text{exact}}(t) = \\sigma(0) \\exp\\left(-\\frac{t}{\\tau}\\right) = E\\varepsilon_0 \\exp\\left(-\\frac{E}{\\eta}t\\right)\n$$\nThis analytical solution will be used to verify the accuracy of the numerical method.\n\n### 2. Numerical Method: Spectral Collocation\n\nWe solve the IVP using a global spectral collocation method on the time interval $[0, T]$.\n\n**Discretization:** The domain $[0, T]$ is discretized using $N$ Chebyshev-Gauss-Lobatto (CGL) points. The CGL nodes are defined on the canonical interval $[-1, 1]$ as $x_j = \\cos\\left(\\frac{\\pi j}{N-1}\\right)$ for $j=0, 1, \\dots, N-1$. These nodes are not in monotonic order. For convenience, we re-index them to run from $-1$ to $1$: $x'_j = -\\cos\\left(\\frac{\\pi j}{N-1}\\right)$ for $j=0, \\dots, N-1$. This gives $x'_0 = -1, \\dots, x'_{N-1} = 1$. We then map these nodes to the time domain $[0, T]$ using an affine transformation:\n$$\nt_j = \\frac{T}{2}(x'_j + 1)\n$$\nThis ensures that $t_0=0$ and $t_{N-1}=T$, providing a monotonically increasing set of time points.\n\n**Chebyshev Differentiation Matrix:** The core of the spectral method is the differentiation matrix $D$, which approximates the derivative of a function represented by its values at the CGL nodes. For the CGL nodes $x_j$ (ordered from $1$ to $-1$, as is conventional in many definitions), the entries of the $N \\times N$ matrix $D$ are:\n$$\nD_{ij} = \\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{x_i - x_j} \\quad \\text{for } i \\neq j\n$$\n$$\nD_{ii} = -\\sum_{j \\neq i} D_{ij}\n$$\nwhere the weights are $c_0=c_{N-1}=2$ and $c_i=1$ for $1 \\le i \\le N-2$. The derivative of the function vector $\\vec{f}$ on $[-1, 1]$ is then approximated by the matrix-vector product $D\\vec{f}$. For the time domain $[0,T]$, the differentiation operator is scaled: $\\mathcal{D}_t = \\frac{2}{T}D$. Our implementation will use the conventional node ordering from $1$ to $-1$ for $D$ and map to time points that run from $T$ to $0$.\n\n**Linear System Formulation:** We seek the numerical solution $\\vec{\\sigma} = [\\sigma_0, \\sigma_1, \\dots, \\sigma_{N-1}]^T$ at the time nodes $\\vec{t} = [t_0, t_1, \\dots, t_{N-1}]^T$. Collocating the ODE $\\dot{\\sigma} + \\frac{1}{\\tau}\\sigma = 0$ at the $N$ time nodes gives the system:\n$$\n\\left(\\frac{2}{T}D\\right)\\vec{\\sigma} + \\frac{1}{\\tau}I\\vec{\\sigma} = \\vec{0}\n$$\nwhere $I$ is the $N \\times N$ identity matrix. This can be written as a linear system $L\\vec{\\sigma} = \\vec{0}$, where the operator matrix is $L = \\frac{2}{T}D + \\frac{1}{\\tau}I$.\n\n**Initial Condition Enforcement:** The system $L\\vec{\\sigma} = \\vec{0}$ is homogeneous and requires a boundary condition for a unique solution. The initial condition is $\\sigma(0) = E\\varepsilon_0$. In our node ordering, time $t=0$ corresponds to the last node, $t_{N-1}=0$ (since $x_{N-1}=-1$). We enforce this condition using the tau method via row replacement. The last row of the matrix $L$ and the right-hand-side vector $\\vec{b}$ (initially all zeros) are modified. The last row of $L$ is replaced with an \"identity row\" $[0, 0, \\dots, 1]$, and the last element of $\\vec{b}$ is set to the initial stress value, $E\\varepsilon_0$.\nThe modified system $L'\\vec{\\sigma} = \\vec{b}$ is:\n- $L'_{ij} = L_{ij}$ for $i=0, \\dots, N-2$.\n- $L'_{N-1, j} = 0$ for $j=0, \\dots, N-2$ and $L'_{N-1, N-1} = 1$.\n- $b_i = 0$ for $i=0, \\dots, N-2$ and $b_{N-1} = E\\varepsilon_0$.\n\nThis non-singular linear system is then solved for the unknown stress vector $\\vec{\\sigma}$.\n\n### 3. Error Analysis\nThe numerical solution $\\sigma_{\\text{num}}(t_k)$ is verified against the exact solution $\\sigma_{\\text{exact}}(t_k)$ at the collocation nodes. The accuracy is quantified by the maximum-norm error:\n$$\ne_\\infty(N) = \\max_{k=0,\\dots,N-1} \\left|\\sigma_{\\text{num}}(t_k) - \\sigma_{\\text{exact}}(t_k)\\right|\n$$\nFor spectral methods applied to smooth analytic functions, the error is expected to decay exponentially with $N$, i.e., $e_\\infty(N) \\propto a^N$ for some base $a \\in (0,1)$. We estimate this base factor using the errors from two discretizations, $N_1=32$ and $N_2=64$:\n$$\na \\approx \\left(\\frac{e_\\infty(N_2)}{e_\\infty(N_1)}\\right)^{\\frac{1}{N_2 - N_1}}\n$$\nThis factor quantifies the rate of spectral convergence. A smaller value of $a$ indicates faster convergence.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the Chebyshev differentiation matrix for N CGL nodes.\n    \n    Args:\n        N (int): The number of collocation points (polynomial degree N-1).\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing:\n            - D (np.ndarray): The (N, N) differentiation matrix.\n            - x (np.ndarray): The (N,) array of CGL nodes from 1 down to -1.\n    \"\"\"\n    if N = 1:\n        return np.array([[0.]]), np.array([0.])\n    \n    # CGL nodes x_j = cos(j*pi/(N-1)) for j=0..N-1\n    # This creates nodes ordered from 1 down to -1.\n    j = np.arange(N)\n    x = np.cos(j * np.pi / (N - 1))\n    \n    # c_j factors\n    c = np.ones(N)\n    c[0] = 2.\n    c[N-1] = 2.\n    \n    # Compute off-diagonal entries\n    D = np.zeros((N, N))\n    x_diff = x[:, np.newaxis] - x[np.newaxis, :]\n    np.fill_diagonal(x_diff, 1.) # Avoid division by zero on diagonal\n    \n    c_ratio = c[:, np.newaxis] / c[np.newaxis, :]\n    \n    indices = np.arange(N)\n    sign = (-1)**(indices[:, np.newaxis] + indices[np.newaxis, :])\n    \n    D = c_ratio * sign / x_diff\n    \n    # Compute diagonal entries using sum rule\n    np.fill_diagonal(D, 0.)\n    D -= np.diag(np.sum(D, axis=1))\n    \n    return D, x\n\ndef solve_maxwell_spectral(E, eta, eps0, T, N_list):\n    \"\"\"\n    Solves the Maxwell stress relaxation problem using a spectral method.\n\n    Args:\n        E (float): Elastic modulus (Pa).\n        eta (float): Viscosity (Pa.s).\n        eps0 (float): Strain magnitude (dimensionless).\n        T (float): Final time (s).\n        N_list (list[int]): List of discretization sizes to evaluate.\n\n    Returns:\n        list[float]: A list containing max-norm errors for each N in N_list,\n                     followed by the empirical convergence factor 'a'.\n    \"\"\"\n    results_for_case = []\n    errors = {}\n    \n    tau = eta / E  # Maxwell relaxation time\n    sigma0 = E * eps0  # Initial stress at t=0\n\n    for N in N_list:\n        # 1. Get differentiation matrix D and nodes x in [-1, 1]\n        D_cheb, x_cheb = chebyshev_diff_matrix(N)\n        \n        # 2. Map nodes to time domain [0, T]. x_cheb runs 1 to -1, so t runs T to 0.\n        t_nodes = 0.5 * T * (x_cheb + 1)\n        \n        # 3. Form the linear operator matrix L\n        # ODE: d(sigma)/dt + (1/tau)*sigma = 0\n        # Time derivative operator on [0, T] is (2/T)*D_cheb\n        L = (2.0 / T) * D_cheb + (1.0 / tau) * np.identity(N)\n        \n        # 4. Set up RHS vector and apply initial condition via tau-enforcement\n        # The initial condition is at t=0, which is the last node (index N-1)\n        # where x = -1. We replace the last row of the system.\n        b = np.zeros(N)\n        \n        L[N-1, :] = 0.0\n        L[N-1, N-1] = 1.0\n        b[N-1] = sigma0\n        \n        # 5. Solve the linear system L * sigma_vec = b\n        sigma_num = np.linalg.solve(L, b)\n        \n        # 6. Compute exact solution for comparison\n        sigma_exact = sigma0 * np.exp(-t_nodes / tau)\n        \n        # 7. Compute max-norm error\n        e_inf = np.max(np.abs(sigma_num - sigma_exact))\n        errors[N] = e_inf\n        results_for_case.append(e_inf)\n        \n    # 8. Compute empirical convergence factor 'a'\n    e_inf_n1 = errors[32]\n    e_inf_n2 = errors[64]\n    \n    if e_inf_n1 > 0 and e_inf_n2 > 0:\n        a = (e_inf_n2 / e_inf_n1)**(1.0 / (64 - 32))\n    else:\n        # Convergence is faster than machine precision can resolve\n        a = 0.0 \n        \n    results_for_case.append(a)\n    \n    return results_for_case\n\ndef solve():\n    \"\"\"\n    Main driver function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: happy path\n        {'E': 3.0e10, 'eta': 3.0e18, 'eps0': 1.0e-5, 'T': 1.0e7},\n        # Case B: fast relaxation\n        {'E': 3.0e10, 'eta': 3.0e16, 'eps0': 1.0e-5, 'T': 1.0e7},\n        # Case C: slow relaxation\n        {'E': 3.0e10, 'eta': 3.0e20, 'eps0': 1.0e-5, 'T': 1.0e7},\n    ]\n    N_list = [8, 16, 32, 64]\n\n    all_results = []\n    for case_params in test_cases:\n        case_results = solve_maxwell_spectral(\n            case_params['E'], case_params['eta'], case_params['eps0'],\n            case_params['T'], N_list\n        )\n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified.\n    inner_lists_str = []\n    for case_result in all_results:\n        # Format each inner list: [val1,val2,val3]\n        inner_str = f\"[{','.join(map(str, case_result))}]\"\n        inner_lists_str.append(inner_str)\n    \n    # Combine the inner lists into the final outer list format: [[...],[...]]\n    final_output_str = f\"[{','.join(inner_lists_str)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "While the Maxwell model captures steady-state creep, the Earth's rheology is more complex, often exhibiting transient deformation phases captured by models like the Burgers rheology. This practice  delves into the critical topic of model mismatch, a common challenge in geophysical inversion. By attempting to fit data generated from a complex Burgers model with a simpler Maxwell model, you will quantify the resulting bias in the inferred viscosity, a crucial lesson in interpreting real-world geodetic data.",
            "id": "3613161",
            "problem": "You are to implement a self-contained computational experiment that quantifies model-mismatch bias when inverting postseismic surface displacement time series generated by a three-dimensional homogeneous Burgers viscoelastic mantle using a mis-specified Maxwell rheology. The geometry is a single linear eight-node hexahedral finite element representing a homogeneous mantle volume with base fixed and a uniform shear traction applied on the top surface. By symmetry and homogeneity, the deformation reduces to homogeneous simple shear, yet your derivation and implementation must start from and be consistent with three-dimensional small-strain linear viscoelasticity and quasi-static equilibrium.\n\nFundamental base to use:\n- Quasi-static linear momentum balance: $\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$ with prescribed tractions and displacements on the boundary, neglecting inertia.\n- Small-strain kinematics: $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\mathsf{T}}\\right)$.\n- Linear viscoelastic correspondence principle and mechanical analogs: a Maxwell element is a linear spring of shear modulus $\\mu$ in series with a dashpot of viscosity $\\eta$; a Kelvin element is a linear spring of shear modulus $\\mu$ in parallel with a dashpot of viscosity $\\eta$; a Burgers element is a Maxwell element in series with a Kelvin element.\n- For simple shear, the deviatoric stress reduces to a scalar shear stress $\\tau$ and shear strain $\\gamma$, consistent with three-dimensional isotropic linear viscoelasticity for homogeneous states.\n\nPhysical configuration:\n- A single hexahedral element of height $H$ in the $z$-direction, with the bottom face at $z = 0$ fixed ($\\mathbf{u} = \\mathbf{0}$) and the top face at $z = H$ subjected to a uniform shear traction $\\mathbf{t} = (\\tau_{0}, 0, 0)$ (shear along $x$) at time $t \\ge 0$.\n- The material has Burgers rheology characterized by the Maxwell branch parameters $(\\mu_{M}, \\eta_{M})$ and the Kelvin branch parameters $(\\mu_{K}, \\eta_{K})$. Assume isotropy and that volumetric effects are irrelevant for the prescribed pure shear loading.\n\nTasks:\n1. Starting from the governing equations above, show that under the stated uniform shear traction, the element experiences spatially uniform simple shear such that the only nonzero stress component is $\\sigma_{xz}(t) = \\tau_{0}$ and that the only nonzero strain component is $\\varepsilon_{xz}(t) = \\tfrac{1}{2}\\gamma(t)$. Use the linear viscoelastic correspondence to reduce the three-dimensional problem to the scalar shear relation between $\\tau(t)$ and $\\gamma(t)$ governed by the Burgers mechanical analog in series. Carefully derive the evolution equation(s) for $\\gamma(t)$ under a step shear stress $\\tau(t) = \\tau_{0} H(t)$, where $H(t)$ is the Heaviside step function, using only the definitions of the Maxwell and Kelvin elements and basic calculus. Do not assume any pre-known closed-form solution; derive it.\n2. Express the top-face horizontal displacement in the $x$-direction as a function of time, $u(t)$, in meters, in terms of the homogeneous shear strain $\\gamma(t)$ and height $H$.\n3. Define a mis-specified inversion that assumes a Maxwell rheology with a known instantaneous elastic compliance equal to the true Burgers instantaneous compliance (so the intercept is fixed). Specifically, model the Maxwell-predicted displacement as $u_{\\text{Mx}}(t) = u_{0} + s\\, t$, where $u_{0}$ is the instantaneous displacement you derived from the Burgers model at $t=0^{+}$, and $s$ is a constant slope to be determined by least squares fit to the Burgers-generated $u(t)$ over a given time window. From the fitted slope $\\hat{s}$, infer the Maxwell viscosity estimate $\\hat{\\eta} = \\dfrac{\\tau_{0} H}{\\hat{s}}$.\n4. Quantify the relative viscosity bias $b = \\dfrac{\\hat{\\eta} - \\eta_{M}}{\\eta_{M}}$ for each test case below.\n\nNumerical and unit requirements:\n- Time $t$ is in seconds.\n- Shear modulus parameters $\\mu_{M}$ and $\\mu_{K}$ are in Pascal ($\\mathrm{Pa}$).\n- Viscosity parameters $\\eta_{M}$ and $\\eta_{K}$ are in Pascal-second ($\\mathrm{Pa \\cdot s}$).\n- Shear traction $\\tau_{0}$ is in Pascal ($\\mathrm{Pa}$).\n- Height $H$ is in meter ($\\mathrm{m}$).\n- The top displacement $u(t)$ must be expressed in meters ($\\mathrm{m}$).\n- The final reported biases $b$ are dimensionless and must be printed as decimal floats rounded to six digits after the decimal point.\n\nImplementation requirements:\n- Implement a program that:\n  - Computes the Burgers-generated displacement time series $u(t_{i})$ at $N$ uniformly spaced time samples $t_{i}$ between $t_{\\min}$ and $t_{\\max}$ (inclusive), with $t_{\\min}  0$.\n  - Uses least squares to fit the slope $\\hat{s}$ of $u_{\\text{Mx}}(t) = u_{0} + s t$ to the Burgers $u(t)$ values (with the intercept $u_{0}$ fixed from the true instantaneous displacement).\n  - Computes $\\hat{\\eta} = \\dfrac{\\tau_{0} H}{\\hat{s}}$ and the bias $b = \\dfrac{\\hat{\\eta} - \\eta_{M}}{\\eta_{M}}$.\n\nTest suite:\nFor each case, use the specified parameters and time window. All constants must be used exactly as given.\n\n- Case $1$ (balanced window):\n  - $\\mu_{M} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$, $\\eta_{M} = 1.0 \\times 10^{19}\\ \\mathrm{Pa \\cdot s}$,\n  - $\\mu_{K} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$, $\\eta_{K} = 3.0 \\times 10^{18}\\ \\mathrm{Pa \\cdot s}$,\n  - $\\tau_{0} = 1.0 \\times 10^{3}\\ \\mathrm{Pa}$, $H = 5.0 \\times 10^{4}\\ \\mathrm{m}$,\n  - $t_{\\min} = 1.0\\ \\text{day} = 1.0 \\times 86400\\ \\mathrm{s}$, $t_{\\max} = 5.0\\ \\text{years} = 5.0 \\times 365.25 \\times 86400\\ \\mathrm{s}$, $N = 50$.\n\n- Case $2$ (long window):\n  - Same material and loading as Case $1$,\n  - $t_{\\min} = 1.0 \\times 86400\\ \\mathrm{s}$, $t_{\\max} = 50.0 \\times 365.25 \\times 86400\\ \\mathrm{s}$, $N = 100$.\n\n- Case $3$ (short window):\n  - Same material and loading as Case $1$,\n  - $t_{\\min} = 1.0 \\times 86400\\ \\mathrm{s}$, $t_{\\max} = 0.1 \\times 365.25 \\times 86400\\ \\mathrm{s}$, $N = 30$.\n\n- Case $4$ (Kelvin dashpot effectively rigid, approaching pure Maxwell behavior):\n  - $\\mu_{M} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$, $\\eta_{M} = 1.0 \\times 10^{19}\\ \\mathrm{Pa \\cdot s}$,\n  - $\\mu_{K} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$, $\\eta_{K} = 1.0 \\times 10^{25}\\ \\mathrm{Pa \\cdot s}$,\n  - $\\tau_{0} = 1.0 \\times 10^{3}\\ \\mathrm{Pa}$, $H = 5.0 \\times 10^{4}\\ \\mathrm{m}$,\n  - $t_{\\min} = 1.0 \\times 86400\\ \\mathrm{s}$, $t_{\\max} = 5.0 \\times 365.25 \\times 86400\\ \\mathrm{s}$, $N = 50$.\n\n- Case $5$ (soft Kelvin spring with slow transient):\n  - $\\mu_{M} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$, $\\eta_{M} = 1.0 \\times 10^{19}\\ \\mathrm{Pa \\cdot s}$,\n  - $\\mu_{K} = 5.0 \\times 10^{9}\\ \\mathrm{Pa}$, $\\eta_{K} = 1.0 \\times 10^{19}\\ \\mathrm{Pa \\cdot s}$,\n  - $\\tau_{0} = 1.0 \\times 10^{3}\\ \\mathrm{Pa}$, $H = 5.0 \\times 10^{4}\\ \\mathrm{m}$,\n  - $t_{\\min} = 1.0 \\times 86400\\ \\mathrm{s}$, $t_{\\max} = 5.0 \\times 365.25 \\times 86400\\ \\mathrm{s}$, $N = 50$.\n\nFinal output format:\n- Your program should produce a single line of output containing the five relative biases $b$ as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $5$, with each bias rounded to six digits after the decimal point (e.g., $[0.123456,-0.000001,0.002345,0.000000,-0.543210]$).",
            "solution": "The problem requires a quantitative analysis of model-mismatch bias in a computational geophysics context. Specifically, we are to model the postseismic crustal deformation resulting from a large earthquake using a simplified one-dimensional representation of the viscoelastic mantle. The true Earth is represented by a Burgers rheology, while an incorrect, simpler Maxwell model is used for inversion. We must derive the analytical solution for the \"true\" model, implement a numerical experiment to fit the \"incorrect\" model, and quantify the resulting bias in the inferred viscosity.\n\n### **1. Derivation from 3D Viscoelasticity to 1D Simple Shear**\n\nThe problem is defined within the framework of three-dimensional, quasi-static, small-strain, linear viscoelasticity.\n\n**Governing Equations:**\nThe quasi-static momentum balance, neglecting inertial forces, is:\n$$ \\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0} $$\nwhere $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor. The small-strain kinematic relation is:\n$$ \\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\mathsf{T}}\\right) $$\nwhere $\\mathbf{u}$ is the displacement vector and $\\boldsymbol{\\varepsilon}$ is the infinitesimal strain tensor.\n\n**Problem Geometry and Boundary Conditions:**\nThe geometry is a layer of height $H$ with its base at $z=0$ fixed ($\\mathbf{u}=\\mathbf{0}$) and its top at $z=H$ subject to a uniform shear traction $\\mathbf{t} = (\\tau_0, 0, 0)$ for time $t \\ge 0$. This traction is oriented along the $x$-axis.\n\n**Reduction to Simple Shear:**\nBy symmetry, we can hypothesize a displacement field of the form $\\mathbf{u} = (u_x(z, t), 0, 0)$. This ansatz is consistent with the boundary conditions, provided $u_x(0,t) = 0$.\nThe components of the strain tensor $\\boldsymbol{\\varepsilon}$ are then:\n$$ \\varepsilon_{xz} = \\varepsilon_{zx} = \\frac{1}{2} \\frac{\\partial u_x}{\\partial z} $$\nAll other components of $\\boldsymbol{\\varepsilon}$ are zero. For an isotropic linear viscoelastic material subjected to pure shear strain, the resulting stress tensor will also be a pure shear stress. Thus, the only non-zero stress components are $\\sigma_{xz}$ and $\\sigma_{zx}$.\n\nThe momentum balance equation, $\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$, simplifies significantly. The $y$ and $z$ components are trivially satisfied ($0=0$). The $x$ component becomes:\n$$ \\frac{\\partial \\sigma_{xx}}{\\partial x} + \\frac{\\partial \\sigma_{xy}}{\\partial y} + \\frac{\\partial \\sigma_{xz}}{\\partial z} = 0 \\implies \\frac{\\partial \\sigma_{xz}}{\\partial z} = 0 $$\nThis implies that $\\sigma_{xz}$ does not vary with depth $z$; it is a function of time only, $\\sigma_{xz}(t)$.\n\nThe traction vector on a surface with unit normal $\\mathbf{n}$ is given by $\\mathbf{t} = \\boldsymbol{\\sigma} \\cdot \\mathbf{n}$. At the top surface $z=H$, the normal is $\\mathbf{n}=(0,0,1)$. The traction is:\n$$ \\mathbf{t}|_{z=H} = (\\sigma_{xz}(t), \\sigma_{yz}(t), \\sigma_{zz}(t)) $$\nGiven the prescribed traction $\\mathbf{t} = (\\tau_0, 0, 0)$ for $t \\ge 0$, we must have $\\sigma_{xz}(t) = \\tau_0$. Since $\\sigma_{xz}$ is independent of $z$, this shear stress value applies throughout the entire layer for $t0$.\n\nThe material is homogeneous. Since the stress $\\sigma_{xz}(t) = \\tau_0$ is spatially uniform, the resulting strain $\\varepsilon_{xz}(t)$ must also be spatially uniform. We define the engineering shear strain $\\gamma(t)$ such that $\\varepsilon_{xz}(t) = \\frac{1}{2}\\gamma(t)$. Therefore:\n$$ \\frac{1}{2}\\frac{\\partial u_x}{\\partial z} = \\frac{1}{2}\\gamma(t) \\implies \\frac{d u_x}{d z} = \\gamma(t) $$\nIntegrating with respect to $z$ yields $u_x(z, t) = \\gamma(t) z + C(t)$. Applying the fixed base boundary condition $u_x(0,t)=0$, we find the integration constant $C(t)=0$. This gives the displacement field:\n$$ u_x(z,t) = \\gamma(t) z $$\nThe problem is thus reduced to finding the evolution of the homogeneous shear strain $\\gamma(t)$ in response to a step shear stress $\\tau(t) = \\sigma_{xz}(t) = \\tau_0 H(t)$, where $H(t)$ is the Heaviside step function. This corresponds to a creep test on a Burgers material.\n\n### **2. Creep Response of a Burgers Material**\n\nA Burgers element consists of a Maxwell element (spring $\\mu_M$, dashpot $\\eta_M$) in series with a Kelvin element (spring $\\mu_K$, dashpot $\\eta_K$ in parallel).\n- For elements in series, the total stress $\\tau$ is the same across each element, and the total strain $\\gamma$ is the sum of the strains of each element: $\\gamma(t) = \\gamma_M(t) + \\gamma_K(t)$.\n- The stress-strain relation for the Maxwell element is $\\dot{\\gamma}_M = \\frac{\\dot{\\tau}}{\\mu_M} + \\frac{\\tau}{\\eta_M}$.\n- The stress-strain relation for the Kelvin element is $\\tau = \\mu_K \\gamma_K + \\eta_K \\dot{\\gamma}_K$.\n\nWe analyze the response to a step stress $\\tau(t) = \\tau_0 H(t)$. For $t  0$, $\\tau = \\tau_0$ is constant, so $\\dot{\\tau}=0$.\n\n**Maxwell Element Strain ($\\gamma_M$):**\nThe strain on the Maxwell element is the sum of its spring and dashpot strains, $\\gamma_M = \\gamma_{M,s} + \\gamma_{M,d}$.\n- The elastic spring responds instantaneously: $\\gamma_{M,s}(t) = \\tau(t) / \\mu_M = (\\tau_0/\\mu_M) H(t)$.\n- The viscous dashpot strain rate is $\\dot{\\gamma}_{M,d} = \\tau(t) / \\eta_M$. For $t0$, integrating gives $\\gamma_{M,d}(t) = (\\tau_0/\\eta_M) t$.\nSo, for $t0$, the Maxwell strain contribution is $\\gamma_{\\text{on Maxwell}}(t) = \\frac{\\tau_0}{\\mu_M} + \\frac{\\tau_0}{\\eta_M} t$.\n\n**Kelvin Element Strain ($\\gamma_K$):**\nFor $t0$, the governing equation for the Kelvin element is a first-order linear ordinary differential equation:\n$$ \\eta_K \\dot{\\gamma}_K + \\mu_K \\gamma_K = \\tau_0 $$\nThe solution is $\\gamma_K(t) = \\gamma_{K,p} + \\gamma_{K,h}$, where $\\gamma_{K,p}$ is a particular solution and $\\gamma_{K,h}$ is the homogeneous solution.\n- The particular solution is the steady-state response, $\\gamma_{K,p} = \\tau_0 / \\mu_K$.\n- The homogeneous solution is $\\gamma_{K,h}(t) = C e^{-(\\mu_K/\\eta_K)t}$.\nThe general solution is $\\gamma_K(t) = \\frac{\\tau_0}{\\mu_K} + C e^{-t/t_R}$, where $t_R = \\eta_K/\\mu_K$ is the retardation time.\nThe initial condition is that the Kelvin element cannot deform instantaneously due to its dashpot, so $\\gamma_K(0^+) = 0$.\n$0 = \\frac{\\tau_0}{\\mu_K} + C \\implies C = -\\frac{\\tau_0}{\\mu_K}$.\nThe strain on the Kelvin element for $t0$ is:\n$$ \\gamma_K(t) = \\frac{\\tau_0}{\\mu_K} \\left(1 - e^{-t/t_R}\\right) $$\n\n**Total Burgers Strain and Displacement:**\nThe total strain is the sum of the strains on the Maxwell and Kelvin elements. Note that the elastic strain from the Maxwell spring provides the full instantaneous elastic response of the Burgers body.\n$$ \\gamma(t) = \\gamma_{M,s}(t) + \\gamma_{M,d}(t) + \\gamma_K(t) = \\frac{\\tau_0}{\\mu_M} + \\frac{\\tau_0}{\\eta_M} t + \\frac{\\tau_0}{\\mu_K} \\left(1 - e^{-t/t_R}\\right) \\quad \\text{for } t  0 $$\nThe top-face displacement is $u(t) = u_x(H, t) = \\gamma(t) H$:\n$$ u(t) = \\tau_0 H \\left[ \\frac{1}{\\mu_M} + \\frac{t}{\\eta_M} + \\frac{1}{\\mu_K} \\left(1 - e^{-t/(\\eta_K/\\mu_K)}\\right) \\right] $$\n\n### **3. Mis-specified Maxwell Model Inversion**\n\nWe now fit the \"true\" displacement data $u(t)$ generated by the Burgers model with a simplified Maxwell model. The displacement predicted by a Maxwell model is:\n$$ u_{\\text{Mx}}(t) = \\frac{\\tau_0 H}{\\mu_{\\text{Mx}}} + \\frac{\\tau_0 H}{\\eta_{\\text{Mx}}} t $$\nThis is a linear function of time. The problem specifies that the inversion assumes the instantaneous elastic response is known. The instantaneous displacement of the Burgers model at $t \\to 0^+$ is:\n$$ u_0 = u(0^+) = \\tau_0 H \\left[ \\frac{1}{\\mu_M} + 0 + \\frac{1}{\\mu_K}(1-1) \\right] = \\frac{\\tau_0 H}{\\mu_M} $$\nWe fix the intercept of our linear model to this true value, so our fitting model is $u_{\\text{fit}}(t) = u_0 + s t$. The slope $s$ is an estimate of $\\frac{\\tau_0 H}{\\eta_{\\text{Mx}}}$.\n\nWe determine the best-fit slope $\\hat{s}$ by minimizing the sum of squared residuals between the true displacement $u(t_i)$ and the model $u_{\\text{fit}}(t_i)$ over a set of time samples $\\{t_i\\}_{i=1}^N$. We are fitting the model $y(t) = st$ to the data $d(t) = u(t) - u_0$. The least-squares functional is:\n$$ S(s) = \\sum_{i=1}^N \\left( d(t_i) - s t_i \\right)^2 $$\nSetting $\\frac{dS}{ds} = 0$ gives the optimal slope $\\hat{s}$:\n$$ \\hat{s} = \\frac{\\sum_{i=1}^N t_i d(t_i)}{\\sum_{i=1}^N t_i^2} = \\frac{\\sum_{i=1}^N t_i (u(t_i) - u_0)}{\\sum_{i=1}^N t_i^2} $$\nFrom this fitted slope $\\hat{s}$, we infer an apparent Maxwell viscosity $\\hat{\\eta}$ using the relation $\\hat{s} = \\frac{\\tau_0 H}{\\hat{\\eta}}$, which gives:\n$$ \\hat{\\eta} = \\frac{\\tau_0 H}{\\hat{s}} $$\n\n### **4. Viscosity Bias and Numerical Implementation**\n\nThe relative bias in the viscosity is the normalized difference between the inferred viscosity $\\hat{\\eta}$ and the true long-term viscosity $\\eta_M$ from the Burgers model's Maxwell branch:\n$$ b = \\frac{\\hat{\\eta} - \\eta_M}{\\eta_M} $$\n\nThe computational procedure for each test case is as follows:\n1.  Define all physical parameters $(\\mu_M, \\eta_M, \\mu_K, \\eta_K, \\tau_0, H)$ and time window parameters $(t_{\\min}, t_{\\max}, N)$.\n2.  Generate $N$ uniformly spaced time samples $t_i$ from $t_{\\min}$ to $t_{\\max}$.\n3.  Calculate the constant instantaneous displacement $u_0 = \\frac{\\tau_0 H}{\\mu_M}$.\n4.  For each time sample $t_i$, calculate the true Burgers displacement $u(t_i)$ using the derived analytical formula.\n5.  Calculate the data to be fitted: $d_i = u(t_i) - u_0$.\n6.  Compute the best-fit slope $\\hat{s}$ using the least-squares formula for regression through the origin.\n7.  Compute the inferred viscosity $\\hat{\\eta} = \\frac{\\tau_0 H}{\\hat{s}}$.\n8.  Compute and store the relative bias $b = (\\hat{\\eta} - \\eta_M) / \\eta_M$.\nThis procedure is repeated for all five test cases. The final output is a list of the computed biases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_bias(params):\n    \"\"\"\n    Calculates the relative viscosity bias for a single test case.\n    \n    Args:\n        params (dict): A dictionary containing all parameters for the case.\n\n    Returns:\n        float: The calculated relative viscosity bias.\n    \"\"\"\n    mu_M = params['mu_M']\n    eta_M = params['eta_M']\n    mu_K = params['mu_K']\n    eta_K = params['eta_K']\n    tau_0 = params['tau_0']\n    H = params['H']\n    t_min = params['t_min']\n    t_max = params['t_max']\n    N = params['N']\n\n    # 1. Generate N uniformly spaced time samples from t_min to t_max.\n    t_samples = np.linspace(t_min, t_max, N)\n\n    # 2. Calculate the true instantaneous displacement u_0.\n    # This corresponds to the instantaneous elastic response of the Maxwell spring.\n    u_0 = (tau_0 * H) / mu_M\n\n    # 3. Calculate the \"true\" displacement time series u(t) from the Burgers model.\n    # The displacement u(t) is H * gamma(t), where gamma is the total strain.\n    # gamma(t) = instantaneous_elastic + viscous_flow + transient_creep\n    #            (Maxwell spring)     (Maxwell dashpot) (Kelvin element)\n    \n    # Retardation time of the Kelvin element\n    # Guard against division by zero, although not needed for the given test cases.\n    if mu_K == 0.0:\n        # If mu_K is 0, the Kelvin element is just a dashpot. Its strain is (tau_0*t)/eta_K.\n        term_kelvin_strain = (tau_0 / eta_K) * t_samples\n    else:\n        t_R = eta_K / mu_K\n        term_kelvin_strain = (tau_0 / mu_K) * (1.0 - np.exp(-t_samples / t_R))\n    \n    # Total strain combines Maxwell and Kelvin responses\n    gamma_t = (tau_0 / mu_M) + (tau_0 / eta_M) * t_samples + term_kelvin_strain\n    \n    # Total displacement at the top surface\n    u_t = H * gamma_t\n    \n    # 4. Perform least squares to fit the slope of u_Mx(t) = u_0 + s*t.\n    # Since u_0 is fixed, we are fitting a line through the origin to the data d(t) = u(t) - u_0.\n    # The data to be fitted is the displacement minus the instantaneous part.\n    d_t = u_t - u_0\n    \n    # The least-squares solution for the slope s_hat is (t dot d) / (t dot t).\n    s_hat = np.dot(t_samples, d_t) / np.dot(t_samples, t_samples)\n    \n    # 5. Infer the apparent Maxwell viscosity eta_hat from the fitted slope s_hat.\n    # The slope of a pure Maxwell model is s = (tau_0 * H) / eta_Mx.\n    eta_hat = (tau_0 * H) / s_hat\n    \n    # 6. Calculate the relative viscosity bias.\n    bias = (eta_hat - eta_M) / eta_M\n    \n    return bias\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment for all test cases.\n    \"\"\"\n    S_PER_DAY = 86400.0\n    S_PER_YEAR = 365.25 * S_PER_DAY\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (balanced window)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 3.0e10, 'eta_K': 3.0e18,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 5.0 * S_PER_YEAR, 'N': 50\n        },\n        # Case 2 (long window)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 3.0e10, 'eta_K': 3.0e18,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 50.0 * S_PER_YEAR, 'N': 100\n        },\n        # Case 3 (short window)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 3.0e10, 'eta_K': 3.0e18,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 0.1 * S_PER_YEAR, 'N': 30\n        },\n        # Case 4 (Kelvin dashpot effectively rigid)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 3.0e10, 'eta_K': 1.0e25,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 5.0 * S_PER_YEAR, 'N': 50\n        },\n        # Case 5 (soft Kelvin spring with slow transient)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 5.0e9, 'eta_K': 1.0e19,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 5.0 * S_PER_YEAR, 'N': 50\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        bias = calculate_bias(case_params)\n        results.append(bias)\n\n    # Format the final results as specified in the problem statement.\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the simulation.\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond simplified, homogeneous rheological models to image spatially continuous variations in viscosity requires powerful and efficient inversion techniques. This exercise  introduces the adjoint-state method, a state-of-the-art approach for computing the sensitivity of geodetic observations to distributed Earth properties. You will derive and implement the discrete adjoint for a viscoelastic system, enabling the calculation of the gradient of a misfit functional, which is the cornerstone of modern, large-scale geophysical inversions.",
            "id": "3613152",
            "problem": "Consider a one-dimensional, plane-shear, quasi-static Maxwell viscoelastic bar occupying a domain $x \\in [0,L]$ with displacement $u(x,t)$ in the shear direction, shear stress $\\tau(t)$, and shear strain $\\gamma(x,t) = \\partial u/\\partial x$. The stress equilibrium reduces to $\\partial \\tau/\\partial x = 0$, so that $\\tau$ is spatially uniform. The Maxwell constitutive relation in shear reads $\\dot{\\gamma}(x,t) = \\tau(t)/\\eta(x) + \\dot{\\tau}(t)/G$, where $\\eta(x)  0$ is the spatially variable viscosity and $G  0$ is the shear modulus. The boundary conditions are $u(0,t)=0$ and $u(L,t) = U(t)$, where $U(t)$ is prescribed, smooth, and monotone increasing from $0$.\n\nFundamental base. Start from quasi-static force balance and the Maxwell constitutive law:\n- Force balance: $\\nabla \\cdot \\sigma = 0$; in one-dimensional shear, $\\partial \\tau/\\partial x = 0$.\n- Kinematics: $\\gamma = \\partial u/\\partial x$, $u(0,t)=0$, $u(L,t)=U(t)$.\n- Constitutive (Maxwell in shear): $\\dot{\\gamma}(x,t) = \\tau(t)/\\eta(x) + \\dot{\\tau}(t)/G$.\n\nShow that the boundary condition implies the ordinary differential equation for $\\tau(t)$:\n$$\n\\dot{\\tau}(t) + G \\alpha \\, \\tau(t) = \\frac{G}{L}\\, \\dot{U}(t), \\quad \\alpha \\equiv \\frac{1}{L}\\int_{0}^{L} \\frac{1}{\\eta(x)}\\, dx,\n$$\nunder the assumptions $u(x,0)=0$ and $\\tau(0)=0$. Let the observation operator collect interior displacements at a fixed set of positions $x_i$, $i \\in \\mathcal{I}$, with $0  x_i  L$. Define the misfit functional over a time window $t \\in [0,T]$:\n$$\nJ[\\eta] = \\frac{1}{2} \\int_{0}^{T} w_t(t) \\sum_{i \\in \\mathcal{I}} w_x(x_i) \\left(u(x_i,t) - d(x_i,t)\\right)^2 \\, dt,\n$$\nwhere $d(x_i,t)$ are observed displacements synthesized from a known reference viscosity field $\\eta_{\\mathrm{true}}(x)$ and the same boundary forcing $U(t)$; $w_t(t) \\ge 0$ and $w_x(x_i) \\ge 0$ are weights that integrate to $1$ over $t$ and positions respectively. You are to compute the gradient of $J$ with respect to the parameter field $\\phi(x) = \\log \\eta(x)$.\n\nDiscretization requirements. Use a uniform spatial grid with $N_x$ cells on $[0,L]$ and a uniform time grid with $N_t$ steps on $[0,T]$. Use backward Euler in time for the stress evolution and for the constitutive update:\n- Stress update: for time step $n$ with step size $\\Delta t$, define $\\tau_n$ by\n$$\n\\frac{\\tau_n - \\tau_{n-1}}{\\Delta t} + G \\alpha \\, \\tau_n = \\frac{G}{L}\\, \\dot{U}_n,\n$$\nwhere $\\dot{U}_n \\approx \\dot{U}(t_n)$, $\\alpha = \\frac{1}{L} \\sum_{j=1}^{N_x} \\Delta x \\, e^{-\\phi_j}$, $\\Delta x = L/N_x$, and $\\phi_j = \\log \\eta_j$ at cell center $x_j$.\n- Strain update: for each spatial cell $j$,\n$$\n\\gamma_j^n - \\gamma_j^{n-1} = \\Delta t \\, \\tau_n \\, e^{-\\phi_j} + \\frac{\\tau_n - \\tau_{n-1}}{G}.\n$$\n- Displacement from strain: for grid node $i$ at position $x_i$, approximate\n$$\nu_i^n = \\sum_{m=1}^{i} \\gamma_m^n \\, \\Delta x, \\quad u_0^n = 0.\n$$\n- Observations: take a fixed index set $\\mathcal{I} \\subset \\{1,\\dots,N_x-1\\}$ corresponding to interior nodes.\n\nAdjoint derivation target. Derive the discrete adjoint recursions for multipliers $\\mu_j^n$ associated with the strain updates and $\\lambda_n$ associated with the stress updates, and show how they produce the gradient $\\partial J / \\partial \\phi_j$. Your derivation must start from the Lagrangian built from the discrete forward equations and $J$. Do not use any previously known adjoint formulas; derive from first principles by taking variations and enforcing stationarity.\n\nNondimensionalization. Work in nondimensional units. Set $L=1$, and take\n- $G = 10$,\n- $U(t) = U_{\\max} \\left(1 - e^{-t/T_0}\\right)$ with $U_{\\max} = 1$ and $T_0 = 0.5$,\n- time grid parameters $N_t = 250$, $\\Delta t = 0.02$, so $T = N_t \\Delta t = 5$,\n- spatial grid parameter $N_x = 64$.\n\nWeights. Use $w_t(t_n) = 1/N_t$ for all time steps and $w_x(x_i) = 1/|\\mathcal{I}|$ for all observation nodes.\n\nObservations. For each test case below, define a reference field $\\phi_{\\mathrm{true}}(x)$, synthesize $d(x_i,t_n)$ by running the forward model once with $\\phi_{\\mathrm{true}}$, and then compute the misfit and gradient for a separate current field $\\phi(x)$.\n\nTest suite. Implement the following three test cases (all in nondimensional units):\n- Case $1$ (smooth contrast): $\\phi_{\\mathrm{true}}(x) = \\log \\eta_0 + a \\sin(2\\pi x)$ with $\\eta_0 = 1$ and $a = \\log 3$. Current field $\\phi(x) = \\log \\eta_0 + b \\cos(2\\pi x)$ with $b = \\log 2$.\n- Case $2$ (uniform): $\\phi_{\\mathrm{true}}(x) = \\log 2$ and current $\\phi(x) = \\log 1$.\n- Case $3$ (step): $\\phi_{\\mathrm{true}}(x) = \\log \\eta_{\\mathrm{low}}$ for $x  0.3$ and $\\phi_{\\mathrm{true}}(x) = \\log \\eta_{\\mathrm{high}}$ for $x \\ge 0.3$, with $\\eta_{\\mathrm{low}} = 0.5$, $\\eta_{\\mathrm{high}} = 5$. Current field $\\phi(x) = \\log \\eta_{\\mathrm{high}}$ for $x  0.3$ and $\\phi(x) = \\log \\eta_{\\mathrm{low}}$ for $x \\ge 0.3$.\n\nObservation nodes. Use interior nodes nearest to $x \\in \\{0.25, 0.5, 0.75\\}$, i.e., choose $\\mathcal{I}$ as those indices.\n\nVerification by directional derivative. In addition to computing the gradient vector $g_j = \\partial J/\\partial \\phi_j$, verify the adjoint by computing a directional finite-difference check along the direction $v_j = \\cos(2\\pi x_j)$:\n$$\n\\mathrm{FD} = \\frac{J(\\phi + \\varepsilon v) - J(\\phi)}{\\varepsilon}, \\quad \\varepsilon = 10^{-6}, \\quad \\mathrm{AD} = \\sum_{j=1}^{N_x} g_j v_j,\n$$\nand report the absolute error $|\\mathrm{FD} - \\mathrm{AD}|$.\n\nProgram requirements. Your program must:\n- Implement the forward solver, the discrete adjoint solver, and the gradient assembly as derived.\n- For each of the three test cases, output a list with three floating-point numbers: the misfit $J$, the Euclidean norm $\\|g\\|_2$, and the absolute adjoint test error $|\\mathrm{FD}-\\mathrm{AD}|$.\n- Produce a single line of output containing the results as a comma-separated list of the three per-case lists, enclosed in square brackets, e.g., $[[J_1,\\|g\\|_1,E_1],[J_2,\\|g\\|_2,E_2],[J_3,\\|g\\|_3,E_3]]$.\n\nAngle units do not apply. All quantities are nondimensional, so no physical units are required in your answer. Ensure numerical stability by adhering to the specified backward Euler updates. The output must be numerically computed and not symbolically simplified. The final output must be exactly one line in the specified format.",
            "solution": "The problem requires the derivation of discrete adjoint equations to compute the gradient of a misfit functional $J$ with respect to the logarithm of a spatially varying viscosity field, $\\phi(x) = \\log \\eta(x)$. The physical system is a one-dimensional Maxwell viscoelastic bar. The derivation must start from first principles using a Lagrangian approach.\n\nFirst, we verify the governing ordinary differential equation (ODE) for the spatially uniform shear stress $\\tau(t)$. The Maxwell constitutive relation is given by $\\dot{\\gamma}(x,t) = \\tau(t)/\\eta(x) + \\dot{\\tau}(t)/G$. Integrating with respect to $x$ from $0$ to $L$:\n$$ \\int_0^L \\dot{\\gamma}(x,t) \\, dx = \\int_0^L \\left(\\frac{\\tau(t)}{\\eta(x)} + \\frac{\\dot{\\tau}(t)}{G}\\right) dx $$\nThe left-hand side, using the kinematic relation $\\gamma = \\partial u/\\partial x$ and commuting the integral and time derivative, becomes:\n$$ \\int_0^L \\frac{\\partial \\dot{u}}{\\partial x} \\, dx = \\dot{u}(L,t) - \\dot{u}(0,t) $$\nWith boundary conditions $u(0,t)=0$ and $u(L,t)=U(t)$, this simplifies to $\\dot{U}(t)$. The right-hand side becomes:\n$$ \\tau(t) \\int_0^L \\frac{1}{\\eta(x)} \\, dx + \\frac{\\dot{\\tau}(t)}{G} \\int_0^L dx = \\tau(t) (L \\alpha) + \\frac{\\dot{\\tau}(t)}{G} L $$\nwhere $\\alpha \\equiv \\frac{1}{L}\\int_0^L \\frac{1}{\\eta(x)} \\, dx$. Equating the two sides gives $\\dot{U}(t) = L\\alpha\\tau(t) + \\frac{L}{G}\\dot{\\tau}(t)$. Rearranging and multiplying by $G/L$ yields the target ODE:\n$$ \\dot{\\tau}(t) + G \\alpha \\, \\tau(t) = \\frac{G}{L}\\, \\dot{U}(t) $$\nThe initial conditions $u(x,0)=0$ and $\\tau(0)=0$ are consistent with this model.\n\nThe core of the problem is to derive the discrete adjoint equations. We start by defining the discrete forward model and the misfit functional. Let $n=1, \\dots, N_t$ be the time step index, and $j=0, \\dots, N_x-1$ be the spatial cell index. Nodes are indexed by $i=0, \\dots, N_x$. The parameter field is $\\phi_j = \\log \\eta_j$.\n\nThe discrete forward model equations, rearranged to be zero, define the constraints $R=0$:\n1. Stress update ($n=1, \\dots, N_t$):\n   $$ R_{\\tau, n} \\equiv \\left(1+G\\alpha \\Delta t\\right)\\tau_n - \\tau_{n-1} - \\frac{G\\Delta t}{L} \\dot{U}_n = 0 $$\n   where $\\alpha = \\frac{\\Delta x}{L} \\sum_{j=0}^{N_x-1} e^{-\\phi_j}$.\n2. Strain update ($j=0, \\dots, N_x-1, n=1, \\dots, N_t$):\n   $$ R_{\\gamma, j, n} \\equiv \\gamma_j^n - \\gamma_j^{n-1} - \\Delta t \\tau_n e^{-\\phi_j} - \\frac{1}{G}(\\tau_n - \\tau_{n-1}) = 0 $$\n3. Displacement calculation ($i \\in \\mathcal{I}, n=1, \\dots, N_t$):\n   $$ R_{u, i, n} \\equiv u_i^n - \\Delta x \\sum_{m=0}^{i-1} \\gamma_m^n = 0 $$\nThe discrete misfit functional is:\n$$ J = \\frac{1}{2} \\sum_{n=1}^{N_t} w_t(t_n) \\sum_{i \\in \\mathcal{I}} w_x(x_i) \\left(u_i^n - d_i^n\\right)^2 $$\nwhere $d_i^n$ are synthetic data.\n\nThe Lagrangian $\\mathcal{L}$ is constructed by augmenting $J$ with the constraints, weighted by Lagrange multipliers $\\lambda_n$ (for stress), $\\mu_j^n$ (for strain), and $\\nu_i^n$ (for displacement):\n$$ \\mathcal{L} = J + \\sum_{n=1}^{N_t} \\lambda_n R_{\\tau, n} + \\sum_{n=1}^{N_t} \\sum_{j=0}^{N_x-1} \\mu_j^n R_{\\gamma, j, n} + \\sum_{n=1}^{N_t} \\sum_{i \\in \\mathcal{I}} \\nu_i^n R_{u, i, n} $$\nThe adjoint equations are derived by enforcing stationarity of $\\mathcal{L}$ with respect to the state variables $u_i^n, \\gamma_j^n, \\tau_n$. The total variation of $J$ with respect to $\\phi_k$ is then given by $\\frac{dJ}{d\\phi_k} = \\frac{\\partial \\mathcal{L}}{\\partial \\phi_k}$.\n\n- **Stationarity w.r.t. $u_i^n$ ($i \\in \\mathcal{I}$):** $\\frac{\\partial \\mathcal{L}}{\\partial u_i^n}=0$ yields the adjoint source:\n$$ \\frac{\\partial J}{\\partial u_i^n} + \\nu_i^n = 0 \\implies \\nu_i^n = - w_t(t_n) w_x(x_i) (u_i^n - d_i^n) $$\n\n- **Stationarity w.r.t. $\\gamma_j^n$:** $\\frac{\\partial \\mathcal{L}}{\\partial \\gamma_j^n}=0$ for $n=1,\\dots,N_t$. This leads to a backward recurrence for the strain multipliers $\\mu_j^n$.\n$$ \\frac{\\partial \\mathcal{L}}{\\partial \\gamma_j^n} = \\mu_j^n - \\mu_j^{n+1} + \\sum_{i \\in \\mathcal{I}} \\nu_i^n \\frac{\\partial R_{u,i,n}}{\\partial \\gamma_j^n} = 0 $$\nUsing $\\frac{\\partial R_{u,i,n}}{\\partial \\gamma_j^n} = -\\Delta x \\cdot \\mathbf{1}_{j \\le i-1}$, we get:\n$$ \\mu_j^n = \\mu_j^{n+1} + \\Delta x \\sum_{i \\in \\mathcal{I}, i > j} \\nu_i^n $$\nThe terminal condition is $\\mu_j^{N_t+1} = 0$. Let's define the adjoint forcing term $f_j^n = \\Delta x \\sum_{i \\in \\mathcal{I}, i > j} \\nu_i^n$. Then, $\\mu_j^n = \\mu_j^{n+1} + f_j^n$.\n\n- **Stationarity w.r.t. $\\tau_n$:** $\\frac{\\partial \\mathcal{L}}{\\partial \\tau_n}=0$ for $n=1,\\dots,N_t$. This yields a backward recurrence for the stress multipliers $\\lambda_n$.\n$$ \\frac{\\partial \\mathcal{L}}{\\partial \\tau_n} = \\lambda_n \\frac{\\partial R_{\\tau,n}}{\\partial \\tau_n} + \\lambda_{n+1} \\frac{\\partial R_{\\tau,n+1}}{\\partial \\tau_n} + \\sum_{j=0}^{N_x-1} \\left( \\mu_j^n \\frac{\\partial R_{\\gamma,j,n}}{\\partial \\tau_n} + \\mu_j^{n+1} \\frac{\\partial R_{\\gamma,j,n+1}}{\\partial \\tau_n} \\right) = 0 $$\nSubstituting the derivatives of the constraint residuals:\n$$ \\lambda_n (1+G\\alpha \\Delta t) - \\lambda_{n+1} + \\sum_{j=0}^{N_x-1} \\left[ \\mu_j^n(-\\Delta t e^{-\\phi_j} - 1/G) + \\mu_j^{n+1}(1/G) \\right] = 0 $$\nThe terminal condition is $\\lambda_{N_t+1}=0$. This can be rearranged into a backward update for $\\lambda_n$:\n$$ \\lambda_n (1+G\\alpha \\Delta t) = \\lambda_{n+1} + \\sum_{j=0}^{N_x-1} \\left[ \\mu_j^n(\\Delta t e^{-\\phi_j} + 1/G) - \\mu_j^{n+1}/G \\right] $$\nUsing $\\mu_j^{n+1} = \\mu_j^n - f_j^n$, this simplifies to a more computationally convenient form:\n$$ \\lambda_n = (1+G\\alpha \\Delta t)^{-1} \\left( \\lambda_{n+1} + \\Delta t \\sum_{j=0}^{N_x-1} \\mu_j^n e^{-\\phi_j} + \\frac{1}{G} \\sum_{j=0}^{N_x-1} f_j^n \\right) $$\n\n- **Gradient Calculation:** The gradient of $J$ with respect to $\\phi_k$ is $\\frac{dJ}{d\\phi_k} = \\frac{\\partial \\mathcal{L}}{\\partial \\phi_k}$.\n$$ \\frac{dJ}{d\\phi_k} = \\sum_{n=1}^{N_t} \\lambda_n \\frac{\\partial R_{\\tau,n}}{\\partial \\phi_k} + \\sum_{n=1}^{N_t} \\sum_{j=0}^{N_x-1} \\mu_j^n \\frac{\\partial R_{\\gamma,j,n}}{\\partial \\phi_k} $$\nThe necessary derivatives are:\n$$ \\frac{\\partial \\alpha}{\\partial \\phi_k} = -\\frac{\\Delta x}{L}e^{-\\phi_k} $$\n$$ \\frac{\\partial R_{\\tau,n}}{\\partial \\phi_k} = G \\Delta t \\tau_n \\frac{\\partial \\alpha}{\\partial \\phi_k} = -G \\frac{\\Delta x \\Delta t}{L} \\tau_n e^{-\\phi_k} $$\n$$ \\frac{\\partial R_{\\gamma,j,n}}{\\partial \\phi_k} = - \\Delta t \\tau_n \\frac{\\partial e^{-\\phi_j}}{\\partial \\phi_k} = \\Delta t \\tau_n e^{-\\phi_j} \\delta_{jk} $$\nSubstituting these into the expression for the gradient gives:\n$$ \\frac{dJ}{d\\phi_k} = \\sum_{n=1}^{N_t} \\left[ \\lambda_n \\left( -G \\frac{\\Delta x \\Delta t}{L} \\tau_n e^{-\\phi_k} \\right) + \\mu_k^n \\left( \\Delta t \\tau_n e^{-\\phi_k} \\right) \\right] $$\nFactoring out common terms yields the final expression for the gradient component:\n$$ \\frac{\\partial J}{\\partial \\phi_k} = \\Delta t \\, e^{-\\phi_k} \\sum_{n=1}^{N_t} \\tau_n \\left( \\mu_k^n - \\lambda_n G \\frac{\\Delta x}{L} \\right) $$\nThis expression is implemented by first running the forward model to store the history of state variables $(\\tau_n, \\gamma_j^n, u_i^n)$, then running the adjoint model backward in time to compute the multiplier histories $(\\lambda_n, \\mu_j^n)$, and finally accumulating the gradient contributions at each time step.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and produce the final output.\n    \"\"\"\n\n    class Params:\n        \"\"\"A container for simulation parameters.\"\"\"\n        def __init__(self):\n            self.L = 1.0\n            self.G = 10.0\n            self.U_max = 1.0\n            self.T0 = 0.5\n            self.Nt = 250\n            self.dt = 0.02\n            self.T = self.Nt * self.dt\n            self.Nx = 64\n            self.dx = self.L / self.Nx\n            \n            self.times = np.linspace(0, self.T, self.Nt + 1)\n            self.cell_coords = (np.arange(self.Nx) + 0.5) * self.dx\n            \n            obs_locs = [0.25, 0.5, 0.75]\n            self.obs_indices = [int(round(loc / self.dx)) for loc in obs_locs]\n            \n            self.wt = 1.0 / self.Nt\n            self.wx = 1.0 / len(self.obs_indices)\n\n            self.eps = 1e-6\n            self.pert_vec = np.cos(2 * np.pi * self.cell_coords)\n\n    def U_dot_fun(t, p):\n        \"\"\"Prescribed boundary velocity.\"\"\"\n        return (p.U_max / p.T0) * np.exp(-t / p.T0)\n\n    def run_forward(phi, p, d_hist=None):\n        \"\"\"Runs the forward model to compute state variables and, optionally, the misfit J.\"\"\"\n        tau_hist = np.zeros(p.Nt + 1)\n        gamma_hist = np.zeros((p.Nt + 1, p.Nx))\n        u_hist = np.zeros((p.Nt + 1, p.Nx + 1))\n        \n        inv_eta = np.exp(-phi)\n        alpha = (p.dx / p.L) * np.sum(inv_eta)\n        U_dot_hist = U_dot_fun(p.times, p)\n        tau_denom = 1.0 + p.G * alpha * p.dt\n\n        for n in range(1, p.Nt + 1):\n            tau_prev = tau_hist[n-1]\n            tau_num = tau_prev + (p.G * p.dt / p.L) * U_dot_hist[n]\n            tau_n = tau_num / tau_denom\n            tau_hist[n] = tau_n\n\n            gamma_prev = gamma_hist[n-1, :]\n            gamma_hist[n, :] = gamma_prev + p.dt * tau_n * inv_eta + (tau_n - tau_prev) / p.G\n            \n            # Efficient displacement update\n            u_hist[n, 1:] = np.cumsum(gamma_hist[n, :]) * p.dx\n        \n        J = 0.0\n        if d_hist is not None:\n            residuals = u_hist[1:, p.obs_indices] - d_hist[1:, p.obs_indices]\n            J = 0.5 * p.wt * p.wx * np.sum(residuals**2)\n\n        return J, (tau_hist, gamma_hist, u_hist)\n\n    def run_adjoint(phi, p, state_hist, d_hist):\n        \"\"\"Runs the adjoint model to compute the gradient of J w.r.t. phi.\"\"\"\n        tau_hist, _, u_hist = state_hist\n        \n        lambda_hist = np.zeros(p.Nt + 2)\n        mu_hist = np.zeros((p.Nt + 2, p.Nx))\n        grad = np.zeros(p.Nx)\n\n        inv_eta = np.exp(-phi)\n        alpha = (p.dx / p.L) * np.sum(inv_eta)\n        lambda_denom_inv = 1.0 / (1.0 + p.G * alpha * p.dt)\n\n        for n in range(p.Nt, 0, -1):\n            nu_n = np.zeros(p.Nx + 1)\n            res_n = u_hist[n,:] - d_hist[n,:]\n            for i_obs in p.obs_indices:\n                nu_n[i_obs] = -p.wt * p.wx * res_n[i_obs]\n\n            s = np.zeros(p.Nx)\n            s_sum_at_node = 0.0\n            for i_node in range(p.Nx, 0, -1):\n                if i_node in p.obs_indices:\n                    s_sum_at_node += nu_n[i_node]\n                \n                j_cell = i_node - 1\n                s[j_cell] = s_sum_at_node\n            \n            f_n = p.dx * s\n            \n            mu_n = mu_hist[n+1, :] + f_n\n\n            lambda_n_num = (lambda_hist[n+1] + \n                           p.dt * np.sum(mu_n * inv_eta) + \n                           (1.0/p.G) * np.sum(f_n))\n            lambda_n = lambda_n_num * lambda_denom_inv\n            \n            mu_hist[n, :] = mu_n\n            lambda_hist[n] = lambda_n\n\n            tau_n = tau_hist[n]\n            term1 = inv_eta * p.dt * tau_n\n            term2 = mu_n - lambda_n * p.G * p.dx / p.L\n            grad += term1 * term2\n\n        return grad\n\n    def run_case(p, phi_true_func, phi_current_func):\n        \"\"\"Executes one complete test case and returns results.\"\"\"\n        phi_true = phi_true_func(p.cell_coords)\n        phi_current = phi_current_func(p.cell_coords)\n\n        # Synthesize data\n        _, (_, _, d_hist) = run_forward(phi_true, p)\n        \n        # Misfit for current phi\n        J, state_hist = run_forward(phi_current, p, d_hist)\n        \n        # Gradient via adjoint\n        grad = run_adjoint(phi_current, p, state_hist, d_hist)\n        grad_norm = np.linalg.norm(grad)\n\n        # Finite difference check\n        phi_pert = phi_current + p.eps * p.pert_vec\n        J_pert, _ = run_forward(phi_pert, p, d_hist)\n        fd_deriv = (J_pert - J) / p.eps\n        ad_deriv = np.dot(grad, p.pert_vec)\n        error = abs(fd_deriv - ad_deriv)\n\n        return [J, grad_norm, error]\n\n    # --- Test Cases ---\n    p = Params()\n\n    # Case 1: Smooth contrast\n    phi_true_1 = lambda x: np.log(3) * np.sin(2 * np.pi * x)\n    phi_current_1 = lambda x: np.log(2) * np.cos(2 * np.pi * x)\n\n    # Case 2: Uniform\n    phi_true_2 = lambda x: np.full_like(x, np.log(2.0))\n    phi_current_2 = lambda x: np.full_like(x, np.log(1.0))\n\n    # Case 3: Step\n    def phi_true_3(x):\n        phi = np.full_like(x, np.log(5.0))\n        phi[x  0.3] = np.log(0.5)\n        return phi\n    def phi_current_3(x):\n        phi = np.full_like(x, np.log(0.5))\n        phi[x  0.3] = np.log(5.0)\n        return phi\n\n    test_cases = [\n        (phi_true_1, phi_current_1),\n        (phi_true_2, phi_current_2),\n        (phi_true_3, phi_current_3),\n    ]\n\n    all_results = []\n    for phi_true_f, phi_current_f in test_cases:\n        results = run_case(p, phi_true_f, phi_current_f)\n        all_results.append(results)\n\n    # Format output\n    output_str = '[' + ','.join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in all_results]) + ']'\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}