{
    "hands_on_practices": [
        {
            "introduction": "任何地质统计学分析的第一步都是理解数据的空间相关性。经验半变异函数是量化这一结构的核心工具，它揭示了数据值随样本点之间距离的增加而变化的程度。本练习  将通过一个小型、明确定义的数据集，带您亲手实践经验半变异函数的计算，从而巩固其基本定义和计算方法。",
            "id": "3599957",
            "problem": "在对一个无量纲地震振幅属性进行二维各向同性地质统计分析时，现有四个观测数据，其空间位置分别为 $(0,0)$、$(1,0)$、$(0,1)$ 和 $(1,1)$，对应的属性值分别为 $2.0$、$3.0$、$2.5$ 和 $3.5$。假设满足二阶平稳性，使用经典无偏经验估计量计算滞后距 $|h|=1$ 和 $|h|=\\sqrt{2}$ 处的全向经验半方差估计值 $\\hat{\\gamma}(h)$。构建以 $|h|$ 为中心、欧几里得范数下径向容差为 $0.01$ 的滞后距分组，并且如果任意无序对的分离距离落在该分组内，则只包含该对一次。按此顺序报告两个半方差估计值以及对每个估计值有贡献的数据对数量：$\\hat{\\gamma}(1)$、$\\hat{\\gamma}(\\sqrt{2})$、$N(1)$、$N(\\sqrt{2})$。无需四舍五入。半方差值以属性值的平方为单位，但最终数值答案中不附加单位。",
            "solution": "首先验证问题的科学性、适定性、客观性和完整性。问题陈述提供了一组四个带有相应属性值的空间数据点，并要求计算两个特定滞后距的全向经验半方差估计值。所有必要信息均已提供：位置 $\\mathbf{x}_i$、值 $Z(\\mathbf{x}_i)$、要使用的估计量（经典无偏）以及滞后距分组的参数（滞后距和容差）。二阶平稳性和各向同性的假设已明确说明，这在此类问题中是标准做法。该问题是基础地质统计学中一个定义明确的练习，因此被认为是有效的。\n\n对于给定的滞后距 $|h|$，半方差 $\\gamma(h)$ 的经典无偏经验估计量由以下公式给出：\n$$ \\hat{\\gamma}(|h|) = \\frac{1}{2N(|h|)} \\sum_{(\\mathbf{x}_i, \\mathbf{x}_j) \\in S(|h|)} [Z(\\mathbf{x}_i) - Z(\\mathbf{x}_j)]^2 $$\n其中 $S(|h|)$ 是所有唯一无序数据点对 $(\\mathbf{x}_i, \\mathbf{x}_j)$ 的集合，这些点对的分离距离 $d_{ij} = ||\\mathbf{x}_i - \\mathbf{x}_j||$ 落在以 $|h|$ 为中心的指定滞后距分组内。$N(|h|)$ 是这类点对的数量，即集合 $S(|h|)$ 的基数。\n\n给定的数据点如下：\n$P_1: \\mathbf{x}_1 = (0,0)$，值为 $Z(\\mathbf{x}_1) = 2.0$\n$P_2: \\mathbf{x}_2 = (1,0)$，值为 $Z(\\mathbf{x}_2) = 3.0$\n$P_3: \\mathbf{x}_3 = (0,1)$，值为 $Z(\\mathbf{x}_3) = 2.5$\n$P_4: \\mathbf{x}_4 = (1,1)$，值为 $Z(\\mathbf{x}_4) = 3.5$\n\n共有 $\\binom{4}{2} = 6$ 个唯一的无序点对。我们必须为每对点计算欧几里得距离 $d_{ij} = \\sqrt{(x_i-x_j)^2 + (y_i-y_j)^2}$ 和属性值的平方差 $[Z(\\mathbf{x}_i) - Z(\\mathbf{x}_j)]^2$。\n\n1.  点对 $(P_1, P_2)$：\n    $d_{12} = \\sqrt{(0-1)^2 + (0-0)^2} = \\sqrt{1} = 1$\n    $[Z(\\mathbf{x}_1) - Z(\\mathbf{x}_2)]^2 = (2.0 - 3.0)^2 = (-1.0)^2 = 1.0$\n\n2.  点对 $(P_1, P_3)$：\n    $d_{13} = \\sqrt{(0-0)^2 + (0-1)^2} = \\sqrt{1} = 1$\n    $[Z(\\mathbf{x}_1) - Z(\\mathbf{x}_3)]^2 = (2.0 - 2.5)^2 = (-0.5)^2 = 0.25$\n\n3.  点对 $(P_1, P_4)$：\n    $d_{14} = \\sqrt{(0-1)^2 + (0-1)^2} = \\sqrt{1+1} = \\sqrt{2}$\n    $[Z(\\mathbf{x}_1) - Z(\\mathbf{x}_4)]^2 = (2.0 - 3.5)^2 = (-1.5)^2 = 2.25$\n\n4.  点对 $(P_2, P_3)$：\n    $d_{23} = \\sqrt{(1-0)^2 + (0-1)^2} = \\sqrt{1+1} = \\sqrt{2}$\n    $[Z(\\mathbf{x}_2) - Z(\\mathbf{x}_3)]^2 = (3.0 - 2.5)^2 = (0.5)^2 = 0.25$\n\n5.  点对 $(P_2, P_4)$：\n    $d_{24} = \\sqrt{(1-1)^2 + (0-1)^2} = \\sqrt{1} = 1$\n    $[Z(\\mathbf{x}_2) - Z(\\mathbf{x}_4)]^2 = (3.0 - 3.5)^2 = (-0.5)^2 = 0.25$\n\n6.  点对 $(P_3, P_4)$：\n    $d_{34} = \\sqrt{(0-1)^2 + (1-1)^2} = \\sqrt{1} = 1$\n    $[Z(\\mathbf{x}_3) - Z(\\mathbf{x}_4)]^2 = (2.5 - 3.5)^2 = (-1.0)^2 = 1.0$\n\n接下来，我们将这些点对分组到指定的滞后距分组中。\n\n对于滞后距 $|h|=1$：\n滞后距分组以 $1$ 为中心，径向容差为 $0.01$，形成的区间为 $[1-0.01, 1+0.01] = [0.99, 1.01]$。\n分离距离落在此分组内的点对是那些 $d_{ij}=1$ 的点对。它们是 $(P_1, P_2)$、$(P_1, P_3)$、$(P_2, P_4)$ 和 $(P_3, P_4)$。\n点对数量为 $N(1) = 4$。\n这些点对的平方差之和为：\n$$ \\sum_{S(1)} [Z(\\mathbf{x}_i) - Z(\\mathbf{x}_j)]^2 = 1.0 + 0.25 + 0.25 + 1.0 = 2.5 $$\n半方差估计值为：\n$$ \\hat{\\gamma}(1) = \\frac{1}{2N(1)} \\times 2.5 = \\frac{1}{2 \\times 4} \\times 2.5 = \\frac{2.5}{8} = \\frac{5/2}{8} = \\frac{5}{16} = 0.3125 $$\n\n对于滞后距 $|h|=\\sqrt{2}$：\n滞后距分组以 $\\sqrt{2}$ 为中心，径向容差为 $0.01$。区间为 $[\\sqrt{2}-0.01, \\sqrt{2}+0.01]$。由于 $\\sqrt{2} \\approx 1.4142$，该区间约为 $[1.4042, 1.4242]$。\n分离距离落在此分组内的点对是那些 $d_{ij}=\\sqrt{2}$ 的点对。它们是 $(P_1, P_4)$ 和 $(P_2, P_3)$。\n点对数量为 $N(\\sqrt{2}) = 2$。\n这些点对的平方差之和为：\n$$ \\sum_{S(\\sqrt{2})} [Z(\\mathbf{x}_i) - Z(\\mathbf{x}_j)]^2 = 2.25 + 0.25 = 2.5 $$\n半方差估计值为：\n$$ \\hat{\\gamma}(\\sqrt{2}) = \\frac{1}{2N(\\sqrt{2})} \\times 2.5 = \\frac{1}{2 \\times 2} \\times 2.5 = \\frac{2.5}{4} = \\frac{5/2}{4} = \\frac{5}{8} = 0.625 $$\n\n要求的输出为 $\\hat{\\gamma}(1)$、$\\hat{\\gamma}(\\sqrt{2})$、$N(1)$ 和 $N(\\sqrt{2})$。\n$\\hat{\\gamma}(1) = 0.3125$\n$\\hat{\\gamma}(\\sqrt{2}) = 0.625$\n$N(1) = 4$\n$N(\\sqrt{2}) = 2$\n这些值是精确值，不需要四舍五入。\n最终答案必须按指定顺序报告。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.3125  0.625  4  2 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在构建了变异函数模型后，下一步就是建立并求解克里金方程组以进行预测。然而，理论上的优雅在实践中常会遇到数值稳定性问题，尤其是在样本点出现聚集时。本练习  作为一个“计算思维实验”，旨在深入剖析克里金矩阵的性质，理解病态条件是如何产生的，并评估为确保结果稳定可靠而采用的数值策略。",
            "id": "3599916",
            "problem": "考虑一个普通克里金法设置，用于一个二阶平稳高斯随机场，其均值未知但恒定，协方差函数为 $C(h)$，在 $h=0$ 处连续，且 $C(0)=\\sigma^{2}$（基台值），默认无掘金效应。普通克里金法源于最佳线性无偏估计（BLUE）原理：在所有满足无偏性约束 $\\sum_{i=1}^{n} \\lambda_{i}=1$ 的形式为 $\\hat{Z}(\\mathbf{x}_{0})=\\sum_{i=1}^{n} \\lambda_{i} Z(\\mathbf{x}_{i})$ 的线性估计量中，最小化估计方差 $\\mathrm{Var}[\\hat{Z}(\\mathbf{x}_{0})-Z(\\mathbf{x}_{0})]$。这导致求解一个增广线性系统，该系统包含协方差块 $C \\in \\mathbb{R}^{n \\times n}$ 和一个用于无偏性约束的拉格朗日乘子。众所周知，近乎重复的样本位置（即相距非常近的样本）会导致克里金线性系统出现严重的病态问题。\n\n假设您有 $n=3$ 个样本位于一条直线上，位置分别为 $x_{1}=0$、 $x_{2}=\\epsilon$ 和 $x_{3}=10$，其中 $\\epsilon>0$ 非常小（例如 $\\epsilon \\ll 1$），并使用指数协方差 $C(h)=\\sigma^{2}\\exp(-h/a)$，其中变程参数 $a>0$，基台值 $\\sigma^{2}>0$，且初始无掘金效应。目标是讨论此设置下克里金线性系统的条件，并评估几种稳定化策略。\n\n下列哪个陈述是正确的？选择所有适用项。\n\nA. 对于近乎重复的样本对 $\\{x_{1},x_{2}\\}$，其 $2\\times 2$ 协方差子矩阵的特征值为 $\\sigma^{2}(1\\pm \\exp(-\\epsilon/a))$，因此当 $\\epsilon \\to 0$ 时，最小特征值的行为类似于 $\\sigma^{2}\\,\\epsilon/a+o(\\epsilon)$，并且该子块的条件数以 $O(1/\\epsilon)$ 的速度增长。\n\nB. 如果用锥削协方差 $\\tilde{C}(h)=C(h)\\,T(h/\\theta)$ 替换 $C(h)$，其中 $T$ 是一个紧支集锥削函数，满足 $T(0)=1$ 和当 $r\\geq 1$ 时 $T(r)=0$，并且锥削范围 $\\theta$ 满足 $\\epsilon \\ll \\theta \\ll 10$，那么近乎重复的 $2\\times 2$ 子块基本保持不变，而长程相关性（例如 $x_{1}$ 或 $x_{2}$ 与 $x_{3}$ 之间的相关性）被减弱或置零；因此，在这种尺度下，由近乎重复的样本对驱动的病态问题通过锥削并未得到实质性改善。\n\nC. 添加一个正的掘金方差 $\\tau^{2}>0$ 对应于对协方差块进行对角加载，即 $C \\mapsto C+\\tau^{2} I$，这会将协方差块的每个特征值向上平移 $\\tau^{2}$，并严格减小其条件数；此外，当 $\\tau^{2}\\to 0^{+}$ 时，带掘金效应的普通克里金预测器收敛于无掘金效应的预测器，而对于任何固定的 $\\tau^{2}>0$，协方差块相对于其掘金增广谱是良态的。\n\nD. 对协方差块进行带主元的 Cholesky 分解，并采用一个秩揭示的停止准则（丢弃低于预定阈值的主元），可以识别由近乎重复的样本引起的近线性相关性；求解仅保留所选主元的降维系统，可以得到克里金预测器的一个数值稳定的近似，并且通过减小主元阈值可以使近似误差任意小。\n\nE. 在不改变相关函数的情况下，将基台值 $\\sigma^{2}$ 重新缩放为一个较小的值，可以减小协方差块的条件数，并且是添加掘金效应的一种数值稳定的替代方法。\n\nF. 对于位于 $x_{1}$ 和 $x_{2}$ 的两个样本，其中 $|x_{1}-x_{2}|=\\epsilon \\ll 1$，在普通克里金法中移除 $Z(x_{2})$ 并将 $Z(x_{1})$ 的权重加倍，对于任何目标位置 $\\mathbf{x}_{0}$，都能严格保持无偏性约束和克里金预测器不变。\n\n答案选项相互独立；可能有一个以上是正确的。您的推理应从协方差、二阶平稳过程的变异函数 $\\gamma(h)=\\sigma^{2}-C(h)$ 以及普通克里金法的 BLUE 公式等核心定义出发，不假设任何无法从这些基础推导出的专门公式。确保您的评估论及了近乎重复的样本对协方差块谱的影响、无偏性约束的作用，以及提到的三种稳定化策略（带主元的 Cholesky 分解、掘金正则化和协方差锥削）的数值影响。",
            "solution": "该问题陈述为地球统计学中一个有效且经典的场景，用以测试对普通克里金法中数值稳定性问题的理解。所有给定条件都是标准的、定义明确且科学合理的。该问题是适定的、客观的，允许对所提供的陈述进行严格的数学分析。\n\n用于确定定义最佳线性无偏估计（BLUE）$\\hat{Z}(\\mathbf{x}_{0})=\\sum_{i=1}^{n} \\lambda_{i} Z(\\mathbf{x}_{i})$的权重 $\\lambda_i$ 的普通克里金系统由以下增广矩阵方程给出：\n$$\n\\begin{pmatrix}\nC  \\mathbf{1} \\\\\n\\mathbf{1}^T  0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\boldsymbol{\\lambda} \\\\\n\\mu\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{c}_0 \\\\\n1\n\\end{pmatrix}\n$$\n这里，$C$ 是 $n \\times n$ 的协方差矩阵，其元素为 $C_{ij} = \\mathrm{Cov}(Z(\\mathbf{x}_i), Z(\\mathbf{x}_j)) = C(\\mathbf{x}_i - \\mathbf{x}_j)$，$\\mathbf{1}$ 是一个全1向量，$\\boldsymbol{\\lambda}$ 是权重向量，$\\mu$ 是用于无偏性约束 $\\sum \\lambda_i = 1$ 的拉格朗日乘子，$\\mathbf{c}_0$ 是样本点与目标点之间的协方差向量，其元素为 $(\\mathbf{c}_0)_i = C(\\mathbf{x}_i - \\mathbf{x}_0)$。\n\n问题指出，近乎重复的样本位置会导致严重的病态问题。这种病态源于协方差块 $C$。如果两个点 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$ 非常接近，那么由于 $C(h)$ 的连续性，对于所有 $k$ 都有 $C(\\mathbf{x}_i - \\mathbf{x}_k) \\approx C(\\mathbf{x}_j - \\mathbf{x}_k)$，因此 $C$ 的第 $i$ 行（和列）与第 $j$ 行（和列）变得几乎相同。这使得矩阵 $C$ 近似奇异。\n\n我们给定 $n=3$ 个点，位于 $x_1=0$、$x_2=\\epsilon$ 和 $x_3=10$，其中 $\\epsilon \\ll 1$。协方差函数为 $C(h) = \\sigma^2 \\exp(-|h|/a)$。协方差矩阵 $C$ 是：\n$$\nC = \\sigma^2\n\\begin{pmatrix}\n1  e^{-\\epsilon/a}  e^{-10/a} \\\\\ne^{-\\epsilon/a}  1  e^{-(10-\\epsilon)/a} \\\\\ne^{-10/a}  e^{-(10-\\epsilon)/a}  1\n\\end{pmatrix}\n$$\n当 $\\epsilon \\to 0$ 时，前两行和前两列变得几乎相同，导致病态。我们现在逐一评估每个陈述。\n\n**A. 对于近乎重复的样本对 $\\{x_{1},x_{2}\\}$，其 $2\\times 2$ 协方差子矩阵的特征值为 $\\sigma^{2}(1\\pm \\exp(-\\epsilon/a))$，因此当 $\\epsilon \\to 0$ 时，最小特征值的行为类似于 $\\sigma^{2}\\,\\epsilon/a+o(\\epsilon)$，并且该子块的条件数以 $O(1/\\epsilon)$ 的速度增长。**\n\n对应于点对 $\\{x_1, x_2\\}$ 的子矩阵是 $C_{sub} = \\begin{pmatrix} C(0)  C(\\epsilon) \\\\ C(\\epsilon)  C(0) \\end{pmatrix} = \\sigma^2 \\begin{pmatrix} 1  e^{-\\epsilon/a} \\\\ e^{-\\epsilon/a}  1 \\end{pmatrix}$。\n特征值 $\\lambda$ 通过求解特征方程 $\\det(C_{sub} - \\lambda I) = 0$ 得到：\n$$ (\\sigma^2 - \\lambda)^2 - (\\sigma^2 e^{-\\epsilon/a})^2 = 0 $$\n$$ \\sigma^2 - \\lambda = \\pm \\sigma^2 e^{-\\epsilon/a} $$\n$$ \\lambda = \\sigma^2(1 \\mp e^{-\\epsilon/a}) $$\n两个特征值是 $\\lambda_{max} = \\sigma^2(1 + e^{-\\epsilon/a})$ 和 $\\lambda_{min} = \\sigma^2(1 - e^{-\\epsilon/a})$。陈述中给出的特征值表达式 $\\sigma^2(1 \\pm \\exp(-\\epsilon/a))$ 正确地描述了这个集合。\n\n现在，我们研究当 $\\epsilon \\to 0$ 时的行为。最小的特征值是 $\\lambda_{min}$。对指数函数使用泰勒展开，$e^{-x} = 1 - x + O(x^2)$ 对于小的 $x$ 成立：\n$$ \\lambda_{min} = \\sigma^2 \\left( 1 - \\left(1 - \\frac{\\epsilon}{a} + O\\left(\\left(\\frac{\\epsilon}{a}\\right)^2\\right)\\right) \\right) = \\sigma^2 \\left( \\frac{\\epsilon}{a} - O(\\epsilon^2) \\right) = \\sigma^2 \\frac{\\epsilon}{a} + o(\\epsilon) $$\n这与陈述相符。\n\n$C_{sub}$ 的条件数是 $\\kappa(C_{sub}) = \\frac{\\lambda_{max}}{\\lambda_{min}}$。\n当 $\\epsilon \\to 0$ 时，$e^{-\\epsilon/a} \\to 1$，所以 $\\lambda_{max} \\to \\sigma^2(1+1) = 2\\sigma^2$。\n$$ \\kappa(C_{sub}) = \\frac{\\sigma^2(1 + e^{-\\epsilon/a})}{\\sigma^2(1 - e^{-\\epsilon/a})} \\approx \\frac{2}{\\epsilon/a} = \\frac{2a}{\\epsilon} $$\n因此，条件数以 $O(1/\\epsilon)$ 的速度增长，这也与陈述相符。\n\n结论：**正确**。\n\n**B. 如果用锥削协方差 $\\tilde{C}(h)=C(h)\\,T(h/\\theta)$ 替换 $C(h)$，其中 $T$ 是一个紧支集锥削函数，满足 $T(0)=1$ 和当 $r\\geq 1$ 时 $T(r)=0$，并且锥削范围 $\\theta$ 满足 $\\epsilon \\ll \\theta \\ll 10$，那么近乎重复的 $2\\times 2$ 子块基本保持不变，而长程相关性（例如 $x_{1}$ 或 $x_{2}$ 与 $x_{3}$ 之间的相关性）被减弱或置零；因此，在这种尺度下，由近乎重复的样本对驱动的病态问题通过锥削并未得到实质性改善。**\n\n锥削协方差矩阵 $\\tilde{C}$ 的元素为 $\\tilde{C}_{ij} = C(h_{ij})T(h_{ij}/\\theta)$。\n对于近乎重复的样本对，距离是 $h_{12} = \\epsilon$。由于 $\\epsilon \\ll \\theta$，锥削函数的参数为 $\\epsilon/\\theta \\ll 1$。因为 $T$ 是连续的且 $T(0)=1$，所以 $T(\\epsilon/\\theta) \\approx 1$。因此，$\\{x_1, x_2\\}$ 的子块变为 $\\sigma^2 \\begin{pmatrix} 1  e^{-\\epsilon/a}T(\\epsilon/\\theta) \\\\ e^{-\\epsilon/a}T(\\epsilon/\\theta)  1 \\end{pmatrix}$，这确实是“基本保持不变”。\n\n对于长程相关性，距离为 $h_{13} = 10$ 和 $h_{23} = 10-\\epsilon$。条件 $\\theta \\ll 10$ 意味着 $10/\\theta \\gg 1$ 和 $(10-\\epsilon)/\\theta \\gg 1$。由于当 $r \\ge 1$ 时 $T(r)=0$，我们有 $T(10/\\theta) = 0$ 和 $T((10-\\epsilon)/\\theta) = 0$。因此，$\\tilde{C}_{13}$ 和 $\\tilde{C}_{23}$ 变为零。如陈述所述，长程相关性被置零。\n\n锥削后的矩阵近似为块对角矩阵：\n$$\n\\tilde{C} \\approx\n\\begin{pmatrix}\n\\sigma^2  \\sigma^2 e^{-\\epsilon/a}  0 \\\\\n\\sigma^2 e^{-\\epsilon/a}  \\sigma^2  0 \\\\\n0  0  \\sigma^2\n\\end{pmatrix}\n$$\n该矩阵的特征值是左上角 $2 \\times 2$ 块的特征值和 $\\sigma^2$。这个 $2 \\times 2$ 块的特征值是 $\\sigma^2(1 \\pm e^{-\\epsilon/a})$。$\\tilde{C}$ 的最小特征值是 $\\lambda_{min}(\\tilde{C}) \\approx \\sigma^2(1 - e^{-\\epsilon/a}) \\approx \\sigma^2 \\epsilon / a$。最大特征值是 $\\lambda_{max}(\\tilde{C}) \\approx \\sigma^2(1 + e^{-\\epsilon/a}) \\approx 2\\sigma^2$。因此，整个锥削矩阵 $\\tilde{C}$ 的条件数是 $\\kappa(\\tilde{C}) \\approx \\frac{2\\sigma^2}{\\sigma^2 \\epsilon / a} = O(1/\\epsilon)$。采用这种 $\\theta$ 选择的锥削过程，隔离了病态子问题，但并未解决其固有的病态性。因此，整体的病态问题没有得到实质性改善。\n\n结论：**正确**。\n\n**C. 添加一个正的掘金方差 $\\tau^{2}>0$ 对应于对协方差块进行对角加载，即 $C \\mapsto C+\\tau^{2} I$，这会将协方差块的每个特征值向上平移 $\\tau^{2}$，并严格减小其条件数；此外，当 $\\tau^{2}\\to 0^{+}$ 时，带掘金效应的普通克里金预测器收敛于无掘金效应的预测器，而对于任何固定的 $\\tau^{2}>0$，协方差块相对于其掘金增广谱是良态的。**\n\n设 $C$ 的特征值为 $\\lambda_i$。矩阵 $C' = C + \\tau^2 I$ 的特征值为 $\\lambda_i' = \\lambda_i + \\tau^2$。这是线性代数的一个标准结果，所以特征值确实向上平移了 $\\tau^2$。\n\n新的条件数是 $\\kappa(C') = \\frac{\\lambda_{max} + \\tau^2}{\\lambda_{min} + \\tau^2}$。原来的条件数是 $\\kappa(C) = \\frac{\\lambda_{max}}{\\lambda_{min}}$。我们检查当 $\\tau^2  0$ 时是否有 $\\kappa(C')  \\kappa(C)$：\n$$ \\frac{\\lambda_{max} + \\tau^2}{\\lambda_{min} + \\tau^2}  \\frac{\\lambda_{max}}{\\lambda_{min}} \\iff \\lambda_{min}(\\lambda_{max} + \\tau^2)  \\lambda_{max}(\\lambda_{min} + \\tau^2) $$\n$$ \\lambda_{min}\\lambda_{max} + \\lambda_{min}\\tau^2  \\lambda_{max}\\lambda_{min} + \\lambda_{max}\\tau^2 \\iff \\lambda_{min}\\tau^2  \\lambda_{max}\\tau^2 $$\n由于 $\\tau^2 > 0$，这等价于 $\\lambda_{min}  \\lambda_{max}$。对于任何非平凡的协方差矩阵（即不是单位矩阵的倍数），这是成立的。因此，添加一个正的掘金值严格减小了条件数。\n\n克里金权重 $\\boldsymbol{\\lambda}$ 是一个线性系统的解。由于当 $\\tau^2 \\ge 0$ 时该系统的矩阵是可逆的（假设点是不同的），解 $\\boldsymbol{\\lambda}(\\tau^2)$ 是 $\\tau^2$ 的连续函数。因此，$\\lim_{\\tau^2 \\to 0^+} \\boldsymbol{\\lambda}(\\tau^2) = \\boldsymbol{\\lambda}(0)$。预测器 $\\hat{Z}(\\mathbf{x}_0) = \\boldsymbol{\\lambda}^T \\mathbf{Z}$ 也因此收敛。\n\n对于任何固定的 $\\tau^2 > 0$，$C+\\tau^2 I$ 的最小特征值是 $\\lambda_{min} + \\tau^2$。由于 $C$ 是半正定的，$\\lambda_{min} \\ge 0$。因此，$C+\\tau^2 I$ 的所有特征值都有一个大于0的下界 $\\tau^2$。条件数 $\\kappa(C+\\tau^2 I)$ 因此有上界 $(\\lambda_{max}+\\tau^2) / \\tau^2$，这是一个有限值。这正是 Tikhonov 正则化（掘金效应是其一个特例）的本质，它使得问题变得良态。“相对于其掘金增广谱是良态的”这一短语正确地暗示了条件现在由掘金值 $\\tau^2$ 的大小控制。\n\n结论：**正确**。\n\n**D. 对协方差块进行带主元的 Cholesky 分解，并采用一个秩揭示的停止准则（丢弃低于预定阈值的主元），可以识别由近乎重复的样本引起的近线性相关性；求解仅保留所选主元的降维系统，可以得到克里金预测器的一个数值稳定的近似，并且通过减小主元阈值可以使近似误差任意小。**\n\n这个陈述准确地描述了通过带主元的 Cholesky 分解进行低秩近似的方法。\n1. 像带主元的 Cholesky 这样的秩揭示分解 ($P^T C P = L L^T$) 会对变量（$C$ 的列）进行排序，从而尽早揭示线性相关性。列之间的近共线性（由近乎重复的点引起）导致分解过程中出现非常小的对角线元素（主元）。对主元大小设置阈值能有效地检测到这种近线性相关性。\n2. 当主元低于阈值时停止分解，会得到一个低秩近似 $C \\approx L_k L_k^T$，其中 $L_k$ 是因子中的良态部分。在由前 $k$ 个主元列张成的子空间中解决克里金问题是一个数值稳定的过程。\n3. 主元阈值控制了近似的秩 $k$。一个较小的阈值允许接受更多的主元，从而增加 $k$。随着阈值趋近于零，$k$ 趋近于矩阵的真实秩（如果矩阵满秩但病态，则为 $n$），近似误差减小。因此，通过降低阈值，可以使误差任意小，但代价是包含了更多矩阵的病态部分。\n\n结论：**正确**。\n\n**E. 在不改变相关函数的情况下，将基台值 $\\sigma^{2}$ 重新缩放为一个较小的值，可以减小协方差块的条件数，并且是添加掘金效应的一种数值稳定的替代方法。**\n\n协方差矩阵可以写成 $C = \\sigma^2 R$，其中 $R$ 是相关矩阵，$R_{ij} = \\exp(-h_{ij}/a)$。$C$ 的特征值为 $\\lambda_i(C) = \\sigma^2 \\lambda_i(R)$。条件数是最大特征值与最小特征值之比：\n$$ \\kappa(C) = \\frac{\\max_i \\lambda_i(C)}{\\min_i \\lambda_i(C)} = \\frac{\\sigma^2 \\max_i \\lambda_i(R)}{\\sigma^2 \\min_i \\lambda_i(R)} = \\frac{\\max_i \\lambda_i(R)}{\\min_i \\lambda_i(R)} = \\kappa(R) $$\n条件数仅取决于相关矩阵 $R$，而 $R$ 由样本几何形状和相关函数决定，与基台值 $\\sigma^2$ 无关。因此，重新缩放基台值对条件数没有影响。陈述的第一部分是错误的。由于这不等同于添加掘金值（添加掘金值会改变条件数），因此第二部分也是错误的。\n\n结论：**不正确**。\n\n**F. 对于位于 $x_{1}$ 和 $x_{2}$ 的两个样本，其中 $|x_{1}-x_{2}|=\\epsilon \\ll 1$，在普通克里金法中移除 $Z(x_{2})$ 并将 $Z(x_{1})$ 的权重加倍，对于任何目标位置 $\\mathbf{x}_{0}$，都能严格保持无偏性约束和克里金预测器不变。**\n\n这个陈述是不正确的，因为“严格保持”这个术语。对于任何 $\\epsilon > 0$，点 $x_1$ 和 $x_2$ 是不同的，信息对 $\\{Z(x_1), Z(x_2)\\}$ 与单一信息 $Z(x_1)$ 是不同的。基于 $n$ 个不同点的 BLUE 是唯一的，不能与基于 $n-1$ 个点的子集的 BLUE 完全相同。后者是一个近似。严格保持只在 $\\epsilon=0$ 的奇异极限下发生。\n此外，“将权重加倍”部分定义不明确且通常是错误的。首先，权重是克里金系统的输出，而不是用户定义的输入。其次，即使我们将其解释为 $n$ 点问题（$\\boldsymbol{\\lambda}$）和 $(n-1)$ 点问题（$\\boldsymbol{\\lambda}'$）的权重之间的关系，在 $\\epsilon=0$ 的极限下，正确的关系是 $x_1$ 上的新权重等于 $x_1$ 和 $x_2$ 上的旧权重之和，即 $\\lambda_1' = \\lambda_1 + \\lambda_2$。只有在 $\\lambda_1 = \\lambda_2$ 的特殊情况下，这个和才等于 $2\\lambda_1$，而这需要一定程度的对称性，对于任意目标位置 $\\mathbf{x}_0$ 而言，这种对称性是无法保证的。该陈述的说法不精确且不严格成立。\n\n结论：**不正确**。",
            "answer": "$$\\boxed{ABCD}$$"
        },
        {
            "introduction": "本章的最后一个练习将理论与实践相结合，要求您完成一个完整的应用任务：为球形地球上的卫星数据实现克里金插值。这个高级实践  超越了简单的欧几里得空间，它要求您仔细考虑距离度量的选择（大地线距离与弦距离）及其对协方差模型和最终预测精度的影响，尤其是在像两极这样的几何敏感区域。",
            "id": "3599939",
            "problem": "您的任务是使用两种竞争性的距离度量：大圆测地距离和三维弦距离，在球体上对卫星重力残差实现非欧几里得普通克里金法。目标是比较一个尊重球面几何的球面马特恩族协方差与一个将点视为嵌入三维欧几里得空间中的弦距离近似。您必须评估并量化这些选择对两极附近预测精度的影响。\n\n您应在以下有科学依据的假设和定义下工作，这些假设和定义是推导的基础：\n\n- 卫星重力残差被建模为球体上二阶平稳高斯过程的一个实现。普通克里金法使用模型协方差寻求最佳线性无偏估计（BLUE），并通过一个未知的常数均值来约束无偏性。\n- 协方差族是马特恩类，由一个平滑度参数和一个尺度（范围）参数参数化。球面马特恩模型使用球体上的大圆测地距离，而弦距离近似使用固定半径球体上嵌入点之间的欧几里得弦长。\n- 大圆距离是球体上的测地距离；弦距离是地球内部两个表面点之间的直线距离。\n- 地球被建模为一个理想球体，半径为 $R = 6371\\,\\mathrm{km}$。\n\n角度和距离：\n\n- 所有输入角度（纬度和经度）均以度为单位提供。在内部，您必须将它们转换为弧度以进行所有三角运算。\n- 所有距离必须以公里为单位计算和使用。\n\n为了避免任何随机性，您将获得一个球体上的确定性地面真值残差场（单位：毫伽，mGal）。设纬度为 $\\lambda$（弧度，北为正），经度为 $\\phi$（弧度，东为正），余纬为 $\\theta$，其中 $\\cos(\\theta) = \\sin(\\lambda)$。将真实残差场定义为\n$$\nf(\\lambda,\\phi) = 0.8 \\cdot \\frac{1}{2}\\left(3\\sin^2\\lambda - 1\\right) + 0.5 \\cdot \\cos^2\\lambda \\cdot \\sin\\left(2\\phi\\right) + 0.2 \\cdot \\sin\\lambda,\n$$\n以 $\\mathrm{mGal}$ 为单位进行评估。没有测量噪声；块金效应纯粹用于数值稳定。\n\n克里金模型细节：\n\n- 使用普通克里金法，通过无偏性约束强制施加一个未知的常数均值。\n- 使用平滑度 $\\nu = 1.5$、边际方差（基台）$\\sigma^2 = 1.0$ $\\mathrm{mGal}^2$ 的马特恩协方差，以及三个不同的范围参数 $\\rho \\in \\{500, 2000, 6000\\}$ $\\mathrm{km}$ 作为参数值的测试套件。为了数值稳定性，在协方差矩阵的对角线上添加一个小的块金值 $\\tau^2 = 10^{-6}$ $\\mathrm{mGal}^2$。不要将块金值包含在克里金方差的目标方差项中。\n- 实现两个版本的协方差函数：\n  1. 球面马特恩：使用半径为 $R$ 的球体上的测地大圆距离 $d_g$。\n  2. 弦距离马特恩：使用半径为 $R$ 的球体上三维位置之间的弦长 $d_c$。\n\n数据：\n\n- 训练位置（度）：纬度 $\\{-60,-30,0,30,60\\}$ 和经度 $\\{0,72,144,216,288\\}$。使用五组纬度和五组经度的所有配对，总共 $25$ 个训练点。不要将两极包含在训练集中。\n- 目标位置（度）：\n  - 极地集：纬度 $\\{85,-85\\}$，经度 $\\{0,90,180,270\\}$，总共 $8$ 个目标。\n  - 赤道集：纬度 $\\{0\\}$，经度 $\\{45,135,225,315\\}$，总共 $4$ 个目标。\n- 在所有训练和目标位置评估 $f(\\lambda,\\phi)$，以获得无噪声的训练值和地面真值目标。\n\n计算任务：\n\n- 在内部将所有角度从度转换为弧度。确保所有距离都在半径为 $R = 6371\\,\\mathrm{km}$ 的球体上以公里为单位计算。\n- 对于每个范围参数 $\\rho \\in \\{500, 2000, 6000\\}$：\n  - 使用 $d_g$ 或 $d_c$ 构建训练协方差矩阵，在对角线上添加块金值 $\\tau^2$，并为每个目标求解普通克里金系统。\n  - 计算两种距离度量在极地和赤道目标的预测值。\n  - 分别计算极地和赤道目标的均方根误差（RMSE），将预测值与地面真值 $f(\\lambda,\\phi)$ 进行比较。\n  - 对于每个 $\\rho$，报告以下量：\n    1. 使用带大圆距离的球面马特恩模型在极地目标的均方根误差。\n    2. 使用弦距离马特恩模型在极地目标的均方根误差。\n    3. 使用带大圆距离的球面马特恩模型在赤道目标的均方根误差。\n    4. 使用弦距离马特恩模型在赤道目标的均方根误差。\n    5. 定义为 $\\mathrm{RMSE}_{\\text{chordal}} - \\mathrm{RMSE}_{\\text{spherical}}$ 的极地均方根误差差异。\n    6. 一个布尔值，指示球面马特恩模型在极地目标的均方根误差是否低于弦距离马特恩模型。\n\n数值和物理单位要求：\n\n- 距离必须以 $\\mathrm{km}$ 为单位。\n- 角度必须转换为弧度以进行三角计算。\n- 残差以 $\\mathrm{mGal}$ 为单位，但程序的最终打印输出必须是无单位的数值；不要在输出中包含单位。\n\n测试套件和覆盖范围：\n\n- 三个范围参数 $\\rho \\in \\{500, 2000, 6000\\}$ 作为测试套件，旨在测试短程行为（度量差异可忽略不计）、中程行为和远程行为（度量差异最显著）。\n- 极地与赤道评估集旨在强调两极附近和赤道沿线的几何特性。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须按升序 $\\{500,2000,6000\\}$ 为每个 $\\rho$ 依次包含上述指定的六个输出。这将产生一个包含 $18$ 个条目的扁平列表：\n  - 对于 $\\rho = 500$：项目 $1$ 到 $6$。\n  - 对于 $\\rho = 2000$：项目 $7$ 到 $12$。\n  - 对于 $\\rho = 6000$：项目 $13$ 到 $18$。\n- 所需格式示例（值为占位符）：\"[x1,x2,x3,x4,x5,b1,x7,x8,x9,x10,x11,b2,x13,x14,x15,x16,x17,b3]\"。",
            "solution": "该问题要求实现并比较两种用于球体上地球物理场的普通克里金模型。这些模型的核心区别在于协方差函数中使用的距离度量：一个采用球体上的真实测地（大圆）距离，另一个则使用欧几里得弦距离近似。目标是量化预测精度的差异，特别是在几何畸变最显著的两极附近。\n\n解决方案的结构如下：首先，我们定义普通克里金法的理论基础和所使用的具体模型。其次，我们详细说明实现策略，包括坐标系、距离计算和克里金算法。最后，我们描述基于均方根误差（RMSE）的评估过程。\n\n**1. 理论框架**\n\n**普通克里金模型**\n\n我们将卫星重力残差建模为二阶平稳高斯随机场 $Z(\\mathbf{x})$ 的单次实现，其中 $\\mathbf{x}$ 是球体上的一个位置。该场具有未知但恒定的均值 $E[Z(\\mathbf{x})] = m$ 和已知的协方差函数 $\\text{Cov}(Z(\\mathbf{x}_i), Z(\\mathbf{x}_j)) = C(d(\\mathbf{x}_i, \\mathbf{x}_j))$，其中 $d$ 是一个距离度量。\n\n普通克里金法为目标位置 $\\mathbf{x}_0$ 处的值 $Z(\\mathbf{x}_0)$ 提供了最佳线性无偏估计（BLUE）。估计量 $\\hat{Z}(\\mathbf{x}_0)$ 是在训练位置 $\\mathbf{x}_i$ 处的 $n$ 个观测值 $z_i = Z(\\mathbf{x}_i)$ 的加权线性组合：\n$$\n\\hat{Z}(\\mathbf{x}_0) = \\sum_{i=1}^{n} \\lambda_i z_i\n$$\n无偏性约束 $E[\\hat{Z}(\\mathbf{x}_0)] = E[Z(\\mathbf{x}_0)]$ 要求权重之和为1：\n$$\n\\sum_{i=1}^{n} \\lambda_i = 1\n$$\n在这一约束条件下，最小化估计方差 $\\text{Var}(\\hat{Z}(\\mathbf{x}_0) - Z(\\mathbf{x}_0))$，可得到以下线性方程组，可以求解权重 $\\boldsymbol{\\lambda} = [\\lambda_1, \\dots, \\lambda_n]^T$ 和拉格朗日乘子 $\\mu$：\n$$\n\\begin{pmatrix}\n\\mathbf{K} + \\tau^2\\mathbf{I}  \\mathbf{1} \\\\\n\\mathbf{1}^T  0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\boldsymbol{\\lambda} \\\\\n\\mu\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{k}_0 \\\\\n1\n\\end{pmatrix}\n$$\n此处，$\\mathbf{K}$ 是训练点之间的 $n \\times n$ 协方差矩阵，其元素为 $K_{ij} = C(d(\\mathbf{x}_i, \\mathbf{x}_j))$。项 $\\tau^2\\mathbf{I}$ 代表块金效应，为保证数值稳定性而加到 $\\mathbf{K}$ 的对角线上，其中 $\\tau^2 = 10^{-6} \\, \\mathrm{mGal}^2$ 且 $\\mathbf{I}$ 是单位矩阵。向量 $\\mathbf{k}_0$ 包含目标点 $\\mathbf{x}_0$ 与每个训练点之间的协方差，其元素为 $(\\mathbf{k}_0)_i = C(d(\\mathbf{x}_0, \\mathbf{x}_i))$。向量 $\\mathbf{1}$ 是一个 $n$ 维的全1列向量。\n\n**协方差函数**\n\n该问题指定了平滑度参数为 $\\nu = 1.5$ 的马特恩协方差族。该函数由下式给出：\n$$\nC(d; \\sigma^2, \\rho) = \\sigma^2 \\left(1 + \\frac{\\sqrt{3}d}{\\rho}\\right) \\exp\\left(-\\frac{\\sqrt{3}d}{\\rho}\\right)\n$$\n其中 $d$ 是距离，$\\sigma^2=1.0 \\, \\mathrm{mGal}^2$ 是边际方差（基台），$\\rho$ 是空间范围参数，取值为 $\\{500, 2000, 6000\\} \\, \\mathrm{km}$。\n\n**球体上的距离度量**\n\n分析的关键在于比较 $d$ 的两种距离度量：\n1.  **测地（大圆）距离 ($d_g$)**：这是球体表面两点之间的最短距离。对于半径为 $R = 6371 \\, \\mathrm{km}$ 的球体上具有球面坐标 $(\\lambda_1, \\phi_1)$ 和 $(\\lambda_2, \\phi_2)$ 的两点，距离为 $d_g = R \\cdot \\Delta\\sigma$，其中 $\\Delta\\sigma$ 是两点之间的中心角。一种数值稳定的计算方法是通过它们单位笛卡尔向量 $\\mathbf{v}_1$ 和 $\\mathbf{v}_2$ 的点积来计算：$\\Delta\\sigma = \\arccos(\\mathbf{v}_1 \\cdot \\mathbf{v}_2)$。这是球体上过程的几何正确距离。\n\n2.  **弦距离 ($d_c$)**：这是穿过球体内部的直线欧几里得距离。给定球面上两点对应的笛卡尔坐标 $\\mathbf{p}_1$ 和 $\\mathbf{p}_2$，距离为 $d_c = \\|\\mathbf{p}_1 - \\mathbf{p}_2\\|_2$。该度量在小间距时能近似 $d_g$，但在大间距时会显著低估它，因为它忽略了空间的曲率。\n\n**2. 实现策略**\n\n**数据和坐标系**\n所有输入的纬度 ($\\lambda$) 和经度 ($\\phi$) 坐标均以度为单位给出，必须转换为弧度以进行三角计算。球面坐标 $(\\lambda, \\phi)$ 被转换为三维笛卡尔坐标系，用于计算弦距离并方便测地距离的计算：\n$$\nx = R \\cos\\lambda \\cos\\phi \\quad ; \\quad y = R \\cos\\lambda \\sin\\phi \\quad ; \\quad z = R \\sin\\lambda\n$$\n在指定的训练和目标位置对地面真值场 $f(\\lambda, \\phi)$ 进行评估，以生成“观测到”的训练值和用于误差计算的真值。\n\n**算法流程**\n对于每个范围参数 $\\rho \\in \\{500, 2000, 6000\\}$，对球面（测地）模型和弦模型都执行以下过程：\n\n1.  **构建协方差矩阵**：使用所选度量（$d_g$ 或 $d_c$）计算所有训练点对之间的 $25 \\times 25$ 距离矩阵。将马特恩协方差函数应用于此距离矩阵以形成协方差矩阵 $\\mathbf{K}$。将块金值 $\\tau^2$ 添加到对角线元素。\n\n2.  **求解克里金系统**：构成一个增广的 $26 \\times 26$ 矩阵 $\\mathbf{A} = \\begin{pmatrix} \\mathbf{K} + \\tau^2\\mathbf{I}  \\mathbf{1} \\\\ \\mathbf{1}^T  0 \\end{pmatrix}$。为了高效地为多个目标点求解权重，我们为每个模型设置计算一次逆矩阵 $\\mathbf{A}^{-1}$。\n\n3.  **计算预测值**：对于每个目标点（在极地和赤道集中）：\n    a.  使用相应的距离度量和马特恩函数，计算目标点与所有训练点之间的协方差向量 $\\mathbf{k}_0$。\n    b.  构建右侧向量 $\\mathbf{b} = [\\mathbf{k}_0^T, 1]^T$。\n    c.  计算权重向量 $\\mathbf{w} = \\mathbf{A}^{-1} \\mathbf{b}$。\n    d.  预测值是前 $n$ 个权重与训练值的点积：$\\hat{f}(\\mathbf{x}_0) = \\boldsymbol{\\lambda}^T \\mathbf{z}$。\n\n**评估度量**\n每个模型的性能通过均方根误差（RMSE）来量化，该误差分别为极地和赤道目标集计算：\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N_{\\text{targets}}} \\sum_{i=1}^{N_{\\text{targets}}} (\\hat{f}_i - f_i)^2}\n$$\n其中 $\\hat{f}_i$ 是预测值，而 $f_i$ 是地面真值。最终要求的输出是这些RMSE值、它们在两极的差异以及一个布尔比较。\n\n这个全面的程序允许在标准的地统计学背景下，对使用几何正确的球面距离与简化的欧几里得近似所产生的影响进行严格的、定量的比较。目标位置的选择，特别是靠近两极的位置，旨在突出弦距离模型在几何上的缺陷。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import inv\n\ndef solve():\n    \"\"\"\n    Implements and compares spherical vs. chordal-distance ordinary kriging\n    on a sphere to evaluate prediction accuracy for a synthetic gravity field.\n    \"\"\"\n    # ------------------\n    # 1. Constants and Setup\n    # ------------------\n    R_EARTH = 6371.0  # km\n    SIGMA2 = 1.0  # mGal^2, marginal variance (sill)\n    TAU2 = 1e-6  # mGal^2, nugget for numerical stability\n    RHO_VALUES = [500.0, 2000.0, 6000.0]  # km, range parameters\n\n    # Define observation and target locations in degrees\n    train_lats_deg = [-60, -30, 0, 30, 60]\n    train_lons_deg = [0, 72, 144, 216, 288]\n    polar_target_lats_deg = [85, -85]\n    polar_target_lons_deg = [0, 90, 180, 270]\n    eq_target_lats_deg = [0]\n    eq_target_lons_deg = [45, 135, 225, 315]\n\n    # Create lists of (latitude, longitude) pairs\n    train_locs_deg = [(lat, lon) for lat in train_lats_deg for lon in train_lons_deg]\n    polar_target_locs_deg = [(lat, lon) for lat in polar_target_lats_deg for lon in polar_target_lons_deg]\n    eq_target_locs_deg = [(lat, lon) for lat in eq_target_lats_deg for lon in eq_target_lons_deg]\n\n    # Convert all locations to radians for calculations\n    train_locs_rad = [(np.deg2rad(lat), np.deg2rad(lon)) for lat, lon in train_locs_deg]\n    polar_target_locs_rad = [(np.deg2rad(lat), np.deg2rad(lon)) for lat, lon in polar_target_locs_deg]\n    eq_target_locs_rad = [(np.deg2rad(lat), np.deg2rad(lon)) for lat, lon in eq_target_locs_deg]\n\n    # ------------------\n    # 2. Helper Functions\n    # ------------------\n\n    def ground_truth(lat_rad, lon_rad):\n        \"\"\"Computes the true residual field value f(lambda, phi).\"\"\"\n        sin_lat = np.sin(lat_rad)\n        cos_lat = np.cos(lat_rad)\n        term1 = 0.8 * 0.5 * (3 * sin_lat**2 - 1)\n        term2 = 0.5 * cos_lat**2 * np.sin(2 * lon_rad)\n        term3 = 0.2 * sin_lat\n        return term1 + term2 + term3\n\n    def to_cartesian(lat_rad, lon_rad, radius):\n        \"\"\"Converts spherical coordinates (lat, lon) to 3D Cartesian.\"\"\"\n        x = radius * np.cos(lat_rad) * np.cos(lon_rad)\n        y = radius * np.cos(lat_rad) * np.sin(lon_rad)\n        z = radius * np.sin(lat_rad)\n        return np.array([x, y, z])\n\n    def great_circle_distance(loc1_rad, loc2_rad, radius):\n        \"\"\"Computes great-circle distance using unit vectors and arccos.\"\"\"\n        lat1, lon1 = loc1_rad\n        lat2, lon2 = loc2_rad\n        \n        v1 = to_cartesian(lat1, lon1, 1.0)\n        v2 = to_cartesian(lat2, lon2, 1.0)\n        \n        dot_product = np.dot(v1, v2)\n        dot_product = np.clip(dot_product, -1.0, 1.0)\n        \n        central_angle = np.arccos(dot_product)\n        return radius * central_angle\n\n    def chordal_distance(p1_cart, p2_cart):\n        \"\"\"Computes Euclidean chordal distance between two Cartesian points.\"\"\"\n        return np.linalg.norm(p1_cart - p2_cart)\n\n    def matern_15(d, rho):\n        \"\"\"Matérn covariance with nu=1.5 and sigma^2=1.0.\"\"\"\n        arg = np.sqrt(3) * d / rho\n        return (1.0 + arg) * np.exp(-arg)\n\n    def calculate_rmse(predictions, truths):\n        \"\"\"Computes the Root Mean Square Error.\"\"\"\n        return np.sqrt(np.mean((predictions - truths)**2))\n\n    # Pre-compute Cartesian coordinates for all locations\n    train_locs_cart = [to_cartesian(lat, lon, R_EARTH) for lat, lon in train_locs_rad]\n    polar_target_locs_cart = [to_cartesian(lat, lon, R_EARTH) for lat, lon in polar_target_locs_rad]\n    eq_target_locs_cart = [to_cartesian(lat, lon, R_EARTH) for lat, lon in eq_target_locs_rad]\n\n    # Generate training values and ground-truth target values\n    train_values = np.array([ground_truth(lat, lon) for lat, lon in train_locs_rad])\n    polar_target_true_values = np.array([ground_truth(lat, lon) for lat, lon in polar_target_locs_rad])\n    eq_target_true_values = np.array([ground_truth(lat, lon) for lat, lon in eq_target_locs_rad])\n\n    # ------------------\n    # 3. Main Processing Loop\n    # ------------------\n    \n    all_results = []\n    n_train = len(train_locs_rad)\n    \n    for rho in RHO_VALUES:\n        #\n        # --- Spherical Model (Great-Circle Distance) ---\n        #\n        K_spherical = np.zeros((n_train, n_train))\n        for i in range(n_train):\n            for j in range(i, n_train):\n                dist = great_circle_distance(train_locs_rad[i], train_locs_rad[j], R_EARTH)\n                cov = matern_15(dist, rho)\n                K_spherical[i, j] = K_spherical[j, i] = cov\n        \n        K_spherical += TAU2 * np.identity(n_train)\n        \n        A_spherical = np.ones((n_train + 1, n_train + 1))\n        A_spherical[:n_train, :n_train] = K_spherical\n        A_spherical[n_train, n_train] = 0.0\n        A_inv_spherical = inv(A_spherical)\n\n        def krige(target_locs_rad, A_inv):\n            preds = []\n            for target_loc_rad in target_locs_rad:\n                k0 = np.array([matern_15(great_circle_distance(target_loc_rad, train_loc, R_EARTH), rho) for train_loc in train_locs_rad])\n                b = np.append(k0, 1.0)\n                weights = A_inv @ b\n                preds.append(weights[:n_train] @ train_values)\n            return np.array(preds)\n\n        polar_preds_spherical = krige(polar_target_locs_rad, A_inv_spherical)\n        eq_preds_spherical = krige(eq_target_locs_rad, A_inv_spherical)\n\n        #\n        # --- Chordal Model ---\n        #\n        K_chordal = np.zeros((n_train, n_train))\n        for i in range(n_train):\n            for j in range(i, n_train):\n                dist = chordal_distance(train_locs_cart[i], train_locs_cart[j])\n                cov = matern_15(dist, rho)\n                K_chordal[i, j] = K_chordal[j, i] = cov\n        \n        K_chordal += TAU2 * np.identity(n_train)\n\n        A_chordal = np.ones((n_train + 1, n_train + 1))\n        A_chordal[:n_train, :n_train] = K_chordal\n        A_chordal[n_train, n_train] = 0.0\n        A_inv_chordal = inv(A_chordal)\n\n        def krige_chordal(target_locs_cart, A_inv):\n            preds = []\n            for target_loc_cart in target_locs_cart:\n                k0 = np.array([matern_15(chordal_distance(target_loc_cart, train_loc_cart), rho) for train_loc_cart in train_locs_cart])\n                b = np.append(k0, 1.0)\n                weights = A_inv @ b\n                preds.append(weights[:n_train] @ train_values)\n            return np.array(preds)\n        \n        polar_preds_chordal = krige_chordal(polar_target_locs_cart, A_inv_chordal)\n        eq_preds_chordal = krige_chordal(eq_target_locs_cart, A_inv_chordal)\n        \n        # ------------------\n        # 4. Compute and Store Results\n        # ------------------\n        \n        rmse_polar_s = calculate_rmse(polar_preds_spherical, polar_target_true_values)\n        rmse_polar_c = calculate_rmse(polar_preds_chordal, polar_target_true_values)\n        rmse_eq_s = calculate_rmse(eq_preds_spherical, eq_target_true_values)\n        rmse_eq_c = calculate_rmse(eq_preds_chordal, eq_target_true_values)\n        \n        diff_polar_rmse = rmse_polar_c - rmse_polar_s\n        is_spherical_better_polar = rmse_polar_s  rmse_polar_c\n        \n        all_results.extend([\n            rmse_polar_s,\n            rmse_polar_c,\n            rmse_eq_s,\n            rmse_eq_c,\n            diff_polar_rmse,\n            is_spherical_better_polar\n        ])\n\n    # ------------------\n    # 5. Final Output\n    # ------------------\n    \n    # Format results to string: booleans as lowercase, floats to 10 decimal places.\n    def format_result(r):\n        if isinstance(r, (bool, np.bool_)):\n            return str(r).lower()\n        return f\"{r:.10f}\"\n\n    print(f\"[{','.join(map(format_result, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}