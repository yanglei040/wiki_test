{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的数值模型之前，理解由线性化浅水方程描述的海啸波的基本行为至关重要。本练习使用达朗贝尔公式 (d'Alembert's formula) 来求解初始扰动后的波形演化 ，这个过程清晰地展示了波的分裂和传播，为更高级模型的验证提供了基准。",
            "id": "3618013",
            "problem": "在深度均匀的深海中，一维（1D）海啸波列可以用线性浅水方程来近似。考虑一个理想化的、深度恒定且无边界的一维无限域，其中自由表面位移 $\\,\\eta(x,t)\\,$ 和深度平均水平速度 $\\,u(x,t)\\,$ 满足线性浅水方程组\n$$\\eta_{t}(x,t)+h\\,u_{x}(x,t)=0,\\qquad u_{t}(x,t)+g\\,\\eta_{x}(x,t)=0,$$\n其中 $\\,h\\,$ 为恒定深度，$\\,g\\,$ 为重力加速度。水体初始静止，表面有一个局部抬升：\n$$\\eta(x,0)=\\eta_{0}(x)=A\\,\\exp\\!\\left(-\\frac{(x-x_{0})^{2}}{2\\,\\sigma^{2}}\\right),\\qquad u(x,0)=0.$$\n从这些方程出发，推导 $\\,\\eta(x,t)\\,$ 的控制方程，并获得与给定初始条件一致的 $\\,\\eta(x,t)\\,$ 的传播解，该解以 $\\,\\eta_{0}\\,$ 的封闭形式表示。然后，对于参数值 $\\,A=1.5\\,$ 米，$\\,x_{0}=0\\,$ 米，$\\,\\sigma=3.0\\times 10^{4}\\,$ 米，$\\,h=4.0\\times 10^{3}\\,$ 米，以及 $\\,g=9.81\\,$ 米/秒²，计算在 $\\,x=1.0\\times 10^{5}\\,$ 米和 $\\,t=6.0\\times 10^{2}\\,$ 秒时 $\\,\\eta(x,t)\\,$ 的值。将最终位移以米为单位表示，并将答案四舍五入到四位有效数字。",
            "solution": "该问题是有效的，因为它具有科学依据、提法明确且客观。它描述了线性浅水方程的一个标准初值问题，这是地球物理流体动力学中的一个基本模型。所有参数和条件在物理上是现实的，在数学上是一致的。\n\n自由表面位移 $\\eta(x,t)$ 和深度平均水平速度 $u(x,t)$ 的控制方程是线性浅水方程：\n$$ \\eta_{t}(x,t)+h\\,u_{x}(x,t)=0 \\quad (1) $$\n$$ u_{t}(x,t)+g\\,\\eta_{x}(x,t)=0 \\quad (2) $$\n其中 $h$ 是恒定深度，$g$ 是重力加速度。下标表示偏微分。\n\n为了推导 $\\eta(x,t)$ 的单个控制方程，我们将方程 $(1)$ 对 $t$ 求导，将方程 $(2)$ 对 $x$ 求导：\n$$ \\eta_{tt}+h\\,u_{xt}=0 \\quad (3) $$\n$$ u_{tx}+g\\,\\eta_{xx}=0 \\quad (4) $$\n假设 $\\eta$ 和 $u$ 足够光滑，则混合偏导数相等（Clairaut's theorem），即 $u_{xt}=u_{tx}$。我们可以将 $(4)$ 中的 $u_{xt}$ 代入 $(3)$：\n$$ \\eta_{tt} - g h\\,\\eta_{xx} = 0 $$\n这是 $\\eta(x,t)$ 的一维线性波动方程：\n$$ \\eta_{tt} = c^{2}\\eta_{xx} $$\n其中波的传播速度为 $c=\\sqrt{gh}$。\n\n这个波动方程的通解由 d'Alembert 公式给出：\n$$ \\eta(x,t) = \\frac{1}{2}\\left[\\eta(x-ct,0) + \\eta(x+ct,0)\\right] + \\frac{1}{2c}\\int_{x-ct}^{x+ct} \\eta_{t}(s,0) \\,ds $$\n我们已知的初始条件是：\n$$ \\eta(x,0) = \\eta_{0}(x) = A\\,\\exp\\!\\left(-\\frac{(x-x_{0})^{2}}{2\\,\\sigma^{2}}\\right) $$\n$$ u(x,0) = 0 $$\n为了使用 d'Alembert 公式，我们需要 $\\eta_t(x,0)$ 的初始条件。从方程 $(1)$，我们有 $\\eta_{t} = -h\\,u_{x}$。在 $t=0$ 时：\n$$ \\eta_{t}(x,0) = -h\\,u_{x}(x,0) $$\n由于对所有 $x$ 都有 $u(x,0)=0$，其空间导数也必须为零：$u_{x}(x,0)=0$。因此，第二个初始条件是 $\\eta_{t}(x,0)=0$。\n\n将初始条件 $\\eta(x,0)=\\eta_{0}(x)$ 和 $\\eta_{t}(x,0)=0$ 代入 d'Alembert 公式，积分项消失，解简化为：\n$$ \\eta(x,t) = \\frac{1}{2}\\left[\\eta_{0}(x-ct) + \\eta_{0}(x+ct)\\right] $$\n这个解描述了初始的高斯剖面分裂成两个相同的波，每个波的振幅为初始振幅的一半，以速度 $c$ 向相反方向传播。\n\n代入 $\\eta_{0}(x)$ 的具体形式：\n$$ \\eta(x,t) = \\frac{A}{2}\\left[\\exp\\!\\left(-\\frac{(x-ct-x_{0})^{2}}{2\\,\\sigma^{2}}\\right) + \\exp\\!\\left(-\\frac{(x+ct-x_{0})^{2}}{2\\,\\sigma^{2}}\\right)\\right] $$\n现在，我们用给定的参数值来计算这个表达式：\n$A=1.5$ 米\n$x_{0}=0$ 米\n$\\sigma=3.0\\times 10^{4}$ 米\n$h=4.0\\times 10^{3}$ 米\n$g=9.81$ 米/秒²\n$x=1.0\\times 10^{5}$ 米\n$t=6.0\\times 10^{2}$ 秒\n\n首先，计算波速 $c$：\n$$ c = \\sqrt{gh} = \\sqrt{(9.81\\,\\text{m/s}^2)(4.0\\times 10^{3}\\,\\text{m})} = \\sqrt{39240} \\approx 198.090888\\,\\text{m/s} $$\n接着，计算 $ct$ 项：\n$$ ct \\approx (198.090888\\,\\text{m/s})(6.0\\times 10^{2}\\,\\text{s}) \\approx 118854.5329\\,\\text{m} $$\n指数中的分母是 $2\\sigma^2$：\n$$ 2\\sigma^{2} = 2(3.0\\times 10^{4}\\,\\text{m})^{2} = 2(9.0\\times 10^{8}\\,\\text{m}^2) = 1.8\\times 10^{9}\\,\\text{m}^2 $$\n当 $x_0=0$ 时的解是：\n$$ \\eta(x,t) = \\frac{1.5}{2}\\left[\\exp\\!\\left(-\\frac{(x-ct)^{2}}{2\\sigma^{2}}\\right) + \\exp\\!\\left(-\\frac{(x+ct)^{2}}{2\\sigma^{2}}\\right)\\right] $$\n现在，计算指数函数的参数：\n对于第一项（向右传播的波）：\n$$ x-ct \\approx (1.0\\times 10^{5} - 118854.5329)\\,\\text{m} = -18854.5329\\,\\text{m} $$\n$$ -\\frac{(x-ct)^{2}}{2\\sigma^{2}} \\approx -\\frac{(-18854.5329)^{2}}{1.8\\times 10^{9}} \\approx -0.1974963 $$\n对于第二项（向左传播的波）：\n$$ x+ct \\approx (1.0\\times 10^{5} + 118854.5329)\\,\\text{m} = 218854.5329\\,\\text{m} $$\n$$ -\\frac{(x+ct)^{2}}{2\\sigma^{2}} \\approx -\\frac{(218854.5329)^{2}}{1.8\\times 10^{9}} \\approx -26.60964 $$\n现在将这些值代入 $\\eta(x,t)$ 的表达式中：\n$$ \\eta(1.0\\times 10^5, 6.0\\times 10^2) \\approx \\frac{1.5}{2}\\left[\\exp(-0.1974963) + \\exp(-26.60964)\\right] $$\n$$ \\eta(1.0\\times 10^5, 6.0\\times 10^2) \\approx 0.75\\left[0.8207914 + 2.77 \\times 10^{-12}\\right] $$\n第二个指数项可以忽略不计。\n$$ \\eta(1.0\\times 10^5, 6.0\\times 10^2) \\approx 0.75 \\times 0.8207914 \\approx 0.61559355\\,\\text{m} $$\n四舍五入到四位有效数字，位移是 $0.6156$ 米。",
            "answer": "$$ \\boxed{0.6156} $$"
        },
        {
            "introduction": "当我们从解析解转向使用显式时间步进的数值模拟时，确保计算的稳定性至关重要。本练习探讨了 Courant–Friedrichs–Lewy (CFL) 条件，这是一个关键概念，它将物理波速、网格尺寸和最大允许时间步长联系起来，以防止数值解变得不稳定和无意义 。您将确定在一个具有变化深度和水流的域中，最具限制性的时间步长。",
            "id": "3618044",
            "problem": "考虑在一个从陆架到深海的剖面上的一维海啸波传播，该传播由守恒形式的非线性浅水方程建模，其中水平坐标为 $x \\in [0,L]$，网格间距为常数 $\\Delta x$。区域长度为 $L = 2.0 \\times 10^{5}\\,\\mathrm{m}$，网格间距为 $\\Delta x = 2.0 \\times 10^{3}\\,\\mathrm{m}$。重力加速度为 $g = 9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$。静水深度从陆架到深海线性变化，其表达式为 $h(x) = h_{0} + \\alpha x$，其中 $h_{0} = 50\\,\\mathrm{m}$ 且 $\\alpha = \\dfrac{4000 - 50}{L}\\,\\mathrm{m}\\,\\mathrm{m}^{-1}$。存在背景流 $u(x) = u_{0} + \\beta x$，其中 $u_{0} = 0.2\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$ 且 $\\beta = \\dfrac{1.0 - 0.2}{L}\\,\\mathrm{(m\\,s^{-1})\\,m^{-1}}$，使得 $u(L) = 1.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$。假设采用显式守恒有限体积离散化，并使用单步时间积分器，其数值通量与控制方程的特征信号速度相一致。此类显式格式的稳定性由 Courant–Friedrichs–Lewy (CFL) 条件控制，选定的 CFL 数为 $C = 0.45$。\n\n从控制方程和特征波传播速度的定义出发，推导该模型中由 CFL 准则所隐含的局部稳定性限制时间步长 $\\Delta t(x)$。然后，分析 $\\Delta t(x)$ 在空间非均匀域上的变化情况，并确定必须用于整个模拟的全局稳定时间步长 $\\Delta t^{\\ast} = \\min_{x \\in [0,L]} \\Delta t(x)$。将 $\\Delta t^{\\ast}$ 的最终数值以秒为单位表示，并将答案四舍五入到四位有效数字。",
            "solution": "合适的出发点是守恒变量下的一维非线性浅水系统。将守恒状态向量记为 $\\boldsymbol{q} = \\begin{pmatrix} h \\\\ m \\end{pmatrix}$，其中 $h$ 是流体深度，$m = h u$ 是深度积分动量。通量向量为 $\\boldsymbol{f}(\\boldsymbol{q}) = \\begin{pmatrix} m \\\\ \\dfrac{m^{2}}{h} + \\dfrac{1}{2} g h^{2} \\end{pmatrix}$。守恒律为\n$$\n\\partial_{t} \\boldsymbol{q} + \\partial_{x} \\boldsymbol{f}(\\boldsymbol{q}) = \\boldsymbol{0}.\n$$\n在局部状态 $(h,u)$ 附近进行线性化，得到一个通量雅可比矩阵 $\\boldsymbol{A} = \\dfrac{\\partial \\boldsymbol{f}}{\\partial \\boldsymbol{q}}$，其特征值是系统的特征速度。标准计算可得\n$$\n\\lambda_{\\pm} = u \\pm \\sqrt{g h}.\n$$\n这些是相对于地面的非线性浅水重力波的传播速度。对于具有单步时间积分器的显式守恒有限体积法，Courant–Friedrichs–Lewy (CFL) 条件指出，时间步长必须足够小，以使最快的特征波在一个步长内移动的距离不超过一个单元格的 $C$ 倍。在均匀网格间距 $\\Delta x$ 下，这意味着局部约束条件\n$$\n\\Delta t(x) \\leq C \\,\\frac{\\Delta x}{\\max\\{|\\lambda_{+}(x)|,\\,|\\lambda_{-}(x)|\\}}.\n$$\n因为对于 $h(x) > 0$，有 $\\sqrt{g h(x)} \\geq 0$，且两个特征值关于 $u(x)$ 对称，可得\n$$\n\\max\\{|\\lambda_{+}(x)|,\\,|\\lambda_{-}(x)|\\} = |u(x)| + \\sqrt{g\\,h(x)}.\n$$\n因此，局部稳定性限制的时间步长为\n$$\n\\Delta t(x) = C \\,\\frac{\\Delta x}{\\,|u(x)| + \\sqrt{g\\,h(x)}\\,}.\n$$\n\n给定 $h(x) = h_{0} + \\alpha x$，其中 $h_{0} = 50\\,\\mathrm{m}$ 且 $\\alpha = \\dfrac{4000 - 50}{L}$，以及 $u(x) = u_{0} + \\beta x$，其中 $u_{0} = 0.2\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$ 且 $\\beta = \\dfrac{1.0 - 0.2}{L}$。区域长度为 $L = 2.0 \\times 10^{5}\\,\\mathrm{m}$，网格间距为 $\\Delta x = 2.0 \\times 10^{3}\\,\\mathrm{m}$，且 $g = 9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$。CFL 数为 $C = 0.45$。\n\n首先，计算 $\\alpha$ 和 $\\beta$：\n$$\n\\alpha = \\frac{4000 - 50}{2.0 \\times 10^{5}} = \\frac{3950}{2.0 \\times 10^{5}} = 1.975 \\times 10^{-2}\\,\\mathrm{m}\\,\\mathrm{m}^{-1},\n$$\n$$\n\\beta = \\frac{1.0 - 0.2}{2.0 \\times 10^{5}} = \\frac{0.8}{2.0 \\times 10^{5}} = 4.0 \\times 10^{-6}\\,\\mathrm{(m\\,s^{-1})\\,m^{-1}}.\n$$\n因此，$h(x)$ 和 $u(x)$ 随 $x$ 线性增加。由于 $\\sqrt{g h(x)}$ 是 $h(x)$ 的单调递增函数，且对于给定的正值，$|u(x)|$ 是 $u(x)$ 的单调递增函数，所以分母 $|u(x)| + \\sqrt{g h(x)}$ 随 $x$ 增加，使得 $\\Delta t(x)$ 成为 $x$ 的单调递减函数。因此，$\\Delta t(x)$ 的全局最小值出现在右边界 $x = L$ 处。\n\n计算在 $x=L$ 处的量：\n$$\nh(L) = h_{0} + \\alpha L = 50 + 1.975 \\times 10^{-2} \\times 2.0 \\times 10^{5} = 50 + 3950 = 4000\\,\\mathrm{m},\n$$\n$$\nu(L) = u_{0} + \\beta L = 0.2 + 4.0 \\times 10^{-6} \\times 2.0 \\times 10^{5} = 0.2 + 0.8 = 1.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1}.\n$$\n计算在 $x=L$ 处的重力波速度：\n$$\nc(L) = \\sqrt{g\\,h(L)} = \\sqrt{9.81 \\times 4000} = \\sqrt{39240}.\n$$\n高精度计算给出\n$$\n\\sqrt{39240} \\approx 198.09089\\,\\mathrm{m}\\,\\mathrm{s}^{-1}.\n$$\n因此，最大局部特征速度为\n$$\ns_{\\max}(L) = |u(L)| + c(L) \\approx 1.0 + 198.09089 = 199.09089\\,\\mathrm{m}\\,\\mathrm{s}^{-1}.\n$$\n于是，全局稳定时间步长为\n$$\n\\Delta t^{\\ast} = C \\,\\frac{\\Delta x}{s_{\\max}(L)} \\approx 0.45 \\times \\frac{2.0 \\times 10^{3}}{199.09089}\\,\\mathrm{s}.\n$$\n计算商：\n$$\n\\frac{2.0 \\times 10^{3}}{199.09089} \\approx 10.04566\\,\\mathrm{s},\n$$\n所以\n$$\n\\Delta t^{\\ast} \\approx 0.45 \\times 10.04566 \\approx 4.52055\\,\\mathrm{s}.\n$$\n四舍五入到四位有效数字并以秒为单位表示，全局时间步长为\n$$\n\\Delta t^{\\ast} \\approx 4.521\\,\\mathrm{s}.\n$$\n\n就其在整个区域内的变化而言，局部时间步长 $\\Delta t(x) = C \\,\\dfrac{\\Delta x}{\\,|u(x)| + \\sqrt{g\\,h(x)}\\,}$ 随 $x$ 减小，因为 $h(x)$ 和 $u(x)$ 都线性增加。在陆架附近 ($x \\approx 0$)，较小的深度产生较小的重力波速度，从而得到较大的 $\\Delta t(x)$；往深海方向 ($x \\approx L$)，大得多的深度产生显著更大的 $\\sqrt{g h}$，从而减小了 $\\Delta t(x)$。因此，最具限制性的时间步长出现在区域中最深、流速最快的部分，这与上述单调性分析一致。",
            "answer": "$$\\boxed{4.521}$$"
        },
        {
            "introduction": "为数值模型编写代码只是工作的一半；验证代码没有错误并正确实现了预期的方程同样重要。本练习介绍了“人造解方法”（Method of Manufactured Solutions, MMS），这是一种强大的代码验证技术 。通过设计一个具有已知解析解的问题，您可以严格测试您的实现，并确认其达到了理论上的收敛精度。",
            "id": "3618014",
            "problem": "考虑用于描述恒定水深下、围绕静止状态的海啸波传播的一维线性化深度平均浅水方程。设 $x \\in [0,L]$ 且具有周期性边界条件，时间 $t \\in [0,T]$。未知量为自由表面高程 $\\eta(x,t)$（单位：米）和深度平均水平速度 $u(x,t)$（单位：米/秒）。控制方程为\n$$\n\\eta_t + h_0 u_x = S_\\eta(x,t), \\qquad u_t + g \\eta_x = S_u(x,t),\n$$\n其中 $h_0$ 是恒定静水深度（单位：米），$g$ 是重力加速度（单位：米/秒²），$S_\\eta,S_u$ 是外部指定的源项。该域在 $x$ 方向上是周期的。\n\n使用人造解方法来验证一个数值实现的形式时空精度阶。具体来说，您必须：\n- 从深度平均层中的质量和动量守恒出发，在静止状态和恒定深度下进行线性化，从而得到上述方程组。这是您唯一可以假定的出发点。\n- 选择光滑、空间周期的人造场 $\\eta(x,t)$ 和 $u(x,t)$，并解析推导出源项 $S_\\eta(x,t)$ 和 $S_u(x,t)$，使得所选的 $\\eta(x,t)$ 和 $u(x,t)$ 对所有 $x,t$ 都满足该强迫系统。\n- 实现一个求解器，在空间上使用二阶精度中心有限差分，在时间上使用二阶强稳定性保持龙格－库塔（SSP-RK2）方法。使用周期性边界条件。为保证稳定性，基于线性波速 $c=\\sqrt{g h_0}$ 使用 Courant–Friedrichs–Lewy 条件来计算时间步长：选择 $\\Delta t = \\text{CFL}\\, \\Delta x/c$，并通过使用整数个步数来调整，以确保精确地在最终时间 $T$ 结束。\n- 为了进行替代的时间精度验证，使用快速傅里叶变换实现一个谱微分算子，从而使空间离散误差可以忽略不计。\n- 为了进行替代的空间精度验证，在时间上实现一个经典的四阶龙格－库塔（RK4）方法，并使 $\\Delta t$ 与 $\\Delta x$ 成正比，从而使时间误差相对于二阶空间误差可以忽略不计。\n\n人造解。您必须在长度为 $L$ 的周期域上使用以下光滑人造解：\n$$\n\\phi(x,t) = \\kappa x - \\omega t, \\qquad \\psi(x,t) = 2\\kappa x + \\omega t,\n$$\n$$\n\\eta(x,t) = A \\cos(\\phi(x,t)) + B \\sin(\\psi(x,t)), \\qquad u(x,t) = C \\sin(\\phi(x,t)) + D \\cos(\\psi(x,t)),\n$$\n其中 $A,B$ 的单位是米，$C,D$ 的单位是米/秒，$\\kappa = 2\\pi m/L$（$m$ 是整数波数），$\\omega$ 是角频率（单位：弧度/秒）。根据控制方程和这些定义，仅使用微分和代数运算，以闭式形式解析推导出 $S_\\eta(x,t)$ 和 $S_u(x,t)$。\n\n数值方法。您的实现必须：\n- 使用 $N$ 个点将 $x$ 均匀离散化，$\\Delta x = L/N$，并采用周期性边界条件。\n- 对于联合时空测试，使用二阶中心差分计算 $f_x$：$f_x[i] \\approx \\left(f[i+1]-f[i-1]\\right)/(2\\Delta x)$。\n- 对于时间阶测试，使用谱微分 $f_x = \\mathcal{F}^{-1}\\{ i k \\,\\mathcal{F}\\{f\\}\\}$（其中 $k$ 是与周期域匹配的傅里叶波数）。\n- 对于联合测试和时间测试，使用 SSP-RK2 在时间上推进；对于纯空间阶测试，使用经典的四阶龙格－库塔方法，并取 $\\Delta t = C_t \\Delta x/c$（$C_t$ 为常数）。\n\n验证协议。对于每个测试，计算在最终时间 $t=T$ 时的相对均方根误差：\n$$\nE = \\frac{\\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1}\\left[\\left(\\eta_i^{\\text{num}}-\\eta(x_i,T)\\right)^2 + \\left(u_i^{\\text{num}}-u(x_i,T)\\right)^2\\right]}}{\\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1}\\left[\\eta(x_i,T)^2 + u(x_i,T)^2\\right]}}.\n$$\n使用网格加密研究（分辨率变化因子为2）来估计观测到的收敛阶，方法如下。给定使用分辨率 $(\\Delta x_1,\\Delta t_1)$ 和 $(\\Delta x_2,\\Delta t_2)$ （其中 $\\Delta x_2 = \\Delta x_1/2$ 且 $\\Delta t_2 = \\Delta t_1/2$，对于时间测试则仅将 $\\Delta t$ 减半）计算出的误差 $E_1$ 和 $E_2$，计算观测阶\n$$\np = \\log_2\\left(\\frac{E_1}{E_2}\\right).\n$$\n\n物理常数和参数。使用 $g = 9.81$ 米/秒²，$h_0 = 4000$ 米，$L = 100000$ 米，$m = 3$，$A = 0.5$ 米，$B = 0.3$ 米，$C = 0.2$ 米/秒，$D = 0.15$ 米/秒，以及 $\\omega = 0.01$ 弧度/秒。初始条件必须根据 $t=0$ 时的人造解来设置，并且源项必须在所选龙格－库塔方法的每个阶段中，在时间上进行一致的评估。\n\n测试套件。运行以下三个验证：\n- 测试 1（联合时空阶，使用 SSP-RK2 和二阶中心差分）：使用 $N \\in \\{64, 128, 256\\}$，$\\text{CFL} = 0.2$，$T = 100$ 秒。使用两个最细的网格 $N=128$ 和 $N=256$ 来估计并报告 $p_{\\text{combined}}$。\n- 测试 2（时间阶，使用 SSP-RK2 和谱微分）：使用 $N = 256$，$T = 100$ 秒，以及两个时间步数 $M \\in \\{250, 500\\}$，使得 $\\Delta t = T/M$ 且 $\\Delta t_2 = \\Delta t_1/2$；估计并报告 $p_{\\text{time}}$。\n- 测试 3（空间阶，使用二阶中心差分和时间上的 RK4）：使用 $N \\in \\{64, 128, 256\\}$，$T = 100$ 秒，以及 $\\Delta t = C_t \\Delta x/c$（$C_t = 0.1$）；使用两个最细的网格估计并报告 $p_{\\text{space}}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为 $[p_{\\text{combined}},p_{\\text{time}},p_{\\text{space}}]$。每个值必须是四舍五入到三位小数的浮点数，不带任何附加文本。三角函数中使用的所有角度均为弧度。所有长度单位必须是米，时间单位必须是秒。将最终输出表示为四舍五入到三位小数的无量纲收敛阶。确保程序完全自包含，并且不需要任何输入。",
            "solution": "该问题为一个针对线性化浅水方程数值格式的验证研究提供了完整且适定的描述。它在科学上是合理的，包含了所有必要的参数，并基于人造解方法概述了清晰的流程。因此，该问题被认为是有效的。\n\n求解过程包括三个主要阶段：\n1.  解析推导人造解方法所需的源项。\n2.  实现数值求解器，包括空间离散化和时间积分格式。\n3.  执行指定的数值实验以测量收敛阶。\n\n### 1. 源项的解析推导\n\n控制方程是在周期域 $x \\in [0,L]$ 上的一维线性化浅水方程：\n$$\n\\eta_t + h_0 u_x = S_\\eta(x,t)\n$$\n$$\nu_t + g \\eta_x = S_u(x,t)\n$$\n此处，$\\eta(x,t)$ 是自由表面高程，$u(x,t)$ 是深度平均速度，$h_0$ 是恒定水深，$g$ 是重力加速度，而 $S_\\eta, S_u$ 是待确定的源项。\n\n该问题指定了以下人造解：\n$$\n\\eta(x,t) = A \\cos(\\kappa x - \\omega t) + B \\sin(2\\kappa x + \\omega t)\n$$\n$$\nu(x,t) = C \\sin(\\kappa x - \\omega t) + D \\cos(2\\kappa x + \\omega t)\n$$\n其中 $\\phi(x,t) = \\kappa x - \\omega t$ 且 $\\psi(x,t) = 2\\kappa x + \\omega t$。为了找到使这些表达式成为精确解的源项 $S_\\eta$ 和 $S_u$，我们首先计算 $\\eta$ 和 $u$ 的必要偏导数。\n\n关于时间 $t$ 的偏导数为：\n$$\n\\eta_t = \\frac{\\partial}{\\partial t} [A \\cos(\\phi) + B \\sin(\\psi)] = A(-\\sin(\\phi))(-\\omega) + B(\\cos(\\psi))(\\omega) = A\\omega \\sin(\\phi) + B\\omega \\cos(\\psi)\n$$\n$$\nu_t = \\frac{\\partial}{\\partial t} [C \\sin(\\phi) + D \\cos(\\psi)] = C(\\cos(\\phi))(-\\omega) + D(-\\sin(\\psi))(\\omega) = -C\\omega \\cos(\\phi) - D\\omega \\sin(\\psi)\n$$\n\n关于空间 $x$ 的偏导数为：\n$$\n\\eta_x = \\frac{\\partial}{\\partial x} [A \\cos(\\phi) + B \\sin(\\psi)] = A(-\\sin(\\phi))(\\kappa) + B(\\cos(\\psi))(2\\kappa) = -A\\kappa \\sin(\\phi) + 2B\\kappa \\cos(\\psi)\n$$\n$$\nu_x = \\frac{\\partial}{\\partial x} [C \\sin(\\phi) + D \\cos(\\psi)] = C(\\cos(\\phi))(\\kappa) + D(-\\sin(\\psi))(2\\kappa) = C\\kappa \\cos(\\phi) - 2D\\kappa \\sin(\\psi)\n$$\n\n将这些导数代入控制方程，即可解出源项：\n$$\nS_\\eta(x,t) = \\eta_t + h_0 u_x = (A\\omega \\sin(\\phi) + B\\omega \\cos(\\psi)) + h_0(C\\kappa \\cos(\\phi) - 2D\\kappa \\sin(\\psi))\n$$\n$$\nS_u(x,t) = u_t + g \\eta_x = (-C\\omega \\cos(\\phi) - D\\omega \\sin(\\psi)) + g(-A\\kappa \\sin(\\phi) + 2B\\kappa \\cos(\\psi))\n$$\n重新整理这些表达式，得到源项的最终解析形式，这将在数值代码中实现：\n$$\nS_\\eta(x,t) = A\\omega \\sin(\\kappa x - \\omega t) + h_0 C\\kappa \\cos(\\kappa x - \\omega t) + B\\omega \\cos(2\\kappa x + \\omega t) - 2h_0 D\\kappa \\sin(2\\kappa x + \\omega t)\n$$\n$$\nS_u(x,t) = -gA\\kappa \\sin(\\kappa x - \\omega t) - C\\omega \\cos(\\kappa x - \\omega t) + 2gB\\kappa \\cos(2\\kappa x + \\omega t) - D\\omega \\sin(2\\kappa x + \\omega t)\n$$\n\n### 2. 数值离散化\n\n空间域 $x \\in [0,L]$ 被离散化为 $N$ 个点 $x_i = i\\Delta x$（$i=0, 1, ..., N-1$），网格间距为 $\\Delta x = L/N$。在任意时间 $t$ 的系统状态由向量 $\\mathbf{U}(t) = [\\eta_0, \\dots, \\eta_{N-1}, u_0, \\dots, u_{N-1}]^T$ 表示。控制方程被重写为常微分方程组（ODEs）：\n$$\n\\frac{d\\mathbf{U}}{dt} = \\mathbf{F}(t, \\mathbf{U}) = \\begin{pmatrix} -h_0 (\\boldsymbol{\\eta}_d)_x + \\mathbf{S}_\\eta(t) \\\\ -g (\\boldsymbol{u}_d)_x + \\mathbf{S}_u(t) \\end{pmatrix}\n$$\n其中 $(\\cdot)_x$ 表示一个空间微分算子，$\\mathbf{S}_\\eta, \\mathbf{S}_u$ 是在网格点上求值的源项。需要两种不同的空间微分算子。\n\n**二阶中心差分**：对于网格上的周期函数 $f$，在点 $x_i$ 处的导数近似为：\n$$\nf_x(x_i) \\approx \\frac{f_{i+1} - f_{i-1}}{2\\Delta x}\n$$\n其中指数对 $N$ 取模以强制周期性。该方法具有二阶精度，即误差为 $O(\\Delta x^2)$。\n\n**谱微分**：为实现高空间精度，采用基于快速傅里叶变换（FFT）的谱方法。导数在傅里叶空间中计算：\n$$\nf_x(x) = \\mathcal{F}^{-1}\\{ i k \\,\\mathcal{F}\\{f(x)\\}\\}\n$$\n其中 $\\mathcal{F}$ 是 FFT，$\\mathcal{F}^{-1}$ 是逆 FFT，$i = \\sqrt{-1}$，$k$ 是与离散域对应的波数向量。该方法具有谱精度，意味着对于光滑函数，其误差下降速度快于 $\\Delta x$ 的任何幂次。\n\n### 3. 时间积分\n\nODE 系统使用两种指定的龙格－库塔方法之一在时间上推进。\n\n**SSP-RK2**：二阶强稳定性保持龙格－库塔方法（也称为 Heun 方法）用于联合时空测试和纯时间测试。对于 ODE $y' = f(t,y)$，从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个时间步为：\n1. $\\mathbf{U}^{(1)} = \\mathbf{U}_n + \\Delta t \\mathbf{F}(t_n, \\mathbf{U}_n)$\n2. $\\mathbf{U}_{n+1} = \\frac{1}{2}\\mathbf{U}_n + \\frac{1}{2}(\\mathbf{U}^{(1)} + \\Delta t \\mathbf{F}(t_{n+1}, \\mathbf{U}^{(1)}))$\n该方法在时间上是二阶精度的，误差为 $O(\\Delta t^2)$。\n\n**RK4**：经典的四阶龙格－库塔方法用于空间精度测试，以确保时间误差与二阶空间误差相比可以忽略不计。对于 $y' = f(t,y)$，一个步长为：\n1. $k_1 = \\mathbf{F}(t_n, \\mathbf{U}_n)$\n2. $k_2 = \\mathbf{F}(t_n + \\Delta t/2, \\mathbf{U}_n + \\Delta t/2 \\cdot k_1)$\n3. $k_3 = \\mathbf{F}(t_n + \\Delta t/2, \\mathbf{U}_n + \\Delta t/2 \\cdot k_2)$\n4. $k_4 = \\mathbf{F}(t_n + \\Delta t, \\mathbf{U}_n + \\Delta t \\cdot k_3)$\n5. $\\mathbf{U}_{n+1} = \\mathbf{U}_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)$\n该方法的时间误差为 $O(\\Delta t^4)$。\n\n### 4. 验证协议\n\n对于每个测试，数值模拟使用 $t=0$ 时的人造解进行初始化，并运行到最终时间 $T$。误差使用相对均方根范数计算：\n$$\nE = \\frac{\\sqrt{\\sum_{i=0}^{N-1}\\left[(\\eta_i^{\\text{num}}-\\eta(x_i,T))^2 + (u_i^{\\text{num}}-u(x_i,T))^2\\right]}}{\\sqrt{\\sum_{i=0}^{N-1}\\left[\\eta(x_i,T)^2 + u(x_i,T)^2\\right]}}\n$$\n观测到的收敛阶 $p$ 是根据对应于两种不同分辨率（例如 $\\Delta x_1$ 和 $\\Delta x_2 = \\Delta x_1/2$）的误差 $E_1$ 和 $E_2$，使用以下公式估算得出：\n$$\np = \\log_2\\left(\\frac{E_1}{E_2}\\right)\n$$\n\n三个必需的测试是：\n-   **测试 1（联合时空阶）**：使用二阶中心差分格式和 SSP-RK2 时间积分器。时间步长 $\\Delta t$ 通过一个固定的 CFL 数与网格间距 $\\Delta x$ 耦合。由于空间和时间方法都是二阶的，预期的收敛阶为 $p_{\\text{combined}} \\approx 2$。\n-   **测试 2（时间阶）**：使用高精度的谱微分使得空间离散误差可以忽略不计。时间上用 SSP-RK2 推进。该测试在固定的空间网格上使用两个不同的时间步长运行。预期的收敛阶为 $p_{\\text{time}} \\approx 2$，与 SSP-RK2 积分器的阶数相匹配。\n-   **测试 3（空间阶）**：使用二阶中心差分格式和高阶 RK4 时间积分器。选择时间步长与 $\\Delta x$ 成正比，使得四阶时间误差 $O(\\Delta t^4) \\propto O(\\Delta x^4)$ 被二阶空间误差 $O(\\Delta x^2)$ 所主导。预期的收敛阶为 $p_{\\text{space}} \\approx 2$，与中心差分格式的阶数相匹配。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Solves the problem by performing three verification tests for a numerical scheme\n    of the linearized shallow water equations using the method of manufactured solutions.\n    \"\"\"\n\n    # Physical constants and problem parameters\n    g = 9.81\n    h0 = 4000.0\n    L = 100000.0\n    m = 3\n    A = 0.5\n    B = 0.3\n    C = 0.2\n    D = 0.15\n    omega = 0.01\n    T_final = 100.0\n    \n    # Derived parameters\n    c = np.sqrt(g * h0)\n    kappa = 2.0 * np.pi * m / L\n\n    # --- Analytical Functions ---\n    def eta_manufactured(x, t):\n        phi = kappa * x - omega * t\n        psi = 2.0 * kappa * x + omega * t\n        return A * np.cos(phi) + B * np.sin(psi)\n\n    def u_manufactured(x, t):\n        phi = kappa * x - omega * t\n        psi = 2.0 * kappa * x + omega * t\n        return C * np.sin(phi) + D * np.cos(psi)\n\n    def source_eta(x, t):\n        phi = kappa * x - omega * t\n        psi = 2.0 * kappa * x + omega * t\n        term1 = A * omega * np.sin(phi)\n        term2 = h0 * C * kappa * np.cos(phi)\n        term3 = B * omega * np.cos(psi)\n        term4 = -2.0 * h0 * D * kappa * np.sin(psi)\n        return term1 + term2 + term3 + term4\n\n    def source_u(x, t):\n        phi = kappa * x - omega * t\n        psi = 2.0 * kappa * x + omega * t\n        term1 = -g * A * kappa * np.sin(phi)\n        term2 = -C * omega * np.cos(phi)\n        term3 = 2.0 * g * B * kappa * np.cos(psi)\n        term4 = -D * omega * np.sin(psi)\n        return term1 + term2 + term3 + term4\n\n    # --- Numerical Components ---\n    def central_diff_2nd(f, dx):\n        return (np.roll(f, -1) - np.roll(f, 1)) / (2.0 * dx)\n\n    def spectral_diff(f, dx):\n        N = len(f)\n        k_freq = fft.fftfreq(N, d=dx)\n        k = 2.0 * np.pi * k_freq\n        f_hat = fft.fft(f)\n        df_hat = 1j * k * f_hat\n        return fft.ifft(df_hat).real\n\n    def rhs(t, y, N, dx, derivative_op):\n        eta_num = y[:N]\n        u_num = y[N:]\n        x = np.linspace(0, L, N, endpoint=False)\n        \n        eta_x = derivative_op(eta_num, dx)\n        u_x = derivative_op(u_num, dx)\n        \n        d_eta_dt = -h0 * u_x + source_eta(x, t)\n        d_u_dt = -g * eta_x + source_u(x, t)\n        \n        return np.concatenate((d_eta_dt, d_u_dt))\n\n    def ssp_rk2_step(t, y, dt, N, dx, derivative_op):\n        y1 = y + dt * rhs(t, y, N, dx, derivative_op)\n        y_next = 0.5 * y + 0.5 * (y1 + dt * rhs(t + dt, y1, N, dx, derivative_op))\n        return y_next\n\n    def rk4_step(t, y, dt, N, dx, derivative_op):\n        k1 = rhs(t, y, N, dx, derivative_op)\n        k2 = rhs(t + 0.5 * dt, y + 0.5 * dt * k1, N, dx, derivative_op)\n        k3 = rhs(t + 0.5 * dt, y + 0.5 * dt * k2, N, dx, derivative_op)\n        k4 = rhs(t + dt, y + dt * k3, N, dx, derivative_op)\n        return y + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    def calculate_error(eta_num, u_num, eta_exact, u_exact):\n        err_sq_sum = np.sum((eta_num - eta_exact)**2 + (u_num - u_exact)**2)\n        norm_sq_sum = np.sum(eta_exact**2 + u_exact**2)\n        return np.sqrt(err_sq_sum / norm_sq_sum)\n\n    def run_simulation(N, T, dt_calculator, time_stepper, derivative_op):\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        \n        dt_candidate = dt_calculator(dx)\n        if dt_candidate > 0:\n            num_steps = int(np.ceil(T / dt_candidate))\n            dt = T / num_steps\n        else: # Temporal test where dt is fixed per run via negative signal\n            dt_fixed = -dt_candidate\n            num_steps = int(round(T / dt_fixed))\n            dt = T / num_steps\n        \n        eta_0 = eta_manufactured(x, 0.0)\n        u_0 = u_manufactured(x, 0.0)\n        y = np.concatenate((eta_0, u_0))\n        t = 0.0\n        \n        for _ in range(num_steps):\n            y = time_stepper(t, y, dt, N, dx, derivative_op)\n            t += dt\n            \n        eta_final_num = y[:N]\n        u_final_num = y[N:]\n        eta_final_exact = eta_manufactured(x, T)\n        u_final_exact = u_manufactured(x, T)\n        \n        return calculate_error(eta_final_num, u_final_num, eta_final_exact, u_final_exact)\n\n    # --- Verification Tests ---\n\n    # Test 1: Combined space-time order\n    cfl_1 = 0.2\n    dt_calc_1 = lambda dx: cfl_1 * dx / c\n    errors_1 = []\n    for N in [64, 128, 256]:\n        error = run_simulation(N, T_final, dt_calc_1, ssp_rk2_step, central_diff_2nd)\n        errors_1.append(error)\n    p_combined = np.log2(errors_1[-2] / errors_1[-1])\n\n    # Test 2: Temporal order\n    N_test2 = 256\n    errors_2 = []\n    for M in [250, 500]:\n        dt_fixed = T_final / M\n        dt_calc_2 = lambda dx: -dt_fixed\n        error = run_simulation(N_test2, T_final, dt_calc_2, ssp_rk2_step, spectral_diff)\n        errors_2.append(error)\n    p_time = np.log2(errors_2[0] / errors_2[1])\n    \n    # Test 3: Spatial order\n    cfl_3 = 0.1\n    dt_calc_3 = lambda dx: cfl_3 * dx / c\n    errors_3 = []\n    for N in [64, 128, 256]:\n        error = run_simulation(N, T_final, dt_calc_3, rk4_step, central_diff_2nd)\n        errors_3.append(error)\n    p_space = np.log2(errors_3[-2] / errors_3[-1])\n\n    # Final result printing\n    print(f\"[{p_combined:.3f},{p_time:.3f},{p_space:.3f}]\")\n\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}