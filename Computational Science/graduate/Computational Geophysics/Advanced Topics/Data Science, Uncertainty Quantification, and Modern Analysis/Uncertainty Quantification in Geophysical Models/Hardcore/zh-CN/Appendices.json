{
    "hands_on_practices": [
        {
            "introduction": "在分析地球物理时间序列时，功率谱密度（PSD）是一个核心工具。一个常见但有风险的假设是噪声是“白”的（不相关），而本练习旨在探讨当噪声实际上是“有色”的（相关）时，这种错误设定会带来何种后果。这项分析实践将加深您对模型假设如何直接影响不确定性估计的理解，您将推导出一个“方差膨胀因子”，它量化了因忽略有色噪声而导致的过度自信程度，这是稳健不确定性量化中的一个基础性教训。",
            "id": "3618146",
            "problem": "考虑一个在时间 $t_{n} = n\\,\\Delta t$ 观测到的均匀采样、实值、零均值的平稳高斯地球物理时间序列 $\\{x_{n}\\}_{n=0}^{N-1}$。令 $f_{k} = \\frac{k}{N\\,\\Delta t}$ 表示正傅里叶频率，其中 $k = 1, 2, \\dots, K$，$K = \\lfloor (N-1)/2 \\rfloor$。在这些频率上定义周期图纵坐标 $\\{I_{k}\\}_{k=1}^{K}$。在平稳高斯过程的标准大样本渐近性和 Whittle 近似下，假设周期图纵坐标近似独立，且满足 $\\mathbb{E}[I_{k}] = S(f_{k})$ 和 $\\operatorname{Var}(I_{k}) = S(f_{k})^{2}$，其中 $S(f)$ 是功率谱密度 (PSD)。\n\n假设真实的 PSD 是一个色噪声幂律 $S_{\\text{true}}(f) = C\\,f^{-\\alpha}$，其中 $C > 0$ 且 $\\alpha > 0$。然而，一位分析师错误地将数据建模为具有恒定 PSD $S_{\\text{model}}(f) = A$（对于某个 $A > 0$）的白噪声，并使用周期图的样本均值来估计 $A$，\n$$\n\\hat{A} = \\frac{1}{K}\\sum_{k=1}^{K} I_{k}.\n$$\n\na) 仅使用上述假设和 Whittle 近似下周期图的性质，推导在 $S_{\\text{true}}(f)$ 下 $\\hat{A}$ 的真实方差与分析师在不正确的白噪声模型下会报告的朴素方差之间的比率。将此方差膨胀因子表示为以 $\\{f_{k}\\}_{k=1}^{K}$、$C$ 和 $\\alpha$ 表示的闭式解析表达式。证明该比率大于或等于 $1$，并找出等式成立的条件。\n\nb) 基于在频率 $\\{f_{k}\\}_{k=1}^{K}$ 上观测到的周期图纵坐标 $\\{I_{k}\\}_{k=1}^{K}$，推导幂律模型 $S(f) = C\\,f^{-\\alpha}$ 的 Whittle 负对数似然（忽略与参数无关的加性常数）。以 $\\alpha$、$C$、$\\{I_{k}\\}$ 和 $\\{f_{k}\\}$ 的函数形式，给出闭式最终表达式。\n\n您的最终答案必须包含所要求的两个解析表达式。无需进行数值计算或四舍五入。",
            "solution": "该问题陈述经核实具有科学依据，是适定且客观的。它基于时间序列分析和谱估计的标准原理，特别是针对平稳高斯过程的 Whittle 似然近似。问题设定完整且一致，可以进行唯一且有意义的推导。\n\n### a) 部分：方差膨胀因子\n\n分析师对恒定功率谱密度 (PSD) $A$ 的估计量由周期图纵坐标的样本均值给出：\n$$\n\\hat{A} = \\frac{1}{K}\\sum_{k=1}^{K} I_{k}\n$$\n\n首先，我们计算该估计量的真实方差。真实方差记为 $\\operatorname{Var}_{\\text{true}}(\\hat{A})$，是在数据由真实幂律 PSD $S_{\\text{true}}(f) = C\\,f^{-\\alpha}$ 生成的假设下计算的。问题陈述指出，周期图纵坐标 $\\{I_{k}\\}$ 近似独立，且 $\\operatorname{Var}(I_{k}) = S(f_{k})^{2}$。在真实模型下，该方差变为 $\\operatorname{Var}(I_{k}) = (S_{\\text{true}}(f_{k}))^{2} = (C f_{k}^{-\\alpha})^{2}$。\n\n使用独立随机变量之和的方差性质：\n$$\n\\operatorname{Var}_{\\text{true}}(\\hat{A}) = \\operatorname{Var}\\left(\\frac{1}{K}\\sum_{k=1}^{K} I_{k}\\right) = \\frac{1}{K^{2}}\\sum_{k=1}^{K}\\operatorname{Var}(I_{k})\n$$\n代入每个纵坐标的真实方差：\n$$\n\\operatorname{Var}_{\\text{true}}(\\hat{A}) = \\frac{1}{K^{2}}\\sum_{k=1}^{K} (C f_{k}^{-\\alpha})^{2} = \\frac{C^{2}}{K^{2}}\\sum_{k=1}^{K} f_{k}^{-2\\alpha}\n$$\n这是估计量 $\\hat{A}$ 的真实方差。\n\n接下来，我们必须确定“分析师会报告的朴素方差”。分析师错误地假设数据服从白噪声模型 $S_{\\text{model}}(f) = A$。在此模型下，估计量 $\\hat{A}$ 的理论方差将是：\n$$\n\\operatorname{Var}_{\\text{model}}(\\hat{A}) = \\frac{1}{K^{2}}\\sum_{k=1}^{K}\\operatorname{Var}(I_{k}) = \\frac{1}{K^{2}}\\sum_{k=1}^{K}A^{2} = \\frac{K A^{2}}{K^{2}} = \\frac{A^{2}}{K}\n$$\n分析师不知道 $A$ 的真实值。报告的方差通常会用估计值 $\\hat{A}$ 代替参数 $A$，从而得到一个随机量 $\\hat{A}^{2}/K$。在这种情况下，对“朴素方差”的一个更稳定和标准的解释是，在错误设定的模型下，于估计量的期望值处评估的估计量理论方差。估计量 $\\hat{A}$ 在白噪声模型下是无偏的，但在真实的色噪声模型下是有偏的。我们在真实的数据生成过程下评估其期望：\n$$\n\\mathbb{E}[\\hat{A}] = \\mathbb{E}\\left[\\frac{1}{K}\\sum_{k=1}^{K} I_{k}\\right] = \\frac{1}{K}\\sum_{k=1}^{K}\\mathbb{E}[I_{k}]\n$$\n在真实模型下，$\\mathbb{E}[I_{k}] = S_{\\text{true}}(f_{k}) = C f_{k}^{-\\alpha}$。所以该估计量的期望是：\n$$\nA_{0} := \\mathbb{E}[\\hat{A}] = \\frac{1}{K}\\sum_{k=1}^{K} C f_{k}^{-\\alpha}\n$$\n朴素方差 $\\operatorname{Var}_{\\text{naive}}(\\hat{A})$ 是分析师模型中的理论方差 $\\frac{A^2}{K}$ 在 $A = A_0$ 处的值：\n$$\n\\operatorname{Var}_{\\text{naive}}(\\hat{A}) = \\frac{A_{0}^{2}}{K} = \\frac{1}{K}\\left(\\frac{1}{K}\\sum_{k=1}^{K} C f_{k}^{-\\alpha}\\right)^{2} = \\frac{C^{2}}{K^{3}}\\left(\\sum_{k=1}^{K} f_{k}^{-\\alpha}\\right)^{2}\n$$\n方差膨胀因子 (VIF) 是真实方差与此朴素方差之比：\n$$\n\\text{VIF} = \\frac{\\operatorname{Var}_{\\text{true}}(\\hat{A})}{\\operatorname{Var}_{\\text{naive}}(\\hat{A})} = \\frac{\\frac{C^{2}}{K^{2}}\\sum_{k=1}^{K} f_{k}^{-2\\alpha}}{\\frac{C^{2}}{K^{3}}\\left(\\sum_{k=1}^{K} f_{k}^{-\\alpha}\\right)^{2}}\n$$\n通过约去项来简化表达式：\n$$\n\\text{VIF} = \\frac{K \\sum_{k=1}^{K} f_{k}^{-2\\alpha}}{\\left(\\sum_{k=1}^{K} f_{k}^{-\\alpha}\\right)^{2}}\n$$\n为了证明该比率大于或等于 $1$，我们应用柯西-施瓦茨不等式。对于 $\\mathbb{R}^K$ 中的两个向量 $\\mathbf{u} = (u_1, \\dots, u_K)$ 和 $\\mathbf{v} = (v_1, \\dots, v_K)$，该不等式表述为 $(\\sum_{k=1}^{K} u_k v_k)^2 \\le (\\sum_{k=1}^{K} u_k^2)(\\sum_{k=1}^{K} v_k^2)$。\n令对所有 $k$ 都有 $u_k = 1$，并令 $v_k = f_k^{-\\alpha}$。那么：\n$$\n\\left(\\sum_{k=1}^{K} 1 \\cdot f_k^{-\\alpha}\\right)^2 \\le \\left(\\sum_{k=1}^{K} 1^2\\right)\\left(\\sum_{k=1}^{K} (f_k^{-\\alpha})^2\\right)\n$$\n$$\n\\left(\\sum_{k=1}^{K} f_k^{-\\alpha}\\right)^2 \\le K \\left(\\sum_{k=1}^{K} f_k^{-2\\alpha}\\right)\n$$\n由于 $\\sum_{k=1}^{K} f_k^{-\\alpha}$ 是正项之和（因为 $f_k>0$），其平方不为零（对于 $K \\ge 1$），我们可以用它来除：\n$$\n1 \\le \\frac{K \\sum_{k=1}^{K} f_k^{-2\\alpha}}{\\left(\\sum_{k=1}^{K} f_k^{-\\alpha}\\right)^2}\n$$\n这证明了 $\\text{VIF} \\ge 1$。等式成立当且仅当向量 $\\mathbf{u}$ 和 $\\mathbf{v}$ 线性相关，即对所有 $k$，$v_k$ 是一个常数。这要求 $f_k^{-\\alpha}$ 对 $k=1, \\dots, K$ 保持恒定。由于 $f_k = k/(N \\Delta t)$ 随 $k$ 变化，该条件只有在指数为零时才满足，即 $\\alpha = 0$。在这种情况下，真实模型 $S_{\\text{true}}(f) = C$ 是一个白噪声谱，与分析师的模型形式一致，此时模型不再是错误设定的。\n\n### b) 部分：Whittle 负对数似然\n\n问题陈述指出，周期图纵坐标 $I_k$ 近似独立，且满足 $\\mathbb{E}[I_{k}] = S(f_{k})$ 和 $\\operatorname{Var}(I_{k}) = S(f_{k})^{2}$。对于平稳高斯过程，这些性质对应于大样本行为，其中每个 $I_k$ 服从均值为 $S(f_k)$ 的指数分布。单个纵坐标 $I_k$ 的概率密度函数 (PDF) 为：\n$$\np(I_k | S(f_k)) = \\frac{1}{S(f_k)} \\exp\\left(-\\frac{I_k}{S(f_k)}\\right)\n$$\nPSD 的模型给出为 $S(f) = C\\,f^{-\\alpha}$。因此，对于每个频率 $f_k$，谱值为 $S(f_k) = C\\,f_k^{-\\alpha}$。将此代入 PDF 中：\n$$\np(I_k | C, \\alpha) = \\frac{1}{C f_k^{-\\alpha}} \\exp\\left(-\\frac{I_k}{C f_k^{-\\alpha}}\\right) = \\frac{f_k^{\\alpha}}{C} \\exp\\left(-\\frac{I_k f_k^{\\alpha}}{C}\\right)\n$$\n独立观测集 $\\{I_k\\}_{k=1}^K$ 的似然函数是它们各自 PDF 的乘积：\n$$\nL(C, \\alpha | \\{I_k\\}) = \\prod_{k=1}^{K} p(I_k | C, \\alpha) = \\prod_{k=1}^{K} \\left[ \\frac{f_k^{\\alpha}}{C} \\exp\\left(-\\frac{I_k f_k^{\\alpha}}{C}\\right) \\right]\n$$\n使用对数似然 $\\ell = \\ln L$ 更为方便：\n$$\n\\ell(C, \\alpha) = \\ln \\left( \\prod_{k=1}^{K} \\left[ \\frac{f_k^{\\alpha}}{C} \\exp\\left(-\\frac{I_k f_k^{\\alpha}}{C}\\right) \\right] \\right) = \\sum_{k=1}^{K} \\ln \\left[ \\frac{f_k^{\\alpha}}{C} \\exp\\left(-\\frac{I_k f_k^{\\alpha}}{C}\\right) \\right]\n$$\n$$\n\\ell(C, \\alpha) = \\sum_{k=1}^{K} \\left[ \\ln\\left(\\frac{f_k^{\\alpha}}{C}\\right) - \\frac{I_k f_k^{\\alpha}}{C} \\right] = \\sum_{k=1}^{K} \\left[ \\alpha \\ln(f_k) - \\ln(C) - \\frac{I_k f_k^{\\alpha}}{C} \\right]\n$$\n将求和中的各项分开，得到 Whittle 对数似然：\n$$\n\\ell(C, \\alpha) = \\alpha \\sum_{k=1}^{K} \\ln(f_k) - K \\ln(C) - \\frac{1}{C} \\sum_{k=1}^{K} I_k f_k^{\\alpha}\n$$\n问题要求的是负对数似然 $-\\ell(C, \\alpha)$：\n$$\n-\\ell(C, \\alpha) = K \\ln(C) - \\alpha \\sum_{k=1}^{K} \\ln(f_k) + \\frac{1}{C} \\sum_{k=1}^{K} I_k f_k^{\\alpha}\n$$\n此表达式是 Whittle 负对数似然，作为参数 $C$ 和 $\\alpha$ 以及数据 $\\{I_k, f_k\\}$ 的函数。短语“忽略与参数无关的加性常数”表示任何不涉及 $C$ 或 $\\alpha$ 的项都可以被舍弃，但在这种标准形式中，所有项都至少依赖于其中一个参数。这是完整的表达式。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{K \\sum_{k=1}^{K} f_{k}^{-2\\alpha}}{\\left( \\sum_{k=1}^{K} f_{k}^{-\\alpha} \\right)^{2}} \\\\\\\\ K\\ln(C) + \\frac{1}{C}\\sum_{k=1}^{K}I_{k}f_{k}^{\\alpha} - \\alpha\\sum_{k=1}^{K}\\ln(f_{k}) \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在理解了模型设定基础之后，我们将从理论分析转向一个实际应用。分层贝叶斯建模是一个强大工具，能有效整合来自多个来源的数据，例如不同验潮站的观测数据。此练习将构建一个包含共享成分（全球季节性效应）和站特定成分（局部海平面趋势）的模型，并将其置于一个连贯的概率框架内。通过这项编码练习，您将获得实施一个基础贝叶斯模型的实践经验，学习如何将参数不确定性正确传播到预测中，并处理现实世界数据中如观测数据缺失等挑战。",
            "id": "3618115",
            "problem": "你需要构建并使用一个分层线性高斯模型，根据包含季节性分量和缺失观测值的潮汐测量仪观测数据来模拟海平面，并推导和计算在未观测时间的后验预测分布。该模型以数学形式指定，并应实现为一个完整的、可运行的程序。所有三角函数中的角度必须以弧度表示。所有海平面必须以米为单位处理，噪声方差以平方米为单位。最终程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，该列表聚合了所有提供的测试用例的结果，每个预测由一个包含预测均值（单位：米）和预测方差（单位：平方米）的双元素列表表示。\n\n模型规范：考虑由 $s \\in \\{0,1,\\dots,S-1\\}$ 索引的 $S$ 个验潮站。令 $t$ 表示以年为单位的时间，令 $\\cos(2\\pi t)$ 和 $\\sin(2\\pi t)$ 表示周期为 1 年的季节性基函数（角度以弧度为单位）。在测站 $s$ 和时间 $t$ 观测到的海平面建模为\n$$\ny_s(t) = \\alpha_s + \\beta_s t + A \\cos(2\\pi t) + B \\sin(2\\pi t) + \\varepsilon_s(t),\n$$\n其中 $\\varepsilon_s(t) \\sim \\mathcal{N}(0,\\sigma^2)$ 在所有观测中独立同分布，且噪声方差 $\\sigma^2$ 已知。定义参数向量\n$$\n\\theta = \\begin{bmatrix} \\alpha_0 \\\\ \\beta_0 \\\\ \\alpha_1 \\\\ \\beta_1 \\\\ \\vdots \\\\ \\alpha_{S-1} \\\\ \\beta_{S-1} \\\\ A \\\\ B \\end{bmatrix} \\in \\mathbb{R}^{2S+2}.\n$$\n假设一个高斯先验\n$$\n\\theta \\sim \\mathcal{N}(m_0, S_0),\n$$\n其中 $m_0$ 和 $S_0$ 指定如下：$m_0$ 是长度为 $2S+2$ 的零向量，$S_0$ 是对角矩阵，其对角线元素为每个测站特定截距 $\\alpha_s$ 的先验方差 $v_\\alpha$、每个测站特定斜率 $\\beta_s$ 的先验方差 $v_\\beta$、以及季节性系数 $A$ 和 $B$ 的先验方差 $v_A$ 和 $v_B$。这构成了一个分层模型，其中特定于测站的系数共享控制其先验可变性的共同超参数 $v_\\alpha$ 和 $v_\\beta$，而季节性系数则是跨所有测站全局共享的。\n\n令 $H \\in \\mathbb{R}^{N \\times (2S+2)}$ 表示从 $N$ 个可用观测构建的设计矩阵，每行对应一个观测 $(s,t)$，其条目为\n$$\nH_{(s,t)} = \\big[0,\\dots,0,\\underbrace{1}_{\\alpha_s},\\underbrace{t}_{\\beta_s},0,\\dots,0,\\underbrace{\\cos(2\\pi t)}_{A},\\underbrace{\\sin(2\\pi t)}_{B}\\big],\n$$\n在 $\\alpha_s$ 的列中放置 $1$，在 $\\beta_s$ 的列中放置 $t$，最后两列用于全局季节性项。缺失的观测通过简单地从 $H$ 中省略它们的行并从观测向量 $y \\in \\mathbb{R}^{N}$ 中省略它们的值来处理。\n\n在线性高斯假设下并给定 $\\sigma^2$，$\\theta$ 的后验分布是高斯分布，其均值为 $m_n$，协方差为 $S_n$：\n$$\nS_n = \\left(S_0^{-1} + \\frac{1}{\\sigma^2} H^\\top H\\right)^{-1}, \\quad\nm_n = S_n \\left(S_0^{-1} m_0 + \\frac{1}{\\sigma^2} H^\\top y\\right).\n$$\n对于在测站 $s^\\ast$ 和时间 $t^\\ast$ 的新预测，令 $h^\\ast \\in \\mathbb{R}^{2S+2}$ 是与 $H$ 类似地构建的相应设计行向量。$y_{s^\\ast}(t^\\ast)$ 的后验预测分布是高斯分布，其均值和方差为\n$$\n\\mu^\\ast = h^\\ast m_n, \\quad \\sigma_\\ast^2 = \\sigma^2 + h^\\ast S_n {h^\\ast}^\\top.\n$$\n你的程序必须为每个指定的查询计算 $(\\mu^\\ast, \\sigma_\\ast^2)$ 对。\n\n测试套件：实现该模型并为以下三个参数集计算后验预测均值和方差。对于每种情况，从给定的观测数据构建设计矩阵 $H$，使用指定的先验超参数构建 $S_0$，并为指定的查询计算预测对。报告所有预测均值（单位：米）和方差（单位：平方米）。\n\n- 情况 1（一般情况，包含两个测站、中等噪声、一些缺失观测值）：\n  - 测站数量：$S = 2$。\n  - 噪声方差：$\\sigma^2 = 0.01$ $\\mathrm{m}^2$。\n  - 先验方差：$v_\\alpha = 0.25$ $\\mathrm{m}^2$，$v_\\beta = 0.0025$ $\\mathrm{m}^2/\\mathrm{year}^2$，$v_A = 0.04$ $\\mathrm{m}^2$，$v_B = 0.04$ $\\mathrm{m}^2$。\n  - 观测值（测站索引 $s$，时间 $t$（年），海平面 $y$（米））：\n    - 测站 $0$：$(s=0, t=0.0, y=0.252)$，$(s=0, t=0.5, y=0.065)$，$(s=0, t=1.5, y=0.082)$，$(s=0, t=2.0, y=0.292)$。\n    - 测站 $1$：$(s=1, t=0.25, y=0.007)$，$(s=1, t=0.75, y=0.113)$，$(s=1, t=1.25, y=0.021)$，$(s=1, t=1.75, y=0.128)$。\n  - 查询（测站索引 $s^\\ast$，时间 $t^\\ast$（年））：$(s^\\ast=0, t^\\ast=2.25)$，$(s^\\ast=0, t^\\ast=0.25)$，$(s^\\ast=1, t^\\ast=2.0)$。\n\n- 情况 2（边界情况，包含一个测站和单个观测值，较大噪声）：\n  - 测站数量：$S = 1$。\n  - 噪声方差：$\\sigma^2 = 0.05$ $\\mathrm{m}^2$。\n  - 先验方差：$v_\\alpha = 0.25$ $\\mathrm{m}^2$，$v_\\beta = 0.0025$ $\\mathrm{m}^2/\\mathrm{year}^2$，$v_A = 0.04$ $\\mathrm{m}^2$，$v_B = 0.04$ $\\mathrm{m}^2$。\n  - 观测值：\n    - 测站 $0$：$(s=0, t=0.0, y=0.20)$。\n  - 查询：$(s^\\ast=0, t^\\ast=0.5)$，$(s^\\ast=0, t^\\ast=1.0)$。\n\n- 情况 3（边缘情况，包含三个测站，其中一个测站无观测值，中等噪声）：\n  - 测站数量：$S = 3$。\n  - 噪声方差：$\\sigma^2 = 0.02$ $\\mathrm{m}^2$。\n  - 先验方差：$v_\\alpha = 0.25$ $\\mathrm{m}^2$，$v_\\beta = 0.0025$ $\\mathrm{m}^2/\\mathrm{year}^2$，$v_A = 0.04$ $\\mathrm{m}^2$，$v_B = 0.04$ $\\mathrm{m}^2$。\n  - 观测值：\n    - 测站 $0$：$(s=0, t=0.0, y=0.260)$，$(s=0, t=0.5, y=0.060)$。\n    - 测站 $1$：$(s=1, t=0.25, y=0.005)$，$(s=1, t=0.75, y=0.115)$。\n    - 测站 $2$：无观测值。\n  - 查询：$(s^\\ast=2, t^\\ast=0.6)$，$(s^\\ast=1, t^\\ast=1.25)$，$(s^\\ast=0, t^\\ast=1.5)$。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个测试用例为其查询生成一个由双元素列表 $[\\mu^\\ast,\\sigma_\\ast^2]$ 组成的列表，顺序如上所列。例如，输出应具有结构 $[[[\\mu_1^{(1)},\\sigma_{1}^{2\\,(1)}],[\\mu_2^{(1)},\\sigma_{2}^{2\\,(1)}],\\dots],[[\\mu_1^{(2)},\\sigma_{1}^{2\\,(2)}],\\dots],[[\\mu_1^{(3)},\\sigma_{1}^{2\\,(3)}],\\dots]]$，所有值均为指定单位的实数。",
            "solution": "用户提供了一个问题陈述，要求实现一个分层线性高斯模型，对模拟的潮汐测量仪数据进行贝叶斯推断。任务是计算在指定的未观测时间点的海平面的后验预测分布。\n\n### 问题验证\n\n**步骤 1：提取给定条件**\n\n问题提供了以下模型、定义和数据：\n\n*   **模型方程**：在测站 $s$ 和时间 $t$ 观测到的海平面 $y_s(t)$ 由以下公式给出\n    $$y_s(t) = \\alpha_s + \\beta_s t + A \\cos(2\\pi t) + B \\sin(2\\pi t) + \\varepsilon_s(t)$$\n*   **噪声模型**：观测噪声 $\\varepsilon_s(t)$ 是独立同分布的，服从 $\\mathcal{N}(0, \\sigma^2)$，其中方差 $\\sigma^2$ 已知。\n*   **参数向量**：模型参数被整合到一个向量 $\\theta \\in \\mathbb{R}^{2S+2}$ 中：\n    $$\\theta = \\begin{bmatrix} \\alpha_0 \\\\ \\beta_0 \\\\ \\vdots \\\\ \\alpha_{S-1} \\\\ \\beta_{S-1} \\\\ A \\\\ B \\end{bmatrix}$$\n*   **先验分布**：$\\theta$ 的先验是多元高斯分布，$\\theta \\sim \\mathcal{N}(m_0, S_0)$。\n    *   先验均值：$m_0$ 是零向量。\n    *   先验协方差：$S_0$ 是一个对角矩阵，其对角线元素对应于每个 $\\alpha_s$ 的先验方差 $v_\\alpha$、每个 $\\beta_s$ 的先验方差 $v_\\beta$、以及 $A$ 的 $v_A$ 和 $B$ 的 $v_B$。\n*   **设计矩阵 ($H$)**：对于 $N$ 个观测， $H$ 是一个 $N \\times (2S+2)$ 的矩阵，其中每行对应于在测站 $s$ 和时间 $t$ 的一次观测，形式如下：\n    $$H_{(s,t)} = \\big[0,\\dots,0,\\underbrace{1}_{\\text{col for }\\alpha_s},\\underbrace{t}_{\\text{col for }\\beta_s},0,\\dots,0,\\underbrace{\\cos(2\\pi t)}_{\\text{col for }A},\\underbrace{\\sin(2\\pi t)}_{\\text{col for }B}\\big]$$\n*   **后验分布**：$\\theta$ 的后验分布是高斯分布，$\\theta | y \\sim \\mathcal{N}(m_n, S_n)$，其中：\n    $$S_n = \\left(S_0^{-1} + \\frac{1}{\\sigma^2} H^\\top H\\right)^{-1}$$\n    $$m_n = S_n \\left(S_0^{-1} m_0 + \\frac{1}{\\sigma^2} H^\\top y\\right)$$\n*   **后验预测分布**：对于在 $(s^\\ast, t^\\ast)$ 处带有设计向量 $h^\\ast$ 的新预测，其预测分布是高斯分布，均值为 $\\mu^\\ast$，方差为 $\\sigma_\\ast^2$：\n    $$\\mu^\\ast = h^\\ast m_n$$\n    $$\\sigma_\\ast^2 = \\sigma^2 + h^\\ast S_n {h^\\ast}^\\top$$\n*   **测试用例**：提供了三个具体的测试用例，每个用例都给出了 $S$、$\\sigma^2$、先验方差、一组观测值 $(s, t, y)$ 和一组查询 $(s^\\ast, t^\\ast)$ 的值。\n\n**步骤 2：使用提取的给定条件进行验证**\n\n根据验证标准对问题进行评估：\n\n*   **科学依据**：该问题在贝叶斯统计学原理上有坚实的基础。使用线性高斯模型是回归和数据同化的标准和基础技术，在包括地球物理学在内的科学领域得到广泛应用。模型结构（特定于测站的趋势加上全局季节性）是一种常见且合理的简化。\n*   **适定性**：问题是适定的。先验方差（$v_\\alpha, v_\\beta, v_A, v_B$）均为正数，这确保了先验协方差矩阵 $S_0$ 是正定的。因此，其逆矩阵 $S_0^{-1}$ 存在且也为正定。矩阵 $H^\\top H$ 是半正定的。一个正定矩阵（$S_0^{-1}$）与一个半正定矩阵（$\\frac{1}{\\sigma^2} H^\\top H$）之和总是正定的。这保证了矩阵 $S_n^{-1}$ 是可逆的，从而确保了唯一的后验协方差 $S_n$ 和均值 $m_n$ 的存在。\n*   **客观性**：问题陈述完全客观，使用了精确的数学公式和数值数据。没有主观或基于意见的成分。\n*   **完整性与一致性**：问题是自洽的。对于每个测试用例，所有必需的参数、数据和超参数都已明确提供。设置中没有矛盾之处。处理缺失观测值的方法（通过从 $H$ 中省略行）是一种标准且一致的方法。\n*   **现实性与可行性**：提供的海平面、时间尺度和方差的数值对于此类简化模型来说是合理的。单位在整个问题中保持一致。计算任务是可行的。\n*   **结构与清晰度**：问题结构清晰。所有变量和数学运算都得到了明确的定义。包含了边缘情况，例如一个没有观测值的测站（情况 3），测试了模型实现的鲁棒性及其对贝叶斯原理的遵守情况（在这种情况下，该测站参数的后验应回归到先验）。\n\n**步骤 3：结论与行动**\n\n问题陈述是**有效的**。它在科学上是合理的，数学上是一致的，是适定的，并且是完整的。我将继续开发解决方案。\n\n### 解决方案设计\n\n该问题要求为线性高斯模型实现标准的贝叶斯更新和预测步骤。解决方案的核心是将所提供的矩阵方程转化为计算算法。每个测试用例的处理过程如下：\n\n1.  **初始化**：给定测站数量 $S$，确定参数向量 $\\theta$ 的维度 $D = 2S + 2$。参数按 $(\\alpha_0, \\beta_0, \\alpha_1, \\beta_1, \\dots, \\alpha_{S-1}, \\beta_{S-1}, A, B)$ 的顺序排列。\n\n2.  **先验设定**：\n    *   构建先验均值向量 $m_0$，它是一个长度为 $D$ 的零向量。\n    *   构建先验协方差矩阵 $S_0$。这是一个 $D \\times D$ 的对角矩阵。对角线元素由给定的先验方差填充：$S$ 个 $v_\\alpha$ 条目，接着是 $S$ 个 $v_\\beta$ 条目，最后是 $v_A$ 和 $v_B$。准确地说，$\\alpha_s$ 和 $\\beta_s$ 的对角元素分别位于索引 $2s$ 和 $2s+1$ 处。$A$ 和 $B$ 的元素位于最后两个索引 $2S$ 和 $2S+1$ 处。\n    *   计算先验协方差的逆矩阵 $S_0^{-1}$，它也是一个对角矩阵，其元素是先验方差的倒数。\n\n3.  **数据处理**：\n    *   从观测列表中构建 $N \\times D$ 的设计矩阵 $H$ 和 $N \\times 1$ 的观测向量 $y$。\n    *   对于每个观测 $(s_i, t_i, y_i)$，创建一个相应的行 $H_i$。该行向量有四个非零元素：索引 $2s_i$ 处为 $1$（对应 $\\alpha_{s_i}$），索引 $2s_i+1$ 处为值 $t_i$（对应 $\\beta_{s_i}$），索引 $2S$ 处为 $\\cos(2\\pi t_i)$（对应 $A$），索引 $2S+1$ 处为 $\\sin(2\\pi t_i)$（对应 $B$）。\n    *   向量 $y$ 简单地收集所有观测值 $y_i$。\n\n4.  **后验计算**：\n    *   计算矩阵 $S_n^{-1} = S_0^{-1} + \\frac{1}{\\sigma^2} H^\\top H$。该矩阵代表后验精度，即先验精度与数据精度（缩放似然）之和。\n    *   将该矩阵求逆以获得后验协方差矩阵：$S_n = (S_n^{-1})^{-1}$。\n    *   计算项 $b = S_0^{-1} m_0 + \\frac{1}{\\sigma^2} H^\\top y$。由于 $m_0 = 0$，这简化为 $b = \\frac{1}{\\sigma^2} H^\\top y$。\n    *   计算后验均值向量：$m_n = S_n b$。此计算找到了更新后参数分布的均值，它平衡了先验信念和来自数据的证据。\n\n5.  **预测**：\n    *   对于每个查询 $(s^\\ast, t^\\ast)$，以与构建 $H$ 的行相同的方式构建 $1 \\times D$ 的设计向量 $h^\\ast$。\n    *   后验预测均值计算为点积 $\\mu^\\ast = h^\\ast m_n$。这给出了在给定模型和观测数据的情况下，查询点的海平面的最佳估计。\n    *   后验预测方差计算为 $\\sigma_\\ast^2 = \\sigma^2 + h^\\ast S_n {h^\\ast}^\\top$。该方差有两个组成部分：固有的观测噪声 $\\sigma^2$ 和通过模型传播的参数不确定性 $h^\\ast S_n {h^\\ast}^\\top$。这个和代表了新预测的总不确定性。\n\n此过程将作为一个函数来实现，可应用于所有三个提供的测试用例。对于某个测站没有观测值的情况（情况 3，测站 2），此框架能正确处理：$H$ 中对应于 $\\alpha_2$ 和 $\\beta_2$ 的列将全为零。因此，这些参数的后验将不会被数据更新，并将保持为其先验分布，这是数学上正确的结果。实现将使用 `numpy` 库进行所有线性代数运算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    def compute_predictions(S, sigma2, prior_variances, observations, queries):\n        \"\"\"\n        Computes posterior predictive means and variances for a single test case.\n\n        Args:\n            S (int): Number of stations.\n            sigma2 (float): Observation noise variance.\n            prior_variances (list): A list of floats [v_alpha, v_beta, v_A, v_B].\n            observations (list): A list of tuples (s, t, y).\n            queries (list): A list of tuples (s_star, t_star).\n\n        Returns:\n            list: A list of [mean, variance] pairs for each query.\n        \"\"\"\n        # Dimension of the parameter vector theta\n        D = 2 * S + 2\n        \n        # 1. Construct prior distribution parameters\n        v_alpha, v_beta, v_A, v_B = prior_variances\n        m0 = np.zeros(D)\n        \n        diag_S0 = []\n        for s in range(S):\n            diag_S0.extend([v_alpha, v_beta])\n        diag_S0.extend([v_A, v_B])\n        S0 = np.diag(diag_S0)\n        \n        # The inverse of a diagonal matrix is a diagonal matrix of reciprocals\n        S0_inv = np.diag(1 / np.array(diag_S0))\n        \n        # 2. Construct design matrix H and observation vector y\n        N = len(observations)\n        if N > 0:\n            H = np.zeros((N, D))\n            y = np.zeros(N)\n            for i, (s, t, y_val) in enumerate(observations):\n                # Row H_i for observation (s, t, y_val)\n                H[i, 2*s] = 1.0                          # Coefficient for alpha_s\n                H[i, 2*s + 1] = t                        # Coefficient for beta_s\n                H[i, 2*S] = np.cos(2 * np.pi * t)        # Coefficient for A\n                H[i, 2*S + 1] = np.sin(2 * np.pi * t)    # Coefficient for B\n                y[i] = y_val\n        else:\n            # Handle cases with no observations (not in test suite but good practice)\n            H = np.zeros((0, D))\n            y = np.zeros(0)\n\n        # 3. Compute posterior distribution parameters (mean mn, covariance Sn)\n        # Posterior precision matrix: S_n^-1 = S_0^-1 + (1/sigma^2) * H^T * H\n        H_T_H = H.T @ H\n        Sn_inv = S0_inv + (1 / sigma2) * H_T_H\n        \n        # Posterior covariance: S_n = (S_n^-1)^-1\n        Sn = np.linalg.inv(Sn_inv)\n        \n        # Posterior mean: m_n = S_n * (S_0^-1 * m_0 + (1/sigma^2) * H^T * y)\n        # Since m_0 is the zero vector, this simplifies.\n        H_T_y = H.T @ y\n        mn = Sn @ ((1 / sigma2) * H_T_y)\n        \n        # 4. Compute predictions for all queries\n        results = []\n        for s_star, t_star in queries:\n            # Construct the design vector h* for the query\n            h_star = np.zeros(D)\n            h_star[2*s_star] = 1.0                             # alpha_{s*}\n            h_star[2*s_star + 1] = t_star                      # beta_{s*}\n            h_star[2*S] = np.cos(2 * np.pi * t_star)           # A\n            h_star[2*S + 1] = np.sin(2 * np.pi * t_star)       # B\n            \n            # Posterior predictive mean: mu* = h* @ m_n\n            mu_star = h_star @ mn\n            \n            # Posterior predictive variance: sigma*^2 = sigma^2 + h* @ S_n @ h*_T\n            sigma2_star = sigma2 + h_star @ Sn @ h_star\n            \n            results.append([mu_star, sigma2_star])\n            \n        return results\n\n    # --- Test Cases ---\n    \n    # Case 1\n    case1 = {\n        \"S\": 2, \"sigma2\": 0.01,\n        \"prior_variances\": [0.25, 0.0025, 0.04, 0.04],\n        \"observations\": [\n            (0, 0.0, 0.252), (0, 0.5, 0.065), (0, 1.5, 0.082), (0, 2.0, 0.292),\n            (1, 0.25, 0.007), (1, 0.75, 0.113), (1, 1.25, 0.021), (1, 1.75, 0.128)\n        ],\n        \"queries\": [(0, 2.25), (0, 0.25), (1, 2.0)]\n    }\n\n    # Case 2\n    case2 = {\n        \"S\": 1, \"sigma2\": 0.05,\n        \"prior_variances\": [0.25, 0.0025, 0.04, 0.04],\n        \"observations\": [(0, 0.0, 0.20)],\n        \"queries\": [(0, 0.5), (0, 1.0)]\n    }\n\n    # Case 3\n    case3 = {\n        \"S\": 3, \"sigma2\": 0.02,\n        \"prior_variances\": [0.25, 0.0025, 0.04, 0.04],\n        \"observations\": [\n            (0, 0.0, 0.260), (0, 0.5, 0.060),\n            (1, 0.25, 0.005), (1, 0.75, 0.115)\n        ],\n        \"queries\": [(2, 0.6), (1, 1.25), (0, 1.5)]\n    }\n    \n    test_cases = [case1, case2, case3]\n    all_results = []\n    \n    for case in test_cases:\n        result_case = compute_predictions(\n            case[\"S\"], case[\"sigma2\"], case[\"prior_variances\"],\n            case[\"observations\"], case[\"queries\"]\n        )\n        all_results.append(result_case)\n\n    # Format the final output string to match the specified format.\n    # The str() function on a list of lists creates the desired structure,\n    # and .replace(\" \", \"\") removes all whitespace.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在构建模型并获得后验分布后，一个关键问题依然存在：这个模型足够好吗？本实践介绍后验预测检验（PPC），这是贝叶斯模型验证的基石。后验预测检验的核心思想是检验您的模型是否能生成与您实际观测到的数据相似的数据。您将为一个重力反演问题设计一个对空间错配敏感的自定义检验统计量，并用它来计算一个$p$值，以量化模型与数据之间的差异。这项练习将使您从仅仅*量化*不确定性，提升到能够*评判*产生不确定性的模型，为您提供一种强大的技术来诊断模型设定错误，从而建立更可靠的地球物理模型。",
            "id": "3618119",
            "problem": "考虑一个沿水平剖面的一维重力反演模型，其地下被离散为包含两个层位的矩形单元。目标是通过构建一个空间相干的检验统计量，为该模型设计一个后验预测检验（Posterior Predictive Check, PPC），并通过后验预测 p 值确定一个决策阈值。该 PPC 必须作为一个完整的、可运行的程序来实现。\n\n基本原理与物理建模。由点质量引起的重力加速度的垂直分量源自 Newton 万有引力定律。通过对近似地下的体积单元进行叠加，地表观测位置处的预测垂直重力异常可以用一个线性正演算子来建模。假设有 $K$ 个地表观测点，其水平位置为 $\\{x_k\\}_{k=1}^K$；以及 $N$ 个地下单元，其中心位置为 $\\{(x_i, z_i)\\}_{i=1}^N$，其中 $z_i$ 是深度。设引力常数为 $G_{\\mathrm{N}} = 6.67430 \\times 10^{-11}$ $\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$，每个单元的体积为 $V = \\Delta x \\,\\Delta z \\, L_y$，其中 $\\Delta x = 100\\,\\mathrm{m}$，$\\Delta z = 100\\,\\mathrm{m}$，平面外厚度 $L_y = 1000\\,\\mathrm{m}$。单元质量为 $m_i = \\rho_i V$，其中 $\\rho_i$ 是密度，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$。观测点 $k$ 处由单元 $i$ 引起的垂直重力为\n$$\ng_{ki} = G_{\\mathrm{N}} \\, m_i \\, \\frac{z_i}{\\left( (x_k - x_i)^2 + z_i^2 \\right)^{3/2}},\n$$\n$k$ 点的总预测异常为\n$$\ng_k(\\boldsymbol{\\rho}) = \\sum_{i=1}^N G_{\\mathrm{N}} \\, (\\rho_i V) \\, \\frac{z_i}{\\left( (x_k - x_i)^2 + z_i^2 \\right)^{3/2}}。\n$$\n所有重力值都应以 $\\mathrm{m}\\,\\mathrm{s}^{-2}$ 为单位进行处理和解释。\n\n后验模型与 PPC 构建。设密度向量 $\\boldsymbol{\\rho} \\in \\mathbb{R}^N$ 的后验分布为多元高斯分布，其均值为 $\\boldsymbol{\\mu}$，协方差为 $\\boldsymbol{\\Sigma}$，其中\n$$\n\\Sigma_{ij} = s^2 \\exp\\left(- \\frac{d_{ij}^2}{\\ell^2} \\right) + \\nu^2 \\delta_{ij},\n$$\n$d_{ij}$ 是单元中心 $(x_i,z_i)$ 和 $(x_j,z_j)$ 之间的欧几里得距离，$s$ 是边际标准差，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$\\ell$ 是相关长度尺度，单位为 $\\mathrm{m}$，$\\nu$ 是块金值（nugget），单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$\\delta_{ij}$ 是克罗内克 δ（Kronecker delta）。\n\n利用从观测位置 $\\{x_k\\}$ 构建的观测核矩阵 $\\mathbf{W} \\in \\mathbb{R}^{K \\times K}$，定义一个空间相干的检验统计量：\n$$\nW_{kl} = \\exp\\left( -\\frac{(x_k - x_l)^2}{2 b^2} \\right),\n$$\n其中 $b$ 是空间带宽，单位为 $\\mathrm{m}$，然后对 $\\mathbf{W}$ 进行重新归一化，使得 $\\mathrm{trace}(\\mathbf{W}) = K$。对于给定的 $\\boldsymbol{\\rho}$，定义残差 $\\mathbf{r}(\\boldsymbol{\\rho}) = \\mathbf{y}_{\\mathrm{obs}} - \\mathbf{G}\\boldsymbol{\\rho}$，其中 $\\mathbf{G} \\in \\mathbb{R}^{K \\times N}$ 表示正演算子，其元素为 $G_{ki} = G_{\\mathrm{N}} V \\, z_i / \\left( (x_k - x_i)^2 + z_i^2 \\right)^{3/2}$。检验统计量为\n$$\nT(\\mathbf{y}, \\boldsymbol{\\rho}) = \\mathbf{r}(\\boldsymbol{\\rho})^\\top \\mathbf{W}\\,\\mathbf{r}(\\boldsymbol{\\rho})。\n$$\n\n后验预测 p 值。对 $s = 1, \\dots, S$，从 $\\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$ 中抽取样本 $\\boldsymbol{\\rho}^{(s)}$，并为每个抽样生成一个后验预测复制\n$$\n\\mathbf{y}_{\\mathrm{rep}}^{(s)} = \\mathbf{G}\\boldsymbol{\\rho}^{(s)} + \\boldsymbol{\\varepsilon}^{(s)}, \\quad \\boldsymbol{\\varepsilon}^{(s)} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_{\\mathrm{pred}}^2 \\mathbf{I}_K),\n$$\n其中 $\\sigma_{\\mathrm{pred}}$ 是后验预测噪声的标准差，单位为 $\\mathrm{m}\\,\\mathrm{s}^{-2}$，$\\mathbf{I}_K$ 是 $K \\times K$ 的单位矩阵。对每个 $s$ 计算 $T\\left(\\mathbf{y}_{\\mathrm{obs}}, \\boldsymbol{\\rho}^{(s)}\\right)$ 和 $T\\left(\\mathbf{y}_{\\mathrm{rep}}^{(s)}, \\boldsymbol{\\rho}^{(s)}\\right)$，并通过以下公式近似后验预测 p 值\n$$\np = \\frac{1}{S} \\sum_{s=1}^S \\mathbb{I}\\left( T\\left(\\mathbf{y}_{\\mathrm{rep}}^{(s)}, \\boldsymbol{\\rho}^{(s)}\\right) \\ge T\\left(\\mathbf{y}_{\\mathrm{obs}}, \\boldsymbol{\\rho}^{(s)}\\right) \\right),\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。使用双边 p 值 $p_{\\mathrm{two}} = 2 \\min(p, 1-p)$ 和一个决策阈值 $\\alpha$，当 $p_{\\mathrm{two}} \\le \\alpha$ 时，模型被拒绝，否则不被拒绝。\n\n设置。使用一个一维剖面，包含 $K = 10$ 个观测点，位置为 $x_k = k \\Delta x$（$k = 0, 1, \\dots, 9$）；以及 $N = 20$ 个地下单元，分布在两个深度层（$z = 50\\,\\mathrm{m}$ 和 $z = 150\\,\\mathrm{m}$），其水平位置为 $x_i = i \\Delta x$，$i$ 对应于每层的索引。假设基线真实密度为 $\\rho_{\\mathrm{base}} = 2600\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，其中一个振幅为 $200\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$ 的异常块体位于较深层（$z = 150\\,\\mathrm{m}$），水平跨越索引 $i \\in \\{3,4,5,6\\}$。生成合成观测数据\n$$\n\\mathbf{y}_{\\mathrm{obs}} = \\mathbf{G}\\boldsymbol{\\rho}_{\\mathrm{true}} + \\boldsymbol{\\varepsilon}_{\\mathrm{obs}}, \\quad \\boldsymbol{\\varepsilon}_{\\mathrm{obs}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_{\\mathrm{true}}^2 \\mathbf{I}_K),\n$$\n其中 $\\sigma_{\\mathrm{true}} = 5 \\times 10^{-6}\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$，并使用固定的随机种子以确保可复现性。\n\n后验设定。对于后验均值，使用与真实模型相同的异常体位置（位于较深层），但振幅为 $\\mu_{\\mathrm{anom}}$，基线密度为 $\\rho_{\\mathrm{base}}$；对于异常体范围外的单元，将其均值设为 $\\rho_{\\mathrm{base}}$。对于协方差，使用 $s = 150\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$ 和块金值 $\\nu = 50\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，距离 $d_{ij}$ 在 $(x,z)$ 平面上计算。观测核的带宽为 $b = 200\\,\\mathrm{m}$。\n\n测试套件。为以下三个参数集实现 PPC，每个参数集使用 $S = 2000$ 个后验样本：\n- 情况 A（噪声设定良好且空间相关性中等）：$\\ell = 150\\,\\mathrm{m}$，$\\sigma_{\\mathrm{pred}} = 5 \\times 10^{-6}\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$，$\\mu_{\\mathrm{anom}} = 180\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$\\alpha = 0.1$。\n- 情况 B（预测噪声被低估）：$\\ell = 150\\,\\mathrm{m}$，$\\sigma_{\\mathrm{pred}} = 1 \\times 10^{-6}\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$，$\\mu_{\\mathrm{anom}} = 180\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$\\alpha = 0.1$。\n- 情况 C（后验空间结构过度平滑）：$\\ell = 500\\,\\mathrm{m}$，$\\sigma_{\\mathrm{pred}} = 5 \\times 10^{-6}\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$，$\\mu_{\\mathrm{anom}} = 50\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$\\alpha = 0.1$。\n\n要求的输出与单位。对于每种情况，计算双边后验预测 p 值 $p_{\\mathrm{two}}$（无量纲，表示为 $[0,1]$ 区间内的小数）。您的程序应生成单行输出，其中包含三个结果，格式为方括号内的逗号分隔列表，例如 $\\left[ p_{\\mathrm{two},A}, p_{\\mathrm{two},B}, p_{\\mathrm{two},C} \\right]$。重力计算必须以 $\\mathrm{m}\\,\\mathrm{s}^{-2}$ 为单位，密度以 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$ 为单位，距离以 $\\mathrm{m}$ 为单位，不使用角度。不允许使用百分比；所有概率必须是小数。\n\n设计约束。实现必须从所述的物理正演模型和高斯后验定义开始。不得在这些基础之外使用简化公式。根据规定从观测坐标构建 $\\mathbf{W}$，并将其重新归一化，使其迹 $\\mathrm{trace}(\\mathbf{W}) = K$。使用固定的随机种子以确保确定性。通过保持规定的参数值和单位，并使用未经修改的测试套件，来确保科学真实性。",
            "solution": "该解答实现了一个用于地球物理重力模型的后验预测检验（PPC）。该过程涉及定义物理模型、生成合成数据、为模型参数指定后验分布，然后使用一个差异变量（检验统计量）来检查模型预测与观测数据之间的系统性差异。\n\n第一步是建立模型的几何和物理参数。地下被离散为 $N=20$ 个矩形单元，排列在两个层位上，每层 10 个单元。上层深度为 $z=50\\,\\mathrm{m}$，下层深度为 $z=150\\,\\mathrm{m}$。每个单元的尺寸为 $\\Delta x = 100\\,\\mathrm{m}$、$\\Delta z = 100\\,\\mathrm{m}$，平面外厚度为 $L_y = 1000\\,\\mathrm{m}$，体积为 $V = 10^5\\,\\mathrm{m}^3$。在 $K=10$ 个地表点进行重力观测，位置为 $x_k = k \\cdot (100\\,\\mathrm{m})$（$k \\in \\{0, 1, \\dots, 9\\}$）。浅层的单元中心索引为 $i=0, \\dots, 9$，深层的索引为 $i=10, \\dots, 19$，两者的水平位置均与观测点对应。\n\n将地下密度 $\\boldsymbol{\\rho} \\in \\mathbb{R}^N$ 映射到重力异常 $\\mathbf{g} \\in \\mathbb{R}^K$ 的正演模型是线性的：$\\mathbf{g} = \\mathbf{G}\\boldsymbol{\\rho}$。正演算子 $\\mathbf{G} \\in \\mathbb{R}^{K \\times N}$ 是一个矩阵，其元素 $G_{ki}$ 代表单元 $i$ 在观测点 $k$ 处的垂直重力贡献。使用所提供的点质量近似，每个元素的计算公式为：\n$$\nG_{ki} = G_{\\mathrm{N}} V \\frac{z_i}{\\left( (x_k - x_i)^2 + z_i^2 \\right)^{3/2}}\n$$\n其中 $G_{\\mathrm{N}} = 6.67430 \\times 10^{-11}\\,\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$ 是引力常数，$(x_k, 0)$ 是第 $k$ 个观测点的坐标，$(x_i, z_i)$ 是第 $i$ 个单元中心的坐标。\n\n为执行 PPC，我们首先需要一组“观测”数据。合成观测数据 $\\mathbf{y}_{\\mathrm{obs}}$ 是从一个已知的真实密度模型 $\\boldsymbol{\\rho}_{\\mathrm{true}}$ 生成的。该真实模型包含一个背景密度 $\\rho_{\\mathrm{base}} = 2600\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$ 和一个密度为 $\\rho_{\\mathrm{base}} + 200\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$ 的高密度块体，位于较深层，水平索引为 $\\{3, 4, 5, 6\\}$，对应于全局单元索引 $\\{13, 14, 15, 16\\}$。标准差为 $\\sigma_{\\mathrm{true}} = 5 \\times 10^{-6}\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$ 的高斯噪声被加到真实重力信号上：\n$$\n\\mathbf{y}_{\\mathrm{obs}} = \\mathbf{G}\\boldsymbol{\\rho}_{\\mathrm{true}} + \\boldsymbol{\\varepsilon}_{\\mathrm{obs}}, \\quad \\boldsymbol{\\varepsilon}_{\\mathrm{obs}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_{\\mathrm{true}}^2 \\mathbf{I}_K)\n$$\n\nPPC 的核心在于将 $\\mathbf{y}_{\\mathrm{obs}}$ 与后验预测数据复制品 $\\mathbf{y}_{\\mathrm{rep}}$ 进行比较。我们首先定义一个检验统计量 $T(\\mathbf{y}, \\boldsymbol{\\rho})$，其设计目的是对空间失配敏感。选择二次型形式：\n$$\nT(\\mathbf{y}, \\boldsymbol{\\rho}) = (\\mathbf{y} - \\mathbf{G}\\boldsymbol{\\rho})^\\top \\mathbf{W} (\\mathbf{y} - \\mathbf{G}\\boldsymbol{\\rho})\n$$\n矩阵 $\\mathbf{W} \\in \\mathbb{R}^{K \\times K}$ 是一个对称的观测核矩阵，它根据残差的空间邻近性对其进行加权，其元素为 $W_{kl} = \\exp\\left( - (x_k - x_l)^2 / (2 b^2) \\right)$，其中 $b=200\\,\\mathrm{m}$。根据定义，未归一化的迹 $\\sum_k W_{kk} = \\sum_k \\exp(0) = K$。因此，为确保 $\\mathrm{trace}(\\mathbf{W})=K$ 而进行的指定归一化是自动满足的，但为了程序的正确性仍予以实现。\n\nPPC 算法按以下步骤进行。对于三个测试案例中的每一个，我们定义密度向量的多元高斯后验分布的参数，$\\boldsymbol{\\rho} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$。后验均值 $\\boldsymbol{\\mu}$ 的结构与 $\\boldsymbol{\\rho}_{\\mathrm{true}}$ 相同，但可能具有不同的异常振幅 $\\mu_{\\mathrm{anom}}$。后验协方差矩阵 $\\boldsymbol{\\Sigma}$ 使用平方指数核和一个块金项进行建模：\n$$\n\\Sigma_{ij} = s^2 \\exp\\left(- \\frac{d_{ij}^2}{\\ell^2} \\right) + \\nu^2 \\delta_{ij}\n$$\n其中 $s=150\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$\\nu=50\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$d_{ij}$ 是单元中心 $i$ 和 $j$ 之间的欧几里得距离，$\\ell$ 是特定于案例的相关长度。\n\n对每个测试案例，我们执行 $S=2000$ 次迭代：\n1.  从其后验分布中抽取一个密度向量样本 $\\boldsymbol{\\rho}^{(s)}$：$\\boldsymbol{\\rho}^{(s)} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$。\n2.  使用此参数抽样计算观测数据的检验统计量：$T_{\\mathrm{obs}}^{(s)} = T(\\mathbf{y}_{\\mathrm{obs}}, \\boldsymbol{\\rho}^{(s)})$。\n3.  生成一个复制数据集 $\\mathbf{y}_{\\mathrm{rep}}^{(s)} = \\mathbf{G}\\boldsymbol{\\rho}^{(s)} + \\boldsymbol{\\varepsilon}^{(s)}$，其中 $\\boldsymbol{\\varepsilon}^{(s)} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_{\\mathrm{pred}}^2 \\mathbf{I}_K)$ 且 $\\sigma_{\\mathrm{pred}}$ 是特定于案例的。\n4.  计算复制数据的检验统计量：$T_{\\mathrm{rep}}^{(s)} = T(\\mathbf{y}_{\\mathrm{rep}}^{(s)}, \\boldsymbol{\\rho}^{(s)})$。这可以简化为 $T_{\\mathrm{rep}}^{(s)} = (\\boldsymbol{\\varepsilon}^{(s)})^\\top \\mathbf{W} \\boldsymbol{\\varepsilon}^{(s)}$。\n\n在 $S$ 次迭代后，我们计算后验预测 p 值，即复制的统计量比观测的统计量更极端的次数所占的比例：\n$$\np = \\frac{1}{S} \\sum_{s=1}^S \\mathbb{I}\\left( T_{\\mathrm{rep}}^{(s)} \\ge T_{\\mathrm{obs}}^{(s)} \\right)\n$$\n最后，计算双边 p 值 $p_{\\mathrm{two}} = 2 \\min(p, 1-p)$。一个低的 $p_{\\mathrm{two}}$ 值（例如，低于阈值 $\\alpha=0.1$）表明该模型无法生成与观测数据相似的数据，这暗示了模型设定有误。整个过程使用向量化的 `NumPy` 操作实现以提高效率。固定的随机种子确保了可复现性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a Posterior Predictive Check (PPC) for a 1D gravity inversion model.\n    \"\"\"\n    # Set a fixed random seed for reproducibility.\n    np.random.seed(42)\n\n    # 1. Setup Constants and Geometry\n    # Physical Constants\n    G_N = 6.67430e-11  # m^3 kg^-1 s^-2\n    \n    # Discretization and Geometry\n    DX = 100.0         # m\n    DZ = 100.0         # m\n    LY = 1000.0        # m\n    V = DX * DZ * LY   # m^3\n    K = 10             # Number of observation points\n    N = 20             # Number of subsurface cells\n\n    x_obs = np.arange(K) * DX\n    z_layers = np.array([50.0, 150.0])\n    \n    # Cell centers: N=20 cells, 10 per layer.\n    # Cells 0-9: z=50m; Cells 10-19: z=150m.\n    x_cell_coords = np.arange(K) * DX\n    cell_centers = np.zeros((N, 2))\n    cell_centers[:K, 0] = x_cell_coords\n    cell_centers[:K, 1] = z_layers[0]\n    cell_centers[K:, 0] = x_cell_coords\n    cell_centers[K:, 1] = z_layers[1]\n\n    # 2. Construct Forward Operator G\n    G = np.zeros((K, N))\n    for k in range(K):\n        for i in range(N):\n            xk = x_obs[k]\n            xi, zi = cell_centers[i, 0], cell_centers[i, 1]\n            denominator = ((xk - xi)**2 + zi**2)**1.5\n            G[k, i] = G_N * V * zi / denominator\n\n    # 3. Generate Synthetic Observed Data y_obs\n    rho_base = 2600.0\n    true_anomaly_amp = 200.0\n    \n    rho_true = np.full(N, rho_base)\n    # Anomaly in deeper layer (indices 10-19) at horizontal indices 3, 4, 5, 6\n    # corresponds to global indices 13, 14, 15, 16.\n    anomaly_indices = [13, 14, 15, 16]\n    rho_true[anomaly_indices] += true_anomaly_amp\n    \n    sigma_true = 5e-6\n    g_true = G @ rho_true\n    epsilon_obs = np.random.normal(0, sigma_true, size=K)\n    y_obs = g_true + epsilon_obs\n\n    # 4. Construct Observation-Kernel Matrix W\n    b = 200.0\n    W = np.zeros((K, K))\n    for k in range(K):\n        for l in range(K):\n            W[k, l] = np.exp(-((x_obs[k] - x_obs[l])**2) / (2 * b**2))\n    \n    # Renormalize W such that trace(W) = K as per instruction.\n    # Note: The trace of the original W is already K since diagonal elements are 1.\n    trace_W = np.trace(W)\n    if trace_W > 0:\n        W_norm = W * K / trace_W\n    else:\n        W_norm = W\n\n    # 5. Implement PPC for each Test Case\n    S = 2000\n    s_cov = 150.0\n    nu_cov = 50.0\n\n    # Pre-compute squared Euclidean distance matrix for covariance\n    dist_sq_matrix = np.sum((cell_centers[:, np.newaxis, :] - cell_centers[np.newaxis, :, :])**2, axis=-1)\n\n    test_cases = [\n        # Case A: ell, sigma_pred, mu_anom\n        {'ell': 150.0, 'sigma_pred': 5e-6, 'mu_anom': 180.0},\n        # Case B: ell, sigma_pred, mu_anom\n        {'ell': 150.0, 'sigma_pred': 1e-6, 'mu_anom': 180.0},\n        # Case C: ell, sigma_pred, mu_anom\n        {'ell': 500.0, 'sigma_pred': 5e-6, 'mu_anom': 50.0},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        ell, sigma_pred, mu_anom = case['ell'], case['sigma_pred'], case['mu_anom']\n        \n        # a. Define Posterior Distribution\n        mu_rho = np.full(N, rho_base)\n        mu_rho[anomaly_indices] += mu_anom\n        \n        Sigma = s_cov**2 * np.exp(-dist_sq_matrix / ell**2) + np.eye(N) * nu_cov**2\n\n        # b. Sample from Posterior\n        rho_samples = np.random.multivariate_normal(mu_rho, Sigma, size=S)\n        \n        # c. PPC Calculation (vectorized)\n        \n        # T_obs for each sample\n        g_preds = rho_samples @ G.T  # Shape: (S, K)\n        r_obs_all = y_obs - g_preds  # Shape: (S, K)\n        T_obs_all = np.sum((r_obs_all @ W_norm) * r_obs_all, axis=1)\n\n        # T_rep for each sample\n        eps_rep_all = np.random.normal(0, sigma_pred, size=(S, K))\n        T_rep_all = np.sum((eps_rep_all @ W_norm) * eps_rep_all, axis=1)\n\n        # d. Calculate p-value\n        p_val = np.sum(T_rep_all >= T_obs_all) / S\n        p_two_sided = 2 * min(p_val, 1-p_val)\n        \n        results.append(p_two_sided)\n\n    # Print final output in the required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}