{
    "hands_on_practices": [
        {
            "introduction": "此练习为将贝叶斯理论应用于实际地球物理问题提供了基础。通过为潮汐测量数据构建一个分层线性模型，您将学习如何将数学规范转化为可执行代码，处理多站点数据和缺失观测值等现实挑战。完成此练习将使您掌握计算后验预测分布的核心技能，这是利用量化不确定性进行预测的基石 。",
            "id": "3618115",
            "problem": "您需要构建并使用一个分层线性高斯模型来处理带有季节性分量和缺失观测值的验潮仪海平面观测数据，并推导和计算在未观测时间点的海平面后验预测分布。该模型以数学术语指定，并应实现为一个完整、可运行的程序。三角函数中的所有角度都必须以弧度表示。所有海平面高度必须以米为单位，噪声方差以平方米为单位。最终程序必须产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，该列表汇总了所有提供的测试用例的结果，每个预测由一个包含预测均值（单位：米）和预测方差（单位：平方米）的两元素列表表示。\n\n模型规范：考虑由 $s \\in \\{0,1,\\dots,S-1\\}$ 索引的 $S$ 个验潮站。令 $t$ 表示以年为单位的时间，并令 $\\cos(2\\pi t)$ 和 $\\sin(2\\pi t)$ 表示周期为 1 年的季节性基函数（角度以弧度为单位）。站点 $s$ 在时间 $t$ 观测到的海平面模型为\n$$\ny_s(t) = \\alpha_s + \\beta_s t + A \\cos(2\\pi t) + B \\sin(2\\pi t) + \\varepsilon_s(t),\n$$\n其中 $\\varepsilon_s(t) \\sim \\mathcal{N}(0,\\sigma^2)$ 在所有观测中独立同分布，且噪声方差 $\\sigma^2$ 已知。定义参数向量\n$$\n\\theta = \\begin{bmatrix} \\alpha_0 \\\\ \\beta_0 \\\\ \\alpha_1 \\\\ \\beta_1 \\\\ \\vdots \\\\ \\alpha_{S-1} \\\\ \\beta_{S-1} \\\\ A \\\\ B \\end{bmatrix} \\in \\mathbb{R}^{2S+2}.\n$$\n假设一个高斯先验\n$$\n\\theta \\sim \\mathcal{N}(m_0, S_0),\n$$\n其中 $m_0$ 和 $S_0$ 指定如下：$m_0$ 是长度为 $2S+2$ 的零向量，$S_0$ 是对角矩阵，其对角线元素为每个特定于站点的截距 $\\alpha_s$ 的先验方差 $v_\\alpha$、每个特定于站点的斜率 $\\beta_s$ 的先验方差 $v_\\beta$ 以及季节性系数 $A$ 和 $B$ 的先验方差 $v_A$ 和 $v_B$。这构成了一个分层模型，其中特定于站点的系数共享控制其先验变异性的共同超参数 $v_\\alpha$ 和 $v_\\beta$，而季节性系数是跨站点全局的。\n\n令 $H \\in \\mathbb{R}^{N \\times (2S+2)}$ 表示从 $N$ 个可用观测构建的设计矩阵，每行对应一个观测 $(s,t)$，其条目为\n$$\nH_{(s,t)} = \\big[0,\\dots,0,\\underbrace{1}_{\\alpha_s},\\underbrace{t}_{\\beta_s},0,\\dots,0,\\underbrace{\\cos(2\\pi t)}_{A},\\underbrace{\\sin(2\\pi t)}_{B}\\big],\n$$\n在 $\\alpha_s$ 的列中放置 $1$，在 $\\beta_s$ 的列中放置 $t$，最后两列用于全局季节性项。处理缺失观测值的方法是，直接从 $H$ 中省略其对应的行，并从观测向量 $y \\in \\mathbb{R}^{N}$ 中省略其值。\n\n在线性高斯假设下并给定 $\\sigma^2$，$\\theta$ 的后验分布是高斯分布，其均值为 $m_n$，协方差为 $S_n$：\n$$\nS_n = \\left(S_0^{-1} + \\frac{1}{\\sigma^2} H^\\top H\\right)^{-1}, \\quad\nm_n = S_n \\left(S_0^{-1} m_0 + \\frac{1}{\\sigma^2} H^\\top y\\right).\n$$\n对于在站点 $s^\\ast$ 和时间 $t^\\ast$ 的新预测，令 $h^\\ast \\in \\mathbb{R}^{2S+2}$ 为与 $H$ 类似地构建的相应设计行向量。$y_{s^\\ast}(t^\\ast)$ 的后验预测分布是高斯分布，其均值和方差为\n$$\n\\mu^\\ast = h^\\ast m_n, \\quad \\sigma_\\ast^2 = \\sigma^2 + h^\\ast S_n {h^\\ast}^\\top.\n$$\n您的程序必须为每个指定的查询计算 $(\\mu^\\ast, \\sigma_\\ast^2)$ 对。\n\n测试套件：实现该模型并为以下三个参数集计算后验预测均值和方差。对于每种情况，从给定的观测值构建设计矩阵 $H$，使用指定的先验超参数构建 $S_0$，并为指定的查询计算预测对。报告所有预测均值（单位：米）和方差（单位：平方米）。\n\n- 情况 1（一般情况，有两个站点，中等噪声，一些缺失观测值）：\n  - 站点数：$S = 2$。\n  - 噪声方差：$\\sigma^2 = 0.01$ $\\mathrm{m}^2$。\n  - 先验方差：$v_\\alpha = 0.25$ $\\mathrm{m}^2$，$v_\\beta = 0.0025$ $\\mathrm{m}^2/\\mathrm{year}^2$，$v_A = 0.04$ $\\mathrm{m}^2$，$v_B = 0.04$ $\\mathrm{m}^2$。\n  - 观测值（站点索引 $s$，时间 $t$ 年，海平面 $y$ 米）：\n    - 站点 0：$(s=0, t=0.0, y=0.252)$, $(s=0, t=0.5, y=0.065)$, $(s=0, t=1.5, y=0.082)$, $(s=0, t=2.0, y=0.292)$。\n    - 站点 1：$(s=1, t=0.25, y=0.007)$, $(s=1, t=0.75, y=0.113)$, $(s=1, t=1.25, y=0.021)$, $(s=1, t=1.75, y=0.128)$。\n  - 查询（站点索引 $s^\\ast$，时间 $t^\\ast$ 年）：$(s^\\ast=0, t^\\ast=2.25)$, $(s^\\ast=0, t^\\ast=0.25)$, $(s^\\ast=1, t^\\ast=2.0)$。\n\n- 情况 2（边界情况，只有一个站点和单个观测值，噪声较大）：\n  - 站点数：$S = 1$。\n  - 噪声方差：$\\sigma^2 = 0.05$ $\\mathrm{m}^2$。\n  - 先验方差：$v_\\alpha = 0.25$ $\\mathrm{m}^2$，$v_\\beta = 0.0025$ $\\mathrm{m}^2/\\mathrm{year}^2$，$v_A = 0.04$ $\\mathrm{m}^2$，$v_B = 0.04$ $\\mathrm{m}^2$。\n  - 观测值：\n    - 站点 0：$(s=0, t=0.0, y=0.20)$。\n  - 查询：$(s^\\ast=0, t^\\ast=0.5)$, $(s^\\ast=0, t^\\ast=1.0)$。\n\n- 情况 3（边缘情况，有三个站点，一个站点无观测值，中等噪声）：\n  - 站点数：$S = 3$。\n  - 噪声方差：$\\sigma^2 = 0.02$ $\\mathrm{m}^2$。\n  - 先验方差：$v_\\alpha = 0.25$ $\\mathrm{m}^2$，$v_\\beta = 0.0025$ $\\mathrm{m}^2/\\mathrm{year}^2$，$v_A = 0.04$ $\\mathrm{m}^2$，$v_B = 0.04$ $\\mathrm{m}^2$。\n  - 观测值：\n    - 站点 0：$(s=0, t=0.0, y=0.260)$, $(s=0, t=0.5, y=0.060)$。\n    - 站点 1：$(s=1, t=0.25, y=0.005)$, $(s=1, t=0.75, y=0.115)$。\n    - 站点 2：无观测值。\n  - 查询：$(s^\\ast=2, t^\\ast=0.6)$, $(s^\\ast=1, t^\\ast=1.25)$, $(s^\\ast=0, t^\\ast=1.5)$。\n\n最终输出格式：您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，其中每个测试用例为其查询生成一个两元素列表 $[\\mu^\\ast,\\sigma_\\ast^2]$ 的列表，顺序如上所列。例如，输出应具有结构 $[[[\\mu_1^{(1)},\\sigma_{1}^{2\\,(1)}],[\\mu_2^{(1)},\\sigma_{2}^{2\\,(1)}],\\dots],[[\\mu_1^{(2)},\\sigma_{1}^{2\\,(2)}],\\dots],[[\\mu_1^{(3)},\\sigma_{1}^{2\\,(3)}],\\dots]]$，所有值均为指定单位的实数。",
            "solution": "用户提供了一个问题陈述，要求实现一个分层线性高斯模型，以对模拟的验潮仪数据执行贝叶斯推断。任务是计算在指定的未观测时间点的海平面后验预测分布。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n问题提供了以下模型、定义和数据：\n\n*   **模型方程**：站点 $s$ 和时间 $t$ 处观测到的海平面 $y_s(t)$ 由下式给出\n    $$y_s(t) = \\alpha_s + \\beta_s t + A \\cos(2\\pi t) + B \\sin(2\\pi t) + \\varepsilon_s(t)$$\n*   **噪声模型**：观测噪声 $\\varepsilon_s(t)$ 是独立同分布的，服从 $\\mathcal{N}(0, \\sigma^2)$，其中方差 $\\sigma^2$ 已知。\n*   **参数向量**：模型参数被整合到一个向量 $\\theta \\in \\mathbb{R}^{2S+2}$ 中：\n    $$\\theta = \\begin{bmatrix} \\alpha_0 \\\\ \\beta_0 \\\\ \\vdots \\\\ \\alpha_{S-1} \\\\ \\beta_{S-1} \\\\ A \\\\ B \\end{bmatrix}$$\n*   **先验分布**：$\\theta$ 的先验是一个多元高斯分布，$\\theta \\sim \\mathcal{N}(m_0, S_0)$。\n    *   先验均值：$m_0$ 是零向量。\n    *   先验协方差：$S_0$ 是一个对角矩阵，其对角线元素对应于每个 $\\alpha_s$ 的先验方差 $v_\\alpha$、每个 $\\beta_s$ 的先验方差 $v_\\beta$、$A$ 的先验方差 $v_A$ 和 $B$ 的先验方差 $v_B$。\n*   **设计矩阵 ($H$)**：对于 $N$ 个观测， $H$ 是一个 $N \\times (2S+2)$ 矩阵，其中每行对应于站点 $s$ 和时间 $t$ 的一次观测，形式如下：\n    $$H_{(s,t)} = \\big[0,\\dots,0,\\underbrace{1}_{\\text{col for }\\alpha_s},\\underbrace{t}_{\\text{col for }\\beta_s},0,\\dots,0,\\underbrace{\\cos(2\\pi t)}_{\\text{col for }A},\\underbrace{\\sin(2\\pi t)}_{\\text{col for }B}\\big]$$\n*   **后验分布**：$\\theta$ 的后验分布是高斯分布，$\\theta | y \\sim \\mathcal{N}(m_n, S_n)$，其中：\n    $$S_n = \\left(S_0^{-1} + \\frac{1}{\\sigma^2} H^\\top H\\right)^{-1}$$\n    $$m_n = S_n \\left(S_0^{-1} m_0 + \\frac{1}{\\sigma^2} H^\\top y\\right)$$\n*   **后验预测分布**：对于在 $(s^\\ast, t^\\ast)$ 处的一个新预测，其设计向量为 $h^\\ast$，预测分布是高斯分布，均值为 $\\mu^\\ast$，方差为 $\\sigma_\\ast^2$：\n    $$\\mu^\\ast = h^\\ast m_n$$\n    $$\\sigma_\\ast^2 = \\sigma^2 + h^\\ast S_n {h^\\ast}^\\top$$\n*   **测试用例**：提供了三个具体的测试用例，每个用例都给出了 $S$、$\\sigma^2$、先验方差的值，一组观测值 $(s, t, y)$，以及一组查询 $(s^\\ast, t^\\ast)$。\n\n**步骤 2：使用提取的信息进行验证**\n\n根据验证标准对问题进行评估：\n\n*   **科学依据**：该问题在贝叶斯统计学原理方面有充分的依据。使用线性高斯模型是回归和数据同化的标准和基本技术，在包括地球物理学在内的科学领域得到广泛应用。模型结构（特定于站点的趋势加上全局季节性）是一种常见且合理的简化。\n*   **适定性**：问题是适定的。先验方差（$v_\\alpha, v_\\beta, v_A, v_B$）均为正数，这确保了先验协方差矩阵 $S_0$ 是正定的。因此，其逆矩阵 $S_0^{-1}$ 存在且也是正定的。矩阵 $H^\\top H$ 是半正定的。一个正定矩阵（$S_0^{-1}$）与一个半正定矩阵（$\\frac{1}{\\sigma^2} H^\\top H$）之和总是正定的。这保证了矩阵 $S_n^{-1}$ 是可逆的，从而确保了唯一的后验协方差 $S_n$ 和均值 $m_n$ 存在。\n*   **客观性**：问题以完全客观的方式陈述，使用了精确的数学公式和数值数据。没有主观或基于意见的成分。\n*   **完整性与一致性**：问题是自洽的。对于每个测试用例，所有必要的参数、数据和超参数都已明确提供。设置中没有矛盾。对缺失观测值的处理（通过从 $H$ 中省略行）是一种标准且一致的方法。\n*   **现实性与可行性**：提供的海平面、时间尺度和方差的数值对于这种类型的简化模型是合理的。单位在整个问题中保持一致。计算任务是可行的。\n*   **结构与清晰度**：问题结构清晰。所有变量和数学运算都得到了明确的定义。包含了边缘情况，例如一个没有观测值的站点（情况 3），这测试了模型实现的稳健性及其对贝叶斯原理的遵循情况（在这种情况下，该站点参数的后验应恢复为先验）。\n\n**步骤 3：结论与行动**\n\n问题陈述是**有效**的。它在科学上是合理的，数学上是一致的，适定的且完整的。我将继续开发解决方案。\n\n### 解决方案设计\n\n该问题要求实现线性高斯模型的标准贝叶斯更新和预测步骤。解决方案的核心是将所提供的矩阵方程转换为计算算法。每个测试用例的处理流程如下：\n\n1.  **初始化**：给定站点数 $S$，确定参数向量 $\\theta$ 的维度 $D = 2S + 2$。参数排序为 $(\\alpha_0, \\beta_0, \\alpha_1, \\beta_1, \\dots, \\alpha_{S-1}, \\beta_{S-1}, A, B)$。\n\n2.  **先验规范**：\n    *   构建先验均值向量 $m_0$，它是一个长度为 $D$ 的零向量。\n    *   构建先验协方差矩阵 $S_0$。这是一个 $D \\times D$ 的对角矩阵。对角线元素用给定的先验方差填充：$S$ 个 $v_\\alpha$ 条目，接着是 $S$ 个 $v_\\beta$ 条目，最后是 $v_A$ 和 $v_B$。确切地说，$\\alpha_s$ 和 $\\beta_s$ 的对角元素分别位于索引 $2s$ 和 $2s+1$ 处。$A$ 和 $B$ 的元素位于最后两个索引 $2S$ 和 $2S+1$ 处。\n    *   计算先验协方差的逆矩阵 $S_0^{-1}$，它也是一个对角矩阵，其元素是先验方差的倒数。\n\n3.  **数据处理**：\n    *   根据观测值列表，构建 $N \\times D$ 的设计矩阵 $H$ 和 $N \\times 1$ 的观测向量 $y$。\n    *   对于每个观测值 $(s_i, t_i, y_i)$，创建一个对应的行 $H_i$。该行向量有四个非零元素：索引 $2s_i$ 处为 $1$（对应 $\\alpha_{s_i}$），索引 $2s_i+1$ 处为 $t_i$（对应 $\\beta_{s_i}$），索引 $2S$ 处为 $\\cos(2\\pi t_i)$（对应 $A$），索引 $2S+1$ 处为 $\\sin(2\\pi t_i)$（对应 $B$）。\n    *   向量 $y$ 简单地收集所有观测值 $y_i$。\n\n4.  **后验计算**：\n    *   计算矩阵 $S_n^{-1} = S_0^{-1} + \\frac{1}{\\sigma^2} H^\\top H$。该矩阵代表后验精度，是先验精度和数据精度（缩放后的似然）之和。\n    *   对该矩阵求逆以获得后验协方差矩阵：$S_n = (S_n^{-1})^{-1}$。\n    *   计算项 $b = S_0^{-1} m_0 + \\frac{1}{\\sigma^2} H^\\top y$。由于 $m_0 = 0$，这简化为 $b = \\frac{1}{\\sigma^2} H^\\top y$。\n    *   计算后验均值向量：$m_n = S_n b$。此计算找到了更新后参数分布的均值，它平衡了先验信念和数据证据。\n\n5.  **预测**：\n    *   对于每个查询 $(s^\\ast, t^\\ast)$，以与 $H$ 的行相同的方式构建 $1 \\times D$ 的设计向量 $h^\\ast$。\n    *   后验预测均值计算为点积 $\\mu^\\ast = h^\\ast m_n$。这给出了在给定模型和观测数据的情况下，查询点的海平面的最佳估计。\n    *   后验预测方差计算为 $\\sigma_\\ast^2 = \\sigma^2 + h^\\ast S_n {h^\\ast}^\\top$。该方差有两个组成部分：固有的观测噪声 $\\sigma^2$ 和通过模型传播的参数不确定性 $h^\\ast S_n {h^\\ast}^\\top$。这个和代表了新预测的总不确定性。\n\n此过程将被实现为一个函数，可应用于所提供的所有三个测试用例。对于某个站点没有观测值的情况（情况 3，站点 2），此框架能正确处理：$H$ 中对应于 $\\alpha_2$ 和 $\\beta_2$ 的列将全为零。因此，这些参数的后验分布将不会被数据更新，并保持为其先验分布，这在数学上是正确的结果。实现将使用 `numpy` 库进行所有线性代数运算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    def compute_predictions(S, sigma2, prior_variances, observations, queries):\n        \"\"\"\n        Computes posterior predictive means and variances for a single test case.\n\n        Args:\n            S (int): Number of stations.\n            sigma2 (float): Observation noise variance.\n            prior_variances (list): A list of floats [v_alpha, v_beta, v_A, v_B].\n            observations (list): A list of tuples (s, t, y).\n            queries (list): A list of tuples (s_star, t_star).\n\n        Returns:\n            list: A list of [mean, variance] pairs for each query.\n        \"\"\"\n        # Dimension of the parameter vector theta\n        D = 2 * S + 2\n        \n        # 1. Construct prior distribution parameters\n        v_alpha, v_beta, v_A, v_B = prior_variances\n        m0 = np.zeros(D)\n        \n        diag_S0 = []\n        for s in range(S):\n            diag_S0.extend([v_alpha, v_beta])\n        diag_S0.extend([v_A, v_B])\n        S0 = np.diag(diag_S0)\n        \n        # The inverse of a diagonal matrix is a diagonal matrix of reciprocals\n        S0_inv = np.diag(1 / np.array(diag_S0))\n        \n        # 2. Construct design matrix H and observation vector y\n        N = len(observations)\n        if N > 0:\n            H = np.zeros((N, D))\n            y = np.zeros(N)\n            for i, (s, t, y_val) in enumerate(observations):\n                # Row H_i for observation (s, t, y_val)\n                H[i, 2*s] = 1.0                          # Coefficient for alpha_s\n                H[i, 2*s + 1] = t                        # Coefficient for beta_s\n                H[i, 2*S] = np.cos(2 * np.pi * t)        # Coefficient for A\n                H[i, 2*S + 1] = np.sin(2 * np.pi * t)    # Coefficient for B\n                y[i] = y_val\n        else:\n            # Handle cases with no observations (not in test suite but good practice)\n            H = np.zeros((0, D))\n            y = np.zeros(0)\n\n        # 3. Compute posterior distribution parameters (mean mn, covariance Sn)\n        # Posterior precision matrix: S_n^-1 = S_0^-1 + (1/sigma^2) * H^T * H\n        H_T_H = H.T @ H\n        Sn_inv = S0_inv + (1 / sigma2) * H_T_H\n        \n        # Posterior covariance: S_n = (S_n^-1)^-1\n        Sn = np.linalg.inv(Sn_inv)\n        \n        # Posterior mean: m_n = S_n * (S_0^-1 * m_0 + (1/sigma^2) * H^T * y)\n        # Since m_0 is the zero vector, this simplifies.\n        H_T_y = H.T @ y\n        mn = Sn @ ((1 / sigma2) * H_T_y)\n        \n        # 4. Compute predictions for all queries\n        results = []\n        for s_star, t_star in queries:\n            # Construct the design vector h* for the query\n            h_star = np.zeros(D)\n            h_star[2*s_star] = 1.0                             # alpha_{s*}\n            h_star[2*s_star + 1] = t_star                      # beta_{s*}\n            h_star[2*S] = np.cos(2 * np.pi * t_star)           # A\n            h_star[2*S + 1] = np.sin(2 * np.pi * t_star)       # B\n            \n            # Posterior predictive mean: mu* = h* @ m_n\n            mu_star = h_star @ mn\n            \n            # Posterior predictive variance: sigma*^2 = sigma^2 + h* @ S_n @ h*_T\n            sigma2_star = sigma2 + h_star @ Sn @ h_star\n            \n            results.append([mu_star, sigma2_star])\n            \n        return results\n\n    # --- Test Cases ---\n    \n    # Case 1\n    case1 = {\n        \"S\": 2, \"sigma2\": 0.01,\n        \"prior_variances\": [0.25, 0.0025, 0.04, 0.04],\n        \"observations\": [\n            (0, 0.0, 0.252), (0, 0.5, 0.065), (0, 1.5, 0.082), (0, 2.0, 0.292),\n            (1, 0.25, 0.007), (1, 0.75, 0.113), (1, 1.25, 0.021), (1, 1.75, 0.128)\n        ],\n        \"queries\": [(0, 2.25), (0, 0.25), (1, 2.0)]\n    }\n\n    # Case 2\n    case2 = {\n        \"S\": 1, \"sigma2\": 0.05,\n        \"prior_variances\": [0.25, 0.0025, 0.04, 0.04],\n        \"observations\": [(0, 0.0, 0.20)],\n        \"queries\": [(0, 0.5), (0, 1.0)]\n    }\n\n    # Case 3\n    case3 = {\n        \"S\": 3, \"sigma2\": 0.02,\n        \"prior_variances\": [0.25, 0.0025, 0.04, 0.04],\n        \"observations\": [\n            (0, 0.0, 0.260), (0, 0.5, 0.060),\n            (1, 0.25, 0.005), (1, 0.75, 0.115)\n        ],\n        \"queries\": [(2, 0.6), (1, 1.25), (0, 1.5)]\n    }\n    \n    test_cases = [case1, case2, case3]\n    all_results = []\n    \n    for case in test_cases:\n        result_case = compute_predictions(\n            case[\"S\"], case[\"sigma2\"], case[\"prior_variances\"],\n            case[\"observations\"], case[\"queries\"]\n        )\n        all_results.append(result_case)\n\n    # Format the final output string to match the specified format.\n    # The str() function on a list of lists creates the desired structure,\n    # and .replace(\" \", \"\") removes all whitespace.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在建立模型之后，评估其有效性至关重要。此练习介绍了后验预测检验（PPC），这是一种通过将观测数据与从模型生成的模拟数据进行比较来诊断模型设定错误的强大技术。您将为一个重力反演问题实现一个复杂的PPC，并学习如何设计对特定模型缺陷敏感的检验统计量，从而将统计概念与物理现实联系起来 。",
            "id": "3618119",
            "problem": "考虑一个沿水平剖面的一维重力反演模型，其双层地下结构被离散为多个矩形单元。目标是通过构建一个空间相干的检验统计量，为该模型设计一个后验预测检验 (PPC)，并通过后验预测 p 值确定一个决策阈值。该 PPC 必须作为一个完整、可运行的程序来实现。\n\n基本原理与物理建模。由质点引起的重力加速度的垂直分量源自牛顿引力定律。通过对近似地下结构的体积单元进行叠加，地表观测位置处的预测垂直重力异常由一个线性正演算子建模。设有 $K$ 个地表观测点，其水平位置为 $\\{x_k\\}_{k=1}^K$，以及 $N$ 个地下单元，其中心位置为 $\\{(x_i, z_i)\\}_{i=1}^N$，其中 $z_i$ 是深度。设引力常数为 $G_{\\mathrm{N}} = 6.67430 \\times 10^{-11}$ $\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$，每个单元的体积为 $V = \\Delta x \\,\\Delta z \\, L_y$，其中 $\\Delta x = 100\\,\\mathrm{m}$，$\\Delta z = 100\\,\\mathrm{m}$，平面外厚度 $L_y = 1000\\,\\mathrm{m}$。单元质量为 $m_i = \\rho_i V$，其中 $\\rho_i$ 是密度，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$。由单元 $i$ 在观测点 $k$ 处产生的垂直重力为\n$$\ng_{ki} = G_{\\mathrm{N}} \\, m_i \\, \\frac{z_i}{\\left( (x_k - x_i)^2 + z_i^2 \\right)^{3/2}},\n$$\n在观测点 $k$ 处的总预测异常为\n$$\ng_k(\\boldsymbol{\\rho}) = \\sum_{i=1}^N G_{\\mathrm{N}} \\, (\\rho_i V) \\, \\frac{z_i}{\\left( (x_k - x_i)^2 + z_i^2 \\right)^{3/2}}。\n$$\n所有重力值都应以 $\\mathrm{m}\\,\\mathrm{s}^{-2}$ 为单位进行处理和解释。\n\n后验模型与 PPC 构建。设密度向量 $\\boldsymbol{\\rho} \\in \\mathbb{R}^N$ 的后验分布为多元高斯分布，其均值为 $\\boldsymbol{\\mu}$，协方差为 $\\boldsymbol{\\Sigma}$，其中\n$$\n\\Sigma_{ij} = s^2 \\exp\\left(- \\frac{d_{ij}^2}{\\ell^2} \\right) + \\nu^2 \\delta_{ij},\n$$\n$d_{ij}$ 是单元中心 $(x_i,z_i)$ 和 $(x_j,z_j)$ 之间的欧几里得距离，$s$ 是边际标准差，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$\\ell$ 是相关长度尺度，单位为 $\\mathrm{m}$，$\\nu$ 是块金值，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$\\delta_{ij}$ 是克罗内克 δ。\n\n使用从观测位置 $\\{x_k\\}$ 构建的观测核矩阵 $\\mathbf{W} \\in \\mathbb{R}^{K \\times K}$ 定义一个空间相干的检验统计量：\n$$\nW_{kl} = \\exp\\left( -\\frac{(x_k - x_l)^2}{2 b^2} \\right),\n$$\n其中 $b$ 是空间带宽，单位为 $\\mathrm{m}$，然后重新归一化 $\\mathbf{W}$ 使得 $\\mathrm{trace}(\\mathbf{W}) = K$。对于给定的 $\\boldsymbol{\\rho}$，定义残差 $\\mathbf{r}(\\boldsymbol{\\rho}) = \\mathbf{y}_{\\mathrm{obs}} - \\mathbf{G}\\boldsymbol{\\rho}$，其中 $\\mathbf{G} \\in \\mathbb{R}^{K \\times N}$ 表示正演算子，其元素为 $G_{ki} = G_{\\mathrm{N}} V \\, z_i / \\left( (x_k - x_i)^2 + z_i^2 \\right)^{3/2}$。检验统计量为\n$$\nT(\\mathbf{y}, \\boldsymbol{\\rho}) = \\mathbf{r}(\\boldsymbol{\\rho})^\\top \\mathbf{W}\\,\\mathbf{r}(\\boldsymbol{\\rho})。\n$$\n\n后验预测 p 值。对于 $s = 1, \\dots, S$，从 $\\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$ 中抽取样本 $\\boldsymbol{\\rho}^{(s)}$，并为每个抽取的样本生成一个后验预测复制品\n$$\n\\mathbf{y}_{\\mathrm{rep}}^{(s)} = \\mathbf{G}\\boldsymbol{\\rho}^{(s)} + \\boldsymbol{\\varepsilon}^{(s)}, \\quad \\boldsymbol{\\varepsilon}^{(s)} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_{\\mathrm{pred}}^2 \\mathbf{I}_K),\n$$\n其中 $\\sigma_{\\mathrm{pred}}$ 是后验预测噪声标准差，单位为 $\\mathrm{m}\\,\\mathrm{s}^{-2}$，$\\mathbf{I}_K$ 是 $K \\times K$ 的单位矩阵。对每个 $s$ 计算 $T\\left(\\mathbf{y}_{\\mathrm{obs}}, \\boldsymbol{\\rho}^{(s)}\\right)$ 和 $T\\left(\\mathbf{y}_{\\mathrm{rep}}^{(s)}, \\boldsymbol{\\rho}^{(s)}\\right)$，并通过下式近似计算后验预测 p 值\n$$\np = \\frac{1}{S} \\sum_{s=1}^S \\mathbb{I}\\left( T\\left(\\mathbf{y}_{\\mathrm{rep}}^{(s)}, \\boldsymbol{\\rho}^{(s)}\\right) \\ge T\\left(\\mathbf{y}_{\\mathrm{obs}}, \\boldsymbol{\\rho}^{(s)}\\right) \\right),\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。使用双边 p 值 $p_{\\mathrm{two}} = 2 \\min(p, 1-p)$ 和一个决策阈值 $\\alpha$，当 $p_{\\mathrm{two}} \\le \\alpha$ 时拒绝模型，否则不拒绝。\n\n设置。使用一个一维剖面，包含 $K = 10$ 个观测点，位置为 $x_k = k \\Delta x$（$k = 0, 1, \\dots, 9$），以及 $N = 20$ 个地下单元，排列在 $z = 50\\,\\mathrm{m}$ 和 $z = 150\\,\\mathrm{m}$ 两个深度层，其水平位置为 $x_i = i \\Delta x$（$i$ 对应于每层的索引）。假设基线真实密度为 $\\rho_{\\mathrm{base}} = 2600\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，并在较深层（$z = 150\\,\\mathrm{m}$）存在一个幅度为 $200\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$ 的异常块体，水平跨越索引 $i \\in \\{3,4,5,6\\}$。生成合成观测数据\n$$\n\\mathbf{y}_{\\mathrm{obs}} = \\mathbf{G}\\boldsymbol{\\rho}_{\\mathrm{true}} + \\boldsymbol{\\varepsilon}_{\\mathrm{obs}}, \\quad \\boldsymbol{\\varepsilon}_{\\mathrm{obs}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_{\\mathrm{true}}^2 \\mathbf{I}_K),\n$$\n其中 $\\sigma_{\\mathrm{true}} = 5 \\times 10^{-6}\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$，并使用固定的随机种子以确保可复现性。\n\n后验设定。对于后验均值，在较深层使用与真实情况相同的异常范围，但幅度为 $\\mu_{\\mathrm{anom}}$，基线为 $\\rho_{\\mathrm{base}}$；对于异常范围之外的单元，将其均值设为 $\\rho_{\\mathrm{base}}$。对于协方差，使用 $s = 150\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$ 和块金值 $\\nu = 50\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，其中距离 $d_{ij}$ 在 $(x,z)$ 平面内计算。观测核的带宽为 $b = 200\\,\\mathrm{m}$。\n\n测试套件。为以下三组参数集实现 PPC，每组使用 $S = 2000$ 个后验样本：\n- 案例 A（精确定位的噪声和中等空间相关性）：$\\ell = 150\\,\\mathrm{m}$，$\\sigma_{\\mathrm{pred}} = 5 \\times 10^{-6}\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$，$\\mu_{\\mathrm{anom}} = 180\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$\\alpha = 0.1$。\n- 案例 B（低估的预测噪声）：$\\ell = 150\\,\\mathrm{m}$，$\\sigma_{\\mathrm{pred}} = 1 \\times 10^{-6}\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$，$\\mu_{\\mathrm{anom}} = 180\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$\\alpha = 0.1$。\n- 案例 C（过度平滑的后验空间结构）：$\\ell = 500\\,\\mathrm{m}$，$\\sigma_{\\mathrm{pred}} = 5 \\times 10^{-6}\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$，$\\mu_{\\mathrm{anom}} = 50\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$\\alpha = 0.1$。\n\n要求的输出和单位。对于每种情况，计算双边后验预测 p 值 $p_{\\mathrm{two}}$（无量纲，表示为 $[0,1]$ 范围内的小数）。您的程序应生成单行输出，其中包含三个结果，形式为逗号分隔的列表并用方括号括起来，例如 $\\left[ p_{\\mathrm{two},A}, p_{\\mathrm{two},B}, p_{\\mathrm{two},C} \\right]$。重力计算必须以 $\\mathrm{m}\\,\\mathrm{s}^{-2}$ 为单位，密度以 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$ 为单位，距离以 $\\mathrm{m}$ 为单位，不使用角度。不允许使用百分比；所有概率必须是小数。\n\n设计约束。实现必须从所述的物理正演模型和高斯后验定义开始。在这些基础之外，不要使用任何快捷公式。按照规定从观测坐标构建 $\\mathbf{W}$ 并将其重新归一化，使其迹为 $\\mathrm{trace}(\\mathbf{W}) = K$。使用固定的随机种子以确保确定性。通过保持所述的参数值和单位，并使用所提供的未经修改的测试套件，来确保科学真实性。",
            "solution": "该解决方案为地球物理重力模型实现了一个后验预测检验 (PPC)。该过程涉及定义物理模型、生成合成数据、为模型参数指定后验分布，然后使用一个差异变量（检验统计量）来检查模型预测与观测数据之间的系统性差异。\n\n第一步是建立模型的几何和物理参数。地下被离散为 $N=20$ 个矩形单元，排列在两个层中，每层 10 个单元。上层深度为 $z=50\\,\\mathrm{m}$，下层深度为 $z=150\\,\\mathrm{m}$。每个单元的尺寸为 $\\Delta x = 100\\,\\mathrm{m}$、$\\Delta z = 100\\,\\mathrm{m}$，平面外厚度为 $L_y = 1000\\,\\mathrm{m}$，因此体积为 $V = 10^5\\,\\mathrm{m}^3$。在 $K=10$ 个地表点进行重力观测，这些点位于 $x_k = k \\cdot (100\\,\\mathrm{m})$（$k \\in \\{0, 1, \\dots, 9\\}$）。浅层单元中心的索引为 $i=0, \\dots, 9$，深层单元中心的索引为 $i=10, \\dots, 19$，它们的水平位置都与观测点相对应。\n\n将地下密度 $\\boldsymbol{\\rho} \\in \\mathbb{R}^N$ 映射到重力异常 $\\mathbf{g} \\in \\mathbb{R}^K$ 的正演模型是线性的：$\\mathbf{g} = \\mathbf{G}\\boldsymbol{\\rho}$。正演算子 $\\mathbf{G} \\in \\mathbb{R}^{K \\times N}$ 是一个矩阵，其元素 $G_{ki}$ 表示单元 $i$ 在观测点 $k$ 处的垂直重力贡献。使用所提供的质点近似，每个元素的计算公式如下：\n$$\nG_{ki} = G_{\\mathrm{N}} V \\frac{z_i}{\\left( (x_k - x_i)^2 + z_i^2 \\right)^{3/2}}\n$$\n其中 $G_{\\mathrm{N}} = 6.67430 \\times 10^{-11}\\,\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$ 是引力常数，$(x_k, 0)$ 是第 $k$ 个观测点的坐标，$(x_i, z_i)$ 是第 $i$ 个单元中心的坐标。\n\n为执行 PPC，我们首先需要一组“观测”数据。合成观测数据 $\\mathbf{y}_{\\mathrm{obs}}$ 是从一个已知的真实密度模型 $\\boldsymbol{\\rho}_{\\mathrm{true}}$ 生成的。这个真实模型包含一个背景密度 $\\rho_{\\mathrm{base}} = 2600\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$ 和一个密度为 $\\rho_{\\mathrm{base}} + 200\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$ 的高密度块体，该块体位于较深层，水平索引为 $\\{3, 4, 5, 6\\}$，对应于全局单元索引 $\\{13, 14, 15, 16\\}$。在真实重力信号中加入了标准差为 $\\sigma_{\\mathrm{true}} = 5 \\times 10^{-6}\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$ 的高斯噪声：\n$$\n\\mathbf{y}_{\\mathrm{obs}} = \\mathbf{G}\\boldsymbol{\\rho}_{\\mathrm{true}} + \\boldsymbol{\\varepsilon}_{\\mathrm{obs}}, \\quad \\boldsymbol{\\varepsilon}_{\\mathrm{obs}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_{\\mathrm{true}}^2 \\mathbf{I}_K)\n$$\n\nPPC 的核心在于将 $\\mathbf{y}_{\\mathrm{obs}}$ 与后验预测数据复制品 $\\mathbf{y}_{\\mathrm{rep}}$ 进行比较。我们首先定义一个检验统计量 $T(\\mathbf{y}, \\boldsymbol{\\rho})$，其设计旨在对空间失配敏感。选择了一个二次型：\n$$\nT(\\mathbf{y}, \\boldsymbol{\\rho}) = (\\mathbf{y} - \\mathbf{G}\\boldsymbol{\\rho})^\\top \\mathbf{W} (\\mathbf{y} - \\mathbf{G}\\boldsymbol{\\rho})\n$$\n矩阵 $\\mathbf{W} \\in \\mathbb{R}^{K \\times K}$ 是一个对称的观测核矩阵，它根据残差的空间邻近性对其进行加权，其元素为 $W_{kl} = \\exp\\left( - (x_k - x_l)^2 / (2 b^2) \\right)$，其中 $b=200\\,\\mathrm{m}$。根据定义，未归一化的迹 $\\sum_k W_{kk} = \\sum_k \\exp(0) = K$。因此，为确保 $\\mathrm{trace}(\\mathbf{W})=K$ 的指定归一化要求被自动满足，但为了程序的正确性，我们仍然执行了这一步。\n\nPPC 算法流程如下。对于三个测试案例中的每一个，我们为密度向量定义一个多元高斯后验分布的参数，$\\boldsymbol{\\rho} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$。后验均值 $\\boldsymbol{\\mu}$ 的结构与 $\\boldsymbol{\\rho}_{\\mathrm{true}}$ 相同，但可能具有不同的异常幅度 $\\mu_{\\mathrm{anom}}$。后验协方差矩阵 $\\boldsymbol{\\Sigma}$ 使用平方指数核和块金项进行建模：\n$$\n\\Sigma_{ij} = s^2 \\exp\\left(- \\frac{d_{ij}^2}{\\ell^2} \\right) + \\nu^2 \\delta_{ij}\n$$\n其中 $s=150\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$\\nu=50\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$d_{ij}$ 是单元中心 $i$ 和 $j$ 之间的欧几里得距离，$\\ell$ 是特定于案例的相关长度。\n\n对于每个测试案例，我们执行 $S=2000$ 次迭代：\n1.  从其后验分布中抽取一个密度向量样本 $\\boldsymbol{\\rho}^{(s)}$：$\\boldsymbol{\\rho}^{(s)} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$。\n2.  使用此参数样本计算观测数据的检验统计量：$T_{\\mathrm{obs}}^{(s)} = T(\\mathbf{y}_{\\mathrm{obs}}, \\boldsymbol{\\rho}^{(s)})$。\n3.  生成一个复制数据集 $\\mathbf{y}_{\\mathrm{rep}}^{(s)} = \\mathbf{G}\\boldsymbol{\\rho}^{(s)} + \\boldsymbol{\\varepsilon}^{(s)}$，其中 $\\boldsymbol{\\varepsilon}^{(s)} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_{\\mathrm{pred}}^2 \\mathbf{I}_K)$ 且 $\\sigma_{\\mathrm{pred}}$ 是特定于案例的。\n4.  计算复制数据的检验统计量：$T_{\\mathrm{rep}}^{(s)} = T(\\mathbf{y}_{\\mathrm{rep}}^{(s)}, \\boldsymbol{\\rho}^{(s)})$。这可以简化为 $T_{\\mathrm{rep}}^{(s)} = (\\boldsymbol{\\varepsilon}^{(s)})^\\top \\mathbf{W} \\boldsymbol{\\varepsilon}^{(s)}$。\n\n经过 $S$ 次迭代后，我们计算后验预测 p 值，即复制的统计量比观测的统计量更极端的次数所占的比例：\n$$\np = \\frac{1}{S} \\sum_{s=1}^S \\mathbb{I}\\left( T_{\\mathrm{rep}}^{(s)} \\ge T_{\\mathrm{obs}}^{(s)} \\right)\n$$\n最后，计算双边 p 值 $p_{\\mathrm{two}} = 2 \\min(p, 1-p)$。一个较低的 $p_{\\mathrm{two}}$（例如，低于阈值 $\\alpha=0.1$）表明模型无法生成与观测数据相似的数据，这暗示了模型设定错误。整个过程使用向量化的 `NumPy` 操作实现以提高效率。固定的随机种子确保了可复现性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a Posterior Predictive Check (PPC) for a 1D gravity inversion model.\n    \"\"\"\n    # Set a fixed random seed for reproducibility.\n    np.random.seed(42)\n\n    # 1. Setup Constants and Geometry\n    # Physical Constants\n    G_N = 6.67430e-11  # m^3 kg^-1 s^-2\n    \n    # Discretization and Geometry\n    DX = 100.0         # m\n    DZ = 100.0         # m\n    LY = 1000.0        # m\n    V = DX * DZ * LY   # m^3\n    K = 10             # Number of observation points\n    N = 20             # Number of subsurface cells\n\n    x_obs = np.arange(K) * DX\n    z_layers = np.array([50.0, 150.0])\n    \n    # Cell centers: N=20 cells, 10 per layer.\n    # Cells 0-9: z=50m; Cells 10-19: z=150m.\n    x_cell_coords = np.arange(K) * DX\n    cell_centers = np.zeros((N, 2))\n    cell_centers[:K, 0] = x_cell_coords\n    cell_centers[:K, 1] = z_layers[0]\n    cell_centers[K:, 0] = x_cell_coords\n    cell_centers[K:, 1] = z_layers[1]\n\n    # 2. Construct Forward Operator G\n    G = np.zeros((K, N))\n    for k in range(K):\n        for i in range(N):\n            xk = x_obs[k]\n            xi, zi = cell_centers[i, 0], cell_centers[i, 1]\n            denominator = ((xk - xi)**2 + zi**2)**1.5\n            G[k, i] = G_N * V * zi / denominator\n\n    # 3. Generate Synthetic Observed Data y_obs\n    rho_base = 2600.0\n    true_anomaly_amp = 200.0\n    \n    rho_true = np.full(N, rho_base)\n    # Anomaly in deeper layer (indices 10-19) at horizontal indices 3, 4, 5, 6\n    # corresponds to global indices 13, 14, 15, 16.\n    anomaly_indices = [13, 14, 15, 16]\n    rho_true[anomaly_indices] += true_anomaly_amp\n    \n    sigma_true = 5e-6\n    g_true = G @ rho_true\n    epsilon_obs = np.random.normal(0, sigma_true, size=K)\n    y_obs = g_true + epsilon_obs\n\n    # 4. Construct Observation-Kernel Matrix W\n    b = 200.0\n    W = np.zeros((K, K))\n    for k in range(K):\n        for l in range(K):\n            W[k, l] = np.exp(-((x_obs[k] - x_obs[l])**2) / (2 * b**2))\n    \n    # Renormalize W such that trace(W) = K as per instruction.\n    # Note: The trace of the original W is already K since diagonal elements are 1.\n    trace_W = np.trace(W)\n    if trace_W > 0:\n        W_norm = W * K / trace_W\n    else:\n        W_norm = W\n\n    # 5. Implement PPC for each Test Case\n    S = 2000\n    s_cov = 150.0\n    nu_cov = 50.0\n\n    # Pre-compute squared Euclidean distance matrix for covariance\n    dist_sq_matrix = np.sum((cell_centers[:, np.newaxis, :] - cell_centers[np.newaxis, :, :])**2, axis=-1)\n\n    test_cases = [\n        # Case A: ell, sigma_pred, mu_anom\n        {'ell': 150.0, 'sigma_pred': 5e-6, 'mu_anom': 180.0},\n        # Case B: ell, sigma_pred, mu_anom\n        {'ell': 150.0, 'sigma_pred': 1e-6, 'mu_anom': 180.0},\n        # Case C: ell, sigma_pred, mu_anom\n        {'ell': 500.0, 'sigma_pred': 5e-6, 'mu_anom': 50.0},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        ell, sigma_pred, mu_anom = case['ell'], case['sigma_pred'], case['mu_anom']\n        \n        # a. Define Posterior Distribution\n        mu_rho = np.full(N, rho_base)\n        mu_rho[anomaly_indices] += mu_anom\n        \n        Sigma = s_cov**2 * np.exp(-dist_sq_matrix / ell**2) + np.eye(N) * nu_cov**2\n\n        # b. Sample from Posterior\n        rho_samples = np.random.multivariate_normal(mu_rho, Sigma, size=S)\n        \n        # c. PPC Calculation (vectorized)\n        \n        # T_obs for each sample\n        g_preds = rho_samples @ G.T  # Shape: (S, K)\n        r_obs_all = y_obs - g_preds  # Shape: (S, K)\n        T_obs_all = np.sum((r_obs_all @ W_norm) * r_obs_all, axis=1)\n\n        # T_rep for each sample\n        eps_rep_all = np.random.normal(0, sigma_pred, size=(S, K))\n        T_rep_all = np.sum((eps_rep_all @ W_norm) * eps_rep_all, axis=1)\n\n        # d. Calculate p-value\n        p_val = np.sum(T_rep_all >= T_obs_all) / S\n        p_two_sided = 2 * min(p_val, 1-p_val)\n        \n        results.append(p_two_sided)\n\n    # Print final output in the required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}