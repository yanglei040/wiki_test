{
    "hands_on_practices": [
        {
            "introduction": "评估一个数值格式的第一步是理解其精度。截断误差分析是实现这一目标的标准方法，它通过泰勒展开将离散算子与原始偏微分方程进行比较。本练习将推导Lax-Wendroff格式的局部截断误差，这不仅能揭示其理论精度阶数，还能确定其主导误差项的性质，这对理解该格式在实际应用中的色散行为至关重要。",
            "id": "3603413",
            "problem": "在一维空间中，考虑具有恒定平流速度 $a0$ 的常系数线性平流方程 $u_{t} + a\\,u_{x} = 0$。设空间网格点为 $x_{j} = j\\,\\Delta x$，时间层级为 $t_{n} = n\\,\\Delta t$，库朗数定义为 $\\nu = a\\,\\Delta t / \\Delta x$。两步Lax-Wendroff格式以其标准的单步守恒形式实现：\n$$\nu_{j}^{n+1} \\;=\\; u_{j}^{n} \\;-\\; \\frac{a\\,\\Delta t}{2\\,\\Delta x}\\,\\Big(u_{j+1}^{n} - u_{j-1}^{n}\\Big) \\;+\\; \\frac{a^{2}\\,\\Delta t^{2}}{2\\,\\Delta x^{2}}\\,\\Big(u_{j+1}^{n} - 2\\,u_{j}^{n} + u_{j-1}^{n}\\Big).\n$$\n定义局部截断误差 $\\tau_{j}^{n}$ 为\n$$\n\\tau_{j}^{n} \\;=\\; \\frac{1}{\\Delta t}\\,\\Big(u(x_{j},t_{n+1}) \\;-\\; \\Big[u_{j}^{n} \\;-\\; \\frac{a\\,\\Delta t}{2\\,\\Delta x}\\,\\big(u_{j+1}^{n} - u_{j-1}^{n}\\big) \\;+\\; \\frac{a^{2}\\,\\Delta t^{2}}{2\\,\\Delta x^{2}}\\,\\big(u_{j+1}^{n} - 2\\,u_{j}^{n} + u_{j-1}^{n}\\big)\\Big]\\Big),\n$$\n其中 $u(x,t)$ 是偏微分方程的精确解。从偏微分方程和空间及时间的泰勒展开式出发，并利用偏微分方程消去时间导数，进行局部截断误差分析。证明 $\\tau_{j}^{n} = O(\\Delta t^{2}, \\Delta x^{2})$，并且当 $\\nu = O(1)$ 时，主导的色散项与 $\\Delta x^{2}\\,u_{xxx}$ 成正比。\n\n将您的最终答案报告为 $\\tau_{j}^{n}$ 的主导项中乘以 $\\Delta x^{2}\\,u_{xxx}$ 的系数 $C(a,\\nu)$，其定义如下：\n$$\n\\tau_{j}^{n} \\;=\\; C(a,\\nu)\\,\\Delta x^{2}\\,u_{xxx}(x_{j},t_{n}) \\;+\\; \\text{更高阶项}.\n$$\n您的最终答案必须是仅包含 $a$ 和 $\\nu$ 的单个封闭形式解析表达式。不需要进行数值计算，也不需要单位。",
            "solution": "该问题是有效的，因为它是偏微分方程数值分析领域中一个适定且有科学依据的问题。所有必要信息均已提供，目标明确。\n\n局部截断误差 $\\tau_{j}^{n}$ 是通过将有限差分算子应用于偏微分方程（PDE）的精确解 $u(x,t)$ 来定义的。给定的定义是\n$$\n\\tau_{j}^{n} = \\frac{1}{\\Delta t} \\left( u(x_{j}, t_{n+1}) - \\left[ u(x_{j},t_{n}) - \\frac{a\\,\\Delta t}{2\\,\\Delta x}\\left(u(x_{j+1},t_{n}) - u(x_{j-1},t_{n})\\right) + \\frac{a^{2}\\,\\Delta t^{2}}{2\\,\\Delta x^{2}}\\left(u(x_{j+1},t_{n}) - 2\\,u(x_j, t_n) + u(x_{j-1},t_{n})\\right) \\right] \\right)\n$$\n其中 $u(x,t)$ 是精确解，所有项都在指定的网格点上求值。为简单起见，我们将 $u(x_{j}, t_{n})$ 表示为 $u$，并将所有其他项在点 $(x_{j}, t_{n})$ 周围进行泰勒级数展开。关于 $x$ 和 $t$ 的偏导数将用下标表示，例如 $u_{x} = \\frac{\\partial u}{\\partial x}$ 和 $u_{t} = \\frac{\\partial u}{\\partial t}$，均在 $(x_j, t_n)$ 处求值。\n\n首先，我们将精确解项 $u(x_{j}, t_{n+1})$ 在 $t_{n}$ 周围按时间进行泰勒级数展开：\n$$\nu(x_{j}, t_{n+1}) = u(x_{j}, t_{n} + \\Delta t) = u + \\Delta t \\, u_{t} + \\frac{\\Delta t^{2}}{2} \\, u_{tt} + \\frac{\\Delta t^{3}}{6} \\, u_{ttt} + O(\\Delta t^{4})\n$$\n控制偏微分方程为 $u_{t} + a\\,u_{x} = 0$，即 $u_{t} = -a\\,u_{x}$。通过对偏微分方程反复求导，并假设 $u(x,t)$ 具有足够的光滑性，我们可以用空间导数来表示高阶时间导数：\n$$\nu_{t} = -a \\, u_{x}\n$$\n$$\nu_{tt} = \\frac{\\partial}{\\partial t}(-a\\,u_{x}) = -a\\,u_{xt} = -a\\,\\frac{\\partial}{\\partial x}(u_{t}) = -a\\,\\frac{\\partial}{\\partial x}(-a\\,u_{x}) = a^{2}\\,u_{xx}\n$$\n$$\nu_{ttt} = \\frac{\\partial}{\\partial t}(a^{2}\\,u_{xx}) = a^{2}\\,u_{xxt} = a^{2}\\,\\frac{\\partial^{2}}{\\partial x^{2}}(u_{t}) = a^{2}\\,\\frac{\\partial^{2}}{\\partial x^{2}}(-a\\,u_{x}) = -a^{3}\\,u_{xxx}\n$$\n将这些代回到 $u(x_{j}, t_{n+1})$ 的展开式中，得到：\n$$\nu(x_{j}, t_{n+1}) = u - a\\,\\Delta t\\,u_{x} + \\frac{a^{2}\\,\\Delta t^{2}}{2}\\,u_{xx} - \\frac{a^{3}\\,\\Delta t^{3}}{6}\\,u_{xxx} + O(\\Delta t^{4})\n$$\n\n接下来，我们分析误差表达式中的数值格式部分。我们需要 $u(x_{j\\pm 1}, t_{n})$ 在 $x_{j}$ 周围的空间泰勒级数展开：\n$$\nu(x_{j+1}, t_{n}) = u + \\Delta x\\,u_{x} + \\frac{\\Delta x^{2}}{2}\\,u_{xx} + \\frac{\\Delta x^{3}}{6}\\,u_{xxx} + \\frac{\\Delta x^{4}}{24}\\,u_{xxxx} + O(\\Delta x^{5})\n$$\n$$\nu(x_{j-1}, t_{n}) = u - \\Delta x\\,u_{x} + \\frac{\\Delta x^{2}}{2}\\,u_{xx} - \\frac{\\Delta x^{3}}{6}\\,u_{xxx} + \\frac{\\Delta x^{4}}{24}\\,u_{xxxx} + O(\\Delta x^{5})\n$$\n数值格式中的各项可以用这些展开式表示：\n一阶导数的中心差分：\n$$\nu(x_{j+1},t_{n}) - u(x_{j-1},t_{n}) = 2\\,\\Delta x\\,u_{x} + \\frac{\\Delta x^{3}}{3}\\,u_{xxx} + O(\\Delta x^{5})\n$$\n二阶导数的中心差分：\n$$\nu(x_{j+1},t_{n}) - 2\\,u(x_{j},t_{n}) + u(x_{j-1},t_{n}) = \\Delta x^{2}\\,u_{xx} + \\frac{\\Delta x^{4}}{12}\\,u_{xxxx} + O(\\Delta x^{6})\n$$\n令 $L_{\\Delta t}(u)$ 表示应用于精确解的数值算子：\n$$\nL_{\\Delta t}(u) = u - \\frac{a\\,\\Delta t}{2\\,\\Delta x}\\left(u(x_{j+1},t_{n}) - u(x_{j-1},t_{n})\\right) + \\frac{a^{2}\\,\\Delta t^{2}}{2\\,\\Delta x^{2}}\\left(u(x_{j+1},t_{n}) - 2\\,u(x_j, t_n) + u(x_{j-1},t_{n})\\right)\n$$\n代入空间展开式得到：\n$$\nL_{\\Delta t}(u) = u - \\frac{a\\,\\Delta t}{2\\,\\Delta x}\\left(2\\,\\Delta x\\,u_{x} + \\frac{\\Delta x^{3}}{3}\\,u_{xxx} + \\dots\\right) + \\frac{a^{2}\\,\\Delta t^{2}}{2\\,\\Delta x^{2}}\\left(\\Delta x^{2}\\,u_{xx} + \\frac{\\Delta x^{4}}{12}\\,u_{xxxx} + \\dots\\right)\n$$\n简化系数：\n$$\nL_{\\Delta t}(u) = u - a\\,\\Delta t\\,u_{x} - \\frac{a\\,\\Delta t\\,\\Delta x^{2}}{6}\\,u_{xxx} + \\frac{a^{2}\\,\\Delta t^{2}}{2}\\,u_{xx} + \\frac{a^{2}\\,\\Delta t^{2}\\,\\Delta x^{2}}{24}\\,u_{xxxx} + \\text{H.O.T.}\n$$\n其中 H.O.T. 代表高阶项。\n\n现在我们可以计算截断误差。根据定义，$\\Delta t\\,\\tau_{j}^{n} = u(x_{j}, t_{n+1}) - L_{\\Delta t}(u)$。\n$$\n\\Delta t\\,\\tau_{j}^{n} = \\left( u - a\\,\\Delta t\\,u_{x} + \\frac{a^{2}\\,\\Delta t^{2}}{2}\\,u_{xx} - \\frac{a^{3}\\,\\Delta t^{3}}{6}\\,u_{xxx} + \\dots \\right) - \\left( u - a\\,\\Delta t\\,u_{x} + \\frac{a^{2}\\,\\Delta t^{2}}{2}\\,u_{xx} - \\frac{a\\,\\Delta t\\,\\Delta x^{2}}{6}\\,u_{xxx} + \\dots \\right)\n$$\n正如二阶格式所预期的那样，直到二阶的项都相互抵消了：\n$$\n\\Delta t\\,\\tau_{j}^{n} = \\left( - \\frac{a^{3}\\,\\Delta t^{3}}{6}\\,u_{xxx} \\right) - \\left( - \\frac{a\\,\\Delta t\\,\\Delta x^{2}}{6}\\,u_{xxx} \\right) + \\text{H.O.T.}\n$$\n$$\n\\Delta t\\,\\tau_{j}^{n} = \\left( \\frac{a\\,\\Delta t\\,\\Delta x^{2}}{6} - \\frac{a^{3}\\,\\Delta t^{3}}{6} \\right) u_{xxx} + \\text{H.O.T.}\n$$\n除以 $\\Delta t$ 求 $\\tau_{j}^{n}$：\n$$\n\\tau_{j}^{n} = \\left( \\frac{a\\,\\Delta x^{2}}{6} - \\frac{a^{3}\\,\\Delta t^{2}}{6} \\right) u_{xxx} + \\text{H.O.T.}\n$$\n这证实了该格式是形式上二阶精度的，即 $\\tau_{j}^{n} = O(\\Delta x^{2}, \\Delta t^{2})$，因为如果 $\\Delta t \\propto \\Delta x$，两项都是 $O(\\Delta x^2)$。主导误差项与 $u_{xxx}$ 成正比，这是一个色散误差项。\n\n为了用 $a$ 和库朗数 $\\nu = a\\,\\Delta t/\\Delta x$ 表示系数，我们从主导项中提出因子 $\\frac{a\\,\\Delta x^{2}}{6}$：\n$$\n\\tau_{j}^{n} = \\frac{a\\,\\Delta x^{2}}{6} \\left( 1 - \\frac{a^{2}\\,\\Delta t^{2}}{\\Delta x^{2}} \\right) u_{xxx} + \\text{H.O.T.}\n$$\n注意到 $\\nu^{2} = (a\\,\\Delta t/\\Delta x)^{2} = a^{2}\\,\\Delta t^{2}/\\Delta x^{2}$，我们有：\n$$\n\\tau_{j}^{n} = \\frac{a\\,\\Delta x^{2}}{6} (1 - \\nu^{2}) u_{xxx} + \\text{H.O.T.}\n$$\n问题将主导误差项定义为 $C(a,\\nu)\\,\\Delta x^{2}\\,u_{xxx}(x_{j},t_{n})$。通过将此形式与我们推导的表达式进行比较，我们可以确定系数 $C(a,\\nu)$：\n$$\nC(a,\\nu)\\,\\Delta x^{2}\\,u_{xxx} = \\frac{a}{6} (1 - \\nu^{2}) \\Delta x^{2}\\,u_{xxx}\n$$\n因此，系数为：\n$$\nC(a,\\nu) = \\frac{a}{6}(1 - \\nu^{2})\n$$\n这就是所需的仅用 $a$ 和 $\\nu$ 表示的封闭形式解析表达式。当 $\\nu=1$ 时，误差为零，此时Lax-Wendroff格式对于常系数线性平流方程是精确的。",
            "answer": "$$\\boxed{\\frac{a}{6}(1 - \\nu^{2})}$$"
        },
        {
            "introduction": "除了精度，稳定性是数值格式的另一个关键属性。冯·诺依曼稳定性分析是一种强大的工具，用于研究格式如何放大或衰减不同的傅里叶模式（波数）。本练习聚焦于奈奎斯特频率，即网格能表示的最高频率，通过比较Lax-Friedrichs和Lax-Wendroff格式在这一频率下的放大因子，来揭示它们迥异的耗散特性，并解释为何一种格式可能在控制数值噪声方面更具优势。",
            "id": "3603414",
            "problem": "考虑一维线性平流方程 $u_{t} + a\\,u_{x} = 0$，其中波速 $a \\in \\mathbb{R}$ 为常数，定义在空间步长为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格上。定义库朗数 $C = a\\,\\Delta t / \\Delta x$。考虑两种经典的有限差分格式：\n\n- Lax-Friedrichs 格式：$u^{n+1}_{j} = \\tfrac{1}{2}\\left(u^{n}_{j+1} + u^{n}_{j-1}\\right) - \\tfrac{C}{2}\\left(u^{n}_{j+1} - u^{n}_{j-1}\\right)$。\n- Lax-Wendroff 格式：$u^{n+1}_{j} = u^{n}_{j} - \\tfrac{C}{2}\\left(u^{n}_{j+1} - u^{n}_{j-1}\\right) + \\tfrac{C^{2}}{2}\\left(u^{n}_{j+1} - 2\\,u^{n}_{j} + u^{n}_{j-1}\\right)$。\n\n使用 von Neumann 分析方法，对于傅里叶模 $u^{n}_{j} = \\hat{u}^{n}\\,\\exp\\left(\\mathrm{i}\\,j\\,\\theta\\right)$，重点关注由无量纲相位 $\\theta = \\pi$ 定义的奈奎斯特波数。比较两种格式在 $\\theta = \\pi$ 处的放大因子，并解释其对在相邻网格点之间符号交替的两倍网格间距振荡（棋盘模）的阻尼效应。选择一个选项，该选项正确陈述了在满足 $0  C \\leq 1$ 的允许库朗数范围内，两种格式在 $\\theta = \\pi$ 处的放大因子及其相应的阻尼行为。\n\nA. 对于 Lax-Friedrichs 格式，对所有 $C$ 都有 $|G(\\pi)| = 1$；而对于 Lax-Wendroff 格式，$G(\\pi) = 1 - 2\\,C^{2}$，因此当 $0  C  1$ 时 $|G(\\pi)|  1$。所以，除了在 $C = 1$ 时，Lax-Wendroff 格式会阻尼奈奎斯特模，而 Lax-Friedrichs 格式则不会。\n\nB. 两种格式都在一个时间步内消除奈奎斯特模，即对所有 $0  C \\leq 1$ 都有 $|G(\\pi)| = 0$；因此两者都强力阻尼棋盘模。\n\nC. 对于 Lax-Friedrichs 格式，对任何 $C \\neq 0$ 都有 $|G(\\pi)|  1$；而对于 Lax-Wendroff 格式，对所有 $0  C \\leq 1$ 都有 $|G(\\pi)| = 1$。因此，Lax-Friedrichs 格式会阻尼奈奎斯特模，而 Lax-Wendroff 格式则不会。\n\nD. 对于两种格式，在所有 $0  C \\leq 1$ 的情况下都有 $|G(\\pi)| = 1$；因此，在整个允许范围内，两种格式都不会阻尼棋盘模。\n\nE. 对于 Lax-Friedrichs 格式， $|G(\\pi)| = 1$；对于 Lax-Wendroff 格式，$G(\\pi) = -2\\,\\mathrm{i}\\,C$。因此，在奈奎斯特波数处，两者都是纯色散且非耗散的。",
            "solution": "用户希望对线性平流方程的两种有限差分格式进行详细分析，重点关注它们在奈奎斯特波数处的行为。\n\n### 问题验证\n问题陈述是有效的。它提出了一个偏微分方程数值分析中的标准问题。所有术语定义明确，物理和数学背景合理，问题是适定的，导向一个唯一的、可验证的解。未发现任何缺陷。\n\n### 推导\n\n问题要求分析一维线性平流方程 $u_t + a u_x = 0$ 的 Lax-Friedrichs 和 Lax-Wendroff 格式的放大因子。分析需使用 von Neumann 方法，并在对应于无量纲相位 $\\theta = \\pi$ 的奈奎斯特波数处进行。\n\n在 von Neumann 分析中，我们考虑解的单个傅里叶模 $u_j^n = \\hat{u}^n e^{\\mathrm{i}j\\theta}$，其中 $j$ 是空间网格指数，$n$ 是时间层级指数，$\\mathrm{i} = \\sqrt{-1}$，$\\theta = k\\Delta x$ 是无量纲波数（$k$ 是波数，$\\Delta x$ 是网格间距）。放大因子 $G(\\theta)$ 由关系式 $\\hat{u}^{n+1} = G(\\theta)\\hat{u}^n$ 定义，这意味着 $u_j^{n+1} = G(\\theta) u_j^n$。由此，我们也可以得到相邻点的关系：$u_{j\\pm 1}^n = \\hat{u}^n e^{\\mathrm{i}(j\\pm 1)\\theta} = e^{\\pm\\mathrm{i}\\theta} u_j^n$。我们将使用这些关系来推导每种格式的放大因子。\n\n对于给定的模 $\\theta$，如果 $|G(\\theta)|  1$，则格式是耗散的；如果 $|G(\\theta)| = 1$，则是非耗散的。奈奎斯特波数 $\\theta=\\pi$ 对应于网格上可分辨的最高频率，表现为 $e^{\\mathrm{i}j\\pi} = (-1)^j$ 形式的“棋盘”或“两倍网格间距”振荡。阻尼此模式通常是为了控制数值振荡。\n\n**1. Lax-Friedrichs 格式**\n\n该格式由下式给出：\n$$u^{n+1}_{j} = \\frac{1}{2}\\left(u^{n}_{j+1} + u^{n}_{j-1}\\right) - \\frac{C}{2}\\left(u^{n}_{j+1} - u^{n}_{j-1}\\right)$$\n其中 $C = a\\,\\Delta t / \\Delta x$ 是库朗数。\n\n代入傅里叶模关系式：\n$$G_{LF}(\\theta)u_j^n = \\frac{1}{2}\\left(e^{\\mathrm{i}\\theta}u_j^n + e^{-\\mathrm{i}\\theta}u_j^n\\right) - \\frac{C}{2}\\left(e^{\\mathrm{i}\\theta}u_j^n - e^{-\\mathrm{i}\\theta}u_j^n\\right)$$\n两边同除以 $u_j^n$（非零）得到放大因子 $G_{LF}(\\theta)$：\n$$G_{LF}(\\theta) = \\frac{1}{2}\\left(e^{\\mathrm{i}\\theta} + e^{-\\mathrm{i}\\theta}\\right) - \\frac{C}{2}\\left(e^{\\mathrm{i}\\theta} - e^{-\\mathrm{i}\\theta}\\right)$$\n使用欧拉恒等式 $\\cos(\\theta) = \\frac{1}{2}(e^{\\mathrm{i}\\theta} + e^{-\\mathrm{i}\\theta})$ 和 $\\sin(\\theta) = \\frac{1}{2\\mathrm{i}}(e^{\\mathrm{i}\\theta} - e^{-\\mathrm{i}\\theta})$，我们可以简化此表达式：\n$$G_{LF}(\\theta) = \\cos(\\theta) - \\frac{C}{2}(2\\mathrm{i}\\sin(\\theta)) = \\cos(\\theta) - \\mathrm{i}C\\sin(\\theta)$$\n现在，我们在奈奎斯特波数 $\\theta = \\pi$ 处计算该值：\n$$G_{LF}(\\pi) = \\cos(\\pi) - \\mathrm{i}C\\sin(\\pi) = -1 - \\mathrm{i}C(0) = -1$$\n在奈奎斯特波数处的放大因子的模为：\n$$|G_{LF}(\\pi)| = |-1| = 1$$\n这个结果与库朗数 $C$ 无关。由于模恰好为 1，Lax-Friedrichs 格式不阻尼奈奎斯特模。棋盘振荡的振幅保持不变，尽管由于 $G_{LF}(\\pi) = -1$，其符号在每个时间步都会翻转。\n\n**2. Lax-Wendroff 格式**\n\n该格式由下式给出：\n$$u^{n+1}_{j} = u^{n}_{j} - \\frac{C}{2}\\left(u^{n}_{j+1} - u^{n}_{j-1}\\right) + \\frac{C^{2}}{2}\\left(u^{n}_{j+1} - 2u^{n}_{j} + u^{n}_{j-1}\\right)$$\n代入傅里叶模关系式：\n$$G_{LW}(\\theta)u_j^n = u_j^n - \\frac{C}{2}\\left(e^{\\mathrm{i}\\theta}u_j^n - e^{-\\mathrm{i}\\theta}u_j^n\\right) + \\frac{C^{2}}{2}\\left(e^{\\mathrm{i}\\theta}u_j^n - 2u_j^n + e^{-\\mathrm{i}\\theta}u_j^n\\right)$$\n两边同除以 $u_j^n$：\n$$G_{LW}(\\theta) = 1 - \\frac{C}{2}\\left(e^{\\mathrm{i}\\theta} - e^{-\\mathrm{i}\\theta}\\right) + \\frac{C^{2}}{2}\\left(e^{\\mathrm{i}\\theta} - 2 + e^{-\\mathrm{i}\\theta}\\right)$$\n使用欧拉恒等式和恒等式 $e^{\\mathrm{i}\\theta} + e^{-\\mathrm{i}\\theta} - 2 = 2\\cos(\\theta) - 2$：\n$$G_{LW}(\\theta) = 1 - \\frac{C}{2}(2\\mathrm{i}\\sin(\\theta)) + \\frac{C^{2}}{2}(2\\cos(\\theta) - 2)$$\n$$G_{LW}(\\theta) = 1 - \\mathrm{i}C\\sin(\\theta) + C^2(\\cos(\\theta) - 1)$$\n现在，我们在奈奎斯特波数 $\\theta = \\pi$ 处计算该值：\n$$G_{LW}(\\pi) = 1 - \\mathrm{i}C\\sin(\\pi) + C^2(\\cos(\\pi) - 1) = 1 - \\mathrm{i}C(0) + C^2(-1 - 1) = 1 - 2C^2$$\n放大因子是实数。我们需要在指定范围 $0  C \\leq 1$ 内求其模。\n$$|G_{LW}(\\pi)| = |1 - 2C^2|$$\n我们来分析这个模的大小：\n- 如果 $C = 1$，$|G_{LW}(\\pi)| = |1 - 2(1)^2| = |-1| = 1$。在稳定性极限处，该格式是非耗散的。\n- 如果 $0  C  1$，那么 $0  C^2  1$ 且 $0  2C^2  2$。这得出 $-1  1 - 2C^2  1$。因此，对于 $0  C  1$，模严格小于 1：$|G_{LW}(\\pi)| = |1 - 2C^2|  1$。\n这意味着 Lax-Wendroff 格式是耗散的，并且在 $0  C  1$ 范围内的所有允许库朗数下都会阻尼奈奎斯特模。它仅在边界情况 $C=1$ 时不阻尼此模。\n\n### 逐项分析\n\n**A. 对于 Lax-Friedrichs 格式，对所有 $C$ 都有 $|G(\\pi)| = 1$；而对于 Lax-Wendroff 格式，$G(\\pi) = 1 - 2\\,C^{2}$，因此当 $0  C  1$ 时 $|G(\\pi)|  1$。所以，除了在 $C = 1$ 时，Lax-Wendroff 格式会阻尼奈奎斯特模，而 Lax-Friedrichs 格式则不会。**\n- 对于 Lax-Friedrichs 格式的陈述 $|G(\\pi)| = 1$ 是正确的。\n- 对于 Lax-Wendroff 格式的陈述 $G(\\pi) = 1 - 2C^2$ 是正确的。\n- 对于 Lax-Wendroff 格式，当 $0  C  1$ 时 $|G(\\pi)|  1$ 的推论是正确的。\n- 最终结论，即 Lax-Wendroff 格式会阻尼奈奎斯特模（除了在 $C=1$ 时），而 Lax-Friedrichs 格式则不会，这与我们的推导完全一致。\n- **结论：正确。**\n\n**B. 两种格式都在一个时间步内消除奈奎斯特模，即对所有 $0  C \\leq 1$ 都有 $|G(\\pi)| = 0$；因此两者都强力阻尼棋盘模。**\n- 这是不正确的。对于 Lax-Friedrichs 格式， $|G(\\pi)| = 1$，而不是 $0$。对于 Lax-Wendroff 格式，仅在特定值 $C = 1/\\sqrt{2}$ 时 $|G(\\pi)| = 0$，而不是对于该范围内的所有 $C$。\n- **结论：不正确。**\n\n**C. 对于 Lax-Friedrichs 格式，对任何 $C \\neq 0$ 都有 $|G(\\pi)|  1$；而对于 Lax-Wendroff 格式，对所有 $0  C \\leq 1$ 都有 $|G(\\pi)| = 1$。因此，Lax-Friedrichs 格式会阻尼奈奎斯特模，而 Lax-Wendroff 格式则不会。**\n- 这个陈述颠倒了两种格式的性质。我们的分析表明 $|G_{LF}(\\pi)|=1$ 且 $|G_{LW}(\\pi)| \\leq 1$（仅在 $C=1$ 时取等号）。\n- **结论：不正确。**\n\n**D. 对于两种格式，在所有 $0  C \\leq 1$ 的情况下都有 $|G(\\pi)| = 1$；因此，在整个允许范围内，两种格式都不会阻尼棋盘模。**\n- 这对于 Lax-Friedrichs 格式是正确的，但对于 Lax-Wendroff 格式是错误的，后者在 $0  C  1$ 时确实会阻尼该模态。\n- **结论：不正确。**\n\n**E. 对于 Lax-Friedrichs 格式， $|G(\\pi)| = 1$；对于 Lax-Wendroff 格式，$G(\\pi) = -2\\,\\mathrm{i}\\,C$。因此，在奈奎斯特波数处，两者都是纯色散且非耗散的。**\n- 对于 Lax-Friedrichs 格式的第一部分是正确的，$|G(\\pi)|=1$。\n- 对于 Lax-Wendroff 格式的第二部分是不正确的。我们推导出 $G_{LW}(\\pi) = 1 - 2C^2$，这是一个实数，而不是虚数值 $-2\\mathrm{i}C$。\n- **结论：不正确。**\n\n基于详细分析，只有选项 A 准确地描述了两种格式在奈奎斯特波数处的行为。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "最后的这个练习将理论与计算实践联系起来。理论分析中揭示的色散误差（来自截断误差分析）和对高频扰动的不良阻尼（来自冯·诺依曼分析）在实际模拟中会表现为“振铃”等数值伪影。本编码练习将指导你诊断这些问题，并实现谱滤波器——这是一种在保持精度的同时提高解质量的实用技术。",
            "id": "3603405",
            "problem": "考虑在周期性域 $x \\in [0,1]$ 上具有恒定平流速度 $a$ 的一维线性平流方程 $u_t + a u_x = 0$。目标是诊断 Lax–Wendroff 格式在粗网格上次网格特征的混叠现象，并提出和评估能够在保持空间二阶精度的同时最小化色散振铃的谱滤波器。\n\n基本原理：\n- 一维线性平流方程为 $u_t + a u_x = 0$，在 $[0,1]$ 上具有周期性边界条件。\n- Lax–Wendroff 有限差分格式通过时间上的泰勒级数和中心空间差分推导得出。\n- 离散傅里叶变换 (DFT) 和快速傅里叶变换 (FFT) 描述了均匀网格上离散信号的表示；奈奎斯特波数为 $k_{\\mathrm{N}} = \\pi/\\Delta x$，其中 $\\Delta x$ 是网格间距。\n- 当连续波数超过奈奎斯特极限时，会产生混叠。对于 $[0,1]$ 上的 $N$ 个点的离散网格，具有整数波数 $k^\\star$ 的模式会混叠到有符号整数索引 $k_{\\mathrm{alias}} = k^\\star - N \\cdot \\mathrm{round}(k^\\star/N)$，该索引位于区间 $[-N/2, N/2)$ 内。\n\n定义与要求：\n- 使用具有 $N$ 个点、间距为 $\\Delta x = 1/N$ 的均匀网格和周期性边界条件。\n- 使用恒定的库朗数 $\\lambda = a \\Delta t / \\Delta x$ 进行时间步进，为保证稳定性，$\\lambda \\in (0,1]$。\n- 实现 Lax–Wendroff 格式的单步时间推进：\n$$\nu_j^{n+1} = u_j^n - \\frac{\\lambda}{2}\\left(u_{j+1}^n - u_{j-1}^n\\right) + \\frac{\\lambda^2}{2}\\left(u_{j+1}^n - 2 u_j^n + u_{j-1}^n\\right).\n$$\n- 实现两种在每个时间步后应用的谱滤波器：\n  1. 指数滤波器，其传递函数为\n  $$\n  G_{\\exp}(k) = \\exp\\left(-\\alpha \\left|\\frac{k}{k_{\\max}}\\right|^m\\right),\n  $$\n  其中 $k$ 是离散波数，$k_{\\max}$ 是 $k$ 的最大幅值，$\\alpha  0$ 是强度参数，$m \\geq 2$ 是阶数（选择 $m$ 严格大于 2 以确保在低波数处失真可忽略并保持二阶精度）。\n  2. 带有截止波数 $k_c$ 的升余弦低通滤波器：\n  $$\n  G_{\\mathrm{rc}}(k) =\n  \\begin{cases}\n  1,  |k| \\leq k_c, \\\\\n  \\frac{1}{2}\\left[1 + \\cos\\left(\\pi \\frac{|k| - k_c}{k_{\\max} - k_c}\\right)\\right],  k_c  |k| \\leq k_{\\max}, \\\\\n  0,  \\text{otherwise},\n  \\end{cases}\n  $$\n  其中 $k_c = \\gamma k_{\\max}$，$0  \\gamma  1$。\n- 滤波器必须保持 $\\mathcal{O}(\\Delta x^2)$ 精度，这要求它们在小 $|k|$ 处与 1 的偏差为 $\\mathcal{O}\\left((k \\Delta x)^2\\right)$ 阶或更小。\n\n诊断与度量标准：\n- 混叠诊断：对于在粗网格上采样的信号 $u(x) = \\sin(2\\pi k^\\star x)$，验证其主要 DFT 峰值是否出现在预测的混叠整数波数 $k_{\\mathrm{alias}}$ 处；以布尔值（真为 $1.0$，假为 $0.0$）报告是否相等。\n- 振铃度量：对于在区间 $[x_0 - w, x_0 + w]$ 上 $u(x) = 1$ 且在别处 $u(x) = 0$ 的帽形初始条件（具有周期性边界），在平流时间 $T$ 后，计算过冲振幅\n$$\n\\delta_{\\mathrm{ring}} = \\max_j u_j^N - 1,\n$$\n其中 $u_j^N$ 是最终时刻的数值解，而精确解在平流后的帽形函数内部各处的振幅均为 $1$。较小的 $\\delta_{\\mathrm{ring}}$ 表示振铃较少。\n- 精度度量：对于光滑且良好解析的初始条件 $u(x) = \\sin(2\\pi k_0 x)$（其中 $k_0$ 低于奈奎斯特波数），平流一个周期 $T = 1/a$，此时精确解等于初始条件。计算离散 $\\ell^2$ 误差\n$$\nE = \\left(\\Delta x \\sum_{j=0}^{N-1} \\left(u_j^{\\mathrm{num}} - u_j^{\\mathrm{exact}}\\right)^2 \\right)^{1/2}\n$$\n并通过下式估计在网格尺寸 $N_1$ 和 $N_2$ 之间的观测精度阶\n$$\np_{\\mathrm{est}} = \\frac{\\log\\left(E_{N_1}/E_{N_2}\\right)}{\\log\\left(\\Delta x_{N_1}/\\Delta x_{N_2}\\right)}.\n$$\n\n测试套件：\n- 测试 1（粗网格上的混叠）：\n  - 域长度 $L = 1$，速度 $a = 1$，点数 $N = 32$，初始波数 $k^\\star = 20$。报告预测的混叠波数 $k_{\\mathrm{alias}}$ 是否等于主要 DFT 峰值（布尔值 $1.0$ 或 $0.0$）。\n- 测试 2（振铃抑制）：\n  - 域长度 $L = 1$，速度 $a = 1$，点数 $N = 64$，库朗数 $\\lambda = 0.8$，帽形函数中心 $x_0 = 0.25$，半宽 $w = 0.05$，最终时间 $T = 0.3$。报告以下情况的过冲振幅 $\\delta_{\\mathrm{ring}}$：\n    - 无滤波器。\n    - 指数滤波器，参数为 $\\alpha = 36$ 和 $m = 8$。\n    - 升余弦滤波器，参数为 $\\gamma = 0.7$。\n- 测试 3（精度缩放和二阶保持性）：\n  - 域长度 $L = 1$，速度 $a = 1$，库朗数 $\\lambda = 0.8$，光滑初始波数 $k_0 = 3$，最终时间 $T = 1$。使用 $N \\in \\{64, 128, 256\\}$。对于三种滤波器设置（无、指数滤波器 $\\alpha = 36, m = 8$、升余弦滤波器 $\\gamma = 0.7$），计算误差 $E_{64}$、$E_{128}$ 和 $E_{256}$，然后计算 $64 \\to 128$ 和 $128 \\to 256$ 之间的观测精度阶 $p_{\\mathrm{est}}$。\n  - 报告六个值：$p_{\\mathrm{est}}^{\\mathrm{none}}(64 \\to 128)$、$p_{\\mathrm{est}}^{\\mathrm{none}}(128 \\to 256)$、$p_{\\mathrm{est}}^{\\exp}(64 \\to 128)$、$p_{\\mathrm{est}}^{\\exp}(128 \\to 256)$、$p_{\\mathrm{est}}^{\\mathrm{rc}}(64 \\to 128)$ 和 $p_{\\mathrm{est}}^{\\mathrm{rc}}(128 \\to 256)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，顺序如下：\n  - 测试 1：一个布尔值（$1.0$ 或 $0.0$）。\n  - 测试 2：三个浮点数（无滤波器、指数滤波器、升余弦滤波器的过冲振幅）。\n  - 测试 3：六个浮点数（按规定顺序的精度阶）。\n- 总体结构示例：$[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8,r_9,r_{10}]$，其中 $r_1$ 是测试 1 的混叠布尔值，$r_2$–$r_4$ 是测试 2 的振铃度量值，$r_5$–$r_{10}$ 是测试 3 的精度阶。",
            "solution": "我们从周期性域上的一维线性平流方程 $u_t + a u_x = 0$ 开始。对于恒定速度 $a$，精确解会将初始条件平移而不改变其形状：$u(x,t) = u_0(x - a t)$，并对域长度取模。为了设计和分析高阶平流格式，我们依赖于空间离散化、时间离散化和傅里叶谱行为之间的关系。\n\nLax–Wendroff 格式的推导：\n从时间上的泰勒展开开始，\n$$\nu(x, t+\\Delta t) = u(x,t) + \\Delta t\\, u_t + \\frac{(\\Delta t)^2}{2} u_{tt} + \\mathcal{O}((\\Delta t)^3).\n$$\n根据偏微分方程 (PDE) $u_t = -a u_x$。再求一次导数得到 $u_{tt} = -a u_{xt} = -a(-a u_{xx}) = a^2 u_{xx}$，假设函数足够光滑。在间距为 $\\Delta x$ 的均匀网格上，用中心差分近似网格点 $x_j$ 处的 $u_x$ 和 $u_{xx}$，\n$$\nu_x(x_j, t) \\approx \\frac{u_{j+1}^n - u_{j-1}^n}{2 \\Delta x}, \\quad\nu_{xx}(x_j, t) \\approx \\frac{u_{j+1}^n - 2 u_j^n + u_{j-1}^n}{(\\Delta x)^2}.\n$$\n将其代入泰勒展开，并定义库朗数 $\\lambda = a \\Delta t / \\Delta x$，得到两步 Lax–Wendroff 格式：\n$$\nu_j^{n+1} = u_j^n - \\frac{\\lambda}{2}\\left(u_{j+1}^n - u_{j-1}^n\\right) + \\frac{\\lambda^2}{2}\\left(u_{j+1}^n - 2 u_j^n + u_{j-1}^n\\right).\n$$\n该格式在空间和时间上都是二阶精度的，并且在 $|\\lambda| \\leq 1$ 时是条件稳定的。\n\n傅里叶分析与混叠：\n对于具有 $N$ 个点和间距 $\\Delta x = 1/N$ 的周期性离散化，离散波数由离散傅里叶变换 (DFT) 产生的集合给出，相应的角波数为 $k = 2\\pi \\cdot \\mathrm{fftfreq}(N, \\Delta x)$。奈奎斯特波数为 $k_{\\mathrm{N}} = \\pi/\\Delta x$。当对一个连续模式 $u(x) = \\sin(2\\pi k^\\star x)$ 进行采样，且其整数波数 $k^\\star$ 超过 $N/2$ 时，会发生混叠，因为离散谱每 $N$ 个模式重复一次：\n$$\nk_{\\mathrm{alias}} = k^\\star - N \\cdot \\mathrm{round}\\left(\\frac{k^\\star}{N}\\right),\n$$\n这将 $k^\\star$ 映射到主区间 $[-N/2, N/2)$ 内。诊断方法是计算采样信号的 DFT 并识别其主峰；该峰值应出现在 $k_{\\mathrm{alias}}$ 处。\n\n谱滤波器与二阶精度保持：\n我们提出两种在每个时间步后于傅里叶空间中应用的滤波器：\n\n1. 指数滤波器。定义\n$$\nG_{\\exp}(k) = \\exp\\left(-\\alpha \\left|\\frac{k}{k_{\\max}}\\right|^m\\right),\n$$\n其中 $m \\geq 2$ 且 $\\alpha  0$。对于小波数，泰勒级数展开得到\n$$\nG_{\\exp}(k) = 1 - \\alpha \\left|\\frac{k}{k_{\\max}}\\right|^m + \\mathcal{O}\\left(\\left|\\frac{k}{k_{\\max}}\\right|^{2m}\\right).\n$$\n因为 $k_{\\max}$ 的量级为 $\\pi/\\Delta x$，所以在低 $|k|$ 处与 1 的偏差尺度为\n$$\n1 - G_{\\exp}(k) = \\mathcal{O}\\left((k \\Delta x)^m\\right).\n$$\n如果 $m \\geq 2$，滤波器对低波数的扰动最多为 $\\Delta x$ 的二阶，从而对于光滑解，能够保持 Lax–Wendroff 格式的二阶精度。\n\n2. 升余弦低通滤波器。定义\n$$\nG_{\\mathrm{rc}}(k) =\n\\begin{cases}\n1,  |k| \\leq k_c, \\\\\n\\frac{1}{2}\\left[1 + \\cos\\left(\\pi \\frac{|k| - k_c}{k_{\\max} - k_c}\\right)\\right],  k_c  |k| \\leq k_{\\max}, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中 $k_c = \\gamma k_{\\max}$，$0  \\gamma  1$。该滤波器保持所有低于截止频率的傅里叶模式不变（对于 $|k| \\leq k_c$，$G_{\\mathrm{rc}}(k) = 1$），确保了低波数处没有失真。平滑的衰减减少了接近 $k_{\\max}$ 的高波数内容，这些内容是导致吉布斯型振铃的原因。因为该滤波器在低波数带内是精确的单位映射，并且二阶格式的解误差主要由截断误差决定，其量级与 $(k \\Delta x)^2$ 相当，所以只要解在通带内得到良好的谱解析，升余弦滤波器就能保持二阶精度。\n\nLax–Wendroff 格式中的振铃现象：\nLax–Wendroff 格式是色散的。对于模式 $u_j^n = \\hat{u}^n e^{i j \\theta}$（其中 $\\theta = k \\Delta x$），其放大因子为\n$$\nA(\\theta) = 1 - i \\lambda \\sin\\theta - \\lambda^2(1 - \\cos\\theta).\n$$\n$A(\\theta)$ 的相角改变了相对于精确速度 $a$ 的相速度，而其实部在 $\\lambda \\neq 0$ 时引入了弱耗散。色散误差在不连续点附近引起振荡过冲（振铃），这让人联想到吉布斯现象。对接近 $k_{\\mathrm{N}}$ 的高波数进行阻尼的谱滤波可以减少这些振荡，同时保持已解析的尺度不变。\n\n算法设计：\n- 使用周期性数组移位实现 Lax–Wendroff 时间步。\n- 通过计算场的 FFT，乘以传递函数 $G(k)$，然后进行逆 FFT 返回物理空间，来实现灵活的谱滤波；取实部以抵消数值舍入误差。\n- 对于混叠，构建一个整数波数 $k^\\star  N/2$ 的高频模式，对其进行采样，并验证 FFT 的主峰是否出现在预测的混叠索引 $k_{\\mathrm{alias}}$ 处。\n- 对于振铃，使用具有尖锐边缘的帽形初始条件，并平流有限时间。测量过冲 $\\delta_{\\mathrm{ring}} = \\max u - 1$，比较无滤波器与滤波后的演化过程。\n- 对于精度，使用一个 $k_0$ 远低于奈奎斯特波数的光滑正弦模式 $u(x) = \\sin(2\\pi k_0 x)$，积分一个周期 $T = 1/a$，并计算在 $N = 64, 128, 256$ 时的 $\\ell^2$ 误差。通过误差和网格间距的对数比来估计观测到的精度阶 $p_{\\mathrm{est}}$。\n\n测试套件的设计选择：\n- 测试 1：选择 $N = 32$ 和 $k^\\star = 20$ 以确保 $k^\\star  N/2$ 从而产生混叠。预测的混叠波数为 $k_{\\mathrm{alias}} = 20 - 32 = -12$。\n- 测试 2：选择 $\\lambda = 0.8$ 和 $T = 0.3$ 以产生明显的色散波纹；指数滤波器使用 $\\alpha = 36$ 和 $m = 8$ 来强力阻尼近奈奎斯特模式，同时将低波数内容保持在 $\\mathcal{O}(\\Delta x^8)$ 的精度；升余弦滤波器使用 $\\gamma = 0.7$ 在 $k_{\\max}$ 的 $70\\%$ 处开始衰减。\n- 测试 3：选择 $k_0 = 3$ 以确保该模式在所有网格尺寸下都得到良好解析。计算在 $N = 64, 128, 256$ 时，无滤波器、指数滤波器和升余弦滤波器情况下的误差，并推导连续网格对之间的 $p_{\\mathrm{est}}$，以验证调整为最小化影响低波数行为的滤波器是否保持 $\\mathcal{O}(\\Delta x^2)$ 精度。\n\n数值单位与输出：\n- 所有输出均为无量纲浮点数；根据 FFT 的约定，角度在内部以弧度处理。\n- 最终要求的输出是单行文本，包含一个用方括号括起来的逗号分隔列表。条目按以下顺序排列：来自测试 1 的一个布尔值，来自测试 2 的三个浮点数，以及来自测试 3 的六个浮点数，总共 10 个条目。\n\n这种基于原理的设计整合了对混叠的傅里叶描述、Lax–Wendroff 格式的色散行为以及为保持二阶精度所需的滤波器传递函数约束，从而得出了一个关于混叠和振铃的全面计算诊断，并附有定量的精度评估。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lax_wendroff_step(u, a, dx, dt):\n    \"\"\"One time step of the Lax–Wendroff scheme on a periodic grid.\"\"\"\n    lam = a * dt / dx\n    u_plus = np.roll(u, -1)\n    u_minus = np.roll(u, 1)\n    return u - 0.5 * lam * (u_plus - u_minus) + 0.5 * (lam ** 2) * (u_plus - 2.0 * u + u_minus)\n\ndef exponential_filter(u, dx, alpha=36.0, m=8):\n    \"\"\"Apply an exponential spectral filter to u.\"\"\"\n    N = u.size\n    k = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)\n    kmax = np.max(np.abs(k))\n    if kmax == 0.0:\n        return u.copy()\n    G = np.exp(-alpha * (np.abs(k) / kmax) ** m)\n    uhat = np.fft.fft(u)\n    uhat_filtered = G * uhat\n    u_filtered = np.fft.ifft(uhat_filtered).real\n    return u_filtered\n\ndef raised_cosine_filter(u, dx, gamma=0.7):\n    \"\"\"Apply a raised-cosine low-pass spectral filter to u.\"\"\"\n    N = u.size\n    k = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)\n    kabs = np.abs(k)\n    kmax = np.max(kabs)\n    if kmax == 0.0:\n        return u.copy()\n    kc = gamma * kmax\n    G = np.ones_like(kabs)\n    mask = (kabs > kc)  (kabs = kmax)\n    # Smooth taper from kc to kmax\n    G[mask] = 0.5 * (1.0 + np.cos(np.pi * (kabs[mask] - kc) / (kmax - kc)))\n    # At exactly kmax, ensure zero to avoid wrap-around noise\n    G[kabs >= kmax] = 0.0\n    uhat = np.fft.fft(u)\n    uhat_filtered = G * uhat\n    u_filtered = np.fft.ifft(uhat_filtered).real\n    return u_filtered\n\ndef apply_filter(u, dx, ftype=None, params=None):\n    \"\"\"Dispatch filter application based on type.\"\"\"\n    if ftype is None:\n        return u\n    params = params or {}\n    if ftype == \"exp\":\n        return exponential_filter(u, dx, **params)\n    elif ftype == \"rc\":\n        return raised_cosine_filter(u, dx, **params)\n    else:\n        # Unknown filter type: no-op\n        return u\n\ndef simulate(u0_func, N, a, T, cfl, ftype=None, fparams=None):\n    \"\"\"Simulate advection using Lax–Wendroff with optional spectral filtering.\"\"\"\n    L = 1.0\n    x = np.linspace(0.0, L, N, endpoint=False)\n    dx = L / N\n    dt = cfl * dx / a\n    # Choose integer steps and adjust dt to hit T exactly\n    nsteps = max(1, int(np.ceil(T / dt)))\n    dt = T / nsteps\n    u = u0_func(x)\n    for _ in range(nsteps):\n        u = lax_wendroff_step(u, a, dx, dt)\n        u = apply_filter(u, dx, ftype, fparams)\n    return x, u\n\ndef aliasing_test(N, k_star):\n    \"\"\"Diagnose aliasing: return 1.0 if dominant DFT peak equals predicted alias index, else 0.0.\"\"\"\n    L = 1.0\n    dx = L / N\n    x = np.linspace(0.0, L, N, endpoint=False)\n    u = np.sin(2.0 * np.pi * k_star * x)\n    uhat = np.fft.fft(u)\n    # Dominant peak index (exclude zero mode to avoid trivial cases)\n    amps = np.abs(uhat)\n    # Zero-out DC if present to avoid dominating at k=0 for certain shapes\n    amps[0] = 0.0\n    k_peak_index = int(np.argmax(amps))\n    # Convert FFT index to signed integer wavenumber in [-N/2, N/2)\n    k_signed = k_peak_index if k_peak_index  N // 2 else k_peak_index - N\n    # Predicted alias\n    k_alias = int(round(k_star - N * round(k_star / N)))\n    return 1.0 if k_signed == k_alias else 0.0\n\ndef top_hat(x, center, halfwidth):\n    \"\"\"Top-hat initial condition with amplitude 1.\"\"\"\n    # Periodic interval handling: consider shortest periodic distance to center\n    L = 1.0\n    dx_periodic = np.minimum(np.abs(x - center), L - np.abs(x - center))\n    return (dx_periodic = halfwidth).astype(float)\n\ndef sine_ic(k0):\n    \"\"\"Smooth sinusoidal initial condition u(x) = sin(2*pi*k0*x).\"\"\"\n    def u0(x):\n        return np.sin(2.0 * np.pi * k0 * x)\n    return u0\n\ndef l2_error(u_num, u_exact, dx):\n    \"\"\"Discrete L2 norm of error.\"\"\"\n    return np.sqrt(dx * np.sum((u_num - u_exact) ** 2))\n\ndef exact_shift(u0_func, x, a, T):\n    \"\"\"Exact solution equals u0 shifted by a*T with periodic wraparound.\"\"\"\n    L = 1.0\n    shift = (x - a * T) % L\n    return u0_func(shift)\n\ndef ringing_metric(N, a, cfl, T, x0, w, filter_spec=None):\n    \"\"\"Compute overshoot above amplitude 1 for a top-hat advected for time T.\"\"\"\n    L = 1.0\n    x = np.linspace(0.0, L, N, endpoint=False)\n    u0 = top_hat(x, x0, w)\n    dx = L / N\n    dt = cfl * dx / a\n    nsteps = max(1, int(np.ceil(T / dt)))\n    dt = T / nsteps\n    u = u0.copy()\n    for _ in range(nsteps):\n        u = lax_wendroff_step(u, a, dx, dt)\n        if filter_spec is not None:\n            u = apply_filter(u, dx, filter_spec[\"type\"], filter_spec.get(\"params\", {}))\n    # Overshoot relative to exact amplitude 1 inside the advected top-hat\n    overshoot = float(np.max(u) - 1.0)\n    return overshoot\n\ndef accuracy_orders(a, cfl, T, k0, Ns, filters):\n    \"\"\"Compute observed orders between successive Ns for given filters.\"\"\"\n    orders = []\n    for f in filters:\n        errors = []\n        for N in Ns:\n            u0f = sine_ic(k0)\n            x, u_num = simulate(u0f, N, a, T, cfl, f.get(\"type\", None), f.get(\"params\", None))\n            dx = 1.0 / N\n            u_exact = exact_shift(u0f, x, a, T)\n            E = l2_error(u_num, u_exact, dx)\n            errors.append(E)\n        # Compute orders between successive Ns: (N1->N2), (N2->N3)\n        for i in range(len(Ns) - 1):\n            dx1 = 1.0 / Ns[i]\n            dx2 = 1.0 / Ns[i + 1]\n            E1 = errors[i]\n            E2 = errors[i + 1]\n            # Avoid log of zero: if E2 or E1 is zero, set order to a large number to indicate high convergence\n            if E1 > 0 and E2 > 0:\n                p_est = np.log(E1 / E2) / np.log(dx1 / dx2)\n            else:\n                p_est = float('inf')\n            orders.append(float(p_est))\n    return orders\n\ndef solve():\n    results = []\n    # Test 1: Aliasing on coarse grid\n    N_alias = 32\n    k_star = 20\n    alias_ok = aliasing_test(N_alias, k_star)\n    results.append(alias_ok)\n\n    # Test 2: Ringing suppression metrics\n    N_ring = 64\n    a = 1.0\n    cfl = 0.8\n    T_ring = 0.3\n    x0 = 0.25\n    w = 0.05\n    # No filter\n    ring_none = ringing_metric(N_ring, a, cfl, T_ring, x0, w, filter_spec=None)\n    results.append(ring_none)\n    # Exponential filter\n    ring_exp = ringing_metric(\n        N_ring, a, cfl, T_ring, x0, w,\n        filter_spec={\"type\": \"exp\", \"params\": {\"alpha\": 36.0, \"m\": 8}}\n    )\n    results.append(ring_exp)\n    # Raised-cosine filter\n    ring_rc = ringing_metric(\n        N_ring, a, cfl, T_ring, x0, w,\n        filter_spec={\"type\": \"rc\", \"params\": {\"gamma\": 0.7}}\n    )\n    results.append(ring_rc)\n\n    # Test 3: Accuracy scaling orders\n    Ns = [64, 128, 256]\n    T_acc = 1.0\n    k0 = 3\n    filters = [\n        {\"type\": None, \"params\": None},                  # None\n        {\"type\": \"exp\", \"params\": {\"alpha\": 36.0, \"m\": 8}},  # Exponential\n        {\"type\": \"rc\", \"params\": {\"gamma\": 0.7}},           # Raised-cosine\n    ]\n    orders = accuracy_orders(a, cfl, T_acc, k0, Ns, filters)\n    results.extend(orders)\n\n    # Final print statement in the exact required format.\n    # Ensure finite representation for 'inf' if it appears; but specs require floats, so we keep default.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}