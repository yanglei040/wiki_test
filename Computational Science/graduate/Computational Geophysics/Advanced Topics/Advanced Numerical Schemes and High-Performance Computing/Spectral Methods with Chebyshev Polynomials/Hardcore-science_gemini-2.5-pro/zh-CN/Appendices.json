{
    "hands_on_practices": [
        {
            "introduction": "我们将从最基本的任务开始：用切比雪夫多项式逼近一个光滑的解析函数。这个练习旨在巩固切比雪夫谱方法的核心机制——从节点生成到通过离散余弦变换（DCT）计算系数，并直观地展示谱方法对解析函数的指数收敛特性。掌握这项基本技能是利用谱方法强大功能的第一步。",
            "id": "3614946",
            "problem": "考虑使用第一类 Chebyshev 多项式在区间 $[-1,1]$ 上为解析函数 $f(x)=e^{x}$ 构建谱插值。这项任务代表了谱方法中的一个核心步骤，该方法在计算地球物理学中广泛用于光滑场（例如，分层速度剖面或温度分布）的高精度近似，其中 Chebyshev 展开为解析函数提供了指数收敛性。\n\n您必须从以下基本依据出发：\n- 第一类 Chebyshev 多项式 $\\{T_n(x)\\}_{n \\ge 0}$ 由关系式 $T_0(x)=1$，$T_1(x)=x$ 和递推式 $T_{n+1}(x)=2x\\,T_n(x)-T_{n-1}(x)$ 定义，等价地 $T_n(x)=\\cos(n\\arccos x)$。\n- Chebyshev–Lobatto 节点为 $x_j=\\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j=0,1,\\dots,N$，$N\\in\\mathbb{N}$，角度以弧度为单位。\n- 在 Chebyshev–Lobatto 节点上的逐点值 $\\{f(x_j)\\}$ 允许一种离散余弦表示，该表示可以通过第一类离散余弦变换 (DCT-I) 映射到 Chebyshev 系数，这利用了当端点取半权重时 $\\{\\cos(k\\theta)\\}$ 在网格 $\\theta_j=\\frac{\\pi j}{N}$ 上的离散正交性。\n\n您的目标是，从基本原理出发，实现从网格数据到 Chebyshev 插值的映射，并评估其准确性。具体而言：\n1. 对于给定的整数 $N\\geq 1$，构建 $N+1$ 个 Chebyshev–Lobatto 节点 $x_j=\\cos\\left(\\frac{\\pi j}{N}\\right)$ 并计算 $f(x)=e^x$ 的样本 $f_j=f(x_j)$。\n2. 使用第一类离散余弦变换 (DCT-I) 从 $\\{f_j\\}_{j=0}^{N}$ 计算 Chebyshev 插值系数 $\\{a_n\\}_{n=0}^{N}$。在重构插值时，您必须正确处理由 Chebyshev–Lobatto 节点上的离散正交性所隐含的端点半权重。\n3. 使用与 Chebyshev 多项式递推关系一致的数值稳定求和策略，在 $x=0.8$ 处计算插值 $P_N(x)$。仔细处理端点贡献，以使插值计算与节点上的插值条件相匹配。\n4. 估计在 $x=0.8$ 处的逐点误差为 $E_N=\\left|P_N(0.8)-e^{0.8}\\right|$。\n\n所有三角表达式中的角度度量必须是弧度。不涉及物理单位。\n\n测试套件：\n为以下 $N$ 值计算 $E_N$，以检验实现的不同方面：\n- 边界情况：$N=1$。\n- 小规模：$N=2$, $N=4$。\n- 中等规模：$N=10$, $N=20$。\n- 大规模以获得高精度和非2次幂覆盖：$N=64$, $N=127$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含七个误差值 $[E_{1},E_{2},E_{4},E_{10},E_{20},E_{64},E_{127}]$，格式为用方括号括起来的逗号分隔列表，以十进制形式（浮点数）表示。例如：“[0.1,0.01,0.001,0.0001,0.00001,1e-6,1e-7]”。您的程序必须完全自包含，无需用户输入，并使用 DCT-I 实现上述指定的计算以获得插值系数。",
            "solution": "目标是为解析函数 $f(x) = e^x$ 在区间 $[-1, 1]$ 上构建不同多项式次数 $N$ 的 Chebyshev 多项式插值，并在 $x=0.8$ 处评估该插值的逐点精度。该过程包括四个主要步骤：在 Chebyshev-Lobatto 节点上对函数进行采样，通过离散余弦变换 (DCT-I) 计算插值的 Chebyshev 系数，使用稳定算法计算所得的多项式和，以及计算近似误差。\n\n**第 1 步：Chebyshev-Lobatto 节点和函数采样**\n\n对于选定的多项式次数 $N \\in \\mathbb{N}$，构造插值函数以在 $N+1$ 个特定点上与函数 $f(x)$ 匹配。Chebyshev-Lobatto 节点是此目的的最佳选择，可最小化多项式插值中的 Runge 现象。这些节点是 Chebyshev 多项式 $T_N(x)$ 在区间 $[-1,1]$ 上的极值点。它们定义为：\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right) \\quad \\text{其中 } j = 0, 1, \\dots, N\n$$\n角度以弧度为单位。然后在这些 $N+1$ 个节点上对函数 $f(x) = e^x$ 进行采样，以获得数据点 $\\{f_j\\}_{j=0}^N$，其中 $f_j = f(x_j) = e^{x_j}$。\n\n**第 2 步：Chebyshev 系数的计算**\n\n次数为 $N$ 的 Chebyshev 插值多项式记为 $P_N(x)$。它可以表示为前 $N+1$ 个第一类 Chebyshev 多项式 $\\{T_n(x)\\}_{n=0}^N$ 的线性组合：\n$$\nP_N(x) = \\sum_{n=0}^{N} c_n T_n(x)\n$$\n插值条件为 $P_N(x_j) = f_j$，$j=0, \\dots, N$。这导出了一个关于系数 $\\{c_n\\}$ 的线性方程组。一种更直接且数值上更高效的求这些系数的方法是利用 Chebyshev 多项式与余弦函数之间的关系，$T_n(\\cos\\theta) = \\cos(n\\theta)$。将 $x_j = \\cos(\\frac{\\pi j}{N})$ 代入插值条件可得：\n$$\nf_j = \\sum_{n=0}^{N} c_n T_n(x_j) = \\sum_{n=0}^{N} c_n \\cos\\left(\\frac{n \\pi j}{N}\\right)\n$$\n这是一个有限离散余弦级数。可以通过利用余弦函数在网格点 $\\theta_j = \\frac{\\pi j}{N}$ 上的离散正交性来求得系数。插值的标准公式通常写成首尾基函数的贡献减半的形式：\n$$\nP_N(x) = \\sum_{n=0}^{N} {}^{'} a_n T_n(x) \\equiv \\frac{1}{2}a_0 T_0(x) + \\sum_{n=1}^{N-1} a_n T_n(x) + \\frac{1}{2}a_N T_N(x)\n$$\n相应的系数 $\\{a_n\\}$ 由一个离散变换给出：\n$$\na_n = \\frac{2}{N} \\sum_{j=0}^{N} {}^{''} f_j T_n(x_j) = \\frac{2}{N} \\sum_{j=0}^{N} {}^{''} f_j \\cos\\left(\\frac{n \\pi j}{N}\\right)\n$$\n其中求和符号上的双撇号表示 $j=0$ 和 $j=N$ 的项乘以 $\\frac{1}{2}$。这个求和与第一类离散余弦变换 (DCT-I) 直接相关。对于数据序列 $\\{f_j\\}_{j=0}^N$，DCT-I 定义为：\n$$\nY_n = f_0 + (-1)^n f_N + 2 \\sum_{j=1}^{N-1} f_j \\cos\\left(\\frac{n \\pi j}{N}\\right)\n$$\n通过观察可知，$a_n$ 公式中的和等于 $\\frac{1}{2}Y_n$。因此，系数为：\n$$\na_n = \\frac{2}{N} \\left(\\frac{1}{2} Y_n\\right) = \\frac{Y_n}{N}\n$$\n为了计算标准形式 $\\sum_{n=0}^N c_n T_n(x)$ 的多项式和，我们将 $c_n$ 设为每个基函数 $T_n(x)$ 的系数。从带撇号求和的公式中，我们有：\n$$\nc_0 = \\frac{1}{2}a_0 = \\frac{Y_0}{2N}, \\quad c_N = \\frac{1}{2}a_N = \\frac{Y_N}{2N}, \\quad \\text{以及} \\quad c_n = a_n = \\frac{Y_n}{N} \\quad \\text{对于 } 1 \\le n \\le N-1.\n$$\n这些系数 $\\{c_n\\}_{n=0}^N$ 将在求值步骤中使用。\n\n**第 3 步：通过 Clenshaw 算法进行稳定的多项式求值**\n\n要在指定点 $x = 0.8$ 处计算 $P_N(x) = \\sum_{n=0}^{N} c_n T_n(x)$，朴素的求和方法效率低下且可能数值不稳定。规定的稳定方法是 Clenshaw 算法，它利用了 Chebyshev 多项式的三项递推关系：对于 $n \\ge 1$，$T_{n+1}(x) = 2x T_n(x) - T_{n-1}(x)$。\n\n该算法按以下步骤计算和 $S$：\n1. 初始化两个变量，$u_{k+2} = 0$ 和 $u_{k+1} = 0$。\n2. 从 $k=N$ 向下迭代到 $k=0$：\n   $$ u_k = c_k + 2x u_{k+1} - u_{k+2} $$\n   在每一步中，旧的 $u_{k+1}$ 成为新的 $u_{k+2}$，旧的 $u_k$ 成为新的 $u_{k+1}$。\n3. 循环完成后，和的值由下式给出：\n   $$ P_N(x) = u_0 - x u_1 $$\n该算法避免了对 $T_n(x)$ 的显式计算，并且既高效（需要 $O(N)$ 次操作）又数值稳定。\n\n**第 4 步：误差估计**\n\n最后一步是量化插值的精度。在 $x=0.8$ 处的逐点误差 $E_N$ 计算为插值 $P_N(0.8)$ 与真实函数值 $f(0.8)$ 之间的绝对差：\n$$\nE_N = |P_N(0.8) - e^{0.8}|\n$$\n对测试套件中的每个 $N$ 值重复整个过程：$N \\in \\{1, 2, 4, 10, 20, 64, 127\\}$。随着 $N$ 的增加，谱方法对解析函数的指数收敛特性应该表现为 $E_N$ 的快速下降。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import dct\n\ndef solve():\n    \"\"\"\n    Computes the error of Chebyshev interpolation for f(x)=e^x at x=0.8\n    for a suite of polynomial degrees N.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 4, 10, 20, 64, 127]\n    \n    # The point at which to evaluate the interpolant and its error.\n    eval_point = 0.8\n    true_value = np.exp(eval_point)\n\n    results = []\n    \n    for N in test_cases:\n        # Step 1: Form the N+1 Chebyshev–Lobatto nodes and compute function samples.\n        # j is an array [0, 1, ..., N]\n        j = np.arange(N + 1)\n        # x_j = cos(pi*j/N)\n        nodes = np.cos(np.pi * j / N)\n        # f_j = f(x_j) = e^(x_j)\n        f_values = np.exp(nodes)\n\n        # Step 2: Compute the Chebyshev interpolant coefficients using DCT-I.\n        # The DCT-I of the function values {f_j} gives {Y_n}.\n        # Y_n = f_0 + (-1)^n f_N + 2 * sum_{j=1}^{N-1} f_j * cos(n*pi*j/N)\n        # The scipy.fft.dct function with type=1 computes exactly this.\n        dct_vals = dct(f_values, type=1)\n\n        # The coefficients {a_n} of the interpolant form P_N(x)=sum'{a_n T_n(x)}\n        # are a_n = Y_n / N.\n        # For evaluation with a standard sum P_N(x)=sum{c_n T_n(x)}, the\n        # coefficients are c_0 = a_0/2, c_N = a_N/2, and c_n = a_n otherwise.\n        # This is equivalent to scaling Y_0 and Y_N by 1/(2N) and other Y_n by 1/N.\n        \n        # Guard against division by zero if N=0, though not in test cases.\n        if N == 0:\n            # For N=0, P_0(x) is a constant f(x_0)=f(1)=e.\n            # In this special case, c_0 = f_0 = e. Error is |e - e^0.8|.\n            # This logic block is for completeness and not required by the test suite.\n            p_N_at_point = f_values[0]\n            error = np.abs(p_N_at_point - true_value)\n            results.append(error)\n            continue\n            \n        cheb_coeffs = dct_vals / N\n        cheb_coeffs[0] /= 2.0\n        cheb_coeffs[N] /= 2.0\n        \n        # Step 3: Evaluate the interpolant P_N(x) at x=0.8 using Clenshaw's algorithm.\n        # This evaluates the sum sum_{n=0 to N} c_n T_n(x).\n        u_k_plus_2 = 0.0\n        u_k_plus_1 = 0.0\n        # Iterate downwards from k=N to 0\n        for k in range(N, -1, -1):\n            # Recurrence: u_k = c_k + 2*x*u_{k+1} - u_{k+2}\n            u_k = cheb_coeffs[k] + 2.0 * eval_point * u_k_plus_1 - u_k_plus_2\n            # Update for next iteration\n            u_k_plus_2 = u_k_plus_1\n            u_k_plus_1 = u_k\n        \n        # The final value of the sum is u_0 - x*u_1\n        # At the end of the loop, u_k_plus_1 holds u_0 and u_k_plus_2 holds u_1.\n        p_N_at_point = u_k_plus_1 - eval_point * u_k_plus_2\n\n        # Step 4: Estimate the pointwise error at x=0.8.\n        error = np.abs(p_N_at_point - true_value)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从理想的光滑函数转向更贴近现实的场景，地球物理现象（如温跃层或示踪剂锋）常常包含陡峭的梯度。这些特征对简单的多项式逼近提出了挑战，并可能导致吉布斯振荡。本练习将介绍谱滤波这一关键技术，用以抑制这些非物理振荡，并探讨在抑制振荡与保持谱精度之间的重要权衡。",
            "id": "3614897",
            "problem": "考虑在区间 $[-1,1]$ 上的一个一维、无量纲化的陡峭锋面廓线，它代表了分层流体中示踪剂的浓度。设目标场为单调过渡函数\n$$\nf(x) = \\tfrac{1}{2}\\left(1 + \\tanh\\left(s\\,(x - x_0)\\right)\\right),\n$$\n其中 $s > 0$ 控制锋面的陡峭程度，$x_0 \\in (-1,1)$ 是锋面的位置。您将构建一个在 $[-1,1]$ 上的切比雪夫多项式逼近，对其切比雪夫系数应用一个 $8$ 阶指数滤波器，并量化振荡抑制与谱精度损失之间的权衡。\n\n从以下基础元素开始：\n- 第一类切比雪夫多项式 $\\{T_k(x)\\}_{k=0}^\\infty$ 满足 $T_k(\\cos \\theta) = \\cos(k\\theta)$，并且在 $[-1,1]$ 上关于权重 $w(x) = (1-x^2)^{-1/2}$ 正交。\n- 切比雪夫-洛巴托网格由节点 $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$ 定义，其中 $j=0,1,\\dots,N$。\n- $N$ 阶截断切比雪夫展开为\n$$\nu_N(x) = \\sum_{k=0}^N a_k T_k(x),\n$$\n其中系数 $\\{a_k\\}$ 是在切比雪夫内积下 $f$ 的精确正交投影系数的近似。\n\n您必须：\n1. 在切比雪夫-洛巴托节点 $\\{x_j\\}_{j=0}^N$ 上对 $f(x)$ 进行采样，以获得节点值 $\\{v_j\\}$。\n2. 计算与节点值 $\\{v_j\\}$ 相匹配的插值多项式的切比雪夫系数 $\\{a_k\\}_{k=0}^N$。\n3. 定义并对系数应用一个 $8$ 阶指数滤波器\n$$\n\\sigma_k = \\exp\\!\\left(-\\alpha \\left(\\frac{k}{N}\\right)^p\\right), \\quad p=8,\\quad \\sigma_0 = 1,\n$$\n并令滤波后的系数为 $\\{\\tilde{a}_k\\}$，其中 $\\tilde{a}_k = \\sigma_k a_k$。\n4. 在 $[-1,1]$ 区间内一个包含 $M$ 个点的均匀网格上，计算 $u_N(x)$ 和滤波后的逼近 $\\tilde{u}_N(x) = \\sum_{k=0}^N \\tilde{a}_k T_k(x)$。\n5. 通过超额总变差来量化振荡抑制，\n$$\n\\mathrm{ETV}(g) = \\sum_{i=0}^{M-2} \\left| g(x_{i+1}) - g(x_i) \\right| - \\left| g(x_{M-1}) - g(x_0) \\right|,\n$$\n在相同的均匀网格 $\\{x_i\\}_{i=0}^{M-1}$ 上对 $g=u_N$ 和 $g=\\tilde{u}_N$ 进行计算。\n6. 通过均匀网格上的相对离散 $L^2$ 误差来量化谱精度损失：\n$$\n\\varepsilon(g) = \\frac{\\left( \\frac{1}{M}\\sum_{i=0}^{M-1} \\left(g(x_i)-f(x_i)\\right)^2 \\right)^{1/2}}{\\left( \\frac{1}{M}\\sum_{i=0}^{M-1} f(x_i)^2 \\right)^{1/2}},\n$$\n对 $g=u_N$ 和 $g=\\tilde{u}_N$ 进行计算。\n\n实现要求：\n- 使用 $[-1,1]$ 区间内 $M=2001$ 个等距网格点来计算超额总变差和相对 $L^2$ 误差。\n- 使用切比雪夫-洛巴托节点计算系数，并从切比雪夫系数计算 $u_N$ 和 $\\tilde{u}_N$。\n- 按定义应用指数 $p=8$ 和参数 $\\alpha > 0$ 的 $8$ 阶滤波器。\n\n测试套件：\n对于下面的每一组参数 $(N,\\alpha,s,x_0)$，按顺序 $[\\mathrm{ETV}(u_N), \\mathrm{ETV}(\\tilde{u}_N), \\varepsilon(u_N), \\varepsilon(\\tilde{u}_N)]$ 计算并报告四个浮点数量。\n\n- 案例 A (通用): $N=128$, $\\alpha=36.0$, $s=40.0$, $x_0=0.2$。\n- 案例 B (弱滤波): $N=128$, $\\alpha=4.0$, $s=40.0$, $x_0=0.2$。\n- 案例 C (强滤波): $N=128$, $\\alpha=72.0$, $s=40.0$, $x_0=0.2$。\n- 案例 D (较粗分辨率，更陡峭的锋面): $N=64$, $\\alpha=36.0$, $s=80.0$, $x_0=0.2$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试案例贡献一个包含四个浮点数的子列表，顺序如上指定，例如：\n[[ETV_unf_A,ETV_flt_A,RelL2_unf_A,RelL2_flt_A],[ETV_unf_B,ETV_flt_B,RelL2_unf_B,RelL2_flt_B],...]\n确保输出只有一行，没有额外的文本或格式。不涉及物理单位；所有量均为无量纲实数。通过在切比雪夫节点中使用 $\\cos(\\cdot)$，所有角度在构造上都以弧度为单位。",
            "solution": "该问题要求构建和分析一个对陡峭锋面的切比雪夫多项式逼近，特别关注吉布斯现象及其通过谱滤波的缓解方法。在计算地球物理学和流体动力学等领域，陡峭界面（例如温跃层、示踪剂锋面）很常见，而这是一个在这些领域应用谱方法的典型问题。\n\n解决方案系统地遵循问题陈述中概述的步骤。\n\n1.  **离散化与函数采样**：需要逼近的函数是在定义域 $x \\in [-1, 1]$ 上的 $f(x) = \\tfrac{1}{2}\\left(1 + \\tanh\\left(s\\,(x - x_0)\\right)\\right)$。参数 $s > 0$ 控制梯度陡峭度，$x_0$ 是锋面的中心。我们通过在 $N+1$ 个切比雪夫-洛巴托节点上对函数 $f(x)$ 进行插值来构建一个 $N$ 阶的切比雪夫逼近。这些节点定义为 $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j=0, 1, \\dots, N$。它们是切比雪夫多项式 $T_N(x)$ 的极值点，并且是高阶插值的标准选择，因为它们在边界附近聚集，这有助于缓解光滑函数的龙格现象。采样值记为 $v_j = f(x_j)$。\n\n2.  **切比雪夫系数的计算**：切比雪夫插值多项式是一个多项式 $u_N(x) = \\sum_{k=0}^N a_k T_k(x)$，它满足对所有 $j=0, \\dots, N$ 都有 $u_N(x_j) = v_j$。系数 $\\{a_k\\}_{k=0}^N$ 由此条件唯一确定。可以使用I型离散余弦变换 (DCT-I) 高效地计算它们。系数由以下公式给出：\n    $$\n    a_k = \\frac{C_k}{N \\bar{c}_k}\n    $$\n    其中，当 $k=0$ 或 $k=N$ 时，$\\bar{c}_k = 2$；当 $1 \\le k \\le N-1$ 时，$\\bar{c}_k = 1$。项 $C_k$ 是将 DCT-I 应用于节点值向量 $[v_0, v_1, \\dots, v_N]$ 的结果：\n    $$\n    C_k = v_0 + (-1)^k v_N + 2 \\sum_{j=1}^{N-1} v_j \\cos\\left(\\frac{\\pi j k}{N}\\right)\n    $$\n    此计算使用 `scipy.fft.dct` 函数并设置 `type=1` 来实现。\n\n3.  **谱滤波**：$f(x)$ 中的陡峭梯度导致切比雪夫系数 $a_k$ 衰减缓慢，在阶数 $N$ 处对级数进行突兀截断会导致锋面附近出现吉布斯振荡。为了抑制这些非物理振荡，对系数应用了谱滤波器。指定的 $8$ 阶指数滤波器由以下滤波器函数定义：\n    $$\n    \\sigma_k = \\exp\\!\\left(-\\alpha \\left(\\frac{k}{N}\\right)^p\\right)\n    $$\n    其中阶数 $p=8$，强度参数 $\\alpha > 0$ 可调。滤波后的系数计算为 $\\tilde{a}_k = \\sigma_k a_k$，其中 $k=0, \\dots, N$。该滤波器平滑地衰减了主要导致吉布斯振荡的高波数系数（大的 $k$）。选择 $p=8$ 使得滤波器在 $k=0$ 附近非常平坦，而在 $k=N$ 附近非常陡峭，从而保留了捕捉函数主体结构的低波数模式，同时积极地抑制了高波数模式。条件 $\\sigma_0 = 1$ 自然地被公式满足，确保了逼近的平均值得以保留。由此产生的滤波后逼近为 $\\tilde{u}_N(x) = \\sum_{k=0}^N \\tilde{a}_k T_k(x)$。\n\n4.  **求值与分析**：未滤波的逼近 $u_N(x)$ 和滤波后的逼近 $\\tilde{u}_N(x)$ 都在一个横跨区间 $[-1, 1]$ 的、包含 $M=2001$ 个点的精细均匀网格上进行求值。求值过程通过 Clenshaw 算法高效执行，该算法在 `numpy.polynomial.chebyshev.chebval` 中可用。然后使用两个度量标准来量化每种逼近的性能：\n\n    a.  **超额总变差 (ETV)**：该度量标准量化了振荡的程度。对于一个完美的单调函数，其总变差等于其在端点处值的绝对差。ETV 是计算出的总变差与这个最小可能变差之间的差值：\n        $$\n        \\mathrm{ETV}(g) = \\left( \\sum_{i=0}^{M-2} \\left| g(x_{i+1}) - g(x_i) \\right| \\right) - \\left| g(x_{M-1}) - g(x_0) \\right|\n        $$\n        较低的 ETV 表示更好地抑制了振荡和更单调的廓线，这对于表示物理锋面是理想的。\n\n    b.  **相对离散 $L^2$ 误差**：该度量标准衡量了由截断和滤波共同导致的精度损失。它被定义为逼近 $g(x)$ 和真实函数 $f(x)$ 之间的均方根误差，并由 $f(x)$ 本身的均方根值进行归一化：\n        $$\n        \\varepsilon(g) = \\frac{\\left( \\frac{1}{M}\\sum_{i=0}^{M-1} \\left(g(x_i)-f(x_i)\\right)^2 \\right)^{1/2}}{\\left( \\frac{1}{M}\\sum_{i=0}^{M-1} f(x_i)^2 \\right)^{1/2}}\n        $$\n    未滤波的逼近 $u_N(x)$ 通常具有较低的 $L^2$ 误差但较高的 ETV。滤波旨在显著降低 ETV，代价是适度增加 $\\varepsilon$。参数 $\\alpha$ 控制了这种权衡：较大的 $\\alpha$ 会导致更强的滤波，更多的振荡抑制（较低的 ETV），但更大的精度损失（较高的 $\\varepsilon$）。\n\n提供的 Python 代码实现了这整个过程，遍历指定的测试案例，为每个参数集计算并报告所需的四个量 $[\\mathrm{ETV}(u_N), \\mathrm{ETV}(\\tilde{u}_N), \\varepsilon(u_N), \\varepsilon(\\tilde{u}_N)]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import dct\nfrom numpy.polynomial.chebyshev import chebval\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (general): N=128, alpha=36.0, s=40.0, x_0=0.2.\n        (128, 36.0, 40.0, 0.2),\n        # Case B (weak filter): N=128, alpha=4.0, s=40.0, x_0=0.2.\n        (128, 4.0, 40.0, 0.2),\n        # Case C (strong filter): N=128, alpha=72.0, s=40.0, x_0=0.2.\n        (128, 72.0, 40.0, 0.2),\n        # Case D (coarser resolution, sharper front): N=64, alpha=36.0, s=80.0, x_0=0.2.\n        (64, 36.0, 80.0, 0.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        result_case = analyze_approximation(*case)\n        results.append(result_case)\n\n    # Final print statement in the exact required format.\n    # Convert each sublist to its string representation and join with commas.\n    # Then enclose the whole thing in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef analyze_approximation(N, alpha, s, x0):\n    \"\"\"\n    Performs the Chebyshev approximation, filtering, and analysis for one case.\n\n    Args:\n        N (int): Degree of the Chebyshev expansion.\n        alpha (float): Strength of the exponential filter.\n        s (float): Sharpness parameter of the tanh front.\n        x0 (float): Location of the tanh front.\n\n    Returns:\n        list: A list of four floats: [ETV(u_N), ETV(u_N_tilde), ε(u_N), ε(u_N_tilde)].\n    \"\"\"\n    M = 2001  # Number of points for evaluation grid\n    p = 8     # Order of the exponential filter\n\n    # 1. Define grids\n    # Chebyshev-Lobatto nodes for coefficient computation\n    j_nodes = np.arange(N + 1)\n    x_nodes = np.cos(np.pi * j_nodes / N)\n\n    # Uniform grid for evaluation\n    x_eval = np.linspace(-1.0, 1.0, M)\n\n    # 2. Define and sample the target function\n    def target_function(x, s_param, x0_param):\n        return 0.5 * (1.0 + np.tanh(s_param * (x - x0_param)))\n\n    v_nodal_values = target_function(x_nodes, s, x0)\n    f_eval_values = target_function(x_eval, s, x0)\n\n    # 3. Compute Chebyshev coefficients using DCT-I\n    # C_k = dct(v, type=1)\n    C_k = dct(v_nodal_values, type=1)\n    \n    # Normalization factors for coefficients of sum_k a_k T_k(x)\n    c_bar = np.ones(N + 1)\n    c_bar[0] = 2.0\n    c_bar[N] = 2.0\n    \n    a_k = C_k / (N * c_bar)\n\n    # 4. Define and apply the 8th-order exponential filter\n    k_vals = np.arange(N + 1)\n    sigma_k = np.exp(-alpha * (k_vals / N)**p)\n    a_k_tilde = sigma_k * a_k\n\n    # 5. Evaluate unfiltered and filtered approximations on the uniform grid\n    u_N_eval = chebval(x_eval, a_k)\n    u_N_tilde_eval = chebval(x_eval, a_k_tilde)\n\n    # 6. Quantify oscillation and accuracy\n    # Excess Total Variation (ETV)\n    def calculate_etv(g_vals):\n        total_var = np.sum(np.abs(np.diff(g_vals)))\n        monotonic_var = np.abs(g_vals[-1] - g_vals[0])\n        return total_var - monotonic_var\n\n    etv_uN = calculate_etv(u_N_eval)\n    etv_uN_tilde = calculate_etv(u_N_tilde_eval)\n\n    # Relative discrete L2 error\n    def calculate_rel_l2_error(g_vals, f_true_vals):\n        l2_error_numerator = np.sqrt(np.mean((g_vals - f_true_vals)**2))\n        l2_norm_denominator = np.sqrt(np.mean(f_true_vals**2))\n        # Handle case where denominator is zero to avoid division by zero.\n        if l2_norm_denominator == 0.0:\n            return 0.0 if l2_error_numerator == 0.0 else np.inf\n        return l2_error_numerator / l2_norm_denominator\n\n    eps_uN = calculate_rel_l2_error(u_N_eval, f_eval_values)\n    eps_uN_tilde = calculate_rel_l2_error(u_N_tilde_eval, f_eval_values)\n    \n    return [etv_uN, etv_uN_tilde, eps_uN, eps_uN_tilde]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "本节练习将前面学习的技能应用于一个真实的地球物理问题，将理论与实践联系起来。我们将使用切比雪夫-伽辽金方法求解分层流体中的垂直模态问题，这是海洋学和大气科学中的一个核心Sturm-Liouville特征值问题。这个实践展示了如何构建和求解源于微分方程弱形式的广义特征值问题，这是谱方法在求解偏微分方程中的典型应用。",
            "id": "3614944",
            "problem": "考虑一个在静力学和长波极限下的分层 Boussinesq 流体的一维垂直模态问题，该问题在无量纲垂直区间 $z\\in[-1,1]$ 上表述。从标准的线性化静力平衡和浮力关系出发，可以得到一个关于垂直结构的 Sturm–Liouville 特征问题，其自伴随形式如下：\n$$\n-\\frac{d^2 \\phi}{dz^2} \\;=\\; \\lambda\\,N^2(z)\\,\\phi(z),\\qquad z\\in(-1,1),\n$$\n附带齐次 Dirichlet 边界条件：\n$$\n\\phi(-1)=0,\\qquad \\phi(1)=0.\n$$\n这里，$N^2(z)$ 是浮力频率的平方剖面，$\\lambda$ 是与斜压正规模相关的（非负）特征值。在本问题中，使用如下剖面：\n$$\nN^2(z)=N_0^2\\,(1+z),\n$$\n其中 $N_0>0$ 是一个常数。该问题在由 $N^2(z)$ 导出的加权 $L^2$ 内积中是适定的，并且算子在满足边界条件的函数子空间上是自伴随且正定的。任何三角表达式中使用的角度都必须是弧度制。\n\n您的任务是实现一个切比雪夫多项式 Galerkin 离散化方法，以近似求解该问题的前几个特征值和特征函数。请按以下步骤进行，除了下面列出的基本性质外，不要使用任何快捷公式。\n\n- 使用第一类切比雪夫多项式 $\\{T_n(z)\\}_{n\\ge 0}$ 作为初始基，并通过采用容许的试探和检验基来强制施加齐次 Dirichlet 边界条件：\n$$\n\\varphi_k(z) \\;=\\; T_k(z)\\;-\\;T_{k+2}(z),\\qquad k=0,1,\\dots,M-1,\n$$\n由于 $T_n(1)=1$ 且 $T_n(-1)=(-1)^n$，该基满足 $\\varphi_k(\\pm 1)=0$。\n- 使用通过分部积分和给定边界条件导出的弱（变分）形式：\n$$\n\\int_{-1}^{1}\\,\\varphi_i'(z)\\,\\varphi_j'(z)\\,dz \\;=\\; \\lambda\\;\\int_{-1}^{1} N^2(z)\\,\\varphi_i(z)\\,\\varphi_j(z)\\,dz,\\qquad i,j=0,\\dots,M-1.\n$$\n- 组装对称正定刚度矩阵 $A\\in\\mathbb{R}^{M\\times M}$ 和对称正定质量矩阵 $B\\in\\mathbb{R}^{M\\times M}$，其元素为：\n$$\nA_{ij} \\;=\\; \\int_{-1}^{1}\\,\\varphi_i'(z)\\,\\varphi_j'(z)\\,dz,\\qquad\nB_{ij} \\;=\\; \\int_{-1}^{1} N^2(z)\\,\\varphi_i(z)\\,\\varphi_j(z)\\,dz.\n$$\n- 通过求解广义对称特征值问题来恢复最小的特征对：\n$$\nA\\,\\mathbf{c} \\;=\\; \\lambda\\,B\\,\\mathbf{c}.\n$$\n- 仅使用以下基本多项式恒等式：$T_n(\\cos\\theta)=\\cos(n\\theta)$ 和 $\\dfrac{d}{dz}T_n(z) = n\\,U_{n-1}(z)$，其中 $U_n(\\cos\\theta)=\\dfrac{\\sin((n+1)\\theta)}{\\sin\\theta}$，$U_n$ 表示第二类切比雪夫多项式。角度 $\\theta$ 采用弧度制。\n\n算法要求：\n- 对于双线性形式的数值积分，使用在 $[-1,1]$ 上的任何适用于光滑被积函数的高阶精确求积法；一个合适的选择是使用 $Q$ 个点的 Gauss–Legendre 求积。确保 $Q$ 相对于 $M$ 足够大以避免积分不足。\n- 在求积节点上计算 $T_n(z)$ 和 $U_n(z)$ 时，使用上述的余弦和正弦表示。通过使用不包括端点的求积节点来避免任何除以零的情况。\n- 在内部使用时，以任何一致的方式对特征函数进行归一化；最终报告的量仅为特征值。\n\n测试套件：\n为以下每个参数集 $(N_0,M,Q)$ 计算三个最小的特征值：\n- 情况 1：$N_0=1.0$, $M=24$, $Q=200$。\n- 情况 2：$N_0=2.0$, $M=24$, $Q=200$。\n- 情况 3：$N_0=1.0$, $M=8$, $Q=120$。\n- 情况 4：$N_0=0.5$, $M=24$, $Q=200$。\n\n输出规范：\n- 对于每种情况，将计算出的特征值按升序排序，并取前三个。将每个值四舍五入到 $8$ 位小数。\n- 您的程序应生成单行输出，其中包含按上述情况顺序排列的、以逗号分隔的列表的列表形式的结果。例如，它应如下所示：\n$[ [\\lambda_{1}^{(1)},\\lambda_{2}^{(1)},\\lambda_{3}^{(1)}], [\\lambda_{1}^{(2)},\\lambda_{2}^{(2)},\\lambda_{3}^{(2)}], [\\lambda_{1}^{(3)},\\lambda_{2}^{(3)},\\lambda_{3}^{(3)}], [\\lambda_{1}^{(4)},\\lambda_{2}^{(4)},\\lambda_{3}^{(4)}] ]$。\n只打印这一行；不要打印任何其他文本。\n\n注意：\n- 上述公式作为一个自伴随加权特征问题是普遍适用的。它通过使用等效的自伴随形式 $-\\,\\phi''=\\lambda\\,N^2\\phi$ 和 Dirichlet 边界条件，避免了在 $z=-1$ 处的任何奇异系数，这与标准静力斜压模态方程的 Liouville 变换是一致的。\n- 三角函数内部使用的所有角度都必须是弧度制。",
            "solution": "所提出的问题是一个适定的 Sturm-Liouville 特征值问题，这是地球物理流体动力学中研究分层流体垂直模态的基础。该问题在科学上合理、内容自洽且数学上明确。因此，我将提供一个完整的解法。\n\n垂直结构函数 $\\phi(z)$ 的控制方程为：\n$$\n-\\frac{d^2 \\phi}{dz^2} = \\lambda\\,N^2(z)\\,\\phi(z),\n$$\n定义在域 $z \\in (-1, 1)$ 上，并服从齐次 Dirichlet 边界条件 $\\phi(-1) = 0$ 和 $\\phi(1) = 0$。浮力频率的平方剖面是深度的线性函数，$N^2(z) = N_0^2\\,(1+z)$。\n\n我们旨在使用 Chebyshev-Galerkin 谱方法找到最小的特征值 $\\lambda$。该方法的核心是将问题投影到一个有限维函数空间上，该空间由一组满足问题边界条件的基函数张成。\n\n首先，将微分方程转换为其弱形式或变分形式。我们将方程乘以一个来自合适空间的检验函数 $v(z)$，并在整个域上积分：\n$$\n-\\int_{-1}^{1} v(z) \\frac{d^2 \\phi}{dz^2} dz = \\lambda \\int_{-1}^{1} v(z) N^2(z) \\phi(z) dz.\n$$\n对左侧应用分部积分，得到：\n$$\n\\left[ -v(z) \\frac{d\\phi}{dz} \\right]_{-1}^{1} + \\int_{-1}^{1} \\frac{dv}{dz} \\frac{d\\phi}{dz} dz = \\lambda \\int_{-1}^{1} v(z) N^2(z) \\phi(z) dz.\n$$\n在 Galerkin 方法中，检验函数 $v(z)$ 与解 $\\phi(z)$ 的试探（基）函数选自同一空间。问题指定了满足边界条件的试探函数，因此我们要求 $v(\\pm 1) = 0$。这使得边界项 $\\left[ -v(z) \\frac{d\\phi}{dz} \\right]_{-1}^{1}$ 消失，从而得到弱形式：\n$$\n\\int_{-1}^{1} v'(z) \\phi'(z) dz = \\lambda \\int_{-1}^{1} v(z) \\phi(z) N^2(z) dz.\n$$\n\n解 $\\phi(z)$ 通过 $M$ 个基函数 $\\varphi_j(z)$ 的有限展开来近似：\n$$\n\\phi(z) \\approx \\phi_M(z) = \\sum_{j=0}^{M-1} c_j \\varphi_j(z),\n$$\n其中 $c_j$ 是未知系数。指定的基函数由第一类切比雪夫多项式 $T_n(z)$ 构造而成，形式为：\n$$\n\\varphi_k(z) = T_k(z) - T_{k+2}(z), \\quad k=0, 1, \\dots, M-1.\n$$\n由于 $T_n(1)=1$ 和 $T_n(-1)=(-1)^n$，这些函数满足 $\\varphi_k(\\pm 1) = 0$，确保了 $T_k(\\pm 1) = T_{k+2}(\\pm 1)$，从而将边界条件正确地并入近似空间中。\n\n将 $\\phi_M(z)$ 的展开式代入弱形式，并选择基函数本身作为检验函数，即 $v(z) = \\varphi_i(z)$（对于 $i=0, 1, \\dots, M-1$），我们得到一个包含 $M$ 个线性方程的系统：\n$$\n\\sum_{j=0}^{M-1} c_j \\left( \\int_{-1}^{1} \\varphi_i'(z) \\varphi_j'(z) dz \\right) = \\lambda \\sum_{j=0}^{M-1} c_j \\left( \\int_{-1}^{1} N^2(z) \\varphi_i(z) \\varphi_j(z) dz \\right).\n$$\n该系统表示为一个广义对称矩阵特征值问题：\n$$\nA \\mathbf{c} = \\lambda B \\mathbf{c},\n$$\n其中 $\\mathbf{c} = [c_0, c_1, \\dots, c_{M-1}]^T$ 是系数向量，刚度矩阵 $A$ 和质量矩阵 $B$ 的元素为：\n$$\nA_{ij} = \\int_{-1}^{1} \\varphi_i'(z) \\varphi_j'(z) dz,\n$$\n$$\nB_{ij} = \\int_{-1}^{1} N^2(z) \\varphi_i(z) \\varphi_j(z) dz = N_0^2 \\int_{-1}^{1} (1+z) \\varphi_i(z) \\varphi_j(z) dz.\n$$\n\n这些矩阵的元素通过数值求积计算。我们采用具有 $Q$ 个点 $\\{z_q\\}_{q=0}^{Q-1}$ 和相应权重 $\\{w_q\\}_{q=0}^{Q-1}$ 的 Gauss-Legendre 求积法在区间 $[-1, 1]$ 上进行计算。因此，矩阵元素近似为：\n$$\nA_{ij} \\approx \\sum_{q=0}^{Q-1} w_q \\varphi_i'(z_q) \\varphi_j'(z_q),\n$$\n$$\nB_{ij} \\approx N_0^2 \\sum_{q=0}^{Q-1} w_q (1+z_q) \\varphi_i(z_q) \\varphi_j(z_q).\n$$\n\n为了在求积节点上计算基函数及其导数，我们使用指定的三角恒等式。通过代换 $z = \\cos\\theta$，我们有 $\\theta = \\arccos(z)$。求积节点 $z_q$ 严格位于 $(-1, 1)$ 内，因此 $\\theta_q = \\arccos(z_q)$ 在 $(0, \\pi)$ 内有良好定义。\n基函数使用 $T_n(\\cos\\theta) = \\cos(n\\theta)$ 进行计算：\n$$\n\\varphi_k(z_q) = T_k(\\cos\\theta_q) - T_{k+2}(\\cos\\theta_q) = \\cos(k\\theta_q) - \\cos((k+2)\\theta_q).\n$$\n导数使用 $\\frac{d}{dz}T_n(z) = n U_{n-1}(z)$ 和 $U_n(\\cos\\theta) = \\frac{\\sin((n+1)\\theta)}{\\sin\\theta}$ 求得：\n$$\n\\varphi_k'(z) = k U_{k-1}(z) - (k+2) U_{k+1}(z).\n$$\n在节点 $z_q=\\cos\\theta_q$ 处计算，这变为：\n$$\n\\varphi_k'(z_q) = k \\frac{\\sin(k\\theta_q)}{\\sin\\theta_q} - (k+2) \\frac{\\sin((k+2)\\theta_q)}{\\sin\\theta_q}.\n$$\n由于 $\\theta_q \\in (0, \\pi)$，分母 $\\sin\\theta_q$ 非零。\n\n组装好矩阵 $A$ 和 $B$ 后，广义特征值问题 $A \\mathbf{c} = \\lambda B \\mathbf{c}$ 进行数值求解。由于 $A$ 和 $B$ 是对称且正定的，可以使用专门且稳定的算法。得到的特征值 $\\lambda$ 是连续问题真实特征值的近似值。我们按升序对这些值进行排序，并按要求选择最小的三个。\n\n值得注意的是常数 $N_0$ 的作用。质量矩阵 $B$ 与 $N_0^2$ 成正比。因此，特征值 $\\lambda$ 与 $N_0^2$ 成反比。这意味着如果我们计算出 $N_0=1.0$ 时的特征值 $\\lambda_{N_0=1}$，那么对于任何其他 $N_0$，其特征值由 $\\lambda_{N_0} = \\lambda_{N_0=1} / N_0^2$ 给出。这种物理上的缩放关系为数值结果提供了一个有价值的一致性检验。\n\n实现过程首先计算 Gauss-Legendre 求积节点和权重。然后，对于给定的 $M$，在这些节点上计算所有基函数及其导数的值并存储。这些值用于通过向量化操作高效地组装矩阵 $A$ 和 $B$。最后，使用标准科学计算库（例如 SciPy）中的广义特征求解器来计算特征值。对问题陈述中指定的每个测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to solve the eigenvalue problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N0, M, Q)\n        (1.0, 24, 200),\n        (2.0, 24, 200),\n        (1.0, 8, 120),\n        (0.5, 24, 200),\n    ]\n\n    all_results = []\n    for N0, M, Q in test_cases:\n        eigenvalues = compute_eigenvalues(N0, M, Q)\n        # Select the three smallest eigenvalues and round them.\n        smallest_three = np.round(eigenvalues[:3], 8).tolist()\n        all_results.append(smallest_three)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list of lists adds spaces inside inner lists,\n    # which matches the problem's symbolic example. The join operation specified in the\n    # template code produces a slightly different whitespace pattern. We construct the\n    # string carefully to match the template's specified join logic.\n    inner_list_strings = [str(res) for res in all_results]\n    print(f\"[{','.join(inner_list_strings)}]\")\n\n\ndef compute_eigenvalues(N0, M, Q):\n    \"\"\"\n    Computes the eigenvalues for a single case (N0, M, Q).\n    \n    Args:\n        N0 (float): Buoyancy frequency constant.\n        M (int): Number of basis functions (size of discretization).\n        Q (int): Number of Gauss-Legendre quadrature points.\n\n    Returns:\n        np.ndarray: An array of computed eigenvalues, sorted in ascending order.\n    \"\"\"\n    # Step 1: Get Gauss-Legendre quadrature nodes and weights for the interval [-1, 1].\n    z_nodes, w_weights = np.polynomial.legendre.leggauss(Q)\n\n    # Step 2: Evaluate basis functions phi_k and their derivatives dphi_k/dz at the nodes.\n    phi_vals, dphi_vals = evaluate_basis_functions(M, z_nodes)\n\n    # Step 3: Assemble the stiffness (A) and mass (B) matrices.\n    # A_ij = integral(phi'_i * phi'_j, dz)\n    # B_ij = integral(N^2 * phi_i * phi_j, dz)\n    \n    # Efficient assembly using vectorized operations.\n    # This is equivalent to dphi_vals @ np.diag(w_weights) @ dphi_vals.T\n    A = dphi_vals @ (dphi_vals * w_weights).T\n\n    # Buoyancy frequency squared N^2(z) = N0^2 * (1 + z) evaluated at nodes.\n    N2_on_nodes = N0**2 * (1 + z_nodes)\n    \n    # This is equivalent to phi_vals @ np.diag(w_weights * N2_on_nodes) @ phi_vals.T\n    B = phi_vals @ (phi_vals * (w_weights * N2_on_nodes)).T\n\n    # Step 4: Solve the generalized symmetric eigenvalue problem A c = lambda B c.\n    # eigh returns eigenvalues in ascending order, which is what we need.\n    eigenvalues = eigh(A, B, eigvals_only=True)\n    \n    return eigenvalues\n\n\ndef evaluate_basis_functions(M, z_nodes):\n    \"\"\"\n    Evaluates Chebyshev-based trial functions and their derivatives at quadrature nodes.\n    The basis functions are phi_k(z) = T_k(z) - T_{k+2}(z).\n    \n    Args:\n        M (int): Number of basis functions.\n        z_nodes (np.ndarray): Quadrature nodes in [-1, 1].\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: \n            - phi_vals (M x Q): Values of basis functions at nodes.\n            - dphi_vals (M x Q): Values of basis function derivatives at nodes.\n    \"\"\"\n    Q = len(z_nodes)\n    \n    # Use the transformation z = cos(theta)\n    # Note: z_nodes from leggauss are in (-1, 1), so arccos is well-defined in (0, pi).\n    theta_nodes = np.arccos(z_nodes)\n    sin_theta = np.sin(theta_nodes) # This will not be zero.\n    \n    # Array of basis indices: k = 0, 1, ..., M-1\n    k = np.arange(M).reshape(-1, 1)\n\n    # Evaluate phi_k(z) = T_k(z) - T_{k+2}(z) using T_n(cos(theta)) = cos(n*theta).\n    # Broadcasting k (M,1) with theta_nodes (Q,) -> (M,Q)\n    T_k = np.cos(k * theta_nodes)\n    T_k_plus_2 = np.cos((k + 2) * theta_nodes)\n    phi_vals = T_k - T_k_plus_2\n    \n    # Evaluate d(phi_k)/dz = k*U_{k-1}(z) - (k+2)*U_{k+1}(z)\n    # using U_{n-1}(cos(theta)) = sin(n*theta)/sin(theta).\n    \n    # Term 1: k*U_{k-1}(z) -> k*sin(k*theta)/sin(theta)\n    # For k=0, the numerator is sin(0)=0, so the term is 0, which is correct.\n    dphi_term1 = k * np.sin(k * theta_nodes) / sin_theta\n    \n    # Term 2: (k+2)*U_{k+1}(z) -> (k+2)*sin((k+2)*theta)/sin(theta)\n    dphi_term2 = (k + 2) * np.sin((k + 2) * theta_nodes) / sin_theta\n    \n    dphi_vals = dphi_term1 - dphi_term2\n    \n    return phi_vals, dphi_vals\n\n# The entry point of the script.\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}