{
    "hands_on_practices": [
        {
            "introduction": "函数逼近是谱方法的核心。这项练习将带你亲手构建一个切比雪夫插值多项式，这是处理光滑函数时一种非常精确的工具。你将学习如何利用切比雪夫-洛巴托节点进行采样，并通过计算效率极高的离散余弦变换（DCT）来确定谱系数，从而深入理解切比雪夫谱方法的运作机制。",
            "id": "3614946",
            "problem": "考虑在区间 $[-1,1]$ 上使用第一类 Chebyshev 多项式为解析函数 $f(x)=e^{x}$ 构建一个谱插值。该任务是谱方法中的一个核心步骤的代表，谱方法在计算地球物理学中被广泛用于高精度近似光滑场（例如，分层速度剖面或温度分布），其中 Chebyshev 展开为解析函数提供了指数收敛性。\n\n您必须从以下基本基础出发：\n- 第一类 Chebyshev 多项式 $\\{T_n(x)\\}_{n \\ge 0}$ 由关系式 $T_0(x)=1$、$T_1(x)=x$ 和递推式 $T_{n+1}(x)=2x\\,T_n(x)-T_{n-1}(x)$ 定义，等价地有 $T_n(x)=\\cos(n\\arccos x)$。\n- Chebyshev–Lobatto 节点为 $x_j=\\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j=0,1,\\dots,N$，$N\\in\\mathbb{N}$，角度以弧度为单位。\n- 在 Chebyshev–Lobatto 节点上的逐点值 $\\{f(x_j)\\}$ 允许一种离散余弦表示，当端点取半权重时，可以利用 $\\{\\cos(k\\theta)\\}$ 在网格 $\\theta_j=\\frac{\\pi j}{N}$ 上的离散正交性，通过第一类离散余弦变换 (DCT-I) 将其映射到 Chebyshev 系数。\n\n您的目标是，从第一性原理出发，实现从网格数据到 Chebyshev 插值多项式的映射，并评估其精度。具体而言：\n1. 对于给定的整数 $N\\geq 1$，构建 $N+1$ 个 Chebyshev–Lobatto 节点 $x_j=\\cos\\left(\\frac{\\pi j}{N}\\right)$，并计算函数 $f(x)=e^x$ 的样本值 $f_j=f(x_j)$。\n2. 使用第一类离散余弦变换 (DCT-I)，从 $\\{f_j\\}_{j=0}^{N}$ 计算 Chebyshev 插值系数 $\\{a_n\\}_{n=0}^{N}$。在重构插值多项式时，您必须正确处理由 Chebyshev–Lobatto 节点上的离散正交性所隐含的端点半权重。\n3. 使用与 Chebyshev 多项式递推关系一致的数值稳定求和策略，在 $x=0.8$ 处计算插值多项式 $P_N(x)$ 的值。请仔细处理端点贡献，以确保插值多项式的求值结果在节点上满足插值条件。\n4. 将 $x=0.8$ 处的逐点误差估计为 $E_N=\\left|P_N(0.8)-e^{0.8}\\right|$。\n\n所有三角表达式中的角度度量单位必须是弧度。不涉及任何物理单位。\n\n测试套件：\n计算以下 $N$ 值的 $E_N$，以检验实现的不同方面：\n- 边界情况：$N=1$。\n- 小尺寸：$N=2$，$N=4$。\n- 中等尺寸：$N=10$，$N=20$。\n- 用于高精度和非2次幂覆盖的大尺寸：$N=64$，$N=127$。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含七个误差值 $[E_{1},E_{2},E_{4},E_{10},E_{20},E_{64},E_{127}]$，形式为用方括号括起来的逗号分隔列表，以十进制形式（浮点数）表示。例如：“[0.1,0.01,0.001,0.0001,0.00001,1e-6,1e-7]”。您的程序必须是完全自包含的，无需用户输入，并按照上述规定使用 DCT-I 实现计算以获得插值系数。",
            "solution": "目标是针对不同的多项式阶数 $N$，为区间 $[-1, 1]$ 上的解析函数 $f(x) = e^x$ 构建 Chebyshev 多项式插值，并在 $x=0.8$ 处评估该插值的逐点精度。该过程涉及四个主要步骤：在 Chebyshev-Lobatto 节点上对函数进行采样，通过离散余弦变换 (DCT-I) 计算插值的 Chebyshev 系数，使用稳定算法计算所得多项式和，以及计算近似误差。\n\n**步骤1：Chebyshev-Lobatto 节点和函数采样**\n\n对于选定的多项式阶数 $N \\in \\mathbb{N}$，构建的插值多项式会在 $N+1$ 个特定点上与函数 $f(x)$ 匹配。Chebyshev-Lobatto 节点是实现此目的的最佳选择，它能最小化多项式插值中的 Runge 现象。这些节点是 Chebyshev 多项式 $T_N(x)$ 在区间 $[-1,1]$ 上的极值点。其定义如下：\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right) \\quad \\text{for } j = 0, 1, \\dots, N\n$$\n角度以弧度为单位。然后在这 $N+1$ 个节点上对函数 $f(x) = e^x$ 进行采样，以获得数据点 $\\{f_j\\}_{j=0}^N$，其中 $f_j = f(x_j) = e^{x_j}$。\n\n**步骤2：计算 Chebyshev 系数**\n\n$N$ 阶 Chebyshev 插值多项式记为 $P_N(x)$。它可以表示为前 $N+1$ 个第一类 Chebyshev 多项式 $\\{T_n(x)\\}_{n=0}^N$ 的线性组合：\n$$\nP_N(x) = \\sum_{n=0}^{N} c_n T_n(x)\n$$\n插值条件为 $P_N(x_j) = f_j$，其中 $j=0, \\dots, N$。这会导出一个关于系数 $\\{c_n\\}$ 的线性方程组。一种更直接且数值上更高效的求这些系数的方法是利用 Chebyshev 多项式与余弦函数之间的联系：$T_n(\\cos\\theta) = \\cos(n\\theta)$。将 $x_j = \\cos(\\frac{\\pi j}{N})$ 代入插值条件，得到：\n$$\nf_j = \\sum_{n=0}^{N} c_n T_n(x_j) = \\sum_{n=0}^{N} c_n \\cos\\left(\\frac{n \\pi j}{N}\\right)\n$$\n这是一个有限离散余弦级数。可以通过利用余弦函数在网格点 $\\theta_j = \\frac{\\pi j}{N}$ 上的离散正交性来求得系数。插值多项式的标准形式通常写成第一个和最后一个基函数的贡献减半的形式：\n$$\nP_N(x) = \\sum_{n=0}^{N} {}^{'} a_n T_n(x) \\equiv \\frac{1}{2}a_0 T_0(x) + \\sum_{n=1}^{N-1} a_n T_n(x) + \\frac{1}{2}a_N T_N(x)\n$$\n相应的系数 $\\{a_n\\}$ 由一个离散变换给出：\n$$\na_n = \\frac{2}{N} \\sum_{j=0}^{N} {}^{''} f_j T_n(x_j) = \\frac{2}{N} \\sum_{j=0}^{N} {}^{''} f_j \\cos\\left(\\frac{n \\pi j}{N}\\right)\n$$\n其中求和符号上的双撇号表示 $j=0$ 和 $j=N$ 的项乘以 $\\frac{1}{2}$。这个求和与第一类离散余弦变换 (DCT-I) 直接相关。对于一个数据序列 $\\{f_j\\}_{j=0}^N$，DCT-I 定义为：\n$$\nY_n = f_0 + (-1)^n f_N + 2 \\sum_{j=1}^{N-1} f_j \\cos\\left(\\frac{n \\pi j}{N}\\right)\n$$\n经观察可知，$a_n$ 公式中的求和等于 $\\frac{1}{2}Y_n$。因此，系数为：\n$$\na_n = \\frac{2}{N} \\left(\\frac{1}{2} Y_n\\right) = \\frac{Y_n}{N}\n$$\n为了计算标准形式的多项式和 $\\sum_{n=0}^N c_n T_n(x)$，我们设 $c_n$ 为每个基函数 $T_n(x)$ 的系数。从带撇号的求和形式中，我们有：\n$$\nc_0 = \\frac{1}{2}a_0 = \\frac{Y_0}{2N}, \\quad c_N = \\frac{1}{2}a_N = \\frac{Y_N}{2N}, \\quad \\text{and} \\quad c_n = a_n = \\frac{Y_n}{N} \\quad \\text{for } 1 \\le n \\le N-1.\n$$\n这些系数 $\\{c_n\\}_{n=0}^N$ 将在求值步骤中使用。\n\n**步骤3：通过 Clenshaw 算法进行稳定的多项式求值**\n\n为了在指定点 $x = 0.8$ 处计算 $P_N(x) = \\sum_{n=0}^{N} c_n T_n(x)$，朴素的求和方法效率低下且可能数值不稳定。指定的稳定方法是 Clenshaw 算法，它利用了 Chebyshev 多项式的三项递推关系：$T_{n+1}(x) = 2x T_n(x) - T_{n-1}(x)$（对于 $n \\ge 1$）。\n\n该算法按以下步骤计算和 $S$：\n1. 初始化两个变量，$u_{k+2} = 0$ 和 $u_{k+1} = 0$。\n2. 从 $k=N$ 向下迭代到 $k=0$：\n   $$ u_k = c_k + 2x u_{k+1} - u_{k+2} $$\n   在每一步中，旧的 $u_{k+1}$ 成为新的 $u_{k+2}$，旧的 $u_k$ 成为新的 $u_{k+1}$。\n3. 循环完成后，和的值由下式给出：\n   $$ P_N(x) = u_0 - x u_1 $$\n该算法避免了对 $T_n(x)$ 的显式计算，并且既高效（需要 $O(N)$ 次操作）又数值稳定。\n\n**步骤4：误差估计**\n\n最后一步是量化插值的精度。在 $x=0.8$ 处的逐点误差 $E_N$ 计算为插值 $P_N(0.8)$ 与函数真值 $f(0.8)$ 之间的绝对差：\n$$\nE_N = |P_N(0.8) - e^{0.8}|\n$$\n对测试套件中的每个 $N$ 值（$N \\in \\{1, 2, 4, 10, 20, 64, 127\\}$）重复整个过程。随着 $N$ 的增加，$E_N$ 的快速下降应能体现出谱方法对解析函数的指数收敛特性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import dct\n\ndef solve():\n    \"\"\"\n    Computes the error of Chebyshev interpolation for f(x)=e^x at x=0.8\n    for a suite of polynomial degrees N.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 4, 10, 20, 64, 127]\n    \n    # The point at which to evaluate the interpolant and its error.\n    eval_point = 0.8\n    true_value = np.exp(eval_point)\n\n    results = []\n    \n    for N in test_cases:\n        # Step 1: Form the N+1 Chebyshev–Lobatto nodes and compute function samples.\n        # j is an array [0, 1, ..., N]\n        j = np.arange(N + 1)\n        # x_j = cos(pi*j/N)\n        nodes = np.cos(np.pi * j / N)\n        # f_j = f(x_j) = e^(x_j)\n        f_values = np.exp(nodes)\n\n        # Step 2: Compute the Chebyshev interpolant coefficients using DCT-I.\n        # The DCT-I of the function values {f_j} gives {Y_n}.\n        # Y_n = f_0 + (-1)^n f_N + 2 * sum_{j=1}^{N-1} f_j * cos(n*pi*j/N)\n        # The scipy.fft.dct function with type=1 computes exactly this.\n        dct_vals = dct(f_values, type=1)\n\n        # The coefficients {a_n} of the interpolant form P_N(x)=sum'{a_n T_n(x)}\n        # are a_n = Y_n / N.\n        # For evaluation with a standard sum P_N(x)=sum{c_n T_n(x)}, the\n        # coefficients are c_0 = a_0/2, c_N = a_N/2, and c_n = a_n otherwise.\n        # This is equivalent to scaling Y_0 and Y_N by 1/(2N) and other Y_n by 1/N.\n        \n        # Guard against division by zero if N=0, though not in test cases.\n        if N == 0:\n            # For N=0, P_0(x) is a constant f(x_0)=f(1)=e.\n            # In this special case, c_0 = f_0 = e. Error is |e - e^0.8|.\n            # This logic block is for completeness and not required by the test suite.\n            p_N_at_point = f_values[0]\n            error = np.abs(p_N_at_point - true_value)\n            results.append(error)\n            continue\n            \n        cheb_coeffs = dct_vals / N\n        cheb_coeffs[0] /= 2.0\n        cheb_coeffs[N] /= 2.0\n        \n        # Step 3: Evaluate the interpolant P_N(x) at x=0.8 using Clenshaw's algorithm.\n        # This evaluates the sum sum_{n=0 to N} c_n T_n(x).\n        u_k_plus_2 = 0.0\n        u_k_plus_1 = 0.0\n        # Iterate downwards from k=N to 0\n        for k in range(N, -1, -1):\n            # Recurrence: u_k = c_k + 2*x*u_{k+1} - u_{k+2}\n            u_k = cheb_coeffs[k] + 2.0 * eval_point * u_k_plus_1 - u_k_plus_2\n            # Update for next iteration\n            u_k_plus_2 = u_k_plus_1\n            u_k_plus_1 = u_k\n        \n        # The final value of the sum is u_0 - x*u_1\n        # At the end of the loop, u_k_plus_1 holds u_0 and u_k_plus_2 holds u_1.\n        p_N_at_point = u_k_plus_1 - eval_point * u_k_plus_2\n\n        # Step 4: Estimate the pointwise error at x=0.8.\n        error = np.abs(p_N_at_point - true_value)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了函数逼近，切比雪夫多项式在数值积分领域也扮演着至关重要的角色。这项练习旨在引导你推导并实现高斯-切比雪夫求积法则，这是一种用于计算带权积分的高精度方法。通过这个过程，你将体会到正交多项式的优美特性如何转化为强大而高效的数值算法，这对于处理谱方法中的积分项至关重要。",
            "id": "3614882",
            "problem": "考虑带第一类切比雪夫权重的加权积分，定义为\n$$\nI \\equiv \\int_{-1}^{1} \\frac{\\ln(1+x)}{\\sqrt{1-x^2}} \\, dx.\n$$\n您的任务是从谱方法与切比雪夫多项式的基本原理出发，构建一个完整的推导和算法，从而使用第一类高斯-切比雪夫求积法对此积分进行数值稳定且精确的近似。然后，计算数值估计值并与解析值进行比较。\n\n基本依据和要求：\n- 使用第一类切比雪夫多项式的定义关系：对于任意整数 $k \\ge 0$，$T_k(x) = \\cos(k \\arccos x)$，其中 $x \\in [-1,1]$。\n- 使用切比雪夫多项式在 $[-1,1]$ 上关于权重 $w(x) = (1-x^2)^{-1/2}$ 的正交性。\n- 仅使用以下事实：与给定权重的正交多项式相关的高斯求积法则，在使用 $n$ 个节点时，能够对所有次数最高为 $2n-1$ 的多项式进行精确积分。不要假定节点或权重的具体公式；请推导它们。\n- 在需要时使用角度代换 $x=\\cos\\theta$，其中 $\\theta \\in [0,\\pi]$。所有角度必须以弧度处理。\n\nA 部分（推导）：\n1. 从定义 $T_k(x) = \\cos(k \\arccos x)$ 和代换 $x=\\cos\\theta$ 出发，推导 $T_k$ 在 $[-1,1]$ 上关于权重 $w(x) = (1-x^2)^{-1/2}$ 的正交性。然后，通过将加权积分转换为 $\\theta$ 变量下的非加权积分，并确定相应的求积节点和权重，从第一性原理推导出 $n$ 点第一类高斯-切比雪夫求积法。用仅依赖于 $n$ 的节点 $x_k$ 和权重 $w_k$ 明确表示结果，并指明角度以弧度为单位。\n2. 通过适当的变量代换和已知的对数-三角函数积分，求出积分 $I$ 的解析闭式解。\n\nB 部分（算法设计与数值实验）：\n1. 基于您推导出的求积节点和权重，设计一个数值稳定的算法来对给定的 $n$ 近似 $I$。通过为 $\\ln(1+x)$ 设计适当的求值策略，解决在 $x=-1$ 附近的浮点数敏感性问题。\n2. 将此算法实现为一个程序，计算绝对误差\n$$\nE_n \\equiv \\left| I_n - I \\right|,\n$$\n其中 $I_n$ 是 $n$ 点高斯-切比雪夫近似值，$I$ 是 A 部分得到的解析值。\n3. 对 $n$ 使用以下测试套件：\n- $n=1$ （边界情况），\n- $n=2$，\n- $n=4$，\n- $n=8$，\n- $n=16$，\n- $n=64$。\n4. 您的程序必须为上述每个 $n$ 计算 $E_n$，并生成单行输出，其中包含按上述顺序排列的结果，形式为方括号内逗号分隔的列表，例如，\n`\"[E1,E2,E3,E4,E5,E6]\"`。\n每个 $E_n$ 必须作为浮点数输出。\n\n注：\n- 这是一个纯数学问题，不涉及任何物理单位。\n- 任何三角表达式中的所有角度都必须以弧度处理。\n- 最终答案必须是一个完整的、可运行的程序，能够生成指定的单行输出。",
            "solution": "该问题要求对第一类高斯-切比雪夫求积法进行全面推导，并应用该方法来近似一个特定的加权积分。任务分为理论推导（A 部分）和带有数值误差分析的算法实现（B 部分）。\n\nA 部分：推导与解析解\n\n1. 第一类高斯-切比雪夫求积法的推导\n\n我们首先建立第一类切比雪夫多项式 $T_k(x)$ 在区间 $[-1, 1]$上关于权重函数 $w(x) = (1-x^2)^{-1/2}$ 的正交性。\n\n次数为 $k$ 的切比雪夫多项式的定义关系是 $T_k(x) = \\cos(k \\arccos x)$。我们考虑两个此类多项式 $T_j(x)$ 和 $T_k(x)$ 的乘积与指定权重函数的积分：\n$$\n\\mathcal{I}_{jk} = \\int_{-1}^{1} T_j(x) T_k(x) \\frac{1}{\\sqrt{1-x^2}} \\, dx\n$$\n我们进行变量代换 $x = \\cos\\theta$。这意味着 $\\arccos x = \\theta$。当 $x$ 从 $-1$ 变化到 $1$ 时，$\\theta$ 从 $\\pi$ 变化到 $0$。微分是 $dx = -\\sin\\theta \\, d\\theta$。项 $\\sqrt{1-x^2}$ 变为 $\\sqrt{1-\\cos^2\\theta} = \\sqrt{\\sin^2\\theta} = \\sin\\theta$，因为 $\\theta \\in [0, \\pi]$，在此区间上 $\\sin\\theta \\ge 0$。\n\n将这些代入积分，我们得到：\n$$\n\\mathcal{I}_{jk} = \\int_{\\pi}^{0} \\cos(j\\theta) \\cos(k\\theta) \\frac{1}{\\sin\\theta} (-\\sin\\theta \\, d\\theta)\n$$\n反转积分限可以消去负号：\n$$\n\\mathcal{I}_{jk} = \\int_{0}^{\\pi} \\cos(j\\theta) \\cos(k\\theta) \\, d\\theta\n$$\n我们使用三角恒等式 $\\cos(A)\\cos(B) = \\frac{1}{2}[\\cos(A+B) + \\cos(A-B)]$：\n$$\n\\mathcal{I}_{jk} = \\frac{1}{2} \\int_{0}^{\\pi} \\left[ \\cos((j+k)\\theta) + \\cos((j-k)\\theta) \\right] \\, d\\theta\n$$\n我们分三种情况计算此积分，假设 $j, k$ 是非负整数。\n\n情况 1：$j \\neq k$。\n由于 $j$ 和 $k$ 是不同的非负整数，所以 $j+k > 0$ 且 $j-k \\neq 0$。\n$$\n\\mathcal{I}_{jk} = \\frac{1}{2} \\left[ \\frac{\\sin((j+k)\\theta)}{j+k} + \\frac{\\sin((j-k)\\theta)}{j-k} \\right]_{0}^{\\pi} = \\frac{1}{2} [ (0-0) + (0-0) ] = 0\n$$\n\n情况 2：$j = k \\neq 0$。\n积分变为：\n$$\n\\mathcal{I}_{kk} = \\frac{1}{2} \\int_{0}^{\\pi} \\left[ \\cos(2k\\theta) + \\cos(0) \\right] \\, d\\theta = \\frac{1}{2} \\int_{0}^{\\pi} (\\cos(2k\\theta) + 1) \\, d\\theta\n$$\n$$\n\\mathcal{I}_{kk} = \\frac{1}{2} \\left[ \\frac{\\sin(2k\\theta)}{2k} + \\theta \\right]_{0}^{\\pi} = \\frac{1}{2} [ (0-0) + (\\pi-0) ] = \\frac{\\pi}{2}\n$$\n\n情况 3：$j = k = 0$。\n$T_0(x) = \\cos(0) = 1$。积分为：\n$$\n\\mathcal{I}_{00} = \\int_{0}^{\\pi} \\cos(0)\\cos(0) \\, d\\theta = \\int_{0}^{\\pi} 1 \\, d\\theta = \\pi\n$$\n综合这些结果，我们得到正交关系：\n$$\n\\int_{-1}^{1} \\frac{T_j(x) T_k(x)}{\\sqrt{1-x^2}} \\, dx = \\begin{cases} 0  j \\neq k \\\\ \\pi/2  j=k \\neq 0 \\\\ \\pi  j=k=0 \\end{cases}\n$$\n现在，我们推导 $n$ 点高斯-切比雪夫求积法则。考虑一个一般的加权积分：\n$$\n\\mathcal{J} = \\int_{-1}^{1} \\frac{f(x)}{\\sqrt{1-x^2}} \\, dx\n$$\n应用同样的代换 $x=\\cos\\theta$，该积分被转换为关于 $\\theta$ 的非加权积分：\n$$\n\\mathcal{J} = \\int_{0}^{\\pi} f(\\cos\\theta) \\, d\\theta\n$$\n我们可以使用一个简单的数值方案来近似这个定积分。关键的洞察是，节点的特定选择对应于一个高斯求积。我们用一个 $n$ 点中点法则来近似该积分。我们将区间 $[0, \\pi]$ 分割成 $n$ 个等宽的子区间，宽度为 $\\Delta\\theta = \\pi/n$。第 $k$ 个子区间是 $[\\frac{(k-1)\\pi}{n}, \\frac{k\\pi}{n}]$。该子区间的中点是：\n$$\n\\theta_k = \\frac{1}{2} \\left( \\frac{(k-1)\\pi}{n} + \\frac{k\\pi}{n} \\right) = \\frac{(2k-1)\\pi}{2n}, \\quad k=1, 2, \\dots, n\n$$\n中点法则的近似值是这些中点处的函数值与子区间宽度的乘积之和：\n$$\n\\mathcal{J} \\approx \\sum_{k=1}^{n} f(\\cos\\theta_k) \\Delta\\theta = \\frac{\\pi}{n} \\sum_{k=1}^{n} f(\\cos\\theta_k)\n$$\n这给了我们 $x$ 域中的求积法则。求积节点 $x_k$ 是中点 $\\theta_k$ 的像：\n$$\nx_k = \\cos(\\theta_k) = \\cos\\left(\\frac{(2k-1)\\pi}{2n}\\right), \\quad k=1, 2, \\dots, n\n$$\n这些恰好是切比雪夫多项式 $T_n(x)$ 的 $n$ 个根。求积权重 $w_k$ 全部相等，由和的常数乘子给出：\n$$\nw_k = \\frac{\\pi}{n}\n$$\n因此，$n$ 点第一类高斯-切比雪夫求积法则是：\n$$\n\\int_{-1}^{1} \\frac{f(x)}{\\sqrt{1-x^2}} \\, dx \\approx \\sum_{k=1}^{n} w_k f(x_k) = \\frac{\\pi}{n} \\sum_{k=1}^{n} f\\left(\\cos\\left(\\frac{(2k-1)\\pi}{2n}\\right)\\right)\n$$\n作为一个与 $T_n(x)$ 的根相关的高斯求积法则，该公式对于任何次数最高为 $2n-1$ 的多项式 $f(x)$ 都是精确的。\n\n2. 积分的解析求值\n\n我们现在求积分 $I$ 的闭式解。\n$$\nI = \\int_{-1}^{1} \\frac{\\ln(1+x)}{\\sqrt{1-x^2}} \\, dx\n$$\n使用代换 $x = \\cos\\theta$，我们像之前一样变换积分：\n$$\nI = \\int_{\\pi}^{0} \\frac{\\ln(1+\\cos\\theta)}{\\sin\\theta} (-\\sin\\theta \\, d\\theta) = \\int_{0}^{\\pi} \\ln(1+\\cos\\theta) \\, d\\theta\n$$\n我们使用半角三角恒等式 $1+\\cos\\theta = 2\\cos^2(\\theta/2)$：\n$$\nI = \\int_{0}^{\\pi} \\ln\\left(2\\cos^2\\left(\\frac{\\theta}{2}\\right)\\right) \\, d\\theta = \\int_{0}^{\\pi} \\left( \\ln 2 + 2\\ln\\left|\\cos\\left(\\frac{\\theta}{2}\\right)\\right| \\right) \\, d\\theta\n$$\n对于 $\\theta \\in [0, \\pi]$，$\\theta/2 \\in [0, \\pi/2]$，所以 $\\cos(\\theta/2) \\ge 0$。绝对值可以去掉。\n$$\nI = \\int_{0}^{\\pi} \\ln 2 \\, d\\theta + 2 \\int_{0}^{\\pi} \\ln\\left(\\cos\\left(\\frac{\\theta}{2}\\right)\\right) \\, d\\theta\n$$\n第一项是 $\\pi \\ln 2$。对于第二个积分，令 $u = \\theta/2$，则 $d\\theta = 2du$。积分限从 $[0, \\pi]$ 变为 $[0, \\pi/2]$。\n$$\n2 \\int_{0}^{\\pi} \\ln\\left(\\cos\\left(\\frac{\\theta}{2}\\right)\\right) \\, d\\theta = 2 \\int_{0}^{\\pi/2} \\ln(\\cos u) (2du) = 4 \\int_{0}^{\\pi/2} \\ln(\\cos u) \\, du\n$$\n将这个标准定积分记为 $J = \\int_{0}^{\\pi/2} \\ln(\\cos u) \\, du$。我们可以通过代换 $v = \\pi/2 - u$ 注意到 $J = \\int_{0}^{\\pi/2} \\ln(\\sin u) \\, du$ 来求值。然后，\n$$\n2J = \\int_{0}^{\\pi/2} \\ln(\\sin u) \\, du + \\int_{0}^{\\pi/2} \\ln(\\cos u) \\, du = \\int_{0}^{\\pi/2} \\ln(\\sin u \\cos u) \\, du\n$$\n使用 $\\sin u \\cos u = \\frac{1}{2}\\sin(2u)$：\n$$\n2J = \\int_{0}^{\\pi/2} \\ln\\left(\\frac{\\sin(2u)}{2}\\right) \\, du = \\int_{0}^{\\pi/2} \\ln(\\sin(2u)) \\, du - \\int_{0}^{\\pi/2} \\ln 2 \\, du\n$$\n第二项是 $-\\frac{\\pi}{2}\\ln 2$。对于第一项，令 $w=2u$，则 $du=dw/2$。\n$$\n\\int_{0}^{\\pi/2} \\ln(\\sin(2u)) \\, du = \\frac{1}{2} \\int_{0}^{\\pi} \\ln(\\sin w) \\, dw = \\frac{1}{2} \\left[ \\int_{0}^{\\pi/2} \\ln(\\sin w) \\, dw + \\int_{\\pi/2}^{\\pi} \\ln(\\sin w) \\, dw \\right]\n$$\n和的第一部分是 $J$。第二部分，根据 $\\sin(w)$ 关于 $w=\\pi/2$ 的对称性，也是 $J$。因此，$\\frac{1}{2}[J+J] = J$。\n代回到关于 $2J$ 的方程中：\n$$\n2J = J - \\frac{\\pi}{2}\\ln 2 \\implies J = -\\frac{\\pi}{2}\\ln 2\n$$\n现在我们可以求出 $I$ 的值：\n$$\nI = \\pi \\ln 2 + 4J = \\pi \\ln 2 + 4\\left(-\\frac{\\pi}{2}\\ln 2\\right) = \\pi \\ln 2 - 2\\pi \\ln 2 = -\\pi \\ln 2\n$$\n该积分的精确解析值是 $I = -\\pi \\ln 2$。\n\nB 部分：算法设计与数值实验\n\n1. 算法设计\n\n需要近似的积分是 $I = \\int_{-1}^{1} \\frac{\\ln(1+x)}{\\sqrt{1-x^2}} \\, dx$。函数是 $f(x) = \\ln(1+x)$。$n$ 点高斯-切比雪夫近似值 $I_n$ 是：\n$$\nI_n = \\frac{\\pi}{n} \\sum_{k=1}^{n} f(x_k) = \\frac{\\pi}{n} \\sum_{k=1}^{n} \\ln(1+x_k)\n$$\n其中节点为 $x_k = \\cos\\left(\\frac{(2k-1)\\pi}{2n}\\right)$。\n\n在计算 $\\ln(1+x_k)$ 时会出现数值稳定性问题。对于大的 $n$，节点 $x_n = \\cos(\\frac{(2n-1)\\pi}{2n}) = \\cos(\\pi - \\frac{\\pi}{2n}) = -\\cos(\\frac{\\pi}{2n})$ 接近 $-1$。当 $x_k$ 非常接近 $-1$ 时，计算 $1+x_k$ 可能会遭受灾难性抵消，即两个几乎相等的浮点数相减导致相对精度的显著损失。\n\n为了避免这个问题，我们重新构造被求和的项。由于 $x_k = \\cos(\\theta_k)$，我们有 $\\ln(1+x_k) = \\ln(1+\\cos\\theta_k)$。使用恒等式 $1+\\cos\\theta = 2\\cos^2(\\theta/2)$，我们可以写出：\n$$\n\\ln(1+\\cos\\theta_k) = \\ln\\left(2\\cos^2\\left(\\frac{\\theta_k}{2}\\right)\\right) = \\ln 2 + 2\\ln\\left(\\cos\\left(\\frac{\\theta_k}{2}\\right)\\right)\n$$\n代入 $\\theta_k = \\frac{(2k-1)\\pi}{2n}$，余弦函数的参数变为 $\\frac{\\theta_k}{2} = \\frac{(2k-1)\\pi}{4n}$。对于所有 $k=1, \\dots, n$，这个角度位于区间 $(0, \\pi/2)$ 内。余弦的计算是良态的，其结果（一个在 $(0, 1)$ 内的数）的对数计算也是良态的。这种形式避免了有问题的减法，并且是数值稳定的。\n\n计算绝对误差 $E_n = |I_n - I|$ 的算法如下：\n1.  设置解析值：$I = -\\pi \\ln 2$。\n2.  对于给定的点数 $n$：\n    a. 初始化一个和 $S=0$。\n    b. 对于 $k=1, 2, \\dots, n$：\n       i.  计算角度参数 $\\alpha_k = \\frac{(2k-1)\\pi}{4n}$。\n       ii. 计算待求和的项：$f_k = \\ln 2 + 2\\ln(\\cos(\\alpha_k))$。\n       iii. 将此项加到和中：$S = S + f_k$。\n    c. 计算数值近似值：$I_n = \\frac{\\pi}{n} S$。\n    d. 计算绝对误差：$E_n = |I_n - I|$。\n3.  对测试套件中的每个 $n$ 值重复此过程并报告误差。\n\n2. 数值实验\n\n以下程序为测试用例 $n \\in \\{1, 2, 4, 8, 16, 64\\}$ 实现了此算法，并按指定格式打印生成的绝对误差 $E_n$。为提高效率，计算使用了 NumPy 进行了向量化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the absolute error of the n-point Gauss-Chebyshev quadrature\n    for the integral of ln(1+x)/sqrt(1-x^2) from -1 to 1.\n    \"\"\"\n    # Define the test cases for n, the number of quadrature points.\n    test_cases = [1, 2, 4, 8, 16, 64]\n\n    # The analytic value of the integral is I = -pi * ln(2).\n    # This was derived in Part A.2 of the solution.\n    analytic_value = -np.pi * np.log(2)\n\n    results = []\n    for n in test_cases:\n        # Main logic to calculate the result for one case (one value of n).\n\n        # Vectorized calculation for all k from 1 to n.\n        k = np.arange(1, n + 1)\n\n        # The term to be summed in the quadrature is ln(1 + x_k).\n        # To avoid catastrophic cancellation when x_k is close to -1,\n        # we use the identity ln(1+cos(theta)) = ln(2) + 2*ln(cos(theta/2)).\n        # Here, theta_k = (2k-1)pi / (2n), so theta_k/2 = (2k-1)pi / (4n).\n        \n        # Calculate the arguments for the cosine function.\n        # This angle is always in (0, pi/2), ensuring numerical stability.\n        angle_arg = (2 * k - 1) * np.pi / (4 * n)\n        \n        # Evaluate the function at each quadrature node using the stable formula.\n        func_values = np.log(2) + 2 * np.log(np.cos(angle_arg))\n        \n        # Sum the function values and multiply by the constant weight pi/n.\n        # This gives the n-point Gauss-Chebyshev approximation I_n.\n        numerical_approx = (np.pi / n) * np.sum(func_values)\n        \n        # The absolute error is E_n = |I_n - I|.\n        abs_error = np.abs(numerical_approx - analytic_value)\n        results.append(abs_error)\n\n    # Final print statement in the exact required format.\n    # The format is a comma-separated list of floating-point numbers\n    # enclosed in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多数值方法的最终目标是求解微分方程。这项综合性练习将向你展示如何应用切比雪夫-伽辽金方法，来解决一个在地球物理流体力学中具有实际意义的特征值问题。你将把之前学到的基函数、弱形式和数值积分等概念结合起来，构建一个完整的求解器。这项实践不仅能巩固你的理论知识，还能让你掌握使用谱方法解决复杂科学问题的完整流程。",
            "id": "3614944",
            "problem": "考虑一个在静力学和长波极限下的分层 Boussinesq 流体的一维垂直模态问题，该问题在无量纲垂直区间 $z\\in[-1,1]$ 上表述。从标准的线性化静力平衡和浮力关系出发，可以得到一个关于垂直结构的 Sturm–Liouville 特征问题，其自伴形式如下\n$$\n-\\frac{d^2 \\phi}{dz^2} \\;=\\; \\lambda\\,N^2(z)\\,\\phi(z),\\qquad z\\in(-1,1),\n$$\n附带齐次 Dirichlet 边界条件\n$$\n\\phi(-1)=0,\\qquad \\phi(1)=0.\n$$\n此处 $N^2(z)$ 是浮力频率的平方剖面，$\\lambda$ 是与斜压正规模态相关的（非负）特征值。在本问题中，使用以下剖面\n$$\nN^2(z)=N_0^2\\,(1+z),\n$$\n其中 $N_00$ 是一个常数。该问题在由 $N^2(z)$ 导出的加权 $L^2$ 内积中是适定的，并且算子在满足边界条件的函数子空间上是自伴且正定的。任何三角表达式中使用的角度必须以弧度为单位。\n\n你的任务是实现一个 Chebyshev 多项式 Galerkin 离散化方法，以近似求解该问题的前几个特征值和特征函数。请按照以下步骤进行，除了下面列出的基本性质外，不要使用任何快捷公式。\n\n- 使用第一类 Chebyshev 多项式 $\\{T_n(z)\\}_{n\\ge 0}$ 作为初始基，并通过采用以下容许的试探基和检验基来施加齐次 Dirichlet 边界条件：\n$$\n\\varphi_k(z) \\;=\\; T_k(z)\\;-\\;T_{k+2}(z),\\qquad k=0,1,\\dots,M-1,\n$$\n该基满足 $\\varphi_k(\\pm 1)=0$，因为 $T_n(\\pm 1)=\\pm 1^n$。\n- 使用通过分部积分并结合给定边界条件推导出的弱（变分）形式：\n$$\n\\int_{-1}^{1}\\,\\varphi_i'(z)\\,\\varphi_j'(z)\\,dz \\;=\\; \\lambda\\;\\int_{-1}^{1} N^2(z)\\,\\varphi_i(z)\\,\\varphi_j(z)\\,dz,\\qquad i,j=0,\\dots,M-1.\n$$\n- 组装对称正定刚度矩阵 $A\\in\\mathbb{R}^{M\\times M}$ 和对称正定质量矩阵 $B\\in\\mathbb{R}^{M\\times M}$，其矩阵元为：\n$$\nA_{ij} \\;=\\; \\int_{-1}^{1}\\,\\varphi_i'(z)\\,\\varphi_j'(z)\\,dz,\\qquad\nB_{ij} \\;=\\; \\int_{-1}^{1} N^2(z)\\,\\varphi_i(z)\\,\\varphi_j(z)\\,dz.\n$$\n- 通过求解广义对称特征值问题来恢复最低的特征对：\n$$\nA\\,\\mathbf{c} \\;=\\; \\lambda\\,B\\,\\mathbf{c}.\n$$\n- 仅使用以下基本多项式恒等式：$T_n(\\cos\\theta)=\\cos(n\\theta)$ 和 $\\dfrac{d}{dz}T_n(z) = n\\,U_{n-1}(z)$，其中 $U_n(\\cos\\theta)=\\dfrac{\\sin((n+1)\\theta)}{\\sin\\theta}$，$U_n$ 表示第二类 Chebyshev 多项式。角度 $\\theta$ 以弧度为单位。\n\n算法要求：\n- 对于双线性形式的数值积分，使用在 $[-1,1]$ 上任何适用于光滑被积函数的高阶精确求积法；一个合适的选择是使用 $Q$ 个点的 Gauss–Legendre 求积法。确保 $Q$ 相对于 $M$ 足够大，以避免积分不足。\n- 要在求积节点上计算 $T_n(z)$ 和 $U_n(z)$，请使用上述的余弦和正弦表示法。通过使用不包含端点的求积节点来避免任何除以零的运算。\n- 以任何一致的方式对特征函数进行归一化以供内部使用；最终报告的量仅为特征值。\n\n测试套件：\n计算以下每组参数 $(N_0,M,Q)$ 的三个最小特征值：\n- 情况 1：$N_0=1.0$, $M=24$, $Q=200$。\n- 情况 2：$N_0=2.0$, $M=24$, $Q=200$。\n- 情况 3：$N_0=1.0$, $M=8$, $Q=120$。\n- 情况 4：$N_0=0.5$, $M=24$, $Q=200$。\n\n输出规格：\n- 对于每种情况，将计算出的特征值按升序排序，并取前三个。将每个值四舍五入到8位小数。\n- 您的程序应生成单行输出，其中包含按上述情况顺序排列的结果，格式为逗号分隔的列表之列表。例如，它应该看起来像：\n$[ [\\lambda_{1}^{(1)},\\lambda_{2}^{(1)},\\lambda_{3}^{(1)}], [\\lambda_{1}^{(2)},\\lambda_{2}^{(2)},\\lambda_{3}^{(2)}], [\\lambda_{1}^{(3)},\\lambda_{2}^{(3)},\\lambda_{3}^{(3)}], [\\lambda_{1}^{(4)},\\lambda_{2}^{(4)},\\lambda_{3}^{(4)}] ]$。\n只打印这一行；不要打印任何附加文本。\n\n注释：\n- 上述公式作为一个自伴加权特征问题是普遍适用的。通过使用等价的自伴形式 $-\\,\\phi''=\\lambda\\,N^2\\phi$ 和 Dirichlet 边界条件，它避免了在 $z=-1$ 处的任何奇异系数，这与标准静力斜压模态方程的 Liouville 变换是一致的。\n- 三角函数内部使用的所有角度都必须以弧度为单位。",
            "solution": "所提出的问题是一个适定的 Sturm-Liouville 特征值问题，它是地球物理流体动力学中研究分层流体垂直模态的基础。该问题在科学上是合理的、自洽的，并且在数学上是明确的。因此，我将给出一个完整的解答。\n\n垂直结构函数 $\\phi(z)$ 的控制方程由下式给出：\n$$\n-\\frac{d^2 \\phi}{dz^2} = \\lambda\\,N^2(z)\\,\\phi(z),\n$$\n定义域为 $z \\in (-1, 1)$，服从齐次 Dirichlet 边界条件 $\\phi(-1) = 0$ 和 $\\phi(1) = 0$。浮力频率的平方剖面是深度的线性函数，$N^2(z) = N_0^2\\,(1+z)$。\n\n我们试图使用 Chebyshev-Galerkin 谱方法找到最小的特征值 $\\lambda$。该方法的核心是将问题投影到一个由满足问题边界条件的一组基函数张成的有限维函数空间上。\n\n首先，将微分方程转化为其弱形式或变分形式。我们将方程乘以一个来自合适空间的检验函数 $v(z)$，并在整个定义域上积分：\n$$\n-\\int_{-1}^{1} v(z) \\frac{d^2 \\phi}{dz^2} dz = \\lambda \\int_{-1}^{1} v(z) N^2(z) \\phi(z) dz.\n$$\n对左侧应用分部积分得到：\n$$\n\\left[ -v(z) \\frac{d\\phi}{dz} \\right]_{-1}^{1} + \\int_{-1}^{1} \\frac{dv}{dz} \\frac{d\\phi}{dz} dz = \\lambda \\int_{-1}^{1} v(z) \\phi(z) N^2(z) dz.\n$$\n在 Galerkin 方法中，检验函数 $v(z)$ 与解 $\\phi(z)$ 的试探（基）函数选自同一空间。问题指定了满足边界条件的试探函数，因此我们要求 $v(\\pm 1) = 0$。这使得边界项 $\\left[ -v(z) \\frac{d\\phi}{dz} \\right]_{-1}^{1}$ 消失，从而得到弱形式：\n$$\n\\int_{-1}^{1} v'(z) \\phi'(z) dz = \\lambda \\int_{-1}^{1} v(z) \\phi(z) N^2(z) dz.\n$$\n\n解 $\\phi(z)$ 由 $M$ 个基函数 $\\varphi_j(z)$ 的有限展开式近似：\n$$\n\\phi(z) \\approx \\phi_M(z) = \\sum_{j=0}^{M-1} c_j \\varphi_j(z),\n$$\n其中 $c_j$ 是未知系数。指定的基函数由第一类 Chebyshev 多项式 $T_n(z)$ 构造而成，具体如下：\n$$\n\\varphi_k(z) = T_k(z) - T_{k+2}(z), \\quad k=0, 1, \\dots, M-1.\n$$\n这些函数满足 $\\varphi_k(\\pm 1) = 0$，因为 $T_n(1)=1$ 和 $T_n(-1)=(-1)^n$，这确保了 $T_k(\\pm 1) = T_{k+2}(\\pm 1)$，从而将边界条件正确地并入近似空间。\n\n将 $\\phi_M(z)$ 的展开式代入弱形式，并选择基函数本身作为检验函数，即 $v(z) = \\varphi_i(z)$（其中 $i=0, 1, \\dots, M-1$），我们得到一个包含 $M$ 个线性方程的方程组：\n$$\n\\sum_{j=0}^{M-1} c_j \\left( \\int_{-1}^{1} \\varphi_i'(z) \\varphi_j'(z) dz \\right) = \\lambda \\sum_{j=0}^{M-1} c_j \\left( \\int_{-1}^{1} N^2(z) \\varphi_i(z) \\varphi_j(z) dz \\right).\n$$\n该系统表示为一个广义对称矩阵特征值问题：\n$$\nA \\mathbf{c} = \\lambda B \\mathbf{c},\n$$\n其中 $\\mathbf{c} = [c_0, c_1, \\dots, c_{M-1}]^T$ 是系数向量，刚度矩阵 $A$ 和质量矩阵 $B$ 的矩阵元为：\n$$\nA_{ij} = \\int_{-1}^{1} \\varphi_i'(z) \\varphi_j'(z) dz,\n$$\n$$\nB_{ij} = \\int_{-1}^{1} N^2(z) \\varphi_i(z) \\varphi_j(z) dz = N_0^2 \\int_{-1}^{1} (1+z) \\varphi_i(z) \\varphi_j(z) dz.\n$$\n\n这些矩阵的矩阵元通过数值求积计算。我们采用在区间 $[-1, 1]$ 上有 $Q$ 个点 $\\{z_q\\}_{q=0}^{Q-1}$ 和相应权重 $\\{w_q\\}_{q=0}^{Q-1}$ 的 Gauss-Legendre 求积法。因此，矩阵元可近似为：\n$$\nA_{ij} \\approx \\sum_{q=0}^{Q-1} w_q \\varphi_i'(z_q) \\varphi_j'(z_q),\n$$\n$$\nB_{ij} \\approx N_0^2 \\sum_{q=0}^{Q-1} w_q (1+z_q) \\varphi_i(z_q) \\varphi_j(z_q).\n$$\n\n为了在求积节点上计算基函数及其导数，我们使用指定的三角恒等式。通过代换 $z = \\cos\\theta$，我们得到 $\\theta = \\arccos(z)$。求积节点 $z_q$ 严格位于 $(-1, 1)$ 内，因此 $\\theta_q = \\arccos(z_q)$ 在 $(0, \\pi)$ 内是良定义的。\n基函数使用 $T_n(\\cos\\theta) = \\cos(n\\theta)$ 进行计算：\n$$\n\\varphi_k(z_q) = T_k(\\cos\\theta_q) - T_{k+2}(\\cos\\theta_q) = \\cos(k\\theta_q) - \\cos((k+2)\\theta_q).\n$$\n导数使用 $\\frac{d}{dz}T_n(z) = n U_{n-1}(z)$ 和 $U_n(\\cos\\theta) = \\frac{\\sin((n+1)\\theta)}{\\sin\\theta}$ 进行计算：\n$$\n\\varphi_k'(z) = k U_{k-1}(z) - (k+2) U_{k+1}(z).\n$$\n在节点 $z_q=\\cos\\theta_q$ 处求值，得到：\n$$\n\\varphi_k'(z_q) = k \\frac{\\sin(k\\theta_q)}{\\sin\\theta_q} - (k+2) \\frac{\\sin((k+2)\\theta_q)}{\\sin\\theta_q}.\n$$\n由于 $\\theta_q \\in (0, \\pi)$，分母 $\\sin\\theta_q$ 不为零。\n\n组装好矩阵 $A$ 和 $B$ 后，对广义特征值问题 $A \\mathbf{c} = \\lambda B \\mathbf{c}$ 进行数值求解。由于 $A$ 和 $B$ 是对称且正定的，可以使用专门且稳定的算法。所得的特征值 $\\lambda$ 是连续问题真实特征值的近似。我们按升序对这些值进行排序，并按要求选择最小的三个。\n\n值得注意的是常数 $N_0$ 的作用。质量矩阵 $B$ 与 $N_0^2$ 成正比。因此，特征值 $\\lambda$ 与 $N_0^2$ 成反比。这意味着，如果我们计算了 $N_0=1.0$ 时的特征值 $\\lambda_{N_0=1}$，那么对于任何其他 $N_0$ 的特征值都由 $\\lambda_{N_0} = \\lambda_{N_0=1} / N_0^2$ 给出。这种物理标度关系为数值结果提供了一个有价值的一致性检验。\n\n实现过程首先计算 Gauss-Legendre 求积节点和权重。然后，对于给定的 $M$，在这些节点上计算所有基函数及其导数的值并存储。这些值用于通过矢量化操作高效地组装矩阵 $A$ 和 $B$。最后，使用标准科学计算库（例如 SciPy）中的广义特征值求解器来计算特征值。对问题陈述中指定的每个测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to solve the eigenvalue problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N0, M, Q)\n        (1.0, 24, 200),\n        (2.0, 24, 200),\n        (1.0, 8, 120),\n        (0.5, 24, 200),\n    ]\n\n    all_results = []\n    for N0, M, Q in test_cases:\n        eigenvalues = compute_eigenvalues(N0, M, Q)\n        # Select the three smallest eigenvalues and round them.\n        smallest_three = np.round(eigenvalues[:3], 8).tolist()\n        all_results.append(smallest_three)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list of lists adds spaces inside inner lists,\n    # which matches the problem's symbolic example. The join operation specified in the\n    # template code produces a slightly different whitespace pattern. We construct the\n    # string carefully to match the template's specified join logic.\n    inner_list_strings = [str(res) for res in all_results]\n    print(f\"[{','.join(inner_list_strings)}]\")\n\n\ndef compute_eigenvalues(N0, M, Q):\n    \"\"\"\n    Computes the eigenvalues for a single case (N0, M, Q).\n    \n    Args:\n        N0 (float): Buoyancy frequency constant.\n        M (int): Number of basis functions (size of discretization).\n        Q (int): Number of Gauss-Legendre quadrature points.\n\n    Returns:\n        np.ndarray: An array of computed eigenvalues, sorted in ascending order.\n    \"\"\"\n    # Step 1: Get Gauss-Legendre quadrature nodes and weights for the interval [-1, 1].\n    z_nodes, w_weights = np.polynomial.legendre.leggauss(Q)\n\n    # Step 2: Evaluate basis functions phi_k and their derivatives dphi_k/dz at the nodes.\n    phi_vals, dphi_vals = evaluate_basis_functions(M, z_nodes)\n\n    # Step 3: Assemble the stiffness (A) and mass (B) matrices.\n    # A_ij = integral(phi'_i * phi'_j, dz)\n    # B_ij = integral(N^2 * phi_i * phi_j, dz)\n    \n    # Efficient assembly using vectorized operations.\n    # This is equivalent to dphi_vals @ np.diag(w_weights) @ dphi_vals.T\n    A = dphi_vals @ (dphi_vals * w_weights).T\n\n    # Buoyancy frequency squared N^2(z) = N0^2 * (1 + z) evaluated at nodes.\n    N2_on_nodes = N0**2 * (1 + z_nodes)\n    \n    # This is equivalent to phi_vals @ np.diag(w_weights * N2_on_nodes) @ phi_vals.T\n    B = phi_vals @ (phi_vals * (w_weights * N2_on_nodes)).T\n\n    # Step 4: Solve the generalized symmetric eigenvalue problem A c = lambda B c.\n    # eigh returns eigenvalues in ascending order, which is what we need.\n    eigenvalues = eigh(A, B, eigvals_only=True)\n    \n    return eigenvalues\n\n\ndef evaluate_basis_functions(M, z_nodes):\n    \"\"\"\n    Evaluates Chebyshev-based trial functions and their derivatives at quadrature nodes.\n    The basis functions are phi_k(z) = T_k(z) - T_{k+2}(z).\n    \n    Args:\n        M (int): Number of basis functions.\n        z_nodes (np.ndarray): Quadrature nodes in [-1, 1].\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: \n            - phi_vals (M x Q): Values of basis functions at nodes.\n            - dphi_vals (M x Q): Values of basis function derivatives at nodes.\n    \"\"\"\n    Q = len(z_nodes)\n    \n    # Use the transformation z = cos(theta)\n    # Note: z_nodes from leggauss are in (-1, 1), so arccos is well-defined in (0, pi).\n    theta_nodes = np.arccos(z_nodes)\n    sin_theta = np.sin(theta_nodes) # This will not be zero.\n    \n    # Array of basis indices: k = 0, 1, ..., M-1\n    k = np.arange(M).reshape(-1, 1)\n\n    # Evaluate phi_k(z) = T_k(z) - T_{k+2}(z) using T_n(cos(theta)) = cos(n*theta).\n    # Broadcasting k (M,1) with theta_nodes (Q,) -> (M,Q)\n    T_k = np.cos(k * theta_nodes)\n    T_k_plus_2 = np.cos((k + 2) * theta_nodes)\n    phi_vals = T_k - T_k_plus_2\n    \n    # Evaluate d(phi_k)/dz = k*U_{k-1}(z) - (k+2)*U_{k+1}(z)\n    # using U_{n-1}(cos(theta)) = sin(n*theta)/sin(theta).\n    \n    # Term 1: k*U_{k-1}(z) -> k*sin(k*theta)/sin(theta)\n    # For k=0, the numerator is sin(0)=0, so the term is 0, which is correct.\n    dphi_term1 = k * np.sin(k * theta_nodes) / sin_theta\n    \n    # Term 2: (k+2)*U_{k+1}(z) -> (k+2)*sin((k+2)*theta)/sin(theta)\n    dphi_term2 = (k + 2) * np.sin((k + 2) * theta_nodes) / sin_theta\n    \n    dphi_vals = dphi_term1 - dphi_term2\n    \n    return phi_vals, dphi_vals\n\n# The entry point of the script.\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}