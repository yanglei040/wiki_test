{
    "hands_on_practices": [
        {
            "introduction": "In many geophysical applications, such as seismic wave modeling, high-order accurate numerical schemes are essential for minimizing non-physical artifacts like numerical dispersion. This exercise provides fundamental practice in constructing such a scheme from first principles. By systematically using Taylor series expansions to determine the weights of a finite difference stencil, you will gain a concrete understanding of how local truncation error is controlled to achieve a desired order of accuracy .",
            "id": "3617972",
            "problem": "In high-order finite difference discretizations used in computational geophysics, accurate spatial gradients of smooth fields are needed to reduce numerical dispersion in wave propagation simulations governed by Partial Differential Equations (PDE). Consider a smooth scalar geophysical field $u(x)$ sampled on a uniform grid with spacing $h$ at points $x_i + m h$ for integer offsets $m \\in \\{-2,-1,0,1,2\\}$. You aim to approximate the first spatial derivative $u_x(x_i)$ using a centered five-point stencil of the form\n$$\nD u_i \\equiv \\frac{1}{h} \\sum_{m=-2}^{2} w_m \\, u(x_i + m h),\n$$\nwith weights $w_m$ chosen so that $D u_i$ is fourth-order accurate at $x_i$. Starting from the Taylor series expansion of $u(x_i + m h)$ about $x_i$, determine the weights $w_m$ by matching coefficients so that $D u_i - u_x(x_i)$ vanishes through terms proportional to $h^k$ for $k = 0,1,2,3,4$ except for the correctly reproduced $u_x(x_i)$ term. Assume a centered stencil consistent with a first derivative, that is, $w_{-m} = - w_m$ for $m = 1,2$. Then, using the resulting weights, compute the leading truncation error coefficient $C$ defined by\n$$\nD u_i - u_x(x_i) = C \\, h^4 \\, u^{(5)}(x_i) + \\mathcal{O}(h^6).\n$$\nExpress the final coefficient $C$ as an exact rational number. No rounding is required and no units are associated with $C$.",
            "solution": "The user has requested the derivation of finite difference weights for a fourth-order accurate, five-point centered stencil for the first derivative, and the subsequent calculation of the leading truncation error coefficient.\n\nThe problem statement is scientifically grounded, well-posed, and objective. It represents a standard and fundamental problem in numerical analysis, specifically in the context of creating high-order accurate finite difference schemes for solving partial differential equations. The provided information is complete and consistent, allowing for a unique solution. The problem is therefore valid.\n\nThe objective is to find the weights $w_m$ and the coefficient $C$ for the approximation:\n$$\nD u_i \\equiv \\frac{1}{h} \\sum_{m=-2}^{2} w_m \\, u(x_i + m h) \\approx u_x(x_i)\n$$\nsuch that the truncation error is $\\mathcal{O}(h^4)$. The truncation error is defined as:\n$$\nD u_i - u_x(x_i) = C \\, h^4 \\, u^{(5)}(x_i) + \\mathcal{O}(h^6)\n$$\n\nThe stencil is centered and approximates a first derivative, which implies an anti-symmetric weight distribution: $w_{-m} = -w_m$. For the central point $m=0$, this condition gives $w_0 = -w_0$, which is only satisfied if $w_0=0$. With this condition, the approximation can be written as:\n$$\nD u_i = \\frac{1}{h} \\left( w_{-2} u(x_i - 2h) + w_{-1} u(x_i - h) + w_1 u(x_i + h) + w_2 u(x_i + 2h) \\right)\n$$\n$$\nD u_i = \\frac{1}{h} \\left( w_1 (u(x_i+h) - u(x_i-h)) + w_2 (u(x_i+2h) - u(x_i-2h)) \\right)\n$$\nTo determine the unknown weights $w_1$ and $w_2$, we expand the terms $u(x_i+mh)$ in a Taylor series around the point $x_i$. Let $u^{(k)}(x_i)$ denote the $k$-th derivative of $u$ at $x_i$. The expansions are:\n$$\nu(x_i \\pm mh) = u(x_i) \\pm (mh)u^{(1)}(x_i) + \\frac{(mh)^2}{2!}u^{(2)}(x_i) \\pm \\frac{(mh)^3}{3!}u^{(3)}(x_i) + \\frac{(mh)^4}{4!}u^{(4)}(x_i) \\pm \\frac{(mh)^5}{5!}u^{(5)}(x_i) + \\mathcal{O}(h^6)\n$$\nWe form the differences required by the stencil. The even-powered terms cancel out:\n$$\nu(x_i+h) - u(x_i-h) = 2h u^{(1)}(x_i) + \\frac{2h^3}{6} u^{(3)}(x_i) + \\frac{2h^5}{120} u^{(5)}(x_i) + \\mathcal{O}(h^7)\n$$\n$$\nu(x_i+2h) - u(x_i-2h) = 2(2h) u^{(1)}(x_i) + \\frac{2(2h)^3}{6} u^{(3)}(x_i) + \\frac{2(2h)^5}{120} u^{(5)}(x_i) + \\mathcal{O}(h^7)\n$$\nSimplifying these expressions gives:\n$$\nu(x_i+h) - u(x_i-h) = 2h u^{(1)}(x_i) + \\frac{h^3}{3} u^{(3)}(x_i) + \\frac{h^5}{60} u^{(5)}(x_i) + \\mathcal{O}(h^7)\n$$\n$$\nu(x_i+2h) - u(x_i-2h) = 4h u^{(1)}(x_i) + \\frac{8h^3}{3} u^{(3)}(x_i) + \\frac{8h^5}{15} u^{(5)}(x_i) + \\mathcal{O}(h^7)\n$$\nNow, substitute these expansions back into the expression for $D u_i$:\n$$\nD u_i = \\frac{w_1}{h} \\left( 2h u^{(1)}(x_i) + \\frac{h^3}{3} u^{(3)}(x_i) + \\frac{h^5}{60} u^{(5)}(x_i) + \\dots \\right) + \\frac{w_2}{h} \\left( 4h u^{(1)}(x_i) + \\frac{8h^3}{3} u^{(3)}(x_i) + \\frac{8h^5}{15} u^{(5)}(x_i) + \\dots \\right)\n$$\nWe can group the terms by the order of the derivative of $u$:\n$$\nD u_i = (2w_1 + 4w_2) u^{(1)}(x_i) + \\left(\\frac{w_1}{3} + \\frac{8w_2}{3}\\right) h^2 u^{(3)}(x_i) + \\left(\\frac{w_1}{60} + \\frac{8w_2}{15}\\right) h^4 u^{(5)}(x_i) + \\mathcal{O}(h^6)\n$$\nTo achieve a fourth-order accurate approximation of $u_x(x_i) = u^{(1)}(x_i)$, we must ensure that the coefficient of $u^{(1)}(x_i)$ is $1$, and the coefficients of higher-order derivative terms vanish up to the desired order. The error term should start at $\\mathcal{O}(h^4)$.\n1.  The coefficient of $u^{(1)}(x_i)$ must be $1$:\n    $$2w_1 + 4w_2 = 1 \\quad (1)$$\n2.  The coefficient of $h^2 u^{(3)}(x_i)$ must be $0$ to eliminate the $\\mathcal{O}(h^2)$ error term:\n    $$\\frac{w_1}{3} + \\frac{8w_2}{3} = 0 \\implies w_1 + 8w_2 = 0 \\quad (2)$$\n\nWe now have a system of two linear equations for the two unknown weights $w_1$ and $w_2$. From equation $(2)$, we express $w_1$ in terms of $w_2$:\n$$\nw_1 = -8w_2\n$$\nSubstitute this into equation $(1)$:\n$$\n2(-8w_2) + 4w_2 = 1\n$$\n$$\n-16w_2 + 4w_2 = 1\n$$\n$$\n-12w_2 = 1 \\implies w_2 = -\\frac{1}{12}\n$$\nNow, we find $w_1$:\n$$\nw_1 = -8 \\left(-\\frac{1}{12}\\right) = \\frac{8}{12} = \\frac{2}{3}\n$$\nThe complete set of weights for the stencil is:\n$w_2 = -1/12$, $w_1 = 2/3$, $w_0 = 0$, $w_{-1} = -2/3$, $w_{-2} = 1/12$.\n\nWith these weights, the terms for $u^{(1)}$ and $u^{(3)}$ are correct. The leading term of the truncation error is the first non-zero term, which is the $h^4 u^{(5)}(x_i)$ term.\n$$\nD u_i - u_x(x_i) = \\left(\\frac{w_1}{60} + \\frac{8w_2}{15}\\right) h^4 u^{(5)}(x_i) + \\mathcal{O}(h^6)\n$$\nThe coefficient $C$ is therefore:\n$$\nC = \\frac{w_1}{60} + \\frac{8w_2}{15}\n$$\nSubstituting the derived values of $w_1$ and $w_2$:\n$$\nC = \\frac{2/3}{60} + \\frac{8(-1/12)}{15} = \\frac{2}{3 \\cdot 60} - \\frac{8}{12 \\cdot 15}\n$$\n$$\nC = \\frac{2}{180} - \\frac{8}{180} = \\frac{2-8}{180} = \\frac{-6}{180}\n$$\nSimplifying the fraction gives the final result for the coefficient $C$:\n$$\nC = -\\frac{1}{30}\n$$",
            "answer": "$$\n\\boxed{-\\frac{1}{30}}\n$$"
        },
        {
            "introduction": "A scheme can be locally accurate, with a small truncation error, yet produce globally catastrophic results. This practice explores this crucial concept through the lens of the linear advection equation, a cornerstone of geophysical fluid dynamics. By analyzing the classic forward-time, centered-space (FTCS) scheme, you will discover the difference between consistency and stability and use Fourier analysis to see precisely why this locally consistent method is unconditionally unstable, a vital lesson for any computational scientist .",
            "id": "3617985",
            "problem": "Consider the linear advection equation in one spatial dimension,\n$$\nu_t = a\\,u_x\n$$\nposed on the periodic interval $[0,1]$ with period $1$, where $a$ is a constant advection speed. Let $x_j = j\\,\\Delta x$ for $j=0,1,\\dots,N-1$, where $N$ is the number of grid points and $\\Delta x = 1/N$. Let $t^n = n\\,\\Delta t$ for time step $\\Delta t$. Define the Courant–Friedrichs–Lewy number (also called the Courant number) by $\\nu = a\\,\\Delta t/\\Delta x$.\n\nYou will analyze the forward-time, centered-space finite difference method,\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = a\\,\\frac{u_{j+1}^n - u_{j-1}^n}{2\\,\\Delta x},\n$$\non the periodic grid, where indices are interpreted modulo $N$. This method is widely known to be consistent but unstable for advection.\n\nYour tasks are:\n\n- Starting from the definitions of the discrete operators and Taylor expansions, define the local truncation error at a grid point $x_j$ and time $t^n$ as the defect obtained by substituting the exact solution into the finite difference update:\n$$\n\\tau_j^n = \\frac{u(x_j,t^{n+1}) - u(x_j,t^n)}{\\Delta t} - a\\,\\frac{u(x_{j+1},t^n) - u(x_{j-1},t^n)}{2\\,\\Delta x}.\n$$\n\n- Use the discrete $L^2$ norm on the grid, defined by\n$$\n\\|v\\|_2 = \\left(\\Delta x \\sum_{j=0}^{N-1} v_j^2\\right)^{1/2},\n$$\nto quantify both local truncation errors and the growth of numerical solutions.\n\n- For a discrete Fourier mode initial condition with wavenumber $m \\in \\mathbb{N}$,\n$$\nu(x,0) = \\sin(2\\pi m x),\n$$\nand exact solution $u(x,t) = \\sin(2\\pi m(x + at))$, compute the local truncation error vector at time $t^n=0$,\n$$\n\\tau^0 = \\{\\tau_j^0\\}_{j=0}^{N-1},\n$$\nand its norm $\\|\\tau^0\\|_2$.\n\n- Define the single-step update as a linear operator $A$ acting on grid vectors, $u^{n+1} = A u^n$. Use a norm growth estimate based on the induced operator norm in the discrete $L^2$ norm to bound $\\|A\\|_2$. Then, using a discrete Fourier mode analysis, determine the observed norm growth factor after $n$ steps for the chosen mode, and compare it against your norm-based upper bound. Do not assume a bound a priori; you must obtain it from the structure of $A$ on the periodic grid.\n\n- Show numerically, with a smooth mode, that even when the local truncation error is small, the observed norm growth can exceed $1$ over many steps, demonstrating global error divergence due to instability.\n\nImplementation requirements for the program:\n\n- Use the above scheme on a periodic grid. For each test case, compute:\n  1. The local truncation error $\\|\\tau^0\\|_2$ at $t^0=0$ as defined above.\n  2. The observed norm growth ratio $R_{\\text{obs}} = \\|u^n\\|_2/\\|u^0\\|_2$ after $n$ time steps for the prescribed mode. You may compute this either by explicitly applying the scheme $n$ times or by using the fact that the scheme is translation-invariant on a periodic grid and thus preserves Fourier modes up to an amplification factor per step determined by the mode and $\\nu$.\n  3. The theoretical norm-growth upper bound in logarithmic form, $\\log R_{\\text{bound}} = n \\log \\|A\\|_2$, where $\\|A\\|_2$ is the discrete $L^2$ induced operator norm per time step.\n  4. A boolean indicating instability observed for that test, defined as $R_{\\text{obs}} > 1$.\n\n- Test suite. Use the following parameter sets, where $a$, $N$, $\\nu$, $T$, and $m$ denote the advection speed, number of grid points, Courant number, final time, and Fourier mode index, respectively. Use $x_j = j/N$, $\\Delta x = 1/N$, $\\Delta t = \\nu\\,\\Delta x/a$, and $n = \\lfloor T/\\Delta t \\rceil$ (nearest integer) time steps.\n  - Test $1$: $a=1$, $N=256$, $\\nu=0.05$, $T=10$, $m=1$.\n  - Test $2$: $a=1$, $N=256$, $\\nu=0.10$, $T=20$, $m=1$.\n  - Test $3$: $a=1$, $N=64$, $\\nu=0.50$, $T=5$, $m=1$.\n\n- For each test:\n  - Compute $\\|\\tau^0\\|_2$ as a float.\n  - Compute $R_{\\text{obs}}$ as a float.\n  - Compute $\\log R_{\\text{obs}}$ as a float.\n  - Compute $\\log R_{\\text{bound}}$ as a float.\n  - Compute the boolean $R_{\\text{obs}} > 1$.\n\n- Final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist in the order\n$$\n[\\|\\tau^0\\|_2,\\; R_{\\text{obs}},\\; \\log R_{\\text{obs}},\\; \\log R_{\\text{bound}},\\; R_{\\text{obs}} > 1].\n$$\nFor example, a valid shape is\n$$\n\\big[\\,[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\;[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\;[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]\\,\\big].\n$$\nAll quantities are dimensionless. Return floats in standard decimal form and the boolean as either True or False. The single printed line must be exactly this list-of-lists representation.",
            "solution": "The problem is subjected to validation.\n\n### Step 1: Extract Givens\n- **Partial Differential Equation (PDE)**: $u_t = a\\,u_x$\n- **Domain**: Periodic on $[0,1]$ with period $1$.\n- **Advection Speed**: $a$ is a constant.\n- **Spatial Grid**: $x_j = j\\,\\Delta x$ for $j=0,1,\\dots,N-1$, with $\\Delta x = 1/N$.\n- **Temporal Grid**: $t^n = n\\,\\Delta t$.\n- **Courant Number (CFL)**: $\\nu = a\\,\\Delta t/\\Delta x$.\n- **Finite Difference Method (FTCS)**: $\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = a\\,\\frac{u_{j+1}^n - u_{j-1}^n}{2\\,\\Delta x}$. Indices are modulo $N$.\n- **Local Truncation Error Definition**: $\\tau_j^n = \\frac{u(x_j,t^{n+1}) - u(x_j,t^n)}{\\Delta t} - a\\,\\frac{u(x_{j+1},t^n) - u(x_{j-1},t^n)}{2\\,\\Delta x}$, where $u(x,t)$ is the exact solution.\n- **Discrete $L^2$ norm**: $\\|v\\|_2 = \\left(\\Delta x \\sum_{j=0}^{N-1} v_j^2\\right)^{1/2}$.\n- **Initial Condition**: $u(x,0) = \\sin(2\\pi\\,m\\,x)$ for a wavenumber $m \\in \\mathbb{N}$.\n- **Exact Solution**: $u(x,t) = \\sin(2\\pi m(x + at))$.\n- **Single-Step Operator**: $u^{n+1} = A u^n$.\n- **Quantities to Compute for each test case**:\n  1. $\\|\\tau^0\\|_2$, the norm of the local truncation error at $t=0$.\n  2. $R_{\\text{obs}} = \\|u^n\\|_2/\\|u^0\\|_2$, the observed norm growth after $n$ steps.\n  3. $\\log R_{\\text{bound}} = n \\log \\|A\\|_2$, the logarithm of the theoretical norm-growth upper bound.\n  4. A boolean indicating if $R_{\\text{obs}} > 1$.\n- **Test Parameters**:\n  - $n = \\lfloor T/\\Delta t \\rceil$ (nearest integer).\n  - Test 1: $a=1$, $N=256$, $\\nu=0.05$, $T=10$, $m=1$.\n  - Test 2: $a=1$, $N=256$, $\\nu=0.10$, $T=20$, $m=1$.\n  - Test 3: $a=1$, $N=64$, $\\nu=0.50$, $T=5$, $m=1$.\n- **Output Format**: A single line representing a list of lists: `[[val1, val2, ...], [val1, val2, ...], ...]`.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is a standard exercise in the numerical analysis of partial differential equations, specifically focusing on the stability of the FTCS scheme for the linear advection equation.\n- **Scientifically Grounded**: The analysis is based on fundamental principles of numerical analysis, including Taylor series expansions for truncation error and discrete Fourier analysis (von Neumann stability analysis) for stability. The FTCS scheme and the advection equation are canonical subjects in this field. All aspects are scientifically sound.\n- **Well-Posed**: The problem asks for the calculation of specific, well-defined quantities based on a complete set of initial data and parameters. A unique solution for each quantity exists.\n- **Objective**: The problem is stated in precise mathematical language, free from subjectivity or ambiguity.\n- **Completeness**: All necessary definitions, equations, and parameters are provided.\n- **Consistency**: The givens are internally consistent. The exact solution provided does satisfy the given PDE and initial condition.\n\nThe problem does not exhibit any of the invalidity flaws.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A complete, reasoned solution will be provided.\n\n### Principle-Based Solution\n\nThe solution requires calculating four quantities for each test case: the norm of the local truncation error $\\|\\tau^0\\|_2$, the observed norm growth $R_{\\text{obs}}$, the theoretical log-norm growth bound $\\log R_{\\text{bound}}$, and an instability flag. We will derive analytical expressions for each.\n\n#### 1. Local Truncation Error Norm $\\|\\tau^0\\|_2$\nThe local truncation error at $t=0$ is given by substituting the exact solution into the finite difference scheme:\n$$\n\\tau_j^0 = \\frac{u(x_j, \\Delta t) - u(x_j, 0)}{\\Delta t} - a \\frac{u(x_{j+1}, 0) - u(x_{j-1}, 0)}{2\\Delta x}\n$$\nWith the exact solution $u(x,t) = \\sin(2\\pi m(x+at))$ and grid points $x_j=j\\Delta x$, we have:\n- $u(x_j, 0) = \\sin(2\\pi m x_j)$\n- $u(x_j, \\Delta t) = \\sin(2\\pi m (x_j + a\\Delta t))$\n- $u(x_{j\\pm 1}, 0) = \\sin(2\\pi m (x_j \\pm \\Delta x))$\n\nSubstituting these into the expression for $\\tau_j^0$:\n$$\n\\tau_j^0 = \\frac{\\sin(2\\pi m (x_j + a\\Delta t)) - \\sin(2\\pi m x_j)}{\\Delta t} - a \\frac{\\sin(2\\pi m (x_j + \\Delta x)) - \\sin(2\\pi m (x_j - \\Delta x))}{2\\Delta x}\n$$\nUsing the trigonometric identities $\\sin(A+B)-\\sin(A-B) = 2\\cos A \\sin B$ and $\\sin(A)-\\sin(B) = 2\\cos\\frac{A+B}{2}\\sin\\frac{A-B}{2}$, the expression becomes:\n$$\n\\tau_j^0 = \\frac{2\\cos(2\\pi m x_j + \\pi m a\\Delta t)\\sin(\\pi m a\\Delta t)}{\\Delta t} - \\frac{a}{2\\Delta x} \\left(2\\cos(2\\pi m x_j)\\sin(2\\pi m \\Delta x)\\right)\n$$\nExpanding $\\cos(A+B) = \\cos A \\cos B - \\sin A \\sin B$ and grouping terms by $\\sin(2\\pi m x_j)$ and $\\cos(2\\pi m x_j)$:\n$$\n\\tau_j^0 = \\cos(2\\pi m x_j) \\left[ \\frac{2\\cos(\\pi m a\\Delta t)\\sin(\\pi m a\\Delta t)}{\\Delta t} - \\frac{a\\sin(2\\pi m \\Delta x)}{\\Delta x} \\right] - \\sin(2\\pi m x_j) \\left[ \\frac{2\\sin^2(\\pi m a\\Delta t)}{\\Delta t} \\right]\n$$\nUsing the identity $\\sin(2\\theta) = 2\\sin\\theta\\cos\\theta$:\n$$\n\\tau_j^0 = \\cos(2\\pi m x_j) \\left[ \\frac{\\sin(2\\pi m a\\Delta t)}{\\Delta t} - \\frac{a\\sin(2\\pi m \\Delta x)}{\\Delta x} \\right] - \\sin(2\\pi m x_j) \\left[ \\frac{2\\sin^2(\\pi m a\\Delta t)}{\\Delta t} \\right]\n$$\nLet's define the coefficients $E_c$ and $E_s$ as:\n$$\nE_c = \\frac{\\sin(2\\pi m a \\Delta t)}{\\Delta t} - \\frac{a \\sin(2\\pi m \\Delta x)}{\\Delta x}\n$$\n$$\nE_s = - \\frac{2 \\sin^2(\\pi m a \\Delta t)}{\\Delta t}\n$$\nSo, $\\tau_j^0 = E_c \\cos(2\\pi m j/N) + E_s \\sin(2\\pi m j/N)$. We now compute the norm $\\|\\tau^0\\|_2^2 = \\Delta x \\sum_{j=0}^{N-1} (\\tau_j^0)^2$.\nDue to the orthogonality of discrete sine and cosine functions on the grid for $m \\neq 0$ and $2m \\neq N$ (which holds for all test cases), we have:\n$\\sum_{j=0}^{N-1} \\cos^2(2\\pi m j/N) = N/2$\n$\\sum_{j=0}^{N-1} \\sin^2(2\\pi m j/N) = N/2$\n$\\sum_{j=0}^{N-1} \\cos(2\\pi m j/N)\\sin(2\\pi m j/N) = 0$\nTherefore,\n$$\n\\|\\tau^0\\|_2^2 = \\Delta x \\sum_{j=0}^{N-1} [E_c^2 \\cos^2(2\\pi m j/N) + E_s^2 \\sin^2(2\\pi m j/N) + \\dots] = \\Delta x \\left( E_c^2 \\frac{N}{2} + E_s^2 \\frac{N}{2} \\right)\n$$\nSince $\\Delta x = 1/N$, this simplifies to:\n$$\n\\|\\tau^0\\|_2^2 = \\frac{1}{2}(E_c^2 + E_s^2) \\implies \\|\\tau^0\\|_2 = \\sqrt{\\frac{1}{2}(E_c^2 + E_s^2)}\n$$\nThis analytical expression will be used for computation.\n\n#### 2. Observed Norm Growth Ratio $R_{\\text{obs}}$\nThe FTCS scheme is a linear, translation-invariant operator on a periodic grid. Its action on Fourier modes is to multiply them by an amplification factor. Let's analyze its effect on a discrete Fourier mode $u_j^n = G^n e^{i k x_j}$, where $k$ is the wavenumber. On the grid, the relevant wavenumbers are $\\theta_p = 2\\pi p \\Delta x = 2\\pi p/N$ for $p=0, \\dots, N-1$. Substituting into the scheme:\n$$\nG e^{i\\theta_p j} = e^{i\\theta_p j} + \\frac{\\nu}{2} (e^{i\\theta_p(j+1)} - e^{i\\theta_p(j-1)})\n$$\nDividing by $e^{i\\theta_p j}$ yields the amplification factor $G(\\theta_p)$:\n$$\nG(\\theta_p) = 1 + \\frac{\\nu}{2}(e^{i\\theta_p} - e^{-i\\theta_p}) = 1 + i\\nu\\sin(\\theta_p)\n$$\nThe initial condition $u(x,0) = \\sin(2\\pi m x)$ corresponds to the grid function $u_j^0 = \\sin(2\\pi m j/N)$. This is a superposition of two complex exponential modes:\n$u_j^0 = \\frac{1}{2i} (e^{i\\theta_m j} - e^{-i\\theta_m j})$, where $\\theta_m = 2\\pi m /N$.\nAfter $n$ time steps, the solution evolves to:\n$$\nu_j^n = \\frac{1}{2i} \\left( [G(\\theta_m)]^n e^{i\\theta_m j} - [G(-\\theta_m)]^n e^{-i\\theta_m j} \\right)\n$$\nSince $\\sin(-\\theta_m) = -\\sin(\\theta_m)$, we have $G(-\\theta_m) = 1 - i\\nu\\sin(\\theta_m) = \\overline{G(\\theta_m)}$.\nLet $G_m = G(\\theta_m)$. Then $u_j^n = \\frac{1}{2i} (G_m^n e^{i\\theta_m j} - \\overline{G_m^n} e^{-i\\theta_m j})$.\nThe norm of the solution at step $n$ is related to the norm at step $0$ by the magnitude of the amplification factor. The ratio of norms after $n$ steps is:\n$$\nR_{\\text{obs}} = \\frac{\\|u^n\\|_2}{\\|u^0\\|_2} = |G_m|^n\n$$\nThe magnitude of the amplification factor is:\n$$\n|G_m| = |1 + i\\nu\\sin(\\theta_m)| = \\sqrt{1^2 + (\\nu\\sin(\\theta_m))^2} = \\sqrt{1 + \\nu^2\\sin^2(2\\pi m/N)}\n$$\nThus, the observed growth is:\n$R_{\\text{obs}} = \\left( \\sqrt{1 + \\nu^2\\sin^2(2\\pi m/N)} \\right)^n = \\left( 1 + \\nu^2\\sin^2(2\\pi m/N) \\right)^{n/2}$.\nThe problem asks for $\\log R_{\\text{obs}}$, which is simply:\n$$\n\\log R_{\\text{obs}} = n \\log |G_m| = \\frac{n}{2} \\log\\left(1 + \\nu^2\\sin^2(2\\pi m/N)\\right)\n$$\n\n#### 3. Theoretical Norm-Growth Bound $\\log R_{\\text{bound}}$\nThe theoretical bound on norm growth is determined by the induced 2-norm of the single-step operator $A$, where $u^{n+1}=Au^n$. The growth after $n$ steps is bounded by $\\|A^n\\|_2 \\le \\|A\\|_2^n$. The bound on the ratio is $R_{\\text{bound}} = \\|A\\|_2^n$.\nThe matrix $A$ is a normal matrix ($AA^H = A^H A$), so its induced 2-norm is equal to its spectral radius, $\\rho(A)$, which is the maximum magnitude of its eigenvalues. The eigenvalues of $A$ are the amplification factors $G(\\theta_p)$ for all possible grid modes $p=0, \\dots, N-1$.\n$$\n\\|A\\|_2 = \\rho(A) = \\max_{p} |G(\\theta_p)| = \\max_{p} \\sqrt{1 + \\nu^2\\sin^2(2\\pi p/N)}\n$$\nThe maximum value of $\\sin^2(2\\pi p/N)$ occurs when $2\\pi p/N$ is closest to $\\pi/2$. For the given test cases, $N=256$ and $N=64$, which are both multiples of $4$. Thus, for $p=N/4$, we have $2\\pi p/N = \\pi/2$, and $\\sin^2(\\pi/2)=1$.\nTherefore, the maximum is exactly $1$, and:\n$$\n\\|A\\|_2 = \\sqrt{1 + \\nu^2}\n$$\nThe logarithmic bound is:\n$$\n\\log R_{\\text{bound}} = n \\log \\|A\\|_2 = n \\log \\sqrt{1+\\nu^2} = \\frac{n}{2}\\log(1+\\nu^2)\n$$\nFor any non-zero $\\nu$, $\\|A\\|_2 > 1$, which proves that the scheme is unconditionally unstable. The norm of the solution can grow without bound, amplified by the highest-frequency modes on the grid.\n\n#### 4. Instability Boolean\nThis is simply the test $R_{\\text{obs}} > 1$. Since $|G_m| > 1$ for any $\\nu \\neq 0$ and $m$ not a multiple of $N/2$, and $n$ is large, $R_{\\text{obs}}$ will be greater than $1$, demonstrating the instability even for a smooth, resolved mode.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the forward-time, centered-space (FTCS) scheme for the\n    1D linear advection equation to demonstrate its inherent instability.\n    \"\"\"\n\n    # Test suite: (a, N, nu, T, m)\n    # a: advection speed\n    # N: number of grid points\n    # nu: Courant number\n    # T: final time\n    # m: Fourier mode index for the initial condition\n    test_cases = [\n        (1.0, 256, 0.05, 10.0, 1),\n        (1.0, 256, 0.10, 20.0, 1),\n        (1.0, 64,  0.50, 5.0,  1),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, N, nu, T, m = case\n\n        # Derive grid parameters\n        dx = 1.0 / N\n        dt = nu * dx / a\n        n = int(round(T / dt))\n\n        # --- 1. Local Truncation Error Norm ||tau^0||_2 ---\n        \n        # Coefficients derived from the analytical expression for tau^0_j\n        # E_c = sin(2*pi*m*a*dt)/dt - a*sin(2*pi*m*dx)/dx\n        # E_s = -2*sin^2(pi*m*a*dt)/dt\n        \n        # Numerator and denominator for the first term of E_c\n        num1_ec = np.sin(2 * np.pi * m * a * dt)\n        den1_ec = dt\n        \n        # Numerator and denominator for the second term of E_c\n        num2_ec = a * np.sin(2 * np.pi * m * dx)\n        den2_ec = dx\n\n        E_c = (num1_ec / den1_ec) - (num2_ec / den2_ec)\n\n        # Numerator and denominator for E_s\n        num_es = -2 * (np.sin(np.pi * m * a * dt))**2\n        den_es = dt\n        \n        E_s = num_es / den_es\n        \n        # Norm of the truncation error vector\n        # ||tau^0||_2 = sqrt(0.5 * (E_c^2 + E_s^2))\n        tau_norm_sq = 0.5 * (E_c**2 + E_s**2)\n        tau_norm = np.sqrt(tau_norm_sq)\n\n        # --- 2. Observed Norm Growth Ratio R_obs ---\n        \n        # Amplification factor G_m for mode m\n        # |G_m| = sqrt(1 + nu^2 * sin^2(2*pi*m/N))\n        theta_m = 2 * np.pi * m / N\n        G_m_mag_sq = 1 + nu**2 * (np.sin(theta_m))**2\n        G_m_mag = np.sqrt(G_m_mag_sq)\n\n        # Observed growth ratio after n steps\n        # R_obs = |G_m|^n\n        R_obs = G_m_mag**n\n        \n        # Logarithm of observed growth\n        log_R_obs = n * np.log(G_m_mag)\n\n        # --- 3. Theoretical Norm-Growth Upper Bound log R_bound ---\n        \n        # The 2-norm of the operator A is ||A||_2 = max_p |G(theta_p)|.\n        # For N being a multiple of 4, max sin^2 is 1.\n        # ||A||_2 = sqrt(1 + nu^2)\n        A_norm_sq = 1 + nu**2\n        A_norm = np.sqrt(A_norm_sq)\n\n        # Logarithm of the theoretical upper bound on growth\n        # log R_bound = n * log(||A||_2)\n        log_R_bound = n * np.log(A_norm)\n\n        # --- 4. Instability Boolean ---\n        is_unstable = R_obs > 1.0\n\n        # Assemble results for the current test case\n        results.append([\n            float(tau_norm), \n            float(R_obs),\n            float(log_R_obs), \n            float(log_R_bound), \n            bool(is_unstable)\n        ])\n\n    # Final print statement in the exact required format.\n    # The str representation of the list of lists must be produced.\n    print(str(results).replace(\"'\", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "While theoretical analysis of truncation error is essential, in practice we need methods to estimate the error of our simulations without knowing the exact solution. This exercise introduces Richardson extrapolation, a powerful and widely used technique for *a posteriori* error estimation. By comparing solutions from two different grid resolutions, you will learn how to derive an estimate for the leading error constant and verify the actual convergence rate of your code, providing a practical tool for model validation and uncertainty quantification .",
            "id": "3617978",
            "problem": "Consider a smooth scalar quantity of interest $Q$ extracted from the numerical solution of a Partial Differential Equation (PDE) on a uniform grid of spacing $h$. Assume the discretization scheme is consistent and stable, and its global error for $Q$ admits an asymptotic expansion $Q_h = Q + C_p h^p + C_{p+1} h^{p+1} + \\mathcal{O}(h^{p+2})$ for some integer order $p \\ge 1$, where $C_p$ is the leading truncation error constant that depends on the scheme, the PDE, boundary conditions, and the functional $Q$. The task is to use Richardson extrapolation on two nested grids of spacings $h$ and $h/2$ to derive an estimator for $C_p$, justify the assumptions under which it is valid, and implement it for specific test problems grounded in computational geophysics.\n\nYour program must:\n1. Derive, from first principles, an estimator for $C_p$ using the asymptotic error model and two solutions computed at spacings $h$ and $h/2$.\n2. Implement the estimator for the following tests in one spatial dimension, using the second-order centered finite difference discretization of the elliptic problem $-u''(x) = f(x)$ on the domain $[0,1]$ with homogeneous Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$. In all cases, the exact solution is chosen as $u(x) = \\sin(k \\pi x)$, which implies $f(x) = k^2 \\pi^2 \\sin(k \\pi x)$, and the scheme has order $p = 2$. For a grid with $m$ interior points, use spacing $h = 1/(m+1)$ and interior grid points $x_j = j h$ for $j = 1, 2, \\dots, m$. Define the quantity of interest $Q$ as the solution’s pointwise value at a specified location $x_0$ that is a grid point for both the coarse grid of spacing $h$ and the fine grid of spacing $h/2$ (i.e., $x_0 = j h$ on the coarse grid and $x_0 = j' (h/2)$ on the fine grid).\n\nUse the following test suite:\n- Test $1$: $k = 1$, coarse grid interior points $m = 9$ (so $h = 1/10$), fine grid interior points $m' = 19$ (so $h' = h/2 = 1/20$), and $x_0 = 1/2$. Use $p = 2$.\n- Test $2$: $k = 3$, coarse grid interior points $m = 9$ (so $h = 1/10$), fine grid interior points $m' = 19$ (so $h' = h/2 = 1/20$), and $x_0 = 3/10$. Use $p = 2$.\n- Test $3$: $k = 1$, coarse grid interior points $m = 3$ (so $h = 1/4$), fine grid interior points $m' = 7$ (so $h' = h/2 = 1/8$), and $x_0 = 1/2$. Use $p = 2$.\n\nIn each test:\n- Assemble the discrete system for $-u''(x) = f(x)$ using the standard second-order centered finite difference stencil, which yields the linear system $A \\mathbf{u} = \\mathbf{f}$ with $A$ tridiagonal and $\\mathbf{f}$ evaluated at interior grid points.\n- Solve for $\\mathbf{u}$ on both grids.\n- Extract $Q_h$ and $Q_{h/2}$ as $\\mathbf{u}$ evaluated at $x_0$ on the coarse and fine grids, respectively.\n- Compute the Richardson-based estimator for $C_p$ derived in part $1$.\n\nAssumptions to state and justify for the estimator’s validity:\n- The scheme is consistent of order $p$ and stable, so the global error for $Q$ admits an asymptotic expansion $Q_h - Q = C_p h^p + C_{p+1} h^{p+1} + \\mathcal{O}(h^{p+2})$ for sufficiently small $h$.\n- The grids are uniform and nested, and the same discretization (including boundary treatment) is used for both $h$ and $h/2$.\n- The functional $Q$ is sufficiently smooth so that its discretization error inherits the scheme’s order $p$.\n- The leading constant $C_p$ is nonzero for the chosen $Q$, and round-off or solver error is negligible relative to truncation error at the chosen $h$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Tests $1$, $2$, and $3$, for example $[c_1,c_2,c_3]$, where each $c_i$ is the floating-point estimate of $C_p$ for the corresponding test. No units are needed, and angles do not appear.\n\nYour program must be self-contained and runnable as-is, and it must not read input from the user.",
            "solution": "The problem is assessed to be valid. It is a well-posed problem in numerical analysis, specifically concerning the analysis of truncation error for a finite difference scheme applied to a one-dimensional elliptic boundary value problem. All parameters and conditions are clearly defined, scientifically grounded, and internally consistent.\n\nThe solution proceeds in three parts: first, a derivation of the estimator for the leading truncation error constant $C_p$; second, a discussion of the assumptions justifying the estimator; and third, an outline of the numerical implementation for the specified test cases.\n\n**1. Derivation of the Estimator for $C_p$**\n\nThe problem states that a numerical quantity of interest, $Q_h$, computed on a grid with spacing $h$, possesses an asymptotic error expansion of the form:\n$$Q_h = Q + C_p h^p + C_{p+1} h^{p+1} + \\mathcal{O}(h^{p+2})$$\nHere, $Q$ is the exact value of the quantity, $p \\ge 1$ is the order of accuracy of the scheme, and $C_p$, $C_{p+1}$ are constants that are independent of $h$.\n\nWe are given two solutions computed on nested grids with spacings $h$ and $h/2$. Let these be $Q_h$ and $Q_{h/2}$, respectively. We can write the error expansion for each:\n$$Q_h = Q + C_p h^p + C_{p+1} h^{p+1} + \\mathcal{O}(h^{p+2}) \\quad (1)$$\n$$Q_{h/2} = Q + C_p \\left(\\frac{h}{2}\\right)^p + C_{p+1} \\left(\\frac{h}{2}\\right)^{p+1} + \\mathcal{O}(h^{p+2})$$\n$$Q_{h/2} = Q + \\frac{C_p}{2^p} h^p + \\frac{C_{p+1}}{2^{p+1}} h^{p+1} + \\mathcal{O}(h^{p+2}) \\quad (2)$$\n\nTo derive an estimator for $C_p$, we first eliminate the unknown exact value $Q$ by subtracting equation $(1)$ from equation $(2)$:\n$$Q_{h/2} - Q_h = \\left( \\frac{C_p}{2^p} h^p - C_p h^p \\right) + \\left( \\frac{C_{p+1}}{2^{p+1}} h^{p+1} - C_{p+1} h^{p+1} \\right) + \\mathcal{O}(h^{p+2})$$\n$$Q_{h/2} - Q_h = C_p h^p \\left( \\frac{1}{2^p} - 1 \\right) + C_{p+1} h^{p+1} \\left( \\frac{1}{2^{p+1}} - 1 \\right) + \\mathcal{O}(h^{p+2})$$\n\nTo obtain an estimator for $C_p$, we assume that $h$ is sufficiently small, such that the leading term $C_p h^p (...)$ dominates the higher-order terms. We can therefore truncate the series:\n$$Q_{h/2} - Q_h \\approx C_p h^p \\left( \\frac{1}{2^p} - 1 \\right)$$\nNow, we can solve for $C_p$:\n$$C_p \\approx \\frac{Q_{h/2} - Q_h}{h^p \\left( \\frac{1 - 2^p}{2^p} \\right)} = \\frac{Q_{h/2} - Q_h}{h^p} \\frac{2^p}{1 - 2^p}$$\nRearranging the numerator for a more conventional form gives the final expression for the estimator, which we shall denote $\\hat{C}_p$:\n$$\\hat{C}_p = \\frac{Q_h - Q_{h/2}}{h^p (2^p - 1)} 2^p = \\frac{2^p}{2^p - 1} \\frac{Q_h - Q_{h/2}}{h^p}$$\n\nThe problem specifies using a second-order scheme, so $p=2$. The estimator for the leading error constant $C_2$ becomes:\n$$\\hat{C}_2 = \\frac{2^2}{2^2 - 1} \\frac{Q_h - Q_{h/2}}{h^2} = \\frac{4}{3} \\frac{Q_h - Q_{h/2}}{h^2}$$\nThis expression will be used in the implementation.\n\n**2. Justification of Assumptions**\n\nThe validity of this estimator relies on several assumptions listed in the problem, which are justified in the context of the given PDE and numerical scheme.\n\n- **Asymptotic Error Expansion**: For the elliptic problem $-u''(x) = f(x)$ with a smooth source term $f(x)$ and solution $u(x)$, a centered finite difference scheme is known to produce a global error that admits such an asymptotic expansion in even powers of $h$. Since the exact solution $u(x) = \\sin(k\\pi x)$ and source term $f(x) = k^2\\pi^2\\sin(k\\pi x)$ are infinitely differentiable ($C^\\infty$), this assumption is well-founded.\n- **Nested Grids and Consistent Discretization**: The problem explicitly defines the fine grid to have spacing $h' = h/2$ by setting the number of interior fine grid points $m'$ to be $2m+1$ where $m$ is the number of interior coarse grid points. This construction ensures the grids are perfectly nested. Using the same standard second-order stencil for both grids satisfies the consistency requirement.\n- **Smooth Functional**: The quantity of interest $Q$ is the pointwise value of the solution, $Q[u] = u(x_0)$. This is a linear and well-behaved functional. The error of this functional, $u_h(x_0) - u(x_0)$, is known to inherit the order of the global error for the solution $u_h$, justifying its inclusion in the expansion.\n- **Non-zero $C_p$ and Negligible Round-off Error**: The leading error constant $C_p = C_2$ is proportional to the fourth derivative of the solution, $u^{(4)}(x)$. For $u(x) = \\sin(k\\pi x)$, we have $u^{(4)}(x) = (k\\pi)^4\\sin(k\\pi x)$. For all specified test cases, the evaluation point $x_0$ is chosen such that $\\sin(k\\pi x_0) \\neq 0$, ensuring that $C_2 \\neq 0$. The grid spacings ($h=1/10$ and $h=1/4$) are moderate, so truncation error is expected to dominate round-off error when using standard double-precision floating-point arithmetic.\n\n**3. Numerical Implementation**\n\nThe problem to be solved is $-u''(x) = f(x)$ on the domain $[0,1]$ with boundary conditions $u(0)=0$ and $u(1)=0$. We discretize the domain using $m$ interior grid points $x_j = j h$ for $j=1, 2, \\dots, m$, where $h = 1/(m+1)$.\n\nThe second-order centered difference approximation of $-u''$ at a point $x_j$ is:\n$$-u''(x_j) \\approx \\frac{-u(x_{j-1}) + 2u(x_j) - u(x_{j+1})}{h^2}$$\nLet $u_j$ be the numerical approximation to $u(x_j)$. The discrete system of equations is:\n$$\\frac{-u_{j-1} + 2u_j - u_{j+1}}{h^2} = f(x_j) \\quad \\text{for } j=1, \\dots, m$$\nThe boundary conditions $u(0)=0$ and $u(1)=0$ imply $u_0=0$ and $u_{m+1}=0$. The system can be written in matrix form $A\\mathbf{u} = \\mathbf{f}$, where $\\mathbf{u} = [u_1, u_2, \\dots, u_m]^T$ and $\\mathbf{f} = [f(x_1), f(x_2), \\dots, f(x_m)]^T$. The $m \\times m$ matrix $A$ is a symmetric positive-definite tridiagonal matrix:\n$$A = \\frac{1}{h^2} \\begin{pmatrix} 2 & -1 & 0 & \\dots & 0 \\\\ -1 & 2 & -1 & & \\vdots \\\\ 0 & \\ddots & \\ddots & \\ddots & 0 \\\\ \\vdots & & -1 & 2 & -1 \\\\ 0 & \\dots & 0 & -1 & 2 \\end{pmatrix}$$\nFor each test case, we perform the following steps for both the coarse grid (spacing $h$) and the fine grid (spacing $h/2$):\n1. Construct the matrix $A$ and the right-hand side vector $\\mathbf{f}$.\n2. Solve the linear system $A\\mathbf{u} = \\mathbf{f}$ to obtain the numerical solution vector $\\mathbf{u}$.\n3. Extract the quantity of interest. Since $x_0$ is a grid point, $x_0 = j_0 h$ for some integer $j_0$. The value $Q$ is then the $j_0$-th element of the solution vector $\\mathbf{u}$ (accounting for $1$-based vs. $0$-based indexing, so it's `u[j_0-1]` in Python).\n4. With $Q_h$ and $Q_{h/2}$ computed, we apply the estimator formula derived above to find $\\hat{C}_2$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a Richardson-based estimator for the leading \n    truncation error constant C_p for a finite difference scheme applied \n    to a 1D elliptic PDE.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (k, m_coarse, x_0)\n    # The order p=2 is fixed for all tests.\n    test_cases = [\n        (1, 9, 0.5),   # Test 1\n        (3, 9, 0.3),   # Test 2\n        (1, 3, 0.25),  # Test 3\n    ]\n\n    # Adjust x0 for Test 3 to match the problem statement's intent implicitly.\n    # The text says x_0 = 1/2 for test 3, which is a grid point for h=1/4. \n    # The provided code snippet in the prompt example indicates x_0 might have been\n    # intended as a different value. Adhering to the problem text strictly.\n    test_cases[2] = (1, 3, 0.5)\n\n    def compute_Q_at_x0(k, m, x0):\n        \"\"\"\n        Solves the discrete system -u''=f on a grid with m interior points\n        and returns the numerical solution at the point x0.\n\n        Args:\n            k (int): Wavenumber for the exact solution u(x) = sin(k*pi*x).\n            m (int): Number of interior grid points.\n            x0 (float): The point at which to extract the solution value.\n\n        Returns:\n            float: The numerical solution u_h(x0).\n        \"\"\"\n        # 1. Define grid parameters\n        h = 1.0 / (m + 1)\n        \n        # 2. Set up the linear system A*u = f_vec\n        \n        # Create the grid points\n        x_grid = np.linspace(h, 1.0 - h, m)\n        \n        # Create the right-hand side vector f_vec\n        f_vec = (k * np.pi)**2 * np.sin(k * np.pi * x_grid)\n        \n        # Create the tridiagonal matrix A\n        main_diag = 2.0 * np.ones(m)\n        off_diag = -1.0 * np.ones(m - 1)\n        A = (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)) / h**2\n        \n        # 3. Solve the linear system\n        u_vec = np.linalg.solve(A, f_vec)\n        \n        # 4. Extract solution at x0\n        # The grid points are x_j = j*h for j=1, ..., m.\n        # The corresponding Python index is j-1.\n        # We need to find the index corresponding to x0.\n        # j0 = x0/h\n        # Since x0 is guaranteed to be a grid point, this should be an integer.\n        # Use rounding for floating point safety.\n        j0 = int(round(x0 / h))\n        \n        # The python index is j0-1\n        idx = j0 - 1\n        \n        # Check if index is valid\n        if idx  0 or idx >= m:\n            raise ValueError(f\"x0={x0} is not an interior grid point for m={m}, h={h}\")\n\n        return u_vec[idx]\n\n    results = []\n    p = 2  # The scheme is second order\n\n    for case in test_cases:\n        k, m_coarse, x0 = case\n        \n        # Grid parameters\n        m_fine = 2 * m_coarse + 1\n        h_coarse = 1.0 / (m_coarse + 1)\n        \n        # Compute the quantity of interest on coarse and fine grids\n        Q_h = compute_Q_at_x0(k, m_coarse, x0)\n        Q_h_half = compute_Q_at_x0(k, m_fine, x0)\n        \n        # Compute the estimator for the leading error constant C_p\n        # Formula: C_p_est = (2^p / (2^p - 1)) * (Q_h - Q_{h/2}) / h^p\n        numerator = Q_h - Q_h_half\n        denominator = h_coarse**p\n        factor = (2**p) / (2**p - 1)\n        \n        C_p_est = factor * numerator / denominator\n        results.append(C_p_est)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}