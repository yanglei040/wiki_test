{
    "hands_on_practices": [
        {
            "introduction": "在地球物理模型（如井周势流模拟）中，我们经常遇到包含端点奇异性的积分。当被积函数不光滑时，诸如辛普森法则这类标准的高阶求积方法会失去其预期的收敛速度和精度。本练习  将引导您实践一种强大的分析技术：通过非线性坐标变换（即“分级网格法”）来正则化被积函数。通过推导最优的变换指数，您将学会如何恢复数值方法的理论高阶收敛性，这是计算科学中的一项基本技能。",
            "id": "3612106",
            "problem": "在对井眼周围的轴对称势流进行建模时，一个常见的数值任务是计算形如下式的端点奇异积分\n$$\nI = \\int_{0}^{1} r^{\\alpha} q(r)\\,dr,\n$$\n其中 $q(r)$ 是 $[0,1]$ 上的光滑函数且 $q(0)\\neq 0$，指数 $\\alpha\\in(-1,0)$ 用于模拟核函数在源点附近物理上合理的代数奇异性。您计划使用复合辛普森法则来近似 $I$，已知当该法则应用于在积分区间上具有有界四阶导数的函数时，其全局收敛阶为四阶。\n\n由于端点奇异性在原始坐标 $r$ 中违反了光滑性要求，考虑通过变量替换 $r = t^{p}$（其中加密指数 $p>0$）来实现幂律网格加密，从而得到\n$$\nI = \\int_{0}^{1} p\\,t^{p-1}\\,(t^{p})^{\\alpha}\\,q(t^{p})\\,dt = \\int_{0}^{1} F(t)\\,dt,\n$$\n其中 $F(t) = p\\,t^{p(\\alpha+1)-1}\\,q(t^{p})$。然后，您将复合辛普森法则应用于 $t\\in[0,1]$ 的一个均匀划分上，该划分包含 $n$ 个子区间（其中 $n$ 为偶数且 $h = 1/n$）。\n\n从复合辛普森法则的基本误差原理和 $F^{(4)}(t)$ 在 $t=0$ 附近的主阶行为出发，推导能够使 $I$ 在变换后坐标 $t$ 中的复合辛普森近似恢复关于 $n$ 的四阶目标全局收敛阶的最小幂律加密指数 $p$。请以关于 $\\alpha$ 的单个闭式解析表达式的形式给出最优加密指数的最终答案。无需进行数值计算，答案中也无需包含单位。",
            "solution": "问题要求找出最小的幂律加密指数 $p$，该指数能够为一个特定类型的奇异积分恢复复合辛普森法则的四阶收敛性。\n\n待近似的积分是\n$$I = \\int_{0}^{1} r^{\\alpha} q(r)\\,dr$$\n其中 $q(r)$ 是 $[0,1]$ 上的光滑函数且 $q(0)\\neq 0$，奇异性指数为 $\\alpha \\in (-1,0)$。奇异点位于积分下限 $r=0$。\n\n复合辛普森法则的理论全局收敛阶为 $O(h^4)$（其中 $h$ 是子区间宽度），前提是被积函数在积分区间上至少四次连续可微，即属于 $C^4[0,1]$ 类。对于我们最初的积分，被积函数为 $f(r) = r^{\\alpha}q(r)$。由于 $\\alpha  0$，其导数将包含形如 $r^{\\alpha-k}$ 的项，这些项在 $r=0$ 处是无界的。因此，直接应用辛普森法则无法得到四阶收敛。\n\n为解决此问题，引入了变量替换 $r = t^p$，其中加密指数 $p0$。积分变换如下：\n$$dr = p\\,t^{p-1}\\,dt$$\n$$I = \\int_{0}^{1} (t^p)^{\\alpha} q(t^p) (p\\,t^{p-1}\\,dt) = \\int_{0}^{1} p\\,t^{p\\alpha+p-1}\\,q(t^p)\\,dt$$\n这可以写作 $I = \\int_{0}^{1} F(t)\\,dt$，其中新的被积函数为\n$$F(t) = p\\,t^{p(\\alpha+1)-1}\\,q(t^{p})$$\n我们现在将复合辛普森法则应用于这个在 $t$ 变量的均匀网格上的变换后的积分。为了恢复 $O(h^4)$ 的收敛阶，我们必须选择合适的 $p$，使得新的被积函数 $F(t)$ 在区间 $t \\in [0,1]$ 上足够光滑。\n\n对于带有端点奇异性的被积函数，求积法则的收敛阶由被积函数的光滑性决定。对于在 $t=0$ 附近表现为 $t^\\beta$ 的被积函数，复合辛普森法则（一种四阶方法）的收敛阶通常由 $O(h^{\\min(4, \\beta+1)})$ 给出。为达到四阶收敛，我们必须确保 $\\min(4, \\beta+1) = 4$，这意味着条件 $\\beta+1 \\ge 4$，即 $\\beta \\ge 3$。\n\n让我们来确定变换后函数 $F(t)$ 的有效指数 $\\beta$。函数 $q(r)$ 在 $[0,1]$ 上是光滑的，因此它在 $r=0$ 附近可以进行泰勒级数展开：\n$$q(r) = q(0) + q'(0)r + \\frac{q''(0)}{2!}r^2 + \\dots$$\n由于 $q(0) \\neq 0$，我们代入 $r=t^p$ 来找出当 $t$ 很小时 $q(t^p)$ 的行为：\n$$q(t^p) = q(0) + q'(0)t^p + O(t^{2p})$$\n现在，我们将此代入 $F(t)$ 的表达式中：\n$$F(t) = p\\,t^{p(\\alpha+1)-1}\\,[q(0) + q'(0)t^p + \\dots]$$\n$$F(t) = p\\,q(0)\\,t^{p(\\alpha+1)-1} + p\\,q'(0)\\,t^{p(\\alpha+1)-1+p} + \\dots$$\n由于 $p0$，决定 $F(t)$ 在 $t=0$ 附近行为的主阶项是第一项。因此，有效奇异性指数为：\n$$\\beta_{\\text{eff}} = p(\\alpha+1)-1$$\n为了恢复四阶收敛，我们必须满足条件 $\\beta_{\\text{eff}} \\ge 3$：\n$$p(\\alpha+1)-1 \\ge 3$$\n$$p(\\alpha+1) \\ge 4$$\n已知 $\\alpha \\in (-1,0)$，这意味着 $\\alpha+1$ 在区间 $(0,1)$ 内。因为 $\\alpha+1  0$，我们可以用它来除不等式两边而不改变不等号的方向：\n$$p \\ge \\frac{4}{\\alpha+1}$$\n问题要求的是恢复目标收敛阶的*最小*幂律加密指数 $p$。这对应于满足所推导条件的最小值，该值通过取等号得到：\n$$p = \\frac{4}{\\alpha+1}$$\n\n让我们验证一下，如问题前提所暗示的，这个 $p$ 的选择确实使得被积函数的四阶导数有界。\n如果我们设定 $p = 4/(\\alpha+1)$，那么 $\\beta_{\\text{eff}} = p(\\alpha+1)-1 = 4-1=3$。函数 $F(t)$ 的形式为：\n$$F(t) = p\\,q(0)\\,t^3 + p\\,q'(0)\\,t^{3+p} + \\dots$$\n这是一个由项 $C_k t^{\\gamma_k}$ 构成的级数，其中指数为 $\\gamma_0=3, \\gamma_1=3+p$ 等。\n我们来考虑四阶导数 $F^{(4)}(t)$。主项的导数 $\\frac{d^4}{dt^4}(p\\,q(0)\\,t^3)$ 为零。因此，$F^{(4)}(t)$ 的主阶行为由级数中下一项的导数决定：\n$$\\frac{d^4}{dt^4} (p\\,q'(0)\\,t^{3+p}) = p\\,q'(0)\\,(3+p)(2+p)(1+p)p\\,t^{p-1} + \\dots$$\n$F^{(4)}(t)$ 的主项表现为 $t^{p-1}$。为了使 $F^{(4)}(t)$ 在 $[0,1]$ 上有界，其主项指数必须为非负数：$p-1 \\ge 0$，即 $p \\ge 1$。\n我们选择的 $p$ 值为 $p = 4/(\\alpha+1)$。由于 $\\alpha \\in (-1,0)$，我们有 $0  \\alpha+1  1$。这意味着 $p > 4$。因此，$p \\ge 1$ 的条件是完全满足的。\n因此，选择 $p=4/(\\alpha+1)$ 可确保 $F^{(4)}(t)$ 有界（实际上，$F^{(4)}(0)=0$），这是复合辛普森法则表现出 $O(h^4)$ 收敛阶的标准条件。任何更小的 $p$ 值都会导致指数 $\\beta_{\\text{eff}}  3$，从而违反光滑性要求并降低收敛阶。因此，这是最小值。",
            "answer": "$$\\boxed{\\frac{4}{\\alpha+1}}$$"
        },
        {
            "introduction": "在数值计算中，特别是在波动现象的建模中，我们有时需要计算两个几乎相等的大数之差。这种被称为“灾难性相消”的运算会导致有效数字的严重损失，从而产生极不准确的结果。本练习  将锻炼您诊断并修复此类数值不稳定性的能力。您将运用三角恒等式，在计算前将被积函数进行解析重构，将其转化为一个数值稳定的形式，这是确保结果可靠与准确的关键预处理步骤。",
            "id": "3612057",
            "problem": "在对水平分层声学半空间中近共振压缩波模式的衰减叠加进行建模时，固定接收器偏移距处时域压力轨迹的频域表示，经过逆变换后，可以写成一个实值振荡积分。对于两个相邻共振的贡献，一个简化但科学上一致的一维代理是积分\n$$\nI(\\alpha,\\omega,\\delta) \\equiv \\int_{0}^{\\infty} \\exp(-\\alpha x)\\,\\big[\\cos(\\omega x) - \\cos((\\omega+\\delta)x)\\big]\\,\\mathrm{d}x,\n$$\n其中 $\\alpha0$ 是有效衰减系数（源于粘滞声学损耗），$\\omega0$ 是中心角频率，$\\delta0$ 是一个小的失谐量，代表两个模态频率的近重合。在数值积分中，当 $\\delta$ 很小时，分别计算 $\\int_{0}^{\\infty} \\exp(-\\alpha x)\\cos(\\omega x)\\,\\mathrm{d}x$ 和 $\\int_{0}^{\\infty} \\exp(-\\alpha x)\\cos((\\omega+\\delta)x)\\,\\mathrm{d}x$ 这两项然后相减的朴素计算方法，会倾向于遭受灾难性抵消。\n\n从拉普拉斯变换的基本定义和基本三角恒等式出发，且不使用任何专门的积分误差公式，完成以下任务：\n\n1. 根据减法的条件数和被积函数的结构，解释为什么当 $\\delta$ 很小时，如果分别计算两个贡献然后相减，会预期发生灾难性抵消。\n\n2. 提出一种对被积函数的解析预处理或重排方法，通过避免直接减去两个几乎相等的大量贡献，来提高小 $\\delta$ 情况下的数值积分稳定性。你的重排必须在代数上是精确的，保持 $I(\\alpha,\\omega,\\delta)$ 的值，并明确指出在 $\\delta$ 很小时控制所得被积函数幅度的任何小因子。\n\n3. 使用所提出的预处理方法，为 $I(\\alpha,\\omega,\\delta)$ 推导一个对所有 $\\alpha0$, $\\omega0$ 和 $\\delta0$ 都有效的精确闭式表达式。推导必须从基本性质（如有界函数的拉普拉斯变换定义和标准的积化和差三角恒等式）开始，并一步步进行到最终的简化表达式。\n\n以 $\\alpha$、$\\omega$ 和 $\\delta$ 的单个闭式解析表达式的形式提供最终答案。无需进行数值计算。",
            "solution": "问题要求分析积分 $I(\\alpha,\\omega,\\delta) \\equiv \\int_{0}^{\\infty} \\exp(-\\alpha x)\\,\\big[\\cos(\\omega x) - \\cos((\\omega+\\delta)x)\\big]\\,\\mathrm{d}x$，其中参数 $\\alpha0$，$\\omega0$，$\\delta0$。按要求将解答分为三部分呈现。\n\n第1部分：灾难性抵消的解释\n\n对该积分的朴素数值计算方法涉及计算两个独立的积分 $I_1$ 和 $I_2$，然后求它们的差：\n$$\nI_1 = \\int_{0}^{\\infty} \\exp(-\\alpha x)\\cos(\\omega x)\\,\\mathrm{d}x\n$$\n$$\nI_2 = \\int_{0}^{\\infty} \\exp(-\\alpha x)\\cos((\\omega+\\delta)x)\\,\\mathrm{d}x\n$$\n原始积分的值则为 $I(\\alpha,\\omega,\\delta) = I_1 - I_2$。\n\n这些积分是拉普拉斯变换的实例。函数 $f(t)$ 的拉普拉斯变换定义为 $\\mathcal{L}\\{f(t)\\}(s) = \\int_0^\\infty \\exp(-st)f(t)\\,\\mathrm{d}t$。一个标准的拉普拉斯变换对是余弦函数的变换：$\\mathcal{L}\\{\\cos(kt)\\}(s) = \\frac{s}{s^2+k^2}$。\n应用此公式，并令 $s=\\alpha$，我们可以求出 $I_1$ 和 $I_2$ 的精确值：\n$$\nI_1 = \\mathcal{L}\\{\\cos(\\omega x)\\}(\\alpha) = \\frac{\\alpha}{\\alpha^2 + \\omega^2}\n$$\n$$\nI_2 = \\mathcal{L}\\{\\cos((\\omega+\\delta)x)\\}(\\alpha) = \\frac{\\alpha}{\\alpha^2 + (\\omega+\\delta)^2}\n$$\n问题指出 $\\delta$ 是一个小的失谐量，意味着 $\\delta \\ll \\omega$。当 $\\delta \\to 0$ 时，$(\\omega+\\delta)^2$ 项趋近于 $\\omega^2$。因此，分母 $\\alpha^2 + (\\omega+\\delta)^2$ 趋近于 $\\alpha^2 + \\omega^2$。这意味着 $I_2$ 变得非常接近 $I_1$。\n\n当两个几乎相等的数在有限精度算术中相减时，就会发生灾难性抵消。如果 $I_1$ 和 $I_2$ 是通过数值方法（例如，使用积分法则）计算的，它们会以具有有限有效数字的浮点数形式存储。当 $\\delta$ 很小时，$I_1$ 和 $I_2$ 将几乎相同。它们的差 $I_1 - I_2$ 将导致开头的、最高位的有效数字相互抵消。减法的结果将由较低位的有效数字决定，而这些数字最容易受到计算 $I_1$ 和 $I_2$ 过程中累积的舍入误差的影响。这会导致结果带有巨大的相对误差和严重的精度损失。当操作数相近时，减法运算是病态的，这正是 $\\delta$ 很小时朴素计算方案中所面临的情况。\n\n第2部分：为提高数值稳定性的解析预处理\n\n为了避免减去几乎相等的量，我们可以将被积函数重排成一个不涉及差的形式。关键是使用三角恒等式来转换表达式 $\\cos(\\omega x) - \\cos((\\omega+\\delta)x)$。我们使用两个余弦之差的和差化积恒等式：\n$$\n\\cos(A) - \\cos(B) = -2 \\sin\\left(\\frac{A+B}{2}\\right) \\sin\\left(\\frac{A-B}{2}\\right)\n$$\n令 $A = \\omega x$ 且 $B = (\\omega+\\delta)x$。于是我们有：\n$$\n\\frac{A+B}{2} = \\frac{\\omega x + (\\omega+\\delta)x}{2} = \\frac{(2\\omega+\\delta)x}{2} = \\left(\\omega + \\frac{\\delta}{2}\\right)x\n$$\n$$\n\\frac{A-B}{2} = \\frac{\\omega x - (\\omega+\\delta)x}{2} = \\frac{-\\delta x}{2}\n$$\n将这些代入恒等式，并使用性质 $\\sin(-z) = -\\sin(z)$，我们得到：\n$$\n\\cos(\\omega x) - \\cos((\\omega+\\delta)x) = -2 \\sin\\left(\\left(\\omega + \\frac{\\delta}{2}\\right)x\\right) \\sin\\left(-\\frac{\\delta x}{2}\\right) = 2 \\sin\\left(\\left(\\omega + \\frac{\\delta}{2}\\right)x\\right) \\sin\\left(\\frac{\\delta x}{2}\\right)\n$$\n现在，该积分可以通过这种代数上精确的重排重写为：\n$$\nI(\\alpha,\\omega,\\delta) = \\int_{0}^{\\infty} \\exp(-\\alpha x) \\left[ 2 \\sin\\left(\\left(\\omega + \\frac{\\delta}{2}\\right)x\\right) \\sin\\left(\\frac{\\delta x}{2}\\right) \\right] \\mathrm{d}x\n$$\n对于小的 $\\delta$ 值，这种形式是数值稳定的。对于小的自变量 $z$，$ \\sin(z) \\approx z$。因此，对于小的 $\\delta$，项 $\\sin(\\frac{\\delta x}{2})$ 近似等于 $\\frac{\\delta x}{2}$。所以被积函数近似地与 $\\delta$ 成正比：\n$$\n\\text{Integrand} \\approx \\exp(-\\alpha x) \\cdot 2 \\sin\\left(\\left(\\omega + \\frac{\\delta}{2}\\right)x\\right) \\cdot \\frac{\\delta x}{2} = \\delta x \\exp(-\\alpha x) \\sin\\left(\\left(\\omega + \\frac{\\delta}{2}\\right)x\\right)\n$$\n对于小 $\\delta$ 值，控制积分幅度的那个小因子 $\\delta$ 现在是被积函数中一个显式的乘法因子。将数值积分方案应用于这种新形式，是对一个本身就很小的函数进行积分，结果将是一个直接计算出的小数，从而避免了灾难性抵消。\n\n第3部分：闭式表达式的推导\n\n为了推导 $I(\\alpha,\\omega,\\delta)$ 的精确闭式表达式，我们从其定义出发，利用积分的线性和已知的拉普拉斯变换形式。尽管第2部分中的预处理对数值稳定性至关重要，但获得最终解析形式的最直接路径是对 $I_1$ 和 $I_2$ 的精确表达式进行解析减法。\n如第1部分所述：\n$$\nI(\\alpha,\\omega,\\delta) = I_1 - I_2 = \\frac{\\alpha}{\\alpha^2 + \\omega^2} - \\frac{\\alpha}{\\alpha^2 + (\\omega+\\delta)^2}\n$$\n这个表达式是精确的，但在数值上不稳定。我们通过通分来合并这两个分数：\n$$\nI(\\alpha,\\omega,\\delta) = \\alpha \\left[ \\frac{1}{\\alpha^2 + \\omega^2} - \\frac{1}{\\alpha^2 + (\\omega+\\delta)^2} \\right]\n$$\n$$\nI(\\alpha,\\omega,\\delta) = \\alpha \\left[ \\frac{(\\alpha^2 + (\\omega+\\delta)^2) - (\\alpha^2 + \\omega^2)}{(\\alpha^2 + \\omega^2)(\\alpha^2 + (\\omega+\\delta)^2)} \\right]\n$$\n现在，我们通过展开 $(\\omega+\\delta)^2$ 项来化简分子：\n$$\n(\\alpha^2 + (\\omega+\\delta)^2) - (\\alpha^2 + \\omega^2) = \\alpha^2 + (\\omega^2 + 2\\omega\\delta + \\delta^2) - \\alpha^2 - \\omega^2\n$$\n$\\alpha^2$ 和 $\\omega^2$ 项相互抵消，剩下：\n$$\n2\\omega\\delta + \\delta^2 = \\delta(2\\omega + \\delta)\n$$\n将这个化简后的分子代回 $I(\\alpha,\\omega,\\delta)$ 的表达式中，我们得到最终的闭式结果：\n$$\nI(\\alpha,\\omega,\\delta) = \\frac{\\alpha \\delta (2\\omega + \\delta)}{(\\alpha^2 + \\omega^2)(\\alpha^2 + (\\omega+\\delta)^2)}\n$$\n这个表达式与最初的两个项之差在代数上是等价的，但对所有有效的参数值（包括小的 $\\delta$）都是数值稳定的，因为它不涉及几乎相等的量的减法。当 $\\delta \\to 0$ 时，分子趋近于 0，整个表达式正确且平滑地趋于 0。",
            "answer": "$$\n\\boxed{\\frac{\\alpha\\delta(2\\omega+\\delta)}{(\\alpha^2+\\omega^2)(\\alpha^2+(\\omega+\\delta)^2)}}\n$$"
        },
        {
            "introduction": "关于求积误差的理论探讨需要通过实际应用来巩固。许多地球物理问题中的被积函数具有尖锐的局部峰值，这对数值方法构成了严峻挑战。本编码练习  提供了一个动手实践的机会，让您直接见证固定步长方法与现代自适应求积方法在处理这类问题时的表现差异。通过在一系列精心设计的“对抗性”积分上实现并比较这两种方法，您将对自适应求积在科学计算中的鲁棒性和必要性获得具体而深刻的理解。",
            "id": "3612054",
            "problem": "考虑在层状介质格林函数公式和地球物理响应函数谱域表示中出现的实值积分的数值评估。这些积分通常包含位于自变量（例如，波数或频率）实轴附近的复共轭极点的贡献，导致被积函数中出现尖锐的局部峰值，并对求积误差敏感。\n\n设被积函数在单位区间上定义为\n$$\nf(x;\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A}) = \\sum_{j=1}^{m} \\frac{A_j}{(x - c_j)^2 + \\epsilon_j^2},\n$$\n其中 $\\mathbf{c} = (c_1,\\dots,c_m)$ 是实数中心，满足 $c_j \\in [0,1]$；$\\boldsymbol{\\epsilon} = (\\epsilon_1,\\dots,\\epsilon_m)$ 是正实数，满足 $\\epsilon_j  0$，表示每个极点到积分路径的距离；$\\mathbf{A} = (A_1,\\dots,A_m)$ 是实数振幅。函数 $f$ 在 $[0,1]$ 上是光滑的，其复奇点位于 $x = c_j \\pm i \\epsilon_j$。\n\n定义精确积分\n$$\nI_{\\text{exact}}(\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A}) = \\int_0^1 f(x;\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A}) \\, dx.\n$$\n定义极点配置的以下对抗性特征度量：\n- 极点到积分路径的最小距离：\n$$\n\\epsilon_{\\min} = \\min_{j} \\epsilon_j.\n$$\n- 极点中心之间的最小间距：\n$$\n\\delta_{\\min} = \\min_{i \\neq j} |c_i - c_j|.\n$$\n（当 $m=1$ 时，按惯例取 $\\delta_{\\min}$ 为 $1$。）\n- 最小边界邻近度（到端点的距离）：\n$$\n\\beta_{\\min} = \\min_j \\left( \\min\\{c_j, 1 - c_j\\} \\right).\n$$\n\n对于每个问题实例，计算 $I_{\\text{exact}}$，然后使用以下方法计算数值近似：\n1. 复合 Simpson 法则，将 $[0,1]$ 均匀划分为 $N$ 个相等的子区间（其中 $N$ 为偶数）。将该近似值记为 $I_{\\text{Simpson}}$。\n2. 一种基于 Gauss–Kronrod 思想的自适应求积方法，该方法使用局部误差估计递归地划分孑区间，以满足严格的绝对和相对容差。将该近似值记为 $I_{\\text{adaptive}}$。\n\n对于每种方法，计算绝对误差\n$$\nE_{\\text{abs}} = |I_{\\text{method}} - I_{\\text{exact}}|\n$$\n和相对误差\n$$\nE_{\\text{rel}} = \\frac{|I_{\\text{method}} - I_{\\text{exact}}|}{|I_{\\text{exact}}|}.\n$$\n当相对误差超过特定于方法的阈值时，即认为出现数值误差尖峰：\n- 对于自适应方法，如果 $E_{\\text{rel}}  T_{\\text{adaptive}}$，则检测到尖峰，其中 $T_{\\text{adaptive}} = 10^{-6}$。\n- 对于复合 Simpson 法则，如果 $E_{\\text{rel}}  T_{\\text{Simpson}}$，则检测到尖峰，其中 $T_{\\text{Simpson}} = 10^{-2}$。\n\n您的程序必须实现：\n- 使用积分学第一性原理对形式为 $1/((x-c)^2+\\epsilon^2)$ 的有理函数进行推导，从而精确计算 $I_{\\text{exact}}(\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A})$。\n- 对每个测试用例，在 $[0,1]$ 上使用给定的 $N$ 实现复合 Simpson 法则。\n- 使用足够小的严格容差的自适应求积方法，以揭示对聚类极点的敏感性。\n\n使用这些方法，构造在积分路径附近具有聚类极点的被积函数，并评估其对误差尖峰的鲁棒性。对于每个测试用例，报告值 $I_{\\text{exact}}$、$I_{\\text{adaptive}}$、$E_{\\text{abs,adaptive}}$、$I_{\\text{Simpson}}$、$E_{\\text{abs,Simpson}}$，以及特征 $\\epsilon_{\\min}$、$\\delta_{\\min}$、$\\beta_{\\min}$，同时附上指示两种方法是否出现尖峰的布尔值。\n\n测试套件：\n在以下四个案例上评估程序，每个案例由 $(\\mathbf{c}, \\boldsymbol{\\epsilon}, \\mathbf{A}, N)$ 指定，其中 $m$ 等于每个向量的长度：\n1. 理想路径（极点分离良好，距离适中）：\n   - $\\mathbf{c} = (0.30, 0.55, 0.80)$\n   - $\\boldsymbol{\\epsilon} = (5\\times 10^{-2}, 4\\times 10^{-2}, 6\\times 10^{-2})$\n   - $\\mathbf{A} = (1.0, 0.8, 0.6)$\n   - $N = 128$。\n2. 内部聚类（中心间距小，距离小）：\n   - $\\mathbf{c} = (0.620, 0.625, 0.627)$\n   - $\\boldsymbol{\\epsilon} = (1.2\\times 10^{-3}, 9\\times 10^{-4}, 1.1\\times 10^{-3})$\n   - $\\mathbf{A} = (1.0, 0.8, 0.7)$\n   - $N = 128$。\n3. 近边界聚类（极点靠近端点 $x=1$）：\n   - $\\mathbf{c} = (0.995, 0.997)$\n   - $\\boldsymbol{\\epsilon} = (2\\times 10^{-3}, 2\\times 10^{-3})$\n   - $\\mathbf{A} = (1.0, 0.9)$\n   - $N = 128$。\n4. 病态聚类（距离极小且在 $x=0$ 附近紧密聚类）：\n   - $\\mathbf{c} = (0.0500, 0.0502, 0.0504)$\n   - $\\boldsymbol{\\epsilon} = (2.0\\times 10^{-4}, 2.5\\times 10^{-4}, 2.0\\times 10^{-4})$\n   - $\\mathbf{A} = (1.0, 1.0, 1.0)$\n   - $N = 128$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个列表。每个测试用例的列表必须按以下顺序排列\n$$\n\\left[ I_{\\text{exact}},\\ I_{\\text{adaptive}},\\ E_{\\text{abs,adaptive}},\\ I_{\\text{Simpson}},\\ E_{\\text{abs,Simpson}},\\ \\epsilon_{\\min},\\ \\delta_{\\min},\\ \\beta_{\\min},\\ \\sigma_{\\text{adaptive}},\\ \\sigma_{\\text{Simpson}} \\right],\n$$\n其中 $\\sigma_{\\text{adaptive}}$ 和 $\\sigma_{\\text{Simpson}}$ 是布尔值，指示相应方法是否发生了尖峰。因此，最终输出的形式为\n$$\n\\left[\\ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot] \\ \\right].\n$$\n不涉及物理单位；所有量均为无量纲实数，反正切函数中的角度应以弧度处理。",
            "solution": "该问题已经过验证，被确定为数值分析领域内一个适定、有科学依据的任务，具体应用于计算地球物理学中的一个问题原型。所有提供的数据和定义都是完整、一致且在数学上是合理的。该问题要求将一种固定步长的数值积分方法（复合 Simpson 法则）与一种自适应方法进行比较，用于处理一类以尖锐、聚类峰值为特征的具有挑战性的被积函数。该分析将在四个旨在探究不同失效模式的测试用例套件上进行。\n\n解决方案首先推导精确积分的解析形式。随后，定义数值方法和特征度量，并概述实现策略，为提供的 Python 代码奠定基础。\n\n### 1. 基于原理的设计：解析与数值评估\n\n问题的核心在于函数 $f(x;\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A})$ 在区间 $[0,1]$ 上的积分。\n$$\nf(x;\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A}) = \\sum_{j=1}^{m} \\frac{A_j}{(x - c_j)^2 + \\epsilon_j^2}\n$$\n这个函数是洛伦兹函数的和。由于积分是线性算子，和的积分等于积分的和：\n$$\nI_{\\text{exact}} = \\int_0^1 f(x;\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A}) \\, dx = \\sum_{j=1}^{m} A_j \\int_0^1 \\frac{1}{(x - c_j)^2 + \\epsilon_j^2} \\, dx\n$$\n因此，问题简化为求基本有理函数的定积分。\n\n#### 1.1. 精确积分的推导\n我们需要计算积分 $J_j = \\int_0^1 \\frac{1}{(x - c_j)^2 + \\epsilon_j^2} \\, dx$。\n这是一个标准的积分形式。我们使用换元法，令 $u = \\frac{x-c_j}{\\epsilon_j}$，这意味着 $du = \\frac{1}{\\epsilon_j}dx$。积分变换如下：\n$$\n\\int \\frac{1}{(x - c_j)^2 + \\epsilon_j^2} \\, dx = \\int \\frac{1}{\\epsilon_j^2 \\left( \\left(\\frac{x-c_j}{\\epsilon_j}\\right)^2 + 1 \\right)} \\, dx = \\frac{1}{\\epsilon_j^2} \\int \\frac{1}{u^2+1} (\\epsilon_j \\, du) = \\frac{1}{\\epsilon_j} \\int \\frac{1}{u^2+1} \\, du\n$$\n其不定积分是众所周知的：\n$$\n\\int \\frac{1}{u^2+1} \\, du = \\arctan(u) + C\n$$\n换回 $x$，我们函数的原函数是：\n$$\n\\int \\frac{1}{(x - c_j)^2 + \\epsilon_j^2} \\, dx = \\frac{1}{\\epsilon_j} \\arctan\\left(\\frac{x-c_j}{\\epsilon_j}\\right) + C\n$$\n现在，我们在区间 $[0,1]$ 上计算定积分：\n$$\nJ_j = \\left[ \\frac{1}{\\epsilon_j} \\arctan\\left(\\frac{x-c_j}{\\epsilon_j}\\right) \\right]_0^1 = \\frac{1}{\\epsilon_j} \\left( \\arctan\\left(\\frac{1-c_j}{\\epsilon_j}\\right) - \\arctan\\left(\\frac{0-c_j}{\\epsilon_j}\\right) \\right)\n$$\n利用性质 $\\arctan(-z) = -\\arctan(z)$，上式可简化为：\n$$\nJ_j = \\frac{1}{\\epsilon_j} \\left( \\arctan\\left(\\frac{1-c_j}{\\epsilon_j}\\right) + \\arctan\\left(\\frac{c_j}{\\epsilon_j}\\right) \\right)\n$$\n总的精确积分 $I_{\\text{exact}}$ 是通过对所有极点求和得到的，并按各自的振幅 $A_j$ 加权：\n$$\nI_{\\text{exact}}(\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A}) = \\sum_{j=1}^{m} \\frac{A_j}{\\epsilon_j} \\left[ \\arctan\\left(\\frac{1-c_j}{\\epsilon_j}\\right) + \\arctan\\left(\\frac{c_j}{\\epsilon_j}\\right) \\right]\n$$\n这个公式提供了一种计算基准真相的方法，数值方法将以此为基准进行评估。\n\n#### 1.2. 数值求积方法\n\n**复合 Simpson 法则：**\n这是一种来自 Newton-Cotes 族的固定步长方法，它在每对子区间上用一个二次多项式来近似被积函数。对于一个积分 $\\int_a^b g(x) \\, dx$，将其划分为 $N$ 个等宽的子区间（其中 $N$ 必须是偶数），宽度为 $h = (b-a)/N$，其公式为：\n$$\nI_{\\text{Simpson}} \\approx \\frac{h}{3} \\left[ g(x_0) + 4\\sum_{k=1}^{N/2} g(x_{2k-1}) + 2\\sum_{k=1}^{N/2-1} g(x_{2k}) + g(x_N) \\right]\n$$\n其中 $x_k = a+kh$。对于我们的问题，$a=0$, $b=1$，且 $h=1/N$。这种方法对于光滑、行为良好的被积函数是简单且高效的。然而，如果固定网格不能充分解析具有局部尖锐特征的函数，其精度会显著下降，而这正是本测试所要考察的情景。\n\n**自适应求积 (Gauss-Kronrod)：**\n与固定步长方法不同，自适应求积算法根据局部误差估计来细化积分区间的划分。在被积函数复杂或变化迅速的区域，区间被划分得更细；在被积函数平滑的区域，则划分得更粗。该问题指定了一种基于 Gauss-Kronrod 思想的方法。这涉及使用两个不同阶数的嵌套求积规则（例如，一个 $7$ 点 Gauss 规则和一个 $15$ 点 Kronrod 规则）来估计子区间上的积分和误差。如果误差过大，该子区间将被分裂，并递归应用此过程。这种方法对于具有尖峰的被积函数非常有效，因为它将计算量集中在最需要的地方。实现将使用 `scipy.integrate.quad` 函数，它是 Fortran 库 QUADPACK 的一个健壮封装，而 QUADPACK 正是这一原理的实现。为确保基准测试的最高精度，将向 `quad` 函数请求非常严格的绝对和相对误差容差（例如，$10^{-14}$）。\n\n### 2. 对抗性度量与误差分析\n\n问题定义了三个度量来量化一个被积函数实例的“难度”：\n- $\\epsilon_{\\min} = \\min_{j} \\epsilon_j$：任意极点到实轴的最小距离。较小的值会导致被积函数中出现更尖锐和更高的峰。\n- $\\delta_{\\min} = \\min_{i \\neq j} |c_i - c_j|$：极点中心之间的最小间距。较小的值意味着峰值更紧密地聚类，使得固定网格难以单独解析它们。对于 $m=1$，$\\delta_{\\min}$ 按惯例为 $1$。\n- $\\beta_{\\min} = \\min_j \\left( \\min\\{c_j, 1 - c_j\\} \\right)$：任意极点到积分边界 $[0,1]$ 的最小邻近度。靠近边界的极点可能对基于多项式近似的方法构成挑战。\n\n每种数值方法的性能通过其绝对误差 $E_{\\text{abs}} = |I_{\\text{method}} - I_{\\text{exact}}|$ 和相对误差 $E_{\\text{rel}} = E_{\\text{abs}} / |I_{\\text{exact}}|$ 来评估。如果相对误差超过预定义的阈值，则记录一个误差“尖峰”：对于自适应方法为 $T_{\\text{adaptive}} = 10^{-6}$，对于 Simpson 法则为 $T_{\\text{Simpson}} = 10^{-2}$。这些阈值反映了对于一个复杂的自适应程序与一个基本的固定步长规则的不同精度期望。\n\n### 3. 实现计划\n\n整体解决方案使用 Python 实现。一个主函数处理指定的四个测试用例中的每一个。对于每个案例：\n1. 使用参数 $(\\mathbf{c}, \\boldsymbol{\\epsilon}, \\mathbf{A}, N)$ 来定义特定的被积函数 $f(x)$。\n2. 使用推导出的反正切公式计算精确积分 $I_{\\text{exact}}$。\n3. 使用具有严格容差的 `scipy.integrate.quad` 找到自适应求积近似值 $I_{\\text{adaptive}}$。\n4. 使用具有 $N$ 个区间的自定义实现来计算复合 Simpson 法则近似值 $I_{\\text{Simpson}}$。\n5. 从极点参数计算对抗性度量 $\\epsilon_{\\min}$、$\\delta_{\\min}$ 和 $\\beta_{\\min}$。\n6. 通过与 $I_{\\text{exact}}$ 比较来计算绝对误差 $E_{\\text{abs,adaptive}}$ 和 $E_{\\text{abs,Simpson}}$。\n7. 计算相对误差以确定布尔尖峰指示符 $\\sigma_{\\text{adaptive}}$ 和 $\\sigma_{\\text{Simpson}}$。\n8. 将这十个结果值收集到该测试用例的列表中。\n最后，将所有四个案例的列表编译并格式化为表示列表的列表的单个字符串，以符合最终输出的要求。这种结构有助于直接比较各种方法的性能与被积函数的对抗性特征在整个测试套件中的相关性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the numerical integration problem for the given test cases.\n    \"\"\"\n    \n    # Test cases defined as (c, epsilon, A, N) tuples.\n    test_cases = [\n        (\n            np.array([0.30, 0.55, 0.80]),\n            np.array([5e-2, 4e-2, 6e-2]),\n            np.array([1.0, 0.8, 0.6]),\n            128\n        ),\n        (\n            np.array([0.620, 0.625, 0.627]),\n            np.array([1.2e-3, 9e-4, 1.1e-3]),\n            np.array([1.0, 0.8, 0.7]),\n            128\n        ),\n        (\n            np.array([0.995, 0.997]),\n            np.array([2e-3, 2e-3]),\n            np.array([1.0, 0.9]),\n            128\n        ),\n        (\n            np.array([0.0500, 0.0502, 0.0504]),\n            np.array([2.0e-4, 2.5e-4, 2.0e-4]),\n            np.array([1.0, 1.0, 1.0]),\n            128\n        )\n    ]\n\n    T_adaptive = 1e-6\n    T_simpson = 1e-2\n\n    all_results = []\n\n    for c_vec, eps_vec, A_vec, N in test_cases:\n        m = len(c_vec)\n\n        # 1. Define the integrand function f(x)\n        def f(x, c, eps, A):\n            val = 0.0\n            for j in range(len(c)):\n                val += A[j] / ((x - c[j])**2 + eps[j]**2)\n            return val\n\n        # 2. Compute the exact integral I_exact\n        def compute_I_exact(c, eps, A):\n            val = 0.0\n            for j in range(len(c)):\n                term = (A[j] / eps[j]) * (np.arctan((1 - c[j]) / eps[j]) + np.arctan(c[j] / eps[j]))\n                val += term\n            return val\n\n        I_exact = compute_I_exact(c_vec, eps_vec, A_vec)\n\n        # 3. Compute the adaptive quadrature approximation\n        # Use stringent tolerances to get a high-accuracy result.\n        f_case = lambda x: f(x, c_vec, eps_vec, A_vec)\n        I_adaptive, _ = quad(f_case, 0, 1, epsabs=1e-14, epsrel=1e-14)\n        E_abs_adaptive = np.abs(I_adaptive - I_exact)\n        E_rel_adaptive = E_abs_adaptive / np.abs(I_exact) if I_exact != 0 else 0\n        sigma_adaptive = E_rel_adaptive > T_adaptive\n\n        # 4. Compute composite Simpson's rule approximation\n        def simpson_rule(func, a, b, n):\n            if n % 2 != 0:\n                raise ValueError(\"Number of subintervals N must be even.\")\n            h = (b - a) / n\n            x = np.linspace(a, b, n + 1)\n            y = func(x)\n            \n            s = y[0] + y[-1]\n            s += 4 * np.sum(y[1:-1:2]) # Odd-indexed points\n            s += 2 * np.sum(y[2:-2:2]) # Even-indexed points\n            \n            return h / 3 * s\n\n        I_simpson = simpson_rule(f_case, 0, 1, N)\n        E_abs_simpson = np.abs(I_simpson - I_exact)\n        E_rel_simpson = E_abs_simpson / np.abs(I_exact) if I_exact != 0 else 0\n        sigma_simpson = E_rel_simpson > T_simpson\n\n        # 5. Compute adversarial feature metrics\n        eps_min = np.min(eps_vec)\n        \n        if m > 1:\n            delta_min = np.min([np.abs(c_i - c_j) for c_i, c_j in combinations(c_vec, 2)])\n        else:\n            delta_min = 1.0\n            \n        beta_min = np.min(np.minimum(c_vec, 1 - c_vec))\n        \n        # 6. Assemble the results list for the current case\n        case_results = [\n            I_exact, I_adaptive, E_abs_adaptive,\n            I_simpson, E_abs_simpson,\n            eps_min, delta_min, beta_min,\n            sigma_adaptive, sigma_simpson\n        ]\n        all_results.append(case_results)\n\n    # 7. Format the final output string\n    # str(sublist) will produce '[item1, item2, ...]'\n    # We join these strings with a comma, then wrap the whole thing in brackets.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}