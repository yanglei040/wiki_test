{
    "hands_on_practices": [
        {
            "introduction": "冯·诺依曼稳定性分析是判断线性偏微分方程有限差分格式稳定性的基石。我们将以热扩散方程为例，这是一个在地球物理学（如岩石圈热扩散）中无处不在的基本过程。这项练习  将指导您从第一性原理出发，一步步推导出确保数值解不会无限增长的稳定性约束条件。",
            "id": "3573133",
            "problem": "在计算地球物理学中，均匀岩石圈柱内的热扩散可理想化为周期性域 $x\\in[0,L]$ 上的一维热传导方程 $u_{t}=\\kappa u_{xx}$，其中 $u(x,t)$ 是温度，$\\kappa>0$ 是热扩散率。考虑一个空间间距为 $\\Delta x$ 的均匀空间网格和一个离散时间步长 $\\Delta t$。令 $u_{j}^{n}$ 表示在网格点 $x_{j}=j\\,\\Delta x$ 和时间 $t_{n}=n\\,\\Delta t$ 处对 $u(x_{j},t_{n})$ 的数值近似。时间导数 $u_{t}$ 用前向欧拉法近似，空间二阶导数 $u_{xx}$ 用二阶中心差分近似：\n$$\nu_{t}(x_{j},t_{n})\\approx \\frac{u_{j}^{n+1}-u_{j}^{n}}{\\Delta t}, \\qquad\nu_{xx}(x_{j},t_{n})\\approx \\frac{u_{j+1}^{n}-2u_{j}^{n}+u_{j-1}^{n}}{\\Delta x^{2}}.\n$$\n从这些基本近似和控制方程 $u_{t}=\\kappa u_{xx}$ 出发，推导出 $u_{j}^{n}$ 的全离散更新关系。然后，利用周期性边界条件和傅里叶模态表示 $u_{j}^{n}=\\hat{u}^{n}\\exp(\\mathrm{i}k x_{j})$（其中 $k$ 为实波数），进行冯·诺依曼 (Von Neumann) (傅里叶) 稳定性分析，以获得作为 $k$ 的函数的放大因子。根据所有傅里叶模态的幅值不增长的要求，推导出确保前向欧拉和二阶中心差分格式稳定性的最大允许时间步 $\\Delta t_{\\max}$（用 $\\kappa$ 和 $\\Delta x$ 表示）。\n\n提供两个闭式符号表达式：(i) 作为 $k$、$\\Delta x$、$\\Delta t$ 和 $\\kappa$ 的函数的放大因子，以及 (ii) 用 $\\kappa$ 和 $\\Delta x$ 表示的最大稳定时间步 $\\Delta t_{\\max}$。不要将稳定性条件表示为不等式。",
            "solution": "控制方程是带周期性边界条件的一维热传导方程 $u_{t}=\\kappa u_{xx}$。在空间间距为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格上，我们使用前向欧拉法近似 $u_{t}$，使用二阶中心差分近似 $u_{xx}$。将这些近似代入 $u_{t}=\\kappa u_{xx}$，得到全离散更新式：\n$$\n\\frac{u_{j}^{n+1}-u_{j}^{n}}{\\Delta t}=\\kappa\\,\\frac{u_{j+1}^{n}-2u_{j}^{n}+u_{j-1}^{n}}{\\Delta x^{2}}.\n$$\n求解 $u_{j}^{n+1}$ 可得\n$$\nu_{j}^{n+1}=u_{j}^{n}+\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}\\left(u_{j+1}^{n}-2u_{j}^{n}+u_{j-1}^{n}\\right).\n$$\n为通过冯·诺依曼 (Von Neumann) 方法分析稳定性，我们考虑周期性网格上的单个傅里叶模态：\n$$\nu_{j}^{n}=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right), \\qquad x_{j}=j\\,\\Delta x,\n$$\n其中 $k\\in\\mathbb{R}$ 是波数，$\\hat{u}^{n}$ 是在时间层 $n$ 的模态振幅。将此表示代入更新公式，我们计算各项：\n$$\nu_{j+1}^{n}=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j+1}\\right)=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)\\exp\\!\\left(\\mathrm{i}k\\Delta x\\right),\n$$\n$$\nu_{j-1}^{n}=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j-1}\\right)=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)\\exp\\!\\left(-\\mathrm{i}k\\Delta x\\right),\n$$\n以及 $u_{j}^{n}=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)$。因此\n$$\nu_{j+1}^{n}-2u_{j}^{n}+u_{j-1}^{n}=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)\\left[\\exp\\!\\left(\\mathrm{i}k\\Delta x\\right)-2+\\exp\\!\\left(-\\mathrm{i}k\\Delta x\\right)\\right].\n$$\n定义放大因子 $G(k)$ 为 $\\hat{u}^{n+1}=G(k)\\,\\hat{u}^{n}$。将傅里叶模态代入更新式并提出公因子 $\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)$ 可得\n$$\n\\hat{u}^{n+1}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)\\left\\{1+\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}\\left[\\exp\\!\\left(\\mathrm{i}k\\Delta x\\right)-2+\\exp\\!\\left(-\\mathrm{i}k\\Delta x\\right)\\right]\\right\\}.\n$$\n消去 $\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)$ 并除以 $\\hat{u}^{n}$ 得到\n$$\nG(k)=1+\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}\\left[\\exp\\!\\left(\\mathrm{i}k\\Delta x\\right)-2+\\exp\\!\\left(-\\mathrm{i}k\\Delta x\\right)\\right].\n$$\n使用恒等式 $\\exp(\\mathrm{i}\\theta)+\\exp(-\\mathrm{i}\\theta)=2\\cos\\theta$，我们简化得：\n$$\nG(k)=1+\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}\\left[2\\cos(k\\Delta x)-2\\right]=1+\\frac{2\\kappa\\,\\Delta t}{\\Delta x^{2}}\\left[\\cos(k\\Delta x)-1\\right].\n$$\n利用三角恒等式 $\\cos\\theta-1=-2\\sin^{2}\\!\\left(\\frac{\\theta}{2}\\right)$，我们得到标准形式\n$$\nG(k)=1-4\\,\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}\\,\\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right).\n$$\n引入无量纲扩散库朗-弗里德里希斯-列维 (Courant–Friedrichs–Lewy, CFL) 数 $r=\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}$。则\n$$\nG(k)=1-4r\\,\\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right),\n$$\n其中对于实数 $k$，有 $\\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right)\\in[0,1]$。为保证显式格式的稳定性，我们要求所有傅里叶模态的幅值不增长，即对所有 $k$ 都有 $|G(k)|\\leq 1$。$G(k)$ 关于 $k$ 的极值出现在 $\\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right)=0$ 和 $\\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right)=1$ 时，得到\n$$\nG_{\\max}=1 \\quad \\text{at} \\quad \\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right)=0, \\qquad G_{\\min}=1-4r \\quad \\text{at} \\quad \\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right)=1.\n$$\n稳定性条件 $|G(k)|\\leq 1$ 可简化为 $|1-4r|\\leq 1$，这等价于\n$$\n-1\\leq 1-4r\\leq 1 \\quad \\Longrightarrow \\quad 0\\leq r\\leq \\frac{1}{2}.\n$$\n因为 $\\kappa>0$ 和 $\\Delta x>0$，所以允许的时间步满足\n$$\n\\Delta t\\leq \\frac{\\Delta x^{2}}{2\\kappa}.\n$$\n因此，最大稳定时间步为\n$$\n\\Delta t_{\\max}=\\frac{\\Delta x^{2}}{2\\kappa}.\n$$\n整理所求的表达式：作为 $k$ 的函数的放大因子是 $G(k)=1-4\\,\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}\\,\\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right)$，确保稳定性的最大允许时间步是 $\\Delta t_{\\max}=\\frac{\\Delta x^{2}}{2\\kappa}$。",
            "answer": "$$\\boxed{1-4\\,\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}\\,\\sin^{2}\\!\\left(\\frac{k\\,\\Delta x}{2}\\right), \\quad \\frac{\\Delta x^{2}}{2\\,\\kappa}}$$"
        },
        {
            "introduction": "在数值稳定性分析中，我们不仅要关注离散格式本身，还必须考虑计算机浮点运算的局限性。即使是数学上完全正确的公式，在实际计算中也可能因为“灾难性抵消”而导致精度严重损失。这项练习  展示了一个常见的地球物理计算场景——求解走时差，并要求我们重新构造表达式，以获得数值上稳定且精确的结果。",
            "id": "3573094",
            "problem": "考虑一个均匀、各向同性的声学介质，其波速为常数 $v$，一个点源位于地表下深度为 $h$ 的位置。从震源到水平偏移距为 $r$ 的接收器的初至走时，由欧几里得路径长度除以速度建模，即 $t(r) = \\frac{1}{v}\\sqrt{r^{2} + h^{2}}$。两个接收器放置在偏移距 $r_{1} = r + \\delta$ 和 $r_{2} = r - \\delta$ 处，其中 $r > 0$ 且 $0  \\delta \\ll r$。令 $t_{1} = t(r_{1})$ 且 $t_{2} = t(r_{2})$。我们感兴趣的量是时差 $\\Delta t = t_{1} - t_{2}$，该量在计算地球物理学中的波形残差和动校正估计器中使用。\n\n假设浮点计算遵循电气和电子工程师协会 (IEEE) 754 双精度标准中的“舍入到最近”模型：对于应用于归一化操作数的任何基本算术运算，$\\operatorname{fl}(x \\,\\mathrm{op}\\, y) = (x \\,\\mathrm{op}\\, y)(1 + \\zeta)$，其中 $|\\zeta| \\leq u$，$u$ 是单位舍入误差。忽略下溢和上溢。同时，采用函数 $f$ 在输入 $x$ 处的前向条件数的标准定义，$\\kappa_{f}(x) = \\lim_{\\epsilon \\to 0} \\sup_{\\|\\Delta x\\| \\leq \\epsilon \\|x\\|} \\frac{\\|f(x + \\Delta x) - f(x)\\| / \\|f(x)\\|}{\\|\\Delta x\\|/\\|x\\|}$，以及减法的标量特化形式。\n\n您的任务是：\n- 从这些基本模型和定义出发，分析在 IEEE 754 双精度下通过对 $t_{1}$ 和 $t_{2}$ 进行朴素减法计算 $\\Delta t$ 的敏感性。推导以前向相对误差界表示的结果，该界用 $u$ 和相应的减法条件数表示，并将此条件数明确地用 $t_{1}$ 和 $t_{2}$ 表示。\n- 从第一性原理和代数恒等式出发，提出并推导一个针对给定走时模型的 $\\Delta t$ 的数值稳定重构公式，以避免灾难性抵消。将重构公式简化为用 $r$、$\\delta$、$h$ 和 $v$ 表示的封闭形式表达式。\n\n提供最终答案，即用 $r$、$\\delta$、$h$ 和 $v$ 表示的 $\\Delta t$ 数值稳定重构公式的单一简化解析表达式。",
            "solution": "首先对问题陈述进行验证。\n\n**第 1 步：提取已知条件**\n- **介质属性**：均匀、各向同性、波速为常数 $v$。\n- **源和接收器几何关系**：源位于深度 $h$；两个接收器位于水平偏移距 $r_{1} = r + \\delta$ 和 $r_{2} = r - \\delta$。\n- **约束条件**：$r  0$ 且 $0  \\delta \\ll r$。\n- **走时模型**：$t(r) = \\frac{1}{v}\\sqrt{r^{2} + h^{2}}$。\n- **接收器走时**：$t_{1} = t(r_{1})$ 且 $t_{2} = t(r_{2})$。\n- **目标量**：时差 $\\Delta t = t_{1} - t_{2}$。\n- **浮点模型**：IEEE $754$ 双精度，舍入到最近。对于基本运算 `op`，$\\operatorname{fl}(x \\,\\mathrm{op}\\, y) = (x \\,\\mathrm{op}\\, y)(1 + \\zeta)$，其中 $|\\zeta| \\leq u$，$u$ 是单位舍入误差。忽略下溢和上溢。\n- **条件数定义**：$\\kappa_{f}(x) = \\lim_{\\epsilon \\to 0} \\sup_{\\|\\Delta x\\| \\leq \\epsilon \\|x\\|} \\frac{\\|f(x + \\Delta x) - f(x)\\| / \\|f(x)\\|}{\\|\\Delta x\\|/\\|x\\|}$。\n\n**第 2 步：使用提取的已知条件进行验证**\n问题定义明确，满足所有有效性标准。\n- **科学依据**：走时方程 $t(r) = \\frac{1}{v}\\sqrt{r^{2} + h^{2}}$ 是在匀速介质中应用勾股定理计算路径长度的正确方法，是地震学和地球物理学中的一个基本模型。浮点误差模型是数值分析中使用的标准模型。\n- **适定性**：问题提供了进行所需分析和推导的所有必要定义、变量和约束。条件 $0  \\delta \\ll r$ 至关重要，因为它恰好制造了问题旨在解决的数值挑战（两个几乎相等的数相减）。\n- **客观性**：问题使用精确、无歧义的数学和科学语言陈述。\n\n该问题没有任何无效性缺陷。它是地球物理学领域内数值计算的一个正式且相关的问题，专门讨论数值算法的准确性。\n\n**第 3 步：结论与行动**\n该问题被判定为**有效**。将提供完整解答。\n\n根据要求，解答分为两部分进行。\n\n**第 1 部分：朴素减法的敏感性分析**\n\n我们感兴趣的量是 $\\Delta t = t_{1} - t_{2}$。给定走时模型 $t(r) = \\frac{1}{v}\\sqrt{r^{2} + h^{2}}$ 和接收器偏移距 $r_1=r+\\delta$ 和 $r_2=r-\\delta$，$t_1$ 和 $t_2$ 的具体表达式为：\n$$\nt_{1} = \\frac{1}{v}\\sqrt{(r+\\delta)^{2} + h^{2}} \\quad \\text{和} \\quad t_{2} = \\frac{1}{v}\\sqrt{(r-\\delta)^{2} + h^{2}}\n$$\n约束条件 $0  \\delta \\ll r$ 意味着 $r_1 \\approx r$ 且 $r_2 \\approx r$，因此 $t_1 \\approx t_2$。直接计算 $\\Delta t$ 涉及两个几乎相等的数相减，这种运算容易发生灾难性抵消。\n\n为了分析误差，我们考虑标准的浮点运算法则模型。$t_1$ 和 $t_2$ 的值并非精确计算。设它们的计算浮点表示为 $\\hat{t}_1$ 和 $\\hat{t}_2$。这些值会因为计算它们的运算而累积一些误差。我们可以将其建模为 $\\hat{t}_1 = t_1(1+\\epsilon_1)$ 和 $\\hat{t}_2 = t_2(1+\\epsilon_2)$，其中 $|\\epsilon_1|$ 和 $|\\epsilon_2|$ 是单位舍入误差 $u$ 的小倍数。\n\n最后一步运算是减法：\n$$\n\\widehat{\\Delta t} = \\operatorname{fl}(\\hat{t}_1 - \\hat{t}_2) = (\\hat{t}_1 - \\hat{t}_2)(1 + \\zeta)\n$$\n其中 $|\\zeta| \\le u$。\n\n前向相对误差由 $\\frac{|\\widehat{\\Delta t} - \\Delta t|}{|\\Delta t|}$ 给出。\n$$\n\\widehat{\\Delta t} - \\Delta t = (t_1(1+\\epsilon_1) - t_2(1+\\epsilon_2))(1+\\zeta) - (t_1 - t_2)\n$$\n展开并仅保留 $\\epsilon_1$、$\\epsilon_2$ 和 $\\zeta$ 的一阶项：\n$$\n\\widehat{\\Delta t} - \\Delta t \\approx (t_1 - t_2)\\zeta + t_1\\epsilon_1 - t_2\\epsilon_2\n$$\n因此，相对误差为：\n$$\n\\frac{\\widehat{\\Delta t} - \\Delta t}{\\Delta t} \\approx \\frac{(t_1 - t_2)\\zeta + t_1\\epsilon_1 - t_2\\epsilon_2}{t_1 - t_2} = \\zeta + \\frac{t_1\\epsilon_1 - t_2\\epsilon_2}{t_1 - t_2}\n$$\n取绝对值，我们可以建立一个界：\n$$\n\\left| \\frac{\\widehat{\\Delta t} - \\Delta t}{\\Delta t} \\right| \\lesssim u + \\frac{|t_1\\epsilon_1| + |t_2\\epsilon_2|}{|t_1 - t_2|} \\le u + \\frac{t_1|\\epsilon_1| + t_2|\\epsilon_2|}{|t_1 - t_2|}\n$$\n假设输入相对误差有界，即 $|\\epsilon_1|, |\\epsilon_2| \\le \\epsilon_{\\text{in}}$，则该界变为：\n$$\n\\left| \\frac{\\widehat{\\Delta t} - \\Delta t}{\\Delta t} \\right| \\lesssim u + \\left(\\frac{t_1 + t_2}{|t_1 - t_2|}\\right) \\epsilon_{\\text{in}}\n$$\n乘以输入误差界 $\\epsilon_{\\text{in}}$ 的项是减法运算 $f(x,y) = x-y$ 的相对条件数。对于正输入 $x=t_1$ 和 $y=t_2$，条件数 $\\kappa$ 为：\n$$\n\\kappa = \\frac{t_1 + t_2}{t_1 - t_2}\n$$\n由于 $t_1 \\approx t_2$，分母 $t_1 - t_2$ 很小，导致 $\\kappa$ 非常大。这会放大输入误差 $\\epsilon_1, \\epsilon_2$，导致最终结果的相对误差很大，这种现象被称为灾难性抵消。前向相对误差的界与 $\\kappa u$ 成正比，可能比 $u$ 大许多个数量级。\n\n**第 2 部分：数值稳定的重构**\n\n为避免这种数值不稳定性，我们必须重构 $\\Delta t$ 的表达式，以消除几乎相等的项相减的情况。该表达式的形式为 $\\sqrt{A} - \\sqrt{B}$。一个标准的代数技巧是乘以并除以其共轭项 $\\sqrt{A} + \\sqrt{B}$。\n\n从 $\\Delta t$ 的定义开始：\n$$\n\\Delta t = t_1 - t_2 = \\frac{1}{v}\\left( \\sqrt{(r+\\delta)^{2} + h^{2}} - \\sqrt{(r-\\delta)^{2} + h^{2}} \\right)\n$$\n我们将括号中的项乘以 $\\frac{\\sqrt{(r+\\delta)^{2} + h^{2}} + \\sqrt{(r-\\delta)^{2} + h^{2}}}{\\sqrt{(r+\\delta)^{2} + h^{2}} + \\sqrt{(r-\\delta)^{2} + h^{2}}}$。\n分子变成平方差：\n$$\n\\left((r+\\delta)^{2} + h^{2}\\right) - \\left((r-\\delta)^{2} + h^{2}\\right)\n$$\n展开平方项：\n$$\n= (r^2 + 2r\\delta + \\delta^2 + h^2) - (r^2 - 2r\\delta + \\delta^2 + h^2)\n$$\n$$\n= r^2 + 2r\\delta + \\delta^2 + h^2 - r^2 + 2r\\delta - \\delta^2 - h^2 = 4r\\delta\n$$\n这种简化是精确的，没有引入任何近似。现在 $\\Delta t$ 的表达式为：\n$$\n\\Delta t = \\frac{1}{v} \\frac{4r\\delta}{\\sqrt{(r+\\delta)^{2} + h^{2}} + \\sqrt{(r-\\delta)^{2} + h^{2}}}\n$$\n最终简化的封闭形式表达式是：\n$$\n\\Delta t = \\frac{4r\\delta}{v\\left(\\sqrt{(r+\\delta)^{2} + h^{2}} + \\sqrt{(r-\\delta)^{2} + h^{2}}\\right)}\n$$\n这个重构后的表达式是数值稳定的。先前两个几乎相等的数相减的项 $t_1 - t_2$ 已被消除。新的分母包含两个几乎相等的正数之和，$v(t_1+t_2)$。两个同号数相加总是一个良态运算，因此可以防止灾难性抵消。这个新公式中的所有运算（加法、乘法、除法、平方根）在数值上都是良性的。",
            "answer": "$$\n\\boxed{\\frac{4r\\delta}{v\\left(\\sqrt{(r+\\delta)^{2} + h^{2}} + \\sqrt{(r-\\delta)^{2} + h^{2}}\\right)}}\n$$"
        },
        {
            "introduction": "现在，让我们通过一个完整的计算实验来连接理论与实践。对于长时间的模拟（例如地震波传播），看似微小的误差会累积并产生灾难性的后果。这项练习  比较了一种通用的标准积分器（四阶龙格-库塔法）和一种旨在保持系统物理结构的“几何积分器”（Störmer-Verlet法），突显了它们在长期能量和相位保持方面的关键差异。",
            "id": "3573143",
            "problem": "考虑一个长度为 $L$ 的周期性域上的一维线性弹性波方程，\n$$\\rho\\,\\frac{\\partial^2 u}{\\partial t^2} = T\\,\\frac{\\partial^2 u}{\\partial x^2},$$\n其中 $u(x,t)$ 是位移场，$\\rho$ 是质量密度，$T$ 是张力。定义波速 $c$ 为 $c = \\sqrt{T/\\rho}$。假设物理单位为：$\\rho$ 的单位是 $\\mathrm{kg/m}$，$T$ 的单位是 $\\mathrm{N}$，$c$ 的单位是 $\\mathrm{m/s}$，$x$ 的单位是 $\\mathrm{m}$，$t$ 的单位是 $\\mathrm{s}$，$u$ 的单位是 $\\mathrm{m}$。在半离散（空间离散化）近似中，使用 $N$ 个间距为 $\\Delta x = L/N$ 的等距网格点和周期性边界条件，并对空间二阶导数使用标准的二阶中心差分，\n$$\\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_i \\approx \\frac{u_{i-1} - 2u_i + u_{i+1}}{\\Delta x^2},$$\n从而得到半离散系统\n$$\\frac{d^2 u_i}{dt^2} = c^2\\,\\frac{u_{i-1} - 2u_i + u_{i+1}}{\\Delta x^2},\\quad i=0,\\dots,N-1,$$\n其中指数对 $N$ 取模以施加周期性。与连续能量密度 $E = \\tfrac{1}{2}\\int (\\rho\\,u_t^2 + T\\,u_x^2)\\,dx$ 一致的离散能量为\n$$E_{\\mathrm{d}}(t) = \\frac{1}{2}\\sum_{i=0}^{N-1}\\Delta x\\left[\\rho\\,v_i(t)^2 + T\\left(\\frac{u_{i+1}(t)-u_i(t)}{\\Delta x}\\right)^2\\right],$$\n其中 $v_i(t) = \\frac{d u_i}{dt}$ 且 $T = \\rho\\,c^2$。设初始条件为具有零初始速度的单个傅里叶模态，\n$$u(x,0) = A\\,\\sin\\left(2\\pi m_0 \\frac{x}{L}\\right),\\quad \\frac{\\partial u}{\\partial t}(x,0) = 0,$$\n在网格上采样。每个傅里叶模态的精确半离散动力学是一个谐振子，其角频率为\n$$\\omega_m = c\\,\\frac{2\\sin\\left(\\pi m/N\\right)}{\\Delta x},$$\n对应于离散拉普拉斯算子的特征值 $-4\\sin^2(\\pi m/N)/\\Delta x^2$。\n\n为该半离散系统实现两种时间积分器：\n- 速度-Verlet 形式的辛 Störmer–Verlet (SV) 方法（定义每步的半步速度更新、全步位置更新和最终半步速度更新）。\n- 应用于 $(\\mathbf{u},\\mathbf{v})$ 的一阶系统的经典四阶 Runge–Kutta (RK4) 方法，其中 $\\mathbf{u}' = \\mathbf{v}$ 和 $\\mathbf{v}' = c^2 \\Delta_x^2 \\mathbf{u}$。\n\n对每个时间积分器，长时间传播该半离散系统并测量：\n1. 长时间能量漂移 $\\Delta E(t) = E_{\\mathrm{d}}(t) - E_{\\mathrm{d}}(0)$，以 $\\mathrm{J}$ 为单位报告。\n2. 受激发的傅里叶模态 $m_0$ 的相位误差累积，以弧度为单位报告。通过投影的模态坐标 $(a(t),\\dot{a}(t))$ 估计数值相位 $\\phi_{\\mathrm{num}}(t)$：\n$$\\phi_{\\mathrm{num}}(t) = \\mathrm{atan2}\\left(-\\frac{\\dot{a}(t)}{A\\,\\omega_{m_0}}, \\frac{a(t)}{A}\\right),$$\n其中 $a(t)$ 和 $\\dot{a}(t)$ 是通过使用 $\\Delta x$ 加权内积将 $(\\mathbf{u}(t),\\mathbf{v}(t))$ 投影到离散基向量 $\\sin(2\\pi m_0 x/L)$ 上得到的。精确相位为 $\\phi_{\\mathrm{exact}}(t) = \\omega_{m_0}\\,t$；报告以弧度为单位的包裹差值 $\\delta\\phi(t) = \\mathrm{wrap}_{[-\\pi,\\pi]}(\\phi_{\\mathrm{num}}(t) - \\phi_{\\mathrm{exact}}(t))$。角度必须以弧度表示。\n\nCourant–Friedrichs–Lewy (CFL) 条件根据最大模态频率 $\\omega_{\\max}$ 为辛 Störmer–Verlet 方法提供了一个稳定性界限，对于半离散算子，该频率为 $\\omega_{\\max} = c\\,\\frac{2}{\\Delta x}$。通过在不同的时间步长和空间分辨率下比较 Störmer–Verlet 和 Runge–Kutta 方法，探究其精度、稳定性和收敛性。\n\n对测试套件使用以下物理和数值参数：\n- $L = 1$（单位 $\\mathrm{m}$），$\\rho = 1$（单位 $\\mathrm{kg/m}$），$c = 1$（单位 $\\mathrm{m/s}$），因此 $T = 1$（单位 $\\mathrm{N}$）。\n- $A = 10^{-3}$（单位 $\\mathrm{m}$），$m_0 = 3$。\n- $t_{\\mathrm{final}} = 20$（单位 $\\mathrm{s}$）。\n- 六个测试用例 $(\\text{积分器}, N, \\Delta t)$：\n    1. $\\text{SV}$, $N=128$, $\\Delta t = 0.002$ (理想情况，小时间步长)。\n    2. $\\text{RK4}$, $N=128$, $\\Delta t = 0.002$ (与 1 相同，用于比较)。\n    3. $\\text{SV}$, $N=128$, $\\Delta t = 0.0075$ (接近辛稳定性极限，因为 CFL 界限表明 $\\Delta t_{\\max} \\approx 1/N = 0.0078125$)。\n    4. $\\text{RK4}$, $N=128$, $\\Delta t = 0.0075$ (在较大时间步长下的非辛方法)。\n    5. $\\text{SV}$, $N=64$, $\\Delta t = 1/64 = 0.015625$ (在较粗网格上的 CFL 临界情况)。\n    6. $\\text{RK4}$, $N=64$, $\\Delta t = 1/64 = 0.015625$ (在临界时间步长下的非辛方法)。\n\n你的程序必须：\n- 构建半离散系统，并使用每个指定的积分器和参数将其向前推进。\n- 计算 $E_{\\mathrm{d}}(0)$ 和 $E_{\\mathrm{d}}(t_{\\mathrm{final}})$，然后报告以 $\\mathrm{J}$ 为单位的 $\\Delta E(t_{\\mathrm{final}})$。\n- 使用上述的投影和角度定义，计算单个受激发的模态 $m_0$ 的相位误差 $\\delta\\phi(t_{\\mathrm{final}})$（以弧度为单位）。\n- 生成单行输出，其中包含结果，格式为逗号分隔的列表的列表 `\"[[\\Delta E_1,\\delta\\phi_1],[\\Delta E_2,\\delta\\phi_2],\\dots,[\\Delta E_6,\\delta\\phi_6]]\"`，其中所有 $\\Delta E_k$ 以 $\\mathrm{J}$ 为单位，所有 $\\delta\\phi_k$ 以弧度为单位。\n\n所有角度必须以弧度为单位。所有物理量必须以上述指定单位报告。不允许使用外部输入或文件；程序必须是自包含且确定性的。",
            "solution": "所提出的问题要求对一维线性弹性波方程进行数值模拟，\n$$\n\\rho\\,\\frac{\\partial^2 u}{\\partial t^2} = T\\,\\frac{\\partial^2 u}{\\partial x^2}\n$$\n在长度为 $L$ 的周期性域上。物理参数是质量密度 $\\rho$ 和张力 $T$，它们定义了波速 $c = \\sqrt{T/\\rho}$。该问题是适定的，有科学依据，并为唯一的、可验证的数值实验提供了所有必要的参数和定义。我们将实现并比较两种时间积分方案：辛 Störmer–Verlet (SV) 方法和经典的四阶 Runge–Kutta (RK4) 方法。比较将侧重于长期能量守恒和相位精度。\n\n首先，我们对空间域进行离散化。我们使用 $N$ 个网格点 $x_i = i\\,\\Delta x$（其中 $i=0, \\dots, N-1$），网格间距为 $\\Delta x = L/N$。使用二阶中心差分格式来近似空间二阶导数，在周期性边界条件下，这会得到常微分方程 (ODEs) 的半离散系统：\n$$\n\\frac{d^2 u_i}{dt^2} = \\frac{c^2}{\\Delta x^2} (u_{i-1} - 2u_i + u_{i+1})\n$$\n其中指数对 $N$ 取模。这可以写成向量形式 $\\frac{d^2 \\mathbf{u}}{dt^2} = \\mathbf{a}(\\mathbf{u})$，其中 $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$ 是网格点上的位移向量，$\\mathbf{a}(\\mathbf{u})$ 是加速度向量。\n\n初始条件是具有零初始速度的单个正弦模态：\n$$\nu(x,0) = A\\,\\sin\\left(2\\pi m_0 \\frac{x}{L}\\right), \\quad \\frac{\\partial u}{\\partial t}(x,0) = 0\n$$\n在网格上采样，得到初始状态向量：\n$$\nu_i(0) = A\\,\\sin\\left(2\\pi m_0 \\frac{i}{N}\\right), \\quad v_i(0) = 0 \\quad \\text{for } i=0, \\dots, N-1\n$$\n其中 $v_i = du_i/dt$。\n\n现在我们将详细介绍用于求解该系统（从 $t=0$ 到 $t=t_{\\mathrm{final}}$）的两种数值积分器。\n\n1.  **Störmer–Verlet (SV) 方法**：这种积分器专为形如 $\\ddot{\\mathbf{u}} = \\mathbf{a}(\\mathbf{u})$ 的二阶常微分方程设计。它是几何积分器这类方法中的一员，特别是辛积分器，以其对哈密顿系统出色的长期能量守恒特性而闻名。我们使用速度-Verlet 格式，它分三步将解从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$：\n    \\begin{enumerate}\n        \\item 计算半步速度：$\\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\mathbf{a}(\\mathbf{u}_n) \\frac{\\Delta t}{2}$\n        \\item 使用半步速度更新位置：$\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\mathbf{v}_{n+1/2} \\Delta t$\n        \\item 使用新的加速度计算最终速度：$\\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\mathbf{a}(\\mathbf{u}_{n+1}) \\frac{\\Delta t}{2}$\n    \\end{enumerate}\n    对于波动方程，该方案的稳定性由 Courant–Friedrichs–Lewy (CFL) 条件决定。对于此特定离散化，该条件为 $c \\frac{\\Delta t}{\\Delta x} \\le 1$。\n\n2.  **四阶 Runge–Kutta (RK4) 方法**：这是一种通用的高精度显式积分器。为应用该方法，我们首先将二阶系统转换为一阶系统。设状态向量为 $\\mathbf{y} = [\\mathbf{u}^T, \\mathbf{v}^T]^T$。系统变为 $\\frac{d\\mathbf{y}}{dt} = F(\\mathbf{y})$，其中 $F(\\mathbf{y}) = [\\mathbf{v}^T, \\mathbf{a}(\\mathbf{u})^T]^T$。RK4 算法如下将解从 $\\mathbf{y}_n$ 推进到 $\\mathbf{y}_{n+1}$：\n    \\begin{enumerate}\n        \\item $\\mathbf{k}_1 = \\Delta t \\, F(\\mathbf{y}_n)$\n        \\item $\\mathbf{k}_2 = \\Delta t \\, F(\\mathbf{y}_n + \\mathbf{k}_1/2)$\n        \\item $\\mathbf{k}_3 = \\Delta t \\, F(\\mathbf{y}_n + \\mathbf{k}_2/2)$\n        \\item $\\mathbf{k}_4 = \\Delta t \\, F(\\mathbf{y}_n + \\mathbf{k}_3)$\n        \\item $\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)$\n    \\end{enumerate}\n    尽管 RK4 的单步精度很高，但它不是辛方法，并且在长时间积分中预计会表现出长期的能量漂移（耗散或增长）。\n\n为评估性能，我们在 $t=t_{\\mathrm{final}}$ 时测量两个关键量：\n\n-   **能量漂移**：系统的离散能量由下式给出：\n    $$\n    E_{\\mathrm{d}}(t) = \\frac{1}{2}\\sum_{i=0}^{N-1}\\Delta x\\left[\\rho\\,v_i(t)^2 + T\\left(\\frac{u_{i+1}(t)-u_i(t)}{\\Delta x}\\right)^2\\right]\n    $$\n    我们计算能量漂移 $\\Delta E = E_{\\mathrm{d}}(t_{\\mathrm{final}}) - E_{\\mathrm{d}}(0)$。对于辛 SV 方法，我们预计 $|\\Delta E|$ 将保持有界且很小，在零附近振荡。对于非辛 RK4 方法，我们预计 $\\Delta E$ 会随时间增长。\n\n-   **相位误差**：对于所选的初始条件，只有单个傅里叶模态 $m_0$ 被激发。对于此模态，半离散系统的精确解是一个角频率为 $\\omega_{m_0} = c \\frac{2\\sin(\\pi m_0/N)}{\\Delta x}$ 的谐波振荡。在时间 $t$ 的精确相位是 $\\phi_{\\mathrm{exact}}(t) = \\omega_{m_0} t$。为了测量数值相位，我们将数值解 $(\\mathbf{u}(t), \\mathbf{v}(t))$ 投影回模态 $m_0$ 的基向量上。投影振幅 $a(t)$ 及其时间导数 $\\dot{a}(t)$ 使用离散内积计算：\n    $$\n    a(t) = \\frac{\\langle \\mathbf{u}(t), \\boldsymbol{\\phi}_{m_0} \\rangle}{\\langle \\boldsymbol{\\phi}_{m_0}, \\boldsymbol{\\phi}_{m_0} \\rangle}, \\quad \\dot{a}(t) = \\frac{\\langle \\mathbf{v}(t), \\boldsymbol{\\phi}_{m_0} \\rangle}{\\langle \\boldsymbol{\\phi}_{m_0}, \\boldsymbol{\\phi}_{m_0} \\rangle}\n    $$\n    其中 $\\boldsymbol{\\phi}_{m_0}$ 是分量为 $\\sin(2\\pi m_0 x_i / L)$ 的向量，内积为 $\\langle \\mathbf{f}, \\mathbf{g} \\rangle = \\sum_i f_i g_i \\Delta x$。归一化因子是 $\\langle \\boldsymbol{\\phi}_{m_0}, \\boldsymbol{\\phi}_{m_0} \\rangle = L/2$。那么数值相位是 $\\phi_{\\mathrm{num}}(t) = \\mathrm{atan2}\\left(-\\dot{a}(t) / (A\\,\\omega_{m_0}), a(t)/A\\right)$。相位误差是包裹差值 $\\delta\\phi(t) = \\mathrm{wrap}_{[-\\pi,\\pi]}(\\phi_{\\mathrm{num}}(t) - \\phi_{\\mathrm{exact}}(t))$。\n\n针对六个指定的测试用例运行模拟，并整理能量漂移和相位误差的结果。使用的参数为 $L=1$, $\\rho=1$, $c=1$, $A=10^{-3}$, $m_0=3$ 以及 $t_{\\mathrm{final}}=20$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D wave equation using Störmer-Verlet and RK4 integrators,\n    and reports energy drift and phase error for a set of test cases.\n    \"\"\"\n    \n    # Define physical and numerical parameters from the problem statement.\n    L = 1.0  # m\n    rho = 1.0  # kg/m\n    c = 1.0  # m/s\n    T = rho * c**2  # N\n    A = 1e-3  # m\n    m0 = 3\n    t_final = 20.0  # s\n\n    # Define the six test cases\n    test_cases = [\n        # (integrator_name, N, dt)\n        ('SV', 128, 0.002),\n        ('RK4', 128, 0.002),\n        ('SV', 128, 0.0075),\n        ('RK4', 128, 0.0075),\n        ('SV', 64, 1/64),\n        ('RK4', 64, 1/64),\n    ]\n\n    results = []\n\n    for integrator_name, N, dt in test_cases:\n        # --- Setup for the current test case ---\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        \n        # Initial conditions\n        u = A * np.sin(2 * np.pi * m0 * x / L)\n        v = np.zeros(N)\n        \n        u0, v0 = np.copy(u), np.copy(v)\n\n        def get_accel(u_state, c_val, dx_val):\n            \"\"\"Computes acceleration using central difference for the 2nd derivative.\"\"\"\n            u_left = np.roll(u_state, 1)\n            u_right = np.roll(u_state, -1)\n            return (c_val**2 / dx_val**2) * (u_left - 2 * u_state + u_right)\n\n        def calculate_energy(u_state, v_state, rho_val, T_val, dx_val):\n            \"\"\"Computes the discrete energy of the system.\"\"\"\n            u_diff = np.roll(u_state, -1) - u_state\n            potential_energy = 0.5 * T_val * np.sum((u_diff / dx_val)**2) * dx_val\n            kinetic_energy = 0.5 * rho_val * np.sum(v_state**2) * dx_val\n            return potential_energy + kinetic_energy\n\n        E0 = calculate_energy(u0, v0, rho, T, dx)\n        \n        # --- Time integration loop ---\n        num_steps = int(round(t_final / dt))\n        actual_t_final = num_steps * dt\n\n        if integrator_name == 'SV':\n            accel = get_accel(u, c, dx)\n            for _ in range(num_steps):\n                v_half = v + 0.5 * dt * accel\n                u = u + dt * v_half\n                accel = get_accel(u, c, dx)\n                v = v_half + 0.5 * dt * accel\n        \n        elif integrator_name == 'RK4':\n            state = np.concatenate((u, v))\n            \n            def F(y):\n                u_part = y[:N]\n                v_part = y[N:]\n                accel_part = get_accel(u_part, c, dx)\n                return np.concatenate((v_part, accel_part))\n\n            for _ in range(num_steps):\n                k1 = dt * F(state)\n                k2 = dt * F(state + 0.5 * k1)\n                k3 = dt * F(state + 0.5 * k2)\n                k4 = dt * F(state + k3)\n                state += (k1 + 2*k2 + 2*k3 + k4) / 6\n            \n            u = state[:N]\n            v = state[N:]\n\n        # --- Post-processing and analysis ---\n        \n        # 1. Energy Drift Calculation\n        Ef = calculate_energy(u, v, rho, T, dx)\n        delta_E = Ef - E0\n\n        # 2. Phase Error Calculation\n        # Exact angular frequency of the semi-discrete system for mode m0\n        omega_m0 = c * (2 * np.sin(np.pi * m0 / N) / dx)\n        phi_exact = omega_m0 * actual_t_final\n\n        # Project numerical solution onto the basis vector for mode m0\n        basis_vec = np.sin(2 * np.pi * m0 * x / L)\n        norm_factor = np.sum(basis_vec**2) * dx # Should be L/2 for m0 != 0, N/2\n\n        a_t = np.sum(u * basis_vec) * dx / norm_factor\n        adot_t = np.sum(v * basis_vec) * dx / norm_factor\n\n        # Numerical phase from projected coordinates\n        phi_num = np.arctan2(-adot_t / (A * omega_m0), a_t / A)\n\n        # Phase error, wrapped to [-pi, pi]\n        delta_phi = phi_num - phi_exact\n        delta_phi = (delta_phi + np.pi) % (2 * np.pi) - np.pi\n\n        results.append([delta_E, delta_phi])\n\n    # Format the final output string\n    result_str = \"[\" + \",\".join([f\"[{e:.15e},{p:.15e}]\" for e, p in results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}