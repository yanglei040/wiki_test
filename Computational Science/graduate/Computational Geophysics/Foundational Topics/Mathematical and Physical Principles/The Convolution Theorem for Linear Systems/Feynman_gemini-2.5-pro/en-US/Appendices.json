{
    "hands_on_practices": [
        {
            "introduction": "The first step in leveraging the convolution theorem is transforming a system's impulse response into the frequency domain. This foundational exercise  explores this process for a classic geophysical model of attenuation—an exponentially decaying signal. By deriving the Fourier transform and analyzing its structure in the complex plane, you will uncover a profound link between a system's physical properties like causality and stability, and the mathematical location of poles in its frequency response.",
            "id": "3616300",
            "problem": "A one-dimensional viscoacoustic half-space is modeled as a causal Linear Time-Invariant (LTI) system whose Green’s function (impulse response) is given by the exponentially decaying function $x(t)=\\exp(-a t)\\,u(t)$ with $a>0$, where $u(t)$ is the unit step. In computational geophysics, a recorded seismogram $y(t)$ generated by a compact source wavelet $s(t)$ can be represented as the convolution $y(t)=(x*s)(t)$ of the Green’s function with the source. The convolution theorem for linear systems connects this time-domain convolution to a frequency-domain product of their spectra, a fact used routinely in seismic deconvolution and attenuation compensation.\n\nStarting strictly from the definition of the angular-frequency Fourier transform,\n$$\nX(\\omega)=\\int_{-\\infty}^{\\infty} x(t)\\,\\exp(-i\\,\\omega\\,t)\\,dt,\n$$\nand the definition of the unit step $u(t)$, derive an explicit closed-form expression for $X(\\omega)$ for the given $x(t)$. Then interpret the location of its pole in the complex $\\omega$-plane by identifying the complex value $\\omega_{\\text{pole}}$ at which $X(\\omega)$ becomes unbounded, and explain in words (in your derivation) how this pole placement is consistent with causality and Bounded-Input Bounded-Output (BIBO) stability of the underlying LTI attenuation operator when viewed through the convolution theorem and its standard analytic continuation.\n\nProvide your final answer as two entries in a single row matrix: first the analytic expression for $X(\\omega)$, and second the complex pole location $\\omega_{\\text{pole}}$. No numerical evaluation is required, and no units are needed in the final answer. If you choose to include any approximations in intermediate reasoning, do not apply them to the final result.",
            "solution": "The problem requires the derivation of the Fourier transform, denoted as $X(\\omega)$, for the given Green's function $x(t)$, the identification of its pole in the complex $\\omega$-plane, and an interpretation of the pole's location in the context of system causality and stability.\n\nThe given Green's function, or impulse response, is $x(t) = \\exp(-a t) u(t)$, where $a$ is a positive real constant ($a>0$) and $u(t)$ is the Heaviside unit step function. The unit step function is defined as:\n$$\nu(t) = \\begin{cases} 0 & \\text{for } t < 0 \\\\ 1 & \\text{for } t \\ge 0 \\end{cases}\n$$\nThe problem specifies the definition of the angular-frequency Fourier transform as:\n$$\nX(\\omega) = \\int_{-\\infty}^{\\infty} x(t) \\exp(-i \\omega t) dt\n$$\n\nTo find $X(\\omega)$, we substitute the expression for $x(t)$ into the integral definition:\n$$\nX(\\omega) = \\int_{-\\infty}^{\\infty} \\exp(-a t) u(t) \\exp(-i \\omega t) dt\n$$\nThe presence of the unit step function $u(t)$ makes the integrand equal to zero for all $t < 0$. Consequently, the lower limit of integration can be changed from $-\\infty$ to $0$. For $t \\ge 0$, $u(t) = 1$. The integral simplifies to:\n$$\nX(\\omega) = \\int_{0}^{\\infty} \\exp(-a t) \\exp(-i \\omega t) dt\n$$\nWe can combine the exponential terms in the integrand:\n$$\nX(\\omega) = \\int_{0}^{\\infty} \\exp(-(a + i \\omega) t) dt\n$$\nThis is a standard improper integral of an exponential function. To evaluate it, we find the antiderivative of the integrand with respect to $t$:\n$$\n\\int \\exp(-(a + i \\omega) t) dt = -\\frac{1}{a + i \\omega} \\exp(-(a + i \\omega) t)\n$$\nNow, we evaluate this antiderivative at the limits of integration, from $t=0$ to $t \\to \\infty$:\n$$\nX(\\omega) = \\left[ -\\frac{1}{a + i \\omega} \\exp(-(a + i \\omega) t) \\right]_{0}^{\\infty}\n$$\n$$\nX(\\omega) = \\lim_{T \\to \\infty} \\left( -\\frac{1}{a + i \\omega} \\exp(-(a + i \\omega) T) \\right) - \\left( -\\frac{1}{a + i \\omega} \\exp(-(a + i \\omega) \\cdot 0) \\right)\n$$\nLet's analyze the limit term. The exponential can be written as $\\exp(-aT) \\exp(-i\\omega T)$. For a real-valued angular frequency $\\omega$, the term $\\exp(-i\\omega T)$ is a complex phasor with unit magnitude, $|\\exp(-i\\omega T)| = 1$. The term $\\exp(-aT)$ determines the behavior of the magnitude. Since it is given that $a > 0$, as $T \\to \\infty$, $\\exp(-aT) \\to 0$. Therefore, the entire limit term evaluates to zero.\n$$\n\\lim_{T \\to \\infty} \\exp(-(a + i \\omega) T) = 0\n$$\nThe second term evaluates to:\n$$\n-\\left( -\\frac{1}{a + i \\omega} \\exp(0) \\right) = \\frac{1}{a + i \\omega}\n$$\nCombining these results, we obtain the explicit closed-form expression for the Fourier transform $X(\\omega)$:\n$$\nX(\\omega) = \\frac{1}{a + i \\omega}\n$$\n\nNext, we identify the pole of $X(\\omega)$. A pole is a value in the complex plane where the function becomes unbounded. For a rational function like $X(\\omega)$, this occurs where the denominator is zero. Let $\\omega_{\\text{pole}}$ be the complex value of $\\omega$ at which the pole is located. We set the denominator to zero and solve for $\\omega_{\\text{pole}}$:\n$$\na + i \\omega_{\\text{pole}} = 0\n$$\n$$\ni \\omega_{\\text{pole}} = -a\n$$\n$$\n\\omega_{\\text{pole}} = \\frac{-a}{i} = \\frac{-a(-i)}{i(-i)} = \\frac{ia}{1} = ia\n$$\nThus, the pole is located at the purely imaginary value $\\omega_{\\text{pole}} = ia$ in the complex $\\omega$-plane.\n\nFinally, we interpret the significance of this pole's location with respect to causality and Bounded-Input Bounded-Output (BIBO) stability. The argument hinges on the analytic continuation of $X(\\omega)$ to a complex variable $\\tilde{\\omega} = \\omega_r + i\\omega_i$. The Fourier integral converges only for values of $\\tilde{\\omega}$ for which the real part of the exponent coefficient, $a - \\text{Im}(\\tilde{\\omega})$, is positive. This defines the Region of Convergence (ROC) as $\\text{Im}(\\tilde{\\omega}) < a$.\n\nCausality of an LTI system means its impulse response $x(t)$ must be zero for $t < 0$. Our $x(t)$ fulfills this by definition due to the $u(t)$ factor. For the Fourier transform convention $\\exp(-i\\omega t)$, a causal (right-sided) time-domain signal implies that its frequency-domain representation $X(\\tilde{\\omega})$ must be analytic in a lower half-plane. This means all poles of $X(\\tilde{\\omega})$ must lie in the complementary upper half-plane. Our pole is at $\\omega_{\\text{pole}} = ia$. Since the problem states $a > 0$, the imaginary part of the pole is positive, $\\text{Im}(\\omega_{\\text{pole}}) = a > 0$. The pole is therefore located in the upper half of the complex $\\omega$-plane, which is consistent with the causality of the system.\n\nBIBO stability of an LTI system requires its impulse response to be absolutely integrable, i.e., $\\int_{-\\infty}^{\\infty} |x(t)| dt < \\infty$. For our system, this condition is:\n$$\n\\int_{-\\infty}^{\\infty} |\\exp(-at) u(t)| dt = \\int_{0}^{\\infty} \\exp(-at) dt = \\left[ -\\frac{1}{a} \\exp(-at) \\right]_{0}^{\\infty} = \\frac{1}{a}\n$$\nSince $a > 0$, this integral is finite, and the system is BIBO stable. In the frequency domain, stability requires that the real axis, $\\text{Im}(\\tilde{\\omega}) = 0$, be included within the ROC. Our ROC is $\\text{Im}(\\tilde{\\omega}) < a$. Since $a > 0$, the real axis (where $\\text{Im}(\\tilde{\\omega}) = 0$) is indeed strictly contained within the ROC. This implies that no poles can lie on the real axis, which would correspond to undamped oscillations and marginal stability or instability. Our pole at $\\omega_{\\text{pole}} = ia$ is not on the real axis. Therefore, the location of the pole strictly in the upper half-plane ($a>0$) is fully consistent with the system being both causal and BIBO stable.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{a + i \\omega} & i a \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "With the ability to represent a system in the frequency domain, we can now apply the convolution theorem to predict its output for a given input. This practice problem  simulates a common scenario where a simple, finite-duration source pulse is filtered by a first-order relaxation system. Solving this problem reinforces how the complex operation of convolution in the time domain simplifies to straightforward multiplication in the frequency domain, a cornerstone of linear system analysis.",
            "id": "3616279",
            "problem": "In a one-dimensional controlled-source acoustic experiment, the source-time function is approximated as a unit-amplitude rectangular pulse of width $T$, and the acquisition chain (including near-surface attenuation and the instrument) is modeled as a stable Linear Time-Invariant (LTI) filter with a causal first-order relaxation impulse response. Specifically, assume\n$$\nx(t) = u(t) - u(t - T),\n$$\n$$\nh(t) = \\frac{1}{\\tau} \\exp\\!\\left(-\\frac{t}{\\tau}\\right) u(t),\n$$\nwhere $u(t)$ is the Heaviside step function, $T > 0$ is the pulse width, and $\\tau > 0$ is the relaxation time. Let $y(t) = (x * h)(t)$ denote the recorded signal.\n\nUsing the convolution theorem for LTI systems and the following angular-frequency Fourier transform convention,\n$$\nX(\\omega) = \\int_{-\\infty}^{\\infty} x(t) \\exp(-\\mathrm{i}\\,\\omega t)\\,dt, \\quad x(t) = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} X(\\omega) \\exp(\\mathrm{i}\\,\\omega t)\\,d\\omega,\n$$\ndo the following:\n1. Derive the spectrum $Y(\\omega)$ of $y(t)$ in closed form by first principles starting from the definitions of convolution and the Fourier transform.\n2. Invert the transform to obtain $y(t)$ as a single closed-form expression involving only elementary functions and $u(t)$.\n\nProvide your final answer as the explicit closed-form expression for $y(t)$ in terms of $T$, $\\tau$, and $t$. No numerical evaluation is required, and no rounding applies.",
            "solution": "### Solution Derivation\nThe objective is to find the output signal $y(t) = (x * h)(t)$ using the convolution theorem, which states that convolution in the time domain corresponds to multiplication in the frequency domain.\n\n**1. Derivation of the Spectrum $Y(\\omega)$**\n\nAccording to the convolution theorem, the Fourier transform of the output, $Y(\\omega)$, is the product of the Fourier transforms of the input, $X(\\omega)$, and the impulse response, $H(\\omega)$.\n$$\nY(\\omega) = X(\\omega) H(\\omega)\n$$\nWe must first compute $X(\\omega)$ and $H(\\omega)$.\n\nThe Fourier transform of the source-time function $x(t) = u(t) - u(t-T)$ is found by direct integration:\n$$\nX(\\omega) = \\int_{-\\infty}^{\\infty} x(t) \\exp(-\\mathrm{i}\\,\\omega t)\\,dt = \\int_{-\\infty}^{\\infty} [u(t) - u(t-T)] \\exp(-\\mathrm{i}\\,\\omega t)\\,dt\n$$\nThe term $[u(t) - u(t-T)]$ is equal to $1$ for $0 \\le t < T$ and $0$ otherwise. The integral becomes:\n$$\nX(\\omega) = \\int_{0}^{T} (1) \\exp(-\\mathrm{i}\\,\\omega t)\\,dt = \\left[ \\frac{\\exp(-\\mathrm{i}\\,\\omega t)}{-\\mathrm{i}\\,\\omega} \\right]_{t=0}^{t=T}\n$$\n$$\nX(\\omega) = \\frac{\\exp(-\\mathrm{i}\\,\\omega T) - \\exp(0)}{-\\mathrm{i}\\,\\omega} = \\frac{1 - \\exp(-\\mathrm{i}\\,\\omega T)}{\\mathrm{i}\\,\\omega}\n$$\nNext, we compute the Fourier transform of the impulse response $h(t) = \\frac{1}{\\tau} \\exp(-t/\\tau)u(t)$:\n$$\nH(\\omega) = \\int_{-\\infty}^{\\infty} h(t) \\exp(-\\mathrm{i}\\,\\omega t)\\,dt = \\int_{0}^{\\infty} \\frac{1}{\\tau} \\exp\\left(-\\frac{t}{\\tau}\\right) \\exp(-\\mathrm{i}\\,\\omega t)\\,dt\n$$\n$$\nH(\\omega) = \\frac{1}{\\tau} \\int_{0}^{\\infty} \\exp\\left(-t\\left(\\frac{1}{\\tau} + \\mathrm{i}\\,\\omega\\right)\\right)\\,dt = \\frac{1}{\\tau} \\left[ \\frac{\\exp\\left(-t\\left(\\frac{1}{\\tau} + \\mathrm{i}\\,\\omega\\right)\\right)}{-\\left(\\frac{1}{\\tau} + \\mathrm{i}\\,\\omega\\right)} \\right]_{t=0}^{t=\\infty}\n$$\nSince $\\tau > 0$, the real part of the exponent's coefficient is positive, so the exponential term vanishes at $t \\to \\infty$.\n$$\nH(\\omega) = \\frac{1}{\\tau} \\left( 0 - \\frac{1}{-\\left(\\frac{1}{\\tau} + \\mathrm{i}\\,\\omega\\right)} \\right) = \\frac{1}{\\tau} \\frac{1}{\\frac{1}{\\tau} + \\mathrm{i}\\,\\omega} = \\frac{1}{\\tau} \\frac{\\tau}{1 + \\mathrm{i}\\,\\omega\\tau} = \\frac{1}{1 + \\mathrm{i}\\,\\omega\\tau}\n$$\nNow, we multiply $X(\\omega)$ and $H(\\omega)$ to obtain the output spectrum $Y(\\omega)$:\n$$\nY(\\omega) = X(\\omega) H(\\omega) = \\left( \\frac{1 - \\exp(-\\mathrm{i}\\,\\omega T)}{\\mathrm{i}\\,\\omega} \\right) \\left( \\frac{1}{1 + \\mathrm{i}\\,\\omega\\tau} \\right) = \\frac{1 - \\exp(-\\mathrm{i}\\,\\omega T)}{\\mathrm{i}\\,\\omega(1 + \\mathrm{i}\\,\\omega\\tau)}\n$$\nThis is the closed-form expression for the spectrum $Y(\\omega)$.\n\n**2. Inversion of the Transform to obtain $y(t)$**\n\nTo find $y(t)$, we must compute the inverse Fourier transform of $Y(\\omega)$. A direct calculation using contour integration is possible, but a more elegant method leverages the structure of the signals in the time domain.\n\nThe input signal is $x(t) = u(t) - u(t-T)$. Due to the linearity of the convolution operation:\n$$\ny(t) = x(t) * h(t) = [u(t) - u(t-T)] * h(t) = (u(t) * h(t)) - (u(t-T) * h(t))\n$$\nLet's define the system's step response, $s_r(t)$, as the convolution of the impulse response with a Heaviside step function:\n$$\ns_r(t) = u(t) * h(t)\n$$\nUsing the time-invariance property of LTI systems, the response to a time-shifted input $u(t-T)$ is the time-shifted step response $s_r(t-T)$.\n$$\nu(t-T) * h(t) = s_r(t-T)\n$$\nTherefore, the output signal can be expressed as the difference of two step responses:\n$$\ny(t) = s_r(t) - s_r(t-T)\n$$\nWe now find the step response $s_r(t)$ by integrating the impulse response $h(t)$. Since $h(t)$ is causal, the integral of its past is zero for $t < 0$. For $t \\ge 0$:\n$$\ns_r(t) = \\int_{-\\infty}^{t} h(\\lambda)\\,d\\lambda = \\int_{0}^{t} \\frac{1}{\\tau} \\exp\\left(-\\frac{\\lambda}{\\tau}\\right)\\,d\\lambda\n$$\n$$\ns_r(t) = \\left[ -\\exp\\left(-\\frac{\\lambda}{\\tau}\\right) \\right]_{0}^{t} = -\\exp\\left(-\\frac{t}{\\tau}\\right) - (-\\exp(0)) = 1 - \\exp\\left(-\\frac{t}{\\tau}\\right)\n$$\nTo write a single expression valid for all time, we include the Heaviside function:\n$$\ns_r(t) = \\left(1 - \\exp\\left(-\\frac{t}{\\tau}\\right)\\right) u(t)\n$$\nFinally, we construct $y(t)$ using the relation $y(t) = s_r(t) - s_r(t-T)$:\n$$\ns_r(t-T) = \\left(1 - \\exp\\left(-\\frac{t-T}{\\tau}\\right)\\right) u(t-T)\n$$\n$$\ny(t) = \\left(1 - \\exp\\left(-\\frac{t}{\\tau}\\right)\\right) u(t) - \\left(1 - \\exp\\left(-\\frac{t-T}{\\tau}\\right)\\right) u(t-T)\n$$\nThis is the final closed-form expression for the recorded signal $y(t)$. It can be analyzed piecewise:\n- For $t < 0$, $y(t) = 0$.\n- For $0 \\le t < T$, $y(t) = 1 - \\exp(-t/\\tau)$.\n- For $t \\ge T$, $y(t) = (1 - \\exp(-t/\\tau)) - (1 - \\exp(-(t-T)/\\tau)) = \\exp(-(t-T)/\\tau) - \\exp(-t/\\tau) = \\exp(-t/\\tau)[\\exp(T/\\tau) - 1]$.\nThe expression using Heaviside functions is the most compact and complete representation.",
            "answer": "$$\n\\boxed{\\left(1 - \\exp\\left(-\\frac{t}{\\tau}\\right)\\right) u(t) - \\left(1 - \\exp\\left(-\\frac{t-T}{\\tau}\\right)\\right) u(t-T)}\n$$"
        },
        {
            "introduction": "While analytical solutions provide deep insight, real-world geophysics relies on computational methods. This hands-on coding exercise  bridges the gap between continuous-time theory and discrete-time implementation using the Fast Fourier Transform (FFT). It tackles a critical and common pitfall: the distinction between the desired linear convolution and the circular convolution that DFT-based multiplication inherently performs. By implementing and quantifying the errors of different approaches, you will master the correct techniques for using FFTs to efficiently filter seismic data and avoid wrap-around artifacts.",
            "id": "3616259",
            "problem": "Consider a discrete-time, finite-length seismic trace modeled as a real-valued sequence $x[n]$ with $0 \\le n \\le N-1$, and a real-valued, finite impulse response $h[n]$ with $0 \\le n \\le M-1$. A linear time-invariant system is defined by the discrete-time linear convolution, which produces the true output $y_{\\text{true}}[n]$ of length $L = N + M - 1$ by $y_{\\text{true}}[n] = \\sum_{k=0}^{N-1} x[k] h[n-k]$ for all integer $n$, with implicit zero extension outside the support. The Discrete Fourier Transform (DFT) of a length-$K$ sequence $s[n]$, $0 \\le n \\le K-1$, is defined by $S[k] = \\sum_{n=0}^{K-1} s[n] e^{-i 2 \\pi k n / K}$ for $0 \\le k \\le K-1$, and the inverse Discrete Fourier Transform (IDFT) by $s[n] = \\frac{1}{K} \\sum_{k=0}^{K-1} S[k] e^{i 2 \\pi k n / K}$. In computational geophysics, frequency-domain methods compute system outputs by multiplying transforms and then inverting the transform. However, the DFT represents periodic sequences of period $K$, so frequency-domain multiplication with equal-length DFTs realizes circular convolution of period $K$ in the time domain. For finite seismic traces, this can introduce wrap-around artifacts unless zero-padding or block processing strategies are used.\n\nYour task is to:\n- Derive, from the given definitions, the precise relationship between circular convolution at length $K$ and frequency-domain multiplication of length-$K$ DFTs, and explain why using equal-length DFTs to compute outputs assumes periodic extension of the sequences.\n- Design an algorithmic procedure to compute three outputs from the same $(x[n], h[n])$ pair:\n  1. A naive circular-convolution output $y_{\\text{circ}}[n]$ of length $N$ computed by equal-length DFT multiplication and IDFT.\n  2. A zero-padded frequency-domain output $y_{\\text{zp}}[n]$ of length $L = N + M - 1$ computed by padding both $x[n]$ and $h[n]$ to length $L$, multiplying their DFTs, and applying the IDFT.\n  3. An overlap-add output $y_{\\text{ola}}[n]$ of length $L = N + M - 1$ computed by partitioning $x[n]$ into blocks of size $B$, zero-padding each block sufficiently to prevent aliasing, multiplying by the zero-padded transform of $h[n]$, and summing overlapped partial results. Choose the frequency-domain length $K_{\\text{ola}}$ such that $K_{\\text{ola}} \\ge B + M - 1$, and for efficiency take $K_{\\text{ola}}$ to be the smallest power of two satisfying this bound.\n- Quantify wrap-around artifacts introduced by circular convolution when compared to the true linear convolution. Define the artifact error vector by $e_{\\text{circ}}[n] = y_{\\text{circ}}[n] - y_{\\text{true}}[n]$ for $0 \\le n \\le N-1$. Compute the relative artifact energy ratio $R_{\\text{circ}} = \\frac{\\sum_{n=0}^{N-1} e_{\\text{circ}}[n]^2}{\\sum_{n=0}^{N-1} y_{\\text{true}}[n]^2}$. Further, quantify the concentration of wrap-around by computing the fraction of the artifact energy in the leading edge of width $M-1$: $F_{\\text{edge}} = \\frac{\\sum_{n=0}^{M-2} e_{\\text{circ}}[n]^2}{\\sum_{n=0}^{N-1} e_{\\text{circ}}[n]^2}$, with the convention $F_{\\text{edge}} = 0$ if the denominator is zero.\n- Quantify the accuracy of the zero-padded and overlap-add outputs relative to the true linear convolution by computing $R_{\\text{zp}} = \\frac{\\sum_{n=0}^{L-1} \\left(y_{\\text{zp}}[n] - y_{\\text{true}}[n]\\right)^2}{\\sum_{n=0}^{L-1} y_{\\text{true}}[n]^2}$ and $R_{\\text{ola}} = \\frac{\\sum_{n=0}^{L-1} \\left(y_{\\text{ola}}[n] - y_{\\text{true}}[n]\\right)^2}{\\sum_{n=0}^{L-1} y_{\\text{true}}[n]^2}$.\n- Implement all computations in a single program that constructs test inputs and computes the specified metrics for a set of test cases.\n\nConstruct $x[n]$ and $h[n]$ for each test case as follows:\n- Create a sparse reflectivity $x[n]$ by placing $K_{\\text{spk}}$ spikes at random positions in $0 \\le n \\le N-1$ with amplitudes drawn uniformly from $[-1, 1]$, and zeros elsewhere. Fix randomness via a case-specific seed to ensure reproducibility.\n- Create a wavelet impulse response $h[n]$ of length $M$ as a discrete Ricker wavelet with unit energy, parameterized by a dimensionless peak parameter $f_0$. Let $t[n] = n - \\frac{M-1}{2}$, and define $h[n] = \\left(1 - 2 (\\pi f_0 t[n])^2 \\right) \\exp\\left( - (\\pi f_0 t[n])^2 \\right)$, normalized to have $\\sum_{n=0}^{M-1} h[n]^2 = 1$.\n\nUse the following test suite, where each tuple specifies $(N, M, f_0, K_{\\text{spk}}, \\text{seed}, B)$:\n- Case $1$: $(256, 51, 0.12, 12, 1, 64)$.\n- Case $2$: $(128, 65, 0.20, 8, 2, 32)$.\n- Case $3$: $(64, 63, 0.25, 6, 3, 16)$.\n- Case $4$: $(300, 41, 0.15, 15, 4, 100)$.\n\nFor each case, compute and return the list $[R_{\\text{circ}}, F_{\\text{edge}}, R_{\\text{zp}}, R_{\\text{ola}}]$ where all quantities are defined as above. Your program should produce a single line of output containing the results as a comma-separated list of these per-case lists enclosed in square brackets, in the format $[[r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}], [r_{2,1}, r_{2,2}, r_{2,3}, r_{2,4}], [r_{3,1}, r_{3,2}, r_{3,3}, r_{3,4}], [r_{4,1}, r_{4,2}, r_{4,3}, r_{4,4}]]$. There are no physical units in this problem, and angles do not appear; therefore no unit conversions are required. All outputs must be real-valued floats.",
            "solution": "The problem at hand requires a rigorous comparison of different discrete convolution methods based on the Discrete Fourier Transform (DFT), a cornerstone of computational signal processing in fields such as geophysics. We must derive the theoretical underpinnings, design algorithms for several convolution variants, and quantify their performance and artifacts.\n\n### 1. Theoretical Foundation: The Convolution Theorem and Its Implications\n\nThe relationship between time-domain convolution and frequency-domain multiplication is governed by the convolution theorem. We first establish this relationship for the DFT and clarify its consequences for finite-length signals.\n\nLet $x[n]$ and $h[n]$ be two finite-length sequences of length $N$ and $M$ respectively. The linear convolution, which models the output of a linear time-invariant (LTI) system, is defined as:\n$$y_{\\text{true}}[n] = (x * h)[n] = \\sum_{k=-\\infty}^{\\infty} x[k] h[n-k]$$\nGiven that $x[n]$ is non-zero only for $0 \\le n \\le N-1$ and $h[n]$ is non-zero only for $0 \\le n \\le M-1$, the resulting sequence $y_{\\text{true}}[n]$ is non-zero only for $0 \\le n \\le N+M-2$. Thus, its total length is $L = N+M-1$.\n\nThe DFT and its inverse (IDFT) are defined for a length-$K$ sequence $s[n]$ as:\n$$S[k] = \\text{DFT}_K\\{s[n]\\} = \\sum_{n=0}^{K-1} s[n] e^{-i 2 \\pi k n / K}$$\n$$s[n] = \\text{IDFT}_K\\{S[k]\\} = \\frac{1}{K} \\sum_{k=0}^{K-1} S[k] e^{i 2 \\pi k n / K}$$\nA critical property of the DFT is that it implicitly treats any finite input sequence of length $K$ as a single period of an infinitely periodic sequence with period $K$. This is because the basis functions $e^{i 2 \\pi k n / K}$ are themselves periodic in $n$ with period $K$.\n\nLet us derive the time-domain operation corresponding to multiplication in the frequency domain. Let $y[n] = \\text{IDFT}_K\\{X[k]H[k]\\}$, where $X[k]=\\text{DFT}_K\\{x[n]\\}$ and $H[k]=\\text{DFT}_K\\{h[n]\\}$ (assuming both sequences are first padded or truncated to length $K$).\n$$y[n] = \\frac{1}{K} \\sum_{k=0}^{K-1} X[k]H[k] e^{i 2 \\pi k n / K}$$\nSubstitute the definition of $H[k]$:\n$$y[n] = \\frac{1}{K} \\sum_{k=0}^{K-1} X[k] \\left( \\sum_{m=0}^{K-1} h[m] e^{-i 2 \\pi k m / K} \\right) e^{i 2 \\pi k n / K}$$\nRearranging the terms:\n$$y[n] = \\sum_{m=0}^{K-1} h[m] \\left( \\frac{1}{K} \\sum_{k=0}^{K-1} X[k] e^{i 2 \\pi k (n-m) / K} \\right)$$\nThe term in the parenthesis is the definition of $\\text{IDFT}_K\\{X[k]\\}$ evaluated at time $(n-m)$. This is simply $x[n-m]$. However, due to the periodic nature of the DFT, this index is implicitly taken modulo $K$. Thus:\n$$y[n] = \\sum_{m=0}^{K-1} h[m] x[(n-m) \\pmod K]$$\nThis is the definition of **circular convolution** of length $K$. Therefore, multiplying the DFTs of two sequences is equivalent to performing circular convolution in the time domain, not linear convolution.\n\nTo compute linear convolution using the DFT, we must prevent the \"wrap-around\" effect of circular convolution. The linear convolution result has length $L = N+M-1$. If we choose a DFT length $K \\ge L$, the result of the circular convolution will have enough space to not wrap around. The result of the $K$-point circular convolution will be identical to the linear convolution result for the first $L$ points, followed by $K-L$ zeros.\n\n### 2. Algorithmic Design and Analysis\n\nBased on the theory above, we design the required computational procedures.\n\n**1. True Linear Convolution ($y_{\\text{true}}[n]$)**\nThis is the ground truth, computed directly in the time domain using the definition of linear convolution. This can be implemented via a direct summation or standard library functions (e.g., `numpy.convolve`). The output has length $L = N+M-1$.\n\n**2. Naive Circular Convolution ($y_{\\text{circ}}[n]$)**\nThis procedure demonstrates the wrap-around artifact. The length is specified as $N$.\n- Pad the impulse response $h[n]$ with zeros to match the length of the input signal, $N$. Let this be $h_N[n]$.\n- Compute the length-$N$ DFTs: $X[k] = \\text{DFT}_N\\{x[n]\\}$ and $H_N[k] = \\text{DFT}_N\\{h_N[n]\\}$.\n- Multiply the transforms: $Y_{\\text{circ}}[k] = X[k] \\cdot H_N[k]$.\n- Compute the inverse transform: $y_{\\text{circ}}[n] = \\text{IDFT}_N\\{Y_{\\text{circ}}[k]\\}$.\nThe result is a length-$N$ sequence. The portion of the linear convolution that would extend past index $N-1$ (the \"tail\") wraps around and is added to the beginning of the sequence. For $0 \\le n \\le M-2$, $y_{\\text{circ}}[n] = y_{\\text{true}}[n] + y_{\\text{true}}[n+N]$, which is the source of the artifact $e_{\\text{circ}}[n]$ in this range.\n\n**3. Zero-Padded Frequency-Domain Convolution ($y_{\\text{zp}}[n]$)**\nThis is the standard and correct method for computing linear convolution via the FFT.\n- Determine the required output length: $L = N+M-1$.\n- Pad both $x[n]$ and $h[n]$ with zeros to length $L$. Let these be $x_L[n]$ and $h_L[n]$.\n- Compute the length-$L$ DFTs: $X_L[k] = \\text{DFT}_L\\{x_L[n]\\}$ and $H_L[k] = \\text{DFT}_L\\{h_L[n]\\}$.\n- Multiply the transforms and invert: $y_{\\text{zp}}[n] = \\text{IDFT}_L\\{X_L[k] \\cdot H_L[k]\\}$.\nThe resulting sequence $y_{\\text{zp}}[n]$ will be of length $L$ and, ignoring floating-point errors, will be identical to $y_{\\text{true}}[n]$.\n\n**4. Overlap-Add Block Convolution ($y_{\\text{ola}}[n]$)**\nThis is an efficient method for convolving a long signal $x[n]$ with a shorter filter $h[n]$.\n- Partition the input signal $x[n]$ into non-overlapping blocks of size $B$.\n- Determine the FFT size, $K_{\\text{ola}}$, required to compute the linear convolution of a block with $h[n]$ without aliasing. We need $K_{\\text{ola}} \\ge B+M-1$. For efficiency, $K_{\\text{ola}}$ is chosen as the smallest power of two satisfying this condition.\n- Pre-compute the zero-padded, length-$K_{\\text{ola}}$ DFT of the filter: $h[n]$ is padded to length $K_{\\text{ola}}$ and transformed to $H_{\\text{ola}}[k]$.\n- Initialize an output buffer $y_{\\text{ola}}[n]$ of length $L = N+M-1$ to all zeros.\n- For each block $x_i[n]$ of $x[n]$ (starting at time index $i \\cdot B$):\n    - Pad the block $x_i[n]$ to length $K_{\\text{ola}}$.\n    - Compute its DFT, $X_i[k]$, and multiply by the stored $H_{\\text{ola}}[k]$ to get $Y_i[k]$.\n    - Compute the inverse DFT, $y_i[n] = \\text{IDFT}_{K_{\\text{ola}}}\\{Y_i[k]\\}$. This is the linear convolution of the block.\n    - Add this result $y_i[n]$ into the main output buffer $y_{\\text{ola}}[n]$ at the correct starting position, $i \\cdot B$. The results of consecutive blocks will overlap by $M-1$ samples and are summed together.\nLike $y_{\\text{zp}}[n]$, the final result $y_{\\text{ola}}[n]$ should be identical to $y_{\\text{true}}[n]$ up to numerical precision.\n\n### 3. Quantification of Artifacts and Accuracy\n\nThe problem requires a set of metrics to quantify the differences between these methods.\n- **Relative Circular Artifact Energy ($R_{\\text{circ}}$)**: $R_{\\text{circ}} = \\frac{\\sum_{n=0}^{N-1} (y_{\\text{circ}}[n] - y_{\\text{true}}[n])^2}{\\sum_{n=0}^{N-1} y_{\\text{true}}[n]^2}$. This measures the energy of the error introduced by circular wrap-around, relative to the energy of the true signal over the same interval.\n- **Leading Edge Error Fraction ($F_{\\text{edge}}$)**: $F_{\\text{edge}} = \\frac{\\sum_{n=0}^{M-2} e_{\\text{circ}}[n]^2}{\\sum_{n=0}^{N-1} e_{\\text{circ}}[n]^2}$. This quantifies how much of the total wrap-around error energy is concentrated in the first $M-1$ samples of the output, which is the region directly affected by the tail wrapping around.\n- **Relative Accuracy of Padded/Overlap-Add Methods ($R_{\\text{zp}}, R_{\\text{ola}}$)**:\n  $R_{\\text{zp}} = \\frac{\\sum_{n=0}^{L-1} (y_{\\text{zp}}[n] - y_{\\text{true}}[n])^2}{\\sum_{n=0}^{L-1} y_{\\text{true}}[n]^2}$ and $R_{\\text{ola}} = \\frac{\\sum_{n=0}^{L-1} (y_{\\text{ola}}[n] - y_{\\text{true}}[n])^2}{\\sum_{n=0}^{L-1} y_{\\text{true}}[n]^2}$. These measure the relative mean squared error for the zero-padded and overlap-add methods compared to the true linear convolution. Since these methods are theoretically exact, these values should be extremely small, on the order of machine precision, reflecting only floating-point arithmetic inaccuracies.\n  \nThe implementation will construct the specified input signals and compute these four metrics for each test case.",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft\n\ndef compute_metrics_for_case(case_params):\n    \"\"\"\n    Computes all required convolution variants and error metrics for a single test case.\n    \"\"\"\n    N, M, f0, K_spk, seed, B = case_params\n    L = N + M - 1\n\n    # --- 1. Construct input signals x[n] and h[n] ---\n    \n    # Sparse reflectivity x[n]\n    rng = np.random.default_rng(seed)\n    spike_indices = rng.choice(N, size=K_spk, replace=False)\n    spike_amplitudes = rng.uniform(-1, 1, size=K_spk)\n    x = np.zeros(N)\n    x[spike_indices] = spike_amplitudes\n\n    # Ricker wavelet h[n]\n    t = np.arange(M) - (M - 1) / 2.0\n    term = (np.pi * f0 * t)**2\n    h = (1 - 2 * term) * np.exp(-term)\n    h /= np.linalg.norm(h) # Normalize to unit energy\n\n    # --- 2. Compute convolution outputs ---\n\n    # Method 1: True Linear Convolution (ground truth)\n    y_true = np.convolve(x, h)\n\n    # Method 2: Naive Circular Convolution\n    h_N = np.zeros(N)\n    if M > 0:\n      h_N[:M] = h\n    Y_circ_k = fft(x) * fft(h_N)\n    y_circ = ifft(Y_circ_k).real\n\n    # Method 3: Zero-Padded Frequency-Domain Convolution\n    x_L = np.zeros(L)\n    x_L[:N] = x\n    h_L = np.zeros(L)\n    h_L[:M] = h\n    Y_zp_k = fft(x_L) * fft(h_L)\n    y_zp = ifft(Y_zp_k).real\n    \n    # Method 4: Overlap-Add Block Convolution\n    L_block = B + M - 1\n    # Smallest power of 2 >= L_block\n    K_ola = 1  (L_block - 1).bit_length() if L_block > 0 else 1\n    \n    h_ola = np.zeros(K_ola)\n    h_ola[:M] = h\n    H_ola_k = fft(h_ola)\n    \n    y_ola = np.zeros(L)\n    num_blocks = int(np.ceil(N / B))\n\n    for i in range(num_blocks):\n        start = i * B\n        end = min((i + 1) * B, N)\n        x_block = x[start:end]\n        \n        x_block_padded = np.zeros(K_ola)\n        x_block_padded[:len(x_block)] = x_block\n        \n        Y_block_k = fft(x_block_padded) * H_ola_k\n        y_block = ifft(Y_block_k).real\n        \n        add_len = min(K_ola, L - start)\n        y_ola[start : start + add_len] += y_block[:add_len]\n\n    # --- 3. Quantify artifacts and accuracy ---\n\n    # R_circ and F_edge\n    y_true_N = y_true[:N]\n    e_circ = y_circ - y_true_N\n    \n    den_y_true_N_sq = np.sum(y_true_N**2)\n    R_circ = np.sum(e_circ**2) / den_y_true_N_sq if den_y_true_N_sq > 0 else 0.0\n\n    err_e_circ_sq = np.sum(e_circ**2)\n    F_edge = np.sum(e_circ[:M-1]**2) / err_e_circ_sq if err_e_circ_sq > 0 else 0.0\n\n    # R_zp and R_ola\n    den_y_true_sq = np.sum(y_true**2)\n    \n    e_zp = y_zp - y_true\n    R_zp = np.sum(e_zp**2) / den_y_true_sq if den_y_true_sq > 0 else 0.0\n    \n    e_ola = y_ola - y_true\n    R_ola = np.sum(e_ola**2) / den_y_true_sq if den_y_true_sq > 0 else 0.0\n    \n    return [R_circ, F_edge, R_zp, R_ola]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (N, M, f0, K_spk, seed, B)\n        (256, 51, 0.12, 12, 1, 64),\n        (128, 65, 0.20, 8, 2, 32),\n        (64, 63, 0.25, 6, 3, 16),\n        (300, 41, 0.15, 15, 4, 100),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = compute_metrics_for_case(case)\n        results.append(case_results)\n\n    # Format the final output string\n    # str(list) automatically adds brackets, so map(str, results) and then join\n    # gives the desired \"[[...],[...]]\" structure.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}