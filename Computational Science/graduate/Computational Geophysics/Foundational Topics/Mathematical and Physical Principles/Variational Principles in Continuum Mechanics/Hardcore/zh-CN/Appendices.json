{
    "hands_on_practices": [
        {
            "introduction": "本练习通过关注运动学——对运动和变形的描述——来为后续内容奠定基础。在我们能够构建能量泛函之前，我们必须掌握一套精确的数学语言来描述应变。本练习将引导你为一个简单但富有启发性的位移场计算小应变张量，并将其直接与不可压缩性概念联系起来，而后者是建立地球地幔模型的关键约束条件。掌握这种联系  是构建稳健的地球动力学变分模型的第一步。",
            "id": "3618612",
            "problem": "考虑一个占据有界域 $\\Omega \\subset \\mathbb{R}^{3}$ 的三维线性弹性岩石，它经历了一个由位移场 $u:\\Omega \\to \\mathbb{R}^{3}$ 描述的小变形。在适用于连续介质力学中小应变的线性化运动学中，无穷小应变张量定义为 $\\varepsilon(u) = \\tfrac{1}{2}\\left(\\nabla u + (\\nabla u)^{T}\\right)$。在近不可压缩线性弹性的变分形式中，等容（体积保持）约束来自于一个包含拉格朗日乘子场 $p$ 的拉格朗日量的驻值条件，该乘子场强制 $\\operatorname{tr}(\\varepsilon(u)) = 0$。假设一个空间仿射位移场 $u(x) = \\alpha\\, x\\, e_{1} + \\beta\\, y\\, e_{2} + \\gamma\\, z\\, e_{3}$，其中系数 $\\alpha, \\beta, \\gamma \\in \\mathbb{R}$ 为常数，$\\{e_{1}, e_{2}, e_{3}\\}$ 是 $\\mathbb{R}^{3}$ 的标准基，且 $x=(x,y,z)$。\n\n任务：\n1. 从位移梯度和小应变张量的定义出发，计算给定 $u(x)$ 的 $\\nabla u$ 和 $\\varepsilon(u)$。\n2. 使用连续介质力学的一阶运动学和质量守恒，推导用 $\\varepsilon(u)$ 表示的相对体积变化的线性化表达式，并说明由带有任意拉格朗日乘子场 $p$ 的变分约束所产生的体积保持条件。\n3. 表达在小应变意义下，体积保持对 $\\alpha, \\beta, \\gamma$ 所施加的条件。\n\n答案规格：\n- 您最终报告的量必须是用 $\\alpha, \\beta, \\gamma$ 表示的体积应变 $\\operatorname{tr}(\\varepsilon(u))$ 的解析表达式。\n- 不需要数值计算。\n- 不要包含单位。\n- 最终答案中不要报告不等式或方程；只报告所要求的表达式。",
            "solution": "在尝试解答之前，将对问题进行验证。\n\n### 步骤 1：提取已知条件\n- 一个三维线性弹性体占据有界域 $\\Omega \\subset \\mathbb{R}^{3}$。\n- 变形是微小的，由位移场 $u:\\Omega \\to \\mathbb{R}^{3}$ 描述。\n- 无穷小应变张量定义为 $\\varepsilon(u) = \\tfrac{1}{2}\\left(\\nabla u + (\\nabla u)^{T}\\right)$。\n- 一个等容（体积保持）约束 $\\operatorname{tr}(\\varepsilon(u)) = 0$ 由一个拉格朗日乘子场 $p$ 强制执行。\n- 特定位移场为 $u(x) = \\alpha\\, x\\, e_{1} + \\beta\\, y\\, e_{2} + \\gamma\\, z\\, e_{3}$。\n- 系数 $\\alpha, \\beta, \\gamma \\in \\mathbb{R}$ 是常数。\n- 基 $\\{e_{1}, e_{2}, e_{3}\\}$ 是 $\\mathbb{R}^{3}$ 的标准基。\n- 位置矢量为 $x=(x,y,z)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题牢固地植根于线性连续介质力学的原理。位移场、位移梯度和小应变张量的定义都是标准的。使用拉格朗日乘子来施加不可压缩性约束是模拟近不可压缩材料的变分方法的基石。该问题在科学上是合理的。\n- **适定性：** 该问题提供了所有必要的定义和位移场的特定函数形式，从而可以直接且唯一地计算所要求的量。任务定义清晰，并导向一个唯一的解。\n- **客观性：** 该问题使用精确、客观的数学语言陈述，没有歧义或主观内容。\n\n### 步骤 3：结论与行动\n问题是有效的。这是一个应用连续介质力学基本定义的适定且有科学依据的练习。现在将提供解答。\n\n***\n\n解答过程将处理问题陈述中指定的三个任务。最终答案将是所要求的表达式。\n\n**1. 位移梯度和应变张量的计算**\n\n位移场 $u(x)$ 以坐标 $x, y, z$ 的函数的分量形式给出。设位置矢量为 $x = x_1 e_1 + x_2 e_2 + x_3 e_3$，其中 $(x_1, x_2, x_3) = (x, y, z)$。位移矢量 $u$ 由下式给出：\n$$\nu(x,y,z) = u_1 e_1 + u_2 e_2 + u_3 e_3 = (\\alpha x) e_1 + (\\beta y) e_2 + (\\gamma z) e_3\n$$\n位移梯度张量 $\\nabla u$ 是一个二阶张量，其在笛卡尔坐标系中的分量为 $(\\nabla u)_{ij} = \\frac{\\partial u_i}{\\partial x_j}$。我们计算这些分量：\n$$\n\\frac{\\partial u_1}{\\partial x_1} = \\frac{\\partial (\\alpha x)}{\\partial x} = \\alpha\n$$\n$$\n\\frac{\\partial u_2}{\\partial x_2} = \\frac{\\partial (\\beta y)}{\\partial y} = \\beta\n$$\n$$\n\\frac{\\partial u_3}{\\partial x_3} = \\frac{\\partial (\\gamma z)}{\\partial z} = \\gamma\n$$\n所有其他的偏导数均为零，例如 $\\frac{\\partial u_1}{\\partial x_2} = \\frac{\\partial (\\alpha x)}{\\partial y} = 0$。\n因此，位移梯度张量 $\\nabla u$ 的矩阵表示为：\n$$\n\\nabla u = \n\\begin{pmatrix}\n\\frac{\\partial u_1}{\\partial x_1} & \\frac{\\partial u_1}{\\partial x_2} & \\frac{\\partial u_1}{\\partial x_3} \\\\\n\\frac{\\partial u_2}{\\partial x_1} & \\frac{\\partial u_2}{\\partial x_2} & \\frac{\\partial u_2}{\\partial x_3} \\\\\n\\frac{\\partial u_3}{\\partial x_1} & \\frac{\\partial u_3}{\\partial x_2} & \\frac{\\partial u_3}{\\partial x_3}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\alpha & 0 & 0 \\\\\n0 & \\beta & 0 \\\\\n0 & 0 & \\gamma\n\\end{pmatrix}\n$$\n接下来，我们使用其定义计算无穷小应变张量 $\\varepsilon(u)$：\n$$\n\\varepsilon(u) = \\frac{1}{2} \\left( \\nabla u + (\\nabla u)^T \\right)\n$$\n$\\nabla u$ 的转置是：\n$$\n(\\nabla u)^T = \n\\begin{pmatrix}\n\\alpha & 0 & 0 \\\\\n0 & \\beta & 0 \\\\\n0 & 0 & \\gamma\n\\end{pmatrix}^T\n=\n\\begin{pmatrix}\n\\alpha & 0 & 0 \\\\\n0 & \\beta & 0 \\\\\n0 & 0 & \\gamma\n\\end{pmatrix}\n$$\n由于 $\\nabla u$ 是一个对角矩阵，所以它是对称的，即 $(\\nabla u)^T = \\nabla u$。将此代入 $\\varepsilon(u)$ 的定义中：\n$$\n\\varepsilon(u) = \\frac{1}{2} \\left( \\nabla u + \\nabla u \\right) = \\frac{1}{2} (2 \\nabla u) = \\nabla u\n$$\n因此，对于这个特定的仿射位移场，无穷小应变张量与位移梯度相同：\n$$\n\\varepsilon(u) = \n\\begin{pmatrix}\n\\alpha & 0 & 0 \\\\\n0 & \\beta & 0 \\\\\n0 & 0 & \\gamma\n\\end{pmatrix}\n$$\n\n**2. 线性化体积变化与等容条件**\n\n局部体积变化由变形映射的雅可比行列式 $J = \\det(F)$ 描述，其中 $F$ 是变形梯度。变形梯度定义为 $F = I + \\nabla u$，其中 $I$ 是二阶单位张量。\n$$\nF = \n\\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n+\n\\begin{pmatrix}\n\\alpha & 0 & 0 \\\\\n0 & \\beta & 0 \\\\\n0 & 0 & \\gamma\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1+\\alpha & 0 & 0 \\\\\n0 & 1+\\beta & 0 \\\\\n0 & 0 & 1+\\gamma\n\\end{pmatrix}\n$$\n雅可比行列式为：\n$$\nJ = \\det(F) = (1+\\alpha)(1+\\beta)(1+\\gamma) = 1 + (\\alpha+\\beta+\\gamma) + (\\alpha\\beta+\\beta\\gamma+\\gamma\\alpha) + \\alpha\\beta\\gamma\n$$\n相对体积变化 $\\Delta V / V_0$ 由 $J-1$ 给出。\n$$\n\\frac{\\Delta V}{V_0} = J-1 = (\\alpha+\\beta+\\gamma) + (\\alpha\\beta+\\beta\\gamma+\\gamma\\alpha) + \\alpha\\beta\\gamma\n$$\n该问题是在小应变线性化运动学的背景下设定的。这意味着系数 $\\alpha$、$\\beta$ 和 $\\gamma$ 很小（即 $|\\alpha| \\ll 1$, $|\\beta| \\ll 1$, $|\\gamma| \\ll 1$）。因此，我们可以忽略二阶及更高阶的项，如 $\\alpha\\beta$、$\\beta\\gamma$、$\\gamma\\alpha$ 和 $\\alpha\\beta\\gamma$。因此，线性化的相对体积变化为：\n$$\n\\left(\\frac{\\Delta V}{V_0}\\right)_{\\text{linearized}} \\approx \\alpha+\\beta+\\gamma\n$$\n连续介质力学中的一个一般性结论指出，对于小应变，相对体积变化等于应变张量的迹，也称为体积应变。让我们对我们的具体情况进行验证。$\\varepsilon(u)$ 的迹是其对角分量之和：\n$$\n\\operatorname{tr}(\\varepsilon(u)) = \\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33} = \\alpha + \\beta + \\gamma\n$$\n这证实了 $\\operatorname{tr}(\\varepsilon(u))$ 代表了线性化体积应变。问题指出，体积保持（等容变形）是通过一个将体积应变设置为零的约束来强制执行的。这是从变分形式中产生的条件。因此，在小应变意义下，保持体积所需的条件是：\n$$\n\\operatorname{tr}(\\varepsilon(u)) = 0\n$$\n\n**3. 对 $\\alpha, \\beta, \\gamma$ 的条件**\n\n从上一步可知，体积保持条件是 $\\operatorname{tr}(\\varepsilon(u)) = 0$。使用根据系数推导出的迹的表达式，我们得到施加在 $\\alpha$、$\\beta$ 和 $\\gamma$ 上的条件：\n$$\n\\alpha + \\beta + \\gamma = 0\n$$\n问题要求的是体积应变 $\\operatorname{tr}(\\varepsilon(u))$ 的解析表达式。根据我们的计算，这个表达式是 $\\alpha + \\beta + \\gamma$。",
            "answer": "$$\n\\boxed{\\alpha + \\beta + \\gamma}\n$$"
        },
        {
            "introduction": "在应变运动学描述的基础上，下一个练习将介绍变分力学的核心引擎：驻定势能原理。通过为一个简单的弹性杆构建能量泛函，你将看到，仅仅要求该能量保持驻定（对于稳定平衡，即取最小值），便能自动导出系统的控制微分方程及其正确的物理边界条件。这种一个标量原理蕴含了所有矢量场物理的强大思想 ，是有限元法等方法优雅性和实用性的核心。",
            "id": "3618647",
            "problem": "考虑一根静态的一维弹性岩石柱（杆），占据区间 $x \\in [0,L]$，其横截面积 $A(x) > 0$ 和杨氏模量 $E(x) > 0$ 均随空间变化。设 $u(x)$ 表示轴向位移场。左端被夹紧，施加了本质边界条件 $u(0) = 0$。在右端 $x=L$ 处作用有规定的向外牵引力 $T$（单位面积上的力）。沿杆作用有分布体力（单位体积的力）$b(x)$，用于模拟重力载荷。假设小应变，一维应变为 $\\varepsilon(x) = u'(x)$；线性弹性，柯西应力为 $\\sigma(x) = E(x)\\,\\varepsilon(x)$；并忽略惯性。\n\n使用总势能驻值原理以及基本的运动学和本构关系，完成以下任务：\n- 通过将弹性应变能相加，并减去外力（体力 $b(x)$ 和在 $x=L$ 处的边界牵引力 $T$）的势，构建总势能泛函 $\\Pi[u]$。\n- 计算一阶变分 $\\delta \\Pi[u;\\delta u]$，并通过分部积分得到内部项和边界项，同时遵守本质边界条件 $u(0)=0$。\n- 从任意容许变分的驻值条件出发，确定在 $x=L$ 处必须满足的自然边界条件，用 $E(x)$、$A(x)$、$u'(x)$ 和 $T$ 表示。\n\n将您的最终答案表示为在 $x=L$ 处的边界条件的左侧减去右侧的单个封闭形式解析表达式。最终表达式中不要包含单位。不需要进行数值计算或四舍五入。",
            "solution": "该问题要求使用总势能驻值原理推导一维弹性杆的自然边界条件。解答过程分三步：首先，构建总势能泛函 $\\Pi[u]$；其次，计算其一阶变分 $\\delta \\Pi$；第三，从驻值原理推导出边界条件。\n\n**1. 构建总势能泛函 $\\Pi[u]$**\n系统的总势能 $\\Pi[u]$ 是储存在杆中的弹性应变能 $U$ 减去外力的势 $W_{\\text{ext}}$。\n$$ \\Pi[u] = U - W_{\\text{ext}} $$\n弹性应变能密度（单位体积的能量）为 $w = \\frac{1}{2} \\sigma(x) \\varepsilon(x)$。使用本构关系 $\\sigma(x) = E(x) \\varepsilon(x)$ 和小应变的运动学关系 $\\varepsilon(x) = u'(x) = \\frac{du}{dx}$，应变能密度变为：\n$$ w(x) = \\frac{1}{2} E(x) [u'(x)]^2 $$\n总应变能 $U$ 是通过将 $w(x)$ 在杆的体积上积分得到的。微分体积元为 $dV = A(x) dx$。\n$$ U = \\int_{\\text{Volume}} w \\, dV = \\int_0^L w(x) A(x) \\, dx = \\int_0^L \\frac{1}{2} E(x) A(x) [u'(x)]^2 \\, dx $$\n外力的势 $W_{\\text{ext}}$ 是由分布体力 $b(x)$ 和边界牵引力 $T$ 所做的功。功是力乘以位移的积分。\n体力 $b(x)$（单位体积的力）所做的功为：\n$$ W_b = \\int_{\\text{Volume}} b(x) u(x) \\, dV = \\int_0^L b(x) A(x) u(x) \\, dx $$\n在边界 $x=L$ 处，向外牵引力 $T$（单位面积的力）所做的功是该边界上的总力 $F_L = T \\cdot A(L)$ 乘以该点的位移 $u(L)$。\n$$ W_T = (T A(L)) u(L) $$\n外力的总势是这些功分量的总和：\n$$ W_{\\text{ext}} = W_b + W_T = \\int_0^L b(x) A(x) u(x) \\, dx + T A(L) u(L) $$\n综合这些结果，总势能泛函 $\\Pi[u]$ 为：\n$$ \\Pi[u] = \\int_0^L \\frac{1}{2} E(x) A(x) [u'(x)]^2 \\, dx - \\left( \\int_0^L b(x) A(x) u(x) \\, dx + T A(L) u(L) \\right) $$\n$$ \\Pi[u] = \\int_0^L \\left( \\frac{1}{2} E(x) A(x) [u'(x)]^2 - b(x) A(x) u(x) \\right) dx - T A(L) u(L) $$\n\n**2. 计算一阶变分 $\\delta \\Pi[u; \\delta u]$**\n势能驻值原理指出，为使系统处于平衡状态，$\\Pi[u]$ 的一阶变分对于所有容许变分 $\\delta u(x)$ 都必须为零。容许变分必须与本质边界条件一致。由于 $u(0)=0$ 是一个本质边界条件，任何容许变分都必须满足 $\\delta u(0) = 0$。\n\n一阶变分 $\\delta \\Pi$ 是通过求 $\\Pi[u]$ 在任意容许变分 $\\delta u$ 方向上的 Gâteaux 导数来计算的。\n$$ \\delta \\Pi = \\frac{d}{d\\epsilon} \\Pi[u + \\epsilon \\delta u] \\bigg|_{\\epsilon=0} $$\n将此应用于 $\\Pi[u]$ 的每一项：\n$$ \\delta \\Pi = \\delta \\left( \\int_0^L \\frac{1}{2} E(x) A(x) [u'(x)]^2 \\, dx \\right) - \\delta \\left( \\int_0^L b(x) A(x) u(x) \\, dx \\right) - \\delta \\left( T A(L) u(L) \\right) $$\n$$ \\delta \\Pi = \\int_0^L E(x) A(x) u'(x) \\delta u'(x) \\, dx - \\int_0^L b(x) A(x) \\delta u(x) \\, dx - T A(L) \\delta u(L) $$\n为了提出因子 $\\delta u(x)$，我们对第一项进行分部积分（$\\int v \\, dw = [vw] - \\int w \\, dv$）：\n令 $v = E(x) A(x) u'(x)$ 且 $dw = \\delta u'(x) dx$。则 $dv = \\frac{d}{dx}[E(x) A(x) u'(x)] dx$ 且 $w = \\delta u(x)$。\n$$ \\int_0^L E(x) A(x) u'(x) \\delta u'(x) \\, dx = \\left[ E(x) A(x) u'(x) \\delta u(x) \\right]_0^L - \\int_0^L \\left( \\frac{d}{dx}[E(x) A(x) u'(x)] \\right) \\delta u(x) \\, dx $$\n将其代回 $\\delta \\Pi$ 的表达式中：\n$$ \\delta \\Pi = \\left[ E(x) A(x) u'(x) \\delta u(x) \\right]_0^L - \\int_0^L \\frac{d}{dx}[E(x) A(x) u'(x)] \\delta u(x) \\, dx - \\int_0^L b(x) A(x) \\delta u(x) \\, dx - T A(L) \\delta u(L) $$\n我们可以合并积分项并展开边界项：\n$$ \\delta \\Pi = -\\int_0^L \\left( \\frac{d}{dx}[E(x) A(x) u'(x)] + b(x) A(x) \\right) \\delta u(x) \\, dx + E(L) A(L) u'(L) \\delta u(L) - E(0) A(0) u'(0) \\delta u(0) - T A(L) \\delta u(L) $$\n应用容许变分的条件 $\\delta u(0) = 0$，在 $x=0$ 处的项消失。将 $x=L$ 处的剩余边界项组合在一起，得到一阶变分的最终形式：\n$$ \\delta \\Pi = -\\int_0^L \\left( \\frac{d}{dx}[E(x) A(x) u'(x)] + b(x) A(x) \\right) \\delta u(x) \\, dx + \\left[ E(L) A(L) u'(L) - T A(L) \\right] \\delta u(L) $$\n\n**3. 确定自然边界条件**\n驻值条件要求对于所有容许变分 $\\delta u(x)$，$\\delta \\Pi = 0$。\n$$ -\\int_0^L \\left( \\frac{d}{dx}[E(x) A(x) u'(x)] + b(x) A(x) \\right) \\delta u(x) \\, dx + \\left[ E(L) A(L) u'(L) - T A(L) \\right] \\delta u(L) = 0 $$\n根据变分法基本引理，由于该方程必须对 $\\delta u(x)$ 的任何选择（其中 $\\delta u(0)=0$）都成立，因此积分部分和边界部分必须各自独立为零。\n积分部分给出了欧拉-拉格朗日方程，这是域内部 $(0, L)$ 平衡的控制微分方程：\n$$ \\frac{d}{dx}[E(x) A(x) u'(x)] + b(x) A(x) = 0 $$\n边界部分涉及变分 $\\delta u(L)$，它是任意的，因为在 $x=L$ 处的位移没有被规定为本质边界条件。为了使边界项对任何 $\\delta u(L)$ 都为零，其系数必须为零。这得出了在 $x=L$ 处的自然边界条件：\n$$ E(L) A(L) u'(L) - T A(L) = 0 $$\n该条件表明，边界处的内力 $\\sigma(L) A(L) = E(L) u'(L) A(L)$ 必须与施加的总外力 $T A(L)$ 相平衡。\n\n问题要求一个等于该边界条件的左侧减去右侧的表达式。该条件可以写成 $E(L) A(L) u'(L) = T A(L)$。因此，所要求的表达式为：\n$$ E(L) A(L) u'(L) - T A(L) $$\n表达式中的所有项，$E(L)$、$A(L)$、$u'(L)$ 和 $T$，都与问题陈述一致。",
            "answer": "$$\n\\boxed{E(L) A(L) u'(L) - T A(L)}\n$$"
        },
        {
            "introduction": "最后的这个练习实现了从静态平衡到动态耗散过程的飞跃，展示了变分原理在计算地球物理学中的现代应用。我们将一个物理过程——沉积物压实——构建为一个“梯度流”，其中系统状态随时间演化，以持续最小化一个自由能泛函。本练习  弥合了从解析理论到数值实现的鸿沟，引导你推导控制偏微分方程，对其进行离散化，甚至使用最终模型通过与合成数据进行比对来校准参数，从而解决一个反演问题。",
            "id": "3618641",
            "problem": "考虑一个占据区间 $z \\in [0,H]$ 的一维垂直沉积物柱，其深度坐标为 $z$，无量纲孔隙度场为 $\\phi(z,t) \\in (0,1)$。将 $\\phi$ 视为一个内变量，在度量诱导的耗散作用下演化以最小化一个自由能泛函。从在由 Lebesgue 空间 $L^2$ 诱导的度量下的 Hilbert 空间中，梯度流在满足一个迁移率（耗散）系数的条件下使自由能下降最快的原理出发，将沉积物压实建模为以下自由能泛函的梯度流\n$$\n\\mathcal{E}[\\phi] \\;=\\; \\int_0^H \\left[ \\frac{a}{2}\\,(\\phi(z)-\\phi_{\\mathrm{ref}})^2 \\;+\\; \\frac{\\kappa}{2}\\,\\left(\\partial_z \\phi(z)\\right)^2 \\;+\\; \\beta\\,z\\,\\phi(z) \\right]\\,\\mathrm{d}z,\n$$\n其中 $a \\gt 0$ 是局部储存刚度，$\\kappa \\ge 0$ 是梯度惩罚（正则化）系数，$\\phi_{\\mathrm{ref}} \\in (0,1)$ 是参考孔隙度，$\\beta \\gt 0$ 用于缩放重力载荷。在 $L^2$ 内积中，具有恒定迁移率 $M \\gt 0$（解释为耗散度量的倒数）的 Rayleigh 原理产生了梯度流偏微分方程（PDE）\n$$\n\\partial_t \\phi \\;=\\; - M \\,\\frac{\\delta \\mathcal{E}}{\\delta \\phi} \\;=\\; -M\\,\\Big(a(\\phi-\\phi_{\\mathrm{ref}}) - \\kappa\\,\\partial_{zz}\\phi + \\beta\\,z\\Big),\n$$\n该方程具有齐次 Neumann 边界条件 $\\partial_z \\phi(0,t) = \\partial_z \\phi(H,t) = 0$ 和给定的初始条件 $\\phi(z,0) = \\phi_0(z)$。所有变量都是无量纲的，因此答案中不需要物理单位。\n\n您的任务是：\n- 推导上述 $\\mathcal{E}[\\phi]$ 的 Euler–Lagrange 变分 $\\delta \\mathcal{E}/\\delta \\phi$，并证明在 $L^2$ 度量和恒定迁移率 $M$ 下可以得到上述梯度流 PDE。\n- 使用二阶中心有限差分法（FDM）在空间上对 PDE 进行离散化，该方法作用于一个包含 $[0,H]$ 上 $N$ 个节点的均匀网格上，通过虚点反射施加齐次 Neumann 边界条件，并使用时间步长为 $\\Delta t$ 的无条件稳定的向后欧拉法在时间上进行离散化。\n- 给定在指定最终时间 $T$ 由相同模型生成的合成“钻孔”孔隙度-深度数据数组，通过最小化离散 $L^2$ 数据失配来校准耗散参数 $M$\n$$\nJ(M) \\;=\\; \\frac{1}{N}\\sum_{i=1}^N \\left(\\phi_{\\text{model}}(z_i,T;M)\\;-\\;\\phi_{\\text{data}}(z_i)\\right)^2.\n$$\n使用在 $M \\in [10^{-3},\\,20]$ 上的有界一维搜索来为每个测试确定最佳拟合的 $M$。\n\n实现要求：\n- 空间网格：$z_i = i\\,\\Delta z$，$i=0,\\dots,N-1$，其中 $\\Delta z = H/(N-1)$。\n- 空间算子：通过虚点反射实现的带有齐次 Neumann 边界条件的离散二阶导数，即在 $i=0$ 处使用 $\\phi_{-1}=\\phi_1$，在 $i=N-1$ 处使用 $\\phi_N=\\phi_{N-2}$。\n- 时间步进：对线性刚性项使用向后欧拉法，即从时间 $t^n$ 到 $t^{n+1}=t^n+\\Delta t$ 的一步为\n$$\n\\frac{\\phi^{n+1}-\\phi^n}{\\Delta t} \\;=\\; -M\\,\\Big(a\\,\\phi^{n+1} - \\kappa\\,\\partial_{zz}\\phi^{n+1} - a\\,\\phi_{\\mathrm{ref}} + \\beta\\,z\\Big).\n$$\n- 初始条件：对于所有 $z$，$\\phi_0(z) \\equiv \\phi_{\\mathrm{ref}}$。\n- 最终时间：$T$。\n- 目标：确定最小化 $J(M)$ 的迁移率 $M$。\n\n测试套件：\n对于以下三个参数集中的每一个，合成数据 $\\phi_{\\text{data}}(z_i)$ 将通过使用列出的“真实”迁移率 $M_{\\text{true}}$ 运行正演模型至时间 $T$ 生成，初始条件为 $\\phi_0(z) = \\phi_{\\mathrm{ref}}$。然后，仅使用参数集和合成数据，通过最小化 $J(M)$ 来估计最佳拟合的 $M$。\n\n- 测试 1（一般情况）：\n  - $a = 1.0$, $\\kappa = 0.01$, $\\beta = 0.5$, $\\phi_{\\mathrm{ref}} = 0.6$, $H = 1.0$, $N = 101$, $T = 1.0$, $M_{\\text{true}} = 2.0$。\n- 测试 2（无梯度正则化的边界情况）：\n  - $a = 1.0$, $\\kappa = 0.0$, $\\beta = 1.0$, $\\phi_{\\mathrm{ref}} = 0.65$, $H = 1.0$, $N = 81$, $T = 0.25$, $M_{\\text{true}} = 5.0$。\n- 测试 3（短时间和小编移率的边缘情况）：\n  - $a = 0.5$, $\\kappa = 0.02$, $\\beta = 0.3$, $\\phi_{\\mathrm{ref}} = 0.55$, $H = 1.0$, $N = 61$, $T = 0.1$, $M_{\\text{true}} = 0.5$。\n\n数值指导：\n- 在数据生成和校准运行中均使用 $\\Delta t = T/200$（因此有 $200$ 个均匀时间步）。\n- 使用在 $M \\in [10^{-3},\\,20]$ 上的有界、无导数的一维最小化器来最小化 $J(M)$，容差为 $10^{-8}$。\n- 所有量均为无量纲。\n\n您的程序必须：\n- 构造离散算子，使用 $M_{\\text{true}}$ 为每个测试生成合成数据，然后通过最小化 $J(M)$ 为每个测试估计最佳拟合迁移率 $\\hat{M}$。\n- 生成一行输出，其中包含三个校准后的迁移率，格式为逗号分隔的列表，并用方括号括起来，保留六位小数，例如 $[\\hat{M}_1,\\hat{M}_2,\\hat{M}_3]$。",
            "solution": "我们从 Hilbert 空间中的一般梯度流框架开始。对于一个在度量诱导耗散作用下演化以降低自由能 $\\mathcal{E}[\\phi]$ 的内变量 $\\phi$，在 Lebesgue 空间 $L^2$ 中具有恒定迁移率 $M \\gt 0$ 的最速下降动力学为\n$$\n\\partial_t \\phi \\;=\\; -M\\,\\frac{\\delta \\mathcal{E}}{\\delta \\phi}.\n$$\n在这里，自由能泛函为\n$$\n\\mathcal{E}[\\phi] \\;=\\; \\int_0^H \\left[\\frac{a}{2}(\\phi-\\phi_{\\mathrm{ref}})^2 + \\frac{\\kappa}{2}(\\partial_z \\phi)^2 + \\beta\\,z\\,\\phi \\right]\\,\\mathrm{d}z,\n$$\n其中 $a \\gt 0$、$\\kappa \\ge 0$、$\\phi_{\\mathrm{ref}} \\in (0,1)$ 和 $\\beta \\gt 0$。\n\n步骤 1（变分导数）：我们计算一阶变分。对于具有齐次 Neumann 边界条件的光滑变分 $\\eta$，令 $\\phi \\mapsto \\phi + \\varepsilon \\eta$，并计算\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}\\varepsilon}\\mathcal{E}[\\phi + \\varepsilon \\eta]\\Big|_{\\varepsilon=0}\n= \\int_0^H \\left[ a(\\phi-\\phi_{\\mathrm{ref}})\\,\\eta + \\kappa\\,\\partial_z \\phi\\,\\partial_z \\eta + \\beta z\\,\\eta \\right]\\mathrm{d}z.\n$$\n对中间项进行分部积分，并施加在 $z=0$ 和 $z=H$ 处的 $\\partial_z \\phi = 0$（齐次 Neumann 边界条件消除了边界项），我们得到\n$$\n\\int_0^H \\kappa\\,\\partial_z \\phi\\,\\partial_z \\eta \\,\\mathrm{d}z\n= -\\int_0^H \\kappa\\,\\partial_{zz}\\phi \\,\\eta \\,\\mathrm{d}z.\n$$\n因此，\n$$\n\\frac{\\delta \\mathcal{E}}{\\delta \\phi} \\;=\\; a(\\phi-\\phi_{\\mathrm{ref}}) - \\kappa\\,\\partial_{zz}\\phi + \\beta z.\n$$\n因此，在 $L^2$ 度量和恒定迁移率 $M$ 下的梯度流偏微分方程（PDE）为\n$$\n\\partial_t \\phi \\;=\\; -M\\left[a(\\phi-\\phi_{\\mathrm{ref}}) - \\kappa\\,\\partial_{zz}\\phi + \\beta z\\right]\n\\;=\\; -M a \\phi + M a \\phi_{\\mathrm{ref}} + M\\kappa\\,\\partial_{zz}\\phi - M\\beta z,\n$$\n该方程具有齐次 Neumann 边界条件 $\\partial_z \\phi(0,t) = \\partial_z \\phi(H,t) = 0$ 和初始条件 $\\phi(z,0) = \\phi_0(z)$。\n\n步骤 2（时空离散化）：我们用 $N$ 个节点 $z_i = i\\Delta z$，$i=0,\\dots,N-1$，$\\Delta z = H/(N-1)$ 来离散化 $[0,H]$。我们用对称三点格式来近似二阶导数。通过虚点反射施加齐次 Neumann 边界条件可得 $\\phi_{-1} = \\phi_1$（在 $i=0$ 处）和 $\\phi_{N} = \\phi_{N-2}$（在 $i=N-1$ 处）。在这些 Neumann 条件下，近似 $\\partial_{zz}$ 的离散拉普拉斯算子 $\\mathbf{L}\\in \\mathbb{R}^{N\\times N}$ 为\n$$\n\\mathbf{L} \\;=\\; \\frac{1}{\\Delta z^2}\\begin{bmatrix}\n-2 & 2 & 0 & \\cdots & 0 \\\\\n1 & -2 & 1 & \\ddots & \\vdots \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & \\ddots & 1 & -2 & 1 \\\\\n0 & \\cdots & 0 & 2 & -2\n\\end{bmatrix}.\n$$\n我们用时间步长为 $\\Delta t$ 的向后欧拉法对时间进行离散化，得到\n$$\n\\frac{\\boldsymbol{\\phi}^{n+1} - \\boldsymbol{\\phi}^{n}}{\\Delta t}\n= -M\\left(a\\,\\boldsymbol{\\phi}^{n+1} - \\kappa\\,\\mathbf{L}\\,\\boldsymbol{\\phi}^{n+1} - a\\,\\phi_{\\mathrm{ref}}\\,\\mathbf{1} + \\beta\\,\\mathbf{z}\\right),\n$$\n其中 $\\boldsymbol{\\phi}^n \\in \\mathbb{R}^N$ 是在时间 $t^n$ 的节点孔隙度向量，$\\mathbf{z} \\in \\mathbb{R}^N$ 包含节点深度，$\\mathbf{1}$ 是全一向量。整理得，\n$$\n\\left(\\mathbf{I} + \\Delta t\\,M\\,a\\,\\mathbf{I} - \\Delta t\\,M\\,\\kappa\\,\\mathbf{L}\\right)\\boldsymbol{\\phi}^{n+1}\n= \\boldsymbol{\\phi}^{n} + \\Delta t\\,M\\left(a\\,\\phi_{\\mathrm{ref}}\\,\\mathbf{1} - \\beta\\,\\mathbf{z}\\right).\n$$\n对于 $a \\gt 0$, $\\kappa \\ge 0$，左侧矩阵是对称正定的，因此每个时间步都存在唯一解。在初始条件 $\\boldsymbol{\\phi}^0 = \\phi_{\\mathrm{ref}}\\,\\mathbf{1}$ 和 $N_{\\text{steps}} = T/\\Delta t$ 个步长下，我们得到 $\\boldsymbol{\\phi}^{N_{\\text{steps}}}$ 作为模型预测。\n\n步骤 3（校准泛函与算法）：令 $\\boldsymbol{\\phi}_{\\text{data}}$ 表示使用已知的“真实”迁移率 $M_{\\text{true}}$ 从同一模型生成的合成数据。对于任意试验的 $M$，正演映射 $M \\mapsto \\boldsymbol{\\phi}_{\\text{model}}(T;M)$ 通过在每个向后欧拉步求解线性系统得到。我们在有界区间 $M \\in [10^{-3},\\,20]$ 上最小化\n$$\nJ(M) \\;=\\; \\frac{1}{N}\\,\\left\\|\\boldsymbol{\\phi}_{\\text{model}}(T;M) - \\boldsymbol{\\phi}_{\\text{data}}\\right\\|_2^2\n$$\n该结构在 $\\boldsymbol{\\phi}$ 中是线性的，并且在状态上是凸的；虽然 $J(M)$ 在解析上对 $M$ 不是全局凸的，但对于这种具有固定 $T$ 的线性、稳定的向后欧拉离散化，失配在实践中是光滑且单峰的，这使得稳健的无导数有界最小化成为可能（例如，Brent 法）。\n\n实现细节：\n- 根据 $(H,N)$ 一次性组装 $\\mathbf{L}$。\n- 在每个时间步，使用直接求解器求解 $\\boldsymbol{\\phi}^{n+1}$ 的线性系统；对于每个试验的 $M$，时间步矩阵会改变，因此为了效率，我们对每次试验进行一次因子分解。\n- 数据生成和校准均使用相同的 $\\Delta t = T/200$，以避免时间离散化不一致。\n- 对于每个测试，用 $M_{\\text{true}}$ 生成 $\\boldsymbol{\\phi}_{\\text{data}}$，然后在 $[10^{-3},\\,20]$ 上最小化 $J(M)$ 以获得 $\\hat{M}$。\n\n测试套件覆盖范围：\n- 测试 1 涵盖了 $\\kappa \\gt 0$ 和中等 $T$ 的一般反应扩散情况。\n- 测试 2 移除了梯度正则化（$\\kappa = 0$），简化为空间局部的刚性松弛加上载荷，考验了求解器处理纯反应算子的能力。\n- 测试 3 使用了小的 $T$ 和小的 $M_{\\text{true}}$，使得信号微弱，考验了灵敏度和数值精度。\n\n最终输出规格：\n- 打印一行包含一个 Python 风格的列表，其中有三个浮点数 $[\\hat{M}_1,\\hat{M}_2,\\hat{M}_3]$，每个 $\\hat{M}_k$ 都四舍五入到六位小数。\n- 所有量均为无量纲，因此不需要物理单位。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve\nfrom scipy.optimize import minimize_scalar\n\ndef neumann_laplacian_matrix(N: int, dz: float) -> np.ndarray:\n    \"\"\"\n    Construct the 1D second-derivative (Laplacian) matrix with homogeneous Neumann BCs\n    via ghost-point reflection on a uniform grid with spacing dz.\n    \"\"\"\n    L = np.zeros((N, N), dtype=float)\n    if N == 1:\n        return np.array([[0.0]])\n    # Interior points\n    for i in range(1, N - 1):\n        L[i, i - 1] = 1.0\n        L[i, i] = -2.0\n        L[i, i + 1] = 1.0\n    # Neumann BC at i=0: phi_{-1} = phi_{1} -> second derivative row: (2*phi1 - 2*phi0)/dz^2\n    L[0, 0] = -2.0\n    L[0, 1] = 2.0\n    # Neumann BC at i=N-1: phi_{N} = phi_{N-2} -> second derivative row: (2*phi_{N-2} - 2*phi_{N-1})/dz^2\n    L[N - 1, N - 2] = 2.0\n    L[N - 1, N - 1] = -2.0\n    L /= dz ** 2\n    return L\n\ndef integrate_backward_euler(a, kappa, beta, phi_ref, H, N, M, T, n_steps):\n    \"\"\"\n    Evolve the porosity field from phi0 = phi_ref (constant) to time T using backward Euler.\n    Returns (phi_T, z_grid).\n    \"\"\"\n    z = np.linspace(0.0, H, N)\n    dz = H / (N - 1) if N > 1 else 1.0\n    L = neumann_laplacian_matrix(N, dz)\n    I = np.eye(N)\n    dt = T / n_steps if n_steps > 0 else T\n    # Initial condition\n    phi = np.full(N, phi_ref, dtype=float)\n    # Assemble constant linear system matrix for this M\n    A = I + dt * M * a * I - dt * M * kappa * L\n    lu, piv = lu_factor(A)\n    # Constant RHS contribution at each step\n    c = M * a * phi_ref - M * beta * z  # vector\n    for _ in range(n_steps):\n        rhs = phi + dt * c\n        phi = lu_solve((lu, piv), rhs)\n    return phi, z\n\ndef generate_synthetic_data(a, kappa, beta, phi_ref, H, N, M_true, T, n_steps):\n    phi_T, z = integrate_backward_euler(a, kappa, beta, phi_ref, H, N, M_true, T, n_steps)\n    return phi_T, z\n\ndef calibrate_mobility(phi_data, a, kappa, beta, phi_ref, H, N, T, n_steps, bounds=(1e-3, 20.0)):\n    \"\"\"\n    Minimize the mean squared error between model solution at time T and given phi_data\n    to estimate M in the given bounds.\n    \"\"\"\n    # Precompute grid and operators that are independent of M inside objective by reusing integration routine.\n    def objective(M):\n        phi_model, _ = integrate_backward_euler(a, kappa, beta, phi_ref, H, N, M, T, n_steps)\n        residual = phi_model - phi_data\n        return float(np.mean(residual ** 2))\n\n    res = minimize_scalar(objective, bounds=bounds, method='bounded', options={'xatol': 1e-8, 'maxiter': 500})\n    return res.x\n\ndef solve():\n    # Define test cases as per the problem statement\n    test_cases = [\n        # Test 1: general case\n        {\n            'a': 1.0, 'kappa': 0.01, 'beta': 0.5, 'phi_ref': 0.6,\n            'H': 1.0, 'N': 101, 'T': 1.0, 'M_true': 2.0\n        },\n        # Test 2: kappa = 0\n        {\n            'a': 1.0, 'kappa': 0.0, 'beta': 1.0, 'phi_ref': 0.65,\n            'H': 1.0, 'N': 81, 'T': 0.25, 'M_true': 5.0\n        },\n        # Test 3: short time, small mobility\n        {\n            'a': 0.5, 'kappa': 0.02, 'beta': 0.3, 'phi_ref': 0.55,\n            'H': 1.0, 'N': 61, 'T': 0.1, 'M_true': 0.5\n        },\n    ]\n    # Use 200 steps for both data generation and calibration\n    n_steps = 200\n    results = []\n    for case in test_cases:\n        a = case['a']\n        kappa = case['kappa']\n        beta = case['beta']\n        phi_ref = case['phi_ref']\n        H = case['H']\n        N = case['N']\n        T = case['T']\n        M_true = case['M_true']\n        # Generate synthetic data\n        phi_data, _ = generate_synthetic_data(a, kappa, beta, phi_ref, H, N, M_true, T, n_steps)\n        # Calibrate M\n        M_est = calibrate_mobility(phi_data, a, kappa, beta, phi_ref, H, N, T, n_steps, bounds=(1e-3, 20.0))\n        results.append(M_est)\n    # Print results rounded to six decimal places in the required single-line format\n    print(\"[\" + \",\".join(f\"{r:.6f}\" for r in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}