{
    "hands_on_practices": [
        {
            "introduction": "The Gaussian function is ubiquitous in science and engineering, serving as a fundamental building block for wavelets, smoothing kernels, and probability distributions. This exercise provides foundational practice in analytical Fourier analysis by tasking you with deriving the two-dimensional Fourier transform of an anisotropic Gaussian. By working through this problem , you will gain a deeper understanding of how spatial characteristics, such as stretching or compression along different axes, are directly mapped into the wavenumber domain.",
            "id": "3598065",
            "problem": "In the spatial modeling of sedimentary basin heterogeneity, a common smoothing kernel is an anisotropic Gaussian defined on the plane by $f(x,y) = \\exp(-a x^{2} - b y^{2})$ with $a0$ and $b0$. Consider the continuous two-dimensional Fourier transform pair used in computational geophysics for spatial wavenumbers:\n$$F(k_{x},k_{y}) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} f(x,y) \\,\\exp\\!\\big(-\\mathrm{i}(k_{x} x + k_{y} y)\\big)\\,\\mathrm{d}x\\,\\mathrm{d}y,$$\nand its inverse\n$$f(x,y) = \\frac{1}{(2\\pi)^{2}} \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} F(k_{x},k_{y}) \\,\\exp\\!\\big(\\mathrm{i}(k_{x} x + k_{y} y)\\big)\\,\\mathrm{d}k_{x}\\,\\mathrm{d}k_{y}.$$\nStarting from these definitions, and assuming only the well-tested fact that Gaussian integrals converge for positive quadratic coefficients, do the following:\n1) Derive an exact closed-form expression for the two-dimensional Fourier transform $F(k_{x},k_{y})$ of $f(x,y)$.\n2) Write the resulting spectrum in the canonical Gaussian form $\\mathcal{A}\\,\\exp\\!\\big(-\\tfrac{1}{2}\\, \\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k}\\big)$, where $\\boldsymbol{k} = (k_{x},k_{y})^{\\top}$, identify the amplitude $\\mathcal{A}$, and determine the spectral covariance matrix $\\boldsymbol{\\Sigma}_{k}$ explicitly in terms of $a$ and $b$. Provide the two diagonal covariance elements corresponding to $k_{x}$ and $k_{y}$.\nExpress your final answer as a single composite object consisting of the transform $F(k_{x},k_{y})$ together with the two diagonal elements of the covariance matrix $\\boldsymbol{\\Sigma}_{k}$. No rounding is required. Do not include units in your final boxed answer.",
            "solution": "The user-provided problem is first subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\n- The function to be transformed is an anisotropic Gaussian kernel: $f(x,y) = \\exp(-a x^{2} - b y^{2})$.\n- The parameters $a$ and $b$ are positive real numbers: $a0$, $b0$.\n- The definition for the two-dimensional Fourier transform is provided as: $F(k_{x},k_{y}) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} f(x,y) \\,\\exp\\!\\big(-\\mathrm{i}(k_{x} x + k_{y} y)\\big)\\,\\mathrm{d}x\\,\\mathrm{d}y$.\n- The corresponding inverse transform is: $f(x,y) = \\frac{1}{(2\\pi)^{2}} \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} F(k_{x},k_{y}) \\,\\exp\\!\\big(\\mathrm{i}(k_{x} x + k_{y} y)\\big)\\,\\mathrm{d}k_{x}\\,\\mathrm{d}k_{y}$.\n- A stated assumption is the convergence of Gaussian integrals of the form $\\int \\exp(-cx^2)dx$ for $c0$.\n- Task 1: Derive the closed-form expression for $F(k_{x},k_{y})$.\n- Task 2: Express the result in the canonical Gaussian form $\\mathcal{A}\\,\\exp\\!\\big(-\\tfrac{1}{2}\\, \\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k}\\big)$ with $\\boldsymbol{k} = (k_{x},k_{y})^{\\top}$, identify the amplitude $\\mathcal{A}$, and determine the diagonal elements of the spectral covariance matrix $\\boldsymbol{\\Sigma}_{k}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed against the validation criteria.\n- **Scientifically Grounded**: The problem is based on the well-established mathematical theory of Fourier transforms and their application to Gaussian functions. These are fundamental tools in physics, engineering, and geophysics. The use of an anisotropic Gaussian as a smoothing kernel is a standard technique in spatial data analysis. The problem is scientifically sound.\n- **Well-Posed**: The function $f(x,y)$ is an element of $L^1(\\mathbb{R}^2)$ since $a0$ and $b0$, which guarantees the existence and uniqueness of its Fourier transform. The tasks are specified clearly and lead to a unique, stable, and meaningful solution.\n- **Objective**: The problem is stated in precise, objective mathematical language, free from any subjectivity or ambiguity.\n- **Complete and Consistent**: All necessary information is provided. The function, the transform definitions, and the constraints on the parameters are all explicitly stated. There are no contradictions.\n- **Other Flaws**: The problem does not exhibit any other flaws such as being unrealistic, ill-posed, trivial, or unverifiable. It is a standard, non-trivial exercise in Fourier analysis.\n\n### Step 3: Verdict and Action\nThe problem is determined to be **valid**. The solution process will now proceed.\n\n### Solution Derivation\n\nThe first task is to compute the two-dimensional Fourier transform of $f(x,y)$. We begin with the provided definition:\n$$F(k_{x},k_{y}) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} \\exp(-a x^{2} - b y^{2}) \\,\\exp(-\\mathrm{i}(k_{x} x + k_{y} y))\\,\\mathrm{d}x\\,\\mathrm{d}y$$\nThe integrand and the domain of integration are separable with respect to the variables $x$ and $y$. We can rewrite the double integral as a product of two independent one-dimensional integrals:\n$$F(k_{x},k_{y}) = \\left( \\int_{-\\infty}^{\\infty} \\exp(-a x^{2} - \\mathrm{i}k_{x} x) \\,\\mathrm{d}x \\right) \\left( \\int_{-\\infty}^{\\infty} \\exp(-b y^{2} - \\mathrm{i}k_{y} y) \\,\\mathrm{d}y \\right)$$\nLet's evaluate the first integral, which we denote $I_x$:\n$$I_x = \\int_{-\\infty}^{\\infty} \\exp(-a x^{2} - \\mathrm{i}k_{x} x) \\,\\mathrm{d}x$$\nTo solve this integral, we complete the square in the exponent:\n$$-a x^{2} - \\mathrm{i}k_{x} x = -a \\left( x^2 + \\frac{\\mathrm{i}k_{x}}{a}x \\right) = -a \\left( x^2 + 2x\\left(\\frac{\\mathrm{i}k_{x}}{2a}\\right) + \\left(\\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 - \\left(\\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 \\right)$$\n$$-a x^{2} - \\mathrm{i}k_{x} x = -a \\left( \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 - \\frac{\\mathrm{i}^2 k_x^2}{4a^2} \\right) = -a \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 - \\frac{k_x^2}{4a}$$\nSubstituting this back into the integral for $I_x$:\n$$I_x = \\int_{-\\infty}^{\\infty} \\exp\\left(-a \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 - \\frac{k_x^2}{4a}\\right) \\,\\mathrm{d}x = \\exp\\left(-\\frac{k_x^2}{4a}\\right) \\int_{-\\infty}^{\\infty} \\exp\\left(-a \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2\\right) \\,\\mathrm{d}x$$\nThe integral is a standard Gaussian integral. By a change of variables $u = x + \\frac{\\mathrm{i}k_{x}}{2a}$, the path of integration is shifted into the complex plane. However, due to the analytic properties of the integrand and its rapid decay at infinity, the value of the integral is unchanged. We use the well-known result $\\int_{-\\infty}^{\\infty} \\exp(-c z^2) \\,\\mathrm{d}z = \\sqrt{\\frac{\\pi}{c}}$ for $\\text{Re}(c)0$. In our case, $c=a  0$.\n$$\\int_{-\\infty}^{\\infty} \\exp\\left(-a \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2\\right) \\,\\mathrm{d}x = \\int_{-\\infty}^{\\infty} \\exp(-a u^2) \\,\\mathrm{d}u = \\sqrt{\\frac{\\pi}{a}}$$\nTherefore, the integral $I_x$ is:\n$$I_x = \\sqrt{\\frac{\\pi}{a}} \\exp\\left(-\\frac{k_x^2}{4a}\\right)$$\nBy direct analogy, the integral with respect to $y$, which we denote $I_y$, is found by replacing $x$ with $y$, $a$ with $b$, and $k_x$ with $k_y$:\n$$I_y = \\sqrt{\\frac{\\pi}{b}} \\exp\\left(-\\frac{k_y^2}{4b}\\right)$$\nThe full two-dimensional Fourier transform is the product $I_x I_y$:\n$$F(k_x, k_y) = I_x I_y = \\left(\\sqrt{\\frac{\\pi}{a}}\\right) \\left(\\sqrt{\\frac{\\pi}{b}}\\right) \\exp\\left(-\\frac{k_x^2}{4a}\\right) \\exp\\left(-\\frac{k_y^2}{4b}\\right)$$\n$$F(k_x, k_y) = \\frac{\\pi}{\\sqrt{ab}} \\exp\\left(-\\frac{k_x^2}{4a} - \\frac{k_y^2}{4b}\\right)$$\nThis is the closed-form expression for the Fourier transform, completing Task 1.\n\nFor Task 2, we must write this result in the canonical form $\\mathcal{A}\\,\\exp\\!\\big(-\\tfrac{1}{2}\\, \\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k}\\big)$ and identify the components.\nBy direct comparison with our derived expression, the amplitude $\\mathcal{A}$ is:\n$$\\mathcal{A} = \\frac{\\pi}{\\sqrt{ab}}$$\nThe argument of the exponential must be equal in both forms:\n$$-\\frac{k_x^2}{4a} - \\frac{k_y^2}{4b} = -\\frac{1}{2} \\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k}$$\nLet the inverse covariance matrix be $\\boldsymbol{\\Sigma}_{k}^{-1} = \\begin{pmatrix} C_{11}  C_{12} \\\\ C_{21}  C_{22} \\end{pmatrix}$. The quadratic form is:\n$$\\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k} = \\begin{pmatrix} k_x  k_y \\end{pmatrix} \\begin{pmatrix} C_{11}  C_{12} \\\\ C_{21}  C_{22} \\end{pmatrix} \\begin{pmatrix} k_x \\\\ k_y \\end{pmatrix} = C_{11}k_x^2 + (C_{12}+C_{21})k_x k_y + C_{22}k_y^2$$\nFrom the expression of the transform, we see that there is no cross-term $k_x k_y$, which implies that the off-diagonal elements of the inverse covariance matrix are zero: $C_{12} = C_{21} = 0$.\nWe can equate the coefficients of the quadratic terms:\n$$\\frac{k_x^2}{2a} + \\frac{k_y^2}{2b} = C_{11}k_x^2 + C_{22}k_y^2$$\nThis gives $C_{11} = \\frac{1}{2a}$ and $C_{22} = \\frac{1}{2b}$.\nSo, the inverse spectral covariance matrix is:\n$$\\boldsymbol{\\Sigma}_{k}^{-1} = \\begin{pmatrix} \\frac{1}{2a}  0 \\\\ 0  \\frac{1}{2b} \\end{pmatrix}$$\nThe spectral covariance matrix $\\boldsymbol{\\Sigma}_{k}$ is the inverse of $\\boldsymbol{\\Sigma}_{k}^{-1}$. For a diagonal matrix, this is simply the matrix of the reciprocals of the diagonal elements:\n$$\\boldsymbol{\\Sigma}_{k} = (\\boldsymbol{\\Sigma}_{k}^{-1})^{-1} = \\begin{pmatrix} 2a  0 \\\\ 0  2b \\end{pmatrix}$$\nThe problem asks for the two diagonal covariance elements corresponding to $k_x$ and $k_y$. These are the diagonal entries of $\\boldsymbol{\\Sigma}_{k}$. Let's denote them $(\\boldsymbol{\\Sigma}_{k})_{11}$ and $(\\boldsymbol{\\Sigma}_{k})_{22}$.\n$$(\\boldsymbol{\\Sigma}_{k})_{11} = 2a$$\n$$(\\boldsymbol{\\Sigma}_{k})_{22} = 2b$$\nThese represent the variances of the spectral distribution in the $k_x$ and $k_y$ directions, respectively.\n\nThe final composite answer consists of the transform $F(k_{x},k_{y})$ and the two diagonal elements of $\\boldsymbol{\\Sigma}_{k}$.\nThe transform is $F(k_{x},k_{y}) = \\frac{\\pi}{\\sqrt{ab}} \\exp\\left(-\\frac{k_x^2}{4a} - \\frac{k_y^2}{4b}\\right)$.\nThe diagonal elements are $2a$ and $2b$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\pi}{\\sqrt{ab}} \\exp\\left(-\\frac{k_x^{2}}{4a} - \\frac{k_y^{2}}{4b}\\right)  2a  2b\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "In computational geophysics, we almost always deal with real-valued data, such as seismic traces or potential field measurements. This reality imparts a crucial structure onto the data's Fourier spectrum known as Hermitian symmetry. This practice  guides you through deriving this property and then implementing a computational verification, demonstrating how it allows for significant reductions in memory and computation time when using algorithms like the Fast Fourier Transform (FFT).",
            "id": "3598122",
            "problem": "Consider discrete seismic traces as finite-length sampled signals. Let a real-valued time-domain trace be denoted by $x[n]$ for integer sample index $n \\in \\{0,1,\\dots,N-1\\}$ with sampling interval $\\Delta t$ expressed in seconds. Let the Discrete Fourier Transform (DFT) be defined by $$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\!\\left(-\\mathrm{i}\\,\\frac{2\\pi}{N}\\,kn\\right), \\quad k \\in \\{0,1,\\dots,N-1\\},$$ where $\\mathrm{i}$ denotes the imaginary unit. Let the continuous-time Fourier transform be defined by $$X(\\omega) = \\int_{-\\infty}^{\\infty} x(t)\\,\\exp\\!\\left(-\\mathrm{i}\\,\\omega\\,t\\right)\\,\\mathrm{d}t,$$ where $\\omega$ is the angular frequency expressed in radians per second. For practical computation, the DFT approximates the continuous transform under standard sampling assumptions.\n\nTask: Using only the core definitions above and standard properties of complex conjugation, derive how the spectrum of a real-valued seismic trace is structurally related across positive and negative frequencies, both in the continuous-time Fourier transform and in the DFT. Explain how one can exploit this structural relationship to compute only a subset of frequency bins and reconstruct the complete spectrum, and justify under what conditions this reduces computational cost (for example on Graphics Processing Unit (GPU) implementations of the Fast Fourier Transform (FFT), where reduced arithmetic translates to speed gains). Then, implement an algorithm that:\n- Computes the full DFT $X[k]$ of input traces.\n- Computes a one-sided spectrum from the real-valued trace and reconstructs the full spectrum via the derived structural relationship.\n- Quantifies equality between the direct full spectrum and the reconstruction for real-valued traces using a norm-based tolerance.\n- Quantifies the failure of the same reconstruction approach for complex-valued traces.\n\nAngle unit specification: Whenever an angular frequency $\\omega$ is used, the unit must be radians per second. Time sampling $\\Delta t$ must be specified in seconds. No other physical units are required in the final outputs because the outputs are dimensionless booleans and floats.\n\nAlgorithmic requirements:\n- Use the Discrete Fourier Transform as defined above and rely on the Fast Fourier Transform for numerical computation.\n- Implement a reconstruction function that builds the full-length complex spectrum $X[k]$ from a one-sided sequence of bins corresponding to nonnegative frequencies, using only the structural relationship that holds for real-valued input signals.\n- Use a relative $\\ell_2$ error metric $$\\varepsilon = \\frac{\\lVert X_{\\text{recon}} - X_{\\text{full}} \\rVert_2}{\\lVert X_{\\text{full}} \\rVert_2}$$ to quantify spectral reconstruction accuracy.\n- Use absolute tolerances expressed as dimensionless numbers for equality checks.\n\nTest suite specification:\nProvide the following four test cases with exact parameters, and produce outputs in the order listed. In each case, any frequencies referenced are angular frequencies in radians per second only if the continuous transform is invoked; otherwise, operate with DFT indices.\n\n1. Real, even-length trace (general case):\n   - Length $N = 2048$.\n   - Sampling interval $\\Delta t = 0.004$ seconds.\n   - Real seismic wavelet $x[n]$ defined by a bandlimited Ricker wavelet centered at $t=0$ with peak frequency $f_0 = 25$ Hz, sampled on the grid $t_n = (n - N/2)\\,\\Delta t$ for $n \\in \\{0,\\dots,N-1\\}$, and zero-padded by virtue of finite support.\n   - Output a boolean indicating whether the full DFT computed directly equals the reconstruction from the one-sided spectrum within a tolerance of $10^{-10}$ in the relative $\\ell_2$ sense.\n\n2. Real, odd-length trace (length parity edge case):\n   - Length $N = 1999$.\n   - Sampling interval $\\Delta t = 0.002$ seconds.\n   - Real seismic wavelet $x[n]$ defined by a bandlimited Ricker wavelet centered at $t=0$ with peak frequency $f_0 = 30$ Hz, sampled on the grid $t_n = (n - N/2)\\,\\Delta t$.\n   - Output a boolean indicating equality of direct full DFT and reconstruction from one-sided spectrum within a tolerance of $10^{-10}$ in the relative $\\ell_2$ sense.\n\n3. Real, even-length trace with discrete-time direct current (DC) and Nyquist components (boundary bins):\n   - Length $N = 1024$.\n   - Sampling interval $\\Delta t = 1.0$ seconds.\n   - Real signal $x[n] = A_{\\text{DC}} + A_{\\text{NYQ}}\\cdot(-1)^n$, with $A_{\\text{DC}} = 1.2$ and $A_{\\text{NYQ}} = 0.7$.\n   - Output a boolean indicating whether the imaginary parts of $X[0]$ (DC bin) and $X[N/2]$ (Nyquist bin) are both less than $10^{-12}$ in absolute value.\n\n4. Complex-valued analytic signal (failure case for the real-signal structural reconstruction):\n   - Use the real trace from Test 1 and form its complex analytic signal $z[n] = x[n] + \\mathrm{i}\\,\\hat{x}[n]$, where $\\hat{x}[n]$ is the Hilbert transform of $x[n]$.\n   - Compute the full DFT $Z[k]$ of $z[n]$ and attempt to reconstruct it from the one-sided part using the same structural relationship that holds for real signals.\n   - Output a float equal to the relative $\\ell_2$ error $\\varepsilon$ as defined above.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order corresponding to the test cases $1$ through $4$. The first three entries must be booleans, and the fourth entry must be a float. For example, the structure must be exactly of the form $$[\\text{boolean}_1,\\text{boolean}_2,\\text{boolean}_3,\\text{float}_4].$$ No additional text or units should appear in the output.",
            "solution": "The problem asks for a derivation of the conjugate symmetry property of the Fourier transform for real-valued signals, an explanation of its use in efficient computation, and a numerical implementation to verify this property and demonstrate its failure for complex-valued signals.\n\n### 1. Fourier Transform Conjugate Symmetry for Real-Valued Signals\n\nA fundamental property of the Fourier transform is that a real-valued signal in one domain (e.g., time) corresponds to a spectrum with Hermitian symmetry in the other domain (frequency). This property is known as conjugate symmetry. We will derive this for both the continuous-time and discrete-time cases.\n\n#### A. Continuous-Time Fourier Transform (CTFT)\n\nLet $x(t)$ be a real-valued and integrable function of time $t$. Its continuous-time Fourier transform $X(\\omega)$ is defined as:\n$$X(\\omega) = \\int_{-\\infty}^{\\infty} x(t)\\,\\exp\\!\\left(-\\mathrm{i}\\,\\omega\\,t\\right)\\,\\mathrm{d}t$$\nwhere $\\omega$ is the angular frequency in radians per second and $\\mathrm{i}$ is the imaginary unit.\n\nTo find the relationship between spectral components at positive and negative frequencies, we examine the complex conjugate of $X(\\omega)$, denoted $X^*(\\omega)$:\n$$X^*(\\omega) = \\left( \\int_{-\\infty}^{\\infty} x(t)\\,\\exp\\!\\left(-\\mathrm{i}\\,\\omega\\,t\\right)\\,\\mathrm{d}t \\right)^*$$\nThe conjugate of an integral is the integral of the conjugate of the integrand:\n$$X^*(\\omega) = \\int_{-\\infty}^{\\infty} \\left(x(t)\\,\\exp\\!\\left(-\\mathrm{i}\\,\\omega\\,t\\right)\\right)^* \\,\\mathrm{d}t$$\nUsing the property $(ab)^* = a^*b^*$, we have:\n$$X^*(\\omega) = \\int_{-\\infty}^{\\infty} x^*(t)\\,\\left(\\exp\\!\\left(-\\mathrm{i}\\,\\omega\\,t\\right)\\right)^* \\,\\mathrm{d}t$$\nSince the signal $x(t)$ is real-valued, its complex conjugate is itself: $x^*(t) = x(t)$. The conjugate of the complex exponential is $\\left(\\exp(-\\mathrm{i}\\theta)\\right)^* = \\exp(\\mathrm{i}\\theta)$. Applying these gives:\n$$X^*(\\omega) = \\int_{-\\infty}^{\\infty} x(t)\\,\\exp\\!\\left(\\mathrm{i}\\,\\omega\\,t\\right)\\,\\mathrm{d}t$$\nWe can rewrite the term $\\exp(\\mathrm{i}\\omega t)$ as $\\exp(-\\mathrm{i}(-\\omega)t)$:\n$$X^*(\\omega) = \\int_{-\\infty}^{\\infty} x(t)\\,\\exp\\!\\left(-\\mathrm{i}\\,(-\\omega)\\,t\\right)\\,\\mathrm{d}t$$\nThis expression is, by definition, the Fourier transform of $x(t)$ evaluated at frequency $-\\omega$, which is $X(-\\omega)$. Therefore, we have established the Hermitian or conjugate symmetry property for the CTFT of a real signal:\n$$X(-\\omega) = X^*(\\omega)$$\nThis implies that the real part of the spectrum, $\\text{Re}\\{X(\\omega)\\}$, is an even function of $\\omega$, and the imaginary part, $\\text{Im}\\{X(\\omega)\\}$, is an odd function of $\\omega$.\n\n#### B. Discrete Fourier Transform (DFT)\n\nNow, consider a discrete, real-valued signal $x[n]$ of finite length $N$, where $n \\in \\{0, 1, \\dots, N-1\\}$. Its Discrete Fourier Transform $X[k]$ is defined as:\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\!\\left(-\\mathrm{i}\\,\\frac{2\\pi}{N}\\,kn\\right), \\quad k \\in \\{0, 1, \\dots, N-1\\}$$\nFollowing a similar procedure, we take the complex conjugate of $X[k]$:\n$$X^*[k] = \\left( \\sum_{n=0}^{N-1} x[n] \\exp\\!\\left(-\\mathrm{i}\\,\\frac{2\\pi}{N}\\,kn\\right) \\right)^* = \\sum_{n=0}^{N-1} x^*[n] \\left(\\exp\\!\\left(-\\mathrm{i}\\,\\frac{2\\pi}{N}\\,kn\\right)\\right)^*$$\nAs $x[n]$ is real, $x^*[n] = x[n]$. This simplifies to:\n$$X^*[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\!\\left(\\mathrm{i}\\,\\frac{2\\pi}{N}\\,kn\\right)$$\nWe use the periodicity of the complex exponential, $\\exp(\\mathrm{i}\\theta) = \\exp(\\mathrm{i}(\\theta - 2\\pi m))$ for any integer $m$. We can write $\\exp\\left(\\mathrm{i}\\frac{2\\pi}{N}kn\\right)$ as $\\exp\\left(\\mathrm{i}\\frac{2\\pi}{N}kn - \\mathrm{i}2\\pi n\\right) = \\exp\\left(-\\mathrm{i}\\frac{2\\pi}{N}(N-k)n\\right)$. Substituting this into the expression for $X^*[k]$ yields:\n$$X^*[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\!\\left(-\\mathrm{i}\\,\\frac{2\\pi}{N}(N-k)n\\right)$$\nThis sum is the definition of the DFT evaluated at index $N-k$, i.e., $X[N-k]$. Thus, for the DFT of a real sequence, we have the symmetry property:\n$$X[N-k] = X^*[k], \\quad k \\in \\{1, 2, \\dots, N-1\\}$$\nThe frequency corresponding to index $k$ can be interpreted as the positive frequency $\\omega_k = \\frac{2\\pi k}{N\\Delta t}$, while the index $N-k$ corresponds to the aliased negative frequency $-\\omega_k$.\n\n### 2. Spectral Reconstruction and Computational Efficiency\n\nThe conjugate symmetry property implies that the spectral coefficients of a real signal are not all independent. This redundancy can be exploited to reduce computational cost.\n\nThe DFT bins are indexed from $k=0$ to $N-1$.\n-   **$k=0$ (DC component):** For $k=0$, the symmetry gives $X[0] = X^*[0]$, which means $X[0]$ must be a real number. This is expected, as $X[0] = \\sum_{n=0}^{N-1} x[n]$, the sum of real numbers.\n-   **Positive Frequencies:** The bins for $k \\in \\{1, \\dots, \\lfloor(N-1)/2\\rfloor\\}$ are independent complex numbers.\n-   **Nyquist Frequency (for even $N$ only):** For even $N$, the index $k=N/2$ is its own conjugate pair since $N - (N/2) = N/2$. The symmetry $X[N/2] = X^*[N/2]$ implies that $X[N/2]$ must also be a real number. Indeed, $X[N/2] = \\sum_{n=0}^{N-1} x[n](-1)^n$ is real.\n-   **Negative Frequencies:** The bins for $k > N/2$ are determined by the positive frequency bins via $X[N-k] = X^*[k]$.\n\nTherefore, to define the complete spectrum, one only needs to compute the bins for non-negative frequencies.\n-   If $N$ is even, we need to compute bins $k=0, 1, \\dots, N/2$. This amounts to $N/2 + 1$ unique spectral values (two real, the rest complex).\n-   If $N$ is odd, we need to compute bins $k=0, 1, \\dots, (N-1)/2$. This amounts to $(N+1)/2$ unique spectral values (one real, the rest complex).\n\n**Reconstruction Algorithm:** Given the one-sided spectrum (bins for non-negative frequencies), the full spectrum can be reconstructed. For example, for an even $N$:\n1. Let the one-sided spectrum be $Y[k]$ for $k=0, \\dots, N/2$.\n2. The full spectrum $X[k]$ is constructed as follows:\n   - $X[k] = Y[k]$ for $k=0, \\dots, N/2$.\n   - $X[k] = Y^*[N-k]$ for $k=N/2+1, \\dots, N-1$.\n\n**Computational Savings:** Standard Fast Fourier Transform (FFT) algorithms for complex inputs have a complexity of roughly $O(N \\log N)$. Specialized algorithms for real-valued inputs (often called `RFFT`) are designed to compute only the non-redundant half of the spectrum. This reduces the number of arithmetic operations by approximately a factor of two (from $\\approx 5N\\log_2 N$ floating-point operations for a complex FFT to $\\approx 2.5N\\log_2 N$ for a real FFT). This reduction in computation, along with decreased memory traffic, yields significant performance gains, especially in hardware-accelerated environments like GPUs.\n\n### 3. Failure for Complex Signals\n\nThe conjugate symmetry property is contingent on the input signal being purely real. If the signal $z[n]$ is complex, then $z^*[n] \\neq z[n]$, and the derivation above fails. In general, for a complex signal, $Z[N-k] \\neq Z^*[k]$, and there is no inherent symmetry between positive and negative frequency components.\n\nA prominent example in geophysics and signal processing is the **analytic signal**, $z[n] = x[n] + \\mathrm{i}\\hat{x}[n]$, where $x[n]$ is a real signal and $\\hat{x}[n]$ is its Hilbert transform. By construction, the DFT of an analytic signal, $Z[k]$, has nearly all its energy at non-negative frequencies ($k \\le N/2$) and is approximately zero for negative frequencies ($k  N/2$). Attempting to reconstruct its spectrum using the real-signal symmetry rule would erroneously create a mirror image of the positive-frequency spectrum in the negative-frequency range, leading to a large discrepancy.\n\n### 4. Algorithmic Implementation\n\nAn algorithm is implemented to conduct four tests. The core of the implementation involves:\n1.  Generating test signals: Ricker wavelets for Cases 1 and 2, a DC+Nyquist signal for Case 3, and an analytic signal for Case 4.\n2.  A function `reconstruct_from_one_sided` that takes the first half of a DFT and reconstructs the full DFT using the conjugate symmetry property.\n3.  A relative $\\ell_2$ error metric, $\\varepsilon = \\lVert X_{\\text{recon}} - X_{\\text{full}} \\rVert_2 / \\lVert X_{\\text{full}} \\rVert_2$, to quantify the accuracy of the reconstruction.\n\nThe validation involves comparing the directly computed full DFT with the one reconstructed from its non-negative frequency components. The results confirm that for real signals (Cases 1, 2, 3), the reconstruction is accurate to within machine precision, while for a complex analytic signal (Case 4), the reconstruction fails, yielding a large error.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import hilbert\n\ndef create_ricker_wavelet(N: int, dt: float, f0: float) - np.ndarray:\n    \"\"\"\n    Generates a Ricker wavelet.\n\n    Args:\n        N (int): The number of samples.\n        dt (float): The sampling interval in seconds.\n        f0 (float): The peak frequency in Hz.\n\n    Returns:\n        np.ndarray: The sampled Ricker wavelet.\n    \"\"\"\n    # The problem statement defines the time grid as t_n = (n - N/2) * dt\n    # This is a direct implementation of the given formula.\n    t = (np.arange(N) - N / 2) * dt\n    pi_f0_t_sq = (np.pi * f0 * t) ** 2\n    return (1.0 - 2.0 * pi_f0_t_sq) * np.exp(-pi_f0_t_sq)\n\ndef reconstruct_from_one_sided(one_sided_spectrum: np.ndarray, N: int) - np.ndarray:\n    \"\"\"\n    Reconstructs the full DFT spectrum from its one-sided version,\n    assuming the original time-domain signal was real.\n    \n    Args:\n        one_sided_spectrum (np.ndarray): The DFT bins for non-negative frequencies.\n        N (int): The full length of the original signal.\n\n    Returns:\n        np.ndarray: The reconstructed full complex spectrum.\n    \"\"\"\n    full_spectrum = np.zeros(N, dtype=np.complex128)\n    \n    # Number of points in the one-sided spectrum\n    num_one_sided = len(one_sided_spectrum)\n    \n    # Copy the non-negative frequency components\n    full_spectrum[0:num_one_sided] = one_sided_spectrum\n    \n    # Reconstruct the negative frequency components using conjugate symmetry\n    # X[N-k] = conj(X[k])\n    # The range of k to conjugate depends on whether N is even or odd.\n    # The Nyquist bin (if it exists) is its own conjugate and is real, so it's excluded from the loop.\n    # The DC bin (k=0) is also real and excluded.\n    \n    # The highest index in the conjugate part is N-1, corresponding to k=1.\n    # The start_k_conj is the first index in the negative frequency part of the full spectrum array.\n    start_k_conj = num_one_sided\n    # Loop backwards from index N-1 down to start_k_conj\n    for k_full in range(N - 1, start_k_conj - 1, -1):\n        k_one_sided = N - k_full\n        full_spectrum[k_full] = np.conj(one_sided_spectrum[k_one_sided])\n        \n    return full_spectrum\n\ndef calculate_relative_l2_error(recon: np.ndarray, full: np.ndarray) - float:\n    \"\"\"\n    Calculates the relative L2 error between two vectors.\n    \n    Args:\n        recon (np.ndarray): The reconstructed vector.\n        full (np.ndarray): The reference (full) vector.\n        \n    Returns:\n        float: The relative L2 error.\n    \"\"\"\n    norm_diff = np.linalg.norm(recon - full)\n    norm_full = np.linalg.norm(full)\n    if norm_full == 0:\n        return 0.0 if norm_diff == 0.0 else np.inf\n    return norm_diff / norm_full\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    results = []\n\n    # --- Test Case 1: Real, even-length trace ---\n    N1 = 2048\n    dt1 = 0.004\n    f01 = 25.0\n    tol1 = 1e-10\n    \n    x1 = create_ricker_wavelet(N1, dt1, f01)\n    X1_full = np.fft.fft(x1)\n    X1_one_sided = X1_full[0 : N1 // 2 + 1]\n    X1_recon = reconstruct_from_one_sided(X1_one_sided, N1)\n    error1 = calculate_relative_l2_error(X1_recon, X1_full)\n    results.append(error1  tol1)\n\n    # --- Test Case 2: Real, odd-length trace ---\n    N2 = 1999\n    dt2 = 0.002\n    f02 = 30.0\n    tol2 = 1e-10\n\n    x2 = create_ricker_wavelet(N2, dt2, f02)\n    X2_full = np.fft.fft(x2)\n    X2_one_sided = X2_full[0 : (N2 + 1) // 2]\n    X2_recon = reconstruct_from_one_sided(X2_one_sided, N2)\n    error2 = calculate_relative_l2_error(X2_recon, X2_full)\n    results.append(error2  tol2)\n\n    # --- Test Case 3: Real, even-length trace with DC and Nyquist components ---\n    N3 = 1024\n    # dt3 is not needed for signal definition but given as 1.0\n    A_DC = 1.2\n    A_NYQ = 0.7\n    tol3 = 1e-12\n\n    n3 = np.arange(N3)\n    x3 = A_DC + A_NYQ * (-1)**n3\n    X3_full = np.fft.fft(x3)\n    \n    # Check if imaginary parts of DC and Nyquist bins are near zero\n    is_dc_real = abs(X3_full[0].imag)  tol3\n    is_nyquist_real = abs(X3_full[N3 // 2].imag)  tol3\n    results.append(is_dc_real and is_nyquist_real)\n\n    # --- Test Case 4: Complex-valued analytic signal (failure case) ---\n    # Use real trace from Test 1\n    # hilbert() returns the analytic signal x + i*H(x)\n    z4 = hilbert(x1)\n    Z4_full = np.fft.fft(z4)\n\n    # Attempt reconstruction using the real-signal symmetry rule\n    Z4_one_sided = Z4_full[0 : N1 // 2 + 1]\n    Z4_recon = reconstruct_from_one_sided(Z4_one_sided, N1)\n    \n    error4 = calculate_relative_l2_error(Z4_recon, Z4_full)\n    results.append(float(error4))\n\n    # --- Final Output ---\n    # Convert booleans to lowercase 'true'/'false' as per standard JSON-like formats.\n    # This was intended but missed in the original code.\n    formatted_results = [str(r).lower() if isinstance(r, bool) else str(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Perhaps the most powerful application of the Fourier transform in signal processing is the convolution theorem, which elegantly converts a computationally demanding convolution in the time domain into a simple multiplication in the frequency domain. This hands-on problem  applies this theorem to a classic geophysical task: modeling seismic multiples. You will implement both time-domain and frequency-domain approaches, allowing you to verify the theorem numerically and explore the practicalities of round-off error and computational precision.",
            "id": "3598100",
            "problem": "A zero-offset one-dimensional multiple-modeling step in seismic processing can be cast as linear time-invariant operations on bandlimited signals. Let $r(t)$ denote a reflectivity series, $s(t)$ a deterministic bandlimited source signature, and $(\\cdot \\star \\cdot)$ the continuous-time convolution. The modeled multiples trace is defined as the linear convolution of $r(t)$ with the auto-convolution of $s(t)$, and all angular frequencies and angles must be interpreted in radians, with time in seconds. Starting only from the core definitions of the Fourier transform and the convolution integral, and from the discrete Fourier transform, complete the following tasks.\n\nBase definitions to use:\n- Continuous-time Fourier transform: for any absolutely integrable $x(t)$,\n$$\\mathcal{F}\\{x\\}(\\omega) = \\int_{-\\infty}^{\\infty} x(t)\\, e^{-i \\omega t}\\, dt,$$\nand its inverse\n$$\\mathcal{F}^{-1}\\{X\\}(t) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} X(\\omega)\\, e^{i \\omega t}\\, d\\omega.$$\n- Continuous-time convolution: for any integrable $f(t), g(t)$,\n$$(f \\star g)(t) = \\int_{-\\infty}^{\\infty} f(\\tau)\\, g(t - \\tau)\\, d\\tau.$$\n- Discrete Fourier transform: for a finite-length sequence $\\{x[n]\\}_{n=0}^{N-1}$,\n$$X[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn/N},\\quad k=0,\\dots,N-1,$$\nwith inverse\n$$x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\, e^{i 2\\pi kn/N},\\quad n=0,\\dots,N-1.$$\n\nTask A (derivation):\n- Starting from the above definitions and no other formulas, derive the frequency-domain representation of the multiples modeled by convolving $r(t)$ with the auto-convolution of $s(t)$. Your derivation must logically establish the algebraic relationship between the Fourier transforms of the inputs and the Fourier transform of the output, using only the stated definitions.\n\nTask B (algorithm design):\n- In discrete time with sampling interval $\\Delta t$ in seconds, consider finite-length sequences $r[n] \\approx r(n \\Delta t)$ and $s[n] \\approx s(n \\Delta t)$. Let $c[n]$ be the linear convolution of $s[n]$ with itself. Let $y_{\\mathrm{time}}[n]$ be the linear convolution of $r[n]$ with $c[n]$. Independently, construct $y_{\\mathrm{freq}}[n]$ by using the discrete Fourier transform definitions and appropriate zero-padding so that circular convolution exactly reproduces the linear convolution. In both pathways, produce the linear-convolution result of the same length $L$, where $L = \\mathrm{len}(r) + \\mathrm{len}(c) - 1$.\n\nTask C (numerical stability and roundoff assessment):\n- For each test case below, compute:\n  - The maximum absolute difference $\\max_n |y_{\\mathrm{time}}[n] - y_{\\mathrm{freq}}[n]|$ (dimensionless).\n  - The relative $\\ell_2$ error $\\|y_{\\mathrm{time}} - y_{\\mathrm{freq}}\\|_2 / \\|y_{\\mathrm{time}}\\|_2$ (dimensionless), with the convention that if $\\|y_{\\mathrm{time}}\\|_2 = 0$ then the relative error is $0$.\n  - The base-$10$ logarithm of the spectral dynamic range of the source spectrum squared, computed as follows. Let $S[k]$ be the discrete Fourier transform of $s[n]$ on the same transform length used in the frequency-domain pathway, and let $P[k] = |S[k]|^2$. Define $P_{\\max} = \\max_k P[k]$ and $P_{\\min} = \\min\\{P[k] : P[k] \\geq P_{\\max}\\,\\varepsilon\\}$ where $\\varepsilon$ is the machine epsilon for double-precision floating point. Report $\\log_{10}\\left(P_{\\max}/P_{\\min}\\right)$ (dimensionless).\n  - A boolean that is true if and only if the relative $\\ell_2$ error is less than or equal to the tolerance $\\tau = 10^{-10}$.\n- All computations must be performed in double-precision. Use the same discrete Fourier transform length in the frequency-domain pathway and in the spectral dynamic range calculation. Time is in seconds, and all angles are in radians.\n\nTest suite (all time quantities in seconds):\n- Case $1$ (general): $\\Delta t = 0.001$, $r[n]$ of length $2048$ as a sparse spike train with spike probability $0.01$ and spike amplitudes uniformly distributed in $[-0.8, 0.8]$ (use a fixed pseudorandom generator seed), $s[n]$ a zero-phase Ricker wavelet of length $251$ with peak frequency $f_0 = 25$ in hertz.\n- Case $2$ (boundary, trivial): $\\Delta t = 0.002$, $r[n] = [1.0]$, $s[n] = [1.0]$.\n- Case $3$ (large dynamic range, scaled): $\\Delta t = 0.001$, $r[n]$ of length $512$ with independent Gaussian samples of zero mean and standard deviation $10^{-3}$ (use a fixed pseudorandom generator seed), $s[n]$ a zero-phase Gaussian wavelet $s(t) = A \\exp\\left(-\\frac{t^2}{2\\sigma^2}\\right)$ of length $401$ with $A = 10^3$ and $\\sigma = 0.004$.\n- Case $4$ (non power-of-two, shifted phase): $\\Delta t = 0.0015$, $r[n]$ of length $401$ with independent samples uniformly distributed in $[-0.5, 0.5]$ (use a fixed pseudorandom generator seed), $s[n]$ a Hann-tapered sinusoid of length $73$ defined by $s[n] = w[n]\\sin(2\\pi f_c n \\Delta t)$ with $f_c = 60$ in hertz and $w[n] = \\tfrac{1}{2}\\left(1 - \\cos\\left(\\tfrac{2\\pi n}{N-1}\\right)\\right)$, where $N$ is the length of $s[n]$.\n\nImplementation requirements:\n- Use linear convolution in the time-domain pathway.\n- In the frequency-domain pathway, choose a discrete Fourier transform length $N_{\\mathrm{fft}}$ that is exactly the required linear convolution length $L$ to avoid circular aliasing and to make the comparison meaningful.\n- Treat negligible imaginary parts in the inverse discrete Fourier transform output by discarding them via the real part.\n\nFinal output format:\n- Your program must produce a single line containing a top-level list of four per-case results in the order of the test suite. Each per-case result must be a list of four entries in the following order: the maximum absolute difference (float), the relative $\\ell_2$ error (float), the base-$10$ spectral dynamic range (float), and the pass boolean. For example, the output must have the form\n$[\\,[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]\\,]$\nwith no additional text.",
            "solution": "The problem statement has been validated and is determined to be a well-posed, scientifically grounded problem in the domain of signal processing and computational geophysics. All provided definitions, parameters, and tasks are clear, consistent, and sufficient for deriving a unique and verifiable solution.\n\n### Task A: Derivation of the Frequency-Domain Representation\n\nThe objective is to find the Fourier transform of the multiples modeled trace, $y(t)$, defined by the continuous-time convolution $y(t) = r(t) \\star (s(t) \\star s(t))$. We are required to start exclusively from the provided definitions of the Fourier transform and convolution.\n\nLet $f(t)$ and $g(t)$ be two absolutely integrable functions. Their convolution is given by:\n$$ (f \\star g)(t) = \\int_{-\\infty}^{\\infty} f(\\tau)\\, g(t - \\tau)\\, d\\tau $$\nThe Fourier transform of their convolution is, by definition:\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = \\int_{-\\infty}^{\\infty} (f \\star g)(t)\\, e^{-i \\omega t}\\, dt $$\nSubstituting the definition of convolution into the Fourier transform integral:\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = \\int_{t=-\\infty}^{\\infty} \\left( \\int_{\\tau=-\\infty}^{\\infty} f(\\tau)\\, g(t - \\tau)\\, d\\tau \\right) e^{-i \\omega t}\\, dt $$\nAssuming the functions are well-behaved such that the order of integration can be interchanged (which is true for functions in $L^1(\\mathbb{R})$, as per Fubini's theorem), we get:\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = \\int_{\\tau=-\\infty}^{\\infty} f(\\tau) \\left( \\int_{t=-\\infty}^{\\infty} g(t - \\tau)\\, e^{-i \\omega t}\\, dt \\right) d\\tau $$\nLet's focus on the inner integral. We perform a change of variables, letting $u = t - \\tau$. This implies $t = u + \\tau$ and $dt = du$. The limits of integration remain unchanged.\n$$ \\int_{t=-\\infty}^{\\infty} g(t - \\tau)\\, e^{-i \\omega t}\\, dt = \\int_{u=-\\infty}^{\\infty} g(u)\\, e^{-i \\omega (u + \\tau)}\\, du $$\nUsing the property of exponentials $e^{a+b} = e^a e^b$, we can separate the terms:\n$$ \\int_{u=-\\infty}^{\\infty} g(u)\\, e^{-i \\omega u} e^{-i \\omega \\tau}\\, du = e^{-i \\omega \\tau} \\int_{u=-\\infty}^{\\infty} g(u)\\, e^{-i \\omega u}\\, du $$\nThe integral on the right is, by definition, the Fourier transform of $g(u)$, which we denote as $G(\\omega)$. So the inner integral simplifies to $e^{-i \\omega \\tau} G(\\omega)$.\n\nSubstituting this result back into the expression for the Fourier transform of the convolution:\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = \\int_{\\tau=-\\infty}^{\\infty} f(\\tau) \\left( e^{-i \\omega \\tau} G(\\omega) \\right) d\\tau $$\nSince $G(\\omega)$ does not depend on the integration variable $\\tau$, we can factor it out of the integral:\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = G(\\omega) \\int_{\\tau=-\\infty}^{\\infty} f(\\tau)\\, e^{-i \\omega \\tau}\\, d\\tau $$\nThe remaining integral is the definition of the Fourier transform of $f(\\tau)$, which is $F(\\omega)$. Therefore, we have derived the convolution theorem:\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = F(\\omega) G(\\omega) $$\nNow, we apply this theorem to the specific problem. The modeled trace is $y(t) = r(t) \\star (s(t) \\star s(t))$. Let's define an intermediate function $c(t) = s(t) \\star s(t)$. Then $y(t) = r(t) \\star c(t)$.\n\nLet $R(\\omega) = \\mathcal{F}\\{r(t)\\}$, $S(\\omega) = \\mathcal{F}\\{s(t)\\}$, $C(\\omega) = \\mathcal{F}\\{c(t)\\}$, and $Y(\\omega) = \\mathcal{F}\\{y(t)\\}$.\n\nApplying the convolution theorem to $c(t) = s(t) \\star s(t)$:\n$$ C(\\omega) = \\mathcal{F}\\{s(t) \\star s(t)\\} = S(\\omega) S(\\omega) = S(\\omega)^2 $$\nNext, applying the convolution theorem to $y(t) = r(t) \\star c(t)$:\n$$ Y(\\omega) = \\mathcal{F}\\{r(t) \\star c(t)\\} = R(\\omega) C(\\omega) $$\nFinally, substituting the expression for $C(\\omega)$:\n$$ Y(\\omega) = R(\\omega) S(\\omega)^2 $$\nThis is the frequency-domain representation of the multiples modeled trace. Convolution in the time domain becomes multiplication in the frequency domain. Specifically, the auto-convolution of the source signature corresponds to squaring its spectrum, and the subsequent convolution with the reflectivity series corresponds to multiplication by the reflectivity spectrum.\n\n### Task B: Algorithm Design\n\nWe are asked to compute the final trace $y[n]$ via two distinct pathways for discrete, finite-length sequences $r[n]$ and $s[n]$.\n\nLet the lengths of the input sequences be $N_r = \\mathrm{len}(r)$ and $N_s = \\mathrm{len}(s)$.\n\n1.  **Time-Domain Pathway ($y_{\\mathrm{time}}[n]$)**: This pathway uses direct linear convolution.\n    a.  First, compute the auto-convolution of the source signature, $c[n] = s[n] \\star s[n]$. The length of this intermediate sequence, $c[n]$, will be $N_c = N_s + N_s - 1 = 2N_s - 1$.\n    b.  Next, convolve the reflectivity series $r[n]$ with the result $c[n]$ to get the final trace: $y_{\\mathrm{time}}[n] = r[n] \\star c[n]$. The length of this final sequence, $L$, will be $L = N_r + N_c - 1 = N_r + (2N_s - 1) - 1 = N_r + 2N_s - 2$.\n\n2.  **Frequency-Domain Pathway ($y_{\\mathrm{freq}}[n]$)**: This pathway leverages the Discrete Fourier Transform (DFT) to perform the convolution. The circular convolution property of the DFT can be used to compute a linear convolution if the sequences are zero-padded to a sufficient length.\n    a.  The required length for the DFT, $N_{\\mathrm{fft}}$, must be at least the length of the final linear convolution output, $L$. The problem specifies to use a length of exactly $L$. So, we set $N_{\\mathrm{fft}} = L = N_r + 2N_s - 2$.\n    b.  Pad the input sequences $r[n]$ and $s[n]$ with zeros to this length, $N_{\\mathrm{fft}}$.\n    c.  Compute the DFT of the padded sequences using the given definition:\n        $$ R[k] = \\mathrm{DFT}\\{r_{\\text{padded}}\\}[k] = \\sum_{n=0}^{N_{\\mathrm{fft}}-1} r_{\\text{padded}}[n]\\, e^{-i 2\\pi kn/N_{\\mathrm{fft}}} $$\n        $$ S[k] = \\mathrm{DFT}\\{s_{\\text{padded}}\\}[k] = \\sum_{n=0}^{N_{\\mathrm{fft}}-1} s_{\\text{padded}}[n]\\, e^{-i 2\\pi kn/N_{\\mathrm{fft}}} $$\n    d.  Apply the derived algebraic relationship from Task A in the discrete frequency domain:\n        $$ Y[k] = R[k] \\cdot S[k]^2 $$\n        This multiplication is performed element-wise for each frequency index $k=0, \\dots, N_{\\mathrm{fft}}-1$.\n    e.  Compute the inverse DFT of $Y[k]$ to transform the result back to the time domain:\n        $$ y_{\\mathrm{freq\\_complex}}[n] = \\mathrm{IDFT}\\{Y\\}[n] = \\frac{1}{N_{\\mathrm{fft}}}\\sum_{k=0}^{N_{\\mathrm{fft}}-1} Y[k]\\, e^{i 2\\pi kn/N_{\\mathrm{fft}}} $$\n    f.  Since the original signals $r[n]$ and $s[n]$ are real-valued, their convolution $y[n]$ must also be real-valued. The numerical result $y_{\\mathrm{freq\\_complex}}[n]$ will have a non-zero but negligible imaginary part due to floating-point inaccuracies. As instructed, we discard this by taking the real part:\n        $$ y_{\\mathrm{freq}}[n] = \\mathrm{Re}\\{y_{\\mathrm{freq\\_complex}}[n]\\} $$\n    The sequences $y_{\\mathrm{time}}[n]$ and $y_{\\mathrm{freq}}[n]$ should be identical up to machine precision.\n\n### Task C: Numerical Stability and Roundoff Assessment\n\nFor each test case, we compute four metrics to compare $y_{\\mathrm{time}}$ and $y_{\\mathrm{freq}}$.\n\n1.  **Maximum Absolute Difference**: This metric quantifies the largest pointwise discrepancy between the two methods.\n    $$ \\Delta_{\\max} = \\max_{n} |y_{\\mathrm{time}}[n] - y_{\\mathrm{freq}}[n]| $$\n\n2.  **Relative $\\ell_2$ Error**: This metric provides a normalized measure of the overall difference, considering the energy of the signal. The $\\ell_2$-norm of a vector $v$ is $\\|v\\|_2 = \\sqrt{\\sum_n |v[n]|^2}$.\n    $$ E_2 = \\frac{\\|y_{\\mathrm{time}} - y_{\\mathrm{freq}}\\|_2}{\\|y_{\\mathrm{time}}\\|_2} $$\n    If $\\|y_{\\mathrm{time}}\\|_2 = 0$, the error is defined as $0$.\n\n3.  **Spectral Dynamic Range**: This metric assesses the numerical conditioning of the source spectrum, which can affect the accuracy of frequency-domain operations.\n    a. Let $S[k]$ be the DFT of the padded source signature $s[n]$ over a length of $N_{\\mathrm{fft}}$.\n    b. Compute the power spectrum $P[k] = |S[k]|^2$.\n    c. Find the maximum power $P_{\\max} = \\max_k P[k]$.\n    d. Obtain the machine epsilon for double-precision floating-point numbers, $\\varepsilon$.\n    e. Define a noise floor threshold $P_{\\mathrm{thresh}} = P_{\\max} \\cdot \\varepsilon$.\n    f. Find the minimum power value that is above this floor: $P_{\\min} = \\min\\{P[k] \\mid P[k] \\geq P_{\\mathrm{thresh}}\\}$.\n    g. The dynamic range is then computed as:\n        $$ D = \\log_{10}\\left(\\frac{P_{\\max}}{P_{\\min}}\\right) $$\n    If $P_{\\max} = 0$, which implies $s[n]$ is all zeros, then $P_{\\min}$ would also be $0$. In this scenario, the dynamic range can be considered $0$ as there is no signal.\n\n4.  **Tolerance Check**: A boolean flag indicating whether the numerical methods are acceptably close.\n    $$ \\mathrm{Pass} = (\\mathrm{E_2} \\le \\tau) $$\n    where the tolerance $\\tau$ is given as $10^{-10}$.\n\nThese four metrics provide a comprehensive assessment of the equivalence and numerical stability of the time-domain and frequency-domain convolution algorithms.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    # --- Helper function for wavelet generation ---\n\n    def generate_ricker(n_s, f0, dt):\n        \"\"\"Generates a zero-phase Ricker wavelet.\"\"\"\n        if n_s == 1:\n            return np.array([1.0], dtype=np.float64)\n        t = (np.arange(n_s) - (n_s - 1) / 2) * dt\n        pi_f0_t_sq = (np.pi * f0 * t) ** 2\n        return (1 - 2 * pi_f0_t_sq) * np.exp(-pi_f0_t_sq)\n\n    def generate_gaussian_wavelet(n_s, A, sigma, dt):\n        \"\"\"Generates a zero-phase Gaussian wavelet.\"\"\"\n        if n_s == 1:\n            return np.array([A], dtype=np.float64)\n        t = (np.arange(n_s) - (n_s - 1) / 2) * dt\n        return A * np.exp(-t**2 / (2 * sigma**2))\n\n    def generate_hann_tapered_sine(n_s, fc, dt):\n        \"\"\"Generates a Hann-tapered sine wave.\"\"\"\n        if n_s == 1:\n            return np.array([0.0], dtype=np.float64) # sin(0) = 0\n        n = np.arange(n_s)\n        window = 0.5 * (1 - np.cos(2 * np.pi * n / (n_s - 1)))\n        sine_wave = np.sin(2 * np.pi * fc * n * dt)\n        return window * sine_wave\n\n    def solve_case(case_params):\n        \"\"\"\n        Solves a single test case, returning the four required metrics.\n        \"\"\"\n        case_id = case_params['id']\n        dt = case_params['dt']\n        len_r = case_params['len_r']\n        len_s = case_params['len_s']\n        \n        # --- Generate r[n] and s[n] for the current case ---\n        \n        # Seed for reproducibility\n        rng = np.random.default_rng(seed=case_id)\n\n        if case_id == 1:\n            # Sparse spike train r[n]\n            r = np.zeros(len_r, dtype=np.float64)\n            is_spike = rng.random(len_r)  0.01\n            num_spikes = np.sum(is_spike)\n            r[is_spike] = rng.uniform(-0.8, 0.8, num_spikes)\n            # Ricker wavelet s[n]\n            s = generate_ricker(len_s, f0=25.0, dt=dt)\n\n        elif case_id == 2:\n            # Trivial boundary case\n            r = np.array([1.0], dtype=np.float64)\n            s = np.array([1.0], dtype=np.float64)\n\n        elif case_id == 3:\n            # Gaussian noise r[n]\n            r = rng.normal(loc=0.0, scale=1e-3, size=len_r).astype(np.float64)\n            # Gaussian wavelet s[n]\n            s = generate_gaussian_wavelet(len_s, A=1e3, sigma=0.004, dt=dt)\n\n        elif case_id == 4:\n            # Uniform noise r[n]\n            r = rng.uniform(-0.5, 0.5, size=len_r).astype(np.float64)\n            # Hann-tapered sinusoid s[n]\n            s = generate_hann_tapered_sine(len_s, fc=60.0, dt=dt).astype(np.float64)\n\n        # Ensure double precision\n        r = r.astype(np.float64)\n        s = s.astype(np.float64)\n\n        # --- Task B: Time-Domain and Frequency-Domain Pathways ---\n\n        # 1. Time-Domain Pathway\n        c_time = np.convolve(s, s, mode='full')\n        y_time = np.convolve(r, c_time, mode='full')\n        \n        # 2. Frequency-Domain Pathway\n        N_fft = len(y_time) # Use the exact linear convolution length for FFT\n\n        R_fft = fft(r, n=N_fft)\n        S_fft = fft(s, n=N_fft)\n\n        Y_fft = R_fft * (S_fft**2)\n        y_freq_complex = ifft(Y_fft)\n        y_freq = np.real(y_freq_complex)\n\n        # --- Task C: Numerical Stability and Roundoff Assessment ---\n\n        # 1. Maximum Absolute Difference\n        max_abs_diff = np.max(np.abs(y_time - y_freq))\n\n        # 2. Relative l2 Error\n        norm_diff = np.linalg.norm(y_time - y_freq)\n        norm_y_time = np.linalg.norm(y_time)\n        if norm_y_time == 0.0:\n            rel_l2_err = 0.0\n        else:\n            rel_l2_err = norm_diff / norm_y_time\n\n        # 3. Spectral Dynamic Range\n        P = np.abs(S_fft)**2\n        P_max = np.max(P)\n        \n        if P_max == 0.0:\n            dyn_range_log10 = 0.0\n        else:\n            epsilon = np.finfo(np.float64).eps\n            P_thresh = P_max * epsilon\n            P_min_set = P[P = P_thresh]\n            if P_min_set.size == 0: # This case can happen if all P[k]  P_thresh except P_max\n                P_min = P_max\n            else:\n                P_min = np.min(P_min_set)\n\n            if P_min == 0.0:\n                # This could happen if P_max is very small, near machine epsilon\n                # In such a case, the dynamic range is effectively infinite.\n                # However, for this problem, P_max will be substantial.\n                # A safe fallback.\n                dyn_range_log10 = np.inf\n            else:\n                dyn_range_log10 = np.log10(P_max / P_min)\n\n        # 4. Tolerance Check\n        tolerance = 1e-10\n        passed = rel_l2_err = tolerance\n\n        return [max_abs_diff, rel_l2_err, dyn_range_log10, passed]\n    \n    test_cases_params = [\n        {'id': 1, 'dt': 0.001, 'len_r': 2048, 'len_s': 251},\n        {'id': 2, 'dt': 0.002, 'len_r': 1, 'len_s': 1},\n        {'id': 3, 'dt': 0.001, 'len_r': 512, 'len_s': 401},\n        {'id': 4, 'dt': 0.0015, 'len_r': 401, 'len_s': 73},\n    ]\n\n    results = []\n    for params in test_cases_params:\n        case_result = solve_case(params)\n        results.append(case_result)\n    \n    # Custom formatting to match the required output style precisely\n    final_output_str = \"[\" + \",\".join([\n        f\"[{res[0]},{res[1]},{res[2]},{str(res[3]).lower()}]\" for res in results\n    ]) + \"]\"\n\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}