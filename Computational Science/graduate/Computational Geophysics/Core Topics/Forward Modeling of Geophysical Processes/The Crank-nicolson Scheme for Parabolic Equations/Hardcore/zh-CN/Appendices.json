{
    "hands_on_practices": [
        {
            "introduction": "尽管Crank-Nicolson格式因其二阶精度和无条件稳定性而备受青睐，但在处理地球物理学中常见的不连续初始条件（例如岩脉侵入）时，会产生非物理性的吉布斯振荡。本练习  提供了宝贵的实践机会，让你通过实施并比较几种常见的抑制策略，来应对这一数值挑战。通过探索使用初始耗散步（如后向欧拉格式）或应用时间滤波器，你将学会如何平滑解并获得在物理上更为可靠的模拟结果。",
            "id": "3616320",
            "problem": "考虑一维热传导方程（计算地球物理学中一种典型的抛物线型偏微分方程），该方程定义在一个有限线段上，代表一个对称的岩脉冷却基准问题。在无量纲设定下进行计算，其中热扩散率、空间、时间和温度均为无量纲。该问题定义在空间域 $x \\in [-L,L]$ 上，边界条件为狄利克雷边界条件 $u(-L,t)=T_c$ 和 $u(L,t)=T_c$，并具有一个不连续的初始条件，代表嵌入冷基质中的热岩脉：\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2}, \\quad u(x,0) = \\begin{cases}\nT_h,  |x|\\le a,\\\\\nT_c,  |x|a,\n\\end{cases}\n\\quad u(-L,t)=T_c,\\; u(L,t)=T_c.\n$$\n此处 $u(x,t)$ 是无量纲温度，$\\kappa$ 是无量纲热扩散率，$T_h$ 是无量纲高温，$T_c$ 是无量纲低温，$a$ 是岩脉的无量纲半宽度。由于 $u(x,0)$ 不连续，已知某些时间离散化方法（特别是梯形法则，也称为 Crank–Nicolson 方法）会产生非物理的吉布斯状振荡。您的任务是研究 Crank–Nicolson 方法在早期时间的三种启动策略，并定量比较它们在 $L^{\\infty}$ 超调和 $L^2$ 误差方面的行为。\n\n您必须在空间上实现间距为 $\\Delta x$ 的均匀网格，在时间上实现均匀的时间步长 $\\Delta t$。考虑以下三种策略：\n- 纯 Crank–Nicolson (CN) 方法：从 $t=0$ 开始，在所有时间步应用 Crank–Nicolson 格式。\n- 后向欧拉转 Crank–Nicolson (BE→CN) 方法：使用后向欧拉方法进行指定数量 $m$ 的启动步，然后在其后步骤中切换到 Crank–Nicolson 方法。这种方法在数值分析文献中有时被称为 Rannacher 启动。\n- 带时间滤波器的 Crank–Nicolson (CN+TF) 方法：在每个时间步 $n \\ge 1$，计算出 Crank–Nicolson 更新 $u^{n+1}$ 后，对内部网格点值应用一个三层时间滤波器，\n$$\nu^{n+1} \\leftarrow u^{n+1} + \\alpha\\left(u^{n} - 2u^{n+1} + u^{n-1}\\right),\n$$\n其中滤波器强度为给定的 $\\alpha$。在 $n=0$ 时，如果需要，可使用 $u^{-1}=u^{0}$ 进行滤波。\n\n您必须计算在早期时间窗口 $t \\in [0,T_{\\mathrm{end}}]$ 内的两个定量诊断指标：\n- 在整个早期时间演化过程中的 $L^{\\infty}$ 超调量，定义为\n$$\n\\max_{0\\le n\\le N}\\left(\\max_x u^n(x) - \\max_x u^0(x),\\,0\\right),\n$$\n该指标测量任何超过初始最大值的正偏差。将其报告为一个非负标量。\n- 在 $t=T_{\\mathrm{end}}$ 时的 $L^2$ 误差，该误差是与给定不连续初始条件的无限域解析解进行比较计算得出的，\n$$\nu_{\\mathrm{exact}}(x,t) = T_c + \\frac{T_h - T_c}{2}\\left[\\operatorname{erf}\\!\\left(\\frac{x+a}{2\\sqrt{\\kappa t}}\\right) - \\operatorname{erf}\\!\\left(\\frac{x-a}{2\\sqrt{\\kappa t}}\\right)\\right],\n$$\n使用在整个网格（包括端点）上权重为 $\\Delta x$ 的离散 $L^2$ 范数：\n$$\n\\|u(\\cdot,T_{\\mathrm{end}})-u_{\\mathrm{exact}}(\\cdot,T_{\\mathrm{end}})\\|_{2} = \\left(\\Delta x \\sum_j \\left[u(x_j,T_{\\mathrm{end}})-u_{\\mathrm{exact}}(x_j,T_{\\mathrm{end}})\\right]^2\\right)^{1/2}.\n$$\n此处 $\\operatorname{erf}(\\cdot)$ 表示高斯误差函数。假设边界足够远，使得无限域解在指定的早期时间窗口内是有效的参考。\n\n您的空间离散化必须在内部节点上使用标准的二阶中心有限差分来近似拉普拉斯算子，并采用狄利克雷边界条件，而您的时间离散化必须实现由其标准两层公式定义的完全隐式后向欧拉格式和 Crank–Nicolson 格式。所有量都是无量纲的，因此不需要物理单位。\n\n测试套件。对于下面的每个参数集，运行所有三种策略，并为每种策略计算由 $t \\in [0,T_{\\mathrm{end}}]$ 上的 $L^{\\infty}$ 超调和 $t=T_{\\mathrm{end}}$ 时的 $L^2$ 误差组成的对。空间网格应为 $x_j = -L + j \\Delta x$，其中 $j=0,1,\\dots,N_x-1$，并假定 $N_x = 2L/\\Delta x + 1$ 为整数。时间网格应为 $t^n = n\\Delta t$，其中 $n=0,1,\\dots,N$，并假定 $N=T_{\\mathrm{end}}/\\Delta t$ 为整数。使用以下三种情况：\n- 情况 A（为引发振荡的粗时间步长）：$L=5$, $a=1$, $\\kappa=1$, $\\Delta x=0.02$, $\\Delta t=0.02$, $T_{\\mathrm{end}}=0.1$, $T_h=1$, $T_c=0$, $m=2$, $\\alpha=0.1$。\n- 情况 B（中等时间步长）：$L=5$, $a=0.5$, $\\kappa=1$, $\\Delta x=0.02$, $\\Delta t=0.002$, $T_{\\mathrm{end}}=0.04$, $T_h=1$, $T_c=0$, $m=2$, $\\alpha=0.1$。\n- 情况 C（高分辨率）：$L=5$, $a=0.5$, $\\kappa=1$, $\\Delta x=0.01$, $\\Delta t=0.0001$, $T_{\\mathrm{end}}=0.01$, $T_h=1$, $T_c=0$, $m=2$, $\\alpha=0.1$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。按以下顺序连接每个情况的六个浮点数结果\n$$\n[\\text{overshoot}_{\\mathrm{CN}},\\; \\|e\\|_{2,\\mathrm{CN}},\\; \\text{overshoot}_{\\mathrm{BE\\rightarrow CN}},\\; \\|e\\|_{2,\\mathrm{BE\\rightarrow CN}},\\; \\text{overshoot}_{\\mathrm{CN+TF}},\\; \\|e\\|_{2,\\mathrm{CN+TF}}],\n$$\n然后先列出情况 A，再列出情况 B，最后列出情况 C，最终形成一个包含 $18$ 个数字的扁平列表：\n$$\n[\\text{A}_{1},\\text{A}_{2},\\dots,\\text{A}_{6},\\text{B}_{1},\\dots,\\text{B}_{6},\\text{C}_{1},\\dots,\\text{C}_{6}].\n$$\n不应打印其他任何文本。所有计算和输出都是如上所述的无量纲标量。",
            "solution": "该问题要求对给定不连续初始条件的一维热传导方程（一种抛物线型偏微分方程）进行数值求解。我们将研究三种数值策略，这些策略旨在处理此类初始数据（尤其是在使用 Crank-Nicolson 方法时）可能引起的吉布斯状振荡。解决方案的开发将首先在空间和时间上离散化偏微分方程，然后实现指定的数值格式，最后计算所需的诊断指标。\n\n控制偏微分方程为：\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2}\n$$\n定义在域 $x \\in [-L, L]$ 和 $t \\ge 0$ 上。初始条件是一个阶跃函数：\n$$\nu(x,0) = \\begin{cases}\nT_h,  |x|\\le a,\\\\\nT_c,  |x|a,\n\\end{cases}\n$$\n狄利克雷边界条件为 $u(-L,t)=T_c$ 和 $u(L,t)=T_c$。\n\n首先，我们将空间域离散化为一个包含 $N_x$ 个点的均匀网格 $x_j = -L + j \\Delta x$，其中 $j=0, 1, \\dots, N_x-1$ 且 $\\Delta x = 2L / (N_x-1)$。时间域离散化为 $t^n = n \\Delta t$，其中 $n=0, 1, \\dots, N$ 且 $\\Delta t = T_{\\mathrm{end}}/N$。令 $u_j^n$ 表示 $u(x_j, t^n)$ 的数值近似。\n\n对于内部网格点（$j=1, \\dots, N_x-2$），空间二阶导数使用二阶中心有限差分进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j, t^n} \\approx \\frac{u_{j-1}^n - 2u_j^n + u_{j+1}^n}{(\\Delta x)^2}\n$$\n将此近似代入偏微分方程，得到一个常微分方程组（ODE），这种方法被称为方法线法：\n$$\n\\frac{du_j}{dt} = \\frac{\\kappa}{(\\Delta x)^2} (u_{j-1} - 2u_j + u_{j+1})\n$$\n我们可以使用通用的 $\\theta$-格式来表示时间演化：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\frac{\\kappa}{(\\Delta x)^2} \\left[ \\theta(u_{j-1}^{n+1} - 2u_j^{n+1} + u_{j+1}^{n+1}) + (1-\\theta)(u_{j-1}^n - 2u_j^n + u_{j+1}^n) \\right]\n$$\n其中 $\\theta=0$ 对应前向欧拉法，$\\theta=1$ 对应后向欧拉法，$\\theta=1/2$ 对应 Crank-Nicolson 方法。令 $\\lambda = \\frac{\\kappa \\Delta t}{(\\Delta x)^2}$ 为无量纲扩散数。重新整理方程，将时间层 $n+1$ 的项组合在左侧（LHS），时间层 $n$ 的项组合在右侧（RHS），得到：\n$$\n-\\theta\\lambda u_{j-1}^{n+1} + (1+2\\theta\\lambda)u_j^{n+1} - \\theta\\lambda u_{j+1}^{n+1} = (1-\\theta)\\lambda u_{j-1}^n + (1-2(1-\\theta)\\lambda)u_j^n + (1-\\theta)\\lambda u_{j+1}^n\n$$\n这代表了针对内部网格点未知值 $u_j^{n+1}$ 的一个三对角线性方程组。\n\n三种策略的实现如下：\n\n1.  **纯 Crank–Nicolson (CN) 方法**：这对应于 $\\theta = 1/2$。该格式在每个时间步都应用。内部节点的系统变为：\n    $$\n    -\\frac{\\lambda}{2} u_{j-1}^{n+1} + (1+\\lambda) u_j^{n+1} - \\frac{\\lambda}{2} u_{j+1}^{n+1} = \\frac{\\lambda}{2} u_{j-1}^{n} + (1-\\lambda) u_j^{n} + \\frac{\\lambda}{2} u_{j+1}^{n}\n    $$\n    该方法无条件稳定，且在时间上具有二阶精度，但已知当应用于具有非光滑初始数据的问题时，会产生虚假振荡，因为该格式对高频模式的阻尼趋近于零。\n\n2.  **后向欧拉转 Crank–Nicolson (BE→CN) 方法**：此策略在前 $m$ 个时间步使用后向欧拉 (BE) 格式，然后切换到 Crank-Nicolson。BE 格式对应于 $\\theta=1$：\n    $$\n    -\\lambda u_{j-1}^{n+1} + (1+2\\lambda) u_j^{n+1} - \\lambda u_{j+1}^{n+1} = u_j^n\n    $$\n    BE 方法在时间上是一阶的，并且具有强耗散性（L-稳定），这能有效抑制由初始不连续性引起的高频振荡。经过几个初始 BE 步骤后，数值解变得平滑，此时可以切换到更精确的 CN 格式进行余下的模拟。\n\n3.  **带时间滤波器的 Crank–Nicolson (CN+TF) 方法**：此方法在每个标准的 CN 步骤后应用一个滤波器来抑制振荡。在每个时间步 $n$，我们首先使用 CN 格式计算一个临时解 $\\tilde{u}^{n+1}$。然后，对内部节点应用一个三层滤波器：\n    $$\n    u^{n+1} \\leftarrow \\tilde{u}^{n+1} + \\alpha(u^{n} - 2\\tilde{u}^{n+1} + u^{n-1})\n    $$\n    滤波器强度由 $\\alpha$ 给出。对于第一步（$n=0$），需要 $t^{-1} = -\\Delta t$ 处的值。按照规定，我们设置 $u^{-1} = u^0$，这将第一步的滤波器简化为 $u^1 \\leftarrow \\tilde{u}^1 + \\alpha(u^0 - 2\\tilde{u}^1 + u^0) = (1-2\\alpha)\\tilde{u}^1 + 2\\alpha u^0$。\n\n对于所有策略，在每个时间步，都会使用高效的算法（如 `scipy.linalg.solve_banded`）来求解内部节点的三对角方程组。边界条件 $u_0^{n+1} = T_c$ 和 $u_{N_x-1}^{n+1} = T_c$ 被并入线性系统的第一个和最后一个方程中。由于测试用例中 $T_c=0$，这些边界项直接变为零。\n\n诊断指标的计算如下：\n-   **$L^{\\infty}$ 超调**：在每个时间步 $n$ 跟踪最大温度。在步骤 $n$ 的超调是 $\\max_j u_j^n - \\max_j u_j^0$。最终报告的值是此量在所有时间步 $n \\in [0, N]$ 上的最大值，并向下取整到 $0$。\n-   **$L^2$ 误差**：在最终时间 $T_{\\mathrm{end}}$，误差是与提供的无限域解析解进行比较计算的：\n    $$\n    u_{\\mathrm{exact}}(x,t) = T_c + \\frac{T_h - T_c}{2}\\left[\\operatorname{erf}\\!\\left(\\frac{x+a}{2\\sqrt{\\kappa t}}\\right) - \\operatorname{erf}\\!\\left(\\frac{x-a}{2\\sqrt{\\kappa t}}\\right)\\right]\n    $$\n    然后，在所有网格点（包括边界）上计算离散 $L^2$ 范数：\n    $$\n    \\|e\\|_{2} = \\left(\\Delta x \\sum_{j=0}^{N_x-1} \\left[u_j^N - u_{\\mathrm{exact}}(x_j, T_{\\mathrm{end}})\\right]^2\\right)^{1/2}\n    $$\n整体实现涉及一个主函数，该函数遍历所提供的测试用例。对于每个用例，它设置网格和初始条件，然后为三种策略中的每一种运行模拟。每个模拟执行时间步进循环，在每一步求解线性系统，并应用任何所需的滤波。模拟结束后，计算并收集诊断数据以用于最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom scipy.special import erf\n\ndef setup_simulation(params):\n    \"\"\"Sets up grid and initial conditions.\"\"\"\n    L, a, kappa, dx, dt, T_end, Th, Tc, m, alpha = params\n    \n    # Grid setup\n    Nx = int(round(2 * L / dx)) + 1\n    x = np.linspace(-L, L, Nx)\n    Nt = int(round(T_end / dt))\n    \n    # Nondimensional diffusion number\n    lambda_ = kappa * dt / (dx**2)\n    \n    # Initial Condition\n    u0 = np.full(Nx, Tc)\n    u0[np.abs(x) = a] = Th\n    \n    return x, Nx, Nt, lambda_, u0, Tc\n\ndef get_analytical_solution(x, t, params):\n    \"\"\"Computes the analytical solution.\"\"\"\n    L, a, kappa, dx, dt, T_end, Th, Tc, m, alpha = params\n    if t == 0:\n        # Handle t=0 case separately to avoid division by zero\n        u_exact = np.full_like(x, Tc)\n        u_exact[np.abs(x) = a] = Th\n        return u_exact\n    \n    denom = 2.0 * np.sqrt(kappa * t)\n    arg1 = (x + a) / denom\n    arg2 = (x - a) / denom\n    u_exact = Tc + (Th - Tc) / 2.0 * (erf(arg1) - erf(arg2))\n    return u_exact\n\ndef run_simulation(params, strategy):\n    \"\"\"Runs a single simulation for a given strategy.\"\"\"\n    L, a, kappa, dx, dt, T_end, Th, Tc, m, alpha = params\n    x, Nx, Nt, lambda_, u0, Tc = setup_simulation(params)\n    \n    u_curr = u0.copy()\n    max_initial_temp = np.max(u0)\n    max_overshoot = 0.0\n    \n    num_interior_nodes = Nx - 2\n\n    # --- Strategy-specific setup ---\n    \n    # Pure CN\n    if strategy == 'CN' or strategy == 'CN_TF' or (strategy == 'BE_CN' and Nt > m):\n        ab_cn = np.zeros((3, num_interior_nodes))\n        ab_cn[0, 1:] = -lambda_ / 2.0\n        ab_cn[1, :] = 1.0 + lambda_\n        ab_cn[2, :-1] = -lambda_ / 2.0\n    \n    # BE\n    if strategy == 'BE_CN':\n        if m > 0:\n            ab_be = np.zeros((3, num_interior_nodes))\n            ab_be[0, 1:] = -lambda_\n            ab_be[1, :] = 1.0 + 2.0 * lambda_\n            ab_be[2, :-1] = -lambda_\n    \n    # CN+TF\n    if strategy == 'CN_TF':\n        u_prev = u0.copy()\n\n    # --- Time-stepping loop ---\n    for n in range(Nt):\n        # Select scheme for BE->CN\n        if strategy == 'BE_CN' and n  m:\n            ab = ab_be\n            rhs = u_curr[1:-1]\n        else: # CN for all other cases\n            ab = ab_cn\n            rhs = (lambda_ / 2.0) * (u_curr[:-2] + u_curr[2:]) + (1.0 - lambda_) * u_curr[1:-1]\n\n        # Solve for interior nodes\n        u_next_interior = solve_banded((1, 1), ab, rhs)\n        \n        u_next = np.empty(Nx)\n        u_next[0], u_next[-1] = Tc, Tc\n        u_next[1:-1] = u_next_interior\n        \n        # Apply Time Filter if required\n        if strategy == 'CN_TF':\n            u_tilde = u_next.copy()\n            u_next[1:-1] = (1.0 - 2.0 * alpha) * u_tilde[1:-1] + alpha * (u_curr[1:-1] + u_prev[1:-1])\n            u_prev[:] = u_curr\n        \n        # Update solution for next step\n        u_curr[:] = u_next\n        \n        # Update overshoot diagnostic\n        current_max = np.max(u_curr)\n        overshoot = current_max - max_initial_temp\n        if overshoot > max_overshoot:\n            max_overshoot = overshoot\n\n    # --- Final diagnostics ---\n    u_final = u_curr\n    u_exact = get_analytical_solution(x, T_end, params)\n    \n    # L2 Error\n    error_vec = u_final - u_exact\n    l2_error = np.sqrt(dx * np.sum(error_vec**2))\n    \n    return max_overshoot, l2_error\n\ndef solve():\n    \"\"\"Main solver function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # Case A (L, a, kappa, dx, dt, T_end, Th, Tc, m, alpha)\n        (5.0, 1.0, 1.0, 0.02, 0.02, 0.1, 1.0, 0.0, 2, 0.1),\n        # Case B\n        (5.0, 0.5, 1.0, 0.02, 0.002, 0.04, 1.0, 0.0, 2, 0.1),\n        # Case C\n        (5.0, 0.5, 1.0, 0.01, 0.0001, 0.01, 1.0, 0.0, 2, 0.1)\n    ]\n    \n    strategies = ['CN', 'BE_CN', 'CN_TF']\n    \n    all_results = []\n    \n    for case_params in test_cases:\n        for strategy in strategies:\n            overshoot, l2_error = run_simulation(case_params, strategy)\n            all_results.append(overshoot)\n            all_results.append(l2_error)\n            \n    # Format results for printing\n    result_str = \",\".join(f\"{res:.8f}\" for res in all_results)\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了处理非光滑初始数据的方法后，下一个挑战是让我们的模拟能够适应随时间变化的地球物理过程。本练习  指导你将Crank-Nicolson格式推广到可变时间步长，以高效、准确地模拟具有突发事件的系统，同时保持其二階精度。更重要的是，你将通过步长加倍测试来验证代码的收敛阶，这是计算科学中验证数值方法正确性的核心技能。",
            "id": "3616345",
            "problem": "考虑与岩石圈构造冷却相关的一维热传导问题，该问题由以下抛物线型偏微分方程 (PDE) 控制\n$$\n\\frac{\\partial T}{\\partial t}(z,t) \\;=\\; \\kappa \\,\\frac{\\partial^2 T}{\\partial z^2}(z,t) \\;+\\; \\frac{q(z,t)}{\\rho\\,c_p},\n$$\n该问题定义在有限域 $z \\in [0,L]$ 上，具有狄利克雷边界条件 $T(0,t) = T_s$ 和 $T(L,t) = T_b$，以及初始条件 $T(z,0) = T_{\\mathrm{init}}$。此处，$T$ 是温度（单位为 $\\mathrm{K}$），$\\kappa$ 是热扩散率（单位为 $\\mathrm{m}^2/\\mathrm{s}$），$q$ 是体积产热率（单位为 $\\mathrm{W}/\\mathrm{m}^3$），$\\rho$ 是密度（单位为 $\\mathrm{kg}/\\mathrm{m}^3$），$c_p$ 是比热容（单位为 $\\mathrm{J}/(\\mathrm{kg}\\cdot\\mathrm{K})$）。假设产热率 $q(z,t)$ 在深度上是分段常数，并在时间 $t_{\\mathrm{jump}}$ 发生突变：在上地壳层 $0 \\le z \\le z_h$ 中，$q(z,t) = q_0$（当 $t  t_{\\mathrm{jump}}$ 时）和 $q(z,t) = q_1$（当 $t \\ge t_{\\mathrm{jump}}$ 时）；而在 $z > z_h$ 的区域，$q(z,t) = 0$。\n\n您的任务是：\n- 使用时间上的广义梯形法则，推导并实现一个可变时间步长的 Crank–Nicolson (CN) 格式，以在非均匀时间步长下保持时间上的二阶精度。通过在每个时间区间的两端计算源项 $q(z,t)$ 并取平均值来显式处理源项，并确保任何会跨越 $t_{\\mathrm{jump}}$ 处不连续点的时间步都被拆分，从而使该不连续点恰好位于一个时间节点上。\n- 使用具有 $M$ 个节点、间距为 $\\Delta z = L/(M-1)$ 的均匀网格上的二阶中心有限差分来离散化空间算子，并直接在 $z=0$ 和 $z=L$ 处施加狄利克雷边界条件。\n- 通过步长减半测试验证时间上的观测精度阶。对于每个测试用例，使用非均匀时间步长方案执行三次运行至最终时间 $t_{\\mathrm{final}}$，其中 $t  t_{\\mathrm{jump}}$ 时的基础步长为 $\\Delta t_{\\mathrm{pre}}$，$t \\ge t_{\\mathrm{jump}}$ 时的基础步长为 $\\Delta t_{\\mathrm{post}}$，然后将这些步长按因子 $1$、$1/2$ 和 $1/4$ 进行缩放。通过使用适用的基础步长向前推进来构建步长方案，并且当下一步将越过 $t_{\\mathrm{jump}}$ 或 $t_{\\mathrm{final}}$ 时，缩短该步长以使其精确地落在断点上。计算在 $t_{\\mathrm{final}}$ 时的温度场 $U_{\\Delta t}$、$U_{\\Delta t/2}$ 和 $U_{\\Delta t/4}$，并估计观测阶\n$$\np \\;=\\; \\frac{\\log\\!\\left(\\frac{\\|U_{\\Delta t} - U_{\\Delta t/2}\\|_2}{\\|U_{\\Delta t/2} - U_{\\Delta t/4}\\|_2}\\right)}{\\log(2)},\n$$\n其中 $\\|\\cdot\\|_2$ 表示在所有网格节点上的离散欧几里得范数。\n\n您必须编写一个完整、可运行的程序，为以下三个科学上合理的测试用例执行上述任务（所有物理量在内部必须使用国际单位制 (SI) 单位；年必须使用 $1\\,\\mathrm{yr} = 365.25 \\times 24 \\times 3600\\,\\mathrm{s}$ 转换为秒）：\n\n- 测试用例 A（理想情况，非均匀时间步长，跳变点与基础步长不对齐）：\n    - $L = 40000\\,\\mathrm{m}$，$M = 101$，$\\kappa = 1.0 \\times 10^{-6}\\,\\mathrm{m}^2/\\mathrm{s}$，\n      $\\rho = 2700\\,\\mathrm{kg}/\\mathrm{m}^3$，$c_p = 1000\\,\\mathrm{J}/(\\mathrm{kg}\\cdot\\mathrm{K})$，\n      $T_s = 273\\,\\mathrm{K}$，$T_b = 1300\\,\\mathrm{K}$，$T_{\\mathrm{init}} = 1300\\,\\mathrm{K}$，\n      $z_h = 15000\\,\\mathrm{m}$，$q_0 = 1.0 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$，$q_1 = 0.3 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$，\n      $t_{\\mathrm{jump}} = 3.0\\,\\mathrm{Myr}$，$t_{\\mathrm{final}} = 10.0\\,\\mathrm{Myr}$，\n      $\\Delta t_{\\mathrm{pre}} = 0.7\\,\\mathrm{Myr}$，$\\Delta t_{\\mathrm{post}} = 1.3\\,\\mathrm{Myr}$。\n\n- 测试用例 B（边界情况：早期跳变，较小的域时间，不同的非均匀步长）：\n    - $L = 50000\\,\\mathrm{m}$，$M = 121$，$\\kappa = 1.0 \\times 10^{-6}\\,\\mathrm{m}^2/\\mathrm{s}$，\n      $\\rho = 2700\\,\\mathrm{kg}/\\mathrm{m}^3$，$c_p = 1000\\,\\mathrm{J}/(\\mathrm{kg}\\cdot\\mathrm{K})$，\n      $T_s = 273\\,\\mathrm{K}$，$T_b = 1200\\,\\mathrm{K}$，$T_{\\mathrm{init}} = 1200\\,\\mathrm{K}$，\n      $z_h = 20000\\,\\mathrm{m}$，$q_0 = 1.5 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$，$q_1 = 0.0\\,\\mathrm{W}/\\mathrm{m}^3$，\n      $t_{\\mathrm{jump}} = 0.2\\,\\mathrm{Myr}$，$t_{\\mathrm{final}} = 5.0\\,\\mathrm{Myr}$，\n      $\\Delta t_{\\mathrm{pre}} = 0.3\\,\\mathrm{Myr}$，$\\Delta t_{\\mathrm{post}} = 0.8\\,\\mathrm{Myr}$。\n\n- 测试用例 C（边缘情况：大幅度变化和更长的演化时间）：\n    - $L = 60000\\,\\mathrm{m}$，$M = 151$，$\\kappa = 1.0 \\times 10^{-6}\\,\\mathrm{m}^2/\\mathrm{s}$，\n      $\\rho = 2700\\,\\mathrm{kg}/\\mathrm{m}^3$，$c_p = 1000\\,\\mathrm{J}/(\\mathrm{kg}\\cdot\\mathrm{K})$，\n      $T_s = 273\\,\\mathrm{K}$，$T_b = 1300\\,\\mathrm{K}$，$T_{\\mathrm{init}} = 1300\\,\\mathrm{K}$，\n      $z_h = 25000\\,\\mathrm{m}$，$q_0 = 2.0 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$，$q_1 = 0.2 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$，\n      $t_{\\mathrm{jump}} = 8.0\\,\\mathrm{Myr}$，$t_{\\mathrm{final}} = 20.0\\,\\mathrm{Myr}$，\n      $\\Delta t_{\\mathrm{pre}} = 1.1\\,\\mathrm{Myr}$，$\\Delta t_{\\mathrm{post}} = 2.0\\,\\mathrm{Myr}$。\n\n对于每个测试用例，按前述方法计算观测阶 $p$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表，例如 $[p_A,p_B,p_C]$。输出 $p_A$、$p_B$ 和 $p_C$ 必须是无单位的实数（浮点数）。计算中的所有中间量都必须以国际单位制 (SI) 处理，并且此问题不涉及角度。最终输出是无量纲的。",
            "solution": "用户要求推导并实现一种可变时间步长的 Crank-Nicolson 方法来求解一维热传导问题，并随后对其时间精度阶进行数值验证。\n\n### 1. 问题详述\n\n控制方程是带源项的一维热方程：\n$$\n\\frac{\\partial T}{\\partial t}(z,t) \\;=\\; \\kappa \\,\\frac{\\partial^2 T}{\\partial z^2}(z,t) \\;+\\; S(z,t)\n$$\n其中 $S(z,t) = q(z,t)/(\\rho c_p)$ 是归一化的体积产热率。问题定义在域 $z \\in [0,L]$ 和时间 $t \\in [0, t_{\\mathrm{final}}]$ 上。边界条件为狄利克雷类型：$T(0,t) = T_s$ 和 $T(L,t) = T_b$。初始条件为 $T(z,0) = T_{\\mathrm{init}}$。\n\n源项 $q(z,t)$ 在空间和时间上均为分段常数：\n$$\nq(z,t) =\n\\begin{cases}\nq_0,   \\text{for } 0 \\le z \\le z_h \\text{ and } t  t_{\\mathrm{jump}} \\\\\nq_1,   \\text{for } 0 \\le z \\le z_h \\text{ and } t \\ge t_{\\mathrm{jump}} \\\\\n0,     \\text{for } z > z_h\n\\end{cases}\n$$\n\n### 2. 数值离散化\n\n我们在均匀空间网格和非均匀时间网格上对问题进行离散化。\n令 $T_j^n \\approx T(z_j, t_n)$，其中 $z_j = j \\Delta z$（$j=0, 1, \\dots, M-1$），$\\Delta z = L/(M-1)$，$t_n$ 是第 $n$ 步的时间。\n\n#### 2.1. 空间离散化\n\n空间二阶导数对内部节点（$j=1, 2, \\dots, M-2$）使用二阶中心有限差分格式进行近似：\n$$\n\\left. \\frac{\\partial^2 T}{\\partial z^2} \\right|_{z_j, t_n} \\approx \\frac{T_{j-1}^n - 2T_j^n + T_{j+1}^n}{(\\Delta z)^2}\n$$\n令 $\\mathbf{U}(t)$ 为 $N_{int} = M-2$ 个内部节点处的温度向量，即 $\\mathbf{U}_j(t) = T_{j+1}(t)$（$j=0, \\dots, N_{int}-1$）。半离散化的常微分方程组 (ODEs) 可以写成矩阵形式：\n$$\n\\frac{d\\mathbf{U}}{dt} = \\frac{\\kappa}{(\\Delta z)^2} \\mathbf{A} \\mathbf{U} + \\frac{\\kappa}{(\\Delta z)^2} \\mathbf{b} + \\mathbf{S}(t)\n$$\n此处，$\\mathbf{A}$ 是表示内部节点离散拉普拉斯算子的 $N_{int} \\times N_{int}$ 三对角矩阵：\n$$\n\\mathbf{A} = \\begin{pmatrix}\n-2  1  0  \\dots  0 \\\\\n1  -2  1  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n0  \\dots  1  -2  1 \\\\\n0  \\dots  0  1  -2\n\\end{pmatrix}\n$$\n向量 $\\mathbf{b}$ 包含了恒定的狄利克雷边界条件：\n$$\n\\mathbf{b} = [T_s, 0, \\dots, 0, T_b]^T\n$$\n而 $\\mathbf{S}(t)$ 是在内部网格点上求值的源项向量。\n\n#### 2.2. 时间离散化\n\n为在非均匀时间步长 $\\Delta t_n = t_{n+1} - t_n$ 下保持二阶精度，我们将梯形法则（Crank-Nicolson 方法）应用于半离散化系统。将 ODE 系统从 $t_n$ 积分到 $t_{n+1}$，得到：\n$$\n\\mathbf{U}^{n+1} - \\mathbf{U}^n = \\int_{t_n}^{t_{n+1}} \\left( \\frac{\\kappa}{(\\Delta z)^2} (\\mathbf{A} \\mathbf{U}(t) + \\mathbf{b}) + \\mathbf{S}(t) \\right) dt\n$$\n对积分应用梯形法则得到：\n$$\n\\frac{\\mathbf{U}^{n+1} - \\mathbf{U}^n}{\\Delta t_n} = \\frac{1}{2} \\left[ \\left(\\frac{\\kappa}{(\\Delta z)^2} (\\mathbf{A} \\mathbf{U}^{n+1} + \\mathbf{b}) + \\mathbf{S}^{n+1}\\right) + \\left(\\frac{\\kappa}{(\\Delta z)^2} (\\mathbf{A} \\mathbf{U}^{n} + \\mathbf{b}) + \\mathbf{S}^{n}\\right) \\right]\n$$\n该格式是无条件稳定的，并且在时间上具有二阶精度。重新整理各项以求解未知状态 $\\mathbf{U}^{n+1}$：\n$$\n\\left(\\mathbf{I} - \\frac{\\kappa \\Delta t_n}{2(\\Delta z)^2} \\mathbf{A}\\right) \\mathbf{U}^{n+1} = \\left(\\mathbf{I} + \\frac{\\kappa \\Delta t_n}{2(\\Delta z)^2} \\mathbf{A}\\right) \\mathbf{U}^{n} + \\frac{\\kappa \\Delta t_n}{(\\Delta z)^2} \\mathbf{b} + \\frac{\\Delta t_n}{2} (\\mathbf{S}^{n+1} + \\mathbf{S}^{n})\n$$\n令 $\\mu = \\frac{\\kappa \\Delta t_n}{2(\\Delta z)^2}$，方程可写为线性系统 $\\mathbf{L} \\mathbf{U}^{n+1} = \\mathbf{R}$ 的形式，其中：\n$$\n\\mathbf{L} = \\mathbf{I} - \\mu \\mathbf{A}\n$$\n$$\n\\mathbf{R} = (\\mathbf{I} + \\mu \\mathbf{A})\\mathbf{U}^{n} + 2\\mu \\mathbf{b} + \\frac{\\Delta t_n}{2} (\\mathbf{S}^{n+1} + \\mathbf{S}^{n})\n$$\n矩阵 $\\mathbf{L}$ 是三对角的，这使得可以使用诸如托马斯算法（追赶法）之类的算法在 $O(M)$ 时间内高效地求解该线性系统。\n\n### 3. 时间步进与源项管理\n\n必须构建时间步进方案，以确保某个时间节点与 $t_{\\mathrm{jump}}$ 处的不连续点重合。从 $t=0$ 开始，根据当前时间是在 $t_{\\mathrm{jump}}$ 之前还是之后来选择时间步长 $\\Delta t$。如果该步长会越过 $t_{\\mathrm{jump}}$ 或 $t_{\\mathrm{final}}$，则将其缩短。具体而言，对于当前时间 $t_{curr}$，下一步的步长为 $\\Delta t_{actual} = \\min(\\Delta t_{base}, t_{break} - t_{curr})$，其中 $t_{break}$ 是下一个关键时间点（$t_{\\mathrm{jump}}$ 或 $t_{\\mathrm{final}}$）。在每个时间点，根据 $q(z,t)$ 在空间节点上的值来计算源向量 $\\mathbf{S}(t)$。\n\n### 4. 精度验证\n\n观测精度阶 $p$ 是通过步长减半测试（一种理查森外推法）来确定的。模拟运行三次至 $t_{\\mathrm{final}}$，基础时间步长 $(\\Delta t_{\\mathrm{pre}}, \\Delta t_{\\mathrm{post}})$ 分别按因子 $1$、$1/2$ 和 $1/4$ 进行缩放，从而得到解 $U_{\\Delta t}$、$U_{\\Delta t/2}$ 和 $U_{\\Delta t/4}$。然后，阶数 $p$ 按如下公式估计：\n$$\np \\;=\\; \\frac{\\log\\!\\left(\\frac{\\|U_{\\Delta t} - U_{\\Delta t/2}\\|_2}{\\|U_{\\Delta t/2} - U_{\\Delta t/4}\\|_2}\\right)}{\\log(2)}\n$$\n其中 $\\|\\cdot\\|_2$ 是在所有空间网格节点上计算的欧几里得范数。对于一个二阶格式，我们预期 $p \\approx 2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute the observed order of accuracy 'p' for each.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        { # Test Case A\n            'L': 40000.0, 'M': 101, 'kappa': 1.0e-6, 'rho': 2700.0, 'cp': 1000.0,\n            'Ts': 273.0, 'Tb': 1300.0, 'T_init': 1300.0, 'zh': 15000.0,\n            'q0': 1.0e-6, 'q1': 0.3e-6, 't_jump': 3.0, 't_final': 10.0,\n            'dt_pre': 0.7, 'dt_post': 1.3\n        },\n        { # Test Case B\n            'L': 50000.0, 'M': 121, 'kappa': 1.0e-6, 'rho': 2700.0, 'cp': 1000.0,\n            'Ts': 273.0, 'Tb': 1200.0, 'T_init': 1200.0, 'zh': 20000.0,\n            'q0': 1.5e-6, 'q1': 0.0, 't_jump': 0.2, 't_final': 5.0,\n            'dt_pre': 0.3, 'dt_post': 0.8\n        },\n        { # Test Case C\n            'L': 60000.0, 'M': 151, 'kappa': 1.0e-6, 'rho': 2700.0, 'cp': 1000.0,\n            'Ts': 273.0, 'Tb': 1300.0, 'T_init': 1300.0, 'zh': 25000.0,\n            'q0': 2.0e-6, 'q1': 0.2e-6, 't_jump': 8.0, 't_final': 20.0,\n            'dt_pre': 1.1, 'dt_post': 2.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p = compute_p_for_case(case)\n        results.append(p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\ndef compute_p_for_case(case_params):\n    \"\"\"\n    Computes the observed order of accuracy 'p' for a single test case.\n    \"\"\"\n    dt_pre_base = case_params['dt_pre']\n    dt_post_base = case_params['dt_post']\n    \n    # Run 1: Base time steps\n    T1 = run_simulation(case_params, dt_pre_base, dt_post_base)\n    # Run 2: Time steps halved\n    T2 = run_simulation(case_params, dt_pre_base / 2.0, dt_post_base / 2.0)\n    # Run 3: Time steps quartered\n    T3 = run_simulation(case_params, dt_pre_base / 4.0, dt_post_base / 4.0)\n\n    # Compute the L2 norms of the differences between solutions.\n    norm12 = np.linalg.norm(T1 - T2)\n    norm23 = np.linalg.norm(T2 - T3)\n\n    # Calculate the observed order of accuracy 'p'.\n    if norm23 == 0.0:\n        return np.nan if norm12 > 0.0 else 2.0 # Converged solution\n    \n    p = np.log(norm12 / norm23) / np.log(2.0)\n    return p\n\ndef run_simulation(params, dt_pre_myr, dt_post_myr):\n    \"\"\"\n    Performs a single heat conduction simulation for a given set of parameters.\n    \"\"\"\n    # Unpack parameters\n    L, M, kappa, rho, cp = params['L'], params['M'], params['kappa'], params['rho'], params['cp']\n    Ts, Tb, T_init, zh = params['Ts'], params['Tb'], params['T_init'], params['zh']\n    q0, q1 = params['q0'], params['q1']\n    t_jump_myr, t_final_myr = params['t_jump'], params['t_final']\n\n    # Unit conversions (Myr -> s)\n    s_per_yr = 365.25 * 24.0 * 3600.0\n    t_jump = t_jump_myr * 1e6 * s_per_yr\n    t_final = t_final_myr * 1e6 * s_per_yr\n    dt_pre = dt_pre_myr * 1e6 * s_per_yr\n    dt_post = dt_post_myr * 1e6 * s_per_yr\n\n    # Spatial grid setup\n    dz = L / (M - 1)\n    z_nodes = np.linspace(0, L, M)\n    num_interior_nodes = M - 2\n    \n    # Initial condition\n    T_initial = np.full(M, T_init)\n    T_initial[0], T_initial[-1] = Ts, Tb\n    U = T_initial[1:-1].copy()\n\n    # Pre-calculate constants and source term configuration\n    alpha_const = kappa / (dz * dz)\n    interior_z = z_nodes[1:-1]\n    source_indices = np.where(interior_z = zh)[0]\n    \n    def get_S_vector(t_s):\n        q_val = q0 if t_s  t_jump else q1\n        s_val = q_val / (rho * cp)\n        S_vec = np.zeros(num_interior_nodes)\n        if s_val != 0.0:\n            S_vec[source_indices] = s_val\n        return S_vec\n\n    def generate_time_steps(tf, tj, dtp, dtpo):\n        current_t = 0.0\n        while current_t  tf * (1. - 1e-12):\n            dt_base = dtp if current_t  tj else dtpo\n            dt_to_jump = tj - current_t if current_t  tj else float('inf')\n            dt_to_final = tf - current_t\n            \n            dt = min(dt_base, dt_to_jump, dt_to_final)\n            if dt = 1e-9: break\n            \n            next_t = current_t + dt\n            yield current_t, next_t\n            current_t = next_t\n\n    # --- Time-stepping loop ---\n    for t_curr, t_next in generate_time_steps(t_final, t_jump, dt_pre, dt_post):\n        dt = t_next - t_curr\n        mu = 0.5 * dt * alpha_const\n\n        # --- Assemble RHS vector ---\n        # 1. (I + mu*A_hat) * U_n term\n        rhs = (1.0 - 2.0 * mu) * U\n        if num_interior_nodes > 1:\n            rhs[1:] += mu * U[:-1]\n            rhs[:-1] += mu * U[1:]\n\n        # 2. Boundary condition contribution: 2*mu*b\n        if num_interior_nodes > 0:\n            rhs[0] += 2.0 * mu * Ts\n            rhs[-1] += 2.0 * mu * Tb\n        \n        # 3. Source term contribution\n        S_n = get_S_vector(t_curr)\n        S_n_1 = get_S_vector(t_next)\n        rhs += 0.5 * dt * (S_n + S_n_1)\n\n        # --- Solve the linear system ---\n        if num_interior_nodes > 0:\n            l_and_u = 1\n            ab = np.zeros((3, num_interior_nodes))\n            ab[0, 1:] = -mu\n            ab[1, :] = 1.0 + 2.0 * mu\n            ab[2, :-1] = -mu\n            U = solve_banded((l_and_u, l_and_u), ab, rhs, overwrite_ab=True, overwrite_b=True)\n\n    # Reconstruct full temperature vector at t_final\n    T_final = np.empty(M)\n    T_final[0], T_final[-1] = Ts, Tb\n    if num_interior_nodes > 0:\n        T_final[1:-1] = U\n    \n    return T_final\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "最后，我们将从实现技巧深入到支撑稳健数值建模的基础理论。本练习  让你扮演数值分析师的角色，通过分析格式在最快衰减本征模上的行为来主动控制其精度。通过校准无量綱时间步长参数 $r$ 来管理振幅和相位误差，你将学会如何基于理论分析对模拟参数做出明智选择，从而在根本上确保计算的稳定性和准确性。",
            "id": "3616370",
            "problem": "您需要为应用于岩石圈冷却背景下抛物线方程的 Crank-Nicolson 格式设计并实现一个基于精度的时步控制器。其基础物理模型是描述有限厚板（代表一段岩石圈）内温度演化的一维热扩散方程，\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2},\n$$\n该方程定义在区间 $x \\in [0,L]$ 上，并带有齐次狄利克雷边界条件 $u(0,t) = 0$ 和 $u(L,t) = 0$。其中，$u(x,t)$ 是温度，$\\kappa$ 是热扩散率，$L$ 是板厚。空间离散化采用具有 $N$ 个内部节点的均匀网格，网格间距为 $\\Delta x = L/(N+1)$，由此产生半离散系统：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\frac{\\kappa}{\\Delta x^2} \\mathbf{L}\\,\\mathbf{u},\n$$\n其中 $\\mathbf{L}$ 是对应齐次狄利克雷条件的经典二阶差分矩阵。时间积分采用 Crank-Nicolson 方法，其无量纲参数为 $r = \\kappa\\,\\Delta t/\\Delta x^2$，其中 $\\Delta t$ 是时步。\n\n您的任务是校准无量纲参数 $r$，以控制半离散算子 $\\mathbf{L}$ 的衰减本征模的数值误差，重点关注谱中的最差情况模态。该校准必须强制执行两个精度要求：\n\n1. 振幅误差控制：对于 $\\mathbf{L}$ 的最差情况离散本征模（其本征值为 $\\mu_{\\max}  0$），定义每步无量纲衰减 $s = r|\\mu_{\\max}|$，并令精确的半离散每步振幅为 $A_{\\mathrm{exact}}(s) = e^{-s}$。定义 Crank-Nicolson 每步放大因子 $A_{\\mathrm{CN}}(s)$，并令每步相对振幅误差为\n$$\nE_{\\mathrm{amp}}(s) = \\frac{|A_{\\mathrm{CN}}(s) - A_{\\mathrm{exact}}(s)|}{A_{\\mathrm{exact}}(s)}.\n$$\n您必须选择 $r$ 以使得对于最差情况模态，$E_{\\mathrm{amp}}(s) \\le \\varepsilon_{\\mathrm{amp}}$ 成立，其中 $\\varepsilon_{\\mathrm{amp}}$ 是给定的容差。此条件必须在每个时步都强制执行。\n\n2. 相位误差控制：由于热扩散产生无振荡的单调衰减，因此对于最差情况模态，离散的每步放大因子必须保持非负，以避免非物理的符号反转。将每步“相位”定义为放大因子的辐角（以弧度为单位）。控制器必须确保对于最差情况模态，此相位等于 $0$，这等效于要求一个非负的放大因子。请用弧度表示相位要求，并将其作为布尔约束来强制执行。\n\n您必须推导出在均匀网格和齐次狄利克雷边界条件下二阶差分矩阵 $\\mathbf{L}$ 的离散最差模态本征值 $|\\mu_{\\max}|$，并用它来构建一个算法，该算法选择满足振幅误差约束和非负性（零相位）约束的最大的 $r$。选定 $r$ 后，您必须确定覆盖目标模拟时域 $T$ 所需的时步数 $M$。为此，需使用一个均匀时步 $\\Delta t$，该时步满足 $\\Delta t \\le \\Delta t_{\\max}$，其中 $\\Delta t_{\\max}$ 由选定的 $r$ 和网格间距所隐含，具体为\n$$\n\\Delta t_{\\max} = \\frac{r\\,\\Delta x^2}{\\kappa}.\n$$\n使用 $M = \\lceil T / \\Delta t_{\\max} \\rceil$ 计算 $M$，然后设置实际的 $\\Delta t = T/M$ 以精确覆盖 $T$。模拟中使用的最终无量纲参数为\n$$\nr_{\\mathrm{final}} = \\frac{\\kappa\\,\\Delta t}{\\Delta x^2}.\n$$\n\n对于下面的每个测试用例，计算并报告：\n- $r_{\\mathrm{final}}$ (浮点数)，\n- $M$ (整数)，\n- 最差模态的每步相对振幅误差 $E_{\\mathrm{amp}}(r_{\\mathrm{final}}|\\mu_{\\max}|)$ (浮点数)，\n- 一个布尔值，指示是否满足相位约束（最差模态每步放大因子为非负），\n- 一个布尔值，指示是否满足振幅约束（每步 $E_{\\mathrm{amp}} \\le \\varepsilon_{\\mathrm{amp}}$）。\n\n所有物理量必须使用国际单位制（SI单位）处理：$\\kappa$ 的单位是 $\\mathrm{m}^2/\\mathrm{s}$，$L$ 的单位是 $\\mathrm{m}$，$T$ 的单位是 $\\mathrm{s}$。相位必须以弧度为单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如：\"[[r1,M1,err1,phase_ok1,amp_ok1],[r2,M2,err2,phase_ok2,amp_ok2]]\"）。\n\n测试套件：\n- 用例1（正常路径）：$\\kappa = 1.0\\times 10^{-6}\\ \\mathrm{m}^2/\\mathrm{s}$，$L = 1.0\\times 10^{5}\\ \\mathrm{m}$，$N = 100$，$T = 1.0\\times 10^{12}\\ \\mathrm{s}$，$\\varepsilon_{\\mathrm{amp}} = 1.0\\times 10^{-3}$。\n- 用例2（严格振幅控制）：$\\kappa = 1.0\\times 10^{-6}\\ \\mathrm{m}^2/\\mathrm{s}$，$L = 1.0\\times 10^{5}\\ \\mathrm{m}$，$N = 100$，$T = 1.0\\times 10^{12}\\ \\mathrm{s}$，$\\varepsilon_{\\mathrm{amp}} = 1.0\\times 10^{-6}$。\n- 用例3（粗网格，中等振幅控制）：$\\kappa = 1.0\\times 10^{-6}\\ \\mathrm{m}^2/\\mathrm{s}$，$L = 1.0\\times 10^{5}\\ \\mathrm{m}$，$N = 10$，$T = 1.0\\times 10^{12}\\ \\mathrm{s}$，$\\varepsilon_{\\mathrm{amp}} = 1.0\\times 10^{-2}$。\n- 用例4（宽松振幅控制，受相位限制）：$\\kappa = 1.0\\times 10^{-6}\\ \\mathrm{m}^2/\\mathrm{s}$，$L = 1.0\\times 10^{5}\\ \\mathrm{m}$，$N = 100$，$T = 1.0\\times 10^{12}\\ \\mathrm{s}$，$\\varepsilon_{\\mathrm{amp}} = 5.0\\times 10^{-1}$。\n\n您的实现必须具有通用性，并适用于具有相同形式的任意测试参数。最终输出必须严格遵循上述的单行、逗号分隔、方括号括起的列表格式。",
            "solution": "用户提供的问题是有效的，因为它在科学上基于数值分析和热传导的原理，是适定的，并包含获得唯一解所需的所有信息。我们着手进行推导和实现。\n\n该问题要求为应用于一维热方程 $\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2}$ 的 Crank-Nicolson 格式设计一个时步控制器。该控制器必须选择无量纲时步参数 $r = \\kappa \\Delta t / \\Delta x^2$，以满足对空间离散化系统的最差情况本征模的数值振幅和相位误差的约束。\n\n### 1. 空间离散化的本征值\n空间域 $x \\in [0, L]$ 用 $N$ 个内部节点进行离散化，得到的网格间距为 $\\Delta x = L/(N+1)$。半离散系统为 $\\frac{d\\mathbf{u}}{dt} = \\frac{\\kappa}{\\Delta x^2} \\mathbf{L}\\,\\mathbf{u}$，其中 $\\mathbf{L}$ 是用于齐次狄利克雷边界条件的 $N \\times N$ 二阶差分矩阵。矩阵 $\\mathbf{L}$ 的本征值是众所周知的，由下式给出：\n$$\n\\mu_j = -4 \\sin^2\\left(\\frac{j\\pi}{2(N+1)}\\right), \\quad \\text{for } j = 1, 2, \\dots, N\n$$\n所有本征值 $\\mu_j$ 都是实数且为负数。对于稳定性和精度而言，“最差情况”模态是衰减最快的模态，对应于具有最大幅值的本征值。其幅值为 $|\\mu_j| = 4 \\sin^2\\left(\\frac{j\\pi}{2(N+1)}\\right)$，当 $j$ 取最大值，即 $j=N$ 时，该幅值最大。因此，问题中表示为 $\\mu_{\\max}$ 的最差情况本征值是 $\\mu_N$。其幅值为：\n$$\n|\\mu_{\\max}| = |\\mu_N| = 4 \\sin^2\\left(\\frac{N\\pi}{2(N+1)}\\right) = 4 \\cos^2\\left(\\frac{\\pi}{2(N+1)}\\right)\n$$\n\n### 2. Crank-Nicolson 放大因子\n将 Crank-Nicolson 方法应用于标量常微分方程 $\\frac{du}{dt} = \\lambda u$，可得到放大因子 $A = \\frac{1 + \\lambda \\Delta t/2}{1 - \\lambda \\Delta t/2}$。对于半离散系统，矩阵算子的本征值为 $\\lambda_j = \\frac{\\kappa}{\\Delta x^2}\\mu_j$。第 $j$ 个本征模的放大因子为：\n$$\nA_j = \\frac{1 + \\frac{1}{2}\\frac{\\kappa \\mu_j \\Delta t}{\\Delta x^2}}{1 - \\frac{1}{2}\\frac{\\kappa \\mu_j \\Delta t}{\\Delta x^2}} = \\frac{1 + \\frac{1}{2} r \\mu_j}{1 - \\frac{1}{2} r \\mu_j}\n$$\n对于最差情况模态，我们使用 $\\mu_{\\max}$。引入问题中的无量纲衰减参数 $s = r|\\mu_{\\max}| = -r\\mu_{\\max}$，我们可以将最差模态的放大因子 $A_{\\mathrm{CN}}$ 写为：\n$$\nA_{\\mathrm{CN}}(s) = \\frac{1 - s/2}{1 + s/2}\n$$\n\n### 3. 约束分析\n必须通过选择可能的最大 $r$ 来满足两个约束。\n\n**相位误差约束：** 放大因子必须为非负，以防止非物理振荡。\n$$\nA_{\\mathrm{CN}}(s) = \\frac{1 - s/2}{1 + s/2} \\ge 0\n$$\n由于 $s>0$，分母 $1+s/2$ 总是正数。因此，约束简化为 $1-s/2 \\ge 0$，这意味着 $s \\le 2$。这为 $s$ 提供了一个上限，从而也为 $r$ 提供了一个上限：\n$$\ns \\le 2 \\implies r|\\mu_{\\max}| \\le 2 \\implies r \\le \\frac{2}{|\\mu_{\\max}|}\n$$\n令此限制为 $r_{\\text{phase}} = 2/|\\mu_{\\max}|$。\n\n**振幅误差约束：** 最差情况模态的每步相对振幅误差必须受容差 $\\varepsilon_{\\mathrm{amp}}$ 的限制。一个时步内的精确放大因子为 $A_{\\mathrm{exact}} = e^{\\lambda_{\\max} \\Delta t} = e^{\\frac{\\kappa\\mu_{\\max}\\Delta t}{\\Delta x^2}} = e^{r\\mu_{\\max}} = e^{-s}$。相对误差为：\n$$\nE_{\\mathrm{amp}}(s) = \\frac{|A_{\\mathrm{CN}}(s) - A_{\\mathrm{exact}}(s)|}{A_{\\mathrm{exact}}(s)} \\le \\varepsilon_{\\mathrm{amp}}\n$$\n代入放大因子的表达式，我们得到：\n$$\n\\left| \\frac{\\frac{1-s/2}{1+s/2} - e^{-s}}{e^{-s}} \\right| = \\left| \\frac{e^s(1-s/2)}{1+s/2} - 1 \\right| \\le \\varepsilon_{\\mathrm{amp}}\n$$\n对于 $s \\in (0, 2]$，可以证明 $A_{\\mathrm{CN}}(s)  A_{\\mathrm{exact}}(s)$，这意味着数值格式比精确解的耗散性略强。因此，绝对值内的量为负，误差为：\n$$\nE_{\\mathrm{amp}}(s) = 1 - \\frac{e^s(1-s/2)}{1+s/2}\n$$\n对于 $s > 0$，此误差函数 $E_{\\mathrm{amp}}(s)$ 是单调递增的。我们必须找到最大的 $s$（表示为 $s_{\\text{amp}}$），使得 $E_{\\mathrm{amp}}(s_{\\text{amp}}) \\le \\varepsilon_{\\mathrm{amp}}$。由于 $E_{\\mathrm{amp}}$ 是单调的，这等效于求解方程 $E_{\\mathrm{amp}}(s) = \\varepsilon_{\\mathrm{amp}}$ 以得到 $s$。这个超越方程没有简单的解析解，必须通过数值方法求解，例如使用像二分法或 Brent 方法这样的求根算法。这个解 $s_{\\text{amp}}$ 给出了受振幅限制的 $r$ 值，即 $r_{\\text{amp}} = s_{\\text{amp}}/|\\mu_{\\max}|$。\n\n### 4. 时步选择算法\n对于每个测试用例，算法如下：\n1.  计算网格间距 $\\Delta x = L/(N+1)$。\n2.  计算最差情况本征值的幅值 $|\\mu_{\\max}| = 4 \\cos^2(\\frac{\\pi}{2(N+1)})$。\n3.  根据相位约束确定 $s$ 的最大允许值，$s_{\\text{phase}} = 2$。\n4.  在区间 $(0, 2]$ 内数值求解方程 $1 - \\frac{e^s(1-s/2)}{1+s/2} = \\varepsilon_{\\mathrm{amp}}$ 以找到 $s_{\\text{amp}}$。\n5.  选择最严格的限制 $s_{\\max} = \\min(s_{\\text{phase}}, s_{\\text{amp}})$。\n6.  计算最大允许的无量纲参数 $r_{\\max} = s_{\\max} / |\\mu_{\\max}|$。\n7.  计算相应的最大物理时步 $\\Delta t_{\\max} = \\frac{r_{\\max} \\Delta x^2}{\\kappa}$。\n8.  确定覆盖模拟时域 $T$ 所需的时步数 $M$：$M = \\lceil T / \\Delta t_{\\max} \\rceil$。\n9.  计算与时域 $T$ 精确匹配的实际时步：$\\Delta t = T / M$。\n10. 计算模拟中使用的最终无量纲参数：$r_{\\mathrm{final}} = \\frac{\\kappa \\Delta t}{\\Delta x^2}$。\n11. 使用此 $r_{\\mathrm{final}}$，计算最终的有效衰减参数 $s_{\\mathrm{final}} = r_{\\mathrm{final}} |\\mu_{\\max}|$。\n12. 利用 $s_{\\mathrm{final}}$，计算最终的每步相对振幅误差 $E_{\\mathrm{amp,final}} = 1 - \\frac{e^{s_{\\mathrm{final}}}(1-s_{\\mathrm{final}}/2)}{1+s_{\\mathrm{final}}/2}$。\n13. 验证约束条件：\n    - 如果 $s_{\\mathrm{final}} \\le 2$，则满足相位约束。\n    - 如果 $E_{\\mathrm{amp,final}} \\le \\varepsilon_{\\mathrm{amp}}$，则满足振幅约束。由于选择了 $\\Delta t \\le \\Delta t_{\\max}$，两个约束在数学上都将得到满足。布尔检查用于验证。\n14. 报告元组 $(r_{\\mathrm{final}}, M, E_{\\mathrm{amp,final}}, \\text{phase\\_ok}, \\text{amp\\_ok})$。\n\n通过控制最具挑战性的模态的行为，此过程保证了数值模拟对所有可分辨的模态都同时满足精度和非振荡行为的标准。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Solves the Crank-Nicolson time-step calibration problem for several test cases.\n    \"\"\"\n    \n    # Test cases from the problem statement.\n    test_cases = [\n        # (kappa, L, N, T, eps_amp)\n        (1.0e-6, 1.0e5, 100, 1.0e12, 1.0e-3), # Case 1: happy path\n        (1.0e-6, 1.0e5, 100, 1.0e12, 1.0e-6), # Case 2: tight amplitude control\n        (1.0e-6, 1.0e5, 10,  1.0e12, 1.0e-2), # Case 3: coarse grid, moderate amplitude control\n        (1.0e-6, 1.0e5, 100, 1.0e12, 5.0e-1), # Case 4: loose amplitude control, phase-limited\n    ]\n\n    results = []\n    \n    def amplitude_error_func(s, eps_amp):\n        \"\"\"\n        Error function E_amp(s) - eps_amp = 0 to be solved for s.\n        E_amp(s) = 1 - (e^s * (1 - s/2)) / (1 + s/2)\n        \"\"\"\n        # Handle s=0 case to avoid division by zero if ever used, although s>0 is expected.\n        if s == 0:\n            return -eps_amp\n        # The equation to solve is E_amp(s) = eps_amp\n        return 1.0 - (np.exp(s) * (1.0 - s / 2.0)) / (1.0 + s / 2.0) - eps_amp\n\n    for case in test_cases:\n        kappa, L, N, T, eps_amp = case\n        \n        # 1. Calculate grid spacing\n        delta_x = L / (N + 1.0)\n        \n        # 2. Calculate the worst-mode eigenvalue magnitude\n        mu_max_mag = 4.0 * np.cos(np.pi / (2.0 * (N + 1.0)))**2\n        \n        # 3. Phase constraint: s_phase_limit = 2\n        s_phase_limit = 2.0\n        \n        # 4. Amplitude constraint: solve for s_amp_limit\n        # The root must be in (0, 2]. Using a small positive number for the lower bound.\n        # If eps_amp is large (>=1), a root might not exist in (0, 2).\n        # E_amp at s=2 is 1. For eps_amp  1, a root exists in (0, 2).\n        if eps_amp >= 1.0:\n            # The error can never reach this value below the phase limit\n            s_amp_limit = s_phase_limit\n        else:\n            # Use brentq to find the root of amplitude_error_func\n            try:\n                s_amp_limit = optimize.brentq(amplitude_error_func, 1e-12, s_phase_limit, args=(eps_amp,))\n            except ValueError:\n                # If f(a)*f(b) > 0, brentq fails. This can happen if eps_amp is\n                # very small and our lower bound is already too high. Retry with 0.\n                s_amp_limit = optimize.brentq(amplitude_error_func, 0, s_phase_limit, args=(eps_amp,))\n            \n        # 5. The most restrictive s is the minimum of the two limits\n        s_max = min(s_phase_limit, s_amp_limit)\n        \n        # 6. Calculate max allowed r\n        r_max = s_max / mu_max_mag\n        \n        # 7. Compute max physical time step\n        delta_t_max = (r_max * delta_x**2) / kappa\n        \n        # 8. Determine number of steps M\n        if delta_t_max = 0: # Avoid division by zero if T is large and dt_max is tiny/zero\n             M = int(1e18) # A huge number, effectively not stepping.\n        else:\n             M = int(np.ceil(T / delta_t_max))\n\n        # 9. Calculate actual time step dt\n        delta_t = T / M\n        \n        # 10. Compute final non-dimensional parameter\n        r_final = (kappa * delta_t) / delta_x**2\n        \n        # 11. Calculate final decay parameter s_final\n        s_final = r_final * mu_max_mag\n        \n        # 12. Compute final amplitude error\n        # Use amplitude_error_func(s_final, 0) which is just E_amp(s_final)\n        E_amp_final = amplitude_error_func(s_final, 0.0)\n        \n        # 13. Verify constraints\n        phase_ok = (s_final = 2.0)\n        # Add a small tolerance for floating point comparison\n        amp_ok = (E_amp_final = eps_amp * (1.0 + 1e-9) or np.isclose(E_amp_final, eps_amp))\n        \n        # 14. Store results\n        # Format: r_final (float), M (integer), E_amp_final (float), phase_ok (bool), amp_ok (bool)\n        results.append([r_final, M, E_amp_final, phase_ok, amp_ok])\n\n    # Format the final output string exactly as specified.\n    # e.g., '[[r1,M1,E1,P1,A1],[r2,M2,E2,P2,A2]]'\n    sub_results_str = [f\"[{r:.6f},{m},{e:.6e},{str(p).lower()},{str(a).lower()}]\" for r, m, e, p, a in results]\n    final_output_str = f\"[{','.join(sub_results_str)}]\"\n    \n    print(final_output_str)\n\n# The original problem asked for a slightly different output format without lowercase booleans.\n# The following code block adheres to the original prompt's implicit format.\n\ndef solve_original_format():\n    \"\"\"\n    Solves the Crank-Nicolson time-step calibration problem for several test cases\n    and formats the output as implicitly defined by the Python code in the prompt.\n    \"\"\"\n    \n    test_cases = [\n        # (kappa, L, N, T, eps_amp)\n        (1.0e-6, 1.0e5, 100, 1.0e12, 1.0e-3), # Case 1\n        (1.0e-6, 1.0e5, 100, 1.0e12, 1.0e-6), # Case 2\n        (1.0e-6, 1.0e5, 10,  1.0e12, 1.0e-2), # Case 3\n        (1.0e-6, 1.0e5, 100, 1.0e12, 5.0e-1), # Case 4\n    ]\n\n    results = []\n    \n    def amplitude_error_func(s, eps_amp):\n        if s == 0: return -eps_amp\n        return 1.0 - (np.exp(s) * (1.0 - s / 2.0)) / (1.0 + s / 2.0) - eps_amp\n\n    for case in test_cases:\n        kappa, L, N, T, eps_amp = case\n        \n        delta_x = L / (N + 1.0)\n        mu_max_mag = 4.0 * np.cos(np.pi / (2.0 * (N + 1.0)))**2\n        s_phase_limit = 2.0\n        \n        if eps_amp >= 1.0:\n            s_amp_limit = s_phase_limit\n        else:\n            try:\n                s_amp_limit = optimize.brentq(amplitude_error_func, 1e-12, s_phase_limit, args=(eps_amp,))\n            except ValueError:\n                s_amp_limit = optimize.brentq(amplitude_error_func, 0, s_phase_limit, args=(eps_amp,))\n\n        s_max = min(s_phase_limit, s_amp_limit)\n        r_max = s_max / mu_max_mag\n        delta_t_max = (r_max * delta_x**2) / kappa\n        \n        if delta_t_max = 0:\n             M = int(1e18)\n        else:\n             M = int(np.ceil(T / delta_t_max))\n\n        delta_t = T / M\n        r_final = (kappa * delta_t) / delta_x**2\n        s_final = r_final * mu_max_mag\n        E_amp_final = amplitude_error_func(s_final, 0.0)\n        \n        phase_ok = (s_final = 2.0)\n        amp_ok = (E_amp_final = eps_amp * (1.0 + 1e-9) or np.isclose(E_amp_final, eps_amp))\n        \n        results.append([r_final, M, E_amp_final, phase_ok, amp_ok])\n\n    sub_results_str = [f\"[{r},{m},{e},{str(p)},{str(a)}]\" for r, m, e, p, a in results]\n    final_output_str = f\"[{','.join(sub_results_str)}]\"\n    \n    print(final_output_str)\n\nsolve_original_format()\n```"
        }
    ]
}