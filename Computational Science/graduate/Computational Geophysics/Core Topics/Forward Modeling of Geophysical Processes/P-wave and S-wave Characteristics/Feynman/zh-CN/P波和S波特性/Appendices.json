{
    "hands_on_practices": [
        {
            "introduction": "地震波最基本的特征是其传播速度，它直接关联到介质的物理性质。本练习将抽象的波速概念与材料的实际物理属性（拉梅参数$ \\lambda $、$ \\mu $和密度$ \\rho $)联系起来，帮助你从第一性原理推导这些关系，并对计算结果进行基本的物理合理性检查。这项基础练习是理解P波和S波行为的起点。",
            "id": "3612495",
            "problem": "考虑一块理想化为均匀、各向同性、线性弹性连续体的结晶岩石。令柯西应力张量通过各向同性材料的胡克定律与无穷小应变张量相关联，并令线性动量平衡在无体力情况下成立。给定岩石的拉梅参数 $\\lambda$ 和 $\\mu$ 以及质量密度 $\\rho$：$\\lambda = 20$ GPa，$\\mu = 30$ GPa，$\\rho = 2500$ kg/m$^3$。从弹性动力学的基本场方程和各向同性弹性的本构定律出发，推导从位移场中出现的膨胀（主波，P波）和剪切（次波，S波）波模的相速度。利用这些结果，计算给定参数下P波速度 $v_{p}$、S波速度 $v_{s}$ 以及它们的比值 $v_{p}/v_{s}$ 的数值。将 $v_{p}$ 和 $v_{s}$ 以米/秒（m/s）表示，将 $v_{p}/v_{s}$ 表示为无量纲小数，并将这三个量均四舍五入到四位有效数字。最后，通过讨论稳定性约束和典型的性质范围，评估计算出的值对于结晶岩石是否物理上合理。",
            "solution": "该问题要求在均匀、各向同性、线性弹性连续体中推导膨胀（P）波和剪切（S）波的相速度，然后进行数值计算和合理性评估。\n\n控制弹性介质动力学的基本场方程是线性动量平衡和本构关系。在没有体力的情况下，线性动量平衡（柯西第一运动定律）由下式给出：\n$$ \\nabla \\cdot \\boldsymbol{\\sigma} = \\rho \\frac{\\partial^2 \\mathbf{u}}{\\partial t^2} $$\n在笛卡尔指标表示法中，此式为：\n$$ \\frac{\\partial \\sigma_{ij}}{\\partial x_j} = \\rho \\frac{\\partial^2 u_i}{\\partial t^2} $$\n其中 $\\boldsymbol{\\sigma}$ 是柯西应力张量，$\\mathbf{u}$ 是位移矢量，$\\rho$ 是质量密度，$t$ 是时间。\n\n均匀、各向同性、线性弹性材料的本构关系是胡克定律，它将应力张量 $\\sigma_{ij}$ 与无穷小应变张量 $\\epsilon_{ij}$ 相关联：\n$$ \\sigma_{ij} = \\lambda \\epsilon_{kk} \\delta_{ij} + 2\\mu \\epsilon_{ij} $$\n这里，$\\lambda$ 和 $\\mu$ 是拉梅参数，$\\delta_{ij}$ 是克罗内克δ。应变张量通过以下方式与位移场相关：\n$$ \\epsilon_{ij} = \\frac{1}{2} \\left( \\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i} \\right) $$\n应变张量的迹 $\\epsilon_{kk}$ 代表体积应变（膨胀），由 $\\epsilon_{kk} = \\nabla \\cdot \\mathbf{u}$ 给出。\n\n为了推导波动方程，我们首先将应变-位移关系代入胡克定律，用位移表示应力：\n$$ \\sigma_{ij} = \\lambda (\\nabla \\cdot \\mathbf{u}) \\delta_{ij} + \\mu \\left( \\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i} \\right) $$\n接下来，我们将这个应力表达式代入运动方程：\n$$ \\rho \\frac{\\partial^2 u_i}{\\partial t^2} = \\frac{\\partial}{\\partial x_j} \\left[ \\lambda (\\nabla \\cdot \\mathbf{u}) \\delta_{ij} + \\mu \\left( \\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i} \\right) \\right] $$\n$$ \\rho \\frac{\\partial^2 u_i}{\\partial t^2} = \\lambda \\frac{\\partial}{\\partial x_i} (\\nabla \\cdot \\mathbf{u}) + \\mu \\frac{\\partial^2 u_i}{\\partial x_j \\partial x_j} + \\mu \\frac{\\partial}{\\partial x_j} \\left( \\frac{\\partial u_j}{\\partial x_i} \\right) $$\n重新排列最后一项的微分顺序，我们得到：\n$$ \\rho \\frac{\\partial^2 u_i}{\\partial t^2} = \\lambda \\frac{\\partial}{\\partial x_i} (\\nabla \\cdot \\mathbf{u}) + \\mu \\nabla^2 u_i + \\mu \\frac{\\partial}{\\partial x_i} \\left( \\frac{\\partial u_j}{\\partial x_j} \\right) $$\n$$ \\rho \\frac{\\partial^2 u_i}{\\partial t^2} = (\\lambda + \\mu) \\frac{\\partial}{\\partial x_i} (\\nabla \\cdot \\mathbf{u}) + \\mu \\nabla^2 u_i $$\n这就是弹性动力学的纳维-柯西方程。以矢量形式表示为：\n$$ \\rho \\frac{\\partial^2 \\mathbf{u}}{\\partial t^2} = (\\lambda + \\mu) \\nabla(\\nabla \\cdot \\mathbf{u}) + \\mu \\nabla^2 \\mathbf{u} $$\n为了将其分离成 P 波和 S 波方程，我们使用亥姆霍兹分解，它将位移矢量场 $\\mathbf{u}$ 分解为一个无旋分量和一个无散分量之和：\n$$ \\mathbf{u} = \\nabla \\phi + \\nabla \\times \\boldsymbol{\\psi} $$\n其中 $\\phi$ 是一个标量势，$\\boldsymbol{\\psi}$ 是一个矢量势。求 $\\mathbf{u}$ 的散度和旋度：\n$$ \\nabla \\cdot \\mathbf{u} = \\nabla \\cdot (\\nabla \\phi) + \\nabla \\cdot (\\nabla \\times \\boldsymbol{\\psi}) = \\nabla^2 \\phi $$\n$$ \\nabla \\times \\mathbf{u} = \\nabla \\times (\\nabla \\phi) + \\nabla \\times (\\nabla \\times \\boldsymbol{\\psi}) = \\nabla(\\nabla \\cdot \\boldsymbol{\\psi}) - \\nabla^2 \\boldsymbol{\\psi} $$\n通过将分解代入纳维-柯西方程，并使用矢量恒等式 $\\nabla^2 \\mathbf{u} = \\nabla(\\nabla \\cdot \\mathbf{u}) - \\nabla \\times (\\nabla \\times \\mathbf{u})$，我们得到：\n$$ \\rho \\frac{\\partial^2}{\\partial t^2}(\\nabla \\phi + \\nabla \\times \\boldsymbol{\\psi}) = (\\lambda + 2\\mu) \\nabla(\\nabla^2 \\phi) - \\mu \\nabla \\times (\\nabla \\times (\\nabla \\times \\boldsymbol{\\psi})) $$\n我们可以为 $\\boldsymbol{\\psi}$ 设定规范，使得 $\\nabla \\cdot \\boldsymbol{\\psi} = 0$。方程变为：\n$$ \\rho \\nabla \\left( \\frac{\\partial^2 \\phi}{\\partial t^2} \\right) + \\rho \\nabla \\times \\left( \\frac{\\partial^2 \\boldsymbol{\\psi}}{\\partial t^2} \\right) = (\\lambda + 2\\mu) \\nabla (\\nabla^2 \\phi) + \\mu \\nabla \\times (\\nabla^2 \\boldsymbol{\\psi}) $$\n通过对梯度项和旋度项进行分组，该方程可以分离为两个独立的方程：\n$$ \\nabla \\left[ (\\lambda + 2\\mu) \\nabla^2 \\phi - \\rho \\frac{\\partial^2 \\phi}{\\partial t^2} \\right] - \\nabla \\times \\left[ \\mu \\nabla^2 \\boldsymbol{\\psi} - \\rho \\frac{\\partial^2 \\boldsymbol{\\psi}}{\\partial t^2} \\right] = \\mathbf{0} $$\n为使此式成立，两个方括号内的项必须独立为零（标量势可相差一个时间函数，该函数可被吸收到其定义中）。\n\n第一个方程，控制标量势 $\\phi$，是：\n$$ \\frac{\\partial^2 \\phi}{\\partial t^2} = \\frac{\\lambda + 2\\mu}{\\rho} \\nabla^2 \\phi $$\n这是一个标准的波动方程，描述了以相速度 $v_p$ 传播的波。该波对应于膨胀波，或P波（主波），其速度为：\n$$ v_p = \\sqrt{\\frac{\\lambda + 2\\mu}{\\rho}} $$\n第二个方程，控制矢量势 $\\boldsymbol{\\psi}$，是：\n$$ \\frac{\\partial^2 \\boldsymbol{\\psi}}{\\partial t^2} = \\frac{\\mu}{\\rho} \\nabla^2 \\boldsymbol{\\psi} $$\n这是一个矢量波动方程，描述了以相速度 $v_s$ 传播的波。该波对应于剪切波，或S波（次波），其速度为：\n$$ v_s = \\sqrt{\\frac{\\mu}{\\rho}} $$\n现在，我们使用给定参数计算数值：$\\lambda = 20$ GPa, $\\mu = 30$ GPa, and $\\rho = 2500$ kg/m$^3$。我们必须使用国际单位制（SI），所以 $1 \\text{ GPa} = 10^9 \\text{ N/m}^2 = 10^9 \\text{ kg} \\cdot \\text{m}^{-1} \\cdot \\text{s}^{-2}$。\n\nP波速度为：\n$$ v_p = \\sqrt{\\frac{20 \\times 10^9 \\text{ Pa} + 2 \\times (30 \\times 10^9 \\text{ Pa})}{2500 \\text{ kg/m}^3}} = \\sqrt{\\frac{80 \\times 10^9}{2500}} \\text{ m/s} = \\sqrt{32 \\times 10^6} \\text{ m/s} $$\n$$ v_p = 5656.85... \\text{ m/s} $$\n四舍五入到四位有效数字，$v_p = 5657$ m/s。\n\nS波速度为：\n$$ v_s = \\sqrt{\\frac{30 \\times 10^9 \\text{ Pa}}{2500 \\text{ kg/m}^3}} = \\sqrt{\\frac{300 \\times 10^8}{2500}} \\text{ m/s} = \\sqrt{12 \\times 10^6} \\text{ m/s} $$\n$$ v_s = 3464.10... \\text{ m/s} $$\n四舍五入到四位有效数字，$v_s = 3464$ m/s。\n\nP波速度与S波速度之比为：\n$$ \\frac{v_p}{v_s} = \\frac{\\sqrt{(\\lambda + 2\\mu)/\\rho}}{\\sqrt{\\mu/\\rho}} = \\sqrt{\\frac{\\lambda + 2\\mu}{\\mu}} = \\sqrt{\\frac{\\lambda}{\\mu} + 2} $$\n$$ \\frac{v_p}{v_s} = \\sqrt{\\frac{20 \\text{ GPa}}{30 \\text{ GPa}} + 2} = \\sqrt{\\frac{2}{3} + 2} = \\sqrt{\\frac{8}{3}} $$\n$$ \\frac{v_p}{v_s} = 1.63299... $$\n四舍五入到四位有效数字，$v_p/v_s = 1.633$。\n\n最后，我们评估这些结果的物理合理性。\n为了使弹性材料稳定，应变能密度必须是正定的。对于各向同性材料，这对拉梅参数施加了约束，即 $\\mu > 0$ 和体积模量 $K = \\lambda + \\frac{2}{3}\\mu > 0$。给定参数为 $\\mu = 30 \\text{ GPa} > 0$ 和 $K = 20 + \\frac{2}{3}(30) = 40 \\text{ GPa} > 0$。稳定性条件得到满足。这些条件确保了波速 $v_p$ 和 $v_s$ 是实数且为正。\n计算出的P波速度 $5657$ m/s 和S波速度 $3464$ m/s 处于结晶岩石（如花岗岩）的典型范围内（其中 $v_p \\approx 5.5-6.5$ km/s and $v_s \\approx 3.0-3.8$ km/s）。\n比值 $v_p/v_s \\approx 1.633$ 在物理上也是合理的。该比值取决于泊松比 $\\nu = \\frac{\\lambda}{2(\\lambda+\\mu)}$。对于给定值，$\\nu = \\frac{20}{2(20+30)} = 0.2$。常见岩石的泊松比在 $0.1$ 到 $0.4$ 之间。$0.2$ 这个值非常典型。作为比较，泊松比 $\\nu=0.25$ 会得到一个常见的基准比值 $v_p/v_s = \\sqrt{3} \\approx 1.732$。我们计算出的比值 $1.633$ 与泊松比略小于 $0.25$ 的材料相符。因此，计算出的值对于指定的材料是物理上合理的。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 5657  3464  1.633 \\end{pmatrix} } $$"
        },
        {
            "introduction": "波动方程的数值模拟是计算地球物理学的基石。然而，在离散网格上求解波动方程会引入数值误差，其中数值频散是最主要的问题之一。本练习将深入探讨不同的数值格式（如不同阶数的有限差分）如何影响模拟波速的准确性，这是开发和使用模拟代码时必须掌握的关键技能。",
            "id": "3612540",
            "problem": "您的任务是使用有限差分（FD）空间离散化方法，对均匀、各向同性弹性介质中的P波（纵波）和S波（横波）进行一次基于原理的数值频散分析。从各向同性弹性波方程和用于分离P波和S波势的 Helmholtz 分解出发。使用二阶和四阶中心差分处理空间离散化，同时保持时间连续（半离散分析）。推导这些 FD 拉普拉斯算子的离散空间傅里叶符号，并获得平面波的半离散频散关系 $\\,\\omega(\\mathbf{k})\\,$。利用该关系，计算在选定的传播方向上，每个波长 $\\,10\\,$ 个采样点时的相速度误差。\n\n使用的基本原理：\n- 牛顿第二定律和线性各向同性弹性理论，导出 Navier 方程，以及将位移场分解为P波和S波势的 Helmholtz 分解。\n- 在均匀介质中，使用波矢量为 $\\,\\mathbf{k}\\,$ 的平面波拟设。\n- 在间距为 $\\,h\\,$ 的笛卡尔网格上，使用二阶和四阶中心差分格式来近似拉普拉斯算子 $\\,\\nabla^{2}\\,$。\n\n具体要求：\n1. 从各向同性线性弹性方程出发，使用 Helmholtz 分解证明标量P波势 $\\,\\phi\\,$ 和矢量S波势 $\\,\\boldsymbol{\\psi}\\,$ 满足标量波动方程 $\\,\\partial^{2}\\phi/\\partial t^{2} = \\alpha^{2}\\,\\nabla^{2}\\phi\\,$ 和 $\\,\\partial^{2}\\boldsymbol{\\psi}/\\partial t^{2} = \\beta^{2}\\,\\nabla^{2}\\boldsymbol{\\psi}\\,$，其中 $\\,\\alpha\\,$ 和 $\\,\\beta\\,$ 分别是P波和S波的波速。\n2. 仅使用拉普拉斯算子 $\\,\\nabla^{2}\\,$ 的中心差分近似对空间进行离散化：\n   - 二阶精度格式。\n   - 四阶精度格式。\n   假设每个坐标方向上的均匀笛卡尔网格间距为 $\\,h\\,$，且周期性足以进行空间傅里叶分析。\n3. 对于平面波 $\\,\\exp\\!\\left(i(\\mathbf{k}\\cdot\\mathbf{x}-\\omega t)\\right)\\,$，推导每种差分格式的半离散频散关系 $\\,\\omega(\\mathbf{k})\\,$。用 FD 拉普拉斯算子的离散傅里叶符号和波速 $\\,c\\,$ 来表示此关系，其中对于P波 $\\,c=\\alpha\\,$，对于S波 $\\,c=\\beta\\,$。\n4. 将相速度定义为 $\\,c_{\\mathrm{ph}}(\\mathbf{k})=\\omega(\\mathbf{k})/\\lVert\\mathbf{k}\\rVert\\,$。将相对相速度误差定义为 $\\,\\varepsilon = c_{\\mathrm{ph}}/c - 1\\,$。以无量纲的小数形式报告误差。\n5. 使用以下测试套件，每个测试在每个波长 $\\,10\\,$ 个点（PPW）的条件下进行。设 PPW 为 $\\,N=10\\,$，无量纲波数大小与网格间距的乘积为 $\\,\\theta = 2\\pi/N\\,$。不失一般性地使用 $\\,h=1\\,$。对于每种情况，分别对P波和S波，以及二阶和四阶空间格式进行评估：\n   - 测试 A（一维，轴对齐）：空间维度 $\\,d=1\\,$，方向 $\\,\\hat{\\mathbf{d}}=[1]$，因此 $\\,\\mathbf{k}=k\\,\\hat{\\mathbf{d}}\\,$ 且 $\\,\\theta = kh\\,$。\n   - 测试 B（二维，轴对齐）：空间维度 $\\,d=2\\,$，方向 $\\,\\hat{\\mathbf{d}}=[1,0]$。\n   - 测试 C（二维，对角线方向）：空间维度 $\\,d=2\\,$，方向 $\\,\\hat{\\mathbf{d}}=\\left[\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right]$。\n   在所有情况下，使用 $\\,N=10\\,$，因此 $\\,\\theta = 2\\pi/10\\,$，并且对于坐标索引 $\\,a\\,$，分量形式的无量纲波数为 $\\,\\theta_{a} = \\theta \\,\\hat{d}_{a}\\,$。\n6. 您的程序应计算每个测试用例的相对相速度误差 $\\,\\varepsilon\\,$，包括：\n   - 使用二阶格式的P波。\n   - 使用四阶格式的P波。\n   - 使用二阶格式的S波。\n   - 使用四阶格式的S波。\n   将结果汇总为以下单行输出格式，即一个用方括号括起来的逗号分隔列表：\n   [$\\varepsilon_{\\mathrm{P},2,\\mathrm{A}}$,$\\varepsilon_{\\mathrm{P},4,\\mathrm{A}}$,$\\varepsilon_{\\mathrm{S},2,\\mathrm{A}}$,$\\varepsilon_{\\mathrm{S},4,\\mathrm{A}}$,$\\varepsilon_{\\mathrm{P},2,\\mathrm{B}}$,$\\varepsilon_{\\mathrm{P},4,\\mathrm{B}}$,$\\varepsilon_{\\mathrm{S},2,\\mathrm{B}}$,$\\varepsilon_{\\mathrm{S},4,\\mathrm{B}}$,$\\varepsilon_{\\mathrm{P},2,\\mathrm{C}}$,$\\varepsilon_{\\mathrm{P},4,\\mathrm{C}}$,$\\varepsilon_{\\mathrm{S},2,\\mathrm{C}}$,$\\varepsilon_{\\mathrm{S},4,\\mathrm{C}}$]\n   其中下标 $\\,\\mathrm{P}$ 或 $\\,\\mathrm{S}\\,$ 表示波类型，$\\,2\\,$ 或 $\\,4\\,$ 表示格式阶数，$\\,\\mathrm{A},\\mathrm{B},\\mathrm{C}\\,$ 表示上述测试用例。\n7. 角度以弧度为单位。无需报告物理单位，因为所要求的输出是无量纲的相对误差。\n\n您的最终答案必须是一个完整、可运行的程序，该程序能精确地生成上述单行输出，其中包含与指定的、每个波长 $\\,10\\,$ 个采样点的测试套件相对应的 $\\,12\\,$ 个条目的数值。",
            "solution": "用户提供了一个有效的问题陈述。任务是使用有限差分法对P波和S波进行数值频散分析。我们将从第一性原理推导必要的关系，然后将其应用于指定的测试用例。\n\n### 第1部分：P波和S波方程的推导\n\n均匀、各向同性、线性弹性介质中的运动由 Navier 方程支配，该方程结合了牛顿第二定律和线性弹性的本构关系：\n$$\n\\rho \\frac{\\partial^2 \\mathbf{u}}{\\partial t^2} = (\\lambda + \\mu) \\nabla(\\nabla \\cdot \\mathbf{u}) + \\mu \\nabla^2 \\mathbf{u}\n$$\n其中 $\\mathbf{u}$ 是位移矢量，$\\rho$ 是密度，$\\lambda$ 和 $\\mu$ 是 Lamé 参数。\n\n使用 Helmholtz 分解，位移矢量场 $\\mathbf{u}$ 可以表示为一个标量势 $\\phi$（P波势）的梯度和一个矢量势 $\\boldsymbol{\\psi}$（S波势）的旋度之和：\n$$\n\\mathbf{u} = \\nabla\\phi + \\nabla \\times \\boldsymbol{\\psi}\n$$\n如果我们施加规范条件，即S波势是无散度的（$\\nabla \\cdot \\boldsymbol{\\psi} = 0$），则此分解是唯一的。\n\n将此分解代入 Navier 方程，我们首先计算 $\\mathbf{u}$ 的散度和拉普拉斯算子：\n$$\n\\nabla \\cdot \\mathbf{u} = \\nabla \\cdot (\\nabla\\phi + \\nabla \\times \\boldsymbol{\\psi}) = \\nabla^2\\phi + \\nabla \\cdot (\\nabla \\times \\boldsymbol{\\psi}) = \\nabla^2\\phi\n$$\n因为旋度的散度恒为零。\n$$\n\\nabla^2\\mathbf{u} = \\nabla^2(\\nabla\\phi + \\nabla \\times \\boldsymbol{\\psi}) = \\nabla(\\nabla^2\\phi) + \\nabla \\times (\\nabla^2\\boldsymbol{\\psi})\n$$\nNavier 方程的左侧变为：\n$$\n\\rho \\frac{\\partial^2 \\mathbf{u}}{\\partial t^2} = \\rho \\frac{\\partial^2}{\\partial t^2}(\\nabla\\phi + \\nabla \\times \\boldsymbol{\\psi}) = \\rho \\nabla\\left(\\frac{\\partial^2\\phi}{\\partial t^2}\\right) + \\rho \\nabla \\times \\left(\\frac{\\partial^2\\boldsymbol{\\psi}}{\\partial t^2}\\right)\n$$\n将这些表达式代回 Navier 方程得到：\n$$\n\\rho \\nabla\\left(\\frac{\\partial^2\\phi}{\\partial t^2}\\right) + \\rho \\nabla \\times \\left(\\frac{\\partial^2\\boldsymbol{\\psi}}{\\partial t^2}\\right) = (\\lambda + \\mu) \\nabla(\\nabla^2\\phi) + \\mu \\left( \\nabla(\\nabla^2\\phi) + \\nabla \\times (\\nabla^2\\boldsymbol{\\psi}) \\right)\n$$\n将带有梯度和旋度算子的项分组：\n$$\n\\nabla\\left[\\rho \\frac{\\partial^2\\phi}{\\partial t^2} - (\\lambda + 2\\mu)\\nabla^2\\phi\\right] + \\nabla \\times \\left[\\rho \\frac{\\partial^2\\boldsymbol{\\psi}}{\\partial t^2} - \\mu\\nabla^2\\boldsymbol{\\psi}\\right] = \\mathbf{0}\n$$\n为使此方程对任意波场成立，方括号中的项必须为零。这将方程分离为两个解耦的波动方程：\n$$\n\\frac{\\partial^2\\phi}{\\partial t^2} = \\frac{\\lambda + 2\\mu}{\\rho} \\nabla^2\\phi \\quad \\text{和} \\quad \\frac{\\partial^2\\boldsymbol{\\psi}}{\\partial t^2} = \\frac{\\mu}{\\rho} \\nabla^2\\boldsymbol{\\psi}\n$$\n定义P波速度 $\\alpha = \\sqrt{(\\lambda+2\\mu)/\\rho}$ 和S波速度 $\\beta = \\sqrt{\\mu/\\rho}$，我们得到势的标准标量和矢量波动方程：\n$$\n\\frac{\\partial^2\\phi}{\\partial t^2} = \\alpha^2 \\nabla^2\\phi \\quad \\text{(P波方程)}\n$$\n$$\n\\frac{\\partial^2\\boldsymbol{\\psi}}{\\partial t^2} = \\beta^2 \\nabla^2\\boldsymbol{\\psi} \\quad \\text{(S波方程)}\n$$\n这两个方程都具有 $\\frac{\\partial^2 f}{\\partial t^2} = c^2 \\nabla^2 f$ 的形式，其中 $c$ 是波速（$\\alpha$ 或 $\\beta$）。\n\n### 第2部分：半离散频散分析\n\n我们分析标量波动方程 $\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u$。我们对空间进行离散化，但不对时间进行离散化（半离散化）。在所有 $d$ 个维度上间距均为 $h$ 的均匀笛卡尔网格上，拉普拉斯算子 $\\nabla^2$ 由离散算子 $\\nabla_h^2$ 近似。半离散方程为：\n$$\n\\frac{d^2 u_{\\mathbf{j}}}{dt^2} = c^2 \\nabla_h^2 u_{\\mathbf{j}}\n$$\n其中 $\\mathbf{j}$ 是网格点的多重索引。\n\n我们通过代入平面波拟设 $u(\\mathbf{x}, t) = e^{i(\\mathbf{k} \\cdot \\mathbf{x} - \\omega t)}$ 来探究该系统的频散特性，其中 $\\mathbf{k}$ 是波矢量，$\\omega$ 是角频率。在网格点 $\\mathbf{x}_{\\mathbf{j}}$ 处，平面波为 $u_{\\mathbf{j}}(t) = e^{i(\\mathbf{k} \\cdot \\mathbf{x}_{\\mathbf{j}} - \\omega t)}$。\n应用时间导数和离散空间算子：\n$$\n(-i\\omega)^2 e^{i(\\mathbf{k} \\cdot \\mathbf{x}_{\\mathbf{j}} - \\omega t)} = c^2 \\nabla_h^2 e^{i(\\mathbf{k} \\cdot \\mathbf{x}_{\\mathbf{j}} - \\omega t)}\n$$\n像 $\\nabla_h^2$ 这样的线性、位移不变离散算子作用于离散平面波 $e^{i\\mathbf{k} \\cdot \\mathbf{x}_{\\mathbf{j}}}$ 的效果是乘法性的。它引入一个称为算子傅里叶符号的因子，记为 $\\hat{\\nabla}_h^2(\\mathbf{k})$：\n$$\n\\nabla_h^2 e^{i\\mathbf{k} \\cdot \\mathbf{x}_{\\mathbf{j}}} = \\hat{\\nabla}_h^2(\\mathbf{k}) e^{i\\mathbf{k} \\cdot \\mathbf{x}_{\\mathbf{j}}}\n$$\n因此，该方程成为一个代数关系：\n$$\n-\\omega^2 = c^2 \\hat{\\nabla}_h^2(\\mathbf{k})\n$$\n这给出了半离散频散关系：\n$$\n\\omega(\\mathbf{k}) = c \\sqrt{-\\hat{\\nabla}_h^2(\\mathbf{k})}\n$$\n数值相速度为 $c_{\\mathrm{ph}}(\\mathbf{k}) = \\omega(\\mathbf{k}) / \\|\\mathbf{k}\\|$。在连续情况下，$\\omega = c\\|\\mathbf{k}\\|$，所以 $c_{\\mathrm{ph}} = c$。数值近似引入了 $c_{\\mathrm{ph}}$ 对 $\\mathbf{k}$ 的依赖性，这种效应称为数值频散。\n\n### 第3部分：有限差分拉普拉斯算子的傅里叶符号\n\n设 $\\theta_a = k_a h$ 为坐标方向 $a$ 上的无量纲波数。离散拉普拉斯算子是一维二阶导数算子之和，$\\nabla_h^2 = \\sum_{a=1}^d \\delta_{aa,h}^2$。\n\n**二阶格式：**\n一维二阶中心差分算子为 $\\delta_{xx,h}^2 u(x) = \\frac{u(x+h) - 2u(x) + u(x-h)}{h^2}$。通过将其应用于 $e^{ik_x x}$ 可以找到其符号：\n$$\n\\hat{\\delta}_{xx,h}^2(k_x) = \\frac{e^{ik_x h} - 2 + e^{-ik_x h}}{h^2} = \\frac{2\\cos(k_x h) - 2}{h^2} = -\\frac{4}{h^2}\\sin^2\\left(\\frac{k_x h}{2}\\right)\n$$\n对于 $d$ 维网格，拉普拉斯算子的符号是各维度上的总和：\n$$\n\\hat{\\nabla}_{h,2}^2(\\mathbf{k}) = \\sum_{a=1}^d \\left( -\\frac{4}{h^2}\\sin^2\\left(\\frac{k_a h}{2}\\right) \\right) = -\\frac{4}{h^2} \\sum_{a=1}^d \\sin^2\\left(\\frac{\\theta_a}{2}\\right)\n$$\n\n**四阶格式：**\n一维四阶中心差分算子为 $\\delta_{xx,h}^2 u(x) = \\frac{-u(x+2h) + 16u(x+h) - 30u(x) + 16u(x-h) - u(x-2h)}{12h^2}$。其符号为：\n$$\n\\hat{\\delta}_{xx,h}^2(k_x) = \\frac{-e^{i2k_x h} + 16e^{ik_x h} - 30 + 16e^{-ik_x h} - e^{-i2k_x h}}{12h^2} = \\frac{-2\\cos(2k_x h) + 32\\cos(k_x h) - 30}{12h^2}\n$$\n$d$ 维拉普拉斯算子的符号为：\n$$\n\\hat{\\nabla}_{h,4}^2(\\mathbf{k}) = \\sum_{a=1}^d \\frac{-2\\cos(2\\theta_a) + 32\\cos(\\theta_a) - 30}{12h^2}\n$$\n\n### 第4部分：相速度误差计算\n\n相对相速度误差定义为 $\\varepsilon = c_{\\mathrm{ph}}/c - 1$。\n$$\n\\varepsilon = \\frac{\\omega(\\mathbf{k})}{c \\|\\mathbf{k}\\|} - 1 = \\frac{\\sqrt{-\\hat{\\nabla}_h^2(\\mathbf{k})}}{\\|\\mathbf{k}\\|} - 1\n$$\n设 $\\|\\boldsymbol{\\theta}\\| = \\sqrt{\\sum \\theta_a^2} = \\sqrt{\\sum (k_a h)^2} = h\\|\\mathbf{k}\\|$。\n$$\n\\varepsilon = \\frac{h \\sqrt{-\\hat{\\nabla}_h^2(\\boldsymbol{\\theta})}}{\\|\\boldsymbol{\\theta}\\|} - 1\n$$\n此误差与物理波速 $c$ 无关，因此对于P波和S波是相同的。\n\n**对于二阶格式：**\n$$\n\\varepsilon_2 = \\frac{h \\sqrt{\\frac{4}{h^2} \\sum_{a=1}^d \\sin^2(\\frac{\\theta_a}{2})}}{\\|\\boldsymbol{\\theta}\\|} - 1 = \\frac{2 \\sqrt{\\sum_{a=1}^d \\sin^2(\\frac{\\theta_a}{2})}}{\\|\\boldsymbol{\\theta}\\|} - 1\n$$\n\n**对于四阶格式：**\n$$\n-\\hat{\\nabla}_{h,4}^2(\\mathbf{k}) = \\frac{1}{12h^2} \\sum_{a=1}^d (30 - 32\\cos(\\theta_a) + 2\\cos(2\\theta_a))\n$$\n$$\n\\varepsilon_4 = \\frac{h \\sqrt{\\frac{1}{12h^2} \\sum_{a=1}^d (30 - 32\\cos(\\theta_a) + 2\\cos(2\\theta_a))}}{\\|\\boldsymbol{\\theta}\\|} - 1 = \\frac{\\sqrt{\\frac{1}{12} \\sum_{a=1}^d (30 - 32\\cos(\\theta_a) + 2\\cos(2\\theta_a))}}{\\|\\boldsymbol{\\theta}\\|} - 1\n$$\n\n### 第5部分：应用于测试用例\n\n问题指定每个波长有 $N=10$ 个点（PPW）。因此，无量纲波数大小为 $\\theta = \\|\\boldsymbol{\\theta}\\| = \\|\\mathbf{k}\\|h = \\frac{2\\pi}{\\lambda} h = \\frac{2\\pi}{\\lambda} (\\frac{\\lambda}{N}) = \\frac{2\\pi}{N}$。当 $N=10$ 时，我们有 $\\theta = \\pi/5$。分量为 $\\theta_a = \\theta \\hat{d}_a$，其中 $\\hat{\\mathbf{d}}$ 是传播方向矢量。\n\n**测试 A（一维，轴对齐）：** $\\hat{\\mathbf{d}}=[1]$, $d=1$。\n$\\theta_1 = \\pi/5$, $\\|\\boldsymbol{\\theta}\\| = \\pi/5$。\n- $\\varepsilon_{2,A} = \\frac{2 \\sin(\\pi/10)}{\\pi/5} - 1$\n- $\\varepsilon_{4,A} = \\frac{\\sqrt{\\frac{1}{12} (30 - 32\\cos(\\pi/5) + 2\\cos(2\\pi/5))}}{\\pi/5} - 1$\n\n**测试 B（二维，轴对齐）：** $\\hat{\\mathbf{d}}=[1, 0]$, $d=2$。\n$\\theta_1 = \\pi/5$, $\\theta_2 = 0$, $\\|\\boldsymbol{\\theta}\\| = \\pi/5$。\n- $\\varepsilon_{2,B} = \\frac{2 \\sqrt{\\sin^2(\\pi/10) + \\sin^2(0)}}{\\pi/5} - 1 = \\varepsilon_{2,A}$\n- 对于 $\\varepsilon_{4,B}$，当 $a=2$（$\\theta_2=0$）时，被加数为 $30 - 32\\cos(0) + 2\\cos(0) = 30-32+2=0$。求和化简为仅含 $a=1$ 的项，使其与一维情况相同。因此，$\\varepsilon_{4,B} = \\varepsilon_{4,A}$。\n\n**测试 C（二维，对角线方向）：** $\\hat{\\mathbf{d}}=[\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}]$, $d=2$。\n$\\theta_1 = \\theta_2 = \\frac{\\pi}{5\\sqrt{2}}$, $\\|\\boldsymbol{\\theta}\\| = \\pi/5$。\n- $\\varepsilon_{2,C} = \\frac{2 \\sqrt{2\\sin^2(\\frac{\\pi}{10\\sqrt{2}})}}{\\pi/5} - 1 = \\frac{2\\sqrt{2}\\sin(\\frac{\\pi}{10\\sqrt{2}})}{\\pi/5} - 1$\n- $\\varepsilon_{4,C} = \\frac{\\sqrt{\\frac{1}{12} \\cdot 2 \\cdot (30 - 32\\cos(\\frac{\\pi}{5\\sqrt{2}}) + 2\\cos(\\frac{2\\pi}{5\\sqrt{2}}))}}{\\pi/5} - 1$\n\n这些公式将被实现以计算所需的数值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the fractional phase velocity error for P and S waves\n    using 2nd- and 4th-order finite difference stencils for three test cases.\n    \"\"\"\n\n    def calculate_error(stencil_order, theta_vec, theta_norm):\n        \"\"\"\n        Calculates the fractional phase velocity error for a given stencil order and wavevector.\n\n        Args:\n            stencil_order (int): The order of the spatial stencil (2 or 4).\n            theta_vec (np.ndarray): The vector of non-dimensional wavenumbers (k_i * h).\n            theta_norm (float): The norm of the non-dimensional wavevector (||k|| * h).\n\n        Returns:\n            float: The fractional phase velocity error (c_ph/c - 1).\n        \"\"\"\n        if stencil_order == 2:\n            # Formula for the 2nd-order accurate stencil\n            sum_sin_sq = np.sum(np.sin(theta_vec / 2.0)**2)\n            # The numerator is the norm of the numerical wavevector\n            k_num_norm = 2.0 * np.sqrt(sum_sin_sq)\n            error = (k_num_norm / theta_norm) - 1.0\n        elif stencil_order == 4:\n            # Formula for the 4th-order accurate stencil\n            sum_cos_terms = np.sum(30.0 - 32.0 * np.cos(theta_vec) + 2.0 * np.cos(2.0 * theta_vec))\n            # The numerator is the norm of the numerical wavevector\n            k_num_norm = np.sqrt(sum_cos_terms / 12.0)\n            error = (k_num_norm / theta_norm) - 1.0\n        else:\n            raise ValueError(\"Stencil order must be 2 or 4.\")\n        \n        return error\n\n    # Common problem parameters\n    N = 10.0  # Points per wavelength\n    theta_norm = 2.0 * np.pi / N  # Non-dimensional wavenumber magnitude\n\n    # --- Test Case A: 1D, axis-aligned ---\n    dir_A = np.array([1.0])\n    theta_vec_A = theta_norm * dir_A\n    err_2_A = calculate_error(2, theta_vec_A, theta_norm)\n    err_4_A = calculate_error(4, theta_vec_A, theta_norm)\n\n    # --- Test Case B: 2D, axis-aligned ---\n    # Propagation along a grid axis in 2D is numerically identical to the 1D case.\n    dir_B = np.array([1.0, 0.0])\n    theta_vec_B = theta_norm * dir_B\n    err_2_B = calculate_error(2, theta_vec_B, theta_norm)\n    err_4_B = calculate_error(4, theta_vec_B, theta_norm)\n    \n    # --- Test Case C: 2D, diagonal ---\n    dir_C = np.array([1.0/np.sqrt(2), 1.0/np.sqrt(2)])\n    theta_vec_C = theta_norm * dir_C\n    err_2_C = calculate_error(2, theta_vec_C, theta_norm)\n    err_4_C = calculate_error(4, theta_vec_C, theta_norm)\n\n    # The fractional error is independent of wave type (P or S).\n    # Assemble the results in the specified single-line output format:\n    # [eps_P,2,A, eps_P,4,A, eps_S,2,A, eps_S,4,A,\n    #  eps_P,2,B, eps_P,4,B, eps_S,2,B, eps_S,4,B,\n    #  eps_P,2,C, eps_P,4,C, eps_S,2,C, eps_S,4,C]\n    results = [\n        err_2_A, err_4_A, err_2_A, err_4_A,\n        err_2_B, err_4_B, err_2_B, err_4_B,\n        err_2_C, err_4_C, err_2_C, err_4_C\n    ]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "地球物理学的一个核心目标是从地震记录中反演地下介质的属性。传统的基于波形逐点比较的反演方法（如$L_2$范数）常常受困于周波跳跃问题，导致优化过程陷入局部极值。这项高级练习将介绍一种基于最优传输理论（瓦瑟斯坦距离$W_2$）的现代解决方案，通过动手实践，量化其在构建更平滑、更凸的反演目标函数方面的优势。",
            "id": "3612545",
            "problem": "设计并实现一个完整的程序，该程序针对包含压缩波（P波）和剪切波（S波）的合成一维地震图，在低频下的周波跳跃（cycle-skipping）方面，比较传统的平方误差失配与二次Wasserstein-2最优传输失配。请基于以下基本依据：(i) 线性弹性波方程支持P波和S波，这些波可以局部地近似为带限脉冲；(ii) 时间序列的能量可以用振幅的平方来表示；(iii) 具有二次成本度量的最优传输定义了概率测度之间的Wasserstein-2距离。您的程序必须计算并比较失配函数曲面，这些曲面是同时应用于P波和S波分量的全局震源时间偏移参数的函数。\n\n程序中需采纳的定义和假设：\n\n- 构造一个合成参考地震图 $s_{\\mathrm{ref}}(t)$，其形式为两个带限脉冲的叠加，中心分别位于时间 $t_{\\mathrm{P}}$ 和 $t_{\\mathrm{S}}$，中心频率分别为 $f_{\\mathrm{P}}$ 和 $f_{\\mathrm{S}}$（单位 $\\mathrm{Hz}$），振幅分别为 $A_{\\mathrm{P}}$ 和 $A_{\\mathrm{S}}$（无量纲）。使用解析Ricker子波来表示每个脉冲，即一种在地震学中广泛使用的零均值带限脉冲，其定义在均匀时间采样上，时间步长为 $\\Delta t$（单位 $\\mathrm{s}$），持续时间为 $T$（单位 $\\mathrm{s}$）。\n- 通过对 $s_{\\mathrm{ref}}(t)$ 应用单一的全局震源时间偏移 $\\Delta_0$（单位 $\\mathrm{s}$）来定义观测地震图 $s_{\\mathrm{obs}}(t)$，使得 $s_{\\mathrm{obs}}(t) = s_{\\mathrm{ref}}(t - \\Delta_0)$。这模拟了一个未知的震源起始时间误差，该误差同等地影响P波和S波的到达。\n- 对于一个候选偏移量 $\\Delta$（单位 $\\mathrm{s}$），定义一个模型地震图 $s_{\\mathrm{mod}}(t;\\Delta) = s_{\\mathrm{ref}}(t - \\Delta)$。对于搜索网格上的每个 $\\Delta$，评估两个标量失配：\n  1. 平方误差（最小二乘）失配 $M_{L_2}(\\Delta)$，定义为 $M_{L_2}(\\Delta) = \\sum_{n} \\big( s_{\\mathrm{mod}}(t_n;\\Delta) - s_{\\mathrm{obs}}(t_n) \\big)^2$。\n  2. Wasserstein-2失配 $M_{W_2}(\\Delta)$，由从 $s_{\\mathrm{mod}}(t;\\Delta)$ 和 $s_{\\mathrm{obs}}(t)$ 构建的能量归一化测度之间的二次最优传输距离定义。为确保非负性，构建能量密度 $\\rho_{\\mathrm{mod}}(t;\\Delta) = \\big( s_{\\mathrm{mod}}(t;\\Delta) \\big)^2$ 和 $\\rho_{\\mathrm{obs}}(t) = \\big( s_{\\mathrm{obs}}(t) \\big)^2$，并将每个密度归一化为单位质量以形成概率测度 $p_{\\mathrm{mod}}(t;\\Delta)$ 和 $p_{\\mathrm{obs}}(t)$，并在时间上使用二次成本度量，即对于位置在 $t$ 和 $t'$ 的时间仓，传输成本为 $(t - t')^2$。在一维空间中，通过对 $u \\in [0,1]$ 上的相应分位数函数的平方差进行积分来计算 $W_2^2$。\n- 对于失配 $M(\\Delta)$，将周波跳跃定义为函数 $\\Delta \\mapsto M(\\Delta)$ 在搜索区间内存在多个不同的局部最小值。通过计算局部最小值的数量 $N_{\\min}$（通过比较相邻网格点找到）来量化周波跳跃。设额外最小值的数量为 $N_{\\mathrm{extra}} = \\max(N_{\\min} - 1, 0)$，其中减1是因为在 $\\Delta \\approx \\Delta_0$ 附近预期存在一个物理上正确的盆地。将 $W_2$ 相对于 $L_2$ 在周波跳跃方面的减少量定义为小数\n$$\nR = \\frac{N_{\\mathrm{extra}}^{(L_2)} - N_{\\mathrm{extra}}^{(W_2)}}{\\max\\big( N_{\\mathrm{extra}}^{(L_2)}, 1 \\big)} ,\n$$\n当 $N_{\\mathrm{extra}}^{(L_2)} \\ge 1$ 时，该值位于 $[0,1]$ 区间内；如果 $N_{\\mathrm{extra}}^{(L_2)} = 0$，则该值等于 $0$。\n\n您的程序必须实现以下步骤：\n\n1. 在均匀网格 $t_n = n \\Delta t$（其中 $n = 0,1,\\dots, \\lfloor T/\\Delta t \\rfloor$）上生成 $s_{\\mathrm{ref}}(t)$，其形式为：振幅为 $A_{\\mathrm{P}}$、中心在 $t_{\\mathrm{P}}$、频率为 $f_{\\mathrm{P}}$ 的Ricker子波，加上振幅为 $A_{\\mathrm{S}}$、中心在 $t_{\\mathrm{S}}$、频率为 $f_{\\mathrm{S}}$ 的Ricker子波。\n2. 通过应用全局偏移 $\\Delta_0$ 形成 $s_{\\mathrm{obs}}(t)$，并在试验偏移量 $\\Delta \\in [-\\Delta_{\\max}, \\Delta_{\\max}]$（步长为 $\\delta_{\\Delta}$，所有单位均为 $\\mathrm{s}$）的均匀网格上评估 $M_{L_2}(\\Delta)$ 和 $M_{W_2}(\\Delta)$。\n3. 通过检测离散网格上的局部最小值来为每个失配计算 $N_{\\min}$，然后计算 $N_{\\mathrm{extra}}^{(L_2)}$、$N_{\\mathrm{extra}}^{(W_2)}$，最后计算 $R$。\n4. 对以下科学上合理的测试套件重复上述步骤（所有时间单位为 $\\mathrm{s}$，频率单位为 $\\mathrm{Hz}$，振幅无量纲）：\n   - 测试 1（理想情况，中等低频）：$(f_{\\mathrm{P}}, f_{\\mathrm{S}}, t_{\\mathrm{P}}, t_{\\mathrm{S}}, A_{\\mathrm{P}}, A_{\\mathrm{S}}, \\Delta_0, \\Delta t, T, \\Delta_{\\max}, \\delta_{\\Delta}) = (5, 3, 0.6, 1.4, 1.0, 0.8, 0.12, 0.001, 2.5, 0.5, 0.002)$。\n   - 测试 2（边界情况，零偏移）：$(4, 2.5, 0.5, 1.2, 1.0, 0.9, 0.0, 0.001, 2.5, 0.5, 0.002)$。\n   - 测试 3（边缘情况，极低频和大偏移）：$(3, 2, 0.8, 1.8, 1.0, 0.7, 0.25, 0.001, 3.0, 0.5, 0.002)$。\n   - 测试 4（边缘情况，弱S波）：$(6, 3, 0.6, 1.0, 1.0, 0.1, 0.15, 0.001, 2.0, 0.5, 0.002)$。\n\n单位和输出规范：\n\n- 时间单位必须是 $\\mathrm{s}$，频率单位必须是 $\\mathrm{Hz}$。振幅是无量纲的。Wasserstein-2距离的单位是 $\\mathrm{s}^2$，因为其成本度量是时间的二次方；而 $L_2$ 失配的单位是振幅的平方单位；周波跳跃减少量 $R$ 是无量纲的，并且必须以四舍五入到三位小数的小数形式报告。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是为相应测试用例计算并四舍五入到三位小数的小数 $R$ 值 (例如，$\\big[0.875,0.333,0.000\\big]$)。",
            "solution": "该问题是有效的。它在科学上基于波传播和优化的原理，定义良好，包含了所有必要的定义和参数，且表述客观。它提出了一个与现代计算地球物理学相关的非平凡的计算任务。\n\n任务是比较两种失配函数，即常规平方误差（$L_2$）和Wasserstein-2（$W_2$），在地震波形反演背景下的表现。主要目标是量化 $W_2$ 度量在多大程度上缓解了周波跳跃问题，周波跳跃是一种优化算法陷入远离真实解的局部最小值中的现象。该比较是通过分析受时间偏移影响的合成地震图的失配函数来执行的。\n\n首先，我们建立生成合成地震图的数学框架。地震图被建模为两个波包的叠加，一个压缩（P）波和一个剪切（S）波。每个波包都由一个解析Ricker子波表示，这是地震学中的标准选择，因其具有零均值、带限的特性。具有中心频率 $f_c$ 且时间中心在 $t_0$ 的Ricker子波的公式为：\n$$\nw(t; f_c, t_0) = \\left(1 - 2\\pi^2 f_c^2 (t - t_0)^2\\right) e^{-\\pi^2 f_c^2 (t - t_0)^2}\n$$\n参考地震图 $s_{\\mathrm{ref}}(t)$ 由两个此类子波（分别代表P波和S波）的线性组合构成：\n$$\ns_{\\mathrm{ref}}(t) = A_{\\mathrm{P}} w(t; f_{\\mathrm{P}}, t_{\\mathrm{P}}) + A_{\\mathrm{S}} w(t; f_{\\mathrm{S}}, t_{\\mathrm{S}})\n$$\n其中 $(A_{\\mathrm{P}}, f_{\\mathrm{P}}, t_{\\mathrm{P}})$ 和 $(A_{\\mathrm{S}}, f_{\\mathrm{S}}, t_{\\mathrm{S}})$ 分别是P波和S波的振幅、中心频率和到达时间。时间在持续时间 $T$ 内以步长 $\\Delta t$ 进行离散化。\n\n观测地震图 $s_{\\mathrm{obs}}(t)$ 是通过对参考信号应用一个真实的、未知的时间偏移 $\\Delta_0$ 来创建的，用以模拟震源起始时间的误差：\n$$\ns_{\\mathrm{obs}}(t) = s_{\\mathrm{ref}}(t - \\Delta_0)\n$$\n为了找到这个偏移，我们为一系列候选偏移量 $\\Delta$ 生成模型地震图 $s_{\\mathrm{mod}}(t; \\Delta)$：\n$$\ns_{\\mathrm{mod}}(t; \\Delta) = s_{\\mathrm{ref}}(t - \\Delta)\n$$\n\n然后，我们在试验偏移量 $\\Delta$ 的网格上评估两种不同的失配函数。\n\n1.  平方误差（$L_2$）失配：这是在每个时间点 $t_n$ 观测地震图和模型地震图之间平方差的总和。它是一种逐点比较，对相位（时间）和振幅差异都很敏感。\n    $$\n    M_{L_2}(\\Delta) = \\sum_{n} \\big( s_{\\mathrm{mod}}(t_n; \\Delta) - s_{\\mathrm{obs}}(t_n) \\big)^2\n    $$\n    当时间偏移 $\\Delta - \\Delta_0$ 超过子波主周期的一半时，$L_2$ 失配会变得高度振荡，从而产生多个局部最小值。这就是周波跳跃问题。\n\n2.  Wasserstein-2（$W_2$）失配：该度量源于最优传输理论。它不是直接比较波形振幅，而是比较能量随时间的分布。这是通过将归一化的能量密度视为概率分布来实现的。\n    首先，我们定义观测信号和模型信号的非负能量密度：\n    $$\n    \\rho_{\\mathrm{obs}}(t) = \\big( s_{\\mathrm{obs}}(t) \\big)^2 \\quad \\text{和} \\quad \\rho_{\\mathrm{mod}}(t; \\Delta) = \\big( s_{\\mathrm{mod}}(t; \\Delta) \\big)^2\n    $$\n    然后将这些密度归一化以获得单位质量，从而形成概率密度函数（PDFs）：\n    $$\n    p(t) = \\frac{\\rho(t)}{\\int \\rho(\\tau) d\\tau}\n    $$\n    对于一维问题，带有时间二次成本函数的平方Wasserstein-2距离 $W_2^2$ 可以通过概率密度函数的分位数函数（逆累积分布函数）高效计算。累积分布函数（CDF）是 $C(t) = \\int_{-\\infty}^{t} p(\\tau) d\\tau$，其反函数是分位数函数 $Q(u) = C^{-1}(u)$，其中 $u \\in [0, 1]$。失配则为：\n    $$\n    M_{W_2}(\\Delta) \\equiv W_2^2(\\Delta) = \\int_{0}^{1} \\big( Q_{\\mathrm{mod}}(u; \\Delta) - Q_{\\mathrm{obs}}(u) \\big)^2 du\n    $$\n    在数值上，此积分的计算方法是：首先计算离散的累积分布函数，然后使用插值法在 $u$ 的均匀网格上找到分位数函数的值，最后使用梯形法则等数值求积规则来近似积分。$W_2$ 距离有效地衡量了将一个能量分布转换为另一个能量分布所需的“功”，使其对能量的整体位置比对逐点的振幅波动更敏感，从而创造一个更凸的失配函数曲面。\n\n为了量化周波跳跃，我们计算离散失配曲线 $M_{L_2}(\\Delta)$ 和 $M_{W_2}(\\Delta)$ 中的局部最小值数量 $N_{\\min}$。一种简单而稳健的方法是在失配曲线的负值上使用峰值查找算法。额外（非物理的）最小值的数量是 $N_{\\mathrm{extra}} = \\max(N_{\\min} - 1, 0)$，这考虑了在 $\\Delta = \\Delta_0$ 附近预期存在的单个真实最小值。\n\n最后，使用指定的度量 $R$ 计算使用 $W_2$ 失配相对于 $L_2$ 失配所实现的周波跳跃减少量：\n$$\nR = \\frac{N_{\\mathrm{extra}}^{(L_2)} - N_{\\mathrm{extra}}^{(W_2)}}{\\max\\big( N_{\\mathrm{extra}}^{(L_2)}, 1 \\big)}\n$$\n该值的范围从 $0$（无改善）到 $1$（完全消除额外最小值，前提是 $L_2$ 失配至少有一个额外最小值）。\n\n该程序将对提供的四个测试用例中的每一个执行整个过程，为每个用例计算 $R$ 并报告结果。这包括生成信号，在偏移网格上计算失配函数曲面，计算最小值数量，并最终计算减少因子 $R$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Solves the computational geophysics problem of comparing L2 and W2 misfits.\n    \"\"\"\n\n    test_cases = [\n        # (f_P, f_S, t_P, t_S, A_P, A_S, delta_0, dt, T, delta_max, d_delta)\n        (5.0, 3.0, 0.6, 1.4, 1.0, 0.8, 0.12, 0.001, 2.5, 0.5, 0.002),\n        (4.0, 2.5, 0.5, 1.2, 1.0, 0.9, 0.0, 0.001, 2.5, 0.5, 0.002),\n        (3.0, 2.0, 0.8, 1.8, 1.0, 0.7, 0.25, 0.001, 3.0, 0.5, 0.002),\n        (6.0, 3.0, 0.6, 1.0, 1.0, 0.1, 0.15, 0.001, 2.0, 0.5, 0.002),\n    ]\n\n    results = []\n\n    def ricker_wavelet(t, f_c, t_0):\n        \"\"\"Generates a Ricker wavelet.\"\"\"\n        term = (np.pi * f_c * (t - t_0))**2\n        return (1.0 - 2.0 * term) * np.exp(-term)\n\n    def compute_w2_squared(s_mod, s_obs, t_grid, dt):\n        \"\"\"Computes the squared Wasserstein-2 distance.\"\"\"\n        # 1. Compute energy densities\n        rho_mod = s_mod**2\n        rho_obs = s_obs**2\n\n        # 2. Normalize to form probability measures (PMFs)\n        total_energy_mod = np.sum(rho_mod)\n        total_energy_obs = np.sum(rho_obs)\n\n        if total_energy_mod  1e-12 or total_energy_obs  1e-12:\n            return 0.0  # Or handle as an error if signals are zero\n\n        p_mod = rho_mod / total_energy_mod\n        p_obs = rho_obs / total_energy_obs\n        \n        # 3. Compute Cumulative Distribution Functions (CDFs)\n        cdf_mod = np.cumsum(p_mod)\n        cdf_obs = np.cumsum(p_obs)\n        \n        # Ensure last element is 1.0 for interpolation stability\n        cdf_mod[-1] = 1.0\n        cdf_obs[-1] = 1.0\n        \n        # 4. Prepare data for quantile function interpolation\n        # To handle plateaus in the CDF, take only unique values\n        unique_mod_indices = np.unique(cdf_mod, return_index=True)[1]\n        unique_obs_indices = np.unique(cdf_obs, return_index=True)[1]\n        \n        cdf_mod_unique = cdf_mod[unique_mod_indices]\n        t_mod_unique = t_grid[unique_mod_indices]\n        \n        cdf_obs_unique = cdf_obs[unique_obs_indices]\n        t_obs_unique = t_grid[unique_obs_indices]\n\n        # 5. Compute quantile functions via interpolation\n        u_grid = np.linspace(0.0, 1.0, len(t_grid))\n        q_mod = np.interp(u_grid, cdf_mod_unique, t_mod_unique)\n        q_obs = np.interp(u_grid, cdf_obs_unique, t_obs_unique)\n\n        # 6. Integrate squared difference of quantile functions\n        squared_diff = (q_mod - q_obs)**2\n        w2_squared = np.trapz(squared_diff, u_grid)\n        \n        return w2_squared\n\n    def count_local_minima(misfit_curve):\n        \"\"\"Counts local minima in a 1D array.\"\"\"\n        # find_peaks finds local maxima, so we search on the negative curve\n        minima_indices, _ = find_peaks(-misfit_curve)\n        return len(minima_indices)\n\n    for case in test_cases:\n        f_p, f_s, t_p, t_s, a_p, a_s, delta_0, dt, T, delta_max, d_delta = case\n        \n        # 1. Generate time grids\n        t_grid = np.arange(0, T, dt)\n        delta_grid = np.arange(-delta_max, delta_max + d_delta, d_delta)\n        \n        # 2. Generate observed seismogram\n        s_obs = a_p * ricker_wavelet(t_grid, f_p, t_p + delta_0) + \\\n                a_s * ricker_wavelet(t_grid, f_s, t_s + delta_0)\n        \n        misfit_l2 = []\n        misfit_w2 = []\n        \n        # 3. Evaluate misfits over the shift grid\n        for delta in delta_grid:\n            # Generate model seismogram for current shift delta\n            s_mod = a_p * ricker_wavelet(t_grid, f_p, t_p + delta) + \\\n                    a_s * ricker_wavelet(t_grid, f_s, t_s + delta)\n            \n            # Compute L2 misfit\n            m_l2 = np.sum((s_mod - s_obs)**2)\n            misfit_l2.append(m_l2)\n            \n            # Compute W2 misfit\n            m_w2 = compute_w2_squared(s_mod, s_obs, t_grid, dt)\n            misfit_w2.append(m_w2)\n    \n        misfit_l2 = np.array(misfit_l2)\n        misfit_w2 = np.array(misfit_w2)\n        \n        # 4. Count minima and calculate R\n        n_min_l2 = count_local_minima(misfit_l2)\n        n_min_w2 = count_local_minima(misfit_w2)\n        \n        n_extra_l2 = max(n_min_l2 - 1, 0)\n        n_extra_w2 = max(n_min_w2 - 1, 0)\n        \n        reduction = (n_extra_l2 - n_extra_w2) / max(n_extra_l2, 1)\n        \n        results.append(f\"{reduction:.3f}\")\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}