{
    "hands_on_practices": [
        {
            "introduction": "In many geophysical transport phenomena, advection dominates diffusion, leading to sharp gradients that are notoriously difficult for standard Galerkin finite element methods to resolve without producing non-physical oscillations. This practice delves into the heart of stabilized methods by guiding you through the derivation of the Streamline Upwind/Petrov-Galerkin (SUPG) stabilization parameter. By enforcing nodal exactness for a model 1D advection-diffusion problem, you will uncover how the optimal stabilization parameter elegantly bridges the gap between diffusion-dominated and advection-dominated regimes, providing a foundational insight into the design of robust numerical schemes .",
            "id": "3618368",
            "problem": "Consider a steady transport of a passive scalar in a saturated porous channel representative of a single streamline in a larger geophysical flow, modeled on the interval $\\Omega = [0,L]$ by the constant-coefficient advection–diffusion operator with uniform Darcy velocity magnitude $|\\mathbf{b}|>0$ aligned with the coordinate axis and molecular dispersion (diffusivity) $\\epsilon>0$:\n$$\n-\\epsilon\\,\\frac{d^{2}u}{dx^{2}} + |\\mathbf{b}|\\,\\frac{du}{dx} = f(x),\n$$\nsupplemented with Dirichlet boundary conditions at $x=0$ and $x=L$. Let the domain be discretized by a uniform mesh of element size $h>0$ and continuous, piecewise-linear trial and test spaces. The Galerkin weak form is stabilized by the Streamline Upwind/Petrov–Galerkin (SUPG) method, where test functions are enriched in the streamline direction, adding on each element $K$ a residual-based term of the form\n$$\n\\int_{K} \\tau_{K}\\,|\\mathbf{b}|\\,\\frac{dw}{dx}\\,\\Big(-\\epsilon\\,\\frac{d^{2}u}{dx^{2}} + |\\mathbf{b}|\\,\\frac{du}{dx} - f\\Big)\\,dx,\n$$\nwith stabilization parameter $\\tau_{K}$ to be determined.\n\nStarting from the operator and weak formulation above, derive on a single element $K$ a closed-form expression for the SUPG stabilization parameter $\\tau$ in terms of the local Peclet number\n$$\nPe = \\frac{|\\mathbf{b}|\\,h}{2\\epsilon}.\n$$\nYour derivation must be based on element-level analysis of the exact constant-coefficient operator and the requirement that the SUPG weighting along the streamline mimics the adjoint Green’s function of the operator on $K$. Use the definition of the Peclet number and properties of the one-dimensional ($1$D) exponential exact solution to obtain an analytic formula for $\\tau$ on the uniform mesh.\n\nFinally, explain how the resulting $\\tau$ scales with $\\epsilon$, $|\\mathbf{b}|$, and $h$ in the asymptotic limits of small $Pe$ and large $Pe$, but present your final answer only as the closed-form analytic expression for $\\tau$ in terms of $Pe$, $|\\mathbf{b}|$, and $h$. No numerical evaluation is required, and no rounding is needed. Express your final answer as a single analytic expression.",
            "solution": "The user wants to derive the Streamline Upwind/Petrov-Galerkin (SUPG) stabilization parameter $\\tau$ for a one-dimensional constant-coefficient advection-diffusion problem. The derivation must be based on an element-level analysis requiring that the resulting finite element scheme be nodally exact for the homogeneous operator.\n\n### Step 1: Problem Validation\nThe problem statement is validated against the specified criteria.\n\n**1.1. Extracted Givens:**\n-   **Governing Equation:** $-\\epsilon \\frac{d^2u}{dx^2} + |\\mathbf{b}| \\frac{du}{dx} = f(x)$ on $\\Omega = [0, L]$.\n-   **Parameters:** Diffusivity $\\epsilon > 0$, Darcy velocity magnitude $|\\mathbf{b}| > 0$.\n-   **Boundary Conditions:** Dirichlet at $x=0$ and $x=L$.\n-   **Discretization:** Uniform mesh with element size $h$. Continuous, piecewise-linear trial and test spaces.\n-   **Stabilization Method:** SUPG, with the stabilization term on an element $K$ given by $\\int_{K} \\tau_{K}\\,|\\mathbf{b}|\\,\\frac{dw}{dx}\\,\\Big(\\,-\\,\\epsilon\\,\\frac{d^{2}u}{dx^{2}} \\;+\\; |\\mathbf{b}|\\,\\frac{du}{dx} \\;-\\; f\\,\\Big)\\,dx$.\n-   **Local Peclet Number:** $Pe = \\frac{|\\mathbf{b}|h}{2\\epsilon}$.\n-   **Objective:** Derive a closed-form expression for the stabilization parameter $\\tau_K$ (denoted as $\\tau$) on a single element.\n-   **Derivation Principle:** The derivation should be based on an element-level analysis ensuring the scheme is nodally exact for the exact constant-coefficient operator.\n-   **Final Output:** A single analytic expression for $\\tau$ in terms of $Pe$, $|\\mathbf{b}|$, and $h$.\n\n**1.2. Validation against Criteria:**\n-   **Scientifically Grounded:** The problem addresses the stabilization of the advection-diffusion equation, a cornerstone of transport phenomena. The SUPG method is a standard, well-vetted technique in computational fluid dynamics and related fields. The principle of designing a stabilization parameter to achieve nodal exactness for a model problem is a classic and fundamentally sound approach in the development of finite element methods. The problem is scientifically rigorous.\n-   **Well-Posed:** The problem provides a clear objective and a well-defined path for the derivation. All necessary components (operator, discretization, stabilization form, analysis principle) are specified, leading to a unique analytical solution.\n-   **Objective:** The problem is stated using precise mathematical and technical language, free from ambiguity or subjective content.\n\n**1.3. Verdict:**\nThe problem is valid. It is a standard, non-trivial derivation in the field of computational methods for differential equations. The solution process can proceed.\n\n### Step 2: Derivation of the Stabilization Parameter $\\tau$\n\nLet $b = |\\mathbf{b}|$. The steady-state, one-dimensional advection-diffusion equation is:\n$$\n-\\epsilon \\frac{d^2u}{dx^2} + b \\frac{du}{dx} = f(x)\n$$\nThe standard Galerkin weak form is obtained by multiplying by a test function $w$ and integrating over an element $K$. After applying integration by parts to the second-order term, we get:\n$$\n\\int_K \\left( \\epsilon \\frac{du}{dx} \\frac{dw}{dx} + b \\frac{du}{dx} w \\right) dx = \\int_K f w dx + \\left[ -\\epsilon \\frac{du}{dx} w \\right]_{\\partial K}\n$$\nThe boundary terms are handled during assembly. The discrete weak form for a finite element approximation $u_h(x) = \\sum_j U_j \\phi_j(x)$ tested against $w_h(x) = \\phi_i(x)$ is:\n$$\n\\sum_K \\int_K \\left( \\epsilon \\frac{du_h}{dx} \\frac{d\\phi_i}{dx} + b \\frac{du_h}{dx} \\phi_i \\right) dx = \\sum_K \\int_K f \\phi_i dx\n$$\nThe SUPG method adds a stabilization term. For continuous piecewise linear elements, $u_h''=0$ inside an element $K$. The residual of the equation for the discrete solution $u_h$ inside $K$ is $R(u_h) = -\\epsilon u_h'' + b u_h' - f = b u_h' - f$. The SUPG modification, as stated in the problem, adds the following term to the weak form for each test function $\\phi_i$:\n$$\n\\sum_K \\int_K \\tau b \\frac{d\\phi_i}{dx} \\left( b \\frac{du_h}{dx} \\right) dx\n$$\nHere, for simplicity, we consider the homogeneous problem where $f(x)=0$. The full SUPG discrete equation is:\n$$\n\\sum_K \\int_K \\left( \\epsilon \\frac{du_h}{dx} \\frac{d\\phi_i}{dx} + b \\frac{du_h}{dx} \\phi_i + \\tau b^2 \\frac{d\\phi_i}{dx} \\frac{du_h}{dx} \\right) dx = 0\n$$\n\nWe analyze the stencil for an interior node $x_j$ on a uniform mesh of size $h$. The test function is the hat function $\\phi_j$, which has support on $[x_{j-1}, x_{j+1}]$. We assemble the contributions from the two adjacent elements, $[x_{j-1}, x_j]$ and $[x_j, x_{j+1}]$.\n\nOn element $[x_{j-1}, x_j]$: $\\frac{d\\phi_j}{dx} = \\frac{1}{h}$ and $\\frac{du_h}{dx} = \\frac{U_j - U_{j-1}}{h}$. The integral of $\\phi_j$ over this element is $\\frac{h}{2}$.\nThe contribution to the stencil is:\n$$\n\\int_{x_{j-1}}^{x_j} \\left( \\epsilon \\left(\\frac{U_j-U_{j-1}}{h}\\right)\\frac{1}{h} + b\\left(\\frac{U_j-U_{j-1}}{h}\\right)\\phi_j + \\tau b^2 \\left(\\frac{U_j-U_{j-1}}{h}\\right)\\frac{1}{h} \\right) dx \\\\\n= \\left( \\frac{\\epsilon}{h} + \\frac{b}{2} + \\frac{\\tau b^2}{h} \\right)(U_j - U_{j-1})\n$$\n\nOn element $[x_j, x_{j+1}]$: $\\frac{d\\phi_j}{dx} = -\\frac{1}{h}$ and $\\frac{du_h}{dx} = \\frac{U_{j+1} - U_j}{h}$. The integral of $\\phi_j$ over this element is $\\frac{h}{2}$.\nThe contribution to the stencil is:\n$$\n\\int_{x_j}^{x_{j+1}} \\left( \\epsilon \\left(\\frac{U_{j+1}-U_j}{h}\\right)\\left(-\\frac{1}{h}\\right) + b\\left(\\frac{U_{j+1}-U_j}{h}\\right)\\phi_j + \\tau b^2 \\left(\\frac{U_{j+1}-U_j}{h}\\right)\\left(-\\frac{1}{h}\\right) \\right) dx \\\\\n= \\left( -\\frac{\\epsilon}{h} + \\frac{b}{2} - \\frac{\\tau b^2}{h} \\right)(U_{j+1} - U_j)\n$$\n\nSumming the contributions gives the complete stencil equation for node $j$:\n$$\n\\left( \\frac{\\epsilon}{h} + \\frac{b}{2} + \\frac{\\tau b^2}{h} \\right)(U_j - U_{j-1}) + \\left( -\\frac{\\epsilon}{h} + \\frac{b}{2} - \\frac{\\tau b^2}{h} \\right)(U_{j+1} - U_j) = 0\n$$\n\nTo find the optimal $\\tau$, we enforce that the numerical solution is nodally exact. The exact solution to the homogeneous equation $-\\epsilon u'' + b u' = 0$ is $u(x) = C_1 + C_2 \\exp(bx/\\epsilon)$. Let $U_j = u(x_j)$. Define $\\alpha = \\frac{bh}{\\epsilon}$.\nThen $U_j - U_{j-1} = u(x_j) - u(x_j-h) = C_2(\\exp(bx_j/\\epsilon) - \\exp(b(x_j-h)/\\epsilon)) = C_2 \\exp(bx_j/\\epsilon) (1-e^{-\\alpha})$.\nAnd $U_{j+1} - U_j = u(x_j+h) - u(x_j) = C_2(\\exp(b(x_j+h)/\\epsilon) - \\exp(bx_j/\\epsilon)) = C_2 \\exp(bx_j/\\epsilon) (e^{\\alpha}-1)$.\n\nSubstituting these into the stencil equation and canceling the common factor $C_2 \\exp(bx_j/\\epsilon)$:\n$$\n\\left( \\frac{\\epsilon}{h} + \\frac{b}{2} + \\frac{\\tau b^2}{h} \\right)(1 - e^{-\\alpha}) + \\left( -\\frac{\\epsilon}{h} + \\frac{b}{2} - \\frac{\\tau b^2}{h} \\right)(e^{\\alpha} - 1) = 0\n$$\nSince $1-e^{-\\alpha} = e^{-\\alpha}(e^\\alpha-1)$, we can divide by $(e^\\alpha-1)$ (for $\\alpha \\neq 0$):\n$$\n\\left( \\frac{\\epsilon}{h} + \\frac{b}{2} + \\frac{\\tau b^2}{h} \\right)e^{-\\alpha} + \\left( -\\frac{\\epsilon}{h} + \\frac{b}{2} - \\frac{\\tau b^2}{h} \\right) = 0\n$$\nWe now solve for $\\tau$. Let's group terms multiplying $\\tau$:\n$$\n\\tau \\frac{b^2}{h} (e^{-\\alpha} - 1) = -\\left(\\frac{\\epsilon}{h} + \\frac{b}{2}\\right)e^{-\\alpha} - \\left(-\\frac{\\epsilon}{h} + \\frac{b}{2}\\right)\n$$\n$$\n\\tau \\frac{b^2}{h} (1 - e^{-\\alpha}) = \\left(\\frac{\\epsilon}{h} + \\frac{b}{2}\\right)e^{-\\alpha} + \\left(-\\frac{\\epsilon}{h} + \\frac{b}{2}\\right) = \\frac{\\epsilon}{h}(e^{-\\alpha}-1) + \\frac{b}{2}(e^{-\\alpha}+1)\n$$\n$$\n\\tau = \\frac{h}{b^2(1-e^{-\\alpha})} \\left[ \\frac{\\epsilon}{h}(e^{-\\alpha}-1) + \\frac{b}{2}(e^{-\\alpha}+1) \\right] = -\\frac{\\epsilon}{b^2} + \\frac{h}{2b} \\frac{e^{-\\alpha}+1}{1-e^{-\\alpha}}\n$$\nUsing the local Peclet number $Pe = \\frac{bh}{2\\epsilon}$, we have $\\alpha = \\frac{bh}{\\epsilon} = 2Pe$.\nThe expression for $\\tau$ becomes:\n$$\n\\tau = -\\frac{\\epsilon}{b^2} + \\frac{h}{2b} \\frac{1+e^{-2Pe}}{1-e^{-2Pe}}\n$$\nThe fraction is the definition of the hyperbolic cotangent:\n$$\n\\frac{1+e^{-2Pe}}{1-e^{-2Pe}} = \\frac{e^{Pe}(e^{-Pe}+e^{Pe})}{e^{Pe}(e^{-Pe}-e^{Pe})} = \\frac{e^{Pe}+e^{-Pe}}{e^{Pe}-e^{-Pe}} = \\coth(Pe)\n$$\nSo, $\\tau = \\frac{h}{2b}\\coth(Pe) - \\frac{\\epsilon}{b^2}$. We can write $\\frac{\\epsilon}{b^2}$ in terms of $Pe$: $\\frac{\\epsilon}{b^2} = \\frac{h}{2b \\cdot Pe}$.\n$$\n\\tau = \\frac{h}{2b}\\coth(Pe) - \\frac{h}{2b \\cdot Pe} = \\frac{h}{2b} \\left( \\coth(Pe) - \\frac{1}{Pe} \\right)\n$$\nReplacing $b$ with $|\\mathbf{b}|$, we obtain the final expression.\n\n### Step 3: Asymptotic Analysis\nWe examine the behavior of $\\tau$ in two limits.\n\n**Advection-Dominated Limit ($Pe \\to \\infty$):**\nFor large $x$, $\\coth(x) \\approx 1$. Therefore, for $Pe \\gg 1$:\n$$\n\\tau \\approx \\frac{h}{2|\\mathbf{b}|} \\left( 1 - \\frac{1}{Pe} \\right) \\to \\frac{h}{2|\\mathbf{b}|}\n$$\nIn this limit, $\\tau$ is independent of the diffusivity $\\epsilon$ and scales as $\\tau \\propto h/|\\mathbf{b}|$. This corresponds to the classical upwinding parameter for a pure advection problem.\n\n**Diffusion-Dominated Limit ($Pe \\to 0$):**\nFor small $x$, the Taylor series for $\\coth(x)$ is $\\frac{1}{x} + \\frac{x}{3} - \\frac{x^3}{45} + O(x^5)$.\nThus, for $Pe \\ll 1$:\n$$\n\\coth(Pe) - \\frac{1}{Pe} \\approx \\left(\\frac{1}{Pe} + \\frac{Pe}{3}\\right) - \\frac{1}{Pe} = \\frac{Pe}{3}\n$$\nSubstituting this into the expression for $\\tau$:\n$$\n\\tau \\approx \\frac{h}{2|\\mathbf{b}|} \\left( \\frac{Pe}{3} \\right) = \\frac{h}{2|\\mathbf{b}|} \\frac{|\\mathbf{b}|h}{6\\epsilon} = \\frac{h^2}{12\\epsilon}\n$$\nIn this limit, $\\tau$ is independent of the velocity $|\\mathbf{b}|$ and scales as $\\tau \\propto h^2/\\epsilon$.\n\nThe derived formula provides a smooth transition between these two physical regimes.",
            "answer": "$$\n\\boxed{\\frac{h}{2|\\mathbf{b}|} \\left( \\coth\\left(\\frac{|\\mathbf{b}|h}{2\\epsilon}\\right) - \\frac{2\\epsilon}{|\\mathbf{b}|h} \\right)}\n$$"
        },
        {
            "introduction": "Geophysical systems are often composed of distinct physical domains, such as fluid-saturated rock and solid strata, that require different governing equations or non-matching discretizations. This exercise introduces domain decomposition and the use of Lagrange multipliers to weakly enforce physical continuity conditions at interfaces, a powerful and flexible technique in multiphysics modeling. By implementing a mortar-type method for a 1D coupled problem, you will translate the abstract theory of saddle-point variational formulations into a concrete block-matrix system, gaining hands-on experience in assembling and solving the coupled algebraic equations that arise from such weak constraints .",
            "id": "3618425",
            "problem": "Consider a one-dimensional domain decomposition into a solid subdomain $\\Omega_s = (0, L_s)$ and a fluid subdomain $\\Omega_f = (L_s, L_s + L_f)$. The state variable is a scalar displacement-like field on each subdomain, denoted $u_s(x)$ for $x \\in \\Omega_s$ and $u_f(x)$ for $x \\in \\Omega_f$. Assume quasi-static behavior with linear constitutive response characterized by positive coefficients $a_s$ on $\\Omega_s$ and $a_f$ on $\\Omega_f$. Let the body source terms be constant $q_s$ on $\\Omega_s$ and $q_f$ on $\\Omega_f$. The governing strong forms on each subdomain are the equilibrium equations $-\\frac{d}{dx}\\left(a_s \\frac{du_s}{dx}\\right) = q_s$ in $\\Omega_s$ and $-\\frac{d}{dx}\\left(a_f \\frac{du_f}{dx}\\right) = q_f$ in $\\Omega_f$, with homogeneous Dirichlet boundary conditions $u_s(0) = 0$ and $u_f(L_s + L_f) = 0$. At the fluid–solid interface $\\Gamma = \\{L_s\\}$, weak continuity and equilibrium are enforced via the jump conditions $\\llbracket u \\rrbracket = u_s(L_s) - u_f(L_s) = 0$ and $\\llbracket a \\frac{du}{dx} \\rrbracket = a_s \\frac{du_s}{dx}(L_s^-) + a_f \\left(-\\frac{du_f}{dx}(L_s^+)\\right) = 0$, where the outward normals on $\\Omega_s$ and $\\Omega_f$ are oriented as $n_s = +1$ and $n_f = -1$, respectively.\n\nStarting from the virtual work principle and the definition of the jump operators, derive the weak formulation on the product space $V_s \\times V_f$ enhanced with a Lagrange multiplier space $M$ on the interface. In particular, express the weak enforcement of $\\llbracket u \\rrbracket = 0$ and $\\llbracket a \\frac{du}{dx} \\rrbracket = 0$ by introducing two interface Lagrange multipliers $\\lambda_u \\in M$ and $\\lambda_t \\in M$, and derive the corresponding saddle-point bilinear form coupling $(u_s, u_f)$ and $(\\lambda_u, \\lambda_t)$.\n\nThen, discretize the weak formulation with piecewise linear finite elements on each subdomain independently, allowing nonmatching mesh sizes. In one dimension, the interface $\\Gamma$ is a single point, so the mortar integrals reduce to evaluations at $x = L_s$. Let the solid subdomain be partitioned into $N_s$ uniform elements and the fluid subdomain into $N_f$ uniform elements. Assemble the block saddle-point system of the form\n$$\n\\begin{bmatrix}\nK_s & 0 & C_s & D_s \\\\\n0 & K_f & -C_f & D_f \\\\\nC_s^\\top & -C_f^\\top & 0 & 0 \\\\\nD_s^\\top & D_f^\\top & 0 & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{u}_s \\\\ \\mathbf{u}_f \\\\ \\lambda_u \\\\ \\lambda_t\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f}_s \\\\ \\mathbf{f}_f \\\\ 0 \\\\ 0\n\\end{bmatrix},\n$$\nwhere $K_s$ and $K_f$ are the subdomain stiffness matrices, $\\mathbf{f}_s$ and $\\mathbf{f}_f$ are the subdomain load vectors, $C_s$ and $C_f$ extract the interface trace values from the subdomain degrees of freedom, and $D_s$ and $D_f$ represent the discrete normal tractions at the interface consistent with outward normal orientations. Implement homogeneous Dirichlet boundary conditions at $x = 0$ for the solid and at $x = L_s + L_f$ for the fluid by eliminating the corresponding degrees of freedom with prescribed value $0$.\n\nYour task is to write a complete, runnable program that:\n- Assembles the discrete operators $K_s$, $K_f$, $\\mathbf{f}_s$, $\\mathbf{f}_f$, $C_s$, $C_f$, $D_s$, and $D_f$ as specified, for several test cases.\n- Solves the saddle-point system for each test case.\n- Returns, for each test case, a pair consisting of the interface displacement $u_\\Gamma = u_s(L_s)$ and the interface traction $t_\\Gamma = a_s \\frac{du_s}{dx}(L_s^-)$, computed consistently with the discrete representation. Since the constraints enforce equilibrium, $t_\\Gamma$ should equal $-a_f \\frac{du_f}{dx}(L_s^+)$; compute and report $t_\\Gamma$ using the solid-side representation.\n\nAll quantities are to be treated as dimensionless in this problem. The finite element assembly must use standard one-dimensional linear elements. For an element of length $h$ with coefficient $a$, the local stiffness matrix is $\\frac{a}{h}\\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$ and the local load vector for constant source $q$ is $\\frac{q h}{2}\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$. The interface trace extraction vectors are defined so that $C_s^\\top \\mathbf{u}_s = u_s(L_s)$ and $C_f^\\top \\mathbf{u}_f = u_f(L_s)$, while the traction vectors $D_s$ and $D_f$ implement $D_s^\\top \\mathbf{u}_s \\approx a_s \\frac{du_s}{dx}(L_s^-)$ and $D_f^\\top \\mathbf{u}_f \\approx -a_f \\frac{du_f}{dx}(L_s^+)$ using the element adjacent to the interface.\n\nDesign your implementation to handle the cases where the subdomain adjacent to the interface has only one unknown degree of freedom (for example, when $N_s = 1$ or $N_f = 1$). In those cases, use the known Dirichlet boundary value $0$ at the noninterface end to define the discrete derivative at the interface consistently.\n\nTest Suite:\nUse the following four test cases, each specified by $(L_s, L_f, N_s, N_f, a_s, a_f, q_s, q_f)$:\n- Case $1$: $(L_s, L_f, N_s, N_f, a_s, a_f, q_s, q_f) = (1, 1, 4, 3, 2, 1, 1, 0.5)$.\n- Case $2$: $(L_s, L_f, N_s, N_f, a_s, a_f, q_s, q_f) = (1, 2, 2, 8, 10, 0.1, 0, 3)$.\n- Case $3$: $(L_s, L_f, N_s, N_f, a_s, a_f, q_s, q_f) = (0.5, 0.5, 2, 2, 1, 1, 1, 1)$.\n- Case $4$: $(L_s, L_f, N_s, N_f, a_s, a_f, q_s, q_f) = (1.5, 0.5, 5, 2, 5, 5, 0, 0)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, report the interface displacement followed by the interface traction, so the output has the form $[u_{\\Gamma,1}, t_{\\Gamma,1}, u_{\\Gamma,2}, t_{\\Gamma,2}, u_{\\Gamma,3}, t_{\\Gamma,3}, u_{\\Gamma,4}, t_{\\Gamma,4}]$, where $u_{\\Gamma,i}$ and $t_{\\Gamma,i}$ are floats.",
            "solution": "The user wants to solve a one-dimensional, two-domain, steady-state problem using a finite element method with Lagrange multipliers for interface coupling.\n\n### Step 1: Problem Validation\n\n**Step 1.1: Extract Givens**\n- **Domains**: Solid $\\Omega_s = (0, L_s)$, Fluid $\\Omega_f = (L_s, L_s + L_f)$.\n- **State variables**: $u_s(x)$ on $\\Omega_s$, $u_f(x)$ on $\\Omega_f$.\n- **Material properties**: Positive coefficients $a_s$ on $\\Omega_s$, $a_f$ on $\\Omega_f$.\n- **Source terms**: Constant body sources $q_s$ on $\\Omega_s$, $q_f$ on $\\Omega_f$.\n- **Strong form (governing equations)**:\n  - $-\\frac{d}{dx}\\left(a_s \\frac{du_s}{dx}\\right) = q_s$ in $\\Omega_s$.\n  - $-\\frac{d}{dx}\\left(a_f \\frac{du_f}{dx}\\right) = q_f$ in $\\Omega_f$.\n- **Boundary conditions (BCs)**:\n  - Homogeneous Dirichlet at outer boundaries: $u_s(0) = 0$ and $u_f(L_s + L_f) = 0$.\n- **Interface conditions at $\\Gamma = \\{L_s\\}$**:\n  - Displacement continuity (jump $\\llbracket u \\rrbracket = 0$): $u_s(L_s) - u_f(L_s) = 0$.\n  - Traction equilibrium (jump $\\llbracket a \\frac{du}{dx} \\rrbracket = 0$): $a_s \\frac{du_s}{dx}(L_s^-) + a_f \\left(-\\frac{du_f}{dx}(L_s^+)\\right) = 0$. Note: Outward normals are $n_s = +1$ and $n_f = -1$.\n- **Numerical Method**:\n  - Piecewise linear finite elements on nonmatching meshes.\n  - Solid domain: $N_s$ uniform elements. Fluid domain: $N_f$ uniform elements.\n  - Lagrange multipliers $\\lambda_u, \\lambda_t$ to enforce interface conditions weakly.\n- **Discrete System Structure**: A block saddle-point system is specified:\n  $$\n  \\begin{bmatrix}\n  K_s & 0 & C_s & D_s \\\\\n  0 & K_f & -C_f & D_f \\\\\n  C_s^\\top & -C_f^\\top & 0 & 0 \\\\\n  D_s^\\top & D_f^\\top & 0 & 0\n  \\end{bmatrix}\n  \\begin{bmatrix}\n  \\mathbf{u}_s \\\\ \\mathbf{u}_f \\\\ \\lambda_u \\\\ \\lambda_t\n  \\end{bmatrix}\n  =\n  \\begin{bmatrix}\n  \\mathbf{f}_s \\\\ \\mathbf{f}_f \\\\ 0 \\\\ 0\n  \\end{bmatrix}\n  $$\n- **Definitions of Discrete Operators**:\n  - $K_s, K_f$: Subdomain stiffness matrices.\n  - $\\mathbf{f}_s, \\mathbf{f}_f$: Subdomain load vectors.\n  - $C_s^\\top \\mathbf{u}_s = u_s(L_s)$, $C_f^\\top \\mathbf{u}_f = u_f(L_s)$.\n  - $D_s^\\top \\mathbf{u}_s \\approx a_s \\frac{du_s}{dx}(L_s^-)$, $D_f^\\top \\mathbf{u}_f \\approx -a_f \\frac{du_f}{dx}(L_s^+)$.\n- **Local Element Matrices**: For an element of length $h$, coefficient $a$, and source $q$:\n  - Local stiffness: $\\frac{a}{h}\\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$.\n  - Local load vector: $\\frac{q h}{2}\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$.\n- **Task**: Assemble and solve the system, then compute interface displacement $u_\\Gamma = u_s(L_s)$ and traction $t_\\Gamma = a_s \\frac{du_s}{dx}(L_s^-)$.\n- **Test Suite**: Four specific sets of parameters $(L_s, L_f, N_s, N_f, a_s, a_f, q_s, q_f)$ are provided.\n\n**Step 1.2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem describes a standard 1D elasticity/diffusion problem with domain decomposition. The governing equations are second-order elliptic partial differential equations. The use of Lagrange multipliers to enforce interface constraints is a well-established technique in computational mechanics (related to FETI and mortar methods). The problem is scientifically and mathematically sound.\n- **Well-Posed**: All necessary data (domain lengths, material properties, source terms, mesh sizes) and conditions (boundary and interface) are provided. The structure of the problem ensures a unique solution exists for the given physical model and its discretization. The resulting linear system is generally non-singular and thus solvable.\n- **Objective**: The problem is stated in precise, formal mathematical and computational language. There are no subjective or ambiguous terms.\n- **No Flaws Detected**: The problem does not violate any of the invalidity criteria. It is self-contained, consistent, and scientifically grounded.\n\n**Step 1.3: Verdict and Action**\n- The problem is **valid**. Proceed to the solution.\n\n### Step 2: Derivation and Implementation Strategy\n\nThe task is to implement a finite element solver for the specified saddle-point system. The core of the task is to correctly construct each block of the system matrix and the right-hand side vector.\n\n**1. Subdomain Discretization and Degrees of Freedom (DOFs)**\n- **Solid Domain $\\Omega_s = (0, L_s)$**: Discretized into $N_s$ elements of length $h_s = L_s / N_s$. This gives $N_s+1$ nodes. Due to the BC $u_s(0)=0$, the unknown DOFs are the nodal values $\\{u_{s,1}, u_{s,2}, \\dots, u_{s,N_s}\\}$. The dimension of the vector $\\mathbf{u}_s$ is $N_s$.\n- **Fluid Domain $\\Omega_f = (L_s, L_s+L_f)$**: Discretized into $N_f$ elements of length $h_f = L_f / N_f$. This gives $N_f+1$ nodes. Due to the BC $u_f(L_s+L_f)=0$, the unknown DOFs are $\\{u_{f,0}, u_{f,1}, \\dots, u_{f,N_f-1}\\}$. The dimension of the vector $\\mathbf{u}_f$ is $N_f$.\n\n**2. Assembly of Subdomain Matrices ($K_s, \\mathbf{f}_s, K_f, \\mathbf{f}_f$)**\nThe standard finite element assembly procedure is used.\n- For a subdomain with $N$ elements and coefficient $a$, length $L$, and source $q$:\n  - The element stiffness matrix is $k_e = \\frac{a}{h} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$ where $h=L/N$.\n  - The element load vector is $f_e = \\frac{q h}{2} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$.\n- These local matrices are assembled into a global system of size $(N+1) \\times (N+1)$.\n- The homogeneous Dirichlet BCs are applied by eliminating the row and column corresponding to the fixed DOF. This results in $N \\times N$ matrices $K_s, K_f$ and vectors $\\mathbf{f}_s, \\mathbf{f}_f$ of size $N_s$ and $N_f$, respectively.\n\n**3. Assembly of Coupling Operators ($C_s, C_f, D_s, D_f$)**\nThese operators are column vectors (or $N \\times 1$ matrices) that map the scalar Lagrange multipliers to forces on the subdomain DOFs.\n- **$C_s$, $C_f$ (Trace operators)**:\n  - $C_s^\\top \\mathbf{u}_s = u_s(L_s) = u_{s,N_s}$. Since $\\mathbf{u}_s = [u_{s,1}, \\dots, u_{s,N_s}]^\\top$, the vector $C_s^\\top$ must be $[0, \\dots, 0, 1]$. Thus, $C_s = [0, \\dots, 0, 1]^\\top$, a column vector of size $N_s$.\n  - $C_f^\\top \\mathbf{u}_f = u_f(L_s) = u_{f,0}$. Since $\\mathbf{u}_f = [u_{f,0}, \\dots, u_{f,N_f-1}]^\\top$, the vector $C_f^\\top$ must be $[1, 0, \\dots, 0]$. Thus, $C_f = [1, 0, \\dots, 0]^\\top$, a column vector of size $N_f$.\n\n- **$D_s$, $D_f$ (Traction operators)**:\n  - $D_s^\\top \\mathbf{u}_s \\approx a_s \\frac{du_s}{dx}(L_s^-)$. The derivative on the last element is $\\frac{u_{s,N_s} - u_{s,N_s-1}}{h_s}$. If $N_s=1$, this becomes $\\frac{u_{s,1} - u_{s,0}}{h_s} = \\frac{u_{s,1}}{h_s}$ as $u_{s,0}=0$.\n    - For $N_s>1$, $D_s^\\top \\mathbf{u}_s = \\frac{a_s}{h_s} (u_{s,N_s} - u_{s,N_s-1})$. So $D_s = \\frac{a_s}{h_s} [0, \\dots, 0, -1, 1]^\\top$.\n    - For $N_s=1$, $D_s^\\top \\mathbf{u}_s = \\frac{a_s}{h_s} u_{s,1}$. So $D_s = [\\frac{a_s}{h_s}]^\\top$.\n  - $D_f^\\top \\mathbf{u}_f \\approx -a_f \\frac{du_f}{dx}(L_s^+)$. The derivative on the first element is $\\frac{u_{f,1} - u_{f,0}}{h_f}$. The approximation becomes $-a_f \\frac{u_{f,1} - u_{f,0}}{h_f} = a_f \\frac{u_{f,0} - u_{f,1}}{h_f}$. If $N_f=1$, this is $\\frac{a_f}{h_f}(u_{f,0} - u_{f,1}) = \\frac{a_f}{h_f} u_{f,0}$ as $u_{f,1}=0$.\n    - For $N_f>1$, $D_f^\\top \\mathbf{u}_f = \\frac{a_f}{h_f} (u_{f,0} - u_{f,1})$. So $D_f = \\frac{a_f}{h_f} [1, -1, 0, \\dots, 0]^\\top$.\n    - For $N_f=1$, $D_f^\\top \\mathbf{u}_f = \\frac{a_f}{h_f} u_{f,0}$. So $D_f = [\\frac{a_f}{h_f}]^\\top$.\n\n**4. Global System Assembly and Solution**\nThe full matrix $A$ of size $(N_s+N_f+2) \\times (N_s+N_f+2)$ and right-hand side vector $B$ are assembled block by block according to the specified structure. The resulting linear system $A\\mathbf{x} = B$ is solved for the solution vector $\\mathbf{x} = [\\mathbf{u}_s^\\top, \\mathbf{u}_f^\\top, \\lambda_u, \\lambda_t]^\\top$.\n\n**5. Extraction of Results**\n- The interface displacement is $u_\\Gamma = u_s(L_s)$, which is the last component of the solution vector's $\\mathbf{u}_s$ part: $u_\\Gamma = \\mathbf{x}[N_s-1]$.\n- The interface traction is $t_\\Gamma = a_s \\frac{du_s}{dx}(L_s^-)$, which is computed using its discrete representation: $t_\\Gamma = D_s^\\top \\mathbf{u}_s$.\n\nThis structured approach is implemented in the Python code below.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_subdomain_system(N, L, a, q, bc_at_zero):\n    \"\"\"\n    Assembles the stiffness matrix K and load vector f for a 1D subdomain\n    with N elements, length L, coefficient a, and source q.\n    Homogeneous Dirichlet BC is applied at one end.\n\n    bc_at_zero=True: BC at x=0 (e.g., solid domain)\n    bc_at_zero=False: BC at the other end, x=L (e.g., fluid domain)\n    \"\"\"\n    if N == 0:\n        return np.array([]).reshape(0,0), np.array([])\n        \n    num_nodes = N + 1\n    h = L / N\n    \n    # Full stiffness matrix (num_nodes x num_nodes) before BCs\n    K_full = np.zeros((num_nodes, num_nodes))\n    for i in range(N):\n        k_elem = (a / h) * np.array([[1, -1], [-1, 1]])\n        K_full[i:i+2, i:i+2] += k_elem\n        \n    # Full load vector (num_nodes) before BCs\n    f_full = np.zeros(num_nodes)\n    if q != 0:\n        for i in range(N):\n            f_elem = (q * h / 2.0) * np.array([1, 1])\n            f_full[i:i+2] += f_elem\n        \n    if bc_at_zero:\n        # BC at node 0 (u_0 = 0), unknowns are u_1, ..., u_N\n        # Matrix size becomes N x N\n        K = K_full[1:, 1:]\n        f = f_full[1:]\n    else:\n        # BC at node N (u_N = 0), unknowns are u_0, ..., u_{N-1}\n        # Matrix size becomes N x N\n        K = K_full[:-1, :-1]\n        f = f_full[:-1]\n        \n    return K, f\n\ndef solve_case(Ls, Lf, Ns, Nf, a_s, a_f, q_s, q_f):\n    \"\"\"\n    Assembles and solves the saddle-point system for one test case.\n    \"\"\"\n    hs = Ls / Ns\n    hf = Lf / Nf\n    \n    # Assemble subdomain matrices\n    Ks, fs = build_subdomain_system(Ns, Ls, a_s, q_s, bc_at_zero=True)\n    Kf, ff = build_subdomain_system(Nf, Lf, a_f, q_f, bc_at_zero=False)\n\n    # Assemble coupling operators (as column vectors)\n    Cs = np.zeros((Ns, 1))\n    Cs[-1, 0] = 1.0\n    \n    Cf = np.zeros((Nf, 1))\n    if Nf > 0:\n        Cf[0, 0] = 1.0\n\n    Ds = np.zeros((Ns, 1))\n    if Ns > 1:\n        Ds[-2, 0] = -(a_s / hs)\n        Ds[-1, 0] = a_s / hs\n    elif Ns == 1:\n        Ds[0, 0] = a_s / hs\n\n    Df = np.zeros((Nf, 1))\n    if Nf > 1:\n        Df[0, 0] = a_f / hf\n        Df[1, 0] = -(a_f / hf)\n    elif Nf == 1:\n        Df[0, 0] = a_f / hf\n        \n    # Assemble the full saddle-point system\n    total_dofs = Ns + Nf + 2\n    A = np.zeros((total_dofs, total_dofs))\n    B = np.zeros(total_dofs)\n\n    # stiffness blocks\n    if Ns > 0:\n        A[0:Ns, 0:Ns] = Ks\n    if Nf > 0:\n        A[Ns:Ns+Nf, Ns:Ns+Nf] = Kf\n    \n    # RHS load vectors\n    if Ns > 0:\n        B[0:Ns] = fs\n    if Nf > 0:\n        B[Ns:Ns+Nf] = ff\n    \n    # Coupling blocks C\n    if Ns > 0:\n        A[0:Ns, Ns+Nf] = Cs[:, 0]\n        A[Ns+Nf, 0:Ns] = Cs[:, 0].T\n    if Nf > 0:\n        A[Ns:Ns+Nf, Ns+Nf] = -Cf[:, 0]\n        A[Ns+Nf, Ns:Ns+Nf] = -Cf[:, 0].T\n\n    # Coupling blocks D\n    if Ns > 0:\n        A[0:Ns, Ns+Nf+1] = Ds[:, 0]\n        A[Ns+Nf+1, 0:Ns] = Ds[:, 0].T\n    if Nf > 0:\n        A[Ns:Ns+Nf, Ns+Nf+1] = Df[:, 0]\n        A[Ns+Nf+1, Ns:Ns+Nf] = Df[:, 0].T\n\n    # Solve the system\n    x = np.linalg.solve(A, B)\n    \n    # Extract solutions\n    u_s_sol = x[0:Ns]\n    \n    # Interface displacement u_gamma = u_s(Ls)\n    u_gamma = u_s_sol[-1]\n    \n    # Interface traction t_gamma = a_s * du_s/dx(Ls)\n    # Computed as D_s^T * u_s\n    t_gamma = (Ds.T @ u_s_sol)[0]\n    \n    return u_gamma, t_gamma\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Ls, Lf, Ns, Nf, as, af, qs, qf)\n        (1.0, 1.0, 4, 3, 2.0, 1.0, 1.0, 0.5),\n        (1.0, 2.0, 2, 8, 10.0, 0.1, 0.0, 3.0),\n        (0.5, 0.5, 2, 2, 1.0, 1.0, 1.0, 1.0),\n        (1.5, 0.5, 5, 2, 5.0, 5.0, 0.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        u_gamma, t_gamma = solve_case(*case)\n        results.append(u_gamma)\n        results.append(t_gamma)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice serves as a capstone, integrating the principles of variational formulations to tackle a complex, time-dependent, and non-linear multiphysics problem: dynamic fracture propagation. Phase-field models provide a powerful framework for simulating the evolution of complex topologies, like cracks, without explicit interface tracking, by regularizing sharp discontinuities over a narrow internal length scale, $ \\ell $. In this exercise , you will derive and implement a coupled model for elastodynamics and phase-field fracture, employing a staggered time-stepping scheme that is common in state-of-the-art computational research, and gaining insight into handling the challenges of stiffness degradation, irreversibility constraints, and energy conservation in dynamic rupture simulations.",
            "id": "3618401",
            "problem": "You are tasked with deriving and implementing a weak variational formulation for a one-dimensional, coupled phase-field fracture and linear elastodynamics model relevant to seismic rupture in computational geophysics. The governing model is based on a total energy functional with a phase-field regularization of brittle fracture and a degraded linear elastic strain energy density. You must work in nondimensional variables (unitless), so no physical units are required.\n\nStart from the following fundamental base:\n- Conservation of linear momentum for a one-dimensional bar: $\\rho \\partial_{tt} u - \\partial_x \\sigma = 0$, where $ \\rho $ is mass density, $ u(x,t) $ is the displacement, and $ \\sigma(x,t) $ is the Cauchy stress.\n- Linear elastic constitutive relation degraded by a scalar damage (phase-field) $ d(x,t) \\in [0,1] $: $\\sigma = g(d) E \\varepsilon$, where $ E $ is Young's modulus, $ \\varepsilon = \\partial_x u $ is the small strain, and $g(d) = (1-\\kappa)(1-d)^2 + \\kappa$ is the degradation function with residual stiffness parameter $ \\kappa \\in (0,1) $.\n- Regularized Griffith-type fracture energy with internal length $ \\ell > 0 $ and critical energy release rate $ G_c > 0 $, with total energy density\n$$\n\\mathcal{E}(u,d) = G_c \\left(\\frac{(1-d)^2}{\\ell} + \\ell |\\partial_x d|^2\\right) + \\psi(\\varepsilon,d), \\quad \\psi(\\varepsilon,d) = \\frac{1}{2} g(d) E \\varepsilon^2.\n$$\n\nThe coupled partial differential equation (PDE) system is:\n- Elastodynamics: $ \\rho \\partial_{tt} u - \\partial_x \\left( g(d) E \\partial_x u \\right) = 0 $.\n- Phase-field (quasi-static minimization at each time for $ d $): the Euler–Lagrange equation is obtained by stationarity of $ \\int \\mathcal{E}(u,d) \\, dx $ with respect to $ d $, with homogeneous natural boundary conditions for $ d $.\n\nBoundary and initial conditions are:\n- Displacement boundary conditions (Dirichlet): $u(0,t) = 0$ and $u(L,t) = U_0(t)$, where $ L > 0 $ is the bar length and $ U_0(t) $ is a prescribed, smooth boundary displacement pulse.\n- Phase-field damage $ d(x,t) $ satisfies homogeneous Neumann boundary conditions $\\partial_x d(0,t) = \\partial_x d(L,t) = 0$.\n- Initial conditions: $u(x,0) = 0$, $\\partial_t u(x,0) = 0$, and a small initial flaw for $ d(x,0) $ around the domain center to trigger fracture, specified below.\n\nYour tasks:\n\n1) Derive the weak forms:\n- Starting from the fundamental base, derive the weak form for the elastodynamics equation by multiplying by a test function $ v \\in H_0^1(0,L) $ (functions vanishing at the displacement boundaries) and integrating by parts in space.\n- Derive the weak form for the phase-field equation by taking the first variation of the total energy with respect to $ d $, multiplying by a test function $ \\eta \\in H^1(0,L) $, integrating by parts in space, and identifying the natural boundary conditions.\n\n2) Propose and justify a stable, consistent numerical scheme:\n- Use central differences in time for $ u $ and a finite-volume or finite-element style discretization in space for $ \\partial_x \\left( g(d) E \\partial_x u \\right) $ on a uniform grid with $ N+1 $ nodes over $ [0,L] $.\n- Treat the damage $ d $ quasi-statically at each time step via a linearized Euler–Lagrange equation for $ d $, obtained by substituting $ \\partial \\psi / \\partial d = g'(d) \\, \\frac{E}{2} \\, \\varepsilon^2 $ with $ g'(d) = -2(1-\\kappa)(1-d) $, and rearranging into a linear elliptic problem of the form\n$$\n\\left(\\frac{2 G_c}{\\ell} + (1-\\kappa) E \\varepsilon^2\\right) d - 2 G_c \\ell \\partial_{xx} d = \\left(\\frac{2 G_c}{\\ell} + (1-\\kappa) E \\varepsilon^2\\right).\n$$\n- Enforce $ d \\in [0,1] $ and irreversibility $ d^{n+1}(x) \\ge d^n(x) $ by projecting the solution at each time step onto these constraints via nodal clipping $ d^{n+1} = \\max\\{ d^n, \\min\\{1, \\tilde d^{n+1} \\} \\} $.\n\n3) Implement the following solver in a single program:\n- Spatial domain: $ [0,L] $ with $ L = 1 $. Use $ N+1 $ nodes at positions $ x_i = i h $ for $ i = 0,1,\\dots,N $ with $ h = L/N $.\n- Initial flaw for $ d $: $d(x,0) = d_\\text{seed} \\exp\\left(-\\frac{(x - L/2)^2}{2\\sigma^2}\\right)$ with $ d_\\text{seed} = 0.05 $ and $ \\sigma = 2 \\ell $.\n- Boundary displacement: use a Ricker pulse $U_0(t) = A \\left(1 - 2\\pi^2 f^2 (t - t_0)^2\\right) \\exp\\left(-\\pi^2 f^2 (t - t_0)^2\\right)$ with $ t_0 = 3/f $.\n- Time integration for $ u $: central difference update at interior nodes,\n$$\nu^{n+1}_i = 2 u^n_i - u^{n-1}_i + \\frac{\\Delta t^2}{\\rho} \\left[ \\frac{1}{h} \\left( a_{i+\\frac{1}{2}} \\frac{u^n_{i+1} - u^n_i}{h} - a_{i-\\frac{1}{2}} \\frac{u^n_i - u^n_{i-1}}{h} \\right) \\right], \\quad a = g(d) E,\n$$\nwith $ u^n_0 = 0 $ and $ u^n_N = U_0(t_n) $. Initialize $ u^0_i = 0 $ for all $ i $ and $ u^{-1}_i = u^0_i $.\n- Damage update: solve the linearized elliptic problem at each time step on nodes with homogeneous Neumann conditions using a consistent second-order finite difference approximation of $ \\partial_{xx} d $ including boundary modifications for zero flux. Then project $ d $ to enforce $ d \\in [0,1] $ and irreversibility.\n- Energy diagnostics at each test case final time $ t = n_\\text{steps} \\, \\Delta t $:\n  - Kinetic energy: $ K = \\frac{1}{2} \\rho \\sum_{i=0}^{N} h \\left( \\frac{u^n_i - u^{n-1}_i}{\\Delta t} \\right)^2 $.\n  - Elastic potential energy: approximate on cells $ i = 0,\\dots,N-1 $ with cell strain $ \\varepsilon_i = (u^n_{i+1} - u^n_i)/h $ and cell degradation $g_i = (1-\\kappa)(1 - d_{\\text{cell},i})^2 + \\kappa$ where $d_{\\text{cell},i} = \\frac{1}{2}(d^n_i + d^n_{i+1})$, as\n  $$\n  \\Pi_\\text{el} = \\frac{1}{2} \\sum_{i=0}^{N-1} h \\, g_i \\, E \\, \\varepsilon_i^2 .\n  $$\n  - Fracture energy: nodal part plus gradient part,\n  $$\n  \\Pi_\\text{frac} = \\sum_{i=0}^{N} h \\, G_c \\, \\frac{(1 - d^n_i)^2}{\\ell} + \\sum_{i=0}^{N-1} h \\, G_c \\, \\ell \\left( \\frac{d^n_{i+1} - d^n_i}{h} \\right)^2 .\n  $$\n  - Total energy: $ \\Pi_\\text{tot} = K + \\Pi_\\text{el} + \\Pi_\\text{frac} $.\n- Output per test case: compute the final maximum damage $ d_\\text{max} = \\max_i d^n_i $ and the final total energy $ \\Pi_\\text{tot} $.\n\n4) Test suite and required final output format:\nRun your program for the following three test cases. All variables are nondimensional and unitless.\n\n- Test case 1 (happy path):\n  - $ N = 200 $, $ L = 1 $, $ \\Delta t = 0.004 $, $ n_\\text{steps} = 600 $,\n  - $ E = 1.0 $, $ \\rho = 1.0 $, $ G_c = 0.002 $, $ \\ell = 0.02 $, $ \\kappa = 10^{-6} $,\n  - $ A = 0.001 $, $ f = 4.0 $.\n\n- Test case 2 (smaller internal length, easier localization):\n  - $ N = 200 $, $ L = 1 $, $ \\Delta t = 0.004 $, $ n_\\text{steps} = 600 $,\n  - $ E = 1.0 $, $ \\rho = 1.0 $, $ G_c = 0.0015 $, $ \\ell = 0.01 $, $ \\kappa = 10^{-6} $,\n  - $ A = 0.001 $, $ f = 4.0 $.\n\n- Test case 3 (higher stiffness, near stability limit):\n  - $ N = 200 $, $ L = 1 $, $ \\Delta t = 0.003 $, $ n_\\text{steps} = 700 $,\n  - $ E = 2.0 $, $ \\rho = 1.0 $, $ G_c = 0.0025 $, $ \\ell = 0.02 $, $ \\kappa = 10^{-6} $,\n  - $ A = 0.0008 $, $ f = 5.0 $.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces, in the order\n$ [d_{\\text{max},1}, \\Pi_{\\text{tot},1}, d_{\\text{max},2}, \\Pi_{\\text{tot},2}, d_{\\text{max},3}, \\Pi_{\\text{tot},3}] $,\nwhere the subscript indicates the test case number. All values are floats.",
            "solution": "The user has provided a comprehensive problem statement for a coupled elastodynamics and phase-field fracture model. The problem is scientifically valid, well-posed, and contains all necessary details for derivation and implementation.\n\n### 1. Derivation of the Weak Forms\n\nThe derivation of the weak form, also known as the variational formulation, is achieved by multiplying the governing partial differential equations (PDEs) by suitable test functions and integrating over the spatial domain. This process transfers derivatives from the solution variables ($u, d$) to the test functions, relaxing the smoothness requirements on the solution.\n\n#### 1.1 Elastodynamics Weak Form\n\nThe conservation of linear momentum in one dimension is given by:\n$$\n\\rho \\, \\partial_{tt} u - \\partial_x \\sigma = 0 \\quad \\text{for } x \\in (0, L)\n$$\nwhere $\\rho$ is the mass density, $u(x,t)$ is the displacement, and $\\sigma(x,t)$ is the Cauchy stress. The stress is related to the strain $\\varepsilon = \\partial_x u$ via the damage-degraded constitutive law $\\sigma = g(d) E \\varepsilon$, where $E$ is Young's modulus and $g(d)$ is the degradation function. Substituting the constitutive law into the momentum equation yields:\n$$\n\\rho \\, \\partial_{tt} u - \\partial_x \\left( g(d) E \\, \\partial_x u \\right) = 0\n$$\nTo derive the weak form, we multiply by a test function $v(x)$ and integrate over the domain $[0,L]$. The test function $v$ must belong to a space of functions that satisfy homogeneous versions of the Dirichlet boundary conditions imposed on $u$. Since $u(0,t)=0$ and $u(L,t)=U_0(t)$, the test function $v$ belongs to the Sobolev space $H_0^1(0,L)$, which contains functions that are square-integrable with square-integrable first derivatives, and vanish at the boundaries: $v(0)=0$ and $v(L)=0$.\n\nThe integrated equation is:\n$$\n\\int_0^L \\left( \\rho \\, (\\partial_{tt} u) v - v \\, \\partial_x \\left( g(d) E \\, \\partial_x u \\right) \\right) dx = 0\n$$\nWe apply integration by parts to the second term:\n$$\n\\int_0^L -v \\, \\partial_x \\sigma \\, dx = -[v \\sigma]_0^L + \\int_0^L \\sigma \\partial_x v \\, dx\n$$\nThe boundary term $[v \\sigma]_0^L = v(L)\\sigma(L,t) - v(0)\\sigma(0,t)$ is zero because $v(0)=v(L)=0$. Substituting this back, we obtain the weak form for the elastodynamics equation:\n\nFind $u(\\cdot, t)$ (satisfying the Dirichlet BCs) such that for all test functions $v \\in H_0^1(0,L)$:\n$$\n\\int_0^L \\rho \\, (\\partial_{tt} u) v \\, dx + \\int_0^L \\left( g(d) E \\, \\partial_x u \\right) \\partial_x v \\, dx = 0\n$$\n\n#### 1.2 Phase-Field Weak Form\n\nThe evolution of the phase-field variable $d$ is governed by the stationarity of the total energy functional $I(d) = \\int_0^L \\mathcal{E}(u,d) \\, dx$ at each time step, treating the strain field $\\varepsilon = \\partial_x u$ as a fixed input. The energy density is:\n$$\n\\mathcal{E}(u,d) = G_c \\left( \\frac{(1-d)^2}{\\ell} + \\ell \\, |\\partial_x d|^2 \\right) + \\frac{1}{2} g(d) \\, E \\, \\varepsilon^2\n$$\nThe condition for stationarity is that the first variation of the total energy with respect to $d$ is zero for all admissible variations $\\eta$. Here, the test function $\\eta$ belongs to the space $H^1(0,L)$, as no Dirichlet conditions are imposed on $d$.\n$$\n\\delta I(d)[\\eta] = \\left. \\frac{d}{d\\alpha} I(d+\\alpha\\eta) \\right|_{\\alpha=0} = 0 \\quad \\forall \\eta \\in H^1(0,L)\n$$\nComputing the derivative with respect to $\\alpha$ yields:\n$$\n\\int_0^L \\left[ G_c \\left( \\frac{2(1-d)(-\\eta)}{\\ell} + 2\\ell \\, (\\partial_x d)(\\partial_x \\eta) \\right) + \\frac{1}{2} g'(d)\\eta \\, E \\, \\varepsilon^2 \\right] dx = 0\n$$\nwhere $g'(d) = -2(1-\\kappa)(1-d)$. Rearranging terms, we get the weak form for the phase-field equation:\n\nFind $d(\\cdot, t) \\in H^1(0,L)$ such that for all test functions $\\eta \\in H^1(0,L)$:\n$$\n\\int_0^L \\left( 2 G_c \\ell (\\partial_x d) (\\partial_x \\eta) + \\left[ \\frac{2G_c}{\\ell}(1-d) - \\frac{1}{2}g'(d)E\\varepsilon^2 \\right] \\eta \\right) dx = 0\n$$\nTo identify the natural boundary conditions, we integrate the first term by parts:\n$$\n\\int_0^L \\left( -\\left(2 G_c \\ell \\partial_{xx} d\\right) \\eta + \\left[ \\frac{2G_c}{\\ell}(1-d) - \\frac{1}{2}g'(d)E\\varepsilon^2 \\right] \\eta \\right) dx + [2 G_c \\ell (\\partial_x d) \\eta]_0^L = 0\n$$\nFor this to hold for arbitrary $\\eta$, including those non-zero at the boundaries, the integrand and the boundary term must vanish independently. The boundary term vanishing implies $2 G_c \\ell (\\partial_x d) \\eta \\rvert_{x=L} - 2 G_c \\ell (\\partial_x d) \\eta \\rvert_{x=0} = 0$. Since $\\eta(0)$ and $\\eta(L)$ can be chosen arbitrarily, this requires $\\partial_x d(0,t)=0$ and $\\partial_x d(L,t)=0$. These are the homogeneous Neumann boundary conditions stated in the problem, and they arise naturally from the variational principle.\n\n### 2. Numerical Scheme Justification\n\nThe problem specifies a staggered numerical scheme, which is justified as follows:\n-   **Time Integration for $u$**: The explicit central difference (leapfrog) scheme is second-order accurate in time and computationally inexpensive as it does not require solving a linear system. Its stability is conditional, governed by the Courant-Friedrichs-Lewy (CFL) condition, $\\max(\\sqrt{g(d)E/\\rho}) \\Delta t / h \\le 1$. The parameters provided in the test cases satisfy this condition.\n-   **Spatial Discretization for $u$**: The provided finite difference formula for the elastodynamics equation is a second-order accurate stencil that can be interpreted as a finite volume method. It correctly handles a spatially variable stiffness $a(x) = g(d(x))E$, ensuring local momentum conservation.\n-   **Quasi-static Damage Update**: At each time step, the displacement field provides a strain field. The damage field is then updated by solving the corresponding Euler-Lagrange equation for $d$. This equation, after substituting $g'(d)$, becomes a linear elliptic (Helmholtz-type) equation for $d$ at each time step, assuming the strain $\\varepsilon$ is known:\n    $$\n    \\left( \\frac{2 G_c}{\\ell} + (1-\\kappa) E \\, \\varepsilon^2 \\right) d - 2 G_c \\ell \\, \\partial_{xx} d = \\left( \\frac{2 G_c}{\\ell} + (1-\\kappa) E \\, \\varepsilon^2 \\right)\n    $$\n    This is solved efficiently using a finite difference method for $\\partial_{xx}d$. The use of ghost points to implement homogeneous Neumann boundary conditions is a standard, second-order accurate technique. This results in a tridiagonal linear system which is solved at each time step.\n-   **Irreversibility and Constraints**: Damage is a dissipative process and must be irreversible ($d^{n+1} \\ge d^n$). The phase-field variable is also bounded, $d \\in [0,1]$. These physical constraints are enforced via a projection (clipping) step: $d^{n+1} = \\max\\{ d^n, \\min\\{1, \\tilde d^{n+1} \\} \\}$, where $\\tilde d$ is the solution of the linear system. This is a common and practical approach.\n\n### 3. Implementation\n\nThe implementation follows a time-stepping loop. Within each step:\n1.  The displacement field `u` is updated to the next time level using the central difference scheme, based on the fields from the two previous time levels and the damage field from the previous level.\n2.  The resulting new displacement field is used to compute the strain field.\n3.  The coefficients of the linear system for the damage field `d` are assembled using the new strain field.\n4.  The tridiagonal linear system for `d` is solved.\n5.  The solution is projected to enforce physical constraints on `d`.\n6.  Fields are updated, and the simulation proceeds to the next time step.\n\nAfter the final time step, diagnostic quantities (kinetic, elastic, and fracture energies) are computed as specified, providing a snapshot of the system's state.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the coupled 1D phase-field fracture and elastodynamics problem\n    for a set of test cases.\n    \"\"\"\n    # Test case parameters\n    test_cases = [\n        # Case 1: Happy path\n        {'N': 200, 'L': 1.0, 'dt': 0.004, 'n_steps': 600,\n         'E': 1.0, 'rho': 1.0, 'Gc': 0.002, 'ell': 0.02, 'kappa': 1e-6,\n         'A': 0.001, 'f': 4.0, 'd_seed': 0.05, 'sigma_d_factor': 2.0},\n        # Case 2: Smaller internal length, easier localization\n        {'N': 200, 'L': 1.0, 'dt': 0.004, 'n_steps': 600,\n         'E': 1.0, 'rho': 1.0, 'Gc': 0.0015, 'ell': 0.01, 'kappa': 1e-6,\n         'A': 0.001, 'f': 4.0, 'd_seed': 0.05, 'sigma_d_factor': 2.0},\n        # Case 3: Higher stiffness, near stability limit\n        {'N': 200, 'L': 1.0, 'dt': 0.003, 'n_steps': 700,\n         'E': 2.0, 'rho': 1.0, 'Gc': 0.0025, 'ell': 0.02, 'kappa': 1e-6,\n         'A': 0.0008, 'f': 5.0, 'd_seed': 0.05, 'sigma_d_factor': 2.0}\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        # Unpack parameters\n        N = params['N']\n        L = params['L']\n        dt = params['dt']\n        n_steps = params['n_steps']\n        E = params['E']\n        rho = params['rho']\n        Gc = params['Gc']\n        ell = params['ell']\n        kappa = params['kappa']\n        A = params['A']\n        f = params['f']\n        d_seed = params['d_seed']\n        sigma_d_factor = params['sigma_d_factor']\n        \n        # Spatial grid\n        h = L / N\n        x = np.linspace(0, L, N + 1)\n\n        # Time parameter for Ricker pulse\n        t0 = 3.0 / f\n\n        # Ricker pulse function for boundary displacement\n        def ricker_pulse(t):\n            arg = (np.pi * f * (t - t0))**2\n            return A * (1.0 - 2.0 * arg) * np.exp(-arg)\n\n        # Degradation function\n        def g(d_field):\n            return (1 - kappa) * (1 - d_field)**2 + kappa\n\n        # --- Initialization ---\n        # Displacement fields at t(n-1), t(n), t(n+1)\n        u_nm1 = np.zeros(N + 1)\n        u_n = np.zeros(N + 1)\n        u_n1 = np.zeros(N + 1)\n\n        # Initial damage field (small flaw)\n        sigma_d = sigma_d_factor * ell\n        d_n = d_seed * np.exp(-(x - L / 2)**2 / (2 * sigma_d**2))\n        \n        # --- Time-stepping loop ---\n        for n in range(n_steps):\n            t_n = n * dt\n\n            # Apply displacement BC at time t_n\n            u_n[0] = 0.0\n            u_n[N] = ricker_pulse(t_n)\n\n            # Compute stiffness coefficients a = g(d)E at cell centers\n            d_cell = 0.5 * (d_n[:-1] + d_n[1:])\n            a = g(d_cell) * E\n            \n            # --- Update displacement u ---\n            # Central difference update for interior nodes\n            stress_div = (a[1:] * (u_n[2:] - u_n[1:-1]) - a[:-1] * (u_n[1:-1] - u_n[:-2])) / h**2\n            u_n1[1:-1] = 2 * u_n[1:-1] - u_nm1[1:-1] + (dt**2 / rho) * stress_div\n\n            # Apply displacement BC at time t_{n+1}\n            u_n1[0] = 0.0\n            u_n1[N] = ricker_pulse(t_n + dt)\n\n            # --- Update damage d ---\n            # 1. Compute strain at nodes from u_n1\n            eps = np.zeros(N + 1)\n            eps[1:-1] = (u_n1[2:] - u_n1[:-2]) / (2 * h) # Central difference\n            eps[0] = (u_n1[1] - u_n1[0]) / h          # Forward difference\n            eps[N] = (u_n1[N] - u_n1[N-1]) / h      # Backward difference\n\n            # 2. Assemble and solve the linear system for d_tilde\n            C = (2 * Gc / ell) + (1 - kappa) * E * eps**2\n            b = C.copy() # Right-hand side\n\n            ab = np.zeros((3, N + 1))\n            k_h2 = (2 * Gc * ell) / h**2\n            \n            ab[1, :] = C + 2 * k_h2                          # Main diagonal\n            ab[0, 1:] = -k_h2                                 # Upper diagonal\n            ab[2, :N] = -k_h2                                 # Lower diagonal\n            \n            # Boundary conditions (Neumann) modifications\n            ab[0, 1] = -2 * k_h2                              # A[0,1]\n            ab[2, N-1] = -2 * k_h2                              # A[N,N-1]\n            \n            d_tilde_n1 = solve_banded((1, 1), ab, b)\n            \n            # 3. Project d_tilde to enforce constraints\n            d_n1 = np.maximum(d_n, np.minimum(1.0, d_tilde_n1))\n\n            # --- Prepare for next time step ---\n            u_nm1, u_n = u_n, u_n1\n            d_n = d_n1\n\n        # --- Post-processing: Calculate diagnostics at final step ---\n        v_final = (u_n - u_nm1) / dt\n        K = 0.5 * rho * np.sum(h * v_final**2)\n\n        eps_cell = (u_n[1:] - u_n[:-1]) / h\n        d_cell_final = 0.5 * (d_n[:-1] + d_n[1:])\n        g_cell_final = g(d_cell_final)\n        Pi_el = 0.5 * np.sum(h * g_cell_final * E * eps_cell**2)\n\n        d_grad_sq = ((d_n[1:] - d_n[:-1]) / h)**2\n        term1 = np.sum(h * Gc * (1 - d_n)**2 / ell)\n        term2 = np.sum(h * Gc * ell * d_grad_sq)\n        Pi_frac = term1 + term2\n\n        Pi_tot = K + Pi_el + Pi_frac\n        d_max = np.max(d_n)\n        \n        all_results.extend([d_max, Pi_tot])\n        \n    print(f\"[{','.join(f'{val:.6f}' for val in all_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}