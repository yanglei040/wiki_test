{
    "hands_on_practices": [
        {
            "introduction": "Building a numerical solver from the ground up is an essential skill in computational science. This first practice guides you through deriving the five-point Laplacian stencil directly from Taylor series expansions and implementing it to solve the Poisson equation, $-\\nabla^2 u = q$. You will use the Method of Manufactured Solutions to perform a grid convergence study, providing a rigorous quantitative method to verify that your implementation is correct and achieves its theoretical second-order accuracy .",
            "id": "3596385",
            "problem": "Consider a two-dimensional scalar field $u(x,y)$ defined on a rectangular domain $\\Omega = [x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$. The governing Partial Differential Equation (PDE) is the Poisson equation with homogeneous ellipticity,\n$$\n- \\nabla^2 u(x,y) = q(x,y),\n$$\nwhere $\\nabla^2$ is the Laplacian operator. In the Method of Manufactured Solutions (MMS), one selects an analytic $u(x,y)$ and defines $q(x,y)$ by applying the differential operator to $u(x,y)$ so that the analytic $u(x,y)$ is the exact solution of the continuous PDE. Impose Dirichlet boundary conditions by setting $u(x,y)$ exactly equal to the manufactured solution on $\\partial \\Omega$. All quantities are dimensionless.\n\nYou will derive, implement, and validate the five-point Laplacian stencil on a structured grid for general rectangular domains with possibly anisotropic spacings. Begin from the following fundamental bases:\n- The definition of the Laplacian in Cartesian coordinates, $\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$.\n- The second-order central-difference approximation for one-dimensional second derivatives derived from Taylor expansions about a grid point.\n\nTasks:\n1. Derive the five-point discrete approximation to $-\\nabla^2 u$ at an interior grid node $(x_i,y_j)$ on a rectangular grid with spacings $h_x$ and $h_y$. Use only Taylor expansions and the definition of $\\nabla^2$; do not use pre-assembled or memorized stencil formulas.\n2. Express the resulting linear algebraic system assembling all interior nodes, and describe how Dirichlet boundary values on $\\partial \\Omega$ enter the right-hand side.\n3. Implement a program that, for each test case below, constructs the discrete operator, enforces Dirichlet boundary conditions consistent with the manufactured solution, solves the linear system for the interior unknowns, computes the discrete $L^2$-error norm,\n$$\n\\|e\\|_{L^2} \\approx \\left( h_x h_y \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\left[u_h(x_i,y_j) - u_{\\text{exact}}(x_i,y_j)\\right]^2 \\right)^{1/2},\n$$\nand reports the observed grid-convergence rate\n$$\np = \\frac{\\ln\\left(\\|e\\|_{\\text{coarse}} / \\|e\\|_{\\text{fine}}\\right)}{\\ln(2)},\n$$\nwhere “coarse” and “fine” refer to two successively refined grids obtained by doubling $N_x$ and $N_y$.\n\nImplementation details:\n- Use a structured grid with $N_x$ interior points along $x$ and $N_y$ interior points along $y$. The spacings are $h_x = \\frac{x_{\\max} - x_{\\min}}{N_x + 1}$ and $h_y = \\frac{y_{\\max} - y_{\\min}}{N_y + 1}$. Interior nodes are at $x_i = x_{\\min} + i h_x$ and $y_j = y_{\\min} + j h_y$ for $i=1,\\dots,N_x$ and $j=1,\\dots,N_y$.\n- Assemble the linear system for the interior nodes only, with Dirichlet boundary values entering the right-hand side as appropriate.\n- For each test case, compute the observed rate $p$ using one coarse grid and one fine grid that doubles the number of interior points in each direction.\n\nTest suite:\n- Test Case $1$ (happy path, isotropic grid on square domain):\n  - Domain: $\\Omega = [0,1] \\times [0,1]$.\n  - Manufactured solution: $u_1(x,y) = \\sin(\\pi x)\\sin(\\pi y)$.\n  - Source term: $q_1(x,y) = -\\nabla^2 u_1(x,y)$.\n  - Grids: $(N_x,N_y) = (16,16)$ and $(32,32)$.\n- Test Case $2$ (anisotropic grid spacing on square domain):\n  - Domain: $\\Omega = [0,1] \\times [0,1]$.\n  - Manufactured solution: $u_2(x,y) = e^{x}\\sin(2\\pi y)$.\n  - Source term: $q_2(x,y) = -\\nabla^2 u_2(x,y)$.\n  - Grids: $(N_x,N_y) = (24,12)$ and $(48,24)$.\n- Test Case $3$ (anisotropic domain and grid):\n  - Domain: $\\Omega = [0,2] \\times [0,1]$.\n  - Manufactured solution: $u_3(x,y) = \\cos(2\\pi x)\\cos(\\pi y)$.\n  - Source term: $q_3(x,y) = -\\nabla^2 u_3(x,y)$.\n  - Grids: $(N_x,N_y) = (60,20)$ and $(120,40)$.\n- Test Case $4$ (edge case with very coarse grid):\n  - Domain: $\\Omega = [0,1] \\times [0,1]$.\n  - Manufactured solution: $u_1(x,y) = \\sin(\\pi x)\\sin(\\pi y)$.\n  - Source term: $q_1(x,y) = -\\nabla^2 u_1(x,y)$.\n  - Grids: $(N_x,N_y) = (4,4)$ and $(8,8)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the observed convergence rates for the four test cases as a comma-separated list enclosed in square brackets, with each rate rounded to four decimal digits, for example, $[p_1,p_2,p_3,p_4]$.",
            "solution": "This response adheres to the user's request by first deriving the five-point finite-difference stencil for the two-dimensional negative Laplacian operator, then describing the assembly of the corresponding linear system, and finally detailing the implementation for verifying the method's convergence rate.\n\n### 1. Derivation of the Five-Point Stencil\n\nThe task is to find a discrete approximation for the operator $-\\nabla^2 u$ at an interior grid node $(x_i, y_j)$ of a structured rectangular grid with spacings $h_x$ and $h_y$. The derivation begins from the Taylor series expansion of a sufficiently smooth function $f(z)$ around a point $z$.\n\nConsider the Taylor expansion of $u(x, y)$ in the $x$-direction around the point $(x_i, y_j)$:\n$$u(x_i \\pm h_x, y_j) = u(x_i, y_j) \\pm h_x \\frac{\\partial u}{\\partial x}\\bigg|_{(x_i,y_j)} + \\frac{h_x^2}{2!} \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i,y_j)} \\pm \\frac{h_x^3}{3!} \\frac{\\partial^3 u}{\\partial x^3}\\bigg|_{(x_i,y_j)} + \\frac{h_x^4}{4!} \\frac{\\partial^4 u}{\\partial x^4}\\bigg|_{(x_i,y_j)} + O(h_x^5)$$\nLet $u_{i,j}$ denote the value of the function $u$ at the grid point $(x_i, y_j)$. The expansions for the neighboring points in $x$ are:\n$$u_{i+1,j} = u(x_i+h_x, y_j) = u_{i,j} + h_x \\frac{\\partial u}{\\partial x} + \\frac{h_x^2}{2} \\frac{\\partial^2 u}{\\partial x^2} + \\frac{h_x^3}{6} \\frac{\\partial^3 u}{\\partial x^3} + O(h_x^4)$$\n$$u_{i-1,j} = u(x_i-h_x, y_j) = u_{i,j} - h_x \\frac{\\partial u}{\\partial x} + \\frac{h_x^2}{2} \\frac{\\partial^2 u}{\\partial x^2} - \\frac{h_x^3}{6} \\frac{\\partial^3 u}{\\partial x^3} + O(h_x^4)$$\nAdding these two equations eliminates the odd-order derivative terms:\n$$u_{i+1,j} + u_{i-1,j} = 2u_{i,j} + h_x^2 \\frac{\\partial^2 u}{\\partial x^2} + \\frac{h_x^4}{12} \\frac{\\partial^4 u}{\\partial x^4} + O(h_x^6)$$\nRearranging to solve for the second partial derivative with respect to $x$ yields the second-order central difference formula:\n$$\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i,y_j)} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} - \\frac{h_x^2}{12} \\frac{\\partial^4 u}{\\partial x^4} + O(h_x^4) = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + O(h_x^2)$$\nAn identical derivation for the $y$-direction yields the approximation for the second partial derivative with respect to $y$:\n$$\\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i,y_j)} = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} + O(h_y^2)$$\nThe Laplacian operator in Cartesian coordinates is $\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$. By substituting the finite difference approximations, we obtain the discrete Laplacian at $(x_i,y_j)$:\n$$\\nabla^2 u \\bigg|_{(x_i,y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}$$\nThe governing PDE is $-\\nabla^2 u = q$. Substituting the discrete operator gives the equation at each interior node $(i,j)$:\n$$-\\left( \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} \\right) = q_{i,j}$$\nGrouping terms by their grid location, we arrive at the five-point stencil equation for $-\\nabla^2 u$:\n$$\\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right)u_{i,j} - \\frac{1}{h_x^2}u_{i-1,j} - \\frac{1}{h_x^2}u_{i+1,j} - \\frac{1}{h_y^2}u_{i,j-1} - \\frac{1}{h_y^2}u_{i,j+1} = q_{i,j}$$\nThis equation couples the value at a central node $(i,j)$ to its four immediate neighbors, forming a five-point stencil. The truncation error of this approximation is $O(h_x^2, h_y^2)$, indicating the method is second-order accurate.\n\n### 2. Linear System Assembly\n\nThe discrete equation must be applied to every interior grid node, for $i=1, \\dots, N_x$ and $j=1, \\dots, N_y$. This results in a system of $N = N_x \\times N_y$ linear algebraic equations. To express this system in matrix form, $\\mathbf{A} \\mathbf{u}_h = \\mathbf{b}$, the unknown values $u_{i,j}$ at the interior nodes are arranged into a single column vector $\\mathbf{u}_h$ of length $N$. A standard approach is lexicographical ordering, where nodes are indexed row-by-row (or column-by-column). Using 0-based indexing for implementation, the global index $k$ for node $(i,j)$ (with $i=0, \\dots, N_x-1$ and $j=0, \\dots, N_y-1$) is $k = j \\cdot N_x + i$.\n\nThe matrix $\\mathbf{A}$ is a sparse, symmetric, and positive-definite matrix of size $N \\times N$. Its structure is block-tridiagonal. Each entry of $\\mathbf{A}$ corresponds to the coefficients of the stencil. For an equation centered at node $k=(j,i)$:\n-   The diagonal entry $A_{k,k}$ is the coefficient of $u_{i,j}$: $\\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right)$.\n-   The off-diagonal entries corresponding to neighbors in the $x$-direction, $u_{i-1,j}$ and $u_{i+1,j}$, are placed at $A_{k,k-1}$ and $A_{k,k+1}$ respectively: $-\\frac{1}{h_x^2}$.\n-   The off-diagonal entries corresponding to neighbors in the $y$-direction, $u_{i,j-1}$ and $u_{i,j+1}$, are placed at $A_{k,k-N_x}$ and $A_{k,k+N_x}$ respectively: $-\\frac{1}{h_y^2}$.\n\nDirichlet boundary conditions specify the values of $u$ on the boundary $\\partial\\Omega$. When the stencil for an interior node adjacent to a boundary involves a boundary node, that value is known. This known value is moved to the right-hand side of the equation.\nFor example, for an interior node $(1, j)$ adjacent to the left boundary $x=x_{\\min}$ (where $i=0$), the term involving $u_{0,j}$ is known:\n$$\\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right)u_{1,j} - \\dots = q_{1,j} + \\frac{1}{h_x^2}u_{0,j}$$\nThe term $\\frac{1}{h_x^2}u_{0,j}$ is added to the corresponding element of the right-hand side vector $\\mathbf{b}$.\nThe vector $\\mathbf{b}$ of length $N$ is thus composed of two parts:\n1.  The value of the source function $q(x,y)$ evaluated at each interior node $(x_i, y_j)$.\n2.  Contributions from the known Dirichlet boundary values, transferred from the left-hand side. For a general interior node $(i,j)$, the corresponding element $b_{k}$ in vector $\\mathbf{b}$ is:\n$$b_k = q_{i,j} + \\delta_{i,1}\\frac{u_{0,j}}{h_x^2} + \\delta_{i,N_x}\\frac{u_{N_x+1,j}}{h_x^2} + \\delta_{j,1}\\frac{u_{i,0}}{h_y^2} + \\delta_{j,N_y}\\frac{u_{i,N_y+1}}{h_y^2}$$\nwhere $\\delta_{m,n}$ is the Kronecker delta.\n\n### 3. Implementation and Verification\n\nThe linear system $\\mathbf{A} \\mathbf{u}_h = \\mathbf{b}$ is solved for the vector of unknowns $\\mathbf{u}_h$. Due to the sparse and structured nature of $\\mathbf{A}$, efficient sparse matrix storage formats (e.g., Compressed Sparse Row) and specialized solvers are used.\n\nAfter computing the numerical solution $u_h(x_i, y_j)$, its accuracy is assessed by comparing it to the known manufactured solution $u_{\\text{exact}}(x_i, y_j)$. The discrete $L^2$-error norm is computed as specified:\n$$ \\|e\\|_{L^2} \\approx \\left( h_x h_y \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\left[u_h(x_i,y_j) - u_{\\text{exact}}(x_i,y_j)\\right]^2 \\right)^{1/2} $$\nThe convergence rate $p$ is then determined by comparing the error from a coarse grid, $\\|e\\|_{\\text{coarse}}$, with the error from a refined grid, $\\|e\\|_{\\text{fine}}$, where the number of interior points in each dimension is doubled. The rate is calculated by:\n$$ p = \\frac{\\ln\\left(\\|e\\|_{\\text{coarse}} / \\|e\\|_{\\text{fine}}\\right)}{\\ln(2)} $$\nFor a second-order accurate method like the one derived, the expected value of $p$ is approximately $2$. The program below implements this entire procedure for the specified test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    # Test Case 1 and 4: u(x,y) = sin(pi*x)*sin(pi*y)\n    def u1(x, y):\n        return np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def q1(x, y):\n        return 2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    # Test Case 2: u(x,y) = exp(x)*sin(2*pi*y)\n    def u2(x, y):\n        return np.exp(x) * np.sin(2 * np.pi * y)\n    \n    def q2(x, y):\n        return (4 * np.pi**2 - 1) * np.exp(x) * np.sin(2 * np.pi * y)\n\n    # Test Case 3: u(x,y) = cos(2*pi*x)*cos(pi*y)\n    def u3(x, y):\n        return np.cos(2 * np.pi * x) * np.cos(np.pi * y)\n\n    def q3(x, y):\n        return 5 * np.pi**2 * np.cos(2 * np.pi * x) * np.cos(np.pi * y)\n\n\n    def solve_poisson(domain, Nx, Ny, u_func, q_func):\n        \"\"\"\n        Solves the Poisson equation on a rectangular domain using a five-point stencil.\n\n        Args:\n            domain (tuple): (xmin, xmax, ymin, ymax).\n            Nx (int): Number of interior grid points in x.\n            Ny (int): Number of interior grid points in y.\n            u_func (callable): Manufactured solution u(x, y).\n            q_func (callable): Source term q(x, y) = -Laplacian(u).\n\n        Returns:\n            float: The discrete L2 error norm.\n        \"\"\"\n        xmin, xmax, ymin, ymax = domain\n        N = Nx * Ny\n\n        # Grid setup\n        hx = (xmax - xmin) / (Nx + 1)\n        hy = (ymax - ymin) / (Ny + 1)\n\n        x_int = np.linspace(xmin + hx, xmax - hx, Nx)\n        y_int = np.linspace(ymin + hy, ymax - hy, Ny)\n        X_int, Y_int = np.meshgrid(x_int, y_int, indexing='ij')\n\n        # Assemble the sparse matrix A\n        # The matrix A represents the negative discrete Laplacian operator.\n        # It has 5 non-zero diagonals.\n        main_diag = np.full(N, 2/hx**2 + 2/hy**2)\n        \n        # Off-diagonals for x-derivatives\n        off_diag_x = np.full(N - 1, -1/hx**2)\n        # Zero out connections between rows\n        off_diag_x[Nx-1::Nx] = 0\n\n        # Off-diagonals for y-derivatives\n        off_diag_y = np.full(N - Nx, -1/hy**2)\n        \n        diagonals = [main_diag, off_diag_x, off_diag_x, off_diag_y, off_diag_y]\n        offsets = [0, -1, 1, -Nx, Nx]\n        \n        A = sparse.diags(diagonals, offsets, shape=(N, N), format='csr')\n\n        # Assemble the right-hand side vector b\n        # Start with the source term q at interior points\n        b = q_func(X_int, Y_int).T.flatten() # Transpose to match lexicographical order\n\n        # Add contributions from Dirichlet boundary conditions\n        # Reshape b to 2D for easier indexing\n        b_grid = b.reshape((Ny, Nx))\n        \n        # Bottom boundary (y = ymin, j=0)\n        b_grid[0, :] += (1/hy**2) * u_func(x_int, ymin)\n        # Top boundary (y = ymax, j=Ny-1)\n        b_grid[-1, :] += (1/hy**2) * u_func(x_int, ymax)\n        # Left boundary (x = xmin, i=0)\n        b_grid[:, 0] += (1/hx**2) * u_func(xmin, y_int)\n        # Right boundary (x = xmax, i=Nx-1)\n        b_grid[:, -1] += (1/hx**2) * u_func(xmax, y_int)\n\n        b = b_grid.flatten()\n        \n        # Solve the linear system\n        u_h_flat = spsolve(A, b)\n\n        # Compute the error\n        u_exact_flat = u_func(X_int, Y_int).T.flatten()\n        error_sq = (u_h_flat - u_exact_flat)**2\n        l2_error = np.sqrt(hx * hy * np.sum(error_sq))\n        \n        return l2_error\n\n    test_cases = [\n        {\"domain\": (0, 1, 0, 1), \"u_func\": u1, \"q_func\": q1, \"grids\": ((16, 16), (32, 32))},\n        {\"domain\": (0, 1, 0, 1), \"u_func\": u2, \"q_func\": q2, \"grids\": ((24, 12), (48, 24))},\n        {\"domain\": (0, 2, 0, 1), \"u_func\": u3, \"q_func\": q3, \"grids\": ((60, 20), (120, 40))},\n        {\"domain\": (0, 1, 0, 1), \"u_func\": u1, \"q_func\": q1, \"grids\": ((4, 4), (8, 8))},\n    ]\n\n    results = []\n    for case in test_cases:\n        (Nx_c, Ny_c), (Nx_f, Ny_f) = case[\"grids\"]\n        \n        error_coarse = solve_poisson(case[\"domain\"], Nx_c, Ny_c, case[\"u_func\"], case[\"q_func\"])\n        error_fine = solve_poisson(case[\"domain\"], Nx_f, Ny_f, case[\"u_func\"], case[\"q_func\"])\n        \n        if error_fine > 0 and error_coarse > 0:\n            rate = np.log(error_coarse / error_fine) / np.log(2)\n        else:\n            rate = 0.0 # Or some other indicator of non-convergence\n\n        results.append(rate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.4f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many geophysical problems involve boundaries where a flux is specified, such as water inflow or heat flow, rather than a fixed value. This exercise  moves beyond simple Dirichlet conditions to tackle the implementation of Neumann boundary conditions for a steady-state groundwater flow model governed by the Laplace equation. By implementing and comparing a first-order and a more accurate second-order \"ghost-cell\" method, you will directly assess how the choice of boundary discretization impacts the accuracy of the computed physical flux.",
            "id": "3596436",
            "problem": "Consider steady groundwater flow in a homogeneous, isotropic aquifer occupying a rectangular domain with coordinates $(x,y) \\in [0,L_x] \\times [0,L_y]$. Let the hydraulic conductivity be a positive constant $K$ with units $\\mathrm{m/s}$. The hydraulic head $h(x,y)$ satisfies the Laplace equation derived from Darcy's law, specifically the conservation form $\\nabla \\cdot (K \\nabla h) = 0$ which reduces to the partial differential equation (PDE) $\\nabla^2 h = 0$ when $K$ is spatially constant. Assume three sides have Dirichlet boundary conditions consistent with a manufactured exact solution, and the right boundary at $x=L_x$ has a prescribed Neumann condition representing a normal flux that varies linearly along $y$.\n\nThe manufactured solution is $h(x,y) = A x + B y + C x y$, which satisfies $\\nabla^2 h = 0$ for all constants $A$, $B$, and $C$. The Dirichlet boundary conditions are enforced at $x=0$, $y=0$, and $y=L_y$, by prescribing $h(0,y)$, $h(x,0)$, and $h(x,L_y)$ from the manufactured solution values. At the right boundary $x=L_x$, the Neumann boundary condition prescribes the normal flux $q_n(y)$ via $-K \\, \\partial h / \\partial x \\big|_{x=L_x} = -K \\left(A + C y\\right)$.\n\nYour task is to discretize the PDE on a uniform Cartesian grid with $N_x$ nodes in the $x$-direction and $N_y$ nodes in the $y$-direction using the standard five-point Laplacian stencil, and to implement two distinct treatments of the Neumann boundary at $x=L_x$ for the discrete operator:\n\n- One-sided difference (OSD): approximate the missing neighbor in the positive $x$ direction using a first-order one-sided difference that enforces the Neumann boundary condition by substituting $h_{i+1,j} = h_{i,j} + \\Delta x \\, \\partial h / \\partial x \\big|_{x=L_x,y_j}$ in the discrete second derivative in $x$, where $\\Delta x = L_x/(N_x-1)$ and $y_j = j \\Delta y$, $\\Delta y = L_y/(N_y-1)$. This leads to the discrete $x$-contribution at the right boundary node being $(h_{i-1,j} - h_{i,j})/\\Delta x^2 + (\\partial h / \\partial x)/\\Delta x$.\n- Ghost-cell reflection (GCR): approximate the missing neighbor using a reflected value across the boundary that enforces the Neumann condition in a way that preserves a central difference structure by substituting $h_{i+1,j} = h_{i-1,j} + 2 \\Delta x \\, \\partial h / \\partial x \\big|_{x=L_x,y_j}$ in the discrete second derivative in $x$. This leads to the discrete $x$-contribution at the right boundary node being $(2 h_{i-1,j} - 2 h_{i,j})/\\Delta x^2 + 2 (\\partial h / \\partial x)/\\Delta x$.\n\nIn both treatments, the $y$-direction second derivative is discretized with the standard central difference $(h_{i,j+1} - 2 h_{i,j} + h_{i,j-1})/\\Delta y^2$, with Dirichlet boundary values at $y=0$ and $y=L_y$ inserted where needed. For interior nodes, use the canonical five-point Laplacian $(h_{i+1,j} - 2 h_{i,j} + h_{i-1,j})/\\Delta x^2 + (h_{i,j+1} - 2 h_{i,j} + h_{i,j-1})/\\Delta y^2 = 0$, with Dirichlet values applied on the left, bottom, and top boundaries.\n\nAfter solving the linear system for $h$ under each Neumann treatment, assess the accuracy of the boundary flux on the right boundary by computing the discrete normal flux using a one-sided interior difference for both methods, $q_n^{\\mathrm{num}}(y_j) = -K \\, \\left(h_{N_x-1,j} - h_{N_x-2,j}\\right)/\\Delta x$, and compare it to the exact boundary flux $q_n^{\\mathrm{exact}}(y_j) = -K \\left(A + C y_j\\right)$. For each case, report the maximum absolute flux error along the right boundary, $\\max_{j} \\left| q_n^{\\mathrm{num}}(y_j) - q_n^{\\mathrm{exact}}(y_j) \\right|$, in units of $\\mathrm{m/s}$.\n\nImplement a complete, runnable program that:\n- Constructs and solves the discrete system for both OSD and GCR boundary treatments as specified.\n- Computes the maximum boundary flux error for each method in units of $\\mathrm{m/s}$.\n\nUse the following test suite of parameter sets, with all lengths in $\\mathrm{m}$ and $K$ in $\\mathrm{m/s}$:\n- Case $\\#1$ (happy path): $(N_x,N_y,L_x,L_y,K,A,B,C) = (41,41,1,1,1,1,0.2,0.5)$.\n- Case $\\#2$ (coarse grid boundary-stress test): $(N_x,N_y,L_x,L_y,K,A,B,C) = (5,5,1,1,1,1,0.3,0.8)$.\n- Case $\\#3$ (constant right-boundary flux): $(N_x,N_y,L_x,L_y,K,A,B,C) = (31,31,1,1,1,1,0.1,0)$.\n- Case $\\#4$ (anisotropic grid spacing): $(N_x,N_y,L_x,L_y,K,A,B,C) = (60,30,2,1,1,0.5,0.4,0.7)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8]$), where $r_{2k-1}$ is the maximum flux error for OSD in case $k$ and $r_{2k}$ is the maximum flux error for GCR in case $k$, each value expressed as a floating-point number in $\\mathrm{m/s}$.",
            "solution": "The user wants to solve the two-dimensional steady-state groundwater flow equation, which is the Laplace equation $\\nabla^2 h = 0$, on a rectangular domain $[0,L_x] \\times [0,L_y]$. The problem is discretized using a finite difference method on a uniform Cartesian grid. The boundary conditions are of a mixed type: Dirichlet conditions are specified on three sides ($x=0$, $y=0$, $y=L_y$), and a Neumann condition is specified on the fourth side ($x=L_x$). The values for the boundary conditions are derived from a known manufactured solution $h(x,y) = A x + B y + C x y$, which is an exact solution to the Laplace equation.\n\nThe core of the task is to implement and compare two different numerical treatments for the Neumann boundary condition at $x=L_x$: a first-order accurate one-sided difference (OSD) and a second-order accurate ghost-cell reflection (GCR) method. For each method, we need to solve the resulting system of linear equations for the hydraulic head $h$ at the grid nodes. Finally, we must assess the accuracy of each method by calculating the maximum absolute error in the computed normal flux along the Neumann boundary, compared to the exact flux derived from the manufactured solution.\n\nThe solution procedure is as follows:\n\n1.  **Grid and System Setup**: For each test case, we define a uniform grid with $N_x \\times N_y$ nodes. The grid spacings are $\\Delta x = L_x/(N_x-1)$ and $\\Delta y = L_y/(N_y-1)$. The unknowns in our system are the values of $h$ at the interior grid nodes and at the nodes on the Neumann boundary, excluding the corners which are fixed by Dirichlet conditions. This gives a total of $(N_x-1) \\times (N_y-2)$ unknowns. We will map the two-dimensional grid indices $(i,j)$ of these unknown nodes to a single one-dimensional index $k$ to form a vector of unknowns.\n\n2.  **Discretization and Matrix Assembly**: We construct a sparse linear system of equations, $\\mathbf{M} \\mathbf{h} = \\mathbf{b}$, where $\\mathbf{h}$ is the vector of unknown head values. For each unknown node $(i,j)$, we write a finite difference equation.\n    -   For interior nodes ($1 \\le i < N_x-1$, $1 \\le j < N_y-2$), we use the standard five-point stencil for the Laplacian:\n        $$\n        \\frac{h_{i+1,j} - 2h_{i,j} + h_{i-1,j}}{\\Delta x^2} + \\frac{h_{i,j+1} - 2h_{i,j} + h_{i,j-1}}{\\Delta y^2} = 0\n        $$\n        Terms involving nodes on Dirichlet boundaries are known and moved to the right-hand side vector $\\mathbf{b}$.\n    -   For nodes on the Neumann boundary ($i = N_x-1$, $1 \\le j < N_y-2$), the discretization of $\\partial^2h/\\partial x^2$ is modified to incorporate the flux condition $\\partial h/\\partial x \\big|_{x=L_x} = A + C y_j$.\n        -   **OSD Treatment**: The $x$-derivative term is approximated as:\n            $$\n            \\frac{h_{i-1,j} - h_{i,j}}{\\Delta x^2} + \\frac{1}{\\Delta x}\\left(\\frac{\\partial h}{\\partial x}\\right)_{i,j}\n            $$\n            This is substituted into the PDE, yielding one row of the linear system.\n        -   **GCR Treatment**: The $x$-derivative term uses a ghost-cell approach, resulting in the approximation:\n            $$\n            \\frac{2h_{i-1,j} - 2h_{i,j}}{\\Delta x^2} + \\frac{2}{\\Delta x}\\left(\\frac{\\partial h}{\\partial x}\\right)_{i,j}\n            $$\n            This is also substituted into the PDE for the corresponding row of the system.\n\n3.  **Solving the System**: The resulting sparse linear system $\\mathbf{M} \\mathbf{h} = \\mathbf{b}$ is solved for $\\mathbf{h}$ using a direct sparse solver from the `scipy.sparse.linalg` library.\n\n4.  **Reconstruction of the Solution**: The solution vector $\\mathbf{h}$ is reshaped and placed into a full $N_x \\times N_y$ grid. The known values from the Dirichlet boundary conditions are then enforced on this grid to obtain the complete numerical solution.\n\n5.  **Flux Error Calculation**: The accuracy of the solution is evaluated by comparing the numerically computed flux on the right boundary with the exact flux.\n    -   The numerical flux at each node $j$ on the boundary $x=L_x$ is calculated using a first-order, one-sided interior difference:\n        $$\n        q_{n,j}^{\\mathrm{num}} = -K \\frac{h_{N_x-1,j} - h_{N_x-2,j}}{\\Delta x}\n        $$\n    -   The exact flux at node $j$ is given by:\n        $$\n        q_{n,j}^{\\mathrm{exact}} = -K (A + C y_j)\n        $$\n    -   The error is the maximum absolute difference between the numerical and exact flux values over all nodes on the right boundary:\n        $$\n        \\text{Error} = \\max_{j} \\left| q_{n,j}^{\\mathrm{num}} - q_{n,j}^{\\mathrm{exact}} \\right|\n        $$\nThis entire process is repeated for each of the four test cases provided, for both the OSD and GCR methods, and the resulting eight error values are collected.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve_case(params, method):\n    \"\"\"\n    Solves the 2D Laplace equation for a single test case and boundary treatment method.\n\n    Args:\n        params (tuple): A tuple containing (Nx, Ny, Lx, Ly, K, A, B, C).\n        method (str): The Neumann boundary treatment method, either 'OSD' or 'GCR'.\n\n    Returns:\n        float: The maximum absolute flux error on the right boundary.\n    \"\"\"\n    Nx, Ny, Lx, Ly, K, A, B, C = params\n\n    if Nx  3 or Ny  3:\n        # If Ny  3, there are no interior nodes in the y-direction, thus num_unknowns is 0.\n        # The flux error at the corners is analytically zero, so the max error is 0.\n        return 0.0\n\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n    x = np.linspace(0, Lx, Nx, dtype=np.float64)\n    y = np.linspace(0, Ly, Ny, dtype=np.float64)\n\n    num_unknowns = (Nx - 1) * (Ny - 2)\n    M = lil_matrix((num_unknowns, num_unknowns), dtype=np.float64)\n    b = np.zeros(num_unknowns, dtype=np.float64)\n\n    # Map grid indices (i, j) of an unknown to a single vector index k.\n    # i corresponds to x-index [1, Nx-1], j to y-index [1, Ny-2].\n    def to_k(i, j):\n        return (i - 1) * (Ny - 2) + (j - 1)\n\n    # Assemble the linear system M*h = b\n    for i in range(1, Nx):\n        for j in range(1, Ny - 1):\n            k = to_k(i, j)\n            \n            # Y-direction contribution (central difference)\n            M[k, k] += -2.0 / dy**2\n            if j == 1:  # Neighbor on bottom Dirichlet boundary (y=0)\n                h_bound = A * x[i]\n                b[k] -= h_bound / dy**2\n            else:\n                k_jm1 = to_k(i, j - 1)\n                M[k, k_jm1] += 1.0 / dy**2\n\n            if j == Ny - 2:  # Neighbor on top Dirichlet boundary (y=Ly)\n                h_bound = A * x[i] + B * Ly + C * x[i] * Ly\n                b[k] -= h_bound / dy**2\n            else:\n                k_jp1 = to_k(i, j + 1)\n                M[k, k_jp1] += 1.0 / dy**2\n\n            # X-direction contribution\n            if i  Nx - 1:  # Interior node in x-direction\n                M[k, k] += -2.0 / dx**2\n                if i == 1:  # Neighbor on left Dirichlet boundary (x=0)\n                    h_bound = B * y[j]\n                    b[k] -= h_bound / dx**2\n                else:\n                    k_im1 = to_k(i - 1, j)\n                    M[k, k_im1] += 1.0 / dx**2\n                \n                k_ip1 = to_k(i + 1, j)\n                M[k, k_ip1] += 1.0 / dx**2\n            \n            else:  # i == Nx - 1, node is on the right Neumann boundary\n                dhdx = A + C * y[j]\n                k_im1 = to_k(i - 1, j)\n                \n                if method == 'OSD':\n                    M[k, k] += -1.0 / dx**2\n                    M[k, k_im1] += 1.0 / dx**2\n                    b[k] -= dhdx / dx\n                elif method == 'GCR':\n                    M[k, k] += -2.0 / dx**2\n                    M[k, k_im1] += 2.0 / dx**2\n                    b[k] -= 2.0 * dhdx / dx\n\n    # Solve the sparse linear system\n    M_csr = M.tocsr()\n    h_unknown = spsolve(M_csr, b)\n\n    # Reconstruct the full solution grid h_full[i, j]\n    h_full = np.zeros((Nx, Ny), dtype=np.float64)\n\n    # Fill in the solved unknown values\n    h_unknown_grid = h_unknown.reshape((Nx - 1, Ny - 2), order='C')\n    h_full[1:Nx, 1:Ny - 1] = h_unknown_grid\n\n    # Apply Dirichlet boundary conditions to the full grid\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    h_full[0, :] = B * Y[0, :]\n    h_full[:, 0] = A * X[:, 0]\n    h_full[:, Ny - 1] = A * X[:, Ny - 1] + B * Ly + C * X[:, Ny - 1] * Ly\n\n    # Calculate numerical flux on the right boundary (x=Lx)\n    h_right_boundary = h_full[Nx - 1, :]\n    h_second_to_right = h_full[Nx - 2, :]\n    q_num = -K * (h_right_boundary - h_second_to_right) / dx\n\n    # Calculate exact flux on the right boundary\n    q_exact = -K * (A + C * y)\n    \n    # Compute the maximum absolute error\n    max_error = np.max(np.abs(q_num - q_exact))\n    \n    return max_error\n    \ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (41, 41, 1.0, 1.0, 1.0, 1.0, 0.2, 0.5),\n        (5, 5, 1.0, 1.0, 1.0, 1.0, 0.3, 0.8),\n        (31, 31, 1.0, 1.0, 1.0, 1.0, 0.1, 0.0),\n        (60, 30, 2.0, 1.0, 1.0, 0.5, 0.4, 0.7)\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate max flux error for One-Sided Difference (OSD)\n        error_osd = solve_case(case, 'OSD')\n        results.append(error_osd)\n\n        # Calculate max flux error for Ghost-Cell Reflection (GCR)\n        error_gcr = solve_case(case, 'GCR')\n        results.append(error_gcr)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Geological media are often anisotropic, meaning their properties, like hydraulic or thermal conductivity, vary with direction. This advanced practice addresses the challenging scenario where the principal axes of the conductivity tensor $\\mathbf{K}$ are not aligned with the computational grid, a common situation in modeling fractured or layered rock. You will discover the limitations of a standard five-point stencil and then implement a sophisticated \"rotated stencil\" correction using local interpolation, providing a powerful method to maintain accuracy for the operator $\\nabla \\cdot (\\mathbf{K} \\nabla u)$ without resorting to a more complex nine-point stencil .",
            "id": "3596408",
            "problem": "Consider the two-dimensional anisotropic diffusion operator in divergence form, defined for a sufficiently smooth scalar field $u(x,y)$ by\n$$\n\\mathcal{L}[u] \\equiv \\nabla \\cdot \\left( \\mathbf{K} \\, \\nabla u \\right),\n$$\nwhere $\\mathbf{K}$ is a constant, symmetric, positive-definite tensor of hydraulic/thermal conductivity with principal values $k_x$ and $k_y$. In the principal-axis frame, $\\mathbf{K}=\\mathrm{diag}(k_x,k_y)$. Suppose the principal axes are rotated by an angle $\\theta$ (in radians) relative to the Cartesian grid directions. In many geophysical flows, such anisotropic diffusion arises from layered media or fracture sets whose permeability tensor is diagonal in a rotated frame.\n\nYour tasks are to proceed from first principles to construct, assess, and amend a five-point discretization that remains grid-aligned yet remains predictive for rotated anisotropy, without introducing a nine-point stencil. The computational domain is periodic on $[0,1]\\times[0,1]$. Angles must be interpreted in radians. There are no physical units in this problem; treat all quantities as dimensionless.\n\nStarting from the fundamental definitions of gradient and divergence and the chain rule for rotations of coordinates, do the following:\n\n- Derive, at the continuous level, the relation between the rotated-tensor operator in the global frame and the principal-axis tensor $\\mathrm{diag}(k_x,k_y)$ rotated by $\\theta$. Express the operator acting on a single real Fourier mode of the form $u(x,y)=\\cos\\!\\left(2\\pi\\,(m\\,x+n\\,y)\\right)$, where $m$ and $n$ are integers, as a scalar multiple of $u(x,y)$. Do not assume any special alignment between $(m,n)$ and the grid axes.\n\n- On a uniform periodic grid with $N\\times N$ nodes and grid spacing $h=1/N$, implement the classical five-point discrete operator that aligns fluxes with the grid directions and uses central second differences. For constant $\\mathbf{K}$ that is diagonal in the grid-aligned frame, this operator reduces to a weighted sum of second differences in $x$ and $y$. Using the rotated tensor from the previous item, define a baseline five-point discrete operator that ignores mixed derivatives and acts as a grid-aligned approximation to the rotated continuous operator.\n\n- Quantify the error of the baseline five-point operator by comparing its action on $u(x,y)=\\cos\\!\\left(2\\pi\\,(m\\,x+n\\,y)\\right)$ to the exact continuous operator derived above, using the relative $\\ell^2$ error\n$$\n\\varepsilon \\equiv \\left( \\frac{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left( \\mathcal{L}_h[u]_{i,j}-\\mathcal{L}[u]_{i,j} \\right)^2}{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left(\\mathcal{L}[u]_{i,j}\\right)^2} \\right)^{1/2}.\n$$\n\n- Propose and implement a rotated-stencil correction that does not introduce a nine-point stencil. Your correction must be derived from first principles and must preserve the use of a five-point core for second differences, but it may evaluate those differences along the principal directions via local rotation. Concretely, compute directional second differences along the two principal directions using central differences with step size $h$ in the rotated frame. Because the principal directions are not grid-aligned, approximate the required off-grid samples of $u$ using periodic bilinear interpolation from the four nearest grid nodes. Combine the two directional second differences with the principal diffusivities $k_x$ and $k_y$ to approximate $\\mathcal{L}[u]$. This realizes a rotated-stencil correction without explicitly introducing a nine-point stencil of fixed grid-aligned points.\n\n- Using the above, evaluate the baseline and corrected discrete operators for the test function $u(x,y)=\\cos\\!\\left(2\\pi\\,(m\\,x+n\\,y)\\right)$ and report the relative $\\ell^2$ errors. Compute, for each test case, the baseline error, the corrected error, and the improvement factor defined as the ratio of baseline error to corrected error. Also report a boolean indicating whether the corrected error is strictly smaller than the baseline error.\n\nYour program must implement all computations on a periodic grid, perform all interpolation with periodic wrapping, and produce results for the following test suite:\n\n- Test case $1$: $N=64$, $k_x=2.0$, $k_y=1.0$, $\\theta=0.0$, $m=3$, $n=2$.\n- Test case $2$: $N=64$, $k_x=2.0$, $k_y=1.0$, $\\theta=\\pi/6$, $m=3$, $n=2$.\n- Test case $3$: $N=64$, $k_x=10.0$, $k_y=1.0$, $\\theta=\\pi/4$, $m=2$, $n=1$.\n- Test case $4$: $N=64$, $k_x=1.0$, $k_y=1.0$, $\\theta=\\pi/3$, $m=4$, $n=3$.\n\nFor each test case, the result must be a list of four items in the order: baseline error (float), corrected error (float), improvement factor (float), improved flag (boolean). All floats must be rounded to $8$ decimal places. The final output format must be a single line containing the list of per-test-case results as a comma-separated list enclosed in square brackets. For example, the output must look like\n$[ [e_{11}, e_{12}, e_{13}, b_1], [e_{21}, e_{22}, e_{23}, b_2], [e_{31}, e_{32}, e_{33}, b_3], [e_{41}, e_{42}, e_{43}, b_4] ]$\nwith no spaces in the printed line. Replace each $e_{ij}$ by the corresponding rounded float and $b_i$ by the corresponding boolean value.",
            "solution": "The problem requires the construction and validation of two finite difference schemes for the two-dimensional anisotropic diffusion operator, $\\mathcal{L}[u] \\equiv \\nabla \\cdot \\left( \\mathbf{K} \\, \\nabla u \\right)$. The conductivity tensor $\\mathbf{K}$ is constant, symmetric, and positive-definite, with principal values $k_x$ and $k_y$ in a coordinate system rotated by an angle $\\theta$ relative to the Cartesian grid. The solution proceeds by first analyzing the continuous operator, then defining a naive baseline discrete operator and a more sophisticated corrected operator, and finally comparing their accuracy on a given test function.\n\nFirst, we derive the explicit form of the continuous operator $\\mathcal{L}[u]$ in the standard Cartesian grid frame $(x,y)$. The transformation of the rank-$2$ conductivity tensor from its principal-axis frame (denoted by a prime) to the grid frame is given by the congruence transformation $\\mathbf{K} = \\mathbf{R}(\\theta) \\mathbf{K}' \\mathbf{R}(\\theta)^T$, where $\\mathbf{K}' = \\mathrm{diag}(k_x, k_y)$ and $\\mathbf{R}(\\theta)$ is the standard rotation matrix.\n$$\n\\mathbf{R}(\\theta) = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix}\n$$\nLetting $c = \\cos\\theta$ and $s = \\sin\\theta$, the tensor $\\mathbf{K}$ in the grid frame is:\n$$\n\\mathbf{K} = \\begin{pmatrix} c  -s \\\\ s  c \\end{pmatrix} \\begin{pmatrix} k_x  0 \\\\ 0  k_y \\end{pmatrix} \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix} = \\begin{pmatrix} k_x c^2 + k_y s^2  (k_x - k_y)sc \\\\ (k_x - k_y)sc  k_x s^2 + k_y c^2 \\end{pmatrix}\n$$\nLet the components of $\\mathbf{K}$ in the grid frame be $K_{11}$, $K_{12} = K_{21}$, and $K_{22}$. Since $\\mathbf{K}$ has constant entries, the operator $\\mathcal{L}[u]$ expands to:\n$$\n\\mathcal{L}[u] = \\nabla \\cdot (\\mathbf{K} \\nabla u) = \\partial_x(K_{11} \\partial_x u + K_{12} \\partial_y u) + \\partial_y(K_{21} \\partial_x u + K_{22} \\partial_y u) = K_{11} \\partial^2_{xx} u + 2 K_{12} \\partial^2_{xy} u + K_{22} \\partial^2_{yy} u\n$$\nWe apply this operator to the specified test function, a single Fourier mode $u(x,y) = \\cos(2\\pi(mx+ny))$. Let $\\phi(x,y) = 2\\pi(mx+ny)$. The required second partial derivatives are $\\partial^2_{xx} u = -(2\\pi m)^2 u$, $\\partial^2_{yy} u = -(2\\pi n)^2 u$, and $\\partial^2_{xy} u = -(2\\pi)^2 mn u$. Substituting these into the expression for $\\mathcal{L}[u]$ shows that $u(x,y)$ is an eigenfunction of the continuous operator:\n$$\n\\mathcal{L}[u] = -(2\\pi)^2 \\left[ K_{11}m^2 + 2 K_{12} mn + K_{22}n^2 \\right] u(x,y)\n$$\nThis can be expressed more compactly using the wavevector $\\mathbf{p} = 2\\pi(m, n)^T$, such that $\\mathcal{L}[u] = -(\\mathbf{p}^T \\mathbf{K} \\mathbf{p}) u$. This analytical result provides the exact reference solution on the grid, against which discrete approximations will be compared.\n\nSecond, we formulate the baseline five-point discrete operator, $\\mathcal{L}_{h, \\text{base}}$. As stipulated, this operator is aligned with the grid and is derived by ignoring the mixed derivative term $2 K_{12} \\partial^2_{xy} u$ that arises from the rotation of the anisotropy tensor. The resulting approximate operator is:\n$$\n\\mathcal{L}_{\\text{base}}[u] \\approx K_{11} \\partial^2_{xx} u + K_{22} \\partial^2_{yy} u\n$$\nUsing standard second-order central differences on a uniform periodic grid with spacing $h=1/N$, we obtain the discrete operator at a grid node $(i,j)$:\n$$\n\\mathcal{L}_{h, \\text{base}}[u]_{i,j} = K_{11} \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + K_{22} \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\n$$\nwhere $u_{i,j} = u(ih, jh)$ and all indices are handled periodically. This operator is computationally efficient but is formally inconsistent whenever $K_{12} \\neq 0$ (i.e., for $\\theta$ not a multiple of $\\pi/2$ and $k_x \\neq k_y$), as it omits a term from the governing partial differential equation.\n\nThird, we design the corrected discrete operator, $\\mathcal{L}_{h, \\text{corr}}$, which circumvents this inconsistency by discretizing the operator in its natural principal-axis frame. In this $(x', y')$ frame, the operator simplifies to:\n$$\n\\mathcal{L}[u] = k_x \\frac{\\partial^2 u}{\\partial (x')^2} + k_y \\frac{\\partial^2 u}{\\partial (y')^2}\n$$\nThe unit vectors along these principal axes are $\\mathbf{e}'_1 = (\\cos\\theta, \\sin\\theta)^T$ and $\\mathbf{e}'_2 = (-\\sin\\theta, \\cos\\theta)^T$. We approximate the second directional derivatives using central differences with step size $h$:\n$$\n\\frac{\\partial^2 u}{\\partial (x')^2} \\bigg|_P \\approx \\frac{u(P+h\\mathbf{e}'_1) - 2u(P) + u(P-h\\mathbf{e}'_1)}{h^2}, \\quad \\frac{\\partial^2 u}{\\partial (y')^2} \\bigg|_P \\approx \\frac{u(P+h\\mathbf{e}'_2) - 2u(P) + u(P-h\\mathbf{e}'_2)}{h^2}\n$$\nwhere $P=(x_i, y_j)$ is a grid node. The evaluation points $P \\pm h\\mathbf{e}'_1$ and $P \\pm h\\mathbf{e}'_2$ are generally not located on the grid. To evaluate $u$ at these off-grid locations, we employ periodic bilinear interpolation using the values at the four surrounding grid nodes. For a point $(x,y)$ in the domain $[0,1) \\times [0,1)$, we find its integer grid cell neighbors $(i_1, j_1), ((i_1+1)\\%N, j_1), (i_1, (j_1+1)\\%N), ((i_1+1)\\%N, (j_1+1)\\%N)$ and the fractional distances $\\alpha$ and $\\beta$. The interpolated value $u_{\\text{interp}}$ is then:\n$$\nu_{\\text{interp}}(x,y) = (1-\\alpha)(1-\\beta)u_{i_1,j_1} + \\alpha(1-\\beta)u_{i_2,j_1} + (1-\\alpha)\\beta u_{i_1,j_2} + \\alpha\\beta u_{i_2,j_2}\n$$\nThe corrected operator combines these pieces:\n$$\n\\mathcal{L}_{h, \\text{corr}}[u]_{i,j} = k_x \\left( \\frac{u_{\\text{interp}}(P+h\\mathbf{e}'_1) - 2u_{i,j} + u_{\\text{interp}}(P-h\\mathbf{e}'_1)}{h^2} \\right) + k_y \\left( \\frac{u_{\\text{interp}}(P+h\\mathbf{e}'_2) - 2u_{i,j} + u_{\\text{interp}}(P-h\\mathbf{e}'_2)}{h^2} \\right)\n$$\nThis formulation provides a consistent approximation to the original operator, as its error sources are the standard truncation error of the central difference and the error from the bilinear interpolation, both of which diminish as $h \\to 0$.\n\nFinally, the accuracy of both discrete operators is quantified using the relative $\\ell^2$ error, $\\varepsilon$. For a given discrete operator $\\mathcal{L}_h$, the error is calculated as:\n$$\n\\varepsilon = \\left( \\frac{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left( \\mathcal{L}_h[u]_{i,j}-\\mathcal{L}[u]_{i,j} \\right)^2}{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left(\\mathcal{L}[u]_{i,j}\\right)^2} \\right)^{1/2}\n$$\nwhere $\\mathcal{L}[u]_{i,j}$ is the exact continuous operator evaluated at grid node $(i,j)$. This metric is computed for both $\\mathcal{L}_{h, \\text{base}}$ and $\\mathcal{L}_{h, \\text{corr}}$, and their performance is compared via the improvement factor, defined as the ratio of the baseline error to the corrected error.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the anisotropic diffusion problem for a suite of test cases.\n    It computes errors for a baseline and a corrected finite difference scheme.\n    \"\"\"\n    test_cases = [\n        # (N, kx, ky, theta, m, n)\n        (64, 2.0, 1.0, 0.0, 3, 2),\n        (64, 2.0, 1.0, np.pi/6, 3, 2),\n        (64, 10.0, 1.0, np.pi/4, 2, 1),\n        (64, 1.0, 1.0, np.pi/3, 4, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_single_case(*case)\n        results.append(result)\n\n    # Format the final output string as a list of lists.\n    # The default string representation for Python lists and booleans is used.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_single_case(N, kx, ky, theta, m, n):\n    \"\"\"\n    Computes numerical solutions and errors for a single test case.\n    \"\"\"\n    h = 1.0 / N\n    x = np.arange(N) * h\n    # Create a 2D grid of coordinates\n    xx, yy = np.meshgrid(x, x, indexing='ij')\n\n    # The test function evaluated on the grid\n    u_grid = np.cos(2 * np.pi * (m * xx + n * yy))\n\n    # --- 1. Exact Continuous Operator Evaluation ---\n    c, s = np.cos(theta), np.sin(theta)\n    \n    # Components of the conductivity tensor K in the grid-aligned frame\n    K11 = kx * c**2 + ky * s**2\n    K12 = (kx - ky) * s * c\n    K22 = kx * s**2 + ky * c**2\n    \n    # Eigenvalue of the continuous operator for the given Fourier mode\n    lambda_exact = -(2 * np.pi)**2 * (K11 * m**2 + 2 * K12 * m * n + K22 * n**2)\n    \n    # Exact operator applied to the test function on the grid\n    L_u_exact = lambda_exact * u_grid\n\n    # --- 2. Baseline Five-Point Operator ---\n    # Central difference approximation for d^2u/dx^2 (periodic)\n    uxx = (np.roll(u_grid, -1, axis=0) - 2 * u_grid + np.roll(u_grid, 1, axis=0)) / h**2\n    # Central difference approximation for d^2u/dy^2 (periodic)\n    uyy = (np.roll(u_grid, -1, axis=1) - 2 * u_grid + np.roll(u_grid, 1, axis=1)) / h**2\n    \n    # Baseline operator application (ignores mixed derivatives)\n    L_h_base_u = K11 * uxx + K22 * uyy\n\n    # --- 3. Corrected Rotated-Stencil Operator ---\n    # Principal direction vectors\n    e1 = np.array([c, s])\n    e2 = np.array([-s, c])\n\n    # Coordinates of points for directional derivatives\n    x_p1, y_p1 = xx + h * e1[0], yy + h * e1[1]\n    x_m1, y_m1 = xx - h * e1[0], yy - h * e1[1]\n    x_p2, y_p2 = xx + h * e2[0], yy + h * e2[1]\n    x_m2, y_m2 = xx - h * e2[0], yy - h * e2[1]\n    \n    # Interpolate u at off-grid points\n    u_p1 = _bilinear_interpolate(x_p1, y_p1, u_grid, h, N)\n    u_m1 = _bilinear_interpolate(x_m1, y_m1, u_grid, h, N)\n    u_p2 = _bilinear_interpolate(x_p2, y_p2, u_grid, h, N)\n    u_m2 = _bilinear_interpolate(x_m2, y_m2, u_grid, h, N)\n\n    # Directional second derivatives\n    d2u_dxprime2 = (u_p1 - 2 * u_grid + u_m1) / h**2\n    d2u_dyprime2 = (u_p2 - 2 * u_grid + u_m2) / h**2\n    \n    # Corrected operator application\n    L_h_corr_u = kx * d2u_dxprime2 + ky * d2u_dyprime2\n\n    # --- 4. Error Calculation ---\n    norm_exact = np.linalg.norm(L_u_exact)\n    \n    # The norm of the exact solution should be non-zero for the given test cases.\n    if norm_exact == 0:\n        # This case should not be reached with the problem's inputs\n        # but is handled for robustness.\n        err_base = 0.0 if np.allclose(L_h_base_u, L_u_exact) else np.inf\n        err_corr = 0.0 if np.allclose(L_h_corr_u, L_u_exact) else np.inf\n    else:\n        err_base = np.linalg.norm(L_h_base_u - L_u_exact) / norm_exact\n        err_corr = np.linalg.norm(L_h_corr_u - L_u_exact) / norm_exact\n\n    # Improvement factor\n    if err_corr > 0:\n        improvement = err_base / err_corr\n    elif err_base > 0: # err_corr is 0\n        improvement = np.inf\n    else: # Both errors are 0\n        improvement = 1.0\n\n    # Improved flag\n    improved = err_corr  err_base\n\n    # Round results and package them\n    return [\n        round(err_base, 8),\n        round(err_corr, 8),\n        round(improvement, 8),\n        improved\n    ]\n\ndef _bilinear_interpolate(x_coords, y_coords, u_grid, h, N):\n    \"\"\"\n    Performs periodic bilinear interpolation on the grid u_grid.\n    x_coords and y_coords are arrays of the same shape specifying points to interpolate.\n    \"\"\"\n    # Scale coordinates to grid index space, with periodic wrapping\n    x_scaled = (x_coords / h) % N\n    y_scaled = (y_coords / h) % N\n\n    # Get integer and fractional parts of scaled coordinates\n    i1 = np.floor(x_scaled).astype(int)\n    j1 = np.floor(y_scaled).astype(int)\n    \n    alpha = x_scaled - i1\n    beta = y_scaled - j1\n    \n    # Get indices of the 4 neighboring grid points (with periodic wrapping)\n    i2 = (i1 + 1) % N\n    j2 = (j1 + 1) % N\n    \n    # Retrieve values at the 4 corner points using advanced indexing\n    u11 = u_grid[i1, j1] # val at (i1, j1)\n    u21 = u_grid[i2, j1] # val at (i2, j1)\n    u12 = u_grid[i1, j2] # val at (i1, j2)\n    u22 = u_grid[i2, j2] # val at (i2, j2)\n\n    # Reshape weights for broadcasting\n    alpha = alpha.reshape(alpha.shape + (1,) * (u11.ndim - alpha.ndim))\n    beta = beta.reshape(beta.shape + (1,) * (u11.ndim - beta.ndim))\n\n    # Bilinear interpolation formula\n    u_interp = (1 - alpha) * (1 - beta) * u11 + \\\n               alpha * (1 - beta) * u21 + \\\n               (1 - alpha) * beta * u12 + \\\n               alpha * beta * u22\n    \n    return u_interp\n\nsolve()\n```"
        }
    ]
}