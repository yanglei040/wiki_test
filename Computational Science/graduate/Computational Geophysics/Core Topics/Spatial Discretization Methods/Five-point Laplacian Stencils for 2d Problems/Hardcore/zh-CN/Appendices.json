{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的检验方式就是亲手实践。这项练习将指导你从最基本的泰勒展开式出发，推导出二维泊松方程的五点差分格式。通过“人造解”方法（Method of Manufactured Solutions），你将编写代码来验证你的离散算子是否具有预期的二阶收敛精度，这是确保数值模拟结果可靠性的关键一步。",
            "id": "3596385",
            "problem": "考虑一个定义在矩形域 $\\Omega = [x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$ 上的二维标量场 $u(x,y)$。其控制性偏微分方程（PDE）为具有齐次椭圆性的泊松方程，\n$$\n- \\nabla^2 u(x,y) = q(x,y),\n$$\n其中 $\\nabla^2$ 是拉普拉斯算子。在人造解方法（MMS）中，我们选择一个解析的 $u(x,y)$，并通过将微分算子应用于 $u(x,y)$ 来定义 $q(x,y)$，从而使该解析的 $u(x,y)$ 成为连续偏微分方程的精确解。通过在 $\\partial \\Omega$ 上将 $u(x,y)$ 精确地设置为人造解来施加狄利克雷边界条件。所有量均为无量纲。\n\n您将推导、实现并验证用于通用矩形域（可能具有各向异性间距）的结构化网格上的五点拉普拉斯模板。请从以下基本出发点开始：\n- 笛卡尔坐标系中拉普拉斯算子的定义，$\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。\n- 从围绕网格点的泰勒展开推导出的，用于一维二阶导数的二阶中心差分近似。\n\n任务：\n1. 在一个间距为 $h_x$ 和 $h_y$ 的矩形网格上，推导内部网格节点 $(x_i,y_j)$ 处 $-\\nabla^2 u$ 的五点离散近似。仅使用泰勒展开和 $\\nabla^2$ 的定义；不要使用预先组合或记忆的模板公式。\n2. 表达出组装所有内部节点后得到的线性代数系统，并描述 $\\partial \\Omega$ 上的狄利克雷边界值如何进入右端项。\n3. 实现一个程序，对于下述的每个测试用例，构建离散算子，强制执行与人造解一致的狄利克雷边界条件，求解内部未知数的线性系统，计算离散 $L^2$ 误差范数，\n$$\n\\|e\\|_{L^2} \\approx \\left( h_x h_y \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\left[u_h(x_i,y_j) - u_{\\text{exact}}(x_i,y_j)\\right]^2 \\right)^{1/2},\n$$\n并报告观测到的网格收敛率\n$$\np = \\frac{\\ln\\left(\\|e\\|_{\\text{coarse}} / \\|e\\|_{\\text{fine}}\\right)}{\\ln(2)},\n$$\n其中“coarse”和“fine”分别指通过将 $N_x$ 和 $N_y$ 加倍而得到的两个连续细化的网格。\n\n实现细节：\n- 使用一个结构化网格，其沿 $x$ 方向有 $N_x$ 个内部点，沿 $y$ 方向有 $N_y$ 个内部点。网格间距为 $h_x = \\frac{x_{\\max} - x_{\\min}}{N_x + 1}$ 和 $h_y = \\frac{y_{\\max} - y_{\\min}}{N_y + 1}$。内部节点位于 $x_i = x_{\\min} + i h_x$ 和 $y_j = y_{\\min} + j h_y$，其中 $i=1,\\dots,N_x$ 且 $j=1,\\dots,N_y$。\n- 仅为内部节点组装线性系统，狄利克雷边界值适当地进入右端项。\n- 对于每个测试用例，使用一个粗网格和一个将各方向内部点数加倍的细网格来计算观测到的收敛率 $p$。\n\n测试套件：\n- 测试用例1（理想情况，方形域上的各向同性网格）：\n  - 域：$\\Omega = [0,1] \\times [0,1]$。\n  - 人造解：$u_1(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n  - 源项：$q_1(x,y) = -\\nabla^2 u_1(x,y)$。\n  - 网格：$(N_x,N_y) = (16,16)$ 和 $(32,32)$。\n- 测试用例2（方形域上的各向异性网格间距）：\n  - 域：$\\Omega = [0,1] \\times [0,1]$。\n  - 人造解：$u_2(x,y) = e^{x}\\sin(2\\pi y)$。\n  - 源项：$q_2(x,y) = -\\nabla^2 u_2(x,y)$。\n  - 网格：$(N_x,N_y) = (24,12)$ 和 $(48,24)$。\n- 测试用例3（各向异性域和网格）：\n  - 域：$\\Omega = [0,2] \\times [0,1]$。\n  - 人造解：$u_3(x,y) = \\cos(2\\pi x)\\cos(\\pi y)$。\n  - 源项：$q_3(x,y) = -\\nabla^2 u_3(x,y)$。\n  - 网格：$(N_x,N_y) = (60,20)$ 和 $(120,40)$。\n- 测试用例4（使用极粗网格的边界情况）：\n  - 域：$\\Omega = [0,1] \\times [0,1]$。\n  - 人造解：$u_1(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n  - 源项：$q_1(x,y) = -\\nabla^2 u_1(x,y)$。\n  - 网格：$(N_x,N_y) = (4,4)$ 和 $(8,8)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的观测收敛率，格式为方括号内的逗号分隔列表，每个率值四舍五入到四位小数，例如 $[p_1,p_2,p_3,p_4]$。",
            "solution": "本回答遵循用户要求，首先推导二维负拉普拉斯算子的五点有限差分模板，然后描述相应线性系统的组装，最后详细说明用于验证该方法收敛率的实现过程。\n\n### 1. 五点模板的推导\n\n任务是为结构化矩形网格上间距为 $h_x$ 和 $h_y$ 的内部网格节点 $(x_i, y_j)$ 找到算子 $-\\nabla^2 u$ 的离散近似。推导始于一个足够光滑的函数 $f(z)$ 在点 $z$ 附近的泰勒级数展开。\n\n考虑函数 $u(x, y)$ 在点 $(x_i, y_j)$ 附近沿 $x$ 方向的泰勒展开：\n$$u(x_i \\pm h_x, y_j) = u(x_i, y_j) \\pm h_x \\frac{\\partial u}{\\partial x}\\bigg|_{(x_i,y_j)} + \\frac{h_x^2}{2!} \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i,y_j)} \\pm \\frac{h_x^3}{3!} \\frac{\\partial^3 u}{\\partial x^3}\\bigg|_{(x_i,y_j)} + \\frac{h_x^4}{4!} \\frac{\\partial^4 u}{\\partial x^4}\\bigg|_{(x_i,y_j)} + O(h_x^5)$$\n令 $u_{i,j}$ 表示函数 $u$ 在网格点 $(x_i, y_j)$ 处的值。在 $x$ 方向上相邻点的展开式为：\n$$u_{i+1,j} = u(x_i+h_x, y_j) = u_{i,j} + h_x \\frac{\\partial u}{\\partial x} + \\frac{h_x^2}{2} \\frac{\\partial^2 u}{\\partial x^2} + \\frac{h_x^3}{6} \\frac{\\partial^3 u}{\\partial x^3} + O(h_x^4)$$\n$$u_{i-1,j} = u(x_i-h_x, y_j) = u_{i,j} - h_x \\frac{\\partial u}{\\partial x} + \\frac{h_x^2}{2} \\frac{\\partial^2 u}{\\partial x^2} - \\frac{h_x^3}{6} \\frac{\\partial^3 u}{\\partial x^3} + O(h_x^4)$$\n将这两个方程相加可以消去奇数阶导数项：\n$$u_{i+1,j} + u_{i-1,j} = 2u_{i,j} + h_x^2 \\frac{\\partial^2 u}{\\partial x^2} + \\frac{h_x^4}{12} \\frac{\\partial^4 u}{\\partial x^4} + O(h_x^6)$$\n重新整理以求解关于 $x$ 的二阶偏导数，得到二阶中心差分公式：\n$$\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i,y_j)} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} - \\frac{h_x^2}{12} \\frac{\\partial^4 u}{\\partial x^4} + O(h_x^4) = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + O(h_x^2)$$\n对 $y$ 方向进行相同的推导，得到关于 $y$ 的二阶偏导数的近似：\n$$\\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i,y_j)} = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} + O(h_y^2)$$\n笛卡尔坐标系中的拉普拉斯算子为 $\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。通过代入有限差分近似，我们得到在 $(x_i,y_j)$ 处的离散拉普拉斯算子：\n$$\\nabla^2 u \\bigg|_{(x_i,y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}$$\n控制性偏微分方程为 $-\\nabla^2 u = q$。代入离散算子，得到每个内部节点 $(i,j)$ 处的方程：\n$$-\\left( \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} \\right) = q_{i,j}$$\n按网格位置对各项进行分组，我们得到 $-\\nabla^2 u$ 的五点模板方程：\n$$\\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right)u_{i,j} - \\frac{1}{h_x^2}u_{i-1,j} - \\frac{1}{h_x^2}u_{i+1,j} - \\frac{1}{h_y^2}u_{i,j-1} - \\frac{1}{h_y^2}u_{i,j+1} = q_{i,j}$$\n该方程将中心节点 $(i,j)$ 的值与其四个直接相邻节点耦合起来，形成一个五点模板。此近似的截断误差为 $O(h_x^2, h_y^2)$，表明该方法是二阶精确的。\n\n### 2. 线性系统组装\n\n离散方程必须应用于每个内部网格节点，即 $i=1, \\dots, N_x$ 和 $j=1, \\dots, N_y$。这会产生一个包含 $N = N_x \\times N_y$ 个线性代数方程的系统。为了以矩阵形式 $\\mathbf{A} \\mathbf{u}_h = \\mathbf{b}$ 表达此系统，内部节点的未知值 $u_{i,j}$ 被排列成一个长度为 $N$ 的单列向量 $\\mathbf{u}_h$。一种标准方法是字典序，其中节点按行（或按列）进行索引。在实现中使用从0开始的索引，节点 $(i,j)$（其中 $i=0, \\dots, N_x-1$ 且 $j=0, \\dots, N_y-1$）的全局索引 $k$ 为 $k = j \\cdot N_x + i$。\n\n矩阵 $\\mathbf{A}$ 是一个大小为 $N \\times N$ 的稀疏、对称、正定矩阵。其结构是块三对角的。$\\mathbf{A}$ 的每个元素对应于模板的系数。对于以节点 $k=(j,i)$ 为中心的方程：\n- 对角线元素 $A_{k,k}$ 是 $u_{i,j}$ 的系数：$\\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right)$。\n- 对应于 $x$ 方向相邻点 $u_{i-1,j}$ 和 $u_{i+1,j}$ 的非对角线元素分别位于 $A_{k,k-1}$ 和 $A_{k,k+1}$：$-\\frac{1}{h_x^2}$。\n- 对应于 $y$ 方向相邻点 $u_{i,j-1}$ 和 $u_{i,j+1}$ 的非对角线元素分别位于 $A_{k,k-N_x}$ 和 $A_{k,k+N_x}$：$-\\frac{1}{h_y^2}$。\n\n狄利克雷边界条件指定了 $u$ 在边界 $\\partial\\Omega$ 上的值。当与边界相邻的内部节点的模板涉及到一个边界节点时，该值是已知的。这个已知值被移到方程的右端。\n例如，对于与左边界 $x=x_{\\min}$（其中 $i=0$）相邻的内部节点 $(1, j)$，涉及 $u_{0,j}$ 的项是已知的：\n$$\\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right)u_{1,j} - \\dots = q_{1,j} + \\frac{1}{h_x^2}u_{0,j}$$\n项 $\\frac{1}{h_x^2}u_{0,j}$ 被加到右端向量 $\\mathbf{b}$ 的相应元素上。\n因此，长度为 $N$ 的向量 $\\mathbf{b}$ 由两部分组成：\n1. 在每个内部节点 $(x_i, y_j)$ 处求值的源函数 $q(x,y)$ 的值。\n2. 从左端转移过来的已知狄利克雷边界值的贡献。对于一个通用的内部节点 $(i,j)$，向量 $\\mathbf{b}$ 中对应的元素 $b_k$ 是：\n$$b_k = q_{i,j} + \\delta_{i,1}\\frac{u_{0,j}}{h_x^2} + \\delta_{i,N_x}\\frac{u_{N_x+1,j}}{h_x^2} + \\delta_{j,1}\\frac{u_{i,0}}{h_y^2} + \\delta_{j,N_y}\\frac{u_{i,N_y+1}}{h_y^2}$$\n其中 $\\delta_{m,n}$ 是克罗内克δ符号。\n\n### 3. 实现与验证\n\n求解线性系统 $\\mathbf{A} \\mathbf{u}_h = \\mathbf{b}$ 以获得未知数向量 $\\mathbf{u}_h$。由于矩阵 $\\mathbf{A}$ 的稀疏和结构化特性，我们使用高效的稀疏矩阵存储格式（例如，压缩稀疏行）和专门的求解器。\n\n计算出数值解 $u_h(x_i, y_j)$ 后，通过将其与已知的人造解 $u_{\\text{exact}}(x_i, y_j)$进行比较来评估其准确性。离散 $L^2$ 误差范数按规定计算：\n$$ \\|e\\|_{L^2} \\approx \\left( h_x h_y \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\left[u_h(x_i,y_j) - u_{\\text{exact}}(x_i,y_j)\\right]^2 \\right)^{1/2} $$\n然后，通过比较粗网格的误差 $\\|e\\|_{\\text{coarse}}$ 和细化网格（每个维度的内部点数加倍）的误差 $\\|e\\|_{\\text{fine}}$ 来确定收敛率 $p$。收敛率计算如下：\n$$ p = \\frac{\\ln\\left(\\|e\\|_{\\text{coarse}} / \\|e\\|_{\\text{fine}}\\right)}{\\ln(2)} $$\n对于像我们推导出的这种二阶精确方法， $p$ 的期望值约为 $2$。下面的程序为指定的测试用例实现了这整个过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    # Test Case 1 and 4: u(x,y) = sin(pi*x)*sin(pi*y)\n    def u1(x, y):\n        return np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def q1(x, y):\n        return 2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    # Test Case 2: u(x,y) = exp(x)*sin(2*pi*y)\n    def u2(x, y):\n        return np.exp(x) * np.sin(2 * np.pi * y)\n    \n    def q2(x, y):\n        return (4 * np.pi**2 - 1) * np.exp(x) * np.sin(2 * np.pi * y)\n\n    # Test Case 3: u(x,y) = cos(2*pi*x)*cos(pi*y)\n    def u3(x, y):\n        return np.cos(2 * np.pi * x) * np.cos(np.pi * y)\n\n    def q3(x, y):\n        return 5 * np.pi**2 * np.cos(2 * np.pi * x) * np.cos(np.pi * y)\n\n\n    def solve_poisson(domain, Nx, Ny, u_func, q_func):\n        \"\"\"\n        Solves the Poisson equation on a rectangular domain using a five-point stencil.\n\n        Args:\n            domain (tuple): (xmin, xmax, ymin, ymax).\n            Nx (int): Number of interior grid points in x.\n            Ny (int): Number of interior grid points in y.\n            u_func (callable): Manufactured solution u(x, y).\n            q_func (callable): Source term q(x, y) = -Laplacian(u).\n\n        Returns:\n            float: The discrete L2 error norm.\n        \"\"\"\n        xmin, xmax, ymin, ymax = domain\n        N = Nx * Ny\n\n        # Grid setup\n        hx = (xmax - xmin) / (Nx + 1)\n        hy = (ymax - ymin) / (Ny + 1)\n\n        x_int = np.linspace(xmin + hx, xmax - hx, Nx)\n        y_int = np.linspace(ymin + hy, ymax - hy, Ny)\n        X_int, Y_int = np.meshgrid(x_int, y_int, indexing='ij')\n\n        # Assemble the sparse matrix A\n        # The matrix A represents the negative discrete Laplacian operator.\n        # It has 5 non-zero diagonals.\n        main_diag = np.full(N, 2/hx**2 + 2/hy**2)\n        \n        # Off-diagonals for x-derivatives\n        off_diag_x = np.full(N - 1, -1/hx**2)\n        # Zero out connections between rows\n        off_diag_x[Nx-1::Nx] = 0\n\n        # Off-diagonals for y-derivatives\n        off_diag_y = np.full(N - Nx, -1/hy**2)\n        \n        diagonals = [main_diag, off_diag_x, off_diag_x, off_diag_y, off_diag_y]\n        offsets = [0, -1, 1, -Nx, Nx]\n        \n        A = sparse.diags(diagonals, offsets, shape=(N, N), format='csr')\n\n        # Assemble the right-hand side vector b\n        # Start with the source term q at interior points\n        b = q_func(X_int, Y_int).T.flatten() # Transpose to match lexicographical order\n\n        # Add contributions from Dirichlet boundary conditions\n        # Reshape b to 2D for easier indexing\n        b_grid = b.reshape((Ny, Nx))\n        \n        # Bottom boundary (y = ymin, j=0)\n        b_grid[0, :] += (1/hy**2) * u_func(x_int, ymin)\n        # Top boundary (y = ymax, j=Ny-1)\n        b_grid[-1, :] += (1/hy**2) * u_func(x_int, ymax)\n        # Left boundary (x = xmin, i=0)\n        b_grid[:, 0] += (1/hx**2) * u_func(xmin, y_int)\n        # Right boundary (x = xmax, i=Nx-1)\n        b_grid[:, -1] += (1/hx**2) * u_func(xmax, y_int)\n\n        b = b_grid.flatten()\n        \n        # Solve the linear system\n        u_h_flat = spsolve(A, b)\n\n        # Compute the error\n        u_exact_flat = u_func(X_int, Y_int).T.flatten()\n        error_sq = (u_h_flat - u_exact_flat)**2\n        l2_error = np.sqrt(hx * hy * np.sum(error_sq))\n        \n        return l2_error\n\n    test_cases = [\n        {\"domain\": (0, 1, 0, 1), \"u_func\": u1, \"q_func\": q1, \"grids\": ((16, 16), (32, 32))},\n        {\"domain\": (0, 1, 0, 1), \"u_func\": u2, \"q_func\": q2, \"grids\": ((24, 12), (48, 24))},\n        {\"domain\": (0, 2, 0, 1), \"u_func\": u3, \"q_func\": q3, \"grids\": ((60, 20), (120, 40))},\n        {\"domain\": (0, 1, 0, 1), \"u_func\": u1, \"q_func\": q1, \"grids\": ((4, 4), (8, 8))},\n    ]\n\n    results = []\n    for case in test_cases:\n        (Nx_c, Ny_c), (Nx_f, Ny_f) = case[\"grids\"]\n        \n        error_coarse = solve_poisson(case[\"domain\"], Nx_c, Ny_c, case[\"u_func\"], case[\"q_func\"])\n        error_fine = solve_poisson(case[\"domain\"], Nx_f, Ny_f, case[\"u_func\"], case[\"q_func\"])\n        \n        if error_fine > 0 and error_coarse > 0:\n            rate = np.log(error_coarse / error_fine) / np.log(2)\n        else:\n            rate = 0.0 # Or some other indicator of non-convergence\n\n        results.append(rate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.4f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在解决了带有狄利克雷（Dirichlet）边界条件的问题后，我们来处理在地球物理学中同样常见的诺伊曼（Neumann）边界条件，它通常用来描述边界上的通量（如水流量或热通量）。这项练习将让你比较两种不同的诺伊曼边界处理方法，并评估它们对边界通量计算精度的影响。通过这个过程，你将更深刻地理解数值边界条件处理的细节及其对物理量计算准确性的重要性。",
            "id": "3596436",
            "problem": "考虑在一个坐标为 $(x,y) \\in [0,L_x] \\times [0,L_y]$ 的矩形域中，均质、各向同性含水层内的稳态地下水流。设水力传导系数为一个正常数 $K$，单位为 $\\mathrm{m/s}$。水头 $h(x,y)$ 满足从达西定律推导出的拉普拉斯方程，具体为守恒形式 $\\nabla \\cdot (K \\nabla h) = 0$，当 $K$ 在空间上为常数时，该方程简化为偏微分方程 (PDE) $\\nabla^2 h = 0$。假设三条边具有与构造的精确解一致的狄利克雷边界条件，而位于 $x=L_x$ 的右边界具有一个规定的诺伊曼条件，该条件表示沿 $y$ 线性变化的法向通量。\n\n构造解为 $h(x,y) = A x + B y + C x y$，对于所有常数 $A$、$B$ 和 $C$，该解都满足 $\\nabla^2 h = 0$。通过从构造解的值规定 $h(0,y)$、$h(x,0)$ 和 $h(x,L_y)$，在 $x=0$、$y=0$ 和 $y=L_y$ 处强制施加狄利克雷边界条件。在右边界 $x=L_x$ 处，诺伊曼边界条件通过 $-K \\, \\partial h / \\partial x \\big|_{x=L_x} = -K \\left(A + C y\\right)$ 规定了法向通量 $q_n(y)$。\n\n您的任务是使用标准的五点拉普拉斯模板，在 $x$ 方向有 $N_x$ 个节点、$y$ 方向有 $N_y$ 个节点的均匀笛卡尔网格上离散化该偏微分方程，并为离散算子在 $x=L_x$ 处的诺伊曼边界实现两种不同的处理方法：\n\n- 单边差分 (OSD)：使用一阶单边差分来近似正 $x$ 方向上缺失的邻居节点，该差分通过在 $x$ 方向的离散二阶导数中代入 $h_{i+1,j} = h_{i,j} + \\Delta x \\, \\partial h / \\partial x \\big|_{x=L_x,y_j}$ 来强制施加诺伊曼边界条件，其中 $\\Delta x = L_x/(N_x-1)$ 且 $y_j = j \\Delta y$，$\\Delta y = L_y/(N_y-1)$。这导致右边界节点上 $x$ 方向的离散贡献为 $(h_{i-1,j} - h_{i,j})/\\Delta x^2 + (\\partial h / \\partial x)/\\Delta x$。\n- 镜像虚拟单元 (GCR)：使用跨边界的镜像值来近似缺失的邻居节点，该方法通过在 $x$ 方向的离散二阶导数中代入 $h_{i+1,j} = h_{i-1,j} + 2 \\Delta x \\, \\partial h / \\partial x \\big|_{x=L_x,y_j}$，以一种保持中心差分结构的方式强制施加诺伊曼条件。这导致右边界节点上 $x$ 方向的离散贡献为 $(2 h_{i-1,j} - 2 h_{i,j})/\\Delta x^2 + 2 (\\partial h / \\partial x)/\\Delta x$。\n\n在这两种处理方法中，$y$ 方向的二阶导数都使用标准中心差分 $(h_{i,j+1} - 2 h_{i,j} + h_{i,j-1})/\\Delta y^2$ 进行离散化，并在需要时插入 $y=0$ 和 $y=L_y$ 处的狄利克雷边界值。对于内部节点，使用规范的五点拉普拉斯算子 $(h_{i+1,j} - 2 h_{i,j} + h_{i-1,j})/\\Delta x^2 + (h_{i,j+1} - 2 h_{i,j} + h_{i,j-1})/\\Delta y^2 = 0$，并在左、下、上边界应用狄利克雷值。\n\n在对每种诺伊曼处理方法求解 $h$ 的线性系统后，通过对两种方法都使用单边内部差分计算离散法向通量 $q_n^{\\mathrm{num}}(y_j) = -K \\, \\left(h_{N_x-1,j} - h_{N_x-2,j}\\right)/\\Delta x$，来评估右边界上边界通量的精度，并将其与精确边界通量 $q_n^{\\mathrm{exact}}(y_j) = -K \\left(A + C y_j\\right)$ 进行比较。对于每种情况，报告沿右边界的最大绝对通量误差 $\\max_{j} \\left| q_n^{\\mathrm{num}}(y_j) - q_n^{\\mathrm{exact}}(y_j) \\right|$，单位为 $\\mathrm{m/s}$。\n\n实现一个完整的、可运行的程序，该程序：\n- 按照规定，为 OSD 和 GCR 两种边界处理方法构建并求解离散系统。\n- 计算每种方法的最大边界通量误差，单位为 $\\mathrm{m/s}$。\n\n使用以下参数集测试套件，所有长度单位为 $\\mathrm{m}$，$K$ 的单位为 $\\mathrm{m/s}$：\n- 案例 $\\#1$ (理想情况)：$(N_x,N_y,L_x,L_y,K,A,B,C) = (41,41,1,1,1,1,0.2,0.5)$。\n- 案例 $\\#2$ (粗网格边界压力测试)：$(N_x,N_y,L_x,L_y,K,A,B,C) = (5,5,1,1,1,1,0.3,0.8)$。\n- 案例 $\\#3$ (右边界恒定通量)：$(N_x,N_y,L_x,L_y,K,A,B,C) = (31,31,1,1,1,1,0.1,0)$。\n- 案例 $\\#4$ (各向异性网格间距)：$(N_x,N_y,L_x,L_y,K,A,B,C) = (60,30,2,1,1,0.5,0.4,0.7)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8]$），其中 $r_{2k-1}$ 是案例 $k$ 中 OSD 的最大通量误差，$r_{2k}$ 是案例 $k$ 中 GCR 的最大通量误差，每个值都表示为一个单位为 $\\mathrm{m/s}$ 的浮点数。",
            "solution": "用户希望在矩形域 $[0,L_x] \\times [0,L_y]$ 上求解二维稳态地下水流方程，即拉普拉斯方程 $\\nabla^2 h = 0$。该问题使用有限差分法在均匀笛卡尔网格上进行离散化。边界条件是混合类型的：在三条边（$x=0$、$y=0$、$y=L_y$）上指定了狄利克雷条件，在第四条边（$x=L_x$）上指定了诺伊曼条件。边界条件的值来源于一个已知的构造解 $h(x,y) = A x + B y + C x y$，该解是拉普拉斯方程的精确解。\n\n任务的核心是为 $x=L_x$ 处的诺伊曼边界条件实现并比较两种不同的数值处理方法：一阶精度的单边差分 (OSD) 和二阶精度的镜像虚拟单元 (GCR) 法。对于每种方法，我们需要求解得到的线性方程组，以获得网格节点上的水头 $h$。最后，我们必须通过计算诺伊曼边界上计算出的法向通量与从构造解导出的精确通量之间的最大绝对误差来评估每种方法的精度。\n\n求解步骤如下：\n\n1.  **网格和系统设置**：对于每个测试案例，我们定义一个具有 $N_x \\times N_y$ 个节点的均匀网格。网格间距为 $\\Delta x = L_x/(N_x-1)$ 和 $\\Delta y = L_y/(N_y-1)$。我们系统中的未知数是内部网格节点和诺伊曼边界上节点（不包括由狄利克雷条件固定的角点）的 $h$ 值。这给出了总共 $(N_x-1) \\times (N_y-2)$ 个未知数。我们将这些未知节点的二维网格索引 $(i,j)$ 映射到一维索引 $k$，以形成一个未知数向量。\n\n2.  **离散化和矩阵组装**：我们构建一个稀疏线性方程组 $\\mathbf{M} \\mathbf{h} = \\mathbf{b}$，其中 $\\mathbf{h}$ 是未知水头值的向量。对于每个未知节点 $(i,j)$，我们写出一个有限差分方程。\n    -   对于内部节点（$1 \\le i  N_x-1$，$1 \\le j  N_y-2$），我们使用标准的五点模板来表示拉普拉斯算子：\n        $$\n        \\frac{h_{i+1,j} - 2h_{i,j} + h_{i-1,j}}{\\Delta x^2} + \\frac{h_{i,j+1} - 2h_{i,j} + h_{i,j-1}}{\\Delta y^2} = 0\n        $$\n        涉及狄利克雷边界上节点的项是已知的，并移至右侧向量 $\\mathbf{b}$。\n    -   对于诺伊曼边界上的节点（$i = N_x-1$，$1 \\le j  N_y-2$），$\\partial^2h/\\partial x^2$ 的离散化被修改以包含通量条件 $\\partial h/\\partial x \\big|_{x=L_x} = A + C y_j$。\n        -   **OSD 处理**：$x$ 方向导数项近似为：\n            $$\n            \\frac{h_{i-1,j} - h_{i,j}}{\\Delta x^2} + \\frac{1}{\\Delta x}\\left(\\frac{\\partial h}{\\partial x}\\right)_{i,j}\n            $$\n            将其代入 PDE，得到线性系统的一行。\n        -   **GCR 处理**：$x$ 方向导数项使用虚拟单元方法，得到近似式：\n            $$\n            \\frac{2h_{i-1,j} - 2h_{i,j}}{\\Delta x^2} + \\frac{2}{\\Delta x}\\left(\\frac{\\partial h}{\\partial x}\\right)_{i,j}\n            $$\n            这也代入 PDE 中，用于系统的相应行。\n\n3.  **求解系统**：使用 `scipy.sparse.linalg` 库中的直接稀疏求解器求解得到的稀疏线性系统 $\\mathbf{M} \\mathbf{h} = \\mathbf{b}$ 以获得 $\\mathbf{h}$。\n\n4.  **解的重构**：将解向量 $\\mathbf{h}$ 重塑并放入一个完整的 $N_x \\times N_y$ 网格中。然后将狄利克雷边界条件的已知值施加到该网格上，以获得完整的数值解。\n\n5.  **通量误差计算**：通过比较右边界上数值计算的通量与精确通量来评估解的精度。\n    -   边界 $x=L_x$ 上每个节点 $j$ 的数值通量使用一阶、单边内部差分计算：\n        $$\n        q_{n,j}^{\\mathrm{num}} = -K \\frac{h_{N_x-1,j} - h_{N_x-2,j}}{\\Delta x}\n        $$\n    -   节点 $j$ 处的精确通量由下式给出：\n        $$\n        q_{n,j}^{\\mathrm{exact}} = -K (A + C y_j)\n        $$\n    -   误差是右边界上所有节点处数值通量与精确通量值之间最大绝对差：\n        $$\n        \\text{Error} = \\max_{j} \\left| q_{n,j}^{\\mathrm{num}} - q_{n,j}^{\\mathrm{exact}} \\right|\n        $$\n对于提供的四个测试案例中的每一个，都对 OSD 和 GCR 方法重复此整个过程，并收集得到的八个误差值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve_case(params, method):\n    \"\"\"\n    Solves the 2D Laplace equation for a single test case and boundary treatment method.\n\n    Args:\n        params (tuple): A tuple containing (Nx, Ny, Lx, Ly, K, A, B, C).\n        method (str): The Neumann boundary treatment method, either 'OSD' or 'GCR'.\n\n    Returns:\n        float: The maximum absolute flux error on the right boundary.\n    \"\"\"\n    Nx, Ny, Lx, Ly, K, A, B, C = params\n\n    if Nx  3 or Ny  3:\n        # If Ny  3, there are no interior nodes in the y-direction, thus num_unknowns is 0.\n        # The flux error at the corners is analytically zero, so the max error is 0.\n        return 0.0\n\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n    x = np.linspace(0, Lx, Nx, dtype=np.float64)\n    y = np.linspace(0, Ly, Ny, dtype=np.float64)\n\n    num_unknowns = (Nx - 1) * (Ny - 2)\n    M = lil_matrix((num_unknowns, num_unknowns), dtype=np.float64)\n    b = np.zeros(num_unknowns, dtype=np.float64)\n\n    # Map grid indices (i, j) of an unknown to a single vector index k.\n    # i corresponds to x-index [1, Nx-1], j to y-index [1, Ny-2].\n    def to_k(i, j):\n        return (i - 1) * (Ny - 2) + (j - 1)\n\n    # Assemble the linear system M*h = b\n    for i in range(1, Nx):\n        for j in range(1, Ny - 1):\n            k = to_k(i, j)\n            \n            # Y-direction contribution (central difference)\n            M[k, k] += -2.0 / dy**2\n            if j == 1:  # Neighbor on bottom Dirichlet boundary (y=0)\n                h_bound = A * x[i]\n                b[k] -= h_bound / dy**2\n            else:\n                k_jm1 = to_k(i, j - 1)\n                M[k, k_jm1] += 1.0 / dy**2\n\n            if j == Ny - 2:  # Neighbor on top Dirichlet boundary (y=Ly)\n                h_bound = A * x[i] + B * Ly + C * x[i] * Ly\n                b[k] -= h_bound / dy**2\n            else:\n                k_jp1 = to_k(i, j + 1)\n                M[k, k_jp1] += 1.0 / dy**2\n\n            # X-direction contribution\n            if i  Nx - 1:  # Interior node in x-direction\n                M[k, k] += -2.0 / dx**2\n                if i == 1:  # Neighbor on left Dirichlet boundary (x=0)\n                    h_bound = B * y[j]\n                    b[k] -= h_bound / dx**2\n                else:\n                    k_im1 = to_k(i - 1, j)\n                    M[k, k_im1] += 1.0 / dx**2\n                \n                k_ip1 = to_k(i + 1, j)\n                M[k, k_ip1] += 1.0 / dx**2\n            \n            else:  # i == Nx - 1, node is on the right Neumann boundary\n                dhdx = A + C * y[j]\n                k_im1 = to_k(i - 1, j)\n                \n                if method == 'OSD':\n                    M[k, k] += -1.0 / dx**2\n                    M[k, k_im1] += 1.0 / dx**2\n                    b[k] -= dhdx / dx\n                elif method == 'GCR':\n                    M[k, k] += -2.0 / dx**2\n                    M[k, k_im1] += 2.0 / dx**2\n                    b[k] -= 2.0 * dhdx / dx\n\n    # Solve the sparse linear system\n    M_csr = M.tocsr()\n    h_unknown = spsolve(M_csr, b)\n\n    # Reconstruct the full solution grid h_full[i, j]\n    h_full = np.zeros((Nx, Ny), dtype=np.float64)\n\n    # Fill in the solved unknown values\n    h_unknown_grid = h_unknown.reshape((Nx - 1, Ny - 2), order='C')\n    h_full[1:Nx, 1:Ny - 1] = h_unknown_grid\n\n    # Apply Dirichlet boundary conditions to the full grid\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    h_full[0, :] = B * Y[0, :]\n    h_full[:, 0] = A * X[:, 0]\n    h_full[:, Ny - 1] = A * X[:, Ny - 1] + B * Ly + C * X[:, Ny - 1] * Ly\n\n    # Calculate numerical flux on the right boundary (x=Lx)\n    h_right_boundary = h_full[Nx - 1, :]\n    h_second_to_right = h_full[Nx - 2, :]\n    q_num = -K * (h_right_boundary - h_second_to_right) / dx\n\n    # Calculate exact flux on the right boundary\n    q_exact = -K * (A + C * y)\n    \n    # Compute the maximum absolute error\n    max_error = np.max(np.abs(q_num - q_exact))\n    \n    return max_error\n    \ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (41, 41, 1.0, 1.0, 1.0, 1.0, 0.2, 0.5),\n        (5, 5, 1.0, 1.0, 1.0, 1.0, 0.3, 0.8),\n        (31, 31, 1.0, 1.0, 1.0, 1.0, 0.1, 0.0),\n        (60, 30, 2.0, 1.0, 1.0, 0.5, 0.4, 0.7)\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate max flux error for One-Sided Difference (OSD)\n        error_osd = solve_case(case, 'OSD')\n        results.append(error_osd)\n\n        # Calculate max flux error for Ghost-Cell Reflection (GCR)\n        error_gcr = solve_case(case, 'GCR')\n        results.append(error_gcr)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "现实世界中的地球物理介质通常是各向异性的，其主要属性（如渗透率）的方向可能与我们的计算网格不一致。当这种情况发生时，标准的五点拉普拉斯算子会因为忽略了交叉导数项而产生显著误差。这项高级练习引导你设计并实现一种巧妙的“旋转模板”校正方法，它通过在材料主方向上进行计算并利用插值来提高精度，同时避免了使用更复杂的九点格式。",
            "id": "3596408",
            "problem": "考虑散度形式的二维各向异性扩散算子，对于一个足够光滑的标量场 $u(x,y)$，其定义为\n$$\n\\mathcal{L}[u] \\equiv \\nabla \\cdot \\left( \\mathbf{K} \\, \\nabla u \\right),\n$$\n其中 $\\mathbf{K}$ 是一个常数、对称、正定的水力/热传导率张量，其主值为 $k_x$ 和 $k_y$。在主轴坐标系中，$\\mathbf{K}=\\mathrm{diag}(k_x,k_y)$。假设主轴相对于笛卡尔网格方向旋转了一个角度 $\\theta$（以弧度为单位）。在许多地球物理流中，这种各向异性扩散源于分层介质或裂缝组，其渗透率张量在一个旋转坐标系中是对角的。\n\n您的任务是，从第一性原理出发，构建、评估和修正一个五点离散化方案。该方案需保持网格对齐，但又能对旋转的各向异性具有预测能力，并且不引入九点模板。计算域在 $[0,1]\\times[0,1]$ 上是周期的。角度必须以弧度为单位进行解释。本问题不涉及物理单位；所有量均视为无量纲。\n\n从梯度和散度的基本定义以及坐标旋转的链式法则出发，完成以下任务：\n\n- 在连续层面上，推导全局坐标系中的旋转张量算子与旋转了 $\\theta$ 角的主轴张量 $\\mathrm{diag}(k_x,k_y)$ 之间的关系。将该算子作用于形式为 $u(x,y)=\\cos\\!\\left(2\\pi\\,(m\\,x+n\\,y)\\right)$ 的单个实傅里叶模式（其中 $m$ 和 $n$ 为整数）的结果表示为 $u(x,y)$ 的一个标量倍数。不要假设 $(m,n)$ 与网格轴之间有任何特殊的对齐关系。\n\n- 在一个具有 $N\\times N$ 个节点和网格间距 $h=1/N$ 的均匀周期性网格上，实现经典的五点离散算子，该算子使通量与网格方向对齐，并使用中心二阶差分。对于在网格对齐坐标系中是对角阵的常数 $\\mathbf{K}$，该算子简化为 $x$ 和 $y$ 方向上二阶差分的加权和。使用前一项得到的旋转张量，定义一个基准五点离散算子，该算子忽略混合导数，并作为旋转后连续算子的一个网格对齐近似。\n\n- 通过将基准五点算子作用于 $u(x,y)=\\cos\\!\\left(2\\pi\\,(m\\,x+n\\,y)\\right)$ 的结果与上面推导的精确连续算子进行比较，来量化其误差。使用相对 $\\ell^2$ 误差\n$$\n\\varepsilon \\equiv \\left( \\frac{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left( \\mathcal{L}_h[u]_{i,j}-\\mathcal{L}[u]_{i,j} \\right)^2}{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left(\\mathcal{L}[u]_{i,j}\\right)^2} \\right)^{1/2}.\n$$\n\n- 提出并实现一个不引入九点模板的旋转模板校正方法。您的校正方法必须从第一性原理推导得出，并且必须保留使用五点核心来计算二阶差分，但它可以通过局部旋转来沿主方向计算这些差分。具体来说，在旋转坐标系中使用步长为 $h$ 的中心差分来计算沿两个主方向的方向二阶导数。由于主方向与网格不对齐，因此需要使用来自四个最近网格节点的周期性双线性插值来近似所需的网格外 $u$ 的采样值。将两个方向二阶差分与主扩散系数 $k_x$ 和 $k_y$ 结合起来，以近似 $\\mathcal{L}[u]$。这样就实现了一种旋转模板校正，而无需显式地引入一个由固定的网格对齐点组成的九点模板。\n\n- 使用以上方法，对测试函数 $u(x,y)=\\cos\\!\\left(2\\pi\\,(m\\,x+n\\,y)\\right)$ 评估基准离散算子和校正后离散算子，并报告其相对 $\\ell^2$ 误差。对每个测试用例，计算基准误差、校正后误差以及定义为基准误差与校正后误差之比的改进因子。同时报告一个布尔值，指明校正后误差是否严格小于基准误差。\n\n您的程序必须在周期性网格上实现所有计算，使用周期性环绕（periodic wrapping）执行所有插值，并为以下测试套件生成结果：\n\n- 测试用例 1：$N=64$, $k_x=2.0$, $k_y=1.0$, $\\theta=0.0$, $m=3$, $n=2$。\n- 测试用例 2：$N=64$, $k_x=2.0$, $k_y=1.0$, $\\theta=\\pi/6$, $m=3$, $n=2$。\n- 测试用例 3：$N=64$, $k_x=10.0$, $k_y=1.0$, $\\theta=\\pi/4$, $m=2$, $n=1$。\n- 测试用例 4：$N=64$, $k_x=1.0$, $k_y=1.0$, $\\theta=\\pi/3$, $m=4$, $n=3$。\n\n对于每个测试用例，结果必须是一个包含四项的列表，顺序为：基准误差（浮点数）、校正后误差（浮点数）、改进因子（浮点数）、改进标志（布尔值）。所有浮点数必须四舍五入到8位小数。最终输出格式必须是单行，其中包含一个由方括号括起来的、以逗号分隔的各测试用例结果列表。例如，输出必须看起来像\n$[ [e_{11}, e_{12}, e_{13}, b_1], [e_{21}, e_{22}, e_{23}, b_2], [e_{31}, e_{32}, e_{33}, b_3], [e_{41}, e_{42}, e_{43}, b_4] ]$\n并且打印行中没有空格。将每个 $e_{ij}$ 替换为相应的四舍五入后的浮点数，将 $b_i$ 替换为相应的布尔值。",
            "solution": "该问题要求为二维各向异性扩散算子 $\\mathcal{L}[u] \\equiv \\nabla \\cdot \\left( \\mathbf{K} \\, \\nabla u \\right)$ 构建并验证两种有限差分格式。传导率张量 $\\mathbf{K}$ 是常数、对称、正定的，其主值 $k_x$ 和 $k_y$ 定义于一个相对于笛卡尔网格旋转了角度 $\\theta$ 的坐标系中。求解过程首先分析连续算子，然后定义一个朴素的基准离散算子和一个更复杂的校正算子，最后在一个给定的测试函数上比较它们的精度。\n\n首先，我们在标准笛卡尔网格坐标系 $(x,y)$ 中推导连续算子 $\\mathcal{L}[u]$ 的显式形式。二阶传导率张量从其主轴坐标系（用撇号表示）到网格坐标系的变换由合同变换 $\\mathbf{K} = \\mathbf{R}(\\theta) \\mathbf{K}' \\mathbf{R}(\\theta)^T$ 给出，其中 $\\mathbf{K}' = \\mathrm{diag}(k_x, k_y)$ 且 $\\mathbf{R}(\\theta)$ 是标准旋转矩阵。\n$$\n\\mathbf{R}(\\theta) = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix}\n$$\n令 $c = \\cos\\theta$ 和 $s = \\sin\\theta$，网格坐标系中的张量 $\\mathbf{K}$ 为：\n$$\n\\mathbf{K} = \\begin{pmatrix} c  -s \\\\ s  c \\end{pmatrix} \\begin{pmatrix} k_x  0 \\\\ 0  k_y \\end{pmatrix} \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix} = \\begin{pmatrix} k_x c^2 + k_y s^2  (k_x - k_y)sc \\\\ (k_x - k_y)sc  k_x s^2 + k_y c^2 \\end{pmatrix}\n$$\n设 $\\mathbf{K}$ 在网格坐标系中的分量为 $K_{11}$、$K_{12} = K_{21}$ 和 $K_{22}$。由于 $\\mathbf{K}$ 的各项为常数，算子 $\\mathcal{L}[u]$ 展开为：\n$$\n\\mathcal{L}[u] = \\nabla \\cdot (\\mathbf{K} \\nabla u) = \\partial_x(K_{11} \\partial_x u + K_{12} \\partial_y u) + \\partial_y(K_{21} \\partial_x u + K_{22} \\partial_y u) = K_{11} \\partial^2_{xx} u + 2 K_{12} \\partial^2_{xy} u + K_{22} \\partial^2_{yy} u\n$$\n我们将此算子应用于指定的测试函数，即单个傅里叶模式 $u(x,y) = \\cos(2\\pi(mx+ny))$。令 $\\phi(x,y) = 2\\pi(mx+ny)$。所需的二阶偏导数为 $\\partial^2_{xx} u = -(2\\pi m)^2 u$、$\\partial^2_{yy} u = -(2\\pi n)^2 u$ 和 $\\partial^2_{xy} u = -(2\\pi)^2 mn u$。将这些代入 $\\mathcal{L}[u]$ 的表达式中，表明 $u(x,y)$ 是该连续算子的一个特征函数：\n$$\n\\mathcal{L}[u] = -(2\\pi)^2 \\left[ K_{11}m^2 + 2 K_{12} mn + K_{22}n^2 \\right] u(x,y)\n$$\n使用波矢 $\\mathbf{p} = 2\\pi(m, n)^T$ 可以更紧凑地表示为 $\\mathcal{L}[u] = -(\\mathbf{p}^T \\mathbf{K} \\mathbf{p}) u$。这个解析结果提供了网格上的精确参考解，离散近似将与之进行比较。\n\n其次，我们构建基准五点离散算子 $\\mathcal{L}_{h, \\text{base}}$。根据规定，该算子与网格对齐，并通过忽略各向异性张量旋转产生的混合导数项 $2 K_{12} \\partial^2_{xy} u$ 而得到。由此得到的近似算子是：\n$$\n\\mathcal{L}_{\\text{base}}[u] \\approx K_{11} \\partial^2_{xx} u + K_{22} \\partial^2_{yy} u\n$$\n在一个间距为 $h=1/N$ 的均匀周期性网格上，使用标准的二阶中心差分，我们得到在网格节点 $(i,j)$ 处的离散算子：\n$$\n\\mathcal{L}_{h, \\text{base}}[u]_{i,j} = K_{11} \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + K_{22} \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\n$$\n其中 $u_{i,j} = u(ih, jh)$ 并且所有索引都进行周期性处理。该算子计算效率高，但只要 $K_{12} \\neq 0$（即当 $\\theta$ 不是 $\\pi/2$ 的倍数且 $k_x \\neq k_y$ 时），它在形式上就是不一致的，因为它省略了控制偏微分方程中的一个项。\n\n第三，我们设计校正后的离散算子 $\\mathcal{L}_{h, \\text{corr}}$。该算子通过在其自然主轴坐标系中对算子进行离散化来规避这种不一致性。在这个 $(x', y')$ 坐标系中，算子简化为：\n$$\n\\mathcal{L}[u] = k_x \\frac{\\partial^2 u}{\\partial (x')^2} + k_y \\frac{\\partial^2 u}{\\partial (y')^2}\n$$\n沿这些主轴的单位向量是 $\\mathbf{e}'_1 = (\\cos\\theta, \\sin\\theta)^T$ 和 $\\mathbf{e}'_2 = (-\\sin\\theta, \\cos\\theta)^T$。我们使用步长为 $h$ 的中心差分来近似二阶方向导数：\n$$\n\\frac{\\partial^2 u}{\\partial (x')^2} \\bigg|_P \\approx \\frac{u(P+h\\mathbf{e}'_1) - 2u(P) + u(P-h\\mathbf{e}'_1)}{h^2}, \\quad \\frac{\\partial^2 u}{\\partial (y')^2} \\bigg|_P \\approx \\frac{u(P+h\\mathbf{e}'_2) - 2u(P) + u(P-h\\mathbf{e}'_2)}{h^2}\n$$\n其中 $P=(x_i, y_j)$ 是一个网格节点。求值点 $P \\pm h\\mathbf{e}'_1$ 和 $P \\pm h\\mathbf{e}'_2$ 通常不位于网格上。为了在这些网格外的点上计算 $u$ 的值，我们采用周期性双线性插值，使用其周围四个网格节点上的值。对于域 $[0,1) \\times [0,1)$ 中的一个点 $(x,y)$，我们找到其整数网格单元邻居 $(i_1, j_1), ((i_1+1)\\%N, j_1), (i_1, (j_1+1)\\%N), ((i_1+1)\\%N, (j_1+1)\\%N)$ 以及小数距离 $\\alpha$ 和 $\\beta$。插值后的值 $u_{\\text{interp}}$ 则是：\n$$\nu_{\\text{interp}}(x,y) = (1-\\alpha)(1-\\beta)u_{i_1,j_1} + \\alpha(1-\\beta)u_{i_2,j_1} + (1-\\alpha)\\beta u_{i_1,j_2} + \\alpha\\beta u_{i_2,j_2}\n$$\n校正后的算子将这些部分组合起来：\n$$\n\\mathcal{L}_{h, \\text{corr}}[u]_{i,j} = k_x \\left( \\frac{u_{\\text{interp}}(P+h\\mathbf{e}'_1) - 2u_{i,j} + u_{\\text{interp}}(P-h\\mathbf{e}'_1)}{h^2} \\right) + k_y \\left( \\frac{u_{\\text{interp}}(P+h\\mathbf{e}'_2) - 2u_{i,j} + u_{\\text{interp}}(P-h\\mathbf{e}'_2)}{h^2} \\right)\n$$\n这个公式为原始算子提供了一个一致的近似，因为其误差来源是中心差分的标准截断误差和双线性插值的误差，这两者都随着 $h \\to 0$ 而减小。\n\n最后，使用相对 $\\ell^2$ 误差 $\\varepsilon$ 来量化两种离散算子的精度。对于一个给定的离散算子 $\\mathcal{L}_h$，误差计算如下：\n$$\n\\varepsilon = \\left( \\frac{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left( \\mathcal{L}_h[u]_{i,j}-\\mathcal{L}[u]_{i,j} \\right)^2}{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left(\\mathcal{L}[u]_{i,j}\\right)^2} \\right)^{1/2}\n$$\n其中 $\\mathcal{L}[u]_{i,j}$ 是在网格节点 $(i,j)$ 处求值的精确连续算子。该度量针对 $\\mathcal{L}_{h, \\text{base}}$ 和 $\\mathcal{L}_{h, \\text{corr}}$ 进行计算，并通过改进因子（定义为基准误差与校正后误差之比）来比较它们的性能。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the anisotropic diffusion problem for a suite of test cases.\n    It computes errors for a baseline and a corrected finite difference scheme.\n    \"\"\"\n    test_cases = [\n        # (N, kx, ky, theta, m, n)\n        (64, 2.0, 1.0, 0.0, 3, 2),\n        (64, 2.0, 1.0, np.pi/6, 3, 2),\n        (64, 10.0, 1.0, np.pi/4, 2, 1),\n        (64, 1.0, 1.0, np.pi/3, 4, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_single_case(*case)\n        results.append(result)\n\n    # Format the final output string as a list of lists.\n    # The default string representation for Python lists and booleans is used.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_single_case(N, kx, ky, theta, m, n):\n    \"\"\"\n    Computes numerical solutions and errors for a single test case.\n    \"\"\"\n    h = 1.0 / N\n    x = np.arange(N) * h\n    # Create a 2D grid of coordinates\n    xx, yy = np.meshgrid(x, x, indexing='ij')\n\n    # The test function evaluated on the grid\n    u_grid = np.cos(2 * np.pi * (m * xx + n * yy))\n\n    # --- 1. Exact Continuous Operator Evaluation ---\n    c, s = np.cos(theta), np.sin(theta)\n    \n    # Components of the conductivity tensor K in the grid-aligned frame\n    K11 = kx * c**2 + ky * s**2\n    K12 = (kx - ky) * s * c\n    K22 = kx * s**2 + ky * c**2\n    \n    # Eigenvalue of the continuous operator for the given Fourier mode\n    lambda_exact = -(2 * np.pi)**2 * (K11 * m**2 + 2 * K12 * m * n + K22 * n**2)\n    \n    # Exact operator applied to the test function on the grid\n    L_u_exact = lambda_exact * u_grid\n\n    # --- 2. Baseline Five-Point Operator ---\n    # Central difference approximation for d^2u/dx^2 (periodic)\n    uxx = (np.roll(u_grid, -1, axis=0) - 2 * u_grid + np.roll(u_grid, 1, axis=0)) / h**2\n    # Central difference approximation for d^2u/dy^2 (periodic)\n    uyy = (np.roll(u_grid, -1, axis=1) - 2 * u_grid + np.roll(u_grid, 1, axis=1)) / h**2\n    \n    # Baseline operator application (ignores mixed derivatives)\n    L_h_base_u = K11 * uxx + K22 * uyy\n\n    # --- 3. Corrected Rotated-Stencil Operator ---\n    # Principal direction vectors\n    e1 = np.array([c, s])\n    e2 = np.array([-s, c])\n\n    # Coordinates of points for directional derivatives\n    x_p1, y_p1 = xx + h * e1[0], yy + h * e1[1]\n    x_m1, y_m1 = xx - h * e1[0], yy - h * e1[1]\n    x_p2, y_p2 = xx + h * e2[0], yy + h * e2[1]\n    x_m2, y_m2 = xx - h * e2[0], yy - h * e2[1]\n    \n    # Interpolate u at off-grid points\n    u_p1 = _bilinear_interpolate(x_p1, y_p1, u_grid, h, N)\n    u_m1 = _bilinear_interpolate(x_m1, y_m1, u_grid, h, N)\n    u_p2 = _bilinear_interpolate(x_p2, y_p2, u_grid, h, N)\n    u_m2 = _bilinear_interpolate(x_m2, y_m2, u_grid, h, N)\n\n    # Directional second derivatives\n    d2u_dxprime2 = (u_p1 - 2 * u_grid + u_m1) / h**2\n    d2u_dyprime2 = (u_p2 - 2 * u_grid + u_m2) / h**2\n    \n    # Corrected operator application\n    L_h_corr_u = kx * d2u_dxprime2 + ky * d2u_dyprime2\n\n    # --- 4. Error Calculation ---\n    norm_exact = np.linalg.norm(L_u_exact)\n    \n    # The norm of the exact solution should be non-zero for the given test cases.\n    if norm_exact == 0:\n        # This case should not be reached with the problem's inputs\n        # but is handled for robustness.\n        err_base = 0.0 if np.allclose(L_h_base_u, L_u_exact) else np.inf\n        err_corr = 0.0 if np.allclose(L_h_corr_u, L_u_exact) else np.inf\n    else:\n        err_base = np.linalg.norm(L_h_base_u - L_u_exact) / norm_exact\n        err_corr = np.linalg.norm(L_h_corr_u - L_u_exact) / norm_exact\n\n    # Improvement factor\n    if err_corr > 0:\n        improvement = err_base / err_corr\n    elif err_base > 0: # err_corr is 0\n        improvement = np.inf\n    else: # Both errors are 0\n        improvement = 1.0\n\n    # Improved flag\n    improved = err_corr  err_base\n\n    # Round results and package them\n    return [\n        round(err_base, 8),\n        round(err_corr, 8),\n        round(improvement, 8),\n        improved\n    ]\n\ndef _bilinear_interpolate(x_coords, y_coords, u_grid, h, N):\n    \"\"\"\n    Performs periodic bilinear interpolation on the grid u_grid.\n    x_coords and y_coords are arrays of the same shape specifying points to interpolate.\n    \"\"\"\n    # Scale coordinates to grid index space, with periodic wrapping\n    x_scaled = (x_coords / h) % N\n    y_scaled = (y_coords / h) % N\n\n    # Get integer and fractional parts of scaled coordinates\n    i1 = np.floor(x_scaled).astype(int)\n    j1 = np.floor(y_scaled).astype(int)\n    \n    alpha = x_scaled - i1\n    beta = y_scaled - j1\n    \n    # Get indices of the 4 neighboring grid points (with periodic wrapping)\n    i2 = (i1 + 1) % N\n    j2 = (j1 + 1) % N\n    \n    # Retrieve values at the 4 corner points using advanced indexing\n    u11 = u_grid[i1, j1] # val at (i1, j1)\n    u21 = u_grid[i2, j1] # val at (i2, j1)\n    u12 = u_grid[i1, j2] # val at (i1, j2)\n    u22 = u_grid[i2, j2] # val at (i2, j2)\n\n    # Reshape weights for broadcasting\n    alpha = alpha.reshape(alpha.shape + (1,) * (u11.ndim - alpha.ndim))\n    beta = beta.reshape(beta.shape + (1,) * (u11.ndim - beta.ndim))\n\n    # Bilinear interpolation formula\n    u_interp = (1 - alpha) * (1 - beta) * u11 + \\\n               alpha * (1 - beta) * u21 + \\\n               (1 - alpha) * beta * u12 + \\\n               alpha * beta * u22\n    \n    return u_interp\n\nsolve()\n```"
        }
    ]
}