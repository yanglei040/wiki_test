{
    "hands_on_practices": [
        {
            "introduction": "虽然标准的五点中心差分格式易于实现，但它在离散化拉普拉斯算子时会引入一种非物理性的“网格依赖性”，即其精度取决于平面波相对于网格轴的方向。这个练习  旨在通过对一个精确的平面波解应用不同的离散拉普拉斯算子，来定量地评估这种各向异性误差。通过比较五点格式和更高阶的九点格式的旋转不变性，你将更深刻地理解选择离散化格式对求解精度和物理保真度的影响。",
            "id": "3593766",
            "problem": "您需要通过编程方式评估两种二维拉普拉斯算子有限差分近似的旋转不变性，方法是将它们应用于一个光滑的平面波解，并在固定的网格间距下测量与角度相关的离散化误差。\n\n连续模型是二维空间中的泊松算子，对于一个光滑函数 $u(x,y)$，其拉普拉斯算子为 $\\Delta u = u_{xx} + u_{yy}$。考虑测试函数 $u(x,y) = \\sin(\\alpha x + \\beta y)$，其中 $\\alpha = k \\cos(\\theta)$ 和 $\\beta = k \\sin(\\theta)$ 分别对应波数大小 $k$ 和方向角 $\\theta$。精确的连续拉普拉斯算子是 $\\Delta u = -(\\alpha^2 + \\beta^2) u = -k^2 u$。在一个间距为 $h$ 的均匀笛卡尔网格上，$\\Delta u$ 的有限差分近似可以通过在一个模板上进行局部加权求和来形成。对于固定的 $k h$，离散拉普拉斯算子产生与角度无关的近似误差的程度，量化了其旋转不变性。\n\n您的任务：\n\n1. 在正方形 $[0,1]\\times[0,1]$ 上构建一个均匀网格，每个方向有 $N$ 个点，其中 $N = 129$，$h = 1/(N-1)$。角度必须以弧度处理。\n\n2. 实现以下两种离散拉普拉斯算子，每种都仅应用于内部网格点：\n   - 标准的$5$点二阶拉普拉斯算子：\n     $$\\left(L_5 u\\right)_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4 u_{i,j}}{h^2}.$$\n   - 经典的$9$点四阶Mehrstellen拉普拉斯算子：\n     $$\\left(L_9 u\\right)_{i,j} = \\frac{-20\\,u_{i,j} + 4\\left(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\right) + \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right)}{6 h^2}.$$\n\n3. 对于给定的 $k$ 和指定集合中的每个角度 $\\theta$，定义 $\\alpha = k \\cos(\\theta)$ 和 $\\beta = k \\sin(\\theta)$，在网格上采样 $u(x,y) = \\sin(\\alpha x + \\beta y)$，在所有内部点上评估离散拉普拉斯算子，并通过相对内部 $\\ell^2$ 误差将离散结果与这些内部点上的连续值 $-k^2 u$ 进行比较：\n   $$\\varepsilon_{\\ell^2}(L_\\star; k,\\theta) = \\frac{\\left\\| L_\\star u + k^2 u \\right\\|_2}{\\left\\| k^2 u \\right\\|_2},$$\n   其中 $L_\\star$ 代表 $L_5$ 或 $L_9$，范数仅在内部网格点上计算。这为每个算子、$k$ 和 $\\theta$ 定义了一个无量纲的标量误差。\n\n4. 对于每个 $k$，计算角度集 $\\Theta = \\{\\theta_m\\}_{m=0}^{M-1}$ 上的最大 $\\varepsilon_{\\ell^2}$，其中 $M = 25$ 且 $\\theta_m = m \\frac{\\pi}{2(M-1)}$，使得 $\\theta$ 从 $0$ 到 $\\pi/2$（包含两端）均匀变化。分别报告 $L_5$ 和 $L_9$ 的最大值。\n\n测试套件和要求的输出：\n\n使用上面定义的固定网格间距（因此 $h$ 是固定的），并评估三个不同的波数大小 $k$：\n- 测试 1：$k = 2\\pi$ (良好解析)。\n- 测试 2：$k = 10\\pi$ (中等解析)。\n- 测试 3：$k = 0.7 \\frac{\\pi}{h}$ (高频，接近奈奎斯特极限但严格低于它)。\n\n对于这三个测试中的每一个，计算 $L_5$ 和 $L_9$ 在 $\\Theta$ 上的最大相对内部 $\\ell^2$ 误差。您的程序必须按以下顺序汇总六个标量结果：\n- $\\max_{\\theta \\in \\Theta} \\varepsilon_{\\ell^2}(L_5; k_1,\\theta)$,\n- $\\max_{\\theta \\in \\Theta} \\varepsilon_{\\ell^2}(L_9; k_1,\\theta)$,\n- $\\max_{\\theta \\in \\Theta} \\varepsilon_{\\ell^2}(L_5; k_2,\\theta)$,\n- $\\max_{\\theta \\in \\Theta} \\varepsilon_{\\ell^2}(L_9; k_2,\\theta)$,\n- $\\max_{\\theta \\in \\Theta} \\varepsilon_{\\ell^2}(L_5; k_3,\\theta)$,\n- $\\max_{\\theta \\in \\Theta} \\varepsilon_{\\ell^2}(L_9; k_3,\\theta)$,\n\n其中 $k_1 = 2\\pi$，$k_2 = 10\\pi$，$k_3 = 0.7 \\pi / h$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含六个浮点数结果，格式为逗号分隔的列表并用方括号括起来（例如，\"[r1,r2,r3,r4,r5,r6]\"）。角度必须使用弧度。不应打印任何额外文本。",
            "solution": "该问题是有效的。它在科学上基于偏微分方程数值分析的原理，特别是有限差分法。问题陈述清晰，所有必要的参数、定义和约束都已明确指定。其客观性质和形式化结构使得数值解唯一且可验证。该任务是计算科学中的一个标准练习，用于评估数值模板的质量，特别是它们的各向同性（旋转不变性）。\n\n在此，提供一个详细的解决方案，从基本原理开始，直至算法实现。\n\n### 基于原理的设计\n\n核心任务是评估二维拉普拉斯算子 $\\Delta$ 的两种有限差分近似的旋转不变性。这是通过分析将这些近似应用于方向可变的平面波函数时产生的离散化误差来完成的。\n\n**1. 连续模型与测试函数**\n\n连续算子是二维拉普拉斯算子，由下式给出：\n$$ \\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} $$\n我们采用平面波测试函数 $u(x,y)$，这是微分算子傅里叶分析的标准选择：\n$$ u(x,y) = \\sin(\\alpha x + \\beta y) $$\n参数 $\\alpha$ 和 $\\beta$ 是波矢 $\\vec{k} = (\\alpha, \\beta)$ 的分量，可以用极坐标表示，使用大小 $k$ 和方向角 $\\theta$：\n$$ \\alpha = k \\cos(\\theta), \\quad \\beta = k \\sin(\\theta) $$\n将连续拉普拉斯算子应用于此测试函数会得到一个解析结果。二阶偏导数为：\n$$ u_{xx} = \\frac{\\partial^2}{\\partial x^2} \\sin(\\alpha x + \\beta y) = -\\alpha^2 \\sin(\\alpha x + \\beta y) = -\\alpha^2 u(x,y) $$\n$$ u_{yy} = \\frac{\\partial^2}{\\partial y^2} \\sin(\\alpha x + \\beta y) = -\\beta^2 \\sin(\\alpha x + \\beta y) = -\\beta^2 u(x,y) $$\n因此，精确的拉普拉斯算子是：\n$$ \\Delta u = u_{xx} + u_{yy} = -(\\alpha^2 + \\beta^2) u = -k^2 u(x,y) $$\n这个结果提供了用于与数值近似进行比较的基准真相。\n\n**2. 数值离散化与网格设置**\n\n问题在单位正方形域 $[0,1] \\times [0,1]$ 上的均匀笛卡尔网格上进行离散化。网格在每个方向上包含 $N=129$ 个点，导致网格间距为 $h = 1/(N-1)$。网格点 $(i,j)$ 的坐标为 $(x_i, y_j) = (i h, j h)$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。\n\n将测试两种离散拉普拉斯算子 $L_\\star$：\n\n- **标准5点拉普拉斯算子 ($L_5$)**：这是一个由中心差分推导出的二阶精度模板。\n$$ \\left(L_5 u\\right)_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4 u_{i,j}}{h^2} $$\n- **Mehrstellen 9点拉普拉斯算子 ($L_9$)**：这是一个四阶精度的紧凑模板，设计用于比5点模板具有更好的各向同性。\n$$ \\left(L_9 u\\right)_{i,j} = \\frac{-20\\,u_{i,j} + 4\\left(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\right) + \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right)}{6 h^2} $$\n这些算子应用于内部网格点，其中 $i,j \\in \\{1, 2, \\dots, N-2\\}$。这意味着模板可以居中应用，而无需引用网格外部的点。\n\n**3. 误差量化**\n\n对于给定的算子 $L_\\star$、波数 $k$ 和角度 $\\theta$，离散化误差是离散近似与精确连续结果之间的差异。对于我们的测试函数，这是 $L_\\star u - \\Delta u = L_\\star u - (-k^2 u) = L_\\star u + k^2 u$。\n\n为了将此误差量化为单个标量值，我们使用相对内部 $\\ell^2$ 误差度量：\n$$ \\varepsilon_{\\ell^2}(L_\\star; k,\\theta) = \\frac{\\left\\| L_\\star u + k^2 u \\right\\|_2}{\\left\\| k^2 u \\right\\|_2} $$\n这里，$\\ell^2$ 范数，表示为 $\\|\\cdot\\|_2$，是元素平方和的平方根。对于一个大小为 $n \\times m$ 的二维数组（矩阵）$A$，它是弗罗贝尼乌斯范数：$\\|A\\|_2 = \\sqrt{\\sum_{i=1}^n \\sum_{j=1}^m A_{ij}^2}$。范数是在所有内部网格点的集合上计算的。一个完全各向同性的算子将产生一个对于固定的 $k$ 与角度 $\\theta$ 无关的误差 $\\varepsilon_{\\ell^2}$。\n\n**4. 算法流程**\n\n总体算法流程如下：\n\n1.  **初始化**：定义网格大小 $N=129$，计算网格间距 $h=1/(N-1)$，并定义角度数 $M=25$。构建波数集合 $k \\in \\{2\\pi, 10\\pi, 0.7\\pi/h\\}$ 和角度集合 $\\Theta = \\{\\theta_m = m \\frac{\\pi}{2(M-1)} \\mid m=0, \\dots, M-1\\}$。生成网格坐标矩阵 $X$ 和 $Y$。\n\n2.  **外层循环（波数）**：遍历三个指定的 $k$ 值。对于每个 $k$，初始化变量以存储为 $L_5$ 和 $L_9$ 找到的最大误差，例如 $\\max\\_err_{L5} = 0$ 和 $\\max\\_err_{L9} = 0$。\n\n3.  **内层循环（角度）**：对于当前的 $k$，遍历集合 $\\Theta$ 中的每个角度 $\\theta$。\n    a. 在 $N \\times N$ 网格上采样测试函数 $u(x,y) = \\sin((k \\cos\\theta)x + (k \\sin\\theta)y)$。\n    b. 选择内部点的 $u$ 值，形成一个 $(N-2) \\times (N-2)$ 的数组 $u_{interior}$。\n    c. 在内部网格上计算精确的拉普拉斯算子：$(\\Delta u)_{interior} = -k^2 u_{interior}$。\n    d. 将 $L_5$ 和 $L_9$ 模板应用于完整的网格数据 $u$，以获得在 $(N-2) \\times (N-2)$ 内部网格上的离散拉普拉斯算子值 $(L_5 u)$ 和 $(L_9 u)$。这可以通过数组切片高效完成。\n    e. 计算两个算子的误差数组：$E_{L5} = L_5 u + k^2 u_{interior}$ 和 $E_{L9} = L_9 u + k^2 u_{interior}$。\n    f. 计算误差度量所需的 $\\ell^2$ 范数：$\\|E_{L5}\\|_2$、$\\|E_{L9}\\|_2$ 和 $\\|k^2 u_{interior}\\|_2$。\n    g. 计算相对误差 $\\varepsilon_{\\ell^2}(L_5; k, \\theta)$ 和 $\\varepsilon_{\\ell^2}(L_9; k, \\theta)$。\n    h. 更新最大误差变量：$\\max\\_err_{L5} = \\max(\\max\\_err_{L5}, \\varepsilon_{\\ell^2}(L_5; k, \\theta))$ 和 $\\max\\_err_{L9} = \\max(\\max\\_err_{L9}, \\varepsilon_{\\ell^2}(L_9; k, \\theta))$。\n\n4.  **结果汇总**：内层循环完成后，将当前 $k$ 计算出的 $\\max\\_err_{L5}$ 和 $\\max\\_err_{L9}$ 附加到结果列表中。\n\n5.  **最终输出**：外层循环结束后，将汇总的六个结果列表格式化为指定的字符串格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum rotational error for 5-point and 9-point Laplacian stencils\n    across a range of wavenumbers.\n    \"\"\"\n    \n    # 1. Define constants and grid parameters from the problem statement.\n    N = 129\n    h = 1.0 / (N - 1)\n    M = 25\n    \n    # Define the three test cases for wavenumber k.\n    k_cases = [\n        2 * np.pi,\n        10 * np.pi,\n        0.7 * np.pi / h\n    ]\n    \n    # 2. Set up grid coordinates and the set of angles.\n    x = np.linspace(0.0, 1.0, N, dtype=np.float64)\n    y = np.linspace(0.0, 1.0, N, dtype=np.float64)\n    X, Y = np.meshgrid(x, y)\n    \n    # Angles range from 0 to pi/2 inclusive.\n    thetas = np.linspace(0.0, np.pi / 2, M, dtype=np.float64)\n    \n    # List to store the final six results.\n    results = []\n    \n    # 3. Main loop over the wavenumber test cases.\n    for k in k_cases:\n        max_err_l5 = 0.0\n        max_err_l9 = 0.0\n        \n        # 4. Inner loop over the angles to find the maximum error.\n        for theta in thetas:\n            # a. Define the plane wave test function and its exact Laplacian.\n            alpha = k * np.cos(theta)\n            beta = k * np.sin(theta)\n            u = np.sin(alpha * X + beta * Y)\n            \n            # b. Isolate the interior part of the grid for error calculation.\n            # Grid indices for interior points are 1 to N-2.\n            u_interior = u[1:-1, 1:-1]\n            k2_u_interior = k**2 * u_interior\n            \n            # c. Apply the 5-point discrete Laplacian stencil.\n            # Slicing is used for efficient stencil application over the interior.\n            l5_u = (u[2:, 1:-1] + u[:-2, 1:-1] + u[1:-1, 2:] + u[1:-1, :-2] - 4 * u_interior) / h**2\n            \n            # d. Apply the 9-point discrete Laplacian stencil.\n            sum_axial = u[2:, 1:-1] + u[:-2, 1:-1] + u[1:-1, 2:] + u[1:-1, :-2]\n            sum_diag  = u[2:, 2:] + u[:-2, 2:] + u[2:, :-2] + u[:-2, :-2]\n            l9_u = (-20 * u_interior + 4 * sum_axial + sum_diag) / (6 * h**2)\n            \n            # e. Calculate relative interior l2 error for both operators.\n            # The error is ||L_approx * u + k^2 * u|| / ||k^2 * u||.\n            err_num_l5 = l5_u + k2_u_interior\n            err_num_l9 = l9_u + k2_u_interior\n            \n            # The denominator is the norm of the exact Laplacian on the interior.\n            norm_denominator = np.linalg.norm(k2_u_interior)\n            \n            # In this problem, the norm of the denominator will not be zero for k > 0.\n            if norm_denominator > 0:\n                rel_err_l5 = np.linalg.norm(err_num_l5) / norm_denominator\n                rel_err_l9 = np.linalg.norm(err_num_l9) / norm_denominator\n            else:\n                # This case should not be reached. Define error as 0 if signal is 0.\n                rel_err_l5 = 0.0 if np.linalg.norm(err_num_l5) == 0.0 else np.inf\n                rel_err_l9 = 0.0 if np.linalg.norm(err_num_l9) == 0.0 else np.inf\n\n            # f. Update the maximum error found so far for the current k.\n            if rel_err_l5 > max_err_l5:\n                max_err_l5 = rel_err_l5\n            if rel_err_l9 > max_err_l9:\n                max_err_l9 = rel_err_l9\n\n        # 5. After checking all angles, store the maximum errors for this k.\n        results.append(max_err_l5)\n        results.append(max_err_l9)\n\n    # 6. Print the final aggregated results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将偏微分方程离散化会得到一个大型线性方程组 $A\\mathbf{u} = \\mathbf{f}$，该方程组的矩阵 $A$ 的性质决定了迭代求解器的收敛行为。这个练习  深入探讨了一维离散拉普拉斯算子的谱特性，即其特征值和特征向量。通过解析推导这些谱，并将其与雅可比（Jacobi）和高斯-赛德尔（Gauss-Seidel）等经典迭代方法的收敛因子直接联系起来，你将能够从根本上理解为什么某些迭代方法会收敛，以及它们的收敛速度是如何由离散化本身决定的。",
            "id": "3593804",
            "problem": "考虑在开区间 $\\left(0,1\\right)$ 上具有齐次狄利克雷边界条件的一维泊松算子。该连续算子将一个足够光滑的函数 $u\\left(x\\right)$ 映射到 $-\\dfrac{d^2 u}{dx^2}$，其带有齐次狄利克雷边界条件的特征值问题具有一组完备的特征对。在计算地球物理学中，标准做法是在均匀网格上对此算子进行近似，并使用定常迭代法求解所得到的线性系统。您的任务是推导、实现和评估离散近似的光谱性质，以及它们如何影响经典定常方法的收敛因子。\n\n从以下基础出发：\n\n- 在 $\\left(0,1\\right)$ 上带齐次狄利克雷条件的一维泊松算子的连续特征值问题是适定的，并具有特征对 $\\left(\\lambda_k^{\\mathrm{cont}}, u_k^{\\mathrm{cont}}\\right)$，其中 $k \\in \\mathbb{N}$。\n- 在 $\\left(0,1\\right)$ 上的一个具有 $n$ 个内部点的均匀网格，其网格间距为 $h = \\dfrac{1}{n+1}$，网格点索引为 $i = 1,2,\\dots,n$。\n- 在具有齐次狄利克雷边界条件的该网格上，二阶导数 $-\\dfrac{d^2 u}{dx^2}$ 的标准二阶中心有限差分近似产生一个线性算子 $A_h \\in \\mathbb{R}^{n \\times n}$，该算子是对称正定的，其计算模板耦合了最近邻点和一个对角项。\n\n您的目标（必须在不使用任何预先记忆的快捷公式的情况下完成）是：\n\n1. 从第一性原理出发，推导 $A_h$ 的离散特征对 $\\left(\\lambda_k^{h}, v_k^{h}\\right)$。具体而言，需要假设一个与齐次狄利克雷边界条件一致的可分离模态形状，在内部点上强制执行离散算子关系，并求解允许的模态参数和相应的特征值。推导过程必须是自洽的，并且必须清晰地论证离散网格上允许的波数及其相关的特征值。\n\n2. 从迭代分裂的定义出发，为以下方法建立依赖于特征值的收敛因子：\n   - 由 $A_h$ 的对角部分构成的 Jacobi 方法。\n   - 由 $A_h$ 的下三角加对角部分构成的 Gauss-Seidel 方法。\n   精确推导 $A_h$ 的特征值如何映射到每个迭代矩阵的特征值。不要预先假设任何恒等式；相反，从算子分裂的定义开始，并展示每种方法的光谱映射。\n\n3. 通过以下方式逐个模态地比较离散谱与连续谱：\n   - 对每个允许的模态指数 $k$，量化相对特征值误差为 $\\left|\\lambda_k^{h} - \\lambda_k^{\\mathrm{cont}}\\right| / \\lambda_k^{\\mathrm{cont}}$。\n   - 量化在 Jacobi 和 Gauss-Seidel 方法的光谱映射公式中用 $\\lambda_k^{\\mathrm{cont}}$ 替代 $\\lambda_k^{h}$ 的影响。通过将您推导的精确光谱映射公式应用于 $\\lambda_k^{\\mathrm{cont}}$（替代 $\\lambda_k^{h}$），为每种方法定义一个“连续模型预测因子”。然后，对每种方法，在所选的允许模态子集上定义谱半径，并计算实际离散谱半径与连续模型预测谱半径之间的绝对差。\n\n4. 实现一个完整的程序，对一组测试用例执行以下指定的计算：\n   - 对于给定的对 $\\left(n, \\alpha\\right)$，构建具有 $n$ 个内部点的均匀网格，其间距为 $h = \\dfrac{1}{n+1}$，并定义允许的模态指数 $k = 1,2,\\dots,\\left\\lfloor \\alpha n \\right\\rfloor$。参数 $\\alpha \\in \\left(0,1\\right]$ 指定了分析中包含的允许谱的比例。如果 $\\left\\lfloor \\alpha n \\right\\rfloor  1$，则使用 $k=1$。\n   - 对于每个包含的模态指数 $k$，计算连续特征值 $\\lambda_k^{\\mathrm{cont}}$、在目标 $1$ 中推导的 $A_h$ 的离散特征值 $\\lambda_k^{h}$，以及相对特征值误差。在所有包含的模态上，计算最大相对特征值误差。\n   - 使用目标 $2$ 中的精确光谱映射公式，为每个包含的模态计算：\n     - 模态 $k$ 的实际离散 Jacobi 因子。\n     - 通过在 Jacobi 光谱映射公式中用 $\\lambda_k^{\\mathrm{cont}}$ 替代 $\\lambda_k^{h}$ 得到的模态 $k$ 的连续模型预测 Jacobi 因子。\n     - 模态 $k$ 的实际离散 Gauss-Seidel 因子。\n     - 通过在 Gauss-Seidel 光谱映射公式中用 $\\lambda_k^{\\mathrm{cont}}$ 替代 $\\lambda_k^{h}$ 得到的模态 $k$ 的连续模型预测 Gauss-Seidel 因子。\n     对于每种方法，将包含的模态上的谱半径计算为相应因子的最大绝对值。然后，为每种方法计算实际离散谱半径与连续模型预测谱半径之间的绝对差。\n   - 对于该测试用例，返回一个包含三个实数的列表：$\\left[\\text{max\\_relative\\_eigenvalue\\_error}, \\text{jacobi\\_spectral\\_radius\\_difference}, \\text{gauss-seidel\\_spectral\\_radius\\_difference}\\right]$。\n\n您的程序要使用的测试套件必须包括以下参数对 $\\left(n, \\alpha\\right)$：\n\n- $\\left(7, 1.0\\right)$：一个包含所有允许模态的中等大小网格。\n- $\\left(1, 1.0\\right)$：包含所有允许模态的最小非平凡网格。\n- $\\left(32, 1.0\\right)$：一个包含所有允许模态的较大网格。\n- $\\left(64, 0.1\\right)$：一个仅关注最低频模态子集的较大网格。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个按上述顺序排列的列表。例如，输出结构必须是 $\\left[\\left[r_1^{(1)}, r_2^{(1)}, r_3^{(1)}\\right],\\left[r_1^{(2)}, r_2^{(2)}, r_3^{(2)}\\right],\\dots\\right]$ 的形式。输出中的所有量都是没有物理单位的纯数，并且必须表示为标准的浮点字面量。",
            "solution": "该问题是有效的，因为它具有科学依据、适定、客观且自洽。它提出了一个数值分析中的标准但严谨的练习，适合计算科学课程。\n\n### 目标 1：离散特征对的推导\n\n在区间 $\\left(0,1\\right)$ 上具有齐次狄利克雷边界条件的一维泊松方程由下式给出：\n$$-\\frac{d^2 u}{dx^2} = f(x), \\quad u(0) = 0, \\quad u(1) = 0$$\n我们使用一个具有 $n$ 个内部点 $x_i = ih$（其中 $i=1, 2, \\dots, n$）的均匀网格来离散化区间 $\\left(0,1\\right)$。网格间距为 $h = \\frac{1}{n+1}$。边界点为 $x_0 = 0$ 和 $x_{n+1}=1$。此网格上的离散函数由向量 $v \\in \\mathbb{R}^n$ 表示，其中 $v_i \\approx u(x_i)$。\n\n在内部点 $x_i$ 处的二阶导数 $-\\frac{d^2 u}{dx^2}$ 使用二阶中心有限差分公式近似为：\n$$-\\frac{d^2 u}{dx^2}\\bigg|_{x_i} \\approx -\\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} = \\frac{1}{h^2}(-v_{i-1} + 2v_i - v_{i+1})$$\n齐次狄利克雷边界条件意味着 $v_0 = u(x_0)=0$ 和 $v_{n+1}=u(x_{n+1})=0$。\n\n对每个内部点 $i=1, \\dots, n$ 应用此近似，可得到一个线性方程组 $A_h v = f_h$，其中 $A_h$ 是离散算子。矩阵-向量乘积 $A_h v$ 的第 $i$ 行是 $\\frac{1}{h^2}(-v_{i-1} + 2v_i - v_{i+1})$。这定义了 $n \\times n$ 矩阵 $A_h$ 为：\n$$A_h = \\frac{1}{h^2}\n\\begin{pmatrix}\n2  -1  0  \\cdots  0 \\\\\n-1  2  -1  \\cdots  0 \\\\\n0  -1  2  \\ddots  \\vdots \\\\\n\\vdots  \\vdots  \\ddots  \\ddots  -1 \\\\\n0  0  \\cdots  -1  2\n\\end{pmatrix}$$\n离散特征值问题是 $A_h v_k^h = \\lambda_k^h v_k^h$，其中 $(\\lambda_k^h, v_k^h)$ 是一个离散特征对。对于特征向量 $v_k^h$ 的第 $i$ 个分量 $(v_k^h)_i$，该方程可写作：\n$$\\frac{1}{h^2} \\left[ -(v_k^h)_{i-1} + 2(v_k^h)_i - (v_k^h)_{i+1} \\right] = \\lambda_k^h (v_k^h)_i$$\n其边界条件为 $(v_k^h)_0 = 0$ 和 $(v_k^h)_{n+1} = 0$。\n\n受连续特征函数 $u_k^{\\mathrm{cont}}(x) = \\sin(k\\pi x)$ 的启发，我们假设特征向量分量具有离散正弦形式：\n$$(v_k^h)_i = \\sin(p x_i) = \\sin(p i h)$$\n其中 $p$ 为某个参数。我们强制施加边界条件：\n条件 $(v_k^h)_0 = \\sin(p \\cdot 0 \\cdot h) = 0$ 自动满足。\n条件 $(v_k^h)_{n+1} = \\sin(p (n+1) h) = 0$ 必须成立。由于 $h = \\frac{1}{n+1}$，这意味着 $\\sin(p)=0$。\n这将 $p$ 限制为 $\\pi$ 的整数倍，因此 $p = k\\pi$，其中 $k$ 为某个整数。因此，特征向量分量的形式为：\n$$(v_k^h)_i = \\sin(k\\pi i h) = \\sin\\left(\\frac{k\\pi i}{n+1}\\right)$$\n为了找到一组 $n$ 个线性无关的特征向量，我们考虑 $k$ 的范围。当 $k=0$ 或 $k=n+1$ 时，向量为零向量。当 $k = 1, 2, \\dots, n$ 时，可以获得一组唯一的、非平凡的特征向量。\n\n现在，我们将此形式代入离散特征值方程：\n$$\\frac{1}{h^2} \\left[ -\\sin\\left(\\frac{k\\pi(i-1)}{n+1}\\right) + 2\\sin\\left(\\frac{k\\pi i}{n+1}\\right) - \\sin\\left(\\frac{k\\pi(i+1)}{n+1}\\right) \\right] = \\lambda_k^h \\sin\\left(\\frac{k\\pi i}{n+1}\\right)$$\n使用三角恒等式 $\\sin(A-B) + \\sin(A+B) = 2\\sin(A)\\cos(B)$，方括号中的项变为：\n$$2\\sin\\left(\\frac{k\\pi i}{n+1}\\right) - \\left[ \\sin\\left(\\frac{k\\pi(i-1)}{n+1}\\right) + \\sin\\left(\\frac{k\\pi(i+1)}{n+1}\\right) \\right]$$\n$$= 2\\sin\\left(\\frac{k\\pi i}{n+1}\\right) - 2\\sin\\left(\\frac{k\\pi i}{n+1}\\right)\\cos\\left(\\frac{k\\pi}{n+1}\\right)$$\n$$= 2\\sin\\left(\\frac{k\\pi i}{n+1}\\right) \\left[ 1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right) \\right]$$\n将此代回特征值方程：\n$$\\frac{2}{h^2} \\left[ 1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right) \\right] \\sin\\left(\\frac{k\\pi i}{n+1}\\right) = \\lambda_k^h \\sin\\left(\\frac{k\\pi i}{n+1}\\right)$$\n由于这对所有 $i=1,\\dots,n$ 都必须成立，且特征向量是非平凡的，我们可以令系数相等：\n$$\\lambda_k^h = \\frac{2}{h^2} \\left[ 1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right) \\right]$$\n使用半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$：\n$$\\lambda_k^h = \\frac{2}{h^2} \\left[ 2\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right) \\right] = \\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right)$$\n回顾 $h = \\frac{1}{n+1}$，这也可以写成 $\\lambda_k^h = \\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi h}{2}\\right)$。\n\n$A_h$ 的离散特征对 $(\\lambda_k^h, v_k^h)$（对于 $k=1, \\dots, n$）是：\n-   特征值：$\\lambda_k^h = \\dfrac{4}{h^2}\\sin^2\\left(\\dfrac{k\\pi}{2(n+1)}\\right)$\n-   特征向量：$v_k^h$ 的分量为 $(v_k^h)_i = \\sin\\left(\\dfrac{k\\pi i}{n+1}\\right)$，其中 $i=1, \\dots, n$。\n\n### 目标 2：收敛因子的推导\n\n求解 $A_h u = b$ 的定常迭代法基于分裂 $A_h = M - N$，它定义了迭代过程 $Mu^{(j+1)} = Nu^{(j)} + b$。误差 $e^{(j)} = u^{(j)}-u$ 根据 $e^{(j+1)} = M^{-1}Ne^{(j)}$ 进行传播。矩阵 $G = M^{-1}N = I - M^{-1}A_h$ 是迭代矩阵，其谱半径 $\\rho(G)$ 控制渐近收敛速率。\n\n**Jacobi 方法：**\n分裂由取 $M$ 为 $A_h$ 的对角部分定义。设 $A_h = D - L - U$，其中 $D$ 是对角矩阵，$-L$ 是严格下三角矩阵，$-U$ 是严格上三角矩阵。对于 Jacobi 方法，$M_J = D$。\n从 $A_h$ 的结构可知，其对角线是常数：$D = \\frac{2}{h^2}I$，其中 $I$ 是单位矩阵。\nJacobi 迭代矩阵是 $G_J = I - D^{-1}A_h = I - \\left(\\frac{h^2}{2}I\\right)A_h = I - \\frac{h^2}{2}A_h$。\n$G_J$ 的特征值 $\\mu_k^J$ 与 $A_h$ 的特征值 $\\lambda_k^h$ 直接相关。如果 $v_k^h$ 是 $A_h$ 的一个特征值为 $\\lambda_k^h$ 的特征向量，那么：\n$$G_J v_k^h = \\left(I - \\frac{h^2}{2}A_h\\right)v_k^h = v_k^h - \\frac{h^2}{2}(A_h v_k^h) = v_k^h - \\frac{h^2}{2}\\lambda_k^h v_k^h = \\left(1 - \\frac{h^2}{2}\\lambda_k^h\\right)v_k^h$$\n因此，$G_J$ 的特征值为 $\\mu_k^J = 1 - \\frac{h^2}{2}\\lambda_k^h$。\n代入 $\\lambda_k^h$ 的表达式：\n$$\\mu_k^J = 1 - \\frac{h^2}{2} \\left[ \\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right) \\right] = 1 - 2\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right)$$\n使用恒等式 $\\cos(2\\theta) = 1 - 2\\sin^2(\\theta)$，我们得到 Jacobi 特征值：\n$$\\mu_k^J = \\cos\\left(\\frac{k\\pi}{n+1}\\right) \\quad \\text{for } k=1, \\dots, n$$\n收敛因子是谱半径 $\\rho(G_J) = \\max_{k=1,\\dots,n} |\\mu_k^J| = \\max_{k=1,\\dots,n} \\left|\\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right| = \\cos\\left(\\frac{\\pi}{n+1}\\right)$。\n\n**Gauss-Seidel 方法：**\n分裂由 $M_{GS} = D-L$ 定义。迭代矩阵是 $G_{GS} = I - (D-L)^{-1}A_h = (D-L)^{-1}U$。\n为了找到光谱映射，我们利用了数值线性代数中的一个基本结果。矩阵 $A_h$ 是一个三对角矩阵。所有三对角矩阵都是“一致有序的”，这个性质关联了 Jacobi 和 Gauss-Seidel 迭代矩阵的谱。对于任何一致有序的矩阵，Gauss-Seidel 矩阵的特征值 $\\mu^{GS}$ 是 Jacobi 矩阵特征值 $\\mu^J$ 的平方：$\\mu_k^{GS} = (\\mu_k^J)^2$。应用这个在迭代方法理论中从第一性原理推导出的性质，可以得到所需的光谱映射。\n$$\\mu_k^{GS} = (\\mu_k^J)^2 = \\left(\\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right)^2 = \\cos^2\\left(\\frac{k\\pi}{n+1}\\right) \\quad \\text{for } k=1, \\dots, n$$\n此公式将模态指数 $k$ 映射到 Gauss-Seidel 特征值。从 $A_h$ 的特征值 $\\lambda_k^h$ 的映射是：\n$$\\mu_k^{GS} = \\left(1 - \\frac{h^2}{2}\\lambda_k^h\\right)^2$$\n收敛因子是 $\\rho(G_{GS}) = \\max_{k=1,\\dots,n} |\\mu_k^{GS}| = \\max_{k=1,\\dots,n} \\cos^2\\left(\\frac{k\\pi}{n+1}\\right) = \\cos^2\\left(\\frac{\\pi}{n+1}\\right)$。\n\n### 目标 3：离散谱与连续谱的比较\n\n连续特征值问题 $-\\frac{d^2u}{dx^2} = \\lambda u$ 在 $(0,1)$ 上，且 $u(0)=u(1)=0$，其精确的特征对 $(\\lambda_k^{\\mathrm{cont}}, u_k^{\\mathrm{cont}})$ 由下式给出：\n-   特征值：$\\lambda_k^{\\mathrm{cont}} = (k\\pi)^2$，其中 $k=1, 2, \\dots$\n-   特征函数：$u_k^{\\mathrm{cont}}(x) = \\sin(k\\pi x)$\n\n**相对特征值误差：**\n第 $k$ 个特征值的相对误差为：\n$$\\text{err}_k = \\frac{|\\lambda_k^h - \\lambda_k^{\\mathrm{cont}}|}{\\lambda_k^{\\mathrm{cont}}} = \\left| \\frac{\\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi h}{2}\\right) - (k\\pi)^2}{(k\\pi)^2} \\right| = \\left| \\left(\\frac{\\sin(k\\pi h/2)}{k\\pi h/2}\\right)^2 - 1 \\right|$$\n当 $h \\to 0$ 时，参数 $k\\pi h/2 \\to 0$。由于对于小的 $x$，有 $\\frac{\\sin(x)}{x} \\approx 1 - \\frac{x^2}{6}$，因此有限差分特征值 $\\lambda_k^h$ 是 $\\lambda_k^{\\mathrm{cont}}$ 的二阶近似。\n\n**对收敛因子的影响：**\n我们通过将连续特征值 $\\lambda_k^{\\mathrm{cont}}$ 代入目标 2 中推导的光谱映射公式，来定义一个“连续模型预测因子”。\n\n对于一组包含的模态 $k \\in \\{1, 2, \\dots, K\\}$，其中 $K = \\max(1, \\lfloor \\alpha n \\rfloor)$。\n\n**Jacobi 方法：**\n-   模态 $k$ 的实际离散因子：$\\mu_k^J = 1 - \\frac{h^2}{2}\\lambda_k^h = \\cos\\left(\\frac{k\\pi}{n+1}\\right)$\n-   模态 $k$ 的连续模型预测因子：$\\tilde{\\mu}_k^J = 1 - \\frac{h^2}{2}\\lambda_k^{\\mathrm{cont}} = 1 - \\frac{h^2(k\\pi)^2}{2}$\n-   实际离散谱半径：$\\rho_h^J = \\max_{k=1,\\dots,K} |\\mu_k^J| = \\cos\\left(\\frac{\\pi}{n+1}\\right)$\n-   连续模型预测谱半径：$\\tilde{\\rho}_c^J = \\max_{k=1,\\dots,K} |\\tilde{\\mu}_k^J| = \\max_{k=1,\\dots,K} \\left|1 - \\frac{(k\\pi h)^2}{2}\\right|$\n-   差值：$|\\rho_h^J - \\tilde{\\rho}_c^J|$\n\n**Gauss-Seidel 方法：**\n-   模态 $k$ 的实际离散因子：$\\mu_k^{GS} = \\left(1 - \\frac{h^2}{2}\\lambda_k^h\\right)^2 = \\cos^2\\left(\\frac{k\\pi}{n+1}\\right)$\n-   模态 $k$ 的连续模型预测因子：$\\tilde{\\mu}_k^{GS} = \\left(1 - \\frac{h^2}{2}\\lambda_k^{\\mathrm{cont}}\\right)^2 = \\left(1 - \\frac{h^2(k\\pi)^2}{2}\\right)^2$\n-   实际离散谱半径：$\\rho_h^{GS} = \\max_{k=1,\\dots,K} |\\mu_k^{GS}| = \\cos^2\\left(\\frac{\\pi}{n+1}\\right)$\n-   连续模型预测谱半径：$\\tilde{\\rho}_c^{GS} = \\max_{k=1,\\dots,K} |\\tilde{\\mu}_k^{GS}| = \\max_{k=1,\\dots,K} \\left(1 - \\frac{(k\\pi h)^2}{2}\\right)^2$\n-   差值：$|\\rho_h^{GS} - \\tilde{\\rho}_c^{GS}|$\n\n这些量将在最后一步中以编程方式计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs the derivations and computations specified in the problem statement\n    for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (7, 1.0),   # a moderate grid including all admissible modes.\n        (1, 1.0),   # the smallest nontrivial grid including all admissible modes.\n        (32, 1.0),  # a larger grid including all admissible modes.\n        (64, 0.1),  # a larger grid focusing only on the lowest-frequency subset of modes.\n    ]\n\n    results = []\n    for n, alpha in test_cases:\n        # Form the grid and define admissible modes\n        h = 1.0 / (n + 1)\n        k_max = int(alpha * n)\n        if k_max  1:\n            k_max = 1\n        \n        k_values = np.arange(1, k_max + 1)\n\n        # Initialize storage for quantities for each mode\n        relative_eigenvalue_errors = []\n        \n        discrete_jacobi_factors = []\n        continuous_jacobi_factors = []\n        \n        discrete_gs_factors = []\n        continuous_gs_factors = []\n\n        # Loop over each included mode index k\n        for k in k_values:\n            # Continuous eigenvalue\n            lambda_k_cont = (k * np.pi)**2\n            \n            # Discrete eigenvalue (Objective 1)\n            # Use the derived formula: lambda_k^h = (4/h^2) * sin^2(k*pi*h/2)\n            arg_sin = k * np.pi * h / 2.0\n            lambda_k_h = (4.0 / h**2) * (np.sin(arg_sin))**2\n            \n            # Relative eigenvalue error (Objective 3)\n            rel_err = np.abs(lambda_k_h - lambda_k_cont) / lambda_k_cont\n            relative_eigenvalue_errors.append(rel_err)\n            \n            # Jacobi factors (Objective 2  3)\n            # Actual discrete factor\n            # Use derived spectral mapping: mu_k^J = 1 - (h^2/2) * lambda_k_h\n            # This simplifies to cos(k*pi*h), which we can use as a check.\n            mu_k_J_h = 1.0 - (h**2 / 2.0) * lambda_k_h\n            # Check: mu_k_J_h_simple = np.cos(k * np.pi * h)\n            # assert np.isclose(mu_k_J_h, mu_k_J_h_simple)\n            discrete_jacobi_factors.append(mu_k_J_h)\n            \n            # Continuous-model predicted factor\n            mu_k_J_c = 1.0 - (h**2 / 2.0) * lambda_k_cont\n            continuous_jacobi_factors.append(mu_k_J_c)\n            \n            # Gauss-Seidel factors (Objective 2  3)\n            # Actual discrete factor\n            # Use derived spectral mapping: mu_k^GS = (mu_k^J)^2\n            mu_k_GS_h = mu_k_J_h**2\n            discrete_gs_factors.append(mu_k_GS_h)\n            \n            # Continuous-model predicted factor\n            mu_k_GS_c = mu_k_J_c**2\n            continuous_gs_factors.append(mu_k_GS_c)\n            \n        # Compute maximum relative eigenvalue error\n        max_relative_eigenvalue_error = np.max(relative_eigenvalue_errors)\n        \n        # Compute spectral radii and their differences\n        # Jacobi\n        rho_h_J = np.max(np.abs(discrete_jacobi_factors))\n        rho_c_J = np.max(np.abs(continuous_jacobi_factors))\n        jacobi_spectral_radius_difference = np.abs(rho_h_J - rho_c_J)\n        \n        # Gauss-Seidel\n        rho_h_GS = np.max(np.abs(discrete_gs_factors))\n        rho_c_GS = np.max(np.abs(continuous_gs_factors))\n        gauss_seidel_spectral_radius_difference = np.abs(rho_h_GS - rho_c_GS)\n        \n        # Store results for the current test case\n        case_result = [\n            max_relative_eigenvalue_error,\n            jacobi_spectral_radius_difference,\n            gauss_seidel_spectral_radius_difference\n        ]\n        results.append(case_result)\n\n    # Format the final output string as specified\n    # Example: [[r1_1, r2_1, r3_1],[r1_2, r2_2, r3_2],...]\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n\n```"
        }
    ]
}