{
    "hands_on_practices": [
        {
            "introduction": "The power of the finite element method lies in its ability to approximate complex solutions using a basis of simple, local polynomials called shape functions. This first practice  is a foundational exercise where you will construct the most common linear ($P_1$) and quadratic ($P_2$) shape functions on a standard reference triangle. By verifying their core properties, you will gain a concrete understanding of the polynomial building blocks that underpin the entire method.",
            "id": "3595599",
            "problem": "Consider the two-dimensional Poisson equation $-\\nabla \\cdot \\left( \\kappa \\nabla u \\right) = f$ posed on a domain $\\Omega \\subset \\mathbb{R}^{2}$, where $\\kappa$ is a spatially varying scalar conductivity, representative of subsurface materials in computational geophysics, and $f$ is a source term representing, for instance, body forces due to density variations. In the Finite Element Method (FEM), conforming Lagrange elements are employed to approximate the weak solution, requiring construction of shape functions on a reference element and verification of their interpolation properties.\n\nLet the reference triangle be $\\hat{K} = \\{ (\\xi,\\eta) \\in \\mathbb{R}^{2} : \\xi \\ge 0,\\ \\eta \\ge 0,\\ \\xi + \\eta \\le 1 \\}$ with vertices at $(0,0)$, $(1,0)$, and $(0,1)$. Denote the barycentric coordinates by $\\lambda_{1} = 1 - \\xi - \\eta$, $\\lambda_{2} = \\xi$, and $\\lambda_{3} = \\eta$.\n\nTasks:\n- Construct the shape functions for the piecewise linear ($P_{1}$) Lagrange element on $\\hat{K}$ and verify the partition of unity and Kronecker delta interpolation properties at the three vertex nodes.\n- Construct the shape functions for the piecewise quadratic ($P_{2}$) Lagrange element on $\\hat{K}$ associated with the six nodal points (the three vertices and the three edge midpoints), and verify the partition of unity and Kronecker delta interpolation properties at all six nodes.\n- As a quantitative consistency check relevant to mass matrix assembly in FEM discretizations of the Poisson equation, compute the scalar integral\n$$\nJ_{2} \\;=\\; \\int_{\\hat{K}} \\left( \\sum_{i=1}^{6} \\phi_{i}^{(2)}(\\xi,\\eta)^{2} \\right)\\, d\\xi\\, d\\eta,\n$$\nwhere $\\{ \\phi_{i}^{(2)} \\}_{i=1}^{6}$ are the $P_{2}$ shape functions constructed on $\\hat{K}$. Provide the exact value of $J_{2}$ as a single real number. Do not round; give the exact value.",
            "solution": "The problem requires the construction and verification of Lagrange finite element shape functions for linear ($P_1$) and quadratic ($P_2$) polynomials on a reference triangle $\\hat{K}$, and a subsequent quantitative check by computing a specific integral involving the $P_2$ shape functions.\n\nLet the reference triangle be $\\hat{K} = \\{ (\\xi,\\eta) \\in \\mathbb{R}^{2} : \\xi \\ge 0,\\ \\eta \\ge 0,\\ \\xi + \\eta \\le 1 \\}$. The vertices are located at $v_{1} = (0,0)$, $v_{2} = (1,0)$, and $v_{3} = (0,1)$. The barycentric coordinates, which are linear functions on $\\hat{K}$, are given as $\\lambda_{1} = 1 - \\xi - \\eta$, $\\lambda_{2} = \\xi$, and $\\lambda_{3} = \\eta$. A key property of barycentric coordinates is that at any point $(\\xi, \\eta) \\in \\hat{K}$, they are non-negative and sum to unity: $\\lambda_{1} + \\lambda_{2} + \\lambda_{3} = 1$. Also, the coordinate $\\lambda_i$ is equal to $1$ at vertex $v_i$ and $0$ at the other two vertices.\n\n**Part 1: $P_1$ Lagrange Element**\n\nThe piecewise linear ($P_1$) Lagrange element on the triangle $\\hat{K}$ is defined by a set of $3$ nodes, which are the vertices of the triangle: $n_1 = v_1 = (0,0)$, $n_2 = v_2 = (1,0)$, and $n_3 = v_3 = (0,1)$. The corresponding shape functions, denoted by $\\phi_i^{(1)}$, must be linear polynomials and satisfy the Kronecker delta property, $\\phi_i^{(1)}(n_j) = \\delta_{ij}$, where $\\delta_{ij}$ is the Kronecker delta.\n\nThe barycentric coordinates themselves are linear functions and inherently satisfy this property at the vertices. Therefore, the $P_1$ shape functions are simply the barycentric coordinates:\n- $\\phi_{1}^{(1)}(\\xi,\\eta) = \\lambda_{1} = 1 - \\xi - \\eta$\n- $\\phi_{2}^{(1)}(\\xi,\\eta) = \\lambda_{2} = \\xi$\n- $\\phi_{3}^{(1)}(\\xi,\\eta) = \\lambda_{3} = \\eta$\n\nWe verify the required properties:\n1.  **Kronecker Delta Property**: We evaluate each shape function at each node.\n    - At $n_1 = (0,0)$: $(\\lambda_1, \\lambda_2, \\lambda_3) = (1,0,0)$. So, $\\phi_{1}^{(1)}(n_1)=1$, $\\phi_{2}^{(1)}(n_1)=0$, $\\phi_{3}^{(1)}(n_1)=0$.\n    - At $n_2 = (1,0)$: $(\\lambda_1, \\lambda_2, \\lambda_3) = (0,1,0)$. So, $\\phi_{1}^{(1)}(n_2)=0$, $\\phi_{2}^{(1)}(n_2)=1$, $\\phi_{3}^{(1)}(n_2)=0$.\n    - At $n_3 = (0,1)$: $(\\lambda_1, \\lambda_2, \\lambda_3) = (0,0,1)$. So, $\\phi_{1}^{(1)}(n_3)=0$, $\\phi_{2}^{(1)}(n_3)=0$, $\\phi_{3}^{(1)}(n_3)=1$.\n    The property $\\phi_i^{(1)}(n_j) = \\delta_{ij}$ for $i,j \\in \\{1,2,3\\}$ is satisfied.\n\n2.  **Partition of Unity Property**: The sum of the shape functions must equal $1$ everywhere on the element.\n    $$ \\sum_{i=1}^{3} \\phi_{i}^{(1)}(\\xi,\\eta) = \\phi_{1}^{(1)} + \\phi_{2}^{(1)} + \\phi_{3}^{(1)} = \\lambda_{1} + \\lambda_{2} + \\lambda_{3} = (1-\\xi-\\eta) + \\xi + \\eta = 1 $$\n    This property is satisfied for all $(\\xi, \\eta) \\in \\hat{K}$.\n\n**Part 2: $P_2$ Lagrange Element**\n\nThe piecewise quadratic ($P_2$) Lagrange element is defined by $6$ nodes: the $3$ vertices and the $3$ midpoints of the edges. Let's define the nodes as:\n- Vertices: $n_1 = (0,0)$, $n_2 = (1,0)$, $n_3 = (0,1)$.\n- Edge midpoints: $n_4 = (\\frac{1}{2},0)$ (midpoint of $n_1$-$n_2$), $n_5 = (\\frac{1}{2},\\frac{1}{2})$ (midpoint of $n_2$-$n_3$), and $n_6 = (0,\\frac{1}{2})$ (midpoint of $n_3$-$n_1$).\n\nThe barycentric coordinates of these nodes are:\n- $n_1 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (1,0,0)$\n- $n_2 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (0,1,0)$\n- $n_3 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (0,0,1)$\n- $n_4 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (\\frac{1}{2},\\frac{1}{2},0)$\n- $n_5 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (0,\\frac{1}{2},\\frac{1}{2})$\n- $n_6 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (\\frac{1}{2},0,\\frac{1}{2})$\n\nThe $P_2$ shape functions, $\\phi_i^{(2)}$, are quadratic polynomials constructed using products of barycentric coordinates.\n- For a vertex node $n_i$ (where $i=1,2,3$), the shape function is of the form $\\phi_{i}^{(2)} = c_i \\lambda_i (\\lambda_i - \\frac{1}{2})$. The normalization constant $c_i$ is found by requiring $\\phi_i^{(2)}(n_i)=1$. At $n_i$, $\\lambda_i=1$, so $c_i(1)(1-\\frac{1}{2}) = 1 \\implies c_i = 2$. Thus, $\\phi_{i}^{(2)} = 2\\lambda_i(\\lambda_i - \\frac{1}{2}) = \\lambda_i(2\\lambda_i - 1)$.\n- For a midpoint node $n_k$ (where $k=4,5,6$) on the edge between vertices $n_i$ and $n_j$, the shape function is of the form $\\phi_{k}^{(2)} = c_k \\lambda_i \\lambda_j$. The constant $c_k$ is found by requiring $\\phi_k^{(2)}(n_k)=1$. At $n_k$, $\\lambda_i=\\lambda_j=\\frac{1}{2}$, so $c_k(\\frac{1}{2})(\\frac{1}{2})=1 \\implies c_k=4$. Thus, the shape function is $\\phi_{k}^{(2)} = 4\\lambda_i \\lambda_j$.\n\nThe $6$ shape functions are:\n- Vertex nodes:\n  - $\\phi_{1}^{(2)} = \\lambda_{1}(2\\lambda_{1} - 1)$\n  - $\\phi_{2}^{(2)} = \\lambda_{2}(2\\lambda_{2} - 1)$\n  - $\\phi_{3}^{(2)} = \\lambda_{3}(2\\lambda_{3} - 1)$\n- Midpoint nodes:\n  - $\\phi_{4}^{(2)} = 4\\lambda_{1}\\lambda_{2}$ (for node $n_4$ between $n_1$ and $n_2$)\n  - $\\phi_{5}^{(2)} = 4\\lambda_{2}\\lambda_{3}$ (for node $n_5$ between $n_2$ and $n_3$)\n  - $\\phi_{6}^{(2)} = 4\\lambda_{3}\\lambda_{1}$ (for node $n_6$ between $n_3$ and $n_1$)\n\nWe verify the properties:\n1.  **Kronecker Delta Property**: We must verify that $\\phi_i^{(2)}(n_j) = \\delta_{ij}$ for all $i,j \\in \\{1, \\dots, 6\\}$. This is a systematic check.\n    - For a vertex function $\\phi_i^{(2)}$ ($i \\in \\{1,2,3\\}$): At any vertex $n_j$, one $\\lambda_k$ is $1$ and the others are $0$. So $\\phi_i^{(2)}(n_j) = \\delta_{ij}(2\\delta_{ij}-1)|_{n_j} = \\delta_{ij}$. At any midpoint $n_k$, two $\\lambda$'s are $\\frac{1}{2}$ and one is $0$. If $\\phi_i^{(2)}$ corresponds to the vertex not on this edge, its $\\lambda_i=0$, so $\\phi_i^{(2)}=0$. If it corresponds to a vertex on the edge, its $\\lambda_i=\\frac{1}{2}$, so $\\phi_i^{(2)} = \\frac{1}{2}(2(\\frac{1}{2})-1)=0$. Thus, vertex functions are $1$ at their own node and $0$ at all other nodes.\n    - For a midpoint function $\\phi_k^{(2)}$ ($k \\in \\{4,5,6\\}$), e.g., $\\phi_4^{(2)} = 4\\lambda_1\\lambda_2$: At any vertex $n_j$, either $\\lambda_1=0$ or $\\lambda_2=0$ (or both), so $\\phi_4^{(2)}(n_j)=0$. At its own node $n_4$, $\\lambda_1=\\lambda_2=\\frac{1}{2}$, so $\\phi_4^{(2)}(n_4) = 4(\\frac{1}{2})(\\frac{1}{2})=1$. At other midpoints $n_5$ or $n_6$, either $\\lambda_1=0$ or $\\lambda_2=0$, so $\\phi_4^{(2)}$ is zero.\n    The Kronecker delta property is satisfied for all $6$ shape functions.\n\n2.  **Partition of Unity Property**:\n    $$ \\sum_{i=1}^{6} \\phi_i^{(2)} = \\sum_{i=1}^{3} \\lambda_i(2\\lambda_i - 1) + 4\\lambda_1\\lambda_2 + 4\\lambda_2\\lambda_3 + 4\\lambda_3\\lambda_1 $$\n    $$ = (2\\lambda_1^2 - \\lambda_1) + (2\\lambda_2^2 - \\lambda_2) + (2\\lambda_3^2 - \\lambda_3) + 4\\lambda_1\\lambda_2 + 4\\lambda_2\\lambda_3 + 4\\lambda_3\\lambda_1 $$\n    $$ = 2(\\lambda_1^2 + \\lambda_2^2 + \\lambda_3^2 + 2\\lambda_1\\lambda_2 + 2\\lambda_2\\lambda_3 + 2\\lambda_3\\lambda_1) - (\\lambda_1 + \\lambda_2 + \\lambda_3) $$\n    This expression simplifies using the identity $(\\lambda_1+\\lambda_2+\\lambda_3)^2 = \\lambda_1^2+\\lambda_2^2+\\lambda_3^2+2\\lambda_1\\lambda_2+2\\lambda_2\\lambda_3+2\\lambda_3\\lambda_1$:\n    $$ = 2(\\lambda_1 + \\lambda_2 + \\lambda_3)^2 - (\\lambda_1 + \\lambda_2 + \\lambda_3) $$\n    Since $\\lambda_1 + \\lambda_2 + \\lambda_3 = 1$, the sum is $2(1)^2 - 1 = 1$. The partition of unity is satisfied.\n\n**Part 3: Calculation of the Integral $J_2$**\n\nWe are asked to compute $J_{2} = \\int_{\\hat{K}} \\left( \\sum_{i=1}^{6} \\phi_{i}^{(2)}(\\xi,\\eta)^{2} \\right)\\, d\\xi\\, d\\eta$. We can compute the integral of each squared shape function and sum the results. For this, we use the integration formula for polynomials in barycentric coordinates over a triangle:\n$$ \\int_{\\hat{K}} \\lambda_1^a \\lambda_2^b \\lambda_3^c \\, d\\xi d\\eta = 2A \\frac{a! b! c!}{(a+b+c+2)!} $$\nwhere $A$ is the area of the triangle. For our reference triangle $\\hat{K}$, the area is $A = \\frac{1}{2}$. The formula simplifies to:\n$$ \\int_{\\hat{K}} \\lambda_1^a \\lambda_2^b \\lambda_3^c \\, d\\xi d\\eta = \\frac{a! b! c!}{(a+b+c+2)!} $$\n\n1.  **Integrals for vertex shape functions ($\\phi_1^{(2)}, \\phi_2^{(2)}, \\phi_3^{(2)}$)**:\n    By symmetry, the integrals of their squares are identical. We compute for $\\phi_1^{(2)}$:\n    $$ (\\phi_1^{(2)})^2 = (\\lambda_1(2\\lambda_1-1))^2 = 4\\lambda_1^4 - 4\\lambda_1^3 + \\lambda_1^2 $$\n    $$ \\int_{\\hat{K}} (\\phi_1^{(2)})^2 \\, d\\xi d\\eta = \\int_{\\hat{K}} (4\\lambda_1^4 - 4\\lambda_1^3 + \\lambda_1^2) \\, d\\xi d\\eta $$\n    $$ = 4 \\int_{\\hat{K}} \\lambda_1^4 \\,d\\xi d\\eta - 4 \\int_{\\hat{K}} \\lambda_1^3 \\,d\\xi d\\eta + \\int_{\\hat{K}} \\lambda_1^2 \\,d\\xi d\\eta $$\n    Using the formula:\n    - $\\int_{\\hat{K}} \\lambda_1^4 = \\frac{4!0!0!}{(4+0+0+2)!} = \\frac{24}{720} = \\frac{1}{30}$\n    - $\\int_{\\hat{K}} \\lambda_1^3 = \\frac{3!0!0!}{(3+0+0+2)!} = \\frac{6}{120} = \\frac{1}{20}$\n    - $\\int_{\\hat{K}} \\lambda_1^2 = \\frac{2!0!0!}{(2+0+0+2)!} = \\frac{2}{24} = \\frac{1}{12}$\n    The integral is $4(\\frac{1}{30}) - 4(\\frac{1}{20}) + \\frac{1}{12} = \\frac{2}{15} - \\frac{1}{5} + \\frac{1}{12} = \\frac{8-12+5}{60} = \\frac{1}{60}$.\n    The sum for the three vertex functions is $3 \\times \\frac{1}{60} = \\frac{3}{60} = \\frac{1}{20}$.\n\n2.  **Integrals for midpoint shape functions ($\\phi_4^{(2)}, \\phi_5^{(2)}, \\phi_6^{(2)}$)**:\n    By symmetry, these integrals are also identical. We compute for $\\phi_4^{(2)}$:\n    $$ (\\phi_4^{(2)})^2 = (4\\lambda_1\\lambda_2)^2 = 16\\lambda_1^2\\lambda_2^2 $$\n    $$ \\int_{\\hat{K}} (\\phi_4^{(2)})^2 \\, d\\xi d\\eta = 16 \\int_{\\hat{K}} \\lambda_1^2\\lambda_2^2 \\, d\\xi d\\eta $$\n    Using the formula with $a=2, b=2, c=0$:\n    $$ \\int_{\\hat{K}} \\lambda_1^2\\lambda_2^2 = \\frac{2!2!0!}{(2+2+0+2)!} = \\frac{4}{6!} = \\frac{4}{720} = \\frac{1}{180} $$\n    The integral is $16 \\times \\frac{1}{180} = \\frac{4}{45}$.\n    The sum for the three midpoint functions is $3 \\times \\frac{4}{45} = \\frac{12}{45} = \\frac{4}{15}$.\n\n3.  **Total Integral $J_2$**:\n    Summing the contributions from all six shape functions:\n    $$ J_2 = \\sum_{i=1}^{6} \\int_{\\hat{K}} (\\phi_i^{(2)})^2 d\\xi d\\eta = \\frac{1}{20} + \\frac{4}{15} $$\n    To sum these fractions, we find a common denominator, which is $60$:\n    $$ J_2 = \\frac{3}{60} + \\frac{16}{60} = \\frac{19}{60} $$\nThe exact value of the integral $J_2$ is $\\frac{19}{60}$.",
            "answer": "$$\n\\boxed{\\frac{19}{60}}\n$$"
        },
        {
            "introduction": "Once the shape functions are defined on a reference element, the next step is to assemble the global system of equations for a specific mesh. This practice  demystifies the assembly process by guiding you through a \"by-hand\" calculation of the stiffness matrix and load vector for a simple two-element domain. Working through this example solidifies the connection between the local element integrals and the final global linear system that we must solve.",
            "id": "3595596",
            "problem": "Consider a steady-state diffusion model for a two-dimensional, homogeneous but anisotropic medium, representative of a cross-section in subsurface flow. Let the governing equation be the conservation law with a linear constitutive relation: conservation of mass requires that the divergence of flux equals the source, and the flux is proportional to the gradient of potential via an anisotropic conductivity tensor. This leads to the diffusion equation in strong form\n$$\n- \\nabla \\cdot \\left( \\mathbf{K} \\, \\nabla u \\right) = f \\quad \\text{in } \\Omega,\n$$\non the domain $\\Omega = [0,1] \\times [0,1]$, with boundary conditions\n$$\nu = 0 \\quad \\text{on } \\Gamma_{\\mathrm{D}} := \\{ (x,y) \\in \\partial \\Omega : x = 0 \\text{ or } y = 0 \\}, \\qquad \\left( \\mathbf{K} \\nabla u \\right) \\cdot \\mathbf{n} = 0 \\quad \\text{on } \\Gamma_{\\mathrm{N}} := \\partial \\Omega \\setminus \\Gamma_{\\mathrm{D}}.\n$$\nAssume a constant source $f(x,y) = 1$ and a constant, symmetric, positive-definite conductivity tensor\n$$\n\\mathbf{K} = \\begin{pmatrix} 2 & 1 \\\\ 1 & 3 \\end{pmatrix}.\n$$\nAll quantities are nondimensionalized; report $u$ as a pure number.\n\nDiscretize $\\Omega$ using first-order, continuous, Lagrange finite elements (often denoted $P_1$ elements) on the simplicial mesh formed by dividing the unit square into two triangles along the diagonal from $(0,0)$ to $(1,1)$. Label the mesh vertices as follows: node $1$ at $(0,0)$, node $2$ at $(1,0)$, node $3$ at $(0,1)$, and node $4$ at $(1,1)$. Let triangle $T_1$ have vertices $(1,2,4)$ and triangle $T_2$ have vertices $(1,4,3)$.\n\nStarting from the governing conservation law and constitutive relation, derive the weak form and then construct the conforming $P_1$ finite element discretization on this mesh. Assemble by hand:\n- the element stiffness matrices and element load vectors on $T_1$ and $T_2$,\n- the global stiffness matrix and global load vector prior to imposing essential boundary conditions.\n\nThen impose the essential boundary conditions on $\\Gamma_{\\mathrm{D}}$ by elimination. Solve the resulting linear system for the sole remaining degree of freedom at node $4$. What is the value of the finite element approximation $u$ at node $4$? Provide an exact value (no rounding) and no units.",
            "solution": "### Derivation of the Weak Form\nThe strong form of the governing equation is:\n$$ - \\nabla \\cdot (\\mathbf{K} \\nabla u) = f \\quad \\text{in } \\Omega $$\nWe multiply by a test function $v$ from a suitable space and integrate over the domain $\\Omega$:\n$$ - \\int_{\\Omega} v (\\nabla \\cdot (\\mathbf{K} \\nabla u)) \\, d\\Omega = \\int_{\\Omega} v f \\, d\\Omega $$\nUsing the divergence theorem (or Green's first identity), we perform integration by parts:\n$$ \\int_{\\Omega} (\\nabla v)^T (\\mathbf{K} \\nabla u) \\, d\\Omega - \\int_{\\partial \\Omega} v (\\mathbf{K} \\nabla u) \\cdot \\mathbf{n} \\, d\\Gamma = \\int_{\\Omega} v f \\, d\\Omega $$\nThe boundary $\\partial \\Omega$ is partitioned into $\\Gamma_D$ and $\\Gamma_N$. The test function $v$ must belong to the space of functions with finite energy that satisfy the homogeneous Dirichlet condition, i.e., $v=0$ on $\\Gamma_D$. This causes the boundary integral over $\\Gamma_D$ to vanish. The boundary integral over $\\Gamma_N$ also vanishes due to the specified homogeneous Neumann condition, $(\\mathbf{K} \\nabla u) \\cdot \\mathbf{n} = 0$ on $\\Gamma_N$.\nThe resulting weak form is: Find $u \\in H^1(\\Omega)$ with $u=0$ on $\\Gamma_D$ such that for all test functions $v \\in H^1_0(\\Omega, \\Gamma_D)$:\n$$ \\int_{\\Omega} (\\nabla v)^T \\mathbf{K} \\nabla u \\, d\\Omega = \\int_{\\Omega} v f \\, d\\Omega $$\nThis can be written as $a(u,v) = L(v)$, where $a(u,v) = \\int_{\\Omega} (\\nabla v)^T \\mathbf{K} \\nabla u \\, d\\Omega$ is a bilinear form and $L(v) = \\int_{\\Omega} v f \\, d\\Omega$ is a linear functional.\n\n### Finite Element Discretization\nThe domain $\\Omega$ is discretized into finite elements. Within each element $T_e$, the solution is approximated as a linear combination of nodal basis functions $N_i$: $u_h(x,y) = \\sum_{j} U_j N_j(x,y)$. Applying the Galerkin method, we use the basis functions $N_i$ as test functions. This leads to the linear system $\\mathbf{S} \\mathbf{U} = \\mathbf{F}$, where the entries of the global stiffness matrix $\\mathbf{S}$ and global load vector $\\mathbf{F}$ are:\n$$ S_{ij} = a(N_j, N_i) = \\int_{\\Omega} (\\nabla N_i)^T \\mathbf{K} \\nabla N_j \\, d\\Omega, \\quad F_i = L(N_i) = \\int_{\\Omega} N_i f \\, d\\Omega $$\nThese are assembled from element contributions: $\\mathbf{s}^{(e)}_{ij} = \\int_{T_e} (\\nabla N_i)^T \\mathbf{K} \\nabla N_j \\, dA$ and $\\mathbf{f}^{(e)}_{i} = \\int_{T_e} N_i f \\, dA$.\n\nFor a $P_1$ triangular element, the gradients of the barycentric basis functions are constant. The element stiffness matrix is given by $\\mathbf{s}^{(e)} = A_e (\\mathbf{B}^{(e)})^T \\mathbf{K} \\mathbf{B}^{(e)}$, where $A_e$ is the element area and $\\mathbf{B}^{(e)}$ is the matrix whose columns are the gradients of the local basis functions. The element load vector for a constant source $f$ is $\\mathbf{f}^{(e)}_i = f \\frac{A_e}{3}$ for each node $i$ of the element.\n\n### Element Matrix Calculations\n**Triangle $T_1$:** Vertices (1, 2, 4) at $(0,0)$, $(1,0)$, $(1,1)$.\nArea $A_1 = \\frac{1}{2}$. The gradient matrix for local nodes $(1,2,3)$ corresponding to global nodes $(1,2,4)$ is:\n$$ \\mathbf{B}^{(1)} = \\begin{pmatrix} -1 & 1 & 0 \\\\ 0 & -1 & 1 \\end{pmatrix} $$\nThe element stiffness matrix $\\mathbf{s}^{(1)}$ for nodes $(1,2,4)$ is:\n$$ \\mathbf{s}^{(1)} = A_1 (\\mathbf{B}^{(1)})^T \\mathbf{K} \\mathbf{B}^{(1)} = \\frac{1}{2} \\begin{pmatrix} -1 & 0 \\\\ 1 & -1 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 2 & 1 \\\\ 1 & 3 \\end{pmatrix} \\begin{pmatrix} -1 & 1 & 0 \\\\ 0 & -1 & 1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 2 & -1 & -1 \\\\ -1 & 3 & -2 \\\\ -1 & -2 & 3 \\end{pmatrix} $$\nThe element load vector $\\mathbf{f}^{(1)}$ is:\n$$ \\mathbf{f}^{(1)} = f \\frac{A_1}{3} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = 1 \\cdot \\frac{1/2}{3} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\frac{1}{6} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} $$\n\n**Triangle $T_2$:** Vertices (1, 4, 3) at $(0,0)$, $(1,1)$, $(0,1)$.\nArea $A_2 = \\frac{1}{2}$. The gradient matrix for local nodes $(1,2,3)$ corresponding to global nodes $(1,4,3)$ is:\n$$ \\mathbf{B}^{(2)} = \\begin{pmatrix} 0 & 1 & -1 \\\\ -1 & 0 & 1 \\end{pmatrix} $$\nThe element stiffness matrix $\\mathbf{s}^{(2)}$ for nodes $(1,4,3)$ is:\n$$ \\mathbf{s}^{(2)} = A_2 (\\mathbf{B}^{(2)})^T \\mathbf{K} \\mathbf{B}^{(2)} = \\frac{1}{2} \\begin{pmatrix} 0 & -1 \\\\ 1 & 0 \\\\ -1 & 1 \\end{pmatrix} \\begin{pmatrix} 2 & 1 \\\\ 1 & 3 \\end{pmatrix} \\begin{pmatrix} 0 & 1 & -1 \\\\ -1 & 0 & 1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 3 & -1 & -2 \\\\ -1 & 2 & -1 \\\\ -2 & -1 & 3 \\end{pmatrix} $$\nThe element load vector $\\mathbf{f}^{(2)}$ is:\n$$ \\mathbf{f}^{(2)} = f \\frac{A_2}{3} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = 1 \\cdot \\frac{1/2}{3} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\frac{1}{6} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} $$\n\n### Assembly of Global System and Solution\nThe global matrices $\\mathbf{S}$ and $\\mathbf{F}$ are assembled by summing the element contributions.\nThe global stiffness matrix is:\n$$ \\mathbf{S} = \\frac{1}{2} \\begin{pmatrix}\ns^{(1)}_{11}+s^{(2)}_{11} & s^{(1)}_{12} & s^{(2)}_{13} & s^{(1)}_{13}+s^{(2)}_{12} \\\\\ns^{(1)}_{21} & s^{(1)}_{22} & 0 & s^{(1)}_{23} \\\\\ns^{(2)}_{31} & 0 & s^{(2)}_{33} & s^{(2)}_{32} \\\\\ns^{(1)}_{31}+s^{(2)}_{21} & s^{(1)}_{32} & s^{(2)}_{23} & s^{(1)}_{33}+s^{(2)}_{22}\n\\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix}\n2+3 & -1 & -2 & -1-1 \\\\\n-1 & 3 & 0 & -2 \\\\\n-2 & 0 & 3 & -1 \\\\\n-1-1 & -2 & -1 & 3+2\n\\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix}\n5 & -1 & -2 & -2 \\\\\n-1 & 3 & 0 & -2 \\\\\n-2 & 0 & 3 & -1 \\\\\n-2 & -2 & -1 & 5\n\\end{pmatrix} $$\nThe global load vector is:\n$$ \\mathbf{F} = \\begin{pmatrix} f^{(1)}_1+f^{(2)}_1 \\\\ f^{(1)}_2 \\\\ f^{(2)}_3 \\\\ f^{(1)}_3+f^{(2)}_2 \\end{pmatrix} = \\begin{pmatrix} 1/6+1/6 \\\\ 1/6 \\\\ 1/6 \\\\ 1/6+1/6 \\end{pmatrix} = \\begin{pmatrix} 1/3 \\\\ 1/6 \\\\ 1/6 \\\\ 1/3 \\end{pmatrix} $$\nThe full system is $\\mathbf{S} \\mathbf{U} = \\mathbf{F}$.\nThe Dirichlet boundary condition $u=0$ on $\\Gamma_D$ applies to nodes $1$, $2$, and $3$. Thus, we have $U_1=0$, $U_2=0$, and $U_3=0$.\nWe only need to solve for the unknown degree of freedom $U_4$. We use the fourth equation of the linear system:\n$$ S_{41}U_1 + S_{42}U_2 + S_{43}U_3 + S_{44}U_4 = F_4 $$\nSubstituting the known values and matrix entries:\n$$ \\frac{1}{2}(-2)U_1 + \\frac{1}{2}(-2)U_2 + \\frac{1}{2}(-1)U_3 + \\frac{1}{2}(5)U_4 = \\frac{1}{3} $$\n$$ \\frac{1}{2}(-2(0) - 2(0) - 1(0) + 5 U_4) = \\frac{1}{3} $$\n$$ \\frac{5}{2}U_4 = \\frac{1}{3} $$\nSolving for $U_4$:\n$$ U_4 = \\frac{1}{3} \\cdot \\frac{2}{5} = \\frac{2}{15} $$\nThe value of the finite element approximation $u$ at node $4$ is $U_4$.",
            "answer": "$$\\boxed{\\frac{2}{15}}$$"
        },
        {
            "introduction": "A numerical solution is only as good as its accuracy. This final practice  transitions from implementation to analysis, focusing on the critical concept of convergence. By writing a program to solve a problem with a known exact solution, you will empirically measure error decay rates and witness the profound effect of local mesh refinement, a key strategy for efficiently handling the singularities often encountered in geophysical models.",
            "id": "3595604",
            "problem": "Consider the one-dimensional Poisson equation with a concentrated point source on the open interval $\\Omega = (0,1)$,\n$$\n- \\frac{d^2 u}{dx^2} = f \\quad \\text{in } \\Omega,\n$$\nsubject to homogeneous Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$. Let the source be a unit Dirac distribution centered at a point $x_0 \\in (0,1)$, i.e.,\n$$\nf = \\delta_{x_0}.\n$$\nThe weak form is: find $u \\in H^1_0(\\Omega)$ such that\n$$\n\\int_0^1 u'(x) v'(x)\\,dx = v(x_0)\n$$\nfor all test functions $v \\in H^1_0(\\Omega)$. You will approximate this problem using the Finite Element Method (FEM) with standard first-order Lagrange basis functions (commonly called $P_1$ elements) on a partition (mesh) of $\\Omega$.\n\nThe goal is to compute empirical error decay rates for the FEM solution in the $H^1$ seminorm and the $L^2$ norm as the mesh is refined, comparing:\n- a uniform refinement strategy (all elements of equal size), and\n- a locally refined strategy that places more and smaller elements near the point source at $x_0$.\n\nYour program must:\n1. Derive the correct discrete load vector for the point source from the weak formulation. Specifically, for the nodal basis functions $\\{\\phi_i\\}$, the load vector entries must satisfy\n$$\nF_i = \\phi_i(x_0).\n$$\n2. Assemble the global stiffness matrix for $P_1$ elements. For an element of length $h_e$, the local stiffness matrix is\n$$\n\\begin{pmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{pmatrix} \\frac{1}{h_e}.\n$$\n3. Enforce homogeneous Dirichlet boundary conditions by solving for the interior degrees of freedom only.\n4. Use the exact continuous solution for validation. For the operator $-d^2/dx^2$ on $(0,1)$ with homogeneous Dirichlet boundary conditions and a unit Dirac at $x_0$, the unique weak solution is the Green's function\n$$\nG(x;x_0) =\n\\begin{cases}\n(1 - x_0)\\, x, & \\text{if } x \\le x_0,\\\\\nx_0\\, (1 - x), & \\text{if } x \\ge x_0,\n\\end{cases}\n$$\nand $u(x) = G(x;x_0)$. On each side of $x_0$, $u'(x)$ is constant: $u'(x) = (1 - x_0)$ for $x < x_0$ and $u'(x) = -x_0$ for $x > x_0$.\n5. Compute errors of the FEM solution $u_h$ against $u$ for each mesh:\n   - The $H^1$ seminorm error\n   $$\n   \\|u - u_h\\|_{H^1_0(\\Omega)} := \\left( \\int_0^1 |u'(x) - u_h'(x)|^2\\,dx \\right)^{1/2}.\n   $$\n   - The $L^2$ norm error\n   $$\n   \\|u - u_h\\|_{L^2(\\Omega)} := \\left( \\int_0^1 |u(x) - u_h(x)|^2\\,dx \\right)^{1/2}.\n   $$\n   The $H^1$ seminorm error integrals can be computed exactly per element because both $u'(x)$ and $u_h'(x)$ are piecewise constant. For the $L^2$ norm, perform exact element-wise evaluation via splitting any element that contains $x_0$ and applying two-point Gauss quadrature on each subsegment (this is exact for piecewise linear differences since the square is at most quadratic).\n6. Define the refinement strategies as follows:\n   - Uniform refinement: use $N \\in \\{32, 64, 128, 256\\}$ equally sized elements on $(0,1)$.\n   - Local refinement around $x_0$: for each $N \\in \\{32, 64, 128, 256\\}$, choose a subinterval $I = [x_{\\mathrm{L}}, x_{\\mathrm{R}}]$ containing $x_0$, where $x_{\\mathrm{L}} = \\max(0, x_0 - w_{\\mathrm{L}})$, $x_{\\mathrm{R}} = \\min(1, x_0 + w_{\\mathrm{R}})$ with $w_{\\mathrm{L}} = 0.282$ and $w_{\\mathrm{R}} = 0.318$. Allocate a fraction $p = 0.6$ of the total elements to $I$ uniformly, and distribute the remaining elements uniformly to $(0, x_{\\mathrm{L}})$ and $(x_{\\mathrm{R}}, 1)$ in proportion to their lengths.\n7. For each refinement strategy and each $N$, assemble, solve, and compute the $H^1$ and $L^2$ errors. Then compute the empirical decay rates by linear regression of $\\log(\\text{error})$ versus $\\log(N)$, reporting the slope magnitude $\\alpha$ defined by\n$$\n\\log(\\text{error}) \\approx C - \\alpha \\log(N),\n$$\nso that $\\alpha$ is a positive number representing the decay rate with respect to the total number of elements $N$.\n8. Use the following test suite of source locations:\n   - Test case $1$: $x_0 = 0.37$ (a general interior point).\n   - Test case $2$: $x_0 = 0.05$ (near the boundary $x=0$).\n   - Test case $3$: $x_0 = \\sqrt{2}/4$ (an irrational location to avoid incidental alignment).\n9. Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, append the four floats in the order\n$$\n[\\alpha_{H^1,\\mathrm{uniform}},\\, \\alpha_{H^1,\\mathrm{local}},\\, \\alpha_{L^2,\\mathrm{uniform}},\\, \\alpha_{L^2,\\mathrm{local}}],\n$$\nand concatenate over the three test cases to form a single list with $12$ floats:\n$$\n[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4,\\alpha_5,\\alpha_6,\\alpha_7,\\alpha_8,\\alpha_9,\\alpha_{10},\\alpha_{11},\\alpha_{12}].\n$$\nNo physical units apply; all quantities are nondimensional. Angles are not used.\n\nYour program must be a complete, runnable Python $3.12$ script that implements the above and prints only the specified single-line output. It must not require any user input, files, or network access, and must only use the Python standard library, NumPy $1.23.5$, and SciPy $1.11.4$.",
            "solution": "The Python program provided in the answer implements the finite element method (FEM) to solve the one-dimensional Poisson equation with a Dirac delta source. It compares the convergence of the numerical solution to the exact analytical solution under two different meshing strategies: uniform refinement and local refinement. The convergence is quantified by computing the decay rates of the $H^1$ seminorm and $L^2$ norm errors.\n\nThe implementation follows the steps outlined in the problem statement. Key components of the algorithm are:\n\n1.  **Mesh Generation**: A function `generate_mesh` is created to produce an array of node coordinates for a given number of elements $N$, a source location $x_0$, and a strategy (`'uniform'` or `'local'`). The local refinement strategy carefully partitions the $N$ elements into three subdomains: a refined central region around $x_0$ and two coarser regions on either side.\n\n2.  **FEM Solver**: The `solve_fem` function implements the core FEM procedure.\n    - It assembles the global stiffness matrix $K$ and load vector $F$ for the interior degrees of freedom. The stiffness matrix is tridiagonal due to the one-dimensional nature of the problem and the use of nearest-neighbor $P_1$ basis functions.\n    - The load vector $F$ is assembled based on the principle $F_i = v_i(x_0)$. For a $P_1$ nodal basis function $\\phi_i$, this simplifies to $F_i = \\phi_i(x_0)$. Only the two basis functions whose support contains $x_0$ yield non-zero entries.\n    - The resulting linear system $K U_{\\text{interior}} = F$ is solved for the interior nodal values $U_{\\text{interior}}$ using `numpy.linalg.solve`.\n    - The full solution vector $U_h$ is constructed by augmenting $U_{\\text{interior}}$ with the zero values at the boundaries, as required by the Dirichlet conditions.\n\n3.  **Error Computation**: The `compute_errors` function calculates the numerical error.\n    - It iterates through each element of the mesh.\n    - The **$H^1$ seminorm error** is computed by integrating the squared difference of the derivatives, $(u' - u_h')^2$, over each element. Since both $u'$ and $u_h'$ are piecewise constant, this integration is exact. If an element contains the singularity $x_0$, the integral is split into two parts at $x_0$.\n    - The **$L^2$ norm error** is computed by integrating $(u - u_h)^2$. On each element, $u_h$ is linear. The exact solution $u$ is piecewise linear. Therefore, the integrand is piecewise quadratic. As specified, the integral is computed exactly using two-point Gaussian quadrature. If an element contains $x_0$, it is split into two sub-intervals, and quadrature is applied to each.\n\n4.  **Convergence Rate Calculation**: The `compute_rate` function takes the list of errors computed for the mesh sequence $N \\in \\{32, 64, 128, 256\\}$ and calculates the convergence rate $\\alpha$. This is done by performing a linear least-squares fit on the log-log data: $\\log(\\text{error})$ versus $\\log(N)$. The rate $\\alpha$ is the negative of the slope of this line.\n\n5.  **Main Execution Loop**: The main function iterates through the specified test cases for $x_0$. For each $x_0$, it runs the simulation for both uniform and local refinement strategies across the range of $N$, collects the errors, computes the four required convergence rates ($\\alpha_{H^1,\\text{uniform}}$, $\\alpha_{H^1,\\text{local}}$, $\\alpha_{L^2,\\text{uniform}}$, $\\alpha_{L^2,\\text{local}}$), and appends them to a results list. Finally, the program prints the concatenated list in the specified format, as demonstrated by the code in the answer section.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the FEM simulation and compute convergence rates.\n    \"\"\"\n    \n    # Constants and parameters from the problem statement\n    W_L = 0.282\n    W_R = 0.318\n    P_REFINE = 0.6\n    Ns = np.array([32, 64, 128, 256], dtype=int)\n    TEST_CASES = [\n        0.37,\n        0.05,\n        np.sqrt(2.0)/4.0,\n    ]\n\n    # --- Helper Functions ---\n\n    def u_exact(x, x0):\n        \"\"\"Computes the exact solution u(x) for a given x0.\"\"\"\n        return np.where(x <= x0, (1.0 - x0) * x, x0 * (1.0 - x))\n\n    def du_exact(x, x0):\n        \"\"\"Computes the exact derivative u'(x) for a given x0.\"\"\"\n        return np.where(x < x0, 1.0 - x0, -x0)\n\n    def generate_mesh(N, x0, strategy):\n        \"\"\"Generates the mesh nodes for uniform or local refinement.\"\"\"\n        if strategy == 'uniform':\n            return np.linspace(0.0, 1.0, N + 1)\n        \n        elif strategy == 'local':\n            x_L = max(0.0, x0 - W_L)\n            x_R = min(1.0, x0 + W_R)\n\n            N_refine = int(np.round(P_REFINE * N))\n            N_coarse = N - N_refine\n\n            len_left = x_L\n            len_right = 1.0 - x_R\n            total_coarse_len = len_left + len_right\n            \n            if total_coarse_len > 1e-12:\n                N_left = int(np.round(N_coarse * len_left / total_coarse_len))\n            else:\n                N_left = 0\n            N_right = N_coarse - N_left\n            \n            # Ensure total number of elements is exactly N due to rounding\n            current_sum = N_left + N_refine + N_right\n            if current_sum != N:\n                N_right += (N - current_sum)\n\n            nodes_list = []\n            if N_left > 0:\n                nodes_list.append(np.linspace(0.0, x_L, N_left, endpoint=False))\n            if N_refine > 0:\n                nodes_list.append(np.linspace(x_L, x_R, N_refine, endpoint=False))\n            if N_right > 0:\n                nodes_list.append(np.linspace(x_R, 1.0, N_right, endpoint=False))\n            \n            nodes = np.concatenate(nodes_list) if nodes_list else np.array([])\n            nodes = np.append(nodes, 1.0)\n            \n            return nodes\n\n    def solve_fem(nodes, x0):\n        \"\"\"Assembles and solves the FEM system for P1 elements.\"\"\"\n        N_elements = len(nodes) - 1\n        N_nodes = N_elements + 1\n        N_interior = N_nodes - 2\n\n        if N_interior <= 0:\n            return np.zeros(N_nodes)\n\n        K = np.zeros((N_interior, N_interior))\n        F = np.zeros(N_interior)\n\n        # Assemble stiffness matrix K (tridiagonal) for interior nodes\n        for i in range(N_interior): # Diagonals based on node i+1\n            glob_idx = i + 1\n            h_left = nodes[glob_idx] - nodes[glob_idx - 1]\n            h_right = nodes[glob_idx + 1] - nodes[glob_idx]\n            K[i, i] = 1.0/h_left + 1.0/h_right\n        for i in range(N_interior - 1): # Off-diagonals\n            glob_idx = i + 1\n            h_right = nodes[glob_idx + 1] - nodes[glob_idx]\n            K[i, i+1] = -1.0/h_right\n            K[i+1, i] = -1.0/h_right\n\n        # Assemble load vector F\n        elem_idx = np.searchsorted(nodes, x0, side='right') - 1\n        elem_idx = min(elem_idx, N_elements - 1)\n        \n        x_j, x_j1 = nodes[elem_idx], nodes[elem_idx+1]\n        h_j = x_j1 - x_j\n        \n        val_phi_j = (x_j1 - x0) / h_j if h_j > 1e-14 else (1.0 if np.isclose(x0, x_j) else 0.0)\n        val_phi_j1 = (x0 - x_j) / h_j if h_j > 1e-14 else (1.0 if np.isclose(x0, x_j1) else 0.0)\n\n        if elem_idx > 0:\n            F[elem_idx - 1] += val_phi_j\n        if elem_idx + 1 < N_nodes - 1:\n            F[elem_idx] += val_phi_j1\n\n        U_interior = np.linalg.solve(K, F)\n        U_h = np.zeros(N_nodes)\n        U_h[1:-1] = U_interior\n        return U_h\n\n    def compute_errors(nodes, U_h, x0):\n        \"\"\"Computes H1-seminorm and L2-norm errors.\"\"\"\n        N_elements = len(nodes) - 1\n        h1_err_sq, l2_err_sq = 0.0, 0.0\n\n        gauss_pts = np.array([-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)])\n        gauss_w = np.array([1.0, 1.0])\n\n        for i in range(N_elements):\n            x_i, x_i1 = nodes[i], nodes[i+1]\n            h_e = x_i1 - x_i\n            if h_e < 1e-14: continue\n\n            # H1 seminorm error\n            du_h = (U_h[i+1] - U_h[i]) / h_e\n            if x0 <= x_i or x0 >= x_i1:\n                du_val = du_exact((x_i + x_i1) / 2.0, x0)\n                h1_err_sq += (du_val - du_h)**2 * h_e\n            else:\n                h1_err_sq += (du_exact(x_i, x0) - du_h)**2 * (x0 - x_i)\n                h1_err_sq += (du_exact(x_i1, x0) - du_h)**2 * (x_i1 - x0)\n            \n            # L2 norm error\n            def u_h_local(x): return U_h[i] * (x_i1 - x) / h_e + U_h[i+1] * (x - x_i) / h_e\n            def integrand_sq(x): return (u_exact(x, x0) - u_h_local(x))**2\n\n            def quad_gauss2(func, a, b):\n                h_sub = b - a\n                if h_sub < 1e-14: return 0.0\n                pts = 0.5 * h_sub * gauss_pts + 0.5 * (a + b)\n                return 0.5 * h_sub * np.sum(gauss_w * func(pts))\n\n            if x0 <= x_i or x0 >= x_i1:\n                l2_err_sq += quad_gauss2(integrand_sq, x_i, x_i1)\n            else:\n                l2_err_sq += quad_gauss2(integrand_sq, x_i, x0)\n                l2_err_sq += quad_gauss2(integrand_sq, x0, x_i1)\n            \n        return np.sqrt(h1_err_sq), np.sqrt(l2_err_sq)\n    \n    def compute_rate(errors):\n        \"\"\"Computes convergence rate alpha from log(error) vs log(N).\"\"\"\n        if any(e < 1e-16 for e in errors): return np.nan\n        log_N = np.log(Ns)\n        log_err = np.log(errors)\n        slope, _ = np.polyfit(log_N, log_err, 1)\n        return -slope\n\n    # --- Main Calculation Loop ---\n    all_results = []\n    for x0 in TEST_CASES:\n        \n        errors_h1_uni, errors_l2_uni = [], []\n        errors_h1_loc, errors_l2_loc = [], []\n\n        for N in Ns:\n            # Uniform refinement\n            nodes_uni = generate_mesh(N, x0, 'uniform')\n            U_h_uni = solve_fem(nodes_uni, x0)\n            h1, l2 = compute_errors(nodes_uni, U_h_uni, x0)\n            errors_h1_uni.append(h1)\n            errors_l2_uni.append(l2)\n\n            # Local refinement\n            nodes_loc = generate_mesh(N, x0, 'local')\n            U_h_loc = solve_fem(nodes_loc, x0)\n            h1, l2 = compute_errors(nodes_loc, U_h_loc, x0)\n            errors_h1_loc.append(h1)\n            errors_l2_loc.append(l2)\n            \n        # Compute rates for the current test case\n        alpha_h1_uni = compute_rate(errors_h1_uni)\n        alpha_h1_loc = compute_rate(errors_h1_loc)\n        alpha_l2_uni = compute_rate(errors_l2_uni)\n        alpha_l2_loc = compute_rate(errors_l2_loc)\n        \n        all_results.extend([alpha_h1_uni, alpha_h1_loc, alpha_l2_uni, alpha_l2_loc])\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}