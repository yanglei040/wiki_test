## 引言
有限元方法（FEM）是求解科学与工程领域[偏微分方程](@entry_id:141332)的基石，其核心思想在于将复杂问题分解为简单的局部问题。然而，从这些在独立单元上定义的局部方程到能够描述整个系统行为的单一全局[方程组](@entry_id:193238)，需要一个关键的、通常也是复杂的步骤——**[全局组装](@entry_id:749916)（global assembly）**。这一过程不仅是连接有限[元理论](@entry_id:638043)与实际计算实现的桥梁，更是高级建模技术和[高性能计算](@entry_id:169980)策略得以实施的基础。许多工程师和科学家熟悉单元级的公式推导，但往往将组装过程视为一个“黑箱”，从而限制了他们解决更复杂问题或优化代码性能的能力。

本文旨在系统地揭开[全局组装](@entry_id:749916)的神秘面纱，为读者提供一个从原理到实践的完整指南。我们将分三个章节深入探讨这一主题：
-   在**第一章：原理与机制**中，我们将剖析组装过程的哲学，即“从局部到全局”，详细介绍[参考单元](@entry_id:168425)上的计算、自由度映射以及处理向量、[非线性](@entry_id:637147)和约束等高级主题的机制。
-   在**第二章：应用与跨学科连接**中，我们将展示[全局组装](@entry_id:749916)如何在[多物理场耦合](@entry_id:171389)、复杂几何与材料、高级[离散化方法](@entry_id:272547)（如[DG方法](@entry_id:748369)）中发挥作用，并连接到并行计算等高性能计算领域。
-   在**第三章：动手实践**中，您将通过一系列精心设计的编程练习，巩固对单元矩阵计算、[稀疏矩阵存储](@entry_id:168858)和并行组装的理解。

通过这一结构化的学习路径，读者将建立对[全局组装](@entry_id:749916)过程的深刻理解，从而能够更自信地开发、验证和优化自己的有限元代码。现在，让我们从构成这一切基础的原理与机制开始。

## 原理与机制

在上一章中，我们介绍了有限元方法 (Finite Element Method, FEM) 作为求解偏微分方程 (PDEs) 的一种强大数值技术的基本思想。其核心在于将一个复杂的连续域分解为更简单、更易于管理的子域（即**有限元**），并在这些单元上逼近解。本章将深入探讨将这些离散的、局部的单元级方程整合成一个单一的、巨大的全局[方程组](@entry_id:193238)的原理和机制。这个过程被称为**[全局组装](@entry_id:749916) (global assembly)**，它是连接有限[元理论](@entry_id:638043)与实际计算实现的桥梁。我们将从基本原理出发，逐步探讨向量问题、[非线性](@entry_id:637147)问题、[自适应网格](@entry_id:164379)和[高性能计算](@entry_id:169980)中的高级主题。

### 组装的哲学：从局部到全局

有限元方法的美妙之处在于它将一个难以处理的全局问题转化为大量易于处理的局部问题的集合。对于一个给定的[偏微分方程](@entry_id:141332)，我们通过其变分或弱形式，在每个单元 $e$ 上推导出局部（或单元）[方程组](@entry_id:193238)，形式通常为 $K_e \mathbf{u}_e = \mathbf{f}_e$。这里，$\mathbf{u}_e$ 是与单元 $e$ 相关的节点未知量（自由度，DOFs）的向量，$K_e$ 是**[单元刚度矩阵](@entry_id:139369)**，$\mathbf{f}_e$ 是**[单元载荷向量](@entry_id:748928)**。

然而，我们的最终目标是求解整个区域 $\Omega$ 上的解。这就要求我们将所有这些独立的单元[方程组](@entry_id:193238)“缝合”成一个能够描述整个系统行为的全局[方程组](@entry_id:193238) $K \mathbf{u} = \mathbf{f}$。这个“缝合”的过程就是[全局组装](@entry_id:749916)。这个过程清晰地划分了两个不同的阶段：

1.  **离散化 (Discretization)**：这是在单元层面计算局部贡献的过程。它涉及到根据弱形式、选择的形函数（[基函数](@entry_id:170178)）和[数值积分法则](@entry_id:175061)，为每个单元计算其[刚度矩阵](@entry_id:178659) $K_e$ 和[载荷向量](@entry_id:635284) $\mathbf{f}_e$。

2.  **组装 (Assembly)**：这是一个纯粹的代数累加过程。它根据网格的**连通性 (connectivity)**，将所有单元矩阵和向量的项添加到全局矩阵和向量的正确位置上。

让我们以一个标量扩散方程为例来说明这一点，该方程在[地球物理学](@entry_id:147342)中广泛用于模拟热传导或[多孔介质流](@entry_id:146440)。考虑以下带有[混合边界条件](@entry_id:176456)的方程 ：
$$
-\nabla\cdot(\kappa\nabla u) = s \quad \text{in } \Omega
$$
其[弱形式](@entry_id:142897)要求我们找到解 $u$，使得对于所有合适的[检验函数](@entry_id:166589) $v$ 都满足：
$$
\int_\Omega \kappa \nabla u \cdot \nabla v \, dx + \text{边界项} = \int_\Omega s v \, dx + \text{边界项}
$$
通过在每个单元 $e$ 上应用这个[弱形式](@entry_id:142897)，并使用[局部基](@entry_id:151573)函数 $\phi_m^e$，我们可以得到[单元刚度矩阵](@entry_id:139369)和[载荷向量](@entry_id:635284)的贡献：
-   **[单元刚度矩阵](@entry_id:139369)**: $K^e_{mn} = \int_{\Omega_e} \kappa \nabla\phi_m^e \cdot \nabla\phi_n^e \, dx$
-   **单元源[载荷向量](@entry_id:635284)**: $f^e_m = \int_{\Omega_e} s \phi_m^e \, dx$

此外，像 Robin 和 Neumann 这样的自然边界条件也会对位于域边界上的单元产生贡献。例如，Robin 条件 $(\kappa\nabla u)\cdot n+\beta u=r$ 会在边界单元的面 $f$ 上产生一个刚度贡献 $K^{R,f}_{mn} = \int_{f} \beta \phi_m^e \phi_n^e \, ds$ 和一个载荷贡献 $f^{R,f}_m = \int_{f} r \phi_m^e \, ds$。

一旦我们为域中的每个单元和边界上的每个面计算了这些局部贡献，组装过程就开始了。[全局刚度矩阵](@entry_id:138630) $K$ 的每个元素 $K_{ij}$ 是所有[单元刚度矩阵](@entry_id:139369)贡献的总和，其中全局自由度 $i$ 和 $j$ 在同一个单元中相互作用。类似地，全局[载荷向量](@entry_id:635284) $\mathbf{f}$ 的每个分量 $f_i$ 也是所有相关单元和边界载荷贡献的总和。这个过程可以用一个**散射算子 (scatter operator)** $A_e$ 来形式化地描述，它将局部自由度映射到全局自由度。全局矩阵和向量可以表示为所有单元贡献的总和 ：
$$
K = \sum_{e \in \mathcal{T}_h} A_e^T K^e A_e, \quad \mathbf{f} = \sum_{e \in \mathcal{T}_h} A_e^T \mathbf{f}^e
$$
（这里为了简洁起见，我们省略了边界项的贡献）。这个过程的本质是一个基于连通性的累加操作，它构成了有限元计算流程的核心。

### 单元贡献的计算：参考单元上的离散化

上一节我们把计算局部贡献的过程称为“离散化”，现在我们来深入了解这个过程是如何高效实现的。直接在物理空间中为每个可能形状和大小各不相同的单元计算积分是极其低效的。取而代之的是，我们引入一个标准化的**参考单元 (reference element)** $\hat{K}$，例如一个单位立方体或三角形。然后，我们为网格中的每个物理单元 $K_e$ 定义一个**[等参映射](@entry_id:173239) (isoparametric mapping)** $F_e: \hat{K} \to K_e$，使得物理坐标 $x$ 可以由参考坐标 $\hat{\xi}$ 表示：$x = F_e(\hat{\xi})$。

这个映射使我们能够将物理单元上的所有计算转移到[参考单元](@entry_id:168425)上进行。这涉及到两个关键的变换 ：
1.  **积分[体积元](@entry_id:267802)变换**：物理[体积元](@entry_id:267802) $dx$ 通过映射的**雅可比矩阵 (Jacobian matrix)** $J(\hat{\xi}) = \frac{\partial x}{\partial \hat{\xi}}$ 的[行列式](@entry_id:142978)与参考体积元 $d\hat{\xi}$ 相关联：$dx = \det(J(\hat{\xi})) d\hat{\xi}$。对于有效的单元，$\det(J)$ 必须为正。

2.  **梯度变换**：物理空间中的[梯度算子](@entry_id:275922) $\nabla_x$ 也必须变换到参考空间中的[梯度算子](@entry_id:275922) $\nabla_{\hat{\xi}}$。利用链式法则，可以推导出它们之间的关系：$\nabla_x \phi = (J^{-\top}) \nabla_{\hat{\xi}} \hat{\phi}$。

将这些变换应用于[单元刚度矩阵](@entry_id:139369)的积分表达式，例如对于[各向异性热传导](@entry_id:152726)问题 $K_e(i,j) = \int_{K_e} \nabla \varphi_i(x)^{\top} A(x) \nabla \varphi_j(x) \, dx$，我们得到一个在参考单元上的积分 ：
$$
K_{e}(i,j) = \int_{\hat{K}} \left( \nabla_{\hat{\xi}} \hat{\varphi}_{i} \right)^{\top} J^{-1} A(F_e(\hat{\xi})) J^{-\top} \nabla_{\hat{\xi}} \hat{\varphi}_{j} \det(J) \, d\hat{\xi}
$$
这个在参考单元 $\hat{K}$ 上的积分现在可以用标准的**[数值积分](@entry_id:136578) (numerical quadrature)** 法则（如[高斯积分](@entry_id:187139)）来近似计算。该积分被替换为一个在预[定积分](@entry_id:147612)点 $\hat{\xi}_q$ 上的加权和：
$$
K_{e}(i,j) \approx \sum_{q=1}^{n_q} \hat{w}_q \left[ \left( \nabla_{\hat{\xi}} \hat{\varphi}_{i} \right)^{\top} J^{-1} A J^{-\top} \nabla_{\hat{\xi}} \hat{\varphi}_{j} \det(J) \right]_{\hat{\xi} = \hat{\xi}_q}
$$
其中 $\hat{w}_q$ 是积分权重。这种方法极为强大，因为它将几何复杂性（通过雅可比矩阵 $J$ 体现）与[基函数](@entry_id:170178)（在参考单元上是固定的）和物理属性（如[电导率张量](@entry_id:155827) $A$）分离开来。

对于时间相关的波动问题，例如线[弹性动力学](@entry_id:175818)，除了[刚度矩阵](@entry_id:178659)外，我们还需要组装一个**质量矩阵 (mass matrix)** $M$。其单元贡献来自于弱形式中的惯性项 $\int_\Omega \rho \ddot{\boldsymbol{u}} \cdot \boldsymbol{v} \, d\boldsymbol{x}$，其中 $\rho$ 是密度。这导致了[单元质量矩阵](@entry_id:748930)的形式为 $M_e(i,j) = \int_{K_e} \rho \boldsymbol{\phi}_i \cdot \boldsymbol{\phi}_j \, d\boldsymbol{x}$ 。这个积分同样可以通过映射到参考单元并使用[数值积分](@entry_id:136578)来计算。

### 组装映射：连通性与自由度

计算出所有单元矩阵 $K_e$ 和向量 $\mathbf{f}_e$ 后，下一步是将它们组装到全局系统 $K \mathbf{u} = \mathbf{f}$ 中。这个过程的核心是一个将每个单元的**局部自由度 (local DOFs)** 映射到**全局自由度 (global DOFs)** 的机制。

这个映射由两个信息共同定义 ：
1.  **单元连通性数组 (Element Connectivity Array)**：这是[网格数据结构](@entry_id:751901)的核心部分，对于每个单元，它列出了组成该单元的全局节点编号。例如，一个[四面体单元](@entry_id:168311) $T_1$ 的连通性可能是 $[1, 2, 3, 4]$，意味着它由全局节点1、2、3和4构成。

2.  **全局自由度编号方案 (Global DOF Numbering Scheme)**：这个方案为系统中的每个独立未知量分配一个唯一的整数索引。对于标量问题（每个节点一个自由度），全局自由度索引通常就是全局节点编号。对于向量问题，例如三维[位移场](@entry_id:141476)，每个节点有多个自由度（如 $u_x, u_y, u_z$）。一个常见的编号方案是按节点分组，即节点 $n$ 的所有自由度排在节点 $n-1$ 之后、节点 $n+1$ 之前。例如，如果每个节点有3个自由度，则节点 $n$ 的自由度全局索引可能是 $3(n-1)+1, 3(n-1)+2, 3(n-1)+3$。

结合这两条信息，我们可以为每个单元 $e$ 构建一个**局部到全局的索引映射 $M_e$**。这个映射告诉我们，单元 $e$ 的第 $r$ 个局部自由度对应于全局系统中的第 $i = M_e(r)$ 个自由度。

组装过程（也称为**散射-相加 scatter-add**）如下进行：对于每个单元 $e$ 的单元矩阵 $K_e$ 中的每一个元素 $(K_e)_{rs}$，我们使用映射 $M_e$ 找到其对应的全局索引 $i=M_e(r)$ 和 $j=M_e(s)$，然后将其值加到全局矩阵的相应位置上：$K_{ij} \mathrel{+}= (K_e)_{rs}$。对[载荷向量](@entry_id:635284) $\mathbf{f}_e$ 也执行类似的操作。

这个过程也决定了全局矩阵 $K$ 的**稀疏模式 (sparsity pattern)**。$K_{ij}$ 的值非零，当且仅当全局自由度 $i$ 和 $j$ 至少在同一个单元中相互耦合。由于[基函数](@entry_id:170178)具有局部支集，一个自由度只与邻近的少数其他自由度相互作用，这使得全局矩阵 $K$ 是一个大型**稀疏矩阵**。在实际应用中，它通常以**压缩稀疏行 (Compressed Sparse Row, CSR)** 或类似格式存储，以节省内存并加速计算 。

### 高级组装主题与验证

随着问题的复杂性增加，组装过程也需要考虑更多的因素。

#### 向量问题与矩阵对称性

当从标量问题（如热传导）转向向量问题（如弹性力学）时，组装的基本原理保持不变，但矩阵的结构和性质值得关注。对于线弹性问题，其[变分形式](@entry_id:166033) $a(\boldsymbol{u}, \boldsymbol{v}) = \int_{\Omega} \boldsymbol{\sigma}(\boldsymbol{u}) : \boldsymbol{\varepsilon}(\boldsymbol{v}) \, d\boldsymbol{x}$ 是对称的，即 $a(\boldsymbol{u}, \boldsymbol{v}) = a(\boldsymbol{v}, \boldsymbol{u})$ 。这种对称性源于[应力张量](@entry_id:148973) $\boldsymbol{\sigma}$ 和应变张量 $\boldsymbol{\varepsilon}$ 的对称性以及弹性[本构矩阵](@entry_id:164908) $D$ 的对称性。因此，正确组装的[全局刚度矩阵](@entry_id:138630) $K$ 和[质量矩阵](@entry_id:177093) $M$ 也必须是**对称**的（$K=K^T, M=M^T$）。

在模拟地球物理中的波传播时，经常会引入阻尼。一种常见的模型是**[瑞利阻尼](@entry_id:172362) (Rayleigh damping)**，其中阻尼矩阵 $C$ 是质量矩阵和刚度矩阵的[线性组合](@entry_id:154743)：$C = \alpha M + \beta K$。由于 $M$ 和 $K$ 都是对称的，所以 $C$ 也是对称的。然而，当我们转换到[频域](@entry_id:160070)并形成**动力刚度矩阵 (dynamic stiffness matrix)** $A(\omega) = K - \omega^2 M + i \omega C$ 时，矩阵的性质会发生变化。由于虚数单位 $i$ 的存在，尽管 $A(\omega)$ 仍然是[转置](@entry_id:142115)对称的（$A=A^T$），但它不再是**厄米特 (Hermitian)** 的（$A \neq A^H = \bar{A}^T$）。具体来说，$A^H = K - \omega^2 M - i \omega C$。只有在无阻尼或零频率的特殊情况下，$A$ 才是厄米特的。这个性质对选择求解器和理解系统能量耗散至关重要 。

#### [非线性](@entry_id:637147)问题的组装

许多地球物理问题本质上是[非线性](@entry_id:637147)的，例如，当材料属性（如[电导率](@entry_id:137481) $k$）依赖于解本身（如温度 $u$）时。这类问题通常通过迭代线性化方法求解，如**皮卡 (Picard)** 迭代或**牛顿-拉夫逊 ([Newton-Raphson](@entry_id:177436))** 方法。每次迭代都需要组装和求解一个[线性系统](@entry_id:147850)，但系统的矩阵会因所选的线性化方案而异 。

-   **[皮卡迭代](@entry_id:149873)**：这是一种简单的[定点迭代](@entry_id:137769)，它将[非线性](@entry_id:637147)系数 "冻结" 在上一次迭代的值上。对于问题 $-\nabla \cdot (k(u)\nabla u) = s$，在第 $m+1$ 次迭代中求解的方程是 $-\nabla \cdot (k(u^{(m)})\nabla u^{(m+1)}) = s$。组装的矩阵 $K_{ij} = \int k(u^{(m)}) \nabla N_i \cdot \nabla N_j \, d\Omega$ 仍然是**[对称正定](@entry_id:145886)**的，其稀疏模式与线性问题完全相同。[皮卡方法](@entry_id:141828)通常**[线性收敛](@entry_id:163614)**。

-   **[牛顿法](@entry_id:140116)**：[牛顿法](@entry_id:140116)通过求解 $J(\mathbf{u}^{(m)}) \delta\mathbf{u} = -R(\mathbf{u}^{(m)})$ 来寻找更新量 $\delta\mathbf{u}$，其中 $R$ 是[非线性方程组](@entry_id:178110)的残差，$J$ 是其[雅可比矩阵](@entry_id:264467)。对于上述问题，$J$ 的项为 $J_{ij} = \frac{\partial R_i}{\partial u_j}$。经过推导，可以发现牛顿雅可比矩阵包含两部分：一部分是与皮卡矩阵相同的对称项，另一部分则来自于 $k(u)$ 对 $u$ 的导数 $k'(u)$。这个附加项的形式为 $\int k'(u^{(m)}) N_j (\nabla u^{(m)} \cdot \nabla N_i) \, d\Omega$，它通常是**非对称**的。因此，牛顿法在每次迭代中组装的是一个[非对称矩阵](@entry_id:153254)。尽管矩阵结构不同，其稀疏模式与皮卡矩阵相同，因为耦合关系仍然由[基函数](@entry_id:170178)的支集重叠决定。[牛顿法](@entry_id:140116)在初始猜测足够接近解时，通常表现出**二次收敛**，速度远快于皮卡法。

#### 带约束的协调离散化

标准的组装过程假设网格是协调的（conforming），即相邻单元共享完整的面、边或顶点。然而，在某些高级应用中，必须处理不协调的网格。

-   **h-自适应与[悬挂节点](@entry_id:149024)**：在 **h-[自适应网格](@entry_id:164379)**中，为了提高局部解的精度，某些单元被细化，而其邻居则不然。这会在粗细单元的交界面上产生所谓的**[悬挂节点](@entry_id:149024) (hanging nodes)**——即细网格上的节点，但不是粗网格的顶点。为了保持解的连续性（即保证离散空间是 $H^1$ 协调的），[悬挂节点](@entry_id:149024)上的值不能是独立的自由度，而必须通过其所在边或面上的粗网格节点的值来插值得到 。这引入了**线性约束方程** $\mathbf{u}_d = C \mathbf{u}_i$，其中 $\mathbf{u}_d$ 是从属（悬挂）自由度向量，$\mathbf{u}_i$ 是独立（主）自由度向量，而 $C$ 是由粗单元[基函数](@entry_id:170178)在[悬挂节点](@entry_id:149024)位置处的值构成的**约束矩阵**。在组装时，这些约束必须被整合进去。这可以通过修改组装过程来实现：全局系统只为独立自由度构建，而从属自由度的贡献通过一个**嵌入矩阵 (embedding matrix)** $E$ "凝聚" 到独立自由度上。最终的协调[刚度矩阵](@entry_id:178659)由变换 $A_c = E^T A E$ 给出，其中 $A$ 是忽略约束时组装的非协调矩阵。

-   **保旋元与边方向**：在电磁学等领域，使用**保旋 (curl-conforming)** 单元（如 Nedelec 单元）来离散化矢量场（如[电场](@entry_id:194326) $\mathbf{E}$）至关重要。对于这类单元，自由度不与节点关联，而是与单元的**边**或**面**关联，其定义通常是场沿着某条边或穿过某个面的切向或法向分量的积分 。例如，一阶 Nedelec 单元的自由度是[电场](@entry_id:194326)沿每条边的切向分量的线积分 $d_e = \int_e \mathbf{E} \cdot \mathbf{t}_e \, ds$。这个定义显然依赖于边的**方向**（由切向量 $\mathbf{t}_e$ 定义）。如果两个相邻单元对共享的同一条边采用了相反的局部方向约定，那么它们计算出的该自由度的贡献就会带相反的符号。如果在组装时忽略了这种方向不一致性，将会破坏场的切向连续性，导致非物理的[伪解](@entry_id:275285)，甚至使全局矩阵变得奇异。正确的组装方法是：首先为网格中的每条边建立一个唯一的**全局方向**（例如，从全局索引较小的顶点指向较大的顶点）。然后，在组装每个单元时，将其局部边方向与全局方向进行比较，得到一个符号因子 $s_{K,e} \in \{+1, -1\}$。单元矩阵 $(K_e)_{ij}$ 对全局矩阵 $K_{IJ}$ 的贡献需要乘以符号因子 $s_{K,e_i}s_{K,e_j}$ 进行修正。

#### 组装验证与质量控制

由于组装过程涉及复杂的索引操作，很容易出错。因此，开发一些验证程序来检查组装的正确性至关重要。

一个非常有效且简单的检查方法利用了标准[拉格朗日基](@entry_id:751105)函数的**单位分解 (partition of unity)** 性质，即在域中的任意点 $\mathbf{x}$，所有[基函数](@entry_id:170178)的和恒为1：$\sum_{i=1}^{n} N_i(\mathbf{x}) = 1$。利用这个性质，我们可以推导出关于质量矩阵 $M$ 的一个精确恒等式 。一个向量 $\mathbf{1}$（所有分量均为1）与[质量矩阵](@entry_id:177093)的二次型 $\mathbf{1}^T M \mathbf{1}$ 等于：
$$
\mathbf{1}^T M \mathbf{1} = \sum_{i,j} M_{ij} = \sum_{i,j} \int_\Omega \rho N_i N_j \, d\mathbf{x} = \int_\Omega \rho \left(\sum_i N_i\right) \left(\sum_j N_j\right) \, d\mathbf{x} = \int_\Omega \rho (1)(1) \, d\mathbf{x} = \text{总质量}
$$
这意味着，正确组装的全局质量矩阵的所有元素之和必须精确等于域的总质量。这个测试非常灵敏。例如，如果一个单元因节点顺序错误而导致其雅可比行列式为负（即所谓的**翻转单元 (inverted element)**），那么它对总和的贡献将是其质量的负值，而不是正值。如果一个质量为 $m_e$ 的单元被翻转，计算出的总和将比真实总质量小 $2m_e$。因此，通过比较 $\mathbf{1}^T M \mathbf{1}$ 与独立计算的域总质量，可以有效地检测出此类错误。

此外，一个正确组装的质量矩阵（对于正密度 $\rho$）必须是**[对称正定](@entry_id:145886)**的。一个翻转的单元会向二次型 $\mathbf{v}^T M \mathbf{v}$ 贡献一个负项，可能导致整个矩阵变得不定。因此，检查组装后的质量矩阵是否存在负[特征值](@entry_id:154894)是诊断[雅可比行列式](@entry_id:137120)符号错误的另一种有效方法 。

### [高性能计算](@entry_id:169980)视角：无矩阵组装

在传统的[有限元分析](@entry_id:138109)中，全局矩阵 $K$ 被显式地组装和存储，然后通过**[稀疏矩阵向量乘法](@entry_id:755103) (SpMV)** 在迭代求解器中反复使用。然而，在现代计算架构（如图形处理器 GPUs）上，这种方法面临挑战。显式存储一个巨大的[稀疏矩阵](@entry_id:138197)会消耗大量内存，而 SpMV 操作的性能往往受到[内存带宽](@entry_id:751847)的限制，而不是计算能力的限制。

一种替代方法是**无矩阵 (matrix-free)** 方法。这种方法完全避免了组装和存储全局矩阵。当需要计算乘积 $K\mathbf{u}$ 时，它会“即时”地通过遍历所有单元、执行局部[矩阵向量乘法](@entry_id:140544)并将结果累加到全局向量中来计算 。
$$
K\mathbf{u} = \left(\sum_e A_e^T K_e A_e\right) \mathbf{u} = \sum_e A_e^T (K_e (A_e \mathbf{u}))
$$
对于使用[高阶张量](@entry_id:200122)积[基函数](@entry_id:170178)的单元，这个过程可以利用**[和因子分解](@entry_id:755628) (sum-factorization)** 技术进一步优化，将多维操作分解为一系列一维操作，从而显著减少计算量。

这两种方法之间的选择是一个典型的计算权衡问题，可以用**[屋顶线模型](@entry_id:163589) (Roofline model)** 来分析。该模型指出，一个计算核心的持续性能取决于其**[算术强度](@entry_id:746514) (arithmetic intensity)**（每字节内存传输的[浮点运算次数](@entry_id:749457)，flop/byte）。

-   **显式 SpMV**：其[算术强度](@entry_id:746514)通常很低且与多项式次数 $p$ 无关。因此，它几乎总是**内存带宽受限**的。

-   **[无矩阵方法](@entry_id:145312)**：对于[高阶单元](@entry_id:750328)，其[算术强度](@entry_id:746514)随着多项式次数 $p$ 的增加而增加（在3D中通常是线性增长，$O(p)$）。这是因为计算量（$\propto p^{d+1}$）比数据量（$\propto p^d$）增长得更快。因此，对于足够高的 $p$，[无矩阵方法](@entry_id:145312)可以从内存受限过渡到**计算受限**，从而更好地利用现代硬件的峰值计算能力 。

此外，还有一个前期成本的权衡。显式组装需要一个显著的、一次性的组装成本 $T_{\text{asm}}$。对于需要大量时间步长的瞬态波传播模拟，如果[无矩阵方法](@entry_id:145312)每次应用的成本 $t_{\text{mf}}$ 略高于 SpMV 的成本 $t_{\text{spmv}}$，那么只有当模拟的总时间步数 $N_t$ 足够大，能够摊销初始组装成本时，显式方法才具有优势。临界的步数由 $N_t > T_{\text{asm}} / (t_{\text{mf}} - t_{\text{spmv}})$ 给出 。

总之，[全局组装](@entry_id:749916)是有限元方法中一个多方面且至关重要的步骤。它不仅是将数学理论转化为可执行代码的机制，还涉及到对对称性、[非线性](@entry_id:637147)、几何约束和计算性能等问题的深刻理解。对这些原理和机制的掌握是进行高级计算[地球物理建模](@entry_id:749869)的基础。