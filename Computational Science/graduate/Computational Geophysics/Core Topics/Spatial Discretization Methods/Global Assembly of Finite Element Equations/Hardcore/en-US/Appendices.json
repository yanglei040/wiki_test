{
    "hands_on_practices": [
        {
            "introduction": "The global system of equations in the finite element method is constructed by summing contributions from individual elements. This first practice grounds you in this fundamental process, using the mass matrix as a concrete example derived from integrating basis functions over an element's domain. This exercise will solidify your understanding of how to calculate an element matrix using numerical quadrature and how to perform a local-to-global assembly, demonstrating how shared nodes accumulate properties from all neighboring elements .",
            "id": "3600322",
            "problem": "Consider the scalar acoustic wave equation used in computational seismology on a three-dimensional domain, where the semi-discrete finite element method with trilinear hexahedral elements leads to a mass matrix. Let the weak form mass bilinear form be the elementwise integral of the density-weighted inner product, so that the consistent element mass matrix satisfies $M_e = \\left[m_{ij}^{(e)}\\right]$ with entries $m_{ij}^{(e)} = \\int_{\\Omega_e} \\rho(\\boldsymbol{x}) N_i(\\boldsymbol{x}) N_j(\\boldsymbol{x}) \\, \\mathrm{d}V$, where $N_i$ are the trilinear shape functions on element $\\Omega_e$. Use the isoparametric mapping $\\boldsymbol{x}(\\xi,\\eta,\\zeta)$ from the reference cube $\\hat{\\Omega} = [-1,1]^3$ to the physical hexahedron and denote the Jacobian determinant by $J(\\xi,\\eta,\\zeta) = \\det\\left(\\partial \\boldsymbol{x} / \\partial (\\xi,\\eta,\\zeta)\\right)$.\n\nTasks:\n1) Starting from the weak-form definition $m_{ij}^{(e)} = \\int_{\\Omega_e} \\rho N_i N_j \\, \\mathrm{d}V$ and the isoparametric transformation, derive the explicit tensor-product $2 \\times 2 \\times 2$ Gauss–Legendre quadrature formula for $M_e$, writing it in a compact matrix form that exhibits the sum over the $8$ quadrature points $(\\xi_a,\\eta_b,\\zeta_c) \\in \\{\\pm 1/\\sqrt{3}\\}^3$ with weights equal to $1$ in each dimension. Your expression must explicitly include the vector of shape functions evaluated at quadrature points, the density evaluated at mapped quadrature points, and $J(\\xi,\\eta,\\zeta)$.\n2) Using first principles, discuss precise conditions on the element mapping and material density field under which diagonal mass lumping is exact in the following two senses: (i) exactness of the consistent element mass computed by quadrature, and (ii) exactness of the diagonal lumped mass matrix when compared to the consistent mass in reproducing elementwise weighted $L^2$ integrals of functions in the finite element space. Your discussion must clearly identify which notions of “exactness” can and cannot hold for standard trilinear hexahedra with positive quadrature weights.\n3) Consider the rectangular domain $\\Omega = [0, 2L_x] \\times [0, L_y] \\times [0, L_z]$ with constant density $\\rho$, discretized by two axis-aligned, congruent trilinear hexahedral elements $\\Omega_1 = [0, L_x] \\times [0, L_y] \\times [0, L_z]$ and $\\Omega_2 = [L_x, 2L_x] \\times [0, L_y] \\times [0, L_z]$. Perform diagonal mass lumping by the standard row-sum procedure at the element level and assemble globally. Determine the lumped global mass associated with the shared global corner node at $\\boldsymbol{x} = (L_x, 0, 0)$. Express your final answer as a single closed-form analytic expression in terms of $\\rho$, $L_x$, $L_y$, and $L_z$. Do not substitute numerical values. No rounding is required. Do not include units in your final expression; however, interpret $\\rho$ as mass density measured in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$ and $L_x$, $L_y$, $L_z$ as lengths measured in $\\mathrm{m}$.",
            "solution": "The problem presents a three-part query concerning the mass matrix in the finite element method as applied to computational seismology. The tasks involve derivation, theoretical discussion, and a specific calculation. The problem will be addressed by sequentially solving each of the three tasks.\n\n### Task 1: Quadrature Formula for the Element Mass Matrix\n\nThe entry $m_{ij}^{(e)}$ of the consistent element mass matrix $M_e$ is given by the integral over the physical element domain $\\Omega_e$:\n$$m_{ij}^{(e)} = \\int_{\\Omega_e} \\rho(\\boldsymbol{x}) N_i(\\boldsymbol{x}) N_j(\\boldsymbol{x}) \\, \\mathrm{d}V$$\nUsing the isoparametric mapping $\\boldsymbol{x} = \\boldsymbol{x}(\\xi, \\eta, \\zeta)$ from the reference cube $\\hat{\\Omega} = [-1,1]^3$ to $\\Omega_e$, the integral is transformed into the reference coordinates $(\\xi, \\eta, \\zeta)$. The shape functions become functions on the reference element, $N_i(\\boldsymbol{x}) = N_i(\\boldsymbol{x}(\\xi, \\eta, \\zeta)) \\equiv \\hat{N}_i(\\xi, \\eta, \\zeta)$, and the volume element transforms as $\\mathrm{d}V = J(\\xi, \\eta, \\zeta) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta \\, \\mathrm{d}\\zeta$, where $J$ is the Jacobian determinant of the mapping.\nThe integral becomes:\n$$m_{ij}^{(e)} = \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} \\rho(\\boldsymbol{x}(\\xi,\\eta,\\zeta)) \\hat{N}_i(\\xi,\\eta,\\zeta) \\hat{N}_j(\\xi,\\eta,\\zeta) J(\\xi,\\eta,\\zeta) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta \\, \\mathrm{d}\\zeta$$\nWe approximate this integral using a $2 \\times 2 \\times 2$ tensor-product Gauss-Legendre quadrature. The quadrature points are $(\\xi_a, \\eta_b, \\zeta_c)$ where $a,b,c \\in \\{1,2\\}$ and $\\{\\xi_1, \\xi_2\\} = \\{\\eta_1, \\eta_2\\} = \\{\\zeta_1, \\zeta_2\\} = \\{-1/\\sqrt{3}, 1/\\sqrt{3}\\}$. The corresponding weights are given as $w_a = w_b = w_c = 1$. The total number of quadrature points is $8$. Let a generic quadrature point be denoted by $\\boldsymbol{q}_k$ with corresponding weight $W_k$, for $k=1, \\dots, 8$. For the tensor-product rule specified, the 3D weight is the product of the 1D weights, so $W_k = w_a w_b w_c = 1 \\cdot 1 \\cdot 1 = 1$ for all $k$.\n\nThe integral is approximated by the sum:\n$$m_{ij}^{(e)} \\approx \\sum_{k=1}^{8} W_k \\left[ \\rho(\\boldsymbol{x}(\\boldsymbol{q}_k)) \\hat{N}_i(\\boldsymbol{q}_k) \\hat{N}_j(\\boldsymbol{q}_k) J(\\boldsymbol{q}_k) \\right]$$\nSince all $W_k=1$, and henceforth dropping the hat notation for shape functions on the reference element, this simplifies to:\n$$m_{ij}^{(e)} \\approx \\sum_{k=1}^{8} \\rho(\\boldsymbol{x}(\\boldsymbol{q}_k)) J(\\boldsymbol{q}_k) N_i(\\boldsymbol{q}_k) N_j(\\boldsymbol{q}_k)$$\nTo write this in a compact matrix form for the entire $8 \\times 8$ element mass matrix $M_e = [m_{ij}^{(e)}]$, we define a column vector of shape functions $\\boldsymbol{N}(\\boldsymbol{q}) = [N_1(\\boldsymbol{q}), N_2(\\boldsymbol{q}), \\dots, N_8(\\boldsymbol{q})]^T$. The term $N_i(\\boldsymbol{q}_k) N_j(\\boldsymbol{q}_k)$ is the $(i,j)$ entry of the outer product $\\boldsymbol{N}(\\boldsymbol{q}_k) \\boldsymbol{N}(\\boldsymbol{q}_k)^T$.\nThe element mass matrix is therefore the sum of $8$ rank-$1$ matrices, each corresponding to a quadrature point:\n$$M_e \\approx \\sum_{k=1}^{8} \\rho(\\boldsymbol{x}(\\boldsymbol{q}_k)) J(\\boldsymbol{q}_k) \\boldsymbol{N}(\\boldsymbol{q}_k) \\boldsymbol{N}(\\boldsymbol{q}_k)^T$$\nTo be more explicit with the tensor-product structure, let the quadrature points be $\\boldsymbol{q}_{abc} = (\\xi_a, \\eta_b, \\zeta_c)$ with $a,b,c \\in \\{1,2\\}$ and weights $w_a=w_b=w_c=1$. The mass matrix formula is:\n$$M_e \\approx \\sum_{a=1}^2 \\sum_{b=1}^2 \\sum_{c=1}^2 w_a w_b w_c \\rho(\\boldsymbol{x}(\\boldsymbol{q}_{abc})) J(\\boldsymbol{q}_{abc}) \\boldsymbol{N}(\\boldsymbol{q}_{abc}) \\boldsymbol{N}(\\boldsymbol{q}_{abc})^T$$\nGiven the weights are unity, this is:\n$$M_e \\approx \\sum_{a=1}^2 \\sum_{b=1}^2 \\sum_{c=1}^2 \\rho(\\boldsymbol{x}(\\xi_a,\\eta_b,\\zeta_c)) J(\\xi_a,\\eta_b,\\zeta_c) \\boldsymbol{N}(\\xi_a,\\eta_b,\\zeta_c) \\boldsymbol{N}(\\xi_a,\\eta_b,\\zeta_c)^T$$\n\n### Task 2: Conditions for Exact Mass Lumping\n\n(i) **Exactness of the consistent element mass computed by quadrature.**\nThe $2 \\times 2 \\times 2$ Gauss-Legendre quadrature rule is exact for integrands that are polynomials of degree at most $2n-1 = 2(2)-1=3$ in each variable independently. The integrand for $m_{ij}^{(e)}$ in reference coordinates is $f(\\xi,\\eta,\\zeta) = \\rho(\\boldsymbol{x}(\\xi,\\eta,\\zeta)) J(\\xi,\\eta,\\zeta) N_i(\\xi,\\eta,\\zeta) N_j(\\xi,\\eta,\\zeta)$.\nThe trilinear shape functions $N_i$ are polynomials of degree $1$ in each variable (e.g., $N_1 = \\frac{1}{8}(1-\\xi)(1-\\eta)(1-\\zeta)$). The product $N_i N_j$ is therefore a polynomial of degree at most $2$ in each variable (e.g., for $i \\neq j$, $N_1 N_8 = \\frac{1}{64}(1-\\xi^2)(1-\\eta^2)(1-\\zeta^2)$). Since degree $2 < 3$, the shape function product part of the integrand is integrated exactly.\nThe mapping is $\\boldsymbol{x}(\\xi,\\eta,\\zeta) = \\sum_k \\boldsymbol{x}_k N_k(\\xi,\\eta,\\zeta)$. The entries of the Jacobian matrix $\\partial\\boldsymbol{x}/\\partial(\\xi,\\eta,\\zeta)$ involve derivatives of $N_k$, which are bilinear (e.g., $\\partial N_k/\\partial\\xi$ is linear in $\\eta$ and $\\zeta$). The Jacobian determinant $J$ is the determinant of a $3 \\times 3$ matrix of such bilinear functions, resulting in a polynomial in $\\xi, \\eta, \\zeta$ whose degree can be up to $6$ in each variable. This is far higher than the degree $3$ that the quadrature rule can handle.\nTherefore, the integration is generally not exact. The precise condition for the quadrature to be exact is that the product $\\rho(\\boldsymbol{x}(\\xi,\\eta,\\zeta)) J(\\xi,\\eta,\\zeta)$ must be of a form such that the total integrand $f(\\xi,\\eta,\\zeta)$ is a polynomial of degree at most $3$ in each variable. A simple, sufficient condition is that both the density $\\rho$ and the Jacobian determinant $J$ are constant. Constant $J$ occurs when the mapping is affine, which for a hexahedral element implies it is a parallelepiped (a rectangular brick being a special case). Constant $\\rho$ is a material property. Under these conditions, the integrand's polynomial degree is determined solely by $N_i N_j$, which is at most $2$ in each variable, and the integration is exact.\n\n(ii) **Exactness of the diagonal lumped mass matrix.**\nThe standard row-sum lumped mass matrix $M_L$ has diagonal entries $(M_L)_{ii} = \\sum_j m_{ij}^{(e)}$ and zero off-diagonal entries. By the partition of unity property of shape functions, $\\sum_j N_j(\\boldsymbol{x}) = 1$, the diagonal entries are equivalent to the nodal mass:\n$$(M_L)_{ii} = \\sum_{j=1}^8 \\int_{\\Omega_e} \\rho N_i N_j \\, \\mathrm{d}V = \\int_{\\Omega_e} \\rho N_i \\left( \\sum_{j=1}^8 N_j \\right) \\, \\mathrm{d}V = \\int_{\\Omega_e} \\rho N_i \\, \\mathrm{d}V$$\nThe question asks for the condition under which lumping is exact in reproducing the elementwise weighted $L^2$ integral of a function $u_h(\\boldsymbol{x}) = \\sum_i u_i N_i(\\boldsymbol{x})$ from the finite element space. Let $\\boldsymbol{u}$ be the vector of nodal values $u_i$. The integral computed with the consistent mass matrix is $\\boldsymbol{u}^T M_e \\boldsymbol{u}$. The same quantity computed with the lumped matrix is $\\boldsymbol{u}^T M_L \\boldsymbol{u}$.\nExactness requires $\\boldsymbol{u}^T M_e \\boldsymbol{u} = \\boldsymbol{u}^T M_L \\boldsymbol{u}$ for any arbitrary choice of nodal values $\\boldsymbol{u}$.\n$$\\sum_{i,j} u_i m_{ij}^{(e)} u_j = \\sum_i u_i^2 (M_L)_{ii} = \\sum_i u_i^2 \\sum_j m_{ij}^{(e)}$$\nThis equality must hold for all $\\boldsymbol{u}$. By expanding the sums and comparing coefficients of terms like $u_i u_j$ for $i \\neq j$, we find that the equality holds if and only if all off-diagonal entries $m_{ij}^{(e)}$ (for $i \\neq j$) are zero. This means the consistent mass matrix $M_e$ must be diagonal.\nThe condition $m_{ij}^{(e)} = \\int_{\\Omega_e} \\rho N_i N_j \\, \\mathrm{d}V = 0$ for $i \\neq j$ implies that the shape functions $N_i$ must be an orthogonal set with respect to the inner product weighted by $\\rho(\\boldsymbol{x})$. Standard Lagrange-type shape functions, including trilinear functions, are not orthogonal; their supports overlap significantly, leading to a non-diagonal (in this case, dense) consistent mass matrix $M_e$. The use of positive quadrature weights as specified further ensures that the computed $M_e$ is not diagonal.\nTherefore, for standard trilinear hexahedra, there are no non-trivial conditions on the element mapping or density field that make mass lumping exact in this sense. Lumping is fundamentally an approximation that alters this quadratic form, though it does preserve the total element mass (i.e., $\\boldsymbol{1}^T M_e \\boldsymbol{1} = \\boldsymbol{1}^T M_L \\boldsymbol{1}$).\n\n### Task 3: Calculation of Lumped Mass at a Shared Node\n\nWe need to compute the global lumped mass at the node $P = (L_x, 0, 0)$. This node is shared by two elements, $\\Omega_1 = [0, L_x] \\times [0, L_y] \\times [0, L_z]$ and $\\Omega_2 = [L_x, 2L_x] \\times [0, L_y] \\times [0, L_z]$. The global lumped mass at a node is the sum of the local lumped mass contributions from all elements that share the node.\n$$M_P^{\\text{global}} = \\sum_{e \\in \\{\\Omega_1, \\Omega_2\\}} (m_{ii}^{(e)})_L$$\nwhere $i$ is the local index of node $P$ in element $e$.\nThe local lumped mass for a node $i$ in an element $e$ is given by $(m_{ii}^{(e)})_L = \\int_{\\Omega_e} \\rho N_i^{(e)} \\, \\mathrm{d}V$.\n\nContribution from element $\\Omega_1$:\nThe element $\\Omega_1$ is a rectangular brick of dimensions $L_x \\times L_y \\times L_z$. The density $\\rho$ is constant. The lumped mass at node $P$ from $\\Omega_1$ is $\\rho \\int_{\\Omega_1} N_P^{(1)} \\, \\mathrm{d}V$, where $N_P^{(1)}$ is the local shape function in $\\Omega_1$ that is unity at $P$.\nWe can evaluate this integral by transforming to the reference element $\\hat{\\Omega}=[-1,1]^3$. The mapping from $\\hat{\\Omega}$ to $\\Omega_1$ is $x=\\frac{L_x}{2}(1+\\xi)$, $y=\\frac{L_y}{2}(1+\\eta)$, $z=\\frac{L_z}{2}(1+\\zeta)$. The Jacobian determinant is constant: $J = \\frac{L_x L_y L_z}{8}$.\nThe node $P=(L_x,0,0)$ corresponds to the reference coordinates $(\\xi,\\eta,\\zeta)=(1,-1,-1)$. The shape function for this node is $N_P^{(1)}(\\xi,\\eta,\\zeta) = \\frac{1}{8}(1+\\xi)(1-\\eta)(1-\\zeta)$.\nThe integral is:\n$$\\int_{\\Omega_1} N_P^{(1)} \\, \\mathrm{d}V = \\int_{-1}^1 \\int_{-1}^1 \\int_{-1}^1 N_P^{(1)}(\\xi,\\eta,\\zeta) J \\, \\mathrm{d}\\xi \\mathrm{d}\\eta \\mathrm{d}\\zeta$$\n$$= J \\int_{-1}^1 \\int_{-1}^1 \\int_{-1}^1 \\frac{1}{8}(1+\\xi)(1-\\eta)(1-\\zeta) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta \\mathrm{d}\\zeta$$\n$$= \\frac{J}{8} \\left( \\int_{-1}^1 (1+\\xi) \\mathrm{d}\\xi \\right) \\left( \\int_{-1}^1 (1-\\eta) \\mathrm{d}\\eta \\right) \\left( \\int_{-1}^1 (1-\\zeta) \\mathrm{d}\\zeta \\right)$$\nEach of the one-dimensional integrals evaluates to $2$. For instance, $\\int_{-1}^1 (1+u) \\mathrm{d}u = [u+u^2/2]_{-1}^1 = 2$.\nSo, $\\int_{\\Omega_1} N_P^{(1)} \\, \\mathrm{d}V = \\frac{J}{8} (2)(2)(2) = J = \\frac{L_x L_y L_z}{8}$.\nThis is $1/8$ of the volume of the element, $\\text{Vol}(\\Omega_1) = L_x L_y L_z$.\nThe mass contribution from $\\Omega_1$ is $(m^{(1)})_L = \\rho \\frac{\\text{Vol}(\\Omega_1)}{8} = \\frac{\\rho L_x L_y L_z}{8}$.\n\nContribution from element $\\Omega_2$:\nThe element $\\Omega_2$ is congruent to $\\Omega_1$, with the same dimensions $L_x \\times L_y \\times L_z$ and the same constant density $\\rho$. The node $P=(L_x,0,0)$ is also a corner node for $\\Omega_2$. By an identical argument, the integral of the corresponding shape function $N_P^{(2)}$ over $\\Omega_2$ is $1/8$ of the element's volume.\nThe mass contribution from $\\Omega_2$ is $(m^{(2)})_L = \\rho \\frac{\\text{Vol}(\\Omega_2)}{8} = \\frac{\\rho L_x L_y L_z}{8}$.\n\nTotal Global Mass:\nThe total lumped mass at node $P$ is the sum of the contributions from the two elements:\n$$M_P^{\\text{global}} = (m^{(1)})_L + (m^{(2)})_L = \\frac{\\rho L_x L_y L_z}{8} + \\frac{\\rho L_x L_y L_z}{8} = 2 \\frac{\\rho L_x L_y L_z}{8} = \\frac{\\rho L_x L_y L_z}{4}$$\nThe final expression for the lumped global mass at the specified node is $\\frac{\\rho L_x L_y L_z}{4}$.",
            "answer": "$$\\boxed{\\frac{\\rho L_x L_y L_z}{4}}$$"
        },
        {
            "introduction": "Beyond inertia, the stiffness matrix models the system's internal forces, which in geophysics often involves complex material properties and distorted geometries. It is crucial that the symmetry of the underlying physical operator, such as diffusion, is preserved in its discrete form to ensure numerical stability and enable the use of efficient solvers. This practice highlights a common but subtle source of error in FEM codes, teaching you to verify and enforce the symmetry of the assembled stiffness matrix by correctly handling coordinate transformations for gradients .",
            "id": "3600339",
            "problem": "You are to study the global assembly of the Finite Element Method (FEM) stiffness matrix for three-dimensional anisotropic diffusion as used in mantle convection modeling, with a focus on assembly-induced asymmetry. Start from the strong form of steady diffusion for a scalar field $T(\\mathbf{x})$ in a domain $\\Omega \\subset \\mathbb{R}^3$ with a symmetric positive definite conductivity tensor $\\mathbf{A}(\\mathbf{x})$, given by $-\\nabla \\cdot (\\mathbf{A} \\nabla T) = 0$. The Galerkin weak form is: find $T \\in V$ such that for all test functions $v \\in V_0$,\n$$\na(T,v) = \\int_{\\Omega} (\\nabla v)^{\\top} \\mathbf{A}(\\mathbf{x}) \\nabla T \\, d\\mathbf{x} = 0,\n$$\nwhere $V$ is an appropriate Sobolev space and $V_0$ accounts for Dirichlet boundary conditions. The bilinear form $a(\\cdot,\\cdot)$ is symmetric because $\\mathbf{A}(\\mathbf{x})$ is symmetric positive definite. In an isoparametric trilinear hexahedral element, the mapping $\\mathbf{x}(\\boldsymbol{\\xi})$ from the reference element $\\hat{K} = [-1,1]^3$ to the physical element $K$ is defined by the same shape functions as the solution interpolation. Denote by $\\mathbf{J} = \\partial \\mathbf{x}/\\partial \\boldsymbol{\\xi}$ the Jacobian of the mapping. The gradient of a shape function $N_i$ in physical coordinates is obtained by the Piola transformation $\\nabla_{\\mathbf{x}} N_i = \\mathbf{J}^{-T} \\nabla_{\\boldsymbol{\\xi}} N_i$. With exact quadrature and consistent mapping, the element stiffness tensor is\n$$\n\\mathbf{K}^{(e)} = \\int_{\\hat{K}} \\mathbf{B}(\\boldsymbol{\\xi})^{\\top} \\mathbf{A}(\\mathbf{x}(\\boldsymbol{\\xi})) \\, \\mathbf{B}(\\boldsymbol{\\xi}) \\, \\det(\\mathbf{J}(\\boldsymbol{\\xi})) \\, d\\boldsymbol{\\xi},\n$$\nwhere $\\mathbf{B}(\\boldsymbol{\\xi})$ has as its columns the physical gradients of the shape functions. This expression is symmetric by construction. However, in practice, non-affine mappings and implementation inconsistencies can produce element stiffness tensors that are not symmetric when an incorrect pullback is used on one of the gradient factors during assembly.\n\nYour task is to implement a program that:\n- Constructs element stiffness matrices for trilinear hexahedra using Gaussian quadrature and an anisotropic, symmetric positive definite conductivity tensor.\n- Demonstrates that for an affine mapping and consistent use of $\\mathbf{J}^{-1}$ in the gradient transformation, the assembled stiffness matrix is symmetric.\n- Demonstrates that for a distorted (non-affine) mapping, if one incorrectly applies $\\mathbf{J}^{-T}$ to the left gradient factor and $\\mathbf{J}^{-1}$ to the right gradient factor in the element integrand, the resulting element stiffness matrix is non-symmetric.\n- Detects and quantifies the asymmetry by computing the Frobenius norm of the skew-symmetric part.\n- Corrects the asymmetry at the global level by replacing $\\mathbf{K}$ with $\\tfrac{1}{2}(\\mathbf{K} + \\mathbf{K}^{\\top})$ and verifies symmetry after correction.\n- Verifies positive definiteness of the corrected, Dirichlet-reduced global matrix for a specified set of Dirichlet nodes.\n\nUse the following fundamental bases and facts:\n- The symmetric positive definiteness of $\\mathbf{A}$ implies that the continuous bilinear form $a(\\cdot,\\cdot)$ is symmetric and coercive under appropriate boundary conditions.\n- In an isoparametric element with mapping $\\mathbf{x}(\\boldsymbol{\\xi})$, the correct pullback of gradients is $\\nabla_{\\mathbf{x}} N = \\mathbf{J}^{-T} \\nabla_{\\boldsymbol{\\xi}} N$, which, when implemented consistently in both left and right gradient factors of the element integrand, yields a symmetric element tensor.\n- The Gaussian quadrature rule with $2\\times 2\\times 2$ points is sufficient to integrate the trilinear hexahedral element stiffness exactly when $\\mathbf{A}$ is constant within the element and the mapping is affine. For non-affine trilinear mappings, it provides a standard consistent approximation.\n\nDefine the anisotropic conductivity tensor as constant within each element and given by\n$$\n\\mathbf{A} = \\mathbf{R} \\, \\mathrm{diag}(k_1,k_2,k_3) \\, \\mathbf{R}^{\\top},\n$$\nwith $k_1 = 6.0$, $k_2 = 1.0$, $k_3 = 0.5$. The rotation $\\mathbf{R}$ is the composition $\\mathbf{R} = \\mathbf{R}_z(\\theta_z)\\mathbf{R}_y(\\theta_y)\\mathbf{R}_x(\\theta_x)$, using angles $\\theta_x = -0.2$, $\\theta_y = 0.5$, $\\theta_z = 0.3$ in radians.\n\nUse trilinear shape functions on the reference hexahedron with the standard node ordering corresponding to the corners at $(\\xi_i,\\eta_i,\\zeta_i) \\in \\{-1,1\\}^3$:\n- $(\\xi_1,\\eta_1,\\zeta_1) = (-1,-1,-1)$,\n- $(\\xi_2,\\eta_2,\\zeta_2) = (1,-1,-1)$,\n- $(\\xi_3,\\eta_3,\\zeta_3) = (1,1,-1)$,\n- $(\\xi_4,\\eta_4,\\zeta_4) = (-1,1,-1)$,\n- $(\\xi_5,\\eta_5,\\zeta_5) = (-1,-1,1)$,\n- $(\\xi_6,\\eta_6,\\zeta_6) = (1,-1,1)$,\n- $(\\xi_7,\\eta_7,\\zeta_7) = (1,1,1)$,\n- $(\\xi_8,\\eta_8,\\zeta_8) = (-1,1,1)$.\n\nAdopt the $2\\times 2\\times 2$ Gauss quadrature with abscissae $\\pm 1/\\sqrt{3}$ and weights $1$ in each direction.\n\nTest suite. You must implement and evaluate the following three test cases and one verification:\n\n- Case A (baseline affine, consistent):\n  - Physical node coordinates for a single element (unit cube):\n    - $\\mathbf{X}_1 = (0,0,0)$, $\\mathbf{X}_2 = (1,0,0)$, $\\mathbf{X}_3 = (1,1,0)$, $\\mathbf{X}_4 = (0,1,0)$,\n    - $\\mathbf{X}_5 = (0,0,1)$, $\\mathbf{X}_6 = (1,0,1)$, $\\mathbf{X}_7 = (1,1,1)$, $\\mathbf{X}_8 = (0,1,1)$.\n  - Assemble the element stiffness with the correct gradient pullback on both sides of the integrand. Assemble globally (single element) and compute the Frobenius norm\n    $$\n    s_A = \\left\\| \\mathbf{K} - \\mathbf{K}^{\\top} \\right\\|_F.\n    $$\n    Return $s_A$ as a floating-point number.\n\n- Case B (distorted mapping, broken assembly to induce asymmetry):\n  - Physical node coordinates for a single distorted element:\n    - $\\mathbf{X}_1 = (0,0,0)$, $\\mathbf{X}_2 = (1,0,0)$, $\\mathbf{X}_3 = (1,1.02,0)$, $\\mathbf{X}_4 = (0,1,0)$,\n    - $\\mathbf{X}_5 = (0,0,1)$, $\\mathbf{X}_6 = (1.03,0,1)$, $\\mathbf{X}_7 = (1.05,0.95,1.02)$, $\\mathbf{X}_8 = (0,1.01,1)$.\n  - Assemble the element stiffness using an inconsistent integrand of the form\n    $$\n    \\tilde{\\mathbf{K}}^{(e)} = \\int_{\\hat{K}} \\tilde{\\mathbf{B}}(\\boldsymbol{\\xi})^{\\top} \\mathbf{A} \\, \\mathbf{B}(\\boldsymbol{\\xi}) \\, \\det(\\mathbf{J}(\\boldsymbol{\\xi})) \\, d\\boldsymbol{\\xi},\n    $$\n    where $\\mathbf{B}$ uses the correct pullback $\\nabla_{\\mathbf{x}} N = \\mathbf{J}^{-T}\\nabla_{\\boldsymbol{\\xi}} N$ and $\\tilde{\\mathbf{B}}$ uses the incorrect pullback $\\nabla_{\\mathbf{x}} N = \\mathbf{J}^{-1}\\nabla_{\\boldsymbol{\\xi}} N$ applied to the left gradient factor. Assemble globally (single element) and compute\n    $$\n    s_B = \\left\\| \\tilde{\\mathbf{K}} - \\tilde{\\mathbf{K}}^{\\top} \\right\\|_F.\n    $$\n    Return $s_B$ as a floating-point number.\n\n- Case C (symmetry correction):\n  - From Case B, define the corrected global stiffness as\n    $$\n    \\mathbf{K}_{\\mathrm{corr}} = \\tfrac{1}{2}\\left(\\tilde{\\mathbf{K}} + \\tilde{\\mathbf{K}}^{\\top}\\right).\n    $$\n  - Compute\n    $$\n    s_C = \\left\\| \\mathbf{K}_{\\mathrm{corr}} - \\mathbf{K}_{\\mathrm{corr}}^{\\top} \\right\\|_F.\n    $$\n    Return $s_C$ as a floating-point number.\n\n- Verification D (positive definiteness under Dirichlet reduction):\n  - Impose homogeneous Dirichlet conditions on the face with minimal $x$-coordinate nodes of the distorted element from Case B, that is, all nodes $\\mathbf{X}_i$ with $x_i = \\min_j x_j$.\n  - Extract the free-free submatrix $\\mathbf{K}_{\\mathrm{ff}}$ from $\\mathbf{K}_{\\mathrm{corr}}$ corresponding to the remaining unconstrained nodes.\n  - Determine whether all eigenvalues of $\\mathbf{K}_{\\mathrm{ff}}$ are strictly positive (greater than a numerical tolerance of $10^{-10}$), and return a boolean value $b_D$ that is true if and only if $\\mathbf{K}_{\\mathrm{ff}}$ is positive definite.\n\nNumerical and implementation requirements:\n- All computations are dimensionless; do not include physical units in the output.\n- Implement trilinear shape functions and their derivatives on the reference element. Use the isoparametric mapping $\\mathbf{x}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{8} N_i(\\boldsymbol{\\xi}) \\, \\mathbf{X}_i$ and $\\mathbf{J} = \\sum_{i=1}^{8} \\mathbf{X}_i \\, (\\nabla_{\\boldsymbol{\\xi}} N_i)^{\\top}$ at quadrature points.\n- Use the Gaussian quadrature points at $\\xi,\\eta,\\zeta \\in \\{-1/\\sqrt{3}, 1/\\sqrt{3}\\}$, with weights $1$.\n- For symmetry detection, use the Frobenius norm $\\| \\cdot \\|_F$.\n- For positive definiteness, use dense eigenvalue computation of $\\mathbf{K}_{\\mathrm{ff}}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[s_A, s_B, s_C, b_D]$. The first three entries must be floating-point numbers, and the fourth entry must be a boolean literal. For example, a valid output would look like $[0.0,0.1234,0.0,True]$.",
            "solution": "We begin from the strong form $-\\nabla \\cdot (\\mathbf{A} \\nabla T) = 0$ with symmetric positive definite $\\mathbf{A}$. The standard Galerkin weak form over $\\Omega$ is $a(T,v) = \\int_{\\Omega} (\\nabla v)^{\\top} \\mathbf{A} \\, \\nabla T \\, d\\mathbf{x}$. Because $\\mathbf{A}$ is symmetric positive definite and the gradient is linear, the bilinear form $a(\\cdot,\\cdot)$ is symmetric. This implies that, when discretized consistently, the global stiffness matrix $\\mathbf{K}$ assembled from element contributions should be symmetric: $\\mathbf{K} = \\mathbf{K}^{\\top}$.\n\nFor trilinear isoparametric hexahedra, we map the reference element $\\hat{K} = [-1,1]^3$ to a physical element $K$ using the same shape functions $N_i(\\boldsymbol{\\xi})$ to interpolate the node coordinates: $\\mathbf{x}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{8} N_i(\\boldsymbol{\\xi}) \\mathbf{X}_i$. The Jacobian matrix is $\\mathbf{J}(\\boldsymbol{\\xi}) = \\frac{\\partial \\mathbf{x}}{\\partial \\boldsymbol{\\xi}} = \\sum_{i=1}^{8} \\mathbf{X}_i (\\nabla_{\\boldsymbol{\\xi}} N_i(\\boldsymbol{\\xi}))^{\\top}$. The correct physical gradients of shape functions are obtained via the Piola transformation $\\nabla_{\\mathbf{x}} N_i = \\mathbf{J}^{-T} \\nabla_{\\boldsymbol{\\xi}} N_i$, or, equivalently for row vectors, $(\\nabla_{\\mathbf{x}} N_i)^{\\top} = \\mathbf{J}^{-1} (\\nabla_{\\boldsymbol{\\xi}} N_i)^{\\top}$.\n\nThe consistent element stiffness is\n$$\n\\mathbf{K}^{(e)} = \\int_{\\hat{K}} \\mathbf{B}(\\boldsymbol{\\xi})^{\\top} \\, \\mathbf{A} \\, \\mathbf{B}(\\boldsymbol{\\xi}) \\, \\det(\\mathbf{J}(\\boldsymbol{\\xi})) \\, d\\boldsymbol{\\xi},\n$$\nwhich is symmetric because it is of the form $\\int \\mathbf{C}^{\\top} \\mathbf{A} \\mathbf{C} \\, dV$ with $\\mathbf{A} = \\mathbf{A}^{\\top}$.\n\nIn practice, non-symmetry can arise if the gradient pullback is applied inconsistently to the two factors of the bilinear form when evaluated numerically. An example of such an inconsistency is to compute the left gradient factor using $\\mathbf{J}^{-1}$ (incorrect for column-vector gradients) and the right gradient factor using $\\mathbf{J}^{-T}$ (correct). This yields an element-level integrand of the form $\\tilde{\\mathbf{B}}^{\\top} \\mathbf{A} \\mathbf{B}$, where $\\tilde{\\mathbf{B}} \\neq \\mathbf{B}$, which does not produce a symmetric tensor in general because $(\\tilde{\\mathbf{B}}^{\\top} \\mathbf{A} \\mathbf{B})^{\\top} = \\mathbf{B}^{\\top} \\mathbf{A} \\tilde{\\mathbf{B}} \\neq \\tilde{\\mathbf{B}}^{\\top} \\mathbf{A} \\mathbf{B}$ unless $\\tilde{\\mathbf{B}} = \\mathbf{B}$.\n\nAlgorithmic design:\n- Implement the trilinear shape functions $N_i(\\xi,\\eta,\\zeta) = \\tfrac{1}{8} (1+\\xi \\xi_i)(1+\\eta \\eta_i)(1+\\zeta \\zeta_i)$ and their reference gradients $\\nabla_{\\boldsymbol{\\xi}} N_i$ using the standard node signs $(\\xi_i,\\eta_i,\\zeta_i) \\in \\{-1,1\\}^3$.\n- For a given set of physical node coordinates $\\{\\mathbf{X}_i\\}_{i=1}^8$, compute $\\mathbf{J}$ and $\\det(\\mathbf{J})$ at each Gauss point $(\\xi,\\eta,\\zeta)$ with weights $w=1$. Check that $\\det(\\mathbf{J})>0$ to avoid inverted elements.\n- Compute two versions of the gradient matrices:\n  - Consistent: $\\mathbf{B}$ has columns $\\nabla_{\\mathbf{x}} N_i = (\\nabla_{\\boldsymbol{\\xi}} N_i)^{\\top} \\mathbf{J}^{-T}$ or row-wise $\\nabla_{\\mathbf{x}} N_i = \\nabla_{\\boldsymbol{\\xi}} N_i \\, \\mathbf{J}^{-1}$.\n  - Broken: $\\tilde{\\mathbf{B}}$ is computed by incorrectly using $\\nabla_{\\mathbf{x}} N_i = \\nabla_{\\boldsymbol{\\xi}} N_i \\, \\mathbf{J}^{-T}$ for the left factor, while the right factor uses the correct $\\mathbf{B}$.\n- Evaluate the element matrices by Gaussian quadrature:\n  - Consistent element: $\\mathbf{K}^{(e)} \\approx \\sum_{q} w_q \\, \\det(\\mathbf{J}_q) \\, \\mathbf{B}_q^{\\top} \\, \\mathbf{A} \\, \\mathbf{B}_q$.\n  - Broken element: $\\tilde{\\mathbf{K}}^{(e)} \\approx \\sum_{q} w_q \\, \\det(\\mathbf{J}_q) \\, \\tilde{\\mathbf{B}}_q^{\\top} \\, \\mathbf{A} \\, \\mathbf{B}_q$.\n- Assemble globally by summing the element contributions. With one element, the global matrix equals the element matrix.\n- Detect asymmetry by computing the Frobenius norm of the skew-symmetric part: $s = \\|\\mathbf{K} - \\mathbf{K}^{\\top}\\|_F$.\n- Correct asymmetry by symmetrization: $\\mathbf{K}_{\\mathrm{corr}} = \\tfrac{1}{2}(\\mathbf{K} + \\mathbf{K}^{\\top})$ and recompute the asymmetry measure $s_C$.\n- For the positive definiteness check, apply homogeneous Dirichlet conditions on all nodes whose $x$-coordinate equals the minimum $x$ among the element nodes (the plane $x = \\min_i x_i$). Extract the free-free submatrix $\\mathbf{K}_{\\mathrm{ff}}$ from $\\mathbf{K}_{\\mathrm{corr}}$ and compute its eigenvalues. If $\\min \\lambda(\\mathbf{K}_{\\mathrm{ff}}) > 10^{-10}$, report true; otherwise, false.\n\nJustification of tests:\n- Case A uses an affine mapping and consistent gradient pullback. Because $\\mathbf{B}$ is computed consistently, each integrand $\\mathbf{B}^{\\top} \\mathbf{A} \\mathbf{B}$ is symmetric, so $s_A$ should be on the order of roundoff, demonstrating a correct symmetric assembly.\n- Case B uses a distorted mapping and the broken left-right gradient application, so $s_B$ should be significantly larger than roundoff, demonstrating detectable asymmetry due to inconsistent implementation.\n- Case C corrects the asymmetry by projection onto the symmetric part, so $s_C$ should be near zero (roundoff), restoring the expected symmetry of the diffusion operator.\n- Verification D demonstrates that, after correction and with appropriate Dirichlet reduction, the matrix is not only symmetric but also positive definite, consistent with the coercivity of the bilinear form under Dirichlet boundary conditions.\n\nThe anisotropic conductivity tensor is constructed as $\\mathbf{A} = \\mathbf{R} \\, \\mathrm{diag}(6.0, 1.0, 0.5) \\, \\mathbf{R}^{\\top}$ where $\\mathbf{R}$ is the rotation about the $x$-, $y$-, and $z$-axes by angles $-0.2$, $0.5$, and $0.3$ radians, respectively. This ensures a non-trivial, rotated anisotropy typical of mantle fabrics.\n\nThe program should output a single line in the format $[s_A,s_B,s_C,b_D]$ as specified, with the first three entries being floating-point numbers and the last a boolean literal.",
            "answer": "```python\nimport numpy as np\n\ndef rotation_matrix_xyz(theta_x, theta_y, theta_z):\n    cx, sx = np.cos(theta_x), np.sin(theta_x)\n    cy, sy = np.cos(theta_y), np.sin(theta_y)\n    cz, sz = np.cos(theta_z), np.sin(theta_z)\n    Rx = np.array([[1.0, 0.0, 0.0],\n                   [0.0, cx, -sx],\n                   [0.0, sx, cx]])\n    Ry = np.array([[cy, 0.0, sy],\n                   [0.0, 1.0, 0.0],\n                   [-sy, 0.0, cy]])\n    Rz = np.array([[cz, -sz, 0.0],\n                   [sz, cz, 0.0],\n                   [0.0, 0.0, 1.0]])\n    # Composition R = Rz * Ry * Rx\n    return Rz @ Ry @ Rx\n\ndef quad_points_2x2x2():\n    g = 1.0/np.sqrt(3.0)\n    pts = []\n    for xi in (-g, g):\n        for eta in (-g, g):\n            for zeta in (-g, g):\n                pts.append((xi, eta, zeta, 1.0))\n    return pts\n\ndef shape_functions_Q1_and_grads(xi, eta, zeta):\n    # Node signs for reference hexahedron\n    signs = np.array([\n        [-1, -1, -1],\n        [ 1, -1, -1],\n        [ 1,  1, -1],\n        [-1,  1, -1],\n        [-1, -1,  1],\n        [ 1, -1,  1],\n        [ 1,  1,  1],\n        [-1,  1,  1],\n    ], dtype=float)\n    N = np.zeros(8, dtype=float)\n    dN_dxi = np.zeros((8, 3), dtype=float)\n    for i in range(8):\n        sx, sy, sz = signs[i]\n        N[i] = 0.125 * (1 + sx*xi) * (1 + sy*eta) * (1 + sz*zeta)\n        dN_dxi[i, 0] = 0.125 * sx * (1 + sy*eta) * (1 + sz*zeta)\n        dN_dxi[i, 1] = 0.125 * sy * (1 + sx*xi) * (1 + sz*zeta)\n        dN_dxi[i, 2] = 0.125 * sz * (1 + sx*xi) * (1 + sy*eta)\n    return N, dN_dxi\n\ndef jacobian_and_grads(phys_nodes, dN_dxi):\n    # phys_nodes: (8,3), dN_dxi: (8,3)\n    # J = X^T * dN_dxi\n    J = phys_nodes.T @ dN_dxi  # (3,8) @ (8,3) -> (3,3)\n    detJ = np.linalg.det(J)\n    invJ = np.linalg.inv(J)\n    # Correct physical gradients: grad_x N = dN_dxi @ invJ\n    dN_dx_correct = dN_dxi @ invJ\n    # Wrong/incorrect physical gradients for left factor: using invJ.T\n    dN_dx_wrong = dN_dxi @ invJ.T\n    return J, detJ, dN_dx_correct, dN_dx_wrong\n\ndef element_stiffness(phys_nodes, A, mode=\"consistent\"):\n    # mode: \"consistent\" -> K = sum B^T A B\n    #       \"broken\"     -> K = sum B_wrong^T A B_right (asymmetric)\n    K = np.zeros((8,8), dtype=float)\n    for xi, eta, zeta, w in quad_points_2x2x2():\n        N, dN_dxi = shape_functions_Q1_and_grads(xi, eta, zeta)\n        J, detJ, dN_dx_correct, dN_dx_wrong = jacobian_and_grads(phys_nodes, dN_dxi)\n        if detJ <= 0:\n            raise ValueError(\"Non-positive Jacobian determinant encountered.\")\n        # Build B matrices: 3x8 with columns grad N_i\n        B_right = dN_dx_correct.T  # shape (3,8)\n        if mode == \"consistent\":\n            integrand = B_right.T @ A @ B_right  # (8,3)(3,3)(3,8) -> (8,8), symmetric\n        elif mode == \"broken\":\n            B_left_wrong = dN_dx_wrong.T  # (3,8)\n            integrand = B_left_wrong.T @ A @ B_right  # (8,3)(3,3)(3,8) -> (8,8), not symmetric\n        else:\n            raise ValueError(\"Unknown mode.\")\n        K += w * detJ * integrand\n    return K\n\ndef frobenius_norm(M):\n    return np.sqrt(np.sum(M*M))\n\ndef solve():\n    # Define anisotropic conductivity tensor A\n    R = rotation_matrix_xyz(theta_x=-0.2, theta_y=0.5, theta_z=0.3)\n    k = np.diag([6.0, 1.0, 0.5])\n    A = R @ k @ R.T\n\n    # Case A: affine unit cube\n    cube_nodes = np.array([\n        [0.0, 0.0, 0.0],  # X1\n        [1.0, 0.0, 0.0],  # X2\n        [1.0, 1.0, 0.0],  # X3\n        [0.0, 1.0, 0.0],  # X4\n        [0.0, 0.0, 1.0],  # X5\n        [1.0, 0.0, 1.0],  # X6\n        [1.0, 1.0, 1.0],  # X7\n        [0.0, 1.0, 1.0],  # X8\n    ], dtype=float)\n    K_A = element_stiffness(cube_nodes, A, mode=\"consistent\")\n    s_A = frobenius_norm(K_A - K_A.T)\n\n    # Case B: distorted element, broken assembly\n    distorted_nodes = np.array([\n        [0.0,   0.0,  0.0],   # X1\n        [1.0,   0.0,  0.0],   # X2\n        [1.0,   1.02, 0.0],   # X3\n        [0.0,   1.0,  0.0],   # X4\n        [0.0,   0.0,  1.0],   # X5\n        [1.03,  0.0,  1.0],   # X6\n        [1.05,  0.95, 1.02],  # X7\n        [0.0,   1.01, 1.0],   # X8\n    ], dtype=float)\n    K_B = element_stiffness(distorted_nodes, A, mode=\"broken\")\n    s_B = frobenius_norm(K_B - K_B.T)\n\n    # Case C: symmetrization correction\n    K_corr = 0.5 * (K_B + K_B.T)\n    s_C = frobenius_norm(K_corr - K_corr.T)\n\n    # Verification D: positive definiteness under Dirichlet reduction on min-x face\n    x_coords = distorted_nodes[:, 0]\n    xmin = np.min(x_coords)\n    dirichlet_nodes = np.where(np.abs(x_coords - xmin) < 1e-12)[0].tolist()\n    all_nodes = list(range(8))\n    free_nodes = [i for i in all_nodes if i not in dirichlet_nodes]\n    # Extract free-free block\n    if len(free_nodes) == 0:\n        # Degenerate case: no free nodes, treat as vacuously positive definite\n        b_D = True\n    else:\n        K_ff = K_corr[np.ix_(free_nodes, free_nodes)]\n        # Check symmetry just in case\n        K_ff = 0.5 * (K_ff + K_ff.T)\n        # Eigenvalues\n        eigvals = np.linalg.eigvalsh(K_ff)\n        b_D = bool(np.min(eigvals) > 1e-10)\n\n    results = [s_A, s_B, s_C, b_D]\n    # Final print statement in the exact required format.\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Assembling the global matrix for large-scale simulations requires managing computational resources, particularly memory, with great care. The locality of finite element basis functions ensures the global matrix is sparse, with a structure defined entirely by the mesh's element connectivity. This final practice bridges the gap between the mathematics of assembly and the logistics of high-performance computing, guiding you to develop an algorithm that predicts the matrix's sparsity pattern for efficient memory pre-allocation .",
            "id": "3600273",
            "problem": "You are tasked with designing an algorithm and implementing a runnable program to preallocate Compressed Sparse Row (CSR) storage for the global stiffness matrix arising from three-dimensional ($3$-D) high-order $Q_p$ finite elements on a structured hexahedral mesh, as used in computational geophysics. The objective is to compute the row-wise nonzero counts of the global matrix without constructing the entries themselves, and to justify the algorithmic complexity from first principles based on element overlap and basis function locality.\n\nStart from the following foundational base:\n\n- The Galerkin finite element method for a scalar, second-order elliptic operator (for example, $-\\nabla \\cdot (\\kappa \\nabla u) = f$ with appropriate boundary conditions) leads to a global sparse matrix where entries are obtained by summing element contributions. An entry between global degrees of freedom $I$ and $J$ is nonzero if and only if there exists at least one element on which the supports of the corresponding basis functions overlap and produce a nonzero bilinear form.\n- A nodal $Q_p$ element in three dimensions has $(p+1)^3$ local degrees of freedom per element, and the support of each basis function is restricted to the element containing its node.\n- In a structured mesh with $n_x$, $n_y$, and $n_z$ elements along the three coordinate directions, the global nodal grid has $N_x = n_x p + 1$, $N_y = n_y p + 1$, and $N_z = n_z p + 1$ nodes along the respective axes. Global node indices are triples $(i,j,k)$ with $i \\in \\{0,\\dots,N_x-1\\}$, $j \\in \\{0,\\dots,N_y-1\\}$, and $k \\in \\{0,\\dots,N_z-1\\}$.\n\nUsing only these bases, derive a formula for the number of nonzeros in each row of the global matrix associated with a global node $(i,j,k)$, expressed in terms of the number of incident elements in each coordinate direction. Conclude a closed-form expression in terms of $p$ and local incident-element multiplicities per direction. Then, design an algorithm that computes the CSR row-pointer array and the total number of nonzeros without explicitly building adjacency sets, by iterating over all global nodes and applying the derived formula. Justify the algorithmic complexity in $\\mathcal{O}$-notation as a function of $n_x$, $n_y$, $n_z$, and $p$.\n\nImplementation requirements:\n\n- You must implement a program that, for each test case, computes:\n    - the total number of nonzeros $nnz$ in the global matrix,\n    - the maximum row nonzero count,\n    - the minimum row nonzero count,\n    - a boolean consistency flag that is true if the closed-form row counts agree with a direct element-union enumeration on a fixed, deterministic sample of rows.\n- You must not construct the global matrix entries nor the full column index arrays; only preallocate counts and the CSR row-pointer lengths.\n\nTest suite:\n\nEvaluate your implementation on the following parameter sets $(n_x,n_y,n_z,p)$:\n\n- Case $1$: $(n_x,n_y,n_z,p) = (1,1,1,4)$.\n- Case $2$: $(n_x,n_y,n_z,p) = (2,2,2,3)$.\n- Case $3$: $(n_x,n_y,n_z,p) = (10,1,1,1)$.\n- Case $4$: $(n_x,n_y,n_z,p) = (3,2,1,5)$.\n\nOutput specification:\n\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list of lists, enclosed in square brackets. Each inner list must be of the form $[nnz,\\max\\_row,\\min\\_row,consistency]$, where $nnz$, $\\max\\_row$, and $\\min\\_row$ are integers and $consistency$ is a boolean. For example, the output format must be exactly like $[[nnz_1,\\max\\_1,\\min\\_1,consistency_1],[nnz_2,\\max\\_2,\\min\\_2,consistency_2],[nnz_3,\\max\\_3,\\min\\_3,consistency_3],[nnz_4,\\max\\_4,\\min\\_4,consistency_4]]$.\n\nThere are no physical units, angle units, or percentages involved in this task; all outputs are unitless integers or booleans. Your algorithm and program must be general and rely only on the principled derivation from basis-function locality and element overlap. In particular, your justification for the complexity must rest on the fact that a global degree of freedom $(i,j,k)$ couples to all degrees of freedom within the union of elements that contain $(i,j,k)$, and that the size of this union is governed by the overlap multiplicities per coordinate direction.",
            "solution": "The problem of preallocating storage for a sparse matrix in a Finite Element Method (FEM) simulation is a critical step for computational efficiency. We are tasked with determining the number of non-zero entries ($nnz$) per row of the global stiffness matrix for a three-dimensional problem discretized with $Q_p$ hexahedral elements on a structured grid. This allows for the construction of the Compressed Sparse Row (CSR) `row_pointer` array without assembling the matrix itself.\n\n### Foundational Principles\n\nThe global stiffness matrix $\\mathbf{K}$ in an FEM context is assembled from element-level stiffness matrices $\\mathbf{k}^e$. An entry $K_{IJ}$ in the global matrix, corresponding to global degrees of freedom (DoFs) $I$ and $J$, is non-zero if and only if the basis functions $\\phi_I$ and $\\phi_J$ associated with these DoFs have overlapping support and their interaction integral is non-zero. For standard nodal $Q_p$ elements, the support of a basis function $\\phi_I$ is the union of all elements that share the node $I$. The interaction integral, stemming from a second-order elliptic operator like the Laplacian, is non-zero if nodes $I$ and $J$ belong to at least one common element. Consequently, the set of DoFs coupled to DoF $I$ (i.e., the non-zero entries in row $I$) corresponds to the set of all unique DoFs contained within the union of elements incident to node $I$.\n\n### Derivation of Row Nonzero Count Formula\n\nLet the computational domain be discretized by a structured mesh of $n_x \\times n_y \\times n_z$ hexahedral elements. For $Q_p$ elements, where $p$ is the polynomial degree, there are $p+1$ nodes along each edge of an element. This results in a global grid of $N = N_x \\times N_y \\times N_z$ nodes, where $N_x = n_x p + 1$, $N_y = n_y p + 1$, and $N_z = n_z p + 1$. Each global node corresponds to a unique DoF, indexed by a triplet $(i, j, k)$ with $i \\in \\{0, \\dots, N_x-1\\}$, $j \\in \\{0, \\dots, N_y-1\\}$, and $k \\in \\{0, \\dots, N_z-1\\}$.\n\nThe number of non-zeros in the row corresponding to node $(i,j,k)$, denoted $R(i,j,k)$, is the total number of unique nodes in the patch of elements surrounding node $(i,j,k)$. The size and shape of this patch depend on the node's location relative to the element boundaries.\n\nA key insight is that due to the tensor-product nature of both the structured grid and the $Q_p$ basis functions, the problem decouples by coordinate direction. Let us define $m_x(i)$, $m_y(j)$, and $m_z(k)$ as the number of element \"layers\" the node $(i,j,k)$ is incident to in each respective direction.\n\n1.  **Multiplicity in one direction (e.g., x-direction):** A node with global x-index $i$ lies in the interior of an element block (along the x-axis) if its index is not a multiple of $p$. If $i$ is a multiple of $p$ (i.e., $i = q \\cdot p$ for some integer $q$) and it is not on the global domain boundary (i.e., $0 < i < N_x-1$), it lies on an interface between two adjacent elements.\n    - The x-indices of internal element interfaces are $\\{p, 2p, \\dots, (n_x-1)p\\}$.\n    - Thus, the multiplicity $m_x(i)$ is $2$ if $i$ is an internal interface index, and $1$ otherwise.\n    $$ m_x(i) = \\begin{cases} 2 & \\text{if } i \\in \\{p, 2p, \\dots, (n_x-1)p\\} \\\\ 1 & \\text{otherwise} \\end{cases} $$\n    Analogous definitions apply for $m_y(j)$ and $m_z(k)$ with respect to $n_y$, $p$ and $n_z$, $p$.\n\n2.  **Coupled Nodal Patch:** A node $(i,j,k)$ is incident to a patch of $m_x(i) \\times m_y(j) \\times m_z(k)$ elements. This patch forms a \"macro-element\". The total number of nodes in this macro-element determines the row count.\n\n3.  **Counting Nodes in the Patch:** In one dimension, a patch of $m_x(i)$ adjacent elements spans $m_x(i) \\cdot p + 1$ nodes. Extending this to three dimensions through the tensor-product structure, the total number of unique nodes in the patch of elements incident to node $(i,j,k)$ is the product of the number of nodes spanned in each direction.\n\nThis leads to the closed-form expression for the number of non-zeros in the row for node $(i,j,k)$:\n$$ R(i,j,k) = (m_x(i)p + 1) \\cdot (m_y(j)p + 1) \\cdot (m_z(k)p + 1) $$\n\nFor example, a node deep inside an element and not on any element boundary has $(m_x, m_y, m_z) = (1,1,1)$, giving $R=(p+1)^3$ non-zeros (all nodes of that single element). A node at the shared vertex of eight interior elements has $(m_x, m_y, m_z) = (2,2,2)$, giving $R=(2p+1)^3$ non-zeros. The formula correctly handles all cases, including nodes on the global domain boundary where the respective multiplicity is always $1$.\n\n### Algorithm Design and Complexity Analysis\n\nThe algorithm leverages the derived formula to compute the required metrics without building any explicit adjacency information.\n\n1.  **Initialization:** Given parameters $(n_x, n_y, n_z, p)$, calculate global node grid dimensions $N_x, N_y, N_z$. Pre-compute sets of interface indices for each direction for efficient lookup. Initialize `total_nnz`, `max_row_count`, and `min_row_count`.\n\n2.  **Iteration:** Loop over every global node $(i,j,k)$ from $(0,0,0)$ to $(N_x-1, N_y-1, N_z-1)$. In each iteration:\n    a. Determine the multiplicities $m_x(i)$, $m_y(j)$, $m_z(k)$ by checking if the indices $i,j,k$ fall into the pre-computed interface sets. This is an $\\mathcal{O}(1)$ operation.\n    b. Apply the formula to calculate the row's nonzero count, $R(i,j,k)$.\n    c. Add this count to `total_nnz` and update `max_row_count` and `min_row_count`.\n\n3.  **Consistency Check:** To validate the formula, a direct enumeration method is used on a fixed, deterministic sample of nodes. For a sample node $(i,j,k)$:\n    a. Identify the block of incident elements, which is of size $m_x(i) \\times m_y(j) \\times m_z(k)$.\n    b. Explicitly generate the set of all unique node indices contained within this block of elements.\n    c. The size of this set gives the `direct_count`.\n    d. Compare `direct_count` with the `formula_count`. If they do not match for any sample node, the consistency flag is set to `False`.\n\n4.  **Complexity Analysis:** The main computational effort lies in the triply nested loop over all global nodes. The total number of nodes is $N = N_x N_y N_z = (n_x p + 1)(n_y p + 1)(n_z p + 1)$. Inside the loop, all operations are $\\mathcal{O}(1)$. Therefore, the algorithm's time complexity is linear in the total number of degrees of freedom:\n    $$ \\mathcal{O}(N) = \\mathcal{O}((n_x p + 1)(n_y p + 1)(n_z p + 1)) $$\n    For large meshes where $n_x, n_y, n_z \\gg 1$, this simplifies to $\\mathcal{O}(n_x n_y n_z p^3)$. The consistency check is performed on a small, constant number of samples, and its complexity per sample, $\\mathcal{O}(p^3)$, does not alter the overall asymptotic complexity.\n\nThis approach provides an efficient and theoretically sound method for pre-allocating the CSR data structures required for the global stiffness matrix assembly.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main entry point to solve the problem for all specified test cases.\n    \"\"\"\n    test_cases = [\n        (1, 1, 1, 4),\n        (2, 2, 2, 3),\n        (10, 1, 1, 1),\n        (3, 2, 1, 5),\n    ]\n\n    case_results = []\n    for case in test_cases:\n        nnz, max_r, min_r, cons = solve_case(*case)\n        # Format each result as '[nnz,max_r,min_r,Consistency]'\n        case_results.append(f\"[{nnz},{max_r},{min_r},{cons}]\")\n\n    # Final output must be a single line in the specified format.\n    print(f\"[{','.join(case_results)}]\")\n\n\ndef solve_case(nx, ny, nz, p):\n    \"\"\"\n    Computes CSR pre-allocation data for a single set of parameters.\n\n    Args:\n        nx (int): Number of elements along the x-axis.\n        ny (int): Number of elements along the y-axis.\n        nz (int): Number of elements along the z-axis.\n        p (int): Polynomial degree of the Qp elements.\n\n    Returns:\n        tuple: (total_nnz, max_row_count, min_row_count, is_consistent)\n    \"\"\"\n    if p == 0:  # Gracefully handle Q0 elements, though problem implies p>=1\n        # For Q0, each element is typically one DoF. The global matrix would\n        # be diagonal if using a Discontinuous Galerkin method. Assuming\n        # cell-centered DoFs with no coupling for simplicity.\n        num_dof = nx * ny * nz\n        return num_dof, 1, 1, True\n\n    # Calculate global grid dimensions\n    Nx = nx * p + 1\n    Ny = ny * p + 1\n    Nz = nz * p + 1\n\n    # Define sets of interface indices for O(1) average time lookup\n    interfaces_x = {k * p for k in range(1, nx)}\n    interfaces_y = {k * p for k in range(1, ny)}\n    interfaces_z = {k * p for k in range(1, nz)}\n\n    total_nnz = 0\n    max_row_count = 0\n    # Initialize min_row_count to a value guaranteed to be larger than any possible count\n    min_row_count = (2 * p + 1)**3 + 1\n\n    # Main loop to compute metrics by iterating over all global nodes\n    for i in range(Nx):\n        for j in range(Ny):\n            for k in range(Nz):\n                # Determine multiplicities based on node position\n                m_x = 2 if i in interfaces_x else 1\n                m_y = 2 if j in interfaces_y else 1\n                m_z = 2 if k in interfaces_z else 1\n\n                # Calculate row nonzero count using the derived formula\n                row_nnz = (m_x * p + 1) * (m_y * p + 1) * (m_z * p + 1)\n\n                # Update aggregates\n                total_nnz += row_nnz\n                if row_nnz > max_row_count:\n                    max_row_count = row_nnz\n                if row_nnz < min_row_count:\n                    min_row_count = row_nnz\n    \n    # Perform consistency check\n    is_consistent = check_consistency(nx, ny, nz, p, interfaces_x, interfaces_y, interfaces_z)\n\n    return int(total_nnz), max_row_count, min_row_count, is_consistent\n\n\ndef check_consistency(nx, ny, nz, p, interfaces_x, interfaces_y, interfaces_z):\n    \"\"\"\n    Validates the formula against a direct element-union enumeration on a sample of nodes.\n    \"\"\"\n    Nx, Ny, Nz = nx * p + 1, ny * p + 1, nz * p + 1\n    \n    # Define a deterministic, fixed set of sample nodes to test\n    sample_nodes = {(0, 0, 0)}\n    # Add nodes near origin\n    sample_nodes.add((min(1, Nx - 1), 0, 0))\n    sample_nodes.add((0, min(1, Ny - 1), 0))\n    sample_nodes.add((0, 0, min(1, Nz - 1)))\n    # Add nodes on first internal interface\n    if nx > 1: sample_nodes.add((p, min(1, Ny - 1), 0))\n    if ny > 1: sample_nodes.add((min(1, Nx - 1), p, 0))\n    if nz > 1: sample_nodes.add((0, 0, p))\n    # Add nodes on interface intersections\n    if nx > 1 and ny > 1: sample_nodes.add((p, p, 0))\n    if nx > 1 and ny > 1 and nz > 1: sample_nodes.add((p, p, p))\n\n    for i, j, k in sample_nodes:\n        # Ensure sample node is within the grid dimensions\n        if not (i < Nx and j < Ny and k < Nz):\n            continue\n\n        # 1. Calculate count using the formula\n        m_x = 2 if i in interfaces_x else 1\n        m_y = 2 if j in interfaces_y else 1\n        m_z = 2 if k in interfaces_z else 1\n        formula_count = (m_x * p + 1) * (m_y * p + 1) * (m_z * p + 1)\n\n        # 2. Calculate count using direct element-union enumeration\n        # Find the starting element index of the patch of incident elements\n        ex_start = i // p - 1 if m_x == 2 else i // p\n        ey_start = j // p - 1 if m_y == 2 else j // p\n        ez_start = k // p - 1 if m_z == 2 else k // p\n\n        # Define the ranges of incident elements\n        ex_range = range(ex_start, ex_start + m_x)\n        ey_range = range(ey_start, ey_start + m_y)\n        ez_range = range(ez_start, ez_start + m_z)\n\n        # Build the union of all nodes from all incident elements\n        union_of_nodes = set()\n        for ex in ex_range:\n            for ey in ey_range:\n                for ez in ez_range:\n                    for inode in range(ex * p, (ex + 1) * p + 1):\n                        for jnode in range(ey * p, (ey + 1) * p + 1):\n                            for knode in range(ez * p, (ez + 1) * p + 1):\n                                union_of_nodes.add((inode, jnode, knode))\n        \n        direct_count = len(union_of_nodes)\n\n        if formula_count != direct_count:\n            return False\n\n    return True\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}