{
    "hands_on_practices": [
        {
            "introduction": "有限元方法的核心在于将控制微分方程的弱形式转化为一个代数方程组。此过程的第一步是推导单元刚度矩阵，它代表了离散化的微分算子。本练习将指导您完成这一基本推导，针对一维线性单元，从变分形式出发，计算出其刚度矩阵，为后续的全局系统组装奠定基础。",
            "id": "3595232",
            "problem": "考虑一个层状地质构造中沿水平坐标 $x$ 的一维稳态导热问题，该过程由能量守恒和傅里叶定律控制。在没有内部储热的稳态条件下，能量守恒意味着热传导通量的散度与体热源相平衡。将温度记为 $u(x)$，热导率记为 $a(x)$，则在区间 $\\Omega=[0,L]$ 上的强形式为\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right)=f(x),\n$$\n并附带在 $x=0$ 和 $x=L$ 处的合适边界条件。在有限元法 (FEM) 中，区域 $\\Omega$ 被划分为一个网格，其节点为 $x_0  x_1  \\dots  x_n = L$。考虑一个长度为 $h_e = x_{i+1}-x_i$ 的典型单元 $[x_i, x_{i+1}]$。若该单元上的热导率 $a(x)$ 为常数 $a_e$，请使用线性形函数推导其 $2 \\times 2$ 的单元刚度矩阵 $k_e$。",
            "solution": "该问题是适定的，具有科学依据，并包含获得唯一解所需的所有信息。这是有限元法 (FEM) 中关于二阶边值问题的一个标准练习。我将继续进行推导和计算。\n\n问题要求推导一维线性有限元的单元刚度矩阵 $k_e$。出发点是控制微分方程的弱形式，\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right)=f(x) \\quad \\text{for } x \\in [x_i, x_{i+1}]\n$$\n为了获得弱形式，我们将其乘以一个检验函数 $w(x)$ 并在单元域 $[x_i, x_{i+1}]$ 上积分：\n$$\n-\\int_{x_i}^{x_{i+1}} w(x) \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) dx = \\int_{x_i}^{x_{i+1}} w(x) f(x) dx\n$$\n对左侧应用分部积分，将一个导数从试探解 $u(x)$ 转移到检验函数 $w(x)$ 上：\n$$\n\\int_{x_i}^{x_{i+1}} a(x)\\frac{du}{dx}\\frac{dw}{dx} dx - \\left[ w(x) a(x) \\frac{du}{dx} \\right]_{x_i}^{x_{i+1}} = \\int_{x_i}^{x_{i+1}} w(x) f(x) dx\n$$\n重新整理得到局部弱形式：\n$$\n\\int_{x_i}^{x_{i+1}} a(x)\\frac{du}{dx}\\frac{dw}{dx} dx = \\int_{x_i}^{x_{i+1}} w(x) f(x) dx + \\left[ w(x) a(x) \\frac{du}{dx} \\right]_{x_i}^{x_{i+1}}\n$$\n左边的项是双线性形式，它产生了刚度矩阵。右侧包含载荷向量和边界通量项。\n\n在 Galerkin 有限元法中，试探解 $u(x)$ 由一个函数 $u_h(x)$ 近似，该函数来自一个由基函数张成的有限维空间，在这个单元上，这些基函数就是线性形函数 $N_1(x)$ 和 $N_2(x)$。该近似解写为节点值 $U_1$ 和 $U_2$（对应于节点 $x_i$ 和 $x_{i+1}$）的线性组合：\n$$\nu_h(x) = U_1 N_1(x) + U_2 N_2(x) = \\sum_{n=1}^{2} U_n N_n(x)\n$$\n检验函数 $w(x)$ 选自同一空间，因此我们设 $w(x) = N_m(x)$，其中 $m \\in \\{1, 2\\}$。在单元上，热导率假定为常数 $a(x) = a_e$。将这些代入双线性形式得到：\n$$\n\\int_{x_i}^{x_{i+1}} a_e \\frac{d}{dx}\\left( \\sum_{n=1}^{2} U_n N_n(x) \\right) \\frac{d N_m(x)}{dx} dx = \\sum_{n=1}^{2} \\left( \\int_{x_i}^{x_{i+1}} a_e \\frac{dN_m}{dx}(x) \\frac{dN_n}{dx}(x) dx \\right) U_n\n$$\n该表达式代表了系统 $k_e U_e$ 的第 $m$ 行，其中 $U_e$ 是节点未知量向量。因此，单元刚度矩阵 $k_e$ 的元素由积分给出：\n$$\n(k_e)_{mn} = \\int_{x_i}^{x_{i+1}} a_e \\frac{dN_m}{dx}(x) \\frac{dN_n}{dx}(x) dx\n$$\n我们现在来计算这些元素。\n\n首先，我们定义在长度为 $h_e = x_{i+1}-x_i$ 的区间 $[x_i, x_{i+1}]$ 上单元的线性形函数 $N_1(x)$ 和 $N_2(x)$。\n形函数 $N_1(x)$ 由条件 $N_1(x_i)=1$ 和 $N_1(x_{i+1})=0$ 定义。满足这些条件的唯一线性多项式是：\n$$\nN_1(x) = \\frac{x_{i+1} - x}{x_{i+1} - x_i} = \\frac{x_{i+1} - x}{h_e}\n$$\n形函数 $N_2(x)$ 由 $N_2(x_i)=0$ 和 $N_2(x_{i+1})=1$ 定义。这得到：\n$$\nN_2(x) = \\frac{x - x_i}{x_{i+1} - x_i} = \\frac{x - x_i}{h_e}\n$$\n\n接下来，我们计算形函数关于 $x$ 的导数：\n$$\n\\frac{dN_1}{dx} = \\frac{d}{dx} \\left( \\frac{x_{i+1} - x}{h_e} \\right) = -\\frac{1}{h_e}\n$$\n$$\n\\frac{dN_2}{dx} = \\frac{d}{dx} \\left( \\frac{x - x_i}{h_e} \\right) = \\frac{1}{h_e}\n$$\n这些导数在整个单元上是常数。\n\n现在我们可以计算 $2 \\times 2$ 刚度矩阵 $k_e$ 的四个元素。\n\n情况 1：$m=1, n=1$\n$$\n(k_e)_{11} = \\int_{x_i}^{x_{i+1}} a_e \\left(-\\frac{1}{h_e}\\right) \\left(-\\frac{1}{h_e}\\right) dx = \\int_{x_i}^{x_{i+1}} \\frac{a_e}{h_e^2} dx = \\frac{a_e}{h_e^2} [x]_{x_i}^{x_{i+1}} = \\frac{a_e}{h_e^2} (x_{i+1} - x_i) = \\frac{a_e}{h_e^2} h_e = \\frac{a_e}{h_e}\n$$\n\n情况 2：$m=1, n=2$\n$$\n(k_e)_{12} = \\int_{x_i}^{x_{i+1}} a_e \\left(-\\frac{1}{h_e}\\right) \\left(\\frac{1}{h_e}\\right) dx = \\int_{x_i}^{x_{i+1}} -\\frac{a_e}{h_e^2} dx = -\\frac{a_e}{h_e^2} [x]_{x_i}^{x_{i+1}} = -\\frac{a_e}{h_e^2} h_e = -\\frac{a_e}{h_e}\n$$\n\n情况 3：$m=2, n=1$\n由于被积函数的对称性，$(k_e)_{21} = (k_e)_{12}$。\n$$\n(k_e)_{21} = \\int_{x_i}^{x_{i+1}} a_e \\left(\\frac{1}{h_e}\\right) \\left(-\\frac{1}{h_e}\\right) dx = -\\frac{a_e}{h_e}\n$$\n\n情况 4：$m=2, n=2$\n$$\n(k_e)_{22} = \\int_{x_i}^{x_{i+1}} a_e \\left(\\frac{1}{h_e}\\right) \\left(\\frac{1}{h_e}\\right) dx = \\int_{x_i}^{x_{i+1}} \\frac{a_e}{h_e^2} dx = \\frac{a_e}{h_e^2} [x]_{x_i}^{x_{i+1}} = \\frac{a_e}{h_e^2} h_e = \\frac{a_e}{h_e}\n$$\n\n将这些元素组装成矩阵 $k_e$：\n$$\nk_e = \\begin{pmatrix} (k_e)_{11}   (k_e)_{12} \\\\ (k_e)_{21}   (k_e)_{22} \\end{pmatrix} = \\begin{pmatrix} \\frac{a_e}{h_e}   -\\frac{a_e}{h_e} \\\\ -\\frac{a_e}{h_e}   \\frac{a_e}{h_e} \\end{pmatrix}\n$$\n提出公因式 $\\frac{a_e}{h_e}$ 得到单元刚度矩阵的最终闭式表达式。\n$$\nk_e = \\frac{a_e}{h_e} \\begin{pmatrix} 1   -1 \\\\ -1   1 \\end{pmatrix}\n$$",
            "answer": "$$\n\\boxed{\\frac{a_e}{h_e} \\begin{pmatrix} 1   -1 \\\\ -1   1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在构建有限元方程组 $A\\mathbf{u}=b$ 时，载荷向量 $\\mathbf{b}$ 负责体现源项（如地壳中的热源）对系统的影响。本练习将重点关注如何计算内部节点的全局载荷向量分量，展示了当源项为分片常数时，相邻单元的贡献是如何在共享节点上进行累加的。通过这个计算，您可以深入理解源项在离散格式中的表达方式。",
            "id": "3595233",
            "problem": "在计算地球物理学背景下，考虑水平分层岩石圈中的稳态一维 ($1$D) 热传导问题，该问题由区间 $[0,L]$ 上的偏微分方程 (PDE) $-k\\,u''(x)=f(x)$ 控制，其中 $k>0$ 是常数热导率，$u(x)$ 是温度，$f(x)$ 是体积生热项。施加狄利克雷 (Dirichlet) 边界条件 $u(0)=T_0$ 和 $u(L)=T_L$，其中 $T_0$ 和 $T_L$ 为给定常数。用一个严格递增的网格 $0=x_0  x_1  \\dots  x_n=L$ 将区间离散化为 $n$ 个单元 $e_k=[x_{k-1}, x_k]$，其长度为 $h_k=x_k-x_{k-1}$。假设在每个单元 $e_k$ 上，热源 $f(x)$ 是一个常数 $f_k$。请推导与一个内部节点 $x_j$ (其中 $j \\in \\{1, \\dots, n-1\\}$) 关联的全局载荷向量分量 $F_j$ 的闭式表达式。",
            "solution": "问题陈述经过严格验证，确认有效。该问题具有科学依据，是适定的、客观的且自洽的，是有限元法应用中的一个标准问题。\n\n任务是推导与内部节点 $x_j$ 关联的全局载荷向量分量 $F_j$ 的闭式表达式，其中 $j \\in \\{1, \\dots, n-1\\}$。载荷向量分量由以下积分定义：\n$$\nF_j = \\int_0^L f(x) \\, \\phi_j(x) \\, \\mathrm{d}x\n$$\n此处，$f(x)$ 是分段常数热源项，而 $\\phi_j(x)$ 是与节点 $x_j$ 关联的分段线性节点基函数（或称“帽函数”）。\n\n节点基函数 $\\phi_j(x)$ 的一个性质是，它仅在与节点 $x_j$ 相邻的单元上非零。由于 $j$ 是一个内部节点索引，这些单元是 $e_j = [x_{j-1}, x_j]$ 和 $e_{j+1} = [x_j, x_{j+1}]$。在所有其他单元上，$\\phi_j(x)=0$。因此，用于计算 $F_j$ 的积分可以简化，其定义域可以限制在 $\\phi_j(x)$ 的支撑集上：\n$$\nF_j = \\int_{x_{j-1}}^{x_{j+1}} f(x) \\, \\phi_j(x) \\, \\mathrm{d}x\n$$\n这个积分可以分为两部分，对应 $\\phi_j(x)$ 支撑集中的每个单元：\n$$\nF_j = \\int_{x_{j-1}}^{x_j} f(x) \\, \\phi_j(x) \\, \\mathrm{d}x + \\int_{x_j}^{x_{j+1}} f(x) \\, \\phi_j(x) \\, \\mathrm{d}x\n$$\n问题陈述指出热源 $f(x)$ 是分段常数，使得对于 $x \\in e_k = [x_{k-1}, x_k]$ 有 $f(x)=f_k$。将此应用于我们的积分，我们得到：\n$$\nF_j = \\int_{x_{j-1}}^{x_j} f_j \\, \\phi_j(x) \\, \\mathrm{d}x + \\int_{x_j}^{x_{j+1}} f_{j+1} \\, \\phi_j(x) \\, \\mathrm{d}x\n$$\n由于 $f_j$ 和 $f_{j+1}$ 是常数，它们可以从积分中提出：\n$$\nF_j = f_j \\int_{x_{j-1}}^{x_j} \\phi_j(x) \\, \\mathrm{d}x + f_{j+1} \\int_{x_j}^{x_{j+1}} \\phi_j(x) \\, \\mathrm{d}x\n$$\n接下来，我们必须定义基函数 $\\phi_j(x)$ 在这两个单元上的解析表达式。\n基函数 $\\phi_j(x)$ 在每个单元上是线性的，并且满足 $\\phi_j(x_j)=1$ 和 $\\phi_j(x_i)=0$（对于 $i \\neq j$）。\n\n在单元 $e_j = [x_{j-1}, x_j]$ 上，函数 $\\phi_j(x)$ 从 $x_{j-1}$ 处的 $0$ 线性增加到 $x_j$ 处的 $1$。该线段的方程为：\n$$\n\\phi_j(x) = \\frac{x - x_{j-1}}{x_j - x_{j-1}} = \\frac{x - x_{j-1}}{h_j} \\quad \\text{for } x \\in [x_{j-1}, x_j]\n$$\n在单元 $e_{j+1} = [x_j, x_{j+1}]$ 上，函数 $\\phi_j(x)$ 从 $x_j$ 处的 $1$ 线性减小到 $x_{j+1}$ 处的 $0$。该线段的方程为：\n$$\n\\phi_j(x) = \\frac{x_{j+1} - x}{x_{j+1} - x_j} = \\frac{x_{j+1} - x}{h_{j+1}} \\quad \\text{for } x \\in [x_j, x_{j+1}]\n$$\n现在，我们将这些表达式代回积分中。\n\n对于第一个积分，在单元 $e_j$ 上：\n$$\n\\int_{x_{j-1}}^{x_j} \\phi_j(x) \\, \\mathrm{d}x = \\int_{x_{j-1}}^{x_j} \\frac{x - x_{j-1}}{h_j} \\, \\mathrm{d}x = \\frac{1}{h_j} \\left[ \\frac{(x - x_{j-1})^2}{2} \\right]_{x_{j-1}}^{x_j}\n$$\n在积分上下限处计算反导数的值：\n$$\n\\frac{1}{h_j} \\left( \\frac{(x_j - x_{j-1})^2}{2} - \\frac{(x_{j-1} - x_{j-1})^2}{2} \\right) = \\frac{1}{h_j} \\left( \\frac{h_j^2}{2} - 0 \\right) = \\frac{h_j}{2}\n$$\n对于第二个积分，在单元 $e_{j+1}$ 上：\n$$\n\\int_{x_j}^{x_{j+1}} \\phi_j(x) \\, \\mathrm{d}x = \\int_{x_j}^{x_{j+1}} \\frac{x_{j+1} - x}{h_{j+1}} \\, \\mathrm{d}x = \\frac{1}{h_{j+1}} \\left[ -\\frac{(x_{j+1} - x)^2}{2} \\right]_{x_j}^{x_{j+1}}\n$$\n在积分上下限处计算反导数的值：\n$$\n\\frac{1}{h_{j+1}} \\left( -\\frac{(x_{j+1} - x_{j+1})^2}{2} - \\left(-\\frac{(x_{j+1} - x_j)^2}{2}\\right) \\right) = \\frac{1}{h_{j+1}} \\left( 0 + \\frac{h_{j+1}^2}{2} \\right) = \\frac{h_{j+1}}{2}\n$$\n这些积分代表了构成帽函数 $\\phi_j(x)$ 的两个三角形的面积。\n\n最后，我们将这些结果代回到 $F_j$ 的表达式中：\n$$\nF_j = f_j \\left( \\frac{h_j}{2} \\right) + f_{j+1} \\left( \\frac{h_{j+1}}{2} \\right)\n$$\n合并各项，得到内部节点 $j$ 处载荷向量分量的所需闭式表达式：\n$$\nF_j = \\frac{1}{2} (f_j h_j + f_{j+1} h_{j+1})\n$$\n该表达式仅依赖于相邻单元的尺寸 $h_j$ 和 $h_{j+1}$，以及相应的分段常数源值 $f_j$ 和 $f_{j+1}$，正如问题陈述所要求。",
            "answer": "$$\n\\boxed{\\frac{f_j h_j + f_{j+1} h_{j+1}}{2}}\n$$"
        },
        {
            "introduction": "掌握了单元矩阵和向量的推导之后，我们便可以将这些构建模块整合起来，编写一个功能完备的有限元求解器。本实践是一个综合性的编程练习，您将实现一个支持线性和二次单元的一维求解器，并用它来研究一个关键的数值性质——离散最大值原理（DMP）。这个原理对于确保地球物理学中扩散问题（如热传导）解的物理真实性至关重要，通过本练习您将探索不同单元类型对该原理的影响。",
            "id": "3595268",
            "problem": "考虑区间 $[0,1]$ 上带有齐次Dirichlet边界条件的一维边值问题，其强形式为 $-(k(x)\\,u'(x))'=f(x)$，其中 $k(x)>0$ 几乎处处成立且 $f(x)\\ge 0$。其弱形式为：求解 $u\\in H_0^1(0,1)$，使得对于所有 $v\\in H_0^1(0,1)$，都有 $\\int_0^1 k(x)\\,u'(x)\\,v'(x)\\,dx=\\int_0^1 f(x)\\,v(x)\\,dx$ 成立。在计算地球物理学中，当模拟扩散过程（例如热传导、水头扩散）时，单调性和离散极值原理（DMP）非常重要。对于一维网格上的线性有限元，在网格和系数满足适当条件时，可以期望得到单调性。\n\n您的任务是实现一个完整的一维空间有限元求解器，该求解器支持次数为 $p\\in\\{1,2\\}$ 的连续分段多项式。您必须：\n\n- 假设 $k(x)$ 在每个单元上是分段常数，使用精确的单元公式，从双线性形式 $a(u,v)=\\int_0^1 k(x)\\,u'(x)\\,v'(x)\\,dx$ 组装全局刚度矩阵 $\\mathbf{A}$。\n- 对于分段常数的 $f(x)$，使用精确的单元公式；并在指定情况下，在单元的子区间上使用精确的解析积分，从线性泛函 $\\ell(v)=\\int_0^1 f(x)\\,v(x)\\,dx$ 组装全局载荷向量 $\\mathbf{b}$。\n- 通过从线性系统中移除边界自由度，来施加齐次Dirichlet边界条件 $u(0)=0$ 和 $u(1)=0$。\n\n在 $f(x)\\ge 0$ 和 $k(x)>0$ 的设定下，为离散极值原理（DMP）定义以下检查：\n\n1. 如果一个矩阵是对称正定的，并且其非对角元为非正数，则该矩阵是Stieltjes矩阵。检查 $\\mathbf{A}$ 是否对称、具有严格为正的对角元、是否为正定矩阵，以及其非对角元是否为非正数。在一维情况下，对于线性有限元，此条件足以保证节点解的单调性。\n2. 检查组装的载荷向量 $\\mathbf{b}$ 是否逐项非负。对于线性有限元（$p=1$），局部形函数在其支集上是非负的，这保证了当 $f(x)\\ge 0$ 时 $\\mathbf{b}$ 的非负性。对于二次有限元（$p=2$），局部形函数可能会变号，因此即使 $f(x)\\ge 0$，$\\mathbf{b}$ 也可能包含负值；这可能违反DMP。\n3. 求解 $\\mathbf{A}\\mathbf{u}=\\mathbf{b}$，并检查计算出的节点值向量 $\\mathbf{u}$（针对内部自由度）是否逐项非负。\n\n就本问题而言，我们定义：对于一个给定的情况，当且仅当上述所有三项检查都通过时，DMP才成立。\n\n实现以下测试用例集（所有网格均位于区间 $[0,1]$ 上）：\n\n- 用例 $\\mathrm{T1}$（分段线性元，均匀网格，常系数）：使用 $p=1$， $N=10$ 个单元，节点位于 $x_i=i/N$（$i=0,1,\\dots,N$），设 $k(x)\\equiv 1$ 且 $f(x)\\equiv 1$。报告DMP是否成立。\n- 用例 $\\mathrm{T2}$（分段线性元，高度非均匀网格，强变系数）：使用 $p=1$，$N=7$ 个单元，节点为 $x=\\big[0,\\,0.01,\\,0.02,\\,0.05,\\,0.15,\\,0.40,\\,0.70,\\,1\\big]$，每个单元上的分段常系数为 $k_e=\\big[10,\\,0.1,\\,100,\\,0.2,\\,50,\\,1.5,\\,5\\big]$。设 $f(x)\\equiv 1$。报告DMP是否成立。\n- 用例 $\\mathrm{T3}$（分段二次单元，均匀网格，常系数）：使用 $p=2$，$N=6$ 个单元，节点位于 $x_i=i/N$（$i=0,1,\\dots,N$），设 $k(x)\\equiv 1$ 且 $f(x)\\equiv 1$。报告DMP是否成立。注意：$p=2$ 的全局刚度矩阵在某些顶点自由度之间具有正的非对角元，因此该矩阵不满足Stieltjes性质；因此，即使解恰好为非负，也应报告DMP不成立。\n- 用例 $\\mathrm{T4}$（分段二次单元，均匀网格，在子区间上的定向正强迫项）：使用 $p=2$，$N=4$ 个单元，节点位于 $x_i=i/N$（$i=0,1,\\dots,N$），设 $k(x)\\equiv 1$，并定义 $f(x)$ 仅在单元 $e=2$ 的右半部分（即在 $[x_2+\\tfrac{h}{2},x_3]$ 上，其中 $h=x_3-x_2$）为严格正，大小为 $C=100$，在其他地方为零。由于变号的二次基函数，这个 $f(x)\\ge 0$ 会在该单元的内部顶点节点处的载荷向量中产生一个负值，从而违反DMP。报告DMP是否成立。\n\n您的程序必须完全按照描述实现组装和检查。对于每个用例，输出一个布尔值，指示DMP是否成立。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是对应于相应案例的布尔值。",
            "solution": "该问题要求为区间 $[0,1]$ 上的边值问题 $-\\frac{d}{dx}(k(x)\\frac{du}{dx}) = f(x)$（带有齐次Dirichlet边界条件 $u(0)=u(1)=0$）实现一个一维有限元方法（FEM）求解器。该求解器必须支持连续分段线性（$p=1$）和分段二次（$p=2$）基函数。一个关键方面是验证四个指定测试用例的离散极值原理（DMP）。DMP被定义为当且仅当满足三个条件时成立：1）内部自由度的全局刚度矩阵是Stieltjes矩阵，2）组装的内部自由度全局载荷向量是逐项非负的，3）得到的数值解是逐项非负的。\n\n解决方案首先推导 $p=1$ 和 $p=2$ 单元的单元刚度矩阵和载荷向量。然后，描述组装过程、边界条件的施加以及DMP检查的实现。最后，根据这些原则分析每个测试用例。\n\n**有限元离散化与单元级计算**\n\n将域 $[0,1]$ 离散化为 $N$ 个单元。对于一个跨度为 $[x_e, x_{e+1}]$、长度为 $h_e = x_{e+1} - x_e$ 的单元 $e$，我们使用一个从参考单元 $\\hat{K} = [-1, 1]$ 到物理单元的映射。单元刚度矩阵的积分为 $A^e_{ij} = \\int_{x_e}^{x_{e+1}} k_e \\phi'_i(x) \\phi'_j(x) dx$，单元载荷向量为 $b^e_i = \\int_{x_e}^{x_{e+1}} f_e(x) \\phi_i(x) dx$。我们假设 $k(x) = k_e$ 在单元 $e$ 上是常数。\n\n**1. 分段线性元 ($p=1$)**\n一个单元有2个节点，每个端点一个。参考单元 $\\hat{K}$ 上的基函数是 $\\hat{\\phi}_1(\\xi) = \\frac{1-\\xi}{2}$ 和 $\\hat{\\phi}_2(\\xi) = \\frac{1+\\xi}{2}$。它们的导数是 $\\frac{d\\hat{\\phi}_1}{d\\xi} = -\\frac{1}{2}$ 和 $\\frac{d\\hat{\\phi}_2}{d\\xi} = \\frac{1}{2}$。\n\n通过将积分变换到参考单元来找到单元刚度矩阵：\n$$ A^e_{ij} = \\int_{-1}^{1} k_e \\left(\\frac{d\\hat{\\phi}_i}{d\\xi}\\frac{2}{h_e}\\right) \\left(\\frac{d\\hat{\\phi}_j}{d\\xi}\\frac{2}{h_e}\\right) \\frac{h_e}{2} d\\xi = \\frac{2k_e}{h_e} \\int_{-1}^{1} \\frac{d\\hat{\\phi}_i}{d\\xi} \\frac{d\\hat{\\phi}_j}{d\\xi} d\\xi $$\n计算该积分得到一维扩散问题的著名单元刚度矩阵：\n$$ \\mathbf{A}^e = \\frac{k_e}{h_e} \\begin{pmatrix} 1   -1 \\\\ -1   1 \\end{pmatrix} $$\n对于分段常数强迫函数 $f(x)=f_e$，单元载荷向量为：\n$$ b^e_i = \\int_{-1}^{1} f_e \\hat{\\phi}_i(\\xi) \\frac{h_e}{2} d\\xi $$\n这给出了单元载荷向量，它对应于积分的梯形法则：\n$$ \\mathbf{b}^e = f_e \\frac{h_e}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} $$\n\n**2. 分段二次单元 ($p=2$)**\n一个单元有3个节点：每个端点一个（顶点节点）和中点一个（内部节点）。在 $\\hat{K}$ 上对应于 $\\xi = -1, 0, 1$ 处节点的基函数是：\n- $\\hat{\\phi}_1(\\xi) = \\frac{\\xi(\\xi-1)}{2}$ (左顶点)\n- $\\hat{\\phi}_2(\\xi) = 1-\\xi^2$ (中点)\n- $\\hat{\\phi}_3(\\xi) = \\frac{\\xi(\\xi+1)}{2}$ (右顶点)\n它们的导数是 $\\frac{d\\hat{\\phi}_1}{d\\xi} = \\xi - \\frac{1}{2}$，$\\frac{d\\hat{\\phi}_2}{d\\xi} = -2\\xi$ 和 $\\frac{d\\hat{\\phi}_3}{d\\xi} = \\xi + \\frac{1}{2}$。\n使用与 $p=1$ 相同的变换计算出的单元刚度矩阵是：\n$$ \\mathbf{A}^e = \\frac{k_e}{3h_e} \\begin{pmatrix} 7   -8   1 \\\\ -8   16   -8 \\\\ 1   -8   7 \\end{pmatrix} $$\n注意正的非对角元 $A^e_{13} = A^e_{31} = \\frac{k_e}{3h_e}$。这些项连接相邻的顶点节点，并导致全局刚度矩阵不满足Stieltjes性质（非正非对角元）。\n\n对于常数强迫项 $f(x)=f_e$，单元载荷向量是：\n$$ \\mathbf{b}^e = f_e \\frac{h_e}{6} \\begin{pmatrix} 1 \\\\ 4 \\\\ 1 \\end{pmatrix} $$\n这对应于积分的辛普森法则。\n\n对于用例T4，强迫函数在单元 $e=2$ 的右半部分为 $f(x) = C = 100$，这对应于参考单元上的区间 $[\\xi_0, \\xi_1] = [0, 1]$。单元载荷向量计算为 $b^e_i = \\int_0^1 C \\hat{\\phi}_i(\\xi) \\frac{h_e}{2} d\\xi$。\n- 对于左顶点节点（$\\hat{\\phi}_1$）：$b^e_1 = C\\frac{h_e}{2} \\int_0^1 \\frac{\\xi(\\xi-1)}{2} d\\xi = C\\frac{h_e}{2} \\left(-\\frac{1}{12}\\right)$。由于 $C>0$ 且 $h_e>0$，该项为负。\n- 对于中点节点（$\\hat{\\phi}_2$）：$b^e_2 = C\\frac{h_e}{2} \\int_0^1 (1-\\xi^2) d\\xi = C\\frac{h_e}{2} \\left(\\frac{2}{3}\\right)$。\n- 对于右顶点节点（$\\hat{\\phi}_3$）：$b^e_3 = C\\frac{h_e}{2} \\int_0^1 \\frac{\\xi(\\xi+1)}{2} d\\xi = C\\frac{h_e}{2} \\left(\\frac{5}{12}\\right)$。\n$b^e_1$ 的负值表明，当使用在单元上并非处处非负的高阶基函数时，一个非负的强迫函数 $f(x) \\ge 0$ 如何能在载荷向量中产生一个负值项。\n\n**全局组装与边界条件**\n全局刚度矩阵 $\\mathbf{A}$ 和载荷向量 $\\mathbf{b}$ 是通过遍历每个单元，计算其局部矩阵 $\\mathbf{A}^e$ 和向量 $\\mathbf{b}^e$，并将其贡献加到相应的全局自由度（DoFs）上来构建的。\n对于 $p=1$，有 $N+1$ 个自由度，索引为 $0, \\dots, N$。对于 $p=2$，有 $2N+1$ 个自由度，索引为 $0, \\dots, 2N$。\n通过从全局系统中移除与边界自由度（第一个和最后一个）对应的行和列来施加齐次Dirichlet边界条件 $u(0)=0$ 和 $u(1)=0$。这将产生一个针对未知内部节点值 $\\mathbf{u}_{int}$ 的较小线性系统 $\\mathbf{A}_{int}\\mathbf{u}_{int} = \\mathbf{b}_{int}$。\n\n**DMP检查与测试用例分析**\n如果对内部系统的以下三项检查通过，则认为DMP成立：\n1.  **Stieltjes矩阵：** $\\mathbf{A}_{int}$ 是对称、正定，且具有非正的非对角元。\n2.  **非负载荷向量：** $\\mathbf{b}_{int}$ 的所有项都是非负的。\n3.  **非负解：** 解 $\\mathbf{u}_{int} = \\mathbf{A}_{int}^{-1}\\mathbf{b}_{int}$ 的所有项都是非负的。\n\n- **用例 T1 ($p=1$，均匀网格，常系数):**\n  1. 矩阵 $\\mathbf{A}_{int}$ 是一个三对角矩阵，其对角元为 $\\frac{2k}{h}$，非对角元为 $-\\frac{k}{h}$。它是对称的，对角占优且对角元为正（因此是正定的），并且具有非正的非对角元。**检查1通过。**\n  2. 载荷向量 $\\mathbf{b}_{int}$ 的项为 $f \\cdot h > 0$。**检查2通过。**\n  3. 由于 $\\mathbf{A}_{int}$ 是一个M-矩阵且 $\\mathbf{b}_{int}$ 是非负的，解 $\\mathbf{u}_{int} = \\mathbf{A}_{int}^{-1}\\mathbf{b}_{int}$ 保证是非负的。**检查3通过。**\n  **T1的结果：DMP成立 (True)。**\n\n- **用例 T2 ($p=1$，非均匀网格，变系数):**\n  1. 与T1类似，$\\mathbf{A}_{int}$ 是三对角的。对角元为 $(\\frac{k_{i-1}}{h_{i-1}} + \\frac{k_i}{h_i})>0$，非对角元为 $-\\frac{k_i}{h_i}0$。该矩阵是对称、正定的，并具有非正的非对角元。**检查1通过。**\n  2. 载荷向量的项为 $f \\frac{h_{i-1}+h_i}{2} > 0$。**检查2通过。**\n  3. T1的论证同样适用。**检查3通过。**\n  **T2的结果：DMP成立 (True)。**\n\n- **用例 T3 ($p=2$，均匀网格，常系数):**\n  1. 含有正非对角元的 $\\mathbf{A}^e$ 矩阵的组装，会产生一个全局矩阵 $\\mathbf{A}_{int}$，该矩阵在连接相邻顶点的自由度之间具有正的非对角元。例如，耦合顶点节点 $x_i$ 和顶点节点 $x_{i+1}$ 的项是正的。因此，$\\mathbf{A}_{int}$ 不是Stieltjes矩阵。**检查1失败。**\n  根据问题定义，若有任何检查失败，则DMP不成立。\n  **T3的结果：DMP不成立 (False)。**\n\n- **用例 T4 ($p=2$，特殊强迫项):**\n  1. 与T3一样，刚度矩阵 $\\mathbf{A}_{int}$ 不是Stieltjes矩阵。**检查1失败。**\n  2. 如上所述，在单元 $e=2$ 右半部分为正的强迫函数 $f(x)>0$ 会在该单元左顶点对应的节点（$x_2=0.5$）处的局部载荷向量 $\\mathbf{b}^e$ 中产生一个负值项。由于在前一个单元上 $f(x)=0$，这个负贡献不会被抵消，因此 $\\mathbf{b}_{int}$ 中的相应项变为负值。**检查2失败。**\n  由于多项检查失败，DMP不成立。\n  **T4的结果：DMP不成立 (False)。**\n\n最终输出是T1、T2、T3和T4的布尔结果列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(p, N, nodes, k_vals, f_type, f_params):\n    \"\"\"\n    Assembles and solves a 1D FEM problem, then performs DMP checks.\n\n    Args:\n        p (int): Polynomial degree (1 or 2).\n        N (int): Number of elements.\n        nodes (np.ndarray): Array of node coordinates.\n        k_vals (list or np.ndarray): Piecewise constant k values for each element.\n        f_type (str): Type of forcing function ('const' or 'special').\n        f_params (dict): Parameters for the forcing function.\n\n    Returns:\n        bool: True if DMP holds, False otherwise.\n    \"\"\"\n    # 1. Setup based on polynomial degree\n    if p == 1:\n        num_dofs = N + 1\n        interior_dof_indices = slice(1, N)\n    elif p == 2:\n        num_dofs = 2 * N + 1\n        interior_dof_indices = slice(1, 2 * N)\n    else:\n        raise ValueError(\"Polynomial degree p must be 1 or 2.\")\n\n    A = np.zeros((num_dofs, num_dofs))\n    b = np.zeros(num_dofs)\n\n    # 2. Assembly loop over elements\n    for e in range(N):\n        x_left = nodes[e]\n        x_right = nodes[e+1]\n        h = x_right - x_left\n        k_e = k_vals[e]\n\n        if p == 1:\n            # Element stiffness matrix for p=1\n            A_e = (k_e / h) * np.array([[1, -1], [-1, 1]])\n            \n            # Element load vector for p=1\n            f_e_val = 0.0\n            if f_type == 'const':\n                f_e_val = f_params['val']\n            b_e = (f_e_val * h / 2.0) * np.array([1, 1])\n            \n            # Global assembly indices\n            dofs = [e, e + 1]\n            A[np.ix_(dofs, dofs)] += A_e\n            b[dofs] += b_e\n        \n        elif p == 2:\n            # Element stiffness matrix for p=2\n            A_e = (k_e / (3.0 * h)) * np.array([[7, -8, 1],\n                                                  [-8, 16, -8],\n                                                  [1, -8, 7]])\n            \n            # Element load vector for p=2\n            b_e = np.zeros(3)\n            if f_type == 'const':\n                f_e_val = f_params['val']\n                b_e = (f_e_val * h / 6.0) * np.array([1, 4, 1])\n            elif f_type == 'special' and e == f_params['elem_idx']:\n                C = f_params['val']\n                # Integrals of basis functions over the right half of ref element [0,1]\n                integrals = np.array([-1.0/12.0, 2.0/3.0, 5.0/12.0])\n                b_e = (C * h / 2.0) * integrals\n            \n            # Global assembly indices\n            dofs = [2*e, 2*e + 1, 2*e + 2]\n            A[np.ix_(dofs, dofs)] += A_e\n            b[dofs] += b_e\n\n    # 3. Apply BCs by extracting interior system\n    A_int = A[interior_dof_indices, interior_dof_indices]\n    b_int = b[interior_dof_indices]\n\n    # 4. Perform DMP checks\n    # Check 1: A_int is a Stieltjes matrix\n    # A small tolerance for floating point comparisons\n    tol = 1e-12\n    is_symmetric = np.allclose(A_int, A_int.T)\n    has_pos_diag = np.all(np.diag(A_int) > tol)\n    \n    is_pos_def = False\n    if is_symmetric:\n        try:\n            # Cholesky decomposition is a standard test for SPD matrices\n            np.linalg.cholesky(A_int)\n            is_pos_def = True\n        except np.linalg.LinAlgError:\n            is_pos_def = False\n    \n    A_off_diag = A_int.copy()\n    np.fill_diagonal(A_off_diag, 0.0)\n    has_nonpos_offdiag = np.all(A_off_diag = tol)\n    \n    check1_passed = is_symmetric and has_pos_diag and is_pos_def and has_nonpos_offdiag\n\n    # Check 2: b_int is entrywise non-negative\n    check2_passed = np.all(b_int >= -tol)\n\n    # Check 3: Solution u_int is entrywise non-negative\n    check3_passed = False\n    if check1_passed and check2_passed: # Optimization, no need to solve if properties fail\n        try:\n            u_int = np.linalg.solve(A_int, b_int)\n            check3_passed = np.all(u_int >= -tol)\n        except np.linalg.LinAlgError:\n            # System is singular, solution does not exist or is not unique\n            check3_passed = False\n            \n    # Per the problem, DMP holds if and only if ALL three checks pass.\n    # The check3_passed will implicitly be False if check1 or check2 fail\n    # because of the conditional block, so we just need to and the results.\n    return check1_passed and check2_passed and check3_passed\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the FEM solver for each.\n    \"\"\"\n    T1_N = 10\n    T2_N = 7\n    T3_N = 6\n    T4_N = 4\n\n    test_cases = [\n        {\n            'p': 1, 'N': T1_N, 'nodes': np.linspace(0, 1, T1_N + 1), \n            'k_vals': [1.0] * T1_N, 'f_type': 'const', 'f_params': {'val': 1.0}\n        },\n        {\n            'p': 1, 'N': T2_N,\n            'nodes': np.array([0, 0.01, 0.02, 0.05, 0.15, 0.40, 0.70, 1]),\n            'k_vals': [10.0, 0.1, 100.0, 0.2, 50.0, 1.5, 5.0],\n            'f_type': 'const', 'f_params': {'val': 1.0}\n        },\n        {\n            'p': 2, 'N': T3_N, 'nodes': np.linspace(0, 1, T3_N + 1),\n            'k_vals': [1.0] * T3_N, 'f_type': 'const', 'f_params': {'val': 1.0}\n        },\n        {\n            'p': 2, 'N': T4_N, 'nodes': np.linspace(0, 1, T4_N + 1),\n            'k_vals': [1.0] * T4_N, 'f_type': 'special',\n            'f_params': {'val': 100.0, 'elem_idx': 2}\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        dmp_holds = run_case(\n            p=case['p'],\n            N=case['N'],\n            nodes=case['nodes'],\n            k_vals=case['k_vals'],\n            f_type=case['f_type'],\n            f_params=case['f_params']\n        )\n        results.append(dmp_holds)\n\n    # Format output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}