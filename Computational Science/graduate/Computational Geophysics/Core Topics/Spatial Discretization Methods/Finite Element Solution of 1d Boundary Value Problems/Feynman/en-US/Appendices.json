{
    "hands_on_practices": [
        {
            "introduction": "The foundation of the finite element method lies in transforming a continuous differential equation into a discrete algebraic system. A crucial first step is deriving the element stiffness matrix, which represents the discrete form of the diffusion operator. This exercise walks you through the fundamental derivation for a one-dimensional linear element, a cornerstone calculation for building any FEM solver for diffusion-type problems. ",
            "id": "3595232",
            "problem": "Consider one-dimensional steady conductive heat transport in a stratified geologic formation along the horizontal coordinate $x$, governed by conservation of energy and Fourierâ€™s law. Under steady conditions with no internal heat storage, conservation of energy implies that the divergence of the conductive heat flux balances the volumetric heat source. Denoting temperature by $u(x)$ and thermal conductivity by $a(x)$, the strong form on an interval $\\Omega=[0,L]$ is\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right)=f(x),\n$$\nwith suitable boundary conditions at $x=0$ and $x=L$. In the finite element method (FEM), the domain $\\Omega$ is partitioned into a mesh with nodes $x_0<x_1<\\cdots<x_N$. Consider a single linear finite element on the generic interval $[x_i,x_{i+1}]$ of length $h_e=x_{i+1}-x_i$, and assume that $a(x)$ is constant on this element, with value $a_e>0$. Let the local trial and test spaces be spanned by the standard linear shape functions $N_1(x)$ and $N_2(x)$ associated with the nodes $x_i$ and $x_{i+1}$, respectively.\n\nStarting from the weighted residual (weak) statement obtained by multiplying the strong form by an arbitrary test function $w(x)$, integrating over $[x_i,x_{i+1}]$, and applying integration by parts to the diffusion term, derive the element-level bilinear form that defines the symmetric $2\\times 2$ element stiffness matrix $k_e$ with entries\n$$\n(k_e)_{mn}=\\int_{x_i}^{x_{i+1}} a_e\\,\\frac{dN_m}{dx}(x)\\,\\frac{dN_n}{dx}(x)\\,dx,\\quad m,n\\in\\{1,2\\}.\n$$\nUsing only this definition, the linear shape functions on $[x_i,x_{i+1}]$, and the assumption that $a_e$ is constant on the element, compute the closed-form expression for the element stiffness matrix $k_e$ in terms of $a_e$ and $h_e$.\n\nYour final answer must be a single closed-form analytical expression. Do not include units in your final answer.",
            "solution": "The problem is well-posed, scientifically grounded, and contains all necessary information for a unique solution. It is a standard exercise in the Finite Element Method (FEM) for second-order boundary value problems. I will proceed with the derivation and computation.\n\nThe problem asks for the derivation of the element stiffness matrix, $k_e$, for a one-dimensional linear finite element. The starting point is the weak form of the governing differential equation,\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right)=f(x) \\quad \\text{for } x \\in [x_i, x_{i+1}]\n$$\nTo obtain the weak form, we multiply by a test function $w(x)$ and integrate over the element domain $[x_i, x_{i+1}]$:\n$$\n-\\int_{x_i}^{x_{i+1}} w(x) \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) dx = \\int_{x_i}^{x_{i+1}} w(x) f(x) dx\n$$\nApplying integration by parts to the left-hand side transfers a derivative from the trial solution $u(x)$ to the test function $w(x)$:\n$$\n\\int_{x_i}^{x_{i+1}} a(x)\\frac{du}{dx}\\frac{dw}{dx} dx - \\left[ w(x) a(x) \\frac{du}{dx} \\right]_{x_i}^{x_{i+1}} = \\int_{x_i}^{x_{i+1}} w(x) f(x) dx\n$$\nRearranging gives the local weak form:\n$$\n\\int_{x_i}^{x_{i+1}} a(x)\\frac{du}{dx}\\frac{dw}{dx} dx = \\int_{x_i}^{x_{i+1}} w(x) f(x) dx + \\left[ w(x) a(x) \\frac{du}{dx} \\right]_{x_i}^{x_{i+1}}\n$$\nThe term on the left is the bilinear form, which gives rise to the stiffness matrix. The right-hand side contains the load vector and the boundary flux terms.\n\nIn the Galerkin FEM, the trial solution $u(x)$ is approximated by a function $u_h(x)$ from a finite-dimensional space spanned by basis functions, which on this element are the linear shape functions $N_1(x)$ and $N_2(x)$. The approximation is written as a linear combination of the nodal values $U_1$ and $U_2$ (corresponding to nodes $x_i$ and $x_{i+1}$):\n$$\nu_h(x) = U_1 N_1(x) + U_2 N_2(x) = \\sum_{n=1}^{2} U_n N_n(x)\n$$\nThe test functions $w(x)$ are chosen from the same space, so we set $w(x) = N_m(x)$ for $m \\in \\{1, 2\\}$. On the element, the conductivity is assumed constant, $a(x) = a_e$. Substituting these into the bilinear form yields:\n$$\n\\int_{x_i}^{x_{i+1}} a_e \\frac{d}{dx}\\left( \\sum_{n=1}^{2} U_n N_n(x) \\right) \\frac{d N_m(x)}{dx} dx = \\sum_{n=1}^{2} \\left( \\int_{x_i}^{x_{i+1}} a_e \\frac{dN_m}{dx}(x) \\frac{dN_n}{dx}(x) dx \\right) U_n\n$$\nThis expression represents the $m$-th row of the system $k_e U_e$, where $U_e$ is the vector of nodal unknowns. Thus, the entries of the element stiffness matrix $k_e$ are given by the integral provided in the problem statement:\n$$\n(k_e)_{mn} = \\int_{x_i}^{x_{i+1}} a_e \\frac{dN_m}{dx}(x) \\frac{dN_n}{dx}(x) dx\n$$\nWe now compute these entries.\n\nFirst, we define the linear shape functions $N_1(x)$ and $N_2(x)$ for the element on the interval $[x_i, x_{i+1}]$ of length $h_e = x_{i+1}-x_i$.\nThe shape function $N_1(x)$ is defined by the conditions $N_1(x_i)=1$ and $N_1(x_{i+1})=0$. The unique linear polynomial satisfying these is:\n$$\nN_1(x) = \\frac{x_{i+1} - x}{x_{i+1} - x_i} = \\frac{x_{i+1} - x}{h_e}\n$$\nThe shape function $N_2(x)$ is defined by $N_2(x_i)=0$ and $N_2(x_{i+1})=1$. This gives:\n$$\nN_2(x) = \\frac{x - x_i}{x_{i+1} - x_i} = \\frac{x - x_i}{h_e}\n$$\n\nNext, we calculate the derivatives of the shape functions with respect to $x$:\n$$\n\\frac{dN_1}{dx} = \\frac{d}{dx} \\left( \\frac{x_{i+1} - x}{h_e} \\right) = -\\frac{1}{h_e}\n$$\n$$\n\\frac{dN_2}{dx} = \\frac{d}{dx} \\left( \\frac{x - x_i}{h_e} \\right) = \\frac{1}{h_e}\n$$\nThese derivatives are constant over the element.\n\nNow we can evaluate the four entries of the $2 \\times 2$ stiffness matrix $k_e$.\n\nCase 1: $m=1, n=1$\n$$\n(k_e)_{11} = \\int_{x_i}^{x_{i+1}} a_e \\left(-\\frac{1}{h_e}\\right) \\left(-\\frac{1}{h_e}\\right) dx = \\int_{x_i}^{x_{i+1}} \\frac{a_e}{h_e^2} dx = \\frac{a_e}{h_e^2} [x]_{x_i}^{x_{i+1}} = \\frac{a_e}{h_e^2} (x_{i+1} - x_i) = \\frac{a_e}{h_e^2} h_e = \\frac{a_e}{h_e}\n$$\n\nCase 2: $m=1, n=2$\n$$\n(k_e)_{12} = \\int_{x_i}^{x_{i+1}} a_e \\left(-\\frac{1}{h_e}\\right) \\left(\\frac{1}{h_e}\\right) dx = \\int_{x_i}^{x_{i+1}} -\\frac{a_e}{h_e^2} dx = -\\frac{a_e}{h_e^2} [x]_{x_i}^{x_{i+1}} = -\\frac{a_e}{h_e^2} h_e = -\\frac{a_e}{h_e}\n$$\n\nCase 3: $m=2, n=1$\nDue to the symmetry of the integrand, $(k_e)_{21} = (k_e)_{12}$.\n$$\n(k_e)_{21} = \\int_{x_i}^{x_{i+1}} a_e \\left(\\frac{1}{h_e}\\right) \\left(-\\frac{1}{h_e}\\right) dx = -\\frac{a_e}{h_e}\n$$\n\nCase 4: $m=2, n=2$\n$$\n(k_e)_{22} = \\int_{x_i}^{x_{i+1}} a_e \\left(\\frac{1}{h_e}\\right) \\left(\\frac{1}{h_e}\\right) dx = \\int_{x_i}^{x_{i+1}} \\frac{a_e}{h_e^2} dx = \\frac{a_e}{h_e^2} [x]_{x_i}^{x_{i+1}} = \\frac{a_e}{h_e^2} h_e = \\frac{a_e}{h_e}\n$$\n\nAssembling these entries into the matrix $k_e$:\n$$\nk_e = \\begin{pmatrix} (k_e)_{11} & (k_e)_{12} \\\\ (k_e)_{21} & (k_e)_{22} \\end{pmatrix} = \\begin{pmatrix} \\frac{a_e}{h_e} & -\\frac{a_e}{h_e} \\\\ -\\frac{a_e}{h_e} & \\frac{a_e}{h_e} \\end{pmatrix}\n$$\nFactoring out the common term $\\frac{a_e}{h_e}$ gives the final closed-form expression for the element stiffness matrix.\n$$\nk_e = \\frac{a_e}{h_e} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$",
            "answer": "$$\n\\boxed{\\frac{a_e}{h_e} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Once the stiffness matrix is understood, the next step is to discretize the source term, forming the load vector on the right-hand side of the linear system. This practice focuses on the assembly process, showing how contributions from a source term distributed over adjacent elements are integrated against a nodal basis function. Mastering this concept is key to understanding how local physics are aggregated into the global system of equations. ",
            "id": "3595233",
            "problem": "In a computational geophysics setting, consider steady-state one-dimensional ($1$D) heat conduction in a horizontally layered lithosphere governed by the partial differential equation (PDE) $-k\\,u''(x)=f(x)$ on the interval $[0,L]$, where $k>0$ is a constant thermal conductivity, $u(x)$ is temperature, and $f(x)$ is a volumetric heat production term. Impose Dirichlet boundary conditions $u(0)=T_0$ and $u(L)=T_L$ with given constants $T_0$ and $T_L$. Discretize $[0,L]$ by a strictly increasing mesh $0=x_0<x_1<\\cdots<x_n=L$ into $n$ elements $e_k=[x_{k-1},x_k]$ of lengths $h_k=x_k-x_{k-1}$ for $k=1,\\dots,n$. Let $V_h$ be the space of globally continuous, piecewise linear functions on this mesh with the usual nodal (hat) basis $\\{\\phi_i\\}_{i=0}^n$. Assume the volumetric source is piecewise constant with respect to the mesh, i.e., $f(x)=f_k$ for $x\\in e_k$, where each $f_k$ is a constant.\n\nUsing the standard Galerkin finite element method (FEM) and starting from the weak form of the PDE and the definition of the global load functional acting on test functions in $V_h$, derive a closed-form analytic expression for the global load vector entry associated with an interior node index $j\\in\\{1,\\dots,n-1\\}$, namely $F_j=\\int_0^L f(x)\\,\\phi_j(x)\\,\\mathrm{d}x$, written solely in terms of the adjacent element sizes $h_j$, $h_{j+1}$ and the corresponding piecewise constant source values $f_j$, $f_{j+1}$. Your final answer must be a single closed-form expression involving $h_j$, $h_{j+1}$, $f_j$, and $f_{j+1}$ only. Do not introduce any additional symbols. Express your answer as an exact expression; no rounding is required.",
            "solution": "The problem statement is critically validated and found to be valid. It is scientifically grounded, well-posed, objective, and self-contained, presenting a standard problem in the application of the finite element method.\n\nThe task is to derive a closed-form expression for the global load vector entry $F_j$ associated with an interior node $x_j$, where $j \\in \\{1, \\dots, n-1\\}$. The load vector entry is defined by the integral:\n$$\nF_j = \\int_0^L f(x) \\, \\phi_j(x) \\, \\mathrm{d}x\n$$\nHere, $f(x)$ is the piecewise constant heat source term, and $\\phi_j(x)$ is the piecewise linear nodal basis function (or \"hat function\") associated with node $x_j$.\n\nThe nodal basis function $\\phi_j(x)$ has the property that it is non-zero only on the elements adjacent to the node $x_j$. Since $j$ is an interior node index, these elements are $e_j = [x_{j-1}, x_j]$ and $e_{j+1} = [x_j, x_{j+1}]$. On all other elements, $\\phi_j(x)=0$. Therefore, the integral for $F_j$ simplifies, as its domain can be restricted to the support of $\\phi_j(x)$:\n$$\nF_j = \\int_{x_{j-1}}^{x_{j+1}} f(x) \\, \\phi_j(x) \\, \\mathrm{d}x\n$$\nThis integral can be split into two parts, one for each element in the support of $\\phi_j(x)$:\n$$\nF_j = \\int_{x_{j-1}}^{x_j} f(x) \\, \\phi_j(x) \\, \\mathrm{d}x + \\int_{x_j}^{x_{j+1}} f(x) \\, \\phi_j(x) \\, \\mathrm{d}x\n$$\nThe problem states that the heat source $f(x)$ is piecewise constant, such that $f(x)=f_k$ for $x \\in e_k = [x_{k-1}, x_k]$. Applying this to our integral, we get:\n$$\nF_j = \\int_{x_{j-1}}^{x_j} f_j \\, \\phi_j(x) \\, \\mathrm{d}x + \\int_{x_j}^{x_{j+1}} f_{j+1} \\, \\phi_j(x) \\, \\mathrm{d}x\n$$\nSince $f_j$ and $f_{j+1}$ are constants, they can be taken out of the integrals:\n$$\nF_j = f_j \\int_{x_{j-1}}^{x_j} \\phi_j(x) \\, \\mathrm{d}x + f_{j+1} \\int_{x_j}^{x_{j+1}} \\phi_j(x) \\, \\mathrm{d}x\n$$\nNext, we must define the analytical expressions for the basis function $\\phi_j(x)$ on each of the two elements.\nThe basis function $\\phi_j(x)$ is linear on each element and satisfies $\\phi_j(x_j)=1$ and $\\phi_j(x_i)=0$ for $i \\neq j$.\n\nOn element $e_j = [x_{j-1}, x_j]$, the function $\\phi_j(x)$ increases linearly from $0$ at $x_{j-1}$ to $1$ at $x_j$. The equation for this line segment is:\n$$\n\\phi_j(x) = \\frac{x - x_{j-1}}{x_j - x_{j-1}} = \\frac{x - x_{j-1}}{h_j} \\quad \\text{for } x \\in [x_{j-1}, x_j]\n$$\nOn element $e_{j+1} = [x_j, x_{j+1}]$, the function $\\phi_j(x)$ decreases linearly from $1$ at $x_j$ to $0$ at $x_{j+1}$. The equation for this line segment is:\n$$\n\\phi_j(x) = \\frac{x_{j+1} - x}{x_{j+1} - x_j} = \\frac{x_{j+1} - x}{h_{j+1}} \\quad \\text{for } x \\in [x_j, x_{j+1}]\n$$\nNow, we substitute these expressions back into the integrals.\n\nFor the first integral, over element $e_j$:\n$$\n\\int_{x_{j-1}}^{x_j} \\phi_j(x) \\, \\mathrm{d}x = \\int_{x_{j-1}}^{x_j} \\frac{x - x_{j-1}}{h_j} \\, \\mathrm{d}x = \\frac{1}{h_j} \\left[ \\frac{(x - x_{j-1})^2}{2} \\right]_{x_{j-1}}^{x_j}\n$$\nEvaluating the antiderivative at the limits:\n$$\n\\frac{1}{h_j} \\left( \\frac{(x_j - x_{j-1})^2}{2} - \\frac{(x_{j-1} - x_{j-1})^2}{2} \\right) = \\frac{1}{h_j} \\left( \\frac{h_j^2}{2} - 0 \\right) = \\frac{h_j}{2}\n$$\nFor the second integral, over element $e_{j+1}$:\n$$\n\\int_{x_j}^{x_{j+1}} \\phi_j(x) \\, \\mathrm{d}x = \\int_{x_j}^{x_{j+1}} \\frac{x_{j+1} - x}{h_{j+1}} \\, \\mathrm{d}x = \\frac{1}{h_{j+1}} \\left[ -\\frac{(x_{j+1} - x)^2}{2} \\right]_{x_j}^{x_{j+1}}\n$$\nEvaluating the antiderivative at the limits:\n$$\n\\frac{1}{h_{j+1}} \\left( -\\frac{(x_{j+1} - x_{j+1})^2}{2} - \\left(-\\frac{(x_{j+1} - x_j)^2}{2}\\right) \\right) = \\frac{1}{h_{j+1}} \\left( 0 + \\frac{h_{j+1}^2}{2} \\right) = \\frac{h_{j+1}}{2}\n$$\nThese integrals represent the areas of the two triangles that form the hat function $\\phi_j(x)$.\n\nFinally, we substitute these results back into the expression for $F_j$:\n$$\nF_j = f_j \\left( \\frac{h_j}{2} \\right) + f_{j+1} \\left( \\frac{h_{j+1}}{2} \\right)\n$$\nCombining the terms gives the desired closed-form expression for the load vector entry at an interior node $j$:\n$$\nF_j = \\frac{1}{2} (f_j h_j + f_{j+1} h_{j+1})\n$$\nThis expression depends only on the adjacent element sizes $h_j$ and $h_{j+1}$, and the corresponding piecewise constant source values $f_j$ and $f_{j+1}$, as required by the problem statement.",
            "answer": "$$\n\\boxed{\\frac{f_j h_j + f_{j+1} h_{j+1}}{2}}\n$$"
        },
        {
            "introduction": "Moving from derivation to implementation, this practice challenges you to build a complete FEM solver and use it as a numerical laboratory. You will investigate the Discrete Maximum Principle (DMP), a critical property for ensuring physically meaningful solutions in diffusion simulations, which states that the solution's extrema should occur at the boundaries unless dictated by a source. This exercise highlights how theoretical properties translate to code and how numerical choices, like the polynomial degree of elements, can have profound impacts on the qualitative behavior of the solution. ",
            "id": "3595268",
            "problem": "Consider the one-dimensional boundary value problem on the interval $[0,1]$ with homogeneous Dirichlet boundary conditions, given by the strong form $-(k(x)\\,u'(x))'=f(x)$, where $k(x)>0$ almost everywhere and $f(x)\\ge 0$. The weak form seeks $u\\in H_0^1(0,1)$ such that $\\int_0^1 k(x)\\,u'(x)\\,v'(x)\\,dx=\\int_0^1 f(x)\\,v(x)\\,dx$ for all $v\\in H_0^1(0,1)$. In computational geophysics, monotonicity and the Discrete Maximum Principle (DMP) are important when modeling diffusive processes (e.g., heat conduction, hydraulic head diffusion). For linear finite elements on a one-dimensional mesh, monotonicity is expected under suitable conditions on the mesh and coefficients.\n\nYour task is to implement a complete finite element solver in one spatial dimension that supports continuous piecewise polynomials of degree $p\\in\\{1,2\\}$. You must:\n\n- Assemble the global stiffness matrix $\\mathbf{A}$ from the bilinear form $a(u,v)=\\int_0^1 k(x)\\,u'(x)\\,v'(x)\\,dx$ using exact element formulas, assuming $k(x)$ is piecewise constant per element.\n- Assemble the global load vector $\\mathbf{b}$ from the linear functional $\\ell(v)=\\int_0^1 f(x)\\,v(x)\\,dx$ using exact element formulas for piecewise constant $f(x)$ and, where specified, exact analytic integration on a subinterval of an element.\n- Enforce homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$ by removing boundary degrees of freedom from the linear system.\n\nDefine the following checks for the Discrete Maximum Principle (DMP) in the setting $f(x)\\ge 0$ and $k(x)>0$:\n\n1. A matrix is a Stieltjes matrix if it is symmetric positive definite and has nonpositive off-diagonal entries. Check that $\\mathbf{A}$ is symmetric, has strictly positive diagonal entries, is positive definite, and has nonpositive off-diagonals. This condition is sufficient in one dimension for monotonicity of the nodal solution under linear finite elements.\n2. Check that the assembled load vector $\\mathbf{b}$ is entrywise nonnegative. For linear finite elements ($p=1$), local shape functions are nonnegative on their support, ensuring nonnegativity of $\\mathbf{b}$ when $f(x)\\ge 0$. For quadratic finite elements ($p=2$), local shape functions may change sign, so $\\mathbf{b}$ can have negative entries even if $f(x)\\ge 0$; this may violate DMP.\n3. Solve $\\mathbf{A}\\mathbf{u}=\\mathbf{b}$ and check whether the computed vector of nodal values $\\mathbf{u}$ (for interior degrees of freedom) is entrywise nonnegative.\n\nFor the purposes of this problem, define that the DMP holds for a given case if and only if all three checks above pass.\n\nImplement the following test suite of cases (all meshes lie on the interval $[0,1]$):\n\n- Case $\\mathrm{T1}$ (piecewise linear elements, uniform mesh, constant coefficients): Use $p=1$, $N=10$ elements with nodes at $x_i=i/N$ for $i=0,1,\\dots,N$, let $k(x)\\equiv 1$ and $f(x)\\equiv 1$. Report whether the DMP holds.\n- Case $\\mathrm{T2}$ (piecewise linear elements, highly nonuniform mesh, strongly varying coefficient): Use $p=1$, $N=7$ elements with nodes $x=\\big[0,\\,0.01,\\,0.02,\\,0.05,\\,0.15,\\,0.40,\\,0.70,\\,1\\big]$, and piecewise constant coefficients per element $k_e=\\big[10,\\,0.1,\\,100,\\,0.2,\\,50,\\,1.5,\\,5\\big]$. Let $f(x)\\equiv 1$. Report whether the DMP holds.\n- Case $\\mathrm{T3}$ (piecewise quadratic elements, uniform mesh, constant coefficients): Use $p=2$, $N=6$ elements with nodes at $x_i=i/N$ for $i=0,1,\\dots,N$, let $k(x)\\equiv 1$, and $f(x)\\equiv 1$. Report whether the DMP holds. Note: The global stiffness matrix for $p=2$ has positive off-diagonal entries between certain vertex degrees of freedom, so the matrix fails the Stieltjes property; thus DMP should be reported as not holding even if the solution happens to be nonnegative.\n- Case $\\mathrm{T4}$ (piecewise quadratic elements, uniform mesh, targeted positive forcing on a subinterval): Use $p=2$, $N=4$ elements with nodes at $x_i=i/N$ for $i=0,1,\\dots,N$, let $k(x)\\equiv 1$, and define $f(x)$ to be strictly positive only on the right half of element $e=2$ (i.e., on $[x_2+\\tfrac{h}{2},x_3]$ where $h=x_3-x_2$) with magnitude $C=100$, and zero elsewhere. This $f(x)\\ge 0$ produces a negative entry in the load vector at the interior vertex node of that element due to the sign-changing quadratic basis, violating the DMP. Report whether the DMP holds.\n\nYour program must implement the assembly and checks exactly as described. For each case, output a boolean indicating whether the DMP holds. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where each $r_i$ is a boolean for the corresponding case.",
            "solution": "The problem requires the implementation of a one-dimensional finite element method (FEM) solver for the boundary value problem $-\\frac{d}{dx}(k(x)\\frac{du}{dx}) = f(x)$ on the interval $[0,1]$ with homogeneous Dirichlet boundary conditions $u(0)=u(1)=0$. The solver must support continuous piecewise linear ($p=1$) and piecewise quadratic ($p=2$) basis functions. A key aspect is to verify the Discrete Maximum Principle (DMP) for four specified test cases. The DMP is defined to hold if and only if three conditions are met: 1) the global stiffness matrix for interior degrees of freedom is a Stieltjes matrix, 2) the assembled global load vector for interior degrees of freedom is entrywise non-negative, and 3) the resulting numerical solution is entrywise non-negative.\n\nThe solution proceeds by first deriving the element stiffness matrices and load vectors for both $p=1$ and $p=2$ elements. Then, the assembly process, enforcement of boundary conditions, and the implementation of the DMP checks are described. Finally, each test case is analyzed based on these principles.\n\n**Finite Element Discretization and Element-Level Computations**\n\nThe domain $[0,1]$ is discretized into $N$ elements. For an element $e$ spanning $[x_e, x_{e+1}]$ with length $h_e = x_{e+1} - x_e$, we use a mapping from a reference element $\\hat{K} = [-1, 1]$ to the physical element. The integral for the element stiffness matrix is given by $A^e_{ij} = \\int_{x_e}^{x_{e+1}} k_e \\phi'_i(x) \\phi'_j(x) dx$, and the element load vector is $b^e_i = \\int_{x_e}^{x_{e+1}} f_e(x) \\phi_i(x) dx$. We assume $k(x) = k_e$ is constant on element $e$.\n\n**1. Piecewise Linear Elements ($p=1$)**\nAn element has $2$ nodes, one at each endpoint. The basis functions on the reference element $\\hat{K}$ are $\\hat{\\phi}_1(\\xi) = \\frac{1-\\xi}{2}$ and $\\hat{\\phi}_2(\\xi) = \\frac{1+\\xi}{2}$. Their derivatives are $\\frac{d\\hat{\\phi}_1}{d\\xi} = -\\frac{1}{2}$ and $\\frac{d\\hat{\\phi}_2}{d\\xi} = \\frac{1}{2}$.\n\nThe element stiffness matrix is found by transforming the integral to the reference element:\n$$ A^e_{ij} = \\int_{-1}^{1} k_e \\left(\\frac{d\\hat{\\phi}_i}{d\\xi}\\frac{2}{h_e}\\right) \\left(\\frac{d\\hat{\\phi}_j}{d\\xi}\\frac{2}{h_e}\\right) \\frac{h_e}{2} d\\xi = \\frac{2k_e}{h_e} \\int_{-1}^{1} \\frac{d\\hat{\\phi}_i}{d\\xi} \\frac{d\\hat{\\phi}_j}{d\\xi} d\\xi $$\nEvaluating the integrals yields the well-known element stiffness matrix for a 1D diffusion problem:\n$$ \\mathbf{A}^e = \\frac{k_e}{h_e} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} $$\nFor a piecewise constant forcing function, $f(x)=f_e$, the element load vector is:\n$$ b^e_i = \\int_{-1}^{1} f_e \\hat{\\phi}_i(\\xi) \\frac{h_e}{2} d\\xi $$\nThis gives the element load vector, which corresponds to the trapezoidal rule for integration:\n$$ \\mathbf{b}^e = f_e \\frac{h_e}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} $$\n\n**2. Piecewise Quadratic Elements ($p=2$)**\nAn element has $3$ nodes: one at each endpoint (vertex nodes) and one at the midpoint (internal node). The basis functions on $\\hat{K}$ corresponding to nodes at $\\xi = -1, 0, 1$ are:\n- $\\hat{\\phi}_1(\\xi) = \\frac{\\xi(\\xi-1)}{2}$ (left vertex)\n- $\\hat{\\phi}_2(\\xi) = 1-\\xi^2$ (midpoint)\n- $\\hat{\\phi}_3(\\xi) = \\frac{\\xi(\\xi+1)}{2}$ (right vertex)\nTheir derivatives are $\\frac{d\\hat{\\phi}_1}{d\\xi} = \\xi - \\frac{1}{2}$, $\\frac{d\\hat{\\phi}_2}{d\\xi} = -2\\xi$, and $\\frac{d\\hat{\\phi}_3}{d\\xi} = \\xi + \\frac{1}{2}$.\nThe element stiffness matrix, computed using the same transformation as for $p=1$, is:\n$$ \\mathbf{A}^e = \\frac{k_e}{3h_e} \\begin{pmatrix} 7 & -8 & 1 \\\\ -8 & 16 & -8 \\\\ 1 & -8 & 7 \\end{pmatrix} $$\nNote the positive off-diagonal entries $A^e_{13} = A^e_{31} = \\frac{k_e}{3h_e}$. These terms connect adjacent vertex nodes and cause the global stiffness matrix to fail the Stieltjes property (non-positive off-diagonals).\n\nFor a constant forcing $f(x)=f_e$, the element load vector is:\n$$ \\mathbf{b}^e = f_e \\frac{h_e}{6} \\begin{pmatrix} 1 \\\\ 4 \\\\ 1 \\end{pmatrix} $$\nThis corresponds to Simpson's rule for integration.\n\nFor Case T4, the forcing function is $f(x) = C = 100$ on the right half of element $e=2$, which corresponds to the interval $[\\xi_0, \\xi_1] = [0, 1]$ on the reference element. The element load vector is calculated as $b^e_i = \\int_0^1 C \\hat{\\phi}_i(\\xi) \\frac{h_e}{2} d\\xi$.\n- For the left vertex node ($\\hat{\\phi}_1$): $b^e_1 = C\\frac{h_e}{2} \\int_0^1 \\frac{\\xi(\\xi-1)}{2} d\\xi = C\\frac{h_e}{2} \\left(-\\frac{1}{12}\\right)$. Since $C>0$ and $h_e>0$, this entry is negative.\n- For the midpoint node ($\\hat{\\phi}_2$): $b^e_2 = C\\frac{h_e}{2} \\int_0^1 (1-\\xi^2) d\\xi = C\\frac{h_e}{2} \\left(\\frac{2}{3}\\right)$.\n- For the right vertex node ($\\hat{\\phi}_3$): $b^e_3 = C\\frac{h_e}{2} \\int_0^1 \\frac{\\xi(\\xi+1)}{2} d\\xi = C\\frac{h_e}{2} \\left(\\frac{5}{12}\\right)$.\nThe negative value for $b^e_1$ demonstrates how a non-negative forcing function $f(x) \\ge 0$ can produce a negative entry in the load vector when using higher-order basis functions that are not everywhere non-negative on the element.\n\n**Global Assembly and Boundary Conditions**\nThe global stiffness matrix $\\mathbf{A}$ and load vector $\\mathbf{b}$ are constructed by iterating through each element, computing its local matrix $\\mathbf{A}^e$ and vector $\\mathbf{b}^e$, and adding their contributions to the corresponding global degrees of freedom (DoFs).\nFor $p=1$, there are $N+1$ DoFs, indexed $0, \\dots, N$. For $p=2$, there are $2N+1$ DoFs, indexed $0, \\dots, 2N$.\nHomogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$ are enforced by removing the rows and columns corresponding to the boundary DoFs (the first and the last) from the global system. This results in a smaller linear system $\\mathbf{A}_{int}\\mathbf{u}_{int} = \\mathbf{b}_{int}$ for the unknown interior nodal values $\\mathbf{u}_{int}$.\n\n**DMP Checks and Analysis of Test Cases**\nThe DMP is considered to hold if the following three checks on the interior system pass:\n1.  **Stieltjes Matrix:** $\\mathbf{A}_{int}$ is symmetric, positive definite, and has non-positive off-diagonal entries.\n2.  **Non-negative Load Vector:** All entries of $\\mathbf{b}_{int}$ are non-negative.\n3.  **Non-negative Solution:** All entries of the solution $\\mathbf{u}_{int} = \\mathbf{A}_{int}^{-1}\\mathbf{b}_{int}$ are non-negative.\n\n- **Case T1 ($p=1$, uniform mesh, constant coefficients):**\n  1. The matrix $\\mathbf{A}_{int}$ is a tridiagonal matrix with diagonal entries $\\frac{2k}{h}$ and off-diagonal entries $-\\frac{k}{h}$. It is symmetric, diagonally dominant with positive diagonals (hence positive definite), and has non-positive off-diagonals. **Check 1 passes.**\n  2. The load vector $\\mathbf{b}_{int}$ has entries $f \\cdot h > 0$. **Check 2 passes.**\n  3. Since $\\mathbf{A}_{int}$ is an M-matrix and $\\mathbf{b}_{int}$ is non-negative, the solution $\\mathbf{u}_{int} = \\mathbf{A}_{int}^{-1}\\mathbf{b}_{int}$ is guaranteed to be non-negative. **Check 3 passes.**\n  **Result for T1: DMP holds (True).**\n\n- **Case T2 ($p=1$, non-uniform mesh, variable coefficients):**\n  1. Similar to T1, $\\mathbf{A}_{int}$ is tridiagonal. The diagonal entries are $(\\frac{k_{i-1}}{h_{i-1}} + \\frac{k_i}{h_i})>0$ and off-diagonal entries are $-\\frac{k_i}{h_i}<0$. The matrix is symmetric, positive definite, and has non-positive off-diagonals. **Check 1 passes.**\n  2. The load vector entries are $f \\frac{h_{i-1}+h_i}{2} > 0$. **Check 2 passes.**\n  3. Arguments from T1 apply. **Check 3 passes.**\n  **Result for T2: DMP holds (True).**\n\n- **Case T3 ($p=2$, uniform mesh, constant coefficients):**\n  1. The assembly of $\\mathbf{A}^e$ matrices, which contain positive off-diagonal entries, results in a global matrix $\\mathbf{A}_{int}$ that has positive off-diagonal entries connecting DoFs of adjacent vertices. For example, the entry coupling vertex node $x_i$ and vertex node $x_{i+1}$ is positive. Therefore, $\\mathbf{A}_{int}$ is not Stieltjes. **Check 1 fails.**\n  Per the problem definition, if any check fails, the DMP does not hold.\n  **Result for T3: DMP does not hold (False).**\n\n- **Case T4 ($p=2$, special forcing):**\n  1. As in T3, the stiffness matrix $\\mathbf{A}_{int}$ is not Stieltjes. **Check 1 fails.**\n  2. As derived above, the forcing function $f(x)>0$ on the right half of element $e=2$ produces a negative entry in the local load vector $\\mathbf{b}^e$ at the node corresponding to the left vertex of that element ($x_2=0.5$). Since $f(x)=0$ on the preceding element, this negative contribution is not offset, and the corresponding entry in $\\mathbf{b}_{int}$ becomes negative. **Check 2 fails.**\n  Since multiple checks fail, the DMP does not hold.\n  **Result for T4: DMP does not hold (False).**\n\nThe final output is the list of boolean results for T1, T2, T3, and T4.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(p, N, nodes, k_vals, f_type, f_params):\n    \"\"\"\n    Assembles and solves a 1D FEM problem, then performs DMP checks.\n\n    Args:\n        p (int): Polynomial degree (1 or 2).\n        N (int): Number of elements.\n        nodes (np.ndarray): Array of node coordinates.\n        k_vals (list or np.ndarray): Piecewise constant k values for each element.\n        f_type (str): Type of forcing function ('const' or 'special').\n        f_params (dict): Parameters for the forcing function.\n\n    Returns:\n        bool: True if DMP holds, False otherwise.\n    \"\"\"\n    # 1. Setup based on polynomial degree\n    if p == 1:\n        num_dofs = N + 1\n        interior_dof_indices = slice(1, N)\n    elif p == 2:\n        num_dofs = 2 * N + 1\n        interior_dof_indices = slice(1, 2 * N)\n    else:\n        raise ValueError(\"Polynomial degree p must be 1 or 2.\")\n\n    A = np.zeros((num_dofs, num_dofs))\n    b = np.zeros(num_dofs)\n\n    # 2. Assembly loop over elements\n    for e in range(N):\n        x_left = nodes[e]\n        x_right = nodes[e+1]\n        h = x_right - x_left\n        k_e = k_vals[e]\n\n        if p == 1:\n            # Element stiffness matrix for p=1\n            A_e = (k_e / h) * np.array([[1, -1], [-1, 1]])\n            \n            # Element load vector for p=1\n            f_e_val = 0.0\n            if f_type == 'const':\n                f_e_val = f_params['val']\n            b_e = (f_e_val * h / 2.0) * np.array([1, 1])\n            \n            # Global assembly indices\n            dofs = [e, e + 1]\n            A[np.ix_(dofs, dofs)] += A_e\n            b[dofs] += b_e\n        \n        elif p == 2:\n            # Element stiffness matrix for p=2\n            A_e = (k_e / (3.0 * h)) * np.array([[7, -8, 1],\n                                                  [-8, 16, -8],\n                                                  [1, -8, 7]])\n            \n            # Element load vector for p=2\n            b_e = np.zeros(3)\n            if f_type == 'const':\n                f_e_val = f_params['val']\n                b_e = (f_e_val * h / 6.0) * np.array([1, 4, 1])\n            elif f_type == 'special' and e == f_params['elem_idx']:\n                C = f_params['val']\n                # Integrals of basis functions over the right half of ref element [0,1]\n                integrals = np.array([-1.0/12.0, 2.0/3.0, 5.0/12.0])\n                b_e = (C * h / 2.0) * integrals\n            \n            # Global assembly indices\n            dofs = [2*e, 2*e + 1, 2*e + 2]\n            A[np.ix_(dofs, dofs)] += A_e\n            b[dofs] += b_e\n\n    # 3. Apply BCs by extracting interior system\n    A_int = A[interior_dof_indices, interior_dof_indices]\n    b_int = b[interior_dof_indices]\n\n    # 4. Perform DMP checks\n    # Check 1: A_int is a Stieltjes matrix\n    # A small tolerance for floating point comparisons\n    tol = 1e-12\n    is_symmetric = np.allclose(A_int, A_int.T)\n    has_pos_diag = np.all(np.diag(A_int) > tol)\n    \n    is_pos_def = False\n    if is_symmetric:\n        try:\n            # Cholesky decomposition is a standard test for SPD matrices\n            np.linalg.cholesky(A_int)\n            is_pos_def = True\n        except np.linalg.LinAlgError:\n            is_pos_def = False\n    \n    A_off_diag = A_int.copy()\n    np.fill_diagonal(A_off_diag, 0.0)\n    has_nonpos_offdiag = np.all(A_off_diag = tol)\n    \n    check1_passed = is_symmetric and has_pos_diag and is_pos_def and has_nonpos_offdiag\n\n    # Check 2: b_int is entrywise non-negative\n    check2_passed = np.all(b_int >= -tol)\n\n    # Check 3: Solution u_int is entrywise non-negative\n    check3_passed = False\n    if check1_passed and check2_passed: # Optimization, no need to solve if properties fail\n        try:\n            u_int = np.linalg.solve(A_int, b_int)\n            check3_passed = np.all(u_int >= -tol)\n        except np.linalg.LinAlgError:\n            # System is singular, solution does not exist or is not unique\n            check3_passed = False\n            \n    # Per the problem, DMP holds if and only if ALL three checks pass.\n    # The check3_passed will implicitly be False if check1 or check2 fail\n    # because of the conditional block, so we just need to and the results.\n    return check1_passed and check2_passed and check3_passed\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the FEM solver for each.\n    \"\"\"\n    T1_N = 10\n    T2_N = 7\n    T3_N = 6\n    T4_N = 4\n\n    test_cases = [\n        {\n            'p': 1, 'N': T1_N, 'nodes': np.linspace(0, 1, T1_N + 1), \n            'k_vals': [1.0] * T1_N, 'f_type': 'const', 'f_params': {'val': 1.0}\n        },\n        {\n            'p': 1, 'N': T2_N,\n            'nodes': np.array([0, 0.01, 0.02, 0.05, 0.15, 0.40, 0.70, 1]),\n            'k_vals': [10.0, 0.1, 100.0, 0.2, 50.0, 1.5, 5.0],\n            'f_type': 'const', 'f_params': {'val': 1.0}\n        },\n        {\n            'p': 2, 'N': T3_N, 'nodes': np.linspace(0, 1, T3_N + 1),\n            'k_vals': [1.0] * T3_N, 'f_type': 'const', 'f_params': {'val': 1.0}\n        },\n        {\n            'p': 2, 'N': T4_N, 'nodes': np.linspace(0, 1, T4_N + 1),\n            'k_vals': [1.0] * T4_N, 'f_type': 'special',\n            'f_params': {'val': 100.0, 'elem_idx': 2}\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        dmp_holds = run_case(\n            p=case['p'],\n            N=case['N'],\n            nodes=case['nodes'],\n            k_vals=case['k_vals'],\n            f_type=case['f_type'],\n            f_params=case['f_params']\n        )\n        results.append(dmp_holds)\n\n    # Format output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}