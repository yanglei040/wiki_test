{
    "hands_on_practices": [
        {
            "introduction": "本实践旨在为任何有限元程序提供一个基础的“健全性检查”。通过构建并验证一个无约束结构的全局刚度矩阵，您可以确认代码是否正确地反映了基本的物理原理。此练习将指导您验证刚体运动（即平移和旋转）不会产生应变能，这是通过证明代表这些运动的向量位于全局刚度矩阵 $\\mathbf{K}$ 的零空间中来实现的 ()。掌握此验证方法对于调试和确保有限元模型的可靠性至关重要。",
            "id": "3588944",
            "problem": "考虑一个在无量纲设置下的二维小应变线性弹性固体，使用常应变三节点三角形通过有限元法（FEM）进行离散。其本构行为是平面应力条件下的线性各向同性弹性。未知位移场由向量 $\\mathbf{u}$ 表示，该向量按 $\\left[u_{x1}, u_{y1}, u_{x2}, u_{y2}, \\dots \\right]^{\\top}$ 的顺序集合了所有节点位移。组装后的全局刚度矩阵为 $\\mathbf{K}$，全局载荷向量为 $\\mathbf{f}$。刚体模态是对应于两个平移和一个平面内旋转的三种位移模式。\n\n使用的基本原理：\n- 虚功原理：对于任意虚位移 $\\delta \\mathbf{u}$，内虚功等于外虚功，即 $\\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta \\boldsymbol{\\varepsilon} \\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\mathbf{b} \\cdot \\delta \\mathbf{u} \\, \\mathrm{d}\\Omega + \\int_{\\Gamma_{t}} \\bar{\\mathbf{t}} \\cdot \\delta \\mathbf{u} \\, \\mathrm{d}\\Gamma$，经过有限元离散后，得到 $\\delta \\mathbf{u}^{\\top} \\mathbf{K} \\mathbf{u} = \\delta \\mathbf{u}^{\\top} \\mathbf{f}$。\n- 线性运动学：对于每个单元，$\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u}_{e}$，其中 $\\mathbf{B}$ 为常应变-位移矩阵。\n- 平面应力下的线性各向同性弹性：$\\boldsymbol{\\sigma} = \\mathbf{D} \\, \\boldsymbol{\\varepsilon}$，其中 $\\mathbf{D} = \\dfrac{E}{1-\\nu^{2}} \\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\dfrac{1-\\nu}{2} \\end{bmatrix}$，$E$ 是杨氏模量，$\\nu$ 是泊松比。\n- 常应变三角形（厚度为 $t$）的单元刚度矩阵：$\\mathbf{K}_{e} = t \\, A_{e} \\, \\mathbf{B}^{\\top} \\mathbf{D} \\mathbf{B}$，其中 $A_{e}$ 是三角形面积，$\\mathbf{B}$ 通过标准的常应变三角形公式由节点坐标计算得出。\n\n任务：\n1. 为单位正方形域 $\\Omega = [0,1] \\times [0,1]$ 组装全局刚度矩阵 $\\mathbf{K}$。该域被离散为两个线性三角形单元，节点位于 $(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$，单元为 $\\{(0,0),(1,0),(1,1)\\}$ 和 $\\{(0,0),(1,1),(0,1)\\}$。使用平面应力，厚度 $t=1$。所有量均为无量纲，因此输出中无需物理单位。\n2. 构造三个大小为 $2N$ 的刚体模态向量 $\\mathbf{r}_{1}$、$\\mathbf{r}_{2}$、$\\mathbf{r}_{3}$，分别对应于：x 方向平移（对所有节点，$\\mathbf{r}_{1}$ 中 $u_{xi} = 1, u_{yi} = 0$），y 方向平移（$\\mathbf{r}_{2}$ 中 $u_{xi} = 0, u_{yi} = 1$），以及绕原点的单位旋转（在节点 $i$ 处，$\\mathbf{r}_{3}$ 中 $u_{xi} = -y_{i}, u_{yi} = x_{i}$）。\n3. 通过为每个组装的 $\\mathbf{K}$ 计算 $j \\in \\{1,2,3\\}$ 的 $\\|\\mathbf{K} \\mathbf{r}_{j}\\|_{2}$ 来验证刚体模态，并将这些范数报告为浮点数。在精确算术和正确组装的情况下，$\\mathbf{K} \\mathbf{r}_{j} = \\mathbf{0}$。\n4. 证明任何与所有刚体模态正交的载荷向量 $\\mathbf{f}$（即对于 $j \\in \\{1,2,3\\}$，$\\mathbf{r}_{j}^{\\top} \\mathbf{f} = 0$）都会产生一个可解的系统 $\\mathbf{K} \\mathbf{u} = \\mathbf{f}$，即至少存在一个解。通过计算最小范数解 $\\mathbf{u} = \\mathbf{K}^{+} \\mathbf{f}$ 来数值验证可解性，其中 $\\mathbf{K}^{+}$ 是 Moore-Penrose 伪逆，并以浮点数形式报告残差范数 $\\|\\mathbf{K}\\mathbf{u} - \\mathbf{f}\\|_{2}$。\n5. 设计一个载荷向量 $\\mathbf{f}$，该向量错误地激发出受约束的（刚体）模态，即它不与刚体模态子空间正交。通过计算 $\\mathbf{f}$ 在 $\\{\\mathbf{r}_{1}, \\mathbf{r}_{2}, \\mathbf{r}_{3}\\}$ 生成空间上的投影的量值来检测这一点，并将此量值报告为浮点数。同时，报告一个指示检测的布尔标志，如果该量值超过容差 $\\varepsilon = 10^{-10}$ 则定义为真，否则为假。\n\n使用以下参数值和载荷的测试套件：\n- 测试用例 #1：$E = 2$, $\\nu = 0.25$, $t = 1$。载荷 $\\mathbf{f}$ 是自平衡的且与刚体模态正交：在节点 $(1,0)$ 的 x 方向施加 $+1$，在节点 $(0,0)$ 的 x 方向施加 $-1$，其他位置为零。\n- 测试用例 #2：$E = 1$, $\\nu = 0$, $t = 1$。载荷 $\\mathbf{f}$ 是一个确定性随机向量，经过投影以与所有刚体模态正交。\n- 测试用例 #3：$E = 2$, $\\nu = 0.25$, $t = 1$。载荷 $\\mathbf{f}$ 是一个均匀向下的节点载荷：在每个节点的 y 方向施加 $-1$，x 方向为零。\n\n对每个测试用例，按顺序生成以下输出：\n- 三个浮点数 $\\|\\mathbf{K} \\mathbf{r}_{1}\\|_{2}$、$\\|\\mathbf{K} \\mathbf{r}_{2}\\|_{2}$、$\\|\\mathbf{K} \\mathbf{r}_{3}\\|_{2}$。\n- 使用 $\\mathbf{u} = \\mathbf{K}^{+} \\mathbf{f}$ 计算的浮点数残差范数 $\\|\\mathbf{K}\\mathbf{u} - \\mathbf{f}\\|_{2}$。\n- $\\mathbf{f}$ 在刚体模态子空间上投影的浮点数量值。\n- 布尔检测标志，如果投影量值超过 $\\varepsilon = 10^{-10}$ 则定义为真，否则为假。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有三个测试用例的串联结果，格式为逗号分隔的列表，并用方括号括起来，即 $\\left[ \\text{case1\\_n1}, \\text{case1\\_n2}, \\text{case1\\_n3}, \\text{case1\\_res}, \\text{case1\\_proj}, \\text{case1\\_flag}, \\text{case2\\_n1}, \\dots, \\text{case3\\_flag} \\right]$。所有数字必须打印为不带单位的原始十进制值，布尔值必须以编程语言的原生布尔字面量形式（true 或 false）打印。",
            "solution": "所提出的问题是有效的。这是在计算固体力学领域中使用有限元法（FEM）的一个适定且有科学依据的练习。所有必要的数据，包括几何形状、材料属性和加载条件，都已提供，并且任务与线性弹性和数值线性代数的既定原理一致。该问题没有矛盾、歧义和事实错误。\n\n求解过程首先为平面应力条件下的常应变三角形（CST）单元建立理论框架。随后，为指定的双单元网格组装全局刚度矩阵。构造并验证了刚体模态。最后，对于每个测试用例，通过利用 Moore-Penrose 伪逆和将载荷向量投影到刚体模态子空间上来评估系统的可解性。\n\n**1. 单元公式**\n\n对于二维平面应力状态下的一个3节点三角形单元，常应变向量 $\\boldsymbol{\\varepsilon} = [\\varepsilon_x, \\varepsilon_y, \\gamma_{xy}]^\\top$ 与节点位移向量 $\\mathbf{u}_e = [u_{x1}, u_{y1}, u_{x2}, u_{y2}, u_{x3}, u_{y3}]^\\top$ 之间的关系由 $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u}_e$ 给出。节点坐标为 $(x_1, y_1)$, $(x_2, y_2)$ 和 $(x_3, y_3)$ 的单元的应变-位移矩阵 $\\mathbf{B}$ 为：\n$$\n\\mathbf{B} = \\frac{1}{2A_e}\n\\begin{bmatrix}\ny_2 - y_3 & 0 & y_3 - y_1 & 0 & y_1 - y_2 & 0 \\\\\n0 & x_3 - x_2 & 0 & x_1 - x_3 & 0 & x_2 - x_1 \\\\\nx_3 - x_2 & y_2 - y_3 & x_1 - x_3 & y_3 - y_1 & x_2 - x_1 & y_1 - y_2\n\\end{bmatrix}\n$$\n其中 $A_e$ 是单元面积。\n\n平面应力条件下的线性各向同性弹性本构关系为 $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$，其中弹性矩阵 $\\mathbf{D}$ 由下式给出：\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0 \\\\\n\\nu & 1 & 0 \\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix}\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。\n\n大小为 $6 \\times 6$ 的单元刚度矩阵 $\\mathbf{K}_e$ 源自虚功原理，计算如下：\n$$\n\\mathbf{K}_e = t A_e \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B}\n$$\n其中 $t$ 是单元厚度，给定为 $t=1$。\n\n**2. 全局刚度矩阵组装**\n\n系统由 $N=4$ 个节点组成，产生 $2N=8$ 个全局自由度（DOF），按 $\\mathbf{u} = [u_{x0}, u_{y0}, u_{x1}, u_{y1}, u_{x2}, u_{y2}, u_{x3}, u_{y3}]^\\top$ 的顺序排列。节点坐标指定为节点 $0:(0,0)$、节点 $1:(1,0)$、节点 $2:(1,1)$ 和节点 $3:(0,1)$。网格由两个单元组成：\n- 单元 1：节点 $(0, 1, 2)$。其自由度映射到全局自由度 $(0, 1, 2, 3, 4, 5)$。\n- 单元 2：节点 $(0, 2, 3)$。其自由度映射到全局自由度 $(0, 1, 4, 5, 6, 7)$。\n\n对于每个单元，我们计算其 $6 \\times 6$ 的刚度矩阵 $\\mathbf{K}_e$。通过将每个单元矩阵的贡献累加到相应的全局自由度位置，组装出 $8 \\times 8$ 的全局刚度矩阵 $\\mathbf{K}$。\n\n**3. 刚体模态**\n\n对于一个没有边界条件的结构（一个“浮动”结构），全局刚度矩阵 $\\mathbf{K}$ 是奇异的。其零空间由刚体模态（RBMs）张成。对于一个二维系统，存在 3 个刚体模态：两个平移和一个平面内旋转。这些模态由 8 维节点位移空间中的向量表示。\n- x 方向平移：$\\mathbf{r}_1 = [1, 0, 1, 0, 1, 0, 1, 0]^\\top$。\n- y 方向平移：$\\mathbf{r}_2 = [0, 1, 0, 1, 0, 1, 0, 1]^\\top$。\n- 绕原点 $(0,0)$ 旋转：坐标为 $(x_i, y_i)$ 的节点 $i$ 的位移是 $(u_{xi}, u_{yi}) = (-y_i, x_i)$。这给出了 $\\mathbf{r}_3 = [0, 0, 0, 1, -1, 1, -1, 0]^\\top$。\n\n一个关键性质是刚体运动不产生应变，因此不产生内力。在数学上，这意味着对于 $j=1, 2, 3$，$\\mathbf{K}\\mathbf{r}_j = \\mathbf{0}$。这通过计算 L2 范数 $\\|\\mathbf{K}\\mathbf{r}_j\\|_2$ 来验证，该范数在数值精度范围内必须为零。\n\n**4. 系统可解性与载荷向量分析**\n\n线性系统 $\\mathbf{K}\\mathbf{u} = \\mathbf{f}$ 有解的充要条件是载荷向量 $\\mathbf{f}$ 位于 $\\mathbf{K}$ 的列空间（值域）中。由于 $\\mathbf{K}$ 是对称的，其值域是其零空间的正交补。因此，存在解的充要条件是 $\\mathbf{f}$ 与零空间中的每个向量正交，即对于 $j=1, 2, 3$，$\\mathbf{r}_j^\\top \\mathbf{f} = 0$。这样的载荷向量是自平衡的。\n\n如果此条件成立，系统有无穷多个形如 $\\mathbf{u}_p + \\mathbf{u}_h$ 的解，其中 $\\mathbf{u}_p$ 是一个特解，$\\mathbf{u}_h$ 是刚体模态的任意线性组合。Moore-Penrose 伪逆 $\\mathbf{K}^{+}$ 提供了唯一的最小范数解 $\\mathbf{u} = \\mathbf{K}^{+}\\mathbf{f}$。如果 $\\mathbf{f}$ 在 $\\mathbf{K}$ 的值域内，则残差范数 $\\|\\mathbf{K}\\mathbf{u} - \\mathbf{f}\\|_2$ 将为零（在容差范围内）。\n\n如果 $\\mathbf{f}$ 不与刚体模态正交，那么它在 $\\mathbf{K}^\\top = \\mathbf{K}$ 的零空间中有一个分量，因此不在 $\\mathbf{K}$ 的值域内。在这种情况下，不存在精确解。伪逆仍然给出最小范数最小二乘解，该解最小化了 $\\|\\mathbf{K}\\mathbf{u} - \\mathbf{f}\\|_2$，但这个最小范数将是非零的。\n\n为了检测 $\\mathbf{f}$ 是否激发了刚体模态，我们将其投影到由 $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$ 张成的子空间上。首先，我们为此子空间构建一个标准正交基，例如，通过对矩阵 $\\mathbf{R} = [\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3]$ 应用 QR 分解来得到一个具有标准正交列的矩阵 $\\mathbf{Q}$。$\\mathbf{f}$ 在该子空间上的投影为 $\\mathbf{f}_{proj} = \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{f}$。此投影的量值为 $\\|\\mathbf{f}_{proj}\\|_2 = \\|\\mathbf{Q}^\\top \\mathbf{f}\\|_2$。如果该量值超过一个小容差 $\\varepsilon=10^{-10}$，则载荷没有被恰当平衡，并会激发刚体运动。\n\n算法通过为每个提供的测试用例实施这些步骤来进行。\n- 对于测试用例 #1，载荷是自平衡的，投影量值应接近于零。\n- 对于测试用例 #2，载荷被构造成与刚体模态正交，因此其投影量值也将接近于零。\n- 对于测试用例 #3，载荷代表一个净向下的力，因此不是自平衡的。它在刚体模态子空间上的投影将非零，并且最小二乘解的残差范数也将非零。",
            "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Solves a set of finite element analysis problems for a 2D elastic solid.\n    \"\"\"\n\n    # --- Nodal and Element Definitions ---\n    nodes = np.array([\n        [0.0, 0.0],  # Node 0\n        [1.0, 0.0],  # Node 1\n        [1.0, 1.0],  # Node 2\n        [0.0, 1.0],  # Node 3\n    ])\n    elements = [\n        [0, 1, 2],\n        [0, 2, 3]\n    ]\n    num_nodes = len(nodes)\n    num_dofs = 2 * num_nodes\n    thickness = 1.0\n\n    # --- Test Case Definitions ---\n    test_cases = [\n        {'E': 2.0, 'nu': 0.25, 'load_type': 'equilibrated'},\n        {'E': 1.0, 'nu': 0.0, 'load_type': 'projected_random'},\n        {'E': 2.0, 'nu': 0.25, 'load_type': 'uniform_downward'},\n    ]\n\n    all_results = []\n    \n    # --- Rigid Body Modes ---\n    r1 = np.tile([1.0, 0.0], num_nodes)  # x-translation\n    r2 = np.tile([0.0, 1.0], num_nodes)  # y-translation\n    r3 = np.zeros(num_dofs)  # rotation about origin\n    for i in range(num_nodes):\n        x, y = nodes[i]\n        r3[2 * i] = -y\n        r3[2 * i + 1] = x\n    \n    R = np.vstack([r1, r2, r3]).T\n    Q_rbm, _ = np.linalg.qr(R) # Orthonormal basis for RBM space\n\n    for case in test_cases:\n        E = case['E']\n        nu = case['nu']\n\n        # --- Assemble Global Stiffness Matrix K ---\n        K = np.zeros((num_dofs, num_dofs))\n        # Constitutive matrix D for plane stress\n        c = E / (1.0 - nu**2)\n        D = c * np.array([\n            [1.0, nu, 0.0],\n            [nu, 1.0, 0.0],\n            [0.0, 0.0, (1.0 - nu) / 2.0]\n        ])\n\n        for el_nodes in elements:\n            # Element coordinates\n            n1_coords, n2_coords, n3_coords = nodes[el_nodes]\n            x1, y1 = n1_coords\n            x2, y2 = n2_coords\n            x3, y3 = n3_coords\n\n            # Element area\n            area = 0.5 * np.linalg.det(np.array([[1, x1, y1], [1, x2, y2], [1, x3, y3]]))\n            \n            # B matrix\n            b1 = y2 - y3\n            b2 = y3 - y1\n            b3 = y1 - y2\n            c1 = x3 - x2\n            c2 = x1 - x3\n            c3 = x2 - x1\n            \n            B = (1.0 / (2.0 * area)) * np.array([\n                [b1, 0, b2, 0, b3, 0],\n                [0, c1, 0, c2, 0, c3],\n                [c1, b1, c2, b2, c3, b3]\n            ])\n\n            # Element stiffness matrix\n            Ke = thickness * area * (B.T @ D @ B)\n\n            # Assemble into global K\n            dofs = np.array([2*n for n in el_nodes for _ in range(2)]) + np.array([0,1]*len(el_nodes))\n            K[np.ix_(dofs, dofs)] += Ke\n\n        # --- Task 3: Verify Rigid Body Modes ---\n        norm_Kr1 = np.linalg.norm(K @ r1)\n        norm_Kr2 = np.linalg.norm(K @ r2)\n        norm_Kr3 = np.linalg.norm(K @ r3)\n        \n        # --- Define Load Vector f ---\n        f = np.zeros(num_dofs)\n        if case['load_type'] == 'equilibrated':\n            f[2 * 1 + 0] = 1.0  # +1 in x-dir at node 1 (1,0)\n            f[2 * 0 + 0] = -1.0 # -1 in x-dir at node 0 (0,0)\n        elif case['load_type'] == 'projected_random':\n            rng = np.random.default_rng(seed=1234) # Deterministic random\n            f_rand = rng.random(num_dofs)\n            # Project f_rand onto orthogonal complement of RBM space\n            f = f_rand - Q_rbm @ (Q_rbm.T @ f_rand)\n        elif case['load_type'] == 'uniform_downward':\n            for i in range(num_nodes):\n                f[2 * i + 1] = -1.0\n\n        # --- Task 4: Compute Minimum-Norm Solution and Residual ---\n        K_pinv = scipy.linalg.pinv(K)\n        u = K_pinv @ f\n        residual_norm = np.linalg.norm(K @ u - f)\n\n        # --- Task 5: Detect Load Projection on RBM Space ---\n        proj_mag = np.linalg.norm(Q_rbm.T @ f)\n        detection_flag = proj_mag > 1e-10\n        \n        # --- Collect Results for This Case ---\n        case_results = [\n            norm_Kr1,\n            norm_Kr2,\n            norm_Kr3,\n            residual_norm,\n            proj_mag,\n            str(detection_flag).lower()\n        ]\n        all_results.extend(case_results)\n\n    # --- Final Print ---\n    # Ensure raw float values are printed without scientific notation for small numbers\n    formatted_results = [f\"{x:.15e}\" if isinstance(x, float) else x for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "本练习将抽象的有限元理论与具体的地球物理问题联系起来。我们将探索如何在重力场中对一个静态分层介质进行建模，并验证其静水压力平衡，这是地球物理学中的一个基石概念。通过这个实践，您将学习如何为复杂的体力（如作用在密度分层介质上的重力）构建一致的节点载荷向量，并处理初始应力场 。这些技能对于模拟岩石圈应力、地壳均衡以及其他重力驱动的地质过程至关重要。",
            "id": "3588957",
            "problem": "考虑一个二维垂直矩形域 $\\Omega = [0,W] \\times [0,H]$，该区域代表一个处于平面应变状态且平面外厚度为单位1的地球物理柱。设垂直坐标为 $z$，向下为正，顶边界位于 $z=0$，底边界位于 $z=H$。材料为线性弹性、均匀、各向同性，其杨氏模量为 $E$，泊松比为 $\\nu$。重力加速度为 $\\mathbf{g} = (0,g)$，其中 $g$ 为严格正值，单位为 $\\mathrm{m/s^2}$。质量密度是分层的，仅取决于 $z$，是由水平层定义的分段常数函数 $\\rho(z)$。\n\n假设小应变运动学、柯西应力对称性和静力平衡（无惯性）。从线性动量平衡和任意容许虚位移场的平衡弱形式出发，推导所需的有限元表达式，以实现以下目标：\n- 对于双线性四边形（四节点）单元，使用标准的双线性形函数和合适的高斯求积进行精确面积分，从而形成与重力相关的一致的单元体力荷载向量。\n- 形成与施加的初始应力场相关的单元内部节点力向量。初始应力场为静水压力（各向同性），即 $\\boldsymbol{\\sigma}_0(z) = -p(z)\\,\\mathbf{I}$，其中压力 $p(z)$ 满足 $dp/dz = \\rho(z)\\,g$ 且 $p(H)=0$。根据给定的分层 $\\rho(z)$ 显式地构造 $p(z)$。\n- 包含与静水初始应力一致的边界面力贡献，即在每个带有外法向单位法向量 $\\mathbf{n}$ 的边界段上，$\\mathbf{t}(z) = \\boldsymbol{\\sigma}_0(z)\\,\\mathbf{n}$。\n\n通过将 $\\Omega$ 划分为 $N_x \\times N_z$ 个轴对齐的双线性四边形单元来定义有限元网格，每个单元在母坐标 $(\\xi,\\eta)\\in[-1,1]^2$ 中具有标准的四节点参数化。使用平面应变和单位厚度。组装全局向量：\n- 通过在整个域上对体力 $\\rho(z)\\,\\mathbf{g}$ 与形函数进行积分，得到重力荷载向量 $\\mathbf{f}_g$。\n- 通过在整个域上对应变-位移矩阵的转置乘以 $\\boldsymbol{\\sigma}_0$ 进行积分，得到初始应力内力向量 $\\mathbf{f}_{\\sigma_0}$。\n- 通过沿所有域边界对静水面力进行积分，得到边界面力向量 $\\mathbf{f}_t$。\n\n使用组装好的向量，在零位移 $\\mathbf{u}_0 = \\mathbf{0}$ 处测试静水压力平衡。在一致的弱形式中，如果静水初始应力和重力完全平衡，则在 $\\mathbf{u}_0=\\mathbf{0}$ 处的平衡要求全局残差\n$$\n\\mathbf{r}(\\mathbf{u}_0) = \\mathbf{f}_{\\sigma_0} - \\mathbf{f}_g - \\mathbf{f}_t\n$$\n为零向量。为每个测试案例计算 $\\mathbf{r}(\\mathbf{u}_0)$ 的无穷范数（最大绝对分量）。\n\n您必须按照以下要求实现完整的计算：\n- 在积分中使用精确的质量密度分层。如果任何单元跨越层界面，则将其垂直积分细分为与密度层对齐的子区域，并在每个子区域中应用高斯求积。\n- 对面积分，在每个参数化方向上使用双线性四边形单元和两点高斯求积；对一维边积分，使用两点高斯求积。\n- 采用平面应变和平面外单位厚度。\n- 重力加速度以 $\\mathrm{m/s^2}$ 表示，弹性模量以 $\\mathrm{Pa}$ 表示，尺寸以 $\\mathrm{m}$ 表示，密度以 $\\mathrm{kg/m^3}$ 表示，力以 $\\mathrm{N}$ 表示。以 $\\mathrm{N}$ 为单位报告残差范数。\n\n测试套件：\n对于下面的三个参数集中的每一个，组装 $\\mathbf{f}_g$、$\\mathbf{f}_{\\sigma_0}$ 和 $\\mathbf{f}_t$，计算 $\\|\\mathbf{r}(\\mathbf{u}_0)\\|_\\infty$，并按指定的最终格式将三个结果作为单行输出。\n\n- 案例 A（均匀层，理想情况）：\n  - $W = 100\\,\\mathrm{m}$, $H = 1000\\,\\mathrm{m}$, $N_x = 2$, $N_z = 2$。\n  - $E = 3.0 \\times 10^{10}\\,\\mathrm{Pa}$, $\\nu = 0.25$, $g = 9.81\\,\\mathrm{m/s^2}$。\n  - 分层：一个层 $[0,1000]$，其 $\\rho = 2200\\,\\mathrm{kg/m^3}$。\n\n- 案例 B（两个层，单元界面未对齐）：\n  - $W = 80\\,\\mathrm{m}$, $H = 900\\,\\mathrm{m}$, $N_x = 3$, $N_z = 3$。\n  - $E = 2.5 \\times 10^{10}\\,\\mathrm{Pa}$, $\\nu = 0.30$, $g = 9.81\\,\\mathrm{m/s^2}$。\n  - 分层：$[0,500]$ 层，$\\rho = 2000\\,\\mathrm{kg/m^3}$；$[500,900]$ 层，$\\rho = 2500\\,\\mathrm{kg/m^3}$。\n\n- 案例 C（薄低密度层，边界情况）：\n  - $W = 120\\,\\mathrm{m}$, $H = 1000\\,\\mathrm{m}$, $N_x = 4$, $N_z = 5$。\n  - $E = 3.5 \\times 10^{10}\\,\\mathrm{Pa}$, $\\nu = 0.20$, $g = 9.81\\,\\mathrm{m/s^2}$。\n  - 分层：$[0,300]$ 层，$\\rho = 1800\\,\\mathrm{kg/m^3}$；$[300,305]$ 层，$\\rho = 100\\,\\mathrm{kg/m^3}$；$[305,1000]$ 层，$\\rho = 2600\\,\\mathrm{kg/m^3}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个由默认字符串转换四舍五入的残差范数，格式为方括号括起来的逗号分隔列表（例如，“[resultA,resultB,resultC]”），其中每个结果是一个浮点数，代表相应案例的 $\\|\\mathbf{r}(\\mathbf{u}_0)\\|_\\infty$（单位为 N）。",
            "solution": "该问题要求使用有限元法验证二维地球物理柱的静水压力平衡。通过计算残余力向量 $\\mathbf{r}(\\mathbf{u}_0)$ 来验证零位移时的平衡状态，对于精确解，该向量必须为零向量。问题指定了使用双线性四边形单元和高斯求积的特定数值实现，因此我们预计由于近似误差，残差会很小但非零。\n\n残差向量定义为 $\\mathbf{r}(\\mathbf{u}_0) = \\mathbf{f}_{\\sigma_0} - \\mathbf{f}_g - \\mathbf{f}_t$，其中 $\\mathbf{f}_g$ 是重力荷载向量，$\\mathbf{f}_{\\sigma_0}$ 是由初始静水压力产生的内力向量，$\\mathbf{f}_t$ 是与初始应力一致的边界面力向量。我们将对这些向量逐一进行公式化和计算。\n\n### 1. 理论框架\n\n**离散化**：将域 $\\Omega = [0,W] \\times [0,H]$ 离散化为 $N_x \\times N_z$ 个双线性四边形单元组成的网格。对于一个单元 $e$，其几何形状和位移场通过从母单元 $(\\xi, \\eta) \\in [-1,1]^2$ 进行的等参映射，由节点值插值得到。我们对物理单元采用标准的逆时针节点编号（1-2-3-4），从左上角开始，并将其映射到母单元的标准节点顺序（左下、右下、右上、左上），这会得到一个正的雅可比行列式 $\\det(\\mathbf{J}) = w_e h_e / 4$，其中 $w_e$ 和 $h_e$ 分别是单元的宽度和高度。\n\n**静水压力**：初始应力为静水压力，$\\boldsymbol{\\sigma}_0(z) = -p(z)\\mathbf{I}$，其中 $p(z)$ 是压力。在给定条件 $dp/dz = \\rho(z)g$ 和 $p(H)=0$ 的情况下，任意深度 $z$ 处的压力是其下方材料柱的重量：\n$$\np(z) = \\int_z^H \\rho(s) g \\, ds\n$$\n由于密度 $\\rho(z)$ 是分段常数，因此 $p(z)$ 是一个关于 $z$ 的连续分段线性函数。\n\n**平衡的弱形式**：在零位移（$\\mathbf{u}=\\mathbf{0}$，因此 $\\boldsymbol{\\sigma}=\\boldsymbol{\\sigma}_0$）下评估的虚功原理指出，内力必须与外力平衡：\n$$\n\\int_{\\Omega} \\mathbf{B}^T \\boldsymbol{\\sigma}_0 \\, d\\Omega = \\int_{\\Omega} \\mathbf{N}^T \\mathbf{b} \\, d\\Omega + \\int_{\\partial\\Omega} \\mathbf{N}^T \\mathbf{t} \\, d\\Gamma\n$$\n其中 $\\mathbf{N}$ 是形函数矩阵，$\\mathbf{B}$ 是应变-位移矩阵，$\\mathbf{b}=[0, \\rho(z)g]^T$ 是体力，$\\mathbf{t}$ 是边界面力。这三项分别对应于 $\\mathbf{f}_{\\sigma_0}$、$\\mathbf{f}_g$ 和 $\\mathbf{f}_t$。虽然在连续意义上，通过精确积分，这些项是相等的，但使用有限精度求积法进行数值计算会引入差异。\n\n### 2. 单元力向量的公式化\n\n我们现在为组装过程构建单元级向量的公式。所有积分都使用指定的求积法则进行。关键挑战在于处理跨越密度层边界的单元。对于此类单元，在 $\\eta \\in [-1, 1]$ 上的垂直积分被分割成子区间，并对每个子区间应用高斯求积。\n\n**A. 重力荷载向量 ($\\mathbf{f}_g^e$)**：\n单元局部节点 $i$ 上重力的 $z$ 分量为：\n$$\nf_{giz}^e = \\int_{\\Omega_e} N_i(x,z) \\rho(z) g \\, d\\Omega = g \\int_{-1}^1\\int_{-1}^1 N_i(\\xi, \\eta) \\rho(z(\\eta)) \\det(\\mathbf{J}) \\, d\\xi d\\eta\n$$\n对于双线性单元，对 $\\xi$ 进行解析积分可将其简化为：\n$$\nf_{giz}^e = g \\frac{w_e h_e}{8} \\int_{-1}^1 (1 + \\eta_i \\eta) \\rho(z(\\eta)) \\, d\\eta\n$$\n其中 $(\\xi_i, \\eta_i)$ 是节点 $i$ 的母坐标。剩下的一维积分将进行数值计算。\n\n**B. 初始应力力向量 ($\\mathbf{f}_{\\sigma_0}^e$)**：\n节点 $i$ 上由初始应力产生的内力为：\n$$\n\\mathbf{f}_{\\sigma_0,i}^e = \\int_{\\Omega_e} \\mathbf{B}_i^T \\boldsymbol{\\sigma}_0(z) \\, d\\Omega = \\int_{\\Omega_e} \\begin{bmatrix} -p(z) \\frac{\\partial N_i}{\\partial x} \\\\ -p(z) \\frac{\\partial N_i}{\\partial z} \\end{bmatrix} d\\Omega\n$$\n使用等参映射并对 $\\xi$ 进行解析积分，可得：\n$$\nf_{\\sigma_0,ix}^e = -\\frac{\\xi_i h_e}{4} \\int_{-1}^1 (1 + \\eta_i \\eta) p(z(\\eta)) \\, d\\eta\n$$\n$$\nf_{\\sigma_0,iz}^e = -\\frac{\\eta_i w_e}{4} \\int_{-1}^1 p(z(\\eta)) \\, d\\eta\n$$\n这些一维积分是数值计算的。被积函数是线性函数（$N_i$）和分段线性函数（$p(z)$）的乘积，结果是分段二次函数，对于这类函数，两点高斯求积不是精确的。\n\n**C. 边界面力向量 ($\\mathbf{f}_t^e$)**：\n面力 $\\mathbf{t} = \\boldsymbol{\\sigma}_0\\mathbf{n} = -p(z)\\mathbf{n}$ 应用于域边界。\n-   **顶边界 ($z=0$):** $\\mathbf{n}=(0,-1)$，因此 $\\mathbf{t}=(0, p(0))$。这贡献于节点力的 $z$ 分量。\n-   **左边界 ($x=0$):** $\\mathbf{n}=(-1,0)$，因此 $\\mathbf{t}=(p(z), 0)$。这贡献于 $x$ 分量。\n-   **右边界 ($x=W$):** $\\mathbf{n}=(1,0)$，因此 $\\mathbf{t}=(-p(z), 0)$。这也贡献于 $x$ 分量。\n-   **底边界 ($z=H$):** $p(H)=0$，因此 $\\mathbf{t}=\\mathbf{0}$。\n对于垂直边界上的单元边，该边上节点 $j$ 的力通过一维积分计算，例如，在左边界上：\n$$\nf_{tx,j}^e = \\int_{z_{edge,1}}^{z_{edge,2}} N_j^{\\text{1D}}(z) p(z) \\, dz = \\frac{h_e}{2} \\int_{-1}^1 N_j^{\\text{1D}}(\\eta) p(z(\\eta)) \\, d\\eta\n$$\n这个一维积分包含一个分段二次的被积函数，也使用两点高斯求积（在层边界处分割）进行评估，这会引入数值误差。\n\n### 3. 实现细节\n\n该实现遍历每个单元，计算三个单元级力向量（$\\mathbf{f}_g^e, \\mathbf{f}_{\\sigma_0}^e, \\mathbf{f}_t^e$），并将它们组装成全局向量。计算的核心是一个稳健的一维积分函数，它通过细分积分域并在每个子区间上应用两点高斯求积来处理分层介质。最后，计算全局残差 $\\mathbf{r}$，并报告其无穷范数 $\\|\\mathbf{r}\\|_\\infty$。非零结果量化了由于使用两点高斯求积近似二次或更高阶多项式的积分而引入的不一致性。",
            "answer": "```python\nimport numpy as np\n\n# Global constants for 2-point Gauss quadrature\nGAUSS_POINTS = np.array([-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)])\nGAUSS_WEIGHTS = np.array([1.0, 1.0])\n\ndef solve():\n    \"\"\"\n    Main driver function to process all test cases defined in the problem.\n    \"\"\"\n    test_cases = [\n        # Case A: Uniform layer, happy path\n        {\n            \"W\": 100.0, \"H\": 1000.0, \"Nx\": 2, \"Nz\": 2, \"g\": 9.81,\n            \"layers\": [(0.0, 1000.0, 2200.0)],\n        },\n        # Case B: Two layers, non-aligned element interfaces\n        {\n            \"W\": 80.0, \"H\": 900.0, \"Nx\": 3, \"Nz\": 3, \"g\": 9.81,\n            \"layers\": [(0.0, 500.0, 2000.0), (500.0, 900.0, 2500.0)],\n        },\n        # Case C: Thin low-density layer, edge case\n        {\n            \"W\": 120.0, \"H\": 1000.0, \"Nx\": 4, \"Nz\": 5, \"g\": 9.81,\n            \"layers\": [\n                (0.0, 300.0, 1800.0),\n                (300.0, 305.0, 100.0),\n                (305.0, 1000.0, 2600.0),\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        residual_norm = compute_residual(**case)\n        results.append(residual_norm)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef create_pressure_function(H, g, layers):\n    \"\"\"\n    Creates a callable function p(z) for the hydrostatic pressure.\n    The pressure is pre-calculated at layer interfaces for efficiency.\n    \"\"\"\n    p_at_interface = {H: 0.0}\n    # Integrate from bottom to top\n    for i in range(len(layers) - 1, -1, -1):\n        z_start, z_end, rho = layers[i]\n        layer_overburden = rho * g * (z_end - z_start)\n        p_at_interface[z_start] = p_at_interface.get(z_end, 0.0) + layer_overburden\n\n    def p(z):\n        if z >= H: return 0.0\n        # Find the layer containing z\n        for z_start, z_end, rho in layers:\n            if z_start <= z and z < z_end:\n                # Pressure is from layers below plus contribution from within the layer\n                return p_at_interface.get(z_end, 0.0) + rho * g * (z_end - z)\n        # Handle the case where z is exactly the bottom boundary\n        if z == H:\n            return 0.0\n        # If z is on a boundary, it should have been caught. If not, it's an issue.\n        # However, for robustness let's check the last layer inclusively for its end point.\n        z_start, z_end, rho = layers[-1]\n        if z_start <= z and z <= z_end:\n            return p_at_interface.get(z_end, 0.0) + rho * g * (z_end - z)\n        return 0.0\n\n    return p\n\ndef integrate_1d_layered(integrand_func, z_min, z_max, layers):\n    \"\"\"\n    Numerically integrates a 1D function over [z_min, z_max], splitting at layer boundaries.\n    The integration is transformed to parent coordinates eta in [-1, 1].\n    \"\"\"\n    h_e = z_max - z_min\n    z_c = z_min + h_e / 2.0\n    \n    eta_splits = [-1.0, 1.0]\n    for z_start, _, _ in layers:\n        if z_min < z_start and z_start < z_max:\n            eta_split = (z_start - z_c) / (h_e / 2.0)\n            eta_splits.append(eta_split)\n    eta_splits = sorted(list(set(eta_splits)))\n\n    total_integral = 0.0\n    for i in range(len(eta_splits) - 1):\n        eta_a, eta_b = eta_splits[i], eta_splits[i+1]\n        \n        # Map [eta_a, eta_b] to [-1, 1] for Gauss quadrature\n        transform = lambda zeta: 0.5 * (eta_b - eta_a) * zeta + 0.5 * (eta_a + eta_b)\n        jacobian_1d = 0.5 * (eta_b - eta_a)\n        \n        integral_piece = 0.0\n        for k in range(len(GAUSS_POINTS)):\n            eta_val = transform(GAUSS_POINTS[k])\n            z_val = z_c + (h_e / 2.0) * eta_val\n            integrand_val = integrand_func(eta_val, z_val)\n            integral_piece += GAUSS_WEIGHTS[k] * integrand_val\n        \n        total_integral += jacobian_1d * integral_piece\n        \n    return total_integral\n\ndef compute_element_vectors(x_min, z_min, w_e, h_e, g, layers, p_func, H, W, ix, iz, Nx, Nz):\n    \"\"\"\n    Computes and returns element-level force vectors fg, f_sigma0, and f_t.\n    \"\"\"\n    fg_e_z = np.zeros(4)\n    f_sigma0_e = np.zeros(8)\n    ft_e = np.zeros(8)\n\n    xi_eta_nodes = np.array([[-1, -1], [1, -1], [1, 1], [-1, 1]]) # Local node coords\n\n    def get_rho(z):\n        for z_start, z_end, rho_val in layers:\n            if z_start <= z and z < z_end:\n                 return rho_val\n        # Handle the case where z is exactly the bottom boundary\n        if z == H:\n            return layers[-1][2]\n        raise ValueError(f\"Density not found for z={z}\")\n\n    # ===== 1. Gravity Load Vector f_g (z-components only) =====\n    for i in range(4):\n        _, eta_i = xi_eta_nodes[i]\n        def integrand_fg(eta, z): return g * get_rho(z) * (1.0 + eta_i * eta)\n        integral_val = integrate_1d_layered(integrand_fg, z_min, z_min + h_e, layers)\n        fg_e_z[i] = (w_e * h_e / 8.0) * integral_val\n\n    # ===== 2. Initial Stress Vector f_sigma0 =====\n    for i in range(4):\n        xi_i, eta_i = xi_eta_nodes[i]\n        # X-component\n        def integrand_x(eta, z): return (1.0 + eta_i * eta) * p_func(z)\n        integral_x = integrate_1d_layered(integrand_x, z_min, z_min + h_e, layers)\n        f_sigma0_e[2 * i] = - (xi_i * h_e / 4.0) * integral_x\n        \n        # Z-component\n        def integrand_z(eta, z): return p_func(z)\n        integral_z = integrate_1d_layered(integrand_z, z_min, z_min + h_e, layers)\n        f_sigma0_e[2 * i + 1] = - (eta_i * w_e / 4.0) * integral_z\n\n    # ===== 3. Boundary Traction Vector f_t =====\n    if iz == 0:  # Top boundary (z=0)\n        p0 = p_func(0.0)\n        ft_e[2*0 + 1] += p0 * w_e / 2.0  # Node 1 z-comp\n        ft_e[2*1 + 1] += p0 * w_e / 2.0  # Node 2 z-comp\n\n    if ix == 0:  # Left boundary (x=0)\n        def integrand_l1(eta, z): return p_func(z) * 0.5 * (1.0 - eta)\n        def integrand_l4(eta, z): return p_func(z) * 0.5 * (1.0 + eta)\n        ft_e[2*0] += (h_e/2.0) * integrate_1d_layered(integrand_l1, z_min, z_min+h_e, layers) # Node 1 x-comp\n        ft_e[2*3] += (h_e/2.0) * integrate_1d_layered(integrand_l4, z_min, z_min+h_e, layers) # Node 4 x-comp\n\n    if ix == Nx - 1:  # Right boundary (x=W)\n        def integrand_r2(eta, z): return -p_func(z) * 0.5 * (1.0 - eta)\n        def integrand_r3(eta, z): return -p_func(z) * 0.5 * (1.0 + eta)\n        ft_e[2*1] += (h_e/2.0) * integrate_1d_layered(integrand_r2, z_min, z_min+h_e, layers) # Node 2 x-comp\n        ft_e[2*2] += (h_e/2.0) * integrate_1d_layered(integrand_r3, z_min, z_min+h_e, layers) # Node 3 x-comp\n\n    return fg_e_z, f_sigma0_e, ft_e\n\ndef compute_residual(W, H, Nx, Nz, g, layers):\n    \"\"\"\n    Assembles global vectors and computes the infinity norm of the residual.\n    \"\"\"\n    dx, dz = W / Nx, H / Nz\n    num_nodes_x, num_nodes_z = Nx + 1, Nz + 1\n    num_dofs = 2 * num_nodes_x * num_nodes_z\n\n    f_g, f_sigma0, f_t = np.zeros(num_dofs), np.zeros(num_dofs), np.zeros(num_dofs)\n    p_func = create_pressure_function(H, g, layers)\n\n    for iz in range(Nz):\n        for ix in range(Nx):\n            x_min, z_min = ix * dx, iz * dz\n            \n            fg_e_z, f_sigma0_e, ft_e = compute_element_vectors(\n                x_min, z_min, dx, dz, g, layers, p_func, H, W, ix, iz, Nx, Nz)\n            \n            # Global node indices for the current element, ordered CCW from top-left\n            node_indices = [\n                iz * num_nodes_x + ix,              # top-left\n                iz * num_nodes_x + ix + 1,            # top-right\n                (iz + 1) * num_nodes_x + ix + 1,      # bottom-right\n                (iz + 1) * num_nodes_x + ix,        # bottom-left\n            ]\n            # Map local node order (CCW from parent's bottom-left) to global order\n            # My local 0 (xi-1,eta-1) -> physical top-left (global node index 0)\n            # My local 1 (xi+1,eta-1) -> physical top-right (global node index 1)\n            # My local 2 (xi+1,eta+1) -> physical bottom-right (global node index 2)\n            # My local 3 (xi-1,eta+1) -> physical bottom-left (global node index 3)\n            # This is a direct mapping in this implementation due to z being positive down\n            \n            # Assemble\n            for i in range(4):\n                glob_idx = node_indices[i]\n                dof_x, dof_z = 2 * glob_idx, 2 * glob_idx + 1\n\n                f_g[dof_z] += fg_e_z[i]\n                \n                f_sigma0[dof_x] += f_sigma0_e[2 * i]\n                f_sigma0[dof_z] += f_sigma0_e[2 * i + 1]\n                \n                f_t[dof_x] += ft_e[2 * i]\n                f_t[dof_z] += ft_e[2 * i + 1]\n\n    residual = f_sigma0 - f_g - f_t\n    return np.max(np.abs(residual))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "这项高级实践旨在解决在地球动力学模拟中常见的关键数值挑战：体积锁定和沙漏不稳定性。您将亲手实现一种基于散度的稳定化方法，以克服由减缩积分技术和近不可压缩材料（泊松比 $\\nu \\to 0.5$）共同引发的数值问题 。通过分析和修正单元刚度矩阵，您将学会如何构建在模拟挑战性材料行为时既高效又鲁棒的有限元模型。",
            "id": "3588945",
            "problem": "考虑一个四节点的等参双线性四边形单元，在平面应变条件下的二维小应变、线性弹性问题。位移场由双线性形函数插值，材料为近不可压缩材料，其泊松比接近$0.5$。问题的基本出发点是虚功原理以及相关的应变-位移关系和本构关系。您必须基于这些基础理论，推导单元刚度矩阵和载荷向量，检验减缩积分对单元刚度的影响，并设计一种能保持载荷一致性的、基于散度的稳定化方法。\n\n使用的基本原理如下：\n- 虚功原理：对于任何容许的虚位移场，内虚功等于外虚功。\n- 小应变运动学：无穷小应变张量是位移的对称梯度。\n- 平面应变条件下的线弹性本构定律。\n- 用于数值积分的等参双线性插值和标准高斯积分法。\n\n在以下设定下进行分析：\n- 几何：一个双线性四边形单元，其节点的物理坐标$(x,y)$（单位：米）为$\\{(0,0),(1,0),(1,1),(0,1)\\}$。在平面外方向上使用单位厚度。单元域记为$\\Omega_e$，其面积为$|\\Omega_e|$。\n- 位移：节点位移向量 $d_e \\in \\mathbb{R}^8$，按$[u_{1x},u_{1y},u_{2x},u_{2y},u_{3x},u_{3y},u_{4x},u_{4y}]^T$顺序排列，单位为米。\n- 材料：杨氏模量$E$，单位为帕斯卡；泊松比$\\nu$（无量纲），由这些参数确定平面应变本构矩阵。\n- 体力：恒定向量 $b = (b_x,b_y)$，单位为牛顿每立方米。\n- 积分法：对于减缩积分刚度矩阵，在单元中心使用单高斯点的减缩积分；对于全积分和稳定项，使用标准的$2 \\times 2$高斯积分。\n- 稳定化设计参数：一个正常数$\\tau$，其选择与剪切模量成比例，用于正则化零能模式，同时不污染近不可压缩极限。\n\n需要完成的任务：\n1) 从虚功原理和小应变运动学出发，推导通过在单元中心的单个高斯点上计算双线性形式得到的单元减缩积分刚度矩阵$K_e^{\\text{red}}$。确保使用等参映射和双线性形函数，在相应高斯点处构造应变-位移矩阵$B(\\xi,\\eta)$，并使用平面应变本构矩阵$C(E,\\nu)$。\n2) 使用相同的基础出发点，推导形式如下的基于散度的稳定化矩阵\n$$\nK_{\\text{stab}} = \\tau \\int_{\\Omega_e} H^T H \\, d\\Omega,\n$$\n其中$H$将节点位移映射到位移散度，即对于节点位移$d_e$，插值位移的散度为$(\\nabla \\cdot u_h) = H d_e$。用双线性形函数的空间导数在积分点处表示$H$，并使用标准的$2 \\times 2$高斯积分计算$K_{\\text{stab}}$。指定$\\tau$的选择方式，使其用基本材料和几何尺度表示，且量纲一致，并且不会降低近不可压缩极限下的性能。\n3) 从虚功原理中带有恒定体力的外力功项出发，推导一致节点体力向量\n$$\nf_e = \\int_{\\Omega_e} N^T b \\, d\\Omega,\n$$\n其中$N$是将节点位移映射到场的双线性形函数矩阵。使用标准的$2 \\times 2$高斯积分计算该向量，并解析地验证对于此单元上的恒定体力$b$、单位厚度和面积$|\\Omega_e|$，该积分必须等于什么值。\n4) 从第一性原理出发，解释为什么添加$K_{\\text{stab}}$不需要对一致体力向量做任何修改就能保持对恒定体力的载荷一致性，以及为什么稳定化不应对刚体运动引入虚假的功。\n5) 数值研究减缩积分和所提出的稳定化方法对刚度矩阵谱的影响，包括其零空间的维数和移除刚体模态后矩阵的条件数。\n\n实现一个程序，对以下测试套件执行上述任务。使用指定的物理单位：长度单位为米，杨氏模量单位为帕斯卡，体力单位为牛顿每立方米。不涉及角度。当需要数值容差来判断特征值是否有效为零时，使用一个相对阈值，即数值小于最大特征值绝对值的$10^{-8}$倍时，视为零。\n\n参数值和测试套件：\n- 单元节点坐标：$(0,0)$、$(1,0)$、$(1,1)$、$(0,1)$，单位为米。单位厚度。\n- 材料参数：$E = 10^6$帕斯卡，$\\nu = 0.4999$（无量纲）。\n- 稳定化缩放：选择$\\tau = \\beta \\, \\mu \\, h^2$，其中$\\mu$是由$(E,\\nu)$在平面应变条件下确定的剪切模量，$h = \\sqrt{|\\Omega_e|}$。使用$\\beta = 1/3$（无量纲）。对于此单元，$|\\Omega_e| = 1$平方米，因此$h = 1$米。\n- 用于载荷一致性检查的体力：$b = (3.2,-1.7)$牛顿每立方米。\n\n您的程序必须：\n- 组装并存储以下单元矩阵：\n  - 使用单元中心的单点减缩积分得到的$K_e^{\\text{red}}$。\n  - 使用标准的$2 \\times 2$高斯积分得到的$K_e^{\\text{full}}$。\n  - 使用标准的$2 \\times 2$高斯积分和所选的$\\tau$得到的$K_{\\text{stab}}$。\n  - $K_e^{\\text{tot}} = K_e^{\\text{red}} + K_{\\text{stab}}$。\n- 使用$2 \\times 2$高斯积分计算一致体力向量$f_e$，并将其与在$\\Omega_e$上恒定体力$b$所对应的解析值进行比较。\n- 计算以下量化输出：\n  1) 一个整数，等于$K_e^{\\text{red}}$的特征值中小于有效零阈值的数量（零空间的维数）。\n  2) 一个整数，等于$K_e^{\\text{tot}}$的特征值中小于有效零阈值的数量。\n  3) 一个浮点数，等于数值积分得到的$f_e$与恒定体力$b$对应的解析$f_e$之间的逐分量最大绝对差值。\n  4) 一个布尔值，指示$f_e$中节点力分量的总和是否等于单元上的总体力，即在相同的数值容差内，$\\sum_i (f_{e,ix}, f_{e,iy})$是否等于$(b_x |\\Omega_e|, b_y |\\Omega_e|)$。\n  5) 一个浮点数，等于$K_e^{\\text{full}}$限制在其正谱上的条件数的$\\log_{10}$值（最大正特征值除以最小正特征值）。\n  6) 一个浮点数，等于$K_e^{\\text{tot}}$限制在其正谱上的条件数的$\\log_{10}$值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按上述顺序聚合的结果，形式为方括号内以逗号分隔的列表。例如，生成形如$[r_1,r_2,r_3,r_4,r_5,r_6]$的输出，其中$r_1$和$r_2$是整数，$r_3$、$r_5$和$r_6$是浮点数，$r_4$是布尔值。",
            "solution": "该问题要求对一个平面应变条件下的四节点四边形有限元进行全面的推导和数值实现，重点关注近不可压缩性带来的挑战。我将首先建立理论框架，然后详细阐述所要求的具体推导和分析。\n\n### 1. 理论基础：虚功原理与有限元离散化\n\n实体力学有限元方法的基础是虚功原理。对于一个占据区域$V$且边界为$\\Gamma$的物体，在体力$b$和面力$\\bar{t}$作用下处于平衡状态，该原理指出，对于任何运动学容许的虚位移场$\\delta u$，内虚功等于外虚功：\n$$\n\\delta W_{\\text{int}} = \\delta W_{\\text{ext}}\n$$\n$$\n\\int_V \\delta\\varepsilon^T \\sigma \\, dV = \\int_V \\delta u^T b \\, dV + \\int_{\\Gamma_t} \\delta u^T \\bar{t} \\, d\\Gamma\n$$\n在这里，$\\sigma$是柯西应力张量，$\\varepsilon$是无穷小应变张量，两者均采用Voigt标记法。虚应变为$\\delta\\varepsilon$。对于小应变线性弹性问题，本构关系为$\\sigma = C \\varepsilon$，应变-位移关系为$\\varepsilon = \\mathcal{L}u$，其中$\\mathcal{L}$是一个微分算子。\n\n在有限元方法中，区域被离散化为单元。在一个单元$\\Omega_e$（体积为$V_e$）内，位移场$u$及其变分$\\delta u$通过形函数矩阵$N$由节点值$d_e$和$\\delta d_e$插值得到：\n$$\nu(x) = N(x) d_e \\quad \\text{and} \\quad \\delta u(x) = N(x) \\delta d_e\n$$\n应变通过包含形函数空间导数的应变-位移矩阵$B$与节点位移相关联：\n$$\n\\varepsilon(x) = B(x) d_e \\quad \\text{and} \\quad \\delta\\varepsilon(x) = B(x) \\delta d_e\n$$\n将这些关系代入单个单元的虚功方程（本问题中忽略面力）可得：\n$$\n\\int_{V_e} (B \\delta d_e)^T C (B d_e) \\, dV = \\int_{V_e} (N \\delta d_e)^T b \\, dV\n$$\n由于$\\delta d_e$是任意的，这导出了单元方程组$K_e d_e = f_e$，其中单元刚度矩阵$K_e$和一致节点力向量$f_e$为：\n$$\nK_e = \\int_{V_e} B^T C B \\, dV \\quad \\text{and} \\quad f_e = \\int_{V_e} N^T b \\, dV\n$$\n对于单位厚度$t=1$的二维问题，体积积分$dV$变为面积积分$d\\Omega$。积分在参考单元域$(\\xi, \\eta) \\in [-1, 1]^2$上使用高斯积分法进行数值计算：\n$$\nK_e = \\int_{-1}^1 \\int_{-1}^1 B(\\xi, \\eta)^T C B(\\xi, \\eta) \\det(J(\\xi, \\eta)) \\, t \\, d\\xi d\\eta\n$$\n其中$J$是从参考坐标到物理坐标的等参映射的雅可比矩阵。\n\n### 2. 等参双线性单元\n\n单元节点位于$\\{(0,0), (1,0), (1,1), (0,1)\\}$。从参考坐标$(\\xi, \\eta)$到物理坐标$(x,y)$的映射为$x(\\xi, \\eta) = \\sum_i N_i(\\xi, \\eta) x_i$和$y(\\xi, \\eta) = \\sum_i N_i(\\xi, \\eta) y_i$。对于给定的节点，这导致了仿射映射$x = \\frac{1}{2}(1+\\xi)$和$y = \\frac{1}{2}(1+\\eta)$。该映射的雅可比矩阵是常数：\n$$\nJ = \\begin{pmatrix} \\partial x / \\partial \\xi & \\partial y / \\partial \\xi \\\\ \\partial x / \\partial \\eta & \\partial y / \\partial \\eta \\end{pmatrix} = \\begin{pmatrix} 1/2 & 0 \\\\ 0 & 1/2 \\end{pmatrix}\n$$\n其行列式为$\\det(J) = 1/4$。形函数$N_i$的空间导数通过雅可比矩阵的逆矩阵求得：$\\begin{pmatrix} N_{i,x} \\\\ N_{i,y} \\end{pmatrix} = J^{-1} \\begin{pmatrix} N_{i,\\xi} \\\\ N_{i,\\eta} \\end{pmatrix}$。\n\n### 3. 任务1：减缩积分刚度矩阵 $K_e^{\\text{red}}$\n\n刚度矩阵为$K_e = \\int_{\\Omega_e} B^T C B \\, d\\Omega$。平面应变本构矩阵$C$由下式给出：\n$$\nC = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{pmatrix} 1-\\nu & \\nu & 0 \\\\ \\nu & 1-\\nu & 0 \\\\ 0 & 0 & \\frac{1-2\\nu}{2} \\end{pmatrix}\n$$\n应变-位移矩阵$B(\\xi, \\eta)$是一个$3 \\times 8$的矩阵，由形函数的空间导数构成。对于节点$i$，其对应的列为$B_i = [ \\begin{smallmatrix} N_{i,x} & 0 \\\\ 0 & N_{i,y} \\\\ N_{i,y} & N_{i,x} \\end{smallmatrix} ]$。\n\n减缩积分在单元中心$(\\xi, \\eta) = (0, 0)$使用单个高斯点，权重为$w=4$（对于$[-1,1]^2$域）。刚度矩阵的积分简化为一次计算：\n$$\nK_e^{\\text{red}} = \\left. B^T C B \\right|_{(\\xi, \\eta)=(0,0)} \\cdot |\\Omega_e|\n$$\n其中$|\\Omega_e| = \\int_{-1}^1\\int_{-1}^1 \\det(J) \\, d\\xi d\\eta = 1/4 \\cdot 4 = 1$。在$(\\xi, \\eta) = (0,0)$处，B矩阵所需的所有形函数空间导数矩阵为：\n$$\n\\left[ \\{N_{i,x}\\}_{i=1}^4, \\{N_{i,y}\\}_{i=1}^4 \\right]_{(0,0)} = \\frac{1}{2}\\begin{bmatrix} -1 & 1 & 1 & -1 \\\\ -1 & -1 & 1 & 1 \\end{bmatrix}\n$$\n这定义了$B(0,0)$，然后用它和材料矩阵$C$来计算$K_e^{\\text{red}}$。\n\n### 4. 任务2：基于散度的稳定化矩阵 $K_{\\text{stab}}$\n\n为了对抗减缩积分引入的伪零能（“沙漏”）模式，在虚功方程中加入了一个稳定项：\n$$\n\\delta W_{\\text{stab}} = \\int_{V_e} \\tau (\\nabla \\cdot \\delta u_h) (\\nabla \\cdot u_h) \\, dV\n$$\n插值位移场$u_h$的散度是$\\nabla \\cdot u_h = \\sum_i (N_{i,x} u_{ix} + N_{i,y} u_{iy})$。这可以写成$(\\nabla \\cdot u_h) = H d_e$，其中$H$是$1 \\times 8$的行向量：\n$$\nH(\\xi, \\eta) = [N_{1,x}, N_{1,y}, N_{2,x}, N_{2,y}, N_{3,x}, N_{3,y}, N_{4,x}, N_{4,y}]\n$$\n因此，稳定化矩阵为：\n$$\nK_{\\text{stab}} = \\int_{V_e} \\tau H^T H \\, dV = \\tau \\int_{\\Omega_e} H^T H \\, t \\, d\\Omega\n$$\n这个积分使用标准的$2 \\times 2$高斯积分法计算。\n\n稳定化参数$\\tau$被指定为$\\tau = \\beta \\mu h^2$。根据虚功原理的量纲分析，稳定项积分 $\\int \\tau (\\nabla \\cdot \\delta u) (\\nabla \\cdot u) \\, dV$ 的单位必须是能量（功）。由于位移散度 $\\nabla \\cdot u$ 是无量纲的，体积微元 $dV$ 的单位是 $m^3$，因此 $\\tau$ 的单位必须是 $N/m^2$ 或帕斯卡（Pa），即压力单位。然而，给定的公式 $\\tau = \\beta \\mu h^2$ 中，剪切模量 $\\mu$ 的单位是 Pa，特征长度 $h$ 的单位是 m，因此 $\\mu h^2$ 的单位是 $Pa \\cdot m^2$，这与要求的压力单位不符。这是一个量纲不一致之处。尽管如此，我们将遵循问题陈述，并注意到由于指定了 $h=1$ m，数值上 $\\tau$ 的计算值等于 $\\beta\\mu$。因此，我们使用 $\\tau = \\frac{1}{3}\\mu$ 进行计算，其中 $\\mu = E/(2(1+\\nu))$。\n\n### 5. 任务3：一致体力向量 $f_e$\n\n一致节点力向量源于体力$b=(b_x, b_y)$做的外虚功：\n$$\nf_e = \\int_{V_e} N^T b \\, dV = t \\int_{\\Omega_e} N^T b \\, d\\Omega\n$$\n其中$N$是$2 \\times 8$的形函数矩阵。对于恒定的体力$b$，节点$i$上的力积分$f_{ei} = b \\cdot t \\int_{\\Omega_e} N_i \\, d\\Omega$可以解析计算。单个双线性形函数在单元面积上的积分是$\\int_{\\Omega_e} N_i d\\Omega = |\\Omega_e|/4$。因此，对于单位正方形单元（$|\\Omega_e|=1, t=1$），每个节点均分总力：$f_{ei} = b/4$。总力向量为$f_e = [b_x/4, b_y/4, \\dots, b_x/4, b_y/4]^T$。$2 \\times 2$积分法足以精确积分双线性形函数，因此数值结果应在机器精度内与解析结果相匹配。\n\n### 6. 任务4：载荷一致性与刚体运动\n\n稳定项被添加到内虚功中，从而修改了平衡方程的刚度部分。导出载荷向量$f_e$的外虚功项保持不变。这种分离确保了作为内部罚的稳定化不会改变外部物理载荷的表示。因此，为保持载荷一致性，不需要对$f_e$进行任何修改。\n\n一个有效的稳定化方法不能惩罚刚体运动，因为刚体运动是无应变变形。二维刚体运动（2个平移，1个旋转）的散度都为零（$\\nabla \\cdot u_{RBM} = 0$）。由于稳定项与$(\\nabla \\cdot u_h)^2$成正比，它对于任何刚体运动都恒等于零。因此，矩阵$K_{\\text{stab}}$不会对这些模态施加任何虚假力或能量惩罚，正确地将它们保留在单元刚度矩阵的零空间中。这可以通过以下方式证明：如果$d_{RBM}$是刚体运动的节点向量，那么$H d_{RBM} = 0$，因此$K_{stab} d_{RBM} = (\\tau \\int H^T H d\\Omega)d_{RBM} = 0$。\n\n### 7. 任务5：数值研究计划\n\n提供的Python代码将计算性地执行前面的理论步骤。它将：\n1.  组装全积分刚度矩阵$K_e^{\\text{full}}$、减缩积分矩阵$K_e^{\\text{red}}$和稳定化矩阵$K_{\\text{stab}}$。\n2.  形成最终的稳定化刚度矩阵$K_e^{\\text{tot}} = K_e^{\\text{red}} + K_{\\text{stab}}$。\n3.  计算一致载荷向量$f_e$。\n4.  对$K_e^{\\text{red}}$和$K_e^{\\text{tot}}$进行特征值分析以确定它们的零空间维数。我们预期$K_e^{\\text{red}}$的零空间维数为5（3个刚体模态 + 2个沙漏模态），而$K_e^{\\text{tot}}$的零空间维数为3（稳定化消除了沙漏模态）。\n5.  计算$K_e^{\\text{full}}$和$K_e^{\\text{tot}}$的正定部分的条件数。我们预期由于体积锁定，$K_e^{\\text{full}}$将是病态的，而$K_e^{\\text{tot}}$的条件数应显著改善。\n6.  验证计算出的载荷向量$f_e$与其解析值的准确性，并检查总力的守恒性。\n\n这项数值研究的结果将为减缩积分和稳定化在近不可压缩极限下对单元性能的影响提供定量的见解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the FEM problem for a single bilinear quadrilateral element as specified.\n    \"\"\"\n    # Parameter values and test suite\n    E = 1.0e6  # Young's modulus in Pascals\n    nu = 0.4999  # Poisson's ratio (dimensionless)\n    b_vec = np.array([3.2, -1.7])  # Body force in N/m^3\n    beta = 1.0 / 3.0  # Stabilization coefficient\n    \n    # Element Geometry\n    # node_coords = np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]])\n    thickness = 1.0  # Unit thickness in meters\n    area = 1.0  # Area in square meters\n    h = np.sqrt(area)  # Characteristic length in meters\n\n    # Material properties\n    # Plane strain constitutive matrix\n    C_factor = E / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    C = C_factor * np.array([\n        [1.0 - nu, nu, 0.0],\n        [nu, 1.0 - nu, 0.0],\n        [0.0, 0.0, (1.0 - 2.0 * nu) / 2.0]\n    ])\n    \n    # Shear modulus and stabilization parameter\n    mu = E / (2.0 * (1.0 + nu))\n    # Using the formula from the problem statement: tau = beta * mu * h^2\n    # Since h=1, this is numerically equivalent to tau = beta * mu.\n    tau = beta * mu * h**2\n\n    # Quadrature rules\n    # 2x2 Gauss Quadrature for [-1, 1] x [-1, 1]\n    gp_val = 1.0 / np.sqrt(3.0)\n    gauss_pts_2x2 = [(-gp_val, -gp_val), (gp_val, -gp_val),\n                     (gp_val, gp_val), (-gp_val, gp_val)]\n    gauss_w_2x2 = [1.0, 1.0, 1.0, 1.0]\n\n    # Shape functions and their derivatives in the reference element\n    def get_shape_info(xi, eta):\n        N = 0.25 * np.array([(1 - xi) * (1 - eta),\n                             (1 + xi) * (1 - eta),\n                             (1 + xi) * (1 + eta),\n                             (1 - xi) * (1 + eta)])\n        \n        dNdxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n        dNdeta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n        \n        return N, dNdxi, dNdeta\n\n    # Jacobian is constant for this specific geometry (unit square)\n    # Mapping: x = 0.5*(1+xi), y = 0.5*(1+eta)\n    J = np.array([[0.5, 0.0], [0.0, 0.5]])\n    detJ = np.linalg.det(J)\n    invJ = np.linalg.inv(J)\n\n    def get_B_and_H_matrices(dNdxi, dNdeta):\n        B = np.zeros((3, 8))\n        H = np.zeros(8)\n        for i in range(4):\n            dNd_phys = invJ @ np.array([dNdxi[i], dNdeta[i]])\n            dNdx_i, dNdy_i = dNd_phys[0], dNd_phys[1]\n            \n            # Strain-displacement matrix B for node i\n            B[0, 2 * i] = dNdx_i\n            B[1, 2 * i + 1] = dNdy_i\n            B[2, 2 * i] = dNdy_i\n            B[2, 2 * i + 1] = dNdx_i\n            \n            # Divergence operator H for node i\n            H[2 * i] = dNdx_i\n            H[2 * i + 1] = dNdy_i\n            \n        return B, H\n\n    # Assemble K_full, K_stab, and f_e using 2x2 quadrature\n    K_full = np.zeros((8, 8))\n    K_stab = np.zeros((8, 8))\n    f_e = np.zeros(8)\n\n    for i in range(len(gauss_pts_2x2)):\n        xi, eta = gauss_pts_2x2[i]\n        w = gauss_w_2x2[i]\n        \n        N, dNdxi, dNdeta = get_shape_info(xi, eta)\n        B, H = get_B_and_H_matrices(dNdxi, dNdeta)\n        \n        K_full += B.T @ C @ B * detJ * w * thickness\n        K_stab += tau * np.outer(H, H) * detJ * w * thickness\n        \n        # Consistent load vector contribution\n        N_mat = np.zeros((2, 8))\n        for j in range(4):\n            N_mat[0, 2 * j] = N[j]\n            N_mat[1, 2 * j + 1] = N[j]\n        f_e += N_mat.T @ b_vec * detJ * w * thickness\n\n    # Assemble K_red using 1-point quadrature\n    xi_red, eta_red = 0.0, 0.0\n    _, dNdxi_red, dNdeta_red = get_shape_info(xi_red, eta_red)\n    B_red, _ = get_B_and_H_matrices(dNdxi_red, dNdeta_red)\n    K_red = B_red.T @ C @ B_red * area * thickness\n\n    # Total stabilized stiffness matrix\n    K_tot = K_red + K_stab\n    \n    # --- Perform Numerical Analysis ---\n\n    # 1. Nullity of K_red\n    e_vals_red = np.linalg.eigvalsh(K_red)\n    lambda_max_red = np.max(np.abs(e_vals_red))\n    tol_red = 1e-8 * lambda_max_red if lambda_max_red > 1e-15 else 1e-8\n    nullity_red = np.sum(np.abs(e_vals_red) < tol_red)\n    \n    # 2. Nullity of K_tot\n    e_vals_tot = np.linalg.eigvalsh(K_tot)\n    lambda_max_tot = np.max(np.abs(e_vals_tot))\n    tol_tot = 1e-8 * lambda_max_tot if lambda_max_tot > 1e-15 else 1e-8\n    nullity_tot = np.sum(np.abs(e_vals_tot) < tol_tot)\n\n    # 3. Maximum absolute difference in force vector\n    f_analytic = np.tile(b_vec * area * thickness / 4.0, 4)\n    f_diff = np.max(np.abs(f_e - f_analytic))\n\n    # 4. Consistency of total nodal force\n    sum_f_num = np.array([np.sum(f_e[0::2]), np.sum(f_e[1::2])])\n    sum_f_analytic = b_vec * area * thickness\n    is_consistent = np.allclose(sum_f_num, sum_f_analytic, rtol=1e-8, atol=1e-9)\n\n    # Helper for condition number calculation\n    def get_log10_cond(matrix, tol_factor=1e-8):\n        e_vals = np.linalg.eigvalsh(matrix)\n        lambda_max = np.max(e_vals)\n        tol = tol_factor * lambda_max if lambda_max > 1e-15 else tol_factor\n        positive_eigs = e_vals[e_vals > tol]\n        if len(positive_eigs) == 0:\n            return np.inf\n        return np.log10(np.max(positive_eigs) / np.min(positive_eigs))\n\n    # 5. Log10 condition number of K_full\n    cond_full_log10 = get_log10_cond(K_full)\n    \n    # 6. Log10 condition number of K_tot\n    cond_tot_log10 = get_log10_cond(K_tot)\n\n    # --- Format and Print Final Output ---\n    results = [\n        int(nullity_red), \n        int(nullity_tot), \n        float(f_diff), \n        bool(is_consistent), \n        float(cond_full_log10), \n        float(cond_tot_log10)\n    ]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}