{
    "hands_on_practices": [
        {
            "introduction": "这个首个练习将带我们回归基础。我们将应用经典的冯·诺依曼稳定性分析，为简单的线性平流方程推导其Courant-Friedrichs-Lewy (CFL)条件。掌握这项技术为你提供了分析许多显式数值格式稳定性的基本数学工具。",
            "id": "3518916",
            "problem": "在采用算子分裂的多物理场耦合模拟中，一个对流子步骤由线性对流方程 $u_{t} + a\\,u_{x} = 0$ 建模，其中波速 $a \\in \\mathbb{R}$ 为常数，网格为均匀网格，空间步长为 $\\Delta x$，时间步长为 $\\Delta t$。考虑一个采用前向欧拉时间步进和 Lax-Friedrichs 数值通量的全离散有限体积法。从守恒律形式出发，并调用数值通量的一致性和守恒性定义，构建与 Lax-Friedrichs 通量相关的全离散更新格式\n$$\nF_{j+\\frac{1}{2}} = \\frac{1}{2}\\big(f(u_{j}) + f(u_{j+1})\\big) - \\frac{\\alpha}{2}\\,\\big(u_{j+1} - u_{j}\\big),\n$$\n其中 $f(u) = a\\,u$，经典的 Lax-Friedrichs 耗散系数通过量纲分析以及要求该格式在零对流极限下简化为凸平均的条件，被选为 $\\alpha = \\frac{\\Delta x}{\\Delta t}$。进行 von Neumann 傅里叶稳定性分析，以推导 Courant-Friedrichs-Lewy (CFL) 条件，该条件定义为比率 $\\frac{|a|\\,\\Delta t}{\\Delta x}$ 的必要界限，以确保对所有傅里叶模式，放大因子的模不超过 1。根据此条件，确定最大稳定时间步长 $\\Delta t_{\\max}$，并将其表示为关于 $a$ 和 $\\Delta x$ 的解析表达式。将你的最终答案表示为关于 $a$ 和 $\\Delta x$ 的封闭形式表达式。",
            "solution": "经评估，问题陈述是有效的，因为它在科学上基于偏微分方程数值分析的原理，是适定的，具有足够的信息以获得唯一解，并且以客观、正式的语言表达。因此，我们可以继续进行求解。\n\n问题要求推导特定数值格式的 Courant-Friedrichs-Lewy (CFL) 条件以及由此产生的最大稳定时间步长。这个过程包括三个主要步骤：构建全离散数值格式，进行 von Neumann 稳定性分析以找到放大因子，以及从该因子的模推导出稳定性条件。\n\n首先，我们构建全离散更新方程。控制偏微分方程是线性对流方程，它是一种守恒律形式，$u_t + (au)_x = 0$。对于有限体积法，单元 $j$ 的半离散形式是通过在宽度为 $\\Delta x = x_{j+1/2} - x_{j-1/2}$ 的单元体积 $[x_{j-1/2}, x_{j+1/2}]$ 上对偏微分方程进行积分得到的。这得到：\n$$\n\\frac{d u_j}{dt} + \\frac{1}{\\Delta x} \\left( F_{j+1/2} - F_{j-1/2} \\right) = 0\n$$\n其中 $u_j$ 是单元 $j$ 中解的单元平均值，而 $F_{j \\pm 1/2}$ 是单元界面处的数值通量。\n\n应用前向欧拉法进行时间积分，我们将时间导数离散化为 $\\frac{du_j}{dt} \\approx \\frac{u_j^{n+1} - u_j^n}{\\Delta t}$，其中上标 $n$ 表示时间层。全离散格式为：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = - \\frac{1}{\\Delta x} \\left( F_{j+1/2}^n - F_{j-1/2}^n \\right)\n$$\n对 $u_j^{n+1}$ 进行整理，得到更新公式：\n$$\nu_j^{n+1} = u_j^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{j+1/2}^n - F_{j-1/2}^n \\right)\n$$\n问题指定了 Lax-Friedrichs 数值通量：\n$$\nF_{j+\\frac{1}{2}} = \\frac{1}{2}\\big(f(u_{j}) + f(u_{j+1})\\big) - \\frac{\\alpha}{2}\\,\\big(u_{j+1} - u_{j}\\big)\n$$\n其中物理通量为 $f(u) = a u$，耗散系数为 $\\alpha = \\frac{\\Delta x}{\\Delta t}$。将这些代入通量定义中，我们得到在时间层 $n$ 时界面 $j+1/2$ 处的通量：\n$$\nF_{j+1/2}^n = \\frac{1}{2}\\left(a u_j^n + a u_{j+1}^n\\right) - \\frac{1}{2}\\frac{\\Delta x}{\\Delta t}\\left(u_{j+1}^n - u_j^n\\right)\n$$\n类似地，界面 $j-1/2$ 处的通量为：\n$$\nF_{j-1/2}^n = \\frac{1}{2}\\left(a u_{j-1}^n + a u_j^n\\right) - \\frac{1}{2}\\frac{\\Delta x}{\\Delta t}\\left(u_j^n - u_{j-1}^n\\right)\n$$\n我们现在计算更新公式中所需的通量差：\n$$\nF_{j+1/2}^n - F_{j-1/2}^n = \\left[ \\frac{a}{2}(u_j^n + u_{j+1}^n) - \\frac{\\Delta x}{2\\Delta t}(u_{j+1}^n - u_j^n) \\right] - \\left[ \\frac{a}{2}(u_{j-1}^n + u_j^n) - \\frac{\\Delta x}{2\\Delta t}(u_j^n - u_{j-1}^n) \\right]\n$$\n$$\nF_{j+1/2}^n - F_{j-1/2}^n = \\frac{a}{2}(u_{j+1}^n - u_{j-1}^n) - \\frac{\\Delta x}{2\\Delta t}(u_{j+1}^n - 2u_j^n + u_{j-1}^n)\n$$\n将此差值代回 $u_j^{n+1}$ 的更新公式中：\n$$\nu_j^{n+1} = u_j^n - \\frac{\\Delta t}{\\Delta x} \\left[ \\frac{a}{2}(u_{j+1}^n - u_{j-1}^n) - \\frac{\\Delta x}{2\\Delta t}(u_{j+1}^n - 2u_j^n + u_{j-1}^n) \\right]\n$$\n$$\nu_j^{n+1} = u_j^n - \\frac{a \\Delta t}{2\\Delta x}(u_{j+1}^n - u_{j-1}^n) + \\frac{1}{2}(u_{j+1}^n - 2u_j^n + u_{j-1}^n)\n$$\n令 Courant 数为 $\\nu = \\frac{a \\Delta t}{\\Delta x}$。方程变为：\n$$\nu_j^{n+1} = u_j^n - \\frac{\\nu}{2}(u_{j+1}^n - u_{j-1}^n) + \\frac{1}{2}u_{j+1}^n - u_j^n + \\frac{1}{2}u_{j-1}^n\n$$\n将各项根据其空间索引 $j-1$、$j$ 和 $j+1$ 进行合并：\n$$\nu_j^{n+1} = (u_j^n - u_j^n) + \\frac{1}{2}(u_{j-1}^n + u_{j+1}^n) - \\frac{\\nu}{2}(u_{j+1}^n - u_{j-1}^n)\n$$\n$$\nu_j^{n+1} = \\frac{1}{2}(u_{j-1}^n + u_{j+1}^n) - \\frac{\\nu}{2}(u_{j+1}^n - u_{j-1}^n)\n$$\n这是全离散更新格式，它等价于经典的Lax方法。\n\n第二，我们进行 von Neumann 稳定性分析。我们寻找形式为 $u_j^n = \\hat{u}^n(k) \\exp(i k x_j)$ 的傅里叶模式解，其中 $x_j = j \\Delta x$，$k$ 是波数，$i = \\sqrt{-1}$。将此代入离散格式中：\n$$\n\\hat{u}^{n+1} \\exp(i k j \\Delta x) = \\frac{1}{2}(\\hat{u}^n e^{ik(j-1)\\Delta x} + \\hat{u}^n e^{ik(j+1)\\Delta x}) - \\frac{\\nu}{2}(\\hat{u}^n e^{ik(j+1)\\Delta x} - \\hat{u}^n e^{ik(j-1)\\Delta x})\n$$\n放大因子定义为 $G(k) = \\frac{\\hat{u}^{n+1}}{\\hat{u}^n}$。除以 $\\hat{u}^n \\exp(i k j \\Delta x)$：\n$$\nG(k) = \\frac{1}{2}(e^{-ik\\Delta x} + e^{ik\\Delta x}) - \\frac{\\nu}{2}(e^{ik\\Delta x} - e^{-ik\\Delta x})\n$$\n使用欧拉公式 $\\exp(\\pm i \\theta) = \\cos(\\theta) \\pm i\\sin(\\theta)$，其中 $\\theta = k \\Delta x$：\n$$\nG(k) = \\cos(k\\Delta x) - \\frac{\\nu}{2}(2i\\sin(k\\Delta x))\n$$\n$$\nG(k) = \\cos(k\\Delta x) - i\\nu\\sin(k\\Delta x)\n$$\n为使格式稳定，放大因子的模对于所有可能的波数 $k$ 都不能超过 $1$，即 $|G(k)| \\le 1$。我们计算模的平方：\n$$\n|G(k)|^2 = (\\text{Re}[G(k)])^2 + (\\text{Im}[G(k)])^2 = \\cos^2(k\\Delta x) + (-\\nu\\sin(k\\Delta x))^2\n$$\n$$\n|G(k)|^2 = \\cos^2(k\\Delta x) + \\nu^2\\sin^2(k\\Delta x)\n$$\n稳定性条件是 $|G(k)|^2 \\le 1$：\n$$\n\\cos^2(k\\Delta x) + \\nu^2\\sin^2(k\\Delta x) \\le 1\n$$\n使用三角恒等式 $\\cos^2(\\theta) = 1 - \\sin^2(\\theta)$：\n$$\n1 - \\sin^2(k\\Delta x) + \\nu^2\\sin^2(k\\Delta x) \\le 1\n$$\n$$\n(\\nu^2 - 1)\\sin^2(k\\Delta x) \\le 0\n$$\n由于对所有实数 $k\\Delta x$，$\\sin^2(k\\Delta x) \\ge 0$ 恒成立，所以该不等式成立的充要条件是系数 $(\\nu^2 - 1)$ 为非正数：\n$$\n\\nu^2 - 1 \\le 0 \\implies \\nu^2 \\le 1\n$$\n开平方根得到此格式的 CFL 条件：\n$$\n|\\nu| \\le 1\n$$\n\n第三，我们确定最大稳定时间步长 $\\Delta t_{\\max}$。我们将 Courant 数的定义 $\\nu = \\frac{a \\Delta t}{\\Delta x}$ 代入稳定性条件中：\n$$\n\\left|\\frac{a \\Delta t}{\\Delta x}\\right| \\le 1\n$$\n由于 $\\Delta t$ 和 $\\Delta x$ 是正的物理量，我们可以写成：\n$$\n\\frac{|a|\\Delta t}{\\Delta x} \\le 1\n$$\n为保持模拟稳定，必须满足此不等式。最大允许时间步长 $\\Delta t_{\\max}$ 在等号成立时取得。假设波速不为零，$a \\neq 0$：\n$$\n\\frac{|a|\\Delta t_{\\max}}{\\Delta x} = 1\n$$\n解出 $\\Delta t_{\\max}$ 得到最终表达式：\n$$\n\\Delta t_{\\max} = \\frac{\\Delta x}{|a|}\n$$\n这就是所要求的最大稳定时间步长的解析表达式。在 $a=0$ 的退化情况下，CFL 条件 $|\\nu| \\le 1$ 变为 $0 \\le 1$，这总是成立的，意味着无条件稳定，不存在有限的最大时间步长。推导出的 $\\Delta t_{\\max}$ 表达式通过在 $|a| \\to 0$ 时变为奇异值，正确地反映了这种情况。",
            "answer": "$$\n\\boxed{\\frac{\\Delta x}{|a|}}\n$$"
        },
        {
            "introduction": "现实世界中的地球物理现象通常是非线性的，这意味着波速可能随解本身而变化。本练习通过研究无粘性伯格斯方程来处理这一关键复杂性。你将学习如何制定一个全局时间步长约束，以确保在整个计算域内的稳定性，即使局部条件差异巨大。",
            "id": "3220247",
            "problem": "考虑无粘性伯格斯方程的非线性守恒律，$$u_t + \\big(f(u)\\big)_x = 0,$$ 其通量为 $$f(u) = \\tfrac{1}{2} u^2,$$ 因此特征速度为 $$a(u) = f'(u) = u.$$ 您在一个间距为 $$\\Delta x > 0$$ 的均匀网格上，使用带有单调黎曼求解器的显式有限体积法，其中在每个时间步中，每个面的更新仅取决于相邻单元的状态。必须选择库朗-弗里德里希-列维 (CFL) 条件，以确保数值依赖域覆盖由特征传播速度决定的物理依赖域。\n\n在当前时间 $$t^n$$，您在一个均匀网格上拥有单元平均值 $$u_i^n$$，其中 $$\\Delta x = 0.05$$，CFL 数为 $$C = 0.8$$。在五个连续的单元上，状态为 $$[0.6,\\,-1.1,\\,0.2,\\,0.9,\\,-0.4],$$ 索引为 $$i = 1,2,3,4,5$$。您必须选择一个单一的全局时间步长 $$\\Delta t$$，用于从 $$t^n$$ 更新到 $$t^{n+1}$$ 期间的所有单元。\n\n哪个选项正确描述了如何调整 CFL 条件以考虑依赖于解的波速，并针对给定状态，得出允许的最大时间步长 $$\\Delta t$$？\n\nA. 使用根据当前状态计算的特征速度大小的全局最大值，强制执行 $$\\max_i \\big|f'(u_i^n)\\big| \\,\\frac{\\Delta t}{\\Delta x} \\le C.$$ 对于伯格斯方程，这给出 $$\\Delta t = \\dfrac{C\\,\\Delta x}{\\max_i |u_i^n|} \\approx 0.03636.$$\n\nB. 使用整个域上特征速度的最小大小以避免过度限制，即 $$\\Delta t = \\dfrac{C\\,\\Delta x}{\\min_i |u_i^n|} \\approx 0.20.$$\n\nC. 使用绝对特征速度的域平均值来设置时间步长，即 $$\\overline{|u|} = \\dfrac{0.6 + 1.1 + 0.2 + 0.9 + 0.4}{5} = 0.64,$$ 所以 $$\\Delta t = \\dfrac{C\\,\\Delta x}{\\overline{|u|}} = 0.0625.$$\n\nD. 仅使用域上最大的正特征速度，忽略负速度，即 $$\\Delta t = \\dfrac{C\\,\\Delta x}{\\max\\{u_i^n : u_i^n > 0\\}} \\approx 0.04444.$$",
            "solution": "用户希望我解决一个关于无粘性伯格斯方程的CFL条件的问题。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n*   **控制方程：** 非线性守恒律为 $$u_t + \\big(f(u)\\big)_x = 0$$。\n*   **通量函数：** $$f(u) = \\tfrac{1}{2} u^2$$。\n*   **特征速度：** $$a(u) = f'(u) = u$$。\n*   **数值方法：** 均匀网格上的显式有限体积法，其中更新取决于相邻单元。\n*   **网格间距：** $$\\Delta x = 0.05$$。\n*   **CFL 数：** $$C = 0.8$$。\n*   **时间 $$t^n$$ 时的状态向量：** 五个连续单元（$$i=1, 2, 3, 4, 5$$）上的单元平均值 $$u_i^n$$ 由向量 $$[0.6, -1.1, 0.2, 0.9, -0.4]$$ 给出。\n*   **时间步进：** 所有单元将使用单一的全局时间步长 $$\\Delta t$$。\n*   **目标：** 确定满足库朗-弗里德里希-列维 (CFL) 条件的最大允许时间步长 $$\\Delta t$$。\n\n**步骤2：使用提取的已知条件进行验证**\n\n1.  **科学依据：** 该问题牢固地植根于偏微分方程数值方法的基础理论。无粘性伯格斯方程是非线性双曲守恒律的典型模型，而 CFL 条件是此类方程显式时间积分格式稳定性分析的基石。所有概念都是标准的且符合事实。\n2.  **适定性：** 该问题是适定的。它提供了一个具体的偏微分方程、一种数值格式类型、所有必要的参数（$$\\Delta x$$, C）以及特定时间（$$u_i^n$$）的初始数据。问题要求根据一个明确定义的稳定性准则求出最大允许时间步长（$$\\Delta t$$），这会导出一个唯一的、有意义的答案。\n3.  **客观性：** 问题以精确、客观的数学语言陈述。它没有歧义、主观性或观点。\n4.  **无缺陷：** 该问题不违反任何无效性标准。它是完整的、一致的、科学上合理的，并直接关系到 CFL 条件的主题。\n\n**步骤3：结论与行动**\n\n问题陈述是**有效的**。我将继续推导解答。\n\n### 求解推导\n\n库朗-弗里德里希-列维 (CFL) 条件是求解双曲型偏微分方程的显式数值方法稳定性的一个必要条件。它规定，一个计算单元的数值依赖域必须包含其物理依赖域。\n\n对于形式为 $$u_t + a(u)u_x = 0$$ 的一维双曲方程，信息以速度 $$a(u)$$ 沿特征曲线传播。对于一个使用紧邻单元信息（空间导数的三点模板）的显式有限体积或有限差分格式，新时间步 $$t^{n+1} = t^n + \\Delta t$$ 时网格点 $$x_i$$ 的值是使用时间 $$t^n$$ 时单元 $$i-1$$、$$i$$ 和 $$i+1$$ 的值计算的。\n\n影响点 $$(x_i, t^{n+1})$$ 解的物理信息源于直线 $$t=t^n$$ 上的一个区间。为使数值格式稳定，任何源自单元 $$i$$ 的特征在单个时间步 $$\\Delta t$$ 内的传播距离不能超过一个网格间距 $$\\Delta x$$。传播的速度由特征速度的大小 $$|a(u)|$$ 给出。因此，条件是 $$|a(u)| \\Delta t \\le \\Delta x$$。\n\n对于非线性问题，特征速度 $$a(u)$$ 不是常数；它随解 $$u$$ 而变化。由于必须对所有单元使用单一的全局时间步长 $$\\Delta t$$ 来同步推进解，因此 $$\\Delta t$$ 的选择必须足够小，以确保在域内任何地方都保持稳定。这意味着 $$\\Delta t$$ 必须受到时间 $$t^n$$ 时域中存在的最大特征速度的限制。因此，稳定性条件变为：\n$$ \\left( \\max_i |a(u_i^n)| \\right) \\frac{\\Delta t}{\\Delta x} \\le 1 $$\n\n问题引入了一个 CFL 数 $$C$$，这是一个因子（通常 $$C \\le 1$$），为实际稳定性收紧了这一约束：\n$$ \\left( \\max_i |a(u_i^n)| \\right) \\frac{\\Delta t}{\\Delta x} \\le C $$\n\n为了找到最大允许时间步长 $$\\Delta t$$，我们解这个不等式：\n$$ \\Delta t \\le \\frac{C \\Delta x}{\\max_i |a(u_i^n)|} $$\n最大值通过取等号获得：\n$$ \\Delta t = \\frac{C \\Delta x}{\\max_i |a(u_i^n)|} $$\n\n现在，我们将其应用于具体问题：\n*   伯格斯方程的特征速度为 $$a(u) = u$$。\n*   给定的单元平均值为 $$u_i^n = [0.6, -1.1, 0.2, 0.9, -0.4]$$。\n*   我们必须找到这些速度绝对值的最大值：\n    $$ |u_i^n| = [|0.6|, |-1.1|, |0.2|, |0.9|, |-0.4|] = [0.6, 1.1, 0.2, 0.9, 0.4] $$\n*   这些值的最大值是：\n    $$ \\max_i |u_i^n| = 1.1 $$\n*   给定的参数是 $$C=0.8$$ 和 $$\\Delta x = 0.05$$。\n*   我们现在可以计算最大允许时间步长 $$\\Delta t$$：\n    $$ \\Delta t = \\frac{C \\Delta x}{\\max_i |u_i^n|} = \\frac{0.8 \\times 0.05}{1.1} = \\frac{0.04}{1.1} $$\n*   进行除法运算：\n    $$ \\Delta t = \\frac{0.04}{1.1} = \\frac{4}{110} = \\frac{2}{55} \\approx 0.0363636... $$\n\n### 逐项分析\n\n*   **选项 A：** 该选项指出，必须使用特征速度大小的全局最大值，强制执行 $$\\max_i \\big|f'(u_i^n)\\big| \\,\\frac{\\Delta t}{\\Delta x} \\le C$$。然后计算出 $$\\Delta t = \\dfrac{C\\,\\Delta x}{\\max_i |u_i^n|} \\approx 0.03636$$。\n    - 这是为非线性双曲问题选择全局时间步长的正确原则。该公式是此原则对伯格斯方程（$$f'(u)=u$$）的直接应用。如上所示，计算结果为 $$\\frac{0.8 \\times 0.05}{1.1} \\approx 0.03636$$。原则、公式和计算都正确。\n    - **结论：正确**\n\n*   **选项 B：** 该选项建议使用特征速度的最小大小 $$\\min_i |u_i^n|$$，得到 $$\\Delta t \\approx 0.20$$。\n    - 这在根本上是错误的。CFL 条件是基于*最快*信息传播速度的限制，而不是最慢的。使用最小速度将导致时间步长过大，从而在速度高于最小值的区域导致数值不稳定。最小绝对速度为 $$\\min\\{0.6, 1.1, 0.2, 0.9, 0.4\\} = 0.2$$。计算出的 $$\\Delta t = \\frac{0.8 \\times 0.05}{0.2} = 0.2$$ 将在速度为 $$-1.1$$ 的单元处导致局部 CFL 数为 $$1.1 \\times \\frac{0.2}{0.05} = 1.1 \\times 4 = 4.4$$。这远大于允许的 CFL 数 $$C=0.8$$。\n    - **结论：错误**\n\n*   **选项 C：** 该选项建议使用绝对特征速度的域平均值 $$\\overline{|u|} = 0.64$$，得到 $$\\Delta t = 0.0625$$。\n    - 这也是错误的。稳定性必须在“最坏情况”下得到保证，即速度最大的单元。平均速度掩盖了这一最大值。得到的时间步长 $$\\Delta t = 0.0625$$ 大于最大允许的稳定时间步长（$$0.03636$$）。在速度为 $$-1.1$$ 的单元处，局部 CFL 数将为 $$|-1.1| \\frac{0.0625}{0.05} = 1.1 \\times 1.25 = 1.375$$，超过了 $$C=0.8$$。该格式将不稳定。\n    - **结论：错误**\n\n*   **选项 D：** 该选项建议仅使用最大的正特征速度，忽略负速度，得到 $$\\Delta t \\approx 0.04444$$。\n    - 这是错误的。对 $$\\Delta t$$ 的限制与传播*速率*有关，即速度的大小。向左传播的波（负速度）与向右传播的波对稳定性的影响同样重要。必须通过使用特征速度的绝对值来考虑两个方向。最大的正速度是 $$0.9$$。得到的时间步长 $$\\Delta t \\approx 0.04444$$ 大于稳定极限。速度为 $$-1.1$$ 的单元将不稳定，其局部 CFL 数为 $$|-1.1| \\frac{0.04444}{0.05} \\approx 1.1 \\times 0.8888 = 0.97768$$，超过了 $$C=0.8$$。\n    - **结论：错误**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "最后一个练习旨在连接理论与可运行的模拟代码。你将为一个具有空间变化性质的多维双曲系统设计并实现一个完整的算法，用于计算稳定的全局时间步长$ \\Delta t$ 。这个练习巩固了前面的概念，并引入了诸如安全因子和处理不同网格与场条件等实际考量。",
            "id": "3615177",
            "problem": "您需要推导、实现并测试一个算法，用于计算计算地球物理学中使用的线性双曲守恒律显式时间积分的全局稳定时间步长，该算法需符合被称为柯朗-弗里德里希斯-列维 (Courant–Friedrichs–Lewy, CFL) 条件的稳定性要求。该计算必须基于扫描每个单元的局部最大特征速度和网格间距，并应用一个安全因子，同时随着场量随时间演化动态更新全局时间步长。\n\n出发点与假设：考虑 $D$ 维空间中的线性双曲系统，\n$$\n\\frac{\\partial \\mathbf{q}}{\\partial t} + \\sum_{d=1}^{D} \\mathbf{A}_d(\\mathbf{x}) \\frac{\\partial \\mathbf{q}}{\\partial x_d} = \\mathbf{0},\n$$\n其中 $\\mathbf{q}(\\mathbf{x},t)$ 是守恒变量的向量，$\\mathbf{A}_d(\\mathbf{x})$ 是空间变化的通量雅可比矩阵。在直角网格的每个单元 $i$ 中，设方向 $d$ 上的网格间距为 $h_{i,d} > 0$，并在时间索引 $t$ 处，方向 $d$ 上的局部最大特征速度大小为 $s_{t,i,d} \\ge 0$（即在时间 $t$ 评估单元 $i$ 中的 $\\mathbf{A}_d$ 的最大模长特征值）。假设使用一种显式单调有限体积法，其数值通量与局部特征速度相容。您必须基于经过充分检验的事实：对于此类显式方法，稳定性要求方向柯朗数的适当线性组合被一个量级为1的常数所限制，并且时间步长 $\\Delta t$ 遵守由最具限制性的单元所施加的全局界限。\n\n您的任务：\n- 基于上述基本定义和原理，进行第一性原理稳定性分析论证，以获得一个必要的稳定性条件，该条件用局部量 $s_{t,i,d}$ 和 $h_{i,d}$ 以及一个用户选择的安全因子 $\\sigma$（其中 $0  \\sigma  1$）来约束 $\\Delta t$。此论证不得依赖于预先给定的简化公式；必须从双曲系统显式格式的性质以及其柯朗数必须保持在稳定性限制内的要求出发进行解释和推导。\n- 设计一个算法，在每个时间索引 $t$，该算法扫描所有单元 $i$ 和所有方向 $d$，结合局部特征速度 $s_{t,i,d}$ 和网格间距 $h_{i,d}$ 来确定一个单一的全局 $\\Delta t_t$，该 $\\Delta t_t$ 满足推导出的稳定性条件并包含安全因子 $\\sigma$，同时包括一个允许的最大时间步长上限 $\\Delta t_{\\mathrm{cap}}$ 以确保数值实用性。该算法必须处理边界情况，例如某些或所有方向上 $s_{t,i,d} = 0$ 的单元，以及所有单元同时具有零特征速度的情况。\n- 将该算法实现为一个完整、可运行的程序，对于下面提供的每个测试用例，该程序使用给定的 $s_{t,i,d}$ 和 $h_{i,d}$ 数组处理一系列时间步 $t = 0,1,2,\\dots$，计算全局时间步长的动态序列 $\\Delta t_t$，并返回该测试用例最后一个时间索引处的值。\n- 单位：所有间距 $h_{i,d}$ 的单位是米 (m)，所有特征速度 $s_{t,i,d}$ 的单位是米/秒 (m/s)，$\\Delta t$ 必须以秒 (s) 表示。您的程序必须以秒为单位打印最终结果。\n- 输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个浮点数格式化为恰好$6$位小数（例如，$\\left[0.012345,0.100000\\right]$）。\n\n测试套件规范（数组按时间主序、单元主序、维度主序组织；也就是说，$s_{t,i,d}$ 是一个按 $t$、$i$、$d$ 顺序排列的三维数组）：\n\n- 测试用例 1（一维、均匀网格、动态速度、理想情况）：\n  - 维度 $D = 1$，单元数 $N = 5$，时间步数 $T = 3$。\n  - 所有单元 $i \\in \\{0,1,2,3,4\\}$ 的间距 $h_{i,1} = 10$ 米。\n  - 安全因子 $\\sigma = 0.9$，上限 $\\Delta t_{\\mathrm{cap}} = 1.0$ 秒。\n  - 速度 (m/s)：\n    - $t = 0$: $\\left[50,40,60,55,45\\right]$，\n    - $t = 1$: $\\left[70,30,65,40,50\\right]$，\n    - $t = 2$: $\\left[80,90,85,75,65\\right]$。\n  - 要求结果：程序必须返回最后计算出的 $\\Delta t$（单位：秒）。\n\n- 测试用例 2（二维、各向异性间距、动态速度）：\n  - 维度 $D = 2$，单元数 $N = 3$，时间步数 $T = 2$。\n  - 间距 (m)：\n    - 单元 $0$: $\\left(h_{0,1},h_{0,2}\\right) = \\left(20,10\\right)$，\n    - 单元 $1$: $\\left(h_{1,1},h_{1,2}\\right) = \\left(25,15\\right)$，\n    - 单元 $2$: $\\left(h_{2,1},h_{2,2}\\right) = \\left(15,15\\right)$。\n  - 安全因子 $\\sigma = 0.8$，上限 $\\Delta t_{\\mathrm{cap}} = 0.5$ 秒。\n  - 速度 (m/s)：\n    - $t = 0$: 单元 $0$ 到 $2$ 分别为 $\\left(30,20\\right)$、$\\left(40,10\\right)$、$\\left(35,35\\right)$，\n    - $t = 1$: 单元 $0$ 到 $2$ 分别为 $\\left(25,25\\right)$、$\\left(45,5\\right)$、$\\left(30,40\\right)$。\n  - 要求结果：程序必须返回最后计算出的 $\\Delta t$（单位：秒）。\n\n- 测试用例 3（三维、包含零速度、时间步长上限约束的边界情况）：\n  - 维度 $D = 3$，单元数 $N = 2$，时间步数 $T = 2$。\n  - 间距 (m)：所有单元均为 $\\left(10,10,10\\right)$。\n  - 安全因子 $\\sigma = 0.7$，上限 $\\Delta t_{\\mathrm{cap}} = 0.05$ 秒。\n  - 速度 (m/s)：\n    - $t = 0$: 单元 $0$ 和 $1$ 分别为 $\\left(0,0,0\\right)$ 和 $\\left(5,5,5\\right)$，\n    - $t = 1$: 单元 $0$ 和 $1$ 分别为 $\\left(1,0,0\\right)$ 和 $\\left(0,0,0\\right)$。\n  - 要求结果：程序必须返回最后计算出的 $\\Delta t$（单位：秒）。\n\n- 测试用例 4（二维、在最后时刻所有速度变为零，静态边界情况）：\n  - 维度 $D = 2$，单元数 $N = 4$，时间步数 $T = 3$。\n  - 间距 (m)：\n    - 单元 $0$: $\\left(50,50\\right)$，\n    - 单元 $1$: $\\left(20,30\\right)$，\n    - 单元 $2$: $\\left(40,25\\right)$，\n    - 单元 $3$: $\\left(30,45\\right)$。\n  - 安全因子 $\\sigma = 0.95$，上限 $\\Delta t_{\\mathrm{cap}} = 1.0$ 秒。\n  - 速度 (m/s)：\n    - $t = 0$: 单元 $0$ 到 $3$ 分别为 $\\left(10,5\\right)$、$\\left(15,10\\right)$、$\\left(8,12\\right)$、$\\left(10,9\\right)$，\n    - $t = 1$: 单元 $0$ 到 $3$ 分别为 $\\left(20,10\\right)$、$\\left(30,20\\right)$、$\\left(16,24\\right)$、$\\left(15,18\\right)$，\n    - $t = 2$: 单元 $0$ 到 $3$ 分别为 $\\left(0,0\\right)$、$\\left(0,0\\right)$、$\\left(0,0\\right)$、$\\left(0,0\\right)$。\n  - 要求结果：程序必须返回最后计算出的 $\\Delta t$（单位：秒）。\n\n您的程序必须独立计算每个测试用例，收集每个用例最后一个时间索引的最终 $\\Delta t$（单位：秒），并打印一行输出，其中包含一个用方括号括起来的、由这四个结果组成的逗号分隔列表，每个数字格式化为恰好$6$位小数。",
            "solution": "该问题要求推导并实现一个算法，用于计算线性双曲系统数值积分的全局稳定时间步长 $\\Delta t$。这将通过遵守柯朗-弗里德里希斯-列维 (CFL) 条件来完成。该过程包括两个主要阶段：首先，对直角网格上的多维系统进行第一性原理推导，得到局部稳定性约束；其次，设计一个鲁棒的算法，用于计算一个单一的全局时间步长，该步长满足计算域中所有单元的此约束，并包含安全因子和最大时间步长上限。\n\n### 第一性原理稳定性分析\n\n控制偏微分方程 (PDE) 是一个 $D$ 维线性双曲系统：\n$$\n\\frac{\\partial \\mathbf{q}}{\\partial t} + \\sum_{d=1}^{D} \\mathbf{A}_d(\\mathbf{x}) \\frac{\\partial \\mathbf{q}}{\\partial x_d} = \\mathbf{0}\n$$\nCFL 条件是双曲 PDE 显式时间积分格式稳定性的一个必要条件。它源于这样一个原理：时空中某一点解的数值依赖域必须包含该 PDE 的物理依赖域。\n\n对于一个显式有限体积或有限差分格式，在时间 $t+\\Delta t$ 单元 $i$ 中的更新值是使用时间 $t$ 时一个有限邻域单元的信息计算得出的。我们首先考虑一维情况 ($D=1$)。PDE 简化为 $\\frac{\\partial \\mathbf{q}}{\\partial t} + \\mathbf{A}_1 \\frac{\\partial \\mathbf{q}}{\\partial x_1} = \\mathbf{0}$。信息以特征速度传播，这些速度是 $\\mathbf{A}_1$ 的特征值。最大传播速度为 $s_{t,i,1}$。在时间间隔 $\\Delta t$ 内，一个波最多可以传播的物理距离是 $s_{t,i,1} \\Delta t$。一个简单的显式数值格式通常使用相邻单元的信息。为保证稳定性，数值格式必须能够“捕捉”到移动最快的物理信息。这意味着在一个时间步内波传播的距离必须小于数值模板所覆盖的距离。对于一个在间距为 $h_{i,1}$ 的网格上使用最近邻信息的格式，这要求 $s_{t,i,1} \\Delta t \\le C_{max} h_{i,1}$，其中 $C_{max}$ 是一个与格式相关的常数，通常量级为 $1$。这可以重写为柯朗数 $C_r = \\frac{s_{t,i,1} \\Delta t}{h_{i,1}}$ 的形式，条件为 $C_r \\le C_{max}$。为简单起见且不失一般性，我们可以设 $C_{max}=1$，因为任何其他值都可以被吸收到安全因子 $\\sigma$ 中。这就得出了单元 $i$ 的局部时间步长约束：\n$$\n\\Delta t \\le \\frac{h_{i,1}}{s_{t,i,1}}\n$$\n这假设 $s_{t,i,1}  0$。如果 $s_{t,i,1} = 0$，则此单元对 $\\Delta t$ 没有约束。\n\n现在，我们将其扩展到具有单元尺寸 $h_{i,1}, h_{i,2}, \\dots, h_{i,D}$ 的直角网格上的 $D$ 维空间。问题陈述中提到了“方向柯朗数的适当线性组合”。对于结构化网格上的许多显式格式（例如，使用算子分裂或多维迎风格式），稳定性约束由所有方向上波传播的综合效应决定。速度为 $s_{t,i,d}$ 的波穿过方向 $d$ 上的单元所需的时间为 $\\tau_{i,d} = h_{i,d} / s_{t,i,d}$。沿此方向穿过单元的信息传递速率是其倒数，$1/\\tau_{i,d} = s_{t,i,d} / h_{i,d}$。流出单元的总信息传递速率是每个维度速率的总和。时间步长 $\\Delta t$ 必须小于由该总速率定义的特征时间尺度。这导出了单元 $i$ 的多维 CFL 条件：\n$$\n\\Delta t \\left( \\sum_{d=1}^{D} \\frac{s_{t,i,d}}{h_{i,d}} \\right) \\le C_{max}\n$$\n再次设置 $C_{max}=1$，我们基于时间 $t$ 时单元 $i$ 的属性，得到时间步长 $\\Delta t$ 的约束：\n$$\n\\Delta t_{t,i} \\le \\frac{1}{\\sum_{d=1}^{D} \\frac{s_{t,i,d}}{h_{i,d}}}\n$$\n该公式提供了单元 $i$ 允许的最大局部时间步长。如果分母中的和为零（即所有 $s_{t,i,d}=0$），则局部时间步长约束为无穷大，意味着该单元不施加稳定性限制。\n\n### 全局时间步长计算的算法设计\n\n由于显式方法使用单一的全局时间步长 $\\Delta t_t$ 将整个计算域从时间 $t$推进到 $t+\\Delta t_t$，这个全局步长必须同时满足每个单元的稳定性条件。因此，$\\Delta t_t$ 不得大于所有局部最大稳定时间步长的最小值。\n\n在给定的时间索引 $t$ 计算全局时间步长 $\\Delta t_t$ 的算法如下：\n\n1.  **计算局部约束**：对于域中的每个单元 $i$（从 $i=0$ 到 $N-1$）：\n    a. 计算特征速度与间距之比的和：\n    $$\n    C_i = \\sum_{d=1}^{D} \\frac{s_{t,i,d}}{h_{i,d}}\n    $$\n    b. 确定最大局部稳定时间步长 $\\Delta t_{t,i}$。\n       - 如果 $C_i  0$，则 $\\Delta t_{t,i} = 1/C_i$。\n       - 如果 $C_i = 0$（当且仅当所有 $d=1, \\dots, D$ 都有 $s_{t,i,d} = 0$ 时发生，因为 $h_{i,d}0$），单元是局部静止的。它对时间步长不施加上限。我们可以将其表示为 $\\Delta t_{t,i} = \\infty$。\n\n2.  **寻找全局稳定性极限**：通过找到所有局部时间步长的最小值来确定整个网格上最严格的约束：\n    $$\n    \\Delta t_{stable} = \\min_{i \\in \\{0, \\dots, N-1\\}} \\{ \\Delta t_{t,i} \\}\n    $$\n    - 如果所有单元的速度都为零（所有 $s_{t,i,d}=0$），那么所有 $\\Delta t_{t,i} = \\infty$，因此 $\\Delta t_{stable} = \\infty$。这对应于系统的完全静止状态。\n\n3.  **应用安全因子**：应用用户提供的安全因子 $\\sigma$（其中 $0  \\sigma  1$）来减小时间步长，从而为抵抗由离散化误差或此线性分析未考虑的非线性效应引起的数值不稳定性提供安全边际。\n    $$\n    \\Delta t_{safe} = \\sigma \\cdot \\Delta t_{stable}\n    $$\n    注意，如果 $\\Delta t_{stable} = \\infty$，那么 $\\Delta t_{safe} = \\infty$。\n\n4.  **强制执行时间步长上限**：最终时间步长 $\\Delta t_t$ 是应用安全因子后的稳定步长与用户定义的最大时间步长上限 $\\Delta t_{\\mathrm{cap}}$ 中的较小者。此上限可防止时间步长变得过大，这可能出于精度原因或在系统预期会再次变为动态时是不希望的。\n    $$\n    \\Delta t_t = \\min(\\Delta t_{safe}, \\Delta t_{\\mathrm{cap}})\n    $$\n    这一步对于处理完全静止系统的情况至关重要，在这种情况下 $\\Delta t_{safe}$ 将是无限的。此时，算法正确地得出 $\\Delta t_t = \\Delta t_{\\mathrm{cap}}$。\n\n最后的任务是实现此算法，为每个测试用例计算时间步长序列，并报告在最后一个时间索引处的值。由于 $\\Delta t_t$ 的计算仅依赖于同一时间索引 $t$ 的速度 $s_{t,i,d}$，我们只需为每个测试用例中指定的最后一个时间索引执行计算，即可获得所需的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by processing each test case to find the final stable time step.\n    \"\"\"\n    \n    # Test case 1: 1D, uniform grid, dynamic speeds\n    test_case_1 = {\n        \"h\": np.full((5, 1), 10.0),\n        \"s\": np.array([\n            [[50.0], [40.0], [60.0], [55.0], [45.0]],\n            [[70.0], [30.0], [65.0], [40.0], [50.0]],\n            [[80.0], [90.0], [85.0], [75.0], [65.0]],\n        ]),\n        \"sigma\": 0.9,\n        \"dt_cap\": 1.0,\n    }\n\n    # Test case 2: 2D, anisotropic spacings, dynamic speeds\n    test_case_2 = {\n        \"h\": np.array([\n            [20.0, 10.0],\n            [25.0, 15.0],\n            [15.0, 15.0]\n        ]),\n        \"s\": np.array([\n            [[30.0, 20.0], [40.0, 10.0], [35.0, 35.0]],\n            [[25.0, 25.0], [45.0, 5.0],  [30.0, 40.0]],\n        ]),\n        \"sigma\": 0.8,\n        \"dt_cap\": 0.5,\n    }\n\n    # Test case 3: 3D, zero speeds, binding cap\n    test_case_3 = {\n        \"h\": np.full((2, 3), 10.0),\n        \"s\": np.array([\n            [[0.0, 0.0, 0.0], [5.0, 5.0, 5.0]],\n            [[1.0, 0.0, 0.0], [0.0, 0.0, 0.0]],\n        ]),\n        \"sigma\": 0.7,\n        \"dt_cap\": 0.05,\n    }\n\n    # Test case 4: 2D, all speeds become zero\n    test_case_4 = {\n        \"h\": np.array([\n            [50.0, 50.0],\n            [20.0, 30.0],\n            [40.0, 25.0],\n            [30.0, 45.0]\n        ]),\n        \"s\": np.array([\n            [[10.0, 5.0], [15.0, 10.0], [8.0, 12.0], [10.0, 9.0]],\n            [[20.0, 10.0], [30.0, 20.0], [16.0, 24.0], [15.0, 18.0]],\n            [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]],\n        ]),\n        \"sigma\": 0.95,\n        \"dt_cap\": 1.0,\n    }\n\n    test_cases = [test_case_1, test_case_2, test_case_3, test_case_4]\n    results = []\n\n    def compute_final_dt(h, s, sigma, dt_cap):\n        \"\"\"\n        Computes the stable time step for the last time index provided.\n        \n        Args:\n            h (np.ndarray): Grid spacings, shape (N, D).\n            s (np.ndarray): Characteristic speeds, shape (T, N, D).\n            sigma (float): Safety factor.\n            dt_cap (float): Maximum allowable time step.\n            \n        Returns:\n            float: The computed final time step.\n        \"\"\"\n        # We only need the state at the last time index for the final result.\n        s_last = s[-1, :, :]  # Speeds at the last time step, shape (N, D)\n        \n        # Calculate the sum of speed/spacing ratios for each cell.\n        # This is the term inside the parenthesis in the CFL condition denominator.\n        # Ratios are calculated element-wise for each cell and dimension.\n        # A small epsilon is added to the denominator h to avoid division by zero\n        # in hypothetical cases, though the problem states h > 0.\n        ratios = s_last / (h + 1e-30) \n        \n        # Sum over the spatial dimensions (axis=1) to get the local inverse time scale for each cell.\n        # `inv_dt_local` has shape (N,).\n        inv_dt_local = np.sum(ratios, axis=1)\n\n        # Calculate local stable time steps.\n        # Where inv_dt_local is 0, the local stable time step is infinite.\n        # `np.divide` with the `where` argument handles this robustly.\n        dt_local = np.full_like(inv_dt_local, np.inf)\n        # Create a mask for non-zero entries to avoid division by zero.\n        nonzero_mask = inv_dt_local > 0\n        dt_local[nonzero_mask] = 1.0 / inv_dt_local[nonzero_mask]\n        \n        # The global stable time step is the minimum of all local time steps.\n        dt_stable = np.min(dt_local)\n        \n        # Apply the safety factor.\n        dt_safe = sigma * dt_stable\n        \n        # Enforce the maximum time step cap. np.min handles infinite values correctly.\n        final_dt = np.min([dt_safe, dt_cap])\n        \n        return final_dt\n\n    for case in test_cases:\n        result = compute_final_dt(case[\"h\"], case[\"s\"], case[\"sigma\"], case[\"dt_cap\"])\n        results.append(result)\n\n    # Format the results to exactly 6 decimal places and print.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}