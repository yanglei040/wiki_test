{
    "hands_on_practices": [
        {
            "introduction": "雅可比矩阵是高斯-牛顿方法的核心。第一个实践将超越抽象的定义，要求您为一个简单但具有代表性的地球物理模型推导雅可比矩阵 。通过分析所得矩阵的每一个元素，您将建立起具体的直觉，理解雅可比矩阵如何量化测量数据对每个模型参数的物理敏感性，以及这种敏感性如何直接影响反演的稳定性。",
            "id": "3599237",
            "problem": "考虑一个双参数地球物理模型 $m=\\begin{pmatrix} m_1 \\\\ m_2 \\end{pmatrix}$，其中 $m_1$ 代表一个控制带限振幅响应的标量属性，$m_2$ 代表一个与各向异性相关的耦合参数。正演算子 $F:\\mathbb{R}^2\\to\\mathbb{R}^2$ 定义为 $F(m)=\\begin{pmatrix} \\sin(\\alpha m_1) \\\\ m_1 m_2 \\end{pmatrix}$，其中 $\\alpha>0$ 是一个已知的缩放常数，其单位的选择使得正弦函数的参数为无量纲。数据加权矩阵为单位矩阵 $W_d=I$。非线性最小二乘残差定义为 $\\phi(m)=\\tfrac{1}{2}\\|F(m)-d\\|_2^2$，其中 $d\\in\\mathbb{R}^2$ 是观测数据。\n\n从 $F(m)$ 的雅可比矩阵和残差的高斯-牛顿线性化的核心定义出发，显式地推导雅可比矩阵 $J(m)$（用 $m_1$、$m_2$ 和 $\\alpha$ 表示）。然后，解释 $J(m)$ 的每个元素如何反映数据对参数的物理灵敏度，并阐释这些元素的大小和符号如何影响高斯-牛顿法向矩阵的条件数。您的推导应从第一性原理出发，不使用任何关于 $F(m)$ 的雅可比矩阵或高斯-牛顿法的现成公式。\n\n请提供 $J(m)$ 的显式闭式解析表达式作为您的最终答案。无需进行数值舍入。如果引入任何角度，它们必须以弧度为单位。由于最终答案是符号表达式，请勿在最终表达式中包含单位。",
            "solution": "本题要求对给定的正演模型 $F(m)$ 推导其雅可比矩阵 $J(m)$，并解释其元素的物理意义及其对高斯-牛顿法的影响。对问题陈述的验证确认了其科学性、适定性和客观性。我们可以开始求解。\n\n正演模型是一个函数 $F: \\mathbb{R}^2 \\to \\mathbb{R}^2$，它将模型参数向量 $m=\\begin{pmatrix} m_1 \\\\ m_2 \\end{pmatrix}$ 映射到数据向量。正演算子的分量由下式给出：\n$$\nF(m) = \\begin{pmatrix} F_1(m_1, m_2) \\\\ F_2(m_1, m_2) \\end{pmatrix} = \\begin{pmatrix} \\sin(\\alpha m_1) \\\\ m_1 m_2 \\end{pmatrix}\n$$\n其中 $\\alpha > 0$ 是一个已知常数。\n\n根据定义，向量值函数 $F(m)$ 的雅可比矩阵 $J(m)$ 是由所有一阶偏导数组成的矩阵。对于一个从 $\\mathbb{R}^2$ 映射到 $\\mathbb{R}^2$ 的函数，它是一个 $2 \\times 2$ 矩阵：\n$$\nJ(m) = \\begin{pmatrix} \\frac{\\partial F_1}{\\partial m_1} & \\frac{\\partial F_1}{\\partial m_2} \\\\ \\frac{\\partial F_2}{\\partial m_1} & \\frac{\\partial F_2}{\\partial m_2} \\end{pmatrix}\n$$\n\n我们从第一性原理出发，利用偏微分法则计算 $J(m)$ 的每个元素。\n\n第一个元素 $J_{11}$ 是 $F_1(m_1, m_2) = \\sin(\\alpha m_1)$ 对 $m_1$ 的偏导数。应用链式法则，我们得到：\n$$\nJ_{11} = \\frac{\\partial}{\\partial m_1} \\left( \\sin(\\alpha m_1) \\right) = \\cos(\\alpha m_1) \\cdot \\frac{\\partial}{\\partial m_1}(\\alpha m_1) = \\alpha \\cos(\\alpha m_1)\n$$\n\n第二个元素 $J_{12}$ 是 $F_1(m_1, m_2) = \\sin(\\alpha m_1)$ 对 $m_2$ 的偏导数。由于 $F_1$ 不依赖于 $m_2$，该导数为零：\n$$\nJ_{12} = \\frac{\\partial}{\\partial m_2} \\left( \\sin(\\alpha m_1) \\right) = 0\n$$\n\n第三个元素 $J_{21}$ 是 $F_2(m_1, m_2) = m_1 m_2$ 对 $m_1$ 的偏导数：\n$$\nJ_{21} = \\frac{\\partial}{\\partial m_1} \\left( m_1 m_2 \\right) = m_2\n$$\n\n第四个元素 $J_{22}$ 是 $F_2(m_1, m_2) = m_1 m_2$ 对 $m_2$ 的偏导数：\n$$\nJ_{22} = \\frac{\\partial}{\\partial m_2} \\left( m_1 m_2 \\right) = m_1\n$$\n\n将这些偏导数组合成矩阵，得到雅可比矩阵 $J(m)$ 的显式形式：\n$$\nJ(m) = \\begin{pmatrix} \\alpha \\cos(\\alpha m_1) & 0 \\\\ m_2 & m_1 \\end{pmatrix}\n$$\n\n接下来，我们解释这些元素的物理意义及其对高斯-牛顿法向矩阵条件数的影响。每个元素 $J_{ij} = \\frac{\\partial F_i}{\\partial m_j}$ 代表第 $i$ 个数据分量对第 $j$ 个模型参数无穷小变化的灵敏度。\n- $J_{11} = \\alpha \\cos(\\alpha m_1)$: 该项量化了第一个数据 $F_1 = \\sin(\\alpha m_1)$ 对参数 $m_1$ 变化的灵敏度。该灵敏度是振荡的，当 $|\\cos(\\alpha m_1)| = 1$ 时（即 $\\alpha m_1$ 是 $\\pi$ 的整数倍时），其幅值最大。在这些点上，函数 $F_1$ 穿过零点，且最陡峭。相反，当 $\\cos(\\alpha m_1) = 0$ 时（即 $\\alpha m_1 = (n + \\frac{1}{2})\\pi$，其中 $n$ 为任意整数），灵敏度为零。这些点对应于正弦波的波峰和波谷，在这些地方，$m_1$ 的微小变化对 $F_1$ 产生的影响可以忽略不计。\n- $J_{12} = 0$: 这表示第一个数据 $F_1$ 对参数 $m_2$ 的变化完全不敏感。根据此模型，带限振幅响应的测量与各向异性参数完全解耦。\n- $J_{21} = m_2$: 这是第二个数据 $F_2 = m_1 m_2$ 对 $m_1$ 扰动的灵敏度。该灵敏度与耦合参数 $m_2$ 的值成正比。如果 $m_2$ 接近于零，第二个数据对 $m_1$ 变得不敏感，这意味着弱耦合。\n- $J_{22} = m_1$: 这是第二个数据 $F_2$ 对 $m_2$ 变化的灵敏度。该灵敏度与 $m_1$ 成正比。如果 $m_1$ 接近于零，第二个数据对各向异性参数 $m_2$不敏感。\n\n高斯-牛顿法使用矩阵 $H_{GN} = J(m)^T J(m)$（因为数据加权矩阵 $W_d = I$）来近似残差函数 $\\phi(m)$ 的Hessian矩阵。该法向矩阵的条件数对于反演的稳定性和收敛性至关重要。一个病态或奇异的 $H_{GN}$ 会导致不稳定的参数更新。\n法向矩阵为：\n$$\nH_{GN} = J^T J = \\begin{pmatrix} \\alpha \\cos(\\alpha m_1) & m_2 \\\\ 0 & m_1 \\end{pmatrix} \\begin{pmatrix} \\alpha \\cos(\\alpha m_1) & 0 \\\\ m_2 & m_1 \\end{pmatrix} = \\begin{pmatrix} \\alpha^2 \\cos^2(\\alpha m_1) + m_2^2 & m_1 m_2 \\\\ m_1 m_2 & m_1^2 \\end{pmatrix}\n$$\n局部线性问题的适定性取决于 $H_{GN}$ 是否可逆。这等价于 $J(m)$ 的列向量是否线性无关。$H_{GN}$ 的行列式提供了对此的度量。对于方阵 $A$，使用属性 $\\det(A^T A) = (\\det A)^2$，我们可以计算：\n$$\n\\det(J) = (\\alpha \\cos(\\alpha m_1))(m_1) - (0)(m_2) = \\alpha m_1 \\cos(\\alpha m_1)\n$$\n因此，法向矩阵的行列式为：\n$$\n\\det(H_{GN}) = (\\det(J))^2 = \\alpha^2 m_1^2 \\cos^2(\\alpha m_1)\n$$\n如果 $\\det(H_{GN}) = 0$，法向矩阵 $H_{GN}$ 变为奇异矩阵，反演问题变为病态问题。这在两种情况下发生：\n1. $m_1 = 0$：如果振幅参数 $m_1$为零，雅可比矩阵变为 $J = \\begin{pmatrix} \\alpha & 0 \\\\ m_2 & 0 \\end{pmatrix}$，其列向量是线性相关的。在物理上，如果 $m_1=0$，那么对于任何 $m_2$ 的值，都有 $F(m) = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。数据不包含关于 $m_2$ 的任何信息，使其无法被恢复。\n2. $\\cos(\\alpha m_1) = 0$：当 $\\alpha m_1 = \\frac{\\pi}{2} + k\\pi$（其中 $k$ 为任意整数）时发生。在这种情况下，雅可比矩阵为 $J = \\begin{pmatrix} 0 & 0 \\\\ m_2 & m_1 \\end{pmatrix}$。第一行為零，使得矩阵秩亏。在物理上，这对应于如前所述的第一个数据 $d_1$ 相对于 $m_1$ 的灵敏度为零的点。在 $F_1$ 的这些极值点，$m_1$ 的微小扰动无法在第一个数据中被“观测”到，导致信息丢失和系统病态。\n\n元素的大小也影响条件数。如果 $m_1$ 非常小，$\\det(H_{GN})$ 会变得非常小，导致条件数很差。类似地，如果模型接近于 $\\cos(\\alpha m_1) \\approx 0$ 的点，问题也近乎病态。雅可比矩阵元素的符号虽然不直接影响 $J^T J$ 的条件数（因为项被平方了），但对于确定高斯-牛顿算法中参数更新步长 $\\delta m$ 的方向至关重要，因为更新依赖于乘积 $J^T (d - F(m))$。",
            "answer": "$$\n\\boxed{\nJ(m) = \\begin{pmatrix}\n\\alpha \\cos(\\alpha m_1) & 0 \\\\\nm_2 & m_1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "将高斯-牛顿方法应用于波动问题时，一个重大的挑战是“周波跳跃”（cycle skipping），即算法由于较大的相位失配而陷入错误的局部极小值。本练习在一个简化的波形反演场景中，有力地展示了这一现象 。您将亲眼看到为什么标准的最小二乘误差函数会失效，然后实现一个基于信号包络的、更稳健的替代误差函数，以引导反演摆脱这些局部陷阱。",
            "id": "3599323",
            "problem": "您需要实现一个完整的、可运行的程序，构建一个一维波形反演玩具模型。在此模型中，正演模拟算子生成一个作为时移 Ricker 子波的单一反射脉冲。反演目标是单个未知参数，即恒定的声波速度，而数据是在地表测量的合成地震图。目标是研究非线性最小二乘 (NLS) 的高斯-牛顿法在标准基于振幅的最小二乘残差和另一种基于包络的失配下的行为，以说明前者中的周波跳跃现象，并展示后者中高斯-牛顿步长的变化。\n\n使用以下基本设置和定义：\n\n- 观测数据是在深度为 $z$ 的单个平坦地下反射层上获取的，介质为速度未知（模型变量为 $m$）的恒速介质。双程走时为 $\\tau(m) = \\dfrac{2 z}{m}$。\n- 震源子波是 Ricker 子波 $s(t) = \\left(1 - 2 a t^2\\right) \\exp\\left(- a t^2\\right)$，其中 $a = \\left(\\pi f_0\\right)^2$，$f_0$ 是中心频率。\n- 无噪声的正演模型是合成地震图 $d\\!\\left(t; m\\right) = s\\!\\left(t - \\tau(m)\\right)$。\n- 基于振幅的最小二乘目标函数为 $\\Phi_{\\mathrm{wf}}(m) = \\dfrac{1}{2} \\left\\| r_{\\mathrm{wf}}(m) \\right\\|_2^2$，其残差为 $r_{\\mathrm{wf}}(t; m) = d_{\\mathrm{obs}}(t) - d\\!\\left(t; m\\right)$。\n- 基于包络的替代失配函数使用振幅包络 $e\\!\\left(t; m\\right) = \\sqrt{ d\\!\\left(t; m\\right)^2 + \\left( \\mathcal{H}\\{ d\\!\\left(t; m\\right) \\} \\right)^2 }$，其中 $\\mathcal{H}\\{\\cdot\\}$ 表示希尔伯特变换，目标函数为 $\\Phi_{\\mathrm{env}}(m) = \\dfrac{1}{2} \\left\\| r_{\\mathrm{env}}(m) \\right\\|_2^2$，其残差为 $r_{\\mathrm{env}}(t; m) = e_{\\mathrm{obs}}(t) - e\\!\\left(t; m\\right)$。\n\n从第一性原理出发，为每个目标函数推导高斯-牛顿步长：\n\n- 从非线性最小二乘目标函数 $\\Phi(m) = \\dfrac{1}{2} \\left\\| r(m) \\right\\|_2^2$ 的定义和高斯-牛顿近似开始，该近似用 $J(m)^\\top J(m)$ 替代精确的 Hessian 矩阵，其中 $J(m)$ 是残差关于 $m$ 的 Jacobian 矩阵。\n- 对于波形残差，使用链式法则和 Ricker 子波的导数，推导 Jacobian 矩阵的项 $J_{\\mathrm{wf}}(t; m) = \\dfrac{\\partial}{\\partial m} d\\!\\left(t; m\\right)$。Ricker 子波的导数是 $s'(t) = \\exp\\!\\left(- a t^2\\right) \\, t \\left( - 6 a + 4 a^2 t^2 \\right)$。用 $z$，$m$ 和 $s'\\!\\big(t - \\tau(m)\\big)$ 明确表示 $J_{\\mathrm{wf}}(t; m)$。\n- 对于包络残差，利用 $\\mathcal{H}\\{\\cdot\\}$ 是线性算子这一事实，通过链式法则推导 Jacobian 矩阵的项 $J_{\\mathrm{env}}(t; m) = \\dfrac{\\partial}{\\partial m} e\\!\\left(t; m\\right)$：$e(t; m) = \\sqrt{x(t; m)^2 + y(t; m)^2}$，其中 $x = d(t; m)$ 和 $y = \\mathcal{H}\\{ d(t; m) \\}$。证明 $\\dfrac{\\partial e}{\\partial m}(t; m) = \\dfrac{ x \\, \\dfrac{\\partial x}{\\partial m} + y \\, \\dfrac{\\partial y}{\\partial m} }{ e }$ 并将 $\\dfrac{\\partial y}{\\partial m}$ 与 $\\mathcal{H}\\!\\left\\{ \\dfrac{\\partial x}{\\partial m} \\right\\}$ 联系起来。\n\n然后，为每个目标函数写出单个参数 $m$ 的高斯-牛顿更新公式：\n$$\n\\Delta m_{\\bullet} = \\dfrac{ \\sum_t J_{\\bullet}(t; m_0) \\, r_{\\bullet}(t; m_0) }{ \\sum_t J_{\\bullet}(t; m_0)^2 },\n$$\n其中 $ \\bullet \\in \\{ \\mathrm{wf}, \\mathrm{env} \\} $ 且 $ m_0 $ 是当前的模型迭代值。解释为什么当 $m_0$ 与真实值相差足够远时，基于波形的残差 $r_{\\mathrm{wf}}$ 会表现出周波跳跃现象，这表现为多周期的相位失配，导致 $J_{\\mathrm{wf}}^\\top r_{\\mathrm{wf}}$ 的符号具有误导性或其幅值很小，从而产生一个不佳的 $\\Delta m_{\\mathrm{wf}}$。将此与基于包络的残差进行对比，后者抑制了振荡相位效应，通常能提供一个更稳健的、朝向真实解的步长 $\\Delta m_{\\mathrm{env}}$。\n\n物理和数值参数：\n\n- 深度 $z = 1000\\,\\mathrm{m}$。\n- 真实速度 $m_\\star = 2000\\,\\mathrm{m/s}$。\n- 中心频率 $f_0 = 10\\,\\mathrm{Hz}$。\n- 时间采样间隔 $\\Delta t = 0.001\\,\\mathrm{s}$。\n- 记录长度 $T = 2.5\\,\\mathrm{s}$。\n\n角度，包括可能隐含在解析信号中的任何相位，都应以弧度为单位。\n\n初始模型速度 $m_0$ 的测试集：\n\n- 情况1（完美匹配）：$m_0 = 2000\\,\\mathrm{m/s}$。\n- 情况2（接近，低于半周期的失配）：$m_0 = 2100\\,\\mathrm{m/s}$。\n- 情况3（中等周波跳跃，约一个周期的失配）：$m_0 = 1800\\,\\mathrm{m/s}$。\n- 情况4（严重周波跳跃，多个周期）：$m_0 = 1500\\,\\mathrm{m/s}$。\n\n您的程序必须：\n\n- 使用 $m_\\star$ 构建 $d_{\\mathrm{obs}}(t)$，并针对测试集中的每个 $m_0$，根据上述高斯-牛顿公式计算 $\\Delta m_{\\mathrm{wf}}$ 和 $\\Delta m_{\\mathrm{env}}$。\n- 使用希尔伯特变换计算包络和包络 Jacobian 矩阵，并采取适当的数值保护措施，以避免在包络振幅极小时出现除以零的情况。\n- 将每个 $\\Delta m$ 以米/秒（$\\mathrm{m/s}$）表示，并四舍五入到 $6$ 位小数。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。此列表中的每个元素对应一个测试用例，并且本身必须是一个包含该用例的高斯-牛顿步长 $\\Delta m_{\\mathrm{wf}}$ 和 $\\Delta m_{\\mathrm{env}} $ 的二元列表（按此顺序）。例如，输出应类似于 $\\left[ [\\Delta m_{\\mathrm{wf}}^{(1)}, \\Delta m_{\\mathrm{env}}^{(1)}], \\ldots, [\\Delta m_{\\mathrm{wf}}^{(4)}, \\Delta m_{\\mathrm{env}}^{(4)}] \\right]$，其中每个数字都打印为 $6$ 位小数，并隐式以 $\\mathrm{m/s}$ 为单位。",
            "solution": "用户提供了一个有效的问题陈述。任务是分析一维波形反演问题的高斯-牛顿优化方法，比较标准的基于波形的目标函数和基于包络的替代方案。分析的重点是周波跳跃现象。解决方案需要为每个目标函数推导高斯-牛顿步长，然后实现一个数值模拟来为几个初始模型计算这些步长。\n\n首先，我们建立理论框架。目标是找到模型参数 $m$（声波速度），以最小化形式为 $\\Phi(m) = \\frac{1}{2} \\|r(m)\\|_2^2$ 的非线性最小二乘目标函数，其中 $r(m)$ 是观测数据和预测数据之间的残差向量。对于离散时间序列，这表示为 $\\Phi(m) = \\frac{1}{2} \\sum_t [r(t; m)]^2$。\n\n高斯-牛顿法通过求解正规方程 $J(m)^\\top J(m) \\Delta m = J(m)^\\top r(m)$ 来计算模型更新步长 $\\Delta m$，其中 $J(m)$ 是正演模型 $d(t;m)$ 的雅可比矩阵，而 $r(m) = d_{\\text{obs}}(t) - d(t;m)$ 是数据残差。模型通过 $m_{k+1} = m_k + \\Delta m$ 进行迭代更新。对于单参数问题，这简化为问题陈述中给出的标量公式，其中 $J$ 代表正演模型的雅可比矩阵。我们的任务是为两个不同的目标函数推导雅可比矩阵 $J$。\n\n合成数据的正演模型是一个时移 Ricker 子波：$d(t; m) = s(t - \\tau(m))$，其中 $s(t) = (1 - 2 a t^2) \\exp(-a t^2)$，$a = (\\pi f_0)^2$，双程走时为 $\\tau(m) = \\frac{2z}{m}$。\n\n**1. 基于波形的目标函数 $\\Phi_{\\mathrm{wf}}(m)$**\n\n残差为 $r_{\\mathrm{wf}}(t; m) = d_{\\mathrm{obs}}(t) - d(t; m)$。正演模型 $d(t;m)$ 关于 $m$ 的雅可比矩阵 $J_{\\mathrm{wf}}(t; m)$ 通过链式法则计算：\n$$\nJ_{\\mathrm{wf}}(t; m) = \\frac{\\partial d(t; m)}{\\partial m} = \\frac{\\partial}{\\partial m} s(t - \\tau(m)) = s'(t - \\tau(m)) \\cdot \\left( -\\frac{\\partial \\tau(m)}{\\partial m} \\right)\n$$\n走时的导数是 $\\frac{\\partial \\tau(m)}{\\partial m} = \\frac{\\partial}{\\partial m}\\left(\\frac{2z}{m}\\right) = -\\frac{2z}{m^2}$。\n代入此式，我们得到：\n$$\nJ_{\\mathrm{wf}}(t; m) = s'(t - \\tau(m)) \\cdot \\left( - \\left( -\\frac{2z}{m^2} \\right) \\right) = \\frac{2z}{m^2} s'(t - \\tau(m))\n$$\n其中 Ricker 子波的导数由 $s'(t) = \\exp(- a t^2) \\, t \\, (-6 a + 4 a^2 t^2)$ 给出。高斯-牛顿步长则为：\n$$\n\\Delta m_{\\mathrm{wf}} = \\frac{\\sum_t J_{\\mathrm{wf}}(t; m_0) \\, r_{\\mathrm{wf}}(t; m_0)}{\\sum_t J_{\\mathrm{wf}}(t; m_0)^2}\n$$\n\n**2. 基于包络的目标函数 $\\Phi_{\\mathrm{env}}(m)$**\n\n残差为 $r_{\\mathrm{env}}(t; m) = e_{\\mathrm{obs}}(t) - e(t; m)$，其中 $e(t; m)$ 是信号 $d(t; m)$ 的振幅包络，定义为 $e(t; m) = |d(t;m) + i \\mathcal{H}\\{d(t;m)\\}|$，$\\mathcal{H}\\{\\cdot\\}$ 表示希尔伯特变换。\n令 $x(t; m) = d(t; m)$ 和 $y(t; m) = \\mathcal{H}\\{d(t; m)\\}$。那么 $e(t; m) = \\sqrt{x^2 + y^2}$。正演模型 $e(t; m)$ 的雅可比矩阵是：\n$$\nJ_{\\mathrm{env}}(t; m) = \\frac{\\partial e}{\\partial m} = \\frac{1}{2\\sqrt{x^2+y^2}} \\left( 2x \\frac{\\partial x}{\\partial m} + 2y \\frac{\\partial y}{\\partial m} \\right) = \\frac{x \\frac{\\partial x}{\\partial m} + y \\frac{\\partial y}{\\partial m}}{e}\n$$\n我们有 $\\frac{\\partial x}{\\partial m} = \\frac{\\partial d}{\\partial m} = J_{\\mathrm{wf}}(t; m)$。由于希尔伯特变换是线性算子，其应用与对 $m$ 的微分可以交换顺序：\n$$\n\\frac{\\partial y}{\\partial m} = \\frac{\\partial}{\\partial m} \\mathcal{H}\\{d(t; m)\\} = \\mathcal{H}\\left\\{\\frac{\\partial d(t; m)}{\\partial m}\\right\\} = \\mathcal{H}\\{J_{\\mathrm{wf}}(t; m)\\}\n$$\n代入这些结果，我们得到包络雅可比矩阵的显式公式：\n$$\nJ_{\\mathrm{env}}(t; m) = \\frac{d(t; m) J_{\\mathrm{wf}}(t; m) + \\mathcal{H}\\{d(t; m)\\} \\mathcal{H}\\{J_{\\mathrm{wf}}(t; m)\\}}{e(t; m)}\n$$\n因此，包络目标函数的高斯-牛顿步长为：\n$$\n\\Delta m_{\\mathrm{env}} = \\frac{\\sum_t J_{\\mathrm{env}}(t; m_0) \\, r_{\\mathrm{env}}(t; m_0)}{\\sum_t J_{\\mathrm{env}}(t; m_0)^2}\n$$\n\n**3. 周波跳跃分析**\n\n基于波形的目标函数 $\\Phi_{\\mathrm{wf}}$ 作为模型参数 $m$ 的函数是高度振荡的，表现出许多局部极小值。当预测子波 $d(t; m_0)$ 与观测数据 $d_{\\mathrm{obs}}(t)$ 的错位是子波半周期的整数倍时，就会出现这些极小值。$\\Delta m_{\\mathrm{wf}}$ 公式中的分子 $\\sum_t J_{\\mathrm{wf}} r_{\\mathrm{wf}}$ 代表了残差与雅可比矩阵的互相关。当初始猜测 $m_0$ 远离真实值 $m_\\star$ 时，时移 $\\tau(m_0) - \\tau(m_\\star)$ 可能很大。如果这个时移超过了子波主周期的大约一半，相关性可能会变小甚至符号反转。符号反转会导致高斯-牛顿步长指向错误的方向，远离真实解。这种未能找到正确极小值的失败现象被称为周波跳跃。\n\n相比之下，包络 $e(t; m)$ 是一个平滑的、非振荡的时间函数，其最大值位于群到达时 $\\tau(m)$ 处。因此，基于包络的目标函数 $\\Phi_{\\mathrm{env}}$ 在更宽的 $m$ 值范围内更为平滑和凸。其围绕全局最小值的吸引盆更大，使得优化不易受周波跳跃的影响。残差 $r_{\\mathrm{env}}$ 捕捉了到达时间的失配，而没有振荡干扰，它与其雅可比矩阵 $J_{\\mathrm{env}}$ 的相关性通常能为即使是较大的初始 $m_0$ 误差提供稳健的更新方向。\n\n下面的程序为指定的测试用例实现了这些计算，展示了与波形失配相比，包络失配的稳健性。在 $J_{\\mathrm{env}}$ 的分母中的包络上添加了一个小常数 $\\epsilon$ 以确保数值稳定性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import hilbert\n\ndef solve():\n    \"\"\"\n    Computes and compares Gauss-Newton steps for waveform and envelope\n    misfit functions in a 1D seismic inversion toy problem.\n    \"\"\"\n    # Physical and numerical parameters\n    z = 1000.0  # Reflector depth in meters\n    m_true = 2000.0  # True velocity in m/s\n    f0 = 10.0  # Central frequency in Hz\n    dt = 0.001  # Time sampling interval in seconds\n    t_max = 2.5  # Record length in seconds\n    epsilon = 1e-9 # Small constant for numerical stability\n\n    # Time vector\n    t = np.arange(0, t_max, dt)\n\n    # Ricker wavelet and its derivative\n    a = (np.pi * f0)**2\n    def ricker(time_vec):\n        return (1.0 - 2.0 * a * time_vec**2) * np.exp(-a * time_vec**2)\n\n    def ricker_derivative(time_vec):\n        return np.exp(-a * time_vec**2) * time_vec * (-6.0 * a + 4.0 * a**2 * time_vec**2)\n\n    # Forward modeling operator\n    def forward_model(m, time_vec):\n        tau = 2.0 * z / m\n        return ricker(time_vec - tau)\n\n    # Generate observed data\n    d_obs = forward_model(m_true, t)\n\n    # Test cases for initial model velocities\n    test_cases = [2000.0, 2100.0, 1800.0, 1500.0]\n\n    results = []\n    \n    for m0 in test_cases:\n        # Calculate predicted data for the current model parameter m0\n        d_pred = forward_model(m0, t)\n\n        # --- 1. Waveform-based inversion step ---\n        r_wf = d_obs - d_pred\n        \n        # Calculate Jacobian for waveform misfit\n        tau0 = 2.0 * z / m0\n        # The Jacobian is d(d)/dm = s'(t-tau) * d(-tau)/dm = s'(t-tau) * (2z/m^2)\n        J_wf = (2.0 * z / m0**2) * ricker_derivative(t - tau0)\n\n        # Calculate Gauss-Newton step for waveform\n        numerator_wf = np.sum(J_wf * r_wf)\n        denominator_wf = np.sum(J_wf**2)\n        \n        if np.isclose(denominator_wf, 0):\n            delta_m_wf = 0.0\n        else:\n            # The update is m_k+1 = m_k + delta_m.\n            # For m0=2100 > m_true=2000, we want a negative delta_m.\n            # For m0=1800  m_true=2000, we want a positive delta_m.\n            # The code calculates this correctly.\n            delta_m_wf = numerator_wf / denominator_wf\n\n        # --- 2. Envelope-based inversion step ---\n        \n        # Calculate analytic signals and envelopes\n        analytic_obs = hilbert(d_obs)\n        analytic_pred = hilbert(d_pred)\n        \n        e_obs = np.abs(analytic_obs)\n        e_pred = np.abs(analytic_pred)\n\n        r_env = e_obs - e_pred\n        \n        # Calculate Jacobian for envelope misfit\n        # J_env = d(e)/dm = [d*d(d)/dm + H{d}*d(H{d})/dm] / e\n        #       = [d*J_wf + H{d}*H{J_wf}] / e\n        analytic_J_wf = hilbert(J_wf)\n        \n        # The numerator is the real part of (analytic_pred_conj * analytic_J_wf)\n        numerator_J_env = np.real(np.conj(analytic_pred) * analytic_J_wf)\n        J_env = np.divide(numerator_J_env, e_pred + epsilon, \n                          out=np.zeros_like(numerator_J_env), \n                          where=(e_pred + epsilon) != 0)\n\n        # Calculate Gauss-Newton step for envelope\n        numerator_env = np.sum(J_env * r_env)\n        denominator_env = np.sum(J_env**2)\n\n        if np.isclose(denominator_env, 0):\n            delta_m_env = 0.0\n        else:\n            delta_m_env = numerator_env / denominator_env\n\n        results.append([round(delta_m_wf, 6), round(delta_m_env, 6)])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在计算科学中，未经检验的实现就是不正确的实现。最后一个实践介绍了一种名为“梯度检验”的基本验证技术，以确保您的代码是可靠的 。您将使用计算高效的伴随状态法来计算高斯-牛顿梯度，然后通过与简单直观的有限差分近似进行比较来验证其正确性，这对任何严谨的从业者来说都是一项至关重要的技能。",
            "id": "3599258",
            "problem": "要求您在计算地球物理学中的非线性最小二乘高斯-牛顿法的背景下，实现并验证一个非线性最小二乘目标的梯度计算。验证基于通过伴随式解析表达式获得的梯度和通过有限差分获得的梯度之间的夹角余弦值。本问题中的所有量均为无量纲。\n\n考虑一个由线性映射和逐点非线性变换复合而成的正演算子。具体来说，设 $W \\in \\mathbb{R}^{N \\times K}$，$B \\in \\mathbb{R}^{K \\times P}$，以及 $m \\in \\mathbb{R}^{P}$。定义正演映射 $F(m) \\in \\mathbb{R}^{N}$ 为\n$$\nF(m) = W \\sin(B m),\n$$\n其中 $\\sin(\\cdot)$ 逐元素作用于向量 $B m \\in \\mathbb{R}^{K}$。给定观测数据 $d_{\\text{obs}} \\in \\mathbb{R}^{N}$，定义残差向量 $r(m) \\in \\mathbb{R}^{N}$ 为\n$$\nr(m) = F(m) - d_{\\text{obs}},\n$$\n以及最小二乘目标为\n$$\n\\phi(m) = \\frac{1}{2} \\|r(m)\\|_2^2.\n$$\n在高斯-牛顿法中，$\\phi(m)$ 的梯度是 $J(m)^{\\top} r(m)$，其中 $J(m)$ 是 $F(m)$ 关于 $m$ 的雅可比矩阵。您的任务是：\n- 基于链式法则，推导并实现一个用于计算 $J(m)^{\\top} r(m)$ 的伴随式表达式，而无需显式构造 $J(m)$。\n- 通过独立扰动 $m$ 的每个分量来估计 $\\phi(m)$ 的偏导数，从而实现对 $\\phi(m)$ 梯度的中心有限差分近似。\n- 计算伴随梯度 $g_{\\text{adj}}(m) = J(m)^{\\top} r(m)$ 和有限差分梯度 $g_{\\text{fd}}(m)$ 之间的夹角余弦值：\n$$\n\\cos \\theta(m) = \\frac{g_{\\text{adj}}(m) \\cdot g_{\\text{fd}}(m)}{\\|g_{\\text{adj}}(m)\\|_2 \\, \\|g_{\\text{fd}}(m)\\|_2}.\n$$\n为了保证数值稳健性，请使用以下特殊情况处理规则：\n- 如果 $\\|g_{\\text{adj}}(m)\\|_2$ 和 $\\|g_{\\text{fd}}(m)\\|_2$ 都小于阈值 $10^{-12}$，则定义 $\\cos \\theta(m) = 1.0$。\n- 如果两个范数中只有一个小于 $10^{-12}$，则定义 $\\cos \\theta(m) = 0.0$。\n- 否则，使用上述公式。\n\n实现您的程序，以对下面指定的测试套件计算 $\\cos \\theta(m)$。程序必须使用双精度算术，并对 $m$ 的第 $i$ 个分量使用自适应中心有限差分步长 $h_i$，其定义为\n$$\nh_i = 10^{-6} \\max(1, |m_i|).\n$$\n不涉及物理单位；所有量均为无量纲。\n\n测试套件规范：\n- 测试用例 $1$ (一般情况): $N=8$, $K=10$, $P=5$。使用伪随机种子 $123$ (用于 $W$) 和 $456$ (用于 $B$) 生成均值为零、单位方差的独立高斯项来构造 $W$ 和 $B$。设 $m_{\\text{true}}$ 为高斯分布，种子为 $789$。设 $d_{\\text{obs}} = W \\sin(B m_{\\text{true}}) + \\eta$，其中 $\\eta$ 是标准差为 $10^{-3}$、种子为 $321$ 的高斯噪声。在 $m_0 = m_{\\text{true}}$ 处计算 $\\cos \\theta$。\n- 测试用例 $2$ (中等扰动): 使用与测试用例 1 相同的 $W$、$B$ 和 $d_{\\text{obs}}$。设 $m_0 = m_{\\text{true}} + \\delta$，其中 $\\delta$ 是种子为 $654$ 的高斯分布，并进行缩放以使每个分量的标准差为 $10^{-1}$。\n- 测试用例 $3$ (边界维度): $N=4$, $K=3$, $P=1$。种子：$5$ (用于 $W$)，$6$ (用于 $B$)。设 $m_{\\text{true}} = [0.7]^{\\top}$。设 $d_{\\text{obs}} = W \\sin(B m_{\\text{true}}) + \\eta$，其中 $\\eta$ 是标准差为 $10^{-4}$、种子为 $11$ 的高斯噪声。在 $m_0 = m_{\\text{true}}$ 处进行评估。\n- 测试用例 $4$ (零残差边缘情况): $N=6$, $K=7$, $P=3$。种子：$7$ (用于 $W$)，$8$ (用于 $B$)。设 $m_0$ 为高斯分布，种子为 $12$。设 $d_{\\text{obs}} = W \\sin(B m_0)$ 为精确值(无噪声)。在 $m_0$ 处进行评估。\n- 测试用例 $5$ (因参数接近 $\\pi/2$ 导致的近零梯度): $N=5$, $K=5$, $P=5$。种子：$9$ (用于 $W$)，$10$ (用于 $B$)。定义 $v = (\\pi/2) \\mathbf{1} \\in \\mathbb{R}^{K}$，并设 $m_0$ 为 $B m \\approx v$ 的最小二乘解。设 $d_{\\text{obs}} = \\mathbf{0} \\in \\mathbb{R}^{N}$。在 $m_0$ 处进行评估。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[result1,result2,result3]$）。这五个结果必须是按顺序排列的测试用例 1 到 5 的 $\\cos \\theta$ 值。每个输出值必须是浮点数。",
            "solution": "该问题要求实现并验证一种用于计算非线性最小二乘目标函数梯度的伴随状态法。验证是通过将伴随状态梯度与通过中心有限差分近似的梯度进行比较来执行的。问题的核心在于正确推导和实现伴随状态梯度计算（该计算避免了雅可比矩阵的显式构造），以及对两个得到的梯度向量进行稳健的数值比较。\n\n设模型参数为一个向量 $m \\in \\mathbb{R}^{P}$。正演模型 $F(m)$ 将参数映射到数据空间 $\\mathbb{R}^{N}$，定义如下：\n$$\nF(m) = W \\sin(B m)\n$$\n其中 $W \\in \\mathbb{R}^{N \\times K}$ 和 $B \\in \\mathbb{R}^{K \\times P}$ 是给定矩阵，$\\sin(\\cdot)$ 函数逐元素应用于向量 $B m \\in \\mathbb{R}^{K}$。\n\n给定一个观测数据向量 $d_{\\text{obs}} \\in \\mathbb{R}^{N}$，残差向量为 $r(m) = F(m) - d_{\\text{obs}}$。非线性最小二乘目标函数 $\\phi(m)$ 定义为残差的L2范数平方的一半：\n$$\n\\phi(m) = \\frac{1}{2} \\|r(m)\\|_2^2 = \\frac{1}{2} r(m)^\\top r(m)\n$$\n\n目标函数 $\\phi(m)$ 关于参数 $m$ 的梯度由下式给出：\n$$\n\\nabla_m \\phi(m) = J(m)^\\top r(m)\n$$\n其中 $J(m) \\in \\mathbb{R}^{N \\times P}$ 是正演算子 $F(m)$ 的雅可比矩阵，其元素为 $J_{ij} = \\frac{\\partial F_i}{\\partial m_j}$。对于高斯-牛顿法，这个梯度是一个关键组成部分。问题将这个解析推导的梯度表示为 $g_{\\text{adj}}(m)$。\n\n**伴随状态梯度推导 ($g_{\\text{adj}}$)**\n对于大规模问题，显式构造雅可比矩阵 $J(m)$ 在计算上是不可行的。伴随状态法提供了一种无需构造 $J(m)$ 即可高效计算梯度-向量积 $J(m)^\\top r(m)$ 的方法。我们通过应用链式法则来推导这个表达式。\n\n正演模型可以看作是三个操作的复合：\n1.  线性变换：$u(m) = B m$\n2.  逐点非线性函数：$v(u) = \\sin(u)$\n3.  线性变换：$F(v) = W v$\n\n这些中间步骤的雅可比矩阵是：\n-   $\\frac{\\partial u}{\\partial m} = B$\n-   $\\frac{\\partial v}{\\partial u} = \\text{diag}(\\cos(u)) = \\text{diag}(\\cos(Bm))$，一个 $K \\times K$ 的对角矩阵。\n-   $\\frac{\\partial F}{\\partial v} = W$\n\n根据链式法则，完整的雅可比矩阵 $J(m)$ 是这些中间雅可比矩阵的乘积：\n$$\nJ(m) = \\frac{\\partial F}{\\partial m} = \\frac{\\partial F}{\\partial v} \\frac{\\partial v}{\\partial u} \\frac{\\partial u}{\\partial m} = W \\, \\text{diag}(\\cos(Bm)) \\, B\n$$\n\n梯度 $g_{\\text{adj}}(m)$ 于是为：\n$$\ng_{\\text{adj}}(m) = J(m)^\\top r(m) = \\left( W \\, \\text{diag}(\\cos(Bm)) \\, B \\right)^\\top r(m)\n$$\n使用性质 $(ABC)^\\top = C^\\top B^\\top A^\\top$ 以及对角矩阵是对称的这一事实，我们得到：\n$$\ng_{\\text{adj}}(m) = B^\\top \\text{diag}(\\cos(Bm)) W^\\top r(m)\n$$\n这个表达式可以从右到左高效地计算，只需要矩阵-向量乘积和逐元素乘积：\n1.  计算残差：$r(m) = W \\sin(Bm) - d_{\\text{obs}}$\n2.  计算伴随源：$s = W^\\top r(m)$，这是一个在 $\\mathbb{R}^K$ 中的向量。\n3.  应用非线性的雅可比矩阵：$z = \\cos(Bm) \\odot s$，其中 $\\odot$ 表示逐元素（哈达玛）积。这等价于乘以对角矩阵 $\\text{diag}(\\cos(Bm))$。\n4.  应用第一个线性算子的伴随：$g_{\\text{adj}}(m) = B^\\top z$。结果是在 $\\mathbb{R}^P$ 中的梯度向量。\n\n**有限差分梯度近似 ($g_{\\text{fd}}$)**\n为了验证解析推导及其实现，我们将其与梯度的数值近似进行比较。梯度的第 $i$ 个分量 $\\frac{\\partial \\phi}{\\partial m_i}$，使用二阶精确的中心有限差分公式来近似：\n$$\n[g_{\\text{fd}}(m)]_i = \\frac{\\phi(m + h_i e_i) - \\phi(m - h_i e_i)}{2 h_i}\n$$\n其中 $e_i$ 是第 $i$ 个标准基向量（一个在第 $i$ 个位置为 1，其余位置为 0 的向量）。对每个分量 $i = 1, \\dots, P$ 执行此计算，以构造完整的梯度向量 $g_{\\text{fd}}(m)$。步长 $h_i$ 是自适应选择的，以平衡截断误差和舍入误差，具体规定如下：\n$$\nh_i = 10^{-6} \\max(1, |m_i|)\n$$\n\n**通过余弦相似度进行验证**\n伴随梯度 $g_{\\text{adj}}(m)$ 和有限差分梯度 $g_{\\text{fd}}(m)$ 之间的一致性通过它们之间夹角 $\\theta$ 的余弦值来量化。这是一个称为“梯度检查”的标准流程。\n$$\n\\cos \\theta(m) = \\frac{g_{\\text{adj}}(m) \\cdot g_{\\text{fd}}(m)}{\\|g_{\\text{adj}}(m)\\|_2 \\, \\|g_{\\text{fd}}(m)\\|_2}\n$$\n$\\cos \\theta(m)$ 的值接近 1.0 表明两个向量指向同一方向，从而验证了伴随方法的实现。\n\n为了数值稳定性，当一个或两个梯度向量的范数接近于零时，需要进行特殊处理。我们使用一个阈值 $\\tau = 10^{-12}$：\n-   如果 $\\|g_{\\text{adj}}(m)\\|_2  \\tau$ 且 $\\|g_{\\text{fd}}(m)\\|_2  \\tau$，我们定义 $\\cos \\theta(m) = 1.0$。这处理了真实梯度为零且两种方法都正确计算出近零向量的情况。\n-   如果两个范数中只有一个小于 $\\tau$，我们定义 $\\cos \\theta(m) = 0.0$。这表示存在差异，因为一种方法计算出零梯度而另一种没有。\n-   否则，使用标准公式。\n\n实现将通过为正演模型、目标函数、伴随梯度和有限差分梯度创建函数来进行。这些函数将被应用于五个指定的测试用例，以计算相应的 $\\cos \\theta$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute cosine similarities.\n    \"\"\"\n\n    def forward_model(W, B, m):\n        \"\"\"Computes F(m) = W * sin(B * m).\"\"\"\n        return W @ np.sin(B @ m)\n\n    def objective_function(W, B, m, d_obs):\n        \"\"\"Computes phi(m) = 0.5 * ||F(m) - d_obs||^2.\"\"\"\n        residual = forward_model(W, B, m) - d_obs\n        return 0.5 * np.linalg.norm(residual)**2\n\n    def compute_adjoint_gradient(W, B, m, d_obs):\n        \"\"\"Computes the gradient via the adjoint-state method.\"\"\"\n        # Step 1: Compute residual\n        residual = forward_model(W, B, m) - d_obs\n        \n        # Step 2: Compute adjoint source\n        adjoint_source = W.T @ residual\n        \n        # Step 3: Apply Jacobian of nonlinearity\n        u = B @ m\n        z = np.cos(u) * adjoint_source\n        \n        # Step 4: Apply adjoint of the first linear operator\n        g_adj = B.T @ z\n        return g_adj\n\n    def compute_fd_gradient(W, B, m, d_obs):\n        \"\"\"Computes the gradient via central finite differences.\"\"\"\n        P = len(m)\n        g_fd = np.zeros(P, dtype=np.float64)\n        \n        for i in range(P):\n            h_i = 1e-6 * max(1.0, abs(m[i]))\n            \n            m_plus = m.copy()\n            m_plus[i] += h_i\n            \n            m_minus = m.copy()\n            m_minus[i] -= h_i\n            \n            phi_plus = objective_function(W, B, m_plus, d_obs)\n            phi_minus = objective_function(W, B, m_minus, d_obs)\n            \n            g_fd[i] = (phi_plus - phi_minus) / (2 * h_i)\n            \n        return g_fd\n\n    def compute_cosine_similarity(g_adj, g_fd):\n        \"\"\"Computes the cosine of the angle between two vectors with robust handling.\"\"\"\n        norm_adj = np.linalg.norm(g_adj)\n        norm_fd = np.linalg.norm(g_fd)\n        threshold = 1e-12\n\n        if norm_adj  threshold and norm_fd  threshold:\n            return 1.0\n        elif norm_adj  threshold or norm_fd  threshold:\n            return 0.0\n        else:\n            dot_product = np.dot(g_adj, g_fd)\n            return dot_product / (norm_adj * norm_fd)\n\n    # --- Test Case Generation ---\n    results = []\n\n    # Test Case 1\n    N, K, P = 8, 10, 5\n    rng_W = np.random.default_rng(123)\n    W1 = rng_W.standard_normal((N, K))\n    rng_B = np.random.default_rng(456)\n    B1 = rng_B.standard_normal((K, P))\n    rng_m_true = np.random.default_rng(789)\n    m_true1 = rng_m_true.standard_normal(P)\n    rng_noise = np.random.default_rng(321)\n    eta1 = 1e-3 * rng_noise.standard_normal(N)\n    d_obs1 = forward_model(W1, B1, m_true1) + eta1\n    m0_1 = m_true1\n\n    g_adj1 = compute_adjoint_gradient(W1, B1, m0_1, d_obs1)\n    g_fd1 = compute_fd_gradient(W1, B1, m0_1, d_obs1)\n    results.append(compute_cosine_similarity(g_adj1, g_fd1))\n\n    # Test Case 2\n    rng_delta = np.random.default_rng(654)\n    delta = 1e-1 * rng_delta.standard_normal(P)\n    m0_2 = m_true1 + delta\n\n    g_adj2 = compute_adjoint_gradient(W1, B1, m0_2, d_obs1)\n    g_fd2 = compute_fd_gradient(W1, B1, m0_2, d_obs1)\n    results.append(compute_cosine_similarity(g_adj2, g_fd2))\n    \n    # Test Case 3\n    N, K, P = 4, 3, 1\n    rng_W = np.random.default_rng(5)\n    W3 = rng_W.standard_normal((N, K))\n    rng_B = np.random.default_rng(6)\n    B3 = rng_B.standard_normal((K, P))\n    m_true3 = np.array([0.7])\n    rng_noise = np.random.default_rng(11)\n    eta3 = 1e-4 * rng_noise.standard_normal(N)\n    d_obs3 = forward_model(W3, B3, m_true3) + eta3\n    m0_3 = m_true3\n\n    g_adj3 = compute_adjoint_gradient(W3, B3, m0_3, d_obs3)\n    g_fd3 = compute_fd_gradient(W3, B3, m0_3, d_obs3)\n    results.append(compute_cosine_similarity(g_adj3, g_fd3))\n\n    # Test Case 4\n    N, K, P = 6, 7, 3\n    rng_W = np.random.default_rng(7)\n    W4 = rng_W.standard_normal((N, K))\n    rng_B = np.random.default_rng(8)\n    B4 = rng_B.standard_normal((K, P))\n    rng_m0 = np.random.default_rng(12)\n    m0_4 = rng_m0.standard_normal(P)\n    d_obs4 = forward_model(W4, B4, m0_4)\n\n    g_adj4 = compute_adjoint_gradient(W4, B4, m0_4, d_obs4)\n    g_fd4 = compute_fd_gradient(W4, B4, m0_4, d_obs4)\n    results.append(compute_cosine_similarity(g_adj4, g_fd4))\n\n    # Test Case 5\n    N, K, P = 5, 5, 5\n    rng_W = np.random.default_rng(9)\n    W5 = rng_W.standard_normal((N, K))\n    rng_B = np.random.default_rng(10)\n    B5 = rng_B.standard_normal((K, P))\n    v = (np.pi / 2) * np.ones(K)\n    m0_5 = np.linalg.lstsq(B5, v, rcond=None)[0]\n    d_obs5 = np.zeros(N)\n\n    g_adj5 = compute_adjoint_gradient(W5, B5, m0_5, d_obs5)\n    g_fd5 = compute_fd_gradient(W5, B5, m0_5, d_obs5)\n    results.append(compute_cosine_similarity(g_adj5, g_fd5))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}