{
    "hands_on_practices": [
        {
            "introduction": "线性反演问题的核心在于求解方程组 $d = G m$。本实践练习旨在通过普通最小二乘法 (Ordinary Least Squares, OLS) 为您提供解决此类问题的基础编码经验。您将处理在地球物理学中常见的各种情况，包括超定、欠定、秩亏和病态系统，并学习如何使用稳健的数值方法来计算模型解、残差范数和模型范数 。",
            "id": "3608201",
            "problem": "考虑一个计算地球物理学中的线性反演问题，其中观测数据向量 $d \\in \\mathbb{R}^{m}$ 通过一个线性正演算子（设计矩阵）$G \\in \\mathbb{R}^{m \\times n}$ 与模型参数向量 $m \\in \\mathbb{R}^{n}$ 相关联。其基本原理是线性数据关系 $d = G m + \\varepsilon$ 以及寻求一个模型 $m^{\\star}$ 以最小化残差范数平方 $\\lVert G m - d \\rVert_{2}^{2}$ 的普通最小二乘准则。由于归一化，所有量均为无量纲，因此不涉及物理单位。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 对每个指定的测试用例 $(G_i, d_i)$，计算普通最小二乘解 $m_i^{\\star}$。\n- 量化残差范数 $\\lVert G_i m_i^{\\star} - d_i \\rVert_{2}$ 和模型范数 $\\lVert m_i^{\\star} \\rVert_{2}$。\n- 按照下面指定的精确格式生成最终输出。\n\n程序必须对 $G$ 可能是超定、欠定、秩亏或病态的情况具有鲁棒性，并计算出在欧几里得意义下最小化残差范数的解。\n\n测试套件：\n1. 超定、满列秩情况：\n   $$ G_1 = \\begin{bmatrix} 1  0.5 \\\\ 0  1 \\\\ 1  -1 \\end{bmatrix}, \\quad d_1 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 0 \\end{bmatrix}. $$\n2. 超定、秩亏情况（第三列等于前两列之和）：\n   $$ G_2 = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\\\ 1  1  2 \\end{bmatrix}, \\quad d_2 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}. $$\n3. 欠定情况：\n   $$ G_3 = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\end{bmatrix}, \\quad d_3 = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}. $$\n4. 病态情况（列向量近似共线）：\n   $$ G_4 = \\begin{bmatrix} 1  1 \\\\ 1  1 + 10^{-8} \\\\ 1  -10^{-8} \\end{bmatrix}, \\quad d_4 = \\begin{bmatrix} 2 \\\\ 2 + 10^{-8} \\\\ 10^{-8} \\end{bmatrix}. $$\n\n对于每个测试用例 $i \\in \\{1,2,3,4\\}$，您的程序必须按此精确顺序输出列表\n$$ [m_{i,1}^{\\star}, m_{i,2}^{\\star}, \\ldots, m_{i,n}^{\\star}, \\lVert G_i m_i^{\\star} - d_i \\rVert_{2}, \\lVert m_i^{\\star} \\rVert_{2}], $$\n将这四个列表聚合为单行输出，形式为用方括号括起来的逗号分隔列表。您的程序应生成单行输出，其中包含用方括号括起来且无空格的逗号分隔结果，例如：\n$$ [[\\cdots],[\\cdots],[\\cdots],[\\cdots]]. $$\n\n不允许外部输入；所有数据必须在程序中硬编码。最终输出为实数（浮点数）。",
            "solution": "用户提供了一个计算地球物理学问题，要求解决一系列形式为 $d = Gm$ 的线性反演问题。目标是找到模型参数向量 $m^{\\star}$，以最小化残差的欧几里得范数 $\\lVert G m - d \\rVert_{2}$。该问题需要针对代表超定、秩亏、欠定和病态系统的四种不同情况进行求解。\n\n### 步骤1：提取给定条件\n\n基本关系由以下线性系统给出：\n$d = G m + \\varepsilon$，其中 $d \\in \\mathbb{R}^{m}$ 是数据向量，$m \\in \\mathbb{R}^{n}$ 是模型参数向量，$G \\in \\mathbb{R}^{m \\times n}$ 是正演算子（设计矩阵），$\\varepsilon$ 表示噪声或误差。\n\n目标是找到 $m^{\\star}$，以解决普通最小二乘（OLS）问题：\n$$ m^{\\star} = \\arg\\min_{m \\in \\mathbb{R}^n} \\lVert G m - d \\rVert_{2}^{2} $$\n\n测试套件提供了四个具体实例 $(G_i, d_i)$：\n\n1.  **情况1（超定、满列秩）：**\n    $$ G_1 = \\begin{bmatrix} 1  0.5 \\\\ 0  1 \\\\ 1  -1 \\end{bmatrix}, \\quad d_1 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 0 \\end{bmatrix} $$\n\n2.  **情况2（超定、秩亏）：**\n    $$ G_2 = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\\\ 1  1  2 \\end{bmatrix}, \\quad d_2 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} $$\n\n3.  **情况3（欠定）：**\n    $$ G_3 = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\end{bmatrix}, \\quad d_3 = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} $$\n\n4.  **情况4（病态）：**\n    $$ G_4 = \\begin{bmatrix} 1  1 \\\\ 1  1 + 10^{-8} \\\\ 1  -10^{-8} \\end{bmatrix}, \\quad d_4 = \\begin{bmatrix} 2 \\\\ 2 + 10^{-8} \\\\ 10^{-8} \\end{bmatrix} $$\n\n对于每种情况，所需的输出是解向量 $m_i^{\\star}$ 的分量、残差范数 $\\lVert G_i m_i^{\\star} - d_i \\rVert_{2}$ 以及模型范数 $\\lVert m_i^{\\star} \\rVert_{2}$。\n\n### 步骤2：使用提取的给定条件进行验证\n\n-   **科学依据：**该问题是一个经典的线性最小二乘问题，是线性代数、数值分析、统计学以及包括计算地球物理学在内的众多STEM领域中的一个基本概念。它没有任何科学或事实上的不健全之处。\n-   **良态性：**问题要求的是“那个”普通最小二乘解。对于解不唯一的情况（欠定或秩亏系统），存在一个唯一的解，它不仅最小化残差范数，而且在所有可能的解中具有最小的欧几里得范数 $\\lVert m^{\\star} \\rVert_{2}$。这就是标准的最小范数最小二乘解。根据这个标准解释，该问题对于所有给定情况都是良态的。\n-   **客观性：**问题使用了精确的数学定义和客观的数值数据进行陈述。没有主观或含糊不清的语言。\n\n该问题是自包含的，所有必要数据均已提供。不同的情况经过精心选择，以测试求解方法的鲁棒性。在归一化系统内，数值是物理上合理的。\n\n### 步骤3：结论与行动\n\n问题有效。将开发一个解决方案。\n\n### 基于原理的解决方案设计\n\n问题的核心是找到一个向量 $m^{\\star}$，以最小化目标函数 $J(m) = \\lVert G m - d \\rVert_{2}^{2}$。该二次函数的最小值在其关于 $m$ 的梯度为零处找到。\n$$ \\nabla_m J(m) = \\nabla_m \\left( (G m - d)^T (G m - d) \\right) = \\nabla_m \\left( m^T G^T G m - 2d^T G m + d^T d \\right) = 2 G^T G m - 2 G^T d $$\n将梯度设为零，得出**正规方程组**：\n$$ (G^T G) m = G^T d $$\n\n如果矩阵 $G^T G \\in \\mathbb{R}^{n \\times n}$ 是可逆的（当且仅当 $G$ 具有满列秩，即列向量线性无关时成立），则存在唯一解：\n$$ m^{\\star} = (G^T G)^{-1} G^T d $$\n这适用于超定、满秩的情况（情况1）。然而，这种方法对于其他情况存在问题：\n-   如果 $G$ 是秩亏或欠定的（情况2和3），$G^T G$ 是奇异的，其逆矩阵不存在。\n-   如果 $G$ 是病态的（情况4），$G^T G$ 会更加病态，因为其条件数是 $G$ 的条件数的平方，即 $\\kappa(G^T G) = (\\kappa(G))^2$。直接求解正规方程组可能导致巨大的数值误差。\n\n需要一种更通用且数值上更鲁棒的方法，能够统一处理所有情况。**奇异值分解（SVD）**提供了这样一种方法。任何矩阵 $G \\in \\mathbb{R}^{m \\times n}$ 都可以分解为：\n$$ G = U \\Sigma V^T $$\n其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵（$U^T U = I_m$, $V^T V = I_n$），$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个矩形对角矩阵，包含非负奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_r > 0$，其中 $r = \\text{rank}(G)$。\n\n使用SVD，可以定义 $G$ 的**Moore-Penrose伪逆**：\n$$ G^{\\dagger} = V \\Sigma^{\\dagger} U^T $$\n其中 $\\Sigma^{\\dagger} \\in \\mathbb{R}^{n \\times m}$ 是通过对 $\\Sigma^T$ 对角线上的非零奇异值取倒数得到的。\n\n对于任何线性系统 $Gm=d$，唯一的最小范数最小二乘解由下式给出：\n$$ m^{\\star} = G^{\\dagger} d $$\n这个解 $m^{\\star}$ 的特性是它能最小化 $\\lVert G m - d \\rVert_{2}$，并且在所有达到此最小值的向量中，$m^{\\star}$ 是欧几里得范数 $\\lVert m \\rVert_{2}$ 最小的一个。该方法能正确且鲁棒地处理所有四个提供的测试用例。\n\n实现将利用一个高质量的数值库函数 `scipy.linalg.lstsq`，该函数基于 SVD 或类似的鲁棒分解，为每种情况计算 $m^{\\star}$。随后，将直接计算残差范数 $\\lVert G m^{\\star} - d \\rVert_{2}$ 和模型范数 $\\lVert m^{\\star} \\rVert_{2}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves a set of linear inverse problems using ordinary least squares,\n    calculates model and residual norms, and formats the output.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    G1 = np.array([\n        [1.0, 0.5],\n        [0.0, 1.0],\n        [1.0, -1.0]\n    ])\n    d1 = np.array([1.0, 2.0, 0.0])\n\n    G2 = np.array([\n        [1.0, 0.0, 1.0],\n        [0.0, 1.0, 1.0],\n        [1.0, 1.0, 2.0]\n    ])\n    d2 = np.array([1.0, 2.0, 3.0])\n\n    G3 = np.array([\n        [1.0, 0.0, 1.0],\n        [0.0, 1.0, 1.0]\n    ])\n    d3 = np.array([1.0, 1.0])\n\n    h = 1e-8\n    G4 = np.array([\n        [1.0, 1.0],\n        [1.0, 1.0 + h],\n        [1.0, -h]\n    ])\n    d4 = np.array([2.0, 2.0 + h, h])\n\n    test_cases = [\n        (G1, d1),\n        (G2, d2),\n        (G3, d3),\n        (G4, d4)\n    ]\n\n    all_results = []\n    # Set a high precision for numpy printing for consistency.\n    # Note: This only affects the string conversion, not the calculations.\n    np.set_printoptions(precision=15, suppress=True)\n\n    for G, d in test_cases:\n        # Use scipy.linalg.lstsq to find the minimum-norm least-squares solution.\n        # This method is robust for all cases (over/underdetermined, rank-deficient).\n        # cond=None uses machine epsilon for cutoff, as recommended.\n        m_star = linalg.lstsq(G, d, cond=None)[0]\n\n        # Calculate the residual vector and its L2-norm.\n        residual_vector = G @ m_star - d\n        residual_norm = np.linalg.norm(residual_vector)\n\n        # Calculate the L2-norm of the model vector.\n        model_norm = np.linalg.norm(m_star)\n\n        # Combine results into a single list for this case.\n        case_result = list(m_star) + [residual_norm, model_norm]\n        all_results.append(case_result)\n\n    # Format the final output as a string representation of a list of lists.\n    # The str() function on a list automatically creates the bracketed format.\n    output_str = \"[\" + \",\".join(map(str, all_results)) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "仅仅找到一个解往往是不够的；理解解的唯一性和模糊性至关重要。本练习将引导您超越求解本身，深入探究算子 $G$ 的结构，重点关注其零空间 $\\mathcal{N}(G)$ 和行空间 $\\mathcal{R}(G^T)$。通过使用奇异值分解 (Singular Value Decomposition, SVD)，您将学会如何精确地识别模型中哪些部分可以被数据约束，哪些部分是模糊的，这是严谨解释反演结果的关键一步 。",
            "id": "3608192",
            "problem": "考虑计算地球物理中的线性正演模型，其中数据向量 $d \\in \\mathbb{R}^m$ 通过线性算子 $G \\in \\mathbb{R}^{m \\times n}$ 与模型向量 $m \\in \\mathbb{R}^n$ 相关联，其关系为 $d = G m$。在线性反问题的分析中，理解零空间 $\\mathcal{N}(G)$ 和转置的像空间 $\\mathcal{R}(G^T)$ 的结构对于量化模型非唯一性和数据可分辨方向至关重要。您的任务是使用奇异值分解 (SVD) 计算 $\\mathcal{N}(G)$ 和 $\\mathcal{R}(G^T)$ 的标准正交基，并对几个测试用例验证秩-零度定理 $n = \\mathrm{rank}(G) + \\dim \\mathcal{N}(G)$。仅使用定义和基本结果：$\\mathcal{N}(G) = \\{ x \\in \\mathbb{R}^n : G x = 0 \\}$，$\\mathcal{R}(G^T)$ 是 $G^T$ 的列空间（等价于 $G$ 的行空间），SVD 将 $G$ 分解为 $G = U \\Sigma V^T$，其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是对角矩阵（可能为矩形），其对角线上的元素为非负奇异值。\n\n将数值秩 $\\mathrm{rank}(G)$ 定义为严格大于阈值 $t$ 的奇异值的数量，其中阈值 $t$ 选择为 $t = \\max(m, n) \\, \\epsilon \\, \\sigma_{\\max}$，$\\epsilon$ 是双精度浮点数的机器精度，$\\sigma_{\\max}$ 是 $G$ 的最大奇异值。使用此秩，从与小于或等于 $t$ 的奇异值相关联的右奇异向量构造 $\\mathcal{N}(G)$ 的标准正交基，并从与大于 $t$ 的奇异值相关联的右奇异向量构造 $\\mathcal{R}(G^T)$ 的标准正交基。然后验证秩-零度定理，并通过计算这两个子空间基向量之间内积矩阵的最大绝对值项来数值检验 $\\mathcal{N}(G)$ 和 $\\mathcal{R}(G^T)$ 之间的正交性。\n\n使用以下矩阵 $G$ 的测试套件，每个矩阵都为探测计算的某个特定方面而指定：\n\n- 情况 1（秩亏矩形矩阵，通过乘积构造以强制降低秩）：令\n$$\nA_1 = \\begin{bmatrix}\n1  0  2  -1 \\\\\n0  1  1  2 \\\\\n1  1  0  0 \\\\\n2  -1  1  1 \\\\\n0  0  1  -1\n\\end{bmatrix} \\in \\mathbb{R}^{5 \\times 4}, \\quad\nB_1 = \\begin{bmatrix}\n1  2  0  -1  0  3  1 \\\\\n0  1  1  0  2  0  -2 \\\\\n2  0  -1  1  1  1  0 \\\\\n-1  1  2  0  -1  0  1\n\\end{bmatrix} \\in \\mathbb{R}^{4 \\times 7},\n$$\n并定义 $G_1 = A_1 B_1 \\in \\mathbb{R}^{5 \\times 7}$。\n\n- 情况 2（方阵，满秩，良态，对角矩阵）：令\n$$\nG_2 = \\mathrm{diag}(3, 2, 1, 4, 5, 6) \\in \\mathbb{R}^{6 \\times 6}.\n$$\n\n- 情况 3（具有非平凡零空间的宽矩阵，通过乘积构造以强制秩最多为 2）：令\n$$\nA_2 = \\begin{bmatrix}\n1  2 \\\\\n-1  0 \\\\\n0  1\n\\end{bmatrix} \\in \\mathbb{R}^{3 \\times 2}, \\quad\nB_2 = \\begin{bmatrix}\n2  -1  0  1  3 \\\\\n1  0  2  -2  -1\n\\end{bmatrix} \\in \\mathbb{R}^{2 \\times 5},\n$$\n并定义 $G_3 = A_2 B_2 \\in \\mathbb{R}^{3 \\times 5}$。\n\n- 情况 4（方阵，病态，具有临界奇异值，对角矩阵）：令\n$$\nG_4 = \\mathrm{diag}(1, 10^{-8}, 10^{-17}, 0) \\in \\mathbb{R}^{4 \\times 4}.\n$$\n\n对于每种情况，计算：\n- 使用上述定义的阈值 $t$ 计算的整数 $\\mathrm{rank}(G)$。\n- 整数 $\\dim \\mathcal{N}(G)$，即为零空间基选择的右奇异向量的数量。\n- 整数 $n$（$G$ 的列数）。\n- 一个布尔值，指示 $n = \\mathrm{rank}(G) + \\dim \\mathcal{N}(G)$ 是否成立。\n- 一个浮点数，等于零空间基的列与 $\\mathcal{R}(G^T)$ 基的列之间内积矩阵的最大绝对值项（这量化了数值正交性；值越低表示正交性越好）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每一项对应一个测试用例的结果。每一项本身也是一个列表，顺序为 $[\\mathrm{rank}(G), \\dim \\mathcal{N}(G), n, \\text{valid}, \\text{orth}]$，例如 $[[r_1,k_1,n_1,\\text{valid}_1,\\text{orth}_1],[r_2,k_2,n_2,\\text{valid}_2,\\text{orth}_2],\\dots]$。此问题不涉及物理单位；所有计算都是无量纲的。",
            "solution": "该问题要求利用给定矩阵 $G$ 的奇异值分解 (SVD) 来计算其零空间 $\\mathcal{N}(G)$ 和行空间 $\\mathcal{R}(G^T)$ 的标准正交基。此外，我们必须验证秩-零度定理，并对几个测试用例评估所计算基的数值正交性。\n\n数据向量 $d \\in \\mathbb{R}^m$ 和模型向量 $m \\in \\mathbb{R}^n$ 之间的关系由线性正演模型 $d = G m$ 给出，其中 $G \\in \\mathbb{R}^{m \\times n}$ 是正演算子。对该系统性质的分析依赖于对与 $G$ 相关的四个基本子空间的理解。本问题重点关注模型空间 $\\mathbb{R}^n$ 的两个子空间：零空间 $\\mathcal{N}(G)$ 和行空间，后者等价于转置的像空间 $\\mathcal{R}(G^T)$。\n\n零空间定义为 $\\mathcal{N}(G) = \\{ x \\in \\mathbb{R}^n : G x = 0 \\}$。它代表了模型空间中对数据不可见的部分，导致了反问题中的非唯一性。\n转置的像空间 $\\mathcal{R}(G^T)$ 是由 $G^T$ 的列（或 $G$ 的行）张成的 $\\mathbb{R}^n$ 的子空间。它代表了可被数据约束的模型空间部分。线性代数的一个基本结果是，这两个子空间在 $\\mathbb{R}^n$ 中是正交补，这意味着 $\\mathbb{R}^n$ 中的任何向量都可以唯一地分解为一个在 $\\mathcal{R}(G^T)$ 中的分量和一个在 $\\mathcal{N}(G)$ 中的分量，并且任何来自 $\\mathcal{R}(G^T)$ 的向量与任何来自 $\\mathcal{N}(G)$ 的向量的内积为零。这意味着 $\\mathbb{R}^n = \\mathcal{R}(G^T) \\oplus \\mathcal{N}(G)$。秩-零度定理是一个直接的推论，它指出这些子空间的维数之和等于总空间的维数：$\\dim(\\mathcal{R}(G^T)) + \\dim(\\mathcal{N}(G)) = n$。由于 $\\mathrm{rank}(G) = \\dim(\\mathcal{R}(G^T))$，该定理通常写为 $\\mathrm{rank}(G) + \\dim(\\mathcal{N}(G)) = n$。\n\n奇异值分解 (SVD) 为计算这些子空间的稳定标准正交基提供了一个强大的工具。$G$ 的 SVD 是分解 $G = U \\Sigma V^T$，其中：\n- $U \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵，其列 $u_i$ 是左奇异向量。\n- $V \\in \\mathbb{R}^{n \\times n}$ 是一个正交矩阵，其列 $v_i$ 是右奇异向量。\n- $\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个矩形对角矩阵，其对角线上有非负实数 $\\sigma_i$，称为奇异值，按非递增顺序排列：$\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge 0$。\n\n令 $G$ 的秩为 $r$。这意味着有 $r$ 个非零奇异值。SVD 揭示了基本子空间的基，如下所示：\n- $V$ 的前 $r$ 列 $\\{v_1, \\dots, v_r\\}$ 构成了 $G$ 的行空间 $\\mathcal{R}(G^T)$ 的一个标准正交基。\n- $V$ 的剩余 $n-r$ 列 $\\{v_{r+1}, \\dots, v_n\\}$ 构成了 $G$ 的零空间 $\\mathcal{N}(G)$ 的一个标准正交基。这是因为对于 $i > r$，有 $\\sigma_i = 0$，这意味着 $G v_i = U \\Sigma V^T v_i = U \\Sigma e_i = \\sigma_i u_i = 0$。\n\n在数值计算中，由于浮点误差，本应为零的奇异值可能会表现为非常小的非零数。因此，必须使用阈值来定义数值秩。问题指定了阈值 $t = \\max(m, n) \\, \\epsilon \\, \\sigma_{\\max}$，其中 $\\epsilon$ 是双精度浮点数的机器精度，$\\sigma_{\\max}$ 是 $G$ 的最大奇异值。数值秩（我们同样用 $r$ 表示）是严格大于 $t$ 的奇异值 $\\sigma_i$ 的数量。\n\n每个测试用例的步骤如下：\n1.  给定矩阵 $G \\in \\mathbb{R}^{m \\times n}$，计算其 SVD 以获得奇异值 $s$ 和右奇异向量矩阵 $V$。\n2.  确定最大奇异值 $\\sigma_{\\max} = s_1$。\n3.  计算阈值 $t = \\max(m, n) \\cdot \\epsilon \\cdot \\sigma_{\\max}$。\n4.  计算数值秩 $r$，即奇异值 $s_i > t$ 的数量。\n5.  $\\mathcal{R}(G^T)$ 的基由 $V$ 的前 $r$ 列组成。\n6.  $\\mathcal{N}(G)$ 的基由 $V$ 的后 $n-r$ 列组成。因此，零空间的维数为 $\\dim \\mathcal{N}(G) = n-r$。\n7.  通过检查等式 $n = r + (n-r)$ 是否成立来验证秩-零度定理。根据我们的构造方法，此检查结果将始终为 `True`。\n8.  数值上验证 $\\mathcal{R}(G^T)$ 和 $\\mathcal{N}(G)$ 之间的正交性。这通过构建两个子空间基向量之间的内积矩阵来完成。令 $V_{\\mathcal{R}}$ 是以 $\\mathcal{R}(G^T)$ 的基为列的矩阵， $V_{\\mathcal{N}}$ 是以 $\\mathcal{N}(G)$ 的基为列的矩阵。内积矩阵为 $C = V_{\\mathcal{R}}^T V_{\\mathcal{N}}$。因为 $V$ 的列是标准正交的，所以理论上 $C$ 的所有元素都应为零。我们计算 $C$ 中元素的最大绝对值 $\\max(|C_{ij}|)$，作为数值正交性的度量。接近零的值表示数值正交性高。如果其中一个子空间是平凡的（即其维数为 0），则正交性不言自明地成立，最大内积定义为 0。\n\n将此过程应用于所提供的四个测试矩阵中的每一个，并汇编结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes properties of fundamental subspaces for a suite of test matrices.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    A1 = np.array([\n        [1, 0, 2, -1],\n        [0, 1, 1, 2],\n        [1, 1, 0, 0],\n        [2, -1, 1, 1],\n        [0, 0, 1, -1]\n    ], dtype=float)\n\n    B1 = np.array([\n        [1, 2, 0, -1, 0, 3, 1],\n        [0, 1, 1, 0, 2, 0, -2],\n        [2, 0, -1, 1, 1, 1, 0],\n        [-1, 1, 2, 0, -1, 0, 1]\n    ], dtype=float)\n    G1 = A1 @ B1\n\n    G2 = np.diag([3.0, 2.0, 1.0, 4.0, 5.0, 6.0])\n\n    A2 = np.array([\n        [1, 2],\n        [-1, 0],\n        [0, 1]\n    ], dtype=float)\n\n    B2 = np.array([\n        [2, -1, 0, 1, 3],\n        [1, 0, 2, -2, -1]\n    ], dtype=float)\n    G3 = A2 @ B2\n\n    G4 = np.diag([1.0, 1e-8, 1e-17, 0.0])\n\n    test_cases = [G1, G2, G3, G4]\n    \n    results = []\n    \n    for G in test_cases:\n        m, n = G.shape\n\n        if n == 0:\n            # Handle matrices with no columns, null space dim is 0, rank is 0.\n            results.append([0, 0, 0, True, 0.0])\n            continue\n        \n        # Compute SVD\n        try:\n            U, s, Vh = np.linalg.svd(G)\n        except np.linalg.LinAlgError:\n            # Handle potential SVD failures, although unlikely for these cases\n            # This path is not expected to be taken with the given inputs.\n            continue\n\n        # Get matrix of right singular vectors\n        V = Vh.T\n\n        # Machine epsilon for the data type of G\n        eps = np.finfo(G.dtype).eps\n        \n        # Determine the numerical rank\n        sigma_max = s[0] if s.size > 0 else 0\n        \n        # If the matrix is the zero matrix, rank is 0. Threshold would be 0.\n        if sigma_max == 0:\n            rank = 0\n        else:\n            threshold = max(m, n) * eps * sigma_max\n            rank = np.sum(s > threshold)\n            \n        dim_null_space = n - rank\n        \n        # Verify Rank-Nullity Theorem: n = rank(G) + dim(N(G))\n        # By construction, this will always be true.\n        rank_nullity_valid = (n == rank + dim_null_space)\n        \n        # Check orthogonality of subspaces\n        # Basis for R(G^T) are the first 'rank' columns of V\n        # Basis for N(G) are the last 'n - rank' columns of V\n        if rank == 0 or rank == n:\n            # If one subspace is trivial, orthogonality holds vacuously.\n            orthogonality_check = 0.0\n        else:\n            V_range = V[:, :rank]\n            V_null = V[:, rank:]\n            inner_products = V_range.T @ V_null\n            orthogonality_check = np.max(np.abs(inner_products))\n        \n        results.append([rank, dim_null_space, n, rank_nullity_valid, orthogonality_check])\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list of lists matches the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "现在，我们将所有概念整合到一个更实际的地球物理层析成像问题中，这类问题通常是病态的。本综合练习将指导您完成一个端到端的“棋盘格测试”工作流，这是评估层析成像实验分辨率的标准方法。您将亲手构建一个正向模型，引入正则化（特别是吉洪诺夫正则化）来从无限多的可能解中挑选出稳定且物理上合理的解，并最终量化评估您反演结果的质量 。",
            "id": "3608136",
            "problem": "您的任务是为代表计算地球物理学中走时层析成像的二维（$2$-D）线性反演问题，构建并评估一个经典的棋盘格分辨率测试。正演模型是线性的，数据是沿直线的线积分，反演问题使用零阶和二阶 Tikhonov 正则化求解。您的目标是实现一个完整的程序，该程序针对几组参数集，建立模型，通过正演算子模拟数据，针对指定的正则化强度求解反演问题，并将恢复的模型与真实的棋盘格进行定量比较，以评估分辨率。\n\n从以下基本基础开始：数据 $d$、正演算子 $G$、模型 $m$ 和噪声 $\\epsilon$ 之间的线性正演关系 $d = G m + \\epsilon$；以及最小二乘原理，该原理通过最小化二次失配来选择 $m$。您必须使用 Tikhonov 正则化，它通过一个形如 $\\lambda^{2} \\lVert L m \\rVert_{2}^{2}$ 的稳定项来扩充失配项，其中 $\\lambda \\ge 0$ 是一个标量权衡参数， $L$ 是一个编码先验期望的离散算子（对于二阶平滑度，请使用网格上的$5$点离散拉普拉斯算子）。不要为解假设任何特定的公式；相反，应系统地构建离散算子，并通过将二次目标函数的导数置零来推导出待解的线性系统。\n\n详细要求：\n\n- 模型网格和棋盘格：\n  - 使用具有 $n_{x} \\times n_{y}$ 个单元格的矩形网格，以行主序索引到一个向量 $m \\in \\mathbb{R}^{n_{x} n_{y}}$ 中。\n  - 构建一个振幅为 $1$、方形区块边长为 $s$ 个单元格的零均值棋盘格模型 $m_{\\mathrm{true}}$。即，$+1$ 和 $-1$ 的交替块，块大小为 $s \\times s$。在计算比较指标时，确保模型是均值中心化的。\n- 正演算子 $G$（射线路径和）：\n  - 模拟与跨越选定行和列的线积分相对应的、轴对齐的直线射线。每条水平射线对应于对整行的模型值求和；每条垂直射线对整列的模型值求和。使用一个步长参数 $q \\in \\mathbb{N}$，从第一行和第一列开始，包含每第 $q$ 行和每第 $q$ 列。对于位于行索引 $i$ 的水平射线，$G$ 的对应行中，对于行 $i$ 中的所有单元格 $j$，其条目应为 $G_{k,j} = 1$，其他地方为 $G_{k,j} = 0$。对于位于列索引 $j$ 的垂直射线，情况类似。\n  - 生成数据 $d = G m_{\\mathrm{true}} + \\epsilon$，其中 $\\epsilon$ 是标准差为 $\\sigma$ 的零均值高斯噪声。每个测试用例使用固定的随机种子以确保可复现性。\n- 反演问题：\n  - 求解 Tikhonov 正则化的最小二乘问题，该问题最小化目标函数 $\\Phi(m) = \\lVert G m - d \\rVert_{2}^{2} + \\lambda^{2} \\lVert L m \\rVert_{2}^{2}$，其中 $L$ 是 $n_{x} \\times n_{y}$ 网格上的$5$点离散拉普拉斯算子，采用自然边界处理（边界上的邻居较少）。对于 $\\lambda = 0$，求解非正则化的最小二乘问题。对于 $\\lambda > 0$，将梯度设为零并求解得到的对称正定线性系统。\n- 分辨率评估指标：\n  - 计算恢复模型 $m_{\\mathrm{est}}$ 和真实模型 $m_{\\mathrm{true}}$ 之间的中心化余弦相似度（相关性）：$r = \\dfrac{(m_{\\mathrm{est}} - \\overline{m}_{\\mathrm{est}})^{T} (m_{\\mathrm{true}} - \\overline{m}_{\\mathrm{true}})}{\\lVert m_{\\mathrm{est}} - \\overline{m}_{\\mathrm{est}} \\rVert_{2} \\, \\lVert m_{\\mathrm{true}} - \\overline{m}_{\\mathrm{true}} \\rVert_{2}}$，其中上划线表示均值。这将产生一个在 $[-1,1]$ 区间内的标量，指示模式恢复的质量。\n- 单位：在本练习中，所有量都是无量纲的；不需要物理单位。\n- 角度单位：不适用。\n- 数值输出：对于每个测试用例，输出标量相关性 $r$，作为四舍五入到三位小数的浮点数。\n\n测试套件（为以下每个参数集提供结果）：\n- 情况 $1$：$(n_{x}, n_{y}, s, \\lambda, \\sigma, q) = (16, 16, 4, 0.5, 0.0, 2)$。\n- 情况 $2$：$(n_{x}, n_{y}, s, \\lambda, \\sigma, q) = (16, 16, 4, 0.0, 0.0, 2)$。\n- 情况 $3$：$(n_{x}, n_{y}, s, \\lambda, \\sigma, q) = (16, 16, 4, 5.0, 0.0, 2)$。\n- 情况 $4$：$(n_{x}, n_{y}, s, \\lambda, \\sigma, q) = (16, 16, 2, 0.5, 0.0, 2)$。\n- 情况 $5$：$(n_{x}, n_{y}, s, \\lambda, \\sigma, q) = (16, 16, 4, 0.5, 0.05, 2)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[r_{1},r_{2},r_{3},r_{4},r_{5}]$），其中每个 $r_{i}$ 都四舍五入到三位小数。\n- 程序必须完全自包含，不接受任何输入，并且仅使用指定的 Python 运行时和库。",
            "solution": "该问题要求为使用 Tikhonov 正则化求解的二维（$2$-D）线性反演问题构建并评估一个棋盘格分辨率测试。这涉及几个阶段：定义模型空间和真实模型、构建正演算子、模拟数据、建立并求解正则化反演问题，以及量化模型恢复的质量。\n\n控制正演问题的基本关系是线性方程：\n$$d = G m + \\epsilon$$\n其中 $d \\in \\mathbb{R}^{N_d}$ 是数据向量，$m \\in \\mathbb{R}^{N_m}$ 是模型参数向量，$G \\in \\mathbb{R}^{N_d \\times N_m}$ 是正演算子，$\\epsilon \\in \\mathbb{R}^{N_d}$ 是一个随机噪声向量。\n\n首先，我们定义模型空间。模型由一个 $n_x \\times n_y$ 单元格的二维矩形网格组成。假设每个单元格内的物理属性是恒定的。这 $N_m = n_x n_y$ 个单元格的值使用行主序索引展开成一个单一向量 $m$。网格坐标 $(i, j)$ 处的单元格（其中 $i$ 是行索引，$0 \\le i  < n_y$，$j$ 是列索引，$0 \\le j < n_x$）对应于向量 $m$ 中的索引 $k = i \\cdot n_x + j$。\n\n真实模型 $m_{\\mathrm{true}}$ 是一个棋盘格图案。对于给定的区块边长 $s$，单元格 $(i, j)$ 的值由其区块坐标 $(\\lfloor i/s \\rfloor, \\lfloor j/s \\rfloor)$ 决定。其值设为 $(-1)^{p+q}$，其中 $p = \\lfloor i/s \\rfloor$ 且 $q = \\lfloor j/s \\rfloor$，从而产生 $+1$ 和 $-1$ 的交替块。对于指定的测试参数，此构造产生一个零均值模型。\n\n接下来，我们构建正演算子 $G$。数据采集被建模为轴对齐的直线射线路径层析成像。每个数据点对应于沿网格特定行或列的模型参数的线积分（和）。以步长 $q$ 对射线进行采样，这意味着对每第 $q$ 行和每第 $q$ 列进行观测，从第一行开始。穿过行 $i$ 的水平射线对应于 $G$ 中的一行，其中对于该网格行中所有模型参数的条目为 $1$，否则为 $0$。类似地，穿过列 $j$ 的垂直射线对应于 $G$ 中的一行，其中对于该网格列中所有模型参数的条目为 $1$。数据点的总数 $N_d$ 是采样的行数和列数之和。\n\n合成数据向量 $d$ 是通过将正演算子应用于真实模型 $d_{\\mathrm{clean}} = G m_{\\mathrm{true}}$，并添加标准差为 $\\sigma$ 的零均值高斯噪声 $\\epsilon$ 来生成的。因此，$d = G m_{\\mathrm{true}} + \\epsilon$。\n\n任务的核心是求解反演问题：给定 $d$ 和 $G$，估计模型 $m$。我们使用 Tikhonov 正则化来找到一个稳定且有意义的解，特别是因为该问题是欠定的（$N_d \\ll N_m$）。这是通过最小化目标函数 $\\Phi(m)$ 实现的，该函数在数据保真度与期望的模型属性（例如平滑度）之间取得平衡：\n$$\\Phi(m) = \\lVert G m - d \\rVert_{2}^{2} + \\lambda^{2} \\lVert L m \\rVert_{2}^{2}$$\n第一项 $\\lVert G m - d \\rVert_{2}^{2}$ 是数据失配，用于衡量模型预测 $Gm$ 与观测数据 $d$ 的拟合程度。第二项 $\\lambda^{2} \\lVert L m \\rVert_{2}^{2}$ 是正则化项或稳定项。参数 $\\lambda \\ge 0$ 控制权衡。算子 $L$ 惩罚偏离先验期望的模型。这里，$L$ 是$5$点离散拉普拉斯算子，通过惩罚大的二阶空间导数来强制平滑。\n\n对于对应于网格单元 $(i,j)$ 的模型参数 $m_k$，拉普拉斯算子的作用是 $(Lm)_k = \\sum_{p \\in N(k)} m_p - (\\deg(k)) m_k$，其中 $N(k)$ 是网格上相邻单元格的索引集合，$\\deg(k)$ 是这类邻居的数量（度）。对于内部单元格，$\\deg(k)=4$。对于边界和角落的单元格，这个数字分别为 $3$ 或 $2$。这被称为自然边界条件。矩阵 $L$ 的构建方式是使其每一行 $k$ 都编码这个有限差分模板。\n\n为了找到最小化 $\\Phi(m)$ 的模型 $m_{\\mathrm{est}}$，我们计算 $\\Phi(m)$ 关于 $m$ 的梯度并将其设为零：\n$$\\nabla_m \\Phi(m) = \\frac{\\partial}{\\partial m} \\left( (Gm-d)^{T}(Gm-d) + \\lambda^2 (Lm)^{T}(Lm) \\right) = 0$$\n$$\\nabla_m \\Phi(m) = 2G^{T}(Gm-d) + 2\\lambda^2 L^{T}Lm = 0$$\n重新整理各项，得到法方程，即一个关于 $m$ 的线性方程组：\n$$(G^{T}G + \\lambda^2 L^{T}L)m = G^{T}d$$\n这个系统可以求解 $m$。然而，形成乘积 $G^{T}G$ 和 $L^{T}L$ 会增加条件数并导致数值不稳定性。一种更稳健的方法是求解一个等价的增广最小二乘问题。最小化 $\\Phi(m)$ 等同于在最小二乘意义下求解以下系统：\n$$ \\begin{pmatrix} G \\\\ \\lambda L \\end{pmatrix} m = \\begin{pmatrix} d \\\\ 0 \\end{pmatrix} $$\n其中向量 $0$ 的维度等于 $L$ 的行数。这种形式在数值上更优越，并且能无缝处理非正则化情况（$\\lambda=0$）。解 $m_{\\mathrm{est}}$ 可以使用标准的线性最小二乘求解器找到。\n\n最后，为了评估恢复的分辨率，我们计算估计模型 $m_{\\mathrm{est}}$ 和真实模型 $m_{\\mathrm{true}}$ 之间的中心化余弦相似度（相关系数）$r$：\n$$r = \\frac{(m_{\\mathrm{est}} - \\overline{m}_{\\mathrm{est}})^{T} (m_{\\mathrm{true}} - \\overline{m}_{\\mathrm{true}})}{\\lVert m_{\\mathrm{est}} - \\overline{m}_{\\mathrm{est}} \\rVert_{2} \\, \\lVert m_{\\mathrm{true}} - \\overline{m}_{\\mathrm{true}} \\rVert_{2}}$$\n其中 $\\overline{m}$ 表示向量 $m$ 的均值。$r$ 值接近 $1$ 表示模式恢复得非常好，而接近 $0$ 或 $-1$ 则表示恢复效果差或呈负相关。该指标有效地量化了在给定参数下层析成像反演的成功程度。最终算法通过对每个指定的测试用例系统地应用这些步骤来进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_checkerboard(nx, ny, s):\n    \"\"\"\n    Constructs a 2D checkerboard model and flattens it to a 1D vector.\n    \n    Args:\n        nx (int): Number of cells in the x-dimension.\n        ny (int): Number of cells in the y-dimension.\n        s (int): Side length of the checkerboard tiles in cells.\n    \n    Returns:\n        np.ndarray: A 1D numpy array representing the true model m_true.\n    \"\"\"\n    x_coords = np.arange(nx)\n    y_coords = np.arange(ny)\n    xx, yy = np.meshgrid(x_coords, y_coords)\n    \n    # Determine tile indices for each cell\n    tile_indices_x = np.floor(xx / s)\n    tile_indices_y = np.floor(yy / s)\n    \n    # Create checkerboard pattern (+1 and -1)\n    checkerboard_2d = (-1)**(tile_indices_y + tile_indices_x)\n    \n    # Flatten to 1D vector in row-major order\n    return checkerboard_2d.ravel()\n\ndef build_forward_operator(nx, ny, q):\n    \"\"\"\n    Constructs the forward operator G for axis-aligned ray tomography.\n    \n    Args:\n        nx (int): Number of cells in the x-dimension.\n        ny (int): Number of cells in the y-dimension.\n        q (int): Stride for sampling rows and columns.\n    \n    Returns:\n        np.ndarray: The forward operator matrix G.\n    \"\"\"\n    num_model_params = nx * ny\n    \n    # Identify which rows and columns to sample\n    rows_to_sample = np.arange(0, ny, q)\n    cols_to_sample = np.arange(0, nx, q)\n    num_data = len(rows_to_sample) + len(cols_to_sample)\n    \n    G = np.zeros((num_data, num_model_params))\n    \n    data_idx = 0\n    # Fill rows for horizontal rays\n    for i_row in rows_to_sample:\n        start_idx = i_row * nx\n        end_idx = start_idx + nx\n        G[data_idx, start_idx:end_idx] = 1.0\n        data_idx += 1\n        \n    # Fill rows for vertical rays\n    for j_col in cols_to_sample:\n        indices = j_col + np.arange(ny) * nx\n        G[data_idx, indices] = 1.0\n        data_idx += 1\n        \n    return G\n\ndef build_laplacian(nx, ny):\n    \"\"\"\n    Constructs the 5-point discrete Laplacian operator L with natural boundary conditions.\n    \n    Args:\n        nx (int): Number of cells in the x-dimension.\n        ny (int): Number of cells in the y-dimension.\n    \n    Returns:\n        np.ndarray: The discrete Laplacian matrix L.\n    \"\"\"\n    num_model_params = nx * ny\n    L = np.zeros((num_model_params, num_model_params))\n    \n    for k in range(num_model_params):\n        i = k // nx  # Row index\n        j = k % nx   # Column index\n        \n        neighbors = []\n        # Neighbor above\n        if i > 0: neighbors.append(k - nx)\n        # Neighbor below\n        if i  ny - 1: neighbors.append(k + nx)\n        # Neighbor left\n        if j > 0: neighbors.append(k - 1)\n        # Neighbor right\n        if j  nx - 1: neighbors.append(k + 1)\n            \n        # Set diagonal to - (number of neighbors)\n        L[k, k] = -len(neighbors)\n        # Set off-diagonals to 1 for each neighbor\n        for neighbor_idx in neighbors:\n            L[k, neighbor_idx] = 1.0\n            \n    return L\n\ndef compute_correlation(m_est, m_true):\n    \"\"\"\n    Computes the centered cosine similarity between two model vectors.\n    \n    Args:\n        m_est (np.ndarray): The estimated model vector.\n        m_true (np.ndarray): The true model vector.\n    \n    Returns:\n        float: The correlation coefficient r.\n    \"\"\"\n    # Center the vectors by subtracting their means\n    m_est_centered = m_est - np.mean(m_est)\n    m_true_centered = m_true - np.mean(m_true)\n    \n    # Compute norms of the centered vectors\n    norm_est = np.linalg.norm(m_est_centered)\n    norm_true = np.linalg.norm(m_true_centered)\n    \n    # Avoid division by zero if a vector is constant\n    if norm_est == 0 or norm_true == 0:\n        return 0.0\n        \n    # Compute the dot product and normalize\n    numerator = np.dot(m_est_centered, m_true_centered)\n    denominator = norm_est * norm_true\n    \n    return numerator / denominator\n\ndef run_single_case(params, seed):\n    \"\"\"\n    Runs a single checkerboard test case.\n    \"\"\"\n    nx, ny, s, lam, sig, q = params\n    \n    # 1. Construct true model, forward operator, and Laplacian\n    m_true = build_checkerboard(nx, ny, s)\n    G = build_forward_operator(nx, ny, q)\n    L = build_laplacian(nx, ny)\n    \n    # 2. Generate synthetic data\n    d_clean = G @ m_true\n    if sig > 0:\n        rng = np.random.default_rng(seed=seed)\n        noise = rng.normal(loc=0.0, scale=sig, size=d_clean.shape)\n        d = d_clean + noise\n    else:\n        d = d_clean\n    \n    # 3. Solve the regularized inverse problem\n    num_model_params = nx * ny\n    if lam > 0:\n        # Augmented system for Tikhonov regularization\n        A_aug = np.vstack([G, lam * L])\n        d_aug = np.concatenate([d, np.zeros(num_model_params)])\n        m_est = np.linalg.lstsq(A_aug, d_aug, rcond=None)[0]\n    else:\n        # Unregularized least-squares (minimum norm solution)\n        m_est = np.linalg.lstsq(G, d, rcond=None)[0]\n\n    # 4. Evaluate resolution\n    correlation = compute_correlation(m_est, m_true)\n    \n    return round(correlation, 3)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (16, 16, 4, 0.5, 0.0, 2),  # Case 1\n        (16, 16, 4, 0.0, 0.0, 2),  # Case 2\n        (16, 16, 4, 5.0, 0.0, 2),  # Case 3\n        (16, 16, 2, 0.5, 0.0, 2),  # Case 4\n        (16, 16, 4, 0.5, 0.05, 2)  # Case 5\n    ]\n    \n    results = []\n    for i, case_params in enumerate(test_cases):\n        # Use a different seed for each case for reproducibility\n        result = run_single_case(case_params, seed=i)\n        results.append(result)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}