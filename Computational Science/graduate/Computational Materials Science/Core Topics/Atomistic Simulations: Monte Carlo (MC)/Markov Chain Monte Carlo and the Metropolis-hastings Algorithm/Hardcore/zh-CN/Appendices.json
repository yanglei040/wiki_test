{
    "hands_on_practices": [
        {
            "introduction": "在构建任何马尔可夫链蒙特卡洛（MCMC）模拟时，一个首要的、不可妥协的原则是遍历性（irreducibility），即算法必须有能力探索整个可能的状态空间。如果违反了这一原则，模拟将被限制在一个子集中，从而无法正确地从目标分布中抽样。这项练习  将通过一个精心设计的、违反遍历性的提议核，在一个简单的伊辛模型上，让你亲手分析其后果，从而让你深刻理解为何遍历性是保证 MCMC 模拟结果可靠性的基石。",
            "id": "3463572",
            "problem": "考虑一个具有 $N=4$ 个格点的一维周期性伊辛格点，该模型模拟了一个环上的二元合金，其中自旋变量 $s_i \\in \\{-1,+1\\}$ 代表格点 $i$ 上的局域物种状态。一个组态 $\\mathbf{s} = (s_1,s_2,s_3,s_4)$ 的能量由带外场的最近邻伊辛哈密顿量给出，\n$$\nE(\\mathbf{s}) = - J \\left( s_1 s_2 + s_2 s_3 + s_3 s_4 + s_4 s_1 \\right) - h \\left( s_1 + s_2 + s_3 + s_4 \\right),\n$$\n其中 $J$ 和 $h$ 分别是与材料相关的相互作用参数和场参数，$\\beta$ 是逆热能，$\\beta = 1/(k_B T)$，其中 $k_B$ 是玻尔兹曼常数，$T$ 是温度。用于采样平衡组态的目标分布是玻尔兹曼分布\n$$\n\\pi(\\mathbf{s}) \\propto \\exp\\!\\left( - \\beta E(\\mathbf{s}) \\right).\n$$\n使用带有 Metropolis-Hastings (MH) 算法的马尔可夫链蒙特卡洛 (MCMC) 方法从 $\\pi(\\mathbf{s})$ 中采样。提议核定义如下：在每一步中，从集合 $\\{2,4\\}$ 中均匀随机地选择一个偶数索引的格点并翻转其自旋，而奇数索引的自旋从不被提议改变。这个提议局部上满足细致平衡，但在完整组态空间上违反了不可約性。\n\n从奇数自旋固定为 $s_1 = +1$ 和 $s_3 = -1$ 的初始组态出发，完成以下任务：\n\n- 使用马尔可夫链的不可约性和细致平衡的定义，解释为什么这个提议会导出状态的闭互通类，并确定由奇数自旋约束 $s_1 = +1$ 和 $s_3 = -1$ 所决定的闭类。\n- 推导 MH 链收敛到的、在该闭类上支持的平稳分布，并将其表示为以固定奇数自旋为条件的玻尔兹曼分布。\n- 计算从此给定奇数自旋约束开始，该链不可达的目标玻尔兹曼概率质量的精确分数，即 1 减去目标分布 $\\pi(\\mathbf{s})$ 下该闭类的总条件概率质量。\n\n你的最终答案必须是关于 $\\beta$、$J$ 和 $h$ 的单个闭式解析表达式。这个量是无量纲的；请以无单位的形式表达你的答案。不要近似；不需要四舍五入。",
            "solution": "所述问题具有科学依据、适定、客观，并包含唯一解所需的所有必要信息。这是统计力学和马尔可夫链蒙特卡洛方法中的一个标准练习，旨在检验可约马尔可夫链的后果。因此，该问题被认为是有效的，下面是完整解答。\n\n问题要求完成三个相关的任务，这些任务涉及一个应用于具有 $N=4$ 个格点的一维周期性伊辛模型的、带有非标准提议机制的 Metropolis-Hastings (MH) 算法。我们将依次解决每个任务。\n\n首先，我们分析由提议核导出的马尔可夫链的结构。系统的状态空间是所有可能的自旋组态 $\\mathbf{s}=(s_1,s_2,s_3,s_4)$ 的集合，其中 $s_i \\in \\{-1, +1\\}$。这给出了总共 $2^4 = 16$ 个可能的状态。提议规则规定，在每一步中，从集合 $\\{2, 4\\}$ 中均匀随机地选择一个格点并翻转其自旋。奇数索引格点上的自旋 $s_1$ 和 $s_3$ 从不被提议改变。\n\n如果可以从任何状态到达任何其他状态（不一定是一步），则马尔可夫链是**不可约的**。给定的提议机制违反了这一性质。如果链从一个具有特定 $(s_1, s_3)$ 值对（比如 $(s_1^*, s_3^*)$）的状态开始，则链生成的任何后续状态的奇数索引自旋也将固定为 $(s_1^*, s_3^*)$。不可能转移到具有不同奇数索引自旋对的状态，例如 $(s_1', s_3')$，其中 $(s_1', s_3') \\neq (s_1^*, s_3^*)$。\n\n这个限制将总状态空间 $\\mathcal{S}$ 划分为四个不相交的子集，每个子集对应于 $(s_1, s_3)$ 的一个可能值对：$\\{(+1, +1), (+1, -1), (-1, +1), (-1, -1)\\}$。在每个这样的子集中，任何状态都可以从任何其他状态到达。例如，在 $s_1$ 和 $s_3$ 固定的子集中，$(s_2, s_4)$ 的任何组态都可以从任何其他组态到达。通过翻转 $s_2$ 可以实现从 $(s_2, s_4)$ 到 $(-s_2, s_4)$ 的转移，而通过先翻转 $s_2$ 再翻转 $s_4$ 可以实现到 $(-s_2, -s_4)$ 的转移。根据 MH 规则，这些转移以某个非零概率被接受。因此，这样一个子集中的所有状态构成一个**互通类**。由于这些类之间不可能发生转移，每个类都是**闭的**。\n\n问题指定了一个初始约束，其中奇数自旋固定为 $s_1 = +1$ 和 $s_3 = -1$。由该约束确定的闭互通类是所有 $s_1=+1$ 和 $s_3=-1$ 的状态 $\\mathbf{s}$ 的集合，而 $s_2$ 和 $s_4$ 可以是 $+1$ 或 $-1$。我们用 $\\mathcal{C}_{1,-1}$ 表示这个类。它包含以下四个状态：\n$\\mathcal{C}_{1,-1} = \\{ (+1, +1, -1, +1), (+1, +1, -1, -1), (+1, -1, -1, +1), (+1, -1, -1, -1) \\}$。\n\n第二，我们推导当马尔可夫链被限制在这个闭类 $\\mathcal{C}_{1,-1}$ 中时的平稳分布。MH 算法的构建是为了满足相对于目标玻尔兹曼分布 $\\pi(\\mathbf{s}) \\propto \\exp(-\\beta E(\\mathbf{s}))$ 的细致平衡条件。该条件是 $\\pi(\\mathbf{s}) P(\\mathbf{s} \\to \\mathbf{s}') = \\pi(\\mathbf{s}') P(\\mathbf{s}' \\to \\mathbf{s})$，适用于任何两个状态 $\\mathbf{s}, \\mathbf{s}'$。当一个相对于分布 $\\pi$ 满足细致平衡的马尔可夫链是可约的时，其动态演化一旦局限于一个闭类 $\\mathcal{C}$，将收敛到一个平稳分布 $\\pi_{\\text{cond}}$，该分布是 $\\pi$ 限制在 $\\mathcal{C}$ 上的条件分布。\n对于任何状态 $\\mathbf{s} \\in \\mathcal{C}_{1,-1}$，这个平稳分布由下式给出：\n$$\n\\pi_{\\text{cond}}(\\mathbf{s}) = \\frac{\\pi(\\mathbf{s})}{\\sum_{\\mathbf{s}' \\in \\mathcal{C}_{1,-1}} \\pi(\\mathbf{s}')} = \\frac{\\exp(-\\beta E(\\mathbf{s}))}{\\sum_{\\mathbf{s}' \\in \\mathcal{C}_{1,-1}} \\exp(-\\beta E(\\mathbf{s}'))}\n$$\n这是以固定奇数自旋 $s_1=+1$ 和 $s_3=-1$ 为条件的玻尔兹曼分布。\n\n第三，我们计算从给定约束开始，链不可达的目标玻尔兹曼概率质量的分数。这个分数是 1 减去可达类 $\\mathcal{C}_{1,-1}$ 的总概率质量。$\\mathcal{C}_{1,-1}$ 的总概率质量是其内部所有状态在完整玻尔兹曼分布 $\\pi(\\mathbf{s}) = \\exp(-\\beta E(\\mathbf{s}))/Z$ 下的概率之和，其中 $Z$ 是对所有 16 个状态的全配分函数。\n$$\nP(\\mathcal{C}_{1,-1}) = \\sum_{\\mathbf{s} \\in \\mathcal{C}_{1,-1}} \\pi(\\mathbf{s}) = \\frac{\\sum_{\\mathbf{s} \\in \\mathcal{C}_{1,-1}} \\exp(-\\beta E(\\mathbf{s}))}{\\sum_{\\mathbf{s} \\in \\mathcal{S}} \\exp(-\\beta E(\\mathbf{s}))} = \\frac{Z_{1,-1}}{Z}\n$$\n因此，不可达质量分数为 $1 - P(\\mathcal{C}_{1,-1}) = 1 - \\frac{Z_{1,-1}}{Z}$。\n\n我们必须计算部分配分函数 $Z_{1,-1}$ 和全配分函数 $Z$。\n哈密顿量为 $E(\\mathbf{s}) = - J \\left( s_1 s_2 + s_2 s_3 + s_3 s_4 + s_4 s_1 \\right) - h \\left( s_1 + s_2 + s_3 + s_4 \\right)$。\n对于类 $\\mathcal{C}_{1,-1}$，我们固定 $s_1=+1$ 和 $s_3=-1$。能量变为：\n$E(\\mathbf{s}) = -J((+1)s_2 + s_2(-1) + (-1)s_4 + s_4(+1)) - h((+1) + s_2 + (-1) + s_4) = -J(0) - h(s_2+s_4) = -h(s_2+s_4)$。\n我们对 $\\mathcal{C}_{1,-1}$ 中的四个状态求和 $\\exp(-\\beta E(\\mathbf{s}))$，这些状态对应于 $(s_2,s_4)$ 对 $(+1,+1), (+1,-1), (-1,+1), (-1,-1)$。\n能量分别为 $-2h, 0, 0, 2h$。\n$Z_{1,-1} = \\exp(2\\beta h) + \\exp(0) + \\exp(0) + \\exp(-2\\beta h) = \\exp(2\\beta h) + \\exp(-2\\beta h) + 2 = 2\\cosh(2\\beta h) + 2$。\n\n接下来，我们计算全配分函数 $Z$。我们可以通过对所有 16 个组态按能量分类求和来做到这一点。不同的能级及其简并度如下：\n\\begin{itemize}\n    \\item $k=4$ 个（+自旋）：$1$ 个状态 $(1,1,1,1)$；$E = -4J-4h$。\n    \\item $k=0$ 个（+自旋）：$1$ 个状态 $(-1,-1,-1,-1)$；$E = -4J+4h$。\n    \\item $k=3$ 个（+自旋）：$4$ 个状态，如 $(1,1,1,-1)$；$E = -2h$。\n    \\item $k=1$ 个（+自旋）：$4$ 个状态，如 $(1,-1,-1,-1)$；$E = 2h$。\n    \\item $k=2$ 个（+自旋），交替如 $(1,-1,1,-1)$：$2$ 个状态；$E = 4J$。\n    \\item $k=2$ 个（+自旋），相邻如 $(1,1,-1,-1)$：$4$ 个状态；$E = 0$。\n\\end{itemize}\n对所有 16 个状态的玻尔兹曼因子求和：\n$Z = \\exp(-\\beta(-4J-4h)) + \\exp(-\\beta(-4J+4h)) + 4\\exp(-\\beta(-2h)) + 4\\exp(-\\beta(2h)) + 2\\exp(-\\beta(4J)) + 4\\exp(0)$。\n$Z = \\exp(4\\beta J + 4\\beta h) + \\exp(4\\beta J - 4\\beta h) + 4\\exp(2\\beta h) + 4\\exp(-2\\beta h) + 2\\exp(-4\\beta J) + 4$。\n我们可以将各项分组：\n$Z = \\exp(4\\beta J)[\\exp(4\\beta h) + \\exp(-4\\beta h)] + 4[\\exp(2\\beta h) + \\exp(-2\\beta h)] + 2\\exp(-4\\beta J) + 4$。\n$Z = 2\\exp(4\\beta J)\\cosh(4\\beta h) + 8\\cosh(2\\beta h) + 2\\exp(-4\\beta J) + 4$。\n\n不可达质量的分数为 $1 - \\frac{Z_{1,-1}}{Z}$：\n$$\n\\text{分数} = 1 - \\frac{2\\cosh(2\\beta h) + 2}{2\\exp(4\\beta J)\\cosh(4\\beta h) + 8\\cosh(2\\beta h) + 2\\exp(-4\\beta J) + 4}\n$$\n这可以写成 $\\frac{Z - Z_{1,-1}}{Z}$：\n$$\n\\text{分数} = \\frac{(2\\exp(4\\beta J)\\cosh(4\\beta h) + 8\\cosh(2\\beta h) + 2\\exp(-4\\beta J) + 4) - (2\\cosh(2\\beta h) + 2)}{2\\exp(4\\beta J)\\cosh(4\\beta h) + 8\\cosh(2\\beta h) + 2\\exp(-4\\beta J) + 4}\n$$\n$$\n\\text{分数} = \\frac{2\\exp(4\\beta J)\\cosh(4\\beta h) + 6\\cosh(2\\beta h) + 2\\exp(-4\\beta J) + 2}{2\\exp(4\\beta J)\\cosh(4\\beta h) + 8\\cosh(2\\beta h) + 2\\exp(-4\\beta J) + 4}\n$$\n分子和分母同时除以 $2$，得到最终表达式：\n$$\n\\text{分数} = \\frac{\\exp(4\\beta J)\\cosh(4\\beta h) + 3\\cosh(2\\beta h) + \\exp(-4\\beta J) + 1}{\\exp(4\\beta J)\\cosh(4\\beta h) + 4\\cosh(2\\beta h) + \\exp(-4\\beta J) + 2}\n$$",
            "answer": "$$\\boxed{\\frac{\\exp(4\\beta J)\\cosh(4\\beta h) + 3\\cosh(2\\beta h) + \\exp(-4\\beta J) + 1}{\\exp(4\\beta J)\\cosh(4\\beta h) + 4\\cosh(2\\beta h) + \\exp(-4\\beta J) + 2}}$$"
        },
        {
            "introduction": "一旦确保了 MCMC 算法的正确性，下一个核心挑战便是提升其效率。在实际应用中，我们常常面临一个权衡：是使用计算成本高但接受率高的“精确”提议，还是使用计算成本低但接受率较低的“廉价”提议？这项练习  构建了一个量化模型来分析这一权衡，要求你通过优化一个代表单位时间内有效样本数的指标，来确定最佳提议策略。通过这个实践，你将学会如何定量地分析和优化采样效率，这是在计算材料科学中进行大规模模拟时的一项关键技能。",
            "id": "3463564",
            "problem": "在使用梅特罗波利斯-哈斯廷斯算法以温度 $T$ 下的玻尔兹曼分布为目标，对晶体缺陷的原子构型进行采样时，考虑一个描述机械稳定构型附近局域弛豫模式的单一集体坐标 $q$。在谐波近似下，势能为 $E(q) \\approx E_{0} + \\frac{1}{2} k_{\\mathrm{eff}} q^{2}$。提议是通过对称随机行走微扰 $q' = q + \\delta$ 生成的，其中 $\\delta$ 从具有单一可调尺度参数 $s$ 的各向同性分布中抽取，使得典型的跳跃距离平方为 $s^{2}$。对于对称提议，梅特罗波利斯-哈斯廷斯接受概率为 $\\alpha(q \\to q') = \\min\\{1, \\exp(-\\beta [E(q') - E(q)])\\}$，其中 $\\beta = 1/(k_{B} T)$，$k_{B}$ 是玻尔兹曼常数。\n\n假设以下建模选择，这些选择由谐波近似和小步长机制证明是合理的：\n- 对于精确的、完全从头计算的能量评估，平均接受率作为尺度 $s$ 的函数是 $a(s) \\approx \\exp(-\\lambda s^{2})$，其中 $\\lambda = \\frac{1}{2} \\beta k_{\\mathrm{eff}}$ 是一个正常数。\n- 对于一个为维持细致平衡而校正的更廉价的基于代理模型的提议（例如，一个两阶段方案，其中代理模型过滤器引起额外的拒绝），有效平均接受率是 $a_{\\mathrm{cheap}}(s) \\approx r \\exp(-\\mu s^{2})$，其中 $0  r  1$ 和 $\\mu  0$ 包含了由不匹配引起的额外敏感性。\n- 对于两种提议机制，在接受条件下的期望跳跃距离平方为 $\\mathbb{E}[(q' - q)^{2} \\mid \\text{accept}] \\approx s^{2}$。\n\n在马尔可夫链蒙特卡洛中，通常使用期望跳跃距离平方作为混合速度和逆积分自相关时间的代理指标。在此代理指标下，将给定 $s$ 时单位墙钟时间内的有效样本量建模为与以下公式成正比：\n$$\nF(s) = \\frac{a(s) \\, s^{2}}{c},\n$$\n其中 $c$ 是每个提议的平均墙钟时间。对于精确评估，取 $c_{\\mathrm{acc}} = 5 \\ \\mathrm{s}$ 和 $\\lambda_{\\mathrm{acc}} = 4$。对于廉价提议，取 $c_{\\mathrm{ch}} = 0.2 \\ \\mathrm{s}$，$r = 0.6$ 和 $\\mu = 9$。\n\n从梅特罗波利斯-哈斯廷斯接受率的定义和上述基于谐波近似的建模假设出发，推导出使每种机制的 $F(s)$ 最大化的尺度 $s$，并从这些最优值推导出廉价机制相对于精确机制的最大化单位时间有效样本量的比率。将你的最终答案表示为等于该比率的单个实数。将答案四舍五入到三位有效数字。该比率是无量纲的；不要包含单位。",
            "solution": "首先评估问题的有效性。\n\n**步骤 1：提取给定条件**\n- 算法：梅特罗波利斯-哈斯廷斯，目标为温度 $T$ 下的玻尔兹曼分布。\n- 谐波近似下的势能：$E(q) \\approx E_{0} + \\frac{1}{2} k_{\\mathrm{eff}} q^{2}$。\n- 提议移动：$q' = q + \\delta$，其中 $\\delta$ 来自尺度为 $s$ 的对称分布。\n- 接受概率：$\\alpha(q \\to q') = \\min\\{1, \\exp(-\\beta [E(q') - E(q)])\\}$，其中 $\\beta = 1/(k_{B} T)$。\n- 精确机制的平均接受率：$a_{\\mathrm{acc}}(s) \\approx \\exp(-\\lambda_{\\mathrm{acc}} s^{2})$。\n- 廉价机制的平均接受率：$a_{\\mathrm{ch}}(s) \\approx r \\exp(-\\mu s^{2})$。\n- 单位时间有效样本量的代理指标：$F(s) = \\frac{a(s) \\, s^{2}}{c}$。\n- 精确机制的参数：$c_{\\mathrm{acc}} = 5 \\ \\mathrm{s}$，$\\lambda_{\\mathrm{acc}} = 4$。\n- 廉价机制的参数：$c_{\\mathrm{ch}} = 0.2 \\ \\mathrm{s}$，$r = 0.6$，$\\mu = 9$。\n\n**步骤 2：使用提取的给定条件进行验证**\n这个问题定义明确，并且在计算材料科学和统计力学领域具有坚实的科学基础。梅特罗波利斯-哈斯廷斯算法、玻尔兹曼分布的使用、对最小值附近势能的谐波近似，以及使用期望跳跃距离平方作为采样效率的代理指标，都是标准的概念和实践。接受概率的函数形式对于小步长机制是合理的近似。问题提供了所有必要的数据，并且没有矛盾、歧义或事实错误。因此，该问题被认为是有效的。\n\n**步骤 3：结论与行动**\n问题有效。下面是完整的、有理有据的解答。\n\n目标是求出廉价机制相对于精确机制的最大化单位时间有效样本量的比率。这需要对每种机制的函数 $F(s) = \\frac{a(s) \\, s^{2}}{c}$ 进行最大化。\n\n首先，我们求出使形如 $G(s) = s^2 \\exp(-k s^2)$ 的函数（其中 $k$ 为某个正常数）最大化的最优尺度参数 $s$ 的一般形式。两种机制的函数 $F(s)$ 都与此形式成正比。为了求最大值，我们计算 $G(s)$ 对 $s$ 的导数并令其为零。\n使用乘积法则求导：\n$$\n\\frac{dG}{ds} = \\frac{d}{ds} \\left( s^2 \\exp(-k s^2) \\right) = (2s) \\exp(-k s^2) + s^2 \\left( \\exp(-k s^2) \\cdot (-2ks) \\right)\n$$\n$$\n\\frac{dG}{ds} = 2s \\exp(-k s^2) (1 - k s^2)\n$$\n对于一个非平凡的最大值 ($s > 0$)，我们将项 $(1 - k s^2)$ 设为零：\n$$\n1 - k s^2 = 0 \\implies s^2 = \\frac{1}{k}\n$$\n最优尺度参数为 $s_{\\mathrm{opt}} = \\sqrt{1/k}$。将 $s_{\\mathrm{opt}}^2 = 1/k$ 代回函数，得到 $G(s)$ 的最大值：\n$$\nG_{\\mathrm{max}} = G(s_{\\mathrm{opt}}) = \\left(\\frac{1}{k}\\right) \\exp\\left(-k \\cdot \\frac{1}{k}\\right) = \\frac{1}{k} \\exp(-1) = \\frac{1}{ke}\n$$\n\n现在，我们将此结果应用于两种机制。\n\n**1. 精确机制**\n需要最大化的函数是：\n$$\nF_{\\mathrm{acc}}(s) = \\frac{a_{\\mathrm{acc}}(s) s^2}{c_{\\mathrm{acc}}} = \\frac{\\exp(-\\lambda_{\\mathrm{acc}} s^2) s^2}{c_{\\mathrm{acc}}} = \\frac{1}{c_{\\mathrm{acc}}} \\left( s^2 \\exp(-\\lambda_{\\mathrm{acc}} s^2) \\right)\n$$\n这对应于我们的通用形式，其中 $k = \\lambda_{\\mathrm{acc}}$。$F_{\\mathrm{acc}}(s)$ 的优化等同于优化 $s^2 \\exp(-\\lambda_{\\mathrm{acc}} s^2)$。\n$F_{\\mathrm{acc}}(s)$ 的最大值，记为 $F_{\\mathrm{acc, max}}$，是：\n$$\nF_{\\mathrm{acc, max}} = \\frac{1}{c_{\\mathrm{acc}}} \\left( \\frac{1}{\\lambda_{\\mathrm{acc}} e} \\right) = \\frac{1}{c_{\\mathrm{acc}} \\lambda_{\\mathrm{acc}} e}\n$$\n代入给定值 $c_{\\mathrm{acc}} = 5$ 和 $\\lambda_{\\mathrm{acc}} = 4$：\n$$\nF_{\\mathrm{acc, max}} = \\frac{1}{5 \\cdot 4 \\cdot e} = \\frac{1}{20e}\n$$\n\n**2. 廉价机制**\n需要最大化的函数是：\n$$\nF_{\\mathrm{ch}}(s) = \\frac{a_{\\mathrm{ch}}(s) s^2}{c_{\\mathrm{ch}}} = \\frac{r \\exp(-\\mu s^2) s^2}{c_{\\mathrm{ch}}} = \\frac{r}{c_{\\mathrm{ch}}} \\left( s^2 \\exp(-\\mu s^2) \\right)\n$$\n这对应于我们的通用形式，其中 $k = \\mu$。$F_{\\mathrm{ch}}(s)$ 的优化等同于优化 $s^2 \\exp(-\\mu s^2)$，结果再乘以预因子 $r/c_{\\mathrm{ch}}$。\n$F_{\\mathrm{ch}}(s)$ 的最大值，记为 $F_{\\mathrm{ch, max}}$，是：\n$$\nF_{\\mathrm{ch, max}} = \\frac{r}{c_{\\mathrm{ch}}} \\left( \\frac{1}{\\mu e} \\right) = \\frac{r}{c_{\\mathrm{ch}} \\mu e}\n$$\n代入给定值 $c_{\\mathrm{ch}} = 0.2$，$r = 0.6$ 和 $\\mu = 9$：\n$$\nF_{\\mathrm{ch, max}} = \\frac{0.6}{0.2 \\cdot 9 \\cdot e} = \\frac{0.6}{1.8 e} = \\frac{1}{3e}\n$$\n\n**3. 最大化效率之比**\n问题要求廉价机制与精确机制的最大化有效样本量之比。\n$$\n\\text{比率} = \\frac{F_{\\mathrm{ch, max}}}{F_{\\mathrm{acc, max}}} = \\frac{ \\frac{r}{c_{\\mathrm{ch}} \\mu e} }{ \\frac{1}{c_{\\mathrm{acc}} \\lambda_{\\mathrm{acc}} e} }\n$$\n分子和分母中的因子 $1/e$ 消掉了：\n$$\n\\text{比率} = \\frac{r c_{\\mathrm{acc}} \\lambda_{\\mathrm{acc}}}{c_{\\mathrm{ch}} \\mu}\n$$\n现在，我们代入数值：\n$$\n\\text{比率} = \\frac{0.6 \\cdot 5 \\cdot 4}{0.2 \\cdot 9} = \\frac{12}{1.8} = \\frac{120}{18} = \\frac{20}{3}\n$$\n换算成小数，即为 $20/3 = 6.666...$。\n问题要求将答案四舍五入到三位有效数字。\n$$\n\\text{比率} \\approx 6.67\n$$\n此结果表明，在给定的建模假设下，当两种方法都经过优化调整时，廉价的、由代理模型辅助的采样策略的效率大约是标准精确方法的 6.67 倍。",
            "answer": "$$\n\\boxed{6.67}\n$$"
        },
        {
            "introduction": "对于具有内在结构的系统，如晶体材料，简单的随机游走提议往往效率低下。利用系统的物理对称性可以设计出更智能、更高效的 MCMC 提议机制。这项综合性练习  将引导你为方形晶格上的合金模型设计一个高级的、利用点群对称性的提议方案。你将首先从细致平衡原理出发，推导出这种非对称、群平均提议所对应的正确接受率公式，然后通过编程实现它。这个练习将理论推导与代码实现紧密结合，是体验计算材料科学家如何将物理直觉转化为强大算法的绝佳机会。",
            "id": "3463637",
            "problem": "您正在使用马尔可夫链蒙特卡洛（MCMC）方法，特别是Metropolis-Hastings（MH）算法，研究方格晶格上的二元合金无序。构型空间由晶格点上所有可能的二元组分标签分配构成。考虑一个尺寸为 $L \\times L$ 且具有周期性边界条件的方格晶格。设构型由 $\\mathbf{s}$ 表示，其中每个格点 $i$ 上的组分为 $s_{i} \\in \\{\\text{A}, \\text{B}\\}$。目标分布由玻尔兹曼权重 $\\pi(\\mathbf{s}) \\propto \\exp(-\\beta E(\\mathbf{s}))$ 定义，其中 $\\beta  0$ 是逆温度，$E(\\mathbf{s})$ 是构型能量。使用最近邻键能\n$$\nE(\\mathbf{s}) \\;=\\; J \\sum_{\\langle i,j \\rangle} \\mathbf{1}[s_i \\ne s_j],\n$$\n其中，求和项对每个无序的最近邻键恰好计算一次，$\\mathbf{1}[\\cdot]$ 是指示函数。假设 $\\beta$ 和 $J$ 是给定的正实数。\n\n您需要设计一种通过对正方形的二面体群进行对称化来保持晶格点群不变性的提议（proposal）。设 $G$ 表示方格晶格的点群（二面体群），其阶为 $|G| = 8$，包含恒等变换、旋转 $90^{\\circ}$、$180^{\\circ}$ 和 $270^{\\circ}$，以及关于垂直轴、水平轴、主对角线和反对角线的反射。定义一个原始交换移动模板，该模板交换两个固定晶格点 $p_0$ 和 $p_1$（这些是晶格坐标）上的组分。对于任何 $g \\in G$，定义一个群变换移动，该移动交换格点 $g(p_0)$ 和 $g(p_1)$ 上的组分。\n\n我们不直接从单个群元素进行提议，而是如下定义群平均提议机制。对于给定的当前构型 $\\mathbf{x}$，考虑通过对所有 $g \\in G$ 应用 $g(p_0)$ 和 $g(p_1)$ 处的交换所获得的、按构型等同性去重后的不同提议构型集合。将此去重后的集合表示为 $\\mathcal{O}_{\\mathbf{x}}$，其基数表示为 $k(\\mathbf{x}) = |\\mathcal{O}_{\\mathbf{x}}|$。该提议从 $\\mathcal{O}_{\\mathbf{x}}$ 的元素中均匀选择，因此提议质量函数 $q(\\mathbf{x} \\to \\mathbf{y})$ 对于 $\\mathbf{y} \\in \\mathcal{O}_{\\mathbf{x}}$ 等于 $1/k(\\mathbf{x})$，否则为 $0$。\n\n任务：\n1. 从细致平衡的定义和Metropolis-Hastings接受机制的构建出发，并且仅使用目标密度为 $\\pi(\\mathbf{s}) \\propto \\exp(-\\beta E(\\mathbf{s}))$ 以及提议是上述定义的群平均均匀机制这两个基本事实，推导从 $\\mathbf{x}$ 到 $\\mathbf{y} \\in \\mathcal{O}_{\\mathbf{x}}$ 的提议跃迁的接受概率 $\\alpha(\\mathbf{x}, \\mathbf{y})$，用 $E(\\cdot)$、$\\beta$、$k(\\mathbf{x})$ 和 $k(\\mathbf{y})$ 表示。您的推导必须从细致平衡原理开始，不得假定接受概率有已知的封闭形式。\n2. 实现一个程序，对于下面定义的每个测试用例，该程序需要构建晶格，使用周期性边界条件计算能量 $E(\\mathbf{s})$，通过将指定的单个群元素 $g$ 应用于模板对 $(p_0, p_1)$ 并交换得到的两个格点来构建提议构型 $\\mathbf{y}$，枚举群平均轨道集 $\\mathcal{O}_{\\mathbf{x}}$ 和 $\\mathcal{O}_{\\mathbf{y}}$，然后使用您推导的表达式计算接受概率 $\\alpha(\\mathbf{x}, \\mathbf{y})$。如果 $\\mathbf{y} = \\mathbf{x}$，则定义 $\\alpha(\\mathbf{x}, \\mathbf{y}) = 1$。\n\n晶格坐标以从零开始的索引 $(r, c)$ 给出，其中 $r \\in \\{0,\\dots,L-1\\}$ 且 $c \\in \\{0,\\dots,L-1\\}$。群 $G$ 通过以下从 $0$ 到 $7$ 索引的八种操作作用于坐标：\n- $0$：恒等变换, $(r,c) \\mapsto (r,c)$,\n- $1$：旋转 $90^{\\circ}$, $(r,c) \\mapsto (c, L - 1 - r)$,\n- $2$：旋转 $180^{\\circ}$, $(r,c) \\mapsto (L - 1 - r, L - 1 - c)$,\n- $3$：旋转 $270^{\\circ}$, $(r,c) \\mapsto (L - 1 - c, r)$,\n- $4$：关于垂直轴的反射, $(r,c) \\mapsto (r, L - 1 - c)$,\n- $5$：关于水平轴的反射, $(r,c) \\mapsto (L - 1 - r, c)$,\n- $6$：关于主对角线的反射, $(r,c) \\mapsto (c, r)$,\n- $7$：关于反对角线的反射, $(r,c) \\mapsto (L - 1 - c, L - 1 - r)$.\n\n构型由一个长度为 $L^2$、基于字母表 $\\{\\text{A}, \\text{B}\\}$ 的行主序字符串指定。能量计算使用周期性邻居，因此每个格点恰好有四个邻居，但在定义 $E(\\mathbf{s})$ 的求和中，每个键只计算一次。\n\n测试套件：\n- 测试用例 1：$L = 3$，$\\beta = 0.7$，$J = 1.0$，构型字符串 \"ABABABABA\"（行主序，对应行为 \"ABA\", \"BAB\", \"ABA\"），模板 $p_0 = (0,0)$，$p_1 = (1,0)$，群元素索引 $g = 1$。\n- 测试用例 2：$L = 3$，$\\beta = 0.9$，$J = 1.0$，构型字符串 \"AAAABAAAA\"（行主序，对应行为 \"AAA\", \"ABA\", \"AAA\"），模板 $p_0 = (0,0)$，$p_1 = (1,0)$，群元素索引 $g = 6$。\n- 测试用例 3：$L = 4$，$\\beta = 0.5$，$J = 1.0$，构型字符串 \"ABABBBAAAABBBABA\"（行主序，对应行为 \"ABAB\", \"BBAA\", \"AABB\", \"BABA\"），模板 $p_0 = (0,0)$，$p_1 = (1,0)$，群元素索引 $g = 4$。\n\n您的程序必须：\n- 对于每个测试用例，从字符串构建 $\\mathbf{x}$，通过将指定的 $g$ 应用于 $(p_0, p_1)$ 并在 $\\mathbf{x}$ 中交换得到的两个格点来构建 $\\mathbf{y}$，通过应用所有 $|G| = 8$ 个群操作并按构型等同性去重来枚举 $\\mathcal{O}_{\\mathbf{x}}$ 和 $\\mathcal{O}_{\\mathbf{y}}$，计算 $E(\\mathbf{x})$ 和 $E(\\mathbf{y})$，然后使用您基于细致平衡推导出的表达式计算 $\\alpha(\\mathbf{x}, \\mathbf{y})$。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如“[0.12345678,0.23456789,0.34567890]”。将每个浮点接受概率四舍五入到恰好 $8$ 位小数。\n\n您的最终输出必须是与上述三个测试用例相对应的三个浮点值列表，顺序与指定相同。不涉及物理单位，角度仅作为群操作的一部分隐式给出；不需要角度单位。最终输出格式严格遵守上述单行描述。",
            "solution": "该问题要求我们首先推导群平均Metropolis-Hastings提议的接受概率，然后实现一个程序来为特定测试用例计算该概率。\n\n### 第一部分：接受概率 $\\alpha(\\mathbf{x}, \\mathbf{y})$ 的推导\n\nMetropolis-Hastings算法旨在从目标概率分布 $\\pi(\\mathbf{s})$ 中抽样。其核心原理是细致平衡，它确保所构建的马尔可夫链的平稳分布确实是 $\\pi(\\mathbf{s})$。细致平衡条件指出，对于任意两个构型 $\\mathbf{x}$ 和 $\\mathbf{y}$，在平衡状态下，从 $\\mathbf{x}$ 到 $\\mathbf{y}$ 的跃迁速率必须等于从 $\\mathbf{y}$ 到 $\\mathbf{x}$ 的跃迁速率：\n$$\n\\pi(\\mathbf{x}) P(\\mathbf{x} \\to \\mathbf{y}) = \\pi(\\mathbf{y}) P(\\mathbf{y} \\to \\mathbf{x})\n$$\n其中 $P(\\mathbf{x} \\to \\mathbf{y})$ 是从构型 $\\mathbf{x}$ 到 $\\mathbf{y}$ 的总跃迁概率。\n\n跃迁概率由两个步骤组成：以概率 $q(\\mathbf{x} \\to \\mathbf{y})$ 从当前构型 $\\mathbf{x}$ 提议一个新构型 $\\mathbf{y}$，然后以概率 $\\alpha(\\mathbf{x}, \\mathbf{y})$ 接受该提议。因此，对于 $\\mathbf{x} \\ne \\mathbf{y}$：\n$$\nP(\\mathbf{x} \\to \\mathbf{y}) = q(\\mathbf{x} \\to \\mathbf{y}) \\alpha(\\mathbf{x}, \\mathbf{y})\n$$\n将此代入细致平衡方程可得：\n$$\n\\pi(\\mathbf{x}) q(\\mathbf{x} \\to \\mathbf{y}) \\alpha(\\mathbf{x}, \\mathbf{y}) = \\pi(\\mathbf{y}) q(\\mathbf{y} \\to \\mathbf{x}) \\alpha(\\mathbf{y}, \\mathbf{x})\n$$\nMetropolis-Hastings算法为满足此方程的接受概率提供了一个特定的选择。接受概率 $\\alpha(\\mathbf{x}, \\mathbf{y})$ 由以下公式给出：\n$$\n\\alpha(\\mathbf{x}, \\mathbf{y}) = \\min\\left(1, \\frac{\\pi(\\mathbf{y}) q(\\mathbf{y} \\to \\mathbf{x})}{\\pi(\\mathbf{x}) q(\\mathbf{x} \\to \\mathbf{y})}\\right)\n$$\n如果提议的移动被接受，则新构型为 $\\mathbf{y}$。如果被拒绝，则构型保持为 $\\mathbf{x}$。保持在 $\\mathbf{x}$ 的概率为 $P(\\mathbf{x} \\to \\mathbf{x}) = q(\\mathbf{x} \\to \\mathbf{x}) + \\sum_{\\mathbf{z} \\ne \\mathbf{x}} q(\\mathbf{x} \\to \\mathbf{z})(1 - \\alpha(\\mathbf{x}, \\mathbf{z}))$。\n\n现在，我们将问题中给出的 $\\pi(\\mathbf{s})$ 和 $q(\\mathbf{x} \\to \\mathbf{y})$ 的具体形式代入。\n\n目标分布是玻尔兹曼分布：\n$$\n\\pi(\\mathbf{s}) \\propto \\exp(-\\beta E(\\mathbf{s}))\n$$\n两个构型 $\\mathbf{y}$ 和 $\\mathbf{x}$ 的概率之比为：\n$$\n\\frac{\\pi(\\mathbf{y})}{\\pi(\\mathbf{x})} = \\frac{Z^{-1} \\exp(-\\beta E(\\mathbf{y}))}{Z^{-1} \\exp(-\\beta E(\\mathbf{x}))} = \\exp(-\\beta (E(\\mathbf{y}) - E(\\mathbf{x})))\n$$\n其中 $Z$ 是配分函数，它被消掉了。\n\n提议机制是群平均的均匀选择。对于给定构型 $\\mathbf{x}$，不同提议构型的集合是 $\\mathcal{O}_{\\mathbf{x}}$，它是通过对二面体群 $G$ 中的所有 $g$ 应用格点 $g(p_0)$ 和 $g(p_1)$ 之间的交换生成的。该集合的基数为 $k(\\mathbf{x}) = |\\mathcal{O}_{\\mathbf{x}}|$。以均匀概率提议一个构型 $\\mathbf{y} \\in \\mathcal{O}_{\\mathbf{x}}$：\n$$\nq(\\mathbf{x} \\to \\mathbf{y}) = \\begin{cases} 1/k(\\mathbf{x})  \\text{if } \\mathbf{y} \\in \\mathcal{O}_{\\mathbf{x}} \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n从 $\\mathbf{y}$ 到 $\\mathbf{x}$ 的逆向提议概率可以类似地定义：\n$$\nq(\\mathbf{y} \\to \\mathbf{x}) = \\begin{cases} 1/k(\\mathbf{y})  \\text{if } \\mathbf{x} \\in \\mathcal{O}_{\\mathbf{y}} \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n为了使从 $\\mathbf{x}$ 到 $\\mathbf{y}$（其中 $\\mathbf{x} \\ne \\mathbf{y}$）的跃迁的接受概率非零，我们必须有 $q(\\mathbf{x} \\to \\mathbf{y}) > 0$，这意味着 $\\mathbf{y} \\in \\mathcal{O}_{\\mathbf{x}}$。这意味着 $\\mathbf{y}$ 是通过交换 $\\mathbf{x}$ 中位于 $g(p_0)$ 和 $g(p_1)$ 格点上的组分（对于某个 $g \\in G$）得到的。此交换操作的逆操作可从 $\\mathbf{y}$ 恢复 $\\mathbf{x}$。这个逆操作本身就是在相同的两个格点 $g(p_0)$ 和 $g(p_1)$ 之间进行交换。由于这个交换模板是构型 $\\mathbf{y}$ 的提议之一（通过应用相同的 $g \\in G$），因此，如果 $\\mathbf{y} \\in \\mathcal{O}_{\\mathbf{x}}$，那么 $\\mathbf{x} \\in \\mathcal{O}_{\\mathbf{y}}$。所以，如果 $q(\\mathbf{x} \\to \\mathbf{y}) > 0$，则 $q(\\mathbf{y} \\to \\mathbf{x}) > 0$。\n\n因此，提议概率之比为：\n$$\n\\frac{q(\\mathbf{y} \\to \\mathbf{x})}{q(\\mathbf{x} \\to \\mathbf{y})} = \\frac{1/k(\\mathbf{y})}{1/k(\\mathbf{x})} = \\frac{k(\\mathbf{x})}{k(\\mathbf{y})}\n$$\n将 $\\pi$ 和 $q$ 的比率代入 $\\alpha(\\mathbf{x}, \\mathbf{y})$ 的表达式中，得到最终的推导表达式。对于从 $\\mathbf{x}$ 到 $\\mathbf{y} \\in \\mathcal{O}_{\\mathbf{x}}$ 的提议跃迁：\n$$\n\\alpha(\\mathbf{x}, \\mathbf{y}) = \\min\\left(1, \\exp(-\\beta (E(\\mathbf{y}) - E(\\mathbf{x}))) \\frac{k(\\mathbf{x})}{k(\\mathbf{y})}\\right)\n$$\n这是对于非平凡提议 $\\mathbf{y} \\ne \\mathbf{x}$ 的接受概率。问题陈述还规定，如果提议结果为 $\\mathbf{y} = \\mathbf{x}$，则接受概率为 $\\alpha(\\mathbf{x}, \\mathbf{x}) = 1$。\n\n### 第二部分：实现策略\n\n程序将按以下步骤构建以解决每个测试用例：\n\n1.  **构型设置**：对每个测试用例，解析输入：晶格尺寸 $L$、逆温度 $\\beta$、能量参数 $J$、构型字符串、模板交换格点 $p_0$ 和 $p_1$，以及特定的群元素索引 $g_{idx}$。构型字符串将被转换为一个 $L \\times L$ 的 NumPy 数组，其中组分 A 和 B 用整数表示（例如，A 为 $0$，B 为 $1$）。\n\n2.  **群操作**：一个函数将实现二面体群 $G$ 在晶格坐标 $(r, c)$ 上的 $8$ 种变换。该函数将接受一个坐标对、群操作索引（$0$ 到 $7$）和晶格尺寸 $L$ 作为输入，并返回变换后的坐标对。\n\n3.  **能量计算**：函数 `calculate_energy` 将计算给定构型的总能量 $E(\\mathbf{s})$。为避免重复计算键能，它将遍历每个格点 $(r, c)$，并将其与“右”邻居 $(r, (c+1) \\pmod L)$ 和“下”邻居 $((r+1) \\pmod L, c)$ 的键能贡献相加。如果键两端的组分不同，则贡献为 $J$，否则为 $0$。\n\n4.  **提议生成**：通过首先用给定的群元素 $g$ 变换模板格点 $p_0$ 和 $p_1$ 得到格点 $s_0 = g(p_0)$ 和 $s_1 = g(p_1)$，从初始构型 $\\mathbf{x}$ 生成特定的提议构型 $\\mathbf{y}$。然后，交换构型 $\\mathbf{x}$ 中格点 $s_0$ 和 $s_1$ 上的组分以产生构型 $\\mathbf{y}$。\n\n5.  **轨道基数计算**：一个辅助函数 `get_orbit_cardinality` 将为任何构型 $\\mathbf{s}$ 计算 $k(\\mathbf{s})$。它将通过以下方式实现：\n    a. 初始化一个空集合来存储唯一的构型。\n    b. 遍历所有 $8$ 个群元素 $g_i \\in G$。\n    c. 对于每个 $g_i$，它计算交换格点 $g_i(p_0)$ 和 $g_i(p_1)$。\n    d. 它在构型 $\\mathbf{s}$ 的副本上执行交换以生成提议构型 $\\mathbf{s}'$。\n    e. 为了使 NumPy 数组可哈希以便存入集合，它被转换为元组的元组。\n    f. 将可哈希的构型添加到集合中。使用集合会自动处理去重。\n    g. 基数 $k(\\mathbf{s})$ 是此集合的最终大小。\n\n6.  **接受概率计算**：\n    a. 程序首先检查 $\\mathbf{y}$ 是否与 $\\mathbf{x}$ 相同。如果被交换的格点 $s_0$ 和 $s_1$ 上的组分相同，就会发生这种情况。若是如此，根据问题定义，$\\alpha(\\mathbf{x}, \\mathbf{y}) = 1.0$。\n    b. 如果 $\\mathbf{y} \\ne \\mathbf{x}$，程序使用上述函数计算 $E(\\mathbf{x})$、$E(\\mathbf{y})$、$k(\\mathbf{x})$ 和 $k(\\mathbf{y})$。\n    c. 最后，它使用推导出的公式计算 $\\alpha(\\mathbf{x}, \\mathbf{y})$：$\\min(1, \\exp(-\\beta(E(\\mathbf{y}) - E(\\mathbf{x}))) \\cdot k(\\mathbf{x}) / k(\\mathbf{y}))$。\n\n7.  **输出格式化**：每个测试用例计算出的接受概率被四舍五入到 $8$ 位小数并存储。最终输出是包含这些值的单行，形式为用方括号括起来的逗号分隔列表。\n\n这种结构化的方法确保了问题的所有组成部分都根据指定的物理和算法原理得到正确实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, beta, J, config_str, p0, p1, g_idx)\n        (3, 0.7, 1.0, \"ABABABABA\", (0, 0), (1, 0), 1),\n        (3, 0.9, 1.0, \"AAAABAAAA\", (0, 0), (1, 0), 6),\n        (4, 0.5, 1.0, \"ABABBBAAAABBBABA\", (0, 0), (1, 0), 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, beta, J, config_str, p0, p1, g_idx = case\n        \n        # Mapping from species character to integer\n        species_map = {'A': 0, 'B': 1}\n        \n        # 1. Configuration Setup\n        x_config_flat = np.array([species_map[c] for c in config_str])\n        x_config = x_config_flat.reshape((L, L))\n        \n        # 2. Group Operations\n        group_ops = get_group_operations(L)\n        \n        # 3. Proposal Generation\n        s0 = group_ops[g_idx](p0)\n        s1 = group_ops[g_idx](p1)\n        \n        y_config = np.copy(x_config)\n        \n        # Check if proposed swap is non-trivial\n        if x_config[s0] != x_config[s1]:\n            y_config[s0], y_config[s1] = y_config[s1], y_config[s0]\n        \n        # 4. Acceptance Probability Calculation\n        \n        # Handle trivial case y = x\n        if np.array_equal(x_config, y_config):\n            alpha = 1.0\n        else:\n            # Calculate energies\n            E_x = calculate_energy(x_config, J, L)\n            E_y = calculate_energy(y_config, J, L)\n            \n            # Calculate orbit cardinalities\n            k_x = get_orbit_cardinality(x_config, p0, p1, L, group_ops)\n            k_y = get_orbit_cardinality(y_config, p0, p1, L, group_ops)\n            \n            # Use derived formula for alpha\n            ratio = (k_x / k_y) if k_y > 0 else 0 \n            alpha = min(1.0, np.exp(-beta * (E_y - E_x)) * ratio)\n            \n        results.append(round(alpha, 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\ndef get_group_operations(L):\n    \"\"\"\n    Returns a list of lambda functions for the 8 dihedral group operations on a square lattice.\n    \"\"\"\n    L_minus_1 = L - 1\n    return [\n        lambda p: (p[0], p[1]),                                       # 0: identity\n        lambda p: (p[1], L_minus_1 - p[0]),                           # 1: rot90\n        lambda p: (L_minus_1 - p[0], L_minus_1 - p[1]),               # 2: rot180\n        lambda p: (L_minus_1 - p[1], p[0]),                           # 3: rot270\n        lambda p: (p[0], L_minus_1 - p[1]),                           # 4: reflection vertical\n        lambda p: (L_minus_1 - p[0], p[1]),                           # 5: reflection horizontal\n        lambda p: (p[1], p[0]),                                       # 6: reflection main diagonal\n        lambda p: (L_minus_1 - p[1], L_minus_1 - p[0]),               # 7: reflection anti-diagonal\n    ]\n\ndef calculate_energy(config, J, L):\n    \"\"\"\n    Calculates the total energy of a configuration using periodic boundary conditions.\n    \"\"\"\n    energy = 0.0\n    for r in range(L):\n        for c in range(L):\n            # Bond with right neighbor\n            c_right = (c + 1) % L\n            if config[r, c] != config[r, c_right]:\n                energy += J\n            # Bond with bottom neighbor\n            r_down = (r + 1) % L\n            if config[r, c] != config[r_down, c]:\n                energy += J\n    # The problem statement says \"sum over each unordered nearest-neighbor bond exactly once\".\n    # My loop counts each bond twice (once from each side, e.g. (r,c) looks at (r,c+1) and (r,c+1) looks at (r,c)).\n    # However, the problem statement also says \"each site has exactly four neighbors\".\n    # The energy summation in the problem is $J \\sum_{\\langle i,j \\rangle} \\mathbf{1}[s_i \\ne s_j]$.\n    # The standard physics definition counts each bond once. My code counts each site's contribution.\n    # Total number of bonds is $2L^2$ for a periodic lattice. My code sums over $2L^2$ half-bonds.\n    # So `energy / 2` is the correct energy according to the standard physics definition.\n    # Let's re-read the problem: \"the summation counts each unordered nearest-neighbor bond exactly once\".\n    # So, yes, my loop double-counts. The result should be divided by 2.\n    return energy / 2.0\n\ndef get_orbit_cardinality(config, p0, p1, L, group_ops):\n    \"\"\"\n    Calculates the cardinality of the set of distinct configurations generated by group-averaged swaps.\n    \"\"\"\n    orbit_configs = set()\n    for g_op in group_ops:\n        temp_config = np.copy(config)\n        \n        # Get swap sites for this group operation\n        sp0 = g_op(p0)\n        sp1 = g_op(p1)\n        \n        # Perform swap\n        if temp_config[sp0] != temp_config[sp1]:\n            temp_config[sp0], temp_config[sp1] = temp_config[sp1], temp_config[sp0]\n\n        # Add a hashable representation of the config to the set\n        orbit_configs.add(temp_config.tobytes())\n        \n    return len(orbit_configs)\n\nsolve()\n```"
        }
    ]
}