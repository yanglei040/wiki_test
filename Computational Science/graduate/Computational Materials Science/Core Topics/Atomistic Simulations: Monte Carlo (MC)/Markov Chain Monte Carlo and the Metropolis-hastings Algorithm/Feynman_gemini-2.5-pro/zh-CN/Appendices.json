{
    "hands_on_practices": [
        {
            "introduction": "MCMC抽样的有效性取决于一些基本属性，例如不可约性（irreducibility），它保证了模拟能够访问所有相关的状态。本练习将探讨当不可约性被蓄意破坏时会发生什么。通过在一个简单的伊辛模型中分析一个有缺陷的提议机制，您将对遍历性（ergodicity）为何至关重要，以及它的失效如何导致从一个不正确的、受限的分布中抽样，获得更深刻、更具体的理解。",
            "id": "3463572",
            "problem": "考虑一个具有 $N=4$ 个格点的一维周期性伊辛晶格，该模型模拟一个环上的二元合金，其中自旋变量 $s_i \\in \\{-1,+1\\}$ 代表格点 $i$ 处的局域物种状态。一个构型 $\\mathbf{s} = (s_1,s_2,s_3,s_4)$ 的能量由带有外场的最近邻伊辛哈密顿量给出，\n$$\nE(\\mathbf{s}) = - J \\left( s_1 s_2 + s_2 s_3 + s_3 s_4 + s_4 s_1 \\right) - h \\left( s_1 + s_2 + s_3 + s_4 \\right),\n$$\n其中 $J$ 和 $h$ 分别是依赖于材料的相互作用参数和场参数，$\\beta$ 是逆热能，$\\beta = 1/(k_B T)$，其中 $k_B$ 是玻尔兹曼常数，$T$ 是温度。用于抽样平衡构型的目标分布是玻尔兹曼分布\n$$\n\\pi(\\mathbf{s}) \\propto \\exp\\!\\left( - \\beta E(\\mathbf{s}) \\right).\n$$\n使用带有 Metropolis-Hastings (MH) 算法的马尔可夫链蒙特卡洛 (MCMC) 方法从 $\\pi(\\mathbf{s})$ 中抽样。提议核定义如下：在每一步中，从集合 $\\{2,4\\}$ 中均匀随机选择一个偶数索引的格点并翻转其自旋，而奇数索引的自旋从不被提议改变。这个提议局部上遵守细致平衡，但在整个构型空间上违反了不可约性。\n\n从奇数自旋固定为 $s_1 = +1$ 和 $s_3 = -1$ 的初始构型开始，执行以下任务：\n\n- 根据马尔可夫链的不可约性和细致平衡的定义，解释为什么这个提议会导出闭的互通类，并确定由奇数自旋约束 $s_1 = +1$ 和 $s_3 = -1$ 决定的闭类。\n- 推导 MH 链收敛到的、支撑在该闭类上的平稳分布，并将其表示为在固定奇数自旋条件下的玻尔兹曼分布。\n- 计算从给定的奇数自旋约束开始，该链无法达到的目标玻尔兹曼概率质量的确切分数，即 1 减去在目标分布 $\\pi(\\mathbf{s})$ 下该闭类的总条件概率质量。\n\n你的最终答案必须是仅含 $\\beta$、$J$ 和 $h$ 的单个闭式解析表达式。这个量是无量纲的；请用无单位的形式表示你的答案。不要近似；不需要四舍五入。",
            "solution": "所述问题具有科学依据、问题明确、客观，并包含唯一解所需的所有必要信息。这是统计力学和马尔可夫链蒙特卡洛方法中的一个标准练习，旨在检验可约马尔可夫链的后果。因此，该问题被认为是有效的，完整的解答如下。\n\n问题要求完成三个相关的任务，这些任务涉及一个应用于具有 $N=4$ 个格点的一维周期性伊辛模型的非标准提议机制的 Metropolis-Hastings (MH) 算法。我们将按顺序处理每个任务。\n\n首先，我们分析由提议核导出的马尔可夫链的结构。系统的状态空间是所有可能的自旋构型 $\\mathbf{s}=(s_1,s_2,s_3,s_4)$ 的集合，其中 $s_i \\in \\{-1, +1\\}$。这总共给出了 $2^4 = 16$ 个可能的状态。提议规则规定，在每一步中，从集合 $\\{2, 4\\}$ 中均匀随机地选择一个格点并翻转其自旋。奇数索引格点上的自旋 $s_1$ 和 $s_3$ 从不被提议改变。\n\n如果一个马尔可夫链中，可以从任何状态转移到任何其他状态（不一定是一步），则称该链是**不可约的**。给定的提议机制违反了这一性质。如果链从一个具有特定 $(s_1, s_3)$ 值对（比如 $(s_1^*, s_3^*)$）的状态开始，则该链生成的任何后续状态的奇数索引自旋也将固定为 $(s_1^*, s_3^*)$。不可能转移到一个具有不同奇数索引自旋对的状态，例如 $(s_1', s_3')$，其中 $(s_1', s_3') \\neq (s_1^*, s_3^*)$。\n\n这种限制将总状态空间 $\\mathcal{S}$ 分割成四个不相交的子集，每个子集对应于 $(s_1, s_3)$ 的一种可能值对：$\\{(+1, +1), (+1, -1), (-1, +1), (-1, -1)\\}$。在每个这样的子集内部，任何状态都可以从任何其他状态到达。例如，在 $s_1$ 和 $s_3$ 固定的子集中，任何 $(s_2, s_4)$ 的构型都可以从任何其他构型到达。通过翻转 $s_2$ 可以实现从 $(s_2, s_4)$ 到 $(-s_2, s_4)$ 的转移，而通过先翻转 $s_2$ 再翻转 $s_4$ 可以实现到 $(-s_2, -s_4)$ 的转移。根据 MH 规则，这些转移以某个非零概率被接受。因此，这样一个子集内的所有状态形成一个**互通类**。由于这些类之间不可能发生转移，所以每个类都是**闭的**。\n\n问题指定了一个初始约束，其中奇数自旋固定为 $s_1 = +1$ 和 $s_3 = -1$。由该约束决定的闭互通类是所有 $s_1=+1$ 和 $s_3=-1$ 的状态 $\\mathbf{s}$ 的集合，而 $s_2$ 和 $s_4$ 可以是 $+1$ 或 $-1$。我们用 $\\mathcal{C}_{1,-1}$ 表示这个类。它包含以下四个状态：\n$\\mathcal{C}_{1,-1} = \\{ (+1, +1, -1, +1), (+1, +1, -1, -1), (+1, -1, -1, +1), (+1, -1, -1, -1) \\}$。\n\n第二，我们推导当马尔可夫链被限制在这个闭类 $\\mathcal{C}_{1,-1}$ 上时的平稳分布。MH 算法的构建是为了满足相对于目标玻尔兹曼分布 $\\pi(\\mathbf{s}) \\propto \\exp(-\\beta E(\\mathbf{s}))$ 的细致平衡条件。该条件是对于任意两个状态 $\\mathbf{s}, \\mathbf{s}'$，有 $\\pi(\\mathbf{s}) P(\\mathbf{s} \\to \\mathbf{s}') = \\pi(\\mathbf{s}') P(\\mathbf{s}' \\to \\mathbf{s})$。当一个满足相对于分布 $\\pi$ 的细致平衡的马尔可夫链是可约的时，其动态演化一旦被限制在一个闭类 $\\mathcal{C}$ 中，将会收敛到一个平稳分布 $\\pi_{\\text{cond}}$，该分布是 $\\pi$ 限制在 $\\mathcal{C}$ 上的条件分布。\n对于任何状态 $\\mathbf{s} \\in \\mathcal{C}_{1,-1}$，这个平稳分布由下式给出：\n$$\n\\pi_{\\text{cond}}(\\mathbf{s}) = \\frac{\\pi(\\mathbf{s})}{\\sum_{\\mathbf{s}' \\in \\mathcal{C}_{1,-1}} \\pi(\\mathbf{s}')} = \\frac{\\exp(-\\beta E(\\mathbf{s}))}{\\sum_{\\mathbf{s}' \\in \\mathcal{C}_{1,-1}} \\exp(-\\beta E(\\mathbf{s}'))}\n$$\n这是在奇数自旋 $s_1=+1$ 和 $s_3=-1$ 固定条件下的玻尔兹曼分布。\n\n第三，我们计算从给定约束开始，链无法达到的目标玻尔兹曼概率质量的分数。这个分数是 1 减去可达类 $\\mathcal{C}_{1,-1}$ 的总概率质量。$\\mathcal{C}_{1,-1}$ 的总概率质量是其内部所有状态在完整玻尔兹曼分布 $\\pi(\\mathbf{s}) = \\exp(-\\beta E(\\mathbf{s}))/Z$ 下的概率之和，其中 $Z$ 是对所有 16 个状态求和的完整配分函数。\n$$\nP(\\mathcal{C}_{1,-1}) = \\sum_{\\mathbf{s} \\in \\mathcal{C}_{1,-1}} \\pi(\\mathbf{s}) = \\frac{\\sum_{\\mathbf{s} \\in \\mathcal{C}_{1,-1}} \\exp(-\\beta E(\\mathbf{s}))}{\\sum_{\\mathbf{s} \\in \\mathcal{S}} \\exp(-\\beta E(\\mathbf{s}))} = \\frac{Z_{1,-1}}{Z}\n$$\n因此，不可达质量分数为 $1 - P(\\mathcal{C}_{1,-1}) = 1 - \\frac{Z_{1,-1}}{Z}$。\n\n我们必须计算部分配分函数 $Z_{1,-1}$ 和完整配分函数 $Z$。\n哈密顿量为 $E(\\mathbf{s}) = - J \\left( s_1 s_2 + s_2 s_3 + s_3 s_4 + s_4 s_1 \\right) - h \\left( s_1 + s_2 + s_3 + s_4 \\right)$。\n对于类 $\\mathcal{C}_{1,-1}$，我们固定 $s_1=+1$ 和 $s_3=-1$。能量变为：\n$E(\\mathbf{s}) = -J((+1)s_2 + s_2(-1) + (-1)s_4 + s_4(+1)) - h((+1) + s_2 + (-1) + s_4) = -J(0) - h(s_2+s_4) = -h(s_2+s_4)$。\n我们对 $\\mathcal{C}_{1,-1}$ 中的四个状态求和 $\\exp(-\\beta E(\\mathbf{s}))$，这四个状态对应于 $(s_2,s_4)$ 对 $(+1,+1), (+1,-1), (-1,+1), (-1,-1)$。能量分别为 $-2h, 0, 0, 2h$。\n$Z_{1,-1} = \\exp(2\\beta h) + \\exp(0) + \\exp(0) + \\exp(-2\\beta h) = \\exp(2\\beta h) + \\exp(-2\\beta h) + 2 = 2\\cosh(2\\beta h) + 2$。\n\n接下来，我们计算完整配分函数 $Z$。我们可以通过对所有 16 种构型按能量分类求和来完成。\n不同的能级及其简并度是：\n\\begin{itemize}\n    \\item $k=4$ 个正自旋：$1$ 个状态 $(1,1,1,1)$；$E = -4J-4h$。\n    \\item $k=0$ 个正自旋：$1$ 个状态 $(-1,-1,-1,-1)$；$E = -4J+4h$。\n    \\item $k=3$ 个正自旋：$4$ 个状态，如 $(1,1,1,-1)$；$E = -2h$。\n    \\item $k=1$ 个正自旋：$4$ 个状态，如 $(1,-1,-1,-1)$；$E = 2h$。\n    \\item $k=2$ 个正自旋，交替排列如 $(1,-1,1,-1)$：$2$ 个状态；$E = 4J$。\n    \\item $k=2$ 个正自旋，相邻排列如 $(1,1,-1,-1)$：$4$ 个状态；$E = 0$。\n\\end{itemize}\n对所有 16 个状态的玻尔兹曼因子求和：\n$Z = \\exp(-\\beta(-4J-4h)) + \\exp(-\\beta(-4J+4h)) + 4\\exp(-\\beta(-2h)) + 4\\exp(-\\beta(2h)) + 2\\exp(-\\beta(4J)) + 4\\exp(0)$。\n$Z = \\exp(4\\beta J + 4\\beta h) + \\exp(4\\beta J - 4\\beta h) + 4\\exp(2\\beta h) + 4\\exp(-2\\beta h) + 2\\exp(-4\\beta J) + 4$。\n我们可以对各项进行分组：\n$Z = \\exp(4\\beta J)[\\exp(4\\beta h) + \\exp(-4\\beta h)] + 4[\\exp(2\\beta h) + \\exp(-2\\beta h)] + 2\\exp(-4\\beta J) + 4$。\n$Z = 2\\exp(4\\beta J)\\cosh(4\\beta h) + 8\\cosh(2\\beta h) + 2\\exp(-4\\beta J) + 4$。\n\n不可达质量的分数为 $1 - \\frac{Z_{1,-1}}{Z}$：\n$$\n\\text{分数} = 1 - \\frac{2\\cosh(2\\beta h) + 2}{2\\exp(4\\beta J)\\cosh(4\\beta h) + 8\\cosh(2\\beta h) + 2\\exp(-4\\beta J) + 4}\n$$\n这可以写作 $\\frac{Z - Z_{1,-1}}{Z}$：\n$$\n\\text{分数} = \\frac{(2\\exp(4\\beta J)\\cosh(4\\beta h) + 8\\cosh(2\\beta h) + 2\\exp(-4\\beta J) + 4) - (2\\cosh(2\\beta h) + 2)}{2\\exp(4\\beta J)\\cosh(4\\beta h) + 8\\cosh(2\\beta h) + 2\\exp(-4\\beta J) + 4}\n$$\n$$\n\\text{分数} = \\frac{2\\exp(4\\beta J)\\cosh(4\\beta h) + 6\\cosh(2\\beta h) + 2\\exp(-4\\beta J) + 2}{2\\exp(4\\beta J)\\cosh(4\\beta h) + 8\\cosh(2\\beta h) + 2\\exp(-4\\beta J) + 4}\n$$\n将分子和分母同除以 $2$ 得到最终表达式：\n$$\n\\text{分数} = \\frac{\\exp(4\\beta J)\\cosh(4\\beta h) + 3\\cosh(2\\beta h) + \\exp(-4\\beta J) + 1}{\\exp(4\\beta J)\\cosh(4\\beta h) + 4\\cosh(2\\beta h) + \\exp(-4\\beta J) + 2}\n$$",
            "answer": "$$\\boxed{\\frac{\\exp(4\\beta J)\\cosh(4\\beta h) + 3\\cosh(2\\beta h) + \\exp(-4\\beta J) + 1}{\\exp(4\\beta J)\\cosh(4\\beta h) + 4\\cosh(2\\beta h) + \\exp(-4\\beta J) + 2}}$$"
        },
        {
            "introduction": "标准的随机游走提议可能效率低下，先进的MCMC方法通常会结合系统的物理知识来设计更优的移动策略。本练习将引入一个强大的概念：利用群论来设计对称化提议，使其尊重材料潜在的晶格不变性。这个问题结合了理论推导与实际编程，您将首先为非对称的群平均提议推导正确的Metropolis-Hastings接受率，然后在代码中应用它，从而掌握能够显著加速晶体材料模拟收敛的高级算法设计技巧。",
            "id": "3463637",
            "problem": "您正在使用马尔可夫链蒙特卡洛（MCMC）方法，特别是Metropolis-Hastings（MH）算法，研究方形晶格上的二元合金无序。构型空间由所有将双元素集合中的物种标签分配给晶格位置的构型组成。考虑一个尺寸为 $L \\times L$、具有周期性边界条件的方形晶格。设构型用 $\\mathbf{s}$ 表示，其中每个位置 $i$ 上的物种为 $s_{i} \\in \\{\\text{A}, \\text{B}\\}$。目标分布由玻尔兹曼权重 $\\pi(\\mathbf{s}) \\propto \\exp(-\\beta E(\\mathbf{s}))$ 定义，其中 $\\beta  0$ 是逆温度，$E(\\mathbf{s})$ 是构型能量。使用最近邻键能\n$$\nE(\\mathbf{s}) \\;=\\; J \\sum_{\\langle i,j \\rangle} \\mathbf{1}[s_i \\ne s_j],\n$$\n其中求和遍历每个无序最近邻键恰好一次，$\\mathbf{1}[\\cdot]$ 是指示函数。假设 $\\beta$ 和 $J$ 是给定的正实数。\n\n您需要设计一种通过在正方形的二面体群上进行对称化来保持晶格点群不变性的提议。设 $G$ 表示方形晶格的点群（二面体群），其大小为 $|G| = 8$，由单位元、旋转 $90^{\\circ}$、$180^{\\circ}$ 和 $270^{\\circ}$，以及关于垂直轴、水平轴、主对角线和副对角线的反射组成。定义一个原始交换移动模板，该模板交换两个固定晶格位置 $p_0$ 和 $p_1$（这些是晶格坐标）上的物种。对于任何 $g \\in G$，定义一个群变换移动，该移动交换位置 $g(p_0)$ 和 $g(p_1)$ 上的物种。\n\n我们不直接从单个群元素进行提议，而是如下定义群平均提议机制。对于给定的当前构型 $\\mathbf{x}$，考虑对所有 $g \\in G$ 应用 $g(p_0)$ 和 $g(p_1)$ 处的交换所获得的、按构型相等性去重的不同提议构型集合。将此去重后的集合表示为 $\\mathcal{O}_{\\mathbf{x}}$，其基数表示为 $k(\\mathbf{x}) = |\\mathcal{O}_{\\mathbf{x}}|$。该提议从 $\\mathcal{O}_{\\mathbf{x}}$ 的元素中均匀选择，因此提议质量函数 $q(\\mathbf{x} \\to \\mathbf{y})$ 对于 $\\mathbf{y} \\in \\mathcal{O}_{\\mathbf{x}}$ 等于 $1/k(\\mathbf{x})$，否则等于 $0$。\n\n任务：\n1. 从细致平衡的定义和Metropolis-Hastings接受机制的构建出发，并且仅使用目标密度为 $\\pi(\\mathbf{s}) \\propto \\exp(-\\beta E(\\mathbf{s}))$ 以及提议是上述定义的群平均均匀机制这一基本事实，推导从 $\\mathbf{x}$ 到 $\\mathbf{y} \\in \\mathcal{O}_{\\mathbf{x}}$ 的提议转移的接受概率 $\\alpha(\\mathbf{x}, \\mathbf{y})$，用 $E(\\cdot)$、$\\beta$、$k(\\mathbf{x})$ 和 $k(\\mathbf{y})$ 表示。您的推导必须从细致平衡原理开始，不得假设接受概率已有的封闭形式。\n2. 实现一个程序，对于下面定义的每个测试用例，构建晶格，使用周期性边界条件计算能量 $E(\\mathbf{s})$，通过将指定的单个群元素 $g$ 应用于模板对 $(p_0, p_1)$ 并交换得到的两个位置来构建提议构型 $\\mathbf{y}$，枚举群平均轨道集 $\\mathcal{O}_{\\mathbf{x}}$ 和 $\\mathcal{O}_{\\mathbf{y}}$，然后使用您推导的表达式计算接受概率 $\\alpha(\\mathbf{x}, \\mathbf{y})$。如果 $\\mathbf{y} = \\mathbf{x}$，则定义 $\\alpha(\\mathbf{x}, \\mathbf{y}) = 1$。\n\n晶格坐标以零为基的索引 $(r, c)$ 给出，$r \\in \\{0,\\dots,L-1\\}$，$c \\in \\{0,\\dots,L-1\\}$。群 $G$ 通过以下从 $0$ 到 $7$ 索引的八个操作作用于坐标：\n- $0$：单位元，$(r,c) \\mapsto (r,c)$，\n- $1$：旋转 $90^{\\circ}$，$(r,c) \\mapsto (c, L - 1 - r)$，\n- $2$：旋转 $180^{\\circ}$，$(r,c) \\mapsto (L - 1 - r, L - 1 - c)$，\n- $3$：旋转 $270^{\\circ}$，$(r,c) \\mapsto (L - 1 - c, r)$，\n- $4$：关于垂直轴反射，$(r,c) \\mapsto (r, L - 1 - c)$，\n- $5$：关于水平轴反射，$(r,c) \\mapsto (L - 1 - r, c)$，\n- $6$：关于主对角线反射，$(r,c) \\mapsto (c, r)$，\n- $7$：关于副对角线反射，$(r,c) \\mapsto (L - 1 - c, L - 1 - r)$。\n\n构型被指定为一个长度为 $L^2$、字母表为 $\\{\\text{A}, \\text{B}\\}$ 的行主序字符串。能量计算使用周期性邻居，以便每个位置都有四个邻居，但在定义 $E(\\mathbf{s})$ 的求和中每个键只计算一次。\n\n测试套件：\n- 测试用例 1：$L = 3$，$\\beta = 0.7$，$J = 1.0$，构型字符串 \"ABABABABA\"（行主序，对应行为 \"ABA\"、\"BAB\"、\"ABA\"），模板 $p_0 = (0,0)$，$p_1 = (1,0)$，群元素索引 $g = 1$。\n- 测试用例 2：$L = 3$，$\\beta = 0.9$，$J = 1.0$，构型字符串 \"AAAABAAAA\"（行主序，对应行为 \"AAA\"、\"ABA\"、\"AAA\"），模板 $p_0 = (0,0)$，$p_1 = (1,0)$，群元素索引 $g = 6$。\n- 测试用例 3：$L = 4$，$\\beta = 0.5$，$J = 1.0$，构型字符串 \"ABABBBAAAABBBABA\"（行主序，对应行为 \"ABAB\"、\"BBAA\"、\"AABB\"、\"BABA\"），模板 $p_0 = (0,0)$，$p_1 = (1,0)$，群元素索引 $g = 4$。\n\n您的程序必须：\n- 对于每个测试用例，从字符串构建 $\\mathbf{x}$，通过将指定的 $g$ 应用于 $(p_0, p_1)$ 并在 $\\mathbf{x}$ 中交换得到的两个位置来构建 $\\mathbf{y}$，通过应用所有 $|G| = 8$ 个群操作并按构型相等性去重来枚举 $\\mathcal{O}_{\\mathbf{x}}$ 和 $\\mathcal{O}_{\\mathbf{y}}$，计算 $E(\\mathbf{x})$ 和 $E(\\mathbf{y})$，然后使用您基于细致平衡推导的表达式计算 $\\alpha(\\mathbf{x}, \\mathbf{y})$。\n- 生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如“[0.12345678,0.23456789,0.34567890]”。将每个浮点数接受概率四舍五入到恰好 $8$ 位小数。\n\n您的最终输出必须是与上述三个测试用例相对应的三个浮点值的列表，顺序如上所述。不涉及物理单位，角度仅作为群操作的一部分隐式给出；不需要角度单位。最终输出格式严格为上述单行格式。",
            "solution": "该问题要求我们首先推导群平均 Metropolis-Hastings 提议的接受概率，然后实现一个程序来为特定测试用例计算该概率。\n\n### 第1部分：接受概率 $\\alpha(\\mathbf{x}, \\mathbf{y})$ 的推导\n\nMetropolis-Hastings 算法旨在从目标概率分布 $\\pi(\\mathbf{s})$ 中采样。其核心原理是细致平衡，它确保所构建的马尔可夫链的稳态分布确实是 $\\pi(\\mathbf{s})$。细致平衡条件指出，对于任意两个构型 $\\mathbf{x}$ 和 $\\mathbf{y}$，在平衡状态下，从 $\\mathbf{x}$ 到 $\\mathbf{y}$ 的转移速率必须等于从 $\\mathbf{y}$ 到 $\\mathbf{x}$ 的转移速率：\n$$\n\\pi(\\mathbf{x}) P(\\mathbf{x} \\to \\mathbf{y}) = \\pi(\\mathbf{y}) P(\\mathbf{y} \\to \\mathbf{x})\n$$\n其中 $P(\\mathbf{x} \\to \\mathbf{y})$ 是从构型 $\\mathbf{x}$ 到 $\\mathbf{y}$ 的总转移概率。\n\n转移概率由两步组成：以概率 $q(\\mathbf{x} \\to \\mathbf{y})$ 从当前构型 $\\mathbf{x}$ 提议一个新构型 $\\mathbf{y}$，然后以概率 $\\alpha(\\mathbf{x}, \\mathbf{y})$ 接受此提议。因此，对于 $\\mathbf{x} \\ne \\mathbf{y}$：\n$$\nP(\\mathbf{x} \\to \\mathbf{y}) = q(\\mathbf{x} \\to \\mathbf{y}) \\alpha(\\mathbf{x}, \\mathbf{y})\n$$\n将此代入细致平衡方程，得到：\n$$\n\\pi(\\mathbf{x}) q(\\mathbf{x} \\to \\mathbf{y}) \\alpha(\\mathbf{x}, \\mathbf{y}) = \\pi(\\mathbf{y}) q(\\mathbf{y} \\to \\mathbf{x}) \\alpha(\\mathbf{y}, \\mathbf{x})\n$$\nMetropolis-Hastings 算法为接受概率提供了一个满足此方程的特定选择。接受概率 $\\alpha(\\mathbf{x}, \\mathbf{y})$ 由以下公式给出：\n$$\n\\alpha(\\mathbf{x}, \\mathbf{y}) = \\min\\left(1, \\frac{\\pi(\\mathbf{y}) q(\\mathbf{y} \\to \\mathbf{x})}{\\pi(\\mathbf{x}) q(\\mathbf{x} \\to \\mathbf{y})}\\right)\n$$\n如果提议的移动被接受，新构型为 $\\mathbf{y}$。如果被拒绝，构型保持为 $\\mathbf{x}$。保持在 $\\mathbf{x}$ 的概率是 $P(\\mathbf{x} \\to \\mathbf{x}) = q(\\mathbf{x} \\to \\mathbf{x}) + \\sum_{\\mathbf{z} \\ne \\mathbf{x}} q(\\mathbf{x} \\to \\mathbf{z})(1 - \\alpha(\\mathbf{x}, \\mathbf{z}))$。\n\n现在，我们将问题中给出的 $\\pi(\\mathbf{s})$ 和 $q(\\mathbf{x} \\to \\mathbf{y})$ 的具体形式代入。\n\n目标分布是玻尔兹曼分布：\n$$\n\\pi(\\mathbf{s}) \\propto \\exp(-\\beta E(\\mathbf{s}))\n$$\n两个构型 $\\mathbf{y}$ 和 $\\mathbf{x}$ 的概率比为：\n$$\n\\frac{\\pi(\\mathbf{y})}{\\pi(\\mathbf{x})} = \\frac{Z^{-1} \\exp(-\\beta E(\\mathbf{y}))}{Z^{-1} \\exp(-\\beta E(\\mathbf{x}))} = \\exp(-\\beta (E(\\mathbf{y}) - E(\\mathbf{x})))\n$$\n其中 $Z$ 是配分函数，它被消掉了。\n\n提议机制是群平均均匀选择。对于给定构型 $\\mathbf{x}$，不同的提议构型集合是 $\\mathcal{O}_{\\mathbf{x}}$，通过对二面体群 $G$ 中所有的 $g$ 应用位置 $g(p_0)$ 和 $g(p_1)$ 之间的交换生成。该集合的基数为 $k(\\mathbf{x}) = |\\mathcal{O}_{\\mathbf{x}}|$。以均匀概率提议一个构型 $\\mathbf{y} \\in \\mathcal{O}_{\\mathbf{x}}$：\n$$\nq(\\mathbf{x} \\to \\mathbf{y}) = \\begin{cases} 1/k(\\mathbf{x})  \\text{if } \\mathbf{y} \\in \\mathcal{O}_{\\mathbf{x}} \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n从 $\\mathbf{y}$ 到 $\\mathbf{x}$ 的逆向提议概率可类似地定义为：\n$$\nq(\\mathbf{y} \\to \\mathbf{x}) = \\begin{cases} 1/k(\\mathbf{y})  \\text{if } \\mathbf{x} \\in \\mathcal{O}_{\\mathbf{y}} \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n对于一个转移 $\\mathbf{x} \\to \\mathbf{y}$（其中 $\\mathbf{x} \\ne \\mathbf{y}$），要使其接受概率非零，我们必须有 $q(\\mathbf{x} \\to \\mathbf{y}) > 0$，这意味着 $\\mathbf{y} \\in \\mathcal{O}_{\\mathbf{x}}$。这意味着 $\\mathbf{y}$ 是通过交换 $\\mathbf{x}$ 中位置 $g(p_0)$ 和 $g(p_1)$ 处的物种得到的，其中 $g \\in G$。此交换操作的逆操作可将 $\\mathbf{y}$ 恢复为 $\\mathbf{x}$。这个逆操作本身是相同两个位置 $g(p_0)$ 和 $g(p_1)$ 之间的交换。由于此交换模板是来自构型 $\\mathbf{y}$ 的提议之一（通过应用相同的 $g \\in G$），因此可以得出，如果 $\\mathbf{y} \\in \\mathcal{O}_{\\mathbf{x}}$，那么 $\\mathbf{x} \\in \\mathcal{O}_{\\mathbf{y}}$。因此，如果 $q(\\mathbf{x} \\to \\mathbf{y}) > 0$，那么 $q(\\mathbf{y} \\to \\mathbf{x}) > 0$。\n\n因此，提议概率的比值为：\n$$\n\\frac{q(\\mathbf{y} \\to \\mathbf{x})}{q(\\mathbf{x} \\to \\mathbf{y})} = \\frac{1/k(\\mathbf{y})}{1/k(\\mathbf{x})} = \\frac{k(\\mathbf{x})}{k(\\mathbf{y})}\n$$\n将 $\\pi$ 和 $q$ 的比率代入 $\\alpha(\\mathbf{x}, \\mathbf{y})$ 的表达式中，即可得到最终的推导结果。对于从 $\\mathbf{x}$ 到 $\\mathbf{y} \\in \\mathcal{O}_{\\mathbf{x}}$ 的提议转移：\n$$\n\\alpha(\\mathbf{x}, \\mathbf{y}) = \\min\\left(1, \\frac{\\pi(\\mathbf{y})}{\\pi(\\mathbf{x})} \\frac{q(\\mathbf{y} \\to \\mathbf{x})}{q(\\mathbf{x} \\to \\mathbf{y})}\\right) = \\min\\left(1, \\exp(-\\beta (E(\\mathbf{y}) - E(\\mathbf{x}))) \\frac{k(\\mathbf{x})}{k(\\mathbf{y})}\\right)\n$$\n这是对于非平凡提议 $\\mathbf{y} \\ne \\mathbf{x}$ 的接受概率。问题陈述还规定，如果提议导致 $\\mathbf{y} = \\mathbf{x}$，则接受概率为 $\\alpha(\\mathbf{x}, \\mathbf{x}) = 1$。\n\n### 第2部分：实现策略\n\n程序将按以下步骤为每个测试用例求解：\n\n1.  **构型设置**：对每个测试用例，解析输入：晶格尺寸 $L$、逆温度 $\\beta$、能量参数 $J$、构型字符串、模板交换位置 $p_0$ 和 $p_1$ 以及特定的群元素索引 $g_{idx}$。构型字符串将被转换为一个 $L \\times L$ 的 NumPy 数组，其中物种 A 和 B 用整数表示（例如，A 为 $0$，B 为 $1$）。\n\n2.  **群操作**：一个函数将实现二面体群 $G$ 在晶格坐标 $(r, c)$ 上的 8 个变换。该函数将接收一个坐标对、群操作索引（0 到 7）和晶格尺寸 $L$作为输入，并返回变换后的坐标对。\n\n3.  **能量计算**：一个函数 `calculate_energy` 将计算给定构型的总能量 $E(\\mathbf{s})$。为避免重复计算键，它将遍历每个位置 $(r, c)$，并累加其与“右”邻居 $(r, (c+1) \\pmod L)$ 和“下”邻居 $((r+1) \\pmod L, c)$ 的键能贡献。如果键两端的物种不同，贡献为 $J$，否则为 $0$。\n\n4.  **提议生成**：特定的提议构型 $\\mathbf{y}$ 是从初始构型 $\\mathbf{x}$ 生成的。首先通过给定的群元素 $g$ 变换模板位置 $p_0$ 和 $p_1$ 得到位置 $s_0 = g(p_0)$ 和 $s_1 = g(p_1)$。然后，交换构型 $\\mathbf{x}$ 中位置 $s_0$ 和 $s_1$ 的物种以产生构型 $\\mathbf{y}$。\n\n5.  **轨道基数计算**：一个辅助函数 `get_orbit_cardinality` 将为任何构型 $\\mathbf{s}$ 计算 $k(\\mathbf{s})$。其过程如下：\n    a. 初始化一个空集合以存储唯一的构型。\n    b. 遍历所有 8 个群元素 $g_i \\in G$。\n    c. 对于每个 $g_i$，计算交换位置 $g_i(p_0)$ 和 $g_i(p_1)$。\n    d. 在构型 $\\mathbf{s}$ 的一个副本上执行交换，以生成提议构型 $\\mathbf{s}'$。\n    e. 为了使 NumPy 数组可哈希以便存入集合，将其转换为元组的元组。\n    f. 将可哈希的构型添加到集合中。使用集合会自动处理去重。\n    g. 基数 $k(\\mathbf{s})$ 是此集合的最终大小。\n\n6.  **接受概率计算**：\n    a. 程序首先检查 $\\mathbf{y}$ 是否与 $\\mathbf{x}$ 相同。如果交换位置 $s_0$ 和 $s_1$ 的物种相同，就可能发生这种情况。若是，根据问题定义，$\\alpha(\\mathbf{x}, \\mathbf{y}) = 1.0$。\n    b. 如果 $\\mathbf{y} \\ne \\mathbf{x}$，程序将使用上述函数计算 $E(\\mathbf{x})$、$E(\\mathbf{y})$、$k(\\mathbf{x})$ 和 $k(\\mathbf{y})$。\n    c. 最后，它使用推导出的公式计算 $\\alpha(\\mathbf{x}, \\mathbf{y})$：$\\min(1, \\exp(-\\beta(E(\\mathbf{y}) - E(\\mathbf{x}))) \\cdot k(\\mathbf{x}) / k(\\mathbf{y}))$。\n\n7.  **输出格式化**：每个测试用例计算出的接受概率将被四舍五入到 8 位小数并存储。最终输出为一行，包含这些值的逗号分隔列表，并用方括号括起。\n\n这种结构化方法确保了所有问题组件都按照指定的物理和算法原理正确实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, beta, J, config_str, p0, p1, g_idx)\n        (3, 0.7, 1.0, \"ABABABABA\", (0, 0), (1, 0), 1),\n        (3, 0.9, 1.0, \"AAAABAAAA\", (0, 0), (1, 0), 6),\n        (4, 0.5, 1.0, \"ABABBBAAAABBBABA\", (0, 0), (1, 0), 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, beta, J, config_str, p0, p1, g_idx = case\n        \n        # Mapping from species character to integer\n        species_map = {'A': 0, 'B': 1}\n        \n        # 1. Configuration Setup\n        x_config_flat = np.array([species_map[c] for c in config_str])\n        x_config = x_config_flat.reshape((L, L))\n        \n        # 2. Group Operations\n        group_ops = get_group_operations(L)\n        \n        # 3. Proposal Generation\n        s0 = group_ops[g_idx](p0)\n        s1 = group_ops[g_idx](p1)\n        \n        y_config = np.copy(x_config)\n        \n        # Check if proposed swap is non-trivial\n        if x_config[s0] != x_config[s1]:\n            y_config[s0], y_config[s1] = y_config[s1], y_config[s0]\n        \n        # 4. Acceptance Probability Calculation\n        \n        # Handle trivial case y = x\n        if np.array_equal(x_config, y_config):\n            alpha = 1.0\n        else:\n            # Calculate energies\n            E_x = calculate_energy(x_config, J, L)\n            E_y = calculate_energy(y_config, J, L)\n            \n            # Calculate orbit cardinalities\n            k_x = get_orbit_cardinality(x_config, p0, p1, L, group_ops)\n            k_y = get_orbit_cardinality(y_config, p0, p1, L, group_ops)\n            \n            # Use derived formula for alpha\n            ratio = (k_x / k_y) if k_y > 0 else 0 \n            alpha = min(1.0, np.exp(-beta * (E_y - E_x)) * ratio)\n            \n        results.append(round(alpha, 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\ndef get_group_operations(L):\n    \"\"\"\n    Returns a list of lambda functions for the 8 dihedral group operations on a square lattice.\n    \"\"\"\n    L_minus_1 = L - 1\n    return [\n        lambda p: (p[0], p[1]),                                       # 0: identity\n        lambda p: (p[1], L_minus_1 - p[0]),                           # 1: rot90\n        lambda p: (L_minus_1 - p[0], L_minus_1 - p[1]),               # 2: rot180\n        lambda p: (L_minus_1 - p[1], p[0]),                           # 3: rot270\n        lambda p: (p[0], L_minus_1 - p[1]),                           # 4: reflection vertical\n        lambda p: (L_minus_1 - p[0], p[1]),                           # 5: reflection horizontal\n        lambda p: (p[1], p[0]),                                       # 6: reflection main diagonal\n        lambda p: (L_minus_1 - p[1], L_minus_1 - p[0]),               # 7: reflection anti-diagonal\n    ]\n\ndef calculate_energy(config, J, L):\n    \"\"\"\n    Calculates the total energy of a configuration using periodic boundary conditions.\n    \"\"\"\n    energy = 0.0\n    for r in range(L):\n        for c in range(L):\n            # Bond with right neighbor\n            c_right = (c + 1) % L\n            if config[r, c] != config[r, c_right]:\n                energy += J\n            # Bond with bottom neighbor\n            r_down = (r + 1) % L\n            if config[r, c] != config[r_down, c]:\n                energy += J\n    return energy\n\ndef get_orbit_cardinality(config, p0, p1, L, group_ops):\n    \"\"\"\n    Calculates the cardinality of the set of distinct configurations generated by group-averaged swaps.\n    \"\"\"\n    orbit_configs = set()\n    for g_op in group_ops:\n        temp_config = np.copy(config)\n        \n        # Get swap sites for this group operation\n        sp0 = g_op(p0)\n        sp1 = g_op(p1)\n        \n        # Perform swap\n        if temp_config[sp0] != temp_config[sp1]:\n            temp_config[sp0], temp_config[sp1] = temp_config[sp1], temp_config[sp0]\n\n        # Add a hashable representation of the config to the set\n        orbit_configs.add(temp_config.tobytes())\n        \n    return len(orbit_configs)\n\nsolve()\n```"
        }
    ]
}