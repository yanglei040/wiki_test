{
    "hands_on_practices": [
        {
            "introduction": "朗之万方程为我们提供了一个优雅而强大的模型，用以描述单个粒子在热浴中的运动。通过解析求解这个模型中阻尼谐振子的速度自相关函数（VACF）及其功率谱，我们可以深入理解微观相互作用（由阻尼项代表）如何体现为可观测的光谱特征，例如谱峰的展宽。 这项练习旨在为解读真实模拟中得到的复杂谱图建立坚实的理论基础。",
            "id": "3501925",
            "problem": "考虑一个单位质量的经典粒子，在与绝对温度为 $T$ 的热浴接触的情况下进行阻尼谐振。其位移 $x(t)$ 满足线性随机微分方程\n$$\n\\ddot{x}(t)+2\\gamma\\,\\dot{x}(t)+\\omega_{0}^{2}\\,x(t)=\\eta(t),\n$$\n其中 $\\gamma>0$ 是阻尼系数，$\\omega_{0}>0$ 是裸谐振频率，$\\eta(t)$ 是代表热浴的平稳零均值高斯白噪声。假设在平衡态下涨落-耗散关系成立，因此噪声自相关函数为\n$$\n\\langle \\eta(t)\\,\\eta(t')\\rangle = 4\\,\\gamma\\,k_{B}\\,T\\,\\delta(t-t'),\n$$\n其中 $k_{B}$ 是玻尔兹曼常数，$\\delta(t)$ 是狄拉克δ函数。定义速度 $v(t)\\equiv \\dot{x}(t)$，速度自相关函数 (VACF) $C_{v}(t)\\equiv \\langle v(t)\\,v(0)\\rangle$，及其双边功率谱 $S_{vv}(\\omega)\\equiv \\int_{-\\infty}^{\\infty} \\exp(i\\omega t)\\,C_{v}(t)\\,dt$。使用以下傅里叶变换约定\n$$\nf(\\omega)=\\int_{-\\infty}^{\\infty}\\exp(i\\omega t)\\,f(t)\\,dt,\\qquad f(t)=\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty}\\exp(-i\\omega t)\\,f(\\omega)\\,d\\omega.\n$$\n仅从这些定义和给定的运动方程出发，并假设在欠阻尼区域 $0  \\gamma  \\omega_{0}$，完成以下任务：\n\n1. 推导在平衡态下对所有实数 $t$ 的 $C_{v}(t)$ 的闭式表达式。\n2. 推导速度功率谱 $S_{vv}(\\omega)$ 的闭式表达式，用 $\\gamma$、$\\omega_{0}$、$k_{B}$、$T$ 和 $\\omega$ 表示。\n3. 利用您的谱结果，识别在 $\\omega\\approx \\omega_{0}$ 附近的谱线形状，确定其以角频率为单位的半高半宽，并解释 $\\gamma$ 如何通过谱线展宽和相关的振动寿命来表征固体中非谐散射的强度。\n\n您最终的方框答案必须是您得到的 $S_{vv}(\\omega)$ 的闭式解析表达式，表示为 $\\omega$、$\\gamma$、$\\omega_{0}$、$k_{B}$ 和 $T$ 的函数。方框内的表达式不应包含任何单位。不需要进行数值计算或四舍五入。",
            "solution": "所述问题是统计物理学中的一个标准、适定的问题，因此被认为是**有效的**。我们可以开始求解。\n\n该问题要求对由郎之万方程描述的阻尼谐振子进行三部分的推导。我们将首先推导速度功率谱 $S_{vv}(\\omega)$，然后是速度自相关函数 (VACF) $C_{v}(t)$，最后分析谱线形状。\n\n**第2部分：速度功率谱 $S_{vv}(\\omega)$ 的推导**\n\n我们首先对郎之万运动方程应用指定的傅里叶变换：\n$$\n\\ddot{x}(t) + 2\\gamma\\dot{x}(t) + \\omega_0^2 x(t) = \\eta(t)\n$$\n根据时间导数 $\\dot{f}(t)$ 的傅里叶变换为 $-i\\omega f(\\omega)$ 的约定，该方程在频域中变为：\n$$\n(-\\omega^2 - 2i\\gamma\\omega + \\omega_0^2) x(\\omega) = \\eta(\\omega)\n$$\n其中 $x(\\omega)$ 和 $\\eta(\\omega)$ 分别是 $x(t)$ 和 $\\eta(t)$ 的傅里叶变换。我们可以解出 $x(\\omega)$：\n$$\nx(\\omega) = \\frac{\\eta(\\omega)}{\\omega_0^2 - \\omega^2 - 2i\\gamma\\omega}\n$$\n速度 $v(t)$ 定义为 $v(t) = \\dot{x}(t)$。其傅里叶变换为 $v(\\omega) = -i\\omega x(\\omega)$。代入 $x(\\omega)$ 的表达式得到：\n$$\nv(\\omega) = \\frac{-i\\omega}{\\omega_0^2 - \\omega^2 - 2i\\gamma\\omega} \\eta(\\omega)\n$$\n该关系式的形式为 $v(\\omega) = \\chi_v(\\omega) \\eta(\\omega)$，其中 $\\chi_v(\\omega)$ 是速度响应函数：\n$$\n\\chi_v(\\omega) = \\frac{-i\\omega}{\\omega_0^2 - \\omega^2 - 2i\\gamma\\omega}\n$$\n根据 Wiener-Khinchin 定理和线性响应理论，输出信号的功率谱 $S_{vv}(\\omega)$ 与输入噪声的功率谱 $S_{\\eta\\eta}(\\omega)$ 通过响应函数的模平方相关联：\n$$\nS_{vv}(\\omega) = |\\chi_v(\\omega)|^2 S_{\\eta\\eta}(\\omega)\n$$\n噪声功率谱 $S_{\\eta\\eta}(\\omega)$ 是噪声自相关函数 $\\langle \\eta(t)\\eta(0) \\rangle$ 的傅里叶变换。给定 $\\langle \\eta(t)\\eta(t') \\rangle = 4\\gamma k_B T \\delta(t-t')$，我们有：\n$$\nS_{\\eta\\eta}(\\omega) = \\int_{-\\infty}^{\\infty} e^{i\\omega t} \\langle \\eta(t)\\eta(0) \\rangle dt = \\int_{-\\infty}^{\\infty} e^{i\\omega t} \\left(4\\gamma k_B T \\delta(t)\\right) dt = 4\\gamma k_B T\n$$\n现在，我们计算响应函数的模平方：\n$$\n|\\chi_v(\\omega)|^2 = \\left| \\frac{-i\\omega}{\\omega_0^2 - \\omega^2 - 2i\\gamma\\omega} \\right|^2 = \\frac{|-i\\omega|^2}{|\\omega_0^2 - \\omega^2 - 2i\\gamma\\omega|^2} = \\frac{\\omega^2}{(\\omega_0^2 - \\omega^2)^2 + (-2\\gamma\\omega)^2} = \\frac{\\omega^2}{(\\omega_0^2 - \\omega^2)^2 + 4\\gamma^2\\omega^2}\n$$\n将这些结果代入 $S_{vv}(\\omega)$ 的方程，我们得到速度功率谱的最终表达式：\n$$\nS_{vv}(\\omega) = \\frac{4\\gamma k_B T \\omega^2}{(\\omega_0^2 - \\omega^2)^2 + 4\\gamma^2\\omega^2}\n$$\n\n**第1部分：速度自相关函数 $C_v(t)$ 的推导**\n\n速度自相关函数 (VACF) $C_v(t)$ 是 $S_{vv}(\\omega)$ 的傅里叶逆变换。然而，我们也可以使用回归假设来推导它，该假设指出平衡相关函数的时间演化模拟了诱导宏观扰动的弛豫过程。对于 $t0$，$C_v(t) = \\langle v(t)v(0) \\rangle$ 可以通过求解 $v(t)$ 的齐次运动方程得到，其初始条件在平衡系综上取平均。对于该系统，这意味着 $\\langle v(0)^2 \\rangle = k_B T$（根据能量均分定理，质量 $m=1$）和 $\\langle x(0)v(0) \\rangle = 0$。因此，我们求解齐次方程 $\\ddot{x} + 2\\gamma\\dot{x} + \\omega_0^2 x = 0$，初始条件为 $x(0)=0$ 和 $v(0)=v_0$。\n\n特征方程为 $r^2+2\\gamma r+\\omega_0^2=0$，其根为 $r=-\\gamma \\pm i\\omega_1$，其中 $\\omega_1 \\equiv \\sqrt{\\omega_0^2 - \\gamma^2}$ 在欠阻尼区域 ($0  \\gamma  \\omega_0$) 是实数。满足 $x(0)=0$ 的 $x(t)$ 的解是 $x(t) = B e^{-\\gamma t}\\sin(\\omega_1 t)$。对应的速度是 $v(t) = \\dot{x}(t) = B e^{-\\gamma t}(-\\gamma \\sin(\\omega_1 t) + \\omega_1 \\cos(\\omega_1 t))$。条件 $v(0)=v_0$ 给出 $v_0 = B\\omega_1$，因此 $B = v_0/\\omega_1$。随后的速度是：\n$$\nv(t) = v_0 e^{-\\gamma t}\\left(\\cos(\\omega_1 t) - \\frac{\\gamma}{\\omega_1}\\sin(\\omega_1 t)\\right)\n$$\n为了求得 $C_v(t)$，我们将 $v_0^2$ 替换为其热平均值 $\\langle v(0)^2 \\rangle = k_B T$：\n$$\nC_v(t) = k_B T e^{-\\gamma t}\\left(\\cos(\\omega_1 t) - \\frac{\\gamma}{\\omega_1}\\sin(\\omega_1 t)\\right), \\quad \\text{for } t  0\n$$\n由于 $C_v(t)$ 是时间的偶函数，我们使用绝对值 $|t|$ 将其推广到所有实数 $t$：\n$$\nC_v(t) = k_B T e^{-\\gamma|t|}\\left(\\cos(\\omega_1 t) - \\frac{\\gamma}{\\omega_1}\\sin(\\omega_1 |t|)\\right)\n$$\n\n**第3部分：谱线形状分析**\n\n为了分析 $S_{vv}(\\omega)$ 在共振点 $\\omega \\approx \\omega_0$ 附近的谱线形状，我们采用近共振近似。我们将分母项重写为 $\\omega_0^2 - \\omega^2 = (\\omega_0-\\omega)(\\omega_0+\\omega)$，并近似为 $\\omega_0+\\omega \\approx 2\\omega_0$。分子项 $\\omega^2$ 近似为 $\\omega_0^2$。\n$$\nS_{vv}(\\omega) \\approx \\frac{4\\gamma k_B T \\omega_0^2}{((\\omega_0-\\omega)2\\omega_0)^2 + 4\\gamma^2\\omega_0^2} = \\frac{4\\gamma k_B T \\omega_0^2}{4\\omega_0^2(\\omega-\\omega_0)^2 + 4\\gamma^2\\omega_0^2} = \\frac{k_B T \\gamma}{(\\omega-\\omega_0)^2 + \\gamma^2}\n$$\n该表达式描述了一个以 $\\omega_0$ 为中心的洛伦兹线型。其峰值（在 $\\omega = \\omega_0$ 处）是 $S_{peak} = k_B T / \\gamma$。半高半宽 (HWHM) 是函数值为 $S_{peak}/2$ 时的频率偏移 $|\\omega-\\omega_0|$。\n$$\n\\frac{k_B T \\gamma}{(\\omega-\\omega_0)^2 + \\gamma^2} = \\frac{1}{2}\\frac{k_B T}{\\gamma} \\implies 2\\gamma^2 = (\\omega-\\omega_0)^2 + \\gamma^2 \\implies |\\omega-\\omega_0| = \\gamma\n$$\n半高半宽 (HWHM) 是 $\\gamma$。\n\n在固态物理学的背景下，这个模型将微观散射与宏观可观测量联系起来。在理想的谐振晶体中，声子（量子化的晶格振动）具有无限的寿命。原子间势中的非谐项会导致声子-声子散射，从而限制了它们的寿命。在郎之万模型中，阻尼系数 $\\gamma$ 代表了这种非谐散射的强度。推导出的谱线展宽（HWHM = $\\gamma$）是这些散射事件的直接结果。振动寿命 $\\tau$ 是速度自相关函数 (VACF) 的衰减常数，$\\tau = 1/\\gamma$。因此，谱峰的半峰全宽 (FWHM = $2\\gamma$) 与振动寿命成反比，即 $FWHM = 2/\\tau$。因此，更强的非谐性（更大的 $\\gamma$）会导致更短的寿命和在测量的振动谱中出现更宽的峰。",
            "answer": "$$\n\\boxed{\\frac{4\\gamma k_{B} T \\omega^{2}}{\\left(\\omega_{0}^{2} - \\omega^{2}\\right)^{2} + 4\\gamma^{2}\\omega^{2}}}\n$$"
        },
        {
            "introduction": "理论的价值最终体现在实践中。在分子动力学模拟中，我们得到的是离散的位置和速度时间序列，一项核心任务便是从中计算振动态密度（VDOS）。 这个动手编程练习将引导你探索两种常见的计算方法——分别基于速度和位移自相关函数——并揭示为何基于VACF的方法在处理诸如漂移和噪声等常见数值伪影时，尤其在低频区域，具有更好的鲁棒性。",
            "id": "3501987",
            "problem": "您被要求设计并实现一个完整且可运行的程序。该程序从运动学和平稳随机过程的基本定义出发，利用速度和位移自相关函数，构建并比较两种振动态密度估计器。您的实现必须完全自包含且具有确定性。\n\n您必须使用的基本原理如下。一个自由度的位移是时间的函数，记为 $u(t)$，其速度由时间导数定义为 $v(t) = \\frac{du(t)}{dt}$。对于任何均值为零的宽义平稳实值时间序列 $x(t)$，其自相关函数为 $C_{xx}(\\tau) = \\mathbb{E}[x(t)x(t+\\tau)]$，且维纳-辛钦定理指出，功率谱密度是自相关函数的傅里叶变换。您必须仅从这些陈述出发进行推导和设计，不得使用任何简化公式。\n\n您的程序必须针对指定的测试套件完成以下任务。\n\n- 在均匀网格 $t_n = n\\,\\Delta t$（其中 $n \\in \\{0,1,\\dots,N-1\\}$）上，为 $u(t)$ 和 $v(t)$ 构建带有加性独立高斯测量噪声的离散时间合成轨迹。使用指定的随机种子以保证可复现性。对于谐波内容，在位移中使用具有固定振幅和相位的余弦模式的有限和，这些振幅和相位将根据种子确定性地生成。相应的无噪声速度必须是无噪声位移的精确时间导数。然后，将指定的测量噪声独立地添加到位移和速度时间序列中。当指定了位移中的线性漂移斜率时，在添加测量噪声之前，将 $d\\,t_n$ 加到 $u(t_n)$ 上，并将相应的常数项 $d$ 加到 $v(t_n)$ 上。\n- 对于 $u$ 和 $v$ 中的每一个，使用均值减法和无偏归一化计算离散样本自相关函数 $\\hat{C}_{xx}[k]$，其中 $k$ 是以样本为单位的离散延迟。对自相关序列应用汉宁窗以减轻截断伪影。计算加窗自相关函数的一侧离散时间傅里叶变换，以获得在角频率 $\\omega_k = \\frac{2\\pi k}{N \\Delta t}$（其中 $k \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$）上采样的非负频谱。\n- 仅使用 $v = du/dt$ 和维纳-辛钦定理所蕴含的 $u$ 和 $v$ 之间的关系（不使用任何其他启发式捷径），在正角频率上构建两种非负的振动态密度估计器：一种基于速度自相关，另一种基于位移自相关。限制在 $\\omega  0$ 的范围内，并使用角频率箱宽 $\\Delta\\omega = \\frac{2\\pi}{N \\Delta t}$ 对每个估计器进行归一化，使其在正角频率上的黎曼和等于 $1$。您的归一化过程必须在程序内部明确实现。\n- 对于每个测试用例，计算以下量化指标：\n  1. 两个归一化估计器的主导角频率（最大值位置）之间的绝对差值，以 $\\mathrm{rad/ps}$ 为单位表示，并四舍五入到三位小数。\n  2. 低频泄漏率之比，定义为由位移估计器计算的在区间 $\\omega \\in [0,\\omega_c]$ 上的归一化积分密度除以由速度估计器计算的相应值，结果四舍五入到三位小数。使用每个案例中给出的角频率阈值 $\\omega_c$，并使用间距 $\\Delta\\omega$ 的离散黎曼和进行积分。\n  3. 对于明确涉及非平稳运动且无真实振动内容的情况，返回一个布尔值，指示来自位移估计器的低频泄漏是否严格大于来自速度估计器的低频泄漏的五倍。\n\n所有测试用例的通用规范：\n\n- 时间步长 $\\Delta t = 0.001\\,\\mathrm{ps}$，总样本数 $N = 16384$，任何随机分量使用随机种子 $12345$。\n- 谐波模式的相位必须根据种子确定性地生成，其方式不应在两个估计器之间引入偏差。\n- 在计算自相关之前，从每个时间序列中独立减去样本均值。\n- 使用无偏自相关归一化，其中延迟 $k$ 的值除以重叠样本数 $N-k$。\n- 在进行离散傅里叶变换之前，对自相关序列应用汉宁窗 $w[k] = \\tfrac{1}{2}\\left(1 - \\cos\\left(\\tfrac{2\\pi k}{N-1}\\right)\\right)$。\n- 为归一化估计器，仅对严格为正的角频率（不包括 $\\omega=0$）进行积分，并确保在该正频率集合上的黎曼和等于 $1$。\n\n测试套件：\n\n- 案例 A（单尖锐模式，低噪声，无漂移）：在位移中使用一个角频率为 $\\omega_0 = 4.0\\,\\mathrm{rad/ps}$、振幅为 $A_0 = 0.10\\,\\mathrm{nm}$ 的谐波模式。无漂移。高斯测量噪声标准差，位移为 $\\sigma_u = 0.001\\,\\mathrm{nm}$，速度为 $\\sigma_v = 0.001\\,\\mathrm{nm/ps}$。使用低频阈值 $\\omega_c = 0.5\\,\\mathrm{rad/ps}$。输出主导频率的绝对差值，作为浮点数，单位为 $\\mathrm{rad/ps}$，四舍五入到三位小数。\n- 案例 B（双模式带线性漂移）：在位移中使用两个谐波模式，角频率为 $\\omega_1 = 1.0\\,\\mathrm{rad/ps}$ 和 $\\omega_2 = 8.0\\,\\mathrm{rad/ps}$，振幅为 $A_1 = 0.08\\,\\mathrm{nm}$ 和 $A_2 = 0.05\\,\\mathrm{nm}$。在添加测量噪声之前，在位移中添加线性漂移斜率 $d = 0.01\\,\\mathrm{nm/ps}$（并在速度中添加相应的恒定漂移）。高斯测量噪声标准差为 $\\sigma_u = 0.002\\,\\mathrm{nm}$ 和 $\\sigma_v = 0.002\\,\\mathrm{nm/ps}$。使用低频阈值 $\\omega_c = 0.5\\,\\mathrm{rad/ps}$。输出低频泄漏率之比（基于位移的除以基于速度的），作为浮点数，四舍五入到三位小数。\n- 案例 C（类布朗非平稳位移）：生成一个速度时间序列，作为均值为零、标准差为 $\\sigma_v = 0.02\\,\\mathrm{nm/ps}$ 的独立高斯样本，然后通过累积时间积分 $u(t_{n+1}) = u(t_n) + v(t_n)\\,\\Delta t$ 构建位移，从 $u(0)=0$ 开始。向位移添加标准差为 $\\sigma_u = 0.002\\,\\mathrm{nm}$ 的高斯测量噪声，向速度添加标准差为 $\\sigma_v^{\\text{meas}} = 0.002\\,\\mathrm{nm/ps}$ 的高斯测量噪声。使用低频阈值 $\\omega_c = 0.5\\,\\mathrm{rad/ps}$。输出一个布尔值，指示基于位移的估计器的低频泄漏是否超过基于速度的估计器的五倍。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含案例 A、案例 B 和案例 C 的结果，形式为方括号括起来的逗号分隔列表。前两个条目是按上述规定四舍五入的浮点数，第三个条目是布尔值。例如，一个带有占位符的输出看起来像 [$x,y,z$]，其中 $x$ 和 $y$ 是保留三位小数的浮点数，而 $z$ 是 True 或 False。\n\n所有物理单位必须按规定遵守，角频率单位为 $\\mathrm{rad/ps}$，位移单位为 $\\mathrm{nm}$，任何布尔值必须以编程语言的规范布尔形式返回。不允许外部输入；所有参数和随机种子均由此规范固定。",
            "solution": "该问题被评估为有效，因为它具有科学依据、问题明确、客观且内部一致。它提出了一个信号处理和统计物理领域中定义明确的计算任务，没有任何逻辑或事实错误。\n\n在此，我们按要求从第一性原理出发，给出一个完整的解决方案。目标是构建并比较两种振动态密度（VDOS）估计器，一种基于速度自相关函数（VACF），另一种基于位移自相关函数（DACF）。\n\n**1. 理论基础：从运动学到谱关系**\n\n问题从位移 $u(t)$ 和速度 $v(t)$ 之间的基本运动学关系开始：\n$$ v(t) = \\frac{du(t)}{dt} $$\n对于一个均值为零的宽义平稳随机过程 $x(t)$，自相关函数定义为 $C_{xx}(\\tau) = \\mathbb{E}[x(t)x(t+\\tau)]$，其中 $\\mathbb{E}[\\cdot]$ 表示期望算子。我们寻求位移自相关 $C_{uu}(\\tau)$ 和速度自相关 $C_{vv}(\\tau)$ 之间的关系。\n\n首先，让我们将互相关函数 $C_{vu}(\\tau) = \\mathbb{E}[v(t)u(t+\\tau)]$ 与 $C_{uu}(\\tau)$ 联系起来。使用速度的定义：\n$$ C_{vu}(\\tau) = \\mathbb{E}\\left[ \\frac{du(t)}{dt} u(t+\\tau) \\right] $$\n对于平稳过程，一个关键性质是 $\\mathbb{E}[A'(t)B(t+\\tau)] = -\\frac{d}{d\\tau} \\mathbb{E}[A(t)B(t+\\tau)]$。应用此性质可得：\n$$ C_{vu}(\\tau) = -\\frac{d}{d\\tau} \\mathbb{E}[u(t)u(t+\\tau)] = -\\frac{dC_{uu}(\\tau)}{d\\tau} $$\n接下来，我们用互相关函数表示 $C_{vv}(\\tau)$。使用性质 $\\mathbb{E}[A(t)B'(t+\\tau)] = \\frac{d}{d\\tau}\\mathbb{E}[A(t)B(t+\\tau)]$：\n$$ C_{vv}(\\tau) = \\mathbb{E}[v(t)v(t+\\tau)] = \\mathbb{E}\\left[v(t)\\frac{du(t+\\tau)}{d(t+\\tau)}\\right] = \\frac{d}{d\\tau}\\mathbb{E}[v(t)u(t+\\tau)] = \\frac{dC_{vu}(\\tau)}{d\\tau} $$\n代入 $C_{vu}(\\tau)$ 的表达式，我们得到两个自相关函数之间的基本关系：\n$$ C_{vv}(\\tau) = \\frac{d}{d\\tau} \\left( -\\frac{dC_{uu}(\\tau)}{d\\tau} \\right) = -\\frac{d^2 C_{uu}(\\tau)}{d\\tau^2} $$\n维纳-辛钦定理指出，功率谱密度（PSD） $S_{xx}(\\omega)$ 是自相关函数的傅里叶变换，即 $S_{xx}(\\omega) = \\mathcal{F}[C_{xx}(\\tau)](\\omega)$。一个 $n$ 阶导数的傅里叶变换由 $\\mathcal{F}[f^{(n)}(\\tau)](\\omega) = (i\\omega)^n \\mathcal{F}[f(\\tau)](\\omega)$ 给出。将此应用于我们的自相关函数关系：\n$$ S_{vv}(\\omega) = \\mathcal{F}[C_{vv}(\\tau)] = \\mathcal{F}\\left[-\\frac{d^2 C_{uu}(\\tau)}{d\\tau^2}\\right] = -(i\\omega)^2 \\mathcal{F}[C_{uu}(\\tau)] = -(-\\omega^2) S_{uu}(\\omega) $$\n这得到了频域中的核心方程：\n$$ S_{vv}(\\omega) = \\omega^2 S_{uu}(\\omega) $$\n\n**2. 振动态密度 (VDOS) 估计器**\n\n在统计力学中，振动态密度 $g(\\omega)$ 描述了振动模式按频率的分布。总动能与系统自由度速度平方的总和有关。因此，VDOS 自然地被定义为与速度涨落的功率谱成正比。\n\n因此，基于速度的 VDOS 估计器 $g_v(\\omega)$ 被认为与速度功率谱成正比：\n$$ g_v(\\omega) \\propto S_{vv}(\\omega) $$\n利用推导出的谱关系，我们可以从位移数据构建一个类似的估计器。为了获得 VDOS，我们必须首先从位移谱计算速度谱，这涉及到乘以 $\\omega^2$。因此，基于位移的 VDOS 估计器 $g_u(\\omega)$ 定义为：\n$$ g_u(\\omega) \\propto \\omega^2 S_{uu}(\\omega) $$\n理论上，对于一个完美的平稳过程，这两个估计器 $g_v(\\omega)$ 和 $g_u(\\omega)$ 应该是相同的。然而，在实践中，它们对噪声、有限样本效应以及像漂移或扩散这样的非平稳性有不同的响应，这正是本问题所要研究的。\n\n**3. 计算算法**\n\n该实现通过对每个指定的测试用例遵循一个离散信号处理流程来进行。\n\n**3.1. 数据生成**\n对于每个案例，在网格 $t_n = n\\Delta t$（其中 $n \\in \\{0, \\dots, N-1\\}$）上生成位移 $u(t_n)$ 和速度 $v(t_n)$ 的合成时间序列。\n- **谐波内容（案例 A, B）：** 构建位移的余弦函数之和及其解析时间导数作为速度。对每个模式使用根据指定种子确定性生成的随机相位。\n- **扩散内容（案例 C）：** 生成一个作为离散高斯白噪声的速度时间序列。然后通过累积离散积分 $u(t_{n+1}) = u(t_n) + v(t_n)\\Delta t$ 获得位移，模拟随机游走（布朗运动）。\n- **漂移与噪声：** 在指定的情况下，向干净的位移轨迹添加线性漂移，向速度轨迹添加恒定漂移。最后，向两个时间序列独立地添加高斯测量噪声。\n\n**3.2. 信号处理流程**\n对于每个时间序列（$u$ 和 $v$）：\n1.  **均值减法：** 从时间序列中减去样本均值，以满足计算自相关函数所需的零均值假设。\n2.  **自相关函数：** 计算离散延迟 $k \\in \\{0, \\dots, N-1\\}$ 的无偏样本自相关函数 $\\hat{C}_{xx}[k]$。其定义为 $\\hat{C}_{xx}[k] = \\frac{1}{N-k} \\sum_{n=0}^{N-1-k} x'_{n}x'_{n+k}$，其中 $x'$ 是减去均值的序列。为此计算使用 `scipy.signal.correlate` 提供的基于 FFT 的高效算法。\n3.  **加窗：** 将汉宁窗 $w[k] = \\tfrac{1}{2}\\left(1 - \\cos\\left(\\tfrac{2\\pi k}{N-1}\\right)\\right)$ 应用于计算出的整个自相关函数，即 $\\hat{C}^{\\text{win}}_{xx}[k] = \\hat{C}_{xx}[k] \\cdot w[k]$，以减少信号截断引起的谱泄漏。\n4.  **功率谱密度：** 从加窗的自相关函数计算单侧 PSD $\\hat{S}_{xx}(\\omega_j)$。这是通过取加窗自相关序列的单侧离散傅里叶变换（`rfft`）的实部来实现的。由数值不精确性产生的任何小的负值都被截断为零，以确保频谱非负。\n\n**3.3. VDOS 构建与归一化**\n未归一化的离散 VDOS 估计器构建如下：\n$$ \\hat{g}_v[\\omega_j] = \\hat{S}_{vv}[\\omega_j] \\quad \\text{和} \\quad \\hat{g}_u[\\omega_j] = \\omega_j^2 \\hat{S}_{uu}[\\omega_j] $$\n其中 $\\omega_j = \\frac{2\\pi j}{N \\Delta t}$ 是离散角频率。然后对每个估计器进行归一化，使其在严格为正的频率（$\\omega_j > 0$）上的黎曼和等于 1。归一化常数 $K$ 是该和的倒数：$K = \\left( \\sum_{j=1}^{\\lfloor N/2 \\rfloor} \\hat{g}[\\omega_j] \\Delta\\omega \\right)^{-1}$，其中 $\\Delta\\omega = \\frac{2\\pi}{N \\Delta t}$。归一化后的 VDOS 是 $g_{\\text{norm}}[\\omega_j] = K \\cdot \\hat{g}[\\omega_j]$。\n\n**4. 指标计算**\n最后一步是从归一化的 VDOS 估计器 $g_u$ 和 $g_v$ 计算指定的指标：\n- **指标 A（主导频率差异）：** 找到每个 VDOS（对于 $\\omega > 0$）最大值对应的角频率 $\\omega_{\\max}$。计算绝对差 $|\\omega_{\\max,u} - \\omega_{\\max,v}|$。\n- **指标 B（低频泄漏率之比）：** 通过离散黎曼和为每个估计器计算在区间 $\\omega \\in [0, \\omega_c]$ 上的积分密度。然后计算基于位移的积分与基于速度的积分之比。\n- **指标 C（非平稳泄漏检查）：** 对于布朗运动案例，计算相同的泄漏积分。返回一个布尔值，指示基于位移的估计器的泄漏是否严格大于基于速度的估计器的五倍。该指标突显了基于 VACF 的方法在处理非平稳扩散运动方面的优越鲁棒性，这种运动在基于 DACF 的方法中表现为严重的低频伪影。\n\n这个严谨的、基于原理的程序确保了两种估计器之间的比较是在坚实的理论和计算基础上进行的。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import correlate\nfrom scipy.fft import rfft, rfftfreq\n\ndef solve():\n    \"\"\"\n    Constructs and compares two estimators of the vibrational density of states\n    using velocity and displacement autocorrelation functions, based on synthetic data.\n    \"\"\"\n    # --- Common Specifications ---\n    DT = 0.001  # time step in ps\n    N = 16384     # number of samples\n    SEED = 12345\n    RNG = np.random.default_rng(SEED)\n\n    # --- Test Suite Parameters ---\n    test_cases_params = [\n        {\n            \"case\": \"A\",\n            \"modes\": [(4.0, 0.10)],  # (omega_rad_ps, amplitude_nm)\n            \"drift_slope\": 0.0,\n            \"sigma_u\": 0.001,\n            \"sigma_v\": 0.001,\n            \"omega_c\": 0.5,\n        },\n        {\n            \"case\": \"B\",\n            \"modes\": [(1.0, 0.08), (8.0, 0.05)],\n            \"drift_slope\": 0.01,\n            \"sigma_u\": 0.002,\n            \"sigma_v\": 0.002,\n            \"omega_c\": 0.5,\n        },\n        {\n            \"case\": \"C\",\n            \"is_brownian\": True,\n            \"brownian_sigma_v\": 0.02, # For generating the core signal\n            \"drift_slope\": 0.0,\n            \"sigma_u\": 0.002, # Measurement noise on u\n            \"sigma_v\": 0.002, # Measurement noise on v\n            \"omega_c\": 0.5,\n        },\n    ]\n\n    results = []\n\n    def analyze_case(params):\n        \"\"\"\n        Performs the full analysis pipeline for a single test case.\n        \"\"\"\n        # Time array\n        t = np.arange(N) * DT\n\n        # --- 1. Generate Synthetic Trajectories ---\n        u_clean = np.zeros(N, dtype=np.float64)\n        v_clean = np.zeros(N, dtype=np.float64)\n\n        if params.get(\"is_brownian\", False):\n            # Case C: Brownian-like motion\n            v_clean = RNG.normal(loc=0.0, scale=params[\"brownian_sigma_v\"], size=N)\n            u_clean = np.cumsum(v_clean) * DT\n        else:\n            # Cases A, B: Harmonic modes\n            num_modes = len(params[\"modes\"])\n            phases = RNG.uniform(0, 2 * np.pi, size=num_modes)\n            for i, (omega, amplitude) in enumerate(params[\"modes\"]):\n                phi = phases[i]\n                u_clean += amplitude * np.cos(omega * t + phi)\n                v_clean += -amplitude * omega * np.sin(omega * t + phi)\n        \n        # Add linear drift if specified\n        drift = params[\"drift_slope\"]\n        if drift != 0.0:\n            u_clean += drift * t\n            v_clean += drift\n            \n        # Add independent Gaussian measurement noise\n        u_noisy = u_clean + RNG.normal(loc=0.0, scale=params[\"sigma_u\"], size=N)\n        v_noisy = v_clean + RNG.normal(loc=0.0, scale=params[\"sigma_v\"], size=N)\n\n        # --- 2. Compute Power Spectral Density (PSD) ---\n        def get_psd(series):\n            # i. Mean subtraction\n            series_mean_sub = series - np.mean(series)\n            \n            # ii. Unbiased Autocorrelation Function (ACF)\n            unscaled_acf = correlate(series_mean_sub, series_mean_sub, mode='full', method='fft')[N - 1:]\n            normalization_factors = N - np.arange(N)\n            acf = unscaled_acf / normalization_factors\n            \n            # iii. Hann Windowing\n            hann_window = 0.5 * (1 - np.cos(2 * np.pi * np.arange(N) / (N - 1)))\n            wacf = acf * hann_window\n            \n            # iv. PSD from FFT of windowed ACF\n            psd = np.real(rfft(wacf))\n            psd[psd  0] = 0  # Ensure non-negativity\n            \n            return psd\n\n        S_uu = get_psd(u_noisy)\n        S_vv = get_psd(v_noisy)\n        \n        # Frequency axis (angular)\n        omega = 2 * np.pi * rfftfreq(N, d=DT)\n        \n        # --- 3. Construct and Normalize VDOS Estimators ---\n        g_u_unnorm = (omega**2) * S_uu\n        g_v_unnorm = S_vv\n\n        # Normalization over strictly positive frequencies (omega  0)\n        d_omega = omega[1] - omega[0]\n        \n        norm_u_integral = np.sum(g_u_unnorm[1:]) * d_omega\n        g_u = g_u_unnorm / norm_u_integral if norm_u_integral > 0 else np.zeros_like(g_u_unnorm)\n\n        norm_v_integral = np.sum(g_v_unnorm[1:]) * d_omega\n        g_v = g_v_unnorm / norm_v_integral if norm_v_integral > 0 else np.zeros_like(g_v_unnorm)\n\n        # --- 4. Compute and Return Required Metrics ---\n        if params[\"case\"] == \"A\":\n            # argmax on omega  0 part of the spectrum\n            idx_max_u = np.argmax(g_u[1:]) + 1\n            idx_max_v = np.argmax(g_v[1:]) + 1\n            freq_diff = abs(omega[idx_max_u] - omega[idx_max_v])\n            return round(freq_diff, 3)\n        \n        elif params[\"case\"] in [\"B\", \"C\"]:\n            omega_c = params[\"omega_c\"]\n            # Find index corresponding to omega_c\n            idx_c = np.searchsorted(omega, omega_c, side='right')\n            # Riemann sum for leakage integral over [0, omega_c]\n            leakage_u = np.sum(g_u[0:idx_c]) * d_omega\n            leakage_v = np.sum(g_v[0:idx_c]) * d_omega\n\n            if params[\"case\"] == \"B\":\n                # Handle potential division by zero\n                ratio = leakage_u / leakage_v if leakage_v != 0 else np.inf\n                return round(ratio, 3)\n            else: # Case C\n                return leakage_u > 5 * leakage_v\n\n    for params in test_cases_params:\n        results.append(analyze_case(params))\n\n    # --- Final Output Formatting ---\n    print(f\"[{results[0]},{results[1]},{results[2]}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "速度自相关函数的应用远不止于分析振动谱。通过Green-Kubo关系，我们可以将时间自相关函数与宏观输运性质联系起来。 本练习聚焦于一个真实的研究场景：如何从有限长度的模拟数据中精确计算自扩散系数$D$。你将学习并实践一种高级数据处理技术，即通过对VACF的长时拖尾进行物理模型拟合与外推，来修正因模拟时间有限而产生的截断误差。",
            "id": "3501959",
            "problem": "给定您从分子动力学(MD)模拟中获得的截断的速度自相关函数(VACF)数值样本。VACF定义为系综平均 $C_v(t) = \\langle \\mathbf{v}(t)\\cdot \\mathbf{v}(0) \\rangle$，其中 $\\mathbf{v}(t)$ 是粒子在时间 $t$ 的速度。您的任务是设计并实现一个自扩散系数 $D$ 的估计器，该估计器通过将一个具有物理动机的函数形式拟合到可访问的尾部段，并解析地外推截断时间之后的贡献，来解决长时尾部缺失的问题。\n\n该估计器必须建立在第一性原理和计算材料科学中公认的、合法的定义之上。它必须使用一个具有物理动机的尾部模型，例如 Kohlrausch–Williams–Watts (KWW) 展宽指数函数 $C_{\\mathrm{tail}}(t) = A \\exp\\!\\big(-(t/\\tau)^{\\beta}\\big)$，其参数 $A$、$\\tau$ 和 $\\beta$ 被约束在具有物理意义的域内。模型的合理性论证必须依赖于关于弛豫过程和振动光谱的物理推理，而不是死记硬背公式。\n\n根据以下要求实现该估计器：\n- 使用具有均匀采样间隔 $\\Delta t$ 和截断时间 $t_{\\max}$ 的截断离散VACF样本 $\\{C_v(t_n)\\}_{n=0}^{N}$，并将VACF视为三维空间中完整速度矢量 $\\mathbf{v}(t)$ 的标量相关。\n- 在 $[0,t_{\\max}]$ 上对可用的VACF进行数值积分，并加上基于对可访问尾部段拟合的余项 $\\int_{t_{\\max}}^{\\infty} C_{\\mathrm{tail}}(t)\\,\\mathrm{d}t$ 的解析外推。将拟合参数约束为 $A \\ge 0$、$\\tau  0$ 和 $0  \\beta \\le 1$，并确保在拟合不适定（例如，尾部点太少）时估计器是稳健的，此时默认尾部贡献为零。\n- 所有最终报告的扩散系数 $D$ 均以 $\\mathrm{m^2/s}$ 为单位表示。\n\n按如下方式为可测试性进行设计。您的程序必须使用物理上合理的合成模型在内部构建VACF测试数据，而不读取任何外部输入。使用玻尔兹曼常数 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\,\\mathrm{J/K}$、温度 $T = 300\\,\\mathrm{K}$ 和粒子质量 $m = 1.0\\times 10^{-24}\\,\\mathrm{kg}$，使得初始VACF水平为 $C_0 = 3 k_{\\mathrm{B}} T / m$。\n\n提供一个包含三个案例的测试套件：\n- 案例 A（通用情况，“理想路径”）：一个展宽指数VACF $C_v(t) = C_0 \\exp\\!\\big(-(t/\\tau)^{\\beta}\\big)$，以 $\\Delta t = 2.0\\times 10^{-14}\\,\\mathrm{s}$ 采样至 $t_{\\max} = 4.0\\times 10^{-12}\\,\\mathrm{s}$，参数为 $\\tau = 1.5\\times 10^{-12}\\,\\mathrm{s}$ 和 $\\beta = 0.65$，并添加零均值高斯噪声，其标准差为每个 $t$ 处无噪声 $C_v(t)$ 值的 $0.01$ 倍。\n- 案例 B（边界情况，短截断）：与案例 A 具有相同的函数形式，但以 $\\Delta t = 1.0\\times 10^{-14}\\,\\mathrm{s}$ 采样至 $t_{\\max} = 3.0\\times 10^{-13}\\,\\mathrm{s}$，噪声相对水平为 $0.05$。\n- 案例 C（边缘情况，包含振动振荡的双组分弛豫）：一个长时展宽指数尾部与一个短时阻尼振动振荡之和，\n  $$C_v(t) = f_{\\mathrm{kww}} C_0 \\exp\\!\\big(-(t/\\tau_{\\mathrm{long}})^{\\beta_{\\mathrm{long}}}\\big) + f_{\\mathrm{osc}} C_0 \\cos(\\omega t)\\exp\\!\\big(-t/\\tau_{\\mathrm{osc}}\\big),$$\n  其中 $f_{\\mathrm{kww}} = 0.5$，$f_{\\mathrm{osc}} = 0.5$，$\\tau_{\\mathrm{long}} = 2.0\\times 10^{-12}\\,\\mathrm{s}$，$\\beta_{\\mathrm{long}} = 0.60$，$\\omega = 2\\pi\\times 1.0\\times 10^{12}\\,\\mathrm{rad/s}$，以及 $\\tau_{\\mathrm{osc}} = 4.0\\times 10^{-13}\\,\\mathrm{s}$，以 $\\Delta t = 2.0\\times 10^{-14}\\,\\mathrm{s}$ 采样至 $t_{\\max} = 5.0\\times 10^{-12}\\,\\mathrm{s}$，噪声相对水平为 $0.02$。\n\n您的程序应使用截断数据的最后一部分来拟合展宽指数尾部（选择最后可用时间的一部分，以便拟合目标是长时衰减），计算截断VACF在 $[0,t_{\\max}]$ 上的数值积分，加上解析尾部积分，并转换为三维扩散系数。所有浮点输出必须以 $\\mathrm{m^2/s}$ 为单位报告。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个案例的扩散估计值，格式为逗号分隔的列表并用方括号括起，例如 $[d_A,d_B,d_C]$，其中 $d_A$、$d_B$ 和 $d_C$ 是以科学记数法打印且小数点后有六位数字的十进制浮点数，单位为 $\\mathrm{m^2/s}$。",
            "solution": "该问题是有效的。它在科学上基于统计力学的原理，特别是关于输运系数的Green-Kubo关系。该问题定义明确、客观，并为构建唯一且可验证的解决方案提供了一整套参数和约束。\n\n在三维系统中，粒子的自扩散系数 $D$ 与其速度涨落的时间相关性有着根本的联系。这种关系由Green-Kubo公式正式表达：\n$$\nD = \\frac{1}{3} \\int_{0}^{\\infty} C_v(t) \\, \\mathrm{d}t\n$$\n其中 $C_v(t)$ 是速度自相关函数 (VACF)，定义为系综平均 $C_v(t) = \\langle \\mathbf{v}(t) \\cdot \\mathbf{v}(0) \\rangle$。因子 $\\frac{1}{3}$ 源于考虑在三个各向同性空间维度中的扩散。VACF的初始值 $C_v(0) = \\langle |\\mathbf{v}(0)|^2 \\rangle$ 由能量均分定理确定，该定理指出平均动能为 $\\frac{3}{2} k_{\\mathrm{B}} T$。由此可得 $C_v(0) = \\frac{3 k_{\\mathrm{B}} T}{m}$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度，$m$ 是粒子质量。\n\n分子动力学(MD)模拟以离散时间序列 $\\{C_v(t_n)\\}$ 的形式提供VACF，该序列在 $\\Delta t$ 的时间间隔内采样，直至有限的截断时间 $t_{\\max}$。主要挑战在于计算 $D$ 的积分延伸至无穷大，而数据却是截断的。仅积分到 $t_{\\max}$ 的简单方法会因忽略相关函数的长时尾部贡献而系统性地低估 $D$。\n\n为解决此问题，我们将积分分为两部分：\n$$\n\\int_{0}^{\\infty} C_v(t) \\, \\mathrm{d}t = \\int_{0}^{t_{\\max}} C_v(t) \\, \\mathrm{d}t + \\int_{t_{\\max}}^{\\infty} C_v(t) \\, \\mathrm{d}t\n$$\n第一项，即在已知数据范围 $[0, t_{\\max}]$ 上的积分，可以进行数值计算。对于均匀采样的数据，梯形法是一种合适且准确的方法：\n$$\nI_{\\text{num}} = \\int_{0}^{t_{\\max}} C_v(t) \\, \\mathrm{d}t \\approx \\Delta t \\left( \\frac{C_v(t_0) + C_v(t_N)}{2} + \\sum_{n=1}^{N-1} C_v(t_n) \\right)\n$$\n其中 $t_n = n \\Delta t$ 且 $t_N = t_{\\max}$。\n\n第二项，即从 $t_{\\max}$ 到无穷大的积分，需要一个模型来描述VACF的渐近衰减。在许多复杂和无序的系统中，例如过冷液体或玻璃态，弛豫过程并不遵循简单的指数衰减。相反，它们表现出弛豫时间尺度的分布，这种分布可以很好地由Kohlrausch–Williams–Watts (KWW)函数或“展宽指数”函数捕捉。这是对尾部行为具有物理动机的选择：\n$$\nC_{\\text{tail}}(t) = A \\exp\\left(-\\left(\\frac{t}{\\tau}\\right)^{\\beta}\\right)\n$$\n该模型的参数是振幅 $A$、特征弛豫时间 $\\tau$ 和展宽指数 $\\beta$。约束条件为 $A \\ge 0$、$\\tau  0$ 和 $0  \\beta \\le 1$。$\\beta=1$ 的情况对应于简单的指数（Debye）弛豫，而较小的 $\\beta$ 值表示更宽的弛豫速率分布。\n\n估计器的步骤如下：\n1.  选择时间序列末端的一部分数据（可访问的尾部）。\n2.  使用非线性最小二乘拟合程序来确定最佳参数 $(A, \\tau, \\beta)$，使KWW模型在物理约束条件下最佳地拟合这部分VACF数据。\n3.  如果拟合成功，则使用拟合参数解析地计算尾部贡献的积分 $I_{\\text{tail}}$：\n    $$\n    I_{\\text{tail}} = \\int_{t_{\\max}}^{\\infty} A \\exp\\left(-\\left(\\frac{t}{\\tau}\\right)^{\\beta}\\right) \\, \\mathrm{d}t\n    $$\n    为求解该积分，我们进行变量替换。令 $u = (t/\\tau)^{\\beta}$。则 $t = \\tau u^{1/\\beta}$ 且 $\\mathrm{d}t = \\frac{\\tau}{\\beta} u^{(1/\\beta)-1} \\mathrm{d}u$。积分下限变为 $u_{\\min} = (t_{\\max}/\\tau)^{\\beta}$。积分变换为：\n    $$\n    I_{\\text{tail}} = A \\int_{(t_{\\max}/\\tau)^{\\beta}}^{\\infty} e^{-u} \\left(\\frac{\\tau}{\\beta} u^{(1/\\beta)-1}\\right) \\, \\mathrm{d}u = \\frac{A\\tau}{\\beta} \\int_{(t_{\\max}/\\tau)^{\\beta}}^{\\infty} u^{(1/\\beta)-1} e^{-u} \\, \\mathrm{d}u\n    $$\n    这个积分是上不完全伽马函数的定义，$\\Gamma(s, x) = \\int_x^{\\infty} t^{s-1} e^{-t} \\, \\mathrm{d}t$。当 $s = 1/\\beta$ 且 $x = (t_{\\max}/\\tau)^{\\beta}$ 时，解析结果是：\n    $$\n    I_{\\text{tail}} = \\frac{A\\tau}{\\beta} \\Gamma\\left(\\frac{1}{\\beta}, \\left(\\frac{t_{\\max}}{\\tau}\\right)^{\\beta}\\right)\n    $$\n4.  总积分为 $I_{\\text{total}} = I_{\\text{num}} + I_{\\text{tail}}$ 的和。\n5.  扩散系数的最终估计值为 $D = \\frac{1}{3} I_{\\text{total}}$。\n6.  为保证稳健性，如果拟合过程失败（例如，由于尾部段数据不足或收敛性差），则尾部贡献 $I_{\\text{tail}}$ 设为零。这确保估计器总能返回一个值，尽管可能精度较低，对应于对积分的简单截断。\n\n该实现将为三个测试案例合成VACF数据，对每个案例应用此估计程序，并报告所得的扩散系数。合成数据包括噪声和多组分弛豫等现实特征，以测试该方法的稳健性和适用性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\nfrom scipy.special import gamma, gammaincc\n\ndef solve():\n    \"\"\"\n    Calculates the self-diffusion coefficient from synthetic VACF data.\n    The estimator combines numerical integration of the available data with an\n    analytical extrapolation of the long-time tail, modeled as a\n    Kohlrausch-Williams-Watts (KWW) stretched exponential function.\n    \"\"\"\n\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"T\": 300.0,\n            \"m\": 1.0e-24,\n            \"dt\": 2.0e-14,\n            \"t_max\": 4.0e-12,\n            \"noise_level\": 0.01,\n            \"model_type\": \"kww\",\n            \"params\": {\"tau\": 1.5e-12, \"beta\": 0.65},\n        },\n        {\n            \"name\": \"Case B\",\n            \"T\": 300.0,\n            \"m\": 1.0e-24,\n            \"dt\": 1.0e-14,\n            \"t_max\": 3.0e-13,\n            \"noise_level\": 0.05,\n            \"model_type\": \"kww\",\n            \"params\": {\"tau\": 1.5e-12, \"beta\": 0.65},\n        },\n        {\n            \"name\": \"Case C\",\n            \"T\": 300.0,\n            \"m\": 1.0e-24,\n            \"dt\": 2.0e-14,\n            \"t_max\": 5.0e-12,\n            \"noise_level\": 0.02,\n            \"model_type\": \"kww_osc\",\n            \"params\": {\n                \"f_kww\": 0.5,\n                \"f_osc\": 0.5,\n                \"tau_long\": 2.0e-12,\n                \"beta_long\": 0.60,\n                \"omega\": 2.0 * np.pi * 1.0e12,\n                \"tau_osc\": 4.0e-13,\n            },\n        },\n    ]\n\n    results = []\n    rng = np.random.default_rng(seed=42)  # For reproducible noise\n\n    for case in test_cases:\n        # 1. Generate synthetic VACF data\n        T, m, dt, t_max = case[\"T\"], case[\"m\"], case[\"dt\"], case[\"t_max\"]\n        C0 = 3.0 * k_B * T / m\n        t_array = np.arange(0, t_max + dt / 2.0, dt)\n        \n        if case[\"model_type\"] == \"kww\":\n            p = case[\"params\"]\n            vacf_noiseless = C0 * np.exp(-((t_array / p[\"tau\"]) ** p[\"beta\"]))\n        elif case[\"model_type\"] == \"kww_osc\":\n            p = case[\"params\"]\n            kww_part = p[\"f_kww\"] * C0 * np.exp(-((t_array / p[\"tau_long\"]) ** p[\"beta_long\"]))\n            osc_part = p[\"f_osc\"] * C0 * np.cos(p[\"omega\"] * t_array) * np.exp(-t_array / p[\"tau_osc\"])\n            vacf_noiseless = kww_part + osc_part\n        \n        noise = rng.normal(loc=0.0, scale=case[\"noise_level\"] * np.abs(vacf_noiseless))\n        vacf_samples = vacf_noiseless + noise\n\n        # 2. Numerical integration of the available VACF\n        numerical_integral = np.trapz(vacf_samples, x=t_array)\n\n        # 3. Fit the tail and calculate the analytical tail integral\n        tail_integral = 0.0\n        \n        # Select the last 40% of the data for fitting the tail\n        tail_fraction = 0.40\n        tail_start_index = int((1.0 - tail_fraction) * len(t_array))\n        \n        # Ensure there are enough points to fit (more than number of parameters)\n        if len(t_array) - tail_start_index > 3:\n            t_tail = t_array[tail_start_index:]\n            vacf_tail = vacf_samples[tail_start_index:]\n\n            def kww_func(t, A, tau, beta):\n                return A * np.exp(-((t / tau) ** beta))\n\n            # Bounds for the fitting parameters\n            bounds = ([0, 1e-16, 1e-6], [np.inf, np.inf, 1.0])\n            \n            # Initial guess for the parameters\n            A_guess = vacf_tail[0] if vacf_tail[0] > 0 else 1.0\n            tau_guess = t_max\n            beta_guess = 0.7\n            p0 = [A_guess, tau_guess, beta_guess]\n            \n            try:\n                popt, _ = curve_fit(kww_func, t_tail, vacf_tail, p0=p0, bounds=bounds, maxfev=5000)\n                A_fit, tau_fit, beta_fit = popt\n\n                # 4. Calculate the analytical integral of the fitted tail\n                # Integral from t_max to infinity of A*exp(-(t/tau)^beta) dt\n                s = 1.0 / beta_fit\n                x = (t_max / tau_fit) ** beta_fit\n                \n                # tail_integral = (A_fit * tau_fit / beta_fit) * Gamma(s, x)\n                # scipy.special.gammaincc(s,x) is Gamma(s,x)/Gamma(s)\n                tail_integral = (A_fit * tau_fit / beta_fit) * gamma(s) * gammaincc(s, x)\n                \n                # Ensure physical result (integral must be non-negative)\n                if tail_integral  0:\n                    tail_integral = 0.0\n\n            except RuntimeError:\n                # If fit fails, the tail contribution is zero\n                tail_integral = 0.0\n        \n        # 5. Calculate the total diffusion coefficient\n        total_integral = numerical_integral + tail_integral\n        D = (1.0 / 3.0) * total_integral\n        results.append(D)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join([f'{d:.6e}' for d in results])}]\")\n\nsolve()\n```"
        }
    ]
}