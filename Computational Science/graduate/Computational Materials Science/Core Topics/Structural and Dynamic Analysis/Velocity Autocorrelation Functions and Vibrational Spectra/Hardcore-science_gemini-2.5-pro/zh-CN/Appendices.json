{
    "hands_on_practices": [
        {
            "introduction": "为建立坚实的理论基础，我们从一个能够抓住振动谱核心特征的最简模型——阻尼谐振子——入手。这项理论练习 () 是一座至关重要的桥梁，它将微观的运动方程与谱图上可观测的宏观特征（如峰位和峰宽）联系起来。通过解析推导速度自相关函数（VACF）及其对应的功率谱，您将从第一性原理的层面深刻理解阻尼（在真实固体中代表非谐声子散射）等物理过程如何导致谱线展宽和有限的振动寿命。",
            "id": "3501925",
            "problem": "考虑一个单位质量的经典粒子，在与绝对温度为 $T$ 的热浴接触时进行阻尼谐波运动。其位移 $x(t)$ 满足线性随机微分方程\n$$\n\\ddot{x}(t)+2\\gamma\\,\\dot{x}(t)+\\omega_{0}^{2}\\,x(t)=\\eta(t),\n$$\n其中 $\\gamma>0$ 是阻尼系数，$\\omega_{0}>0$ 是裸谐波频率，$\\eta(t)$ 是代表热浴的平稳零均值高斯白噪声。假设在平衡状态下涨落耗散关系成立，因此噪声自相关函数为\n$$\n\\langle \\eta(t)\\,\\eta(t')\\rangle = 4\\,\\gamma\\,k_{B}\\,T\\,\\delta(t-t'),\n$$\n其中 $k_{B}$ 是玻尔兹曼常数，$\\delta(t)$ 是狄拉克δ函数。定义速度 $v(t)\\equiv \\dot{x}(t)$、速度自相关函数 (VACF) $C_{v}(t)\\equiv \\langle v(t)\\,v(0)\\rangle$ 及其双边功率谱 $S_{vv}(\\omega)\\equiv \\int_{-\\infty}^{\\infty} \\exp(i\\omega t)\\,C_{v}(t)\\,dt$。使用傅里叶变换约定\n$$\nf(\\omega)=\\int_{-\\infty}^{\\infty}\\exp(i\\omega t)\\,f(t)\\,dt,\\qquad f(t)=\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty}\\exp(-i\\omega t)\\,f(\\omega)\\,d\\omega.\n$$\n仅从这些定义和给定的运动方程出发，并假设处于欠阻尼状态 $0  \\gamma  \\omega_{0}$，完成以下任务：\n\n1. 推导平衡状态下所有实数 $t$ 的 $C_{v}(t)$ 的闭式表达式。\n2. 用 $\\gamma$、$\\omega_{0}$、 $k_{B}$、 $T$ 和 $\\omega$ 推导速度功率谱 $S_{vv}(\\omega)$ 的闭式表达式。\n3. 利用你的谱结果，确定 $\\omega\\approx \\omega_{0}$ 附近的线型，计算其半峰半宽（以角频率为单位），并解释 $\\gamma$ 如何通过谱展宽和相关的振动寿命来表征固体中非谐散射的强度。\n\n你最终的方框答案必须是你得到的 $S_{vv}(\\omega)$ 的闭式解析表达式，表示为 $\\omega$、$\\gamma$、$\\omega_{0}$、$k_{B}$ 和 $T$ 的函数。方框内的表达式不应包含任何单位。不需要进行数值计算或四舍五入。",
            "solution": "所述问题是统计物理学中一个标准的、适定的问题，因此被认为是**有效的**。我们可以继续进行求解。\n\n该问题要求对由朗之万方程描述的阻尼谐振子进行三部分的推导。我们将首先推导速度功率谱 $S_{vv}(\\omega)$，然后是速度自相关函数 (VACF) $C_{v}(t)$，最后分析谱线形状。\n\n**第2部分：速度功率谱 $S_{vv}(\\omega)$ 的推导**\n\n我们首先对朗之万运动方程应用指定的傅里叶变换：\n$$\n\\ddot{x}(t) + 2\\gamma\\dot{x}(t) + \\omega_0^2 x(t) = \\eta(t)\n$$\n根据时间导数 $\\dot{f}(t)$ 的傅里叶变换为 $i\\omega f(\\omega)$ 的约定，频域中的方程变为：\n$$\n(-\\omega^2 + 2i\\gamma\\omega + \\omega_0^2) x(\\omega) = \\eta(\\omega)\n$$\n其中 $x(\\omega)$ 和 $\\eta(\\omega)$ 分别是 $x(t)$ 和 $\\eta(t)$ 的傅里叶变换。我们可以解出 $x(\\omega)$：\n$$\nx(\\omega) = \\frac{\\eta(\\omega)}{\\omega_0^2 - \\omega^2 + 2i\\gamma\\omega}\n$$\n速度 $v(t)$ 定义为 $v(t) = \\dot{x}(t)$。其傅里叶变换为 $v(\\omega) = i\\omega x(\\omega)$。代入 $x(\\omega)$ 的表达式得到：\n$$\nv(\\omega) = \\frac{i\\omega}{\\omega_0^2 - \\omega^2 + 2i\\gamma\\omega} \\eta(\\omega)\n$$\n该关系的形式为 $v(\\omega) = \\chi_v(\\omega) \\eta(\\omega)$，其中 $\\chi_v(\\omega)$ 是速度响应函数：\n$$\n\\chi_v(\\omega) = \\frac{i\\omega}{\\omega_0^2 - \\omega^2 + 2i\\gamma\\omega}\n$$\n根据维纳-辛钦定理和线性响应理论，输出信号的功率谱 $S_{vv}(\\omega)$ 与输入噪声的功率谱 $S_{\\eta\\eta}(\\omega)$ 通过响应函数的模平方相关联：\n$$\nS_{vv}(\\omega) = |\\chi_v(\\omega)|^2 S_{\\eta\\eta}(\\omega)\n$$\n噪声功率谱 $S_{\\eta\\eta}(\\omega)$ 是噪声自相关函数 $\\langle \\eta(t)\\eta(0) \\rangle$ 的傅里叶变换。给定 $\\langle \\eta(t)\\eta(t') \\rangle = 4\\gamma k_B T \\delta(t-t')$，我们有：\n$$\nS_{\\eta\\eta}(\\omega) = \\int_{-\\infty}^{\\infty} e^{i\\omega t} \\langle \\eta(t)\\eta(0) \\rangle dt = \\int_{-\\infty}^{\\infty} e^{i\\omega t} \\left(4\\gamma k_B T \\delta(t)\\right) dt = 4\\gamma k_B T\n$$\n现在，我们计算响应函数的模平方：\n$$\n|\\chi_v(\\omega)|^2 = \\left| \\frac{i\\omega}{\\omega_0^2 - \\omega^2 + 2i\\gamma\\omega} \\right|^2 = \\frac{|i\\omega|^2}{|(\\omega_0^2 - \\omega^2) + i(2\\gamma\\omega)|^2} = \\frac{\\omega^2}{(\\omega_0^2 - \\omega^2)^2 + (2\\gamma\\omega)^2} = \\frac{\\omega^2}{(\\omega_0^2 - \\omega^2)^2 + 4\\gamma^2\\omega^2}\n$$\n将这些结果代回 $S_{vv}(\\omega)$ 的方程，我们得到速度功率谱的最终表达式：\n$$\nS_{vv}(\\omega) = \\frac{4\\gamma k_B T \\omega^2}{(\\omega_0^2 - \\omega^2)^2 + 4\\gamma^2\\omega^2}\n$$\n\n**第1部分：速度自相关函数 $C_v(t)$ 的推导**\n\n$C_v(t)$ (VACF) 是 $S_{vv}(\\omega)$ 的傅里叶逆变换。然而，我们也可以使用回归假设来推导它，该假设指出平衡相关函数的时间演化模拟了诱导宏观扰动的弛豫过程。对于 $t0$，$C_v(t) = \\langle v(t)v(0) \\rangle$ 是通过求解 $v(t)$ 的齐次运动方程得到的，其初始条件在平衡系综上平均。对于该系统，这意味着 $\\langle v(0)^2 \\rangle = k_B T$ （根据能量均分定理，质量 $m=1$）和 $\\langle x(0)v(0) \\rangle = 0$。因此，我们求解齐次方程 $\\ddot{x} + 2\\gamma\\dot{x} + \\omega_0^2 x = 0$，初始条件为 $x(0)=0$ 和 $v(0)=v_0$。\n\n特征方程为 $r^2+2\\gamma r+\\omega_0^2=0$，其根为 $r=-\\gamma \\pm i\\omega_1$，其中 $\\omega_1 \\equiv \\sqrt{\\omega_0^2 - \\gamma^2}$ 在欠阻尼状态（$0  \\gamma  \\omega_0$）下为实数。满足 $x(0)=0$ 的 $x(t)$ 的解是 $x(t) = B e^{-\\gamma t}\\sin(\\omega_1 t)$。相应的速度是 $v(t) = \\dot{x}(t) = B e^{-\\gamma t}(-\\gamma \\sin(\\omega_1 t) + \\omega_1 \\cos(\\omega_1 t))$。条件 $v(0)=v_0$ 给出 $v_0 = B\\omega_1$，因此 $B = v_0/\\omega_1$。随后的速度是：\n$$\nv(t) = v_0 e^{-\\gamma t}\\left(\\cos(\\omega_1 t) - \\frac{\\gamma}{\\omega_1}\\sin(\\omega_1 t)\\right)\n$$\n为了求得 $C_v(t)$，我们将 $v_0^2$ 替换为其热平均值 $\\langle v(0)^2 \\rangle = k_B T$：\n$$\nC_v(t) = k_B T e^{-\\gamma t}\\left(\\cos(\\omega_1 t) - \\frac{\\gamma}{\\omega_1}\\sin(\\omega_1 t)\\right), \\quad \\text{for } t > 0\n$$\n由于 $C_v(t)$ 是时间的偶函数，我们使用绝对值 $|t|$ 将其推广到所有实数 $t$：\n$$\nC_v(t) = k_B T e^{-\\gamma|t|}\\left(\\cos(\\omega_1 t) - \\frac{\\gamma}{\\omega_1}\\sin(\\omega_1 |t|)\\right)\n$$\n\n**第3部分：谱线形状分析**\n\n为了分析 $S_{vv}(\\omega)$ 在共振点 $\\omega \\approx \\omega_0$ 附近的线型，我们采用近共振近似。我们将分母项重写为 $\\omega_0^2 - \\omega^2 = (\\omega_0-\\omega)(\\omega_0+\\omega)$ 并近似为 $\\omega_0+\\omega \\approx 2\\omega_0$。分子项 $\\omega^2$ 近似为 $\\omega_0^2$。\n$$\nS_{vv}(\\omega) \\approx \\frac{4\\gamma k_B T \\omega_0^2}{((\\omega_0-\\omega)2\\omega_0)^2 + 4\\gamma^2\\omega_0^2} = \\frac{4\\gamma k_B T \\omega_0^2}{4\\omega_0^2(\\omega-\\omega_0)^2 + 4\\gamma^2\\omega_0^2} = \\frac{k_B T \\gamma}{(\\omega-\\omega_0)^2 + \\gamma^2}\n$$\n此表达式描述了一个以 $\\omega_0$ 为中心的洛伦兹线型。其峰值（在 $\\omega = \\omega_0$ 处）为 $S_{peak} = k_B T / \\gamma$。半峰半宽 (HWHM) 是指当函数值达到峰值一半时，对应频率与中心频率之差的绝对值 $|\\omega-\\omega_0|$。\n$$\n\\frac{k_B T \\gamma}{(\\omega-\\omega_0)^2 + \\gamma^2} = \\frac{1}{2}\\frac{k_B T}{\\gamma} \\implies 2\\gamma^2 = (\\omega-\\omega_0)^2 + \\gamma^2 \\implies |\\omega-\\omega_0| = \\gamma\n$$\nHWHM 为 $\\gamma$。\n\n在固态物理学的背景下，该模型将微观散射与宏观可观测量联系起来。在理想的谐波晶体中，声子（量子化的晶格振动）具有无限的寿命。原子间势中的非谐项引起声子-声子散射，这限制了它们的寿命。朗之万模型中的阻尼系数 $\\gamma$ 代表了这种非谐散射的强度。推导出的谱展宽 (HWHM = $\\gamma$) 是这些散射事件的直接结果。振动寿命 $\\tau$ 是 VACF 的衰减常数，$\\tau = 1/\\gamma$。因此，谱峰的半峰全宽 (FWHM = $2\\gamma$) 与振动寿命成反比，$FWHM = 2/\\tau$。因此，更强的非谐性（更大的 $\\gamma$）会导致更短的寿命和在测量的振动谱中更宽的峰。",
            "answer": "$$\n\\boxed{\\frac{4\\gamma k_{B} T \\omega^{2}}{\\left(\\omega_{0}^{2} - \\omega^{2}\\right)^{2} + 4\\gamma^{2}\\omega^{2}}}\n$$"
        },
        {
            "introduction": "从理想的解析世界进入计算数据的实际领域，下一个练习将探讨分子动力学轨迹信号处理的一个关键方面。虽然位移 $u(t)$ 和速度 $v(t)$ 通过简单的时间导数联系在一起，但在面对噪声、漂移或扩散等实际缺陷时，从它们推导出的振动态密度（VDOS）估计量的表现可能大相径庭。这个动手编程练习 () 将指导您实现并比较这两种方法，从而揭示为何基于速度的方法通常更稳健，并且不易受低频伪影的影响。",
            "id": "3501987",
            "problem": "要求您设计并实现一个完整、可运行的程序，该程序从运动学和静态随机过程的基本定义出发，使用速度和位移自相关函数构建并比较两种振动态密度估计量。您的实现必须完全自包含且确定性。\n\n您必须使用的基本依据如下。自由度的位移是时间的函数，表示为 $u(t)$，其速度由时间导数定义为 $v(t) = \\frac{du(t)}{dt}$。对于任何均值为零的宽义平稳实值时间序列 $x(t)$，其自相关函数为 $C_{xx}(\\tau) = \\mathbb{E}[x(t)x(t+\\tau)]$，且维纳-辛钦定理指出，功率谱密度是自相关函数的傅里叶变换。您必须仅从这些陈述开始进行推导和设计，不得使用任何简化公式。\n\n您的程序必须对指定的测试套件执行以下操作。\n\n- 在均匀网格 $t_n = n\\,\\Delta t$（其中 $n \\in \\{0,1,\\dots,N-1\\}$）上构建 $u(t)$ 和 $v(t)$ 的离散时间合成轨迹，并附加独立的加性高斯测量噪声，使用指定的随机种子以确保可复现性。对于谐波内容，在位移中使用余弦模态的有限和，其振幅和相位应根据种子确定性地生成。相应的无噪声速度必须是无噪声位移的精确时间导数。然后，在位移和速度时间序列上独立地添加指定的测量噪声。当指定了位移的线性漂移斜率时，在添加测量噪声之前，将 $d\\,t_n$ 加到 $u(t_n)$ 上，并将相应的常数项 $d$ 加到 $v(t_n)$ 上。\n- 对于 $u$ 和 $v$ 中的每一个，计算离散样本自相关函数 $\\hat{C}_{xx}[k]$，使用减去均值和无偏归一化，其中 $k$ 是以样本为单位的离散延迟。对自相关序列应用汉宁窗以减轻截断效应。计算加窗自相关函数的单边离散时间傅里叶变换，以获得在角频率 $\\omega_k = \\frac{2\\pi k}{N \\Delta t}$（其中 $k \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$）上采样的非负谱。\n- 仅使用由 $v = du/dt$ 和维纳-辛钦定理所蕴含的 $u$ 和 $v$ 之间的关系（不得使用任何其他启发式简化方法），在正角频率上构建两个非负的振动态密度估计量：一个基于速度自相关，另一个基于位移自相关。仅限于 $\\omega  0$，并对每个估计量进行归一化，使其在正角频率上的黎曼和等于 $1$，使用角频率频箱宽度 $\\Delta\\omega = \\frac{2\\pi}{N \\Delta t}$。您的归一化过程必须是显式的，并在程序内部完成。\n- 对于每个测试用例，计算以下量化指标：\n  1. 两个归一化估计量的主导角频率（最大值位置）之间的绝对差，以 $\\mathrm{rad/ps}$ 为单位表示，并四舍五入到三位小数。\n  2. 低频泄漏的比率，定义为由基于位移的估计量计算的在区间 $\\omega \\in [0,\\omega_c]$ 上的归一化积分密度除以由基于速度的估计量计算的该值，四舍五入到三位小数。使用每个用例中给出的角频率阈值 $\\omega_c$，并通过间距为 $\\Delta\\omega$ 的离散黎曼和进行积分。\n  3. 对于明确涉及非平稳运动且无真实振动内容的情况，返回一个布尔值，指示基于位移的估计量的低频泄漏是否严格大于基于速度的估计量的五倍。\n\n所有测试用例的通用规范：\n\n- 使用时间步长 $\\Delta t = 0.001\\,\\mathrm{ps}$，总样本数 $N = 16384$，以及对任何随机分量使用随机种子 $12345$。\n- 谐波模态的相位必须根据种子确定性地生成，其方式不应在两个估计量之间引入偏差。\n- 在计算自相关之前，从每个时间序列中独立减去其样本均值。\n- 使用无偏自相关归一化，其中延迟 $k$ 的项除以重叠样本数 $N-k$。\n- 在进行离散傅里叶变换之前，对自相关序列应用汉宁窗 $w[k] = \\tfrac{1}{2}\\left(1 - \\cos\\left(\\tfrac{2\\pi k}{N-1}\\right)\\right)$。\n- 对于估计量的归一化，仅在严格为正的角频率（不包括 $\\omega=0$）上进行积分，并确保在该正频率集合上的黎曼和等于 $1$。\n\n测试套件：\n\n- 用例 A（单锐模态，低噪声，无漂移）：在位移中使用一个谐波模态，角频率 $\\omega_0 = 4.0\\,\\mathrm{rad/ps}$，振幅 $A_0 = 0.10\\,\\mathrm{nm}$。无漂移。高斯测量噪声标准差，位移为 $\\sigma_u = 0.001\\,\\mathrm{nm}$，速度为 $\\sigma_v = 0.001\\,\\mathrm{nm/ps}$。使用低频阈值 $\\omega_c = 0.5\\,\\mathrm{rad/ps}$。输出主导频率绝对差，为浮点数，单位为 $\\mathrm{rad/ps}$，四舍五入到三位小数。\n- 用例 B（双模态带线性漂移）：在位移中使用两个谐波模态，角频率 $\\omega_1 = 1.0\\,\\mathrm{rad/ps}$ 和 $\\omega_2 = 8.0\\,\\mathrm{rad/ps}$，振幅 $A_1 = 0.08\\,\\mathrm{nm}$ 和 $A_2 = 0.05\\,\\mathrm{nm}$。在添加测量噪声之前，在位移中添加线性漂移斜率 $d = 0.01\\,\\mathrm{nm/ps}$（并在速度中添加相应的恒定漂移）。高斯测量噪声标准差 $\\sigma_u = 0.002\\,\\mathrm{nm}$ 和 $\\sigma_v = 0.002\\,\\mathrm{nm/ps}$。使用低频阈值 $\\omega_c = 0.5\\,\\mathrm{rad/ps}$。输出低频泄漏的比率（基于位移的除以基于速度的），为浮点数，四舍五入到三位小数。\n- 用例 C（类布朗运动的非平稳位移）：生成一个速度时间序列作为均值为零、标准差为 $\\sigma_v = 0.02\\,\\mathrm{nm/ps}$ 的独立高斯样本，然后通过累积时间积分 $u(t_{n+1}) = u(t_n) + v(t_n)\\,\\Delta t$ 构建位移，从 $u(0)=0$ 开始。在位移上添加标准差为 $\\sigma_u = 0.002\\,\\mathrm{nm}$ 的高斯测量噪声，在速度上添加标准差为 $\\sigma_v^{\\text{meas}} = 0.002\\,\\mathrm{nm/ps}$ 的高斯测量噪声。使用低频阈值 $\\omega_c = 0.5\\,\\mathrm{rad/ps}$。输出一个布尔值，指示基于位移的估计量的低频泄漏是否超过基于速度的估计量的五倍。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，包含用例 A、用例 B 和用例 C 的结果，形式为方括号括起来的逗号分隔列表，其中前两个条目是按上述规定四舍五入的浮点数，第三个条目是布尔值。例如，一个带有占位符的输出看起来像 [$x,y,z$]，其中 $x$ 和 $y$ 是三位小数的浮点数，$z$ 是 True 或 False。\n\n所有物理单位必须按规定遵守，角频率单位为 $\\mathrm{rad/ps}$，位移单位为 $\\mathrm{nm}$，任何布尔值必须以规范的编程语言布尔形式返回。不允许外部输入；所有参数和随机种子均由此规范固定。",
            "solution": "该问题被评估为有效，因为它在科学上是合理的、良态的、客观的且内部一致。它在信号处理和统计物理领域提出了一个定义明确的计算任务，没有任何逻辑或事实上的缺陷。\n\n在此，我们根据要求从第一性原理出发，给出一个完整的解决方案。目标是构建并比较两种振动态密度（VDOS）估计量，一种基于速度自相关函数（VACF），另一种基于位移自相关函数（DACF）。\n\n**1. 理论基础：从运动学到谱关系**\n\n问题始于位移 $u(t)$ 和速度 $v(t)$ 之间的基本运动学关系：\n$$ v(t) = \\frac{du(t)}{dt} $$\n对于一个均值为零的宽义平稳随机过程 $x(t)$，其自相关函数定义为 $C_{xx}(\\tau) = \\mathbb{E}[x(t)x(t+\\tau)]$，其中 $\\mathbb{E}[\\cdot]$ 表示期望算子。我们寻求位移自相关 $C_{uu}(\\tau)$ 与速度自相关 $C_{vv}(\\tau)$ 之间的关系。\n\n首先，让我们将互相关 $C_{vu}(\\tau) = \\mathbb{E}[v(t)u(t+\\tau)]$ 与 $C_{uu}(\\tau)$ 联系起来。利用速度的定义：\n$$ C_{vu}(\\tau) = \\mathbb{E}\\left[ \\frac{du(t)}{dt} u(t+\\tau) \\right] $$\n对于平稳过程，一个关键属性是 $\\mathbb{E}[A'(t)B(t+\\tau)] = -\\frac{d}{d\\tau} \\mathbb{E}[A(t)B(t+\\tau)]$。应用此属性可得：\n$$ C_{vu}(\\tau) = -\\frac{d}{d\\tau} \\mathbb{E}[u(t)u(t+\\tau)] = -\\frac{dC_{uu}(\\tau)}{d\\tau} $$\n接下来，我们用互相关来表示 $C_{vv}(\\tau)$。使用属性 $\\mathbb{E}[A(t)B'(t+\\tau)] = \\frac{d}{d\\tau}\\mathbb{E}[A(t)B(t+\\tau)]$:\n$$ C_{vv}(\\tau) = \\mathbb{E}[v(t)v(t+\\tau)] = \\mathbb{E}\\left[v(t)\\frac{du(t+\\tau)}{d(t+\\tau)}\\right] = \\frac{d}{d\\tau}\\mathbb{E}[v(t)u(t+\\tau)] = \\frac{dC_{vu}(\\tau)}{d\\tau} $$\n代入 $C_{vu}(\\tau)$ 的表达式，我们得到两个自相关函数之间的基本关系：\n$$ C_{vv}(\\tau) = \\frac{d}{d\\tau} \\left( -\\frac{dC_{uu}(\\tau)}{d\\tau} \\right) = -\\frac{d^2 C_{uu}(\\tau)}{d\\tau^2} $$\n维纳-辛钦定理指出，功率谱密度（PSD）$S_{xx}(\\omega)$ 是自相关函数的傅里叶变换，$S_{xx}(\\omega) = \\mathcal{F}[C_{xx}(\\tau)](\\omega)$。一个 $n$ 阶导数的傅里叶变换由 $\\mathcal{F}[f^{(n)}(\\tau)](\\omega) = (i\\omega)^n \\mathcal{F}[f(\\tau)](\\omega)$ 给出。将此应用于我们的自相关函数关系：\n$$ S_{vv}(\\omega) = \\mathcal{F}[C_{vv}(\\tau)] = \\mathcal{F}\\left[-\\frac{d^2 C_{uu}(\\tau)}{d\\tau^2}\\right] = -(i\\omega)^2 \\mathcal{F}[C_{uu}(\\tau)] = -(-\\omega^2) S_{uu}(\\omega) $$\n这得到了频域中的核心方程：\n$$ S_{vv}(\\omega) = \\omega^2 S_{uu}(\\omega) $$\n\n**2. 振动态密度（VDOS）估计量**\n\n在统计力学中，振动态密度 $g(\\omega)$ 描述了振动模态按频率的分布。总动能与系统自由度速度平方的总和有关。因此，VDOS 自然地被定义为与速度涨落的功率谱成正比。\n\n因此，基于速度的 VDOS 估计量 $g_v(\\omega)$ 被认为与速度功率谱成正比：\n$$ g_v(\\omega) \\propto S_{vv}(\\omega) $$\n利用推导出的谱关系，我们可以从位移数据构建一个类似的估计量。为了获得 VDOS，我们必须首先从位移谱计算速度谱，这涉及到乘以 $\\omega^2$。因此，基于位移的 VDOS 估计量 $g_u(\\omega)$ 定义为：\n$$ g_u(\\omega) \\propto \\omega^2 S_{uu}(\\omega) $$\n理论上，对于一个完全平稳的过程，这两个估计量 $g_v(\\omega)$ 和 $g_u(\\omega)$ 应该是相同的。然而，在实践中，它们对噪声、有限样本效应以及像漂移或扩散这样的非平稳性的响应不同，而这正是本问题所研究的内容。\n\n**3. 计算算法**\n\n实现过程遵循一个离散信号处理流程，对每个指定的测试用例进行处理。\n\n**3.1. 数据生成**\n对于每个用例，在网格 $t_n = n\\Delta t$（其中 $n \\in \\{0, \\dots, N-1\\}$）上生成位移 $u(t_n)$ 和速度 $v(t_n)$ 的合成时间序列。\n- **谐波内容（用例 A, B）：** 构建位移的余弦函数之和及其解析时间导数作为速度。对每个模态使用从指定种子确定性生成的随机相位。\n- **扩散内容（用例 C）：** 生成一个速度时间序列作为离散高斯白噪声。然后通过累积离散积分 $u(t_{n+1}) = u(t_n) + v(t_n)\\Delta t$ 获得位移，模拟随机游走（布朗运动）。\n- **漂移和噪声：** 在指定的情况下，向清洁位移轨迹添加线性漂移，向速度轨迹添加恒定漂移。最后，向两个时间序列添加独立的高斯测量噪声。\n\n**3.2. 信号处理流程**\n对于每个时间序列（$u$ 和 $v$）：\n1.  **均值减法：** 从时间序列中减去样本均值，以满足 ACF 计算的零均值假设。\n2.  **自相关函数：** 计算离散延迟 $k \\in \\{0, \\dots, N-1\\}$ 的无偏样本自相关函数 $\\hat{C}_{xx}[k]$。其定义为 $\\hat{C}_{xx}[k] = \\frac{1}{N-k} \\sum_{n=0}^{N-1-k} x'_{n}x'_{n+k}$，其中 $x'$ 是减去均值的序列。为此，使用 `scipy.signal.correlate` 提供的基于 FFT 的高效算法。\n3.  **加窗：** 将汉宁窗 $w[k] = \\tfrac{1}{2}\\left(1 - \\cos\\left(\\tfrac{2\\pi k}{N-1}\\right)\\right)$ 应用于计算出的整个 ACF 长度，即 $\\hat{C}^{\\text{win}}_{xx}[k] = \\hat{C}_{xx}[k] \\cdot w[k]$，以减少信号截断引起的频谱泄漏。\n4.  **功率谱密度：** 从加窗的 ACF 计算单边 PSD $\\hat{S}_{xx}(\\omega_j)$。这是通过对加窗 ACF 序列进行单边离散傅里叶变换（`rfft`）并取其实部来实现的。任何由数值不精确导致的微小负值都被裁剪为零，以确保谱的非负性。\n\n**3.3. VDOS 构建与归一化**\n未归一化的离散 VDOS 估计量构建如下：\n$$ \\hat{g}_v[\\omega_j] = \\hat{S}_{vv}[\\omega_j] \\quad \\text{和} \\quad \\hat{g}_u[\\omega_j] = \\omega_j^2 \\hat{S}_{uu}[\\omega_j] $$\n其中 $\\omega_j = \\frac{2\\pi j}{N \\Delta t}$ 是离散角频率。然后对每个估计量进行归一化，使其在严格正频率（$\\omega_j  0$）上的黎曼和等于 1。归一化常数 $K$ 是该和的倒数：$K = \\left( \\sum_{j=1}^{\\lfloor N/2 \\rfloor} \\hat{g}[\\omega_j] \\Delta\\omega \\right)^{-1}$，其中 $\\Delta\\omega = \\frac{2\\pi}{N \\Delta t}$。归一化后的 VDOS 为 $g_{\\text{norm}}[\\omega_j] = K \\cdot \\hat{g}[\\omega_j]$。\n\n**4. 指标计算**\n最后一步是根据归一化后的 VDOS 估计量 $g_u$ 和 $g_v$ 计算指定的指标：\n- **指标 A（主导频率差）：** 找到每个 VDOS（对于 $\\omega  0$）最大值对应的角频率 $\\omega_{\\max}$。计算绝对差 $|\\omega_{\\max,u} - \\omega_{\\max,v}|$。\n- **指标 B（低频泄漏比）：** 对于每个估计量，通过离散黎曼和计算在区间 $\\omega \\in [0, \\omega_c]$ 上的积分密度。然后计算基于位移的积分与基于速度的积分之比。\n- **指标 C（非平稳泄漏检查）：** 对于布朗运动情况，计算相同的泄漏积分。返回一个布尔值，指示基于位移的估计量的泄漏是否严格大于基于速度的估计量的五倍。该指标突出了基于 VACF 的方法在处理非平稳扩散运动方面的优越鲁棒性，这种运动在基于 DACF 的方法中表现为严重的低频伪影。\n\n这个严格的、基于原理的程序确保了两种估计量之间的比较是在坚实的理论和计算基础上进行的。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import correlate\nfrom scipy.fft import rfft, rfftfreq\n\ndef solve():\n    \"\"\"\n    Constructs and compares two estimators of the vibrational density of states\n    using velocity and displacement autocorrelation functions, based on synthetic data.\n    \"\"\"\n    # --- Common Specifications ---\n    DT = 0.001  # time step in ps\n    N = 16384     # number of samples\n    SEED = 12345\n    RNG = np.random.default_rng(SEED)\n\n    # --- Test Suite Parameters ---\n    test_cases_params = [\n        {\n            \"case\": \"A\",\n            \"modes\": [(4.0, 0.10)],  # (omega_rad_ps, amplitude_nm)\n            \"drift_slope\": 0.0,\n            \"sigma_u\": 0.001,\n            \"sigma_v\": 0.001,\n            \"omega_c\": 0.5,\n        },\n        {\n            \"case\": \"B\",\n            \"modes\": [(1.0, 0.08), (8.0, 0.05)],\n            \"drift_slope\": 0.01,\n            \"sigma_u\": 0.002,\n            \"sigma_v\": 0.002,\n            \"omega_c\": 0.5,\n        },\n        {\n            \"case\": \"C\",\n            \"is_brownian\": True,\n            \"brownian_sigma_v\": 0.02, # For generating the core signal\n            \"drift_slope\": 0.0,\n            \"sigma_u\": 0.002, # Measurement noise on u\n            \"sigma_v\": 0.002, # Measurement noise on v\n            \"omega_c\": 0.5,\n        },\n    ]\n\n    results = []\n\n    def analyze_case(params):\n        \"\"\"\n        Performs the full analysis pipeline for a single test case.\n        \"\"\"\n        # Time array\n        t = np.arange(N) * DT\n\n        # --- 1. Generate Synthetic Trajectories ---\n        u_clean = np.zeros(N, dtype=np.float64)\n        v_clean = np.zeros(N, dtype=np.float64)\n\n        if params.get(\"is_brownian\", False):\n            # Case C: Brownian-like motion\n            v_clean = RNG.normal(loc=0.0, scale=params[\"brownian_sigma_v\"], size=N)\n            u_clean = np.cumsum(v_clean) * DT\n        else:\n            # Cases A, B: Harmonic modes\n            num_modes = len(params[\"modes\"])\n            phases = RNG.uniform(0, 2 * np.pi, size=num_modes)\n            for i, (omega, amplitude) in enumerate(params[\"modes\"]):\n                phi = phases[i]\n                u_clean += amplitude * np.cos(omega * t + phi)\n                v_clean += -amplitude * omega * np.sin(omega * t + phi)\n        \n        # Add linear drift if specified\n        drift = params[\"drift_slope\"]\n        if drift != 0.0:\n            u_clean += drift * t\n            v_clean += drift\n            \n        # Add independent Gaussian measurement noise\n        u_noisy = u_clean + RNG.normal(loc=0.0, scale=params[\"sigma_u\"], size=N)\n        v_noisy = v_clean + RNG.normal(loc=0.0, scale=params[\"sigma_v\"], size=N)\n\n        # --- 2. Compute Power Spectral Density (PSD) ---\n        def get_psd(series):\n            # i. Mean subtraction\n            series_mean_sub = series - np.mean(series)\n            \n            # ii. Unbiased Autocorrelation Function (ACF)\n            unscaled_acf = correlate(series_mean_sub, series_mean_sub, mode='full', method='fft')[N - 1:]\n            normalization_factors = N - np.arange(N)\n            acf = unscaled_acf / normalization_factors\n            \n            # iii. Hann Windowing\n            hann_window = 0.5 * (1 - np.cos(2 * np.pi * np.arange(N) / (N - 1)))\n            wacf = acf * hann_window\n            \n            # iv. PSD from FFT of windowed ACF\n            psd = np.real(rfft(wacf))\n            psd[psd  0] = 0  # Ensure non-negativity\n            \n            return psd\n\n        S_uu = get_psd(u_noisy)\n        S_vv = get_psd(v_noisy)\n        \n        # Frequency axis (angular)\n        omega = 2 * np.pi * rfftfreq(N, d=DT)\n        \n        # --- 3. Construct and Normalize VDOS Estimators ---\n        g_u_unnorm = (omega**2) * S_uu\n        g_v_unnorm = S_vv\n\n        # Normalization over strictly positive frequencies (omega > 0)\n        d_omega = omega[1] - omega[0]\n        \n        norm_u_integral = np.sum(g_u_unnorm[1:]) * d_omega\n        g_u = g_u_unnorm / norm_u_integral if norm_u_integral > 0 else np.zeros_like(g_u_unnorm)\n\n        norm_v_integral = np.sum(g_v_unnorm[1:]) * d_omega\n        g_v = g_v_unnorm / norm_v_integral if norm_v_integral > 0 else np.zeros_like(g_v_unnorm)\n\n        # --- 4. Compute and Return Required Metrics ---\n        if params[\"case\"] == \"A\":\n            # argmax on omega > 0 part of the spectrum\n            idx_max_u = np.argmax(g_u[1:]) + 1\n            idx_max_v = np.argmax(g_v[1:]) + 1\n            freq_diff = abs(omega[idx_max_u] - omega[idx_max_v])\n            return round(freq_diff, 3)\n        \n        elif params[\"case\"] in [\"B\", \"C\"]:\n            omega_c = params[\"omega_c\"]\n            # Find index corresponding to omega_c\n            idx_c = np.searchsorted(omega, omega_c, side='right')\n            # Riemann sum for leakage integral over [0, omega_c]\n            leakage_u = np.sum(g_u[0:idx_c]) * d_omega\n            leakage_v = np.sum(g_v[0:idx_c]) * d_omega\n\n            if params[\"case\"] == \"B\":\n                # Handle potential division by zero\n                ratio = leakage_u / leakage_v if leakage_v != 0 else np.inf\n                return round(ratio, 3)\n            else: # Case C\n                return leakage_u > 5 * leakage_v\n\n    for params in test_cases_params:\n        results.append(analyze_case(params))\n\n    # --- Final Output Formatting ---\n    print(f\"[{results[0]},{results[1]},{results[2]}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们最后的练习在前两个实践的基础上，着手解决计算机模拟的另一个基本限制：有限的模拟时长。著名的 Green-Kubo 关系允许我们通过对 VACF 积分来计算重要的输运系数，例如自扩散系数 $D$。然而，这个积分在形式上需要延伸至无穷长时间，这是任何模拟都无法实现的。本练习 () 介绍了一种强大且广泛使用的技术来克服数据截断问题，它将指导您结合直接数值积分与解析外推的方法，通过一个有物理动机的拟合模型来处理 VACF 的长时尾部，从而得到更准确的计算结果。",
            "id": "3501959",
            "problem": "您将获得来自分子动力学 (MD) 模拟的速度自相关函数 (VACF) 的截断数值样本。VACF 定义为系综平均 $C_v(t) = \\langle \\mathbf{v}(t)\\cdot \\mathbf{v}(0) \\rangle$，其中 $\\mathbf{v}(t)$ 是粒子在时间 $t$ 的速度。您的任务是设计并实现一个自扩散系数 $D$ 的估算器。该估算器需要通过将一个具有物理动机的函数形式拟合到可及的拖尾部分，并解析外推出超出截断时间的贡献，来解释缺失的长时拖尾。\n\n该估算器必须建立在第一性原理以及计算材料科学中合法且广为接受的定义之上。它必须使用一个具有物理动机的拖尾模型，例如 Kohlrausch–Williams–Watts (KWW) 拉伸指数函数 $C_{\\mathrm{tail}}(t) = A \\exp\\!\\big(-(t/\\tau)^{\\beta}\\big)$，其参数 $A$、$\\tau$ 和 $\\beta$ 被约束在具有物理意义的域内。模型的选择依据必须依赖于关于弛豫过程和振动谱的物理推理，而不是对公式的死记硬背。\n\n在以下要求下实现该估算器：\n- 使用具有均匀采样间隔 $\\Delta t$ 和截断时间 $t_{\\max}$ 的截断离散 VACF 样本 $\\{C_v(t_n)\\}_{n=0}^{N}$，并将 VACF 视为三维空间中完整速度矢量 $\\mathbf{v}(t)$ 的标量相关性。\n- 在 $[0, t_{\\max}]$ 上对可用的 VACF 进行数值积分，并加上基于对可及拖尾部分的拟合得到的余项 $\\int_{t_{\\max}}^{\\infty} C_{\\mathrm{tail}}(t)\\,\\mathrm{d}t$ 的解析外推。将拟合参数约束为 $A \\ge 0$、$\\tau  0$ 和 $0  \\beta \\le 1$，并确保在拟合不适定（例如，拖尾数据点太少）时估算器具有鲁棒性，在这种情况下将拖尾贡献默认为零。\n- 所有最终报告的扩散系数 $D$ 均以 $\\mathrm{m^2/s}$ 为单位表示。\n\n按如下方式为可测试性进行设计。您的程序必须使用物理上合理的合成模型在内部构建 VACF 测试数据，而无需读取任何外部输入。使用 Boltzmann 常数 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\,\\mathrm{J/K}$、温度 $T = 300\\,\\mathrm{K}$ 和粒子质量 $m = 1.0\\times 10^{-24}\\,\\mathrm{kg}$，使得初始 VACF 水平为 $C_0 = 3 k_{\\mathrm{B}} T / m$。\n\n提供一个包含三种情况的测试套件：\n- 情况 A（通用，“理想路径”）：一个拉伸指数 VACF $C_v(t) = C_0 \\exp\\!\\big(-(t/\\tau)^{\\beta}\\big)$，采样间隔 $\\Delta t = 2.0\\times 10^{-14}\\,\\mathrm{s}$，采样至 $t_{\\max} = 4.0\\times 10^{-12}\\,\\mathrm{s}$，参数为 $\\tau = 1.5\\times 10^{-12}\\,\\mathrm{s}$ 和 $\\beta = 0.65$。在每个时间点 $t$ 添加了零均值高斯噪声，其标准差等于无噪声 $C_v(t)$ 值的 $0.01$ 倍。\n- 情况 B（边界，短截断）：与情况 A 具有相同的函数形式，但采样间隔为 $\\Delta t = 1.0\\times 10^{-14}\\,\\mathrm{s}$，采样至 $t_{\\max} = 3.0\\times 10^{-13}\\,\\mathrm{s}$，噪声相对水平为 $0.05$。\n- 情况 C（边缘，具有振动振荡的双组分弛豫）：一个长时拉伸指数拖尾与一个短时阻尼振动振荡之和，\n  $$C_v(t) = f_{\\mathrm{kww}} C_0 \\exp\\!\\big(-(t/\\tau_{\\mathrm{long}})^{\\beta_{\\mathrm{long}}}\\big) + f_{\\mathrm{osc}} C_0 \\cos(\\omega t)\\exp\\!\\big(-t/\\tau_{\\mathrm{osc}}\\big),$$\n  参数为 $f_{\\mathrm{kww}} = 0.5$, $f_{\\mathrm{osc}} = 0.5$, $\\tau_{\\mathrm{long}} = 2.0\\times 10^{-12}\\,\\mathrm{s}$, $\\beta_{\\mathrm{long}} = 0.60$, $\\omega = 2\\pi\\times 1.0\\times 10^{12}\\,\\mathrm{rad/s}$ 和 $\\tau_{\\mathrm{osc}} = 4.0\\times 10^{-13}\\,\\mathrm{s}$，采样间隔 $\\Delta t = 2.0\\times 10^{-14}\\,\\mathrm{s}$，采样至 $t_{\\max} = 5.0\\times 10^{-12}\\,\\mathrm{s}$，噪声相对水平为 $0.02$。\n\n您的程序应使用截断数据的最后一部分来拟合拉伸指数拖尾（选择最后可用时间的一部分，以便拟合目标是长时衰减），计算截断 VACF 在 $[0,t_{\\max}]$ 上的数值积分，加上解析拖尾积分，并转换为三维空间中的扩散系数。所有浮点输出都必须以 $\\mathrm{m^2/s}$ 为单位报告。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三种情况的扩散估算值，格式为方括号括起来的逗号分隔列表，例如 $[d_A,d_B,d_C]$，其中 $d_A$、$d_B$ 和 $d_C$ 是以 $\\mathrm{m^2/s}$ 为单位的十进制浮点数，并以小数点后六位的科学记数法打印。",
            "solution": "该问题是有效的。它在科学上植根于统计力学的原理，特别是关于输运系数的 Green-Kubo 关系。\n\n该问题是适定的、客观的，并为构建唯一且可验证的解提供了一套完整的参数和约束。\n\n在三维系统中，粒子的自扩散系数 $D$ 与其速度涨落的时间相关性有着根本的联系。这种关系由 Green-Kubo 公式正式表达：\n$$\nD = \\frac{1}{3} \\int_{0}^{\\infty} C_v(t) \\, \\mathrm{d}t\n$$\n其中 $C_v(t)$ 是速度自相关函数 (VACF)，定义为系综平均 $C_v(t) = \\langle \\mathbf{v}(t) \\cdot \\mathbf{v}(0) \\rangle$。系数 $\\frac{1}{3}$ 源于考虑在三个各向同性空间维度中的扩散。VACF 的初始值 $C_v(0) = \\langle |\\mathbf{v}(0)|^2 \\rangle$ 由能量均分定理确定，该定理指出平均动能为 $\\frac{3}{2} k_{\\mathrm{B}} T$。这得出 $C_v(0) = \\frac{3 k_{\\mathrm{B}} T}{m}$，其中 $k_{\\mathrm{B}}$ 是 Boltzmann 常数，$T$ 是绝对温度，$m$ 是粒子质量。\n\n分子动力学 (MD) 模拟以离散时间序列 $\\{C_v(t_n)\\}$ 的形式提供 VACF，该序列以 $\\Delta t$ 的时间间隔采样，直至有限的截断时间 $t_{\\max}$。主要的挑战在于计算 $D$ 的积分延伸至无穷大，而数据却是截断的。仅积分到 $t_{\\max}$ 的朴素方法会因忽略相关函数的长时拖尾贡献而系统性地低估 $D$。\n\n为解决此问题，我们将积分分为两部分：\n$$\n\\int_{0}^{\\infty} C_v(t) \\, \\mathrm{d}t = \\int_{0}^{t_{\\max}} C_v(t) \\, \\mathrm{d}t + \\int_{t_{\\max}}^{\\infty} C_v(t) \\, \\mathrm{d}t\n$$\n第一项，即在已知数据范围 $[0, t_{\\max}]$ 上的积分，可以进行数值计算。对于均匀采样的数据，梯形法则是一种合适且准确的方法：\n$$\nI_{\\text{num}} = \\int_{0}^{t_{\\max}} C_v(t) \\, \\mathrm{d}t \\approx \\Delta t \\left( \\frac{C_v(t_0) + C_v(t_N)}{2} + \\sum_{n=1}^{N-1} C_v(t_n) \\right)\n$$\n其中 $t_n = n \\Delta t$ 且 $t_N = t_{\\max}$。\n\n第二项，即从 $t_{\\max}$ 到无穷大的积分，需要一个 VACF 渐近衰减的模型。在许多复杂和无序的系统中，例如过冷液体或玻璃，弛豫过程不遵循简单的指数衰减。相反，它们表现出一种弛豫时间尺度的分布，这种分布可以很好地由 Kohlrausch–Williams–Watts (KWW) 或“拉伸指数”函数来描述。这是对拖尾行为的一个具有物理动机的选择：\n$$\nC_{\\text{tail}}(t) = A \\exp\\left(-\\left(\\frac{t}{\\tau}\\right)^{\\beta}\\right)\n$$\n该模型的参数是振幅 $A$、特征弛豫时间 $\\tau$ 和拉伸指数 $\\beta$。约束条件为 $A \\ge 0$、$\\tau  0$ 和 $0  \\beta \\le 1$。$\\beta=1$ 的情况对应于简单的指数（Debye）弛豫，而较小的 $\\beta$ 值表示更宽的弛豫速率分布。\n\n估算器按以下步骤进行：\n1.  选取时间序列末尾的一部分数据（可及的拖尾）。\n2.  使用非线性最小二乘拟合程序来确定最佳参数 $(A, \\tau, \\beta)$，使得 KWW 模型在满足物理约束的条件下，能最好地拟合这部分 VACF 数据。\n3.  如果拟合成功，则使用拟合参数解析计算拖尾贡献的积分 $I_{\\text{tail}}$：\n    $$\n    I_{\\text{tail}} = \\int_{t_{\\max}}^{\\infty} A \\exp\\left(-\\left(\\frac{t}{\\tau}\\right)^{\\beta}\\right) \\, \\mathrm{d}t\n    $$\n    为求解此积分，我们进行换元。令 $u = (t/\\tau)^{\\beta}$。则 $t = \\tau u^{1/\\beta}$ 且 $\\mathrm{d}t = \\frac{\\tau}{\\beta} u^{(1/\\beta)-1} \\mathrm{d}u$。积分下限变为 $u_{\\min} = (t_{\\max}/\\tau)^{\\beta}$。积分变换为：\n    $$\n    I_{\\text{tail}} = A \\int_{(t_{\\max}/\\tau)^{\\beta}}^{\\infty} e^{-u} \\left(\\frac{\\tau}{\\beta} u^{(1/\\beta)-1}\\right) \\, \\mathrm{d}u = \\frac{A\\tau}{\\beta} \\int_{(t_{\\max}/\\tau)^{\\beta}}^{\\infty} u^{(1/\\beta)-1} e^{-u} \\, \\mathrm{d}u\n    $$\n    该积分是上不完全伽马函数 $\\Gamma(s, x) = \\int_x^{\\infty} t^{s-1} e^{-t} \\, \\mathrm{d}t$ 的定义。当 $s = 1/\\beta$ 且 $x = (t_{\\max}/\\tau)^{\\beta}$ 时，解析结果为：\n    $$\n    I_{\\text{tail}} = \\frac{A\\tau}{\\beta} \\Gamma\\left(\\frac{1}{\\beta}, \\left(\\frac{t_{\\max}}{\\tau}\\right)^{\\beta}\\right)\n    $$\n4.  总积分为 $I_{\\text{total}} = I_{\\text{num}} + I_{\\text{tail}}$ 之和。\n5.  扩散系数的最终估算值为 $D = \\frac{1}{3} I_{\\text{total}}$。\n6.  为了保证鲁棒性，如果拟合过程失败（例如，由于拖尾部分数据不足或收敛性差），则将拖尾贡献 $I_{\\text{tail}}$ 设为零。这确保估算器总能返回一个值，尽管这个值可能不太准确，它对应于对积分的简单截断。\n\n该实现将为三个测试案例合成 VACF 数据，对每个案例应用此估算程序，并报告所得的扩散系数。合成数据包含噪声和多组分弛豫等现实特征，以测试该方法的鲁棒性和适用性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\nfrom scipy.special import gamma, gammaincc\n\ndef solve():\n    \"\"\"\n    Calculates the self-diffusion coefficient from synthetic VACF data.\n    The estimator combines numerical integration of the available data with an\n    analytical extrapolation of the long-time tail, modeled as a\n    Kohlrausch-Williams-Watts (KWW) stretched exponential function.\n    \"\"\"\n\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"T\": 300.0,\n            \"m\": 1.0e-24,\n            \"dt\": 2.0e-14,\n            \"t_max\": 4.0e-12,\n            \"noise_level\": 0.01,\n            \"model_type\": \"kww\",\n            \"params\": {\"tau\": 1.5e-12, \"beta\": 0.65},\n        },\n        {\n            \"name\": \"Case B\",\n            \"T\": 300.0,\n            \"m\": 1.0e-24,\n            \"dt\": 1.0e-14,\n            \"t_max\": 3.0e-13,\n            \"noise_level\": 0.05,\n            \"model_type\": \"kww\",\n            \"params\": {\"tau\": 1.5e-12, \"beta\": 0.65},\n        },\n        {\n            \"name\": \"Case C\",\n            \"T\": 300.0,\n            \"m\": 1.0e-24,\n            \"dt\": 2.0e-14,\n            \"t_max\": 5.0e-12,\n            \"noise_level\": 0.02,\n            \"model_type\": \"kww_osc\",\n            \"params\": {\n                \"f_kww\": 0.5,\n                \"f_osc\": 0.5,\n                \"tau_long\": 2.0e-12,\n                \"beta_long\": 0.60,\n                \"omega\": 2.0 * np.pi * 1.0e12,\n                \"tau_osc\": 4.0e-13,\n            },\n        },\n    ]\n\n    results = []\n    rng = np.random.default_rng(seed=42)  # For reproducible noise\n\n    for case in test_cases:\n        # 1. Generate synthetic VACF data\n        T, m, dt, t_max = case[\"T\"], case[\"m\"], case[\"dt\"], case[\"t_max\"]\n        C0 = 3.0 * k_B * T / m\n        t_array = np.arange(0, t_max + dt / 2.0, dt)\n        \n        if case[\"model_type\"] == \"kww\":\n            p = case[\"params\"]\n            vacf_noiseless = C0 * np.exp(-((t_array / p[\"tau\"]) ** p[\"beta\"]))\n        elif case[\"model_type\"] == \"kww_osc\":\n            p = case[\"params\"]\n            kww_part = p[\"f_kww\"] * C0 * np.exp(-((t_array / p[\"tau_long\"]) ** p[\"beta_long\"]))\n            osc_part = p[\"f_osc\"] * C0 * np.cos(p[\"omega\"] * t_array) * np.exp(-t_array / p[\"tau_osc\"])\n            vacf_noiseless = kww_part + osc_part\n        \n        noise = rng.normal(loc=0.0, scale=case[\"noise_level\"] * np.abs(vacf_noiseless))\n        vacf_samples = vacf_noiseless + noise\n\n        # 2. Numerical integration of the available VACF\n        numerical_integral = np.trapz(vacf_samples, x=t_array)\n\n        # 3. Fit the tail and calculate the analytical tail integral\n        tail_integral = 0.0\n        \n        # Select the last 40% of the data for fitting the tail\n        tail_fraction = 0.40\n        tail_start_index = int((1.0 - tail_fraction) * len(t_array))\n        \n        # Ensure there are enough points to fit (more than number of parameters)\n        if len(t_array) - tail_start_index > 3:\n            t_tail = t_array[tail_start_index:]\n            vacf_tail = vacf_samples[tail_start_index:]\n\n            def kww_func(t, A, tau, beta):\n                return A * np.exp(-((t / tau) ** beta))\n\n            # Bounds for the fitting parameters\n            bounds = ([0, 1e-16, 1e-6], [np.inf, np.inf, 1.0])\n            \n            # Initial guess for the parameters\n            A_guess = vacf_tail[0] if vacf_tail[0] > 0 else 1.0\n            tau_guess = t_max\n            beta_guess = 0.7\n            p0 = [A_guess, tau_guess, beta_guess]\n            \n            try:\n                popt, _ = curve_fit(kww_func, t_tail, vacf_tail, p0=p0, bounds=bounds, maxfev=5000)\n                A_fit, tau_fit, beta_fit = popt\n\n                # 4. Calculate the analytical integral of the fitted tail\n                # Integral from t_max to infinity of A*exp(-(t/tau)^beta) dt\n                s = 1.0 / beta_fit\n                x = (t_max / tau_fit) ** beta_fit\n                \n                # tail_integral = (A_fit * tau_fit / beta_fit) * Gamma(s, x)\n                # scipy.special.gammaincc(s,x) is Gamma(s,x)/Gamma(s)\n                tail_integral = (A_fit * tau_fit / beta_fit) * gamma(s) * gammaincc(s, x)\n                \n                # Ensure physical result (integral must be non-negative)\n                if tail_integral  0:\n                    tail_integral = 0.0\n\n            except RuntimeError:\n                # If fit fails, the tail contribution is zero\n                tail_integral = 0.0\n        \n        # 5. Calculate the total diffusion coefficient\n        total_integral = numerical_integral + tail_integral\n        D = (1.0 / 3.0) * total_integral\n        results.append(D)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join([f'{d:.6e}' for d in results])}]\")\n\nsolve()\n```"
        }
    ]
}