{
    "hands_on_practices": [
        {
            "introduction": "The creation of a pseudopotential begins with a fundamental question: if we design a smooth, nodeless pseudo-wavefunction that mimics the true valence wavefunction outside a core radius, what is the effective potential that produces it? This exercise guides you through this \"inverse problem\" by algebraically rearranging the radial Schrödinger equation. Completing this practice will demystify the origin of the local pseudopotential, showing how it is mathematically determined to reproduce a target wavefunction at a given energy. ",
            "id": "3470110",
            "problem": "In constructing Norm-Conserving (NC) pseudopotentials for Density Functional Theory (DFT) calculations in computational materials science, one prescribes smooth pseudo partial waves inside a chosen core radius $r_c$ and enforces that these pseudo solutions satisfy the radial Schrödinger equation at designated reference energies. Consider the $s$-channel ($l=0$) pseudo partial wave defined inside the core region $0<r\\le r_c$ by\n$$\nu_0(r) = r \\exp(-\\alpha r^2),\n$$\nwhere $\\alpha>0$ is a parameter already chosen to satisfy norm-conservation, and let the target reference eigenvalue be $\\epsilon_0$ (in Hartree atomic units). Assume the standard single-particle radial Schrödinger equation in atomic units for the reduced radial function $u_l(r)$,\n$$\n-\\frac{1}{2}\\frac{d^2 u_l(r)}{dr^2} + \\left[\\frac{l(l+1)}{2 r^2} + V_l^{\\mathrm{PS}}(r)\\right] u_l(r) = \\epsilon_l\\, u_l(r),\n$$\nto be satisfied by the pseudo quantities in the domain $0<r\\le r_c$.\n\nStarting from this fundamental equation and the given $u_0(r)$ and $\\epsilon_0$, and without making any further approximations beyond the stated model, derive the closed-form expression of the local pseudopotential component $V_0^{\\mathrm{PS}}(r)$ inside the core radius $r_c$ that reproduces the target pseudo solution. Express your final result as a single analytic expression in terms of $r$, $\\alpha$, and $\\epsilon_0$. No numerical evaluation is required. The final answer must be a single closed-form analytic expression.",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of quantum mechanics and computational materials science, specifically in the standard method for constructing pseudopotentials. The problem is well-posed, objective, and provides a self-contained and consistent set of givens, allowing for the derivation of a unique, meaningful solution.\n\nThe objective is to find the local pseudopotential, $V_0^{\\mathrm{PS}}(r)$, that produces a given pseudo partial wave, $u_0(r)$, at a specific reference energy, $\\epsilon_0$. The governing equation is the single-particle radial Schrödinger equation in atomic units. For the $s$-channel, the angular momentum quantum number is $l=0$, which simplifies the equation considerably as the centrifugal term $\\frac{l(l+1)}{2r^2}$ vanishes.\n\nThe radial Schrödinger equation for $l=0$ is:\n$$\n-\\frac{1}{2}\\frac{d^2 u_0(r)}{dr^2} + V_0^{\\mathrm{PS}}(r) u_0(r) = \\epsilon_0 u_0(r)\n$$\nThis equation holds for the specified domain $0 < r \\le r_c$. To find the potential $V_0^{\\mathrm{PS}}(r)$, we can rearrange this equation. This process is often referred to as the \"inversion\" of the Schrödinger equation.\n$$\nV_0^{\\mathrm{PS}}(r) u_0(r) = \\epsilon_0 u_0(r) + \\frac{1}{2}\\frac{d^2 u_0(r)}{dr^2}\n$$\nFor the domain of interest where $u_0(r) \\neq 0$, we can divide by $u_0(r)$ to isolate $V_0^{\\mathrm{PS}}(r)$:\n$$\nV_0^{\\mathrm{PS}}(r) = \\epsilon_0 + \\frac{1}{2u_0(r)}\\frac{d^2 u_0(r)}{dr^2}\n$$\nThe problem provides the functional form of the pseudo partial wave:\n$$\nu_0(r) = r \\exp(-\\alpha r^2)\n$$\nwhere $\\alpha > 0$. The next step is to compute the first and second derivatives of $u_0(r)$ with respect to $r$.\n\nFirst, we compute the first derivative, $\\frac{du_0}{dr}$, using the product rule:\n$$\n\\frac{d u_0(r)}{dr} = \\frac{d}{dr}\\left(r \\exp(-\\alpha r^2)\\right) = \\left(\\frac{d}{dr}r\\right)\\exp(-\\alpha r^2) + r\\left(\\frac{d}{dr}\\exp(-\\alpha r^2)\\right)\n$$\n$$\n\\frac{d u_0(r)}{dr} = 1 \\cdot \\exp(-\\alpha r^2) + r \\cdot (-2\\alpha r)\\exp(-\\alpha r^2)\n$$\n$$\n\\frac{d u_0(r)}{dr} = (1 - 2\\alpha r^2) \\exp(-\\alpha r^2)\n$$\nNext, we compute the second derivative, $\\frac{d^2u_0}{dr^2}$, by differentiating the first derivative, again using the product rule:\n$$\n\\frac{d^2 u_0(r)}{dr^2} = \\frac{d}{dr}\\left( (1 - 2\\alpha r^2) \\exp(-\\alpha r^2) \\right)\n$$\n$$\n\\frac{d^2 u_0(r)}{dr^2} = \\left(\\frac{d}{dr}(1 - 2\\alpha r^2)\\right)\\exp(-\\alpha r^2) + (1 - 2\\alpha r^2)\\left(\\frac{d}{dr}\\exp(-\\alpha r^2)\\right)\n$$\n$$\n\\frac{d^2 u_0(r)}{dr^2} = (-4\\alpha r)\\exp(-\\alpha r^2) + (1 - 2\\alpha r^2)(-2\\alpha r)\\exp(-\\alpha r^2)\n$$\nFactoring out the term $\\exp(-\\alpha r^2)$:\n$$\n\\frac{d^2 u_0(r)}{dr^2} = \\left[ -4\\alpha r - 2\\alpha r(1 - 2\\alpha r^2) \\right] \\exp(-\\alpha r^2)\n$$\n$$\n\\frac{d^2 u_0(r)}{dr^2} = \\left[ -4\\alpha r - 2\\alpha r + 4\\alpha^2 r^3 \\right] \\exp(-\\alpha r^2)\n$$\n$$\n\\frac{d^2 u_0(r)}{dr^2} = (-6\\alpha r + 4\\alpha^2 r^3) \\exp(-\\alpha r^2)\n$$\nNow, we substitute this second derivative back into our expression for $V_0^{\\mathrm{PS}}(r)$:\n$$\nV_0^{\\mathrm{PS}}(r) = \\epsilon_0 + \\frac{1}{2u_0(r)} \\left[ (-6\\alpha r + 4\\alpha^2 r^3) \\exp(-\\alpha r^2) \\right]\n$$\nSubstituting the expression for $u_0(r) = r \\exp(-\\alpha r^2)$:\n$$\nV_0^{\\mathrm{PS}}(r) = \\epsilon_0 + \\frac{(-6\\alpha r + 4\\alpha^2 r^3) \\exp(-\\alpha r^2)}{2 r \\exp(-\\alpha r^2)}\n$$\nThe term $\\exp(-\\alpha r^2)$ cancels out from the numerator and denominator:\n$$\nV_0^{\\mathrm{PS}}(r) = \\epsilon_0 + \\frac{-6\\alpha r + 4\\alpha^2 r^3}{2r}\n$$\nFinally, we simplify the fraction by dividing each term in the numerator by $2r$:\n$$\nV_0^{\\mathrm{PS}}(r) = \\epsilon_0 + \\frac{-6\\alpha r}{2r} + \\frac{4\\alpha^2 r^3}{2r}\n$$\n$$\nV_0^{\\mathrm{PS}}(r) = \\epsilon_0 - 3\\alpha + 2\\alpha^2 r^2\n$$\nThis is the closed-form analytic expression for the local pseudopotential component inside the core radius. It is a smooth, finite potential, quadratic in $r$, which is consistent with the goals of pseudopotential construction.",
            "answer": "$$\\boxed{\\epsilon_0 - 3\\alpha + 2\\alpha^2 r^2}$$"
        },
        {
            "introduction": "Ultrasoft pseudopotentials achieve remarkable computational efficiency by relaxing the strict norm-conserving constraint, which results in a \"charge deficit\" within the atomic core. This practice provides a concrete, quantitative look at how this deficit arises and how it is perfectly corrected by a localized augmentation charge density. Through analytical derivation and a simple coding exercise, you will verify the foundational principle that makes the ultrasoft method both efficient and accurate. ",
            "id": "3470104",
            "problem": "Consider the valence electron density in Kohn–Sham Density Functional Theory (DFT). For an isolated atom, assume a spherically symmetric all-electron valence density $n^{\\mathrm{AE}}(r)$ that integrates to the number of valence electrons $Z_v$. In a norm-conserving pseudopotential, the pseudo density $n^{\\mathrm{NC}}(r)$ conserves the integrated charge within a defined core radius $r_c$, while in an ultrasoft pseudopotential the pseudo density $n^{\\mathrm{US}}(r)$ is not required to conserve the norm inside $r_c$. Ultrasoft pseudopotentials introduce a localized augmentation charge density $q^{\\mathrm{aug}}(r)$ supported in the augmentation region (usually the core) such that the physically meaningful integrated charge inside any region is recovered when the augmentation is added to the pseudo density.\n\nStarting from the definition of integrated charge inside a sphere of radius $R$ centered on the atom,\n$$\nQ(R) \\equiv \\int_{|\\mathbf{r}|\\le R} n(\\mathbf{r})\\, \\mathrm{d}^3 r = \\int_0^R 4\\pi r^2\\, n(r)\\, \\mathrm{d}r,\n$$\nconsider the following physically motivated, tractable model of an ultrasoft pseudopotential for a valence-only calculation:\n\n- All-electron valence density per atom $a$ is modeled by a Slater-type (hydrogenic) spherically symmetric density\n$$\nn_a^{\\mathrm{AE}}(r) = \\frac{Z_{v,a}}{\\pi a_a^3}\\,\\exp\\!\\left(-\\frac{2r}{a_a}\\right),\n$$\nwhich is normalized so that\n$$\n\\int_0^\\infty 4\\pi r^2\\, n_a^{\\mathrm{AE}}(r)\\, \\mathrm{d}r = Z_{v,a}.\n$$\nHere $Z_{v,a}$ is the valence electron count (in electrons) and $a_a$ is a characteristic decay length (in Bohr radii).\n\n- Ultrasoft pseudo density $n_a^{\\mathrm{US}}(r)$ is defined to match the all-electron density outside a core radius $r_{c,a}$ and to be a smooth scaled density inside the core,\n$$\nn_a^{\\mathrm{US}}(r) =\n\\begin{cases}\n\\alpha_a\\, n_a^{\\mathrm{AE}}(r), & 0 \\le r < r_{c,a},\\\\\nn_a^{\\mathrm{AE}}(r), & r \\ge r_{c,a},\n\\end{cases}\n$$\nwith a constant $0<\\alpha_a<1$ modeling a reduced norm in the core region.\n\n- Augmentation density $q_a^{\\mathrm{aug}}(r)$ is localized inside the core and defined to restore the missing valence charge,\n$$\nq_a^{\\mathrm{aug}}(r) =\n\\begin{cases}\n\\left(1-\\alpha_a\\right)\\, n_a^{\\mathrm{AE}}(r), & 0 \\le r < r_{c,a},\\\\\n0, & r \\ge r_{c,a}.\n\\end{cases}\n$$\n\nFor a diatomic molecule with two atoms $a\\in\\{1,2\\}$ at a separation of $d$ Bohr radii, assume the independent-atom superposition approximation for the valence density and focus on the per-atom integrated charges inside spheres centered on each atom. Under this approximation, the difference between all-electron and pseudo valence charges inside a small sphere around atom $a$ arises only from that atom’s core region, because contributions from the other atom’s valence density are identical for all-electron and pseudo outside its own core and the augmentation region does not overlap the small sphere when $d$ is sufficiently large.\n\nTasks:\n\n1. Derive from the given definitions the expression for the all-electron integrated valence charge inside a sphere of radius $R$,\n$$\nQ_a^{\\mathrm{AE}}(R) = \\int_0^R 4\\pi r^2\\, n_a^{\\mathrm{AE}}(r)\\, \\mathrm{d}r,\n$$\nand show it can be expressed in closed form.\n\n2. Using $Q_a^{\\mathrm{AE}}(R)$, derive piecewise expressions for\n$$\nQ_a^{\\mathrm{US}}(R) = \\int_0^R 4\\pi r^2\\, n_a^{\\mathrm{US}}(r)\\, \\mathrm{d}r,\\quad\nQ_a^{\\mathrm{aug}}(R) = \\int_0^R 4\\pi r^2\\, q_a^{\\mathrm{aug}}(r)\\, \\mathrm{d}r,\n$$\nand use these to prove that\n$$\nQ_a^{\\mathrm{AE}}(R) = Q_a^{\\mathrm{US}}(R) + Q_a^{\\mathrm{aug}}(R)\n$$\nfor any $R\\ge 0$.\n\n3. Implement a program that, for the parameter values specified below, computes for each test case the two quantities\n$$\n\\Delta_{\\mathrm{before}} \\equiv Q_a^{\\mathrm{AE}}(R) - Q_a^{\\mathrm{US}}(R), \\quad\n\\Delta_{\\mathrm{after}} \\equiv Q_a^{\\mathrm{AE}}(R) - \\left(Q_a^{\\mathrm{US}}(R) + Q_a^{\\mathrm{aug}}(R)\\right),\n$$\nboth expressed in electrons. Your program must output a single line: a comma-separated list enclosed in square brackets, containing the sequence of floats\n$$\n[\\Delta_{\\mathrm{before}}^{(1)}, \\Delta_{\\mathrm{after}}^{(1)}, \\Delta_{\\mathrm{before}}^{(2)}, \\Delta_{\\mathrm{after}}^{(2)}, \\dots]\n$$\nin the exact order of the test suite cases given below.\n\nUse atomic units with lengths in Bohr radii and charges in electrons. Angles do not appear. No percentages are required.\n\nTest suite (diatomic molecule, atom-centered spheres, large separation so that augmentation regions do not overlap the other atom’s sphere):\n\n- Interatomic separation: $d = 4.0$ Bohr radii.\n\n- Atom $1$ parameters: $Z_{v,1} = 1$ electrons, $a_1 = 0.8$ Bohr radii, $r_{c,1} = 0.5$ Bohr radii, $\\alpha_1 = 0.55$. Radii to test: $R \\in \\{0.25, 0.5, 1.5\\}$ Bohr radii.\n\n- Atom $2$ parameters: $Z_{v,2} = 4$ electrons, $a_2 = 1.1$ Bohr radii, $r_{c,2} = 0.9$ Bohr radii, $\\alpha_2 = 0.65$. Radii to test: $R \\in \\{0.6, 0.9, 2.2\\}$ Bohr radii.\n\nDesign for coverage:\n- The choice $R<r_{c,a}$ exercises the reduced core norm region.\n- The choice $R=r_{c,a}$ is a boundary case.\n- The choice $R>r_{c,a}$ includes both core and tail regions.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in electrons, following the ordering of the six radii above for atom $1$ then atom $2$, with each radius contributing two consecutive numbers $\\Delta_{\\mathrm{before}}$ and $\\Delta_{\\mathrm{after}}$.",
            "solution": "The problem is scientifically grounded, well-posed, and self-contained. It is based on established concepts in computational materials science, specifically Density Functional Theory (DFT) and the theory of pseudopotentials. The provided models for electron densities and the definitions of integrated charges are consistent and allow for a unique, verifiable solution. Thus, the problem is deemed valid and a full solution is presented below.\n\nThe solution proceeds in three parts as requested by the problem statement. First, a closed-form expression for the all-electron integrated charge is derived. Second, expressions for the ultrasoft pseudo-charge and augmentation charge are derived, and the fundamental charge conservation identity is proven. Finally, the strategy for the computational implementation is detailed based on these derivations.\n\n**1. Derivation of the All-Electron Integrated Charge $Q_a^{\\mathrm{AE}}(R)$**\n\nThe all-electron (AE) integrated valence charge, $Q_a^{\\mathrm{AE}}(R)$, inside a sphere of radius $R$ is defined by the integral:\n$$\nQ_a^{\\mathrm{AE}}(R) = \\int_0^R 4\\pi r^2\\, n_a^{\\mathrm{AE}}(r)\\, \\mathrm{d}r\n$$\nThe problem provides a model for the all-electron valence density:\n$$\nn_a^{\\mathrm{AE}}(r) = \\frac{Z_{v,a}}{\\pi a_a^3}\\,\\exp\\!\\left(-\\frac{2r}{a_a}\\right)\n$$\nSubstituting this into the integral gives:\n$$\nQ_a^{\\mathrm{AE}}(R) = \\int_0^R 4\\pi r^2 \\left(\\frac{Z_{v,a}}{\\pi a_a^3}\\,\\exp\\!\\left(-\\frac{2r}{a_a}\\right)\\right)\\, \\mathrm{d}r = \\frac{4 Z_{v,a}}{a_a^3} \\int_0^R r^2 \\exp\\!\\left(-\\frac{2r}{a_a}\\right)\\, \\mathrm{d}r\n$$\nTo solve this integral, we can use repeated integration by parts or a standard integral formula. The indefinite integral of the form $\\int x^2 e^{-cx} dx$ is:\n$$\n\\int r^2 e^{-cr}\\, \\mathrm{d}r = -e^{-cr} \\left(\\frac{r^2}{c} + \\frac{2r}{c^2} + \\frac{2}{c^3}\\right)\n$$\nIn our case, the constant is $c = 2/a_a$. The definite integral is:\n$$\n\\int_0^R r^2 \\exp\\!\\left(-\\frac{2r}{a_a}\\right)\\, \\mathrm{d}r = \\left[ -e^{-2r/a_a} \\left(\\frac{r^2}{2/a_a} + \\frac{2r}{(2/a_a)^2} + \\frac{2}{(2/a_a)^3}\\right) \\right]_0^R\n$$\n$$\n= \\left[ -e^{-2r/a_a} \\left(\\frac{a_a r^2}{2} + \\frac{a_a^2 r}{2} + \\frac{a_a^3}{4}\\right) \\right]_0^R\n$$\n$$\n= \\left( -e^{-2R/a_a} \\left(\\frac{a_a R^2}{2} + \\frac{a_a^2 R}{2} + \\frac{a_a^3}{4}\\right) \\right) - \\left( -e^0 \\left(0 + 0 + \\frac{a_a^3}{4}\\right) \\right)\n$$\n$$\n= \\frac{a_a^3}{4} - e^{-2R/a_a} \\left(\\frac{a_a R^2}{2} + \\frac{a_a^2 R}{2} + \\frac{a_a^3}{4}\\right)\n$$\nSubstituting this back into the expression for $Q_a^{\\mathrm{AE}}(R)$:\n$$\nQ_a^{\\mathrm{AE}}(R) = \\frac{4 Z_{v,a}}{a_a^3} \\left[ \\frac{a_a^3}{4} - e^{-2R/a_a} \\left(\\frac{a_a R^2}{2} + \\fraca_a^2 R}{2} + \\frac{a_a^3}{4}\\right) \\right]\n$$\n$$\n= Z_{v,a} \\left[ 1 - \\frac{4}{a_a^3} e^{-2R/a_a} \\left(\\frac{a_a R^2}{2} + \\frac{a_a^2 R}{2} + \\frac{a_a^3}{4}\\right) \\right]\n$$\nSimplifying the terms in the parenthesis, we obtain the final closed-form expression:\n$$\nQ_a^{\\mathrm{AE}}(R) = Z_{v,a} \\left[ 1 - \\exp\\!\\left(-\\frac{2R}{a_a}\\right) \\left(1 + \\frac{2R}{a_a} + \\frac{2R^2}{a_a^2}\\right) \\right]\n$$\nThis expression is equivalent to $Z_{v,a} \\left[1 - e^{-x}(1+x+x^2/2)\\right]$ with $x=2R/a_a$, a form related to the lower incomplete gamma function.\n\n**2. Derivation of $Q_a^{\\mathrm{US}}(R)$, $Q_a^{\\mathrm{aug}}(R)$, and Proof of Conservation**\n\nThe piecewise definitions of the ultrasoft (US) pseudo density $n_a^{\\mathrm{US}}(r)$ and the augmentation density $q_a^{\\mathrm{aug}}(r)$ lead to piecewise expressions for their integrated charges. Let $r_c \\equiv r_{c,a}$.\n\nFor the US integrated charge $Q_a^{\\mathrm{US}}(R) = \\int_0^R 4\\pi r^2 n_a^{\\mathrm{US}}(r) \\mathrm{d}r$:\n- If $0 \\le R < r_c$:\n$$\nQ_a^{\\mathrm{US}}(R) = \\int_0^R 4\\pi r^2 \\left( \\alpha_a n_a^{\\mathrm{AE}}(r) \\right) \\mathrm{d}r = \\alpha_a \\int_0^R 4\\pi r^2 n_a^{\\mathrm{AE}}(r) \\mathrm{d}r = \\alpha_a Q_a^{\\mathrm{AE}}(R)\n$$\n- If $R \\ge r_c$:\n$$\nQ_a^{\\mathrm{US}}(R) = \\int_0^{r_c} 4\\pi r^2 n_a^{\\mathrm{US}}(r) \\mathrm{d}r + \\int_{r_c}^R 4\\pi r^2 n_a^{\\mathrm{US}}(r) \\mathrm{d}r\n$$\n$$\n= \\int_0^{r_c} 4\\pi r^2 \\left( \\alpha_a n_a^{\\mathrm{AE}}(r) \\right) \\mathrm{d}r + \\int_{r_c}^R 4\\pi r^2 n_a^{\\mathrm{AE}}(r) \\mathrm{d}r\n$$\n$$\n= \\alpha_a Q_a^{\\mathrm{AE}}(r_c) + \\left( Q_a^{\\mathrm{AE}}(R) - Q_a^{\\mathrm{AE}}(r_c) \\right) = Q_a^{\\mathrm{AE}}(R) - (1 - \\alpha_a) Q_a^{\\mathrm{AE}}(r_c)\n$$\n\nFor the augmentation integrated charge $Q_a^{\\mathrm{aug}}(R) = \\int_0^R 4\\pi r^2 q_a^{\\mathrm{aug}}(r) \\mathrm{d}r$:\n- If $0 \\le R < r_c$:\n$$\nQ_a^{\\mathrm{aug}}(R) = \\int_0^R 4\\pi r^2 \\left( (1-\\alpha_a) n_a^{\\mathrm{AE}}(r) \\right) \\mathrm{d}r = (1-\\alpha_a) Q_a^{\\mathrm{AE}}(R)\n$$\n- If $R \\ge r_c$:\n$$\nQ_a^{\\mathrm{aug}}(R) = \\int_0^{r_c} 4\\pi r^2 q_a^{\\mathrm{aug}}(r) \\mathrm{d}r + \\int_{r_c}^R 4\\pi r^2 q_a^{\\mathrm{aug}}(r) \\mathrm{d}r\n$$\n$$\n= \\int_0^{r_c} 4\\pi r^2 \\left( (1-\\alpha_a) n_a^{\\mathrm{AE}}(r) \\right) \\mathrm{d}r + \\int_{r_c}^R 4\\pi r^2 (0) \\mathrm{d}r = (1-\\alpha_a) Q_a^{\\mathrm{AE}}(r_c)\n$$\n\nNow, we prove that $Q_a^{\\mathrm{AE}}(R) = Q_a^{\\mathrm{US}}(R) + Q_a^{\\mathrm{aug}}(R)$ for any $R \\ge 0$.\n- For $0 \\le R < r_c$:\n$$\nQ_a^{\\mathrm{US}}(R) + Q_a^{\\mathrm{aug}}(R) = \\alpha_a Q_a^{\\mathrm{AE}}(R) + (1-\\alpha_a) Q_a^{\\mathrm{AE}}(R) = (\\alpha_a + 1 - \\alpha_a) Q_a^{\\mathrm{AE}}(R) = Q_a^{\\mathrm{AE}}(R)\n$$\n- For $R \\ge r_c$:\n$$\nQ_a^{\\mathrm{US}}(R) + Q_a^{\\mathrm{aug}}(R) = \\left( Q_a^{\\mathrm{AE}}(R) - (1 - \\alpha_a) Q_a^{\\mathrm{AE}}(r_c) \\right) + \\left( (1-\\alpha_a) Q_a^{\\mathrm{AE}}(r_c) \\right) = Q_a^{\\mathrm{AE}}(R)\n$$\nThe identity holds for all $R \\ge 0$, confirming that the augmentation charge correctly restores the all-electron charge at all radii.\n\n**3. Computational Implementation**\n\nThe quantities to be computed are:\n$$\n\\Delta_{\\mathrm{before}} \\equiv Q_a^{\\mathrm{AE}}(R) - Q_a^{\\mathrm{US}}(R)\n$$\n$$\n\\Delta_{\\mathrm{after}} \\equiv Q_a^{\\mathrm{AE}}(R) - \\left(Q_a^{\\mathrm{US}}(R) + Q_a^{\\mathrm{aug}}(R)\\right)\n$$\nFrom the identity proven in part 2, it is immediately evident that:\n$$\n\\Delta_{\\mathrm{after}} = Q_a^{\\mathrm{AE}}(R) - Q_a^{\\mathrm{AE}}(R) = 0\n$$\nThis will hold for all test cases, up to floating-point precision. The implementation will set this value to exactly $0.0$.\n\nFor $\\Delta_{\\mathrm{before}}$, we substitute the derived expressions for $Q_a^{\\mathrm{US}}(R)$:\n- If $0 \\le R < r_c$:\n$$\n\\Delta_{\\mathrm{before}} = Q_a^{\\mathrm{AE}}(R) - \\alpha_a Q_a^{\\mathrm{AE}}(R) = (1-\\alpha_a) Q_a^{\\mathrm{AE}}(R)\n$$\n- If $R \\ge r_c$:\n$$\n\\Delta_{\\mathrm{before}} = Q_a^{\\mathrm{AE}}(R) - \\left( Q_a^{\\mathrm{AE}}(R) - (1 - \\alpha_a) Q_a^{\\mathrm{AE}}(r_c) \\right) = (1-\\alpha_a) Q_a^{\\mathrm{AE}}(r_c)\n$$\nThese two cases can be combined into a single expression:\n$$\n\\Delta_{\\mathrm{before}} = (1-\\alpha_a) Q_a^{\\mathrm{AE}}(\\min(R, r_c))\n$$\nNotably, this is identical to the expression for the augmentation charge, $Q_a^{\\mathrm{aug}}(R)$. This is expected, as the augmentation charge is precisely defined to be the difference between the all-electron and pseudo-electron densities.\n\nThe program will implement a function to compute $Q_a^{\\mathrm{AE}}(R)$ using the formula from part 1. It will then use this function to calculate $\\Delta_{\\mathrm{before}}$ for each test case according to the compact formula derived above, and set $\\Delta_{\\mathrm{after}}$ to $0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating charge differences for an ultrasoft\n    pseudopotential model.\n    \"\"\"\n\n    def q_ae(R, Zv, a_val):\n        \"\"\"\n        Calculates the all-electron integrated charge Q_a^AE(R).\n\n        Args:\n            R (float): Radius of the integration sphere.\n            Zv (float): Number of valence electrons.\n            a_val (float): Characteristic decay length.\n\n        Returns:\n            float: The integrated all-electron charge.\n        \"\"\"\n        if R <= 0.0:\n            return 0.0\n        \n        # We use the derived formula:\n        # Q_a^AE(R) = Zv * [1 - exp(-x) * (1 + x + x^2/2)] where x = 2*R/a_val\n        x = 2.0 * R / a_val\n        poly_term = 1.0 + x + 0.5 * x**2\n        exp_term = np.exp(-x)\n        \n        return Zv * (1.0 - exp_term * poly_term)\n\n    # test_cases format: (Zv, a, rc, alpha, R)\n    test_cases = [\n        # Atom 1 parameters: Zv=1, a=0.8, rc=0.5, alpha=0.55\n        # R values: 0.25, 0.5, 1.5\n        (1.0, 0.8, 0.5, 0.55, 0.25),\n        (1.0, 0.8, 0.5, 0.55, 0.5),\n        (1.0, 0.8, 0.5, 0.55, 1.5),\n        \n        # Atom 2 parameters: Zv=4, a=1.1, rc=0.9, alpha=0.65\n        # R values: 0.6, 0.9, 2.2\n        (4.0, 1.1, 0.9, 0.65, 0.6),\n        (4.0, 1.1, 0.9, 0.65, 0.9),\n        (4.0, 1.1, 0.9, 0.65, 2.2),\n    ]\n\n    results = []\n    for Zv, a_val, rc, alpha, R in test_cases:\n        # From the derivation, Delta_after is analytically zero.\n        # Delta_after = Q_ae - (Q_us + Q_aug) = Q_ae - Q_ae = 0\n        delta_after = 0.0\n\n        # From the derivation, Delta_before = Q_ae - Q_us, which equals Q_aug.\n        # Q_aug(R) = (1-alpha) * Q_ae(min(R, rc))\n        R_effective = min(R, rc)\n        q_ae_at_Reff = q_ae(R_effective, Zv, a_val)\n        delta_before = (1.0 - alpha) * q_ae_at_Reff\n        \n        results.append(delta_before)\n        results.append(delta_after)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Selecting a pseudopotential for a simulation involves navigating a crucial design dilemma: the trade-off between computational cost and scientific accuracy. This comprehensive exercise simulates this real-world challenge by tasking you with evaluating two pseudopotentials that differ only in their core radius, $r_c$. By quantifying their required plane-wave cutoff and transferability error, you will gain hands-on insight into how \"harder\" potentials (smaller $r_c$) are more transferable but computationally expensive, while \"softer\" ones are more efficient but less accurate across diverse chemical environments. ",
            "id": "3470115",
            "problem": "You are to construct a simplified, self-contained computational study that emulates the design and evaluation of two norm-conserving pseudopotentials for a single element, with different core radii. The objective is to match the same scattering phase shifts at multiple energies while quantifying the trade-off between plane-wave cutoff energy and transferability error in bond lengths across different environments. The program must implement the following model and calculations precisely as specified.\n\nFundamental base and definitions to use:\n- Scattering phase shifts follow from the stationary radial Schrödinger equation and are defined via the partial-wave expansion. In atomic units, with reduced mass set to $1$, the wave vector satisfies $k = \\sqrt{2 E}$ for energy $E$.\n- For the $s$-wave (angular momentum $l=0$), the effective range expansion is $k \\cot \\delta_0(E) = -\\frac{1}{a_0} + \\frac{r_0}{2} k^2$.\n- For the $p$-wave (angular momentum $l=1$), the low-energy effective expansion is $k^3 \\cot \\delta_1(E) = -\\frac{1}{a_1} + \\frac{r_1}{2} k^2$.\n- The phase shift can be computed from these expansions using the principal value of the arctangent to ensure continuity: for $l=0$, $\\delta_0(E) = \\arctan\\left( \\frac{k}{-\\frac{1}{a_0} + \\frac{r_0}{2} k^2} \\right)$; for $l=1$, $\\delta_1(E) = \\arctan\\left( \\frac{k^3}{-\\frac{1}{a_1} + \\frac{r_1}{2} k^2} \\right)$.\n- A norm-conserving pseudopotential should reproduce the scattering properties and preserve the radial norm of the valence wavefunction within a chosen core radius. In this model, you will impose phase shift matching at specified energies and zero deviation and zero slope at a low-energy anchor to mimic norm conservation constraints.\n\nReference phase shifts:\n- Treat the all-electron reference scattering as given by the above effective range forms with fixed parameters. Use $a_0 = 1.20$ (in bohr), $r_0 = 2.50$ (in bohr), $a_1 = 1.00$ (in bohr$^3$), and $r_1 = 1.80$ (in bohr). Energies are in Hartree and phase shifts in radians.\n\nPseudopotential construction:\n- You will construct two pseudopotentials, denoted $\\mathrm{PP}_A$ and $\\mathrm{PP}_B$, by defining their phase shifts for channels $l \\in \\{0,1\\}$ as a perturbation of the reference:\n$$\n\\delta_l^{\\mathrm{PP}}(E; r_c) = \\delta_l^{\\mathrm{ref}}(E) + \\gamma_l(r_c)\\, h_l(E),\n$$\nwhere $r_c$ is the core radius of the pseudopotential, $h_l(E)$ is a smooth perturbation polynomial, and $\\gamma_l(r_c)$ is a hardness-dependent amplitude scaling. Impose matching at three fitting energies $E_1, E_2, E_3$ such that $h_l(E_i)=0$ and enforce a double root at the lowest energy $E_1$ to impose zero slope, i.e.,\n$$\nh_l(E) = C_l \\,(E - E_1)^2 (E - E_2)(E - E_3),\n$$\nwith constants $C_0 = 0.02$ and $C_1 = 0.015$. Let the amplitude scale as\n$$\n\\gamma_l(r_c) = \\frac{c_l}{r_c^4}, \\quad c_0 = 0.12, \\quad c_1 = 0.10.\n$$\nThis construction ensures $\\delta_l^{\\mathrm{PP}}(E_i; r_c) = \\delta_l^{\\mathrm{ref}}(E_i)$ and $\\frac{d}{dE}\\delta_l^{\\mathrm{PP}}(E_1; r_c) = \\frac{d}{dE}\\delta_l^{\\mathrm{ref}}(E_1)$, which jointly emulate the norm-conservation constraints at the anchor energy.\n\nPlane-wave cutoff model:\n- Model the reciprocal-space decay of the pseudopotential form factor by a Gaussian envelope $|V_l(G)|^2 \\propto \\exp\\left( - (G r_c)^2 \\right)$, where $G$ is the reciprocal-space magnitude. Define the tail fraction beyond a cutoff $G_{\\mathrm{cut}}$ as\n$$\nf_{\\mathrm{tail}}(G_{\\mathrm{cut}}; r_c) = \\frac{\\int_{G_{\\mathrm{cut}}}^{\\infty} 4\\pi G^2 \\exp\\left( - (G r_c)^2 \\right)\\, dG}{\\int_{0}^{\\infty} 4\\pi G^2 \\exp\\left( - (G r_c)^2 \\right)\\, dG}.\n$$\nUsing standard Gaussian integrals, this fraction simplifies to\n$$\nf_{\\mathrm{tail}}(G_{\\mathrm{cut}}; r_c) = \\mathrm{erfc}(z) + \\frac{2}{\\sqrt{\\pi}} z e^{-z^2}, \\quad z = r_c\\, G_{\\mathrm{cut}},\n$$\nwhere $\\mathrm{erfc}$ is the complementary error function. For a specified tolerance $\\varepsilon$, determine $G_{\\mathrm{cut}}$ by solving $f_{\\mathrm{tail}}(G_{\\mathrm{cut}}; r_c) \\le \\varepsilon$. The corresponding plane-wave kinetic energy cutoff is\n$$\nE_{\\mathrm{cut}} = \\frac{G_{\\mathrm{cut}}^2}{2},\n$$\nin Hartree. Express $E_{\\mathrm{cut}}$ in electronvolts (eV) using $1\\,\\mathrm{Hartree} = 27.2114\\,\\mathrm{eV}$.\n\nTransferability error in bond lengths:\n- For a given environment characterized by an energy distribution $P_{\\mathrm{env}}(E)$ over valence scattering energies and channel weights $w_0$ and $w_1$ for $s$- and $p$-channels, define a proxy for bond length error as\n$$\n\\Delta R_{\\mathrm{env}}(r_c) = \\alpha \\sum_{l=0}^{1} w_l \\int_{0}^{E_{\\max}} P_{\\mathrm{env}}(E) \\left| \\delta_l^{\\mathrm{PP}}(E; r_c) - \\delta_l^{\\mathrm{ref}}(E) \\right|\\, dE,\n$$\nwith sensitivity $\\alpha = 0.02$ (in angstrom per radian), $E_{\\max} = 2.0$ (Hartree), and normalized $P_{\\mathrm{env}}(E)$ over $[0,E_{\\max}]$. Use $w_0 = 0.6$ and $w_1 = 0.4$.\n\nEnvironments:\n- Use three environments with Gaussian energy distributions truncated to $[0,E_{\\max}]$ and renormalized:\n1. Molecular-like: mean $\\mu_1 = 0.20$ (Hartree), standard deviation $\\sigma_1 = 0.10$ (Hartree).\n2. Ionic-like: mean $\\mu_2 = 0.60$ (Hartree), standard deviation $\\sigma_2 = 0.20$ (Hartree).\n3. Metallic-like: mean $\\mu_3 = 1.20$ (Hartree), standard deviation $\\sigma_3 = 0.40$ (Hartree).\nDefine each $P_{\\mathrm{env}}(E)$ as the normalized Gaussian density on $[0,E_{\\max}]$.\n\nFitting energies:\n- Use $E_1 = 0.20$ (Hartree), $E_2 = 0.80$ (Hartree), and $E_3 = 1.50$ (Hartree) for matching.\n\nTest suite:\n- Provide three test cases, each specifying the two core radii and the tolerance:\n1. Case 1: $r_{c,A} = 1.20$ (bohr), $r_{c,B} = 1.80$ (bohr), $\\varepsilon = 1.0\\times 10^{-4}$.\n2. Case 2: $r_{c,A} = 1.00$ (bohr), $r_{c,B} = 2.20$ (bohr), $\\varepsilon = 1.0\\times 10^{-5}$.\n3. Case 3: $r_{c,A} = 1.60$ (bohr), $r_{c,B} = 1.60$ (bohr), $\\varepsilon = 5.0\\times 10^{-5}$.\n\nComputation requirements:\n- Compute the phase shifts for $l=0,1$ according to the effective expansions and the pseudopotential perturbation.\n- For each pseudopotential in each test case, determine $E_{\\mathrm{cut}}$ by solving the tail criterion; express the final plane-wave cutoff in electronvolts (eV).\n- For each pseudopotential in each test case, compute $\\Delta R_{\\mathrm{env}}$ for the three environments; express the bond length errors in angstrom (Å). Use numerical integration by sampling $E$ uniformly on $[0,E_{\\max}]$ with sufficient resolution to ensure numerical stability.\n- Angles must be in radians and energies in Hartree internally, with the final $E_{\\mathrm{cut}}$ reported in electronvolts (eV) and $\\Delta R_{\\mathrm{env}}$ in angstrom (Å).\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output the following eight numbers in order:\n1. $E_{\\mathrm{cut},A}$ (eV),\n2. $E_{\\mathrm{cut},B}$ (eV),\n3. $\\Delta R_{\\mathrm{mol},A}$ (Å),\n4. $\\Delta R_{\\mathrm{mol},B}$ (Å),\n5. $\\Delta R_{\\mathrm{ion},A}$ (Å),\n6. $\\Delta R_{\\mathrm{ion},B}$ (Å),\n7. $\\Delta R_{\\mathrm{met},A}$ (Å),\n8. $\\Delta R_{\\mathrm{met},B}$ (Å).\n- Concatenate the results for all three test cases into a single flat list in the same order.\n- The list entries must be numeric floats.\n\nThe program must be complete and runnable without external input. All constants and functions must be implemented explicitly. Ensure scientific realism by following the definitions above. The target education level is advanced graduate in computational materials science. The code must be written in Python and must not require any additional libraries beyond those specified.",
            "solution": "The problem requires the construction and evaluation of two norm-conserving pseudopotentials, $\\mathrm{PP}_A$ and $\\mathrm{PP}_B$, characterized by different core radii, $r_{c,A}$ and $r_{c,B}$. The core of the analysis is to quantify the fundamental trade-off in pseudopotential design: the balance between computational efficiency, represented by the plane-wave kinetic energy cutoff $E_{\\mathrm{cut}}$, and transferability, proxied by the error in bond length $\\Delta R_{\\mathrm{env}}$ across different chemical environments.\n\nThe solution is implemented by following a sequence of physically-motivated modeling steps. All calculations are performed in atomic units (Hartree for energy, Bohr for length) unless specified otherwise.\n\n**1. Reference All-Electron Scattering Model**\n\nThe scattering properties of the true all-electron potential are modeled using the effective range expansion for the $s$-wave ($l=0$) and a similar low-energy expansion for the $p$-wave ($l=1$) scattering phase shifts, $\\delta_l^{\\mathrm{ref}}(E)$. The wave vector $k$ is related to the energy $E$ by $k = \\sqrt{2E}$.\n\nFor the $s$-wave ($l=0$), the expansion is given by:\n$$\nk \\cot \\delta_0^{\\mathrm{ref}}(E) = -\\frac{1}{a_0} + \\frac{r_0}{2} k^2\n$$\nFor the $p$-wave ($l=1$), the expansion is:\n$$\nk^3 \\cot \\delta_1^{\\mathrm{ref}}(E) = -\\frac{1}{a_1} + \\frac{r_1}{2} k^2\n$$\nwhere $a_0 = 1.20\\,\\mathrm{bohr}$, $r_0 = 2.50\\,\\mathrm{bohr}$, $a_1 = 1.00\\,\\mathrm{bohr}^3$, and $r_1 = 1.80\\,\\mathrm{bohr}$ are the scattering length and effective range parameters. The phase shifts are computed using the principal value of the arctangent function, as specified:\n$$\n\\delta_0^{\\mathrm{ref}}(E) = \\arctan\\left( \\frac{k}{-\\frac{1}{a_0} + \\frac{r_0}{2} k^2} \\right)\n$$\n$$\n\\delta_1^{\\mathrm{ref}}(E) = \\arctan\\left( \\frac{k^3}{-\\frac{1}{a_1} + \\frac{r_1}{2} k^2} \\right)\n$$\n\n**2. Pseudopotential Construction**\n\nThe pseudopotential phase shifts, $\\delta_l^{\\mathrm{PP}}(E; r_c)$, are constructed as a perturbation of the reference phase shifts. This ensures that the pseudopotential mimics the true potential at specific fitting energies. The model is:\n$$\n\\delta_l^{\\mathrm{PP}}(E; r_c) = \\delta_l^{\\mathrm{ref}}(E) + \\gamma_l(r_c)\\, h_l(E)\n$$\nThe perturbation consists of two parts:\n- A smooth polynomial function $h_l(E)$, designed to be zero at the fitting energies $E_1 = 0.20$, $E_2 = 0.80$, and $E_3 = 1.50$ (all in Hartree). A double root at $E_1$ enforces that the derivative also matches the reference, a key component of the norm-conservation constraint.\n$$\nh_l(E) = C_l \\,(E - E_1)^2 (E - E_2)(E - E_3)\n$$\nwith given constants $C_0 = 0.02$ and $C_1 = 0.015$.\n- A hardness-dependent amplitude $\\gamma_l(r_c)$ that scales with the core radius $r_c$. A smaller $r_c$ (a \"harder\" potential) implies a larger perturbation away from the fitting energies.\n$$\n\\gamma_l(r_c) = \\frac{c_l}{r_c^4}\n$$\nwith constants $c_0 = 0.12$ and $c_1 = 0.10$.\n\n**3. Plane-Wave Cutoff Energy ($E_{\\mathrm{cut}}$)**\n\nThe computational cost of a plane-wave calculation is largely determined by the kinetic energy cutoff, $E_{\\mathrm{cut}}$. This cutoff is related to the smoothness of the pseudopotential in real space. A smoother potential (larger $r_c$) decays faster in reciprocal space, requiring a lower $E_{\\mathrm{cut}}$. This relationship is modeled by assuming the pseudopotential's form factor decays as a Gaussian, $|V_l(G)|^2 \\propto \\exp\\left( - (G r_c)^2 \\right)$, where $G$ is the reciprocal-space vector magnitude.\n\nThe required reciprocal-space cutoff, $G_{\\mathrm{cut}}$, is determined by ensuring that the fraction of the \"tail\" of the potential lying beyond $G_{\\mathrm{cut}}$ is less than a specified tolerance $\\varepsilon$. This tail fraction is given by:\n$$\nf_{\\mathrm{tail}}(G_{\\mathrm{cut}}; r_c) = \\mathrm{erfc}(z) + \\frac{2}{\\sqrt{\\pi}} z e^{-z^2}, \\quad \\text{where } z = r_c\\, G_{\\mathrm{cut}}\n$$\nWe must numerically solve the nonlinear equation $f_{\\mathrm{tail}}(z) = \\varepsilon$ for the variable $z$. A root-finding algorithm, specifically Brent's method, is employed for this task, leveraging the fact that $f_{\\mathrm{tail}}(z)$ is a monotonically decreasing function for $z > 0$. Once the solution $z^*$ is found, we obtain $G_{\\mathrm{cut}} = z^* / r_c$. The corresponding plane-wave kinetic energy cutoff is:\n$$\nE_{\\mathrm{cut}} = \\frac{G_{\\mathrm{cut}}^2}{2}\n$$\nThis value, calculated in Hartree, is then converted to electronvolts ($1\\,\\mathrm{Hartree} = 27.2114\\,\\mathrm{eV}$).\n\n**4. Transferability Error ($\\Delta R_{\\mathrm{env}}$)**\n\nThe transferability of a pseudopotential assesses its accuracy in chemical environments different from the one it was fitted for. We use a proxy for the error in predicted bond length, $\\Delta R_{\\mathrm{env}}$, defined as a weighted integral of the absolute difference between the pseudopotential and reference phase shifts over a range of energies.\n$$\n\\Delta R_{\\mathrm{env}}(r_c) = \\alpha \\sum_{l=0}^{1} w_l \\int_{0}^{E_{\\max}} P_{\\mathrm{env}}(E) \\left| \\delta_l^{\\mathrm{PP}}(E; r_c) - \\delta_l^{\\mathrm{ref}}(E) \\right|\\, dE\n$$\nThe parameters are given as $\\alpha = 0.02\\,\\mathrm{Å/rad}$, $w_0 = 0.6$, $w_1 = 0.4$, and $E_{\\max} = 2.0\\,\\mathrm{H}$. The term $|\\delta_l^{\\mathrm{PP}} - \\delta_l^{\\mathrm{ref}}|$ simplifies to $|\\gamma_l(r_c) h_l(E)|$. The expression for the error can be restructured to separate the $r_c$-dependent part from the integral:\n$$\n\\Delta R_{\\mathrm{env}}(r_c) = \\frac{\\alpha}{r_c^4} \\sum_{l=0}^{1} w_l c_l J_{l, \\mathrm{env}} \\quad \\text{where} \\quad J_{l, \\mathrm{env}} = \\int_{0}^{E_{\\max}} P_{\\mathrm{env}}(E) |h_l(E)|\\, dE\n$$\nThe energy distribution $P_{\\mathrm{env}}(E)$ is modeled for three distinct environments (molecular, ionic, metallic) using a Gaussian distribution defined by a mean $\\mu$ and standard deviation $\\sigma$, truncated to the interval $[0, E_{\\max}]$ and subsequently renormalized. The integrals $J_{l, \\mathrm{env}}$, which are independent of $r_c$, are pre-computed for each environment using numerical integration (the trapezoidal rule over a fine energy grid). With these integrals, $\\Delta R_{\\mathrm{env}}(r_c)$ can be efficiently calculated for any given $r_c$.\n\n**5. Computational Execution**\n\nThe overall computational procedure involves:\n1. Pre-calculating the fixed integrals $J_{l, \\mathrm{env}}$ for the three specified environments (molecular, ionic, metallic).\n2. Iterating through each test case, which provides values for $r_{c,A}$, $r_{c,B}$, and the cutoff tolerance $\\varepsilon$.\n3. For each pseudopotential ($\\mathrm{PP}_A$ and $\\mathrm{PP}_B$), calculate $E_{\\mathrm{cut}}$ by numerically solving for $G_{\\mathrm{cut}}$ and then converting to energy.\n4. For each pseudopotential, calculate the transferability error $\\Delta R_{\\mathrm{env}}$ for each of the three environments using the pre-computed integrals.\n5. Collate the eight resulting values for each test case and format them into the specified output string.\nThis procedure systematically evaluates the constructed pseudopotentials against the defined metrics.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc, erf\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to construct, evaluate, and compare pseudopotentials.\n    \"\"\"\n    # Define physical constants and model parameters\n    HARTREE_TO_EV = 27.2114\n\n    # Reference scattering parameters (all in atomic units)\n    A0, R0 = 1.20, 2.50  # s-wave (l=0)\n    A1, R1 = 1.00, 1.80  # p-wave (l=1)\n\n    # Pseudopotential construction parameters\n    C_L = {0: 0.02, 1: 0.015}\n    C_l = {0: 0.12, 1: 0.10}\n    E1, E2, E3 = 0.20, 0.80, 1.50\n\n    # Transferability error parameters\n    ALPHA = 0.02\n    EMAX = 2.0\n    W_L = {0: 0.6, 1: 0.4}\n\n    # Environment parameters (mu, sigma) in Hartree\n    ENVIRONMENTS = {\n        'mol': (0.20, 0.10),\n        'ion': (0.60, 0.20),\n        'met': (1.20, 0.40)\n    }\n\n    # Numerical integration parameters\n    N_PTS = 2001\n    E_GRID = np.linspace(0, EMAX, N_PTS)\n\n    # Test cases: (rc_A, rc_B, epsilon)\n    test_cases = [\n        (1.20, 1.80, 1.0e-4),\n        (1.00, 2.20, 1.0e-5),\n        (1.60, 1.60, 5.0e-5),\n    ]\n\n    def h_l(E, l):\n        \"\"\"Calculates the perturbation polynomial h_l(E).\"\"\"\n        return C_L[l] * (E - E1)**2 * (E - E2) * (E - E3)\n\n    def gamma_l(rc, l):\n        \"\"\"Calculates the scaling amplitude gamma_l(rc).\"\"\"\n        return C_l[l] / rc**4\n\n    def calculate_Ecut(rc, epsilon):\n        \"\"\"Calculates the plane-wave cutoff energy E_cut in eV.\"\"\"\n        \n        def f_tail_minus_eps(z):\n            \"\"\"Function whose root needs to be found: f_tail(z) - epsilon.\"\"\"\n            if z < 0: return 1.0 - epsilon # Domain is z >= 0\n            return erfc(z) + (2.0 / np.sqrt(np.pi)) * z * np.exp(-z**2) - epsilon\n\n        # Brent's method to find the root z* of f_tail(z) = epsilon\n        # Bracket [0.01, 8.0] is safe as f(0.01) > 0 and f(8) < 0 for relevant epsilon.\n        try:\n            z_star = brentq(f_tail_minus_eps, 0.01, 8.0)\n        except ValueError:\n            # Fallback for extreme epsilon values, though not expected here\n            if epsilon >= 1.0: return 0.0 # No cutoff needed\n            z_star = 0.0\n\n        G_cut = z_star / rc\n        E_cut_H = G_cut**2 / 2.0\n        return E_cut_H * HARTREE_TO_EV\n\n    def get_J_integrals(env_params):\n        \"\"\"Pre-calculates the transferability integrals J_l for a given environment.\"\"\"\n        mu, sigma = env_params\n        \n        # Renormalized truncated Gaussian probability distribution P_env(E)\n        unnorm_P = (1.0 / (sigma * np.sqrt(2.0 * np.pi))) * np.exp(-((E_GRID - mu)**2) / (2.0 * sigma**2))\n        \n        norm_const = 0.5 * (erf((EMAX - mu) / (sigma * np.sqrt(2.0))) - erf(-mu / (sigma * np.sqrt(2.0))))\n        \n        if norm_const < 1e-15: # Effectively zero probability in the domain\n            return 0.0, 0.0\n\n        P_env = unnorm_P / norm_const\n        \n        # Calculate integrals J_0 and J_1 using the trapezoidal rule\n        h0_vals = h_l(E_GRID, 0)\n        h1_vals = h_l(E_GRID, 1)\n        \n        integrand0 = P_env * np.abs(h0_vals)\n        integrand1 = P_env * np.abs(h1_vals)\n        \n        J0 = np.trapz(integrand0, E_GRID)\n        J1 = np.trapz(integrand1, E_GRID)\n        \n        return J0, J1\n\n    def calculate_delta_R(rc, j_integrals):\n        \"\"\"Calculates the bond length error proxy Delta_R.\"\"\"\n        J0, J1 = j_integrals\n        \n        # gamma is positive, so abs(gamma) = gamma\n        g0 = gamma_l(rc, 0)\n        g1 = gamma_l(rc, 1)\n        \n        delta_R = ALPHA * (W_L[0] * g0 * J0 + W_L[1] * g1 * J1)\n        return delta_R\n\n    # --- Main Calculation Loop ---\n    results = []\n    \n    # Pre-calculate J integrals for each environment\n    j_integrals_all_envs = {name: get_J_integrals(params) for name, params in ENVIRONMENTS.items()}\n\n    for rc_A, rc_B, epsilon in test_cases:\n        # --- Calculations for Pseudopotential A ---\n        Ecut_A = calculate_Ecut(rc_A, epsilon)\n        delta_R_mol_A = calculate_delta_R(rc_A, j_integrals_all_envs['mol'])\n        delta_R_ion_A = calculate_delta_R(rc_A, j_integrals_all_envs['ion'])\n        delta_R_met_A = calculate_delta_R(rc_A, j_integrals_all_envs['met'])\n        \n        # --- Calculations for Pseudopotential B ---\n        Ecut_B = calculate_Ecut(rc_B, epsilon)\n        delta_R_mol_B = calculate_delta_R(rc_B, j_integrals_all_envs['mol'])\n        delta_R_ion_B = calculate_delta_R(rc_B, j_integrals_all_envs['ion'])\n        delta_R_met_B = calculate_delta_R(rc_B, j_integrals_all_envs['met'])\n        \n        results.extend([\n            Ecut_A, Ecut_B,\n            delta_R_mol_A, delta_R_mol_B,\n            delta_R_ion_A, delta_R_ion_B,\n            delta_R_met_A, delta_R_met_B,\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}