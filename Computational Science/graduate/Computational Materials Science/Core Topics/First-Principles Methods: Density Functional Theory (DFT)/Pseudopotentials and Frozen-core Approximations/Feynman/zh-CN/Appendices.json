{
    "hands_on_practices": [
        {
            "introduction": "赝势构筑的核心思想是在一个截断半径 $r_c$ 之外，赝波函数能够精确地重现全电子波函数的行为。本练习将通过一个简化的模型，带你亲手实践这一基本原理，通过匹配对数微商来确定赝势的形式 。这个过程能帮助你深入理解赝势理论的基石，并为掌握更复杂的赝势构造方法打下坚实的基础。",
            "id": "3481321",
            "problem": "在冻芯近似下的保范赝势理论中，离子实和紧束缚的芯电子被一个有效势所取代，该有效势能在选定的能量下再现全电子参考的价电子散射。Hamann 构建方法和 Troullier–Martins 构建方法都要求在芯截断半径处径向波函数的对数导数相等，而 Troullier–Martins 还额外施加了高阶光滑性约束。考虑一个价电子的最简单 s-通道 ($l=0$) 散射，它由原子单位制（其中 $\\hbar = 1$ 和 $m_{e} = 1$）下的径向 Kohn–Sham 方程描述：\n$$\n- \\frac{1}{2} \\frac{d^{2} u(r)}{d r^{2}} + V(r)\\, u(r) = E\\, u(r),\n$$\n其正则边界条件为 $u(0) = 0$。在一个 Hamann 风格的最小局域赝势模型中，设\n$$\nV(r) = \\begin{cases}\nV_{0},  0 \\le r  r_{c}, \\\\\n0,  r \\ge r_{c},\n\\end{cases}\n$$\n其中 $V_{0}$ 是一个待定常数，$r_{c}$ 是芯截断半径。全电子参考给出了在截断处的对数导数目标值，\n$$\nD_{\\text{AE}}(E_{\\text{ref}}) \\equiv \\left.\\frac{u_{\\text{AE}}^{\\prime}(r)}{u_{\\text{AE}}(r)}\\right|_{r=r_{c}} \\quad \\text{在能量 } E_{\\text{ref}} \\text{ 处}.\n$$\n假设来自全电子计算的以下实际输入：参考能量为 $E_{\\text{ref}} = 0.5$ Hartree 原子单位，截断处的对数导数目标值为 $D_{\\text{AE}}(E_{\\text{ref}}) = 0$。取芯截断半径为 $r_{c} = 2$ 玻尔。仅从上述径向方程、其在恒定势区域的通解以及在 $r=r_{c}$ 处对数导数的连续性出发，推导确定 $V_{0}$ 的标量方程，并求解该方程以获得 $V_{0}$ 的数值。最终能量以 Hartree 为单位表示，并将您的答案四舍五入到四位有效数字。",
            "solution": "用户希望我解决这个问题。我已经确认问题是有效的。我现在将开始解答。\n该问题要求为一个简化的局域赝势寻找恒定的势阱深度 $V_{0}$，使得相应径向波函数的对数导数在特定能量和截断半径处与目标值匹配。\n\n控制方程是在原子单位制下用于 s-通道 ($l=0$) 的径向 Kohn-Sham 方程：\n$$\n- \\frac{1}{2} \\frac{d^{2} u(r)}{d r^{2}} + V(r)\\, u(r) = E\\, u(r)\n$$\n在原点的边界条件是 $u(0)=0$。赝势 $V(r)$ 是一个简单的方势阱：\n$$\nV(r) = \\begin{cases}\nV_{0},  0 \\le r  r_{c} \\\\\n0,  r \\ge r_{c}\n\\end{cases}\n$$\n给定参考能量 $E = E_{\\text{ref}} = 0.5$ Hartree，芯截断半径 $r_{c} = 2$ 玻尔，以及全电子对数导数目标值 $D_{\\text{AE}}(E_{\\text{ref}}) = 0$。这种赝势构建的基本条件是，赝波函数 $u(r)$ 在 $r=r_{c}$ 处的对数导数必须与全电子目标值匹配：\n$$\n\\left.\\frac{u'(r)}{u(r)}\\right|_{r=r_{c}} = D_{\\text{AE}}(E_{\\text{ref}}) = 0\n$$\n为了求出 $V_{0}$，我们必须求解在 $r  r_{c}$ 区域的径向方程，应用边界条件，然后在 $r=r_{c}$ 处施加对数导数条件。\n\n在区域 $0 \\le r  r_{c}$ 内，势为 $V(r) = V_{0}$。径向方程变为：\n$$\n- \\frac{1}{2} \\frac{d^{2} u(r)}{d r^{2}} + V_{0}\\, u(r) = E_{\\text{ref}}\\, u(r)\n$$\n整理各项，我们得到：\n$$\n\\frac{d^{2} u(r)}{d r^{2}} = -2(E_{\\text{ref}} - V_{0}) u(r)\n$$\n解的性质取决于项 $(E_{\\text{ref}} - V_{0})$ 的符号。让我们考虑两种情况。\n\n情况 1：$E_{\\text{ref}}  V_{0}$。\n在这种情况下，$(E_{\\text{ref}} - V_{0})$ 是负的。我们定义一个实常数 $\\kappa$，使得 $\\kappa^2 = 2(V_{0} - E_{\\text{ref}})$。微分方程变为：\n$$\n\\frac{d^{2} u(r)}{d r^{2}} = \\kappa^2 u(r)\n$$\n通解是双曲函数的线性组合：\n$$\nu(r) = A \\sinh(\\kappa r) + B \\cosh(\\kappa r)\n$$\n应用边界条件 $u(0)=0$：\n$$\nu(0) = A \\sinh(0) + B \\cosh(0) = A(0) + B(1) = B = 0\n$$\n所以，此区域的解必须是 $u(r) = A \\sinh(\\kappa r)$ 的形式。其导数为 $u'(r) = A \\kappa \\cosh(\\kappa r)$。对数导数为：\n$$\n\\frac{u'(r)}{u(r)} = \\frac{A \\kappa \\cosh(\\kappa r)}{A \\sinh(\\kappa r)} = \\kappa \\coth(\\kappa r)\n$$\n在 $r=r_{c}$ 处计算该值并将其设为目标值 $0$：\n$$\n\\kappa \\coth(\\kappa r_{c}) = 0\n$$\n对于非平庸解，我们需要 $\\kappa \\neq 0$，这意味着 $V_{0} \\neq E_{\\text{ref}}$。双曲余切函数 $\\coth(x)$ 对于任何有限的、非零的实数自变量 $x$ 都不会为零。因此，对于 $\\kappa \\neq 0$，该方程无解。这意味着假设 $E_{\\text{ref}}  V_{0}$ 与所需条件不一致。\n\n情况 2：$E_{\\text{ref}}  V_{0}$。\n在这种情况下，$(E_{\\text{ref}} - V_{0})$ 是正的。我们定义一个实常数 $k$，使得 $k^2 = 2(E_{\\text{ref}} - V_{0})$。微分方程变为：\n$$\n\\frac{d^{2} u(r)}{d r^{2}} = -k^2 u(r)\n$$\n通解是三角函数的线性组合：\n$$\nu(r) = C \\sin(k r) + D \\cos(k r)\n$$\n应用边界条件 $u(0)=0$：\n$$\nu(0) = C \\sin(0) + D \\cos(0) = C(0) + D(1) = D = 0\n$$\n因此，此区域的解为 $u(r) = C \\sin(k r)$。其导数为 $u'(r) = C k \\cos(k r)$。对数导数为：\n$$\n\\frac{u'(r)}{u(r)} = \\frac{C k \\cos(k r)}{C \\sin(k r)} = k \\cot(k r)\n$$\n现在，我们在 $r=r_{c}$ 处施加匹配条件：\n$$\n\\left.\\frac{u'(r)}{u(r)}\\right|_{r=r_{c}} = k \\cot(k r_{c}) = 0\n$$\n因为 $E_{\\text{ref}}  V_{0}$，所以 $k$ 不能为零（除非 $V_0 = E_{\\text{ref}}$，这将导致 $u(r)=Cr$ 且对数导数为 $1/r_c \\neq 0$）。因此，我们必须有 $\\cot(k r_{c}) = 0$。当余切函数的自变量是 $\\frac{\\pi}{2}$ 的奇数倍时，此条件成立：\n$$\nk r_{c} = n \\frac{\\pi}{2}, \\quad \\text{其中 } n = \\pm 1, \\pm 3, \\dots \\text{ 为奇整数}\n$$\n赝势的一个关键要求是，赝波函数在芯半径 $r_{c}$ 内不应有节点，以避免产生虚假的、深束缚的类芯态。波函数为 $u(r) = C \\sin(k r)$。要使其在区间 $(0, r_{c})$ 内无节点，对于所有 $r \\in (0, r_{c})$，自变量 $kr$ 必须在 $(0, \\pi)$ 范围内。这意味着 $k r_{c} \\le \\pi$。满足此无节点条件的唯一解是 $n=1$：\n$$\nk r_{c} = \\frac{\\pi}{2}\n$$\n现在我们可以求解 $V_{0}$。代入 $k$ 的定义：\n$$\n\\sqrt{2(E_{\\text{ref}} - V_{0})} \\cdot r_{c} = \\frac{\\pi}{2}\n$$\n两边平方得到：\n$$\n2(E_{\\text{ref}} - V_{0}) r_{c}^{2} = \\frac{\\pi^2}{4}\n$$\n求解 $V_{0}$：\n$$\nE_{\\text{ref}} - V_{0} = \\frac{\\pi^2}{8 r_{c}^{2}}\n$$\n$$\nV_{0} = E_{\\text{ref}} - \\frac{\\pi^2}{8 r_{c}^{2}}\n$$\n这就是推导出的 $V_{0}$ 的标量方程。现在，我们代入给定的数值：$E_{\\text{ref}} = 0.5$ 和 $r_{c} = 2$。\n$$\nV_{0} = 0.5 - \\frac{\\pi^2}{8 (2)^{2}} = 0.5 - \\frac{\\pi^2}{32}\n$$\n使用 $\\pi \\approx 3.14159265$ 的值：\n$$\n\\pi^2 \\approx 9.8696044\n$$\n$$\nV_{0} \\approx 0.5 - \\frac{9.8696044}{32} \\approx 0.5 - 0.3084251\n$$\n$$\nV_{0} \\approx 0.1915749\n$$\n题目要求最终答案四舍五入到四位有效数字。\n$$\nV_{0} \\approx 0.1916\n$$\n最终的势以 Hartree 为单位给出，因为所有输入都是原子单位。",
            "answer": "$$\n\\boxed{0.1916}\n$$"
        },
        {
            "introduction": "一个高质量赝势的关键特性是其“可移植性”，即在不同化学环境中保持其准确性。本练习将引导你从第一性原理出发，推导并验证范数守恒（norm conservation）条件如何保证赝势在一阶近似下具有良好的可移植性 。通过结合理论推导与数值计算，你将深刻体会到赝势设计中的这一核心原则及其对计算结果可靠性的重要意义。",
            "id": "3481296",
            "problem": "考虑一个在原子单位制下、球对称环境中的单价电子问题，其中全电子 (AE) 处理和赝势 (PS) 处理仅在核半径 $r_c$ 内部不同，而在 $r_c$ 外部则完全相同。以径向薛定谔方程为出发点，其中角动量为 $l$ 的分波通道遵循带有有效球形势的单粒子方程。假设采用冻结核近似，即核电荷分布对环境变化不响应，并且构建 AE 到 PS 的映射是为了在 $r_c$ 外部再现价电子散射。模守恒条件定义为\n$$\n\\int_0^{r_c} \\left|\\phi_l^{\\text{PS}}(r)\\right|^2 \\, dr = \\int_0^{r_c} \\left|\\phi_l^{\\text{AE}}(r)\\right|^2 \\, dr,\n$$\n对于每个角动量通道 $l$，其中 $\\phi_l^{\\text{AE}}(r)$ 和 $\\phi_l^{\\text{PS}}(r)$ 分别表示核区域内的 AE 和 PS 径向解。\n\n从应用于球对称势散射的一阶、不含时微扰理论出发，并利用分波相移表示散射性质，请从第一性原理推导，为何当环境诱导的势移 $\\Delta V(r)$ 在核区域内缓慢变化或在 $0 \\le r \\le r_c$ 范围内为常数时，模守恒条件能确保散射性质相对于该势移的一阶可移植性。明确证明，对于 $\\Delta V(r) = \\Delta V_0$（核内常数），由于模守恒，AE 与 PS 散射响应的一阶差异会精确抵消。然后，通过将 $\\Delta V(r)$ 在 $r=0$ 附近展开，并将可移植性误差与 AE 和 PS 概率的径向矩之差关联起来，来量化当 $\\Delta V(r)$ 在核内平滑变化时的领头修正。\n\n为使该推导可通过算法进行测试，为给定的通道 $l$ 定义一个无量纲可移植性误差代理：\n$$\nT_l \\equiv \\int_0^{r_c} w(r)\\left(\\rho_l^{\\text{PS}}(r) - \\rho_l^{\\text{AE}}(r)\\right)\\, dr,\n$$\n其中对于 $X \\in \\{\\text{AE}, \\text{PS}\\}$ 有 $\\rho_l^{X}(r) \\equiv \\left|\\phi_l^{X}(r)\\right|^2$，并且 $w(r) \\equiv \\Delta V(r)/\\overline{\\Delta V}$，其中\n$$\n\\overline{\\Delta V} \\equiv \\frac{1}{r_c}\\int_0^{r_c} \\Delta V(r)\\, dr.\n$$\n根据构造，由于模守恒，对于 $\\Delta V(r)=\\text{常数}$，有 $T_l = 0$，而当 $\\Delta V(r)$ 随空间变化时，$T_l \\ne 0$ 则量化了这种偏差。为便于数值处理，将通道 $l$ 中的 AE 和 PS 核区径向概率密度建模为\n$$\n\\rho_l^{\\text{AE}}(r) = r^{2l} e^{-\\lambda r}, \\quad \\rho_l^{\\text{PS,raw}}(r) = r^{2l} e^{-\\mu r},\n$$\n其中 $\\lambda$ 和 $\\mu$ 是正衰减参数，并通过一个因子 $s$ 缩放原始 PS 模型来强制实现模守恒，使得\n$$\ns \\int_0^{r_c} r^{2l} e^{-\\mu r} \\, dr = \\int_0^{r_c} r^{2l} e^{-\\lambda r} \\, dr,\n$$\n并设对于 $0 \\le r \\le r_c$ 有 $\\rho_l^{\\text{PS}}(r) = s\\, r^{2l} e^{-\\mu r}$。环境诱导的势移 $\\Delta V(r)$ 是球对称的，并且仅在 $0 \\le r \\le r_c$ 范围内有定义。所有长度均以玻尔半径的原子单位表示，能量以哈特里表示，但根据构造，输出量 $T_l$ 是无量纲的。\n\n您的程序必须使用数值积分计算以下每个测试用例的 $T_l$，并生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。对于所有测试用例，打印输出时使用四舍五入到 6 位小数。测试套件如下：\n\n- 案例 1（恒定势移，抵消检验）：$l=0$, $r_c=1.0$, $\\lambda=4.0$, $\\mu=2.0$，且 $\\Delta V(r) = \\Delta V_0$，其中 $\\Delta V_0 = 0.5$。\n- 案例 2（平滑二次变化，理想情况）：$l=1$, $r_c=1.0$, $\\lambda=3.0$, $\\mu=2.5$，且 $\\Delta V(r) = \\Delta V_0 + \\alpha r^2$，其中 $\\Delta V_0=0.2$, $\\alpha=0.1$。\n- 案例 3（高离子性环境，强核区局域峰）：$l=0$, $r_c=0.6$, $\\lambda=6.0$, $\\mu=2.0$，且 $\\Delta V(r) = \\Delta V_0 + A e^{-r/\\xi}$，其中 $\\Delta V_0=1.0$, $A=5.0$, $\\xi=0.2$。\n- 案例 4（更高角动量抑制核区敏感性）：$l=3$, $r_c=1.2$, $\\lambda=3.0$, $\\mu=2.0$，且 $\\Delta V(r) = \\Delta V_0 + \\alpha r^2$，其中 $\\Delta V_0=0.3$, $\\alpha=0.2$。\n\n程序应：\n- 实现带有上述定义的模守恒缩放因子 $s$ 的 $\\rho_l^{\\text{AE}}(r)$ 和 $\\rho_l^{\\text{PS}}(r)$。\n- 实现指定的 $\\Delta V(r)$ 函数并计算 $\\overline{\\Delta V}$。\n- 对每个案例，在 $r \\in [0, r_c]$ 上使用数值积分计算 $T_l$。\n- 输出一行结果，格式为逗号分隔的 Python 列表，每个值四舍五入到 6 位小数，例如 `\"[x_1,x_2,x_3,x_4]\"`。\n\n您的解决方案必须为 $\\Delta V(r)$ 是常数的情况推导出模守恒的保证，并解释当 $\\Delta V(r)$ 在核内变化时领头阶偏差的来源。最终答案必须是一个完整的、可在 Python 中运行的程序，执行时能精确地按指定格式打印出所需的输出。",
            "solution": "所述问题在科学上是合理的、自洽的且定义明确的。它提出了一个标准但简化的模型，用于分析计算材料科学中赝势的一个关键性质：可移植性。所有定义、参数和目标都清晰列出，从而可以进行严格的推导和直接的数值实现。因此，我们着手进行求解。\n\n这个问题的核心在于理解赝势 (PS) 的行为方式。赝势被设计用于再现某个参考原子构型的全电子 (AE) 势的散射性质，而我们需要理解当化学环境改变时，该赝势会如何表现。这种“可移植性”对于基于赝势的计算的预测能力至关重要。我们使用一阶不含时微扰理论来分析这一点。\n\n让我们考虑一个单价电子在球对称原子核上散射的情况。每个角动量通道 $l$ 的散射性质都被编码在相移 $\\delta_l(E)$ 中。一个由环境引起的微小势能变化 $\\Delta V(r)$，将导致相移的一阶变化。根据散射态的一阶微扰理论，该变化由以下公式给出：\n$$\n\\Delta \\delta_l \\approx -\\frac{1}{v} \\int \\Delta V(\\mathbf{r}) |\\Psi_{l,E}(\\mathbf{r})|^2 \\, d^3\\mathbf{r}\n$$\n其中 $v$ 是入射电子的速度，$\\Psi_{l,E}$ 是能量为 $E$、通道为 $l$ 的未受微扰的散射波函数。在原子单位制（$m_e=1/2$, $\\hbar=1$, $e=1$）中，速度 $v$ 等于波数 $k$，其中 $E = k^2/(2m_e) = k^2$。我们假设采用这种常规标度。波函数可以分离为径向和角向部分，$\\Psi_{l,E}(\\mathbf{r}) = R_l(r) Y_{lm}(\\theta, \\phi)$。径向部分 $R_l(r)$ 通常写作 $\\phi_l(r)/r$，其中 $\\phi_l(r)$ 是径向薛定谔方程的解。对立体角积分后的径向概率密度为 $|\\phi_l(r)|^2$。问题中使用了记号 $\\rho_l(r) = |\\phi_l(r)|^2$。对角坐标积分后，相移的变化与径向积分成正比：\n$$\n\\Delta \\delta_l \\propto \\int_0^\\infty \\rho_l(r) \\Delta V(r) \\, dr\n$$\n赝势的可移植性是通过比较 PS 形式主义与 AE 形式主义中对 $\\Delta V(r)$ 的响应来评估的。一阶可移植性误差是计算出的响应之差：\n$$\n\\text{Error} \\propto \\Delta \\delta_l^{\\text{PS}} - \\Delta \\delta_l^{\\text{AE}} \\propto \\int_0^\\infty \\rho_l^{\\text{PS}}(r) \\Delta V(r) \\, dr - \\int_0^\\infty \\rho_l^{\\text{AE}}(r) \\Delta V(r) \\, dr\n$$\n这可以写成一个单一的积分：\n$$\n\\text{Error} \\propto \\int_0^\\infty \\left( \\rho_l^{\\text{PS}}(r) - \\rho_l^{\\text{AE}}(r) \\right) \\Delta V(r) \\, dr\n$$\n根据构造，对于大于截断半径 $r_c$ 的半径，赝势与全电子势是相同的。因此，相应的波函数和电荷密度也是相同的，即对于 $r \\ge r_c$ 有 $\\rho_l^{\\text{PS}}(r) = \\rho_l^{\\text{AE}}(r)$。因此，误差的积分仅在核区域内非零：\n$$\n\\text{Error} \\propto \\int_0^{r_c} \\left( \\rho_l^{\\text{PS}}(r) - \\rho_l^{\\text{AE}}(r) \\right) \\Delta V(r) \\, dr\n$$\n\n现在，我们在 $\\Delta V(r)$ 的不同条件下分析这个误差积分。\n\n**情况1：恒定势移**\n如果势移在核区域内是恒定的，即对于 $r \\in [0, r_c]$ 有 $\\Delta V(r) = \\Delta V_0$，我们可以将其从积分中提出来：\n$$\n\\text{Error} \\propto \\Delta V_0 \\int_0^{r_c} \\left( \\rho_l^{\\text{PS}}(r) - \\rho_l^{\\text{AE}}(r) \\right) \\, dr = \\Delta V_0 \\left( \\int_0^{r_c} \\rho_l^{\\text{PS}}(r) \\, dr - \\int_0^{r_c} \\rho_l^{\\text{AE}}(r) \\, dr \\right)\n$$\n问题陈述了模守恒条件：\n$$\n\\int_0^{r_c} \\left|\\phi_l^{\\text{PS}}(r)\\right|^2 \\, dr = \\int_0^{r_c} \\left|\\phi_l^{\\text{AE}}(r)\\right|^2 \\, dr \\implies \\int_0^{r_c} \\rho_l^{\\text{PS}}(r) \\, dr = \\int_0^{r_c} \\rho_l^{\\text{AE}}(r) \\, dr\n$$\n这个条件确保了在核半径内包含的总电子电荷对于 AE 和 PS 模型是相同的。将此代入误差表达式，我们发现括号中的项恰好为零。\n$$\n\\text{Error} \\propto \\Delta V_0 \\times 0 = 0\n$$\n因此，对于核内的一个恒定势移，模守恒赝势在一阶上是完全可移植的。\n\n**情况2：平滑变化的势移**\n如果 $\\Delta V(r)$ 不是常数，但在核内平滑变化，我们可以用 $r=0$ 附近的泰勒级数展开来近似它：\n$$\n\\Delta V(r) = \\Delta V(0) + r \\Delta V'(0) + \\frac{r^2}{2!} \\Delta V''(0) + \\mathcal{O}(r^3)\n$$\n将此代入误差积分：\n$$\n\\text{Error} \\propto \\int_0^{r_c} \\left(\\rho_l^{\\text{PS}} - \\rho_l^{\\text{AE}}\\right) \\left(\\Delta V(0) + r \\Delta V'(0) + \\frac{r^2}{2} \\Delta V''(0) + \\dots\\right) dr\n$$\n我们可以逐项检查：\n\\begin{align*}\n\\text{Error}  \\propto \\Delta V(0) \\int_0^{r_c} \\left(\\rho_l^{\\text{PS}} - \\rho_l^{\\text{AE}}\\right) dr  \\text{(第 1 项)} \\\\\n + \\Delta V'(0) \\int_0^{r_c} r \\left(\\rho_l^{\\text{PS}} - \\rho_l^{\\text{AE}}\\right) dr  \\text{(第 2 项)} \\\\\n + \\frac{\\Delta V''(0)}{2} \\int_0^{r_c} r^2 \\left(\\rho_l^{\\text{PS}} - \\rho_l^{\\text{AE}}\\right) dr  \\text{(第 3 项)} \\\\\n + \\dots\n\\end{align*}\n由于模守恒条件，第 1 项消失，就像在恒定势的情况下一样。因此，领头阶误差由第 2 项决定，它取决于核内 AE 和 PS 电荷密度的一阶径向矩之差。下一个修正（第 3 项）取决于二阶矩的差异，依此类推。\n$$\n\\text{Error} \\propto \\Delta V'(0) \\left( \\langle r \\rangle_{\\text{PS}} - \\langle r \\rangle_{\\text{AE}} \\right)_{\\text{core}} + \\frac{\\Delta V''(0)}{2} \\left( \\langle r^2 \\rangle_{\\text{PS}} - \\langle r^2 \\rangle_{\\text{AE}} \\right)_{\\text{core}} + \\dots\n$$\n其中 $\\langle r^n \\rangle_{X, \\text{core}} = \\int_0^{r_c} r^n \\rho_l^X(r) dr$。这表明，要使赝势具有高可移植性，其赝电荷密度 $\\rho_l^{\\text{PS}}$ 不仅必须匹配 $r_c$ 内的总 AE 电荷，还应尽可能精确地再现 AE 电荷密度的低阶径向矩。\n\n问题陈述中给出的无量纲可移植性误差代理 $T_l$，\n$$\nT_l \\equiv \\int_0^{r_c} w(r)\\left(\\rho_l^{\\text{PS}}(r) - \\rho_l^{\\text{AE}}(r)\\right)\\, dr \\quad \\text{with} \\quad w(r) = \\frac{\\Delta V(r)}{\\overline{\\Delta V}}\n$$\n正是我们已经分析过的误差积分，通过微扰的平均值 $\\overline{\\Delta V} = \\frac{1}{r_c}\\int_0^{r_c} \\Delta V(r)\\, dr$ 进行了归一化。这种归一化使得 $T_l$ 成为一个无量纲量，它捕捉了由势移 $\\Delta V(r)$ 的*形状*引起的误差，而与其总幅度无关。对于恒定的 $\\Delta V(r)$，$w(r)=1$，并且由于模守恒，$T_l=0$。对于变化的 $\\Delta V(r)$，$T_l$ 量化了与完美可移植性的偏差。\n\n下面的程序使用给定的 $\\rho_l^{\\text{AE}}$ 和 $\\rho_l^{\\text{PS}}$ 模型以及数值积分，实现了对指定测试用例的 $T_l$ 计算。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the final result.\n    \"\"\"\n\n    def calculate_transferability_error(l, rc, lam, mu, delta_v_func):\n        \"\"\"\n        Calculates the transferability error proxy T_l for a single case.\n\n        Args:\n            l (int): Angular momentum channel.\n            rc (float): Core radius.\n            lam (float): Decay parameter for the AE model.\n            mu (float): Decay parameter for the PS model.\n            delta_v_func (callable): Function for the potential shift Delta V(r).\n\n        Returns:\n            float: The calculated value of T_l.\n        \"\"\"\n        \n        # Define the functional form of the unscaled probability densities.\n        # integrand_ae_norm corresponds to rho_l^AE(r).\n        # integrand_ps_raw_norm corresponds to the unscaled rho_l^PS,raw(r).\n        integrand_ae_norm = lambda r: r**(2 * l) * np.exp(-lam * r)\n        integrand_ps_raw_norm = lambda r: r**(2 * l) * np.exp(-mu * r)\n\n        # 1. Calculate the norm-conserving scaling factor 's'.\n        # The norm is the integral of the probability density from 0 to rc.\n        norm_ae, _ = quad(integrand_ae_norm, 0, rc)\n        norm_ps_raw, _ = quad(integrand_ps_raw_norm, 0, rc)\n\n        # s scales the raw PS density to match the AE norm inside the core.\n        if np.isclose(norm_ps_raw, 0):\n            # This case implies the PS density is zero, making 's' ill-defined.\n            # Based on the problem's models, this should not occur for positive parameters.\n            # If it did, and AE norm is also zero, s=1 would be fine. If not, error is infinite.\n            # For robustness, we check, but don't expect it to be triggered.\n            s = 1.0 if np.isclose(norm_ae, 0) else np.inf\n        else:\n            s = norm_ae / norm_ps_raw\n\n        # 2. Define the final, scaled probability densities.\n        rho_ae = integrand_ae_norm\n        rho_ps = lambda r: s * integrand_ps_raw_norm(r)\n        \n        # 3. Calculate the average of the potential shift, Delta V_bar.\n        dv_integral, _ = quad(delta_v_func, 0, rc)\n        if np.isclose(rc, 0):\n            dv_bar = 0.0\n        else:\n            dv_bar = dv_integral / rc\n\n        # 4. Calculate the transferability error proxy T_l.\n        # The weight function w(r) = Delta V(r) / Delta V_bar.\n        # The integrand for T_l is w(r) * (rho_ps(r) - rho_ae(r)).\n        if np.isclose(dv_bar, 0):\n            # This can happen if Delta V(r) averages to zero.\n            # If Delta V(r) is constant and zero, the error is zero.\n            # The problem defines T_l via a ratio, so if dv_bar is zero,\n            # T_l is only well-defined if the numerator integral is also zero.\n            # We explicitly check for this, although not expected for the given test cases.\n            numerator_integrand = lambda r: delta_v_func(r) * (rho_ps(r) - rho_ae(r))\n            numerator, _ = quad(numerator_integrand, 0, rc)\n            return 0.0 if np.isclose(numerator, 0) else np.nan\n\n        # Regular case where dv_bar is non-zero.\n        integrand_tl = lambda r: (delta_v_func(r) / dv_bar) * (rho_ps(r) - rho_ae(r))\n        Tl, _ = quad(integrand_tl, 0, rc)\n        \n        return Tl\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'l': 0, 'rc': 1.0, 'lam': 4.0, 'mu': 2.0, 'dv_func': lambda r: 0.5},\n        {'l': 1, 'rc': 1.0, 'lam': 3.0, 'mu': 2.5, 'dv_func': lambda r: 0.2 + 0.1 * r**2},\n        {'l': 0, 'rc': 0.6, 'lam': 6.0, 'mu': 2.0, 'dv_func': lambda r: 1.0 + 5.0 * np.exp(-r / 0.2)},\n        {'l': 3, 'rc': 1.2, 'lam': 3.0, 'mu': 2.0, 'dv_func': lambda r: 0.3 + 0.2 * r**2},\n    ]\n\n    results = []\n    for case in test_cases:\n        Tl = calculate_transferability_error(\n            case['l'], case['rc'], case['lam'], case['mu'], case['dv_func']\n        )\n        results.append(Tl)\n\n    # Format the final output string as required.\n    # Each value is formatted to 6 decimal places.\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在实际的材料计算中，为了提高计算效率，我们常常使用比范数守恒赝势更“软”的超软赝势（Ultrasoft Pseudopotentials, USPPs）。本练习提供了一个宝贵的编程实践机会，让你通过求解广义本征值问题，亲自计算并比较超软赝势和范数守恒赝势下的总能量与原子间作用力 。通过这个练习，你将直接面对并解决超软赝势引入的复杂性，例如非正交的重叠算符，从而掌握在现代DFT计算中应用高级赝势的关键技能。",
            "id": "3481350",
            "problem": "在一个每个晶胞含一个原子的简化一维周期性固体中，使用位于原子位置中心的单个非局域投影算符对超软赝势 (USPP) 和守恒赝势 (NC) 进行建模。在原子单位制下进行计算，其中能量以哈特里 (Ha) 表示，长度以玻尔表示，力以哈特里每玻尔 (Ha/$a_0$) 表示。考虑一个单电子 Kohn–Sham 态，并在一个长度为 $L$、包含 $N$ 个点的均匀实空间网格上表示该系统，采用周期性边界条件。\n\n使用的起点和基本定义：\n- 非局域赝势的 Kohn–Sham 哈密顿量包含一个动能算符和一个局域势项，以及一个非局域投影算符的贡献。在 USPP 中，波函数满足一个带有重叠算符的广义本征值问题。\n- 动能算符由对位置的二阶导数导出，而广义本征问题的本征态的 Hellmann–Feynman 力取决于哈密顿量和重叠算符对原子位置的导数。\n- USPP 中的增广通过一个由投影算符构造的秩为一的非局域算符来改变重叠算符和电荷归一化。\n- 使用单个实标量非局域投影函数和单个局域势，两者都以原子坐标 $R$ 为中心，并且都只通过平移依赖于 $R$。\n\n离散化和模型规范：\n- 使用间距为 $\\Delta x = L/N$ 的均匀网格 $x_i$ 和周期性边界条件。动能算符通过带有周期性环绕的标准二阶中心差分拉普拉斯算子来近似。\n- 使用以 $R$ 为中心的高斯势阱作为局域势模型，$V_{\\mathrm{loc}}(x) = v_0 \\exp\\left(-\\frac{d(x,R)^2}{2 \\sigma_v^2}\\right)$，其中 $d(x,R)$ 是最近镜像周期距离。\n- 使用单个非局域投影算符 $\\beta(x) = \\beta_0 \\exp\\left(-\\frac{d(x,R)^2}{2 \\sigma_\\beta^2}\\right)$。\n- 将 USPP 广义重叠算符定义为 $S = I + q \\, |\\beta\\rangle \\langle \\beta|$，哈密顿量定义为 $H = T + V_{\\mathrm{loc}} + D \\, |\\beta\\rangle \\langle \\beta|$，其中 $T$ 是动能算符，$D$ 是非局域强度，$q$ 控制增广重叠。为保证在均匀网格上的数值一致性，将 $|\\beta\\rangle \\langle \\beta|$ 视为由带有适当网格权重因子的离散化投影向量构造的秩为一的算符。\n- 将增广能量贡献定义为 $E_{\\mathrm{aug}} = c_{\\mathrm{aug}} \\left(\\langle \\beta | \\psi \\rangle\\right)^2$，其中标量 $c_{\\mathrm{aug}}$ 用于调节增广能量。此项不属于广义重叠部分，但通过 $\\beta$ 对 $R$ 的显式依赖性，对总能量及其力有明确的贡献。\n\n任务：\n1. 在网格上构造 $H$ 和 $S$ 的离散矩阵，作为实对称矩阵处理，并在离散设置中一致地处理秩为一的投影算符。\n2. 求解 USPP 下的广义本征值问题 $H \\phi = \\varepsilon S \\phi$ 以获得最低能量态，并归一化本征向量使得 $\\phi^T S \\phi = 1$。\n3. 计算总能量，即在 USPP 本征态上评估的局域、非局域和增广贡献之和。局域贡献是 $T + V_{\\mathrm{loc}}$ 的期望值，非局域贡献是投影能量，增广贡献是模型 $E_{\\mathrm{aug}}$。\n4. 通过显式评估局域势和非局域投影算符的导数贡献，计算 USPP 情况下的原子上的 Hellmann–Feynman 力，并根据广义本征问题的要求，包含与 $\\varepsilon$ 相关的重叠算符贡献。此外，通过增广能量对投影算符的依赖性，包含其产生的显式力。\n5. 对 NC 情况重复步骤 2-4，其中 $q = 0$ 且 $c_{\\mathrm{aug}} = 0$，即 $S = I$ 且不包含增广能量。使用未经重叠修改的相同 $H$，求解标准本征问题，并相应地计算总能量和力的贡献。\n\n网格积分约定：\n- 变换离散波函数以确保欧几里得点积对应于物理积分，并构造 $H$ 和 $S$ 以使广义本征问题直接与积分相关。所有基于投影算符的秩为一算符必须包含适当的网格权重缩放，以使 $\\langle \\beta | \\psi \\rangle$ 近似于连续积分。\n\n力评估指南：\n- 使用适用于广义本征问题的 Hellmann–Feynman 力，该力包含重叠算符项，并通过恒等式 $\\partial_R f(x-R) = - \\partial_x f(x-R)$ 和周期性边界条件计算 $V_{\\mathrm{loc}}$ 和 $\\beta$ 相对于 $R$ 的空间导数。\n- 投影算符的导数产生 $\\partial_R \\beta$ 与 $\\beta$ 的对称秩为一组合。在离散网格上使用适当的权重一致地评估所有项。\n\n单位和输出：\n- 能量以哈特里 (Ha) 表示，力以哈特里每玻尔 (Ha/$a_0$) 表示。每个数值结果都应为浮点数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为方括号括起来的逗号分隔列表，顺序为 $[E_{\\mathrm{USPP}}^{(1)},F_{\\mathrm{USPP}}^{(1)},E_{\\mathrm{NC}}^{(1)},F_{\\mathrm{NC}}^{(1)},E_{\\mathrm{USPP}}^{(2)},F_{\\mathrm{USPP}}^{(2)},E_{\\mathrm{NC}}^{(2)},F_{\\mathrm{NC}}^{(2)},\\dots]$。\n\n测试套件：\n使用以下参数集，均采用原子单位，其中 $L = 10.0$, $N = 256$, $v_0 = -5.0$, $\\sigma_v = 0.5$, $\\beta_0 = 1.0$, $\\sigma_\\beta = 0.4$:\n- 案例 1：$R = 3.0$, $D = 0.5$, $q = 0.2$, $c_{\\mathrm{aug}} = 0.1$。\n- 案例 2 (NC 边界)：$R = 3.0$, $D = 0.5$, $q = 0.0$, $c_{\\mathrm{aug}} = 0.0$。\n- 案例 3 (无非局域，仅增广重叠)：$R = 5.0$, $D = 0.0$, $q = 0.6$, $c_{\\mathrm{aug}} = 0.2$。\n- 案例 4 (强增广)：$R = 7.5$, $D = 0.5$, $q = 1.0$, $c_{\\mathrm{aug}} = 0.5$。\n\n您的实现必须是完全自包含的，除了上述信息外不作任何假设，并以指定的精确格式生成最终输出。",
            "solution": "该问题要求计算由超软 (USPP) 和守恒 (NC) 赝势描述的一维周期性系统的基态能量和原子力。解决方案涉及在实空间网格上离散化 Kohn-Sham 方程，并求解所得的矩阵本征值问题。所有计算均在原子单位制（$\\hbar=1$, $m_e=1$, $e=1$）下进行。\n\n问题的核心在于广义本征值方程 $H\\phi = \\varepsilon S\\phi$。在 USPP 形式体系中，哈密顿量 $H$ 和重叠算符 $S$ 都被一个非局域投影算符 $|\\beta\\rangle$ 修改。总能量是期望值和一个显式增广项的总和。力是使用 Hellmann-Feynman 定理推导出来的，该定理被推广以适用于非幺正重叠算符。\n\n首先，我们建立连续形式的表述。系统由一个在长度为 $L$ 的周期性晶胞中的单电子描述。哈密顿算符为 $H = T + V_{\\mathrm{loc}} + D |\\beta\\rangle \\langle \\beta|$，其中 $T = -\\frac{1}{2} \\frac{d^2}{dx^2}$ 是动能算符，$V_{\\mathrm{loc}}(x, R)$ 是以原子位置 $R$ 为中心的局域势，$D |\\beta\\rangle \\langle \\beta|$ 是强度为 $D$ 的非局域投影算符。投影函数是 $\\beta(x, R)$。对于 USPP，重叠算符是 $S = I + q |\\beta\\rangle \\langle \\beta|$，其中 $I$ 是单位算符，$q$ 是增广电荷参数。总能量定义为动能和局域势算符的期望值、非局域投影能量以及一个独立的增广能量项的总和：\n$$\nE_{\\text{USPP}} = \\frac{\\langle \\phi | T + V_{\\mathrm{loc}} | \\phi \\rangle}{\\langle \\phi | S | \\phi \\rangle} + D \\frac{(\\langle \\phi | \\beta \\rangle)^2}{\\langle \\phi | S | \\phi \\rangle} + c_{\\mathrm{aug}} \\frac{(\\langle \\phi | \\beta \\rangle)^2}{\\langle \\phi | S | \\phi \\rangle}\n$$\n其中所有内积 $\\langle f | g \\rangle$ 都意味着积分 $\\int f^*(x) g(x) dx$。本征函数 $\\phi$ 被归一化，使得 $\\langle \\phi | S | \\phi \\rangle = 1$。在此归一化下，广义本征问题的本征值 $\\varepsilon$ 对应于前两项的和，$\\varepsilon = \\langle \\phi | H | \\phi \\rangle = \\langle \\phi | T + V_{\\mathrm{loc}} | \\phi \\rangle + D (\\langle \\phi | \\beta \\rangle)^2$。因此，总能量简化为 $E_{\\text{USPP}} = \\varepsilon + E_{\\text{aug}}$，其中 $E_{\\text{aug}} = c_{\\mathrm{aug}}(\\langle \\phi | \\beta \\rangle)^2$。\n\n为了数值求解，我们在长度为 $L$ 的晶胞上将系统离散化到一个包含 $N$ 个点 $\\{x_i\\}$ 的均匀网格上，网格间距为 $\\Delta x = L/N$。函数变为向量，例如，分量为 $\\psi_i = \\psi(x_i)$ 的 $\\vec{\\psi}$。积分通过求和来近似：$\\int f(x) dx \\approx \\sum_i f(x_i) \\Delta x$。因此，内积为 $\\langle f|g \\rangle \\approx (\\vec{f}^T \\vec{g}) \\Delta x$。\n\n算符变为 $N \\times N$ 矩阵。动能算符 $T$ 由矩阵 $\\mathbf{T}$ 表示。对二阶导数使用二阶中心差分近似 $\\frac{d^2\\psi}{dx^2}\\Big|_{x_i} \\approx \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{\\Delta x^2}$，矩阵 $\\mathbf{T}$ 的矩阵元为：\n$$\n\\mathbf{T}_{ij} = \\begin{cases} 1/\\Delta x^2  i=j \\\\ -1/(2\\Delta x^2)  |i-j|=1 \\text{ or } (N-1) \\text{ (periodic)} \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n局域势 $V_{\\mathrm{loc}}(x) = v_0 \\exp\\left(-\\frac{d(x,R)^2}{2 \\sigma_v^2}\\right)$（其中 $d(x,R)$ 是周期性距离）成为一个对角矩阵 $\\mathbf{V}_{\\mathrm{loc}}$，其元素为 $(\\mathbf{V}_{\\mathrm{loc}})_{ii} = V_{\\mathrm{loc}}(x_i)$。\n\n非局域投影算符 $|\\beta\\rangle\\langle\\beta|$ 作用于波函数 $\\psi$ 的结果是 $\\beta(x) \\int \\beta(x')\\psi(x')dx'$。在离散形式下，它作用于向量 $\\vec{\\psi}$ 的结果是一个向量，其第 $i$ 个分量是 $\\beta_i \\sum_j \\beta_j \\psi_j \\Delta x$。这对应于矩阵运算 $(\\Delta x \\cdot \\vec{\\beta}\\vec{\\beta}^T)\\vec{\\psi}$。因此，矩阵表示为：\n$$\n\\mathbf{H} = \\mathbf{T} + \\mathbf{V}_{\\mathrm{loc}} + D \\Delta x (\\vec{\\beta}\\vec{\\beta}^T)\n$$\n$$\n\\mathbf{S} = \\mathbf{I} + q \\Delta x (\\vec{\\beta}\\vec{\\beta}^T)\n$$\n其中 $\\mathbf{I}$ 是单位矩阵，$\\vec{\\beta}$ 是投影值 $\\beta(x_i)$ 的向量。广义本征值问题变成了矩阵方程 $\\mathbf{H}\\vec{\\phi}_{\\text{raw}} = \\varepsilon \\mathbf{S}\\vec{\\phi}_{\\text{raw}}$。标准数值求解器得到的本征向量 $\\vec{\\phi}_{\\text{raw}}$ 满足归一化条件 $\\vec{\\phi}_{\\text{raw}}^T \\mathbf{S} \\vec{\\phi}_{\\text{raw}} = 1$。满足连续归一化条件 $\\langle \\phi | S | \\phi \\rangle = \\vec{\\phi}^T \\mathbf{S} \\vec{\\phi} \\Delta x = 1$ 的物理波函数向量 $\\vec{\\phi}$ 与求解器输出的关系是 $\\vec{\\phi} = \\vec{\\phi}_{\\text{raw}} / \\sqrt{\\Delta x}$。\n\n总能量由最低本征值 $\\varepsilon$ 和相应的本征向量 $\\vec{\\phi}$ 计算得出。\n$$\nE_{\\text{USPP}} = \\varepsilon + c_{\\mathrm{aug}} (\\vec{\\phi}^T \\vec{\\beta} \\Delta x)^2\n$$\n原子上的力为 $F = -dE_{\\text{tot}}/dR$。将 Hellmann-Feynman 定理应用于广义本征问题部分 ($\\varepsilon$) 并加上增广项的显式导数，可得：\n$$\nF = - \\left( \\frac{d\\varepsilon}{dR} + \\frac{\\partial E_{\\text{aug}}}{\\partial R} \\right) = - \\left( \\langle \\phi | \\frac{\\partial H}{\\partial R} - \\varepsilon \\frac{\\partial S}{\\partial R} | \\phi \\rangle_{\\text{cont}} + \\frac{\\partial E_{\\text{aug}}}{\\partial R} \\right)\n$$\n算符的导数取决于 $V_{\\mathrm{loc}}(x,R)$ 和 $\\beta(x,R)$ 对 $R$ 的导数。利用性质 $\\partial_R f(x-R) = -\\partial_x f(x-R)$，我们通过网格上的中心差分来计算这些导数。设 $\\vec{V}' = \\partial_R \\vec{V}_{\\text{loc}}$ 且 $\\vec{\\beta}' = \\partial_R \\vec{\\beta}$。力的贡献为：\n$\\langle \\phi | \\partial_R V_{\\mathrm{loc}} | \\phi \\rangle = (\\vec{\\phi}^T \\text{diag}(\\vec{V}') \\vec{\\phi}) \\Delta x = ((\\vec{\\phi} \\circ \\vec{\\phi})^T \\vec{V}') \\Delta x$。\n$\\langle \\phi | \\partial_R (|\\beta\\rangle\\langle\\beta|) | \\phi \\rangle = 2 \\langle \\phi|\\beta \\rangle \\langle \\phi|\\beta' \\rangle = 2 C C'$，其中 $C = \\vec{\\phi}^T \\vec{\\beta} \\Delta x$ 且 $C' = \\vec{\\phi}^T \\vec{\\beta}' \\Delta x$。\n合并各项，总力为：\n$$\nF_{\\text{USPP}} = - \\left[ ((\\vec{\\phi} \\circ \\vec{\\phi})^T \\vec{V}') \\Delta x + 2(D - \\varepsilon q)CC' + 2c_{\\mathrm{aug}}CC' \\right]\n$$\n$$\nF_{\\text{USPP}} = - \\left[ ((\\vec{\\phi} \\circ \\vec{\\phi})^T \\vec{V}') \\Delta x + 2(D + c_{\\mathrm{aug}} - \\varepsilon q)CC' \\right]\n$$\n其中 $\\circ$ 表示逐元素乘积。\n\n守恒 (NC) 情况通过设置 $q=0$ 和 $c_{\\mathrm{aug}}=0$ 来处理。这使重叠算符简化为 $S=I$，从而将问题变为一个标准本征值问题。总能量变为 $E_{\\text{NC}} = \\varepsilon_{\\text{NC}}$，力的表达式简化为：\n$$\nF_{\\text{NC}} = - \\left[ ((\\vec{\\phi}_{\\text{NC}} \\circ \\vec{\\phi}_{\\text{NC}})^T \\vec{V}') \\Delta x + 2D C_{\\text{NC}}C'_{\\text{NC}} \\right]\n$$\n请注意，NC 波函数 $\\vec{\\phi}_{\\text{NC}}$ 是通过求解 $S=I$ 的标准本征问题得到的，它将与 USPP 波函数不同。对于每个测试用例，我们首先执行完整的 USPP 计算，然后用 $q=0$ 和 $c_{\\mathrm{aug}}=0$ 重复计算，以获得相应的 NC 结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the 1D pseudopotential problem for a given set of test cases.\n    \"\"\"\n    # --- Global System Parameters (atomic units) ---\n    L = 10.0\n    N = 256\n    v0 = -5.0\n    sigma_v = 0.5\n    beta0 = 1.0\n    sigma_beta = 0.4\n\n    # --- Test Suite ---\n    test_cases = [\n        # (R, D, q, c_aug)\n        (3.0, 0.5, 0.2, 0.1),\n        (3.0, 0.5, 0.0, 0.0),\n        (5.0, 0.0, 0.6, 0.2),\n        (7.5, 0.5, 1.0, 0.5),\n    ]\n\n    # --- Grid Setup ---\n    dx = L / N\n    x_grid = np.linspace(0, L, N, endpoint=False)\n\n    # --- Helper Functions ---\n    def periodic_distance(x, R):\n        \"\"\"Calculates the nearest-image periodic distance.\"\"\"\n        d = np.abs(x - R)\n        return np.minimum(d, L - d)\n\n    def get_kinetic_matrix(n_points, grid_spacing):\n        \"\"\"Constructs the kinetic energy operator matrix T.\"\"\"\n        T = np.zeros((n_points, n_points), dtype=float)\n        factor = -0.5 / (grid_spacing**2)\n        diag_val = -2.0 * factor\n        offdiag_val = 1.0 * factor\n        for i in range(n_points):\n            T[i, i] = diag_val\n            T[i, (i - 1 + n_points) % n_points] = offdiag_val\n            T[i, (i + 1) % n_points] = offdiag_val\n        return T\n\n    def get_gradient(f, grid_spacing):\n        \"\"\"Calculates the spatial gradient of f using periodic central differences.\"\"\"\n        return (np.roll(f, -1) - np.roll(f, 1)) / (2 * grid_spacing)\n\n    T_mat = get_kinetic_matrix(N, dx)\n\n    # --- Main Calculation Function ---\n    def solve_case(R, D, q, c_aug):\n        \"\"\"\n        Calculates energy and force for a single parameter set.\n        \"\"\"\n        # A. Build operators on the grid\n        V_loc_vec = v0 * np.exp(-periodic_distance(x_grid, R)**2 / (2 * sigma_v**2))\n        beta_vec = beta0 * np.exp(-periodic_distance(x_grid, R)**2 / (2 * sigma_beta**2))\n        \n        V_loc_mat = np.diag(V_loc_vec)\n        beta_proj = np.outer(beta_vec, beta_vec)\n        \n        H_mat = T_mat + V_loc_mat + D * dx * beta_proj\n        S_mat = np.identity(N) + q * dx * beta_proj\n        \n        # B. Solve the generalized eigenvalue problem H*phi = eps*S*phi\n        eps_all, phi_raw_mat = eigh(H_mat, S_mat)\n        eps = eps_all[0]\n        phi_raw = phi_raw_mat[:, 0]\n        \n        # C. Calculate Total Energy\n        phi = phi_raw / np.sqrt(dx)\n        C = np.dot(phi, beta_vec) * dx\n        E_aug = c_aug * C**2\n        E_total = eps + E_aug\n        \n        # D. Calculate Hellmann-Feynman Force\n        V_loc_grad_vec = -get_gradient(V_loc_vec, dx)\n        beta_grad_vec = -get_gradient(beta_vec, dx)\n        \n        force_local = np.dot(phi**2, V_loc_grad_vec) * dx\n        C_prime = np.dot(phi, beta_grad_vec) * dx\n        force_nonlocal = 2 * (D + c_aug - eps * q) * C * C_prime\n        \n        F_total = -(force_local + force_nonlocal)\n        \n        return E_total, F_total\n\n    # --- Process all test cases ---\n    all_results = []\n    for R, D_uspp, q, c_aug in test_cases:\n        # Calculate USPP case\n        E_uspp, F_uspp = solve_case(R, D_uspp, q, c_aug)\n        all_results.extend([E_uspp, F_uspp])\n        \n        # Calculate corresponding NC case\n        E_nc, F_nc = solve_case(R, D_uspp, 0.0, 0.0)\n        all_results.extend([E_nc, F_nc])\n        \n    # --- Format and Print Output ---\n    output_str = f\"[{','.join([f'{r:.6f}' for r in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}