{
    "hands_on_practices": [
        {
            "introduction": "本练习将建立平面波能量截断（$E_{\\text{cut}}$）与模拟中实空间分辨率之间的基本联系。你将从基本的量子力学和采样理论出发，亲手推导它们之间的关系，从而深刻直观地理解为何“更硬”的赝势（具有更小的核半径）需要更高的 $E_{\\text{cut}}$ 来精确描述原子核附近波函数的快速振荡。该实践为你提供了一种在进行完整收敛性测试之前，预估必要能量截断值的原则性方法。",
            "id": "3440845",
            "problem": "您的任务是构建一个基于第一性原理的预测器，用于预测解析模守恒赝势核心区短波长特征所需的最小平面波能量截断，然后使用一个简单的、物理上合理的收敛模型对计算出的可观测量进行验证，从而验证该预测。工作应完全基于第一性原理和经过充分检验的事实，而非快捷公式。\n\n起点与目标：\n- 从电子平面波（动量为 $\\mathbf{p}$）的非相对论动能、动量与波矢之间的德布罗意关系，以及实空间中带限函数的经典采样准则出发。基于这些，推导平面波能量截断与所保留的最大倒易晶格矢量大小之间的关系，以及实空间采样分辨率与该倒易空间带宽之间的关系。\n- 使用这些推导出的关系，获得一个预测器，用于预测在核心区直径 $2 r_c$ 至少被 $N$ 个网格点采样的约束下，为使实空间网格能解析半径为 $r_c$ 的赝势核心区中的振荡特征所需的最小能量截断 $E_{\\mathrm{cut,min}}$。\n- 使用一个综合的、物理上合理的收敛模型，对计算出的 Bader 电荷可观测量进行验证，从而验证预测的 $E_{\\mathrm{cut,min}}$。Bader 电荷是通过电子密度中的零通量面分配给原子的积分电子电荷，其单位为电子。假设该可观测量随倒易空间带宽的增加而单调收敛，并且可以模型化为指数趋近于一个极限值。\n\n使用的基本事实：\n- 非相对论粒子的动能为 $E = p^2/(2m)$，其中 $p$ 是动量， $m$ 是电子质量。\n- 德布罗意关系将动量与波矢联系起来：$p = \\hbar k$，其中 $k$ 是波矢的模，$\\hbar$ 是约化普朗克常数。\n- 对一个带限于最大波矢模 $G_{\\max}$ 的函数进行实空间采样，要求网格间距不大于奈奎斯特间距，该间距与 $G_{\\max}$ 成反比。\n- 单位与换算：能量以电子伏特 (eV) 表示，长度以埃 ($\\mathrm{\\AA}$) 表示，电子质量以 $\\mathrm{kg}$ 表示，约化普朗克常数以 $\\mathrm{J\\cdot s}$ 表示。在从 $G_{\\max}$ 计算 $E_{\\mathrm{cut}}$ 时，按需使用精确的国际单位制（SI）常数和单位换算。\n\n预测准则：\n- 施加核心区直径 $2 r_c$ 至少被 $N$ 个点采样的要求。这意味着实空间网格间距 $\\Delta x$ 必须满足 $\\Delta x \\le 2 r_c / N$。\n- 结合 $E_{\\mathrm{cut}}$、$G_{\\max}$ 和 $\\Delta x$ 之间的关系，得到作为 $r_c$ 和 $N$ 的函数的 $E_{\\mathrm{cut,min}}$。\n\n验证模型：\n- 设模型化的 Bader 电荷为 $Q(G_{\\max}) = Q_{\\infty} - A \\exp(-\\kappa G_{\\max})$，其中 $Q_{\\infty}$ 是当 $G_{\\max} \\to \\infty$ 时的渐近值，$A$ 是一个正振幅，$\\kappa$ 是一个量纲为长度倒数的正常数衰减参数，使得 $\\kappa G_{\\max}$ 无量纲。假设 $Q(G_{\\max})$ 的单位是电子。\n- 定义收敛判据如下：对于给定的 $E_{\\mathrm{cut}}$ 及其对应的 $G_{\\max}$，计算在缩放后的截断能 $\\alpha_1 E_{\\mathrm{cut}}$ 和 $\\alpha_2 E_{\\mathrm{cut}}$（其中 $\\alpha_1 > 1$ 且 $\\alpha_2 > \\alpha_1$）下的可观测量。如果可观测量大小的两次连续差值均小于容差 $\\tau$（单位：电子），则宣布收敛。\n\n数值要求与输出：\n- 在所有计算中使用以下国际单位制（SI）的物理常数：\n  - 电子质量 $m = 9.1093837015 \\times 10^{-31}\\,\\mathrm{kg}$，\n  - 约化普朗克常数 $\\hbar = 1.054571817 \\times 10^{-34}\\,\\mathrm{J\\cdot s}$，\n  - 电子伏特到焦耳的换算 $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$，\n  - 埃到米的换算 $1\\,\\mathrm{\\AA} = 1.0 \\times 10^{-10}\\,\\mathrm{m}$。\n- 以 eV 为单位表示预测的最小能量截断 $E_{\\mathrm{cut,min}}$，四舍五入到一位小数。\n- 以 $\\mathrm{\\AA}$ 为单位表示相应的实空间网格间距 $\\Delta x$，四舍五入到三位小数。\n- Bader 电荷的单位是电子；用于收敛判断的差值必须以电子为单位计算。使用 $0.002$ 电子的容差 $\\tau$。\n\n测试集：\n- 使用代表氧（O）、氮（N）和氟（F）的三个赝势核心区半径，其 $r_c$ 值和模型参数指定如下：\n  1. 氧：$r_c = 0.60\\,\\mathrm{\\AA}$，$N = 6$，$Q_{\\infty} = 6.0$ 电子，$A = 0.5$ 电子，$\\kappa = 0.30\\,\\mathrm{\\AA}^{-1}$。\n  2. 氮：$r_c = 0.55\\,\\mathrm{\\AA}$，$N = 6$，$Q_{\\infty} = 5.0$ 电子，$A = 0.5$ 电子，$\\kappa = 0.28\\,\\mathrm{\\AA}^{-1}$。\n  3. 氟：$r_c = 0.50\\,\\mathrm{\\AA}$，$N = 6$，$Q_{\\infty} = 7.0$ 电子，$A = 0.5$ 电子，$\\kappa = 0.32\\,\\mathrm{\\AA}^{-1}$。\n- 对于验证缩放因子，使用 $\\alpha_1 = 1.25$ 和 $\\alpha_2 = 1.50$。\n\n算法任务：\n- 推导并实现从 $E_{\\mathrm{cut}}$ 到 $G_{\\max}$ 以及从 $G_{\\max}$ 到 $\\Delta x$ 的映射。\n- 对每个测试用例，根据 $r_c$ 和 $N$ 的约束计算预测的 $E_{\\mathrm{cut,min}}$。\n- 计算相应的 $\\Delta x$。\n- 通过在 $E_{\\mathrm{cut,min}}$、$\\alpha_1 E_{\\mathrm{cut,min}}$ 和 $\\alpha_2 E_{\\mathrm{cut,min}}$ 处评估模型化的 Bader 电荷来进行收敛性验证，并正确地将每个能量转换为 $G_{\\max}$。报告基于连续差值的收敛判据是否满足。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的 Python 风格列表的结果，每个测试用例一个条目，顺序为氧、氮、氟。\n- 每个条目必须是一个形式为 $[E_{\\mathrm{cut,min}}, \\Delta x, \\text{converged}]$ 的列表，其中 $E_{\\mathrm{cut,min}}$ 是一个以 eV 为单位、四舍五入到一位小数的浮点数，$\\Delta x$ 是一个以 $\\mathrm{\\AA}$ 为单位、四舍五入到三位小数的浮点数，$\\text{converged}$ 是一个布尔值，指示在预测的截断能下验证判据是否成立。\n- 格式示例（使用占位符值）：$[[100.0,0.250,True],[110.0,0.245,False],[120.0,0.240,True]]$。\n\n角度单位不适用。本问题不使用百分比。确保所有计算量都遵守指定的单位和四舍五入指令，且程序无需用户输入。",
            "solution": "该问题要求推导一个用于预测计算材料学中所需最小平面波能量截断 $E_{\\mathrm{cut,min}}$ 的预测模型，并随后使用一个综合的收敛模型对该预测进行验证。整个过程将按要求从第一性原理出发进行开发。\n\n### 第一部分：基本关系的推导\n\n基于平面波的电子结构方法（如密度泛函理论，DFT）的基础在于将波函数展开为平面波基组。该基组的大小由一个能量截断 $E_{\\mathrm{cut}}$ 控制。我们首先建立这个能量截断、它所定义的倒易空间带宽以及相应的实空间网格分辨率之间的关系。\n\n首先，我们考虑一个非相对论自由电子的动能 $E$。它由经典表达式给出：\n$$E = \\frac{p^2}{2m}$$\n其中 $p$ 是电子动量的模， $m$ 是电子质量。德布罗意关系将该动量与电子波矢的模 $k = |\\mathbf{k}|$ 联系起来：\n$$p = \\hbar k$$\n其中 $\\hbar$ 是约化普朗克常数。将德布罗意关系代入动能表达式，我们得到电子平面波的能量：\n$$E(k) = \\frac{(\\hbar k)^2}{2m} = \\frac{\\hbar^2 k^2}{2m}$$\n在平面波计算中，基组被截断，只包含动能最高达到指定截断能 $E_{\\mathrm{cut}}$ 的平面波。这意味着展开式中包含了所有满足 $\\frac{\\hbar^2 G^2}{2m} \\le E_{\\mathrm{cut}}$ 的倒易晶格矢量 $\\mathbf{G}$。因此，基组中所包含的最大倒易晶格矢量的大小，记为 $G_{\\max}$，由该截断能决定：\n$$E_{\\mathrm{cut}} = \\frac{\\hbar^2 G_{\\max}^2}{2m}$$\n这个方程提供了从倒易空间带宽 $G_{\\max}$ 到能量截断 $E_{\\mathrm{cut}}$ 的直接映射。我们可以反解它来求得给定 $E_{\\mathrm{cut}}$ 对应的 $G_{\\max}$：\n$$G_{\\max} = \\frac{\\sqrt{2m E_{\\mathrm{cut}}}}{\\hbar}$$\n接下来，我们将倒易空间带宽 $G_{\\max}$ 与实空间网格分辨率 $\\Delta x$ 联系起来。采样定理指出，为了无混叠地表示一个函数，采样率必须足够高。对于一个傅里叶分量在波矢模大于 $G_{\\max}$ 时为零的函数，所需的最小采样分辨率与 $G_{\\max}$ 相关。平面波计算代码中的一个标准惯例是，为确保最高频率的基函数得到良好表示，根据基函数本身的类奈奎斯特判据来设置实空间网格间距 $\\Delta x$：\n$$\\Delta x \\le \\frac{\\pi}{G_{\\max}}$$\n为了在给定的 $G_{\\max}$ 下获得尽可能高的分辨率（反之亦然），我们取等式：\n$$\\Delta x = \\frac{\\pi}{G_{\\max}}$$\n这个关系意味着更大的倒易空间带宽（更大的 $G_{\\max}$）对应更精细的实空间网格（更小的 $\\Delta x$），这对于表示更短波长的特征是必需的。\n\n### 第二部分：$E_{\\mathrm{cut,min}}$ 预测器的推导\n\n我们的任务是推导一个预测器，用于预测解析赝势核心区内特征所需的最小能量截断 $E_{\\mathrm{cut,min}}$。问题提出了一个具体的实空间采样约束：赝势核心区的直径 $2r_c$ 必须被至少 $N$ 个网格点采样。这为最大允许的网格间距 $\\Delta x$ 提供了一个直接条件：\n$$N \\cdot \\Delta x \\le 2r_c \\quad \\implies \\quad \\Delta x \\le \\frac{2r_c}{N}$$\n为了满足这个约束，同时使用尽可能低的能量截断（从而使用尽可能大的 $\\Delta x$），我们将网格间距设置为其最大允许值：\n$$\\Delta x = \\frac{2r_c}{N}$$\n现在，我们可以结合我们推导出的关系。将这个 $\\Delta x$ 的表达式代入其与 $G_{\\max}$ 相关的方程中，我们可以找到所需的最小倒易空间带宽，我们称之为 $G_{\\mathrm{cut,min}}$：\n$$\\frac{2r_c}{N} = \\frac{\\pi}{G_{\\mathrm{cut,min}}} \\quad \\implies \\quad G_{\\mathrm{cut,min}} = \\frac{N\\pi}{2r_c}$$\n最后，我们将这个最小所需带宽 $G_{\\mathrm{cut,min}}$ 代入能量-波矢关系式，以求得预测的最小能量截断 $E_{\\mathrm{cut,min}}$：\n$$E_{\\mathrm{cut,min}} = \\frac{\\hbar^2 G_{\\mathrm{cut,min}}^2}{2m} = \\frac{\\hbar^2}{2m} \\left( \\frac{N\\pi}{2r_c} \\right)^2$$\n该公式提供了一个直接的、基于第一性原理的预测器，用于根据赝势核心区的物理尺寸 $r_c$ 和期望的采样密度 $N$ 来预测最小能量截断。\n\n### 第三部分：验证步骤\n\n为了验证这个预测，我们使用一个综合模型来描述计算出的可观测量——Bader 电荷 $Q$——随倒易空间带宽 $G_{\\max}$ 的收敛行为。该模型被给出为指数趋近于渐近值 $Q_{\\infty}$ 的形式：\n$$Q(G_{\\max}) = Q_{\\infty} - A e^{-\\kappa G_{\\max}}$$\n其中 $A$ 是一个正振幅，$\\kappa$ 是一个正常数衰减常数。\n\n验证方案如下：\n1.  对于每个测试用例（原子），使用给定的参数 $r_c$、$N$、$Q_{\\infty}$、$A$ 和 $\\kappa$，首先计算预测的 $E_{\\mathrm{cut,min}}$ 和相应的 $\\Delta x$。\n2.  在该预测的截断能下评估可观测量 $Q$ 的收敛性。判据涉及检查在缩放后的能量截断下 $Q$ 的连续差值。定义基准能量 $E_0 = E_{\\mathrm{cut,min}}$，以及两个更高的能量 $E_1 = \\alpha_1 E_0$ 和 $E_2 = \\alpha_2 E_0$，其中给定的缩放因子为 $\\alpha_1 = 1.25$ 和 $\\alpha_2 = 1.50$。\n3.  对于每个能量 $E_i$（其中 $i \\in \\{0, 1, 2\\}$），我们必须首先将其转换为相应的带宽 $G_{\\max,i}$，以便在 $Q$ 的模型中使用。这包括：\n    a.  将能量从电子伏特 ($\\mathrm{eV}$) 转换为焦耳 ($\\mathrm{J}$)，因为基本常数是国际单位制（SI）。设 $e$ 为以库仑为单位的元电荷，则 $E_{\\mathrm{J}} = E_{\\mathrm{eV}} \\cdot e$。\n    b.  使用 $G_{\\max,i} = \\frac{\\sqrt{2m E_{i, \\mathrm{J}}}}{\\hbar}$ 计算以 $\\mathrm{m}^{-1}$ 为单位的 $G_{\\max,i}$。\n    c.  将 $G_{\\max,i}$ 从 $\\mathrm{m}^{-1}$ 转换为 $\\mathrm{\\AA}^{-1}$，因为模型参数 $\\kappa$ 的单位是 $\\mathrm{\\AA}^{-1}$。换算关系为 $G_{\\max,i} [\\mathrm{\\AA}^{-1}] = G_{\\max,i} [\\mathrm{m}^{-1}] \\cdot 10^{-10} \\mathrm{m}/\\mathrm{\\AA}$。\n4.  计算每个带宽下的可观测量：$Q_0 = Q(G_{\\max,0})$，$Q_1 = Q(G_{\\max,1})$ 和 $Q_2 = Q(G_{\\max,2})$。\n5.  检查是否满足收敛判据。如果可观测量的两个连续变化量均小于容差 $\\tau = 0.002$ 电子，则认为预测得到了验证（“收敛”）：\n    $$|Q_1 - Q_0|  \\tau \\quad \\text{且} \\quad |Q_2 - Q_1|  \\tau$$\n\n### 算法总结\n\n最终的实现将对三个测试用例（氧、氮、氟）中的每一个执行以下步骤：\n1.  使用提供的 $r_c$（单位 $\\mathrm{\\AA}$）和 $N$ 的值。\n2.  使用推导出的公式计算 $E_{\\mathrm{cut,min}}$（单位 eV），确保所有物理常数（$\\hbar$、$m$、$e$）均采用国际单位制，并正确应用 $\\mathrm{\\AA}$、$\\mathrm{m}$、$\\mathrm{eV}$ 和 $\\mathrm{J}$ 之间的换算。结果四舍五入到一位小数。\n3.  计算相应的实空间网格间距 $\\Delta x = 2r_c / N$（单位 $\\mathrm{\\AA}$）。结果四舍五入到三位小数。\n4.  计算三个能量值 $E_0 = E_{\\mathrm{cut,min}}$（为保证精度使用未四舍五入的值）、$E_1 = 1.25 E_0$ 和 $E_2 = 1.50 E_0$。\n5.  对每个能量 $E_i$，计算相应的 $G_{\\max,i}$（单位 $\\mathrm{\\AA}^{-1}$）。\n6.  使用原子的特定模型参数（$Q_{\\infty}$、$A$、$\\kappa$），计算三个电荷值 $Q_0$、$Q_1$ 和 $Q_2$。\n7.  将绝对差值 $|Q_1 - Q_0|$ 和 $|Q_2 - Q_1|$ 与容差 $\\tau=0.002$ 进行比较，以确定是否满足收敛判据。\n8.  将每个原子的结果收集到一个形式为 $[E_{\\mathrm{cut,min}}, \\Delta x, \\text{converged}]$ 的列表中，并呈现在一个最终列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and validates a predictor for the plane-wave energy cutoff.\n    \"\"\"\n    \n    # Physical constants in SI units\n    M_E = 9.1093837015e-31  # Electron mass in kg\n    H_BAR = 1.054571817e-34  # Reduced Planck constant in J*s\n    E_CHARGE = 1.602176634e-19 # Elementary charge in C (J/eV)\n    ANGSTROM_TO_METER = 1.0e-10 # Angstrom to meter conversion\n\n    # Validation parameters\n    ALPHA_1 = 1.25\n    ALPHA_2 = 1.50\n    TOLERANCE = 0.002  # electrons\n\n    # Define the test cases from the problem statement.\n    # (r_c [A], N, Q_inf [e], A [e], kappa [A^-1])\n    test_cases = [\n        # Oxygen\n        (0.60, 6, 6.0, 0.5, 0.30),\n        # Nitrogen\n        (0.55, 6, 5.0, 0.5, 0.28),\n        # Fluorine\n        (0.50, 6, 7.0, 0.5, 0.32),\n    ]\n\n    results = []\n\n    def get_charge(energy_ev, q_inf, amp, kappa):\n        \"\"\"\n        Calculates the Bader charge for a given energy cutoff using the model.\n        Args:\n            energy_ev (float): Energy cutoff in eV.\n            q_inf (float): Asymptotic charge value.\n            amp (float): Exponential model amplitude.\n            kappa (float): Exponential model decay constant in A^-1.\n        Returns:\n            float: The calculated Bader charge.\n        \"\"\"\n        # Convert energy from eV to Joules\n        energy_j = energy_ev * E_CHARGE\n        \n        # Calculate G_max in m^-1\n        # E = (hbar^2 * G_max^2) / (2 * m) => G_max = sqrt(2*m*E) / hbar\n        g_max_si = np.sqrt(2 * M_E * energy_j) / H_BAR\n        \n        # Convert G_max to A^-1 for the model\n        g_max_angstrom_inv = g_max_si * ANGSTROM_TO_METER\n        \n        # Calculate charge using the convergence model\n        # Q(G_max) = Q_inf - A * exp(-kappa * G_max)\n        charge = q_inf - amp * np.exp(-kappa * g_max_angstrom_inv)\n        return charge\n\n    for case in test_cases:\n        r_c_angstrom, n_samples, q_inf, amp, kappa = case\n        \n        # --- Prediction Step ---\n        \n        # Convert core radius to meters\n        r_c_meter = r_c_angstrom * ANGSTROM_TO_METER\n        \n        # Calculate the minimum required reciprocal-space bandwidth G_cut,min in m^-1\n        # G_cut,min = (N * pi) / (2 * r_c)\n        g_cut_min_si = (n_samples * np.pi) / (2 * r_c_meter)\n        \n        # Calculate predicted minimum energy cutoff E_cut,min in Joules\n        # E_cut,min = (hbar^2 * G_cut,min^2) / (2 * m)\n        e_cut_min_j = (H_BAR**2 * g_cut_min_si**2) / (2 * M_E)\n        \n        # Convert E_cut,min to eV\n        e_cut_min_ev = e_cut_min_j / E_CHARGE\n        \n        # Calculate the corresponding real-space grid spacing in Angstrom\n        # dx = 2 * r_c / N\n        delta_x_angstrom = (2 * r_c_angstrom) / n_samples\n        \n        # --- Validation Step ---\n        \n        # Define the three energy cutoffs for validation\n        e0 = e_cut_min_ev  # Use unrounded value for precision\n        e1 = ALPHA_1 * e0\n        e2 = ALPHA_2 * e0\n        \n        # Calculate the observable Q at each cutoff\n        q0 = get_charge(e0, q_inf, amp, kappa)\n        q1 = get_charge(e1, q_inf, amp, kappa)\n        q2 = get_charge(e2, q_inf, amp, kappa)\n        \n        # Check convergence criterion\n        diff1 = abs(q1 - q0)\n        diff2 = abs(q2 - q1)\n        \n        is_converged = (diff1  TOLERANCE) and (diff2  TOLERANCE)\n        \n        # --- Formatting Step ---\n        \n        # Round final results as per requirements\n        e_cut_min_rounded = round(e_cut_min_ev, 1)\n        delta_x_rounded = round(delta_x_angstrom, 3)\n        \n        results.append([e_cut_min_rounded, delta_x_rounded, is_converged])\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) correctly formats the inner lists and booleans.\n    print(f\"[[{results[0][0]},{results[0][1]},{str(results[0][2]).lower()}],[{results[1][0]},{results[1][1]},{str(results[1][2]).lower()}],[{results[2][0]},{results[2][1]},{str(results[2][2]).lower()}]]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "第一个实践侧重于解析微观特征，而本练习则将视角转向宏观材料性质。你将使用Lejaeghere $\\Delta$因子——一个材料科学领域的标准基准测试——来量化$E_{\\text{cut}}$的选择如何影响计算所得的状态方程。该实践展示了如何基于可物理测量的综合量（如平衡体积和体弹模量）来评估收敛性，而这通常是模拟的最终目标。",
            "id": "3440851",
            "problem": "您的任务是实现一个完全指定且自包含的 Lejaeghere $\\Delta$ 因子的数值基准测试，用以确定在仅改变能量截断值的情况下，对于多个赝势族和化学元素，达到目标精度所需的最小平面波能量截断值。您的实现必须从已被接受且经过充分检验的物理公式和定义出发，并通过严格的数值计算来执行。程序必须生成一个汇总所有测试案例的单行结果。\n\n请使用以下基本组成部分。\n\n1. 物态方程。使用能量作为体积函数的三阶 Birch–Murnaghan 物态方程，\n$$\nE(V) \\;=\\; E_0 \\;+\\; \\frac{9}{16}\\, B_0\\, V_0 \\left\\{ \\left[ \\left(\\frac{V_0}{V}\\right)^{2/3} - 1 \\right]^3 B_0' \\;+\\; \\left[ \\left(\\frac{V_0}{V}\\right)^{2/3} - 1 \\right]^2 \\left[ 6 - 4\\left(\\frac{V_0}{V}\\right)^{2/3} \\right] \\right\\}.\n$$\n此处，$E(V)$ 的单位是电子伏特/原子，$V$ 和 $V_0$ 的单位是 $\\text{\\AA}^3$/原子，$B_0$ 是体积模量，单位是 $\\text{eV}/\\text{\\AA}^3$，$B_0'$ 是无量纲的。对于所有情况，取 $E_0 = 0$ eV，因为此基准测试不需要绝对能量偏移。\n\n2. $\\Delta$ 因子定义。给定一个参考物态方程 $E_{\\mathrm{ref}}(V)$ 和一个测试物态方程 $E_{\\mathrm{test}}(V)$，将 Lejaeghere $\\Delta$ 因子定义为\n$$\n\\Delta \\;=\\; \\sqrt{ \\frac{1}{V_{\\max} - V_{\\min}} \\int_{V_{\\min}}^{V_{\\max}} \\left( E_{\\mathrm{ref}}(V) - E_{\\mathrm{test}}(V) \\right)^2 \\, dV }.\n$$\n使用 1000 meV 每 eV 的换算因子，将 $\\Delta$ 从电子伏特/原子转换为 $\\text{meV}$/原子的单位报告。在 $V_0$ 周围使用一个对称的积分窗口：\n$$\nV_{\\min} \\;=\\; 0.94\\, V_0^{\\mathrm{(ref)}}, \\quad V_{\\max} \\;=\\; 1.06\\, V_0^{\\mathrm{(ref)}},\n$$\n并使用数值上足够鲁棒的均匀采样。\n\n3. 参考材料。使用以下参考平衡参数，其中 $B_0$ 以吉帕斯卡 (GPa) 给出，必须使用换算因子 $1\\,\\text{eV}/\\text{\\AA}^3 = 160.21766208\\,\\text{GPa}$ 将其转换为 $\\text{eV}/\\text{\\AA}^3$：\n- 原子序数 $Z = 6$ 的元素 (碳)：$V_0^{\\mathrm{(ref)}} = 5.67\\,\\text{\\AA}^3$/原子, $B_0^{\\mathrm{(ref)}} = 443\\,\\text{GPa}$, ${B_0'}^{\\mathrm{(ref)}} = 4.0$。\n- 原子序数 $Z = 14$ 的元素 (硅)：$V_0^{\\mathrm{(ref)}} = 20.00\\,\\text{\\AA}^3$/原子, $B_0^{\\mathrm{(ref)}} = 99\\,\\text{GPa}$, ${B_0'}^{\\mathrm{(ref)}} = 4.0$。\n- 原子序数 $Z = 29$ 的元素 (铜)：$V_0^{\\mathrm{(ref)}} = 11.90\\,\\text{\\AA}^3$/原子, $B_0^{\\mathrm{(ref)}} = 137\\,\\text{GPa}$, ${B_0'}^{\\mathrm{(ref)}} = 4.0$。\n\n4. 建模平面波能量截断值的影响。定义一个合成的但科学上合理的模型，其中近似（测试）物态方程的参数依赖于平面波能量截断值 $E_{\\mathrm{cut}}$ (单位 eV)、元素的原子序数 $Z$ 和赝势族。设 $Z_0 = 10$ 和 $\\beta = 0.5$。对于一个给定的具有衰减指数 $p$ 和振幅 $a_{V_0}$、$a_{B_0}$、$a_{B_0'}$ 的赝势族，通过以下公式定义在能量截断值 $E_{\\mathrm{cut}}$ 下的测试参数：\n$$\nV_0^{\\mathrm{(test)}}(E_{\\mathrm{cut}}, Z) \\;=\\; V_0^{\\mathrm{(ref)}} \\left[ 1 \\;+\\; a_{V_0}\\,\\left(\\frac{Z}{Z_0}\\right)^{\\beta} \\, E_{\\mathrm{cut}}^{-p} \\right],\n$$\n$$\nB_0^{\\mathrm{(test)}}(E_{\\mathrm{cut}}, Z) \\;=\\; B_0^{\\mathrm{(ref)}} \\left[ 1 \\;+\\; a_{B_0}\\,\\left(\\frac{Z}{Z_0}\\right)^{\\beta} \\, E_{\\mathrm{cut}}^{-p} \\right],\n$$\n$$\n{B_0'}^{\\mathrm{(test)}}(E_{\\mathrm{cut}}, Z) \\;=\\; {B_0'}^{\\mathrm{(ref)}} \\left[ 1 \\;+\\; a_{B_0'}\\,\\left(\\frac{Z}{Z_0}\\right)^{\\beta} \\, E_{\\mathrm{cut}}^{-p} \\right].\n$$\n使用以下赝势族及其参数：\n- 族 “GBRV_USPP”：$p = 0.9$, $a_{V_0} = 0.5$, $a_{B_0} = 0.6$, $a_{B_0'} = 0.3$。\n- 族 “SG15_ONCV”：$p = 1.1$, $a_{V_0} = 0.35$, $a_{B_0} = 0.45$, $a_{B_0'} = 0.25$。\n- 族 “PSlibrary_PAW”：$p = 1.3$, $a_{V_0} = 0.25$, $a_{B_0} = 0.35$, $a_{B_0'} = 0.2$。\n\n5. 能量截断值扫描。对于每个测试案例，搜索以下离散的能量截断值集合（单位 eV）：\n$$\n\\{200,\\, 250,\\, 300,\\, 350,\\, 400,\\, 500,\\, 600,\\, 700,\\, 800\\}.\n$$\n\n6. 接受阈值。目标精度标准是 $\\Delta  1$ meV/原子。对于每个测试案例，报告网格中满足该标准的最小 $E_{\\mathrm{cut}}$。如果没有值满足该标准，则该案例返回 $-1$。\n\n需要实现的任务。\n\nA. 实现使用参考参数的 Birch–Murnaghan 物态方程计算 $E_{\\mathrm{ref}}(V)$，以及使用每个 $E_{\\mathrm{cut}}$ 下的测试参数和相同函数形式计算 $E_{\\mathrm{test}}(V)$。\n\nB. 通过在 $V \\in [0.94\\, V_0^{\\mathrm{(ref)}},\\, 1.06\\, V_0^{\\mathrm{(ref)}}]$ 上使用足够密集以确保结果稳定的均匀网格进行数值积分，来计算 $\\Delta$ 因子。将 $\\Delta$ 转换为 meV/原子。\n\nC. 对于每个测试案例，根据网格确定满足 $\\Delta  1$ meV/原子的最小 $E_{\\mathrm{cut}}$。如果没有，则返回 $-1$。\n\nD. 趋势分析。对于每个赝势族，计算在找到有效最小值的元素集合中，$Z$ 与最小 $E_{\\mathrm{cut}}$ 之间的 Pearson 相关系数。给定配对 $\\{(Z_i, E_i)\\}$，计算\n$$\nr \\;=\\; \\frac{\\sum_i (Z_i - \\bar{Z})(E_i - \\bar{E})}{\\sqrt{\\sum_i (Z_i - \\bar{Z})^2}\\; \\sqrt{\\sum_i (E_i - \\bar{E})^2}},\n$$\n其中 $\\bar{Z}$ 和 $\\bar{E}$ 是有效配对的样本均值。如果有效配对少于 2 个或任何分母为零，则定义 $r = 0.0$。\n\n测试套件与所需输出。\n\n- 使用项目 $3$ 中指定的元素和参考参数，$Z \\in \\{6, 14, 29\\}$。\n- 使用项目 $4$ 中指定的赝势族。\n- 定义包含 9 个测试案例的有序列表，顺序完全如下：\n  $[(Z{=}6,\\ \\mathrm{GBRV\\_USPP}),\\ (Z{=}6,\\ \\mathrm{SG15\\_ONCV}),\\ (Z{=}6,\\ \\mathrm{PSlibrary\\_PAW}),\\ (Z{=}14,\\ \\mathrm{GBRV\\_USPP}),\\ (Z{=}14,\\ \\mathrm{SG15\\_ONCV}),\\ (Z{=}14,\\ \\mathrm{PSlibrary\\_PAW}),\\ (Z{=}29,\\ \\mathrm{GBRV\\_USPP}),\\ (Z{=}29,\\ \\mathrm{SG15\\_ONCV}),\\ (Z{=}29,\\ \\mathrm{PSlibrary\\_PAW})]$。\n\n- 对于这 9 个案例中的每一个，程序必须输出最小 $E_{\\mathrm{cut}}$（单位 eV），为所提供网格中的一个整数，如果无法达到则为 $-1$。\n\n- 然后，追加 3 个浮点数值，对应于按 $[\\mathrm{GBRV\\_USPP},\\, \\mathrm{SG15\\_ONCV},\\, \\mathrm{PSlibrary\\_PAW}]$ 顺序为每个族计算的 Pearson 相关系数 $r$。\n\n最终输出格式。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔并用方括号括起来的结果列表（例如，$[r_1,r_2,\\dots]$）。该列表必须包含 12 个条目：前 9 个是按指定顺序排列的每个案例的最小 $E_{\\mathrm{cut}}$ 值，后面是按指定族顺序排列的 3 个相关系数。所有能量必须以 eV 为单位，$\\Delta$ 必须以 meV/原子为单位进行评估。不应打印其他任何文本。",
            "solution": "该问题要求实现一个数值基准测试，以确定在不同元素和赝势族中，为达到指定精度所需的最小平面波能量截断值 $E_{\\mathrm{cut}}$。该基准测试基于 Lejaeghere $\\Delta$ 因子，它量化了近似物态方程 (EOS) 与参考物态方程之间的差异。解决方案涉及一个结构化的、分步的计算过程。\n\n首先，我们建立基础物理模型。晶体固体的能量-体积关系由三阶 Birch–Murnaghan 物态方程描述，其表达式为：\n$$\nE(V) \\;=\\; E_0 \\;+\\; \\frac{9}{16}\\, B_0\\, V_0 \\left\\{ \\left[ \\left(\\frac{V_0}{V}\\right)^{2/3} - 1 \\right]^3 B_0' \\;+\\; \\left[ \\left(\\frac{V_0}{V}\\right)^{2/3} - 1 \\right]^2 \\left[ 6 - 4\\left(\\frac{V_0}{V}\\right)^{2/3} \\right] \\right\\}\n$$\n此处，$E(V)$ 是每个原子的能量，$V$ 是每个原子的体积，$V_0$ 是平衡体积，$B_0$ 是平衡态下的体积模量，而 $B_0'$ 是其压力导数。问题指定将参考能量 $E_0 = 0$ eV，因为只有能量差是相关的。体积模量 $B_0$ 以吉帕斯卡 (GPa) 给出，必须使用给定的换算因子 $1\\,\\text{eV}/\\text{\\AA}^3 = 160.21766208\\,\\text{GPa}$ 将其转换为 $\\text{eV}/\\text{\\AA}^3$。我们将实现一个函数，根据这些参数计算 $E(V)$。\n\n其次，我们对能量截断值的影响进行建模。问题提供了一个合成模型，用以描述测试计算的物态方程参数（$V_0^{\\mathrm{(test)}}$、$B_0^{\\mathrm{(test)}}$、${B_0'}^{\\mathrm{(test)}}$）如何依赖于能量截断值 $E_{\\mathrm{cut}}$、原子序数 $Z$ 以及赝势族的特性（$p$、$a_{V_0}$、$a_{B_0}$、$a_{B_0'}$）。该模型引入了相对于 $E_{\\mathrm{cut}}$ 的幂律衰减：\n$$\nV_0^{\\mathrm{(test)}}(E_{\\mathrm{cut}}, Z) \\;=\\; V_0^{\\mathrm{(ref)}} \\left[ 1 \\;+\\; a_{V_0}\\,\\left(\\frac{Z}{Z_0}\\right)^{\\beta} \\, E_{\\mathrm{cut}}^{-p} \\right]\n$$\n$$\nB_0^{\\mathrm{(test)}}(E_{\\mathrm{cut}}, Z) \\;=\\; B_0^{\\mathrm{(ref)}} \\left[ 1 \\;+\\; a_{B_0}\\,\\left(\\frac{Z}{Z_0}\\right)^{\\beta} \\, E_{\\mathrm{cut}}^{-p} \\right]\n$$\n$$\n{B_0'}^{\\mathrm{(test)}}(E_{\\mathrm{cut}}, Z) \\;=\\; {B_0'}^{\\mathrm{(ref)}} \\left[ 1 \\;+\\; a_{B_0'}\\,\\left(\\frac{Z}{Z_0}\\right)^{\\beta} \\, E_{\\mathrm{cut}}^{-p} \\right]\n$$\n常数 $Z_0 = 10$ 和 $\\beta = 0.5$ 将被使用。对于每个测试案例和指定网格中的每个 $E_{\\mathrm{cut}}$，将使用这些公式从给定的参考参数生成测试物态方程的参数。\n\n第三，我们使用 $\\Delta$ 因子来量化参考物态方程 $E_{\\mathrm{ref}}(V)$ 和测试物态方程 $E_{\\mathrm{test}}(V)$ 之间的一致性。该度量是在特定体积范围内计算的均方根差：\n$$\n\\Delta \\;=\\; \\sqrt{ \\frac{1}{V_{\\max} - V_{\\min}} \\int_{V_{\\min}}^{V_{\\max}} \\left( E_{\\mathrm{ref}}(V) - E_{\\mathrm{test}}(V) \\right)^2 \\, dV }\n$$\n积分在参考平衡体积周围的对称窗口上进行：$V_{\\min} = 0.94\\, V_0^{\\mathrm{(ref)}}$ 和 $V_{\\max} = 1.06\\, V_0^{\\mathrm{(ref)}}$。该积分将使用梯形法则在一个包含 1001 个点的精细均匀网格上进行数值计算。对于平滑的 Birch-Murnaghan 函数，此密度足以确保结果稳定且准确。得到的 $\\Delta$ 最初单位为 eV/原子，通过乘以 1000 转换为 meV/原子。\n\n第四，该算法的核心是一个搜索过程。对于 9 个测试案例（每个案例是元素和赝势族的组合）中的每一个，我们按升序遍历离散的能量截断值列表 $\\{200,\\, 250,\\, \\dots,\\, 800\\}$ eV。在每一步中，我们计算 $\\Delta$ 因子。第一个满足精度标准 $\\Delta  1$ meV/原子的 $E_{\\mathrm{cut}}$ 值被记录为该测试案例的结果。如果列表中的所有截断值都不满足标准，则结果记录为 $-1$。\n\n最后，对每个赝势族进行趋势分析。我们计算原子序数 $Z$ 与该元素找到的最小 $E_{\\mathrm{cut}}$ 之间的 Pearson 相关系数 $r$。此分析仅限于在该族内确定了有效最小截断值（即不为 $-1$）的元素。公式为：\n$$\nr \\;=\\; \\frac{\\sum_i (Z_i - \\bar{Z})(E_i - \\bar{E})}{\\sqrt{\\sum_i (Z_i - \\bar{Z})^2}\\; \\sqrt{\\sum_i (E_i - \\bar{E})^2}}\n$$\n其中，求和遍历有效的配对 $(Z_i, E_i)$，$\\bar{Z}$ 和 $\\bar{E}$ 分别是样本均值。根据规定，如果一个族少于 2 个有效数据点，或者任一变量的标准差为零，则相关系数定义为 $r = 0.0$。\n\n程序将执行这整个过程，收集 9 个最小截断值和 3 个相关系数，并按要求将它们打印在一个逗号分隔的列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a numerical benchmark of the Lejaeghere Delta-factor to determine\n    the minimum energy cutoff for a target accuracy across several materials\n    and pseudopotential families.\n    \"\"\"\n\n    # --- 1. Define Constants and Given Data ---\n\n    GPA_TO_EV_PER_A3 = 160.21766208\n    Z0 = 10.0\n    BETA = 0.5\n    E_CUT_GRID = [200, 250, 300, 350, 400, 500, 600, 700, 800]\n    DELTA_THRESHOLD_MEV = 1.0\n    NUM_INTEGRATION_POINTS = 1001\n\n    REF_MATERIALS = {\n        6: {\"Z\": 6, \"V0_ref\": 5.67, \"B0_ref_gpa\": 443, \"B0_prime_ref\": 4.0},\n        14: {\"Z\": 14, \"V0_ref\": 20.00, \"B0_ref_gpa\": 99, \"B0_prime_ref\": 4.0},\n        29: {\"Z\": 29, \"V0_ref\": 11.90, \"B0_ref_gpa\": 137, \"B0_prime_ref\": 4.0},\n    }\n\n    # Convert B0 to eV/A^3\n    for z in REF_MATERIALS:\n        REF_MATERIALS[z][\"B0_ref\"] = REF_MATERIALS[z][\"B0_ref_gpa\"] / GPA_TO_EV_PER_A3\n\n    PSEUDO_FAMILIES = {\n        \"GBRV_USPP\": {\"p\": 0.9, \"a_V0\": 0.5, \"a_B0\": 0.6, \"a_B0_prime\": 0.3},\n        \"SG15_ONCV\": {\"p\": 1.1, \"a_V0\": 0.35, \"a_B0\": 0.45, \"a_B0_prime\": 0.25},\n        \"PSlibrary_PAW\": {\"p\": 1.3, \"a_V0\": 0.25, \"a_B0\": 0.35, \"a_B0_prime\": 0.2},\n    }\n\n    TEST_CASES = [\n        (6, \"GBRV_USPP\"), (6, \"SG15_ONCV\"), (6, \"PSlibrary_PAW\"),\n        (14, \"GBRV_USPP\"), (14, \"SG15_ONCV\"), (14, \"PSlibrary_PAW\"),\n        (29, \"GBRV_USPP\"), (29, \"SG15_ONCV\"), (29, \"PSlibrary_PAW\"),\n    ]\n\n    # --- 2. Implement Physical and Mathematical Models ---\n\n    def birch_murnaghan_eos(V, V0, B0, B0_prime):\n        \"\"\"Calculates energy for a given volume using the Birch-Murnaghan EOS.\"\"\"\n        # E0 is taken as 0\n        x = (V0 / V)**(2.0/3.0)\n        term1 = ((x - 1.0)**3) * B0_prime\n        term2 = ((x - 1.0)**2) * (6.0 - 4.0 * x)\n        E = (9.0 / 16.0) * B0 * V0 * (term1 + term2)\n        return E\n\n    def get_test_params(E_cut, z, ref_params, family_params):\n        \"\"\"Calculates the test EOS parameters based on E_cut.\"\"\"\n        p = family_params[\"p\"]\n        a_V0 = family_params[\"a_V0\"]\n        a_B0 = family_params[\"a_B0\"]\n        a_B0_prime = family_params[\"a_B0_prime\"]\n\n        mod_factor = (z / Z0)**BETA * E_cut**(-p)\n\n        V0_test = ref_params[\"V0_ref\"] * (1.0 + a_V0 * mod_factor)\n        B0_test = ref_params[\"B0_ref\"] * (1.0 + a_B0 * mod_factor)\n        B0_prime_test = ref_params[\"B0_prime_ref\"] * (1.0 + a_B0_prime * mod_factor)\n\n        return V0_test, B0_test, B0_prime_test\n\n    def calculate_delta(ref_params, test_params):\n        \"\"\"Computes the Lejaeghere Delta-factor.\"\"\"\n        V0_ref, B0_ref, B0_prime_ref = ref_params[\"V0_ref\"], ref_params[\"B0_ref\"], ref_params[\"B0_prime_ref\"]\n        V0_test, B0_test, B0_prime_test = test_params\n\n        V_min = 0.94 * V0_ref\n        V_max = 1.06 * V0_ref\n        \n        V_grid = np.linspace(V_min, V_max, NUM_INTEGRATION_POINTS)\n\n        E_ref = birch_murnaghan_eos(V_grid, V0_ref, B0_ref, B0_prime_ref)\n        E_test = birch_murnaghan_eos(V_grid, V0_test, B0_test, B0_prime_test)\n        \n        integrand = (E_ref - E_test)**2\n        \n        integral_mean = np.trapz(integrand, V_grid) / (V_max - V_min)\n        \n        delta_ev = np.sqrt(integral_mean)\n        delta_mev = delta_ev * 1000.0\n        \n        return delta_mev\n\n    def calculate_pearson_correlation(data_pairs):\n        \"\"\"Computes the Pearson correlation coefficient for a list of (Z, E) pairs.\"\"\"\n        if len(data_pairs)  2:\n            return 0.0\n\n        z_vals, e_vals = zip(*data_pairs)\n        z_vals = np.array(z_vals)\n        e_vals = np.array(e_vals)\n\n        mean_z = np.mean(z_vals)\n        mean_e = np.mean(e_vals)\n\n        dev_z = z_vals - mean_z\n        dev_e = e_vals - mean_e\n\n        numerator = np.sum(dev_z * dev_e)\n        denominator_z_sq = np.sum(dev_z**2)\n        denominator_e_sq = np.sum(dev_e**2)\n\n        if denominator_z_sq == 0 or denominator_e_sq == 0:\n            return 0.0\n            \n        denominator = np.sqrt(denominator_z_sq * denominator_e_sq)\n        \n        return numerator / denominator\n\n    # --- 3. Execute the Benchmark ---\n\n    min_ecut_results = []\n    correlation_data = {family: [] for family in PSEUDO_FAMILIES}\n\n    for Z, family_name in TEST_CASES:\n        ref_params = REF_MATERIALS[Z]\n        family_params = PSEUDO_FAMILIES[family_name]\n        \n        found_ecut = -1\n        for E_cut in E_CUT_GRID:\n            test_params = get_test_params(E_cut, Z, ref_params, family_params)\n            delta = calculate_delta(ref_params, test_params)\n            \n            if delta  DELTA_THRESHOLD_MEV:\n                found_ecut = E_cut\n                break\n        \n        min_ecut_results.append(found_ecut)\n        \n        if found_ecut != -1:\n            correlation_data[family_name].append((Z, found_ecut))\n\n    # --- 4. Calculate Correlation and Finalize Results ---\n    \n    correlation_results = []\n    family_order = [\"GBRV_USPP\", \"SG15_ONCV\", \"PSlibrary_PAW\"]\n    for family_name in family_order:\n        data_pairs = correlation_data[family_name]\n        r = calculate_pearson_correlation(data_pairs)\n        correlation_results.append(r)\n        \n    final_results = min_ecut_results + correlation_results\n\n    # --- 5. Format and Print Output ---\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的计算需要在多个误差来源和计算成本之间进行权衡。这最后一个实践将你带入这一复杂的多目标优化场景，要求你同时考虑能量截断（$E_{\\text{cut}}$）和布里渊区采样（$k$点网格）。你将为总能量、力和应力构建一个误差预算，然后找出帕累托最优的 $(E_{\\text{cut}}, N_k)$ 参数对，以最小的计算代价达到所需的精度。本练习为你介绍了一个用于设计高效、稳健的高通量计算流程的强大框架。",
            "id": "3440829",
            "problem": "您的任务是设计并实现一个程序化流程，用于规范化计算材料科学中平面波计算的收敛性测试，重点关注能量截断选择和布里渊区采样密度。其目标是构建一个显式的误差预算，并计算出能量截断和倒易空间采样密度的帕累托最优对，这些最优对需要同时满足对总能量、原子力和应力张量分量的严格精度目标。\n\n请从以下基本原理出发，这些原理在该领域被广泛接受，并且必须用于算法设计的推理：\n\n- 在电子结构计算中，平面波基组在动能截断 $E_{cut}$ 处被截断，产生一个变分基组截断误差，该误差随 $E_{cut}$ 的增加而单调递减。在解是平滑的渐近区域，此误差可以很好地由一个形式为 $C \\, E_{cut}^{-p}$ 的衰减函数描述，其中 $C > 0$ 且 $p > 0$。\n\n- 布里渊区积分通过在有限的 $k$ 点集上采样来进行近似。对于足够光滑的被积函数和结构化网格，求积误差会随着 $k$ 点总数 $N_k$ 的增加而减小，其形式为一个衰减函数 $D \\, N_k^{-q}$，其中 $D > 0$ 且 $q > 0$。\n\n您可以假设每个所关心物理量的总误差可以表示为由能量截断控制的贡献和由 $k$ 点网格控制的贡献之和。对于此问题，您必须使用以下抽象误差模型，其中所有参数均为正数且与材料相关：\n$$\n\\Delta E(E_{cut}, N_k) = \\alpha_E \\, E_{cut}^{-p_E} + \\beta_E \\, N_k^{-q_E}, \\quad\n\\Delta F(E_{cut}, N_k) = \\alpha_F \\, E_{cut}^{-p_F} + \\beta_F \\, N_k^{-q_F}, \\quad\n\\Delta \\sigma(E_{cut}, N_k) = \\alpha_\\sigma \\, E_{cut}^{-p_\\sigma} + \\beta_\\sigma \\, N_k^{-q_\\sigma}.\n$$\n\n精度要求是严格的，并且必须同时满足：\n- 每个原子的总能量误差满足 $|\\Delta E| \\le 1$ meV/atom，这必须强制为 $|\\Delta E| \\le 0.001$ eV/atom。\n- 力误差大小满足 $|\\Delta F| \\le 0.01$ eV/$\\text{\\AA}$。\n- 应力误差满足 $|\\Delta \\sigma| \\le 0.1$ GPa。\n\n该程序必须在能量截断和 k 点网格密度的离散候选集上进行搜索，并返回在上述可行性约束下关于二维目标向量 $(E_{cut}, N_k)$ 的帕累托最优对集合。一个可行对 $(E_{cut}, N_k)$ 是帕累托最优的，如果不存在另一个可行对 $(E_{cut}', N_k')$ 使得 $E_{cut}' \\le E_{cut}$ 且 $N_k' \\le N_k$，并且至少有一个不等式是严格的。该定义体现了在满足所有精度目标的同时，最小化平面波动能截断和 k 点网格密度的目标。\n\n单位和离散化：\n\n- 能量截断必须以 $\\mathrm{eV}$ 表示。\n- k 点网格密度是总整数计数 $N_k$（无单位）。\n- 候选能量截断值为离散集合 $\\{300, 350, 400, 450, 500, 600, 700\\}$ $\\mathrm{eV}$。\n- 候选 k 点网格密度为离散集合 $\\{8, 12, 16, 20, 24, 32\\}$。\n\n测试套件：\n\n您必须为以下依赖于材料的参数集计算帕累托集，每个参数集由六元组 $(\\alpha_E, p_E, \\beta_E, q_E; \\alpha_F, p_F, \\beta_F, q_F; \\alpha_\\sigma, p_\\sigma, \\beta_\\sigma, q_\\sigma)$ 定义，所有单位均与误差阈值一致：\n\n- 案例 $1$（类金属，k 点收敛较慢）：\n  $\\alpha_E = 80$, $p_E = 2.0$, $\\beta_E = 0.03$, $q_E = 1.5$; \n  $\\alpha_F = 2.5$, $p_F = 1.5$, $\\beta_F = 0.12$, $q_F = 1.2$; \n  $\\alpha_\\sigma = 12$, $p_\\sigma = 1.2$, $\\beta_\\sigma = 1.2$, $q_\\sigma = 1.0$。\n\n- 案例 $2$（类绝缘体，k 点收敛快，对基组敏感）：\n  $\\alpha_E = 150$, $p_E = 2.2$, $\\beta_E = 0.01$, $q_E = 2.0$; \n  $\\alpha_F = 4.0$, $p_F = 1.8$, $\\beta_F = 0.05$, $q_F = 1.7$; \n  $\\alpha_\\sigma = 20$, $p_\\sigma = 1.5$, $\\beta_\\sigma = 0.8$, $q_\\sigma = 1.6$。\n\n- 案例 $3$（临界情况，需要高 $E_{cut}$ 和密集的 k 点网格）：\n  $\\alpha_E = 300$, $p_E = 2.4$, $\\beta_E = 0.05$, $q_E = 1.2$; \n  $\\alpha_F = 8.0$, $p_F = 1.6$, $\\beta_F = 0.2$, $q_F = 1.2$; \n  $\\alpha_\\sigma = 30$, $p_\\sigma = 1.3$, $\\beta_\\sigma = 2.2$, $q_\\sigma = 1.1$。\n\n- 案例 $4$（不可行的边界情况，在提供的网格中无解）：\n  $\\alpha_E = 400$, $p_E = 2.0$, $\\beta_E = 0.3$, $q_E = 1.0$; \n  $\\alpha_F = 10.0$, $p_F = 1.2$, $\\beta_F = 0.5$, $q_F = 1.1$; \n  $\\alpha_\\sigma = 50$, $p_\\sigma = 1.1$, $\\beta_\\sigma = 5.0$, $q_\\sigma = 0.9$。\n\n您的程序应：\n- 枚举指定离散集中的所有 $(E_{cut}, N_k)$ 对。\n- 对每个测试案例，使用给定参数和上述模型计算三种误差。\n- 识别同时满足所有三个约束的可行对。\n- 从可行集中，根据 $(E_{cut}, N_k)$ 上的二维偏序计算帕累托最优子集。\n- 对每个测试案例，按 $E_{cut}$ 然后按 $N_k$ 的升序字典序对帕累托最优对进行排序。\n\n最终输出格式：\n- 对于每个测试案例，返回编码为列表 $[E_{cut}, N_k]$ 的帕累托最优对列表，其中 $E_{cut}$ 的单位是 $\\mathrm{eV}$，$N_k$ 是一个整数。\n- 您的程序应生成单行输出，包含四个测试案例结果的逗号分隔列表，每个结果本身是一个 $[E_{cut}, N_k]$ 对的列表，不含空格，并用方括号括起来。例如：$[[[300,12],[350,8]],[[400,16]],[],[[700,32]]]$。",
            "solution": "所提出的问题要求设计一个计算流程，以确定平面波电子结构计算中两个关键参数的最优设置：动能截断 $E_{cut}$ 和布里渊区采样网格的密度（由 k 点总数 $N_k$ 表示）。其目标是找到能同时最小化这两个参数并满足对总能量、原子力和应力张量的一系列严格精度约束的参数对 $(E_{cut}, N_k)$。这是一个在离散搜索空间上的多目标优化问题。这些解对构成了帕累托最优前沿。\n\n该方法的基础在于所提供的唯象误差模型，这些模型描述了计算量作为 $E_{cut}$ 和 $N_k$ 函数的收敛行为。对于一个通用的关心物理量 $Q$（其中 $Q$ 可以是总能量 $E$、最大原子力大小 $F$ 或最大应力张量分量大小 $\\sigma$），总数值误差 $\\Delta Q$ 被假设为两个独立贡献之和：一个来自基组截断（$E_{cut}$），另一个来自布里渊区积分（$N_k$）。误差模型给定如下：\n$$\n\\Delta E(E_{cut}, N_k) = \\alpha_E \\, E_{cut}^{-p_E} + \\beta_E \\, N_k^{-q_E}\n$$\n$$\n\\Delta F(E_{cut}, N_k) = \\alpha_F \\, E_{cut}^{-p_F} + \\beta_F \\, N_k^{-q_F}\n$$\n$$\n\\Delta \\sigma(E_{cut}, N_k) = \\alpha_\\sigma \\, E_{cut}^{-p_\\sigma} + \\beta_\\sigma \\, N_k^{-q_\\sigma}\n$$\n对于每个物理量 $Q$ 的参数 $(\\alpha_Q, p_Q, \\beta_Q, q_Q)$ 均为正数，并依赖于被模拟的特定材料体系。\n\n必须同时满足的精度约束是：\n1.  总能量误差：$|\\Delta E| \\le \\tau_E$，其中 $\\tau_E = 0.001$ eV/atom。\n2.  力误差：$|\\Delta F| \\le \\tau_F$，其中 $\\tau_F = 0.01$ eV/Å。\n3.  应力误差：$|\\Delta \\sigma| \\le \\tau_\\sigma$，其中 $\\tau_\\sigma = 0.1$ GPa。\n\n对最优参数的搜索是在离散的候选值集合上进行的：\n-   $E_{cut} \\in \\mathcal{E}_{cut} = \\{300, 350, 400, 450, 500, 600, 700\\}$ eV。\n-   $N_k \\in \\mathcal{N}_k = \\{8, 12, 16, 20, 24, 32\\}$。\n完整的搜索空间是笛卡尔积 $\\mathcal{S} = \\mathcal{E}_{cut} \\times \\mathcal{N}_k$。\n\n对于每个给定的特定材料参数集，识别帕累托最优对 $(E_{cut}, N_k)$ 的算法流程被设计为两个主要阶段。\n\n**阶段 1：识别可行集**\n第一阶段涉及对搜索空间 $\\mathcal{S}$ 中所有可能的对 $(E_{cut}, N_k)$ 进行暴力枚举。对每一对，我们使用指定的误差模型和材料参数计算三个误差值 $\\Delta E$、$\\Delta F$ 和 $\\Delta \\sigma$。当且仅当一个参数对同时满足所有三个精度约束时，它被认为是*可行*的：\n$$\n(\\Delta E \\le \\tau_E) \\land (\\Delta F \\le \\tau_F) \\land (\\Delta \\sigma \\le \\tau_\\sigma)\n$$\n所有满足这些条件的对被收集到一个*可行集*中，记为 $\\mathcal{F}$。如果搜索空间 $\\mathcal{S}$ 中没有一对参数满足所有标准，则可行集 $\\mathcal{F}$ 为空。\n\n**阶段 2：确定帕累托最优前沿**\n第二阶段筛选可行集 $\\mathcal{F}$ 以找到帕累托最优子集。在这个二维最小化问题的背景下，如果一个可行对 $P_1 = (E_{cut,1}, N_{k,1})$ 满足 $E_{cut,1} \\le E_{cut,2}$ 和 $N_{k,1} \\le N_{k,2}$，且至少有一个不等式是严格的，那么它就*支配*另一个可行对 $P_2 = (E_{cut,2}, N_{k,2})$。帕累托最优集（或帕累托前沿）由所有不被任何其他可行对支配的可行对组成。这些代表了计算效率最高的选择，因为对 $E_{cut}$ 或 $N_k$ 的任何进一步降低都将需要增加另一个参数以保持可行性，或者将违反精度约束。\n\n一个找到此二维帕累托前沿的高效算法如下：\n1.  如果可行集 $\\mathcal{F}$ 为空，则帕累托集也为空。\n2.  否则，对 $\\mathcal{F}$ 中的参数对按字典序排序，首先按 $E_{cut}$ 升序，然后按 $N_k$ 升序。令此排序后的列表为 $F_{sorted}$。\n3.  为帕累托最优集 $\\mathcal{P}$ 初始化一个空列表，并初始化一个跟踪变量 `min_nk_seen` 为一个比任何可能的 $N_k$ 都大的值（例如，无穷大）。\n4.  遍历 $F_{sorted}$ 中的每一对 $(e, n)$。\n5.  对于每一对，将其 $N_k$ 值 $n$与 `min_nk_seen` 进行比较。\n    -   如果 $n  \\text{min\\_nk\\_seen}$，则该对 $(e, n)$ 不被任何已处理的点所支配。因为列表是按 $e$ 排序的，帕累托集中的任何先前点 $(e', n')$ 都具有 $e'  e$。由于我们还知道 $n  \\text{min\\_nk\\_seen} \\le n'$，因此先前的点不会支配当前点。所以，$(e, n)$ 是帕累托前沿上的一个新点。它被添加到 $\\mathcal{P}$ 中，并且 `min_nk_seen` 更新为 $n$。\n    -   如果 $n \\ge \\text{min\\_nk\\_seen}$，则当前对 $(e, n)$ 被一个先前识别的帕累托最优点 $(e', n')$ 所支配，其中 $e' \\le e$ 且 $n'  n$。因此，$(e, n)$ 被丢弃。\n\n该算法能正确且高效地（复杂度为 $O(|\\mathcal{F}|\\log|\\mathcal{F}|)$，主要由排序决定）识别帕累托最优集。最终的实现将此流程应用于提供的四个测试案例中的每一个，构建结果列表的无空格字符串表示形式作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Pareto-optimal (E_cut, N_k) pairs for plane-wave calculations\n    based on a given error model and convergence criteria.\n    \"\"\"\n    \n    # Define candidate sets for energy cutoff and k-mesh density\n    E_cut_candidates = [300, 350, 400, 450, 500, 600, 700]\n    Nk_candidates = [8, 12, 16, 20, 24, 32]\n\n    # Define error thresholds\n    tau_E = 0.001  # eV/atom\n    tau_F = 0.01   # eV/Angstrom\n    tau_sigma = 0.1  # GPa\n\n    # Define test cases. Each tuple contains 12 parameters in the order:\n    # (alpha_E, p_E, beta_E, q_E, \n    #  alpha_F, p_F, beta_F, q_F,\n    #  alpha_sigma, p_sigma, beta_sigma, q_sigma)\n    test_cases = [\n        # Case 1 (metal-like)\n        (80, 2.0, 0.03, 1.5, 2.5, 1.5, 0.12, 1.2, 12, 1.2, 1.2, 1.0),\n        # Case 2 (insulator-like)\n        (150, 2.2, 0.01, 2.0, 4.0, 1.8, 0.05, 1.7, 20, 1.5, 0.8, 1.6),\n        # Case 3 (borderline)\n        (300, 2.4, 0.05, 1.2, 8.0, 1.6, 0.2, 1.2, 30, 1.3, 2.2, 1.1),\n        # Case 4 (infeasible)\n        (400, 2.0, 0.3, 1.0, 10.0, 1.2, 0.5, 1.1, 50, 1.1, 5.0, 0.9),\n    ]\n\n    def calculate_error(E_cut, Nk, alpha, p, beta, q):\n        \"\"\"Calculates the error for a given quantity based on the model.\"\"\"\n        return alpha * E_cut**(-p) + beta * Nk**(-q)\n\n    all_results = []\n    for case_params in test_cases:\n        # Unpack parameters for readability\n        aE, pE, bE, qE, aF, pF, bF, qF, aS, pS, bS, qS = case_params\n        \n        # Step 1: Find all feasible (E_cut, Nk) pairs\n        feasible_pairs = []\n        for E_cut in E_cut_candidates:\n            for Nk in Nk_candidates:\n                error_E = calculate_error(E_cut, Nk, aE, pE, bE, qE)\n                error_F = calculate_error(E_cut, Nk, aF, pF, bF, qF)\n                error_sigma = calculate_error(E_cut, Nk, aS, pS, bS, qS)\n\n                if error_E = tau_E and error_F = tau_F and error_sigma = tau_sigma:\n                    feasible_pairs.append([E_cut, Nk])\n\n        # Step 2: Determine the Pareto-optimal front from the feasible set\n        if not feasible_pairs:\n            all_results.append([])\n            continue\n\n        # Sort pairs lexicographically: by E_cut, then by Nk\n        feasible_pairs.sort(key=lambda x: (x[0], x[1]))\n\n        pareto_optimal_set = []\n        min_nk_seen = float('inf')\n        for e_cut, nk in feasible_pairs:\n            if nk  min_nk_seen:\n                pareto_optimal_set.append([e_cut, nk])\n                min_nk_seen = nk\n        \n        all_results.append(pareto_optimal_set)\n\n    # Format the final output string to match the exact requirement (no spaces)\n    result_strings = [str(res).replace(\" \", \"\") for res in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}