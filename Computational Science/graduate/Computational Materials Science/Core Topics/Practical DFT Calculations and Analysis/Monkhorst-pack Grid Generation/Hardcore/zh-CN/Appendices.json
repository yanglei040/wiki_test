{
    "hands_on_practices": [
        {
            "introduction": "在进行任何布里渊区积分之前，我们必须首先根据晶体的实空间晶格矢量生成一组离散的采样点，即$k$点。本练习提供了在分数坐标中构建Monkhorst-Pack网格的基础实践。更重要的是，它解决了将这些点映射到第一布里渊区这一关键任务，确保我们的采样被限制在倒易空间原点周围的唯一且连续的区域内。",
            "id": "3467044",
            "problem": "您需要从第一性原理出发，推导并实现一个算法，该算法在晶体的倒易空间中构建一个均匀的采样点集，并将这些点映射到第一布里渊区（FBZ）。该算法必须生成能带结构计算中常用的三维网格的所有点，并确保这些点位于FBZ内。FBZ被定义为倒易晶格的Wigner–Seitz（WS）原胞。网格必须用相对于倒易基矢的分数坐标表示。\n\n使用的基本基矢和定义：\n\n- 设实空间原胞晶格基矢的三元组为矩阵 $\\mathbf{A} \\in \\mathbb{R}^{3 \\times 3}$ 的列向量，单位为埃（Angstrom）。倒易晶格原胞基矢定义为 $\\mathbf{B} = 2\\pi \\left( \\mathbf{A}^{-1} \\right)^{\\top}$，单位为逆埃（inverse Angstrom）。任何倒易晶格矢量都可以写成 $\\mathbf{G} = n_1 \\mathbf{b}_1 + n_2 \\mathbf{b}_2 + n_3 \\mathbf{b}_3 = \\mathbf{B}\\mathbf{n}$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$。\n\n- 倒易空间中的一个点 $\\mathbf{k}$ 可以用分数坐标 $\\mathbf{f} \\in \\mathbb{R}^3$ 参数化为 $\\mathbf{k} = \\mathbf{B}\\mathbf{f}$。\n\n- 第一布里渊区（FBZ）是倒易晶格的Wigner–Seitz（WS）原胞，它是指比其他任何倒易晶格点更靠近原点 $\\mathbf{0}$ 的点集 $\\mathbf{k}$。等价地，如果对于所有非零的 $\\mathbf{n} \\in \\mathbb{Z}^3$，都有 $\\|\\mathbf{k}\\| \\le \\|\\mathbf{k} - \\mathbf{B}\\mathbf{n}\\|$，则 $\\mathbf{k}$ 在FBZ内。\n\n您的目标：\n\n1. 从沿每个倒易基矢方向具有均匀采样密度且关于 $\\Gamma$ 点（原点）对称的要求出发，以分数坐标构建一个包含 $N_1 \\times N_2 \\times N_3$ 个点的三维网格，使得沿每个方向的 $N_i$ 个样本都是均匀分布且以原点为中心的。用 $\\mathbf{f}_{m_1,m_2,m_3}$ 表示分数坐标，其中索引 $m_i \\in \\{1,2,\\dots,N_i\\}$。\n\n2. 通过减去一个合适的倒易晶格矢量 $\\mathbf{G} = \\mathbf{B}\\mathbf{n}$，为每个 $\\mathbf{k} = \\mathbf{B}\\mathbf{f}$ 实现一个到FBZ的映射，其中选择 $\\mathbf{n} \\in \\mathbb{Z}^3$ 以最小化欧几里得范数 $\\|\\mathbf{B}(\\mathbf{f} + \\mathbf{n})\\|$。所有距离和范数都用逆埃表示。\n\n3. 为测试映射的鲁棒性，引入一个可选的均匀分数坐标偏移（或“平移”）$\\mathbf{s} \\in \\mathbb{R}^3$，使得用于构成 $\\mathbf{k}$ 的初始分数坐标在映射前为 $\\mathbf{f}_{m_1,m_2,m_3} + \\mathbf{s}$。映射必须将点带回到FBZ内。\n\n4. FBZ成员资格的验证标准必须使用WS定义：对于一个映射后的 $\\mathbf{k}$，验证对于 $\\mathbb{Z}^3$ 中原点的一个对称有界邻域内的所有非零整数矢量 $\\mathbf{n}$，都有 $\\|\\mathbf{k}\\| \\le \\|\\mathbf{k} - \\mathbf{B}\\mathbf{n}\\|$。使用一个足以判断您的测试套件生成的点的FBZ成员资格的有界邻域。\n\n单位和输出要求：\n\n- 所有实空间晶格输入 $\\mathbf{A}$ 的单位均为埃。所有倒易空间量（包括 $\\mathbf{k}$ 的范数）必须以逆埃计算和报告。\n\n- 角度单位不适用于此问题。\n\n- 您的程序必须生成一行输出，对每个测试用例，包含一个具有三个值的列表：\n    1. 一个整数，等于映射前在FBZ之外的点的数量，\n    2. 一个整数，等于映射后仍在FBZ之外的点的数量（如果映射正确，此值应为 $0$），\n    3. 一个浮点数，等于映射后各点中最大的欧几里得范数 $\\max \\|\\mathbf{k}\\|$，单位为逆埃，四舍五入到六位小数。\n  将所有测试用例的列表聚合到一个顶层的、用方括号括起来的逗号分隔列表中（例如，“[[a,b,c],[d,e,f],...]”）。\n\n测试套件：\n\n实现该算法并在以下四种情况下运行。在每种情况下，构建 $\\mathbf{B} = 2\\pi \\left( \\mathbf{A}^{-1} \\right)^{\\top}$ 并生成 $N_1 \\times N_2 \\times N_3$ 网格，应用平移 $\\mathbf{s}$，映射到FBZ，并报告所要求的三个值。\n\n- 案例1（理想情况，正交晶格）：\n  $\\mathbf{A} = \\begin{bmatrix} 1.0  0.0  0.0 \\\\ 0.0  1.0  0.0 \\\\ 0.0  0.0  1.0 \\end{bmatrix}$ 埃, $(N_1,N_2,N_3) = (2,2,2)$, $\\mathbf{s} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}$。\n\n- 案例2（正交晶格，有显著平移）：\n  $\\mathbf{A} = \\begin{bmatrix} 3.0  0.0  0.0 \\\\ 0.0  2.0  0.0 \\\\ 0.0  0.0  1.0 \\end{bmatrix}$ 埃, $(N_1,N_2,N_3) = (3,3,3)$, $\\mathbf{s} = \\begin{bmatrix} 0.6 \\\\ 0.2 \\\\ -0.4 \\end{bmatrix}$。\n\n- 案例3（斜晶格）：\n  $\\mathbf{A} = \\begin{bmatrix} 2.0  0.1  0.0 \\\\ 0.0  2.2  0.3 \\\\ 0.0  0.0  1.8 \\end{bmatrix}$ 埃, $(N_1,N_2,N_3) = (4,2,3)$, $\\mathbf{s} = \\begin{bmatrix} 0.3 \\\\ 0.3 \\\\ 0.3 \\end{bmatrix}$。\n\n- 案例4（类六角晶格，大平移和最小网格）：\n  $\\mathbf{A} = \\begin{bmatrix} 1.0  0.5  0.0 \\\\ 0.0  0.866  0.0 \\\\ 0.0  0.0  2.5 \\end{bmatrix}$ 埃, $(N_1,N_2,N_3) = (1,1,1)$, $\\mathbf{s} = \\begin{bmatrix} 1.2 \\\\ -1.2 \\\\ 0.8 \\end{bmatrix}$。\n\n您的程序应产生一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个如上所述的三元素列表。",
            "solution": "该问题要求推导并实现一个算法，用于生成倒易空间中的均匀采样点网格（称为Monkhorst-Pack网格），并将这些点映射到第一布里渊区（FBZ）。\n\n### 1. 倒易晶格与坐标系\n\n晶体结构由一组实空间原胞基矢定义，这些基矢作为矩阵 $\\mathbf{A}$ 的列向量给出。相应的倒易晶格原胞基矢构成了倒易空间的基，它们是矩阵 $\\mathbf{B}$ 的列向量，定义为：\n$$\n\\mathbf{B} = 2\\pi (\\mathbf{A}^{-1})^\\top\n$$\n倒易空间中的任何点 $\\mathbf{k}$ 都可以用笛卡尔坐标（单位为 $\\AA^{-1}$）或相对于基 $\\mathbf{B}$ 的分数坐标 $\\mathbf{f}$ 表示：\n$$\n\\mathbf{k} = \\mathbf{Bf} = f_1 \\mathbf{b}_1 + f_2 \\mathbf{b}_2 + f_3 \\mathbf{b}_3\n$$\n倒易晶格矢量 $\\mathbf{G}$ 对应于分数坐标为整数的点，即 $\\mathbf{G} = \\mathbf{B}\\mathbf{n}$，其中整数矢量 $\\mathbf{n} \\in \\mathbb{Z}^3$。\n\n### 2. Monkhorst-Pack 网格生成\n\n目标是在倒易空间中创建一个以原点（$\\Gamma$点）为中心的 $N_1 \\times N_2 \\times N_3$ 均匀网格。这通过在分数坐标空间中生成一个均匀网格来实现。为确保网格关于原点对称，沿每个方向 $i$ 的分数坐标 $f_i$ 选择如下：\n$$\nf_i = \\frac{m_i - \\frac{N_i+1}{2}}{N_i} \\quad \\text{for } m_i = 1, 2, \\dots, N_i\n$$\n对于奇数 $N_i$，这个序列包含 $0$；对于偶数 $N_i$，它关于 $0$ 对称。例如，对于 $N_i=3$，分数坐标为 $\\{-\\frac{1}{3}, 0, \\frac{1}{3}\\}$；对于 $N_i=4$，它们是 $\\{-\\frac{3}{8}, -\\frac{1}{8}, \\frac{1}{8}, \\frac{3}{8}\\}$。所有生成的坐标都位于区间 $(-0.5, 0.5)$ 内。\n\n问题指定了一个额外的均匀平移 $\\mathbf{s}$ 应用于网格。因此，最终的未映射分数坐标集 $\\mathbf{f'}$ 为：\n$$\n\\mathbf{f'}_{m_1,m_2,m_3} = \\mathbf{f}_{m1,m2,m3} + \\mathbf{s}\n$$\n初始的k点集则由 $\\mathbf{k}_{init} = \\mathbf{Bf'}$ 给出。这些点不保证位于第一布里渊区内。\n\n### 3. 映射到第一布里渊区\n\n第一布里渊区（FBZ）是倒易晶格以原点为中心的Wigner-Seitz原胞。它被定义为所有比任何其他倒易晶格点 $\\mathbf{G} = \\mathbf{B}\\mathbf{n}$ ($\\mathbf{n} \\neq \\mathbf{0}$) 更靠近原点（$\\mathbf{G} = \\mathbf{0}$）的点 $\\mathbf{k}$ 的集合：\n$$\n\\text{FBZ} = \\{ \\mathbf{k} \\in \\mathbb{R}^3 \\mid \\|\\mathbf{k}\\| \\le \\|\\mathbf{k} - \\mathbf{B}\\mathbf{n}\\| \\quad \\forall \\mathbf{n} \\in \\mathbb{Z}^3, \\mathbf{n} \\neq \\mathbf{0} \\}\n$$\n为了将任意点 $\\mathbf{k}_{init}$ 映射到FBZ，我们必须减去最接近 $\\mathbf{k}_{init}$ 的特定倒易晶格矢量 $\\mathbf{G}^* = \\mathbf{B}\\mathbf{n}^*$。映射后的点 $\\mathbf{k}_{mapped} = \\mathbf{k}_{init} - \\mathbf{G}^*$ 将比任何其他倒易晶格点更靠近原点，从而满足FBZ的定义。\n\n这个任务等价于为每个 $\\mathbf{k}_{init}$ 解决最近向量问题（CVP）：找到一个整数矢量 $\\mathbf{n}^* \\in \\mathbb{Z}^3$，使得欧几里得距离 $\\|\\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n}\\|$ 最小化。\n$$\n\\mathbf{n}^* = \\arg\\min_{\\mathbf{n} \\in \\mathbb{Z}^3} \\|\\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n}\\|^2\n$$\n虽然CVP在一般情况下是NP难问题，但对于像 $\\mathbb{R}^3$ 这样的低维空间，我们可以使用基于搜索的方法有效解决它。一个鲁棒的策略是首先找到 $\\mathbf{n}$ 的一个良好初始猜测，然后在其局部邻域内搜索。\n$\\mathbf{k}_{init}$ 的分数坐标提供了一个很好的猜测。我们首先计算 $\\mathbf{f'} = \\mathbf{B}^{-1}\\mathbf{k}_{init}$，其中 $\\mathbf{B}^{-1} = \\frac{1}{2\\pi}\\mathbf{A}^\\top$。分数空间中最接近的整数矢量就是 $\\mathbf{n}_{guess} = \\text{round}(\\mathbf{f'})$。这对应于CVP的Babai舍入算法。\n\n为了改进这一点，我们在以 $\\mathbf{n}_{guess}$ 为中心的一个小整数立方体内对 $\\mathbf{n}^*$ 进行暴力搜索。我们搜索所有候选矢量 $\\mathbf{n} = \\mathbf{n}_{guess} + \\Delta\\mathbf{n}$，其中 $\\Delta\\mathbf{n}$ 是分量较小的整数矢量（例如，$\\Delta n_i \\in \\{-1, 0, 1\\}$）。这将检查 $3^3=27$ 个 $\\mathbf{n}$ 的候选，并保证能找到解，如果解位于这个局部邻域内的话，这对于典型的物理系统来说是一个非常安全的假设。\n\n映射一个点 $\\mathbf{k}_{init}$ 的算法是：\n1.  计算分数坐标 $\\mathbf{f'} = \\mathbf{B}^{-1}\\mathbf{k}_{init}$。\n2.  确定初始猜测的整数矢量 $\\mathbf{n}_{guess} = \\text{round}(\\mathbf{f'})$。\n3.  在以 $\\mathbf{n}_{guess}$ 为中心的 $3 \\times 3 \\times 3$ 立方体内搜索所有整数矢量 $\\mathbf{n}$。对于每个候选 $\\mathbf{n}$，计算距离的平方 $d^2 = \\|\\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n}\\|^2$。\n4.  找出产生最小 $d^2$ 的矢量 $\\mathbf{n}^*$。\n5.  最终映射的点是 $\\mathbf{k}_{mapped} = \\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n}^*$。\n\n### 4. FBZ 成员资格验证\n\n要验证一个点 $\\mathbf{k}$ 是否在FBZ中，我们直接应用定义。我们必须检查对于一个足够大的原点邻域内的所有非零整数矢量 $\\mathbf{n}$，是否都有 $\\|\\mathbf{k}\\|^2 \\le \\|\\mathbf{k} - \\mathbf{B}\\mathbf{n}\\|^2$。对于这些测试用例，一个 $n_i \\in \\{-1, 0, 1\\}$ 的搜索框（26个非零矢量）是足够的。使用一个小的数值容差 $\\epsilon$ 来处理浮点数比较，即我们检查 $\\|\\mathbf{k}\\|^2 > \\|\\mathbf{k} - \\mathbf{B}\\mathbf{n}\\|^2 + \\epsilon$ 来判断一个点是否在FBZ之外。\n\n### 5. 步骤总结\n对于每个测试用例，整个算法流程如下：\n1.  给定 $\\mathbf{A}$，计算 $\\mathbf{B} = 2\\pi (\\mathbf{A}^{-1})^\\top$ 和 $\\mathbf{B}^{-1} = \\frac{1}{2\\pi} \\mathbf{A}^\\top$。\n2.  生成基础的Monkhorst-Pack分数坐标网格 $\\mathbf{f}$。\n3.  应用平移 $\\mathbf{s}$ 得到初始坐标 $\\mathbf{f'} = \\mathbf{f} + \\mathbf{s}$。\n4.  对于每个 $\\mathbf{f'}$，计算初始k点 $\\mathbf{k}_{init} = \\mathbf{Bf'}$。\n5.  使用验证程序计算初始时在FBZ之外的点的数量。\n6.  使用基于CVP的搜索算法将每个 $\\mathbf{k}_{init}$ 映射到其在FBZ中的等效点 $\\mathbf{k}_{mapped}$。\n7.  计算映射后仍在FBZ之外的点的数量（此值应为零）。\n8.  确定所有 $\\mathbf{k}_{mapped}$ 点中的最大欧几里得范数。\n9.  报告这三个计算出的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements an algorithm for Monkhorst-Pack grid generation\n    and mapping to the First Brillouin Zone for a series of test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"A\": np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]),\n            \"N\": (2, 2, 2),\n            \"s\": np.array([0.0, 0.0, 0.0])\n        },\n        {\n            \"A\": np.array([[3.0, 0.0, 0.0], [0.0, 2.0, 0.0], [0.0, 0.0, 1.0]]),\n            \"N\": (3, 3, 3),\n            \"s\": np.array([0.6, 0.2, -0.4])\n        },\n        {\n            \"A\": np.array([[2.0, 0.1, 0.0], [0.0, 2.2, 0.3], [0.0, 0.0, 1.8]]),\n            \"N\": (4, 2, 3),\n            \"s\": np.array([0.3, 0.3, 0.3])\n        },\n        {\n            \"A\": np.array([[1.0, 0.5, 0.0], [0.0, 0.866, 0.0], [0.0, 0.0, 2.5]]),\n            \"N\": (1, 1, 1),\n            \"s\": np.array([1.2, -1.2, 0.8])\n        }\n    ]\n\n    results = []\n    \n    # Define the search box for integer vectors n for FBZ verification.\n    # A 3x3x3 cube around the origin is sufficient for these test cases.\n    verify_n_coords = [-1, 0, 1]\n    verify_n_vectors = []\n    for i in verify_n_coords:\n        for j in verify_n_coords:\n            for k in verify_n_coords:\n                if i == 0 and j == 0 and k == 0:\n                    continue\n                verify_n_vectors.append(np.array([i, j, k]))\n\n    def is_in_fbz(k_vec, B_mat, n_vectors, tol=1e-12):\n        \"\"\"\n        Verifies if a k-point is inside the First Brillouin Zone.\n        A point k is in the FBZ if ||k|| = ||k - G|| for all G = B@n.\n        \"\"\"\n        k_norm_sq = np.dot(k_vec, k_vec)\n        for n in n_vectors:\n            G = B_mat @ n\n            k_shifted_norm_sq = np.dot(k_vec - G, k_vec - G)\n            if k_norm_sq > k_shifted_norm_sq + tol:\n                return False\n        return True\n\n    def map_to_fbz(k_vec, B_mat, B_inv_mat):\n        \"\"\"\n        Maps a k-point into the First Brillouin Zone by solving the\n        Closest Vector Problem over a local search grid.\n        \"\"\"\n        # Get fractional coordinates to find a good guess for integer vector n\n        f_prime = B_inv_mat @ k_vec\n        n_guess = np.round(f_prime)\n        \n        min_dist_sq = np.inf\n        best_n = np.zeros(3)\n\n        # Search in a 3x3x3 cube around the initial guess n_guess\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                for l in range(-1, 2):\n                    n_cand = n_guess + np.array([i, j, l])\n                    G_cand = B_mat @ n_cand\n                    dist_sq = np.dot(k_vec-G_cand, k_vec-G_cand)\n                    if dist_sq  min_dist_sq:\n                        min_dist_sq = dist_sq\n                        best_n = n_cand\n        \n        G_final = B_mat @ best_n\n        return k_vec - G_final\n\n    for case in test_cases:\n        A = case[\"A\"]\n        N = case[\"N\"]\n        s = case[\"s\"]\n        \n        B = 2 * np.pi * np.linalg.inv(A).T\n        B_inv = (1 / (2 * np.pi)) * A.T\n\n        # Generate Monkhorst-Pack grid points\n        N1, N2, N3 = N\n        m1_vals = np.arange(1, N1 + 1)\n        m2_vals = np.arange(1, N2 + 1)\n        m3_vals = np.arange(1, N3 + 1)\n\n        f1 = (m1_vals - (N1 + 1) / 2) / N1\n        f2 = (m2_vals - (N2 + 1) / 2) / N2\n        f3 = (m3_vals - (N3 + 1) / 2) / N3\n        \n        initial_k_points = []\n        for i in range(N1):\n            for j in range(N2):\n                for k in range(N3):\n                    f = np.array([f1[i], f2[j], f3[k]])\n                    f_shifted = f + s\n                    k_point = B @ f_shifted\n                    initial_k_points.append(k_point)\n\n        outside_before = 0\n        outside_after = 0\n        max_norm_after = 0.0\n\n        for k_init in initial_k_points:\n            if not is_in_fbz(k_init, B, verify_n_vectors):\n                outside_before += 1\n            \n            k_mapped = map_to_fbz(k_init, B, B_inv)\n            \n            if not is_in_fbz(k_mapped, B, verify_n_vectors):\n                outside_after += 1\n            \n            norm_val = np.linalg.norm(k_mapped)\n            if norm_val > max_norm_after:\n                max_norm_after = norm_val\n\n        results.append([outside_before, outside_after, round(max_norm_after, 6)])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "对于对称晶体而言，对整个布里渊区进行暴力积分在计算上是极其浪费的。本练习探讨了如何利用晶体对称性来显著减少计算所需的$k$点数量。您将开发一种算法，将完整的$k$点网格划分为对称等价的轨道，并识别出一个最小的不可约$k$点集合，每个$k$点都带有相应的权重，这是高效电子结构计算的基石。",
            "id": "3467067",
            "problem": "给定一个周期性倒易晶格，其倒易晶格基矢定义了倒易空间中的分数坐标。一个分数坐标 $\\mathbf{k}$ 代表一个波矢，其等价关系为加上整数值的倒易晶格矢量，即 $\\mathbf{k} \\sim \\mathbf{k} + \\mathbf{G}$，其中 $\\mathbf{G} \\in \\mathbb{Z}^3$ 是任意整数矢量。考虑一组点操作 $\\{ \\mathbf{R} \\}$，它们通过 $\\mathbf{k} \\mapsto \\mathbf{R}\\mathbf{k}$ 作用于分数坐标。假设每个 $\\mathbf{R}$ 都是一个行列式为 $\\det(\\mathbf{R}) = \\pm 1$ 的整数值 $3 \\times 3$ 矩阵，其作用保持倒易晶格不变，并且集合 $\\{ \\mathbf{R} \\}$ 在复合运算下是封闭的且包含单位操作。这些操作代表了空间群的点群部分；它们在分数坐标上的作用被认为是模去倒易晶格平移，即在应用 $\\mathbf{R}$ 之后，通过 $\\mathbf{k}' \\mapsto \\mathbf{k}' + \\mathbf{G}$（其中 $\\mathbf{G}$ 是某个整数矢量）将得到的 $\\mathbf{k}'$ 还原到一个典范原胞中，以使其进入一个选定的代表性区域，例如典范超立方体 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$。\n\n您的任务是设计并实现一个程序，在给定以下条件的情况下：\n- 一个由整数 $\\mathbf{N} = (N_1, N_2, N_3)$ 指定的均匀 Monkhorst–Pack (MP) 采样网格，\n- 一组在分数倒易坐标系下的封闭点操作 $\\{ \\mathbf{R} \\}$，\n\n构建不可约采样点集（相对于 $\\{ \\mathbf{R} \\}$ 的不可约布里渊区 (IBZ)），并为每个不可约代表点 $\\mathbf{k}_\\alpha$ 计算权重 $w_\\alpha$，使得每个对称等价类对总网格点数的贡献是成比例的。\n\n从基本定义和经过充分检验的事实开始：\n- 对于一个在所有点操作下保持不变的函数 $f(\\mathbf{k})$（即对所有 $\\mathbf{R} \\in \\{ \\mathbf{R} \\}$ 都有 $f(\\mathbf{R}\\mathbf{k}) = f(\\mathbf{k})$），其在布里渊区上的积分可以用离散网格上的均匀求和来近似。当正确计算了简并度后，将求和简化为对称不等价点是有效的。\n- 一个点 $\\mathbf{k}$ 在 $\\{ \\mathbf{R} \\}$ 作用下的等价类（轨道）是集合 $\\mathcal{O}(\\mathbf{k}) = \\left\\{ \\mathrm{wrap}\\!\\left(\\mathbf{R}\\mathbf{k}\\right) \\mid \\mathbf{R} \\in \\{ \\mathbf{R} \\} \\right\\}$，其中 $\\mathrm{wrap}(\\cdot)$ 通过加上一个适当的整数矢量将分数坐标映射回典范原胞。网格中位于同一轨道上的不同点是对称等价的。\n\n对您的程序的要求：\n- 生成一个关于原点对称的 Monkhorst–Pack 网格，并在每个倒易方向上用 $N_i$ 个点进行均匀采样。该构造必须遵守周期性，即相差整数矢量的点在模去倒易晶格的意义下是等同的。除了关于原点对称和 Monkhorst–Pack 网格标准的均匀间距要求外，不要假设任何特定的中心化。\n- 在给定的 $\\{ \\mathbf{R} \\}$ 作用下，将整个网格划分为不相交的对称轨道。对于每个轨道 $\\alpha$，选择一个典范代表点 $\\mathbf{k}_\\alpha$（例如，在 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$ 中字典序最小的分数坐标），并赋予一个权重 $w_\\alpha = \\dfrac{|\\mathcal{O}(\\mathbf{k}_\\alpha)|}{N_1 N_2 N_3}$，其中 $|\\cdot|$ 表示轨道的大小。这种选择确保了总权重之和为 1，即 $\\sum_\\alpha w_\\alpha = 1$。\n- 使用数值上稳健的方法将点折叠到 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$ 区域，并使用一个容差来识别由对称操作映射的网格点。\n\n您的程序必须实现上述功能，并为每个测试用例生成以下结果元组：\n- 不可约点的整数数量 $M$。\n- 所有权重的浮点数总和 $S$。\n- 所有不可约点中的浮点数最小权重 $\\min w_\\alpha$。\n- 所有不可约点中的浮点数最大权重 $\\max w_\\alpha$。\n- 一个布尔值 $b$，指示 $|S - 1|$ 是否小于一个小的容差（例如，$10^{-12}$）。\n\n测试套件：\n- 用例 A (一般的“理想路径”)：$\\mathbf{N} = (N_1, N_2, N_3) = (4, 4, 4)$，点操作为绕 $z$ 轴的四重循环旋转，\n  $$\\mathbf{R}_0 = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{90} = \\begin{pmatrix} 0  -1  0 \\\\ 1  0  0 \\\\ 0  0  1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{180} = \\begin{pmatrix} -1  0  0 \\\\ 0  -1  0 \\\\ 0  0  1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{270} = \\begin{pmatrix} 0  1  0 \\\\ -1  0  0 \\\\ 0  0  1 \\end{pmatrix}。$$\n- 用例 B (边界条件，无对称性约化)：$\\mathbf{N} = (N_1, N_2, N_3) = (3, 3, 3)$，仅有单位操作，\n  $$\\mathbf{R}_0 = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}。$$\n- 用例 C (边缘情况，有反演配对)：$\\mathbf{N} = (N_1, N_2, N_3) = (2, 2, 2)$，具有反演对称性，\n  $$\\mathbf{R}_0 = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{\\mathrm{inv}} = \\begin{pmatrix} -1  0  0 \\\\ 0  -1  0 \\\\ 0  0  -1 \\end{pmatrix}。$$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，每个测试用例贡献一个格式为 $[M,S,\\min w_\\alpha,\\max w_\\alpha,b]$ 的列表。因此，整体输出必须类似于\n  $$ \\big[ [M_A,S_A,\\min w_A,\\max w_A,b_A], [M_B,S_B,\\min w_B,\\max w_B,b_B], [M_C,S_C,\\min w_C,\\max w_C,b_C] \\big], $$\n  所有数字都以普通十进制数打印，布尔值以普通逻辑值打印。此问题不涉及任何物理单位或角度单位；所有量均为无量纲的实数或整数。",
            "solution": "所提出的问题是，在给定一组点对称操作的情况下，开发一个程序，将布里渊区的均匀 Monkhorst-Pack (MP) k点采样网格约化为其不可约集。我们还必须为每个不可约k点计算相应的权重。这项任务是现代电子结构计算的基石，因为它通过利用晶体对称性极大地降低了计算成本。该问题是良定的、科学上合理的，并为唯一的算法解提供了足够的信息。\n\n我们首先建立基本定义和原理。\n\n倒易空间中的一个点 $\\mathbf{k}$ 由相对于倒易晶格基矢的分数坐标表示。周期性意味着，如果任意两点 $\\mathbf{k}$ 和 $\\mathbf{k}'$ 相差一个整数矢量 $\\mathbf{G} \\in \\mathbb{Z}^3$（即 $\\mathbf{k}' = \\mathbf{k} + \\mathbf{G}$），则它们被认为是等价的。为了使用唯一的表示，我们将所有k点映射到一个典范原胞中，此处选择为超立方体 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$。这个映射表示为 $\\mathrm{wrap}(\\mathbf{k})$，通过操作 $\\mathbf{k} \\mapsto \\mathbf{k} - \\lfloor \\mathbf{k} + \\tfrac{1}{2} \\rfloor$ 实现，其中操作是逐分量执行的。\n\nMonkhorst-Pack (MP) 网格是对倒易空间的均匀采样。对于由整数 $\\mathbf{N} = (N_1, N_2, N_3)$ 指定的网格，总共生成 $N_{tot} = N_1 N_2 N_3$ 个点。为确保网格关于原点（$\\Gamma$点）对称，我们构造网格点 $\\mathbf{k}=(k_1, k_2, k_3)$，其中每个分量 $k_j$ 由下式给出：\n$$k_j = \\frac{2i_j - N_j - 1}{2N_j} \\quad \\text{for } i_j = 1, 2, \\dots, N_j$$\n这种构造方法生成的k点集在反演操作 $\\mathbf{k} \\mapsto -\\mathbf{k}$（模去倒易晶格矢量）下保持不变。\n\n晶体的点群由一组对称操作 $\\{ \\mathbf{R} \\}$ 给出，这些操作是行列式为 $\\det(\\mathbf{R}) = \\pm 1$ 的 $3 \\times 3$ 整数矩阵。一个操作 $\\mathbf{R}$ 对k点 $\\mathbf{k}$ 的作用是一个线性变换 $\\mathbf{k}' = \\mathbf{R}\\mathbf{k}$，然后将结果折叠回典范原胞中。\n\n如果存在一个操作 $\\mathbf{R} \\in \\{ \\mathbf{R} \\}$ 使得 $\\mathrm{wrap}(\\mathbf{R}\\mathbf{k}_a) = \\mathbf{k}_b$，那么两个k点 $\\mathbf{k}_a$ 和 $\\mathbf{k}_b$ 是对称等价的。与给定点 $\\mathbf{k}$ 等价的所有点的集合构成其轨道，即 $\\mathcal{O}(\\mathbf{k}) = \\{ \\mathrm{wrap}(\\mathbf{R}\\mathbf{k}) \\mid \\mathbf{R} \\in \\{ \\mathbf{R} \\} \\}$。这些轨道的基本性质是它们将整个k点网格划分为不相交的集合。\n\n目标是为每个轨道找到一个代表k点。这组代表点构成了给定网格和对称性下的不可约布里渊区（IBZ）k点集。代表点的选择必须是典范的，以确保唯一性。一个标准的选择是每个轨道内字典序最小的k点。\n\n一个不可约k点 $\\mathbf{k}_\\alpha$ 的权重 $w_\\alpha$ 定义为其轨道大小 $|\\mathcal{O}(\\mathbf{k}_\\alpha)|$ 与完整网格中k点总数 $N_{tot}$ 的比率：\n$$w_\\alpha = \\frac{|\\mathcal{O}(\\mathbf{k}_\\alpha)|}{N_1 N_2 N_3}$$\n根据构造，所有不相交轨道的总大小等于网格点的总数，即 $\\sum_\\alpha |\\mathcal{O}(\\mathbf{k}_\\alpha)| = N_{tot}$。因此，所有权重的总和必须等于 1：\n$$\\sum_\\alpha w_\\alpha = \\sum_\\alpha \\frac{|\\mathcal{O}(\\mathbf{k}_\\alpha)|}{N_{tot}} = \\frac{1}{N_{tot}} \\sum_\\alpha |\\mathcal{O}(\\mathbf{k}_\\alpha)| = \\frac{N_{tot}}{N_{tot}} = 1$$\n\n实现此程序的算法如下：\n1.  **网格生成**: 给定 $\\mathbf{N}=(N_1, N_2, N_3)$，使用上述原点对称的构造方法生成包含 $N_{tot}$ 个k点的完整网格。\n2.  **划分**: 遍历完整网格中的每个k点 $\\mathbf{k}_i$。为避免冗余计算，维护一个 `visited_points` 集合。\n    a. 如果 $\\mathbf{k}_i$ 已在 `visited_points` 中，则跳过它，因为它属于一个已经处理过的轨道。\n    b. 如果 $\\mathbf{k}_i$ 尚未被访问，则它是待发现的新轨道的第一个成员。\n3.  **轨道构建**: 对于新的点 $\\mathbf{k}_i$，通过应用每一个对称操作 $\\mathbf{R} \\in \\{ \\mathbf{R} \\}$ 来计算其完整轨道：\n    a. 计算 $\\mathbf{k}' = \\mathrm{wrap}(\\mathbf{R}\\mathbf{k}_i)$。\n    b. 将得到的唯一k点 $\\mathbf{k}'$ 添加到一个代表当前轨道的临时集合中。此处的数值容差至关重要；如果浮点k矢量的逐分量差异小于一个阈值（例如 $10^{-8}$），则它们被认为是相同的。对四舍五入后的坐标元组进行哈希是管理唯一性的有效技术。\n4.  **不可约点和权重**:\n    a. 轨道的大小 $|\\mathcal{O}(\\mathbf{k}_i)|$ 是上一步中找到的唯一k点的数量。\n    b. 权重计算为 $w_i = |\\mathcal{O}(\\mathbf{k}_i)| / N_{tot}$。\n    c. 该轨道的典范代表点被选为轨道中所有点里字典序最小的矢量。\n    d. 存储典范代表点及其权重。\n5.  **更新已访问集合**: 将新计算出的轨道中的所有点添加到 `visited_points` 集合中。\n6.  **重复**: 继续此过程，直到完整网格中的所有点都已被访问。\n7.  **最终结果**: 迭代完成后，典范代表点的列表即为不可约k点集。根据权重列表，计算不可约点的总数 $M$、权重总和 $S$、最小权重 $\\min w_\\alpha$ 和最大权重 $\\max w_\\alpha$。验证 $|S - 1|$ 是否低于一个数值容差。\n\n该算法系统地划分了完整网格，并正确地识别出不可约集及其权重，遵循了应用于晶格的群论原理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def wrap_to_canonical_cell(k_vector):\n        \"\"\"\n        Wraps a fractional coordinate vector into the canonical cell [-0.5, 0.5).\n        This is equivalent to k -> k - floor(k + 0.5).\n        \"\"\"\n        return k_vector - np.floor(k_vector + 0.5)\n\n    def get_k_point_hash(k_vector, precision=8):\n        \"\"\"\n        Creates a hashable representation of a k-vector by rounding to a\n        fixed precision to handle floating point inaccuracies.\n        \"\"\"\n        return tuple(np.round(k_vector, precision))\n\n    def generate_mp_grid(n_dims):\n        \"\"\"\n        Generates a Gamma-centered (origin-symmetric) Monkhorst-Pack grid.\n        Args:\n            n_dims (tuple): A tuple (N1, N2, N3) of grid dimensions.\n        Returns:\n            np.ndarray: A (N1*N2*N3, 3) array of k-point coordinates.\n        \"\"\"\n        k_coords = []\n        for n in n_dims:\n            # Formula for Gamma-centered grid: (2*i - N - 1) / (2*N) for i=1..N\n            k_coords.append((2 * np.arange(1, n + 1) - n - 1) / (2 * n))\n        \n        # Use meshgrid with 'ij' indexing to get Cartesian product in a standard order\n        kx, ky, kz = np.meshgrid(k_coords[0], k_coords[1], k_coords[2], indexing='ij')\n        \n        # Stack and reshape to get a list of (kx, ky, kz) vectors\n        grid = np.stack([kx, ky, kz], axis=-1).reshape(-1, 3)\n        return grid\n\n    def compute_ibz(n_dims, r_ops, tol=1e-12, hash_precision=8):\n        \"\"\"\n        Computes the irreducible Brillouin zone (IBZ) for a given MP grid\n        and a set of point group symmetry operations.\n\n        Args:\n            n_dims (tuple): Grid dimensions (N1, N2, N3).\n            r_ops (list): List of 3x3 numpy arrays for symmetry operations.\n            tol (float): Tolerance for checking if the sum of weights is 1.\n            hash_precision (int): Decimal precision for hashing k-points.\n\n        Returns:\n            tuple: (M, S, min_w, max_w, b) where\n                M: Number of irreducible points.\n                S: Sum of weights.\n                min_w: Minimum weight.\n                max_w: Maximum weight.\n                b: Boolean, True if |S-1|  tol.\n        \"\"\"\n        n_total = np.prod(n_dims)\n        full_grid = generate_mp_grid(n_dims)\n        \n        visited_k_hashes = set()\n        ir_k_points = []\n        ir_weights = []\n        \n        for k_point in full_grid:\n            # Check if point has been visited (is part of a previously found orbit)\n            # We must wrap the point first to get its canonical representation\n            # before checking the visited set.\n            canonical_k_point = wrap_to_canonical_cell(k_point)\n            k_hash = get_k_point_hash(canonical_k_point, hash_precision)\n\n            if k_hash in visited_k_hashes:\n                continue\n            \n            # If not visited, this k-point starts a new orbit.\n            # Generate the orbit by applying all symmetry operations.\n            orbit_hashes = set()\n            for r_mat in r_ops:\n                k_rotated = r_mat @ k_point\n                k_wrapped = wrap_to_canonical_cell(k_rotated)\n                orbit_hashes.add(get_k_point_hash(k_wrapped, hash_precision))\n            \n            # Calculate orbit properties\n            orbit_size = len(orbit_hashes)\n            weight = orbit_size / n_total\n            \n            # Determine canonical representative (lexicographically smallest)\n            canonical_rep_tuple = min(orbit_hashes)\n            \n            ir_k_points.append(np.array(canonical_rep_tuple))\n            ir_weights.append(weight)\n            \n            # Mark all points in the newly found orbit as visited\n            visited_k_hashes.update(orbit_hashes)\n            \n        m = len(ir_k_points)\n        s = np.sum(ir_weights)\n        min_w = np.min(ir_weights) if ir_weights else 0.0\n        max_w = np.max(ir_weights) if ir_weights else 0.0\n        b = np.abs(s - 1.0)  tol\n        \n        return m, s, min_w, max_w, b\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": (4, 4, 4),\n            \"R\": [\n                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n                np.array([[0, -1, 0], [1, 0, 0], [0, 0, 1]]),\n                np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 1]]),\n                np.array([[0, 1, 0], [-1, 0, 0], [0, 0, 1]]),\n            ]\n        },\n        {\n            \"N\": (3, 3, 3),\n            \"R\": [\n                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            ]\n        },\n        {\n            \"N\": (2, 2, 2),\n            \"R\": [\n                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n                np.array([[-1, 0, 0], [0, -1, 0], [0, 0, -1]]),\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, s, min_w, max_w, b_val = compute_ibz(case[\"N\"], case[\"R\"])\n        results.append(f\"[{m},{s},{min_w},{max_w},{str(b_val).lower()}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在完成计算后，一个关键问题依然存在：$k$点采样的密度是否足以得到收敛的结果？本练习介绍了一种强大的“后验”（*a posteriori*）方法，通过比较来自两个不同网格的结果来回答这个问题。您不仅将学会构建一个实用的误差估计，还将实现理查德森外推法（Richardson extrapolation），这是一种结合两次计算结果以产生比单一计算更精确估计的技术。",
            "id": "3467022",
            "problem": "您需要实现一个完整的、可运行的程序，该程序生成蒙克霍斯特-帕克网格，并使用它们为合成的能量和力密度构建布里渊区积分的后验误差估计和理查森外推。上下文是计算材料科学中对布里渊区的数值积分。所有角度都以弧度处理，所有报告的量均为无量纲。\n\n起点是以下一组基本定义。\n\n- 布里渊区被视为由倒易晶格矢量 $\\mathbf{b}_1$、$\\mathbf{b}_2$ 和 $\\mathbf{b}_3$ 张成的平行六面体。对于晶格参数归一化的简单立方晶格，假设 $\\mathbf{b}_1 = 2\\pi \\,\\hat{\\mathbf{e}}_x$、$\\mathbf{b}_2 = 2\\pi \\,\\hat{\\mathbf{e}}_y$ 和 $\\mathbf{b}_3 = 2\\pi \\,\\hat{\\mathbf{e}}_z$，因此布里渊区在笛卡尔分量中是立方体 $[-\\pi,\\pi]^3$。布里渊区体积为 $V_{\\mathrm{BZ}} = (2\\pi)^3$。\n\n- 蒙克霍斯特-帕克 (MP) 网格由三个正整数 $(N_1,N_2,N_3)$ 和一个位移矢量 $\\mathbf{s} = (s_1,s_2,s_3)$ 定义，其中每个 $s_i \\in [0,1)$。在简约坐标中，采样点为\n$$\nt_i(n_i) = \\frac{n_i + s_i}{N_i}, \\quad n_i \\in \\{0,1,\\dots,N_i-1\\}, \\quad i\\in\\{1,2,3\\}。\n$$\n到笛卡尔倒易空间的映射通过以下方式执行\n$$\n\\mathbf{k}(\\mathbf{n}) = \\sum_{i=1}^3 \\left( t_i(n_i) - \\frac{1}{2} \\right) \\mathbf{b}_i,\n$$\n因此对于所有的 $\\mathbf{n}=(n_1,n_2,n_3)$，都有 $\\mathbf{k}(\\mathbf{n}) \\in [-\\pi,\\pi]^3$。\n\n- 标量被积函数 $f(\\mathbf{k})$ 的布里渊区平均值为\n$$\n\\bar{f} = \\frac{1}{V_{\\mathrm{BZ}}} \\int_{\\mathrm{BZ}} f(\\mathbf{k}) \\, d^3 k.\n$$\n均匀 MP 网格求积通过 $f$ 在网格点上的简单平均来近似 $\\bar{f}$，因为所有 MP 网格权重都相等。对于矢量值被积函数 $\\mathbf{g}(\\mathbf{k})$，平均值是分量式应用的。\n\n您将使用以下模拟金属性费米面的合成的、物理上合理的被积函数：\n\n- 总能量密度是半径为 $k_F$ 的费米球的指示函数，\n$$\ne(\\mathbf{k}) = \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}},\n$$\n因此其精确的布里渊区平均值为\n$$\n\\bar{E}_{\\mathrm{exact}} = \\frac{1}{V_{\\mathrm{BZ}}} \\int_{\\mathrm{BZ}} \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}} \\, d^3k = \\frac{\\frac{4}{3}\\pi k_F^3}{(2\\pi)^3} = \\frac{k_F^3}{6\\pi^2}.\n$$\n\n- 力密度是在同一费米球内与 $\\mathbf{k}$ 成正比的矢量场，\n$$\n\\mathbf{f}(\\mathbf{k}) = \\mathbf{k} \\, \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}},\n$$\n根据对称性，其精确的布里渊区平均值为零矢量，\n$$\n\\bar{\\mathbf{F}}_{\\mathrm{exact}} = \\frac{1}{V_{\\mathrm{BZ}}} \\int_{\\mathrm{BZ}} \\mathbf{k}\\, \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}} \\, d^3k = \\mathbf{0}。\n$$\n\n在具有位移 $\\mathbf{s}^{(N)}$ 的网格 $(N,N,N)$ 上，定义离散平均值\n$$\nE^{(N)} = \\frac{1}{N^3} \\sum_{\\mathbf{n}} e\\!\\left(\\mathbf{k}(\\mathbf{n})\\right), \\quad \\mathbf{F}^{(N)} = \\frac{1}{N^3} \\sum_{\\mathbf{n}} \\mathbf{f}\\!\\left(\\mathbf{k}(\\mathbf{n})\\right),\n$$\n类似地，在具有位移 $\\mathbf{s}^{(N+1)}$ 的 $(N+1,N+1,N+1)$ 网格上定义 $E^{(N+1)}$ 和 $\\mathbf{F}^{(N+1)}$。由于指示函数被积函数在费米面上是非光滑的，当使用均匀采样时，对于足够大的 $N$，形式如下的主导误差模型是合适的\n$$\nE^{(N)} = \\bar{E}_{\\infty} + \\frac{C_E}{N} + \\mathcal{O}\\!\\left(\\frac{1}{N^2}\\right), \\quad \\mathbf{F}^{(N)} = \\bar{\\mathbf{F}}_{\\infty} + \\frac{\\mathbf{C}_F}{N} + \\mathcal{O}\\!\\left(\\frac{1}{N^2}\\right)。\n$$\n在该模型下，可以利用关于 $1/N$ 的理查森外推来消除主导的 $\\mathcal{O}(1/N)$ 误差，并从两个连续的网格中近似无限分辨率极限 $\\bar{E}_{\\infty}$ 和 $\\bar{\\mathbf{F}}_{\\infty}$。您必须从这个渐近模型推导出标量和矢量情况下的外推公式，而不使用任何预先给定的快捷公式。\n\n使用两个互补网格 $(N,N,N)$（位移为 $\\mathbf{s}^{(N)}$）和 $(N+1,N+1,N+1)$（位移为 $\\mathbf{s}^{(N+1)}$）构建后验误差估计，这里定义为不同的位移。标量能量的估计器应该是一个非负标量，仅依赖于两个计算出的离散值；力的估计器应该是一个非负标量，仅依赖于两个计算出的离散矢量，例如它们在合适范数下的差值。这些估计器不得使用任何关于精确积分的知识。\n\n程序中要实现的任务：\n\n- 根据给定的 $(N_1,N_2,N_3)$ 和位移 $\\mathbf{s}$ 生成如上定义的蒙克霍斯特-帕克网格。\n\n- 对每个测试案例，计算 $E^{(N)}$、$E^{(N+1)}$、$\\mathbf{F}^{(N)}$ 和 $\\mathbf{F}^{(N+1)}$。\n\n- 推导并应用关于 $1/N$ 的理查森外推，从 $E^{(N)}$、$E^{(N+1)}$ 和 $\\mathbf{F}^{(N)}$、$\\mathbf{F}^{(N+1)}$ 获得 $E^{\\mathrm{R}}$ 和 $\\mathbf{F}^{\\mathrm{R}}$。\n\n- 仅使用两个互补网格构建后验误差估计器 $\\eta_E$ 和 $\\eta_F$。\n\n- 仅为验证目的，通过将 $E^{\\mathrm{R}}$ 与 $\\bar{E}_{\\mathrm{exact}}$ 以及 $\\mathbf{F}^{\\mathrm{R}}$ 与 $\\bar{\\mathbf{F}}_{\\mathrm{exact}}$ 进行比较，计算真实误差。\n\n测试套件，涵盖典型情况、不同位移的情况以及小网格边缘情况：\n\n- 案例 1：$N = 6$，$\\mathbf{s}^{(N)} = (0,0,0)$，$\\mathbf{s}^{(N+1)} = (0.5,0.5,0.5)$，$k_F = 1.2$。\n\n- 案例 2：$N = 3$，$\\mathbf{s}^{(N)} = (0.25,0.25,0.25)$，$\\mathbf{s}^{(N+1)} = (0.75,0.75,0.75)$，$k_F = 1.8$。\n\n- 案例 3：$N = 2$，$\\mathbf{s}^{(N)} = (0,0,0)$，$\\mathbf{s}^{(N+1)} = (0.5,0.5,0.5)$，$k_F = 0.3$。\n\n要求的最终输出格式：\n\n- 对每个案例，按以下顺序输出一个包含六个浮点数的列表：\n    1. $E^{\\mathrm{R}}$。\n    2. $\\eta_E$。\n    3. $|E^{\\mathrm{R}} - \\bar{E}_{\\mathrm{exact}}|$。\n    4. $\\|\\mathbf{F}^{\\mathrm{R}}\\|_2$。\n    5. $\\eta_F$。\n    6. $\\|\\mathbf{F}^{\\mathrm{R}} - \\bar{\\mathbf{F}}_{\\mathrm{exact}}\\|_2$。\n\n- 将三个案例的结果汇总为单行，形式为一个扁平的、逗号分隔的 Python 风格列表，不含额外文本，例如\n$$\n[\\text{案例 1 的六个数字}, \\text{案例 2 的六个数字}, \\text{案例 3 的六个数字}]。\n$$\n\n程序必须按此格式精确输出一行。所有计算都以弧度进行，所有输出均为通过标准浮点表示法四舍五入的无量纲实数。不允许使用外部输入或文件；所有数据都包含在程序中。",
            "solution": "用户提供的问题是计算材料科学领域中一个定义明确的计算任务，具体涉及对第一布里渊区上物理量的数值积分。该问题科学上合理，数学上一致，并包含了进行求解所需的所有信息。\n\n问题的核心是实现用于布里渊区采样的蒙克霍斯特-帕克 (MP) 方法，然后应用理查森外推来提高所计算积分的准确性。我们将首先形式化所需的推导，然后概述计算流程。\n\n### 蒙克霍斯特-帕克网格生成\n\n指定简单立方晶胞的倒易晶格由矢量 $\\mathbf{b}_1 = 2\\pi \\,\\hat{\\mathbf{e}}_x$、$\\mathbf{b}_2 = 2\\pi \\,\\hat{\\mathbf{e}}_y$ 和 $\\mathbf{b}_3 = 2\\pi \\,\\hat{\\mathbf{e}}_z$ 给出。第一布里渊区 (BZ) 对应于倒易晶格的维格纳-赛兹原胞，对于这个简单情况，它是一个由 $\\mathbf{k} = (k_x, k_y, k_z)$ 且 $k_i \\in [-\\pi, \\pi]$ 定义的立方体。此 BZ 的体积为 $V_{\\mathrm{BZ}} = (2\\pi)^3$。\n\n一个蒙克霍斯特-帕克网格由一组正整数 $(N_1, N_2, N_3)$ 和一个位移矢量 $\\mathbf{s} = (s_1, s_2, s_3)$ 定义，其中每个分量 $s_i \\in [0, 1)$。网格点，在简约坐标中，为：\n$$\nt_i(n_i) = \\frac{n_i + s_i}{N_i}, \\quad \\text{for } n_i \\in \\{0, 1, \\dots, N_i-1\\}, \\quad i \\in \\{1, 2, 3\\}.\n$$\n这些简约坐标使用提供的公式映射到倒易空间中的笛卡尔坐标：\n$$\n\\mathbf{k}(\\mathbf{n}) = \\sum_{i=1}^3 \\left( t_i(n_i) - \\frac{1}{2} \\right) \\mathbf{b}_i\n$$\n对于简单立方晶格特定的 $\\mathbf{b}_i$ 矢量，$\\mathbf{k}$ 点的分量为：\n$$\nk_i(\\mathbf{n}) = k_i(n_i) = 2\\pi \\left( \\frac{n_i + s_i}{N_i} - \\frac{1}{2} \\right)\n$$\n此公式生成一个 $N_1 \\times N_2 \\times N_3$ 个点的均匀网格，用于对布里渊区进行采样。\n\n### 布里渊区积分的数值求积\n\n函数 $f(\\mathbf{k})$ 的布里渊区平均值定义为：\n$$\n\\bar{f} = \\frac{1}{V_{\\mathrm{BZ}}} \\int_{\\mathrm{BZ}} f(\\mathbf{k}) \\, d^3 k\n$$\n蒙克霍斯特-帕克方案通过在网格点上计算的函数值的简单算术平均来近似此积分。对于一个大小为 $N \\times N \\times N$ 的均匀网格，对平均值 $\\bar{q}$ 的离散近似 $Q^{(N)}$ 为：\n$$\nQ^{(N)} = \\frac{1}{N^3} \\sum_{n_1=0}^{N-1} \\sum_{n_2=0}^{N-1} \\sum_{n_3=0}^{N-1} q(\\mathbf{k}(\\mathbf{n}))\n$$\n其中 $q$ 可以是标量能量密度 $e(\\mathbf{k})$ 或矢量力密度 $\\mathbf{f}(\\mathbf{k})$。问题指定了以下合成的被积函数：\n-   能量密度：$e(\\mathbf{k}) = \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}}$，其中 $\\mathbf{1}$ 是指示函数。精确平均值为 $\\bar{E}_{\\mathrm{exact}} = k_F^3 / (6\\pi^2)$。\n-   力密度：$\\mathbf{f}(\\mathbf{k}) = \\mathbf{k} \\, \\mathbf{1}_{\\{\\|\\mathbf{k}\\| \\le k_F\\}}$。由于被积函数在对称域上的奇对称性，精确平均值为 $\\bar{\\mathbf{F}}_{\\mathrm{exact}} = \\mathbf{0}$。\n\n### 理查森外推的推导\n\n问题指出，对于所使用的非光滑被积函数，离散平均值 $Q^{(N)}$ 向真值 $\\bar{Q}_{\\infty}$ 的收敛遵循以下渐近误差模型：\n$$\nQ^{(N)} = \\bar{Q}_{\\infty} + \\frac{C_Q}{N} + \\mathcal{O}\\left(\\frac{1}{N^2}\\right)\n$$\n其中 $C_Q$ 是一个常数。我们可以使用在不同网格上的两次计算来消除主导阶误差项 $\\mathcal{O}(1/N)$。考虑大小为 $N$ 和 $N+1$ 的网格。我们有：\n$$\nE^{(N)} = \\bar{E}_{\\infty} + \\frac{C_E}{N} + \\mathcal{O}\\left(\\frac{1}{N^2}\\right)\n$$\n$$\nE^{(N+1)} = \\bar{E}_{\\infty} + \\frac{C_E}{N+1} + \\mathcal{O}\\left(\\frac{1}{(N+1)^2}\\right)\n$$\n忽略高阶项，我们将它们视为一个关于未知数 $\\bar{E}_{\\infty}$ 和 $C_E$ 的二元线性方程组：\n$$\nE^{(N)} \\approx \\bar{E}_{\\infty} + \\frac{C_E}{N} \\quad (1)\n$$\n$$\nE^{(N+1)} \\approx \\bar{E}_{\\infty} + \\frac{C_E}{N+1} \\quad (2)\n$$\n从 (1) 中，我们表示 $C_E$ 为 $C_E \\approx N(E^{(N)} - \\bar{E}_{\\infty})$。将其代入 (2) 得：\n$$\nE^{(N+1)} \\approx \\bar{E}_{\\infty} + \\frac{N(E^{(N)} - \\bar{E}_{\\infty})}{N+1}\n$$\n两边乘以 $(N+1)$ 并重新整理以求解 $\\bar{E}_{\\infty}$：\n$$\n(N+1)E^{(N+1)} \\approx (N+1)\\bar{E}_{\\infty} + N(E^{(N)} - \\bar{E}_{\\infty})\n$$\n$$\n(N+1)E^{(N+1)} - NE^{(N)} \\approx (N+1)\\bar{E}_{\\infty} - N\\bar{E}_{\\infty} = \\bar{E}_{\\infty}\n$$\n这给出了理查森外推估计值 $E^{\\mathrm{R}}$，其误差为 $\\mathcal{O}(1/N^2)$：\n$$\nE^{\\mathrm{R}} = (N+1)E^{(N+1)} - N E^{(N)}\n$$\n同样的推导可以分量式地应用于矢量量 $\\mathbf{F}^{(N)}$，从而得到外推力矢量 $\\mathbf{F}^{\\mathrm{R}}$ 的类似公式：\n$$\n\\mathbf{F}^{\\mathrm{R}} = (N+1)\\mathbf{F}^{(N+1)} - N \\mathbf{F}^{(N)}\n$$\n\n### 后验误差估计\n\n后验误差估计器仅使用计算结果来衡量数值误差，而无需知道精确解。一个简单而有效的选择是两个网格结果之间差值的量级。\n对于标量能量，我们定义估计器 $\\eta_E$ 为：\n$$\n\\eta_E = |E^{(N+1)} - E^{(N)}|\n$$\n这个量与主导阶误差系数直接相关，因为 $\\eta_E \\approx |C_E|/(N(N+1))$。\n对于矢量力，我们定义估计器 $\\eta_F$ 为差矢量的标准欧几里得范数：\n$$\n\\eta_F = \\|\\mathbf{F}^{(N+1)} - \\mathbf{F}^{(N)}\\|_2\n$$\n$\\eta_E$ 和 $\\eta_F$ 都是非负标量，它们衡量两个网格上计算结果的一致性，可作为真实误差的代理。\n\n### 计算步骤总结\n\n对于由 $N$、$\\mathbf{s}^{(N)}$、$\\mathbf{s}^{(N+1)}$ 和 $k_F$ 指定的每个测试案例：\n1.  在具有位移 $\\mathbf{s}^{(N)}$ 的 $N \\times N \\times N$ 网格上计算离散平均值 $E^{(N)}$ 和 $\\mathbf{F}^{(N)}$。\n2.  在具有位移 $\\mathbf{s}^{(N+1)}$ 的 $(N+1) \\times (N+1) \\times (N+1)$ 网格上计算离散平均值 $E^{(N+1)}$ 和 $\\mathbf{F}^{(N+1)}$。\n3.  计算理查森外推值 $E^{\\mathrm{R}} = (N+1)E^{(N+1)} - N E^{(N)}$ 和 $\\mathbf{F}^{\\mathrm{R}} = (N+1)\\mathbf{F}^{(N+1)} - N \\mathbf{F}^{(N)}$。\n4.  计算后验误差估计器 $\\eta_E = |E^{(N+1)} - E^{(N)}|$ 和 $\\eta_F = \\|\\mathbf{F}^{(N+1)} - \\mathbf{F}^{(N)}\\|_2$。\n5.  计算精确能量平均值 $\\bar{E}_{\\mathrm{exact}} = k_F^3 / (6\\pi^2)$。精确力平均值 $\\bar{\\mathbf{F}}_{\\mathrm{exact}}$ 是零矢量。\n6.  确定外推结果的真实误差：$|E^{\\mathrm{R}} - \\bar{E}_{\\mathrm{exact}}|$ 和 $\\|\\mathbf{F}^{\\mathrm{R}} - \\bar{\\mathbf{F}}_{\\mathrm{exact}}\\|_2 = \\|\\mathbf{F}^{\\mathrm{R}}\\|_2$。\n7.  按指定顺序收集六个所需的浮点数：$E^{\\mathrm{R}}$、$\\eta_E$、_`|E^{\\mathrm{R}} - \\bar{E}_{\\mathrm{exact}}|`_、$\\|\\mathbf{F}^{\\mathrm{R}}\\|_2$、$\\eta_F$ 和 $\\|\\mathbf{F}^{\\mathrm{R}} - \\bar{\\mathbf{F}}_{\\mathrm{exact}}\\|_2$。\n\n这些步骤在提供的 Python 程序中实现，以生成最终的数值结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_averages(grid_size: int, shift: np.ndarray, kF: float) -> tuple[float, np.ndarray]:\n    \"\"\"\n    Computes the discrete Brillouin zone averages for energy and force densities.\n\n    Args:\n        grid_size: The number of k-points along one dimension (N).\n        shift: The Monkhorst-Pack grid shift vector (s_1, s_2, s_3).\n        kF: The Fermi radius for the synthetic integrands.\n\n    Returns:\n        A tuple containing the average energy (scalar) and average force (3D vector).\n    \"\"\"\n    # Create 1D coordinate arrays for k_x, k_y, k_z\n    n_vals = np.arange(grid_size)\n    k_coords_1d = []\n    for i in range(3):\n        # Reduced coordinates\n        t_i = (n_vals + shift[i]) / grid_size\n        # Cartesian reciprocal coordinates\n        k_coord_i = 2 * np.pi * (t_i - 0.5)\n        k_coords_1d.append(k_coord_i)\n\n    # Create a 3D grid of k-vectors using meshgrid.\n    # 'ij' indexing ensures the output array axes correspond to kx, ky, kz.\n    kx_grid, ky_grid, kz_grid = np.meshgrid(\n        k_coords_1d[0], k_coords_1d[1], k_coords_1d[2], indexing='ij'\n    )\n    # Stack the coordinate grids to get a grid of 3D vectors.\n    # Shape: (grid_size, grid_size, grid_size, 3)\n    k_points = np.stack([kx_grid, ky_grid, kz_grid], axis=-1)\n\n    # Calculate the Euclidean norm of each k-vector in the grid.\n    k_norms = np.linalg.norm(k_points, axis=3)\n\n    # Evaluate the indicator function for the Fermi sphere.\n    # This represents the energy density e(k).\n    indicator = (k_norms = kF).astype(float)\n\n    # The BZ average of e(k) is the simple mean over the grid.\n    E_avg = np.mean(indicator)\n\n    # Evaluate the force density f(k) = k * indicator.\n    # Use broadcasting to multiply the (N, N, N, 3) k_points grid\n    # by the (N, N, N) indicator grid.\n    f_k = k_points * indicator[..., np.newaxis]\n    \n    # The BZ average of f(k) is the mean over grid dimensions (0, 1, 2).\n    F_avg = np.mean(f_k, axis=(0, 1, 2))\n\n    return E_avg, F_avg\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 6, 's_N': (0.0, 0.0, 0.0), 's_Np1': (0.5, 0.5, 0.5), 'kF': 1.2},\n        {'N': 3, 's_N': (0.25, 0.25, 0.25), 's_Np1': (0.75, 0.75, 0.75), 'kF': 1.8},\n        {'N': 2, 's_N': (0.0, 0.0, 0.0), 's_Np1': (0.5, 0.5, 0.5), 'kF': 0.3},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N = case['N']\n        kF = case['kF']\n        s_N = np.array(case['s_N'])\n        s_Np1 = np.array(case['s_Np1'])\n\n        # Compute discrete averages for grid N and grid N+1\n        E_N, F_N = compute_averages(N, s_N, kF)\n        E_Np1, F_Np1 = compute_averages(N + 1, s_Np1, kF)\n\n        # Apply Richardson extrapolation\n        E_R = (N + 1) * E_Np1 - N * E_N\n        F_R = (N + 1) * F_Np1 - N * F_N\n\n        # Construct a posteriori error estimators\n        eta_E = np.abs(E_Np1 - E_N)\n        eta_F = np.linalg.norm(F_Np1 - F_N)\n\n        # Compute exact values for comparison\n        E_exact = kF**3 / (6 * np.pi**2)\n        F_exact_vec = np.array([0.0, 0.0, 0.0])\n\n        # Compute true errors of the extrapolated results\n        true_err_E = np.abs(E_R - E_exact)\n        norm_F_R = np.linalg.norm(F_R)\n        # The 6th required output is ||F^R - F_exact||_2, which is ||F^R - 0||_2 = ||F^R||_2\n        true_err_F = np.linalg.norm(F_R - F_exact_vec)\n\n        # Assemble the six required quantities for this test case\n        case_results = [\n            E_R,\n            eta_E,\n            true_err_E,\n            norm_F_R,\n            eta_F,\n            true_err_F,\n        ]\n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}