{
    "hands_on_practices": [
        {
            "introduction": "This first practice is about translating theory into code. We will implement the plane-wave method for a simple one-dimensional system, which is the conceptual foundation for modern electronic structure codes. By constructing and diagonalizing the Hamiltonian for a periodic potential from scratch, you will gain a concrete understanding of how energy bands and band gaps emerge from the Schrödinger equation in a crystal .",
            "id": "3435150",
            "problem": "You are given a one-dimensional electron moving in a scalar periodic potential with lattice constant $a$, described by the stationary Schrödinger equation\n$$\n\\left[-\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x)\\right]\\psi_{k}(x) = E(k)\\,\\psi_{k}(x),\n$$\nwhere $V(x)$ satisfies $V(x+a)=V(x)$. According to Bloch's theorem, any eigenfunction can be written as $\\psi_k(x) = e^{ikx}u_k(x)$ with $u_k(x+a)=u_k(x)$. Consider the specific potential $V(x)=V_0\\cos\\!\\left(\\frac{2\\pi}{a}x\\right)$ and construct $\\psi_k(x)$ numerically by expanding $u_k(x)$ in Fourier modes. Your task is to derive from first principles an algorithm that builds and diagonalizes the Hamiltonian in a plane-wave basis truncated to a finite number of reciprocal lattice vectors and to use it to extract band energies at selected crystal momenta.\n\nFundamental base to use:\n- The time-independent Schrödinger equation for a single particle in one dimension.\n- The statement of Bloch's theorem and the periodicity of $u_k(x)$.\n- The definition of Fourier series for periodic functions with period $a$, and the set of reciprocal lattice vectors $G_n = \\frac{2\\pi}{a}n$ for integer $n$.\n\nRequirements for the construction:\n- Start from $\\psi_k(x)=e^{ikx}u_k(x)$ with $u_k(x)=\\sum_{n=-N_{\\text{max}}}^{N_{\\text{max}}} c_n\\,e^{i G_n x}$, where $G_n=\\frac{2\\pi}{a}n$, and $N_{\\text{max}}$ is a finite cutoff.\n- Substitute the expansion into the Schrödinger equation to obtain a finite-dimensional Hermitian matrix eigenproblem for the coefficients $c_n$ at fixed $k$.\n- Explicitly use the Fourier coefficients of $V(x)=V_0\\cos\\!\\left(\\frac{2\\pi}{a}x\\right)$ to determine which matrix elements are nonzero.\n- Work in energy units of $E_0=\\frac{\\hbar^2}{2ma^2}$, and report all energies as dimensionless numbers in units of $E_0$. Set $a=1$ and $\\frac{\\hbar^2}{2m}=1$ for numerical evaluation, so that $G_0=2\\pi$ and $E_0=1$.\n- Use crystal momentum values $k\\in\\{0, \\pi/2, \\pi\\}$, with angles in radians.\n\nYour program must:\n- Implement the described plane-wave Hamiltonian construction and diagonalization for given $(V_0,N_{\\text{max}})$ and crystal momentum $k$.\n- For each specified parameter set, compute:\n  1. The lowest band energy at $k=0$.\n  2. The lowest band energy at $k=\\pi$.\n  3. The direct band gap at the Brillouin-zone boundary $k=\\pi$, defined as $E_2(\\pi)-E_1(\\pi)$ where $E_1(\\pi)\\le E_2(\\pi)\\le\\cdots$ are the ascending eigenvalues at $k=\\pi$.\n\nPhysical units and reporting:\n- All energies must be reported in units of $E_0=\\frac{\\hbar^2}{2ma^2}$, as dimensionless floats. Angles are in radians.\n\nTest suite:\n- Use $a=1$ and the following parameter sets $(V_0,N_{\\text{max}})$:\n  - Case $1$: $(V_0,N_{\\text{max}})=(0,3)$.\n  - Case $2$: $(V_0,N_{\\text{max}})=(1,5)$.\n  - Case $3$: $(V_0,N_{\\text{max}})=(10,9)$.\n  - Case $4$: $(V_0,N_{\\text{max}})=(-2,7)$.\n\nFinal output format:\n- For each case, compute the triple $\\big(E_1(0),\\,E_1(\\pi),\\,E_2(\\pi)-E_1(\\pi)\\big)$ and round each float to $6$ decimal places using standard rounding.\n- Your program should produce a single line of output containing the results for all four cases, concatenated in order and flattened into one list, as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,\\dots,r_{12}]$ with $12$ floats total.",
            "solution": "The user-provided problem is assessed to be valid as it represents a standard, well-posed problem in introductory solid-state physics, free from scientific or logical flaws. We will now proceed with a complete solution.\n\nThe objective is to solve the time-independent Schrödinger equation for an electron in a one-dimensional periodic potential $V(x) = V_0\\cos\\!\\left(\\frac{2\\pi}{a}x\\right)$. The equation is:\n$$\n\\left[-\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x)\\right]\\psi_{k}(x) = E(k)\\,\\psi_{k}(x)\n$$\nwhere $V(x) = V(x+a)$. According to Bloch's theorem, the eigenfunctions $\\psi_k(x)$ can be expressed in the form $\\psi_k(x) = e^{ikx}u_k(x)$, where $u_k(x)$ has the same periodicity as the lattice, $u_k(x+a) = u_k(x)$. The crystal momentum $k$ is a good quantum number.\n\nSubstituting the Bloch form into the Schrödinger equation, we derive an equation for the periodic function $u_k(x)$. The derivatives of $\\psi_k(x)$ are:\n$$\n\\frac{d\\psi_k}{dx} = e^{ikx}\\left(ik + \\frac{d}{dx}\\right)u_k(x)\n$$\n$$\n\\frac{d^2\\psi_k}{dx^2} = e^{ikx}\\left(ik + \\frac{d}{dx}\\right)^2 u_k(x) = e^{ikx}\\left(-\\!k^2 + 2ik\\frac{d}{dx} + \\frac{d^2}{dx^2}\\right)u_k(x)\n$$\nSubstituting this into the Schrödinger equation and canceling the common factor $e^{ikx}$ yields an eigenvalue equation for $u_k(x)$:\n$$\n\\left[\\frac{\\hbar^2}{2m}\\left(-k^2 + 2ik\\frac{d}{dx} + \\frac{d^2}{dx^2}\\right)\\!\\!(-1) + V(x)\\right]u_k(x) = E(k)u_k(x)\n$$\n$$\n\\left[\\frac{\\hbar^2}{2m}\\left(k - i\\frac{d}{dx}\\right)^2 + V(x)\\right]u_k(x) = E(k)u_k(x)\n$$\nSince $u_k(x)$ is periodic with period $a$, it can be expanded in a Fourier series over the reciprocal lattice vectors $G_n = \\frac{2\\pi}{a}n$ for integer $n$:\n$$\nu_k(x) = \\sum_{n} c_n e^{iG_n x}\n$$\nThe problem specifies a finite basis set truncated at $n = \\pm N_{\\text{max}}$.\n$$\nu_k(x) = \\sum_{n=-N_{\\text{max}}}^{N_{\\text{max}}} c_n e^{iG_n x}\n$$\nSimilarly, the periodic potential $V(x)$ is expanded in a Fourier series:\n$$\nV(x) = \\sum_{p} V_p e^{iG_p x}\n$$\nFor the specific potential $V(x) = V_0\\cos\\!\\left(\\frac{2\\pi}{a}x\\right)$, we can use Euler's formula:\n$$\nV(x) = \\frac{V_0}{2}\\left(e^{i\\frac{2\\pi}{a}x} + e^{-i\\frac{2\\pi}{a}x}\\right) = \\frac{V_0}{2}\\left(e^{iG_1 x} + e^{iG_{-1} x}\\right)\n$$\nFrom this, we identify the non-zero Fourier coefficients of the potential: $V_1 = V_{-1} = \\frac{V_0}{2}$. All other coefficients $V_p$ are zero, including the average potential $V_0_d = 0$.\n\nSubstituting the Fourier expansions for $u_k(x)$ and $V(x)$ into the equation for $u_k(x)$:\n$$\n\\left[\\frac{\\hbar^2}{2m}\\left(k - i\\frac{d}{dx}\\right)^2 + \\sum_p V_p e^{iG_p x}\\right] \\sum_n c_n e^{iG_n x} = E(k) \\sum_n c_n e^{iG_n x}\n$$\nThe differential operator acts on each basis function $e^{iG_n x}$ as:\n$$\n\\left(k - i\\frac{d}{dx}\\right)e^{iG_n x} = (k+G_n)e^{iG_n x}\n$$\n$$\n\\left(k - i\\frac{d}{dx}\\right)^2 e^{iG_n x} = (k+G_n)^2 e^{iG_n x}\n$$\nThe equation becomes:\n$$\n\\sum_n \\frac{\\hbar^2}{2m}(k+G_n)^2 c_n e^{iG_n x} + \\left(\\sum_p V_p e^{iG_p x}\\right)\\left(\\sum_n c_n e^{iG_n x}\\right) = E(k) \\sum_n c_n e^{iG_n x}\n$$\nThe product of the two series is a convolution in coefficient space:\n$$\n\\sum_n \\frac{\\hbar^2}{2m}(k+G_n)^2 c_n e^{iG_n x} + \\sum_{n,p} V_p c_n e^{i(G_n+G_p)x} = E(k) \\sum_n c_n e^{iG_n x}\n$$\nTo obtain a matrix equation, we project onto a basis function $e^{-iG_m x}$ and integrate over one unit cell (from $x=0$ to $x=a$), scaled by $1/a$. Using the orthogonality relation $\\frac{1}{a}\\int_0^a e^{iG_j x} e^{-iG_m x} dx = \\delta_{jm}$, we obtain an equation for each coefficient $c_m$:\n$$\n\\frac{\\hbar^2}{2m}(k+G_m)^2 c_m + \\sum_{n,p} V_p c_n \\delta_{m, n+p} = E(k)c_m\n$$\nThe Kronecker delta $\\delta_{m, n+p}$ enforces the condition $m=n+p$, which implies $n=m-p$. The summation over $n$ and $p$ reduces to a single sum over $p$:\n$$\n\\frac{\\hbar^2}{2m}(k+G_m)^2 c_m + \\sum_p V_p c_{m-p} = E(k)c_m\n$$\nThis is the central equation in matrix form, $H \\mathbf{c} = E \\mathbf{c}$, where $\\mathbf{c}$ is the vector of coefficients $(c_n)$. The matrix elements $H_{mn}$ are given by:\n$$\nH_{mn} = \\frac{\\hbar^2}{2m}(k+G_m)^2 \\delta_{mn} + V_{m-n}\n$$\nFor our specific potential, $V_{m-n}$ is non-zero only when $m-n = \\pm 1$, where $V_1 = V_{-1} = V_0/2$. This leads to a tridiagonal Hamiltonian matrix in the basis of reciprocal lattice vectors indexed by $n$:\n\\begin{itemize}\n    \\item Diagonal elements ($m=n$): $H_{mm} = \\frac{\\hbar^2}{2m}(k+G_m)^2$\n    \\item Off-diagonal elements ($m=n \\pm 1$): $H_{m,m-1} = V_{1} = V_0/2$ and $H_{m,m+1} = V_{-1} = V_0/2$\n\\end{itemize}\nThe problem specifies working in units where $a=1$ and $\\frac{\\hbar^2}{2m}=1$. All energies are consequently in units of $E_0 = \\frac{\\hbar^2}{2ma^2}=1$. In these units, the reciprocal lattice vectors are $G_n = 2\\pi n$, and the Hamiltonian matrix elements are:\n$$\nH_{mn} = (k+2\\pi m)^2 \\delta_{mn} + \\frac{V_0}{2}(\\delta_{m,n+1} + \\delta_{m,n-1})\n$$\nThe algorithm for the solution is as follows:\n1. For a given set of parameters $(V_0, N_{\\text{max}})$ and a crystal momentum $k$, construct the Hamiltonian matrix $H$. The indices $m,n$ range from $-N_{\\text{max}}$ to $N_{\\text{max}}$, so the matrix size is $(2N_{\\text{max}}+1) \\times (2N_{\\text{max}}+1)$.\n2. The matrix is populated by setting the diagonal elements to $(k+2\\pi m)^2$ and the super- and sub-diagonal elements to $V_0/2$.\n3. This real, symmetric (and therefore Hermitian) matrix is diagonalized using a numerical linear algebra routine. We use `scipy.linalg.eigh`, which is optimized for Hermitian matrices and returns sorted real eigenvalues.\n4. The eigenvalues of $H$ are the band energies $E_n(k)$.\n5. For each test case $(V_0, N_{\\text{max}})$:\n   a. Compute eigenvalues for $k=0$. The lowest eigenvalue is $E_1(0)$.\n   b. Compute eigenvalues for $k=\\pi$. The two lowest eigenvalues are $E_1(\\pi)$ and $E_2(\\pi)$.\n   c. The direct band gap at the zone boundary is calculated as $\\Delta E = E_2(\\pi)-E_1(\\pi)$.\n6. The resulting triple $(E_1(0), E_1(\\pi), \\Delta E)$ is collected for each case, rounded to $6$ decimal places, and formatted as a single flat list.\nThis procedure is implemented in the provided Python code.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the 1D Schrödinger equation for a periodic potential using a plane-wave basis.\n    It computes band energies and gaps for several test cases and formats the output.\n    \"\"\"\n\n    def compute_band_energies(V0, N_max, k):\n        \"\"\"\n        Constructs and diagonalizes the Hamiltonian for a 1D periodic potential.\n\n        The problem is solved in a plane-wave basis truncated to include reciprocal lattice\n        vectors G_n for n from -N_max to +N_max. The units are chosen such that\n        hbar^2/(2m) = 1 and the lattice constant a = 1.\n\n        Args:\n            V0 (float): The amplitude of the cosine potential, V(x) = V0 * cos(2*pi*x).\n            N_max (int): The cutoff for the Fourier expansion, defining the basis size.\n            k (float): The crystal momentum.\n\n        Returns:\n            numpy.ndarray: A sorted array of energy eigenvalues in units of E0 = hbar^2/(2*m*a^2).\n        \"\"\"\n        dim = 2 * N_max + 1\n        # The matrix indices j run from 0 to 2*N_max.\n        # The physical indices n (for G_n) run from -N_max to N_max.\n        # The mapping between them is n = j - N_max.\n        \n        # Initialize the Hamiltonian matrix.\n        H = np.zeros((dim, dim))\n\n        # Under the specified units (a=1), the reciprocal lattice vectors are G_n = 2*pi*n.\n        # The kinetic energy operator is diagonal in this basis.\n        n_indices = np.arange(-N_max, N_max + 1)\n        G_n_array = 2 * np.pi * n_indices\n        diagonal_terms = (k + G_n_array)**2\n        np.fill_diagonal(H, diagonal_terms)\n\n        # The potential V(x) = V0*cos(2*pi*x) has only two non-zero Fourier coefficients,\n        # V_1 = V_{-1} = V0/2. This couples basis states |k+G_n> with |k+G_{n-1}> and |k+G_{n+1}>.\n        # This results in a tridiagonal Hamiltonian matrix.\n        if dim > 1:\n            off_diagonal_val = V0 / 2.0\n            # Populate the super-diagonal (H_{n, n+1})\n            np.fill_diagonal(H[0:, 1:], off_diagonal_val)\n            # Populate the sub-diagonal (H_{n, n-1})\n            np.fill_diagonal(H[1:, 0:], off_diagonal_val)\n        \n        # Diagonalize the Hermitian matrix to find eigenvalues (energies).\n        # eigh returns sorted eigenvalues, which is convenient.\n        eigenvalues = eigh(H, eigvals_only=True)\n        \n        return eigenvalues\n\n    # Test cases defined in the problem statement: (V0, N_max)\n    test_cases = [\n        (0.0, 3),\n        (1.0, 5),\n        (10.0, 9),\n        (-2.0, 7),\n    ]\n\n    results = []\n    \n    # Define k points of interest\n    k_zero = 0.0\n    k_pi = np.pi # Brillouin zone boundary for a=1\n\n    for V0, N_max in test_cases:\n        # 1. Compute the lowest band energy at k=0 (Gamma point)\n        eigenvalues_k0 = compute_band_energies(V0, N_max, k_zero)\n        E1_at_k0 = eigenvalues_k0[0]\n        \n        # 2. Compute eigenvalues at k=pi (Brillouin zone boundary)\n        eigenvalues_k_pi = compute_band_energies(V0, N_max, k_pi)\n        \n        # 3. Extract lowest energy at k=pi\n        E1_at_k_pi = eigenvalues_k_pi[0]\n        \n        # 4. Compute the direct band gap at k=pi\n        E2_at_k_pi = eigenvalues_k_pi[1]\n        gap_at_k_pi = E2_at_k_pi - E1_at_k_pi\n        \n        # Append the triple of results, rounded to 6 decimal places.\n        results.append(round(E1_at_k0, 6))\n        results.append(round(E1_at_k_pi, 6))\n        results.append(round(gap_at_k_pi, 6))\n\n    # Print the final flattened list in the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real materials are three-dimensional, and calculating their properties often requires averaging over all possible electron momenta in the Brillouin zone. This exercise moves to a 3D FCC lattice and introduces the tight-binding model, a complementary approach to the plane-wave method. You will learn to generate a Monkhorst-Pack grid for efficient $k$-space sampling and use time-reversal symmetry to reduce computational cost, two essential techniques in computational materials science .",
            "id": "3435201",
            "problem": "Design and implement a complete program that constructs a Monkhorst–Pack (MP) grid for a Face-Centered Cubic (FCC) lattice, computes valence band energies using a nearest-neighbor tight-binding model, and analyzes the convergence of these energies with respect to mesh density and symmetry reduction. The analysis must be grounded in Bloch’s theorem and the tight-binding framework. The program must be self-contained and produce results for a specified test suite.\n\nBegin from the following fundamental base:\n- Bloch’s theorem: an eigenstate in a periodic potential can be written as $\\psi_{\\mathbf{k}}(\\mathbf{r}) = \\mathrm{e}^{\\mathrm{i} \\mathbf{k}\\cdot \\mathbf{r}} u_{\\mathbf{k}}(\\mathbf{r})$, with $u_{\\mathbf{k}}(\\mathbf{r}+\\mathbf{R}) = u_{\\mathbf{k}}(\\mathbf{r})$ for any direct lattice vector $\\mathbf{R}$.\n- Tight-binding Hamiltonian for a Bravais lattice with one orbital per site and only nearest-neighbor hopping: $H = \\sum_{\\mathbf{R}} \\varepsilon_{s} c_{\\mathbf{R}}^{\\dagger} c_{\\mathbf{R}} + \\sum_{\\langle \\mathbf{R}, \\mathbf{R}' \\rangle} t \\, c_{\\mathbf{R}}^{\\dagger} c_{\\mathbf{R}'}$, where $\\varepsilon_{s}$ is the on-site energy, $t$ is the nearest-neighbor hopping integral, and $\\langle \\cdot, \\cdot \\rangle$ indicates nearest neighbors.\n\nGeometry and reciprocal lattice:\n- Consider an FCC lattice with conventional cubic lattice parameter $a$ and the standard FCC nearest-neighbor geometry. Use the direct-lattice nearest-neighbor displacement vectors $\\mathbf{d}$ of the form $(a/2)\\,(0,\\pm 1,\\pm 1)$, $(a/2)\\,(\\pm 1,0,\\pm 1)$, and $(a/2)\\,(\\pm 1,\\pm 1,0)$, totaling $12$ vectors.\n- Use the primitive reciprocal lattice basis vectors $\\mathbf{b}_{1} = \\frac{2\\pi}{a}(-1,1,1)$, $\\mathbf{b}_{2} = \\frac{2\\pi}{a}(1,-1,1)$, and $\\mathbf{b}_{3} = \\frac{2\\pi}{a}(1,1,-1)$, which satisfy $\\mathbf{a}_{i}\\cdot \\mathbf{b}_{j} = 2\\pi \\delta_{ij}$.\n\nMonkhorst–Pack sampling:\n- Define a Monkhorst–Pack mesh with $N_{1}=N_{2}=N_{3}=N$ points per reciprocal primitive direction, with fractional coordinates $q_{i}(m_{i}) = \\frac{2 m_{i} - N_{i} - 1}{2 N_{i}}$ for $m_{i} \\in \\{1,2,\\ldots,N_{i}\\}$.\n- The crystal momentum points are $\\mathbf{k}(m_{1},m_{2},m_{3}) = q_{1}(m_{1}) \\mathbf{b}_{1} + q_{2}(m_{2}) \\mathbf{b}_{2} + q_{3}(m_{3}) \\mathbf{b}_{3}$.\n\nValence band energy model:\n- Using Bloch’s theorem and the nearest-neighbor tight-binding Hamiltonian for one $s$-orbital per lattice site, derive the band energy $E(\\mathbf{k})$ as a function of $\\mathbf{k}$ and the neighbor vectors $\\mathbf{d}$, the on-site energy $\\varepsilon_{s}$, and the hopping integral $t$. Do not assume any specific shortcut formula; derive directly from the phase factors $\\mathrm{e}^{\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{d}}$ contributed by the $12$ nearest neighbors. The valence band energy at crystal momentum $\\mathbf{k}$ is the single-band tight-binding energy $E(\\mathbf{k})$ in electronvolts.\n\nSymmetry reduction:\n- Implement time-reversal symmetry reduction (a special case of symmetry for non-magnetic, real tight-binding Hamiltonians): $E(\\mathbf{k}) = E(-\\mathbf{k})$. Use this to reduce the MP grid by pairing $\\mathbf{k}$ and $-\\mathbf{k}$ into a single representative with multiplicity $2$, except when $\\mathbf{k} = -\\mathbf{k}$ (e.g., the $\\Gamma$ point), which has multiplicity $1$.\n\nConvergence analysis tasks:\n- For each mesh density $N$, compute the following quantities:\n  1. $E_{\\min}^{\\text{full}}(N)$: the minimum valence band energy over all $\\mathbf{k}$-points in the full MP grid.\n  2. $\\overline{E}^{\\text{full}}(N)$: the simple average of $E(\\mathbf{k})$ over the full MP grid, normalized by the total number of $\\mathbf{k}$-points.\n  3. $E_{\\min}^{\\text{red}}(N)$: the minimum valence band energy over the time-reversal-reduced set of representatives.\n  4. $\\overline{E}^{\\text{red}}(N)$: the weighted average of $E(\\mathbf{k})$ over the reduced set, with weights equal to the multiplicity divided by the total number of $\\mathbf{k}$-points in the full grid.\n  5. $\\Delta \\overline{E}(N) = \\left| \\overline{E}^{\\text{full}}(N) - \\overline{E}^{\\text{red}}(N) \\right|$.\n  6. $r(N)$: the reduction ratio defined as the number of reduced representatives divided by the total number of points in the full grid.\n\nPhysical units:\n- Express all energies in electronvolts (eV). The lattice constant $a$ must be treated in angstroms (Å), and the crystal momentum components are in inverse angstroms so that $\\mathbf{k}\\cdot\\mathbf{d}$ is dimensionless inside trigonometric functions.\n\nTest suite:\n- Use the following physically plausible parameters as the test suite. For each case, the program must produce the six outputs listed above in the stated order.\n  - Case 1 (boundary): $a = 3.600$ Å, $\\varepsilon_{s} = -5.000$ eV, $t = -1.000$ eV, $N = 1$.\n  - Case 2 (even mesh): $a = 3.600$ Å, $\\varepsilon_{s} = -5.000$ eV, $t = -1.000$ eV, $N = 2$.\n  - Case 3 (moderate mesh): $a = 3.600$ Å, $\\varepsilon_{s} = -5.000$ eV, $t = -1.000$ eV, $N = 5$.\n  - Case 4 (denser mesh): $a = 3.600$ Å, $\\varepsilon_{s} = -5.000$ eV, $t = -1.000$ eV, $N = 10$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of six floats in the order $[E_{\\min}^{\\text{full}}, \\overline{E}^{\\text{full}}, E_{\\min}^{\\text{red}}, \\overline{E}^{\\text{red}}, \\Delta \\overline{E}, r]$. For example, the output must look like:\n- \"[[case1_values],[case2_values],[case3_values],[case4_values]]\"\nNo other text should be printed.",
            "solution": "The problem requires the design and implementation of a program to analyze the convergence of tight-binding valence band energies in a Face-Centered Cubic (FCC) lattice with respect to the density of a Monkhorst–Pack (MP) k-point grid. This involves deriving the energy dispersion relation, generating the k-point grid, calculating energies, and applying time-reversal symmetry to reduce the computational cost. The analysis will be performed for a specific test suite.\n\n### Step 1: Derivation of the Tight-Binding Energy Dispersion\n\nThe system is described by a single-orbital, nearest-neighbor tight-binding Hamiltonian on a Bravais lattice:\n$$ H = \\sum_{\\mathbf{R}} \\varepsilon_{s} c_{\\mathbf{R}}^{\\dagger} c_{\\mathbf{R}} + \\sum_{\\langle \\mathbf{R}, \\mathbf{R}' \\rangle} t \\, c_{\\mathbf{R}}^{\\dagger} c_{\\mathbf{R}'} $$\nwhere $\\varepsilon_{s}$ is the on-site energy of the $s$-orbital, $t$ is the hopping integral between nearest-neighbor sites at positions $\\mathbf{R}$ and $\\mathbf{R}'$, and $c_{\\mathbf{R}}^{\\dagger}$ ($c_{\\mathbf{R}}$) are the creation (annihilation) operators for an electron at site $\\mathbf{R}$.\n\nAccording to Bloch's theorem, the eigenstates in a periodic potential can be written as Bloch waves. For a single orbital per unit cell, the trial wavefunction is a Bloch sum of atomic orbitals $\\phi(\\mathbf{r} - \\mathbf{R})$:\n$$ |\\psi_{\\mathbf{k}}\\rangle = \\frac{1}{\\sqrt{N_{\\text{sites}}}} \\sum_{\\mathbf{R}} e^{i\\mathbf{k}\\cdot\\mathbf{R}} |\\mathbf{R}\\rangle $$\nwhere $|\\mathbf{R}\\rangle$ represents the atomic orbital centered at lattice site $\\mathbf{R}$, and $\\mathbf{k}$ is a crystal momentum vector in the first Brillouin zone.\n\nThe energy dispersion $E(\\mathbf{k})$ is the expectation value of the Hamiltonian for this state:\n$$ E(\\mathbf{k}) = \\langle\\psi_{\\mathbf{k}}|H|\\psi_{\\mathbf{k}}\\rangle = \\frac{1}{N_{\\text{sites}}} \\sum_{\\mathbf{R}, \\mathbf{R}'} e^{-i\\mathbf{k}\\cdot\\mathbf{R}} \\langle\\mathbf{R}|H|\\mathbf{R}'\\rangle e^{i\\mathbf{k}\\cdot\\mathbf{R}'} $$\nThe Hamiltonian matrix elements are $\\langle\\mathbf{R}|H|\\mathbf{R}'\\rangle = \\varepsilon_{s}$ if $\\mathbf{R}=\\mathbf{R}'$, $t$ if $\\mathbf{R}$ and $\\mathbf{R}'$ are nearest neighbors, and $0$ otherwise.\nSubstituting these into the energy expression separates the sum into on-site and hopping contributions.\n\nThe on-site term:\n$$ E_{\\text{on-site}} = \\frac{1}{N_{\\text{sites}}} \\sum_{\\mathbf{R}} e^{-i\\mathbf{k}\\cdot\\mathbf{R}} (\\varepsilon_{s}) e^{i\\mathbf{k}\\cdot\\mathbf{R}} = \\frac{1}{N_{\\text{sites}}} \\sum_{\\mathbf{R}} \\varepsilon_{s} = \\varepsilon_{s} $$\n\nThe hopping term involves summing over nearest-neighbor pairs. Let $\\mathbf{R}' = \\mathbf{R} + \\mathbf{d}$, where $\\mathbf{d}$ is one of the nearest-neighbor displacement vectors.\n$$ E_{\\text{hopping}} = \\frac{1}{N_{\\text{sites}}} \\sum_{\\mathbf{R}} \\sum_{\\mathbf{d}} e^{-i\\mathbf{k}\\cdot\\mathbf{R}} (t) e^{i\\mathbf{k}\\cdot(\\mathbf{R}+\\mathbf{d})} = \\frac{1}{N_{\\text{sites}}} \\sum_{\\mathbf{R}} \\sum_{\\mathbf{d}} t \\, e^{i\\mathbf{k}\\cdot\\mathbf{d}} = t \\sum_{\\mathbf{d}} e^{i\\mathbf{k}\\cdot\\mathbf{d}} $$\nThe sum is over all nearest-neighbor vectors $\\mathbf{d}$. Combining the terms, we get the energy dispersion relation:\n$$ E(\\mathbf{k}) = \\varepsilon_{s} + t \\sum_{\\mathbf{d}} e^{i\\mathbf{k}\\cdot\\mathbf{d}} $$\nFor an FCC lattice with conventional lattice parameter $a$, there are $12$ nearest-neighbor vectors of the form $(a/2)(\\pm 1, \\pm 1, 0)$ and its permutations. The set of vectors is symmetric under inversion, i.e., if $\\mathbf{d}$ is a nearest-neighbor vector, so is $-\\mathbf{d}$. This allows us to write the sum of exponentials as a sum of cosines:\n$$ \\sum_{\\mathbf{d}} e^{i\\mathbf{k}\\cdot\\mathbf{d}} = \\sum_{\\mathbf{d}} \\cos(\\mathbf{k}\\cdot\\mathbf{d}) + i \\sum_{\\mathbf{d}} \\sin(\\mathbf{k}\\cdot\\mathbf{d}) = \\sum_{\\mathbf{d}} \\cos(\\mathbf{k}\\cdot\\mathbf{d}) $$\nThe imaginary part vanishes because for each $\\mathbf{d}$, the term $\\sin(\\mathbf{k}\\cdot\\mathbf{d})$ is cancelled by $\\sin(\\mathbf{k}\\cdot(-\\mathbf{d})) = -\\sin(\\mathbf{k}\\cdot\\mathbf{d})$. Let $\\mathbf{k}=(k_x, k_y, k_z)$. The sum evaluates to:\n$$ \\sum_{\\mathbf{d}} e^{i\\mathbf{k}\\cdot\\mathbf{d}} = 4 \\left( \\cos\\left(\\frac{k_x a}{2}\\right)\\cos\\left(\\frac{k_y a}{2}\\right) + \\cos\\left(\\frac{k_y a}{2}\\right)\\cos\\left(\\frac{k_z a}{2}\\right) + \\cos\\left(\\frac{k_z a}{2}\\right)\\cos\\left(\\frac{k_x a}{2}\\right) \\right) $$\nThus, the final expression for the band energy is:\n$$ E(\\mathbf{k}) = \\varepsilon_{s} + 4t \\left( \\cos\\left(\\frac{k_x a}{2}\\right)\\cos\\left(\\frac{k_y a}{2}\\right) + \\cos\\left(\\frac{k_y a}{2}\\right)\\cos\\left(\\frac{k_z a}{2}\\right) + \\cos\\left(\\frac{k_z a}{2}\\right)\\cos\\left(\\frac{k_x a}{2}\\right) \\right) $$\n\n### Step 2: Monkhorst–Pack Grid Generation\n\nThe crystal momentum vectors $\\mathbf{k}$ are sampled on a regular mesh within the first Brillouin zone. The Monkhorst-Pack scheme provides a systematic way to generate this mesh. The specified MP grid is defined by $N_1 = N_2 = N_3 = N$ points along each reciprocal primitive lattice direction. The k-points are given by:\n$$ \\mathbf{k}(m_{1},m_{2},m_{3}) = q_{1}(m_{1}) \\mathbf{b}_{1} + q_{2}(m_{2}) \\mathbf{b}_{2} + q_{3}(m_{3}) \\mathbf{b}_{3} $$\nwhere $m_i \\in \\{1, 2, \\ldots, N\\}$. The fractional coordinates $q_i$ are defined as:\n$$ q_{i}(m_{i}) = \\frac{2 m_{i} - N - 1}{2 N} $$\nThis choice centers the grid at the $\\Gamma$-point $(\\mathbf{k}=\\mathbf{0})$ when $N$ is odd, as for $m_i = (N+1)/2$, $q_i=0$. When $N$ is even, the grid is shifted and does not include $\\Gamma$.\nThe FCC primitive reciprocal lattice vectors are given in Cartesian coordinates as:\n$$ \\mathbf{b}_{1} = \\frac{2\\pi}{a}(-1,1,1), \\quad \\mathbf{b}_{2} = \\frac{2\\pi}{a}(1,-1,1), \\quad \\mathbf{b}_{3} = \\frac{2\\pi}{a}(1,1,-1) $$\nThe Cartesian components $(k_x, k_y, k_z)$ of a k-point are found by linear combination:\n$$ k_x = \\frac{2\\pi}{a}(-q_1 + q_2 + q_3) $$\n$$ k_y = \\frac{2\\pi}{a}(q_1 - q_2 + q_3) $$\n$$ k_z = \\frac{2\\pi}{a}(q_1 + q_2 - q_3) $$\nThe total number of k-points in the full grid is $N^3$.\n\n### Step 3: Symmetry Reduction\n\nFor Hamiltonians that are real in real space and in the absence of a magnetic field, time-reversal symmetry dictates that $E(\\mathbf{k}) = E(-\\mathbf{k})$. The MP grid construction is symmetric such that if $\\mathbf{k}$ is a point on the grid, $-\\mathbf{k}$ is also on the grid. This redundancy can be exploited to reduce the number of k-points for which the energy must be explicitly calculated.\nThe grid is reduced by selecting one representative from each pair $(\\mathbf{k}, -\\mathbf{k})$ where $\\mathbf{k} \\neq -\\mathbf{k}$. Such a representative is assigned a multiplicity (or weight) of $w=2$. Points that are their own inverse, $\\mathbf{k} = -\\mathbf{k}$ (up to a reciprocal lattice vector), are called Time-Reversal Invariant Momenta (TRIMs). In the specified MP scheme, the only TRIM is the $\\Gamma$-point ($\\mathbf{k}=\\mathbf{0}$), which occurs when $N$ is odd. A TRIM has multiplicity $w=1$.\nThe reduction can be implemented by iterating through the grid indices $(m_1, m_2, m_3)$. For each index tuple, its inverse is $(N+1-m_1, N+1-m_2, N+1-m_3)$. We build a reduced set by including only one representative from each pair of index tuples, tracking those already included.\n\n### Step 4: Computational Analysis\n\nFor each test case defined by $(a, \\varepsilon_s, t, N)$, the following quantities are computed:\n\n1.  **Full Grid Calculations**:\n    -   Generate all $N^3$ k-points.\n    -   Calculate $E(\\mathbf{k})$ for each point.\n    -   $E_{\\min}^{\\text{full}}(N)$: The minimum energy found across the entire grid.\n    -   $\\overline{E}^{\\text{full}}(N)$: The simple average of all calculated energies, $\\frac{1}{N^3}\\sum_i E_i$.\n\n2.  **Reduced Grid Calculations**:\n    -   Generate the set of representative k-points and their corresponding multiplicities $\\{w_j\\}$.\n    -   $E_{\\min}^{\\text{red}}(N)$: The minimum energy across the reduced set. Since the set of energy values is identical to the full grid, $E_{\\min}^{\\text{red}}(N) = E_{\\min}^{\\text{full}}(N)$.\n    -   $\\overline{E}^{\\text{red}}(N)$: The weighted average over the reduced set. The problem defines this as $\\sum_{j \\in \\text{red}} E(\\mathbf{k}_j) \\left(\\frac{w_j}{N^3}\\right)$. By construction, this sum is mathematically equivalent to the simple average over the full grid:\n    $$ \\overline{E}^{\\text{red}}(N) = \\frac{1}{N^3} \\sum_{j \\in \\text{red}} w_j E(\\mathbf{k}_j) = \\frac{1}{N^3} \\sum_{i \\in \\text{full}} E(\\mathbf{k}_i) = \\overline{E}^{\\text{full}}(N) $$\n\n3.  **Final Metrics**:\n    -   $\\Delta \\overline{E}(N) = \\left| \\overline{E}^{\\text{full}}(N) - \\overline{E}^{\\text{red}}(N) \\right|$. This should be zero within floating-point precision, serving as a validation of the symmetry reduction implementation.\n    -   $r(N)$: The reduction ratio, defined as the number of points in the reduced set divided by the total number of points in the full grid ($N^3$). For even $N$, $r(N) = 0.5$. For odd $N$, $r(N) = ( (N^3-1)/2 + 1 ) / N^3 = 0.5 + 1/(2N^3)$.\n\nThe implementation proceeds by first defining the geometric and physical parameters. Then, for each test case, it loops through the k-point indices, calculates Cartesian k-vectors, and computes their energies. These energies are aggregated to find the full-grid statistics. Simultaneously or subsequently, the symmetry reduction logic is applied to generate the reduced set and compute its statistics. Finally, the six required quantities are collected and formatted for output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It orchestrates the calculation for each case and formats the final output.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3.600, -5.000, -1.000, 1),\n        (3.600, -5.000, -1.000, 2),\n        (3.600, -5.000, -1.000, 5),\n        (3.600, -5.000, -1.000, 10),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, eps_s, t, N = case\n        case_results = analyze_fcc_tight_binding_grid(a, eps_s, t, N)\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The string representation of a Python list is used for each sub-list.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef analyze_fcc_tight_binding_grid(a, eps_s, t, N):\n    \"\"\"\n    Performs the full analysis for a single FCC tight-binding case.\n\n    Args:\n        a (float): Lattice constant in Angstroms.\n        eps_s (float): On-site energy in eV.\n        t (float): Nearest-neighbor hopping integral in eV.\n        N (int): Monkhorst-Pack grid division number.\n\n    Returns:\n        list: A list of 6 float values corresponding to the analysis tasks.\n    \"\"\"\n    \n    # 1. Define geometry and reciprocal basis vectors\n    b1 = (2 * np.pi / a) * np.array([-1, 1, 1])\n    b2 = (2 * np.pi / a) * np.array([1, -1, 1])\n    b3 = (2 * np.pi / a) * np.array([1, 1, -1])\n\n    # 2. Generate full Monkhorst-Pack grid and compute energies\n    m_indices_1d = np.arange(1, N + 1)\n    \n    full_energies = np.zeros(N**3)\n    \n    # Iterate through all points in the grid using their 1D indices\n    # m1 changes slowest, m3 changes fastest\n    idx = 0\n    for m1 in m_indices_1d:\n        for m2 in m_indices_1d:\n            for m3 in m_indices_1d:\n                q1 = (2 * m1 - N - 1) / (2 * N)\n                q2 = (2 * m2 - N - 1) / (2 * N)\n                q3 = (2 * m3 - N - 1) / (2 * N)\n                \n                k_vec = q1 * b1 + q2 * b2 + q3 * b3\n                kx, ky, kz = k_vec\n                \n                # Energy calculation based on the derived formula\n                cos_term = (np.cos(kx * a / 2) * np.cos(ky * a / 2) +\n                            np.cos(ky * a / 2) * np.cos(kz * a / 2) +\n                            np.cos(kz * a / 2) * np.cos(kx * a / 2))\n                \n                energy = eps_s + 4 * t * cos_term\n                full_energies[idx] = energy\n                idx += 1\n\n    # 3. Calculate full grid quantities\n    E_min_full = np.min(full_energies)\n    E_avg_full = np.mean(full_energies)\n\n    # 4. Perform symmetry reduction and related calculations\n    reduced_indices_tuples = []\n    multiplicities = []\n    seen_indices_tuples = set()\n\n    for m1 in m_indices_1d:\n        for m2 in m_indices_1d:\n            for m3 in m_indices_1d:\n                current_m_idx = (m1, m2, m3)\n                if current_m_idx in seen_indices_tuples:\n                    continue\n\n                inv_m_idx = (N + 1 - m1, N + 1 - m2, N + 1 - m3)\n                \n                reduced_indices_tuples.append(current_m_idx)\n                \n                if current_m_idx == inv_m_idx:\n                    multiplicities.append(1)\n                    seen_indices_tuples.add(current_m_idx)\n                else:\n                    multiplicities.append(2)\n                    seen_indices_tuples.add(current_m_idx)\n                    seen_indices_tuples.add(inv_m_idx)\n\n    # 5. Calculate reduced grid quantities\n    reduced_energies = []\n    for m_idx_tuple in reduced_indices_tuples:\n        m1, m2, m3 = m_idx_tuple\n        # Map 3D index (m1, m2, m3) to 1D index of the energy array\n        linear_idx = (m1 - 1) * N * N + (m2 - 1) * N + (m3 - 1)\n        reduced_energies.append(full_energies[linear_idx])\n    \n    reduced_energies = np.array(reduced_energies)\n    E_min_red = np.min(reduced_energies)\n\n    # Weighted average over the reduced set\n    total_points = N**3\n    weights = np.array(multiplicities)\n    E_avg_red = np.sum(reduced_energies * weights) / total_points\n    \n    # 6. Final analysis quantities\n    delta_E_avg = np.abs(E_avg_full - E_avg_red)\n    reduction_ratio = len(reduced_indices_tuples) / total_points\n    \n    return [\n        round(E_min_full, 12),\n        round(E_avg_full, 12),\n        round(E_min_red, 12),\n        round(E_avg_red, 12),\n        round(delta_E_avg, 12),\n        round(reduction_ratio, 12)\n    ]\n\n# Execute the main function when the script is run.\nsolve()\n```"
        },
        {
            "introduction": "The elegant rules of crystal symmetry can enforce surprising and robust features in the electronic band structure, going beyond simple band gaps. This advanced practice explores the consequences of a non-symmorphic (glide) symmetry, which combines a translation and a point-group operation. By building a tight-binding model that respects this symmetry, you will numerically verify the phenomenon of \"band sticking,\" a protected degeneracy at the Brillouin zone boundary that is a hallmark of certain topological materials .",
            "id": "3435165",
            "problem": "Consider a two-dimensional crystalline lattice with primitive vectors $\\mathbf{a} = (a,0)$ and $\\mathbf{b} = (0,b)$ and two spinless orbitals per unit cell located at positions $\\mathbf{r}_A = (0,0)$ and $\\mathbf{r}_B = (a/2,0)$. Set $a=b=1$ and treat all energies as dimensionless. Assume tight-binding hopping processes are translationally invariant and real, ensuring time-reversal symmetry for spinless particles (time-reversal symmetry squares to $+1$). The crystal possesses a non-symmorphic glide symmetry $G$ given by reflection $y \\mapsto -y$ followed by a half-translation $(a/2,0)$ along $x$. In the Bloch basis $\\{\\lvert A\\rangle, \\lvert B\\rangle\\}$ with even mirror parity orbitals, the symmetry action of $G$ is represented by the unitary matrix $U_G(\\mathbf{k}) = e^{- i k_x a/2}\\, \\sigma_x$, where $\\sigma_x$ is the Pauli matrix acting in the sublattice space and $\\mathbf{k}=(k_x,k_y)$ is the crystal momentum.\n\nStarting only from Bloch’s theorem and the defining symmetry action stated above, construct a minimal $2\\times 2$ Bloch Hamiltonian $H(\\mathbf{k})$ in the sublattice basis that:\n- Respects translational invariance and time-reversal symmetry (real hopping amplitudes).\n- Respects the glide symmetry in the sense that $U_G(\\mathbf{k})\\, H(k_x,k_y)\\, U_G^\\dagger(\\mathbf{k}) = H(k_x,-k_y)$.\n- Is generated by the following physically motivated real-space hopping processes:\n  1. Same-sublattice nearest-neighbor hoppings along $\\pm \\mathbf{a}$ with amplitude $t_x$, and along $\\pm \\mathbf{b}$ with amplitude $t_y$ (identical for $A$ and $B$ as they are related by the glide).\n  2. Inter-sublattice hoppings between $A$ and $B$ along displacements $(\\pm a/2, 0)$ with amplitude $t_1$, and symmetrically along $(\\pm a/2, \\pm b)$ with amplitude $t_2$, and $(\\pm a/2, \\pm 2b)$ with amplitude $t_3$. These sets are included as mirror-symmetric pairs so that the resulting inter-sublattice matrix element is even in $k_y$ and real.\n  3. An allowed glide-symmetric sublattice-odd vertical contribution parameterized by $t_{\\mathrm{odd}}$ that is odd in $k_y$ and multiplies $\\sigma_z$. You may realize this term at the level of the Bloch Hamiltonian directly as a $\\sin(k_y b)$ factor; this is symmetry-allowed and corresponds to a difference between $A$ and $B$ dispersions that flips sign under $k_y \\mapsto -k_y$.\n  4. To test the fragility of the degeneracy, include an explicitly glide-breaking sublattice imbalance term $\\Delta_{\\mathrm{break}}$ proportional to $\\sigma_z$ that is even in $k_y$ (a constant). This violates the glide constraint and is used only as an edge case in the test suite below.\n\nYour model should be written as a Hermitian matrix of the form $H(\\mathbf{k}) = d_0(\\mathbf{k})\\, \\sigma_0 + d_x(\\mathbf{k})\\, \\sigma_x + d_y(\\mathbf{k})\\, \\sigma_y + d_z(\\mathbf{k})\\, \\sigma_z$, where $\\sigma_0$ is the identity and $\\sigma_{x,y,z}$ are Pauli matrices in the $\\{A,B\\}$ basis. Derive the symmetry-imposed parity constraints on $d_\\mu(\\mathbf{k})$ under $k_y \\mapsto -k_y$ that follow from the glide relation, and then, using Bloch’s theorem, obtain the $k$-dependence induced by the specified real-space hoppings. You must not assume any final expressions without derivation.\n\nDemonstrate, using the constructed $H(\\mathbf{k})$, that:\n- The glide representation satisfies $U_G^2(\\mathbf{k}) = e^{- i k_x a}\\, \\sigma_0$. In particular, at the Brillouin-zone boundary $k_x=\\pi/a$, one has $U_G^2 = - \\sigma_0$, and the glide eigenvalues are $\\pm i$.\n- Along the glide-invariant lines $k_y=0$ and $k_y=\\pi/b$, time-reversal symmetry ensures that at the time-reversal invariant momenta $X=(\\pi/a,0)$ and $M=(\\pi/a,\\pi/b)$, bands must stick into degenerate pairs when glide symmetry is preserved, consistent with irreducible representation pairing by complex-conjugate glide eigenvalues $\\pm i$.\n\nYour program must:\n1. Implement the derived $H(\\mathbf{k})$ and $U_G(\\mathbf{k})$ for $a=b=1$.\n2. For each parameter set listed in the test suite below, numerically evaluate the two eigenvalues of $H(\\mathbf{k})$ at the three momenta $X=(\\pi,0)$, $M=(\\pi,\\pi)$, and the non-time-reversal-invariant boundary point $B_{\\mathrm{mid}}=(\\pi,\\pi/2)$. Declare a degeneracy “true” if the absolute difference between the two eigenvalues is less than a tolerance $\\tau = 10^{-8}$, and “false” otherwise.\n3. For each parameter set, compute the Frobenius norm of the commutator $[H(\\mathbf{k}), U_G(\\mathbf{k})]$ at $X=(\\pi,0)$ as a nonnegative real number. This norm must be exactly zero when glide symmetry is preserved and generally nonzero when broken by $\\Delta_{\\mathrm{break}}$.\n4. Aggregate, for each parameter set, a list of four results: the three booleans for degeneracies at $X$, $M$, $B_{\\mathrm{mid}}$, followed by the float equal to the commutator norm at $X$.\n\nTest suite (use $a=b=1$):\n- Case $1$ (generic glide-symmetric with sublattice-odd vertical term present): $\\epsilon = 0$, $t_x=-0.8$, $t_y=-0.6$, $t_1=1.0$, $t_2=0.35$, $t_3=-0.2$, $t_{\\mathrm{odd}}=0.5$, $\\Delta_{\\mathrm{break}}=0$.\n- Case $2$ (glide-symmetric without sublattice-odd term, enforcing full boundary sticking): $\\epsilon = 0$, $t_x=-0.8$, $t_y=-0.6$, $t_1=1.0$, $t_2=0.35$, $t_3=-0.2$, $t_{\\mathrm{odd}}=0$, $\\Delta_{\\mathrm{break}}=0$.\n- Case $3$ (explicit glide-breaking edge case): $\\epsilon = 0$, $t_x=-0.8$, $t_y=-0.6$, $t_1=1.0$, $t_2=0.35$, $t_3=-0.2$, $t_{\\mathrm{odd}}=0.5$, $\\Delta_{\\mathrm{break}}=0.1$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of the three case-results enclosed in square brackets. Each case-result is itself a list in the order $[\\mathrm{degX}, \\mathrm{degM}, \\mathrm{degBmid}, \\mathrm{comm\\_X}]$. For example: $[[\\mathrm{true},\\mathrm{true},\\mathrm{false},0.0],[\\dots],[\\dots]]$. The booleans must be printed in Python’s canonical lowercase spelling, and the float must be printed as a standard decimal numeral. There are no physical units to report because $a=b=1$ and energies are dimensionless by construction.",
            "solution": "The problem requires the construction and analysis of a $2 \\times 2$ tight-binding Bloch Hamiltonian $H(\\mathbf{k})$ for a two-dimensional lattice with a non-symmorphic glide symmetry. The analysis will proceed in several steps: verification of the problem's validity, derivation of the Hamiltonian from symmetry and hopping terms, analysis of the mandatory band degeneracies imposed by the symmetry, and finally a numerical implementation to verify these physical consequences.\n\n### Problem Validation\nThe problem is first subjected to rigorous validation.\n\n**Step 1: Extracted Givens**\n- **Lattice and Basis**: 2D lattice with primitive vectors $\\mathbf{a} = (a,0)$ and $\\mathbf{b} = (0,b)$. Two spinless orbitals per cell at $\\mathbf{r}_A = (0,0)$, $\\mathbf{r}_B = (a/2,0)$.\n- **Constants**: $a=1$, $b=1$. Energies are dimensionless.\n- **Symmetries**: Translational invariance, time-reversal symmetry (TRS) with real hoppings, and a non-symmorphic glide symmetry $G$.\n- **Glide Symmetry Representation**: $G$ is $y \\mapsto -y$ plus translation $(a/2,0)$. Its matrix representation is $U_G(\\mathbf{k}) = e^{- i k_x a/2}\\, \\sigma_x$.\n- **Symmetry Constraint**: $U_G(\\mathbf{k})\\, H(k_x,k_y)\\, U_G^\\dagger(\\mathbf{k}) = H(k_x,-k_y)$.\n- **Hopping Terms for Construction**:\n    1.  Same-sublattice (intra-sublattice) NN hopping: $t_x$ along $\\pm\\mathbf{a}$, $t_y$ along $\\pm\\mathbf{b}$.\n    2.  Inter-sublattice hopping: $t_1$ for displacements $(\\pm a/2, 0)$; $t_2$ for $(\\pm a/2, \\pm b)$; $t_3$ for $(\\pm a/2, \\pm 2b)$.\n    3.  Sublattice-odd term: $t_{\\mathrm{odd}}\\sin(k_y b)\\sigma_z$.\n    4.  Symmetry-breaking term: $\\Delta_{\\mathrm{break}}\\sigma_z$.\n- **Required Derivations**:\n    1.  Demonstrate $U_G^2(\\mathbf{k}) = e^{- i k_x a}\\, \\sigma_0$ and eigenvalues $\\pm i$ at $k_x=\\pi/a$.\n    2.  Explain band sticking at $X=(\\pi/a,0)$ and $M=(\\pi/a,\\pi/b)$.\n- **Numerical Tasks**: For three specified parameter sets, calculate eigenvalues of $H(\\mathbf{k})$ at $X$, $M$, and $B_{\\mathrm{mid}}=(\\pi,\\pi/2)$ to check for degeneracy (tolerance $\\tau = 10^{-8}$), and compute the Frobenius norm of $[H(X), U_G(X)]$.\n\n**Step 2 & 3: Verdict and Action**\nThe problem is **valid**. It is a well-posed, scientifically-grounded problem from theoretical condensed matter physics. It is self-contained, with all necessary parameters and definitions provided. The tasks involve standard, albeit non-trivial, derivations and numerical verifications common in the field. There are no contradictions, ambiguities, or factual inaccuracies. The solution process may therefore proceed.\n\n### Theoretical Derivation\nWe will set $a=1$ and $b=1$ for the derivation.\n\n**1. Glide Symmetry Constraints on $H(\\mathbf{k})$**\nThe Hamiltonian is expressed in the Pauli matrix basis: $H(\\mathbf{k}) = d_0(\\mathbf{k})\\sigma_0 + d_x(\\mathbf{k})\\sigma_x + d_y(\\mathbf{k})\\sigma_y + d_z(\\mathbf{k})\\sigma_z$. The glide symmetry constraint is $U_G(\\mathbf{k})H(\\mathbf{k})U_G^\\dagger(\\mathbf{k}) = H(k_x, -k_y)$.\nSubstituting $U_G(\\mathbf{k}) = e^{-i k_x/2}\\sigma_x$ and $U_G^\\dagger(\\mathbf{k}) = \\sigma_x e^{i k_x/2}$:\n$$ e^{-i k_x/2}\\sigma_x \\left( \\sum_{\\mu=0,x,y,z} d_\\mu(k_x, k_y) \\sigma_\\mu \\right) \\sigma_x e^{i k_x/2} = \\sum_{\\mu=0,x,y,z} d_\\mu(k_x, -k_y) \\sigma_\\mu $$\n$$ \\sigma_x H(k_x, k_y) \\sigma_x = H(k_x, -k_y) $$\nUsing Pauli algebra identities $\\sigma_x \\sigma_0 \\sigma_x = \\sigma_0$, $\\sigma_x \\sigma_x \\sigma_x = \\sigma_x$, $\\sigma_x \\sigma_y \\sigma_x = -\\sigma_y$, and $\\sigma_x \\sigma_z \\sigma_x = -\\sigma_z$, we find:\n$$ d_0(k_x,k_y)\\sigma_0 + d_x(k_x,k_y)\\sigma_x - d_y(k_x,k_y)\\sigma_y - d_z(k_x,k_y)\\sigma_z = d_0(k_x,-k_y)\\sigma_0 + d_x(k_x,-k_y)\\sigma_x + d_y(k_x,-k_y)\\sigma_y + d_z(k_x,-k_y)\\sigma_z $$\nComparing coefficients of the Pauli matrices yields the parity constraints under the transformation $k_y \\mapsto -k_y$:\n- $d_0$ must be an even function of $k_y$.\n- $d_x$ must be an even function of $k_y$.\n- $d_y$ must be an odd function of $k_y$.\n- $d_z$ must be an odd function of $k_y$.\n\n**2. Construction of the Bloch Hamiltonian**\nThe matrix elements of the Bloch Hamiltonian are the lattice Fourier transforms of the real-space hopping integrals $t(\\vec{\\delta})$ over all displacement vectors $\\vec{\\delta}$. For a two-component basis $\\{A, B\\}$, the Hamiltonian is a $2\\times 2$ matrix $H(\\mathbf{k}) = \\begin{pmatrix} H_{AA}(\\mathbf{k}) & H_{AB}(\\mathbf{k}) \\\\ H_{BA}(\\mathbf{k}) & H_{BB}(\\mathbf{k}) \\end{pmatrix}$. With real hopping amplitudes, Hermiticity implies $H_{BA}(\\mathbf{k}) = H_{AB}^*(\\mathbf{k})$. The decomposition is $H_{AA} = d_0+d_z$, $H_{BB} = d_0-d_z$, and $H_{AB} = d_x-id_y$.\n\n- **Intra-sublattice terms ($H_{AA}$, $H_{BB}$)**: Hoppings connect sites of the same type. The problem states these are identical for $A$ and $B$, which means these terms contribute only to $d_0$.\n  The displacement vectors are $\\pm\\mathbf{a}=(\\pm 1, 0)$ and $\\pm\\mathbf{b}=(0, \\pm 1)$.\n  $$ H_{AA}(\\mathbf{k}) = H_{BB}(\\mathbf{k}) = t_x(e^{i k_x} + e^{-i k_x}) + t_y(e^{i k_y} + e^{-i k_y}) = 2t_x\\cos(k_x) + 2t_y\\cos(k_y) $$\n  This contributes to $d_0$. The parameter $\\epsilon$ from the test suite, if interpreted as an overall energy shift, would add to $d_0$. Since $\\epsilon=0$, we ignore it. Thus, $d_0(\\mathbf{k}) = 2t_x\\cos(k_x) + 2t_y\\cos(k_y)$. This is even in $k_y$, as required.\n\n- **Inter-sublattice terms ($H_{AB}$)**: Hoppings connect $A$ and $B$ sites. $H_{AB}(\\mathbf{k}) = \\sum_{\\vec{\\delta}_{AB}} t(\\vec{\\delta}_{AB}) e^{i\\mathbf{k}\\cdot\\vec{\\delta}_{AB}}$.\n  1.  Hoppings with amplitude $t_1$ over displacements $(\\pm 1/2, 0)$: $t_1(e^{i k_x/2} + e^{-i k_x/2}) = 2t_1\\cos(k_x/2)$.\n  2.  Hoppings with amplitude $t_2$ over $(\\pm 1/2, \\pm 1)$: $t_2 \\sum_{\\sigma_x, \\sigma_y = \\pm 1} e^{i(\\sigma_x k_x/2 + \\sigma_y k_y)} = 4t_2\\cos(k_x/2)\\cos(k_y)$.\n  3.  Hoppings with amplitude $t_3$ over $(\\pm 1/2, \\pm 2)$: $4t_3\\cos(k_x/2)\\cos(2k_y)$.\n  Combining these, we get:\n  $$ H_{AB}(\\mathbf{k}) = 2\\cos(k_x/2) \\left( t_1 + 2t_2\\cos(k_y) + 2t_3\\cos(2k_y) \\right) $$\n  Since all hopping amplitudes are real, $H_{AB}(\\mathbf{k})$ is real. Hermiticity requires $H_{BA}(\\mathbf{k}) = H_{AB}(\\mathbf{k})$. This means $d_x = H_{AB}$ and $d_y = 0$. Both $d_x$ (even in $k_y$) and $d_y$ (trivially odd in $k_y$) satisfy the symmetry constraints.\n\n- **Sublattice-odd and breaking terms**: These contribute to $d_z$.\n  The problem specifies a term $t_{\\mathrm{odd}}\\sin(k_y)\\sigma_z$ and a breaking term $\\Delta_{\\mathrm{break}}\\sigma_z$.\n  So, $d_z(\\mathbf{k}) = t_{\\mathrm{odd}}\\sin(k_y) + \\Delta_{\\mathrm{break}}$.\n  For the glide-symmetric case ($\\Delta_{\\mathrm{break}}=0$), $d_z(\\mathbf{k}) = t_{\\mathrm{odd}}\\sin(k_y)$ is odd in $k_y$, satisfying the constraint. The constant term $\\Delta_{\\mathrm{break}}$ is even and explicitly breaks the glide symmetry.\n\n- **Final Hamiltonian**:\n  $H(\\mathbf{k}) = d_0(\\mathbf{k})\\sigma_0 + d_x(\\mathbf{k})\\sigma_x + d_z(\\mathbf{k})\\sigma_z$, with\n  $d_0(\\mathbf{k}) = 2t_x\\cos(k_x) + 2t_y\\cos(k_y)$\n  $d_x(\\mathbf{k}) = 2\\cos(k_x/2) \\left( t_1 + 2t_2\\cos(k_y) + 2t_3\\cos(2k_y) \\right)$\n  $d_z(\\mathbf{k}) = t_{\\mathrm{odd}}\\sin(k_y) + \\Delta_{\\mathrm{break}}$\n\n**3. Symmetry-Protected Degeneracy**\n- **Glide Operator Properties**: $U_G(\\mathbf{k}) = e^{-ik_x/2}\\sigma_x$. Squaring this operator gives:\n  $$ U_G^2(\\mathbf{k}) = (e^{-ik_x/2}\\sigma_x)^2 = e^{-ik_x}\\sigma_x^2 = e^{-ik_x}\\sigma_0 $$\n  At the Brillouin zone boundary $k_x=\\pi$, this becomes $U_G^2(\\pi,k_y) = e^{-i\\pi}\\sigma_0 = -\\sigma_0$. The eigenvalues $\\lambda_G$ of $U_G(\\pi,k_y)$ must then satisfy $\\lambda_G^2 = -1$, which means $\\lambda_G = \\pm i$.\n\n- **Band Sticking at $X$ and $M$**: The eigenvalues of the Hamiltonian are $E_{\\pm}(\\mathbf{k}) = d_0(\\mathbf{k}) \\pm \\sqrt{d_x(\\mathbf{k})^2 + d_y(\\mathbf{k})^2 + d_z(\\mathbf{k})^2}$. With $d_y=0$, $E_{\\pm}(\\mathbf{k}) = d_0(\\mathbf{k}) \\pm \\sqrt{d_x(\\mathbf{k})^2 + d_z(\\mathbf{k})^2}$. Degeneracy occurs if and only if the radical vanishes, meaning $d_x(\\mathbf{k})=0$ and $d_z(\\mathbf{k})=0$.\n\n  Let's analyze the behavior on the line $k_x = \\pi$:\n  $d_x(\\pi, k_y) = 2\\cos(\\pi/2)(\\dots) = 0$. Thus, $d_x$ is identically zero along this entire line.\n  $d_z(\\pi, k_y) = t_{\\mathrm{odd}}\\sin(k_y) + \\Delta_{\\mathrm{break}}$.\n  \n  In the glide-symmetric case ($\\Delta_{\\mathrm{break}}=0$), degeneracy requires $d_z = t_{\\mathrm{odd}}\\sin(k_y) = 0$. This condition is met at the high-symmetry momenta $k_y=0$ (point $X(\\pi,0)$) and $k_y=\\pi$ (point $M(\\pi,\\pi)$). Therefore, the bands must be degenerate at $X$ and $M$. This phenomenon, where bands are forced to be degenerate at specific high-symmetry points due to non-symmorphic symmetries and time reversal, is known as band sticking. The degeneracy at a generic point on the line, such as $B_{\\mathrm{mid}}(\\pi, \\pi/2)$, is lifted if $t_{\\mathrm{odd}}\\neq 0$. If $t_{\\mathrm{odd}}=0$, the bands are degenerate along the entire $k_x=\\pi$ line.\n\n**4. Commutator Calculation**\nWe compute the commutator $C = [H(\\mathbf{k}), U_G(\\mathbf{k})]$ at the point $X=(\\pi,0)$.\nAt $X$, $U_G(X) = e^{-i\\pi/2}\\sigma_x = -i\\sigma_x$.\nThe Hamiltonian coefficients are:\n$d_0(X) = 2t_x\\cos(\\pi) + 2t_y\\cos(0) = -2t_x + 2t_y$.\n$d_x(X) = 0$.\n$d_z(X) = t_{\\mathrm{odd}}\\sin(0) + \\Delta_{\\mathrm{break}} = \\Delta_{\\mathrm{break}}$.\nSo, $H(X) = (-2t_x + 2t_y)\\sigma_0 + \\Delta_{\\mathrm{break}}\\sigma_z$.\n$$ C = [H(X), U_G(X)] = [(-2t_x + 2t_y)\\sigma_0 + \\Delta_{\\mathrm{break}}\\sigma_z, -i\\sigma_x] = -i\\Delta_{\\mathrm{break}}[\\sigma_z, \\sigma_x] $$\nUsing $[\\sigma_z, \\sigma_x] = 2i\\sigma_y$:\n$$ C = -i\\Delta_{\\mathrm{break}}(2i\\sigma_y) = 2\\Delta_{\\mathrm{break}}\\sigma_y = \\begin{pmatrix} 0 & -2i\\Delta_{\\mathrm{break}} \\\\ 2i\\Delta_{\\mathrm{break}} & 0 \\end{pmatrix} $$\nThe Frobenius norm is $\\|C\\|_F = \\sqrt{\\mathrm{Tr}(C^\\dagger C)} = \\sqrt{|-2i\\Delta_{\\mathrm{break}}|^2 + |2i\\Delta_{\\mathrm{break}}|^2} = \\sqrt{4\\Delta_{\\mathrm{break}}^2 + 4\\Delta_{\\mathrm{break}}^2} = \\sqrt{8\\Delta_{\\mathrm{break}}^2} = 2\\sqrt{2}|\\Delta_{\\mathrm{break}}|$. This norm is zero if and only if $\\Delta_{\\mathrm{break}}=0$, confirming that this parameter breaks the glide symmetry.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes a tight-binding Hamiltonian for a 2D lattice\n    with non-symmorphic glide symmetry, checking for symmetry-protected\n    degeneracies and symmetry breaking.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Generic glide-symmetric case\n        {'epsilon': 0, 'tx':-0.8, 'ty':-0.6, 't1':1.0, 't2':0.35, 't3':-0.2, 't_odd':0.5, 'delta_break':0.0},\n        # Case 2: Glide-symmetric with t_odd=0, leading to full boundary sticking\n        {'epsilon': 0, 'tx':-0.8, 'ty':-0.6, 't1':1.0, 't2':0.35, 't3':-0.2, 't_odd':0.0, 'delta_break':0.0},\n        # Case 3: Explicit glide-breaking case\n        {'epsilon': 0, 'tx':-0.8, 'ty':-0.6, 't1':1.0, 't2':0.35, 't3':-0.2, 't_odd':0.5, 'delta_break':0.1},\n    ]\n\n    def build_hamiltonian(k, params):\n        \"\"\"Constructs the 2x2 Bloch Hamiltonian H(k).\"\"\"\n        kx, ky = k\n        a, b = 1.0, 1.0 # Set lattice constants to 1\n        \n        # Unpack parameters\n        tx = params['tx']\n        ty = params['ty']\n        t1 = params['t1']\n        t2 = params['t2']\n        t3 = params['t3']\n        t_odd = params['t_odd']\n        delta_break = params['delta_break']\n\n        # Pauli matrices\n        sigma0 = np.array([[1, 0], [0, 1]], dtype=complex)\n        sigmax = np.array([[0, 1], [1, 0]], dtype=complex)\n        sigmaz = np.array([[1, 0], [0, -1]], dtype=complex)\n\n        # Calculate coefficients d_mu(k)\n        d0 = 2 * tx * np.cos(kx * a) + 2 * ty * np.cos(ky * b)\n        dx = 2 * np.cos(kx * a / 2.0) * (t1 + 2 * t2 * np.cos(ky * b) + 2 * t3 * np.cos(2 * ky * b))\n        # dy is zero for this model\n        dz = t_odd * np.sin(ky * b) + delta_break\n\n        H = d0 * sigma0 + dx * sigmax + dz * sigmaz\n        return H\n\n    def build_glide_op(k):\n        \"\"\"Constructs the 2x2 glide symmetry operator U_G(k).\"\"\"\n        kx, _ = k\n        a = 1.0\n        sigmax = np.array([[0, 1], [1, 0]], dtype=complex)\n        Ug = np.exp(-1j * kx * a / 2.0) * sigmax\n        return Ug\n\n    results = []\n    tolerance = 1e-8\n    \n    # Define high-symmetry momenta\n    k_X = (np.pi, 0.0)\n    k_M = (np.pi, np.pi)\n    k_Bmid = (np.pi, np.pi / 2.0)\n    momenta = [k_X, k_M, k_Bmid]\n\n    for params in test_cases:\n        case_results = []\n        \n        # 1. Check for degeneracies at X, M, B_mid\n        for k in momenta:\n            H = build_hamiltonian(k, params)\n            eigvals = np.linalg.eigvalsh(H)\n            is_degenerate = np.abs(eigvals[0] - eigvals[1])  tolerance\n            case_results.append(is_degenerate)\n            \n        # 2. Compute the Frobenius norm of the commutator [H(X), U_G(X)]\n        H_X = build_hamiltonian(k_X, params)\n        Ug_X = build_glide_op(k_X)\n        commutator = H_X @ Ug_X - Ug_X @ H_X\n        comm_norm = np.linalg.norm(commutator, 'fro')\n        case_results.append(comm_norm)\n        \n        results.append(case_results)\n\n    # Format the final output string as per the requirements\n    def format_case_result(res_list):\n        # [bool, bool, bool, float] -> \"[true,true,false,0.0]\"\n        bool_strs = [str(b).lower() for b in res_list[:3]]\n        float_str = str(res_list[3])\n        return f\"[{','.join(bool_strs)},{float_str}]\"\n\n    final_output_str = f\"[{','.join(map(format_case_result, results))}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}