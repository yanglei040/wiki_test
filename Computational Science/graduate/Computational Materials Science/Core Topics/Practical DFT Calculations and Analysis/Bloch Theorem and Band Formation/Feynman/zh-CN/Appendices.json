{
    "hands_on_practices": [
        {
            "introduction": "理论学习的最佳补充是动手实践。本节将指导你从第一性原理出发，将布洛赫定理应用于一个具体模型。通过在一个简单的周期性余弦势中求解薛定谔方程，你将亲手构建一个平面波基组下的哈密顿量矩阵，并通过对其进行对角化来计算能带结构。这个练习是理解电子能带理论如何转化为计算代码的基石。",
            "id": "3435150",
            "problem": "给定一个在一维标量周期势中运动的电子，其晶格常数为 $a$，由稳态薛定谔方程描述：\n$$\n\\left[-\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x)\\right]\\psi_{k}(x) = E(k)\\,\\psi_{k}(x),\n$$\n其中 $V(x)$ 满足 $V(x+a)=V(x)$。根据布洛赫定理，任何本征函数都可以写成 $\\psi_k(x) = e^{ikx}u_k(x)$ 的形式，其中 $u_k(x+a)=u_k(x)$。考虑特定势 $V(x)=V_0\\cos\\!\\left(\\frac{2\\pi}{a}x\\right)$，并通过将 $u_k(x)$ 展开为傅里叶模式来数值构造 $\\psi_k(x)$。你的任务是：从第一性原理推导一个算法，该算法在一个被截断为有限数量倒易晶格矢量的平面波基中构建并对角化哈密顿量，并用它来提取选定晶体动量下的能带能量。\n\n使用的基本原理：\n- 一维单粒子不含时薛定谔方程。\n- 布洛赫定理的陈述以及 $u_k(x)$ 的周期性。\n- 周期为 $a$ 的周期函数的傅里叶级数定义，以及对于整数 $n$ 的倒易晶格矢量集合 $G_n = \\frac{2\\pi}{a}n$。\n\n构造要求：\n- 从 $\\psi_k(x)=e^{ikx}u_k(x)$ 开始，其中 $u_k(x)=\\sum_{n=-N_{\\text{max}}}^{N_{\\text{max}}} c_n\\,e^{i G_n x}$，$G_n=\\frac{2\\pi}{a}n$，并且 $N_{\\text{max}}$ 是一个有限的截断值。\n- 将该展开式代入薛定谔方程，以获得在固定 $k$ 值下关于系数 $c_n$ 的有限维厄米矩阵本征问题。\n- 明确使用 $V(x)=V_0\\cos\\!\\left(\\frac{2\\pi}{a}x\\right)$ 的傅里叶系数来确定哪些矩阵元非零。\n- 使用能量单位 $E_0=\\frac{\\hbar^2}{2ma^2}$ 进行计算，并以 $E_0$ 为单位将所有能量报告为无量纲数。为了进行数值计算，设置 $a=1$ 和 $\\frac{\\hbar^2}{2m}=1$，因此 $G_0=2\\pi$ 且 $E_0=1$。\n- 使用晶体动量值 $k\\in\\{0, \\pi/2, \\pi\\}$，角度以弧度为单位。\n\n你的程序必须：\n- 对于给定的 $(V_0,N_{\\text{max}})$ 和晶体动量 $k$，实现所述的平面波哈密顿量构建和对角化。\n- 对于每个指定的参数集，计算：\n  1. $k=0$ 时的最低能带能量。\n  2. $k=\\pi$ 时的最低能带能量。\n  3. 布里渊区边界 $k=\\pi$ 处的直接带隙，定义为 $E_2(\\pi)-E_1(\\pi)$，其中 $E_1(\\pi)\\le E_2(\\pi)\\le\\cdots$ 是 $k=\\pi$ 处的升序排列的本征值。\n\n物理单位和报告：\n- 所有能量必须以 $E_0=\\frac{\\hbar^2}{2ma^2}$ 为单位报告，作为无量纲浮点数。角度以弧度为单位。\n\n测试套件：\n- 使用 $a=1$ 和以下参数集 $(V_0,N_{\\text{max}})$：\n  - 情况 1：$(V_0,N_{\\text{max}})=(0,3)$。\n  - 情况 2：$(V_0,N_{\\text{max}})=(1,5)$。\n  - 情况 3：$(V_0,N_{\\text{max}})=(10,9)$。\n  - 情况 4：$(V_0,N_{\\text{max}})=(-2,7)$。\n\n最终输出格式：\n- 对于每种情况，计算三元组 $\\big(E_1(0),\\,E_1(\\pi),\\,E_2(\\pi)-E_1(\\pi)\\big)$，并将每个浮点数使用标准四舍五入到6位小数。\n- 你的程序应生成单行输出，其中包含所有四种情况的结果，按顺序连接并展平为一个列表，形式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,\\dots,r_{12}]$，总共包含12个浮点数。",
            "solution": "用户提供的问题经评估为有效，因为它代表了固态物理导论中的一个标准的、良构的问题，没有科学或逻辑上的缺陷。我们现在将提供一个完整的解决方案。\n\n目标是求解一维周期势 $V(x) = V_0\\cos\\!\\left(\\frac{2\\pi}{a}x\\right)$ 中电子的不含时薛定谔方程。该方程为：\n$$\n\\left[-\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x)\\right]\\psi_{k}(x) = E(k)\\,\\psi_{k}(x)\n$$\n其中 $V(x) = V(x+a)$。根据布洛赫定理，本征函数 $\\psi_k(x)$ 可以表示为 $\\psi_k(x) = e^{ikx}u_k(x)$ 的形式，其中 $u_k(x)$ 具有与晶格相同的周期性，$u_k(x+a) = u_k(x)$。晶体动量 $k$ 是一个好量子数。\n\n将布洛赫形式代入薛定谔方程，我们推导出关于周期函数 $u_k(x)$ 的方程。$\\psi_k(x)$ 的导数是：\n$$\n\\frac{d\\psi_k}{dx} = e^{ikx}\\left(ik + \\frac{d}{dx}\\right)u_k(x)\n$$\n$$\n\\frac{d^2\\psi_k}{dx^2} = e^{ikx}\\left(ik + \\frac{d}{dx}\\right)^2 u_k(x) = e^{ikx}\\left(-\\!k^2 + 2ik\\frac{d}{dx} + \\frac{d^2}{dx^2}\\right)u_k(x)\n$$\n将此代入薛定谔方程并消去公因子 $e^{ikx}$，得到 $u_k(x)$ 的本征值方程：\n$$\n\\left[\\frac{\\hbar^2}{2m}\\left(-k^2 + 2ik\\frac{d}{dx} + \\frac{d^2}{dx^2}\\right)\\!\\!(-1) + V(x)\\right]u_k(x) = E(k)u_k(x)\n$$\n$$\n\\left[\\frac{\\hbar^2}{2m}\\left(k - i\\frac{d}{dx}\\right)^2 + V(x)\\right]u_k(x) = E(k)u_k(x)\n$$\n由于 $u_k(x)$ 是周期为 $a$ 的周期函数，它可以展开为关于倒易晶格矢量 $G_n = \\frac{2\\pi}{a}n$（其中 $n$ 为整数）的傅里叶级数：\n$$\nu_k(x) = \\sum_{n} c_n e^{iG_n x}\n$$\n问题指定了一个在 $n = \\pm N_{\\text{max}}$ 处截断的有限基组。\n$$\nu_k(x) = \\sum_{n=-N_{\\text{max}}}^{N_{\\text{max}}} c_n e^{iG_n x}\n$$\n类似地，周期势 $V(x)$ 也可展开为傅里叶级数：\n$$\nV(x) = \\sum_{p} V_p e^{iG_p x}\n$$\n对于特定势 $V(x) = V_0\\cos\\!\\left(\\frac{2\\pi}{a}x\\right)$，我们可以使用欧拉公式：\n$$\nV(x) = \\frac{V_0}{2}\\left(e^{i\\frac{2\\pi}{a}x} + e^{-i\\frac{2\\pi}{a}x}\\right) = \\frac{V_0}{2}\\left(e^{iG_1 x} + e^{iG_{-1} x}\\right)\n$$\n由此，我们确定势的非零傅里叶系数为：$V_1 = V_{-1} = \\frac{V_0}{2}$。所有其他系数 $V_p$ 均为零，包括平均势 $V_0_d = 0$。\n\n将 $u_k(x)$ 和 $V(x)$ 的傅里叶展开式代入 $u_k(x)$ 的方程中：\n$$\n\\left[\\frac{\\hbar^2}{2m}\\left(k - i\\frac{d}{dx}\\right)^2 + \\sum_p V_p e^{iG_p x}\\right] \\sum_n c_n e^{iG_n x} = E(k) \\sum_n c_n e^{iG_n x}\n$$\n微分算子作用于每个基函数 $e^{iG_n x}$ 的结果如下：\n$$\n\\left(k - i\\frac{d}{dx}\\right)e^{iG_n x} = (k+G_n)e^{iG_n x}\n$$\n$$\n\\left(k - i\\frac{d}{dx}\\right)^2 e^{iG_n x} = (k+G_n)^2 e^{iG_n x}\n$$\n方程变为：\n$$\n\\sum_n \\frac{\\hbar^2}{2m}(k+G_n)^2 c_n e^{iG_n x} + \\left(\\sum_p V_p e^{iG_p x}\\right)\\left(\\sum_n c_n e^{iG_n x}\\right) = E(k) \\sum_n c_n e^{iG_n x}\n$$\n这两个级数的乘积在系数空间中是一个卷积：\n$$\n\\sum_n \\frac{\\hbar^2}{2m}(k+G_n)^2 c_n e^{iG_n x} + \\sum_{n,p} V_p c_n e^{i(G_n+G_p)x} = E(k) \\sum_n c_n e^{iG_n x}\n$$\n为了得到矩阵方程，我们投影到基函数 $e^{-iG_m x}$ 上，并在一个晶胞内（从 $x=0$ 到 $x=a$）积分，再乘以 $1/a$。利用正交关系 $\\frac{1}{a}\\int_0^a e^{iG_j x} e^{-iG_m x} dx = \\delta_{jm}$，我们得到每个系数 $c_m$ 的方程：\n$$\n\\frac{\\hbar^2}{2m}(k+G_m)^2 c_m + \\sum_{n,p} V_p c_n \\delta_{m, n+p} = E(k)c_m\n$$\n克罗内克δ函数 $\\delta_{m, n+p}$ 强制要求条件 $m=n+p$ 成立，这意味着 $n=m-p$。对 $n$ 和 $p$ 的求和简化为对 $p$ 的单个求和。\n$$\n\\frac{\\hbar^2}{2m}(k+G_m)^2 c_m + \\sum_p V_p c_{m-p} = E(k)c_m\n$$\n这就是矩阵形式的中心方程，$H \\mathbf{c} = E \\mathbf{c}$，其中 $\\mathbf{c}$ 是系数矢量 $(c_n)$。矩阵元 $H_{mn}$ 由下式给出：\n$$\nH_{mn} = \\frac{\\hbar^2}{2m}(k+G_m)^2 \\delta_{mn} + V_{m-n}\n$$\n对于我们的特定势，$V_{m-n}$ 仅在 $m-n = \\pm 1$ 时非零，其中 $V_1 = V_{-1} = V_0/2$。这导致在由 $n$ 索引的倒易晶格矢量基中，哈密顿矩阵是一个三对角矩阵。\n\\begin{itemize}\n    \\item 对角元 ($m=n$)：$H_{mm} = \\frac{\\hbar^2}{2m}(k+G_m)^2$\n    \\item 非对角元 ($m=n \\pm 1$)：$H_{m,m-1} = V_{1} = V_0/2$ 和 $H_{m,m+1} = V_{-1} = V_0/2$\n\\end{itemize}\n问题指定在 $a=1$ 和 $\\frac{\\hbar^2}{2m}=1$ 的单位制下进行计算。因此，所有能量都以 $E_0 = \\frac{\\hbar^2}{2ma^2}=1$ 为单位。在这些单位中，倒易晶格矢量为 $G_n = 2\\pi n$，哈密顿矩阵元为：\n$$\nH_{mn} = (k+2\\pi m)^2 \\delta_{mn} + \\frac{V_0}{2}(\\delta_{m,n+1} + \\delta_{m,n-1})\n$$\n求解算法如下：\n1. 对于给定的参数集 $(V_0, N_{\\text{max}})$ 和晶体动量 $k$，构建哈密顿矩阵 $H$。索引 $m,n$ 的范围是从 $-N_{\\text{max}}$ 到 $N_{\\text{max}}$，因此矩阵大小为 $(2N_{\\text{max}}+1) \\times (2N_{\\text{max}}+1)$。\n2. 通过将对角元设置为 $(k+2\\pi m)^2$ 以及将上对角元和下对角元设置为 $V_0/2$ 来填充矩阵。\n3. 使用数值线性代数程序对这个实对称（因此是厄米）矩阵进行对角化。我们使用 `scipy.linalg.eigh`，它针对厄米矩阵进行了优化，并返回排序后的实数本征值。\n4. $H$ 的本征值即为能带能量 $E_n(k)$。\n5. 对于每个测试用例 $(V_0, N_{\\text{max}})$：\n   a. 计算 $k=0$ 时的本征值。最低的本征值是 $E_1(0)$。\n   b. 计算 $k=\\pi$ 时的本征值。两个最低的本征值是 $E_1(\\pi)$ 和 $E_2(\\pi)$。\n   c. 区域边界处的直接带隙计算为 $\\Delta E = E_2(\\pi)-E_1(\\pi)$。\n6. 对每种情况，收集得到的三元组 $(E_1(0), E_1(\\pi), \\Delta E)$，四舍五入到6位小数，并格式化为单个扁平列表。\n这个过程在提供的Python代码中实现。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the 1D Schrödinger equation for a periodic potential using a plane-wave basis.\n    It computes band energies and gaps for several test cases and formats the output.\n    \"\"\"\n\n    def compute_band_energies(V0, N_max, k):\n        \"\"\"\n        Constructs and diagonalizes the Hamiltonian for a 1D periodic potential.\n\n        The problem is solved in a plane-wave basis truncated to include reciprocal lattice\n        vectors G_n for n from -N_max to +N_max. The units are chosen such that\n        hbar^2/(2m) = 1 and the lattice constant a = 1.\n\n        Args:\n            V0 (float): The amplitude of the cosine potential, V(x) = V0 * cos(2*pi*x).\n            N_max (int): The cutoff for the Fourier expansion, defining the basis size.\n            k (float): The crystal momentum.\n\n        Returns:\n            numpy.ndarray: A sorted array of energy eigenvalues in units of E0 = hbar^2/(2*m*a^2).\n        \"\"\"\n        dim = 2 * N_max + 1\n        # The matrix indices j run from 0 to 2*N_max.\n        # The physical indices n (for G_n) run from -N_max to N_max.\n        # The mapping between them is n = j - N_max.\n        \n        # Initialize the Hamiltonian matrix.\n        H = np.zeros((dim, dim))\n\n        # Under the specified units (a=1), the reciprocal lattice vectors are G_n = 2*pi*n.\n        # The kinetic energy operator is diagonal in this basis.\n        n_indices = np.arange(-N_max, N_max + 1)\n        G_n_array = 2 * np.pi * n_indices\n        diagonal_terms = (k + G_n_array)**2\n        np.fill_diagonal(H, diagonal_terms)\n\n        # The potential V(x) = V0*cos(2*pi*x) has only two non-zero Fourier coefficients,\n        # V_1 = V_{-1} = V0/2. This couples basis states |k+G_n> with |k+G_{n-1}> and |k+G_{n+1}>.\n        # This results in a tridiagonal Hamiltonian matrix.\n        if dim > 1:\n            off_diagonal_val = V0 / 2.0\n            # Populate the super-diagonal (H_{n, n+1})\n            np.fill_diagonal(H[0:, 1:], off_diagonal_val)\n            # Populate the sub-diagonal (H_{n, n-1})\n            np.fill_diagonal(H[1:, 0:], off_diagonal_val)\n        \n        # Diagonalize the Hermitian matrix to find eigenvalues (energies).\n        # eigh returns sorted eigenvalues, which is convenient.\n        eigenvalues = eigh(H, eigvals_only=True)\n        \n        return eigenvalues\n\n    # Test cases defined in the problem statement: (V0, N_max)\n    test_cases = [\n        (0.0, 3),\n        (1.0, 5),\n        (10.0, 9),\n        (-2.0, 7),\n    ]\n\n    results = []\n    \n    # Define k points of interest\n    k_zero = 0.0\n    k_pi = np.pi # Brillouin zone boundary for a=1\n\n    for V0, N_max in test_cases:\n        # 1. Compute the lowest band energy at k=0 (Gamma point)\n        eigenvalues_k0 = compute_band_energies(V0, N_max, k_zero)\n        E1_at_k0 = eigenvalues_k0[0]\n        \n        # 2. Compute eigenvalues at k=pi (Brillouin zone boundary)\n        eigenvalues_k_pi = compute_band_energies(V0, N_max, k_pi)\n        \n        # 3. Extract lowest energy at k=pi\n        E1_at_k_pi = eigenvalues_k_pi[0]\n        \n        # 4. Compute the direct band gap at k=pi\n        E2_at_k_pi = eigenvalues_k_pi[1]\n        gap_at_k_pi = E2_at_k_pi - E1_at_k_pi\n        \n        # Append the triple of results, rounded to 6 decimal places.\n        results.append(round(E1_at_k0, 6))\n        results.append(round(E1_at_k_pi, 6))\n        results.append(round(gap_at_k_pi, 6))\n\n    # Print the final flattened list in the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "任何数值计算的核心问题之一是其收敛性与准确性。在上一个练习的基础上，我们将探讨计算材料科学中的一个关键实践步骤：收敛性测试。你将系统地研究计算出的基态能量如何随着平面波截断能（即基组大小）的增加而收敛，并量化其收敛速度。掌握这一技能对于确保任何实际模拟结果的可靠性至关重要。",
            "id": "3435162",
            "problem": "要求您实现一维不含时薛定谔方程的平面波离散化，用于描述质量为 $m$ 的电子在空间周期性势场中的行为，并量化最低布洛赫能带能量相对于平面波动能截断的收敛性。该物理系统由势场 $V(x)=V_0\\cos(2\\pi x/a)$ 定义，其中 $a$ 是晶格常数，$V_0$ 是势场振幅。在整个计算过程中使用以下约化单位：设约化普朗克常数 $\\hbar=1$ 和电子质量 $m=1$，因此能量是无量纲的。您的程序必须为下述每个测试用例输出一个收敛指数，输出值无需任何物理单位。\n\n出发点与核心定义：\n- 考虑一维不含时薛定谔方程 $H\\psi_k(x)=E_k\\psi_k(x)$，其中 $H=-\\frac{1}{2}\\frac{d^2}{dx^2}+V(x)$，势场为周期性势场 $V(x)=V_0\\cos(2\\pi x/a)$。\n- 根据布洛赫定理，本征函数的形式为 $\\psi_k(x)=e^{ikx}u_k(x)$，其中 $u_k(x)$ 的周期为 $a$，$k$ 是第一布里渊区中的晶体动量。\n- 将 $u_k(x)$ 展开为平面波 $e^{iGx}$，其中 $G$ 取遍倒易晶格矢量 $G_0=2\\pi/a$ 的整数倍，即 $G=nG_0$，其中 $n\\in\\mathbb{Z}$。在平面波基 $\\{|k+G\\rangle\\}$ 中，哈密顿矩阵由动能和 $V(x)$ 的傅里叶分量决定。\n\n实现要求：\n- 对于给定的 $k$、$V_0$ 和 $a$，定义动能平面波截断 $E_{\\text{cut}}>0$，并将基组限制为所有动能不超过该截断的平面波 $|k+nG_0\\rangle$：包含所有满足 $\\frac{1}{2}(k+nG_0)^2\\le E_{\\text{cut}}$ 的整数 $n$。\n- 在此截断后的基组中，使用以下公式构建哈密顿矩阵：\n  - 动能矩阵元：$\\langle k+n'G_0| -\\frac{1}{2}\\frac{d^2}{dx^2} | k+nG_0\\rangle=\\frac{1}{2}(k+nG_0)^2\\,\\delta_{n',n}$。\n  - 势能矩阵元由 $V(x)=V_0\\cos(2\\pi x/a)$ 的傅里叶级数确定；仅有的非零傅里叶系数位于 $G=\\pm G_0$ 处，其振幅为 $V_{\\pm G_0}=V_0/2$。因此，在 $\\{n\\}$ 指数中，仅有的非零非对角耦合发生在最近邻之间：$\\langle k+n'G_0| V | k+nG_0\\rangle=(V_0/2)\\,(\\delta_{n',n+1}+\\delta_{n',n-1})$。\n- 对于指定列表中的每个 $E_{\\text{cut}}$，计算截断后哈密顿量的最低本征值 $E_0(k;E_{\\text{cut}})$。使用一个非常大的截断 $E_{\\text{cut}}^{\\text{ref}}$ 来定义参考值 $E_0^{\\text{ref}}(k)=E_0(k;E_{\\text{cut}}^{\\text{ref}})$，并定义绝对本征值误差 $\\varepsilon(E_{\\text{cut}})=\\lvert E_0(k;E_{\\text{cut}})-E_0^{\\text{ref}}(k)\\rvert$。\n- 对所提供的截断值列表，执行 $\\log \\varepsilon(E_{\\text{cut}})$ 关于 $\\log E_{\\text{cut}}$ 的对数-对数线性回归，并报告其斜率 $s$，该斜率估计了收敛速率指数，即当 $E_{\\text{cut}}\\to\\infty$ 时，$\\varepsilon(E_{\\text{cut}})\\sim C\\,E_{\\text{cut}}^{\\,s}$。\n\n角度和单位说明：\n- 所有三角函数的参数均以弧度为单位。\n- 由于采用 $\\hbar=1$ 和 $m=1$ 的约化单位约定，您的计算中能量和动量均为无量纲。报告最终的数值斜率时，使用无量纲浮点数。\n\n测试套件：\n- 使用倒易晶格矢量 $G_0=2\\pi/a$，其中 $a=1$。\n- 对每个测试用例，使用以下参数和截断值计算斜率 $s$，并将参考截断值设为 $E_{\\text{cut}}^{\\text{ref}}=2000$。\n  1. 测试用例 1：$V_0=2$，$a=1$，$k=0$，$E_{\\text{cut}}\\in\\{30,60,120,240\\}$。\n  2. 测试用例 2：$V_0=2$，$a=1$，$k=\\pi/a$，$E_{\\text{cut}}\\in\\{30,60,120,240\\}$。\n  3. 测试用例 3：$V_0=5$，$a=1$，$k=(\\pi/2)/a$，$E_{\\text{cut}}\\in\\{40,80,160,320\\}$。\n\n算法约束：\n- 哈密顿量的构建必须遵循所述的动能项和余弦势场的非零傅里叶分量。对于每个 $E_{\\text{cut}}$，实现必须精确地包含满足动能截断条件 $\\frac{1}{2}(k+nG_0)^2\\le E_{\\text{cut}}$ 的所有基态。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，每个测试用例对应一项，顺序与上述列表相同。每项必须是拟合斜率 $s$，表示为浮点数，并四舍五入到三位小数。例如，一个有效的输出可能看起来像“[$-1.002,-1.015,-0.998$]”。\n\n科学真实性要求：\n- 仅使用此处陈述的定义和构造，不使用任何外部数据。确保所有矩阵都是厄米的，并且本征值问题以给定规模下的完全数值精度求解。\n\n您的程序必须实现上述要求，并打印完全符合指定格式的最终输出。程序在运行时不提供任何输入；所有参数均已指定。斜率计算必须使用每个测试用例列出的所有截断值。",
            "solution": "该问题要求实现一种平面波离散化方法，以求解周期性势场中的一维不含时薛定谔方程，并分析基态能量相对于基组动能截断的收敛性。\n\n该物理系统是一个质量为 $m=1$ 的电子，在哈密顿量 $H=-\\frac{1}{2}\\frac{d^2}{dx^2}+V(x)$ 的作用下，于势场 $V(x) = V_0\\cos(2\\pi x/a)$ 中运动，其中约化普朗克常数 $\\hbar=1$。根据布洛赫定理，对于给定的晶体动量 $k$，波函数可以写为 $\\psi_k(x) = e^{ikx}u_k(x)$，其中 $u_k(x)$ 与势场具有相同的周期 $a$。周期函数 $u_k(x)$ 可以展开为关于倒易晶格矢量 $G_n = nG_0 = n(2\\pi/a)$ 的傅里叶级数，其中 $n$ 为整数：\n$$u_k(x) = \\sum_n c_{n} e^{iG_n x}$$\n这导出了完整波函数 $\\psi_k(x)$ 在平面波基组上的展开式：\n$$\\psi_k(x) = \\sum_n c_{n} e^{i(k+G_n)x}$$\n通过在此基组中求解薛定谔方程 $H\\psi_k(x) = E_k\\psi_k(x)$，可以找到系数 $c_n$ 和能量本征值 $E_k$。将平面波展开式代入薛定谔方程，并投影到基态 $|k+G_{n'}\\rangle$（由函数 $e^{i(k+G_{n'})x}$ 表示）上，得到系数 $\\vec{c}$ 基下的矩阵本征值方程：\n$$\\sum_n H_{n',n} c_n = E_k c_{n'}$$\n其中 $H_{n',n}$ 是哈密顿量在平面波基 $\\{|k+G_n\\rangle\\}$ 中的矩阵元。\n\n矩阵元由 $H_{n',n} = \\langle k+G_{n'} | H | k+G_n \\rangle$ 给出。哈密顿量由动能项 $T = -\\frac{1}{2}\\frac{d^2}{dx^2}$ 和势能项 $V(x)$ 组成。\n\n动能算符在平面波基中是对角的。其矩阵元为：\n$$T_{n',n} = \\langle k+G_{n'} | T | k+G_n \\rangle = \\frac{1}{2}(k+G_n)^2 \\delta_{n',n}$$\n势场为 $V(x) = V_0\\cos(G_0 x) = \\frac{V_0}{2}(e^{iG_0x} + e^{-iG_0x})$。其矩阵元由势场的傅里叶变换给出：\n$$V_{n',n} = \\langle k+G_{n'} | V(x) | k+G_n \\rangle = \\frac{1}{L} \\int_0^L e^{-i(k+G_{n'})x} V(x) e^{i(k+G_n)x} dx$$\n$$V_{n',n} = \\frac{V_0}{2L} \\int_0^L e^{-i(G_{n'}-G_n)x} (e^{iG_0x} + e^{-iG_0x}) dx$$\n$$V_{n',n} = \\frac{V_0}{2L} \\int_0^L (e^{i(G_n-G_{n'}+G_0)x} + e^{i(G_n-G_{n'}-G_0)x}) dx$$\n仅当指数为零时，积分才不为零。这发生在 $G_n-G_{n'}+G_0 = 0$（即 $n-n'+1=0$，所以 $n'=n+1$）或 $G_n-G_{n'}-G_0 = 0$（即 $n-n'-1=0$，所以 $n'=n-1$）时。因此，矩阵元的值为 $\\frac{V_0}{2}$。综合起来，我们得到：\n$$V_{n',n} = \\frac{V_0}{2}(\\delta_{n',n+1} + \\delta_{n',n-1})$$\n因此，完整的哈密顿矩阵是一个实对称三对角矩阵，其元素为：\n$$H_{n',n} = \\frac{1}{2}(k+nG_0)^2 \\delta_{n',n} + \\frac{V_0}{2}(\\delta_{n',n+1} + \\delta_{n',n-1})$$\n\n在实际计算中，无限基组必须被截断。这通过施加一个动能截断 $E_{\\text{cut}}$ 来实现，只包括那些动能低于该截断的平面波 $|k+G_n\\rangle$：\n$$\\frac{1}{2}(k+nG_0)^2 \\le E_{\\text{cut}}$$\n这个不等式确定了一个有限的整数 $n$ 范围，这些整数构成了给定 $E_{\\text{cut}}$ 的基组。对于一组给定的参数 $(V_0, a, k)$ 和一个截断值 $E_{\\text{cut}}$，我们执行以下步骤：\n1. 确定满足截断条件的整数集合 $\\{n\\}$。设 $N$ 为这些整数的数量。\n2. 使用上面定义的元素 $H_{n',n}$ 构建 $N \\times N$ 的哈密顿矩阵 $H$，其中索引现在遍历所选的整数集合。\n3. 求解该矩阵的本征值问题。最低的本征值是该基组下的基态能量，即 $E_0(k; E_{\\text{cut}})$。\n\n为了量化收敛性，我们为一系列递增的截断值 $E_{\\text{cut}}$ 计算此能量。误差是相对于一个高度收敛的参考能量 $E_0^{\\text{ref}}(k) = E_0(k; E_{\\text{cut}}^{\\text{ref}})$ 定义的，该参考能量是用一个非常大的截断值 $E_{\\text{cut}}^{\\text{ref}}$ 计算得出的。误差为 $\\varepsilon(E_{\\text{cut}}) = \\lvert E_0(k; E_{\\text{cut}}) - E_0^{\\text{ref}}(k)\\rvert$。收敛速率通过假设幂律关系 $\\varepsilon(E_{\\text{cut}}) \\propto E_{\\text{cut}}^{\\,s}$ 来估计。对两边取对数得到 $\\log \\varepsilon = s \\log E_{\\text{cut}} + \\text{const}$。因此，指数 $s$ 可以作为 $\\log \\varepsilon$ 对 $\\log E_{\\text{cut}}$ 的线性回归斜率来找到。\n\n每个测试用例的算法流程如下：\n1. 设置参数 $V_0$、$a$ 和 $k$。倒易晶格矢量为 $G_0 = 2\\pi/a$。\n2. 使用参考截断值 $E_{\\text{cut}}^{\\text{ref}} = 2000$ 计算参考能量 $E_0^{\\text{ref}}$。\n3. 对于所提供列表中的每个 $E_{\\text{cut}}$：\n    a. 从条件 $\\frac{-k-\\sqrt{2E_{\\text{cut}}}}{G_0} \\le n \\le \\frac{-k+\\sqrt{2E_{\\text{cut}}}}{G_0}$ 确定整数范围 $n_{\\text{min}} \\le n \\le n_{\\text{max}}$。\n    b. 为整数 $\\{n_{\\text{min}}, \\dots, n_{\\text{max}}\\}$ 构建哈密顿矩阵。\n    c. 求解其最低本征值 $E_0(E_{\\text{cut}})$。\n4. 计算所有截断值下的误差 $\\varepsilon(E_{\\text{cut}})$。\n5. 对点集 $(\\log E_{\\text{cut}}, \\log \\varepsilon(E_{\\text{cut}}))$ 进行线性拟合以获得斜率 $s$。\n\n然后对问题陈述中指定的所有测试用例重复此过程。收集并格式化得到的斜率 $s$，以用于最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the specified test cases.\n    It calculates the convergence exponent for the lowest Bloch band energy\n    with respect to the plane-wave kinetic energy cutoff.\n    \"\"\"\n\n    # Test cases as defined in the problem statement:\n    # (V0, a, k, list_of_E_cut)\n    test_cases = [\n        (2.0, 1.0, 0.0, [30.0, 60.0, 120.0, 240.0]),\n        (2.0, 1.0, np.pi / 1.0, [30.0, 60.0, 120.0, 240.0]),\n        (5.0, 1.0, (np.pi / 2.0) / 1.0, [40.0, 80.0, 160.0, 320.0]),\n    ]\n    ref_e_cut = 2000.0\n\n    results = []\n\n    for v0, a, k, e_cuts in test_cases:\n        \n        # Calculate reference energy with a high cutoff\n        ref_energy = _calculate_lowest_eigenvalue(v0, a, k, ref_e_cut)\n\n        energies = []\n        for e_cut in e_cuts:\n            energy = _calculate_lowest_eigenvalue(v0, a, k, e_cut)\n            energies.append(energy)\n        \n        energies = np.array(energies)\n        e_cuts_np = np.array(e_cuts)\n        \n        # Calculate the absolute error\n        errors = np.abs(energies - ref_energy)\n\n        # It's possible for an error to be zero if the basis set is the same\n        # as the reference (unlikely here) or if numerical precision issues arise.\n        # We filter out such points to avoid log(0).\n        valid_indices = errors > 0\n        \n        log_e_cuts = np.log(e_cuts_np[valid_indices])\n        log_errors = np.log(errors[valid_indices])\n\n        # Perform log-log linear regression to find the slope\n        # polyfit(x, y, 1) returns [slope, intercept]\n        if len(log_e_cuts) > 1:\n            slope, _ = np.polyfit(log_e_cuts, log_errors, 1)\n        else:\n            # Not enough points for a fit, this case should not happen\n            # with the given problem data.\n            slope = np.nan\n\n        results.append(slope)\n\n    # Format output as specified\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _calculate_lowest_eigenvalue(v0, a, k, e_cut):\n    \"\"\"\n    Calculates the lowest energy eigenvalue for a given set of parameters.\n\n    Args:\n        v0 (float): Potential amplitude.\n        a (float): Lattice constant.\n        k (float): Crystal momentum.\n        e_cut (float): Kinetic energy cutoff.\n\n    Returns:\n        float: The lowest eigenvalue of the Hamiltonian.\n    \"\"\"\n    g0 = 2 * np.pi / a\n\n    # Determine the range of integers n for the basis set\n    # from the condition 1/2 * (k + n*g0)^2 = e_cut\n    sqrt_2_e_cut = np.sqrt(2 * e_cut)\n    n_min_bound = (-k - sqrt_2_e_cut) / g0\n    n_max_bound = (-k + sqrt_2_e_cut) / g0\n\n    n_min = int(np.ceil(n_min_bound))\n    n_max = int(np.floor(n_max_bound))\n\n    n_values = np.arange(n_min, n_max + 1)\n    basis_size = len(n_values)\n\n    if basis_size == 0:\n        return np.inf\n\n    # Create a mapping from integer n to matrix index\n    n_to_idx = {n: i for i, n in enumerate(n_values)}\n\n    # Assemble the Hamiltonian matrix\n    hamiltonian = np.zeros((basis_size, basis_size))\n\n    # Fill kinetic energy (diagonal) and potential (off-diagonal) terms\n    for i, n in enumerate(n_values):\n        # Kinetic energy term\n        hamiltonian[i, i] = 0.5 * (k + n * g0)**2\n        \n        # Potential coupling term to n-1\n        n_prev = n - 1\n        if n_prev in n_to_idx:\n            j = n_to_idx[n_prev]\n            hamiltonian[i, j] = v0 / 2.0\n        \n        # Potential coupling term to n+1\n        n_next = n + 1\n        if n_next in n_to_idx:\n            j = n_to_idx[n_next]\n            hamiltonian[i, j] = v0 / 2.0\n\n    # The Hamiltonian is Hermitian (real and symmetric).\n    # eigh is efficient for such matrices and returns sorted eigenvalues.\n    eigenvalues = eigh(hamiltonian, eigvals_only=True)\n    \n    return eigenvalues[0]\n\nsolve()\n```"
        },
        {
            "introduction": "晶体对称性，尤其是那些更为复杂的非点式对称性，深刻地影响着电子能带的拓扑特性。本次高级实践将引导你探索非点式对称性所导致的能带简并现象。通过构建一个包含滑移对称性的紧束缚模型，你将能够数值验证在布里渊区边界上出现的“能带粘连”现象，这是一种受对称性保护、无法轻易消除的奇特简并。",
            "id": "3435165",
            "problem": "考虑一个二维晶格，其原胞矢量为 $\\mathbf{a} = (a,0)$ 和 $\\mathbf{b} = (0,b)$，每个晶胞有两个无自旋轨道，分别位于 $\\mathbf{r}_A = (0,0)$ 和 $\\mathbf{r}_B = (a/2,0)$。设 $a=b=1$ 且所有能量均视为无量纲。假设紧束缚跃迁过程具有平移不变性且为实数，从而保证了无自旋粒子（时间反演对称性平方为 $+1$）的时间反演对称性。该晶体具有一个非点式滑移对称性 $G$，该对称性由一个反射操作 $y \\mapsto -y$ 和一个沿 $x$ 方向的半平移 $(a/2,0)$ 构成。在具有偶镜面宇称轨道的布洛赫基 $\\{|A\\rangle, |B\\rangle\\}$ 中，$G$ 的对称性作用由幺正矩阵 $U_G(\\mathbf{k}) = e^{- i k_x a/2}\\, \\sigma_x$ 表示，其中 $\\sigma_x$ 是作用在子晶格空间中的泡利矩阵，$\\mathbf{k}=(k_x,k_y)$ 是晶体动量。\n\n仅从布洛赫定理和上述定义的对称性作用出发，在子晶格基中构造一个最小的 $2\\times 2$ 布洛赫哈密顿量 $H(\\mathbf{k})$，该哈密顿量满足：\n- 满足平移不变性和时间反演对称性（实数跃迁振幅）。\n- 满足滑移对称性，即 $U_G(\\mathbf{k})\\, H(k_x,k_y)\\, U_G^\\dagger(\\mathbf{k}) = H(k_x,-k_y)$。\n- 由以下具有物理动机的实空间跃迁过程生成：\n  1. 沿 $\\pm \\mathbf{a}$ 方向、振幅为 $t_x$ 的同子晶格最近邻跃迁，以及沿 $\\pm \\mathbf{b}$ 方向、振幅为 $t_y$ 的同子晶格最近邻跃迁（对于 $A$ 和 $B$ 相同，因为它们通过滑移对称性相关联）。\n  2. 沿位移 $(\\pm a/2, 0)$、振幅为 $t_1$ 的 $A$ 和 $B$ 之间的子晶格间跃迁；以及对称地沿 $(\\pm a/2, \\pm b)$、振幅为 $t_2$ 和 $(\\pm a/2, \\pm 2b)$、振幅为 $t_3$ 的子晶格间跃迁。这些集合作为镜面对称对被包含，以使最终的子晶格间矩阵元在 $k_y$ 中为偶函数且为实数。\n  3. 一个允许的、由 $t_{\\mathrm{odd}}$ 参数化的、滑移对称的子晶格奇垂直贡献，该贡献在 $k_y$ 中为奇函数并乘以 $\\sigma_z$。你可以直接在布洛赫哈密顿量层面将此项实现为一个 $\\sin(k_y b)$ 因子；这在对称性上是允许的，并对应于 $A$ 和 $B$ 色散之间的差异，该差异在 $k_y \\mapsto -k_y$ 变换下符号反转。\n  4. 为了测试简并的脆弱性，引入一个与 $\\sigma_z$ 成正比、在 $k_y$ 中为偶函数（一个常数）的、明确破坏滑移对称性的子晶格不平衡项 $\\Delta_{\\mathrm{break}}$。该项违反了滑移约束，仅在下面的测试套件中用作边缘案例。\n\n你的模型应写成厄米矩阵的形式 $H(\\mathbf{k}) = d_0(\\mathbf{k})\\, \\sigma_0 + d_x(\\mathbf{k})\\, \\sigma_x + d_y(\\mathbf{k})\\, \\sigma_y + d_z(\\mathbf{k})\\, \\sigma_z$，其中 $\\sigma_0$ 是单位矩阵，$\\sigma_{x,y,z}$ 是在 $\\{A,B\\}$ 基中的泡利矩阵。推导在 $k_y \\mapsto -k_y$ 变换下，由滑移关系导出的对 $d_\\mu(\\mathbf{k})$ 的对称性宇称约束，然后使用布洛赫定理，获得由指定的实空间跃迁所引起的 $k$ 依赖关系。你不能未经推导就假设任何最终表达式。\n\n利用所构造的 $H(\\mathbf{k})$ 证明：\n- 滑移表示满足 $U_G^2(\\mathbf{k}) = e^{- i k_x a}\\, \\sigma_0$。特别地，在布里渊区边界 $k_x=\\pi/a$ 处，有 $U_G^2 = - \\sigma_0$，且滑移本征值为 $\\pm i$。\n- 沿着滑移不变线 $k_y=0$ 和 $k_y=\\pi/b$，时间反演对称性确保在时间反演不变动量点 $X=(\\pi/a,0)$ 和 $M=(\\pi/a,\\pi/b)$ 处，当滑移对称性保持时，能带必须粘连成简并对，这与通过复共轭滑移本征值 $\\pm i$ 进行的不可约表示配对相符。\n\n你的程序必须：\n1. 实现针对 $a=b=1$ 推导出的 $H(\\mathbf{k})$ 和 $U_G(\\mathbf{k})$。\n2. 对于下面测试套件中列出的每组参数，数值计算 $H(\\mathbf{k})$ 在三个动量点 $X=(\\pi,0)$、$M=(\\pi,\\pi)$ 和非时间反演不变的边界点 $B_{\\mathrm{mid}}=(\\pi,\\pi/2)$ 的两个本征值。如果两个本征值之间的绝对差小于容差 $\\tau = 10^{-8}$，则声明简并为“true”，否则为“false”。\n3. 对于每组参数，计算在 $X=(\\pi,0)$ 处的对易子 $[H(\\mathbf{k}), U_G(\\mathbf{k})]$ 的弗罗贝尼乌斯范数，结果为一个非负实数。当滑移对称性保持时，该范数必须精确为零；当被 $\\Delta_{\\mathrm{break}}$ 破坏时，通常非零。\n4. 对于每组参数，汇总一个包含四个结果的列表：在 $X$、$M$、$B_{\\mathrm{mid}}$ 处简并性的三个布尔值，后跟在 $X$ 处等于对易子范数的浮点数。\n\n测试套件（使用 $a=b=1$）：\n- 情况 1（存在子晶格奇垂直项的通用滑移对称情况）：$\\epsilon = 0$, $t_x=-0.8$, $t_y=-0.6$, $t_1=1.0$, $t_2=0.35$, $t_3=-0.2$, $t_{\\mathrm{odd}}=0.5$, $\\Delta_{\\mathrm{break}}=0$。\n- 情况 2（无子晶格奇项的滑移对称情况，强制实现完全边界粘连）：$\\epsilon = 0$, $t_x=-0.8$, $t_y=-0.6$, $t_1=1.0$, $t_2=0.35$, $t_3=-0.2$, $t_{\\mathrm{odd}}=0$, $\\Delta_{\\mathrm{break}}=0$。\n- 情况 3（明确破坏滑移对称性的边缘案例）：$\\epsilon = 0$, $t_x=-0.8$, $t_y=-0.6$, $t_1=1.0$, $t_2=0.35$, $t_3=-0.2$, $t_{\\mathrm{odd}}=0.5$, $\\Delta_{\\mathrm{break}}=0.1$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的三个情况结果的逗号分隔列表。每个情况结果本身就是一个列表，顺序为 $[\\mathrm{degX}, \\mathrm{degM}, \\mathrm{degBmid}, \\mathrm{comm\\_X}]$。例如：$[[\\mathrm{true},\\mathrm{true},\\mathrm{false},0.0],[\\dots],[\\dots]]$。布尔值必须以 Python 的规范小写形式打印，浮点数必须以标准十进制数形式打印。无需报告物理单位，因为根据设定，$a=b=1$ 且能量是无量纲的。",
            "solution": "该问题要求构造并分析一个二维晶格的 $2 \\times 2$ 紧束缚布洛赫哈密顿量 $H(\\mathbf{k})$，该晶格具有非点式滑移对称性。分析将分几步进行：验证问题的有效性，从对称性和跃迁项推导哈密顿量，分析对称性所要求的强制能带简并，最后通过数值实现来验证这些物理后果。\n\n### 问题验证\n首先对问题进行严格验证。\n\n**步骤1：提取的已知条件**\n- **晶格与基矢**：二维晶格，原胞矢量为 $\\mathbf{a} = (a,0)$ 和 $\\mathbf{b} = (0,b)$。每个晶胞有两个无自旋轨道，分别位于 $\\mathbf{r}_A = (0,0)$ 和 $\\mathbf{r}_B = (a/2,0)$。\n- **常数**：$a=1$，$b=1$。能量是无量纲的。\n- **对称性**：平移不变性，时间反演对称性（TRS，实数跃迁），以及非点式滑移对称性 $G$。\n- **滑移对称性表示**：$G$ 为 $y \\mapsto -y$ 再加上平移 $(a/2,0)$。其矩阵表示为 $U_G(\\mathbf{k}) = e^{- i k_x a/2}\\, \\sigma_x$。\n- **对称性约束**：$U_G(\\mathbf{k})\\, H(k_x,k_y)\\, U_G^\\dagger(\\mathbf{k}) = H(k_x,-k_y)$。\n- **用于构造的跃迁项**：\n    1.  同子晶格（子晶格内）最近邻跃迁：沿 $\\pm\\mathbf{a}$ 方向为 $t_x$，沿 $\\pm\\mathbf{b}$ 方向为 $t_y$。\n    2.  子晶格间跃迁：位移 $(\\pm a/2, 0)$ 为 $t_1$；$(\\pm a/2, \\pm b)$ 为 $t_2$；$(\\pm a/2, \\pm 2b)$ 为 $t_3$。\n    3.  子晶格奇项：$t_{\\mathrm{odd}}\\sin(k_y b)\\sigma_z$。\n    4.  对称性破缺项：$\\Delta_{\\mathrm{break}}\\sigma_z$。\n- **要求进行的推导**：\n    1.  证明 $U_G^2(\\mathbf{k}) = e^{- i k_x a}\\, \\sigma_0$ 且在 $k_x=\\pi/a$ 时本征值为 $\\pm i$。\n    2.  解释在 $X=(\\pi/a,0)$ 和 $M=(\\pi/a,\\pi/b)$ 处的能带粘连。\n- **数值任务**：对于三个指定的参数集，计算 $H(\\mathbf{k})$ 在 $X$、$M$ 和 $B_{\\mathrm{mid}}=(\\pi,\\pi/2)$ 的本征值，检查是否存在简并（容差 $\\tau = 10^{-8}$），并计算 $[H(X), U_G(X)]$ 的弗罗贝尼乌斯范数。\n\n**步骤2和3：结论与行动**\n问题是**有效**的。这是一个来自理论凝聚态物理领域的、定义明确且科学严谨的问题。它自成体系，提供了所有必要的参数和定义。任务涉及该领域中标准的、但并非微不足道的推导和数值验证。没有矛盾、歧义或事实错误。因此可以继续进行求解过程。\n\n### 理论推导\n在推导中我们将设 $a=1$ 和 $b=1$。\n\n**1. $H(\\mathbf{k})$ 上的滑移对称性约束**\n哈密顿量在泡利矩阵基中表示为：$H(\\mathbf{k}) = d_0(\\mathbf{k})\\sigma_0 + d_x(\\mathbf{k})\\sigma_x + d_y(\\mathbf{k})\\sigma_y + d_z(\\mathbf{k})\\sigma_z$。滑移对称性约束为 $U_G(\\mathbf{k})H(\\mathbf{k})U_G^\\dagger(\\mathbf{k}) = H(k_x, -k_y)$。\n代入 $U_G(\\mathbf{k}) = e^{-i k_x/2}\\sigma_x$ 和 $U_G^\\dagger(\\mathbf{k}) = \\sigma_x e^{i k_x/2}$：\n$$ e^{-i k_x/2}\\sigma_x \\left( \\sum_{\\mu=0,x,y,z} d_\\mu(k_x, k_y) \\sigma_\\mu \\right) \\sigma_x e^{i k_x/2} = \\sum_{\\mu=0,x,y,z} d_\\mu(k_x, -k_y) \\sigma_\\mu $$\n$$ \\sigma_x H(k_x, k_y) \\sigma_x = H(k_x, -k_y) $$\n使用泡利代数恒等式 $\\sigma_x \\sigma_0 \\sigma_x = \\sigma_0$，$\\sigma_x \\sigma_x \\sigma_x = \\sigma_x$，$\\sigma_x \\sigma_y \\sigma_x = -\\sigma_y$ 和 $\\sigma_x \\sigma_z \\sigma_x = -\\sigma_z$，我们得到：\n$$ d_0(k_x,k_y)\\sigma_0 + d_x(k_x,k_y)\\sigma_x - d_y(k_x,k_y)\\sigma_y - d_z(k_x,k_y)\\sigma_z = d_0(k_x,-k_y)\\sigma_0 + d_x(k_x,-k_y)\\sigma_x + d_y(k_x,-k_y)\\sigma_y + d_z(k_x,-k_y)\\sigma_z $$\n比较泡利矩阵的系数，得到在变换 $k_y \\mapsto -k_y$ 下的宇称约束：\n- $d_0$ 必须是 $k_y$ 的偶函数。\n- $d_x$ 必须是 $k_y$ 的偶函数。\n- $d_y$ 必须是 $k_y$ 的奇函数。\n- $d_z$ 必须是 $k_y$ 的奇函数。\n\n**2. 布洛赫哈密顿量的构造**\n布洛赫哈密顿量的矩阵元是实空间跃迁积分 $t(\\vec{\\delta})$ 对所有位移矢量 $\\vec{\\delta}$ 的晶格傅里叶变换。对于双组分基 $\\{A, B\\}$，哈密顿量是一个 $2\\times 2$ 矩阵 $H(\\mathbf{k}) = \\begin{pmatrix} H_{AA}(\\mathbf{k})  H_{AB}(\\mathbf{k}) \\\\ H_{BA}(\\mathbf{k})  H_{BB}(\\mathbf{k}) \\end{pmatrix}$。对于实数跃迁振幅，厄米性意味着 $H_{BA}(\\mathbf{k}) = H_{AB}^*(\\mathbf{k})$。其分解为 $H_{AA} = d_0+d_z$，$H_{BB} = d_0-d_z$ 和 $H_{AB} = d_x-id_y$。\n\n- **子晶格内项 ($H_{AA}$, $H_{BB}$)**：跃迁连接同类格点。问题陈述这些对于 $A$ 和 $B$ 是相同的，这意味着这些项仅对 $d_0$ 有贡献。\n  位移矢量为 $\\pm\\mathbf{a}=(\\pm 1, 0)$ 和 $\\pm\\mathbf{b}=(0, \\pm 1)$。\n  $$ H_{AA}(\\mathbf{k}) = H_{BB}(\\mathbf{k}) = t_x(e^{i k_x} + e^{-i k_x}) + t_y(e^{i k_y} + e^{-i k_y}) = 2t_x\\cos(k_x) + 2t_y\\cos(k_y) $$\n  这贡献于 $d_0$。测试套件中的参数 $\\epsilon$，如果解释为总能量偏移，将会加到 $d_0$ 上。由于 $\\epsilon=0$，我们忽略它。因此，$d_0(\\mathbf{k}) = 2t_x\\cos(k_x) + 2t_y\\cos(k_y)$。这是 $k_y$ 的偶函数，符合要求。\n\n- **子晶格间项 ($H_{AB}$)**：跃迁连接 $A$ 和 $B$ 格点。$H_{AB}(\\mathbf{k}) = \\sum_{\\vec{\\delta}_{AB}} t(\\vec{\\delta}_{AB}) e^{i\\mathbf{k}\\cdot\\vec{\\delta}_{AB}}$。\n  1.  在位移 $(\\pm 1/2, 0)$ 上振幅为 $t_1$ 的跃迁：$t_1(e^{i k_x/2} + e^{-i k_x/2}) = 2t_1\\cos(k_x/2)$。\n  2.  在 $(\\pm 1/2, \\pm 1)$ 上振幅为 $t_2$ 的跃迁：$t_2 \\sum_{\\sigma_x, \\sigma_y = \\pm 1} e^{i(\\sigma_x k_x/2 + \\sigma_y k_y)} = 4t_2\\cos(k_x/2)\\cos(k_y)$。\n  3.  在 $(\\pm 1/2, \\pm 2)$ 上振幅为 $t_3$ 的跃迁：$4t_3\\cos(k_x/2)\\cos(2k_y)$。\n  将这些结合起来，我们得到：\n  $$ H_{AB}(\\mathbf{k}) = 2\\cos(k_x/2) \\left( t_1 + 2t_2\\cos(k_y) + 2t_3\\cos(2k_y) \\right) $$\n  由于所有跃迁振幅都是实数，$H_{AB}(\\mathbf{k})$ 是实数。厄米性要求 $H_{BA}(\\mathbf{k}) = H_{AB}(\\mathbf{k})$。这意味着 $d_x = H_{AB}$ 且 $d_y = 0$。$d_x$（$k_y$ 的偶函数）和 $d_y$（平凡地是 $k_y$ 的奇函数）都满足对称性约束。\n\n- **子晶格奇项和对称性破缺项**：这些项对 $d_z$ 有贡献。\n  问题指定了一个项 $t_{\\mathrm{odd}}\\sin(k_y)\\sigma_z$ 和一个破缺项 $\\Delta_{\\mathrm{break}}\\sigma_z$。\n  所以，$d_z(\\mathbf{k}) = t_{\\mathrm{odd}}\\sin(k_y) + \\Delta_{\\mathrm{break}}$。\n  对于滑移对称情况（$\\Delta_{\\mathrm{break}}=0$），$d_z(\\mathbf{k}) = t_{\\mathrm{odd}}\\sin(k_y)$ 是 $k_y$ 的奇函数，满足约束。常数项 $\\Delta_{\\mathrm{break}}$ 是偶函数，明确破坏了滑移对称性。\n\n- **最终哈密顿量**：\n  $H(\\mathbf{k}) = d_0(\\mathbf{k})\\sigma_0 + d_x(\\mathbf{k})\\sigma_x + d_z(\\mathbf{k})\\sigma_z$，其中\n  $d_0(\\mathbf{k}) = 2t_x\\cos(k_x) + 2t_y\\cos(k_y)$\n  $d_x(\\mathbf{k}) = 2\\cos(k_x/2) \\left( t_1 + 2t_2\\cos(k_y) + 2t_3\\cos(2k_y) \\right)$\n  $d_z(\\mathbf{k}) = t_{\\mathrm{odd}}\\sin(k_y) + \\Delta_{\\mathrm{break}}$\n\n**3. 对称性保护的简并**\n- **滑移算符性质**：$U_G(\\mathbf{k}) = e^{-ik_x/2}\\sigma_x$。对此算符求平方得到：\n  $$ U_G^2(\\mathbf{k}) = (e^{-ik_x/2}\\sigma_x)^2 = e^{-ik_x}\\sigma_x^2 = e^{-ik_x}\\sigma_0 $$\n  在布里渊区边界 $k_x=\\pi$ 处，这变成 $U_G^2(\\pi,k_y) = e^{-i\\pi}\\sigma_0 = -\\sigma_0$。$U_G(\\pi,k_y)$ 的本征值 $\\lambda_G$ 必须满足 $\\lambda_G^2 = -1$，这意味着 $\\lambda_G = \\pm i$。\n\n- **X点和M点的能带粘连**：哈密顿量的本征值为 $E_{\\pm}(\\mathbf{k}) = d_0(\\mathbf{k}) \\pm \\sqrt{d_x(\\mathbf{k})^2 + d_y(\\mathbf{k})^2 + d_z(\\mathbf{k})^2}$。当 $d_y=0$ 时，$E_{\\pm}(\\mathbf{k}) = d_0(\\mathbf{k}) \\pm \\sqrt{d_x(\\mathbf{k})^2 + d_z(\\mathbf{k})^2}$。简并当且仅当根号内的表达式为零时发生，即 $d_x(\\mathbf{k})=0$ 且 $d_z(\\mathbf{k})=0$。\n\n  我们来分析在 $k_x = \\pi$ 这条线上的行为：\n  $d_x(\\pi, k_y) = 2\\cos(\\pi/2)(\\dots) = 0$。因此，$d_x$ 在整条线上恒为零。\n  $d_z(\\pi, k_y) = t_{\\mathrm{odd}}\\sin(k_y) + \\Delta_{\\mathrm{break}}$。\n  \n  在滑移对称情况下（$\\Delta_{\\mathrm{break}}=0$），简并要求 $d_z = t_{\\mathrm{odd}}\\sin(k_y) = 0$。这个条件在高对称动量点 $k_y=0$（点 $X(\\pi,0)$）和 $k_y=\\pi$（点 $M(\\pi,\\pi)$）处得到满足。因此，能带在 $X$ 和 $M$ 点必须是简并的。这种由于非点式对称性和时间反演，能带在特定高对称点被迫简并的现象，被称为能带粘连。在线上的一个普通点，如 $B_{\\mathrm{mid}}(\\pi, \\pi/2)$，如果 $t_{\\mathrm{odd}}\\neq 0$，简并就会被解除。如果 $t_{\\mathrm{odd}}=0$，能带在整个 $k_x=\\pi$ 线上都是简并的。\n\n**4. 对易子计算**\n我们在点 $X=(\\pi,0)$ 计算对易子 $C = [H(\\mathbf{k}), U_G(\\mathbf{k})]$。\n在 $X$ 点，$U_G(X) = e^{-i\\pi/2}\\sigma_x = -i\\sigma_x$。\n哈密顿量的系数为：\n$d_0(X) = 2t_x\\cos(\\pi) + 2t_y\\cos(0) = -2t_x + 2t_y$。\n$d_x(X) = 0$。\n$d_z(X) = t_{\\mathrm{odd}}\\sin(0) + \\Delta_{\\mathrm{break}} = \\Delta_{\\mathrm{break}}$。\n所以，$H(X) = (-2t_x + 2t_y)\\sigma_0 + \\Delta_{\\mathrm{break}}\\sigma_z$。\n$$ C = [H(X), U_G(X)] = [(-2t_x + 2t_y)\\sigma_0 + \\Delta_{\\mathrm{break}}\\sigma_z, -i\\sigma_x] = -i\\Delta_{\\mathrm{break}}[\\sigma_z, \\sigma_x] $$\n使用 $[\\sigma_z, \\sigma_x] = 2i\\sigma_y$：\n$$ C = -i\\Delta_{\\mathrm{break}}(2i\\sigma_y) = 2\\Delta_{\\mathrm{break}}\\sigma_y = \\begin{pmatrix} 0  -2i\\Delta_{\\mathrm{break}} \\\\ 2i\\Delta_{\\mathrm{break}}  0 \\end{pmatrix} $$\n弗罗贝尼乌斯范数是 $\\|C\\|_F = \\sqrt{\\mathrm{Tr}(C^\\dagger C)} = \\sqrt{|-2i\\Delta_{\\mathrm{break}}|^2 + |2i\\Delta_{\\mathrm{break}}|^2} = \\sqrt{4\\Delta_{\\mathrm{break}}^2 + 4\\Delta_{\\mathrm{break}}^2} = \\sqrt{8\\Delta_{\\mathrm{break}}^2} = 2\\sqrt{2}|\\Delta_{\\mathrm{break}}|$。该范数当且仅当 $\\Delta_{\\mathrm{break}}=0$ 时为零，这证实了该参数会破坏滑移对称性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes a tight-binding Hamiltonian for a 2D lattice\n    with non-symmorphic glide symmetry, checking for symmetry-protected\n    degeneracies and symmetry breaking.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Generic glide-symmetric case\n        {'epsilon': 0, 'tx':-0.8, 'ty':-0.6, 't1':1.0, 't2':0.35, 't3':-0.2, 't_odd':0.5, 'delta_break':0.0},\n        # Case 2: Glide-symmetric with t_odd=0, leading to full boundary sticking\n        {'epsilon': 0, 'tx':-0.8, 'ty':-0.6, 't1':1.0, 't2':0.35, 't3':-0.2, 't_odd':0.0, 'delta_break':0.0},\n        # Case 3: Explicit glide-breaking case\n        {'epsilon': 0, 'tx':-0.8, 'ty':-0.6, 't1':1.0, 't2':0.35, 't3':-0.2, 't_odd':0.5, 'delta_break':0.1},\n    ]\n\n    def build_hamiltonian(k, params):\n        \"\"\"Constructs the 2x2 Bloch Hamiltonian H(k).\"\"\"\n        kx, ky = k\n        a, b = 1.0, 1.0 # Set lattice constants to 1\n        \n        # Unpack parameters\n        tx = params['tx']\n        ty = params['ty']\n        t1 = params['t1']\n        t2 = params['t2']\n        t3 = params['t3']\n        t_odd = params['t_odd']\n        delta_break = params['delta_break']\n\n        # Pauli matrices\n        sigma0 = np.array([[1, 0], [0, 1]], dtype=complex)\n        sigmax = np.array([[0, 1], [1, 0]], dtype=complex)\n        sigmaz = np.array([[1, 0], [0, -1]], dtype=complex)\n\n        # Calculate coefficients d_mu(k)\n        d0 = 2 * tx * np.cos(kx * a) + 2 * ty * np.cos(ky * b)\n        dx = 2 * np.cos(kx * a / 2.0) * (t1 + 2 * t2 * np.cos(ky * b) + 2 * t3 * np.cos(2 * ky * b))\n        # dy is zero for this model\n        dz = t_odd * np.sin(ky * b) + delta_break\n\n        H = d0 * sigma0 + dx * sigmax + dz * sigmaz\n        return H\n\n    def build_glide_op(k):\n        \"\"\"Constructs the 2x2 glide symmetry operator U_G(k).\"\"\"\n        kx, _ = k\n        a = 1.0\n        sigmax = np.array([[0, 1], [1, 0]], dtype=complex)\n        Ug = np.exp(-1j * kx * a / 2.0) * sigmax\n        return Ug\n\n    results = []\n    tolerance = 1e-8\n    \n    # Define high-symmetry momenta\n    k_X = (np.pi, 0.0)\n    k_M = (np.pi, np.pi)\n    k_Bmid = (np.pi, np.pi / 2.0)\n    momenta = [k_X, k_M, k_Bmid]\n\n    for params in test_cases:\n        case_results = []\n        \n        # 1. Check for degeneracies at X, M, B_mid\n        for k in momenta:\n            H = build_hamiltonian(k, params)\n            eigvals = np.linalg.eigvalsh(H)\n            is_degenerate = np.abs(eigvals[0] - eigvals[1])  tolerance\n            case_results.append(is_degenerate)\n            \n        # 2. Compute the Frobenius norm of the commutator [H(X), U_G(X)]\n        H_X = build_hamiltonian(k_X, params)\n        Ug_X = build_glide_op(k_X)\n        commutator = H_X @ Ug_X - Ug_X @ H_X\n        comm_norm = np.linalg.norm(commutator, 'fro')\n        case_results.append(comm_norm)\n        \n        results.append(case_results)\n\n    # Format the final output string as per the requirements\n    def format_case_result(res_list):\n        # [bool, bool, bool, float] -> \"[true,true,false,0.0]\"\n        bool_strs = [str(b).lower() for b in res_list[:3]]\n        float_str = str(res_list[3])\n        return f\"[{','.join(bool_strs)},{float_str}]\"\n\n    final_output_str = f\"[{','.join(map(format_case_result, results))}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}