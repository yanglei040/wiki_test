{
    "hands_on_practices": [
        {
            "introduction": "温度有两个等价的定义：一个来自统计力学，通过熵对能量的导数（$1/T = \\partial S / \\partial E$）得出；另一个来自经典动力学，通过平均动能得出。为了验证一个系统处于热平衡状态，这两个定义必须一致。本练习提供了一个动手实践的方法，通过一个简单且可解析求解的谐振子系统，来验证这一定义上的自洽性，从而在抽象的统计力学理论和具体的分子动力学模拟之间建立起桥梁。",
            "id": "3494648",
            "problem": "考虑一个由 $N$ 个独立的一维经典谐振子组成的系统，该系统在微正则系综中遵循确定性分子动力学演化。其哈密顿量为 $H(\\mathbf{x},\\mathbf{p}) = \\sum_{i=1}^{N} \\left( \\frac{p_i^2}{2 m} + \\frac{1}{2} m \\omega^2 x_i^2 \\right)$，其中 $m$ 是质量（单位：千克），$\\omega$ 是角频率（单位：弧度/秒），$x_i$ 是位置（单位：米），$p_i$ 是动量（单位：千克·米/秒）。微正则熵定义为 $S(E) = k_{\\mathrm{B}} \\ln \\Omega(E)$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数（单位：焦耳/开尔文），$\\Omega(E)$ 是能量小于或等于 $E$ 的微观状态的相空间体积。态密度为 $g(E) = \\partial \\Omega(E)/\\partial E$。微正则逆温度定义为 $1/T(E) = \\partial S(E) / \\partial E$。\n\n从上述定义和基本原理出发，推导一个通过在相空间中对能量壳层进行采样来重构此哈密顿量的态密度 $g(E)$ 的过程。根据重构的 $g(E)$，计算 $S(E)$，然后评估 $1/T(E) = \\partial S(E)/\\partial E$。另外，在相同的总能量 $E$ 下，执行微正则分子动力学（由牛顿定律支配、使用速度 Verlet 算法积分的恒定能量动力学），并通过动能的时间序列 $K(t)$，根据动能温度的经典定义来估算动能温度。比较这两个逆温度：从熵的导数获得的 $1/T(E)$ 和从 $K(t)$ 获得的 $1/T_{\\mathrm{kin}}$。\n\n您的程序必须实现以下功能：\n\n- 一个用于 $N$ 个独立谐振子的速度 Verlet 积分器，使用指定的 $m$ 和 $\\omega$、时间步长 $\\Delta t$（单位：秒）和给定的步数。随机初始化位置和速度，然后重新缩放它们以匹配一个精确的目标总能量 $E$（单位：焦耳）。\n- 从基本原理出发，通过在相空间中进行能量壳层采样来重构该哈密顿量的 $g(E)$。使用此重构计算 $S(E)$，然后计算 $1/T(E) = \\partial S/\\partial E$。\n- 根据分子动力学轨迹得到的 $K(t)$ 的时间平均值计算动能温度 $T_{\\mathrm{kin}}$。使用适用于具有 $N$ 个二次速度自由度的经典动能的关系式。\n\n对于每个测试用例，报告两个逆温度之间的相对差异，该差异定义为一个无单位小数：\n$$\n\\delta = \\frac{\\left| \\frac{1}{T(E)} - \\frac{1}{T_{\\mathrm{kin}}} \\right|}{\\frac{1}{T_{\\mathrm{kin}}}}.\n$$\n\n在整个过程中使用国际单位制（SI）：质量单位为千克，角频率单位为弧度/秒，时间单位为秒，能量单位为焦耳，温度单位为开尔文。除了角频率的规定外，不需要角度。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n\n测试套件（每个用例是一个元组 $(N, m, \\omega, E, \\Delta t, \\text{steps})$）：\n\n1. $(4,\\;6.6335209\\times 10^{-26}\\,\\mathrm{kg},\\;1.0\\times 10^{13}\\,\\mathrm{rad/s},\\;4 k_{\\mathrm{B}} \\cdot 300\\,\\mathrm{K},\\;1.0\\times 10^{-16}\\,\\mathrm{s},\\;80000)$\n2. $(4,\\;6.6335209\\times 10^{-26}\\,\\mathrm{kg},\\;1.0\\times 10^{13}\\,\\mathrm{rad/s},\\;4 k_{\\mathrm{B}} \\cdot 1\\,\\mathrm{K},\\;1.0\\times 10^{-16}\\,\\mathrm{s},\\;80000)$\n3. $(1,\\;6.6335209\\times 10^{-26}\\,\\mathrm{kg},\\;1.0\\times 10^{13}\\,\\mathrm{rad/s},\\;1 k_{\\mathrm{B}} \\cdot 270\\,\\mathrm{K},\\;1.0\\times 10^{-16}\\,\\mathrm{s},\\;120000)$\n4. $(8,\\;6.6335209\\times 10^{-26}\\,\\mathrm{kg},\\;1.0\\times 10^{13}\\,\\mathrm{rad/s},\\;8 k_{\\mathrm{B}} \\cdot 1200\\,\\mathrm{K},\\;1.0\\times 10^{-16}\\,\\mathrm{s},\\;60000)$\n\n您的程序应生成单行输出，其中包含四个 $\\delta$ 值，格式为以逗号分隔的列表并用方括号括起来（例如，\"[result1,result2,result3,result4]\"）。",
            "solution": "该问题要求对微正则系综中 $N$ 个独立的一维经典谐振子组成的系统的两种温度定义进行比较。第一种 $T(E)$ 源于统计力学中熵的定义。第二种 $T_{\\mathrm{kin}}$ 源于通过分子动力学模拟获得的时间平均动能。本解答将给出两者的理论推导，概述数值计算过程，并建立它们的理论等效性，所附程序将对此进行数值验证。\n\n### 1. 从态密度推导统计温度\n\n第一步是从微正则熵 $S(E) = k_{\\mathrm{B}} \\ln \\Omega(E)$ 推导统计温度 $T(E)$，其中 $\\Omega(E)$ 是能量小于或等于 $E$ 的状态的相空间体积。逆温度则由 $1/T(E) = \\partial S(E)/\\partial E$ 给出。\n\n系统的哈密顿量为：\n$$\nH(\\mathbf{x},\\mathbf{p}) = \\sum_{i=1}^{N} \\left( \\frac{p_i^2}{2 m} + \\frac{1}{2} m \\omega^2 x_i^2 \\right)\n$$\n相空间体积 $\\Omega(E)$ 是在 $H(\\mathbf{x},\\mathbf{p}) \\leq E$ 条件下对所有位置 $x_i$ 和动量 $p_i$ 的积分：\n$$\n\\Omega(E) = \\int_{H(\\mathbf{x},\\mathbf{p}) \\leq E} \\prod_{i=1}^{N} dx_i dp_i\n$$\n为了计算这个积分，我们进行变量替换，将不等式转换成一个超球面的方程。让我们定义新的坐标 $q_j$：\n$$\nq_{2i-1} = \\sqrt{\\frac{m \\omega^2}{2}} x_i \\quad \\text{以及} \\quad q_{2i} = \\frac{1}{\\sqrt{2m}} p_i\n$$\n在这些新坐标下，哈密顿量变为：\n$$\nH = \\sum_{i=1}^{N} (q_{2i-1}^2 + q_{2i}^2) = \\sum_{j=1}^{2N} q_j^2\n$$\n条件 $H \\leq E$ 现在是 $\\sum_{j=1}^{2N} q_j^2 \\leq E$，这描述了一个 $2N$ 维超球体的内部，其半径为 $R = \\sqrt{E}$。\n\n体积微元变换如下：\n$$\ndx_i = \\sqrt{\\frac{2}{m \\omega^2}} dq_{2i-1} \\quad \\text{以及} \\quad dp_i = \\sqrt{2m} dq_{2i}\n$$\n每个振子的雅可比行列式是 $J_i = \\sqrt{\\frac{2}{m \\omega^2}} \\sqrt{2m} = \\frac{2}{\\omega}$。对于整个 $N$-振子系统，相空间体积微元是：\n$$\n\\prod_{i=1}^{N} dx_i dp_i = \\left(\\frac{2}{\\omega}\\right)^N \\prod_{j=1}^{2N} dq_j\n$$\n相空间体积积分变为：\n$$\n\\Omega(E) = \\left(\\frac{2}{\\omega}\\right)^N \\int_{\\sum_{j=1}^{2N} q_j^2 \\leq E} \\prod_{j=1}^{2N} dq_j\n$$\n该积分是半径为 $R$ 的 $d$ 维超球体的体积，由公式 $V_d(R) = \\frac{\\pi^{d/2}}{\\Gamma(d/2 + 1)} R^d$ 给出。当 $d=2N$ 且 $R=\\sqrt{E}$ 时，体积为：\n$$\nV_{2N}(\\sqrt{E}) = \\frac{\\pi^N}{\\Gamma(N+1)} (\\sqrt{E})^{2N} = \\frac{(\\pi E)^N}{N!}\n$$\n将其代回，我们得到相空间体积：\n$$\n\\Omega(E) = \\left(\\frac{2}{\\omega}\\right)^N \\frac{(\\pi E)^N}{N!} = \\frac{1}{N!} \\left(\\frac{2\\pi E}{\\omega}\\right)^N\n$$\n问题要求的是态密度 $g(E)$，即 $\\Omega(E)$ 的导数：\n$$\ng(E) = \\frac{\\partial \\Omega(E)}{\\partial E} = \\frac{1}{N!} \\left(\\frac{2\\pi}{\\omega}\\right)^N \\frac{\\partial (E^N)}{\\partial E} = \\frac{N}{N!} \\left(\\frac{2\\pi}{\\omega}\\right)^N E^{N-1} = \\frac{1}{(N-1)!} \\left(\\frac{2\\pi}{\\omega}\\right)^N E^{N-1}\n$$\n对于这个特定的哈密顿量，这一解析推导构成了从第一性原理出发所要求的 $g(E)$ 的“重构”。熵则为：\n$$\nS(E) = k_{\\mathrm{B}} \\ln \\Omega(E) = k_{\\mathrm{B}} \\ln \\left[ \\frac{1}{N!} \\left(\\frac{2\\pi}{\\omega}\\right)^N E^N \\right] = k_{\\mathrm{B}} \\left( \\ln\\left[\\frac{1}{N!} \\left(\\frac{2\\pi}{\\omega}\\right)^N\\right] + N \\ln E \\right)\n$$\n微正则逆温度 $1/T(E)$ 是熵对能量的导数：\n$$\n\\frac{1}{T(E)} = \\frac{\\partial S(E)}{\\partial E} = k_{\\mathrm{B}} \\frac{\\partial}{\\partial E} (N \\ln E) = \\frac{N k_{\\mathrm{B}}}{E}\n$$\n这提供了逆温度的第一个纯理论值。\n\n### 2. 从分子动力学推导动能温度\n\n第二种方法是通过分子动力学（MD）模拟计算动能温度 $T_{\\mathrm{kin}}$。动能温度的经典定义源于能量均分定理，该定理指出哈密顿量中每个二次自由度对系统的平均能量贡献为 $\\frac{1}{2} k_{\\mathrm{B}} T$。\n\n系统的总动能为 $K = \\sum_{i=1}^{N} \\frac{p_i^2}{2m}$。这是 $N$ 个二次项（每个动量 $p_i$ 一项）的和。根据能量均分定理，时间平均总动能 $\\langle K \\rangle$ 与动能温度 $T_{\\mathrm{kin}}$ 的关系为：\n$$\n\\langle K \\rangle = N \\cdot \\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{kin}}\n$$\n由此，我们可以将动能逆温度表示为：\n$$\n\\frac{1}{T_{\\mathrm{kin}}} = \\frac{N k_{\\mathrm{B}}}{2 \\langle K \\rangle}\n$$\n$\\langle K \\rangle$ 的值通过执行恒定能量的 MD 模拟并在长轨迹上对瞬时动能进行平均来获得。\n\n模拟过程如下：\n1.  **初始化**：$N$ 个位置 $x_i$ 和 $N$ 个速度 $v_i$ 通过从标准正态分布中抽取的随机值进行初始化。初始动量为 $p_i = m v_i$。根据这些初始条件计算初始总能量 $E_{\\mathrm{init}}$。然后，位置和动量通过一个因子 $\\lambda = \\sqrt{E / E_{\\mathrm{init}}}$进行重新缩放，其中 $E$ 是目标总能量。这确保了模拟从微正则系综所要求的精确能量开始。\n2.  **积分**：使用速度 Verlet 算法传播轨迹，这是一种时间可逆的辛积分器，能为长时间模拟提供出色的能量守恒性。对于振子 $i$，力为 $F_i = -m \\omega^2 x_i$，因此加速度为 $a_i = -\\omega^2 x_i$。在一个时间步长 $\\Delta t$ 内，位置 $x_i$ 和速度 $v_i$ 的更新步骤如下：\n    $$\n    v_i(t + \\Delta t/2) = v_i(t) + \\frac{1}{2} a_i(t) \\Delta t\n    $$\n    $$\n    x_i(t + \\Delta t) = x_i(t) + v_i(t + \\Delta t/2) \\Delta t\n    $$\n    $$\n    a_i(t + \\Delta t) = -\\omega^2 x_i(t + \\Delta t)\n    $$\n    $$\n    v_i(t + \\Delta t) = v_i(t + \\Delta t/2) + \\frac{1}{2} a_i(t + \\Delta t) \\Delta t\n    $$\n3.  **平均**：在模拟过程中，每一步都会计算瞬时动能 $K(t) = \\sum_{i=1}^N \\frac{(m v_i(t))^2}{2m}$ 并进行累加。在模拟结束时计算时间平均值 $\\langle K \\rangle$。\n\n### 3. 比较与理论等效性\n\n对于经典谐振子系统，维里定理指出总动能的时间平均值等于总势能的时间平均值，即 $\\langle K \\rangle = \\langle V \\rangle$。由于在微正则系综中总能量 $E = K + V$ 是守恒的，我们有 $E = \\langle K + V \\rangle = \\langle K \\rangle + \\langle V \\rangle$。这意味着 $\\langle K \\rangle = E/2$。\n\n将这个预期结果代入动能温度的表达式中，得到：\n$$\n\\frac{1}{T_{\\mathrm{kin}}} = \\frac{N k_{\\mathrm{B}}}{2 \\langle K \\rangle} = \\frac{N k_{\\mathrm{B}}}{2 (E/2)} = \\frac{N k_{\\mathrm{B}}}{E}\n$$\n这与从统计力学推导出的 $1/T(E)$ 的表达式完全相同。因此，对于该系统，这两种温度定义在理论上是等效的。本计算的目的是数值验证这种等效性。相对差异 $\\delta$ 将量化由有限时间步长和有限模拟时长引起的任何偏差。一个小的 $\\delta$ 值证实了温度的统计图像和动力学图像的一致性，以及 MD 模拟的准确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.constants import k as k_B\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite from the problem statement.\n    # Each case is a tuple (N, m, omega, E_factor, T_factor, dt, steps)\n    # where E = N * k_B * T_factor for cases 1,3,4 and 4*k_B*T_factor for case 2\n    test_cases_raw = [\n        (4, 6.6335209e-26, 1.0e13, 4, 300, 1.0e-16, 80000),\n        (4, 6.6335209e-26, 1.0e13, 4, 1, 1.0e-16, 80000),\n        (1, 6.6335209e-26, 1.0e13, 1, 270, 1.0e-16, 120000),\n        (8, 6.6335209e-26, 1.0e13, 8, 1200, 1.0e-16, 60000),\n    ]\n\n    test_cases = []\n    for i, case in enumerate(test_cases_raw):\n        N, m, omega, E_factor, T_factor, dt, steps = case\n        # Energy E is defined as N * k_B * T for all cases in the problem logic\n        # For N=4, E=4*kB*T. For N=1, E=1*kB*T. For N=8, E=8*kB*T.\n        E = E_factor * k_B * T_factor\n        test_cases.append((N, m, omega, E, dt, steps))\n\n    results = []\n    for case in test_cases:\n        delta = compute_relative_difference(case)\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_relative_difference(case_params):\n    \"\"\"\n    Computes the relative difference delta for a single test case.\n    \"\"\"\n    N, m, omega, E_target, dt, n_steps = case_params\n\n    # ======== 1. Statistical Temperature T(E) ========\n    # From the derivation, 1/T(E) = N * k_B / E\n    inv_T_statistical = (N * k_B) / E_target\n\n    # ======== 2. Kinetic Temperature T_kin from MD ========\n    # Perform MD simulation to get the time-averaged kinetic energy"
        },
        {
            "introduction": "微正则系综中计算的平均值依赖于遍历假设，即单个轨迹的时间平均等于整个能量面上的系综平均。本练习将介绍两种强大的诊断工具——时间自相关函数和庞加莱截面，用于从视觉上和定量上评估模拟是否充分“混合”并探索了所有可及的相空间。理解这些诊断方法至关重要，可以避免因模拟轨迹被困在相空间的微小区域而导致的计算结果偏差。",
            "id": "3494707",
            "problem": "编写一个完整、可运行的程序，为微正则系综中的哈密顿分子动力学，在恒定能量流形上实现并应用一种基于原理的混合诊断方法。您的诊断必须结合两个独立的判据：(i) 一个可观测量的时间自相关的衰减，以及 (ii) 能量壳上庞加莱截面的覆盖率。然后，量化一个对称性选择的可观量的有限时间微正则偏差。设计必须从基本定义和定律出发，不使用简便公式。\n\n您必须将您的推导和算法建立在以下基本原理之上：\n- 适用于哈密顿系统的牛顿力学，其中位置 $q$ 和动量 $p$ 遵循哈密顿方程 $\\dot{q} = \\partial H / \\partial p$ 和 $\\dot{p} = - \\partial H / \\partial q$，其中 $H(q,p)$ 是哈密顿量。\n- 微正则系综由能量壳 $H(q,p)=E$ 上的均匀不变密度定义，其中总能量为 $E$。对于一个相函数（可观测量）$A(q,p)$，微正则期望 $\\langle A \\rangle_{\\mu E}$ 是 $A$ 在能量壳上相对于不变测度的平均值。\n- 能量壳上的混合意味着中心化可观测量的时间相关性在长时间后会衰减到零，并且轨道以一种能够填充庞加莱截面中类面积区域的方式探索可达流形（而不是像可积动力学那样位于光滑曲线上）。\n- 对于沿哈密顿轨道由有界可观测量构建的平稳时间序列 $a(t)$，定义涨落 $\\delta a(t) = a(t) - \\overline{a}$，其中 $\\overline{a}$ 是在有限区间上的时间平均。定义归一化自相关 $\\rho(\\tau) = C(\\tau)/C(0)$，其中 $C(\\tau) = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\delta a(t)\\,\\delta a(t+\\tau)\\,dt$。在有限 $T$ 的计算中，使用长轨道通过离散时间估计量来近似 $C(\\tau)$。\n- 庞加莱截面由一个余维一曲面定义，此处对于二维系统取为 $y=0$ 且 $p_y>0$。由长轨道在能量 $E$ 下产生的一组截面点 $(x,p_x)$ 位于截面的能量允许区域内。对于可积系统，截面点位于光滑的不变曲线上；对于混合（混沌）系统，截面点填充正面积区域。\n\n算法要求与可观测量选择：\n- 您必须使用辛速度-Verlet格式，以恒定时间步长 $dt$ 对每个哈密顿系统进行积分，以最小化能量漂移。\n- 对于每个系统，定义一个标量可观测量 $A(q,p)$，在指定能量下，其微正则期望因对称性而已知：\n  - 各向同性二维谐振子：$A(t) = x(t)^2 - y(t)^2$，因能量壳上的对称性，其微正则期望为 $\\langle A \\rangle_{\\mu E} = 0$。\n  - Henon–Heiles系统：$A(t) = x(t)$，因哈密顿量的 $x \\mapsto -x$ 对称性，其微正则期望为 $\\langle A \\rangle_{\\mu E} = 0$。\n  - 对称一维双阱：$A(t) = x(t)$，因 $x \\mapsto -x$ 对称性，其微正则期望为 $\\langle A \\rangle_{\\mu E} = 0$。\n- 定义偏差的有限时间估计为 $b_T = \\left|\\overline{A}_T - \\langle A \\rangle_{\\mu E}\\right|$，其中 $\\overline{A}_T$ 是 $A$ 在模拟时间 $T$ 上的时间平均。\n- 定义在固定延迟窗口上的积分绝对相关时间为\n$$\n\\tau_{\\mathrm{abs}} = dt \\sum_{k=1}^{K} \\left|\\rho(k\\,dt)\\right|,\n$$\n其中 $K$ 的选择对应于一个窗口 $T_{\\mathrm{lag}} = K\\,dt$，该窗口远小于总模拟时间，但远大于微观时间尺度。\n- 为二维系统定义庞加莱覆盖分数如下：利用 $y=0$ 且 $p_y>0$ 的穿越事件，记录穿越时刻的 $(x,p_x)$。将截面上固定的能量允许区域划分为一个均匀的 $G \\times G$ 网格，并计算至少被访问过一次的网格单元的比例。对于二维各向同性谐振子和Henon–Heiles系统中选定的截面 $y=0$ 和能量 $E$，允许区域是圆盘 $x^2 + p_x^2 \\le 2E$。对于一维系统，报告覆盖分数为 $0$，因为所选截面不适用。\n\n混合判定规则：\n- 当且仅当以下两个条件同时成立时，宣布轨道是混合的：$\\tau_{\\mathrm{abs}} < \\tau_{\\mathrm{thr}}$ 并且覆盖分数超过阈值 $c_{\\mathrm{thr}}$，阈值将在下面指定。\n\n数值细节、单位和测试套件：\n- 全程使用无量纲单位。\n- 对每个系统使用时间步长为 $dt = 10^{-2}$、总步数为 $N = 60000$ 的速度-Verlet积分器，总模拟时间为 $T = N \\, dt = 600$。\n- 使用快速卷积方法计算归一化自相关，并取 $T_{\\mathrm{lag}} = 50$，因此 $K = T_{\\mathrm{lag}}/dt = 5000$。按上述定义计算 $\\tau_{\\mathrm{abs}}$。\n- 对于庞加莱覆盖，在正方形 $[-R,R] \\times [-R,R]$（其中 $R = \\sqrt{2E}$）上使用均匀的 $G \\times G$ 网格（$G = 64$），并通过中心位于圆盘 $x^2 + p_x^2 \\le 2E$ 内的网格单元数量来归一化覆盖率。\n- 混合判定的阈值：$\\tau_{\\mathrm{thr}} = 10$ 和 $c_{\\mathrm{thr}} = 0.05$。\n\n模拟以下三个系统（这组参数值构成所需的测试套件）：\n- 情况1（二维各向同性谐振子）：哈密顿量 $H = \\frac{1}{2}(p_x^2 + p_y^2) + \\frac{1}{2}(x^2 + y^2)$，总能量 $E = 1$。初始条件 $(x_0,y_0,p_{x,0},p_{y,0}) = (1,0,1,0)$。可观测量 $A(t)=x(t)^2 - y(t)^2$。对于这种情况，微正则值为 $\\langle A \\rangle_{\\mu E} = 0$。\n- 情况2（Henon–Heiles）：哈密顿量 $H = \\frac{1}{2}(p_x^2 + p_y^2) + \\frac{1}{2}(x^2 + y^2) + x^2 y - \\frac{1}{3} y^3$，总能量 $E = 0.12$。初始条件 $(x_0,y_0,p_{x,0}) = (0,0.1,0)$，并选择 $p_{y,0} > 0$ 以满足 $H=E$。可观测量 $A(t)=x(t)$。对于这种情况，微正则值为 $\\langle A \\rangle_{\\mu E} = 0$。\n- 情况3（一维对称双阱）：哈密顿量 $H = \\frac{1}{2}p^2 + \\frac{1}{4}(x^2 - 1)^2$，总能量 $E = 0.1$。初始条件 $x_0 = -1$，选择 $p_0 > 0$ 以满足 $H=E$。可观测量 $A(t)=x(t)$。对于这种情况，微正则值为 $\\langle A \\rangle_{\\mu E} = 0$。\n\n程序输出规范：\n- 对于每种情况，计算布尔类型的混合判定结果和绝对偏差 $b_T$。您的程序应生成单行输出，其中包含一个由三个双元素列表组成的列表，按情况顺序排列，每个内部列表的形式为 $[\\text{mixing\\_boolean}, \\text{bias}]$。混合布尔值必须是编程语言的布尔类型。偏差必须是四舍五入到六位小数的浮点数。例如，输出行可能看起来像 $[[\\text{True},0.012345],[\\text{False},0.678901],[\\text{False},0.234567]]$。",
            "solution": "问题陈述经评估有效。它在科学上植根于经典力学和统计力学，是良构的，提供了所有必要的参数和定义，并且其表述是客观的。该问题要求为哈密顿系统中的混合实现一种复杂的诊断方法，这是计算物理学中的一项典型任务。它结合了时间分析（自相关）和相空间几何分析（庞加莱截面），以对三个广为人知的模型系统的动力学进行分类。\n\n解决方案首先从基本原理构建必要的组件，然后将它们应用于三个指定的测试案例。\n\n### 1. 理论基础与数值积分\n\n每个系统的动力学由哈密顿量 $H(q,p)$ 控制，其中 $q$ 是广义坐标，$p$ 是共轭动量。时间演化遵循哈密顿运动方程：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p}, \\quad \\dot{p} = - \\frac{\\partial H}{\\partial q}\n$$\n对于指定形式为 $H(q,p) = \\frac{1}{2m}p^2 + V(q)$ 的哈密顿量，并假设单位质量（$m=1$），这些方程变为 $\\dot{q} = p$ 和 $\\dot{p} = -\\nabla V(q) = F(q)$，其中 $F(q)$ 是从势能 $V(q)$ 导出的力。\n\n为了在数值上积分这些运动方程，同时保持哈密顿流的几何结构并确保良好的能量守恒，我们采用**辛速度-Verlet算法**。对于时间步长 $dt$，该算法将位置和动量从时间 $t$ 更新到 $t+dt$ 的过程如下：\n1.  将动量更新半步：$p(t + dt/2) = p(t) + F(q(t)) \\cdot (dt/2)$。\n2.  使用半步动量将位置更新一个完整步长：$q(t + dt) = q(t) + p(t + dt/2) \\cdot dt$。\n3.  在新位置计算新力 $F(q(t + dt))$。\n4.  完成动量更新：$p(t + dt) = p(t + dt/2) + F(q(t + dt)) \\cdot (dt/2)$。\n\n这个过程重复 $N=60000$ 步，步长为 $dt=10^{-2}$，以生成总时长为 $T=600$ 的轨道。\n\n### 2. 混合的诊断度量\n\n微正则系综描述了一个总能量恒为 $E$ 的孤立系统。遍历假设断言，对于一个混沌系统，沿单一长轨道的时间平均等同于在恒能面上的系综平均。如果一个系统是遍历的，并且可观测量之间的相关性随时间衰减，则该系统是**混合的**。我们使用两个度量来测试混合行为。\n\n#### 2.1. 自相关时间 $\\tau_{\\mathrm{abs}}$\n\n对于一个可观测量 $A(t)$ 的平稳时间序列，我们首先计算其在轨道上的时间平均值 $\\overline{A}_T$。涨落为 $\\delta A(t) = A(t) - \\overline{A}_T$。归一化时间自相关函数为：\n$$\n\\rho(\\tau) = \\frac{C(\\tau)}{C(0)}, \\quad \\text{其中} \\quad C(\\tau) = \\langle \\delta A(t) \\delta A(t+\\tau) \\rangle_t\n$$\n在混合系统中，当 $\\tau \\to \\infty$ 时，$\\rho(\\tau) \\to 0$。在非遍历或可积系统中，$\\rho(\\tau)$ 可能表现出持续振荡。我们通过计算在延迟窗口 $T_{\\mathrm{lag}} = K\\,dt = 50$ 上的积分绝对相关时间来量化衰减速率：\n$$\n\\tau_{\\mathrm{abs}} = dt \\sum_{k=1}^{K} \\left|\\rho(k\\,dt)\\right|\n$$\n一个小的 $\\tau_{\\mathrm{abs}}$ 表示快速衰减，是混合的一个标志。自相关通过基于快速傅里叶变换（FFT）的卷积方法（Wiener-Khinchin定理）高效计算。\n\n#### 2.2. 庞加莱截面覆盖率\n\n庞加莱截面提供了相空间动力学的几何视图。对于我们的二维系统，我们通过平面 $y=0$ 定义截面，并记录轨道每次以正 $y$ 方向动量（$p_y>0$）穿过该平面时的状态 $(x, p_x)$。\n-   对于一个**可积**系统，这些点位于光滑的一维曲线上（不变环面）。\n-   对于一个**混合**系统，这些点似乎填充了截面上的一个二维区域，对应于在能量流形上的混沌漫游。\n\n为了量化这一点，我们用一个均匀的 $G \\times G$ 网格（其中 $G=64$）对截面的可及区域 $x^2 + p_x^2 \\le 2E$ 进行离散化。覆盖分数是轨道至少访问过一次的网格单元数，除以其中心位于可及圆盘内的网格单元总数。高覆盖分数表示与混合一致的混沌、面积填充行为。对于一维系统，此特定截面不适用，覆盖率定义为 $0$。\n\n### 3. 有限时间偏差与混合判定\n\n**有限时间偏差** $b_T$ 衡量了可观测量的时间平均计算值 $\\overline{A}_T$ 与其真实的微正则期望 $\\langle A \\rangle_{\\mu E}$ 之间的偏离。所选的可观测量因对称性而满足 $\\langle A \\rangle_{\\mu E} = 0$。因此，偏差就是：\n$$\nb_T = \\left|\\overline{A}_T\\right|\n$$\n大的偏差表明轨道未能遍历地探索相空间。\n\n最终的**混合判定**结合了我们的两个判据。当且仅当以下两个条件都满足时，轨道被判定为`混合`：\n1.  积分相关时间小：$\\tau_{\\mathrm{abs}}  < \\tau_{\\mathrm{thr}}$（$\\tau_{\\mathrm{thr}} = 10$）。\n2.  庞加莱覆盖率显著：`coverage` $> c_{\\mathrm{thr}}$（$c_{\\mathrm{thr}} = 0.05$）。\n\n### 4. 在测试系统上的应用\n\n该框架应用于三个系统：\n\n1.  **各向同性谐振子 ($E=1$)**: 这个系统是完全可积的。所选的初始条件 $(1,0,1,0)$ 导致沿 $x$ 轴的平凡轨道，其中 $y(t) \\equiv 0$ 且 $p_y(t) \\equiv 0$。它永远不会以 $p_y>0$ 穿过庞加莱截面，导致覆盖率为零。可观测量 $A(t) = x(t)^2 - y(t)^2 = x(t)^2$ 是周期的，导致非衰减的相关函数和大的 $\\tau_{\\mathrm{abs}}$。该系统被正确地识别为**非混合**。\n\n2.  **Henon-Heiles系统 ($E=0.12$)**: 在这个能量下，该系统已知主要表现为混沌。我们预期轨道会探索能量壳的很大一部分体积。$A(t)=x(t)$ 的自相关应迅速衰减，庞加莱截面应被密集填充。该系统应被识别为**混合**，并且由于相空间的对称探索，偏差应该很小。\n\n3.  **对称双阱 ($E=0.1$)**: 势垒高度为 $V(0) = 0.25$。由于总能量 $E=0.1$ 低于势垒高度，从一个阱（在 $x_0=-1$）开始的轨道将被困在该阱中。它无法探索整个能量面，这违反了遍历性。$A(t)=x(t)$ 的时间平均值将是负的，而不是对称期望值 $0$，导致大的偏差。运动是周期的，因此 $\\tau_{\\mathrm{abs}}$ 会很大。庞加莱覆盖率定义为 $0$。该系统被正确地识别为**非混合**。\n\n实现细节遵循问题中指定的数值参数，包括初始动量的计算和分析度量的具体定义。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import fftconvolve\n\n# This program must be run with:\n# python 3.12\n# numpy 1.23.5\n# scipy 1.11.4\n\ndef solve():\n    \"\"\"\n    Main function to run the mixing diagnostics on three Hamiltonian systems.\n    \"\"\"\n    # Global numerical parameters from the problem statement\n    DT = 1e-2\n    N_STEPS = 60000\n    T_LAG = 50.0\n    K_STEPS = int(T_LAG / DT)\n    GRID_SIZE = 64\n    TAU_THR = 10.0\n    C_THR = 0.05\n\n    # --- System Definitions ---\n\n    # Case 1: Isotropic Harmonic Oscillator\n    def ho_force(q):\n        return -q\n    def ho_observable(q, p):\n        return q[0]**2 - q[1]**2\n\n    # Case 2: Henon-Heiles\n    def hh_force(q):\n        x, y = q\n        fx = -x - 2 * x * y\n        fy = -y - x**2 + y**2\n        return np.array([fx, fy])\n    def hh_observable(q, p):\n        return q[0]\n\n    # Case 3: 1D Symmetric Double Well\n    def dw_force(q):\n        x = q[0]\n        fx = x - x**3\n        return np.array([fx])\n    def dw_observable(q, p):\n        return q[0]\n\n    # --- Core Simulation and Analysis Functions ---\n\n    def velocity_verlet_integrator(z0, dim, force_func, dt, n_steps):\n        \"\"\"\n        Integrates Hamiltonian dynamics using the velocity-Verlet algorithm.\n        Also detects and records Poincaré section crossings for 2D systems.\n        \"\"\"\n        z_history = np.zeros((n_steps + 1, 2 * dim))\n        z = z0.copy()\n        z_history[0] = z\n        \n        poincare_points = []\n\n        q_old, p_old = None, None\n\n        for i in range(n_steps):\n            q = z[:dim]\n            p = z[dim:]\n\n            if dim == 2:\n                q_old = q.copy()\n            \n            # Velocity-Verlet update\n            p_half = p + force_func(q) * (dt / 2.0)\n            q_new = q + p_half * dt\n            p_new = p_half + force_func(q_new) * (dt / 2.0)\n            \n            z[:dim], z[dim:] = q_new, p_new\n            z_history[i + 1] = z\n\n            # Poincaré section detection for 2D systems (y=0, py>0)\n            if dim == 2:\n                y_old, y_new = q_old[1], q_new[1]\n                if y_old * y_new  0 and p_new[1] > 0:\n                    # Linear interpolation to find the crossing point\n                    alpha = -y_old / (y_new - y_old)\n                    x_cross = q_old[0] + alpha * (q_new[0] - q_old[0])\n                    px_cross = z_history[i, 2] + alpha * (p_new[0] - z_history[i, 2])\n                    poincare_points.append((x_cross, px_cross))\n\n        return z_history, poincare_points\n\n    def calculate_autocorrelation(A_series, k_max, dt):\n        \"\"\"\n        Calculates the normalized autocorrelation and the integrated absolute correlation time.\n        \"\"\"\n        signal = A_series - np.mean(A_series)\n        n = len(signal)\n        # Using FFT for fast convolution\n        autocov = fftconvolve(signal, signal[::-1], mode='full')[n - 1:]\n        \n        # Biased estimator for autocovariance\n        autocov /= n\n        \n        # Avoid division by zero if variance is nil\n        if autocov[0] == 0:\n            return 0.0\n\n        rho = autocov / autocov[0]\n        \n        tau_abs = dt * np.sum(np.abs(rho[1:k_max + 1]))\n        return tau_abs\n\n    def calculate_poincare_coverage(points, E, G):\n        \"\"\"\n        Calculates the coverage fraction of a Poincaré section.\n        \"\"\"\n        if not points:\n            return 0.0\n\n        R = np.sqrt(2 * E)\n        \n        # Calculate the total number of grid cells within the allowed domain\n        grid_coords = np.linspace(-R, R, G, endpoint=False) + R/G\n        centers_x, centers_y = np.meshgrid(grid_coords, grid_coords)\n        in_disk = centers_x**2 + centers_y**2 = 2 * E\n        total_allowed_cells = np.sum(in_disk)\n\n        if total_allowed_cells == 0:\n            return 0.0\n\n        visited_cells = set()\n        for x, px in points:\n            if -R = x  R and -R = px  R:\n                ix = int((x + R) / (2 * R) * G)\n                ipx = int((px + R) / (2 * R) * G)\n                visited_cells.add((ix, ipx))\n        \n        coverage = len(visited_cells) / total_allowed_cells\n        return coverage\n\n    def process_case(case, dt, n_steps, k_steps, grid_size, tau_thr, c_thr):\n        \"\"\"\n        Processes a single test case: runs simulation and performs analysis.\n        \"\"\"\n        # Run integrator\n        state_history, poincare_points = velocity_verlet_integrator(\n            case[\"ic\"], case[\"dim\"], case[\"force_func\"], dt, n_steps\n        )\n\n        # Calculate observable time series\n        q_history = state_history[:, :case[\"dim\"]]\n        p_history = state_history[:, case[\"dim\"]:]\n        A_series = np.array([case[\"observable_func\"](q, p) for q, p in zip(q_history, p_history)])\n        \n        # Calculate bias\n        A_mean = np.mean(A_series)\n        bias = np.abs(A_mean - case[\"mu_A\"])\n\n        # Calculate correlation time\n        tau_abs = calculate_autocorrelation(A_series, k_steps, dt)\n        \n        # Calculate Poincaré coverage\n        if case[\"dim\"] == 2:\n            coverage = calculate_poincare_coverage(poincare_points, case[\"E\"], grid_size)\n        else:\n            coverage = 0.0\n            \n        # Apply mixing decision rule\n        is_mixing = (tau_abs  tau_thr) and (coverage > c_thr)\n        \n        return is_mixing, bias\n\n    # --- Test Suite Setup and Execution ---\n\n    test_cases = [\n        # Case 1: Harmonic Oscillator\n        {\n            \"name\": \"HO\", \"dim\": 2, \"force_func\": ho_force,\n            \"observable_func\": ho_observable, \"E\": 1.0,\n            \"ic\": np.array([1.0, 0.0, 1.0, 0.0]), \"mu_A\": 0.0\n        },\n        # Case 2: Henon-Heiles\n        {\n            \"name\": \"HH\", \"dim\": 2, \"force_func\": hh_force,\n            \"observable_func\": hh_observable, \"E\": 0.12,\n            \"ic\": np.array([0.0, 0.1, 0.0, 0.0]), \"mu_A\": 0.0\n        },\n        # Case 3: Double Well\n        {\n            \"name\": \"DW\", \"dim\": 1, \"force_func\": dw_force,\n            \"observable_func\": dw_observable, \"E\": 0.1,\n            \"ic\": np.array([-1.0, 0.0]), \"mu_A\": 0.0\n        }\n    ]\n\n    # Complete initial conditions using energy constraint\n    # Case 2: Henon-Heiles\n    E2, q2, p2x = test_cases[1][\"E\"], test_cases[1][\"ic\"][:2], test_cases[1][\"ic\"][2]\n    V2 = 0.5 * (q2[0]**2 + q2[1]**2) + q2[0]**2 * q2[1] - (q2[1]**3) / 3.0\n    p2y_sq = 2 * (E2 - V2) - p2x**2\n    test_cases[1][\"ic\"][3] = np.sqrt(p2y_sq)\n\n    # Case 3: Double Well\n    E3, q3 = test_cases[2][\"E\"], test_cases[2][\"ic\"][0]\n    V3 = 0.25 * (q3**2 - 1.0)**2\n    p3_sq = 2 * (E3 - V3)\n    test_cases[2][\"ic\"][1] = np.sqrt(p3_sq)\n\n    # Process all cases and collect results\n    results = []\n    for case in test_cases:\n        is_mixing, bias = process_case(\n            case, DT, N_STEPS, K_STEPS, GRID_SIZE, TAU_THR, C_THR\n        )\n        results.append([is_mixing, round(bias, 6)])\n\n    # Final print statement in the exact required format\n    # The default str() representation of lists has spaces, which we remove\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "对于从正则系综（$NVT$）过渡而来的学习者，一个常见的陷阱是：在微正则系综（$NVE$）模拟中，热容（$C_V$）不能通过总能量的涨落来计算，因为总能量是守恒的。本练习明确地展示了这种方法的失效，并提供了通过熵的二阶导数（$\\partial^2 S / \\partial E^2$）来计算 $C_V$ 的正确微正则路径。这个练习能够加深对不同系综之间差异的理解，并为学生提供在 $NVE$ 模拟中计算响应函数的正确理论工具。",
            "id": "3494674",
            "problem": "您正在研究用于经典分子动力学的定数-定容-定能（$NVE$）微正则系综，及其对估算模型材料热容 $C$ 的影响。在正则（$NVT$）系综中，人们通常使用将热容与能量涨落联系起来的涨落公式。然而，在微正则（$NVE$）系综中，总能量是守恒的，因此正则涨落公式对于 $C$ 失效。您的目标是通过测量 $NVE$ 中动能 $K$ 的涨落来证明这一失效，然后利用熵 $S(E)$ 相对于能量的曲率，构建一个正确的微正则系综下的 $C$ 的替代方案。\n\n请将您的推理和计算基于以下原理和事实：\n- 具有可分离动能和势能的经典系统的牛顿哈密顿动力学：$H = K + U$，其中 $K = \\sum_i p_i^2/(2m_i)$ 且 $U$ 是位置的函数。\n- 微正则系综由能量壳层 $H(\\mathbf{p},\\mathbf{q}) = E$ 上的均匀概率密度定义，吉布斯熵 $S(E)$ 可定义为 $S(E) = k_{\\mathrm{B}} \\ln \\Phi(E)$，其中 $\\Phi(E)$ 是由能量曲面 $H \\leq E$ 包围的相空间体积。\n- 经典系统中的能量均分定理指出，每个二次自由度在热平衡时对平均能量的贡献为 $k_{\\mathrm{B}} T / 2$，对于具有许多自由度的微正则系统，当使用吉布斯熵温度时，该关系在主导阶上同样成立。\n- 对于只有二次动能项的类理想气体系统，相空间体积的标度关系为 $\\Phi(E) \\propto E^{f/2}$，其中 $f$ 是二次动量自由度的数量。\n- 对于具有二次动能项和二次势能项（非耦合或通过线性变换耦合）的谐振子网络系统，相空间体积的标度关系为 $\\Phi(E) \\propto E^{f}$，其中 $f$ 是二次动量自由度的数量（总共有 $2f$ 个二次项贡献，$f$ 个来自势头，$f$ 个来自坐标）。\n\n任务：\n1. 对于下面的每个测试用例，在微正则（$NVE$）条件下，通过对微正则分布进行采样，生成动能方差 $\\langle K^2 \\rangle - \\langle K \\rangle^2$ 的测量值。对于具有二次模式的谐振子网络，分数 $x = K/E$ 服从 $(0,1)$ 上的Beta分布，参数为 $a = f/2, b = f/2$，这是因为能量球面上的均匀测度被分成了 $f$ 个动量和 $f$ 个坐标的二次贡献。对于只有动能的理想气体，$K \\equiv E$，因此 $x \\equiv 1$ 且方差为零。\n2. 使用您测量的 $\\langle K \\rangle$，通过能量均分定理定义一个微正则温度 $T = 2 \\langle K \\rangle / (f k_{\\mathrm{B}})$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，单位为焦耳/开尔文。\n3. 通过将动能方差代入正则公式，计算一个朴素的正则涨落估计值 $C_{\\mathrm{fluct}}$：设 $C_{\\mathrm{fluct}} = (\\langle K^2 \\rangle - \\langle K \\rangle^2) / (k_{\\mathrm{B}} T^2)$。这是一个对正则公式的故意误用，您必须对其进行量化。\n4. 利用吉布斯熵 $S(E)$ 相对于能量的曲率，构建一个正确的微正则热容 $C_{\\mathrm{micro}}$。不要使用任何正则涨落公式。相反，从微正则热力学中温度的定义出发，推导出一个用 $S(E)$ 对 $E$ 的导数表示 $C_{\\mathrm{micro}}$ 的关系式。利用给定两种系统类型的 $\\Phi(E)$ 的标度形式，使这些导数具体化，然后计算 $C_{\\mathrm{micro}}$。\n5. 对于每个测试用例，输出两个值：$C_{\\mathrm{fluct}}$ 和 $C_{\\mathrm{micro}}$，单位均为焦耳/开尔文，以64位浮点数形式。\n\n要求：\n- 所有能量必须以焦耳（$\\mathrm{J}$）为单位，温度以开尔文（$\\mathrm{K}$）为单位，热容以焦耳/开尔文（$\\mathrm{J/K}$）为单位。\n- 此计算不涉及角度。\n- 不涉及百分比；任何比率都必须以小数形式报告。\n- 采样时使用固定的随机种子以保证可复现性。\n- 测试套件：\n  - 案例1（边界行为，小自由度）：谐振子网络，$f = 2$, $E = 1.0 \\times 10^{-20}\\ \\mathrm{J}$。\n  - 案例2（较大系统，多自由度）：谐振子网络，$f = 30$, $E = 1.0 \\times 10^{-19}\\ \\mathrm{J}$。\n  - 案例3（边缘情况，仅动能的理想气体）：理想气体，$f = 6$, $E = 1.0 \\times 10^{-21}\\ \\mathrm{J}$。\n  - 案例4（中等规模谐振子网络）：谐振子网络，$f = 6$, $E = 1.0 \\times 10^{-21}\\ \\mathrm{J}$。\n- 采样规范：\n  - 对于谐振子网络情况，从 $\\mathrm{Beta}(a,b)$ 分布中采样 $x$，其中 $a = f/2$, $b = f/2$，然后设 $K = x E$。为保证精度，至少使用 $5 \\times 10^{4}$ 个样本。\n  - 对于理想气体，对所有样本设置 $K = E$。\n- 最终输出格式：\n  - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含8个数字，顺序为 $[C_{\\mathrm{fluct}}^{(1)}, C_{\\mathrm{micro}}^{(1)}, C_{\\mathrm{fluct}}^{(2)}, C_{\\mathrm{micro}}^{(2)}, C_{\\mathrm{fluct}}^{(3)}, C_{\\mathrm{micro}}^{(3)}, C_{\\mathrm{fluct}}^{(4)}, C_{\\mathrm{micro}}^{(4)}]$，对应于上面列出的四个测试用例。\n\n通过从所述基础推导所有必需的公式来确保科学真实性，并且不要对 $C_{\\mathrm{micro}}$ 使用任何正则涨落公式。",
            "solution": "该问题要求分析微正则（$NVE$）系综中的热容计算。具体来说，我们必须将一个朴素应用的正则涨落公式与一个严格推导的微正则热容表达式 $C$ 进行对比。分析将针对两种模型系统进行：理想气体和和谐振子网络。\n\n首先，我们推导微正则热容 $C_{\\mathrm{micro}}$ 的正确表达式。微正则热力学的基础是吉布斯熵 $S(E)$，根据能量曲面 $H \\leq E$ 所包围的相空间体积 $\\Phi(E)$ 定义：\n$$S(E) = k_{\\mathrm{B}} \\ln \\Phi(E)$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。热力学温度 $T$ 定义为熵对能量变化的倒数：\n$$ \\frac{1}{T} = \\frac{\\partial S(E)}{\\partial E} $$\n定容热容 $C$ 定义为使温度升高一个单位所需的能量，$C = \\partial E / \\partial T$。我们可以用 $S(E)$ 的导数来表示它。对温度的定义使用链式法则：\n$$ \\frac{\\partial}{\\partial E} \\left(\\frac{1}{T}\\right) = \\frac{\\partial}{\\partial T}\\left(\\frac{1}{T}\\right) \\frac{\\partial T}{\\partial E} = -\\frac{1}{T^2} \\frac{\\partial T}{\\partial E} = -\\frac{1}{T^2 C} $$\n同时，我们有：\n$$ \\frac{\\partial}{\\partial E} \\left(\\frac{1}{T}\\right) = \\frac{\\partial}{\\partial E} \\left(\\frac{\\partial S(E)}{\\partial E}\\right) = \\frac{\\partial^2 S(E)}{\\partial E^2} $$\n将这两个表达式相等，得到一个基于熵曲率的微正则热容公式：\n$$ C_{\\mathrm{micro}} = -\\frac{1}{T^2 \\left(\\frac{\\partial^2 S(E)}{\\partial E^2}\\right)} = - \\frac{\\left(\\frac{\\partial S(E)}{\\partial E}\\right)^2}{\\frac{\\partial^2 S(E)}{\\partial E^2}} $$\n我们现在将这个公式应用于具体的系统，使用它们给定的相空间体积标度律。\n\n对于一个具有 $f$ 个二次动量自由度（并隐含 $f$ 个二次势能自由度）的谐振子网络，相空间体积的标度关系为 $\\Phi(E) \\propto E^f$。因此，对于某个常数 $c_1$，$S(E) = k_{\\mathrm{B}} \\ln(c_1 E^f) = k_{\\mathrm{B}} \\ln c_1 + f k_{\\mathrm{B}} \\ln E$。其导数为：\n$$ \\frac{\\partial S}{\\partial E} = \\frac{f k_{\\mathrm{B}}}{E} \\quad \\text{和} \\quad \\frac{\\partial^2 S}{\\partial E^2} = -\\frac{f k_{\\mathrm{B}}}{E^2} $$\n将这些代入我们对 $C_{\\mathrm{micro}}$ 的表达式中：\n$$ C_{\\mathrm{micro}}^{\\mathrm{(harmonic)}} = - \\frac{\\left(\\frac{f k_{\\mathrm{B}}}{E}\\right)^2}{-\\frac{f k_{\\mathrm{B}}}{E^2}} = \\frac{f^2 k_{\\mathrm{B}}^2 / E^2}{f k_{\\mathrm{B}} / E^2} = f k_{\\mathrm{B}} $$\n\n对于一个具有 $f$ 个二次动量自由度的理想气体，相空间体积的标度关系为 $\\Phi(E) \\propto E^{f/2}$。熵为 $S(E) = k_{\\mathrm{B}} \\ln(c_2 E^{f/2}) = k_{\\mathrm{B}} \\ln c_2 + \\frac{f}{2} k_{\\mathrm{B}} \\ln E$。其导数为：\n$$ \\frac{\\partial S}{\\partial E} = \\frac{f k_{\\mathrm{B}}}{2E} \\quad \\text{和} \\quad \\frac{\\partial^2 S}{\\partial E^2} = -\\frac{f k_{\\mathrm{B}}}{2E^2} $$\n将这些代入 $C_{\\mathrm{micro}}$ 的表达式中：\n$$ C_{\\mathrm{micro}}^{\\mathrm{(ideal)}} = - \\frac{\\left(\\frac{f k_{\\mathrm{B}}}{2E}\\right)^2}{-\\frac{f k_{\\mathrm{B}}}{2E^2}} = \\frac{f^2 k_{\\mathrm{B}}^2 / (4E^2)}{f k_{\\mathrm{B}} / (2E^2)} = \\frac{f}{2} k_{\\mathrm{B}} $$\n这些结果，$f k_{\\mathrm{B}}$ 和 $\\frac{f}{2} k_{\\mathrm{B}}$，是这些系统的正确、公认的经典热容值。\n\n接下来，我们评估基于涨落的朴素估计值 $C_{\\mathrm{fluct}}$。这涉及到故意误用正则系综的热容公式，但将其应用于微正则系综内的动能涨落。规定的公式是：\n$$ T = \\frac{2 \\langle K \\rangle}{f k_{\\mathrm{B}}} \\quad \\text{和} \\quad C_{\\mathrm{fluct}} = \\frac{\\langle K^2 \\rangle - \\langle K \\rangle^2}{k_{\\mathrm{B}} T^2} = \\frac{\\mathrm{Var}(K)}{k_{\\mathrm{B}} T^2} $$\n期望值 $\\langle K \\rangle$ 和 $\\langle K^2 \\rangle$ 将通过采样获得。\n\n对于谐振子网络，动能分数 $x = K/E$ 被指定服从贝塔（Beta）分布，$x \\sim \\mathrm{Beta}(a,b)$，参数为 $a = b = f/2$。该分布的均值和方差有解析解：\n$$ \\langle x \\rangle = \\frac{a}{a+b} = \\frac{f/2}{f} = \\frac{1}{2} $$\n$$ \\mathrm{Var}(x) = \\frac{ab}{(a+b)^2(a+b+1)} = \\frac{(f/2)^2}{f^2(f+1)} = \\frac{1}{4(f+1)} $$\n由此，我们求出动能 $K = xE$ 的均值和方差：\n$$ \\langle K \\rangle = E \\langle x \\rangle = \\frac{E}{2} $$\n$$ \\mathrm{Var}(K) = E^2 \\mathrm{Var}(x) = \\frac{E^2}{4(f+1)} $$\n使用这些解析结果（数值采样将对其进行近似），我们可以找到 $C_{\\mathrm{fluct}}$ 的表达式。首先，温度是：\n$$ T = \\frac{2 (E/2)}{f k_{\\mathrm{B}}} = \\frac{E}{f k_{\\mathrm{B}}} $$\n这个温度与从熵推导出的温度（$1/T = \\partial S/\\partial E = f k_{\\mathrm{B}}/E$）相匹配，证实了问题前提的一致性。现在，我们计算 $C_{\\mathrm{fluct}}$：\n$$ C_{\\mathrm{fluct}}^{\\mathrm{(harmonic)}} = \\frac{\\mathrm{Var}(K)}{k_{\\mathrm{B}} T^2} = \\frac{E^2 / (4(f+1))}{k_{\\mathrm{B}} (E / (f k_{\\mathrm{B}}))^2} = \\frac{E^2}{4(f+1)} \\frac{f^2 k_{\\mathrm{B}}}{E^2} = \\frac{f^2}{4(f+1)} k_{\\mathrm{B}} $$\n\n对于理想气体，系统只有动能，所以 $K \\equiv E$。\n$$ \\langle K \\rangle = E \\quad \\text{和} \\quad \\mathrm{Var}(K) = \\langle E^2 \\rangle - \\langle E \\rangle^2 = E^2 - E^2 = 0 $$\n温度为 $T = 2E/(f k_{\\mathrm{B}})$，这也与熵的导数一致。基于涨落的热容立即可以得出：\n$$ C_{\\mathrm{fluct}}^{\\mathrm{(ideal)}} = \\frac{0}{k_{\\mathrm{B}} T^2} = 0 $$\n\n$C_{\\mathrm{micro}}$ 和 $C_{\\mathrm{fluct}}$ 之间的差异现在很清楚了。对于谐振子网络，$C_{\\mathrm{fluct}} = k_{\\mathrm{B}} f^2 / (4(f+1))$，当 $f$ 很大时，它趋近于 $f k_{\\mathrm{B}} / 4$，比正确值 $C_{\\mathrm{micro}} = f k_{\\mathrm{B}}$ 小4倍。对于理想气体，$C_{\\mathrm{fluct}}$ 恒为零，而正确值为 $C_{\\mathrm{micro}} = f k_{\\mathrm{B}} / 2$。这表明 $NVE$ 系综中的动能涨落不能通过简单的正则公式得到热容。\n\n计算过程将包括：\n1. 对于每个测试用例，使用 $C_{\\mathrm{micro}}^{\\mathrm{(harmonic)}} = f k_{\\mathrm{B}}$ 或 $C_{\\mathrm{micro}}^{\\mathrm{(ideal)}} = \\frac{f}{2} k_{\\mathrm{B}}$ 计算解析的 $C_{\\mathrm{micro}}$。\n2. 对于谐振子网络情况，从 $\\mathrm{Beta}(f/2, f/2)$ 分布中生成大量 $x$ 的样本，以获得 $\\langle K \\rangle$ 和 $\\mathrm{Var}(K)$ 的数值估计。对于理想气体情况，设置 $\\langle K \\rangle = E$ 和 $\\mathrm{Var}(K) = 0$。\n3. 使用数值上获得的 $\\langle K \\rangle$ 来计算 $T$。\n4. 使用数值上获得的 $\\mathrm{Var}(K)$ 和计算出的 $T$ 来求得 $C_{\\mathrm{fluct}}$。\n5. 报告每个测试用例的 $C_{\\mathrm{fluct}}$ 和 $C_{\\mathrm{micro}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import beta\n\ndef solve():\n    \"\"\"\n    Calculates and compares a naive fluctuation-based heat capacity (C_fluct)\n    with the correct microcanonical heat capacity (C_micro) for different\n    model systems in the NVE ensemble.\n    \"\"\"\n    #\n    # CONSTANTS AND PARAMETERS\n    #\n    # Boltzmann constant in J/K (CODATA 2018)\n    k_B = 1.380649e-23\n\n    # Sampling parameters\n    NUM_SAMPLES = 50000\n    # Use a fixed random seed for reproducibility\n    RNG = np.random.default_rng(seed=42)\n\n    # Test suite from the problem statement\n    # Each tuple: (system_type, degrees_of_freedom_f, total_energy_E)\n    test_cases = [\n        (\"harmonic\", 2, 1.0e-20),\n        (\"harmonic\", 30, 1.0e-19),\n        (\"ideal\", 6, 1.0e-21),\n        (\"harmonic\", 6, 1.0e-21),\n    ]\n\n    results = []\n\n    for system_type, f, E in test_cases:\n        #\n        # Task 4: Correct Microcanonical Heat Capacity (C_micro)\n        # This is calculated from the analytical formulas derived from the\n        # curvature of the Gibbs entropy S(E).\n        #\n        if system_type == \"harmonic\":\n            # For a harmonic network, C_micro = f * k_B\n            C_micro = f * k_B\n        elif system_type == \"ideal\":\n            # For an ideal gas, C_micro = (f / 2) * k_B\n            C_micro = (f / 2) * k_B\n        else:\n            raise ValueError(f\"Unknown system type: {system_type}\")\n\n        #\n        # Tasks 1-3: Naive Fluctuation Heat Capacity (C_fluct)\n        # This is calculated by sampling kinetic energy K and applying a\n        # deliberately misused canonical fluctuation formula.\n        #\n        if system_type == \"harmonic\":\n            # Task 1 (part 1): Sample kinetic energy K for a harmonic network\n            # The kinetic energy fraction x = K/E follows a Beta distribution\n            # with parameters a = f/2, b = f/2.\n            a = f / 2.0\n            b = f / 2.0\n            \n            x_samples = beta.rvs(a, b, size=NUM_SAMPLES, random_state=RNG)\n            K_samples = x_samples * E\n            \n            # Calculate mean and variance of kinetic energy from samples\n            mean_K = np.mean(K_samples)\n            var_K = np.var(K_samples) # np.var uses ddof=0, population variance\n\n        elif system_type == \"ideal\":\n            # Task 1 (part 2): For an ideal gas, K is constant and equal to E\n            mean_K = E\n            var_K = 0.0\n\n        # Task 2: Define microcanonical temperature T from mean kinetic energy\n        # The equipartition theorem gives T = 2 *"
        }
    ]
}