{
    "hands_on_practices": [
        {
            "introduction": "Potential energy surfaces often emerge from the complex interplay between electronic and lattice degrees of freedom, a concept formalized by the Born-Oppenheimer approximation. This exercise explores the Jahn-Teller effect, a classic example where an electronic degeneracy is lifted by a spontaneous structural distortion, creating a non-trivial PES topology. By constructing the PES from a coupled electron-lattice model, you will gain hands-on experience in mapping the energy landscape and relating its features, such as the presence of a double-well potential, to the underlying physics of orbital occupancy and electron-phonon coupling. ",
            "id": "3479238",
            "problem": "Consider a perovskite lattice with a single transition-metal site hosting an electronically degenerate $e_g$ manifold. Within the Born–Oppenheimer approximation, the potential energy surface (PES) is the sum of lattice elastic energy and the ground-state electronic energy as a function of the symmetry-adapted Jahn–Teller normal coordinates $Q_2$ and $Q_3$ (both in $\\mathrm{\\AA}$). Assume linear electron–lattice coupling, harmonic elasticity supplemented by quartic stabilization, and an optional trigonal crystal-field term. The two-level electronic Hamiltonian in the $e_g$ subspace is modeled as $H_{\\mathrm{el}}(Q_2,Q_3) = - g \\left( Q_2 \\tau_x + Q_3 \\tau_z \\right) - \\Delta \\tau_z$, where $g$ is the electron–lattice coupling strength in $\\mathrm{eV}/\\mathrm{\\AA}$, $\\Delta$ is a trigonal crystal-field energy in $\\mathrm{eV}$, and $\\tau_x$, $\\tau_z$ are Pauli matrices acting in the orbital pseudospin basis. Let the lattice energy be $E_{\\mathrm{lat}}(Q_2,Q_3) = \\tfrac{1}{2} k_2 Q_2^2 + \\tfrac{1}{2} k_3 Q_3^2 + \\tfrac{1}{4} \\beta \\left( Q_2^4 + Q_3^4 \\right) + \\tfrac{1}{2} \\kappa Q_2^2 Q_3^2$, with $k_2$ and $k_3$ in $\\mathrm{eV}/\\mathrm{\\AA}^2$, and $\\beta$, $\\kappa$ in $\\mathrm{eV}/\\mathrm{\\AA}^4$. Assume electronic occupancy $n_{\\mathrm{occ}} \\in \\{0,1,2\\}$ electrons in the $e_g$ subspace per site, neglecting electron–electron interactions beyond filling the available levels.\n\nStarting from these definitions and physical laws, the PES is $E(Q_2,Q_3) = E_{\\mathrm{lat}}(Q_2,Q_3) + E_{\\mathrm{el,gs}}(Q_2,Q_3;n_{\\mathrm{occ}})$, where $E_{\\mathrm{el,gs}}$ is the ground-state electronic energy that must be obtained by diagonalizing $H_{\\mathrm{el}}(Q_2,Q_3)$ and filling the lowest $n_{\\mathrm{occ}}$ eigenvalues. Your task is to implement a program that, for each parameter set in the test suite below, constructs $E(Q_2,Q_3)$ on a square grid $Q_2,Q_3 \\in [-Q_{\\max}, Q_{\\max}]$, detects distinct local minima, determines whether a double-well topology exists, and computes the barrier height between the two lowest-energy minima along the straight-line path connecting them.\n\nDefinitions and computational requirements:\n- The eigenvalues of $H_{\\mathrm{el}}(Q_2,Q_3)$ are the pair $\\pm \\sqrt{(g Q_2)^2 + (g Q_3 + \\Delta)^2}$ in $\\mathrm{eV}$. Define $E_{\\mathrm{el,gs}}(Q_2,Q_3;n_{\\mathrm{occ}})$ by summing the lowest $n_{\\mathrm{occ}}$ of these eigenvalues: for $n_{\\mathrm{occ}} = 0$, $E_{\\mathrm{el,gs}} = 0$; for $n_{\\mathrm{occ}} = 1$, $E_{\\mathrm{el,gs}} = - \\sqrt{(g Q_2)^2 + (g Q_3 + \\Delta)^2}$; for $n_{\\mathrm{occ}} = 2$, $E_{\\mathrm{el,gs}} = 0$.\n- A local minimum on the grid is any grid point whose value is strictly less than the values at its eight neighboring grid points (use standard $3 \\times 3$ neighborhood). Merge minima closer than a Euclidean distance tolerance of $d_{\\mathrm{tol}} = 0.05$ $\\mathrm{\\AA}$ into a single minimum by keeping the lowest-energy representative.\n- A double-well topology is present if at least two distinct local minima exist and the barrier height computed below is strictly positive.\n- The barrier height is defined as the maximum of $E(Q_2(t), Q_3(t))$ along the straight-line segment connecting the two lowest-energy minima minus the energy of the lower of those two minima, where $(Q_2(t), Q_3(t)) = (1-t)(Q_2^{(1)}, Q_3^{(1)}) + t (Q_2^{(2)}, Q_3^{(2)})$ and $t \\in [0,1]$ is sampled uniformly with $N_{\\mathrm{path}} = 1001$ points.\n\nFor each test case, your program must output a list with five entries: \n$[\\text{is\\_double\\_well}, E_{\\min}, B, Q_2^{\\min}, Q_3^{\\min}]$, where $\\text{is\\_double\\_well}$ is a boolean, $E_{\\min}$ is the minimum PES energy in $\\mathrm{eV}$, $B$ is the barrier height in $\\mathrm{eV}$, and $(Q_2^{\\min}, Q_3^{\\min})$ are the coordinates of the lowest-energy minimum in $\\mathrm{\\AA}$. Express $E_{\\min}$ and $B$ in $\\mathrm{eV}$ and $(Q_2^{\\min}, Q_3^{\\min})$ in $\\mathrm{\\AA}$, each rounded to six decimal places. Angles are not required in this problem.\n\nTest suite parameters, given as tuples $(n_{\\mathrm{occ}}, g, k_2, k_3, \\beta, \\kappa, \\Delta, Q_{\\max}, N_{\\mathrm{grid}})$:\n- Case A (happy path, clear cooperative Jahn–Teller double-well for single occupancy): $(1,\\, 1.6,\\, 1.0,\\, 0.8,\\, 0.25,\\, 0.20,\\, 0.0,\\, 2.5,\\, 201)$.\n- Case B (weak coupling boundary, single-well): $(1,\\, 0.2,\\, 1.0,\\, 0.8,\\, 0.25,\\, 0.20,\\, 0.0,\\, 1.0,\\, 201)$.\n- Case C (two-electron occupancy suppresses Jahn–Teller, single-well): $(2,\\, 1.6,\\, 1.0,\\, 0.8,\\, 0.25,\\, 0.20,\\, 0.0,\\, 2.5,\\, 201)$.\n- Case D (asymmetric double-well due to trigonal field): $(1,\\, 1.6,\\, 1.0,\\, 0.8,\\, 0.25,\\, 0.20,\\, 0.3,\\, 2.5,\\, 201)$.\n- Case E (no electrons, purely elastic single-well): $(0,\\, 1.6,\\, 1.0,\\, 0.8,\\, 0.25,\\, 0.20,\\, 0.0,\\, 2.5,\\, 201)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case result is itself a list in the form $[\\text{boolean}, \\text{float}, \\text{float}, \\text{float}, \\text{float}]$, for example, $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$. No other text should be printed. The numerical values must follow the unit instructions above and the rounding requirement specified.",
            "solution": "The problem is scientifically well-grounded, self-contained, and computationally well-defined. It presents a standard model for the Jahn-Teller effect in a solid-state context, a key concept in materials physics. The model for the potential energy surface (PES), $E(Q_2, Q_3)$, combines a physically motivated lattice energy, $E_{\\mathrm{lat}}$, with an electronic energy, $E_{\\mathrm{el,gs}}$, derived from a two-level quantum system. All parameters, definitions, and computational procedures are specified unambiguously, allowing for a unique and verifiable solution. The problem is therefore deemed **valid**.\n\nThe solution to this problem requires implementing a series of computational steps to analyze the topology of the potential energy surface $E(Q_2, Q_3)$ for different sets of physical parameters.\n\nThe total potential energy surface (PES) is given by the sum of the lattice and electronic ground-state energies:\n$$E(Q_2,Q_3) = E_{\\mathrm{lat}}(Q_2,Q_3) + E_{\\mathrm{el,gs}}(Q_2,Q_3;n_{\\mathrm{occ}})$$\nwhere the lattice energy is a quartic polynomial:\n$$E_{\\mathrm{lat}}(Q_2,Q_3) = \\tfrac{1}{2} k_2 Q_2^2 + \\tfrac{1}{2} k_3 Q_3^2 + \\tfrac{1}{4} \\beta \\left( Q_2^4 + Q_3^4 \\right) + \\tfrac{1}{2} \\kappa Q_2^2 Q_3^2$$\nand the electronic ground-state energy depends on the occupancy $n_{\\mathrm{occ}}$:\n$$E_{\\mathrm{el,gs}}(Q_2,Q_3;n_{\\mathrm{occ}}) = \\begin{cases} 0 & \\text{if } n_{\\mathrm{occ}}=0 \\\\ - \\sqrt{(g Q_2)^2 + (g Q_3 + \\Delta)^2} & \\text{if } n_{\\mathrm{occ}}=1 \\\\ 0 & \\text{if } n_{\\mathrm{occ}}=2 \\end{cases}$$\n\nThe algorithmic approach to finding the requested properties of this PES is as follows:\n\n1.  **Grid Discretization and PES Evaluation**: For each test case, we first establish a discrete grid in the $(Q_2, Q_3)$ plane. The coordinates for the grid points are generated using `numpy.linspace` from $-Q_{\\max}$ to $Q_{\\max}$ with $N_{\\mathrm{grid}}$ points for each axis. A meshgrid is then created to represent all $(Q_2, Q_3)$ pairs. The total energy $E(Q_2, Q_3)$ is calculated for every point on this grid using the provided formulae, yielding a 2D array of energy values.\n\n2.  **Local Minima Identification**: The problem defines a local minimum as a grid point with an energy value strictly less than its eight immediate neighbors. To find these points efficiently, a vectorized approach is employed. The energy grid $E$ is padded with `infinity` on all sides. Then, for each point in the original grid, we perform a boolean comparison against its eight neighbors, which are accessed from the padded grid via slicing. A point is a local minimum only if all eight comparisons are true. The `numpy.argwhere` function is used on the resulting boolean mask to retrieve the indices of all local minima.\n\n3.  **Minima Merging**: Given the discrete nature of the grid, a single continuous minimum might be detected as several adjacent grid points. To consolidate these, a merging procedure is applied. First, the list of detected local minima (each with its energy and coordinates) is sorted by energy in ascending order. Then, we iterate through this sorted list, building a new list of distinct minima. A candidate minimum is added to the new list only if its Euclidean distance to all previously accepted minima is greater than the tolerance $d_{\\mathrm{tol}} = 0.05 \\, \\mathrm{\\AA}$. This ensures that for any cluster of minima closer than $d_{\\mathrm{tol}}$, only the one with the absolute lowest energy is retained.\n\n4.  **Analysis and Output Calculation**:\n    -   The global minimum energy, $E_{\\min}$, and its coordinates, $(Q_2^{\\min}, Q_3^{\\min})$, are taken from the lowest-energy minimum in the final merged list. If no local minima are found, the global minimum is determined by searching the entire energy grid $E$.\n    -   To determine if a double-well topology exists and to calculate the barrier height $B$, we check if at least two distinct minima were found.\n    -   If fewer than two minima exist, the system is not a double well (`is_double_well = False`) and the barrier height is defined as $B=0$.\n    -   If two or more minima are present, we consider the two with the lowest energies, let's call their coordinates $(Q_2^{(1)}, Q_3^{(1)})$ and $(Q_2^{(2)}, Q_3^{(2)})$. A straight-line path between them is parameterized by $t \\in [0,1]$:\n    $$(Q_2(t), Q_3(t)) = (1-t)(Q_2^{(1)}, Q_3^{(1)}) + t (Q_2^{(2)}, Q_3^{(2)})$$\n    -   This path is sampled at $N_{\\mathrm{path}} = 1001$ points. The analytic PES function, $E(Q_2, Q_3)$, is evaluated at each of these $(Q_2(t), Q_3(t))$ coordinates.\n    -   The barrier height $B$ is calculated as the maximum energy along this path minus the global minimum energy $E_{\\min}$ (which is the energy of the deeper of the two wells).\n    -   A double-well topology, `is_double_well`, is confirmed to be `True` if at least two minima were found and the calculated barrier height $B$ is strictly positive.\n\n5.  **Formatting**: Finally, for each test case, the results $[\\text{is\\_double\\_well}, E_{\\min}, B, Q_2^{\\min}, Q_3^{\\min}]$ are collected. The floating-point numbers are rounded to six decimal places, and the collection of all results is formatted into the required single-line string representation of a list of lists.\n\nThis systematic procedure is applied to each of the five test cases to generate the final output.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It iterates through each parameter set, processes it, and prints the final result.\n    \"\"\"\n\n    def process_case(params):\n        \"\"\"\n        Processes a single test case: builds the PES, finds minima, and calculates barrier.\n        \"\"\"\n        n_occ = params['n_occ']\n        g = params['g']\n        k2 = params['k2']\n        k3 = params['k3']\n        beta = params['beta']\n        kappa = params['kappa']\n        delta = params['delta']\n        Q_max = params['Q_max']\n        N_grid = params['N_grid']\n        d_tol = 0.05\n        N_path = 1001\n\n        def calculate_pes(q2, q3):\n            \"\"\"Analytic function for the Potential Energy Surface.\"\"\"\n            E_lat = 0.5 * k2 * q2**2 + 0.5 * k3 * q3**2 + \\\n                    0.25 * beta * (q2**4 + q3**4) + 0.5 * kappa * q2**2 * q3**2\n\n            if n_occ == 1:\n                E_el_gs = -np.sqrt((g * q2)**2 + (g * q3 + delta)**2)\n            else:  # n_occ = 0 or 2\n                E_el_gs = np.zeros_like(q2) if isinstance(q2, np.ndarray) else 0.0\n\n            return E_lat + E_el_gs\n\n        # 1. Grid Discretization and PES Evaluation\n        q_coords = np.linspace(-Q_max, Q_max, N_grid)\n        Q2, Q3 = np.meshgrid(q_coords, q_coords)\n        E = calculate_pes(Q2, Q3)\n\n        # 2. Local Minima Identification\n        padded_E = np.pad(E, pad_width=1, mode='constant', constant_values=np.inf)\n        minima_mask = (E < padded_E[0:-2, 0:-2]) & (E < padded_E[0:-2, 1:-1]) & \\\n                      (E < padded_E[0:-2, 2:])   & (E < padded_E[1:-1, 0:-2]) & \\\n                      (E < padded_E[1:-1, 2:])   & (E < padded_E[2:,   0:-2]) & \\\n                      (E < padded_E[2:,   1:-1]) & (E < padded_E[2:,   2:])\n        \n        min_indices = np.argwhere(minima_mask)\n        \n        local_minima = []\n        if min_indices.size > 0:\n            for i, j in min_indices:\n                local_minima.append({'E': E[i, j], 'Q2': Q2[i, j], 'Q3': Q3[i, j]})\n        \n        # 3. Minima Merging\n        sorted_minima = []\n        if local_minima:\n            local_minima.sort(key=lambda m: m['E'])\n            merged_minima = []\n            for min_candidate in local_minima:\n                is_close = any(\n                    np.sqrt((min_candidate['Q2'] - em['Q2'])**2 + (min_candidate['Q3'] - em['Q3'])**2) < d_tol\n                    for em in merged_minima\n                )\n                if not is_close:\n                    merged_minima.append(min_candidate)\n            sorted_minima = merged_minima\n\n        # 4. Analysis and Output Calculation\n        is_double_well = False\n        barrier_height = 0.0\n\n        if not sorted_minima:\n            min_idx = np.unravel_index(np.argmin(E), E.shape)\n            E_min = E[min_idx]\n            Q2_min, Q3_min = Q2[min_idx], Q3[min_idx]\n        else:\n            min1 = sorted_minima[0]\n            E_min, Q2_min, Q3_min = min1['E'], min1['Q2'], min1['Q3']\n\n            if len(sorted_minima) >= 2:\n                min2 = sorted_minima[1]\n                q2_1, q3_1 = min1['Q2'], min1['Q3']\n                q2_2, q3_2 = min2['Q2'], min2['Q3']\n                \n                t = np.linspace(0, 1, N_path)\n                path_q2 = (1 - t) * q2_1 + t * q2_2\n                path_q3 = (1 - t) * q3_1 + t * q3_2\n                \n                path_E = calculate_pes(path_q2, path_q3)\n                \n                E_path_max = np.max(path_E)\n                B = E_path_max - E_min \n                \n                if B > 1e-9:  # Use tolerance for floating point > 0 check\n                    barrier_height = B\n                    is_double_well = True\n\n        return [is_double_well, E_min, barrier_height, Q2_min, Q3_min]\n\n    test_cases = [\n        # Case A\n        {'n_occ': 1, 'g': 1.6, 'k2': 1.0, 'k3': 0.8, 'beta': 0.25, 'kappa': 0.20, 'delta': 0.0, 'Q_max': 2.5, 'N_grid': 201},\n        # Case B\n        {'n_occ': 1, 'g': 0.2, 'k2': 1.0, 'k3': 0.8, 'beta': 0.25, 'kappa': 0.20, 'delta': 0.0, 'Q_max': 1.0, 'N_grid': 201},\n        # Case C\n        {'n_occ': 2, 'g': 1.6, 'k2': 1.0, 'k3': 0.8, 'beta': 0.25, 'kappa': 0.20, 'delta': 0.0, 'Q_max': 2.5, 'N_grid': 201},\n        # Case D\n        {'n_occ': 1, 'g': 1.6, 'k2': 1.0, 'k3': 0.8, 'beta': 0.25, 'kappa': 0.20, 'delta': 0.3, 'Q_max': 2.5, 'N_grid': 201},\n        # Case E\n        {'n_occ': 0, 'g': 1.6, 'k2': 1.0, 'k3': 0.8, 'beta': 0.25, 'kappa': 0.20, 'delta': 0.0, 'Q_max': 2.5, 'N_grid': 201},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        all_results.append(process_case(params))\n\n    # 5. Formatting\n    result_strings = []\n    for res in all_results:\n        bool_val, e_min, b, q2, q3 = res\n        result_strings.append(\n            f\"[{str(bool_val).lower()},{e_min:.6f},{b:.6f},{q2:.6f},{q3:.6f}]\"\n        )\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once a potential energy surface is defined, a primary task is to identify pathways for transitions between its local minima, such as an adatom diffusing between two stable sites. This practice introduces the Nudged Elastic Band (NEB) method, a cornerstone algorithm for locating the Minimum Energy Path (MEP) and its associated transition state on a PES. Implementing the NEB algorithm will provide a deep, practical understanding of how activation energy barriers and reaction coordinates are computationally determined, which are critical parameters for modeling chemical reaction rates and diffusion processes. ",
            "id": "3479294",
            "problem": "You are asked to design and implement a self-contained Nudged Elastic Band (NEB) calculation to determine the adatom diffusion barrier between adjacent hollow sites on a face-centered cubic (fcc) $(111)$ surface using a simplified, physically plausible, analytic potential energy surface (PES). Your program must compute the minimum-energy path and the energy barrier for multiple test cases, and produce the results as a single line of output.\n\nThe context and model are as follows.\n\n- Fundamental base:\n  - A potential energy surface is a scalar field $V(\\mathbf{r})$ that assigns a potential energy to each configuration coordinate $\\mathbf{r}$. For an adatom constrained to a surface, $\\mathbf{r} = (x,y)$ in two dimensions.\n  - A discrete chain of configurations (images) approximates a continuous path. A band of $N$ images $\\{\\mathbf{r}_0,\\ldots,\\mathbf{r}_{N-1}\\}$ with fixed endpoints $\\mathbf{r}_0$ and $\\mathbf{r}_{N-1}$ is used to model a transition path. Endpoints are minima of $V(\\mathbf{r})$ corresponding to adjacent hollow sites.\n  - Elastic forces maintain approximately uniform spacing between images, while the physical potential energy gradient drives the band toward the minimum-energy path. The saddle point along the path corresponds to the maximal energy image after convergence.\n\n- Surface lattice and analytic PES model:\n  - Consider a triangular Bravais lattice appropriate for the fcc $(111)$ surface. Let the real-space surface lattice parameter be $a$ in angstroms. Define the magnitude of the first-shell reciprocal lattice vectors as $G = \\frac{4\\pi}{\\sqrt{3} a}$.\n  - Use the first-harmonic hexagonal “egg-box” PES\n    $$V(x,y) = V_1 \\left[\\cos(G x) + 2 \\cos\\!\\left(\\frac{G x}{2}\\right)\\cos\\!\\left(\\frac{\\sqrt{3} G y}{2}\\right)\\right],$$\n    where $V_1$ is an energy scale in electronvolts. Take $a = 2.5\\ \\text{\\AA}$ and $V_1 = 0.4\\ \\text{eV}$. Energies must be computed and reported in electronvolts, and distances in angstroms. All angles in trigonometric functions are in radians.\n  - Two adjacent hollow sites along the high-symmetry line $y=0$ occur at\n    $$x_1 = \\frac{4\\pi}{3 G} = \\frac{a}{\\sqrt{3}},\\quad x_2 = \\frac{8\\pi}{3 G} = \\frac{2 a}{\\sqrt{3}},\\quad y_1=y_2=0.$$\n    Use $\\mathbf{r}_0=(x_1,0)$ and $\\mathbf{r}_{N-1}=(x_2,0)$ as fixed endpoints.\n\n- NEB design requirements:\n  - Construct a band of $N$ images, including endpoints. The initial guess for interior images must be:\n    - Linear interpolation along $x$ with $y=0$ for a “linear” path, uniformly spaced in the path parameter $t \\in [0,1]$ with $t_i = \\frac{i}{N-1}$ for image index $i$, or\n    - A “sinusoidal” path with a transverse displacement $y_i = A \\sin(\\pi t_i)$, where $A$ is a given amplitude in angstroms. Use $y_0=y_{N-1}=0$ to keep endpoints fixed. Angles in the sine function are in radians.\n  - Use identical Hookean springs of stiffness $k$ in $\\text{eV}/\\text{\\AA}^2$ between adjacent images to promote uniform spacing.\n  - Use a standard NEB force decomposition that preserves only the perpendicular component of the true force (negative gradient of the PES) and only the parallel component of the spring force along a tangent defined from neighboring images. You may optionally employ a climbing-image modification that inverts the parallel component of the true force on the highest-energy interior image to converge precisely to the saddle point.\n  - Use steepest-descent updates for the images with a position update $\\Delta \\mathbf{r}_i = \\alpha \\mathbf{F}^{\\text{NEB}}_i$, where $\\alpha$ is a step size with units $\\text{\\AA}^2/\\text{eV}$, and $\\mathbf{F}^{\\text{NEB}}_i$ is the NEB force on image $i$.\n  - The convergence criterion is that the maximum NEB force magnitude over all non-endpoint images is below a specified tolerance $\\tau$ in $\\text{eV}/\\text{\\AA}$.\n\n- Quantity to report:\n  - For each test case, compute the diffusion barrier energy defined as $E^\\ddagger - E_\\text{min}$, where $E^\\ddagger$ is the energy of the highest-energy image after convergence and $E_\\text{min} = \\min\\{V(\\mathbf{r}_0), V(\\mathbf{r}_{N-1})\\}$. Express each barrier in electronvolts, rounded to six decimal places.\n\nTest suite. Your program must use exactly the following test cases and parameters:\n\n- Case $1$ (happy path): $N=7$, $k=5.0\\ \\text{eV}/\\text{\\AA}^2$, $\\tau=1.0\\times 10^{-3}\\ \\text{eV}/\\text{\\AA}$, $\\alpha=0.02\\ \\text{\\AA}^2/\\text{eV}$, $N_\\text{max}=5000$, initial path type “linear”, climbing image enabled.\n- Case $2$ (coarse discretization with climbing image): $N=3$, $k=5.0\\ \\text{eV}/\\text{\\AA}^2$, $\\tau=1.0\\times 10^{-4}\\ \\text{eV}/\\text{\\AA}$, $\\alpha=0.02\\ \\text{\\AA}^2/\\text{eV}$, $N_\\text{max}=8000$, initial path type “linear”, climbing image enabled.\n- Case $3$ (stiff springs, no climbing image): $N=9$, $k=50.0\\ \\text{eV}/\\text{\\AA}^2$, $\\tau=1.0\\times 10^{-3}\\ \\text{eV}/\\text{\\AA}$, $\\alpha=0.01\\ \\text{\\AA}^2/\\text{eV}$, $N_\\text{max}=6000$, initial path type “linear”, climbing image disabled.\n- Case $4$ (curved initial path): $N=7$, $k=1.0\\ \\text{eV}/\\text{\\AA}^2$, $\\tau=2.0\\times 10^{-3}\\ \\text{eV}/\\text{\\AA}$, $\\alpha=0.03\\ \\text{\\AA}^2/\\text{eV}$, $N_\\text{max}=6000$, initial path type “sinusoidal” with amplitude $A=0.3\\ \\text{\\AA}$, climbing image enabled.\n\nFinal output format. Your program should produce a single line of output containing a comma-separated list of the four barrier energies, rounded to six decimal places, enclosed in square brackets, in the order of Cases $1$ through $4$ (for example, $[0.200000,0.199876,0.201234,0.200001]$). Energies must be reported in electronvolts.",
            "solution": "The problem requires the implementation of the Nudged Elastic Band (NEB) method to find the minimum-energy path (MEP) and calculate the diffusion barrier for an adatom on a model surface. The solution proceeds by first defining the system's potential energy surface (PES), then detailing the NEB algorithm, and finally applying it to the specified test cases.\n\nFirst, we define the physical system. The adatom's potential energy on the face-centered cubic (fcc) $(111)$ surface is modeled by a two-dimensional analytic potential $V(x,y)$. The surface has a real-space lattice parameter of $a = 2.5\\ \\text{\\AA}$. The PES is given by the first-harmonic hexagonal \"egg-box\" potential:\n$$V(x,y) = V_1 \\left[\\cos(G x) + 2 \\cos\\!\\left(\\frac{G x}{2}\\right)\\cos\\!\\left(\\frac{\\sqrt{3} G y}{2}\\right)\\right]$$\nHere, $V_1 = 0.4\\ \\text{eV}$ is the energy scale, and $G = \\frac{4\\pi}{\\sqrt{3} a}$ is the magnitude of the first-shell reciprocal lattice vectors. All angular arguments in the trigonometric functions are in radians.\n\nThe true force on an adatom at position $\\mathbf{r} = (x,y)$ is the negative gradient of this potential, $\\mathbf{F}^{\\text{true}}(\\mathbf{r}) = -\\nabla V(\\mathbf{r})$. The components of the gradient are:\n$$ \\frac{\\partial V}{\\partial x} = -V_1 G \\left[ \\sin(G x) + \\sin\\left(\\frac{G x}{2}\\right)\\cos\\left(\\frac{\\sqrt{3} G y}{2}\\right) \\right] $$\n$$ \\frac{\\partial V}{\\partial y} = -V_1 G \\sqrt{3} \\cos\\left(\\frac{G x}{2}\\right)\\sin\\left(\\frac{\\sqrt{3} G y}{2}\\right) $$\n\nThe diffusion path is discretized into a chain of $N$ configurations, called images, denoted by $\\{\\mathbf{r}_0, \\mathbf{r}_1, \\dots, \\mathbf{r}_{N-1}\\}$. The endpoints, $\\mathbf{r}_0$ and $\\mathbf{r}_{N-1}$, are fixed at two adjacent hollow sites, which are minima of the PES. These are given as:\n$$ \\mathbf{r}_0 = \\left(\\frac{a}{\\sqrt{3}}, 0\\right) \\quad \\text{and} \\quad \\mathbf{r}_{N-1} = \\left(\\frac{2a}{\\sqrt{3}}, 0\\right) $$\nThe energy at these minima is $E_{\\text{min}} = V(\\mathbf{r}_0) = V(\\mathbf{r}_{N-1}) = -1.5 V_1 = -0.6\\ \\text{eV}$. The interior images, $\\{\\mathbf{r}_1, \\dots, \\mathbf{r}_{N-2}\\}$, are initialized either by linear interpolation between the endpoints or a sinusoidal path, and are then relaxed to find the MEP.\n\nThe NEB method computes the forces that guide the images toward the MEP. The total NEB force on image $i$, $\\mathbf{F}^{\\text{NEB}}_i$, is a sum of two components: the perpendicular component of the true force and the parallel component of a spring force. The spring force ensures roughly equal spacing between images.\nFor each interior image $i \\in \\{1, \\dots, N-2\\}$, we define a local tangent vector $\\hat{\\tau}_i$ to the path. A robust definition, which we adopt, is to use the normalized vector connecting the neighboring images:\n$$ \\hat{\\tau}_i = \\frac{\\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}}{||\\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}||} $$\n\nThe true force $\\mathbf{F}^{\\text{true}}_i = -\\nabla V(\\mathbf{r}_i)$ is decomposed into components parallel and perpendicular to this tangent:\n$$ \\mathbf{F}^{\\text{true, }\\|}_i = (\\mathbf{F}^{\\text{true}}_i \\cdot \\hat{\\tau}_i) \\hat{\\tau}_i $$\n$$ \\mathbf{F}^{\\text{true, }\\perp}_i = \\mathbf{F}^{\\text{true}}_i - \\mathbf{F}^{\\text{true, }\\|}_i $$\nThe NEB algorithm uses only the perpendicular component, $\\mathbf{F}^{\\text{true, }\\perp}_i$, which relaxes the path towards the MEP without causing images to slide along it.\n\nImaginary springs with stiffness $k$ are placed between adjacent images. The full spring force on image $i$ is $\\mathbf{F}^{\\text{spring-full}}_i = k(\\mathbf{r}_{i+1} - \\mathbf{r}_i) - k(\\mathbf{r}_i - \\mathbf{r}_{i-1})$. Only the component of this force parallel to the tangent is retained:\n$$ \\mathbf{F}^{\\text{spring, }\\|}_i = (\\mathbf{F}^{\\text{spring-full}}_i \\cdot \\hat{\\tau}_i) \\hat{\\tau}_i $$\nThis component serves to equalize the spacing between images along the path.\n\nThe total force in a standard NEB calculation is the sum of these selected components:\n$$ \\mathbf{F}^{\\text{NEB}}_i = \\mathbf{F}^{\\text{true, }\\perp}_i + \\mathbf{F}^{\\text{spring, }\\|}_i $$\n\nFor a more accurate determination of the saddle point, the climbing-image NEB (CI-NEB) modification is used. The interior image with the highest potential energy, $i_{\\text{max}} = \\arg\\max_{j \\in \\{1,\\dots,N-2\\}} V(\\mathbf{r}_j)$, is designated as the \"climbing\" image. For this specific image, the spring forces are removed, and the parallel component of the true force is inverted. The force becomes:\n$$ \\mathbf{F}^{\\text{CI-NEB}}_{i_{\\text{max}}} = \\mathbf{F}^{\\text{true, }\\perp}_{i_{\\text{max}}} - \\mathbf{F}^{\\text{true, }\\|}_{i_{\\text{max}}} = \\mathbf{F}^{\\text{true}}_{i_{\\text{max}}} - 2 \\mathbf{F}^{\\text{true, }\\|}_{i_{\\text{max}}} $$\nThis modification pushes the image uphill along the path to converge precisely on the maximum of the MEP, i.e., the saddle point.\n\nThe positions of the interior images are updated iteratively using a simple steepest-descent algorithm:\n$$ \\mathbf{r}_i(t+1) = \\mathbf{r}_i(t) + \\alpha \\mathbf{F}^{\\text{NEB/CI-NEB}}_i(t) $$\nwhere $\\alpha$ is a constant step size. The process is repeated until the magnitude of the largest force on any interior image falls below a specified tolerance, $\\max_i ||\\mathbf{F}_i|| < \\tau$, or a maximum number of iterations, $N_{\\text{max}}$, is reached.\n\nAfter convergence, the energy of each image along the MEP is calculated. The highest energy found along the path is denoted $E^\\ddagger = \\max_{i \\in \\{0,\\dots,N-1\\}} V(\\mathbf{r}_i)$. The diffusion barrier is then the difference between this saddle point energy and the energy of the initial/final state:\n$$ E_b = E^\\ddagger - E_{\\text{min}} $$\nThis procedure is carried out for each of the four specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path)\n        {'N': 7, 'k': 5.0, 'tau': 1.0e-3, 'alpha': 0.02, 'N_max': 5000, \n         'initial_path': 'linear', 'A': 0.0, 'climbing_image': True},\n        # Case 2 (coarse discretization with climbing image)\n        {'N': 3, 'k': 5.0, 'tau': 1.0e-4, 'alpha': 0.02, 'N_max': 8000, \n         'initial_path': 'linear', 'A': 0.0, 'climbing_image': True},\n        # Case 3 (stiff springs, no climbing image)\n        {'N': 9, 'k': 50.0, 'tau': 1.0e-3, 'alpha': 0.01, 'N_max': 6000, \n         'initial_path': 'linear', 'A': 0.0, 'climbing_image': False},\n        # Case 4 (curved initial path)\n        {'N': 7, 'k': 1.0, 'tau': 2.0e-3, 'alpha': 0.03, 'N_max': 6000, \n         'initial_path': 'sinusoidal', 'A': 0.3, 'climbing_image': True},\n    ]\n\n    results = []\n    for params in test_cases:\n        barrier = run_neb(**params)\n        results.append(barrier)\n\n    # Format output as specified\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\n\ndef run_neb(N, k, tau, alpha, N_max, initial_path, A, climbing_image):\n    \"\"\"\n    Performs a Nudged Elastic Band calculation for a single test case.\n    \n    Args:\n        N (int): Number of images in the band.\n        k (float): Spring constant in eV/Å^2.\n        tau (float): Convergence tolerance for force in eV/Å.\n        alpha (float): Step size for steepest descent in Å^2/eV.\n        N_max (int): Maximum number of iterations.\n        initial_path (str): 'linear' or 'sinusoidal'.\n        A (float): Amplitude for sinusoidal path in Å.\n        climbing_image (bool): Whether to use the climbing-image modification.\n\n    Returns:\n        float: The calculated diffusion barrier in eV.\n    \"\"\"\n    #\n    # --- 1. System Setup: Constants and PES ---\n    #\n    a = 2.5  # Surface lattice parameter in Å\n    V1 = 0.4  # PES energy scale in eV\n    G = 4.0 * np.pi / (np.sqrt(3.0) * a)\n\n    def potential(r):\n        \"\"\"Calculates the potential energy V(x, y).\"\"\"\n        x, y = r\n        cos1 = np.cos(G * x)\n        cos2 = np.cos(0.5 * G * x)\n        cos3 = np.cos(0.5 * np.sqrt(3.0) * G * y)\n        return V1 * (cos1 + 2.0 * cos2 * cos3)\n\n    def grad_potential(r):\n        \"\"\"Calculates the gradient of the potential energy nabla V(x, y).\"\"\"\n        x, y = r\n        g_x_half = 0.5 * G * x\n        g_y_term = 0.5 * np.sqrt(3.0) * G * y\n        \n        sin_gx = np.sin(G * x)\n        sin_g_x_half = np.sin(g_x_half)\n        cos_g_x_half = np.cos(g_x_half)\n        sin_g_y_term = np.sin(g_y_term)\n        cos_g_y_term = np.cos(g_y_term)\n\n        dv_dx = -V1 * G * (sin_gx + sin_g_x_half * cos_g_y_term)\n        dv_dy = -V1 * G * np.sqrt(3.0) * cos_g_x_half * sin_g_y_term\n        return np.array([dv_dx, dv_dy])\n\n    #\n    # --- 2. Initialize the Band ---\n    #\n    r_start = np.array([a / np.sqrt(3.0), 0.0])\n    r_end = np.array([2.0 * a / np.sqrt(3.0), 0.0])\n    \n    band = np.zeros((N, 2))\n    band[0] = r_start\n    band[-1] = r_end\n    \n    for i in range(1, N - 1):\n        t_i = i / (N - 1.0)\n        band[i, 0] = r_start[0] + t_i * (r_end[0] - r_start[0])\n        if initial_path == 'sinusoidal':\n            band[i, 1] = A * np.sin(np.pi * t_i)\n\n    #\n    # --- 3. NEB Optimization Loop ---\n    #\n    for step in range(N_max):\n        # Calculate energies of all images\n        energies = np.array([potential(r) for r in band])\n        \n        # Find index of climbing image (if applicable)\n        climb_idx = -1\n        if climbing_image and N > 2:\n            # Only interior images can climb\n            climb_idx = np.argmax(energies[1:-1]) + 1\n        \n        forces_neb = np.zeros_like(band)\n        \n        # Calculate forces for all interior images\n        for i in range(1, N - 1):\n            # Define tangent vector\n            tau_vec = band[i + 1] - band[i - 1]\n            tau_norm = np.linalg.norm(tau_vec)\n            if tau_norm  1e-9:\n                tau_hat = np.zeros(2)\n            else:\n                tau_hat = tau_vec / tau_norm\n\n            # True force from potential gradient\n            F_true = -grad_potential(band[i])\n            \n            # --- Climbing image force calculation ---\n            if climbing_image and i == climb_idx:\n                F_true_parallel_comp = np.dot(F_true, tau_hat)\n                F_true_parallel = F_true_parallel_comp * tau_hat\n                # Force is true force with inverted parallel component\n                forces_neb[i] = F_true - 2.0 * F_true_parallel\n            # --- Standard NEB force calculation ---\n            else:\n                # Perpendicular component of true force\n                F_true_parallel_comp = np.dot(F_true, tau_hat)\n                F_true_perp = F_true - F_true_parallel_comp * tau_hat\n                \n                # Parallel component of spring force\n                len_segment_plus = np.linalg.norm(band[i + 1] - band[i])\n                len_segment_minus = np.linalg.norm(band[i] - band[i - 1])\n                F_spring_parallel_comp = k * (len_segment_plus - len_segment_minus)\n                F_spring_parallel = F_spring_parallel_comp * tau_hat\n\n                forces_neb[i] = F_true_perp + F_spring_parallel\n\n        # Update positions of interior images\n        band[1:-1] += alpha * forces_neb[1:-1]\n\n        # Check for convergence\n        if N > 2:\n            max_force_mag = np.max(np.linalg.norm(forces_neb[1:-1], axis=1))\n            if max_force_mag  tau:\n                break\n        else: # N=3 case, only one moving image\n            if np.linalg.norm(forces_neb[1])  tau:\n                break\n\n    #\n    # --- 4. Calculate Final Barrier ---\n    #\n    final_energies = np.array([potential(r) for r in band])\n    E_min = final_energies[0]\n    E_dagger = np.max(final_energies)\n    barrier = E_dagger - E_min\n    \n    return barrier\n\nsolve()\n```"
        },
        {
            "introduction": "In realistic computational studies, the potential energy surfaces obtained from methods like Density Functional Theory (DFT) are not exact and carry inherent uncertainties, for instance, due to the choice of the exchange-correlation functional. This advanced exercise tackles the crucial task of uncertainty quantification by modeling a DFT-calculated diffusion barrier, $ \\Delta E $, as a random variable and examining how this uncertainty propagates to a macroscopic observable. You will use principles of probability theory and statistical mechanics to analytically connect the uncertainty in the PES to the predicted ionic conductivity, assessing the robustness of the computational model. ",
            "id": "3479253",
            "problem": "Consider ionic diffusion on a crystalline lattice where the Potential Energy Surface (PES) obtained from Density Functional Theory (DFT) controls the activated hopping of ions. Two exchange–correlation functionals are compared: Perdew–Burke–Ernzerhof (PBE) and Strongly Constrained and Appropriately Normed (SCAN). The diffusion barrier $ \\Delta E $ predicted by each functional is modeled as a normal random variable due to systematic PES modeling errors. You will assess the sensitivity of ionic conductivity to these barrier uncertainties by propagating them through Transition State Theory (TST) at a fixed temperature. The goal is to quantitatively evaluate robustness of predicted ionic conductivity to exchange–correlation choices.\n\nWork under the following physically grounded conditions and constants:\n- Fixed absolute temperature $ T = 800\\,\\mathrm{K} $.\n- Attempt frequency $ \\nu = 1.0 \\times 10^{13}\\,\\mathrm{s}^{-1} $.\n- Jump length $ l = 3.0 \\times 10^{-10}\\,\\mathrm{m} $.\n- Spatial dimensionality $ d = 3 $.\n- Number of equivalent nearest-neighbor jump directions $ z = 6 $.\n- Correlation factor (assumed unity) $ f = 1 $.\n- Mobile ion number density $ n = 5.0 \\times 10^{27}\\,\\mathrm{m}^{-3} $.\n- Elementary charge $ q = 1.602\\,176\\,634 \\times 10^{-19}\\,\\mathrm{C} $.\n- Use the Boltzmann constant in electronvolt per Kelvin for barrier statistics $ k_{\\mathrm{B}}^{\\mathrm{(eV/K)}} = 8.617\\,333\\,262\\,145 \\times 10^{-5}\\,\\mathrm{eV/K} $ when relating $ \\Delta E $ to thermal activation, and use the Boltzmann constant in joule per Kelvin $ k_{\\mathrm{B}}^{\\mathrm{(J/K)}} = 1.380\\,649 \\times 10^{-23}\\,\\mathrm{J/K} $ when relating diffusion to conductivity.\n\nFundamental base for derivation and computation:\n- Classical Transition State Theory (TST): barrier-mediated hopping governed by thermal activation at fixed $ T $.\n- Unbiased random walk on a lattice with $ z $ equivalent neighbors in $ d $ dimensions and finite jump length $ l $.\n- Thermodynamic–kinetic link between diffusion and electrical response via the Nernst–Einstein relation.\n- Elementary probability for transformations of normal random variables through smooth mappings.\n\nComputational tasks and outputs:\n1. For each functional, treat the barrier $ \\Delta E $ as $ \\Delta E \\sim \\mathcal{N}(\\mu, \\sigma^2) $ where $ \\mu $ and $ \\sigma $ are given in electronvolt (eV). Without resorting to Monte Carlo simulation, propagate the barrier uncertainty through TST and random-walk diffusion to the ionic conductivity. Compute the mean ionic conductivity and the standard deviation of ionic conductivity for each functional. Express conductivities in siemens per meter ($ \\mathrm{S/m} $).\n2. Compute the probability, expressed as a decimal, that SCAN predicts a higher ionic conductivity than PBE at the fixed temperature, taking into account the uncertainty in both barriers.\n3. Define a robustness predicate for this comparison as follows: the prediction is deemed robust if the probability that SCAN yields higher conductivity is at least $ 0.8 $ and the larger of the two coefficients of variation (standard deviation divided by mean) among the two conductivities does not exceed $ 0.5 $. Output this predicate as a boolean.\n\nTest suite:\nFor each case below, use the common constants listed above and the fixed temperature. Each case provides $ (\\mu_{\\mathrm{PBE}}, \\sigma_{\\mathrm{PBE}}, \\mu_{\\mathrm{SCAN}}, \\sigma_{\\mathrm{SCAN}}) $ in eV.\n- Case $ 1 $: $ (0.35, 0.05, 0.28, 0.03) $.\n- Case $ 2 $: $ (0.15, 0.02, 0.18, 0.01) $.\n- Case $ 3 $: $ (0.90, 0.12, 0.80, 0.10) $.\n- Case $ 4 $: $ (0.40, 0.08, 0.40, 0.01) $.\n- Case $ 5 $ (boundary, no uncertainty): $ (0.30, 0.00, 0.25, 0.00) $.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case is represented by a bracketed comma-separated sublist in the following order: $ [\\text{mean}_{\\mathrm{PBE}}, \\text{std}_{\\mathrm{PBE}}, \\text{mean}_{\\mathrm{SCAN}}, \\text{std}_{\\mathrm{SCAN}}, \\text{prob}(\\text{cond}_{\\text{SCAN}} > \\text{cond}_{\\text{PBE}}), \\text{robust}] $. All conductivities must be in $ \\mathrm{S/m} $, all probabilities as decimals, and the final element is a boolean. For example, the overall output should look like $ [[a,b,c,d,e,f],[\\dots],\\dots] $ with no spaces.",
            "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded, well-posed, and contains sufficient information to derive a unique solution. The problem asks for a quantitative analysis of how uncertainties in Density Functional Theory (DFT)-calculated diffusion barriers propagate to ionic conductivity, and how this impacts the comparison between two common exchange-correlation functionals, PBE and SCAN. A minor notational ambiguity exists where the requested output format refers to `prob(σ_SCAN > σ_PBE)`. The anaphor `σ` has been used in the problem for the standard deviation of the energy barrier. However, Task 2 explicitly asks for the probability of SCAN predicting a higher *ionic conductivity* than PBE. Given this context, we will proceed by interpreting the '`σ`' in the output format as the symbol for ionic conductivity, a common convention. The solution will be derived analytically, without Monte Carlo simulation, as stipulated.\n\nThe derivation proceeds in three main stages:\n1.  Establish the functional relationship between the diffusion energy barrier $ \\Delta E $ and the ionic conductivity, which we shall denote by $ \\kappa $.\n2.  Propagate the uncertainty from the normally distributed random variable $ \\Delta E $ to find the moments (mean and standard deviation) of the resulting distribution for $ \\kappa $.\n3.  Compare the two random variables $ \\kappa_{\\mathrm{PBE}} $ and $ \\kappa_{\\mathrm{SCAN}} $ to compute the required probability and evaluate the robustness predicate.\n\n**1. From Diffusion Barrier to Ionic Conductivity**\n\nThe relationship between the diffusion activation barrier $ \\Delta E $ and ionic conductivity $ \\kappa $ is established by linking three physical models: Transition State Theory (TST), random walk diffusion, and the Nernst-Einstein relation.\n\nAccording to TST, the thermally activated hop frequency $ \\Gamma $ of an ion is given by the Arrhenius equation:\n$$ \\Gamma = \\nu \\exp\\left(-\\frac{\\Delta E}{k_{\\mathrm{B}} T}\\right) $$\nwhere $ \\nu $ is the attempt frequency, $ T $ is the absolute temperature, and $ k_{\\mathrm{B}} $ is the Boltzmann constant. Since $ \\Delta E $ is provided in electronvolts ($ \\mathrm{eV} $), we must use the Boltzmann constant in units of $ \\mathrm{eV/K} $, denoted as $ k_{\\mathrm{B}}^{\\mathrm{(eV/K)}} $. Let us define the inverse thermal energy $ \\beta_{\\mathrm{eV}} = \\frac{1}{k_{\\mathrm{B}}^{\\mathrm{(eV/K)}} T} $. The equation becomes:\n$$ \\Gamma = \\nu \\exp\\left(-\\beta_{\\mathrm{eV}} \\Delta E\\right) $$\n\nNext, the macroscopic diffusion coefficient $ D $ is related to the microscopic hopping parameters. For an unbiased random walk on a lattice with $ z $ equivalent nearest-neighbor sites, dimensionality $ d $, jump length $ l $, and correlation factor $ f $, the diffusion coefficient is:\n$$ D = \\frac{1}{2d} z f l^2 \\Gamma $$\nUsing the provided values $ d=3 $, $ z=6 $, and $ f=1 $, this simplifies to:\n$$ D = \\frac{1}{2 \\cdot 3} \\cdot 6 \\cdot 1 \\cdot l^2 \\Gamma = l^2 \\Gamma = l^2 \\nu \\exp\\left(-\\beta_{\\mathrm{eV}} \\Delta E\\right) $$\n\nFinally, the Nernst-Einstein relation connects the diffusion coefficient $ D $ to the ionic conductivity $ \\kappa $:\n$$ \\kappa = \\frac{n q^2 D}{k_{\\mathrm{B}} T} $$\nwhere $ n $ is the mobile ion number density and $ q $ is the elementary charge. In this final relation, energy terms must be in SI units (Joules). Therefore, we must use the Boltzmann constant in units of $ \\mathrm{J/K} $, denoted $ k_{\\mathrm{B}}^{\\mathrm{(J/K)}} $.\n\nSubstituting the expression for $ D $ yields the complete relationship between $ \\kappa $ and $ \\Delta E $:\n$$ \\kappa(\\Delta E) = \\left(\\frac{n q^2 l^2 \\nu}{k_{\\mathrm{B}}^{\\mathrm{(J/K)}} T}\\right) \\exp\\left(-\\frac{\\Delta E}{k_{\\mathrm{B}}^{\\mathrm{(eV/K)}} T}\\right) $$\nLet's define a pre-exponential constant $ C = \\frac{n q^2 l^2 \\nu}{k_{\\mathrm{B}}^{\\mathrm{(J/K)}} T} $. This constant has units of conductivity ($ \\mathrm{S/m} $). The expression simplifies to:\n$$ \\kappa(\\Delta E) = C \\exp(-\\beta_{\\mathrm{eV}} \\Delta E) $$\n\n**2. Uncertainty Propagation and Moments of Conductivity**\n\nThe problem states that for each functional, the diffusion barrier $ \\Delta E $ is a normal random variable, $ \\Delta E \\sim \\mathcal{N}(\\mu_E, \\sigma_E^2) $. We must find the mean $ \\mu_\\kappa = E[\\kappa] $ and standard deviation $ \\sigma_\\kappa = \\sqrt{\\mathrm{Var}(\\kappa)} $.\n\nLet the random variable be $ X = \\Delta E $. Then $ \\kappa = C e^{-\\beta_{\\mathrm{eV}} X} $. If $ X $ is normally distributed, then $ Y = e^X $ follows a log-normal distribution.\nLet's define a new random variable $ Z = -\\beta_{\\mathrm{eV}} X $. Since $ X $ is normal, $ Z $ is also normal. Its mean and variance are:\n$$ \\mu_Z = E[-\\beta_{\\mathrm{eV}} X] = -\\beta_{\\mathrm{eV}} \\mu_E $$\n$$ \\sigma_Z^2 = \\mathrm{Var}(-\\beta_{\\mathrm{eV}} X) = (-\\beta_{\\mathrm{eV}})^2 \\mathrm{Var}(X) = (\\beta_{\\mathrm{eV}} \\sigma_E)^2 $$\nThe conductivity is $ \\kappa = C e^Z $. Since $ C $ is a constant, $ \\kappa $ follows a scaled log-normal distribution. The moments of $ e^Z $ for $ Z \\sim \\mathcal{N}(\\mu_Z, \\sigma_Z^2) $ are well-known:\n$$ E[e^Z] = \\exp(\\mu_Z + \\sigma_Z^2/2) $$\n$$ \\mathrm{Var}(e^Z) = (\\exp(\\sigma_Z^2) - 1)\\exp(2\\mu_Z + \\sigma_Z^2) $$\nApplying these to $ \\kappa $:\nThe mean ionic conductivity is:\n$$ \\mu_\\kappa = E[C e^Z] = C E[e^Z] = C \\exp(\\mu_Z + \\sigma_Z^2/2) = C \\exp\\left(-\\beta_{\\mathrm{eV}} \\mu_E + \\frac{(\\beta_{\\mathrm{eV}} \\sigma_E)^2}{2}\\right) $$\nThe variance of the ionic conductivity is:\n$$ \\sigma_\\kappa^2 = \\mathrm{Var}(C e^Z) = C^2 \\mathrm{Var}(e^Z) = C^2 \\left(\\exp(\\sigma_Z^2) - 1\\right)\\exp(2\\mu_Z + \\sigma_Z^2) $$\nA more direct way to express the standard deviation, $ \\sigma_\\kappa $, is via the coefficient of variation (CV), $ \\mathrm{CV}_\\kappa = \\sigma_\\kappa / \\mu_\\kappa $:\n$$ \\mathrm{CV}_\\kappa = \\sqrt{\\exp(\\sigma_Z^2) - 1} = \\sqrt{\\exp((\\beta_{\\mathrm{eV}} \\sigma_E)^2) - 1} $$\nTherefore, the standard deviation is:\n$$ \\sigma_\\kappa = \\mu_\\kappa \\sqrt{\\exp((\\beta_{\\mathrm{eV}} \\sigma_E)^2) - 1} $$\nThese formulas allow the computation of the mean and standard deviation of conductivity for both PBE and SCAN functionals, given their respective $ \\mu_E $ and $ \\sigma_E $.\n\n**3. Probabilistic Comparison and Robustness**\n\nTask 2 requires computing the probability $ P(\\kappa_{\\mathrm{SCAN}}  \\kappa_{\\mathrm{PBE}}) $. Let the barriers and conductivities be denoted with subscripts $ S $ for SCAN and $ P $ for PBE. The barriers $ \\Delta E_S \\sim \\mathcal{N}(\\mu_{E,S}, \\sigma_{E,S}^2) $ and $ \\Delta E_P \\sim \\mathcal{N}(\\mu_{E,P}, \\sigma_{E,P}^2) $ are assumed to be independent.\nThe inequality $ \\kappa_S  \\kappa_P $ can be written as:\n$$ C \\exp(-\\beta_{\\mathrm{eV}} \\Delta E_S)  C \\exp(-\\beta_{\\mathrm{eV}} \\Delta E_P) $$\nSince $ C  0 $ and the exponential function is monotonic, this is equivalent to:\n$$ -\\beta_{\\mathrm{eV}} \\Delta E_S  -\\beta_{\\mathrm{eV}} \\Delta E_P $$\nDividing by $ -\\beta_{\\mathrm{eV}} $ (a negative constant) reverses the inequality:\n$$ \\Delta E_S  \\Delta E_P $$\nThus, we need to compute $ P(\\Delta E_S - \\Delta E_P  0) $. Let $ Y = \\Delta E_S - \\Delta E_P $. Since $ \\Delta E_S $ and $ \\Delta E_P $ are independent normal variables, their difference $ Y $ is also a normal variable with mean and variance:\n$$ \\mu_Y = E[\\Delta E_S] - E[\\Delta E_P] = \\mu_{E,S} - \\mu_{E,P} $$\n$$ \\sigma_Y^2 = \\mathrm{Var}(\\Delta E_S) + \\mathrm{Var}(\\Delta E_P) = \\sigma_{E,S}^2 + \\sigma_{E,P}^2 $$\nThe desired probability is $ P(Y  0) $. We standardize $ Y $ to a standard normal variable $ Z_{\\mathrm{std}} \\sim \\mathcal{N}(0, 1) $:\n$$ P(Y  0) = P\\left(\\frac{Y - \\mu_Y}{\\sigma_Y}  \\frac{0 - \\mu_Y}{\\sigma_Y}\\right) = \\Phi\\left(-\\frac{\\mu_Y}{\\sigma_Y}\\right) $$\nwhere $ \\Phi $ is the cumulative distribution function (CDF) of the standard normal distribution. Substituting the expressions for $ \\mu_Y $ and $ \\sigma_Y $:\n$$ P(\\kappa_S  \\kappa_P) = \\Phi\\left(-\\frac{\\mu_{E,S} - \\mu_{E,P}}{\\sqrt{\\sigma_{E,S}^2 + \\sigma_{E,P}^2}}\\right) = \\Phi\\left(\\frac{\\mu_{E,P} - \\mu_{E,S}}{\\sqrt{\\sigma_{E,S}^2 + \\sigma_{E,P}^2}}\\right) $$\nThis probability can be calculated using standard scientific libraries.\n\nFinally, the robustness predicate is evaluated based on two conditions:\n1.  The probability of SCAN yielding a higher conductivity is at least $ 0.8 $: $ P(\\kappa_S  \\kappa_P) \\ge 0.8 $.\n2.  The larger of the two coefficients of variation does not exceed $ 0.5 $: $ \\max(\\mathrm{CV}_{\\kappa,P}, \\mathrm{CV}_{\\kappa,S}) \\le 0.5 $.\nThe predicate is `True` if both conditions are met, and `False` otherwise.\n\n**Summary of Computational Steps:**\nFor each test case $(\\mu_{E,P}, \\sigma_{E,P}, \\mu_{E,S}, \\sigma_{E,S})$:\n1.  Calculate constants: $ \\beta_{\\mathrm{eV}} = \\frac{1}{k_{\\mathrm{B}}^{\\mathrm{(eV/K)}} T} $ and $ C = \\frac{n q^2 l^2 \\nu}{k_{\\mathrm{B}}^{\\mathrm{(J/K)}} T} $.\n2.  For PBE and SCAN, calculate mean conductivity $ \\mu_\\kappa $ and standard deviation $ \\sigma_\\kappa $ using the derived moment formulas.\n3.  Calculate the probability $ P(\\kappa_S  \\kappa_P) $ using the CDF of the normal distribution.\n4.  Calculate the coefficients of variation $ \\mathrm{CV}_{\\kappa,P} $ and $ \\mathrm{CV}_{\\kappa,S} $.\n5.  Evaluate the two conditions for the robustness predicate and combine them with a logical AND.\n6.  Format the six resulting values for the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the ionic diffusion sensitivity analysis problem.\n    \"\"\"\n\n    # --- Physical Constants and Given Parameters ---\n    T = 800.0  # Absolute temperature in K\n    nu = 1.0e13  # Attempt frequency in s^-1\n    l = 3.0e-10  # Jump length in m\n    d = 3  # Spatial dimensionality (unused as z is given)\n    z = 6  # Number of jump directions\n    f = 1.0  # Correlation factor\n    n = 5.0e27  # Mobile ion number density in m^-3\n    q = 1.602176634e-19  # Elementary charge in C\n    k_B_eV = 8.617333262145e-5  # Boltzmann constant in eV/K\n    k_B_J = 1.380649e-23  # Boltzmann constant in J/K\n\n    # --- Derived Constants ---\n    # Inverse thermal energy in eV^-1\n    beta_eV = 1.0 / (k_B_eV * T)\n    # Pre-exponential factor for conductivity in S/m\n    C = (n * q**2 * l**2 * nu) / (k_B_J * T)\n\n    # --- Test Cases ---\n    # Each case is (mu_PBE, sigma_PBE, mu_SCAN, sigma_SCAN) in eV.\n    test_cases = [\n        (0.35, 0.05, 0.28, 0.03),\n        (0.15, 0.02, 0.18, 0.01),\n        (0.90, 0.12, 0.80, 0.10),\n        (0.40, 0.08, 0.40, 0.01),\n        (0.30, 0.00, 0.25, 0.00),\n    ]\n\n    all_results = []\n\n    def calculate_conductivity_stats(mu_E, sigma_E):\n        \"\"\"\n        Calculates mean, std dev, and CV of conductivity.\n        \n        Args:\n            mu_E (float): Mean of the energy barrier (eV).\n            sigma_E (float): Standard deviation of the energy barrier (eV).\n\n        Returns:\n            tuple: (mean_conductivity, std_dev_conductivity, coeff_of_variation)\n        \"\"\"\n        if sigma_E == 0.0:\n            mean_kappa = C * np.exp(-beta_eV * mu_E)\n            std_kappa = 0.0\n            cv_kappa = 0.0\n            return mean_kappa, std_kappa, cv_kappa\n\n        term_sigma_sq = (beta_eV * sigma_E)**2\n        \n        mean_kappa = C * np.exp(-beta_eV * mu_E + term_sigma_sq / 2.0)\n        \n        # CV = sqrt(exp(sigma_Z^2) - 1)\n        cv_kappa = np.sqrt(np.exp(term_sigma_sq) - 1)\n        \n        std_kappa = mean_kappa * cv_kappa\n        \n        return mean_kappa, std_kappa, cv_kappa\n\n    for case in test_cases:\n        mu_E_pbe, sigma_E_pbe, mu_E_scan, sigma_E_scan = case\n\n        # Task 1: Calculate moments of conductivity\n        mean_kappa_pbe, std_kappa_pbe, cv_pbe = calculate_conductivity_stats(mu_E_pbe, sigma_E_pbe)\n        mean_kappa_scan, std_kappa_scan, cv_scan = calculate_conductivity_stats(mu_E_scan, sigma_E_scan)\n\n        # Task 2: Calculate probability P(kappa_SCAN > kappa_PBE)\n        # This is equivalent to P(delta_E_SCAN  delta_E_PBE)\n        mu_diff = mu_E_scan - mu_E_pbe\n        sigma_sum_sq = sigma_E_scan**2 + sigma_E_pbe**2\n\n        if sigma_sum_sq == 0.0:\n            # Deterministic case\n            prob = 1.0 if mu_E_scan  mu_E_pbe else 0.0\n        else:\n            sigma_diff = np.sqrt(sigma_sum_sq)\n            # P(Y  0) = CDF at (0 - mu_Y) / sigma_Y = CDF at -mu_Y / sigma_Y\n            prob = norm.cdf(-mu_diff / sigma_diff)\n        \n        # Task 3: Evaluate robustness predicate\n        cond1 = prob >= 0.8\n        cond2 = max(cv_pbe, cv_scan) = 0.5\n        is_robust = cond1 and cond2\n\n        # Format results for the current case\n        case_results = [\n            mean_kappa_pbe,\n            std_kappa_pbe,\n            mean_kappa_scan,\n            std_kappa_scan,\n            prob,\n            str(is_robust).lower() # Output 'true' or 'false'\n        ]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format\n    output_str = \"[\" + \",\".join([f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]},{res[5]}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}