{
    "hands_on_practices": [
        {
            "introduction": "在许多模拟中，正确地初始化原子速度是确保系统从所需温度开始的第一步。这项实践将指导您从统计力学原理出发，使用稳健的 Box-Muller 变换来实现麦克斯韦-玻尔兹曼分布。此练习强调了将理论与实际的、数值稳定的代码实现联系起来的重要性 。",
            "id": "3458384",
            "problem": "您的任务是根据计算材料科学中使用的物理上合理的原理，实现一个初始化单原子气体原子速度分量的程序。从统计力学和基本概率论的第一性原理出发，构建算法，不依赖于预先提供的公式。您的实现和分析必须满足以下要求。\n\n1. 物理基础与目标分布。使用能量均分定理和麦克斯韦-玻尔兹曼分布来论证，在温度为 $T$ 的热平衡状态下，质量为 $m$ 的粒子的每个速度笛卡尔分量都是一个独立的、均值为零、方差为 $\\sigma^2$ 的高斯随机变量，其中 $\\sigma^2$ 必须从第一性原理推导得出。最终的速度分量以米每秒 (m/s) 表示。为明确起见：符号 $m$ 的单位必须是千克 (kg)，$T$ 的单位必须是开尔文 (K)，玻尔兹曼常数 $k_{\\mathrm{B}}$ 必须以国际单位制 (SI) 正确地纳入计算。\n\n2. 概率变换。从独立均匀随机变量的概率密度和保测度变换出发，推导一种方法，将开区间 $(0,1)$ 上的两个独立均匀随机变量映射为两个独立标准正态随机变量。推导必须基于变量替换公式和具有几何动机的变换，且在本问题陈述中不得直接使用任何捷径公式。角度必须以弧度处理。\n\n3. 对大 $N$ 的数值鲁棒性。您的算法必须解决在变换接近 $0$ 的均匀分布随机数时出现的数值稳定性问题。具体要求如下：\n   - 引入一个严格为正的截断阈值 $\\epsilon$，使得变换中使用的任何均匀分布随机数 $u_1$ 都满足 $u_1 \\ge \\epsilon$，以避免出现未定义的对数和极端值。必须分析 $\\epsilon$ 的选择及其影响。\n   - 通过在截断前强制将 $u_1$ 的前 $K$ 次抽取值设为 $0$，实现可控的病态输入注入，以验证截断逻辑并量化其效果。\n   - 通过报告所有生成的速度分量是否为有限值，并报告以 m/s 为单位的最大分量绝对值，来量化稳定性。\n\n4. 种子可复现性。使用一个伪随机数生成器 (PRNG)，该生成器由一个种子初始化以确保可复现性。对于每个测试用例，通过使用相同种子生成两次速度分量和使用不同种子生成一次来展示可复现性。将精确相等性检查报告为布尔值。\n\n5. 计算诊断指标。对每个测试用例，计算并报告：\n   - 所有分量的样本绝对均值，单位为 m/s。\n   - 所有分量的样本方差与理论推导方差 $\\sigma^2$ 之间的相对误差（无量纲），计算公式为 $(\\hat{\\sigma}^2 - \\sigma^2)/\\sigma^2$。\n   - 最大分量绝对值，单位为 m/s。\n   - 被截断的均匀分布随机数的数量，即在截断前有多少个 $u_1$ 小于 $\\epsilon$。\n   - 一个布尔值，指示所有分量是否为有限值。\n   - 一个布尔值，指示使用相同种子的两次独立实现是否完全相等。\n   - 一个布尔值，指示使用不同种子的实现是否完全相等。\n\n6. 测试套件。实现并运行以下具有科学依据的案例。使用氩原子质量 $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$。使用国际单位制 (SI)。对于每个案例，为每个原子生成三个速度分量（$x$、$y$ 和 $z$），单位均为 m/s。角度必须是弧度。\n   - 案例 A (正常路径): $N = 100000$, $T = 300\\ \\mathrm{K}$, $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$, 种子 $= 314159265$, $\\epsilon = 10^{-12}$, $K = 0$。\n   - 案例 B (注入零值的稳定性压力测试): $N = 100000$, $T = 300\\ \\mathrm{K}$, $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$, 种子 $= 271828182$, $\\epsilon = 10^{-16}$, $K = 1$。\n   - 案例 C (大 $N$ 可复现性): $N = 500000$, $T = 1000\\ \\mathrm{K}$, $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$, 种子 $= 777$, $\\epsilon = 10^{-12}$, $K = 0$。\n   - 案例 D (边界条件，最小样本): $N = 1$, $T = 300\\ \\mathrm{K}$, $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$, 种子 $= 42$, $\\epsilon = 10^{-12}$, $K = 0$。\n\n7. 最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个列表，包含第 5 项中描述的七个条目，并按规定顺序排列。例如，打印的输出必须类似于 $[[\\text{float},\\text{float},\\text{float},\\text{int},\\text{bool},\\text{bool},\\text{bool}],[\\dots],\\dots]$，不含任何额外文本。\n\n解决方案必须是自包含的，且无需用户输入即可运行。所有角度计算必须以弧度为单位。所有报告的速度必须以 $\\mathrm{m/s}$ 为单位，除非另有说明，所有其他报告的量都应为无量纲。",
            "solution": "初始化原子速度是计算材料科学中的一项基础性任务，尤其对于分子动力学 (MD) 模拟等方法而言。其目标是为一个包含 $N$ 个粒子的系统生成一组速度，这组速度在统计上应与给定的热力学状态（特别是温度为 $T$ 的正则系综）相符。该解决方案需要综合运用统计力学、概率论和数值方法的原理。\n\n### 1. 物理基础与目标分布\n\n这个问题的物理基础在于经典统计力学。根据**能量均分定理**，在处于热平衡的系统中，与系统哈密顿量中每个二次自由度相关的平均能量等于 $\\frac{1}{2} k_{\\mathrm{B}} T$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。\n\n对于单原子气体，原子被视为质点。单个质量为 $m$ 的原子的动能 $E_k$ 由其沿三个笛卡尔轴的动能之和给出：\n$$ E_k = \\frac{1}{2} m v_x^2 + \\frac{1}{2} m v_y^2 + \\frac{1}{2} m v_z^2 $$\n系统的哈密顿量包含这三项，每一项都是速度分量（$v_x$、$v_y$ 或 $v_z$）的二次函数。因此，每一项都对应一个适用能量均分定理的自由度。对于任意给定的速度分量，例如 $v_i$（其中 $i \\in \\{x, y, z\\}$），其平均能量为：\n$$ \\left\\langle \\frac{1}{2} m v_i^2 \\right\\rangle = \\frac{1}{2} k_{\\mathrm{B}} T $$\n由于 $m$ 是一个常数，这可以简化为：\n$$ \\langle v_i^2 \\rangle = \\frac{k_{\\mathrm{B}} T}{m} $$\n**麦克斯韦-玻尔兹曼分布**描述了热平衡状态下气体中粒子速率的分布。该分布的一个关键推论是，单个速度分量 $v_i$ 的概率分布是一个高斯（或正态）分布。其概率密度函数 $p(v_i)$ 正比于玻尔兹曼因子 $\\exp(-E_i / (k_{\\mathrm{B}}T))$，其中 $E_i = \\frac{1}{2} m v_i^2$。\n$$ p(v_i) \\propto \\exp\\left(-\\frac{m v_i^2}{2 k_{\\mathrm{B}} T}\\right) $$\n这是零均值高斯分布的函数形式。平均速度 $\\langle v_i \\rangle$ 必须为零，因为在一个简单的平衡状态下，气体在任何方向上都没有净漂移。\n\n速度分量 $v_i$ 的方差 $\\sigma_{v_i}^2$ 定义为 $\\sigma_{v_i}^2 = \\langle (v_i - \\langle v_i \\rangle)^2 \\rangle$。由于 $\\langle v_i \\rangle = 0$，方差就是 $\\sigma_{v_i}^2 = \\langle v_i^2 \\rangle$。根据我们从能量均分定理得到的结果，我们推导出了理论方差：\n$$ \\sigma^2 \\equiv \\sigma_{v_i}^2 = \\frac{k_{\\mathrm{B}} T}{m} $$\n此外，速度分量 $v_x$、$v_y$ 和 $v_z$ 是统计上独立的。因此，每个原子的每个速度分量 $v_i$ 都必须从一个独立同分布的正态分布 $\\mathcal{N}(0, \\sigma^2)$ 中抽取，该分布的均值 $\\mu=0$，方差 $\\sigma^2 = k_{\\mathrm{B}} T / m$。\n\n### 2. 用于生成正态随机数的概率变换\n\n要从目标分布 $\\mathcal{N}(0, \\sigma^2)$ 生成一个随机变量 $v_i$，我们可以先生成一个标准正态随机数 $Z \\sim \\mathcal{N}(0, 1)$，然后对其进行缩放：$v_i = \\sigma Z$。挑战在于如何从我们能轻易产生的随机源（通常是区间 $(0,1)$ 上的均匀分布随机数）生成标准正态随机数。**Box-Muller 变换**提供了一种将两个独立的均匀随机变量转换为两个独立的标准正态随机变量的方法。我们从第一性原理出发推导此方法。\n\n设 $U_1$ 和 $U_2$ 是从 $(0,1)$ 上的均匀分布中抽取的两个独立随机变量。我们寻求一个变换 $(Z_1, Z_2) = g(U_1, U_2)$，使得 $Z_1$ 和 $Z_2$ 是独立的标准正态变量。$(Z_1, Z_2)$ 的联合概率密度函数 (PDF) 是它们各自 PDF 的乘积：\n$$ p(z_1, z_2) = p(z_1)p(z_2) = \\left(\\frac{1}{\\sqrt{2\\pi}} e^{-z_1^2/2}\\right) \\left(\\frac{1}{\\sqrt{2\\pi}} e^{-z_2^2/2}\\right) = \\frac{1}{2\\pi} e^{-(z_1^2 + z_2^2)/2} $$\n通过转换为极坐标 $(R, \\Theta)$，推导过程得以简化，其中 $Z_1 = R\\cos\\Theta$ 且 $Z_2 = R\\sin\\Theta$。半径的平方为 $R^2 = Z_1^2 + Z_2^2$。极坐标下的联合 PDF 可通过使用变换的雅可比行列式（即 $R$）得到：$p(r, \\theta) dr d\\theta = p(z_1,z_2) dz_1 dz_2$。\n$$ p(r, \\theta) = \\frac{1}{2\\pi} e^{-r^2/2} \\cdot r $$\n该联合 PDF 是可分离的：$p(r,\\theta) = (\\frac{1}{2\\pi}) \\cdot (r e^{-r^2/2})$。这表明角度 $\\Theta$ 在 $[0, 2\\pi]$ 上均匀分布，且与半径 $R$ 独立。\n\n因此，我们可以通过一个简单的线性映射，从我们的一个均匀分布随机数（比如 $U_2$）生成 $\\Theta$：\n$$ \\Theta = 2\\pi U_2 $$\n为了生成 $R$，我们使用逆变换采样技术。我们首先求出随机变量 $S=R^2$ 的累积分布函数 (CDF)。对于 $r \\ge 0$，$R$ 的 PDF 是 $p_R(r) = \\int_0^{2\\pi} p(r,\\theta) d\\theta = r e^{-r^2/2}$。$R$ 的 CDF 是 $F_R(r) = \\int_0^r s e^{-s^2/2} ds = 1-e^{-r^2/2}$。那么，对于某个值 $s_0 \\ge 0$，$S=R^2$ 的 CDF 是 $F_S(s_0)=P(S \\le s_0) = P(R^2 \\le s_0) = P(R \\le \\sqrt{s_0}) = F_R(\\sqrt{s_0}) = 1 - e^{-s_0/2}$。这是一个率参数为 $\\lambda=1/2$ 的指数分布的 CDF。通过逆变换采样，我们可以通过将其 CDF 等于一个均匀分布随机数（比如 $U_1$）来生成一个随机数 $S$：\n$$ U_1 = F_S(S) = 1 - e^{-S/2} $$\n解出 $S$：$e^{-S/2} = 1 - U_1$，得到 $S = -2 \\ln(1 - U_1)$。由于 $U_1$ 在 $(0,1)$ 上均匀分布，变量 $1-U_1$ 也在 $(0,1)$ 上均匀分布。因此，我们可以直接使用 $U_1$ 来简化表达式：\n$$ S = R^2 = -2 \\ln(U_1) $$\n结合我们关于 $R$（即 $\\sqrt{S}$）和 $\\Theta$ 的结果，我们可以变换回笛卡尔坐标下的 $Z_1$ 和 $Z_2$：\n$$ Z_1 = R \\cos\\Theta = \\sqrt{-2 \\ln U_1} \\cos(2\\pi U_2) $$\n$$ Z_2 = R \\sin\\Theta = \\sqrt{-2 \\ln U_1} \\sin(2\\pi U_2) $$\n这对方程构成了 Box-Muller 变换。\n\n### 3. 数值实现策略\n\n生成 $3N$ 个速度分量的总体算法如下：\n1.  确定所需的随机数对的数量，即 $\\lceil 3N/2 \\rceil$。\n2.  使用以特定种子初始化的伪随机数生成器 (PRNG) 生成 $2 \\times \\lceil 3N/2 \\rceil$ 个均匀分布随机数，以确保可复现性。将这些随机数组织成对 $(U_1, U_2)$。\n3.  Box-Muller 变换中的项 $\\ln(U_1)$ 在 $U_1=0$ 时未定义，并且当 $U_1 \\to 0^+$ 时发散到 $-\\infty$。这可能导致浮点溢出（`Inf`）或 `NaN` 值。为确保数值稳定性，我们引入一个截断阈值 $\\epsilon > 0$ 并强制 $U_1 \\ge \\epsilon$。任何生成的 $U_1 < \\epsilon$ 都被替换为 $\\epsilon$。此过程限制了所生成速度的大小。我们必须统计此截断被激活的次数。\n4.  为了验证截断机制，我们可以通过在应用截断之前强制将 $U_1$ 的前 $K$ 次抽取值设为 $0$ 来注入病态输入。\n5.  对于每一对 $(U_1, U_2)$，使用推导出的 Box-Muller 公式计算相应的标准正态随机数对 $(Z_1, Z_2)$。\n6.  将所有生成的 $Z$ 值收集到一个数组中，并将其截断至所需的 $3N$ 大小。\n7.  将每个标准正态随机数 $Z_i$ 乘以标准差 $\\sigma = \\sqrt{k_{\\mathrm{B}} T / m}$ 进行缩放，以产生最终的速度分量 $v_i = \\sigma Z_i$。\n\n### 4. 可复现性与诊断\n\n使用带有指定种子的 PRNG 可确保“随机”数序列是确定性的，并且可以被精确复现。我们通过使用相同种子运行生成过程两次，并使用不同种子运行一次来验证这一点，检查生成的速度数组是否完全相等。\n\n为了评估生成数据的质量和稳定性，我们为每个测试用例计算几个诊断指标：\n1.  **样本绝对均值**：应接近理论均值 $0$。\n2.  **相对方差误差**：比较所有 $3N$ 个分量的样本方差 $\\hat{\\sigma}^2$ 与理论方差 $\\sigma^2$，公式为 $(\\hat{\\sigma}^2 - \\sigma^2)/\\sigma^2$。对于大的 $N$，此值应很小。\n3.  **最大分量绝对值**：提供了分布“尾部”的度量，并直接受 $U_1$ 截断的影响。\n4.  **被截断随机数的数量**：量化了数值稳定性程序的影响。\n5.  **有限性检查**：一个布尔值，用于确认没有产生 `Inf` 或 `NaN` 值。\n6.  **可复现性检查**：布尔值，用于确认相同的种子产生相同的结果，而不同的种子产生不同的结果。\n\n这些步骤为模拟中的原子速度初始化提供了一个完整的、物理上和数学上都合理的程序，并包含了验证和鲁棒性检查。",
            "answer": "```python\nimport numpy as np\n\ndef generate_velocities(N, T, m, seed, epsilon, K):\n    \"\"\"\n    Generates atomic velocity components based on the Maxwell-Boltzmann distribution.\n\n    Args:\n        N (int): Number of atoms.\n        T (float): Temperature in Kelvin.\n        m (float): Mass of one atom in kg.\n        seed (int): Seed for the Pseudorandom Number Generator (PRNG).\n        epsilon (float): Clipping threshold for uniform variates.\n        K (int): Number of pathological zero inputs to inject for u1.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: An array of 3*N velocity components (m/s).\n            - int: The number of clipped u1 variates.\n    \"\"\"\n    num_components = 3 * N\n    if num_components == 0:\n        return np.array([]), 0\n\n    # Number of pairs needed for Box-Muller transform\n    num_pairs = (num_components + 1) // 2\n\n    # Initialize a Pseudorandom Number Generator (PRNG) for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Generate uniform variates on (0, 1). Using 'low=np.finfo(float).tiny'\n    # is a robust way to avoid true zeros, but the problem requires\n    # handling zeros explicitly via clipping. So we use low=0.0.\n    u1 = rng.uniform(low=0.0, high=1.0, size=num_pairs)\n    u2 = rng.uniform(low=0.0, high=1.0, size=num_pairs)\n\n    # Inject K pathological inputs (force first K draws of u1 to zero)\n    if K > 0:\n        u1[:K] = 0.0\n\n    # Count how many u1 values are below the threshold *before* clipping\n    clipped_count = np.sum(u1  epsilon)\n\n    # Apply clipping to avoid log(0)\n    u1 = np.maximum(u1, epsilon)\n\n    # Box-Muller transform to get standard normal variates\n    mag = np.sqrt(-2.0 * np.log(u1))\n    z1 = mag * np.cos(2.0 * np.pi * u2)\n    z2 = mag * np.sin(2.0 * np.pi * u2)\n\n    # Interleave the pairs of standard normals into a single array\n    std_normals = np.empty(num_pairs * 2, dtype=float)\n    std_normals[0::2] = z1\n    std_normals[1::2] = z2\n\n    # Trim to the exact number of components required\n    std_normals = std_normals[:num_components]\n\n    # Scale by sigma = sqrt(k_B * T / m) to get final velocities\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n    sigma = np.sqrt((k_B * T) / m)\n    velocities = std_normals * sigma\n\n    return velocities, int(clipped_count)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    m_Ar = 6.6335209e-26  # Mass of Argon atom in kg\n\n    test_cases = [\n        # N, T, m, seed, epsilon, K\n        (100000, 300.0, m_Ar, 314159265, 1e-12, 0),  # Case A\n        (100000, 300.0, m_Ar, 271828182, 1e-16, 1),  # Case B\n        (500000, 1000.0, m_Ar, 777, 1e-12, 0),      # Case C\n        (1, 300.0, m_Ar, 42, 1e-12, 0),              # Case D\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        N, T, m, seed, epsilon, K = case\n        k_B = 1.380649e-23\n\n        # Generate primary set of velocities\n        v_main, clips = generate_velocities(N, T, m, seed, epsilon, K)\n\n        # Generate again with same seed for reproducibility check\n        v_redux, _ = generate_velocities(N, T, m, seed, epsilon, K)\n\n        # Generate with a different seed for reproducibility check\n        v_other, _ = generate_velocities(N, T, m, seed + 1, epsilon, K)\n\n        # 1. Absolute sample mean\n        abs_sample_mean = np.abs(np.mean(v_main)) if v_main.size > 0 else 0.0\n\n        # 2. Relative variance error\n        if v_main.size > 1:\n            sample_variance = np.var(v_main)\n            theoretical_variance = (k_B * T) / m\n            relative_error_var = (sample_variance - theoretical_variance) / theoretical_variance\n        else:\n            # Variance is not well-defined for a single point, but np.var returns 0.\n            # Avoid division by zero, report a non-sensical but defined value.\n            relative_error_var = 0.0 if N == 0 else -1.0 # By definition, a single point sample has 0 variance. \n\n        # 3. Maximum absolute component magnitude\n        max_abs_mag = np.max(np.abs(v_main)) if v_main.size > 0 else 0.0\n        \n        # 4. Count of clipped uniform variates\n        clipped_count = clips\n\n        # 5. Boolean indicating if all components are finite\n        all_finite = np.all(np.isfinite(v_main))\n\n        # 6. Boolean for same-seed equality\n        same_seed_equal = np.array_equal(v_main, v_redux)\n\n        # 7. Boolean for different-seed equality\n        diff_seed_equal = np.array_equal(v_main, v_other)\n        \n        case_results = [\n            abs_sample_mean,\n            relative_error_var,\n            max_abs_mag,\n            clipped_count,\n            all_finite,\n            same_seed_equal,\n            diff_seed_equal\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as required\n    case_strings = []\n    for res_list in all_results:\n        # Convert each item to its string representation\n        # For booleans, Python's str() produces 'True'/'False' which needs to be lowercase.\n        str_items = [str(item).lower() if isinstance(item, bool) else str(item) for item in res_list]\n        case_strings.append(f\"[{','.join(str_items)}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "为玻璃或液体等非晶材料创建实际的初始位置是一个挑战。本练习演示了随机序列相加 (Random Sequential Addition, RSA) 方法，这是一种生成无序原子堆积的常用且直观的算法。这项实践还涵盖了计算效率（单元列表）和堆积的物理极限等实际问题 。",
            "id": "3458396",
            "problem": "要求您设计并实现一个有理论依据的算法，在一个周期性立方体盒子中，使用带有硬核排斥半径的随机顺序吸附 (RSA) 方法，为单原子非晶结构初始化原子位置和速度。对于每个测试用例，您的程序必须尝试放置预定数量的原子，同时强制执行严格的最小中心距，然后初始化与目标热力学温度一致的速度。\n\n使用的基本原理包括：牛顿运动定律、速度定义 $v = dx/dt$、能量均分定理（即每个二次自由度的平均动能等于 $\\tfrac{1}{2} k_{\\mathrm{B}} T$），以及关于麦克斯韦-玻尔兹曼统计和RSA饱和覆盖率的公认物理事实。您必须从这些基本原理推导出您所使用的所有公式。\n\n定义和要求：\n\n- 系统是一个边长为 $L$ 的立方体盒子，具有周期性边界条件。所有长度必须以米 (m) 为单位。\n- 目标质量密度为 $\\rho_{\\mathrm{m}}$（单位为 $\\mathrm{kg/m^3}$）。原子质量为 $m_{\\text{amu}}$（以统一原子质量单位u为单位），转换关系为 $m = m_{\\text{amu}} \\cdot u$，其中 $u = 1.66053906660 \\times 10^{-27} \\,\\mathrm{kg}$。\n- 原子数 $N$ 由盒子体积 $V = L^3$ 和质量密度通过 $N = \\mathrm{round}\\!\\left(\\dfrac{\\rho_{\\mathrm{m}} V}{m}\\right)$ 计算得出，为一个整数。\n- 位置通过RSA进行初始化：在 $[0,L)^3$ 内均匀地提出一个随机位置，如果其与每个先前接受的原子的最小镜像距离（使用周期性边界条件）至少为硬核排斥参数 $r_0$（单位为米），则接受该位置，否则拒绝并重试。您可以对每个原子设置尝试次数上限。\n- 程序必须使用最小镜像约定：对于任何位移分量 $\\Delta x$，在计算欧几里得距离之前，应用 $\\Delta x \\leftarrow \\Delta x - L \\,\\mathrm{round}(\\Delta x/L)$ 来强制周期性。\n- 速度根据温度为 $T$（单位为开尔文）时质量为 $m$ 的单原子粒子的麦克斯韦-玻尔兹曼分布进行初始化，即每个笛卡尔分量都独立服从均值为零、方差为 $\\sigma^2 = k_{\\mathrm{B}} T / m$ 的正态分布，其中 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$。通过减去质心速度来强制净动量为零，然后利用可用自由度上的能量均分定理重新缩放速度，以精确匹配目标温度。\n- 移除质心运动后的瞬时温度计算如下\n$$\nT_{\\mathrm{inst}} = \\frac{2 K}{f k_{\\mathrm{B}}}, \\quad K = \\sum_{i=1}^{N} \\frac{1}{2} m \\lVert \\mathbf{v}_i \\rVert^2, \\quad f = 3N-3.\n$$\n通过一个统一的标量因子重新缩放所有速度，使得 $T_{\\mathrm{inst}}$ 等于目标温度 $T$；报告重新缩放后的绝对温度误差 $|T_{\\mathrm{inst}} - T|$（单位为开尔文）。\n- 堆积分数的定义是将每个原子视为半径为 $r_0/2$ 的硬球，因此单球体积为 $v_{\\mathrm{s}}(r_0) = \\dfrac{\\pi}{6} r_0^3$。对于任意给定构型，实现的堆积分数为\n$$\n\\phi = \\frac{N \\, v_{\\mathrm{s}}(r_0)}{V}.\n$$\n所有堆积分数都表示为无量纲的浮点数。\n- 从数密度 $\\rho = N/V$ 和硬核排斥模型出发，量化预期堆积分数作为 $r_0$ 的函数。在三维空间中相同球体的无限系统RSA极限下，公认的饱和堆积分数约为 $\\phi_{\\mathrm{sat}} \\approx 0.382$。因此，对于任意给定的 $r_0$，定义预期堆积分数函数\n$$\n\\phi_{\\mathrm{exp}}(r_0) = \\min\\!\\left( \\rho \\, v_{\\mathrm{s}}(r_0), \\, \\phi_{\\mathrm{sat}} \\right).\n$$\n同时定义相应的饱和原子数容量\n$$\nN_{\\max}(r_0) = \\left\\lfloor \\frac{\\phi_{\\mathrm{sat}} V}{v_{\\mathrm{s}}(r_0)} \\right\\rfloor,\n$$\n该值必须在尝试RSA之前用于判断可行性：如果 $N  N_{\\max}(r_0)$，则对于RSA而言，放置在原理上是不可行的，您的算法必须不经尝试放置直接返回失败。\n\n您的程序必须为每个测试用例执行以下操作：\n\n1. 给定输入 $L$、$\\rho_{\\mathrm{m}}$、$m_{\\mathrm{u}}$、$r_0$、$T$ 以及每个原子的最大RSA尝试次数（整数），计算 $N$ 并使用上述的 $N_{\\max}(r_0)$ 检查可行性。\n2. 如果可行，使用空间单元列表加速策略，在周期性边界条件下尝试RSA以确保实际性能。如果在尝试预算内放置了所有 $N$ 个原子，则报告成功；否则报告失败。\n3. 按照描述在温度 $T$ 下初始化速度，强制质心动量为零，基于能量均分定理重新缩放至目标温度，并计算重新缩放后的绝对温度误差 $|T_{\\mathrm{inst}}-T|$（单位为开尔文）。\n4. 如果放置成功，计算实现的堆积分数 $\\phi$；如果不成功，则报告 $\\phi = -1.0$。\n5. 计算上面定义的预期堆积分数 $\\phi_{\\mathrm{exp}}(r_0)$。\n\n为了可复现性，请使用以下固定的随机种子：$s = 2025$。\n\n测试套件：\n\n请提供以下三种情况的结果，全部使用国际单位制 (SI)。所有常数和结果都必须使用指定的单位：\n\n- 情况 A (理想路径)：\n  - $L = 1.5 \\times 10^{-9} \\,\\mathrm{m}$，\n  - $\\rho_{\\mathrm{m}} = 2700 \\,\\mathrm{kg/m^3}$，\n  - $m_{\\mathrm{u}} = 26.9815385$，\n  - $r_0 = 2.2 \\times 10^{-10} \\,\\mathrm{m}$，\n  - $T = 300 \\,\\mathrm{K}$，\n  - 每个原子的尝试次数 $= 5000$。\n- 情况 B (接近饱和但可行)：\n  - $L = 1.5 \\times 10^{-9} \\,\\mathrm{m}$，\n  - $\\rho_{\\mathrm{m}} = 2700 \\,\\mathrm{kg/m^3}$，\n  - $m_{\\mathrm{u}} = 26.9815385$，\n  - $r_0 = 2.25 \\times 10^{-10} \\,\\mathrm{m}$，\n  - $T = 300 \\,\\mathrm{K}$，\n  - 每个原子的尝试次数 $= 15000$。\n- 情况 C (因RSA饱和边界而不可行)：\n  - $L = 1.5 \\times 10^{-9} \\,\\mathrm{m}$，\n  - $\\rho_{\\mathrm{m}} = 2700 \\,\\mathrm{kg/m^3}$，\n  - $m_{\\mathrm{u}} = 26.9815385$，\n  - $r_0 = 2.35 \\times 10^{-10} \\,\\mathrm{m}$，\n  - $T = 300 \\,\\mathrm{K}$，\n  - 每个原子的尝试次数 $= 2000$。\n\n最终输出格式：\n\n您的程序应生成一行输出，其中包含一个包含三个结果的列表，每个测试用例一个结果，中间没有空格。每个测试用例的结果本身必须是包含四个条目的列表，顺序如下：\n- 成功指示符，$1$ 表示成功，$0$ 表示失败，\n- 实现的堆积分数 $\\phi$，为浮点数，四舍五入到六位小数（失败时使用 $-1.000000$），\n- 预期的堆积分数 $\\phi_{\\mathrm{exp}}$，为浮点数，四舍五入到六位小数，\n- 绝对温度误差 $|T_{\\mathrm{inst}}-T|$，单位为开尔文，四舍五入到六位小数。\n\n例如，总体格式必须类似于\n$[\\,[1,0.123456,0.120000,0.000000],[\\dots],[\\dots]\\,]$\n并替换为您计算出的三个条目。",
            "solution": "该问题要求设计并实现一个算法，用于在一个周期性立方体域内为单原子非晶结构的模拟初始化原子位置和速度。此过程涉及多个基于计算物理和统计力学的步骤，详情如下。\n\n首先，我们确定系统的基本参数。给定立方体盒子的边长 $L$，其体积为 $V = L^3$。单个原子的质量 $m$ 由其原子质量数值 $m_{\\text{amu}}$（以统一原子质量单位u为单位）通过转换因子 $u$ 计算得出，即 $m = m_{\\text{amu}} \\cdot u$。给定目标质量密度 $\\rho_{\\mathrm{m}}$，盒子中的总质量为 $\\rho_{\\mathrm{m}} V$。然后，原子数 $N$ 通过取总质量与单原子质量之比的最接近整数来确定：\n$$\nN = \\mathrm{round}\\!\\left(\\frac{\\rho_{\\mathrm{m}} V}{m}\\right)\n$$\n\n第二步是使用随机顺序吸附 (RSA) 生成原子位置。这是一个迭代过程，原子被逐一添加到体积中。候选位置 $\\mathbf{r}_{\\mathrm{new}}$ 从盒子内的均匀随机分布中生成，即每个坐标 $x, y, z$ 都在 $[0, L)$ 范围内。仅当新原子与任何先前放置的原子不重叠时，该位置才被接受。不重叠条件由一个硬核排斥半径 $r_0$ 强制执行，意味着任意两个原子之间的中心距必须至少为 $r_0$。由于系统具有周期性边界条件 (PBC)，此距离必须使用最小镜像约定 (MIC) 计算。对于任意两个位置矢量 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$，它们的位移矢量为 $\\Delta\\mathbf{r} = \\mathbf{r}_i - \\mathbf{r}_j$。MIC调整此矢量的每个分量，例如 $\\Delta x$ 变为 $\\Delta x_{\\mathrm{mic}} = \\Delta x - L \\cdot \\mathrm{round}(\\Delta x / L)$。然后平方距离为 $d^2 = \\Delta x_{\\mathrm{mic}}^2 + \\Delta y_{\\mathrm{mic}}^2 + \\Delta z_{\\mathrm{mic}}^2$。如果对于所有先前放置的原子，都有 $d \\ge r_0$，则接受新位置。\n\n对每个新原子与所有现有原子进行暴力距离检查，计算成本高昂，其复杂度为 $O(N^2)$。为了加速这一过程，采用了单元列表数据结构。模拟盒子被划分为一个由更小的立方单元组成的网格，每个单元的边长至少为 $r_0$。要检查一个候选位置，我们只需计算它与自身所在单元及相邻26个单元中原子的距离。这将搜索复杂度降低到 $O(N)$。\n\nRSA无法实现任意高的堆积密度。对于三维空间中的相同球体，存在一个理论饱和堆积分数，$\\phi_{\\mathrm{sat}} \\approx 0.382$。在尝试放置之前，我们执行可行性检查。单个硬球的体积为 $v_{\\mathrm{s}}(r_0) = \\frac{\\pi}{6} r_0^3$。可通过RSA放置的最大原子数 $N_{\\max}$ 受此饱和密度的限制：\n$$\nN_{\\max}(r_0) = \\left\\lfloor \\frac{\\phi_{\\mathrm{sat}} V}{v_{\\mathrm{s}}(r_0)} \\right\\rfloor\n$$\n如果目标原子数 $N$ 超过 $N_{\\max}(r_0)$，则先验地认为放置是不可行的。如果尝试放置但失败（由于超过每个原子的有限尝试次数），或者被认为是不可行的，则实现的堆积分数 $\\phi$ 报告为 $-1.0$。如果成功，$\\phi$ 计算为所有原子的总体积除以盒子体积：\n$$\n\\phi = \\frac{N v_{\\mathrm{s}}(r_0)}{V}\n$$\n预期的堆积分数 $\\phi_{\\mathrm{exp}}(r_0)$ 定义为目标数密度 $\\rho = N/V$ 所隐含的堆积分数与饱和极限中的较小者：$\\phi_{\\mathrm{exp}}(r_0) = \\min(\\rho v_{\\mathrm{s}}(r_0), \\phi_{\\mathrm{sat}})$。\n\n第三，在成功放置所有 $N$ 个原子后，分配它们的初始速度。根据统计力学中关于处于温度 $T$ 的热平衡系统的能量均分定理，每个二次自由度的平均能量为 $\\frac{1}{2} k_{\\mathrm{B}} T$。对于单原子粒子，存在三个平移自由度。这意味着每个速度分量（$v_x, v_y, v_z$）都遵循一个均值为零、方差为 $\\sigma^2 = k_{\\mathrm{B}} T / m$ 的高斯（正态）分布。我们从这个分布中生成 $3N$ 个随机数，以创建一组初始速度 $\\{\\mathbf{v}_i\\}$。\n\n为确保系统整体没有净漂移（即总动量守恒于零），计算并从每个原子的速度中减去质心速度 $\\mathbf{v}_{\\mathrm{CM}} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{v}_i$：$\\mathbf{v}'_i = \\mathbf{v}_i - \\mathbf{v}_{\\mathrm{CM}}$。此约束从系统中移除了3个自由度，留下 $f = 3N-3$ 个独立的自由度。\n\n最后，对速度进行重新缩放，以确保系统的瞬时温度与目标温度 $T$ 完全匹配。瞬时温度 $T_{\\mathrm{inst}}$ 通过总动能 $K$ 定义：\n$$\nK = \\sum_{i=1}^{N} \\frac{1}{2} m \\lVert \\mathbf{v}'_i \\rVert^2, \\quad T_{\\mathrm{inst}} = \\frac{2 K}{f k_{\\mathrm{B}}}\n$$\n由于初始速度生成的统计性质，$T_{\\mathrm{inst}}$ 将接近但不会精确等于 $T$。为了修正这一点，所有速度矢量都乘以一个因子 $\\lambda = \\sqrt{T / T_{\\mathrm{inst}}}$。最终的速度为 $\\mathbf{v}''_i = \\lambda \\mathbf{v}'_i$。根据构造，由这些重新缩放的速度计算出的温度将精确等于 $T$，绝对误差 $|T_{\\mathrm{final}} - T|$ 仅因浮点精度限制而不为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation setup for all test cases and print results.\n    \"\"\"\n    # Define physical constants\n    M_U = 1.66053906660e-27  # Unified atomic mass unit in kg\n    K_B = 1.380649e-23       # Boltzmann constant in J/K\n    PHI_SAT = 0.382          # RSA saturation packing fraction for 3D spheres\n    \n    # Global random number generator for reproducibility\n    RNG = np.random.default_rng(2025)\n\n    test_cases = [\n        # Case A (happy path)\n        {'L': 1.5e-9, 'rho_m': 2700, 'm_u': 26.9815385, 'r_0': 2.2e-10, 'T': 300, 'trials_per_atom': 5000},\n        # Case B (near saturation)\n        {'L': 1.5e-9, 'rho_m': 2700, 'm_u': 26.9815385, 'r_0': 2.25e-10, 'T': 300, 'trials_per_atom': 15000},\n        # Case C (infeasible)\n        {'L': 1.5e-9, 'rho_m': 2700, 'm_u': 26.9815385, 'r_0': 2.35e-10, 'T': 300, 'trials_per_atom': 2000},\n    ]\n\n    def solve_case(L, rho_m, m_u, r_0, T, trials_per_atom):\n        \"\"\"\n        Solves a single test case for atomic position and velocity initialization.\n        \"\"\"\n        # 1. Calculate system parameters\n        V = L**3\n        m = m_u * M_U\n        N = int(round((rho_m * V) / m))\n        v_s = (np.pi / 6) * r_0**3\n        r_0_sq = r_0**2\n\n        # 2. Feasibility check and expected packing fraction\n        phi_exp = min((N / V) * v_s, PHI_SAT)\n        if v_s > 0:\n            N_max = np.floor((PHI_SAT * V) / v_s)\n        else:\n            N_max = float('inf')\n\n        if N > N_max:\n            return 0, -1.0, phi_exp, 0.0\n\n        # 3. RSA Position Initialization with Cell-List Acceleration\n        positions = np.zeros((N, 3))\n        \n        # If N=0, placement is trivially successful\n        if N == 0:\n             return 1, 0.0, phi_exp, 0.0\n\n        n_cells = int(np.floor(L / r_0))\n        if n_cells  1: # r_0 >= L, can't place more than 1 atom\n            if N > 1:\n                return 0, -1.0, phi_exp, 0.0\n            else: # N=1, this will succeed on first try, no neighbors to check\n                positions[0] = RNG.uniform(0, L, size=3)\n                success = 1\n                phi_achieved = (N * v_s) / V\n                # continue to velocity initialization\n        else: # Standard RSA with cell list\n            cell_size = L / n_cells\n            cells = {}\n            success = 0\n            \n            for i in range(N):\n                placed_atom = False\n                for _ in range(trials_per_atom):\n                    pos_new = RNG.uniform(0, L, size=3)\n                    cell_coords = tuple(np.floor(pos_new / cell_size).astype(int))\n                    \n                    conflict = False\n                    for di in [-1, 0, 1]:\n                        for dj in [-1, 0, 1]:\n                            for dk in [-1, 0, 1]:\n                                nc_x = (cell_coords[0] + di + n_cells) % n_cells\n                                nc_y = (cell_coords[1] + dj + n_cells) % n_cells\n                                nc_z = (cell_coords[2] + dk + n_cells) % n_cells\n                                neighbor_cell = (nc_x, nc_y, nc_z)\n                                \n                                if neighbor_cell in cells:\n                                    for other_idx in cells[neighbor_cell]:\n                                        delta = pos_new - positions[other_idx]\n                                        delta -= L * np.round(delta / L)\n                                        dist_sq = np.sum(delta**2)\n                                        if dist_sq  r_0_sq:\n                                            conflict = True\n                                            break\n                                if conflict: break\n                            if conflict: break\n                        if conflict: break\n                    \n                    if not conflict:\n                        positions[i] = pos_new\n                        if cell_coords not in cells:\n                            cells[cell_coords] = []\n                        cells[cell_coords].append(i)\n                        placed_atom = True\n                        break\n                \n                if not placed_atom:\n                    return 0, -1.0, phi_exp, 0.0\n\n            success = 1\n            phi_achieved = (N * v_s) / V\n\n        # 4. Velocity Initialization\n        if N > 1 :\n            sigma_v = np.sqrt(K_B * T / m)\n            velocities = RNG.normal(loc=0.0, scale=sigma_v, size=(N, 3))\n            \n            # Remove CoM velocity\n            v_com = np.mean(velocities, axis=0)\n            velocities -= v_com\n\n            # Rescale to target temperature\n            f = 3 * N - 3\n            K_current = 0.5 * m * np.sum(velocities**2)\n            \n            # T_inst can be zero if all velocities happen to be zero after CoM removal\n            if K_current  1e-30:\n                T_inst = 0.0\n            else:\n                T_inst = (2 * K_current) / (f * K_B)\n            \n            if T_inst > 1e-15:\n                scaling_factor = np.sqrt(T / T_inst)\n                velocities *= scaling_factor\n            \n            # Final temperature check\n            K_final = 0.5 * m * np.sum(velocities**2)\n            if f > 0:\n                T_final = (2 * K_final) / (f * K_B)\n                temp_err = abs(T_final - T)\n            else:\n                temp_err = 0.0\n        else:\n            temp_err = 0.0 # No kinetic energy to scale for N=1 \n\n        return success, phi_achieved, phi_exp, temp_err\n\n    all_results = []\n    for case_params in test_cases:\n        res_tuple = solve_case(\n            L=case_params['L'],\n            rho_m=case_params['rho_m'],\n            m_u=case_params['m_u'],\n            r_0=case_params['r_0'],\n            T=case_params['T'],\n            trials_per_atom=case_params['trials_per_atom']\n        )\n        all_results.append(res_tuple)\n    \n    # Format the final output string exactly as required\n    result_strings = []\n    for res in all_results:\n        success, phi, phi_exp, temp_err = res\n        result_strings.append(f\"[{success},{phi:.6f},{phi_exp:.6f},{temp_err:.6f}]\")\n        \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现在我们转向一个更高级的主题：初始化包含特定缺陷的晶体系统。本练习侧重于创建刃型位错，这是一种控制塑性变形的基本缺陷。它展示了一种强大的多尺度方法，利用连续介质线弹性理论（Volterra 构造）来确定原子位移场，从而弥合宏观理论与原子模拟之间的差距 。",
            "id": "3458312",
            "problem": "考虑一个包含刃型位错偶极子的单原子晶体的二维初始化，该初始化适用于分子动力学 (MD) 或蒙特卡洛 (MC) 模拟。使用各向同性线弹性理论在平面应变条件下的 Volterra 构造，推导出一个伯格斯矢量沿水平轴的单个刃型位错的位移场。然后，叠加两个具有相反伯格斯矢量的此类场，以获得一个与二维周期性边界条件兼容的偶极子。将初始的理想方形晶格映射到弹性位移后的位置，移除核心半径内的小部分原子，并根据目标温度下的 Maxwell-Boltzmann 分布分配速度，同时强制总线动量为零。\n\n你的程序必须仅从基本定律和定义出发，实现以下内容：\n\n1) 几何结构与晶格初始化：\n- 在二维空间中，使用边长为 $L_x$ 和 $L_y$（以埃为单位）的矩形周期性盒子。在盒子内部构建一个晶格间距为 $a$（以埃为单位）的理想方形晶格，使用所有满足 $0 \\le i \\cdot a  L_x$ 和 $0 \\le j \\cdot a  L_y$ 条件的晶格点 $\\{(i a, j a)\\}$，其中 $i \\in \\mathbb{Z}$ 且 $j \\in \\mathbb{Z}$。所有位置必须以埃为单位。\n- 将两个位错核心分别放置在位置 $(x_1, y_1)$ 和 $(x_2, y_2)$，其伯格斯矢量分别为 $+b \\,\\hat{\\mathbf{x}}$ 和 $-b \\,\\hat{\\mathbf{x}}$，其中 $b$ 是以埃为单位表示的伯格斯矢量的大小。\n\n2) 通过 Volterra 构造计算位移场：\n- 在平面应变条件下，使用各向同性线弹性理论，推导一个伯格斯矢量大小为 $b$、方向沿 $x$ 轴、泊松比为 $\\nu$ 的单个刃型位错的二维位移场 $\\mathbf{u}(x,y)$。你的推导必须从线弹性理论的控制方程和 Volterra 切割规定出发，最终得到 $\\mathbf{u}(x,y)$ 的一个闭式表达式。\n- 使用叠加原理，通过对两个位错的贡献求和，得到位错偶极子的总位移 $\\mathbf{u}_{\\text{tot}}(x,y)$。在计算位移之前，必须在周期性边界条件下计算距离，方法是对指向核心 $(x_c, y_c)$ 的相对坐标 $(x-x_c, y-y_c)$ 在两个方向上应用最小镜像约定。\n- 为了对对数和 $1/r$ 奇异性进行正则化，移除任何与任一位错核心的最小镜像距离小于核心截断半径 $r_c$（以埃为单位）的原子。这种移除操作模拟了非线性的核心区域。\n\n3) 周期性与回卷：\n- 在将所有剩余原子按 $\\mathbf{u}_{\\text{tot}}(x,y)$ 进行位移后，使用取模运算将位置回卷到周期性盒子 $[0,L_x) \\times [0,L_y)$ 内，单位为埃。\n\n4) 速度初始化：\n- 对于质量为 $m$（以原子质量单位计）的粒子，从目标温度为 $T$（以开尔文计）的二维 Maxwell-Boltzmann 分布中为所有剩余原子分配初始速度 $(v_x, v_y)$。使用换算关系 $1$ 原子质量单位 $= 1.66053906660 \\times 10^{-27}$ 千克将 $m$ 转换为千克。使用玻尔兹曼常数 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}$ 焦耳/开尔文。使用二维能量均分定理从动能定义温度。\n- 通过从所有粒子速度中减去质心速度来强制总线动量为零，然后重标度速度，使得瞬时动能温度在浮点误差范围内精确等于 $T$（以开尔文计）。所有角度使用弧度。\n\n5) 输出诊断信息：\n对于下述的每个测试用例，计算并返回以下四个量：\n- 核心移除后剩余的整数原子数 $N$。\n- 以开尔文为单位的绝对温度误差 $\\Delta T$，定义为由最终速度计算出的瞬时动能温度与目标温度 $T$ 之间的绝对差值。\n- 以米/秒为单位的质心速率的大小 $|\\mathbf{v}_{\\mathrm{COM}}|$，在强制总动量为零并重标度后计算。\n- 以埃为单位的最小原子间距 $d_{\\min}$，使用最小镜像约定在周期性边界条件下计算。\n\n6) 随机性与可复现性：\n- 使用以整数 $2025$ 为种子的伪随机数生成器，以确保结果是可复现的。\n\n7) 测试套件：\n精确实现以下三个测试用例。在每个用例中，将两个位错放置在 $(x_1, y_1) = (L_x/4, \\, L_y/2)$（伯格斯矢量为 $+b \\,\\hat{\\mathbf{x}}$）和 $(x_2, y_2) = (3 L_x/4, \\, L_y/2)$（伯格斯矢量为 $-b \\,\\hat{\\mathbf{x}}$）。对所有相对矢量使用最小镜像约定。以上述指定的单位报告结果。\n\n- 用例 A：\n  - $L_x = 200$ 埃, $L_y = 200$ 埃。\n  - $a = 2.5$ 埃。\n  - $b = a$。\n  - $\\nu = 0.33$。\n  - $r_c = 5.0$ 埃。\n  - $T = 300$ 开尔文。\n  - $m = 58.6934$ 原子质量单位。\n\n- 用例 B：\n  - $L_x = 120$ 埃, $L_y = 100$ 埃。\n  - $a = 2.86$ 埃。\n  - $b = a$。\n  - $\\nu = 0.28$。\n  - $r_c = 4.29$ 埃。\n  - $T = 1000$ 开尔文。\n  - $m = 55.845$ 原子质量单位。\n\n- 用例 C：\n  - $L_x = 80$ 埃, $L_y = 80$ 埃。\n  - $a = 4.05$ 埃。\n  - $b = a$。\n  - $\\nu = 0.49$。\n  - $r_c = 4.86$ 埃。\n  - $T = 10$ 开尔文。\n  - $m = 26.9815$ 原子质量单位。\n\n8) 最终输出格式：\n- 你的程序应生成单行输出，其中包含一个类 JSON 的嵌套列表，按 [用例 A, 用例 B, 用例 C] 的顺序包含所有三个用例的结果。每个内部列表必须严格包含四个条目，顺序为 $[N, \\Delta T, |\\mathbf{v}_{\\mathrm{COM}}|, d_{\\min}]$。整数 $N$ 应打印为整数。所有浮点值必须四舍五入到六位小数。例如，一个有效的输出形状是\n  - $[[N_A,\\Delta T_A,|\\mathbf{v}_{\\mathrm{COM},A}|,d_{\\min,A}],[N_B,\\Delta T_B,|\\mathbf{v}_{\\mathrm{COM},B}|,d_{\\min,B}],[N_C,\\Delta T_C,|\\mathbf{v}_{\\mathrm{COM},C}|,d_{\\min,C}]]]$,\n作为单行打印，不含任何附加文本。\n\n所有计算都必须使用指定的单位进行：位置以埃为单位，速度以米/秒为单位，温度以开尔文为单位，质量以千克为单位，以及给定的玻尔兹曼常数。角度以弧度为单位，对数为自然对数。程序必须是自包含的，不接受用户输入。每当需要周期性边界条件下的相对矢量时，都必须使用最小镜像约定。",
            "solution": "我们从各向同性固体的平面应变线弹性理论开始。用 $x$ 和 $y$ 表示平面内坐标，用 $\\mathbf{u} = (u_x, u_y)$ 表示位移场，用剪切模量 $\\mu$ 和泊松比 $\\nu$ 表示弹性常数，用 $\\mathbf{b} = b \\,\\hat{\\mathbf{x}}$ 表示沿 $x$ 轴取向的刃型位错的伯格斯矢量。在 Volterra 构造中，通过在介质中进行切割，在切口两侧施加一个等于 $\\mathbf{b}$ 的不连续位移，并要求系统满足由线弹性理论的 Navier–Cauchy 方程所描述的力学平衡，从而引入一个刃型位错。在平面应变条件下，位移场的控制方程为\n$$\n\\mu \\nabla^2 \\mathbf{u} + (\\lambda + \\mu) \\nabla (\\nabla \\cdot \\mathbf{u}) = \\mathbf{0},\n$$\n其中 $\\lambda = \\frac{2\\mu \\nu}{1-2\\nu}$ 是第一 Lamé 常数，应变能密度是小应变张量 $\\varepsilon_{ij} = \\frac{1}{2}(\\partial_i u_j + \\partial_j u_i)$ 的二次函数。Volterra 规定要求，围绕一个包围位错核心的闭合回路对 $\\nabla \\mathbf{u}$ 的线积分等于伯格斯矢量：\n$$\n\\oint_C \\nabla \\mathbf{u} \\cdot d\\mathbf{\\ell} = \\mathbf{b}.\n$$\n在平面应变条件下，无限大介质中单个直刃型位错（位错线沿平面外方向）的经典解是通过使用一个 Airy 应力函数 $\\Phi(x,y)$ 推导得出的。该函数满足双谐和方程 $\\nabla^4 \\Phi = 0$，其边界条件强制切口两侧的位移不连续，并要求无穷远处的应力为零。满足这些条件可以得到应力场，对应力场积分可得到位移场（相差一个刚体平移）。对于位于原点、伯格斯矢量为 $\\mathbf{b} = b\\,\\hat{\\mathbf{x}}$ 的位错，其产生的位移为\n$$\nu_x(x,y) = \\frac{b}{2\\pi} \\left[ \\arctan\\!\\left(\\frac{y}{x}\\right) + \\frac{x\\,y}{2(1-\\nu)\\,(x^2 + y^2)} \\right],\n$$\n$$\nu_y(x,y) = \\frac{b}{2\\pi} \\left[ -\\frac{1-2\\nu}{4(1-\\nu)} \\ln\\!\\left(x^2 + y^2\\right) + \\frac{y^2 - x^2}{4(1-\\nu)\\,(x^2 + y^2)} \\right].\n$$\n这些表达式是经过充分检验的，它们是通过对由刃型位错的 Airy 应力函数导出的应力分量进行积分得到的。$u_y$ 中的对数项定义时可带有一个加性常数，该常数对应于刚体平移，对相对位置没有物理影响。\n\n对于位于 $(x_c, y_c)$ 的位错，我们将 $(x,y)$ 替换为 $(x-x_c, y-y_c)$。在线弹性理论中，叠加原理适用。因此，对于核心分别位于 $(x_1,y_1)$ 和 $(x_2,y_2)$、伯格斯矢量分别为 $+b\\,\\hat{\\mathbf{x}}$ 和 $-b\\,\\hat{\\mathbf{x}}$ 的位错偶极子，其总位移为\n$$\n\\mathbf{u}_{\\text{tot}}(x,y) = \\mathbf{u}^{(+b)}(x-x_1, y-y_1) + \\mathbf{u}^{(-b)}(x-x_2, y-y_2),\n$$\n其中 $\\mathbf{u}^{(-b)}$ 是通过将公式中的 $b$ 替换为 $-b$ 得到的。为了在边长为 $L_x$ 和 $L_y$ 的矩形盒子中实施周期性边界条件，我们使用最小镜像约定来计算相对矢量 $(x-x_c, y-y_c)$：\n$$\n\\Delta x = (x - x_c) - L_x \\,\\mathrm{round}\\!\\left(\\frac{x-x_c}{L_x}\\right), \\quad \\Delta y = (y - y_c) - L_y \\,\\mathrm{round}\\!\\left(\\frac{y-y_c}{L_y}\\right),\n$$\n然后将 $(\\Delta x, \\Delta y)$ 代入位移公式。\n\n弹性场在核心处是奇异的；因此，我们移除任何与任一核心的最小镜像距离 $r = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2}$ 小于截断半径 $r_c$ 的原子。这模拟了非线性核心，并对对数项和 $1/r$ 项进行了正则化。\n\n在算法上，我们对每个测试用例按以下步骤进行：\n- 构建晶格间距为 $a$ 的理想方形晶格，通过枚举所有满足 $0 \\le ia  L_x$ 和 $0 \\le ja  L_y$ 的 $i,j$ 来生成位置 $\\mathbf{r} = (x,y)$，单位为埃。\n- 计算到 $(x_1,y_1)$ 的最小镜像相对矢量 $(\\Delta x_1, \\Delta y_1)$ 和到 $(x_2,y_2)$ 的最小镜像相对矢量 $(\\Delta x_2, \\Delta y_2)$，计算距离 $r_1$ 和 $r_2$，并只保留满足 $r_1 \\ge r_c$ 和 $r_2 \\ge r_c$ 的原子。\n- 对于剩余的原子，使用上述公式计算 $\\mathbf{u}^{(+b)}(\\Delta x_1, \\Delta y_1)$ 和 $\\mathbf{u}^{(-b)}(\\Delta x_2, \\Delta y_2)$ 并求和得到 $\\mathbf{u}_{\\text{tot}}$。更新位置 $\\mathbf{r}' = \\mathbf{r} + \\mathbf{u}_{\\text{tot}}$，并对每个分量取模 $L_x$ 和 $L_y$ 以实施周期性。\n- 从温度为 $T$ 的二维 Maxwell-Boltzmann 分布中初始化速度。对于单个分量，方差为 $\\sigma^2 = k_{\\mathrm{B}} T / m$，因此从均值为零、标准差为 $\\sigma = \\sqrt{k_{\\mathrm{B}} T / m}$（其中 $m$ 以千克为单位）的正态分布中独立抽取 $v_x$ 和 $v_y$。减去质心速度 $\\mathbf{v}_{\\mathrm{COM}}$ 以强制总动量为零。此操作施加了 2 个约束，因此系统的自由度变为 $2N-2$。根据能量均分定理，瞬时温度 $T_{\\text{inst}}$ 与总动能 $K = \\frac{1}{2}m \\sum_i (v_{x,i}^2 + v_{y,i}^2)$ 的关系为 $K = \\frac{2N-2}{2} k_{\\mathrm{B}} T_{\\text{inst}}$。然后通过因子 $\\alpha = \\sqrt{T/T_{\\text{inst}}}$ 重标度速度，使得最终的瞬时温度在浮点误差范围内等于 $T$。重标度后，重新计算 $\\mathbf{v}_{\\mathrm{COM}}$。\n- 计算诊断信息：$N$ 是剩余原子的数量；$\\Delta T = |T_{\\text{inst}} - T|$，单位为开尔文；$|\\mathbf{v}_{\\mathrm{COM}}| = \\sqrt{(\\overline{v_x})^2 + (\\overline{v_y})^2}$，单位为米/秒；以及在周期性边界条件下的最小原子间距 $d_{\\min}$。最小距离通过在最终位置上构建一个盒子大小为 $(L_x, L_y)$ 的周期性 k-d 树来高效计算，并查询每个点的第二近邻（第一近邻是点本身），然后取所有粒子的最小值。\n\n所有测试参数中，长度以埃表示，温度以开尔文表示，输入质量值以原子质量单位表示，并使用 $1$ 原子质量单位 $= 1.66053906660 \\times 10^{-27}$ 千克转换为千克。玻尔兹曼常数为 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}$ 焦耳/开尔文。角度以弧度为单位，对数为自然对数。随机数生成器以 $2025$ 为种子以保证可复现性。\n\n最后，程序按 [用例 A, 用例 B, 用例 C] 的顺序汇总三个指定用例的诊断信息，并打印一行包含嵌套列表的结果，其中每个用例的结果按 $[N, \\Delta T, |\\mathbf{v}_{\\mathrm{COM}}|, d_{\\min}]$ 的顺序排列。整数 $N$ 作为整数打印，浮点值在打印前四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import cKDTree\n\n# Physical constants\nKB = 1.380649e-23  # Boltzmann constant in J/K\nAMU_TO_KG = 1.66053906660e-27  # kg per atomic mass unit\n\ndef min_image(delta, boxlen):\n    \"\"\"Apply the minimum image convention to a coordinate difference.\"\"\"\n    return delta - np.round(delta / boxlen) * boxlen\n\ndef displacement_edge(dx, dy, b, nu):\n    \"\"\"\n    Displacement field (ux, uy) for an edge dislocation with Burgers vector b along +x,\n    isotropic elasticity, plane strain. Inputs dx, dy are arrays of relative coordinates\n    (minimum-image) to the dislocation core. Units: dx,dy,b in Angstrom. Returns ux,uy in Angstrom.\n    \"\"\"\n    r2 = dx*dx + dy*dy\n    # Avoid division by zero: caller must mask out core (r2 >= rc^2)\n    # Use numpy.errstate to manage warnings for logs of small values if any remain.\n    with np.errstate(divide='ignore', invalid='ignore'):\n        ux = (b/(2.0*np.pi)) * (np.arctan2(dy, dx) + (dx*dy) / (2.0*(1.0-nu)*r2))\n        uy = (b/(2.0*np.pi)) * (-(1.0-2.0*nu)/(4.0*(1.0-nu)) * np.log(r2) + (dy*dy - dx*dx)/(4.0*(1.0-nu)*r2))\n    return ux, uy\n\ndef build_square_lattice(Lx, Ly, a):\n    \"\"\"\n    Build a 2D square lattice in [0,Lx) x [0,Ly) with spacing a.\n    Returns positions as an (N,2) array in Angstrom.\n    \"\"\"\n    nx = int(np.floor(Lx / a))\n    ny = int(np.floor(Ly / a))\n    xs = a * np.arange(nx, dtype=float)\n    ys = a * np.arange(ny, dtype=float)\n    X, Y = np.meshgrid(xs, ys, indexing='xy')\n    pos = np.column_stack((X.ravel(), Y.ravel()))\n    return pos\n\ndef apply_dipole_displacement(positions, Lx, Ly, x1, y1, x2, y2, b, nu, rc):\n    \"\"\"\n    Apply dislocation dipole displacement field to positions.\n    Remove atoms within rc of either core. Wrap positions into the box.\n    Returns displaced positions (N',2), mask of kept atoms (N,), and indices of kept atoms.\n    \"\"\"\n    # Relative vectors to core 1\n    dx1 = min_image(positions[:, 0] - x1, Lx)\n    dy1 = min_image(positions[:, 1] - y1, Ly)\n    r1 = np.sqrt(dx1*dx1 + dy1*dy1)\n    # Relative vectors to core 2\n    dx2 = min_image(positions[:, 0] - x2, Lx)\n    dy2 = min_image(positions[:, 1] - y2, Ly)\n    r2 = np.sqrt(dx2*dx2 + dy2*dy2)\n    # Mask out core regions\n    mask = (r1 >= rc)  (r2 >= rc)\n    kept_idx = np.nonzero(mask)[0]\n    pos_kept = positions[mask].copy()\n    # Compute displacements for kept atoms\n    dx1_k = dx1[mask]; dy1_k = dy1[mask]\n    dx2_k = dx2[mask]; dy2_k = dy2[mask]\n    # Displacement from +b at core1\n    ux1, uy1 = displacement_edge(dx1_k, dy1_k, b, nu)\n    # Displacement from -b at core2 (flip sign of b)\n    ux2, uy2 = displacement_edge(dx2_k, dy2_k, -b, nu)\n    ux_tot = ux1 + ux2\n    uy_tot = uy1 + uy2\n    # Apply and wrap\n    pos_kept[:, 0] = (pos_kept[:, 0] + ux_tot) % Lx\n    pos_kept[:, 1] = (pos_kept[:, 1] + uy_tot) % Ly\n    return pos_kept, mask, kept_idx\n\ndef initialize_velocities(N, T, mass_amu, rng):\n    \"\"\"\n    Initialize 2D velocities from Maxwell-Boltzmann at temperature T (K) for mass mass_amu (amu).\n    Enforce zero COM and rescale to exact T. Returns velocities (N,2) in m/s.\n    \"\"\"\n    if N == 0:\n        return np.array([])\n    m = mass_amu * AMU_TO_KG\n    sigma = np.sqrt(KB * T / m)\n    v = rng.normal(loc=0.0, scale=sigma, size=(N, 2))\n    # Remove COM velocity\n    if N > 1:\n        v_mean = v.mean(axis=0)\n        v -= v_mean\n        # Compute instantaneous temperature and rescale\n        v2_sum = np.sum(v**2)\n        dof = 2 * N - 2\n        if dof > 0:\n            T_inst = (m * v2_sum) / (dof * KB)\n            if T_inst > 1e-15:\n                alpha = np.sqrt(T / T_inst)\n                v *= alpha\n    return v\n\ndef compute_temperature(v, mass_amu):\n    \"\"\"Compute kinetic temperature in 2D from velocities v (N,2), mass in amu. Returns K.\"\"\"\n    N = v.shape[0]\n    if N  2:\n        return T if N==1 else 0.0 # Cannot define temp for N=1 with CoM removal\n    m = mass_amu * AMU_TO_KG\n    v2_sum = np.sum(v**2)\n    dof = 2 * N - 2\n    T_inst = (m * v2_sum) / (dof * KB)\n    return T_inst\n\ndef min_pair_distance_periodic(positions, Lx, Ly):\n    \"\"\"\n    Compute minimum pairwise distance under periodic boundary conditions using cKDTree.\n    Returns the minimal distance (float). If N  2, returns nan.\n    \"\"\"\n    N = positions.shape[0]\n    if N  2:\n        return float('nan')\n    tree = cKDTree(positions, boxsize=[Lx, Ly])\n    # Query the distance to the 2 nearest neighbors; the first is the point itself (0.0)\n    dists, idxs = tree.query(positions, k=2, workers=-1)\n    # Exclude self (0 distance), take second neighbor distance\n    second = dists[:, 1]\n    return float(np.min(second))\n\ndef run_case(Lx, Ly, a, b, nu, rc, T, mass_amu, rng):\n    \"\"\"\n    Run a single test case with given parameters.\n    Returns tuple: (N, delta_T, v_com_mag, dmin)\n    \"\"\"\n    # Build lattice\n    positions = build_square_lattice(Lx, Ly, a)\n    # Dislocation cores positions\n    x1, y1 = Lx/4.0, Ly/2.0\n    x2, y2 = 3.0*Lx/4.0, Ly/2.0\n    # Apply displacement and remove cores\n    pos_disp, mask, kept_idx = apply_dipole_displacement(positions, Lx, Ly, x1, y1, x2, y2, b, nu, rc)\n    N = pos_disp.shape[0]\n    # Initialize velocities\n    v = initialize_velocities(N, T, mass_amu, rng)\n    # Diagnostics\n    T_final = compute_temperature(v, mass_amu) if N > 1 else T\n    delta_T = abs(T_final - T) if np.isfinite(T_final) else 0.0\n    v_com = np.linalg.norm(v.mean(axis=0)) if N > 0 else 0.0\n    dmin = min_pair_distance_periodic(pos_disp, Lx, Ly)\n    return N, delta_T, v_com, dmin\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Units: Angstrom for Lx,Ly,a,b,rc. T in K. mass in amu.\n    test_cases = [\n        # Case A\n        {\n            \"Lx\": 200.0, \"Ly\": 200.0, \"a\": 2.5, \"b\": 2.5,\n            \"nu\": 0.33, \"rc\": 5.0, \"T\": 300.0, \"mass_amu\": 58.6934\n        },\n        # Case B\n        {\n            \"Lx\": 120.0, \"Ly\": 100.0, \"a\": 2.86, \"b\": 2.86,\n            \"nu\": 0.28, \"rc\": 4.29, \"T\": 1000.0, \"mass_amu\": 55.845\n        },\n        # Case C\n        {\n            \"Lx\": 80.0, \"Ly\": 80.0, \"a\": 4.05, \"b\": 4.05,\n            \"nu\": 0.49, \"rc\": 4.86, \"T\": 10.0, \"mass_amu\": 26.9815\n        },\n    ]\n\n    rng = np.random.default_rng(2025)\n\n    results = []\n    for params in test_cases:\n        N, dT, vcom, dmin = run_case(\n            Lx=params[\"Lx\"], Ly=params[\"Ly\"], a=params[\"a\"], b=params[\"b\"],\n            nu=params[\"nu\"], rc=params[\"rc\"], T=params[\"T\"], mass_amu=params[\"mass_amu\"],\n            rng=rng\n        )\n        results.append((N, dT, vcom, dmin))\n\n    # Format output: nested list [[N, dT, vcom, dmin], ...] with floats rounded to 6 decimals\n    def fmt_case(case):\n        N, dT, vcom, dmin = case\n        return f\"[{N},{dT:.6f},{vcom:.6f},{dmin if np.isnan(dmin) else f'{dmin:.6f}'}]\"\n\n    out_str_list = []\n    for c in results:\n        N_val, dT_val, vcom_val, dmin_val = c\n        dmin_str = f\"{dmin_val:.6f}\" if np.isfinite(dmin_val) else \"float('nan')\"\n        # The output format does not specify what to do with nan. Printing it as a string is safest.\n        # However, let's assume a large number or a specific string is not intended, just format.\n        if not np.isfinite(dmin_val): dmin_str = \"0.000000\" # Placeholder if nan\n        out_str_list.append(f\"[{N_val},{dT_val:.6f},{vcom_val:.6f},{dmin_str}]\")\n\n    print(\"[\" + \",\".join(out_str_list) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}