{
    "hands_on_practices": [
        {
            "introduction": "为了在约束流形上精确地积分运动方程，我们必须理解约束条件如何随时间演化。本练习要求你对完整约束方程的二阶时间导数中出现的“曲率项”$c(q,\\dot q)$进行基本推导。通过完成这个练习 ，你将更深刻地体会约束的几何解释，并巩固支撑RATTLE等算法的数学形式。",
            "id": "3439796",
            "problem": "考虑一个三维双原子系统，其原子位置为 $r_a \\in \\mathbb{R}^3$ 和 $r_b \\in \\mathbb{R}^3$。定义键矢量 $r_{ab} = r_a - r_b$、相对速度 $v_{ab} = \\dot{r}_a - \\dot{r}_b$ 和一个固定的键长 $d  0$。施加的完整距离约束为\n$$\n\\sigma(q) = r_{ab} \\cdot r_{ab} - d^2 = 0,\n$$\n其中 $q = (r_a, r_b)$ 表示全坐标矢量。在基于约束的分子动力学中，该约束的二阶时间导数具有以下一般形式\n$$\n\\ddot{\\sigma}(q,\\dot{q},\\ddot{q}) = \\nabla \\sigma(q) \\cdot \\ddot{q} + c(q,\\dot{q}),\n$$\n其中曲率项定义为\n$$\nc(q,\\dot{q}) = \\dot{q}^{\\top} \\nabla^2 \\sigma(q) \\, \\dot{q}.\n$$\n从这些定义和牛顿运动学出发，推导出一个用 $v_{ab}$ 和 $r_{ab}$ 表示的关于 $c(q,\\dot{q})$ 的显式表达式。你的最终答案必须是 $c(q,\\dot{q})$ 的一个单一、闭合形式的解析表达式。无需进行数值评估，最终表达式中也不应包含单位。",
            "solution": "让我们通过计算约束函数 $\\sigma(q)$ 的海森矩阵，然后评估二次型，来系统地进行推导。\n\n**第一步：定义坐标和速度矢量**\n\n全坐标矢量 $q$ 是一个由两个原子位置组成的 $6 \\times 1$ 列矢量，其时间导数 $\\dot{q}$ 是相应的速度矢量：\n$$\nq = \\begin{pmatrix} r_a \\\\ r_b \\end{pmatrix}, \\quad \\dot{q} = \\begin{pmatrix} \\dot{r}_a \\\\ \\dot{r}_b \\end{pmatrix}\n$$\n其中 $r_a, r_b, \\dot{r}_a, \\dot{r}_b$ 均为 $\\mathbb{R}^3$ 中的三维矢量。因此，$\\dot{q}^{\\top}$ 是一个 $1 \\times 6$ 的行矢量：\n$$\n\\dot{q}^{\\top} = \\begin{pmatrix} \\dot{r}_a^{\\top}  \\dot{r}_b^{\\top} \\end{pmatrix}\n$$\n\n**第二步：计算约束的梯度**\n\n接下来，我们计算约束函数 $\\sigma(q) = (r_a - r_b) \\cdot (r_a - r_b) - d^2$ 关于 $q$ 的分量的梯度。这可以通过对矢量分量 $r_a$ 和 $r_b$ 求偏导数来完成：\n$$\n\\frac{\\partial \\sigma}{\\partial r_a} = 2(r_a - r_b) = 2r_{ab}\n$$\n$$\n\\frac{\\partial \\sigma}{\\partial r_b} = 2(r_a - r_b) \\cdot (-1) = -2(r_a - r_b) = -2r_{ab}\n$$\n这给出了梯度矢量（表示为分块行矢量）：\n$$\n\\nabla \\sigma(q) = \\begin{pmatrix} \\frac{\\partial \\sigma}{\\partial r_a}  \\frac{\\partial \\sigma}{\\partial r_b} \\end{pmatrix} = \\begin{pmatrix} 2r_{ab}^{\\top}  -2r_{ab}^{\\top} \\end{pmatrix}\n$$\n或者，作为一个 $6 \\times 1$ 的列矢量：\n$$\n\\nabla \\sigma(q) = \\begin{pmatrix} 2r_{ab} \\\\ -2r_{ab} \\end{pmatrix}\n$$\n\n**第三步：计算约束的海森矩阵**\n\n现在，我们计算海森矩阵 $\\nabla^2 \\sigma(q)$，即二阶偏导数矩阵。这将是一个 $6 \\times 6$ 的矩阵，我们可以将其表示为一个 $2 \\times 2$ 的分块形式，其中每个分块都是一个 $3 \\times 3$ 的矩阵。\n$$\n\\nabla^2 \\sigma(q) = \\begin{pmatrix} \\frac{\\partial^2 \\sigma}{\\partial r_a^2}  \\frac{\\partial^2 \\sigma}{\\partial r_a \\partial r_b} \\\\ \\frac{\\partial^2 \\sigma}{\\partial r_b \\partial r_a}  \\frac{\\partial^2 \\sigma}{\\partial r_b^2} \\end{pmatrix}\n$$\n通过对梯度的分量进行微分来计算这些分块：\n$$\n\\frac{\\partial^2 \\sigma}{\\partial r_a^2} = \\frac{\\partial}{\\partial r_a} (2r_{ab}) = \\frac{\\partial}{\\partial r_a} (2(r_a - r_b)) = 2I_3\n$$\n$$\n\\frac{\\partial^2 \\sigma}{\\partial r_a \\partial r_b} = \\frac{\\partial}{\\partial r_b} (2r_{ab}) = \\frac{\\partial}{\\partial r_b} (2(r_a - r_b)) = -2I_3\n$$\n$$\n\\frac{\\partial^2 \\sigma}{\\partial r_b \\partial r_a} = \\frac{\\partial}{\\partial r_a} (-2r_{ab}) = \\frac{\\partial}{\\partial r_a} (-2(r_a - r_b)) = -2I_3\n$$\n$$\n\\frac{\\partial^2 \\sigma}{\\partial r_b^2} = \\frac{\\partial}{\\partial r_b} (-2r_{ab}) = \\frac{\\partial}{\\partial r_b} (-2(r_a - r_b)) = 2I_3\n$$\n其中 $I_3$ 是 $3 \\times 3$ 的单位矩阵。\n\n将这些分块组合起来得到完整的海森矩阵：\n$$\n\\nabla^2 \\sigma(q) = \\begin{pmatrix} 2I_3  -2I_3 \\\\ -2I_3  2I_3 \\end{pmatrix} = 2 \\begin{pmatrix} I_3  -I_3 \\\\ -I_3  I_3 \\end{pmatrix}\n$$\n\n**第四步：计算曲率项**\n\n最后，我们通过评估二次型 $c(q,\\dot{q}) = \\dot{q}^{\\top} \\nabla^2 \\sigma(q) \\, \\dot{q}$ 来计算曲率项 $c(q,\\dot{q})$。\n\n代入 $\\dot{q}^{\\top}$ 和 $\\nabla^2 \\sigma(q)$ 的表达式：\n$$\nc(q,\\dot{q}) = \\begin{pmatrix} \\dot{r}_a^{\\top}  \\dot{r}_b^{\\top} \\end{pmatrix} \\left( 2 \\begin{pmatrix} I_3  -I_3 \\\\ -I_3  I_3 \\end{pmatrix} \\right) \\begin{pmatrix} \\dot{r}_a \\\\ \\dot{r}_b \\end{pmatrix}\n$$\n现在，我们进行矩阵乘法：\n$$\nc(q,\\dot{q}) = 2 \\begin{pmatrix} \\dot{r}_a^{\\top}  \\dot{r}_b^{\\top} \\end{pmatrix} \\begin{pmatrix} I_3 \\dot{r}_a - I_3 \\dot{r}_b \\\\ -I_3 \\dot{r}_a + I_3 \\dot{r}_b \\end{pmatrix}\n$$\n$$\nc(q,\\dot{q}) = 2 \\begin{pmatrix} \\dot{r}_a^{\\top}  \\dot{r}_b^{\\top} \\end{pmatrix} \\begin{pmatrix} \\dot{r}_a - \\dot{r}_b \\\\ -(\\dot{r}_a - \\dot{r}_b) \\end{pmatrix}\n$$\n$$\nc(q,\\dot{q}) = 2 \\left( \\dot{r}_a^{\\top}(\\dot{r}_a - \\dot{r}_b) - \\dot{r}_b^{\\top}(\\dot{r}_a - \\dot{r}_b) \\right)\n$$\n提出公因子 $(\\dot{r}_a - \\dot{r}_b)$：\n$$\nc(q,\\dot{q}) = 2 \\left( (\\dot{r}_a^{\\top} - \\dot{r}_b^{\\top})(\\dot{r}_a - \\dot{r}_b) \\right)\n$$\n$$\nc(q,\\dot{q}) = 2 (\\dot{r}_a - \\dot{r}_b)^{\\top} (\\dot{r}_a - \\dot{r}_b)\n$$\n这可以简化为相对速度矢量与自身的点积。\n\n使用相对速度的定义 $v_{ab} = \\dot{r}_a - \\dot{r}_b$，我们得到最终的表达式：\n$$\nc(q,\\dot{q}) = 2 (v_{ab})^{\\top} v_{ab} = 2 (v_{ab} \\cdot v_{ab})\n$$\n最终答案可以用 $2 \\|v_{ab}\\|^2$ 或 $2 v_{ab} \\cdot v_{ab}$ 来表示。",
            "answer": "$$\n\\boxed{2 v_{ab} \\cdot v_{ab}}\n$$"
        },
        {
            "introduction": "像SHAKE这样的迭代算法通过重复校正粒子位置来求解约束力，这个过程的效率关键取决于一个反映分子几何构型的耦合矩阵$A(\\mathbf{r})$的性质。本练习要求你通过为不同分子拓扑结构构建该矩阵，并凭经验测量其条件数如何影响迭代求解器的收敛性，来探索这种联系 。这个练习能让你深刻洞察约束算法的性能瓶颈，以及分子结构在模拟稳定性中的重要性。",
            "id": "3439810",
            "problem": "在约束分子动力学中，通过在积分器（如 SHAKE 算法（强制位置约束）或 RATTLE 算法（强制位置和速度约束））的每个时间步内求解拉格朗日乘子，来施加完整键长约束。考虑在三维空间中，有一组 $N$ 个质点，其质量为 $\\{m_a\\}_{a=1}^{N}$，位置为 $\\{\\mathbf{r}_a\\}_{a=1}^{N}$。从一个分子图中定义了一组 $K$ 个标量完整约束，其中每个约束 $k$ 是两个粒子 $(i_k,j_k)$ 之间的固定距离，表示为 $c_k(\\mathbf{r}) = \\lVert \\mathbf{r}_{i_k} - \\mathbf{r}_{j_k} \\rVert^2 - d_{i_k j_k}^2 = 0$。约束 $k$ 相对于粒子 $a$ 的梯度是 $\\nabla_{\\mathbf{r}_a} c_k(\\mathbf{r})$，它仅在 $a \\in \\{i_k, j_k\\}$ 时非零，并且当 $a=i_k$ 时等于 $2(\\mathbf{r}_{i_k} - \\mathbf{r}_{j_k})$，当 $a=j_k$ 时等于 $-2(\\mathbf{r}_{i_k} - \\mathbf{r}_{j_k})$。定义约束雅可比矩阵 $G(\\mathbf{r}) \\in \\mathbb{R}^{K \\times 3N}$，其行 $g_k^\\top$ 汇集了这些梯度；并定义对角质量矩阵 $M = \\mathrm{diag}(m_1 I_3, \\dots, m_N I_3) \\in \\mathbb{R}^{3N \\times 3N}$，其中 $I_3$ 是 $3 \\times 3$ 单位矩阵。耦合约束的对称矩阵 $A(\\mathbf{r}) \\in \\mathbb{R}^{K \\times K}$ 由 $A(\\mathbf{r}) = G(\\mathbf{r}) M^{-1} G(\\mathbf{r})^\\top$ 给出，其元素为\n$$\nA_{kl}(\\mathbf{r}) = \\sum_{a=1}^{N} \\left(\\nabla_{\\mathbf{r}_a} c_k(\\mathbf{r})\\right)^\\top \\left(m_a^{-1} I_3\\right) \\left(\\nabla_{\\mathbf{r}_a} c_l(\\mathbf{r})\\right).\n$$\n当约束形成多个闭环或近似线性相关时，$A(\\mathbf{r})$ 可能是病态的（近奇异）。为了在 SHAKE 或 RATTLE 中施加约束，需要求解线性系统 $A(\\mathbf{r}) \\, \\boldsymbol{\\lambda} = \\mathbf{b}$ 以获得拉格朗日乘子 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^K$，其中 $\\mathbf{b} \\in \\mathbb{R}^K$ 取决于当前的约束违反情况和积分细节。用于求解线性系统的高斯-赛德尔迭代法使用 $A(\\mathbf{r})$ 的下三角部分顺序更新 $\\boldsymbol{\\lambda}$，其收敛速率随着 $A(\\mathbf{r})$ 条件数的增加而恶化。\n\n你的任务是编写一个完整的、可运行的程序，该程序从第一性原理出发，构建几个分子图及其对应的 $A(\\mathbf{r})$ 矩阵，并为每种情况根据经验确定将相对残差范数减小到指定容差 $\\epsilon$ 以下所需的高斯-赛德尔迭代次数的下界。具体来说：\n\n- 仅使用以下基本定义和事实：\n  - 带完整约束的牛顿力学和拉格朗日乘子形式体系。\n  - 由 $c_k(\\mathbf{r})$ 的梯度构成的约束雅可比矩阵 $G(\\mathbf{r})$。\n  - 质量加权耦合 $A(\\mathbf{r}) = G(\\mathbf{r}) M^{-1} G(\\mathbf{r})^\\top$。\n  - 求解 $A \\boldsymbol{\\lambda} = \\mathbf{b}$ 的高斯-赛德尔迭代，从 $\\boldsymbol{\\lambda}^{(0)} = \\mathbf{0}$ 初始化，它使用最新值顺序更新每个分量 $\\lambda_i$。\n  - 在第 $t$ 次迭代时的相对残差为 $\\rho^{(t)} = \\lVert \\mathbf{b} - A \\boldsymbol{\\lambda}^{(t)} \\rVert_2 / \\lVert \\mathbf{b} \\rVert_2$。\n\n- 对于每个测试实例，将右侧定义为常数向量 $\\mathbf{b} = (1, 1, \\dots, 1)^\\top \\in \\mathbb{R}^K$。\n\n- 对于每个测试实例，除非另有说明，否则所有质量 $m_a$ 均等于 $1$。\n\n- 使用标准的前向扫描更新来实现高斯-赛德尔方法\n  $$\n  \\lambda_i^{(t+1)} \\leftarrow \\frac{1}{A_{ii}} \\left(b_i - \\sum_{j=1}^{i-1} A_{ij} \\lambda_j^{(t+1)} - \\sum_{j=i+1}^{K} A_{ij} \\lambda_j^{(t)} \\right),\n  $$\n  并在满足 $\\rho^{(T)} \\le \\epsilon$ 的最小迭代指数 $T$ 处停止。这个 $T$ 就是所要求的经验下界。\n\n- 如果在 $10^5$ 次迭代内未达到收敛，则停止并为该测试返回已达到的迭代次数 $10^5$。\n\n构建以下测试套件。每个测试实例由粒子位置、一组成对距离约束、不全为 $1$ 时的质量向量以及容差 $\\epsilon$ 指定。此问题中没有物理单位；所有量都是无量纲的。\n\n- 测试 1（平凡情况，单个约束）：\n  - 粒子：$N=2$，位置为 $\\mathbf{r}_0 = (0, 0, 0)$, $\\mathbf{r}_1 = (1, 0, 0)$。\n  - 约束：$K=1$，边为 $(0,1)$。\n  - 质量：全部为 $1$。\n  - 容差：$\\epsilon = 10^{-12}$。\n\n- 测试 2（带闭环的单环）：\n  - 粒子：$N=6$，位于 $xy$ 平面单位圆上，角度为 $2\\pi i / 6$，$i \\in \\{0,1,2,3,4,5\\}$，即 $\\mathbf{r}_i = (\\cos(2\\pi i/6), \\sin(2\\pi i/6), 0)$。\n  - 约束：$K=6$，形成环的边为 $(i, (i+1) \\bmod 6)$，$i \\in \\{0,1,2,3,4,5\\}$。\n  - 质量：全部为 $1$。\n  - 容差：$\\epsilon = 10^{-8}$。\n\n- 测试 3（增加弦以提高环连通性的环）：\n  - 粒子：与测试 2 相同。\n  - 约束：6 条环边加上一条弦 $(0,3)$，因此 $K=7$。\n  - 质量：全部为 $1$。\n  - 容差：$\\epsilon = 10^{-8}$。\n\n- 测试 4（近奇异的三重约束三角形，几乎共线）：\n  - 粒子：$N=3$，位置为 $\\mathbf{r}_0 = (0, 0, 0)$, $\\mathbf{r}_1 = (1, 0, 0)$, $\\mathbf{r}_2 = (2, 10^{-6}, 0)$。\n  - 约束：$K=3$，边为 $(0,1)$, $(1,2)$, $(0,2)$。\n  - 质量：全部为 $1$。\n  - 容差：$\\epsilon = 10^{-12}$。\n\n- 测试 5（线性链，三对角耦合）：\n  - 粒子：$N=4$，位置为 $\\mathbf{r}_0 = (0, 0, 0)$, $\\mathbf{r}_1 = (1, 0, 0)$, $\\mathbf{r}_2 = (2, 0, 0)$, $\\mathbf{r}_3 = (3, 0, 0)$。\n  - 约束：$K=3$，边为 $(0,1)$, $(1,2)$, $(2,3)$。\n  - 质量：全部为 $1$。\n  - 容差：$\\epsilon = 10^{-10}$。\n\n你的程序必须：\n\n- 根据梯度和质量显式构建 $A(\\mathbf{r})$。\n- 从 $\\boldsymbol{\\lambda}^{(0)} = \\mathbf{0}$ 开始运行高斯-赛德尔方法，并为每个测试计算满足 $\\rho^{(T)} \\le \\epsilon$ 的最小 $T$。\n- 将五个测试的结果汇总到单行输出中，格式为 Python 整数列表的精确格式，例如，$[T_1,T_2,T_3,T_4,T_5]$，逗号后没有空格。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4,result5]”）。",
            "solution": "该问题要求实现一个程序，用于在约束分子动力学背景下求解拉格朗日乘子时，根据经验确定高斯-赛德尔迭代达到收敛所需的次数。这包括两个主要步骤：首先，根据分子系统的几何形状和拓扑结构构建约束耦合矩阵 $A(\\mathbf{r})$；其次，将迭代求解器应用于得到的线性系统。\n\n问题的核心在于完整约束的形式体系。一组 $K$ 个约束由 $c_k(\\mathbf{r}) = 0$ 给出，其中 $k=1, \\dots, K$。对于此问题，约束是成对距离，$c_k(\\mathbf{r}) = \\lVert \\mathbf{r}_{i_k} - \\mathbf{r}_{j_k} \\rVert^2 - d_{i_k j_k}^2 = 0$。在 SHAKE 或 RATTLE 等算法中，满足这些条件所需的约束力与约束的梯度 $\\nabla_{\\mathbf{r}_a} c_k(\\mathbf{r})$ 成正比。比例系数是拉格朗日乘子 $\\lambda_k$。\n\n约束违反与所需乘子之间的关系被封装在一个线性系统 $A(\\mathbf{r})\\boldsymbol{\\lambda} = \\mathbf{b}$ 中，其中 $A(\\mathbf{r})$ 是一个对称的 $K \\times K$ 矩阵。矩阵 $A(\\mathbf{r})$ 定义为 $A(\\mathbf{r}) = G(\\mathbf{r}) M^{-1} G(\\mathbf{r})^\\top$，其中 $G(\\mathbf{r})$ 是 $K \\times 3N$ 约束雅可比矩阵，其行是每个约束相对于所有粒子坐标的展开梯度，而 $M$ 是 $3N \\times 3N$ 的对角质量矩阵。该矩阵的元素 $A_{kl}$ 表示约束 $k$ 和约束 $l$ 之间通过粒子的质量加权迁移率产生的耦合。\n\n元素 $A_{kl}$ 的显式公式如下：\n$$\nA_{kl}(\\mathbf{r}) = \\sum_{a=1}^{N} \\frac{1}{m_a} \\left(\\nabla_{\\mathbf{r}_a} c_k(\\mathbf{r})\\right)^\\top \\left(\\nabla_{\\mathbf{r}_a} c_l(\\mathbf{r})\\right)\n$$\n粒子 $i_k$ 和 $j_k$ 之间的约束 $c_k(\\mathbf{r})$ 的梯度仅对这两个粒子非零。令 $\\mathbf{d}_k = \\mathbf{r}_{i_k} - \\mathbf{r}_{j_k}$。梯度为：\n$$\n\\nabla_{\\mathbf{r}_a} c_k(\\mathbf{r}) = \n\\begin{cases} \n2\\mathbf{d}_k  \\text{if } a = i_k \\\\\n-2\\mathbf{d}_k  \\text{if } a = j_k \\\\\n\\mathbf{0}  \\text{otherwise}\n\\end{cases}\n$$\n因此，$A_{kl}$ 的求和仅包括同时属于约束 $k$（涉及粒子 $i_k, j_k$）和约束 $l$（涉及 $i_l, j_l$）的公共粒子的项。\n\n我们来分析一下 $A_{kl}$ 的结构：\n1.  **对角元素 ($k=l$):** 约束与自身耦合。所涉及的粒子是 $i_k$ 和 $j_k$。\n    $$\n    A_{kk} = \\frac{1}{m_{i_k}}(\\nabla_{\\mathbf{r}_{i_k}} c_k)^\\top(\\nabla_{\\mathbf{r}_{i_k}} c_k) + \\frac{1}{m_{j_k}}(\\nabla_{\\mathbf{r}_{j_k}} c_k)^\\top(\\nabla_{\\mathbf{r}_{j_k}} c_k)\n    $$\n    $$\n    A_{kk} = \\frac{1}{m_{i_k}}(2\\mathbf{d}_k)^\\top(2\\mathbf{d}_k) + \\frac{1}{m_{j_k}}(-2\\mathbf{d}_k)^\\top(-2\\mathbf{d}_k) = 4\\lVert \\mathbf{d}_k \\rVert^2 \\left( \\frac{1}{m_{i_k}} + \\frac{1}{m_{j_k}} \\right)\n    $$\n2.  **非对角元素 ($k \\neq l$):** 耦合取决于共享的粒子。求和是针对原子 $a \\in \\{i_k, j_k\\} \\cap \\{i_l, j_l\\}$。对于每个这样的共享原子 $a$，我们加上一项 $\\frac{1}{m_a} (\\nabla_{\\mathbf{r}_a} c_k) \\cdot (\\nabla_{\\mathbf{r}_a} c_l)$。例如，如果约束恰好共享一个粒子，比如 $i_k = i_l = a$，且粒子 $j_k, j_l$ 是不同的，则该项为：\n    $$\n    A_{kl} = \\frac{1}{m_a}(\\nabla_{\\mathbf{r}_a} c_k)^\\top(\\nabla_{\\mathbf{r}_a} c_l) = \\frac{1}{m_a}(2\\mathbf{d}_k)^\\top(2\\mathbf{d}_l) = \\frac{4}{m_a} \\mathbf{d}_k \\cdot \\mathbf{d}_l\n    $$\n    如果一个约束涉及原子 $a$ 作为其第一个粒子 ($i_k=a$)，而另一个约束涉及它作为第二个粒子 ($j_l=a$)，则符号会反转：\n    $$\n    A_{kl} = \\frac{1}{m_a}(2\\mathbf{d}_k)^\\top(-2\\mathbf{d}_l) = -\\frac{4}{m_a} \\mathbf{d}_k \\cdot \\mathbf{d}_l\n    $$\n    一个通用的实现将对所有四种可能的符号组合进行求和，这取决于共享原子在每个约束中扮演的角色。\n\n一旦为给定系统构建了矩阵 $A$，我们就使用高斯-赛德尔方法求解线性系统 $A\\boldsymbol{\\lambda} = \\mathbf{b}$。给定初始猜测 $\\boldsymbol{\\lambda}^{(0)} = \\mathbf{0}$，该方法迭代更新每个分量 $\\lambda_i$ ($i=1, \\dots, K$)，如下所示：\n$$\n\\lambda_i^{(t+1)} = \\frac{1}{A_{ii}} \\left(b_i - \\sum_{j=1}^{i-1} A_{ij} \\lambda_j^{(t+1)} - \\sum_{j=i+1}^{K} A_{ij} \\lambda_j^{(t)} \\right)\n$$\n迭代过程从 $t=0, 1, 2, \\dots$ 开始，直到相对残差范数 $\\rho^{(t)} = \\lVert \\mathbf{b} - A \\boldsymbol{\\lambda}^{(t)} \\rVert_2 / \\lVert \\mathbf{b} \\rVert_2$ 小于指定的容差 $\\epsilon$。达到此目的所需的迭代次数 $T$ 就是期望的输出。对于此问题，$\\mathbf{b}$ 是一个全为一的向量。对五个测试配置中的每一个重复此过程，这些配置旨在探测矩阵 $A$ 的不同条件属性，从平凡的单个约束到由近共线几何产生的近奇异系统。\n\n实现将包括一个主函数，该函数遍历所有测试用例。对于每个用例，它将：\n1.  初始化粒子位置、质量和约束定义。\n2.  调用一个子程序，使用派生的公式构建 $K \\times K$ 矩阵 $A$。\n3.  调用第二个子程序来执行高斯-赛德尔迭代，从 $\\boldsymbol{\\lambda}^{(0)} = \\mathbf{0}$ 开始并使用 $\\mathbf{b} = (1, \\dots, 1)^\\top$，计算迭代次数直到满足收敛准则 $\\rho^{(T)} \\leq \\epsilon$ 或达到 $10^5$ 次迭代的最大值。\n4.  存储得到的迭代次数 $T$。\n最后，将所有计算出的迭代次数收集起来，并格式化为所需的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_A(positions, constraints, masses):\n    \"\"\"\n    Constructs the A matrix from particle positions, constraints, and masses.\n\n    Args:\n        positions (np.ndarray): (N, 3) array of particle positions.\n        constraints (list of tuples): List of K constraints, each a tuple (i, j) of particle indices.\n        masses (np.ndarray): (N,) array of particle masses.\n\n    Returns:\n        np.ndarray: The (K, K) symmetric matrix A.\n    \"\"\"\n    K = len(constraints)\n    A = np.zeros((K, K))\n\n    # Pre-calculate difference vectors for all constraints\n    d_vectors = []\n    for i_k, j_k in constraints:\n        d_vectors.append(positions[i_k] - positions[j_k])\n    d_vectors = np.array(d_vectors)\n\n    for k in range(K):\n        for l in range(k, K):\n            i_k, j_k = constraints[k]\n            i_l, j_l = constraints[l]\n\n            d_k = d_vectors[k]\n            d_l = d_vectors[l]\n\n            # Find common particles between constraint k and l\n            common_particles = set([i_k, j_k]).intersection(set([i_l, j_l]))\n            \n            sum_term = 0.0\n            for a in common_particles:\n                # Determine sign for gradient based on atom's role in constraint\n                sign_k = 1 if a == i_k else -1\n                sign_l = 1 if a == i_l else -1\n                \n                # Gradients are (sign * 2 * d), so dot product is (4 * sign_k * sign_l * d_k . d_l)\n                term = (4.0 * sign_k * sign_l * np.dot(d_k, d_l)) / masses[a]\n                sum_term += term\n\n            A[k, l] = sum_term\n            if k != l:\n                A[l, k] = sum_term\n    \n    return A\n\ndef gauss_seidel(A, b, epsilon, max_iter):\n    \"\"\"\n    Solves Ax = b using the Gauss-Seidel method.\n\n    Args:\n        A (np.ndarray): The matrix A.\n        b (np.ndarray): The vector b.\n        epsilon (float): The tolerance for the relative residual norm.\n        max_iter (int): The maximum number of iterations.\n\n    Returns:\n        int: The number of iterations performed.\n    \"\"\"\n    K = len(b)\n    lambdas = np.zeros(K)\n    \n    norm_b = np.linalg.norm(b)\n    if norm_b == 0:\n        return 0\n\n    for t in range(max_iter):\n        lambdas_old = np.copy(lambdas)\n        for i in range(K):\n            # Sum over j  i using newly computed lambda values\n            sigma1 = np.dot(A[i, :i], lambdas[:i])\n            # Sum over j > i using old lambda values\n            sigma2 = np.dot(A[i, i + 1:], lambdas_old[i + 1:])\n            \n            if A[i, i] == 0: # Avoid division by zero, though A should be positive definite\n                return max_iter\n                \n            lambdas[i] = (b[i] - sigma1 - sigma2) / A[i, i]\n\n        # Check for convergence\n        residual = b - A @ lambdas\n        rel_residual_norm = np.linalg.norm(residual) / norm_b\n        \n        if rel_residual_norm = epsilon:\n            return t + 1\n            \n    return max_iter\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    max_iterations = 100000\n\n    test_cases = [\n        # Test 1 (trivial, single constraint)\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0]]),\n            \"constraints\": [(0, 1)],\n            \"masses\": np.array([1.0, 1.0]),\n            \"epsilon\": 1e-12\n        },\n        # Test 2 (single ring with closed loop)\n        {\n            \"positions\": np.array([\n                [np.cos(2 * np.pi * i / 6), np.sin(2 * np.pi * i / 6), 0.0]\n                for i in range(6)\n            ]),\n            \"constraints\": [(i, (i + 1) % 6) for i in range(6)],\n            \"masses\": np.ones(6),\n            \"epsilon\": 1e-8\n        },\n        # Test 3 (ring with an added chord)\n        {\n            \"positions\": np.array([\n                [np.cos(2 * np.pi * i / 6), np.sin(2 * np.pi * i / 6), 0.0]\n                for i in range(6)\n            ]),\n            \"constraints\": [(i, (i + 1) % 6) for i in range(6)] + [(0, 3)],\n            \"masses\": np.ones(6),\n            \"epsilon\": 1e-8\n        },\n        # Test 4 (nearly singular triple-constraint triangle)\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [2.0, 1e-6, 0.0]]),\n            \"constraints\": [(0, 1), (1, 2), (0, 2)],\n            \"masses\": np.ones(3),\n            \"epsilon\": 1e-12\n        },\n        # Test 5 (linear chain, tridiagonal coupling)\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [2.0, 0.0, 0.0], [3.0, 0.0, 0.0]]),\n            \"constraints\": [(0, 1), (1, 2), (2, 3)],\n            \"masses\": np.ones(4),\n            \"epsilon\": 1e-10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A = build_A(case[\"positions\"], case[\"constraints\"], case[\"masses\"])\n        K = len(case[\"constraints\"])\n        b = np.ones(K)\n        iterations = gauss_seidel(A, b, case[\"epsilon\"], max_iterations)\n        results.append(iterations)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在一个生产级别的分子动力学模拟中，仅仅期望约束求解器收敛是不够的；我们必须主动监控其性能并适应变化的条件。这最后一个练习将指导你设计和实现完成此任务所需的工具 。你将推导用于诊断约束违例的量化指标，并使用它们构建一个自适应算法，该算法能动态调整求解器参数，从而确保计算效率和物理精度之间的平衡。",
            "id": "3439765",
            "problem": "要求您为分子动力学中的完整距离约束设计和实现诊断度量，并提出如何使用这些度量在运行期间调整迭代次数或容差。考虑一个由 $N$ 个点粒子组成的系统，其位置为 $\\mathbf{q} \\in \\mathbb{R}^{3N}$，速度为 $\\mathbf{v} \\in \\mathbb{R}^{3N}$，该系统根据牛顿第二定律演化，并受到完整约束的作用，这些约束对选定的粒子对之间的键长强制施加固定值。约束被指定为 $C$ 个粒子对 $(i,j)$，其目标距离为 $d_{ij}$，必须在任何时候都满足固定距离的等式条件。约束通过迭代算法（如SHAKE算法，用于强制位置约束）和RATTLE算法（用于强制速度约束）来实施，这些算法应用增量拉格朗日乘子更新。\n\n从完整约束及其时间导数的定义出发，推导用于量化位置和速度约束违背情况的诊断度量。您的度量必须基于固定距离约束的几何定义，并且必须同时包含位置和速度的最大违背值和所有约束的均方根（RMS）违背值。对于位置度量，违背值应基于实际原子间距离与目标值的偏差。对于速度度量，违背值应基于相对速度沿键方向的分量。所有位置量必须以米为单位表示，所有速度量必须以米/秒为单位表示。诊断度量必须在不依赖简化公式的情况下定义，并且必须从基本的约束定义中推导出来。\n\n此外，请为以下内容提出一种自适应策略：\n- 在给定时间步长下，位置约束求解器（例如SHAKE）和速度约束求解器（例如RATTLE）使用的迭代次数，以及\n- 定义可接受的约束满足程度的位置和速度容差。\n\n您的自适应策略必须建立在迭代求解器的线性收缩模型之上，该模型的特征是应用于违背幅度的每次迭代的缩减因子 $\\rho \\in (0,1)$。假设您可以访问当前的违背幅度和当前的迭代次数。请推导达到给定目标容差需要多少次额外迭代，并定义一个使用计算出的诊断度量来调整容差的鲁棒规则。您的自适应规则必须包含边界，以避免提出不符合物理规律或数值不稳定的建议。\n\n实现一个程序，为每个测试用例计算：\n- 最大位置违背值（米），\n- 均方根位置违背值（米），\n- 最大速度违背值（米/秒），\n- 均方根速度违背值（米/秒），\n- 推荐的位置求解器新总迭代次数（一个整数），\n- 推荐的速度求解器新总迭代次数（一个整数），\n- 推荐的下一个位置容差（米）（一个浮点数），\n- 推荐的下一个速度容差（米/秒）（一个浮点数）。\n\n使用以下基于收缩的自适应策略：\n- 给定当前最大违背值 $V$ 和目标容差 $\\tau$，以及当前总迭代次数 $n$ 和收缩因子 $\\rho \\in (0,1)$，计算所需的额外迭代次数 $x$，以使 $V \\rho^{x} \\le \\tau$。如果 $\\rho \\ge 1$，则将求解器视为不收敛，并将 $x$ 设置为达到上限所需的剩余预算。新的总迭代次数为 $n + x$，并被限制在最大上限内。\n- 定义安全因子 $s = \\max(V, \\varepsilon) / \\tau$，其中使用一个小的 $\\varepsilon$ 来正则化除法。通过幂律规则 $\\tau_{\\text{next}} = \\operatorname{clamp}\\left(\\tau \\cdot s^{-\\eta}, \\tau_{\\min}, \\tau_{\\max}\\right)$ 更新容差，其中指数 $\\eta  0$ 和边界 $\\tau_{\\min}$ 和 $\\tau_{\\max}$ 是预先设定的。\n\n您的程序必须产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个测试用例的结果本身就是按上述顺序排列的列表。例如，最终输出格式必须类似于 $[\\,[r_{1,1},r_{1,2},\\dots],[r_{2,1},r_{2,2},\\dots]\\,]$。\n\n以下所有输入使用的位置单位为米，速度单位为米/秒。不使用角度。对于容差更新规则，使用 $\\eta = 0.5$，位置容差的边界为 $\\tau_{\\min} = 10^{-13}$，$\\tau_{\\max} = 10^{-11}$，速度容差的边界为 $\\tau_{\\min} = 10^{-13}$，$\\tau_{\\max} = 10^{-11}$，所有单位均为其各自的单位。\n\n测试套件：\n- 测试用例 1（正常路径）：\n  - $N = 3$，约束：$(0,1)$ 和 $(1,2)$，其中 $d_{01} = 10^{-10}$ 和 $d_{12} = 10^{-10}$。\n  - 位置 $\\mathbf{q}$：$\\mathbf{r}_0 = (0,0,0)$，$\\mathbf{r}_1 = (1.01 \\times 10^{-10}, 0, 0)$，$\\mathbf{r}_2 = (2.0 \\times 10^{-10}, 0, 0)$。\n  - 速度 $\\mathbf{v}$：$\\mathbf{v}_0 = (0,0,0)$，$\\mathbf{v}_1 = (0,10^{-3},0)$，$\\mathbf{v}_2 = (0,0,0)$。\n  - 当前迭代次数：位置 $n_p = 2$，速度 $n_v = 2$。\n  - 目标容差：$\\tau_p = 10^{-12}$ 米，$\\tau_v = 10^{-12}$ 米/秒。\n  - 收缩因子：$\\rho_p = 0.5$，$\\rho_v = 0.5$。\n  - 上限：$n_{p,\\max} = 8$, $n_{v,\\max} = 8$。\n- 测试用例 2（边界：零违背）：\n  - $N = 3$，约束：$(0,1)$ 和 $(1,2)$，其中 $d_{01} = 10^{-10}$ 和 $d_{12} = 10^{-10}$。\n  - 位置 $\\mathbf{q}$：$\\mathbf{r}_0 = (0,0,0)$，$\\mathbf{r}_1 = (1.0 \\times 10^{-10}, 0, 0)$，$\\mathbf{r}_2 = (2.0 \\times 10^{-10}, 0, 0)$。\n  - 速度 $\\mathbf{v}$：$\\mathbf{v}_0 = (0,0,0)$，$\\mathbf{v}_1 = (0,10^{-2},0)$，$\\mathbf{v}_2 = (0,-10^{-2},0)$。\n  - 当前迭代次数：位置 $n_p = 1$，速度 $n_v = 1$。\n  - 目标容差：$\\tau_p = 10^{-12}$ 米，$\\tau_v = 10^{-12}$ 米/秒。\n  - 收缩因子：$\\rho_p = 0.7$，$\\rho_v = 0.7$。\n  - 上限：$n_{p,\\max} = 5$, $n_{v,\\max} = 5$。\n- 测试用例 3（边缘：高违背和慢收缩）：\n  - $N = 3$，约束：$(0,1)$ 和 $(1,2)$，其中 $d_{01} = 10^{-10}$ 和 $d_{12} = 10^{-10}$。\n  - 位置 $\\mathbf{q}$：$\\mathbf{r}_0 = (0,0,0)$，$\\mathbf{r}_1 = (0.95 \\times 10^{-10}, 0, 0)$，$\\mathbf{r}_2 = (1.90 \\times 10^{-10}, 0, 0)$。\n  - 速度 $\\mathbf{v}$：$\\mathbf{v}_0 = (0,0,0)$，$\\mathbf{v}_1 = (10^{-3},0,0)$，$\\mathbf{v}_2 = (-10^{-3},0,0)$。\n  - 当前迭代次数：位置 $n_p = 1$，速度 $n_v = 1$。\n  - 目标容差：$\\tau_p = 10^{-12}$ 米，$\\tau_v = 10^{-12}$ 米/秒。\n  - 收缩因子：$\\rho_p = 0.9$，$\\rho_v = 0.95$。\n  - 上限：$n_{p,\\max} = 20$, $n_{v,\\max} = 20$。\n\n您的程序必须产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是按上述顺序排列的列表，数字以标准十进制表示法表示，不带单位。例如：$[[\\dots],[\\dots],[\\dots]]$。",
            "solution": "该问题要求推导并实现用于分子动力学模拟中完整距离约束的诊断度量和自适应策略。该问题具有科学依据，定义明确，并为得出唯一解提供了所有必要信息。\n\n首先，我们从基本原理推导约束违背的诊断度量。两个粒子 $i$ 和 $j$ 之间的完整距离约束，其位置分别为 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 和 $\\mathbf{r}_j \\in \\mathbb{R}^3$，表示为要求它们之间的距离保持为一个常数值 $d_{ij}$：\n$$ \\|\\mathbf{r}_i - \\mathbf{r}_j\\| = d_{ij} $$\n为了数值稳定性，这通常写成平方形式：$g_{ij}(\\mathbf{q}) = (\\mathbf{r}_i - \\mathbf{r}_j) \\cdot (\\mathbf{r}_i - \\mathbf{r}_j) - d_{ij}^2 = 0$。\n\n**位置约束违背度量**\n问题规定位置违背度量应基于实际原子间距离与目标值的偏差。对于单个约束 $(i,j)$，违背值 $V_{p, ij}$ 是当前距离与目标距离之间的绝对差：\n$$ V_{p, ij} = \\left| \\|\\mathbf{r}_i - \\mathbf{r}_j\\| - d_{ij} \\right| $$\n对于一个有 $C$ 个此类约束的系统，我们定义两个聚合度量：\n1.  **最大位置违背值 ($V_{p, \\max}$)**：所有约束中的最大违背值，表示最坏情况下的误差。\n    $$ V_{p, \\max} = \\max_{(i,j) \\in \\text{constraints}} \\left\\{ V_{p, ij} \\right\\} $$\n2.  **均方根（RMS）位置违背值 ($V_{p, \\text{rms}}$)**：违背值平方的平均值的平方根，提供了典型误差大小的度量。\n    $$ V_{p, \\text{rms}} = \\sqrt{\\frac{1}{C} \\sum_{(i,j) \\in \\text{constraints}} (V_{p, ij})^2} = \\sqrt{\\frac{1}{C} \\sum_{(i,j) \\in \\text{constraints}} \\left( \\|\\mathbf{r}_i - \\mathbf{r}_j\\| - d_{ij} \\right)^2} $$\n\n**速度约束违背度量**\n速度约束是通过要求位置约束方程的时间导数为零来推导的。令 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$ 和 $\\mathbf{v}_{ij} = \\mathbf{v}_i - \\mathbf{v}_j$，其中 $\\mathbf{v}_i = d\\mathbf{r}_i/dt$ 是粒子 $i$ 的速度。\n$$ \\frac{d}{dt} \\left( \\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ij} - d_{ij}^2 \\right) = 0 $$\n$$ 2 \\mathbf{r}_{ij} \\cdot \\frac{d\\mathbf{r}_{ij}}{dt} = 2 \\mathbf{r}_{ij} \\cdot \\mathbf{v}_{ij} = 0 $$\n这个条件 $\\mathbf{r}_{ij} \\cdot \\mathbf{v}_{ij} = 0$ 意味着相对速度向量必须与粒子间分离向量正交。问题指出，违背度量必须基于相对速度沿键方向的分量。沿键的单位向量是 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / \\|\\mathbf{r}_{ij}\\|$。$\\mathbf{v}_{ij}$ 沿此方向的分量是 $\\mathbf{v}_{ij} \\cdot \\hat{\\mathbf{r}}_{ij}$。单个约束 $(i,j)$ 的速度违背值是该分量的大小：\n$$ V_{v, ij} = \\left| \\mathbf{v}_{ij} \\cdot \\hat{\\mathbf{r}}_{ij} \\right| = \\frac{\\left| (\\mathbf{v}_i - \\mathbf{v}_j) \\cdot (\\mathbf{r}_i - \\mathbf{r}_j) \\right|}{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|} $$\n只要 $\\|\\mathbf{r}_i - \\mathbf{r}_j\\| \\neq 0$，该度量就是明确定义的。\n对于有 $C$ 个约束的系统，聚合度量为：\n1.  **最大速度违背值 ($V_{v, \\max}$)**：\n    $$ V_{v, \\max} = \\max_{(i,j) \\in \\text{constraints}} \\left\\{ V_{v, ij} \\right\\} $$\n2.  **均方根（RMS）速度违背值 ($V_{v, \\text{rms}}$)**：\n    $$ V_{v, \\text{rms}} = \\sqrt{\\frac{1}{C} \\sum_{(i,j) \\in \\text{constraints}} (V_{v, ij})^2} = \\sqrt{\\frac{1}{C} \\sum_{(i,j) \\in \\text{constraints}} \\left( \\frac{(\\mathbf{v}_i - \\mathbf{v}_j) \\cdot (\\mathbf{r}_i - \\mathbf{r}_j)}{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|} \\right)^2} $$\n\n**自适应策略**\n求解器迭代次数和容差的自适应策略基于线性收缩模型和幂律更新规则。\n\n**迭代次数自适应：**\n给定当前最大违背值 $V$（$V_{p, \\max}$ 或 $V_{v, \\max}$）、目标容差 $\\tau$、当前迭代次数 $n$ 和收缩因子 $\\rho \\in (0,1)$，我们寻求满足 $V \\rho^x \\le \\tau$ 所需的最小额外整数迭代次数 $x$。\n如果 $V  \\tau$ 且 $0  \\rho  1$，我们求解 $x$：\n$$ \\rho^x \\le \\frac{\\tau}{V} \\implies x \\log(\\rho) \\le \\log\\left(\\frac{\\tau}{V}\\right) \\implies x \\ge \\frac{\\log(\\tau/V)}{\\log(\\rho)} $$\n由于 $x$ 必须是整数，我们取其上取整：$x = \\lceil \\log(\\tau/V)/\\log(\\rho) \\rceil$。如果 $V \\le \\tau$，则不需要额外迭代，因此 $x=0$。如果求解器不收敛（$\\rho \\ge 1$），则将 $x$ 设置为达到上限所需的剩余预算，即 $n_{\\max} - n$。推荐的新总迭代次数为 $n_{\\text{rec}} = \\min(n+x, n_{\\max})$。\n\n**容差自适应：**\n容差 $\\tau$ 根据观察到的性能进行调整。安全因子 $s = \\max(V, \\varepsilon) / \\tau$ 将实现的违背值 $V$ 与目标值 $\\tau$ 进行比较。一个小常数 $\\varepsilon$ 对除法进行正则化。新容差使用带有指数 $\\eta$ 的幂律规则计算：\n$$ \\tau_{\\text{next}} = \\tau \\cdot s^{-\\eta} $$\n然后将这个新值限制在预定义的范围 $[\\tau_{\\min}, \\tau_{\\max}]$ 内以确保稳定性。对于此问题，$\\eta = 0.5$。该逻辑独立地应用于位置和速度容差，使用它们各自的最大违背值和参数。\n- 如果 $V  \\tau$，则 $s  1$ 且 $s^{-\\eta}  1$，从而收紧下一步的容差。\n- 如果 $V  \\tau$，则 $s  1$ 且 $s^{-\\eta}  1$，从而放宽容差。\n$\\operatorname{clamp}$ 函数定义为 $\\operatorname{clamp}(v, v_{\\min}, v_{\\max}) = \\max(v_{\\min}, \\min(v, v_{\\max}))$。\n\n这些推导出的公式和自适应规则被实现以处理给定的测试用例。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics constraint diagnostics problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (happy path)\n        {\n            \"N\": 3,\n            \"constraints\": [((0, 1), 1e-10), ((1, 2), 1e-10)],\n            \"q\": np.array([[0.0, 0.0, 0.0], [1.01e-10, 0.0, 0.0], [2.0e-10, 0.0, 0.0]]),\n            \"v\": np.array([[0.0, 0.0, 0.0], [0.0, 1e-3, 0.0], [0.0, 0.0, 0.0]]),\n            \"n_p\": 2, \"n_v\": 2,\n            \"tau_p\": 1e-12, \"tau_v\": 1e-12,\n            \"rho_p\": 0.5, \"rho_v\": 0.5,\n            \"n_p_max\": 8, \"n_v_max\": 8\n        },\n        # Test Case 2 (boundary: zero violation)\n        {\n            \"N\": 3,\n            \"constraints\": [((0, 1), 1e-10), ((1, 2), 1e-10)],\n            \"q\": np.array([[0.0, 0.0, 0.0], [1.0e-10, 0.0, 0.0], [2.0e-10, 0.0, 0.0]]),\n            \"v\": np.array([[0.0, 0.0, 0.0], [0.0, 1e-2, 0.0], [0.0, -1e-2, 0.0]]),\n            \"n_p\": 1, \"n_v\": 1,\n            \"tau_p\": 1e-12, \"tau_v\": 1e-12,\n            \"rho_p\": 0.7, \"rho_v\": 0.7,\n            \"n_p_max\": 5, \"n_v_max\": 5\n        },\n        # Test Case 3 (edge: high violation and slow contraction)\n        {\n            \"N\": 3,\n            \"constraints\": [((0, 1), 1e-10), ((1, 2), 1e-10)],\n            \"q\": np.array([[0.0, 0.0, 0.0], [0.95e-10, 0.0, 0.0], [1.90e-10, 0.0, 0.0]]),\n            \"v\": np.array([[0.0, 0.0, 0.0], [1e-3, 0.0, 0.0], [-1e-3, 0.0, 0.0]]),\n            \"n_p\": 1, \"n_v\": 1,\n            \"tau_p\": 1e-12, \"tau_v\": 1e-12,\n            \"rho_p\": 0.9, \"rho_v\": 0.95,\n            \"n_p_max\": 20, \"n_v_max\": 20\n        }\n    ]\n\n    eta = 0.5\n    tau_p_bounds = (1e-13, 1e-11)\n    tau_v_bounds = (1e-13, 1e-11)\n    epsilon = np.finfo(float).eps\n\n    results = []\n    for case in test_cases:\n        positions = case[\"q\"]\n        velocities = case[\"v\"]\n        \n        pos_violations = []\n        vel_violations = []\n\n        for (i, j), d_ij in case[\"constraints\"]:\n            r_i, r_j = positions[i], positions[j]\n            v_i, v_j = velocities[i], velocities[j]\n            \n            r_ij = r_i - r_j\n            norm_rij = np.linalg.norm(r_ij)\n            \n            # Position violation\n            pos_viol = abs(norm_rij - d_ij)\n            pos_violations.append(pos_viol)\n            \n            # Velocity violation\n            if norm_rij  0:\n                v_ij = v_i - v_j\n                vel_viol = abs(np.dot(v_ij, r_ij)) / norm_rij\n            else:\n                vel_viol = 0.0 if np.allclose(v_i, v_j) else float('inf')\n            vel_violations.append(vel_viol)\n            \n        pos_violations = np.array(pos_violations)\n        vel_violations = np.array(vel_violations)\n        \n        max_pos_viol = np.max(pos_violations)\n        rms_pos_viol = np.sqrt(np.mean(np.square(pos_violations)))\n        \n        # Handle case where there are no velocity violations\n        if len(vel_violations)  0 and np.all(vel_violations == 0):\n             max_vel_viol = 0.0\n             rms_vel_viol = 0.0\n        elif len(vel_violations)  0:\n             max_vel_viol = np.max(vel_violations)\n             rms_vel_viol = np.sqrt(np.mean(np.square(vel_violations)))\n        else: # No constraints\n             max_vel_viol = 0.0\n             rms_vel_viol = 0.0\n\n        # Adaptation for iteration counts\n        # Position\n        if max_pos_viol = case[\"tau_p\"]:\n            x_p = 0\n        elif case[\"rho_p\"] = 1.0:\n            x_p = case[\"n_p_max\"] - case[\"n_p\"]\n        else:\n            x_p = math.ceil(math.log(case[\"tau_p\"] / max_pos_viol) / math.log(case[\"rho_p\"]))\n        \n        rec_n_p = int(min(case[\"n_p\"] + x_p, case[\"n_p_max\"]))\n\n        # Velocity\n        if max_vel_viol = case[\"tau_v\"]:\n            x_v = 0\n        elif case[\"rho_v\"] = 1.0:\n            x_v = case[\"n_v_max\"] - case[\"n_v\"]\n        else:\n            # Avoid log(0) if max_vel_viol is 0 but still greater than tau_v, which won't happen.\n            # However, if max_vel_viol is tiny, protect against large computation.\n            # Based on logic, max_vel_viol > tau_v > 0 here.\n            x_v = math.ceil(math.log(case[\"tau_v\"] / max_vel_viol) / math.log(case[\"rho_v\"]))\n        \n        rec_n_v = int(min(case[\"n_v\"] + x_v, case[\"n_v_max\"]))\n        \n        # Adaptation for tolerances\n        # Position\n        s_p = max(max_pos_viol, epsilon) / case[\"tau_p\"]\n        tau_p_next_raw = case[\"tau_p\"] * (s_p ** -eta)\n        rec_tau_p = np.clip(tau_p_next_raw, tau_p_bounds[0], tau_p_bounds[1])\n\n        # Velocity\n        s_v = max(max_vel_viol, epsilon) / case[\"tau_v\"]\n        tau_v_next_raw = case[\"tau_v\"] * (s_v ** -eta)\n        rec_tau_v = np.clip(tau_v_next_raw, tau_v_bounds[0], tau_v_bounds[1])\n        \n        case_results = [\n            max_pos_viol, rms_pos_viol,\n            max_vel_viol, rms_vel_viol,\n            rec_n_p, rec_n_v,\n            rec_tau_p, rec_tau_v\n        ]\n        results.append(case_results)\n\n    # Format output as a string representation of a list of lists.\n    result_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}