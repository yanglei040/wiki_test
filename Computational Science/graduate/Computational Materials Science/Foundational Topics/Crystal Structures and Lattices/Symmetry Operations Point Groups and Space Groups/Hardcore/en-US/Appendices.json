{
    "hands_on_practices": [
        {
            "introduction": "Before relying on automated software, a computational scientist must grasp the foundational link between a crystal's metric and its classification. This exercise takes you back to first principles, asking you to derive the Bravais lattice type and crystal system directly from a given set of lattice parameters ($a,b,c, \\alpha, \\beta, \\gamma$). Mastering this practice sharpens your ability to interpret geometric data and reinforces the crucial distinction between a primitive cell, which contains one lattice point, and a conventional cell, which is chosen to clearly exhibit the lattice's full symmetry .",
            "id": "3491341",
            "problem": "A crystalline solid has lattice parameters $(a,b,c,\\alpha,\\beta,\\gamma)$ satisfying $a=b\\neq c$, $\\alpha=\\beta=90^{\\circ}$, and $\\gamma=120^{\\circ}$, where all angles are given in degrees. Starting from the core definitions of Bravais lattices, crystal systems, conventional versus primitive cells, and the geometric definition of a unit cell volume as the volume of a parallelepiped spanned by translation vectors, do the following:\n\n- Use the metric constraints to determine the crystal system and Bravais lattice type from first principles.\n- Identify whether the conventional cell for this Bravais lattice is primitive or centered, and justify your choice using symmetry and metric arguments.\n- Construct a set of primitive translation vectors in a right-handed Cartesian frame with the $c$ axis along $\\hat{\\mathbf{z}}$ and the basal plane spanned by $\\hat{\\mathbf{x}}$ and $\\hat{\\mathbf{y}}$, consistent with the given metric constraints.\n- Using only the geometric definition of volume via the scalar triple product, derive the primitive cell volume $V_{p}$ from your primitive translation vectors and simplify the result.\n\nProvide, as your final answer, the exact value of the dimensionless ratio $V_{p}/(a^{2}c)$. Do not approximate your answer; give it in exact closed form. No units are required for this dimensionless ratio. The final answer must be a single expression.",
            "solution": "The analysis of the problem statement begins with the validation of its premises and constraints. The given lattice parameters are $(a,b,c,\\alpha,\\beta,\\gamma)$ with the constraints $a=b\\neq c$, $\\alpha=\\beta=90^{\\circ}$, and $\\gamma=120^{\\circ}$. These constraints are self-consistent and correspond to the definition of a standard crystal system in crystallography. The problem is scientifically grounded, well-posed, and objective, with all information required for a unique solution provided. Therefore, the problem is valid, and we may proceed with the solution.\n\nThe first task is to determine the crystal system and Bravais lattice type from the given metric constraints. Crystal systems are classified based on the minimum symmetry required to describe the lattice geometry, which is reflected in the constraints on the conventional unit cell axes and angles. The given constraints are $a=b \\neq c$, $\\alpha=\\beta=90^{\\circ}$, and $\\gamma=120^{\\circ}$. The presence of a unique axis (the $c$-axis, since $c \\neq a, b$) perpendicular to a basal plane (since $\\alpha = \\beta = 90^{\\circ}$) where the two-dimensional lattice has two equal axes with a non-$90^{\\circ}$ angle ($a=b, \\gamma=120^{\\circ}$) is characteristic of the hexagonal crystal system. A hexagonal lattice possesses a single axis of either $6$-fold or $3$-fold rotational symmetry. The specific angle $\\gamma=120^{\\circ}$ implies the presence of a $6$-fold or $3$-fold axis, which is the defining symmetry element for the hexagonal family. The provided constraints define the conventional cell of the **Hexagonal** crystal system. For the hexagonal system, there is only one Bravais lattice: the **Hexagonal Primitive** lattice, denoted by the symbol P.\n\nThe second task is to identify whether the conventional cell for this Bravais lattice is primitive or centered. A primitive cell contains exactly one lattice point. The conventional cell for the hexagonal Bravais lattice has lattice points only at its corners. By convention, the lattice points at the corners of a unit cell are shared among the $8$ cells that meet at that corner, so each of the $8$ corners contributes $1/8$ of a lattice point to the cell. Thus, the total number of lattice points per conventional hexagonal cell is $8 \\times (1/8) = 1$. Since the conventional cell contains precisely one lattice point, it is, by definition, a **primitive** cell. No centering vectors are needed to describe the lattice. It is important to distinguish this from the rhombohedral lattice, which can be described by a non-primitive (centered) hexagonal cell. However, the problem statement's constraints directly define the primitive hexagonal Bravais lattice.\n\nThe third task is to construct a set of primitive translation vectors. Since the conventional cell is primitive, we can use its lattice vectors. We will define a right-handed Cartesian coordinate system as specified, with the $c$-axis along $\\hat{\\mathbf{z}}$. The primitive translation vectors are denoted as $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$.\nTheir magnitudes are $|\\mathbf{a}_1|=a$, $|\\mathbf{a}_2|=b=a$, and $|\\mathbf{a}_3|=c$.\nThe angles between them are $\\angle(\\mathbf{a}_2, \\mathbf{a}_3) = \\alpha = 90^{\\circ}$, $\\angle(\\mathbf{a}_1, \\mathbf{a}_3) = \\beta = 90^{\\circ}$, and $\\angle(\\mathbf{a}_1, \\mathbf{a}_2) = \\gamma = 120^{\\circ}$.\n\nWe set up the vectors in Cartesian coordinates $(x,y,z)$:\n1.  Let the vector $\\mathbf{a}_3$ be aligned with the Cartesian $\\hat{\\mathbf{z}}$ axis:\n    $$ \\mathbf{a}_3 = (0, 0, c) $$\n2.  Since $\\alpha = \\beta = 90^{\\circ}$, both $\\mathbf{a}_1$ and $\\mathbf{a}_2$ must lie in the $xy$-plane. We align $\\mathbf{a}_1$ with the Cartesian $\\hat{\\mathbf{x}}$ axis:\n    $$ \\mathbf{a}_1 = (a, 0, 0) $$\n3.  The vector $\\mathbf{a}_2$ must have a magnitude of $a$ and make an angle of $\\gamma=120^{\\circ}$ with $\\mathbf{a}_1$. Its components in the $xy$-plane are:\n    $$ \\mathbf{a}_2 = (a \\cos(120^{\\circ}), a \\sin(120^{\\circ}), 0) $$\n    Using the trigonometric values $\\cos(120^{\\circ}) = -1/2$ and $\\sin(120^{\\circ}) = \\sqrt{3}/2$, we obtain:\n    $$ \\mathbf{a}_2 = \\left(-\\frac{a}{2}, \\frac{a\\sqrt{3}}{2}, 0\\right) $$\nThe resulting set of primitive translation vectors is:\n$$ \\mathbf{a}_1 = (a, 0, 0) $$\n$$ \\mathbf{a}_2 = \\left(-\\frac{a}{2}, \\frac{a\\sqrt{3}}{2}, 0\\right) $$\n$$ \\mathbf{a}_3 = (0, 0, c) $$\n\nThe fourth task is to derive the primitive cell volume, $V_p$, using the scalar triple product of these vectors. The volume is given by $V_p = |\\mathbf{a}_1 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_3)|$, which can be computed as the absolute value of the determinant of the matrix whose rows are the vector components.\n$$ V_p = \\left| \\det \\begin{pmatrix} a  0  0 \\\\ -a/2  a\\sqrt{3}/2  0 \\\\ 0  0  c \\end{pmatrix} \\right| $$\nWe can expand the determinant along the first row:\n$$ V_p = \\left| a \\det \\begin{pmatrix} a\\sqrt{3}/2  0 \\\\ 0  c \\end{pmatrix} - 0 + 0 \\right| $$\n$$ V_p = \\left| a \\left( \\left(\\frac{a\\sqrt{3}}{2}\\right)(c) - (0)(0) \\right) \\right| $$\n$$ V_p = \\left| a \\left( \\frac{a c \\sqrt{3}}{2} \\right) \\right| = \\frac{\\sqrt{3}}{2} a^2 c $$\nThe volume is positive, confirming that the constructed vector set is right-handed. The primitive cell volume is $V_p = \\frac{\\sqrt{3}}{2} a^2 c$.\n\nFinally, we are asked to provide the exact value of the dimensionless ratio $V_p / (a^2 c)$.\n$$ \\frac{V_p}{a^2 c} = \\frac{\\frac{\\sqrt{3}}{2} a^2 c}{a^2 c} $$\nThe terms $a^2$ and $c$ cancel, leaving the simplified expression.\n$$ \\frac{V_p}{a^2 c} = \\frac{\\sqrt{3}}{2} $$\nThis is the final dimensionless ratio in exact closed form.",
            "answer": "$$\\boxed{\\frac{\\sqrt{3}}{2}}$$"
        },
        {
            "introduction": "In practice, we describe complex crystal structures not by listing every atom, but by using the compact language of space groups and Wyckoff positions. This hands-on coding exercise demonstrates how an entire, perfectly symmetric crystal structure can be generated from a minimal set of representative atoms by applying the operations of its space group. By implementing this generative process, you will gain a concrete understanding of how symmetry drastically reduces a structure's descriptive complexity and independent degrees of freedom, a principle that is fundamental to the efficiency of modern materials simulation and crystallographic databases .",
            "id": "3491353",
            "problem": "You are asked to implement a complete and runnable program that constructs a minimal, verifiable pipeline around symmetry operations, Wyckoff positions, and degrees-of-freedom counting in crystalline space groups. The program must operate purely on fractional atomic coordinates in the unit cube and use only a small, explicitly specified subset of space groups. The program must be deterministic and self-contained.\n\nFundamental base and definitions to use:\n- A space group acts on fractional coordinates $\\mathbf{r} \\in [0,1)^3$ by affine maps $(R,\\boldsymbol{\\tau})$ with $R \\in \\mathbb{Z}^{3 \\times 3}$ and $\\boldsymbol{\\tau} \\in \\mathbb{R}^3$, via $\\mathbf{r} \\mapsto R \\mathbf{r} + \\boldsymbol{\\tau}$ modulo lattice translations. Coordinates are always reduced modulo $1$ componentwise.\n- A Wyckoff position is an orbit of a point under the action of the space group, with multiplicity $m$ equal to the number of points in the orbit inside a primitive unit cell for a generic representative of that orbit.\n- The site-symmetry group of a point $\\mathbf{r}$ is the subgroup of space-group operations that leave $\\mathbf{r}$ invariant modulo a lattice vector. For a general Wyckoff position, the site-symmetry group is trivial and has order $1$; for a special Wyckoff position, the site-symmetry group has order greater than $1$.\n- The number of independent positional parameters $p$ for a Wyckoff position is the dimension of the free parameters needed to specify a symmetrically independent representative of that position within the unit cell.\n- Without symmetry, $m$ atoms would have $3 m$ positional degrees of freedom. Under symmetry, only $p$ independent parameters remain. The reduction in independent positional degrees of freedom is therefore $\\Delta = 3 m - p$.\n\nSpace groups and Wyckoff data you must implement:\n- Space group $G = 1$ (symbol $P1$):\n  - Symmetry operations: only the identity $R = I_3$, $\\boldsymbol{\\tau} = (0,0,0)$.\n  - Wyckoff positions:\n    - Letter $\\mathrm{a}$: multiplicity $m = 1$, site symmetry $1$, parameterization $(x,y,z)$ with $p = 3$.\n- Space group $G = 2$ (symbol $P\\bar{1}$):\n  - Symmetry operations: identity and inversion about the origin, i.e., $(R,\\boldsymbol{\\tau}) \\in \\{(I_3,(0,0,0)), (-I_3,(0,0,0))\\}$.\n  - Wyckoff positions:\n    - Letter $\\mathrm{a}$: multiplicity $m = 1$, coordinates $(0,0,0)$, site symmetry $\\bar{1}$, $p = 0$.\n    - Letter $\\mathrm{b}$: multiplicity $m = 1$, coordinates $(\\tfrac{1}{2}, \\tfrac{1}{2}, \\tfrac{1}{2})$, site symmetry $\\bar{1}$, $p = 0$.\n    - Letter $\\mathrm{i}$ (general): multiplicity $m = 2$, parameterization $(x,y,z)$ and $(-x,-y,-z)$ modulo $1$, $p = 3$.\n\nTasks your program must perform:\n- Enumerate all Wyckoff positions for a given $G \\in \\{1,2\\}$ by returning their letters, multiplicities $m$, site symmetries, and the number $p$ of independent positional parameters.\n- For a specific Wyckoff letter, generate a structure by:\n  - Sampling the $p$ free parameters uniformly in $[0,1)$ using a fixed seed when requested, or using explicitly supplied parameters when provided.\n  - Applying all symmetry operations of $G$ to the independent representative to generate all equivalent fractional coordinates in $[0,1)$ that constitute the orbit (deduplicate modulo $1$ within a numerical tolerance).\n- Quantify the reduction in positional degrees of freedom as $\\Delta = 3m - p$ for that Wyckoff position.\n- Verify group-closure consistency for the generated structure: every symmetry operation applied to every generated atomic position must map to a position that coincides (modulo $1$ within a tolerance) with one of the generated positions. Report a boolean indicating whether this check passes.\n\nAngle units and physical units are not applicable because all coordinates are fractional and dimensionless.\n\nTest suite and required outputs:\nUse the following five test cases, each described by a tuple $(G, \\text{letter}, \\text{seed}, \\text{params})$ where $\\text{seed}$ is used only when $\\text{params}$ is not provided. For each test case, your program must compute and collect the result as a list $[m, p, \\Delta, \\text{invariant}]$:\n- Case $1$: $(G = 1, \\text{letter} = \\mathrm{a}, \\text{seed} = 42, \\text{params} = \\text{None})$.\n- Case $2$: $(G = 2, \\text{letter} = \\mathrm{i}, \\text{seed} = 123, \\text{params} = \\text{None})$.\n- Case $3$: $(G = 2, \\text{letter} = \\mathrm{a}, \\text{seed} = \\text{None}, \\text{params} = \\text{None})$.\n- Case $4$: $(G = 2, \\text{letter} = \\mathrm{b}, \\text{seed} = \\text{None}, \\text{params} = \\text{None})$.\n- Case $5$: $(G = 2, \\text{letter} = \\mathrm{i}, \\text{seed} = \\text{None}, \\text{params} = (\\tfrac{1}{2}, 0.3, 0))$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a list $[m,p,\\Delta,\\text{invariant}]$, so the final output must look like\n  [$[m_1,p_1,\\Delta_1,\\text{invariant}_1]$, $[m_2,p_2,\\Delta_2,\\text{invariant}_2]$, $[m_3,p_3,\\Delta_3,\\text{invariant}_3]$, $[m_4,p_4,\\Delta_4,\\text{invariant}_4]$, $[m_5,p_5,\\Delta_5,\\text{invariant}_5]$]\nwith no extra text. Booleans must be reported in the programming language’s native boolean literals. All integers must be exact, and no floating-point values other than those required for internal checks should appear in the final output.",
            "solution": "The problem requires the implementation of a computational pipeline to handle crystallographic symmetry operations for a specific subset of space groups, namely $G=1$ ($P1$) and $G=2$ ($P\\bar{1}$). The tasks involve generating atomic coordinates for given Wyckoff positions, calculating the reduction in configurational degrees of freedom, and verifying the closure property of the space group operations on the generated structures. The solution is predicated on the principles of group theory as applied to crystallography.\n\nFirst, we must establish a formal representation for the space group data. A space group operation is an affine transformation $(\\boldsymbol{R}, \\boldsymbol{\\tau})$ acting on a fractional coordinate vector $\\mathbf{r} \\in [0,1)^3$. The transformation is given by $\\mathbf{r}' = \\boldsymbol{R}\\mathbf{r} + \\boldsymbol{\\tau}$, where results are taken modulo lattice translations (i.e., component-wise modulo $1$). The rotational part $\\boldsymbol{R}$ is a $3 \\times 3$ integer matrix, and the translational part $\\boldsymbol{\\tau}$ is a $3 \\times 1$ real vector.\n\nThe specific data provided in the problem statement will be encoded in a structured format accessible to the program.\nFor space group $G=1$ ($P1$), there is only one symmetry operation: the identity $(\\boldsymbol{I}, \\mathbf{0})$, where $\\boldsymbol{I}$ is the $3 \\times 3$ identity matrix and $\\mathbf{0}$ is the zero vector.\nFor space group $G=2$ ($P\\bar{1}$), there are two operations: the identity $(\\boldsymbol{I}, \\mathbf{0})$ and inversion through the origin $(-\\boldsymbol{I}, \\mathbf{0})$.\n\nThe Wyckoff positions for each group are also defined. A Wyckoff position is an orbit of points under the group's symmetry operations. It is characterized by its multiplicity $m$, site symmetry, and the number of independent parameters $p$ needed to define a representative point of the orbit.\n- For $G=1$, the single Wyckoff position $1a$ has $m=1$ and $p=3$, with a representative point parameterized as $(x, y, z)$.\n- For $G=2$, there are three specified Wyckoff positions:\n    - $2a$: A special position with multiplicity $m=1$ and $p=0$. The representative point is fixed at $(0,0,0)$.\n    - $2b$: Another special position with $m=1$ and $p=0$, with representative at $(\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2})$.\n    - $2i$: The general position with $m=2$ and $p=3$, with a representative parameterized as $(x, y, z)$.\n\nThe core of the algorithm proceeds on a case-by-case basis as specified by the test suite. For each test case defined by a tuple $(G, \\text{letter}, \\text{seed}, \\text{params})$, we perform the following steps:\n\n1.  **Retrieve Wyckoff and Symmetry Data**: Based on the given space group number $G$ and Wyckoff letter, we retrieve the corresponding multiplicity $m$, number of parameters $p$, and the set of symmetry operations $\\{(\\boldsymbol{R}_i, \\boldsymbol{\\tau}_i)\\}$.\n\n2.  **Generate Representative Point**: A single representative coordinate vector $\\mathbf{r}_{rep}$ is established.\n    - If the input `params` tuple is provided, its values are used.\n    - If `params` is not provided, we check the number of parameters $p$. If $p0$, we generate $p$ pseudo-random numbers in the interval $[0,1)$ using a random number generator seeded with the given `seed`. These numbers form the coordinates of $\\mathbf{r}_{rep}$.\n    - If $p=0$, the Wyckoff position is special, and $\\mathbf{r}_{rep}$ is set to its pre-defined fixed coordinates.\n\n3.  **Generate Crystal Structure (Orbit Generation)**: The full set of symmetrically equivalent points (the orbit) is generated by applying every symmetry operation $(\\boldsymbol{R}_i, \\boldsymbol{\\tau}_i)$ to the representative point $\\mathbf{r}_{rep}$. Each resulting vector $\\mathbf{r}'_i = \\boldsymbol{R}_i \\mathbf{r}_{rep} + \\boldsymbol{\\tau}_i$ is reduced modulo $1$ component-wise. A numerically robust way to perform this reduction on a vector $\\mathbf{v}$ is $\\mathbf{v} - \\lfloor \\mathbf{v} \\rfloor$.\n    A crucial step is to collect only the unique positions. Due to floating-point arithmetic, a simple equality check is insufficient. Two vectors $\\mathbf{v}_1$ and $\\mathbf{v}_2$ are considered equivalent if their difference, wrapped into the primary unit cell, is close to the zero vector. That is, if $\\|\\mathbf{v}_1 - \\mathbf{v}_2 - \\text{round}(\\mathbf{v}_1 - \\mathbf{v}_2)\\|  \\epsilon$ for a small tolerance $\\epsilon$. We will use a tolerance of $\\epsilon = 10^{-6}$. The collection of unique points forms the crystal structure.\n\n4.  **Calculate Reduction in Degrees of Freedom**: The reduction in positional degrees of freedom, $\\Delta$, is calculated using the formula $\\Delta = 3m - p$. Here, $m$ is the multiplicity of the Wyckoff position (for a generic representative), not necessarily the number of points in the generated orbit, which might be smaller if the chosen parameters for $\\mathbf{r}_{rep}$ accidentally fall on a higher-symmetry site. The values for $m$ and $p$ are taken directly from the problem's definition for the specified Wyckoff letter.\n\n5.  **Verify Group Closure Consistency**: This is a fundamental check to ensure the generated structure is a valid orbit. The property of group closure implies that applying any group operation to any point already in the orbit must result in another point that is also in the orbit.\n    We implement this check by iterating through every generated position $\\mathbf{p}$ in the structure and every symmetry operation $(\\boldsymbol{R}_j, \\boldsymbol{\\tau}_j)$ in the space group. For each pair, we compute the transformed point $\\mathbf{p}' = \\boldsymbol{R}_j \\mathbf{p} + \\boldsymbol{\\tau}_j$ (modulo $1$). We then verify if this $\\mathbf{p}'$ is equivalent (within the numerical tolerance $\\epsilon$) to at least one of the points in the originally generated set of positions. If this holds true for all pairs, the structure is invariant, and a boolean flag is set to `True`. If even one check fails, the flag is set to `False`.\n\nFinally, for each test case, the computed values $[m, p, \\Delta, \\text{invariant}]$ are collected. The final output is a list of these results, formatted precisely as requested.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the crystallography problem by processing a series of test cases\n    involving space groups, Wyckoff positions, and symmetry operations.\n    \"\"\"\n    \n    # Define a numerical tolerance for floating-point comparisons.\n    TOL = 1e-6\n\n    # Define the space group and Wyckoff position data.\n    SPACE_GROUP_DATA = {\n        1: { # P1\n            \"ops\": [\n                (np.identity(3, dtype=int), np.array([0.0, 0.0, 0.0]))\n            ],\n            \"wyckoff\": {\n                \"a\": {\"m\": 1, \"p\": 3, \"coords\": None, \"site_sym\": \"1\"}\n            }\n        },\n        2: { # P-1\n            \"ops\": [\n                (np.identity(3, dtype=int), np.array([0.0, 0.0, 0.0])),\n                (-np.identity(3, dtype=int), np.array([0.0, 0.0, 0.0]))\n            ],\n            \"wyckoff\": {\n                \"a\": {\"m\": 1, \"p\": 0, \"coords\": np.array([0.0, 0.0, 0.0]), \"site_sym\": \"-1\"},\n                \"b\": {\"m\": 1, \"p\": 0, \"coords\": np.array([0.5, 0.5, 0.5]), \"site_sym\": \"-1\"},\n                \"i\": {\"m\": 2, \"p\": 3, \"coords\": None, \"site_sym\": \"1\"}\n            }\n        }\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, \"a\", 42, None),\n        (2, \"i\", 123, None),\n        (2, \"a\", None, None),\n        (2, \"b\", None, None),\n        (2, \"i\", None, (0.5, 0.3, 0.0)),\n    ]\n\n    # Helper function to apply modulo 1 reduction to fractional coordinates.\n    def reduce_modulo_1(vec):\n        return vec - np.floor(vec)\n\n    # Helper function to check if two vectors are close, considering periodic boundaries.\n    def are_close(v1, v2):\n        diff = v1 - v2\n        periodic_diff = diff - np.round(diff)\n        return np.linalg.norm(periodic_diff)  TOL\n\n    # Helper function to format a list into the required string format without spaces.\n    def format_list(lst):\n        return f\"[{','.join(str(item) for item in lst)}]\"\n\n    results = []\n    for G, letter, seed, params in test_cases:\n        # 1. Retrieve data\n        group_info = SPACE_GROUP_DATA[G]\n        wyckoff_info = group_info[\"wyckoff\"][letter]\n        ops = group_info[\"ops\"]\n        m, p = wyckoff_info[\"m\"], wyckoff_info[\"p\"]\n\n        # 2. Generate representative point\n        r_rep = None\n        if params is not None:\n            r_rep = np.array(params)\n        elif p  0:\n            rng = np.random.default_rng(seed=seed)\n            r_rep = rng.random(p)\n        else: # p == 0\n            r_rep = wyckoff_info[\"coords\"]\n\n        # 3. Generate orbit\n        positions = []\n        for R, tau in ops:\n            new_pos = reduce_modulo_1(R @ r_rep + tau)\n            \n            # Add to list only if not already present (within tolerance)\n            is_new = True\n            for pos in positions:\n                if are_close(new_pos, pos):\n                    is_new = False\n                    break\n            if is_new:\n                positions.append(new_pos)\n\n        # 4. Calculate reduction in degrees of freedom\n        delta = 3 * m - p\n\n        # 5. Verify group closure consistency\n        is_invariant = True\n        if not positions: # Handle cases with no positions, though not expected here\n             is_invariant = True\n        else:\n            for R, tau in ops:\n                for p_initial in positions:\n                    p_final = reduce_modulo_1(R @ p_initial + tau)\n                    \n                    # Check if p_final is in the set of positions\n                    found_match = False\n                    for p_target in positions:\n                        if are_close(p_final, p_target):\n                            found_match = True\n                            break\n                    \n                    if not found_match:\n                        is_invariant = False\n                        break\n                if not is_invariant:\n                    break\n        \n        results.append([m, p, delta, is_invariant])\n\n    # Final print statement in the exact required format.\n    final_output_str = f\"[{','.join(format_list(r) for r in results)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "This practice bridges the gap between ideal symmetry theory and the realities of computational research, where atomic positions from simulations or experiments are never perfectly symmetric. The challenge is to assign a space group not to a perfect mathematical object, but to a set of coordinates subject to numerical noise or physical displacements. By implementing a tolerance-sweeping procedure, you will model this real-world analysis, explore how the assigned symmetry group can change with the chosen positional tolerance $\\varepsilon$, and gain practical insight into the critical concepts of pseudosymmetry and the stability of symmetry assignments .",
            "id": "3491404",
            "problem": "Implement a program that, given a finite set of candidate symmetry operations acting on fractional atomic coordinates of a periodic crystal, sweeps a list of positional tolerances to assign the most symmetric space group from a fixed catalog at each tolerance, quantifies the stability of the assignment across tolerances, and detects pseudosymmetry by identifying the first tolerance at which the assigned group strictly increases in complexity. The problem must be solved under the following strictly mathematical specification grounded in the core definitions of crystallographic symmetry.\n\nA crystal is represented by: \n- a lattice matrix $\\mathbf{L}\\in\\mathbb{R}^{3\\times 3}$ whose columns are the real-space basis vectors $\\mathbf{a},\\mathbf{b},\\mathbf{c}$ in Angstroms (denote Angstrom by $\\text{\\AA}$), and \n- a set of $N$ fractional coordinates $\\{\\mathbf{f}_i\\in [0,1)^3\\}_{i=1}^N$ along with species labels (for this problem, a single species is used for all atoms). Fractional-to-Cartesian mapping is $\\mathbf{r}=\\mathbf{L}\\,\\mathbf{f}$, where $\\mathbf{f}$ is a column vector.\n\nA symmetry operation in this problem is restricted to be symmorphic with zero translation, and is represented by an integer orthogonal rotation (or roto-reflection) matrix $\\mathbf{R}\\in\\mathrm{O}(3,\\mathbb{Z})$. An operation $\\mathbf{R}$ is said to be satisfied by a structure at positional tolerance $\\varepsilon$ (in $\\text{\\AA}$) if there exists a one-to-one correspondence between the transformed fractional positions $\\{\\mathbf{f}'_i=\\mathbf{R}\\mathbf{f}_i\\ \\mathrm{mod}\\ 1\\}$ and the original set $\\{\\mathbf{f}_j\\}$ such that every pair of matched atoms is within distance $\\varepsilon$ in the minimum-image metric: for each match, the Cartesian distance\n$$\nd_{ij} \\equiv \\min_{\\mathbf{n}\\in\\mathbb{Z}^3} \\left\\| \\mathbf{L}\\left(\\mathbf{f}'_i-\\mathbf{f}_j+\\mathbf{n}\\right) \\right\\|_2 \\le \\varepsilon,\n$$\nwith the Euclidean norm $\\|\\cdot\\|_2$. The minimum-image search must be performed exactly by checking all integer shifts $\\mathbf{n}$ with components in $\\{-1,0,1\\}$ and selecting the minimal norm.\n\nYou are given a fixed catalog of candidate operations, each specified by its matrix $\\mathbf{R}$ about the origin (all angles specified below are in degrees):\n- Identity $E$: $\\mathbf{R}=\\mathrm{diag}(1,1,1)$.\n- Inversion $I$: $\\mathbf{R}=\\mathrm{diag}(-1,-1,-1)$.\n- Two-fold rotation about $z$, $C_{2z}$: $\\mathbf{R}=\\mathrm{diag}(-1,-1,1)$.\n- Four-fold rotation about $z$, $C_{4z}$: \n$$\n\\mathbf{R}=\\begin{bmatrix}\n0  -1  0\\\\\n1  0  0\\\\\n0  0  1\n\\end{bmatrix}.\n$$\n- Mirror across $x=0$ plane, $m_x$: $\\mathbf{R}=\\mathrm{diag}(-1,1,1)$.\n- Mirror across $y=0$ plane, $m_y$: $\\mathbf{R}=\\mathrm{diag}(1,-1,1)$.\n- Mirror across $z=0$ plane, $m_z$: $\\mathbf{R}=\\mathrm{diag}(1,1,-1)$.\n\nDefine the following catalog of space-group proxies (each identified by an integer code and the minimal set of required satisfied operations). The assigned group at a given tolerance is the one with the largest number of required operations whose required operations are all satisfied; ties must be broken by the larger code:\n- Code $1$: $P1$ with requirements $\\{E\\}$.\n- Code $2$: $P\\bar{1}$ with requirements $\\{E,I\\}$.\n- Code $3$: $P2(z)$ with requirements $\\{E,C_{2z}\\}$.\n- Code $4$: $Pm(x)$ with requirements $\\{E,m_x\\}$.\n- Code $5$: $P4$ with requirements $\\{E,C_{4z},C_{2z}\\}$.\n- Code $6$: $P4/m$ with requirements $\\{E,C_{4z},C_{2z},m_z\\}$.\n- Code $7$: $Pmm$ with requirements $\\{E,m_x,m_y\\}$.\n- Code $8$: $P4mm$ with requirements $\\{E,C_{4z},C_{2z},m_x,m_y\\}$.\n\nGiven a list of tolerances $\\{\\varepsilon_k\\}_{k=1}^K$ (in $\\text{\\AA}$), define the assignment sequence $\\{G_k\\}_{k=1}^K$ where $G_k$ is the group code assigned at $\\varepsilon_k$. Let $c(G)$ denote the number of required operations for group $G$ (for example, $c(8)=5$). A pseudosymmetry jump is said to occur at index $k^\\star$ if $c(G_{k^\\star})c(G_{k^\\star-1})$ for the smallest such $k^\\star\\in\\{2,\\dots,K\\}$. Let $\\varepsilon^\\star=\\varepsilon_{k^\\star}$, $G=G_{k^\\star-1}$, and $H=G_{k^\\star}$. If no such index exists, there is no jump.\n\nDefine the stability score $s$ as the fraction of the tolerance list at which the majority group (the most frequent code across $\\{G_k\\}$; break ties by picking the group with larger $c(G)$, and then by larger code) appears.\n\nImplement the above using only the specified operations and groups, following these core definitions. All angles must be treated in degrees, all positional tolerances in $\\text{\\AA}$, and all lattice lengths in $\\text{\\AA}$.\n\nInput data are embedded in the program via the following test suite (no user input). Lattice matrices $\\mathbf{L}$ are to be constructed from lengths and angles using the standard triclinic convention with columns as lattice vectors:\n- Structure $S_1$ (nearly four-fold with slight anisotropy; pseudosymmetric):\n    - Lattice parameters: $a=b=3.5\\,\\text{\\AA}$, $c=10.0\\,\\text{\\AA}$, $\\alpha=\\beta=\\gamma=90^\\circ$.\n    - Fractional positions: four atoms at $(0.5+u,0.5,0)$, $(0.5-u,0.5,0)$, $(0.5,0.5+v,0)$, $(0.5,0.5-v,0)$ with $u=0.2$, $v=0.196$.\n- Structure $S_2$ (generic skew, no symmetry beyond identity):\n    - Lattice parameters: $a=3.2\\,\\text{\\AA}$, $b=4.7\\,\\text{\\AA}$, $c=12.0\\,\\text{\\AA}$, $\\alpha=90^\\circ$, $\\beta=90^\\circ$, $\\gamma=80^\\circ$.\n    - Fractional positions: three atoms at $(0.1,0.2,0.0)$, $(0.33,0.73,0.0)$, $(0.81,0.27,0.0)$.\n- Structure $S_3$ (perfect four-fold symmetric):\n    - Lattice parameters: same as $S_1$.\n    - Fractional positions: four atoms at $(0.5+u,0.5,0)$, $(0.5-u,0.5,0)$, $(0.5,0.5+v,0)$, $(0.5,0.5-v,0)$ with $u=0.2$, $v=0.2$.\n\nTolerance sweep (in $\\text{\\AA}$) is fixed at $\\{\\varepsilon_k\\}=\\{0.0005,\\,0.005,\\,0.02,\\,0.05\\}$.\n\nYour program must:\n- For each structure and for each tolerance $\\varepsilon_k$, determine the set of satisfied operations, assign the group code $G_k$ from the catalog according to the rule above, and produce the sequence $\\{G_k\\}$.\n- Compute the pseudosymmetry flag $p$, equal to $1$ if a jump occurs and $0$ otherwise.\n- Compute the first jump tolerance $\\varepsilon^\\star$ (in $\\text{\\AA}$), rounded to four decimals; if no jump, output $-1.0$.\n- Compute the jump pair $(G,H)$ as integers; if no jump, output $(-1,-1)$.\n- Compute the stability score $s$ (a decimal in $[0,1]$), rounded to three decimals.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for $S_1$, $S_2$, and $S_3$ as a comma-separated list enclosed in square brackets, where each test case result is the list $[p,\\varepsilon^\\star,G,H,s]$. For example, a syntactic template is $[[p_1,\\varepsilon^\\star_1,G_1,H_1,s_1],[p_2,\\varepsilon^\\star_2,G_2,H_2,s_2],[p_3,\\varepsilon^\\star_3,G_3,H_3,s_3]]$. Angles must be in degrees, and distances and tolerances must be in $\\text{\\AA}$.",
            "solution": "The problem requires the implementation of a computational procedure to analyze the symmetry of three-dimensional periodic crystal structures. This involves determining which symmetry operations from a given catalog are satisfied by a structure within a specified positional tolerance $\\varepsilon$, assigning a space group proxy based on these satisfied operations, and analyzing how this assignment changes as the tolerance is varied. The final output includes a characterization of pseudosymmetry and a measure of assignment stability.\n\nThe methodology adheres to the precise mathematical definitions provided in the problem statement.\n\nFirst, we establish the geometric representation of the crystal. A crystal lattice is defined by three basis vectors $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$. From the given lattice parameters—lengths $a$, $b$, $c$ and angles $\\alpha$, $\\beta$, $\\gamma$—we construct the lattice matrix $\\mathbf{L} = \\begin{bmatrix} \\mathbf{a}  \\mathbf{b}  \\mathbf{c} \\end{bmatrix}$. This matrix transforms fractional coordinates $\\mathbf{f} \\in [0,1)^3$ into Cartesian coordinates $\\mathbf{r} \\in \\mathbb{R}^3$ via the linear transformation $\\mathbf{r} = \\mathbf{L}\\mathbf{f}$. The standard triclinic convention is used for this construction, converting angles from degrees to radians for trigonometric calculations.\n\nThe core of the analysis is to determine whether a given symmetry operation, represented by an integer orthogonal matrix $\\mathbf{R}$, is respected by the crystal structure within a positional tolerance $\\varepsilon$. An operation is considered satisfied if a one-to-one correspondence (a permutation) can be established between the original set of atomic fractional coordinates $\\{\\mathbf{f}_j\\}$ and the set of transformed coordinates $\\{\\mathbf{f}'_i = \\mathbf{R}\\mathbf{f}_i \\pmod 1\\}$. The modulo $1$ operation ensures that the transformed coordinates are mapped back into the primary unit cell. For a correspondence to be valid, the Cartesian distance between each pair of matched atoms $(\\mathbf{f}'_i, \\mathbf{f}_j)$ must be no greater than $\\varepsilon$. This distance is calculated using the minimum image convention to account for the periodic nature of the crystal. The distance is defined as $d_{ij} = \\min_{\\mathbf{n}\\in\\{-1,0,1\\}^3} \\| \\mathbf{L}(\\mathbf{f}'_i - \\mathbf{f}_j + \\mathbf{n}) \\|_2$. The search for the minimum is performed exactly by checking all $27$ integer shift vectors $\\mathbf{n}$ with components in $\\{-1, 0, 1\\}$.\n\nTo find the one-to-one mapping between the original and transformed a-tomic sites, we formulate it as a linear assignment problem (or minimum weight bipartite matching problem). A cost matrix $\\mathbf{D}$ of size $N \\times N$ is constructed, where $D_{ij}$ is the minimum image distance between the $i$-th transformed atom $\\mathbf{f}'_i$ and the $j$-th original atom $\\mathbf{f}_j$. The Hungarian algorithm, available via `scipy.optimize.linear_sum_assignment`, is employed to find the permutation of atoms that minimizes the total distance. Once this optimal pairing is found, the operation $\\mathbf{R}$ is deemed satisfied if and only if every distance in this optimal assignment is less than or equal to the tolerance $\\varepsilon$.\n\nWith this procedure, for each tolerance $\\varepsilon_k$ in the provided list, we can determine the complete set of satisfied operations from the catalog. The next step is to assign a space group proxy. The problem provides a catalog of eight group proxies, each defined by a code, a name, and a minimal set of required symmetry operations. At a given tolerance, we find all group proxies from the catalog for which all required operations are present in our set of satisfied operations. Among these valid candidates, we select the one with the largest number of required operations, denoted $c(G)$. Any ties are resolved by choosing the group with the larger integer code.\n\nThis process is repeated for each tolerance $\\varepsilon_k$ in the sweep, generating a sequence of group assignments $\\{G_k\\}$. This sequence is then analyzed to extract two key metrics: a pseudosymmetry indicator and a stability score.\n\nA pseudosymmetry jump is detected if the complexity of the assigned group, measured by $c(G)$, strictly increases at some point in the tolerance sweep. We identify the first index $k^\\star \\in \\{2, \\dots, K\\}$ where $c(G_{k^\\star})  c(G_{k^\\star-1})$. If such a jump exists, we report a flag $p=1$, the tolerance $\\varepsilon^\\star = \\varepsilon_{k^\\star}$ at which it occurs, and the pair of group codes $(G, H) = (G_{k^\\star-1}, G_{k^\\star})$ involved in the transition. If no such jump is found, we report $p=0$ and placeholder values.\n\nThe stability score $s$ quantifies the robustness of the symmetry assignment. It is calculated as the fraction of tolerances at which the \"majority group\" is assigned. The majority group is the one that appears most frequently in the sequence $\\{G_k\\}$. If there is a tie in frequency, the tie is broken by selecting the group with the higher complexity $c(G)$. If a tie persists, it is broken by selecting the group with the higher code.\n\nThe final implementation encapsulates this entire logic, processing each of the three given crystal structures ($S_1, S_2, S_3$) through the tolerance sweep and computing the five required output values: the pseudosymmetry flag $p$, the jump tolerance $\\varepsilon^\\star$, the jump pair $(G,H)$, and the stability score $s$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Main function to perform symmetry analysis on a suite of test structures.\n    \"\"\"\n\n    def get_lattice_matrix(a, b, c, alpha, beta, gamma):\n        \"\"\"\n        Constructs the lattice matrix L from lattice parameters a, b, c, alpha, beta, gamma.\n        The columns of L are the lattice vectors a, b, c in Cartesian space.\n        \"\"\"\n        alpha_rad = np.deg2rad(alpha)\n        beta_rad = np.deg2rad(beta)\n        gamma_rad = np.deg2rad(gamma)\n\n        cos_a, cos_b, cos_g = np.cos(alpha_rad), np.cos(beta_rad), np.cos(gamma_rad)\n        sin_g = np.sin(gamma_rad)\n\n        # Volume term, handle case of sin_g=0 if gamma is 0 or 180\n        vol_sq_term = 1.0 - cos_a**2 - cos_b**2 - cos_g**2 + 2.0 * cos_a * cos_b * cos_g\n        if vol_sq_term  0: vol_sq_term = 0 # handle minor floating point issues\n        \n        # Standard triclinic cell construction\n        # a is along x\n        # b is in xy plane\n        # c is general\n        ax, ay, az = a, 0.0, 0.0\n        bx, by, bz = b * cos_g, b * sin_g, 0.0\n        cx = c * cos_b\n        cy = c * (cos_a - cos_b * cos_g) / sin_g if sin_g != 0 else 0.0\n        cz = c * np.sqrt(vol_sq_term) / sin_g if sin_g != 0 else 0.0\n\n        return np.array([[ax, bx, cx], [ay, by, cy], [az, bz, cz]])\n\n    def is_op_satisfied(L, f_coords, R, epsilon):\n        \"\"\"\n        Checks if a symmetry operation R is satisfied for a given structure and tolerance.\n        \"\"\"\n        num_atoms = f_coords.shape[0]\n        # Transform coordinates: f' = R * f (mod 1)\n        f_prime = (R @ f_coords.T).T\n        f_prime = f_prime - np.floor(f_prime)\n\n        # Build distance matrix D_ij = d(f'_i, f_j) using minimum image convention\n        dist_matrix = np.zeros((num_atoms, num_atoms))\n        \n        # Pre-generate the 27 shift vectors n\n        shifts = np.array([\n            (i, j, k) for i in [-1, 0, 1] for j in [-1, 0, 1] for k in [-1, 0, 1]\n        ])\n\n        for i in range(num_atoms):\n            for j in range(num_atoms):\n                delta_f = f_prime[i] - f_coords[j]\n                \n                # Minimum image distance calculation\n                # Add all 27 shifts to delta_f and find coord with minimum norm\n                all_shifted_f = delta_f + shifts\n                cart_coords = all_shifted_f @ L.T\n                dists_sq = np.sum(cart_coords**2, axis=1)\n                min_dist_sq = np.min(dists_sq)\n                dist_matrix[i, j] = np.sqrt(min_dist_sq)\n\n        # Use Hungarian algorithm to find the optimal one-to-one mapping\n        row_ind, col_ind = linear_sum_assignment(dist_matrix)\n        \n        # Check if all pairs in the optimal assignment are within tolerance\n        max_dist_in_mapping = np.max(dist_matrix[row_ind, col_ind])\n        \n        return max_dist_in_mapping = epsilon\n\n    # Static data as defined in the problem\n    test_suite = [\n        {\n            \"name\": \"S1\",\n            \"lattice_params\": {\"a\": 3.5, \"b\": 3.5, \"c\": 10.0, \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 90.0},\n            \"frac_coords\": np.array([\n                [0.5 + 0.2, 0.5, 0.0], [0.5 - 0.2, 0.5, 0.0],\n                [0.5, 0.5 + 0.196, 0.0], [0.5, 0.5 - 0.196, 0.0]\n            ])\n        },\n        {\n            \"name\": \"S2\",\n            \"lattice_params\": {\"a\": 3.2, \"b\": 4.7, \"c\": 12.0, \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 80.0},\n            \"frac_coords\": np.array([[0.1, 0.2, 0.0], [0.33, 0.73, 0.0], [0.81, 0.27, 0.0]])\n        },\n        {\n            \"name\": \"S3\",\n            \"lattice_params\": {\"a\": 3.5, \"b\": 3.5, \"c\": 10.0, \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 90.0},\n            \"frac_coords\": np.array([\n                [0.5 + 0.2, 0.5, 0.0], [0.5 - 0.2, 0.5, 0.0],\n                [0.5, 0.5 + 0.2, 0.0], [0.5, 0.5 - 0.2, 0.0]\n            ])\n        }\n    ]\n    tolerances = [0.0005, 0.005, 0.02, 0.05]\n    ops_catalog = {\n        'E': np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]], dtype=int),\n        'I': np.array([[-1, 0, 0], [0, -1, 0], [0, 0, -1]], dtype=int),\n        'C2z': np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 1]], dtype=int),\n        'C4z': np.array([[0, -1, 0], [1, 0, 0], [0, 0, 1]], dtype=int),\n        'mx': np.array([[-1, 0, 0], [0, 1, 0], [0, 0, 1]], dtype=int),\n        'my': np.array([[1, 0, 0], [0, -1, 0], [0, 0, 1]], dtype=int),\n        'mz': np.array([[1, 0, 0], [0, 1, 0], [0, 0, -1]], dtype=int)\n    }\n    space_groups_catalog = {\n        1: {'reqs': {'E'}}, 2: {'reqs': {'E', 'I'}},\n        3: {'reqs': {'E', 'C2z'}}, 4: {'reqs': {'E', 'mx'}},\n        5: {'reqs': {'E', 'C4z', 'C2z'}}, 6: {'reqs': {'E', 'C4z', 'C2z', 'mz'}},\n        7: {'reqs': {'E', 'mx', 'my'}}, 8: {'reqs': {'E', 'C4z', 'C2z', 'mx', 'my'}}\n    }\n    for code in space_groups_catalog:\n        space_groups_catalog[code]['c'] = len(space_groups_catalog[code]['reqs'])\n\n    final_results = []\n    \n    for structure in test_suite:\n        lattice_matrix = get_lattice_matrix(**structure[\"lattice_params\"])\n        frac_coords = structure[\"frac_coords\"]\n        \n        G_sequence = []\n        for eps in tolerances:\n            satisfied_ops = {op_name for op_name, R in ops_catalog.items()\n                             if is_op_satisfied(lattice_matrix, frac_coords, R, eps)}\n\n            best_group_code = -1\n            max_ops = -1\n            for code, group_data in sorted(space_groups_catalog.items()):\n                if group_data['reqs'].issubset(satisfied_ops):\n                    if group_data['c'] > max_ops:\n                        max_ops = group_data['c']\n                        best_group_code = code\n                    elif group_data['c'] == max_ops:\n                        best_group_code = max(best_group_code, code)\n            G_sequence.append(best_group_code)\n\n        # Analyze G_sequence\n        p, eps_star, G, H = 0, -1.0, -1, -1\n        for k in range(1, len(G_sequence)):\n            c_prev = space_groups_catalog[G_sequence[k-1]]['c']\n            c_curr = space_groups_catalog[G_sequence[k]]['c']\n            if c_curr > c_prev:\n                p = 1\n                eps_star = tolerances[k]\n                G, H = G_sequence[k-1], G_sequence[k]\n                break\n        \n        # Stability score calculation\n        if not G_sequence:\n            s = 0.0\n        else:\n            counts = Counter(G_sequence)\n            max_freq = max(counts.values())\n            candidates = [code for code, freq in counts.items() if freq == max_freq]\n            \n            if len(candidates) == 1:\n                majority_group_code = candidates[0]\n            else:\n                # Tie-breaking: higher complexity c(G), then higher code\n                candidates.sort(key=lambda code: (space_groups_catalog[code]['c'], code), reverse=True)\n                majority_group_code = candidates[0]\n\n            s = counts[majority_group_code] / len(G_sequence)\n\n        # Format results as specified\n        result = [p, round(eps_star, 4), G, H, round(s, 3)]\n        final_results.append(result)\n\n    # Print final result in specified format\n    print(str(final_results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        }
    ]
}