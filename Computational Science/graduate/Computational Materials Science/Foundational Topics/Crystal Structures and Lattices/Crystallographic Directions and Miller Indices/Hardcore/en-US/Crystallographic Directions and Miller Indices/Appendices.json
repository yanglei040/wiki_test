{
    "hands_on_practices": [
        {
            "introduction": "Crystallographic indices are more than abstract labels; they are a direct link to the physical and chemical properties of a material's surface. This first practice brings this connection to life by guiding you through the computational modeling of a vicinal surface—a surface slightly misaligned from a low-index plane, resulting in a regular array of atomic steps and terraces. You will translate the Miller indices of a vicinal plane into tangible nanoscale features like terrace width and kink density, a crucial skill in modeling crystal growth, surface catalysis, and thin-film epitaxy. ",
            "id": "3442343",
            "problem": "Consider a simple cubic Bravais lattice with lattice parameter $a$ measured in angstroms. A crystallographic plane is denoted by its Miller indices $(h,k,l)$ and its outward unit normal is parallel to the direction $(h,k,l)$ in a cubic crystal. The $(111)$ plane has unit normal parallel to $(1,1,1)$. A vicinal surface near $(111)$ can be parameterized by $(h,h,l)$ with $h,l \\in \\mathbb{Z}^{+}$, and its miscut angle $\\alpha$ is the acute angle between the normals of $(h,h,l)$ and $(111)$. The interplanar spacing for a cubic system satisfies the well-tested relation $1/d_{hkl}^{2} = (h^{2}+k^{2}+l^{2})/a^{2}$.\n\nYour task is to write a complete, runnable program that, for each specified $(h,h,l)$ vicinal surface:\n- Derives the miscut angle $\\alpha$ in radians from the geometric definition of the angle between unit normals.\n- Computes the interplanar spacing $d_{111}$ using the cubic interplanar spacing relation.\n- Computes the terrace width $w$ implied by the right-triangle geometry in which the step height equals $d_{111}$ and the slope is determined by the miscut angle $\\alpha$.\n- Constructs the two-dimensional surface lattice of the $(111)$ plane from the simple cubic three-dimensional lattice by selecting two shortest in-plane lattice translations and projects them onto two orthogonal in-plane directions: the step-edge direction $\\hat{\\mathbf{u}}_{\\parallel}$ along $[1\\;\\overline{1}\\;0]$ and the miscut direction $\\hat{\\mathbf{u}}_{\\perp}$ along $[1\\;1\\;\\overline{2}]$. Using these, defines the in-plane row spacing $s_{\\perp}$ as the minimal positive projection of any nonzero integer linear combination of the in-plane basis vectors onto $\\hat{\\mathbf{u}}_{\\perp}$, and similarly defines $s_{\\parallel}$ as the minimal positive projection onto $\\hat{\\mathbf{u}}_{\\parallel}$. All projections must be computed in angstroms.\n- Forms the ratio $r = w/s_{\\perp}$ and computes a best rational approximant $p/q$ to $r$ via the convergents of the simple continued fraction of $r$, constrained by a maximum denominator $q \\leq Q_{\\max}$ for a given integer bound $Q_{\\max}$. If $\\alpha = 0$ then define $w$ to be $+\\infty$ and set $p=q=0$.\n- Predicts the step density as $\\delta_{\\text{step}} = 1/w$ (in $\\text{\\AA}^{-1}$, with the convention $\\delta_{\\text{step}}=0$ if $w=+\\infty$).\n- Predicts a kink linear density along the step edge using the rational approximant as $\\delta_{\\text{kink}} = p/(q\\,s_{\\parallel})$ (in $\\text{\\AA}^{-1}$, and define $\\delta_{\\text{kink}}=0$ if $q=0$).\n\nFundamental base and definitions you must use:\n- The unit normal to $(h,k,l)$ in a cubic crystal is proportional to $(h,k,l)$.\n- The angle between two unit vectors $\\hat{\\mathbf{n}}_{1}$ and $\\hat{\\mathbf{n}}_{2}$ is determined by their dot product through $\\cos \\alpha = \\hat{\\mathbf{n}}_{1}\\cdot \\hat{\\mathbf{n}}_{2}$.\n- The interplanar spacing relation for cubic crystals is $1/d_{hkl}^{2} = (h^{2}+k^{2}+l^{2})/a^{2}$.\n- The $(111)$ two-dimensional lattice can be generated by the shortest nonzero lattice translations lying in the $(111)$ plane that satisfy $x+y+z=0$ in the simple cubic lattice; a convenient pair is $\\mathbf{t}_{1} = a(1,-1,0)$ and $\\mathbf{t}_{2} = a(1,0,-1)$, which span the hexagonal surface net.\n- Orthogonal in-plane directions: $\\hat{\\mathbf{u}}_{\\parallel} \\parallel (1,-1,0)$ and $\\hat{\\mathbf{u}}_{\\perp} \\parallel (1,1,-2)$, with exact normalization required so that they are unit vectors within the $(111)$ plane.\n\nAngle unit and physical units:\n- Express all angles in radians.\n- Express all lengths in angstroms.\n- Express all densities (step and kink densities) in inverse angstroms.\n\nNumerical output specification:\n- For each test case, output a list of seven entries $[\\alpha, d_{111}, w, \\delta_{\\text{step}}, p, q, \\delta_{\\text{kink}}]$, where $\\alpha$, $d_{111}$, $w$, $\\delta_{\\text{step}}$, and $\\delta_{\\text{kink}}$ are floats, and $p$, $q$ are integers. If $w=+\\infty$, print it as a floating-point infinity and set $\\delta_{\\text{step}}=0$ and $\\delta_{\\text{kink}}=0$.\n- Round all finite floating-point quantities to six decimal places.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list of these seven-entry lists, enclosed in square brackets, for example: $[[\\dots],[\\dots],\\dots]$.\n\nTest suite:\n- Case A (general vicinal): $a = 3.600$ angstroms, $(h,h,l)=(1,1,3)$, $Q_{\\max} = 20$.\n- Case B (moderate vicinal): $a = 4.050$ angstroms, $(h,h,l)=(2,2,3)$, $Q_{\\max} = 50$.\n- Case C (boundary $(111)$): $a = 5.430$ angstroms, $(h,h,l)=(1,1,1)$, $Q_{\\max} = 20$.\n- Case D (small miscut): $a = 3.520$ angstroms, $(h,h,l)=(10,10,11)$, $Q_{\\max} = 200$.\n\nFinal output format:\n- Your program must print exactly one line: a single array containing four lists (one per test case), each list being $[\\alpha, d_{111}, w, \\delta_{\\text{step}}, p, q, \\delta_{\\text{kink}}]$, with floats rounded to six decimals and integers unrounded, for example: $[[\\alpha_{A},d_{111,A},w_{A},\\delta_{\\text{step},A},p_{A},q_{A},\\delta_{\\text{kink},A}],[\\alpha_{B},\\dots],\\dots]$.",
            "solution": "The user-provided problem is a well-posed computational task in the domain of computational materials science, specifically concerning the crystallography of vicinal surfaces. The problem is scientifically grounded, internally consistent, and contains all necessary information for a unique solution. Therefore, the problem is deemed **valid**.\n\nThe solution proceeds by implementing the sequence of calculations specified in the problem statement for each given test case. A test case is defined by the simple cubic lattice parameter $a$, the indices $(h,h,l)$ of the vicinal plane, and a maximum denominator $Q_{\\max}$ for rational approximation.\n\nThe required quantities are derived as follows:\n\n1.  **Miscut Angle ($\\alpha$)**: The miscut angle $\\alpha$ is the acute angle between the normal vector of the vicinal plane $(h,h,l)$ and the normal of the reference plane $(111)$. For a cubic crystal, the normal to a plane $(h,k,l)$ is the direction $[h,k,l]$. Let $\\mathbf{n}_v = (h,h,l)$ and $\\mathbf{n}_r = (1,1,1)$ be the normal vectors. The angle between them is found using the dot product formula:\n    $$ \\cos \\alpha = \\frac{\\mathbf{n}_v \\cdot \\mathbf{n}_r}{\\|\\mathbf{n}_v\\| \\|\\mathbf{n}_r\\|} = \\frac{(h)(1) + (h)(1) + (l)(1)}{\\sqrt{h^2+h^2+l^2} \\sqrt{1^2+1^2+1^2}} = \\frac{2h+l}{\\sqrt{2h^2+l^2}\\sqrt{3}} $$\n    The angle is then $\\alpha = \\arccos\\left(\\frac{2h+l}{\\sqrt{3(2h^2+l^2)}}\\right)$. For the special case where the plane is $(111)$ itself (i.e., $h=l$), the numerator becomes $3h$ and the denominator becomes $\\sqrt{3(3h^2)} = 3h$, so $\\cos \\alpha = 1$ and $\\alpha=0$.\n\n2.  **Interplanar Spacing ($d_{111}$)**: The interplanar spacing $d_{hkl}$ for a cubic crystal with lattice parameter $a$ is given by $1/d_{hkl}^2 = (h^2+k^2+l^2)/a^2$. For the $(111)$ plane, this yields:\n    $$ \\frac{1}{d_{111}^2} = \\frac{1^2+1^2+1^2}{a^2} = \\frac{3}{a^2} \\implies d_{111} = \\frac{a}{\\sqrt{3}} $$\n    This value represents the height of a single atomic step on the vicinal surface.\n\n3.  **Terrace Width ($w$) and Step Density ($\\delta_{\\text{step}}$)**: A vicinal surface can be pictured as a staircase where the terraces are atomically flat $(111)$ planes and the risers are atomic steps of height $d_{111}$. The miscut angle $\\alpha$ relates the step height and the terrace width $w$ through simple trigonometry:\n    $$ \\tan \\alpha = \\frac{\\text{step height}}{\\text{terrace width}} = \\frac{d_{111}}{w} $$\n    Thus, the terrace width is $w = d_{111} / \\tan \\alpha$. If $\\alpha = 0$, the surface is perfectly flat, so $w = \\infty$. The step density is the reciprocal of the terrace width, $\\delta_{\\text{step}} = 1/w$. If $w=\\infty$, $\\delta_{\\text{step}}=0$.\n\n4.  **In-plane Row Spacings ($s_{\\parallel}, s_{\\perp}$)**: The problem defines two orthogonal in-plane directions on the $(111)$ surface: $\\hat{\\mathbf{u}}_{\\parallel}$ parallel to $[1\\;\\overline{1}\\;0]$ and $\\hat{\\mathbf{u}}_{\\perp}$ parallel to $[1\\;1\\;\\overline{2}]$. Their normalized forms are:\n    $$ \\hat{\\mathbf{u}}_{\\parallel} = \\frac{1}{\\sqrt{2}}(1, -1, 0) \\quad \\text{and} \\quad \\hat{\\mathbf{u}}_{\\perp} = \\frac{1}{\\sqrt{6}}(1, 1, -2) $$\n    The two-dimensional surface lattice is generated by integer linear combinations ($m, n \\in \\mathbb{Z}$) of the basis vectors $\\mathbf{t}_1 = a(1,-1,0)$ and $\\mathbf{t}_2 = a(1,0,-1)$. A general surface lattice vector is $\\mathbf{T} = m\\mathbf{t}_1 + n\\mathbf{t}_2 = a(m+n, -m, -n)$.\n    The projection of $\\mathbf{T}$ onto $\\hat{\\mathbf{u}}_{\\parallel}$ is $P_{\\parallel} = \\mathbf{T} \\cdot \\hat{\\mathbf{u}}_{\\parallel} = \\frac{a}{\\sqrt{2}}(2m+n)$. Since $m$ and $n$ are integers, $2m+n$ can be any integer. The minimal positive projection is for $2m+n=1$, thus $s_{\\parallel} = a/\\sqrt{2}$.\n    The projection of $\\mathbf{T}$ onto $\\hat{\\mathbf{u}}_{\\perp}$ is $P_{\\perp} = \\mathbf{T} \\cdot \\hat{\\mathbf{u}}_{\\perp} = \\frac{a}{\\sqrt{6}}(3n) = \\frac{a\\sqrt{3}}{\\sqrt{2}}n$. The minimal positive projection is for $n=1$, thus $s_{\\perp} = a\\sqrt{3}/\\sqrt{2}$.\n\n5.  **Rational Approximant ($p/q$)**: The ratio $r = w/s_{\\perp}$ is calculated. Substituting the expressions for $w$ and $s_{\\perp}$:\n    $$ r = \\frac{w}{s_{\\perp}} = \\frac{d_{111}/\\tan\\alpha}{a\\sqrt{3}/\\sqrt{2}} = \\frac{(a/\\sqrt{3})/\\tan\\alpha}{a\\sqrt{3}/\\sqrt{2}} = \\frac{a}{\\sqrt{3}\\tan\\alpha} \\cdot \\frac{\\sqrt{2}}{a\\sqrt{3}} = \\frac{\\sqrt{2}}{3\\tan\\alpha} $$\n    A best rational approximant $p/q$ for $r$ is found using the continued fraction algorithm, subject to the constraint that the denominator $q$ does not exceed $Q_{\\max}$. This is efficiently handled by standard library functions. For the $\\alpha=0$ case, the problem explicitly defines $p=0$ and $q=0$.\n\n6.  **Kink Density ($\\delta_{\\text{kink}}$)**: The linear density of kinks along a step edge is given by $\\delta_{\\text{kink}} = p/(q s_{\\parallel})$. If $q=0$, then $\\delta_{\\text{kink}}=0$.\n\nThese steps are implemented in a Python program, which iterates through the provided test cases, performs the calculations, and formats the output as specified.",
            "answer": "```python\nimport numpy as np\nfrom fractions import Fraction\n\ndef calculate_properties(a, h_idx, l_idx, Q_max):\n    \"\"\"\n    Calculates crystallographic properties for a vicinal surface.\n    \n    Args:\n        a (float): Lattice parameter in angstroms.\n        h_idx (int): The 'h' index for the (h,h,l) plane.\n        l_idx (int): The 'l' index for the (h,h,l) plane.\n        Q_max (int): Maximum denominator for rational approximation.\n        \n    Returns:\n        list: A list of 7 calculated properties.\n    \"\"\"\n    \n    # 1. Miscut Angle (alpha)\n    # The normal to (h,h,l) is (h,h,l). The normal to (1,1,1) is (1,1,1).\n    if h_idx == l_idx:\n        # This is the (111) plane direction, so miscut is zero.\n        alpha = 0.0\n    else:\n        # cos(alpha) = (v1 . v2) / (|v1| |v2|)\n        cos_alpha_num = 2 * h_idx + l_idx\n        cos_alpha_den = np.sqrt(3 * (2 * h_idx**2 + l_idx**2))\n        # Clamp to handle potential floating point errors for arguments near 1.0\n        cos_alpha_arg = np.clip(cos_alpha_num / cos_alpha_den, -1.0, 1.0)\n        alpha = np.arccos(cos_alpha_arg)\n\n    # 2. Interplanar Spacing (d111) for the (111) plane\n    d111 = a / np.sqrt(3)\n\n    # 3. Terrace Width (w) and Step Density (delta_step)\n    if alpha < 1e-12: # Treat very small angles as zero\n        w = np.inf\n        delta_step = 0.0\n    else:\n        tan_alpha = np.tan(alpha)\n        w = d111 / tan_alpha\n        delta_step = 1.0 / w\n\n    # 4. In-plane Row Spacings (s_parallel, s_perp)\n    s_parallel = a / np.sqrt(2)\n    s_perp = a * np.sqrt(3) / np.sqrt(2)\n\n    # 5. Best Rational Approximant (p/q)\n    if w == np.inf:\n        # Special case as defined in the problem\n        p, q = 0, 0\n    else:\n        r = w / s_perp\n        # Use standard library's Fraction to find the best rational approximant\n        rational_approx = Fraction(r).limit_denominator(Q_max)\n        p = rational_approx.numerator\n        q = rational_approx.denominator\n\n    # 6. Kink Linear Density (delta_kink)\n    if q == 0:\n        # By definition, if q is 0, kink density is 0.\n        delta_kink = 0.0\n    else:\n        delta_kink = p / (q * s_parallel)\n\n    return [alpha, d111, w, delta_step, p, q, delta_kink]\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # (a, h, l, Q_max) corresponding to (h,h,l) planes\n        (3.600, 1, 3, 20),      # Case A: (1,1,3)\n        (4.050, 2, 3, 50),      # Case B: (2,2,3)\n        (5.430, 1, 1, 20),      # Case C: (1,1,1)\n        (3.520, 10, 11, 200),   # Case D: (10,10,11)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        a, h_idx, l_idx, Q_max = case\n        result = calculate_properties(a, h_idx, l_idx, Q_max)\n        all_results.append(result)\n\n    def format_value(v):\n        \"\"\"Formats a single value according to the output specification.\"\"\"\n        if isinstance(v, float):\n            if np.isinf(v):\n                return 'inf'\n            # Format to 6 decimal places, f-string handles rounding.\n            return f'{v:.6f}'\n        # Integers p and q are returned as strings.\n        return str(v)\n\n    def format_result_list(result_list):\n        \"\"\"Formats a list of results into the required string format.\"\"\"\n        return f\"[{','.join(format_value(v) for v in result_list)}]\"\n\n    # Generate the final output string\n    formatted_strings = [format_result_list(res) for res in all_results]\n    print(f\"[{','.join(formatted_strings)}]\")\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "In any crystal, symmetry dictates that many distinct sets of Miller indices actually describe physically identical planes. This practice tackles the fundamental computational challenge of managing this redundancy by systematically enumerating only the unique, non-equivalent plane families. You will implement an algorithm that applies point-group theory to sort planes into equivalence classes and select a single \"canonical\" representative for each, a core technique for creating efficient materials databases and setting up high-throughput simulations. ",
            "id": "3442333",
            "problem": "You are given a direct Bravais lattice in three dimensions specified by a basis matrix $\\mathbf{A} \\in \\mathbb{R}^{3 \\times 3}$ whose columns are the direct lattice basis vectors in a fixed Cartesian coordinate system, and a set of point-group operations given as rotation matrices $\\{\\mathbf{R}_i\\}$ with $\\mathbf{R}_i \\in \\mathrm{SO}(3)$ acting on Cartesian vectors. A plane family in the lattice is specified by a Miller index triplet $\\mathbf{h} = (h,k,l) \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$ reduced to coprime integers. The corresponding reciprocal lattice basis is defined by the standard reciprocal basis formula from solid-state physics,\n$$\n\\mathbf{B}^{\\ast} = 2\\pi\\,\\mathbf{A}^{-\\mathsf{T}},\n$$\nso that a plane normal in reciprocal space is $\\mathbf{G}(\\mathbf{h}) = \\mathbf{B}^{\\ast}\\,\\mathbf{h}$. Two Miller triplets $\\mathbf{h}$ and $\\mathbf{h}'$ are considered equivalent if there exists a point-group rotation $\\mathbf{R}$ such that their reciprocal normals are related by an undirected equivalence,\n$$\n\\mathbf{G}(\\mathbf{h}') \\propto \\pm\\,\\mathbf{R}\\,\\mathbf{G}(\\mathbf{h}),\n$$\nthat is, the orientations of the normals are the same up to symmetry and overall sign, which reflects that a crystallographic plane does not have an orientation arrow. Equivalently, using $\\mathbf{h}' = \\mathbf{M}(\\mathbf{R})\\,\\mathbf{h}$ with\n$$\n\\mathbf{M}(\\mathbf{R}) \\equiv \\left(\\mathbf{B}^{\\ast}\\right)^{-1}\\,\\mathbf{R}\\,\\mathbf{B}^{\\ast} = \\mathbf{A}^{\\mathsf{T}}\\,\\mathbf{R}\\,\\mathbf{A}^{-\\mathsf{T}},\n$$\ntwo Miller triplets $\\mathbf{h}$ and $\\mathbf{h}'$ are equivalent if $\\mathbf{h}'$ lies in the orbit generated by integer unimodular transformations $\\{\\mathbf{M}(\\mathbf{R}_i)\\}$ and overall sign change. Assume all provided point-group rotations are true symmetries of the lattice, so that each $\\mathbf{M}(\\mathbf{R}_i)$ is an integer unimodular matrix.\n\nYour task is to design and implement an algorithm that enumerates all distinct plane families up to a maximum index norm bound by leveraging the reciprocal lattice representation and point-group symmetry to avoid duplicates. The index norm bound is defined as a Euclidean bound on Miller indices,\n$$\n\\|\\mathbf{h}\\|_2 \\equiv \\sqrt{h^2 + k^2 + l^2} \\le H,\n$$\nfor a given positive integer $H$. Only primitive Miller indices (that is, with $\\gcd(|h|,|k|,|l|)=1$) are to be considered. Two triplets that differ by an overall integer factor represent the same family and must be treated as duplicates.\n\nDefine a canonical representative for each equivalence class as follows. For any candidate integer triplet $\\mathbf{v} = (v_1,v_2,v_3)$, first apply sign normalization: if the first nonzero component of $\\mathbf{v}$ is negative, replace $\\mathbf{v}$ by $-\\mathbf{v}$; otherwise leave $\\mathbf{v}$ unchanged. Among all sign-normalized images obtained by applying every symmetry $\\mathbf{M}(\\mathbf{R}_i)$ to a given primitive $\\mathbf{h}$, select the lexicographically smallest triplet (comparing $v_1$ first, then $v_2$, then $v_3$) as the canonical representative for the equivalence class that contains $\\mathbf{h}$.\n\nYour program must implement the following, starting only from the fundamental definitions above.\n\n- Construct $\\mathbf{B}^{\\ast}$ from $\\mathbf{A}$ and use it to derive $\\mathbf{M}(\\mathbf{R}) = \\mathbf{A}^{\\mathsf{T}}\\,\\mathbf{R}\\,\\mathbf{A}^{-\\mathsf{T}}$.\n- Enumerate all primitive Miller triplets $\\mathbf{h} \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$ with $\\|\\mathbf{h}\\|_2 \\le H$.\n- For each $\\mathbf{h}$, compute its equivalence orbit under the group generated by $\\{\\mathbf{M}(\\mathbf{R}_i)\\}$ and the undirected sign equivalence, and insert only one canonical representative per equivalence class into the output set.\n- Sort the final set of canonical representatives in lexicographic order.\n\nScientific realism constraints and units: There are no physical units required in the final answer. The angles used to construct rotation matrices must be specified and interpreted in degrees.\n\nTest suite. Your program must execute on the following three test cases and aggregate the outputs.\n\n- Test case $1$ (happy path, high symmetry): Direct lattice $\\mathbf{A} = \\mathrm{diag}(1.0,1.0,1.0)$. Point group is the full proper rotational symmetry group of the cube (the octahedral group), that is, all $3 \\times 3$ orthogonal matrices with integer entries and determinant $+1$; construct this set algorithmically by enumerating all axis permutations and sign choices that yield determinant $+1$. Use index norm bound $H=2$.\n- Test case $2$ (anisotropic but symmetric): Direct lattice $\\mathbf{A} = \\mathrm{diag}(1.0,1.0,1.5)$. Point group is the proper rotational dihedral group about the $z$-axis with fourfold symmetry, generated by a rotation $\\mathbf{R}_z$ by $90^{\\circ}$ about the $z$-axis and a rotation $\\mathbf{R}_x$ by $180^{\\circ}$ about the $x$-axis, both given in degrees. Build the full group by closure under matrix multiplication. Use index norm bound $H=2$.\n- Test case $3$ (edge case, no symmetry): Direct lattice\n$$\n\\mathbf{A} = \\begin{bmatrix}\n1.0 & 0.3 & 0.2\\\\\n0.0 & 1.1 & 0.4\\\\\n0.0 & 0.0 & 0.9\n\\end{bmatrix}.\n$$\nPoint group contains only the identity rotation. Use index norm bound $H=1$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in order and is itself a lexicographically sorted list of canonical representatives, each representative being a list $[h,k,l]$ of integers. For example, a valid overall format is\n$[[[h_{11},k_{11},l_{11}],\\dots],[[h_{21},k_{21},l_{21}],\\dots],[[h_{31},k_{31},l_{31}],\\dots]]$\nwith no additional text. All angles mentioned must be interpreted in degrees, and all answers are pure integers; no physical units are required.",
            "solution": "The user wants to find the canonical representatives of crystallographic plane families for different lattice symmetries and norm bounds.\n\n### Principle-Based Design\n\nThe problem requires enumerating unique families of crystallographic planes, represented by their Miller indices $\\mathbf{h} = (h,k,l)$, under the equivalence defined by the lattice's point-group symmetry. Two Miller indices are equivalent if their corresponding reciprocal lattice vectors are related by a point-group rotation, up to a sign. This physical equivalence translates into a mathematical transformation on the Miller indices themselves.\n\nThe core of the algorithm will be structured around these principles:\n\n1.  **Reciprocal Space and Symmetry Transformation**: A crystallographic plane is defined by a normal vector in reciprocal space. A reciprocal lattice vector $\\mathbf{G}$ corresponding to Miller indices $\\mathbf{h} = (h,k,l)$ is given by $\\mathbf{G}(\\mathbf{h}) = \\mathbf{B}^{\\ast}\\,\\mathbf{h}$, where $\\mathbf{B}^{\\ast}$ is the reciprocal lattice basis. The basis $\\mathbf{B}^{\\ast}$ is related to the direct lattice basis $\\mathbf{A}$ by $\\mathbf{B}^{\\ast} = 2\\pi (\\mathbf{A}^{-1})^{\\mathsf{T}}$. A symmetry operation in real space, represented by a rotation matrix $\\mathbf{R}$, transforms the Miller indices $\\mathbf{h}$ to an equivalent set $\\mathbf{h}'$. The transformation rule for these co-variant indices is $\\mathbf{h}' = \\mathbf{M}(\\mathbf{R})\\,\\mathbf{h}$, where the transformation matrix $\\mathbf{M}(\\mathbf{R})$ is derived as $\\mathbf{M}(\\mathbf{R}) = (\\mathbf{B}^{\\ast})^{-1} \\mathbf{R} \\mathbf{B}^{\\ast}$. Substituting the definition of $\\mathbf{B}^{\\ast}$, and ignoring the scalar factor $2\\pi$ which cancels out, we get $\\mathbf{M}(\\mathbf{R}) = \\mathbf{A}^{\\mathsf{T}} \\mathbf{R} (\\mathbf{A}^{\\mathsf{T}})^{-1}$. This is the formula provided in the problem statement. For any point-group symmetry $\\mathbf{R}$ of the lattice, this matrix $\\mathbf{M}(\\mathbf{R})$ must be an integer matrix with determinant $\\pm 1$ (unimodular), ensuring that it maps integer triplets to integer triplets.\n\n2.  **Equivalence Classes and Orbits**: The set of all Miller indices equivalent to a given $\\mathbf{h}$ forms an equivalence class, or an orbit. This orbit is generated by applying all symmetry transformation matrices $\\{\\mathbf{M}(\\mathbf{R}_i)\\}$ and considering sign changes (as planes are undirected, $(h,k,l)$ and $(-h,-k,-l)$ are equivalent). The task is to find one unique representative for each such orbit.\n\n3.  **Canonical Representative**: A canonical representative is defined to uniquely identify each equivalence class. The problem specifies a two-step procedure:\n    a. **Sign Normalization**: Any triplet $\\mathbf{v}$ is normalized by flipping its sign if its first non-zero component is negative. This ensures that equivalent pairs $\\{\\mathbf{v}, -\\mathbf{v}\\}$ map to a single normalized form.\n    b. **Lexicographical Minimum**: For a given primitive Miller index triplet $\\mathbf{h}$, we generate its full orbit. We then sign-normalize every triplet in the orbit. The canonical representative for the family of $\\mathbf{h}$ is the lexicographically smallest triplet among all these normalized forms.\n\n4.  **Enumeration Algorithm**: The overall algorithm is an enumeration followed by a reduction to canonical forms.\n    a. **Generate Candidates**: Systematically generate all primitive integer triplets $\\mathbf{h}=(h,k,l)$ within the specified Euclidean norm bound, $\\|\\mathbf{h}\\|_2 \\le H$. A triplet is primitive if $\\gcd(|h|,|k|,|l|) = 1$.\n    b. **Identify Unique Families**: For each primitive candidate $\\mathbf{h}$, we compute its canonical representative. To avoid redundant computations, we maintain a set of already processed triplets. If a candidate $\\mathbf{h}$ has not been processed, we compute its full orbit, find its canonical representative, add this representative to our final result set, and mark all triplets in the orbit as processed.\n    c. **Final Output**: The collected set of unique canonical representatives is converted to a list and sorted lexicographically to produce the final result.\n\n### Implementation Steps\n\nThe implementation will address each test case by following these steps:\n\n1.  **Group Generation**: For each test case, the corresponding set of point-group rotation matrices $\\{\\mathbf{R}_i\\}$ is generated.\n    -   *Case 1 (Cubic)*: The octahedral group $O$ consists of all $24$ signed permutation matrices with determinant $+1$. These are generated algorithmically.\n    -   *Case 2 (Tetragonal)*: The dihedral group $D_4$ is generated by taking the closure of the given generators ($R_z(90^\\circ)$ and $R_x(180^\\circ)$) under matrix multiplication.\n    -   *Case 3 (Triclinic)*: The group is trivial, containing only the identity matrix.\n\n2.  **Symmetry Matrix Calculation**: For each rotation $\\mathbf{R}_i$, the corresponding Miller index transformation matrix $\\mathbf{M}(\\mathbf{R}_i) = \\mathbf{A}^{\\mathsf{T}}\\mathbf{R}_i(\\mathbf{A}^{-1})^{\\mathsf{T}}$ is computed. Since the computation involves floating-point arithmetic but the result must be an integer matrix, the elements of the computed $\\mathbf{M}$ are rounded to the nearest integer.\n\n3.  **Enumeration and Reduction**: The main loop iterates through integers $h, k, l$ from $-H$ to $H$.\n    -   It filters out triplets that are outside the norm bound, the zero vector, non-primitive triplets, and any triplet that has already been accounted for.\n    -   For a new primitive triplet, it computes the full orbit $\\{\\pm \\mathbf{M}(\\mathbf{R}_i)\\mathbf{h}\\}$, determines the canonical representative by finding the lexicographical minimum of the sign-normalized orbit members, and adds it to the results. All members of the orbit are then marked as processed.\n\n4.  **Sorting and Formatting**: The final set of canonical representatives is sorted and formatted into the specified string representation.\n\nThis systematic approach guarantees that every possible plane family up to the norm limit is considered exactly once, and the representative for each family is chosen according to the precise rules given in the problem.",
            "answer": "```python\nimport numpy as np\nimport math\nimport itertools\n\ndef gcd_three(a: int, b: int, c: int) -> int:\n    \"\"\"Computes the greatest common divisor of three integers.\"\"\"\n    return math.gcd(math.gcd(abs(a), abs(b)), abs(c))\n\ndef generate_cubic_group() -> list[np.ndarray]:\n    \"\"\"\n    Generates the 24 rotation matrices of the proper cubic point group (Octahedral group O).\n    These are the 3x3 signed permutation matrices with determinant +1.\n    \"\"\"\n    matrices = []\n    identity = np.identity(3, dtype=int)\n    for p in itertools.permutations([0, 1, 2]):\n        for s in itertools.product([1, -1], repeat=3):\n            R = np.zeros((3, 3), dtype=int)\n            R[:, 0] = s[0] * identity[:, p[0]]\n            R[:, 1] = s[1] * identity[:, p[1]]\n            R[:, 2] = s[2] * identity[:, p[2]]\n            if int(round(np.linalg.det(R))) == 1:\n                matrices.append(R)\n    return matrices\n\ndef generate_d4_group() -> list[np.ndarray]:\n    \"\"\"\n    Generates the 8 rotation matrices of the D4 point group by closure.\n    Generators are a 90-degree rotation about z and a 180-degree rotation about x.\n    \"\"\"\n    theta_z = np.deg2rad(90)\n    Rz = np.array([\n        [np.cos(theta_z), -np.sin(theta_z), 0],\n        [np.sin(theta_z), np.cos(theta_z), 0],\n        [0, 0, 1]\n    ])\n    theta_x = np.deg2rad(180)\n    Rx = np.array([\n        [1, 0, 0],\n        [0, np.cos(theta_x), -np.sin(theta_x)],\n        [0, np.sin(theta_x), np.cos(theta_x)]\n    ])\n\n    Rz_int = np.round(Rz).astype(int)\n    Rx_int = np.round(Rx).astype(int)\n    \n    group_tuples = {tuple(map(tuple, np.identity(3, dtype=int)))}\n    generators = [Rz_int, Rx_int]\n    \n    while True:\n        current_size = len(group_tuples)\n        new_ops = set()\n        for op1_tup in group_tuples:\n            op1 = np.array(op1_tup)\n            for gen in generators:\n                new_op = np.dot(op1, gen)\n                new_ops.add(tuple(map(tuple, new_op)))\n        group_tuples.update(new_ops)\n        if len(group_tuples) == current_size:\n            break\n\n    return [np.array(m) for m in group_tuples]\n\ndef find_canonical_representatives(A: np.ndarray, R_matrices: list[np.ndarray], H: int) -> list[list[int]]:\n    \"\"\"\n    Enumerates canonical representatives for Miller indices up to norm H for a given\n    lattice A and point group rotations R_matrices.\n    \"\"\"\n    try:\n        A_inv_T = np.linalg.inv(A).T\n    except np.linalg.LinAlgError:\n        return []\n\n    M_matrices = [np.round(A.T @ R @ A_inv_T).astype(int) for R in R_matrices]\n\n    canonical_reps = set()\n    processed_hkls = set()\n    \n    H_sq = H**2\n    for h in range(-H, H + 1):\n        for k in range(-H, H + 1):\n            for l in range(-H, H + 1):\n                if h**2 + k**2 + l**2 > H_sq:\n                    continue\n                \n                hkl_tuple = (h, k, l)\n\n                if hkl_tuple in processed_hkls or hkl_tuple == (0, 0, 0):\n                    continue\n\n                if gcd_three(h, k, l) != 1:\n                    continue\n                \n                hkl_vec = np.array(hkl_tuple)\n                \n                orbit = set()\n                for M in M_matrices:\n                    orbit.add(tuple(M @ hkl_vec))\n                \n                full_orbit_signed = set()\n                for v in orbit:\n                    full_orbit_signed.add(v)\n                    full_orbit_signed.add(tuple(-x for x in v))\n                \n                orbit_normalized = set()\n                for v_tuple in full_orbit_signed:\n                    v_list = list(v_tuple)\n                    \n                    first_nonzero_idx = -1\n                    for i in range(3):\n                        if v_list[i] != 0:\n                            first_nonzero_idx = i\n                            break\n                    \n                    if first_nonzero_idx != -1 and v_list[first_nonzero_idx] < 0:\n                        v_tuple_norm = tuple(-x for x in v_list)\n                    else:\n                        v_tuple_norm = v_tuple\n                    orbit_normalized.add(v_tuple_norm)\n                \n                canonical_rep = min(orbit_normalized)\n                canonical_reps.add(canonical_rep)\n                \n                processed_hkls.update(full_orbit_signed)\n\n    return sorted([list(rep) for rep in canonical_reps])\n\ndef solve():\n    \"\"\"\n    Executes the three test cases and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": np.identity(3),\n            \"R_matrices\": generate_cubic_group(),\n            \"H\": 2\n        },\n        {\n            \"A\": np.diag([1.0, 1.0, 1.5]),\n            \"R_matrices\": generate_d4_group(),\n            \"H\": 2\n        },\n        {\n            \"A\": np.array([[1.0, 0.3, 0.2], [0.0, 1.1, 0.4], [0.0, 0.0, 0.9]]),\n            \"R_matrices\": [np.identity(3, dtype=int)],\n            \"H\": 1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        reps = find_canonical_representatives(case[\"A\"], case[\"R_matrices\"], case[\"H\"])\n        results.append(reps)\n\n    # Format output string without using external libraries like json\n    result_str = str(results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Having explored how to derive properties from indices and how to classify them by symmetry, we now address the \"inverse problem\" central to experimental materials science. This final practice challenges you to build an algorithm that infers the most likely Miller indices from noisy experimental data, such as plane normals measured by Electron Backscatter Diffraction (EBSD). By implementing a robust optimization scheme to handle real-world imperfections, you will gain practical experience in bridging theoretical crystallography with the realities of data analysis. ",
            "id": "3442251",
            "problem": "You are given a finite set of measured unit normal directions in three-dimensional Cartesian coordinates and a reciprocal lattice basis that defines the crystallographic relationship between Miller indices and plane normals. The fundamental base consists of the definitions of reciprocal lattice vectors and Miller indices, and the geometric relationship that the plane with Miller indices $(hkl)$ has a normal direction parallel to the reciprocal lattice vector $\\mathbf{G} = h \\mathbf{b}_1 + k \\mathbf{b}_2 + l \\mathbf{b}_3$, where $\\mathbf{b}_1$, $\\mathbf{b}_2$, and $\\mathbf{b}_3$ are the reciprocal lattice basis vectors satisfying $\\mathbf{b}_i \\cdot \\mathbf{a}_j = 2\\pi \\delta_{ij}$ with $\\mathbf{a}_j$ the direct lattice basis. The observable plane normal direction in Cartesian coordinates is collinear with $\\mathbf{G}$, and its orientation is invariant under the sign flip $\\mathbf{G} \\mapsto -\\mathbf{G}$.\n\nYour task is to write a complete, runnable program that infers the coprime integer Miller indices $(h,k,l) \\in \\mathbb{Z}^3$ of a crystallographic plane from measured unit normal directions $\\{\\hat{\\mathbf{n}}_i\\}_{i=1}^N$, robustly handling outliers. The inference must be based on minimizing a robust aggregate of angular deviations between the measured directions and the direction of the candidate reciprocal vector $\\hat{\\mathbf{G}} = \\mathbf{G}/\\|\\mathbf{G}\\|$. The angular deviation for each measurement is defined by the angle in radians\n$$\n\\varphi_i = \\arccos\\big(|\\hat{\\mathbf{n}}_i \\cdot \\hat{\\mathbf{G}}|\\big),\n$$\nwhich enforces invariance with respect to the sign of $\\hat{\\mathbf{G}}$. Robustness must be achieved by aggregating the deviations using the Huber loss function with parameter $\\delta > 0$,\n$$\n\\rho_\\delta(\\varphi) = \\begin{cases}\n\\frac{1}{2}\\varphi^2, & |\\varphi| \\le \\delta,\\\\\n\\delta\\left(|\\varphi| - \\frac{1}{2}\\delta\\right), & |\\varphi| > \\delta,\n\\end{cases}\n$$\noptionally after trimming the largest fraction $\\tau \\in [0,1)$ of $\\{\\varphi_i\\}$ to reject outliers. The objective to be minimized is the trimmed sum of Huber losses over the remaining angles.\n\nThe integral constraints are:\n- $(h,k,l) \\in \\mathbb{Z}^3$,\n- $(h,k,l) \\neq (0,0,0)$,\n- $\\gcd(|h|,|k|,|l|) = 1$ (coprime integer constraint),\n- $|h|,|k|,|l| \\le H_{\\max}$ for a given bound $H_{\\max} \\in \\mathbb{N}$.\n\nSince general-purpose mixed-integer solvers are not to be used, the program must perform an exact enumeration of candidates within the bound $H_{\\max}$ and select the minimizer of the robust objective. In case of ties in the objective value, apply deterministic tie-breaking in the following order: \n- prefer the candidate with smaller $\\|\\mathbf{G}\\|$, \n- then prefer the candidate whose first nonzero index is positive (canonical sign convention), \n- then prefer the lexicographically smaller tuple of absolute values $(|h|,|k|,|l|)$, \n- and finally prefer the lexicographically smaller signed tuple $(h,k,l)$ under the canonical sign convention.\n\nAll angles must be computed in radians. The final answers for each test case must be expressed as integer triples $[h,k,l]$.\n\nImplement the program to solve the following test suite, using the specified parameters and data exactly as provided. For each case, the reciprocal basis matrix $\\mathbf{B} \\in \\mathbb{R}^{3 \\times 3}$ is given by its columns $\\mathbf{b}_1,\\mathbf{b}_2,\\mathbf{b}_3$, and the measured unit normals are listed explicitly. The units of $\\mathbf{B}$ are inverse length, but only directions are used in the objective.\n\n- Test Case $1$ (simple cubic, target near $(1,1,0)$):\n  - $\\mathbf{B} = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$.\n  - Measured normals $\\{\\hat{\\mathbf{n}}_i\\}$:\n    - $\\hat{\\mathbf{n}}_1 = (0.71, 0.70, 0.00)$,\n    - $\\hat{\\mathbf{n}}_2 = (0.69, 0.72, 0.02)$,\n    - $\\hat{\\mathbf{n}}_3 = (0.73, 0.68, -0.01)$,\n    - $\\hat{\\mathbf{n}}_4 = (-0.71, -0.70, 0.00)$,\n    - $\\hat{\\mathbf{n}}_5 = (0.00, 0.00, 1.00)$,\n    - $\\hat{\\mathbf{n}}_6 = (0.70, 0.71, 0.00)$.\n  - Robust parameters: $\\delta = 0.10$, $\\tau = 0.17$, $H_{\\max} = 3$.\n\n- Test Case $2$ (simple cubic, target near $(1,1,1)$):\n  - $\\mathbf{B} = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$.\n  - Measured normals $\\{\\hat{\\mathbf{n}}_i\\}$:\n    - $\\hat{\\mathbf{n}}_1 = (0.58, 0.58, 0.58)$,\n    - $\\hat{\\mathbf{n}}_2 = (0.60, 0.61, 0.51)$,\n    - $\\hat{\\mathbf{n}}_3 = (0.55, 0.56, 0.65)$,\n    - $\\hat{\\mathbf{n}}_4 = (-0.58, -0.58, -0.58)$,\n    - $\\hat{\\mathbf{n}}_5 = (1.00, 0.00, 0.00)$.\n  - Robust parameters: $\\delta = 0.10$, $\\tau = 0.20$, $H_{\\max} = 3$.\n\n- Test Case $3$ (orthorhombic reciprocal basis, target near $(2,1,1)$):\n  - $\\mathbf{B} = \\begin{bmatrix} \\frac{1}{3} & 0 & 0 \\\\ 0 & \\frac{1}{4} & 0 \\\\ 0 & 0 & \\frac{1}{5} \\end{bmatrix}$ (columns are $\\left(\\frac{1}{3},0,0\\right)$, $\\left(0,\\frac{1}{4},0\\right)$, $\\left(0,0,\\frac{1}{5}\\right)$).\n  - Measured normals $\\{\\hat{\\mathbf{n}}_i\\}$:\n    - $\\hat{\\mathbf{n}}_1 = (0.90, 0.34, 0.27)$,\n    - $\\hat{\\mathbf{n}}_2 = (0.89, 0.35, 0.29)$,\n    - $\\hat{\\mathbf{n}}_3 = (0.92, 0.33, 0.26)$,\n    - $\\hat{\\mathbf{n}}_4 = (-0.90, -0.34, -0.27)$,\n    - $\\hat{\\mathbf{n}}_5 = (0.00, 1.00, 0.00)$.\n  - Robust parameters: $\\delta = 0.10$, $\\tau = 0.20$, $H_{\\max} = 4$.\n\n- Test Case $4$ (boundary with zeros in indices, target near $(0,0,1)$):\n  - $\\mathbf{B} = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$.\n  - Measured normals $\\{\\hat{\\mathbf{n}}_i\\}$:\n    - $\\hat{\\mathbf{n}}_1 = (0.00, 0.01, 0.9999)$,\n    - $\\hat{\\mathbf{n}}_2 = (-0.01, 0.00, 0.9998)$,\n    - $\\hat{\\mathbf{n}}_3 = (0.02, -0.01, 0.9997)$,\n    - $\\hat{\\mathbf{n}}_4 = (1.00, 0.00, 0.00)$,\n    - $\\hat{\\mathbf{n}}_5 = (0.00, 1.00, 0.00)$.\n  - Robust parameters: $\\delta = 0.10$, $\\tau = 0.40$, $H_{\\max} = 2$.\n\nYour program must implement the exact enumeration of candidates, the robust objective calculation in radians, trimming by $\\tau$, and the specified tie-breaking. The final output must be a single line containing a comma-separated list of the inferred index triples for the four test cases, enclosed in square brackets, for example $[\\,[h_1,k_1,l_1],\\,[h_2,k_2,l_2],\\,[h_3,k_3,l_3],\\,[h_4,k_4,l_4]\\,]$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the exact format:\n$$\n[[h_1,k_1,l_1],[h_2,k_2,l_2],[h_3,k_3,l_3],[h_4,k_4,l_4]].\n$$",
            "solution": "### Problem Validation\n\nThe problem statement has been critically evaluated against the specified criteria.\n\n**Step 1: Extract Givens**\n\n*   **Objective**: Infer coprime integer Miller indices $(h,k,l) \\in \\mathbb{Z}^3$ from a set of $N$ measured unit normal directions $\\{\\hat{\\mathbf{n}}_i\\}$.\n*   **Physical Model**: A crystallographic plane with Miller indices $(h,k,l)$ has a normal direction parallel to the reciprocal lattice vector $\\mathbf{G} = h \\mathbf{b}_1 + k \\mathbf{b}_2 + l \\mathbf{b}_3$. The direction is invariant to sign flip $\\mathbf{G} \\mapsto -\\mathbf{G}$.\n*   **Reciprocal Basis**: The vectors $\\mathbf{b}_i$ are provided for each test case as columns of a matrix $\\mathbf{B}$.\n*   **Optimization Criterion**: Minimize the trimmed sum of Huber losses of angular deviations.\n*   **Angular Deviation**: $\\varphi_i = \\arccos\\big(|\\hat{\\mathbf{n}}_i \\cdot \\hat{\\mathbf{G}}|\\big)$, with $\\hat{\\mathbf{G}} = \\mathbf{G}/\\|\\mathbf{G}\\|$.\n*   **Huber Loss**: A robust loss function $\\rho_\\delta(\\varphi)$ is defined with a parameter $\\delta$.\n    $$\n    \\rho_\\delta(\\varphi) = \\begin{cases}\n    \\frac{1}{2}\\varphi^2, & |\\varphi| \\le \\delta,\\\\\n    \\delta\\left(|\\varphi| - \\frac{1}{2}\\delta\\right), & |\\varphi| > \\delta.\n    \\end{cases}\n    $$\n*   **Trimming**: The largest fraction $\\tau$ of angular deviations $\\{\\varphi_i\\}$ are discarded as outliers before aggregation.\n*   **Search Space Constraints**:\n    1.  $(h,k,l)$ are integers.\n    2.  $(h,k,l) \\neq (0,0,0)$.\n    3.  $\\gcd(|h|,|k|,|l|) = 1$.\n    4.  $|h|,|k|,|l| \\le H_{\\max}$.\n*   **Solution Method**: Exact enumeration of all valid candidates within the search space.\n*   **Tie-Breaking Rules (in order of application)**:\n    1.  Prefer smaller objective value.\n    2.  Prefer smaller vector norm $\\|\\mathbf{G}\\|$.\n    3.  Prefer candidate whose first nonzero index is positive.\n    4.  Prefer lexicographically smaller tuple of absolute values $(|h|,|k|,|l|)$.\n    5.  Prefer lexicographically smaller signed tuple $(h,k,l)$.\n*   **Test Data**: Four specific test cases are provided, each with a reciprocal basis matrix $\\mathbf{B}$, a set of measured normals $\\{\\hat{\\mathbf{n}}_i\\}$, and parameters $\\delta$, $\\tau$, and $H_{\\max}$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is analyzed for validity:\n*   **Scientifically Grounded**: The problem is fundamentally based on established principles of solid-state physics and crystallography, specifically the relationship between Miller indices and reciprocal lattice vectors. The statistical methods employed (robust loss functions, outlier trimming) are standard and appropriate for analyzing experimental data with noise.\n*   **Well-Posed**: The problem is well-posed. The objective function is explicitly defined, the search space is finite, and the comprehensive, deterministic tie-breaking rules ensure that a unique solution exists and can be found.\n*   **Objective**: The problem is stated in precise, formal language, free of ambiguity or subjective claims.\n*   **Completeness**: All necessary information—basis vectors, measured data, and all model parameters—is provided for each test case.\n*   **Feasibility**: The specified search bound $H_{\\max}$ results in a search space that is computationally tractable for an exact enumeration approach, as required. For the largest bound, $H_{\\max} = 4$, the number of candidates to check is $(2 \\cdot 4 + 1)^3 - 1 = 728$, which is well within feasible limits for modern processors.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is a well-defined, scientifically sound, and computationally feasible task in the domain of computational materials science. A solution will be developed and presented.\n\n### Solution Methodology\n\nThe task is to identify the most likely Miller indices $(h,k,l)$ for a set of measured plane normals by performing a constrained optimization over a discrete search space. The methodology involves three main components: candidate generation, objective function evaluation, and a systematic search with deterministic tie-breaking.\n\n**1. Candidate Generation and Constraints**\n\nThe solution space consists of integer triples $(h,k,l)$. An exhaustive search is performed for all candidates satisfying $|h| \\le H_{\\max}$, $|k| \\le H_{\\max}$, and $|l| \\le H_{\\max}$. Each generated candidate $(h,k,l)$ is validated against two primary crystallographic constraints:\n*   **Non-triviality**: The indices must not be the zero vector, i.e., $(h,k,l) \\neq (0,0,0)$.\n*   **Coprimality**: The indices must be coprime, i.e., $\\gcd(|h|,|k|,|l|) = 1$. This ensures that the indices represent a unique plane family and are in their lowest integer form. The greatest common divisor is computed as $\\gcd(\\text{abs}(h), \\gcd(\\text{abs}(k), \\text{abs}(l)))$.\n\n**2. Objective Function Evaluation**\n\nFor each valid candidate $(h,k,l)$, a robust objective value is computed to quantify its agreement with the measured data $\\{\\hat{\\mathbf{n}}_i\\}_{i=1}^N$. This process involves several steps:\n*   **Reciprocal Vector Calculation**: The corresponding reciprocal lattice vector $\\mathbf{G}$ is calculated using the provided reciprocal basis matrix $\\mathbf{B} = [\\mathbf{b}_1 | \\mathbf{b}_2 | \\mathbf{b}_3]$. Letting $\\mathbf{m} = [h,k,l]^T$, the vector is found via matrix-vector multiplication: $\\mathbf{G} = \\mathbf{B} \\mathbf{m}$.\n*   **Angular Deviation**: The vector $\\mathbf{G}$ is normalized to obtain the unit direction $\\hat{\\mathbf{G}} = \\mathbf{G}/\\|\\mathbf{G}\\|$. The angular deviation $\\varphi_i$ for each measured normal $\\hat{\\mathbf{n}}_i$ is computed as $\\varphi_i = \\arccos(|\\hat{\\mathbf{n}}_i \\cdot \\hat{\\mathbf{G}}|)$. The use of the absolute value $|\\cdot|$ correctly accounts for the physical equivalence of a plane normal and its opposite direction.\n*   **Robust Aggregation**: To mitigate the effect of outliers, a two-stage robust aggregation is performed.\n    1.  **Trimming**: The set of $N$ computed angles $\\{\\varphi_i\\}$ is sorted, and the largest $\\lfloor \\tau N \\rfloor$ angles are discarded, where $\\tau$ is the trimming fraction.\n    2.  **Huber Loss**: For each of the remaining angles $\\varphi$, the Huber loss $\\rho_\\delta(\\varphi)$ is calculated. This function behaves quadratically for small deviations ($|\\varphi| \\le \\delta$), penalizing them lightly, and linearly for large deviations ($|\\varphi| > \\delta$), reducing the influence of residual errors.\n*   **Total Objective**: The final objective value for the candidate $(h,k,l)$ is the sum of the Huber losses over the set of trimmed angles.\n\n**3. Optimization and Tie-Breaking**\n\nThe algorithm iterates through all valid candidates, calculating the objective value for each. It maintains a record of the \"best\" candidate found thus far. A new candidate replaces the current best if it has a strictly lower objective value. In the event of a tie in the objective value, a multi-stage, deterministic tie-breaking procedure is invoked to ensure a unique solution:\n\n1.  **Vector Norm**: The candidate with the smaller reciprocal vector norm, $\\|\\mathbf{G}\\|$, is preferred. This favors planes with larger interplanar spacing, a common physical preference.\n2.  **Canonical Sign**: If a tie persists, the candidate whose first non-zero index (reading from $h$ to $k$ to $l$) is positive is chosen.\n3.  **Absolute Lexicographical Order**: If still tied, the candidates' absolute indices $(|h|,|k|,|l|)$ are compared lexicographically. The one that is smaller is preferred.\n4.  **Signed Lexicographical Order**: As a final tie-breaker, the signed indices $(h,k,l)$ are compared lexicographically. The smaller tuple is chosen.\n\nThis structured search and tie-breaking protocol guarantees the identification of a single, optimal set of Miller indices for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to define and solve the test cases for Miller index inference.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"B\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            \"normals\": np.array([\n                [0.71, 0.70, 0.00],\n                [0.69, 0.72, 0.02],\n                [0.73, 0.68, -0.01],\n                [-0.71, -0.70, 0.00],\n                [0.00, 0.00, 1.00],\n                [0.70, 0.71, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.17,\n            \"H_max\": 3\n        },\n        # Test Case 2\n        {\n            \"B\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            \"normals\": np.array([\n                [0.58, 0.58, 0.58],\n                [0.60, 0.61, 0.51],\n                [0.55, 0.56, 0.65],\n                [-0.58, -0.58, -0.58],\n                [1.00, 0.00, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.20,\n            \"H_max\": 3\n        },\n        # Test Case 3\n        {\n            \"B\": np.array([[1/3, 0, 0], [0, 1/4, 0], [0, 0, 1/5]]),\n            \"normals\": np.array([\n                [0.90, 0.34, 0.27],\n                [0.89, 0.35, 0.29],\n                [0.92, 0.33, 0.26],\n                [-0.90, -0.34, -0.27],\n                [0.00, 1.00, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.20,\n            \"H_max\": 4\n        },\n        # Test Case 4\n        {\n            \"B\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            \"normals\": np.array([\n                [0.00, 0.01, 0.9999],\n                [-0.01, 0.00, 0.9998],\n                [0.02, -0.01, 0.9997],\n                [1.00, 0.00, 0.00],\n                [0.00, 1.00, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.40,\n            \"H_max\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Before passing normals, ensure they are unit vectors\n        norm_of_normals = np.linalg.norm(case[\"normals\"], axis=1, keepdims=True)\n        # Avoid division by zero for zero vectors, though not expected here\n        norm_of_normals[norm_of_normals == 0] = 1.0\n        unit_normals = case[\"normals\"] / norm_of_normals\n        \n        best_hkl = find_best_hkl(case[\"B\"], unit_normals, case[\"delta\"], case[\"tau\"], case[\"H_max\"])\n        results.append(list(best_hkl))\n    \n    # Format output precisely as requested: [[h1,k1,l1],[h2,k2,l2],...]\n    inner_results_str = [f\"[{h},{k},{l}]\" for h, k, l in results]\n    print(f\"[{','.join(inner_results_str)}]\")\n\n\ndef huber_loss(phi, delta):\n    \"\"\"Calculates the Huber loss for a given angle phi and parameter delta.\"\"\"\n    if abs(phi) <= delta:\n        return 0.5 * phi**2\n    else:\n        return delta * (abs(phi) - 0.5 * delta)\n\ndef first_nonzero_is_positive(h, k, l):\n    \"\"\"Checks if the first non-zero element of (h,k,l) is positive.\"\"\"\n    if h > 0: return True\n    if h < 0: return False\n    if k > 0: return True\n    if k < 0: return False\n    if l > 0: return True\n    # l < 0 is the only remaining case, as (0,0,0) is excluded\n    return False\n\ndef find_best_hkl(B, normals, delta, tau, H_max):\n    \"\"\"\n    Finds the best Miller indices (h,k,l) by minimizing the robust objective function.\n    \"\"\"\n    best_candidate = {\n        \"hkl\": None,\n        \"objective\": float('inf'),\n        \"norm_G\": float('inf'),\n    }\n\n    n_normals = normals.shape[0]\n    num_to_trim = int(math.floor(tau * n_normals))\n\n    for h in range(-H_max, H_max + 1):\n        for k in range(-H_max, H_max + 1):\n            for l in range(-H_max, H_max + 1):\n                \n                # Constraint 1: Not (0,0,0)\n                if h == 0 and k == 0 and l == 0:\n                    continue\n                \n                # Constraint 2: Coprime\n                if math.gcd(abs(h), math.gcd(abs(k), abs(l))) != 1:\n                    continue\n                \n                hkl_vec = np.array([h, k, l])\n                \n                # Calculate objective\n                G = B @ hkl_vec\n                norm_G = np.linalg.norm(G)\n                \n                if norm_G == 0: # Should not happen with valid B and non-zero hkl\n                    continue\n                \n                G_hat = G / norm_G\n                \n                dot_products = np.abs(normals @ G_hat)\n                # Clamp to avoid domain errors with arccos due to float precision\n                dot_products = np.clip(dot_products, -1.0, 1.0)\n                angles = np.arccos(dot_products)\n                \n                sorted_angles = np.sort(angles)\n                \n                if num_to_trim > 0:\n                    trimmed_angles = sorted_angles[:-num_to_trim]\n                else:\n                    trimmed_angles = sorted_angles\n                \n                objective = sum(huber_loss(phi, delta) for phi in trimmed_angles)\n                \n                # Comparison and tie-breaking\n                is_better = False\n                if objective < best_candidate[\"objective\"]:\n                    is_better = True\n                elif objective == best_candidate[\"objective\"]:\n                    if norm_G < best_candidate[\"norm_G\"]:\n                        is_better = True\n                    elif norm_G == best_candidate[\"norm_G\"]:\n                        new_is_pos = first_nonzero_is_positive(h, k, l)\n                        best_is_pos = first_nonzero_is_positive(*best_candidate[\"hkl\"])\n                        if new_is_pos and not best_is_pos:\n                            is_better = True\n                        elif new_is_pos == best_is_pos:\n                            abs_new = (abs(h), abs(k), abs(l))\n                            abs_best = tuple(abs(x) for x in best_candidate[\"hkl\"])\n                            if abs_new < abs_best:\n                                is_better = True\n                            elif abs_new == abs_best:\n                                if hkl_vec.tolist() < best_candidate[\"hkl\"]:\n                                    is_better = True\n\n                if is_better:\n                    best_candidate[\"hkl\"] = [h, k, l]\n                    best_candidate[\"objective\"] = objective\n                    best_candidate[\"norm_G\"] = norm_G\n                    \n    return tuple(best_candidate[\"hkl\"])\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}