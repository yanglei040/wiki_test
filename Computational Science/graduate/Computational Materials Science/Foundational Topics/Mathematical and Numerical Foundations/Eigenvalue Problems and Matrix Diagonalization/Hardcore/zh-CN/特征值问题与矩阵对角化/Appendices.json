{
    "hands_on_practices": [
        {
            "introduction": "对角化不仅仅是一个数学过程，更是从哈密顿量中提取物理内涵的核心工具。本练习将引导你研究 Aubry–André 模型，这是一个研究准周期晶格中局域化转变的经典模型。通过直接对角化哈密顿量并分析其本征向量和本征值，你可以亲手揭示系统如何从电子波函数延展的金属态过渡到波函数局域的绝缘态，并学习使用参与率等关键指标来量化这一物理现象。",
            "id": "3446844",
            "problem": "考虑一维紧束缚哈密顿量，其具有被称为 Aubry–André（也称为几乎马修）模型的准周期性在位调制。在计算材料科学中，该模型是使用矩阵对角化和本征值分析研究准周期晶格中局域化相变的经典模型。该模型定义在长度为 $N$、具有开放边界条件的链上，最近邻之间的跃迁振幅为 $t$，在位调制的强度为 $\\lambda$，其不可通约频率由一个有理数近似。在位点基 $\\{|i\\rangle\\}_{i=0}^{N-1}$ 中，哈密顿矩阵 $\\mathbf{H} \\in \\mathbb{R}^{N \\times N}$ 由下式指定：\n$$\nH_{i,j} = t \\, (\\delta_{i,j+1} + \\delta_{i,j-1}) + \\lambda \\cos\\!\\big(2\\pi \\alpha \\, i + \\phi \\big) \\, \\delta_{i,j},\n$$\n其中 $i \\in \\{0,1,\\dots,N-1\\}$，$t \\in \\mathbb{R}$，$\\lambda \\in \\mathbb{R}$，$\\alpha \\in \\mathbb{R}$ 是一个由有理数 $p/q$ 近似的无理数，$\\phi \\in \\mathbb{R}$ 是一个相位。开放边界条件通过 $H_{-1,0}=H_{N,N-1}=0$ 强制施加，这在实践中意味着只有链内最近邻的非对角元不为零。计算的基本依据是矩阵本征值问题，\n$$\n\\mathbf{H} \\, \\psi_n = E_n \\, \\psi_n,\n$$\n其中 $E_n \\in \\mathbb{R}$ 是本征值，$\\psi_n \\in \\mathbb{R}^N$ 是对应的归一化本征矢量，满足 $\\sum_{i=0}^{N-1} |\\psi_n(i)|^2 = 1$。为了量化本征态的空间延展与局域化程度，使用为归一化本征矢量定义的参与率\n$$\nP_n = \\frac{\\Big(\\sum_{i=0}^{N-1} |\\psi_n(i)|^2 \\Big)^2}{\\sum_{i=0}^{N-1} |\\psi_n(i)|^4} = \\frac{1}{\\sum_{i=0}^{N-1} |\\psi_n(i)|^4},\n$$\n以及归一化参与率 $p_n = P_n/N \\in (0,1]$。为了在不进行谱展开的情况下量化本征值统计特性，使用为有序谱 $E_0 \\le E_1 \\le \\dots \\le E_{N-1}$ 定义的连续能级间距比。将间距记为 $\\delta_k = E_{k+1} - E_k$（对于 $k \\in \\{0,1,\\dots,N-2\\}$），为 $k \\in \\{0,1,\\dots,N-3\\}$ 定义比率\n$$\nr_k = \\frac{\\min(\\delta_k,\\delta_{k+1})}{\\max(\\delta_k,\\delta_{k+1})},\n$$\n及其平均值 $r = \\frac{1}{N-2} \\sum_{k=0}^{N-3} r_k$，计算时需排除任何分母为零的未定义情况。\n\n您的任务是实现一个程序，该程序对下面的每个测试用例，构建 $\\mathbf{H}$，对其进行数值对角化以获得 $\\{E_n,\\psi_n\\}$，计算平均归一化参与率\n$$\n\\overline{p} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\frac{1}{N \\sum_{i=0}^{N-1} |\\psi_n(i)|^4},\n$$\n以及如上定义的连续能级间距的平均比率 $r$。在所有情况下均使用 $t=1$。角度是无量纲的，以弧度为单位。本问题中没有物理单位；所有量均为无量纲量。\n\n测试套件参数以元组 $(N,\\alpha,\\lambda,\\phi)$ 的形式指定，固定 $t=1$：\n\n- 情况 A（延展区候选）：$(N,\\alpha,\\lambda,\\phi) = (144,\\, 89/144,\\, 1.5,\\, 0.0)$。\n- 情况 B（临界区候选）：$(N,\\alpha,\\lambda,\\phi) = (144,\\, 89/144,\\, 2.0,\\, 0.0)$。\n- 情况 C（局域区候选）：$(N,\\alpha,\\lambda,\\phi) = (144,\\, 89/144,\\, 3.0,\\, 0.0)$。\n- 情况 D（无调制基线）：$(N,\\alpha,\\lambda,\\phi) = (144,\\, 89/144,\\, 0.0,\\, 0.0)$。\n- 情况 E（不同近似值和相位，局域化）：$(N,\\alpha,\\lambda,\\phi) = (89,\\, 55/89,\\, 3.0,\\, 0.3)$。\n\n您的程序必须输出单行内容，其中包含一个结果列表，每个情况一个结果，并按所列顺序排列。每个结果必须是列表 $[\\lambda, \\overline{p}, r]$，所有三个条目均以十进制数形式给出，并四舍五入到小数点后六位。全部输出必须是形如\n$$\n\\big[\\,[\\lambda_1,\\overline{p}_1,r_1],\\,[\\lambda_2,\\overline{p}_2,r_2],\\,\\dots\\,\\big]\n$$\n的单行。不应打印任何额外文本。",
            "solution": "我们从实对称哈密顿矩阵 $\\mathbf{H} \\in \\mathbb{R}^{N \\times N}$ 的矩阵本征值问题开始，这保证了存在一组完备的正交归一的本征矢量和实数本征值。具有开放边界条件的一维链上的 Aubry–André 哈密顿量由最近邻之间的跃迁振幅 $t$ 和在位调制 $\\lambda \\cos(2\\pi \\alpha i + \\phi)$ 定义，其频率 $\\alpha$ 在无限大尺寸极限下是无理数，在有限系统中则由有理数近似。索引 $i$ 的取值范围为 $0$到 $N-1$，$\\delta_{i,j}$ 表示克罗内克δ符号。\n\n计算工作流程如下：\n\n1. 矩阵构造。对每个测试用例 $(N,\\alpha,\\lambda,\\phi)$（$t=1$），通过设置以下元素来构造 $\\mathbf{H}$：\n   - 对于 $i \\in \\{0,1,\\dots,N-1\\}$，对角元为\n     $$\n     H_{i,i} = \\lambda \\cos(2\\pi \\alpha i + \\phi).\n     $$\n   - 对于 $i \\in \\{0,1,\\dots,N-2\\}$，非对角的最近邻元素为\n     $$\n     H_{i,i+1} = H_{i+1,i} = t = 1.\n     $$\n   所有其他元素均为零，这强制施加了开放边界条件。\n\n2. 对角化。使用实对称矩阵的求解程序求解\n   $$\n   \\mathbf{H}\\,\\psi_n = E_n \\,\\psi_n,\n   $$\n   得到非递减排序的本征值 $\\{E_n\\}_{n=0}^{N-1}$ 和满足\n   $$\n   \\sum_{i=0}^{N-1} |\\psi_n(i)|^2 = 1\n   $$\n   的正交归一的本征矢量 $\\{\\psi_n\\}_{n=0}^{N-1}$。\n   正交归一性确保了数值稳定性，并允许直接使用参与率的定义。\n\n3. 参与率。对每个归一化本征矢量 $\\psi_n$，使用以下定义计算参与率\n   $$\n   P_n = \\frac{\\left(\\sum_{i=0}^{N-1} |\\psi_n(i)|^2\\right)^2}{\\sum_{i=0}^{N-1} |\\psi_n(i)|^4} = \\frac{1}{\\sum_{i=0}^{N-1} |\\psi_n(i)|^4}.\n   $$\n   右侧的等式源于归一化条件 $\\sum_i |\\psi_n(i)|^2 = 1$。归一化参与率 $p_n = P_n/N \\in (0,1]$ 衡量本征态有效占据系统的分数，其中 $p_n \\approx 1$ 表示空间延展态，而 $p_n \\ll 1$ 表示局域在少数位点上。计算平均归一化参与率\n   $$\n   \\overline{p} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\frac{1}{N \\sum_{i=0}^{N-1} |\\psi_n(i)|^4 }.\n   $$\n\n4. 本征值间距统计。将本征值按升序排序（对称矩阵的对角化程序已提供排好序的结果）。计算间距 $\\delta_k = E_{k+1} - E_k$（对于 $k \\in \\{0,1,\\dots,N-2\\}$）。然后为 $k \\in \\{0,1,\\dots,N-3\\}$ 计算连续间隙的比率\n   $$\n   r_k = \\frac{\\min(\\delta_k, \\delta_{k+1})}{\\max(\\delta_k, \\delta_{k+1})}\n   $$\n   ，排除任何分母为零以避免除零错误的项。平均比率\n   $$\n   r = \\frac{1}{M} \\sum_{k} r_k,\n   $$\n   其中 $M$ 是有效 $r_k$ 的数量，是能级排斥的无量纲度量：对于类似于不相关能级的强局域谱，$r$ 趋向于泊松统计的特征值；而对于具有能级排斥的延展态，$r$ 通常更大。使用比率避免了进行谱展开的需要。\n\n5. 测试套件与输出。对每个提供的测试用例，执行步骤 $1$–$4$ 以获得 $(\\lambda, \\overline{p}, r)$。将结果按指定顺序组合成列表的列表 $[\\,[\\lambda_1,\\overline{p}_1,r_1],\\dots]$，并作为单行打印。将每个浮点数四舍五入到小数点后六位，以生成简洁、可测试的输出。\n\n算法设计细节和数值考虑：\n- 哈密顿矩阵是三对角矩阵，对角线为余弦函数；测试套件中的维度 $N$ 足够小，使用对称求解器进行密集对角化在计算上是微不足道的。\n- 因为 $\\mathbf{H}$ 是实对称的，$\\psi_n$ 可以取为实数，这将绝对值运算简化为实数项的平方。\n- 求解器得到的本征矢量的归一化保证了 $P_n$ 可以稳健地计算为 $1/\\sum_i |\\psi_n(i)|^4$，但为了数值安全，可以计算分子 $(\\sum_i |\\psi_n(i)|^2)^2$ 再除以 $\\sum_i |\\psi_n(i)|^4$。在浮点容差范围内，两者产生相同的值。\n- 比率 $r_k$ 的界限在 $[0,1]$ 内，提供了一个无需重新缩放的良态统计量。\n- 准周期频率 $\\alpha$ 由斐波那契比率 $89/144$ 和 $55/89$ 近似，它们是黄金比例倒数的标准有理近似值，并为有限链提供了高质量的不可通约性。\n\n最终程序确定性地实现了此流程，并以所要求的精确单行格式打印结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_hamiltonian(N: int, alpha: float, lam: float, phi: float, t: float = 1.0) - np.ndarray:\n    \"\"\"\n    Construct the Aubry–André Hamiltonian matrix for a 1D chain with open boundary conditions.\n\n    H_{i,i}   = lam * cos(2*pi*alpha*i + phi)\n    H_{i,i+1} = H_{i+1,i} = t\n\n    Parameters\n    ----------\n    N : int\n        System size (number of lattice sites).\n    alpha : float\n        Quasiperiodic frequency (rational approximant of an irrational).\n    lam : float\n        Modulation strength lambda.\n    phi : float\n        Phase offset in radians.\n    t : float\n        Nearest-neighbor hopping amplitude (default 1.0).\n\n    Returns\n    -------\n    H : np.ndarray\n        Real symmetric Hamiltonian matrix of shape (N, N).\n    \"\"\"\n    H = np.zeros((N, N), dtype=np.float64)\n    i = np.arange(N, dtype=np.float64)\n    H[np.arange(N), np.arange(N)] = lam * np.cos(2.0 * np.pi * alpha * i + phi)\n    offdiag_indices = np.arange(N - 1)\n    H[offdiag_indices, offdiag_indices + 1] = t\n    H[offdiag_indices + 1, offdiag_indices] = t\n    return H\n\ndef participation_ratio(evecs: np.ndarray) - float:\n    \"\"\"\n    Compute the mean normalized participation ratio over all eigenvectors.\n\n    Parameters\n    ----------\n    evecs : np.ndarray\n        Eigenvectors as columns, shape (N, N), assumed normalized.\n\n    Returns\n    -------\n    pbar : float\n        Mean of P_n / N over n, where P_n = 1 / sum_i |psi_n(i)|^4.\n    \"\"\"\n    # evecs are real for a real symmetric matrix, but compute generically\n    psi2 = evecs**2  # since real; otherwise use np.abs(evecs)**2\n    denom = np.sum(psi2**2, axis=0)  # sum_i |psi_n(i)|^4 for each n\n    # Avoid division by zero (should not happen for normalized, nonzero vectors)\n    denom = np.where(denom == 0.0, np.finfo(np.float64).tiny, denom)\n    Pn = 1.0 / denom  # since sum_i |psi|^2 = 1 by normalization\n    N = evecs.shape[0]\n    pn_norm = Pn / N\n    return float(np.mean(pn_norm))\n\ndef mean_spacing_ratio(evals: np.ndarray) - float:\n    \"\"\"\n    Compute the mean ratio of consecutive level spacings, r ="
        },
        {
            "introduction": "理解材料的振动模式对于揭示其热导率、热膨胀和声学特性至关重要。本实践将标准本征值问题扩展到在晶格动力学中更为普遍的广义本征值问题 $K u = \\lambda M u$。你将学习如何为原子团簇构建刚度矩阵 $K$ 和质量矩阵 $M$，并处理一个核心的实际挑战：利用投影技术分离出真实的内部振动与无物理意义的刚体平移和转动，从而准确求解材料的振动谱。",
            "id": "3446833",
            "problem": "考虑一个在三维空间($\\mathrm{3D}$)中由 $N$ 个原子组成的有限团簇，其具有 $3N$ 个位移自由度 (DOF)。设 $M \\in \\mathbb{R}^{3N \\times 3N}$ 为对角质量矩阵，其对角线上是由原子索引 $i \\in \\{1,\\dots,N\\}$ 和质量 $m_i$ 构成的 $3 \\times 3$ 分块矩阵 $m_i I_3$。设 $K \\in \\mathbb{R}^{3N \\times 3N}$ 为对称刚度（海森）矩阵，其产生于力学平衡状态下成对中心弹簧相互作用的线性化。在小位移情况下，总势能由以下二次型给出\n$$\n\\Pi(u) = \\frac{1}{2} u^\\top K u,\n$$\n其中 $u \\in \\mathbb{R}^{3N}$ 集合了所有原子的笛卡尔位移。无阻尼自由振动的广义特征值问题为\n$$\nK u = \\lambda M u,\n$$\n其中 $\\lambda = \\omega^2$，$\\omega$ 为角频率。在没有外部约束的情况下，刚体子空间由三个平移和三个围绕质心的旋转所张成，$K$ 是半正定的，其零空间包含这些刚体模式。\n\n您的任务是在一个独立的程序中，实现一个质量加权投影以移除刚体模式，并计算投影算符在非刚体子空间上的广义谱。根据第一性原理以及线性弹性力学和经典力学中经过充分检验的事实，刚体平移模式是每个原子 $i$ 上的位移 $u_i = t$（其中 $t \\in \\mathbb{R}^3$），而围绕质心位置 $r_{\\mathrm{cm}}$ 的刚体旋转模式是原子 $i$ 上的位移 $u_i = \\omega \\times (r_i - r_{\\mathrm{cm}})$（其中角速度矢量 $\\omega \\in \\mathbb{R}^3$）。质量加权内积定义为\n$$\n\\langle x, y \\rangle_M = x^\\top M y,\n$$\n并且应构建到刚体子空间的 $M$-正交补上的正交投影，并用其来约束广义特征值问题。\n\n请使用经过充分检验的、针对原子 $i$ 和 $j$ 之间弹簧的贡献，来实现仅抵抗沿原子间连线方向伸长的中心弹簧的刚度矩阵 $K$。该弹簧的弹簧常数为 $k_{ij}$，单位方向为 $n_{ij} = \\frac{r_j - r_i}{\\|r_j - r_i\\|}$：\n- 其 $3 \\times 3$ 块贡献为 $B_{ij} = k_{ij} \\, n_{ij} n_{ij}^\\top$。\n- 通过将 $B_{ij}$ 加到对角块 $(i,i)$ 和 $(j,j)$ 上，并从非对角块 $(i,j)$ 和 $(j,i)$ 中减去 $B_{ij}$ 来组装 $K$。\n\n请使用以下测试套件。在所有情况下，边都是原子索引上的完全图（所有对 $i  j$），质心使用给定的 $m_i$ 计算，旋转是围绕 $r_{\\mathrm{cm}}$进行的。所有量都是无量纲的，并应在一致的任意单位下处理。\n\n- 测试用例 1（理想情况）：$N = 4$ 个原子，位置为\n$$\nr_1 = (1,1,1), \\quad r_2 = (-1,-1,1), \\quad r_3 = (-1,1,-1), \\quad r_4 = (1,-1,-1),\n$$\n质量为 $m = [1,1,1,1]$，弹簧常数统一为 $k_{ij} = k_0$，其中 $k_0 = 50$。\n\n- 测试用例 2（异构质量）：位置与测试用例 1 相同，质量为 $m = [1.0,\\,2.0,\\,3.5,\\,0.8]$，弹簧常数统一为 $k_{ij} = k_0$，其中 $k_0 = 10$。\n\n- 测试用例 3（一般几何形状，异构参数）：$N = 5$ 个原子，位置为\n$$\nr_1 = (0.0,\\,0.0,\\,0.0), \\quad r_2 = (1.2,\\,-0.7,\\,0.3), \\quad r_3 = (-0.9,\\,1.1,\\,0.8), \\quad r_4 = (0.5,\\,0.4,\\,-1.5), \\quad r_5 = (-1.3,\\,-0.2,\\,0.9),\n$$\n质量为 $m = [1.0,\\,0.8,\\,1.5,\\,1.2,\\,0.9]$，弹簧常数定义为\n$$\nk_{ij} = k_0 \\left(1 + 0.1 (i + j)\\right), \\quad \\text{其中 } k_0 = 5.0,\n$$\n对于每对 $(i,j)$ 且 $i  j$。\n\n- 测试用例 4（具有近奇异刚度的边界情况）：位置和质量与测试用例 1 相同，弹簧常数统一为 $k_{ij} = k_0$，其中 $k_0 = 10^{-6}$。\n\n对于每个测试用例，执行以下计算步骤：\n1. 组装 $K$ 和 $M$。\n2. 使用三个线性无关的平移和三个围绕 $r_{\\mathrm{cm}}$ 的线性无关的旋转为刚体子空间构建一个基。\n3. 构建到刚体子空间补空间上的 $M$-正交投影，并提取该补空间的一个 $M$-标准正交基。\n4. 将广义特征值问题约束到此补空间上，并计算所有特征值 $\\lambda$。\n5. 对于每个测试用例，报告最小特征值以及一个布尔值，该值指示在数值容差 $\\epsilon = 10^{-10}$ 内是否所有特征值都严格为正；即，对于补空间中的所有特征值，是否有 $\\lambda  \\epsilon$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个条目对应一个测试用例，并且本身是一个形式为 $[\\text{min\\_eigenvalue}, \\text{all\\_positive}]$ 的双元素列表。例如，输出格式应为\n$$\n[[\\lambda_{\\min}^{(1)}, \\text{True}],[\\lambda_{\\min}^{(2)}, \\text{True}],[\\lambda_{\\min}^{(3)}, \\text{True}],[\\lambda_{\\min}^{(4)}, \\text{True}]]\n$$\n用实际数值替换占位符。",
            "solution": "所提供的问题是计算材料科学领域，特别是在有限原子团簇的晶格动力学方面，一个适定且科学上合理的练习。它基于经典力学和线性代数的原理。任务是计算在移除非振动的、零频率的刚体模式后原子团簇的振动谱。所有提供的数据和定义都是标准的、一致的，并且足以获得唯一且有意义的解。因此，该问题是有效的，我们接下来进行详细的求解。\n\n其基本物理模型是原子间势能的谐波近似，这对于偏离力学平衡构型的微小位移 $u \\in \\mathbb{R}^{3N}$ 是有效的。势能由二次型 $\\Pi(u) = \\frac{1}{2} u^\\top K u$ 给出，其中 $K \\in \\mathbb{R}^{3N \\times 3N}$ 是对称的、半正定的刚度矩阵（或海森矩阵）。动能为 $T(\\dot{u}) = \\frac{1}{2} \\dot{u}^\\top M \\dot{u}$，其中 $M \\in \\mathbb{R}^{3N \\times 3N}$ 是对角的、正定的质量矩阵。应用拉格朗日运动方程可得到二阶常微分方程组 $M \\ddot{u} + K u = 0$。假设谐波解的形式为 $u(t) = u_0 e^{i\\omega t}$，我们得到广义特征值问题：\n$$\nK u = \\omega^2 M u\n$$\n令 $\\lambda = \\omega^2$，我们得到标准形式 $K u = \\lambda M u$。特征值 $\\lambda$ 是振动简正模角频率的平方，特征向量 $u$ 是相应的位移模式。\n\n质量矩阵 $M$ 是一个对角矩阵，由 $N$ 个形式为 $m_i I_3$ 的分块组成，其中 $m_i$ 是第 $i$ 个原子的质量，$I_3$ 是 $3 \\times 3$ 的单位矩阵。\n$$\nM = \\begin{pmatrix} m_1 I_3   \\\\  m_2 I_3  \\\\   \\ddots  \\\\    m_N I_3 \\end{pmatrix}\n$$\n刚度矩阵 $K$ 是由成对中心弹簧相互作用的贡献组装而成的。对于一个连接原子 $i$ 和 $j$（位于 $r_i$ 和 $r_j$）且弹簧常数为 $k_{ij}$ 的弹簧，其储存的能量与长度变化的平方成正比。这导致一个 $3 \\times 3$ 的分块贡献 $B_{ij} = k_{ij} n_{ij} n_{ij}^\\top$，其中 $n_{ij} = \\frac{r_j - r_i}{\\|r_j - r_i\\|}$ 是沿原子间连线的单位向量。完整的刚度矩阵 $K$ 是通过将这些分块加到对角子矩阵上并从非对角子矩阵中减去它们来组装的，这反映了作用在原子上的力：\n$$\nK_{ii} = \\sum_{j \\neq i} B_{ij}, \\quad K_{ij} = -B_{ij} \\text{ for } i \\neq j\n$$\n\n对于一个有限的、无约束的团簇，存在一些不改变原子间距离、因此不储存势能的运动模式。这些就是刚体模式：三个平移和三个旋转。这些模式张成了刚度矩阵 $K$ 的零空间，意味着对于任何刚体模式 $u$，$Ku=0$。因此，广义特征值问题会产生六个零特征值（$\\lambda=0$）。为了研究团簇的内部振动，必须将这些非振动模式投影出去。\n\n这个投影是在赋有质量加权内积 $\\langle x, y \\rangle_M = x^\\top M y$ 的空间中进行的。这个内积具有物理动机，因为动能是 $\\frac{1}{2} \\langle \\dot{u}, \\dot{u} \\rangle_M$。在 $M$-正交于刚体模式的子空间上求解特征值问题的步骤如下：\n\n1.  **变换为标准特征值问题**：广义特征值问题 $K u = \\lambda M u$ 可以转换为标准特征值问题。由于 $M$ 是正定的，其 Cholesky 分解存在。对于对角矩阵 $M$，我们可以简单地定义一个对角矩阵 $L = M^{1/2}$ 使得 $M = LL^\\top = L^2$。将 $u = L^{-1} \\tilde{u}$ 代入方程得到：\n    $$\n    K L^{-1} \\tilde{u} = \\lambda L L^{-1} \\tilde{u}\n    $$\n    从左侧乘以 $L^{-1}$（由于 $L$ 是对角的，它也等于 $(L^{-1})^\\top$）得到：\n    $$\n    (L^{-1} K L^{-1}) \\tilde{u} = \\lambda \\tilde{u}\n    $$\n    这是一个针对变换后的刚度矩阵 $\\tilde{K} = L^{-1} K L^{-1}$ 的标准特征值问题 $\\tilde{K} \\tilde{u} = \\lambda \\tilde{u}$。\n\n2.  **识别刚体子空间**：必须构造六个刚体模式。\n    -   **平移**：通过将每个原子的位移分别设置为 $(1,0,0)$、$(0,1,0)$ 和 $(0,0,1)$ 来形成三个基向量。\n    -   **旋转**：首先，计算质心：$r_{\\mathrm{cm}} = \\frac{\\sum_{i=1}^N m_i r_i}{\\sum_{i=1}^N m_i}$。旋转模式对应于围绕 $r_{\\mathrm{cm}}$ 的无穷小旋转。对于一个角速度矢量为 $\\omega$ 的旋转，原子 $i$ 的位移是 $u_i = \\omega \\times (r_i - r_{\\mathrm{cm}})$。通过选择 $\\omega$ 为 $(1,0,0)$、$(0,1,0)$ 和 $(0,0,1)$ 来形成三个基向量。\n    这六个向量，每个大小为 $3N$，构成了刚体子空间的一个基。我们将它们收集为矩阵 $V_{\\mathrm{rigid}} \\in \\mathbb{R}^{3N \\times 6}$ 的列。\n\n3.  **构造投影**：在变换后的坐标系中，刚体模式由 $\\tilde{V}_{\\mathrm{rigid}} = L V_{\\mathrm{rigid}}$ 的列给出。我们需要找到 $\\tilde{K}$ 在正交于由 $\\tilde{V}_{\\mathrm{rigid}}$ 的列所张成的子空间上的特征值。\n    一种数值稳健地寻找该正交补的标准正交基的方法是奇异值分解（SVD）。设 $\\tilde{V}_{\\mathrm{rigid}}$ 的 SVD 为 $U \\Sigma W^\\top$。矩阵 $U \\in \\mathbb{R}^{3N \\times 3N}$ 是酉矩阵，其列构成了 $\\mathbb{R}^{3N}$ 的一个完备标准正交基。如果 $\\tilde{V}_{\\mathrm{rigid}}$ 的秩为 $d$（对于非共线系统，该值为 $6$），那么 $U$ 的前 $d$ 列与 $\\tilde{V}_{\\mathrm{rigid}}$ 张成相同的子空间。$U$ 的其余 $3N-d$ 列构成了其正交补的一个标准正交基。设此基为 $\\tilde{Q}_{\\mathrm{comp}} = U[:, d:]$。\n\n4.  **求解投影后的问题**：补子空间中的任何向量 $\\tilde{u}$ 都可以写成基向量的线性组合：$\\tilde{u} = \\tilde{Q}_{\\mathrm{comp}} c$，其中 $c \\in \\mathbb{R}^{3N-d}$ 是系数向量。将此代入标准特征值问题：\n    $$\n    \\tilde{K} (\\tilde{Q}_{\\mathrm{comp}} c) = \\lambda (\\tilde{Q}_{\\mathrm{comp}} c)\n    $$\n    通过从左侧乘以 $\\tilde{Q}_{\\mathrm{comp}}^\\top$ 来投影到该基上：\n    $$\n    (\\tilde{Q}_{\\mathrm{comp}}^\\top \\tilde{K} \\tilde{Q}_{\\mathrm{comp}}) c = \\lambda (\\tilde{Q}_{\\mathrm{comp}}^\\top \\tilde{Q}_{\\mathrm{comp}}) c\n    $$\n    由于 $\\tilde{Q}_{\\mathrm{comp}}$ 的列是标准正交的，$\\tilde{Q}_{\\mathrm{comp}}^\\top \\tilde{Q}_{\\mathrm{comp}} = I_{3N-d}$。问题简化为一个针对 $(3N-d) \\times (3N-d)$ 矩阵 $K_{\\mathrm{proj}} = \\tilde{Q}_{\\mathrm{comp}}^\\top \\tilde{K} \\tilde{Q}_{\\mathrm{comp}}$ 的更小的标准特征值问题：\n    $$\n    K_{\\mathrm{proj}} c = \\lambda c\n    $$\n    $K_{\\mathrm{proj}}$ 的特征值 $\\lambda$ 是内部振动模式频率的平方。对于一个稳定的团簇，所有这些特征值必须严格为正。数值实现将为每个测试用例计算这些特征值，并报告最小特征值以及在给定容差内是否所有特征值都为正。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svd, eigh\n\ndef solve_vibrational_problem(positions, masses, k_func, N):\n    \"\"\"\n    Solves the vibrational problem for a cluster of N atoms.\n\n    Args:\n        positions (np.ndarray): (N, 3) array of atom positions.\n        masses (np.ndarray): (N,) array of atom masses.\n        k_func (callable): Function k_func(i, j) that returns the spring constant \n                           between atoms i and j (0-indexed).\n        N (int): Number of atoms.\n\n    Returns:\n        tuple: A tuple containing (min_eigenvalue, all_positive_flag).\n    \"\"\"\n    dim = 3\n    total_dof = dim * N\n    tol = 1e-10\n\n    # Step 1: Assemble Stiffness (K) and Mass (M) matrices\n    M_diag = np.repeat(masses, dim)\n    M = np.diag(M_diag)\n    L_inv = np.diag(1.0 / np.sqrt(M_diag))\n    L = np.diag(np.sqrt(M_diag))\n\n    K = np.zeros((total_dof, total_dof))\n    for i in range(N):\n        for j in range(i + 1, N):\n            r_i = positions[i]\n            r_j = positions[j]\n            d_ij = r_j - r_i\n            dist = np.linalg.norm(d_ij)\n            if dist  tol:\n                continue\n            n_ij = d_ij / dist\n            \n            k_ij = k_func(i, j)\n            B_ij = k_ij * np.outer(n_ij, n_ij)\n            \n            s_i, s_j = dim * i, dim * j\n            K[s_i:s_i+dim, s_i:s_i+dim] += B_ij\n            K[s_j:s_j+dim, s_j:s_j+dim] += B_ij\n            K[s_i:s_i+dim, s_j:s_j+dim] -= B_ij\n            K[s_j:s_j+dim, s_i:s_i+dim] -= B_ij\n\n    # Step 2: Construct a basis for the rigid-body subspace\n    # Center of mass calculation\n    total_mass = np.sum(masses)\n    r_cm = np.sum(masses[:, np.newaxis] * positions, axis=0) / total_mass\n    rel_pos = positions - r_cm\n\n    V_rigid = np.zeros((total_dof, dim * 2))\n\n    # 3 translation modes\n    for k in range(dim):\n        V_rigid[k::dim, k] = 1.0\n\n    # 3 rotation modes\n    for k in range(dim):\n        omega = np.zeros(dim)\n        omega[k] = 1.0\n        # rot_disp_k = cross(omega, rel_pos)\n        rot_disp_k = np.cross(omega, rel_pos, axisa=0, axisb=1)\n        V_rigid[:, dim + k] = rot_disp_k.flatten()\n\n    # Step 3: Build an M-orthonormal basis for the complement of the rigid-body subspace\n    # Transform rigid modes to the mass-weighted coordinate system\n    V_rigid_tilde = L @ V_rigid\n    \n    # Use SVD to find an orthonormal basis for the complement space\n    U, s, _ = svd(V_rigid_tilde, full_matrices=True)\n    \n    # The rank of V_rigid_tilde determines the dimension of the rigid subspace\n    rank = np.sum(s > tol)\n    \n    Q_comp_tilde = U[:, rank:]\n\n    # Step 4: Restrict the generalized eigenvalue problem and compute eigenvalues\n    # Transform K to the mass-weighted coordinate system\n    K_tilde = L_inv @ K @ L_inv\n\n    # Project K_tilde onto the complement subspace\n    K_proj = Q_comp_tilde.T @ K_tilde @ Q_comp_tilde\n    \n    # The projected matrix must be symmetric. Enforce it to handle small numerical errors.\n    K_proj = 0.5 * (K_proj + K_proj.T)\n\n    # Compute eigenvalues of the projected problem\n    eigenvalues = eigh(K_proj, eigvals_only=True)\n\n    # Step 5: Report results\n    if len(eigenvalues) == 0:\n        min_eigenvalue = 0.0\n        all_positive = True\n    else:\n        min_eigenvalue = np.min(eigenvalues)\n        all_positive = bool(np.all(eigenvalues > tol))\n\n    return [min_eigenvalue, all_positive]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the solver for each case.\n    \"\"\"\n    r_case1 = np.array([\n        [1.0, 1.0, 1.0],\n        [-1.0, -1.0, 1.0],\n        [-1.0, 1.0, -1.0],\n        [1.0, -1.0, -1.0]\n    ])\n    \n    r_case3 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.2, -0.7, 0.3],\n        [-0.9, 1.1, 0.8],\n        [0.5, 0.4, -1.5],\n        [-1.3, -0.2, 0.9]\n    ])\n\n    test_cases = [\n        {\n            \"N\": 4,\n            \"positions\": r_case1,\n            \"masses\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"k_func\": lambda i, j: 50.0\n        },\n        {\n            \"N\": 4,\n            \"positions\": r_case1,\n            \"masses\": np.array([1.0, 2.0, 3.5, 0.8]),\n            \"k_func\": lambda i, j: 10.0\n        },\n        {\n            \"N\": 5,\n            \"positions\": r_case3,\n            \"masses\": np.array([1.0, 0.8, 1.5, 1.2, 0.9]),\n            \"k_func\": lambda i, j: 5.0 * (1.0 + 0.1 * ((i + 1) + (j + 1)))\n        },\n        {\n            \"N\": 4,\n            \"positions\": r_case1,\n            \"masses\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"k_func\": lambda i, j: 1e-6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_vibrational_problem(case[\"positions\"], case[\"masses\"], case[\"k_func\"], case[\"N\"])\n        results.append(result)\n\n    # Format the results into the required string representation without extra spaces\n    result_strings = []\n    for res in results:\n        # Custom string formatting to match problem specification\n        min_eig_str = f\"{res[0]:.8e}\" if isinstance(res[0], float) else str(res[0])\n        bool_str = 'True' if res[1] else 'False'\n        result_strings.append(f\"[{min_eig_str},{bool_str}]\")\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在计算材料科学中，利用对称性是简化复杂问题、提升计算效率的关键策略。许多材料系统固有的几何对称性可以通过群论的语言精确描述，并直接应用于其哈密顿量。本练习将指导你运用群论中的投影算符方法，构建对称匹配的基函数，从而将一个庞大且难以处理的哈密顿量矩阵变换为由多个小矩阵构成的块对角形式。这不仅极大地降低了对角化所需的计算成本，也加深了对本征态对称性的物理理解。",
            "id": "3446824",
            "problem": "给定一个有限点群、一组在此群下变换的基函数，以及在该群操作下不变的哈密顿矩阵。你的任务是构造对称匹配的基函数，以块对角化每个哈密顿量，并量化对角化过程中的计算节省。这是一个纯数学问题：哈密顿量是一个作用于有限维向量空间的实对称矩阵，点群通过置换矩阵作用于基函数。\n\n基本原理：出发点是这样一个事实，如果一个矩阵 $H$ 与有限群 $G$ 的所有表示矩阵 $D(g)$ 对易，即对于所有 $g \\in G$ 都有 $[H, D(g)] = HD(g) - D(g)H = 0$，那么存在一个基变换，可以同时将 $H$ 块对角化为与 $G$ 的不可约表示相关的块。构造这种基变换的方法是，通过形成原始基函数的对称匹配线性组合，这些线性组合按照不可约表示进行变换，从而产生 $H$ 在其上独立作用的不变子空间。\n\n使用以下有限群和基：\n\n- 基函数 $\\{\\phi_0, \\phi_1, \\phi_2, \\phi_3\\}$ 位于四个位点，坐标分别为 $(0,+1)$、$(+1,0)$、$(0,-1)$、$(-1,0)$，按索引 $0,1,2,3$ 排序。\n- 点群是 $C_{2v}$，其操作有：单位元 $E$、绕原点旋转 $\\pi$ 的 $C_2$、关于 $x$ 轴的反射 $\\sigma_x$ 以及关于 $y$ 轴的反射 $\\sigma_y$。每个操作通过置换索引来作用：\n  - $E$: $0 \\mapsto 0$, $1 \\mapsto 1$, $2 \\mapsto 2$, $3 \\mapsto 3$。\n  - $C_2$: $0 \\mapsto 2$, $1 \\mapsto 3$, $2 \\mapsto 0$, $3 \\mapsto 1$。\n  - $\\sigma_x$: $0 \\mapsto 2$, $1 \\mapsto 1$, $2 \\mapsto 0$, $3 \\mapsto 3$。\n  - $\\sigma_y$: $0 \\mapsto 0$, $1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 1$。\n  这些操作定义了作用于一般基函数组合系数列向量上的 $4 \\times 4$ 置换矩阵 $D(g)$。\n\n构建一个程序，给定群作用矩阵 $D(g)$ 和一个满足 $[H, D(g)] = 0$（对于所有 $g \\in G$）的哈密顿量 $H$，执行以下操作：\n- 通过将原始基投影到在 $G$ 下不可约变换的子空间上，构造对称匹配的基函数。\n- 将这些基函数组装成一个正交的基变换矩阵，该矩阵可以块对角化 $H$。\n- 对角化每个块并连接特征值。\n- 将连接后的块特征值与完整哈密顿量的特征值进行比较。\n- 通过比率 $r = \\left(\\sum_{i} n_i^3\\right) / N^3$ 来量化块对角化的计算节省，其中 $N$ 是完整维度，$n_i$ 是块的大小。\n\n你的程序必须为以下哈密顿量测试套件实现并测试上述内容，所有这些都是大小为 $N = 4$ 的实对称矩阵：\n\n1. 理想情况（完全 $C_{2v}$ 不变性）：\n   $$H_1 = \\begin{bmatrix}\n   0  1  0  1 \\\\\n   1  0  1  0 \\\\\n   0  1  0  1 \\\\\n   1  0  1  0\n   \\end{bmatrix}.$$\n   这对应于正方形四条边上相等的最近邻耦合 $t = 1$ 和零在位能，并且它与所有 $g \\in C_{2v}$ 的 $D(g)$ 对易。\n\n2. 保持 $C_{2v}$ 的不同相互作用类型：\n   $$H_2 = \\begin{bmatrix}\n   0  1  0.5  1 \\\\\n   1  0  1  0.5 \\\\\n   0.5  1  0  1 \\\\\n   1  0.5  1  0\n   \\end{bmatrix}.$$\n   这在相对位点 $\\{0,2\\}$ 和 $\\{1,3\\}$ 之间增加了对角耦合 $t_d = 0.5$，同时保持群不变性。\n\n3. 保持 $C_{2v}$ 的各向异性在位能：\n   $$H_3 = \\begin{bmatrix}\n   2  1  0  1 \\\\\n   1  0  1  0 \\\\\n   0  1  2  1 \\\\\n   1  0  1  0\n   \\end{bmatrix}.$$\n   这在索引 $0$ 和 $2$ 处有在位能 $a = 2$，在索引 $1$ 和 $3$ 处有 $b = 0$，最近邻耦合相等，为 $t = 1$。\n\n4. 平凡群的边界情况（无对称性约化）：与情况1中相同的 $H_1$，但群仅包含单位操作 $E$。\n\n对于每个测试用例，你的程序应该：\n- 为所选群构造对称匹配的基函数。\n- 对哈密顿量进行块对角化并对角化每个块。\n- 计算三次操作计数的比率 $r$ 和通过块对角化得到的排序特征值与通过完全对角化得到的排序特征值之间的最大绝对差 $d$：\n  $$r = \\frac{\\sum_i n_i^3}{N^3}, \\quad d = \\max_j \\left| \\lambda^{(\\mathrm{full})}_j - \\lambda^{(\\mathrm{block})}_j \\right|.$$\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。按顺序报告每个测试用例的对 $(r, d)$，并将其平铺成一个列表。例如，四个测试用例的输出应为以下形式\n$[r_1, d_1, r_2, d_2, r_3, d_3, r_4, d_4]$，\n其中每个 $r_i$ 和 $d_i$ 表示为浮点数。不涉及物理单位，也不使用角度。所有值都必须由你的程序进行数值计算。",
            "solution": "用户请求验证并解决一个以群论应用为中心的问题，该问题涉及在计算材料科学背景下对哈密顿矩阵进行块对角化。\n\n### 第1步：问题验证\n\n问题陈述已根据指定标准进行了仔细分析。\n\n- **提取已知条件**：\n  - 基函数：$\\{\\phi_0, \\phi_1, \\phi_2, \\phi_3\\}$ 位于特定的笛卡尔坐标，映射到索引 $0, 1, 2, 3$。\n  - 点群：$C_{2v} = \\{E, C_2, \\sigma_x, \\sigma_y\\}$。\n  - 群作用：定义为基索引的置换，由此导出 $4 \\times 4$ 表示矩阵 $D(g)$。\n  - 不变性条件：哈密顿量 $H$ 被说明为满足 $[H, D(g)] = 0$ 对于所有群操作 $g$。\n  - 任务：通过投影构造对称匹配基函数（SAFs），形成一个基变换矩阵 $U$ 以块对角化 $H$，对角化这些块，并量化计算节省（$r$）和准确性（$d$）。\n  - 计算节省度量：$r = (\\sum_i n_i^3) / N^3$，其中 $n_i$ 是块的大小，$N$ 是完整矩阵的维度。\n  - 准确性度量：$d = \\max_j | \\lambda^{(\\mathrm{full})}_j - \\lambda^{(\\mathrm{block})}_j |$。\n  - 测试用例：四个指定的哈密顿矩阵和对称群对。\n    1. 具有 $C_{2v}$ 对称性的 $H_1$。\n    2. 具有 $C_{2v}$ 对称性的 $H_2$。\n    3. 具有 $C_{2v}$ 对称性的 $H_3$。\n    4. 具有平凡群 $\\{E\\}$ 的 $H_1$。\n\n- **使用提取的已知条件进行验证**：\n  1.  **科学上合理**：该问题是有限群表示论在简化量子力学和凝聚态物理中特征值问题的经典应用。舒尔引理和大正交性定理为与对称群对易的算符的块对角化提供了理论基础。$C_{2v}$ 群、所选的基点位置以及哈密顿量的结构都是标准模型。检查证实，所提供的哈密顿量 $H_1, H_2, H_3$ 确实与 $C_{2v}$ 的表示矩阵对易，正如所断言的。该问题在科学和数学上是合理的。\n  2.  **良构性**：该问题是良构的。表示空间分解为不可约子空间是唯一的，导致一组唯一的块大小 $\\{n_i\\}$ 和唯一的特征值。寻找对称匹配基的程序是确定性的。所需的输出 $r$ 和 $d$ 是唯一确定的量。\n  3.  **客观性**：问题的所有组成部分都以数学精度定义。没有歧义、主观性或依赖于观点。\n  4.  **完整性**：问题是自包含的，提供了进行求解所需的所有必要数据和定义。\n  5.  **可行性**：计算涉及对小型（$4 \\times 4$）矩阵的标准线性代数运算，计算上是微不足道的。\n\n- **结论**：\n  该问题是**有效的**。它是一个定义明确、科学上合理的计算物理问题，可以通过算法解决。\n\n### 第2步：求解推导\n\n解决方案需要实现用于块对角化的群论机制。\n\n**1. 群表示与特征标理论**\n点群是 $C_{2v}$，一个阶为 $|G|=4$ 的阿贝尔群。其操作和特征标表是基础。群操作以基索引 $\\{0, 1, 2, 3\\}$ 上的置换形式给出。这些置换定义了 $4 \\times 4$ 的表示矩阵 $D(g)$。\n\n- $E: (0)(1)(2)(3) \\implies D(E) = I_4$。\n- $C_2: (0 \\leftrightarrow 2, 1 \\leftrightarrow 3) \\implies D(C_2)_{ij} = \\delta_{i,C_2(j)}$。\n- $\\sigma_x: (0 \\leftrightarrow 2) \\implies D(\\sigma_x)_{ij} = \\delta_{i,\\sigma_x(j)}$。\n- $\\sigma_y: (1 \\leftrightarrow 3) \\implies D(\\sigma_y)_{ij} = \\delta_{i,\\sigma_y(j)}$。\n\n$C_{2v}$ 的特征标表包含其四个一维不可约表示（irreps）：$A_1, A_2, B_1, B_2$。\n| 不可约表示 | $\\chi(E)$ | $\\chi(C_2)$ | $\\chi(\\sigma_x)$ | $\\chi(\\sigma_y)$ |\n|:---:|:---:|:---:|:---:|:---:|\n| $A_1$ | $1$ | $1$ | $1$ | $1$ |\n| $A_2$ | $1$ | $1$ | $-1$ | $-1$ |\n| $B_1$ | $1$ | $-1$ | $1$ | $-1$ |\n| $B_2$ | $1$ | $-1$ | $-1$ | $1$ |\n\n**2. 可约表示的分解**\n由基 $\\{\\phi_0, \\phi_1, \\phi_2, \\phi_3\\}$ 提供的表示 $\\Gamma$ 是可约的。其特征标为 $\\chi(g) = \\mathrm{Tr}(D(g))$，它计算了在操作 $g$ 下保持不变的基函数数量。\n- $\\chi(E) = \\mathrm{Tr}(I_4) = 4$。\n- $\\chi(C_2) = 0$（没有不动点）。\n- $\\chi(\\sigma_x) = 2$（索引 $1, 3$ 是固定的）。\n- $\\chi(\\sigma_y) = 2$（索引 $0, 2$ 是固定的）。\n\n不可约表示 $\\alpha$ 在 $\\Gamma$ 中出现的次数由约化公式 $a_\\alpha = \\frac{1}{|G|} \\sum_{g \\in G} \\chi^{(\\alpha)*}(g) \\chi(g)$ 给出。\n- $a_{A_1} = \\frac{1}{4}[1(4) + 1(0) + 1(2) + 1(2)] = 2$。\n- $a_{A_2} = \\frac{1}{4}[1(4) + 1(0) - 1(2) - 1(2)] = 0$。\n- $a_{B_1} = \\frac{1}{4}[1(4) - 1(0) + 1(2) - 1(2)] = 1$。\n- $a_{B_2} = \\frac{1}{4}[1(4) - 1(0) - 1(2) + 1(2)] = 1$。\n\n因此，可约表示分解为 $\\Gamma = 2A_1 \\oplus B_1 \\oplus B_2$。这意味着任何具有 $C_{2v}$ 对称性的哈密顿量都将被块对角化为一个 $2 \\times 2$ 的块（对应于 $A_1$ 子空间）和两个 $1 \\times 1$ 的块（分别对应于 $B_1$ 和 $B_2$）。因此，块的大小为 $n_1=2, n_2=1, n_3=1$。\n\n**3. 对称匹配基函数（SAFs）的构造**\nSAFs 是使用投影算子 $P^{(\\alpha)} = \\frac{l_\\alpha}{|G|} \\sum_{g \\in G} \\chi^{(\\alpha)*}(g) D(g)$ 构造的。由于这里所有的不可约表示都是一维的（$l_\\alpha=1$），我们将原始基向量（标准基向量 $e_0, ..., e_3$）投影到每个不可约子空间上。\n- **$A_1$ 子空间**：投影 $e_0$ 和 $e_1$ 产生两个线性无关的向量：$e_0+e_2$ 和 $e_1+e_3$。将它们正交归一化得到前两个 SAFs：$\\psi_1 = \\frac{1}{\\sqrt{2}}(e_0+e_2)$ 和 $\\psi_2 = \\frac{1}{\\sqrt{2}}(e_1+e_3)$。\n- **$B_1$ 子空间**：投影基向量产生一个独立的向量，与 $e_1-e_3$ 成比例。归一化的 SAF 是 $\\psi_3 = \\frac{1}{\\sqrt{2}}(e_1-e_3)$。\n- **$B_2$ 子空间**：投影产生一个独立的向量，与 $e_0-e_2$ 成比例。归一化的 SAF 是 $\\psi_4 = \\frac{1}{\\sqrt{2}}(e_0-e_2)$。\n\n**4. 基变换与块对角化**\nSAFs $\\{\\psi_1, \\psi_2, \\psi_3, \\psi_4\\}$ 构成了酉变换矩阵 $U$ 的列。\n$$ U = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1  0  0  1 \\\\ 0  1  1  0 \\\\ 1  0  0  -1 \\\\ 0  1  -1  0 \\end{pmatrix} $$\n然后，块对角哈密顿量被计算为 $H' = U^T H U$。根据分解从 $H'$ 中提取块：一个 $2 \\times 2$ 的块对应 $A_1$，一个 $1 \\times 1$ 的块对应 $B_1$，另一个 $1 \\times 1$ 的块对应 $B_2$。\n\n**5. 算法实现**\n- 对于每个涉及 $C_{2v}$ 群的测试用例：\n  1. 如上所述构造矩阵 $U$。\n  2. 计算块对角矩阵 $H' = U^T H U$。\n  3. 提取块（$2 \\times 2, 1 \\times 1, 1 \\times 1$）。\n  4. 对角化每个块。对于一个 $1 \\times 1$ 的块 $[b]$，特征值是 $b$。使用标准数值程序对角化 $2 \\times 2$ 的块。\n  5. 收集并排序得到的特征值。\n  6. 直接对角化完整的哈密顿量 $H$ 以进行比较。\n  7. 计算度量 $r = (2^3+1^3+1^3)/4^3 = 10/64 = 0.15625$ 和 $d$（排序后特征值的最大绝对差）。\n- 对于具有平凡群 $\\{E\\}$ 的测试用例：\n  1. 该群只有一个不可约表示，对应于整个 $4$ 维空间。不可能进行约化。\n  2. “块”是整个 $4 \\times 4$ 矩阵。块大小为 $n_1=4$。\n  3. 计算节省比率为 $r = 4^3/4^3 = 1$。\n  4. 从完整矩阵计算特征值。差值 $d$ 必然为零。\n\n该程序将为提供的测试用例自动化整个过程，并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the symmetry-based block diagonalization problem for a series of Hamiltonians.\n    \"\"\"\n\n    # Define the permutation matrices for the C2v group generators.\n    # D(g) acts on a coefficient vector c as c' = D(g) c.\n    # This corresponds to transforming the basis as g(phi_i) = phi_{g(i)}.\n    # The matrix D(g) has D_ij = 1 if i=g(j), 0 otherwise.\n    \n    # E: (0)(1)(2)(3)\n    D_E = np.identity(4)\n    # C2: 0-2, 1-3, 2-0, 3-1\n    D_C2 = np.array([[0,0,1,0],[0,0,0,1],[1,0,0,0],[0,1,0,0]])\n    # sigma_x (reflection across xz-plane): 0-2, 1-1, 2-0, 3-3\n    D_sigmax = np.array([[0,0,1,0],[0,1,0,0],[1,0,0,0],[0,0,0,1]])\n    # sigma_y (reflection across yz-plane): 0-0, 1-3, 2-2, 3-1\n    D_sigmay = np.array([[1,0,0,0],[0,0,0,1],[0,0,1,0],[0,1,0,0]])\n\n    C2v_group_reps = {'E': D_E, 'C2': D_C2, 'sigmax': D_sigmax, 'sigmay': D_sigmay}\n    \n    # Character table for C2v group\n    # Rows are irreps, columns correspond to E, C2, sigmax, sigmay\n    char_table_C2v = {\n        'A1': {'E': 1, 'C2': 1, 'sigmax': 1, 'sigmay': 1},\n        'A2': {'E': 1, 'C2': 1, 'sigmax':-1, 'sigmay':-1},\n        'B1': {'E': 1, 'C2':-1, 'sigmax': 1, 'sigmay':-1},\n        'B2': {'E': 1, 'C2':-1, 'sigmax':-1, 'sigmay': 1},\n    }\n    \n    # Define test case Hamiltonians\n    H1 = np.array([\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ], dtype=float)\n\n    H2 = np.array([\n        [0,   1, 0.5, 1],\n        [1,   0, 1,   0.5],\n        [0.5, 1, 0,   1],\n        [1, 0.5, 1,   0]\n    ], dtype=float)\n\n    H3 = np.array([\n        [2, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 2, 1],\n        [1, 0, 1, 0]\n    ], dtype=float)\n\n    test_cases = [\n        (H1, 'C2v'),\n        (H2, 'C2v'),\n        (H3, 'C2v'),\n        (H1, 'trivial')\n    ]\n\n    results = []\n    \n    def get_saf_basis(group_name, group_reps, char_table):\n        \"\"\"\n        Constructs the symmetry-adapted basis (SAF) transformation matrix U and block sizes.\n        \"\"\"\n        if group_name == 'trivial':\n            return np.identity(4), [4]\n\n        U_cols = []\n        block_sizes = []\n        \n        N = 4  # Dimension of the basis\n        group_order = len(group_reps)\n        basis_vectors = [np.eye(N)[i] for i in range(N)]\n        \n        # Order of irreps for deterministic U matrix construction\n        irrep_names = ['A1', 'A2', 'B1', 'B2']\n\n        for irrep_name in irrep_names:\n            irrep_chars = char_table[irrep_name]\n            # Projection operator for this irrep\n            # P_alpha = (l_alpha / |G|) * sum_g chi_alpha(g)* D(g)\n            # l_alpha = 1 for all C2v irreps\n            P_alpha = np.zeros((N, N))\n            for g_name, D_g in group_reps.items():\n                P_alpha += irrep_chars[g_name] * D_g\n            P_alpha *= (1.0 / group_order)\n\n            # Project original basis vectors to find vectors spanning the irrep subspace\n            projected_vectors = []\n            for v in basis_vectors:\n                pv = P_alpha @ v\n                # Check if the projected vector is non-zero\n                if not np.allclose(pv, 0):\n                    projected_vectors.append(pv)\n            \n            if not projected_vectors:\n                continue\n\n            # Orthonormalize the collected vectors for this irrep's subspace\n            # Using QR decomposition on matrix of column vectors\n            # This is robust against linear dependencies\n            Q, R = np.linalg.qr(np.array(projected_vectors).T)\n            \n            # The columns of Q form an orthonormal basis for the subspace.\n            # The rank of R tells us the dimension of the subspace.\n            rank = np.sum(np.abs(np.diag(R)) > 1e-9)\n            if rank > 0:\n                U_cols.extend([Q[:, i] for i in range(rank)])\n                block_sizes.append(rank)\n\n        return np.array(U_cols).T, block_sizes\n\n    for H, group_name in test_cases:\n        N = H.shape[0]\n\n        # 1. Construct symmetry-adapted basis functions (SAFs)\n        if group_name == 'C2v':\n            U, block_sizes = get_saf_basis(group_name, C2v_group_reps, char_table_C2v)\n        else: # Trivial group\n             U, block_sizes = get_saf_basis(group_name, None, None)\n\n        # 2. Block-diagonalize the Hamiltonian\n        H_prime = U.T @ H @ U\n        \n        # 3. Diagonalize each block and concatenate eigenvalues\n        block_eigenvalues = []\n        current_idx = 0\n        for size in block_sizes:\n            block = H_prime[current_idx:current_idx+size, current_idx:current_idx+size]\n            if size > 0:\n                # Use eigh for symmetric matrices\n                eigvals = np.linalg.eigh(block)[0]\n                block_eigenvalues.extend(eigvals)\n            current_idx += size\n\n        block_eigenvalues.sort()\n\n        # 4. Compare with eigenvalues of the full Hamiltonian\n        full_eigenvalues = np.linalg.eigh(H)[0]\n        full_eigenvalues.sort()\n        \n        # 5. Quantify computational savings (r) and accuracy (d)\n        r = sum([n**3 for n in block_sizes]) / (N**3)\n        d = np.max(np.abs(np.array(full_eigenvalues) - np.array(block_eigenvalues)))\n\n        results.extend([r, d])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}