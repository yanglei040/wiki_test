{
    "hands_on_practices": [
        {
            "introduction": "牛顿法因其在理想条件下的二次收敛速度而备受推崇，但其收敛性并非总是理所当然。这个练习将引导你探索牛顿法在两种常见但棘手的场景下的失效模式：当函数在根附近存在多重根或平坦区域时。通过亲手实现和对比朴素牛顿法、步长缩放的牛顿法以及带回溯线搜索的阻尼牛顿法，你将掌握诊断求解器行为并采用标准策略来恢复其鲁棒性和效率的核心技能。",
            "id": "3164867",
            "problem": "您需要实现并分析一维非线性求根的数值求解器，重点关注当函数在根附近存在平坦区域时牛顿法的行为。设 $x^\\*$ 表示函数 $f(x)$ 的一个单根，并考虑牛顿迭代 $x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}$。您的任务是设计在 $x^\\*$ 处或其附近表现出接近平坦行为的光滑函数 $f(x)$，演示牛顿法如何可能停滞或变得低效，并实现通过步长缩放和阻尼来挽救收敛性的策略。\n\n此任务的基本假设如下：\n- 可微性：$f(x)$ 在应用该方法的区域是可微的，在某些情况下，$f'(x)$ 在 $x^\\*$ 附近可能很小。\n- 对于重根，如果 $f(x) = (x - x^\\*)^m$ 且整数 $m \\geq 2$，那么 $f'(x^\\*) = 0$，并且根点的局部几何是平坦的。\n- 反正切函数 $\\arctan(y)$ 对所有实数 $y$ 都是光滑的，其值是以弧度为单位的角度。\n\n您必须实现三种求解器：\n- 一种朴素牛顿求解器，直接应用 $x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}$，当 $\\lvert x_n - x^\\* \\rvert \\leq \\varepsilon$ 时终止。\n- 一种步长缩放的牛顿求解器，专为已知的根重数 $m \\geq 2$ 而设计，使用 $x_{n+1} = x_n - m \\frac{f(x_n)}{f'(x_n)}$。此方法重新缩放牛顿步长以考虑重数。\n- 一种带回溯线搜索的阻尼牛顿求解器：计算无阻尼步长 $\\Delta = -\\frac{f(x_n)}{f'(x_n)}$，通过从 $1$ 开始对半递减来选择步长 $\\lambda \\in (0, 1]$，直到满足 $\\lvert f(x_n + \\lambda \\Delta) \\rvert  \\lvert f(x_n) \\rvert$，然后设置 $x_{n+1} = x_n + \\lambda \\Delta$。当 $\\lvert x_n - x^\\* \\rvert \\leq \\varepsilon$ 时终止。\n\n设计以下测试函数和案例：\n- 案例 A（重根，在根点处平坦）：\n  - 函数：$f_1(x) = (x - 0.5)^2$，导数 $f_1'(x) = 2(x - 0.5)$，根 $x^\\* = 0.5$，重数 $m = 2$。\n  - 初始猜测值：$x_0 = 2.0$，容差 $\\varepsilon = 10^{-12}$，最大迭代次数 $N_{\\max} = 200$。\n  - 计算两个量：\n    1. 朴素牛顿求解器达到 $\\lvert x_n - x^\\* \\rvert \\leq \\varepsilon$ 所需的整数迭代次数（预期为缓慢的线性收敛行为）。\n    2. 重数缩放的牛顿求解器达到 $\\lvert x_n - x^\\* \\rvert \\leq \\varepsilon$ 所需的整数迭代次数。\n\n- 案例 B（根点附近斜率接近于零，但非重根）：\n  - 函数：$f_2(x) = \\arctan(\\alpha x)$，导数 $f_2'(x) = \\frac{\\alpha}{1 + \\alpha^2 x^2}$，根 $x^\\* = 0$。\n  - 角度单位：$\\arctan(\\cdot)$ 的输出以弧度为单位。\n  - 参数：$\\alpha = 10^{-3}$，初始猜测值 $x_0 = \\frac{1}{\\alpha}$，容差 $\\varepsilon = 10^{-12}$，朴素牛顿法的最大迭代次数 $N_{\\max} = 50$，阻尼牛顿法的最大迭代次数 $N_{\\max} = 500$。\n  - 计算两个量：\n    1. 一个布尔值（编码为整数1表示真，0表示假），指示朴素牛顿求解器是否在 $N_{\\max}$ 次迭代内收敛到 $\\lvert x_n - x^\\* \\rvert \\leq \\varepsilon$。\n    2. 阻尼牛顿求解器达到 $\\lvert x_n - x^\\* \\rvert \\leq \\varepsilon$ 所需的整数迭代次数。\n\n- 案例 C（根点附近斜率极其平坦，导致无阻尼步长过大）：\n  - 函数：$f_3(x) = \\arctan(\\alpha x)$，导数 $f_3'(x) = \\frac{\\alpha}{1 + \\alpha^2 x^2}$，根 $x^\\* = 0$。\n  - 角度单位：$\\arctan(\\cdot)$ 的输出以弧度为单位。\n  - 参数：$\\alpha = 10^{-4}$，初始猜测值 $x_0 = \\frac{10}{\\alpha}$，容差 $\\varepsilon = 10^{-12}$，朴素牛顿法的最大迭代次数 $N_{\\max} = 50$，阻尼牛顿法的最大迭代次数 $N_{\\max} = 2000$。\n  - 计算两个量：\n    1. 一个布尔值（编码为整数1表示真，0表示假），指示朴素牛顿求解器是否在 $N_{\\max}$ 次迭代内收敛到 $\\lvert x_n - x^\\* \\rvert \\leq \\varepsilon$。\n    2. 阻尼牛顿求解器达到 $\\lvert x_n - x^\\* \\rvert \\leq \\varepsilon$ 所需的整数迭代次数。\n\n科学真实性要求：\n- 所有计算必须使用实数，反正切函数 $\\arctan$ 返回以弧度为单位的值。\n- 在朴素牛顿求解器中，检测并将非有限迭代值（例如，非数值或无穷大）视为不收敛。\n\n最终输出规范：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果严格按以下顺序排列：\n  - $[$案例 A 朴素法迭代次数, 案例 A 步长缩放法迭代次数, 案例 B 朴素法是否收敛的布尔值, 案例 B 阻尼法迭代次数, 案例 C 朴素法是否收敛的布尔值, 案例 C 阻尼法迭代次数$]$。\n- 每个条目必须是整数。",
            "solution": "用户提供的问题陈述已被评估并确定为有效。它在科学上基于数值分析的原理，特别是非线性求根算法。该问题是适定的，提供了所有必要的函数、参数和终止准则，以产生一组唯一且可验证的结果。其语言客观、正式。问题结构旨在探索牛顿法的已知失效模式以及标准修正技术（步长缩放和阻尼）的有效性，这是计算科学中一个经典且重要的话题。\n\n问题的核心是用于寻找函数 $f(x)$ 的根 $x^\\*$（其中 $f(x^\\*) = 0$）的牛顿法。该方法是一个基于以下更新规则的迭代过程：\n$$x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}$$\n此公式源于求解 $f(x)$ 在 $x_n$ 附近的一阶泰勒展开式的根，这在几何上对应于找到曲线在点 $(x_n, f(x_n))$ 处切线的x轴截距。\n\n牛顿法的收敛行为关键取决于 $f(x)$ 在根 $x^\\*$ 附近的性质。对于单根，其中 $f'(x^\\*) \\neq 0$，该方法表现出二次收敛，意味着只要初始猜测值 $x_0$ 足够接近 $x^\\*$，每次迭代的正确小数位数大约会翻倍。然而，在以下两种本问题所探讨的条件下，其性能会下降：重根和导数值小的区域（平坦区域）。\n\n**1. 朴素牛顿法与缩放牛顿法对重根的分析（案例 A）**\n\n在案例 A 中，函数为 $f_1(x) = (x - 0.5)^2$。根是 $x^\\* = 0.5$，重数为 $m=2$，因为函数及其导数 $f_1'(x) = 2(x - 0.5)$ 在 $x^\\*$ 处均为零。\n\n- **朴素牛顿求解器**：迭代公式为：\n$$x_{n+1} = x_n - \\frac{(x_n - 0.5)^2}{2(x_n - 0.5)} = x_n - \\frac{1}{2}(x_n - 0.5)$$\n设第 $n$ 步的误差为 $e_n = x_n - x^\\* = x_n - 0.5$。误差的更新规则变为：\n$$x_{n+1} - 0.5 = (x_n - 0.5) - \\frac{1}{2}(x_n - 0.5)$$\n$$e_{n+1} = \\frac{1}{2} e_n$$\n这表明误差在每一步仅减半，这是线性收敛的特征，收敛率为 $C = \\frac{m-1}{m} = \\frac{2-1}{2} = 0.5$。这比在单根情况下看到的二次收敛要慢得多。\n\n- **重数缩放的牛顿求解器**：通过使用已知的重数 $m=2$ 来修正步长，更新规则变为：\n$$x_{n+1} = x_n - m \\frac{f(x_n)}{f'(x_n)} = x_n - 2 \\frac{(x_n - 0.5)^2}{2(x_n - 0.5)} = x_n - (x_n - 0.5) = 0.5$$\n该方法在一次迭代中就精确收敛到根 $x^\\* = 0.5$，无论初始猜测值 $x_0$ 是什么（只要 $x_0 \\neq x^\\*$）。这种修正有效地恢复了二次收敛。\n\n**2. 朴素牛顿法与阻尼牛顿法对近乎平坦区域的分析（案例 B 和案例 C）**\n\n在案例 B 和 C 中，函数是 $f(x) = \\arctan(\\alpha x)$，它在 $x^\\* = 0$ 处有一个单根。导数是 $f'(x) = \\frac{\\alpha}{1 + (\\alpha x)^2}$。在根点， $f'(0) = \\alpha$。对于给定的较小 $\\alpha$ 值（$10^{-3}$ 和 $10^{-4}$），导数在根附近非常小，形成了一个近乎平坦的区域。\n\n- **朴素牛顿求解器**：更新步长为 $\\Delta = -\\frac{f(x_n)}{f'(x_n)} = -\\frac{\\arctan(\\alpha x_n)(1 + (\\alpha x_n)^2)}{\\alpha}$。\n当迭代值 $x_n$ 远离根点，使得 $|\\alpha x_n| \\gg 1$ 时，项 $\\arctan(\\alpha x_n)$ 接近其渐近值 $\\pm \\frac{\\pi}{2}$。步长近似变为：\n$$\\Delta \\approx -\\frac{(\\pm \\frac{\\pi}{2})(1 + (\\alpha x_n)^2)}{\\alpha}$$\n分子中的 $(\\alpha x_n)^2$ 项导致步长 $|\\Delta|$ 变得极大。对于初始猜测值 $x_0 = c/\\alpha$，这会导致一个巨大的第一步，完全过冲根所在的区域。\n  - 在案例 B 中，$x_0 = 1/\\alpha$，所以 $\\alpha x_0 = 1$。第一步很大，但不会导致立即发散；相反，它导致在根附近振荡，未能在迭代次数限制内收敛。\n  - 在案例 C 中，$x_0 = 10/\\alpha$，所以 $\\alpha x_0 = 10$。第一步非常大，以至于下一个迭代值 $|x_1|$ 的量级远大于 $|x_0|$。这是发散的迹象。\n\n- **带回溯的阻尼牛顿求解器**：此方法缓解了过冲问题。它首先计算完整的、可能非常大的牛顿步长 $\\Delta$。然后引入一个缩放因子 $\\lambda \\in (0, 1]$，将新的迭代值设为 $x_{n+1} = x_n + \\lambda \\Delta$。关键在于线搜索策略：$\\lambda$ 初始化为 $1$，并反复减半，直到满足条件 $|f(x_n + \\lambda \\Delta)|  |f(x_n)|$。这个条件是 Armijo-Goldstein 条件的简化形式，它通过减小函数的绝对值（一个价值函数）来确保每一步都取得进展。通过系统地减小步长，阻尼法避免了朴素法的无控制跳跃，并强制收敛，尽管如果 $\\lambda$ 必须变得非常小，可能需要很多次迭代。这种“挽救”机制使得阻尼法对于具有平坦区域或从远离根点开始的函数更加鲁棒。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs numerical solvers for three root-finding test cases.\n    \"\"\"\n\n    # --- Solver Implementations ---\n\n    def newton_naive(f, df, x0, x_star, tol, max_iter):\n        \"\"\"\n        Naive Newton's method.\n        Returns the number of iterations to converge, or max_iter + 1 on failure.\n        \"\"\"\n        x = float(x0)\n        \n        # Check if starting point is already at the root\n        if abs(x - x_star) = tol:\n            return 0\n\n        for i in range(1, max_iter + 1):\n            f_x = f(x)\n            df_x = df(x)\n\n            # Handle division by zero or very small derivative\n            if abs(df_x)  1e-20:\n                return max_iter + 1\n\n            step = f_x / df_x\n            x_new = x - step\n\n            # Handle non-finite results (divergence)\n            if not np.isfinite(x_new):\n                return max_iter + 1\n            \n            x = x_new\n            \n            if abs(x - x_star) = tol:\n                return i\n        \n        return max_iter + 1\n\n    def newton_scaled(f, df, x0, x_star, m, tol, max_iter):\n        \"\"\"\n        Newton's method with step scaling for known root multiplicity m.\n        Returns the number of iterations to converge, or max_iter + 1 on failure.\n        \"\"\"\n        x = float(x0)\n\n        if abs(x - x_star) = tol:\n            return 0\n\n        for i in range(1, max_iter + 1):\n            f_x = f(x)\n            df_x = df(x)\n\n            if abs(df_x)  1e-20:\n                return max_iter + 1\n            \n            step = m * f_x / df_x\n            x = x - step\n\n            if abs(x - x_star) = tol:\n                return i\n        \n        return max_iter + 1\n\n    def newton_damped(f, df, x0, x_star, tol, max_iter):\n        \"\"\"\n        Damped Newton's method with backtracking line search.\n        Returns the number of iterations to converge, or max_iter + 1 on failure.\n        \"\"\"\n        x = float(x0)\n\n        if abs(x - x_star) = tol:\n            return 0\n\n        for i in range(1, max_iter + 1):\n            f_x = f(x)\n            df_x = df(x)\n\n            if abs(df_x)  1e-20:\n                return max_iter + 1\n            \n            delta = -f_x / df_x\n            \n            lambd = 1.0\n            abs_f_x = abs(f_x)\n\n            # Backtracking line search\n            # Keep halving lambda until the step reduces the function's absolute value\n            while abs(f(x + lambd * delta)) >= abs_f_x:\n                lambd /= 2.0\n                # Failsafe for an overly restrictive search\n                if lambd  1e-15:\n                    return max_iter + 1\n\n            x = x + lambd * delta\n\n            if abs(x - x_star) = tol:\n                return i\n        \n        return max_iter + 1\n\n    # --- Problem Definitions  Execution ---\n\n    results = []\n\n    # Case A: Multiple root f(x) = (x - 0.5)^2\n    f1 = lambda x: (x - 0.5)**2\n    df1 = lambda x: 2 * (x - 0.5)\n    x_star1 = 0.5\n    x0_A = 2.0\n    tol_A = 1e-12\n    n_max_A = 200\n\n    iters_A_naive = newton_naive(f1, df1, x0_A, x_star1, tol_A, n_max_A)\n    results.append(iters_A_naive)\n    \n    iters_A_scaled = newton_scaled(f1, df1, x0_A, x_star1, 2, tol_A, n_max_A)\n    results.append(iters_A_scaled)\n\n\n    # Case B: Near-flat slope, f(x) = arctan(alpha*x)\n    alpha_B = 1e-3\n    f2 = lambda x: np.arctan(alpha_B * x)\n    df2 = lambda x: alpha_B / (1 + (alpha_B * x)**2)\n    x_star2 = 0.0\n    x0_B = 1.0 / alpha_B\n    tol_B = 1e-12\n    n_max_B_naive = 50\n    n_max_B_damped = 500\n\n    iters_B_naive = newton_naive(f2, df2, x0_B, x_star2, tol_B, n_max_B_naive)\n    converged_B_naive = 1 if iters_B_naive = n_max_B_naive else 0\n    results.append(converged_B_naive)\n\n    iters_B_damped = newton_damped(f2, df2, x0_B, x_star2, tol_B, n_max_B_damped)\n    results.append(iters_B_damped)\n\n\n    # Case C: Extremely flat slope, f(x) = arctan(alpha*x)\n    alpha_C = 1e-4\n    f3 = lambda x: np.arctan(alpha_C * x)\n    df3 = lambda x: alpha_C / (1 + (alpha_C * x)**2)\n    x_star3 = 0.0\n    x0_C = 10.0 / alpha_C\n    tol_C = 1e-12\n    n_max_C_naive = 50\n    n_max_C_damped = 2000\n\n    iters_C_naive = newton_naive(f3, df3, x0_C, x_star3, tol_C, n_max_C_naive)\n    converged_C_naive = 1 if iters_C_naive = n_max_C_naive else 0\n    results.append(converged_C_naive)\n\n    iters_C_damped = newton_damped(f3, df3, x0_C, x_star3, tol_C, n_max_C_damped)\n    results.append(iters_C_damped)\n\n    # --- Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将数值理论应用于实际问题是计算科学的核心。本练习将一个基础的材料科学问题——晶体中的平衡点缺陷浓度——转化为一个非线性求根任务。你不仅需要实现一个可靠的、能够处理极端物理条件的求解器，更重要的是，你将学习如何利用物理模型在极端温度下的渐近行为来构建“有物理依据”的初始猜测值。这种融合物理直觉与数值算法的策略，对于开发高效且稳定的科学计算程序至关重要。",
            "id": "3486023",
            "problem": "您正在使用一个适用于计算材料科学的最小热力学模型，对晶体固体中理想晶格内的点空位平衡分数进行建模。设在绝对温度 $T$ 下，空位点分数为 $\\phi \\in (0,1)$，空位形成能为 $E_f$。在理想、无相互作用的单组分晶格气体模型中，当空位产生的净驱动力消失时，系统达到平衡。由此产生的平衡可以表述为求解非线性函数的根：\n$$\nR(\\phi; E_f, T) \\equiv \\exp\\!\\left(-\\dfrac{E_f}{k_B T}\\right) - \\dfrac{\\phi}{1-\\phi} = 0,\n$$\n其中 $k_B$ 是玻尔兹曼常数。假设 $E_f  0$，$T  0$，并且该模型应用于理想性假设合理的区域。\n\n您的任务是为 $\\phi$ 实现一个鲁棒的求根求解器，该求解器在广泛的温度范围内（包括 $\\exp(-E_f/(k_B T))$ 变得非常小或非常接近1的极端情况）都应是可靠的。您的设计必须基于以下原则：\n- 从理想晶格气体中平衡的基本定义和玻尔兹曼因子 $\\exp(-E_f/(k_B T))$ 出发。\n- 构建一个尊重物理域 $\\phi \\in (0,1)$ 的全局收敛数值方法。您必须将基于导数的更新（例如，应用于 $R(\\phi)$ 的牛顿法）与一个保护步骤相结合，该步骤保证下一次迭代停留在允许的区间内，并在导数步骤不足够时保证收敛。\n- 在极低温度 $T$（此时 $\\exp(-E_f/(k_B T))$ 极小）和相对于 $E_f$ 的极高温度 $T$（此时 $\\exp(-E_f/(k_B T))$ 接近1）的极限区域，推导平衡的渐近标度。使用这些渐近标度构建有原则的初始猜测值 $\\phi_0(E_f,T)$，以在不违反域约束的情况下加速在极端区域的收敛。\n\n物理和数值单位：\n- $E_f$ 使用电子伏特（eV）。\n- $T$ 使用开尔文（K）。\n- $k_B$ 使用 $8.617333262145\\times 10^{-5}\\ \\mathrm{eV/K}$。\n- 空位分数 $\\phi$ 是无量纲的。将数值结果报告为无量纲的浮点数。\n\n算法要求：\n- 实现一个求解器，该求解器使用 $R(\\phi)$ 及其解析导数的基于导数的迭代，并带有一个保护措施：如果导数步骤会离开区间 $(0,1)$ 或未能减小残差，则退回到一个区间限定的步骤（例如，在维护的区间内进行二分法）。确保该方法对于任何允许的输入 $E_f0$，$T0$ 都是全局收敛的。\n- 基于残差 $\\lvert R(\\phi)\\rvert$ 和/或步长选择停止标准，该标准需足够严格，以在整个测试套件中为 $\\phi$ 提供至少10位有效数字的精度。\n\n测试套件：\n按照以下精确顺序，为以下参数集评估您的求解器：\n1. $(E_f, T) = (0.4\\ \\mathrm{eV}, 3000\\ \\mathrm{K})$，\n2. $(E_f, T) = (1.2\\ \\mathrm{eV}, 300\\ \\mathrm{K})$，\n3. $(E_f, T) = (1.2\\ \\mathrm{eV}, 1200\\ \\mathrm{K})$，\n4. $(E_f, T) = (0.01\\ \\mathrm{eV}, 3000\\ \\mathrm{K})$。\n\n答案规范和输出格式：\n- 对于每种情况，通过求解 $R(\\phi; E_f, T)=0$ 来计算平衡空位分数 $\\phi$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4]”）。每个结果必须是至少有10位有效数字的浮点数。不应打印任何额外的文本或空白字符。",
            "solution": "该问题要求设计并实现一个鲁棒的数值求解器，用于寻找晶体固体中的平衡空位分数 $\\phi$。其控制方程是一个从基本热力学原理推导出的非线性函数。\n\n**1. 问题表述和物理基础**\n\n在恒定温度和压力下，系统的平衡态由其吉布斯自由能 $G$ 的最小值确定。对于一个包含 $N$ 个总晶格点和 $n_v$ 个空位的晶体，其吉布斯自由能模型为 $G(n_v) = n_v E_f - T S_{conf}(n_v)$，其中 $E_f$ 是空位形成能，$T$ 是绝对温度，$S_{conf}$ 是构型熵。构型熵源于排列空位的多种方式，由 $S_{conf} = k_B \\ln W$ 给出，其中 $W = N! / (n_v! (N-n_v)!)$ 且 $k_B$ 是玻尔兹曼常数。\n\n使用对阶乘的斯特林近似（$\\ln z! \\approx z\\ln z - z$）（该近似对于晶体中的大量原子是准确的），单位晶格点的熵 $s_{conf} = S_{conf}/N$ 可以用空位分数 $\\phi = n_v/N$ 表示为：\n$$ s_{conf}(\\phi) \\approx -k_B \\left[ \\phi \\ln \\phi + (1-\\phi) \\ln(1-\\phi) \\right] $$\n于是，单位晶格点的吉布斯自由能为 $g(\\phi) = \\phi E_f + k_B T \\left[ \\phi \\ln \\phi + (1-\\phi) \\ln(1-\\phi) \\right]$。平衡对应于 $g(\\phi)$ 的最小值，通过将其关于 $\\phi$ 的导数设为零来求得：\n$$ \\frac{\\partial g}{\\partial \\phi} = E_f + k_B T \\left( \\ln\\phi + 1 - \\ln(1-\\phi) - 1 \\right) = E_f + k_B T \\ln\\left(\\frac{\\phi}{1-\\phi}\\right) = 0 $$\n重新整理该条件，得到待求解的方程：\n$$ \\frac{\\phi}{1-\\phi} = \\exp\\left(-\\frac{E_f}{k_B T}\\right) $$\n这是一个关于函数 $R(\\phi; E_f, T) = 0$ 的求根问题，其中残差 $R(\\phi)$ 定义为：\n$$ R(\\phi) \\equiv \\exp\\left(-\\frac{E_f}{k_B T}\\right) - \\frac{\\phi}{1-\\phi} = 0 $$\n解必须位于具有物理意义的域 $\\phi \\in (0,1)$ 内。\n\n**2. 解析解**\n\n为了验证，我们注意到该方程可以解析求解。令 $B = \\exp(-E_f/(k_B T))$。方程 $B = \\phi/(1-\\phi)$ 可以重新整理为 $\\phi = B(1-\\phi)$，得到 $\\phi(1+B) = B$。因此，精确解为：\n$$ \\phi = \\frac{B}{1+B} = \\frac{\\exp(-E_f/(k_B T))}{1+\\exp(-E_f/(k_B T))} $$\n由于 $E_f > 0$ 且 $T > 0$，玻尔兹曼因子 $B$ 严格位于区间 $(0, 1)$ 内。因此，$\\phi$ 的精确解总是在区间 $(0, 0.5)$ 内。这个解析结果为我们的数值方法提供了一个完美的基准，尽管核心任务仍然是实现指定的数值求解器。\n\n**3. 数值求解器：带保护的牛顿法**\n\n我们的任务是构建一个既快速又鲁棒的求解器。混合牛顿-二分法是实现此目的的理想选择。它结合了牛顿法在解附近时的快速二次收敛性与二分法保证的全局收敛性。\n\n牛顿法通过迭代 $\\phi_{k+1} = \\phi_k - R(\\phi_k)/R'(\\phi_k)$ 来找到根。我们首先需要 $R(\\phi)$ 的导数：\n$$ R'(\\phi) = \\frac{d}{d\\phi} \\left( B - \\frac{\\phi}{1-\\phi} \\right) = - \\frac{1 \\cdot (1-\\phi) - \\phi \\cdot (-1)}{(1-\\phi)^2} = -\\frac{1}{(1-\\phi)^2} $$\n函数 $R(\\phi)$ 在其定义域上是严格递减的（$R'(\\phi)0$）和凹的（$R''(\\phi)=-2(1-\\phi)^{-3}0$）。这种凹性意味着纯牛顿法可能会越过根，并可能产生物理域 $(0,1)$ 之外的迭代值，因此需要一个保护措施。\n\n我们的保护措施包括维护一个已知根所在的区间 $[\\phi_a, \\phi_b]$，即 $R(\\phi_a) > 0$ 且 $R(\\phi_b)  0$。鉴于解总是在 $(0,0.5)$ 内，初始区间可以设为 $[0, 0.5]$，这可以通过检查端点来验证：$R(0) = B > 0$ 且 $R(0.5) = B-1  0$。\n\n每次迭代的算法如下：\n1.  从当前迭代值 $\\phi_k$ 计算牛顿步长，找到候选解 $\\phi_{newton}$。\n2.  如果 $\\phi_{newton}$ 落在了当前区间 $[\\phi_a, \\phi_b]$ 之外，则拒绝该值。算法退回到二分法步骤，下一个迭代值变为中点 $\\phi_{k+1} = (\\phi_a + \\phi_b)/2$。\n3.  如果 $\\phi_{newton}$ 在区间内，则接受其为下一个迭代值，$\\phi_{k+1} = \\phi_{newton}$。\n4.  通过计算 $R(\\phi_{k+1})$ 的值并用 $\\phi_{k+1}$ 替换 $\\phi_a$ 或 $\\phi_b$ 来更新下一次迭代的区间，以保持符号变化的性质。\n\n此策略确保每一步都在一个缩小的、有保证的区间内向根推进，从而确保全局收敛。\n\n**4. 用于优化初始猜测的渐近分析**\n\n通过使用一个已经接近真实解的初始猜测值 $\\phi_0$ 来开始，可以大大提高求解器的效率。我们通过对极限温度区域（由 $x = E_f/(k_B T)$ 参数化）下解的渐近分析来推导此类猜测值。\n\n*   **低温极限（$T \\to 0$，因此 $x \\to \\infty$）：** 在此区域，$B = e^{-x}$ 非常小。解析解 $\\phi = B/(1+B)$ 可以用其一阶泰勒级数项很好地近似：\n    $$ \\phi \\approx B = \\exp\\left(-\\frac{E_f}{k_B T}\\right) $$\n*   **高温极限（$T \\to \\infty$，因此 $x \\to 0$）：** 在此区域，$B = e^{-x}$ 接近于 1。使用泰勒展开 $e^{-x} \\approx 1 - x$，解析解变为：\n    $$ \\phi = \\frac{e^{-x}}{1+e^{-x}} \\approx \\frac{1-x}{1 + (1-x)} = \\frac{1-x}{2-x} $$\n    展开 $(1-x/2)^{-1} \\approx 1+x/2$，我们发现 $\\phi \\approx \\frac{1}{2}(1-x)(1+x/2) \\approx \\frac{1}{2}(1-x/2) = \\frac{1}{2} - \\frac{x}{4}$。这给出了近似值：\n    $$ \\phi \\approx \\frac{1}{2} - \\frac{E_f}{4k_B T} $$\n\n我们采用一个基于 $x=E_f/(k_B T)$ 的简单转换标准。如果 $x  1$，我们使用低温猜测值。如果 $x \\le 1$，我们使用高温猜测值。这为所有物理条件提供了一个高度精确的起始点，从而最大限度地减少了所需的迭代次数。\n\n**5. 收敛准则**\n\n为了满足至少10位有效数字精度的要求，当残差的绝对值 $|R(\\phi_k)|$ 小于一个严格的容差（设为 $10^{-16}$）时，迭代过程终止。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_vacancy_fraction(Ef, T, tol=1e-16, max_iter=50):\n    \"\"\"\n    Computes the equilibrium vacancy fraction phi using a safeguarded Newton's method.\n\n    Args:\n        Ef (float): Vacancy formation energy in eV.\n        T (float): Absolute temperature in K.\n        tol (float): Convergence tolerance for the residual.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        float: The equilibrium vacancy fraction phi.\n    \"\"\"\n    KB_EV_K = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    if T = 0 or Ef = 0:\n        raise ValueError(\"Temperature and formation energy must be positive.\")\n\n    # Calculate the dimensionless energy term x and the Boltzmann factor B\n    x = Ef / (KB_EV_K * T)\n    \n    # Use np.exp with care for potential underflow\n    B = np.exp(-x) if x  np.log(np.finfo(float).max) else 0.0\n\n    # Define the residual function R(phi) and its derivative R'(phi)\n    # R(phi) = B - phi / (1 - phi)\n    def R(phi):\n        if phi == 1.0:\n            return -np.inf\n        # To avoid catastrophic cancellation when B is close to phi/(1-phi)\n        # we can rewrite R(phi)\n        # return (B * (1 - phi) - phi) / (1 - phi)\n        # However, the direct form is fine for this problem.\n        return B - phi / (1.0 - phi)\n\n    def R_prime(phi):\n        if phi == 1.0:\n            return -np.inf\n        return -1.0 / (1.0 - phi)**2\n\n    # Asymptotic analysis for a principled initial guess\n    if x > 1.0:\n        # Low-temperature regime approximation\n        phi_k = B\n    else:\n        # High-temperature regime approximation\n        phi_k = 0.5 - x / 4.0\n\n    # The analytical solution is always in (0, 0.5), so this is a safe bracket\n    phi_a, phi_b = 0.0, 0.5\n\n    # Check if initial guess is within the bracket; if not, use bisection center\n    if not (phi_a  phi_k  phi_b):\n        phi_k = (phi_a + phi_b) / 2.0\n\n    for _ in range(max_iter):\n        res = R(phi_k)\n\n        # Check for convergence\n        if abs(res)  tol:\n            return phi_k\n\n        # Update the bracket using the sign of the residual\n        if res > 0:\n            phi_a = phi_k\n        else:\n            phi_b = phi_k\n\n        # Newton's method step\n        deriv = R_prime(phi_k)\n        \n        # Avoid division by zero, though unlikely for this function\n        if abs(deriv)  np.finfo(float).eps:\n            phi_next = (phi_a + phi_b) / 2.0\n        else:\n            phi_newton = phi_k - res / deriv\n            # Safeguard: if Newton step is out of bounds, use bisection\n            if phi_newton = phi_a or phi_newton >= phi_b:\n                phi_next = (phi_a + phi_b) / 2.0\n            else:\n                phi_next = phi_newton\n        \n        # Update the iterate\n        if abs(phi_k - phi_next)  tol * abs(phi_k) + tol:\n            # Step size is very small, likely converged\n            return phi_next\n            \n        phi_k = phi_next\n\n    raise RuntimeError(f\"Solver failed to converge for Ef={Ef}, T={T}\")\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.4, 3000.0),  # (Ef in eV, T in K)\n        (1.2, 300.0),\n        (1.2, 1200.0),\n        (0.01, 3000.0)\n    ]\n\n    results = []\n    for Ef_case, T_case in test_cases:\n        # Calculate the equilibrium vacancy fraction for the case\n        phi_eq = solve_vacancy_fraction(Ef_case, T_case)\n        # Format result to ensure sufficient precision\n        results.append(f\"{phi_eq:.15g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在解决了单变量问题后，我们将挑战升级到多维非凸系统，这在现代计算力学中极为常见。本练习要求你求解一个非线性弹性储能泛函的驻点，这需要你运用矩阵微积分来推导控制方程组。通过实现一个带有线搜索的牛顿求解器，你不仅能找到解，还将绘制出不同平衡态（如平凡解与有物理意义的形变）的吸引盆，从而深入理解材料在复杂载荷下的多重稳定行为和路径依赖性。",
            "id": "3486017",
            "problem": "考虑一个二维材料在有限变形下的弹性势能密度，其表达式为 $W(F) = \\mu \\|F\\|_F^2 + \\lambda (\\det F - 1)^2$，其中 $F \\in \\mathbb{R}^{2 \\times 2}$ 是变形梯度，$\\|F\\|_F$ 是弗罗贝尼乌斯范数，$\\det F$ 是行列式，$\\mu  0$ 和 $\\lambda  0$ 是材料常数。该能量的驻点满足非线性矩阵方程 $\\nabla_F W(F) = 0$。通过将矩阵 $F$ 展开为其元素构成的向量，该问题可被视为一个在 $\\mathbb{R}^4$ 空间中的求根问题。您的任务如下：\n\n- 从基础微积分事实出发，即行列式的导数满足 $\\frac{\\partial \\det(F)}{\\partial F_{ij}} = \\operatorname{Cof}(F)_{ij}$（其中 $\\operatorname{Cof}(F)$ 是代数余子式矩阵），并且一个复合了矩阵变量的标量场的梯度可以逐元素计算，推导当 $F = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$ 时，梯度 $\\nabla_F W(F)$ 的表达式，以及与非线性系统 $\\nabla_F W(F) = 0$ 相关联的雅可比矩阵。请勿使用或假定任何预先推导的简化公式：从弗罗贝尼乌斯范数、行列式和代数余子式的定义出发进行推导。\n\n- 设计并实现一个牛顿迭代法来求解四维非线性系统 $\\nabla_F W(F) = 0$，使用基于残差范数的评价函数和 Armijo 回溯线搜索来提高稳健性。明确地实现一个回溯线搜索，以确保评价函数有充分的下降。通过对收敛的驻点进行分类来绘制吸引盆。使用以下分类方法：如果迭代收敛到平凡驻点（数值上其特征为 $\\|F\\|_F \\leq \\varepsilon$，其中 $\\varepsilon$ 是一个很小的容差），则返回 $0$；如果迭代收敛到缩放旋转流形（数值上其特征为 $F \\approx \\operatorname{Cof}(F)$ 和 $\\det F \\approx r^\\star$，其中 $r^\\star := 1 - \\mu/\\lambda$），则返回 $1$；否则返回 $2$。应通过沿秩一方向 $u \\otimes v$ 初始化并观察迭代收敛到哪个吸引盆来探测秩一连通性的存在。\n\n- 对每个测试用例，使用不带线搜索的标准牛顿法进行第二次运行，以揭示在非凸能量形貌上的潜在失效模式。报告标准方法是否收敛（布尔值）。\n\n使用材料参数 $\\mu = 0.5$ 和 $\\lambda = 1.0$。角度必须以弧度表示。构建以下初始变形梯度测试集：\n1. 在缩放旋转流形附近的一个扰动，其中 $a = \\sqrt{1 - \\mu/\\lambda}$：$F_1 = \\begin{pmatrix} a  10^{-4} \\\\ -10^{-4}  a \\end{pmatrix}$，此处 $a = \\sqrt{0.5}$。\n2. 精确位于零角度的缩放旋转流形上：$F_2 = \\begin{pmatrix} a  0 \\\\ 0  a \\end{pmatrix}$，其中 $a = \\sqrt{0.5}$。\n3. 一个小振幅的秩一开始：$F_3 = u \\otimes v$，其中 $u = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$，$v = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$，并缩放 $10^{-3}$，即 $F_3 = \\begin{pmatrix} 0  10^{-3} \\\\ 0  0 \\end{pmatrix}$。\n4. 一个中等振幅的秩一开始：$F_4 = \\alpha \\, u \\otimes v$，其中 $\\alpha = 0.2$，$u = \\begin{pmatrix} \\cos(\\pi/4) \\\\ \\sin(\\pi/4) \\end{pmatrix}$，$v = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$，即 $F_4 = \\begin{pmatrix} 0.14142136  0 \\\\ 0.14142136  0 \\end{pmatrix}$。\n5. 一个具有负行列式的远场初始点：$F_5 = \\begin{pmatrix} -1.5  0.7 \\\\ 0.9  -0.1 \\end{pmatrix}$。\n\n对每个测试用例，运行两种求解器（标准牛顿法和带回溯线搜索的牛顿法），并为该测试用例生成包含三个值的列表作为最终结果：\n- 一个布尔值，指示标准牛顿法是否在容差范围内收敛，\n- 使用回溯线搜索时，收敛解的整数分类（如上定义的 $0$、$1$ 或 $2$），\n- 一个浮点数，给出线搜索运行的最终残差范数（$\\nabla_F W(F)$ 的欧几里得范数），四舍五入到六位小数。\n\n您的程序应生成单行输出，其中包含五个测试用例的结果。结果格式为一个逗号分隔的列表，列表中的每个元素是包含三个条目的子列表，并用方括号括起来（例如，“[[true_or_false,classification,residual],...]”，其中残差表示为十进制数）。不涉及物理单位；角度必须按规定以弧度为单位。",
            "solution": "该问题要求推导给定弹性势能密度驻点的控制方程，并实现一个数值求解器来找到这些点。我们将首先验证问题的有效性，然后给出所需的解析推导，最后详细说明数值算法。\n\n该问题被认为是有效的。它在科学上基于非线性连续介质力学的原理，特别是关于超弹性材料模型。能量泛函 $W(F) = \\mu \\|F\\|_F^2 + \\lambda (\\det F - 1)^2$ 是在 $2 \\times 2$ 矩阵空间上一个定义良好且可微的函数，它代表了一个简单的模型，该模型同时惩罚偏离刚性（通过弗罗贝尼乌斯范数项）和体积变化（通过行列式项）。寻找驻点 $\\nabla_F W(F) = 0$ 的任务是计算力学中的一个标准问题，可通过求根算法解决。该问题是适定的，为数值研究提供了所有必要的定义、材料参数和初始条件。它是客观且无歧义的。\n\n### 1. 梯度和雅可比矩阵的推导\n\n设变形梯度表示为 $F \\in \\mathbb{R}^{2 \\times 2}$，其分量为：\n$$\nF = \\begin{pmatrix} F_{11}  F_{12} \\\\ F_{21}  F_{22} \\end{pmatrix} = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}\n$$\n弹性势能密度由下式给出：\n$$\nW(F) = \\mu \\|F\\|_F^2 + \\lambda (\\det F - 1)^2\n$$\n其中 $\\mu > 0$ 和 $\\lambda > 0$ 是材料常数。\n\n用分量 $\\{a, b, c, d\\}$ 表示，弗罗贝尼乌斯范数的平方为 $\\|F\\|_F^2 = a^2 + b^2 + c^2 + d^2$，行列式为 $\\det F = ad - bc$。能量函数可写为：\n$$\nW(a,b,c,d) = \\mu (a^2 + b^2 + c^2 + d^2) + \\lambda (ad - bc - 1)^2\n$$\n$W$ 的驻点位于其相对于 $F$ 的梯度为零之处。梯度 $\\nabla_F W(F)$ 是一个 $2 \\times 2$ 矩阵，其 $(i,j)$ 元为 $\\frac{\\partial W}{\\partial F_{ij}}$。\n\n我们应用链式法则计算梯度。第一项的梯度为：\n$$\n\\nabla_F (\\mu \\|F\\|_F^2) = \\nabla_F \\left(\\mu \\sum_{i,j=1}^2 F_{ij}^2\\right) = 2\\mu F\n$$\n对于第二项，我们使用给定的法则 $\\frac{\\partial \\det(F)}{\\partial F_{ij}} = \\operatorname{Cof}(F)_{ij}$。$F$ 的代数余子式矩阵为：\n$$\n\\operatorname{Cof}(F) = \\begin{pmatrix} d  -c \\\\ -b  a \\end{pmatrix}\n$$\n第二项的梯度为：\n$$\n\\nabla_F (\\lambda(\\det F - 1)^2) = 2\\lambda(\\det F - 1) \\nabla_F(\\det F) = 2\\lambda(\\det F - 1) \\operatorname{Cof}(F)\n$$\n综合以上两项，能量函数的完整梯度为：\n$$\n\\nabla_F W(F) = 2\\mu F + 2\\lambda(\\det F - 1) \\operatorname{Cof}(F)\n$$\n需要求解的非线性方程是 $\\nabla_F W(F) = 0$。我们定义残差函数 $G(F) = \\nabla_F W(F)$。为了实现数值求解器，我们将矩阵 $F$ 展开成一个向量 $x = (a, b, c, d)^T \\in \\mathbb{R}^4$。矩阵方程 $G(F)=0$ 变为向量方程 $g(x)=0$，其中 $g(x)$ 是 $G(F)$ 的展开形式。\n代入 $F$ 和 $\\operatorname{Cof}(F)$ 的分量表达式，我们得到：\n$$\ng(x) = \\begin{pmatrix} g_1 \\\\ g_2 \\\\ g_3 \\\\ g_4 \\end{pmatrix} = \\begin{pmatrix}\n2\\mu a + 2\\lambda(ad-bc-1)d \\\\\n2\\mu b + 2\\lambda(ad-bc-1)(-c) \\\\\n2\\mu c + 2\\lambda(ad-bc-1)(-b) \\\\\n2\\mu d + 2\\lambda(ad-bc-1)a\n\\end{pmatrix} = \\begin{pmatrix}\n2\\mu a + 2\\lambda(ad-bc-1)d \\\\\n2\\mu b - 2\\lambda(ad-bc-1)c \\\\\n2\\mu c - 2\\lambda(ad-bc-1)b \\\\\n2\\mu d + 2\\lambda(ad-bc-1)a\n\\end{pmatrix}\n$$\n该系统的雅可比矩阵 $J_g(x)$ 是一个 $4 \\times 4$ 的偏导数矩阵，$J_{ij} = \\frac{\\partial g_i}{\\partial x_j}$，其中 $x = (x_1, x_2, x_3, x_4)^T = (a, b, c, d)^T$。\n由于残差函数 $g(x)$ 是标量势能 $W(x)$ 的梯度，雅可比矩阵 $J_g(x)$ 实际上是 $W(x)$ 的黑塞矩阵，因此它必须是对称的。完整的雅可比矩阵为：\n$$\nJ_g(x) = \\begin{pmatrix}\n2\\mu + 2\\lambda d^2   -2\\lambda cd   -2\\lambda bd   2\\lambda(2ad-bc-1) \\\\\n-2\\lambda cd   2\\mu + 2\\lambda c^2   -2\\lambda(ad-2bc-1)   -2\\lambda ac \\\\\n-2\\lambda bd   -2\\lambda(ad-2bc-1)   2\\mu + 2\\lambda b^2   -2\\lambda ab \\\\\n2\\lambda(2ad-bc-1)   -2\\lambda ac   -2\\lambda ab   2\\mu + 2\\lambda a^2\n\\end{pmatrix}\n$$\n\n### 2. 带回溯线搜索的牛顿法\n\n为了求解非线性系统 $g(x) = 0$，我们采用牛顿法。给定一个迭代点 $x_k$，下一个迭代点 $x_{k+1}$ 通过求解线性化系统得到步长 $\\Delta x_k$：\n$$\nJ_g(x_k) \\Delta x_k = -g(x_k)\n$$\n一个标准的牛顿更新是 $x_{k+1} = x_k + \\Delta x_k$。然而，对于像本问题这样的非凸能量形貌，迭代点很容易被送到局部二次近似很差的区域，从而导致发散。为了使该方法全局化并提高稳健性，我们引入一个步长因子 $\\alpha_k \\in (0, 1]$，更新方式为 $x_{k+1} = x_k + \\alpha_k \\Delta x_k$。\n\n步长 $\\alpha_k$ 由回溯线搜索确定，以确保评价函数有充分的下降。一个合适的评价函数是 $m(x) = \\frac{1}{2}\\|g(x)\\|_2^2$。牛顿步长 $\\Delta x_k$ 是此函数的下降方向。我们寻找满足 Armijo 条件的 $\\alpha_k$：\n$$\nm(x_k + \\alpha_k \\Delta x_k) \\leq m(x_k) + c_1 \\alpha_k \\nabla m(x_k)^T \\Delta x_k\n$$\n其中 $c_1$ 是一个很小的常数，通常为 $10^{-4}$。注意到 $\\nabla m(x_k)^T \\Delta x_k = g(x_k)^T J_g(x_k) \\Delta x_k = -g(x_k)^T g(x_k) = -\\|g(x_k)\\|_2^2$，该条件变为：\n$$\n\\frac{1}{2}\\|g(x_k + \\alpha_k \\Delta x_k)\\|_2^2 \\leq \\frac{1}{2}\\|g(x_k)\\|_2^2 - c_1 \\alpha_k \\|g(x_k)\\|_2^2\n$$\n线搜索算法从 $\\alpha_k=1$ 开始，并用一个回溯因子 $\\tau \\in (0, 1)$（例如 $\\tau=0.5$）重复乘以它，直到满足此条件。\n\n### 3. 驻点的分类\n\n一旦迭代收敛到解 $F_c$，我们对其进行分类。\n- **类别 0 (平凡解):** 零矩阵 $F=0$ 是一个驻点，因为 $G(0) = 2\\mu(0) + 2\\lambda(0-1)\\operatorname{Cof}(0) = 0$。在数值上，如果 $\\|F_c\\|_F \\leq \\varepsilon$（其中 $\\varepsilon$ 是一个很小的容差），我们将解分类为平凡解。\n- **类别 1 (缩放旋转流形):** 此类别代表具有物理意义的非退化解。从驻点条件 $G(F)=0$ 可得 $F = -\\frac{\\lambda}{\\mu}(\\det F - 1)\\operatorname{Cof}(F)$。一类关键解满足 $F = k \\, \\operatorname{Cof}(F)$。如果 $k=1$，则 $F=\\operatorname{Cof}(F)$，这是一个矩阵成为缩放旋转矩阵的条件（即 $F_{11}=F_{22}$ 和 $F_{12}=-F_{21}$）。将 $F=\\operatorname{Cof}(F)$ 代入驻点条件得到 $F = -\\frac{\\lambda}{\\mu}(\\det F - 1)F$，对于 $F \\neq 0$ 这意味着 $1 = -\\frac{\\lambda}{\\mu}(\\det F - 1)$，即 $\\det F = 1 - \\mu/\\lambda$。对于给定的参数 $\\mu=0.5, \\lambda=1.0$，这给出 $\\det F = 0.5$。在数值上，如果一个解同时满足 $\\|F_c - \\operatorname{Cof}(F_c)\\|_F \\leq \\varepsilon_{approx}$ 和 $|\\det F_c - (1-\\mu/\\lambda)| \\leq \\varepsilon_{approx}$，我们将其分类为类别 1。\n- **类别 2 (其他):** 任何不属于类别 0 或类别 1 的收敛解。这可能包括能量泛函的其他驻点或鞍点。\n\n这个框架不仅使我们能够找到解，还能表征不同类型稳态的吸引盆，这对于理解材料的力学行为至关重要。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for stationary points of an elastic energy functional using Newton's method\n    and classifies the basins of attraction.\n    \"\"\"\n    mu = 0.5\n    lmbda = 1.0\n\n    # Define test cases\n    a_sqrt_half = np.sqrt(0.5)\n    test_cases = [\n        np.array([[a_sqrt_half, 1e-4], [-1e-4, a_sqrt_half]]),\n        np.array([[a_sqrt_half, 0.0], [0.0, a_sqrt_half]]),\n        np.array([[0.0, 1e-3], [0.0, 0.0]]),\n        np.array([[0.14142136, 0.0], [0.14142136, 0.0]]),\n        np.array([[-1.5, 0.7], [0.9, -0.1]])\n    ]\n\n    results = []\n    for F_initial in test_cases:\n        x_initial = F_initial.flatten()\n\n        # Run plain Newton's method\n        plain_converged, _ = newton_solver(x_initial, mu, lmbda, use_line_search=False)\n\n        # Run Newton's method with backtracking line search\n        line_search_converged, x_final = newton_solver(x_initial, mu, lmbda, use_line_search=True)\n        \n        F_final = x_final.reshape((2, 2))\n        final_residual_norm = np.linalg.norm(residual_g(x_final, mu, lmbda))\n\n        # Classify the solution from the line search run\n        classification = classify_solution(F_final, mu, lmbda)\n        \n        # Round the residual as required\n        rounded_residual = round(final_residual_norm, 6)\n\n        results.append([plain_converged, classification, rounded_residual])\n\n    # Format and print the final output\n    # Using a custom formatter to avoid trailing zeros for integers\n    def format_item(item):\n        if isinstance(item, bool):\n            return str(item).lower()\n        if isinstance(item, int):\n            return str(item)\n        if isinstance(item, float):\n            return f\"{item:.6f}\"\n        return str(item)\n\n    result_str = \"[\" + \",\".join(\n        \"[\" + \",\".join(map(format_item, r)) + \"]\" for r in results\n    ) + \"]\"\n    print(result_str)\n\ndef residual_g(x, mu, lmbda):\n    \"\"\"Computes the residual vector g(x).\"\"\"\n    a, b, c, d = x\n    det_F = a * d - b * c\n    S = det_F - 1\n    g = np.zeros(4)\n    g[0] = 2 * mu * a + 2 * lmbda * S * d\n    g[1] = 2 * mu * b - 2 * lmbda * S * c\n    g[2] = 2 * mu * c - 2 * lmbda * S * b\n    g[3] = 2 * mu * d + 2 * lmbda * S * a\n    return g\n\ndef jacobian_J(x, mu, lmbda):\n    \"\"\"Computes the Jacobian matrix J(x).\"\"\"\n    a, b, c, d = x\n    J = np.zeros((4, 4))\n    \n    # Row 1\n    J[0, 0] = 2 * mu + 2 * lmbda * d**2\n    J[0, 1] = -2 * lmbda * c * d\n    J[0, 2] = -2 * lmbda * b * d\n    J[0, 3] = 2 * lmbda * (2 * a * d - b * c - 1)\n    \n    # Row 2\n    J[1, 0] = -2 * lmbda * c * d\n    J[1, 1] = 2 * mu + 2 * lmbda * c**2\n    J[1, 2] = -2 * lmbda * (a * d - 2 * b * c - 1)\n    J[1, 3] = -2 * lmbda * a * c\n    \n    # Row 3\n    J[2, 0] = -2 * lmbda * b * d\n    J[2, 1] = -2 * lmbda * (a * d - 2 * b * c - 1)\n    J[2, 2] = 2 * mu + 2 * lmbda * b**2\n    J[2, 3] = -2 * lmbda * a * b\n    \n    # Row 4\n    J[3, 0] = 2 * lmbda * (2 * a * d - b * c - 1)\n    J[3, 1] = -2 * lmbda * a * c\n    J[3, 2] = -2 * lmbda * a * b\n    J[3, 3] = 2 * mu + 2 * lmbda * a**2\n    \n    return J\n\ndef newton_solver(x0, mu, lmbda, use_line_search=True, max_iter=100, tol=1e-8, c1=1e-4, tau=0.5):\n    \"\"\"\n    Newton's method solver, with optional backtracking line search.\n    \"\"\"\n    x = np.copy(x0)\n    for _ in range(max_iter):\n        g = residual_g(x, mu, lmbda)\n        if np.linalg.norm(g)  tol:\n            return True, x\n        \n        J = jacobian_J(x, mu, lmbda)\n        \n        try:\n            delta_x = np.linalg.solve(J, -g)\n        except np.linalg.LinAlgError:\n            # Singular Jacobian\n            return False, x\n\n        if use_line_search:\n            alpha = 1.0\n            g_norm_sq = np.dot(g, g)\n            # Armijo condition check\n            while True:\n                x_new = x + alpha * delta_x\n                g_new = residual_g(x_new, mu, lmbda)\n                g_new_norm_sq = np.dot(g_new, g_new)\n                if g_new_norm_sq = g_norm_sq - 2 * c1 * alpha * g_norm_sq:\n                    break\n                alpha *= tau\n                if alpha  1e-8: # Prevent infinite loop\n                    return False, x\n            x += alpha * delta_x\n        else: # Plain Newton\n            x += delta_x\n        \n        # Check for divergence in plain Newton mode for stability\n        if not use_line_search and np.linalg.norm(x) > 1e10:\n             return False, x\n\n    # Check for convergence after max_iter\n    g_final = residual_g(x, mu, lmbda)\n    converged = np.linalg.norm(g_final)  tol\n    return converged, x\n\ndef classify_solution(F, mu, lmbda, tol_trivial=1e-6, tol_approx=1e-6):\n    \"\"\"\n    - 0: trivial stationary point\n    - 1: scaled-rotation manifold\n    - 2: other\n    \"\"\"\n    # Class 0: Trivial solution\n    if np.linalg.norm(F, 'fro') = tol_trivial:\n        return 0\n\n    # Class 1: Scaled-rotation manifold\n    a, b, c, d = F.flatten()\n    Cof_F = np.array([[d, -c], [-b, a]])\n    \n    det_F = a * d - b * c\n    r_star = 1.0 - mu / lmbda\n    \n    is_cof_match = np.linalg.norm(F - Cof_F, 'fro') = tol_approx\n    is_det_match = abs(det_F - r_star) = tol_approx\n    \n    if is_cof_match and is_det_match:\n        return 1\n\n    # Class 2: Other\n    return 2\n\nsolve()\n```"
        }
    ]
}