{
    "hands_on_practices": [
        {
            "introduction": "在计算材料科学中，精确计算物理量的空间导数是模拟扩散、通量和力的基础。虽然简单的差分公式广为人知，但高保真模拟通常需要更高阶的格式来最小化数值误差。本练习将引导你从第一性原理（即泰勒级数展开）出发，推导一个四阶中心差分公式 ，为你理解和构建高级数值方法奠定坚实的理论基础。",
            "id": "3471358",
            "problem": "在计算材料科学关于微观结构演化的一维相场模拟中，守恒序参量场 $u(x)$ 定义在一个间距为 $h$ 的均匀网格上。为了计算保证质量守恒并最小化数值色散的扩散通量，需要精确计算空间导数 $u'(x)$。从点 $x$ 处的泰勒级数定义出发，推导一个仅使用 $u(x-2h)$、$u(x-h)$、$u(x+h)$ 和 $u(x+2h)$ 这些值的四阶精度中心差分格式，用于逼近 $u'(x)$。显式计算该格式的主截断误差项，用 $u^{(5)}(x)$ 和 $h$ 表示。将最终结果表示为符号解析表达式。最终答案无需进行数值四舍五入，也无需物理单位，因为表达式相对于所涉及的变量是无量纲的。",
            "solution": "所述问题是有效的。这是一个定义明确的数学推导任务，其基础是科学计算（如计算材料科学）中应用的数值分析标准原理。术语精确，目标清晰且可实现。所有必要信息均已提供。\n\n我们的任务是使用点 $x-2h$、$x-h$、$x+h$ 和 $x+2h$ 处的函数值，推导一阶导数 $u'(x)$ 的一个四阶精度中心差分格式。我们还必须找到截断误差的主项。\n\n令 $u'(x)$ 的近似值为 $D_h[u](x)$。我们寻求给定函数值的线性组合：\n$$\nD_h[u](x) = A u(x-2h) + B u(x-h) + C u(x+h) + D u(x+2h)\n$$\n问题指定了中心差分格式，这意味着对称性。对于一阶导数的近似，这种对称性表现为系数的反对称性：$D = -A$ 和 $C = -B$。该格式不使用点 $u(x)$，此公式满足该条件。\n\n为了确定系数 $A$、$B$、$C$ 和 $D$，我们将每一项 $u(x+kh)$ 在点 $x$ 附近展开为泰勒级数。我们要求最终表达式能以 $\\mathcal{O}(h^4)$ 阶的截断误差逼近 $u'(x)$。我们展开到五阶导数以找到主误差项。\n\n泰勒级数展开式为：\n$$\nu(x+h) = u(x) + h u'(x) + \\frac{h^2}{2!} u''(x) + \\frac{h^3}{3!} u'''(x) + \\frac{h^4}{4!} u^{(4)}(x) + \\frac{h^5}{5!} u^{(5)}(x) + \\mathcal{O}(h^6)\n$$\n$$\nu(x-h) = u(x) - h u'(x) + \\frac{h^2}{2!} u''(x) - \\frac{h^3}{3!} u'''(x) + \\frac{h^4}{4!} u^{(4)}(x) - \\frac{h^5}{5!} u^{(5)}(x) + \\mathcal{O}(h^6)\n$$\n$$\nu(x+2h) = u(x) + (2h) u'(x) + \\frac{(2h)^2}{2!} u''(x) + \\frac{(2h)^3}{3!} u'''(x) + \\frac{(2h)^4}{4!} u^{(4)}(x) + \\frac{(2h)^5}{5!} u^{(5)}(x) + \\mathcal{O}(h^6)\n$$\n$$\nu(x-2h) = u(x) - (2h) u'(x) + \\frac{(2h)^2}{2!} u''(x) - \\frac{(2h)^3}{3!} u'''(x) + \\frac{(2h)^4}{4!} u^{(4)}(x) - \\frac{(2h)^5}{5!} u^{(5)}(x) + \\mathcal{O}(h^6)\n$$\n\n将这些展开式代入 $D_h[u](x)$ 的表达式中，并按 $u(x)$ 的导数对各项进行分组：\n$$\n\\begin{align*}\nD_h[u](x) = u(x)  (A+B+C+D) \\\\\n+ u'(x)  h(-2A-B+C+2D) \\\\\n+ u''(x)  \\frac{h^2}{2}(4A+B+C+4D) \\\\\n+ u'''(x)  \\frac{h^3}{6}(-8A-B+C+8D) \\\\\n+ u^{(4)}(x)  \\frac{h^4}{24}(16A+B+C+16D) \\\\\n+ u^{(5)}(x)  \\frac{h^5}{120}(-32A-B+C+32D) + \\mathcal{O}(h^6)\n\\end{align*}\n$$\n\n为使 $D_h[u](x)$ 成为 $u'(x)$ 的一个相容近似，$u'(x)$ 的系数必须为1，而其他导数（直到所需的精度阶）的系数必须为0。\n\n1.  $u(x)$ 的系数：$A+B+C+D = 0$。根据 $D=-A$ 和 $C=-B$，我们得到 $A+B-B-A=0$，此式自动满足。\n2.  $u'(x)$ 的系数：$h(-2A-B+C+2D) = 1$。利用对称性，$h(-2A-B-B-2A) = h(-4A-2B)=1$。因此，$4A+2B = -1/h$。\n3.  $u''(x)$ 的系数：$\\frac{h^2}{2}(4A+B+C+4D) = \\frac{h^2}{2}(4A+B-B-4A)=0$。此式也因对称性条件而自动满足。\n4.  $u'''(x)$ 的系数：我们希望格式至少是二阶精度的，因此该项的系数必须为零。$\\frac{h^3}{6}(-8A-B+C+8D) = \\frac{h^3}{6}(-8A-B-B-8A) = \\frac{h^3}{6}(-16A-2B) = 0$。这给出 $16A+2B=0$。\n5.  $u^{(4)}(x)$ 的系数：$\\frac{h^4}{24}(16A+B+C+16D) = \\frac{h^4}{24}(16A+B-B-16A)=0$。该项也因对称性而消失。这意味着如果我们消去 $u'''(x)$ 项，该方法将自动达到四阶精度。\n\n现在我们求解关于 $A$ 和 $B$ 的二元线性方程组：\n$$\n\\begin{cases}\n4A+2B = -1/h \\\\\n16A+2B = 0\n\\end{cases}\n$$\n由第二个方程可得 $2B = -16A$，即 $B = -8A$。\n将此代入第一个方程：\n$$\n4A + 2(-8A) = -1/h \\implies 4A - 16A = -1/h \\implies -12A = -1/h \\implies A = \\frac{1}{12h}\n$$\n现在我们求其他系数：\n$$\nB = -8A = -8\\left(\\frac{1}{12h}\\right) = -\\frac{8}{12h} = -\\frac{2}{3h}\n$$\n$$\nC = -B = \\frac{2}{3h}\n$$\n$$\nD = -A = -\\frac{1}{12h}\n$$\n将这些系数代回 $D_h[u](x)$ 的公式：\n$$\nD_h[u](x) = \\frac{1}{12h}u(x-2h) - \\frac{2}{3h}u(x-h) + \\frac{2}{3h}u(x+h) - \\frac{1}{12h}u(x+2h)\n$$\n这可以更紧凑地写成：\n$$\nD_h[u](x) = \\frac{-u(x+2h) + 8u(x+h) - 8u(x-h) + u(x-2h)}{12h}\n$$\n这就是所求的 $u'(x)$ 的四阶中心差分格式。\n\n现在，我们计算主截断误差项。截断误差 $T(h)$ 定义为 $T(h) = D_h[u](x) - u'(x)$。该误差的主项来自于泰勒展开式中 $u'(x)$ 项之后的第一个非零项。我们构造的格式使得 $u(x)$、$u''(x)$、$u'''(x)$ 和 $u^{(4)}(x)$ 的系数都为零。下一项是来自 $u^{(5)}(x)$ 的项。因此，主误差项为：\n$$\nT_{lead} = \\left(D_h[u](x) \\text{ 展开式中 } u^{(5)}(x) \\text{ 的系数}\\right) \\times u^{(5)}(x)\n$$\n$$\nT_{lead} = \\frac{h^5}{120}(-32A-B+C+32D) u^{(5)}(x)\n$$\n代入 $A, B, C, D$ 的值：\n$$\nT_{lead} = \\frac{h^5}{120} \\left(-32\\left(\\frac{1}{12h}\\right) - \\left(-\\frac{8}{12h}\\right) + \\left(\\frac{8}{12h}\\right) + 32\\left(-\\frac{1}{12h}\\right)\\right) u^{(5)}(x)\n$$\n$$\nT_{lead} = \\frac{h^5}{120 \\cdot 12h} (-32 + 8 + 8 - 32) u^{(5)}(x)\n$$\n$$\nT_{lead} = \\frac{h^4}{1440} (-48) u^{(5)}(x) = -\\frac{48}{1440} h^4 u^{(5)}(x)\n$$\n简化分数 $\\frac{48}{1440} = \\frac{4}{120} = \\frac{1}{30}$。\n因此，主截断误差项为：\n$$\nT_{lead} = -\\frac{1}{30}h^4 u^{(5)}(x)\n$$\n精度阶数确实为 $\\mathcal{O}(h^4)$，符合要求。完整的近似表达式为 $D_h[u](x) = u'(x) - \\frac{1}{30} h^4 u^{(5)}(x) + \\mathcal{O}(h^6)$。\n\n问题要求以符号解析表达式给出最终结果，包括差分格式和主截断误差项。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{-u(x+2h) + 8u(x+h) - 8u(x-h) + u(x-2h)}{12h},  -\\frac{1}{30}h^4 u^{(5)}(x) \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "任何有限差分近似都存在截断误差，这会限制其计算精度。理查森外推法 (Richardson extrapolation) 是一种强大的通用技术，它可以通过组合不同步长的计算结果来系统性地消除主导误差项。在本实践中 ，你将实现该方法来提高压力状态方程导数的计算精度，并学习如何通过启发式检查来判断计算是否处于方法有效的“渐进区”。",
            "id": "3471306",
            "problem": "您的任务是在一个无量纲化的计算材料科学设定中，实现一个程序，使用数值微分和理查森外推法来估计压力物态方程 $P(V)$ 相对于体积 $V$ 的导数。所有量均为无量纲，三角函数中使用的任何角度都必须是弧度。所使用的基本基础是导数作为极限的定义以及对于足够光滑的 $P(V)$ 存在局部泰勒展开。您的估计器必须通过在对称偏移量 $V \\pm h$ 处对 $P(V)$ 进行求值来构建，使用一个 $O(h^2)$ 精度的对称差分格式，然后通过一个两级理查森外推程序进行外推以减少偏差。此外，还需实现启发式一致性检查，以检测步长是否处于 $O(h^2)$ 误差模型尚不占主导地位的前渐近区。\n\n要求：\n- 仅基于 $P(V+h)$ 和 $P(V-h)$ 的值，实现一个用于计算 $\\frac{dP}{dV}$ 的 $O(h^2)$ 精度对称差分估计器。\n- 实现一个两级理查森外推法，该方法使用步长 $h$ 和 $h/2$ 的结果来抵消 $O(h^2)$ 估计器中的主偏差项。然后，使用 $h/2$ 和 $h/4$ 重复此过程以获得一个更精确的估计。\n- 实现启发式一致性检查以检测前渐近行为。至少，比较在 $h$、$h/2$ 和 $h/4$ 处的估计值之间连续差分的缩放比例，以及两个理查森外推值之间的一致性。如果观察到的行为与预期的 $h^2$ 缩放和一致的外推收敛不符，则将该情况标记为前渐近。\n- 对于每个测试用例，报告一个从较小步长对的理查森外推中获得的 $\\frac{dP}{dV}$ 的单一估计值，以及一个指示是否检测到前渐近区的布尔标志。\n- 所有量均为无量纲，因此不需要物理单位。如果使用三角函数，其参数必须以弧度解释。\n\n测试套件：\n实现程序以处理以下四个测试用例。对于每个用例，使用指定的函数 $P(V)$、求值点 $V_0$ 和初始步长 $h$（您将依次将其减半为 $h/2$ 和 $h/4$）：\n- 用例 $1$（光滑有理式）：$P(V) = \\frac{A}{V}$，其中 $A = 2.5$，$V_0 = 1.2$，$h = 0.1$。\n- 用例 $2$（远离奇点的移位奇点有理式）：$P(V) = \\frac{R T}{V - b} - \\frac{a}{V^2}$，其中 $R T = 3.0$，$a = 1.2$，$b = 0.3$，$V_0 = 0.8$，$h = 0.05$。\n- 用例 $3$（指数可压缩性代理）：$P(V) = P_0 e^{-k V}$，其中 $P_0 = 5.0$，$k = 0.7$，$V_0 = 2.0$，$h = 0.2$。\n- 用例 $4$（模拟数值或采样伪影的振荡污染）：$P(V) = \\frac{A}{V} + \\epsilon \\sin(\\omega V)$，其中 $A = 1.0$，$\\epsilon = 0.01$，$\\omega = 80.0$，$V_0 = 1.0$，$h = 0.05$。角度 $\\omega V$ 是弧度。\n\n启发式一致性检查：\n- 使用在 $h$、$h/2$ 和 $h/4$ 处的估计值来计算连续差分的比率 $r$。如果估计器处于其 $O(h^2)$ 渐近区，比率 $r$ 应接近 $4$。如果 $r$ 与 $4$ 有显著偏差，则表明存在前渐近行为。\n- 使用对 $(h, h/2)$ 和 $(h/2, h/4)$ 计算两个理查森外推值。如果这两个外推值在小相对容差之外不一致，则标记为前渐近行为。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个包含外推导数估计值和布尔标志的二元列表，按四个测试用例的顺序排列。例如，输出必须看起来像\n$[ [\\text{est}_1,\\text{flag}_1],[\\text{est}_2,\\text{flag}_2],[\\text{est}_3,\\text{flag}_3],[\\text{est}_4,\\text{flag}_4] ]$，\n其中每个 $\\text{est}_i$ 是一个浮点数，每个 $\\text{flag}_i$ 是一个布尔值。",
            "solution": "该问题要求实现一种数值微分算法，并用理查森外推法进行增强，以估计压力物态方程的导数 $\\frac{dP}{dV}$。该实现还必须包括启发式检查，以检测前渐近收敛行为。问题定义良好，具有科学依据，并提供了进行求解所需的所有信息。\n\n该方法的核心在于足够光滑的函数 $P(V)$ 在点 $V_0$ 附近的泰勒级数展开。$P(V_0+h)$ 和 $P(V_0-h)$ 的展开式由下式给出：\n$$ P(V_0+h) = P(V_0) + h P'(V_0) + \\frac{h^2}{2!} P''(V_0) + \\frac{h^3}{3!} P'''(V_0) + \\frac{h^4}{4!} P^{(4)}(V_0) + \\dots $$\n$$ P(V_0-h) = P(V_0) - h P'(V_0) + \\frac{h^2}{2!} P''(V_0) - \\frac{h^3}{3!} P'''(V_0) + \\frac{h^4}{4!} P^{(4)}(V_0) - \\dots $$\n其中 $P^{(n)}(V_0)$ 表示 $P(V)$ 在 $V_0$ 处的 $n$ 阶导数。\n\n将第二个展开式从第一个中减去，我们消除了所有 $h$ 的偶次幂项：\n$$ P(V_0+h) - P(V_0-h) = 2h P'(V_0) + \\frac{2h^3}{3!} P'''(V_0) + \\frac{2h^5}{5!} P^{(5)}(V_0) + \\dots $$\n\n重新整理此方程以求解一阶导数 $P'(V_0)$，得到：\n$$ P'(V_0) = \\frac{P(V_0+h) - P(V_0-h)}{2h} - \\frac{h^2}{6} P'''(V_0) - \\frac{h^4}{120} P^{(5)}(V_0) - \\dots $$\n\n该表达式构成了我们数值估计器的基础。我们定义对称差分近似 $D(h)$ 为：\n$$ D(h) = \\frac{P(V_0+h) - P(V_0-h)}{2h} $$\n\n此近似的误差 $E(h) = D(h) - P'(V_0)$ 的结构是 $h^2$ 的幂级数：\n$$ E(h) = C_1 h^2 + C_2 h^4 + C_3 h^6 + \\dots $$\n其中系数 $C_k$ 取决于 $P(V)$ 在 $V_0$ 处的高阶导数（例如，$C_1 = \\frac{1}{6}P'''(V_0)$）。因为主误差项与 $h^2$ 成正比，所以这是一个 $O(h^2)$ 精度的格式。\n\n理查森外推法是一种系统地消除主误差项的技术。设真实导数为 $P'_{true}$。我们可以为两个不同的步长 $h$ 和 $h/2$ 写出近似值：\n$$ D(h) = P'_{true} + C_1 h^2 + C_2 h^4 + \\dots $$\n$$ D(h/2) = P'_{true} + C_1 \\left(\\frac{h}{2}\\right)^2 + C_2 \\left(\\frac{h}{2}\\right)^4 + \\dots = P'_{true} + \\frac{1}{4} C_1 h^2 + \\frac{1}{16} C_2 h^4 + \\dots $$\n\n我们可以通过线性组合这两个方程来消除主误差项 $C_1 h^2$。将第二个方程乘以 $4$ 并减去第一个方程，得到：\n$$ 4 D(h/2) - D(h) = (4 P'_{true} - P'_{true}) + (C_1 h^2 - C_1 h^2) + \\left(\\frac{1}{4} C_2 h^4 - C_2 h^4\\right) + \\dots $$\n$$ 4 D(h/2) - D(h) = 3 P'_{true} - \\frac{3}{4} C_2 h^4 + \\dots $$\n\n求解 $P'_{true}$，我们得到理查森外推估计值 $R(h, h/2)$：\n$$ R(h, h/2) = \\frac{4 D(h/2) - D(h)}{3} = P'_{true} - \\frac{1}{4} C_2 h^4 + \\dots $$\n这个新估计的误差阶数为 $O(h^4)$，这是一个显著的改进。问题指定了一个两级外推，这涉及将此过程应用两次：首先对步长对 $(h, h/2)$ 得到一个估计 $R_1$，其次对步长对 $(h/2, h/4)$ 得到一个更精确的估计 $R_2$。最终报告的估计值将是 $R_2$。\n\n此过程有效的一个关键假设是，对于所选的步长 $h$，误差由主导项 $C_1 h^2$ 决定。如果高阶项（$C_2h^4$ 等）很显著，或者如果函数不能被其泰勒多项式局部地很好地近似（例如，由于高频振荡），该方法可能不会表现出预期的 $O(h^2)$ 收敛性。这被称为前渐近区。我们为此行为实现了两种启发式检查。\n\n1.  **收敛比率检查**：如果误差由 $h^2$ 项主导，则估计值中连续差分的比率应趋于一个常数。设 $D_1=D(h)$、$D_2=D(h/2)$ 和 $D_3=D(h/4)$。差分近似为：\n    $$ D_1 - D_2 \\approx \\left(P'_{true} + C_1 h^2\\right) - \\left(P'_{true} + C_1 (h/2)^2\\right) = \\frac{3}{4} C_1 h^2 $$\n    $$ D_2 - D_3 \\approx \\left(P'_{true} + C_1 (h/2)^2\\right) - \\left(P'_{true} + C_1 (h/4)^2\\right) = \\frac{3}{16} C_1 h^2 $$\n    这些差分的比率 $r = \\frac{D_1 - D_2}{D_2 - D_3}$ 应约等于 $4$。与该值的显著偏差表明 $O(h^2)$ 误差模型不成立，从而标记为前渐近行为。使用 $|r-4|  1.0$ 的偏差容差。\n\n2.  **外推值一致性**：两个外推估计值 $R_1 = R(h, h/2)$ 和 $R_2 = R(h/2, h/4)$ 都是真实导数的 $O(h^4)$ 近似。因此，它们应该比原始的 $D_k$ 估计值彼此更接近。如果它们的相对差异较大，这表明外推过程本身不稳定或不一致，因为其基本假设被违反了。使用 $1\\%$ 的相对差异阈值来标记此情况。\n\n如果触发了这两个检查中的任何一个，则结果将被标记为可能因前渐近行为而不可靠。对于每个测试用例，算法将按以下步骤进行：\n1.  计算步长为 $h$、$h/2$ 和 $h/4$ 的对称差分估计值 $D_1, D_2, D_3$。\n2.  执行收敛比率检查。\n3.  计算两个外推值 $R_1$ 和 $R_2$。\n4.  执行外推值一致性检查。\n5.  如果任一检查指示前渐近行为，则将布尔标志设置为 `True`。\n6.  该用例的最终报告结果是由更精确的估计值 $R_2$ 和前渐近标志组成的对。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical differentiation problem for the given test cases.\n    \"\"\"\n\n    def estimate_derivative(P_func, V0, h_init):\n        \"\"\"\n        Estimates the derivative of a function P(V) at V0 using symmetric\n        difference with two-level Richardson extrapolation. Also performs\n        heuristic checks for pre-asymptotic behavior.\n\n        Args:\n            P_func (callable): The function P(V) to differentiate.\n            V0 (float): The point at which to evaluate the derivative.\n            h_init (float): The initial step size.\n\n        Returns:\n            list: A list containing [derivative_estimate, is_preasymptotic_flag].\n        \"\"\"\n        # Symmetric difference estimator\n        def D(f, v, h_step):\n            return (f(v + h_step) - f(v - h_step)) / (2.0 * h_step)\n\n        # Step sizes\n        h1 = h_init\n        h2 = h_init / 2.0\n        h3 = h_init / 4.0\n\n        # Compute the three basic estimates\n        D1 = D(P_func, V0, h1)\n        D2 = D(P_func, V0, h2)\n        D3 = D(P_func, V0, h3)\n\n        # Heuristic checks for pre-asymptotic behavior\n        is_preasymptotic = False\n\n        # Check 1: Ratio of successive differences\n        # The ratio should be close to 4 for an O(h^2) method.\n        # r = (D(h) - D(h/2)) / (D(h/2) - D(h/4))\n        diff1 = D1 - D2\n        diff2 = D2 - D3\n        \n        # Avoid division by zero if differences are tiny\n        if abs(diff2)  1e-12:\n            # If the difference is zero, it might mean the method has converged.\n            # The ratio test is not applicable, but this is not a sign of pre-asymptotic behavior.\n            pass\n        else:\n            ratio = diff1 / diff2\n            # Flag if the ratio \"substantially deviates\" from 4.\n            if abs(ratio - 4.0) > 1.0:\n                is_preasymptotic = True\n\n        # Compute Richardson-extrapolated values\n        # R = (4 * D_finer - D_coarser) / 3\n        R1 = (4.0 * D2 - D1) / 3.0  # From (h, h/2)\n        R2 = (4.0 * D3 - D2) / 3.0  # From (h/2, h/4)\n\n        # Check 2: Consistency of extrapolated values\n        # The two O(h^4) estimates should be close to each other.\n        # Use a relative difference check to avoid issues with magnitude.\n        # Add a small epsilon to the denominator to handle cases where R values are near zero.\n        denominator = max(abs(R1), abs(R2), 1e-9)\n        relative_diff = abs(R1 - R2) / denominator\n        \n        # Flag if relative difference is larger than a tolerance (e.g., 1%).\n        if relative_diff > 0.01:\n            is_preasymptotic = True\n            \n        # Per problem specification, return the more refined estimate (R2) and the flag.\n        return [R2, is_preasymptotic]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1,\n            \"P_func\": lambda V: 2.5 / V,\n            \"V0\": 1.2,\n            \"h\": 0.1\n        },\n        {\n            \"id\": 2,\n            \"P_func\": lambda V: (3.0 / (V - 0.3)) - (1.2 / V**2),\n            \"V0\": 0.8,\n            \"h\": 0.05\n        },\n        {\n            \"id\": 3,\n            \"P_func\": lambda V: 5.0 * np.exp(-0.7 * V),\n            \"V0\": 2.0,\n            \"h\": 0.2\n        },\n        {\n            \"id\": 4,\n            \"P_func\": lambda V: (1.0 / V) + 0.01 * np.sin(80.0 * V),\n            \"V0\": 1.0,\n            \"h\": 0.05\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = estimate_derivative(case[\"P_func\"], case[\"V0\"], case[\"h\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists matches the required format.\n    print(f\"[[{results[0][0]}, {str(results[0][1]).lower()}],[{results[1][0]}, {str(results[1][1]).lower()}],[{results[2][0]}, {str(results[2][1]).lower()}],[{results[3][0]}, {str(results[3][1]).lower()}]]\")\n\nsolve()\n```"
        }
    ]
}