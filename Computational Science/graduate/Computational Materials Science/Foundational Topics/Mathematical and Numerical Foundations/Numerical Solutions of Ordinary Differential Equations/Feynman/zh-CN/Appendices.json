{
    "hands_on_practices": [
        {
            "introduction": "我们的实践探索始于数值积分中最基本的概念：稳定性。本练习使用最简单的时间步进格式之一——显式欧拉法，来阐明为何并非所有步长都能导出正确甚至有界的解。通过分析一个瞬态热传导模型，您将推导出限制最大允许时间步长的稳定性条件，从而对条件稳定性及其在计算材料科学模拟中的重要性有一个具体的理解。",
            "id": "3472108",
            "problem": "在各向同性热扩散系数为$D$的均匀晶体薄膜的瞬态热传导中，其控制偏微分方程 (PDE) 为 $\\frac{\\partial u}{\\partial t} = D \\nabla^{2} u$。使用带有质量集总的 Galerkin 有限元法进行标准的空间离散化，可得到形式为 $\\dot{\\mathbf{u}} = \\mathbf{L}\\mathbf{u}$ 的自治线性常微分方程 (ODE) 系统，其中 $\\mathbf{L}$ 是一个实对称负定矩阵。考虑与 $\\mathbf{L}$ 的一个特征对 $(\\lambda, \\mathbf{v})$ 相关联的单个模态分量 $y(t)$，即 $\\mathbf{L}\\mathbf{v} = \\lambda \\mathbf{v}$ 且 $y(t) = \\mathbf{v}^{\\top}\\mathbf{u}(t)$，它遵循标量线性 ODE $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{R}$ 且 $\\lambda < 0$。\n\n从时间导数的前向有限差分定义和显式 Euler 时间推进更新出发，推导标量单步放大因子 $R(z)$ 作为 $z = \\lambda h$ 的函数，其中 $h > 0$ 是时间步长。使用绝对稳定区域 $\\mathcal{S}$ 的定义，即满足 $|R(z)| < 1$ 的复数 $z$ 的集合，确定最大步长 $h$ 作为给定的负实数 $\\lambda$ 的函数，以使 $z = \\lambda h$ 保持在 $\\mathcal{S}$ 内。\n\n将您的最终答案表示为 $R(z)$ 和 $h_{\\max}(\\lambda)$ 的闭式解析表达式。无需数值四舍五入。最终表达式中不需要物理单位。",
            "solution": "该问题要求推导显式 Euler 方法的放大因子，并随后确定受稳定性限制的时间步长。\n\n出发点是标量线性常微分方程，通常称为测试方程，它控制着系统单个模态分量的演化：\n$$\ny'(t) = \\lambda y(t)\n$$\n此处，$y(t)$ 是模态在时间 $t$ 的振幅，$\\lambda$ 是相应的负实数特征值。\n\n显式 Euler 方法是通过将时间离散化为大小为 $h > 0$ 的步长来推导的。设 $y_n$ 是 $y(t_n)$ 在时间 $t_n = n h$ 的数值近似。在 $t_n$ 处的时间导数 $y'(t)$ 使用前向有限差分进行近似：\n$$\ny'(t_n) \\approx \\frac{y_{n+1} - y_n}{h}\n$$\n将此近似代入 ODE 得到时间推进格式：\n$$\n\\frac{y_{n+1} - y_n}{h} = \\lambda y_n\n$$\n这个更新规则定义了显式 Euler 方法。为了找到单步放大因子，我们求解 $y_{n+1}$ 关于 $y_n$ 的表达式：\n$$\ny_{n+1} - y_n = \\lambda h y_n\n$$\n$$\ny_{n+1} = y_n + \\lambda h y_n = (1 + \\lambda h) y_n\n$$\n我们记为 $R$ 的标量单步放大因子是解在每个时间步长上乘以的因子。它定义为比率 $y_{n+1} / y_n$：\n$$\nR = \\frac{y_{n+1}}{y_n} = 1 + \\lambda h\n$$\n问题指定该因子应表示为 $z = \\lambda h$ 的函数。将 $z$ 代入 $R$ 的表达式中，得到第一个所需的表达式：\n$$\nR(z) = 1 + z\n$$\n任务的第二部分是确定使方法稳定的最大步长 $h_{\\max}$。问题将绝对稳定区域 $\\mathcal{S}$ 定义为放大因子的大小严格小于 $1$ 的复数 $z$ 的集合：\n$$\n\\mathcal{S} = \\{z \\in \\mathbb{C} : |R(z)| < 1\\}\n$$\n为了使数值解保持有界且不被人为地放大，$z = \\lambda h$ 必须位于该区域内。代入我们对 $R(z)$ 的表达式，稳定性条件变为：\n$$\n|1 + z| < 1\n$$\n问题指出 $\\lambda$ 是一个负实数 ($\\lambda < 0$)，时间步长 $h$ 是正数 ($h > 0$)。因此，它们的乘积 $z = \\lambda h$ 是一个负实数。设 $z = x$，其中 $x \\in \\mathbb{R}$ 且 $x < 0$。稳定性条件简化为：\n$$\n|1 + x| < 1\n$$\n对于实数参数，这个不等式等价于：\n$$\n-1 < 1 + x < 1\n$$\n我们通过从所有部分减去 $1$ 来解这个复合不等式关于 $x$ 的解：\n$$\n-1 - 1 < x < 1 - 1\n$$\n$$\n-2 < x < 0\n$$\n因此，为使方法稳定，$z = \\lambda h$ 必须位于开区间 $(-2, 0)$ 内。我们将 $z = \\lambda h$ 代回这个不等式中：\n$$\n-2 < \\lambda h < 0\n$$\n这个复合不等式包含两个条件：\n1. $\\lambda h < 0$: 因为给定 $\\lambda < 0$ 且 $h > 0$，它们的乘积总是负的。因此这个条件总是满足的。\n2. $-2 < \\lambda h$: 这个条件对时间步长 $h$ 施加了一个约束。为了解出 $h$，我们用 $\\lambda$ 除。由于 $\\lambda$ 是一个负数，除以它会反转不等号的方向：\n$$\n\\frac{-2}{\\lambda} > h\n$$\n这可以改写为：\n$$\nh < \\frac{-2}{\\lambda}\n$$\n这个不等式定义了对于给定的负特征值 $\\lambda$，显式 Euler 方法保持稳定的时间步长 $h$ 的范围。最大允许步长 $h_{\\max}$ 是这个稳定步长集合的上确界，也就是区间的上界。\n$$\nh_{\\max}(\\lambda) = \\frac{-2}{\\lambda}\n$$\n在这个边界值处，$h = -2/\\lambda$，我们有 $z = \\lambda h = -2$，这得到 $|R(z)| = |1 - 2| = |-1| = 1$。这位于稳定区域的边界上，但不在其内部，这与严格不等式 $|R(z)| < 1$ 一致。\n\n两个所需的表达式是 $R(z) = 1+z$ 和 $h_{\\max}(\\lambda) = \\frac{-2}{\\lambda}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1 + z & \\frac{-2}{\\lambda} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "认识到显式方法的稳定性限制后，我们转向隐式格式，这是处理材料动力学中常见刚性系统的主力方法。一个隐式步需要为下一时间点的解求解一个非线性代数方程。本练习将指导您在一个缺陷与位错演化模型的背景下，推导并实现牛顿-拉夫逊方法——完成此任务的标准算法。 这对于开发或理解稳健的模拟工具至关重要。",
            "id": "3472164",
            "problem": "考虑一个与计算材料科学相关的刚性、无量纲化的微观结构动力学模型，其中无量纲点缺陷浓度 $c$ 和无量纲位错密度 $\\rho$ 的演化由一个常微分方程 (ODE) 自治系统描述：\n$$\n\\frac{d}{dt}\n\\begin{pmatrix}\nc \\\\\n\\rho\n\\end{pmatrix}\n=\n\\Phi\\!\\left(\n\\begin{pmatrix}\nc \\\\\n\\rho\n\\end{pmatrix}\n\\right), \\quad\n\\Phi\\!\\left(\n\\begin{pmatrix}\nc \\\\\n\\rho\n\\end{pmatrix}\n\\right)\n=\n\\begin{pmatrix}\n-k\\,c + a\\,\\rho\\,c \\\\\nb\\,c - d\\,\\rho\n\\end{pmatrix},\n$$\n其中 $k$、$a$、$b$ 和 $d$ 为正常数。像后向欧拉法这样的隐式单步法，通过求解非线性步长方程将解从 $t_n$ 推进到 $t_{n+1}=t_n + h$：\n$$\nG(y_{n+1}) \\equiv y_{n+1} - y_n - h\\,\\Phi(y_{n+1}) = 0,\n$$\n其中 $y = (c,\\rho)^{\\top}$ 且 $h>0$ 是步长。从非线性映射求根和一阶泰勒线性化的基本定义出发，推导在每个时间步求解 $G(y_{n+1})=0$ 的牛顿迭代法。使用 $G$ 的雅可比矩阵显式地推导迭代映射，并说明该雅可比矩阵如何依赖于 $\\Phi$ 的雅可比矩阵。然后，陈述基于残差范数和步长范数的停止准则，并明确指出所使用的范数。\n\n接下来，将您推导的迭代和准则应用于以下具体实例。设 $k=5$、$a=3$、$b=2$、$d=4$，步长 $h=0.05$，上一步的值为 $y_n=\\big(0.8,\\,0.6\\big)^{\\top}$。使用初始牛顿猜测值 $y_{n+1}^{(0)}=y_n$。通过求解适当的线性系统，执行一次牛顿更新以计算第一个牛顿步长 $s^{(0)}=y_{n+1}^{(1)}-y_{n+1}^{(0)}$。计算欧几里得范数 $\\|s^{(0)}\\|_2$。假设残差和步长停止容差分别为 $\\tau_{\\mathrm{res}}=1.0\\times 10^{-4}$ 和 $\\tau_{\\mathrm{step}}=1.0\\times 10^{-4}$，并评论在第一次更新后是否有任一准则会触发终止。将 $\\|s^{(0)}\\|_2$ 的值报告为一个无量纲实数。将您的答案四舍五入到四位有效数字。",
            "solution": "该问题要求推导用于求解由常微分方程组的隐式时间步进格式产生的非线性系统的牛顿迭代法，然后将其应用于一个具体案例。\n\n### 第1部分：牛顿迭代的推导\n\n将后向欧拉法应用于 ODE 系统 $\\frac{dy}{dt} = \\Phi(y)$，在每个时间步得到关于 $y_{n+1}$ 的非线性代数方程：\n$$\ny_{n+1} = y_n + h\\,\\Phi(y_{n+1})\n$$\n这可以写成一个求根问题 $G(y_{n+1}) = 0$，其中函数 $G$ 定义为：\n$$\nG(y_{n+1}) \\equiv y_{n+1} - y_n - h\\,\\Phi(y_{n+1}) = 0\n$$\n牛顿法是一种迭代求根算法。设 $y_{n+1}^{(k)}$ 是解 $y_{n+1}$ 的第 $k$ 次近似。我们寻求一个修正量或步长 $s^{(k)}$，使得 $y_{n+1}^{(k+1)} = y_{n+1}^{(k)} + s^{(k)}$ 是一个更好的近似。我们通过在 $y_{n+1}^{(k)}$ 周围使用一阶泰勒展开对 $G$ 进行线性化来找到 $s^{(k)}$：\n$$\nG(y_{n+1}^{(k+1)}) = G(y_{n+1}^{(k)} + s^{(k)}) \\approx G(y_{n+1}^{(k)}) + J_G(y_{n+1}^{(k)}) s^{(k)}\n$$\n其中 $J_G(y_{n+1}^{(k)})$ 是 $G$ 在 $y_{n+1}^{(k)}$ 处计算的雅可比矩阵。为了找到根，我们将 $G(y_{n+1}^{(k+1)})$ 的近似值设为零：\n$$\nG(y_{n+1}^{(k)}) + J_G(y_{n+1}^{(k)}) s^{(k)} = 0\n$$\n这给出了牛顿步长 $s^{(k)}$ 的线性系统：\n$$\nJ_G(y_{n+1}^{(k)}) s^{(k)} = -G(y_{n+1}^{(k)})\n$$\n然后，牛顿迭代通过求解这个关于 $s^{(k)}$ 的线性系统并更新解来定义：\n$$\ny_{n+1}^{(k+1)} = y_{n+1}^{(k)} + s^{(k)}\n$$\n为了使其明确，我们必须推导 $G$ 的雅可比矩阵。向量 $y_n$ 相对于变量 $y_{n+1}$ 是一个常数。为了求导，我们简单地将 $y_{n+1}$ 表示为 $y$。\n$$\nJ_G(y) = \\frac{\\partial G(y)}{\\partial y} = \\frac{\\partial}{\\partial y} \\left( y - y_n - h\\,\\Phi(y) \\right)\n$$\n使用向量微积分的法则：\n$$\nJ_G(y) = \\frac{\\partial y}{\\partial y} - \\frac{\\partial y_n}{\\partial y} - h \\frac{\\partial \\Phi(y)}{\\partial y} = I - 0 - h\\,J_{\\Phi}(y)\n$$\n其中 $I$ 是单位矩阵，$J_{\\Phi}(y)$ 是函数 $\\Phi(y)$ 的雅可比矩阵。因此，$G$ 的雅可比矩阵与 $\\Phi$ 的雅可比矩阵的关系如下：\n$$\nJ_G(y) = I - h\\,J_{\\Phi}(y)\n$$\n将此代入牛顿系统，迭代映射由以下序列定义（对于 $k=0, 1, 2, ...$）：\n1. 求解关于 $s^{(k)}$ 的线性系统：\n   $$\n   \\left(I - h\\,J_{\\Phi}(y_{n+1}^{(k)})\\right) s^{(k)} = -(y_{n+1}^{(k)} - y_n - h\\,\\Phi(y_{n+1}^{(k)})) = y_n - y_{n+1}^{(k)} + h\\,\\Phi(y_{n+1}^{(k)})\n   $$\n2. 更新解：\n   $$\n   y_{n+1}^{(k+1)} = y_{n+1}^{(k)} + s^{(k)}\n   $$\n\n对于具体系统 $y = (c, \\rho)^{\\top}$ 和 $\\Phi(y) = \\begin{pmatrix} -k\\,c + a\\,\\rho\\,c \\\\ b\\,c - d\\,\\rho \\end{pmatrix}$，$\\Phi$ 的雅可比矩阵是：\n$$\nJ_{\\Phi}(y) = \\begin{pmatrix} \\frac{\\partial}{\\partial c}(-k\\,c + a\\,\\rho\\,c) & \\frac{\\partial}{\\partial \\rho}(-k\\,c + a\\,\\rho\\,c) \\\\ \\frac{\\partial}{\\partial c}(b\\,c - d\\,\\rho) & \\frac{\\partial}{\\partial \\rho}(b\\,c - d\\,\\rho) \\end{pmatrix} = \\begin{pmatrix} a\\,\\rho - k & a\\,c \\\\ b & -d \\end{pmatrix}\n$$\n\n### 第2部分：停止准则\n\n牛顿迭代持续进行，直到达到期望的精度水平。这通过停止准则来监控。两个常见的准则是：\n1.  **残差范数准则**：如果残差向量 $G(y_{n+1}^{(k)})$ 的范数低于指定的容差 $\\tau_{\\mathrm{res}}$，则迭代停止。残差衡量了当前迭代值满足目标方程的程度。该准则是：\n    $$\n    \\|G(y_{n+1}^{(k)})\\| \\le \\tau_{\\mathrm{res}}\n    $$\n2.  **步长范数准则**：如果更新步长 $s^{(k)}$ 的范数低于指定的容差 $\\tau_{\\mathrm{step}}$，则迭代停止。一个小的步长表明解不再发生显著变化。该准则是：\n    $$\n    \\|s^{(k)}\\| \\le \\tau_{\\mathrm{step}}\n    $$\n在这两种情况下，都必须指定一个向量范数，例如欧几里得范数 $(\\|\\cdot\\|_2)$ 或最大范数 $(\\|\\cdot\\|_{\\infty})$。问题指定在定量部分使用欧几里得范数。\n\n### 第3部分：应用于具体实例\n\n我们被给予以下参数值：\n$k=5$、$a=3$、$b=2$、$d=4$、$h=0.05$。\n上一步的值为 $y_n = \\begin{pmatrix} c_n \\\\ \\rho_n \\end{pmatrix} = \\begin{pmatrix} 0.8 \\\\ 0.6 \\end{pmatrix}^{\\top}$。\n牛顿迭代的初始猜测值为 $y_{n+1}^{(0)} = y_n = \\begin{pmatrix} 0.8 \\\\ 0.6 \\end{pmatrix}^{\\top}$。\n\n设 $y^{(0)} = y_{n+1}^{(0)}$。我们需要通过求解 $(I - h\\,J_{\\Phi}(y^{(0)})) s^{(0)} = h\\,\\Phi(y^{(0)})$ 来计算第一个牛顿步长 $s^{(0)}$，由于 $y^{(0)} = y_n$，右侧已被简化。\n\n首先，我们在 $y^{(0)} = (0.8, 0.6)^{\\top}$ 处计算 $\\Phi$ 和 $J_{\\Phi}$：\n$$\n\\Phi(y^{(0)}) = \\begin{pmatrix} -5(0.8) + 3(0.6)(0.8) \\\\ 2(0.8) - 4(0.6) \\end{pmatrix} = \\begin{pmatrix} -4 + 1.44 \\\\ 1.6 - 2.4 \\end{pmatrix} = \\begin{pmatrix} -2.56 \\\\ -0.8 \\end{pmatrix}\n$$\n$$\nJ_{\\Phi}(y^{(0)}) = \\begin{pmatrix} 3(0.6) - 5 & 3(0.8) \\\\ 2 & -4 \\end{pmatrix} = \\begin{pmatrix} 1.8 - 5 & 2.4 \\\\ 2 & -4 \\end{pmatrix} = \\begin{pmatrix} -3.2 & 2.4 \\\\ 2 & -4 \\end{pmatrix}\n$$\n接下来，我们构造线性系统的矩阵 $I - h\\,J_{\\Phi}(y^{(0)})$：\n$$\nI - h\\,J_{\\Phi}(y^{(0)}) = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} - 0.05 \\begin{pmatrix} -3.2 & 2.4 \\\\ 2 & -4 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} - \\begin{pmatrix} -0.16 & 0.12 \\\\ 0.1 & -0.2 \\end{pmatrix} = \\begin{pmatrix} 1.16 & -0.12 \\\\ -0.1 & 1.2 \\end{pmatrix}\n$$\n线性系统的右侧是 $h\\,\\Phi(y^{(0)})$：\n$$\nh\\,\\Phi(y^{(0)}) = 0.05 \\begin{pmatrix} -2.56 \\\\ -0.8 \\end{pmatrix} = \\begin{pmatrix} -0.128 \\\\ -0.04 \\end{pmatrix}\n$$\n我们求解关于 $s^{(0)} = (s_c^{(0)}, s_{\\rho}^{(0)})^{\\top}$ 的线性系统：\n$$\n\\begin{pmatrix} 1.16 & -0.12 \\\\ -0.1 & 1.2 \\end{pmatrix} s^{(0)} = \\begin{pmatrix} -0.128 \\\\ -0.04 \\end{pmatrix}\n$$\n为了求解这个问题，我们可以对这个 $2 \\times 2$ 矩阵求逆。行列式为 $\\det = (1.16)(1.2) - (-0.12)(-0.1) = 1.392 - 0.012 = 1.38$。\n$$\ns^{(0)} = \\frac{1}{1.38} \\begin{pmatrix} 1.2 & 0.12 \\\\ 0.1 & 1.16 \\end{pmatrix} \\begin{pmatrix} -0.128 \\\\ -0.04 \\end{pmatrix} = \\frac{1}{1.38} \\begin{pmatrix} 1.2(-0.128) + 0.12(-0.04) \\\\ 0.1(-0.128) + 1.16(-0.04) \\end{pmatrix}\n$$\n$$\ns^{(0)} = \\frac{1}{1.38} \\begin{pmatrix} -0.1536 - 0.0048 \\\\ -0.0128 - 0.0464 \\end{pmatrix} = \\frac{1}{1.38} \\begin{pmatrix} -0.1584 \\\\ -0.0592 \\end{pmatrix} \\approx \\begin{pmatrix} -0.1147826... \\\\ -0.0428985... \\end{pmatrix}\n$$\n现在我们计算步长的欧几里得范数 $\\|s^{(0)}\\|_2$：\n$$\n\\|s^{(0)}\\|_2 = \\sqrt{(-0.1147826...)^2 + (-0.0428985...)^2} \\approx \\sqrt{0.0131750... + 0.001839...} = \\sqrt{0.0150150...} \\approx 0.122537...\n$$\n四舍五入到四位有效数字，$\\|s^{(0)}\\|_2 \\approx 0.1225$。\n\n最后，我们检查容差为 $\\tau_{\\mathrm{res}}=1.0\\times 10^{-4}$ 和 $\\tau_{\\mathrm{step}}=1.0\\times 10^{-4}$ 的停止准则。\n- **步长范数**：$\\|s^{(0)}\\|_2 \\approx 0.1225$。因为 $0.1225 > 1.0\\times 10^{-4}$，所以步长范数准则未满足。\n- **残差范数**：初始猜测值处的残差是 $G(y^{(0)}) = y^{(0)} - y_n - h\\,\\Phi(y^{(0)}) = -h\\,\\Phi(y^{(0)})$。\n  $$\n  \\|G(y^{(0)})\\|_2 = \\|-h\\,\\Phi(y^{(0)})\\|_2 = \\|-1\\|_2 \\left\\| \\begin{pmatrix} -0.128 \\\\ -0.04 \\end{pmatrix} \\right\\|_2 = \\sqrt{(-0.128)^2 + (-0.04)^2}\n  $$\n  $$\n  \\|G(y^{(0)})\\|_2 = \\sqrt{0.016384 + 0.0016} = \\sqrt{0.017984} \\approx 0.1341\n  $$\n  因为 $0.1341 > 1.0\\times 10^{-4}$，所以残差范数准则未满足。\n\n在第一次更新后，两个准则都不会触发终止。问题要求 $\\|s^{(0)}\\|_2$ 的值。",
            "answer": "$$\n\\boxed{0.1225}\n$$"
        },
        {
            "introduction": "现代求解器的最终目标是兼具效率与稳健性。这最后一个练习将我们对显式和隐式方法的理解融为一体，以构建一个智能的自适应积分器。您将通过计算雅可比矩阵的谱半径，实现一个能够实时自动检测系统“刚性”的机制。 基于这些信息，求解器将在快速的显式方法和稳定的隐式方法之间动态切换，这是许多先进模拟软件的核心策略。",
            "id": "3472179",
            "problem": "考虑一个源于计算材料科学的无量纲化缺陷聚集动力学模型，该模型用于描述晶体中由辐照引起的点缺陷。令状态向量为 $y(t) = \\begin{bmatrix} m(t) \\\\ c(t) \\end{bmatrix}$，其中 $m(t)$ 是可移动缺陷的浓度，$c(t)$ 是不可移动团簇的浓度。其演化过程由一个自治常微分方程（ODE）系统建模\n$$\n\\frac{d}{dt} y(t) = f\\big(y(t), t\\big),\n$$\n其中\n$$\n\\begin{aligned}\n\\frac{d}{dt} m(t) = G(t) - k_f \\, m(t)^2 + k_r \\, c(t) - k_m \\, m(t), \\\\\n\\frac{d}{dt} c(t) = \\tfrac{1}{2} \\, k_f \\, m(t)^2 - k_r \\, c(t),\n\\end{aligned}\n$$\n$k_f \\ge 0$、$k_r \\ge 0$ 和 $k_m \\ge 0$ 是无量纲速率常数，生成速率 $G(t)$ 是一个模拟脉冲辐照的光滑周期源。假设\n$$\nG(t) = G_0 + G_p \\, \\max\\left(0, \\sin\\!\\left( \\frac{2\\pi t}{P} \\right)\\right)^2,\n$$\n其中 $G_0 \\ge 0$，$G_p \\ge 0$，周期 $P > 0$。初始条件为 $y(0) = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n\n定义雅可比矩阵 $J(y,t) = \\frac{\\partial f}{\\partial y}(y,t)$ 及其谱半径 $\\rho(J) = \\max\\{ |\\lambda| : \\lambda \\text{ is an eigenvalue of } J \\}$。考虑一个固定的时间步长 $\\Delta t > 0$ 和无量纲刚度指标 $s_n = \\rho\\big(J(y_n,t_n)\\big) \\, \\Delta t$，该指标在步数索引 $n$ 处计算，其中 $t_n = n \\, \\Delta t$ 且 $y_n \\approx y(t_n)$。\n\n您必须设计并实现一个在从 $t=0$ 到 $t=T_{\\mathrm{end}}$ 的时间积分过程中，带有迟滞效应的自动刚度检测和模式切换机制。该机制在以下两者之间进行选择：\n- 一个显式四阶龙格-库塔方法（fourth-order Runge–Kutta (RK4)）步，和\n- 一个在每个时间步通过牛顿法求解的隐式后向欧拉步。\n\n切换逻辑使用两个阈值 $0 < \\theta_{\\mathrm{L}} < \\theta_{\\mathrm{U}}$ 来产生迟滞效应。设当前积分器模式为“显式”或“隐式”。在每一步中，计算 $s_n$。然后应用以下规则：\n- 如果当前模式为显式且 $s_n > \\theta_{\\mathrm{U}}$，则将下一步切换为隐式。\n- 如果当前模式为隐式且 $s_n < \\theta_{\\mathrm{L}}$，则将下一步切换为显式。\n- 否则，保持当前模式。\n在 $s_n = \\theta_{\\mathrm{L}}$ 或 $s_n = \\theta_{\\mathrm{U}}$ 的情况下，不切换模式。在 $t=0$ 时，将模式初始化为显式。\n\n实现要求：\n- 显式步必须是步长为 $\\Delta t$ 的单个经典 RK4 步。\n- 隐式步必须是步长为 $\\Delta t$ 的单个后向欧拉步，通过将牛顿法应用于残差 $R(y) = y - y_n - \\Delta t \\, f(y, t_{n+1})$ 来求解非线性方程 $y_{n+1} = y_n + \\Delta t \\, f(y_{n+1}, t_{n+1})$。在牛顿迭代中，推导并使用精确的雅可比矩阵 $\\frac{\\partial R}{\\partial y} = I - \\Delta t \\, \\frac{\\partial f}{\\partial y}(y, t_{n+1})$。使用基于牛顿更新范数的合理停止准则，并限制迭代次数以保证终止。\n- 在每一步之后，通过强制执行 $m \\ge 0$ 和 $c \\ge 0$ 来确保状态保持物理意义。\n\n您的程序必须对多个参数集积分该系统，并收集有关迟滞效应和刚度驱动模式选择的定量度量。对于每个参数集，报告：\n- $t = T_{\\mathrm{end}}$ 时的最终状态分量：$m(T_{\\mathrm{end}})$ 和 $c(T_{\\mathrm{end}})$。\n- 执行的显式步总数（整数）。\n- 执行的隐式步总数（整数）。\n- 模式切换总数（整数）。\n- 最终模式指示符（整数），其中 $0$ 表示显式，$1$ 表示隐式。\n\n所有时间和参数都是无量纲的；不使用物理单位。三角函数内的角度以弧度为单位。\n\n测试套件规范：\n使用以下四个参数集来测试不同的工况和迟滞行为。在所有情况下，初始条件均为 $y(0)=\\begin{bmatrix}0\\\\0\\end{bmatrix}$，初始模式为显式。\n\n- 案例 1（非刚性基线）：$(G_0, G_p, P, k_f, k_r, k_m, \\Delta t, T_{\\mathrm{end}}, \\theta_{\\mathrm{L}}, \\theta_{\\mathrm{U}}) = (0.01, 0.02, 0.5, 50.0, 1.0, 1.0, 0.01, 2.0, 0.5, 0.7)$。\n- 案例 2（持续刚性）：$(G_0, G_p, P, k_f, k_r, k_m, \\Delta t, T_{\\mathrm{end}}, \\theta_{\\mathrm{L}}, \\theta_{\\mathrm{U}}) = (0.2, 1.0, 0.5, 50.0, 1.0, 1.0, 0.01, 2.0, 0.5, 0.7)$。\n- 案例 3（振荡刚性，窄迟滞）：$(G_0, G_p, P, k_f, k_r, k_m, \\Delta t, T_{\\mathrm{end}}, \\theta_{\\mathrm{L}}, \\theta_{\\mathrm{U}}) = (0.05, 0.5, 0.5, 50.0, 1.0, 1.0, 0.01, 2.0, 0.5, 0.7)$。\n- 案例 4（振荡刚性，宽迟滞）：$(G_0, G_p, P, k_f, k_r, k_m, \\Delta t, T_{\\mathrm{end}}, \\theta_{\\mathrm{L}}, \\theta_{\\mathrm{U}}) = (0.05, 0.5, 0.5, 50.0, 1.0, 1.0, 0.01, 2.0, 0.3, 1.0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试案例，并且本身是一个 $[\\, m(T_{\\mathrm{end}}),\\, c(T_{\\mathrm{end}}),\\, \\text{explicit\\_steps},\\, \\text{implicit\\_steps},\\, \\text{switches},\\, \\text{final\\_mode} \\,]$ 形式的列表。$m(T_{\\mathrm{end}})$ 和 $c(T_{\\mathrm{end}})$ 都必须四舍五入到 $6$ 位小数。最终输出必须类似于 $[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$，不含任何额外文本。",
            "solution": "我们从常微分方程（ODE）的基本动力学建模和稳定性概念开始。在包含可移动缺陷和团簇的缺陷聚集中，质量作用定律形式给出了浓度的多项式速率以及捕获和释放的线性项。令 $y(t) = \\begin{bmatrix} m(t) \\\\ c(t) \\end{bmatrix}$。无量纲化的控制 ODE 系统为\n$$\n\\frac{d}{dt} m = G(t) - k_f m^2 + k_r c - k_m m, \\qquad\n\\frac{d}{dt} c = \\tfrac{1}{2} k_f m^2 - k_r c,\n$$\n其中\n$$G(t)=G_0 + G_p \\max\\left(0, \\sin\\!\\left( \\frac{2\\pi t}{P} \\right)\\right)^2$$\n右侧函数为 $f(y,t) = \\begin{bmatrix} f_1 \\\\ f_2 \\end{bmatrix}$，其中 $f_1(m,c,t) = G(t) - k_f m^2 + k_r c - k_m m$ 且 $f_2(m,c,t) = \\tfrac{1}{2} k_f m^2 - k_r c$。\n\n雅可比矩阵 $J(y,t)=\\frac{\\partial f}{\\partial y}(y,t)$ 是通过将 $f$ 对 $y$ 求导得到的：\n$$\nJ(y,t) = \\begin{bmatrix}\n\\frac{\\partial f_1}{\\partial m} & \\frac{\\partial f_1}{\\partial c} \\\\\n\\frac{\\partial f_2}{\\partial m} & \\frac{\\partial f_2}{\\partial c}\n\\end{bmatrix}\n= \\begin{bmatrix}\n-2 k_f m - k_m & k_r \\\\\nk_f m & -k_r\n\\end{bmatrix}.\n$$\n在 $(y,t)$ 点附近的瞬时线性化动力学由 $J(y,t)$ 控制。对于应用于线性测试方程 $y'=\\lambda y$ 的显式方法的稳定性，一个非放大的必要条件是 $|\\lambda| \\Delta t \\lesssim \\mathcal{O}(1)$，因此对于非线性系统，一个实用的刚度指标是使用谱半径 $\\rho(J)$ 和乘积 $s = \\rho(J)\\Delta t$。如果 $s$ 很大，最快的线性化模式要求使用隐式方案以保证数值稳定性和效率；如果 $s$ 很小，则显式方案就足够了。这启发了基于阈值的切换方法。\n\n我们通过将两个阈值 $0 < \\theta_{\\mathrm{L}} < \\theta_{\\mathrm{U}}$ 应用于 $s_n = \\rho(J(y_n,t_n)) \\Delta t$ 来引入迟滞效应。当 $s_n$ 在单个阈值附近波动时，迟滞效应通过创建一个保留当前模式的区间来防止频繁切换。其逻辑是：\n- 如果当前模式为显式且 $s_n > \\theta_{\\mathrm{U}}$，则下一步切换为隐式。\n- 如果当前模式为隐式且 $s_n < \\theta_{\\mathrm{L}}$，则下一步切换为显式。\n- 如果 $s_n$ 在 $[\\theta_{\\mathrm{L}},\\theta_{\\mathrm{U}}]$ 区间内或恰好等于某个边界值，则保持当前模式。\n\n我们现在详细说明数值方案。\n\n显式方案：四阶龙格-库塔（RK4）。给定 $t_n$ 时的 $y_n$ 和步长 $\\Delta t$，更新公式为\n$$\n\\begin{aligned}\nk_1 = f(y_n, t_n), \\\\\nk_2 = f\\left(y_n + \\tfrac{1}{2}\\Delta t\\, k_1, \\, t_n + \\tfrac{1}{2}\\Delta t\\right), \\\\\nk_3 = f\\left(y_n + \\tfrac{1}{2}\\Delta t\\, k_2, \\, t_n + \\tfrac{1}{2}\\Delta t\\right), \\\\\nk_4 = f\\left(y_n + \\Delta t\\, k_3, \\, t_n + \\Delta t\\right), \\\\\ny_{n+1} = y_n + \\tfrac{\\Delta t}{6} \\left( k_1 + 2 k_2 + 2 k_3 + k_4 \\right).\n\\end{aligned}\n$$\n只要步长能够解析最快的模式，RK4 方法就是稳定的，这可近似为 $s_n$ 足够小。\n\n隐式方案：后向欧拉法与牛顿法结合。我们在\n$$\ny_{n+1} = y_n + \\Delta t\\, f(y_{n+1}, t_{n+1}),\n$$\n中求解 $y_{n+1}$，这等价于求取残差\n$$\nR(y) = y - y_n - \\Delta t\\, f(y, t_{n+1}).\n$$\n的根。牛顿法迭代\n$$\n\\left( \\frac{\\partial R}{\\partial y}(y^{(j)}) \\right) \\delta y^{(j)} = -R\\big(y^{(j)}\\big), \\qquad\ny^{(j+1)} = y^{(j)} + \\delta y^{(j)},\n$$\n其中残差的精确雅可比矩阵为\n$$\n\\frac{\\partial R}{\\partial y}(y) = I - \\Delta t\\, J(y,t_{n+1}),\n$$\n而 $I$ 表示 $2 \\times 2$ 单位矩阵。一个合理的初始猜测是前向欧拉预测值 $y^{(0)} = y_n + \\Delta t\\, f(y_n, t_n)$。当 $\\|\\delta y^{(j)}\\|_2 \\le \\varepsilon \\max(1, \\|y^{(j)}\\|_2)$（对于一个小的容差 $\\varepsilon$）或达到最大迭代次数时，我们终止迭代。为提高鲁棒性，可以应用简单的回溯线搜索：如果残差的范数没有减小，则将步长乘以一个因子（例如减半）。\n\n谱半径评估：在每一步，我们显式计算 $J(y_n,t_n)$\n$$\nJ(y_n,t_n) = \\begin{bmatrix}\n-2 k_f m_n - k_m & k_r \\\\\nk_f m_n & -k_r\n\\end{bmatrix},\n$$\n计算其特征值 $\\lambda_1, \\lambda_2$，并设置 $\\rho(J) = \\max(|\\lambda_1|, |\\lambda_2|)$。刚度指标为 $s_n = \\rho(J)\\, \\Delta t$。\n\n从 $t=0$ 到 $t=T_{\\mathrm{end}}$ 使用固定步长 $\\Delta t$ 的算法流程：\n- 初始化 $n=0$，$t_0=0$，$y_0=\\begin{bmatrix}0\\\\0\\end{bmatrix}$，模式=显式，并将显式步、隐式步和模式切换的计数器设置为 $0$。\n- 对于 $n = 0,1,\\dots, N-1$ (其中 $N = \\lfloor T_{\\mathrm{end}}/\\Delta t \\rfloor$)：\n  - 计算 $J(y_n,t_n)$，找到 $\\rho(J)$，构造 $s_n = \\rho(J)\\, \\Delta t$。\n  - 使用阈值 $(\\theta_{\\mathrm{L}}, \\theta_{\\mathrm{U}})$ 应用迟滞逻辑。如果触发切换，则模式切换计数器加一。\n  - 使用当前模式前进一个步长（如果为显式，则用 RK4；如果为隐式，则用后向欧拉），在更新后强制非负性 $m \\ge 0, c \\ge 0$。\n  - 增加相应的显式或隐式步计数器。\n- 返回 $y_N \\approx y(T_{\\mathrm{end}})$ 的分量和计数器；将最终模式编码为 $0$（显式）和 $1$（隐式）。\n\n测试套件和预期的定性行为：\n- 案例 1：较小的 $G_0$ 和 $G_p$ 使 $m$ 保持较小，因此 $-2k_f m - k_m$ 保持适中，$s_n$ 保持在 $\\theta_{\\mathrm{L}}$ 以下。预期主要为显式步，很少或没有切换，最终模式为显式。\n- 案例 2：较大的 $G_0$ 和 $G_p$ 增加了 $m$，使 $|{-2k_f m - k_m}|$ 变大，从而 $s_n$ 迅速超过 $\\theta_{\\mathrm{U}}$。预期会早期切换到隐式并此后保持隐式，切换次数为零或一，最终模式为隐式。\n- 案例 3：中等强度的驱动力产生在迟滞带 $(\\theta_{\\mathrm{L}}, \\theta_{\\mathrm{U}})$ 上下振荡的 $s_n$，由于带很窄，会在脉冲之间引发多次切换。\n- 案例 4：与案例 3 相同的驱动力，但迟滞带更宽；系统在切换前能容忍更大范围的 $s_n$，导致与案例 3 相比切换次数更少。\n\n程序实现了以上所有内容，并为每个测试案例输出列表 $[\\, m(T_{\\mathrm{end}}),\\, c(T_{\\mathrm{end}}),\\, \\text{explicit\\_steps},\\, \\text{implicit\\_steps},\\, \\text{switches},\\, \\text{final\\_mode} \\,]$，其中 $m(T_{\\mathrm{end}})$ 和 $c(T_{\\mathrm{end}})$ 四舍五入到 $6$ 位小数。三角函数求值中的所有角度均以弧度为单位，所有量均为无量纲。单行输出按要求将四个案例的结果汇总为一个包含四个列表的列表。数值结果通过切换次数直接量化了迟滞效应，表明在案例 4 的更宽迟滞阈值下，相对于案例 3，切换次数减少了。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef f_vec(y, t, params):\n    m, c = y\n    G0, Gp, P, kf, kr, km = params['G0'], params['Gp'], params['P'], params['kf'], params['kr'], params['km']\n    s = np.sin(2.0 * np.pi * t / P)\n    G = G0 + Gp * max(0.0, s)**2\n    dm = G - kf * m * m + kr * c - km * m\n    dc = 0.5 * kf * m * m - kr * c\n    return np.array([dm, dc], dtype=float)\n\ndef jacobian(y, t, params):\n    m, c = y\n    kf, kr, km = params['kf'], params['kr'], params['km']\n    j11 = -2.0 * kf * m - km\n    j12 = kr\n    j21 = kf * m\n    j22 = -kr\n    return np.array([[j11, j12], [j21, j22]], dtype=float)\n\ndef spectral_radius(J):\n    ev = np.linalg.eigvals(J)\n    return float(np.max(np.abs(ev)))\n\ndef rk4_step(y, t, dt, params):\n    k1 = f_vec(y, t, params)\n    k2 = f_vec(y + 0.5 * dt * k1, t + 0.5 * dt, params)\n    k3 = f_vec(y + 0.5 * dt * k2, t + 0.5 * dt, params)\n    k4 = f_vec(y + dt * k3, t + dt, params)\n    y_next = y + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n    # Enforce nonnegativity\n    y_next = np.maximum(y_next, 0.0)\n    return y_next\n\ndef backward_euler_step(y, t, dt, params, newton_tol=1e-10, max_iter=30):\n    # Solve R(z) = z - y - dt * f(z, t+dt) = 0\n    t_new = t + dt\n    # Predictor: forward Euler\n    z = y + dt * f_vec(y, t, params)\n    # Newton iteration with simple backtracking\n    def residual(zv):\n        return zv - y - dt * f_vec(zv, t_new, params)\n    def jac_res(zv):\n        return np.eye(2) - dt * jacobian(zv, t_new, params)\n    R = residual(z)\n    for _ in range(max_iter):\n        Jres = jac_res(z)\n        try:\n            delta = np.linalg.solve(Jres, -R)\n        except np.linalg.LinAlgError:\n            # Fallback to small perturbation if singular; break and use current z\n            break\n        # Backtracking line search\n        alpha = 1.0\n        z_trial = z + alpha * delta\n        R_trial = residual(z_trial)\n        norm_R = np.linalg.norm(R)\n        norm_R_trial = np.linalg.norm(R_trial)\n        # Ensure sufficient decrease\n        while norm_R_trial > norm_R and alpha > 1e-4:\n            alpha *= 0.5\n            z_trial = z + alpha * delta\n            R_trial = residual(z_trial)\n            norm_R_trial = np.linalg.norm(R_trial)\n        z = z_trial\n        R = R_trial\n        if np.linalg.norm(alpha * delta) <= newton_tol * max(1.0, np.linalg.norm(z)):\n            break\n    z = np.maximum(z, 0.0)\n    return z\n\ndef simulate_case(case):\n    # Unpack case: (G0, Gp, P, kf, kr, km, dt, T_end, theta_L, theta_U)\n    G0, Gp, P, kf, kr, km, dt, T_end, theta_L, theta_U = case\n    params = {'G0': G0, 'Gp': Gp, 'P': P, 'kf': kf, 'kr': kr, 'km': km}\n    y = np.array([0.0, 0.0], dtype=float)\n    t = 0.0\n    N = int(round(T_end / dt))\n    mode = 'explicit'  # initial mode\n    exp_steps = 0\n    imp_steps = 0\n    switches = 0\n    for n in range(N):\n        # stiffness indicator s_n = rho(J(y_n, t_n)) * dt\n        J = jacobian(y, t, params)\n        rho = spectral_radius(J)\n        s = rho * dt\n        # hysteresis switching\n        if mode == 'explicit':\n            if s > theta_U:\n                mode = 'implicit'\n                switches += 1\n        else:  # implicit\n            if s < theta_L:\n                mode = 'explicit'\n                switches += 1\n        # step\n        if mode == 'explicit':\n            y = rk4_step(y, t, dt, params)\n            exp_steps += 1\n        else:\n            y = backward_euler_step(y, t, dt, params)\n            imp_steps += 1\n        t += dt\n    final_mode_indicator = 0 if mode == 'explicit' else 1\n    mT = round(float(y[0]), 6)\n    cT = round(float(y[1]), 6)\n    return [f\"{mT:.6f}\", f\"{cT:.6f}\", str(exp_steps), str(imp_steps), str(switches), str(final_mode_indicator)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: non-stiff baseline\n        (0.01, 0.02, 0.5, 50.0, 1.0, 1.0, 0.01, 2.0, 0.5, 0.7),\n        # Case 2: persistently stiff\n        (0.2, 1.0, 0.5, 50.0, 1.0, 1.0, 0.01, 2.0, 0.5, 0.7),\n        # Case 3: oscillatory stiffness, narrow hysteresis\n        (0.05, 0.5, 0.5, 50.0, 1.0, 1.0, 0.01, 2.0, 0.5, 0.7),\n        # Case 4: oscillatory stiffness, wide hysteresis\n        (0.05, 0.5, 0.5, 50.0, 1.0, 1.0, 0.01, 2.0, 0.3, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        res = simulate_case(case)\n        # Format as list string with correct separators\n        case_str = \"[\" + \",\".join(res) + \"]\"\n        results.append(case_str)\n\n    # Final print statement in the exact required format.\n    print(\"[\" + \",\".join(results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}