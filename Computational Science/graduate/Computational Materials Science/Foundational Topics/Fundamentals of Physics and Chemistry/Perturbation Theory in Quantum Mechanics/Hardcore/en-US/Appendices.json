{
    "hands_on_practices": [
        {
            "introduction": "This exercise provides a direct implementation of the formal machinery of degenerate perturbation theory, a crucial tool for understanding systems with high symmetry, such as molecular crystals. You will construct an effective Hamiltonian within a degenerate subspace to calculate how a symmetry-lowering perturbation splits energy levels. By comparing your results with an exact diagonalization, you will gain hands-on insight into the accuracy of first- and second-order corrections and the behavior of quantum states under perturbation .",
            "id": "3474534",
            "problem": "Consider a tight-binding surrogate of a highly symmetric molecular crystal used to model the single-particle Kohn-Sham operator from Density Functional Theory (DFT). The unperturbed Hamiltonian is a Hermitian matrix $H_0 \\in \\mathbb{R}^{4 \\times 4}$ with exact twofold degeneracy, and a symmetry-lowering perturbation $V \\in \\mathbb{R}^{4 \\times 4}$ is introduced. The total Hamiltonian is defined as $H(\\lambda) = H_0 + \\lambda V$ with $\\lambda \\in \\mathbb{R}$ a dimensionless parameter controlling the perturbation strength. All energies are to be treated in electronvolts (eV).\n\nThe matrices are specified as follows. The unperturbed Hamiltonian $H_0$ is diagonal:\n$$\nH_0 = \\mathrm{diag}(0.8,\\, 1.0,\\, 1.0,\\, 1.6)\\,,\n$$\nwhich contains an exact twofold degeneracy at $E_0 = 1.0\\,\\mathrm{eV}$ in the subspace spanned by the canonical basis vectors corresponding to indices $1$ and $2$ (using zero-based indexing). The perturbation $V$ is a Hermitian matrix that lowers symmetry by coupling the degenerate states and mixing them with the non-degenerate states:\n$$\nV =\n\\begin{pmatrix}\n0 & 0.1 & -0.1 & 0.02 \\\\\n0.1 & 0.05 & 0.2 & 0.05 \\\\\n-0.1 & 0.2 & -0.05 & 0.07 \\\\\n0.02 & 0.05 & 0.07 & 0\n\\end{pmatrix}\\,.\n$$\n\nStarting from the time-independent Schrödinger equation $H(\\lambda)|{\\psi}\\rangle = E(\\lambda)|{\\psi}\\rangle$ and the standard postulates of quantum mechanics for Hermitian operators, implement degenerate perturbation theory up to second order inside the degenerate manifold of $H_0$ to predict the splitting of the formerly degenerate energy level, and then compare it to benchmark “symmetry-adapted DFT” results taken here to be the exact eigenvalue splitting of $H(\\lambda)$ obtained by direct diagonalization.\n\nYour program must perform the following tasks for each given $\\lambda$:\n1. Identify the twofold degenerate subspace of $H_0$ at energy $E_0 = 1.0\\,\\mathrm{eV}$ and construct the projector $P$ onto this subspace, and the complementary projector $Q = I - P$.\n2. Compute the first-order effective Hamiltonian restricted to the degenerate manifold, $H_{\\mathrm{eff}}^{(1)}(\\lambda) = \\lambda\\,PVP$, and its eigenvalues to obtain the first-order energy corrections inside the degenerate subspace.\n3. Compute the second-order contribution to the effective Hamiltonian inside the degenerate manifold using the resolvent of $H_0$ restricted to the complementary subspace:\n$$\nH_{\\mathrm{eff}}^{(2)}(\\lambda) = \\lambda^2\\,PVQ\\,(E_0 I_Q - QH_0Q)^{-1}\\,QVP\\,,\n$$\nand form the total effective Hamiltonian $H_{\\mathrm{eff}}(\\lambda) = H_{\\mathrm{eff}}^{(1)}(\\lambda) + H_{\\mathrm{eff}}^{(2)}(\\lambda)$. Diagonalize $H_{\\mathrm{eff}}(\\lambda)$ to obtain the two energies within the degenerate subspace up to second order, and define the predicted splitting $\\Delta_{\\mathrm{PT}}(\\lambda)$ as the absolute difference of these two energies.\n4. Obtain the exact benchmark splitting $\\Delta_{\\mathrm{exact}}(\\lambda)$ by diagonalizing $H(\\lambda)$ directly and selecting the two eigenvalues whose eigenvectors have the largest total weight within the degenerate subspace (sum of squared magnitudes on indices $1$ and $2$). Define $\\Delta_{\\mathrm{exact}}(\\lambda)$ as the absolute difference of these two selected eigenvalues.\n5. Compute the relative error as a dimensionless decimal:\n$$\n\\varepsilon(\\lambda) =\n\\begin{cases}\n0.0 & \\text{if } \\Delta_{\\mathrm{exact}}(\\lambda) = 0,\\\\\n\\left|\\Delta_{\\mathrm{PT}}(\\lambda) - \\Delta_{\\mathrm{exact}}(\\lambda)\\right| \\big/ \\Delta_{\\mathrm{exact}}(\\lambda) & \\text{otherwise.}\n\\end{cases}\n$$\n\nUse the following test suite of perturbation strengths:\n$$\n\\lambda \\in \\{0.0,\\, 0.1,\\, 0.5,\\, 1.0\\}\\,.\n$$\n\nAll energies must be treated in $\\mathrm{eV}$, while the final reported quantities are dimensionless decimals. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered in the same sequence of the test suite values. For example: “[result\\_for\\_0.0,result\\_for\\_0.1,result\\_for\\_0.5,result\\_for\\_1.0]”.",
            "solution": "The user-provided problem has been assessed and is determined to be **valid**. It is a well-posed, scientifically grounded problem in quantum mechanics, specifically an application of time-independent degenerate perturbation theory to a tight-binding model, which is a common task in computational materials science. All required data and definitions are provided, and the problem is free of contradictions or ambiguities.\n\nHerein, a complete solution is presented.\n\n### 1. Theoretical Framework\n\nThe core of the problem is to compute the splitting of a degenerate energy level under a small perturbation, using two different methods: degenerate perturbation theory and exact diagonalization.\n\n**a. Unperturbed System and Degeneracy**\nThe unperturbed Hamiltonian, $H_0$, is given as a diagonal matrix:\n$$\nH_0 = \\mathrm{diag}(0.8,\\, 1.0,\\, 1.0,\\, 1.6)\n$$\nThe eigenvalues are the diagonal entries. There is a twofold degeneracy at energy $E_0 = 1.0 \\, \\mathrm{eV}$, corresponding to the basis states $|1\\rangle$ and $|2\\rangle$ (using zero-based indexing). The degenerate subspace, $D$, is spanned by $\\{|1\\rangle, |2\\rangle\\}$. The complementary subspace, $D_{\\perp}$, is spanned by $\\{|0\\rangle, |3\\rangle\\}$.\n\nWe define the projector onto the degenerate subspace $D$ as $P$, and onto the complementary subspace $D_{\\perp}$ as $Q$. In the canonical basis, these are:\n$$\nP = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 \\end{pmatrix}, \\quad Q = I - P = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}\n$$\n\n**b. Degenerate Perturbation Theory**\nThe total Hamiltonian is $H(\\lambda) = H_0 + \\lambda V$. We seek the corrections to the degenerate energy level $E_0$ by constructing an effective Hamiltonian, $H_{\\mathrm{eff}}$, that acts solely within the degenerate subspace $D$. The problem asks to compute this up to second order in $\\lambda$. The eigenvalues of $H_{\\mathrm{eff}}$ will be the energy corrections $\\Delta E$.\n\nThe effective Hamiltonian is given by $H_{\\mathrm{eff}}(\\lambda) = H_{\\mathrm{eff}}^{(1)}(\\lambda) + H_{\\mathrm{eff}}^{(2)}(\\lambda)$.\n\n**First-Order Contribution:**\nThe first-order term is $H_{\\mathrm{eff}}^{(1)}(\\lambda) = \\lambda\\,PVP$. This operator, when restricted to the degenerate subspace $D$, is represented by a $2 \\times 2$ matrix, $W_1$, whose elements are $(\\boldsymbol{W}_1)_{ij} = \\langle i|V|j\\rangle$ for $i, j \\in \\{1, 2\\}$.\n$$\n\\boldsymbol{W}_1 = \\begin{pmatrix} V_{11} & V_{12} \\\\ V_{21} & V_{22} \\end{pmatrix} = \\begin{pmatrix} 0.05 & 0.2 \\\\ 0.2 & -0.05 \\end{pmatrix}\n$$\n\n**Second-Order Contribution:**\nThe second-order term is $H_{\\mathrm{eff}}^{(2)}(\\lambda) = \\lambda^2\\,PVQ\\,(E_0 I_Q - QH_0Q)^{-1}\\,QVP$. This operator also acts within $D$. Its $2 \\times 2$ matrix representation, $\\boldsymbol{W}_2$, can be calculated by summing over the intermediate states $|k\\rangle$ in the complementary subspace $D_{\\perp}$:\n$$\n(\\boldsymbol{W}_2)_{ij} = \\sum_{k \\in D_{\\perp}} \\frac{\\langle i|V|k\\rangle\\langle k|V|j\\rangle}{E_0 - E_k} \\quad \\text{for } i, j \\in D\n$$\nThe states in $D_{\\perp}$ are $|0\\rangle$ and $|3\\rangle$, with unperturbed energies $E_0^{(0)} = 0.8 \\, \\mathrm{eV}$ and $E_3^{(0)} = 1.6 \\, \\mathrm{eV}$.\nThe components of $\\boldsymbol{W}_2$ are:\n$$\n(\\boldsymbol{W}_2)_{ij} = \\frac{V_{i0}V_{0j}}{E_0-E_0^{(0)}} + \\frac{V_{i3}V_{3j}}{E_0-E_3^{(0)}}\n$$\nFor $i, j \\in \\{1, 2\\}$ and using $E_0=1.0$, this yields:\n$$\n(\\boldsymbol{W}_2)_{11} = \\frac{V_{10}^2}{1.0-0.8} + \\frac{V_{13}^2}{1.0-1.6} = \\frac{0.1^2}{0.2} + \\frac{0.05^2}{-0.6} \\approx 0.045833\n$$\n$$\n(\\boldsymbol{W}_2)_{12} = \\frac{V_{10}V_{02}}{0.2} + \\frac{V_{13}V_{32}}{-0.6} = \\frac{(0.1)(-0.1)}{0.2} + \\frac{(0.05)(0.07)}{-0.6} \\approx -0.055833\n$$\n$$\n(\\boldsymbol{W}_2)_{21} = (\\boldsymbol{W}_2)_{12} \\quad (\\text{since } V \\text{ is Hermitian})\n$$\n$$\n(\\boldsymbol{W}_2)_{22} = \\frac{V_{20}^2}{0.2} + \\frac{V_{23}^2}{-0.6} = \\frac{(-0.1)^2}{0.2} + \\frac{0.07^2}{-0.6} \\approx 0.041833\n$$\n\n**Total Effective Hamiltonian:**\nThe total $2 \\times 2$ effective Hamiltonian matrix on the degenerate subspace $D$ is:\n$$\n\\boldsymbol{H}_{\\mathrm{eff,2\\times2}}(\\lambda) = \\lambda \\boldsymbol{W}_1 + \\lambda^2 \\boldsymbol{W}_2\n$$\nWe find the eigenvalues of this matrix, $\\Delta E_1(\\lambda)$ and $\\Delta E_2(\\lambda)$. The predicted energy splitting is then:\n$$\n\\Delta_{\\mathrm{PT}}(\\lambda) = |\\Delta E_1(\\lambda) - \\Delta E_2(\\lambda)|\n$$\n\n**c. Exact Diagonalization**\nThe benchmark splitting is obtained by direct numerical diagonalization of the full Hamiltonian $H(\\lambda) = H_0 + \\lambda V$. This yields four eigenvalues $E_i(\\lambda)$ and corresponding eigenvectors $|\\psi_i(\\lambda)\\rangle$.\nTo identify the two energies that evolved from the original degenerate level, we calculate the \"weight\" of each eigenvector $|\\psi_i\\rangle$ within the original degenerate subspace $D$:\n$$\nw_i = |\\langle 1|\\psi_i\\rangle|^2 + |\\langle 2|\\psi_i\\rangle|^2 = |\\psi_{i,1}|^2 + |\\psi_{i,2}|^2\n$$\nwhere $\\psi_{i,j}$ is the $j$-th component of the eigenvector $|\\psi_i\\rangle$. We select the two eigenvalues whose eigenvectors have the two largest weights. Let these eigenvalues be $E_a(\\lambda)$ and $E_b(\\lambda)$. The exact splitting is:\n$$\n\\Delta_{\\mathrm{exact}}(\\lambda) = |E_a(\\lambda) - E_b(\\lambda)|\n$$\n\n**d. Relative Error**\nFinally, the relative error between the perturbation theory result and the exact result is computed as:\n$$\n\\varepsilon(\\lambda) = \\left|\\Delta_{\\mathrm{PT}}(\\lambda) - \\Delta_{\\mathrm{exact}}(\\lambda)\\right| \\big/ \\Delta_{\\mathrm{exact}}(\\lambda)\n$$\nwith a special case for $\\Delta_{\\mathrm{exact}}(\\lambda) = 0$.\n\n### 2. Algorithmic Implementation\n\nThe Python implementation will follow these steps for each given value of $\\lambda$:\n\n1.  **Initialization**: Define the matrices $H_0$ and $V$ using `numpy` arrays. Define the degenerate energy $E_0$ and the indices for the degenerate ($P_{idx}$) and complementary ($Q_{idx}$) subspaces.\n2.  **Perturbation Theory Calculation**:\n    a. Construct the $2 \\times 2$ matrices $\\boldsymbol{W}_1$ and $\\boldsymbol{W}_2$ using the sub-blocks of $V$ and the energy denominators as derived above.\n    b. Form the $2 \\times 2$ effective Hamiltonian matrix $\\boldsymbol{H}_{\\mathrm{eff,2\\times2}}(\\lambda) = \\lambda \\boldsymbol{W}_1 + \\lambda^2 \\boldsymbol{W}_2$.\n    c. Compute its eigenvalues using `numpy.linalg.eigh`. The splitting $\\Delta_{\\mathrm{PT}}(\\lambda)$ is the absolute difference of these eigenvalues.\n3.  **Exact Diagonalization**:\n    a. Construct the full $4 \\times 4$ Hamiltonian matrix $H(\\lambda) = H_0 + \\lambda V$.\n    b. Compute its eigenvalues and eigenvectors using `numpy.linalg.eigh`.\n    c. For each eigenvector, calculate its weight in the degenerate subspace.\n    d. Identify the indices of the two eigenvectors with the largest weights.\n    e. The corresponding eigenvalues are the ones of interest. The splitting $\\Delta_{\\mathrm{exact}}(\\lambda)$ is their absolute difference.\n4.  **Error Calculation**: Compute the relative error $\\varepsilon(\\lambda)$ according to the given formula.\n5.  **Iteration**: Repeat for all values in the test suite for $\\lambda$ and store the results.\n6.  **Output**: Format the collected results into the specified string format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the degenerate perturbation theory problem for a given set of parameters.\n    \"\"\"\n    # Define the unperturbed Hamiltonian H_0 as a diagonal matrix.\n    # Eigenenergies are in eV.\n    H0 = np.diag([0.8, 1.0, 1.0, 1.6])\n\n    # Define the perturbation matrix V.\n    V = np.array([\n        [0.0,  0.1, -0.1,  0.02],\n        [0.1,  0.05,  0.2,  0.05],\n        [-0.1,  0.2, -0.05,  0.07],\n        [0.02, 0.05,  0.07,  0.0]\n    ])\n\n    # Parameters for the degenerate-subspace calculation.\n    E0 = 1.0  # Degenerate energy level in eV.\n    p_indices = [1, 2]  # Indices of the degenerate subspace (P-space).\n    q_indices = [0, 3]  # Indices of the complementary subspace (Q-space).\n\n    # Test suite for the perturbation strength lambda.\n    test_cases = [0.0, 0.1, 0.5, 1.0]\n\n    results = []\n    for lam in test_cases:\n        # --- Degenerate Perturbation Theory Calculation ---\n\n        # W1 is the 2x2 matrix of the perturbation V restricted to the P-space.\n        # This corresponds to the first-order correction.\n        W1 = V[np.ix_(p_indices, p_indices)]\n\n        # W2 is the 2x2 matrix for the second-order correction.\n        # It is calculated using the formula derived from perturbation theory.\n        \n        # V_PQ block connects P-space to Q-space.\n        V_PQ = V[np.ix_(p_indices, q_indices)] \n        # V_QP block connects Q-space to P-space.\n        V_QP = V[np.ix_(q_indices, p_indices)]\n\n        # Energy denominators for the states in the Q-space.\n        E_q = H0.diagonal()[q_indices]\n        energy_denominators = E0 - E_q\n        \n        # The resolvent matrix (diagonal in this basis).\n        # We must handle the case of zero denominators, though not expected here.\n        with np.errstate(divide='raise'):\n            resolvent_diag = 1.0 / energy_denominators\n        \n        # Calculate W2 = V_PQ @ Resolvent @ V_QP\n        W2 = V_PQ @ np.diag(resolvent_diag) @ V_QP\n\n        # Form the 2x2 effective Hamiltonian matrix up to second order.\n        H_eff_2x2 = lam * W1 + lam**2 * W2\n\n        # Eigenvalues of the effective Hamiltonian are the energy shifts.\n        energy_shifts_pt = np.linalg.eigvalsh(H_eff_2x2)\n\n        # The predicted splitting is the difference between these energy shifts.\n        delta_pt = np.abs(energy_shifts_pt[1] - energy_shifts_pt[0])\n\n        # --- Exact Diagonalization Calculation ---\n        \n        # Construct the full Hamiltonian H(lambda) = H0 + lambda * V.\n        H_lam = H0 + lam * V\n\n        # Diagonalize the full Hamiltonian. eigh is used for Hermitian matrices.\n        exact_energies, exact_evecs = np.linalg.eigh(H_lam)\n\n        # Identify the two states that evolved from the degenerate subspace.\n        # These are the states whose eigenvectors have the largest weight in the P-space.\n        weights = np.sum(np.abs(exact_evecs[p_indices, :])**2, axis=0)\n        \n        # Get the indices of the two largest weights.\n        top_two_indices = np.argsort(weights)[-2:]\n        \n        # Select the corresponding exact energies.\n        relevant_energies = exact_energies[top_two_indices]\n\n        # The exact splitting is the difference between these two energies.\n        delta_exact = np.abs(relevant_energies[1] - relevant_energies[0])\n\n        # --- Relative Error Calculation ---\n\n        if delta_exact == 0.0:\n            # If there is no splitting, the perturbation theory should also predict none.\n            # In this case, relative error is 0.\n            relative_error = 0.0\n        else:\n            relative_error = np.abs(delta_pt - delta_exact) / delta_exact\n            \n        results.append(relative_error)\n\n    # Format the final output as a comma-separated list in brackets.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Building on fundamental concepts, this practice explores a common scenario in materials science where first-order perturbative effects are forbidden by symmetry, as seen in the valley splitting of silicon. You will apply near-degenerate perturbation theory to discover that the leading-order energy splitting arises from second-order virtual transitions to a remote state. This exercise is key to understanding how higher-order processes govern important physical phenomena and provides a benchmark against an exact solution for a minimal, physically-motivated model .",
            "id": "3474558",
            "problem": "Consider a minimal, symmetry-consistent near-degenerate perturbation theory model for valley splitting in strained silicon within the conduction-band manifold relevant to computational materials science. The physical base is the time-independent Schrödinger equation and standard perturbation theory. Let the unperturbed Hamiltonian be $H_0$ with a two-dimensional degenerate subspace spanned by $\\{ |1 \\rangle, |2 \\rangle \\}$ at energy $E_0$ and a single remote state $|r \\rangle$ at energy $E_r$, with $E_r > E_0$. The perturbation is linear in the uniaxial strain magnitude $\\lambda$ and is given by $V(\\lambda) = \\lambda W$, where $W$ is a strain-induced operator. Assume that first-order intra-subspace matrix elements vanish by symmetry, namely $W_{11} = W_{22} = W_{12} = W_{21} = 0$, and that the only nonzero couplings are between the valley subspace and the remote state with $W_{1r} = g$ and $W_{2r} = -g$, where $g$ is a real deformation potential amplitude. This captures the physically relevant situation in which symmetry forbids first-order splitting in the valley subspace, and the leading splitting arises at second order via virtual transitions through $|r \\rangle$.\n\nUsing degenerate perturbation theory, define the projector $P$ onto the valley subspace and $Q = I - P$. The effective Hamiltonian in the valley subspace up to second order in $\\lambda$ is\n$$\nH_{\\mathrm{eff}}^{(2)}(\\lambda) = E_0 I + \\lambda P W P + \\lambda^2 P W Q \\left( E_0 I - Q H_0 Q \\right)^{-1} Q W P,\n$$\nwhere $I$ is the identity operator on the appropriate space. In this model, $P W P = 0$ and the second-order term is nonzero due to $W_{ir}$, $i \\in \\{1,2\\}$.\n\nYour tasks are:\n- Derive the valley splitting $\\Delta E(\\lambda)$, defined as the difference between the two eigenvalues of $H_{\\mathrm{eff}}^{(2)}(\\lambda)$ in the valley subspace, keeping terms up to second order in $\\lambda$.\n- Benchmark this perturbative $\\Delta E(\\lambda)$ against the exact splitting obtained by diagonalizing the full Hamiltonian\n$$\nH(\\lambda) =\n\\begin{pmatrix}\nE_0 & 0 & \\lambda g \\\\\n0 & E_0 & -\\lambda g \\\\\n\\lambda g & -\\lambda g & E_r\n\\end{pmatrix},\n$$\nwhich is a $3 \\times 3$ matrix in the basis $\\{ |1 \\rangle, |2 \\rangle, |r \\rangle \\}$.\n\nUse the following scientifically plausible constants, expressed in electronvolts (eV):\n- $E_0 = 0.00 \\ \\text{eV}$,\n- $E_r = 0.20 \\ \\text{eV}$,\n- $g = 0.10 \\ \\text{eV}$.\n\nConstruct a test suite over four strain magnitudes:\n- $\\lambda = 0.00$,\n- $\\lambda = 0.001$,\n- $\\lambda = 0.020$,\n- $\\lambda = 0.050$.\n\nFor each $\\lambda$ in the test suite:\n- Compute the perturbative splitting $\\Delta E_{\\mathrm{pert}}(\\lambda)$ using the effective Hamiltonian up to second order in $\\lambda$ as derived.\n- Compute the exact splitting $\\Delta E_{\\mathrm{exact}}(\\lambda)$ by diagonalizing $H(\\lambda)$ and taking the difference between its two lowest eigenvalues.\n\nAll energies must be expressed in electronvolts (eV), rounded to six decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is a two-element list $[\\Delta E_{\\mathrm{pert}}(\\lambda), \\Delta E_{\\mathrm{exact}}(\\lambda)]$ corresponding to one $\\lambda$ in the test suite, in the same order. For example, an output for two test cases would look like $[[x_1,y_1],[x_2,y_2]]$, where $x_i$ and $y_i$ are floats in eV rounded to six decimal places.\n\nThe problem must be solved from first principles, starting with the definitions and laws described above and using standard results from perturbation theory. No shortcut formulas for the final splitting should be given in the problem statement. In absence of external first-principles data such as those from Density Functional Theory (DFT), use exact diagonalization of the minimal Hamiltonian $H(\\lambda)$ as the benchmark reference.",
            "solution": "The problem statement has been validated and is deemed **valid**. It is scientifically grounded in the principles of quantum mechanics, specifically near-degenerate perturbation theory. The problem is well-posed, with all necessary constants, definitions, and a clear objective. It is also objective, using formal and precise language free of subjective claims. The provided minimal model and parameters for valley splitting in silicon are physically motivated and computationally tractable.\n\n### 1. Derivation of Perturbative Valley Splitting, $\\Delta E_{\\mathrm{pert}}(\\lambda)$\n\nWe begin with the provided formula for the effective Hamiltonian in the degenerate valley subspace $\\{|1 \\rangle, |2 \\rangle\\}$ up to second order in the strain parameter $\\lambda$:\n$$\nH_{\\mathrm{eff}}^{(2)}(\\lambda) = E_0 I + \\lambda P W P + \\lambda^2 P W Q ( E_0 I - Q H_0 Q )^{-1} Q W P\n$$\nHere, $P = |1 \\rangle\\langle 1| + |2 \\rangle\\langle 2|$ is the projector onto the degenerate subspace, and $Q = I - P = |r \\rangle\\langle r|$ is the projector onto the remote state subspace, as the total Hilbert space is spanned by $\\{|1 \\rangle, |2 \\rangle, |r \\rangle\\}$.\n\nWe evaluate each term's contribution to the $2 \\times 2$ matrix representation of $H_{\\mathrm{eff}}^{(2)}(\\lambda)$ in the $\\{|1 \\rangle, |2 \\rangle\\}$ basis.\n\n- **Zeroth-order term**: $E_0 I$ is represented by the matrix $\\begin{pmatrix} E_0 & 0 \\\\ 0 & E_0 \\end{pmatrix}$.\n\n- **First-order term**: $\\lambda P W P$. The matrix elements are $\\lambda \\langle i | W | j \\rangle = \\lambda W_{ij}$ for $i,j \\in \\{1,2\\}$. The problem states that by symmetry, $W_{11} = W_{22} = W_{12} = W_{21} = 0$. Therefore, this term is the zero matrix: $\\lambda \\begin{pmatrix} 0 & 0 \\\\ 0 & 0 \\end{pmatrix}$.\n\n- **Second-order term**: $H^{(2)} = \\lambda^2 P W Q ( E_0 I - Q H_0 Q )^{-1} Q W P$. Its matrix elements $(H^{(2)})_{ij}$ for $i,j \\in \\{1,2\\}$ are given by:\n$$\n(H^{(2)})_{ij} = \\lambda^2 \\langle i | W Q ( E_0 I - Q H_0 Q )^{-1} Q W | j \\rangle\n$$\nInserting a complete set of states, which is just $|r \\rangle$ for the subspace projected by $Q$, we get:\n$$\n(H^{(2)})_{ij} = \\lambda^2 \\langle i | W | r \\rangle \\langle r | ( E_0 I - Q H_0 Q )^{-1} | r \\rangle \\langle r | W | j \\rangle\n$$\nThe operator in the middle acts on the eigenstate $|r \\rangle$. Since $H_0 |r \\rangle = E_r |r \\rangle$ and $Q |r \\rangle = |r \\rangle$, we have $(E_0 I - Q H_0 Q) |r \\rangle = (E_0 - E_r)|r \\rangle$. The inverse operator thus yields $(E_0 - E_r)^{-1}$. The expression simplifies to:\n$$\n(H^{(2)})_{ij} = \\lambda^2 W_{ir} \\frac{1}{E_0 - E_r} W_{rj}\n$$\nUsing the given non-zero couplings $W_{1r} = g$, $W_{2r} = -g$, and noting that $W_{rj} = \\langle r | W | j \\rangle = \\langle j | W | r \\rangle^* = W_{jr}^* = W_{jr}$ because $g$ is real, we find the matrix elements:\n- $(H^{(2)})_{11} = \\lambda^2 \\frac{W_{1r} W_{r1}}{E_0 - E_r} = \\lambda^2 \\frac{g \\cdot g}{E_0 - E_r} = \\frac{\\lambda^2 g^2}{E_0 - E_r}$\n- $(H^{(2)})_{22} = \\lambda^2 \\frac{W_{2r} W_{r2}}{E_0 - E_r} = \\lambda^2 \\frac{(-g) \\cdot (-g)}{E_0 - E_r} = \\frac{\\lambda^2 g^2}{E_0 - E_r}$\n- $(H^{(2)})_{12} = \\lambda^2 \\frac{W_{1r} W_{r2}}{E_0 - E_r} = \\lambda^2 \\frac{g \\cdot (-g)}{E_0 - E_r} = -\\frac{\\lambda^2 g^2}{E_0 - E_r}$\n- $(H^{(2)})_{21} = (H^{(2)})_{12} = -\\frac{\\lambda^2 g^2}{E_0 - E_r}$\n\nCombining all terms, the effective Hamiltonian is:\n$$\nH_{\\mathrm{eff}}^{(2)}(\\lambda) = \\begin{pmatrix} E_0 + \\frac{\\lambda^2 g^2}{E_0 - E_r} & -\\frac{\\lambda^2 g^2}{E_0 - E_r} \\\\ -\\frac{\\lambda^2 g^2}{E_0 - E_r} & E_0 + \\frac{\\lambda^2 g^2}{E_0 - E_r} \\end{pmatrix}\n$$\nThe eigenvalues $E'$ of a $2 \\times 2$ matrix of the form $\\begin{pmatrix} A & B \\\\ B & A \\end{pmatrix}$ are $A \\pm B$. Here, $A = E_0 + \\frac{\\lambda^2 g^2}{E_0 - E_r}$ and $B = -\\frac{\\lambda^2 g^2}{E_0 - E_r}$.\nThe eigenvalues are:\n- $E'_1 = A+B = E_0 + \\frac{\\lambda^2 g^2}{E_0 - E_r} - \\frac{\\lambda^2 g^2}{E_0 - E_r} = E_0$\n- $E'_2 = A-B = E_0 + \\frac{\\lambda^2 g^2}{E_0 - E_r} - (-\\frac{\\lambda^2 g^2}{E_0 - E_r}) = E_0 + \\frac{2\\lambda^2 g^2}{E_0 - E_r}$\n\nThe valley splitting $\\Delta E_{\\mathrm{pert}}(\\lambda)$ is the absolute difference between these eigenvalues:\n$$\n\\Delta E_{\\mathrm{pert}}(\\lambda) = |E'_1 - E'_2| = \\left| -\\frac{2\\lambda^2 g^2}{E_0 - E_r} \\right| = \\frac{2\\lambda^2 g^2}{E_r - E_0}\n$$\nThis is the final expression for the perturbative splitting up to second order.\n\n### 2. Derivation of Exact Valley Splitting, $\\Delta E_{\\mathrm{exact}}(\\lambda)$\n\nThe exact splitting is found by diagonalizing the full $3 \\times 3$ Hamiltonian:\n$$\nH(\\lambda) =\n\\begin{pmatrix}\nE_0 & 0 & \\lambda g \\\\\n0 & E_0 & -\\lambda g \\\\\n\\lambda g & -\\lambda g & E_r\n\\end{pmatrix}\n$$\nThe eigenvalues $E$ are the roots of the characteristic equation $\\det(H(\\lambda) - E I) = 0$:\n$$\n\\det \\begin{pmatrix} E_0 - E & 0 & \\lambda g \\\\ 0 & E_0 - E & -\\lambda g \\\\ \\lambda g & -\\lambda g & E_r - E \\end{pmatrix} = 0\n$$\nExpanding the determinant along the first row:\n$$\n(E_0 - E) \\left[ (E_0 - E)(E_r - E) - (-\\lambda g)(-\\lambda g) \\right] - 0 + (\\lambda g) \\left[ 0 - (E_0 - E)(\\lambda g) \\right] = 0\n$$\n$$\n(E_0 - E) \\left[ (E_0 - E)(E_r - E) - \\lambda^2 g^2 \\right] - \\lambda^2 g^2 (E_0 - E) = 0\n$$\n$$\n(E_0 - E) \\left[ (E_0 - E)(E_r - E) - 2\\lambda^2 g^2 \\right] = 0\n$$\nThis equation yields one root immediately: $E_1 = E_0$. The other two roots come from the quadratic equation:\n$$\n(E_0 - E)(E_r - E) - 2\\lambda^2 g^2 = 0 \\implies E^2 - (E_0 + E_r)E + E_0 E_r - 2\\lambda^2 g^2 = 0\n$$\nUsing the quadratic formula, the other two eigenvalues are:\n$$\nE = \\frac{(E_0 + E_r) \\pm \\sqrt{(E_0 + E_r)^2 - 4(E_0 E_r - 2\\lambda^2 g^2)}}{2}\n$$\n$$\nE = \\frac{(E_0 + E_r) \\pm \\sqrt{E_0^2 + 2E_0E_r + E_r^2 - 4E_0E_r + 8\\lambda^2 g^2}}{2} = \\frac{(E_0 + E_r) \\pm \\sqrt{(E_r - E_0)^2 + 8\\lambda^2 g^2}}{2}\n$$\nIn the limit $\\lambda \\to 0$, the roots of the quadratic become $E_0$ and $E_r$. Thus, the two lowest eigenvalues of $H(\\lambda)$, corresponding to the perturbed valley states, are:\n- $E_1 = E_0$\n- $E_2 = \\frac{(E_0 + E_r) - \\sqrt{(E_r - E_0)^2 + 8\\lambda^2 g^2}}{2}$\n\nThe exact valley splitting $\\Delta E_{\\mathrm{exact}}(\\lambda)$ is the absolute difference between these two lowest eigenvalues:\n$$\n\\Delta E_{\\mathrm{exact}}(\\lambda) = |E_1 - E_2| = \\left| E_0 - \\frac{E_0 + E_r - \\sqrt{(E_r - E_0)^2 + 8\\lambda^2 g^2}}{2} \\right|\n$$\n$$\n\\Delta E_{\\mathrm{exact}}(\\lambda) = \\left| \\frac{2E_0 - E_0 - E_r + \\sqrt{(E_r - E_0)^2 + 8\\lambda^2 g^2}}{2} \\right|\n$$\n$$\n\\Delta E_{\\mathrm{exact}}(\\lambda) = \\left| \\frac{-(E_r - E_0) + \\sqrt{(E_r - E_0)^2 + 8\\lambda^2 g^2}}{2} \\right|\n$$\nSince $\\sqrt{(E_r - E_0)^2 + 8\\lambda^2 g^2} > (E_r - E_0)$, the numerator is positive.\n$$\n\\Delta E_{\\mathrm{exact}}(\\lambda) = \\frac{\\sqrt{(E_r - E_0)^2 + 8\\lambda^2 g^2} - (E_r - E_0)}{2}\n$$\nThis is the final expression for the exact splitting.\n\n### 3. Numerical Calculation\nThe derived formulas will be used to compute the splittings for the specified parameters: $E_0 = 0.00 \\ \\text{eV}$, $E_r = 0.20 \\ \\text{eV}$, $g = 0.10 \\ \\text{eV}$, and for each $\\lambda \\in \\{0.00, 0.001, 0.020, 0.050\\}$. The results will be rounded to six decimal places as requested.\n\nThe implementation will calculate:\n- $\\Delta E_{\\mathrm{pert}}(\\lambda) = \\frac{2\\lambda^2 (0.10)^2}{0.20 - 0.00} = \\frac{0.02 \\lambda^2}{0.20} = 0.1 \\lambda^2$\n- $\\Delta E_{\\mathrm{exact}}(\\lambda) = \\frac{\\sqrt{(0.20)^2 + 8\\lambda^2 (0.10)^2} - 0.20}{2} = \\frac{\\sqrt{0.04 + 0.08 \\lambda^2} - 0.20}{2}$\n\nThe results for each $\\lambda$ will be compiled into the final output format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for and compares perturbative and exact valley splitting in a minimal\n    3-level quantum system model.\n    \"\"\"\n    # Define the scientifically plausible constants in units of electronvolts (eV).\n    E0 = 0.00\n    Er = 0.20\n    g = 0.10\n\n    # Define the test suite of strain magnitudes.\n    test_cases = [0.00, 0.001, 0.020, 0.050]\n\n    results = []\n    for lam in test_cases:\n        # Calculate perturbative splitting using the derived formula:\n        # delta_E_pert = 2 * lambda^2 * g^2 / (Er - E0)\n        pert_split = (2 * lam**2 * g**2) / (Er - E0)\n\n        # Calculate exact splitting using the derived formula:\n        # delta_E_exact = (sqrt((Er - E0)^2 + 8 * lambda^2 * g^2) - (Er - E0)) / 2\n        # Use numpy.sqrt for numerical stability and correctness.\n        er_minus_e0 = Er - E0\n        exact_split = (np.sqrt(er_minus_e0**2 + 8 * lam**2 * g**2) - er_minus_e0) / 2\n        \n        # Store the pair of results for the current lambda.\n        # The problem requires the output numbers to be rounded to six decimal places,\n        # and formatted as a list of lists of floats without extra spaces.\n        # We format the numbers into strings with the required precision.\n        result_pair_str = f\"[{pert_split:.6f},{exact_split:.6f}]\"\n        results.append(result_pair_str)\n\n    # Final print statement in the exact required format: [[x1,y1],[x2,y2],...]\n    # The list `results` contains strings that are already formatted as \"[n1,n2]\",\n    # so we join them with commas and enclose in an outer pair of brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice introduces the powerful Green's function formalism, a cornerstone of modern computational materials science for studying defects, surfaces, and quantum transport. You will use the Dyson equation to derive a perturbative series for the local density of states at a surface and contrast this expansion with an exact, non-perturbative recursive calculation. This exercise illuminates the connection between the Dyson series and direct solutions, demonstrating a fundamental technique for modeling localized perturbations in extended systems .",
            "id": "3474571",
            "problem": "Consider a one-dimensional tight-binding representation of a crystalline slab along the surface-normal direction, where the slab consists of $N$ atomic layers with open boundary conditions. Each layer is modeled by a single orbital with on-site energy $\\,\\epsilon\\,$ and nearest-neighbor hopping $\\,t\\,$ between adjacent layers. A weak surface perturbation is present as an additional on-site energy $\\,v\\,$ applied only to the top surface layer (layer index $\\,0\\,$). Work within the framework of time-independent perturbation theory in quantum mechanics and the retarded Green's function formalism used in computational materials science.\n\nDefine the retarded Green's function operator as $\\,G(z)=(z-H)^{-1}\\,$ for complex energy $\\,z=E+i\\eta\\,$ with $\\,\\eta>0\\,$ small. The unperturbed Hamiltonian $\\,H_0\\,$ corresponds to the slab without the surface perturbation, and the perturbation $\\,V\\,$ acts only at the surface layer $\\,0\\,$. Focus on the surface-local Green's function element $\\,G_{00}(E)\\,$ and the associated local density of states at the surface,\n$$\\rho_0(E)=-\\frac{1}{\\pi}\\,\\mathrm{Im}\\,G_{00}(E).$$\n\nYour tasks are:\n- Starting from fundamental operator identities of perturbation theory and Green's functions, obtain a systematic series expansion in powers of the surface potential $\\,v\\,$ for the surface-local Green's function element $\\,G_{00}(E)\\,$ built from the unperturbed resolvent $\\,G_0(z)=(z-H_0)^{-1}\\,$. Truncate this series at orders $\\,M=0,1,2,3\\,$ to get approximations $\\,G^{(M)}_{00}(E)\\,$.\n- Independently compute the exact $\\,G_{00}(E)\\,$ for the finite slab using a recursive Green's function method suitable for block tridiagonal Hamiltonians, and from it compute the exact local density of states $\\,\\rho^{\\mathrm{exact}}_0(E)$ for the slab with the surface perturbation included.\n- For each truncation order $\\,M\\in\\{0,1,2,3\\}\\,$, compute the approximate local density of states $\\,\\rho^{(M)}_0(E)=-\\frac{1}{\\pi}\\,\\mathrm{Im}\\,G^{(M)}_{00}(E)\\,$ and quantify the truncation error as the relative error\n$$\\delta^{(M)}=\\frac{\\left|\\rho^{(M)}_0(E)-\\rho^{\\mathrm{exact}}_0(E)\\right|}{\\max\\left(\\left|\\rho^{\\mathrm{exact}}_0(E)\\right|,\\varepsilon_{\\mathrm{ref}}\\right)},$$\nwhere $\\,\\varepsilon_{\\mathrm{ref}}\\,$ is a small positive reference to avoid division by zero. Take $\\,\\varepsilon_{\\mathrm{ref}}=10^{-15}\\,$. All energies $\\,E,\\,\\epsilon,\\,t,\\,v,\\,\\eta\\,$ are in electronvolts (eV). The final errors $\\,\\delta^{(M)}\\,$ are dimensionless and must be reported as decimals (not percentages).\n\nImplement both computations in a single program:\n- The perturbative series construction must start from the unperturbed resolvent $\\,G_0(z)\\,$ for the slab.\n- The exact computation must be performed via a layer-by-layer recursive Green's function suitable for a finite tridiagonal chain with open boundaries, not via direct full-matrix inversion.\n\nUse the following test suite (each tuple is $(N,t,\\epsilon,v,E,\\eta)$, with energies in eV):\n1. $(200,\\,1.0,\\,0.0,\\,0.05,\\,0.0,\\,10^{-3})$ a representative mid-band case with weak perturbation.\n2. $(200,\\,1.0,\\,0.0,\\,0.0,\\,0.5,\\,10^{-4})$ a zero-perturbation consistency case.\n3. $(200,\\,1.0,\\,0.0,\\,0.2,\\,1.95,\\,10^{-3})$ an energy near the upper band edge to probe series convergence stress.\n4. $(10,\\,1.0,\\,0.2,\\,0.1,\\,0.2,\\,10^{-3})$ a short slab with nonzero baseline on-site energy.\n\nFor each test case, compute the four relative errors $\\,\\delta^{(M)}\\,$ for $\\,M=0,1,2,3\\,$. Your program should produce a single line of output containing all results for the entire test suite as a comma-separated list enclosed in square brackets, ordered by test case and within each test case by increasing $\\,M\\,$, i.e.,\n$$[\\delta^{(0)}_{\\text{case 1}},\\delta^{(1)}_{\\text{case 1}},\\delta^{(2)}_{\\text{case 1}},\\delta^{(3)}_{\\text{case 1}},\\ldots,\\delta^{(0)}_{\\text{case 4}},\\delta^{(1)}_{\\text{case 4}},\\delta^{(2)}_{\\text{case 4}},\\delta^{(3)}_{\\text{case 4}}].$$\nNo other output is permitted. Angles are not involved. Ensure numerical stability with the specified small $\\,\\eta\\,$ and $\\,\\varepsilon_{\\mathrm{ref}}\\,$. The final numerical outputs are floats and do not carry units.",
            "solution": "The problem requires a comparison between a perturbative expansion and an exact calculation for the surface-local Green's function and the corresponding local density of states (LDOS) of a one-dimensional tight-binding slab. The analysis will be performed within the framework of retarded Green's functions and time-independent perturbation theory.\n\nFirst, we define the system and its Hamiltonian. The system is a linear chain of $N$ sites (layers) with open boundary conditions. The Hamiltonian $H$ can be separated into an unperturbed part $H_0$ and a perturbation $V$.\nThe unperturbed Hamiltonian $H_0$ describes the slab with a uniform on-site energy $\\epsilon$ and nearest-neighbor hopping $t$. In the site basis $\\{|0\\rangle, |1\\rangle, \\ldots, |N-1\\rangle\\}$, its matrix elements are:\n$$ (H_0)_{ij} = \\epsilon \\delta_{ij} + t (\\delta_{i,j+1} + \\delta_{i,j-1}) $$\nThis is a symmetric tridiagonal matrix.\nThe perturbation $V$ is a purely local potential $v$ applied only to the surface layer, site $|0\\rangle$. Thus, $V$ has only one non-zero matrix element:\n$$ V_{ij} = v \\delta_{i0} \\delta_{j0} \\implies V = v |0\\rangle\\langle0| $$\nThe full Hamiltonian is $H = H_0 + V$.\n\nThe retarded Green's function operator is defined as $G(z) = (z-H)^{-1}$, where $z = E+i\\eta$ is a complex energy with a small positive imaginary part $\\eta > 0$. The unperturbed Green's function is $G_0(z) = (z-H_0)^{-1}$. The surface-local Green's function is the matrix element $G_{00}(z) = \\langle 0 | G(z) | 0 \\rangle$, and the surface LDOS is $\\rho_0(E) = -\\frac{1}{\\pi}\\mathrm{Im}[G_{00}(E+i\\eta)]$.\n\n**Perturbative Expansion**\nThe perturbative series for the Green's function is derived from the Dyson equation, a fundamental operator identity:\n$$ G = G_0 + G_0 V G $$\nTo find the specific matrix element $G_{00}$, we project this equation onto the basis states:\n$$ G_{00} = \\langle 0 | G | 0 \\rangle = \\langle 0 | G_0 | 0 \\rangle + \\langle 0 | G_0 V G | 0 \\rangle $$\n$$ G_{00} = (G_0)_{00} + \\sum_{k,l} \\langle 0 | G_0 | k \\rangle \\langle k | V | l \\rangle \\langle l | G | 0 \\rangle $$\nSubstituting $V_{kl} = v \\delta_{k0} \\delta_{l0}$:\n$$ G_{00} = (G_0)_{00} + \\sum_{k,l} (G_0)_{0k} (v \\delta_{k0} \\delta_{l0}) G_{l0} $$\n$$ G_{00} = (G_0)_{00} + v (G_0)_{00} G_{00} $$\nThis algebraic equation can be solved exactly for $G_{00}$:\n$$ G_{00}(1 - v(G_0)_{00}) = (G_0)_{00} \\implies G_{00} = \\frac{(G_0)_{00}}{1 - v(G_0)_{00}} $$\nAssuming the perturbation is weak such that $|v(G_0)_{00}| < 1$, we can expand the denominator as a geometric series:\n$$ G_{00} = (G_0)_{00} \\sum_{n=0}^{\\infty} [v(G_0)_{00}]^n = \\sum_{n=0}^{\\infty} v^n ((G_0)_{00})^{n+1} $$\nThe problem asks to truncate this series at order $M$. The $M$-th order approximation $G_{00}^{(M)}$ is the sum up to the $v^M$ term:\n$$ G_{00}^{(M)} = \\sum_{n=0}^{M} v^n ((G_0)_{00})^{n+1} $$\nSpecifically, for $M \\in \\{0, 1, 2, 3\\}$:\n- $G_{00}^{(0)} = (G_0)_{00}$\n- $G_{00}^{(1)} = (G_0)_{00} + v((G_0)_{00})^2$\n- $G_{00}^{(2)} = (G_0)_{00} + v((G_0)_{00})^2 + v^2((G_0)_{00})^3$\n- $G_{00}^{(3)} = (G_0)_{00} + v((G_0)_{00})^2 + v^2((G_0)_{00})^3 + v^3((G_0)_{00})^4$\n\nTo use this expansion, we first need to compute the unperturbed surface-local Green's function, $(G_0)_{00}$.\n\n**Recursive Green's Function Method**\nThe problem mandates a recursive, layer-by-layer method for computing the Green's functions, which avoids full matrix inversion. This is a standard technique in computational physics. The local Green's function at a site can be expressed in terms of the site's energy and the self-energy, which encapsulates the effect of the rest of the system coupled to that site.\n\nThe full system's surface Green's function $G_{00}$ is for site $0$, which has on-site energy $\\epsilon+v$ and is coupled to the rest of the chain (sites $1, \\ldots, N-1$). Its Green's function is:\n$$ G_{00}(z) = \\frac{1}{z - (\\epsilon+v) - \\Sigma(z)} $$\nHere, $\\Sigma(z)$ is the self-energy at site $0$ due to its coupling to site $1$. It is given by $\\Sigma(z) = t \\cdot g_{\\text{rest}} \\cdot t = t^2 g_{\\text{rest}}$, where $g_{\\text{rest}}$ is the surface Green's function of the isolated subsystem of sites $1, \\ldots, N-1$. This subsystem is an unperturbed chain of length $N-1$.\n\nThe unperturbed surface Green's function $(G_0)_{00}$ is calculated similarly, but with the unperturbed on-site energy $\\epsilon$:\n$$ (G_0)_{00}(z) = \\frac{1}{z - \\epsilon - \\Sigma(z)} $$\nBoth calculations require the same self-energy $\\Sigma(z)$.\n\nThe self-energy $\\Sigma(z)$ is computed by finding the surface Green's function of the remaining chain of length $N-1$. This can be done recursively. Let $g_k(z)$ be the surface Green's function of an unperturbed, isolated chain of length $k$.\nFor $k=1$, the chain is a single site, so $g_1(z) = (z-\\epsilon)^{-1}$.\nFor a chain of length $k$, its surface site is coupled to a sub-chain of length $k-1$. The surface Green's function follows the recurrence relation:\n$$ g_k(z) = \\frac{1}{z - \\epsilon - t^2 g_{k-1}(z)} $$\nThis is a continued fraction expansion. To find $\\Sigma(z) = t^2 g_{N-1}(z)$, we iterate this relation $N-2$ times, starting from $g_1(z)$. For the special case $N=1$, there is no rest of the chain, so $\\Sigma(z)=0$.\n\n**Computational Algorithm**\nFor each test case $(N, t, \\epsilon, v, E, \\eta)$:\n1.  Define the complex energy $z = E + i\\eta$.\n2.  Compute the self-energy $\\Sigma(z)$. If $N=1$, $\\Sigma = 0$. If $N > 1$, compute $g_{N-1}(z)$ via the recurrence:\n    a. Initialize $g_{\\text{chain}} = (z-\\epsilon)^{-1}$ (this is $g_1$).\n    b. Iterate $N-2$ times: $g_{\\text{chain}} = (z - \\epsilon - t^2 g_{\\text{chain}})^{-1}$. The result is $g_{N-1}$.\n    c. $\\Sigma = t^2 g_{\\text{chain}}$.\n3.  Compute the exact surface-local Green's function $G_{00} = (z - (\\epsilon+v) - \\Sigma)^{-1}$ and the corresponding exact LDOS $\\rho^{\\mathrm{exact}}_0(E) = -\\frac{1}{\\pi}\\mathrm{Im}[G_{00}]$.\n4.  Compute the unperturbed surface-local Green's function $(G_0)_{00} = (z - \\epsilon - \\Sigma)^{-1}$.\n5.  Generate the perturbative series approximations $G_{00}^{(M)}$ for $M=0,1,2,3$ by summing the series terms.\n    - $G_{00}^{(M)} = G_{00}^{(M-1)} + v^M ((G_0)_{00})^{M+1}$ for $M \\geq 1$.\n6.  For each $M$, calculate the approximate LDOS $\\rho_0^{(M)}(E) = -\\frac{1}{\\pi}\\mathrm{Im}[G_{00}^{(M)}]$.\n7.  Calculate the relative error $\\delta^{(M)}$ using the formula:\n    $$ \\delta^{(M)} = \\frac{\\left|\\rho^{(M)}_0(E)-\\rho^{\\mathrm{exact}}_0(E)\\right|}{\\max\\left(\\left|\\rho^{\\mathrm{exact}}_0(E)\\right|,\\varepsilon_{\\mathrm{ref}}\\right)}, \\quad \\text{with } \\varepsilon_{\\mathrm{ref}} = 10^{-15} $$\n8.  Collect the four errors $\\delta^{(0)}, \\delta^{(1)}, \\delta^{(2)}, \\delta^{(3)}$ for the current test case.\nAfter processing all test cases, the collected errors are formatted into a single output line as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases.\n    It compares a perturbative expansion with an exact recursive Green's function\n    calculation for the surface local density of states (LDOS) of a 1D tight-binding chain.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is (N, t, epsilon, v, E, eta)\n    test_cases = [\n        (200, 1.0, 0.0, 0.05, 0.0, 1e-3),\n        (200, 1.0, 0.0, 0.0, 0.5, 1e-4),\n        (200, 1.0, 0.0, 0.2, 1.95, 1e-3),\n        (10, 1.0, 0.2, 0.1, 0.2, 1e-3),\n    ]\n\n    all_results = []\n    e_ref = 1e-15\n\n    for case in test_cases:\n        N, t, epsilon, v, E, eta = case\n        z = complex(E, eta)\n        t2 = t**2\n\n        # 1. Compute the self-energy Sigma from the rest of the chain (sites 1 to N-1)\n        # This subsystem is an unperturbed chain of length N-1.\n        self_energy = 0.0 + 0.0j\n        if N > 1:\n            # We need the surface Green's function of a chain of length (N-1).\n            # Start with a chain of length 1 (site N-1)\n            g_chain = 1.0 / (z - epsilon)\n            \n            # Recursively add N-2 more sites (N-2, N-3, ..., 1)\n            # This loop repeats (N-2) times.\n            for _ in range(N - 2):\n                g_chain = 1.0 / (z - epsilon - t2 * g_chain)\n            \n            # The final g_chain is the surface GF of the chain from 1..N-1\n            # The self-energy at site 0 is t^2 * g_chain\n            self_energy = t2 * g_chain\n\n        # 2. Compute exact Green's function for the full perturbed system\n        g00_exact = 1.0 / (z - (epsilon + v) - self_energy)\n        ldos_exact = -1.0 / np.pi * np.imag(g00_exact)\n\n        # 3. Compute unperturbed Green's function for the perturbative expansion\n        g00_unperturbed = 1.0 / (z - epsilon - self_energy)\n\n        # 4. Compute perturbative approximations and their errors\n        case_errors = []\n        \n        # The M-th order series is sum_{n=0 to M} v^n * (g00_unperturbed)^(n+1)\n        current_g_series = 0.0 + 0.0j\n        # This term will hold v^n * (g00_unperturbed)^(n+1)\n        term = g00_unperturbed \n\n        for M in range(4): # Loop for M = 0, 1, 2, 3\n            current_g_series += term\n            \n            ldos_M = -1.0 / np.pi * np.imag(current_g_series)\n            \n            # Calculate relative error\n            numerator = np.abs(ldos_M - ldos_exact)\n            denominator = np.maximum(np.abs(ldos_exact), e_ref)\n            error = numerator / denominator\n            case_errors.append(error)\n            \n            # Prepare the next term for the series\n            # The next term is v^(M+1) * g_0^(M+2)\n            # which is the current term (v^M * g_0^(M+1)) times v*g_0\n            term *= v * g00_unperturbed\n        \n        all_results.extend(case_errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}