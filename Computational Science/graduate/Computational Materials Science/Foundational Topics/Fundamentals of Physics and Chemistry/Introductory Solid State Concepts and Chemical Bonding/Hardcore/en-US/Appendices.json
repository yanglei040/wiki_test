{
    "hands_on_practices": [
        {
            "introduction": "The predictive power of Density Functional Theory ($DFT$) is fundamentally limited by the numerical parameters used in the calculation. Before any physical property can be reliably computed, one must ensure that the results are converged with respect to the plane-wave basis set cutoff ($E_{\\mathrm{cut}}$), the Brillouin zone sampling density ($k$-points), and any smearing applied to the electronic occupations ($\\sigma$). This exercise guides you through the process of creating a systematic and quantitative convergence protocol, a critical skill for any computational materials scientist, by using a well-defined error model to balance computational cost against a target accuracy .",
            "id": "3458680",
            "problem": "Consider the cohesive energy of crystalline silicon defined as follows. The cohesive energy per atom, denoted $E_{\\mathrm{coh}}$, is the difference between the total energy of an isolated silicon atom $E_{\\mathrm{atom}}$ and the total energy per atom of bulk silicon $E_{\\mathrm{bulk}}/N$, i.e., $E_{\\mathrm{coh}} = E_{\\mathrm{atom}} - E_{\\mathrm{bulk}}/N$. In a plane-wave Density Functional Theory (DFT) calculation, the computed cohesive energy suffers from three primary controllable numerical errors: basis-set truncation due to finite plane-wave cutoff, incomplete Brillouin zone integration due to finite $k$-point density, and smearing-induced bias due to a nonzero electronic smearing width. Your task is to design a systematic and quantitative convergence protocol for $E_{\\mathrm{coh}}$ with respect to these three parameters.\n\nUse the following fundamental physical and numerical bases as starting points:\n- The Rayleigh–Ritz variational principle implies that a larger basis set (higher cutoff energy) cannot increase the ground state energy and that the basis-set incompleteness error of a plane-wave expansion for smooth pseudopotentials typically decays as a power law with the plane-wave kinetic energy cutoff $E_{\\mathrm{cut}}$.\n- Brillouin zone integration of smooth functions with Monkhorst–Pack sampling behaves as a Riemann sum whose integration error decays with the number of $k$-points $N_k$.\n- For a semiconductor, a small finite electronic smearing width $\\sigma$ (for example, Fermi–Dirac smearing) introduces a systematic bias in the internal energy that is analytic at small $\\sigma$ and scales quadratically with $\\sigma$.\n\nAdopt a surrogate, additive error model for the cohesive energy of silicon that is consistent with these bases:\n$$\n\\Delta E_{\\mathrm{coh}}(E_{\\mathrm{cut}}, N_k, \\sigma) \\;=\\; \\Delta E_{\\mathrm{pw}}(E_{\\mathrm{cut}}) \\;+\\; \\Delta E_{k}(N_k) \\;+\\; \\Delta E_{\\mathrm{sm}}(\\sigma),\n$$\nwith the following asymptotic scalings and positive prefactors:\n$$\n\\Delta E_{\\mathrm{pw}}(E_{\\mathrm{cut}}) \\;=\\; A_{\\mathrm{pw}} \\, E_{\\mathrm{cut}}^{-\\tfrac{3}{2}}, \\qquad\n\\Delta E_{k}(N_k) \\;=\\; \\frac{A_{k}}{N_k}, \\qquad\n\\Delta E_{\\mathrm{sm}}(\\sigma) \\;=\\; A_{\\mathrm{sm}} \\, \\sigma^{2}.\n$$\nAssume the following fixed material- and method-dependent constants appropriate for a norm-conserving or projector-augmented-wave silicon calculation with a smooth pseudopotential:\n- $A_{\\mathrm{pw}} = 12.0$ (with $E_{\\mathrm{cut}}$ in electronvolts, abbreviated eV),\n- $A_{k} = 0.6$ (in eV),\n- $A_{\\mathrm{sm}} = 0.1$ (in eV$^{-1}$),\nand a reference cohesive energy $E_{\\mathrm{coh}}^{\\mathrm{true}} = 4.63$ eV per atom used only to interpret the magnitude of errors. All energies must be expressed in eV, and $\\sigma$ must be expressed in eV.\n\nDesign a protocol that, given a target absolute error budget $\\tau$ and a triplet of nonnegative sub-budgets $(b_{\\mathrm{pw}}, b_{k}, b_{\\mathrm{sm}})$ satisfying $b_{\\mathrm{pw}} + b_{k} + b_{\\mathrm{sm}} \\le \\tau$, produces the smallest parameters that separately enforce the following three inequalities:\n$$\n\\Delta E_{\\mathrm{pw}}(E_{\\mathrm{cut}}) \\le b_{\\mathrm{pw}}, \\quad\n\\Delta E_{k}(N_k) \\le b_{k}, \\quad\n\\Delta E_{\\mathrm{sm}}(\\sigma) \\le b_{\\mathrm{sm}}.\n$$\nImpose the following discretization and reporting rules to make the results practically actionable and unambiguous:\n- $E_{\\mathrm{cut}}$ must be chosen as the smallest integer (in eV) that satisfies its inequality; report $E_{\\mathrm{cut}}$ in eV rounded to three decimal places.\n- $N_k$ must be chosen as the smallest positive integer that satisfies its inequality; report $N_k$ as an integer.\n- $\\sigma$ must be chosen as the largest value that still satisfies its inequality, then rounded down to the nearest $0.001$ eV to avoid exceeding the error sub-budget after rounding; report $\\sigma$ in eV rounded to three decimal places.\n\nFinally, compute and report, for each test case, the achieved total absolute error\n$$\n\\Delta E_{\\mathrm{tot}} \\;=\\; \\Delta E_{\\mathrm{pw}}(E_{\\mathrm{cut}}) + \\Delta E_{k}(N_k) + \\Delta E_{\\mathrm{sm}}(\\sigma)\n$$\nusing the actually selected $(E_{\\mathrm{cut}}, N_k, \\sigma)$ after applying the discretization and rounding rules. Report $\\Delta E_{\\mathrm{tot}}$ in eV rounded to six decimal places.\n\nTest suite. Apply your protocol to the following four cases, which together probe a general case, a tight boundary, a loose tolerance, and an imbalanced smearing budget. Each case is specified by $(\\tau, b_{\\mathrm{pw}}, b_{k}, b_{\\mathrm{sm}})$:\n- Case A (general): $(\\tau, b_{\\mathrm{pw}}, b_{k}, b_{\\mathrm{sm}}) = (0.005, 0.0025, 0.0015, 0.001)$.\n- Case B (tight): $(\\tau, b_{\\mathrm{pw}}, b_{k}, b_{\\mathrm{sm}}) = (0.001, 0.0005, 0.00025, 0.00025)$.\n- Case C (loose): $(\\tau, b_{\\mathrm{pw}}, b_{k}, b_{\\mathrm{sm}}) = (0.020, 0.015, 0.003, 0.002)$.\n- Case D (imbalanced smearing): $(\\tau, b_{\\mathrm{pw}}, b_{k}, b_{\\mathrm{sm}}) = (0.003, 0.0015, 0.0014, 0.0001)$.\n\nYour program must compute, for each case, the recommended $(E_{\\mathrm{cut}}, N_k, \\sigma)$ and the achieved $\\Delta E_{\\mathrm{tot}}$ using the model above and the specified rounding rules.\n\nFinal output format. Your program should produce a single line of output containing the four case results aggregated into one Python-like list literal of lists, where each inner list is\n$$\n[E_{\\mathrm{cut}} \\text{ in eV (float with three decimals)},\\; N_k \\text{ (integer)},\\; \\sigma \\text{ in eV (float with three decimals)},\\; \\Delta E_{\\mathrm{tot}} \\text{ in eV (float with six decimals)}].\n$$\nFor example, the overall output must have the form\n$[[e_1, n_1, s_1, d_1],[e_2, n_2, s_2, d_2],[e_3, n_3, s_3, d_3],[e_4, n_4, s_4, d_4]]$\non a single line, with no additional text, and all energies in eV. Angles do not appear in this problem. Percentages must not be used anywhere; use decimals only.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of computational materials science, specifically Density Functional Theory ($DFT$). The error models provided for plane-wave cutoff energy, $k$-point sampling, and electronic smearing are standard, well-posed approximations used in convergence studies. The problem is self-contained, objective, and provides all necessary data and rules to arrive at a unique, verifiable solution. We may therefore proceed with the derivation of the computational protocol.\n\nThe objective is to determine the minimum computational parameters $(E_{\\mathrm{cut}}, N_k, \\sigma)$ that satisfy a set of individual error budgets $(b_{\\mathrm{pw}}, b_{k}, b_{\\mathrm{sm}})$. The error models are given as:\n$$\n\\Delta E_{\\mathrm{pw}}(E_{\\mathrm{cut}}) = A_{\\mathrm{pw}} \\, E_{\\mathrm{cut}}^{-\\tfrac{3}{2}}\n$$\n$$\n\\Delta E_{k}(N_k) = \\frac{A_{k}}{N_k}\n$$\n$$\n\\Delta E_{\\mathrm{sm}}(\\sigma) = A_{\\mathrm{sm}} \\, \\sigma^{2}\n$$\nwith constants $A_{\\mathrm{pw}} = 12.0$ (in units of $\\text{eV}^{5/2}$), $A_{k} = 0.6$ ($\\text{eV}$), and $A_{\\mathrm{sm}} = 0.1$ ($\\text{eV}^{-1}$). For each parameter, we will solve the corresponding inequality and apply the specified discretization and rounding rules.\n\nFirst, we determine the required plane-wave cutoff energy, $E_{\\mathrm{cut}}$. The condition is $\\Delta E_{\\mathrm{pw}}(E_{\\mathrm{cut}}) \\le b_{\\mathrm{pw}}$. Substituting the model and rearranging the inequality for $E_{\\mathrm{cut}}$ yields:\n$$\nA_{\\mathrm{pw}} \\, E_{\\mathrm{cut}}^{-\\tfrac{3}{2}} \\le b_{\\mathrm{pw}} \\implies E_{\\mathrm{cut}}^{\\tfrac{3}{2}} \\ge \\frac{A_{\\mathrm{pw}}}{b_{\\mathrm{pw}}} \\implies E_{\\mathrm{cut}} \\ge \\left(\\frac{A_{\\mathrm{pw}}}{b_{\\mathrm{pw}}}\\right)^{\\tfrac{2}{3}}\n$$\nSince $\\Delta E_{\\mathrm{pw}}$ is a monotonically decreasing function of $E_{\\mathrm{cut}}$, this inequality defines a lower bound for $E_{\\mathrm{cut}}$. The problem requires the smallest integer value for $E_{\\mathrm{cut}}$ that satisfies this condition. This is obtained by computing the lower bound and taking its ceiling.\n$$\nE_{\\mathrm{cut,final}} = \\left\\lceil \\left(\\frac{A_{\\mathrm{pw}}}{b_{\\mathrm{pw}}}\\right)^{\\tfrac{2}{3}} \\right\\rceil\n$$\n\nSecond, we determine the required number of $k$-points, $N_k$. The condition is $\\Delta E_{k}(N_k) \\le b_{k}$. Substituting the model for the $k$-point integration error and solving for $N_k$:\n$$\n\\frac{A_{k}}{N_k} \\le b_{k} \\implies N_k \\ge \\frac{A_{k}}{b_{k}}\n$$\nThe error $\\Delta E_{k}$ is a monotonically decreasing function of $N_k$. We require the smallest positive integer for $N_k$, which is found by taking the ceiling of the lower bound.\n$$\nN_{k,\\text{final}} = \\left\\lceil \\frac{A_{k}}{b_{k}} \\right\\rceil\n$$\n\nThird, we determine the electronic smearing width, $\\sigma$. The condition is $\\Delta E_{\\mathrm{sm}}(\\sigma) \\le b_{\\mathrm{sm}}$. The error $\\Delta E_{\\mathrm{sm}}$ increases with $\\sigma$, so this condition sets an upper bound on $\\sigma$.\n$$\nA_{\\mathrm{sm}} \\, \\sigma^{2} \\le b_{\\mathrm{sm}} \\implies \\sigma^2 \\le \\frac{b_{\\mathrm{sm}}}{A_{\\mathrm{sm}}} \\implies \\sigma \\le \\sqrt{\\frac{b_{\\mathrm{sm}}}{A_{\\mathrm{sm}}}}\n$$\nThe protocol asks for the largest value of $\\sigma$ satisfying this inequality, which is the upper bound itself, $\\sigma_{\\mathrm{max}} = \\sqrt{b_{\\mathrm{sm}}/A_{\\mathrm{sm}}}$. This value must then be rounded down to the nearest $0.001$ eV. This can be expressed mathematically as:\n$$\n\\sigma_{\\text{final}} = \\frac{\\left\\lfloor 1000 \\cdot \\sqrt{\\frac{b_{\\mathrm{sm}}}{A_{\\mathrm{sm}}}} \\right\\rfloor}{1000}\n$$\nThis rounding rule ensures the resulting error $\\Delta E_{\\mathrm{sm}}(\\sigma_{\\text{final}})$ does not exceed the sub-budget $b_{\\mathrm{sm}}$.\n\nFinally, after determining the discrete, actionable parameters $(E_{\\mathrm{cut,final}}, N_{k,\\text{final}}, \\sigma_{\\text{final}})$, we calculate the total achieved error, $\\Delta E_{\\mathrm{tot}}$, by substituting these values back into the individual error functions and summing the results.\n$$\n\\Delta E_{\\mathrm{tot}} = \\Delta E_{\\mathrm{pw}}(E_{\\mathrm{cut,final}}) + \\Delta E_{k}(N_{k,\\text{final}}) + \\Delta E_{\\mathrm{sm}}(\\sigma_{\\text{final}})\n$$\n$$\n\\Delta E_{\\mathrm{tot}} = A_{\\mathrm{pw}} \\, E_{\\mathrm{cut,final}}^{-\\tfrac{3}{2}} + \\frac{A_{k}}{N_{k,\\text{final}}} + A_{\\mathrm{sm}} \\, \\sigma_{\\text{final}}^{2}\n$$\nThe values of $(E_{\\mathrm{cut,final}}, N_{k,\\text{final}}, \\sigma_{\\text{final}})$ and the resulting $\\Delta E_{\\mathrm{tot}}$ are then reported according to the specified formatting rules for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the convergence parameters for DFT calculations based on a\n    surrogate error model and a set of test cases.\n    \"\"\"\n    \n    # Define the constants from the problem statement.\n    A_pw = 12.0  # Units: eV^(5/2)\n    A_k = 0.6    # Units: eV\n    A_sm = 0.1   # Units: eV^(-1)\n\n    # Define the test cases from the problem statement.\n    # Each case is (tau, b_pw, b_k, b_sm).\n    test_cases = [\n        # Case A (general)\n        (0.005, 0.0025, 0.0015, 0.001),\n        # Case B (tight)\n        (0.001, 0.0005, 0.00025, 0.00025),\n        # Case C (loose)\n        (0.020, 0.015, 0.003, 0.002),\n        # Case D (imbalanced smearing)\n        (0.003, 0.0015, 0.0014, 0.0001),\n    ]\n\n    all_results_formatted = []\n\n    for case in test_cases:\n        _, b_pw, b_k, b_sm = case\n\n        # 1. Determine E_cut\n        # E_cut >= (A_pw / b_pw)^(2/3)\n        # We need the smallest integer satisfying this.\n        e_cut_bound = (A_pw / b_pw)**(2.0/3.0)\n        e_cut_final = int(np.ceil(e_cut_bound))\n\n        # 2. Determine N_k\n        # N_k >= A_k / b_k\n        # We need the smallest positive integer satisfying this.\n        n_k_bound = A_k / b_k\n        n_k_final = int(np.ceil(n_k_bound))\n\n        # 3. Determine sigma\n        # sigma <= sqrt(b_sm / A_sm)\n        # We need the largest value, rounded down to the nearest 0.001 eV.\n        sigma_bound = np.sqrt(b_sm / A_sm)\n        sigma_final = np.floor(sigma_bound * 1000) / 1000.0\n\n        # 4. Calculate the total achieved error with the final parameters\n        delta_e_pw = A_pw * (e_cut_final**(-1.5))\n        delta_e_k = A_k / n_k_final\n        delta_e_sm = A_sm * (sigma_final**2)\n        delta_e_tot = delta_e_pw + delta_e_k + delta_e_sm\n\n        # Format the inner list as a string according to output rules.\n        inner_list_str = (\n            f\"[{e_cut_final:.3f},\"\n            f\"{n_k_final},\"\n            f\"{sigma_final:.3f},\"\n            f\"{delta_e_tot:.6f}]\"\n        )\n        all_results_formatted.append(inner_list_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_formatted)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once numerical convergence is achieved, total energies become powerful tools for predicting a vast range of material properties, with a quintessential example being the formation energy of point defects. This practice introduces the supercell method, a standard technique for modeling defects in periodic crystals, using a simplified pair potential to illustrate the core concepts . You will derive and apply the formula for vacancy formation energy and investigate the origin and behavior of finite-size errors, which arise from artificial interactions between a defect and its periodic images.",
            "id": "3458666",
            "problem": "You are tasked with implementing a computational workflow to estimate the vacancy formation energy in face-centered cubic (FCC) aluminum using a supercell approach and to examine finite-size convergence with respect to cell size. Work at fixed volume with periodic boundary conditions.\n\nFundamental bases to use:\n- The definition of vacancy formation as removing one atom from a perfect crystal and placing it into a reservoir with the same chemical potential, all at fixed volume and boundary conditions.\n- The total energy of a system as a sum over pairwise interactions within a physically justified cutoff and using the minimum image convention for periodic boundary conditions.\n- The relation between chemical potential and energy per atom in a large, homogeneous crystal at fixed volume.\n\nConstruct an FCC aluminum lattice as follows:\n- Use the conventional cubic lattice parameter $a_0 = 4.05\\,\\mathrm{\\AA}$.\n- The FCC basis in fractional coordinates of the conventional cubic cell is $\\{(0,0,0), (0, \\tfrac{1}{2}, \\tfrac{1}{2}), (\\tfrac{1}{2}, 0, \\tfrac{1}{2}), (\\tfrac{1}{2}, \\tfrac{1}{2}, 0)\\}$, with Cartesian positions obtained by multiplying by $a_0$.\n- Build a cubic supercell by replicating the conventional cell $n \\times n \\times n$ times, where $n$ is an integer.\n\nModel the interatomic interactions with a Morse pair potential:\n- The pair potential is $V(r) = D\\left(e^{-2 a (r - r_0)} - 2 e^{-a (r - r_0)}\\right)$.\n- Use $D = 0.35\\,\\mathrm{eV}$, $a = 1.2\\,\\mathrm{\\AA^{-1}}$, and $r_0 = a_0/\\sqrt{2}\\,\\mathrm{\\AA}$.\n- Impose a real-space cutoff $r_c = 8.0\\,\\mathrm{\\AA}$; interactions with $r \\ge r_c$ are neglected.\n- Use the minimum image convention under Born–von Karman periodic boundary conditions, with a cubic box of side length $L = n a_0$.\n\nDefine the perfect supercell energy $E_{\\mathrm{perf}}(n)$ as the total pair energy of all atoms in the $n \\times n \\times n$ FCC supercell. Define the defective supercell energy $E_{\\mathrm{def}}(n)$ by removing a single atom to create a vacancy in the same box. Remove the atom that is closest to the box center at $(L/2, L/2, L/2)$, measured in Cartesian coordinates.\n\nStarting only from the above bases and definitions, derive the expression for the vacancy formation energy $E_f(n)$ in terms of $E_{\\mathrm{perf}}(n)$ and $E_{\\mathrm{def}}(n)$ and implement it in your program. Clearly justify the role of the chemical potential and how it is approximated within this finite supercell method. Discuss how $E_f(n)$ is expected to converge as $n$ increases, based on elastic and electronic finite-size effects, and the scaling of defect–image interactions with $n$.\n\nYour program must:\n- Construct the FCC positions for each given $n$.\n- Compute $E_{\\mathrm{perf}}(n)$ and $E_{\\mathrm{def}}(n)$ as described.\n- Compute the vacancy formation energy $E_f(n)$ using your derived expression.\n- Use $\\mathrm{\\AA}$ for lengths and $\\mathrm{eV}$ for energies.\n- Express each final vacancy formation energy in electronvolts (eV) as a float rounded to three decimal places.\n\nTest suite:\n- Use the replication sizes $n \\in \\{1, 2, 3, 4\\}$ to illustrate finite-size convergence.\n- Edge case: $n = 1$ represents the minimal periodic image interaction dominated case.\n- Increasing $n$ values provide the trend towards the large-cell limit.\n\nFinal output format:\n- Your program should produce a single line of output containing the vacancy formation energies $[E_f(1), E_f(2), E_f(3), E_f(4)]$ as a comma-separated list enclosed in square brackets, with each entry rounded to three decimal places in $\\mathrm{eV}$ (for example, \"[0.123,0.456,0.789,1.234]\").",
            "solution": "The problem requires the calculation of the vacancy formation energy, $E_f$, in face-centered cubic (FCC) aluminum for different supercell sizes, $n$, to investigate finite-size convergence. This will be accomplished using a pairwise Morse potential within a fixed-volume, periodic supercell framework.\n\n**1. Theoretical Framework: Vacancy Formation Energy**\n\nThe vacancy formation energy, $E_f$, is defined as the energy cost to create a single vacancy in an otherwise perfect crystal. This process involves removing one atom from a bulk site and transferring it to a conceptual energy reservoir, which represents the state of an atom in a perfect, infinite crystal. The energy of an atom in this reservoir is the chemical potential, $\\mu$.\n\nLet the perfect supercell contain $N$ atoms and have a total energy of $E_{\\mathrm{perf}}(N)$. Upon removing one atom, the system becomes a defective supercell with $N-1$ atoms and a total energy of $E_{\\mathrm{def}}(N-1)$. The energy change, and thus the vacancy formation energy, is given by:\n$$E_f = [E_{\\mathrm{def}}(N-1) + \\mu] - E_{\\mathrm{perf}}(N)$$\n\nIn a computational model using finite supercells, the chemical potential $\\mu$ of the infinite crystal must be approximated. The most common and physically sound approximation is the average energy per atom in the \"best\" available perfect crystal, which is the perfect supercell itself. Therefore, we approximate $\\mu$ for a supercell containing $N$ atoms as:\n$$\\mu \\approx \\frac{E_{\\mathrm{perf}}(N)}{N}$$\n\nSubstituting this approximation into the definition of $E_f$ yields the formula for the vacancy formation energy within the supercell model:\n$$E_f(N) = E_{\\mathrm{def}}(N-1) + \\frac{E_{\\mathrm{perf}}(N)}{N} - E_{\\mathrm{perf}}(N)$$\n$$E_f(N) = E_{\\mathrm{def}}(N-1) - \\left(1 - \\frac{1}{N}\\right) E_{\\mathrm{perf}}(N) = E_{\\mathrm{def}}(N-1) - \\frac{N-1}{N} E_{\\mathrm{perf}}(N)$$\nFor an $n \\times n \\times n$ supercell of a conventional FCC cell (which contains $4$ atoms), the total number of atoms is $N = 4n^3$. The formula is thus applied with this value of $N$. This calculation is performed at a constant supercell volume, meaning no atomic relaxations around the vacancy or cell volume changes are considered, which is a common first-order approximation.\n\n**2. Computational Methodology**\n\nThe implementation follows a direct simulation of the physical system as defined.\n\n**FCC Supercell Construction**: An FCC supercell is constructed by replicating the conventional cubic cell, with lattice parameter $a_0 = 4.05\\,\\mathrm{\\AA}$, $n$ times along each of the three Cartesian axes. The conventional cell contains $4$ atoms at fractional coordinates $\\{(0,0,0), (0, \\tfrac{1}{2}, \\tfrac{1}{2}), (\\tfrac{1}{2}, 0, \\tfrac{1}{2}), (\\tfrac{1}{2}, \\tfrac{1}{2}, 0)\\}$. The resulting supercell is a cubic box of side length $L = n a_0$ containing $N = 4n^3$ atoms and subject to periodic boundary conditions.\n\n**Total Energy Calculation**: The total energy of a configuration of atoms is computed as the sum of all pairwise interactions, governed by the Morse potential:\n$$V(r) = D\\left(e^{-2 a (r - r_0)} - 2 e^{-a (r - r_0)}\\right)$$\nwith parameters $D = 0.35\\,\\mathrm{eV}$, $a = 1.2\\,\\mathrm{\\AA^{-1}}$, and $r_0 = a_0/\\sqrt{2}\\,\\mathrm{\\AA}$. The total energy $E_{\\mathrm{total}}$ for a system of atoms is:\n$$E_{\\mathrm{total}} = \\sum_{i<j} V(r_{ij})$$\nwhere the sum is over all unique pairs of atoms $(i, j)$. The interatomic distance $r_{ij}$ is calculated using the **minimum image convention** to account for periodic boundary conditions. For a displacement vector $\\Delta\\vec{x} = \\vec{x}_i - \\vec{x}_j$, the minimum image displacement is $\\Delta\\vec{x}' = \\Delta\\vec{x} - L \\cdot \\mathrm{round}(\\Delta\\vec{x}/L)$, where `round` is applied component-wise. Interactions are neglected for distances $r_{ij} \\ge r_c$, where the cutoff radius is $r_c = 8.0\\,\\mathrm{\\AA}$.\n\n**Workflow**:\n1.  For each replication factor $n \\in \\{1, 2, 3, 4\\}$, the positions of all $N = 4n^3$ atoms in the perfect supercell are generated.\n2.  The total energy of this perfect cell, $E_{\\mathrm{perf}}(n)$, is computed.\n3.  A vacancy is introduced by removing the single atom closest to the geometric center of the supercell, $(L/2, L/2, L/2)$. This creates a defective cell with $N-1$ atoms.\n4.  The total energy of the defective cell, $E_{\\mathrm{def}}(n)$, is computed using the same box size $L$ and parameters.\n5.  The vacancy formation energy $E_f(n)$ is calculated using the derived formula.\n\n**3. Convergence and Finite-Size Effects**\n\nThe use of a finite supercell with periodic boundary conditions introduces artificial interactions between the vacancy and its periodic images. These spurious interactions are a source of finite-size error. As the supercell size $n$ (and thus $L$) increases, the distance between a vacancy and its nearest images increases, causing the error to diminish. For a neutral defect like a vacancy in three dimensions, the leading-order elastic interaction energy is expected to decay as $1/L^3$, or equivalently, $1/n^3$. Therefore, we expect the calculated $E_f(n)$ to converge towards the infinite-cell limit, $E_f(\\infty)$, as $n$ increases. The test suite with $n = \\{1, 2, 3, 4\\}$ will illustrate this convergence trend. The case $n=1$ is expected to have the largest error due to strong interactions across the small periodic cell ($L=a_0=4.05\\,\\mathrm{\\AA}$).",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the vacancy formation energy in FCC aluminum for various supercell sizes\n    using a Morse pair potential and a fixed-volume supercell approach.\n    \"\"\"\n\n    # --- Problem Constants and Parameters ---\n    A0 = 4.05  # Lattice parameter in Angstroms\n    D_MORSE = 0.35  # Morse parameter D in eV\n    A_MORSE = 1.2   # Morse parameter a in Angstrom^-1\n    RC = 8.0     # Cutoff radius in Angstroms\n    R0_MORSE = A0 / np.sqrt(2.0)  # Morse parameter r0 in Angstroms\n\n    # --- Test Suite ---\n    N_REPLICATIONS = [1, 2, 3, 4]\n\n    # --- FCC Lattice Basis ---\n    # Basis vectors in fractional coordinates for a conventional cell\n    fcc_basis_frac = np.array([\n        [0.0, 0.0, 0.0],\n        [0.0, 0.5, 0.5],\n        [0.5, 0.0, 0.5],\n        [0.5, 0.5, 0.0]\n    ])\n    # Basis vectors in Cartesian coordinates\n    fcc_basis_cart = fcc_basis_frac * A0\n\n    def calculate_total_energy(positions, L, rc, D, a_p, r0):\n        \"\"\"\n        Calculates the total potential energy of a system of atoms using a Morse potential.\n        \n        Args:\n            positions (np.ndarray): Array of atomic positions (num_atoms, 3).\n            L (float): Side length of the cubic simulation box.\n            rc (float): Cutoff radius for the pair potential.\n            D, a_p, r0 (float): Morse potential parameters.\n        \n        Returns:\n            float: Total potential energy of the system in eV.\n        \"\"\"\n        num_atoms = positions.shape[0]\n        total_energy = 0.0\n        rc_sq = rc * rc\n\n        for i in range(num_atoms):\n            for j in range(i + 1, num_atoms):\n                # Calculate displacement vector between atom i and atom j\n                dr = positions[i] - positions[j]\n                \n                # Apply Minimum Image Convention for periodic boundary conditions\n                dr -= L * np.rint(dr / L)\n                \n                r_sq = np.dot(dr, dr)\n                \n                # Check if the pair is within the cutoff radius\n                if r_sq < rc_sq:\n                    r = np.sqrt(r_sq)\n                    # The r > 0 check is implicitly handled by the j > i loop\n                    exp_term = np.exp(-a_p * (r - r0))\n                    pair_energy = D * (exp_term**2 - 2.0 * exp_term)\n                    total_energy += pair_energy\n        return total_energy\n\n    vacancy_formation_energies = []\n\n    for n in N_REPLICATIONS:\n        # 1. Construct the perfect supercell by replicating the conventional cell\n        L = n * A0  # Supercell box length\n        \n        perfect_positions = []\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    # Translation vector for this replica of the conventional cell\n                    translation = np.array([i, j, k]) * A0\n                    for basis_pos in fcc_basis_cart:\n                        perfect_positions.append(basis_pos + translation)\n        \n        perfect_positions = np.array(perfect_positions)\n        N = perfect_positions.shape[0]\n        \n        # 2. Calculate the total energy of the perfect supercell, E_perf(n)\n        E_perf = calculate_total_energy(perfect_positions, L, RC, D_MORSE, A_MORSE, R0_MORSE)\n        \n        # 3. Create a vacancy by removing the atom closest to the box center\n        box_center = np.array([L/2.0, L/2.0, L/2.0])\n        \n        # Find the index of the atom to remove\n        distances_to_center = np.linalg.norm(perfect_positions - box_center, axis=1)\n        idx_to_remove = np.argmin(distances_to_center)\n        \n        # Create the defective positions array by removing the identified atom\n        defective_positions = np.delete(perfect_positions, idx_to_remove, axis=0)\n\n        # 4. Calculate the total energy of the defective supercell, E_def(n)\n        E_def = calculate_total_energy(defective_positions, L, RC, D_MORSE, A_MORSE, R0_MORSE)\n\n        # 5. Calculate the vacancy formation energy E_f(n) using the derived formula\n        if N > 0:\n            E_f = E_def - ((N - 1) / N) * E_perf\n        else:\n            E_f = 0.0 # This case will not be reached for n >= 1\n        \n        vacancy_formation_energies.append(E_f)\n\n    # 6. Format and print the final output as specified\n    # The results are rounded to three decimal places.\n    formatted_results = [f\"{val:.3f}\" for val in vacancy_formation_energies]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main function to solve the problem\nsolve()\n```"
        },
        {
            "introduction": "Beyond numerical precision, the physical accuracy of a $DFT$ calculation depends critically on the choice of the exchange-correlation ($XC$) functional, which approximates the complex many-body effects of electrons. Different functionals, from generalized gradient approximations (GGAs) to hybrids, offer varying balances of accuracy and computational cost and can yield significantly different descriptions of chemical bonding. This exercise uses an intuitive tight-binding model to demystify how the choice of $XC$ functional translates into tangible differences in properties like charge localization and band gaps, connecting abstract theory to observable material characteristics .",
            "id": "3458713",
            "problem": "You must write a complete, runnable program that models the exchange–correlation functional dependence of bond covalency in a one-dimensional diatomic chain using a tight-binding linear combination of atomic orbitals (LCAO) framework. The goal is to compare the effects of different exchange–correlation functionals from Density Functional Theory (DFT), namely Perdew–Burke–Ernzerhof (PBE), Strongly Constrained and Appropriately Normed (SCAN), the regularized-restored variant of SCAN ($r^2$SCAN), and a hybrid functional with a specified fraction of exact exchange, on three quantities: charge localization, band gaps, and bond strengths derived from Crystal Orbital Hamilton Population (COHP).\n\nFundamental base:\n- The tight-binding Hamiltonian for a diatomic chain with one orbital per atom and nearest-neighbor coupling is constructed using Bloch's theorem. Let the two atoms per unit cell be labeled $A$ and $B$, with onsite energies $\\varepsilon_A$ and $\\varepsilon_B$, and a nearest-neighbor hopping parameter $t$ that couples $A$–$B$ within the cell and $B$ to $A$ in the next cell. Let the lattice constant be $a$.\n- The Bloch Hamiltonian in the $\\{A,B\\}$ basis is\n$$\nH(k) = \\begin{pmatrix}\n\\varepsilon_A & t\\left(1 + e^{-i k a}\\right) \\\\\nt\\left(1 + e^{i k a}\\right) & \\varepsilon_B\n\\end{pmatrix},\n$$\nwhere $k$ is the crystal momentum, expressed in radians. The two band energies for each $k$, denoted by $E_-(k)$ and $E_+(k)$ (valence and conduction, respectively), are obtained by solving the eigenvalue problem $H(k)\\,\\mathbf{c}(k) = E(k)\\,\\mathbf{c}(k)$, where $\\mathbf{c}(k)$ is the normalized eigenvector with components $c_A(k)$ and $c_B(k)$. Let $\\Delta \\equiv \\varepsilon_A - \\varepsilon_B$ and $E_0 \\equiv (\\varepsilon_A + \\varepsilon_B)/2$.\n- The band gap is the minimal direct gap across the Brillouin zone\n$$\nE_g = \\min_{k \\in [-\\pi/a,\\pi/a]}\\left[E_+(k) - E_-(k)\\right],\n$$\nexpressed in electronvolts (eV).\n- The charge localization on atom $A$ is defined as the Brillouin-zone average of the valence-band weight on $A$\n$$\nL_A = \\frac{1}{N_k}\\sum_{j=1}^{N_k} \\left|c_A(k_j)\\right|^2,\n$$\nwhich is dimensionless and constrained between $0$ and $1$.\n- The COHP-derived bond strength is modeled as the Brillouin-zone average of the negative real part of the off-diagonal Hamiltonian projected onto the occupied valence eigenstate\n$$\nB = -\\frac{1}{N_k}\\sum_{j=1}^{N_k} \\operatorname{Re}\\!\\left[c_A^*(k_j)\\,H_{AB}(k_j)\\,c_B(k_j)\\right],\n$$\nwith $H_{AB}(k) = t\\left(1+e^{-i k a}\\right)$, expressed in electronvolts (eV). The quantity $B$ serves as an energy-like measure per unit cell, with larger positive values indicating stronger net bonding contributions from occupied states.\n\nTo model the effect of different exchange–correlation functionals on covalency, use functional-specific renormalization factors that alter the onsite energy difference and hopping amplitude. For a baseline parameter set $(\\varepsilon_A,\\varepsilon_B,t)$, define the renormalized parameters as follows. Compute the mean energy $E_0 = (\\varepsilon_A + \\varepsilon_B)/2$ and the baseline difference $\\Delta = \\varepsilon_A - \\varepsilon_B$. For a given functional, apply\n$$\n\\Delta' = s_{\\Delta}\\,\\Delta,\\quad\nt' = s_t\\,t,\\quad\n\\varepsilon_A' = E_0 + \\frac{\\Delta'}{2},\\quad\n\\varepsilon_B' = E_0 - \\frac{\\Delta'}{2}.\n$$\nUse the following functional-specific renormalization factors:\n- For Perdew–Burke–Ernzerhof (PBE): $s_{\\Delta} = 0.85$, $s_t = 1.05$.\n- For Strongly Constrained and Appropriately Normed (SCAN): $s_{\\Delta} = 0.95$, $s_t = 1.00$.\n- For $r^2$SCAN (regularized-restored SCAN): $s_{\\Delta} = 1.00$, $s_t = 0.98$.\n- For a hybrid functional with exact exchange fraction $\\alpha$ (dimensionless): $s_{\\Delta} = 1.0 + 0.6\\,\\alpha$, $s_t = 1.0 - 0.3\\,\\alpha$.\n\nAlgorithmic tasks:\n1. For each test case below, construct the renormalized Hamiltonian $H(k)$ over a uniform $k$-mesh from $-\\pi/a$ to $\\pi/a$, with $N_k$ points and angles in radians.\n2. Solve the $2\\times 2$ eigenproblem for each $k$ to obtain $E_-(k)$, $E_+(k)$ and the valence eigenvector $\\mathbf{c}_-(k)$.\n3. Compute the band gap $E_g$ in electronvolts (eV), the charge localization $L_A$ (dimensionless), and the COHP-derived bond strength $B$ in electronvolts (eV) as defined above.\n4. Round all floating-point outputs to four decimal places.\n\nUse the following test suite of parameter sets, which jointly probe a general case, functional variation, and boundary limits. In all cases below, angles must be treated in radians, and the lattice constant $a$ must be used explicitly in the Brillouin-zone limits $k \\in [-\\pi/a,\\pi/a]$.\n- Test case 1: Functional = PBE, $\\varepsilon_A = -0.5\\,\\mathrm{eV}$, $\\varepsilon_B = +0.5\\,\\mathrm{eV}$, $t = 2.0\\,\\mathrm{eV}$, $a = 3.0\\,\\text{\\AA}$.\n- Test case 2: Functional = $r^2$SCAN, $\\varepsilon_A = -0.5\\,\\mathrm{eV}$, $\\varepsilon_B = +0.5\\,\\mathrm{eV}$, $t = 2.0\\,\\mathrm{eV}$, $a = 3.0\\,\\text{\\AA}$.\n- Test case 3: Functional = SCAN, $\\varepsilon_A = -2.0\\,\\mathrm{eV}$, $\\varepsilon_B = +2.0\\,\\mathrm{eV}$, $t = 1.0\\,\\mathrm{eV}$, $a = 3.0\\,\\text{\\AA}$.\n- Test case 4: Functional = Hybrid with $\\alpha = 0.25$, $\\varepsilon_A = -2.0\\,\\mathrm{eV}$, $\\varepsilon_B = +2.0\\,\\mathrm{eV}$, $t = 1.0\\,\\mathrm{eV}$, $a = 3.0\\,\\text{\\AA}$.\n- Test case 5: Functional = PBE, boundary case with $t = 0.0\\,\\mathrm{eV}$, $\\varepsilon_A = -0.6\\,\\mathrm{eV}$, $\\varepsilon_B = +0.6\\,\\mathrm{eV}$, $a = 3.0\\,\\text{\\AA}$.\n- Test case 6: Functional = $r^2$SCAN, boundary case with $\\Delta = 0.0\\,\\mathrm{eV}$ (i.e., $\\varepsilon_A = 0.0\\,\\mathrm{eV}$, $\\varepsilon_B = 0.0\\,\\mathrm{eV}$), $t = 0.8\\,\\mathrm{eV}$, $a = 3.0\\,\\text{\\AA}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is formatted as a list of three numbers $[E_g,L_A,B]$ and all numbers are rounded to four decimal places. The final output must have no spaces. For example, the output should look like $[[x_1,y_1,z_1],[x_2,y_2,z_2],\\ldots]$ with each $x_i$ in $\\mathrm{eV}$, each $y_i$ dimensionless, and each $z_i$ in $\\mathrm{eV}$.",
            "solution": "We begin with the tight-binding description of a one-dimensional diatomic chain using the Linear Combination of Atomic Orbitals (LCAO) basis. The unit cell contains two atoms labeled $A$ and $B$. Each atom contributes a single orbital, with onsite energies $\\varepsilon_A$ and $\\varepsilon_B$. Nearest-neighbor coupling is represented by a hopping parameter $t$ that connects $A$–$B$ within a unit cell and $B$ in one cell to $A$ in the next cell. The lattice constant is $a$.\n\nBy Bloch's theorem, the crystal momentum $k$ lies in the Brillouin zone $k \\in [-\\pi/a,\\pi/a]$, with angles in radians. The Bloch Hamiltonian in the $\\{A,B\\}$ basis is\n$$\nH(k) = \\begin{pmatrix}\n\\varepsilon_A & t\\left(1 + e^{-i k a}\\right) \\\\\nt\\left(1 + e^{i k a}\\right) & \\varepsilon_B\n\\end{pmatrix}.\n$$\nThis is a Hermitian $2\\times 2$ matrix whose eigenvalues at each $k$ yield the valence band energy $E_-(k)$ and conduction band energy $E_+(k)$. Let $\\Delta \\equiv \\varepsilon_A - \\varepsilon_B$ be the onsite energy difference and $E_0 \\equiv (\\varepsilon_A + \\varepsilon_B)/2$ be the mean energy. The eigenvalues can be expressed as\n$$\nE_{\\pm}(k) = E_0 \\pm \\sqrt{\\left(\\frac{\\Delta}{2}\\right)^2 + \\left| t\\left(1 + e^{i k a}\\right) \\right|^2 }.\n$$\nUsing $\\left|1+e^{i k a}\\right|^2 = 2(1+\\cos(k a))$, the off-diagonal coupling vanishes at $k a = \\pi$ (zone boundary), where $\\cos(k a) = -1$, yielding $E_{\\pm}(k=\\pi/a) = E_0 \\pm |\\Delta|/2$ and thus a direct gap $E_g = |E_+(k) - E_-(k)| = |\\Delta|$ at that point. In general, the minimal direct gap across the Brillouin zone is\n$$\nE_g = \\min_{k \\in [-\\pi/a,\\pi/a]}\\left[E_+(k) - E_-(k)\\right],\n$$\nwhich in this symmetric coupling model equals $|\\Delta|$ because the coupling vanishes at the zone boundary. Therefore, the onsite energy difference controls the minimal direct gap, while the hopping mainly influences the dispersion and the character of eigenvectors.\n\nThe valence-band eigenvector $\\mathbf{c}_-(k)$ is a normalized two-component vector with entries $c_A(k)$ and $c_B(k)$ such that $\\left|c_A(k)\\right|^2 + \\left|c_B(k)\\right|^2 = 1$. The charge localization on atom $A$ can be quantified by the Brillouin-zone average:\n$$\nL_A = \\frac{1}{N_k}\\sum_{j=1}^{N_k} \\left|c_A(k_j)\\right|^2,\n$$\nwhere $\\{k_j\\}$ is a uniform mesh over the Brillouin zone and $N_k$ is the number of points. The quantity $L_A$ lies in $[0,1]$ and indicates the fraction of valence-band character on atom $A$. In the limit $t \\rightarrow 0$ and $\\varepsilon_A < \\varepsilon_B$, the valence band localizes entirely on atom $A$, so $L_A \\rightarrow 1$.\n\nThe Crystal Orbital Hamilton Population (COHP) is a bond analysis technique that measures the energy contributions of bonding and antibonding interactions between atomic orbitals. For the purposes of this model, a COHP-derived bond strength can be captured by the projection of the off-diagonal Hamiltonian onto the occupied valence eigenstate and averaged across the Brillouin zone:\n$$\nB = -\\frac{1}{N_k}\\sum_{j=1}^{N_k} \\operatorname{Re}\\!\\left[c_A^*(k_j)\\,H_{AB}(k_j)\\,c_B(k_j)\\right],\n$$\nwith $H_{AB}(k) = t\\left(1+e^{-i k a}\\right)$. The negative sign is chosen so that larger positive $B$ indicates stronger bonding contributions from occupied states, consistent with the notion that bonding interactions lower the energy. The unit of $B$ is electronvolts (eV), and it represents an average energy-like measure per unit cell derived from the occupied band.\n\nWe next model the effect of various exchange–correlation functionals on the parameters $(\\varepsilon_A,\\varepsilon_B,t)$ via renormalization. Semilocal functionals such as Perdew–Burke–Ernzerhof (PBE) and Strongly Constrained and Appropriately Normed (SCAN) are known to exhibit delocalization errors that can reduce onsite energy splittings (hence decreasing $E_g$) and increase hopping (hence reducing charge localization and increasing mixing). The $r^2$SCAN functional (regularized-restored SCAN) aims to maintain SCAN's accurate constraints while improving numerical behavior, often resulting in slightly reduced hopping compared to SCAN. Hybrid functionals incorporate a fraction $\\alpha$ of exact exchange, which tends to increase localization and onsite energy differences, thereby increasing band gaps and decreasing hopping. We encode these qualitative trends using functional-dependent scaling factors:\n- PBE: $s_{\\Delta} = 0.85$, $s_t = 1.05$.\n- SCAN: $s_{\\Delta} = 0.95$, $s_t = 1.00$.\n- $r^2$SCAN: $s_{\\Delta} = 1.00$, $s_t = 0.98$.\n- Hybrid with exact exchange fraction $\\alpha$: $s_{\\Delta} = 1.0 + 0.6\\,\\alpha$, $s_t = 1.0 - 0.3\\,\\alpha$.\n\nGiven a baseline parameter set $(\\varepsilon_A,\\varepsilon_B,t)$, we carry the mean energy $E_0 = (\\varepsilon_A + \\varepsilon_B)/2$ and onsite difference $\\Delta = \\varepsilon_A - \\varepsilon_B$. The renormalized parameters under a chosen functional are\n$$\n\\Delta' = s_{\\Delta}\\,\\Delta,\\quad\nt' = s_t\\,t,\\quad\n\\varepsilon_A' = E_0 + \\frac{\\Delta'}{2},\\quad\n\\varepsilon_B' = E_0 - \\frac{\\Delta'}{2}.\n$$\nUsing these, we construct $H(k)$, solve for $E_{\\pm}(k)$ and $\\mathbf{c}_-(k)$, and compute $E_g$, $L_A$, and $B$ for each test case. Numerically, $k$ is sampled uniformly in the interval $[-\\pi/a,\\pi/a]$ in radians. The eigenproblem is solved by a standard Hermitian $2\\times 2$ solver; the valence band is identified as the lower eigenvalue at each $k$.\n\nEdge-case behavior clarifies the correctness of this approach:\n- When $t=0$, the off-diagonal elements $H_{AB}(k)$ vanish for all $k$, so the eigenvalues reduce to $E_{\\pm} = \\varepsilon_A$ and $\\varepsilon_B$ independent of $k$, leading to $E_g = |\\Delta'|$ and $L_A \\rightarrow 1$ if $\\varepsilon_A' < \\varepsilon_B'$. The COHP-derived bond strength $B$ becomes $0$ because there is no bonding interaction.\n- When $\\Delta = 0$, the system becomes chemically symmetric, and the minimal direct gap collapses to $E_g = 0$. The valence-band eigenvectors distribute evenly between sites, leading to $L_A \\approx 0.5$ (exactly $0.5$ in the symmetric case), and bonding is driven purely by hopping, so $B$ reflects the averaged mixing via $H_{AB}(k)$.\n\nImplementation details to satisfy the output requirements:\n- Compute $E_g$ in electronvolts (eV).\n- Compute $L_A$ as dimensionless.\n- Compute $B$ in electronvolts (eV).\n- Round all three quantities to four decimal places.\n- Produce a single-line output as a comma-separated list enclosed in square brackets, with each test case result formatted as $[E_g,L_A,B]$ with no spaces.\n\nApplying this procedure to the specified six test cases yields a consistent, quantitative comparison of functional-dependent covalency metrics in a minimal, yet physically grounded, tight-binding model. The program will implement these steps and print the aggregated results in the exact required format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_functional_scaling(eps_a, eps_b, t, functional, alpha=None):\n    \"\"\"\n    Apply functional-specific renormalization to onsite energy difference and hopping.\n    Keeps the mean energy E0 invariant while scaling the difference Delta and hopping t.\n    \"\"\"\n    E0 = 0.5 * (eps_a + eps_b)\n    Delta = eps_a - eps_b\n\n    if functional == \"PBE\":\n        s_delta, s_t = 0.85, 1.05\n    elif functional == \"SCAN\":\n        s_delta, s_t = 0.95, 1.00\n    elif functional == \"r2SCAN\":\n        s_delta, s_t = 1.00, 0.98\n    elif functional == \"HYB\":\n        if alpha is None:\n            raise ValueError(\"Hybrid functional requires alpha (exact exchange fraction).\")\n        s_delta = 1.0 + 0.6 * alpha\n        s_t = 1.0 - 0.3 * alpha\n    else:\n        raise ValueError(f\"Unknown functional: {functional}\")\n\n    Delta_prime = s_delta * Delta\n    t_prime = s_t * t\n    eps_a_prime = E0 + 0.5 * Delta_prime\n    eps_b_prime = E0 - 0.5 * Delta_prime\n    return eps_a_prime, eps_b_prime, t_prime\n\n\ndef H_k(k, eps_a, eps_b, t, a):\n    \"\"\"\n    Construct the 2x2 tight-binding Bloch Hamiltonian for the diatomic chain:\n    H(k) = [[eps_a, t (1 + e^{-i k a})],\n            [t (1 + e^{+i k a}), eps_b]]\n    \"\"\"\n    offdiag = t * (1.0 + np.exp(-1j * k * a))\n    H = np.array([[eps_a, offdiag],\n                  [np.conjugate(offdiag), eps_b]], dtype=np.complex128)\n    return H\n\n\ndef compute_properties(eps_a, eps_b, t, a, nk=2001):\n    \"\"\"\n    Compute band gap E_g (eV), charge localization L_A (dimensionless),\n    and COHP-derived bond strength B (eV) by sampling k over the Brillouin zone.\n    \"\"\"\n    # k in radians, sampled uniformly in [-pi/a, pi/a]\n    k_min = -np.pi / a\n    k_max = +np.pi / a\n    ks = np.linspace(k_min, k_max, nk)\n\n    gaps = []\n    loc_weights_A = []\n    cohp_contribs = []\n\n    for k in ks:\n        H = H_k(k, eps_a, eps_b, t, a)\n        # Hermitian eigenproblem: eigh returns eigenvalues ascending and eigenvectors as columns\n        w, v = np.linalg.eigh(H)\n        E_valence = w[0]\n        E_conduction = w[1]\n        gaps.append(E_conduction - E_valence)\n\n        # Valence eigenvector is the first column (corresponding to the lowest eigenvalue)\n        c_val = v[:, 0]\n        cA = c_val[0]\n        cB = c_val[1]\n        # Charge localization on A\n        loc_weights_A.append(np.abs(cA)**2)\n\n        # COHP-derived bond strength contribution: -Re(c_A^* H_AB c_B)\n        H_AB = H[0, 1]\n        cohp_contribs.append(-np.real(np.conjugate(cA) * H_AB * cB))\n\n    E_g = float(np.min(gaps))\n    L_A = float(np.mean(loc_weights_A))\n    B = float(np.mean(cohp_contribs))\n\n    return E_g, L_A, B\n\n\ndef format_results(results):\n    \"\"\"\n    Format list of result triples [[Eg, LA, B], ...] with each float rounded to 4 decimals,\n    and produce a single-line string without spaces: [[x,y,z],[...],...]\n    \"\"\"\n    formatted_triples = []\n    for triple in results:\n        formatted = \"[\" + \",\".join(f\"{x:.4f}\" for x in triple) + \"]\"\n        formatted_triples.append(formatted)\n    return \"[\" + \",\".join(formatted_triples) + \"]\"\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (functional, eps_a, eps_b, t, a, alpha)\n    test_cases = [\n        (\"PBE\",   -0.5,  +0.5, 2.0, 3.0, None),   # Test case 1\n        (\"r2SCAN\",-0.5,  +0.5, 2.0, 3.0, None),   # Test case 2\n        (\"SCAN\",  -2.0,  +2.0, 1.0, 3.0, None),   # Test case 3\n        (\"HYB\",   -2.0,  +2.0, 1.0, 3.0, 0.25),   # Test case 4\n        (\"PBE\",   -0.6,  +0.6, 0.0, 3.0, None),   # Test case 5 (boundary: t=0)\n        (\"r2SCAN\", 0.0,   0.0, 0.8, 3.0, None),   # Test case 6 (boundary: Delta=0)\n    ]\n\n    results = []\n    for functional, eps_a, eps_b, t, a, alpha in test_cases:\n        eps_a_p, eps_b_p, t_p = apply_functional_scaling(eps_a, eps_b, t, functional, alpha)\n        Eg, LA, B = compute_properties(eps_a_p, eps_b_p, t_p, a, nk=2001)\n        results.append([Eg, LA, B])\n\n    # Final print statement in the exact required format.\n    print(format_results(results))\n\nsolve()\n```"
        }
    ]
}