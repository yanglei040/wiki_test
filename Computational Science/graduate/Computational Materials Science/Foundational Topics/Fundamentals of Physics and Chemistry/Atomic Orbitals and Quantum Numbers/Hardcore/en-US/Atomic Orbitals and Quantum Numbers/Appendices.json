{
    "hands_on_practices": [
        {
            "introduction": "Electronic structure codes often represent atomic orbitals using complex spherical harmonics, $Y_l^m$, for their mathematical elegance and efficiency. However, for chemical interpretation and visualization, the real-valued cubic harmonics such as $p_x$ and $d_{x^2-y^2}$ are far more intuitive. This practice bridges that gap, guiding you through the implementation of the transformation from the complex to the real basis and verifying the resulting orbital shapes and symmetries .",
            "id": "3433597",
            "problem": "In computational materials science, electronic structure codes typically represent atomic angular basis functions using complex spherical harmonics $Y_{\\ell}^{m}$, where $\\ell$ is the orbital angular momentum quantum number and $m$ is its projection. For analysis under crystal symmetries, it is often necessary to convert these to real cubic harmonics aligned with Cartesian axes, such as the familiar $p$ and $d$ orbitals in a cubic crystal environment. Starting from the separation of variables of the time-independent Schrödinger equation in spherical coordinates, which yields angular solutions as spherical harmonics $Y_{\\ell}^{m}(\\theta,\\phi)$ on the unit sphere, implement a post-processing tool that maps the complex spherical harmonics to real cubic harmonics and verifies the mapping both by reproducing expected Cartesian shapes on the unit sphere and by demonstrating the correct degeneracy structure under cubic symmetry operations.\n\nFundamental base:\n- The complex spherical harmonics $Y_{\\ell}^{m}(\\theta,\\phi)$ form an orthonormal basis on the unit sphere for fixed $\\ell$, with $m$ ranging from $- \\ell$ to $+\\ell$.\n- Real cubic harmonics are obtained as specific real linear combinations of the complex spherical harmonics for a given $\\ell$, chosen to align with Cartesian polynomial shapes on the unit sphere.\n- Rotations in three-dimensional space act on functions on the sphere by transforming their arguments: a rotation $R$ maps a function $f(x,y,z)$ to $f(R^{-1}\\cdot(x,y,z))$.\n- Under cubic symmetry, the $\\ell = 2$ manifold decomposes into a doublet and a triplet subspace, corresponding to two-dimensional and three-dimensional irreducible representations.\n\nYour program must:\n1. Derive and implement the conversion from complex spherical harmonics $Y_{\\ell}^{m}$, with $\\ell = 1$ and $\\ell = 2$, to the standard real cubic harmonics aligned with Cartesian axes on the unit sphere. Use angles in radians.\n2. Numerically verify that the resulting real cubic harmonics reproduce the expected Cartesian shapes restricted to the unit sphere by computing the correlation coefficient between each computed harmonic $h$ and its target Cartesian polynomial shape $t$:\n   $$\\mathrm{corr}(h,t) = \\frac{\\sum_{k=1}^{N} h(\\Omega_k)\\, t(\\Omega_k)}{\\sqrt{\\left(\\sum_{k=1}^{N} h(\\Omega_k)^2\\right)\\left(\\sum_{k=1}^{N} t(\\Omega_k)^2\\right)}},$$\n   where $\\Omega_k$ are $N$ sample points uniformly distributed on the unit sphere, with $N$ specified in the test suite. The target shapes on the unit sphere should be taken as $p_x \\sim x$, $p_y \\sim y$, $p_z \\sim z$, $d_{x^2-y^2} \\sim x^2 - y^2$, $d_{xy} \\sim x y$, $d_{xz} \\sim x z$, $d_{yz} \\sim y z$, and $d_{z^2} \\sim 3 z^2 - 1$, all evaluated at $(x,y,z)$ on the unit sphere.\n3. Demonstrate the correct degeneracy structure of the $\\ell = 2$ set under cubic symmetry by constructing the representation of specific cubic rotations on the $d$-orbital basis and showing block structure corresponding to a two-dimensional subspace and a three-dimensional subspace. For each rotation $R$, compute the $5 \\times 5$ representation matrix $C_R$ defined by expanding each rotated basis function in the original basis using the discrete inner product over the sample points. Verify that the off-block mixing between the two-dimensional and three-dimensional subspaces is numerically negligible.\n\nTest suite and parameters:\n- Use three sets of sample sizes:\n  - For $\\ell = 1$ shape verification: $N = 4096$.\n  - For $\\ell = 2$ shape verification: $N = 8192$.\n  - For degeneracy checks: $N = 6000$.\n- Use the following cubic rotations (angles in radians):\n  - $R_z(\\pi/2)$: rotation by $\\pi/2$ about the $z$-axis.\n  - $R_x(\\pi/2)$: rotation by $\\pi/2$ about the $x$-axis.\n  - $R_y(\\pi/2)$: rotation by $\\pi/2$ about the $y$-axis.\n- For each rotation, compute the maximum absolute value of the coefficients in the off-blocks of $C_R$ that mix the two-dimensional subspace $\\{d_{z^2}, d_{x^2-y^2}\\}$ and the three-dimensional subspace $\\{d_{xy}, d_{yz}, d_{xz}\\}$, and report whether this maximum is less than a tolerance $\\epsilon = 10^{-6}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order:\n  - The three correlation coefficients for $\\ell = 1$: $[\\mathrm{corr}(p_x), \\mathrm{corr}(p_y), \\mathrm{corr}(p_z)]$ as floats.\n  - The five correlation coefficients for $\\ell = 2$: $[\\mathrm{corr}(d_{x^2-y^2}), \\mathrm{corr}(d_{xy}), \\mathrm{corr}(d_{xz}), \\mathrm{corr}(d_{yz}), \\mathrm{corr}(d_{z^2})]$ as floats.\n  - Three booleans indicating whether the degeneracy off-block mixing is below $\\epsilon$ for $R_z(\\pi/2)$, $R_x(\\pi/2)$, and $R_y(\\pi/2)$, respectively.\n- For example, the output format should be: $[\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{boolean},\\text{boolean},\\text{boolean}]$.",
            "solution": "The problem statement is scientifically sound, well-posed, and provides all necessary information to proceed with a solution. It addresses a standard and important task in computational materials science: the transformation between different representations of atomic orbitals and the verification of their properties.\n\nThe solution is implemented in three stages: first, the derivation and implementation of the real cubic harmonics from complex spherical harmonics for orbital angular momentum quantum numbers $\\ell=1$ and $\\ell=2$. Second, the numerical verification of the correspondence between these computed real harmonics and their well-known Cartesian polynomial forms on the unit sphere. Third, a demonstration of the transformation properties of the $\\ell=2$ harmonics under cubic symmetry operations, which reveals their degenerate subspace structure.\n\n**1. From Complex Spherical to Real Cubic Harmonics**\n\nThe angular part of the time-independent Schrödinger equation for a central potential is solved by the complex spherical harmonics, $Y_{\\ell}^{m}(\\theta, \\phi)$. These functions form an orthonormal basis on the surface of a sphere for a given quantum number $\\ell$, with the magnetic quantum number $m$ ranging from $-\\ell$ to $+\\ell$. They are given by:\n$$Y_{\\ell}^{m}(\\theta, \\phi) = \\sqrt{\\frac{(2\\ell+1)}{4\\pi}\\frac{(\\ell-m)!}{(\\ell+m)!}} P_{\\ell}^{m}(\\cos\\theta) e^{im\\phi}$$\nwhere $P_{\\ell}^{m}$ are the associated Legendre polynomials and the phase factor $e^{im\\phi}$ makes them complex for $m \\neq 0$. The Condon-Shortley phase convention, which includes a factor of $(-1)^m$ for $m>0$, is commonly used and is the standard in `scipy.special.sph_harm`. A key property under this convention is $Y_{\\ell}^{-m} = (-1)^m (Y_{\\ell}^{m})^*$, where $*$ denotes complex conjugation.\n\nWhile $Y_{\\ell}^{m}$ are eigenfunctions of the $L_z$ operator, they are not convenient for visualizing electron density in Cartesian space, as chemical bonds align with axes. Real-valued harmonics are constructed via linear combinations of $Y_{\\ell}^{m}$ and $Y_{\\ell}^{-m}$ that eliminate the imaginary parts. The real cubic harmonics are a specific set of such real orbitals chosen to transform according to the irreducible representations of the cubic point group, matching the familiar shapes of $p$- and $d$-orbitals.\n\nFor a given $\\ell$ and $m > 0$, two real, orthonormal functions can be formed:\n$$u_{\\ell,m} \\propto \\Re(Y_{\\ell}^{m})$$\n$$v_{\\ell,m} \\propto \\Im(Y_{\\ell}^{m})$$\nFor $m=0$, $Y_{\\ell}^{0}$ is already real. We select specific combinations and signs to match the conventional Cartesian polynomial forms $x, y, z, xy, yz, xz, x^2-y^2, 3z^2-1$, evaluated on the unit sphere ($r=1$). Using the `scipy` implementation of $Y_{\\ell}^{m}$, the following definitions yield functions that correlate positively with the target polynomials:\nFor $\\ell=1$ ($p$-orbitals):\n- $p_z = Y_1^0 \\propto \\cos\\theta \\equiv z$\n- $p_x = -\\sqrt{2} \\Re(Y_1^1) \\propto \\sin\\theta\\cos\\phi \\equiv x$\n- $p_y = -\\sqrt{2} \\Im(Y_1^1) \\propto \\sin\\theta\\sin\\phi \\equiv y$\n\nFor $\\ell=2$ ($d$-orbitals):\n- $d_{z^2} = Y_2^0 \\propto 3\\cos^2\\theta-1 \\equiv 3z^2-1$\n- $d_{x^2-y^2} = \\sqrt{2} \\Re(Y_2^2) \\propto \\sin^2\\theta\\cos(2\\phi) \\equiv x^2-y^2$\n- $d_{xy} = \\sqrt{2} \\Im(Y_2^2) \\propto \\sin^2\\theta\\sin(2\\phi) \\equiv 2xy$\n- $d_{xz} = -\\sqrt{2} \\Re(Y_2^1) \\propto \\sin\\theta\\cos\\theta\\cos\\phi \\equiv xz$\n- $d_{yz} = -\\sqrt{2} \\Im(Y_2^1) \\propto \\sin\\theta\\cos\\theta\\sin\\phi \\equiv yz$\n\n**2. Numerical Shape Verification**\n\nTo verify that these constructed functions, $h$, reproduce the target Cartesian polynomial shapes, $t$, we compute their correlation coefficient over a set of $N$ sample points, $\\Omega_k$, uniformly distributed on the unit sphere. For a robust and deterministic sampling, a Fibonacci lattice is employed. The correlation coefficient is defined as the cosine similarity between the vectors of function values evaluated at the sample points:\n$$\\mathrm{corr}(h,t) = \\frac{\\sum_{k=1}^{N} h(\\Omega_k)\\, t(\\Omega_k)}{\\sqrt{\\left(\\sum_{k=1}^{N} h(\\Omega_k)^2\\right)\\left(\\sum_{k=1}^{N} t(\\Omega_k)^2\\right)}}$$\nA value close to $1.0$ confirms that the computed harmonic has the correct shape and orientation. This check is performed for the $p$-orbitals with $N=4096$ points and for the $d$-orbitals with $N=8192$ points.\n\n**3. Degeneracy Structure under Cubic Symmetry**\n\nThe five $d$-orbitals are degenerate in a spherically symmetric environment but split into distinct sets of degenerate orbitals under the lower symmetry of a crystal. In a cubic crystal field, they split into a two-dimensional doublet, labeled $e_g$ (spanning $\\{d_{z^2}, d_{x^2-y^2}\\}$), and a three-dimensional triplet, labeled $t_{2g}$ (spanning $\\{d_{xy}, d_{yz}, d_{xz}\\}$). This means that any symmetry operation of the cube will only transform an $e_g$ orbital into a linear combination of other $e_g$ orbitals, and likewise for $t_{2g}$ orbitals. There is no mixing between the two subspaces.\n\nWe verify this property computationally. A rotation $R$ acts on a function $f(\\vec{r})$ by transforming its argument: the rotated function is $f'(\\vec{r}) = f(R^{-1}\\vec{r})$. We can express this rotated function $f'_j$ as a linear combination of the original basis functions $\\{f_i\\}$:\n$$f'_j = \\sum_{i} (C_R)_{ij} f_i$$\nThe matrix $C_R$ is the representation of the rotation $R$ in the basis $\\{f_i\\}$. Its coefficients are found by projecting $f'_j$ onto each $f_i$ using a discrete inner product over $N=6000$ sample points: $\\langle g, h \\rangle = \\sum_k g(\\Omega_k)h(\\Omega_k)$. This leads to the matrix equation $B = G C_R$, where $G_{im} = \\langle f_i, f_m \\rangle$ is the Gram matrix and $B_{ij} = \\langle f_i, f'_j \\rangle$. The representation is then $C_R = G^{-1}B$.\n\nFor our basis ordered as $\\{d_{z^2}, d_{x^2-y^2}, d_{xy}, d_{yz}, d_{xz}\\}$, the matrix $C_R$ should be block-diagonal, with a $2 \\times 2$ block for the $e_g$ subspace and a $3 \\times 3$ block for the $t_{2g}$ subspace.\n$$ C_R \\approx \\begin{pmatrix}\nC_{e_g} & \\mathbf{0}_{2\\times3} \\\\\n\\mathbf{0}_{3\\times2} & C_{t_{2g}}\n\\end{pmatrix} $$\nWe compute $C_R$ for rotations of $\\pi/2$ about the $x$, $y$, and $z$ axes. We then find the maximum absolute value of the elements in the off-diagonal blocks (the $2 \\times 3$ and $3 \\times 2$ zero-blocks) and verify that this value is numerically negligible (less than a tolerance $\\epsilon = 10^{-6}$), confirming the expected degeneracy structure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef solve():\n    \"\"\"\n    Main function to perform all calculations and print the finale result.\n    \"\"\"\n    \n    # ------------------ Helper Functions ------------------\n    \n    def get_fibonacci_sphere_points(n_points):\n        \"\"\"\n        Generates uniformly distributed points on a unit sphere using a Fibonacci lattice.\n        \n        Args:\n            n_points (int): The number of points to generate.\n            \n        Returns:\n            tuple: Arrays for (theta, phi, x, y, z) coordinates of the points.\n        \"\"\"\n        indices = np.arange(0, n_points, dtype=float) + 0.5\n        \n        # Golden ratio\n        phi_const = (1 + np.sqrt(5)) / 2\n        \n        # Spherical coordinates\n        theta = np.arccos(1 - 2 * indices / n_points)\n        phi = (2 * np.pi * indices / phi_const) % (2 * np.pi)\n        \n        # Cartesian coordinates\n        x = np.sin(theta) * np.cos(phi)\n        y = np.sin(theta) * np.sin(phi)\n        z = np.cos(theta)\n        \n        return theta, phi, x, y, z\n\n    def get_real_harmonics(l_val, theta, phi):\n        \"\"\"\n        Calculates real cubic harmonics from complex spherical harmonics.\n        \n        Args:\n            l_val (int): The angular momentum quantum number (1 or 2).\n            theta (np.ndarray): Array of polar angles.\n            phi (np.ndarray): Array of azimuthal angles.\n            \n        Returns:\n            dict: A dictionary mapping orbital names to their evaluated values.\n        \"\"\"\n        Y = {}\n        for m_val in range(-l_val, l_val + 1):\n            Y[m_val] = sph_harm(m_val, l_val, phi, theta)\n            \n        real_harmonics = {}\n        if l_val == 1:\n            real_harmonics['px'] = -np.sqrt(2) * Y[1].real\n            real_harmonics['py'] = -np.sqrt(2) * Y[1].imag\n            real_harmonics['pz'] = Y[0].real\n        elif l_val == 2:\n            # Order for correlation check: d_x2-y2, d_xy, d_xz, d_yz, d_z2\n            real_harmonics['d_z2'] = Y[0].real\n            real_harmonics['d_x2-y2'] = np.sqrt(2) * Y[2].real\n            real_harmonics['d_xy'] = np.sqrt(2) * Y[2].imag\n            real_harmonics['d_xz'] = -np.sqrt(2) * Y[1].real\n            real_harmonics['d_yz'] = -np.sqrt(2) * Y[1].imag\n        return real_harmonics\n\n    def get_target_polynomials(l_val, x, y, z):\n        \"\"\"\n        Evaluates the target Cartesian polynomial shapes on the unit sphere.\n        \n        Args:\n            l_val (int): The angular momentum quantum number (1 or 2).\n            x, y, z (np.ndarray): Cartesian coordinates of sample points.\n            \n        Returns:\n            dict: A dictionary mapping target names to their evaluated values.\n        \"\"\"\n        targets = {}\n        if l_val == 1:\n            targets['px'] = x\n            targets['py'] = y\n            targets['pz'] = z\n        elif l_val == 2:\n            targets['d_z2'] = 3 * z**2 - 1\n            targets['d_x2-y2'] = x**2 - y**2\n            targets['d_xy'] = x * y\n            targets['d_xz'] = x * z\n            targets['d_yz'] = y * z\n        return targets\n\n    def calculate_correlation(h, t):\n        \"\"\"\n        Computes the correlation coefficient between two vectors of function values.\n        \n        Args:\n            h (np.ndarray): Values of the computed harmonic.\n            t (np.ndarray): Values of the target polynomial.\n            \n        Returns:\n            float: The correlation coefficient.\n        \"\"\"\n        return np.dot(h, t) / (np.linalg.norm(h) * np.linalg.norm(t))\n\n    def get_rotation_matrix(axis, angle):\n        \"\"\"\n        Constructs a 3D rotation matrix.\n        \n        Args:\n            axis (str): The axis of rotation ('x', 'y', or 'z').\n            angle (float): The angle of rotation in radians.\n        \n        Returns:\n            np.ndarray: The 3x3 rotation matrix.\n        \"\"\"\n        c, s = np.cos(angle), np.sin(angle)\n        if axis == 'x':\n            return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])\n        elif axis == 'y':\n            return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])\n        elif axis == 'z':\n            return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n\n    def cartesian_to_spherical(x, y, z):\n        \"\"\"\n        Converts Cartesian coordinates to spherical coordinates (ignoring radius).\n        \n        Args:\n            x, y, z (np.ndarray): Cartesian coordinate arrays.\n        \n        Returns:\n            tuple: Arrays for (theta, phi) angles.\n        \"\"\"\n        theta = np.arccos(np.clip(z, -1.0, 1.0))\n        phi = np.arctan2(y, x)\n        return theta, phi\n\n    # ------------------ Main Logic ------------------\n\n    results = []\n    \n    # Part 1: l=1 Shape Verification\n    N1 = 4096\n    theta1, phi1, x1, y1, z1 = get_fibonacci_sphere_points(N1)\n    real_harmonics_l1 = get_real_harmonics(1, theta1, phi1)\n    target_polys_l1 = get_target_polynomials(1, x1, y1, z1)\n    \n    p_orbitals_order = ['px', 'py', 'pz']\n    for orbital in p_orbitals_order:\n        corr = calculate_correlation(real_harmonics_l1[orbital], target_polys_l1[orbital])\n        results.append(corr)\n\n    # Part 2: l=2 Shape Verification\n    N2 = 8192\n    theta2, phi2, x2, y2, z2 = get_fibonacci_sphere_points(N2)\n    real_harmonics_l2 = get_real_harmonics(2, theta2, phi2)\n    target_polys_l2 = get_target_polynomials(2, x2, y2, z2)\n    \n    d_orbitals_corr_order = ['d_x2-y2', 'd_xy', 'd_xz', 'd_yz', 'd_z2']\n    for orbital in d_orbitals_corr_order:\n        corr = calculate_correlation(real_harmonics_l2[orbital], target_polys_l2[orbital])\n        results.append(corr)\n\n    # Part 3: l=2 Degeneracy Structure Verification\n    N3 = 6000\n    TOLERANCE = 1e-6\n    theta3, phi3, x3, y3, z3 = get_fibonacci_sphere_points(N3)\n    \n    # Basis order for degeneracy check: e_g {d_z2, d_x2-y2}, t_2g {d_xy, d_yz, d_xz}\n    d_degen_order = ['d_z2', 'd_x2-y2', 'd_xy', 'd_yz', 'd_xz']\n    harmonics_l2_degen = get_real_harmonics(2, theta3, phi3)\n    \n    f_basis = np.array([harmonics_l2_degen[orb] for orb in d_degen_order]).T\n\n    # Gram matrix G = F^T F\n    G = f_basis.T @ f_basis\n    G_inv = np.linalg.inv(G)\n\n    initial_coords = np.vstack([x3, y3, z3])\n\n    rot_matrices = {\n        'Rz': get_rotation_matrix('z', np.pi/2),\n        'Rx': get_rotation_matrix('x', np.pi/2),\n        'Ry': get_rotation_matrix('y', np.pi/2),\n    }\n\n    for R_matrix in rot_matrices.values():\n        R_inv = R_matrix.T\n        rotated_coords = R_inv @ initial_coords\n        rx, ry, rz = rotated_coords[0,:], rotated_coords[1,:], rotated_coords[2,:]\n        \n        r_theta, r_phi = cartesian_to_spherical(rx, ry, rz)\n        \n        rot_d_harmonics = get_real_harmonics(2, r_theta, r_phi)\n        f_prime_basis = np.array([rot_d_harmonics[orb] for orb in d_degen_order]).T\n\n        # Matrix B = F^T F'\n        B = f_basis.T @ f_prime_basis\n        \n        # Representation matrix C_R = G^-1 B\n        C_R = G_inv @ B\n\n        # Check off-block elements\n        off_block_eg_t2g = C_R[0:2, 2:5]\n        off_block_t2g_eg = C_R[2:5, 0:2]\n\n        max_off_diag = max(np.abs(off_block_eg_t2g).max(), np.abs(off_block_t2g_eg).max())\n        results.append(max_off_diag < TOLERANCE)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Localized electronic states, such as those introduced by point defects in a crystal, are key to understanding a material's electronic and optical properties. A powerful way to analyze these states is to decompose their wavefunctions into contributions from different angular momentum channels ($s, p, d$, etc.). This exercise provides hands-on practice with this projection technique, demonstrating how to identify the dominant orbital character of a model defect state and track its evolution under external pressure .",
            "id": "3433580",
            "problem": "In computational materials science, localized electronic states near point defects in wide-band-gap oxides can be characterized by their angular momentum content when expanded in an atomic-like basis. Assume a single-particle Kohn–Sham (KS) defect state, localized around the defect site, is probed within a chosen spherical region of radius $R$ centered on the defect. The angular dependence of the state can be represented in the spherical harmonic basis $Y_{\\ell m}(\\theta,\\phi)$, while the radial component is modeled with pressure-dependent decaying functions. Use the orthonormality of spherical harmonics as the fundamental base and the separation of variables of the time-independent Schrödinger equation in spherical coordinates to derive a projection scheme that identifies the dominant local $(\\ell,m)$ character of the defect state inside the sphere and tracks its evolution under hydrostatic pressure.\n\nYou are given a synthetic but physically motivated model wavefunction inside the sphere:\n$$\n\\psi(\\mathbf{r};P) \\equiv \\psi(r,\\theta,\\phi;P) = \\sum_{\\ell=0}^{2} A_{\\ell 0}(P)\\, f_{\\ell}(r;P)\\, Y_{\\ell 0}(\\theta,\\phi),\n$$\nwith only $m=0$ components retained to represent a symmetry-preserving defect along the $z$ axis. The radial functions are\n$$\nf_0(r;P) = N_0(P)\\, e^{-r/a(P)},\\quad\nf_1(r;P) = N_1(P)\\, r\\, e^{-r/a(P)},\\quad\nf_2(r;P) = N_2(P)\\, r^2\\, e^{-r/a(P)},\n$$\nwhere the pressure-dependent decay length is\n$$\na(P) = \\frac{a_0}{1+\\beta P}.\n$$\nTake $a_0 = 1.5$ angstrom and $\\beta = 0.02$ per gigapascal so that $P$ is in gigapascal and $a(P)$ is in angstrom. The normalization constants $N_{\\ell}(P)$ are chosen so that the radial measure integrates to unity over all space for each channel,\n$$\n\\int_{0}^{\\infty} r^2\\, f_{\\ell}(r;P)\\, dr = 1,\n$$\nwhich implies\n$$\nN_0(P) = \\frac{1}{2\\,a(P)^3},\\quad N_1(P) = \\frac{1}{6\\,a(P)^4},\\quad N_2(P) = \\frac{1}{24\\,a(P)^5}.\n$$\nThe unnormalized pressure-dependent angular amplitudes are\n$$\n\\tilde{A}_{00}(P) = \\cos\\big(\\theta(P)\\big),\\quad\n\\tilde{A}_{10}(P) = \\sin\\big(\\theta(P)\\big),\\quad\n\\tilde{A}_{20}(P) = \\gamma \\max(P,0),\n$$\nwith\n$$\n\\theta(P) = \\theta_0 + k P,\\quad \\theta_0 = \\frac{\\pi}{8},\\quad k = \\frac{\\pi}{90},\\quad \\gamma = 0.03,\n$$\nwhere angles are in radians and pressure $P$ is in gigapascal. The amplitudes are then normalized to unit norm,\n$$\nA_{\\ell 0}(P) = \\frac{\\tilde{A}_{\\ell 0}(P)}{\\sqrt{\\sum_{\\ell'=0}^{2} \\tilde{A}_{\\ell' 0}(P)^2}}.\n$$\n\nStarting from the orthonormality of spherical harmonics,\n$$\n\\int Y_{\\ell m}^{*}(\\theta,\\phi)\\, Y_{\\ell' m'}(\\theta,\\phi)\\, d\\Omega = \\delta_{\\ell\\ell'}\\delta_{m m'},\n$$\nderive the expression for the projection coefficient inside a finite sphere of radius $R$,\n$$\nC_{\\ell 0}(R,P) = \\int_{0}^{R}\\int \\psi(r,\\theta,\\phi;P)\\, Y_{\\ell 0}^{*}(\\theta,\\phi)\\, r^2 \\sin\\theta\\, d\\theta\\, d\\phi\\, dr,\n$$\nand show how it reduces to a product of an angular amplitude and a radial integral due to the orthonormality in angle. For the given $f_{\\ell}$, compute the radial accumulation factors\n$$\nS_{\\ell}(R,P) \\equiv \\int_{0}^{R} r^2\\, f_{\\ell}(r;P)\\, dr,\n$$\nand use them to evaluate\n$$\nC_{\\ell 0}(R,P) = A_{\\ell 0}(P)\\, S_{\\ell}(R,P).\n$$\nDefine the channel weights inside the sphere as\n$$\nw_{\\ell 0}(R,P) = \\frac{\\left|C_{\\ell 0}(R,P)\\right|^2}{\\sum_{\\ell'=0}^{2}\\left|C_{\\ell' 0}(R,P)\\right|^2}.\n$$\nYour task is to implement a program that, for each specified test case $(R,P)$, computes the normalized weights $w_{00}(R,P)$, $w_{10}(R,P)$, $w_{20}(R,P)$ and identifies the dominant $(\\ell,m)$ channel by maximum weight. Round the reported weights to $6$ decimal places. Report the dominant pair as integers $(\\ell,m)$.\n\nPhysical units: input pressures $P$ are in gigapascal and radii $R$ are in angstrom. The computed weights are dimensionless.\n\nAngle unit: radians must be used for all trigonometric functions.\n\nTest suite to cover diverse conditions:\n- Case $1$: $R=4.0$ angstrom, $P=0$ gigapascal.\n- Case $2$: $R=4.0$ angstrom, $P=10$ gigapascal.\n- Case $3$: $R=4.0$ angstrom, $P=20$ gigapascal.\n- Case $4$: $R=2.0$ angstrom, $P=10$ gigapascal.\n- Case $5$: $R=4.0$ angstrom, $P=-5$ gigapascal.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is a list of the form $[\\ell_{\\mathrm{dom}},m_{\\mathrm{dom}},w_{00},w_{10},w_{20}]$ with the weights in the order $[\\ell=0,\\ell=1,\\ell=2]$. For example, a valid output format is\n$[[0,0,0.750000,0.200000,0.050000],[\\dots],\\dots]$.",
            "solution": "The problem statement has been critically validated and is deemed to be self-contained, scientifically grounded, and well-posed. All provided data, definitions, and constraints are consistent and physically meaningful within the context of computational materials science and quantum mechanics. The task is to derive and implement a projection scheme to analyze a model defect-state wavefunction.\n\n### Derivation of the Projection Coefficient $C_{\\ell 0}(R,P)$\n\nThe projection coefficient, $C_{\\ell 0}(R,P)$, quantifies the contribution of the $(\\ell, m=0)$ angular momentum channel to the total wavefunction, $\\psi(\\mathbf{r};P)$, within a sphere of radius $R$. It is defined by the inner product of the wavefunction with the corresponding spherical harmonic, $Y_{\\ell 0}(\\theta,\\phi)$, integrated over the volume of the sphere.\n\nThe definition is given as:\n$$\nC_{\\ell 0}(R,P) = \\int_{0}^{R}\\int_{\\Omega} \\psi(r,\\theta,\\phi;P)\\, Y_{\\ell 0}^{*}(\\theta,\\phi)\\, r^2 d\\Omega\\, dr\n$$\nwhere the differential solid angle is $d\\Omega = \\sin\\theta\\, d\\theta\\, d\\phi$.\n\nThe model wavefunction provided is a linear combination of basis functions, each being a product of a radial part $f_{\\ell'}(r;P)$ and an angular part $Y_{\\ell' 0}(\\theta,\\phi)$:\n$$\n\\psi(r,\\theta,\\phi;P) = \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P)\\, f_{\\ell'}(r;P)\\, Y_{\\ell' 0}(\\theta,\\phi)\n$$\nSubstituting this expression for $\\psi$ into the definition of $C_{\\ell 0}(R,P)$:\n$$\nC_{\\ell 0}(R,P) = \\int_{0}^{R}\\int_{\\Omega} \\left( \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P)\\, f_{\\ell'}(r;P)\\, Y_{\\ell' 0}(\\theta,\\phi) \\right) Y_{\\ell 0}^{*}(\\theta,\\phi)\\, r^2 d\\Omega\\, dr\n$$\nSince the integral and sum operators are linear, their order can be interchanged. The coefficients $A_{\\ell' 0}(P)$ and the radial functions $f_{\\ell'}(r;P)$ are independent of the angular variables $(\\theta,\\phi)$ and can be factored out of the angular integral:\n$$\nC_{\\ell 0}(R,P) = \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P) \\int_{0}^{R} f_{\\ell'}(r;P)\\, r^2 \\left( \\int_{\\Omega} Y_{\\ell' 0}(\\theta,\\phi) Y_{\\ell 0}^{*}(\\theta,\\phi)\\, d\\Omega \\right) dr\n$$\nThe core of the derivation rests on the orthonormality property of the spherical harmonics:\n$$\n\\int_{\\Omega} Y_{\\ell' m'}(\\theta,\\phi) Y_{\\ell m}^{*}(\\theta,\\phi)\\, d\\Omega = \\delta_{\\ell\\ell'}\\delta_{mm'}\n$$\nIn our case, $m=m'=0$, so the integral simplifies to:\n$$\n\\int_{\\Omega} Y_{\\ell' 0}(\\theta,\\phi) Y_{\\ell 0}^{*}(\\theta,\\phi)\\, d\\Omega = \\delta_{\\ell\\ell'}\n$$\n(Note that for $m=0$, the spherical harmonics are real, so $Y_{\\ell 0}^{*} = Y_{\\ell 0}$.)\n\nSubstituting the Kronecker delta $\\delta_{\\ell\\ell'}$ back into the expression for $C_{\\ell 0}(R,P)$:\n$$\nC_{\\ell 0}(R,P) = \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P) \\int_{0}^{R} f_{\\ell'}(r;P)\\, r^2 \\delta_{\\ell\\ell'} dr\n$$\nThe Kronecker delta is non-zero (equal to $1$) only when $\\ell'=\\ell$. This property collapses the summation over $\\ell'$ to a single term corresponding to the specific $\\ell$ of the projection:\n$$\nC_{\\ell 0}(R,P) = A_{\\ell 0}(P) \\int_{0}^{R} f_{\\ell}(r;P)\\, r^2 dr\n$$\nThe remaining integral is precisely the definition of the radial accumulation factor, $S_{\\ell}(R,P)$:\n$$\nS_{\\ell}(R,P) \\equiv \\int_{0}^{R} r^2\\, f_{\\ell}(r;P)\\, dr\n$$\nThus, we arrive at the final expression for the projection coefficient, which separates the angular and radial contributions:\n$$\nC_{\\ell 0}(R,P) = A_{\\ell 0}(P)\\, S_{\\ell}(R,P)\n$$\nThis demonstrates that the projection operation effectively isolates the channel-specific amplitude $A_{\\ell 0}(P)$ and weights it by the fraction of the radial density $r^2|f_\\ell(r;P)|$ contained within the sphere of radius $R$.\n\n### Derivation of the Radial Accumulation Factors $S_{\\ell}(R,P)$\n\nThe radial accumulation factor $S_{\\ell}(R,P)$ for each channel $\\ell \\in \\{0, 1, 2\\}$ must be calculated. The radial functions are $f_0(r;P) = N_0(P) e^{-r/a(P)}$, $f_1(r;P) = N_1(P) r e^{-r/a(P)}$, and $f_2(r;P) = N_2(P) r^2 e^{-r/a(P)}$.\nLet's introduce the variable $x = r/a(P)$, where $a(P)$ is the pressure-dependent decay length. The integral for $S_{\\ell}(R,P)$ can be expressed in terms of $x$.\n\nFor $\\ell=0$:\n$$S_0(R,P) = \\int_{0}^{R} r^2 N_0(P) e^{-r/a(P)} dr = N_0(P) \\int_{0}^{R} r^2 e^{-r/a(P)} dr$$\nWith $N_0(P) = 1/(2a(P)^3)$ and substituting $r=xa(P)$, $dr=a(P)dx$:\n$$S_0(R,P) = \\frac{1}{2a(P)^3} \\int_{0}^{R/a(P)} (xa(P))^2 e^{-x} a(P)dx = \\frac{1}{2} \\int_{0}^{R/a(P)} x^2 e^{-x} dx$$\nThis integral is related to the lower incomplete gamma function, $\\gamma(s,z) = \\int_0^z t^{s-1}e^{-t}dt$. Here, $s=3$ and $z=R/a(P)$. The integral is $\\gamma(3, R/a(P))$. The corresponding regularized lower incomplete gamma function is $P(s,z) = \\gamma(s,z)/\\Gamma(s)$. Since $\\Gamma(3)=2! = 2$, we have $S_0(R,P) = P(3, R/a(P))$.\n\nSimilarly, for $\\ell=1$ and $\\ell=2$, we integrate $r^3$ and $r^4$ respectively:\n$$S_1(R,P) = \\frac{1}{6} \\int_{0}^{R/a(P)} x^3 e^{-x} dx = \\frac{\\gamma(4, R/a(P))}{\\Gamma(4)} = P(4, R/a(P))$$\n$$S_2(R,P) = \\frac{1}{24} \\int_{0}^{R/a(P)} x^4 e^{-x} dx = \\frac{\\gamma(5, R/a(P))}{\\Gamma(5)} = P(5, R/a(P))$$\nFor integer $s$, $P(s,z) = 1 - e^{-z}\\sum_{k=0}^{s-1} \\frac{z^k}{k!}$. Letting $z=R/a(P)$, we obtain the explicit formulas:\n$$S_0(R,P) = 1 - e^{-z} \\left(1 + z + \\frac{z^2}{2}\\right)$$\n$$S_1(R,P) = 1 - e^{-z} \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{6}\\right)$$\n$$S_2(R,P) = 1 - e^{-z} \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}\\right)$$\nThese formulas can be implemented directly or by using a standard library function for the regularized incomplete gamma function.\n\n### Computational Strategy\n\nThe overall algorithm to compute the channel weights for a given pair of inputs $(R,P)$ is as follows:\n1.  Define the physical constants $a_0=1.5$, $\\beta=0.02$, $\\theta_0=\\pi/8$, $k=\\pi/90$, and $\\gamma=0.03$.\n2.  Calculate the pressure-dependent decay length $a(P) = a_0 / (1+\\beta P)$.\n3.  Calculate the pressure-dependent angle $\\theta(P) = \\theta_0 + kP$.\n4.  Compute the unnormalized angular amplitudes: $\\tilde{A}_{00}(P) = \\cos(\\theta(P))$, $\\tilde{A}_{10}(P) = \\sin(\\theta(P))$, and $\\tilde{A}_{20}(P) = \\gamma \\max(P,0)$.\n5.  Normalize the amplitudes: $A_{\\ell 0}(P) = \\tilde{A}_{\\ell 0}(P) / \\sqrt{\\sum_{\\ell'} \\tilde{A}_{\\ell' 0}(P)^2}$.\n6.  Calculate the dimensionless variable $z = R/a(P)$.\n7.  Compute the radial accumulation factors $S_0(R,P)$, $S_1(R,P)$, and $S_2(R,P)$ using the formulas derived above (or equivalent library functions).\n8.  Calculate the projection coefficients $C_{\\ell 0}(R,P) = A_{\\ell 0}(P) \\times S_{\\ell}(R,P)$ for $\\ell \\in \\{0, 1, 2\\}$.\n9.  Compute the squared magnitudes of the coefficients, $|C_{\\ell 0}(R,P)|^2$.\n10. Calculate the channel weights $w_{\\ell 0}(R,P) = |C_{\\ell 0}(R,P)|^2 / \\sum_{\\ell'} |C_{\\ell' 0}(R,P)|^2$.\n11. Identify the dominant channel $(\\ell_{\\mathrm{dom}}, m_{\\mathrm{dom}})$ by finding the index $\\ell$ that maximizes the weight $w_{\\ell 0}$. The magnetic quantum number $m$ is fixed at $m_{\\mathrm{dom}}=0$.\n12. Format the results as requested: $[\\ell_{\\mathrm{dom}}, m_{\\mathrm{dom}}, w_{00}, w_{10}, w_{20}]$, with weights rounded to $6$ decimal places.\n\nThis procedure will be implemented for each test case specified in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammainc\n\ndef solve():\n    \"\"\"\n    Computes and identifies the dominant angular momentum channel for a model\n    defect state under varying pressure and analysis radius.\n    \"\"\"\n    \n    # Define physical constants and parameters from the problem statement.\n    a0 = 1.5      # angstrom\n    beta = 0.02   # per GPa\n    theta0 = np.pi / 8.0\n    k = np.pi / 90.0\n    gamma = 0.03\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (R in angstrom, P in gigapascal)\n        (4.0, 0.0),\n        (4.0, 10.0),\n        (4.0, 20.0),\n        (2.0, 10.0),\n        (4.0, -5.0),\n    ]\n\n    results_str = []\n    for R, P in test_cases:\n        # Step 1: Calculate pressure-dependent parameters\n        a_P = a0 / (1.0 + beta * P)\n        theta_P = theta0 + k * P\n\n        # Step 2: Calculate unnormalized angular amplitudes\n        A_tilde_00 = np.cos(theta_P)\n        A_tilde_10 = np.sin(theta_P)\n        A_tilde_20 = gamma * max(P, 0.0)\n        \n        # Step 3: Normalize the angular amplitudes\n        amplitudes_tilde = np.array([A_tilde_00, A_tilde_10, A_tilde_20])\n        norm_A = np.sqrt(np.sum(np.square(amplitudes_tilde)))\n        amplitudes_A = amplitudes_tilde / norm_A if norm_A > 0 else np.zeros(3)\n\n        # Step 4: Calculate radial accumulation factors S_l(R,P)\n        # These are regularized lower incomplete gamma functions P(s, z)\n        # where s = l + n + 1 and z = R/a(P).\n        # For f_l(r) ~ r^l, the integral is over r^2 * f_l(r) ~ r^(l+2).\n        # So we have integrals over r^2, r^3, r^4 corresponding to s=3,4,5.\n        z = R / a_P\n        S_factors = np.array([\n            gammainc(3, z),  # S_0(R,P) for l=0\n            gammainc(4, z),  # S_1(R,P) for l=1\n            gammainc(5, z)   # S_2(R,P) for l=2\n        ])\n\n        # Step 5: Calculate projection coefficients C_l0(R,P)\n        coeffs_C = amplitudes_A * S_factors\n\n        # Step 6: Calculate channel weights w_l0(R,P)\n        squared_C = np.square(coeffs_C)\n        sum_squared_C = np.sum(squared_C)\n        \n        if sum_squared_C > 1e-12: # Avoid division by zero\n            weights = squared_C / sum_squared_C\n        else:\n            weights = np.array([1.0/3.0, 1.0/3.0, 1.0/3.0]) # Degenerate case, e.g. R=0\n\n        w00, w10, w20 = weights\n        \n        # Step 7: Identify the dominant channel\n        l_dom = np.argmax(weights)\n        m_dom = 0\n        \n        # Step 8: Format the output for the current case\n        result_str = f\"[{l_dom},{m_dom},{w00:.6f},{w10:.6f},{w20:.6f}]\"\n        results_str.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Modern electronic structure methods like the Projector Augmented-Wave (PAW) approach rely on a set of localized atomic-like basis functions, or partial waves, to accurately describe the wavefunction near the atomic core. The choice of this basis is not arbitrary; its completeness directly impacts the accuracy of calculated physical observables. In this exercise, you will implement a simplified augmentation scheme to investigate how the number and shape of these partial waves influence the computed orbital-resolved density of states and local magnetic moments in a model transition metal oxide .",
            "id": "3433603",
            "problem": "You are tasked with implementing a simplified, yet principled, projector augmented-wave augmentation scheme for a single angular momentum channel in order to study how the number and radial shape of partial waves affects orbital-resolved quantities. Your implementation must be based on first principles of quantum mechanics and standard definitions used in electronic structure theory, and must be expressed in purely mathematical and algorithmic terms.\n\nThe physical and mathematical context is the following. In the augmentation sphere of radius $r_{c}$ around an atom, the electronic structure code represents the all-electron wavefunction by augmenting a smooth pseudo-wavefunction with a set of localized partial waves. For a given angular momentum channel $l$, define a family of $N$ radial partial waves $R_{n l}(r)$, indexed by $n \\in \\{1,\\dots,N\\}$, that are supported on $r \\in [0,r_{c}]$. Assume spherical symmetry within the augmentation sphere and treat only the radial part for the channel $l$. Let the reference radial amplitude for the target $l$-channel be a normalized function $\\psi_{l}(r)$ representing the all-electron character inside the sphere.\n\nThe computational tasks are:\n\n1. Define each partial wave as $R_{n l}(r) = \\mathcal{N}_{n l} \\, r^{l} e^{-\\alpha_{n} r^{2}}$ on $r \\in [0,r_{c}]$, where $\\alpha_{n} > 0$ controls the radial shape and $\\mathcal{N}_{n l}$ is the normalization factor chosen such that $\\int_{0}^{r_{c}} r^{2} \\left|R_{n l}(r)\\right|^{2} \\, \\mathrm{d}r = 1$. For the test suite below, you will use the rule $\\alpha_{n} = \\alpha_{\\mathrm{base}} \\cdot n$, with given $\\alpha_{\\mathrm{base}} > 0$.\n\n2. Construct biorthogonal projector functions $p_{n l}(r)$ such that $\\int_{0}^{r_{c}} r^{2} R_{n l}(r) \\, p_{m l}(r) \\, \\mathrm{d}r = \\delta_{n m}$ for all $n,m \\in \\{1,\\dots,N\\}$. You must obtain $p_{n l}(r)$ by inverting the finite overlap matrix $S_{n m} = \\int_{0}^{r_{c}} r^{2} R_{n l}(r) \\, R_{m l}(r) \\, \\mathrm{d}r$ and forming the linear combinations $p_{n l}(r) = \\sum_{m=1}^{N} \\left(S^{-1}\\right)_{n m} R_{m l}(r)$.\n\n3. Define a normalized reference radial amplitude for the $l$-channel as $\\psi_{l}(r) = \\mathcal{N}^{\\mathrm{ref}}_{l} \\, r^{l} e^{-\\alpha_{\\mathrm{ref}} r^{2}}$ with $\\int_{0}^{r_{c}} r^{2} \\left|\\psi_{l}(r)\\right|^{2} \\, \\mathrm{d}r = 1$.\n\n4. Compute the projection coefficients $a_{n} = \\int_{0}^{r_{c}} r^{2} \\, p_{n l}(r) \\, \\psi_{l}(r) \\, \\mathrm{d}r$ and the reconstructed projection $\\psi^{\\mathrm{proj}}_{l}(r) = \\sum_{n=1}^{N} a_{n} R_{n l}(r)$.\n\n5. Define the captured fraction $f$ of the $l$-channel radial amplitude by $f = \\int_{0}^{r_{c}} r^{2} \\left|\\psi^{\\mathrm{proj}}_{l}(r)\\right|^{2} \\, \\mathrm{d}r$. This quantity measures how completely the chosen partial waves span the reference $l$-channel character inside the sphere. By construction $0 \\le f \\le 1$.\n\n6. Model a simplified $3 d$ manifold (with $l = 2$) in a transition metal oxide as five discrete levels: three $t_{2 g}$ levels at energy $E_{t}$ and two $e_{g}$ levels at energy $E_{e}$. Introduce collinear spin polarization by shifting spin-up and spin-down energies by $\\pm \\Delta/2$, so that the spin-up energies are $E_{t}^{\\uparrow} = E_{t} - \\Delta/2$ (threefold) and $E_{e}^{\\uparrow} = E_{e} - \\Delta/2$ (twofold), and the spin-down energies are $E_{t}^{\\downarrow} = E_{t} + \\Delta/2$ (threefold) and $E_{e}^{\\downarrow} = E_{e} + \\Delta/2$ (twofold). Let $E_{F}$ denote the Fermi level.\n\n7. Define a Gaussian broadening function $G(x;\\eta) = \\frac{1}{\\eta \\sqrt{\\pi}} \\exp\\left(-\\frac{x^{2}}{\\eta^{2}}\\right)$ of width parameter $\\eta > 0$. The $d$-channel, spin-resolved density of states at the Fermi level is modeled as\n$$\nD^{\\sigma}_{d}(E_{F}) = f \\sum_{i \\in \\text{levels of spin } \\sigma} G\\left(E_{F} - E_{i}^{\\sigma}; \\eta\\right),\n$$\nwhere $\\sigma \\in \\{\\uparrow,\\downarrow\\}$ and the sum runs over the five $d$ levels with their respective degeneracies and energies for spin $\\sigma$. Express $D^{\\sigma}_{d}(E_{F})$ in states per electronvolt (eV$^{-1}$).\n\n8. Determine the orbital-resolved $d$-channel magnetic moment (in Bohr magnetons) by counting occupations at $E_{F}$ and scaling by the captured fraction $f$:\n$$\n\\mu_{d} = \\mu_{B} \\left( f \\, N_{\\uparrow} - f \\, N_{\\downarrow} \\right),\n$$\nwhere $N_{\\sigma}$ is the number of $d$ levels of spin $\\sigma$ that satisfy $E_{i}^{\\sigma} \\le E_{F}$, and $\\mu_{B}$ denotes the Bohr magneton. In this simplified model, take $\\mu_{B} = 1$ so that $\\mu_{d}$ is reported in Bohr magnetons directly as a dimensionless float.\n\nAll radial integrals must be evaluated on $r \\in [0,r_{c}]$ with measure $r^{2} \\, \\mathrm{d}r$. Angles do not enter because of the assumed spherical symmetry within the augmentation sphere. Radial distances must be treated in Bohr radii, energies in electronvolts, the density of states in states per electronvolt, and magnetic moments in Bohr magnetons.\n\nYour program must implement the above scheme and apply it to the following test suite. For each test case, the parameters are given as a tuple $(l, r_{c}, N, \\alpha_{\\mathrm{base}}, \\alpha_{\\mathrm{ref}}, E_{t}, E_{e}, \\Delta, E_{F}, \\eta)$:\n\n- Test case $1$ (happy path): $(2, 2.0, 3, 2.0, 1.2, -1.0, 0.5, 1.5, 0.0, 0.2)$.\n- Test case $2$ (reduced completeness): $(2, 2.0, 1, 2.0, 1.2, -1.0, 0.5, 1.5, 0.0, 0.2)$.\n- Test case $3$ (shape mismatch): $(2, 2.0, 4, 5.0, 1.0, -1.0, 0.5, 1.5, 0.0, 0.2)$.\n- Test case $4$ (nonmagnetic boundary): $(2, 2.0, 3, 2.0, 1.2, -1.0, 0.5, 0.0, 0.0, 0.2)$.\n\nFor each test case, compute and return the triple $[D^{\\uparrow}_{d}(E_{F}), D^{\\downarrow}_{d}(E_{F}), \\mu_{d}]$, where $D^{\\uparrow}_{d}(E_{F})$ and $D^{\\downarrow}_{d}(E_{F})$ are floats in eV$^{-1}$ and $\\mu_{d}$ is a float in Bohr magnetons.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list in the order specified above. For example, the output should look like\n$\\left[ [x_{1}, y_{1}, z_{1}], [x_{2}, y_{2}, z_{2}], [x_{3}, y_{3}, z_{3}], [x_{4}, y_{4}, z_{4}] \\right]$,\nwith actual numeric values where $x_{i}$, $y_{i}$, and $z_{i}$ are floats.",
            "solution": "The problem requires the implementation of a simplified projector augmented-wave (PAW) scheme to compute orbital-resolved properties. The problem is valid as it is scientifically grounded in the principles of quantum mechanics and electronic structure theory, is mathematically well-posed, and all parameters and procedures are objectively and completely defined. The solution proceeds by implementing the specified steps.\n\nThe core of the problem involves projecting a reference radial wavefunction, $\\psi_{l}(r)$, onto a finite basis of $N$ partial waves, $\\{R_{n l}(r)\\}_{n=1}^{N}$. All functions are defined within an augmentation sphere of radius $r_{c}$.\n\nFirst, we define the functional form of the unnormalized radial partial waves and the reference wave for a given angular momentum channel $l$:\n$$\n\\tilde{R}_{n l}(r) = r^{l} e^{-\\alpha_{n} r^{2}}\n$$\n$$\n\\tilde{\\psi}_{l}(r) = r^{l} e^{-\\alpha_{\\mathrm{ref}} r^{2}}\n$$\nwhere $n \\in \\{1, \\dots, N\\}$, and the decay parameters are given by $\\alpha_{n} = \\alpha_{\\mathrm{base}} \\cdot n$. The functions are supported on the interval $r \\in [0, r_{c}]$.\n\nThe normalized functions, $R_{n l}(r)$ and $\\psi_{l}(r)$, are obtained by requiring unit norm with respect to the inner product defined with the measure $r^2 dr$:\n$$\n\\int_{0}^{r_{c}} r^{2} |R_{n l}(r)|^{2} \\, \\mathrm{d}r = 1 \\quad \\text{and} \\quad \\int_{0}^{r_{c}} r^{2} |\\psi_{l}(r)|^{2} \\, \\mathrm{d}r = 1\n$$\nThis determines the normalization constants $\\mathcal{N}_{n l}$ and $\\mathcal{N}^{\\mathrm{ref}}_{l}$, such that $R_{n l}(r) = \\mathcal{N}_{n l} \\tilde{R}_{n l}(r)$ and $\\psi_l(r) = \\mathcal{N}^{\\mathrm{ref}}_{l} \\tilde{\\psi}_l(r)$. The normalization integral for a function of the form $f(r) = r^l e^{-Ar^2}$ is given by:\n$$\n\\int_{0}^{r_{c}} r^{2} |f(r)|^{2} \\, \\mathrm{d}r = \\int_{0}^{r_{c}} r^{2l+2} e^{-2Ar^2} \\, \\mathrm{d}r\n$$\nThis integral can be evaluated analytically using the lower incomplete gamma function, $\\gamma(s, x) = \\int_0^x t^{s-1} e^{-t} dt$. By substituting $t = 2Ar^2$, we find the integral is equal to:\n$$\nI(A, l) = \\frac{1}{2(2A)^{(2l+3)/2}} \\gamma\\left(\\frac{2l+3}{2}, 2Ar_c^2\\right)\n$$\nThe normalization constant is then $\\mathcal{N} = 1/\\sqrt{I(A,l)}$.\n\nSecond, we construct the biorthogonal projector functions $p_{nl}(r)$. The partial waves $\\{R_{nl}(r)\\}$ are not mutually orthogonal. Their overlap is quantified by the overlap matrix $S$:\n$$\nS_{nm} = \\int_{0}^{r_{c}} r^{2} R_{n l}(r) R_{m l}(r) \\, \\mathrm{d}r\n$$\nThe integral for the matrix elements $S_{nm}$ is of a similar form:\n$$\n\\int_{0}^{r_{c}} r^{2} (\\mathcal{N}_{nl} r^l e^{-\\alpha_n r^2}) (\\mathcal{N}_{ml} r^l e^{-\\alpha_m r^2}) \\, \\mathrm{d}r = \\mathcal{N}_{nl}\\mathcal{N}_{ml} \\int_{0}^{r_{c}} r^{2l+2} e^{-(\\alpha_n+\\alpha_m)r^2} \\, \\mathrm{d}r\n$$\nThis integral can also be evaluated using a generalized form of the integral expression $I$ above. The biorthogonal projectors are formed as linear combinations of the partial waves, $p_{n l}(r) = \\sum_{m=1}^{N} (S^{-1})_{nm} R_{m l}(r)$, where $S^{-1}$ is the inverse of the matrix $S$. By construction, these projectors satisfy the biorthogonality condition $\\int_{0}^{r_{c}} r^{2} p_{n l}(r) R_{m l}(r) \\, \\mathrm{d}r = \\delta_{nm}$.\n\nThird, we project the reference wave $\\psi_l(r)$ onto the basis of partial waves. The projected wave is $\\psi^{\\mathrm{proj}}_{l}(r) = \\sum_{n=1}^{N} a_{n} R_{n l}(r)$, where the coefficients $a_n$ are computed as:\n$$\na_{n} = \\int_{0}^{r_{c}} r^{2} p_{n l}(r) \\psi_{l}(r) \\, \\mathrm{d}r = \\sum_{m=1}^{N} (S^{-1})_{nm} \\int_{0}^{r_{c}} r^{2} R_{m l}(r) \\psi_{l}(r) \\, \\mathrm{d}r\n$$\nLet's define the vector $\\mathbf{b}$ of overlaps between the reference wave and the partial waves, with components $b_m = \\int_{0}^{r_{c}} r^{2} R_{m l}(r) \\psi_{l}(r) \\, \\mathrm{d}r$. The vector of projection coefficients is then given by $\\mathbf{a} = S^{-1}\\mathbf{b}$.\n\nFourth, we calculate the captured fraction $f$, which measures the fidelity of the projection. It is the squared norm of the projected wave:\n$$\nf = \\int_{0}^{r_{c}} r^{2} |\\psi^{\\mathrm{proj}}_{l}(r)|^{2} \\, \\mathrm{d}r = \\int_{0}^{r_{c}} r^{2} \\left( \\sum_n a_n R_{nl}(r) \\right) \\left( \\sum_m a_m R_{ml}(r) \\right) \\, \\mathrm{d}r\n$$\n$$\nf = \\sum_{n,m} a_n a_m S_{nm} = \\mathbf{a}^T S \\mathbf{a}\n$$\nSubstituting $\\mathbf{a} = S^{-1}\\mathbf{b}$, and noting that $S$ is symmetric ($S^T = S$), we get a computationally convenient form:\n$$\nf = (S^{-1}\\mathbf{b})^T S (S^{-1}\\mathbf{b}) = \\mathbf{b}^T (S^{-1})^T S S^{-1} \\mathbf{b} = \\mathbf{b}^T S^{-1} \\mathbf{b} = \\mathbf{b} \\cdot \\mathbf{a}\n$$\nThis fraction $f$ scales the contributions from the $d$-channel to the observable quantities.\n\nFifth, we apply this scheme to a physical model of a $3d$ manifold ($l=2$) in a solid. The energies of the threefold degenerate $t_{2g}$ levels and twofold degenerate $e_g$ levels are split by spin polarization:\n$$\nE_{t}^{\\uparrow} = E_{t} - \\Delta/2, \\quad E_{e}^{\\uparrow} = E_{e} - \\Delta/2\n$$\n$$\nE_{t}^{\\downarrow} = E_{t} + \\Delta/2, \\quad E_{e}^{\\downarrow} = E_{e} + \\Delta/2\n$$\nThe spin-resolved density of states (DOS) at the Fermi level $E_F$ is calculated by summing Gaussian functions centered at these energy levels, weighted by their degeneracies and the captured fraction $f$:\n$$\nD^{\\sigma}_{d}(E_{F}) = f \\sum_{i \\in \\text{levels of spin } \\sigma} G\\left(E_{F} - E_{i}^{\\sigma}; \\eta\\right)\n$$\nwhere $\\sigma \\in \\{\\uparrow, \\downarrow\\}$ and $G(x;\\eta) = (\\eta\\sqrt{\\pi})^{-1} \\exp(-x^2/\\eta^2)$. For the $d$-channel, this is:\n$$\nD^{\\uparrow}_{d}(E_{F}) = f \\left[ 3 G(E_F - E_t^\\uparrow; \\eta) + 2 G(E_F - E_e^\\uparrow; \\eta) \\right]\n$$\n$$\nD^{\\downarrow}_{d}(E_{F}) = f \\left[ 3 G(E_F - E_t^\\downarrow; \\eta) + 2 G(E_F - E_e^\\downarrow; \\eta) \\right]\n$$\nFinally, the magnetic moment $\\mu_d$ is computed by counting the occupied states for each spin channel, scaled by $f$:\n$$\n\\mu_d = f(N_\\uparrow - N_\\downarrow)\n$$\nwhere $N_\\sigma$ is the total number of states of spin $\\sigma$ with energy less than or equal to $E_F$. Specifically, $N_{\\uparrow} = 3 \\cdot \\mathbb{I}(E_t^\\uparrow \\le E_F) + 2 \\cdot \\mathbb{I}(E_e^\\uparrow \\le E_F)$ and $N_{\\downarrow} = 3 \\cdot \\mathbb{I}(E_t^\\downarrow \\le E_F) + 2 \\cdot \\mathbb{I}(E_e^\\downarrow \\le E_F)$, with $\\mathbb{I}(\\cdot)$ being the indicator function. The Bohr magneton $\\mu_B$ is taken as $1$.\n\nThe algorithm consists of computing these quantities for each test case by implementing the derived formulae using numerical libraries for matrix operations and special functions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma, gammainc\n\ndef solve():\n    \"\"\"\n    Implements a simplified projector augmented-wave scheme to compute\n    orbital-resolved physical properties for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (l, r_c, N, alpha_base, alpha_ref, E_t, E_e, Delta, E_F, eta)\n        (2, 2.0, 3, 2.0, 1.2, -1.0, 0.5, 1.5, 0.0, 0.2), # Test case 1\n        (2, 2.0, 1, 2.0, 1.2, -1.0, 0.5, 1.5, 0.0, 0.2), # Test case 2\n        (2, 2.0, 4, 5.0, 1.0, -1.0, 0.5, 1.5, 0.0, 0.2), # Test case 3\n        (2, 2.0, 3, 2.0, 1.2, -1.0, 0.5, 0.0, 0.0, 0.2), # Test case 4\n    ]\n\n    results = []\n\n    def integral_helper(A, k, rc_val):\n        \"\"\"\n        Calculates the integral of r^k * exp(-A * r^2) from 0 to rc_val.\n        This is used for all radial integrals.\n        \"\"\"\n        if A <= 0:\n            # This case should not be reached with the given alpha > 0.\n            return 0.0\n        \n        # Power for the gamma function and A\n        power = (k + 1) / 2\n        # Argument for the incomplete gamma function\n        arg = A * rc_val**2\n        \n        # The integral is related to the lower incomplete gamma function, gamma(s, x).\n        # gamma(s,x) = Gamma(s) * P(s,x)\n        # where P(s,x) is the regularized lower incomplete gamma function (gammainc).\n        incomplete_gamma_val = gamma(power) * gammainc(power, arg)\n        \n        # Final expression for the integral\n        return incomplete_gamma_val / (2 * A**power)\n\n    for case in test_cases:\n        l, r_c, N, alpha_base, alpha_ref, E_t, E_e, Delta, E_F, eta = case\n\n        # Set of alpha parameters for the partial waves\n        alphas = [alpha_base * (n + 1) for n in range(N)]\n        \n        # The power of r in the integrands for normalization and overlap\n        k = 2 * l + 2\n        \n        # 1. & 3. Calculate normalization constants for partial waves and reference wave\n        # The integral for normalization of a wave ~ r^l * exp(-alpha * r^2) is\n        # integral_helper(2 * alpha, 2*l + 2, r_c).\n        norm_consts_sq_inv = [integral_helper(2 * alpha, k, r_c) for alpha in alphas]\n        norm_consts = [1.0 / np.sqrt(nci) for nci in norm_consts_sq_inv]\n\n        norm_ref_sq_inv = integral_helper(2 * alpha_ref, k, r_c)\n        norm_ref = 1.0 / np.sqrt(norm_ref_sq_inv)\n        \n        # 2. Construct the overlap matrix S\n        S = np.zeros((N, N))\n        for i in range(N):\n            for j in range(i, N):\n                val = norm_consts[i] * norm_consts[j] * integral_helper(alphas[i] + alphas[j], k, r_c)\n                S[i, j] = val\n                S[j, i] = val\n        \n        S_inv = np.linalg.inv(S)\n        \n        # 4. Compute the overlap vector b between the reference wave and partial waves\n        b = np.zeros(N)\n        for i in range(N):\n            b[i] = norm_consts[i] * norm_ref * integral_helper(alphas[i] + alpha_ref, k, r_c)\n\n        # 5. Compute the captured fraction f = b^T * S^-1 * b\n        f = np.dot(b, np.dot(S_inv, b))\n        \n        # 6. Define the spin-polarized energy levels\n        Et_up, Ee_up = E_t - Delta / 2, E_e - Delta / 2\n        Et_down, Ee_down = E_t + Delta / 2, E_e + Delta / 2\n\n        # 7. Compute the spin-resolved density of states at E_F\n        def gaussian(x, eta_val):\n            return (1.0 / (eta_val * np.sqrt(np.pi))) * np.exp(-(x**2) / (eta_val**2))\n\n        dos_up = f * (3 * gaussian(E_F - Et_up, eta) + 2 * gaussian(E_F - Ee_up, eta))\n        dos_down = f * (3 * gaussian(E_F - Et_down, eta) + 2 * gaussian(E_F - Ee_down, eta))\n        \n        # 8. Determine the orbital-resolved magnetic moment\n        N_up = (3 if Et_up <= E_F else 0) + (2 if Ee_up <= E_F else 0)\n        N_down = (3 if Et_down <= E_F else 0) + (2 if Ee_down <= E_F else 0)\n        mu_d = f * (N_up - N_down)\n\n        results.append([dos_up, dos_down, mu_d])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}