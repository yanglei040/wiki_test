{
    "hands_on_practices": [
        {
            "introduction": "量子力学和经典力学的一个基石是相同粒子不可区分的原理。因此，任何物理上真实的原子间势，其能量预测值都必须对相同种类原子的置换保持不变；系统的能量应仅取决于原子的位置和种类，而非它们的人为标签。本实践  提供了一种具体的、动手操作的方法，通过使用一个正确构建的势函数和一个特意设计的有缺陷的势函数进行对比，来编写真正的计算测试，以验证这一基本的置换不变性。",
            "id": "3498423",
            "problem": "给定一项计算材料科学领域的任务，涉及机器学习原子间势 (MLIP) 的训练和验证。任何原子间势的一个基本物理要求是，预测的总能量在化学上相同的原子的置换下保持不变，因为系统的势能仅取决于原子的位置和化学特性，而不取决于任意的标记方式。具体来说，考虑一个包含 $N$ 个原子的系统，其位置为 $\\mathbf{r}_i \\in \\mathbb{R}^3$，物种标签为 $s_i \\in \\{\\text{A}, \\text{B}, \\dots\\}$，其中 $i \\in \\{1,\\dots,N\\}$。目标是构建并实现一个测试，用于验证在对化学上相同的原子组进行重新标记时，预测能量 $E$ 的置换不变性。\n\n从牛顿力学和经典势能框架出发：总势能是位置和物种集合的函数，$E = E(\\{\\mathbf{r}_i\\}, \\{s_i\\})$，它必须尊重相同原子的不可区分性。以此为基础，形式化一个算法测试，该测试：\n- 识别对应于化学上相同原子（即相同的 $s_i$）的索引组，\n- 在每个组内应用确定性置换（即，在保持其他索引不变的情况下，重新排序相同种类原子之间的索引），\n- 计算每次置换前后的能量，\n- 检查能量是否在规定的容差范围内保持不变，从而确定置换不变性。\n\n为了使测试可执行且在数值上具体，请在相同的构型上使用两个玩具 MLIP 能量模型：\n- 一个置换不变模型 $E_{\\mathrm{PI}}$，定义为\n$$\nE_{\\mathrm{PI}}(\\{\\mathbf{r}_i\\}, \\{s_i\\}) = \\sum_{i=1}^N w_{s_i} \\left( \\sum_{\\substack{j=1 \\\\ j \\neq i}}^N \\exp\\!\\left(-\\frac{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2}{\\sigma^2}\\right) \\right)^2,\n$$\n其中 $w_{s}$ 是一个依赖于物种的权重，$\\sigma$ 是一个正长度尺度。此构造使用对邻居的求和以及依赖于物种的权重，并且相对于相同物种内原子的重新排序是对称的。\n- 一个刻意设计的非置换不变模型 $E_{\\mathrm{NPI}}$，定义为\n$$\nE_{\\mathrm{NPI}}(\\{\\mathbf{r}_i\\}, \\{s_i\\}) = \\sum_{i=1}^N \\alpha_i \\left( \\sum_{\\substack{j=1 \\\\ j \\neq i}}^N \\exp\\!\\left(-\\frac{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2}{\\sigma^2}\\right) \\right),\n$$\n其中 $\\alpha_i$ 是一个依赖于索引的系数，它仅取决于原子索引 $i$ 而非物种；当相同物种的原子在不同索引间被重新标记时，这会破坏置换不变性。\n\n在所有测试用例中，使用以下参数值：\n- 物种权重：$w_{\\text{A}} = 0.7$, $w_{\\text{B}} = 1.2$，\n- 长度尺度：$\\sigma = 0.8$，\n- 不变性检查的容差：$\\varepsilon = 10^{-10}$，\n- 索引权重：$\\alpha_i = i$（对 $i$ in $\\{1,\\dots,N\\}$ 使用 1-based 索引）。\n\n原子位置以埃（angstrom）为单位指定，但在这些玩具模型中，能量根据其构造是无量纲的。由于输出是布尔值，最终答案无需进行单位转换。\n\n构建一个包含多种情况的构型测试套件，这些构型在科学上是合理的（原子间距约为几埃）。对于每个构型，您必须在每个物种组内测试多种确定性置换，具体包括：\n- 每个组内的恒等置换，\n- 每个组内索引顺序的反转，\n- 每个组内索引的循环旋转一位（当组大小至少为 2 时）。\n\n对于给定的模型，一个构型是置换不变的，当且仅当所有这些置换构型的计算能量在容差 $\\varepsilon$ 内与原始能量相等。\n\n测试套件：\n- 情况 1（常规情况）：$N = 4$，物种 $[\\text{A}, \\text{A}, \\text{B}, \\text{B}]$，位置\n  - $\\mathbf{r}_1 = (0.00, 0.00, 0.00)$，\n  - $\\mathbf{r}_2 = (1.10, 0.00, 0.00)$，\n  - $\\mathbf{r}_3 = (0.50, 0.80, 0.00)$，\n  - $\\mathbf{r}_4 = (1.60, 1.25, 0.30)$。\n- 情况 2（所有物种相同，非对称几何构型）：$N = 3$，物种 $[\\text{A}, \\text{A}, \\text{A}]$，位置\n  - $\\mathbf{r}_1 = (0.00, 0.00, 0.00)$，\n  - $\\mathbf{r}_2 = (1.00, 0.20, 0.10)$，\n  - $\\mathbf{r}_3 = (0.30, 0.70, 0.40)$。\n- 情况 3（两个相同物种靠近，第三个不同）：$N = 3$，物种 $[\\text{B}, \\text{B}, \\text{A}]$，位置\n  - $\\mathbf{r}_1 = (0.00, 0.00, 0.00)$，\n  - $\\mathbf{r}_2 = (0.30, 0.00, 0.00)$，\n  - $\\mathbf{r}_3 = (0.10, 0.40, 0.20)$。\n- 情况 4（混合分组，数量不同）：$N = 5$，物种 $[\\text{A}, \\text{B}, \\text{A}, \\text{B}, \\text{A}]$，位置\n  - $\\mathbf{r}_1 = (0.00, 0.00, 0.00)$，\n  - $\\mathbf{r}_2 = (0.90, 0.10, 0.00)$，\n  - $\\mathbf{r}_3 = (0.30, 1.10, 0.20)$，\n  - $\\mathbf{r}_4 = (1.30, 0.80, 0.20)$，\n  - $\\mathbf{r}_5 = (0.60, 0.40, 1.00)$。\n\n您的程序必须：\n- 实现两个能量模型 $E_{\\mathrm{PI}}$ 和 $E_{\\mathrm{NPI}}$，\n- 对每个测试用例，在每个物种组内生成指定的置换，\n- 计算原始构型和置换后构型的能量，\n- 为每种情况确定两个布尔值：构型对于 $E_{\\mathrm{PI}}$ 是否是置换不变的，以及对于 $E_{\\mathrm{NPI}}$ 是否是置换不变的。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且是一个包含两个布尔值 $[b_{\\mathrm{PI}}, b_{\\mathrm{NPI}}]$ 的列表。例如，输出应类似于 $[[\\text{True},\\text{False}],[\\text{True},\\text{False}],\\dots]$，不含空格。",
            "solution": "该问题要求创建并实现一个计算测试，以验证一个基本物理原理：势能的置换不变性。在任何由经典力学或量子力学支配的系统中，总势能 $E$ 取决于粒子的集合，由它们的属性（如质量、电荷、物种）和状态变量（如位置、动量）定义。它必须独立于分配给相同粒子的任意标签或索引。对于一个包含 $N$ 个原子、位置为 $\\{\\mathbf{r}_i\\}$、化学物种为 $\\{s_i\\}$（其中 $i \\in \\{1, \\dots, N\\}$）的系统，这意味着如果我们应用一个仅交换相同物种原子的置换 $P$，能量必须保持不变。形式上，如果对于所有 $i$，$s_{P(i)} = s_i$，那么能量函数必须满足 $E(\\{\\mathbf{r}_{P(i)}\\}, \\{s_{P(i)}\\}) = E(\\{\\mathbf{r}_i\\}, \\{s_i\\})$。这是一个关键的对称性约束，任何物理上真实的原子间势，包括机器学习模型，都必须满足。\n\n任务是使用两个给定的玩具能量模型 $E_{\\mathrm{PI}}$ 和 $E_{\\mathrm{NPI}}$，在一组给定的原子构型上，为这一原理形式化一个算法测试。\n\n验证算法流程如下：\n1.  **识别物种分组**：对于一个给定的包含 $N$ 个原子、物种为 $\\{s_1, s_2, \\dots, s_N\\}$ 的构型，第一步是将原子索引集合 $\\{0, 1, \\dots, N-1\\}$ 划分为不相交的子集，每个子集包含单一化学物种的原子的索引。例如，对于物种 $[\\text{A}, \\text{B}, \\text{A}]$，分组将是 $I_{\\text{A}} = \\{0, 2\\}$ 和 $I_{\\text{B}} = \\{1\\}$。\n\n2.  **生成置换**：对于每个包含至少两个原子的物种组，我们生成一组确定性的、非平凡的置换。问题指定了要为每个组考虑三种类型的置换：恒等、反转和循环旋转。恒等置换作为基准。测试置换是那些在一个物种组内重新排序索引，同时保持所有其他索引不变的置换。具体来说，对于每个物种组 $I_s$：\n    *   通过反转 $I_s$ 中索引的顺序来创建一个反转置换映射。\n    *   通过将 $I_s$ 中的每个索引移动到前一个索引的位置（第一个索引移动到最后一个位置）来创建一个循环置换映射。对于大小为 2 的组，这与反转相同。\n\n3.  **计算并比较能量**：测试的核心在于比较原始构型的能量与置换后构型的能量。\n    *   首先，计算原始未置换构型的能量 $E_0$。\n    *   然后，对于每个生成的置换映射 $p$，通过根据 $p$ 重新排序原子的位置和物种数组来构建一个新的构型。设置换后的位置为 $\\{\\mathbf{r}'_i\\}$，物种为 $\\{s'_i\\}$。计算这个新构型的能量 $E_p$。\n    *   通过测试原始能量和置换后能量的绝对差是否在给定的数值容差 $\\varepsilon$ 内来执行不变性检查：$|E_p - E_0| \\le \\varepsilon$。\n    *   如果此条件对*所有*生成的测试置换都成立，则认为模型对于给定的构型是置换不变的。如果只要有一个置换导致显著的能量变化，则该模型在该构型上的测试失败。\n\n这两个能量模型旨在展示这一原理：\n\n-   **置换不变模型 ($E_{\\mathrm{PI}}$)**：\n    $$E_{\\mathrm{PI}}(\\{\\mathbf{r}_i\\}, \\{s_i\\}) = \\sum_{i=1}^N w_{s_i} \\left( \\sum_{\\substack{j=1 \\\\ j \\neq i}}^N \\exp\\!\\left(-\\frac{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2}{\\sigma^2}\\right) \\right)^2$$\n    该模型的不变性源于权重因子 $w_{s_i}$ 取决于原子的物种 $s_i$，这是一个物理属性。当相同的原子被置换时（例如，交换索引 $k$ 和 $l$，其中 $s_k=s_l$），它们对应的权重也相同（$w_{s_k} = w_{s_l}$）。一个原子的能量贡献取决于其物种及其几何环境。置换仅仅是重新排列了外层求和 $\\sum_{i=1}^N$ 中的项，因为被求和的几何环境集合保持不变，所以总和也保持不变。预期该模型将通过所有构型的不变性测试。\n\n-   **非置换不变模型 ($E_{\\mathrm{NPI}}$)**：\n    $$E_{\\mathrm{NPI}}(\\{\\mathbf{r}_i\\}, \\{s_i\\}) = \\sum_{i=1}^N \\alpha_i \\left( \\sum_{\\substack{j=1 \\\\ j \\neq i}}^N \\exp\\!\\left(-\\frac{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2}{\\sigma^2}\\right) \\right)$$\n    该模型被刻意构造成违反置换不变性。系数 $\\alpha_i = i$ 直接依赖于分配给原子的任意数字索引 $i$，而不是其内在的物理属性（如物种）或其位置。当两个索引为 $k$ 和 $l$ 的原子被置换时，它们的几何环境被交换，但依赖于索引的系数 $\\alpha_k$ 和 $\\alpha_l$ 仍然保留在它们原始的索引位置。现在位于索引 $k$ 的原子的能量贡献变为 $\\alpha_k$ 乘以原来与索引 $l$ 相关联的环境总和。除非两个交换原子的几何环境偶然相同（对于给定的非对称构型，情况并非如此）或者 $\\alpha_k = \\alpha_l$（一个平凡的置换），否则总能量将会改变。预期该模型将无法通过不变性测试。\n\n实现将把此逻辑应用于四个测试用例中的每一个，评估 $E_{\\mathrm{PI}}$ 和 $E_{\\mathrm{NPI}}$，并为每个模型生成一对布尔值，指示测试结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef solve():\n    \"\"\"\n    Main function to run the permutation invariance tests.\n    \"\"\"\n    # Define parameters from the problem statement.\n    params = {\n        'w': {'A': 0.7, 'B': 1.2},\n        'sigma': 0.8,\n        'epsilon': 1e-10\n    }\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of (positions, species).\n    test_cases = [\n        (\n            [[0.00, 0.00, 0.00], [1.10, 0.00, 0.00], [0.50, 0.80, 0.00], [1.60, 1.25, 0.30]],\n            ['A', 'A', 'B', 'B']\n        ),\n        (\n            [[0.00, 0.00, 0.00], [1.00, 0.20, 0.10], [0.30, 0.70, 0.40]],\n            ['A', 'A', 'A']\n        ),\n        (\n            [[0.00, 0.00, 0.00], [0.30, 0.00, 0.00], [0.10, 0.40, 0.20]],\n            ['B', 'B', 'A']\n        ),\n        (\n            [[0.00, 0.00, 0.00], [0.90, 0.10, 0.00], [0.30, 1.10, 0.20], [1.30, 0.80, 0.20], [0.60, 0.40, 1.00]],\n            ['A', 'B', 'A', 'B', 'A']\n        )\n    ]\n    \n    def energy_pi(positions: np.ndarray, species: np.ndarray, p: dict) -> float:\n        \"\"\"Computes energy using the permutation-invariant model.\"\"\"\n        n_atoms = len(positions)\n        if n_atoms  2:\n            return 0.0\n        \n        dist_sq = cdist(positions, positions, 'sqeuclidean')\n        gauss_terms = np.exp(-dist_sq / (p['sigma']**2))\n        np.fill_diagonal(gauss_terms, 0)\n        \n        local_env_sums = np.sum(gauss_terms, axis=1)\n        weights = np.array([p['w'][s] for s in species])\n        \n        energy = np.sum(weights * (local_env_sums**2))\n        return energy\n\n    def energy_npi(positions: np.ndarray, species: np.ndarray, p: dict) -> float:\n        \"\"\"Computes energy using the non-permutation-invariant model.\"\"\"\n        n_atoms = len(positions)\n        if n_atoms  2:\n            return 0.0\n            \n        alphas = np.arange(1, n_atoms + 1)\n        \n        dist_sq = cdist(positions, positions, 'sqeuclidean')\n        gauss_terms = np.exp(-dist_sq / (p['sigma']**2))\n        np.fill_diagonal(gauss_terms, 0)\n        \n        local_env_sums = np.sum(gauss_terms, axis=1)\n        \n        energy = np.sum(alphas * local_env_sums)\n        return energy\n\n    def get_permutation_maps(species: np.ndarray) -> list:\n        \"\"\"Generates permutation maps for reversal and cyclic shifts within species groups.\"\"\"\n        n_atoms = len(species)\n        species_groups = {}\n        for i, s_atom in enumerate(species):\n            species_groups.setdefault(s_atom, []).append(i)\n        \n        perm_maps = []\n        original_map = list(range(n_atoms))\n        \n        for group_indices in species_groups.values():\n            if len(group_indices)  2:\n                continue\n            \n            # Reversal permutation for this group\n            p_map_rev = original_map[:]\n            rev_indices = group_indices[::-1]\n            for i in range(len(group_indices)):\n                p_map_rev[group_indices[i]] = rev_indices[i]\n            if p_map_rev != original_map:\n                perm_maps.append(p_map_rev)\n            \n            # Cyclic permutation for this group\n            p_map_cyc = original_map[:]\n            cyc_indices = [group_indices[-1]] + group_indices[:-1]\n            for i in range(len(group_indices)):\n                p_map_cyc[group_indices[i]] = cyc_indices[i]\n            if p_map_cyc != original_map and p_map_cyc not in perm_maps:\n                perm_maps.append(p_map_cyc)\n                \n        return perm_maps\n\n    def check_invariance_for_case(positions: np.ndarray, species: np.ndarray, p: dict) -> list:\n        \"\"\"Checks permutation invariance for a single case for both models.\"\"\"\n        # Calculate original energies\n        e0_pi = energy_pi(positions, species, p)\n        e0_npi = energy_npi(positions, species, p)\n\n        perm_maps = get_permutation_maps(species)\n        \n        is_pi_invariant = True\n        is_npi_invariant = True\n        \n        for p_map in perm_maps:\n            perm_pos = positions[p_map]\n            perm_species = species[p_map]\n            \n            # Test PI model\n            e_pi = energy_pi(perm_pos, perm_species, p)\n            if abs(e_pi - e0_pi) > p['epsilon']:\n                is_pi_invariant = False\n                \n            # Test NPI model\n            e_npi = energy_npi(perm_pos, perm_species, p)\n            if abs(e_npi - e0_npi) > p['epsilon']:\n                is_npi_invariant = False\n        \n        return [is_pi_invariant, is_npi_invariant]\n\n    results = []\n    for pos_list, species_list in test_cases:\n        positions_np = np.array(pos_list)\n        species_np = np.array(species_list)\n        result = check_invariance_for_case(positions_np, species_np, params)\n        results.append(result)\n\n    # Format output string as [[Bool,Bool],[Bool,Bool],...] with no spaces\n    result_str = \",\".join([str(r).replace(\" \", \"\") for r in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了尊重粒子身份的不可区分性，一个有效的势函数还必须遵循空间的基本对称性。物理定律不应因观察者的位置或朝向而改变，这一概念被形式化为在欧几里得群 $E(3)$ 变换下的不变性。本练习  将指导你构建一个严格的测试，以验证势函数的能量在刚性平移和旋转下保持不变，并且产生的力是等变的，即它们会随系统一同旋转。",
            "id": "3498502",
            "problem": "构建一个合成数据集，以探究与机器学习原子间势的训练和验证相关的等变性和不变性。目标是验证对于一个各向同性、可微的对势，总能量在三维欧几里得群（E(3)）的旋转和平移下是不变的，而力在三维特殊正交群（SO(3)）下是等变的，即它们与构型一致地旋转。从以下基本基础开始：一个刚体运动由一个满足 $R^{\\top} R = I$ 的旋转矩阵 $R \\in SO(3)$ 和一个平移向量 $t \\in \\mathbb{R}^{3}$ 定义；原子位置 $x_i \\in \\mathbb{R}^{3}$ 的变换为 $x'_i = R x_i + t$。原子间距 $r_{ij} = \\lVert x_i - x_j \\rVert$ 在此类刚体运动下是不变的，一个仅依赖于对距离的标量势能必须在 $E(3)$ 下是不变的。定义为 $F_i = -\\nabla_{x_i} E$ 的力，在施加于旋转后的构型时，会根据 $F'_i = R F_i$ 进行旋转变换。程序必须实现一个特定的各向同性对势，以使测试完全量化和可复现：使用能量为\n$$\nE_{\\mathrm{LJ}}(X;\\epsilon,\\sigma) = \\sum_{1 \\le i  j \\le N} 4 \\epsilon \\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right],\n$$\n的 Lennard–Jones $12$-$6$ 势，其中 $X = (x_1,\\dots,x_N)$，$N$ 是原子数，$\\epsilon$ 是以 $\\mathrm{eV}$ 为单位的深度参数，$\\sigma$ 是以 $\\text{\\AA}$ 为单位的长度尺度，$r_{ij} = \\lVert x_i - x_j \\rVert$ 的单位是 $\\text{\\AA}$。力必须计算为 $F_i = -\\nabla_{x_i} E_{\\mathrm{LJ}}$，单位为 $\\mathrm{eV}/\\text{\\AA}$。\n\n为探究违例情况，可选择性地为能量增加一个取向依赖、平移不变的项\n$$\nE_{\\mathrm{orient}}(X; \\alpha, n) = \\alpha \\sum_{i=1}^{N} \\left((x_i - \\bar{x}) \\cdot n\\right)^2,\n$$\n其中 $\\bar{x} = \\frac{1}{N} \\sum_{k=1}^{N} x_k$ 是质心，$n \\in \\mathbb{R}^{3}$ 是实验室参考系中的一个固定单位向量，$\\alpha$ 的单位是 $\\mathrm{eV}/\\text{\\AA}^2$。总能量则为 $E_{\\mathrm{tot}} = E_{\\mathrm{LJ}} + E_{\\mathrm{orient}}$，总力为 $F_i = -\\nabla_{x_i} E_{\\mathrm{tot}}$。\n\n数据集的构建和评估必须从基本定义中逻辑地推导出来。对于给定的基础构型 $X$，通过应用如下采样的随机刚体运动 $(R,t)$ 来生成一组构型：旋转必须通过使用由独立标准正态分量生成的归一化四元数，在 $SO(3)$ 上均匀采样（在转换为旋转矩阵之前将四元数归一化为单位长度）；平移必须对于指定的幅度 $A \\ge 0$，在区间 $[-A,A]$（单位 $\\text{\\AA}$）内按分量均匀采样。对于仅旋转测试，设置 $A=0$。对于仅平移测试，设置 $R=I$。对于固定角度旋转测试，使用具有指定旋转轴和角度的 Rodrigues 旋转公式，其中角度必须以弧度表示。\n\n对于每个变换后的构型 $X'$，计算能量不变性误差\n$$\n\\delta_E = \\frac{\\left|E_{\\mathrm{tot}}(X') - E_{\\mathrm{tot}}(X)\\right|}{\\max\\left(\\lvert E_{\\mathrm{tot}}(X)\\rvert, 10^{-12}\\right)},\n$$\n以及力等变性误差\n$$\n\\delta_F = \\frac{\\left\\lVert F(X') - R F(X)\\right\\rVert_F}{\\max\\left(\\lVert F(X)\\rVert_F, 10^{-12}\\right)},\n$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示 $N \\times 3$ 力矩阵的 Frobenius 范数。通过取最大值 $\\max \\delta_E$ 和 $\\max \\delta_F$ 来聚合数据集中所有运动的误差。如果对于指定的容差 $\\tau_E$ 和 $\\tau_F$，同时满足 $\\max \\delta_E \\le \\tau_E$ 和 $\\max \\delta_F \\le \\tau_F$，则测试用例通过。\n\n所有距离必须以 $\\text{\\AA}$ 计算，能量以 $\\mathrm{eV}$ 计算，力以 $\\mathrm{eV}/\\text{\\AA}$ 计算。角度必须以弧度为单位。程序必须为每个测试用例输出表示通过或失败的布尔值。\n\n实现以下测试套件以确保覆盖性、科学真实性和边缘情况。对于每个用例，将 Lennard–Jones 参数设置为 $\\epsilon = 0.0103\\,\\mathrm{eV}$ 和 $\\sigma = 3.4\\,\\text{\\AA}$：\n\n用例 $1$ (一般 $E(3)$ 不变性/等变性)：$N = 8$，基础位置在边长为 $L = 10.0\\,\\text{\\AA}$ 的立方体中使用随机种子 $1234$ 均匀采样，运动次数 $25$，在 $SO(3)$ 上的“随机”旋转类型，平移幅度 $A = 5.0\\,\\text{\\AA}$，运动种子 $5678$，无取向项（设置 $\\alpha = 0$），容差 $\\tau_E = 10^{-12}$ 和 $\\tau_F = 10^{-11}$。\n\n用例 $2$ (纯平移边界)：$N = 6$，基础位置在边长为 $L = 12.0\\,\\text{\\AA}$ 的立方体中使用种子 $42$ 均匀采样，运动次数 $10$，旋转设置为单位矩阵 $R = I$，平移幅度 $A = 10.0\\,\\text{\\AA}$，运动种子 $101$，无取向项，容差 $\\tau_E = 10^{-12}$ 和 $\\tau_F = 10^{-11}$。\n\n用例 $3$ (纯旋转边界)：$N = 7$，基础位置在边长为 $L = 8.0\\,\\text{\\AA}$ 的立方体中使用种子 $7$ 均匀采样，运动次数 $12$，使用 Rodrigues 公式将旋转设置为围绕轴 $a = (1,1,2)$ 的固定角度 $\\theta = \\pi/3$，平移幅度 $A = 0.0\\,\\text{\\AA}$，运动种子 $77$，无取向项，容差 $\\tau_E = 10^{-12}$ 和 $\\tau_F = 10^{-11}$。\n\n用例 $4$ (带取向依赖项的违例情况)：$N = 8$，基础位置在边长为 $L = 9.0\\,\\text{\\AA}$ 的立方体中使用种子 $99$ 均匀采样，运动次数 $15$，在 $SO(3)$ 上的“随机”旋转类型，平移幅度 $A = 3.0\\,\\text{\\AA}$，运动种子 $123$，包含取向依赖项，其中 $\\alpha = 1.0\\,\\mathrm{eV}/\\text{\\AA}^2$ 且固定单位向量为 $n = (0,0,1)$，容差 $\\tau_E = 10^{-12}$ 和 $\\tau_F = 10^{-11}$。\n\n用例 $5$ (近简并距离)：$N = 3$，位置明确定义为 $x_1 = (0,0,0)$、$x_2 = (0.9\\,\\sigma, 0, 0)$ 和 $x_3 = (6\\,\\sigma, 6\\,\\sigma, 0)$，单位为 $\\text{\\AA}$，运动次数 $5$，在 $SO(3)$ 上的“随机”旋转类型，平移幅度 $A = 2.0\\,\\text{\\AA}$，运动种子 $909$，无取向项，容差 $\\tau_E = 10^{-12}$ 和 $\\tau_F = 10^{-11}$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 是一个布尔值，表示用例 $k$ 在其给定容差下是否通过。不允许有其他输出。",
            "solution": "用户在计算材料科学领域提供了一个定义明确的问题。该问题有科学依据，要求对物理原理进行严格的实现，并且没有致命缺陷。因此，它被认为是**有效的**。\n\n### 基于原理的设计\n\n问题的核心是构建一个计算测试来验证原子间势的几何对称性。对于均匀和各向同性空间中任何相互作用的粒子系统，基本物理定律规定，总势能 $E$ 必须在构成欧几里得群 $E(3)$ 的刚体运动（平移和旋转）下保持不变。因此，作用在每个粒子 $i$ 上的力 $F_i = -\\nabla_{x_i} E$ 必须在这些变换下是等变的。这意味着如果整个原子位置系统 $x_i$ 被一个矩阵 $R \\in SO(3)$ 旋转，每个力矢量 $F_i$ 也必须被同一个矩阵 $R$ 旋转，即 $F'_i = R F_i$。这些性质对于任何物理上真实的原子间势都是必不可少的，包括由机器学习方法生成的势。\n\n我们的解决方案使用一个著名的各向同性对势——Lennard-Jones ($12$-$6$) 势——作为基准，对这些性质进行直接测试。还实现了一个可选的非各向同性项，作为阴性对照，以展示该测试如何正确识别违反这些基本对称性的势。\n\n#### 1. 势能和力的计算\n\n总能量 $E_{\\mathrm{tot}}$ 是 Lennard-Jones 势 $E_{\\mathrm{LJ}}$ 和一个可选的取向依赖项 $E_{\\mathrm{orient}}$ 的和。\n\n**Lennard-Jones (LJ) 项：** LJ 势定义为：\n$$\nE_{\\mathrm{LJ}}(X) = \\sum_{1 \\le i  j \\le N} 4 \\epsilon \\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right]\n$$\n其中 $r_{ij} = \\lVert x_i - x_j \\rVert$ 是原子 $i$ 和 $j$ 之间的距离。由于 $E_{\\mathrm{LJ}}$ 仅依赖于原子间距，而原子间距在 $E(3)$ 变换下是不变的，因此 $E_{\\mathrm{LJ}}$ 本身也是不变的。作用在原子 $i$ 上的力是通过对能量关于其位置 $x_i$ 取负梯度得出的：\n$$\nF_i^{\\mathrm{LJ}} = -\\nabla_{x_i} E_{\\mathrm{LJ}} = \\sum_{j \\neq i} \\frac{24\\epsilon}{r_{ij}^2} \\left[2\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right] (x_i - x_j)\n$$\n该表达式通过遍历所有唯一的原子对，计算对力，并根据牛顿第三定律 ($F_{ij} = -F_{ji}$) 为每个原子累加结果来实现。\n\n**取向依赖项：** 为了测试框架检测违例的能力，增加了一个非各向同性项：\n$$\nE_{\\mathrm{orient}}(X) = \\alpha \\sum_{i=1}^{N} \\left((x_i - \\bar{x}) \\cdot n\\right)^2\n$$\n其中 $\\bar{x}$ 是原子的几何中心，$n$ 是实验室参考系中的一个固定向量。该项在平移下不变，但在旋转下不不变，因为系统的旋转会改变点积 $(x_i - \\bar{x}) \\cdot n$。相应的力是：\n$$\nF_i^{\\mathrm{orient}} = -\\nabla_{x_i} E_{\\mathrm{orient}} = -2\\alpha \\left( (x_i - \\bar{x}) \\cdot n \\right) n\n$$\n总力为 $F_i = F_i^{\\mathrm{LJ}} + F_i^{\\mathrm{orient}}$。\n\n#### 2. 几何变换\n\n该测试涉及对基础原子构型 $X$ 应用刚体运动 $(R, t)$ 以生成新的构型 $X'$：\n$$\nx'_i = R x_i + t\n$$\n实现的一个关键部分是生成旋转矩阵 $R \\in SO(3)$。\n-   **均匀随机旋转：** 为了从 $SO(3)$ 中均匀采样，我们从四个从标准正态分布中抽取的独立随机数生成一个四元数。这个四维向量被归一化以产生一个单位四元数，然后将其转换为一个 $3 \\times 3$ 的旋转矩阵。这是一种标准的、鲁棒的无偏采样方法。\n-   **固定轴旋转：** 对于特定的确定性测试，我们使用 Rodrigues 旋转公式来构建与给定旋转轴 $u$ 和角度 $\\theta$ 对应的旋转矩阵 $R$：\n    $$\n    R(\\theta, u) = I \\cos\\theta + (1-\\cos\\theta) u u^\\top + [u]_\\times \\sin\\theta\n    $$\n    其中 $I$ 是单位矩阵，$u u^\\top$ 是旋转轴与其自身的外积，$[u]_\\times$ 是其叉积矩阵。\n\n#### 3. 误差度量和验证\n\n对于每个变换后的构型 $X'$，我们使用两种相对误差度量来量化对称性的破坏程度。\n\n**能量不变性误差 ($\\delta_E$)：**\n$$\n\\delta_E = \\frac{\\left|E_{\\mathrm{tot}}(X') - E_{\\mathrm{tot}}(X)\\right|}{\\max\\left(\\lvert E_{\\mathrm{tot}}(X)\\rvert, 10^{-12}\\right)}\n$$\n对于一个完全不变的势，此误差应为零，仅受浮点精度的限制。\n\n**力等变性误差 ($\\delta_F$)：**\n$$\n\\delta_F = \\frac{\\left\\lVert F(X') - R F(X)\\right\\rVert_F}{\\max\\left(\\lVert F(X)\\rVert_F, 10^{-12}\\right)}\n$$\n此处，$F(X)$ 是基础构型的 $N \\times 3$ 力矢量矩阵。$R F(X)$ 表示正确旋转后的力矩阵，其计算方式为 $F(X) R^\\top$。该误差衡量的是在旋转结构上计算出的力 $F(X')$ 与原始结构旋转后的力之间的偏差。一个小的 $\\delta_F$ 表明力是等变的。Frobenius 范数 $\\lVert \\cdot \\rVert_F$ 用于聚合所有原子的误差。\n\n分母中包含一个小的常数（$10^{-12}$），以防止在总能量或总力为零的情况下发生除零错误。最终的测试结果是通过将一组变换中观察到的最大误差与用户指定的容差 $\\tau_E$ 和 $\\tau_F$ 进行比较来确定的。\n\n#### 4. 算法实现\n\n该解决方案的结构是一个遍历预定义测试用例集的循环。对于每个用例：\n1.  生成一个初始原子构型 $X$，可以是从立方体内的均匀分布生成，也可以是来自明确定义的坐标。\n2.  计算基础能量 $E_{\\mathrm{tot}}(X)$ 和力 $F(X)$。\n3.  运行一个循环，次数为指定的运动次数。在每次迭代中，根据用例的规范生成一个刚体运动 $(R, t)$。\n4.  应用该运动以创建 $X'$，并计算其能量 $E_{\\mathrm{tot}}(X')$ 和力 $F(X')$。\n5.  计算误差 $\\delta_E$ 和 $\\delta_F$，并用它们来更新观察到的最大误差。\n6.  最后，将这些最大误差与阈值 $\\tau_E$ 和 $\\tau_F$ 进行比较，以得出布尔值`pass`（通过）或`fail`（失败）的结果。\n\n这种结构化的方法确保了物理定律中的对称性基本原理对于给定的势模型得到了严格且定量的测试，从而遵循了问题的严格要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_system_properties(positions, epsilon, sigma, alpha, n_vec):\n    \"\"\"\n    Calculates total energy and forces for a system of atoms.\n    \n    Args:\n        positions (np.ndarray): Nx3 array of atomic positions in Angstroms.\n        epsilon (float): LJ energy depth in eV.\n        sigma (float): LJ length scale in Angstroms.\n        alpha (float): Strength of the orientation-dependent term in eV/Angstrom^2.\n        n_vec (np.ndarray or None): 3-element unit vector for the orientation term.\n\n    Returns:\n        tuple: A tuple containing:\n            - total_energy (float): Total potential energy in eV.\n            - total_forces (np.ndarray): Nx3 array of forces in eV/Angstrom.\n    \"\"\"\n    n_atoms = positions.shape[0]\n    total_energy = 0.0\n    total_forces = np.zeros_like(positions)\n\n    # Lennard-Jones part\n    for i in range(n_atoms):\n        for j in range(i + 1, n_atoms):\n            r_ij_vec = positions[i, :] - positions[j, :]\n            r_ij_sq = np.dot(r_ij_vec, r_ij_vec)\n            \n            if r_ij_sq == 0:\n                continue\n\n            r_ij = np.sqrt(r_ij_sq)\n            \n            sig_over_r = sigma / r_ij\n            sr6 = sig_over_r ** 6\n            sr12 = sr6 ** 2\n\n            total_energy += 4.0 * epsilon * (sr12 - sr6)\n\n            f_magnitude_over_r = (24.0 * epsilon / r_ij_sq) * (2.0 * sr12 - sr6)\n            f_vec = f_magnitude_over_r * r_ij_vec\n            \n            total_forces[i, :] += f_vec\n            total_forces[j, :] -= f_vec\n\n    # Orientation-dependent part\n    if alpha > 0 and n_vec is not None:\n        centroid = np.mean(positions, axis=0)\n        positions_centered = positions - centroid\n        \n        projections = positions_centered @ n_vec\n        \n        total_energy += alpha * np.sum(projections**2)\n        \n        # F_i = -2 * alpha * n * ((x_i - x_bar) . n)\n        force_orient = -2.0 * alpha * np.outer(projections, n_vec)\n        total_forces += force_orient\n\n    return total_energy, total_forces\n\ndef generate_random_rotation(rng):\n    \"\"\"Generates a random SO(3) rotation matrix from a uniform distribution.\"\"\"\n    q = rng.standard_normal(4)\n    q /= np.linalg.norm(q)\n    w, x, y, z = q\n    \n    return np.array([\n        [1 - 2*(y*y + z*z), 2*(x*y - w*z),     2*(x*z + w*y)],\n        [2*(x*y + w*z),     1 - 2*(x*x + z*z), 2*(y*z - w*x)],\n        [2*(x*z - w*y),     2*(y*z + w*x),     1 - 2*(x*x + y*y)]\n    ])\n\ndef rodrigues_rotation(axis, angle):\n    \"\"\"Generates a rotation matrix using Rodrigues' formula.\"\"\"\n    axis = axis / np.linalg.norm(axis)\n    ux, uy, uz = axis\n    c = np.cos(angle)\n    s = np.sin(angle)\n    c1 = 1 - c\n\n    return np.array([\n        [c + ux*ux*c1,         ux*uy*c1 - uz*s,    ux*uz*c1 + uy*s],\n        [uy*ux*c1 + uz*s,      c + uy*uy*c1,       uy*uz*c1 - ux*s],\n        [uz*ux*c1 - uy*s,      uz*uy*c1 + ux*s,    c + uz*uz*c1]\n    ])\n\ndef solve():\n    # Define the test cases from the problem statement.\n    epsilon = 0.0103  # eV\n    sigma = 3.4      # Angstrom\n\n    test_cases = [\n        # Case 1\n        {'N': 8, 'pos_type': 'uniform', 'L': 10.0, 'pos_seed': 1234,\n         'motions_count': 25, 'rot_type': 'random', 'A': 5.0, 'motion_seed': 5678,\n         'alpha': 0.0, 'n': None, 'tau_E': 1e-12, 'tau_F': 1e-11},\n        # Case 2\n        {'N': 6, 'pos_type': 'uniform', 'L': 12.0, 'pos_seed': 42,\n         'motions_count': 10, 'rot_type': 'identity', 'A': 10.0, 'motion_seed': 101,\n         'alpha': 0.0, 'n': None, 'tau_E': 1e-12, 'tau_F': 1e-11},\n        # Case 3\n        {'N': 7, 'pos_type': 'uniform', 'L': 8.0, 'pos_seed': 7,\n         'motions_count': 12, 'rot_type': 'fixed', 'rot_axis': np.array([1.0, 1.0, 2.0]),\n         'rot_angle': np.pi/3, 'A': 0.0, 'motion_seed': 77,\n         'alpha': 0.0, 'n': None, 'tau_E': 1e-12, 'tau_F': 1e-11},\n        # Case 4\n        {'N': 8, 'pos_type': 'uniform', 'L': 9.0, 'pos_seed': 99,\n         'motions_count': 15, 'rot_type': 'random', 'A': 3.0, 'motion_seed': 123,\n         'alpha': 1.0, 'n': np.array([0.0, 0.0, 1.0]), 'tau_E': 1e-12, 'tau_F': 1e-11},\n        # Case 5\n        {'N': 3, 'pos_type': 'explicit',\n         'base_pos_values': np.array([[0.0, 0.0, 0.0], [0.9, 0.0, 0.0], [6.0, 6.0, 0.0]]),\n         'motions_count': 5, 'rot_type': 'random', 'A': 2.0, 'motion_seed': 909,\n         'alpha': 0.0, 'n': None, 'tau_E': 1e-12, 'tau_F': 1e-11}\n    ]\n\n    results = []\n    for case in test_cases:\n        pos_rng = np.random.default_rng(case.get('pos_seed'))\n        motion_rng = np.random.default_rng(case['motion_seed'])\n\n        # Generate base configuration\n        if case['pos_type'] == 'uniform':\n            side = case['L']\n            X_base = pos_rng.uniform(-side / 2, side / 2, size=(case['N'], 3))\n        else: # explicit\n            X_base = case['base_pos_values'] * sigma\n\n        # Calculate properties for the base configuration\n        E_base, F_base = calculate_system_properties(\n            X_base, epsilon, sigma, case['alpha'], case['n']\n        )\n\n        max_delta_E = 0.0\n        max_delta_F = 0.0\n\n        for _ in range(case['motions_count']):\n            # Generate transformation (R, t)\n            if case['rot_type'] == 'random':\n                R = generate_random_rotation(motion_rng)\n            elif case['rot_type'] == 'identity':\n                R = np.identity(3)\n            else: # fixed\n                R = rodrigues_rotation(case['rot_axis'], case['rot_angle'])\n            \n            translation_amp = case['A']\n            if translation_amp > 0:\n                t = motion_rng.uniform(-translation_amp, translation_amp, size=3)\n            else:\n                t = np.zeros(3)\n\n            # Apply transformation\n            X_prime = X_base @ R.T + t\n\n            # Calculate properties for the transformed configuration\n            E_prime, F_prime = calculate_system_properties(\n                X_prime, epsilon, sigma, case['alpha'], case['n']\n            )\n\n            # Calculate errors\n            # Energy invariance error\n            denom_E = np.maximum(np.abs(E_base), 1e-12)\n            delta_E = np.abs(E_prime - E_base) / denom_E\n            max_delta_E = np.maximum(max_delta_E, delta_E)\n            \n            # Force equivariance error\n            F_base_rotated = F_base @ R.T\n            denom_F = np.maximum(np.linalg.norm(F_base, 'fro'), 1e-12)\n            delta_F = np.linalg.norm(F_prime - F_base_rotated, 'fro') / denom_F\n            max_delta_F = np.maximum(max_delta_F, delta_F)\n\n        # Check against tolerances\n        passed = (max_delta_E = case['tau_E']) and (max_delta_F = case['tau_F'])\n        results.append(str(passed).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当我们掌握了如何验证势函数的基本物理对称性后，一个在实际机器学习原子间势（MLIP）开发中的关键问题便浮出水面：我们如何才能最高效地构建精确的模型？MLIP 的质量极其依赖其训练数据。这项高级实践  探索了主动学习的概念，即模型本身可以帮助决定学习哪些新的数据点最有价值。通过在一个理想化的设定下比较几种不同的查询策略，你将深入理解如何智能且高效地扩展训练数据集以提升模型性能。",
            "id": "3498498",
            "problem": "您将实现一个程序，该程序在原子系统中力的简化和理想化的线性高斯建模假设下，比较三种主动学习查询策略在达到固定力均方根误差 (RMSE) 阈值所需的最小查询次数 $N$ 方面的表现。这三种策略是：$D$-最优性、最大预测方差和对抗性分子动力学 (MD)。您的程序必须为下面提供的每个测试用例计算出，对于每种策略，使得在目标分布上预测的力的 RMSE 小于或等于指定阈值的最小整数 $N$。该阈值以电子伏特每埃 ($\\mathrm{eV}/\\mathrm{\\AA}$) 为单位表示。最终输出必须是单行文本，其中包含所有测试用例的汇总结果，格式如文末所述。\n\n使用的基本假设和定义：\n- 考虑一个单分量力模型，该模型在固定的有限维描述符映射中是线性的。设观测到的标量力分量 $y$ 满足 $y = \\boldsymbol{\\phi}(\\mathbf{x})^{\\top} \\mathbf{w} + \\varepsilon$，其中 $\\mathbf{w}$ 是一个维度为 $d$ 的参数向量，$\\boldsymbol{\\phi}(\\mathbf{x}) \\in \\mathbb{R}^d$ 是一个特征向量，$\\varepsilon$ 是观测噪声。\n- 假设 $\\mathbf{w}$ 服从零均值和各向同性协方差的高斯先验分布：$\\mathbf{w} \\sim \\mathcal{N}(\\mathbf{0}, \\tau^2 \\mathbf{I}_d)$。观测噪声是独立同分布的高斯噪声：$\\varepsilon \\sim \\mathcal{N}(0, \\sigma_f^2)$，其中 $\\sigma_f$ 的单位是 $\\mathrm{eV}/\\mathrm{\\AA}$。\n- 描述符的目标测试分布的协方差矩阵为 $\\mathbf{C} = \\operatorname{diag}(\\lambda_1, \\ldots, \\lambda_d)$，其对角线元素 $\\lambda_i$ 为给定的非负值（无量纲）。\n- 每次查询贡献一个与单个规范基方向对齐的单位范数描述符，因此在 $N$ 次查询后，设计矩阵满足 $\\mathbf{X}^{\\top} \\mathbf{X} = \\operatorname{diag}(m_1, \\ldots, m_d)$，其中 $m_i$ 是非负整数，其和为 $N$。\n\n您必须比较以下按顺序应用的查询策略：\n- $D$-最优性：选择查询，使 $\\mathbf{X}^{\\top} \\mathbf{X}$ 的对角线元素尽可能相等，即，对于给定的 $N$，分配计数 $m_i$ 以使得对所有 $i, j$ 都有 $|m_i - m_j| \\leq 1$。\n- 最大预测方差 (max variance)：在每一步选择使当前针对目标分布测量的预测不确定性权重最大化的索引 $i$，并通过最小索引确定性地打破平局。具体来说，给定当前计数 $m_i$，选择使比率 $w_i / (\\tau^{-2} + \\sigma_f^{-2} m_i)$ 最大化的索引 $i$，其中 $w_i = \\lambda_i$。\n- 对抗性分子动力学 (MD)：将对抗性采样建模为优先选择在目标分布下很少出现的方向，方法是使用一个对抗性描述符协方差，其对角线元素为 $\\mu_i = 1/\\lambda_i$（对于 $\\lambda_i  0$；如果 $\\lambda_i = 0$，则将 $\\mu_i$ 定义为一个大的固定正常数）。在每一步选择使 $w_i / (\\tau^{-2} + \\sigma_f^{-2} m_i)$ 最大化的索引 $i$，其中 $w_i = \\mu_i$，并通过最小索引确定性地打破平局。这产生了一种由对抗性优先级驱动的分配，而评估指标仍然是目标分布的 RMSE。\n\n评估指标和决策规则：\n- 均方根误差（RMSE）必须在描述符的目标分布上进行评估，并以 $\\mathrm{eV}/\\mathrm{\\AA}$ 表示。给定模型和 $N$ 次查询后的一组计数（$m_1, \\dots, m_d$），计算 RMSE 并确定使 RMSE 小于或等于测试用例指定的阈值 $T$ 的最小整数 $N$。如果阈值 $T$ 严格小于噪声水平 $\\sigma_f$，则该阈值是无法达到的；但是，所提供的所有测试阈值都满足 $T  \\sigma_f$。\n\n测试套件：\n为以下测试用例提供结果。在每个案例中，$d$ 等于向量 $\\lambda_i$ 值的长度。\n\n- 测试用例 1：$d = 3$，$\\boldsymbol{\\lambda} = [1.0, 1.0, 1.0]$，$\\sigma_f = 0.05\\,\\mathrm{eV}/\\mathrm{\\AA}$，$\\tau = 0.10\\,\\mathrm{eV}/\\mathrm{\\AA}$，阈值 $T = 0.080\\,\\mathrm{eV}/\\mathrm{\\AA}$。\n- 测试用例 2：$d = 3$，$\\boldsymbol{\\lambda} = [8.0, 1.0, 0.2]$，$\\sigma_f = 0.05\\,\\mathrm{eV}/\\mathrm{\\AA}$，$\\tau = 0.10\\,\\mathrm{eV}/\\mathrm{\\AA}$，阈值 $T = 0.070\\,\\mathrm{eV}/\\mathrm{\\AA}$。\n- 测试用例 3：$d = 4$，$\\boldsymbol{\\lambda} = [5.0, 2.0, 0.5, 0.1]$，$\\sigma_f = 0.03\\,\\mathrm{eV}/\\mathrm{\\AA}$，$\\tau = 0.08\\,\\mathrm{eV}/\\mathrm{\\AA}$，阈值 $T = 0.040\\,\\mathrm{eV}/\\mathrm{\\AA}$。\n\n您的程序必须为每个测试用例计算一个包含三个整数的列表 $[N_{D\\text{-opt}}, N_{\\text{max-var}}, N_{\\text{adv-MD}}]$，分别表示 $D$-最优性、最大预测方差和对抗性 MD 策略达到阈值所需的最小查询次数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的汇总结果，形式为由方括号括起来的逗号分隔的列表。例如，最终打印的行必须类似于 $[[n_{11},n_{12},n_{13}],[n_{21},n_{22},n_{23}],[n_{31},n_{32},n_{33}]]$，其中每个 $n_{ij}$ 是如上定义的整数。",
            "solution": "首先验证问题，以确保其科学基础扎实、定义明确且客观。\n\n### 步骤 1：提取的已知条件\n- **模型**：一个线性力模型 $y = \\boldsymbol{\\phi}(\\mathbf{x})^{\\top} \\mathbf{w} + \\varepsilon$，其中 $y$ 是一个标量力分量，$\\boldsymbol{\\phi}(\\mathbf{x}) \\in \\mathbb{R}^d$ 是一个特征向量，$\\mathbf{w} \\in \\mathbb{R}^d$ 是一个参数向量，$\\varepsilon$ 是观测噪声。\n- **先验分布**：参数向量 $\\mathbf{w}$ 服从高斯先验 $\\mathbf{w} \\sim \\mathcal{N}(\\mathbf{0}, \\tau^2 \\mathbf{I}_d)$。\n- **观测噪声**：噪声 $\\varepsilon$ 服从高斯分布，$\\varepsilon \\sim \\mathcal{N}(0, \\sigma_f^2)$。\n- **目标分布**：目标测试集中的描述符 $\\boldsymbol{\\phi}$ 从一个零均值且对角协方差矩阵为 $\\mathbf{C} = \\operatorname{diag}(\\lambda_1, \\ldots, \\lambda_d)$ 的分布中抽取。\n- **查询**：每次查询增加一个与规范基向量对齐的描述符。在 $N$ 次查询后，设计矩阵 $\\mathbf{X}$ 满足 $\\mathbf{X}^{\\top} \\mathbf{X} = \\operatorname{diag}(m_1, \\ldots, m_d)$，其中 $m_i$ 是非负整数，使得 $\\sum_{i=1}^d m_i = N$。\n- **查询策略**：\n    1.  **$D$-最优性**：对于给定的总查询次数 $N$，计数 $m_i$ 的分布尽可能均匀，即对所有 $i, j \\in \\{1, \\ldots, d\\}$ 都有 $|m_i - m_j| \\leq 1$。\n    2.  **最大预测方差 (max variance)**：在每一步，选择使量 $w_i / (\\tau^{-2} + \\sigma_f^{-2} m_i)$ 最大化的维度 $i$，其中权重 $w_i = \\lambda_i$。通过选择最小的索引 $i$ 来打破平局。\n    3.  **对抗性分子动力学 (MD)**：在每一步，选择使 $w_i / (\\tau^{-2} + \\sigma_f^{-2} m_i)$ 最大化的维度 $i$，其中权重 $w_i = \\mu_i = 1/\\lambda_i$（对于 $\\lambda_i  0$）。通过选择最小的索引 $i$ 来打破平局。\n- **评估**：找到使目标分布上的均方根误差 (RMSE) 小于或等于阈值 $T$ 的最小整数 $N$。所有测试用例均满足 $T  \\sigma_f$。\n- **测试用例**：\n    -   用例 1：$d = 3$，$\\boldsymbol{\\lambda} = [1.0, 1.0, 1.0]$，$\\sigma_f = 0.05\\,\\mathrm{eV}/\\mathrm{\\AA}$，$\\tau = 0.10\\,\\mathrm{eV}/\\mathrm{\\AA}$，$T = 0.080\\,\\mathrm{eV}/\\mathrm{\\AA}$。\n    -   用例 2：$d = 3$，$\\boldsymbol{\\lambda} = [8.0, 1.0, 0.2]$，$\\sigma_f = 0.05\\,\\mathrm{eV}/\\mathrm{\\AA}$，$\\tau = 0.10\\,\\mathrm{eV}/\\mathrm{\\AA}$，$T = 0.070\\,\\mathrm{eV}/\\mathrm{\\AA}$。\n    -   用例 3：$d = 4$，$\\boldsymbol{\\lambda} = [5.0, 2.0, 0.5, 0.1]$，$\\sigma_f = 0.03\\,\\mathrm{eV}/\\mathrm{\\AA}$，$\\tau = 0.08\\,\\mathrm{eV}/\\mathrm{\\AA}$，$T = 0.040\\,\\mathrm{eV}/\\mathrm{\\AA}$。\n\n### 步骤 2：验证\n该问题是贝叶斯统计和主动学习领域一个明确定义的练习，置于计算材料科学的背景下。线性高斯模型是用于分析研究的标准简化模型。所有术语都定义清晰，给定的参数在科学上是合理的。该问题是自包含的，因为 RMSE 的公式可以使用所提供的模型从第一性原理推导出来。条件 $T  \\sigma_f$ 确保解的存在。平局打破规则使序列策略具有确定性。关于 $\\lambda_i=0$ 时 $\\mu_i$ 定义的一个模糊之处与所提供的测试用例无关，因为所有测试用例中 $\\lambda_i  0$。$D$-最优性策略的解释需要将分布的计数分配给各个维度；最合乎逻辑的方法是将较大的计数与对误差贡献更大的维度（即较大的 $\\lambda_i$）配对，这可以在给定 $N$ 的情况下最小化 RMSE。我们将采用此解释。该问题被视为有效。\n\n### 步骤 3：解决方案设计\n\n问题的核心是为给定的 $N$ 个样本在 $d$ 个维度上的分配（由计数 $m_1, \\ldots, m_d$ 表示）计算 RMSE。\n\n**RMSE 推导**\n该问题是一个贝叶斯线性回归问题。权重的先验分布是 $p(\\mathbf{w}) = \\mathcal{N}(\\mathbf{w} | \\mathbf{0}, \\tau^2 \\mathbf{I}_d)$。给定一个带有设计矩阵 $\\mathbf{X}$ 和噪声观测值的训练集，$\\mathbf{w}$ 的后验分布为 $p(\\mathbf{w}|\\mathcal{D}) = \\mathcal{N}(\\mathbf{w} | \\mathbf{w}_N, \\mathbf{\\Sigma}_N)$，其中 $\\mathbf{w}_N$ 是后验均值，$\\mathbf{\\Sigma}_N$ 是后验协方差。后验协方差由精度矩阵的逆给出：\n$$ \\mathbf{\\Sigma}_N^{-1} = (\\tau^2 \\mathbf{I}_d)^{-1} + \\sigma_f^{-2} \\mathbf{X}^{\\top} \\mathbf{X} = \\tau^{-2} \\mathbf{I}_d + \\sigma_f^{-2} \\operatorname{diag}(m_1, \\ldots, m_d) $$\n由于该矩阵是对角矩阵，其逆矩阵，即后验协方差 $\\mathbf{\\Sigma}_N$，也是对角矩阵：\n$$ \\mathbf{\\Sigma}_N = \\operatorname{diag}\\left( \\frac{1}{\\tau^{-2} + \\sigma_f^{-2} m_1}, \\ldots, \\frac{1}{\\tau^{-2} + \\sigma_f^{-2} m_d} \\right) $$\n对于一个具有特征向量 $\\boldsymbol{\\phi}$ 的新数据点，总预测方差是模型不确定性和固有噪声方差之和，即 $\\boldsymbol{\\phi}^\\top \\mathbf{\\Sigma}_N \\boldsymbol{\\phi} + \\sigma_f^2$。均方误差 (MSE) 是此量在 $\\boldsymbol{\\phi}$ 的目标分布上的平均值。\n$$ \\text{MSE} = \\mathbb{E}_{\\boldsymbol{\\phi}}[\\boldsymbol{\\phi}^\\top \\mathbf{\\Sigma}_N \\boldsymbol{\\phi} + \\sigma_f^2] = \\mathbb{E}_{\\boldsymbol{\\phi}}[\\boldsymbol{\\phi}^\\top \\mathbf{\\Sigma}_N \\boldsymbol{\\phi}] + \\sigma_f^2 $$\n使用属性 $\\mathbb{E}[\\mathbf{x}^\\top \\mathbf{A} \\mathbf{x}] = \\operatorname{Tr}(\\mathbf{A}\\mathbb{E}[\\mathbf{x}\\mathbf{x}^\\top]) + \\mathbb{E}[\\mathbf{x}]^\\top\\mathbf{A}\\mathbb{E}[\\mathbf{x}]$ 以及目标分布具有零均值和协方差 $\\mathbf{C} = \\mathbb{E}[\\boldsymbol{\\phi}\\boldsymbol{\\phi}^\\top] = \\operatorname{diag}(\\lambda_1, \\ldots, \\lambda_d)$ 的事实，我们得到：\n$$ \\text{MSE} = \\operatorname{Tr}(\\mathbf{\\Sigma}_N \\mathbf{C}) + \\sigma_f^2 $$\n由于 $\\mathbf{\\Sigma}_N$ 和 $\\mathbf{C}$ 都是对角矩阵，迹是它们对角元素乘积之和：\n$$ \\text{MSE}(m_1, \\ldots, m_d) = \\sigma_f^2 + \\sum_{i=1}^d \\frac{\\lambda_i}{\\tau^{-2} + \\sigma_f^{-2} m_i} $$\n均方根误差是 MSE 的平方根：\n$$ \\text{RMSE} = \\sqrt{\\sigma_f^2 + \\sum_{i=1}^d \\frac{\\lambda_i}{\\tau^{-2} + \\sigma_f^{-2} m_i}} $$\n我们需要找到最小的整数 $N = \\sum_i m_i$ 使得 $\\text{RMSE} \\le T$，或等价地，$\\text{MSE} \\le T^2$。\n\n**算法方法**\n对于每种策略，我们将从 $N=1$ 开始搜索最小的 $N$。\n\n**$D$-最优性策略：**\n这是一个非序列策略，对于任何给定的 $N$，计数 $\\{m_i\\}$ 都是确定的。设 $q = \\lfloor N/d \\rfloor$ 和 $r = N \\pmod d$。计数将是 $r$ 个 $q+1$ 和 $d-r$ 个 $q$。为了使这组计数达到尽可能低的 RMSE，我们将较大的计数与具有较大 $\\lambda_i$ 值的维度配对，因为这些维度对误差的贡献最大。\n算法如下：\n1. 对于 $N = 1, 2, 3, \\ldots$\n2. 确定计数：$r$ 个维度获得 $q+1$ 个样本，$d-r$ 个维度获得 $q$ 个样本。\n3. 将 $\\boldsymbol{\\lambda}$ 按降序排序。将 $r$ 个 $q+1$ 的计数分配给前 $r$ 个排序后的维度，将 $q$ 的计数分配给剩余的 $d-r$ 个维度。\n4. 使用推导出的公式计算 MSE。\n5. 如果 $\\text{MSE} \\le T^2$，则返回 $N$。\n\n**最大预测方差和对抗性 MD 策略：**\n这些是序列策略。我们从零样本（所有 $i$ 的 $m_i = 0$）开始，每次增加一个样本。\n算法如下：\n1. 初始化 $m_i = 0$ 对所有 $i=1, \\ldots, d$。\n2. 对于 $N = 1, 2, 3, \\ldots$\n3. 计算每个维度 $i$ 的采集分数：$S_i = w_i / (\\tau^{-2} + \\sigma_f^{-2} m_i)$。\n    - 对于最大预测方差：$w_i = \\lambda_i$。\n    - 对于对抗性 MD：$w_i = 1/\\lambda_i$。\n4. 找到具有最大分数的维度 $i^*$，$i^* = \\arg\\max_i S_i$。通过选择最小的索引 $i$ 来打破平局。\n5. 增加该维度的计数：$m_{i^*} \\leftarrow m_{i^*} + 1$。\n6. 使用新的计数 $\\{m_i\\}$ 计算 MSE。\n7. 如果 $\\text{MSE} \\le T^2$，则返回 $N$。\n\n对每个测试用例重复此过程，以找到三个所需的 $N$ 值，然后将它们汇总成最终的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_mse(m_counts, lambdas, sigma_f_sq, tau_inv_sq, sigma_f_inv_sq):\n    \"\"\"\n    Calculates the Mean Squared Error (MSE) for a given set of sample counts.\n    \n    Args:\n        m_counts (np.ndarray): Array of sample counts for each dimension.\n        lambdas (np.ndarray): Diagonal entries of the target covariance matrix.\n        sigma_f_sq (float): Squared observation noise variance.\n        tau_inv_sq (float): Inverse squared prior width.\n        sigma_f_inv_sq (float): Inverse squared observation noise variance.\n\n    Returns:\n        float: The calculated MSE.\n    \"\"\"\n    error_sum = np.sum(lambdas / (tau_inv_sq + sigma_f_inv_sq * m_counts))\n    mse = sigma_f_sq + error_sum\n    return mse\n\ndef solve_d_optimality(d, lambdas, sigma_f, tau, T):\n    \"\"\"\n    Finds the minimal number of queries N for the D-optimality strategy.\n    For a given N, counts are distributed as evenly as possible and assigned\n    to dimensions to minimize RMSE (larger counts go to larger lambdas).\n    \"\"\"\n    # Pre-calculate squared and inverse values for efficiency.\n    sigma_f_sq = sigma_f**2\n    tau_inv_sq = tau**-2\n    sigma_f_inv_sq = 1.0 / sigma_f_sq\n    T_sq = T**2\n    \n    # Sort lambdas in descending order to pair them with larger counts.\n    sorted_lambdas = np.sort(lambdas)[::-1]\n    \n    N = 0\n    while True:\n        N += 1\n        q = N // d\n        r = N % d\n        \n        # Create the array of counts, with r dimensions getting q+1 samples.\n        m_counts = np.full(d, q, dtype=int)\n        m_counts[:r] += 1\n        \n        mse = calculate_mse(m_counts, sorted_lambdas, sigma_f_sq, tau_inv_sq, sigma_f_inv_sq)\n        \n        if mse = T_sq:\n            return N\n\ndef solve_sequential_strategy(d, lambdas, sigma_f, tau, T, strategy_weights):\n    \"\"\"\n    Finds the minimal N for sequential query strategies (max variance, adversarial).\n    \n    Args:\n        d (int): Number of dimensions.\n        lambdas (np.ndarray): Target distribution covariance diagonal.\n        sigma_f (float): Observation noise standard deviation.\n        tau (float): Prior width standard deviation.\n        T (float): RMSE threshold.\n        strategy_weights (np.ndarray): Weights for the acquisition score.\n\n    Returns:\n        int: The minimal number of queries N.\n    \"\"\"\n    sigma_f_sq = sigma_f**2\n    tau_inv_sq = tau**-2\n    sigma_f_inv_sq = 1.0 / sigma_f_sq\n    T_sq = T**2\n    \n    m_counts = np.zeros(d, dtype=int)\n    \n    N = 0\n    while True:\n        N += 1\n        \n        # Calculate scores for each dimension.\n        scores = strategy_weights / (tau_inv_sq + sigma_f_inv_sq * m_counts)\n        \n        # Find the index of the maximum score. np.argmax naturally breaks\n        # ties by returning the first index, which is the smallest.\n        best_idx = np.argmax(scores)\n        \n        # Update the count for the selected dimension.\n        m_counts[best_idx] += 1\n        \n        mse = calculate_mse(m_counts, lambdas, sigma_f_sq, tau_inv_sq, sigma_f_inv_sq)\n        \n        if mse = T_sq:\n            return N\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        {'d': 3, 'lambdas': np.array([1.0, 1.0, 1.0]), 'sigma_f': 0.05, 'tau': 0.10, 'T': 0.080},\n        {'d': 3, 'lambdas': np.array([8.0, 1.0, 0.2]), 'sigma_f': 0.05, 'tau': 0.10, 'T': 0.070},\n        {'d': 4, 'lambdas': np.array([5.0, 2.0, 0.5, 0.1]), 'sigma_f': 0.03, 'tau': 0.08, 'T': 0.040},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        d = case['d']\n        lambdas = case['lambdas']\n        sigma_f = case['sigma_f']\n        tau = case['tau']\n        T = case['T']\n\n        # 1. D-optimality\n        N_dopt = solve_d_optimality(d, lambdas, sigma_f, tau, T)\n\n        # 2. Maximum predictive variance\n        weights_maxvar = lambdas\n        N_maxvar = solve_sequential_strategy(d, lambdas, sigma_f, tau, T, weights_maxvar)\n\n        # 3. Adversarial Molecular Dynamics\n        # The problem states lambda_i > 0 for all test cases.\n        weights_adv_md = 1.0 / lambdas\n        N_adv = solve_sequential_strategy(d, lambdas, sigma_f, tau, T, weights_adv_md)\n        \n        all_results.append([N_dopt, N_maxvar, N_adv])\n        \n    # The str() of a list of lists produces the required output format.\n    # Joining them with commas and wrapping in brackets completes it.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}