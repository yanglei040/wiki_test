{
    "hands_on_practices": [
        {
            "introduction": "深入理解原子环境描述子的最佳方式之一是从头开始构建它们。本练习将引导你完成两种主流描述子——光滑原子位置重叠（SOAP）和以原子为中心的对称函数（ACSF）——的详细数值实现。通过从基本数学定义出发，你将亲手处理包括径向基函数、球谐函数投影和旋转不变性在内的核心构件，从而牢固掌握描述子的构造原理。",
            "id": "3443939",
            "problem": "要求您实现并数值验证用于描述局部原子环境的描述符，重点是光滑原子位置重叠（SOAP）和以原子为中心的对称函数（ACSF），从以原子为中心的密度和旋转不变性的基本定义开始。实现必须严格遵循以下说明，并为指定的测试套件生成一个汇总数值结果的单行输出。\n\n基本基础如下。考虑一个位于原点的中心原子和一组有限的邻居原子，其位置由笛卡尔坐标给出。距离以埃（Angstrom）为单位。角度必须以弧度计算。定义了一个各向同性的截断函数以确保局部性。环境的密度由点贡献表示，描述符必须在全局旋转和平移下保持不变。您的程序应实现：\n\n- 一个光滑的径向截断函数 $f_c(r)$，满足当 $r \\le r_c$ 时 $f_c(r) = \\frac{1}{2}\\left[\\cos\\left(\\frac{\\pi r}{r_c}\\right) + 1\\right]$，当 $r > r_c$ 时 $f_c(r) = 0$，$r_c$ 的单位为埃。\n- 一个近似的 SOAP 描述符，通过将点密度投影到正交归一的径向基和球谐函数上构建，然后形成旋转不变的功率谱，并用其欧几里得范数进行归一化。点密度近似对应于高斯平滑密度在 $\\sigma \\to 0$ 时的极限，对于本数值练习的目的是可接受的。\n- ACSF 径向和角向函数，设计为在平移、旋转和相同邻居的排列下保持不变。\n\n所有角度必须以弧度计算，所有距离必须以埃为单位。描述符应定义如下：\n\n- 对于截断函数，使用 $r_c = 3.0$ 埃，并如上定义 $f_c(r)$。\n- 对于 SOAP，通过使用格拉姆-施密特（Gram-Schmidt）方法对高斯径向探针 $g_k(r) = \\exp\\left( -\\frac{(r - R_k)^2}{2\\sigma_r^2} \\right)$ 关于加权内积 $\\langle u, v \\rangle = \\int_{0}^{r_c} u(r)\\,v(r)\\,r^2 \\,\\mathrm{d}r$ 进行正交归一化，来构建一个正交归一的径向基 $\\{\\phi_n(r)\\}_{n=0}^{N_n-1}$。该内积在均匀径向网格上离散化。使用 $N_n = 3$ 个径向函数，$\\sigma_r = 0.3$ 埃，中心 $R_k = r_c \\cdot \\frac{k+1}{N_n+1}$，其中 $k \\in \\{0,1,2\\}$。使用一个在 $[0,r_c]$ 上有 $N_r = 400$ 个点的均匀径向网格。设角向基为复球谐函数 $Y_{\\ell m}(\\theta,\\phi)$，最高到 $\\ell_{\\max} = 2$。对于相对于中心原子的位置向量为 $\\mathbf{r}_j$ 的邻居，定义 $r_j = \\|\\mathbf{r}_j\\|$，$\\theta_j$ 为余纬，$\\phi_j$ 为方位角。近似的展开系数为\n$$\nc_{n \\ell m} = \\sum_{j} \\phi_n(r_j)\\, Y_{\\ell m}(\\theta_j,\\phi_j)\\, f_c(r_j),\n$$\n其中求和遍及截断半径内的所有邻居。旋转不变的功率谱分量为\n$$\np_{n n' \\ell} = \\sum_{m=-\\ell}^{\\ell} c_{n \\ell m}\\, c_{n' \\ell m}^*,\n$$\n描述符是 $p_{n n' \\ell}$ 在 $\\ell \\in \\{0,1,2\\}$ 和 $0 \\le n \\le n' \\le N_n-1$ 上的串联，如果其欧几里得范数非零，则进行归一化。\n- 对于 ACSF 径向函数 $G^{(2)}$，对于一个中心原子及其邻居（索引为 $j$），使用以下函数族\n$$\nG^{(2)}(\\eta, R_s) = \\sum_{j} \\exp\\left( -\\eta\\, (r_{j} - R_s)^2 \\right)\\, f_c(r_{j}),\n$$\n参数为 $\\eta = 1.0$ 和 $R_s \\in \\{0.5, 1.0, 1.5, 2.0, 2.5\\}$（单位为埃）；报告这个 $5$ 分量向量的和。\n- 对于 ACSF 角向函数 $G^{(4)}$，对于不同的邻居对 $(j,k)$（其中 $j  k$），使用\n$$\nG^{(4)}(\\eta, \\zeta, \\lambda) = 2^{1-\\zeta} \\sum_{j  k} (1 + \\lambda \\cos\\theta_{jik})^{\\zeta} \\exp(-\\eta(r_{ij}^2+r_{ik}^2+r_{jk}^2)) f_c(r_{ij})f_c(r_{ik})f_c(r_{jk})\n$$\n参数为 $\\eta=0.5, \\zeta=4.0, \\lambda=-1.0$；报告单个 $G^{(4)}$ 的值。",
            "solution": "问题陈述已经过仔细审查，并被确定为有效。它在科学上基于计算材料科学的原理，自洽地包含了所有必要的参数和定义，并且是适定的，允许一个唯一的、可验证的数值解。因此，我们可以进行形式化的求解。\n\n目标是实现并数值评估两种用于描述局部原子环境的描述符：光滑原子位置重叠（SOAP）和以原子为中心的对称函数（ACSF）。这些描述符旨在提供原子局部环境的数值指纹，该指纹对平移、旋转和相同邻居原子的排列保持不变。\n\n### 1. 基本定义\n\n我们从两种描述符类型共有的基本元素开始。局部环境是为中心原子定义的，我们将其置于原点 $\\mathbf{0}$，并有一组邻居原子位于位置 $\\{\\mathbf{r}_j\\}$。\n\n一个关键组成部分是光滑截断函数 $f_c(r)$，它确保只有在特定半径 $r_c$ 内的原子才对描述符有贡献。这种局部性对于计算效率和物理相关性至关重要。指定的截断函数为：\n$$\nf_c(r) = \\begin{cases} \\frac{1}{2}\\left[\\cos\\left(\\frac{\\pi r}{r_c}\\right) + 1\\right]  \\text{if } r \\le r_c \\\\ 0  \\text{if } r  r_c \\end{cases}\n$$\n截断半径 $r_c = 3.0$ 埃。这里，$r = \\|\\mathbf{r}\\|$ 是径向距离。\n\n### 2. 光滑原子位置重叠（SOAP）描述符\n\nSOAP 描述符是通过在一组基函数上展开局部原子密度，然后形成一个旋转不变的功率谱来构建的。问题指定了一种近似形式，其中原子密度是狄拉克δ函数的和，$\\rho(\\mathbf{r}) = \\sum_j \\delta(\\mathbf{r} - \\mathbf{r}_j)$。\n\n**步骤 2.1：正交归一径向基 $\\{\\phi_n(r)\\}$**\n第一步是为展开的径向部分构建一个正交归一基。我们从一组非正交的高斯函数开始：\n$$\ng_k(r) = \\exp\\left( -\\frac{(r - R_k)^2}{2\\sigma_r^2} \\right)\n$$\n对于 $k \\in \\{0, 1, ..., N_n-1\\}$。问题指定了 $N_n = 3$ 个径向函数，$\\sigma_r = 0.3$ 埃，以及中心 $R_k = r_c \\cdot \\frac{k+1}{N_n+1}$。\n\n这些函数使用格拉姆-施密特（Gram-Schmidt）过程，关于一个加权内积 $\\langle u, v \\rangle = \\int_{0}^{r_c} u(r)\\,v(r)\\,r^2 \\,\\mathrm{d}r$ 进行正交化。在数值上，这个积分在从 $r=0$ 到 $r=r_c$ 的 $N_r = 400$ 个点的均匀径向网格上进行离散化。设网格点为 $\\{r_i\\}$，间距为 $\\Delta r$。内积近似为以下求和：\n$$\n\\langle u, v \\rangle \\approx \\sum_{i=0}^{N_r-1} u(r_i)v(r_i)r_i^2 \\Delta r\n$$\n然后将格拉姆-施密特过程应用于集合 $\\{g_k(r)\\}$ 以获得正交归一基 $\\{\\phi_n(r)\\}$。\n\n**步骤 2.2：展开系数 $c_{n \\ell m}$**\n原子环境被投影到一个由我们的径向基函数 $\\phi_n(r)$ 和复球谐函数 $Y_{\\ell m}(\\theta, \\phi)$ 的乘积形成的基上，其中 $\\theta$ 是余纬，$\\phi$ 是方位角。展开系数通过对截断半径内每个邻居 $j$ 的贡献求和得到：\n$$\nc_{n \\ell m} = \\sum_{j} \\phi_n(r_j)\\, Y_{\\ell m}(\\theta_j,\\phi_j)\\, f_c(r_j)\n$$\n其中 $(r_j, \\theta_j, \\phi_j)$ 是邻居位置 $\\mathbf{r}_j$ 的球坐标。$\\phi_n(r_j)$ 的值是通过在距离 $r_j$ 处评估数值定义的基函数得到的，对此，径向网格上的线性插值是一种合适的方法。角分辨率由 $\\ell_{\\max} = 2$ 限制。\n\n**步骤 2.3：功率谱 $p_{n n' \\ell}$ 和最终描述符**\n为实现旋转不变性，我们通过对磁量子数 $m$ 求和来构建功率谱：\n$$\np_{n n' \\ell} = \\sum_{m=-\\ell}^{\\ell} c_{n \\ell m}\\, c_{n' \\ell m}^*\n$$\n其中 $c^*$ 表示复共轭。分量 $p_{n n' \\ell}$ 在坐标系旋转下是不变的。最终的 SOAP 描述符是一个向量，由所有 $\\ell \\in \\{0, 1, 2\\}$ 和所有唯一对 $0 \\le n \\le n' \\le N_n-1$ 的实值分量 $p_{n n' \\ell}$ 串联而成。如果该向量的欧几里得范数非零，则将其归一化为单位长度。\n\n### 3. 以原子为中心的对称函数（ACSF）\n\nACSF 是另一类描述符，直接由几何量（距离和角度）构建，以确保其构造上的不变性。\n\n**步骤 3.1：径向函数 $G^{(2)}$**\n径向对称函数 $G^{(2)}$ 探测邻居的径向分布。它定义为对所有邻居 $j$ 的求和：\n$$\nG^{(2)}(\\eta, R_s) = \\sum_{j} \\exp\\left( -\\eta\\, (r_{j} - R_s)^2 \\right)\\, f_c(r_{j})\n$$\n其中 $\\eta$ 控制高斯函数的宽度，$R_s$ 是一个可变的中心。问题要求计算一个 $G^{(2)}$ 值的向量，其参数为 $\\eta = 1.0$ 和 $R_s \\in \\{0.5, 1.0, 1.5, 2.0, 2.5\\}$，并报告这五个分量的和。\n\n**步骤 3.2：角向函数 $G^{(4)}$**\n角向对称函数 $G^{(4)}$ 探测邻居的角向分布，考虑原子三元组（中心原子和两个邻居 $j$ 和 $k$）。它被定义为对所有不同的邻居对 $(j, k)$ 求和。问题中指定的具体形式为：\n$$\nG^{(4)}(\\eta, \\zeta, \\lambda) = 2^{1-\\zeta} \\sum_{j  k} (1 + \\lambda \\cos\\theta_{jik})^{\\zeta} \\exp(-\\eta(r_{ij}^2+r_{ik}^2+r_{jk}^2)) f_c(r_{ij})f_c(r_{ik})f_c(r_{jk})\n$$\n这个函数包含一个角向部分 $(1 + \\lambda \\cos\\theta_{jik})^{\\zeta}$ 和一个复杂的径向部分，该部分依赖于三元组中的所有三个距离 $r_{ij}, r_{ik}, r_{jk}$。对所有 $j  k$ 的对进行求和，确保了对相同邻居的排列不变性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef solve():\n    \"\"\"\n    Main function to compute and print the required results for the five test cases.\n    \"\"\"\n    \n    # --- Problem Parameters ---\n    RC = 3.0  # Cutoff radius in Angstroms\n\n    # SOAP parameters\n    N_N = 3  # Number of radial basis functions\n    L_MAX = 2  # Maximum angular momentum\n    SIGMA_R = 0.3  # Width of Gaussian radial probes\n    N_R = 400  # Number of points in the radial grid\n\n    # ACSF G2 parameters\n    G2_ETA = 1.0\n    G2_RS_VALUES = np.array([0.5, 1.0, 1.5, 2.0, 2.5])\n\n    # ACSF G4 parameters\n    G4_ETA = 0.5\n    G4_ZETA = 4.0\n    G4_LAMBDA = -1.0\n\n    # --- Helper Functions ---\n\n    def cartesian_to_spherical(xyz):\n        \"\"\"Converts Cartesian coordinates to spherical coordinates (r, theta, phi).\"\"\"\n        if xyz.ndim == 1:\n            xyz = xyz.reshape(1, -1)\n        r = np.sqrt(np.sum(xyz**2, axis=1))\n        # np.arccos is sensitive to values slightly  1.0 due to precision\n        safe_z_over_r = np.clip(xyz[:, 2] / r, -1.0, 1.0)\n        theta = np.arccos(safe_z_over_r)  # Colatitude\n        phi = np.arctan2(xyz[:, 1], xyz[:, 0])  # Azimuth\n        return r, theta, phi\n\n    def cutoff_function(r, rc):\n        \"\"\"Smooth cosine cutoff function.\"\"\"\n        r = np.asarray(r)\n        fc = np.zeros_like(r, dtype=float)\n        mask = r = rc\n        fc[mask] = 0.5 * (np.cos(np.pi * r[mask] / rc) + 1.0)\n        return fc\n\n    # --- SOAP Implementation ---\n\n    # Pre-calculate the orthonormal radial basis to be reused.\n    def create_soap_radial_basis(n_n, rc, sigma_r, n_r):\n        \"\"\"Constructs the orthonormal radial basis via Gram-Schmidt.\"\"\"\n        r_grid = np.linspace(0, rc, n_r)\n        dr = r_grid[1] - r_grid[0]\n\n        # Initial Gaussian basis functions\n        g_basis = []\n        r_k_centers = rc * (np.arange(n_n) + 1) / (n_n + 1)\n        for r_k in r_k_centers:\n            g_k = np.exp(-((r_grid - r_k) ** 2) / (2 * sigma_r ** 2))\n            g_basis.append(g_k)\n        \n        # Inner product for functions on the grid\n        def inner_product(f1, f2):\n            integrand = f1 * f2 * r_grid**2\n            return np.sum(integrand) * dr\n\n        # Gram-Schmidt orthonormalization\n        ortho_basis = []\n        for g_n in g_basis:\n            phi_n = g_n\n            for phi_j in ortho_basis:\n                phi_n = phi_n - inner_product(g_n, phi_j) * phi_j\n            \n            norm = np.sqrt(inner_product(phi_n, phi_n))\n            if norm > 1e-15:\n                phi_n /= norm\n            else: # Handle case of linearly dependent vector\n                phi_n *= 0.0\n            ortho_basis.append(phi_n)\n            \n        return r_grid, ortho_basis\n\n    R_GRID, PHI_BASIS = create_soap_radial_basis(N_N, RC, SIGMA_R, N_R)\n\n    def compute_soap_descriptor(neighbors, rc, n_n, l_max, r_grid, phi_basis):\n        \"\"\"Computes the normalized SOAP power spectrum vector.\"\"\"\n        if len(neighbors) == 0:\n            n_components = sum((n_n * (n_n + 1) // 2 for l in range(l_max + 1)))\n            return np.zeros(n_components)\n\n        r_j, theta_j, phi_j = cartesian_to_spherical(neighbors)\n        fc_j = cutoff_function(r_j, rc)\n        \n        valid_indices = np.where(r_j = rc)[0]\n        if len(valid_indices) == 0:\n            n_components = sum((n_n * (n_n + 1) // 2 for l in range(l_max + 1)))\n            return np.zeros(n_components)\n\n        # Interpolate radial basis functions at neighbor distances\n        phi_n_r_j = np.array([np.interp(r_j[valid_indices], r_grid, phi_n) for phi_n in phi_basis])\n\n        # Compute expansion coefficients c_nlm\n        c_nlm = np.zeros((n_n, l_max + 1, 2 * l_max + 1), dtype=complex)\n        for n in range(n_n):\n            for l in range(l_max + 1):\n                for m in range(-l, l + 1):\n                    # scipy.special.sph_harm takes (m, l, azimuth, polar)\n                    ylm = sph_harm(m, l, phi_j[valid_indices], theta_j[valid_indices])\n                    # Sum over valid neighbors\n                    c_nlm[n, l, m + l_max] = np.sum(phi_n_r_j[n] * ylm * fc_j[valid_indices])\n\n        # Compute power spectrum p_nn'l\n        power_spectrum_list = []\n        for l in range(l_max + 1):\n            for n1 in range(n_n):\n                for n2 in range(n1, n_n):\n                    # sum over m\n                    c1 = c_nlm[n1, l, l_max-l : l_max+l+1]\n                    c2_conj = np.conj(c_nlm[n2, l, l_max-l : l_max+l+1])\n                    p_val = np.sum(c1 * c2_conj)\n                    power_spectrum_list.append(p_val.real) # Should be real anyway\n\n        p_vec = np.array(power_spectrum_list)\n        norm = np.linalg.norm(p_vec)\n\n        if norm > 1e-15:\n            return p_vec / norm\n        return p_vec\n\n    # --- ACSF Implementation ---\n\n    def compute_g2_sum(neighbors, rc, eta, rs_values):\n        \"\"\"Computes the sum of the G2 ACSF vector components.\"\"\"\n        if len(neighbors) == 0:\n            return 0.0\n        \n        r_j = np.linalg.norm(neighbors, axis=1)\n        fc_j = cutoff_function(r_j, rc)\n        \n        g2_vector = []\n        for rs in rs_values:\n            g2_val = np.sum(np.exp(-eta * (r_j - rs)**2) * fc_j)\n            g2_vector.append(g2_val)\n            \n        return np.sum(g2_vector)\n\n    def compute_g4(neighbors, rc, eta, zeta, lam):\n        \"\"\"Computes the G4 angular ACSF value.\"\"\"\n        num_neighbors = len(neighbors)\n        if num_neighbors  2:\n            return 0.0\n            \n        total_g4 = 0.0\n        \n        for j in range(num_neighbors):\n            for k in range(j + 1, num_neighbors):\n                r_j_vec = neighbors[j]\n                r_k_vec = neighbors[k]\n                \n                r_j = np.linalg.norm(r_j_vec)\n                r_k = np.linalg.norm(r_k_vec)\n                \n                r_jk_vec = r_k_vec - r_j_vec\n                r_jk = np.linalg.norm(r_jk_vec)\n                \n                fc_j = cutoff_function(r_j, rc)\n                fc_k = cutoff_function(r_k, rc)\n                fc_jk = cutoff_function(r_jk, rc)\n                \n                if fc_j == 0 or fc_k == 0 or fc_jk == 0:\n                    continue\n\n                # cos(theta_jk) = (r_j . r_k) / (|r_j| |r_k|)\n                cos_theta_jk = np.dot(r_j_vec, r_k_vec) / (r_j * r_k)\n                \n                term = (1 + lam * cos_theta_jk)**zeta\n                exp_term = np.exp(-eta * (r_j**2 + r_k**2 + r_jk**2))\n                \n                total_g4 += term * exp_term * fc_j * fc_k * fc_jk\n                \n        return (2**(1 - zeta)) * total_g4\n\n    # --- Test Cases ---\n    \n    test_cases = {\n        1: np.array([[1.0, 0.0, 0.0], [0.0, 1.5, 0.0], [0.0, 0.0, 2.0]]),\n        2: np.array([[0.0, 1.0, 0.0], [-1.5, 0.0, 0.0], [0.0, 0.0, 2.0]]), # Case 1 rotated\n        3: np.array([[3.0, 0.0, 0.0]]),\n        4: np.empty((0, 3)),\n        5: np.array([[1.0, 0.0, 0.0], [-1.0, 0.0, 0.0]])\n    }\n\n    # --- Calculate Required Outputs ---\n    \n    results = []\n\n    # Result 1: Max absolute difference between SOAP for Case 1 and Case 2\n    soap1 = compute_soap_descriptor(test_cases[1], RC, N_N, L_MAX, R_GRID, PHI_BASIS)\n    soap2 = compute_soap_descriptor(test_cases[2], RC, N_N, L_MAX, R_GRID, PHI_BASIS)\n    result1 = np.max(np.abs(soap1 - soap2))\n    results.append(result1)\n\n    # Result 2: Value of f_c(r) at r = r_c for Case 3\n    result2 = cutoff_function(test_cases[3][0, 0], RC)\n    results.append(result2)\n\n    # Result 3: Euclidean norm of normalized SOAP for Case 4\n    soap4 = compute_soap_descriptor(test_cases[4], RC, N_N, L_MAX, R_GRID, PHI_BASIS)\n    # The problem asks for the norm of the *final* vector.\n    # If the initial norm is 0, the vector is not normalized and remains 0.\n    # So the norm of the final vector is also 0.\n    result3 = np.linalg.norm(soap4)\n    results.append(result3)\n\n    # Result 4: Sum of 5-component ACSF G2 vector for Case 1\n    result4 = compute_g2_sum(test_cases[1], RC, G2_ETA, G2_RS_VALUES)\n    results.append(result4)\n\n    # Result 5: ACSF G4 value for Case 5\n    result5 = compute_g4(test_cases[5], RC, G4_ETA, G4_ZETA, G4_LAMBDA)\n    results.append(result5)\n\n    # Final print statement\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当存在像对分布函数（pair distribution function）这样更简单的工具时，我们为什么还需要像SOAP这样复杂的高阶描述子？本练习旨在通过一个富有启发性的思想实验来回答这个问题。你将构建几对原子环境，它们具有完全相同的对分布函数但结构上却截然不同，然后探索SOAP描述子中包含的角向信息如何能够将它们区分开来，从而揭示高阶描述子的独特辨识能力。",
            "id": "3443973",
            "problem": "您的任务是构建并分析两种三维局部原子环境。这两种环境具有相同的对分布，但无法通过任何刚性旋转或反射相互叠合。目标是确定一个基于原子位置光滑重叠（SOAP）的旋转不变描述符区分这两种环境所需的最小角分辨率，该分辨率以最小非负整数 $l_{\\max}$ 表示。目标描述符必须直接根据邻居分布的角向分解构建，并且在每个角量子数 $l$ 上都必须是旋转不变的。\n\n此任务的基本依据如下：\n- 中心原子周围的对分布，记作 $g(r)$，仅取决于到中心原子的邻居距离的多重集，并舍弃所有角度信息。\n- 球谐函数在单位球面上构成一个正交归一基，由 $(l,m)$ 索引，其中 $l \\in \\{0,1,2,\\dots\\}$ 且 $m \\in \\{-l,-l+1,\\dots,l\\}$。\n- 旋转不变性是通过以不依赖于方向的方式聚合角向模的幅值来获得的；具体来说，在固定的 $l$ 下对 $m$ 求和会产生旋转不变的量。\n\n您必须实现一个程序，为下面提供的每个测试用例执行以下步骤：\n- 将中心原子周围的两个局部环境构建为邻居矢量的有限集。每个邻居矢量是一个三维笛卡尔矢量，表示邻居相对于中心原子的位置。所有角度必须以弧度处理。\n- 通过在每个环境中使用相同的邻居半径多重集，确保该对环境中的两者具有相同的对分布 $g(r)$，从而仅有角度信息不同。\n- 采用标准 SOAP 原子密度的零宽度极限（因此每个邻居都贡献为单位球面上的一个方向点），并使用与将半径划分为壳层一致的正交归一径向通道方案。在指定的壳层上使用分段常数、相互正交的径向通道来分离来自不同半径的贡献；在单壳层情况下，只有一个壳层。对于多壳层情况，按规定使用一个分割半径定义两个壳层。\n- 对于一个选定的非负搜索上限 $L_{\\text{search}}$，通过将每个径向壳层内的邻居方向投影到球谐函数上，并聚合所有 $m$ 的幅值以形成每个 $l$ 的旋转不变量，来计算每个角量子数 $l \\in \\{0,1,\\dots,L_{\\text{search}}\\}$ 处的旋转不变描述符。对于多壳层情况，在每个 $l$ 处，描述符的构成需包括壳层之间的跨通道相关性。\n- 确定最小的 $l_{\\max} \\in \\{0,1,\\dots,L_{\\text{search}}\\}$，使得两个环境的描述符在该值上的差异超过固定的数值容差，或者如果对于所有 $l \\le L_{\\text{search}}$ 都未检测到差异，则返回 $-1$。\n\n您的程序必须使用以下方式实现上述要求：\n- 使用以弧度为参数的球谐函数进行计算。\n- 使用 $10^{-12}$ 的数值容差来判断描述符是否相等。\n- 搜索上限 $L_{\\text{search}} = 12$。\n\n在以下测试套件中设计环境。在所有情况下，邻居半径不带任何物理单位，是纯数字，所有角度量均以弧度为单位。\n\n- 测试用例 1（单壳层）：环境 $\\mathcal{A}_1$ 在半径为 $1$ 处有 $4$ 个邻居，位于内切于单位球面的正四面体的顶点上（使用四个方向 $(\\pm 1,\\pm 1,\\pm 1)/\\sqrt{3}$，其中负号数量为偶数）。环境 $\\mathcal{B}_1$ 在半径为 $1$ 处有 $4$ 个邻居，位于赤道平面上，方向为 $(1,0,0)$、$(-1,0,0)$、$(0,1,0)$、$(0,-1,0)$。两者具有相同的 $g(r)$，因为所有邻居半径均为 $1$。\n- 测试用例 2（单壳层）：环境 $\\mathcal{A}_2$ 在半径为 $1$ 处有 $6$ 个邻居，方向为 $(\\pm 1,0,0)$、$(0,\\pm 1,0)$、$(0,0,\\pm 1)$（八面体排布）。环境 $\\mathcal{B}_2$ 在半径为 $1$ 处有 $6$ 个邻居，均匀分布在赤道圆周上，方位角分别为 $0$、$\\pi/3$、$2\\pi/3$、$\\pi$、$4\\pi/3$、$5\\pi/3$，极角为 $\\pi/2$。两者具有相同的 $g(r)$，因为所有邻居半径均为 $1$。\n- 测试用例 3（单壳层）：环境 $\\mathcal{A}_3$ 与 $\\mathcal{A}_1$ 相同。环境 $\\mathcal{B}_3$ 是将 $\\mathcal{A}_1$ 绕 $z$ 轴旋转 $0.37$ 弧度得到的。这两者通过旋转是同构的，因此它们的旋转不变描述符对于所有 $l$ 都应一致。\n- 测试用例 4（双壳层）：环境 $\\mathcal{A}_4$ 有 $5$ 个邻居，半径为 $\\{1,1,1.5,1.5,1.5\\}$。将两个半径为 $1$ 的邻居沿 $(0,0,1)$ 和 $(0,0,-1)$ 放置。将三个半径为 $1.5$ 的邻居放置在赤道平面上，方位角为 $0$、$2\\pi/3$、$4\\pi/3$，极角为 $\\pi/2$。环境 $\\mathcal{B}_4$ 具有相同的半径多重集 $\\{1,1,1.5,1.5,1.5\\}$，两个半径为 $1$ 的邻居也沿 $(0,0,1)$ 和 $(0,0,-1)$ 放置，但三个半径为 $1.5$ 的邻居不在赤道平面上，而是具有共同的极角 $1.0$ 和方位角 $0$、$2\\pi/3$、$4\\pi/3$。使用双壳层径向方案，分割半径为 $1.25$，因此半径 $1$ 属于内层，半径 $1.5$ 属于外层。\n\n对于每个测试用例，从 $l=0$ 搜索到 $L_{\\text{search}}$，并报告两种环境的旋转不变描述符差异超出容差时的最小 $l_{\\max}$，如果在搜索范围内未检测到差异，则返回 $-1$。您的程序应生成一行输出，其中包含一个方括号括起来的逗号分隔列表（例如，$[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$），其中每个条目是 $\\{-1,0,1,\\dots,12\\}$ 中的一个整数。",
            "solution": "该问题要求确定一个旋转不变描述符区分成对的三维局部原子环境所需的最小角分辨率，该分辨率用整数 $l_{\\max}$ 表示。这些环境被构造成具有相同的对分布，但具有不同的高阶（角向）相关性。该描述符基于原子位置光滑重叠（SOAP）形式体系，并简化为原子邻居的零宽度极限。\n\n### 数学框架\n一个局部原子环境由一组相对于中心原子的邻居位置矢量 $\\{\\vec{r}_i\\}$ 定义。原子邻居密度 $\\rho(\\vec{r})$ 是位于每个邻居位置的狄拉克δ函数的总和：\n$$\n\\rho(\\vec{r}) = \\sum_i \\delta(\\vec{r} - \\vec{r}_i)\n$$\n这个密度在一个基中展开，其中角向部分使用球谐函数 $Y_{lm}(\\hat{r})$，径向部分使用径向基 $g_n(r)$。问题指定了一个简化的径向方案，其中邻居被划分到不相交的壳层中。特定壳层 $n$ 内的密度展开系数由下式给出：\n$$\nc_{nlm} = \\int \\rho(\\vec{r}) g_n(r) Y_{lm}^*(\\hat{r}) d\\vec{r}\n$$\n对于δ函数密度和一个划分方案（其中 $g_n(r)$ 实际上是壳层 $n$ 的指示函数），该积分简化为对属于该壳层的邻居 $\\{i\\}$（我们用集合 $I_n$ 表示）的求和：\n$$\nc_{nlm} = \\sum_{i \\in I_n} Y_{lm}^*(\\theta_i, \\phi_i)\n$$\n其中 $(\\theta_i, \\phi_i)$ 是邻居矢量 $\\vec{r}_i$ 的极角和方位角。球谐函数 $Y_{lm}(\\theta, \\phi)$ 使用标准的物理学约定进行计算，其中 $\\theta \\in [0, \\pi]$ 和 $\\phi \\in [0, 2\\pi)$。\n\n### 旋转不变描述符\n为了实现旋转不变性，我们从展开系数构建功率谱。对于给定的角动量通道 $l$，功率谱分量是通过耦合来自两个径向壳层 $n_1$ 和 $n_2$ 的系数，并对磁量子数 $m$ 求和来形成的：\n$$\np_{n_1 n_2 l} = \\sum_{m=-l}^{l} c_{n_1 l m}^* c_{n_2 l m}\n$$\n这些量在原子环境的刚性旋转下是不变的。对于给定的 $l$，这些值的集合构成了该角量子数下的描述符。\n\n- **单壳层情况**：我们只有一个壳层 ($n_1=n_2=1$)。在量子数 $l$ 下的描述符是标量值 $p_{11l} = \\sum_{m=-l}^{l} |c_{1lm}|^2$。\n- **双壳层情况**：对于两个壳层 ($n \\in \\{1, 2\\}$)，在量子数 $l$ 下的描述符必须包括所有自相关 ($p_{11l}, p_{22l}$) 和互相关 ($p_{12l}, p_{21l}$)。由于 $p_{21l} = p_{12l}^*$，对于给定的 $l$，其独特信息被实数向量 $(p_{11l}, p_{22l}, \\text{Re}(p_{12l}), \\text{Im}(p_{12l}))$ 所捕获。\n\n### 寻找 $l_{\\max}$ 的算法\n对于每一对环境 $\\mathcal{A}$ 和 $\\mathcal{B}$，我们搜索它们的描述符出现差异的最小非负整数 $l_{\\max}$。\n\n1.  对于从 $0$ 到 $L_{\\text{search}} = 12$ 的每个角量子数 $l$：\n    a. 计算环境 $\\mathcal{A}$ 的描述符向量，记为 $D_l^{(\\mathcal{A})}$。\n    b. 计算环境 $\\mathcal{B}$ 的描述符向量，记为 $D_l^{(\\mathcal{B})}$。\n    c. 如果欧几里得距离 $\\|D_l^{(\\mathcal{A})} - D_l^{(\\mathcal{B})}\\| > 10^{-12}$，则 $l$ 是最小的区分角量子数。我们设置 $l_{\\max} = l$ 并终止对该对的搜索。\n2.  如果循环完成而没有发现任何差异，则说明在 $L_{\\text{search}}$ 的范围内，这些环境是不可区分的。在这种情况下，我们设置 $l_{\\max} = -1$。\n\n### 测试用例分析\n\n- **测试用例 1**：正四面体（$\\mathcal{A}_1$，对称群 $T_d$）与方形平面排列（$\\mathcal{B}_1$，对称性 $D_{4h}$）。由于其高对称性，四面体环境在球谐函数基上的展开，其第一个非零功率谱分量出现在 $l=3$。相比之下，方形平面结构对称性较低，其第一个非零的非平凡（$l>0$）功率谱分量出现在 $l=2$（四极）。因此，两种环境的描述符将在 $l=2$ 处首次出现差异。预期结果是 $l_{\\max}=2$。\n\n- **测试用例 2**：八面体（$\\mathcal{A}_2$，对称性 $O_h$）与平面正六边形（$\\mathcal{B}_2$，对称性 $D_{6h}$）。两种结构都具有高对称性。根据群论，对于八面体构型，其邻居密度在球谐函数上的展开，第一个非零的功率谱分量出现在角量子数 $l=4$ 处。对于平面正六边形构型，第一个非零的功率谱分量出现在 $l=6$ 处。因此，两种结构在 $l=0$ 处具有相同的（非零）分量，在 $l=1,2,3$ 处分量均为零。它们第一个产生差异的角量子数是 $l=4$，此时八面体环境的描述符分量非零，而六边形的仍然为零。因此，预期结果为 $l_{\\max}=4$。\n\n- **测试用例 3**：正四面体（$\\mathcal{A}_3$）与旋转了 $0.37$ 弧度的同一四面体（$\\mathcal{B}_3$）。该描述符被设计为旋转不变的。因此，$\\mathcal{A}_3$ 和 $\\mathcal{B}_3$ 的描述符在数值精度范围内对于所有 $l$ 都应该是相同的。预期结果是 $l_{\\max}=-1$。\n\n- **测试用例 4**：具有 $D_{3h}$ 对称性的双壳层环境（$\\mathcal{A}_4$）与具有 $C_{3v}$ 对称性的环境（$\\mathcal{B}_4$）。两种环境中的内层是相同的。$\\mathcal{A}_4$ 的外层由赤道平面上的三个原子组成，其矢量和为零，导致偶极矩为零（$c_{2,1,m}^{(\\mathcal{A}_4)}=0$）。$\\mathcal{B}_4$ 的外层三个原子位于 $1.0$ 弧度的极角处，导致沿 $z$ 轴的净矢量和非零。这意味着存在非零的偶极矩（$c_{2,1,0}^{(\\mathcal{B}_4)} \\neq 0$）。因此，$\\mathcal{A}_4$ 的功率谱项 $p_{22,1}$ 将为零，而 $\\mathcal{B}_4$ 的则非零。预期这两个环境将在 $l=1$ 处被区分开。",
            "answer": "```python\n# The complete and runnable Python 3 code.\n# Execution environment: python 3.12, numpy 1.23.5, scipy 1.11.4\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef cart_to_sph(vecs):\n    \"\"\"Converts Cartesian coordinates to spherical coordinates (r, theta, phi).\"\"\"\n    r = np.linalg.norm(vecs, axis=1)\n    # Handle the case of the origin to avoid division by zero\n    theta = np.zeros_like(r)\n    phi = np.zeros_like(r)\n    non_zero_r_mask = r > 1e-15\n    \n    # Polar angle theta from z-axis\n    theta[non_zero_r_mask] = np.arccos(vecs[non_zero_r_mask, 2] / r[non_zero_r_mask])\n    \n    # Azimuthal angle phi from x-axis in xy-plane\n    phi[non_zero_r_mask] = np.arctan2(vecs[non_zero_r_mask, 1], vecs[non_zero_r_mask, 0])\n    return r, theta, phi\n\ndef compute_descriptors_for_l(env_points_by_shell, l_val, n_shells):\n    \"\"\"\n    Computes the descriptor vector for a single l value.\n    'env_points_by_shell' is a list of (thetas, phis) tuples, one for each shell.\n    \"\"\"\n    # Compute c_nlm coefficients for each shell\n    c_lms_per_shell = []\n    for thetas, phis in env_points_by_shell:\n        c_lm = np.zeros(2 * l_val + 1, dtype=np.complex128)\n        if thetas.size > 0:\n            for m_idx, m_val in enumerate(range(-l_val, l_val + 1)):\n                # scipy.special.sph_harm(m, l, phi, theta)\n                ylm_vals = sph_harm(m_val, l_val, phis, thetas)\n                c_lm[m_idx] = np.sum(np.conj(ylm_vals))\n        c_lms_per_shell.append(c_lm)\n\n    # Compute power spectrum components p_n1n2l\n    if n_shells == 1:\n        c1 = c_lms_per_shell[0]\n        p11l = np.sum(np.conj(c1) * c1).real\n        return np.array([p11l])\n    elif n_shells == 2:\n        c1 = c_lms_per_shell[0]\n        c2 = c_lms_per_shell[1]\n        p11l = np.sum(np.conj(c1) * c1).real\n        p22l = np.sum(np.conj(c2) * c2).real\n        p12l = np.sum(np.conj(c1) * c2)\n        return np.array([p11l, p22l, p12l.real, p12l.imag])\n    return np.array([])\n\ndef find_lmax(env_a_pts, env_b_pts, l_search, n_shells=1, split_radius=None, tol=1e-12):\n    \"\"\"\n    Finds the minimal l_max at which two environments' descriptors differ.\n    \"\"\"\n    \n    # Partition neighbors into shells and get spherical coords\n    def get_spherical_coords_by_shell(points):\n        coords_by_shell = []\n        if n_shells == 1:\n            if points.shape[0] > 0:\n                _, thetas, phis = cart_to_sph(points)\n                coords_by_shell.append((thetas, phis))\n            else:\n                 coords_by_shell.append((np.array([]), np.array([])))\n        elif n_shells == 2:\n            radii = np.linalg.norm(points, axis=1)\n            shell1_pts = points[radii  split_radius]\n            shell2_pts = points[radii >= split_radius]\n            for shell_pts in [shell1_pts, shell2_pts]:\n                if shell_pts.shape[0] > 0:\n                    _, thetas, phis = cart_to_sph(shell_pts)\n                    coords_by_shell.append((thetas, phis))\n                else:\n                    coords_by_shell.append((np.array([]), np.array([])))\n        return coords_by_shell\n\n    sph_coords_a = get_spherical_coords_by_shell(env_a_pts)\n    sph_coords_b = get_spherical_coords_by_shell(env_b_pts)\n\n    for l_val in range(l_search + 1):\n        desc_a = compute_descriptors_for_l(sph_coords_a, l_val, n_shells)\n        desc_b = compute_descriptors_for_l(sph_coords_b, l_val, n_shells)\n        \n        diff = np.linalg.norm(desc_a - desc_b)\n        \n        if diff > tol:\n            return l_val\n    \n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the analysis, and print results.\n    \"\"\"\n    L_SEARCH = 12\n\n    # Test Case 1: Tetrahedron vs. Square Planar\n    a1_pts = np.array([[1, 1, 1], [1, -1, -1], [-1, 1, -1], [-1, -1, 1]]) / np.sqrt(3)\n    b1_pts = np.array([[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0]], dtype=float)\n\n    # Test Case 2: Octahedron vs. Planar Hexagon\n    a2_pts = np.array([[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]], dtype=float)\n    b2_phis = np.arange(6) * np.pi / 3\n    b2_pts = np.array([[np.cos(phi), np.sin(phi), 0] for phi in b2_phis])\n\n    # Test Case 3: Tetrahedron vs. Rotated Tetrahedron\n    a3_pts = a1_pts.copy()\n    angle = 0.37\n    rot_matrix = np.array([\n        [np.cos(angle), -np.sin(angle), 0],\n        [np.sin(angle),  np.cos(angle), 0],\n        [0, 0, 1]\n    ])\n    b3_pts = a3_pts @ rot_matrix.T\n\n    # Test Case 4: Two-shell D3h vs. C3v-like\n    a4_shell1 = np.array([[0, 0, 1.0], [0, 0, -1.0]]) * 1.0\n    a4_phis = np.arange(3) * 2 * np.pi / 3\n    a4_shell2 = np.array([[np.cos(phi), np.sin(phi), 0] for phi in a4_phis]) * 1.5\n    a4_pts = np.vstack([a4_shell1, a4_shell2])\n    \n    b4_shell1 = np.array([[0, 0, 1.0], [0, 0, -1.0]]) * 1.0\n    b4_theta = 1.0\n    b4_phis = np.arange(3) * 2 * np.pi / 3\n    b4_shell2 = np.array([\n        [np.sin(b4_theta) * np.cos(phi), np.sin(b4_theta) * np.sin(phi), np.cos(b4_theta)]\n        for phi in b4_phis\n    ]) * 1.5\n    b4_pts = np.vstack([b4_shell1, b4_shell2])\n\n    test_cases = [\n        (a1_pts, b1_pts, 1, None),\n        (a2_pts, b2_pts, 1, None),\n        (a3_pts, b3_pts, 1, None),\n        (a4_pts, b4_pts, 2, 1.25)\n    ]\n    \n    results = []\n    for a_pts, b_pts, n_shells, split_radius in test_cases:\n        lmax = find_lmax(a_pts, b_pts, L_SEARCH, n_shells=n_shells, split_radius=split_radius)\n        results.append(lmax)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "描述子的数学设计对其在分子动力学（MD）模拟中作为机器学习势函数的性能有着直接而深远的影响。本练习聚焦于一个关键设计细节——截断函数（cutoff function）。通过分析推导，你将探索不同平滑度的截断函数如何影响原子间力的连续性，这对于保证MD模拟的能量守恒和稳定性至关重要。",
            "id": "3443993",
            "problem": "考虑一个用于机器学习原子间势的以原子为中心的径向描述符，其定义为 $G(r) = \\phi(r)\\,f_c(r)$，其中 $r$ 是中心原子与其相邻原子之间的标量原子间距，$\\phi(r)$ 是一个光滑的径向基，而 $f_c(r)$ 是一个截断函数，它通过在有限的截断距离 $r_c$ 处将贡献逐渐削减至零来强制实现局域性。这种构造在 Atom-Centered Symmetry Functions (ACSF) 中是标准的，并且也类似于 Smooth Overlap of Atomic Positions (SOAP) 中使用的局域化核函数。\n\n假设径向基为高斯函数 $\\phi(r) = \\exp\\!\\left(-\\eta\\,(r - R_s)^2\\right)$，其参数为 $\\eta  0$ 和 $R_s \\ge 0$。截断函数 $f_c(r)$ 从三类中选择，每一类在截断点 $r = r_c$ 处具有不同的光滑度：\n\n1. $C^0$ 连续线性锥削函数：\n   $$ f_c^{(0)}(r) = \\begin{cases} 1 - \\dfrac{r}{r_c},  0 \\le r  r_c, \\\\ 0,  r \\ge r_c. \\end{cases} $$\n   此函数是连续的，且有 $f_c^{(0)}(r_c)=0$，但其一阶导数在 $r_c$ 处不连续。\n\n2. $C^1$ 连续余弦锥削函数：\n   $$ f_c^{(1)}(r) = \\begin{cases} \\dfrac{1}{2}\\left[1 + \\cos\\!\\left(\\dfrac{\\pi\\,r}{r_c}\\right)\\right],  0 \\le r \\le r_c, \\\\ 0,  r \\ge r_c. \\end{cases} $$\n   此函数及其一阶导数在 $r_c$ 处均连续，且有 $f_c^{(1)}(r_c)=0$ 和 $\\dfrac{d}{dr}f_c^{(1)}(r_c)=0$。\n\n3. $C^\\infty$ 光滑紧支撑凸包函数：\n   $$ f_c^{(\\infty)}(r) = \\begin{cases} \\exp\\!\\left(-\\dfrac{r^2}{r_c^2 - r^2}\\right),  0 \\le r  r_c, \\\\ 0,  r \\ge r_c. \\end{cases} $$\n   此函数是无穷次可微的，在截断点处有 $f_c^{(\\infty)}(r_c)=0$，并且所有阶导数从左侧趋近时都等于零；从右侧看，它恒等于零。\n\n从单变量微积分的基本法则（包括乘法法则和链式法则）出发，为每种 $f_c(r) \\in \\{f_c^{(0)}, f_c^{(1)}, f_c^{(\\infty)}\\}$ 的选择，推导径向导数 $\\dfrac{\\partial G}{\\partial r}$ 在 $r=r_c$ 处的左极限和右极限的解析表达式。通过跳变幅度明确地量化导数的不连续性\n$$ \\Delta\\left(\\dfrac{\\partial G}{\\partial r}\\right)\\Big|_{r_c} \\equiv \\left|\\lim_{r \\to r_c^-} \\dfrac{\\partial G}{\\partial r} - \\lim_{r \\to r_c^+} \\dfrac{\\partial G}{\\partial r}\\right|. $$\n\n为了将导数的不连续性与分子动力学 (MD) 的稳定性联系起来，考虑一个简单的能量映射 $E(G) = a\\,G$，其中 $a$ 是一个常系数（为归一化，设 $a=1$）。径向力投影为 $F_r = -\\dfrac{\\partial E}{\\partial r} = -\\dfrac{\\partial G}{\\partial r}$。使用 $\\dfrac{\\partial G}{\\partial r}$ 在 $r_c$ 处的跳变幅度作为力噪声的代理，并定义一个稳定性判据：如果 $\\Delta\\!\\left(\\dfrac{\\partial G}{\\partial r}\\right)\\big|_{r_c} \\le T$，则对于给定的截断函数选择，MD 被认为是稳定的，其中 $T$ 是为每个测试用例提供的预设阈值。\n\n你的程序必须实现这些推导，并为每个提供的测试用例计算所有三类截断函数的跳变幅度以及在给定阈值下的相应稳定性布尔值。此问题中的所有量均为无量纲。\n\n测试套件参数是元组 $(\\eta, R_s, r_c, T)$：\n\n- 用例 1 (一般情况，截断点附近有不可忽略的重叠)：$(\\eta=2.0, R_s=4.5, r_c=5.0, T=0.05)$。\n- 用例 2 (基函数中心远离截断点，强衰减)：$(\\eta=10.0, R_s=0.0, r_c=5.0, T=10^{-8})$。\n- 用例 3 (基函数中心位于截断点，较小的 $r_c$)：$(\\eta=0.5, R_s=1.0, r_c=1.0, T=0.5)$。\n- 用例 4 (基函数中心位于截断点，较大的 $r_c$)：$(\\eta=1.0, R_s=8.0, r_c=8.0, T=0.2)$。\n\n最终输出格式要求：你的程序应生成单行输出，包含一个列表的列表，其中每个内部列表对应一个测试用例，并按\n$$[\\Delta_0,\\ \\Delta_1,\\ \\Delta_\\infty,\\ \\text{stable}_0,\\ \\text{stable}_1,\\ \\text{stable}_\\infty],$$\n的顺序列出，其中 $\\Delta_0$、$\\Delta_1$、$\\Delta_\\infty$ 分别是 $f_c^{(0)}$、$f_c^{(1)}$ 和 $f_c^{(\\infty)}$ 的跳变幅度，而 $\\text{stable}_\\ast$ 是满足给定阈值 $T$ 判据的布尔值。打印的单行必须具有精确的 Python 列表格式，例如：\n$$[[0.1,0.0,0.0,False,True,True],[\\dots]].$$",
            "solution": "该问题要求推导和计算径向描述符函数 $G(r)$ 在截断半径 $r_c$ 处一阶导数的不连续性。此不连续性用于评估分子动力学模拟中相应简化力模型的数值稳定性。\n\n径向描述符由乘积 $G(r) = \\phi(r) f_c(r)$ 给出，其中径向基是高斯函数 $\\phi(r) = \\exp(-\\eta(r - R_s)^2)$，$f_c(r)$ 是三种指定的截断函数之一。\n\n首先，我们推导 $G(r)$ 关于原子间距 $r$ 的导数的一般表达式。根据微分的乘法法则，我们有：\n$$ \\frac{\\partial G}{\\partial r} = \\frac{\\partial}{\\partial r} \\left[ \\phi(r) f_c(r) \\right] = \\frac{\\partial \\phi}{\\partial r} f_c(r) + \\phi(r) \\frac{\\partial f_c}{\\partial r} $$\n高斯基函数 $\\phi(r)$ 的导数可通过链式法则求得：\n$$ \\frac{\\partial \\phi}{\\partial r} = \\frac{d}{dr} \\left( -\\eta(r-R_s)^2 \\right) \\cdot \\exp\\!\\left(-\\eta(r - R_s)^2\\right) = -2\\eta(r-R_s) \\exp\\!\\left(-\\eta(r - R_s)^2\\right) $$\n我们记 $\\phi'(r) \\equiv \\frac{\\partial \\phi}{\\partial r}$ 和 $f_c'(r) \\equiv \\frac{\\partial f_c}{\\partial r}$。那么描述符的导数是：\n$$ \\frac{\\partial G}{\\partial r} = \\phi'(r) f_c(r) + \\phi(r) f_c'(r) $$\n该导数在 $r=r_c$ 处的不连续性，或称跳变幅度，定义为：\n$$ \\Delta\\left(\\dfrac{\\partial G}{\\partial r}\\right)\\Big|_{r_c} = \\left|\\lim_{r \\to r_c^-} \\dfrac{\\partial G}{\\partial r} - \\lim_{r \\to r_c^+} \\dfrac{\\partial G}{\\partial r}\\right| $$\n我们必须为每种情况计算左极限和右极限。\n\n对于所有三种截断函数，当 $r \\ge r_c$ 时，$f_c(r) = 0$。这意味着对于 $r  r_c$，$f_c(r)$ 是一个常数函数，其导数 $f_c'(r)$ 也为 $0$。因此，对于 $r  r_c$，描述符 $G(r) = \\phi(r) \\cdot 0 = 0$，其导数 $\\frac{\\partial G}{\\partial r}$ 也为 $0$。所以，右极限普遍为零：\n$$ \\lim_{r \\to r_c^+} \\dfrac{\\partial G}{\\partial r} = \\lim_{r \\to r_c^+} 0 = 0 $$\n跳变幅度简化为左极限的绝对值：\n$$ \\Delta\\left(\\dfrac{\\partial G}{\\partial r}\\right)\\Big|_{r_c} = \\left|\\lim_{r \\to r_c^-} \\dfrac{\\partial G}{\\partial r}\\right| $$\n现在我们为三种截断函数中的每一种计算这个极限。\n\n1.  **$C^0$ 连续线性锥削函数, $f_c^{(0)}(r)$**：\n    对于 $0 \\le r  r_c$，我们有 $f_c^{(0)}(r) = 1 - \\frac{r}{r_c}$，其导数为 $f_c^{(0)'}(r) = -\\frac{1}{r_c}$。\n    描述符在 $r  r_c$ 时的导数为：\n    $$ \\frac{\\partial G^{(0)}}{\\partial r} = \\phi'(r) \\left(1 - \\frac{r}{r_c}\\right) + \\phi(r) \\left(-\\frac{1}{r_c}\\right) $$\n    我们取 $r \\to r_c^-$ 的极限。由于 $\\phi(r)$ 和 $\\phi'(r)$ 是连续函数，我们可以直接代入 $r=r_c$：\n    $$ \\lim_{r \\to r_c^-} \\frac{\\partial G^{(0)}}{\\partial r} = \\phi'(r_c) \\left(1 - \\frac{r_c}{r_c}\\right) - \\frac{\\phi(r_c)}{r_c} = \\phi'(r_c) \\cdot 0 - \\frac{\\phi(r_c)}{r_c} = -\\frac{\\phi(r_c)}{r_c} $$\n    跳变幅度 $\\Delta_0$ 为：\n    $$ \\Delta_0 = \\left|-\\frac{\\phi(r_c)}{r_c}\\right| = \\frac{\\phi(r_c)}{r_c} = \\frac{\\exp(-\\eta(r_c-R_s)^2)}{r_c} $$\n    导数是不连续的，因为尽管 $\\lim_{r \\to r_c^-} f_c^{(0)}(r) = 0$，但其导数 $\\lim_{r \\to r_c^-} f_c^{(0)'}(r) = -1/r_c$ 不为零，这在乘法法则展开式的第二项中造成了不连续性。\n\n2.  **$C^1$ 连续余弦锥削函数, $f_c^{(1)}(r)$**：\n    对于 $0 \\le r \\le r_c$，我们有 $f_c^{(1)}(r) = \\frac{1}{2}\\left[1 + \\cos\\left(\\frac{\\pi r}{r_c}\\right)\\right]$。其导数为 $f_c^{(1)'}(r) = -\\frac{\\pi}{2r_c}\\sin\\left(\\frac{\\pi r}{r_c}\\right)$。\n    描述符在 $r \\le r_c$ 时的导数为：\n    $$ \\frac{\\partial G^{(1)}}{\\partial r} = \\phi'(r) \\cdot \\frac{1}{2}\\left[1 + \\cos\\left(\\frac{\\pi r}{r_c}\\right)\\right] - \\phi(r) \\cdot \\frac{\\pi}{2r_c}\\sin\\left(\\frac{\\pi r}{r_c}\\right) $$\n    取 $r \\to r_c^-$ 的极限：\n    $$ \\lim_{r \\to r_c^-} \\frac{\\partial G^{(1)}}{\\partial r} = \\phi'(r_c) \\cdot \\frac{1}{2}\\left[1 + \\cos(\\pi)\\right] - \\phi(r_c) \\cdot \\frac{\\pi}{2r_c}\\sin(\\pi) $$\n    $$ = \\phi'(r_c) \\cdot \\frac{1}{2}\\left[1 - 1\\right] - \\phi(r_c) \\cdot \\frac{\\pi}{2r_c} \\cdot 0 = \\phi'(r_c) \\cdot 0 - \\phi(r_c) \\cdot 0 = 0 $$\n    跳变幅度 $\\Delta_1$ 为：\n    $$ \\Delta_1 = |0 - 0| = 0 $$\n    导数是连续的，这对于一个光滑函数 $\\phi(r)$ 和一个 $C^1$ 连续函数 $f_c^{(1)}(r)$ 的乘积是符合预期的，因为后者的函数值及其一阶导数在 $r_c$ 处均为零。\n\n3.  **$C^\\infty$ 光滑紧支撑凸包函数, $f_c^{(\\infty)}(r)$**：\n    对于 $0 \\le r  r_c$，$f_c^{(\\infty)}(r) = \\exp\\left(-\\frac{r^2}{r_c^2 - r^2}\\right)$。此函数的构造使其在其定义域上无穷次可微，并且所有阶导数从左侧趋近 $r=r_c$ 时均为零。\n    让我们对一阶导数证实这一点。对于 $r  r_c$，$f_c^{(\\infty)'}(r) = f_c^{(\\infty)}(r) \\left( -\\frac{2rr_c^2}{(r_c^2 - r^2)^2} \\right)$。\n    当 $r \\to r_c^-$ 时，此表达式的极限由指数项主导，该指数项趋于零的速度比任何多项式项发散的速度都快。因此，$\\lim_{r \\to r_c^-} f_c^{(\\infty)}(r) = 0$ 且 $\\lim_{r \\to r_c^-} f_c^{(\\infty)'}(r) = 0$。\n    描述符在 $r  r_c$ 时的导数为：\n    $$ \\frac{\\partial G^{(\\infty)}}{\\partial r} = \\phi'(r) f_c^{(\\infty)}(r) + \\phi(r) f_c^{(\\infty)'}(r) $$\n    取 $r \\to r_c^-$ 的极限：\n    $$ \\lim_{r \\to r_c^-} \\frac{\\partial G^{(\\infty)}}{\\partial r} = \\phi'(r_c) \\cdot \\lim_{r \\to r_c^-} f_c^{(\\infty)}(r) + \\phi(r_c) \\cdot \\lim_{r \\to r_c^-} f_c^{(\\infty)'}(r) $$\n    $$ = \\phi'(r_c) \\cdot 0 + \\phi(r_c) \\cdot 0 = 0 $$\n    跳变幅度 $\\Delta_\\infty$ 为：\n    $$ \\Delta_\\infty = |0 - 0| = 0 $$\n    导数是连续的，这对于涉及 $C^\\infty$ 函数的乘积是符合预期的。\n\n总之，跳变幅度的公式为：\n-   $\\Delta_0 = \\frac{1}{r_c} \\exp(-\\eta(r_c-R_s)^2)$\n-   $\\Delta_1 = 0$\n-   $\\Delta_\\infty = 0$\n\n每种截断函数选择的稳定性判据是通过将其跳变幅度与阈值 $T$ 进行比较来确定的。如果 $\\Delta \\le T$，则模拟是稳定的。对于 $C^1$ 和 $C^\\infty$ 截断函数，跳变幅度始终为零，因此对于任何非负阈值 $T$，它们将始终满足稳定性判据。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the derivative discontinuity for different cutoff functions\n    and assesses the stability for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (eta, Rs, rc, T)\n    test_cases = [\n        (2.0, 4.5, 5.0, 0.05),\n        (10.0, 0.0, 5.0, 1e-8),\n        (0.5, 1.0, 1.0, 0.5),\n        (1.0, 8.0, 8.0, 0.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        eta, Rs, rc, T = case\n\n        # --- Calculate jump magnitudes ---\n\n        # Case 0: C^0-continuous linear taper\n        # Formula: Delta_0 = exp(-eta * (rc - Rs)^2) / rc\n        phi_rc = np.exp(-eta * (rc - Rs)**2)\n        delta_0 = phi_rc / rc\n        \n        # Case 1: C^1-continuous cosine taper\n        # Formula: Delta_1 = 0\n        delta_1 = 0.0\n        \n        # Case 2: C^infinity-smooth bump function\n        # Formula: Delta_inf = 0\n        delta_inf = 0.0\n\n        # --- Apply stability criterion ---\n        # Stability is True if Delta = T\n        stable_0 = delta_0 = T\n        stable_1 = delta_1 = T\n        stable_inf = delta_inf = T\n\n        # Append the list of results for this case\n        case_result = [delta_0, delta_1, delta_inf, stable_0, stable_1, stable_inf]\n        results.append(case_result)\n\n    # --- Format the final output string ---\n    # The output format must exactly match \"[[val,val,...],[val,val,...]]\"\n    # with no spaces after commas. Python's default str() on lists adds spaces,\n    # so we manually construct the string to meet the requirement.\n    \n    # Collect string representations of each inner list\n    output_parts = []\n    for res_list in results:\n        # res_list contains: [float, float, float, bool, bool, bool]\n        # Convert each element to its string representation\n        # Note: str(True) is \"True\", str(False) is \"False\"\n        list_items_as_strings = [\n            f\"{res_list[0]}\",\n            f\"{res_list[1]}\",\n            f\"{res_list[2]}\",\n            str(res_list[3]),\n            str(res_list[4]),\n            str(res_list[5]),\n        ]\n        \n        # Join items with comma and wrap in brackets for this case\n        inner_list_str = f\"[{','.join(list_items_as_strings)}]\"\n        output_parts.append(inner_list_str)\n\n    # Join the string representations of all cases with a comma\n    # and wrap in outer brackets to form the final string\n    final_output_string = f\"[{','.join(output_parts)}]\"\n\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}