{
    "hands_on_practices": [
        {
            "introduction": "在分子模拟中，为了提高计算效率，通常会对粒子间的相互作用势进行截断。然而，这种截断会引入系统误差，影响相平衡性质计算的准确性。本练习将指导您推导并量化用于补偿势函数截断部分影响的“长程校正”，这是获得精确相平衡数据的关键一步 。",
            "id": "3454569",
            "problem": "考虑一个单组分流体的两相吉布斯系综蒙特卡洛 (GEMC) 模拟，该流体通过 Lennard-Jones 对势相互作用。Lennard-Jones 势定义为 $u(r) = 4\\epsilon\\left[\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^6\\right]$, 其中 $\\epsilon$ 设定能量标度，$\\sigma$ 设定长度标度。在实际模拟中，势能在截断距离 $r_c$ 处被截断，并且通常会添加长程校正来补偿 $r>r_c$ 范围内的被忽略的贡献。在本问题中，您将通过为两个分别具有数密度 $\\rho_1$ 和 $\\rho_2$ 的盒子推导和实现尾部校正，来量化当省略长程校正时共存性质中的偏差。\n\n从以下适用于超出截断距离 $r_c$ 后径向分布函数 $g(r)=1$ 的均匀流体的、经过充分检验的基本公式出发：\n- 单位体积的势能由 $U/V = \\dfrac{1}{2}\\rho^2 \\int u(r)\\, 4\\pi r^2\\,dr$ 给出。\n- 对压力的维里贡献由 $P_{\\text{vir}} = -\\dfrac{2\\pi}{3}\\rho^2 \\int r^3\\dfrac{du}{dr}\\,dr$ 给出。\n- 在 Widom 插入图像中，过剩化学势由 $\\mu_{\\text{ex}} = -k_{\\text{B}}T\\ln\\left\\langle e^{-\\Delta U/k_{\\text{B}}T}\\right\\rangle$ 给出；在对超出 $r_c$ 的尾部进行平均场近似时，插入能贡献简化为 $u(r)$ 对 $4\\pi r^2$ 的均匀积分，并由密度 $\\rho$ 加权。\n\n您的任务：\n1. 假设在 $r\\in[r_c,\\infty)$ 范围内 $g(r)=1$，推导出来自该范围贡献的单位体积势能的尾部校正 $U_{\\text{tail}}/V$。用 $\\rho$、$\\epsilon$、$\\sigma$ 和 $r_c$ 表示。\n2. 假设 $g(r)=1$，从 $r\\in[r_c,\\infty)$ 的维里表达式推导对压力的尾部校正 $P_{\\text{tail}}$。\n3. 通过考虑一个测试粒子与密度为 $\\rho$ 的均匀流体中超出 $r_c$ 范围的粒子之间的平均场插入能，推导对过剩化学势的尾部校正 $\\mu_{\\text{tail}}$。\n4. 解释在 GEMC 中，盒子间截断（未校正）压力和截断（未校正）化学势的均等化如何意味着真实压力和真实化学势会因尾部校正的差异而不同。将共存偏差定义为 $\\Delta P_{\\text{bias}} = P_{\\text{tail}}(\\rho_1) - P_{\\text{tail}}(\\rho_2)$ 和 $\\Delta \\mu_{\\text{bias}} = \\mu_{\\text{tail}}(\\rho_1) - \\mu_{\\text{tail}}(\\rho_2)$。\n5. 实现一个程序，该程序对每个测试用例，使用您推导的公式计算每个盒子中单位体积的尾部能量以及共存偏差 $\\Delta P_{\\text{bias}}$ 和 $\\Delta \\mu_{\\text{bias}}$。所有量都必须根据所提供的 $\\epsilon$ 和 $\\sigma$ 值，以约化的 Lennard-Jones 单位报告（即，能量以 $\\epsilon$ 为单位，长度以 $\\sigma$ 为单位，密度以 $\\sigma^{-3}$ 为单位）。不涉及角度或百分比。\n\n测试套件（每个用例指定 $(\\epsilon,\\sigma,r_c,\\rho_1,\\rho_2)$）：\n- 用例 A: $(\\epsilon, \\sigma, r_c, \\rho_1, \\rho_2) = (1, 1, 2.5, 0.8, 0.02)$。\n- 用例 B: $(\\epsilon, \\sigma, r_c, \\rho_1, \\rho_2) = (1, 1, 5.0, 0.7, 0.02)$。\n- 用例 C (边界情况，密度相等): $(\\epsilon, \\sigma, r_c, \\rho_1, \\rho_2) = (1, 1, 2.5, 0.5, 0.5)$。\n- 用例 D (短截断，偏差更强): $(\\epsilon, \\sigma, r_c, \\rho_1, \\rho_2) = (1, 1, 1.5, 0.85, 0.01)$。\n\n对于每个测试用例，您的程序必须输出一个包含四个浮点数的列表：\n- $U_{\\text{tail}}(\\rho_1)/V$,\n- $U_{\\text{tail}}(\\rho_2)/V$,\n- $\\Delta P_{\\text{bias}}$,\n- $\\Delta \\mu_{\\text{bias}}$.\n\n最终输出格式：您的程序应生成单行输出，其中包含一个以逗号分隔的列表，列表被方括号括起，其中每个元素对应一个测试用例，并且本身是上述指定的四个浮点数的列表（例如，$[[x_{A1},x_{A2},x_{A3},x_{A4}],[x_{B1},x_{B2},x_{B3},x_{B4}],\\dots]$）。",
            "solution": "在尝试解答之前，需对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **系统**: 一个单组分流体的两相吉布斯系综蒙特卡洛 (GEMC) 模拟。\n- **相互作用势**: Lennard-Jones 势, $u(r) = 4\\epsilon\\left[\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^6\\right]$。\n- **参数**: $\\epsilon$ (能量标度), $\\sigma$ (长度标度)。\n- **模拟协议**: 势能在截断距离 $r_c$ 处被截断。\n- **目标**: 为两个分别具有数密度 $\\rho_1$ 和 $\\rho_2$ 的盒子，量化当省略长程校正时共存性质中的偏差。\n- **近似**: 对于距离 $r > r_c$, 径向分布函数 $g(r)=1$。\n- **基本公式**:\n    - 单位体积势能: $U/V = \\dfrac{1}{2}\\rho^2 \\int u(r)\\, 4\\pi r^2\\,dr$。\n    - 对压力的维里贡献: $P_{\\text{vir}} = -\\dfrac{2\\pi}{3}\\rho^2 \\int r^3\\dfrac{du}{dr}\\,dr$。\n    - 过剩化学势 (平均场尾部): 插入能贡献是 $u(r)$ 对 $4\\pi r^2$ 的均匀积分，并由密度 $\\rho$ 加权。\n- **任务**:\n    1. 推导单位体积势能的尾部校正, $U_{\\text{tail}}/V$。\n    2. 推导压力的尾部校正, $P_{\\text{tail}}$。\n    3. 推导过剩化学势的尾部校正, $\\mu_{\\text{tail}}$。\n    4. 解释 GEMC 中共存偏差 $\\Delta P_{\\text{bias}}$ 和 $\\Delta \\mu_{\\text{bias}}$ 的来源。\n    5. 实现一个程序来计算 $U_{\\text{tail}}(\\rho_1)/V$, $U_{\\text{tail}}(\\rho_2)/V$, $\\Delta P_{\\text{bias}}$, 和 $\\Delta \\mu_{\\text{bias}}$。\n- **单位**: 所有量都以基于 $\\epsilon$ 和 $\\sigma$ 的约化 Lennard-Jones 单位表示。\n- **测试用例**:\n    - 用例 A: $(\\epsilon, \\sigma, r_c, \\rho_1, \\rho_2) = (1, 1, 2.5, 0.8, 0.02)$。\n    - 用例 B: $(\\epsilon, \\sigma, r_c, \\rho_1, \\rho_2) = (1, 1, 5.0, 0.7, 0.02)$。\n    - 用例 C: $(\\epsilon, \\sigma, r_c, \\rho_1, \\rho_2) = (1, 1, 2.5, 0.5, 0.5)$。\n    - 用例 D: $(\\epsilon, \\sigma, r_c, \\rho_1, \\rho_2) = (1, 1, 1.5, 0.85, 0.01)$。\n- **输出格式**: 单行，包含每个测试用例的四个浮点数的列表的列表：$[[U_{\\text{tail}}(\\rho_1)/V, U_{\\text{tail}}(\\rho_2)/V, \\Delta P_{\\text{bias}}, \\Delta \\mu_{\\text{bias}}]_{\\text{A}}, \\dots]$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估：\n- **科学依据**: 该问题是一个统计力学和计算物理学中的标准练习。它涉及 Lennard-Jones 流体、吉布斯系综模拟以及长程校正的推导，所有这些都是基本且成熟的概念。对于 $r > r_c$ 假设 $g(r)=1$ 是这些推导的标准平均场近似。\n- **定义明确**: 问题被明确指定。它要求推导特定的物理量，并随后对一组给定参数进行数值计算。任务明确，可得出唯一解。\n- **客观性**: 语言技术性强且精确，没有任何主观或有偏见的陈述。\n- **缺陷检查**: 该问题不违反任何无效性标准。它在科学上是合理的、可形式化的、完整的，并提出了一个在计算科学中虽非微不足道但可解决的挑战。\n\n### 步骤 3：结论与行动\n问题是有效的。将提供分步解答。\n\n---\n\n推导将使用约化的 Lennard-Jones 单位进行，其中能量以 $\\epsilon$ 为单位表示，长度以 $\\sigma$ 为单位，密度 $\\rho^*$ 以 $\\sigma^{-3}$ 为单位，依此类推。测试用例提供了 $\\epsilon=1$ 和 $\\sigma=1$，因此给定的 $r_c$ 和 $\\rho$ 的数值已经是适当的约化单位。为简洁起见，约化量上的星号将被省略。约化的 Lennard-Jones 势为：\n$$\nu(r) = 4\\left(r^{-12} - r^{-6}\\right)\n$$\n\n**1. 单位体积势能的尾部校正 $U_{\\text{tail}}/V$ 的推导**\n\n单位体积势能的尾部校正是来自距离 $r \\in [r_c, \\infty)$ 处相互作用的贡献。使用提供的公式和在该范围内 $g(r)=1$ 的假设：\n$$\n\\frac{U_{\\text{tail}}}{V} = \\frac{1}{2}\\rho^2 \\int_{r_c}^{\\infty} u(r) \\, 4\\pi r^2 \\, dr\n$$\n代入 Lennard-Jones 势：\n$$\n\\frac{U_{\\text{tail}}}{V} = \\frac{1}{2}\\rho^2 \\int_{r_c}^{\\infty} 4\\left(r^{-12} - r^{-6}\\right) \\, 4\\pi r^2 \\, dr = 8\\pi\\rho^2 \\int_{r_c}^{\\infty} \\left(r^{-10} - r^{-4}\\right) \\, dr\n$$\n进行积分：\n$$\n\\int \\left(r^{-10} - r^{-4}\\right) \\, dr = \\frac{r^{-9}}{-9} - \\frac{r^{-3}}{-3} = -\\frac{1}{9}r^{-9} + \\frac{1}{3}r^{-3}\n$$\n计算从 $r_c$ 到 $\\infty$ 的定积分：\n$$\n\\left[-\\frac{1}{9}r^{-9} + \\frac{1}{3}r^{-3}\\right]_{r_c}^{\\infty} = (0 - 0) - \\left(-\\frac{1}{9}r_c^{-9} + \\frac{1}{3}r_c^{-3}\\right) = \\frac{1}{9}r_c^{-9} - \\frac{1}{3}r_c^{-3}\n$$\n因此，单位体积势能的尾部校正的最终表达式为：\n$$\n\\frac{U_{\\text{tail}}}{V}(\\rho, r_c) = 8\\pi\\rho^2 \\left(\\frac{1}{9r_c^9} - \\frac{1}{3r_c^3}\\right)\n$$\n\n**2. 压力尾部校正 $P_{\\text{tail}}$ 的推导**\n\n压力的尾部校正来自于 $r \\in [r_c, \\infty)$ 的维里贡献。首先，我们求势的导数：\n$$\n\\frac{du}{dr} = 4\\left(-12r^{-13} + 6r^{-7}\\right)\n$$\n压力的尾部贡献则为：\n$$\nP_{\\text{tail}} = -\\frac{2\\pi}{3}\\rho^2 \\int_{r_c}^{\\infty} r^3 \\frac{du}{dr} \\, dr = -\\frac{2\\pi}{3}\\rho^2 \\int_{r_c}^{\\infty} r^3 \\cdot 4\\left(-12r^{-13} + 6r^{-7}\\right) \\, dr\n$$\n$$\nP_{\\text{tail}} = -\\frac{8\\pi}{3}\\rho^2 \\int_{r_c}^{\\infty} \\left(-12r^{-10} + 6r^{-4}\\right) \\, dr\n$$\n对表达式进行积分：\n$$\n\\int \\left(-12r^{-10} + 6r^{-4}\\right) \\, dr = -12\\frac{r^{-9}}{-9} + 6\\frac{r^{-3}}{-3} = \\frac{4}{3}r^{-9} - 2r^{-3}\n$$\n计算定积分：\n$$\n\\left[\\frac{4}{3}r^{-9} - 2r^{-3}\\right]_{r_c}^{\\infty} = (0 - 0) - \\left(\\frac{4}{3}r_c^{-9} - 2r_c^{-3}\\right) = 2r_c^{-3} - \\frac{4}{3}r_c^{-9}\n$$\n将其代回，压力的尾部校正为：\n$$\nP_{\\text{tail}}(\\rho, r_c) = -\\frac{8\\pi}{3}\\rho^2 \\left(2r_c^{-3} - \\frac{4}{3}r_c^{-9}\\right) = \\frac{32\\pi}{9}\\rho^2 r_c^{-9} - \\frac{16\\pi}{3}\\rho^2 r_c^{-3}\n$$\n\n**3. 化学势尾部校正 $\\mu_{\\text{tail}}$ 的推导**\n\n根据 Widom 测试粒子方法，在平均场近似下（即 $g(r)=1$），过剩化学势的尾部校正是将一个测试粒子插入到密度为 $\\rho$ 的均匀流体中时，该粒子与所有距离大于 $r_c$ 的粒子之间的相互作用能。\n$$\n\\mu_{\\text{tail}} = \\int_{r_c}^{\\infty} u(r) \\rho g(r) \\, 4\\pi r^2 \\, dr = \\rho \\int_{r_c}^{\\infty} u(r) \\, 4\\pi r^2 \\, dr\n$$\n我们需要计算积分 $\\int_{r_c}^{\\infty} u(r) \\, 4\\pi r^2 \\, dr$。\n$$\n\\int_{r_c}^{\\infty} 4\\left(r^{-12} - r^{-6}\\right) 4\\pi r^2 dr = 16\\pi \\int_{r_c}^{\\infty} \\left(r^{-10} - r^{-4}\\right) dr\n$$\n使用与能量校正中相同的积分计算：\n$$\n\\int_{r_c}^{\\infty} \\left(r^{-10} - r^{-4}\\right) dr = \\left[-\\frac{1}{9}r^{-9} + \\frac{1}{3}r^{-3}\\right]_{r_c}^{\\infty} = \\frac{1}{9}r_c^{-9} - \\frac{1}{3}r_c^{-3}\n$$\n因此，过剩化学势的尾部校正为：\n$$\n\\mu_{\\text{tail}}(\\rho, r_c) = 16\\pi\\rho \\left(\\frac{1}{9r_c^9} - \\frac{1}{3r_c^3}\\right)\n$$\n该结果与每个粒子的能量尾部贡献的两倍是一致的，即 $\\mu_{\\text{tail}} = 2 \\times (U_{\\text{tail}}/N)$，因为 $U_{\\text{tail}}/N = \\frac{1}{2}\\rho \\int_{r_c}^{\\infty} u(r) 4\\pi r^2 dr$。\n\n**4. GEMC 中的共存偏差**\n\n在 GEMC 模拟中，两相（例如，盒子 1 中的液体，盒子 2 中的蒸气）之间的平衡要求温度、压力和化学势相等：$T_1=T_2$，$P_1=P_2$ 和 $\\mu_1=\\mu_2$。模拟算法强制执行这些条件。\n当使用没有长程校正的截断势时，算法实际上是使*截断*性质相等，这些性质是仅从 $r \\le r_c$ 的势计算得出的。让它们表示为 $P_{\\text{trunc}}$ 和 $\\mu_{\\text{trunc}}$。因此，在收敛时，模拟建立了：\n$$\nP_{1, \\text{trunc}} = P_{2, \\text{trunc}} \\quad \\text{和} \\quad \\mu_{1, \\text{trunc}} = \\mu_{2, \\text{trunc}}\n$$\n真实的物理性质是截断部分和尾部校正的总和：\n$$\nP_{\\text{true}}(\\rho) = P_{\\text{trunc}}(\\rho) + P_{\\text{tail}}(\\rho)\n$$\n$$\n\\mu_{\\text{true}}(\\rho) = \\mu_{\\text{trunc}}(\\rho) + \\mu_{\\text{tail}}(\\rho)\n$$\n因此，两个盒子之间*真实*压力的差异是：\n$$\n\\Delta P = P_{1, \\text{true}} - P_{2, \\text{true}} = \\left(P_{1, \\text{trunc}} + P_{\\text{tail}}(\\rho_1)\\right) - \\left(P_{2, \\text{trunc}} + P_{\\text{tail}}(\\rho_2)\\right)\n$$\n由于 $P_{1, \\text{trunc}} = P_{2, \\text{trunc}}$，这简化为压力偏差：\n$$\n\\Delta P_{\\text{bias}} = P_{\\text{tail}}(\\rho_1) - P_{\\text{tail}}(\\rho_2)\n$$\n同样地，*真实*化学势的差异是：\n$$\n\\Delta \\mu = \\mu_{1, \\text{true}} - \\mu_{2, \\text{true}} = \\left(\\mu_{1, \\text{trunc}} + \\mu_{\\text{tail}}(\\rho_1)\\right) - \\left(\\mu_{2, \\text{trunc}} + \\mu_{\\text{tail}}(\\rho_2)\\right)\n$$\n由于 $\\mu_{1, \\text{trunc}} = \\mu_{2, \\text{trunc}}$，这简化为化学势偏差：\n$$\n\\Delta \\mu_{\\text{bias}} = \\mu_{\\text{tail}}(\\rho_1) - \\mu_{\\text{tail}}(\\rho_2)\n$$\n因为尾部校正 $P_{\\text{tail}}$ 和 $\\mu_{\\text{tail}}$ 是密度（分别为 $\\rho^2$ 和 $\\rho$）的函数，并且共存相具有不同的密度（$\\rho_1 \\neq \\rho_2$），所以尾部校正不相等。这导致了系统性误差或偏差，即模拟系统没有达到真正的力学和化学平衡。\n\n**5. 实现**\n以下 Python 代码实现了推导出的公式，并为给定的测试用例计算所需的量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef u_tail_per_v(rho, rc):\n    \"\"\"\n    Calculates the tail correction to the potential energy per unit volume\n    in reduced Lennard-Jones units.\n    Formula: U_tail/V = 8 * pi * rho^2 * (1/9 * rc^-9 - 1/3 * rc^-3)\n    \"\"\"\n    rc_inv3 = 1.0 / (rc**3)\n    rc_inv9 = 1.0 / (rc**9)\n    return 8.0 * np.pi * rho**2 * (rc_inv9 / 9.0 - rc_inv3 / 3.0)\n\ndef p_tail(rho, rc):\n    \"\"\"\n    Calculates the tail correction to the pressure in reduced\n    Lennard-Jones units.\n    Formula: P_tail = (32*pi/9 * rc^-9 - 16*pi/3 * rc^-3) * rho^2\n    \"\"\"\n    rc_inv3 = 1.0 / (rc**3)\n    rc_inv9 = 1.0 / (rc**9)\n    term1 = (32.0 * np.pi / 9.0) * rc_inv9\n    term2 = -(16.0 * np.pi / 3.0) * rc_inv3\n    return (term1 + term2) * rho**2\n\ndef mu_tail(rho, rc):\n    \"\"\"\n    Calculates the tail correction to the excess chemical potential in\n    reduced Lennard-Jones units.\n    Formula: mu_tail = 16 * pi * rho * (1/9 * rc^-9 - 1/3 * rc^-3)\n    \"\"\"\n    rc_inv3 = 1.0 / (rc**3)\n    rc_inv9 = 1.0 / (rc**9)\n    return 16.0 * np.pi * rho * (rc_inv9 / 9.0 - rc_inv3 / 3.0)\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the results in the\n    specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (epsilon, sigma, r_c, rho_1, rho_2)\n    # Since epsilon and sigma are 1, parameters are already in reduced units.\n    test_cases = [\n        (1, 1, 2.5, 0.8, 0.02),\n        (1, 1, 5.0, 0.7, 0.02),\n        (1, 1, 2.5, 0.5, 0.5),\n        (1, 1, 1.5, 0.85, 0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        epsilon, sigma, rc, rho1, rho2 = case\n\n        # Calculate the tail energy per unit volume for each box\n        U_tail_V1 = u_tail_per_v(rho1, rc)\n        U_tail_V2 = u_tail_per_v(rho2, rc)\n\n        # Calculate the tail pressure for each box\n        P_tail1 = p_tail(rho1, rc)\n        P_tail2 = p_tail(rho2, rc)\n        # The pressure bias is the difference in tail corrections\n        delta_P_bias = P_tail1 - P_tail2\n\n        # Calculate the tail chemical potential for each box\n        mu_tail1 = mu_tail(rho1, rc)\n        mu_tail2 = mu_tail(rho2, rc)\n        # The chemical potential bias is the difference in tail corrections\n        delta_mu_bias = mu_tail1 - mu_tail2\n\n        case_results = [U_tail_V1, U_tail_V2, delta_P_bias, delta_mu_bias]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # [[val_A1, val_A2, ...], [val_B1, val_B2, ...], ...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在解决了基本模拟的准确性问题之后，我们转向一个更复杂的场景：纳米孔中的流体。对于这类受限体系，标准的吉布斯系综蒙特卡罗（GEMC）移动可能效率不高或不适用。本练习旨在挑战您设计一种混合算法，将GEMC的粒子交换移动与巨正则蒙特卡罗（GCMC）的插入和删除移动相结合，并确保其严格遵守细致平衡原理 。这个过程将展示蒙特卡罗方法在处理复杂相平衡问题时的强大功能和灵活性。",
            "id": "3454523",
            "problem": "您需要设计并测试一个混合马尔可夫链蒙特卡罗 (MC) 方案，该方案将吉布斯系综蒙特卡罗 (GEMC) 的粒子交换与限制在多孔盒子内的巨正则系综蒙特卡罗 (GCMC) 的插入和删除相结合，用于一个简化的甲烷在纳米孔中共存的模型。计算的目标是确保该混合移动集相对于预期的稳态分布满足细致平衡，并且混合不同类型的移动不会破坏微观可逆性。\n\n考虑两个固定温度下的模拟盒子：一个多孔盒子（盒子 $1$）和一个体相盒子（盒子 $2$）。对于两个盒子，都将甲烷视为无相互作用的点粒子（理想气体）。多孔盒子受到一个空间均匀的外势作用，使得盒子 $1$ 中的每个粒子都贡献一个能量惩罚 $+\\epsilon$（其中 $\\epsilon \\ge 0$），而体相盒子没有外部贡献。使用约化单位，其中 $k_{\\mathrm B}T = 1$，因此 $\\beta = 1$，并令所有能量以相同的约化能量单位表示，所有体积以相同的约化体积单位表示。在这些单位中，将所有数值写为纯数。设化学势为标量 $\\mu$，也使用这些约化单位。\n\n定义以下混合移动类型：\n- 移动类型 S（类吉布斯交换）：在盒子 $2$ 中选择一个粒子，并提议将其移动到盒子 $1$ 中的一个均匀随机位置（反向移动类似地将粒子从盒子 $1$ 移动到盒子 $2$）。此移动在正向（盒子 $2 \\to 1$）上使 $(N_1,N_2)$ 改变 $(+1,-1)$，其中 $N_1$ 和 $N_2$ 是当前的粒子数。\n- 移动类型 G（多孔盒子中的巨正则移动）：提议在盒子 $1$ 中的一个均匀随机位置进行插入（反向是在其粒子中均匀选择一个从盒子 $1$ 中删除）。此移动在正向（插入）上使 $(N_1,N_2)$ 改变 $(+1,0)$。\n\n假设移动类型独立于状态被选择，类型 S 的固定概率为 $p_{\\mathrm S}$，类型 G 的固定概率为 $p_{\\mathrm G}$，且 $p_{\\mathrm S} + p_{\\mathrm G} = 1$。在每种类型内部，假设一个移动及其反向移动之间的方向选择概率固定为 $1/2$（对于类型 S，是盒子 $2 \\to 1$ 与盒子 $1 \\to 2$；对于类型 G，是插入与删除）。在一个特定方向内，提议概率为：\n- 对于类型 S，盒子 $2 \\to 1$：从 $N_2$ 个粒子中均匀选择一个，并在盒子 $1$ 中均匀选择一个新位置，给出与 $(1/N_2)\\,(1/V_1)$ 成正比的提议密度；反向移动使用 $(1/(N_1+1))\\,(1/V_2)$。\n- 对于类型 G，向盒子 $1$ 插入：在 $V_1$ 中均匀选择一个位置，提议密度为 $(1/V_1)$；反向删除使用 $(1/(N_1+1))$。\n\n设粒子数为 $(N_1,N_2)$ 的构型的未归一化稳态权重与下式成正比：\n$$\n\\pi(N_1,N_2) \\propto \\exp\\!\\big(-\\beta\\,U_1(N_1) - \\beta\\,U_2(N_2) + \\beta\\,\\mu\\,(N_1 + N_2)\\big),\n$$\n其中 $U_1(N_1) = \\epsilon\\,N_1$ 且 $U_2(N_2) = 0$。位置变量已被积分掉，这与理想气体和均匀外场的假设一致；您的接受概率公式必须源于在 Metropolis–Hastings 构造中使用所述提议机制的第一性原理细致平衡。\n\n任务 1. 从细致平衡原理和 Metropolis–Hastings 接受准则出发，推导以下接受概率：\n- 类型 S 的正向交换（盒子 $2 \\to 1$）及其反向交换（盒子 $1 \\to 2$），确保对于给定的 $\\pi(N_1,N_2)$ 满足细致平衡。\n- 类型 G 的正向插入（到盒子 $1$）及其反向删除（从盒子 $1$），确保对于给定的 $\\pi(N_1,N_2)$ 满足细致平衡。\n\n您的推导必须从细致平衡的定义和给定的提议密度开始，并且必须得出以 $(N_1,N_2,V_1,V_2,\\beta,\\epsilon,\\mu)$ 表示的显式接受函数。\n\n任务 2. 实现一个程序，该程序：\n- 对于给定的参数和指定的正向方向，计算正向和反向的单步转移概率 $K(x \\to y)$ 和 $K(y \\to x)$，其中 $K$ 包括类型选择概率、方向选择概率、该移动的提议概率以及推导出的 Metropolis–Hastings 接受概率。\n- 验证比率 $K(x \\to y)/K(y \\to x)$ 是否等于由给定的 $\\pi(N_1,N_2)$ 以及移动类型和方向引起的 $(N_1,N_2)$ 变化所隐含的比率 $\\pi(y)/\\pi(x)$。对于移动类型 S（盒子 $2 \\to 1$），该比率必须是 $\\exp(-\\beta\\,\\epsilon)$；对于移动类型 G（向盒子 $1$ 插入），该比率必须是 $\\exp(\\beta\\,\\mu - \\beta\\,\\epsilon)$。\n- 返回一个布尔值，指示两侧的绝对差值是否小于 $10^{-12}$ 的容差。\n\n测试套件。使用约化单位，其中 $\\beta = 1$。对于以下每种情况，计算上述布尔值。在所有情况中，使用 $p_{\\mathrm S} = 0.7$ 和 $p_{\\mathrm G} = 0.3$。\n- 情况 1（类型 S 正向，盒子 $2 \\to 1$）：$N_1 = 10$，$N_2 = 90$，$V_1 = 5.0$，$V_2 = 95.0$，$\\epsilon = 1.5$。\n- 情况 2（类型 S 正向，盒子 $2 \\to 1$）：$N_1 = 0$，$N_2 = 5$，$V_1 = 12.0$，$V_2 = 8.0$，$\\epsilon = 2.3$。\n- 情况 3（类型 G 正向，向盒子 $1$ 插入）：$N_1 = 10$，$V_1 = 5.0$，$\\epsilon = 1.5$，$\\mu = -2.0$。\n- 情况 4（类型 G 正向，向盒子 $1$ 插入）：$N_1 = 0$，$V_1 = 2.0$，$\\epsilon = 0.2$，$\\mu = 3.0$。\n- 情况 5（类型 G 正向，向盒子 $1$ 插入）：$N_1 = 50$，$V_1 = 100.0$，$\\epsilon = 4.0$，$\\mu = 1.0$。\n\n最终输出格式。您的程序应生成一行输出，其中包含对应于情况 $1$ 到 $5$ 的五个布尔值，格式为逗号分隔的列表，并用方括号括起来，例如，“[True,True,True,True,True]”。不允许有其他输出。",
            "solution": "该问题要求为一个混合的吉布斯系综蒙特卡罗 (GEMC) 和巨正则系综蒙特卡罗 (GCMC) 方案推导接受概率，并随后进行数值验证，以证明所得到的转移概率满足细致平衡原理。该系统包含两个盒子，其中有无相互作用的粒子，盒子 $1$ 中的粒子有额外的能量惩罚 $\\epsilon$。所有计算均在 $\\beta = (k_BT)^{-1} = 1$ 的约化单位下进行。\n\n此分析的基础是细致平衡条件，它指出对于构型空间中的任意两个状态 $x$ 和 $y$，平衡时的转移速率必须满足：\n$$\n\\pi(x) K(x \\to y) = \\pi(y) K(y \\to x)\n$$\n此处，$\\pi(x)$ 是状态 $x$ 的平衡概率，$K(x \\to y)$ 是从状态 $x$ 到 $y$ 的总转移概率。转移概率可以分解为提议一个移动的概率 $p_{select}(x \\to y)$ 和接受它的概率 $A(x \\to y)$：\n$$\nK(x \\to y) = p_{select}(x \\to y) A(x \\to y)\n$$\nMetropolis-Hastings 算法提供了一种保证细致平衡的接受概率选择：\n$$\nA(x \\to y) = \\min\\left(1, \\frac{\\pi(y) p_{select}(y \\to x)}{\\pi(x) p_{select}(x \\to y)}\\right)\n$$\n问题规定，选择一个移动类型（S 或 G）及其方向（例如，正向或反向）与当前状态无关，并且对于一个移动及其反向移动是对称的。也就是说，$p_{type}(x \\to y) = p_{type}(y \\to x)$ 并且 $p_{dir}(x \\to y) = p_{dir}(y \\to x)$。完整的提议概率 $p_{select}(x \\to y)$ 包括这些概率以及一个与从初始构型生成特定最终构型相关的项 $T_{prob}(x \\to y)$。\n$$\np_{select}(x \\to y) = p_{type} \\cdot p_{dir} \\cdot T_{prob}(x \\to y)\n$$\n由于 $p_{type}$ 和 $p_{dir}$ 的对称性，接受准则简化为：\n$$\nA(x \\to y) = \\min\\left(1, \\frac{\\pi(y) T_{prob}(y \\to x)}{\\pi(x) T_{prob}(x \\to y)}\\right)\n$$\n问题为宏观态 $(N_1, N_2)$ 提供了一个未归一化的稳态权重：\n$$\n\\pi(N_1, N_2) \\propto \\exp(-\\beta \\epsilon N_1 + \\beta \\mu (N_1 + N_2))\n$$\n我们使用此表达式以及给定的提议项 $T_{prob}$ 来推导接受准则。\n\n**任务 1：接受概率的推导**\n\n**移动类型 S（类吉布斯交换）**\n此移动在盒子 $1$ 和盒子 $2$ 之间转移一个粒子。\n- 正向移动 ($2 \\to 1$)：状态从 $x = (N_1, N_2)$ 变为 $y = (N_1+1, N_2-1)$。\n- 反向移动 ($1 \\to 2$)：状态从 $y = (N_1+1, N_2-1)$ 变为 $x = (N_1, N_2)$。\n提议项给定为 $T_{prob}(x \\to y) \\propto \\frac{1}{N_2 V_1}$ 和 $T_{prob}(y \\to x) \\propto \\frac{1}{(N_1+1) V_2}$。稳态权重之比为：\n$$\n\\frac{\\pi(y)}{\\pi(x)} = \\frac{\\pi(N_1+1, N_2-1)}{\\pi(N_1, N_2)} = \\frac{\\exp(-\\beta\\epsilon(N_1+1) + \\beta\\mu(N_1+1+N_2-1))}{\\exp(-\\beta\\epsilon N_1 + \\beta\\mu(N_1+N_2))} = \\exp(-\\beta\\epsilon)\n$$\n接受函数的参数 $R_S$ 为：\n$$\nR_S = \\frac{\\pi(y)}{\\pi(x)} \\frac{T_{prob}(y \\to x)}{T_{prob}(x \\to y)} = \\exp(-\\beta\\epsilon) \\frac{1/((N_1+1)V_2)}{1/(N_2 V_1)} = \\frac{N_2 V_1}{(N_1+1)V_2} \\exp(-\\beta\\epsilon)\n$$\n正向交换 ($2 \\to 1$) 的接受概率为：\n$$\nA_{S, 2 \\to 1} = \\min(1, R_S) = \\min\\left(1, \\frac{N_2 V_1}{(N_1+1)V_2} \\exp(-\\beta\\epsilon)\\right)\n$$\n反向交换 ($1 \\to 2$) 的接受概率为：\n$$\nA_{S, 1 \\to 2} = \\min(1, 1/R_S) = \\min\\left(1, \\frac{(N_1+1)V_2}{N_2 V_1} \\exp(\\beta\\epsilon)\\right)\n$$\n\n**移动类型 G（多孔盒子中的巨正则移动）**\n此移动在盒子 $1$ 中插入或删除一个粒子。\n- 正向移动（插入）：状态从 $x = (N_1, N_2)$ 变为 $y = (N_1+1, N_2)$。\n- 反向移动（删除）：状态从 $y = (N_1+1, N_2)$ 变为 $x = (N_1, N_2)$。\n提议项给定为 $T_{prob}(x \\to y) \\propto \\frac{1}{V_1}$ 和 $T_{prob}(y \\to x) \\propto \\frac{1}{N_1+1}$。稳态权重之比为：\n$$\n\\frac{\\pi(y)}{\\pi(x)} = \\frac{\\pi(N_1+1, N_2)}{\\pi(N_1, N_2)} = \\frac{\\exp(-\\beta\\epsilon(N_1+1) + \\beta\\mu(N_1+1+N_2))}{\\exp(-\\beta\\epsilon N_1 + \\beta\\mu(N_1+N_2))} = \\exp(\\beta\\mu - \\beta\\epsilon)\n$$\n接受函数的参数 $R_G$ 为：\n$$\nR_G = \\frac{\\pi(y)}{\\pi(x)} \\frac{T_{prob}(y \\to x)}{T_{prob}(x \\to y)} = \\exp(\\beta\\mu - \\beta\\epsilon) \\frac{1/(N_1+1)}{1/V_1} = \\frac{V_1}{N_1+1} \\exp(\\beta\\mu - \\beta\\epsilon)\n$$\n正向插入的接受概率为：\n$$\nA_{G, \\text{ins}} = \\min(1, R_G) = \\min\\left(1, \\frac{V_1}{N_1+1} \\exp(\\beta\\mu - \\beta\\epsilon)\\right)\n$$\n反向删除的接受概率为：\n$$\nA_{G, \\text{del}} = \\min(1, 1/R_G) = \\min\\left(1, \\frac{N_1+1}{V_1} \\exp(-\\beta\\mu + \\beta\\epsilon)\\right)\n$$\n\n**任务 2：数值验证**\n任务是验证总转移概率之比 $\\frac{K(x \\to y)}{K(y \\to x)}$ 等于稳态概率之比 $\\frac{\\pi(y)}{\\pi(x)}$。根据构造，此等式必须成立。恒等式 $\\frac{A(x \\to y)}{A(y \\to x)} = \\frac{\\pi(y) T_{prob}(y \\to x)}{\\pi(x) T_{prob}(x \\to y)}$ 保证了这一点：\n$$\n\\frac{K(x \\to y)}{K(y \\to x)} = \\frac{p_{type} p_{dir} T_{prob}(x \\to y) A(x \\to y)}{p_{type} p_{dir} T_{prob}(y \\to x) A(y \\to x)} = \\frac{T_{prob}(x \\to y)}{T_{prob}(y \\to x)} \\frac{\\pi(y) T_{prob}(y \\to x)}{\\pi(x) T_{prob}(x \\to y)} = \\frac{\\pi(y)}{\\pi(x)}\n$$\n程序将对每个测试用例，使用推导出的接受概率公式，数值计算此方程的两边，并验证它们在指定容差内的一致性。对于从初始状态 $x$ 到最终状态 $y$ 的正向移动，左边是 $K(x \\to y)$ 与 $K(y \\to x)$ 的比率，右边是解析已知的目标比率，对于类型 S 是 $\\exp(-\\beta\\epsilon)$，对于类型 G 是 $\\exp(\\beta\\mu - \\beta\\epsilon)$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and verifies detailed balance for a hybrid MC scheme.\n    \n    The function tests two types of Monte Carlo moves (S: swap, G: grand canonical)\n    for a simplified model of gas coexistence in nanopores. For each test case,\n    it calculates the forward and reverse transition probabilities K(x->y) and K(y->x).\n    It then verifies that their ratio K(x->y)/K(y->x) equals the ratio of the\n    stationary probabilities pi(y)/pi(x), as required by detailed balance.\n    \"\"\"\n    \n    # Parameters given in the problem\n    p_S = 0.7\n    p_G = 0.3\n    beta = 1.0\n    tolerance = 1e-12\n\n    # Test suite from the problem statement.\n    # Each case: (type, N1_initial, N2_initial, V1, V2, epsilon, mu)\n    # V2 or mu might be None if not used by the move type.\n    test_cases = [\n        ('S', 10, 90, 5.0, 95.0, 1.5, None),\n        ('S', 0, 5, 12.0, 8.0, 2.3, None),\n        ('G', 10, None, 5.0, None, 1.5, -2.0),\n        ('G', 0, None, 2.0, None, 0.2, 3.0),\n        ('G', 50, None, 100.0, None, 4.0, 1.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        move_type, N1, N2, V1, V2, epsilon, mu = case\n        \n        computed_ratio = 0.0\n        target_ratio = 0.0\n\n        if move_type == 'S':\n            # Type S forward move: box 2 -> 1\n            # Initial state x: (N1, N2), Final state y: (N1+1, N2-1)\n            \n            # The problem's test cases ensure N2 > 0 for this move.\n            \n            # Target ratio from stationary distribution: pi(y)/pi(x) = exp(-beta*epsilon)\n            target_ratio = np.exp(-beta * epsilon)\n\n            # Proposal factors T_prob from the problem statement\n            T_forward = 1.0 / (N2 * V1)\n            T_reverse = 1.0 / ((N1 + 1) * V2)\n\n            # Argument R for the Metropolis-Hastings acceptance rule\n            # R = (pi(y)/pi(x)) * (T_reverse / T_forward)\n            R = target_ratio * (T_reverse / T_forward) if T_forward != 0 else float('inf')\n\n            # Acceptance probabilities A(x->y) and A(y->x)\n            A_forward = min(1.0, R)\n            A_reverse = min(1.0, 1.0 / R) if R != 0 else 1.0\n\n            # Total transition probabilities K = p_type * p_direction * T_prob * A\n            # p_direction is 1/2 for both forward and reverse moves.\n            K_forward = p_S * 0.5 * T_forward * A_forward\n            K_reverse = p_S * 0.5 * T_reverse * A_reverse\n            \n            # Ratio of transition probabilities K(x->y)/K(y->x)\n            if K_reverse == 0:\n                # This should not happen with the given test cases.\n                computed_ratio = float('inf') if K_forward != 0 else 1.0\n            else:\n                computed_ratio = K_forward / K_reverse\n\n        elif move_type == 'G':\n            # Type G forward move: insertion into box 1\n            # Initial state x: (N1, N_any), Final state y: (N1+1, N_any)\n\n            # Target ratio from analytical derivation: pi(y)/pi(x) = exp(beta*mu - beta*epsilon)\n            target_ratio = np.exp(beta * mu - beta * epsilon)\n\n            # Proposal factors T_prob\n            T_forward = 1.0 / V1          # Insertion\n            T_reverse = 1.0 / (N1 + 1)    # Deletion\n            \n            # Argument R for the Metropolis-Hastings acceptance rule\n            R = target_ratio * (T_reverse / T_forward) if T_forward != 0 else float('inf')\n            \n            # Acceptance probabilities\n            A_forward = min(1.0, R)\n            A_reverse = min(1.0, 1.0 / R) if R != 0 else 1.0\n            \n            # Total transition probabilities K\n            K_forward = p_G * 0.5 * T_forward * A_forward\n            K_reverse = p_G * 0.5 * T_reverse * A_reverse\n            \n            # Ratio K(x->y)/K(y->x)\n            if K_reverse == 0:\n                computed_ratio = float('inf') if K_forward != 0 else 1.0\n            else:\n                computed_ratio = K_forward / K_reverse\n        \n        # Verify if computed ratio matches the target ratio within tolerance\n        is_balanced = np.abs(computed_ratio - target_ratio)  tolerance\n        results.append(is_balanced)\n        \n    # Format and print the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将从计算密度和压力等宏观性质，转向一个更基本的物理量：熵。由于熵不是一个可以直接在模拟中测量的力学量，因此需要采用特殊的技术。本练习将介绍热力学积分，这是一种强大的方法，可以通过对模拟过程中采样的势能进行积分来计算自由能和熵的差异，从而更深入地理解相分离的驱动力 。",
            "id": "3454516",
            "problem": "考虑一个通过Gibbs系综蒙特卡洛方法模拟的、在相同温度下具有两个共存相的单组分经典流体。对于一个经典系统，其正则配分函数可以分解为动能部分和构型部分。通过这种分解来定义构型亥姆霍兹自由能 $F_{\\mathrm{conf}}(T,V,N)$，使得构型部分的贡献满足以下恒等式：\n$$\n\\frac{\\partial}{\\partial \\beta}\\big(\\beta F_{\\mathrm{conf}}(T,V,N)\\big)=\\langle U\\rangle_{T,V,N},\n$$\n其中 $\\beta=1/T$（玻尔兹曼常数设为1），$\\langle U\\rangle$ 是势能的系综平均值。对于一个包含 $N$ 个粒子的均匀相，定义单粒子构型量 $a_{\\mathrm{conf}}=F_{\\mathrm{conf}}/N$ 和 $u=\\langle U\\rangle/N$。单粒子构型熵为\n$$\ns_{\\mathrm{conf}}(T,\\rho)=\\frac{u(T,\\rho)-a_{\\mathrm{conf}}(T,\\rho)}{T}.\n$$\n由于在相同温度下，两相的单粒子熵的动能贡献是相同的，因此两相之间的总单粒子熵之差等于该温度下单粒子构型熵之差。\n\n您的任务是，对下面的每个测试用例，在指定的目标逆温 $\\beta^\\star$ 下，通过对 $\\beta$ 进行热力学积分，数值计算两个共存相 $A$ 和 $B$ 之间的单粒子构型熵之差：\n$$\n\\beta^\\star a_{\\mathrm{conf}}(\\beta^\\star) = \\beta_0 a_{\\mathrm{conf}}(\\beta_0) + \\int_{\\beta_0}^{\\beta^\\star} u(\\beta)\\,d\\beta,\n$$\n其中 $\\beta_0$ 是一个给定的参考逆温，而 $\\beta_0 a_{\\mathrm{conf}}(\\beta_0)$ 是一个给定的参考值。您必须：\n- 当 $\\beta_0$ 和 $\\beta^\\star$ 之间的子区间数量为偶数时，使用复合辛普森法则对 $\\beta$ 进行数值积分；如果为奇数，则在最大的偶数个初始子区间上应用复合辛普森法则，并在最后一个子区间上使用单个梯形步。\n- 使用关系式 $s_{\\mathrm{conf}}(\\beta^\\star)=\\beta^\\star\\left[u(\\beta^\\star)-a_{\\mathrm{conf}}(\\beta^\\star)\\right]$ 计算每个相在 $\\beta^\\star$ 处的单粒子构型熵，并报告其差值 $s_{\\mathrm{conf}}^A(\\beta^\\star)-s_{\\mathrm{conf}}^B(\\beta^\\star)$。\n- 在约化单位中进行计算，其中玻尔兹曼常数 $k_{\\mathrm{B}}=1$，因此熵是无量纲的，并以 $k_{\\mathrm{B}}$ 为单位进行测量。\n\n每个测试用例的输入数据以离散数组 $(\\beta_i,u(\\beta_i))$ 的形式提供，用于相 $A$ 和 $B$，覆盖从 $\\beta_0$ 到 $\\beta^\\star$（含两端）的区间，同时提供参考值 $y_0^A=\\beta_0 a_{\\mathrm{conf}}^A(\\beta_0)$ 和 $y_0^B=\\beta_0 a_{\\mathrm{conf}}^B(\\beta_0)$。除了提供的样本之外，您不能假设任何特定的解析形式。\n\n测试套件（三个用例）：\n- 用例1：\n  - $\\beta$ 值：$[0.5,0.6,0.7,0.8,0.9,1.0]$。\n  - A相数据：$u_A(\\beta)=[2.25,2.30,2.35,2.40,2.45,2.50]$。\n  - B相数据：$u_B(\\beta)=[1.60,1.62,1.64,1.66,1.68,1.70]$。\n  - 参考值：$\\beta_0=0.5$, $\\beta^\\star=1.0$, $y_0^A=0.700000$, $y_0^B=0.400000$。\n- 用例2：\n  - $\\beta$ 值：$[1.0,1.5,2.0]$。\n  - A相数据：$u_A(\\beta)=[1.0,1.0,1.0]$。\n  - B相数据：$u_B(\\beta)=[0.9,0.9,0.9]$。\n  - 参考值：$\\beta_0=1.0$, $\\beta^\\star=2.0$, $y_0^A=0.000000$, $y_0^B=0.000000$。\n- 用例3：\n  - $\\beta$ 值：$[0.2,0.4,0.6,0.8,1.0,1.2]$。\n  - A相数据：$u_A(\\beta)=[1.0220,1.0480,1.0780,1.1120,1.1500,1.1920]$。\n  - B相数据：$u_B(\\beta)=[1.1908,1.1832,1.1772,1.1728,1.1700,1.1688]$。\n  - 参考值：$\\beta_0=0.2$, $\\beta^\\star=1.2$, $y_0^A=0.300000$, $y_0^B=0.250000$。\n\n要求：\n- 实现一个程序，对每个用例，计算以 $k_{\\mathrm{B}}$ 为单位的单粒子构型熵之差 $s_{\\mathrm{conf}}^A(\\beta^\\star)-s_{\\mathrm{conf}}^B(\\beta^\\star)$，结果为浮点数。\n- 数值细节：\n  - 假设 $\\beta$ 值是严格递增的，并且包含 $\\beta_0$ 和 $\\beta^\\star$ 作为端点。\n  - 通过按提供的顺序分段应用复合辛普森法则，在均匀或非均匀网格上使用该法则。当 $\\beta_0$ 和 $\\beta^\\star$ 之间的子区间总数为奇数时，在最后一个子区间上附加使用单个梯形法则。\n- 最终输出：\n  - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”）。\n  - 将每个结果表示为小数，四舍五入到小数点后恰好六位，单位为 $k_{\\mathrm{B}}$。\n\n无需用户输入。程序必须硬编码上述测试套件，并按指定格式输出包含三个结果的列表。",
            "solution": "用户要求计算在指定的逆温 $\\beta^\\star$下，两个共存相 $A$ 和 $B$ 之间的单粒子构型熵之差 $s_{\\mathrm{conf}}^A(\\beta^\\star) - s_{\\mathrm{conf}}^B(\\beta^\\star)$。该解是通过从参考态 $(\\beta_0, a_{\\mathrm{conf}}(\\beta_0))$ 到目标态 $(\\beta^\\star, a_{\\mathrm{conf}}(\\beta^\\star))$ 的热力学积分推导得出的。\n\n提供了基础热力学关系式：\n$$\n\\frac{\\partial}{\\partial\\beta} \\left(\\beta a_{\\mathrm{conf}}\\right) = u(\\beta)\n$$\n其中 $\\beta=1/T$ 是逆温（$k_B=1$），$a_{\\mathrm{conf}}$ 是单粒子构型亥姆霍兹自由能，$u$ 是单粒子势能。\n\n将此表达式从参考逆温 $\\beta_0$ 积分到目标逆温 $\\beta^\\star$ 可得到热力学积分公式：\n$$\n\\int_{\\beta_0}^{\\beta^\\star} \\frac{\\partial}{\\partial\\beta} \\left(\\beta a_{\\mathrm{conf}}\\right) d\\beta = \\int_{\\beta_0}^{\\beta^\\star} u(\\beta) \\, d\\beta\n$$\n$$\n\\beta^\\star a_{\\mathrm{conf}}(\\beta^\\star) - \\beta_0 a_{\\mathrm{conf}}(\\beta_0) = \\int_{\\beta_0}^{\\beta^\\star} u(\\beta) \\, d\\beta\n$$\n我们定义 $y(\\beta) = \\beta a_{\\mathrm{conf}}(\\beta)$。方程变为：\n$$\ny(\\beta^\\star) = y(\\beta_0) + \\int_{\\beta_0}^{\\beta^\\star} u(\\beta) \\, d\\beta\n$$\n每个相的 $y(\\beta_0)$ 值是给定的。积分必须根据离散数据 $(\\beta_i, u(\\beta_i))$ 进行数值计算。\n\n数值积分按规定执行。对于定义了 $n$ 个子区间的一组 $n+1$ 个数据点 $(\\beta_0, u_0), \\dots, (\\beta_n, u_n)$，我们检查 $n$ 是偶数还是奇数。假设网格均匀，步长为 $h = \\beta_{i+1} - \\beta_i$：\n1.  如果 $n$ 是偶数，我们在所有 $n$ 个区间上应用复合辛普森法则：\n    $$\n    \\int_{\\beta_0}^{\\beta_n} u(\\beta) \\, d\\beta \\approx \\frac{h}{3} \\left[ u_0 + 4\\sum_{i=1, i \\text{ odd}}^{n-1} u_i + 2\\sum_{i=2, i \\text{ even}}^{n-2} u_i + u_n \\right]\n    $$\n2.  如果 $n$ 是奇数，我们在前 $n-1$ 个（这是一个偶数）区间上应用复合辛普森法则，并在最后一个区间 $[\\beta_{n-1}, \\beta_n]$ 上应用梯形法则：\n    $$\n    \\int_{\\beta_0}^{\\beta_n} u(\\beta) \\, d\\beta \\approx \\left( \\frac{h}{3} \\left[ u_0 + 4\\sum_{i=1, i \\text{ odd}}^{n-2} u_i + 2\\sum_{i=2, i \\text{ even}}^{n-2} u_i + u_{n-1} \\right] \\right) + \\left( \\frac{h}{2} [u_{n-1} + u_n] \\right)\n    $$\n\n计算完给定相的积分后，我们求出 $y(\\beta^\\star)$，然后求解在目标温度下的单粒子自由能：\n$$\na_{\\mathrm{conf}}(\\beta^\\star) = \\frac{y(\\beta^\\star)}{\\beta^\\star} = \\frac{1}{\\beta^\\star} \\left[ y(\\beta_0) + \\int_{\\beta_0}^{\\beta^\\star} u(\\beta) \\, d\\beta \\right]\n$$\n\n单粒子构型熵 $s_{\\mathrm{conf}}$ 由下式给出：\n$$\ns_{\\mathrm{conf}} = \\frac{u-a_{\\mathrm{conf}}}{T} = \\beta(u - a_{\\mathrm{conf}})\n$$\n在目标态，这变为：\n$$\ns_{\\mathrm{conf}}(\\beta^\\star) = \\beta^\\star \\left[ u(\\beta^\\star) - a_{\\mathrm{conf}}(\\beta^\\star) \\right]\n$$\n其中 $u(\\beta^\\star)$ 是所提供的能量数据数组中的最后一个值。\n\n这个过程被独立地应用于相 $A$ 和相 $B$，以获得 $s_{\\mathrm{conf}}^A(\\beta^\\star)$ 和 $s_{\\mathrm{conf}}^B(\\beta^\\star)$。每个测试用例的最终结果是差值：$s_{\\mathrm{conf}}^A(\\beta^\\star) - s_{\\mathrm{conf}}^B(\\beta^\\star)$。\n\n整体算法如下：\n对于每个测试用例：\n1.  定义一个函数，根据子区间的数量执行指定的数值积分。\n2.  定义一个函数，该函数接收单个相的数据 $(\\beta_i, u_i, y_0)$ 并计算 $s_{\\mathrm{conf}}(\\beta^\\star)$。\n    a. 调用积分函数来计算 $u(\\beta)$ 的积分。\n    b. 使用热力学积分公式计算 $a_{\\mathrm{conf}}(\\beta^\\star)$。\n    c. 使用其定义计算 $s_{\\mathrm{conf}}(\\beta^\\star)$。\n3.  对相 $A$ 调用步骤2中的函数，以获得 $s_{\\mathrm{conf}}^A(\\beta^\\star)$。\n4.  对相 $B$ 调用步骤2中的函数，以获得 $s_{\\mathrm{conf}}^B(\\beta^\\star)$。\n5.  计算差值 $\\Delta s_{\\mathrm{conf}} = s_{\\mathrm{conf}}^A(\\beta^\\star) - s_{\\mathrm{conf}}^B(\\beta^\\star)$。\n6.  将结果存储并格式化为六位小数。\n7.  处理完所有用例后，将结果列表格式化为所需的字符串 `\"[result1,result2,result3]\"`。",
            "answer": "```python\nimport numpy as np\n\ndef _numerical_integral(betas, us):\n    \"\"\"\n    Computes the integral of u(beta) dbeta using a hybrid numerical scheme.\n    \n    The scheme uses composite Simpson's rule. If the number of intervals\n    is odd, the last interval is integrated using the trapezoidal rule.\n    The grid is assumed to be uniform.\n    \"\"\"\n    n = len(betas) - 1 # Number of subintervals\n    if n  1:\n        return 0.0\n    \n    h = betas[1] - betas[0] # Assumes uniform grid spacing\n    \n    integral = 0.0\n    \n    if n % 2 == 0: # Even number of intervals\n        # Apply composite Simpson's rule over all intervals\n        integral = (h / 3.0) * (us[0] + 4 * np.sum(us[1:n:2]) + 2 * np.sum(us[2:n-1:2]) + us[n])\n    else: # Odd number of intervals\n        # Apply Simpson's rule on the first n-1 intervals\n        if n > 1:\n            simpson_part = (h / 3.0) * (us[0] + 4 * np.sum(us[1:n-1:2]) + 2 * np.sum(us[2:n-2:2]) + us[n-1])\n            integral += simpson_part\n        \n        # Apply trapezoidal rule on the last interval\n        trapezoid_part = (h / 2.0) * (us[n-1] + us[n])\n        integral += trapezoid_part\n        \n    return integral\n\ndef _calculate_s_conf(betas, us, y0):\n    \"\"\"\n    Calculates the configurational entropy per particle for a single phase.\n    \n    Args:\n        betas (list): Array of inverse temperatures.\n        us (list): Array of potential energies per particle.\n        y0 (float): Reference value beta_0 * a_conf(beta_0).\n        \n    Returns:\n        float: The configurational entropy per particle at beta_star.\n    \"\"\"\n    beta_star = betas[-1]\n    u_star = us[-1]\n    \n    # 1. Numerically integrate u(beta) from beta_0 to beta_star\n    integral_u = _numerical_integral(np.array(betas), np.array(us))\n    \n    # 2. Calculate beta* * a_conf(beta*)\n    y_star = y0 + integral_u\n    \n    # 3. Calculate a_conf(beta*)\n    a_conf_star = y_star / beta_star\n    \n    # 4. Calculate s_conf(beta*)\n    s_conf_star = beta_star * (u_star - a_conf_star)\n    \n    return s_conf_star\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"betas\": [0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n            \"u_A\": [2.25, 2.30, 2.35, 2.40, 2.45, 2.50],\n            \"u_B\": [1.60, 1.62, 1.64, 1.66, 1.68, 1.70],\n            \"y0_A\": 0.700000,\n            \"y0_B\": 0.400000,\n        },\n        {\n            \"betas\": [1.0, 1.5, 2.0],\n            \"u_A\": [1.0, 1.0, 1.0],\n            \"u_B\": [0.9, 0.9, 0.9],\n            \"y0_A\": 0.000000,\n            \"y0_B\": 0.000000,\n        },\n        {\n            \"betas\": [0.2, 0.4, 0.6, 0.8, 1.0, 1.2],\n            \"u_A\": [1.0220, 1.0480, 1.0780, 1.1120, 1.1500, 1.1920],\n            \"u_B\": [1.1908, 1.1832, 1.1772, 1.1728, 1.1700, 1.1688],\n            \"y0_A\": 0.300000,\n            \"y0_B\": 0.250000,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        s_conf_A = _calculate_s_conf(case[\"betas\"], case[\"u_A\"], case[\"y0_A\"])\n        s_conf_B = _calculate_s_conf(case[\"betas\"], case[\"u_B\"], case[\"y0_B\"])\n        \n        delta_s = s_conf_A - s_conf_B\n        results.append(f\"{delta_s:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}