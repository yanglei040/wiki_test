{
    "hands_on_practices": [
        {
            "introduction": "本章的第一个实践是相图计算的基石。我们将学习如何计算一个给定材料的“凸包之上能量”（energy above the hull），记作 $\\Delta E_{\\mathrm{hull}}$。这个值是一个关键的判据，它告诉我们一个相在热力学上是稳定的，还是会分解成其他更稳定的相。本练习将指导你如何将这个物理问题转化为一个线性规划模型，这是一个在材料计算中应用广泛的强大数学工具。",
            "id": "3441315",
            "problem": "给定一个具有成分向量和每个原子总能量的目标相，以及一个竞争相列表（不包括目标相），每个竞争相都有其自身的成分向量和每个原子的总能量。假设热力学温度有效为零开尔文，因此亥姆霍兹自由能简化为内能，并用密度泛函理论 (DFT) 的每个原子总能量来近似内能。使用以下基本原则来形式化此问题：(i) 零开尔文下能量对成分的凸包是竞争相能量作为成分函数的所有凸组合的集合；(ii) 一个相是稳定的，当且仅当其能量位于其成分处的下凸包络上；(iii) 凸包之上能量是相能量与相同成分处凸包能量之间的非负差值。\n\n形式上，设目标相的成分向量为 $\\mathbf{x}_{t}\\in\\mathbb{R}^{d}$，其各分量非负且总和为1，每个原子的能量为 $E_{t}$（单位：电子伏特/原子）。设有 $n$ 个竞争相，由 $i\\in\\{1,\\dots,n\\}$ 索引，每个竞争相的成分向量为 $\\mathbf{x}_{i}\\in\\mathbb{R}^{d}$，其各分量非负且总和为1，每个原子的能量为 $E_{i}$（单位：电子伏特/原子）。将成分 $\\mathbf{x}_{t}$ 处的凸包能量定义为以下线性规划的最优值\n$$\n\\min_{\\mathbf{c}\\in\\mathbb{R}^{n}} \\sum_{i=1}^{n} c_{i} E_{i}\n$$\n约束条件为\n$$\n\\sum_{i=1}^{n} c_{i} \\mathbf{x}_{i} = \\mathbf{x}_{t},\\quad \\sum_{i=1}^{n} c_{i} = 1,\\quad c_{i} \\ge 0\\ \\ \\forall i.\n$$\n将凸包之上能量定义为\n$$\n\\Delta E_{\\mathrm{hull}} = \\max\\left(0,\\, E_{t} - \\min_{\\mathbf{c}} \\sum_{i=1}^{n} c_{i} E_{i}\\right).\n$$\n如果 $\\Delta E_{\\mathrm{hull}} = 0$，则目标相在凸包上是稳定的，分解反应为空分解；在这种情况下，报告所有分解系数均为零。如果 $\\Delta E_{\\mathrm{hull}} > 0$，则最优分解反应系数是上述线性规划达到最小值的最优解 $\\mathbf{c}^{\\star}$ 的分量。\n\n您的任务是编写一个程序，为下面套件中的每个测试用例计算以毫电子伏特/原子为单位的 $\\Delta E_{\\mathrm{hull}}$ 以及相应的最优分解反应系数。所有能量 $E$ 均以电子伏特/原子为单位。将 $\\Delta E_{\\mathrm{hull}}$ 以毫电子伏特/原子（meV/原子）为单位报告，并四舍五入为最接近的整数。将分解系数向量报告为一个浮点数列表，每个数字四舍五入到小数点后6位，其顺序与测试用例中提供的竞争相顺序相同。如果目标相是稳定的（即，在数值容差范围内 $\\Delta E_{\\mathrm{hull}}=0$），则报告一个长度为 $n$ 的零向量。\n\n使用以下测试套件。每个测试用例指定一个目标相和一系列竞争相。每个相都列出了成分向量和每个原子的能量。所有成分都以归一化的分数形式给出，其分量总和为1。\n\n测试用例 $\\mathbf{1}$（二元体系 $\\mathrm{A}$–$\\mathrm{B}$，稳定目标相）：\n- 目标相：成分 $\\left[0.5,\\,0.5\\right]$，能量 $-0.6\\ \\mathrm{eV/atom}$。\n- 按顺序排列的竞争相：\n  $1$: $\\mathrm{A}$，成分 $\\left[1.0,\\,0.0\\right]$，能量 $0.0\\ \\mathrm{eV/atom}$；\n  $2$: $\\mathrm{B}$，成分 $\\left[0.0,\\,1.0\\right]$，能量 $0.0\\ \\mathrm{eV/atom}$。\n\n测试用例 $\\mathbf{2}$（二元体系 $\\mathrm{A}$–$\\mathrm{B}$，不稳定目标相 $\\mathrm{A}_{2}\\mathrm{B}$）：\n- 目标相：成分 $\\left[\\frac{2}{3},\\,\\frac{1}{3}\\right]$，能量 $-0.3\\ \\mathrm{eV/atom}$。\n- 按顺序排列的竞争相：\n  $1$: $\\mathrm{A}$，成分 $\\left[1.0,\\,0.0\\right]$，能量 $0.0\\ \\mathrm{eV/atom}$；\n  $2$: $\\mathrm{B}$，成分 $\\left[0.0,\\,1.0\\right]$，能量 $0.0\\ \\mathrm{eV/atom}$；\n  $3$: $\\mathrm{AB}$，成分 $\\left[0.5,\\,0.5\\right]$，能量 $-0.6\\ \\mathrm{eV/atom}$。\n\n测试用例 $\\mathbf{3}$（三元体系 $\\mathrm{A}$–$\\mathrm{B}$–$\\mathrm{C}$，稳定三元目标相）：\n- 目标相：成分 $\\left[\\frac{1}{3},\\,\\frac{1}{3},\\,\\frac{1}{3}\\right]$，能量 $-0.65\\ \\mathrm{eV/atom}$。\n- 按顺序排列的竞争相：\n  $1$: $\\mathrm{A}$，成分 $\\left[1.0,\\,0.0,\\,0.0\\right]$，能量 $0.0\\ \\mathrm{eV/atom}$；\n  $2$: $\\mathrm{B}$，成分 $\\left[0.0,\\,1.0,\\,0.0\\right]$，能量 $0.0\\ \\mathrm{eV/atom}$；\n  $3$: $\\mathrm{C}$，成分 $\\left[0.0,\\,0.0,\\,1.0\\right]$，能量 $0.0\\ \\mathrm{eV/atom}$；\n  $4$: $\\mathrm{AB}$，成分 $\\left[0.5,\\,0.5,\\,0.0\\right]$，能量 $-0.6\\ \\mathrm{eV/atom}$；\n  $5$: $\\mathrm{AC}$，成分 $\\left[0.5,\\,0.0,\\,0.5\\right]$，能量 $-0.5\\ \\mathrm{eV/atom}$；\n  $6$: $\\mathrm{BC}$，成分 $\\left[0.0,\\,0.5,\\,0.5\\right]$，能量 $-0.55\\ \\mathrm{eV/atom}$。\n\n测试用例 $\\mathbf{4}$（二元体系 $\\mathrm{A}$–$\\mathrm{B}$，端元成分处的不稳定目标相）：\n- 目标相：成分 $\\left[1.0,\\,0.0\\right]$，能量 $0.05\\ \\mathrm{eV/atom}$。\n- 按顺序排列的竞争相：\n  $1$: $\\mathrm{A}$，成分 $\\left[1.0,\\,0.0\\right]$，能量 $0.0\\ \\mathrm{eV/atom}$；\n  $2$: $\\mathrm{B}$，成分 $\\left[0.0,\\,1.0\\right]$，能量 $0.0\\ \\mathrm{eV/atom}$。\n\n您的程序必须：\n- 为每个测试用例，建立并求解线性规划，以获得目标成分下的最小混合物能量及相关系数。\n- 以毫电子伏特/原子为单位计算 $\\Delta E_{\\mathrm{hull}}$，结果为整数（四舍五入到最接近的整数）。\n- 对于稳定的目标相，报告一个全零的分解系数向量；对于不稳定的目标相，报告最优系数，每个系数四舍五入到小数点后6位，并按指定顺序排列。\n\n最终输出格式：您的程序应生成单行输出，包含一个结果列表，每个测试用例一个结果，中间没有多余的空格。每个结果必须是一个形如 $\\left[\\Delta E_{\\mathrm{hull}}^{\\mathrm{meV/atom}},\\,[c_{1},c_{2},\\dots,c_{n}]\\right]$ 的双元素列表，其中 $\\Delta E_{\\mathrm{hull}}^{\\mathrm{meV/atom}}$ 是一个整数，而 $c_{i}$ 是四舍五入到小数点后6位的浮点数。例如，包含两个结果的一行输出应如下所示：$\\left[[100,[0.333333,0.666667]],\\,[0,[0.000000,0.000000]]\\right]$。\n\n假设每个案例都具有数值可行性，并在判断稳定性和系数取舍时，使用 $10^{-9}$ 的非负性容差和 $10^{-8}$ 的等式约束容差。",
            "solution": "该问题在科学上是有效的、良构的，并形式化了计算材料科学中的一个基石概念：热力学相稳定性的预测。任务是计算目标相相对于一组竞争相的凸包之上能量 $\\Delta E_{\\mathrm{hull}}$。该量决定了目标相在 $0\\ \\mathrm{K}$ 温度下是稳定，还是会分解为竞争相的混合物。此问题可归结为求解一个线性规划（LP）问题。\n\n在恒定体积和 $0\\ \\mathrm{K}$ 温度下，系统的状态由其内能 $U$ 描述。一个相是热力学稳定的，当且仅当它在给定成分下具有最低的可能能量。我们可以通过绘制能量与成分的关系图来将其可视化。所有稳定相及其混合物的集合构成了一个“下凸包络”或“凸包”。任何能量-成分点位于此凸包上的相都是稳定的；任何位于其上方的相都是不稳定或亚稳态的，并有驱动力分解为正下方凸包上的稳定相。\n\n该问题将特定目标成分 $\\mathbf{x}_{t}$ 处的凸包能量定义为具有成分 $\\mathbf{x}_{t}$ 的 $n$ 个竞争相的任何混合物的最小能量。这是一个经典的约束优化问题。设混合物的系数为 $c_{1}, c_{2}, \\dots, c_{n}$，代表混合物中每个竞争相 $i$ 的摩尔分数。该混合物必须满足三个条件：\n1. 混合物的总成分必须等于目标成分：$\\sum_{i=1}^{n} c_{i} \\mathbf{x}_{i} = \\mathbf{x}_{t}$。\n2. 系数必须总和为一，因为它们是分数：$\\sum_{i=1}^{n} c_{i} = 1$。\n3. 系数必须为非负，因为我们不能有负数量的相：对所有 $i$，$c_{i} \\ge 0$。\n\n这种混合物的总能量是竞争相能量的加权平均值：$E_{\\mathrm{mixture}} = \\sum_{i=1}^{n} c_{i} E_{i}$。我们的目标是找到满足约束条件同时最小化该能量的系数集 $\\mathbf{c} = (c_1, \\dots, c_n)$。这正是所提供的线性规划的定义：\n$$\nE_{\\mathrm{hull}}(\\mathbf{x}_t) = \\min_{\\mathbf{c}} \\sum_{i=1}^{n} c_{i} E_{i}\n$$\n约束条件为：\n$$\n\\sum_{i=1}^{n} c_{i} \\mathbf{x}_{i} = \\mathbf{x}_{t}\n$$\n$$\n\\sum_{i=1}^{n} c_{i} = 1\n$$\n$$\nc_{i} \\ge 0\\ \\ \\forall i=1,\\dots,n\n$$\n正如问题验证部分所述，由于所有成分向量 $\\mathbf{x}_{i}$ 和 $\\mathbf{x}_{t}$ 都已归一化（其分量总和为1），约束 $\\sum_{i=1}^{n} c_{i} = 1$ 在数学上是冗余的，因为它已由成分约束 $\\sum_{i=1}^{n} c_{i} \\mathbf{x}_{i} = \\mathbf{x}_{t}$ 隐含。然而，在实现数值解时，标准做法是使用简化的成分变量集以避免线性相关。对于一个 $d$ 组分体系，我们使用每个成分向量的前 $d-1$ 个分量。在这个降维空间中，约束 $\\sum_{i=1}^{n} c_{i} = 1$ 不再是冗余的，必须明确包含。这会得到一个数值稳定且良态的LP。\n\n因此，对于一个具有 $n$ 个竞争相的 $d$ 组分体系，LP可表述如下：\n设 $\\mathbf{c}$ 为包含 $n$ 个未知系数的向量。\n要最小化的目标函数是 $\\mathbf{E}^T \\mathbf{c}$，其中 $\\mathbf{E}$ 是竞争相能量 $E_i$ 的向量。\n等式约束写为 $A_{eq} \\mathbf{c} = \\mathbf{b}_{eq}$。我们如下构建 $d \\times n$ 矩阵 $A_{eq}$ 和 $d$ 元素向量 $\\mathbf{b}_{eq}$：\n- $A_{eq}$ 的前 $d-1$ 行由竞争相成分向量 $\\mathbf{x}_i$ 的前 $d-1$ 个分量填充。\n- $A_eq$ 的最后一行全为1。\n- $\\mathbf{b}_{eq}$ 的前 $d-1$ 个元素是目标成分向量 $\\mathbf{x}_t$ 的前 $d-1$ 个分量。\n- $\\mathbf{b}_{eq}$ 的最后一个元素是1。\n非负性约束是 $c_i \\ge 0$，它定义了每个变量的界限。\n\n我们利用 `scipy.optimize.linprog` 函数来求解此LP。该函数返回目标函数的最优值，即凸包能量 $E_{\\mathrm{hull}}(\\mathbf{x}_t)$，以及达到此最小值的最优系数向量 $\\mathbf{c}^{\\star}$。\n\n然后，凸包之上能量计算为 $\\Delta E = E_{t} - E_{\\mathrm{hull}}(\\mathbf{x}_t)$。根据问题定义，我们必须报告 $\\Delta E_{\\mathrm{hull}} = \\max(0, \\Delta E)$。使用 $10^{-8}$ 的数值容差来评估稳定性：如果 $\\Delta E \\le 10^{-8}$，则认为该相是稳定的。\n- 如果稳定，$\\Delta E_{\\mathrm{hull}}$ 报告为 $0\\ \\mathrm{meV/atom}$，分解系数报告为零向量，表示空分解。\n- 如果不稳定（$\\Delta E > 10^{-8}$），$\\Delta E_{\\mathrm{hull}}$ 以 meV/原子为单位报告，并四舍五入到最接近的整数。分解系数由LP的最优解 $\\mathbf{c}^{\\star}$ 给出，每个分量四舍五入到小数点后6位。在四舍五入之前，由浮点数不精确性产生的小负值被截断为零。\n\n将此系统性步骤应用于每个测试用例，以生成最终结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to solve the phase stability problem for all test cases.\n    \"\"\"\n    # Tolerances specified in the problem\n    STABILITY_TOLERANCE = 1e-8\n\n    test_cases = [\n        # Test case 1 (binary system A–B, stable target)\n        {\n            \"target\": (np.array([0.5, 0.5]), -0.6),\n            \"competitors\": [\n                (np.array([1.0, 0.0]), 0.0),\n                (np.array([0.0, 1.0]), 0.0),\n            ]\n        },\n        # Test case 2 (binary system A–B, unstable target A2B)\n        {\n            \"target\": (np.array([2/3, 1/3]), -0.3),\n            \"competitors\": [\n                (np.array([1.0, 0.0]), 0.0),\n                (np.array([0.0, 1.0]), 0.0),\n                (np.array([0.5, 0.5]), -0.6),\n            ]\n        },\n        # Test case 3 (ternary system A–B–C, stable ternary target)\n        {\n            \"target\": (np.array([1/3, 1/3, 1/3]), -0.65),\n            \"competitors\": [\n                (np.array([1.0, 0.0, 0.0]), 0.0),\n                (np.array([0.0, 1.0, 0.0]), 0.0),\n                (np.array([0.0, 0.0, 1.0]), 0.0),\n                (np.array([0.5, 0.5, 0.0]), -0.6),\n                (np.array([0.5, 0.0, 0.5]), -0.5),\n                (np.array([0.0, 0.5, 0.5]), -0.55),\n            ]\n        },\n        # Test case 4 (binary system A–B, unstable target at an endmember composition)\n        {\n            \"target\": (np.array([1.0, 0.0]), 0.05),\n            \"competitors\": [\n                (np.array([1.0, 0.0]), 0.0),\n                (np.array([0.0, 1.0]), 0.0),\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        target_comp, target_energy = case[\"target\"]\n        competitor_comps = [c[0] for c in case[\"competitors\"]]\n        competitor_energies = [c[1] for c in case[\"competitors\"]]\n\n        # --- Set up the linear program ---\n        # Number of competing phases\n        n_competitors = len(competitor_energies)\n        # Number of components in the chemical system\n        d_components = len(target_comp)\n\n        # Objective function vector (energies of competing phases)\n        c_obj = np.array(competitor_energies)\n\n        # Equality constraint matrix A_eq\n        # For a d-component system, we use d-1 composition constraints\n        # and 1 constraint for the sum of coefficients.\n        A_eq = np.zeros((d_components, n_competitors))\n        if d_components > 1:\n            A_eq[:-1, :] = np.array(competitor_comps)[:, :-1].T\n        A_eq[-1, :] = 1.0\n\n        # Equality constraint vector b_eq\n        b_eq = np.zeros(d_components)\n        if d_components > 1:\n            b_eq[:-1] = target_comp[:-1]\n        b_eq[-1] = 1.0\n\n        # Bounds for coefficients c_i >= 0\n        bounds = [(0, None) for _ in range(n_competitors)]\n        \n        # --- Solve the linear program ---\n        # The 'highs' method is robust and is the default in recent SciPy.\n        lp_result = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        if not lp_result.success:\n            # Problem statement guarantees feasibility. If this happens, it's an unexpected issue.\n            raise RuntimeError(\"Linear program solver failed for a test case.\")\n\n        hull_energy = lp_result.fun\n        optimal_coeffs = lp_result.x\n        \n        # --- Calculate energy above hull and determine stability ---\n        delta_E = target_energy - hull_energy\n\n        if delta_E <= STABILITY_TOLERANCE:\n            # Phase is stable or on the hull\n            dE_mev = 0\n            # Per problem spec, report zero coefficients for stable phases\n            decomp_coeffs = [0.0] * n_competitors\n        else:\n            # Phase is unstable\n            # Convert to meV/atom and round to nearest integer\n            dE_mev = int(round(delta_E * 1000))\n            # Use the optimizer from the LP as decomposition coefficients.\n            # Clip small negative values due to float precision before rounding.\n            decomp_coeffs = np.round(np.maximum(0, optimal_coeffs), 6).tolist()\n            \n        results.append([dE_mev, decomp_coeffs])\n\n    # --- Format and print the final output string ---\n    # The output format must be a single line with no spaces.\n    formatted_results = []\n    for res in results:\n        dE_val, coeffs_list = res\n        coeffs_str = f\"[{','.join([f'{c:.6f}' for c in coeffs_list])}]\"\n        formatted_results.append(f\"[{dE_val},{coeffs_str}]\")\n    \n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "一旦我们发现一个相是不稳定的，下一个自然而然的问题是：它会分解成什么？这个实践直接建立在前一个练习的基础上。它将向你展示如何将线性规划的抽象解（即稳定相的权重系数）转化为一个具体、配平的化学反应方程式。掌握这一步对于清晰地传达你的计算结果和理解相不稳定性的实际后果至关重要。",
            "id": "3441322",
            "problem": "给定一个由元素 $A$、$B$ 和 $C$组成的三元化学体系中一组固定的候选产物相。每个相都由其组分向量、化学式单位大小和每原子生成能指定。一个单一的亚稳态三元反应物将分解为这些候选产物的非负线性组合。您的任务是计算能使每原子反应能最小化的化学计量平衡反应系数，然后报告最小化的每原子反应能以及最简整数反应系数。\n\n该问题的基本原理如下。在一个三元体系中，每个原子组分向量为 $\\mathbf{y} = (y_A,y_B,y_C)$ 的相位于由 $y_A \\ge 0$、$y_B \\ge 0$、$y_C \\ge 0$ 和 $y_A + y_B + y_C = 1$ 定义的吉布斯组分单纯形上。对于一个给定的亚稳态反应物，其组分为 $\\mathbf{c}_R$，每原子生成能为 $E_R$，以及一组由 $i$ 索引的产物相，其组分为 $\\mathbf{y}_i$，每原子生成能为 $E_i$，使每原子反应能最小化的分解可通过求解以下凸优化问题获得：\n$$\n\\min_{\\{w_i\\}_{i=1}^M} \\sum_{i=1}^M w_i E_i \\quad \\text{subject to} \\quad \\sum_{i=1}^M w_i \\mathbf{y}_i = \\mathbf{c}_R,\\; w_i \\ge 0,\n$$\n其中 $M$ 是候选产物的数量，等式对 $A$、$B$ 和 $C$ 分量均成立。每原子反应能则为\n$$\n\\Delta E = \\left(\\sum_{i=1}^M w_i E_i\\right) - E_R,\n$$\n该值由上述解最小化。权重 $w_i$ 的非负性确保了产物位于凸包上，该凸包映射了在反应物组分下能量最低的相组合。\n\n为了将连续解转换为化学计量平衡的整数反应系数，设反应物的化学式单位大小 $s_R$ 等于其最简整数化学式表示中的原子总数，并设产物 $i$ 的化学式单位大小 $s_i$ 等于其最简整数化学式中的原子总数。如果 $\\{w_i\\}$ 是最优解，则任何正整数 $m$ 都会产生一个平衡反应\n$$\n\\alpha \\cdot R \\to \\sum_{i=1}^M \\beta_i \\cdot P_i,\n$$\n其中 $\\alpha = m$ 且\n$$\n\\beta_i = m \\cdot \\frac{s_R}{s_i} \\, w_i.\n$$\n通过选择使所有 $\\beta_i$ 均为整数的最小正整数 $m$，然后将所有系数 $(\\alpha,\\beta_1,\\dots,\\beta_M)$ 除以它们的最大公约数，即可获得最简整数反应系数。这将产生化学计量平衡的整数系数。\n\n所有能量单位均为每原子电子伏特 (eV/atom)。所有组分向量必须解释为原子分数。您必须以 eV/atom 为单位表示最终的每原子反应能，并四舍五入到六位小数。\n\n候选产物相在所有测试用例中都是固定的，并列在下方。每个相由 $(\\text{名称}, \\mathbf{y}, s, E)$ 指定：\n- $A$: $(A, (1,0,0), 1, 0.0)$\n- $B$: $(B, (0,1,0), 1, 0.0)$\n- $C$: $(C, (0,0,1), 1, 0.0)$\n- $AB$: $(AB, (0.5,0.5,0), 2, -0.60)$\n- $AC$: $(AC, (0.5,0,0.5), 2, -0.50)$\n- $BC$: $(BC, (0,0.5,0.5), 2, -0.55)$\n\n您的程序必须为每个测试用例求解线性规划，转换为包括反应物系数在内的最简整数反应系数，并按指定格式输出结果。对于每个测试用例，您必须输出一个包含两个条目的列表：最小化的每原子反应能 $\\Delta E$（以 eV/atom 为单位，四舍五入到六位小数），以及按固定顺序 $[\\alpha, \\beta_{AB}, \\beta_{AC}, \\beta_{BC}, \\beta_{A}, \\beta_{B}, \\beta_{C}]$ 排列的最简整数反应系数列表，其中 $\\alpha$ 是反应物系数，其余条目是产物系数。\n\n测试套件：\n- 案例 1：反应物 $A_2B_1C_1$，其中 $s_R = 4$，组分 $\\mathbf{c}_R = (0.5,0.25,0.25)$，以及 $E_R = -0.40$。\n- 案例 2：反应物 $A_1B_1C_2$，其中 $s_R = 4$，组分 $\\mathbf{c}_R = (0.25,0.25,0.5)$，以及 $E_R = -0.47$。\n- 案例 3：反应物 $A_3B_1C_1$，其中 $s_R = 5$，组分 $\\mathbf{c}_R = (0.6,0.2,0.2)$，以及 $E_R = -0.40$。\n- 案例 4：反应物 $A_4B_3C_3$，其中 $s_R = 10$，组分 $\\mathbf{c}_R = (0.4,0.3,0.3)$，以及 $E_R = -0.52$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有四个案例的结果，形式为一个用方括号括起来的逗号分隔列表。每个案例的结果本身必须是一个 $[\\Delta E, [\\alpha, \\beta_{AB}, \\beta_{AC}, \\beta_{BC}, \\beta_{A}, \\beta_{B}, \\beta_{C}]]$ 形式的列表。例如，整体输出应类似于 $[[\\Delta E_1,[\\alpha_1,\\dots]],[\\Delta E_2,[\\alpha_2,\\dots]],[\\Delta E_3,[\\alpha_3,\\dots]],[\\Delta E_4,[\\alpha_4,\\dots]]]$，其中 $\\Delta E_i$ 四舍五入到六位小数，所有系数均为整数。",
            "solution": "用户的要求是解决一系列与相稳定性和反应热力学相关的计算材料科学问题。我将首先验证问题陈述，如果有效，则提供一个完整的解决方案。\n\n### 步骤 1：提取已知条件\n\n**固定的候选产物相：**\n问题定义了一个在三元 $A-B-C$ 体系中包含 $M=6$ 个候选产物相的固定集合。每个相 $i$ 由其名称、组分向量 $\\mathbf{y}_i$、化学式单位大小 $s_i$ 和每原子生成能 $E_i$ 描述。\n- $P_1 = AB$: $\\mathbf{y}_{AB} = (0.5, 0.5, 0)$, $s_{AB} = 2$, $E_{AB} = -0.60$ eV/atom\n- $P_2 = AC$: $\\mathbf{y}_{AC} = (0.5, 0, 0.5)$, $s_{AC} = 2$, $E_{AC} = -0.50$ eV/atom\n- $P_3 = BC$: $\\mathbf{y}_{BC} = (0, 0.5, 0.5)$, $s_{BC} = 2$, $E_{BC} = -0.55$ eV/atom\n- $P_4 = A$: $\\mathbf{y}_{A} = (1, 0, 0)$, $s_{A} = 1$, $E_{A} = 0.0$ eV/atom\n- $P_5 = B$: $\\mathbf{y}_{B} = (0, 1, 0)$, $s_{B} = 1$, $E_{B} = 0.0$ eV/atom\n- $P_6 = C$: $\\mathbf{y}_{C} = (0, 0, 1)$, $s_{C} = 1$, $E_{C} = 0.0$ eV/atom\n\n**优化问题：**\n对于给定的亚稳态反应物，其组分为 $\\mathbf{c}_R$，每原子生成能为 $E_R$，找到权重 $\\{w_i\\}$，求解：\n$$\n\\min_{\\{w_i\\}_{i=1}^M} \\sum_{i=1}^M w_i E_i \\quad \\text{subject to} \\quad \\sum_{i=1}^M w_i \\mathbf{y}_i = \\mathbf{c}_R,\\; w_i \\ge 0\n$$\n\n**反应能：**\n最小化的每原子反应能为：\n$$\n\\Delta E = \\left(\\sum_{i=1}^M w_i E_i\\right) - E_R\n$$\n\n**整数化学计量系数：**\n反应由 $\\alpha \\cdot R \\to \\sum_{i=1}^M \\beta_i \\cdot P_i$ 给出。整数系数从最优权重 $\\{w_i\\}$ 导出，使用：\n- $\\alpha = m$\n- $\\beta_i = m \\cdot \\frac{s_R}{s_i} \\, w_i$\n其中 $m$ 是使所有 $\\beta_i$ 均为整数的最小正整数，最终的系数集 $(\\alpha, \\beta_1, \\dots, \\beta_M)$ 通过除以它们的最大公约数 (GCD) 得到。\n\n**测试用例：**\n- **案例 1：** 反应物 $A_2B_1C_1$。$s_R = 4$, $\\mathbf{c}_R = (0.5, 0.25, 0.25)$, $E_R = -0.40$ eV/atom。\n- **案例 2：** 反应物 $A_1B_1C_2$。$s_R = 4$, $\\mathbf{c}_R = (0.25, 0.25, 0.5)$, $E_R = -0.47$ eV/atom。\n- **案例 3：** 反应物 $A_3B_1C_1$。$s_R = 5$, $\\mathbf{c}_R = (0.6, 0.2, 0.2)$, $E_R = -0.40$ eV/atom。\n- **案例 4：** 反应物 $A_4B_3C_3$。$s_R = 10$, $\\mathbf{c}_R = (0.4, 0.3, 0.3)$, $E_R = -0.52$ eV/atom。\n\n**输出格式：**\n对于每个测试用例，结果是一个列表 $[\\Delta E, [\\alpha, \\beta_{AB}, \\beta_{AC}, \\beta_{BC}, \\beta_A, \\beta_B, \\beta_C]]$，其中 $\\Delta E$ 四舍五入到六位小数，所有系数均为整数。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学基础（关键）：** 该问题牢固地植根于化学热力学和计算材料科学的原理。使用凸包和线性规划来寻找给定组分的最低能量相组合是预测相稳定性和反应路径的标准和基本技术。能量值和组分在物理上是现实的。\n- **适定性：** 问题被构建为一个线性规划 (LP) 问题，这是一个经典且适定的优化问题。目标函数是线性的，可行域是由线性等式和非负性约束定义的凸多胞体。因为候选产物相包括纯元素 $A$、$B$ 和 $C$，它们的组分跨越了整个吉布斯单纯形。这保证了任何反应物组分 $\\mathbf{c}_R$ 都可以表示为产物组分的非负线性组合，确保总能找到一个可行解。将连续权重转换为最简整数化学计量系数的过程也是确定性和明确定义的。\n- **客观性（关键）：** 问题使用精确、无歧义的科学和数学语言陈述。所有量都已定义，任务以算法方式指定，没有主观解释的余地。\n- **完整性和一致性：** 所有必要的数据（每个案例的相属性、反应物属性）和数学公式都已明确提供。组分是正确归一化的原子分数，化学式单位大小与所提供的化学式一致。问题是自洽且内部一致的。\n\n该问题没有表现出验证清单中列出的任何缺陷（例如，科学上不健全、模糊、数据缺失）。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。将提供一个解决方案。\n\n### 解决方案设计\n\n问题的核心是为四个测试用例中的每一个求解一个线性规划 (LP) 问题。该解决方案将使用 Python 中的 `scipy.optimize.linprog` 函数实现，该函数非常适合此任务。\n\n**1. 线性规划公式：**\n优化问题可以转换为 `scipy.optimize.linprog` 所需的标准形式：\n$\\min_{\\mathbf{x}} \\mathbf{c}^T \\mathbf{x}$，约束条件为 $\\mathbf{A}_{eq} \\mathbf{x} = \\mathbf{b}_{eq}$ 和 $\\mathbf{x} \\ge 0$。\n\n- 变量向量 $\\mathbf{x}$ 对应于产物相的权重 $\\{w_i\\}$，按固定顺序排列：$\\mathbf{x} = [w_{AB}, w_{AC}, w_{BC}, w_A, w_B, w_C]^T$。\n- 目标函数系数向量 $\\mathbf{c}$ 由每原子生成能 $\\{E_i\\}$ 组成：$\\mathbf{c} = [-0.60, -0.50, -0.55, 0.0, 0.0, 0.0]^T$。\n- 等式约束矩阵 $\\mathbf{A}_{eq}$ 表示每个元素的质量平衡。其列是产物相的组分向量 $\\mathbf{y}_i$，其行对应于元素 $A$、$B$ 和 $C$。\n$$\n\\mathbf{A}_{eq} = \\begin{pmatrix}\n0.5  & 0.5 & 0.0 & 1.0 & 0.0 & 0.0 \\\\\n0.5  & 0.0 & 0.5 & 0.0 & 1.0 & 0.0 \\\\\n0.0  & 0.5 & 0.5 & 0.0 & 0.0 & 1.0\n\\end{pmatrix}\n$$\n- 等式约束向量 $\\mathbf{b}_{eq}$ 是反应物组分向量 $\\mathbf{c}_R$。该向量在每个测试用例中都不同。\n- 约束 $\\mathbf{x} \\ge 0$（即 $w_i \\ge 0$）由 `linprog` 中的默认边界处理。\n\n**2. 反应能计算：**\n一旦 LP 问题求解完毕，`linprog` 将返回最优权重 $\\mathbf{x}^* = \\{w_i^*\\}$ 和最小化的目标函数值，即产物混合物的总生成能 $E_{products} = \\mathbf{c}^T \\mathbf{x}^*$。然后，每原子反应能 $\\Delta E$ 计算如下：\n$$\n\\Delta E = E_{products} - E_R\n$$\n其中 $E_R$ 是给定测试用例中反应物的生成能。\n\n**3. 转换为整数化学计量系数：**\n连续权重 $\\{w_i^*\\}$ 必须转换为最简整数反应系数 $(\\alpha, \\{\\beta_i\\})$。\n\n- 首先，我们计算产物的未缩放有理系数 $\\{q_i\\}$：$q_i = \\frac{s_R}{s_i} w_i^*$。为保持精度，此计算使用 Python 的 `fractions` 模块进行。来自 LP 求解器的浮点结果 $\\{w_i^*\\}$ 被转换为 `Fraction` 对象。\n- 反应物的系数 $\\alpha$ 被设置为一个乘数 $m$。产物的系数则为 $\\beta_i = m \\cdot q_i$。我们寻求使所有 $\\beta_i$ 值都为整数的最小正整数 $m$。这个 $m$ 是所有有理数 $\\{q_i\\}$ 分母的最小公倍数 (LCM)。\n- 找到 $m$ 后，整数系数计算为 $\\alpha = m$ 和 $\\beta_i = \\text{integer}(m \\cdot q_i)$。\n- 最后，所有系数的集合 $\\{\\alpha, \\beta_1, \\beta_2, \\dots\\}$ 通过将每个系数除以它们的最大公约数 (GCD) 来简化为其最简形式。\n\n此程序将应用于问题陈述中指定的四个测试用例。最终结果将按要求格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom fractions import Fraction\nimport math\n\ndef solve():\n    \"\"\"\n    Solves for the minimum reaction energy and stoichiometric coefficients for\n    the decomposition of metastable ternary compounds.\n    \"\"\"\n\n    # Define the fixed set of candidate product phases\n    # Order: [AB, AC, BC, A, B, C]\n    products = {\n        'names': ['AB', 'AC', 'BC', 'A', 'B', 'C'],\n        'energies': np.array([-0.60, -0.50, -0.55, 0.0, 0.0, 0.0]),  # E_i in eV/atom\n        'sizes': np.array([2, 2, 2, 1, 1, 1]),  # s_i\n        'compositions': np.array([ # y_i\n            [0.5, 0.5, 0.0],  # AB\n            [0.5, 0.0, 0.5],  # AC\n            [0.0, 0.5, 0.5],  # BC\n            [1.0, 0.0, 0.0],  # A\n            [0.0, 1.0, 0.0],  # B\n            [0.0, 0.0, 1.0],  # C\n        ])\n    }\n    \n    # A_eq matrix for the linear program (conservation of elements A, B, C)\n    A_eq = products['compositions'].T\n\n    # Define the test cases for the reactants\n    test_cases = [\n        # (s_R, c_R, E_R)\n        (4, np.array([0.5, 0.25, 0.25]), -0.40),    # Case 1: A2B1C1\n        (4, np.array([0.25, 0.25, 0.5]), -0.47),     # Case 2: A1B1C2\n        (5, np.array([0.6, 0.2, 0.2]), -0.40),       # Case 3: A3B1C1\n        (10, np.array([0.4, 0.3, 0.3]), -0.52),      # Case 4: A4B3C3\n    ]\n\n    results = []\n    \n    # Tolerance for treating a float as zero\n    TOL = 1e-9\n\n    for s_R, c_R, E_R in test_cases:\n        # Solve the linear program to find the optimal weights w_i\n        # min c*x s.t. A_eq*x = b_eq, x >= 0\n        res = linprog(c=products['energies'], A_eq=A_eq, b_eq=c_R, bounds=(0, None), method='highs')\n\n        if not res.success:\n            # This should not happen for this well-posed problem\n            raise RuntimeError(\"Linear programming failed to find a solution.\")\n\n        # The optimal weights for the products\n        w = res.x\n        \n        # The minimized formation energy of the product mixture\n        E_products = res.fun\n        \n        # The minimized reaction energy per atom\n        delta_E = E_products - E_R\n\n        # --- Convert continuous weights to minimal integer stoichiometric coefficients ---\n        \n        q_fractions = []\n        denominators = [1]\n        \n        for i in range(len(w)):\n            if w[i] > TOL:\n                # Convert float weight to a rational number\n                w_frac = Fraction.from_float(w[i]).limit_denominator()\n                \n                # Calculate the unscaled rational coefficient q_i\n                q_i = (Fraction(s_R) / Fraction(products['sizes'][i])) * w_frac\n                q_fractions.append(q_i)\n                denominators.append(q_i.denominator)\n            else:\n                q_fractions.append(Fraction(0))\n\n        # The multiplier m is the LCM of the denominators\n        m = math.lcm(*denominators)\n        \n        # The reactant coefficient\n        alpha = m\n        \n        # The product coefficients\n        betas = np.array([int(m * q) for q in q_fractions])\n\n        # Find the greatest common divisor (GCD) of all non-zero coefficients\n        all_coeffs = [alpha] + list(b for b in betas if b > 0)\n        common_divisor = math.gcd(*all_coeffs)\n        \n        # Reduce coefficients to their minimal integer form\n        final_alpha = alpha // common_divisor\n        final_betas = (betas // common_divisor).tolist()\n\n        # Assemble the final result for this case\n        case_result = [\n            round(delta_E, 6),\n            [final_alpha] + final_betas\n        ]\n        results.append(case_result)\n\n    # Format the final output string exactly as specified\n    # The default str() for lists uses spaces, but the example suggests compact output.\n    output_str = str(results).replace(\", \", \",\")\n    print(output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "到目前为止，我们的分析都局限在绝对零度。最后的这个实践将引入温度这一关键维度，将静态的能量图像转变为由吉布斯自由能主导的动态系统。你将研究凸包如何随着温度升高而“呼吸”——改变其形状和体积，并发现这种几何演变与各组成相的熵之间的深刻联系。这个练习让你得以一窥相图的构建过程，以及材料稳定性如何在真实条件下发生变化。",
            "id": "3441339",
            "problem": "给定一个三元合金体系，其离散的候选相由一个整数标签索引。每个相都由其在三元成分单纯形中的一个成分点和其在零温下的热力学描述符来表征。对于成分为 $(x_A,x_B)$ 的相，化学计量约束为 $x_A \\ge 0$、 $x_B \\ge 0$、 $x_A + x_B \\le 1$，且 $x_C = 1 - x_A - x_B$。在绝对温度 $T$ 下，每个原子的吉布斯自由能模型为 $G(T) = H_0 - T S k_B$，其中 $H_0$ 是在 $T=0\\,\\mathrm{K}$ 时每个原子的生成焓，$S$ 是以每个原子的玻尔兹曼常数为单位表示的每个原子的构型熵，$k_B$ 是玻尔兹曼常数。该模型是计算材料科学中用于评估相稳定性的标准温度线性近似，并与吉布斯自由能的定义一致。考虑在固定温度 $T$ 下，由所有相的 $(x_A,x_B,G(T))$ 构成的三维点云。将凸包体积 $V(T)$ 定义为该点集在 $\\mathbb{R}^3$ 中凸包的常规欧几里得体积。\n\n您的任务是计算凸包相对于温度的“呼吸”速率，即导数 $\\partial V/\\partial T$，并将其符号与作为凸包顶点的相和所有相集合之间的熵差联系起来。\n\n使用以下数据。玻尔兹曼常数为 $k_B = 8.617333262145 \\times 10^{-5}\\,\\mathrm{eV/K}$。每个相 $i$ 由 $(x_A,x_B,H_0,S)$ 指定，其中 $H_0$ 的单位为 $\\mathrm{eV/atom}$，$S$ 的单位为 $k_B/\\mathrm{atom}$：\n- 相 1：$(x_A,x_B,H_0,S) = (0.95,0.03,-0.20,0.50)$\n- 相 2：$(x_A,x_B,H_0,S) = (0.03,0.95,-0.19,0.55)$\n- 相 3：$(x_A,x_B,H_0,S) = (0.02,0.02,-0.18,0.30)$\n- 相 4：$(x_A,x_B,H_0,S) = (0.60,0.35,-0.32,0.80)$\n- 相 5：$(x_A,x_B,H_0,S) = (0.60,0.05,-0.28,0.60)$\n- 相 6：$(x_A,x_B,H_0,S) = (0.05,0.60,-0.27,0.65)$\n- 相 7：$(x_A,x_B,H_0,S) = (0.33,0.33,-0.35,0.90)$\n- 相 8：$(x_A,x_B,H_0,S) = (0.20,0.50,-0.31,0.75)$\n- 相 9：$(x_A,x_B,H_0,S) = (0.50,0.20,-0.30,0.70)$\n- 相 10：$(x_A,x_B,H_0,S) = (0.20,0.20,-0.29,0.50)$\n\n对于每个给定的温度 $T$，请遵循以下精确步骤：\n- 形成三维点集 $\\{(x_A^{(i)},x_B^{(i)},G^{(i)}(T))\\}_{i=1}^{10}$，其中 $G^{(i)}(T) = H_0^{(i)} - T\\,S^{(i)}\\,k_B$。\n- 计算该点集在 $\\mathbb{R}^3$ 中的凸包体积 $V(T)$。\n- 使用一个小的温度步长 $\\Delta T$ 的中心有限差分来近似温度导数：$\\partial V/\\partial T \\approx \\left[V(T+\\Delta T)-V(T-\\Delta T)\\right]/(2\\,\\Delta T)$。\n\n为了将呼吸速率与熵差联系起来，将在温度 $T$ 下的凸包顶点集合 $\\mathcal{V}(T)$ 定义为那些点是凸包顶点的相的子集。设 $\\bar{S}_{\\mathrm{vert}}(T)$ 是 $i \\in \\mathcal{V}(T)$ 的 $S^{(i)}$ 的算术平均值，设 $\\bar{S}_{\\mathrm{all}}$ 是所有相 $i \\in \\{1,\\dots,10\\}$ 的算术平均值。定义熵差 $\\Delta S(T) = \\bar{S}_{\\mathrm{vert}}(T) - \\bar{S}_{\\mathrm{all}}$。在每个温度下，判断 $\\partial V/\\partial T$ 的符号是否与 $\\Delta S(T)$ 的符号匹配，并遵循以下平局打破约定：如果一个量的绝对值小于容差 $\\varepsilon$，则将其视为零，并赋予其零符号。对 $\\partial V/\\partial T$ 使用 $\\varepsilon_V = 10^{-9}$（单位为 $\\mathrm{eV/(atom\\cdot K)}$），对 $\\Delta S(T)$ 使用 $\\varepsilon_S = 10^{-12}$（无量纲，单位为 $k_B/\\mathrm{atom}$）。如果两个符号都为正、都为负或都为零，则符号一致性为真；否则为假。\n\n使用以下测试套件：\n- 温度：$T \\in \\{300, 800, 1200\\}\\,\\mathrm{K}$。\n- 中心差分步长：$\\Delta T = 1\\,\\mathrm{K}$。\n\n您的程序应计算测试套件中每个 $T$ 的 $\\partial V/\\partial T$ 的有限差分近似值（单位为 $\\mathrm{eV/(atom\\cdot K)}$，四舍五入到六位小数），以及如上定义的与 $\\Delta S(T)$ 的布尔符号一致性。最终输出格式必须是单行，包含一个逗号分隔的 Python 风格列表，其中的条目按以下顺序排列：$[\\text{在 } 300\\,\\mathrm{K} \\text{ 时的 } \\partial V/\\partial T, \\text{在 } 300\\,\\mathrm{K} \\text{ 时的一致性}, \\text{在 } 800\\,\\mathrm{K} \\text{ 时的 } \\partial V/\\partial T, \\text{在 } 800\\,\\mathrm{K} \\text{ 时的一致性}, \\text{在 } 1200\\,\\mathrm{K} \\text{ 时的 } \\partial V/\\partial T, \\text{在 } 1200\\,\\mathrm{K} \\text{ 时的一致性}]$。每个导数必须以 $\\mathrm{eV/(atom\\cdot K)}$ 为单位并四舍五入到六位小数，每个一致性必须是布尔字面值，不得有附加文本。",
            "solution": "该解决方案基于吉布斯自由能的定义和凸包的几何性质。对于一个焓为 $H_0$、熵为 $S$ 的相，在绝对温度 $T$ 下，其每个原子的吉布斯自由能为 $G(T) = H_0 - T S k_B$，其中 $k_B$ 是玻尔兹曼常数。这是连接自由能、焓和熵的基本热力学关系。因为每个相的 $G(T)$ 都与 $T$ 呈仿射关系，所以由 $(x_A,x_B,G(T))$ 定义的 $\\mathbb{R}^3$ 中的点云是一组点，其第三个坐标随 $T$ 线性移动，每个点的斜率由 $-S k_B$ 决定。\n\n凸包体积 $V(T)$ 是这些点在 $\\mathbb{R}^3$ 中凸包所包围的欧几里得体积。随着 $T$ 的变化，这个凸多胞体会变形，因为每个点的第三个坐标都以由 $S$ 决定的速率随 $T$ 线性移动。由于组合结构（哪些点是顶点）只能在面发生翻转的孤立温度点上改变，并且在这些变化之间体积是 $T$ 的平滑函数，因此导数 $\\partial V/\\partial T$ 几乎处处有定义。在数值上，我们用一个小的温度增量 $\\Delta T$ 的中心有限差分 $[V(T+\\Delta T) - V(T-\\Delta T)]/(2\\,\\Delta T)$ 来近似它。\n\n为了将呼吸速率与熵差联系起来，考虑哪些点控制着 $V(T)$。凸包体积由其面决定，这些面是凸包顶点的凸组合。在我们的设置中，温度 $T$ 下的凸包顶点是那些其点在 $(x_A,x_B,G(T))$ 空间中成为极点的相。这些顶点的自由能坐标随 $T$ 移动的速率与其熵 $S$ 成正比。如果顶点的平均 $S$ 高于全体系的平均值，那么增加 $T$ 往往会增大了顶点间 $G$ 的分布范围，从而倾向于增加凸包体积。相反，如果顶点的平均 $S$ 较低，则凸包倾向于沿能量轴压缩。这启发我们将 $\\partial V/\\partial T$ 的符号与 $\\Delta S(T) = \\bar{S}_{\\mathrm{vert}}(T) - \\bar{S}_{\\mathrm{all}}$ 的符号进行比较，其中 $\\bar{S}_{\\mathrm{vert}}(T)$ 是在温度 $T$ 下凸包顶点的平均 $S$，而 $\\bar{S}_{\\mathrm{all}}$ 是所有相的平均 $S$。如果在容差范围内这些符号匹配，我们则评估为“一致”。\n\n算法步骤如下：\n- 对于测试套件中的每个温度 $T$，为每个相 $i$ 计算 $G^{(i)}(T) = H_0^{(i)} - T S^{(i)} k_B$ 以获得点云 $(x_A^{(i)}, x_B^{(i)}, G^{(i)}(T))$。\n- 计算此点集的 $\\mathbb{R}^3$ 凸包并记录其体积 $V(T)$。使用 $\\Delta T = 1\\,\\mathrm{K}$ 并类似地计算 $V(T+\\Delta T)$ 和 $V(T-\\Delta T)$，以中心差分的形式估算 $\\partial V/\\partial T$。\n- 提取温度 $T$ 下凸包的顶点索引，并计算 $\\bar{S}_{\\mathrm{vert}}(T)$ 作为这些索引上 $S^{(i)}$ 的算术平均值。一次性计算所有相的 $\\bar{S}_{\\mathrm{all}}$。构造 $\\Delta S(T) = \\bar{S}_{\\mathrm{vert}}(T) - \\bar{S}_{\\mathrm{all}}$。\n- 使用容差 $\\varepsilon_V = 10^{-9}$（单位为 $\\mathrm{eV/(atom\\cdot K)}$）确定 $\\partial V/\\partial T$ 的符号：绝对值小于 $\\varepsilon_V$ 的值被视为零。使用容差 $\\varepsilon_S = 10^{-12}$ 确定 $\\Delta S(T)$ 的符号。如果两个符号都为正、都为负或都为零，则符号一致性布尔值为真。\n- 对于每个温度，报告 $\\partial V/\\partial T$ 的有限差分估计值（单位为 $\\mathrm{eV/(atom\\cdot K)}$，四舍五入到六位小数），后跟布尔一致性。将所有结果按指定的温度顺序汇总到一个列表中。\n\n这个过程利用了计算材料科学中温度线性自由能模型和凸包构造，来量化凸包的“呼吸”，并将其速率与在每个温度下定义凸包的相的相对熵联系起来。使用中心有限差分确保了在 $\\Delta T$ 很小的情况下有二阶精度的局部近似，而容差则控制了数值噪声和在评估温度附近凸包可能发生的拓扑变化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import ConvexHull\n\nKB_eV_per_K = 8.617333262145e-5  # eV/K\n\ndef phase_data():\n    # Returns arrays for compositions, enthalpies, entropies\n    # Each row: (xA, xB, H0 [eV/atom], S [k_B/atom])\n    data = np.array([\n        [0.95, 0.03, -0.20, 0.50],\n        [0.03, 0.95, -0.19, 0.55],\n        [0.02, 0.02, -0.18, 0.30],\n        [0.60, 0.35, -0.32, 0.80],\n        [0.60, 0.05, -0.28, 0.60],\n        [0.05, 0.60, -0.27, 0.65],\n        [0.33, 0.33, -0.35, 0.90],\n        [0.20, 0.50, -0.31, 0.75],\n        [0.50, 0.20, -0.30, 0.70],\n        [0.20, 0.20, -0.29, 0.50],\n    ], dtype=float)\n    xA = data[:, 0]\n    xB = data[:, 1]\n    H0 = data[:, 2]\n    S_kB = data[:, 3]\n    return xA, xB, H0, S_kB\n\ndef compute_points(T, xA, xB, H0, S_kB):\n    # G(T) = H0 - T * S * k_B\n    G = H0 - T * (S_kB * KB_eV_per_K)\n    pts = np.column_stack([xA, xB, G])\n    return pts\n\ndef hull_volume(points):\n    # Compute convex hull volume in 3D\n    # If points are co-linear/planar in a degenerate way (unlikely here), handle gracefully\n    hull = ConvexHull(points, qhull_options='QJ')  # joggled input to avoid degeneracy\n    return hull.volume, hull\n\ndef finite_difference_dVdT(T, dT, xA, xB, H0, S_kB):\n    pts_plus = compute_points(T + dT, xA, xB, H0, S_kB)\n    V_plus, _ = hull_volume(pts_plus)\n    pts_minus = compute_points(T - dT, xA, xB, H0, S_kB)\n    V_minus, _ = hull_volume(pts_minus)\n    dVdT = (V_plus - V_minus) / (2.0 * dT)\n    return dVdT\n\ndef sign_with_tol(val, tol):\n    if abs(val) < tol:\n        return 0\n    return 1 if val > 0 else -1\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_temperatures = [300.0, 800.0, 1200.0]  # K\n    dT = 1.0  # K\n    eps_V = 1e-9\n    eps_S = 1e-12\n\n    xA, xB, H0, S_kB = phase_data()\n    S_all_avg = float(np.mean(S_kB))\n\n    results = []\n    for T in test_temperatures:\n        # Compute derivative dV/dT via central difference\n        dVdT = finite_difference_dVdT(T, dT, xA, xB, H0, S_kB)\n\n        # Compute current hull and its vertex set\n        pts = compute_points(T, xA, xB, H0, S_kB)\n        V_T, hull = hull_volume(pts)\n        vertex_indices = np.unique(hull.vertices)\n        S_vert_avg = float(np.mean(S_kB[vertex_indices]))\n        delta_S = S_vert_avg - S_all_avg  # in k_B/atom\n\n        # Determine sign agreement\n        sgn_dV = sign_with_tol(dVdT, eps_V)\n        sgn_dS = sign_with_tol(delta_S, eps_S)\n        agreement = (sgn_dV == sgn_dS)\n\n        # Round derivative to six decimal places\n        dVdT_rounded = round(dVdT, 6)\n        results.append(dVdT_rounded)\n        results.append(str(agreement)) # Explicitly convert to string \"True\" or \"False\"\n\n    # Final print statement in the exact required format.\n    final_string = \",\".join(results)\n    print(f\"[{final_string}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}