{
    "hands_on_practices": [
        {
            "introduction": "A crucial first step in any reliable computational study is to verify that your method adheres to fundamental physical principles. This exercise demonstrates the core origin of magnetocrystalline anisotropy by showing that in the absence of spin-orbit coupling (SOC), the system's total energy must be invariant to the global orientation of magnetization. By working through a simplified tight-binding model, you will numerically confirm this rotational invariance, a critical sanity check to ensure that any calculated anisotropy is physical and not an artifact of the computational setup.",
            "id": "3462882",
            "problem": "You are tasked with constructing and analyzing a minimal, physically plausible tight-binding model that captures the rotational properties of the spin degrees of freedom in the context of Density Functional Theory (DFT) with noncollinear magnetism. The purpose is to demonstrate that, in the absence of Spin-Orbit Coupling (SOC), the total electronic energy as a function of the spin quantization axis orientation $E(\\theta)$ is invariant with respect to rotations in spin space, up to numerical tolerance, thereby ensuring that no spurious magnetocrystalline anisotropy is introduced by the computational setup.\n\nStart from fundamental principles: in the absence of spin-orbit coupling, the Pauli Hamiltonian with an exchange field is rotationally invariant in spin space. As a minimal computational model, consider a two-orbital ($p_x$, $p_y$) tight-binding system on a two-dimensional square lattice. Let the orbital dispersions be\n$$\n\\varepsilon_x(\\mathbf{k}) = \\varepsilon_0 + 2 t_1 \\cos k_x + 2 t_2 \\cos k_y,\n$$\n$$\n\\varepsilon_y(\\mathbf{k}) = \\varepsilon_0 + 2 t_2 \\cos k_x + 2 t_1 \\cos k_y,\n$$\nwith lattice constant set to unity and $\\mathbf{k}$ sampled uniformly in the first Brillouin zone with $k_x, k_y \\in [-\\pi, \\pi)$; angle variables must always be expressed in radians. Define the orbital Hamiltonian\n$$\nH_{\\text{orb}}(\\mathbf{k}) = \\begin{pmatrix} \\varepsilon_x(\\mathbf{k}) & 0 \\\\ 0 & \\varepsilon_y(\\mathbf{k}) \\end{pmatrix}.\n$$\nLet the orbital angular momentum operator along the crystalline $z$ axis in the $(p_x, p_y)$ basis be\n$$\nL_z = \\begin{pmatrix} 0 & i \\\\ -i & 0 \\end{pmatrix},\n$$\nin units where $\\hbar = 1$. Let the Pauli matrices be $\\sigma_x, \\sigma_y, \\sigma_z$ and $I_2$ be the $2 \\times 2$ identity matrix. Model a collinear mean-field exchange interaction of magnitude $\\Delta$ along a unit vector $\\mathbf{n}(\\theta) = (\\sin \\theta, 0, \\cos \\theta)$, which represents the spin quantization axis. Introduce a spin-orbit coupling as a local on-site term $\\lambda L_z \\otimes \\sigma_z$ that ties the spin to the lattice axes. The full Bloch Hamiltonian is\n$$\nH(\\mathbf{k}, \\theta) = H_{\\text{orb}}(\\mathbf{k}) \\otimes I_2 + \\Delta \\, I_2 \\otimes \\left(\\mathbf{n}(\\theta) \\cdot \\boldsymbol{\\sigma}\\right) + \\lambda \\, L_z \\otimes \\sigma_z.\n$$\n\nAt zero temperature, for a given electron number per unit cell $n_e$, approximate the total energy per unit cell $E(\\theta)$ by uniformly sampling a rectangular $\\mathbf{k}$-point mesh of size $N_x \\times N_y$, diagonalizing $H(\\mathbf{k}, \\theta)$ at each $\\mathbf{k}$, collecting all $4$ band energies for each $\\mathbf{k}$, sorting them globally across the Brillouin zone, and summing the lowest $n_e N_k$ energies, where $N_k = N_x N_y$. The energy per unit cell is then\n$$\nE(\\theta) = \\frac{1}{N_k} \\sum_{m=1}^{n_e N_k} \\epsilon_m(\\theta),\n$$\nwhere $\\epsilon_m(\\theta)$ are the globally sorted single-particle eigenvalues of $H(\\mathbf{k}, \\theta)$ over all $\\mathbf{k}$-points. All energies must be handled and reported in electronvolts (eV).\n\nYour program must implement this model and, for each test case specified below, compute $E(\\theta)$ for a list of angles and then evaluate the maximum absolute deviation from a reference orientation:\n$$\n\\Delta E_{\\max} = \\max_{\\theta} \\left| E(\\theta) - E(\\theta_{\\text{ref}}) \\right|.\n$$\nA test case passes (boolean output is $True$) if $\\Delta E_{\\max} \\le \\tau$ for the specified numerical tolerance $\\tau$ (expressed in eV), and fails (boolean output is $False$) otherwise.\n\nAngle variables must be in radians. Energies must be in electronvolts (eV). The final output must be a single line containing the boolean results for all test cases as a comma-separated list enclosed in square brackets, for example, \"[True,False,True]\".\n\nUse the following test suite, designed to probe different facets of the invariance:\n\n- Test Case A (general noncollinear, no SOC, anisotropic orbitals, happy path):\n  - $\\varepsilon_0 = 0.0$ eV, $t_1 = 1.0$ eV, $t_2 = 0.2$ eV, $\\Delta = 0.4$ eV, $\\lambda = 0.0$ eV.\n  - $n_e = 2.0$ electrons per unit cell.\n  - $N_x = 10$, $N_y = 10$ ($N_k = 100$).\n  - Angles: $\\theta \\in \\{ 0.0, \\pi/7, \\pi/4, \\pi/2 \\}$.\n  - Tolerance: $\\tau = 1\\times 10^{-9}$ eV.\n  - Expected behavior: rotational invariance, boolean should be $True$.\n\n- Test Case B (boundary condition: no magnetization, no SOC):\n  - $\\varepsilon_0 = 0.0$ eV, $t_1 = 0.8$ eV, $t_2 = 0.6$ eV, $\\Delta = 0.0$ eV, $\\lambda = 0.0$ eV.\n  - $n_e = 1.0$ electrons per unit cell.\n  - $N_x = 8$, $N_y = 8$ ($N_k = 64$).\n  - Angles: $\\theta \\in \\{ 0.0, \\pi/3, \\pi \\}$.\n  - Tolerance: $\\tau = 1\\times 10^{-9}$ eV.\n  - Expected behavior: rotational invariance, boolean should be $True$.\n\n- Test Case C (edge case: SOC present, anisotropy should be observable):\n  - $\\varepsilon_0 = 0.0$ eV, $t_1 = 1.0$ eV, $t_2 = 0.2$ eV, $\\Delta = 0.4$ eV, $\\lambda = 0.2$ eV.\n  - $n_e = 2.0$ electrons per unit cell.\n  - $N_x = 20$, $N_y = 20$ ($N_k = 400$).\n  - Angles: $\\theta \\in \\{ 0.0, \\pi/7, \\pi/4, \\pi/2 \\}$.\n  - Tolerance: $\\tau = 1\\times 10^{-9}$ eV.\n  - Expected behavior: broken rotational invariance due to SOC, boolean should be $False$.\n\n- Test Case D (boundary condition: coarse grid, no SOC):\n  - $\\varepsilon_0 = 0.0$ eV, $t_1 = 1.2$ eV, $t_2 = 0.7$ eV, $\\Delta = 0.5$ eV, $\\lambda = 0.0$ eV.\n  - $n_e = 2.0$ electrons per unit cell.\n  - $N_x = 4$, $N_y = 4$ ($N_k = 16$).\n  - Angles: $\\theta \\in \\{ 0.0, \\pi/4, \\pi/2 \\}$.\n  - Tolerance: $\\tau = 1\\times 10^{-9}$ eV.\n  - Expected behavior: rotational invariance, boolean should be $True$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order of Test Cases A, B, C, and D.",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of condensed matter physics, specifically tight-binding models and the theory of magnetism. It is well-posed, providing a complete set of equations, parameters, and a clear computational procedure. The language is objective and unambiguous. We may therefore proceed with the solution.\n\nThe core task is to numerically verify a fundamental principle of magnetism: in the absence of spin-orbit coupling (SOC), the total energy of a system is invariant under a global rotation of all electron spins. Any dependence of the total energy on the spin orientation, known as magnetocrystalline anisotropy, must arise from an interaction that couples the spin degrees of freedom to the crystal lattice. In our model, this coupling is provided by the SOC term.\n\nThe solution is implemented by following these steps for each test case:\n\n1.  **Model Definition**: We first define the matrix representations of the operators involved. The Hilbert space for a single atomic site is the tensor product of a $2$-dimensional orbital space spanned by $\\{ |p_x\\rangle, |p_y\\rangle \\}$ and a $2$-dimensional spin space spanned by $\\{ |\\uparrow\\rangle, |\\downarrow\\rangle \\}$. The total basis is $4$-dimensional. The Pauli matrices are:\n    $$\n    \\sigma_x = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}, \\quad \\sigma_y = \\begin{pmatrix} 0 & -i \\\\ i & 0 \\end{pmatrix}, \\quad \\sigma_z = \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}\n    $$\n    The identity matrix in spin space is $I_2$. The orbital angular momentum operator $L_z$ is given in the problem statement.\n\n2.  **Hamiltonian Construction**: For each point $\\mathbf{k} = (k_x, k_y)$ in the Brillouin zone and for each spin orientation angle $\\theta$, we construct the $4 \\times 4$ Bloch Hamiltonian matrix $H(\\mathbf{k}, \\theta)$. The Hamiltonian is the sum of three terms:\n    $$\n    H(\\mathbf{k}, \\theta) = H_{\\text{orb}}(\\mathbf{k}) \\otimes I_2 + H_{\\text{exch}}(\\theta) + H_{\\text{soc}}\n    $$\n    -   The orbital term, $H_{\\text{orb}}(\\mathbf{k}) \\otimes I_2$, describes the kinetic energy of electrons and their interaction with the periodic potential of the lattice, independent of spin. The orbital dispersions are $\\varepsilon_x(\\mathbf{k}) = \\varepsilon_0 + 2 t_1 \\cos k_x + 2 t_2 \\cos k_y$ and $\\varepsilon_y(\\mathbf{k}) = \\varepsilon_0 + 2 t_2 \\cos k_x + 2 t_1 \\cos k_y$.\n    -   The exchange term, $H_{\\text{exch}}(\\theta) = \\Delta \\, I_2 \\otimes \\left(\\mathbf{n}(\\theta) \\cdot \\boldsymbol{\\sigma}\\right)$, represents the effective magnetic field from electron-electron interactions (exchange-correlation). It aligns the spins along the general direction $\\mathbf{n}(\\theta) = (\\sin \\theta, 0, \\cos \\theta)$. This term is explicitly:\n        $$\n        H_{\\text{exch}}(\\theta) = \\Delta \\, I_2 \\otimes \\begin{pmatrix} \\cos\\theta & \\sin\\theta \\\\ \\sin\\theta & -\\cos\\theta \\end{pmatrix}\n        $$\n    -   The spin-orbit coupling (SOC) term, $H_{\\text{soc}} = \\lambda \\, L_z \\otimes \\sigma_z$, links the spin orientation to the orbital degrees of freedom, which are fixed to the crystal lattice. This is the term that can break the rotational invariance in spin space.\n\n    Combining these terms results in the full Hamiltonian matrix, which is Hermitian:\n    $$\n    H(\\mathbf{k}, \\theta) = \\begin{pmatrix}\n    \\varepsilon_x(\\mathbf{k}) + \\Delta\\cos\\theta & \\Delta\\sin\\theta & i\\lambda & 0 \\\\\n    \\Delta\\sin\\theta & \\varepsilon_x(\\mathbf{k}) - \\Delta\\cos\\theta & 0 & -i\\lambda \\\\\n    -i\\lambda & 0 & \\varepsilon_y(\\mathbf{k}) + \\Delta\\cos\\theta & \\Delta\\sin\\theta \\\\\n    0 & i\\lambda & \\Delta\\sin\\theta & \\varepsilon_y(\\mathbf{k}) - \\Delta\\cos\\theta\n    \\end{pmatrix}\n    $$\n    This matrix is implemented using `numpy.kron` for clarity and correctness, and is of complex data type due to the terms $i\\lambda$.\n\n3.  **Brillouin Zone Integration**: The total energy per unit cell, $E(\\theta)$, is an integral over the first Brillouin zone. We approximate this integral by summing over a discrete, uniform mesh of $\\mathbf{k}$-points. A mesh of size $N_x \\times N_y$ is generated, with $k_x$ and $k_y$ spanning the interval $[-\\pi, \\pi)$. For each of the $N_k = N_x N_y$ points in this mesh, we construct and diagonalize the Hamiltonian $H(\\mathbf{k}, \\theta)$. Since the Hamiltonian is Hermitian, its eigenvalues are real, and `numpy.linalg.eigvalsh` is an efficient and numerically stable choice for this task. This process yields $4 \\times N_k$ single-particle energy eigenvalues for each angle $\\theta$.\n\n4.  **Total Energy Calculation**: At zero temperature ($T=0$), the electrons occupy the lowest available energy states up to the Fermi level. Given an electron number per unit cell $n_e$, the total number of occupied states across the simulated Brillouin zone is $n_e N_k$. To find the total electronic energy per unit cell for a given angle $\\theta$, we perform the following steps:\n    a. Collect all $4 \\times N_k$ eigenvalues from the diagonalizations at all $\\mathbf{k}$-points.\n    b. Sort these eigenvalues in ascending order.\n    c. Sum the lowest $n_e N_k$ eigenvalues.\n    d. Normalize this sum by dividing by the number of $\\mathbf{k}$-points, $N_k$.\n    $$\n    E(\\theta) = \\frac{1}{N_k} \\sum_{m=1}^{n_e N_k} \\epsilon_m(\\theta)\n    $$\n    This procedure is repeated for every angle $\\theta$ specified in the test case.\n\n5.  **Anisotropy Evaluation**: To quantify the rotational invariance, we calculate the maximum energy deviation, $\\Delta E_{\\max}$, across the calculated angles. We select the energy at the first angle, $\\theta_{\\text{ref}}$, as the reference energy $E(\\theta_{\\text{ref}})$.\n    $$\n    \\Delta E_{\\max} = \\max_{\\theta} \\left| E(\\theta) - E(\\theta_{\\text{ref}}) \\right|\n    $$\n    A test case is considered passed if this deviation is within a given numerical tolerance $\\tau$, i.e., $\\Delta E_{\\max} \\le \\tau$. This boolean result is computed for each test case.\n\nThis complete procedure is encapsulated in a Python script. For cases where the SOC constant $\\lambda$ is zero, we expect $\\Delta E_{\\max}$ to be zero (or on the order of machine precision, much smaller than the tolerance $\\tau=1 \\times 10^{-9}$ eV), as the Hamiltonian $H(\\mathbf{k}, \\theta)$ is unitarily equivalent to $H(\\mathbf{k}, 0)$ for all $\\theta$, resulting in an identical set of eigenvalues. When $\\lambda$ is non-zero, this unitary equivalence is broken, and $E(\\theta)$ is expected to vary with $\\theta$, leading to a $\\Delta E_{\\max}$ that exceeds the tolerance. The program systematically applies this methodology to each of the four test cases and aggregates their boolean outcomes.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes magnetocrystalline anisotropy for a tight-binding model\n    to verify rotational invariance in the absence of spin-orbit coupling.\n    \"\"\"\n\n    # Define test cases as specified in the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"params\": {\"eps0\": 0.0, \"t1\": 1.0, \"t2\": 0.2, \"Delta\": 0.4, \"lambda_\": 0.0},\n            \"ne\": 2.0, \"Nk_dims\": (10, 10),\n            \"angles\": [0.0, np.pi/7, np.pi/4, np.pi/2],\n            \"tolerance\": 1e-9,\n        },\n        # Test Case B\n        {\n            \"params\": {\"eps0\": 0.0, \"t1\": 0.8, \"t2\": 0.6, \"Delta\": 0.0, \"lambda_\": 0.0},\n            \"ne\": 1.0, \"Nk_dims\": (8, 8),\n            \"angles\": [0.0, np.pi/3, np.pi],\n            \"tolerance\": 1e-9,\n        },\n        # Test Case C\n        {\n            \"params\": {\"eps0\": 0.0, \"t1\": 1.0, \"t2\": 0.2, \"Delta\": 0.4, \"lambda_\": 0.2},\n            \"ne\": 2.0, \"Nk_dims\": (20, 20),\n            \"angles\": [0.0, np.pi/7, np.pi/4, np.pi/2],\n            \"tolerance\": 1e-9,\n        },\n        # Test Case D\n        {\n            \"params\": {\"eps0\": 0.0, \"t1\": 1.2, \"t2\": 0.7, \"Delta\": 0.5, \"lambda_\": 0.0},\n            \"ne\": 2.0, \"Nk_dims\": (4, 4),\n            \"angles\": [0.0, np.pi/4, np.pi/2],\n            \"tolerance\": 1e-9,\n        },\n    ]\n\n    # Pre-define constant matrices\n    I2 = np.identity(2, dtype=float)\n    SIGMA_X = np.array([[0, 1], [1, 0]], dtype=float)\n    SIGMA_Z = np.array([[1, 0], [0, -1]], dtype=float)\n    L_Z = np.array([[0, 1j], [-1j, 0]], dtype=complex)\n\n    def calculate_total_energy(params, ne, Nk_dims, theta):\n        \"\"\"\n        Calculates the total energy per unit cell for a given spin orientation theta.\n        \"\"\"\n        eps0, t1, t2, Delta, lambda_ = params.values()\n        Nx, Ny = Nk_dims\n        Nk = Nx * Ny\n\n        # Generate k-point mesh\n        kx_vals = np.linspace(-np.pi, np.pi, Nx, endpoint=False)\n        ky_vals = np.linspace(-np.pi, np.pi, Ny, endpoint=False)\n        \n        all_eigenvalues = []\n\n        # Construct constant parts of the Hamiltonian\n        n_vec_sigma = np.cos(theta) * SIGMA_Z + np.sin(theta) * SIGMA_X\n        h_exch = Delta * np.kron(I2, n_vec_sigma)\n        h_soc = lambda_ * np.kron(L_Z, SIGMA_Z)\n\n        for kx in kx_vals:\n            for ky in ky_vals:\n                # Orbital dispersions\n                eps_x_k = eps0 + 2 * t1 * np.cos(kx) + 2 * t2 * np.cos(ky)\n                eps_y_k = eps0 + 2 * t2 * np.cos(kx) + 2 * t1 * np.cos(ky)\n                \n                h_orb_diag = np.array([[eps_x_k, 0], [0, eps_y_k]])\n                h_orb = np.kron(h_orb_diag, I2)\n\n                # Full Hamiltonian\n                H_k = h_orb + h_exch + h_soc\n                \n                # Diagonalize and collect eigenvalues\n                eigenvalues = np.linalg.eigvalsh(H_k)\n                all_eigenvalues.extend(eigenvalues)\n        \n        # Sort all eigenvalues globally\n        all_eigenvalues.sort()\n\n        # Sum occupied states\n        num_occupied = int(ne * Nk)\n        total_energy_sum = np.sum(all_eigenvalues[0:num_occupied])\n\n        # Return energy per unit cell\n        return total_energy_sum / Nk\n\n    results = []\n    for case in test_cases:\n        energies_for_case = []\n        for theta in case[\"angles\"]:\n            energy = calculate_total_energy(case[\"params\"], case[\"ne\"], case[\"Nk_dims\"], theta)\n            energies_for_case.append(energy)\n        \n        # Calculate max deviation from reference energy\n        e_ref = energies_for_case[0]\n        delta_e_max = np.max(np.abs(np.array(energies_for_case) - e_ref))\n        \n        # Check against tolerance\n        passed = delta_e_max <= case[\"tolerance\"]\n        results.append(passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In practice, the rich information contained in the anisotropy energy surface is often condensed into a few key parameters. This exercise develops the essential skill of extracting these magnetocrystalline anisotropy constants, such as $K_1$ and $K_2$, from calculated data. You will implement the torque method, which relies on the fundamental relationship $T(\\theta) = -\\partial E/\\partial \\theta$, and use a least-squares fitting procedure to determine the constants, providing a powerful and often more detailed alternative to relying on total energy differences alone.",
            "id": "3462916",
            "problem": "You are given a uniaxial magnetocrystalline anisotropy model for hexagonal close-packed cobalt, where the magnetocrystalline anisotropy energy as a function of polar angle is represented by the series expansion $E(\\theta) \\approx K_1 \\sin^2 \\theta + K_2 \\sin^4 \\theta$. The fundamental base you must use is the mathematical definition of torque $T(\\theta)$ as the negative angular derivative of energy, i.e., $T(\\theta) = -\\frac{\\partial E}{\\partial \\theta}$, together with the assumption that the series expansion above is the leading-order symmetry-allowed form for uniaxial systems. Using these foundations, you must derive and implement an algorithm that extracts the coefficients $K_1$ and $K_2$ from discrete torque data sampled at several angles, and then assess numerical consistency by comparing the predicted hard-minus-easy axis energy difference from the fitted coefficients against a direct total energy difference supplied independently.\n\nYour implementation must adhere to the following scientifically realistic and self-consistent scenario and constraints:\n\n- Use angles in radians.\n- Use microelectronvolt per formula unit as the energy unit; write this as $\\mu \\mathrm{eV}$ per formula unit.\n- Use microelectronvolt per formula unit per radian as the torque unit; write this as $\\mu \\mathrm{eV}$ per formula unit per radian.\n- Do not assume any shortcut formulas beyond the given definitions. Your derivation should start from $E(\\theta) \\approx K_1 \\sin^2 \\theta + K_2 \\sin^4 \\theta$ and $T(\\theta) = -\\frac{\\partial E}{\\partial \\theta}$, and proceed by demonstrating how to estimate $K_1$ and $K_2$ from a finite set of measured torques using a mathematically justified procedure.\n\nYour program must perform the following, using the four test cases below:\n\n- For each test case, you are given a set of angles $\\{\\theta_i\\}$, a corresponding set of measured torques $\\{T_i\\}$, and two energy values $E(\\theta=0)$ and $E(\\theta=\\pi/2)$.\n- Using the torque data only, compute the least-squares estimates $\\hat{K}_1$ and $\\hat{K}_2$.\n- Compute $\\Delta E_{\\text{fit}} = \\hat{K}_1 + \\hat{K}_2$.\n- Compute the direct energy difference $\\Delta E_{\\text{direct}} = E(\\theta=\\pi/2) - E(\\theta=0)$.\n- Compute the absolute difference $d = |\\Delta E_{\\text{fit}} - \\Delta E_{\\text{direct}}|$.\n- With a consistency tolerance $\\tau = 1.0$ $\\mu \\mathrm{eV}$, define a boolean consistency flag $c$ that is $c = \\text{True}$ if $d \\le \\tau$, else $c = \\text{False}$.\n\nTest suite parameter values:\n\n- Case $1$ (noiseless, moderate anisotropy):\n  - Angles: $\\left[\\frac{\\pi}{12}, \\frac{\\pi}{6}, \\frac{\\pi}{4}, \\frac{\\pi}{3}, \\frac{5\\pi}{12}\\right]$.\n  - Torques (in $\\mu \\mathrm{eV}$ per formula unit per radian): $\\left[-30.3349364905389, -54.1265877354711, -65.0, -58.45671475438329, -34.6650635094611\\right]$.\n  - Energies (in $\\mu \\mathrm{eV}$ per formula unit): $E(\\theta=0) = 0.0$, $E(\\theta=\\pi/2) = 65.0$.\n- Case $2$ (noisy torque and energy data, same underlying scale):\n  - Angles: $\\left[\\frac{\\pi}{12}, \\frac{\\pi}{6}, \\frac{\\pi}{4}, \\frac{\\pi}{3}, \\frac{5\\pi}{12}\\right]$.\n  - Torques (in $\\mu \\mathrm{eV}$ per formula unit per radian): $\\left[-30.1349364905389, -54.2265877354711, -64.95, -58.45671475438329, -34.8150635094611\\right]$.\n  - Energies (in $\\mu \\mathrm{eV}$ per formula unit): $E(\\theta=0) = 0.0$, $E(\\theta=\\pi/2) = 65.3$.\n- Case $3$ (vanishing fourth-order term):\n  - Angles: $\\left[\\frac{\\pi}{12}, \\frac{\\pi}{6}, \\frac{\\pi}{4}, \\frac{\\pi}{3}, \\frac{5\\pi}{12}\\right]$.\n  - Torques (in $\\mu \\mathrm{eV}$ per formula unit per radian): $\\left[-15.0, -25.98076211353316, -30.0, -25.98076211353316, -15.0\\right]$.\n  - Energies (in $\\mu \\mathrm{eV}$ per formula unit): $E(\\theta=0) = 0.0$, $E(\\theta=\\pi/2) = 30.0$.\n- Case $4$ (very small anisotropy):\n  - Angles: $\\left[\\frac{\\pi}{12}, \\frac{\\pi}{6}, \\frac{\\pi}{4}, \\frac{\\pi}{3}, \\frac{5\\pi}{12}\\right]$.\n  - Torques (in $\\mu \\mathrm{eV}$ per formula unit per radian): $\\left[-0.5334936490538904, -1.0825317547305483, -1.5, -1.5155444566227678, -0.9665063509461097\\right]$.\n  - Energies (in $\\mu \\mathrm{eV}$ per formula unit): $E(\\theta=0) = 0.0$, $E(\\theta=\\pi/2) = 1.5$.\n\nAngle unit is radians. Energy unit is $\\mu \\mathrm{eV}$ per formula unit. Torque unit is $\\mu \\mathrm{eV}$ per formula unit per radian. All computations and outputs must respect these units.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist of the form $[\\hat{K}_1,\\hat{K}_2,\\Delta E_{\\text{direct}},\\Delta E_{\\text{fit}},d,c]$. For example, a valid output format is $[[a_1,b_1,x_1,y_1,z_1,t_1],[a_2,b_2,x_2,y_2,z_2,t_2],[a_3,b_3,x_3,y_3,z_3,t_3],[a_4,b_4,x_4,y_4,z_4,t_4]]$ where $a_i$, $b_i$, $x_i$, $y_i$, and $z_i$ are floats and $t_i$ is a boolean. Your program must exactly print this single line and nothing else.",
            "solution": "The problem presented is valid. It is scientifically grounded in the principles of magnetism, specifically the phenomenological model of uniaxial magnetocrystalline anisotropy. It is well-posed, providing a complete and consistent set of data and definitions to allow for a unique and meaningful solution via a standard numerical method. The objectives are stated with clarity and precision, free of subjective or ambiguous language.\n\nThe core of the problem is to determine the magnetocrystalline anisotropy coefficients, $K_1$ and $K_2$, from a set of discrete torque measurements. The physical model provided for the anisotropy energy $E$ as a function of the polar angle $\\theta$ (the angle between the magnetization vector and the crystallographic $c$-axis) is the truncated series expansion for a uniaxial system:\n$$E(\\theta) = K_1 \\sin^2 \\theta + K_2 \\sin^4 \\theta$$\nHere, $\\theta=0$ corresponds to the easy magnetization axis (minimum energy) and $\\theta=\\pi/2$ corresponds to the hard magnetization axis (maximum energy), assuming $K_1+K_2 > 0$.\n\nThe torque, $T(\\theta)$, exerted on the magnetic moment by the crystal lattice is defined as the negative derivative of the anisotropy energy with respect to the angle:\n$$T(\\theta) = -\\frac{\\partial E}{\\partial \\theta}$$\nWe derive the theoretical expression for the torque by differentiating the energy expression with respect to $\\theta$:\n$$T(\\theta) = -\\frac{\\partial}{\\partial \\theta} \\left( K_1 \\sin^2 \\theta + K_2 \\sin^4 \\theta \\right)$$\nUsing the chain rule, $\\frac{d}{d\\theta}\\sin^n\\theta = n\\sin^{n-1}\\theta\\cos\\theta$, we obtain:\n$$T(\\theta) = - \\left( K_1 \\cdot 2\\sin\\theta\\cos\\theta + K_2 \\cdot 4\\sin^3\\theta\\cos\\theta \\right)$$\nThis equation expresses the torque $T(\\theta)$ as a linear combination of the unknown coefficients $K_1$ and $K_2$:\n$$T(\\theta) = (-2\\sin\\theta\\cos\\theta) K_1 + (-4\\sin^3\\theta\\cos\\theta) K_2$$\n\nGiven a set of $N$ experimental or computational measurements of torque $\\{T_i\\}$ at corresponding angles $\\{\\theta_i\\}$, we can formulate a system of linear equations. For each measurement $i \\in \\{1, ..., N\\}$:\n$$T_i = (-2\\sin\\theta_i\\cos\\theta_i) K_1 + (-4\\sin^3\\theta_i\\cos\\theta_i) K_2 + \\epsilon_i$$\nwhere $\\epsilon_i$ represents measurement noise or model error. This system can be written in matrix form as $\\mathbf{y} = \\mathbf{X}\\mathbf{k} + \\mathbf{\\epsilon}$, where:\n$$\n\\mathbf{y} = \\begin{pmatrix} T_1 \\\\ T_2 \\\\ \\vdots \\\\ T_N \\end{pmatrix}, \\quad\n\\mathbf{k} = \\begin{pmatrix} K_1 \\\\ K_2 \\end{pmatrix}, \\quad\n\\mathbf{X} = \\begin{pmatrix}\n-2\\sin\\theta_1\\cos\\theta_1 & -4\\sin^3\\theta_1\\cos\\theta_1 \\\\\n-2\\sin\\theta_2\\cos\\theta_2 & -4\\sin^3\\theta_2\\cos\\theta_2 \\\\\n\\vdots & \\vdots \\\\\n-2\\sin\\theta_N\\cos\\theta_N & -4\\sin^3\\theta_N\\cos\\theta_N\n\\end{pmatrix}\n$$\nThe goal is to find the coefficient vector $\\hat{\\mathbf{k}}$ that best fits the data. The method of ordinary least squares (OLS) provides such an estimate by minimizing the sum of the squares of the residuals, $||\\mathbf{y} - \\mathbf{X}\\mathbf{k}||^2$. The OLS solution is given by the normal equations:\n$$\\hat{\\mathbf{k}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}$$\nThis computation will yield the estimated coefficients, $\\hat{K}_1$ and $\\hat{K}_2$.\n\nThe second part of the task is to perform a consistency check. The energy difference between the hard axis ($\\theta=\\pi/2$) and the easy axis ($\\theta=0$) can be calculated from the fitted model. Let this be $\\Delta E_{\\text{fit}}$.\n$$E(\\pi/2) = K_1 \\sin^2(\\pi/2) + K_2 \\sin^4(\\pi/2) = K_1(1)^2 + K_2(1)^4 = K_1 + K_2$$\n$$E(0) = K_1 \\sin^2(0) + K_2 \\sin^4(0) = 0$$\nThus, the predicted energy difference is:\n$$\\Delta E_{\\text{fit}} = E(\\pi/2) - E(0) = \\hat{K}_1 + \\hat{K}_2$$\nThis value is to be compared with the directly provided energy difference, $\\Delta E_{\\text{direct}} = E(\\theta=\\pi/2) - E(\\theta=0)$, where the energy values are supplied independently of the torque data. The absolute difference $d = |\\Delta E_{\\text{fit}} - \\Delta E_{\\text{direct}}|$ is calculated and compared against a given tolerance $\\tau = 1.0$ $\\mu \\mathrm{eV}$ per formula unit. A consistency flag $c$ is set to $\\text{True}$ if $d \\le \\tau$, and $\\text{False}$ otherwise. This procedure validates the consistency between the differential (torque) and integral (total energy) data within the framework of the chosen model.\n\nThe implementation will construct the matrix $\\mathbf{X}$ and vector $\\mathbf{y}$ for each test case, solve for $\\hat{\\mathbf{k}}$ using `numpy.linalg.lstsq`, and then compute the required quantities for the consistency check.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for magnetocrystalline anisotropy coefficients and performs a consistency check\n    for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (noiseless, moderate anisotropy)\n        {\n            \"angles\": np.array([np.pi/12, np.pi/6, np.pi/4, np.pi/3, 5*np.pi/12]),\n            \"torques\": np.array([-30.3349364905389, -54.1265877354711, -65.0, -58.45671475438329, -34.6650635094611]),\n            \"E0\": 0.0,\n            \"Epi_2\": 65.0\n        },\n        # Case 2 (noisy torque and energy data, same underlying scale)\n        {\n            \"angles\": np.array([np.pi/12, np.pi/6, np.pi/4, np.pi/3, 5*np.pi/12]),\n            \"torques\": np.array([-30.1349364905389, -54.2265877354711, -64.95, -58.45671475438329, -34.8150635094611]),\n            \"E0\": 0.0,\n            \"Epi_2\": 65.3\n        },\n        # Case 3 (vanishing fourth-order term)\n        {\n            \"angles\": np.array([np.pi/12, np.pi/6, np.pi/4, np.pi/3, 5*np.pi/12]),\n            \"torques\": np.array([-15.0, -25.98076211353316, -30.0, -25.98076211353316, -15.0]),\n            \"E0\": 0.0,\n            \"Epi_2\": 30.0\n        },\n        # Case 4 (very small anisotropy)\n        {\n            \"angles\": np.array([np.pi/12, np.pi/6, np.pi/4, np.pi/3, 5*np.pi/12]),\n            \"torques\": np.array([-0.5334936490538904, -1.0825317547305483, -1.5, -1.5155444566227678, -0.9665063509461097]),\n            \"E0\": 0.0,\n            \"Epi_2\": 1.5\n        }\n    ]\n\n    results = []\n    \n    # Consistency tolerance in micro-eV per formula unit\n    tolerance = 1.0\n\n    for case in test_cases:\n        angles = case[\"angles\"]\n        torques = case[\"torques\"]\n        E0 = case[\"E0\"]\n        Epi_2 = case[\"Epi_2\"]\n\n        # Construct the design matrix X and the observation vector y\n        # T(theta) = (-2*sin(theta)*cos(theta)) * K1 + (-4*sin^3(theta)*cos(theta)) * K2\n        \n        s = np.sin(angles)\n        c = np.cos(angles)\n        \n        # Column for K1 coefficient\n        col1 = -2 * s * c\n        \n        # Column for K2 coefficient\n        col2 = -4 * (s**3) * c\n        \n        # Design matrix X\n        X = np.vstack((col1, col2)).T\n        \n        # Observation vector y\n        y = torques\n        \n        # Solve the linear least-squares problem Xk = y for k = [K1, K2]\n        # np.linalg.lstsq returns the solution vector as the first element of a tuple.\n        k_hat, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        K1_hat = k_hat[0]\n        K2_hat = k_hat[1]\n        \n        # Compute the energy difference from the fitted coefficients\n        # Delta_E_fit = E(pi/2) - E(0) = (K1_hat + K2_hat) - 0\n        delta_E_fit = K1_hat + K2_hat\n        \n        # Compute the direct energy difference from provided values\n        delta_E_direct = Epi_2 - E0\n        \n        # Compute the absolute difference\n        abs_diff = np.abs(delta_E_fit - delta_E_direct)\n        \n        # Check for consistency against the tolerance\n        is_consistent = abs_diff <= tolerance\n        \n        # Store results for this case\n        results.append([K1_hat, K2_hat, delta_E_direct, delta_E_fit, abs_diff, is_consistent])\n\n    # Format the final output string according to the problem specification.\n    # Each sublist is converted to a string, with spaces removed.\n    # These strings are then joined by commas and enclosed in brackets.\n    formatted_results = [str(r).replace(\" \", \"\") for r in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    # The final print statement must match the specified format exactly.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate goal of many magnetocrystalline anisotropy calculations is to determine the preferred orientation of magnetization in a material, known as its easy state. This practice moves beyond simple uniaxial systems to the more general case of reconstructing the full anisotropy energy surface $E(\\theta, \\phi)$ for a tetragonal crystal. By systematically mapping the energy landscape and locating its global minimum, you will learn to classify the magnetic ground state as easy-axis, easy-plane, or the more complex easy-cone state, a crucial step in predicting the behavior of magnetic materials.",
            "id": "3462922",
            "problem": "You are tasked with building a complete, runnable program that reconstructs a magnetocrystalline anisotropy energy surface and classifies the type of magnetic easy state based on the location of minima. Your program must compute the energy on a spherical grid of magnetization orientations using physically motivated symmetry-invariant terms and must implement constrained magnetization rotation paths. Angles must be treated in radians, and energy density must be in $\\mathrm{J}/\\mathrm{m}^3$.\n\nThe foundational base is the following: magnetocrystalline anisotropy energy (MAE) arises from spin-orbit coupling and depends only on the direction of the magnetization vector relative to the crystal lattice. For a tetragonal crystal, a well-tested symmetry-invariant expansion of the energy density $E(\\theta,\\phi)$ as a function of the spherical angles $\\theta$ and $\\phi$ incorporates an out-of-plane uniaxial component and an in-plane fourfold component. Use a truncated expansion up to fourth order in the sine of the polar angle $\\theta$ together with a fourfold azimuthal dependence:\n$$\nE(\\theta,\\phi) = K_1 \\sin^2\\theta + K_2 \\sin^4\\theta + K_4 \\sin^4\\theta \\cos(4\\phi),\n$$\nwhere $K_1$, $K_2$, and $K_4$ are anisotropy constants expressed in $\\mathrm{J}/\\mathrm{m}^3$, $\\theta \\in [0,\\pi]$, and $\\phi \\in [0,2\\pi)$.\n\nYour program must:\n\n- Construct a two-dimensional grid for $(\\theta,\\phi)$ with $\\theta$ sampled at $N_\\theta$ points and $\\phi$ sampled at $N_\\phi$ points, both uniformly spaced in radians. Use $N_\\theta = 361$ and $N_\\phi = 721$, with $\\phi$ sampled on $[0,2\\pi)$ using an exclusive endpoint to avoid duplication at $\\phi = 2\\pi$.\n- Implement constrained magnetization rotation paths as follows:\n    - Meridional paths: fix $\\phi$ to the set $\\{\\phi_0\\}$ where $\\phi_0 \\in \\{0,\\pi/4,\\pi/2,3\\pi/4\\}$, and vary $\\theta$ over its full range.\n    - Parallel paths: fix $\\theta$ to the set $\\{\\theta_0\\}$ where $\\theta_0 \\in \\{0,\\pi/6,\\pi/3,\\pi/2\\}$, and vary $\\phi$ over its full range.\n  Compute $E(\\theta,\\phi)$ along these constrained paths in addition to the full grid. Use these path evaluations to corroborate the location of minima found on the full grid; however, the classification must be based on the global minimum over the full grid.\n- Identify the global minimizer $(\\theta_{\\min},\\phi_{\\min})$ on the full grid, with a default selection rule for perfectly flat energy surfaces: if $\\max(E)-\\min(E) < \\varepsilon$ for a small threshold $\\varepsilon$, choose $\\theta_{\\min} = 0$ and $\\phi_{\\min} = 0$.\n- Classify the easy state type solely from $\\theta_{\\min}$:\n  - Easy axis: $\\theta_{\\min} = 0$ (within a numerical tolerance),\n  - Easy plane: $\\theta_{\\min} = \\pi/2$ (within a numerical tolerance),\n  - Easy cone: $0 < \\theta_{\\min} < \\pi/2$.\n  Use a numerical tolerance of $\\delta = 10^{-6}$ radians to decide equality to the boundaries.\n- Return the triplet $[\\theta_{\\min},\\phi_{\\min},b]$ where $b$ is a boolean that is $\\text{True}$ if and only if the state is easy-cone, and $\\text{False}$ otherwise. Angles are in radians and energy density is only used internally in $\\mathrm{J}/\\mathrm{m}^3$ as specified.\n\nTest suite and parameters:\n\nYour program must execute the following test suite of parameter sets $(K_1,K_2,K_4)$, all in $\\mathrm{J}/\\mathrm{m}^3$:\n\n- Case $\\mathbf{A}$ (general easy-axis, no azimuthal anisotropy): $(K_1,K_2,K_4) = (1.0\\times 10^5, 1.0\\times 10^4, 0)$.\n- Case $\\mathbf{B}$ (easy-plane, no azimuthal anisotropy): $(K_1,K_2,K_4) = (-1.0\\times 10^5, 0, 0)$.\n- Case $\\mathbf{C}$ (easy-cone with fourfold azimuthal anisotropy): $(K_1,K_2,K_4) = (1.0\\times 10^4, -3.0\\times 10^4, 2.0\\times 10^3)$.\n- Case $\\mathbf{D}$ (perfectly flat energy): $(K_1,K_2,K_4) = (0, 0, 0)$.\n- Case $\\mathbf{E}$ (easy-plane with strong in-plane preference): $(K_1,K_2,K_4) = (-1.0\\times 10^4, 0, -5.0\\times 10^3)$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of the list must itself be a list of the form $[\\theta_{\\min},\\phi_{\\min},b]$, in the same order as the test suite. For example, the output should look like\n$$\n[\\,[\\theta_{\\min}^{(A)},\\phi_{\\min}^{(A)},b^{(A)}],[\\theta_{\\min}^{(B)},\\phi_{\\min}^{(B)},b^{(B)}],\\dots\\,],\n$$\nwith angles in radians and $b$ a boolean.",
            "solution": "The user-provided problem has been rigorously validated and is determined to be **valid**. It is scientifically grounded in the established theory of magnetism, specifically the phenomenological model of magnetocrystalline anisotropy for tetragonal systems. The problem is well-posed, providing a clear objective, a complete set of equations, parameters, and boundary conditions, allowing for a unique and meaningful numerical solution. The language is objective and formal. We may therefore proceed with the solution.\n\nThe problem requires the numerical minimization of the magnetocrystalline anisotropy energy (MAE) density, $E(\\theta, \\phi)$, for a tetragonal crystal system to determine its magnetic ground state, or \"easy state\". The provided energy expression is a truncated series expansion in terms of the direction cosines of the magnetization vector, represented by spherical coordinates $(\\theta, \\phi)$:\n$$\nE(\\theta,\\phi) = K_1 \\sin^2\\theta + K_2 \\sin^4\\theta + K_4 \\sin^4\\theta \\cos(4\\phi)\n$$\nHere, $K_1$, $K_2$, and $K_4$ are the temperature-dependent anisotropy constants, $\\theta \\in [0, \\pi]$ is the polar angle, and $\\phi \\in [0, 2\\pi)$ is the azimuthal angle. The goal is to find the angular coordinates $(\\theta_{\\min}, \\phi_{\\min})$ that globally minimize this function for several given sets of constants.\n\nThe computational strategy involves a direct search on a discrete grid of angles. We construct a uniform grid for $\\theta$ and $\\phi$ with the specified resolutions of $N_\\theta = 361$ points on $[0, \\pi]$ and $N_\\phi = 721$ points on $[0, 2\\pi)$, ensuring the $\\phi=2\\pi$ endpoint is excluded to prevent redundancy. The `numpy` library is exceptionally well-suited for this task, as its vectorized operations allow for the efficient computation of the energy $E$ over the entire two-dimensional grid without explicit loops.\n\nFor each test case, defined by a triplet $(K_1, K_2, K_4)$, the following procedure is executed:\n1.  A two-dimensional grid of $(\\theta, \\phi)$ values is generated.\n2.  The energy density $E(\\theta, \\phi)$ is calculated at every point on this grid, yielding a matrix of energy values.\n3.  A special case for a magnetically isotropic system (flat energy surface) is handled. If the difference between the maximum and minimum calculated energy is below a small numerical threshold, $\\varepsilon$, the system is treated as having no preference. As per the problem specification, the minimizer is set to $(\\theta_{\\min}, \\phi_{\\min}) = (0, 0)$. A scientifically reasonable threshold of $\\varepsilon = 10^{-9} \\, \\mathrm{J}/\\mathrm{m}^3$ is chosen, which is appropriate for standard double-precision floating-point arithmetic relative to the energy scales involved.\n4.  For the general case, the indices of the minimum value in the energy matrix are located. These indices are then mapped back to the corresponding $(\\theta, \\phi)$ values, which are denoted $(\\theta_{\\min}, \\phi_{\\min})$.\n5.  The role of constrained paths (meridional and parallel) is noted as a method for corroborating the minima, which is sound scientific practice. However, as the problem mandates that the final classification must be based on the global minimum over the full grid, the implementation will focus directly on the full grid search to produce the required output.\n\nThe final step is to classify the type of magnetic easy state based on the value of $\\theta_{\\min}$. The classification rules given are:\n-   Easy axis: $\\theta_{\\min} \\approx 0$\n-   Easy plane: $\\theta_{\\min} \\approx \\pi/2$\n-   Easy cone: $0 < \\theta_{\\min} < \\pi/2$\n\nA critical observation is the symmetry of the energy function with respect to the equatorial plane, i.e., $E(\\theta, \\phi) = E(\\pi - \\theta, \\phi)$, arising from the use of $\\sin^2\\theta$. This means any minimum at an angle $\\theta_0 \\in (0, \\pi/2)$ is degenerate with a minimum at $\\pi - \\theta_0 \\in (\\pi/2, \\pi)$. The provided classification rules are defined for $\\theta_{\\min} \\in [0, \\pi/2]$. To ensure a physically robust classification regardless of which degenerate minimum is found by the numerical search, we base the classification on proximity to the high-symmetry states. A state is \"easy axis\" if magnetization aligns with the z-axis (i.e., $\\theta_{\\min} \\approx 0$ or $\\theta_{\\min} \\approx \\pi$). It is \"easy plane\" if it lies in the xy-plane ($\\theta_{\\min} \\approx \\pi/2$). An \"easy cone\" state is any state that is neither easy axis nor easy plane. This captures the complete physical picture. The numerical tolerance for these comparisons is given as $\\delta = 10^{-6}$ radians.\n\nA boolean flag, $b$, is set to $\\text{True}$ if the state is classified as an easy cone, and $\\text{False}$ otherwise. The resulting triplet $[\\theta_{\\min}, \\phi_{\\min}, b]$ is computed for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the magnetocrystalline anisotropy energy (MAE) on a spherical grid,\n    finds the energy minimum, and classifies the magnetic easy state.\n    \"\"\"\n\n    # Define the constants and parameters for the calculation.\n    N_theta = 361\n    N_phi = 721\n    delta = 1e-6  # Tolerance for angle classification in radians\n    epsilon = 1e-9 # Threshold for detecting a flat energy surface in J/m^3\n\n    # Define the test suite of anisotropy constants (K1, K2, K4) in J/m^3.\n    test_cases = [\n        (1.0e5, 1.0e4, 0.0),      # Case A: Easy-axis\n        (-1.0e5, 0.0, 0.0),       # Case B: Easy-plane\n        (1.0e4, -3.0e4, 2.0e3),  # Case C: Easy-cone\n        (0.0, 0.0, 0.0),          # Case D: Flat energy\n        (-1.0e4, 0.0, -5.0e3),     # Case E: Easy-plane with in-plane preference\n    ]\n\n    # Generate the spherical coordinate grids.\n    # theta spans [0, pi] inclusive.\n    theta_vec = np.linspace(0, np.pi, N_theta)\n    # phi spans [0, 2*pi) exclusive of the endpoint.\n    phi_vec = np.linspace(0, 2 * np.pi, N_phi, endpoint=False)\n    \n    # Create 2D meshgrid for vectorized calculations.\n    # 'ij' indexing ensures THETA's shape is (N_theta, N_phi).\n    THETA, PHI = np.meshgrid(theta_vec, phi_vec, indexing='ij')\n\n    # Pre-calculate trigonometric terms for efficiency.\n    SIN_THETA = np.sin(THETA)\n    SIN2_THETA = SIN_THETA**2\n    SIN4_THETA = SIN2_THETA**2\n    COS_4PHI = np.cos(4 * PHI)\n\n    results = []\n    \n    for K1, K2, K4 in test_cases:\n        # Calculate the magnetocrystalline anisotropy energy density over the grid.\n        E = K1 * SIN2_THETA + K2 * SIN4_THETA + K4 * SIN4_THETA * COS_4PHI\n\n        # Check for a flat energy surface (isotropic case).\n        if np.max(E) - np.min(E) < epsilon:\n            theta_min = 0.0\n            phi_min = 0.0\n        else:\n            # Find the 2D index of the global minimum energy.\n            min_idx = np.unravel_index(np.argmin(E), E.shape)\n            \n            # Retrieve the corresponding theta and phi values.\n            theta_min = theta_vec[min_idx[0]]\n            phi_min = phi_vec[min_idx[1]]\n\n        # Classify the easy state based on the angle theta_min.\n        # The classification logic is designed to be robust against the E(theta)=E(pi-theta) symmetry.\n        # An easy-axis state corresponds to theta near 0 or pi.\n        is_easy_axis = (abs(theta_min) <= delta) or (abs(theta_min - np.pi) <= delta)\n        # An easy-plane state corresponds to theta near pi/2.\n        is_easy_plane = abs(theta_min - np.pi / 2) <= delta\n        \n        # An easy-cone state is any state that is neither axis nor plane.\n        is_easy_cone = not (is_easy_axis or is_easy_plane)\n        \n        # The returned boolean b is True if and only if the state is easy-cone.\n        b = is_easy_cone\n\n        results.append([theta_min, phi_min, b])\n\n    # Format the final output as a string representation of a list of lists.\n    # The `str()` of a list produces the required '[item1, item2, ...]' format.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}