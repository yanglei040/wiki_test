{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of computational mechanics is the translation of continuum principles into discrete numerical models. This exercise provides direct, hands-on experience with this process by focusing on the construction of the stiffness matrix, the fundamental building block of the Finite Element Method (FEM). By deriving and implementing the stiffness matrix for a constant-strain triangle, you will solidify your understanding of how shape functions, the strain-displacement matrix ($\\mathbf{B}$), and the constitutive matrix ($\\mathbf{D}$) combine to link nodal forces to nodal displacements, forming the basis for solving complex elasticity problems .",
            "id": "3490647",
            "problem": "You are asked to construct the constant-strain triangular element stiffness matrix for a two-dimensional, isotropic, linearly elastic solid under plane strain conditions. The starting point is the small-strain linearized kinematics and Hooke’s law. Use the following fundamental bases:\n\n- Kinematics: the infinitesimal strain tensor is defined by the symmetric gradient of the displacement vector, that is, $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\top}\\right)$. In two dimensions, with engineering shear strain $\\gamma_{xy} = 2 \\varepsilon_{xy}$, the strain vector is $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} \\varepsilon_{xx} & \\varepsilon_{yy} & \\gamma_{xy}\\end{bmatrix}^{\\top}$.\n- Constitutive law: for isotropic linear elasticity in plane strain, $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$, where $\\boldsymbol{\\sigma} = \\begin{bmatrix}\\sigma_{xx} & \\sigma_{yy} & \\tau_{xy}\\end{bmatrix}^{\\top}$ and the elasticity matrix $\\mathbf{D}$ is determined by the Lamé parameters $\\lambda$ and $\\mu$ which are functions of Young’s modulus $E$ and Poisson’s ratio $\\nu$.\n- Principle of Virtual Work for the Finite Element Method (FEM): the element stiffness matrix for a three-node linear triangle with thickness $t$ is $\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^{\\top}\\mathbf{D}\\mathbf{B}\\,t\\, d\\Omega$, where $\\mathbf{B}$ maps nodal displacements to strains via the strain-displacement relation and $\\mathbf{D}$ is the constitutive matrix.\n\nTasks:\n\n1. For a given triangle with nodes at coordinates $(x_i,y_i)$ for $i \\in \\{1,2,3\\}$, construct the linear shape functions $N_i(x,y)$ satisfying $N_i(x_j,y_j) = \\delta_{ij}$ and $N_1+N_2+N_3=1$. Use these to explicitly form the gradient $\\nabla N_i$ for each node, which is constant over the element domain $\\Omega_e$ for a linear triangle. From these gradients, assemble the matrix $\\mathbf{B}$ that maps nodal displacements $\\mathbf{u}_e = \\begin{bmatrix}u_1 & v_1 & u_2 & v_2 & u_3 & v_3\\end{bmatrix}^{\\top}$ to the strain vector $\\boldsymbol{\\varepsilon}$ through $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\,\\mathbf{u}_e$.\n2. Using the isotropic plane strain constitutive law expressed in terms of $E$ and $\\nu$, build the matrix $\\mathbf{D}$.\n3. Compute the element stiffness $\\mathbf{K}_e$ by evaluating the integral. For a linear triangle, $\\mathbf{B}$ and $\\mathbf{D}$ are constant over $\\Omega_e$, so the integral reduces to the product of the element area and the integrand.\n4. Implement a program that, for each test case below, computes $\\mathbf{K}_e$ and returns the flattened $6\\times 6$ matrix in row-major order as a list of $36$ floating-point numbers. Each entry corresponds to stiffness in Newton per meter, that is, in units of $\\mathrm{N/m}$. Each floating-point number in the output must be rounded to six significant figures. Angles do not appear in this problem. There are no percentages.\n\nUse the following test suite. Each test case provides:\n- Node coordinates in meters $(x_i,y_i)$ for $i=1,2,3$,\n- Young’s modulus in Pascals $E$,\n- Poisson’s ratio $\\nu$ (dimensionless),\n- Thickness $t$ in meters.\n\nTest cases:\n- Case 1 (happy path): $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(1,0)$, $(x_3,y_3)=(0,1)$, $E=210\\times 10^{9}$, $\\nu=0.30$, $t=0.01$.\n- Case 2 (equilateral geometry): $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(1,0)$, $(x_3,y_3)=\\left(0.5, \\sqrt{3}/2\\right)$, $E=70\\times 10^{9}$, $\\nu=0.25$, $t=0.005$.\n- Case 3 (nearly incompressible, small element): $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(0.001,0)$, $(x_3,y_3)=(0,0.002)$, $E=100\\times 10^{9}$, $\\nu=0.49$, $t=0.001$.\n- Case 4 (clockwise node ordering): $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(0,2)$, $(x_3,y_3)=(2,0)$, $E=50\\times 10^{9}$, $\\nu=0.20$, $t=0.02$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The outer list contains one entry per test case in the order listed above. Each entry is itself a bracketed list of the $36$ entries of $\\mathbf{K}_e$ flattened in row-major order. The only acceptable output format is:\n- A single line,\n- No spaces anywhere,\n- Brackets and commas exactly as separators,\n- Each number rounded to six significant figures in $\\mathrm{N/m}$.\n\nFor example, the overall structure must be like:\n\"[[k11_case1,k12_case1,...,k66_case1],[k11_case2,...,k66_case2],[k11_case3,...,k66_case3],[k11_case4,...,k66_case4]]\"\n\nNo other text should be printed. The input is embedded in the program; no user input is required. The program must be complete and runnable.",
            "solution": "The posed problem is valid as it is scientifically grounded in the principles of linear elasticity and the Finite Element Method, is well-posed with sufficient data, and uses objective, formal language. We proceed with the solution.\n\nThe objective is to derive and implement the element stiffness matrix $\\mathbf{K}_e$ for a three-node constant-strain triangular (CST) element under a state of plane strain. The derivation follows a sequence of steps founded on the principles of continuum mechanics and finite element analysis.\n\nStep $1$: Kinematics and the Strain-Displacement Matrix ($\\mathbf{B}$)\n\nThe displacement field within the triangular element, $\\mathbf{u}(x,y) = \\begin{bmatrix} u(x,y) & v(x,y) \\end{bmatrix}^{\\top}$, is interpolated from the discrete nodal displacements $\\mathbf{u}_i = \\begin{bmatrix} u_i & v_i \\end{bmatrix}^{\\top}$ at the three nodes $i \\in \\{1, 2, 3\\}$. This interpolation is achieved using linear shape functions $N_i(x,y)$:\n$$ u(x,y) = \\sum_{i=1}^{3} N_i(x,y) u_i $$\n$$ v(x,y) = \\sum_{i=1}^{3} N_i(x,y) v_i $$\nThe shape functions $N_i(x,y)$ are uniquely defined by the nodal coordinates $(x_j, y_j)$ and the element's area, $A$. The area of the triangle can be calculated using the determinant of the augmented coordinate matrix:\n$$ A = \\frac{1}{2} \\det \\begin{pmatrix} 1 & x_1 & y_1 \\\\ 1 & x_2 & y_2 \\\\ 1 & x_3 & y_3 \\end{pmatrix} = \\frac{1}{2} \\left[ x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2) \\right] $$\nFor a linear triangular element, the gradients of the shape functions are constant over the element domain $\\Omega_e$. The gradient for the $i$-th shape function is:\n$$ \\nabla N_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\frac{1}{2A} \\begin{pmatrix} \\beta_i \\\\ \\gamma_i \\end{pmatrix} $$\nwhere the coefficients $\\beta_i$ and $\\gamma_i$ are functions of the nodal coordinates, defined by a cyclic permutation of indices $(i, j, k) \\in \\{(1, 2, 3), (2, 3, 1), (3, 1, 2)\\}$:\n$$ \\beta_i = y_j - y_k $$\n$$ \\gamma_i = x_k - x_j $$\nThe infinitesimal strain vector, using engineering shear strain $\\gamma_{xy}$, is defined as $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} \\varepsilon_{xx} & \\varepsilon_{yy} & \\gamma_{xy} \\end{bmatrix}^{\\top}$. The strain components are derived from the displacement field:\n$$ \\varepsilon_{xx} = \\frac{\\partial u}{\\partial x} = \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial x} u_i $$\n$$ \\varepsilon_{yy} = \\frac{\\partial v}{\\partial y} = \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial y} v_i $$\n$$ \\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x} = \\sum_{i=1}^3 \\left( \\frac{\\partial N_i}{\\partial y} u_i + \\frac{\\partial N_i}{\\partial x} v_i \\right) $$\nThis linear relationship between strain and nodal displacements is compactly written as $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u}_e$, where $\\mathbf{u}_e = \\begin{bmatrix} u_1 & v_1 & u_2 & v_2 & u_3 & v_3 \\end{bmatrix}^{\\top}$ is the vector of nodal degrees of freedom. The strain-displacement matrix $\\mathbf{B}$ is a $3 \\times 6$ matrix assembled from the gradients of the shape functions:\n$$ \\mathbf{B} = \\frac{1}{2A} \\begin{bmatrix} \\beta_1 & 0 & \\beta_2 & 0 & \\beta_3 & 0 \\\\ 0 & \\gamma_1 & 0 & \\gamma_2 & 0 & \\gamma_3 \\\\ \\gamma_1 & \\beta_1 & \\gamma_2 & \\beta_2 & \\gamma_3 & \\beta_3 \\end{bmatrix} $$\n\nStep $2$: Constitutive Law and the Elasticity Matrix ($\\mathbf{D}$)\n\nFor a linearly elastic, isotropic material under plane strain conditions ($\\varepsilon_{zz}=0$), the stress vector $\\boldsymbol{\\sigma} = \\begin{bmatrix} \\sigma_{xx} & \\sigma_{yy} & \\tau_{xy} \\end{bmatrix}^{\\top}$ is related to the strain vector $\\boldsymbol{\\varepsilon}$ by the generalized Hooke's Law, $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$. The $3 \\times 3$ plane strain elasticity matrix $\\mathbf{D}$ is expressed in terms of Young's modulus $E$ and Poisson's ratio $\\nu$:\n$$ \\mathbf{D} = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{bmatrix} 1-\\nu & \\nu & 0 \\\\ \\nu & 1-\\nu & 0 \\\\ 0 & 0 & \\frac{1-2\\nu}{2} \\end{bmatrix} $$\nThis matrix is symmetric and constant for a homogeneous material.\n\nStep $3$: Element Stiffness Matrix ($\\mathbf{K}_e$) Assembly\n\nThe element stiffness matrix $\\mathbf{K}_e$ quantifies the relationship between nodal forces and nodal displacements. It is derived from the principle of virtual work and is given by the integral over the element domain $\\Omega_e$:\n$$ \\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^{\\top} \\mathbf{D} \\mathbf{B} \\, t \\, d\\Omega $$\nwhere $t$ is the constant element thickness. A key property of the CST element is that the matrices $\\mathbf{B}$ and $\\mathbf{D}$ (for a homogeneous material) are constant throughout the element. Therefore, the integrand is constant and the integral simplifies to the product of the integrand and the element area, $|A|$:\n$$ \\mathbf{K}_e = (\\mathbf{B}^{\\top} \\mathbf{D} \\mathbf{B}) \\, t\\, |A| $$\nThe use of the absolute value of the area, $|A|$, ensures that the resulting stiffness matrix is positive definite, irrespective of whether the nodes are ordered in a clockwise or counter-clockwise sense. Substituting the full expression for $\\mathbf{B}$:\n$$ \\mathbf{K}_e = \\left( \\frac{1}{2A} \\mathbf{B}^* \\right)^{\\top} \\mathbf{D} \\left( \\frac{1}{2A} \\mathbf{B}^* \\right) \\, t \\, |A| = \\frac{t|A|}{4A^2} (\\mathbf{B}^*)^{\\top} \\mathbf{D} \\mathbf{B}^* $$\nwhere $\\mathbf{B}^* = 2A \\mathbf{B}$ is the strain-displacement matrix without the $1/(2A)$ scaling factor. Since $A^2 = |A|^2$, the expression simplifies to a computationally robust form:\n$$ \\mathbf{K}_e = \\frac{t}{4|A|} (\\mathbf{B}^*)^{\\top} \\mathbf{D} \\mathbf{B}^* $$\nThis final expression is implemented to compute the $6 \\times 6$ symmetric element stiffness matrix. The procedure involves calculating the geometric terms ($\\beta_i, \\gamma_i, |A|$), forming the matrices $\\mathbf{B}^*$ and $\\mathbf{D}$, and performing the specified matrix multiplications.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve for the element stiffness matrix for all test cases.\n    \"\"\"\n\n    def round_to_significant_figures(value, sf):\n        \"\"\"\n        Rounds a number to a specified number of significant figures.\n        \"\"\"\n        if value == 0:\n            return 0.0\n        # Calculate the position of the most significant digit\n        pos = math.floor(math.log10(abs(value)))\n        # Determine the number of decimal places for rounding\n        precision = sf - 1 - pos\n        return round(value, int(precision))\n\n    def get_stiffness_matrix(nodes, E, nu, t):\n        \"\"\"\n        Computes the constant-strain triangle stiffness matrix for plane strain.\n\n        Args:\n            nodes (list of tuples): A list of three (x, y) coordinate tuples for the triangle nodes.\n            E (float): Young's modulus in Pascals.\n            nu (float): Poisson's ratio (dimensionless).\n            t (float): Element thickness in meters.\n\n        Returns:\n            numpy.ndarray: The 6x6 element stiffness matrix.\n        \"\"\"\n        # Step 1: Nodal coordinates and element geometry\n        (x1, y1), (x2, y2), (x3, y3) = nodes\n        \n        # Calculate the signed area of the triangle. The formula's sign depends on node ordering (CCW is positive).\n        A_signed = 0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n        if abs(A_signed) < 1e-15:\n            # Handle degenerate triangles (collinear nodes)\n            raise ValueError(\"Element has zero area; nodes may be collinear.\")\n        \n        A_abs = abs(A_signed)\n\n        # Step 2: Components for the strain-displacement matrix (B)\n        # These are derived from the gradients of the linear shape functions.\n        # beta_i = y_j - y_k\n        # gamma_i = x_k - x_j\n        # (i,j,k) are cyclic permutations of (1,2,3)\n        beta1 = y2 - y3\n        beta2 = y3 - y1\n        beta3 = y1 - y2\n        \n        gamma1 = x3 - x2\n        gamma2 = x1 - x3\n        gamma3 = x2 - x1\n        \n        # B_star is the B matrix without the 1/(2A) scaling factor.\n        B_star = np.array([\n            [beta1, 0,     beta2, 0,     beta3, 0    ],\n            [0,     gamma1, 0,    gamma2, 0,     gamma3],\n            [gamma1, beta1, gamma2, beta2, gamma3, beta3 ]\n        ], dtype=float)\n\n        # Step 3: Constitutive matrix (D) for plane strain\n        # This matrix relates stress to strain for an isotropic material.\n        # The form used here is for engineering shear strain.\n        prefactor_D = E / ((1 + nu) * (1 - 2 * nu))\n        D = prefactor_D * np.array([\n            [1 - nu, nu,     0              ],\n            [nu,     1 - nu, 0              ],\n            [0,      0,      (1 - 2 * nu) / 2]\n        ], dtype=float)\n\n        # Step 4: Element stiffness matrix (K_e) assembly\n        # K_e = (t / (4 * |A|)) * B*^T @ D @ B*\n        K_e = (t / (4 * A_abs)) * (B_star.T @ D @ B_star)\n        \n        return K_e\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Right triangle, common material (steel-like)\n        {'nodes': [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0)], 'E': 210e9, 'nu': 0.30, 't': 0.01},\n        # Case 2: Equilateral triangle, different material (aluminum-like)\n        {'nodes': [(0.0, 0.0), (1.0, 0.0), (0.5, np.sqrt(3)/2)], 'E': 70e9, 'nu': 0.25, 't': 0.005},\n        # Case 3: Nearly incompressible material, small element\n        {'nodes': [(0.0, 0.0), (0.001, 0.0), (0.0, 0.002)], 'E': 100e9, 'nu': 0.49, 't': 0.001},\n        # Case 4: Clockwise node ordering to test robustness of area calculation\n        {'nodes': [(0.0, 0.0), (0.0, 2.0), (2.0, 0.0)], 'E': 50e9, 'nu': 0.20, 't': 0.02},\n    ]\n\n    # Process each test case and collect results\n    results_as_strings = []\n    for case in test_cases:\n        K_e = get_stiffness_matrix(case['nodes'], case['E'], case['nu'], case['t'])\n        \n        # Flatten the 6x6 matrix into a 1D array of 36 elements (row-major)\n        flattened_K = K_e.flatten()\n\n        # Round each value to 6 significant figures\n        rounded_values = [round_to_significant_figures(val, 6) for val in flattened_K]\n\n        # Format the numbers into a comma-separated string enclosed in brackets\n        case_result_string = f\"[{','.join(map(str, rounded_values))}]\"\n        results_as_strings.append(case_result_string)\n\n    # Final print statement in the exact required format: [[...],[...],...]\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from forward prediction to inverse characterization, a primary task in materials science is determining a material's properties from experimental or first-principles data. This practice simulates the workflow for extracting the full anisotropic stiffness tensor, $C_{ijkl}$, from a series of stress-strain measurements, akin to processing data from Density Functional Theory (DFT) calculations. More importantly, this exercise demonstrates that the quality of the characterization depends critically on the \"experimental\" design; by comparing different sets of applied strains, you will learn to use metrics like the condition number and A-optimality to design a computational experiment that minimizes parameter uncertainty and yields a robust estimate of the material's elastic constants .",
            "id": "3490639",
            "problem": "You are tasked with designing and implementing a computational experiment, grounded in first principles of small-strain linear elasticity, to extract the full anisotropic stiffness tensor $C_{ijkl}$ of a low-symmetry crystal from synthetic Density Functional Theory (DFT) data generated by applying finite deformations. Your objective is to construct and compare different sets of independent strain states, then select the one that minimizes the numerical covariance of the fitted stiffness parameters under a specified stress noise model. All calculations must be carried out in the standard Voigt representation with engineering shear convention.\n\nThe problem must be formulated and solved using only the following foundational concepts:\n- Small-strain kinematics: the infinitesimal strain tensor $\\,\\varepsilon_{ij} = \\tfrac{1}{2}\\left(\\partial u_i/\\partial x_j + \\partial u_j/\\partial x_i\\right)\\,$.\n- Linear elasticity (Hooke’s law): the Cauchy stress tensor $\\,\\sigma_{ij}\\,$ relates linearly to strain as $\\,\\sigma_{ij} = C_{ijkl}\\,\\varepsilon_{kl}\\,$.\n- Standard Voigt mapping with engineering shear convention:\n  - Strain vector $\\,\\mathbf{e} = [\\varepsilon_{11},\\varepsilon_{22},\\varepsilon_{33},2\\varepsilon_{23},2\\varepsilon_{13},2\\varepsilon_{12}]^\\top\\,$.\n  - Stress vector $\\,\\mathbf{s} = [\\sigma_{11},\\sigma_{22},\\sigma_{33},\\sigma_{23},\\sigma_{13},\\sigma_{12}]^\\top\\,$.\n  - In Voigt form, $\\,\\mathbf{s} = \\mathbf{C}\\,\\mathbf{e}\\,$ for a $\\,6\\times 6\\,$ symmetric positive-definite stiffness matrix $\\,\\mathbf{C}\\,$ that encodes the anisotropic stiffness tensor $\\,C_{ijkl}\\,$ under the above mapping.\n\nYour program must implement the following, starting strictly from these definitions and laws:\n\n- Construct a synthetic “ground-truth” full anisotropic stiffness matrix $\\,\\mathbf{C}^\\star\\,$ in gigapascals (GPa) as a symmetric positive-definite matrix in Voigt form by the following deterministic procedure:\n  - Let $\\,\\mathbf{A}\\in\\mathbb{R}^{6\\times 6}\\,$ be a matrix with entries drawn from the standard normal distribution using a pseudorandom generator seeded with $\\,20231105\\,$. Compute a thin $\\,\\mathbf{Q}\\mathbf{R}\\,$ factorization $\\,\\mathbf{A}=\\mathbf{Q}\\mathbf{R}\\,$ with $\\,\\mathbf{Q}\\in\\mathbb{R}^{6\\times 6}\\,$ orthogonal. Enforce a proper orthogonal matrix by multiplying $\\,\\mathbf{Q}\\,$ on the right by $\\,\\mathrm{diag}(\\mathrm{sign}(\\mathrm{diag}(\\mathbf{R})))\\,$.\n  - Let $\\,\\mathbf{D}=\\mathrm{diag}([300,250,220,100,90,80])\\,$ in GPa (all diagonal entries are in GPa). Define $\\,\\mathbf{C}^\\star = \\mathbf{Q}^\\top \\mathbf{D}\\,\\mathbf{Q}\\,$ in GPa. This produces a symmetric positive-definite $\\,\\mathbf{C}^\\star\\,$ that represents a low-symmetry crystal in Voigt form.\n\n- Generate synthetic DFT stresses without adding measurement noise: for each prescribed strain state $\\,\\mathbf{e}^{(s)}\\,$, compute $\\,\\mathbf{s}^{(s)} = \\mathbf{C}^\\star \\mathbf{e}^{(s)}\\,$ in GPa.\n\n- Fit the stiffness by ordinary least squares using only the definitions above. Stack $\\,S\\,$ strain states into a matrix $\\,\\mathbf{E}\\in\\mathbb{R}^{S\\times 6}\\,$ (each row is $\\,\\mathbf{e}^{(s)\\top}\\,$) and the corresponding stresses into $\\,\\mathbf{S}\\in\\mathbb{R}^{S\\times 6}\\,$ (each row is $\\,\\mathbf{s}^{(s)\\top}\\,$). Treat each stress component as a separate linear regression onto $\\,\\mathbf{E}\\,$ to obtain an unconstrained estimate $\\,\\widehat{\\mathbf{C}}\\in\\mathbb{R}^{6\\times 6}\\,$, then enforce major symmetry by projection $\\,\\widehat{\\mathbf{C}} \\leftarrow \\tfrac{1}{2}\\left(\\widehat{\\mathbf{C}}+\\widehat{\\mathbf{C}}^\\top\\right)\\,$. Do not use any formula other than what follows from $\\,\\mathbf{s}=\\mathbf{C}\\mathbf{e}\\,$ and standard least squares algebra.\n\n- Assume an uncorrelated, homoscedastic stress noise model in GPa: each stress component has zero-mean Gaussian noise with variance $\\,\\sigma_\\mathrm{noise}^2\\,$ (even though you will not add noise to the synthetic $\\mathbf{s}^{(s)}$), and use it to compute the parameter covariance implied by the design. Under this model, the per-row regression covariance is $\\,\\sigma_\\mathrm{noise}^2\\left(\\mathbf{E}^\\top\\mathbf{E}\\right)^{-1}\\,$, yielding a block-diagonal covariance for the $\\,36\\,$ parameters before enforcing major symmetry. Use the following scalar summaries of numerical stability and uncertainty:\n  - The spectral condition number of $\\,\\mathbf{E}\\,$ defined as the ratio of its largest singular value to its smallest singular value; if $\\,\\mathbf{E}\\,$ is rank-deficient, define the condition number as $+\\infty$.\n  - The A-optimality metric $\\,\\mathrm{A} = \\mathrm{tr}\\big(\\mathrm{Cov}(\\mathrm{vec}(\\widehat{\\mathbf{C}}))\\big)\\,$ computed from the block-diagonal covariance prior to symmetry projection, which equals $\\,6\\,\\sigma_\\mathrm{noise}^2\\,\\mathrm{tr}\\!\\left((\\mathbf{E}^\\top\\mathbf{E})^{-1}\\right)\\,$ when $\\,\\mathbf{E}\\,$ has full column rank.\n\nYou must compare three candidate strain-state designs, each scaled by a specified strain amplitude $\\,a\\,$ (dimensionless). Use the Voigt vector convention above for each state:\n\n- Design $\\,1$ (rank-deficient boundary case): $\\,S=6\\,$ states consisting only of normal strains, repeated, with rows\n  - $\\,\\mathbf{e}^{(1)}=a\\,[1,0,0,0,0,0]^\\top\\,$,\n  - $\\,\\mathbf{e}^{(2)}=a\\,[0,1,0,0,0,0]^\\top\\,$,\n  - $\\,\\mathbf{e}^{(3)}=a\\,[0,0,1,0,0,0]^\\top\\,$,\n  - $\\,\\mathbf{e}^{(4)}=a\\,[1,0,0,0,0,0]^\\top\\,$,\n  - $\\,\\mathbf{e}^{(5)}=a\\,[0,1,0,0,0,0]^\\top\\,$,\n  - $\\,\\mathbf{e}^{(6)}=a\\,[0,0,1,0,0,0]^\\top\\,$.\n\n- Design $\\,2$ (orthonormal $\\,6$-state basis): $\\,S=6\\,$ states given by the $\\,6\\times 6\\,$ identity in Voigt space scaled by $\\,a\\,$,\n  - $\\,\\mathbf{e}^{(1)}=a\\,[1,0,0,0,0,0]^\\top, \\ldots, \\mathbf{e}^{(6)}=a\\,[0,0,0,0,0,1]^\\top\\,$.\n\n- Design $\\,3$ (overdetermined random unit strains): $\\,S=30\\,$ states, each row independently generated by drawing a $\\,6$-dimensional standard normal vector using seed $\\,7\\,$, normalizing it to unit Euclidean norm in Voigt space, then scaling by $\\,a\\,$.\n\nYou must evaluate the following test suite of cases, each with specified strain amplitude $\\,a\\,$ and assumed stress noise standard deviation $\\,\\sigma_\\mathrm{noise}\\,$ in GPa:\n\n- Case $\\,1$: $\\,a=0.005\\,$, $\\,\\sigma_\\mathrm{noise}=0.02\\,$ GPa.\n- Case $\\,2$: $\\,a=0.001\\,$, $\\,\\sigma_\\mathrm{noise}=0.05\\,$ GPa.\n- Case $\\,3$: $\\,a=0.02\\,$, $\\,\\sigma_\\mathrm{noise}=0.005\\,$ GPa.\n\nFor each case, compute, for each design, the least-squares estimate $\\,\\widehat{\\mathbf{C}}\\,$ (in GPa), the spectral condition number of $\\,\\mathbf{E}\\,$, and the A-optimality metric $\\,\\mathrm{A}\\,$ (in GPa$^2$ units). Then, for each case, select the optimal design as the one with the smallest A-optimality metric $\\,\\mathrm{A}\\,$; break ties, if any, by the smaller condition number; if still tied, choose the smallest design index.\n\nPhysical and numerical units: all stiffness and stress values must be in gigapascals (GPa). Strain is dimensionless. Do not add random noise to the synthetic stresses; use the noise level only to compute the implied covariance.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is the integer index of the selected optimal design for the corresponding case, in the order of the cases above. For example, your program should print a line of the format \"[d1,d2,d3]\".",
            "solution": "We proceed from first principles in small-strain linear elasticity. The infinitesimal strain tensor is $\\,\\varepsilon_{ij} = \\tfrac{1}{2}\\left(\\partial u_i/\\partial x_j + \\partial u_j/\\partial x_i\\right)\\,$. In the linear elastic regime, Hooke’s law states $\\,\\sigma_{ij} = C_{ijkl}\\,\\varepsilon_{kl}\\,$, where $\\,C_{ijkl}\\,$ is the fourth-order stiffness tensor with minor and major symmetries and positive-definiteness ensuring $\\,\\varepsilon_{ij} C_{ijkl} \\varepsilon_{kl} > 0\\,$ for all nonzero $\\,\\varepsilon_{ij}\\,$.\n\nUsing the standard Voigt mapping with engineering shear, we define the strain vector $\\,\\mathbf{e} = [\\varepsilon_{11}, \\varepsilon_{22}, \\varepsilon_{33}, 2\\varepsilon_{23}, 2\\varepsilon_{13}, 2\\varepsilon_{12}]^\\top\\,$ and stress vector $\\,\\mathbf{s} = [\\sigma_{11}, \\sigma_{22}, \\sigma_{33}, \\sigma_{23}, \\sigma_{13}, \\sigma_{12}]^\\top\\,$. Under this mapping, Hooke’s law becomes the $\\,6\\times 6\\,$ linear relation $\\,\\mathbf{s} = \\mathbf{C}\\,\\mathbf{e}\\,$, where $\\,\\mathbf{C}\\,$ is symmetric positive-definite in the sense that $\\,\\mathbf{e}^\\top \\mathbf{C}\\, \\mathbf{e} > 0\\,$ for all nonzero $\\,\\mathbf{e}\\,$.\n\nTo estimate $\\,\\mathbf{C}\\,$ from synthetic Density Functional Theory (DFT) data, we apply a set of strain states $\\,\\{\\mathbf{e}^{(s)}\\}_{s=1}^S\\,$ and obtain stresses $\\,\\mathbf{s}^{(s)} = \\mathbf{C}^\\star \\mathbf{e}^{(s)}\\,$ for a fixed, but unknown, ground-truth $\\,\\mathbf{C}^\\star\\,$. Stacking $\\,\\mathbf{e}^{(s)}\\,$ into $\\,\\mathbf{E}\\in\\mathbb{R}^{S\\times 6}\\,$ (rows are $\\,\\mathbf{e}^{(s)\\top}\\,$) and $\\,\\mathbf{s}^{(s)}\\,$ into $\\,\\mathbf{S}\\in\\mathbb{R}^{S\\times 6}\\,$ (rows are $\\,\\mathbf{s}^{(s)\\top}\\,$), Hooke’s law gives $\\,\\mathbf{S} = \\mathbf{E}\\, \\mathbf{C}^\\top\\,$. For each stress component (each column of $\\,\\mathbf{S}\\,$), we have a linear regression onto the columns of $\\,\\mathbf{E}\\,$. The ordinary least squares (OLS) estimator for the $\\,\\alpha$-th row of $\\,\\mathbf{C}\\,$, denoted $\\,\\mathbf{c}_\\alpha^\\top\\,$, is\n$$\n\\widehat{\\mathbf{c}}_\\alpha = \\left(\\mathbf{E}^\\top \\mathbf{E}\\right)^{-1}\\mathbf{E}^\\top\\, \\mathbf{s}_\\alpha,\n$$\nprovided $\\,\\mathbf{E}\\,$ has full column rank. Stacking these gives $\\,\\widehat{\\mathbf{C}}^\\top = \\left(\\mathbf{E}^\\top \\mathbf{E}\\right)^{-1}\\mathbf{E}^\\top \\mathbf{S}\\,$. To enforce the major symmetry implied by $\\,C_{ijkl}=C_{klij}\\,$ in Voigt form, we project onto the symmetric part,\n$$\n\\widehat{\\mathbf{C}} \\leftarrow \\tfrac{1}{2}\\left(\\widehat{\\mathbf{C}} + \\widehat{\\mathbf{C}}^\\top\\right).\n$$\n\nWe next quantify numerical stability and uncertainty. Under an uncorrelated, homoscedastic stress noise model with variance $\\,\\sigma_\\mathrm{noise}^2\\,$ per stress component (in GPa$^2$), the OLS covariance of each row estimate is\n$$\n\\mathrm{Cov}\\!\\left(\\widehat{\\mathbf{c}}_\\alpha\\right) \\;=\\; \\sigma_\\mathrm{noise}^2 \\left(\\mathbf{E}^\\top \\mathbf{E}\\right)^{-1}.\n$$\nBefore applying the symmetry projection, the full parameter covariance for the $\\,36\\,$ parameters of $\\,\\mathbf{C}\\,$ is block-diagonal with $\\,6\\,$ identical $\\,6\\times 6\\,$ blocks, so the A-optimality metric (trace of the covariance) is\n$$\n\\mathrm{A} \\;=\\; 6\\,\\sigma_\\mathrm{noise}^2 \\,\\mathrm{tr}\\!\\left(\\left(\\mathbf{E}^\\top \\mathbf{E}\\right)^{-1}\\right),\n$$\nwhenever $\\,\\mathbf{E}\\,$ has full column rank. If $\\,\\mathbf{E}\\,$ is rank-deficient, then $\\,\\left(\\mathbf{E}^\\top \\mathbf{E}\\right)^{-1}\\,$ does not exist, and we assign $\\,\\mathrm{A}=+\\infty\\,$. The spectral condition number of $\\,\\mathbf{E}\\,$ is the ratio of its largest to smallest singular values, which we also set to $+\\infty$ if rank-deficient.\n\nWe define the synthetic ground-truth $\\,\\mathbf{C}^\\star\\,$ in Voigt form by a deterministic orthogonal similarity transform of a diagonal matrix to ensure positive-definiteness. Let $\\,\\mathbf{A}\\in\\mathbb{R}^{6\\times 6}\\,$ be standard normal with seed $\\,20231105\\,$. Compute $\\,\\mathbf{A}=\\mathbf{Q}\\mathbf{R}\\,$ and enforce a proper orthogonal $\\,\\mathbf{Q}\\,$ via right-multiplication by $\\,\\mathrm{diag}(\\mathrm{sign}(\\mathrm{diag}(\\mathbf{R})))\\,$. With $\\,\\mathbf{D}=\\mathrm{diag}([300,250,220,100,90,80])\\,$ in GPa, define $\\,\\mathbf{C}^\\star = \\mathbf{Q}^\\top \\mathbf{D}\\,\\mathbf{Q}\\,$ in GPa. This $\\,\\mathbf{C}^\\star\\,$ is symmetric positive-definite and represents a low-symmetry crystal in Voigt terms.\n\nWe compare three designs of strain states, each scaled by amplitude $\\,a\\,$:\n- Design $\\,1$ uses only normal strains duplicated, so $\\,\\mathbf{E}\\,$ has only the first three columns nonzero and is rank-deficient. Therefore, its condition number and $\\,\\mathrm{A}\\,$ are $+\\infty$ for all $\\,a\\,$.\n- Design $\\,2$ uses the $\\,6\\times 6\\,$ identity scaled by $\\,a\\,$, so $\\,\\mathbf{E} = a\\,\\mathbf{I}_6\\,$ and $\\,\\mathbf{E}^\\top \\mathbf{E} = a^2 \\mathbf{I}_6\\,$. Thus $\\,\\left(\\mathbf{E}^\\top \\mathbf{E}\\right)^{-1} = a^{-2}\\mathbf{I}_6\\,$, the condition number is $\\,1\\,$, and the A-optimality metric is\n$$\n\\mathrm{A}_2 = 6\\,\\sigma_\\mathrm{noise}^2\\,\\mathrm{tr}(a^{-2}\\mathbf{I}_6) = 6\\,\\sigma_\\mathrm{noise}^2 \\cdot 6\\,a^{-2} = 36\\,\\sigma_\\mathrm{noise}^2/a^2.\n$$\n- Design $\\,3$ uses $\\,S=30\\,$ random unit vectors in Voigt space (seed $\\,7\\,$), scaled by $\\,a\\,$. In expectation, $\\,\\mathbf{E}^\\top \\mathbf{E}\\,$ is proportional to $\\,a^2 \\mathbf{I}_6\\,$, specifically close to $\\,a^2 (S/6)\\,\\mathbf{I}_6\\,$, yielding an A-optimality approximately\n$$\n\\mathrm{A}_3 \\approx 6\\,\\sigma_\\mathrm{noise}^2\\,\\mathrm{tr}\\!\\left(\\left(a^2 (S/6)\\,\\mathbf{I}_6\\right)^{-1}\\right) \\;=\\; 6\\,\\sigma_\\mathrm{noise}^2 \\cdot 6 \\cdot \\frac{6}{a^2 S} \\;=\\; \\frac{216\\,\\sigma_\\mathrm{noise}^2}{a^2 S}.\n$$\nFor $\\,S=30\\,$, this is $\\,7.2\\,\\sigma_\\mathrm{noise}^2/a^2\\,$, which is strictly smaller than $\\,36\\,\\sigma_\\mathrm{noise}^2/a^2\\,$ of Design $\\,2\\,$. Therefore, we expect Design $\\,3\\,$ to be optimal among these three for any positive $\\,a\\,$ and $\\,\\sigma_\\mathrm{noise}\\,$.\n\nWe now apply the test suite:\n- Case $\\,1$: $\\,a=0.005\\,$, $\\,\\sigma_\\mathrm{noise}=0.02\\,$ GPa.\n- Case $\\,2$: $\\,a=0.001\\,$, $\\,\\sigma_\\mathrm{noise}=0.05\\,$ GPa.\n- Case $\\,3$: $\\,a=0.02\\,$, $\\,\\sigma_\\mathrm{noise}=0.005\\,$ GPa.\n\nIn all cases, Design $\\,1$ is rank-deficient with $\\,\\mathrm{A}=+\\infty\\,$. Design $\\,2$ has finite $\\,\\mathrm{A}_2=36\\,\\sigma_\\mathrm{noise}^2/a^2\\,$, and Design $\\,3$ has smaller $\\,\\mathrm{A}_3\\,$ due to having more independent strain states. Therefore, Design $\\,3$ minimizes the A-optimality metric in all three cases. If needed, the spectral condition number also favors Design $\\,2$ and Design $\\,3\\,$ over Design $\\,1\\,$; Design $\\,2$ has condition number $\\,1\\,$, while Design $\\,3\\,$ is well-conditioned with high probability.\n\nConsequently, the optimal design indices for the three cases are $[3,3,3]$. The required output is a single line with these integers enclosed in square brackets.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_true_C():\n    \"\"\"\n    Construct a symmetric positive-definite 6x6 stiffness matrix C* in Voigt form (GPa)\n    using a deterministic procedure:\n    - Generate a random 6x6 matrix with standard normal entries (seed=20231105).\n    - Perform QR decomposition to get an orthogonal Q (adjusted to be proper).\n    - Form C* = Q^T D Q with D = diag([300,250,220,100,90,80]) GPa.\n    \"\"\"\n    rng = np.random.default_rng(20231105)\n    A = rng.standard_normal((6, 6))\n    Q, R = np.linalg.qr(A)\n    # Enforce proper orthogonal Q: make diag of R positive\n    sign_diag = np.sign(np.diag(R))\n    sign_diag[sign_diag == 0.0] = 1.0\n    Q = Q @ np.diag(sign_diag)\n    D = np.diag([300.0, 250.0, 220.0, 100.0, 90.0, 80.0])\n    C = Q.T @ D @ Q\n    # Symmetrize numerically\n    C = 0.5 * (C + C.T)\n    return C\n\ndef design_strains(design_id, a):\n    \"\"\"\n    Return strain design matrix E (S x 6) for the given design and amplitude a.\n    Voigt mapping with engineering shear: e = [e11,e22,e33,2e23,2e13,2e12].\n    Designs:\n      1: Rank-deficient, only normal strains repeated (6 states).\n      2: Orthonormal 6-state basis (identity) scaled by a.\n      3: 30 random unit 6-vectors (seed=7) scaled by a.\n    \"\"\"\n    if design_id == 1:\n        E = np.array([\n            [1,0,0,0,0,0],\n            [0,1,0,0,0,0],\n            [0,0,1,0,0,0],\n            [1,0,0,0,0,0],\n            [0,1,0,0,0,0],\n            [0,0,1,0,0,0],\n        ], dtype=float)\n        return a * E\n    elif design_id == 2:\n        E = np.eye(6, dtype=float)\n        return a * E\n    elif design_id == 3:\n        rng = np.random.default_rng(7)\n        rows = []\n        for _ in range(30):\n            v = rng.standard_normal(6)\n            nrm = np.linalg.norm(v)\n            # Avoid zero norm; extremely unlikely\n            if nrm == 0.0:\n                v = np.array([1,0,0,0,0,0], dtype=float)\n                nrm = 1.0\n            rows.append((v / nrm) * a)\n        return np.vstack(rows)\n    else:\n        raise ValueError(\"Unknown design_id\")\n\ndef fit_C_and_metrics(C_true, E, sigma_noise):\n    \"\"\"\n    Given true C (6x6), strain design E (Sx6), and noise std sigma_noise (GPa),\n    compute synthetic stresses S (Sx6) without noise, OLS estimate C_hat, and metrics:\n    - Spectral condition number of E (inf if rank deficient).\n    - A-optimality metric A = 6 * sigma_noise^2 * trace( (E^T E)^{-1} ) (inf if rank deficient).\n    Returns (C_hat, condE, A_metric).\n    \"\"\"\n    # Synthetic stress data: S = E * C_true^T (since S rows are s^T)\n    S = E @ C_true.T  # shape S x 6\n    # Compute (E^T E) and its inverse or pseudo-inverse\n    EtE = E.T @ E\n    # Check rank\n    svals = np.linalg.svd(E, compute_uv=False)\n    tol = np.finfo(float).eps * max(E.shape) * svals[0] if svals.size > 0 else 0.0\n    rank = np.sum(svals > tol)\n    if rank < 6:\n        condE = float('inf')\n        A_metric = float('inf')\n        # Least squares fit using pseudoinverse for completeness\n        # C_hat^T = (E^T E)^+ E^T S\n        EtE_pinv = np.linalg.pinv(EtE)\n        C_hat_T = EtE_pinv @ E.T @ S\n    else:\n        condE = float(svals[0] / svals[-1])\n        EtE_inv = np.linalg.inv(EtE)\n        A_metric = 6.0 * (sigma_noise ** 2) * np.trace(EtE_inv)\n        C_hat_T = EtE_inv @ E.T @ S\n    C_hat = C_hat_T.T\n    # Enforce major symmetry\n    C_hat = 0.5 * (C_hat + C_hat.T)\n    return C_hat, condE, A_metric\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (a, sigma_noise_GPa)\n    test_cases = [\n        (0.005, 0.02),   # Case 1\n        (0.001, 0.05),   # Case 2\n        (0.02, 0.005),   # Case 3\n    ]\n\n    C_true = build_true_C()\n\n    results = []\n    for a, sigma_noise in test_cases:\n        design_metrics = []\n        for design_id in (1, 2, 3):\n            E = design_strains(design_id, a)\n            C_hat, condE, A_metric = fit_C_and_metrics(C_true, E, sigma_noise)\n            design_metrics.append((design_id, A_metric, condE))\n        # Select optimal: min A_metric, tie-break by condE, then by design_id\n        # Filter to numeric comparable values; inf compares as larger in Python\n        design_metrics.sort(key=lambda t: (t[1], t[2], t[0]))\n        best_design = design_metrics[0][0]\n        results.append(best_design)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "This final practice elevates the inverse problem to a system-level challenge, where material parameters must be calibrated using indirect boundary measurements rather than local stress-strain pairs. You will implement the powerful adjoint method to efficiently compute the gradient of a misfit functional with respect to the material's elastic constants within a full FEM framework. By deriving and coding the adjoint system and verifying its gradient against finite differences, you will gain experience with a state-of-the-art technique essential for large-scale optimization, parameter identification, and data assimilation in computational engineering and science .",
            "id": "3490664",
            "problem": "Implement an adjoint-based gradient computation for two-dimensional, small-strain, linear elasticity with spatially uniform but anisotropic elastic constants, and verify the sensitivities against finite differences. All quantities are non-dimensional. Your program must assemble a discrete forward model using the Finite Element Method (FEM) with linear triangular elements on a rectangular mesh, enforce mixed boundary conditions, compute a displacement field, define a boundary misfit functional, derive and implement an adjoint solve to obtain the gradient of the misfit with respect to selected components of the fourth-order stiffness tensor, and compare the adjoint gradient to a central finite-difference gradient. The final output must be a single line containing a list of floats as specified at the end of this statement.\n\nStart from the following fundamental base:\n- Balance of linear momentum without body forces: $-\\partial_j \\sigma_{ij} = 0$ in the domain.\n- Small-strain definition: $\\varepsilon_{kl} = \\dfrac{1}{2}(\\partial_k u_l + \\partial_l u_k)$.\n- Linear elastic constitutive relation with constant stiffness: $\\sigma_{ij} = C_{ijkl} \\varepsilon_{kl}$.\n- Weak form of equilibrium: find $u_i$ such that $\\int_{\\Omega} \\varepsilon_{ij}(v)\\, C_{ijkl}\\, \\varepsilon_{kl}(u)\\, d\\Omega = \\int_{\\Gamma_t} v_i\\, t_i\\, d\\Gamma$ for all admissible test functions $v_i$, where $t_i$ is the applied traction on the Neumann boundary $\\Gamma_t$ and $u_i$ is prescribed on the Dirichlet boundary.\n\nDiscretization and parameterization:\n- Use a rectangular domain of size $L_x \\times L_y$, meshed by a uniform grid of $n_x \\times n_y$ nodes, split into linear triangular elements (two per rectangle). Use standard $P1$ shape functions, engineering shear strain $\\gamma_{xy} = \\partial_x u_y + \\partial_y u_x$, and the $3 \\times 3$ constitutive matrix $D$ in Voigt notation mapping $[\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$ to $[\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}]^T$.\n- Restrict $C_{ijkl}$ to an orthotropic, symmetric form aligned with the coordinate axes, represented in Voigt notation by\n$$\nD(p) = \\begin{bmatrix}\nC_{11} & C_{12} & 0\\\\\nC_{12} & C_{22} & 0\\\\\n0 & 0 & C_{66}\n\\end{bmatrix},\n$$\nwith parameter vector $p = [C_{11}, C_{22}, C_{12}, C_{66}]^T$. Assume $C_{11} > 0$, $C_{22} > 0$, $C_{66} > 0$, and $C_{12}^2  C_{11} C_{22}$ to ensure positive definiteness.\n\nBoundary value problem and misfit:\n- Apply homogeneous Dirichlet boundary conditions on the left edge $x = 0$: $u_x = 0$, $u_y = 0$ there.\n- Apply a uniform traction $t = (t_x, t_y)$ on the right edge $x = L_x$, with the top and bottom edges traction-free.\n- Assemble the global stiffness matrix $K(p)$ by summing elemental contributions $K_e(p) = \\int_{\\Omega_e} B^T D(p) B \\, d\\Omega$, where $B$ is the standard $3 \\times 6$ strain-displacement matrix for linear triangles, and apply boundary conditions to form a solvable linear system $K(p) u(p) = f$.\n- Define the selection operator $M$ that extracts the degrees of freedom on the right boundary $x = L_x$ (both components at those nodes). The misfit functional is\n$J(p) = \\frac{1}{2} \\| M u(p) - d \\|_2^2,$\nwhere $d$ are synthetic “measurements” generated by a forward solve at a “true” parameter $p_{\\text{true}}$ under the same traction and boundary conditions.\n\nAdjoint-based gradient:\n- Differentiate the discrete equilibrium $K(p) u(p) = f$ to obtain $K(p)\\, du + \\left(\\frac{\\partial K}{\\partial p_m}\\right) u\\, dp_m = 0$, hence $du = -K(p)^{-1} \\left(\\frac{\\partial K}{\\partial p_m}\\right) u\\, dp_m$.\n- For $J(p) = \\frac{1}{2} \\| M u(p) - d \\|_2^2$, variation gives $dJ = (Mu - d)^T M\\, du$. Introduce the adjoint variable $\\lambda$ as the solution of the adjoint system\n$K(p)\\, \\lambda = M^T (M u - d),$\nand use it to obtain\n$\\frac{\\partial J}{\\partial p_m} = - \\lambda^T \\left(\\frac{\\partial K}{\\partial p_m}\\right) u.$\n- Because $K(p)$ is assembled linearly from $D(p)$ and $D(p)$ is linear in the parameters, the matrices $\\frac{\\partial K}{\\partial p_m}$ can be preassembled from the constant elemental matrices $K_e^{(m)} = \\int_{\\Omega_e} B^T E^{(m)} B\\, d\\Omega$, where\n$$\nE^{(1)} = \\begin{bmatrix}100\\\\000\\\\000\\end{bmatrix},\\quad\nE^{(2)} = \\begin{bmatrix}000\\\\010\\\\000\\end{bmatrix},\\quad\nE^{(3)} = \\begin{bmatrix}010\\\\100\\\\000\\end{bmatrix},\\quad\nE^{(4)} = \\begin{bmatrix}000\\\\000\\\\001\\end{bmatrix}.\n$$\n\nFinite-difference verification:\n- Use central finite differences for each parameter $p_m$:\n$\\left.\\frac{\\partial J}{\\partial p_m}\\right|_{\\text{FD}} \\approx \\frac{J(p + h_m e_m) - J(p - h_m e_m)}{2 h_m},\\quad h_m = \\varepsilon \\max(1, |p_m|),$\nwith $\\varepsilon = 10^{-7}$ and $e_m$ the $m$-th standard basis vector. To avoid division by very small finite-difference values in normalization, report a normalized error per component\n$\\eta_m = \\frac{\\left| \\left.\\frac{\\partial J}{\\partial p_m}\\right|_{\\text{adj}} - \\left.\\frac{\\partial J}{\\partial p_m}\\right|_{\\text{FD}} \\right|}{\\max\\left(1, \\left|\\left.\\frac{\\partial J}{\\partial p_m}\\right|_{\\text{FD}}\\right|\\right)}.$\nFor each test case, report the maximum over $m$ of $\\eta_m$.\n\nTest suite:\n- Mesh and geometry for all cases: $n_x = 5$, $n_y = 3$, $L_x = 1.0$, $L_y = 0.5$.\n- For each case, specify the traction $t = (t_x, t_y)$, the “true” parameter $p_{\\text{true}}$ used to generate $d$, and the evaluation parameter $p$ at which the adjoint gradient and the finite-difference gradient are compared. All quantities are non-dimensional numbers.\n\nProvide the following three test cases:\n- Case A:\n  - $t_x = 1.0$, $t_y = 0.2$.\n  - $p_{\\text{true}} = [12.0, 8.0, 3.0, 4.0]^T$.\n  - $p = [10.0, 9.0, 2.5, 3.5]^T$.\n- Case B:\n  - $t_x = 0.0$, $t_y = 1.0$.\n  - $p_{\\text{true}} = [20.0, 10.0, 6.0, 5.0]^T$.\n  - $p = [18.0, 11.0, 5.5, 4.8]^T$.\n- Case C:\n  - $t_x = 0.5$, $t_y = 0.5$.\n  - $p_{\\text{true}} = [15.0, 15.0, 7.0, 3.0]^T$.\n  - $p = [14.5, 14.0, 6.8, 3.2]^T$.\n\nYour program must:\n- Assemble the global stiffness matrix $K(p)$ and four parameter-derivative matrices $\\frac{\\partial K}{\\partial p_m}$ using linear triangular elements and exact element formulas based on constant shape function gradients, and enforce Dirichlet conditions on $x = 0$ by modification of the global system.\n- Assemble the Neumann load vector by consistent edge integration along $x = L_x$ with edge contributions split equally between the two edge nodes.\n- Solve for $u(p_{\\text{true}})$ to synthesize $d = M u(p_{\\text{true}})$.\n- For each case, solve the forward problem at $p$, compute $J(p)$, form and solve the adjoint system $K(p)\\lambda = M^T(Mu - d)$, compute the adjoint gradient components via $-\\lambda^T \\left(\\frac{\\partial K}{\\partial p_m}\\right) u$, and compute central finite-difference approximations for the same components. Report the maximum normalized error $\\max_m \\eta_m$ per case.\n\nFinal output format:\n- Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, in scientific notation with three significant digits for each float (for example, $[1.23e-07,4.56e-08,7.89e-09]$).",
            "solution": "The implementation addresses the problem of computing and verifying adjoint-based gradients for a two-dimensional linear elasticity problem. The solution is structured within a Python class, `AdjointElasticitySolver`, which encapsulates the entire Finite Element Method (FEM) model and the sensitivity analysis logic. The design follows the principles and equations specified in the problem statement.\n\nFirst, the geometric and mesh data are established. The domain is a rectangle of size $L_x \\times L_y = 1.0 \\times 0.5$, discretized by a uniform grid of $n_x \\times n_y = 5 \\times 3$ nodes. Each rectangular cell formed by four adjacent nodes is subdivided into two linear triangular ($P1$) elements. This process generates the node coordinates and element connectivity, which are stored for subsequent calculations.\n\nThe core of the FEM implementation is the assembly of the global stiffness matrix $K(p)$. The problem specifies an orthotropic material with a constitutive matrix $D(p)$ that is linear in the parameter vector $p = [C_{11}, C_{22}, C_{12}, C_{66}]^T$. This linearity allows the global stiffness matrix to be expressed as a linear combination $K(p) = \\sum_{m=1}^{4} p_m K^{(m)}$, where each $K^{(m)} = \\frac{\\partial K}{\\partial p_m}$ is a constant matrix corresponding to one of the parameters. These four derivative matrices are pre-computed and stored. The assembly process for each $K^{(m)}$ involves iterating through all elements $\\Omega_e$ in the mesh and summing up the elemental contributions $K_e^{(m)} = \\int_{\\Omega_e} B^T E^{(m)} B \\, d\\Omega$. For a linear triangular element, the strain-displacement matrix $B$ is constant, so the integral simplifies to $K_e^{(m)} = (\\text{Area}_e) B^T E^{(m)} B$. The $B$ matrix is the standard $3 \\times 6$ matrix mapping the $6$ nodal displacements of a triangle to the $3$ components of engineering strain $[\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$. The matrices $E^{(m)}$ are the specified constant basis matrices for the constitutive law.\n\nThe discrete system of equations is $K(p)u=f$. The load vector $f$ arises from the prescribed Neumann boundary condition, a uniform traction $t=(t_x, t_y)$ on the right edge of the domain ($x=L_x$). This traction is converted into a consistent nodal force vector by integrating the shape functions against the traction along each element edge on the boundary. For linear elements, this results in the total force on an edge being split equally between its two nodes. The implementation correctly accumulates forces at each node on the right boundary.\n\nHomogeneous Dirichlet boundary conditions, $u_x=u_y=0$ on the left edge ($x=0$), are enforced by modifying the global system. For each constrained degree of freedom, the corresponding row and column of the stiffness matrix $K$ are set to zero, the diagonal element is set to $1$, and the corresponding entry in the load vector $f$ is set to $0$. This procedure isolates the constrained DOFs and ensures a unique solution for the remaining unconstrained DOFs.\n\nThe adjoint-based gradient computation proceeds as follows:\n1.  **Synthetic Data Generation**: The forward problem is solved using the \"true\" parameters $p_{\\text{true}}$ to obtain the displacement field $u_{\\text{true}}$. The synthetic measurement data $d$ are then defined as the displacements at the nodes on the right boundary, i.e., $d = M u_{\\text{true}}$, where $M$ is the selection operator for those DOFs.\n2.  **Forward Solve**: At the evaluation parameter $p$, the forward system $K(p)u=f$ is solved to obtain the displacement field $u$.\n3.  **Adjoint Solve**: The adjoint variable $\\lambda$ is found by solving the adjoint system $K(p)^T \\lambda = M^T (M u(p) - d)$. Since the stiffness matrix $K(p)$ is symmetric ($K(p)^T = K(p)$), this is equivalent to solving $K(p)\\lambda = M^T(Mu-d)$. The right-hand side of this system is a vector containing the misfit residuals $(Mu-d)$ at the right-boundary DOFs and zeros elsewhere. The same Dirichlet boundary condition enforcement procedure is applied to this system.\n4.  **Gradient Calculation**: The gradient of the misfit functional $J$ with respect to each parameter $p_m$ is computed using the formula $\\frac{\\partial J}{\\partial p_m} = -\\lambda^T K^{(m)} u$, utilizing the pre-assembled derivative matrices $K^{(m)}$.\n\nTo verify the correctness of the adjoint gradient, it is compared against a gradient computed via the central finite-difference method. For each parameter $p_m$, the functional $J$ is evaluated at perturbed parameter values $p \\pm h_m e_m$, where $h_m = \\varepsilon \\max(1, |p_m|)$ with $\\varepsilon=10^{-7}$. The finite-difference gradient is then $\\frac{J(p+h_m e_m) - J(p-h_m e_m)}{2h_m}$.\n\nThe final reported value for each test case is the maximum normalized error between the adjoint and finite-difference gradients over all four parameters, $\\max_m \\eta_m$, where $\\eta_m = \\frac{|\\text{adj\\_grad}_m - \\text{fd\\_grad}_m|}{\\max(1, |\\text{fd\\_grad}_m|)}$. The full procedure is automated for the three test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.linalg\n\nclass AdjointElasticitySolver:\n    \"\"\"\n    Implements an adjoint-based gradient computation for 2D linear elasticity.\n    \"\"\"\n    def __init__(self, nx, ny, Lx, Ly):\n        self.nx, self.ny = nx, ny\n        self.Lx, self.Ly = Lx, Ly\n        self.num_nodes = nx * ny\n        self.num_dofs = 2 * self.num_nodes\n\n        self.nodes = self._generate_nodes()\n        self.elements = self._generate_elements()\n        \n        self.K_derivs = self._assemble_K_derivatives()\n\n        self.dirichlet_dofs = self._get_dirichlet_dofs()\n        self.right_boundary_dofs = self._get_right_boundary_dofs()\n\n    def _generate_nodes(self):\n        x = np.linspace(0, self.Lx, self.nx)\n        y = np.linspace(0, self.Ly, self.ny)\n        xv, yv = np.meshgrid(x, y)\n        return np.vstack([xv.ravel(), yv.ravel()]).T\n\n    def _generate_elements(self):\n        elements = []\n        for j in range(self.ny - 1):\n            for i in range(self.nx - 1):\n                n1 = j * self.nx + i\n                n2 = j * self.nx + (i + 1)\n                n3 = (j + 1) * self.nx + i\n                n4 = (j + 1) * self.nx + (i + 1)\n                elements.append([n1, n2, n4])\n                elements.append([n1, n4, n3])\n        return np.array(elements)\n\n    def _get_elemental_B_and_area(self, node_indices):\n        coords = self.nodes[node_indices]\n        (x1, y1), (x2, y2), (x3, y3) = coords[0], coords[1], coords[2]\n        \n        area = 0.5 * np.linalg.det(np.array([[x1, y1, 1], [x2, y2, 1], [x3, y3, 1]]))\n        \n        b1, b2, b3 = y2 - y3, y3 - y1, y1 - y2\n        c1, c2, c3 = x3 - x2, x1 - x3, x2 - x1\n        \n        B = (1 / (2 * area)) * np.array([\n            [b1, 0, b2, 0, b3, 0],\n            [0, c1, 0, c2, 0, c3],\n            [c1, b1, c2, b2, c3, b3]\n        ])\n        return B, abs(area)\n        \n    def _assemble_K_derivatives(self):\n        K_derivs = [np.zeros((self.num_dofs, self.num_dofs)) for _ in range(4)]\n        \n        E_matrices = [\n            np.array([[1, 0, 0], [0, 0, 0], [0, 0, 0]], dtype=float),\n            np.array([[0, 0, 0], [0, 1, 0], [0, 0, 0]], dtype=float),\n            np.array([[0, 1, 0], [1, 0, 0], [0, 0, 0]], dtype=float),\n            np.array([[0, 0, 0], [0, 0, 0], [0, 0, 1]], dtype=float)\n        ]\n        \n        for elem_nodes in self.elements:\n            B, area = self._get_elemental_B_and_area(elem_nodes)\n            dofs = np.ravel([[2 * n, 2 * n + 1] for n in elem_nodes])\n            \n            for m in range(4):\n                Ke_m = B.T @ E_matrices[m] @ B * area\n                K_derivs[m][np.ix_(dofs, dofs)] += Ke_m\n                \n        return K_derivs\n\n    def _get_dirichlet_dofs(self):\n        dofs = []\n        for i in range(self.num_nodes):\n            if np.isclose(self.nodes[i, 0], 0.0):\n                dofs.extend([2 * i, 2 * i + 1])\n        return np.array(dofs)\n\n    def _get_right_boundary_dofs(self):\n        dofs = []\n        for i in range(self.num_nodes):\n            if np.isclose(self.nodes[i, 0], self.Lx):\n                dofs.extend([2 * i, 2 * i + 1])\n        return np.array(dofs)\n        \n    def assemble_K(self, p):\n        K = np.zeros((self.num_dofs, self.num_dofs))\n        for m in range(4):\n            K += p[m] * self.K_derivs[m]\n        return K\n\n    def assemble_f(self, t):\n        tx, ty = t\n        f = np.zeros(self.num_dofs)\n        edge_len = self.Ly / (self.ny - 1)\n        \n        for j in range(self.ny):\n            node_idx = j * self.nx + (self.nx - 1)\n            load_multiplier = 1.0 if 0  j  self.ny - 1 else 0.5\n            \n            f[2 * node_idx] += load_multiplier * edge_len * tx\n            f[2 * node_idx + 1] += load_multiplier * edge_len * ty\n        return f\n\n    def apply_bcs(self, K, f):\n        K_mod, f_mod = K.copy(), f.copy()\n        for dof in self.dirichlet_dofs:\n            K_mod[dof, :] = 0\n            K_mod[:, dof] = 0\n            K_mod[dof, dof] = 1.0\n            f_mod[dof] = 0.0\n        return K_mod, f_mod\n\n    def solve_system(self, p, t):\n        K = self.assemble_K(p)\n        f = self.assemble_f(t)\n        K_mod, f_mod = self.apply_bcs(K, f)\n        u = scipy.linalg.solve(K_mod, f_mod)\n        return u\n        \n    def calculate_J(self, u, d):\n        u_right = u[self.right_boundary_dofs]\n        return 0.5 * np.sum((u_right - d)**2)\n\n    def run_case(self, t, p_true, p):\n        p_true, p = np.array(p_true), np.array(p)\n        \n        u_true = self.solve_system(p_true, t)\n        d = u_true[self.right_boundary_dofs]\n        \n        u = self.solve_system(p, t)\n        \n        adj_rhs = np.zeros(self.num_dofs)\n        residual = u[self.right_boundary_dofs] - d\n        adj_rhs[self.right_boundary_dofs] = residual\n        \n        K_p = self.assemble_K(p)\n        K_mod, adj_rhs_mod = self.apply_bcs(K_p, adj_rhs)\n        lambda_adj = scipy.linalg.solve(K_mod, adj_rhs_mod)\n        \n        grad_adj = np.zeros(4)\n        for m in range(4):\n            grad_adj[m] = -lambda_adj.T @ self.K_derivs[m] @ u\n            \n        grad_fd = np.zeros(4)\n        epsilon = 1e-7\n        \n        for m in range(4):\n            h = epsilon * max(1.0, abs(p[m]))\n            \n            p_plus = p.copy(); p_plus[m] += h\n            u_plus = self.solve_system(p_plus, t)\n            J_plus = self.calculate_J(u_plus, d)\n            \n            p_minus = p.copy(); p_minus[m] -= h\n            u_minus = self.solve_system(p_minus, t)\n            J_minus = self.calculate_J(u_minus, d)\n            \n            grad_fd[m] = (J_plus - J_minus) / (2 * h)\n            \n        errors = np.abs(grad_adj - grad_fd) / np.maximum(1.0, np.abs(grad_fd))\n        return np.max(errors)\n\ndef solve():\n    test_cases = [\n        {'t': (1.0, 0.2), 'p_true': [12.0, 8.0, 3.0, 4.0], 'p': [10.0, 9.0, 2.5, 3.5]},\n        {'t': (0.0, 1.0), 'p_true': [20.0, 10.0, 6.0, 5.0], 'p': [18.0, 11.0, 5.5, 4.8]},\n        {'t': (0.5, 0.5), 'p_true': [15.0, 15.0, 7.0, 3.0], 'p': [14.5, 14.0, 6.8, 3.2]}\n    ]\n\n    solver = AdjointElasticitySolver(nx=5, ny=3, Lx=1.0, Ly=0.5)\n    \n    results = []\n    for case in test_cases:\n        max_error = solver.run_case(case['t'], case['p_true'], case['p'])\n        results.append(max_error)\n\n    formatted_results = [f\"{res:.2e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}