{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的检验方式是动手实践。本练习将指导您从零开始，为二维线弹性问题中最基础的单元——常应变三角形单元——构建其刚度矩阵。通过这个实践，您将深刻理解有限元方法如何将位移、应变和应力之间的连续介质力学关系，转化为可计算的离散代数方程，为更复杂的计算分析打下坚实基础。",
            "id": "3490647",
            "problem": "要求您构建在平面应变条件下的二维、各向同性、线性弹性固体的常应变三角形单元刚度矩阵。起点是小应变线性化运动学和胡克定律。使用以下基本依据：\n\n- 运动学：无穷小应变张量由位移矢量的对称梯度定义，即 $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\top}\\right)$。在二维情况下，使用工程剪应变 $\\gamma_{xy} = 2 \\varepsilon_{xy}$，应变向量为 $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} \\varepsilon_{xx}  \\varepsilon_{yy}  \\gamma_{xy}\\end{bmatrix}^{\\top}$。\n- 本构律：对于平面应变中的各向同性线性弹性，$\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{\\sigma} = \\begin{bmatrix}\\sigma_{xx}  \\sigma_{yy}  \\tau_{xy}\\end{bmatrix}^{\\top}$，弹性矩阵 $\\mathbf{D}$ 由拉梅参数 $\\lambda$ 和 $\\mu$ 决定，这两个参数是杨氏模量 $E$ 和泊松比 $\\nu$ 的函数。\n- 有限元法 (FEM) 的虚功原理：对于厚度为 $t$ 的三节点线性三角形，其单元刚度矩阵为 $\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^{\\top}\\mathbf{D}\\mathbf{B}\\,t\\, d\\Omega$，其中 $\\mathbf{B}$ 通过应变-位移关系将节点位移映射到应变，而 $\\mathbf{D}$ 是本构矩阵。\n\n任务：\n\n1. 对于一个给定节点坐标为 $(x_i,y_i)$（$i \\in \\{1,2,3\\}$）的三角形，构建满足 $N_i(x_j,y_j) = \\delta_{ij}$ 和 $N_1+N_2+N_3=1$ 的线性形函数 $N_i(x,y)$。利用这些形函数为每个节点显式构建梯度 $\\nabla N_i$，对于线性三角形，该梯度在单元域 $\\Omega_e$ 上是常数。根据这些梯度，组装矩阵 $\\mathbf{B}$，该矩阵通过 $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\,\\mathbf{u}_e$ 将节点位移 $\\mathbf{u}_e = \\begin{bmatrix}u_1  v_1  u_2  v_2  u_3  v_3\\end{bmatrix}^{\\top}$ 映射到应变向量 $\\boldsymbol{\\varepsilon}$。\n2. 使用以 $E$ 和 $\\nu$ 表示的各向同性平面应变本构律，构建矩阵 $\\mathbf{D}$。\n3. 通过计算积分来求得单元刚度 $\\mathbf{K}_e$。对于线性三角形，$\\mathbf{B}$ 和 $\\mathbf{D}$ 在 $\\Omega_e$ 上是常数，因此积分简化为单元面积与被积函数的乘积。\n4. 实现一个程序，对下面的每个测试用例，计算 $\\mathbf{K}_e$ 并返回一个按行主序展开的 $6\\times 6$ 矩阵，形式为一个包含36个浮点数的列表。每个条目对应于刚度，单位为牛顿每米 (N/m)。输出中的每个浮点数必须四舍五入到六位有效数字。本问题不涉及角度。不存在百分比。\n\n使用以下测试套件。每个测试用例提供：\n- 节点坐标，单位为米 (m)：$(x_i,y_i)$，其中 $i=1,2,3$，\n- 杨氏模量，单位为帕斯卡 (Pa)：$E$，\n- 泊松比 $\\nu$（无量纲），\n- 厚度 $t$，单位为米 (m)。\n\n测试用例：\n- 用例1（常规情况）：$(x_1,y_1)=(0,0)$，$(x_2,y_2)=(1,0)$，$(x_3,y_3)=(0,1)$，$E=210\\times 10^{9}$，$\\nu=0.30$，$t=0.01$。\n- 用例2（等边几何形状）：$(x_1,y_1)=(0,0)$，$(x_2,y_2)=(1,0)$，$(x_3,y_3)=\\left(0.5, \\sqrt{3}/2\\right)$，$E=70\\times 10^{9}$，$\\nu=0.25$，$t=0.005$。\n- 用例3（近不可压缩，小单元）：$(x_1,y_1)=(0,0)$，$(x_2,y_2)=(0.001,0)$，$(x_3,y_3)=(0,0.002)$，$E=100\\times 10^{9}$，$\\nu=0.49$，$t=0.001$。\n- 用例4（顺时针节点排序）：$(x_1,y_1)=(0,0)$，$(x_2,y_2)=(0,2)$，$(x_3,y_3)=(2,0)$，$E=50\\times 10^{9}$，$\\nu=0.20$，$t=0.02$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。外层列表按上述顺序列出每个测试用例的一个条目。每个条目本身是一个方括号括起来的列表，包含按行主序展开的 $\\mathbf{K}_e$ 的36个条目。唯一可接受的输出格式是：\n- 单行输出，\n- 任何地方都没有空格，\n- 方括号和逗号完全用作分隔符，\n- 每个数字以 N/m 为单位四舍五入到六位有效数字。\n\n例如，整体结构必须如下：\n\"[[k11_case1,k12_case1,...,k66_case1],[k11_case2,...,k66_case2],[k11_case3,...,k66_case3],[k11_case4,...,k66_case4]]\"\n\n不应打印任何其他文本。输入嵌入在程序中；不需要用户输入。程序必须是完整且可运行的。",
            "solution": "所提出的问题是有效的，因为它在科学上基于线性弹性和有限元法的原理，数据充分，问题适定，并使用了客观、正式的语言。我们开始进行求解。\n\n目标是推导并实现一个在平面应变状态下的三节点常应变三角形（CST）单元的单元刚度矩阵 $\\mathbf{K}_e$。推导过程遵循一系列基于连续介质力学和有限元分析原理的步骤。\n\n步骤 $1$：运动学与应变-位移矩阵 ($\\mathbf{B}$)\n\n三角形单元内的位移场 $\\mathbf{u}(x,y) = \\begin{bmatrix} u(x,y)  v(x,y) \\end{bmatrix}^{\\top}$ 是通过三个节点 $i \\in \\{1, 2, 3\\}$ 处的离散节点位移 $\\mathbf{u}_i = \\begin{bmatrix} u_i  v_i \\end{bmatrix}^{\\top}$ 插值得到的。这种插值通过使用线性形函数 $N_i(x,y)$ 来实现：\n$$ u(x,y) = \\sum_{i=1}^{3} N_i(x,y) u_i $$\n$$ v(x,y) = \\sum_{i=1}^{3} N_i(x,y) v_i $$\n形函数 $N_i(x,y)$ 由节点坐标 $(x_j, y_j)$ 和单元面积 $A$ 唯一确定。三角形的面积可以使用增广坐标矩阵的行列式计算：\n$$ A = \\frac{1}{2} \\det \\begin{pmatrix} 1  x_1  y_1 \\\\ 1  x_2  y_2 \\\\ 1  x_3  y_3 \\end{pmatrix} = \\frac{1}{2} \\left[ x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2) \\right] $$\n对于线性三角形单元，形函数的梯度在单元域 $\\Omega_e$ 上是常数。第 $i$ 个形函数的梯度为：\n$$ \\nabla N_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\frac{1}{2A} \\begin{pmatrix} \\beta_i \\\\ \\gamma_i \\end{pmatrix} $$\n其中系数 $\\beta_i$ 和 $\\gamma_i$ 是节点坐标的函数，通过指标 $(i, j, k) \\in \\{(1, 2, 3), (2, 3, 1), (3, 1, 2)\\}$ 的循环置换来定义：\n$$ \\beta_i = y_j - y_k $$\n$$ \\gamma_i = x_k - x_j $$\n使用工程剪应变 $\\gamma_{xy}$ 的无穷小应变向量定义为 $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} \\varepsilon_{xx}  \\varepsilon_{yy}  \\gamma_{xy} \\end{bmatrix}^{\\top}$。应变分量由位移场导出：\n$$ \\varepsilon_{xx} = \\frac{\\partial u}{\\partial x} = \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial x} u_i $$\n$$ \\varepsilon_{yy} = \\frac{\\partial v}{\\partial y} = \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial y} v_i $$\n$$ \\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x} = \\sum_{i=1}^3 \\left( \\frac{\\partial N_i}{\\partial y} u_i + \\frac{\\partial N_i}{\\partial x} v_i \\right) $$\n应变与节点位移之间的这种线性关系可以紧凑地写为 $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u}_e$，其中 $\\mathbf{u}_e = \\begin{bmatrix} u_1  v_1  u_2  v_2  u_3  v_3 \\end{bmatrix}^{\\top}$ 是节点自由度向量。应变-位移矩阵 $\\mathbf{B}$ 是一个由形函数梯度组装而成的 $3 \\times 6$ 矩阵：\n$$ \\mathbf{B} = \\frac{1}{2A} \\begin{bmatrix} \\beta_1  0  \\beta_2  0  \\beta_3  0 \\\\ 0  \\gamma_1  0  \\gamma_2  0  \\gamma_3 \\\\ \\gamma_1  \\beta_1  \\gamma_2  \\beta_2  \\gamma_3  \\beta_3 \\end{bmatrix} $$\n\n步骤 $2$：本构律与弹性矩阵 ($\\mathbf{D}$)\n\n对于处于平面应变条件（$\\varepsilon_{zz}=0$）下的线性弹性、各向同性材料，应力向量 $\\boldsymbol{\\sigma} = \\begin{bmatrix} \\sigma_{xx}  \\sigma_{yy}  \\tau_{xy} \\end{bmatrix}^{\\top}$ 通过广义胡克定律与应变向量 $\\boldsymbol{\\varepsilon}$ 相关联，即 $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$。$3 \\times 3$ 的平面应变弹性矩阵 $\\mathbf{D}$ 用杨氏模量 $E$ 和泊松比 $\\nu$ 表示为：\n$$ \\mathbf{D} = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{bmatrix} 1-\\nu  \\nu  0 \\\\ \\nu  1-\\nu  0 \\\\ 0  0  \\frac{1-2\\nu}{2} \\end{bmatrix} $$\n对于均匀材料，该矩阵是对称且恒定的。\n\n步骤 $3$：单元刚度矩阵 ($\\mathbf{K}_e$) 组装\n\n单元刚度矩阵 $\\mathbf{K}_e$ 量化了节点力与节点位移之间的关系。它由虚功原理推导得出，并通过在单元域 $\\Omega_e$ 上的积分给出：\n$$ \\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^{\\top} \\mathbf{D} \\mathbf{B} \\, t \\, d\\Omega $$\n其中 $t$ 是恒定的单元厚度。CST单元的一个关键特性是，矩阵 $\\mathbf{B}$ 和 $\\mathbf{D}$（对于均匀材料）在整个单元内是常数。因此，被积函数是常数，积分简化为被积函数与单元面积 $|A|$ 的乘积：\n$$ \\mathbf{K}_e = (\\mathbf{B}^{\\top} \\mathbf{D} \\mathbf{B}) \\, t\\, |A| $$\n使用面积的绝对值 $|A|$ 可以确保最终的刚度矩阵是正定的，无论节点是按顺时针还是逆时针方向排序。代入 $\\mathbf{B}$ 的完整表达式：\n$$ \\mathbf{K}_e = \\left( \\frac{1}{2A} \\mathbf{B}^* \\right)^{\\top} \\mathbf{D} \\left( \\frac{1}{2A} \\mathbf{B}^* \\right) \\, t \\, |A| = \\frac{t|A|}{4A^2} (\\mathbf{B}^*)^{\\top} \\mathbf{D} \\mathbf{B}^* $$\n其中 $\\mathbf{B}^* = 2A \\mathbf{B}$ 是没有 $1/(2A)$ 缩放因子的应变-位移矩阵。由于 $A^2 = |A|^2$，表达式简化为一种计算上稳健的形式：\n$$ \\mathbf{K}_e = \\frac{t}{4|A|} (\\mathbf{B}^*)^{\\top} \\mathbf{D} \\mathbf{B}^* $$\n这个最终表达式被用于计算 $6 \\times 6$ 的对称单元刚度矩阵。该过程涉及计算几何项（$\\beta_i, \\gamma_i, |A|$），构建矩阵 $\\mathbf{B}^*$ 和 $\\mathbf{D}$，并执行指定的矩阵乘法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve for the element stiffness matrix for all test cases.\n    \"\"\"\n\n    def round_to_significant_figures(value, sf):\n        \"\"\"\n        Rounds a number to a specified number of significant figures.\n        \"\"\"\n        if value == 0:\n            return 0.0\n        # Calculate the position of the most significant digit\n        pos = math.floor(math.log10(abs(value)))\n        # Determine the number of decimal places for rounding\n        precision = sf - 1 - pos\n        return round(value, int(precision))\n\n    def get_stiffness_matrix(nodes, E, nu, t):\n        \"\"\"\n        Computes the constant-strain triangle stiffness matrix for plane strain.\n\n        Args:\n            nodes (list of tuples): A list of three (x, y) coordinate tuples for the triangle nodes.\n            E (float): Young's modulus in Pascals.\n            nu (float): Poisson's ratio (dimensionless).\n            t (float): Element thickness in meters.\n\n        Returns:\n            numpy.ndarray: The 6x6 element stiffness matrix.\n        \"\"\"\n        # Step 1: Nodal coordinates and element geometry\n        (x1, y1), (x2, y2), (x3, y3) = nodes\n        \n        # Calculate the signed area of the triangle. The formula's sign depends on node ordering (CCW is positive).\n        A_signed = 0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n        if abs(A_signed)  1e-15:\n            # Handle degenerate triangles (collinear nodes)\n            raise ValueError(\"Element has zero area; nodes may be collinear.\")\n        \n        A_abs = abs(A_signed)\n\n        # Step 2: Components for the strain-displacement matrix (B)\n        # These are derived from the gradients of the linear shape functions.\n        # beta_i = y_j - y_k\n        # gamma_i = x_k - x_j\n        # (i,j,k) are cyclic permutations of (1,2,3)\n        beta1 = y2 - y3\n        beta2 = y3 - y1\n        beta3 = y1 - y2\n        \n        gamma1 = x3 - x2\n        gamma2 = x1 - x3\n        gamma3 = x2 - x1\n        \n        # B_star is the B matrix without the 1/(2A) scaling factor.\n        B_star = np.array([\n            [beta1, 0,     beta2, 0,     beta3, 0    ],\n            [0,     gamma1, 0,    gamma2, 0,     gamma3],\n            [gamma1, beta1, gamma2, beta2, gamma3, beta3 ]\n        ], dtype=float)\n\n        # Step 3: Constitutive matrix (D) for plane strain\n        # This matrix relates stress to strain for an isotropic material.\n        # The form used here is for engineering shear strain.\n        prefactor_D = E / ((1 + nu) * (1 - 2 * nu))\n        D = prefactor_D * np.array([\n            [1 - nu, nu,     0              ],\n            [nu,     1 - nu, 0              ],\n            [0,      0,      (1 - 2 * nu) / 2]\n        ], dtype=float)\n\n        # Step 4: Element stiffness matrix (K_e) assembly\n        # K_e = (t / (4 * |A|)) * B*^T @ D @ B*\n        K_e = (t / (4 * A_abs)) * (B_star.T @ D @ B_star)\n        \n        return K_e\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Right triangle, common material (steel-like)\n        {'nodes': [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0)], 'E': 210e9, 'nu': 0.30, 't': 0.01},\n        # Case 2: Equilateral triangle, different material (aluminum-like)\n        {'nodes': [(0.0, 0.0), (1.0, 0.0), (0.5, np.sqrt(3)/2)], 'E': 70e9, 'nu': 0.25, 't': 0.005},\n        # Case 3: Nearly incompressible material, small element\n        {'nodes': [(0.0, 0.0), (0.001, 0.0), (0.0, 0.002)], 'E': 100e9, 'nu': 0.49, 't': 0.001},\n        # Case 4: Clockwise node ordering to test robustness of area calculation\n        {'nodes': [(0.0, 0.0), (0.0, 2.0), (2.0, 0.0)], 'E': 50e9, 'nu': 0.20, 't': 0.02},\n    ]\n\n    # Process each test case and collect results\n    results_as_strings = []\n    for case in test_cases:\n        K_e = get_stiffness_matrix(case['nodes'], case['E'], case['nu'], case['t'])\n        \n        # Flatten the 6x6 matrix into a 1D array of 36 elements (row-major)\n        flattened_K = K_e.flatten()\n\n        # Round each value to 6 significant figures\n        rounded_values = [round_to_significant_figures(val, 6) for val in flattened_K]\n\n        # Format the numbers into a comma-separated string enclosed in brackets\n        case_result_string = f\"[{','.join(map(str, rounded_values))}]\"\n        results_as_strings.append(case_result_string)\n\n    # Final print statement in the exact required format: [[...],[...],...]\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在计算材料科学中，一个核心任务是从第一性原理或分子动力学模拟中提取材料的宏观本构参数。本练习模拟了这一过程，要求您设计一个计算实验来提取一个低对称性晶体的完整各向异性刚度张量$C_{ijkl}$。您将学习如何通过施加一系列精心选择的应变状态，并利用最小二乘法拟合应力-应变数据，来确定材料常数，同时还将探索如何通过优化实验设计来最小化拟合参数的数值不确定性。",
            "id": "3490639",
            "problem": "您的任务是设计并实现一个计算实验，该实验基于小应变线性弹性理论的第一性原理，通过施加有限变形生成的合成密度泛函理论 (DFT) 数据，提取低对称性晶体的完整各向异性刚度张量 $C_{ijkl}$。您的目标是构建并比较几组不同的独立应变状态，然后选择在指定的应力噪声模型下，能够使拟合刚度参数的数值协方差最小化的那一组。所有计算必须在采用工程剪切约定的标准 Voigt 表示法中进行。\n\n问题必须仅使用以下基本概念进行表述和求解：\n- 小应变运动学：无穷小应变张量 $\\,\\varepsilon_{ij} = \\tfrac{1}{2}\\left(\\partial u_i/\\partial x_j + \\partial u_j/\\partial x_i\\right)\\,$。\n- 线性弹性（胡克定律）：柯西应力张量 $\\,\\sigma_{ij}\\,$ 与应变呈线性关系，即 $\\,\\sigma_{ij} = C_{ijkl}\\,\\varepsilon_{kl}\\,$.\n- 采用工程剪切约定的标准 Voigt 映射：\n  - 应变向量 $\\,\\mathbf{e} = [\\varepsilon_{11},\\varepsilon_{22},\\varepsilon_{33},2\\varepsilon_{23},2\\varepsilon_{13},2\\varepsilon_{12}]^\\top\\,$。\n  - 应力向量 $\\,\\mathbf{s} = [\\sigma_{11},\\sigma_{22},\\sigma_{33},\\sigma_{23},\\sigma_{13},\\sigma_{12}]^\\top\\,$。\n  - 在 Voigt 形式下，$\\,\\mathbf{s} = \\mathbf{C}\\,\\mathbf{e}\\,$，其中 $\\,\\mathbf{C}\\,$ 是一个 $\\,6\\times 6\\,$ 的对称正定刚度矩阵，它根据上述映射编码了各向异性刚度张量 $\\,C_{ijkl}\\,$。\n\n您的程序必须严格从这些定义和定律出发，实现以下内容：\n\n- 通过以下确定性程序，在 Voigt 形式下构造一个单位为吉帕斯卡 (GPa) 的合成“基准真相”全各向异性刚度矩阵 $\\,\\mathbf{C}^\\star\\,$，该矩阵为对称正定矩阵：\n  - 令 $\\,\\mathbf{A}\\in\\mathbb{R}^{6\\times 6}\\,$ 是一个矩阵，其元素使用种子为 $\\,20231105\\,$ 的伪随机数生成器从标准正态分布中抽取。计算瘦 $\\,\\mathbf{Q}\\mathbf{R}\\,$ 分解 $\\,\\mathbf{A}=\\mathbf{Q}\\mathbf{R}\\,$，其中 $\\,\\mathbf{Q}\\in\\mathbb{R}^{6\\times 6}\\,$ 是正交矩阵。通过将 $\\,\\mathbf{Q}\\,$ 右乘 $\\,\\mathrm{diag}(\\mathrm{sign}(\\mathrm{diag}(\\mathbf{R})))\\,$ 来强制其为正常正交矩阵。\n  - 令 $\\,\\mathbf{D}=\\mathrm{diag}([300,250,220,100,90,80])\\,$，单位为 GPa（所有对角线元素单位均为 GPa）。定义 $\\,\\mathbf{C}^\\star = \\mathbf{Q}^\\top \\mathbf{D}\\,\\mathbf{Q}\\,$，单位为 GPa。这将生成一个对称正定的 $\\,\\mathbf{C}^\\star\\,$，它在 Voigt 形式下代表一个低对称性晶体。\n\n- 生成不添加测量噪声的合成 DFT 应力：对于每个给定的应变状态 $\\,\\mathbf{e}^{(s)}\\,$，计算 $\\,\\mathbf{s}^{(s)} = \\mathbf{C}^\\star \\mathbf{e}^{(s)}\\,$，单位为 GPa。\n\n- 仅使用上述定义，通过普通最小二乘法拟合刚度。将 $\\,S\\,$ 个应变状态堆叠成一个矩阵 $\\,\\mathbf{E}\\in\\mathbb{R}^{S\\times 6}\\,$（每行为 $\\,\\mathbf{e}^{(s)\\top}\\,$），并将相应的应力堆叠成矩阵 $\\,\\mathbf{S}\\in\\mathbb{R}^{S\\times 6}\\,$（每行为 $\\,\\mathbf{s}^{(s)\\top}\\,$）。将每个应力分量视为对 $\\,\\mathbf{E}\\,$ 的独立线性回归，以获得无约束估计 $\\,\\widehat{\\mathbf{C}}\\in\\mathbb{R}^{6\\times 6}\\,$，然后通过投影 $\\,\\widehat{\\mathbf{C}} \\leftarrow \\tfrac{1}{2}\\left(\\widehat{\\mathbf{C}}+\\widehat{\\mathbf{C}}^\\top\\right)\\,$ 强制其具有主对称性。除了从 $\\,\\mathbf{s}=\\mathbf{C}\\mathbf{e}\\,$ 和标准最小二乘代数导出的公式外，不要使用任何其他公式。\n\n- 假设一个单位为 GPa 的不相关、同方差应力噪声模型：每个应力分量都具有零均值、方差为 $\\,\\sigma_\\mathrm{noise}^2\\,$ 的高斯噪声（尽管您不会向合成的 $\\mathbf{s}^{(s)}$ 添加噪声），并用它来计算设计所隐含的参数协方差。在此模型下，每行的回归协方差为 $\\,\\sigma_\\mathrm{noise}^2\\left(\\mathbf{E}^\\top\\mathbf{E}\\right)^{-1}\\,$，在强制主对称性之前，这为 $\\,36\\,$ 个参数产生一个块对角协方差。使用以下数值稳定性和不确定性的标量总结：\n  - $\\,\\mathbf{E}\\,$ 的谱条件数，定义为其最大奇异值与最小奇异值之比；如果 $\\,\\mathbf{E}\\,$ 是秩亏的，则将条件数定义为 $+\\infty$。\n  - A-最优性度量 $\\,\\mathrm{A} = \\mathrm{tr}\\big(\\mathrm{Cov}(\\mathrm{vec}(\\widehat{\\mathbf{C}}))\\big)\\,$，根据对称投影之前的块对角协方差计算，当 $\\,\\mathbf{E}\\,$ 满列秩时，其值等于 $\\,6\\,\\sigma_\\mathrm{noise}^2\\,\\mathrm{tr}\\!\\left((\\mathbf{E}^\\top\\mathbf{E})^{-1}\\right)\\,$。\n\n您必须比较三种候选的应变状态设计，每种设计都由指定的应变幅值 $\\,a\\,$（无量纲）缩放。对每种状态使用上述 Voigt 向量约定：\n\n- 设计 $\\,1$（秩亏边界情况）：$\\,S=6\\,$ 个状态，仅包含重复的正应变，各行为\n  - $\\,\\mathbf{e}^{(1)}=a\\,[1,0,0,0,0,0]^\\top\\,$,\n  - $\\,\\mathbf{e}^{(2)}=a\\,[0,1,0,0,0,0]^\\top\\,$,\n  - $\\,\\mathbf{e}^{(3)}=a\\,[0,0,1,0,0,0]^\\top\\,$,\n  - $\\,\\mathbf{e}^{(4)}=a\\,[1,0,0,0,0,0]^\\top\\,$,\n  - $\\,\\mathbf{e}^{(5)}=a\\,[0,1,0,0,0,0]^\\top\\,$,\n  - $\\,\\mathbf{e}^{(6)}=a\\,[0,0,1,0,0,0]^\\top\\,$.\n\n- 设计 $\\,2$（正交归一的 $\\,6$ 状态基）：$\\,S=6\\,$ 个状态，由 Voigt 空间中经 $\\,a\\,$ 缩放的 $\\,6\\times 6\\,$ 单位矩阵给出，\n  - $\\,\\mathbf{e}^{(1)}=a\\,[1,0,0,0,0,0]^\\top, \\ldots, \\mathbf{e}^{(6)}=a\\,[0,0,0,0,0,1]^\\top\\,$.\n\n- 设计 $\\,3$（超定的随机单位应变）：$\\,S=30\\,$ 个状态，每行通过使用种子 $\\,7\\,$ 抽取一个 $\\,6$ 维标准正态向量，将其在 Voigt 空间中归一化为单位欧几里得范数，然后乘以 $\\,a\\,$ 来独立生成。\n\n您必须评估以下测试案例集，每个案例都有指定的应变幅值 $\\,a\\,$ 和假设的应力噪声标准差 $\\,\\sigma_\\mathrm{noise}\\,$（单位为 GPa）：\n\n- 案例 $\\,1$：$\\,a=0.005\\,$，$\\,\\sigma_\\mathrm{noise}=0.02\\,$ GPa。\n- 案例 $\\,2$：$\\,a=0.001\\,$，$\\,\\sigma_\\mathrm{noise}=0.05\\,$ GPa。\n- 案例 $\\,3$：$\\,a=0.02\\,$，$\\,\\sigma_\\mathrm{noise}=0.005\\,$ GPa。\n\n对于每个案例，针对每种设计，计算最小二乘估计 $\\,\\widehat{\\mathbf{C}}\\,$（单位 GPa）、$\\,\\mathbf{E}\\,$ 的谱条件数以及 A-最优性度量 $\\,\\mathrm{A}\\,$（单位 GPa$^2$）。然后，为每个案例选择 A-最优性度量 $\\,\\mathrm{A}\\,$ 最小的设计作为最优设计；如有平局，则选择条件数较小的；若仍为平局，则选择设计索引最小的。\n\n物理和数值单位：所有刚度和应力值必须以吉帕斯卡 (GPa) 为单位。应变是无量纲的。不要向合成应力添加随机噪声；仅使用噪声水平来计算隐含的协方差。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是对应案例所选最优设计的设计索引整数，顺序与上述案例顺序一致。例如，您的程序应打印格式为“[d1,d2,d3]”的一行。",
            "solution": "我们从小应变线性弹性的第一性原理出发。无穷小应变张量为 $\\varepsilon_{ij} = \\tfrac{1}{2}\\left(\\partial u_i/\\partial x_j + \\partial u_j/\\partial x_i\\right)$。在线性弹性范围内，胡克定律表述为 $\\sigma_{ij} = C_{ijkl}\\,\\varepsilon_{kl}$，其中 $C_{ijkl}$ 是四阶刚度张量，具有次对称性和主对称性，其正定性确保对于所有非零 $\\varepsilon_{ij}$，都有 $\\varepsilon_{ij} C_{ijkl} \\varepsilon_{kl} > 0$。\n\n使用采用工程剪切约定的标准 Voigt 映射，我们定义应变向量 $\\mathbf{e} = [\\varepsilon_{11}, \\varepsilon_{22}, \\varepsilon_{33}, 2\\varepsilon_{23}, 2\\varepsilon_{13}, 2\\varepsilon_{12}]^\\top$ 和应力向量 $\\mathbf{s} = [\\sigma_{11}, \\sigma_{22}, \\sigma_{33}, \\sigma_{23}, \\sigma_{13}, \\sigma_{12}]^\\top$。在此映射下，胡克定律变为 $6\\times 6$ 的线性关系 $\\mathbf{s} = \\mathbf{C}\\,\\mathbf{e}$，其中 $\\mathbf{C}$ 是对称正定的，即对于所有非零 $\\mathbf{e}$，都有 $\\mathbf{e}^\\top \\mathbf{C}\\, \\mathbf{e} > 0$。\n\n为了从合成的密度泛函理论 (DFT) 数据中估计 $\\mathbf{C}$，我们施加一组应变状态 $\\{\\mathbf{e}^{(s)}\\}_{s=1}^S$，并为一个固定但未知的基准真相 $\\mathbf{C}^\\star$ 获得应力 $\\mathbf{s}^{(s)} = \\mathbf{C}^\\star \\mathbf{e}^{(s)}$。将 $\\mathbf{e}^{(s)}$ 堆叠成矩阵 $\\mathbf{E}\\in\\mathbb{R}^{S\\times 6}$（各行为 $\\mathbf{e}^{(s)\\top}$），并将 $\\mathbf{s}^{(s)}$ 堆叠成矩阵 $\\mathbf{S}\\in\\mathbb{R}^{S\\times 6}$（各行为 $\\mathbf{s}^{(s)\\top}$），胡克定律给出 $\\mathbf{S} = \\mathbf{E}\\, \\mathbf{C}^\\top$。对于每个应力分量（即 $\\mathbf{S}$ 的每一列），我们有一个对 $\\mathbf{E}$ 各列的线性回归。$\\mathbf{C}$ 的第 $\\alpha$ 行（表示为 $\\mathbf{c}_\\alpha^\\top$）的普通最小二乘 (OLS) 估计量是\n$$\n\\widehat{\\mathbf{c}}_\\alpha = \\left(\\mathbf{E}^\\top \\mathbf{E}\\right)^{-1}\\mathbf{E}^\\top\\, \\mathbf{s}_\\alpha,\n$$\n前提是 $\\mathbf{E}$ 具有满列秩。将这些堆叠起来得到 $\\widehat{\\mathbf{C}}^\\top = \\left(\\mathbf{E}^\\top \\mathbf{E}\\right)^{-1}\\mathbf{E}^\\top \\mathbf{S}$。为了强制执行 Voigt 形式中由 $C_{ijkl}=C_{klij}$ 所隐含的主对称性，我们投影到对称部分，\n$$\n\\widehat{\\mathbf{C}} \\leftarrow \\tfrac{1}{2}\\left(\\widehat{\\mathbf{C}} + \\widehat{\\mathbf{C}}^\\top\\right).\n$$\n\n接下来我们量化数值稳定性和不确定性。在一个不相关、同方差的应力噪声模型下，每个应力分量的方差为 $\\sigma_\\mathrm{noise}^2$ (单位 GPa$^2$) ，每行估计的 OLS 协方差为\n$$\n\\mathrm{Cov}\\!\\left(\\widehat{\\mathbf{c}}_\\alpha\\right) \\;=\\; \\sigma_\\mathrm{noise}^2 \\left(\\mathbf{E}^\\top \\mathbf{E}\\right)^{-1}.\n$$\n在应用对称投影之前，$\\mathbf{C}$ 的 $36$ 个参数的完整参数协方差是块对角的，有 $6$ 个相同的 $6\\times 6$ 块，因此 A-最优性度量（协方差的迹）是\n$$\n\\mathrm{A} \\;=\\; 6\\,\\sigma_\\mathrm{noise}^2 \\,\\mathrm{tr}\\!\\left(\\left(\\mathbf{E}^\\top \\mathbf{E}\\right)^{-1}\\right),\n$$\n只要 $\\mathbf{E}$ 是满列秩。如果 $\\mathbf{E}$ 是秩亏的，那么 $\\left(\\mathbf{E}^\\top \\mathbf{E}\\right)^{-1}$ 不存在，我们设定 $\\mathrm{A}=+\\infty$。$\\mathbf{E}$ 的谱条件数是其最大奇异值与最小奇异值之比，如果矩阵是秩亏的，我们也将其设为 $+\\infty$。\n\n我们通过对角矩阵的确定性正交相似变换来定义 Voigt 形式下的合成基准真相 $\\mathbf{C}^\\star$，以确保其正定性。令 $\\mathbf{A}\\in\\mathbb{R}^{6\\times 6}$ 为使用种子 $20231105$ 的标准正态分布矩阵。计算 $\\mathbf{A}=\\mathbf{Q}\\mathbf{R}$ 并通过右乘 $\\mathrm{diag}(\\mathrm{sign}(\\mathrm{diag}(\\mathbf{R})))$ 来强制 $\\mathbf{Q}$ 为正常正交矩阵。使用 $\\mathbf{D}=\\mathrm{diag}([300,250,220,100,90,80])$（单位 GPa），定义 $\\mathbf{C}^\\star = \\mathbf{Q}^\\top \\mathbf{D}\\,\\mathbf{Q}$（单位 GPa）。这个 $\\mathbf{C}^\\star$ 是对称正定的，并在 Voigt 形式下代表一个低对称性晶体。\n\n我们比较三种应变状态的设计，每种都由振幅 $a$ 缩放：\n- 设计 $1$ 仅使用重复的正应变，因此 $\\mathbf{E}$ 只有前三列非零，是秩亏的。因此，对于所有 $a$，其条件数和 $\\mathrm{A}$ 均为 $+\\infty$。\n- 设计 $2$ 使用由 $a$ 缩放的 $6\\times 6$ 单位矩阵，因此 $\\mathbf{E} = a\\,\\mathbf{I}_6$ 且 $\\mathbf{E}^\\top \\mathbf{E} = a^2 \\mathbf{I}_6$。于是 $\\left(\\mathbf{E}^\\top \\mathbf{E}\\right)^{-1} = a^{-2}\\mathbf{I}_6$，条件数为 $1$，A-最优性度量为\n$$\n\\mathrm{A}_2 = 6\\,\\sigma_\\mathrm{noise}^2\\,\\mathrm{tr}(a^{-2}\\mathbf{I}_6) = 6\\,\\sigma_\\mathrm{noise}^2 \\cdot 6\\,a^{-2} = 36\\,\\sigma_\\mathrm{noise}^2/a^2.\n$$\n- 设计 $3$ 在 Voigt 空间中使用 $S=30$ 个随机单位向量（种子为 $7$），并由 $a$ 缩放。在期望上，$\\mathbf{E}^\\top \\mathbf{E}$ 与 $a^2 \\mathbf{I}_6$ 成比例，具体接近 $a^2 (S/6)\\,\\mathbf{I}_6$，产生的 A-最优性近似为\n$$\n\\mathrm{A}_3 \\approx 6\\,\\sigma_\\mathrm{noise}^2\\,\\mathrm{tr}\\!\\left(\\left(a^2 (S/6)\\,\\mathbf{I}_6\\right)^{-1}\\right) \\;=\\; 6\\,\\sigma_\\mathrm{noise}^2 \\cdot 6 \\cdot \\frac{6}{a^2 S} \\;=\\; \\frac{216\\,\\sigma_\\mathrm{noise}^2}{a^2 S}.\n$$\n对于 $S=30$，这个值是 $7.2\\,\\sigma_\\mathrm{noise}^2/a^2$，严格小于设计 $2$ 的 $36\\,\\sigma_\\mathrm{noise}^2/a^2$。因此，我们预期对于任何正的 $a$ 和 $\\sigma_\\mathrm{noise}$，设计 $3$ 在这三者中都是最优的。\n\n我们现在应用测试集：\n- 案例 $1$：$a=0.005$，$\\sigma_\\mathrm{noise}=0.02$ GPa。\n- 案例 $2$：$a=0.001$，$\\sigma_\\mathrm{noise}=0.05$ GPa。\n- 案例 $3$：$a=0.02$，$\\sigma_\\mathrm{noise}=0.005$ GPa。\n\n在所有情况下，设计 $1$ 都是秩亏的，$\\mathrm{A}=+\\infty$。设计 $2$ 有有限的 $\\mathrm{A}_2=36\\,\\sigma_\\mathrm{noise}^2/a^2$，而设计 $3$ 因为有更多独立的应变状态，其 $\\mathrm{A}_3$ 更小。因此，在所有三种情况下，设计 $3$ 都最小化了 A-最优性度量。如果需要，谱条件数也支持设计 $2$ 和设计 $3$ 优于设计 $1$；设计 $2$ 的条件数为 $1$，而设计 $3$ 有很大概率是良态的。\n\n因此，这三种情况下的最优设计索引是 $[3,3,3]$。要求的输出是包含这些整数并用方括号括起来的单行文本。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_true_C():\n    \"\"\"\n    Construct a symmetric positive-definite 6x6 stiffness matrix C* in Voigt form (GPa)\n    using a deterministic procedure:\n    - Generate a random 6x6 matrix with standard normal entries (seed=20231105).\n    - Perform QR decomposition to get an orthogonal Q (adjusted to be proper).\n    - Form C* = Q^T D Q with D = diag([300,250,220,100,90,80]) GPa.\n    \"\"\"\n    rng = np.random.default_rng(20231105)\n    A = rng.standard_normal((6, 6))\n    Q, R = np.linalg.qr(A)\n    # Enforce proper orthogonal Q: make diag of R positive\n    sign_diag = np.sign(np.diag(R))\n    sign_diag[sign_diag == 0.0] = 1.0\n    Q = Q @ np.diag(sign_diag)\n    D = np.diag([300.0, 250.0, 220.0, 100.0, 90.0, 80.0])\n    C = Q.T @ D @ Q\n    # Symmetrize numerically\n    C = 0.5 * (C + C.T)\n    return C\n\ndef design_strains(design_id, a):\n    \"\"\"\n    Return strain design matrix E (S x 6) for the given design and amplitude a.\n    Voigt mapping with engineering shear: e = [e11,e22,e33,2e23,2e13,2e12].\n    Designs:\n      1: Rank-deficient, only normal strains repeated (6 states).\n      2: Orthonormal 6-state basis (identity) scaled by a.\n      3: 30 random unit 6-vectors (seed=7) scaled by a.\n    \"\"\"\n    if design_id == 1:\n        E = np.array([\n            [1,0,0,0,0,0],\n            [0,1,0,0,0,0],\n            [0,0,1,0,0,0],\n            [1,0,0,0,0,0],\n            [0,1,0,0,0,0],\n            [0,0,1,0,0,0],\n        ], dtype=float)\n        return a * E\n    elif design_id == 2:\n        E = np.eye(6, dtype=float)\n        return a * E\n    elif design_id == 3:\n        rng = np.random.default_rng(7)\n        rows = []\n        for _ in range(30):\n            v = rng.standard_normal(6)\n            nrm = np.linalg.norm(v)\n            # Avoid zero norm; extremely unlikely\n            if nrm == 0.0:\n                v = np.array([1,0,0,0,0,0], dtype=float)\n                nrm = 1.0\n            rows.append((v / nrm) * a)\n        return np.vstack(rows)\n    else:\n        raise ValueError(\"Unknown design_id\")\n\ndef fit_C_and_metrics(C_true, E, sigma_noise):\n    \"\"\"\n    Given true C (6x6), strain design E (Sx6), and noise std sigma_noise (GPa),\n    compute synthetic stresses S (Sx6) without noise, OLS estimate C_hat, and metrics:\n    - Spectral condition number of E (inf if rank deficient).\n    - A-optimality metric A = 6 * sigma_noise^2 * trace( (E^T E)^{-1} ) (inf if rank deficient).\n    Returns (C_hat, condE, A_metric).\n    \"\"\"\n    # Synthetic stress data: S = E * C_true^T (since S rows are s^T)\n    S = E @ C_true.T  # shape S x 6\n    # Compute (E^T E) and its inverse or pseudo-inverse\n    EtE = E.T @ E\n    # Check rank\n    svals = np.linalg.svd(E, compute_uv=False)\n    tol = np.finfo(float).eps * max(E.shape) * svals[0] if svals.size > 0 else 0.0\n    rank = np.sum(svals > tol)\n    if rank  6:\n        condE = float('inf')\n        A_metric = float('inf')\n        # Least squares fit using pseudoinverse for completeness\n        # C_hat^T = (E^T E)^+ E^T S\n        EtE_pinv = np.linalg.pinv(EtE)\n        C_hat_T = EtE_pinv @ E.T @ S\n    else:\n        condE = float(svals[0] / svals[-1])\n        EtE_inv = np.linalg.inv(EtE)\n        A_metric = 6.0 * (sigma_noise ** 2) * np.trace(EtE_inv)\n        C_hat_T = EtE_inv @ E.T @ S\n    C_hat = C_hat_T.T\n    # Enforce major symmetry\n    C_hat = 0.5 * (C_hat + C_hat.T)\n    return C_hat, condE, A_metric\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (a, sigma_noise_GPa)\n    test_cases = [\n        (0.005, 0.02),   # Case 1\n        (0.001, 0.05),   # Case 2\n        (0.02, 0.005),   # Case 3\n    ]\n\n    C_true = build_true_C()\n\n    results = []\n    for a, sigma_noise in test_cases:\n        design_metrics = []\n        for design_id in (1, 2, 3):\n            E = design_strains(design_id, a)\n            C_hat, condE, A_metric = fit_C_and_metrics(C_true, E, sigma_noise)\n            design_metrics.append((design_id, A_metric, condE))\n        # Select optimal: min A_metric, tie-break by condE, then by design_id\n        # Filter to numeric comparable values; inf compares as larger in Python\n        design_metrics.sort(key=lambda t: (t[1], t[2], t[0]))\n        best_design = design_metrics[0][0]\n        results.append(best_design)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "当材料参数未知且需要从边界测量数据中反演时，我们便进入了参数校准的领域，这是一个典型的逆问题。虽然有限差分法可以用于计算目标函数对参数的梯度，但其计算成本高昂。本高级练习将引导您实现一种更为高效和优雅的梯度计算方法——伴随法（Adjoint Method），并将其应用于校准弹性常数，最后通过与有限差分结果的对比来验证其准确性。掌握伴随法是进行大规模优化和设计问题的关键一步。",
            "id": "3490664",
            "problem": "实现一种基于伴随方法的梯度计算，用于二维、小应变、线弹性问题，该问题具有空间均匀但各向异性的弹性常数，并与有限差分法的结果进行比较以验证其灵敏度。所有量均为无量纲。您的程序必须使用有限元法（FEM）在矩形网格上使用线性三角形单元组装离散正演模型，施加混合边界条件，计算位移场，定义一个边界失配泛函，推导并实现伴随求解，以获得失配泛函相对于四阶刚度张量选定分量的梯度，并将伴随梯度与中心有限差分梯度进行比较。最终输出必须是单行，包含一个浮点数列表，具体格式见本说明末尾。\n\n从以下基本原理出发：\n- 无体力情况下的线性动量平衡：在域内 $-\\partial_j \\sigma_{ij} = 0$。\n- 小应变定义：$\\varepsilon_{kl} = \\dfrac{1}{2}(\\partial_k u_l + \\partial_l u_k)$。\n- 具有恒定刚度的线弹性本构关系：$\\sigma_{ij} = C_{ijkl} \\varepsilon_{kl}$。\n- 平衡的弱形式：求 $u_i$ 使得 $\\int_{\\Omega} \\varepsilon_{ij}(v)\\, C_{ijkl}\\, \\varepsilon_{kl}(u)\\, d\\Omega = \\int_{\\Gamma_t} v_i\\, t_i\\, d\\Gamma$ 对于所有容许的测试函数 $v_i$ 均成立，其中 $t_i$ 是在诺伊曼边界 $\\Gamma_t$ 上施加的面力，而 $u_i$ 是在狄利克雷边界上给定的。\n\n离散化与参数化：\n- 使用尺寸为 $L_x \\times L_y$ 的矩形域，由 $n_x \\times n_y$ 个节点的均匀网格划分，并分割为线性三角形单元（每个矩形两个）。使用标准的 $P1$ 形函数、工程剪应变 $\\gamma_{xy} = \\partial_x u_y + \\partial_y u_x$，以及采用 Voigt 记法的 $3 \\times 3$ 本构矩阵 $D$，将 $[\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$ 映射到 $[\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}]^T$。\n- 将 $C_{ijkl}$ 限制为与坐标轴对齐的正交各向异性对称形式，用 Voigt 记法表示为\n$$\nD(p) = \\begin{bmatrix}\nC_{11}   C_{12}   0\\\\\nC_{12}   C_{22}   0\\\\\n0   0   C_{66}\n\\end{bmatrix},\n$$\n参数向量为 $p = [C_{11}, C_{22}, C_{12}, C_{66}]^T$。假设 $C_{11}  0$，$C_{22}  0$，$C_{66}  0$ 且 $C_{12}^2  C_{11} C_{22}$ 以确保正定性。\n\n边值问题与失配：\n- 在左边界 $x = 0$ 处施加齐次狄利克雷边界条件：$u_x = 0$，$u_y = 0$。\n- 在右边界 $x = L_x$ 处施加均匀面力 $t = (t_x, t_y)$，上下边界为自由面力。\n- 通过对单元贡献 $K_e(p) = \\int_{\\Omega_e} B^T D(p) B \\, d\\Omega$ 求和来组装全局刚度矩阵 $K(p)$，其中 $B$ 是线性三角形单元的标准 $3 \\times 6$ 应变-位移矩阵，并施加边界条件以形成可解的线性系统 $K(p) u(p) = f$。\n- 定义选择算子 $M$，用于提取右边界 $x = L_x$ 上的自由度（这些节点上的两个分量）。失配泛函为\n$$\nJ(p) = \\frac{1}{2} \\| M u(p) - d \\|_2^2,\n$$\n其中 $d$ 是在“真实”参数 $p_{\\text{true}}$ 下，在相同的面力和边界条件下通过正演求解生成的合成“测量值”。\n\n基于伴随方法的梯度：\n- 对离散平衡方程 $K(p) u(p) = f$ 求导，得到 $K(p)\\, du + \\left(\\frac{\\partial K}{\\partial p_m}\\right) u\\, dp_m = 0$，因此 $du = -K(p)^{-1} \\left(\\frac{\\partial K}{\\partial p_m}\\right) u\\, dp_m$。\n- 对于 $J(p) = \\frac{1}{2} \\| M u(p) - d \\|_2^2$，其变分为 $dJ = (Mu - d)^T M\\, du$。引入伴随变量 $\\lambda$ 作为伴随系统的解\n$$\nK(p)\\, \\lambda = M^T (M u - d),\n$$\n并用它来得到\n$$\n\\frac{\\partial J}{\\partial p_m} = - \\lambda^T \\left(\\frac{\\partial K}{\\partial p_m}\\right) u.\n$$\n- 因为 $K(p)$ 是由 $D(p)$ 线性组装的，而 $D(p)$ 对参数是线性的，所以矩阵 $\\frac{\\partial K}{\\partial p_m}$ 可以从恒定的单元矩阵 $K_e^{(m)} = \\int_{\\Omega_e} B^T E^{(m)} B\\, d\\Omega$ 预先组装，其中\n$$\nE^{(1)} = \\begin{bmatrix}1  0  0\\\\0  0  0\\\\0  0  0\\end{bmatrix},\\quad\nE^{(2)} = \\begin{bmatrix}0  0  0\\\\0  1  0\\\\0  0  0\\end{bmatrix},\\quad\nE^{(3)} = \\begin{bmatrix}0  1  0\\\\1  0  0\\\\0  0  0\\end{bmatrix},\\quad\nE^{(4)} = \\begin{bmatrix}0  0  0\\\\0  0  0\\\\0  0  1\\end{bmatrix}.\n$$\n\n有限差分验证：\n- 对每个参数 $p_m$ 使用中心有限差分：\n$$\n\\left.\\frac{\\partial J}{\\partial p_m}\\right|_{\\text{FD}} \\approx \\frac{J(p + h_m e_m) - J(p - h_m e_m)}{2 h_m},\\quad h_m = \\varepsilon \\max(1, |p_m|),\n$$\n其中 $\\varepsilon = 10^{-7}$，$e_m$ 是第 $m$ 个标准基向量。为避免归一化时除以非常小的有限差分值，报告每个分量的归一化误差\n$$\n\\eta_m = \\frac{\\left| \\left.\\frac{\\partial J}{\\partial p_m}\\right|_{\\text{adj}} - \\left.\\frac{\\partial J}{\\partial p_m}\\right|_{\\text{FD}} \\right|}{\\max\\left(1, \\left|\\left.\\frac{\\partial J}{\\partial p_m}\\right|_{\\text{FD}}\\right|\\right)}.\n$$\n对于每个测试用例，报告 $\\eta_m$ 在所有 $m$ 上的最大值。\n\n测试套件：\n- 所有用例的网格和几何形状：$n_x = 5$，$n_y = 3$，$L_x = 1.0$，$L_y = 0.5$。\n- 对于每个用例，指定用于生成 $d$ 的面力 $t = (t_x, t_y)$ 和“真实”参数 $p_{\\text{true}}$，以及用于比较伴随梯度和有限差分梯度的评估参数 $p$。所有量均为无量纲数。\n\n提供以下三个测试用例：\n- 用例 A：\n  - $t_x = 1.0$，$t_y = 0.2$。\n  - $p_{\\text{true}} = [12.0, 8.0, 3.0, 4.0]^T$。\n  - $p = [10.0, 9.0, 2.5, 3.5]^T$。\n- 用例 B：\n  - $t_x = 0.0$，$t_y = 1.0$。\n  - $p_{\\text{true}} = [20.0, 10.0, 6.0, 5.0]^T$。\n  - $p = [18.0, 11.0, 5.5, 4.8]^T$。\n- 用例 C：\n  - $t_x = 0.5$，$t_y = 0.5$。\n  - $p_{\\text{true}} = [15.0, 15.0, 7.0, 3.0]^T$。\n  - $p = [14.5, 14.0, 6.8, 3.2]^T$。\n\n您的程序必须：\n- 使用线性三角形单元和基于恒定形函数梯度的精确单元公式，组装全局刚度矩阵 $K(p)$ 和四个参数导数矩阵 $\\frac{\\partial K}{\\partial p_m}$，并通过修改全局系统在 $x=0$ 处施加狄利克雷条件。\n- 通过沿 $x = L_x$ 的一致性边积分来组装诺伊曼载荷向量，边贡献在两个边节点之间平分。\n- 求解 $u(p_{\\text{true}})$ 以合成 $d = M u(p_{\\text{true}})$。\n- 对于每个用例，在参数 $p$ 下求解正演问题，计算 $J(p)$，构建并求解伴随系统 $K(p)\\lambda = M^T(Mu - d)$，通过 $-\\lambda^T \\left(\\frac{\\partial K}{\\partial p_m}\\right) u$ 计算伴随梯度分量，并为相同分量计算中心有限差分近似值。报告每个用例的最大归一化误差 $\\max_m \\eta_m$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个结果，以逗号分隔的列表形式，并用方括号括起来，每个浮点数使用三位有效数字的科学记数法（例如，$[1.23e-07,4.56e-08,7.89e-09]$）。",
            "solution": "该实现解决了二维线弹性问题中基于伴随方法的梯度计算与验证问题。该解决方案在 Python 类 `AdjointElasticitySolver` 中构建，该类封装了整个有限元法（FEM）模型和灵敏度分析逻辑。其设计遵循问题陈述中指定的原理和方程。\n\n首先，建立几何和网格数据。计算域是一个尺寸为 $L_x \\times L_y = 1.0 \\times 0.5$ 的矩形，由 $n_x \\times n_y = 5 \\times 3$ 个节点的均匀网格离散化。由四个相邻节点形成的每个矩形单元被细分为两个线性三角形（$P1$）单元。此过程生成节点坐标和单元连接性，这些数据将被存储以用于后续计算。\n\nFEM 实现的核心是组装全局刚度矩阵 $K(p)$。问题指定了一种正交各向异性材料，其本构矩阵 $D(p)$ 对参数向量 $p = [C_{11}, C_{22}, C_{12}, C_{66}]^T$ 是线性的。这种线性关系使得全局刚度矩阵可以表示为线性组合 $K(p) = \\sum_{m=1}^{4} p_m K^{(m)}$，其中每个 $K^{(m)} = \\frac{\\partial K}{\\partial p_m}$ 是对应于其中一个参数的常数矩阵。这四个导数矩阵被预先计算并存储。每个 $K^{(m)}$ 的组装过程涉及遍历网格中的所有单元 $\\Omega_e$ 并累加单元贡献 $K_e^{(m)} = \\int_{\\Omega_e} B^T E^{(m)} B \\, d\\Omega$。对于线性三角形单元，应变-位移矩阵 $\\mathbf{B}$ 是常数，因此积分简化为 $K_e^{(m)} = (\\text{Area}_e) \\mathbf{B}^T \\mathbf{E}^{(m)} \\mathbf{B}$。$\\mathbf{B}$ 矩阵是将三角形的6个节点位移映射到工程应变 $[\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$ 的3个分量的标准 $3 \\times 6$ 矩阵。矩阵 $\\mathbf{E}^{(m)}$ 是为本构定律指定的恒定基矩阵。\n\n离散方程组为 $K(p)u=f$。载荷向量 $f$ 来自规定的诺伊曼边界条件，即域右边界（$x=L_x$）上的均匀面力 $t=(t_x, t_y)$。通过在边界上沿每个单元边对面力与形函数进行积分，将该面力转换为一致的节点力向量。对于线性单元，这导致边上的总力在其两个节点之间平均分配。该实现在右边界的每个节点上正确地累积力。\n\n齐次狄利克雷边界条件 $u_x=u_y=0$ 在左边界（$x=0$）上通过修改全局系统来施加。对于每个约束自由度，刚度矩阵 $\\mathbf{K}$ 的相应行和列被设置为零，对角线元素被设置为1，载荷向量 $\\mathbf{f}$ 中的相应条目被设置为0。此过程隔离了约束自由度，并确保了其余非约束自由度的唯一解。\n\n基于伴随方法的梯度计算按以下步骤进行：\n1.  **合成数据生成**：使用“真实”参数 $p_{\\text{true}}$ 求解正演问题，以获得位移场 $u_{\\text{true}}$。然后将合成测量数据 $d$ 定义为右边界上节点的位移，即 $d = M u_{\\text{true}}$，其中 $\\mathbf{M}$ 是这些自由度的选择算子。\n2.  **正演求解**：在评估参数 $p$ 下，求解正演系统 $K(p)u=f$ 以获得位移场 $u$。\n3.  **伴随求解**：通过求解伴随系统 $K(p)^T \\lambda = M^T (M u(p) - d)$ 来找到伴随变量 $\\lambda$。由于刚度矩阵 $K(p)$ 是对称的（$K(p)^T = K(p)$），这等效于求解 $K(p)\\lambda = M^T(Mu-d)$。该系统的右侧是一个向量，在右边界自由度处包含失配残差 $(Mu-d)$，在其他位置为零。对此系统应用相同的狄利克雷边界条件强制执行程序。\n4.  **梯度计算**：使用公式 $\\frac{\\partial J}{\\partial p_m} = -\\lambda^T \\mathbf{K}^{(m)} u$ 计算失配泛函 $J$ 相对于每个参数 $p_m$ 的梯度，利用预先组装的导数矩阵 $\\mathbf{K}^{(m)}$。\n\n为了验证伴随梯度的正确性，将其与通过中心有限差分法计算的梯度进行比较。对于每个参数 $p_m$，在扰动后的参数值 $p \\pm h_m e_m$ 处评估泛函 $J$，其中 $h_m = \\varepsilon \\max(1, |p_m|)$ 且 $\\varepsilon=10^{-7}$。然后有限差分梯度为 $\\frac{J(p+h_m e_m) - J(p-h_m e_m)}{2h_m}$。\n\n每个测试用例最终报告的值是伴随梯度和有限差分梯度在所有四个参数上的最大归一化误差 $\\max_m \\eta_m$，其中 $\\eta_m = \\frac{|\\text{adj\\_grad}_m - \\text{fd\\_grad}_m|}{\\max(1, |\\text{fd\\_grad}_m|)}$。整个过程对提供的三个测试用例是自动化的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.linalg\n\nclass AdjointElasticitySolver:\n    \"\"\"\n    Implements an adjoint-based gradient computation for 2D linear elasticity.\n    \"\"\"\n    def __init__(self, nx, ny, Lx, Ly):\n        self.nx, self.ny = nx, ny\n        self.Lx, self.Ly = Lx, Ly\n        self.num_nodes = nx * ny\n        self.num_dofs = 2 * self.num_nodes\n\n        self.nodes = self._generate_nodes()\n        self.elements = self._generate_elements()\n        \n        self.K_derivs = self._assemble_K_derivatives()\n\n        self.dirichlet_dofs = self._get_dirichlet_dofs()\n        self.right_boundary_dofs = self._get_right_boundary_dofs()\n\n    def _generate_nodes(self):\n        x = np.linspace(0, self.Lx, self.nx)\n        y = np.linspace(0, self.Ly, self.ny)\n        xv, yv = np.meshgrid(x, y)\n        return np.vstack([xv.ravel(), yv.ravel()]).T\n\n    def _generate_elements(self):\n        elements = []\n        for j in range(self.ny - 1):\n            for i in range(self.nx - 1):\n                n1 = j * self.nx + i\n                n2 = j * self.nx + (i + 1)\n                n3 = (j + 1) * self.nx + i\n                n4 = (j + 1) * self.nx + (i + 1)\n                elements.append([n1, n2, n4])\n                elements.append([n1, n4, n3])\n        return np.array(elements)\n\n    def _get_elemental_B_and_area(self, node_indices):\n        coords = self.nodes[node_indices]\n        (x1, y1), (x2, y2), (x3, y3) = coords[0], coords[1], coords[2]\n        \n        area = 0.5 * np.linalg.det(np.array([[x1, y1, 1], [x2, y2, 1], [x3, y3, 1]]))\n        \n        b1, b2, b3 = y2 - y3, y3 - y1, y1 - y2\n        c1, c2, c3 = x3 - x2, x1 - x3, x2 - x1\n        \n        B = (1 / (2 * area)) * np.array([\n            [b1, 0, b2, 0, b3, 0],\n            [0, c1, 0, c2, 0, c3],\n            [c1, b1, c2, b2, c3, b3]\n        ])\n        return B, abs(area)\n        \n    def _assemble_K_derivatives(self):\n        K_derivs = [np.zeros((self.num_dofs, self.num_dofs)) for _ in range(4)]\n        \n        E_matrices = [\n            np.array([[1, 0, 0], [0, 0, 0], [0, 0, 0]], dtype=float),\n            np.array([[0, 0, 0], [0, 1, 0], [0, 0, 0]], dtype=float),\n            np.array([[0, 1, 0], [1, 0, 0], [0, 0, 0]], dtype=float),\n            np.array([[0, 0, 0], [0, 0, 0], [0, 0, 1]], dtype=float)\n        ]\n        \n        for elem_nodes in self.elements:\n            B, area = self._get_elemental_B_and_area(elem_nodes)\n            dofs = np.ravel([[2 * n, 2 * n + 1] for n in elem_nodes])\n            \n            for m in range(4):\n                Ke_m = B.T @ E_matrices[m] @ B * area\n                K_derivs[m][np.ix_(dofs, dofs)] += Ke_m\n                \n        return K_derivs\n\n    def _get_dirichlet_dofs(self):\n        dofs = []\n        for i in range(self.num_nodes):\n            if np.isclose(self.nodes[i, 0], 0.0):\n                dofs.extend([2 * i, 2 * i + 1])\n        return np.array(dofs)\n\n    def _get_right_boundary_dofs(self):\n        dofs = []\n        for i in range(self.num_nodes):\n            if np.isclose(self.nodes[i, 0], self.Lx):\n                dofs.extend([2 * i, 2 * i + 1])\n        return np.array(dofs)\n        \n    def assemble_K(self, p):\n        K = np.zeros((self.num_dofs, self.num_dofs))\n        for m in range(4):\n            K += p[m] * self.K_derivs[m]\n        return K\n\n    def assemble_f(self, t):\n        tx, ty = t\n        f = np.zeros(self.num_dofs)\n        edge_len = self.Ly / (self.ny - 1)\n        \n        for j in range(self.ny):\n            node_idx = j * self.nx + (self.nx - 1)\n            load_multiplier = 1.0 if 0  j  self.ny - 1 else 0.5\n            \n            f[2 * node_idx] += load_multiplier * edge_len * tx\n            f[2 * node_idx + 1] += load_multiplier * edge_len * ty\n        return f\n\n    def apply_bcs(self, K, f):\n        K_mod, f_mod = K.copy(), f.copy()\n        for dof in self.dirichlet_dofs:\n            K_mod[dof, :] = 0\n            K_mod[:, dof] = 0\n            K_mod[dof, dof] = 1.0\n            f_mod[dof] = 0.0\n        return K_mod, f_mod\n\n    def solve_system(self, p, t):\n        K = self.assemble_K(p)\n        f = self.assemble_f(t)\n        K_mod, f_mod = self.apply_bcs(K, f)\n        u = scipy.linalg.solve(K_mod, f_mod)\n        return u\n        \n    def calculate_J(self, u, d):\n        u_right = u[self.right_boundary_dofs]\n        return 0.5 * np.sum((u_right - d)**2)\n\n    def run_case(self, t, p_true, p):\n        p_true, p = np.array(p_true), np.array(p)\n        \n        u_true = self.solve_system(p_true, t)\n        d = u_true[self.right_boundary_dofs]\n        \n        u = self.solve_system(p, t)\n        \n        adj_rhs = np.zeros(self.num_dofs)\n        residual = u[self.right_boundary_dofs] - d\n        adj_rhs[self.right_boundary_dofs] = residual\n        \n        K_p = self.assemble_K(p)\n        K_mod, adj_rhs_mod = self.apply_bcs(K_p, adj_rhs)\n        lambda_adj = scipy.linalg.solve(K_mod, adj_rhs_mod)\n        \n        grad_adj = np.zeros(4)\n        for m in range(4):\n            grad_adj[m] = -lambda_adj.T @ self.K_derivs[m] @ u\n            \n        grad_fd = np.zeros(4)\n        epsilon = 1e-7\n        \n        for m in range(4):\n            h = epsilon * max(1.0, abs(p[m]))\n            \n            p_plus = p.copy(); p_plus[m] += h\n            u_plus = self.solve_system(p_plus, t)\n            J_plus = self.calculate_J(u_plus, d)\n            \n            p_minus = p.copy(); p_minus[m] -= h\n            u_minus = self.solve_system(p_minus, t)\n            J_minus = self.calculate_J(u_minus, d)\n            \n            grad_fd[m] = (J_plus - J_minus) / (2 * h)\n            \n        errors = np.abs(grad_adj - grad_fd) / np.maximum(1.0, np.abs(grad_fd))\n        return np.max(errors)\n\ndef solve():\n    test_cases = [\n        {'t': (1.0, 0.2), 'p_true': [12.0, 8.0, 3.0, 4.0], 'p': [10.0, 9.0, 2.5, 3.5]},\n        {'t': (0.0, 1.0), 'p_true': [20.0, 10.0, 6.0, 5.0], 'p': [18.0, 11.0, 5.5, 4.8]},\n        {'t': (0.5, 0.5), 'p_true': [15.0, 15.0, 7.0, 3.0], 'p': [14.5, 14.0, 6.8, 3.2]}\n    ]\n\n    solver = AdjointElasticitySolver(nx=5, ny=3, Lx=1.0, Ly=0.5)\n    \n    results = []\n    for case in test_cases:\n        max_error = solver.run_case(case['t'], case['p_true'], case['p'])\n        results.append(max_error)\n\n    formatted_results = [f\"{res:.2e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}