{
    "hands_on_practices": [
        {
            "introduction": "Calculating any macroscopic property from phonons, such as the internal energy or heat capacity, requires integrating contributions from all vibrational modes across the Brillouin Zone (BZ). Numerically, this integral is approximated by a sum over a discrete mesh of wavevectors $\\mathbf{q}$. This practice demonstrates the fundamental task of convergence testing, allowing you to quantify how the accuracy of these thermodynamic integrals depends on the density of the $\\mathbf{q}$-point mesh and establish confidence in your computational results .",
            "id": "3477074",
            "problem": "You are to write a complete, runnable program that numerically investigates the convergence of the phonon density of states and derived thermodynamic integrals with respect to the uniform wavevector mesh density in the first Brillouin Zone (BZ) of a simple cubic lattice. The goal is to quantify how the numerical error scales with mesh spacing for smooth integrands.\n\nUse the following physically consistent and computationally tractable setup.\n\n1. Consider a single optical phonon branch with a smooth gapped dispersion over the simple cubic Brillouin Zone (BZ). Let the wavevector domain be $$[-\\pi,\\pi]^3,$$ and define the angular frequency as\n$$\n\\omega(\\mathbf{q}) = \\sqrt{\\omega_0^2 + v^2\\left[\\sin^2\\left(\\frac{q_x}{2}\\right) + \\sin^2\\left(\\frac{q_y}{2}\\right) + \\sin^2\\left(\\frac{q_z}{2}\\right)\\right]},\n$$\nwith parameters $\\omega_0 = 0.4$ and $v = 1.0$. All angles must be treated in radians. Use reduced units where the reduced Planck constant $\\hbar = 1$ and the Boltzmann constant $k_B = 1$, so that frequencies and temperatures are dimensionless.\n\n2. The phonon density of states $g(\\omega)$ is defined as the normalized distribution of $\\omega(\\mathbf{q})$ over the BZ such that\n$$\n\\int g(\\omega)\\,d\\omega = 1.\n$$\nApproximate $g(\\omega)$ by a histogram of $\\omega(\\mathbf{q})$ sampled on a uniform mesh, using $M$ equally spaced bins over $[\\omega_{\\min},\\omega_{\\max}]$, where\n$$\n\\omega_{\\min} = \\omega_0,\\quad \\omega_{\\max} = \\sqrt{\\omega_0^2 + 3v^2}.\n$$\nSet $M=200$. Use the midpoint sampling rule for the uniform mesh:\n$$\nq_\\alpha(k) = -\\pi + \\left(k + \\frac{1}{2}\\right)\\Delta,\\quad \\Delta = \\frac{2\\pi}{N},\\quad k=0,1,\\dots,N-1,\\quad \\alpha\\in\\{x,y,z\\}.\n$$\nHere $N$ is the number of points per direction, and the total number of wavevectors is $N^3$.\n\n3. Define the Bose–Einstein occupation number\n$$\nn_B(\\omega,T) = \\frac{1}{\\exp\\left(\\frac{\\omega}{T}\\right) - 1},\n$$\nand the internal energy per mode\n$$\nU(T) = \\langle \\omega\\,n_B(\\omega,T)\\rangle_{\\mathbf{q}},\n$$\nwhere $\\langle\\cdot\\rangle_{\\mathbf{q}}$ denotes the uniform average over the discrete mesh in $\\mathbf{q}$. Define the constant-volume heat capacity per mode as\n$$\nC_V(T) = \\frac{dU(T)}{dT}.\n$$\n\n4. For each quantity computed on a mesh of size $N$, define the mesh spacing $h = \\frac{2\\pi}{N}$. Use a high-density reference mesh $N_{\\mathrm{ref}}=64$ to obtain $g_{\\mathrm{ref}}(\\omega),\\,U_{\\mathrm{ref}}(T),\\,C_{V,\\mathrm{ref}}(T)$. For any target mesh $N\\in\\{8,12,16,24,32,48\\}$, define the numerical error metrics as follows:\n- For the density of states, use the $L^2$ error over the histogram bins:\n$$\n\\varepsilon_g(N) = \\left(\\sum_{m=1}^{M}\\left[g_N(\\omega_m) - g_{\\mathrm{ref}}(\\omega_m)\\right]^2\\,\\Delta\\omega\\right)^{1/2},\n$$\nwhere $\\omega_m$ are the bin centers and $\\Delta\\omega$ is the uniform bin width.\n- For the internal energy and heat capacity, use the absolute errors\n$$\n\\varepsilon_U(N,T) = \\left|U_N(T) - U_{\\mathrm{ref}}(T)\\right|,\\quad \\varepsilon_{C_V}(N,T) = \\left|C_{V,N}(T) - C_{V,\\mathrm{ref}}(T)\\right|.\n$$\n\n5. Estimate the error scaling exponents $p$ defined by the relation\n$$\n\\varepsilon \\approx C\\,h^p,\n$$\nby performing a linear least-squares fit of $\\log\\varepsilon$ versus $\\log h$ across the set of $N$ values. The slope of the fitted line is the estimated $p$.\n\nYour program must implement the above and produce the estimated exponents for the following test suite of parameter values:\n- Case A (happy path): internal energy at temperature $T=0.1$.\n- Case B: internal energy at temperature $T=0.5$.\n- Case C: heat capacity at temperature $T=0.5$.\n- Case D: density of states $g(\\omega)$ using the $L^2$ error.\n\nAll outputs are dimensionless. Angles must be in radians. The output must be a single line containing the results as a comma-separated list enclosed in square brackets, in the order $[p_{U}(0.1),\\,p_{U}(0.5),\\,p_{C_V}(0.5),\\,p_{g}]$, where each entry is a floating-point number.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[0.0,0.0,0.0,0.0]$).",
            "solution": "The user has provided a problem from computational materials science that requires a numerical investigation of the convergence of phonon-related properties with respect to the density of a uniform wavevector mesh. The problem is to be validated against a set of strict criteria before a solution is attempted.\n\n### Step 1: Extract Givens\n\n- **Dispersion Relation**: A single optical phonon branch on a simple cubic Brillouin Zone, $\\mathbf{q}\\in[-\\pi,\\pi]^3$, is given by the angular frequency:\n$$\n\\omega(\\mathbf{q}) = \\sqrt{\\omega_0^2 + v^2\\left[\\sin^2\\left(\\frac{q_x}{2}\\right) + \\sin^2\\left(\\frac{q_y}{2}\\right) + \\sin^2\\left(\\frac{q_z}{2}\\right)\\right]}\n$$\n- **Parameters**: $\\omega_0 = 0.4$, $v = 1.0$.\n- **Constants**: Reduced Planck constant $\\hbar = 1$, Boltzmann constant $k_B = 1$. Angles are in radians.\n- **Phonon Density of States (DOS)**: $g(\\omega)$ is a normalized distribution, $\\int g(\\omega)\\,d\\omega = 1$. It is approximated by a histogram of $\\omega(\\mathbf{q})$ values.\n- **Histogram**: $M=200$ equally spaced bins over the range $[\\omega_{\\min},\\omega_{\\max}]$, where $\\omega_{\\min} = \\omega_0$ and $\\omega_{\\max} = \\sqrt{\\omega_0^2 + 3v^2}$.\n- **Wavevector Mesh**: A uniform mesh defined by the midpoint sampling rule:\n$$\nq_\\alpha(k) = -\\pi + \\left(k + \\frac{1}{2}\\right)\\Delta,\\quad \\Delta = \\frac{2\\pi}{N},\\quad k=0,1,\\dots,N-1,\\quad \\alpha\\in\\{x,y,z\\}.\n$$\nThe total number of wavevectors is $N^3$.\n- **Thermodynamic Definitions**:\n    - Bose–Einstein occupation: $n_B(\\omega,T) = \\frac{1}{\\exp\\left(\\frac{\\omega}{T}\\right) - 1}$.\n    - Internal energy per mode: $U(T) = \\langle \\omega\\,n_B(\\omega,T)\\rangle_{\\mathbf{q}}$, where $\\langle\\cdot\\rangle_{\\mathbf{q}}$ is the uniform average over the discrete mesh.\n    - Constant-volume heat capacity per mode: $C_V(T) = \\frac{dU(T)}{dT}$.\n- **Error Analysis**:\n    - Mesh spacing: $h = \\frac{2\\pi}{N}$.\n    - Reference mesh: $N_{\\mathrm{ref}}=64$.\n    - Target meshes: $N \\in \\{8, 12, 16, 24, 32, 48\\}$.\n    - DOS error: $\\varepsilon_g(N) = \\left(\\sum_{m=1}^{M}\\left[g_N(\\omega_m) - g_{\\mathrm{ref}}(\\omega_m)\\right]^2\\,\\Delta\\omega\\right)^{1/2}$.\n    - Thermodynamic property errors: $\\varepsilon_U(N,T) = |U_N(T) - U_{\\mathrm{ref}}(T)|$ and $\\varepsilon_{C_V}(N,T) = |C_{V,N}(T) - C_{V,\\mathrm{ref}}(T)|$.\n- **Convergence Exponent**: The exponent $p$ is defined by $\\varepsilon \\approx C\\,h^p$ and is to be estimated from the slope of a linear least-squares fit of $\\log\\varepsilon$ versus $\\log h$.\n- **Required Calculations**: Estimate $p$ for four cases: (A) $U(T=0.1)$, (B) $U(T=0.5)$, (C) $C_V(T=0.5)$, and (D) $g(\\omega)$.\n- **Output**: A single line with a comma-separated list of the four exponents: $[p_{U}(0.1),\\,p_{U}(0.5),\\,p_{C_V}(0.5),\\,p_{g}]$.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded**: The problem is a standard numerical exercise in computational condensed matter physics. The phonon dispersion relation is a simplified but physically plausible model. The definitions of the density of states, Bose-Einstein statistics, internal energy, and heat capacity are all standard and correct.\n- **Well-Posed**: The problem is specified with mathematical precision. All necessary constants, functions, and numerical procedures (mesh generation, averaging, error calculation, fitting) are explicitly defined. The task is to execute this well-defined numerical experiment and report the results. A unique and meaningful solution (the set of convergence exponents) is guaranteed to exist for the procedure described.\n- **Objective**: The problem statement is entirely quantitative and mathematical, free from any subjective or ambiguous language.\n\nThe problem does not violate any of the invalidity criteria. It is scientifically sound, formally specified, and computationally feasible. The integrands for the internal energy and heat capacity are smooth, periodic functions of the wavevector $\\mathbf{q}$. For such functions, the midpoint rule (which is what the specified mesh sampling is) is known to be highly accurate. The error of the Brillouin zone integration is governed by the Euler-Maclaurin formula, which predicts that the leading error term scales as $h^2$, where $h$ is the mesh spacing. Therefore, we anticipate finding a convergence exponent $p \\approx 2$ for $U(T)$ and $C_V(T)$. The density of states $g(\\omega)$, however, is known to contain non-differentiable features (van Hove singularities) where $\\nabla_{\\mathbf{q}}\\omega = \\mathbf{0}$. The numerical approximation of a non-smooth function or its distribution is expected to converge more slowly, leading to a smaller exponent $p$. The problem is well-posed to explore this contrast.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. A solution will be provided.\n\n### Principle-Based Design\n\nThe solution will be implemented as a Python program adhering to the specified environment. The core of the program is a function that calculates the physical properties of interest for a given mesh density $N$. This function encapsulates the physics model and numerical methods.\n\n1.  **Wavevector Mesh and Dispersion**: For a given mesh size $N$, a 3D uniform grid of wavevectors $\\mathbf{q}$ is generated in the first Brillouin Zone $[-\\pi, \\pi]^3$ using the specified midpoint rule. The phonon frequency $\\omega(\\mathbf{q})$ is then computed for each point on this grid, leveraging NumPy's vectorized operations for efficiency.\n\n2.  **Density of States (DOS)**: The distribution of the computed $\\omega(\\mathbf{q})$ values is calculated using a histogram with $M=200$ bins over the analytically determined frequency range $[\\omega_{\\min}, \\omega_{\\max}]$. The histogram is normalized to represent a probability density function, satisfying $\\int g(\\omega) d\\omega = 1$.\n\n3.  **Thermodynamic Averages**: The internal energy $U(T)$ and heat capacity $C_V(T)$ are calculated as averages over the $N^3$ discrete wavevector points.\n    - The integrand for the internal energy is $f_U = \\omega \\, n_B(\\omega, T)$.\n    - The heat capacity is $C_V(T) = dU/dT$. The differentiation is performed analytically on the integrand before the numerical averaging:\n      $$\n      C_V(T) = \\left\\langle \\frac{d}{dT} \\left(\\omega \\, n_B(\\omega, T)\\right) \\right\\rangle_{\\mathbf{q}} = \\left\\langle \\omega \\frac{d n_B}{dT} \\right\\rangle_{\\mathbf{q}}\n      $$\n      where\n      $$\n      \\frac{d n_B(\\omega, T)}{dT} = \\frac{\\omega}{T^2} \\frac{\\exp(\\omega/T)}{[\\exp(\\omega/T) - 1]^2}\n      $$\n    Both calculations are implemented as vectorized NumPy operations over the array of $\\omega$ values.\n\n4.  **Error Calculation and Convergence Analysis**:\n    - A high-density reference calculation is performed with $N_{\\mathrm{ref}}=64$.\n    - For a series of coarser mesh sizes $N \\in \\{8, 12, 16, 24, 32, 48\\}$, the properties are re-calculated, and the errors ($\\varepsilon_g$, $\\varepsilon_U$, $\\varepsilon_{C_V}$) relative to the reference values are computed according to the specified error metrics.\n    - The convergence exponent $p$ is determined by the relationship $\\varepsilon \\approx C h^p$, which linearizes to $\\log\\varepsilon \\approx \\log C + p \\log h$. A linear least-squares fit is performed on the logarithm of the errors versus the logarithm of the mesh spacing $h=2\\pi/N$. The slope of this fit gives the desired exponent $p$. This is accomplished using `numpy.polyfit`.\n\nThis structured approach ensures that the calculations are performed exactly as specified, leading to the determination of the four requested convergence exponents.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Numerically investigates the convergence of phonon properties with respect to\n    k-point mesh density, calculates convergence exponents, and prints the result.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    omega_0 = 0.4\n    v = 1.0\n    M = 200  # Number of histogram bins for DOS\n\n    # --- Mesh Definitions ---\n    N_ref = 64\n    N_vals = np.array([8, 12, 16, 24, 32, 48])\n    T_cases = {'U': [0.1, 0.5], 'Cv': [0.5]}\n\n    # --- Frequency range for DOS histogram ---\n    omega_min = omega_0\n    omega_max = np.sqrt(omega_0**2 + 3.0 * v**2)\n    omega_bins = np.linspace(omega_min, omega_max, M + 1)\n    delta_omega = (omega_max - omega_min) / M\n\n    def compute_properties(N, temperatures):\n        \"\"\"\n        Calculates phonon DOS, internal energy, and heat capacity for a given\n        mesh size N.\n        \n        Args:\n            N (int): Number of q-points per dimension.\n            temperatures (dict): Dictionary with keys 'U' and 'Cv' holding\n                                 lists of temperatures to compute.\n        \n        Returns:\n            dict: A dictionary containing the computed properties.\n        \"\"\"\n        # 1. Generate q-mesh and compute omega(q)\n        delta_q = 2.0 * np.pi / N\n        q_1d = -np.pi + (np.arange(N) + 0.5) * delta_q\n        qx, qy, qz = np.meshgrid(q_1d, q_1d, q_1d, indexing='ij')\n\n        omega_q_sq_term = np.sin(qx / 2.0)**2 + np.sin(qy / 2.0)**2 + np.sin(qz / 2.0)**2\n        omega_vals = np.sqrt(omega_0**2 + v**2 * omega_q_sq_term)\n        omega_flat = omega_vals.flatten()\n\n        results = {}\n\n        # 2. Compute DOS histogram\n        dos, _ = np.histogram(omega_flat, bins=omega_bins, density=True)\n        results['dos'] = dos\n\n        # 3. Compute thermodynamic properties\n        with np.errstate(over='ignore'): # exp can overflow for large omega/T\n            for T in temperatures.get('U', []):\n                # Using a numerically stable check for large arguments\n                exp_arg = omega_flat / T\n                exp_term = np.exp(exp_arg)\n                n_b = np.divide(1.0, exp_term - 1.0, where=(exp_term > 1.0))\n                U = np.mean(omega_flat * n_b)\n                results[f'U_{T}'] = U\n\n            for T in temperatures.get('Cv', []):\n                exp_arg = omega_flat / T\n                exp_term = np.exp(exp_arg)\n                # Handle potential division by zero if exp_term is 1\n                denom = (exp_term - 1.0)**2\n                # Calculate integrand, setting it to 0 where denom is 0\n                cv_integrand = np.divide(\n                    (omega_flat**2 / T**2) * exp_term,\n                    denom,\n                    out=np.zeros_like(denom),\n                    where=(denom != 0)\n                )\n                Cv = np.mean(cv_integrand)\n                results[f'Cv_{T}'] = Cv\n                \n        return results\n\n    # --- Main Calculation Logic ---\n\n    # 1. Compute high-resolution reference values\n    ref_data = compute_properties(N_ref, T_cases)\n\n    # 2. Loop over target meshes to compute errors\n    h_vals = 2.0 * np.pi / N_vals\n    errors = {\n        'U_0.1': [],\n        'U_0.5': [],\n        'Cv_0.5': [],\n        'dos': []\n    }\n\n    for N in N_vals:\n        current_data = compute_properties(N, T_cases)\n\n        # DOS L2 error\n        err_g = np.sqrt(np.sum((current_data['dos'] - ref_data['dos'])**2) * delta_omega)\n        errors['dos'].append(err_g)\n\n        # Internal energy errors\n        errors['U_0.1'].append(np.abs(current_data['U_0.1'] - ref_data['U_0.1']))\n        errors['U_0.5'].append(np.abs(current_data['U_0.5'] - ref_data['U_0.5']))\n\n        # Heat capacity error\n        errors['Cv_0.5'].append(np.abs(current_data['Cv_0.5'] - ref_data['Cv_0.5']))\n\n    # 3. Perform linear fits to get convergence exponents\n    log_h = np.log(h_vals)\n    exponents = {}\n    \n    # Filter out zero errors before taking log for fitting\n    for key, err_list in errors.items():\n        valid_indices = [i for i, e in enumerate(err_list) if e > 0]\n        if len(valid_indices)  2:\n            # Not enough points for a fit, assign NaN or a sensible default\n            p = np.nan\n        else:\n            log_err = np.log(np.array(err_list)[valid_indices])\n            log_h_fit = log_h[valid_indices]\n            p, _ = np.polyfit(log_h_fit, log_err, 1)\n        exponents[key] = p\n\n    # 4. Format and print the final output\n    # Order: [p_U(0.1), p_U(0.5), p_CV(0.5), p_g]\n    final_results = [\n        exponents['U_0.1'],\n        exponents['U_0.5'],\n        exponents['Cv_0.5'],\n        exponents['dos']\n    ]\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A primary goal of computational materials science is to predict the relative stability of different crystal structures (polymorphs) under varying temperature and pressure. The phonon density of states provides the essential ingredient to calculate the vibrational contribution to the Gibbs free energy, $G(T,P)$. In this exercise, you will compute and compare the free energies of two competing phases to determine the phase transition temperature, directly linking the vibrational spectrum to macroscopic phase behavior .",
            "id": "3477028",
            "problem": "You are given two crystalline polymorphs, labeled phase A and phase B, each described by a vibrational density of states (DoS) function $g(\\omega)$ over angular frequency $\\omega$. The vibrational DoS is defined such that $\\int_{0}^{\\infty} g(\\omega)\\,d\\omega = 3n$ modes per formula unit, where $n$ is the number of atoms per formula unit. Assume $n=1$. The vibrational Helmholtz free energy per formula unit at absolute temperature $T$ is defined in the harmonic approximation by\n$$\nF_{\\mathrm{vib}}(T) = \\int_{0}^{\\infty} g(\\omega)\\left[\\tfrac{1}{2}\\hbar\\omega + k_{\\mathrm{B}}T\\ln\\!\\left(1 - e^{-\\hbar\\omega/(k_{\\mathrm{B}}T)}\\right)\\right]\\,d\\omega,\n$$\nwith the understanding that at $T=0$ the second term vanishes and $F_{\\mathrm{vib}}(0)=\\int_{0}^{\\infty} g(\\omega)\\,\\tfrac{1}{2}\\hbar\\omega\\,d\\omega$. The Gibbs free energy at a fixed pressure $P$ is approximated by\n$$\nG(T,P) = E_{0} + F_{\\mathrm{vib}}(T) + PV,\n$$\nwhere $E_{0}$ is the static-lattice internal energy at $T=0$ excluding vibrational zero-point contributions, and $V$ is the volume per formula unit, both phase-specific. Physical constants are Planck’s reduced constant $\\hbar$ and Boltzmann’s constant $k_{\\mathrm{B}}$. Use the International System of Units (SI) consistently, with energies in Joule in intermediate steps and report specified outputs in electronvolt (eV) per formula unit as directed below.\n\nFor numerical implementation without external input, model each $g(\\omega)$ as a weighted sum of lognormal components,\n$$\ng(\\omega) = \\sum_{i=1}^{m} w_{i}\\,\\phi(\\omega;\\mu_{i},\\sigma_{i}),\\quad\n\\phi(\\omega;\\mu,\\sigma) = \\frac{1}{\\omega\\,\\sigma\\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(\\ln\\omega - \\mu)^{2}}{2\\sigma^{2}}\\right),\\quad \\omega>0,\n$$\nwhere each component is normalized over $(0,\\infty)$ to unity, and $w_{i}$ is the component weight. The logarithmic parameters $\\mu_{i}$ and $\\sigma_{i}$ are related to a specified median angular frequency by $\\mu_{i} = \\ln \\omega_{i}^{\\mathrm{med}}$, with $\\sigma_{i}>0$ controlling the spectral width. For convenience, the test suite below specifies medians via cycle frequencies $f_{i}$ in terahertz, related to angular frequency by $\\omega_{i}^{\\mathrm{med}} = 2\\pi f_{i}\\times 10^{12}\\,\\mathrm{rad/s}$. After construction, numerically renormalize each $g(\\omega)$ so that $\\int_{0}^{\\infty} g(\\omega)\\,d\\omega = 3$ to enforce the mode count for $n=1$.\n\nTask. For each test case in the suite, compute two quantities:\n1. The vibrational Helmholtz free-energy difference at a specified evaluation temperature $T_{\\mathrm{eval}}$, defined by $\\Delta F_{\\mathrm{vib}}(T_{\\mathrm{eval}}) = F_{\\mathrm{vib}}^{(B)}(T_{\\mathrm{eval}}) - F_{\\mathrm{vib}}^{(A)}(T_{\\mathrm{eval}})$, expressed in $\\mathrm{eV}$ per formula unit, as a floating-point number.\n2. The smallest nonnegative temperature $T_{\\mathrm{tr}}$ (in $\\mathrm{K}$) at which the Gibbs free energies are equal, that is, the smallest $T\\ge 0$ such that $\\Delta G(T) = G^{(B)}(T,P)-G^{(A)}(T,P) = 0$. If $\\Delta G(T)$ is numerically indistinguishable from zero over the sampled range (see numerical tolerance requirement below), report $T_{\\mathrm{tr}}=0$. If no such temperature exists within the closed interval $[0, T_{\\max}]$, report $T_{\\mathrm{tr}}=-1$ as a floating-point sentinel.\n\nUse a single, consistent numerical scheme to evaluate the integrals defining $F_{\\mathrm{vib}}(T)$ over a finite angular frequency grid $(\\omega_{j})_{j=1}^{N}$ that spans the support of the specified lognormal components for the case at hand, with adequate resolution to ensure numerical stability for all temperatures sampled in $[0,T_{\\max}]$. For $T>0$, evaluate the integral term containing the logarithm using a numerically stable formulation. Handle the $T=0$ case explicitly via the zero-point limit. For root finding, search for sign changes of $\\Delta G(T)$ over a temperature grid on $[0,T_{\\max}]$ and then refine with a robust bracketing method to find the smallest root if one exists. Use $T_{\\max} = 2000\\,\\mathrm{K}$.\n\nUnits and numerical requirements.\n- Express $\\Delta F_{\\mathrm{vib}}(T_{\\mathrm{eval}})$ in $\\mathrm{eV}$ per formula unit and $T_{\\mathrm{tr}}$ in $\\mathrm{K}$ as floating-point numbers.\n- Use $T_{\\mathrm{eval}}=300\\,\\mathrm{K}$ for all test cases.\n- Use a numerical tolerance of $\\varepsilon = 10^{-6}\\,\\mathrm{eV}$ to decide “numerically indistinguishable from zero” when assessing whether $\\max_{T\\in[0,T_{\\max}]}|\\Delta G(T)|$ is effectively zero; in that case return $T_{\\mathrm{tr}}=0$.\n- If no sign change occurs and the “all-zero” condition above is not met, return $T_{\\mathrm{tr}}=-1$.\n\nTest suite. Implement the following three cases, each with phase-specific parameters. Each density of states is specified by triplets $(f_{i},\\sigma_{i},w_{i})$ with $f_{i}$ in $\\mathrm{THz}$ to be converted to angular frequency medians via $\\omega_{i}^{\\mathrm{med}} = 2\\pi f_{i}\\times 10^{12}\\,\\mathrm{rad/s}$. The pressure $P$ is in $\\mathrm{Pa}$, the static energies $E_{0}$ in $\\mathrm{eV}$ per formula unit, and the volumes $V$ in $\\mathrm{m}^{3}$ per formula unit.\n\n- Case $1$ (crossing expected at finite $T$):\n  - $P = 10^{9}\\,\\mathrm{Pa}$, $T_{\\mathrm{eval}}=300\\,\\mathrm{K}$, $T_{\\max}=2000\\,\\mathrm{K}$.\n  - Phase $A$: $E_{0}^{(A)} = -1.000\\,\\mathrm{eV}$, $V^{(A)} = 2.0\\times 10^{-29}\\,\\mathrm{m}^{3}$, $g^{(A)}$: $\\{(2,\\;0.25,\\;1),\\;(5,\\;0.25,\\;1),\\;(10,\\;0.25,\\;1)\\}$.\n  - Phase $B$: $E_{0}^{(B)} = -0.995\\,\\mathrm{eV}$, $V^{(B)} = 1.9\\times 10^{-29}\\,\\mathrm{m}^{3}$, $g^{(B)}$: $\\{(3,\\;0.25,\\;1),\\;(7,\\;0.25,\\;1),\\;(13,\\;0.25,\\;1)\\}$.\n\n- Case $2$ (no crossing in range expected; one phase favored at all $T$):\n  - $P = 0\\,\\mathrm{Pa}$, $T_{\\mathrm{eval}}=300\\,\\mathrm{K}$, $T_{\\max}=2000\\,\\mathrm{K}$.\n  - Phase $A$: $E_{0}^{(A)} = -1.000\\,\\mathrm{eV}$, $V^{(A)} = 2.0\\times 10^{-29}\\,\\mathrm{m}^{3}$, $g^{(A)}$: $\\{(8,\\;0.25,\\;1),\\;(12,\\;0.25,\\;1),\\;(18,\\;0.25,\\;1)\\}$.\n  - Phase $B$: $E_{0}^{(B)} = -1.050\\,\\mathrm{eV}$, $V^{(B)} = 2.0\\times 10^{-29}\\,\\mathrm{m}^{3}$, $g^{(B)}$: $\\{(4,\\;0.25,\\;1),\\;(8,\\;0.25,\\;1),\\;(12,\\;0.25,\\;1)\\}$.\n\n- Case $3$ (degenerate case; identical inputs imply $G^{(A)}=G^{(B)}$):\n  - $P = 0\\,\\mathrm{Pa}$, $T_{\\mathrm{eval}}=300\\,\\mathrm{K}$, $T_{\\max}=2000\\,\\mathrm{K}$.\n  - Phase $A$: $E_{0}^{(A)} = -1.000\\,\\mathrm{eV}$, $V^{(A)} = 2.0\\times 10^{-29}\\,\\mathrm{m}^{3}$, $g^{(A)}$: $\\{(6,\\;0.25,\\;1),\\;(9,\\;0.25,\\;1),\\;(15,\\;0.25,\\;1)\\}$.\n  - Phase $B$: $E_{0}^{(B)} = -1.000\\,\\mathrm{eV}$, $V^{(B)} = 2.0\\times 10^{-29}\\,\\mathrm{m}^{3}$, $g^{(B)}$: $\\{(6,\\;0.25,\\;1),\\;(9,\\;0.25,\\;1),\\;(15,\\;0.25,\\;1)\\}$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list of lists, in the form\n$$\n\\big[\\,[\\Delta F_{\\mathrm{vib}}^{(1)}(300\\,\\mathrm{K}),\\,T_{\\mathrm{tr}}^{(1)}],\\;[\\Delta F_{\\mathrm{vib}}^{(2)}(300\\,\\mathrm{K}),\\,T_{\\mathrm{tr}}^{(2)}],\\;[\\Delta F_{\\mathrm{vib}}^{(3)}(300\\,\\mathrm{K}),\\,T_{\\mathrm{tr}}^{(3)}]\\,\\big],\n$$\nwhere each $\\Delta F_{\\mathrm{vib}}^{(i)}(300\\,\\mathrm{K})$ is in $\\mathrm{eV}$ per formula unit and each $T_{\\mathrm{tr}}^{(i)}$ in $\\mathrm{K}$. The program must print exactly this single-line representation, for example like $[[x_{1},y_{1}],[x_{2},y_{2}],[x_{3},y_{3}]]$ with no extra text. All angles are irrelevant here; if any angle were to appear, it should be given in radians, but no angles are used in this task.",
            "solution": "The problem requires the calculation of thermodynamic properties for two crystalline phases, A and B, based on their vibrational densities of states (DoS), $g(\\omega)$. The primary tasks are to compute the difference in vibrational Helmholtz free energy, $\\Delta F_{\\mathrm{vib}}$, at a specific temperature $T_{\\mathrm{eval}}$, and to find the phase transition temperature, $T_{\\mathrm{tr}}$, where the Gibbs free energies of the two phases are equal.\n\nThe solution is developed in a series of logical steps: defining the physical model, establishing a numerical framework for the necessary calculations, and then implementing a computational strategy to find the required quantities for each test case. All calculations will be performed in SI units, with conversions to other units, such as electronvolts (eV), applied only as specified for the final output.\n\n**1. Physical Constants and Units**\nThe following physical constants from the International System of Units (SI) are used:\n-   Reduced Planck constant: $\\hbar \\approx 1.054571817 \\times 10^{-34}\\,\\mathrm{J}\\cdot\\mathrm{s}$\n-   Boltzmann constant: $k_{\\mathrm{B}} \\approx 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$\n\nEnergy values provided in electronvolts (eV) are converted to Joules using the elementary charge $e$:\n-   $1\\,\\mathrm{eV} \\approx 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$\n\n**2. Vibrational Density of States (DoS) Model**\nThe DoS for each phase, $g(\\omega)$, is modeled as a weighted sum of $m$ lognormal distributions:\n$$\ng(\\omega) = \\sum_{i=1}^{m} w_{i}\\,\\phi(\\omega;\\mu_{i},\\sigma_{i})\n$$\nwhere $\\phi(\\omega;\\mu,\\sigma)$ is the lognormal probability density function, defined for angular frequency $\\omega > 0$:\n$$\n\\phi(\\omega;\\mu,\\sigma) = \\frac{1}{\\omega\\,\\sigma\\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(\\ln\\omega - \\mu)^{2}}{2\\sigma^{2}}\\right)\n$$\nThe parameter $\\mu_i$ is the mean of the logarithm of the variable, related to the median frequency $\\omega_i^{\\mathrm{med}}$ by $\\mu_i = \\ln \\omega_i^{\\mathrm{med}}$. The median frequencies are derived from cycle frequencies $f_i$ (given in THz) via $\\omega_{i}^{\\mathrm{med}} = 2\\pi f_{i}\\times 10^{12}\\,\\mathrm{rad/s}$.\n\nThe problem states that each DoS must be numerically renormalized to satisfy the condition for $n=1$ atom per formula unit:\n$$\n\\int_{0}^{\\infty} g(\\omega)\\,d\\omega = 3\n$$\nThis is accomplished by first constructing an unnormalized DoS, $g_{\\mathrm{un}}(\\omega)$, using the provided weights $w_i$. We then compute its integral numerically over a sufficiently large frequency range, $I_{\\mathrm{un}} = \\int_{0}^{\\infty} g_{\\mathrm{un}}(\\omega)\\,d\\omega$. The final, normalized DoS is obtained by scaling:\n$$\ng(\\omega) = g_{\\mathrm{un}}(\\omega) \\times \\frac{3}{I_{\\mathrm{un}}}\n$$\nAll integrations involving the DoS are performed numerically over a discrete grid of angular frequencies $(\\omega_j)$, chosen to span the effective support of all lognormal components for a given test case. The trapezoidal rule provides sufficient accuracy for a dense grid.\n\n**3. Thermodynamic Functions**\nThe vibrational Helmholtz free energy, $F_{\\mathrm{vib}}(T)$, is given by:\n$$\nF_{\\mathrm{vib}}(T) = \\int_{0}^{\\infty} g(\\omega)\\left[\\tfrac{1}{2}\\hbar\\omega + k_{\\mathrm{B}}T\\ln\\!\\left(1 - e^{-\\hbar\\omega/(k_{\\mathrm{B}}T)}\\right)\\right]\\,d\\omega\n$$\nThis expression can be separated into a temperature-independent zero-point energy (ZPE) contribution and a temperature-dependent thermal contribution, $F_{\\mathrm{vib,th}}(T)$:\n$$\nF_{\\mathrm{vib}}(T) = \\mathrm{ZPE} + F_{\\mathrm{vib,th}}(T)\n$$\nwhere\n$$\n\\mathrm{ZPE} = \\int_{0}^{\\infty} g(\\omega)\\,\\tfrac{1}{2}\\hbar\\omega\\,d\\omega\n$$\n$$\nF_{\\mathrm{vib,th}}(T) = \\int_{0}^{\\infty} g(\\omega)\\,k_{\\mathrm{B}}T\\ln\\!\\left(1 - e^{-\\hbar\\omega/(k_{\\mathrm{B}}T)}\\right)\\,d\\omega\n$$\nFor $T=0\\,\\mathrm{K}$, $F_{\\mathrm{vib,th}}(0) = 0$ and $F_{\\mathrm{vib}}(0) = \\mathrm{ZPE}$. For $T > 0\\,\\mathrm{K}$, the logarithmic term $\\ln(1-e^{-x})$ with $x=\\hbar\\omega/(k_{\\mathrm{B}}T)$ requires careful numerical evaluation to avoid loss of precision when $x$ is small. The expression `numpy.log(-numpy.expm1(-x))` provides a numerically stable alternative to `numpy.log(1-numpy.exp(-x))`.\n\nThe Gibbs free energy $G(T,P)$ is approximated as:\n$$\nG(T,P) = E_{0} + F_{\\mathrm{vib}}(T) + PV\n$$\nwhere $E_0$ is the static-lattice energy and $V$ is the volume per formula unit.\n\n**4. Computational Strategy**\n\n**4.1. Calculation of $\\Delta F_{\\mathrm{vib}}(T_{\\mathrm{eval}})**$\nThe vibrational Helmholtz free energy difference at $T_{\\mathrm{eval}}=300\\,\\mathrm{K}$ is $\\Delta F_{\\mathrm{vib}}(300\\,\\mathrm{K}) = F_{\\mathrm{vib}}^{(B)}(300\\,\\mathrm{K}) - F_{\\mathrm{vib}}^{(A)}(300\\,\\mathrm{K})$. We compute $F_{\\mathrm{vib}}(300\\,\\mathrm{K})$ for each phase by numerically integrating the respective ZPE and thermal contributions over the shared angular frequency grid. The final result is converted from Joules to eV.\n\n**4.2. Calculation of Transition Temperature $T_{\\mathrm{tr}}$**\nThe transition temperature $T_{\\mathrm{tr}}$ is the smallest non-negative root of the Gibbs free energy difference, $\\Delta G(T) = G^{(B)}(T,P) - G^{(A)}(T,P) = 0$.\n$$\n\\Delta G(T) = (E_0^{(B)} - E_0^{(A)}) + (F_{\\mathrm{vib}}^{(B)}(T) - F_{\\mathrm{vib}}^{(A)}(T)) + P(V^{(B)} - V^{(A)}) = 0\n$$\nLet $\\Delta E_0 = E_0^{(B)} - E_0^{(A)}$, $\\Delta V = V^{(B)} - V^{(A)}$, and $\\Delta F_{\\mathrm{vib}}(T) = F_{\\mathrm{vib}}^{(B)}(T) - F_{\\mathrm{vib}}^{(A)}(T)$. The equation to solve is:\n$$\n\\Delta G(T) = \\Delta E_0 + \\Delta F_{\\mathrm{vib}}(T) + P\\Delta V = 0\n$$\nThe search for $T_{\\mathrm{tr}}$ follows a specific protocol:\n1.  A temperature grid is established from $T=0\\,\\mathrm{K}$ to $T=T_{\\max}=2000\\,\\mathrm{K}$.\n2.  $\\Delta G(T)$ is computed for each temperature on this grid.\n3.  The absolute maximum of $\\Delta G(T)$ over the grid is found. If this value, converted to eV, is less than the tolerance $\\varepsilon = 10^{-6}\\,\\mathrm{eV}$, the phases are considered degenerate, and $T_{\\mathrm{tr}} = 0.0\\,\\mathrm{K}$.\n4.  Otherwise, the grid of $\\Delta G(T)$ values is scanned for sign changes. An interval $[T_i, T_{i+1}]$ where $\\Delta G(T_i) \\cdot \\Delta G(T_{i+1})  0$ brackets a root.\n5.  The first such interval found (corresponding to the smallest transition temperature) is refined using a robust root-finding algorithm, `scipy.optimize.brentq`, to determine $T_{\\mathrm{tr}}$ with high precision.\n6.  If no sign change is detected across the entire temperature range $[0, T_{\\max}]$, it is concluded that no transition occurs, and $T_{\\mathrm{tr}} = -1.0\\,\\mathrm{K}$ is returned. An explicit check is also made for a root at $T=0\\,\\mathrm{K}$.\n\nThis methodology is applied to each of the three test cases specified in the problem statement, yielding the required pairs of $[\\Delta F_{\\mathrm{vib}}(300\\,\\mathrm{K}), T_{\\mathrm{tr}}]$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases described in the prompt.\n    \"\"\"\n    \n    # Physical constants in SI units\n    HBAR = 1.054571817e-34  # J*s\n    K_B = 1.380649e-23        # J/K\n    E_CHARGE = 1.602176634e-19 # C (for eV to J conversion)\n\n    def get_g_of_omega(omega_grid, dos_params):\n        \"\"\"\n        Constructs the vibrational density of states (DoS) on a given frequency grid.\n        \n        Args:\n            omega_grid (np.ndarray): Grid of angular frequencies (rad/s).\n            dos_params (list): List of tuples (f_i, sigma_i, w_i) for each lognormal component.\n                               f_i is in THz.\n\n        Returns:\n            np.ndarray: The normalized DoS g(omega) on the grid.\n        \"\"\"\n        g_unnormalized = np.zeros_like(omega_grid)\n        for f, sigma, w in dos_params:\n            omega_med = 2 * np.pi * f * 1e12\n            mu = np.log(omega_med)\n            \n            # Avoid log(0) at omega_grid[0] if it's 0\n            safe_omega = np.maximum(omega_grid, 1e-30)\n            \n            exponent = -((np.log(safe_omega) - mu)**2) / (2 * sigma**2)\n            phi = (1 / (safe_omega * sigma * np.sqrt(2 * np.pi))) * np.exp(exponent)\n            g_unnormalized += w * phi\n\n        # Numerically renormalize so that integral(g(omega) d_omega) = 3\n        integral_unnormalized = np.trapz(g_unnormalized, omega_grid)\n        if integral_unnormalized > 1e-9: # Avoid division by zero\n            g_normalized = g_unnormalized * (3.0 / integral_unnormalized)\n        else:\n            g_normalized = g_unnormalized\n        \n        return g_normalized\n\n    def calculate_F_vib(T, omega_grid, g_omega):\n        \"\"\"\n        Calculates the vibrational Helmholtz free energy F_vib at temperature T.\n\n        Args:\n            T (float): Temperature in Kelvin.\n            omega_grid (np.ndarray): Grid of angular frequencies (rad/s).\n            g_omega (np.ndarray): Normalized DoS on the omega_grid.\n\n        Returns:\n            float: Vibrational Helmholtz free energy in Joules.\n        \"\"\"\n        # Zero-Point Energy (ZPE)\n        zpe_integrand = 0.5 * HBAR * omega_grid * g_omega\n        zpe = np.trapz(zpe_integrand, omega_grid)\n\n        if T  1e-9: # T=0 case\n            return zpe\n\n        # Thermal contribution\n        # Use numerically stable form for log(1 - exp(-x))\n        x = HBAR * omega_grid / (K_B * T)\n        # np.log(-np.expm1(-x)) is a stable way to compute np.log(1-np.exp(-x))\n        log_term = np.log(-np.expm1(-x))\n        \n        thermal_integrand = K_B * T * g_omega * log_term\n        thermal_contrib = np.trapz(thermal_integrand, omega_grid)\n\n        return zpe + thermal_contrib\n\n    def solve_case(case_params):\n        \"\"\"\n        Solves for a single test case.\n        \"\"\"\n        P = case_params['P']\n        T_eval = case_params['T_eval']\n        T_max = case_params['T_max']\n        \n        # Phase A parameters\n        E0_A_eV = case_params['A']['E0']\n        V_A = case_params['A']['V']\n        dos_params_A = case_params['A']['g']\n        \n        # Phase B parameters\n        E0_B_eV = case_params['B']['E0']\n        V_B = case_params['B']['V']\n        dos_params_B = case_params['B']['g']\n\n        # Setup numerical grid for omega\n        # A wide and dense grid to ensure accuracy for all cases.\n        omega_min = 0.1 * 1e12\n        omega_max = 500 * 1e12\n        num_points = 10000\n        omega_grid = np.linspace(omega_min, omega_max, num_points)\n\n        # Calculate DoS for both phases\n        g_A = get_g_of_omega(omega_grid, dos_params_A)\n        g_B = get_g_of_omega(omega_grid, dos_params_B)\n\n        # --- Task 1: Calculate Delta_F_vib at T_eval ---\n        F_vib_A_eval = calculate_F_vib(T_eval, omega_grid, g_A)\n        F_vib_B_eval = calculate_F_vib(T_eval, omega_grid, g_B)\n        delta_F_vib_eval_J = F_vib_B_eval - F_vib_A_eval\n        delta_F_vib_eval_eV = delta_F_vib_eval_J / E_CHARGE\n\n        # --- Task 2: Calculate transition temperature T_tr ---\n        E0_A_J = E0_A_eV * E_CHARGE\n        E0_B_J = E0_B_eV * E_CHARGE\n        \n        delta_E0_J = E0_B_J - E0_A_J\n        delta_V = V_B - V_A\n        PV_term = P * delta_V\n\n        memo_F_vib = {}\n        def get_F_vib(T, g_omega):\n            T_key = round(T, 8) # Avoid recomputing for same T in brentq\n            if (T_key, tuple(g_omega)) in memo_F_vib:\n                 return memo_F_vib[(T_key, tuple(g_omega))]\n            res = calculate_F_vib(T, omega_grid, g_omega)\n            memo_F_vib[(T_key, tuple(g_omega))] = res\n            return res\n\n        def delta_G(T):\n            F_vib_A = get_F_vib(T, g_A)\n            F_vib_B = get_F_vib(T, g_B)\n            delta_F_vib = F_vib_B - F_vib_A\n            return delta_E0_J + delta_F_vib + PV_term\n        \n        # Search for T_tr\n        T_grid = np.linspace(0, T_max, 201)\n        delta_G_values_J = np.array([delta_G(T) for T in T_grid])\n        delta_G_values_eV = delta_G_values_J / E_CHARGE\n        \n        # Check for numerically degenerate case\n        tolerance_eV = 1e-6\n        if np.max(np.abs(delta_G_values_eV))  tolerance_eV:\n            T_tr = 0.0\n            return [delta_F_vib_eval_eV, T_tr]\n\n        # Search for roots\n        T_tr = -1.0\n        # Check for T=0 root explicitly\n        if abs(delta_G_values_J[0])  tolerance_eV * E_CHARGE:\n            T_tr = 0.0\n            return [delta_F_vib_eval_eV, T_tr]\n            \n        for i in range(len(T_grid) - 1):\n            T1, T2 = T_grid[i], T_grid[i+1]\n            G1, G2 = delta_G_values_J[i], delta_G_values_J[i+1]\n            if G1 * G2  0:\n                try:\n                    root = brentq(delta_G, T1, T2)\n                    T_tr = root\n                    break # Found the smallest non-negative root\n                except ValueError:\n                    # Should not happen if G1*G2  0\n                    continue\n        \n        return [delta_F_vib_eval_eV, T_tr]\n\n    test_cases = [\n        {\n            'P': 1e9, 'T_eval': 300, 'T_max': 2000,\n            'A': {'E0': -1.000, 'V': 2.0e-29, 'g': [(2, 0.25, 1), (5, 0.25, 1), (10, 0.25, 1)]},\n            'B': {'E0': -0.995, 'V': 1.9e-29, 'g': [(3, 0.25, 1), (7, 0.25, 1), (13, 0.25, 1)]}\n        },\n        {\n            'P': 0, 'T_eval': 300, 'T_max': 2000,\n            'A': {'E0': -1.000, 'V': 2.0e-29, 'g': [(8, 0.25, 1), (12, 0.25, 1), (18, 0.25, 1)]},\n            'B': {'E0': -1.050, 'V': 2.0e-29, 'g': [(4, 0.25, 1), (8, 0.25, 1), (12, 0.25, 1)]}\n        },\n        {\n            'P': 0, 'T_eval': 300, 'T_max': 2000,\n            'A': {'E0': -1.000, 'V': 2.0e-29, 'g': [(6, 0.25, 1), (9, 0.25, 1), (15, 0.25, 1)]},\n            'B': {'E0': -1.000, 'V': 2.0e-29, 'g': [(6, 0.25, 1), (9, 0.25, 1), (15, 0.25, 1)]}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    print(f\"[{','.join([str(r) for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While the harmonic model provides a robust foundation, real materials exhibit thermal expansion, an effect rooted in the change of vibrational frequencies with volume. The mode Grüneisen parameter, $\\gamma_{\\mathbf{q}\\nu}$, is the key quantity that connects the phonon spectrum to this anharmonic behavior. This practice guides you through the numerical calculation of $\\gamma_{\\mathbf{q}\\nu}$ using a finite difference approach, a standard technique for quantifying how phonon modes respond to strain and drive thermal expansion .",
            "id": "3477037",
            "problem": "Consider a three-dimensional isotropic crystal with a single phonon branch. Let the phonon angular frequency be modeled as $$\\omega(\\mathbf{q},V)=\\sqrt{\\omega_0(V)^2+v(V)^2\\lVert \\mathbf{q}\\rVert^2}$$ where $\\omega_0(V)=A_0 V^{-\\eta_0}$ and $v(V)=A_1 V^{-\\eta_1}$. Here, $\\mathbf{q}$ is a wavevector in the Brillouin Zone (BZ), $V$ is the crystal volume, $A_0$ and $A_1$ are positive dimensionless constants, and $\\eta_0$ and $\\eta_1$ are positive dimensionless exponents. The Grüneisen parameter for a mode indexed by wavevector $\\mathbf{q}$ and branch index $\\nu$ (here a single branch so $\\nu$ can be omitted) is defined by the fundamental relation $$\\gamma_{\\mathbf{q}\\nu}=-\\frac{V}{\\omega_{\\mathbf{q}\\nu}}\\frac{\\partial \\omega_{\\mathbf{q}\\nu}}{\\partial V}$$. The task is to compute $\\gamma_{\\mathbf{q}\\nu}$ numerically using a symmetric finite-difference approximation of $\\partial \\omega/\\partial V$ at a baseline volume $V_0$, assess its convergence with respect to the magnitude of the volume perturbation, and assess the convergence of Brillouin Zone sampling by varying the uniform $\\mathbf{q}$-mesh resolution.\n\nUse units where the reduced Planck constant and Boltzmann constant are both equal to one, i.e., $\\hbar=1$ and $k_{\\mathrm{B}}=1$, so all quantities are dimensionless. Sample the Brillouin Zone of a simple cubic lattice using a uniform grid of $N$ points per Cartesian direction over $[-\\pi,\\pi)$ for each component of $\\mathbf{q}$, and approximate integrals by discrete sums. Use the symmetric finite-difference formula $$\\frac{\\partial \\omega}{\\partial V}\\bigg|_{V_0}\\approx \\frac{\\omega(\\mathbf{q},V_0+\\Delta V)-\\omega(\\mathbf{q},V_0-\\Delta V)}{2\\Delta V}$$ and then $$\\gamma_{\\mathbf{q}}\\approx -\\frac{V_0}{\\omega(\\mathbf{q},V_0)}\\cdot\\frac{\\omega(\\mathbf{q},V_0+\\Delta V)-\\omega(\\mathbf{q},V_0-\\Delta V)}{2\\Delta V}$$.\n\nTo establish a reference for error quantification, use the provided dispersion model and calculus to derive the exact analytic expression for $\\gamma_{\\mathbf{q}}$ at $V_0$. Then quantify the finite-difference error by the root-mean-square error $$\\mathrm{RMSE}=\\sqrt{\\frac{1}{M}\\sum_{i=1}^{M}\\left(\\gamma_{\\mathbf{q}_i}^{\\mathrm{FD}}-\\gamma_{\\mathbf{q}_i}^{\\mathrm{exact}}\\right)^2}$$ where $M=N^3$ is the total number of sampled $\\mathbf{q}$-points, $\\gamma_{\\mathbf{q}_i}^{\\mathrm{FD}}$ denotes the finite-difference value, and $\\gamma_{\\mathbf{q}_i}^{\\mathrm{exact}}$ is the exact analytic value. Additionally, to connect with phonon Density of States (DOS) and thermodynamic functions, compute the specific heat per mode at temperature $T$ using the Bose–Einstein statistics formula $$C(\\omega,T)=\\left(\\frac{\\omega}{T}\\right)^2\\frac{e^{\\omega/T}}{\\left(e^{\\omega/T}-1\\right)^2}$$ in these dimensionless units, and evaluate the specific-heat-weighted average Grüneisen parameter $$\\Gamma_C(T)=\\frac{\\sum_{i=1}^{M}\\gamma_{\\mathbf{q}_i} C\\!\\left(\\omega(\\mathbf{q}_i,V_0),T\\right)}{\\sum_{i=1}^{M}C\\!\\left(\\omega(\\mathbf{q}_i,V_0),T\\right)}$$ for both the finite-difference and exact-analytic $\\gamma_{\\mathbf{q}_i}$, reporting the absolute error $\\left|\\Gamma_C^{\\mathrm{FD}}(T)-\\Gamma_C^{\\mathrm{exact}}(T)\\right|$.\n\nUse the fixed parameter values $A_0=2.0$, $A_1=1.0$, $\\eta_0=1.2$, $\\eta_1=0.3$, and $V_0=1.0$. Implement all calculations in dimensionless units as specified.\n\nTest Suite:\nCompute the pair of metrics $\\left[\\mathrm{RMSE},\\,\\left|\\Gamma_C^{\\mathrm{FD}}(T)-\\Gamma_C^{\\mathrm{exact}}(T)\\right|\\right]$ for each of the following parameter sets, expressed as tuples $(\\Delta V/V_0,\\,N,\\,T)$:\n\n$\\left(0.01,\\,30,\\,0.5\\right)$\n$\\left(0.01,\\,8,\\,0.5\\right)$\n$\\left(0.10,\\,30,\\,0.5\\right)$\n$\\left(10^{-6},\\,30,\\,0.5\\right)$\n$\\left(0.01,\\,60,\\,0.5\\right)$\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list $\\left[\\mathrm{RMSE},\\,\\left|\\Gamma_C^{\\mathrm{FD}}-\\Gamma_C^{\\mathrm{exact}}\\right|\\right]$. For example, $\\left[\\left[r_1,e_1\\right],\\left[r_2,e_2\\right],\\ldots\\right]$, with all numbers rendered as standard decimal floats in dimensionless units.",
            "solution": "The user-provided problem is assessed to be valid. It is scientifically sound, well-posed, objective, and self-contained, presenting a standard problem in computational materials science that involves deriving an analytical expression, implementing a numerical approximation, and quantifying the errors.\n\n### 1. Theoretical Framework and Analytical Derivation\n\nThe primary goal is to compute the mode Grüneisen parameter $$\\gamma_{\\mathbf{q}}$$, which quantifies the logarithmic change in a phonon mode's frequency $$\\omega_{\\mathbf{q}}$$ with respect to the logarithmic change in crystal volume $$V$$. The fundamental definition is:\n$$\n\\gamma_{\\mathbf{q}} = -\\frac{\\partial \\ln \\omega_{\\mathbf{q}}}{\\partial \\ln V} = -\\frac{V}{\\omega_{\\mathbf{q}}} \\frac{\\partial \\omega_{\\mathbf{q}}}{\\partial V}\n$$\nThe problem provides a model for the phonon dispersion relation for a single isotropic branch:\n$$\n\\omega(\\mathbf{q},V) = \\sqrt{\\omega_0(V)^2 + v(V)^2 \\lVert \\mathbf{q} \\rVert^2}\n$$\nwhere $$q = \\lVert \\mathbf{q} \\rVert$$ is the magnitude of the wavevector and the volume-dependent parameters are given by power laws:\n$$\n\\omega_0(V) = A_0 V^{-\\eta_0} \\quad \\text{and} \\quad v(V) = A_1 V^{-\\eta_1}\n$$\nTo derive the exact analytical expression for $$\\gamma_{\\mathbf{q}}$$, we first compute the partial derivative of $$\\omega(\\mathbf{q},V)$$ with respect to $$V$$. It is more convenient to first differentiate $$\\omega^2$$:\n$$\n\\frac{\\partial (\\omega^2)}{\\partial V} = \\frac{\\partial}{\\partial V} \\left( \\omega_0(V)^2 + v(V)^2 q^2 \\right) = 2\\omega_0 \\frac{d\\omega_0}{dV} + 2v \\frac{dv}{dV} q^2\n$$\nThe derivatives of the parameters are:\n$$\n\\frac{d\\omega_0}{dV} = A_0(-\\eta_0)V^{-\\eta_0-1} = -\\frac{\\eta_0}{V} (A_0 V^{-\\eta_0}) = -\\frac{\\eta_0 \\omega_0(V)}{V}\n$$\n$$\n\\frac{dv}{dV} = A_1(-\\eta_1)V^{-\\eta_1-1} = -\\frac{\\eta_1}{V} (A_1 V^{-\\eta_1}) = -\\frac{\\eta_1 v(V)}{V}\n$$\nSubstituting these into the derivative of $$\\omega^2$$:\n$$\n\\frac{\\partial (\\omega^2)}{\\partial V} = 2\\omega_0 \\left(-\\frac{\\eta_0 \\omega_0}{V}\\right) + 2v \\left(-\\frac{\\eta_1 v}{V}\\right) q^2 = -\\frac{2}{V} \\left( \\eta_0 \\omega_0^2 + \\eta_1 v^2 q^2 \\right)\n$$\nUsing the chain rule, $$\\frac{\\partial (\\omega^2)}{\\partial V} = 2\\omega \\frac{\\partial \\omega}{\\partial V}$$, we find $$\\frac{\\partial \\omega}{\\partial V}$$:\n$$\n\\frac{\\partial \\omega}{\\partial V} = \\frac{1}{2\\omega} \\frac{\\partial (\\omega^2)}{\\partial V} = -\\frac{1}{\\omega V} \\left( \\eta_0 \\omega_0^2 + \\eta_1 v^2 q^2 \\right)\n$$\nFinally, substituting this into the definition of $$\\gamma_{\\mathbf{q}}$$:\n$$\n\\gamma_{\\mathbf{q}}(V) = -\\frac{V}{\\omega} \\left( -\\frac{1}{\\omega V} \\left( \\eta_0 \\omega_0(V)^2 + \\eta_1 v(V)^2 q^2 \\right) \\right) = \\frac{\\eta_0 \\omega_0(V)^2 + \\eta_1 v(V)^2 q^2}{\\omega^2}\n$$\nReplacing $$\\omega^2$$ with its definition, we arrive at the exact analytical expression for the Grüneisen parameter:\n$$\n\\gamma_{\\mathbf{q}}^{\\mathrm{exact}}(V) = \\frac{\\eta_0 \\omega_0(V)^2 + \\eta_1 v(V)^2 \\lVert \\mathbf{q}\\rVert^2}{\\omega_0(V)^2 + v(V)^2 \\lVert \\mathbf{q}\\rVert^2}\n$$\nThis expression will be evaluated at the baseline volume $$V_0$$ and serve as the reference for quantifying numerical errors.\n\n### 2. Numerical Procedure and Error Metrics\n\nThe numerical part of the problem involves several steps: Brillouin Zone (BZ) sampling, finite-difference approximation, and calculation of thermodynamic averages and error metrics.\n\n#### a. Brillouin Zone Sampling\nThe BZ of the simple cubic lattice is a cube in reciprocal space. We sample it using a uniform grid of $$N \\times N \\times N$$ points. The wavevector components $$q_x, q_y, q_z$$ are sampled over the interval $$[-\\pi, \\pi)$$. For a given $$N$$, the set of sampled wavevectors $$\\mathbf{q}_i$$ is constructed, and for each, the squared magnitude $$\\lVert \\mathbf{q}_i \\rVert^2$$ is computed. The total number of points is $$M=N^3$$.\n\n#### b. Finite-Difference Approximation\nThe derivative $$\\partial \\omega / \\partial V$$ is approximated at $$V_0$$ using a symmetric (central) finite-difference scheme with a volume perturbation $$\\Delta V$$:\n$$\n\\frac{\\partial \\omega(\\mathbf{q}, V)}{\\partial V}\\bigg|_{V_0} \\approx \\frac{\\omega(\\mathbf{q}, V_0+\\Delta V) - \\omega(\\mathbf{q}, V_0-\\Delta V)}{2\\Delta V}\n$$\nThe corresponding approximation for the Grüneisen parameter is:\n$$\n\\gamma_{\\mathbf{q}}^{\\mathrm{FD}} \\approx -\\frac{V_0}{\\omega(\\mathbf{q}, V_0)} \\cdot \\frac{\\omega(\\mathbf{q}, V_0+\\Delta V) - \\omega(\\mathbf{q}, V_0-\\Delta V)}{2\\Delta V}\n$$\nThis calculation is performed for every sampled wavevector $$\\mathbf{q}_i$$.\n\n#### c. Thermodynamic Averaging and Specific Heat\nThe specific heat capacity of a single phonon mode of frequency $$\\omega$$ at temperature $$T$$ is given by the Bose-Einstein statistics (with $$k_B = 1$$):\n$$\nC(\\omega, T) = \\left(\\frac{\\omega}{T}\\right)^2 \\frac{e^{\\omega/T}}{\\left(e^{\\omega/T}-1\\right)^2}\n$$\nFor robust numerical evaluation, this can be rewritten. Letting $$x = \\omega/T$$, we have:\n$$\nC(x) = \\frac{x^2 e^x}{(e^x-1)^2} = \\frac{x^2}{e^{-x}(e^x-1)^2} = \\frac{x^2}{(e^{x/2}-e^{-x/2})^2} = \\frac{x^2}{4\\sinh^2(x/2)}\n$$\nAn equivalent stable form is $$C(x) = \\frac{x^2}{2(\\cosh(x)-1)}$$, which is well-behaved for both very small and very large $$x$$.\n\nThe specific-heat-weighted average Grüneisen parameter, $$\\Gamma_C(T)$$, is computed by averaging the mode-dependent $$\\gamma_{\\mathbf{q}_i}$$ values over the BZ, weighted by their respective contributions to the specific heat:\n$$\n\\Gamma_C(T) = \\frac{\\sum_{i=1}^{M} \\gamma_{\\mathbf{q}_i} C(\\omega(\\mathbf{q}_i, V_0), T)}{\\sum_{i=1}^{M} C(\\omega(\\mathbf{q}_i, V_0), T)}\n$$\nThis average is computed using both $$\\gamma_{\\mathbf{q}_i}^{\\mathrm{exact}}$$ and $$\\gamma_{\\mathbf{q}_i}^{\\mathrm{FD}}$$.\n\n#### d. Error Quantification\nTwo metrics are used to assess the numerical accuracy:\n1.  **Root-Mean-Square Error (RMSE)**: This measures the average deviation of the finite-difference approximation from the exact value across all sampled modes.\n    $$\n    \\mathrm{RMSE} = \\sqrt{\\frac{1}{M} \\sum_{i=1}^{M} \\left(\\gamma_{\\mathbf{q}_i}^{\\mathrm{FD}} - \\gamma_{\\mathbf{q}_i}^{\\mathrm{exact}}\\right)^2}\n    $$\n2.  **Absolute Error in Weighted Average**: This measures the error in the macroscopic thermodynamic quantity $$\\Gamma_C(T)$$ resulting from the use of the approximated $$\\gamma_{\\mathbf{q}_i}^{\\mathrm{FD}}$$.\n    $$\n    \\text{Error} = \\left| \\Gamma_C^{\\mathrm{FD}}(T) - \\Gamma_C^{\\mathrm{exact}}(T) \\right|\n    $$\n\n### 3. Implementation Plan\n\nThe solution is implemented as a Python script using the `numpy` library for efficient vectorized calculations.\n1.  Define all physical and model constants: $$A_0, A_1, \\eta_0, \\eta_1, V_0$$.\n2.  Define helper functions for $$\\omega_0(V)$$, $$v(V)$$, and $$\\omega(\\mathbf{q}, V)$$.\n3.  Iterate through each test case tuple $$(\\Delta V/V_0, N, T)$$.\n4.  For each case:\n    a. Generate the 3D grid of $$\\mathbf{q}$$-vectors and compute their squared norms.\n    b. Calculate the array of exact Grüneisen parameters, $$\\gamma^{\\mathrm{exact}}$$, at $$V_0$$ using the derived analytical formula.\n    c. Calculate the array of finite-difference Grüneisen parameters, $$\\gamma^{\\mathrm{FD}}$$, by evaluating $$\\omega$$ at $$V_0$$, $$V_0+\\Delta V$$, and $$V_0-\\Delta V$$.\n    d. Compute the RMSE between the $$\\gamma^{\\mathrm{exact}}$$ and $$\\gamma^{\\mathrm{FD}}$$ arrays.\n    e. Compute the array of specific heat values, $$C_i$$, using the phonon frequencies at $$V_0$$.\n    f. Calculate the weighted averages $$\\Gamma_C^{\\mathrm{exact}}(T)$$ and $$\\Gamma_C^{\\mathrm{FD}}(T)$$.\n    g. Calculate the absolute error between these two averages.\n    h. Store the resulting pair of metrics, `[RMSE, Absolute Error]`.\n5.  Format the final collection of results into a single string as specified and print it.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes numerical errors in the Grüneisen parameter calculation for a model\n    phonon dispersion, as a function of finite-difference step size and Brillouin\n    Zone sampling density.\n    \"\"\"\n    # Fixed parameter values from the problem statement.\n    A0 = 2.0\n    A1 = 1.0\n    ETA0 = 1.2\n    ETA1 = 0.3\n    V0 = 1.0\n\n    # Test suite: tuples of (dV/V0, N, T)\n    test_cases = [\n        (0.01, 30, 0.5),\n        (0.01, 8, 0.5),\n        (0.10, 30, 0.5),\n        (1e-6, 30, 0.5),\n        (0.01, 60, 0.5),\n    ]\n\n    # Helper functions for the dispersion model\n    def omega0_func(V, A0_val=A0, eta0_val=ETA0):\n        return A0_val * V ** (-eta0_val)\n\n    def v_func(V, A1_val=A1, eta1_val=ETA1):\n        return A1_val * V ** (-eta1_val)\n\n    def omega_func(q_norm_sq, V):\n        w0_sq = omega0_func(V) ** 2\n        v_sq = v_func(V) ** 2\n        return np.sqrt(w0_sq + v_sq * q_norm_sq)\n\n    # Numerically stable specific heat function C(omega, T)\n    def specific_heat_func(omega, T):\n        # x = omega / T\n        x = omega / T\n        # Handle the case where T is extremely low or omega is 0, making x large or 0.\n        # The form x^2 / (2 * (cosh(x) - 1)) is stable.\n        # Add a small epsilon to the denominator to prevent division by zero if x is exactly 0,\n        # though with the given model omega is always positive.\n        denominator = 2 * (np.cosh(x) - 1)\n        # For very small x, cosh(x) ~ 1 + x^2/2, so denom ~ x^2, and C ~ 1.\n        # The limit as x->0 is 1. We can use a condition to avoid 0/0.\n        c = np.ones_like(x)\n        mask = denominator > 0\n        c[mask] = (x[mask]**2) / denominator[mask]\n        return c\n\n    results = []\n\n    for dv_ratio, N, T in test_cases:\n        dV = V0 * dv_ratio\n\n        # 1. Generate q-points grid\n        q_coords = np.linspace(-np.pi, np.pi, N, endpoint=False)\n        qx, qy, qz = np.meshgrid(q_coords, q_coords, q_coords, indexing='ij')\n        q_norm_sq = qx**2 + qy**2 + qz**2\n\n        # 2. Calculate exact analytical Grüneisen parameter at V0\n        omega0_V0_sq = omega0_func(V0)**2\n        v_V0_sq = v_func(V0)**2\n        \n        numerator_exact = ETA0 * omega0_V0_sq + ETA1 * v_V0_sq * q_norm_sq\n        denominator_exact = omega0_V0_sq + v_V0_sq * q_norm_sq\n        gamma_exact = numerator_exact / denominator_exact\n\n        # 3. Calculate finite-difference Grüneisen parameter\n        V_plus = V0 + dV\n        V_minus = V0 - dV\n\n        omega_at_V0 = omega_func(q_norm_sq, V0)\n        omega_at_Vplus = omega_func(q_norm_sq, V_plus)\n        omega_at_Vminus = omega_func(q_norm_sq, V_minus)\n\n        d_omega_d_V_fd = (omega_at_Vplus - omega_at_Vminus) / (2 * dV)\n        gamma_fd = -V0 / omega_at_V0 * d_omega_d_V_fd\n\n        # 4. Calculate RMSE\n        rmse = np.sqrt(np.mean((gamma_fd - gamma_exact)**2))\n\n        # 5. Calculate specific-heat-weighted average Grüneisen params and their error\n        C_q = specific_heat_func(omega_at_V0, T)\n        \n        sum_C = np.sum(C_q)\n\n        Gamma_C_exact = np.sum(gamma_exact * C_q) / sum_C\n        Gamma_C_fd = np.sum(gamma_fd * C_q) / sum_C\n        \n        abs_error_Gamma_C = np.abs(Gamma_C_fd - Gamma_C_exact)\n\n        results.append([rmse, abs_error_Gamma_C])\n\n    # Format the final output string to match the required format: [[r1,e1],[r2,e2],...]\n    # without spaces inside the inner lists.\n    result_strings = [f\"[{r},{e}]\" for r, e in results]\n    final_output_string = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}