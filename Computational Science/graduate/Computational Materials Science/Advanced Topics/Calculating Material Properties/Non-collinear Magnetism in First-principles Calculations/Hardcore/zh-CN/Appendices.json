{
    "hands_on_practices": [
        {
            "introduction": "第一性原理计算的一个核心应用是为更高级别的模型（如微磁学模型）提供精确的参数。本练习将指导您完成一个关键过程：如何从一系列计算得到的平面自旋螺旋能量 $E(\\mathbf{q})$ 中，通过最小二乘拟合提取出描述磁织构行为的基本物理量，例如自旋刚度 $D$ 和 Dzyaloshinskii-Moriya 相互作用（DMI）矢量 $\\mathbf{D}$。这个实践将帮助您理解连接原子尺度计算和宏观磁现象的桥梁 ()。",
            "id": "3468726",
            "problem": "给定铁磁性金属中平面自旋螺旋的合成第一性原理总能量，这些能量是在三种交换相关近似下计算的：局域自旋密度近似 (LSDA)、广义梯度近似 (GGA) 和元广义梯度近似 (meta-GGA)。对于小波矢，对称性和解析性意味着，具有传播矢量 $\\mathbf{q}$ 和手性 $s \\in \\{+1,-1\\}$ 的均匀自旋螺旋的每原子能量可进行最低阶展开\n$$\nE(\\mathbf{q},s,c)=E_{0} + K\\,c + D\\,|\\mathbf{q}|^{2} + s\\,\\mathbf{D}\\cdot\\mathbf{q},\n$$\n其中 $E_{0}$ 是基线能量，$D$ 是标量自旋刚度，$\\mathbf{D}$ 是 Dzyaloshinskii–Moriya 相互作用 (DMI) 矢量，$K$ 是相对于易轴 $\\hat{\\mathbf{z}}$ 的单轴磁晶各向异性常数，$c$ 是各向异性贡献的取向因子。此处提供的数据中，所有自旋螺旋都在 $xy$ 平面内，因此对于所有非共线螺旋，$c=1$。还提供了两种均匀（共线）态：一种与易轴 $\\hat{\\mathbf{z}}$ 对齐，此时 $c=0$；另一种垂直于 $\\hat{\\mathbf{z}}$，此时 $c=1$。手性 $s=+1$ 表示右旋，$s=-1$ 表示左旋。单位如下：能量单位为毫电子伏特/原子 (meV/atom)，波矢单位为埃格斯特朗的倒数 ($\\text{\\AA}^{-1}$)，因此 $D$ 的单位为 $\\text{meV}\\cdot\\text{\\AA}^{2}$，$\\mathbf{D}$ 的单位为 $\\text{meV}\\cdot\\text{\\AA}$，$K$ 的单位为 meV/atom。\n\n任务。从上述展开式和不同不变贡献的线性叠加原理出发，推导一种算法，该算法在给定一组测量值 $\\{(\\mathbf{q}_{i},s_{i},c_{i},E_{i})\\}$ 的情况下，通过求解关于回归量 $\\{1,c_{i},|\\mathbf{q}_{i}|^{2}, s_{i} q_{i,x}, s_{i} q_{i,y}, s_{i} q_{i,z}\\}$ 的线性最小二乘问题来估计参数 $\\{D,\\mathbf{D},K\\}$。然后将该算法实现为一个完整的、可运行的程序，该程序按如下规定报告每个泛函的拟合参数。\n\n数据。对于每个泛函，均以下列形式给出元组列表 $(q_{x},q_{y},q_{z},s,c,E)$。所有 $E$ 值单位为 meV/atom，所有 $q$ 分量单位为 $\\text{\\AA}^{-1}$。均匀态列在最后，其 $\\mathbf{q}=\\mathbf{0}$；对于这些状态，使用 $s=0$。\n\n- LSDA (局域自旋密度近似):\n  - 螺旋态:\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,+1,1,-117.71)$\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,-1,1,-117.89)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,+1,1,-117.83)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,-1,1,-117.77)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,+1,1,-118.448)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,-1,1,-118.448)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,+1,1,-118.67)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,-1,1,-118.73)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,+1,1,-119.069)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,-1,1,-119.087)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,+1,1,-119.171)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,-1,1,-119.093)$\n  - 均匀态:\n    - $(0.00,0.00,0.00,0,0,-120.00)$\n    - $(0.00,0.00,0.00,0,1,-119.60)$\n\n- GGA (广义梯度近似):\n  - 螺旋态:\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,+1,1,-147.63)$\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,-1,1,-147.87)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,+1,1,-147.70)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,-1,1,-147.80)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,+1,1,-148.47)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,-1,1,-148.47)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,+1,1,-148.665)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,-1,1,-148.835)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,+1,1,-149.131)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,-1,1,-149.209)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,+1,1,-149.273)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,-1,1,-149.187)$\n  - 均匀态:\n    - $(0.00,0.00,0.00,0,0,-150.00)$\n    - $(0.00,0.00,0.00,0,1,-149.75)$\n\n- meta-GGA (元-广义梯度近似):\n  - 螺旋态:\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,+1,1,-197.76)$\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,-1,1,-197.64)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,+1,1,-197.64)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,-1,1,-197.76)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,+1,1,-198.468)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,-1,1,-198.516)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,+1,1,-198.80)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,-1,1,-198.80)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,+1,1,-199.244)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,-1,1,-199.280)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,+1,1,-199.289)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,-1,1,-199.367)$\n  - 均匀态:\n    - $(0.00,0.00,0.00,0,0,-200.00)$\n    - $(0.00,0.00,0.00,0,1,-199.90)\n\n要求。\n- 仅使用上述线性模型，并通过构建设计矩阵（其列对应于 $1$、$c$、$|\\mathbf{q}|^2$、$s\\,q_{x}$、$s\\,q_{y}$、$s\\,q_{z}$）从第一性原理推导最小二乘估计量。\n- 对于每个泛函，估计并报告元组 $[D,D_{x},D_{y},D_{z},K]$，其中 $\\mathbf{D}=(D_{x},D_{y},D_{z})$。\n- 数值单位:\n  - 能量必须以 meV/atom 为单位处理。\n  - 波矢必须以 $\\text{\\AA}^{-1}$ 为单位处理。\n  - 报告 $D$ 的单位为 $\\text{meV}\\cdot\\text{\\AA}^{2}$，$\\mathbf{D}$ 的每个分量的单位为 $\\text{meV}\\cdot\\text{\\AA}$，$K$ 的单位为 meV/atom。\n- 本问题不使用角度单位。\n- 输出取整：将每个报告的数字四舍五入到小数点后三位。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表按 LSDA、GGA、meta-GGA 的顺序对应一个泛函。确切格式为\n  $$\n  \\big[\\,[D_{\\mathrm{LSDA}},D_{x,\\mathrm{LSDA}},D_{y,\\mathrm{LSDA}},D_{z,\\mathrm{LSDA}},K_{\\mathrm{LSDA}}],\\,[D_{\\mathrm{GGA}},D_{x,\\mathrm{GGA}},D_{y,\\mathrm{GGA}},D_{z,\\mathrm{GGA}},K_{\\mathrm{GGA}}],\\,[D_{\\mathrm{mGGA}},D_{x,\\mathrm{mGGA}},D_{y,\\mathrm{mGGA}},D_{z,\\mathrm{mGGA}},K_{\\mathrm{mGGA}}]\\,\\big]\n  $$\n  其中每个值都四舍五入到三位小数。例如，输出可能如下所示\n  $$\n  [[180.000,0.900,-0.300,0.000,0.400],[200.000,1.200,0.500,0.000,0.250],[220.000,-0.600,0.600,0.300,0.100]].\n  $$\n\n测试套件和覆盖范围。\n- LSDA 集包含一个 $q_{z}\\neq 0$ 但 $D_{z}=0$ 的方向，以及一个能量与 $s$ 无关的情况，用于探测量 $z$ 方向上 DMI 的缺失。\n- GGA 集使用非零的 $D_{x}$ 和 $D_{y}$，具有两种手性以及多个 $|\\mathbf{q}|$ 的量级，以稳健地约束 $D$。\n- meta-GGA 集包含非零的 $D_{z}$ 和一个 $\\mathbf{D}\\cdot\\mathbf{q}=0$ 的螺旋，以测试对零投影情况的敏感性。\n- 在 $\\mathbf{q}=\\mathbf{0}$ 处，$c=0$ 和 $c=1$ 的均匀态允许独立识别 $K$ 并将其与截距 $E_{0}$ 分开。\n\n您提交的内容必须是一个单一、完整的程序，该程序根据所提供的数据构建设计矩阵，解决最小二乘问题，并以上述确切格式打印结果，所有数字四舍五入到三位小数，不使用任何输入文件。该程序必须是自包含的，并且可以直接运行。",
            "solution": "该问题要求推导并实现一种算法，从一组合成的第一性原理总能量计算中估计微磁学参数。所提供的平面自旋螺旋中每个原子的能量 $E$ 作为其波矢 $\\mathbf{q}$、手性 $s$ 和各向异性取向因子 $c$ 的函数的模型是：\n$$\nE(\\mathbf{q},s,c)=E_{0} + K\\,c + D\\,|\\mathbf{q}|^{2} + s\\,\\mathbf{D}\\cdot\\mathbf{q}\n$$\n其中 $E_{0}$ 是基线能量，$K$ 是单轴磁晶各向异性常数，$D$ 是标量自旋刚度，$\\mathbf{D}$ 是 Dzyaloshinskii–Moriya 相互作用 (DMI) 矢量。任务是估计参数 $\\{D, \\mathbf{D}, K\\}$。\n\n首先，我们展开 DMI 项 $s\\,\\mathbf{D}\\cdot\\mathbf{q}$。设 $\\mathbf{D} = (D_{x}, D_{y}, D_{z})$ 且 $\\mathbf{q} = (q_{x}, q_{y}, q_{z})$，该项变为 $s(D_{x}q_{x} + D_{y}q_{y} + D_{z}q_{z})$。将其代入能量模型，揭示了其相对于参数的线性结构：\n$$\nE(\\mathbf{q},s,c) = E_{0}(1) + K(c) + D(|\\mathbf{q}|^{2}) + D_{x}(s q_{x}) + D_{y}(s q_{y}) + D_{z}(s q_{z})\n$$\n括号中的项是回归变量，而 $\\{E_{0}, K, D, D_{x}, D_{y}, D_{z}\\}$ 是待确定的系数。给定一组 $N$ 个测量值 $\\{(\\mathbf{q}_{i}, s_{i}, c_{i}, E_{i})\\}_{i=1}^{N}$，这就定义了一个线性方程组。该系统适用于线性最小二乘分析。\n\n我们将问题用矩阵表示法表述为 $\\mathbf{y} \\approx \\mathbf{X}\\boldsymbol{\\beta}$，其中：\n- $\\mathbf{y}$ 是观测能量的 $N \\times 1$ 列向量：$\\mathbf{y} = [E_{1}, E_{2}, \\dots, E_{N}]^T$。\n- $\\boldsymbol{\\beta}$ 是未知模型参数的 $M \\times 1$ 列向量。对于此问题，有 $M=6$ 个参数。我们根据问题陈述中指定的回归量顺序定义 $\\boldsymbol{\\beta}$：$\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\beta_2, \\beta_3, \\beta_4, \\beta_5]^T = [E_0, K, D, D_x, D_y, D_z]^T$。\n- $\\mathbf{X}$ 是 $N \\times M$ 的设计矩阵。$\\mathbf{X}$ 的每一行 $i$ 由第 $i$ 个数据点构造，各列对应于回归量 $\\{1, c, |\\mathbf{q}|^{2}, s q_{x}, s q_{y}, s q_{z}\\}$。具体来说，第 $i$ 行为：\n$$\n\\mathbf{X}_{i,:} = \\begin{bmatrix} 1  c_{i}  |\\mathbf{q}_{i}|^{2}  s_{i}q_{i,x}  s_{i}q_{i,y}  s_{i}q_{i,z} \\end{bmatrix}\n$$\n其中 $|\\mathbf{q}_{i}|^{2} = q_{i,x}^2 + q_{i,y}^2 + q_{i,z}^2$。\n\n线性最小二乘法旨在寻找参数矢量 $\\hat{\\boldsymbol{\\beta}}$，以最小化残差平方和 $S = \\sum_{i=1}^{N} (E_i - \\mathbf{X}_{i,:}\\boldsymbol{\\beta})^2 = (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta})^T (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta})$。最小化 $S$ 的解可以通过求解正规方程找到：\n$$\n(\\mathbf{X}^T \\mathbf{X}) \\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T \\mathbf{y}\n$$\n假设 $\\mathbf{X}$ 的列是线性无关的（对于一组精心设计的测量，这通常是成立的），则矩阵 $\\mathbf{X}^T \\mathbf{X}$ 是可逆的。那么，参数矢量的唯一最小二乘估计为：\n$$\n\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}\n$$\n所实现的算法将针对每个泛函的数据集执行以下操作：\n1.  根据所提供的数据元组 $(q_{x}, q_{y}, q_{z}, s, c, E)$ 构建设计矩阵 $\\mathbf{X}$ 和观测向量 $\\mathbf{y}$。\n2.  通过求解线性最小二乘问题，数值计算参数矢量 $\\hat{\\boldsymbol{\\beta}}$。最好使用稳定的数值例程（如基于 QR 分解或奇异值分解 (SVD) 的例程）来完成，这比显式计算 $\\mathbf{X}^T \\mathbf{X}$ 的逆更稳健。\n3.  所得矢量 $\\hat{\\boldsymbol{\\beta}} = [\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2, \\hat{\\beta}_3, \\hat{\\beta}_4, \\hat{\\beta}_5]^T$ 的分量是物理参数的估计值：\n    - 各向异性常数 $K \\approx \\hat{\\beta}_1$\n    - 自旋刚度 $D \\approx \\hat{\\beta}_2$\n    - DMI 矢量分量 $\\{D_x, D_y, D_z\\} \\approx \\{\\hat{\\beta}_3, \\hat{\\beta}_4, \\hat{\\beta}_5\\}$\n4.  从 $\\hat{\\boldsymbol{\\beta}}$ 的分量中组合出所需的输出元组 $[D, D_x, D_y, D_z, K]$，它对应于 $[\\hat{\\beta}_2, \\hat{\\beta}_3, \\hat{\\beta}_4, \\hat{\\beta}_5, \\hat{\\beta}_1]$。\n5.  将最终值四舍五入到三位小数，并按规定格式化。\n此过程根据所提供的理论模型，从能量数据中系统地推导出物理参数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Fits micromagnetic parameters to synthetic first-principles energy data\n    using linear least-squares regression and prints the results.\n    \"\"\"\n    \n    # Data sets provided in the problem statement.\n    # Each tuple is (qx, qy, qz, s, c, E).\n    lsda_data = [\n        # Spirals\n        (0.10, 0.00, 0.00, 1, 1, -117.71),\n        (0.10, 0.00, 0.00, -1, 1, -117.89),\n        (0.00, 0.10, 0.00, 1, 1, -117.83),\n        (0.00, 0.10, 0.00, -1, 1, -117.77),\n        (0.00, 0.00, 0.08, 1, 1, -118.448),\n        (0.00, 0.00, 0.08, -1, 1, -118.448),\n        (0.05, 0.05, 0.00, 1, 1, -118.67),\n        (0.05, 0.05, 0.00, -1, 1, -118.73),\n        (0.02, 0.03, 0.04, 1, 1, -119.069),\n        (0.02, 0.03, 0.04, -1, 1, -119.087),\n        (-0.04, 0.01, 0.03, 1, 1, -119.171),\n        (-0.04, 0.01, 0.03, -1, 1, -119.093),\n        # Uniform\n        (0.00, 0.00, 0.00, 0, 0, -120.00),\n        (0.00, 0.00, 0.00, 0, 1, -119.60)\n    ]\n\n    gga_data = [\n        # Spirals\n        (0.10, 0.00, 0.00, 1, 1, -147.63),\n        (0.10, 0.00, 0.00, -1, 1, -147.87),\n        (0.00, 0.10, 0.00, 1, 1, -147.70),\n        (0.00, 0.10, 0.00, -1, 1, -147.80),\n        (0.00, 0.00, 0.08, 1, 1, -148.47),\n        (0.00, 0.00, 0.08, -1, 1, -148.47),\n        (0.05, 0.05, 0.00, 1, 1, -148.665),\n        (0.05, 0.05, 0.00, -1, 1, -148.835),\n        (0.02, 0.03, 0.04, 1, 1, -149.131),\n        (0.02, 0.03, 0.04, -1, 1, -149.209),\n        (-0.04, 0.01, 0.03, 1, 1, -149.273),\n        (-0.04, 0.01, 0.03, -1, 1, -149.187),\n        # Uniform\n        (0.00, 0.00, 0.00, 0, 0, -150.00),\n        (0.00, 0.00, 0.00, 0, 1, -149.75)\n    ]\n\n    meta_gga_data = [\n        # Spirals\n        (0.10, 0.00, 0.00, 1, 1, -197.76),\n        (0.10, 0.00, 0.00, -1, 1, -197.64),\n        (0.00, 0.10, 0.00, 1, 1, -197.64),\n        (0.00, 0.10, 0.00, -1, 1, -197.76),\n        (0.00, 0.00, 0.08, 1, 1, -198.468),\n        (0.00, 0.00, 0.08, -1, 1, -198.516),\n        (0.05, 0.05, 0.00, 1, 1, -198.80),\n        (0.05, 0.05, 0.00, -1, 1, -198.80),\n        (0.02, 0.03, 0.04, 1, 1, -199.244),\n        (0.02, 0.03, 0.04, -1, 1, -199.280),\n        (-0.04, 0.01, 0.03, 1, 1, -199.289),\n        (-0.04, 0.01, 0.03, -1, 1, -199.367),\n        # Uniform\n        (0.00, 0.00, 0.00, 0, 0, -200.00),\n        (0.00, 0.00, 0.00, 0, 1, -199.90)\n    ]\n\n    all_datasets = [lsda_data, gga_data, meta_gga_data]\n    overall_results = []\n\n    for dataset in all_datasets:\n        num_points = len(dataset)\n        # Design matrix X: columns for [1, c, |q|^2, s*qx, s*qy, s*qz]\n        X = np.zeros((num_points, 6))\n        # Observation vector y: energies E\n        y = np.zeros(num_points)\n\n        for i, point in enumerate(dataset):\n            qx, qy, qz, s, c, E = point\n            q_sq = qx**2 + qy**2 + qz**2\n            \n            X[i, 0] = 1.0       # Corresponds to E0 (intercept)\n            X[i, 1] = float(c)  # Corresponds to K\n            X[i, 2] = q_sq      # Corresponds to D\n            X[i, 3] = s * qx    # Corresponds to Dx\n            X[i, 4] = s * qy    # Corresponds to Dy\n            X[i, 5] = s * qz    # Corresponds to Dz\n            \n            y[i] = E\n\n        # Solve the linear least-squares problem X*p = y for p\n        params, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        \n        # Extract parameters according to the model: E = E0 + K*c + D*|q|^2 + ...\n        # params[0] = E0\n        K = params[1]\n        D = params[2]\n        Dx = params[3]\n        Dy = params[4]\n        Dz = params[5]\n        \n        # Assemble the results in the required order: [D, Dx, Dy, Dz, K]\n        result_list = [D, Dx, Dy, Dz, K]\n        overall_results.append(result_list)\n\n    # Format the final output string as a list of lists, with each number\n    # rounded to three decimal places.\n    output_parts = []\n    for res_list in overall_results:\n        formatted_numbers = [f\"{num:.3f}\" for num in res_list]\n        output_parts.append(f\"[{','.join(formatted_numbers)}]\")\n        \n    final_output = f\"[[{','.join(output_parts)}]]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "精确计算自旋螺旋的能量色散 $E(\\mathbf{q})$ 曲线是至关重要的，但实践中充满挑战。本练习将揭示一个常见的数值陷阱：当用于布里渊区积分的 $\\mathbf{k}$ 点网格与自旋螺旋矢量 $\\mathbf{q}$ 不公度时，会引入显著的计算误差。通过对比非自适应和自适应 $\\mathbf{k}+\\mathbf{q}$ 采样策略，您将亲手量化这种偏差，并学会如何通过构建公度网格来消除它，从而确保计算的准确性 ()。",
            "id": "3468708",
            "problem": "您的任务是量化非公度 $\\mathbf{k}$ 点网格如何偏置计算出的自旋螺旋能量 $E(\\mathbf{q})$，这是在一个简化的、受第一性原理启发的非共线磁性模型中进行的，并实现一种自适应的 $\\mathbf{k}+\\mathbf{q}$ 采样策略来改善这种偏差。背景设定为一个二维正方晶格，具有单带紧束缚色散和一个用于广义布洛赫定理耦合的代理模型。\n\n基本假设和定义：\n- 考虑一个二维布里渊区，它是笛卡尔积 $[-\\pi,\\pi)\\times[-\\pi,\\pi)$，单位为弧度。所有角度都必须以弧度为单位。\n- 在正方晶格上使用单带紧束缚色散\n$$\n\\varepsilon(\\mathbf{k}) \\equiv \\varepsilon(k_x,k_y) = -2t\\left[\\cos(k_x) + \\cos(k_y)\\right],\n$$\n其中 $t=1$（无量纲）。\n- 在由广义布洛赫定理（GBT）描述的自旋螺旋中，波矢 $\\mathbf{q}$ 将 $\\mathbf{k}$ 态与 $\\mathbf{k}+\\mathbf{q}$ 态耦合。作为弱交换作用下二阶微扰能量的一个平滑代理，定义\n$$\nS(x,y;\\alpha) = \\frac{1}{1 + \\alpha\\,(y-x)^2},\n$$\n其中 $\\alpha=0.5$（无量纲）。自旋螺旋能量泛函定义为布里渊区内的平均值\n$$\nE(\\mathbf{q}) = \\frac{1}{\\Omega_{\\text{BZ}}}\\int_{\\text{BZ}} d^2k \\; S\\big(\\varepsilon(\\mathbf{k}),\\varepsilon(\\mathbf{k}+\\mathbf{q});\\alpha\\big),\n$$\n其中 $\\Omega_{\\text{BZ}}=(2\\pi)^2$。\n\n离散采样和数值任务：\n- 将布里渊区积分替换为在具有笛卡尔节点的 $N\\times N$ 网格上的均匀 Monkhorst-Pack 式求和\n$$\nk_x(i) = -\\pi + \\left(i+\\tfrac{1}{2}\\right)\\Delta, \\quad k_y(j) = -\\pi + \\left(j+\\tfrac{1}{2}\\right)\\Delta,\\quad \\Delta=\\frac{2\\pi}{N},\n$$\n其中整数 $i,j\\in\\{0,1,\\dots,N-1\\}$。\n- 定义一个周期性包裹算符 $\\mathcal{W}$，它通过 $\\mathcal{W}(\\theta)=((\\theta+\\pi)\\bmod 2\\pi)-\\pi$ 将任意角度 $\\theta$ 映射到 $[-\\pi,\\pi)$。\n\n实现 $E(\\mathbf{q})$ 的三个数值估计量：\n1. 一个高分辨率参考值 $E_{\\text{ref}}(\\mathbf{q})$，通过在大小为 $N_{\\text{ref}}\\times N_{\\text{ref}}$（其中 $N_{\\text{ref}}=384$）的密集网格上进行上述黎曼和计算得到。\n2. 一个在 $N\\times N$ 网格上的粗略非自适应估计 $E_{\\text{na}}(\\mathbf{q};N)$，它模拟一个只知道粗略网格上能带能量的代码：\n   - 仅在 $N\\times N$ 网格点上预计算 $\\varepsilon$。\n   - 对于每个粗略网格点 $\\mathbf{k}$，构造 $\\mathbf{k}+\\mathbf{q}$，用 $\\mathcal{W}$ 包裹每个分量，并通过对预计算的 $N\\times N$ 值表进行周期性双线性插值来评估 $\\varepsilon(\\mathbf{k}+\\mathbf{q})$。当 $\\mathbf{q}$ 与粗略网格公度时（即 $q_x/\\Delta$ 和 $q_y/\\Delta$ 都是整数），插值简化为精确的查表操作。\n   - 在 $N\\times N$ 网格上对 $S\\big(\\varepsilon(\\mathbf{k}),\\varepsilon(\\mathbf{k}+\\mathbf{q});\\alpha\\big)$ 进行平均，以获得 $E_{\\text{na}}(\\mathbf{q};N)$。\n3. 一个自适应的 $\\mathbf{k}+\\mathbf{q}$ 估计 $E_{\\text{ad}}(\\mathbf{q};N)$，它寻找一个与 $\\mathbf{q}$ 公度的精细化网格：\n   - 对于一个容差 $\\tau=10^{-12}$ 和一个上界 $M_{\\max}=96$，找到最小的整数 $M\\ge N$，使得 $q_x/\\Delta_M$ 和 $q_y/\\Delta_M$ 与某个整数的差值都在 $\\tau$ 以内，其中 $\\Delta_M=2\\pi/M$。如果不存在这样的 $M\\le M_{\\max}$，则设置 $M=M_{\\max}$。\n   - 按照非自适应情况下的方法计算 $E_{\\text{ad}}(\\mathbf{q};N)$，但使用 $M\\times M$ 网格以及在该精细化网格上的周期性双线性插值。当实现公度性时，双线性插值再次简化为精确的查表操作，从而消除了 $\\mathbf{k}+\\mathbf{q}$ 的对齐偏差。\n\n误差度量：\n- 对于每个测试用例，计算相对误差\n$$\n\\delta_{\\text{na}} = \\frac{\\left|E_{\\text{na}}(\\mathbf{q};N) - E_{\\text{ref}}(\\mathbf{q})\\right|}{\\max\\left(|E_{\\text{ref}}(\\mathbf{q})|,10^{-12}\\right)},\\quad\n\\delta_{\\text{ad}} = \\frac{\\left|E_{\\text{ad}}(\\mathbf{q};N) - E_{\\text{ref}}(\\mathbf{q})\\right|}{\\max\\left(|E_{\\text{ref}}(\\mathbf{q})|,10^{-12}\\right)}.\n$$\n- 同时报告布尔值 $b_{\\text{imp}}$，当且仅当 $\\delta_{\\text{ad}}  \\delta_{\\text{na}}$ 时为真。\n\n测试套件：\n- 使用以下四个测试用例，它们探究了公度和非公度场景、多分量 $\\mathbf{q}$ 以及一个边界条件：\n  - 情况 A：$N=12$，$\\mathbf{q}=(\\pi/3,\\,0)$。\n  - 情况 B：$N=12$，$\\mathbf{q}=(\\pi/5,\\,0)$。\n  - 情况 C：$N=12$，$\\mathbf{q}=(\\pi/5,\\,2\\pi/5)$。\n  - 情况 D：$N=12$，$\\mathbf{q}=(0,\\,0)$。\n\n最终输出要求：\n- 您的程序必须生成单行输出，其中包含一个列表的列表，每个内部列表对应一个测试用例，顺序为 A、B、C、D。每个内部列表必须按此顺序包含恰好三个条目：$\\delta_{\\text{na}}$（浮点数）、$\\delta_{\\text{ad}}$（浮点数）和 $b_{\\text{imp}}$（布尔值）。输出必须具有 Python 字面量列表的精确格式，例如 `[[0.1,0.05,True],[\\dots],\\dots]`，不含额外文本，空格可选。由于模型是无量纲的，且所有角度都以弧度为单位，因此不需要物理单位。",
            "solution": "该问题被认为是有效的。它在科学上是有根据的，是计算材料科学中一个明确定义的模型问题，旨在测试处理非公度结构的数值方法。它的提法是适定的，所有必要的函数、参数和程序都已明确定义。问题陈述客观且无歧义。\n\n任务是实现并比较自旋螺旋能量泛函 $E(\\mathbf{q})$ 的三个数值估计量。该泛函量化了具有由波矢 $\\mathbf{q}$ 表征的自旋螺旋磁序系统的能量。该比较将突显当自旋螺旋波矢 $\\mathbf{q}$ 与采样网格非公度时，标准离散布里渊区采样所引入的数值偏差，并展示自适应网格策略如何减轻这种偏差。\n\n首先，我们定义模型的基本物理和数学组成部分。\n该系统是一个二维正方晶格，其布里渊区（BZ）是方形区域 $[-\\pi, \\pi) \\times [-\\pi, \\pi)$，面积为 $\\Omega_{\\text{BZ}} = (2\\pi)^2$。\n电子能带结构由单带紧束缚色散关系描述：\n$$\n\\varepsilon(\\mathbf{k}) = \\varepsilon(k_x, k_y) = -2t \\left[ \\cos(k_x) + \\cos(k_y) \\right]\n$$\n其中 $\\mathbf{k} = (k_x, k_y)$ 是布里渊区中的一个波矢，跳跃参数设置为 $t=1$。\n产生自旋螺旋态的相互作用由一个代理耦合函数 $S$ 建模，该函数依赖于由矢量 $\\mathbf{q}$ 耦合的两个态的能量：\n$$\nS(x, y; \\alpha) = \\frac{1}{1 + \\alpha (y-x)^2}\n$$\n参数 $\\alpha$ 控制着对耦合态能量之间巨大差异的能量惩罚强度，给定为 $\\alpha=0.5$。\n总自旋螺旋能量 $E(\\mathbf{q})$ 是该耦合函数在布里渊区中所有可能的状态对 $(\\mathbf{k}, \\mathbf{k}+\\mathbf{q})$ 上的平均值：\n$$\nE(\\mathbf{q}) = \\frac{1}{\\Omega_{\\text{BZ}}} \\int_{\\text{BZ}} d^2k \\; S\\big(\\varepsilon(\\mathbf{k}), \\varepsilon(\\mathbf{k}+\\mathbf{q}); \\alpha\\big)\n$$\n\n在数值上，连续积分被替换为在均匀的 $N \\times N$ $\\mathbf{k}$ 点网格上的离散求和，这类似于 Monkhorst-Pack 采样方案。网格点定义为：\n$$\nk_x(i) = -\\pi + \\left(i + \\frac{1}{2}\\right)\\Delta, \\quad k_y(j) = -\\pi + \\left(j + \\frac{1}{2}\\right)\\Delta\n$$\n其中整数 $i, j \\in \\{0, 1, \\dots, N-1\\}$，网格间距为 $\\Delta = 2\\pi/N$。然后，积分由黎曼和近似：\n$$\nE(\\mathbf{q}) \\approx \\frac{1}{N^2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} S\\big(\\varepsilon(\\mathbf{k}_{ij}), \\varepsilon(\\mathbf{k}_{ij}+\\mathbf{q}); \\alpha\\big)\n$$\n其中 $\\mathbf{k}_{ij} = (k_x(i), k_y(j))$。一个关键步骤是处理矢量 $\\mathbf{k}+\\mathbf{q}$，其分量可能落在主布里渊区间 $[-\\pi, \\pi)$ 之外。我们使用周期性包裹算符 $\\mathcal{W}$ 将它们映射回该区间，定义为 $\\mathcal{W}(\\theta) = ((\\theta+\\pi) \\pmod{2\\pi}) - \\pi$。\n\n现在我们将详细介绍 $E(\\mathbf{q})$ 的三个不同数值估计量。\n\n1.  **高分辨率参考值, $E_{\\text{ref}}(\\mathbf{q})$**：这作为我们数值实验的“基准真相”。它通过在具有 $N_{\\text{ref}} = 384$ 的非常密集的网格上执行离散求和来计算。对于每个网格点 $\\mathbf{k}$，$\\varepsilon(\\mathbf{k})$ 和 $\\varepsilon(\\mathcal{W}(\\mathbf{k}+\\mathbf{q}))$ 都直接从 $\\varepsilon$ 的解析公式计算。点的高密度确保了对真实积分的非常精确的近似，从而最小化了离散化误差。\n\n2.  **非自适应估计量, $E_{\\text{na}}(\\mathbf{q}; N)$**：此方法模拟在粗略的 $N \\times N$ 网格上执行的标准的、非自适应的第一性原理计算。\n    - 首先，预先计算一个能量值表 $\\varepsilon(\\mathbf{k})$，并仅存储粗略 $N \\times N$ 网格上的点。\n    - 求和在此粗略网格上进行。对于每个粗略网格点 $\\mathbf{k}$，我们需要能量 $\\varepsilon(\\mathbf{k}+\\mathbf{q})$。\n    - 当 $\\mathbf{q}$ 与网格非公度时（即，$q_x/\\Delta$ 或 $q_y/\\Delta$ 不是整数），点 $\\mathbf{k}' = \\mathcal{W}(\\mathbf{k}+\\mathbf{q})$ 将不会与我们预计算表中的任何点重合。\n    - 为了获得 $\\varepsilon(\\mathbf{k}')$，我们必须从表中的周围四个网格点进行插值。问题指定了周期性双线性插值。给定一个点 $\\mathbf{k}'=(k'_x, k'_y)$ 和在间距为 $\\Delta$ 的 $N \\times N$ 网格上的能量表，我们找到“向下取整”的网格索引 $(i_0, j_0)$ 和归一化位移 $(t_x, t_y)$，使得 $k'_x$ 位于网格点 $i_0$ 和 $(i_0+1)\\pmod N$ 之间，对 $k'_y$ 也类似。然后插值得到的能量是：\n      $$\n      \\varepsilon(\\mathbf{k}') \\approx (1-t_x)(1-t_y)\\varepsilon_{i_0,j_0} + t_x(1-t_y)\\varepsilon_{i_0+1,j_0} + (1-t_x)t_y\\varepsilon_{i_0,j_0+1} + t_x t_y\\varepsilon_{i_0+1,j_0+1}\n      $$\n      （索引取模 $N$）。这种插值引入了一个误差，该误差取决于 $\\varepsilon(\\mathbf{k})$ 的非线性和 $\\mathbf{k}'$ 的位置。$E_{\\text{na}}$ 是 $S(\\varepsilon(\\mathbf{k}), \\varepsilon_{\\text{interp}}(\\mathcal{W}(\\mathbf{k}+\\mathbf{q})); \\alpha)$ 在粗略网格上的平均值。\n\n3.  **自适应估计量, $E_{\\text{ad}}(\\mathbf{q}; N)$**：此方法旨在通过选择一个与 $\\mathbf{q}$ 公度的新的、更精细的网格来消除插值误差。\n    - 执行搜索以找到最小的整数网格大小 $M$（其中 $N \\le M \\le M_{\\max}$），使得新的网格间距 $\\Delta_M = 2\\pi/M$ 使 $\\mathbf{q}$ 成为一个网格矢量。当 $q_x/\\Delta_M$ 和 $q_y/\\Delta_M$ 都与某个整数的差值在微小容差 $\\tau=10^{-12}$ 以内时，即达到此目的。如果在 $M \\le M_{\\max}=96$ 的范围内找不到这样的 $M$，则将 $M$ 设置为 $M_{\\max}$。\n    - 然后在新的自适应 $M \\times M$ 网格上执行整个计算。在此 $M \\times M$ 网格上计算 $\\varepsilon(\\mathbf{k})$ 的能量表。$E_{\\text{ad}}$ 的求和也在该网格上进行。\n    - 对于 $M \\times M$ 网格上的每个点 $\\mathbf{k}$，平移后的点 $\\mathbf{k}+\\mathbf{q}$ 现在将落在（或非常接近）另一个网格点上。因此，$\\varepsilon(\\mathcal{W}(\\mathbf{k}+\\mathbf{q}))$ 的双线性插值变成了一个简单的、精确的查表操作，从而消除了非自适应方案中存在的偏差源。\n\n最后，为了量化改进，我们计算两种粗略网格方法相对于高分辨率参考值的相对误差：\n$$\n\\delta_{\\text{na}} = \\frac{\\left|E_{\\text{na}}(\\mathbf{q};N) - E_{\\text{ref}}(\\mathbf{q})\\right|}{\\max\\left(|E_{\\text{ref}}(\\mathbf{q})|, 10^{-12}\\right)}, \\quad \\delta_{\\text{ad}} = \\frac{\\left|E_{\\text{ad}}(\\mathbf{q};N) - E_{\\text{ref}}(\\mathbf{q})\\right|}{\\max\\left(|E_{\\text{ref}}(\\mathbf{q})|, 10^{-12}\\right)}\n$$\n如果自适应方法更准确，即 $\\delta_{\\text{ad}}  \\delta_{\\text{na}}$，则布尔标志 $b_{\\text{imp}}$ 设置为真。实现将处理四个指定的测试用例，并为每个用例报告这三个度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants from the problem statement\nT_HOP = 1.0\nALPHA = 0.5\nN_REF = 384\nTAU = 1e-12\nM_MAX = 96\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n\n    def wrap(theta):\n        \"\"\"Applies the periodic wrapping operator W to map angles to [-pi, pi).\"\"\"\n        return (theta + np.pi) % (2 * np.pi) - np.pi\n\n    def epsilon(k, t):\n        \"\"\"Computes the tight-binding dispersion epsilon(k).\"\"\"\n        kx, ky = k[..., 0], k[..., 1]\n        return -2 * t * (np.cos(kx) + np.cos(ky))\n\n    def S_func(eps1, eps2, alpha):\n        \"\"\"Computes the surrogate coupling function S(eps1, eps2; alpha).\"\"\"\n        return 1.0 / (1.0 + alpha * (eps2 - eps1)**2)\n\n    def bilinear_interp(k_prime, eps_grid, N):\n        \"\"\"Performs periodic bilinear interpolation of epsilon on a grid.\"\"\"\n        delta = 2.0 * np.pi / N\n        kx_p_wrapped, ky_p_wrapped = k_prime\n\n        # Calculate floating-point indices and interpolation weights\n        ix_float = (kx_p_wrapped + np.pi) / delta - 0.5\n        iy_float = (ky_p_wrapped + np.pi) / delta - 0.5\n\n        ix0 = int(np.floor(ix_float))\n        iy0 = int(np.floor(iy_float))\n        \n        # Check for near-integer cases due to floating point arithmetic\n        if np.isclose(ix_float, np.round(ix_float)):\n            ix_float = np.round(ix_float)\n            ix0 = int(ix_float)\n        if np.isclose(iy_float, np.round(iy_float)):\n            iy_float = np.round(iy_float)\n            iy0 = int(iy_float)\n        \n        tx = ix_float - ix0\n        ty = iy_float - iy0\n\n        # Apply periodic boundary conditions on indices\n        ix0 %= N\n        iy0 %= N\n        ix1 = (ix0 + 1) % N\n        iy1 = (iy0 + 1) % N\n\n        # Get values at the four surrounding grid points\n        v00 = eps_grid[ix0, iy0]\n        v10 = eps_grid[ix1, iy0]\n        v01 = eps_grid[ix0, iy1]\n        v11 = eps_grid[ix1, iy1]\n\n        # Perform interpolation\n        c0 = v00 * (1 - tx) + v10 * tx\n        c1 = v01 * (1 - tx) + v11 * tx\n\n        return c0 * (1 - ty) + c1 * ty\n\n    def find_M(q, N, M_max, tau):\n        \"\"\"Finds the smallest commensurate grid size M >= N.\"\"\"\n        q_frac = q / (2 * np.pi)\n        for M_cand in range(N, M_max + 1):\n            scaled_q = M_cand * q_frac\n            residuals = np.abs(scaled_q - np.round(scaled_q))\n            if np.all(residuals  tau):\n                return M_cand\n        return M_max\n\n    def calc_E_ref(q, N, t, alpha):\n        \"\"\"Computes the high-resolution reference energy E_ref.\"\"\"\n        delta = 2.0 * np.pi / N\n        k_1d = -np.pi + (np.arange(N) + 0.5) * delta\n        kx_grid, ky_grid = np.meshgrid(k_1d, k_1d, indexing='ij')\n        k_grid = np.stack((kx_grid, ky_grid), axis=-1)\n\n        eps_k = epsilon(k_grid, t)\n        \n        k_plus_q = k_grid + q\n        k_plus_q_wrapped = wrap(k_plus_q)\n        \n        eps_k_plus_q = epsilon(k_plus_q_wrapped, t)\n        \n        s_vals = S_func(eps_k, eps_k_plus_q, alpha)\n        \n        return np.mean(s_vals)\n\n    def calc_E_interp(q, N, t, alpha):\n        \"\"\"Computes energy using interpolation, base for E_na and E_ad.\"\"\"\n        delta = 2.0 * np.pi / N\n        k_1d = -np.pi + (np.arange(N) + 0.5) * delta\n        kx_grid, ky_grid = np.meshgrid(k_1d, k_1d, indexing='ij')\n        k_grid = np.stack((kx_grid, ky_grid), axis=-1)\n\n        eps_table = epsilon(k_grid, t)\n        \n        total_s = 0.0\n        for i in range(N):\n            for j in range(N):\n                k = k_grid[i, j, :]\n                eps_k = eps_table[i, j]\n                \n                k_plus_q = k + q\n                k_plus_q_wrapped = wrap(k_plus_q)\n                \n                eps_k_plus_q = bilinear_interp(k_plus_q_wrapped, eps_table, N)\n                total_s += S_func(eps_k, eps_k_plus_q, alpha)\n        \n        return total_s / (N * N)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # N, q\n        (12, np.array([np.pi/3, 0.0])),         # Case A\n        (12, np.array([np.pi/5, 0.0])),         # Case B\n        (12, np.array([np.pi/5, 2*np.pi/5])),  # Case C\n        (12, np.array([0.0, 0.0])),             # Case D\n    ]\n\n    results = []\n    for N, q in test_cases:\n        # 1. Compute reference energy\n        E_ref = calc_E_ref(q, N_REF, T_HOP, ALPHA)\n        \n        # 2. Compute non-adaptive energy\n        E_na = calc_E_interp(q, N, T_HOP, ALPHA)\n\n        # 3. Compute adaptive energy\n        M = find_M(q, N, M_MAX, TAU)\n        E_ad = calc_E_interp(q, M, T_HOP, ALPHA)\n        \n        # 4. Compute error metrics\n        denom = max(abs(E_ref), 1e-12)\n        delta_na = abs(E_na - E_ref) / denom\n        delta_ad = abs(E_ad - E_ref) / denom\n        b_imp = delta_ad  delta_na\n        \n        results.append([delta_na, delta_ad, b_imp])\n\n    # Final print statement in the exact required format.\n    # Convert boolean to Python literal string 'True' or 'False'\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{str(r[2])}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "在非共线磁性的研究中，我们不仅需要寻找体系的基态，还常常需要研究或施加特定的磁构型，尤其是在处理阻挫系统或亚稳态时。本练习通过一个经典的Heisenberg模型，让您亲身体验约束计算的核心思想：使用拉格朗日乘子方法来精确地施加一个目标非共线磁序（例如三角形晶格上的 $120^\\circ$ 序）。您将实现一个迭代算法来求解这个约束问题，并学习如何通过评估残余转矩来衡量约束的收敛性 ()。",
            "id": "3468712",
            "problem": "在一个具有三个格点的三角形团簇上，使用拉格朗日乘子实现一个最小经典约束非共线自旋计算，以强制实现一个目标 $120^\\circ$ 自旋序。该系统由 $N=3$ 个经典自旋 $\\{\\mathbf{m}_i\\}_{i=1}^N$ 组成，每个自旋都是一个三维单位向量，代表格点 $i$ 处的局域磁化方向。这些自旋位于一个三角形上，因此每个格点都与另外两个格点作为最近邻相互作用。其物理模型是具有反铁磁交换耦合的经典各向同性海森堡模型。\n\n从以下基本定义开始：\n\n- 这个三角形上的经典海森堡能量（对于通用交换作用 $J$）为\n$$\nE_{\\text{ex}} = \\frac{J}{2}\\sum_{i=1}^{3}\\sum_{\\substack{j=1\\\\ j\\neq i}}^{3}\\mathbf{m}_i\\cdot\\mathbf{m}_j,\n$$\n其中 $J0$ 对应于反铁磁耦合，因子 $\\tfrac{1}{2}$ 用于避免对自旋对的双重计数。\n\n- 格点 $i$ 处的交换有效场定义为能量关于 $\\mathbf{m}_i$ 的负梯度，\n$$\n\\mathbf{B}_i^{\\text{ex}} = -\\frac{\\partial E_{\\text{ex}}}{\\partial \\mathbf{m}_i} = -J\\sum_{\\substack{j=1\\\\ j\\neq i}}^{3}\\mathbf{m}_j.\n$$\n\n为了强制实现一个目标非共线序，我们引入拉格朗日乘子 $\\boldsymbol{\\lambda}_i$，它与自旋相对于预设目标方向 $\\mathbf{m}_i^{(0)}$ 的偏差线性耦合。约束能量贡献为\n$$\nE_{\\lambda} = \\sum_{i=1}^{3}\\boldsymbol{\\lambda}_i\\cdot\\big(\\mathbf{m}_i - \\mathbf{m}_i^{(0)}\\big),\n$$\n由此产生一个约束场贡献\n$$\n\\mathbf{B}_i^{\\text{constr}} = -\\frac{\\partial E_{\\lambda}}{\\partial \\mathbf{m}_i} = -\\boldsymbol{\\lambda}_i.\n$$\n因此，总有效场为\n$$\n\\mathbf{B}_i^{\\text{eff}} = \\mathbf{B}_i^{\\text{ex}} + \\mathbf{B}_i^{\\text{constr}} = -J\\sum_{\\substack{j=1\\\\ j\\neq i}}^{3}\\mathbf{m}_j - \\boldsymbol{\\lambda}_i.\n$$\n\n三角形上的目标 $120^\\circ$ 自旋序由平面内的三个单位向量指定\n$$\n\\mathbf{m}_1^{(0)}=\\big(\\cos 0,\\sin 0,0\\big),\\quad\n\\mathbf{m}_2^{(0)}=\\big(\\cos (2\\pi/3),\\sin (2\\pi/3),0\\big),\\quad\n\\mathbf{m}_3^{(0)}=\\big(\\cos (4\\pi/3),\\sin (4\\pi/3),0\\big),\n$$\n所有角度均以弧度表示。自旋的初始条件是将整个目标图案在平面内均匀旋转角度 $\\phi_0$，即\n$$\n\\mathbf{m}_i^{(0,\\text{init})} = R_z(\\phi_0)\\,\\mathbf{m}_i^{(0)},\n$$\n其中 $R_z(\\phi)$ 是绕 $z$ 轴旋转角度 $\\phi$ 的旋转。初始拉格朗日乘子为 $\\boldsymbol{\\lambda}_i=\\mathbf{0}$。\n\n实现以下迭代原始-对偶方案，固定迭代次数为 $T$：\n\n1. 对每个格点 $i$，使用上述定义计算交换场 $\\mathbf{B}_i^{\\text{ex}}$ 和有效场 $\\mathbf{B}_i^{\\text{eff}}$。\n\n2. 通过向有效场方向进行带阻尼的对齐来更新自旋：\n$$\n\\tilde{\\mathbf{m}}_i = \n\\begin{cases}\n\\frac{\\mathbf{B}_i^{\\text{eff}}}{\\lVert \\mathbf{B}_i^{\\text{eff}}\\rVert},  \\text{if } \\lVert \\mathbf{B}_i^{\\text{eff}}\\rVert > \\varepsilon, \\\\\n\\mathbf{m}_i,  \\text{otherwise},\n\\end{cases}\n$$\n$$\n\\mathbf{m}_i \\leftarrow \\operatorname{normalize}\\Big((1-\\beta)\\,\\mathbf{m}_i + \\beta\\,\\tilde{\\mathbf{m}}_i\\Big),\n$$\n其中 $\\beta\\in(0,1]$ 是一个混合参数，$\\varepsilon0$ 是一个用于避免除以零的小阈值，并且 $\\operatorname{normalize}(\\mathbf{v})=\\mathbf{v}/\\lVert\\mathbf{v}\\rVert$。\n\n3. 对拉格朗日乘子执行一个对偶上升步，以强制执行约束：\n$$\n\\boldsymbol{\\lambda}_i \\leftarrow \\boldsymbol{\\lambda}_i + \\gamma\\left(\\mathbf{m}_i - \\mathbf{m}_i^{(0)}\\right),\n$$\n其中 $\\gamma0$ 是对偶步长。\n\n完成 $T$ 次迭代后，评估每个格点上的剩余力矩，\n$$\n\\boldsymbol{\\tau}_i = \\mathbf{m}_i \\times \\mathbf{B}_i^{\\text{eff}},\n$$\n并报告所有格点中范数的最大值，\n$$\n\\tau_{\\max} = \\max_{i\\in\\{1,2,3\\}}\\lVert \\boldsymbol{\\tau}_i\\rVert.\n$$\n\n角度单位：所有角度，包括初始旋转角 $\\phi_0$，都必须解释为弧度。在此无量纲设置中，自旋或力矩大小没有物理单位；请报告原始浮点数值。\n\n你的任务是编写一个完整、可运行的程序，实现上述方案，并为以下每个测试用例计算 $\\tau_{\\max}$（每个测试都是从其自身的初始条件开始的独立运行）：\n\n- 测试 1：$J=1.0$, $\\beta=0.55$, $\\gamma=0.8$, $T=800$, $\\phi_0=\\pi/12$。\n- 测试 2：$J=0.0$, $\\beta=0.55$, $\\gamma=0.8$, $T=400$, $\\phi_0=\\pi/6$。\n- 测试 3：$J=10.0$, $\\beta=0.35$, $\\gamma=0.5$, $T=1200$, $\\phi_0=\\pi/18$。\n\n实现细节：\n\n- 使用如上定义的目标方向 $\\mathbf{m}_i^{(0)}$。\n- 对于每个测试用例，通过将 $\\mathbf{m}_i^{(0)}$ 绕 $z$ 轴旋转 $\\phi_0$ 来初始化 $\\mathbf{m}_i$。\n- 对所有 $i$ 初始化 $\\boldsymbol{\\lambda}_i=\\mathbf{0}$。\n- 在对齐步骤中使用小阈值 $\\varepsilon=10^{-12}$。\n- 在每次迭代中，保持所有自旋归一化为单位长度。\n\n要求的最终输出格式：你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，结果顺序与上述测试的顺序一致。每个数字必须格式化为小数点后恰好六位。例如，包含三个结果的输出应如下所示\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3],\n$$\n其中每个 $\\text{result}_k$ 是一个小数点后恰好有六位数字的十进制字符串。输出必须是三个测试的 $\\tau_{\\max}$ 值。",
            "solution": "用户提供的问题已被分析，并根据指定标准被认为是有效的。该问题在科学上是合理的、适定的、客观的，并包含了一个确定性解所需的所有必要信息。\n\n该问题要求实现一个原始-对偶迭代算法，以找到三格点三角形团簇上经典海森堡模型的约束基态。其目标是使用拉格朗日乘子法强制实现一个特定的 $120^\\circ$ 非共线自旋构型。该求解过程涉及迭代更新自旋向量（原始变量）和拉格朗日乘子（对偶变量），直到系统接近静态平衡。\n\n系统的总能量（包括约束）由一个拉格朗日泛函 $L$ 描述：\n$$\nL(\\{\\mathbf{m}_i\\}, \\{\\boldsymbol{\\lambda}_i\\}) = E_{\\text{ex}}(\\{\\mathbf{m}_i\\}) + E_{\\lambda}(\\{\\mathbf{m}_i\\}, \\{\\boldsymbol{\\lambda}_i\\}) = \\frac{J}{2}\\sum_{i=1}^{3}\\sum_{\\substack{j=1\\\\ j\\neq i}}^{3}\\mathbf{m}_i\\cdot\\mathbf{m}_j + \\sum_{i=1}^{3}\\boldsymbol{\\lambda}_i\\cdot\\big(\\mathbf{m}_i - \\mathbf{m}_i^{(0)}\\big)\n$$\n在这里，$\\{\\mathbf{m}_i\\}_{i=1}^3$ 是单位长度的经典自旋向量，$J$ 是交换耦合常数，$\\{\\mathbf{m}_i^{(0)}\\}_{i=1}^3$ 是目标自旋方向，$\\{\\boldsymbol{\\lambda}_i\\}_{i=1}^3$ 是拉格朗日乘子。解对应于此拉格朗日量的鞍点，在该鞍点处，泛函关于原始变量 $\\mathbf{m}_i$ 取最小值，而关于对偶变量 $\\boldsymbol{\\lambda}_i$ 取最大值。\n\n所描述的迭代算法是解决此类鞍点问题的标准方法。它包含在每次迭代中执行的两个主要步骤：原始更新（对自旋进行梯度下降）和对偶更新（对乘子进行梯度上升）。\n\n**1. 原始步骤：自旋更新**\n\n在有效磁场的影响下，自旋被更新以降低系统能量。这个有效场 $\\mathbf{B}_i^{\\text{eff}}$ 是拉格朗日量关于自旋向量 $\\mathbf{m}_i$ 的负梯度：\n$$\n\\mathbf{B}_i^{\\text{eff}} = -\\frac{\\partial L}{\\partial \\mathbf{m}_i} = -\\frac{\\partial E_{\\text{ex}}}{\\partial \\mathbf{m}_i} - \\frac{\\partial E_{\\lambda}}{\\partial \\mathbf{m}_i} = \\mathbf{B}_i^{\\text{ex}} + \\mathbf{B}_i^{\\text{constr}}\n$$\n其中 $\\mathbf{B}_i^{\\text{ex}} = -J\\sum_{j \\neq i} \\mathbf{m}_j$ 是来自相邻自旋的交换场，$\\mathbf{B}_i^{\\text{constr}} = -\\boldsymbol{\\lambda}_i$ 是来自拉格朗日乘子的约束场。\n\n自旋更新通过朝着此有效场方向的带阻尼对齐来执行。首先，确定目标方向：\n$$\n\\tilde{\\mathbf{m}}_i = \\frac{\\mathbf{B}_i^{\\text{eff}}}{\\lVert \\mathbf{B}_i^{\\text{eff}}\\rVert}\n$$\n如果 $\\mathbf{B}_i^{\\text{eff}}$ 接近于零，则使用一个微小阈值 $\\varepsilon$ 来防止除以零。然后，使用混合方案更新自旋：\n$$\n\\mathbf{m}_i \\leftarrow \\operatorname{normalize}\\Big((1-\\beta)\\,\\mathbf{m}_i + \\beta\\,\\tilde{\\mathbf{m}}_i\\Big)\n$$\n参数 $\\beta \\in (0,1]$ 是一个控制更新步长以确保稳定性的混合因子。`normalize` 操作对于强制执行自旋向量的单位长度约束 $\\lVert\\mathbf{m}_i\\rVert=1$至关重要。此步骤对应于在单位向量流形上的梯度下降。\n\n**2. 对偶步骤：拉格朗日乘子更新**\n\n更新拉格朗日乘子以强制执行约束 $\\mathbf{m}_i = \\mathbf{m}_i^{(0)}$。这是通过对对偶变量的梯度上升步来实现的：\n$$\n\\boldsymbol{\\lambda}_i \\leftarrow \\boldsymbol{\\lambda}_i + \\gamma\\left(\\mathbf{m}_i - \\mathbf{m}_i^{(0)}\\right)\n$$\n在这里，$\\gamma  0$ 是一个步长参数。更新将 $\\boldsymbol{\\lambda}_i$ 推向约束违反的方向 $(\\mathbf{m}_i - \\mathbf{m}_i^{(0)})$。在下一次迭代中，$\\boldsymbol{\\lambda}_i$ 的这种变化会修改约束场 $\\mathbf{B}_i^{\\text{constr}}$，施加一个修正“力”，从而驱动自旋 $\\mathbf{m}_i$ 更接近其目标 $\\mathbf{m}_i^{(0)}$。\n\n**3. 收敛性和最终输出**\n\n迭代过程重复固定的步数 $T$。静态平衡的特征是每个自旋上的力矩为零，即 $\\boldsymbol{\\tau}_i = \\mathbf{m}_i \\times \\mathbf{B}_i^{\\text{eff}} = \\mathbf{0}$，这种情况发生在每个自旋都与其有效场平行时。要报告的量 $\\tau_{\\max} = \\max_i \\lVert\\boldsymbol{\\tau}_i\\rVert$ 作为一种度量，衡量系统在 $T$ 次迭代后距离此平衡态有多近。\n\n实现将首先根据给定的旋转角 $\\phi_0$ 初始化自旋，并将拉格朗日乘子初始化为零。然后，在一个循环中执行 $T$ 步的原始和对偶更新。最后，计算并报告最大剩余力矩范数。向量运算将使用 `numpy` 库来处理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a primal-dual scheme for a constrained classical Heisenberg model\n    on a 3-site triangular cluster and computes the maximum residual torque for\n    three different test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (J, beta, gamma, T, phi0)\n    test_cases = [\n        (1.0, 0.55, 0.8, 800, np.pi / 12.0),\n        (0.0, 0.55, 0.8, 400, np.pi / 6.0),\n        (10.0, 0.35, 0.5, 1200, np.pi / 18.0),\n    ]\n\n    # Small threshold for numerical stability\n    epsilon = 1e-12\n    \n    results = []\n\n    # Define the target 120-degree spin order in the xy-plane.\n    m_target = np.array([\n        [np.cos(0.0), np.sin(0.0), 0.0],\n        [np.cos(2.0 * np.pi / 3.0), np.sin(2.0 * np.pi / 3.0), 0.0],\n        [np.cos(4.0 * np.pi / 3.0), np.sin(4.0 * np.pi / 3.0), 0.0]\n    ])\n\n    for J, beta, gamma, T, phi0 in test_cases:\n        # ----- Initialization for the current test case -----\n        \n        # Initialize spins m_i by rotating the target pattern by phi0 around the z-axis.\n        c, s = np.cos(phi0), np.sin(phi0)\n        Rz = np.array([[c, -s, 0.0], [s, c, 0.0], [0.0, 0.0, 1.0]])\n        # m is a (3, 3) array where m[i] is the spin vector for site i.\n        m = (Rz @ m_target.T).T\n        \n        # Initialize Lagrange multipliers lambda_i to zero.\n        # lam is a (3, 3) array where lam[i] is the lambda vector for site i.\n        lam = np.zeros_like(m)\n\n        # ----- Iterative Primal-Dual Scheme -----\n        for _ in range(T):\n            m_old = m.copy()\n            m_new = np.zeros_like(m)\n\n            # Primal step: Update spins m_i for all sites i=0,1,2.\n            # This is done using the spin configuration from the previous step (m_old).\n            for i in range(3):\n                # Sum of neighboring spins for site i\n                m_neighbors_sum = np.sum(m_old, axis=0) - m_old[i]\n                \n                # Exchange field\n                B_ex_i = -J * m_neighbors_sum\n                \n                # Effective field (includes constraining field -lambda_i)\n                B_eff_i = B_ex_i - lam[i]\n                \n                norm_B_eff = np.linalg.norm(B_eff_i)\n                \n                # Determine target direction for alignment\n                if norm_B_eff > epsilon:\n                    m_tilde_i = B_eff_i / norm_B_eff\n                else:\n                    m_tilde_i = m_old[i]\n                \n                # Damped update with mixing parameter beta\n                m_mixed = (1.0 - beta) * m_old[i] + beta * m_tilde_i\n                \n                # Normalize to maintain unit spin length\n                norm_m_mixed = np.linalg.norm(m_mixed)\n                if norm_m_mixed > epsilon:\n                    m_new[i] = m_mixed / norm_m_mixed\n                else:\n                    m_new[i] = m_old[i] # Should not happen with beta > 0\n            \n            # Atomically update the spins for the next step\n            m = m_new\n\n            # Dual step: Update Lagrange multipliers lambda_i.\n            # This uses the newly computed spins 'm' to calculate the constraint violation.\n            lam += gamma * (m - m_target)\n\n        # ----- Final Calculation: Residual Torques -----\n        \n        tau_norms = []\n        for i in range(3):\n            # Recalculate the final effective field for each site\n            m_neighbors_sum = np.sum(m, axis=0) - m[i]\n            B_ex_i = -J * m_neighbors_sum\n            B_eff_i = B_ex_i - lam[i]\n            \n            # Calculate the torque tau_i = m_i x B_eff_i\n            tau_i = np.cross(m[i], B_eff_i)\n            \n            # Store the norm of the torque vector\n            tau_norms.append(np.linalg.norm(tau_i))\n            \n        # Find the maximum torque norm across all three sites\n        tau_max = np.max(tau_norms)\n        results.append(tau_max)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}