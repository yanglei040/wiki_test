{
    "hands_on_practices": [
        {
            "introduction": "在数值计算中，布洛赫波函数的相位具有任意性，这被称为规范自由度。虽然最终的物理可观测量（如反常霍尔电导率）是规范不变的，但计算过程中的中间量（如贝里联络）却依赖于规范的选择。本练习  将通过比较一种规范依赖的有限差分方法和一种规范不变的格点Wilson圈方法，来深刻揭示这一问题，并展示如何稳健地计算贝里曲率和陈数。",
            "id": "3433169",
            "problem": "要求你编写一个完整的、可运行的程序，分析在二维双带紧束缚模型中，瓦尼尔规范（Wannier gauge）的选择如何影响计算出的贝里曲率 $ \\Omega_{z}(\\mathbf{k}) $ 和反常霍尔电导率 $ \\sigma_{xy} $。该分析必须通过比较模拟不同投影集的不同规范固定策略，并量化一个离散光滑度度量来执行。你的程序必须实现两种贝里曲率的数值估计量：一个规范依赖的有限差分估计量和一个规范不变的格点链路变量估计量，然后计算每种估计量在不同规范选择下的 $ \\sigma_{xy} $ 的方差。所有布里渊区角度必须以弧度处理，最终的 $ \\sigma_{xy} $ 必须以 $ e^{2}/h $ 为单位返回，并约定 $ e = h = 1 $（因此是无量纲的）。\n\n物理模型是方格上的祁-吴-张（Qi–Wu–Zhang）双带陈绝缘体。布洛赫哈密顿量为\n$$\nH(\\mathbf{k}) = d_{x}(\\mathbf{k})\\,\\sigma_{x} + d_{y}(\\mathbf{k})\\,\\sigma_{y} + d_{z}(\\mathbf{k})\\,\\sigma_{z},\n$$\n其中泡利矩阵为 $ \\sigma_{x},\\sigma_{y},\\sigma_{z} $，且\n$$\nd_{x}(\\mathbf{k}) = \\sin(k_{x}), \\quad d_{y}(\\mathbf{k}) = \\sin(k_{y}), \\quad d_{z}(\\mathbf{k}) = m + \\cos(k_{x}) + \\cos(k_{y}).\n$$\n布里渊区为 $ k_{x},k_{y} \\in [-\\pi,\\pi) $。低能带是占据带。使用一个均匀的 $ N \\times N $ 网格，其中\n$$\nk_{x}(i) = -\\pi + \\frac{2\\pi}{N}\\,i, \\quad k_{y}(j) = -\\pi + \\frac{2\\pi}{N}\\,j, \\quad i,j \\in \\{0,1,\\dots,N-1\\},\n$$\n并采用周期性边界条件。记 $ \\delta k = 2\\pi/N $。\n\n规范选择。设 $ | u(\\mathbf{k})\\rangle $ 是在 $ \\mathbf{k} $ 处归一化的占据带本征矢量。通过首先用一个投影集固定相位，然后施加一个确定的、依赖于 $ \\mathbf{k} $ 的相位来构造三种类瓦尼尔规范。对于规范指数 $ g \\in \\{0,1,2\\} $，定义投影自旋量\n$$\n\\lvert p_{0}\\rangle = \\begin{pmatrix}1\\\\0\\end{pmatrix}, \\quad\n\\lvert p_{1}\\rangle = \\begin{pmatrix}0\\\\1\\end{pmatrix}, \\quad\n\\lvert p_{2}\\rangle = \\frac{1}{\\sqrt{2}}\\begin{pmatrix}1\\\\ e^{i\\pi/3}\\end{pmatrix}.\n$$\n在每个 $ \\mathbf{k} $ 点，通过一个补偿性的 $ U(1) $ 相位乘法强制 $ \\arg\\langle p_{g}\\vert u(\\mathbf{k})\\rangle = 0 $ 和 $ \\langle p_{g}\\vert u(\\mathbf{k})\\rangle \\ge 0 $，从而定义相位固定的本征矢量 $ \\lvert \\tilde{u}_{g}(\\mathbf{k})\\rangle $。然后施加一个额外的光滑相位场 $ \\phi_{g}(\\mathbf{k}) $ 并设置\n$$\n\\lvert u_{g}(\\mathbf{k})\\rangle = e^{i\\phi_{g}(\\mathbf{k})}\\,\\lvert \\tilde{u}_{g}(\\mathbf{k})\\rangle.\n$$\n这些相位场是确定性给出的\n$$\n\\phi_{0}(\\mathbf{k}) = 0, \\quad \\phi_{1}(\\mathbf{k}) = \\alpha_{1}\\,\\Big(\\sin(k_{x}) + \\tfrac{1}{2}\\cos(k_{y})\\Big), \\quad \\phi_{2}(\\mathbf{k}) = \\alpha_{2}\\,\\sin(2k_{x})\\sin(2k_{y}),\n$$\n其振幅 $ \\alpha_{1} $ 和 $ \\alpha_{2} $ 由每个测试用例指定，而 $ \\alpha_{0} = 0 $。\n\n光滑度度量。对于每个规范 $ g $，定义离散光滑度度量\n$$\nS_{g} = \\frac{1}{2N^{2}} \\sum_{i,j} \\sum_{\\mu \\in \\{x,y\\}} \\Big(1 - \\big|\\langle u_{g}(k_{x}(i),k_{y}(j)) \\vert u_{g}(k_{x}(i)+\\delta k\\,\\delta_{\\mu,x}, k_{y}(j)+\\delta k\\,\\delta_{\\mu,y}) \\rangle \\big| \\Big),\n$$\n采用周期性边界条件。较小的 $ S_{g} $ 意味着更光滑的规范。\n\n贝里曲率估计量。实现以下两者：\n- 规范依赖的有限差分估计量。首先近似贝里联络分量\n$$\nA_{\\mu}^{(g)}(\\mathbf{k}) = i\\,\\langle u_{g}(\\mathbf{k})\\vert \\partial_{k_{\\mu}} u_{g}(\\mathbf{k})\\rangle,\n$$\n使用中心差分\n$$\n\\partial_{k_{\\mu}} \\lvert u_{g}(\\mathbf{k})\\rangle \\approx \\frac{\\lvert u_{g}(\\mathbf{k}+\\delta k\\,\\hat{\\mu})\\rangle - \\lvert u_{g}(\\mathbf{k}-\\delta k\\,\\hat{\\mu})\\rangle}{2\\delta k},\n$$\n然后近似计算\n$$\n\\Omega_{z,\\text{FD}}^{(g)}(\\mathbf{k}) = \\partial_{k_{x}} A_{y}^{(g)}(\\mathbf{k}) - \\partial_{k_{y}} A_{x}^{(g)}(\\mathbf{k}),\n$$\n同样在网格上使用中心差分。有限差分反常霍尔电导率为\n$$\n\\sigma_{xy,\\text{FD}}^{(g)} = \\frac{1}{2\\pi} \\sum_{i,j} \\Omega_{z,\\text{FD}}^{(g)}(k_{x}(i),k_{y}(j))\\,(\\delta k)^{2},\n$$\n以 $ e^{2}/h $ 为单位表示，其中 $ e = h = 1 $。\n- 规范不变的格点链路变量估计量。定义链路变量\n$$\nU_{\\mu}^{(g)}(\\mathbf{k}) = \\frac{\\langle u_{g}(\\mathbf{k})\\vert u_{g}(\\mathbf{k}+\\delta k\\,\\hat{\\mu})\\rangle}{\\big|\\langle u_{g}(\\mathbf{k})\\vert u_{g}(\\mathbf{k}+\\delta k\\,\\hat{\\mu})\\rangle\\big|},\n$$\n以及每个格框上的格点场强\n$$\nF^{(g)}(\\mathbf{k}) = \\arg\\Big[ U_{x}^{(g)}(\\mathbf{k})\\,U_{y}^{(g)}(\\mathbf{k}+\\delta k\\,\\hat{x})\\,\\big(U_{x}^{(g)}(\\mathbf{k}+\\delta k\\,\\hat{y})\\big)^{-1}\\,\\big(U_{y}^{(g)}(\\mathbf{k})\\big)^{-1} \\Big],\n$$\n其中 $ \\arg $ 返回在 $ (-\\pi,\\pi] $ 内的主值。相应的电导率为\n$$\n\\sigma_{xy,\\text{LI}}^{(g)} = \\frac{1}{2\\pi} \\sum_{\\text{plaquettes}} F^{(g)}(\\mathbf{k}),\n$$\n同样以 $ e^{2}/h $ 为单位。\n\n规范间方差。对于每种估计量类型 $ E \\in \\{\\text{FD},\\text{LI}\\} $ 和每个测试用例，计算三种规范 $ g \\in \\{0,1,2\\} $ 的总体方差，\n$$\n\\mathrm{Var}_{E} = \\frac{1}{3} \\sum_{g=0}^{2} \\Big(\\sigma_{xy,E}^{(g)} - \\overline{\\sigma}_{xy,E}\\Big)^{2}, \\quad \\overline{\\sigma}_{xy,E} = \\frac{1}{3}\\sum_{g=0}^{2} \\sigma_{xy,E}^{(g)}.\n$$\n\n测试套件。你的程序必须精确评估以下四个测试用例，每个用例由 $ (m,N,\\alpha_{1},\\alpha_{2}) $ 指定：\n- 用例 1（正常路径，拓扑）：$ m = -1.0 $，$ N = 25 $，$ \\alpha_{1} = 0.5 $，$ \\alpha_{2} = 1.5 $。\n- 用例 2（接近相变边界）：$ m = -1.9 $，$ N = 25 $，$ \\alpha_{1} = 1.0 $，$ \\alpha_{2} = 2.0 $。\n- 用例 3（平庸绝缘体）：$ m = 0.5 $，$ N = 25 $，$ \\alpha_{1} = 0.5 $，$ \\alpha_{2} = 1.5 $。\n- 用例 4（粗网格压力测试）：$ m = -1.0 $，$ N = 9 $，$ \\alpha_{1} = 2.0 $，$ \\alpha_{2} = 4.0 $。\n\n所需输出。对于每个测试用例，生成一个包含 5 个浮点数的列表：\n- 三种规范间的方差 $ \\mathrm{Var}_{\\text{FD}} $。\n- 三种规范间的方差 $ \\mathrm{Var}_{\\text{LI}} $。\n- 三个光滑度度量 $ S_{0}, S_{1}, S_{2} $。\n\n最终输出格式。你的程序应生成单行输出，包含每个用例的列表所组成的列表，格式需完全符合：\n$$\n\\big[ [v_{1}^{\\text{FD}},v_{1}^{\\text{LI}},S_{1,0},S_{1,1},S_{1,2}], [v_{2}^{\\text{FD}},v_{2}^{\\text{LI}},S_{2,0},S_{2,1},S_{2,2}], [v_{3}^{\\text{FD}},v_{3}^{\\text{LI}},S_{3,0},S_{3,1},S_{3,2}], [v_{4}^{\\text{FD}},v_{4}^{\\text{LI}},S_{4,0},S_{4,1},S_{4,2}] \\big],\n$$\n不含任何额外文本。所有 $ \\sigma_{xy} $ 值必须表示为以 $ e^{2}/h $ 为单位的无量纲数，其中 $ e = h = 1 $。所有角度均以弧度为单位。必须严格使用上面给出的总体方差定义。你的程序不得读取任何输入。",
            "solution": "该问题要求对一个双带紧束缚模型中，规范依赖效应对反常霍尔电导率 (AHC) 计算的影响进行数值分析。该分析涉及在三种不同的规范选择下，实现并比较两种不同的 AHC 数值估计量。解决方案是按照所提供的物理原理和数学定义，通过一系列步骤构建的。\n\n首先，我们建立计算环境。物理系统，即祁-吴-张模型，定义在二维方格上，这对应于一个离散化的布里渊区 (BZ)。对于给定的网格大小 $N$，我们构造一个均匀的 $N \\times N$ 动量矢量 $\\mathbf{k} = (k_x, k_y)$ 网格。动量定义为 $k_{x}(i) = -\\pi + \\frac{2\\pi}{N}\\,i$ 和 $k_{y}(j) = -\\pi + \\frac{2\\pi}{N}\\,j$，其中 $i,j \\in \\{0,1,\\dots,N-1\\}$。网格间距为 $\\delta k = 2\\pi/N$。\n\n计算的核心是布洛赫哈密顿量，$H(\\mathbf{k}) = \\mathbf{d}(\\mathbf{k}) \\cdot \\boldsymbol{\\sigma}$，其中 $\\boldsymbol{\\sigma} = (\\sigma_x, \\sigma_y, \\sigma_z)$ 是泡利矩阵的矢量，$\\mathbf{d}(\\mathbf{k}) = (\\sin(k_{x}), \\sin(k_{y}), m + \\cos(k_{x}) + \\cos(k_{y}))$。对于网格上的每个点 $\\mathbf{k}$，我们构造这个 $2 \\times 2$ 的厄米矩阵。\n\n下一步是确定被占据的电子态。我们在每个 $\\mathbf{k}$ 点求解本征值问题 $H(\\mathbf{k})\\lvert u(\\mathbf{k}) \\rangle = E(\\mathbf{k})\\lvert u(\\mathbf{k}) \\rangle$。这通过一个稳健且高效的数值线性代数程序（具体为 `numpy.linalg.eigh`）来完成。该哈密顿量有两个能带，本征值为 $E_\\pm(\\mathbf{k}) = \\pm |\\mathbf{d}(\\mathbf{k})|$。问题指定能量为 $E_-(\\mathbf{k}) = -|\\mathbf{d}(\\mathbf{k})|$ 的低能带是被占据的能带。我们提取相应的归一化本征矢量，记为 $\\lvert u_{\\text{raw}}(\\mathbf{k}) \\rangle$。对角化程序的输出对每个本征矢量都有一个任意的相位，这就是待研究的规范自由度的来源。\n\n然后，我们实现三种指定的规范固定程序，用 $g \\in \\{0,1,2\\}$ 索引。每个程序包括两个步骤。首先，通过将原始本征矢量 $\\lvert u_{\\text{raw}}(\\mathbf{k})\\rangle$ 投影到一个恒定的参考自旋量 $\\lvert p_g \\rangle$ 上来固定初始相位。三个投影自旋量是 $\\lvert p_{0}\\rangle = (1,0)^T$，$\\lvert p_{1}\\rangle = (0,1)^T$，和 $\\lvert p_{2}\\rangle = (1/\\sqrt{2})(1, e^{i\\pi/3})^T$。对于每个 $\\mathbf{k}$，我们计算投影交叠 $c_g(\\mathbf{k}) = \\langle p_g \\vert u_{\\text{raw}}(\\mathbf{k}) \\rangle$。然后，我们将 $\\lvert u_{\\text{raw}}(\\mathbf{k}) \\rangle$ 乘以一个补偿相位因子 $e^{-i\\arg(c_g(\\mathbf{k}))}$，以获得相位固定的态 $\\lvert \\tilde{u}_g(\\mathbf{k}) \\rangle$。这强制了交叠 $\\langle p_g \\vert \\tilde{u}_g(\\mathbf{k}) \\rangle$ 为实数且非负的条件。其次，施加一个额外的、依赖于k的光滑相位场 $\\phi_g(\\mathbf{k})$，得到最终的规范化本征矢量 $\\lvert u_{g}(\\mathbf{k})\\rangle = e^{i\\phi_{g}(\\mathbf{k})}\\,\\lvert \\tilde{u}_{g}(\\mathbf{k})\\rangle$。相位场为 $\\phi_{0}(\\mathbf{k}) = 0$，$\\phi_{1}(\\mathbf{k}) = \\alpha_{1}(\\sin(k_{x}) + \\frac{1}{2}\\cos(k_{y}))$，以及 $\\phi_{2}(\\mathbf{k}) = \\alpha_{2}\\sin(2k_{x})\\sin(2k_{y})$。对三种规范中的每一种都重复整个过程。\n\n对于每个 $g$，得到规范化本征矢量的网格 $\\lvert u_g(\\mathbf{k}) \\rangle$ 后，我们继续计算所需的量。\n\n每个规范的光滑度由度量 $S_g$ 来量化。该度量涉及计算相邻k点处本征矢量之间的内积（交叠）的模，即 $\\langle u_g(\\mathbf{k}) \\vert u_g(\\mathbf{k}+\\delta k\\,\\hat{\\mu}) \\rangle$，对两个方向 $\\mu \\in \\{x,y\\}$ 都进行计算。该计算使用 `numpy.roll` 进行矢量化，以高效地访问具有周期性边界条件的相邻网格点。公式 $S_{g} = \\frac{1}{2N^{2}} \\sum_{i,j} \\sum_{\\mu \\in \\{x,y\\}} (1 - |\\langle u_{g}(\\mathbf{k}) \\vert u_{g}(\\mathbf{k}') \\rangle |)$ 是通过对整个网格上的局域项求和来实现的。\n\n接下来，实现两种用于 AHC $\\sigma_{xy}$ 的估计量。\n第一种是规范依赖的有限差分 (FD) 估计量。此方法近似了贝里曲率的连续谱公式 $\\Omega_z = \\partial_{k_x} A_y - \\partial_{k_y} A_x$，其中 $A_\\mu = i\\langle u|\\partial_{k_\\mu} u \\rangle$ 是贝里联络。我们首先计算贝里联络的分量 $A_x^{(g)}(\\mathbf{k})$ 和 $A_y^{(g)}(\\mathbf{k})$，方法是用中心有限差分近似替换导数 $\\partial_{k_\\mu} \\lvert u_{g}(\\mathbf{k})\\rangle$。这涉及在相应方向上 $\\pm \\delta k$ 的位移。随后，我们通过对计算出的联络场 $A_{x}^{(g)}$ 和 $A_{y}^{(g)}$ 应用另一个中心有限差分近似来计算贝里曲率 $\\Omega_{z,\\text{FD}}^{(g)}(\\mathbf{k})$。最后，AHC 通过对所有网格点上的曲率求和并乘以面积元得到：$\\sigma_{xy,\\text{FD}}^{(g)} = \\frac{1}{2\\pi} \\sum_{\\mathbf{k}} \\Omega_{z,\\text{FD}}^{(g)}(\\mathbf{k}) (\\delta k)^2$。\n\n第二种是规范不变的格点链路变量 (LI) 估计量。此方法基于计算格框通量，这是场强的离散类比。我们首先定义链路变量 $U_{\\mu}^{(g)}(\\mathbf{k}) = \\frac{\\langle u_{g}(\\mathbf{k})\\vert u_{g}(\\mathbf{k}+\\delta k\\,\\hat{\\mu})\\rangle}{|\\langle u_{g}(\\mathbf{k})\\vert u_{g}(\\mathbf{k}+\\delta k\\,\\hat{\\mu})\\rangle|}$，对于 $\\mu \\in \\{x,y\\}$。这些是单位模长的复数。然后，格点场强 $F^{(g)}(\\mathbf{k})$ 被计算为格框乘积 $U_x^{(g)}(\\mathbf{k}) U_y^{(g)}(\\mathbf{k}+\\delta k \\hat{x}) (U_x^{(g)}(\\mathbf{k}+\\delta k \\hat{y}))^{-1} (U_y^{(g)}(\\mathbf{k}))^{-1}$ 的相位。`numpy.angle` 函数用于获取辐角的主值。AHC 则是这些场强在 BZ 中所有格框上的总和，再乘以 $1/(2\\pi)$：$\\sigma_{xy,\\text{LI}}^{(g)} = \\frac{1}{2\\pi} \\sum_{\\mathbf{k}} F^{(g)}(\\mathbf{k})$。该公式被明确设计为在在位规范变换 $e^{i\\phi_g(\\mathbf{k})}$ 下保持不变。\n\n在为三种规范（$g=0,1,2$）中的每一种计算出 AHC 值 $\\sigma_{xy, \\text{FD}}^{(g)}$ 和 $\\sigma_{xy, \\text{LI}}^{(g)}$ 之后，我们计算每种估计量类型在不同规范间的方差。如问题所定义，计算总体方差：$\\mathrm{Var}_{E} = \\frac{1}{3} \\sum_{g=0}^{2} (\\sigma_{xy,E}^{(g)} - \\overline{\\sigma}_{xy,E})^{2}$，其中 $\\overline{\\sigma}_{xy,E}$ 是三种规范的平均值。这对 $E=\\text{FD}$ 和 $E=\\text{LI}$ 都进行计算。\n\n这整个计算工作流被封装在一个函数中，该函数接受测试用例参数 $(m, N, \\alpha_1, \\alpha_2)$ 作为输入，并返回一个包含两个方差和三个光滑度度量的列表：$[\\mathrm{Var}_{\\text{FD}}, \\mathrm{Var}_{\\text{LI}}, S_0, S_1, S_2]$。一个主脚本遍历四个指定的测试用例，为每个用例调用此函数，并将结果收集到一个嵌套列表中，然后以所需格式打印出来。",
            "answer": "```python\nimport numpy as np\n\ndef compute_case_results(m, N, alpha1, alpha2):\n    \"\"\"\n    Performs the full analysis for a single test case.\n    Returns a list containing [Var_FD, Var_LI, S_0, S_1, S_2].\n    \"\"\"\n    # 1. Setup grid and Hamiltonian\n    dk = 2 * np.pi / N\n    k_vals = -np.pi + dk * np.arange(N)\n    Kx, Ky = np.meshgrid(k_vals, k_vals, indexing='ij')\n\n    sigma_x = np.array([[0, 1], [1, 0]], dtype=complex)\n    sigma_y = np.array([[0, -1j], [1j, 0]], dtype=complex)\n    sigma_z = np.array([[1, 0], [0, -1]], dtype=complex)\n\n    d_x = np.sin(Kx)\n    d_y = np.sin(Ky)\n    d_z = m + np.cos(Kx) + np.cos(Ky)\n\n    H_k = d_x[..., np.newaxis, np.newaxis] * sigma_x + \\\n          d_y[..., np.newaxis, np.newaxis] * sigma_y + \\\n          d_z[..., np.newaxis, np.newaxis] * sigma_z\n          \n    # 2. Diagonalize H(k) to get eigenvectors for the lower band\n    _, eigvecs = np.linalg.eigh(H_k)\n    u_raw = eigvecs[..., :, 0]\n\n    # 3. Define gauges\n    p_g_list = [\n        np.array([1, 0], dtype=complex),\n        np.array([0, 1], dtype=complex),\n        1/np.sqrt(2) * np.array([1, np.exp(1j * np.pi / 3)], dtype=complex)\n    ]\n    phi_g_list = [\n        np.zeros((N, N), dtype=float),\n        alpha1 * (np.sin(Kx) + 0.5 * np.cos(Ky)),\n        alpha2 * np.sin(2 * Kx) * np.sin(2 * Ky)\n    ]\n\n    sigmas_fd = []\n    sigmas_li = []\n    smoothness_metrics = []\n\n    # 4. Loop over three gauges\n    for g in range(3):\n        # --- Gauge Fixing ---\n        p_g = p_g_list[g]\n        phi_g = phi_g_list[g]\n        \n        c_g_k = np.einsum('i,kji->kj', p_g.conj(), u_raw)\n        correction_phase = np.exp(-1j * np.angle(c_g_k))\n        u_tilde_g = u_raw * correction_phase[..., np.newaxis]\n        u_g = u_tilde_g * np.exp(1j * phi_g)[..., np.newaxis]\n\n        # --- Smoothness Metric S_g ---\n        overlap_x = np.einsum('ijk,ijk->ij', u_g.conj(), np.roll(u_g, -1, axis=0))\n        overlap_y = np.einsum('ijk,ijk->ij', u_g.conj(), np.roll(u_g, -1, axis=1))\n        S_g = (1.0 / (2 * N**2)) * np.sum((1 - np.abs(overlap_x)) + (1 - np.abs(overlap_y)))\n        smoothness_metrics.append(S_g)\n\n        u_g_xp1 = np.roll(u_g, -1, axis=0)\n        u_g_xm1 = np.roll(u_g, 1, axis=0)\n        u_g_yp1 = np.roll(u_g, -1, axis=1)\n        u_g_ym1 = np.roll(u_g, 1, axis=1)\n\n        # --- FD Estimator ---\n        du_dx = (u_g_xp1 - u_g_xm1) / (2 * dk)\n        du_dy = (u_g_yp1 - u_g_ym1) / (2 * dk)\n\n        A_x = 1j * np.einsum('ijk,ijk->ij', u_g.conj(), du_dx)\n        A_y = 1j * np.einsum('ijk,ijk->ij', u_g.conj(), du_dy)\n        \n        dA_y_dx = (np.roll(A_y, -1, axis=0) - np.roll(A_y, 1, axis=0)) / (2 * dk)\n        dA_x_dy = (np.roll(A_x, -1, axis=1) - np.roll(A_x, 1, axis=1)) / (2 * dk)\n\n        Omega_z_fd = dA_y_dx - dA_x_dy\n        sigma_fd = (1 / (2 * np.pi)) * np.sum(Omega_z_fd.real) * dk**2\n        sigmas_fd.append(sigma_fd)\n\n        # --- LI Estimator ---\n        U_x = np.einsum('ijk,ijk->ij', u_g.conj(), u_g_xp1)\n        U_x /= np.abs(U_x)\n        U_y = np.einsum('ijk,ijk->ij', u_g.conj(), u_g_yp1)\n        U_y /= np.abs(U_y)\n        \n        U_x_shifted_y = np.roll(U_x, -1, axis=1)\n        U_y_shifted_x = np.roll(U_y, -1, axis=0)\n\n        F_k = np.angle(U_x * U_y_shifted_x * np.conj(U_x_shifted_y) * np.conj(U_y))\n        sigma_li = (1 / (2 * np.pi)) * np.sum(F_k)\n        sigmas_li.append(sigma_li)\n\n    # 5. Calculate variance\n    var_fd = np.var(sigmas_fd, ddof=0)\n    var_li = np.var(sigmas_li, ddof=0)\n    \n    return [var_fd, var_li, smoothness_metrics[0], smoothness_metrics[1], smoothness_metrics[2]]\n\ndef main():\n    \"\"\"\n    Main execution function to run all test cases and print results.\n    \"\"\"\n    test_suite = [\n        (-1.0, 25, 0.5, 1.5),\n        (-1.9, 25, 1.0, 2.0),\n        (0.5, 25, 0.5, 1.5),\n        (-1.0, 9, 2.0, 4.0),\n    ]\n    \n    all_results = [compute_case_results(*params) for params in test_suite]\n    \n    # Format the output string as a list of lists, without spaces.\n    print(str(all_results).replace(\" \", \"\"))\n\nif __name__ == '__main__':\n    main()\n```"
        },
        {
            "introduction": "任何可靠的计算结果都必须经过严格的收敛性测试。本练习  将指导你系统地研究各项数值参数——例如k点密度、能量展宽以及插值方法——如何影响最终的反常霍尔电导率计算结果。通过这项实践，你将学会如何确定一组能够达到预设精度目标的计算参数，这是计算材料科学研究中的一项核心技能。",
            "id": "3433226",
            "problem": "您的任务是设计并实现一个关于反常霍尔电导率的数值收敛性研究，该研究需遵循适用于计算材料科学的第一性原理。考虑一个二维双带模型，其哈密顿量为有质量的 Dirac 哈密顿量 $H(\\mathbf{k}) = \\mathbf{d}(\\mathbf{k}) \\cdot \\boldsymbol{\\sigma}$，其中 $\\boldsymbol{\\sigma}$ 是泡利矩阵，$\\mathbf{d}(\\mathbf{k}) = \\left(A k_x, A k_y, m\\right)$，其中常数 $A>0$ 且质量 $m \\neq 0$。设费米能级为 $E_F = 0$，并假设使用一个平滑的展宽函数来近似零温极限。反常霍尔电导率 (AHC) 经由电导量子 $e^2/h$ 归一化为无量纲形式，可以从贝里相位表述出发，表示为对类布里渊区内占据态的积分：\n$$\n\\sigma_{xy}^{\\mathrm{norm}} = \\frac{1}{2\\pi} \\sum_{n \\in \\{+,-\\}} \\int_{\\mathcal{D}} f\\left(E_n(\\mathbf{k})\\right) \\, \\Omega_n(\\mathbf{k}) \\, d^2 k,\n$$\n其中 $E_{\\pm}(\\mathbf{k}) = \\pm \\|\\mathbf{d}(\\mathbf{k})\\|$，$f(E)$ 是占据数函数，$\\Omega_n(\\mathbf{k})$ 是能带 $n$ 的贝里曲率。对于一个普适的双带 $\\mathbf{d} \\cdot \\boldsymbol{\\sigma}$ 模型，能带 $n$ 的贝里曲率由下式给出：\n$$\n\\Omega_{n}(\\mathbf{k}) = s_n \\frac{1}{2} \\frac{\\mathbf{d}(\\mathbf{k}) \\cdot \\left( \\frac{\\partial \\mathbf{d}}{\\partial k_x} \\times \\frac{\\partial \\mathbf{d}}{\\partial k_y} \\right)}{\\|\\mathbf{d}(\\mathbf{k})\\|^3},\n$$\n其中 $s_{+} = +1$ 且 $s_{-} = -1$。对于指定的 $\\mathbf{d}(\\mathbf{k})$，可推得：\n$$\n\\Omega_{\\pm}(\\mathbf{k}) = \\pm \\frac{m A^2}{2 \\left(m^2 + A^2 k_x^2 + A^2 k_y^2\\right)^{3/2}}.\n$$\n占据数 $f(E)$ 在 $E_F = 0$ 处使用高斯展宽替代 Heaviside 阶跃函数进行近似：\n$$\nf(E) = \\frac{1}{2} \\left[ 1 - \\operatorname{erf}\\left( \\frac{E - E_F}{\\sqrt{2}\\,\\sigma} \\right) \\right],\n$$\n其中 $\\sigma>0$ 是展宽宽度，$\\operatorname{erf}(\\cdot)$ 是误差函数。这种选择确保了在 $\\sigma \\to 0^+$ 时，过渡既平滑又越来越陡峭。\n\n您的程序必须：\n1. 构建一个方形积分区域 $\\mathcal{D} = \\{(k_x,k_y) \\mid -k_{\\max} \\le k_x \\le k_{\\max},\\ -k_{\\max} \\le k_y \\le k_{\\max}\\}$，并通过一个 $N_k \\times N_k$ 的矩形 $k$ 点网格对 $\\sigma_{xy}^{\\mathrm{norm}}$ 进行数值积分。使用 $A = 1$，$m = 1$，$E_F = 0$ 和 $k_{\\max} = 10$。\n2. 对于给定的参数三元组 $(N_k, \\sigma, p)$，按如下方式计算 $\\sigma_{xy}^{\\mathrm{norm}}$：\n   - 在粗糙的 $N_k \\times N_k$ 网格上计算被积函数 $g(\\mathbf{k}) = \\sum_{n \\in \\{+,-\\}} f(E_n(\\mathbf{k}))\\,\\Omega_n(\\mathbf{k})$。\n   - 使用阶数为 $p \\in \\{0,1,3\\}$ 的样条插值，将 $g(\\mathbf{k})$ 插值到一个大小为 $N_{\\mathrm{ref}} \\times N_{\\mathrm{ref}}$ 的公共精细网格上，其中 $p=0$ 为最近邻插值，$p=1$ 为双线性插值，$p=3$ 为双三次插值。使用 $N_{\\mathrm{ref}} = 800$。\n   - 在精细网格上使用矩形法则进行积分，面积元为 $\\Delta A = \\left(\\frac{2k_{\\max}}{N_{\\mathrm{ref}}}\\right)^2$，并应用归一化因子 $\\frac{1}{2\\pi}$。\n3. 通过在 $N_{\\mathrm{ref}} \\times N_{\\mathrm{ref}}$ 网格上直接计算相同的积分，建立一个高精度的基准值 $\\sigma_{xy}^{\\mathrm{norm,ref}}$。计算时使用展宽宽度 $\\sigma_{\\mathrm{ref}} = 10^{-6}$ 且不进行任何插值。\n\n定义相对偏差\n$$\n\\Delta = \\left| \\frac{\\sigma_{xy}^{\\mathrm{norm}} - \\sigma_{xy}^{\\mathrm{norm,ref}}}{\\sigma_{xy}^{\\mathrm{norm,ref}}} \\right|\n$$\n并评估是否达到了小于 1% 的目标容差，即 $\\Delta  0.01$。\n\n您的程序必须评估以下参数三元组 $(N_k, \\sigma, p)$ 的测试套件：\n- 案例 1: $(32, 0.02, 1)$\n- 案例 2: $(128, 0.01, 1)$\n- 案例 3: $(64, 0.05, 3)$\n- 案例 4: $(16, 0.10, 1)$\n- 案例 5: $(64, 0.0001, 3)$\n- 案例 6: $(48, 0.05, 0)$\n\n物理单位：反常霍尔电导率以无量纲的归一化单位（除以 $e^2/h$）报告。不需要其他物理单位。角度单位不适用。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的布尔值逗号分隔列表，顺序与测试套件相同（例如，$[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3},\\mathrm{result4},\\mathrm{result5},\\mathrm{result6}]$），每个布尔值表示该案例是否满足小于 1% 的容差要求。",
            "solution": "该问题是有效的。它提出了一个定义明确的数值任务，该任务基于凝聚态物理中反常霍尔效应的标准理论框架。所有必要的方程、参数和步骤都已明确指定，没有内部矛盾或科学谬误。\n\n目标是针对一个二维有质量 Dirac 模型的反常霍尔电导率（AHC）进行数值收敛性研究。这包括为多种数值参数组合（k 点网格密度、能量展宽和插值阶数）计算 AHC，并将其与一个高精度参考值进行比较，以确定是否满足指定的容差。\n\n核心物理量是归一化的反常霍尔电导率 $\\sigma_{xy}^{\\mathrm{norm}}$，它由 Kubo-Streda 公式给出，并用贝里曲率 $\\Omega_n(\\mathbf{k})$ 表示：\n$$\n\\sigma_{xy}^{\\mathrm{norm}} = \\frac{1}{2\\pi} \\sum_{n \\in \\{+,-\\}} \\int_{\\mathcal{D}} f\\left(E_n(\\mathbf{k})\\right) \\, \\Omega_n(\\mathbf{k}) \\, d^2 k\n$$\n该积分在动量空间（$\\mathbf{k}$-空间）中的一个指定区域 $\\mathcal{D}$ 上进行。此公式的各组成部分由模型哈密顿量 $H(\\mathbf{k}) = \\mathbf{d}(\\mathbf{k}) \\cdot \\boldsymbol{\\sigma}$ 定义，其中 $\\boldsymbol{\\sigma}$ 是泡利矩阵矢量，$\\mathbf{d}(\\mathbf{k}) = (A k_x, A k_y, m)$。\n\n两个能带（导带和价带）的能量本征值为 $E_n(\\mathbf{k})$，其中 $n \\in \\{+,-\\}$：\n$$\nE_{\\pm}(\\mathbf{k}) = \\pm \\|\\mathbf{d}(\\mathbf{k})\\| = \\pm \\sqrt{A^2 k_x^2 + A^2 k_y^2 + m^2}\n$$\n贝里曲率 $\\Omega_n(\\mathbf{k})$ 在动量空间中充当一个虚构的磁场，对于此模型，其表达式为：\n$$\n\\Omega_{\\pm}(\\mathbf{k}) = \\pm \\frac{m A^2}{2 \\left(m^2 + A^2 k_x^2 + A^2 k_y^2\\right)^{3/2}}\n$$\n我们观察到 $\\Omega_+(\\mathbf{k}) = -\\Omega_-(\\mathbf{k})$。函数 $f(E)$ 是占据数函数。在零温下，它是一个 Heaviside 阶跃函数，$f(E) = \\Theta(E_F - E)$。为了数值稳定性，它被一个高斯展宽的近似所取代：\n$$\nf(E) = \\frac{1}{2} \\left[ 1 - \\operatorname{erf}\\left( \\frac{E - E_F}{\\sqrt{2}\\,\\sigma} \\right) \\right]\n$$\n其中 $E_F=0$ 是费米能级，$\\sigma$ 是展宽宽度。\n\n被积函数可以被简化。令 $g(\\mathbf{k}) = \\sum_{n} f(E_n(\\mathbf{k})) \\Omega_n(\\mathbf{k})$。代入表达式并利用 $E_+ = -E_-$ 和 $\\Omega_+ = -\\Omega_-$：\n$$\ng(\\mathbf{k}) = f(E_+)\\Omega_+ + f(E_-)\\Omega_- = f(E_+)\\Omega_+ + f(-E_+)(-\\Omega_+) = \\Omega_+ \\left[ f(E_+) - f(-E_+) \\right]\n$$\n使用 $E_F=0$ 时 $f(E)$ 的定义以及属性 $\\operatorname{erf}(-x) = -\\operatorname{erf}(x)$：\n$$\nf(E_+) - f(-E_+) = \\frac{1}{2}\\left[1 - \\operatorname{erf}\\left(\\frac{E_+}{\\sqrt{2}\\sigma}\\right)\\right] - \\frac{1}{2}\\left[1 - \\operatorname{erf}\\left(\\frac{-E_+}{\\sqrt{2}\\sigma}\\right)\\right] = -\\operatorname{erf}\\left(\\frac{E_+}{\\sqrt{2}\\sigma}\\right)\n$$\n因此，总的被积函数简化为单项：\n$$\ng(\\mathbf{k}) = -\\Omega_+(\\mathbf{k}) \\operatorname{erf}\\left(\\frac{E_+(\\mathbf{k})}{\\sqrt{2}\\,\\sigma}\\right)\n$$\n这种形式在计算上更高效，因为它将函数求值的次数减半。\n\n数值计算步骤如下：\n首先，建立一个高精度的参考值 $\\sigma_{xy}^{\\mathrm{norm,ref}}$。这是通过在区域 $\\mathcal{D} = [-k_{\\max}, k_{\\max}] \\times [-k_{\\max}, k_{\\max}]$ 上的一个 $N_{\\mathrm{ref}} \\times N_{\\mathrm{ref}}$ 精细网格上直接对 $g(\\mathbf{k})$ 进行数值积分来完成的。积分使用矩形法则进行：\n$$\n\\sigma_{xy}^{\\mathrm{norm,ref}} = \\frac{1}{2\\pi} \\sum_{i,j} g(\\mathbf{k}_{ij}; \\sigma_{\\mathrm{ref}}) \\Delta A\n$$\n其中 $\\mathbf{k}_{ij}$ 是 $N_{\\mathrm{ref}} \\times N_{\\mathrm{ref}}$ 网格上的点，展宽是一个小值 $\\sigma_{\\mathrm{ref}} = 10^{-6}$ 以近似零温极限，面积元为 $\\Delta A = \\left(\\frac{2k_{\\max}}{N_{\\mathrm{ref}}}\\right)^2$。在实现中，我们使用具体的模型参数 $A=1$，$m=1$，$k_{\\max}=10$ 和 $N_{\\mathrm{ref}}=800$。\n\n其次，对于每个测试案例的三元组 $(N_k, \\sigma, p)$，计算一个测试值 $\\sigma_{xy}^{\\mathrm{norm}}$。这涉及一个多步骤过程，旨在模拟实际的计算工作流程，即在粗糙网格上执行计算然后进行插值：\n1.  在粗糙的 $N_k \\times N_k$ 网格上计算被积函数 $g(\\mathbf{k}; \\sigma)$。\n2.  使用阶数为 $p$ 的样条插值将所得值插值到精细的 $N_{\\mathrm{ref}} \\times N_{\\mathrm{ref}}$ 网格上。映射关系为 $p=0$（最近邻），$p=1$（双线性）和 $p=3$（双三次）。\n3.  使用与参考计算相同的矩形法则，在精细网格上对插值后的函数 $g_{\\mathrm{interp}}(\\mathbf{k})$ 进行积分。\n\n最后，对每个测试案例，计算相对偏差 $\\Delta$ 并与容差进行比较：\n$$\n\\Delta = \\left| \\frac{\\sigma_{xy}^{\\mathrm{norm}} - \\sigma_{xy}^{\\mathrm{norm,ref}}}{\\sigma_{xy}^{\\mathrm{norm,ref}}} \\right|  0.01\n$$\n每个案例的结果是一个布尔值，表示是否满足此条件。该实现将使用 `numpy` 进行高效的数组计算，并使用 `scipy.interpolate.RegularGridInterpolator` 进行插值步骤，它将整数阶数 $p$ 映射到所需的插值方案。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Computes a numerical convergence study for anomalous Hall conductivity (AHC).\n    \"\"\"\n    # Define constants and global parameters from the problem statement\n    A = 1.0\n    m = 1.0\n    k_max = 10.0\n    E_F = 0.0\n    N_ref = 800\n    sigma_ref = 1e-6\n\n    # --- Step 1: Define the fine reference grid ---\n    # The grid points are defined by linspace, spanning the domain.\n    k_ref_coords = np.linspace(-k_max, k_max, N_ref)\n    kx_ref_grid, ky_ref_grid = np.meshgrid(k_ref_coords, k_ref_coords, indexing='ij')\n\n    # --- Step 2: Define the physical functions based on the model ---\n    \n    # Memoize energy and Berry curvature on the fine grid to avoid re-computation\n    _energy_ref_grid = np.sqrt((A * kx_ref_grid)**2 + (A * ky_ref_grid)**2 + m**2)\n    _omega_plus_ref_grid = (m * A**2) / (2 * _energy_ref_grid**3)\n\n    def calculate_integrand(kx_grid, ky_grid, sigma):\n        \"\"\"\n        Calculates the simplified integrand g(k) on a given grid.\n        g(k) = -Omega_+(k) * erf(E_+(k) / (sqrt(2)*sigma))\n        \"\"\"\n        energy = np.sqrt((A * kx_grid)**2 + (A * ky_grid)**2 + m**2)\n        omega_plus = (m * A**2) / (2 * energy**3)\n        \n        # In the limit of small sigma, E/sigma becomes large, and erf(...) -> 1 for E>0.\n        if sigma  1e-12:\n            erf_term = np.ones_like(energy)\n        else:\n            erf_term = erf(energy / (np.sqrt(2) * sigma))\n        \n        return -omega_plus * erf_term\n\n    # --- Step 3: Calculate the high-accuracy reference AHC ---\n    # Calculate integrand on the fine grid with the reference smearing\n    integrand_ref = calculate_integrand(kx_ref_grid, ky_ref_grid, sigma_ref)\n\n    # Integrate using the rectangle rule as specified\n    dk_ref_area = ((2 * k_max) / N_ref) ** 2\n    integral_ref = np.sum(integrand_ref) * dk_ref_area\n    sigma_xy_ref = integral_ref / (2 * np.pi)\n\n    # --- Step 4: Define test suite and process each case ---\n    test_cases = [\n        # (Nk, sigma, p)\n        (32, 0.02, 1),\n        (128, 0.01, 1),\n        (64, 0.05, 3),\n        (16, 0.10, 1),\n        (64, 0.0001, 3),\n        (48, 0.05, 0),\n    ]\n\n    # Map interpolation order p to scipy's 'kind' argument\n    p_map = {0: 'nearest', 1: 'linear', 3: 'cubic'}\n    \n    results = []\n    \n    # Grid of points for evaluating the interpolator\n    fine_points_for_interp = np.stack([kx_ref_grid.ravel(), ky_ref_grid.ravel()], axis=-1)\n\n    for Nk, sigma, p in test_cases:\n        # Define the coarse grid for the current test case\n        k_coarse_coords = np.linspace(-k_max, k_max, Nk)\n        kx_coarse_grid, ky_coarse_grid = np.meshgrid(k_coarse_coords, k_coarse_coords, indexing='ij')\n\n        # Calculate integrand on the coarse grid with the case-specific smearing\n        integrand_coarse = calculate_integrand(kx_coarse_grid, ky_coarse_grid, sigma)\n\n        # Set up and run the interpolation from the coarse grid to the fine grid\n        interpolator = RegularGridInterpolator(\n            (k_coarse_coords, k_coarse_coords), \n            integrand_coarse, \n            method=p_map[p], \n            bounds_error=False, \n            fill_value=0.0\n        )\n        \n        # Evaluate the interpolator on the fine grid points\n        integrand_interp = interpolator(fine_points_for_interp).reshape((N_ref, N_ref))\n        \n        # Integrate the interpolated function on the fine grid\n        integral_test = np.sum(integrand_interp) * dk_ref_area\n        sigma_xy_test = integral_test / (2 * np.pi)\n\n        # Calculate the relative deviation and check against the 1% tolerance\n        # The value of sigma_xy_ref is ~-0.45, so no risk of division by zero.\n        delta = np.abs((sigma_xy_test - sigma_xy_ref) / sigma_xy_ref)\n        \n        results.append(delta  0.01)\n\n    # Print the final output in the specified format\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        }
    ]
}