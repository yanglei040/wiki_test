{
    "hands_on_practices": [
        {
            "introduction": "声子玻尔兹曼输运方程（BTE）的核心是描述声子散射的碰撞项。在热平衡状态下，该碰撞项必须为零，这一条件是由细致平衡原理所保证的。本练习将通过一个第一性原理的计算来实践并验证三声子散射过程中的细致平衡原理，从而加深对声子输运基本统计物理规律的理解 。",
            "id": "3495030",
            "problem": "实现一个程序，该程序使用处于热平衡状态下三声子过程的声子玻尔兹曼输运方程 (BTE) 碰撞项，通过检查分裂和合并过程的正向和反向统计贡献是否相等来验证细致平衡。该验证必须从第一性原理出发，基于玻色-爱因斯坦占据数和能量守恒约束进行。使用以下基本依据：\n- 温度为 $T$ 时，角频率为 $\\omega$ 的声子模式的玻色-爱因斯坦占据数为 $n(\\omega, T) = \\dfrac{1}{\\exp\\!\\left(\\dfrac{\\hbar \\omega}{k_{\\mathrm{B}} T}\\right) - 1}$，其中 $\\hbar$ 是约化普朗克常数，而 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。\n- 微观可逆性意味着对于同一模式三元组，散射矩阵元平方 $\\left|V\\right|^2$ 在交换正向和反向过程时是对称的。\n- 三声子过程的能量守恒约束表示为：分裂（衰变）过程为 $\\omega_{\\lambda} = \\omega_{\\mu} + \\omega_{\\nu}$，合并（吸收）过程为 $\\omega_{\\nu} = \\omega_{\\lambda} + \\omega_{\\mu}$。\n\n定义两种过程类型：\n- 分裂（衰变）过程 $\\lambda \\rightarrow \\mu + \\nu$。\n- 合并（吸收）过程 $\\lambda + \\mu \\rightarrow \\nu$。\n\n根据玻色-爱因斯坦占据数因子，为每种过程构建正向和反向统计贡献，这与量子统计中的受激发射和吸收一致，并在满足能量守恒的条件下验证其在平衡态下是否相等。你的程序必须：\n- 对每个频率 $\\omega$ 和温度 $T$ 计算 $n(\\omega, T)$。\n- 对于每个三元组，使用玻色-爱因斯坦因子计算指定过程类型的正向和反向统计贡献（微观可逆性意味着正向和反向的散射矩阵元相同）。\n- 通过比较角频率的适当和与差，检查指定过程类型的能量守恒。\n- 当且仅当能量守恒在指定容差范围内成立，并且正向和反向统计贡献在指定的相对容差范围内相等时，才宣告相等。\n\n使用以下测试套件，其中每个测试用例是一个元组 $(\\text{process}, T, \\omega_{\\lambda}, \\omega_{\\mu}, \\omega_{\\nu})$：\n- 用例 $1$ (正常情况，分裂，中等温度): $(\\text{\"split\"},\\, 300\\,\\mathrm{K},\\, 2.0\\times 10^{13}\\,\\mathrm{rad/s},\\, 1.2\\times 10^{13}\\,\\mathrm{rad/s},\\, 0.8\\times 10^{13}\\,\\mathrm{rad/s})$。\n- 用例 $2$ (正常情况，合并，低温): $(\\text{\"merge\"},\\, 80\\,\\mathrm{K},\\, 1.0\\times 10^{12}\\,\\mathrm{rad/s},\\, 1.5\\times 10^{12}\\,\\mathrm{rad/s},\\, 2.5\\times 10^{12}\\,\\mathrm{rad/s})$。\n- 用例 $3$ (边界情况，分裂，一个极低频率): $(\\text{\"split\"},\\, 50\\,\\mathrm{K},\\, 1.001\\times 10^{9}\\,\\mathrm{rad/s},\\, 1.0\\times 10^{9}\\,\\mathrm{rad/s},\\, 1.0\\times 10^{6}\\,\\mathrm{rad/s})$。\n- 用例 $4$ (反面情况，能量守恒被破坏): $(\\text{\"split\"},\\, 300\\,\\mathrm{K},\\, 2.0\\times 10^{13}\\,\\mathrm{rad/s},\\, 1.1\\times 10^{13}\\,\\mathrm{rad/s},\\, 1.0\\times 10^{13}\\,\\mathrm{rad/s})$。\n\n数值容差：\n- 在检查角频率的和与差的相等性时，使用 $\\delta_{\\omega} = 10^{-6}\\,\\mathrm{rad/s}$ 的绝对能量守恒容差。\n- 在比较正向和反向统计贡献时，使用 $\\delta_{\\mathrm{rel}} = 10^{-10}$ 的相对相等容差。\n\n单位：\n- 所有角频率必须以 $\\mathrm{rad/s}$ 为单位处理。\n- 温度必须以 $\\mathrm{K}$ 为单位处理。\n\n你的程序应产生单行输出，其中包含四个测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，每个条目是一个布尔值，指示该用例的细致平衡是否成立（例如，$[\\text{True},\\text{False},\\text{True},\\text{True}]$）。最终输出必须是严格按照指定格式的一行列表，不含任何额外文本。",
            "solution": "该问题要求验证处于热平衡状态下三声子散射过程的细致平衡原理。该原理是平衡系统中微观可逆性的一个基本推论，它指出任何基本过程的速率都等于其逆过程的速率。在声子玻尔兹曼输运方程 (BTE) 的背景下，该原理确保了碰撞项在平衡时为零，从而得到稳态的声子分布。\n\n我们从声子的定义性统计属性开始。声子是玻色子准粒子，在温度 $T$ 下，角频率为 $\\omega$ 的模式的平衡占据数 $n$ 由玻色-爱因斯坦分布给出：\n$$\nn(\\omega, T) = \\frac{1}{\\exp\\left(\\frac{\\hbar \\omega}{k_{\\mathrm{B}} T}\\right) - 1}\n$$\n其中 $\\hbar$ 是约化普朗克常数，而 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。\n\n该问题考虑了两种类型的三声子过程：\n1.  **分裂（或衰变）**：一个模式为 $\\lambda$ 的声子衰变为两个模式分别为 $\\mu$ 和 $\\nu$ 的声子。这表示为 $\\lambda \\rightarrow \\mu + \\nu$。\n2.  **合并（或吸收）**：两个模式分别为 $\\lambda$ 和 $\\mu$ 的声子合并形成一个模式为 $\\nu$ 的新声子。这表示为 $\\lambda + \\mu \\rightarrow \\nu$。\n\n任何散射过程的跃迁速率 $W$ 都与散射矩阵元的平方 $|V|^2$ 以及一个取决于初态和末态占据数的统计因子成正比。对于涉及玻色子的过程，在一个已被 $n$ 个粒子占据的状态中创建一个粒子的概率与 $(n+1)$ 成正比（受激发射加自发发射），而从该状态中湮灭一个粒子的概率与 $n$ 成正比（吸收）。\n\n让我们为每种过程类型形式化细致平衡条件。\n\n**1. 分裂过程：$\\lambda \\rightleftharpoons \\mu + \\nu$**\n\n正向过程是 $\\lambda \\rightarrow \\mu + \\nu$。它涉及湮灭一个模式为 $\\lambda$ 的声子，并为模式 $\\mu$ 和 $\\nu$ 各产生一个声子。此过程的统计因子，我们记为 $S_{\\text{forward}}$，由每个事件的概率乘积给出：\n$$\nS_{\\text{forward}} = n_{\\lambda} (n_{\\mu} + 1) (n_{\\nu} + 1)\n$$\n其中对于 $i \\in \\{\\lambda, \\mu, \\nu\\}$，$n_i = n(\\omega_i, T)$。\n\n反向过程是 $\\mu + \\nu \\rightarrow \\lambda$。它涉及湮灭模式为 $\\mu$ 和 $\\nu$ 的声子，并产生一个模式为 $\\lambda$ 的声子。其统计因子 $S_{\\text{reverse}}$ 为：\n$$\nS_{\\text{reverse}} = n_{\\mu} n_{\\nu} (n_{\\lambda} + 1)\n$$\n\n细致平衡原理断言，在平衡状态下，正向和反向速率相等。鉴于微观可逆性确保了正向和反向路径的散射矩阵元相同，即 $|V_{\\lambda \\rightarrow \\mu\\nu}|^2 = |V_{\\mu\\nu \\rightarrow \\lambda}|^2$，速率的相等意味着统计因子的相等：\n$$\nn_{\\lambda} (n_{\\mu} + 1) (n_{\\nu} + 1) = (n_{\\lambda} + 1) n_{\\mu} n_{\\nu}\n$$\n该方程可以重排为：\n$$\n\\frac{n_{\\lambda}}{n_{\\lambda} + 1} = \\frac{n_{\\mu}}{n_{\\mu} + 1} \\frac{n_{\\nu}}{n_{\\nu} + 1}\n$$\n代入玻色-爱因斯坦分布的定义，我们发现 $\\frac{n}{n+1} = \\exp\\left(-\\frac{\\hbar \\omega}{k_{\\mathrm{B}} T}\\right)$。因此，等式变为：\n$$\n\\exp\\left(-\\frac{\\hbar \\omega_{\\lambda}}{k_{\\mathrm{B}} T}\\right) = \\exp\\left(-\\frac{\\hbar \\omega_{\\mu}}{k_{\\mathrm{B}} T}\\right) \\exp\\left(-\\frac{\\hbar \\omega_{\\nu}}{k_{\\mathrm{B}} T}\\right) = \\exp\\left(-\\frac{\\hbar (\\omega_{\\mu} + \\omega_{\\nu})}{k_{\\mathrm{B}} T}\\right)\n$$\n该恒等式成立的充要条件是能量守恒，即 $\\omega_{\\lambda} = \\omega_{\\mu} + \\omega_{\\nu}$。\n\n**2. 合并过程：$\\lambda + \\mu \\rightleftharpoons \\nu$**\n\n正向过程是 $\\lambda + \\mu \\rightarrow \\nu$。它涉及湮灭声子 $\\lambda$ 和 $\\mu$ 并产生声子 $\\nu$。统计因子为：\n$$\nS_{\\text{forward}} = n_{\\lambda} n_{\\mu} (n_{\\nu} + 1)\n$$\n\n反向过程是 $\\nu \\rightarrow \\lambda + \\mu$。它涉及湮灭声子 $\\nu$ 并产生声子 $\\lambda$ 和 $\\mu$。统计因子为：\n$$\nS_{\\text{reverse}} = n_{\\nu} (n_{\\lambda} + 1) (n_{\\mu} + 1)\n$$\n\n在平衡状态下，细致平衡要求 $S_{\\text{forward}} = S_{\\text{reverse}}$：\n$$\nn_{\\lambda} n_{\\mu} (n_{\\nu} + 1) = n_{\\nu} (n_{\\lambda} + 1) (n_{\\mu} + 1)\n$$\n这可以重排为：\n$$\n\\frac{n_{\\nu} + 1}{n_{\\nu}} = \\frac{n_{\\lambda} + 1}{n_{\\lambda}} \\frac{n_{\\mu} + 1}{n_{\\mu}}\n$$\n使用恒等式 $\\frac{n+1}{n} = \\exp\\left(\\frac{\\hbar \\omega}{k_{\\mathrm{B}} T}\\right)$，我们得到：\n$$\n\\exp\\left(\\frac{\\hbar \\omega_{\\nu}}{k_{\\mathrm{B}} T}\\right) = \\exp\\left(\\frac{\\hbar \\omega_{\\lambda}}{k_{\\mathrm{B}} T}\\right) \\exp\\left(\\frac{\\hbar \\omega_{\\mu}}{k_{\\mathrm{B}} T}\\right) = \\exp\\left(\\frac{\\hbar (\\omega_{\\lambda} + \\omega_{\\mu})}{k_{\\mathrm{B}} T}\\right)\n$$\n该恒等式成立的充要条件是能量守恒，即 $\\omega_{\\nu} = \\omega_{\\lambda} + \\omega_{\\mu}$。\n\n计算任务是为给定的测试用例验证此原理。算法如下：\n1.  定义物理常数 $\\hbar$ 和 $k_{\\mathrm{B}}$，以及指定的数值容差 $\\delta_{\\omega} = 10^{-6}\\,\\mathrm{rad/s}$ 和 $\\delta_{\\mathrm{rel}} = 10^{-10}$。\n2.  对于每个测试用例 $(\\text{process}, T, \\omega_{\\lambda}, \\omega_{\\mu}, \\omega_{\\nu})$：\n    a. 首先，在绝对容差 $\\delta_{\\omega}$ 内检查能量守恒。\n       - 对于 `split` 过程，验证是否 $|\\omega_{\\lambda} - (\\omega_{\\mu} + \\omega_{\\nu})| \\le \\delta_{\\omega}$。\n       - 对于 `merge` 过程，验证是否 $|\\omega_{\\nu} - (\\omega_{\\lambda} + \\omega_{\\mu})| \\le \\delta_{\\omega}$。\n       - 如果能量不守恒，则细致平衡不成立，结果为 `False`。\n    b. 如果能量守恒，则继续使用玻色-爱因斯坦公式计算声子占据数 $n_{\\lambda}$、$n_{\\mu}$ 和 $n_{\\nu}$。通过使用等效于 `expm1` 的函数来处理指数函数小参数的数值稳定性问题。\n    c. 根据过程类型，计算如上推导的正向 ($S_{\\text{fwd}}$) 和反向 ($S_{\\text{rev}}$) 统计因子。\n    d. 使用相对容差 $\\delta_{\\mathrm{rel}}$ 比较 $S_{\\text{fwd}}$ 和 $S_{\\text{rev}}$ 是否相等。像 `np.isclose` 这样的稳健方法适合于这种浮点数比较。\n    e. 当且仅当能量守恒和统计因子相等两个条件都满足时，该测试用例的结果为 `True`。\n3.  收集所有测试用例的布尔结果，并将其格式化为指定的输出字符串。",
            "answer": "```python\nimport numpy as np\nfrom scipy.constants import hbar, k as k_B\n\ndef solve():\n    \"\"\"\n    Verifies the principle of detailed balance for three-phonon scattering processes.\n    \"\"\"\n    # Define numerical tolerances from the problem statement.\n    delta_omega = 1e-6   # rad/s, for energy conservation\n    delta_rel = 1e-10    # relative tolerance for statistical contributions\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (process_type, T (K), omega_lambda (rad/s), omega_mu (rad/s), omega_nu (rad/s))\n        (\"split\", 300.0, 2.0e13, 1.2e13, 0.8e13),\n        (\"merge\", 80.0, 1.0e12, 1.5e12, 2.5e12),\n        (\"split\", 50.0, 1.001e9, 1.0e9, 1.0e6),\n        (\"split\", 300.0, 2.0e13, 1.1e13, 1.0e13),\n    ]\n\n    results = []\n\n    def bose_einstein_n(omega: float, T: float) -> float:\n        \"\"\"\n        Computes the Bose-Einstein occupation number n(omega, T).\n        Handles numerical stability for small and large arguments.\n        \"\"\"\n        if T == 0.0:\n            return 0.0\n        \n        # Argument of the exponential function\n        arg = (hbar * omega) / (k_B * T)\n        \n        # For very large arguments, exp(arg) -> inf, so n -> 0.\n        # This prevents overflow.\n        if arg > np.log(np.finfo(float).max):\n            return 0.0\n            \n        # For small arguments, exp(arg) - 1 is prone to precision loss.\n        # np.expm1(arg) computes exp(arg) - 1 accurately.\n        return 1.0 / np.expm1(arg)\n\n    for case in test_cases:\n        process_type, T, omega_lambda, omega_mu, omega_nu = case\n\n        # Step 1: Verify energy conservation.\n        energy_conserved = False\n        if process_type == \"split\":\n            if abs(omega_lambda - (omega_mu + omega_nu)) = delta_omega:\n                energy_conserved = True\n        elif process_type == \"merge\":\n            if abs(omega_nu - (omega_lambda + omega_mu)) = delta_omega:\n                energy_conserved = True\n        \n        if not energy_conserved:\n            results.append(False)\n            continue\n\n        # Step 2: Compute phonon occupation numbers.\n        n_lambda = bose_einstein_n(omega_lambda, T)\n        n_mu = bose_einstein_n(omega_mu, T)\n        n_nu = bose_einstein_n(omega_nu, T)\n\n        # Step 3: Compute forward and reverse statistical contributions.\n        S_fwd, S_rev = 0.0, 0.0\n        if process_type == \"split\":\n            # Forward: lambda -> mu + nu\n            S_fwd = n_lambda * (n_mu + 1.0) * (n_nu + 1.0)\n            # Reverse: mu + nu -> lambda\n            S_rev = (n_lambda + 1.0) * n_mu * n_nu\n        elif process_type == \"merge\":\n            # Forward: lambda + mu -> nu\n            S_fwd = n_lambda * n_mu * (n_nu + 1.0)\n            # Reverse: nu -> lambda + mu\n            S_rev = (n_lambda + 1.0) * (n_mu + 1.0) * n_nu\n            \n        # Step 4: Verify equality of statistical contributions.\n        # Detailed balance is confirmed if the statistical factors are equal.\n        # np.isclose is used for robust floating-point comparison.\n        contributions_equal = np.isclose(S_fwd, S_rev, rtol=delta_rel, atol=0.0)\n        \n        results.append(contributions_equal)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "弛豫时间近似（RTA）将复杂的BTE简化，为晶格热导率 $k$ 提供了一个直接的积分表达式。然而，如何精确地计算这个在整个布里渊区（BZ）上的积分，是实际计算中的一个关键数值挑战。本练习将引导你实现并比较两种主流的布里渊区积分方法——高斯展宽法和四面体方法，以理解它们在收敛性和精度上的表现，这是从事相关计算研究的一项核心技能 。",
            "id": "3495049",
            "problem": "考虑一个三维简单立方晶体，其每个原胞含单个原子，并具有三个声学声子支：一个速度为 $v_{\\mathrm{L}}$ 的纵波支和两个速度为 $v_{\\mathrm{T}}$ 的横波支。假设每个声子支都具有各向同性的线性（类德拜）色散关系，$\\omega_s(\\mathbf{q}) = v_s \\lvert \\mathbf{q} \\rvert$，其中 $\\mathbf{q}$ 位于布里渊区内部，该布里渊区近似为一个立方体 $\\left[-\\pi/a,\\pi/a\\right]^3$，$a$ 是晶格常数，$s \\in \\{\\mathrm{L}, \\mathrm{T}\\}$ 表示声子支。群速度为 $\\mathbf{v}_s(\\mathbf{q}) = \\nabla_{\\mathbf{q}} \\omega_s(\\mathbf{q}) = v_s \\mathbf{q}/\\lvert \\mathbf{q} \\rvert$。假设弛豫时间模型为 $\\tau(\\omega, T) = \\tau_0 \\left[1 + \\left(\\omega/\\omega_c\\right)^2\\right]^{-1}$，其中 $\\tau_0$ 和 $\\omega_c$ 为常数，模式热容为 $C(\\omega, T) = k_{\\mathrm{B}} \\left(\\dfrac{x^2 e^x}{\\left(e^x-1\\right)^2}\\right)$，其中 $x = \\hbar \\omega / (k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$\\hbar$ 是约化普朗克常数。在声子玻尔兹曼输运方程的单模弛豫时间近似下，$x$ 方向的热导率张量元由以下布里渊区积分定义\n$$\nk_{xx}(T) = \\sum_{s \\in \\{\\mathrm{L},\\mathrm{T},\\mathrm{T}\\}} \\int_{\\mathrm{BZ}} \\frac{d^3 \\mathbf{q}}{(2\\pi)^3}\\, C\\!\\left(\\omega_s(\\mathbf{q}), T\\right)\\, v_{s,x}(\\mathbf{q})^2\\, \\tau\\!\\left(\\omega_s(\\mathbf{q}), T\\right).\n$$\n您的任务是编写一个完整、可运行的程序，该程序能够：\n1. 在一个大小为 $N_q \\times N_q \\times N_q$ 的均匀 $\\mathbf{q}$ 网格上对布里渊区立方体进行离散化，其中 $N_q$ 由每个测试用例指定，网格间距为 $h = 2(\\pi/a)/(N_q-1)$。\n2. 在每个网格点上计算被积函数 $f_s(\\mathbf{q}) = C\\!\\left(\\omega_s(\\mathbf{q}), T\\right)\\, v_{s,x}(\\mathbf{q})^2\\, \\tau\\!\\left(\\omega_s(\\mathbf{q}), T\\right)$，对所有声子支 $s$ 求和，并使用两种数值布里渊区积分策略计算 $k_{xx}(T)$：\n   - 高斯展宽法：将求和后的被积函数 $f(\\mathbf{q})$ 与一个宽度为 $\\sigma$（在 $\\mathbf{q}$ 空间中）的归一化三维高斯函数 $G_\\sigma(\\Delta \\mathbf{q}) \\propto \\exp\\!\\left(-\\lVert \\Delta \\mathbf{q} \\rVert^2/(2\\sigma^2)\\right)$ 进行卷积，然后使用矩形法近似该积分，即 $k_{xx}^{\\mathrm{G}} \\approx \\frac{h^3}{(2\\pi)^3} \\sum_{\\mathbf{q}} \\left(G_\\sigma * f\\right)(\\mathbf{q})$。卷积时使用镜像边界处理，以避免边缘附近的质量损失。\n   - 四面体积分法：将每个网格立方单元分割成六个四面体，在每个四面体内使用其四个顶点的函数值对 $f(\\mathbf{q})$ 进行线性近似，并将所有四面体上线性插值函数的精确积分值相加，即 $k_{xx}^{\\mathrm{T}} \\approx \\frac{1}{(2\\pi)^3} \\sum_{\\text{tetra}} V_{\\text{tetra}} \\,\\overline{f}_{\\text{tetra}}$，其中 $V_{\\text{tetra}}$ 是四面体在 $\\mathbf{q}$ 空间中的几何体积，$\\overline{f}_{\\text{tetra}}$ 是 $f$ 在其四个顶点处的平均值。\n3. 通过计算一个在更精细网格 $N_q^{\\mathrm{ref}} = 33$ 上使用四面体积分法得到的高分辨率参考值 $k_{xx}^{\\mathrm{ref}}$，来量化每种方法的残余数值误差，并报告相对误差 $E^{\\mathrm{G}} = \\lvert k_{xx}^{\\mathrm{G}} - k_{xx}^{\\mathrm{ref}} \\rvert / k_{xx}^{\\mathrm{ref}}$ 和 $E^{\\mathrm{T}} = \\lvert k_{xx}^{\\mathrm{T}} - k_{xx}^{\\mathrm{ref}} \\rvert / k_{xx}^{\\mathrm{ref}}$。\n使用以下物理常数和参数：\n- 晶格常数 $a = 5.43 \\times 10^{-10}\\,\\mathrm{m}$。\n- 温度 $T = 300\\,\\mathrm{K}$。\n- 纵波速度 $v_{\\mathrm{L}} = 8433\\,\\mathrm{m/s}$。\n- 横波速度 $v_{\\mathrm{T}} = 5843\\,\\mathrm{m/s}$。\n- 玻尔兹曼常数 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$。\n- 约化普朗克常数 $\\hbar = 1.054571817 \\times 10^{-34}\\,\\mathrm{J\\,s}$。\n- 弛豫时间参数 $\\tau_0 = 1.0 \\times 10^{-11}\\,\\mathrm{s}$ 和 $\\omega_c = 1.0 \\times 10^{13}\\,\\mathrm{rad/s}$。\n\n数值计算细节：\n- 在 $\\mathbf{q} = \\mathbf{0}$ 处，定义 $v_{s,x}^2(\\mathbf{q}) = v_s^2/3$ 以确保各向同性极限行为并避免除以零。\n- 对于高斯展宽法，使用卷积核宽度 $\\sigma$，其通过网格间距 $h$ 表示为 $\\sigma = \\alpha h$，其中 $\\alpha$ 是特定于测试用例的因子。\n\n测试套件：\n为以下 $(N_q,\\alpha)$ 对提供结果：\n- $(7, 1.0)$\n- $(9, 0.0)$\n- $(13, 0.5)$\n- $(17, 0.0)$\n\n对于每个测试用例，计算并返回四个量：$k_{xx}^{\\mathrm{G}}$、$k_{xx}^{\\mathrm{T}}$、$E^{\\mathrm{G}}$ 和 $E^{\\mathrm{T}}$。\n\n答案规格：\n- 将每个热导率以 $\\mathrm{W/(m\\,K)}$ 为单位表示为浮点数。\n- 将每个误差表示为浮点数（十进制）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果按上述顺序作为子列表报告，即 $\\left[ [k_{xx}^{\\mathrm{G}}, k_{xx}^{\\mathrm{T}}, E^{\\mathrm{G}}, E^{\\mathrm{T}}], \\ldots \\right]$。",
            "solution": "该问题已被验证，并被确定为计算材料科学领域内一个定义良好、科学上合理且计算上可行的任务。它为计算晶格热导率提供了一套完整且一致的物理模型、参数和数值程序。所有必需的信息都已提供，不存在矛盾或含糊之处。\n\n该解答通过遵循问题陈述中概述的步骤来实现。计算的核心是在离散化的布里渊区（BZ）上，针对指定温度 $T$ 计算热导率积分。\n\n首先，我们定义所有已提供的物理常数和材料参数：晶格常数 $a = 5.43 \\times 10^{-10}\\,\\mathrm{m}$、温度 $T = 300\\,\\mathrm{K}$、声子支速度 $v_{\\mathrm{L}} = 8433\\,\\mathrm{m/s}$ 和 $v_{\\mathrm{T}} = 5843\\,\\mathrm{m/s}$、玻尔兹曼常数 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$、约化普朗克常数 $\\hbar = 1.054571817 \\times 10^{-34}\\,\\mathrm{J\\,s}$，以及弛豫时间参数 $\\tau_0 = 1.0 \\times 10^{-11}\\,\\mathrm{s}$ 和 $\\omega_c = 1.0 \\times 10^{13}\\,\\mathrm{rad/s}$。\n\n主要的计算过程被封装在一个函数中，该函数在代表布里渊区的3D网格上构建被积函数。对于给定的网格尺寸 $N_q \\times N_q \\times N_q$，将边长为 $2\\pi/a$ 的立方体近似的布里渊区进行离散化。使用 `numpy.linspace(-numpy.pi/a, numpy.pi/a, N_q)` 生成 $\\mathbf{q}$ 矢量的分量，并使用 `numpy.meshgrid` 创建3D网格。网格间距为 $h = 2(\\pi/a)/(N_q-1)$。\n\n对于网格上的每个点 $\\mathbf{q}$ 和三个声子支（一个纵波支，两个横波支）中的每一个，我们计算必要的物理量。总被积函数 $f(\\mathbf{q})$ 是来自每个声子支 $s \\in \\{\\mathrm{L},\\mathrm{T},\\mathrm{T}\\}$ 的贡献之和。对于速度为 $v_s$ 的给定声子支，计算过程如下：\n1.  **声子频率**：类德拜色散关系给出 $\\omega_s(\\mathbf{q}) = v_s \\lvert \\mathbf{q} \\rvert$，其中 $\\lvert \\mathbf{q} \\rvert$ 是波矢量的欧几里得范数。\n2.  **模式热容**：每个模式的热容为 $C(\\omega, T) = k_{\\mathrm{B}} \\left(\\frac{x^2 e^x}{(e^x-1)^2}\\right)$，其中 $x = \\hbar \\omega / (k_{\\mathrm{B}} T)$。在 $\\mathbf{q} = \\mathbf{0}$ 处需特别注意，此时 $\\omega = 0$ 且 $x = 0$。在此极限下，$C(0, T) = k_{\\mathrm{B}}$，这点被明确处理以避免数值不确定性。\n3.  **弛豫时间**：使用给定模型 $\\tau(\\omega) = \\tau_0 \\left[1 + (\\omega/\\omega_c)^2\\right]^{-1}$ 进行计算。\n4.  **群速度分量**：$x$ 方向的群速度平方为 $v_{s,x}(\\mathbf{q})^2 = (v_s q_x / \\lvert \\mathbf{q} \\rvert)^2$。在奇点 $\\mathbf{q} = \\mathbf{0}$ 处，我们使用规定的各向同性平均值 $v_{s,x}^2(\\mathbf{0}) = v_s^2/3$。\n然后，每个网格点上的完整被积函数为 $f(\\mathbf{q}) = f_{\\mathrm{L}}(\\mathbf{q}) + 2 f_{\\mathrm{T}}(\\mathbf{q})$，其中 $f_s(\\mathbf{q}) = C(\\omega_s(\\mathbf{q}), T) v_{s,x}(\\mathbf{q})^2 \\tau(\\omega_s(\\mathbf{q}), T)$。\n\n在网格上计算出被积函数后，应用两种数值积分方法。\n1.  **高斯展宽积分法**：此方法将布里渊区积分近似为 $k_{xx}^{\\mathrm{G}} \\approx \\frac{h^3}{(2\\pi)^3} \\sum_{\\mathbf{q}} (G_\\sigma * f)(\\mathbf{q})$。总被积函数网格 $f(\\mathbf{q})$ 与三维高斯核 $G_\\sigma$ 的卷积使用 `scipy.ndimage.gaussian_filter` 执行。滤波器的 `sigma` 参数以网格间距为单位，设置为问题指定的 $\\alpha$ 值，因为当物理标准差为 $\\sigma = \\alpha h$ 时，滤波器的标准差对应于 `alpha` 个像素。按规定使用镜像边界条件（`mode='mirror'`）。如果 $\\alpha=0$，此方法简化为标准的矩形法积分，此时卷积是单位操作。\n2.  **四面体积分法**：此方法通过将布里渊区分割为一组四面体来提供更精确的积分值。积分域被划分为 $(N_q-1)^3$ 个体积为 $h^3$ 的小立方单元。每个单元进一步被分割成六个体积相等的四面体，其体积为 $V_{\\text{tetra}} = h^3/6$。每个四面体上的积分近似为 $V_{\\text{tetra}} \\overline{f}_{\\text{tetra}}$，其中 $\\overline{f}_{\\text{tetra}}$ 是被积函数在四面体四个顶点值的算术平均值。总积分 $k_{xx}^{\\mathrm{T}}$ 是布里渊区内所有四面体贡献的总和，再除以 $(2\\pi)^3$。这是通过遍历每个网格单元，获取其八个顶点的被积函数值，使用标准分解方法对该单元内六个四面体的贡献求和，并累加结果来实现的。\n\n为量化数值误差，首先计算一个高分辨率的参考值 $k_{xx}^{\\mathrm{ref}}$。这是通过在 $N_q^{\\mathrm{ref}} = 33$ 的精细网格上使用更精确的四面体积分法完成的。然后，对于每个测试用例 $(N_q, \\alpha)$，计算热导率 $k_{xx}^{\\mathrm{G}}$ 和 $k_{xx}^{\\mathrm{T}}$。接着，计算相对误差 $E^{\\mathrm{G}} = \\lvert k_{xx}^{\\mathrm{G}} - k_{xx}^{\\mathrm{ref}} \\rvert / k_{xx}^{\\mathrm{ref}}$ 和 $E^{\\mathrm{T}} = \\lvert k_{xx}^{\\mathrm{T}} - k_{xx}^{\\mathrm{ref}} \\rvert / k_{xx}^{\\mathrm{ref}}$。\n\n最终的程序结构首先计算参考值，然后遍历指定的测试用例，执行两种积分方法的计算，计算误差，并为每个用例存储四个结果值（$k_{xx}^{\\mathrm{G}}、k_{xx}^{\\mathrm{T}}、E^{\\mathrm{G}}、E^{\\mathrm{T}}$）。最后，将这些结果格式化为最终输出所需的嵌套列表字符串格式。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import gaussian_filter\n\ndef calculate_integrand(N_q, a, v_L, v_T, k_B, h_bar, T, tau_0, omega_c):\n    \"\"\"\n    Computes the thermal conductivity integrand on a 3D q-mesh.\n    \"\"\"\n    q_max = np.pi / a\n    # Create the q-space grid\n    if N_q == 1:\n        q_coords = np.array([0.0])\n        h = 2 * q_max\n    else:\n        q_coords = np.linspace(-q_max, q_max, N_q)\n        h = q_coords[1] - q_coords[0]\n\n    qx, qy, qz = np.meshgrid(q_coords, q_coords, q_coords, indexing='ij')\n    q_norm = np.sqrt(qx**2 + qy**2 + qz**2)\n    \n    # Identify the q=0 point for special handling\n    is_q_zero = (q_norm == 0)\n\n    f_grid = np.zeros((N_q, N_q, N_q), dtype=np.float64)\n\n    # Sum over phonon branches: 1 Longitudinal, 2 Transverse\n    for v_s, weight in [(v_L, 1.0), (v_T, 2.0)]:\n        # Angular frequency omega = v_s * |q|\n        omega = v_s * q_norm\n        \n        # Dimensionless variable for heat capacity\n        x = np.divide(h_bar * omega, (k_B * T), out=np.zeros_like(omega), where=(k_B * T) != 0)\n        \n        # Mode heat capacity C(omega, T)\n        C_grid = np.full_like(x, k_B) # Default value for x=0\n        nonzero_mask = (x != 0)\n        x_nz = x[nonzero_mask]\n        C_grid[nonzero_mask] = k_B * (x_nz**2 * np.exp(x_nz)) / np.expm1(x_nz)**2\n        \n        # Relaxation time tau(omega)\n        tau_grid = tau_0 / (1.0 + (omega / omega_c)**2)\n        \n        # Group velocity squared v_sx^2\n        vsx2_grid = np.full_like(q_norm, v_s**2 / 3.0) # Default for q=0\n        nonzero_q_mask = ~is_q_zero\n        vsx2_grid[nonzero_q_mask] = (v_s**2 * qx[nonzero_q_mask]**2) / q_norm[nonzero_q_mask]**2\n        \n        # Accumulate integrand for this branch\n        f_grid += weight * C_grid * vsx2_grid * tau_grid\n        \n    return f_grid, h\n\ndef integrate_gaussian(f_grid, h, alpha):\n    \"\"\"\n    Integrates the grid using Gaussian smearing.\n    \"\"\"\n    if alpha == 0.0:\n        smeared_f_grid = f_grid\n    else:\n        # sigma for gaussian_filter is in pixel units, which is exactly alpha here.\n        smeared_f_grid = gaussian_filter(f_grid, sigma=alpha, mode='mirror')\n        \n    integral = np.sum(smeared_f_grid) * h**3\n    k_xx = integral / (2 * np.pi)**3\n    return k_xx\n\ndef integrate_tetrahedron(f_grid, h):\n    \"\"\"\n    Integrates the grid using the linear tetrahedron method.\n    \"\"\"\n    N_q = f_grid.shape[0]\n    if N_q  2:\n        return 0.0\n\n    total_f_sum = 0.0\n    \n    # Loop over all elementary cells in the grid\n    for i in range(N_q - 1):\n        for j in range(N_q - 1):\n            for k in range(N_q - 1):\n                # Fetch 8 vertex values of the cell\n                f_verts = [\n                    f_grid[i,   j,   k],   f_grid[i+1, j,   k],\n                    f_grid[i,   j+1, k],   f_grid[i,   j,   k+1],\n                    f_grid[i+1, j+1, k],   f_grid[i+1, j,   k+1],\n                    f_grid[i,   j+1, k+1], f_grid[i+1, j+1, k+1]\n                ]\n                \n                # Sum of vertices for the 6 tetrahedra using a standard space-filling decomposition\n                cell_f_sum = (f_verts[0]+f_verts[1]+f_verts[4]+f_verts[7]) + \\\n                             (f_verts[0]+f_verts[1]+f_verts[5]+f_verts[7]) + \\\n                             (f_verts[0]+f_verts[2]+f_verts[4]+f_verts[7]) + \\\n                             (f_verts[0]+f_verts[2]+f_verts[6]+f_verts[7]) + \\\n                             (f_verts[0]+f_verts[3]+f_verts[5]+f_verts[7]) + \\\n                             (f_verts[0]+f_verts[3]+f_verts[6]+f_verts[7])\n                \n                total_f_sum += cell_f_sum\n\n    # The integral per tetrahedron is V_tetra * avg(f) = (h^3/6) * sum(f_i)/4\n    integral = total_f_sum * (h**3 / 24.0)\n    k_xx = integral / (2 * np.pi)**3\n    return k_xx\n\ndef solve():\n    # Physical constants and parameters\n    a = 5.43e-10       # m\n    T = 300.0          # K\n    v_L = 8433.0       # m/s\n    v_T = 5843.0       # m/s\n    k_B = 1.380649e-23 # J/K\n    h_bar = 1.054571817e-34 # J s\n    tau_0 = 1.0e-11    # s\n    omega_c = 1.0e13   # rad/s\n\n    # Test suite\n    test_cases = [\n        (7, 1.0),\n        (9, 0.0),\n        (13, 0.5),\n        (17, 0.0)\n    ]\n    N_q_ref = 33\n\n    # Calculate reference thermal conductivity\n    f_grid_ref, h_ref = calculate_integrand(N_q_ref, a, v_L, v_T, k_B, h_bar, T, tau_0, omega_c)\n    k_xx_ref = integrate_tetrahedron(f_grid_ref, h_ref)\n\n    results = []\n    for N_q, alpha in test_cases:\n        # Compute integrand on the test grid\n        f_grid, h = calculate_integrand(N_q, a, v_L, v_T, k_B, h_bar, T, tau_0, omega_c)\n\n        # Calculate k_xx with both methods\n        k_xx_G = integrate_gaussian(f_grid, h, alpha)\n        k_xx_T = integrate_tetrahedron(f_grid, h)\n\n        # Calculate relative errors\n        E_G = np.abs(k_xx_G - k_xx_ref) / k_xx_ref\n        E_T = np.abs(k_xx_T - k_xx_ref) / k_xx_ref\n        \n        results.append([k_xx_G, k_xx_T, E_G, E_T])\n\n    # Format output string\n    case_strings = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_string = f\"[{','.join(case_strings)}]\"\n    print(final_string)\n\nsolve()\n```"
        },
        {
            "introduction": "为了超越RTA的局限性并获得更精确的结果，我们需要求解完整的线性化玻尔兹曼输运方程（LBTE）。该方程通常表现为一个大型线性方程组 $\\mathbf{M}\\boldsymbol{\\phi} = \\mathbf{v}$，其中碰撞矩阵 $\\mathbf{M}$ 的性质（如条件数）直接影响求解效率。本练习通过一个简化的物理模型，对比了简单的定点迭代法和更高效的共轭梯度法，直观地揭示了高级迭代求解器在处理真实材料中常见的病态系统时的巨大优势 。",
            "id": "3495072",
            "problem": "实现一个用于晶体固体中线性化玻尔兹曼输运方程 (LBTE) 的、数学上自洽的双支玩具模型，以比较在计算沿单个笛卡尔方向的热导率时，基本定点（理查森）迭代法与共轭梯度法的收敛行为。该模型应为纯线性代数模型，并使用物理上合理的参数。\n\n从稳态声子 LBTE 的标准线性响应公式出发，该公式已针对微小温度梯度进行线性化。将碰撞（散射）算符建模为一个对称正定矩阵，作用于一个未知的模态位移向量。对于一组由 $i$ 索引的声子模态，定义以下玩具 LBTE：\n$$\n\\mathbf{M}\\,\\boldsymbol{\\phi} = \\mathbf{v},\n$$\n其中 $\\mathbf{M}\\in\\mathbb{R}^{m\\times m}$ 是对称正定矩阵，代表线性化的碰撞算符；$\\boldsymbol{\\phi}\\in\\mathbb{R}^{m}$ 是沿输运方向的未知类位移响应振幅向量；$\\mathbf{v}\\in\\mathbb{R}^{m}$ 是沿该方向的群速度向量。然后，沿该方向的热导率 $k$ 可通过解 $\\boldsymbol{\\phi}$ 计算得出：\n$$\nk = \\sum_{i=1}^{m} C_i\\, v_i\\, \\phi_i,\n$$\n其中 $C_i$ 是模态体积热容。\n\n通过将模态分辨的弛豫时间与匹配波矢指标上的支间耦合相结合，为一个双支系统（每支有 $N$ 个模态，总共 $m=2N$ 个模态）构建 $\\mathbf{M}$。具体来说，设对角部分由模态分辨的散射率 $1/\\tau_i$ 给出，匹配模态之间的支间耦合由一个非负标量 $\\gamma$ 参数化。定义：\n$$\n\\mathbf{M} = \\operatorname{diag}\\!\\big(1/\\tau_1, \\dots, 1/\\tau_m\\big) + \\gamma\\,\\mathbf{L},\n$$\n其中 $\\mathbf{L}$ 是跨波矢指标的块对角矩阵，其每个 $2\\times 2$ 块将对应于相同离散波矢 $k$ 的两个支耦合起来，形式如下：\n$$\n\\mathbf{L}_k=\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}.\n$$\n这种构造确保了当 $\\tau_i0$ 且 $\\gamma\\ge 0$ 时，$\\mathbf{M}$ 是对称正定的。\n\n您必须为该线性系统实现两个求解器：\n- 定点（理查森）迭代法：\n  $$\n  \\boldsymbol{\\phi}^{(n+1)}=\\boldsymbol{\\phi}^{(n)} + \\omega\\,\\big(\\mathbf{v}-\\mathbf{M}\\boldsymbol{\\phi}^{(n)}\\big),\n  $$\n  初始条件为 $\\boldsymbol{\\phi}^{(0)}=\\mathbf{0}$，步长 $\\omega$ 选择为\n  $$\n  \\omega=\\frac{0.99}{\\lambda_{\\max}(\\mathbf{M})},\n  $$\n  其中 $\\lambda_{\\max}(\\mathbf{M})$ 是 $\\mathbf{M}$ 的最大特征值，将通过幂迭代法进行数值估计。\n- 无预处理的共轭梯度 (CG) 法，初始条件为 $\\boldsymbol{\\phi}^{(0)}=\\mathbf{0}$。\n\n两个求解器都必须在相对残差范数满足\n$$\n\\frac{\\|\\mathbf{v}-\\mathbf{M}\\boldsymbol{\\phi}\\|_2}{\\|\\mathbf{v}\\|_2}\\le \\varepsilon,\n$$\n（容差 $\\varepsilon=10^{-10}$）时终止，或者在定点法达到 $10^{6}$ 次迭代、共轭梯度法达到 $10^{4}$ 次迭代的硬上限时终止，以先到者为准。\n\n求解后，使用收敛解 $\\boldsymbol{\\phi}$ 计算 $k$，并以 $\\mathrm{W\\,m^{-1}\\,K^{-1}}$ 为单位报告结果。为进行公平比较，请使用相同的容差计算并报告两种方法的迭代次数。\n\n实现您的程序以评估以下三个测试用例（每个用例 $N=6$，因此 $m=12$），它们代表了不同的条件数和耦合机制。对每个用例，定义各支的速度 $\\mathbf{v}^{(\\mathrm{ac})}$ 和 $\\mathbf{v}^{(\\mathrm{op})}$（单位为 $\\mathrm{m\\,s^{-1}}$），各模态的体积热容 $C^{(\\mathrm{ac})}$ 和 $C^{(\\mathrm{op})}$（单位为 $\\mathrm{J\\,m^{-3}\\,K^{-1}}$，在每支内为常数），各模态的弛豫时间 $\\boldsymbol{\\tau}^{(\\mathrm{ac})}$ 和 $\\boldsymbol{\\tau}^{(\\mathrm{op})}$（单位为 $\\mathrm{ps}$），以及耦合参数 $\\gamma$（单位为 $\\mathrm{s^{-1}}$）。使用 $1\\,\\mathrm{ps}=1\\times 10^{-12}\\,\\mathrm{s}$。\n\n- 用例 A（良态，中等耦合）：\n  - $\\mathbf{v}^{(\\mathrm{ac})} = [3.0\\times 10^{3},\\,3.2\\times 10^{3},\\,3.4\\times 10^{3},\\,3.6\\times 10^{3},\\,3.8\\times 10^{3},\\,4.0\\times 10^{3}]\\,\\mathrm{m\\,s^{-1}}$，\n  - $\\mathbf{v}^{(\\mathrm{op})} = [0.5\\times 10^{3},\\,0.6\\times 10^{3},\\,0.7\\times 10^{3},\\,0.8\\times 10^{3},\\,0.9\\times 10^{3},\\,1.0\\times 10^{3}]\\,\\mathrm{m\\,s^{-1}}$，\n  - $C^{(\\mathrm{ac})} = 1.2\\times 10^{5}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}$ 每模态，$C^{(\\mathrm{op})} = 2.0\\times 10^{5}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}$ 每模态，\n  - $\\boldsymbol{\\tau}^{(\\mathrm{ac})} = [20,\\,18,\\,16,\\,14,\\,12,\\,10]\\,\\mathrm{ps}$，\n  - $\\boldsymbol{\\tau}^{(\\mathrm{op})} = [5,\\,5,\\,5,\\,5,\\,5,\\,5]\\,\\mathrm{ps}$，\n  - $\\gamma = 0.2\\times 10^{12}\\,\\mathrm{s^{-1}}$。\n\n- 用例 B（病态，强耦合且寿命差异大）：\n  - $\\mathbf{v}^{(\\mathrm{ac})} = [2.5\\times 10^{3},\\,3.0\\times 10^{3},\\,3.5\\times 10^{3},\\,4.0\\times 10^{3},\\,4.5\\times 10^{3},\\,5.0\\times 10^{3}]\\,\\mathrm{m\\,s^{-1}}$，\n  - $\\mathbf{v}^{(\\mathrm{op})} = [0.3\\times 10^{3},\\,0.4\\times 10^{3},\\,0.5\\times 10^{3},\\,0.6\\times 10^{3},\\,0.7\\times 10^{3},\\,0.8\\times 10^{3}]\\,\\mathrm{m\\,s^{-1}}$，\n  - $C^{(\\mathrm{ac})} = 1.0\\times 10^{5}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}$ 每模态，$C^{(\\mathrm{op})} = 2.0\\times 10^{5}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}$ 每模态，\n  - $\\boldsymbol{\\tau}^{(\\mathrm{ac})} = [200,\\,150,\\,100,\\,80,\\,60,\\,50]\\,\\mathrm{ps}$，\n  - $\\boldsymbol{\\tau}^{(\\mathrm{op})} = [1,\\,1.2,\\,1.5,\\,2,\\,2.5,\\,3]\\,\\mathrm{ps}$，\n  - $\\gamma = 5.0\\times 10^{12}\\,\\mathrm{s^{-1}}$。\n\n- 用例 C（由于长寿命导致对角线接近奇异，弱耦合）：\n  - $\\mathbf{v}^{(\\mathrm{ac})} = [2.0\\times 10^{3},\\,2.2\\times 10^{3},\\,2.4\\times 10^{3},\\,2.6\\times 10^{3},\\,2.8\\times 10^{3},\\,3.0\\times 10^{3}]\\,\\mathrm{m\\,s^{-1}}$，\n  - $\\mathbf{v}^{(\\mathrm{op})} = [0.4\\times 10^{3},\\,0.5\\times 10^{3},\\,0.6\\times 10^{3},\\,0.7\\times 10^{3},\\,0.8\\times 10^{3},\\,0.9\\times 10^{3}]\\,\\mathrm{m\\,s^{-1}}$，\n  - $C^{(\\mathrm{ac})} = 1.3\\times 10^{5}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}$ 每模态，$C^{(\\mathrm{op})} = 1.7\\times 10^{5}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}$ 每模态，\n  - $\\boldsymbol{\\tau}^{(\\mathrm{ac})} = [5000,\\,2000,\\,1000,\\,500,\\,200,\\,100]\\,\\mathrm{ps}$，\n  - $\\boldsymbol{\\tau}^{(\\mathrm{op})} = [20,\\,20,\\,20,\\,20,\\,20,\\,20]\\,\\mathrm{ps}$，\n  - $\\gamma = 0.05\\times 10^{12}\\,\\mathrm{s^{-1}}$。\n\n对每个用例：\n- 使用给定的 $\\tau_i$（从 $\\mathrm{ps}$ 转换为 $\\mathrm{s}$）和 $\\gamma$ 组装矩阵 $\\mathbf{M}$（单位为 $\\mathrm{s^{-1}}$）。\n- 通过拼接声学支和光学支的速度来组装向量 $\\mathbf{v}$。\n- 将 $\\mathbf{C}$ 组装成一个包含各支每模态常数的向量。\n\n使用两种求解器并根据指定的停止准则求解 $\\mathbf{M}\\,\\boldsymbol{\\phi}=\\mathbf{v}$。计算 $k=\\sum_i C_i v_i \\phi_i$（单位为 $\\mathrm{W\\,m^{-1}\\,K^{-1}}$）。对每个用例，报告三元组 $[k,\\; n_{\\mathrm{FP}},\\; n_{\\mathrm{CG}}]$，其中 $n_{\\mathrm{FP}}$ 和 $n_{\\mathrm{CG}}$ 分别是定点法和共轭梯度法收敛所需的迭代次数。将 $k$ 以 $\\mathrm{W\\,m^{-1}\\,K^{-1}}$ 为单位表示，并四舍五入到六位小数。\n\n最终输出格式：您的程序应生成单行输出，其中包含三个用例的结果，格式为由逗号分隔的三个无空格的方括号三元组，并被一对总的方括号包围，例如，\n$$\n\\big[ [k_A,n_{\\mathrm{FP},A},n_{\\mathrm{CG},A}], [k_B,n_{\\mathrm{FP},B},n_{\\mathrm{CG},B}], [k_C,n_{\\mathrm{FP},C},n_{\\mathrm{CG},C}] \\big],\n$$\n但没有任何空格。程序不得读取任何输入，也不得打印任何其他内容。",
            "solution": "该问题是有效的。它提出了一个具有科学依据且数学上适定的玩具模型，用于计算晶体固体的热导率。所有参数、方程和数值步骤都已明确定义，从而能够得到唯一且可验证的解。\n\n问题的核心是求解线性方程组 $\\mathbf{M}\\boldsymbol{\\phi} = \\mathbf{v}$ 以得到未知向量 $\\boldsymbol{\\phi}$，然后计算热导率 $k$。该问题设置在声子玻尔兹曼输运方程 (BTE) 的背景下，其中 $\\mathbf{M}$ 代表线性化的碰撞算符，$\\mathbf{v}$ 是沿输运方向的声子群速度向量，$\\boldsymbol{\\phi}$ 是模态偏离平衡态的向量。热导率由 $k = \\sum_{i=1}^{m} C_i v_i \\phi_i$ 给出，其中 $C_i$ 是模态体积热容。\n\n该模型包含 $m=2N$ 个声子模态，其中声学支有 $N=6$ 个模态，光学支有 $N=6$ 个模态，总共 $m=12$ 个模态。速度向量 $\\mathbf{v}$、热容向量 $\\mathbf{C}$ 和弛豫时间向量 $\\boldsymbol{\\tau}$ 是通过交错排列声学支和光学支的数据构建的。对于从 $0$ 到 $N-1$ 的索引 $i$，系统模态 $2i$ 和 $2i+1$ 分别对应第 $i$ 个声学模态和第 $i$ 个光学模态。为保持一致性，所有输入参数都将转换为国际单位制（SI）基本单位。具体而言，以皮秒（ps）为单位给出的弛豫时间 $\\tau_i$ 通过乘以 $1 \\times 10^{-12}$ 转换为秒（s）。\n\n$m \\times m$ 矩阵 $\\mathbf{M}$ 按规定组装：\n$$\n\\mathbf{M} = \\operatorname{diag}\\!\\big(1/\\tau_1, \\dots, 1/\\tau_m\\big) + \\gamma\\,\\mathbf{L}\n$$\n第一项是弛豫时间倒数（散射率）的对角矩阵。第二项引入了相同波矢指标下声学模态和光学模态之间的耦合。耦合强度由 $\\gamma \\ge 0$ 给出。矩阵 $\\mathbf{L}$ 是块对角矩阵，由 $N$ 个相同的 $2 \\times 2$ 块 $\\mathbf{L}_k=\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}$ 沿其主对角线构成。这种构造确保了 $\\mathbf{M}$ 是一个对称正定 (SPD) 矩阵，这保证了唯一解的存在以及迭代求解方法的适用性。\n\n实现了两种迭代方法来求解 $\\boldsymbol{\\phi}$，两者都从初始猜测 $\\boldsymbol{\\phi}^{(0)} = \\mathbf{0}$ 开始：\n\n1.  **定点（理查森）迭代法**：解通过以下方案更新：\n    $$\n    \\boldsymbol{\\phi}^{(n+1)} = \\boldsymbol{\\phi}^{(n)} + \\omega\\,\\big(\\mathbf{v}-\\mathbf{M}\\boldsymbol{\\phi}^{(n)}\\big)\n    $$\n    通过选择步长 $\\omega$ 使迭代矩阵 $\\mathbf{I} - \\omega\\mathbf{M}$ 的谱半径小于 $1$ 来保证收敛。规定的选择是 $\\omega = 0.99 / \\lambda_{\\max}(\\mathbf{M})$，其中 $\\lambda_{\\max}(\\mathbf{M})$ 是 $\\mathbf{M}$ 的最大特征值。该值使用幂迭代法进行数值估计，该方法适用于寻找矩阵的最大模特征值。\n\n2.  **共轭梯度 (CG) 法**：实现了一个标准的、无预处理的 CG 算法。该方法对大型稀疏 SPD 系统非常有效，因为在精确算术中，它保证在至多 $m$ 次迭代内找到精确解，并且在实践中通常收敛得快得多。它构造了一系列 M-正交的搜索方向来最小化误差。\n\n当定义为 $\\frac{\\|\\mathbf{v}-\\mathbf{M}\\boldsymbol{\\phi}\\|_2}{\\|\\mathbf{v}\\|_2}$ 的相对残差范数低于容差 $\\varepsilon=10^{-10}$ 时，或者当达到最大迭代次数（定点法为 $10^6$ 次，CG 法为 $10^4$ 次）时，两个求解器都会终止。\n\n在获得收敛解向量 $\\boldsymbol{\\phi}$（使用更稳健的 CG 方法的结果）后，热导率 $k$ 计算为向量 $(C_1v_1, C_2v_2, \\dots, C_mv_m)$ 与 $\\boldsymbol{\\phi}$ 的点积。计算中的单位是一致的，最终得到 $k$ 的单位为 $\\mathrm{W\\,m^{-1}\\,K^{-1}}$。\n\n整个过程应用于三个测试用例，每个用例具有不同的物理参数，代表矩阵 $\\mathbf{M}$ 的不同条件状况。每个用例的最终输出是一个三元组，包含计算出的热导率 $k$（四舍五入到六位小数）、定点法的迭代次数 $n_{\\mathrm{FP}}$ 和共轭梯度法的迭代次数 $n_{\\mathrm{CG}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef power_iteration(A, tol=1e-8, max_iter=1000):\n    \"\"\"\n    Estimates the largest eigenvalue of a symmetric matrix using the power iteration method.\n    \"\"\"\n    # Use a reproducible random vector to avoid issues with orthogonality to the dominant eigenvector.\n    # Seeding is done within the function for local reproducibility.\n    # This is a detail of the specific algorithm implementation.\n    rng = np.random.default_rng(seed=0)\n    b_k = rng.random(A.shape[1])\n    b_k = b_k / np.linalg.norm(b_k)\n\n    lambda_old = 0.0\n    for _ in range(max_iter):\n        # Matrix-vector product\n        Ab = A @ b_k\n        \n        # Re-normalize the vector\n        Ab_norm = np.linalg.norm(Ab)\n        if Ab_norm == 0:\n            return 0.0\n        b_k = Ab / Ab_norm\n        \n        # Rayleigh quotient for eigenvalue estimation\n        lambda_new = b_k.T @ A @ b_k\n        \n        if np.abs(lambda_new - lambda_old)  tol:\n            break\n        lambda_old = lambda_new\n            \n    return lambda_new\n\ndef richardson_solver(M, v, tol, max_iter):\n    \"\"\"\n    Solves the system M*phi = v using the fixed-point (Richardson) iteration.\n    \"\"\"\n    m = M.shape[0]\n    phi = np.zeros(m)\n    \n    lambda_max = power_iteration(M)\n    # If lambda_max is zero, M is a zero matrix. If v is also zero, phi=0 is a solution.\n    # Otherwise, no solution or omega would be infinite.\n    if lambda_max == 0:\n        return phi, 0\n    omega = 0.99 / lambda_max\n\n    v_norm = np.linalg.norm(v)\n    if v_norm == 0:\n        return phi, 0\n\n    for i in range(max_iter):\n        residual = v - M @ phi\n        rel_res_norm = np.linalg.norm(residual) / v_norm\n        \n        if rel_res_norm = tol:\n            return phi, i\n        \n        phi += omega * residual\n        \n    return phi, max_iter\n\ndef cg_solver(M, v, tol, max_iter):\n    \"\"\"\n    Solves the system M*phi = v using the Conjugate Gradient method.\n    \"\"\"\n    m = M.shape[0]\n    phi = np.zeros(m)\n    \n    r = v - M @ phi\n    p = r.copy()\n    rs_old = np.dot(r, r)\n\n    v_norm = np.linalg.norm(v)\n    if v_norm == 0:\n        return phi, 0\n\n    # Check initial residual; if the initial guess is sufficient, 0 iterations were needed.\n    if np.sqrt(rs_old) / v_norm = tol:\n        return phi, 0\n\n    for i in range(max_iter):\n        Ap = M @ p\n        alpha = rs_old / np.dot(p, Ap)\n        \n        phi += alpha * p\n        r -= alpha * Ap\n        \n        rel_res_norm = np.linalg.norm(r) / v_norm\n        if rel_res_norm = tol:\n            return phi, i + 1\n\n        rs_new = np.dot(r, r)\n        if rs_old == 0: # Should not happen if residual is not small enough, but for safety\n             break\n        p = r + (rs_new / rs_old) * p\n        rs_old = rs_new\n        \n    return phi, max_iter\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (well-conditioned, moderate coupling)\n        {\n            \"N\": 6,\n            \"v_ac\": np.array([3.0e3, 3.2e3, 3.4e3, 3.6e3, 3.8e3, 4.0e3]),\n            \"v_op\": np.array([0.5e3, 0.6e3, 0.7e3, 0.8e3, 0.9e3, 1.0e3]),\n            \"C_ac\": 1.2e5, \"C_op\": 2.0e5,\n            \"tau_ac\": np.array([20, 18, 16, 14, 12, 10]),\n            \"tau_op\": np.array([5, 5, 5, 5, 5, 5]),\n            \"gamma\": 0.2e12\n        },\n        # Case B (ill-conditioned, strong coupling and broad lifetime contrast)\n        {\n            \"N\": 6,\n            \"v_ac\": np.array([2.5e3, 3.0e3, 3.5e3, 4.0e3, 4.5e3, 5.0e3]),\n            \"v_op\": np.array([0.3e3, 0.4e3, 0.5e3, 0.6e3, 0.7e3, 0.8e3]),\n            \"C_ac\": 1.0e5, \"C_op\": 2.0e5,\n            \"tau_ac\": np.array([200, 150, 100, 80, 60, 50]),\n            \"tau_op\": np.array([1, 1.2, 1.5, 2, 2.5, 3]),\n            \"gamma\": 5.0e12\n        },\n        # Case C (nearly singular diagonal due to long lifetimes, weak coupling)\n        {\n            \"N\": 6,\n            \"v_ac\": np.array([2.0e3, 2.2e3, 2.4e3, 2.6e3, 2.8e3, 3.0e3]),\n            \"v_op\": np.array([0.4e3, 0.5e3, 0.6e3, 0.7e3, 0.8e3, 0.9e3]),\n            \"C_ac\": 1.3e5, \"C_op\": 1.7e5,\n            \"tau_ac\": np.array([5000, 2000, 1000, 500, 200, 100]),\n            \"tau_op\": np.array([20, 20, 20, 20, 20, 20]),\n            \"gamma\": 0.05e12\n        }\n    ]\n\n    results = []\n    \n    tol = 1e-10\n    max_iter_fp = 1000000\n    max_iter_cg = 10000\n    ps_to_s = 1e-12\n\n    for case in test_cases:\n        N = case[\"N\"]\n        m = 2 * N\n        \n        # Assemble interleaved vectors v, C, tau\n        v = np.zeros(m)\n        C = np.zeros(m)\n        tau = np.zeros(m)\n        \n        v[0::2] = case[\"v_ac\"]\n        v[1::2] = case[\"v_op\"]\n        \n        C[0::2] = case[\"C_ac\"]\n        C[1::2] = case[\"C_op\"]\n        \n        tau[0::2] = case[\"tau_ac\"] * ps_to_s\n        tau[1::2] = case[\"tau_op\"] * ps_to_s\n        \n        # Assemble collision matrix M\n        M = np.diag(1.0 / tau)\n        \n        gamma = case[\"gamma\"]\n        L_block = np.array([[1, -1], [-1, 1]])\n        for i in range(N):\n            M[2*i:2*i+2, 2*i:2*i+2] += gamma * L_block\n            \n        # Solve with fixed-point (Richardson)\n        _, n_fp = richardson_solver(M, v, tol, max_iter_fp)\n\n        # Solve with Conjugate Gradient\n        phi_cg, n_cg = cg_solver(M, v, tol, max_iter_cg)\n        \n        # Calculate thermal conductivity k using the CG solution\n        k = np.dot(C * v, phi_cg)\n        \n        results.append(f\"[{k:.6f},{n_fp},{n_cg}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}