{
    "hands_on_practices": [
        {
            "introduction": "The thermal conductivity integral is the cornerstone of Boltzmann Transport Equation (BTE) based calculations. This exercise provides direct experience in translating this theoretical integral into a numerical result by implementing and comparing two essential Brillouin zone integration techniques: Gaussian smearing and the linear tetrahedron method. Mastering these methods is fundamental for ensuring the accuracy and convergence of any first-principles thermal conductivity calculation .",
            "id": "3495049",
            "problem": "Consider a three-dimensional simple cubic crystal with a single atom per primitive cell and three acoustic phonon branches: one longitudinal branch with speed $v_{\\mathrm{L}}$ and two transverse branches with speed $v_{\\mathrm{T}}$. Assume an isotropic linear (Debye-like) dispersion for each branch, $\\omega_s(\\mathbf{q}) = v_s \\lvert \\mathbf{q} \\rvert$, for $\\mathbf{q}$ inside the Brillouin zone approximated as the cube $\\left[-\\pi/a,\\pi/a\\right]^3$, where $a$ is the lattice parameter and $s \\in \\{\\mathrm{L}, \\mathrm{T}\\}$ denotes the branch. The group velocity is $\\mathbf{v}_s(\\mathbf{q}) = \\nabla_{\\mathbf{q}} \\omega_s(\\mathbf{q}) = v_s \\mathbf{q}/\\lvert \\mathbf{q} \\rvert$. Assume a relaxation time model $\\tau(\\omega, T) = \\tau_0 \\left[1 + \\left(\\omega/\\omega_c\\right)^2\\right]^{-1}$, with constants $\\tau_0$ and $\\omega_c$, and mode heat capacity $C(\\omega, T) = k_{\\mathrm{B}} \\left(\\dfrac{x^2 e^x}{\\left(e^x-1\\right)^2}\\right)$, where $x = \\hbar \\omega / (k_{\\mathrm{B}} T)$, $k_{\\mathrm{B}}$ is the Boltzmann constant, and $\\hbar$ is the reduced Planck constant. Under the single-mode relaxation time approximation of the phonon Boltzmann transport equation, the thermal conductivity tensor element in the $x$ direction is defined by the Brillouin-zone integral\n$$\nk_{xx}(T) = \\sum_{s \\in \\{\\mathrm{L},\\mathrm{T},\\mathrm{T}\\}} \\int_{\\mathrm{BZ}} \\frac{d^3 \\mathbf{q}}{(2\\pi)^3}\\, C\\!\\left(\\omega_s(\\mathbf{q}), T\\right)\\, v_{s,x}(\\mathbf{q})^2\\, \\tau\\!\\left(\\omega_s(\\mathbf{q}), T\\right).\n$$\nYour task is to write a complete, runnable program that:\n1. Discretizes the Brillouin zone cube on a uniform $\\mathbf{q}$-mesh of size $N_q \\times N_q \\times N_q$, with $N_q$ specified per test case, and spacing $h = 2(\\pi/a)/(N_q-1)$.\n2. Computes the integrand $f_s(\\mathbf{q}) = C\\!\\left(\\omega_s(\\mathbf{q}), T\\right)\\, v_{s,x}(\\mathbf{q})^2\\, \\tau\\!\\left(\\omega_s(\\mathbf{q}), T\\right)$ at each grid point, sums over branches $s$, and evaluates $k_{xx}(T)$ using two numerical Brillouin-zone integration strategies:\n   - Gaussian smearing: Convolve the summed integrand $f(\\mathbf{q})$ with a normalized three-dimensional Gaussian $G_\\sigma(\\Delta \\mathbf{q}) \\propto \\exp\\!\\left(-\\lVert \\Delta \\mathbf{q} \\rVert^2/(2\\sigma^2)\\right)$ of width $\\sigma$ (in $\\mathbf{q}$-space) and then approximate the integral using the rectangular rule, i.e., $k_{xx}^{\\mathrm{G}} \\approx \\frac{h^3}{(2\\pi)^3} \\sum_{\\mathbf{q}} \\left(G_\\sigma * f\\right)(\\mathbf{q})$. Use mirror boundary handling for the convolution to avoid loss of mass near edges.\n   - Tetrahedron integration: Partition each grid cube cell into six tetrahedra, approximate $f(\\mathbf{q})$ linearly within each tetrahedron using the values at its four vertices, and sum the exact integrals of the linearly interpolated function over all tetrahedra, i.e., $k_{xx}^{\\mathrm{T}} \\approx \\frac{1}{(2\\pi)^3} \\sum_{\\text{tetra}} V_{\\text{tetra}} \\,\\overline{f}_{\\text{tetra}}$, where $V_{\\text{tetra}}$ is the geometric volume of the tetrahedron in $\\mathbf{q}$-space and $\\overline{f}_{\\text{tetra}}$ is the average of $f$ at its four vertices.\n3. Quantifies residual numerical error for each method by computing a high-resolution reference value $k_{xx}^{\\mathrm{ref}}$ using tetrahedron integration at a finer mesh $N_q^{\\mathrm{ref}} = 33$, and reporting the relative error $E^{\\mathrm{G}} = \\lvert k_{xx}^{\\mathrm{G}} - k_{xx}^{\\mathrm{ref}} \\rvert / k_{xx}^{\\mathrm{ref}}$ and $E^{\\mathrm{T}} = \\lvert k_{xx}^{\\mathrm{T}} - k_{xx}^{\\mathrm{ref}} \\rvert / k_{xx}^{\\mathrm{ref}}$.\nUse the following physical constants and parameters:\n- Lattice parameter $a = 5.43 \\times 10^{-10}\\,\\mathrm{m}$.\n- Temperature $T = 300\\,\\mathrm{K}$.\n- Longitudinal speed $v_{\\mathrm{L}} = 8433\\,\\mathrm{m/s}$.\n- Transverse speed $v_{\\mathrm{T}} = 5843\\,\\mathrm{m/s}$.\n- Boltzmann constant $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$.\n- Reduced Planck constant $\\hbar = 1.054571817 \\times 10^{-34}\\,\\mathrm{J\\,s}$.\n- Relaxation time parameters $\\tau_0 = 1.0 \\times 10^{-11}\\,\\mathrm{s}$ and $\\omega_c = 1.0 \\times 10^{13}\\,\\mathrm{rad/s}$.\n\nNumerical details:\n- At $\\mathbf{q} = \\mathbf{0}$, define $v_{s,x}^2(\\mathbf{q}) = v_s^2/3$ to ensure isotropic limiting behavior and avoid division by zero.\n- For Gaussian smearing, use a convolution kernel width $\\sigma$ expressed in terms of the mesh spacing $h$ as $\\sigma = \\alpha h$ with case-specific factor $\\alpha$.\n\nTest suite:\nProvide results for the following $(N_q,\\alpha)$ pairs:\n- $(7, 1.0)$\n- $(9, 0.0)$\n- $(13, 0.5)$\n- $(17, 0.0)$\n\nFor each test case, compute and return the four quantities $k_{xx}^{\\mathrm{G}}$, $k_{xx}^{\\mathrm{T}}$, $E^{\\mathrm{G}}$, and $E^{\\mathrm{T}}$.\n\nAnswer specification:\n- Express each thermal conductivity in $\\mathrm{W/(m\\,K)}$ as a floating-point number.\n- Express each error as a floating-point number (decimal).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case reported as a sublist in the order given above, i.e., $\\left[ [k_{xx}^{\\mathrm{G}}, k_{xx}^{\\mathrm{T}}, E^{\\mathrm{G}}, E^{\\mathrm{T}}], \\ldots \\right]$.",
            "solution": "The problem has been validated and is determined to be a well-posed, scientifically grounded, and computationally feasible task in the domain of computational materials science. It provides a complete and consistent set of physical models, parameters, and numerical procedures for calculating lattice thermal conductivity. All required information is present, and there are no contradictions or ambiguities.\n\nThe solution is implemented by following the steps outlined in the problem statement. The core of the calculation is the evaluation of the thermal conductivity integral for a specified temperature $T$ on a discretized Brillouin zone (BZ).\n\nFirst, we define all physical constants and material parameters as provided: lattice parameter $a = 5.43 \\times 10^{-10}\\,\\mathrm{m}$, temperature $T = 300\\,\\mathrm{K}$, phonon-branch speeds $v_{\\mathrm{L}} = 8433\\,\\mathrm{m/s}$ and $v_{\\mathrm{T}} = 5843\\,\\mathrm{m/s}$, Boltzmann constant $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$, reduced Planck constant $\\hbar = 1.054571817 \\times 10^{-34}\\,\\mathrm{J\\,s}$, and relaxation time parameters $\\tau_0 = 1.0 \\times 10^{-11}\\,\\mathrm{s}$ and $\\omega_c = 1.0 \\times 10^{13}\\,\\mathrm{rad/s}$.\n\nThe main computational procedure is encapsulated in a function that constructs the integrand on a 3D grid representing the BZ. For a given mesh size $N_q \\times N_q \\times N_q$, the BZ, approximated as a cube of side length $2\\pi/a$, is discretized. The $\\mathbf{q}$-vector components are generated using `numpy.linspace(-numpy.pi/a, numpy.pi/a, N_q)`, and `numpy.meshgrid` creates the 3D grid. The grid spacing is $h = 2(\\pi/a)/(N_q-1)$.\n\nFor each point $\\mathbf{q}$ on the grid and for each of the three phonon branches (one longitudinal, two transverse), we compute the necessary physical quantities. The total integrand $f(\\mathbf{q})$ is the sum of contributions from each branch $s \\in \\{\\mathrm{L},\\mathrm{T},\\mathrm{T}\\}$. For a given branch with speed $v_s$, the calculation proceeds as follows:\n1.  **Phonon Frequency**: The Debye-like dispersion gives $\\omega_s(\\mathbf{q}) = v_s \\lvert \\mathbf{q} \\rvert$, where $\\lvert \\mathbf{q} \\rvert$ is the Euclidean norm of the wavevector.\n2.  **Mode Heat Capacity**: The heat capacity per mode is $C(\\omega, T) = k_{\\mathrm{B}} \\left(\\frac{x^2 e^x}{(e^x-1)^2}\\right)$ with $x = \\hbar \\omega / (k_{\\mathrm{B}} T)$. Special care is taken at $\\mathbf{q} = \\mathbf{0}$, where $\\omega = 0$ and $x = 0$. In this limit, $C(0, T) = k_{\\mathrm{B}}$, which is handled explicitly to avoid numerical indeterminacy.\n3.  **Relaxation Time**: This is calculated using the given model $\\tau(\\omega) = \\tau_0 \\left[1 + (\\omega/\\omega_c)^2\\right]^{-1}$.\n4.  **Group Velocity Component**: The squared group velocity in the $x$-direction is $v_{s,x}(\\mathbf{q})^2 = (v_s q_x / \\lvert \\mathbf{q} \\rvert)^2$. At the singular point $\\mathbf{q} = \\mathbf{0}$, we use the prescribed isotropic average value $v_{s,x}^2(\\mathbf{0}) = v_s^2/3$.\nThe full integrand at each grid point is then $f(\\mathbf{q}) = f_{\\mathrm{L}}(\\mathbf{q}) + 2 f_{\\mathrm{T}}(\\mathbf{q})$, where $f_s(\\mathbf{q}) = C(\\omega_s(\\mathbf{q}), T) v_{s,x}(\\mathbf{q})^2 \\tau(\\omega_s(\\mathbf{q}), T)$.\n\nWith the integrand computed on the grid, two numerical integration methods are applied.\n1.  **Gaussian Smearing Integration**: This method approximates the BZ integral as $k_{xx}^{\\mathrm{G}} \\approx \\frac{h^3}{(2\\pi)^3} \\sum_{\\mathbf{q}} (G_\\sigma * f)(\\mathbf{q})$. The convolution of the total integrand grid $f(\\mathbf{q})$ with a 3D Gaussian kernel $G_\\sigma$ is performed using `scipy.ndimage.gaussian_filter`. The filter's `sigma` parameter, measured in grid-spacing units, is set to the problem-specified value $\\alpha$, as the filter's standard deviation corresponds to `alpha` pixels when the physical standard deviation is $\\sigma = \\alpha h$. Mirror boundary conditions (`mode='mirror'`) are used as specified. If $\\alpha=0$, this method reduces to the standard rectangular rule integration, where the convolution is an identity operation.\n2.  **Tetrahedron Integration**: This method provides a more accurate value for the integral by partitioning the BZ into a set of tetrahedra. The integration domain is divided into $(N_q-1)^3$ small cubic cells of volume $h^3$. Each cell is further partitioned into six tetrahedra of equal volume $V_{\\text{tetra}} = h^3/6$. The integral over each tetrahedron is approximated as $V_{\\text{tetra}} \\overline{f}_{\\text{tetra}}$, where $\\overline{f}_{\\text{tetra}}$ is the arithmetic mean of the integrand values at the tetrahedron's four vertices. The total integral $k_{xx}^{\\mathrm{T}}$ is the sum of these contributions over all tetrahedra in the BZ, divided by $(2\\pi)^3$. This is implemented by iterating through each grid cell, fetching the integrand values at its eight vertices, summing the contributions from the six tetrahedra within that cell using a standard decomposition, and accumulating the result.\n\nTo quantify numerical error, a high-resolution reference value, $k_{xx}^{\\mathrm{ref}}$, is first computed. This is done using the more accurate tetrahedron integration method on a fine grid with $N_q^{\\mathrm{ref}} = 33$. Then, for each test case $(N_q, \\alpha)$, the thermal conductivities $k_{xx}^{\\mathrm{G}}$ and $k_{xx}^{\\mathrm{T}}$ are calculated. The relative errors are then computed as $E^{\\mathrm{G}} = \\lvert k_{xx}^{\\mathrm{G}} - k_{xx}^{\\mathrm{ref}} \\rvert / k_{xx}^{\\mathrm{ref}}$ and $E^{\\mathrm{T}} = \\lvert k_{xx}^{\\mathrm{T}} - k_{xx}^{\\mathrm{ref}} \\rvert / k_{xx}^{\\mathrm{ref}}$.\n\nThe final program structure first computes the reference value, then iterates through the specified test cases, performing the calculations for both integration methods, computing the errors, and storing the four resulting values ($k_{xx}^{\\mathrm{G}}, k_{xx}^{\\mathrm{T}}, E^{\\mathrm{G}}, E^{\\mathrm{T}}$) for each case. Finally, these results are formatted into the required nested list string format for the final output.",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import gaussian_filter\n\ndef calculate_integrand(N_q, a, v_L, v_T, k_B, h_bar, T, tau_0, omega_c):\n    \"\"\"\n    Computes the thermal conductivity integrand on a 3D q-mesh.\n    \"\"\"\n    q_max = np.pi / a\n    # Create the q-space grid\n    if N_q == 1:\n        q_coords = np.array([0.0])\n        h = 2 * q_max\n    else:\n        q_coords = np.linspace(-q_max, q_max, N_q)\n        h = q_coords[1] - q_coords[0]\n\n    qx, qy, qz = np.meshgrid(q_coords, q_coords, q_coords, indexing='ij')\n    q_norm = np.sqrt(qx**2 + qy**2 + qz**2)\n    \n    # Identify the q=0 point for special handling\n    is_q_zero = (q_norm == 0)\n\n    f_grid = np.zeros((N_q, N_q, N_q), dtype=np.float64)\n\n    # Sum over phonon branches: 1 Longitudinal, 2 Transverse\n    for v_s, weight in [(v_L, 1.0), (v_T, 2.0)]:\n        # Angular frequency omega = v_s * |q|\n        omega = v_s * q_norm\n        \n        # Dimensionless variable for heat capacity\n        x = np.divide(h_bar * omega, (k_B * T), out=np.zeros_like(omega), where=(k_B * T) != 0)\n        \n        # Mode heat capacity C(omega, T)\n        C_grid = np.full_like(x, k_B) # Default value for x=0\n        nonzero_mask = (x != 0)\n        x_nz = x[nonzero_mask]\n        C_grid[nonzero_mask] = k_B * (x_nz**2 * np.exp(x_nz)) / np.expm1(x_nz)**2\n        \n        # Relaxation time tau(omega)\n        tau_grid = tau_0 / (1.0 + (omega / omega_c)**2)\n        \n        # Group velocity squared v_sx^2\n        vsx2_grid = np.full_like(q_norm, v_s**2 / 3.0) # Default for q=0\n        nonzero_q_mask = ~is_q_zero\n        vsx2_grid[nonzero_q_mask] = (v_s**2 * qx[nonzero_q_mask]**2) / q_norm[nonzero_q_mask]**2\n        \n        # Accumulate integrand for this branch\n        f_grid += weight * C_grid * vsx2_grid * tau_grid\n        \n    return f_grid, h\n\ndef integrate_gaussian(f_grid, h, alpha):\n    \"\"\"\n    Integrates the grid using Gaussian smearing.\n    \"\"\"\n    if alpha == 0.0:\n        smeared_f_grid = f_grid\n    else:\n        # sigma for gaussian_filter is in pixel units, which is exactly alpha here.\n        smeared_f_grid = gaussian_filter(f_grid, sigma=alpha, mode='mirror')\n        \n    integral = np.sum(smeared_f_grid) * h**3\n    k_xx = integral / (2 * np.pi)**3\n    return k_xx\n\ndef integrate_tetrahedron(f_grid, h):\n    \"\"\"\n    Integrates the grid using the linear tetrahedron method.\n    \"\"\"\n    N_q = f_grid.shape[0]\n    if N_q  2:\n        return 0.0\n\n    total_f_sum = 0.0\n    \n    # Loop over all elementary cells in the grid\n    for i in range(N_q - 1):\n        for j in range(N_q - 1):\n            for k in range(N_q - 1):\n                # Fetch 8 vertex values of the cell\n                f_verts = [\n                    f_grid[i,   j,   k],   f_grid[i+1, j,   k],\n                    f_grid[i,   j+1, k],   f_grid[i,   j,   k+1],\n                    f_grid[i+1, j+1, k],   f_grid[i+1, j,   k+1],\n                    f_grid[i,   j+1, k+1], f_grid[i+1, j+1, k+1]\n                ]\n                \n                # Sum of vertices for the 6 tetrahedra using a standard space-filling decomposition\n                cell_f_sum = (f_verts[0]+f_verts[1]+f_verts[4]+f_verts[7]) + \\\n                             (f_verts[0]+f_verts[1]+f_verts[5]+f_verts[7]) + \\\n                             (f_verts[0]+f_verts[2]+f_verts[4]+f_verts[7]) + \\\n                             (f_verts[0]+f_verts[2]+f_verts[6]+f_verts[7]) + \\\n                             (f_verts[0]+f_verts[3]+f_verts[5]+f_verts[7]) + \\\n                             (f_verts[0]+f_verts[3]+f_verts[6]+f_verts[7])\n                \n                total_f_sum += cell_f_sum\n\n    # The integral per tetrahedron is V_tetra * avg(f) = (h^3/6) * sum(f_i)/4\n    integral = total_f_sum * (h**3 / 24.0)\n    k_xx = integral / (2 * np.pi)**3\n    return k_xx\n\ndef solve():\n    # Physical constants and parameters\n    a = 5.43e-10       # m\n    T = 300.0          # K\n    v_L = 8433.0       # m/s\n    v_T = 5843.0       # m/s\n    k_B = 1.380649e-23 # J/K\n    h_bar = 1.054571817e-34 # J s\n    tau_0 = 1.0e-11    # s\n    omega_c = 1.0e13   # rad/s\n\n    # Test suite\n    test_cases = [\n        (7, 1.0),\n        (9, 0.0),\n        (13, 0.5),\n        (17, 0.0)\n    ]\n    N_q_ref = 33\n\n    # Calculate reference thermal conductivity\n    f_grid_ref, h_ref = calculate_integrand(N_q_ref, a, v_L, v_T, k_B, h_bar, T, tau_0, omega_c)\n    k_xx_ref = integrate_tetrahedron(f_grid_ref, h_ref)\n\n    results = []\n    for N_q, alpha in test_cases:\n        # Compute integrand on the test grid\n        f_grid, h = calculate_integrand(N_q, a, v_L, v_T, k_B, h_bar, T, tau_0, omega_c)\n\n        # Calculate k_xx with both methods\n        k_xx_G = integrate_gaussian(f_grid, h, alpha)\n        k_xx_T = integrate_tetrahedron(f_grid, h)\n\n        # Calculate relative errors\n        E_G = np.abs(k_xx_G - k_xx_ref) / k_xx_ref\n        E_T = np.abs(k_xx_T - k_xx_ref) / k_xx_ref\n        \n        results.append([k_xx_G, k_xx_T, E_G, E_T])\n\n    # Format output string\n    case_strings = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_string = f\"[{','.join(case_strings)}]\"\n    print(final_string)\n\nsolve()\n```"
        },
        {
            "introduction": "A total thermal conductivity value, while useful, hides the rich details of the underlying phonon transport. This practice focuses on deconstructing the total conductivity into its constituent mode contributions, a crucial step for physical interpretation and materials design. By analyzing a discrete set of phonon modes and simulating a hypothetical mode-selective scatterer, you will learn to identify which phonons are the dominant heat carriers and are thus the most effective targets for engineering thermal transport properties .",
            "id": "3495094",
            "problem": "A solid is modeled as an isotropic crystal whose lattice thermal conductivity arises from phonon transport governed by the phonon Boltzmann transport equation (BTE) under a small imposed temperature gradient. Begin from the linearized steady-state phonon Boltzmann transport equation with the relaxation time approximation (RTA) and energy conservation, where the perturbation to the equilibrium Bose-Einstein occupation is driven by the gradient of temperature. The heat current density along a Cartesian axis is obtained from the sum over phonon modes of the product of phonon energy, group velocity, and the occupation perturbation. Use these fundamentals to derive an expression for the lattice thermal conductivity along one axis in terms of the mode-resolved volumetric heat capacity, group velocity magnitude, and relaxation time.\n\nAssume the following modeling assumptions and data are given:\n- The system is isotropic, so that the isotropic angular average of the squared velocity component along any axis satisfies $\\langle v_x^2 \\rangle = v^2/3$ for each mode.\n- The phonon population is described by the Bose-Einstein distribution $n_0(\\omega,T) = \\left(\\exp\\left(\\hbar \\omega/(k_{\\mathrm{B}} T)\\right) - 1\\right)^{-1}$, where $\\hbar$ is the reduced Planck constant and $k_{\\mathrm{B}}$ is the Boltzmann constant.\n- The mode-resolved volumetric heat capacity weight arising from a discrete sampling of the Brillouin zone is $C_j(T) = W_j k_{\\mathrm{B}} \\, \\phi(x_j)$ with $x_j = \\hbar \\omega_j / (k_{\\mathrm{B}} T)$ and $\\phi(x) = \\dfrac{x^2 e^x}{(e^x - 1)^2}$. Here $W_j$ carries the effective number of states per unit volume represented by mode $j$.\n\nA hypothetical mode-selective scatterer is introduced that acts only on selected phonon branches by uniformly scaling the relaxation times within the targeted branch by a suppression factor $s \\in [0,1]$, i.e., $\\tau_j \\mapsto s \\, \\tau_j$ if mode $j$ belongs to the targeted branch and $\\tau_j$ is unchanged otherwise. You will quantify the change in thermal conductivity produced by this scatterer and algorithmically identify the most effective target modes and branches to reduce thermal conductivity.\n\nData for a discrete set of modes $j \\in \\{0,1,2,3,4,5,6,7\\}$ is provided below. Each mode has a branch label $b_j \\in \\{0,1,2\\}$ with the mapping $0 \\rightarrow$ longitudinal acoustic (LA), $1 \\rightarrow$ transverse acoustic (TA), and $2 \\rightarrow$ transverse optical (TO). For each mode $j$, the parameters are the angular frequency $\\omega_j$ in $\\mathrm{rad}\\,\\mathrm{s}^{-1}$, the group velocity magnitude $v_j$ in $\\mathrm{m}\\,\\mathrm{s}^{-1}$, the relaxation time $\\tau_j$ in $\\mathrm{s}$, and the per-mode weight $W_j$ in $\\mathrm{m}^{-3}$:\n- Branch indices $b = [\\, $0$,\\, $0$,\\, $1$,\\, $1$,\\, $1$,\\, $2$,\\, $2$,\\, $2$ \\,]$.\n- Angular frequencies $\\omega$ in $\\mathrm{rad}\\,\\mathrm{s}^{-1}$: $[\\, 1.0\\times 10^{12},\\, 1.5\\times 10^{12},\\, 0.8\\times 10^{12},\\, 1.2\\times 10^{12},\\, 2.0\\times 10^{12},\\, 8.0\\times 10^{13},\\, 1.2\\times 10^{14},\\, 1.6\\times 10^{14} \\,]$.\n- Group velocities $v$ in $\\mathrm{m}\\,\\mathrm{s}^{-1}$: $[\\, 6500,\\, 6000,\\, 3500,\\, 3200,\\, 3000,\\, 800,\\, 700,\\, 600 \\,]$.\n- Relaxation times $\\tau$ in $\\mathrm{s}$: $[\\, 2.5\\times 10^{-11},\\, 2.0\\times 10^{-11},\\, 1.4\\times 10^{-11},\\, 1.1\\times 10^{-11},\\, 0.9\\times 10^{-11},\\, 0.8\\times 10^{-12},\\, 0.6\\times 10^{-12},\\, 0.5\\times 10^{-12} \\,]$.\n- Weights $W$ in $\\mathrm{m}^{-3}$: $[\\, 1.2\\times 10^{27},\\, 1.0\\times 10^{27},\\, 1.1\\times 10^{27},\\, 1.1\\times 10^{27},\\, 0.9\\times 10^{27},\\, 0.7\\times 10^{27},\\, 0.6\\times 10^{27},\\, 0.5\\times 10^{27} \\,]$.\n\nTasks:\n1) From the fundamental base described above, derive the expression for the lattice thermal conductivity along one axis for this discretized mode set under the isotropic relaxation time approximation in terms of $C_j(T)$, $v_j$, and $\\tau_j$.\n\n2) Implement the derived expression to compute the baseline thermal conductivity $k(T)$ for a given temperature $T$ as a sum of mode contributions from the provided data.\n\n3) Define and apply the mode-selective scatterer that uniformly rescales $\\tau_j$ by the suppression factor $s$ for modes in a chosen branch $b \\in \\{0,1,2\\}$. Compute the change $\\Delta k = k_{\\mathrm{suppressed}} - k_{\\mathrm{baseline}}$.\n\n4) For a given suppression factor $s$, identify the most effective single branch $b^\\star \\in \\{0,1,2\\}$ to target that yields the largest magnitude reduction in thermal conductivity (i.e., the most negative $\\Delta k$). In the case of exact ties, choose the smallest branch index.\n\n5) For a given integer budget $L \\ge 1$, identify the $L$ individual modes $j$ whose suppression by the same factor $s$ would produce the largest reduction in $k$. In the case of exact ties, choose the smaller mode indices.\n\nTest suite and required outputs:\n- Case A (general): $T = 300$ $\\mathrm{K}$, suppression factor $s = 0.2$, apply suppression to branch $b = 1$. Output a two-element list $[\\Delta k,\\, b^\\star]$ where $\\Delta k$ is expressed in $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$ and rounded to six decimal places, and $b^\\star$ is the integer index of the best branch for the same suppression factor $s$.\n- Case B (low temperature edge): $T = 50$ $\\mathrm{K}$, suppression factor $s = 0.2$, apply suppression to branch $b = 2$. Output $[\\Delta k,\\, b^\\star]$ in the same format and units as Case A.\n- Case C (boundary condition): $T = 300$ $\\mathrm{K}$, suppression factor $s = 1.0$, apply suppression to branch $b = 0$. Output $[\\Delta k,\\, b^\\star]$ in the same format and units as Case A.\n- Case D (budgeted targeting across modes): $T = 300$ $\\mathrm{K}$, suppression factor $s = 0.1$, and budget $L = 3$. Output a list of the $L$ selected mode indices in descending order of their marginal reduction contributions.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order corresponding to Cases A through D: $[\\text{result\\_A}, \\text{result\\_B}, \\text{result\\_C}, \\text{result\\_D}]$, where each of $\\text{result\\_A}$, $\\text{result\\_B}$, and $\\text{result\\_C}$ is a two-element list $[\\Delta k, b^\\star]$ and $\\text{result\\_D}$ is a list of $L$ integers. Ensure that all $\\Delta k$ values are in $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$ rounded to six decimal places.",
            "solution": "The objective is to derive an expression for the lattice thermal conductivity from fundamental principles of phonon transport and subsequently apply it to analyze the effect of mode-selective scattering in a model isotropic crystal.\n\n### Step 1: Derivation of the Lattice Thermal Conductivity Expression\n\nThe analysis begins with the linearized steady-state phonon Boltzmann transport equation (BTE) under the relaxation time approximation (RTA). For a system under a small temperature gradient $\\nabla T$, the BTE describes the deviation of the phonon distribution function $n_j$ for a mode $j$ (with angular frequency $\\omega_j$ and group velocity vector $\\vec{v}_j$) from its equilibrium Bose-Einstein distribution $n_{0,j}$. The linearized steady-state BTE is:\n$$\n(\\vec{v}_j \\cdot \\nabla n_j)_{\\text{drift}} = \\left(\\frac{\\partial n_j}{\\partial t}\\right)_{\\text{scatt}}\n$$\nThe drift term for a steady state can be written using the chain rule as $\\vec{v}_j \\cdot \\nabla n_{0,j} = \\vec{v}_j \\cdot \\nabla T \\frac{\\partial n_{0,j}}{\\partial T}$. The scattering term under the RTA is given by $-\\frac{n_j - n_{0,j}}{\\tau_j}$, where $\\tau_j$ is the relaxation time of mode $j$. Equating the two gives:\n$$\n\\vec{v}_j \\cdot \\nabla T \\frac{\\partial n_{0,j}}{\\partial T} = -\\frac{n_j - n_{0,j}}{\\tau_j}\n$$\nThe perturbation in the occupation number, $n'_j = n_j - n_{0,j}$, is therefore:\n$$\nn'_j = -\\tau_j (\\vec{v}_j \\cdot \\nabla T) \\frac{\\partial n_{0,j}}{\\partial T}\n$$\nThe heat current density, $\\vec{J}$, is the sum of the contributions from all phonon modes. Each mode contributes its energy, $\\hbar \\omega_j$, carried at its group velocity, $\\vec{v}_j$. The net current arises only from the perturbation $n'_j$, as the equilibrium distribution carries no net heat current due to symmetry ($\\sum_j \\hbar \\omega_j \\vec{v}_j n_{0,j} = 0$). For a discrete set of modes representing the solid, the heat current density is:\n$$\n\\vec{J} = \\sum_j \\hbar \\omega_j \\vec{v}_j n'_j\n$$\nHere, the sum $\\sum_j$ implies a sum over mode states weighted by their density in phase space, effectively including the volume normalization factor. Substituting the expression for $n'_j$:\n$$\n\\vec{J} = \\sum_j \\hbar \\omega_j \\vec{v}_j \\left( -\\tau_j (\\vec{v}_j \\cdot \\nabla T) \\frac{\\partial n_{0,j}}{\\partial T} \\right) = -\\left( \\sum_j \\hbar \\omega_j \\frac{\\partial n_{0,j}}{\\partial T} \\tau_j (\\vec{v}_j \\otimes \\vec{v}_j) \\right) \\nabla T\n$$\nwhere $\\otimes$ denotes the outer product. By Fourier's law of heat conduction, $\\vec{J} = -\\hat{k} \\nabla T$, the thermal conductivity tensor $\\hat{k}$ is identified as:\n$$\n\\hat{k} = \\sum_j \\hbar \\omega_j \\frac{\\partial n_{0,j}}{\\partial T} \\tau_j (\\vec{v}_j \\otimes \\vec{v}_j)\n$$\nThe term $\\hbar \\omega_j \\frac{\\partial n_{0,j}}{\\partial T}$ is the contribution of a single phonon state of mode $j$ to the heat capacity. The problem provides the mode-resolved volumetric heat capacity, $C_j(T)$, which represents this quantity multiplied by the effective density of states for that mode, $W_j$. Specifically, $C_j(T) = W_j \\hbar \\omega_j \\frac{\\partial n_{0,j}}{\\partial T}$. This is consistent with the provided formula $C_j(T) = W_j k_{\\mathrm{B}} \\, \\phi(x_j)$, where $\\phi(x_j)$ with $x_j = \\hbar \\omega_j / (k_{\\mathrm{B}} T)$ is the Einstein heat capacity function, as $\\frac{\\partial n_{0,j}}{\\partial T} = \\frac{k_{\\mathrm{B}}}{\\hbar \\omega_j} \\phi(x_j)$. The sum $\\sum_j$ now runs over the given representative modes, with their contributions to the volumetric property already incorporated into $C_j(T)$.\n\nThe thermal conductivity along a single Cartesian axis, say $x$, is the diagonal component $k_{xx}$:\n$$\nk_{xx} = \\sum_j C_j(T) \\tau_j v_{j,x}^2\n$$\nFor an isotropic system, the velocity components are related to the magnitude by $\\langle v_{j,x}^2 \\rangle = \\langle v_{j,y}^2 \\rangle = \\langle v_{j,z}^2 \\rangle = v_j^2/3$. Applying this averaging to each mode's contribution, the expression for the scalar thermal conductivity $k$ becomes:\n$$\nk(T) = \\frac{1}{3} \\sum_j C_j(T) v_j^2 \\tau_j\n$$\nThis equation provides the required expression for the lattice thermal conductivity in terms of the given mode-resolved quantities $C_j(T)$, $v_j$, and $\\tau_j$. This completes Task 1.\n\n### Step 2: Algorithmic Implementation\n\nBased on the derived formula, the subsequent tasks can be implemented algorithmically.\n\n**Task 2 (Baseline Conductivity):** The baseline thermal conductivity, $k_{\\mathrm{baseline}}$, is computed by summing the individual contributions, $k_j = \\frac{1}{3} C_j(T) v_j^2 \\tau_j$, for all modes $j \\in \\{0, \\dots, 7\\}$ using the provided data and a given temperature $T$. The function $C_j(T)$ is evaluated using the provided expression involving $\\phi(x_j)$.\n\n**Task 3 (Suppression and $\\Delta k$):** The mode-selective scatterer modifies the relaxation time of modes within a target branch $b$ to $\\tau'_j = s \\cdot \\tau_j$. The suppressed thermal conductivity is $k_{\\mathrm{suppressed}} = \\frac{1}{3} \\sum_j C_j(T) v_j^2 \\tau'_j$. The change in thermal conductivity, $\\Delta k$, is $k_{\\mathrm{suppressed}} - k_{\\mathrm{baseline}}$. Since $k$ is linear in $\\tau_j$, this simplifies to:\n$$\n\\Delta k = k_{\\mathrm{suppressed}} - k_{\\mathrm{baseline}} = \\sum_{j \\in \\text{branch } b} \\frac{1}{3} C_j(T) v_j^2 (s \\tau_j - \\tau_j) = (s-1) \\sum_{j \\in \\text{branch } b} k_j\n$$\nwhere $k_j$ is the baseline contribution of mode $j$. This efficient formula is used for calculation.\n\n**Task 4 (Optimal Branch Targeting):** To find the branch $b^\\star$ that yields the most negative $\\Delta k$ for a given suppression factor $s  1$, we must maximize the magnitude $|\\Delta k|$. Since $\\Delta k = (s-1) \\sum_{j \\in \\text{branch } b} k_j$ and $(s-1)$ is a negative constant, this is equivalent to maximizing the sum of baseline contributions $\\sum_{j \\in \\text{branch } b} k_j$. The algorithm computes this sum for each branch ($b=0,1,2$) and identifies the branch with the largest total contribution. The tie-breaking rule (smallest branch index) is handled by the choice of search order or using `argmax`.\n\n**Task 5 (Optimal Mode Targeting):** For a budget of $L$ modes, the goal is to choose the $L$ modes that will produce the largest total reduction in $k$. The reduction from suppressing a single mode $j$ is $(s-1)k_j$. To maximize the total reduction, one must select the $L$ modes with the largest individual baseline contributions $k_j$. The algorithm calculates $k_j$ for all modes, sorts these contributions in descending order, and selects the first $L$ mode indices from this sorted list. The tie-breaking rule (smaller mode index first) is enforced by using a stable sort algorithm.\n\nThe numerical implementation requires the physical constants $\\hbar = 1.054571817 \\times 10^{-34}$ $\\mathrm{J}\\cdot\\mathrm{s}$ and $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}$ $\\mathrm{J}\\cdot\\mathrm{K}^{-1}$, and a numerically stable implementation of the function $\\phi(x) = \\frac{x^2 e^x}{(e^x - 1)^2}$, for which the form $\\phi(x) = \\left(\\frac{x/2}{\\sinh(x/2)}\\right)^2$ is suitable.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the thermal conductivity problem by deriving the expression and applying it\n    to the given data and test cases.\n    \"\"\"\n    \n    # Define physical constants\n    HBAR = 1.054571817e-34  # Reduced Planck constant in J*s\n    KB = 1.380649e-23      # Boltzmann constant in J/K\n\n    # Provided discrete mode data\n    BRANCHES = np.array([0, 0, 1, 1, 1, 2, 2, 2])\n    OMEGA = np.array([1.0e12, 1.5e12, 0.8e12, 1.2e12, 2.0e12, 8.0e13, 1.2e14, 1.6e14])  # rad/s\n    V = np.array([6500., 6000., 3500., 3200., 3000., 800., 700., 600.]) # m/s\n    TAU = np.array([2.5e-11, 2.0e-11, 1.4e-11, 1.1e-11, 0.9e-11, 0.8e-12, 0.6e-12, 0.5e-12]) # s\n    W = np.array([1.2e27, 1.0e27, 1.1e27, 1.1e27, 0.9e27, 0.7e27, 0.6e27, 0.5e27]) # m^-3\n\n    def phi(x):\n        \"\"\"\n        Numerically stable calculation of the heat capacity weighting function.\n        phi(x) = x^2 * exp(x) / (exp(x) - 1)^2\n        This is equivalent to (x/2 / sinh(x/2))^2.\n        \"\"\"\n        # Initialize result array with the limit value for x - 0, which is 1.\n        result = np.ones_like(x, dtype=float)\n        \n        # Create a mask for non-zero values to avoid division by zero.\n        non_zero_mask = (x != 0)\n        half_x_nz = x[non_zero_mask] / 2.0\n        \n        # Calculate for non-zero elements.\n        result[non_zero_mask] = (half_x_nz / np.sinh(half_x_nz))**2\n        return result\n\n    def calculate_k_contributions(T):\n        \"\"\"\n        Calculates the individual contribution of each mode to the thermal conductivity.\n        k_j = (1/3) * C_j * v_j^2 * tau_j\n        \"\"\"\n        if T = 0:\n            return np.zeros_like(OMEGA)\n            \n        # Calculate dimensionless frequency x_j = hbar*omega_j / (kB*T)\n        x = HBAR * OMEGA / (KB * T)\n        \n        # Calculate mode-resolved volumetric heat capacity C_j = W_j * kB * phi(x_j)\n        C = W * KB * phi(x)\n        \n        # Calculate mode contributions to thermal conductivity\n        k_contribs = (1.0 / 3.0) * C * (V**2) * TAU\n        return k_contribs\n\n    # --- Processing Test Cases ---\n    \n    results = []\n\n    # Case A: T=300K, s=0.2, target_branch=1\n    T_A = 300.0\n    s_A = 0.2\n    target_branch_A = 1\n    k_contribs_A = calculate_k_contributions(T_A)\n    # Calculate delta_k for branch 1\n    k_sum_branch_A = np.sum(k_contribs_A[BRANCHES == target_branch_A])\n    delta_k_A = (s_A - 1.0) * k_sum_branch_A\n    # Calculate b_star for T=300K\n    branch_contribs_A = [np.sum(k_contribs_A[BRANCHES == b]) for b in range(3)]\n    b_star_A = np.argmax(branch_contribs_A)\n    results.append(f\"[{delta_k_A:.6f},{b_star_A}]\")\n\n    # Case B: T=50K, s=0.2, target_branch=2\n    T_B = 50.0\n    s_B = 0.2\n    target_branch_B = 2\n    k_contribs_B = calculate_k_contributions(T_B)\n    # Calculate delta_k for branch 2\n    k_sum_branch_B = np.sum(k_contribs_B[BRANCHES == target_branch_B])\n    delta_k_B = (s_B - 1.0) * k_sum_branch_B\n    # Calculate b_star for T=50K\n    branch_contribs_B = [np.sum(k_contribs_B[BRANCHES == b]) for b in range(3)]\n    b_star_B = np.argmax(branch_contribs_B)\n    results.append(f\"[{delta_k_B:.6f},{b_star_B}]\")\n\n    # Case C: T=300K, s=1.0, target_branch=0\n    s_C = 1.0\n    # delta_k is guaranteed to be 0 since s=1.0\n    delta_k_C = 0.0\n    # b_star is the same as in Case A as T is the same.\n    b_star_C = b_star_A\n    results.append(f\"[{delta_k_C:.6f},{b_star_C}]\")\n\n    # Case D: T=300K, s=0.1, L=3\n    L_D = 3\n    # Use contributions from Case A calculation (T=300K)\n    k_contribs_D = k_contribs_A\n    # Get indices that sort contributions in descending order.\n    # 'stable' kind ensures that for ties, the smaller index comes first.\n    sorted_indices = np.argsort(-k_contribs_D, kind='stable')\n    best_L_modes = sorted_indices[:L_D]\n    result_D_str = f\"[{','.join(map(str, best_L_modes))}]\"\n    results.append(result_D_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The Relaxation Time Approximation (RTA) is a powerful simplification, but it can fail to capture the complex interplay of different scattering events. To go beyond the RTA, the linearized BTE must be solved as a full matrix equation, often written as $L \\boldsymbol{\\phi} = \\mathbf{v}$. This exercise  dives into the numerical heart of modern BTE solvers by having you implement and compare the convergence of a simple fixed-point iteration with the more sophisticated Conjugate Gradient method, illustrating the importance of efficient linear algebra in tackling complex transport problems.",
            "id": "3495072",
            "problem": "Implement a mathematically self-contained two-branch toy model for the Linearized Boltzmann Transport Equation (LBTE) in a crystalline solid to compare the convergence behavior of a basic fixed-point (Richardson) iteration versus the Conjugate Gradient method when computing the thermal conductivity along a single Cartesian direction. The model shall be purely linear-algebraic and use physically plausible parameters.\n\nStart from the standard linear-response formulation of the phonon LBTE in steady state, linearized with respect to a small temperature gradient. Model the collision (scattering) operator as a symmetric positive definite matrix that acts on a vector of unknown modal displacements. For a set of phonon modes indexed by $i$, define the following toy LBTE:\n$$\n\\mathbf{M}\\,\\boldsymbol{\\phi} = \\mathbf{v},\n$$\nwhere $\\mathbf{M}\\in\\mathbb{R}^{m\\times m}$ is symmetric positive definite and represents the linearized collision operator, $\\boldsymbol{\\phi}\\in\\mathbb{R}^{m}$ is the unknown vector of displacement-like response amplitudes along the transport direction, and $\\mathbf{v}\\in\\mathbb{R}^{m}$ is the vector of group velocities along that direction. The thermal conductivity $k$ along this direction is then computed from the solution $\\boldsymbol{\\phi}$ as\n$$\nk = \\sum_{i=1}^{m} C_i\\, v_i\\, \\phi_i,\n$$\nwhere $C_i$ is the volumetric modal heat capacity.\n\nConstruct $\\mathbf{M}$ for a two-branch system with $N$ modes per branch (total $m=2N$ modes) by combining mode-resolved relaxation times with inter-branch coupling at matched wavevector indices. Specifically, let the diagonal part be given by mode-resolved scattering rates $1/\\tau_i$ and let the inter-branch coupling between matched modes be parameterized by a nonnegative scalar $\\gamma$. Define\n$$\n\\mathbf{M} = \\operatorname{diag}\\!\\big(1/\\tau_1, \\dots, 1/\\tau_m\\big) + \\gamma\\,\\mathbf{L},\n$$\nwhere $\\mathbf{L}$ is block-diagonal across wavevector indices with each $2\\times 2$ block coupling the two branches for the same discrete wavevector $k$ as\n$$\n\\mathbf{L}_k=\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}.\n$$\nThis choice ensures that $\\mathbf{M}$ is symmetric positive definite for $\\tau_i0$ and $\\gamma\\ge 0$.\n\nYou must implement two solvers for the linear system:\n- Fixed-point (Richardson) iteration:\n  $$\n  \\boldsymbol{\\phi}^{(n+1)}=\\boldsymbol{\\phi}^{(n)} + \\omega\\,\\big(\\mathbf{v}-\\mathbf{M}\\boldsymbol{\\phi}^{(n)}\\big),\n  $$\n  with $\\boldsymbol{\\phi}^{(0)}=\\mathbf{0}$ and a stepsize $\\omega$ chosen as\n  $$\n  \\omega=\\frac{0.99}{\\lambda_{\\max}(\\mathbf{M})},\n  $$\n  where $\\lambda_{\\max}(\\mathbf{M})$ is the largest eigenvalue of $\\mathbf{M}$, to be estimated numerically by power iteration.\n- Conjugate Gradient (CG) method without preconditioning, initialized at $\\boldsymbol{\\phi}^{(0)}=\\mathbf{0}$.\n\nBoth solvers must terminate when the relative residual norm satisfies\n$$\n\\frac{\\|\\mathbf{v}-\\mathbf{M}\\boldsymbol{\\phi}\\|_2}{\\|\\mathbf{v}\\|_2}\\le \\varepsilon,\n$$\nwith tolerance $\\varepsilon=10^{-10}$, or a hard cap of $10^{6}$ iterations for the fixed-point method and $10^{4}$ iterations for Conjugate Gradient, whichever occurs first.\n\nAfter solving, compute $k$ using the converged solution $\\boldsymbol{\\phi}$ and report it in $\\mathrm{W\\,m^{-1}\\,K^{-1}}$. For a fair comparison, compute and report the iteration counts for both methods using the same tolerance.\n\nImplement your program to evaluate the following three test cases (each with $N=6$ so $m=12$), representing different conditioning and coupling regimes. For each case, define the per-branch velocities $\\mathbf{v}^{(\\mathrm{ac})}$ and $\\mathbf{v}^{(\\mathrm{op})}$ in $\\mathrm{m\\,s^{-1}}$, per-mode volumetric heat capacities $C^{(\\mathrm{ac})}$ and $C^{(\\mathrm{op})}$ in $\\mathrm{J\\,m^{-3}\\,K^{-1}}$ (constant within each branch), per-mode relaxation times $\\boldsymbol{\\tau}^{(\\mathrm{ac})}$ and $\\boldsymbol{\\tau}^{(\\mathrm{op})}$ in $\\mathrm{ps}$, and coupling $\\gamma$ in $\\mathrm{s^{-1}}$. Use $1\\,\\mathrm{ps}=1\\times 10^{-12}\\,\\mathrm{s}$.\n\n- Case A (well-conditioned, moderate coupling):\n  - $\\mathbf{v}^{(\\mathrm{ac})} = [3.0\\times 10^{3},\\,3.2\\times 10^{3},\\,3.4\\times 10^{3},\\,3.6\\times 10^{3},\\,3.8\\times 10^{3},\\,4.0\\times 10^{3}]\\,\\mathrm{m\\,s^{-1}}$,\n  - $\\mathbf{v}^{(\\mathrm{op})} = [0.5\\times 10^{3},\\,0.6\\times 10^{3},\\,0.7\\times 10^{3},\\,0.8\\times 10^{3},\\,0.9\\times 10^{3},\\,1.0\\times 10^{3}]\\,\\mathrm{m\\,s^{-1}}$,\n  - $C^{(\\mathrm{ac})} = 1.2\\times 10^{5}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}$ per mode, $C^{(\\mathrm{op})} = 2.0\\times 10^{5}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}$ per mode,\n  - $\\boldsymbol{\\tau}^{(\\mathrm{ac})} = [20,\\,18,\\,16,\\,14,\\,12,\\,10]\\,\\mathrm{ps}$,\n  - $\\boldsymbol{\\tau}^{(\\mathrm{op})} = [5,\\,5,\\,5,\\,5,\\,5,\\,5]\\,\\mathrm{ps}$,\n  - $\\gamma = 0.2\\times 10^{12}\\,\\mathrm{s^{-1}}$.\n\n- Case B (ill-conditioned, strong coupling and broad lifetime contrast):\n  - $\\mathbf{v}^{(\\mathrm{ac})} = [2.5\\times 10^{3},\\,3.0\\times 10^{3},\\,3.5\\times 10^{3},\\,4.0\\times 10^{3},\\,4.5\\times 10^{3},\\,5.0\\times 10^{3}]\\,\\mathrm{m\\,s^{-1}}$,\n  - $\\mathbf{v}^{(\\mathrm{op})} = [0.3\\times 10^{3},\\,0.4\\times 10^{3},\\,0.5\\times 10^{3},\\,0.6\\times 10^{3},\\,0.7\\times 10^{3},\\,0.8\\times 10^{3}]\\,\\mathrm{m\\,s^{-1}}$,\n  - $C^{(\\mathrm{ac})} = 1.0\\times 10^{5}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}$ per mode, $C^{(\\mathrm{op})} = 2.0\\times 10^{5}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}$ per mode,\n  - $\\boldsymbol{\\tau}^{(\\mathrm{ac})} = [200,\\,150,\\,100,\\,80,\\,60,\\,50]\\,\\mathrm{ps}$,\n  - $\\boldsymbol{\\tau}^{(\\mathrm{op})} = [1,\\,1.2,\\,1.5,\\,2,\\,2.5,\\,3]\\,\\mathrm{ps}$,\n  - $\\gamma = 5.0\\times 10^{12}\\,\\mathrm{s^{-1}}$.\n\n- Case C (nearly singular diagonal due to long lifetimes, weak coupling):\n  - $\\mathbf{v}^{(\\mathrm{ac})} = [2.0\\times 10^{3},\\,2.2\\times 10^{3},\\,2.4\\times 10^{3},\\,2.6\\times 10^{3},\\,2.8\\times 10^{3},\\,3.0\\times 10^{3}]\\,\\mathrm{m\\,s^{-1}}$,\n  - $\\mathbf{v}^{(\\mathrm{op})} = [0.4\\times 10^{3},\\,0.5\\times 10^{3},\\,0.6\\times 10^{3},\\,0.7\\times 10^{3},\\,0.8\\times 10^{3},\\,0.9\\times 10^{3}]\\,\\mathrm{m\\,s^{-1}}$,\n  - $C^{(\\mathrm{ac})} = 1.3\\times 10^{5}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}$ per mode, $C^{(\\mathrm{op})} = 1.7\\times 10^{5}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}$ per mode,\n  - $\\boldsymbol{\\tau}^{(\\mathrm{ac})} = [5000,\\,2000,\\,1000,\\,500,\\,200,\\,100]\\,\\mathrm{ps}$,\n  - $\\boldsymbol{\\tau}^{(\\mathrm{op})} = [20,\\,20,\\,20,\\,20,\\,20,\\,20]\\,\\mathrm{ps}$,\n  - $\\gamma = 0.05\\times 10^{12}\\,\\mathrm{s^{-1}}$.\n\nFor each case:\n- Assemble $\\mathbf{M}$ in $\\mathrm{s^{-1}}$ using the given $\\tau_i$ (converted from $\\mathrm{ps}$ to $\\mathrm{s}$) and $\\gamma$.\n- Assemble $\\mathbf{v}$ by concatenating the acoustic and optical branch velocities.\n- Assemble $\\mathbf{C}$ as a vector with the branch-wise per-mode constants.\n\nSolve $\\mathbf{M}\\,\\boldsymbol{\\phi}=\\mathbf{v}$ using both solvers with the specified stopping criteria. Compute $k=\\sum_i C_i v_i \\phi_i$ in $\\mathrm{W\\,m^{-1}\\,K^{-1}}$. Report, for each case, the triple $[k,\\; n_{\\mathrm{FP}},\\; n_{\\mathrm{CG}}]$, where $n_{\\mathrm{FP}}$ and $n_{\\mathrm{CG}}$ are the iteration counts until convergence for the fixed-point and Conjugate Gradient methods, respectively. Express $k$ in $\\mathrm{W\\,m^{-1}\\,K^{-1}}$, rounded to six decimal places.\n\nFinal output format: Your program should produce a single line of output containing the results for the three cases as a comma-separated list of three bracketed triples with no whitespace, enclosed in a single pair of square brackets, for example,\n$$\n\\big[ [k_A,n_{\\mathrm{FP},A},n_{\\mathrm{CG},A}], [k_B,n_{\\mathrm{FP},B},n_{\\mathrm{CG},B}], [k_C,n_{\\mathrm{FP},C},n_{\\mathrm{CG},C}] \\big],\n$$\nbut with no spaces. The program must not read any input and must not print anything else.",
            "solution": "The problem is valid. It presents a scientifically grounded and mathematically well-posed toy model for computing thermal conductivity in a crystalline solid. All parameters, equations, and numerical procedures are explicitly defined, allowing for a unique and verifiable solution.\n\nThe core of the problem is to solve the linear system of equations $\\mathbf{M}\\boldsymbol{\\phi} = \\mathbf{v}$ for the unknown vector $\\boldsymbol{\\phi}$, and then to compute the thermal conductivity $k$. The problem is set in the context of the phonon Boltzmann transport equation (BTE), where $\\mathbf{M}$ represents the linearized collision operator, $\\mathbf{v}$ is the vector of phonon group velocities along the transport direction, and $\\boldsymbol{\\phi}$ is the vector of modal deviations from equilibrium. The thermal conductivity is given by $k = \\sum_{i=1}^{m} C_i v_i \\phi_i$, where $C_i$ is the volumetric modal heat capacity.\n\nThe model consists of $m=2N$ phonon modes, with $N=6$ modes in an acoustic branch and $N=6$ in an optical branch, for a total of $m=12$ modes. The vectors for velocity $\\mathbf{v}$, heat capacity $\\mathbf{C}$, and relaxation time $\\boldsymbol{\\tau}$ are constructed by interleaving the data from the acoustic and optical branches. For an index $i$ from $0$ to $N-1$, the system modes $2i$ and $2i+1$ correspond to the $i$-th acoustic and $i$-th optical modes, respectively. All input parameters are converted to base SI units for consistency. Specifically, relaxation times $\\tau_i$ given in picoseconds ($ps$) are converted to seconds ($s$) by multiplying by $1 \\times 10^{-12}$.\n\nThe $m \\times m$ matrix $\\mathbf{M}$ is assembled as specified:\n$$\n\\mathbf{M} = \\operatorname{diag}\\!\\big(1/\\tau_1, \\dots, 1/\\tau_m\\big) + \\gamma\\,\\mathbf{L}\n$$\nThe first term is a diagonal matrix of inverse relaxation times (scattering rates). The second term introduces coupling between the acoustic and optical modes at the same wavevector index. The coupling strength is given by $\\gamma \\ge 0$. The matrix $\\mathbf{L}$ is block-diagonal, composed of $N$ identical $2 \\times 2$ blocks $\\mathbf{L}_k=\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}$ along its main diagonal. This construction ensures that $\\mathbf{M}$ is a symmetric positive-definite (SPD) matrix, which guarantees that a unique solution exists and that the iterative solution methods are applicable.\n\nTwo iterative methods are implemented to solve for $\\boldsymbol{\\phi}$, both starting from an initial guess of $\\boldsymbol{\\phi}^{(0)} = \\mathbf{0}$:\n\n1.  **Fixed-Point (Richardson) Iteration**: The solution is updated via the scheme\n    $$\n    \\boldsymbol{\\phi}^{(n+1)} = \\boldsymbol{\\phi}^{(n)} + \\omega\\,\\big(\\mathbf{v}-\\mathbf{M}\\boldsymbol{\\phi}^{(n)}\\big)\n    $$\n    Convergence is guaranteed by selecting the step size $\\omega$ such that the spectral radius of the iteration matrix $\\mathbf{I} - \\omega\\mathbf{M}$ is less than $1$. The prescribed choice is $\\omega = 0.99 / \\lambda_{\\max}(\\mathbf{M})$, where $\\lambda_{\\max}(\\mathbf{M})$ is the largest eigenvalue of $\\mathbf{M}$. This value is estimated numerically using the power iteration method, which is suitable for finding the largest-magnitude eigenvalue of a matrix.\n\n2.  **Conjugate Gradient (CG) Method**: A standard, non-preconditioned CG algorithm is implemented. This method is highly effective for large, sparse SPD systems, as it is guaranteed to find the exact solution in at most $m$ iterations in exact arithmetic and often converges much faster in practice. It constructs a sequence of M-orthogonal search directions to minimize the error.\n\nBoth solvers terminate when the relative residual norm, defined as $\\frac{\\|\\mathbf{v}-\\mathbf{M}\\boldsymbol{\\phi}\\|_2}{\\|\\mathbf{v}\\|_2}$, falls below a tolerance of $\\varepsilon=10^{-10}$, or when a maximum number of iterations ($10^6$ for fixed-point, $10^4$ for CG) is reached.\n\nAfter obtaining the converged solution vector $\\boldsymbol{\\phi}$ (using the result from the more robust CG method), the thermal conductivity $k$ is calculated as the dot product of the vector $(C_1v_1, C_2v_2, \\dots, C_mv_m)$ and $\\boldsymbol{\\phi}$. The units of the calculation are consistent, yielding $k$ in $\\mathrm{W\\,m^{-1}\\,K^{-1}}$.\n\nThe entire procedure is applied to three test cases, each with different physical parameters representing distinct conditioning regimes of the matrix $\\mathbf{M}$. The final output for each case is a triplet containing the calculated thermal conductivity $k$ (rounded to six decimal places), the number of iterations for the fixed-point method $n_{\\mathrm{FP}}$, and the number of iterations for the CG method $n_{\\mathrm{CG}}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef power_iteration(A, tol=1e-8, max_iter=1000):\n    \"\"\"\n    Estimates the largest eigenvalue of a symmetric matrix using the power iteration method.\n    \"\"\"\n    # Use a reproducible random vector to avoid issues with orthogonality to the dominant eigenvector.\n    # Seeding is done within the function for local reproducibility.\n    # This is a detail of the specific algorithm implementation.\n    rng = np.random.default_rng(seed=0)\n    b_k = rng.random(A.shape[1])\n    b_k = b_k / np.linalg.norm(b_k)\n\n    lambda_old = 0.0\n    for _ in range(max_iter):\n        # Matrix-vector product\n        Ab = A @ b_k\n        \n        # Re-normalize the vector\n        Ab_norm = np.linalg.norm(Ab)\n        if Ab_norm == 0:\n            return 0.0\n        b_k = Ab / Ab_norm\n        \n        # Rayleigh quotient for eigenvalue estimation\n        lambda_new = b_k.T @ A @ b_k\n        \n        if np.abs(lambda_new - lambda_old)  tol:\n            break\n        lambda_old = lambda_new\n            \n    return lambda_new\n\ndef richardson_solver(M, v, tol, max_iter):\n    \"\"\"\n    Solves the system M*phi = v using the fixed-point (Richardson) iteration.\n    \"\"\"\n    m = M.shape[0]\n    phi = np.zeros(m)\n    \n    lambda_max = power_iteration(M)\n    # If lambda_max is zero, M is a zero matrix. If v is also zero, phi=0 is a solution.\n    # Otherwise, no solution or omega would be infinite.\n    if lambda_max == 0:\n        return phi, 0\n    omega = 0.99 / lambda_max\n\n    v_norm = np.linalg.norm(v)\n    if v_norm == 0:\n        return phi, 0\n\n    for i in range(max_iter):\n        residual = v - M @ phi\n        rel_res_norm = np.linalg.norm(residual) / v_norm\n        \n        if rel_res_norm = tol:\n            return phi, i\n        \n        phi += omega * residual\n        \n    return phi, max_iter\n\ndef cg_solver(M, v, tol, max_iter):\n    \"\"\"\n    Solves the system M*phi = v using the Conjugate Gradient method.\n    \"\"\"\n    m = M.shape[0]\n    phi = np.zeros(m)\n    \n    r = v - M @ phi\n    p = r.copy()\n    rs_old = np.dot(r, r)\n\n    v_norm = np.linalg.norm(v)\n    if v_norm == 0:\n        return phi, 0\n\n    # Check initial residual; if the initial guess is sufficient, 0 iterations were needed.\n    if np.sqrt(rs_old) / v_norm = tol:\n        return phi, 0\n\n    for i in range(max_iter):\n        Ap = M @ p\n        alpha = rs_old / np.dot(p, Ap)\n        \n        phi += alpha * p\n        r -= alpha * Ap\n        \n        rel_res_norm = np.linalg.norm(r) / v_norm\n        if rel_res_norm = tol:\n            return phi, i + 1\n\n        rs_new = np.dot(r, r)\n        if rs_old == 0: # Should not happen if residual is not small enough, but for safety\n             break\n        p = r + (rs_new / rs_old) * p\n        rs_old = rs_new\n        \n    return phi, max_iter\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (well-conditioned, moderate coupling)\n        {\n            \"N\": 6,\n            \"v_ac\": np.array([3.0e3, 3.2e3, 3.4e3, 3.6e3, 3.8e3, 4.0e3]),\n            \"v_op\": np.array([0.5e3, 0.6e3, 0.7e3, 0.8e3, 0.9e3, 1.0e3]),\n            \"C_ac\": 1.2e5, \"C_op\": 2.0e5,\n            \"tau_ac\": np.array([20, 18, 16, 14, 12, 10]),\n            \"tau_op\": np.array([5, 5, 5, 5, 5, 5]),\n            \"gamma\": 0.2e12\n        },\n        # Case B (ill-conditioned, strong coupling and broad lifetime contrast)\n        {\n            \"N\": 6,\n            \"v_ac\": np.array([2.5e3, 3.0e3, 3.5e3, 4.0e3, 4.5e3, 5.0e3]),\n            \"v_op\": np.array([0.3e3, 0.4e3, 0.5e3, 0.6e3, 0.7e3, 0.8e3]),\n            \"C_ac\": 1.0e5, \"C_op\": 2.0e5,\n            \"tau_ac\": np.array([200, 150, 100, 80, 60, 50]),\n            \"tau_op\": np.array([1, 1.2, 1.5, 2, 2.5, 3]),\n            \"gamma\": 5.0e12\n        },\n        # Case C (nearly singular diagonal due to long lifetimes, weak coupling)\n        {\n            \"N\": 6,\n            \"v_ac\": np.array([2.0e3, 2.2e3, 2.4e3, 2.6e3, 2.8e3, 3.0e3]),\n            \"v_op\": np.array([0.4e3, 0.5e3, 0.6e3, 0.7e3, 0.8e3, 0.9e3]),\n            \"C_ac\": 1.3e5, \"C_op\": 1.7e5,\n            \"tau_ac\": np.array([5000, 2000, 1000, 500, 200, 100]),\n            \"tau_op\": np.array([20, 20, 20, 20, 20, 20]),\n            \"gamma\": 0.05e12\n        }\n    ]\n\n    results = []\n    \n    tol = 1e-10\n    max_iter_fp = 1000000\n    max_iter_cg = 10000\n    ps_to_s = 1e-12\n\n    for case in test_cases:\n        N = case[\"N\"]\n        m = 2 * N\n        \n        # Assemble interleaved vectors v, C, tau\n        v = np.zeros(m)\n        C = np.zeros(m)\n        tau = np.zeros(m)\n        \n        v[0::2] = case[\"v_ac\"]\n        v[1::2] = case[\"v_op\"]\n        \n        C[0::2] = case[\"C_ac\"]\n        C[1::2] = case[\"C_op\"]\n        \n        tau[0::2] = case[\"tau_ac\"] * ps_to_s\n        tau[1::2] = case[\"tau_op\"] * ps_to_s\n        \n        # Assemble collision matrix M\n        M = np.diag(1.0 / tau)\n        \n        gamma = case[\"gamma\"]\n        L_block = np.array([[1, -1], [-1, 1]])\n        for i in range(N):\n            M[2*i:2*i+2, 2*i:2*i+2] += gamma * L_block\n            \n        # Solve with fixed-point (Richardson)\n        _, n_fp = richardson_solver(M, v, tol, max_iter_fp)\n\n        # Solve with Conjugate Gradient\n        phi_cg, n_cg = cg_solver(M, v, tol, max_iter_cg)\n        \n        # Calculate thermal conductivity k using the CG solution\n        k = np.dot(C * v, phi_cg)\n        \n        results.append(f\"[{k:.6f},{n_fp},{n_cg}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}