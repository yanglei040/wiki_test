{
    "hands_on_practices": [
        {
            "introduction": "A crucial first step in any molecular dynamics simulation is defining a simulation cell that is large enough to contain the physical phenomena of interest without introducing artifacts from periodic boundary conditions. This exercise guides you through developing a criterion for the minimum box size in a displacement cascade simulation by modeling the cascade as a two-stage process: an initial ballistic core followed by a diffusive thermal spike. By deriving the relationship between the cascade's spatial extent and the simulation box length, you will gain practical insight into how to ensure your simulation results are physically meaningful .",
            "id": "3484027",
            "problem": "A molecular dynamics simulation of a displacement cascade in a crystalline solid is performed using periodic boundary conditions (PBC). To avoid spurious interactions between the cascade and its periodic images, the simulation cell must be large enough that the cascade-induced region of atomic redistribution does not overlap with that of its nearest periodic image during the entire event. Consider the following physically motivated model:\n\n- The ballistic phase of the cascade instantaneously creates a core of displacements within an approximately spherical region of radius $R_{c}$.\n- During the subsequent thermal spike of duration $\\tau_{\\mathrm{ts}}$, atoms inside the transiently disordered region undergo liquid-like self-diffusion that is well approximated as Fickian diffusion with an effective self-diffusion coefficient $D_{\\mathrm{liq}}$, assumed constant over $\\tau_{\\mathrm{ts}}$.\n- The simulation box is cubic with edge length $L$, so the nearest-image separation is $L$.\n\nAdopt the following non-overlap criterion: the effective radial extent of the cascade, defined as the ballistic radius plus one root-mean-square diffusion length accumulated during the thermal spike, must be strictly less than half the nearest-image separation. Starting from the diffusion equation and the definition of the mean-squared displacement, derive an expression for the minimal box length $L_{\\min}$ satisfying this criterion in terms of $R_{c}$, $D_{\\mathrm{liq}}$, and $\\tau_{\\mathrm{ts}}$. Then evaluate $L_{\\min}$ for the parameters $R_{c} = 4.2 \\ \\text{nm}$, $D_{\\mathrm{liq}} = 2.5 \\times 10^{-8} \\ \\text{m}^{2} \\ \\text{s}^{-1}$, and $\\tau_{\\mathrm{ts}} = 12 \\ \\text{ps}$. Express your final result in nanometers and round your answer to three significant figures.",
            "solution": "The problem is first validated to ensure it is scientifically sound, well-posed, and complete.\n\n### Step 1: Extract Givens\n- **System**: A molecular dynamics simulation of a displacement cascade in a crystalline solid.\n- **Boundary Conditions**: Periodic boundary conditions (PBC).\n- **Simulation Box**: Cubic with edge length $L$.\n- **Nearest-Image Separation**: $L$.\n- **Cascade Model**:\n    - An initial ballistic phase creates a spherical core of displacements with radius $R_{c}$.\n    - A subsequent thermal spike phase of duration $\\tau_{\\mathrm{ts}}$ occurs.\n    - During the thermal spike, atomic self-diffusion is modeled as Fickian diffusion with a constant coefficient $D_{\\mathrm{liq}}$.\n- **Non-Overlap Criterion**: The effective radial extent of the cascade must be strictly less than half the nearest-image separation.\n- **Definition of Effective Radial Extent**: $R_{\\mathrm{eff}} = R_{c} + \\ell_{\\mathrm{rms}}$, where $\\ell_{\\mathrm{rms}}$ is one root-mean-square diffusion length accumulated during the thermal spike.\n- **Task**:\n    1. Derive an expression for the minimal box length $L_{\\min}$ in terms of $R_{c}$, $D_{\\mathrm{liq}}$, and $\\tau_{\\mathrm{ts}}$.\n    2. Evaluate $L_{\\min}$ for the parameters $R_{c} = 4.2 \\ \\text{nm}$, $D_{\\mathrm{liq}} = 2.5 \\times 10^{-8} \\ \\text{m}^{2} \\ \\text{s}^{-1}$, and $\\tau_{\\mathrm{ts}} = 12 \\ \\text{ps}$.\n- **Final Result Specification**: Express the final numerical answer in nanometers, rounded to three significant figures.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is well-grounded in the principles of computational materials science and statistical physics. The model described (ballistic phase followed by a thermal spike with Fickian diffusion) is a standard and physically motivated simplification used to analyze displacement cascades. The use of PBC and the concern for finite-size effects (spurious image interactions) are central to the practice of molecular dynamics simulations.\n- **Well-Posed**: The problem is well-posed. It provides a clear, quantitative criterion and sufficient data to derive a unique expression for $L_{\\min}$ and then calculate its numerical value.\n- **Objective**: The problem is stated using objective, precise scientific language.\n- **Completeness and Consistency**: The problem is self-contained. All necessary variables and constants are defined, and their values are provided for the numerical part. The units are consistent, although they require conversion for the final calculation. There are no contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\n\nThe problem requires deriving an expression for the minimal simulation box length, $L_{\\min}$, based on a non-overlap criterion.\n\nThe non-overlap criterion states that the effective radial extent of the cascade, $R_{\\mathrm{eff}}$, must be strictly less than half the nearest-image separation, which is $\\frac{L}{2}$.\n$$ R_{\\mathrm{eff}} < \\frac{L}{2} $$\nThe effective radial extent is defined as the sum of the ballistic core radius, $R_{c}$, and one root-mean-square diffusion length, $\\ell_{\\mathrm{rms}}$.\n$$ R_{\\mathrm{eff}} = R_{c} + \\ell_{\\mathrm{rms}} $$\nSubstituting this definition into the criterion gives:\n$$ R_{c} + \\ell_{\\mathrm{rms}} < \\frac{L}{2} $$\nThe minimal box length, $L_{\\min}$, corresponds to the boundary of this condition:\n$$ \\frac{L_{\\min}}{2} = R_{c} + \\ell_{\\mathrm{rms}} $$\n$$ L_{\\min} = 2(R_{c} + \\ell_{\\mathrm{rms}}) $$\nTo proceed, we must find an expression for $\\ell_{\\mathrm{rms}}$. The root-mean-square diffusion length is the square root of the mean-squared displacement (MSD), $\\langle r^{2} \\rangle$. For diffusion occurring over a time $\\tau_{\\mathrm{ts}}$, we have:\n$$ \\ell_{\\mathrm{rms}} = \\sqrt{\\langle r^{2}(\\tau_{\\mathrm{ts}}) \\rangle} $$\nThe problem states that we must start from the diffusion equation to determine the MSD. The diffusion equation, or Fick's second law, for the concentration of diffusing particles, $C(\\mathbf{r}, t)$, is:\n$$ \\frac{\\partial C(\\mathbf{r}, t)}{\\partial t} = D_{\\mathrm{liq}} \\nabla^{2} C(\\mathbf{r}, t) $$\nThe mean-squared displacement in three dimensions is defined as the second moment of the position vector $\\mathbf{r}$:\n$$ \\langle r^{2}(t) \\rangle = \\int r^{2} C(\\mathbf{r}, t) \\, dV $$\nwhere the integral is over all space. We assume the concentration profile is normalized, such that $\\int C(\\mathbf{r}, t) \\, dV = 1$. To find the time evolution of the MSD, we differentiate with respect to time:\n$$ \\frac{d}{dt} \\langle r^{2}(t) \\rangle = \\int r^{2} \\frac{\\partial C(\\mathbf{r}, t)}{\\partial t} \\, dV $$\nSubstituting the diffusion equation:\n$$ \\frac{d}{dt} \\langle r^{2}(t) \\rangle = \\int r^{2} (D_{\\mathrm{liq}} \\nabla^{2} C) \\, dV = D_{\\mathrm{liq}} \\int r^{2} (\\nabla \\cdot \\nabla C) \\, dV $$\nWe use integration by parts in three dimensions, in the form $\\int u (\\nabla \\cdot \\mathbf{F}) dV = \\oint_{\\partial V} u \\mathbf{F} \\cdot d\\mathbf{S} - \\int (\\nabla u) \\cdot \\mathbf{F} dV$. Let $u = r^{2}$ and $\\mathbf{F} = \\nabla C$. The integral is over all space, so the boundary $\\partial V$ is at infinity. Since $C$ and its gradient $\\nabla C$ must vanish at infinity for a localized distribution, the surface integral is zero.\n$$ \\int r^{2} (\\nabla \\cdot \\nabla C) \\, dV = - \\int (\\nabla r^{2}) \\cdot (\\nabla C) \\, dV $$\nThe gradient of $r^{2} = x^{2} + y^{2} + z^{2}$ is $\\nabla r^{2} = 2x\\hat{\\mathbf{i}} + 2y\\hat{\\mathbf{j}} + 2z\\hat{\\mathbf{k}} = 2\\mathbf{r}$.\n$$ \\int r^{2} (\\nabla^{2} C) \\, dV = - \\int (2\\mathbf{r}) \\cdot (\\nabla C) \\, dV = -2 \\int \\mathbf{r} \\cdot (\\nabla C) \\, dV $$\nWe apply integration by parts a second time to the remaining integral. Let $u=C$ and $\\mathbf{F}=\\mathbf{r}$. The form is $\\int \\mathbf{F} \\cdot (\\nabla u) dV = \\oint_{\\partial V} u\\mathbf{F} \\cdot d\\mathbf{S} - \\int u(\\nabla \\cdot \\mathbf{F}) dV$. Again, the surface integral at infinity is zero.\n$$ \\int \\mathbf{r} \\cdot (\\nabla C) \\, dV = - \\int C (\\nabla \\cdot \\mathbf{r}) \\, dV $$\nThe divergence of the position vector in three dimensions is $\\nabla \\cdot \\mathbf{r} = \\frac{\\partial x}{\\partial x} + \\frac{\\partial y}{\\partial y} + \\frac{\\partial z}{\\partial z} = 1+1+1 = 3$.\n$$ \\int \\mathbf{r} \\cdot (\\nabla C) \\, dV = - \\int C (3) \\, dV = -3 \\int C \\, dV $$\nSince the concentration is normalized, $\\int C \\, dV = 1$. Thus, $\\int \\mathbf{r} \\cdot (\\nabla C) \\, dV = -3$.\nSubstituting this back, we find:\n$$ \\int r^{2} (\\nabla^{2} C) \\, dV = -2(-3) = 6 $$\nNow we can complete the expression for the time derivative of the MSD:\n$$ \\frac{d}{dt} \\langle r^{2}(t) \\rangle = D_{\\mathrm{liq}} (6) = 6D_{\\mathrm{liq}} $$\nIntegrating this ordinary differential equation from $t=0$ to $t=\\tau_{\\mathrm{ts}}$, assuming the initial displacement is zero ($\\langle r^{2}(0) \\rangle = 0$ for the diffusive part), we get the Einstein-Smoluchowski relation in three dimensions:\n$$ \\langle r^{2}(\\tau_{\\mathrm{ts}}) \\rangle = 6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}} $$\nThe root-mean-square diffusion length is therefore:\n$$ \\ell_{\\mathrm{rms}} = \\sqrt{6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}}} $$\nFinally, we substitute this expression into our equation for $L_{\\min}$:\n$$ L_{\\min} = 2(R_{c} + \\sqrt{6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}}}) $$\nThis is the required symbolic expression for the minimal box length.\n\n### Numerical Evaluation\nNext, we evaluate $L_{\\min}$ using the provided parameters. First, we must ensure all units are consistent. We will convert all quantities to SI units (meters, seconds).\n\n- $R_{c} = 4.2 \\ \\text{nm} = 4.2 \\times 10^{-9} \\ \\text{m}$\n- $D_{\\mathrm{liq}} = 2.5 \\times 10^{-8} \\ \\text{m}^{2} \\ \\text{s}^{-1}$\n- $\\tau_{\\mathrm{ts}} = 12 \\ \\text{ps} = 12 \\times 10^{-12} \\ \\text{s}$\n\nFirst, we calculate the argument of the square root:\n$$ 6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}} = 6 \\times (2.5 \\times 10^{-8} \\ \\text{m}^{2} \\ \\text{s}^{-1}) \\times (12 \\times 10^{-12} \\ \\text{s}) $$\n$$ 6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}} = (15 \\times 10^{-8}) \\times (12 \\times 10^{-12}) \\ \\text{m}^{2} $$\n$$ 6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}} = 180 \\times 10^{-20} \\ \\text{m}^{2} = 1.8 \\times 10^{-18} \\ \\text{m}^{2} $$\nNow, we calculate the root-mean-square diffusion length $\\ell_{\\mathrm{rms}}$:\n$$ \\ell_{\\mathrm{rms}} = \\sqrt{1.8 \\times 10^{-18} \\ \\text{m}^{2}} = \\sqrt{1.8} \\times 10^{-9} \\ \\text{m} $$\n$$ \\ell_{\\mathrm{rms}} \\approx 1.34164 \\times 10^{-9} \\ \\text{m} = 1.34164 \\ \\text{nm} $$\nNow we can compute $L_{\\min}$:\n$$ L_{\\min} = 2(R_{c} + \\ell_{\\mathrm{rms}}) = 2(4.2 \\ \\text{nm} + 1.34164 \\ \\text{nm}) $$\n$$ L_{\\min} = 2(5.54164 \\ \\text{nm}) $$\n$$ L_{\\min} \\approx 11.08328 \\ \\text{nm} $$\nThe problem requires the answer to be rounded to three significant figures.\n$$ L_{\\min} \\approx 11.1 \\ \\text{nm} $$\nThe final result is $11.1$.",
            "answer": "$$\n\\boxed{11.1}\n$$"
        },
        {
            "introduction": "For energetic particles in a cascade, interactions with the target material's electrons represent a critical energy-loss channel that is not captured by classical interatomic potentials. This exercise focuses on implementing this \"electronic stopping\" force, a velocity-dependent drag that is essential for realistic cascade simulations. You will calibrate a stopping power model from tabulated data and integrate it into a dynamics simulation, learning how to correctly account for the dissipated energy and verify the numerical implementation .",
            "id": "3484083",
            "problem": "You are asked to derive, calibrate, and test a velocity-proportional electronic stopping force in a minimal molecular dynamics (MD) context for a self-ion in a pure element. You will implement a single projectile iron (Fe) atom undergoing motion under a dissipative force that models electronic stopping, and you will analyze numerical energy conservation by explicitly accounting for the energy transferred to electrons as a sink variable.\n\nFundamental base and definitions: \n- The electronic stopping force is defined as a velocity-proportional drag of the form $\\mathbf{F}_{\\mathrm{stop}}=-S_{e}(v)\\,\\hat{\\mathbf{v}}$, where $v=\\lVert \\mathbf{v}\\rVert$ is the speed, $\\hat{\\mathbf{v}}=\\mathbf{v}/\\lVert \\mathbf{v}\\rVert$ is the unit velocity direction, and $S_{e}(v)$ is the electronic stopping power. \n- The stopping power is defined as the energy loss per unit path length, so that $\\mathrm{d}E/\\mathrm{d}x=-S_{e}(v)$ for the projectile kinetic energy $E$. \n- The kinetic energy of a point particle of mass $m$ and speed $v$ is $E=\\tfrac{1}{2} m v^{2}$. \n- The work rate of the stopping force equals $\\mathrm{d}E/\\mathrm{d}t=\\mathbf{F}_{\\mathrm{stop}}\\cdot \\mathbf{v}=-S_{e}(v)\\,v$, which implies $\\mathrm{d}E/\\mathrm{d}x = (\\mathrm{d}E/\\mathrm{d}t)/(\\mathrm{d}x/\\mathrm{d}t)=-S_{e}(v)$, consistent with the definition.\n\nUnits and numerical system: \n- Use electronvolt ($\\mathrm{eV}$) for energy, ångström ($\\mathrm{\\AA}$) for length, and femtosecond ($\\mathrm{fs}$) for time. In these units, mass will be expressed in $\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2}$. The conversion factor is $1\\,\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2} = 1.602176634\\times 10^{-29}\\,\\mathrm{kg}$. The mass of iron is $m_{\\mathrm{Fe}}=55.845\\,\\mathrm{amu}$ with $1\\,\\mathrm{amu}=1.66053906660\\times 10^{-27}\\,\\mathrm{kg}$. You must convert $m_{\\mathrm{Fe}}$ to $\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2}$ within your program.\n- All answers involving physical quantities must be expressed in the units specified above. All angles, if any, must be in radians. No angles appear in this problem. If a fraction is required, express it as a decimal number.\n\nCalibration data for electronic stopping in iron (self-ion in iron, plausible numerical dataset):\n- The table provides pairs $\\left(E_{\\mathrm{kin}}, S_{e}\\right)$, where $E_{\\mathrm{kin}}$ is the projectile kinetic energy and $S_{e}$ is the electronic stopping power. The kinetic energies and stopping powers are given at the following points:\n  - $\\left(1\\,\\mathrm{keV},\\,0.6\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$,\n  - $\\left(5\\,\\mathrm{keV},\\,1.8\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$,\n  - $\\left(10\\,\\mathrm{keV},\\,2.8\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$,\n  - $\\left(20\\,\\mathrm{keV},\\,4.0\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$,\n  - $\\left(50\\,\\mathrm{keV},\\,5.5\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$,\n  - $\\left(100\\,\\mathrm{keV},\\,6.5\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$.\n- You must calibrate $S_{e}(v)$ from these data by mapping each tabulated kinetic energy $E_{\\mathrm{kin}}$ to speed $v=\\sqrt{2E_{\\mathrm{kin}}/m_{\\mathrm{Fe}}}$ in the specified units, then constructing a smooth, positive, shape-preserving interpolant for $S_{e}$ as a function of $v$. To promote robustness and positivity, build this interpolant in log-log space, that is, fit $\\log S_{e}$ as a function of $\\log v$ using a shape-preserving cubic method, then define $S_{e}(v)=\\exp\\!\\left[\\text{interpolant}(\\log v)\\right]$. Outside the tabulated speed range, clamp $v$ to the bounds of the calibration domain before evaluating $S_{e}$.\n\nMD model and numerical tasks:\n- Consider a single Fe projectile moving in one dimension along the $x$-axis with initial speed $v_{0}>0$ and initial position $x_{0}=0$. The only force is the electronic stopping force $\\mathbf{F}_{\\mathrm{stop}}=-S_{e}(v)\\,\\hat{\\mathbf{v}}$, which in one dimension reduces to $F_{\\mathrm{stop}}(v)=-S_{e}(v)$ for $v\\ge 0$. The equation of motion is $\\mathrm{d}v/\\mathrm{d}t=-S_{e}(v)/m_{\\mathrm{Fe}}$ and $\\mathrm{d}x/\\mathrm{d}t=v$.\n- Define the electron sink energy $E_{\\mathrm{el}}(t)$ such that $\\mathrm{d}E_{\\mathrm{el}}/\\mathrm{d}t=S_{e}(v)\\,v$ and $E_{\\mathrm{el}}(0)=0$. By construction, the total $E_{\\mathrm{tot}}(t)=E_{\\mathrm{kin}}(t)+E_{\\mathrm{el}}(t)$ should be conserved in the continuous equations, where $E_{\\mathrm{kin}}(t)=\\tfrac{1}{2}m_{\\mathrm{Fe}} v(t)^{2}$.\n- Implement a time integrator for this system using a second-order explicit method (for example, the Heun method) that updates $x(t)$ and $v(t)$ with time step $\\Delta t$, and accumulates $E_{\\mathrm{el}}$ using a second-order accurate quadrature (for example, the trapezoidal rule). Ensure that $v(t)\\ge 0$ is enforced to avoid unphysical negative speeds due to numerical overshoot at late times.\n\nTest suite and required outputs:\n- Calibrated stopping power queries: Using your fitted $S_{e}(v)$, compute $S_{e}$ at the following kinetic energies by first mapping each energy to speed via $v=\\sqrt{2E/m_{\\mathrm{Fe}}}$:\n  - $E=\\{2,15,80\\}\\,\\mathrm{keV}$. Report the three stopping power values in $\\mathrm{eV}/\\mathrm{\\AA}$ as floats.\n- Energy conservation diagnostics: For each of the following triplets $(E_{0},\\Delta t,T_{\\mathrm{end}})$, simulate the projectile from initial kinetic energy $E_{0}$ until time $T_{\\mathrm{end}}$ using your integrator. For each simulation, compute the maximum relative drift in total energy defined by\n  $$\\max_{0\\le t\\le T_{\\mathrm{end}}}\\frac{\\left|E_{\\mathrm{kin}}(t)+E_{\\mathrm{el}}(t)-E_{0}\\right|}{E_{0}}.$$\n  Use the following cases:\n  - $(E_{0},\\Delta t,T_{\\mathrm{end}})=(10\\,\\mathrm{keV},\\,0.1\\,\\mathrm{fs},\\,2000\\,\\mathrm{fs})$,\n  - $(E_{0},\\Delta t,T_{\\mathrm{end}})=(20\\,\\mathrm{keV},\\,0.01\\,\\mathrm{fs},\\,2000\\,\\mathrm{fs})$,\n  - $(E_{0},\\Delta t,T_{\\mathrm{end}})=(50\\,\\mathrm{keV},\\,1.0\\,\\mathrm{fs},\\,2000\\,\\mathrm{fs})$.\n  Report the three maximum relative drifts as decimals.\n- Range-to-threshold: Starting from $E_{0}=50\\,\\mathrm{keV}$ and time step $\\Delta t=0.1\\,\\mathrm{fs}$, simulate until the kinetic energy decays to $E_{\\mathrm{th}}=1\\,\\mathrm{keV}$ or until a hard cap of $T_{\\max}=50000\\,\\mathrm{fs}$, whichever occurs first. Report the total distance traveled $R$ in $\\mathrm{\\AA}$ as a float.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n  $$\\left[\\;S_{e}(2\\,\\mathrm{keV}),\\;S_{e}(15\\,\\mathrm{keV}),\\;S_{e}(80\\,\\mathrm{keV}),\\;\\delta_{1},\\;\\delta_{2},\\;\\delta_{3},\\;R\\;\\right],$$\n  where $\\delta_{i}$ are the maximum relative energy drifts for the three energy-conservation simulations. All seven entries must be numeric in the specified units.\n\nScientific realism constraints:\n- The calibration and simulations must use the provided dataset, the physical mass conversion, and the stated unit system. \n- The integrator design and energy accounting must be consistent with the definitions above. \n- Do not use any external data or files. Everything must be self-contained and runnable.\n\nYour final program must follow the execution environment and output format requirements stated separately and produce the single-line result for the entire test suite. No additional text should be printed.",
            "solution": "The user has requested the derivation, calibration, and testing of a velocity-proportional electronic stopping force model for a single Fe projectile in a molecular dynamics (MD) context. The problem is well-defined, scientifically grounded, and provides all necessary data and constraints for a unique solution. It is therefore deemed valid.\n\nThe solution proceeds in several stages:\n1.  **Unit System and Constants**: All physical quantities are handled in a consistent unit system of electronvolts ($\\mathrm{eV}$) for energy, ångströms ($\\mathrm{\\AA}$) for length, and femtoseconds ($\\mathrm{fs}$) for time. The mass of an iron (Fe) atom, given as $m_{\\mathrm{Fe}}=55.845\\,\\mathrm{amu}$, is converted to the MD unit of mass, $\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2}$.\n    -   $1\\,\\mathrm{amu}=1.66053906660\\times 10^{-27}\\,\\mathrm{kg}$\n    -   $m_{\\mathrm{Fe}} = 55.845\\,\\mathrm{amu} \\times (1.66053906660\\times 10^{-27}\\,\\mathrm{kg}/\\mathrm{amu}) \\approx 9.2731\\times 10^{-26}\\,\\mathrm{kg}$.\n    -   The conversion factor for mass is $1\\,\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2} = 1.602176634\\times 10^{-29}\\,\\mathrm{kg}$.\n    -   Therefore, $m_{\\mathrm{Fe}} \\approx \\frac{9.2731\\times 10^{-26}\\,\\mathrm{kg}}{1.602176634\\times 10^{-29}\\,\\mathrm{kg}/(\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2})} \\approx 5787.855\\,\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2}$.\n\n2.  **Calibration of Electronic Stopping Power $S_e(v)$**: The electronic stopping power $S_e$ is calibrated as a function of projectile speed $v$. The provided dataset consists of pairs $(E_{\\mathrm{kin}}, S_e)$.\n    -   Each kinetic energy $E_{\\mathrm{kin}}$ (in $\\mathrm{keV}$) from the calibration table is converted to speed $v$ (in $\\mathrm{\\AA}/\\mathrm{fs}$) using the relationship $v = \\sqrt{2E_{\\mathrm{kin}}/m_{\\mathrm{Fe}}}$. All energies are first converted to $\\mathrm{eV}$.\n    -   The problem specifies a shape-preserving cubic interpolation in log-log space. This is achieved by fitting $\\log(S_e)$ as a function of $\\log(v)$ using `scipy.interpolate.PchipInterpolator`. This method ensures monotonicity and avoids spurious oscillations.\n    -   The resulting interpolator is wrapped in a function $S_e(v)$ that computes $S_e(v) = \\exp\\!\\left[\\text{interpolant}(\\log v)\\right]$. For numerical stability and physical realism, if $v \\le 0$, $S_e(v)$ is set to $0$. As per the problem, for speeds outside the calibration range, the input speed $v$ is clamped to the range's boundaries before evaluation.\n\n3.  **Numerical Integration of Equations of Motion**: A one-dimensional simulation of the Fe projectile is performed. The only force is the electronic stopping force, $F_{\\mathrm{stop}}(v)=-S_{e}(v)$ for $v \\ge 0$. The equations of motion are:\n    $$ \\frac{\\mathrm{d}v}{\\mathrm{d}t} = \\frac{F_{\\mathrm{stop}}(v)}{m_{\\mathrm{Fe}}} = -\\frac{S_{e}(v)}{m_{\\mathrm{Fe}}} $$\n    $$ \\frac{\\mathrm{d}x}{\\mathrm{d}t} = v $$\n    These equations are integrated using a second-order explicit integrator, the Heun method. For a system $\\mathbf{y}' = \\mathbf{f}(\\mathbf{y})$, the update rule is:\n    $$ \\mathbf{y}_{\\text{pred}} = \\mathbf{y}_n + \\Delta t \\, \\mathbf{f}(\\mathbf{y}_n) $$\n    $$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{2} \\left[ \\mathbf{f}(\\mathbf{y}_n) + \\mathbf{f}(\\mathbf{y}_{\\text{pred}}) \\right] $$\n    For our state vector $\\mathbf{y} = [x, v]^T$, this translates to updates for position $x$ and velocity $v$. A non-negativity constraint $v \\ge 0$ is enforced at each step to prevent unphysical negative speeds from numerical overshoot.\n\n4.  **Energy Conservation and Sink Term**: The total energy of the system is the sum of the projectile's kinetic energy $E_{\\mathrm{kin}}(t) = \\frac{1}{2}m_{\\mathrm{Fe}}v(t)^2$ and the energy dissipated into the electronic subsystem, $E_{\\mathrm{el}}(t)$. The rate of change of the electronic energy sink is given by the power dissipated by the stopping force:\n    $$ \\frac{\\mathrm{d}E_{\\mathrm{el}}}{\\mathrm{d}t} = S_{e}(v)v $$\n    This equation is integrated numerically using the second-order trapezoidal rule, consistent with the order of the Heun integrator for the equations of motion:\n    $$ E_{\\mathrm{el}}(t_{n+1}) = E_{\\mathrm{el}}(t_n) + \\frac{\\Delta t}{2} \\left[ S_e(v_n)v_n + S_e(v_{n+1})v_{n+1} \\right] $$\n    The total energy $E_{\\mathrm{tot}}(t) = E_{\\mathrm{kin}}(t) + E_{\\mathrm{el}}(t)$ should be conserved. Deviations from the initial energy $E_0$ are monitored to assess the numerical accuracy of the simulation.\n\n5.  **Execution of Test Suite**: The implementation is applied to solve the three tasks specified:\n    -   **$S_e$ Queries**: The calibrated $S_e(v)$ function is used to find stopping powers for projectiles with kinetic energies of $2$, $15$, and $80\\,\\mathrm{keV}$.\n    -   **Energy Conservation Diagnostics**: Three simulations are run with different initial energies $E_0$ and time steps $\\Delta t$. The maximum relative drift in total energy, $\\max |E_{\\mathrm{tot}}(t) - E_0|/E_0$, is computed for each case.\n    -   **Range Calculation**: A simulation is run starting from $E_0=50\\,\\mathrm{keV}$ until the projectile's energy drops below a threshold of $E_{\\mathrm{th}}=1\\,\\mathrm{keV}$. The total distance traveled, or range $R$, is recorded.\n\nThe final output concatenates the results from these three tasks into a single list as requested. The implementation is self-contained in a single Python script.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the problem of simulating a projectile under electronic stopping,\n    including calibration, integration, and analysis tasks.\n    \"\"\"\n\n    # Define physical constants and conversion factors as per the problem statement.\n    AMU_IN_KG = 1.66053906660e-27\n    EV_FS2_PER_A2_IN_KG = 1.602176634e-29\n    FE_MASS_AMU = 55.845\n\n    # Calculate the mass of an iron atom in the specified MD units (eV*fs^2/A^2).\n    m_Fe_kg = FE_MASS_AMU * AMU_IN_KG\n    m_Fe = m_Fe_kg / EV_FS2_PER_A2_IN_KG\n\n    def calibrate_stopping_power(mass_fe):\n        \"\"\"\n        Calibrates the electronic stopping power S_e as a function of speed v,\n        based on provided (E_kin, S_e) data. The calibration is performed\n        via shape-preserving cubic interpolation in log-log space.\n\n        Args:\n            mass_fe (float): Mass of the projectile in MD units.\n\n        Returns:\n            A function S_e(v) that returns the stopping power.\n        \"\"\"\n        # Calibration data: (E_kin [keV], S_e [eV/A])\n        cal_data = np.array([\n            (1.0, 0.6), (5.0, 1.8), (10.0, 2.8), (20.0, 4.0),\n            (50.0, 5.5), (100.0, 6.5)\n        ], dtype=float)\n\n        E_kin_keV = cal_data[:, 0]\n        Se_cal = cal_data[:, 1]\n\n        # Convert kinetic energy E_kin [keV] to speed v [A/fs]\n        E_kin_eV = E_kin_keV * 1000.0\n        v_cal = np.sqrt(2 * E_kin_eV / mass_fe)\n\n        # Prepare for log-log interpolation\n        log_v_cal = np.log(v_cal)\n        log_Se_cal = np.log(Se_cal)\n\n        # Create the shape-preserving (monotonic) cubic interpolator\n        pchip = PchipInterpolator(log_v_cal, log_Se_cal)\n        min_log_v, max_log_v = log_v_cal[0], log_v_cal[-1]\n\n        def Se_function(v):\n            \"\"\"\n            Computes electronic stopping power S_e for a given speed v.\n            Handles v <= 0 and clamps v to the calibration range.\n            \"\"\"\n            if v <= 0:\n                return 0.0\n            log_v = np.log(v)\n            clamped_log_v = np.clip(log_v, min_log_v, max_log_v)\n            log_Se = pchip(clamped_log_v)\n            return np.exp(log_Se)\n\n        return Se_function\n\n    def run_simulation(E0_keV, dt_fs, Se_func, mass_fe, t_end_fs=None, E_th_keV=None, t_max_fs=None):\n        \"\"\"\n        Simulates the 1D motion of a projectile under electronic stopping.\n        Can run in two modes:\n        1. Energy conservation check: Runs for a fixed time.\n        2. Range calculation: Runs until energy drops to a threshold or time limit is reached.\n        \"\"\"\n        E0_eV = E0_keV * 1000.0\n        v0 = np.sqrt(2 * E0_eV / mass_fe)\n        E_kin0 = E0_eV\n\n        t, x, v, E_el = 0.0, 0.0, v0, 0.0\n        max_rel_drift = 0.0\n        \n        is_range_calc = (E_th_keV is not None and t_max_fs is not None)\n        \n        t_limit = t_max_fs if is_range_calc else t_end_fs\n        E_th_eV = E_th_keV * 1000.0 if is_range_calc else None\n        \n        num_steps = int(np.ceil(t_limit / dt_fs))\n\n        for _ in range(num_steps):\n            if is_range_calc:\n                current_E_kin = 0.5 * mass_fe * v**2 if v > 0 else 0.0\n                if current_E_kin <= E_th_eV:\n                    break\n            \n            # Heun's method for velocity and position\n            v_n = v\n            Se_n = Se_func(v_n)\n            accel_n = -Se_n / mass_fe if v_n > 0 else 0.0\n            \n            v_tilde = v_n + dt_fs * accel_n\n            \n            Se_tilde = Se_func(v_tilde)\n            accel_tilde = -Se_tilde / mass_fe if v_tilde > 0 else 0.0\n            \n            v_next = v_n + 0.5 * dt_fs * (accel_n + accel_tilde)\n            v_next = max(0.0, v_next)\n\n            x_next = x + 0.5 * dt_fs * (v_n + v_tilde)\n            \n            # Trapezoidal rule for energy sink\n            Se_next = Se_func(v_next)\n            E_el_next = E_el + 0.5 * dt_fs * ((Se_n * v_n) + (Se_next * v_next))\n\n            x, v, E_el = x_next, v_next, E_el_next\n\n            if not is_range_calc:\n                E_kin_next = 0.5 * mass_fe * v**2\n                E_tot_next = E_kin_next + E_el\n                if E_kin0 > 0:\n                    rel_drift = abs(E_tot_next - E_kin0) / E_kin0\n                    max_rel_drift = max(max_rel_drift, rel_drift)\n        \n        return x if is_range_calc else max_rel_drift\n\n    all_results = []\n    \n    Se_func = calibrate_stopping_power(m_Fe)\n\n    # Task 1: Calibrated stopping power queries\n    query_energies_keV = [2.0, 15.0, 80.0]\n    for E_keV in query_energies_keV:\n        E_eV = E_keV * 1000.0\n        v_query = np.sqrt(2 * E_eV / m_Fe)\n        all_results.append(Se_func(v_query))\n\n    # Task 2: Energy conservation diagnostics\n    conservation_cases = [\n        (10.0, 0.1, 2000.0), # (E0_keV, dt_fs, T_end_fs)\n        (20.0, 0.01, 2000.0),\n        (50.0, 1.0, 2000.0)\n    ]\n    for E0, dt, Tend in conservation_cases:\n        drift = run_simulation(E0, dt, Se_func, m_Fe, t_end_fs=Tend)\n        all_results.append(drift)\n    \n    # Task 3: Range-to-threshold\n    final_range = run_simulation(\n        E0_keV=50.0, dt_fs=0.1, Se_func=Se_func, mass_fe=m_Fe,\n        E_th_keV=1.0, t_max_fs=50000.0\n    )\n    all_results.append(final_range)\n    \n    # Final output format: [Se_1, Se_2, Se_3, drift_1, drift_2, drift_3, Range]\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The final output of a cascade simulation is a complex configuration of point defects, and a key scientific goal is to characterize the morphology of these defect clusters. This practice problem introduces a powerful post-processing technique that uses graph theory to distinguish between planar ($2$D) and volumetric ($3$D) defect structures. You will learn to construct a graph from atomic coordinates and use the mean clustering coefficient, a metric sensitive to the embedding dimension, to classify the resulting damage structure automatically .",
            "id": "3484085",
            "problem": "You are tasked with implementing a complete, runnable program that constructs graph representations of point-defect clusters from displacement cascade simulations and computes graph metrics to classify cluster morphologies as planar dislocation loops versus three-dimensional aggregates across primary knock-on atom energy and temperature. The program must be fully deterministic and produce a single-line, machine-checkable output over a prescribed test suite. All mathematical definitions below must be implemented exactly, and all physical and numerical quantities are specified with their units.\n\nFundamental base and definitions:\n\n- Let a cluster be a finite set of positions $\\{\\mathbf{x}_i\\}_{i=1}^{N}$ with $\\mathbf{x}_i \\in \\mathbb{R}^3$ in units of Angstrom.\n- Build an undirected, simple graph $G = (V,E)$ with node set $V = \\{1,\\dots,N\\}$ from the positions via a distance-based cutoff. For a user-specified integer $m \\ge 2$ and scale factor $\\eta > 0$, compute for each node $i$ the distance to its $m$-th nearest neighbor, $d_i^{(m)}$, and define the global cutoff\n  $$ r_{\\mathrm{c}} = \\eta \\cdot \\mathrm{median}\\left(\\{d_i^{(m)}\\}_{i=1}^{N}\\right). $$\n  The adjacency matrix $A \\in \\{0,1\\}^{N \\times N}$ is defined by\n  $$ A_{ij} = \\begin{cases}1,& 0 < \\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2 \\le r_{\\mathrm{c}},\\\\ 0,& \\text{otherwise},\\end{cases} $$\n  with $A_{ii} = 0$ and $A_{ij} = A_{ji}$.\n- The degree of node $i$ is $k_i = \\sum_{j=1}^{N} A_{ij}$. The degree distribution is the multiset $\\{k_i\\}_{i=1}^{N}$.\n- The local clustering coefficient (triadic closure) at node $i$ with $k_i \\ge 2$ is\n  $$ C_i = \\frac{2 t_i}{k_i (k_i - 1)}, $$\n  where $t_i$ is the number of edges among the neighbors of node $i$,\n  $$ t_i = \\sum_{1 \\le p < q \\le N} A_{ip} A_{iq} A_{pq}. $$\n  For $k_i < 2$, define $C_i = 0$. The mean local clustering coefficient is\n  $$ \\bar{C} = \\frac{1}{|\\{i \\,:\\, k_i \\ge 2\\}|} \\sum_{i : k_i \\ge 2} C_i, $$\n  with the convention $\\bar{C} = 0$ if $\\{i : k_i \\ge 2\\} = \\emptyset$.\n\nScientific basis for classification:\n\n- When edges are formed by a geometric proximity rule, the resulting graph is a random geometric graph constrained by the embedding dimension. For a comparable neighbor count, two-dimensional embeddings (planar disks) have larger overlap areas of neighborhoods than three-dimensional embeddings (spherical volumes), leading to larger $\\bar{C}$ in two dimensions than in three dimensions. This effect can be understood from fundamental geometry: for fixed neighbor count (controlled here by the adaptive cutoff), the ratio of pairwise neighborhood intersection measure to neighborhood measure is larger in lower dimensions, raising the probability of closed triplets, hence larger $\\bar{C}$.\n- Therefore, we classify clusters using a threshold on $\\bar{C}$:\n  $$ \\text{label} = \\begin{cases} 0,& \\bar{C} \\ge C_{\\mathrm{thr}} \\quad \\text{(planar loop)},\\\\ 1,& \\bar{C} < C_{\\mathrm{thr}} \\quad \\text{(three-dimensional aggregate)}.\\end{cases} $$\n\nSynthetic, physically motivated cluster generator to produce coordinates from primary knock-on atom energy and temperature:\n\n- Primary Knock-on Atom (PKA) energy is denoted $E_{\\mathrm{PKA}}$ in kilo-electronvolt, and temperature is $T$ in Kelvin.\n- Fix a reference energy $E_{\\mathrm{ref}} = 20$ kilo-electronvolt and define a size scale factor $s_E = (E_{\\mathrm{PKA}}/E_{\\mathrm{ref}})^{1/3}$ (dimensionless), motivated by energy-volume scaling in cascades.\n- A temperature-energy switching rule determines whether a planar loop or a volumetric cluster is generated:\n  $$ T_{\\mathrm{switch}}(E_{\\mathrm{PKA}}) = T_0 + \\alpha \\left(E_{\\mathrm{PKA}} - E_{\\mathrm{ref}}\\right), $$\n  where $T_0 = 800$ Kelvin and $\\alpha = 4$ Kelvin per kilo-electronvolt. If $T \\ge T_{\\mathrm{switch}}(E_{\\mathrm{PKA}})$, generate a planar loop-like cluster; otherwise, generate a three-dimensional cluster.\n- Planar loop-like cluster synthesis: sample $N$ points uniformly in a disk of radius $R_{\\mathrm{loop}} = 12 \\, s_E$ Angstrom in the plane $z=0$. Radial sampling must use $r = R_{\\mathrm{loop}} \\sqrt{U}$ with $U \\sim \\mathrm{Uniform}(0,1)$, and angular sampling must use $\\theta \\sim \\mathrm{Uniform}(0,2\\pi)$ with angles in radians. Add small out-of-plane perturbations $\\delta z \\sim \\mathcal{N}(0,\\sigma_z^2)$ with $\\sigma_z = 0.15 \\cdot (T/1000)$ Angstrom.\n- Three-dimensional cluster synthesis: sample $N$ points uniformly in a sphere of radius $R_{\\mathrm{3D}} = 10 \\, s_E$ Angstrom using the radius law $r = R_{\\mathrm{3D}} \\, U^{1/3}$ with $U \\sim \\mathrm{Uniform}(0,1)$ and uniformly random direction vectors in $\\mathbb{R}^3$.\n- Use a fixed random seed equal to $12345$ so that all coordinates are reproducible.\n\nGraph construction hyperparameters and classification threshold:\n\n- Use $m = 6$ and $\\eta = 1.05$ for the adaptive cutoff. If $N-1 < m$, then use $m_{\\mathrm{eff}} = N-1$ in place of $m$.\n- Use $C_{\\mathrm{thr}} = 0.50$ as the classification threshold.\n- All distances must be computed in Angstrom, and all angles in radians.\n\nTest suite:\n\nProvide the following five test cases as ordered tuples $(N, E_{\\mathrm{PKA}} \\, [\\mathrm{keV}], T \\, [\\mathrm{K}])$:\n\n- Case A (happy path planar): $(80, 10, 1000)$.\n- Case B (happy path volumetric): $(120, 40, 500)$.\n- Case C (boundary at switching line): $(60, 20, 800)$.\n- Case D (small cluster edge case): $(12, 25, 850)$.\n- Case E (near-switch volumetric): $(90, 30, 820)$.\n\nProgram requirements:\n\n- Implement the generator, graph construction, degree distribution, and mean local clustering coefficient exactly as defined.\n- For each test case, build the graph and compute the degree distribution $\\{k_i\\}$ and $\\bar{C}$, then output the morphology label as an integer where $0$ denotes a loop-like morphology and $1$ denotes a three-dimensional morphology.\n- The final program output must be a single line containing a comma-separated list of the labels for the five test cases in the given order, enclosed in square brackets. For example, the output format must be exactly like $[x_1,x_2,x_3,x_4,x_5]$ where each $x_i$ is an integer.",
            "solution": "The problem requires the implementation of a computational workflow to classify the morphology of point-defect clusters, generated synthetically, as either planar (label $0$) or three-dimensional (label $1$). This is accomplished by modeling the clusters as graphs and using a graph-theoretic metric, the mean local clustering coefficient, as a discriminative feature. The entire process, from data generation to classification, is deterministic due to a fixed random seed.\n\nThe solution is implemented in three main stages: synthetic cluster generation, graph construction and analysis, and final classification.\n\n**1. Synthetic Cluster Generation**\n\nThe generation of cluster coordinates $\\{\\mathbf{x}_i\\}_{i=1}^{N}$ is physically motivated, mimicking outcomes of displacement cascades in materials. The morphology is determined by a competition between Primary Knock-on Atom (PKA) energy, $E_{\\mathrm{PKA}}$, and temperature, $T$.\n\nFirst, a size-scaling factor, $s_E = (E_{\\mathrm{PKA}}/E_{\\mathrm{ref}})^{1/3}$, is calculated, where $E_{\\mathrm{ref}} = 20$ keV is a reference energy. This $1/3$ power law is consistent with theoretical models where the volume of the cascade-affected region scales linearly with energy.\n\nNext, a temperature threshold, $T_{\\mathrm{switch}}$, is computed as a linear function of PKA energy:\n$$ T_{\\mathrm{switch}}(E_{\\mathrm{PKA}}) = T_0 + \\alpha (E_{\\mathrm{PKA}} - E_{\\mathrm{ref}}) $$\nwith base temperature $T_0 = 800$ K and slope $\\alpha = 4$ K/keV. If the ambient temperature $T$ is greater than or equal to this threshold ($T \\ge T_{\\mathrm{switch}}(E_{\\mathrm{PKA}})$), a planar, loop-like cluster is generated. Otherwise, a three-dimensional, aggregate-like cluster is formed. This rule models the physical tendency for defects to arrange into lower-dimensional structures (dislocation loops) at higher temperatures where thermal mobility is enhanced.\n\n- **Planar Loop Synthesis ($T \\ge T_{\\mathrm{switch}}$)**: $N$ points are sampled uniformly from a disk of radius $R_{\\mathrm{loop}} = 12 \\, s_E$ Angstrom. To ensure uniform spatial density, radial coordinates $r$ are sampled according to $r = R_{\\mathrm{loop}} \\sqrt{U}$, where $U$ is a random variate from $\\mathrm{Uniform}(0,1)$. Angular coordinates $\\theta$ are sampled from $\\mathrm{Uniform}(0,2\\pi)$. A small, temperature-dependent Gaussian noise with standard deviation $\\sigma_z = 0.15 \\cdot (T/1000)$ Angstrom is added to the $z$-coordinate to simulate thermal vibrations and slight deviations from a perfect plane.\n\n- **Three-Dimensional Aggregate Synthesis ($T < T_{\\mathrm{switch}}$)**: $N$ points are sampled uniformly from a sphere of radius $R_{\\mathrm{3D}} = 10 \\, s_E$ Angstrom. Uniform volume sampling requires the radial coordinate $r$ to be sampled as $r = R_{\\mathrm{3D}} \\, U^{1/3}$, with $U \\sim \\mathrm{Uniform}(0,1)$. The direction is sampled uniformly from the unit sphere $\\mathbb{S}^2$.\n\nA single pseudorandom number generator, initialized with a fixed seed of $12345$, ensures the entire generation process is reproducible.\n\n**2. Graph Construction and Metric Calculation**\n\nGiven the set of $N$ coordinates, an undirected graph $G=(V, E)$ is constructed. The core of this process is an adaptive cutoff radius $r_{\\mathrm{c}}$ that determines connectivity.\n\nFirst, for each point $\\mathbf{x}_i$, we find the distance to its $m$-th nearest neighbor, $d_i^{(m)}$, where $m=6$. A special case handles small clusters where the number of other points is less than $m$: if $N-1 < m$, we use $m_{\\mathrm{eff}} = N-1$ instead. The global cutoff radius is then defined as:\n$$ r_{\\mathrm{c}} = \\eta \\cdot \\mathrm{median}\\left(\\{d_i^{(m)}\\}_{i=1}^{N}\\right) $$\nwhere $\\eta = 1.05$ is a scaling factor. This adaptive approach ensures that the resulting graph has a number of connections per node that is robust to variations in the overall density of the point cloud.\n\nThe adjacency matrix $A$ of the graph is constructed based on this cutoff. An edge exists between nodes $i$ and $j$ if their Euclidean distance is positive and does not exceed $r_{\\mathrm{c}}$:\n$$ A_{ij} = 1 \\quad \\text{if} \\quad 0 < \\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2 \\le r_{\\mathrm{c}}, \\quad \\text{and} \\quad A_{ij}=0 \\quad \\text{otherwise}. $$\nBy definition, $A_{ii}=0$ and the matrix is symmetric, $A_{ij}=A_{ji}$.\n\nThe primary graph metric for classification is the mean local clustering coefficient, $\\bar{C}$. For each node $i$, its local clustering coefficient $C_i$ measures the density of connections among its immediate neighbors. It is defined for nodes with degree $k_i = \\sum_{j} A_{ij} \\ge 2$:\n$$ C_i = \\frac{2 t_i}{k_i (k_i - 1)} $$\nwhere $t_i$ is the number of triangles (closed triplets of connected nodes) that include node $i$. For nodes with $k_i < 2$, $C_i$ is defined as $0$. The number of triangles $t_i$ can be calculated combinatorially, but a more computationally efficient method leverages matrix algebra: the number of paths of length 3 from a node $i$ back to itself is given by the $i$-th diagonal element of the matrix cube, $(A^3)_{ii}$. Since each triangle involving node $i$ corresponds to two such paths (one clockwise, one counter-clockwise), we have $2t_i = (A^3)_{ii}$.\n\nThe mean local clustering coefficient $\\bar{C}$ is the average of $C_i$ over all nodes with degree $k_i \\ge 2$:\n$$ \\bar{C} = \\frac{1}{|\\{i \\,:\\, k_i \\ge 2\\}|} \\sum_{i : k_i \\ge 2} C_i $$\nIf no nodes have a degree of $2$ or more, $\\bar{C}$ is defined to be $0$.\n\n**3. Morphological Classification**\n\nThe scientific basis for using $\\bar{C}$ is geometric. For a graph where nodes have, on average, a similar number of neighbors (as ensured by the adaptive cutoff), nodes embedded in two-dimensional space will have a higher $\\bar{C}$ than nodes in three-dimensional space. This is because neighborhoods (disks in 2D, spheres in 3D) have a larger relative intersection volume in lower dimensions, increasing the probability that two neighbors of a node are also neighbors of each other.\n\nThe final classification is performed by comparing $\\bar{C}$ to a fixed threshold, $C_{\\mathrm{thr}} = 0.50$:\n- If $\\bar{C} \\ge C_{\\mathrm{thr}}$, the cluster is classified as a planar loop (label $0$).\n- If $\\bar{C} < C_{\\mathrm{thr}}$, the cluster is classified as a three-dimensional aggregate (label $1$).\n\nThe provided program implements this complete pipeline, processing each test case from the specified suite and generating the corresponding classification label.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\ndef solve():\n    \"\"\"\n    Main function to run the full simulation and classification pipeline.\n    It orchestrates cluster generation, graph construction, and metric-based\n    classification for a predefined suite of test cases.\n    \"\"\"\n    \n    # Initialize a single random number generator with a fixed seed for reproducibility.\n    # This generator is passed to any function that requires random numbers.\n    rng = np.random.default_rng(12345)\n\n    # Define physical constants and model hyperparameters as specified.\n    E_REF = 20.0  # Reference PKA energy in keV\n    T0 = 800.0    # Base temperature in K\n    ALPHA = 4.0   # Temperature-Energy coupling in K/keV\n    M_PARAM = 6   # Neighbor parameter for adaptive cutoff\n    ETA = 1.05    # Scale factor for adaptive cutoff\n    C_THR = 0.50  # Threshold for classification\n\n    # Define the five test cases as (N, E_pka [keV], T [K]).\n    test_cases = [\n        (80, 10.0, 1000.0),  # Case A: Happy path planar\n        (120, 40.0, 500.0),  # Case B: Happy path volumetric\n        (60, 20.0, 800.0),   # Case C: Boundary at switching line\n        (12, 25.0, 850.0),   # Case D: Small cluster edge case\n        (90, 30.0, 820.0),   # Case E: Near-switch volumetric\n    ]\n\n    results = []\n    for N, E_pka, T in test_cases:\n        # For each case, generate the coordinates based on the physical model.\n        coords = _generate_cluster(N, E_pka, T, E_REF, T0, ALPHA, rng)\n        # Classify the generated cluster using the graph-based method.\n        label = _classify_cluster(coords, M_PARAM, ETA, C_THR)\n        results.append(label)\n\n    # Print the final output in the specified format \"[label1,label2,...]\".\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _generate_cluster(N, E_pka, T, E_ref, T0, alpha, rng):\n    \"\"\"\n    Generates a synthetic point-defect cluster based on PKA energy and temperature.\n    \"\"\"\n    s_E = (E_pka / E_ref)**(1/3.0)\n    T_switch = T0 + alpha * (E_pka - E_ref)\n\n    if T >= T_switch:\n        # Generate a planar, loop-like cluster.\n        R_loop = 12.0 * s_E\n        sigma_z = 0.15 * (T / 1000.0)\n        \n        # Uniform sampling in a disk requires a square-root transformation of the radial uniform variate.\n        u_rad = rng.uniform(0, 1, size=N)\n        radii = R_loop * np.sqrt(u_rad)\n        \n        thetas = rng.uniform(0, 2 * np.pi, size=N)\n        \n        x = radii * np.cos(thetas)\n        y = radii * np.sin(thetas)\n        z = rng.normal(0, sigma_z, size=N)\n        \n        return np.vstack((x, y, z)).T\n    else:\n        # Generate a three-dimensional, aggregate-like cluster.\n        R_3d = 10.0 * s_E\n        \n        # Uniform sampling in a sphere requires a cube-root transformation of the radial uniform variate.\n        u_rad = rng.uniform(0, 1, size=N)\n        radii = R_3d * (u_rad**(1/3.0))\n        \n        # Generate uniformly distributed random direction vectors on the unit sphere.\n        vecs = rng.normal(0, 1, size=(N, 3))\n        norms = np.linalg.norm(vecs, axis=1, keepdims=True)\n        # Avoid division by zero for a zero-vector, though highly improbable.\n        norms[norms == 0] = 1\n        unit_vecs = vecs / norms\n        \n        # Scale unit vectors by the sampled radii.\n        return radii[:, np.newaxis] * unit_vecs\n\ndef _classify_cluster(coords, m_param, eta, C_thr):\n    \"\"\"\n    Classifies a cluster by constructing a graph and computing its mean local clustering coefficient.\n    \"\"\"\n    N = coords.shape[0]\n    \n    # Handle trivial cases (e.g., N < 2) where a graph is ill-defined.\n    if N <= 1:\n        return 1  # Cannot form edges, C_bar is 0, classified as 3D.\n\n    # Adjust m for small clusters as per problem spec.\n    m_eff = min(m_param, N - 1)\n    if m_eff < 1:\n        return 1 # Not enough neighbors to define m-th nearest.\n\n    # 1. Compute pairwise Euclidean distance matrix.\n    dist_matrix = squareform(pdist(coords, 'euclidean'))\n    \n    # 2. Find m-th nearest neighbor distances for each point.\n    sorted_dist = np.sort(dist_matrix, axis=1)\n    # sorted_dist[:, 0] is always 0 (distance to self).\n    # sorted_dist[:, k] is the k-th nearest neighbor distance.\n    d_m_list = sorted_dist[:, m_eff]\n    \n    # 3. Compute the adaptive cutoff radius.\n    r_c = eta * np.median(d_m_list)\n    \n    # 4. Construct the adjacency matrix.\n    adj_matrix = ((dist_matrix > 0) & (dist_matrix <= r_c)).astype(int)\n    \n    # 5. Compute node degrees (k_i).\n    k = adj_matrix.sum(axis=1)\n\n    # 6. Compute mean local clustering coefficient (C_bar).\n    k_ge_2_mask = k >= 2\n    \n    if not np.any(k_ge_2_mask):\n        C_bar = 0.0\n    else:\n        # Efficiently compute number of triangles t_i using matrix exponentiation.\n        # (A^3)_ii = 2 * t_i\n        adj_matrix_cubed = np.linalg.matrix_power(adj_matrix, 3)\n        two_ti = np.diag(adj_matrix_cubed)\n        \n        # Denominators for C_i: k_i * (k_i - 1).\n        denominators = k * (k - 1)\n        \n        # Calculate C_i only for nodes where the denominator is non-zero (k_i >= 2).\n        valid_two_ti = two_ti[k_ge_2_mask]\n        valid_denominators = denominators[k_ge_2_mask]\n        \n        C_i_list = valid_two_ti / valid_denominators\n        C_bar = np.mean(C_i_list)\n        \n    # 7. Classify based on C_bar and the threshold C_thr.\n    label = 1 if C_bar < C_thr else 0\n    \n    return label\n\nsolve()\n```"
        }
    ]
}