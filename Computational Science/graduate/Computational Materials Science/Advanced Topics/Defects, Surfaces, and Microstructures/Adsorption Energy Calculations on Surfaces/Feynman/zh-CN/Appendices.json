{
    "hands_on_practices": [
        {
            "introduction": "吸附能的精确计算不仅需要考虑电子结构，还必须包含吸附物和表面在相互作用下的结构弛豫。本练习  使用一个物理上合理的二次谐波模型，来量化和比较单点计算、仅吸附物弛豫、仅表面弛豫以及全系统弛豫对吸附能的影响。通过这个实践，你将亲手揭示忽略结构弛豫可能引入的误差，并深刻理解为何在吸附研究中进行完整的几何优化至关重要。",
            "id": "3432211",
            "problem": "要求您构建并执行一个程序，该程序使用一个具有物理动机的弛豫二次代理模型，对氨气($\\mathrm{NH_3}$)在氧化镁(MgO)上的吸附能进行单点计算和完全弛豫计算，并进行比较，同时量化因未弛豫吸附质和表面而引入的误差。吸附能定义为组合系统的总能量与各孤立组分能量之和的差值。在密度泛函理论(DFT)工作流程中，单点吸附能计算是在一个固定的参考构型下评估组合系统，而完全弛豫的吸附能计算则允许系统在相关自由度上最小化其能量。在本问题中，您不需要进行电子结构计算。取而代之的是，您将通过与简谐近似和线性响应一致的二次展开来模拟参考构型附近的能量学。\n\n基本和建模假设：\n- 吸附能 $ E_{\\mathrm{ads}} $ 定义为 $ E_{\\mathrm{ads}} = E_{\\mathrm{tot}}(\\text{surface} + \\text{adsorbate}) - E_{\\mathrm{surf}} - E_{\\mathrm{ads}}^{\\text{gas}} $，其中 $ E_{\\mathrm{tot}} $ 是组合系统的总能量，$ E_{\\mathrm{surf}} $ 是洁净表面的能量，$ E_{\\mathrm{ads}}^{\\text{gas}} $ 是孤立吸附质的能量。\n- 在参考构型（单点）附近，相对于单点基线的相互作用引起的能量变化被建模为\n$$\nE_{\\mathrm{rel}}(\\mathbf{x}) = \\frac{1}{2}\\,\\mathbf{x}^{\\top}\\mathbf{K}\\,\\mathbf{x} - \\mathbf{f}^{\\top}\\mathbf{x},\n$$\n其中 $ \\mathbf{x} $ 是所选自由度围绕参考构型的微小位移（单位为埃），$ \\mathbf{K} $ 是一个正定刚度矩阵（单位为电子伏特每平方埃），$ \\mathbf{f} $ 是一个有效力矢量（单位为电子伏特每埃），表示相互作用的线性驱动趋势。单点基线相互作用能为 $ E_{\\mathrm{int}}^{0} $（单位为电子伏特），使得当 $ \\mathbf{x} = \\mathbf{0} $ 时，吸附能等于 $ E_{\\mathrm{int}}^{0} $。\n- 通过在允许的坐标子集上对 $ E_{\\mathrm{rel}}(\\mathbf{x}) $ 进行最小化，同时将所有受约束的坐标固定在 $ \\mathbf{0} $，可以获得弛豫后的总吸附能。完全弛豫的吸附能对应于对所有坐标进行最小化。仅吸附质弛豫是在保持表面坐标固定的情况下对吸附质坐标进行最小化，而仅表面弛豫是在保持吸附质坐标固定的情况下对表面坐标进行最小化。\n\n您的程序必须为每个测试用例计算以下三个量，并以电子伏特(eV)为单位，四舍五入到三位小数的正浮点数形式返回它们：\n- 单点吸附能相对于完全弛豫吸附能的误差，定义为 $ E_{\\mathrm{ads}}^{\\text{single}} - E_{\\mathrm{ads}}^{\\text{full}} $。\n- 仅吸附质弛豫的吸附能相对于完全弛豫吸附能的误差，定义为 $ E_{\\mathrm{ads}}^{\\text{ads-only}} - E_{\\mathrm{ads}}^{\\text{full}} $。\n- 仅表面弛豫的吸附能相对于完全弛豫吸附能的误差，定义为 $ E_{\\mathrm{ads}}^{\\text{surf-only}} - E_{\\mathrm{ads}}^{\\text{full}} $。\n\n所有能量必须以电子伏特(eV)表示。位移在概念上以埃(Å)为单位，刚度矩阵项以eV/Å$^2$为单位，力矢量项以eV/Å为单位。您的程序必须实现精确的二次最小化；不允许使用数值优化。\n\n测试套件：\n对于每个测试用例，自由度的排序方式是：前 $p$ 个条目对应于吸附质自由度，后 $q$ 个条目对应于表面自由度。刚度矩阵是对角矩阵，$ \\mathbf{K} = \\mathrm{diag}(k_1, k_2, \\dots, k_{p+q}) $，力矢量为 $ \\mathbf{f} = (f_1, f_2, \\dots, f_{p+q}) $。请使用以下参数集：\n\n- 案例1（Mg顶位，中等强度的酸碱相互作用）：\n  - $p = 2$， $q = 1$。\n  - $ \\mathbf{K} = \\mathrm{diag}(18.0, 12.0, 45.0) $，单位 eV/Å$^2$。\n  - $ \\mathbf{f} = (2.5, 1.0, 1.5) $，单位 eV/Å。\n  - $ E_{\\mathrm{int}}^{0} = -0.90 $ eV。\n\n- 案例2（O顶位，较弱的相互作用）：\n  - $p = 2$， $q = 1$。\n  - $ \\mathbf{K} = \\mathrm{diag}(10.0, 8.0, 30.0) $，单位 eV/Å$^2$。\n  - $ \\mathbf{f} = (0.8, 0.3, 0.5) $，单位 eV/Å。\n  - $ E_{\\mathrm{int}}^{0} = -0.35 $ eV。\n\n- 案例3（Mg顶位，具有极刚性的表面模式）：\n  - $p = 2$， $q = 1$。\n  - $ \\mathbf{K} = \\mathrm{diag}(16.0, 14.0, 1000000.0) $，单位 eV/Å$^2$。\n  - $ \\mathbf{f} = (2.0, 1.2, 1.0) $，单位 eV/Å。\n  - $ E_{\\mathrm{int}}^{0} = -0.80 $ eV。\n\n要求的输出和格式：\n- 对于每个案例，计算三个浮点数：$ \\Delta_{\\mathrm{SP}} = E_{\\mathrm{ads}}^{\\text{single}} - E_{\\mathrm{ads}}^{\\text{full}} $，$ \\Delta_{\\mathrm{AO}} = E_{\\mathrm{ads}}^{\\text{ads-only}} - E_{\\mathrm{ads}}^{\\text{full}} $，以及 $ \\Delta_{\\mathrm{SO}} = E_{\\mathrm{ads}}^{\\text{surf-only}} - E_{\\mathrm{ads}}^{\\text{full}} $。这些数字必须以eV为单位，并四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含结果，格式为精确的逗号分隔列表的列表：$ [ [\\Delta_{\\mathrm{SP}}^{(1)}, \\Delta_{\\mathrm{AO}}^{(1)}, \\Delta_{\\mathrm{SO}}^{(1)}], [\\Delta_{\\mathrm{SP}}^{(2)}, \\Delta_{\\mathrm{AO}}^{(2)}, \\Delta_{\\mathrm{SO}}^{(2)}], [\\Delta_{\\mathrm{SP}}^{(3)}, \\Delta_{\\mathrm{AO}}^{(3)}, \\Delta_{\\mathrm{SO}}^{(3)}] ] $，其中上标 $ (1), (2), (3) $ 分别表示案例1、2、3。输出必须是单行，不含任何额外文本。所有值均以eV为单位。\n\n要求科学真实性：请勿更改所提供的参数，并确保您的程序精确且确定性地解决定义的二次最小化问题，同时遵守指定的单位。",
            "solution": "用户在计算材料科学领域提供了一个科学上有效且定义明确的问题。该问题要求使用一个具有物理动机的能量景观二次模型，来量化在忽略或仅部分包含结构弛豫时，吸附能计算中的误差。解决方案要求在不同约束下对二次能量泛函进行精确最小化。\n\n基本原理是，总吸附能 $E_{\\mathrm{ads}}$ 是基线单点相互作用能 $E_{\\mathrm{int}}^{0}$ 与一个弛豫能量项 $E_{\\mathrm{rel}}(\\mathbf{x})$ 的和，后者取决于原子相对于参考构型的位移 $\\mathbf{x}$。弛豫能的函数形式如下：\n$$\nE_{\\mathrm{rel}}(\\mathbf{x}) = \\frac{1}{2}\\,\\mathbf{x}^{\\top}\\mathbf{K}\\,\\mathbf{x} - \\mathbf{f}^{\\top}\\mathbf{x}\n$$\n其中 $\\mathbf{K}$ 是正定刚度（Hessian）矩阵，$\\mathbf{f}$ 是力矢量（负梯度）。因此，总吸附能为 $E_{\\mathrm{ads}}(\\mathbf{x}) = E_{\\mathrm{int}}^{0} + E_{\\mathrm{rel}}(\\mathbf{x})$。\n\n为了找到给定允许位移集下的最小能量，我们必须找到使 $E_{\\mathrm{rel}}(\\mathbf{x})$ 最小化的位移矢量 $\\mathbf{x}^*$。这发生在能量相对于允许位移的梯度为零的点。设全套坐标被划分为一个允许坐标集 $\\mathbf{x}_a$ 和一个固定坐标集 $\\mathbf{x}_f = \\mathbf{0}$。通过将能量函数相对于 $\\mathbf{x}_a$ 的梯度设为零来实现最小化：\n$$\n\\nabla_{\\mathbf{x}_a} E_{\\mathrm{rel}}(\\mathbf{x}) = \\mathbf{K}_{aa}\\mathbf{x}_a - \\mathbf{f}_a = \\mathbf{0}\n$$\n其中 $\\mathbf{K}_{aa}$ 是 $\\mathbf{K}$ 中对应于允许坐标的子矩阵，$\\mathbf{f}_a$ 是 $\\mathbf{f}$ 中对应的子矢量。允许坐标的最优位移为 $\\mathbf{x}_a^* = \\mathbf{K}_{aa}^{-1}\\mathbf{f}_a$。\n\n将此结果代回能量泛函（其中 $\\mathbf{x}_f = \\mathbf{0}$），最小弛豫能为：\n$$\nE_{\\mathrm{rel}}^{\\text{min}} = \\frac{1}{2}(\\mathbf{x}_a^*)^{\\top}\\mathbf{K}_{aa}\\mathbf{x}_a^* - \\mathbf{f}_a^{\\top}\\mathbf{x}_a^* = \\frac{1}{2}\\mathbf{f}_a^{\\top}(\\mathbf{K}_{aa}^{-1})^{\\top}\\mathbf{K}_{aa}(\\mathbf{K}_{aa}^{-1}\\mathbf{f}_a) - \\mathbf{f}_a^{\\top}(\\mathbf{K}_{aa}^{-1}\\mathbf{f}_a) = -\\frac{1}{2}\\mathbf{f}_a^{\\top}\\mathbf{K}_{aa}^{-1}\\mathbf{f}_a\n$$\n问题指明刚度矩阵 $\\mathbf{K}$ 是对角矩阵，即 $\\mathbf{K} = \\mathrm{diag}(k_1, k_2, \\dots, k_{p+q})$。这极大地简化了计算，因为自由度是解耦的。其逆矩阵就是 $\\mathbf{K}^{-1} = \\mathrm{diag}(1/k_1, 1/k_2, \\dots, 1/k_{p+q})$。沿坐标子集进行最小化所关联的弛豫能是每个允许坐标 $i$ 的单独弛豫能 $R_i = -\\frac{1}{2}f_i^2/k_i$ 的总和。\n\n我们现在可以定义四种相关的吸附能：\n1.  **单点吸附能 ($E_{\\mathrm{ads}}^{\\text{single}}$)**：不允许弛豫，因此 $\\mathbf{x} = \\mathbf{0}$ 且 $E_{\\mathrm{rel}} = 0$。\n    $$E_{\\mathrm{ads}}^{\\text{single}} = E_{\\mathrm{int}}^{0}$$\n2.  **完全弛豫吸附能 ($E_{\\mathrm{ads}}^{\\text{full}}$)**：所有 $p+q$ 个坐标都进行弛豫。弛豫能是所有坐标上贡献的总和。\n    $$E_{\\mathrm{ads}}^{\\text{full}} = E_{\\mathrm{int}}^{0} - \\frac{1}{2}\\sum_{i=1}^{p+q} \\frac{f_i^2}{k_i}$$\n3.  **仅吸附质弛豫吸附能 ($E_{\\mathrm{ads}}^{\\text{ads-only}}$)**：仅弛豫前 $p$ 个吸附质坐标。\n    $$E_{\\mathrm{ads}}^{\\text{ads-only}} = E_{\\mathrm{int}}^{0} - \\frac{1}{2}\\sum_{i=1}^{p} \\frac{f_i^2}{k_i}$$\n4.  **仅表面弛豫吸附能 ($E_{\\mathrm{ads}}^{\\text{surf-only}}$)**：仅弛豫后 $q$ 个表面坐标。\n    $$E_{\\mathrm{ads}}^{\\text{surf-only}} = E_{\\mathrm{int}}^{0} - \\frac{1}{2}\\sum_{i=p+1}^{p+q} \\frac{f_i^2}{k_i}$$\n\n该问题要求计算三个误差量，它们代表了忽略某些弛豫所带来的能量代价。\n-   **单点与完全弛豫的误差，$\\Delta_{\\mathrm{SP}}$**：这是通过弛豫所有自由度获得的总能量。\n    $$\\Delta_{\\mathrm{SP}} = E_{\\mathrm{ads}}^{\\text{single}} - E_{\\mathrm{ads}}^{\\text{full}} = E_{\\mathrm{int}}^{0} - \\left(E_{\\mathrm{int}}^{0} - \\frac{1}{2}\\sum_{i=1}^{p+q} \\frac{f_i^2}{k_i}\\right) = \\frac{1}{2}\\sum_{i=1}^{p+q} \\frac{f_i^2}{k_i}$$\n-   **仅吸附质与完全弛豫的误差，$\\Delta_{\\mathrm{AO}}$**：这是通过弛豫表面坐标获得的能量，在仅吸附质计算中被忽略了。\n    $$\\Delta_{\\mathrm{AO}} = E_{\\mathrm{ads}}^{\\text{ads-only}} - E_{\\mathrm{ads}}^{\\text{full}} = \\left(E_{\\mathrm{int}}^{0} - \\frac{1}{2}\\sum_{i=1}^{p} \\frac{f_i^2}{k_i}\\right) - \\left(E_{\\mathrm{int}}^{0} - \\frac{1}{2}\\sum_{i=1}^{p+q} \\frac{f_i^2}{k_i}\\right) = \\frac{1}{2}\\sum_{i=p+1}^{p+q} \\frac{f_i^2}{k_i}$$\n-   **仅表面与完全弛豫的误差，$\\Delta_{\\mathrm{SO}}$**：这是通过弛豫吸附质坐标获得的能量，在仅表面计算中被忽略了。\n    $$\\Delta_{\\mathrm{SO}} = E_{\\mathrm{ads}}^{\\text{surf-only}} - E_{\\mathrm{ads}}^{\\text{full}} = \\left(E_{\\mathrm{int}}^{0} - \\frac{1}{2}\\sum_{i=p+1}^{p+q} \\frac{f_i^2}{k_i}\\right) - \\left(E_{\\mathrm{int}}^{0} - \\frac{1}{2}\\sum_{i=1}^{p+q} \\frac{f_i^2}{k_i}\\right) = \\frac{1}{2}\\sum_{i=1}^{p} \\frac{f_i^2}{k_i}$$\n\n注意这个简单的关系式 $\\Delta_{\\mathrm{SP}} = \\Delta_{\\mathrm{AO}} + \\Delta_{\\mathrm{SO}}$，它之所以成立是因为自由度是解耦的（即 $\\mathbf{K}$ 是对角矩阵）。\n\n算法如下：\n对于每个测试用例，给定参数 $p$、$q$、$\\mathbf{K}=\\mathrm{diag}(k_i)$ 和 $\\mathbf{f}=(f_i)$：\n1.  计算每个自由度的单独弛豫能贡献：$E_{\\mathrm{rel},i} = \\frac{1}{2} \\frac{f_i^2}{k_i}$。\n2.  通过对前 $p$ 个坐标求和，计算总的吸附质弛豫能：$E_{\\mathrm{relax, ads}} = \\sum_{i=1}^{p} E_{\\mathrm{rel},i}$。这等于 $\\Delta_{\\mathrm{SO}}$。\n3.  通过对后 $q$ 个坐标求和，计算总的表面弛豫能：$E_{\\mathrm{relax, surf}} = \\sum_{i=p+1}^{p+q} E_{\\mathrm{rel},i}$。这等于 $\\Delta_{\\mathrm{AO}}$。\n4.  计算总弛豫能：$E_{\\mathrm{relax, total}} = E_{\\mathrm{relax, ads}} + E_{\\mathrm{relax, surf}}$。这等于 $\\Delta_{\\mathrm{SP}}$。\n5.  收集三个误差项 $[\\Delta_{\\mathrm{SP}}, \\Delta_{\\mathrm{AO}}, \\Delta_{\\mathrm{SO}}]$，将每个值四舍五入到三位小数，并按要求格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates and compares single-point versus relaxed adsorption energies\n    for three test cases using a quadratic surrogate model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (Mg-top site, moderately strong acid-base interaction)\n        {\n            \"p\": 2, \"q\": 1,\n            \"K_diag\": np.array([18.0, 12.0, 45.0]),\n            \"f\": np.array([2.5, 1.0, 1.5]),\n        },\n        # Case 2 (O-top site, weaker interaction)\n        {\n            \"p\": 2, \"q\": 1,\n            \"K_diag\": np.array([10.0, 8.0, 30.0]),\n            \"f\": np.array([0.8, 0.3, 0.5]),\n        },\n        # Case 3 (Mg-top site with an extremely stiff surface mode)\n        {\n            \"p\": 2, \"q\": 1,\n            \"K_diag\": np.array([16.0, 14.0, 1000000.0]),\n            \"f\": np.array([2.0, 1.2, 1.0]),\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        p = case[\"p\"]\n        k = case[\"K_diag\"]\n        f = case[\"f\"]\n        \n        # Calculate the relaxation energy contribution for each coordinate.\n        # This is E_rel,i = 0.5 * f_i^2 / k_i.\n        relaxation_energies = 0.5 * np.square(f) / k\n        \n        # The energy gain from relaxing adsorbate coordinates corresponds to Delta_SO.\n        # This is the sum over the first p coordinates.\n        delta_so = np.sum(relaxation_energies[:p])\n        \n        # The energy gain from relaxing surface coordinates corresponds to Delta_AO.\n        # This is the sum over the last q coordinates.\n        delta_ao = np.sum(relaxation_energies[p:])\n        \n        # The total relaxation energy corresponds to Delta_SP.\n        # Since K is diagonal, this is the sum of adsorbate and surface relaxations.\n        delta_sp = delta_so + delta_ao\n        \n        # Assemble the results for the current case.\n        # The problem asks for positive floats rounded to three decimal places.\n        case_results = [delta_sp, delta_ao, delta_so]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified.\n    # The output is a comma-separated list of lists, with no spaces.\n    inner_lists_str = []\n    for res_list in all_results:\n        # Format each number to always show 3 decimal places.\n        formatted_nums = [f\"{x:.3f}\" for x in res_list]\n        # Join numbers with a comma.\n        inner_str = f\"[{','.join(formatted_nums)}]\"\n        inner_lists_str.append(inner_str)\n        \n    # Join the string representations of inner lists with a comma.\n    final_output_str = f\"[{','.join(inner_lists_str)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "获得可靠的吸附能需要对计算参数（如$k$点网格、截断能等）进行仔细的收敛性测试。然而，一个更微妙的挑战是“误差抵消”现象：各部分（吸附质、平板）能量计算的较大误差可能偶然相互抵消，得到一个看似准确的吸附能。本练习  让你通过实现一个包含多种误差来源的综合模型，学习如何构建一个诊断工具，以区分真实的收敛与这种具有误导性的结果。",
            "id": "3432197",
            "problem": "要求您实现一项程序化研究，探讨密度泛函理论 (DFT) 板层计算中的数值参数如何影响计算得到的表面吸附能，并识别表观上的一致是何时由误差抵消而非真正的收敛所致。从第一性原理出发：玻恩–奥本海默总电子能量定义了一个构型的能量状态，而吸附能是吸附物和板层分离的初始态与吸附物结合到板层的最终态之间的总能量变化。将吸附能的表达式推导为物理上明确定义的状态的总能量之差，然后构建一个算法来评估其如何随数值参数收敛。\n\n模型和单位。考虑三个体系：吸附了吸附物的板层、洁净板层以及气相中的孤立吸附物，分别用标签 “sa”、“slab” 和 “gas” 表示。在理想的无限精度极限下，对应的玻恩–奥本海默总能量是固定常数：$E_{\\mathrm{sa}}^{\\mathrm{true}}=-123.456\\,\\mathrm{eV}$，$E_{\\mathrm{slab}}^{\\mathrm{true}}=-120.000\\,\\mathrm{eV}$ 和 $E_{\\mathrm{gas}}^{\\mathrm{true}}=-1.900\\,\\mathrm{eV}$。由于四个可系统控制的数值参数，计算得到的总能量会偏离这些真实值：布里渊区采样 $N_k$（无量纲）、平面波截断能 $E_{\\mathrm{cut}}$（单位为电子伏特）、板层中的原子层数 $N_{\\mathrm{layers}}$（无量纲）以及真空层厚度 $d_{\\mathrm{vac}}$（单位为埃）。对于每个标签 $x\\in\\{\\mathrm{sa},\\mathrm{slab},\\mathrm{gas}\\}$，计算得到的能量 $E_x(N_k,E_{\\mathrm{cut}},N_{\\mathrm{layers}},d_{\\mathrm{vac}})$ 被建模为 $E_x^{\\mathrm{true}}$ 加上一系列有物理动机的误差项之和：\n$$E_x(N_k,E_{\\mathrm{cut}},N_{\\mathrm{layers}},d_{\\mathrm{vac}})=E_x^{\\mathrm{true}}+\\varepsilon_{k}^{(x)}(N_k)+\\varepsilon_{\\mathrm{pw}}^{(x)}(E_{\\mathrm{cut}})+\\varepsilon_{\\mathrm{layers}}^{(x)}(N_{\\mathrm{layers}})+\\varepsilon_{\\mathrm{vac}}^{(x)}(d_{\\mathrm{vac}})+\\varepsilon_{\\times 1}^{(x)}(E_{\\mathrm{cut}},N_{\\mathrm{layers}})+\\varepsilon_{\\times 2}^{(x)}(N_k,N_{\\mathrm{layers}})。$$\n这些误差项编码了经过充分检验的渐进行为：\n- 布里渊区积分误差（光滑函数的积分）：$$\\varepsilon_{k}^{(\\mathrm{sa})}(N_k)=\\frac{A_{k}^{(\\mathrm{sa})}}{N_k^2},\\quad \\varepsilon_{k}^{(\\mathrm{slab})}(N_k)=\\frac{A_{k}^{(\\mathrm{slab})}}{N_k^2},\\quad \\varepsilon_{k}^{(\\mathrm{gas})}(N_k)=\\frac{A_{k}^{(\\mathrm{gas})}}{N_k^2},$$ 其中 $A_{k}^{(\\mathrm{sa})}=3.0\\,\\mathrm{eV}$，$A_{k}^{(\\mathrm{slab})}=2.5\\,\\mathrm{eV}$，$A_{k}^{(\\mathrm{gas})}=0.2\\,\\mathrm{eV}$。\n- 平面波基组截断误差（傅里叶尾部衰减）：$$\\varepsilon_{\\mathrm{pw}}^{(x)}(E_{\\mathrm{cut}})=\\frac{A_{\\mathrm{pw}}^{(x)}}{E_{\\mathrm{cut}}^{3/2}},$$ 其中 $A_{\\mathrm{pw}}^{(\\mathrm{sa})}=200.0\\,\\mathrm{eV}$，$A_{\\mathrm{pw}}^{(\\mathrm{slab})}=180.0\\,\\mathrm{eV}$，$A_{\\mathrm{pw}}^{(\\mathrm{gas})}=10.0\\,\\mathrm{eV}$。\n- 板层厚度有限尺寸误差（镜像相互作用和量子限制效应）：$$\\varepsilon_{\\mathrm{layers}}^{(\\mathrm{slab})}(N_{\\mathrm{layers}})=\\frac{A_{\\mathrm{layers}}^{(\\mathrm{slab})}}{N_{\\mathrm{layers}}^2}+B_{\\mathrm{layers}}^{(\\mathrm{slab})}\\exp\\!\\left(-\\frac{N_{\\mathrm{layers}}}{L_{\\mathrm{layers}}^{(\\mathrm{slab})}}\\right),$$ $$\\varepsilon_{\\mathrm{layers}}^{(\\mathrm{sa})}(N_{\\mathrm{layers}})=\\frac{A_{\\mathrm{layers}}^{(\\mathrm{sa})}}{N_{\\mathrm{layers}}^2}+B_{\\mathrm{layers}}^{(\\mathrm{sa})}\\exp\\!\\left(-\\frac{N_{\\mathrm{layers}}}{L_{\\mathrm{layers}}^{(\\mathrm{sa})}}\\right),$$ $$\\varepsilon_{\\mathrm{layers}}^{(\\mathrm{gas})}(N_{\\mathrm{layers}})=0,$$ 其中 $A_{\\mathrm{layers}}^{(\\mathrm{slab})}=0.8\\,\\mathrm{eV}$，$B_{\\mathrm{layers}}^{(\\mathrm{slab})}=0.5\\,\\mathrm{eV}$，$L_{\\mathrm{layers}}^{(\\mathrm{slab})}=2.5$，以及 $A_{\\mathrm{layers}}^{(\\mathrm{sa})}=0.9\\,\\mathrm{eV}$，$B_{\\mathrm{layers}}^{(\\mathrm{sa})}=0.4\\,\\mathrm{eV}$，$L_{\\mathrm{layers}}^{(\\mathrm{sa})}=2.2$。\n- 真空层有限尺寸误差（残余偶极相互作用和代数镜像尾部）：$$\\varepsilon_{\\mathrm{vac}}^{(\\mathrm{slab})}(d_{\\mathrm{vac}})=A_{\\mathrm{vac}}^{(\\mathrm{slab})}\\exp\\!\\left(-\\frac{d_{\\mathrm{vac}}}{L_{\\mathrm{vac}}^{(\\mathrm{slab})}}\\right)+\\frac{\\phi^{(\\mathrm{slab})}}{d_{\\mathrm{vac}}^2},$$ $$\\varepsilon_{\\mathrm{vac}}^{(\\mathrm{sa})}(d_{\\mathrm{vac}})=A_{\\mathrm{vac}}^{(\\mathrm{sa})}\\exp\\!\\left(-\\frac{d_{\\mathrm{vac}}}{L_{\\mathrm{vac}}^{(\\mathrm{sa})}}\\right)+\\frac{\\phi^{(\\mathrm{sa})}}{d_{\\mathrm{vac}}^2},$$ $$\\varepsilon_{\\mathrm{vac}}^{(\\mathrm{gas})}(d_{\\mathrm{vac}})=0,$$ 其中 $A_{\\mathrm{vac}}^{(\\mathrm{slab})}=0.35\\,\\mathrm{eV}$，$L_{\\mathrm{vac}}^{(\\mathrm{slab})}=4.0\\,\\text{\\AA}$，$\\phi^{(\\mathrm{slab})}=1.2\\,\\mathrm{eV}\\cdot\\text{\\AA}^2$，以及 $A_{\\mathrm{vac}}^{(\\mathrm{sa})}=0.40\\,\\mathrm{eV}$，$L_{\\mathrm{vac}}^{(\\mathrm{sa})}=3.5\\,\\text{\\AA}$，$\\phi^{(\\mathrm{sa})}=1.0\\,\\mathrm{eV}\\cdot\\text{\\AA}^2$。\n- 捕捉离散化之间耦合的交叉项：$$\\varepsilon_{\\times 1}^{(x)}(E_{\\mathrm{cut}},N_{\\mathrm{layers}})=\\frac{\\kappa^{(x)}}{E_{\\mathrm{cut}}\\,N_{\\mathrm{layers}}},\\qquad \\varepsilon_{\\times 2}^{(x)}(N_k,N_{\\mathrm{layers}})=\\frac{\\mu^{(x)}}{N_k\\,N_{\\mathrm{layers}}},$$ 其中 $\\kappa^{(\\mathrm{sa})}=\\kappa^{(\\mathrm{slab})}=5.0\\,\\mathrm{eV}$，$\\kappa^{(\\mathrm{gas})}=0.5\\,\\mathrm{eV}$，以及 $\\mu^{(\\mathrm{sa})}=\\mu^{(\\mathrm{slab})}=0.6\\,\\mathrm{eV}$，$\\mu^{(\\mathrm{gas})}=0.05\\,\\mathrm{eV}$。\n\n任务。\n1. 从玻恩–奥本海默关于总能量是态函数的概念出发，以及吸附过程是从分离态到结合态的转变这一物理定义，推导吸附能作为三个总能量 $E_{\\mathrm{sa}}$、$E_{\\mathrm{slab}}$ 和 $E_{\\mathrm{gas}}$ 组合的数学表达式。不要使用简便公式；相反，应从能量守恒以及分离参考态中无相互作用子系统能量的可加性出发进行论证。\n2. 实现一个算法，对于给定的 $(N_k,E_{\\mathrm{cut}},N_{\\mathrm{layers}},d_{\\mathrm{vac}})$，通过上述模型计算 $E_{\\mathrm{sa}}$、$E_{\\mathrm{slab}}$ 和 $E_{\\mathrm{gas}}$，然后计算吸附能及其与使用真实常数定义的真实吸附能的偏差。能量必须以电子伏特 (eV) 表示。\n3. 误差抵消诊断。为表观收敛的吸附能定义一个阈值 $\\tau_{\\mathrm{ads}}=0.04\\,\\mathrm{eV}$，并为显著的组分误差定义一个阈值 $\\tau_{\\mathrm{comp}}=0.10\\,\\mathrm{eV}$。如果吸附能绝对偏差严格小于 $\\tau_{\\mathrm{ads}}$，而至少有两个组分绝对误差 $\\{|\\varepsilon^{(\\mathrm{sa})}|,|\\varepsilon^{(\\mathrm{slab})}|,|\\varepsilon^{(\\mathrm{gas})}|\\}$ 大于或等于 $\\tau_{\\mathrm{comp}}$，则声明为“误导性抵消”。\n4. 测试套件。在以下探测不同区间的参数集上评估您的程序，并返回吸附能值和诊断结果：\n   - 情况 A（良好收敛）：$N_k=24$，$E_{\\mathrm{cut}}=800\\,\\mathrm{eV}$，$N_{\\mathrm{layers}}=10$，$d_{\\mathrm{vac}}=20\\,\\text{\\AA}$。\n   - 情况 B（通过抵消实现的表观一致）：$N_k=8$，$E_{\\mathrm{cut}}=350\\,\\mathrm{eV}$，$N_{\\mathrm{layers}}=4$，$d_{\\mathrm{vac}}=12\\,\\text{\\AA}$。\n   - 情况 C（受真空层限制，存在抵消）：$N_k=16$，$E_{\\mathrm{cut}}=450\\,\\mathrm{eV}$，$N_{\\mathrm{layers}}=8$，$d_{\\mathrm{vac}}=6\\,\\text{\\AA}$。\n   - 情况 D（严重欠收敛）：$N_k=1$，$E_{\\mathrm{cut}}=250\\,\\mathrm{eV}$，$N_{\\mathrm{layers}}=3$，$d_{\\mathrm{vac}}=8\\,\\text{\\AA}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个案例的结果本身是一个二元列表 $[E_{\\mathrm{ads}},\\text{flag}]$。这里，$E_{\\mathrm{ads}}$ 是以电子伏特为单位计算的吸附能（四舍五入到三位小数），而 $\\text{flag}$ 是一个布尔值，指示是否检测到误导性抵消。例如，整体形式必须像 $[[e_1,b_1],[e_2,b_2],[e_3,b_3],[e_4,b_4]]$。",
            "solution": "该问题要求推导并实现一个用于密度泛函理论 (DFT) 中吸附能计算的模型，重点在于识别误导性的误差抵消。解决方案分两个阶段进行：首先，根据基本原理推导吸附能表达式；其次，基于所提供的误差模型设计算法来计算该能量并诊断数值伪影。\n\n定义吸附能的基本原理是总能量守恒，在玻恩–奥本海默近似的背景下，总能量是系统原子构型的态函数。吸附过程是一个从初始的无相互作用态到最终的相互作用态的转变。\n\n1.  **初始态**：初始态由一个洁净的固体表面（板层）和一个气相吸附物分子组成。假设这两个组分无限分离，因此没有相互作用。一个由无相互作用组分组成的系统的总能量是其各自能量的总和。设 $E_{\\mathrm{slab}}$ 为孤立板层的总能量，$E_{\\mathrm{gas}}$ 为孤立气相分子的总能量。那么，初始态的总能量 $E_{\\mathrm{initial}}$ 为：\n    $$E_{\\mathrm{initial}} = E_{\\mathrm{slab}} + E_{\\mathrm{gas}}$$\n\n2.  **最终态**：最终态是吸附物与板层表面结合的单一相互作用体系。设其总能量为 $E_{\\mathrm{sa}}$，定义了最终态的能量 $E_{\\mathrm{final}}$：\n    $$E_{\\mathrm{final}} = E_{\\mathrm{sa}}$$\n\n3.  **吸附能 ($E_{\\mathrm{ads}}$)**：吸附能是吸附过程中的总能量变化，定义为 $E_{\\mathrm{final}} - E_{\\mathrm{initial}}$。根据表面科学的惯例，负值表示释放能量的放热过程。\n    $$E_{\\mathrm{ads}} = E_{\\mathrm{final}} - E_{\\mathrm{initial}} = E_{\\mathrm{sa}} - (E_{\\mathrm{slab}} + E_{\\mathrm{gas}})$$\n    这个表达式是基础性的，它既适用于理想化的精确能量，也适用于通过有限数值精度计算出的能量，前提是所有三个组分（$E_{\\mathrm{sa}}$、$E_{\\mathrm{slab}}$ 和 $E_{\\mathrm{gas}}$）的计算都使用相同的理论水平和数值参数。\n\n真实吸附能 $E_{\\mathrm{ads}}^{\\mathrm{true}}$ 是根据给定的真实总能量计算得出的：\n$$E_{\\mathrm{ads}}^{\\mathrm{true}} = E_{\\mathrm{sa}}^{\\mathrm{true}} - (E_{\\mathrm{slab}}^{\\mathrm{true}} + E_{\\mathrm{gas}}^{\\mathrm{true}})$$\n$$E_{\\mathrm{ads}}^{\\mathrm{true}} = (-123.456\\,\\mathrm{eV}) - ((-120.000\\,\\mathrm{eV}) + (-1.900\\,\\mathrm{eV})) = -123.456\\,\\mathrm{eV} - (-121.900\\,\\mathrm{eV}) = -1.556\\,\\mathrm{eV}$$\n\n计算得到的吸附能 $E_{\\mathrm{ads}}^{\\mathrm{comp}}$ 是使用对 $x \\in \\{\\mathrm{sa}, \\mathrm{slab}, \\mathrm{gas}\\}$ 数值计算的能量 $E_x(N_k, E_{\\mathrm{cut}}, N_{\\mathrm{layers}}, d_{\\mathrm{vac}})$ 来计算的。计算吸附能的误差为 $\\Delta E_{\\mathrm{ads}} = E_{\\mathrm{ads}}^{\\mathrm{comp}} - E_{\\mathrm{ads}}^{\\mathrm{true}}$。此误差可以用每个组分的总数值误差 $\\varepsilon^{(x)} = E_{x}^{\\mathrm{comp}} - E_{x}^{\\mathrm{true}}$ 来表示：\n$$\\Delta E_{\\mathrm{ads}} = (E_{\\mathrm{sa}}^{\\mathrm{comp}} - E_{\\mathrm{sa}}^{\\mathrm{true}}) - (E_{\\mathrm{slab}}^{\\mathrm{comp}} - E_{\\mathrm{slab}}^{\\mathrm{true}}) - (E_{\\mathrm{gas}}^{\\mathrm{comp}} - E_{\\mathrm{gas}}^{\\mathrm{true}})$$\n$$\\Delta E_{\\mathrm{ads}} = \\varepsilon^{(\\mathrm{sa})} - \\varepsilon^{(\\mathrm{slab})} - \\varepsilon^{(\\mathrm{gas})}$$\n这个关系表明，即使单个误差 $\\varepsilon^{(x)}$ 很大，$\\Delta E_{\\mathrm{ads}}$ 也可能很小，这种现象被称为误差抵消。例如，如果 $\\varepsilon^{(\\mathrm{sa})} \\approx \\varepsilon^{(\\mathrm{slab})}$ 且 $\\varepsilon^{(\\mathrm{gas})}$ 很小，$\\Delta E_{\\mathrm{ads}}$ 将接近于零。“误导性抵消”的诊断方法就是为了检测这种情况。\n\n解决该问题的算法如下：\n首先，我们将所提供的常数和模型参数结构化，以便于访问。然后，对于每个由一组数值参数 $(N_k, E_{\\mathrm{cut}}, N_{\\mathrm{layers}}, d_{\\mathrm{vac}})$ 定义的测试用例：\n1.  对于每个体系 $x \\in \\{\\mathrm{sa}, \\mathrm{slab}, \\mathrm{gas}\\}$，通过将所有六个指定误差项的贡献相加，计算总数值误差 $\\varepsilon^{(x)}$：\n    $$\\varepsilon^{(x)}(N_k, E_{\\mathrm{cut}}, N_{\\mathrm{layers}}, d_{\\mathrm{vac}}) = \\varepsilon_{k}^{(x)} + \\varepsilon_{\\mathrm{pw}}^{(x)} + \\varepsilon_{\\mathrm{layers}}^{(x)} + \\varepsilon_{\\mathrm{vac}}^{(x)} + \\varepsilon_{\\times 1}^{(x)} + \\varepsilon_{\\times 2}^{(x)}$$\n2.  计算每个体系的计算总能量：$E_x^{\\mathrm{comp}} = E_x^{\\mathrm{true}} + \\varepsilon^{(x)}$。\n3.  计算吸附能：$E_{\\mathrm{ads}}^{\\mathrm{comp}} = E_{\\mathrm{sa}}^{\\mathrm{comp}} - (E_{\\mathrm{slab}}^{\\mathrm{comp}} + E_{\\mathrm{gas}}^{\\mathrm{comp}})$。\n4.  计算吸附能的偏差：$\\Delta E_{\\mathrm{ads}} = E_{\\mathrm{ads}}^{\\mathrm{comp}} - E_{\\mathrm{ads}}^{\\mathrm{true}}$。\n5.  应用误导性抵消诊断：\n    a. 检查吸附能绝对偏差是否低于其阈值：$|\\Delta E_{\\mathrm{ads}}|  \\tau_{\\mathrm{ads}}$，其中 $\\tau_{\\mathrm{ads}} = 0.04\\,\\mathrm{eV}$。\n    b. 统计总绝对误差达到或超过其阈值的组分数量：检查 $|\\varepsilon^{(\\mathrm{sa})}|, |\\varepsilon^{(\\mathrm{slab})}|, |\\varepsilon^{(\\mathrm{gas})}|$ 中有多少个大于或等于 $\\tau_{\\mathrm{comp}}$，其中 $\\tau_{\\mathrm{comp}} = 0.10\\,\\mathrm{eV}$。\n    c. 如果 (a) 条件为真且 (b) 中的计数大于或等于 2，则将误导性抵消标志设置为真。否则，为假。\n6.  该测试用例的结果是一个列表，其中包含四舍五入到三位小数的计算吸附能和布尔类型的抵消标志。将所有测试用例的这些结果汇总并格式化为最终的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes adsorption energy and diagnoses error cancellation based on a\n    model of DFT convergence behavior.\n    \"\"\"\n\n    # --- Step 1: Define Constants and Models ---\n    \n    # True energies in eV\n    E_true = {\n        'sa': -123.456,\n        'slab': -120.000,\n        'gas': -1.900\n    }\n    \n    # Coefficients for error models\n    # The units provided in the problem for some coefficients are notationally\n    # inconsistent, but the numerical values are interpreted as correct for use\n    # in the given formulas to yield energies in eV.\n    coeffs = {\n        'A_k': {'sa': 3.0, 'slab': 2.5, 'gas': 0.2}, # eV\n        'A_pw': {'sa': 200.0, 'slab': 180.0, 'gas': 10.0}, # eV^(5/2) implied\n        'A_layers': {'sa': 0.9, 'slab': 0.8}, # eV\n        'B_layers': {'sa': 0.4, 'slab': 0.5}, # eV\n        'L_layers': {'sa': 2.2, 'slab': 2.5}, # unitless\n        'A_vac': {'sa': 0.40, 'slab': 0.35}, # eV\n        'L_vac': {'sa': 3.5, 'slab': 4.0}, # Angstrom\n        'phi': {'sa': 1.0, 'slab': 1.2}, # eV * Angstrom^2\n        'kappa': {'sa': 5.0, 'slab': 5.0, 'gas': 0.5}, # eV^2 implied\n        'mu': {'sa': 0.6, 'slab': 0.6, 'gas': 0.05} # eV\n    }\n\n    # --- Step 2: Implement Error Functions ---\n    \n    def get_total_error(label, Nk, Ecut, Nlayers, dvac):\n        \"\"\"Calculates the total numerical error for a given system and parameters.\"\"\"\n        \n        # Brillouin zone integration error\n        err_k = coeffs['A_k'][label] / (Nk**2)\n        \n        # Plane-wave basis truncation error\n        err_pw = coeffs['A_pw'][label] / (Ecut**(3/2))\n        \n        # Slab thickness finite-size error\n        if label in ['sa', 'slab']:\n            err_layers = (coeffs['A_layers'][label] / (Nlayers**2) + \n                         coeffs['B_layers'][label] * np.exp(-Nlayers / coeffs['L_layers'][label]))\n        else: # gas\n            err_layers = 0.0\n        \n        # Vacuum finite-size error\n        if label in ['sa', 'slab']:\n            err_vac = (coeffs['A_vac'][label] * np.exp(-dvac / coeffs['L_vac'][label]) +\n                       coeffs['phi'][label] / (dvac**2))\n        else: # gas\n            err_vac = 0.0\n            \n        # Cross term 1\n        err_x1 = coeffs['kappa'][label] / (Ecut * Nlayers)\n        \n        # Cross term 2\n        err_x2 = coeffs['mu'][label] / (Nk * Nlayers)\n        \n        total_err = err_k + err_pw + err_layers + err_vac + err_x1 + err_x2\n        return total_err\n\n    # --- Step 3: Define Test Cases and Thresholds ---\n    \n    test_cases = [\n        # Case A (well-converged)\n        {'Nk': 24, 'Ecut': 800, 'Nlayers': 10, 'dvac': 20},\n        # Case B (apparent agreement by cancellation)\n        {'Nk': 8, 'Ecut': 350, 'Nlayers': 4, 'dvac': 12},\n        # Case C (vacuum-limited, cancellation present)\n        {'Nk': 16, 'Ecut': 450, 'Nlayers': 8, 'dvac': 6},\n        # Case D (severely under-converged)\n        {'Nk': 1, 'Ecut': 250, 'Nlayers': 3, 'dvac': 8},\n    ]\n\n    tau_ads = 0.04  # eV\n    tau_comp = 0.10 # eV\n\n    # --- Step 4: Main Calculation Loop ---\n    \n    results = []\n    \n    # Calculate true adsorption energy for reference\n    E_ads_true = E_true['sa'] - (E_true['slab'] + E_true['gas'])\n\n    for params in test_cases:\n        # Calculate numerical errors for each component\n        err_sa = get_total_error('sa', **params)\n        err_slab = get_total_error('slab', **params)\n        err_gas = get_total_error('gas', **params)\n        \n        # Calculate computed total energies\n        E_comp_sa = E_true['sa'] + err_sa\n        E_comp_slab = E_true['slab'] + err_slab\n        E_comp_gas = E_true['gas'] + err_gas\n        \n        # Calculate computed adsorption energy\n        E_ads_comp = E_comp_sa - (E_comp_slab + E_comp_gas)\n        \n        # Calculate adsorption energy deviation\n        delta_E_ads = E_ads_comp - E_ads_true\n        \n        # --- Step 5: Apply Error Cancellation Diagnostic ---\n        \n        # Check condition 1: |delta_E_ads|  tau_ads\n        cond1 = abs(delta_E_ads)  tau_ads\n        \n        # Check condition 2: number of large component errors\n        component_errors = [abs(err_sa), abs(err_slab), abs(err_gas)]\n        large_error_count = sum(1 for err in component_errors if err >= tau_comp)\n        cond2 = large_error_count >= 2\n        \n        misleading_cancellation = cond1 and cond2\n        \n        # Store results for this case\n        # Standard round() is sufficient and appropriate here\n        rounded_E_ads = round(E_ads_comp, 3)\n\n        # Format boolean as lowercase true/false as in typical JSON/list outputs\n        # This is a bit ambiguous in the prompt, so using standard Python bool representation.\n        # After re-reading the prompt, it does not specify string or native boolean.\n        # A list of lists containing floats and booleans is a valid python structure.\n        results.append([rounded_E_ads, misleading_cancellation])\n\n    # --- Step 6: Format and Print Final Output ---\n    # The formatting needs to be precise, converting Python list of lists to the specified string format\n    # with lowercase booleans.\n    def format_result(res):\n        e_ads, flag = res\n        # Ensure three decimal places even for round numbers\n        e_ads_str = f\"{e_ads:.3f}\"\n        flag_str = str(flag).lower()\n        return f\"[{e_ads_str},{flag_str}]\"\n\n    output_str = f\"[{','.join(map(format_result, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}