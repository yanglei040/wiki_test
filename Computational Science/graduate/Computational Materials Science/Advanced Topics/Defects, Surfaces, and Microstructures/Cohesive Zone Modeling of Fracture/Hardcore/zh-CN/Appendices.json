{
    "hands_on_practices": [
        {
            "introduction": "内聚区模型的有效性在很大程度上取决于其核心——牵引力-分离法则（Traction-Separation Law, TSL）——的准确性。由于这些法则是现象学的，因此其参数（如内聚强度 $\\sigma_{\\max}$ 和断裂能 $G_c$）必须通过实验或更底层的模拟来确定。本练习将指导您完成一个关键的多尺度建模任务：从原子模拟得到的离散力-位移数据中，通过非线性最小二乘法拟合一个连续的指数形式TSL，从而提取出宏观的内聚参数 。这个过程是连接微观机理和宏观断裂行为的桥梁，是进行高保真度断裂模拟的基础。",
            "id": "3439023",
            "problem": "给定一个界面的原子尺度计算的牵引力-分离数据，该界面被假设遵循指数形式的牵引力-分离定律 (Traction–Separation Law, TSL)。该 TSL 的形式为 $T(\\delta)=\\sigma_{\\max}(\\delta/\\delta_0)\\exp(1-\\delta/\\delta_0)$，其中 $T(\\delta)$ 是分离量为 $\\delta$ 时的牵引力，$\\sigma_{\\max}$ 是峰值牵引力，$\\delta_0$ 是牵引力达到最大值时的分离量。从分离功（断裂能）$G_c$ 是牵引力-分离曲线下面积的基本定义出发，您的任务是通过最小化测量牵引力与 TSL 预测值之间的残差平方和，确定最能拟合所提供数据的 $G_c$ 和 $\\delta_0$。\n\n使用以下基本原则：\n- 分离功（断裂能）定义为 $G_c=\\int_0^{\\infty}T(\\delta)\\,\\mathrm{d}\\delta$。\n- 最佳拟合参数使目标函数 $\\sum_i\\left(T_i - T(\\delta_i;\\sigma_{\\max},\\delta_0)\\right)^2$ 最小化，其中 $T_i$ 是测量的牵引力，$\\delta_i$ 是测量的分离量。\n\n为保证数值一致性，分离量必须以纳米（nanometers）表示，牵引力必须以吉帕斯卡（gigapascals）表示。计算 $G_c$，单位为焦耳/平方米。在根据拟合参数计算 $G_c$ 时，通过将 $\\sigma_{\\max}$ 从吉帕斯卡转换为帕斯卡，并将 $\\delta_0$ 从纳米转换为米，来确保单位一致性。\n\n您必须实现一个程序，对每个测试案例执行以下步骤：\n1. 通过带约束的非线性最小二乘法将参数 $\\sigma_{\\max}$ 和 $\\delta_0$ 拟合到所提供的牵引力-分离数据集，约束条件为 $\\sigma_{\\max}0$ 和 $\\delta_00$。\n2. 使用拟合参数，通过将 $T(\\delta)$ 对 $\\delta$ 从零到无穷大进行积分来计算 $G_c$。\n3. 输出拟合的 $\\delta_0$（单位为纳米）和计算出的 $G_c$（单位为焦耳/平方米）。\n\n测试套件：\n您必须使用下面定义的合成数据集。在每种情况下，测量数据 $\\{(\\delta_i, T_i)\\}$ 都是从具有已知底层参数集的模型中确定性地生成的，并带有一个模拟原子尺度噪声的确定性非随机扰动。对于每种情况，分离点 $\\delta_i$ 均按指定值，真实牵引力为 $T_{\\text{true}}(\\delta_i)=\\sigma_{\\max}(\\delta_i/\\delta_0)\\exp(1-\\delta_i/\\delta_0)$，其中 $\\sigma_{\\max}$ 和 $\\delta_0$ 为给定的真实值，测量牵引力为 $T_i=T_{\\text{true}}(\\delta_i)+\\Delta T(\\delta_i)$，其确定性扰动为\n$$\\Delta T(\\delta)=\\alpha\\,\\sigma_{\\max}\\left(\\frac{\\delta}{\\delta_0}\\right)\\exp\\!\\left(-\\frac{\\delta}{\\delta_0}\\right)\\sin\\!\\left(\\beta\\,\\frac{\\delta}{\\delta_0}\\right),$$\n其中 $\\alpha$ 和 $\\beta$ 是特定于案例的常数。所有牵引力单位为吉帕斯卡，分离量单位为纳米。\n\n- 案例 $1$（一般情况）：\n  - 真实参数：$\\sigma_{\\max}=\\,$$4.0$ 吉帕斯卡，$\\delta_0=\\,$$0.20$ 纳米。\n  - 采样：$\\delta_i=\\,$$i\\times 0.05$ 纳米，对于 $i=\\,$$0,1,2,\\dots,24$（即范围 $0$ 到 $1.20$ 纳米）。\n  - 扰动常数：$\\alpha=\\,$$0.05$, $\\beta=\\,$$3.0$。\n\n- 案例 $2$（尖锐内聚响应，小 $\\delta_0$）：\n  - 真实参数：$\\sigma_{\\max}=\\,$$9.0$ 吉帕斯卡，$\\delta_0=\\,$$0.05$ 纳米。\n  - 采样：$\\delta_i=\\,$$i\\times 0.01$ 纳米，对于 $i=\\,$$0,1,2,\\dots,50$（即范围 $0$ 到 $0.50$ 纳米）。\n  - 扰动常数：$\\alpha=\\,$$0.03$, $\\beta=\\,$$4.0$。\n\n- 案例 $3$（宽缓内聚响应，大 $\\delta_0$）：\n  - 真实参数：$\\sigma_{\\max}=\\,$$1.8$ 吉帕斯卡，$\\delta_0=\\,$$0.60$ 纳米。\n  - 采样：$\\delta_i=\\,$$i\\times 0.10$ 纳米，对于 $i=\\,$$0,1,2,\\dots,30$（即范围 $0$ 到 $3.00$ 纳米）。\n  - 扰动常数：$\\alpha=\\,$$0.04$, $\\beta=\\,$$2.5$。\n\n算法要求：\n- 对每个数据集使用带约束的非线性最小二乘法拟合模型参数，边界条件为 $\\sigma_{\\max}\\,$$0$ 和 $\\delta_0\\,$$0$。\n- 通过使用 $\\sigma_{\\max}^{(0)}=\\max_i T_i$ 和在索引 $k$ 处的 $\\delta_0^{(0)}=\\delta_{k}$（其中 $T_k=\\max_i T_i$）来估计初始猜测值。\n- 使用拟合参数，通过对 $\\delta\\in[0,\\infty)$ 上的 $T(\\delta)$ 进行积分来计算 $G_c$。\n\n单位与最终输出：\n- 返回 $\\delta_0$（单位为纳米）和 $G_c$（单位为焦耳/平方米）。\n- 如有角度，以弧度表示（本问题未使用）。\n- 您的程序的最终输出必须是单行，包含一个逗号分隔的 Python 风格列表，其中包含所有案例结果的扁平化形式，顺序为案例 $1$、案例 $2$、案例 $3$。每个案例贡献其拟合的 $\\delta_0$（纳米）和其 $G_c$（焦耳/平方米）。例如，输出格式为 $[\\delta_{0,1},G_{c,1},\\delta_{0,2},G_{c,2},\\delta_{0,3},G_{c,3}]$。每个项目必须是浮点数。为了可读性，您可以四舍五入到合理的小数位数，但这些值必须与拟合参数和单位转换保持一致。",
            "solution": "该问题被认为是有效的，因为它科学地基于断裂力学中的内聚区模型原理，问题定义明确（适定），并且为获得唯一解提供了所有必要的数据和约束。\n\n求解过程分三个阶段：首先，对给定的牵引力-分离定律（TSL）进行解析处理；其次，推导断裂能 $G_c$；第三，设计数值算法以拟合参数并计算所需量。\n\n1.  **牵引力-分离定律（TSL）的解析处理**\n\n假设的指数型 TSL 由以下函数给出：\n$$T(\\delta) = \\sigma_{\\max} \\left(\\frac{\\delta}{\\delta_0}\\right) \\exp\\left(1 - \\frac{\\delta}{\\delta_0}\\right)$$\n其中 $T(\\delta)$ 是在给定分离量 $\\delta$ 时的牵引力，$\\sigma_{\\max}$ 是峰值牵引力（内聚强度），$\\delta_0$ 是分离的特征长度尺度。问题指出 $\\delta_0$ 是牵引力达到最大值时的分离量。这可以通过求 $T(\\delta)$ 相对于 $\\delta$ 的极值来验证。我们计算导数 $\\frac{\\mathrm{d}T}{\\mathrm{d}\\delta}$ 并将其设为零：\n$$ \\frac{\\mathrm{d}T}{\\mathrm{d}\\delta} = \\frac{\\mathrm{d}}{\\mathrm{d}\\delta} \\left[ \\sigma_{\\max} \\frac{\\delta}{\\delta_0} e^{1} e^{-\\delta/\\delta_0} \\right] $$\n使用微分的乘法法则 $(uv)' = u'v + uv'$，其中 $u = \\delta$ 且 $v = e^{-\\delta/\\delta_0}$：\n$$ \\frac{\\mathrm{d}T}{\\mathrm{d}\\delta} = \\frac{\\sigma_{\\max} e}{\\delta_0} \\left[ (1) \\cdot e^{-\\delta/\\delta_0} + \\delta \\cdot \\left(-\\frac{1}{\\delta_0}\\right) e^{-\\delta/\\delta_0} \\right] $$\n$$ \\frac{\\mathrm{d}T}{\\mathrm{d}\\delta} = \\frac{\\sigma_{\\max} e}{\\delta_0} e^{-\\delta/\\delta_0} \\left( 1 - \\frac{\\delta}{\\delta_0} \\right) $$\n将导数设为零以找到临界点，需要 $1 - \\frac{\\delta}{\\delta_0} = 0$，因为对于有限正值的 $\\delta_0$ 和 $\\sigma_{\\max}$，其他项不为零。这得到：\n$$ \\delta = \\delta_0 $$\n将 $\\delta = \\delta_0$ 代回原始 TSL 方程，验证了在此分离量下的牵引力确实是 $\\sigma_{\\max}$：\n$$ T(\\delta_0) = \\sigma_{\\max} \\left(\\frac{\\delta_0}{\\delta_0}\\right) \\exp\\left(1 - \\frac{\\delta_0}{\\delta_0}\\right) = \\sigma_{\\max}(1)\\exp(0) = \\sigma_{\\max} $$\n这证实了问题中定义的参数 $\\sigma_{\\max}$ 和 $\\delta_0$ 的物理解释。\n\n2.  **断裂能 $G_c$ 的推导**\n\n分离功，或称断裂能 $G_c$，定义为分离界面所需的单位面积总能量，即牵引力-分离曲线下从零到无穷大分离量的面积。数学上表示为：\n$$ G_c = \\int_0^{\\infty} T(\\delta) \\, \\mathrm{d}\\delta $$\n代入 $T(\\delta)$ 的表达式：\n$$ G_c = \\int_0^{\\infty} \\sigma_{\\max} \\left(\\frac{\\delta}{\\delta_0}\\right) \\exp\\left(1 - \\frac{\\delta}{\\delta_0}\\right) \\, \\mathrm{d}\\delta $$\n我们可以通过提出常数来简化这个积分：\n$$ G_c = \\frac{\\sigma_{\\max} e}{\\delta_0} \\int_0^{\\infty} \\delta \\exp\\left(-\\frac{\\delta}{\\delta_0}\\right) \\, \\mathrm{d}\\delta $$\n我们用无量纲变量 $u = \\delta / \\delta_0$ 进行换元。这意味着 $\\delta = u \\delta_0$ 且 $\\mathrm{d}\\delta = \\delta_0 \\, \\mathrm{d}u$。积分的上下限保持不变，从 $u=0$ 到 $u=\\infty$。\n$$ G_c = \\frac{\\sigma_{\\max} e}{\\delta_0} \\int_0^{\\infty} (u \\delta_0) \\exp(-u) \\, (\\delta_0 \\, \\mathrm{d}u) $$\n$$ G_c = \\sigma_{\\max} e \\delta_0 \\int_0^{\\infty} u \\exp(-u) \\, \\mathrm{d}u $$\n积分 $\\int_0^{\\infty} u \\exp(-u) \\, \\mathrm{d}u$ 是一个与伽马函数 $\\Gamma(z) = \\int_0^{\\infty} t^{z-1} e^{-t} \\, \\mathrm{d}t$ 相关的标准形式。在我们的例子中，$z-1=1$，所以 $z=2$。因此，该积分的值为 $\\Gamma(2) = 1! = 1$。或者，使用分部积分法：\n$$ \\int u e^{-u} \\, \\mathrm{d}u = u(-e^{-u}) - \\int (-e^{-u}) \\, \\mathrm{d}u = -u e^{-u} - e^{-u} $$\n$$ \\int_0^{\\infty} u e^{-u} \\, \\mathrm{d}u = \\left[ -e^{-u}(u+1) \\right]_0^{\\infty} = \\lim_{u\\to\\infty}(-e^{-u}(u+1)) - (-e^0(0+1)) = 0 - (-1) = 1 $$\n因此，断裂能由一个非常简洁的表达式给出：\n$$ G_c = e \\sigma_{\\max} \\delta_0 $$\n其中 $e$ 是欧拉数，约等于 $2.71828$。\n\n单位一致性至关重要。问题规定 $\\sigma_{\\max}$ 将以吉帕斯卡（$ \\text{GPa} $）为单位进行拟合，$\\delta_0$ 以纳米（$ \\text{nm} $）为单位，并要求 $G_c$ 的单位为焦耳/平方米（$ \\text{J/m}^2 $）。我们来检查一下单位：\n$$ 1 \\, \\text{J/m}^2 = 1 \\, \\text{N/m} = 1 \\, \\text{Pa} \\cdot \\text{m} $$\n将拟合参数转换为国际单位制基本单位：\n$$ \\sigma_{\\max} [\\text{Pa}] = \\sigma_{\\max, \\text{fit}}[\\text{GPa}] \\times 10^9 $$\n$$ \\delta_0 [\\text{m}] = \\delta_{0, \\text{fit}}[\\text{nm}] \\times 10^{-9} $$\n得到的 $G_c$ 是：\n$$ G_c [\\text{J/m}^2] = e \\cdot (\\sigma_{\\max, \\text{fit}}[\\text{GPa}] \\times 10^9) \\cdot (\\delta_{0, \\text{fit}}[\\text{nm}] \\times 10^{-9}) $$\n$$ G_c [\\text{J/m}^2] = e \\cdot \\sigma_{\\max, \\text{fit}}[\\text{GPa}] \\cdot \\delta_{0, \\text{fit}}[\\text{nm}] $$\n方便的是，转换因子 $10^9$ 和 $10^{-9}$ 相互抵消了。因此，我们可以直接将 $\\sigma_{\\max}$ 的拟合值（单位 GPa）与 $\\delta_0$ 的拟合值（单位 nm）以及 $e$ 相乘，从而得到 $G_c$（单位 J/m²）。\n\n3.  **数值实现设计**\n\n每个测试案例的算法流程如下：\na. **数据生成**：首先，我们必须为每个测试案例合成“测量的”牵引力-分离数据 $\\{(\\delta_i, T_i)\\}$。分离点 $\\delta_i$ 是给定的。牵引力值 $T_i$ 使用提供的公式计算，该公式结合了真实的 TSL 和一个确定性扰动：\n$$ T_i = \\sigma_{\\max, \\text{true}}\\left(\\frac{\\delta_i}{\\delta_{0, \\text{true}}}\\right)e^{1-\\frac{\\delta_i}{\\delta_{0, \\text{true}}}} + \\alpha\\,\\sigma_{\\max, \\text{true}}\\left(\\frac{\\delta_i}{\\delta_{0, \\text{true}}}\\right)e^{-\\frac{\\delta_i}{\\delta_{0, \\text{true}}}}\\sin\\left(\\beta\\,\\frac{\\delta_i}{\\delta_{0, \\text_true}}}\\right) $$\n\nb. **初始猜测值估计**：按要求，为优化程序构建初始猜测值。我们找到测量牵引力数据的最大值 $T_{\\max} = \\max_i T_i$。内聚强度的初始猜测值为 $\\sigma_{\\max}^{(0)} = T_{\\max}$。特征分离量的初始猜测值 $\\delta_0^{(0)}$ 是该最大牵引力出现时的分离值 $\\delta_k$，即 $T_k = T_{\\max}$ 处。\n\nc. **带约束的非线性最小二乘拟合**：任务的核心是找到使残差平方和 $S$ 最小化的参数 $(\\sigma_{\\max}, \\delta_0)$：\n$$ S(\\sigma_{\\max}, \\delta_0) = \\sum_i \\left(T_i - T(\\delta_i; \\sigma_{\\max}, \\delta_0)\\right)^2 $$\n这是一个非线性最小二乘问题。我们将使用 `scipy.optimize` 库中的 `curve_fit` 函数，该函数专为此目的设计。调用该函数时，将传入 TSL 模型函数、数据 $(\\delta_i, T_i)$、初始猜测值 $(\\sigma_{\\max}^{(0)}, \\delta_0^{(0)})$ 以及约束条件 $\\sigma_{\\max}  0$ 和 $\\delta_0  0$。这些约束通过 `bounds` 参数施加，将下界设置为 $[0, 0]$，上界设置为 $[\\infty, \\infty]$。\n\nd. **最终计算与输出**：一旦优化程序收敛并返回最佳拟合参数 $(\\sigma_{\\max, \\text{fit}}, \\delta_{0, \\text{fit}})$，我们使用第 2 步推导出的解析公式计算断裂能 $G_{c, \\text{fit}} = e \\cdot \\sigma_{\\max, \\text{fit}} \\cdot \\delta_{0, \\text{fit}}$。每个案例的最终输出将是值对 $(\\delta_{0, \\text{fit}}, G_{c, \\text{fit}})$，并按规定格式化。\n\n此过程将内聚区模型的基本理论与标准的数值优化技术相结合，以解决所述问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Fits an exponential TSL to synthetic data and calculates fracture energy.\n    \"\"\"\n    # Euler's number, np.e is an alias for np.exp(1)\n    E_CONST = np.e\n\n    # Define the Traction-Separation Law (TSL) model function\n    def tsl_model(delta, sigma_max, delta_0):\n        \"\"\"\n        Exponential Traction-Separation Law.\n        T(delta) = sigma_max * (delta/delta_0) * exp(1 - delta/delta_0)\n        \"\"\"\n        # Use np.errstate to prevent warnings for delta=0 or delta_0 near zero during iteration\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ratio = delta / delta_0\n            traction = sigma_max * ratio * np.exp(1.0 - ratio)\n        # For delta=0, ratio is 0, so traction is 0.\n        # np.nan_to_num handles any NaNs that might arise if delta_0 is zero.\n        return np.nan_to_num(traction)\n\n    # Define the function to generate synthetic data for each test case\n    def generate_data(true_sigma_max, true_delta_0, delta_points, alpha, beta):\n        \"\"\"\n        Generates synthetic traction-separation data with a deterministic perturbation.\n        \"\"\"\n        # Calculate the true traction based on the TSL model\n        t_true = tsl_model(delta_points, true_sigma_max, true_delta_0)\n        \n        # Calculate the deterministic perturbation\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ratio = delta_points / true_delta_0\n            delta_T = alpha * true_sigma_max * ratio * np.exp(-ratio) * np.sin(beta * ratio)\n        delta_T = np.nan_to_num(delta_T)\n\n        # Measured traction is the sum of true traction and perturbation\n        t_measured = t_true + delta_T\n        \n        # Ensure traction at zero separation is exactly zero\n        if delta_points.size  0 and delta_points[0] == 0.0:\n            t_measured[0] = 0.0\n            \n        return delta_points, t_measured\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            # Case 1: General case\n            'true_params': {'sigma_max': 4.0, 'delta_0': 0.20},\n            'sampling': {'points': np.arange(0, 25) * 0.05},\n            'perturbation': {'alpha': 0.05, 'beta': 3.0}\n        },\n        {\n            # Case 2: Sharp cohesive response\n            'true_params': {'sigma_max': 9.0, 'delta_0': 0.05},\n            'sampling': {'points': np.arange(0, 51) * 0.01},\n            'perturbation': {'alpha': 0.03, 'beta': 4.0}\n        },\n        {\n            # Case 3: Broad cohesive response\n            'true_params': {'sigma_max': 1.8, 'delta_0': 0.60},\n            'sampling': {'points': np.arange(0, 31) * 0.10},\n            'perturbation': {'alpha': 0.04, 'beta': 2.5}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Generate the synthetic dataset for the current case\n        delta_data, traction_data = generate_data(\n            case['true_params']['sigma_max'],\n            case['true_params']['delta_0'],\n            case['sampling']['points'],\n            case['perturbation']['alpha'],\n            case['perturbation']['beta']\n        )\n\n        # Step 2: Estimate an initial guess for the parameters\n        if len(traction_data)  0 and np.max(traction_data)  0:\n            sigma_max_guess = np.max(traction_data)\n            delta_0_guess_index = np.argmax(traction_data)\n            delta_0_guess = delta_data[delta_0_guess_index]\n            # Ensure the initial guess for delta_0 is not zero\n            if delta_0_guess == 0.0:\n                delta_0_guess = 1e-6 # A small positive number\n        else:\n            # Fallback in case of empty or all-zero data\n            sigma_max_guess = 1.0\n            delta_0_guess = 0.1\n        \n        p0 = [sigma_max_guess, delta_0_guess]\n\n        # Step 3: Fit the TSL model to the data via constrained nonlinear least squares\n        # Constraints: sigma_max  0 and delta_0  0\n        bounds = ([0, 0], [np.inf, np.inf])\n        \n        try:\n            p_opt, _ = curve_fit(tsl_model, delta_data, traction_data, p0=p0, bounds=bounds)\n            sigma_max_fit, delta_0_fit = p_opt\n        except RuntimeError:\n            # This should not happen with the provided data, but is good practice\n            sigma_max_fit, delta_0_fit = np.nan, np.nan\n\n        # Step 4: Compute the work of separation (fracture energy) Gc\n        # Gc [J/m^2] = e * sigma_max [GPa] * delta_0 [nm]\n        gc_fit = E_CONST * sigma_max_fit * delta_0_fit\n\n        # Append the fitted delta_0 (in nm) and computed Gc (in J/m^2) to the results list\n        results.append(delta_0_fit)\n        results.append(gc_fit)\n\n    # Final print statement in the exact required format\n    # Using a fixed number of decimal places for consistent output\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确定了材料的内聚参数后，下一步是在数值模拟中有效地使用它们。一个关键的挑战是确保有限元网格足够精细，以准确捕捉裂尖的内聚过程区（cohesive process zone）。本练习将引导您从第一性原理出发，推导出一个关键的材料特征长度——内聚过程区长度 $r_p$——它如何依赖于弹性模量 $E$、断裂能 $G_c$ 和内聚强度 $\\sigma_{\\max}$ 。通过分析不同网格尺寸下的离散化误差，您将深刻理解为何充分解析 $r_p$ 对获得收敛和物理上可靠的模拟结果至关重要。",
            "id": "3439118",
            "problem": "考虑一个均质线弹性固体中的I型断裂，其裂纹尖端前方由一个内聚区模拟。假设采用三角形牵引力-分离位移本构律，其特征为峰值内聚牵引力 $\\sigma_{\\max}$ 和临界断裂能（也称为临界能量释放率）$G_c$。设体材料的杨氏模量为 $E$，并通过采用等于 $E$ 的有效模量（平面应力替代）来忽略泊松效应。内聚本构由牵引力-分离位移关系 $T(\\delta)$ 指定，该关系弹性增加至 $\\sigma_{\\max}$，然后线性软化至零，使得下降分支下的面积等于 $G_c$。您可以假设界面的上升弹性分支足够陡峭，以至于其弹性储能在能量平衡中与软化分支相比可以忽略不计。过程区长度 $r_p$ 定义为裂纹尖端前方内聚牵引力处于活动状态（严格大于零且小于 $\\sigma_{\\max}$）的区域长度。\n\n任务 1 (推导)：从基本原理和经过充分检验的事实出发，推导过程区长度作为 $E$、$\\sigma_{\\max}$ 和 $G_c$ 函数的标度关系。使用以下基础作为您的出发点：\n- 断裂中的能量平衡：每单位新产生裂纹面积的内聚牵引力所做的功等于临界断裂能 $G_c$。\n- 对于峰值为 $\\sigma_{\\max}$ 且最终分离位移为 $\\delta_f$ 的三角形牵引力-分离位移本构律，软化区面积满足 $\\int_0^{\\delta_f} T(\\delta)\\,d\\delta = \\tfrac{1}{2}\\sigma_{\\max}\\,\\delta_f = G_c$。\n- 一维裂纹带理想化中的协调性：当非弹性应变在整个区域内近似均匀时，长度为 $r_p$ 的过程区上的裂纹张开位移 $\\delta$ 与非弹性应变增量通过 $\\delta \\approx r_p\\,\\Delta\\varepsilon$ 相关联。\n- 体材料中的线弹性：$\\sigma = E\\,\\varepsilon$。\n\n基于以上条件，推导显式表达式 $r_p = C\\,E\\,G_c/\\sigma_{\\max}^2$，并在一个明确陈述且具有物理合理性的稳定性或协调性条件下，确定从峰值载荷到裂纹带完全脱聚过渡过程的无量纲常数 $C$。您的推导必须在这些基础之上进行，并避免引入任何未经证实的本构假设。\n\n任务 2 (通过界面离散化进行网格依赖性测试)：考虑使用尺寸均匀为 $h$ 的线性界面单元来表示沿界面的内聚过程区。在离散模型中，表示的过程区长度 $r_p^{\\text{disc}}$ 被约束为 $h$ 的整数倍。对于任务 1 中给定的解析解 $r_p$，通过向上取整到 $h$ 的最近倍数来定义离散表示：\n$$\nr_p^{\\text{disc}} = \\lceil r_p/h \\rceil\\,h,\n$$\n这对应于覆盖连续过程区所需的最少连续界面单元数量。将相对表示误差定义为\n$$\ne(h) = \\frac{\\left|r_p^{\\text{disc}} - r_p\\right|}{r_p}.\n$$\n对于下面的每个参数集，计算 $r_p$，然后对由 $h = q\\,r_p$（其中 $q \\in \\{0.93,\\,0.37,\\,0.18,\\,0.07\\}$）指定的四个系统加密的网格计算 $e(h)$。\n\n单位和数值格式：\n- 对 $E$ 和 $\\sigma_{\\max}$ 使用 $\\text{Pa}$，对 $G_c$ 使用 $\\text{J}/\\text{m}^2$。\n- 将 $r_p$ 以米为单位表示。\n- 对于每种情况，报告保留六位有效数字的 $r_p$ 和保留六位小数的每个误差 $e(h)$。\n\n测试套件（待评估的三种情况）：\n1. $E = 70\\times 10^9$, $\\sigma_{\\max} = 50\\times 10^6$, $G_c = 800$.\n2. $E = 210\\times 10^9$, $\\sigma_{\\max} = 1.2\\times 10^9$, $G_c = 60$.\n3. $E = 3\\times 10^9$, $\\sigma_{\\max} = 5\\times 10^6$, $G_c = 200$.\n\n最终程序输出格式：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表形式的结果。对于每个测试用例，输出一个包含五个条目的列表：标量 $r_p$（单位为米，六位有效数字），后跟按顺序排列的四个误差 $e(h)$（无量纲小数，六位小数），分别对应 $q \\in \\{0.93,\\,0.37,\\,0.18,\\,0.07\\}$。\n- 例如，输出应如下所示：\n[[rp_case1,e1_case1,e2_case1,e3_case1,e4_case1],[rp_case2,e1_case2,e2_case2,e3_case2,e4_case2],[rp_case3,e1_case3,e2_case3,e3_case3,e4_case3]]\n不含任何额外文本。\n\n程序必须是一个完整、可运行的实现，直接根据指定参数计算这些量，并以上述确切格式打印结果。不允许用户输入，所有使用的常量必须在程序中定义。",
            "solution": "用户提供了一个计算断裂力学领域的问题，具体涉及内聚区模型。我的任务是首先验证问题陈述，如果有效，则提供一个完整的解决方案，包括理论推导和用于数值评估的 Python 程序。\n\n### 步骤 1：问题验证\n\n根据指定标准对问题进行审查。\n\n-   **给定条件提取**：\n    -   模型：I 型断裂，均质线弹性固体。\n    -   内聚本构：三角形牵引力-分离位移本构律，峰值牵引力为 $\\sigma_{\\max}$，临界断裂能为 $G_c$。上升弹性分支的能量贡献可忽略不计。\n    -   材料属性：杨氏模量 $E$。泊松比被忽略。\n    -   过程区长度 $r_p$：内聚牵引力活动区域的长度。\n    -   任务 1 目标：推导 $r_p = C\\,E\\,G_c/\\sigma_{\\max}^2$ 并求出常数 $C$。\n    -   推导基础：\n        1.  能量平衡：单位面积的内聚功等于 $G_c$。\n        2.  三角形定律能量：$\\int_0^{\\delta_f} T(\\delta)\\,d\\delta = \\tfrac{1}{2}\\sigma_{\\max}\\,\\delta_f = G_c$。\n        3.  裂纹带运动学：对于均匀非弹性应变 $\\Delta\\varepsilon$，$\\delta \\approx r_p\\,\\Delta\\varepsilon$。\n        4.  线弹性：$\\sigma = E\\,\\varepsilon$。\n    -   任务 2 目标：对于单元尺寸 $h = q\\,r_p$（其中 $q \\in \\{0.93,\\,0.37,\\,0.18,\\,0.07\\}$）的网格，计算相对表示误差 $e(h) = \\frac{\\left|r_p^{\\text{disc}} - r_p\\right|}{r_p}$。\n    -   离散过程区：$r_p^{\\text{disc}} = \\lceil r_p/h \\rceil\\,h$。\n    -   测试用例：提供了三组 $(E, \\sigma_{\\max}, G_c)$。\n    -   格式化：给出了关于单位、有效数字和小数位的具体规则。\n\n-   **验证结论**：\n    1.  **科学合理性**：该问题具有科学依据。内聚区模型是断裂力学中的标准工具。三角形本构律是一种常见的理想化方法。标度律 $r_p \\propto EG_c/\\sigma_{\\max}^2$ 是一个众所周知的结果，从第一性原理推导它是一项有效的学术练习。对目标表达式的量纲分析证实了其一致性：$[E G_c / \\sigma_{\\max}^2] = (\\text{N}/\\text{m}^2) \\cdot (\\text{J}/\\text{m}^2) / (\\text{N}/\\text{m}^2)^2 = (\\text{N}/\\text{m}^2) \\cdot (\\text{N} \\cdot \\text{m}/\\text{m}^2) / (\\text{N}/\\text{m}^2)^2 = (\\text{N}/\\text{m}^2) \\cdot (\\text{N}/\\text{m}) / (\\text{N}^2/\\text{m}^4) = (\\text{N}^2/\\text{m}^3) / (\\text{N}^2/\\text{m}^4) = \\text{m}$，这是一个长度单位。\n    2.  **适定性**：该问题是适定的。推导任务受到给定基础的约束，数值任务是基于显式公式的直接计算。推导要求陈述一个“物理上合理的稳定性或协调性条件”，这是构建此类模型的标准部分，并不会使问题欠定。\n    3.  **客观性**：问题以精确、客观的语言陈述。\n    4.  **完整性**：所提供的数据和基础足以得出一个唯一的解。测试套件中的参数值对于各种工程材料都是物理上合理的。\n\n-   **结论**：问题被判定为**有效**。我将继续进行解答。\n\n### 任务 1：过程区长度标度律的推导\n\n目标是推导形式为 $r_p = C\\,E\\,G_c/\\sigma_{\\max}^2$ 的过程区长度 $r_p$ 的表达式，并确定常数 $C$。推导必须建立在所提供的基础之上。\n\n1.  **内聚本构分析**：问题指定了一个三角形牵引力-分离位移本构律 $T(\\delta)$，其中牵引力从峰值 $\\sigma_{\\max}$ 线性软化到零，经历的临界分离距离为 $\\delta_f$。每单位断裂面积耗散的能量 $G_c$ 由这个软化三角形的面积给出。这在基础 2 中明确说明：\n    $$ G_c = \\frac{1}{2} \\sigma_{\\max} \\delta_f $$\n    由此关系，我们可以用材料的内聚属性表达临界分离位移 $\\delta_f$：\n    $$ \\delta_f = \\frac{2 G_c}{\\sigma_{\\max}} $$\n\n2.  **峰值应力下的材料行为**：根据基础 4（线弹性, $\\sigma = E\\varepsilon$），与过程区相邻的体弹性材料在内聚失效过程开始前可以承受的最大应力为 $\\sigma_{\\max}$。与此峰值应力对应的弹性应变为：\n    $$ \\varepsilon_{peak} = \\frac{\\sigma_{\\max}}{E} $$\n\n3.  **物理上合理的协调性条件**：问题要求一个协调性条件来连接体弹性行为与内聚区的变形。我们假设以下条件：在过程区内产生完全脱聚所需的特征非弹性应变 $\\Delta\\varepsilon_f$ 与材料所能承受的峰值弹性应变 $\\varepsilon_{peak}$ 在同一数量级。对于这个简化模型，我们令它们相等：\n    $$ \\Delta\\varepsilon_f = \\varepsilon_{peak} = \\frac{\\sigma_{\\max}}{E} $$\n    这个条件在物理上将弹性体的应变能力与内聚带内失效所需的应变联系起来。\n\n4.  **裂纹带运动学**：基础 3 提供了一个一维“裂纹带”关系，将裂纹张开位移 $\\delta$ 和过程区长度 $r_p$ 上的非弹性应变 $\\Delta\\varepsilon$ 联系起来。假设非弹性应变是均匀的，这给出 $\\delta = r_p \\cdot \\Delta\\varepsilon$。我们在完全断裂点应用此关系，此时分离位移为 $\\delta_f$，累积的非弹性应变为 $\\Delta\\varepsilon_f$：\n    $$ \\delta_f = r_p \\cdot \\Delta\\varepsilon_f $$\n\n5.  **综合与最终表达式**：现在我们组合上面推导出的表达式来求解 $r_p$。将 $\\delta_f$（来自步骤 1）和 $\\Delta\\varepsilon_f$（来自步骤 3）的表达式代入运动学关系（来自步骤 4）：\n    $$ \\frac{2 G_c}{\\sigma_{\\max}} = r_p \\cdot \\left( \\frac{\\sigma_{\\max}}{E} \\right) $$\n    求解 $r_p$ 得到最终表达式：\n    $$ r_p = \\frac{2 E G_c}{\\sigma_{\\max}^2} $$\n    这个结果与所需形式 $r_p = C\\,E\\,G_c/\\sigma_{\\max}^2$ 相符，其中无量纲常数确定为 $C = 2$。\n\n### 任务 2：离散化误差的数值评估\n\n第二个任务是为三个给定的测试用例计算 $r_p$，然后为四种不同的网格尺寸 $h$ 评估相对表示误差 $e(h)$。\n\n过程区长度使用推导出的公式计算：$r_p = 2 E G_c / \\sigma_{\\max}^2$。\n\n相对表示误差 $e(h)$ 定义为 $e(h) = |r_p^{\\text{disc}} - r_p| / r_p$，其中 $r_p^{\\text{disc}} = \\lceil r_p/h \\rceil h$。单元尺寸 $h$ 被给定为过程区长度的一部分，即 $h = q \\cdot r_p$。\n\n我们可以简化误差表达式：\n$$ e(h) = \\frac{|\\lceil r_p/(q \\cdot r_p) \\rceil (q \\cdot r_p) - r_p|}{r_p} = \\frac{|\\lceil 1/q \\rceil \\cdot q \\cdot r_p - r_p|}{r_p} = |\\lceil 1/q \\rceil \\cdot q - 1| $$\n这表明误差 $e(h)$ 仅依赖于相对网格尺寸参数 $q$，并且对于所有三个测试用例都是相同的。\n\n-   对于 $q = 0.93$: $e = |\\lceil 1/0.93 \\rceil \\cdot 0.93 - 1| = |2 \\cdot 0.93 - 1| = |1.86 - 1| = 0.86$\n-   对于 $q = 0.37$: $e = |\\lceil 1/0.37 \\rceil \\cdot 0.37 - 1| = |3 \\cdot 0.37 - 1| = |1.11 - 1| = 0.11$\n-   对于 $q = 0.18$: $e = |\\lceil 1/0.18 \\rceil \\cdot 0.18 - 1| = |6 \\cdot 0.18 - 1| = |1.08 - 1| = 0.08$\n-   对于 $q = 0.07$: $e = |\\lceil 1/0.07 \\rceil \\cdot 0.07 - 1| = |15 \\cdot 0.07 - 1| = |1.05 - 1| = 0.05$\n\n每个案例的 $r_p$ 计算如下：\n\n-   **案例 1**：$E = 70 \\times 10^9$ Pa, $\\sigma_{\\max} = 50 \\times 10^6$ Pa, $G_c = 800$ J/m$^2$\n    $r_p = 2 \\cdot (70 \\times 10^9) \\cdot 800 / (50 \\times 10^6)^2 = 0.0448$ m\n\n-   **案例 2**：$E = 210 \\times 10^9$ Pa, $\\sigma_{\\max} = 1.2 \\times 10^9$ Pa, $G_c = 60$ J/m$^2$\n    $r_p = 2 \\cdot (210 \\times 10^9) \\cdot 60 / (1.2 \\times 10^9)^2 = 1.75 \\times 10^{-5}$ m\n\n-   **案例 3**：$E = 3 \\times 10^9$ Pa, $\\sigma_{\\max} = 5 \\times 10^6$ Pa, $G_c = 200$ J/m$^2$\n    $r_p = 2 \\cdot (3 \\times 10^9) \\cdot 200 / (5 \\times 10^6)^2 = 0.048$ m\n\n在最终程序中，这些值将按照 $r_p$ 保留六位有效数字、误差保留六位小数的格式进行格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code that solves the problem.\n# This program computes the cohesive process zone length and discretization\n# errors for three different material parameter sets.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cohesive zone modeling problem by deriving the process zone length,\n    calculating it for given test cases, and evaluating the mesh representation error.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (Young's Modulus E in Pa, peak traction sigma_max in Pa, fracture energy G_c in J/m^2)\n    test_cases = [\n        (70e9, 50e6, 800),\n        (210e9, 1.2e9, 60),\n        (3e9, 5e6, 200),\n    ]\n\n    # Define the relative mesh size parameters\n    q_values = [0.93, 0.37, 0.18, 0.07]\n\n    # Calculate the representation errors. The error only depends on q.\n    # The calculation is based on e(h) = |ceil(1/q) * q - 1|\n    errors = [abs(np.ceil(1/q) * q - 1) for q in q_values]\n\n    # This list will store the result lists for each case.\n    all_results = []\n\n    for case in test_cases:\n        E, sigma_max, G_c = case\n\n        # Task 1: Calculate the analytical process zone length, r_p\n        # From the derivation, r_p = 2 * E * G_c / sigma_max^2\n        r_p = 2 * E * G_c / (sigma_max**2)\n\n        # Build the list of results for the current case.\n        # The first element is r_p, followed by the four error values.\n        current_results = [r_p] + errors\n        all_results.append(current_results)\n    \n    # Format the results for the final output string according to the problem specification.\n    # The final output must be a single line string representing a list of lists.\n    # Example format: [[rp_case1,e1,e2,e3,e4],[rp_case2,e1,e2,e3,e4],...]\n    \n    output_parts = []\n    for case_result in all_results:\n        # Extract the process zone length and the error values\n        rp_val = case_result[0]\n        error_vals = case_result[1:]\n\n        # Format r_p to six significant figures using scientific notation (e.g., \"x.xxxxx-e-yy\")\n        rp_str = f\"{rp_val:.5e}\"\n        \n        # Format each error to six decimal places (e.g., \"0.xxxxxx\")\n        err_strs = [f\"{e:.6f}\" for e in error_vals]\n        \n        # Combine the formatted strings for the current case into a list representation.\n        case_str = f\"[{rp_str},{','.join(err_strs)}]\"\n        output_parts.append(case_str)\n\n    # Combine all case strings into the final output format.\n    final_output_string = f\"[{','.join(output_parts)}]\"\n\n    # Print the final formatted string.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "将内聚区模型的物理概念转化为可执行的计算代码，是计算材料科学家的一项核心技能。本练习将带您深入有限元方法（Finite Element Method, FEM）的核心，实践如何为一个四节点内聚界面单元计算其内力向量 。通过应用形函数、高斯积分和虚功原理，您将学习如何根据节点位移和给定的双线性TSL，计算出界面上的内聚牵引力，并将其分配为等效的节点力。这个过程是任何基于CZM的有限元模拟的基础，它将连续的牵引力-分离行为与离散的结构力学求解器联系起来。",
            "id": "3439060",
            "problem": "给定一个二维界面单元，其包含四个节点，节点 $1$ 和 $2$ 位于底面，节点 $3$ 和 $4$ 位于顶面。每个节点在全局坐标系中有两个位移分量。该单元用于通过内聚区方法模拟断裂，其中使用非耦合的双线性牵引-分离本构。在每个积分点（高斯点），局部界面坐标系由一个单位切向向量和一个单位法向向量定义。请利用虚功原理和标准的等参插值方法，从第一性原理推导如何根据位移跳跃计算高斯点处的法向和切向牵引力，并组装作用于节点自由度上的单元内力向量。\n\n假设与建模背景：\n- 内聚响应在法向和切向方向上是非耦合的。\n- 在法向方向，只有拉伸分离会产生内聚牵引力；压缩分离不产生内聚牵引力。\n- 切向响应相对于方向是对称的，遵循切向分离的符号。\n- 牵引-分离本构是双线性的：一个初始的线弹性段，直至由初始刚度和阈值分离定义的峰值，随后是线性软化段，直至在临界分离处牵引力降为零。\n- 平面外维度的厚度通过一个显式的厚度参数进行单位缩放。\n\n推导中使用的基本原理：\n- 界面的虚功原理，该原理使用形函数将牵引力向量分配到节点自由度上。\n- 沿界面的双节点线段的线性形函数，独立应用于顶面和底面。\n- 沿界面单元自然坐标的标准两点高斯积分。\n- 高斯点处局部切向和法向向量的正交性和归一化。\n\n编程任务：\n实现一个完整的程序，对以下每个测试用例执行以下步骤：\n1. 使用沿界面坐标 $s \\in [-1,1]$ 的线性形函数，在每个高斯点插值计算底面和顶面的位移。\n2. 计算每个高斯点处的位移跳跃，即插值得到的顶面和底面位移之差。\n3. 将位移跳跃投影到该高斯点的局部坐标系上，以获得法向和切向分离。\n4. 使用给定的参数（初始刚度、达到峰值牵引力的阈值分离、牵引力减为零时的临界分离）和非耦合的双线性牵引-分离本构，计算每个高斯点处的法向和切向牵引力。在法向方向，当分离为非正值时，将牵引力设置为零。\n5. 通过将局部法向和切向牵引力与局部坐标系向量相结合，构建每个高斯点处的全局牵引力向量。\n6. 通过将高斯点牵引力贡献分配给四个节点来组装单元内力向量，并赋予适当的符号：底面节点为负，顶面节点为正，并由形函数、高斯权重、映射的雅可比行列式和厚度进行加权。\n7. 以 $[f_{x1}, f_{y1}, f_{x2}, f_{y2}, f_{x3}, f_{y3}, f_{x4}, f_{y4}]$ 的顺序生成一个扁平化列表形式的最终单元力向量。\n\n使用以下数值积分方案：\n- 两个高斯点，其横坐标为 $s_1 = -1/\\sqrt{3}$ 和 $s_2 = +1/\\sqrt{3}$，权重为 $w_1 = w_2 = 1$。\n- 线性形函数 $N_1(s) = (1 - s)/2$ 和 $N_2(s) = (1 + s)/2$。\n- 沿界面的线性映射的雅可比行列式为 $J = L/2$，其中 $L$ 是单元的物理长度。\n\n单位：\n- 位移单位为米。\n- 初始刚度单位为帕斯卡/米。\n- 分离量单位为米。\n- 牵引力单位为帕斯卡。\n- 力必须以牛顿表示。在数值积分中，使用平面外厚度参数 $b$（单位为米）和界面长度 $L$（单位为米），通过等于 $b \\times L$ 的面积将牵引力缩放为力。\n\n测试套件：\n对于所有测试用例，均使用上述积分方案。最终输出必须是以牛顿表示的单元力向量，除了自然的浮点数表示外，指令不强加任何舍入。程序必须硬编码以下四个测试用例：\n\n- 测试用例 1 (弹性范围内的中等拉伸和剪切)：\n  - $u_1 = [0.0, 0.0]$, $u_2 = [0.0, 0.0]$, $u_3 = [1.0\\times 10^{-6}, 2.0\\times 10^{-6}]$, $u_4 = [1.5\\times 10^{-6}, 2.5\\times 10^{-6}]$。\n  - 两个高斯点处的局部坐标系：切向向量 $t^{(1)} = [1.0, 0.0]$，$t^{(2)} = [1.0, 0.0]$；法向向量 $n^{(1)} = [0.0, 1.0]$，$n^{(2)} = [0.0, 1.0]$。\n  - 参数：$K_n = 1.0\\times 10^{9}$，$K_t = 5.0\\times 10^{8}$，$\\delta_{0n} = 2.0\\times 10^{-5}$，$\\delta_{fn} = 6.0\\times 10^{-5}$，$\\delta_{0t} = 2.5\\times 10^{-5}$，$\\delta_{ft} = 7.0\\times 10^{-5}$。\n  - 几何形状：$L = 1.0\\times 10^{-1}$，$b = 1.0\\times 10^{-2}$。\n\n- 测试用例 2 (法向压缩和小剪切)：\n  - $u_1 = [0.0, 0.0]$, $u_2 = [0.0, 0.0]$, $u_3 = [1.0\\times 10^{-6}, -3.0\\times 10^{-5}]$, $u_4 = [2.0\\times 10^{-6}, -4.0\\times 10^{-5}]$。\n  - 两个高斯点处的局部坐标系：$t^{(1)} = [1.0, 0.0]$，$t^{(2)} = [1.0, 0.0]$；$n^{(1)} = [0.0, 1.0]$，$n^{(2)} = [0.0, 1.0]$。\n  - 参数：$K_n = 1.0\\times 10^{9}$，$K_t = 5.0\\times 10^{8}$，$\\delta_{0n} = 2.0\\times 10^{-5}$，$\\delta_{fn} = 6.0\\times 10^{-5}$，$\\delta_{0t} = 2.5\\times 10^{-5}$，$\\delta_{ft} = 7.0\\times 10^{-5}$。\n  - 几何形状：$L = 1.0\\times 10^{-1}$，$b = 1.0\\times 10^{-2}$。\n\n- 测试用例 3 (切向软化和小法向张开)：\n  - $u_1 = [0.0, 0.0]$, $u_2 = [0.0, 0.0]$, $u_3 = [3.0\\times 10^{-5}, 1.0\\times 10^{-6}]$, $u_4 = [4.0\\times 10^{-5}, 1.0\\times 10^{-6}]$。\n  - 两个高斯点处的局部坐标系：$t^{(1)} = [1.0, 0.0]$，$t^{(2)} = [1.0, 0.0]$；$n^{(1)} = [0.0, 1.0]$，$n^{(2)} = [0.0, 1.0]$。\n  - 参数：$K_n = 1.0\\times 10^{9}$，$K_t = 5.0\\times 10^{8}$，$\\delta_{0n} = 2.0\\times 10^{-5}$，$\\delta_{fn} = 6.0\\times 10^{-5}$，$\\delta_{0t} = 2.5\\times 10^{-5}$，$\\delta_{ft} = 7.0\\times 10^{-5}$。\n  - 几何形状：$L = 1.0\\times 10^{-1}$，$b = 1.0\\times 10^{-2}$。\n\n- 测试用例 4 (旋转坐标系，法向超出破坏范围，切向处于软化阶段)：\n  - 局部坐标系旋转角度 $\\theta = \\pi/6$ 弧度，因此 $t = [\\cos(\\theta), \\sin(\\theta)]$ 且 $n = [-\\sin(\\theta), \\cos(\\theta)]$；在两个高斯点处使用相同的 $t$ 和 $n$。\n  - 数值上，$t = [0.8660254037844386, 0.5]$ 且 $n = [-0.5, 0.8660254037844386]$。\n  - 顶部节点位移经过调整，以产生较大的法向张开和中等剪切：$u_3 = 8.0\\times 10^{-5}\\,n + 3.0\\times 10^{-5}\\,t = [-1.4019237962155611\\times 10^{-5}, 8.428203230275509\\times 10^{-5}]$，$u_4 = 9.0\\times 10^{-5}\\,n + 3.5\\times 10^{-5}\\,t = [-1.4689111140456177\\times 10^{-5}, 9.544228654700208\\times 10^{-5}]$，且 $u_1 = [0.0, 0.0]$，$u_2 = [0.0, 0.0]$。\n  - 参数：$K_n = 1.0\\times 10^{9}$，$K_t = 5.0\\times 10^{8}$，$\\delta_{0n} = 2.0\\times 10^{-5}$，$\\delta_{fn} = 6.0\\times 10^{-5}$，$\\delta_{0t} = 2.5\\times 10^{-5}$，$\\delta_{ft} = 7.0\\times 10^{-5}$。\n  - 几何形状：$L = 1.0\\times 10^{-1}$，$b = 1.0\\times 10^{-2}$。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果是按所述方式扁平化的单元内力向量，以牛顿表示。最终输出格式必须严格为 $[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$ 的形式，其中每个内部列表包含八个浮点数，无任何附加文本。",
            "solution": "该问题是有效的，因为它定义明确，在计算固体力学中有科学依据，并提供了一套完整且一致的数据和定义。任务是基于虚功原理和双线性牵引-分离本构，推导并实现一个四节点内聚界面单元的内力向量计算。\n\n### 1. 理论公式\n\n**1.1. 单元运动学和插值**\n四节点内聚单元模拟了两个表面之间的分离。节点 $1$ 和 $2$ 位于底面，节点 $3$ 和 $4$ 位于顶面。几何形状由自然坐标 $s \\in [-1, 1]$ 参数化。我们将 $s = -1$ 与节点 $1$ 和 $3$ 关联，将 $s = 1$ 与节点 $2$ 和 $4$ 关联。\n\n底面上任意点的位移向量 $\\mathbf{u}^b(s)$ 和顶面上的位移向量 $\\mathbf{u}^t(s)$ 是使用线性形函数 $N_1(s)$ 和 $N_2(s)$ 从节点位移插值得到的：\n$$ N_1(s) = \\frac{1-s}{2}, \\quad N_2(s) = \\frac{1+s}{2} $$\n插值位移为：\n$$ \\mathbf{u}^b(s) = N_1(s)\\mathbf{u}_1 + N_2(s)\\mathbf{u}_2 $$\n$$ \\mathbf{u}^t(s) = N_1(s)\\mathbf{u}_3 + N_2(s)\\mathbf{u}_4 $$\n其中 $\\mathbf{u}_i = [u_{ix}, u_{iy}]^T$ 是节点 $i$ 的位移向量。\n\n界面上的位移跳跃（或分离向量）$\\boldsymbol{\\delta}(s)$ 是顶面和底面位移之差：\n$$ \\boldsymbol{\\delta}(s) = \\mathbf{u}^t(s) - \\mathbf{u}^b(s) = N_1(s)(\\mathbf{u}_3 - \\mathbf{u}_1) + N_2(s)(\\mathbf{u}_4 - \\mathbf{u}_2) $$\n\n**1.2. 局部分离**\n在每个积分点（高斯点）$s_i$ 处，由一个切向向量 $\\mathbf{t}$ 和一个法向向量 $\\mathbf{n}$ 组成的正交基定义了一个局部坐标系。位移跳跃向量 $\\boldsymbol{\\delta}(s_i)$（在全局坐标系中）被投影到这个局部基上，以获得法向分离 $\\delta_n$ 和切向分离 $\\delta_t$：\n$$ \\delta_n(s_i) = \\boldsymbol{\\delta}(s_i) \\cdot \\mathbf{n}(s_i) = \\mathbf{n}(s_i)^T \\boldsymbol{\\delta}(s_i) $$\n$$ \\delta_t(s_i) = \\boldsymbol{\\delta}(s_i) \\cdot \\mathbf{t}(s_i) = \\mathbf{t}(s_i)^T \\boldsymbol{\\delta}(s_i) $$\n\n**1.3. 非耦合双线性牵引-分离本构 (TSL)**\n内聚牵引力是根据局部分离计算的。法向和切向响应是非耦合的。\n\n*   **法向牵引力 ($T_n$)**：仅在正（拉伸）分离时产生牵引力。\n    $$ T_n(\\delta_n) = \\begin{cases}\n    0   \\text{if } \\delta_n \\le 0 \\\\\n    K_n \\delta_n   \\text{if } 0  \\delta_n \\le \\delta_{0n} \\\\\n    K_n \\delta_{0n} \\left( \\frac{\\delta_{fn} - \\delta_n}{\\delta_{fn} - \\delta_{0n}} \\right)   \\text{if } \\delta_{0n}  \\delta_n  \\delta_{fn} \\\\\n    0   \\text{if } \\delta_n \\ge \\delta_{fn}\n    \\end{cases} $$\n    其中 $K_n$ 是初始法向刚度，$\\delta_{0n}$ 是峰值牵引力时的分离量，$\\delta_{fn}$ 是破坏时的临界分离量。\n\n*   **切向牵引力 ($T_t$)**：该本构相对于剪切方向是对称的。\n    $$ T_t(\\delta_t) = \\begin{cases}\n    K_t \\delta_t   \\text{if } |\\delta_t| \\le \\delta_{0t} \\\\\n    K_t \\delta_{0t} \\left( \\frac{\\delta_{ft} - |\\delta_t|}{\\delta_{ft} - \\delta_{0t}} \\right) \\text{sign}(\\delta_t)   \\text{if } \\delta_{0t}  |\\delta_t|  \\delta_{ft} \\\\\n    0   \\text{if } |\\delta_t| \\ge \\delta_{ft}\n    \\end{cases} $$\n    其中 $K_t$ 是初始切向刚度，$\\delta_{0t}$ 是峰值牵引力时的分离量，$\\delta_{ft}$ 是破坏时的临界分离量。项 $\\text{sign}(\\delta_t) = \\delta_t/|\\delta_t|$ (当 $\\delta_t \\neq 0$ 时) 且为 $0$ (当 $\\delta_t = 0$ 时)。\n\n**1.4. 单元内力向量的组装**\n虚功原理将牵引力与节点力联系起来。由内聚牵引力 $\\mathbf{T}$ 在虚拟位移跳跃 $\\delta\\boldsymbol{\\delta}$ 上所做的内虚功 $\\delta W_{int}$ 为：\n$$ \\delta W_{int} = \\int_A \\mathbf{T}^T \\delta\\boldsymbol{\\delta} \\,dA $$\n积分区域为内聚面面积 $A$。全局坐标系中的牵引力向量 $\\mathbf{T}$ 从其局部分量 $T_n$ 和 $T_t$ 恢复得到：\n$$ \\mathbf{T}(s) = T_n(s) \\mathbf{n}(s) + T_t(s) \\mathbf{t}(s) $$\n虚拟位移跳跃通过形函数与虚拟节点位移 $\\delta\\mathbf{u}^e$ 相关联。单元内力向量 $\\mathbf{f}_{int}$ 的最终表达式为：\n$$ \\mathbf{f}_{int} = \\int_{L} \\mathbf{B}(s)^T \\mathbf{T}(s) b \\,dx $$\n其中 $b$ 是平面外厚度，$L$ 是单元长度，$\\mathbf{B}(s)$ 是将节点位移与跳跃关联起来的应变-位移矩阵。对于此单元，力向量分量为：\n$$ \\mathbf{f}_{1,2} = -\\int_L \\begin{pmatrix} N_1(s) \\\\ N_2(s) \\end{pmatrix} \\mathbf{T}(s) b \\,dx, \\quad \\mathbf{f}_{3,4} = \\int_L \\begin{pmatrix} N_1(s) \\\\ N_2(s) \\end{pmatrix} \\mathbf{T}(s) b \\,dx $$\n这对应于将节点力收集为：\n$$ \\mathbf{f}_1 = -\\int, \\quad \\mathbf{f}_2 = -\\int, \\quad \\mathbf{f}_3 = +\\int, \\quad \\mathbf{f}_4 = +\\int $$\n该积分使用高斯求积法进行数值计算。对于线性单元，微分长度 $dx$ 通过 $dx = J\\,ds$ 与自然坐标相关联，其中雅可比行列式 $J=L/2$。使用两点方案（$s_i = \\pm 1/\\sqrt{3}$，$w_i=1$）：\n$$ \\mathbf{f}_{int} = \\sum_{i=1}^{2} w_i \\begin{bmatrix}\n-N_1(s_i)\\mathbf{T}(s_i) \\\\ -N_2(s_i)\\mathbf{T}(s_i) \\\\ N_1(s_i)\\mathbf{T}(s_i) \\\\ N_2(s_i)\\mathbf{T}(s_i)\n\\end{bmatrix} b J $$\n得到的 $8 \\times 1$ 向量随后被扁平化为 $[f_{x1}, f_{y1}, f_{x2}, f_{y2}, f_{x3}, f_{y3}, f_{x4}, f_{y4}]$。\n\n### 2. 实现算法\n每个测试用例的实现步骤如下：\n1.  为单元内力 $\\mathbf{f}_{int}$ 初始化一个 $8 \\times 1$ 的零向量。\n2.  定义用于两点求积的高斯点 $s_i$ 和权重 $w_i$。\n3.  计算雅可比行列式 $J = L/2$。\n4.  遍历每个高斯点 $s_i$：\n    a. 计算形函数 $N_1(s_i)$ 和 $N_2(s_i)$。\n    b. 插值位移 $\\mathbf{u}^b(s_i)$ 和 $\\mathbf{u}^t(s_i)$，以找到全局位移跳跃向量 $\\boldsymbol{\\delta}(s_i)$。\n    c. 将 $\\boldsymbol{\\delta}(s_i)$ 投影到局部坐标系向量 $(\\mathbf{t}_i, \\mathbf{n}_i)$ 上，以找到标量分离量 $\\delta_n$ 和 $\\delta_t$。\n    d. 应用双线性牵引-分离本构计算牵引力 $T_n$ 和 $T_t$。\n    e. 重构全局牵引力向量 $\\mathbf{T}(s_i) = T_n \\mathbf{n}_i + T_t \\mathbf{t}_i$。\n    f. 使用第1.4节中的公式计算此高斯点的力贡献，并将其加到 $\\mathbf{f}_{int}$ 中，权重为 $w_i$、$b$ 和 $J$。\n5. 循环结束后，向量 $\\mathbf{f}_{int}$ 包含所有八个自由度的总内力。此向量被转换为列表以供输出。",
            "answer": "```python\nimport numpy as np\n\ndef compute_tractions(delta_n, delta_t, params):\n    \"\"\"\n    Computes normal and tangential tractions based on a bilinear traction-separation law.\n\n    Args:\n        delta_n (float): Normal separation.\n        delta_t (float): Tangential separation.\n        params (dict): Dictionary of cohesive material parameters.\n\n    Returns:\n        tuple: A tuple containing the normal traction (Tn) and tangential traction (Tt).\n    \"\"\"\n    Kn, Kt = params['Kn'], params['Kt']\n    d0n, dfn = params['delta_0n'], params['delta_fn']\n    d0t, dft = params['delta_0t'], params['delta_ft']\n\n    # Normal traction (Tn) calculation\n    Tn = 0.0\n    if delta_n > 0:\n        if delta_n = d0n:\n            Tn = Kn * delta_n\n        elif delta_n  dfn:\n            Tn_max = Kn * d0n\n            Tn = Tn_max * (dfn - delta_n) / (dfn - d0n)\n    # For delta_n = 0 (compression) or delta_n >= dfn (failure), Tn is 0.\n\n    # Tangential traction (Tt) calculation\n    Tt = 0.0\n    abs_delta_t = abs(delta_t)\n    if abs_delta_t > 1e-15: # Avoid division by zero, floating point safe check for non-zero\n        if abs_delta_t = d0t:\n            Tt = Kt * delta_t\n        elif abs_delta_t  dft:\n            Tt_max = Kt * d0t\n            Tt = Tt_max * (dft - abs_delta_t) / (dft - d0t) * np.sign(delta_t)\n    # For abs_delta_t = 0 or abs_delta_t >= dft (failure), Tt is 0.\n\n    return Tn, Tt\n\ndef compute_internal_force(case):\n    \"\"\"\n    Computes the element internal force vector for a 4-node cohesive element.\n\n    Args:\n        case (dict): A dictionary containing all data for a single test case.\n\n    Returns:\n        list: The flattened 8-component element internal force vector.\n    \"\"\"\n    u1 = np.array(case['u1'], dtype=float)\n    u2 = np.array(case['u2'], dtype=float)\n    u3 = np.array(case['u3'], dtype=float)\n    u4 = np.array(case['u4'], dtype=float)\n    local_frames = case['local_frames']\n    params = case['params']\n    L, b = case['geometry']['L'], case['geometry']['b']\n\n    # Gauss quadrature: 2-point scheme for a line element\n    gauss_points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    gauss_weights = [1.0, 1.0]\n\n    # Jacobian of the mapping from natural to physical coordinates\n    J = L / 2.0\n\n    # Initialize the element internal force vector [fx1, fy1, fx2, fy2, ...]\n    f_int = np.zeros(8)\n\n    for i, s in enumerate(gauss_points):\n        w = gauss_weights[i]\n\n        # Linear shape functions N1(s) and N2(s)\n        N1 = 0.5 * (1.0 - s)\n        N2 = 0.5 * (1.0 + s)\n\n        # Interpolate displacements on bottom and top surfaces\n        u_bottom = N1 * u1 + N2 * u2\n        u_top = N1 * u3 + N2 * u4\n\n        # Compute displacement jump vector in global coordinates\n        delta_global = u_top - u_bottom\n\n        # Get local frame vectors at the current Gauss point\n        t_vec = np.array(local_frames[i]['t'], dtype=float)\n        n_vec = np.array(local_frames[i]['n'], dtype=float)\n\n        # Project jump to get local normal and tangential separations\n        delta_n = np.dot(delta_global, n_vec)\n        delta_t = np.dot(delta_global, t_vec)\n\n        # Compute tractions using the bilinear constitutive law\n        Tn, Tt = compute_tractions(delta_n, delta_t, params)\n\n        # Form the global traction vector\n        T_global = Tn * n_vec + Tt * t_vec\n\n        # Assemble contribution to the internal force vector\n        factor = w * b * J\n\n        # Force contribution to node 1 (bottom, s=-1 side)\n        f_int[0:2] -= N1 * T_global * factor\n        # Force contribution to node 2 (bottom, s=+1 side)\n        f_int[2:4] -= N2 * T_global * factor\n        # Force contribution to node 3 (top, s=-1 side)\n        f_int[4:6] += N1 * T_global * factor\n        # Force contribution to node 4 (top, s=+1 side)\n        f_int[6:8] += N2 * T_global * factor\n\n    return f_int.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            'u1': [0.0, 0.0], 'u2': [0.0, 0.0],\n            'u3': [1.0e-6, 2.0e-6], 'u4': [1.5e-6, 2.5e-6],\n            'local_frames': [{'t': [1.0, 0.0], 'n': [0.0, 1.0]}, {'t': [1.0, 0.0], 'n': [0.0, 1.0]}],\n            'params': {'Kn': 1.0e9, 'Kt': 5.0e8, 'delta_0n': 2.0e-5, 'delta_fn': 6.0e-5, 'delta_0t': 2.5e-5, 'delta_ft': 7.0e-5},\n            'geometry': {'L': 1.0e-1, 'b': 1.0e-2}\n        },\n        # Test case 2\n        {\n            'u1': [0.0, 0.0], 'u2': [0.0, 0.0],\n            'u3': [1.0e-6, -3.0e-5], 'u4': [2.0e-6, -4.0e-5],\n            'local_frames': [{'t': [1.0, 0.0], 'n': [0.0, 1.0]}, {'t': [1.0, 0.0], 'n': [0.0, 1.0]}],\n            'params': {'Kn': 1.0e9, 'Kt': 5.0e8, 'delta_0n': 2.0e-5, 'delta_fn': 6.0e-5, 'delta_0t': 2.5e-5, 'delta_ft': 7.0e-5},\n            'geometry': {'L': 1.0e-1, 'b': 1.0e-2}\n        },\n        # Test case 3\n        {\n            'u1': [0.0, 0.0], 'u2': [0.0, 0.0],\n            'u3': [3.0e-5, 1.0e-6], 'u4': [4.0e-5, 1.0e-6],\n            'local_frames': [{'t': [1.0, 0.0], 'n': [0.0, 1.0]}, {'t': [1.0, 0.0], 'n': [0.0, 1.0]}],\n            'params': {'Kn': 1.0e9, 'Kt': 5.0e8, 'delta_0n': 2.0e-5, 'delta_fn': 6.0e-5, 'delta_0t': 2.5e-5, 'delta_ft': 7.0e-5},\n            'geometry': {'L': 1.0e-1, 'b': 1.0e-2}\n        },\n        # Test case 4\n        {\n            'u1': [0.0, 0.0], 'u2': [0.0, 0.0],\n            'u3': [-1.4019237962155611e-5, 8.428203230275509e-5],\n            'u4': [-1.4689111140456177e-5, 9.544228654700208e-5],\n            'local_frames': [\n                {'t': [0.8660254037844386, 0.5], 'n': [-0.5, 0.8660254037844386]},\n                {'t': [0.8660254037844386, 0.5], 'n': [-0.5, 0.8660254037844386]}\n            ],\n            'params': {'Kn': 1.0e9, 'Kt': 5.0e8, 'delta_0n': 2.0e-5, 'delta_fn': 6.0e-5, 'delta_0t': 2.5e-5, 'delta_ft': 7.0e-5},\n            'geometry': {'L': 1.0e-1, 'b': 1.0e-2}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        f_int_vector = compute_internal_force(case)\n        results.append(f_int_vector)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}