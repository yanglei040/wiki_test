{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of predictive cohesive zone modeling is the establishment of an accurate Traction-Separation Law (TSL) that reflects the material's failure behavior. This practice provides a direct, hands-on experience in bridging atomistic-scale physics with continuum-level models. By fitting a defined TSL function to synthetically generated force-displacement data, you will learn the essential techniques of parameter extraction and model calibration, a critical skill for developing robust fracture simulations . The exercise also reinforces the physical meaning of the fracture energy $G_c$ as the work of separation.",
            "id": "3439023",
            "problem": "You are given atomistically computed traction–separation data for an interface that is hypothesized to follow an exponential Traction–Separation Law (TSL). The TSL has the form $T(\\delta)=\\sigma_{\\max}(\\delta/\\delta_0)\\exp(1-\\delta/\\delta_0)$, where $T(\\delta)$ is the traction at separation $\\delta$, $\\sigma_{\\max}$ is the peak traction, and $\\delta_0$ is the separation at which the traction attains its maximum. Starting from the fundamental definition that the work of separation (fracture energy) $G_c$ is the area under the traction–separation curve, your task is to determine $G_c$ and $\\delta_0$ that best fit the provided data by minimizing the sum of squared residuals between the measured traction and the TSL prediction.\n\nUse the following base principles:\n- The work of separation (fracture energy) is defined as $G_c=\\int_0^{\\infty}T(\\delta)\\,\\mathrm{d}\\delta$.\n- The best-fit parameters minimize the objective $\\sum_i\\left(T_i - T(\\delta_i;\\sigma_{\\max},\\delta_0)\\right)^2$, where $T_i$ are measured tractions and $\\delta_i$ are measured separations.\n\nFor numerical consistency, separations must be expressed in nanometers and tractions in gigapascals. Compute $G_c$ in joules per square meter. In the computation of $G_c$ from the fitted parameters, ensure unit consistency by converting $\\sigma_{\\max}$ from gigapascals to pascals and $\\delta_0$ from nanometers to meters.\n\nYou must implement a program that, for each test case, performs the following steps:\n1. Fit the parameters $\\sigma_{\\max}$ and $\\delta_0$ to the provided traction–separation dataset via constrained nonlinear least squares with constraints $\\sigma_{\\max}>0$ and $\\delta_0>0$.\n2. Using the fitted parameters, compute $G_c$ by integrating $T(\\delta)$ over $\\delta$ from zero to infinity.\n3. Output the fitted $\\delta_0$ in nanometers and the computed $G_c$ in joules per square meter.\n\nTest suite:\nYou must use the synthetic datasets defined below. In each case, the measured data $\\{(\\delta_i, T_i)\\}$ are generated deterministically from the model with a known underlying parameter set and a deterministic non-random perturbation that mimics atomistic noise. For each case, the separation points $\\delta_i$ are as specified, the true traction is $T_{\\text{true}}(\\delta_i)=\\sigma_{\\max}(\\delta_i/\\delta_0)\\exp(1-\\delta_i/\\delta_0)$ with the given true $\\sigma_{\\max}$ and true $\\delta_0$, and the measured traction is $T_i=T_{\\text{true}}(\\delta_i)+\\Delta T(\\delta_i)$ with deterministic perturbation\n$$\\Delta T(\\delta)=\\alpha\\,\\sigma_{\\max}\\left(\\frac{\\delta}{\\delta_0}\\right)\\exp\\!\\left(-\\frac{\\delta}{\\delta_0}\\right)\\sin\\!\\left(\\beta\\,\\frac{\\delta}{\\delta_0}\\right),$$\nwhere $\\alpha$ and $\\beta$ are case-specific constants. All tractions are in gigapascals and separations in nanometers.\n\n- Case $1$ (general case):\n  - True parameters: $\\sigma_{\\max}=4.0$ gigapascals, $\\delta_0=0.20$ nanometers.\n  - Sampling: $\\delta_i=i\\times 0.05$ nanometers for $i=0,1,2,\\dots,24$ (i.e., range $0$ to $1.20$ nanometers).\n  - Perturbation constants: $\\alpha=0.05$, $\\beta=3.0$.\n\n- Case $2$ (sharp cohesive response, small $\\delta_0$):\n  - True parameters: $\\sigma_{\\max}=9.0$ gigapascals, $\\delta_0=0.05$ nanometers.\n  - Sampling: $\\delta_i=i\\times 0.01$ nanometers for $i=0,1,2,\\dots,50$ (i.e., range $0$ to $0.50$ nanometers).\n  - Perturbation constants: $\\alpha=0.03$, $\\beta=4.0$.\n\n- Case $3$ (broad cohesive response, large $\\delta_0$):\n  - True parameters: $\\sigma_{\\max}=1.8$ gigapascals, $\\delta_0=0.60$ nanometers.\n  - Sampling: $\\delta_i=i\\times 0.10$ nanometers for $i=0,1,2,\\dots,30$ (i.e., range $0$ to $3.00$ nanometers).\n  - Perturbation constants: $\\alpha=0.04$, $\\beta=2.5$.\n\nAlgorithmic requirements:\n- Use constrained nonlinear least squares with bounds $\\sigma_{\\max}>0$ and $\\delta_0>0$ to fit the model parameters for each dataset.\n- Estimate an initial guess by using $\\sigma_{\\max}^{(0)}=\\max_i T_i$ and $\\delta_0^{(0)}=\\delta_{k}$ at the index $k$ where $T_k=\\max_i T_i$.\n- Use the fitted parameters to compute $G_c$ via integration of $T(\\delta)$ over $\\delta\\in[0,\\infty)$.\n\nUnits and final outputs:\n- Return $\\delta_0$ in nanometers and $G_c$ in joules per square meter.\n- Express angles, if any, in radians (none are used in this problem).\n- The final output of your program must be a single line containing a comma-separated Python-style list with all case results flattened, in the order Case $1$, Case $2$, Case $3$, with each case contributing its fitted $\\delta_0$ (nanometers) followed by its $G_c$ (joules per square meter). For example, the output format is $[\\delta_{0,1},G_{c,1},\\delta_{0,2},G_{c,2},\\delta_{0,3},G_{c,3}]$. Each item must be a float. You may round to a reasonable number of decimal places for readability, but the values must be consistent with the fitted parameters and unit conversions.",
            "solution": "The problem is deemed valid as it is scientifically grounded in the principles of cohesive zone modeling from fracture mechanics, is well-posed, and all necessary data and constraints for a unique solution are provided.\n\nThe solution proceeds in three stages: first, an analytical treatment of the provided Traction-Separation Law (TSL); second, the derivation of the fracture energy, $G_c$; and third, the design of the numerical algorithm to fit the parameters and compute the required quantities.\n\n1.  **Analytical Treatment of the Traction-Separation Law (TSL)**\n\nThe hypothesized exponential TSL is given by the function:\n$$T(\\delta) = \\sigma_{\\max} \\left(\\frac{\\delta}{\\delta_0}\\right) \\exp\\left(1 - \\frac{\\delta}{\\delta_0}\\right)$$\nwhere $T(\\delta)$ is the traction at a given separation $\\delta$, $\\sigma_{\\max}$ is the peak traction (cohesive strength), and $\\delta_0$ is a characteristic length scale of the separation. The problem states that $\\delta_0$ is the separation at which the traction is maximum. This can be verified by finding the extremum of $T(\\delta)$ with respect to $\\delta$. We compute the derivative $\\frac{\\mathrm{d}T}{\\mathrm{d}\\delta}$ and set it to zero:\n$$ \\frac{\\mathrm{d}T}{\\mathrm{d}\\delta} = \\frac{\\mathrm{d}}{\\mathrm{d}\\delta} \\left[ \\sigma_{\\max} \\frac{\\delta}{\\delta_0} e^{1} e^{-\\delta/\\delta_0} \\right] $$\nUsing the product rule for differentiation, $(uv)' = u'v + uv'$, with $u = \\delta$ and $v = e^{-\\delta/\\delta_0}$:\n$$ \\frac{\\mathrm{d}T}{\\mathrm{d}\\delta} = \\frac{\\sigma_{\\max} e}{\\delta_0} \\left[ (1) \\cdot e^{-\\delta/\\delta_0} + \\delta \\cdot \\left(-\\frac{1}{\\delta_0}\\right) e^{-\\delta/\\delta_0} \\right] $$\n$$ \\frac{\\mathrm{d}T}{\\mathrm{d}\\delta} = \\frac{\\sigma_{\\max} e}{\\delta_0} e^{-\\delta/\\delta_0} \\left( 1 - \\frac{\\delta}{\\delta_0} \\right) $$\nSetting the derivative to zero to find the critical points requires $1 - \\frac{\\delta}{\\delta_0} = 0$, since the other terms are non-zero for finite, positive $\\delta_0$ and $\\sigma_{\\max}$. This yields:\n$$ \\delta = \\delta_0 $$\nSubstituting $\\delta = \\delta_0$ back into the original TSL equation verifies that the traction at this separation is indeed $\\sigma_{\\max}$:\n$$ T(\\delta_0) = \\sigma_{\\max} \\left(\\frac{\\delta_0}{\\delta_0}\\right) \\exp\\left(1 - \\frac{\\delta_0}{\\delta_0}\\right) = \\sigma_{\\max}(1)\\exp(0) = \\sigma_{\\max} $$\nThis confirms the physical interpretation of the parameters $\\sigma_{\\max}$ and $\\delta_0$ as defined in the problem.\n\n2.  **Derivation of the Fracture Energy, $G_c$**\n\nThe work of separation, or fracture energy $G_c$, is defined as the total energy per unit area required to separate the interface, which is the area under the traction-separation curve from zero to infinite separation. Mathematically, this is:\n$$ G_c = \\int_0^{\\infty} T(\\delta) \\, \\mathrm{d}\\delta $$\nSubstituting the expression for $T(\\delta)$:\n$$ G_c = \\int_0^{\\infty} \\sigma_{\\max} \\left(\\frac{\\delta}{\\delta_0}\\right) \\exp\\left(1 - \\frac{\\delta}{\\delta_0}\\right) \\, \\mathrm{d}\\delta $$\nWe can simplify this integral by factoring out constants:\n$$ G_c = \\frac{\\sigma_{\\max} e}{\\delta_0} \\int_0^{\\infty} \\delta \\exp\\left(-\\frac{\\delta}{\\delta_0}\\right) \\, \\mathrm{d}\\delta $$\nLet's perform a substitution with a dimensionless variable $u = \\delta / \\delta_0$. This implies $\\delta = u \\delta_0$ and $\\mathrm{d}\\delta = \\delta_0 \\, \\mathrm{d}u$. The limits of integration remain unchanged, from $u=0$ to $u=\\infty$.\n$$ G_c = \\frac{\\sigma_{\\max} e}{\\delta_0} \\int_0^{\\infty} (u \\delta_0) \\exp(-u) \\, (\\delta_0 \\, \\mathrm{d}u) $$\n$$ G_c = \\sigma_{\\max} e \\delta_0 \\int_0^{\\infty} u \\exp(-u) \\, \\mathrm{d}u $$\nThe integral $\\int_0^{\\infty} u \\exp(-u) \\, \\mathrm{d}u$ is a standard form related to the Gamma function, $\\Gamma(z) = \\int_0^{\\infty} t^{z-1} e^{-t} \\, \\mathrm{d}t$. For our case, $z-1=1$, so $z=2$. Thus, the integral evaluates to $\\Gamma(2) = 1! = 1$. Alternatively, using integration by parts:\n$$ \\int u e^{-u} \\, \\mathrm{d}u = u(-e^{-u}) - \\int (-e^{-u}) \\, \\mathrm{d}u = -u e^{-u} - e^{-u} $$\n$$ \\int_0^{\\infty} u e^{-u} \\, \\mathrm{d}u = \\left[ -e^{-u}(u+1) \\right]_0^{\\infty} = \\lim_{u\\to\\infty}(-e^{-u}(u+1)) - (-e^0(0+1)) = 0 - (-1) = 1 $$\nTherefore, the fracture energy is given by the remarkably simple expression:\n$$ G_c = e \\sigma_{\\max} \\delta_0 $$\nwhere $e$ is Euler's number, approximately $2.71828$.\n\nUnit consistency is critical. The problem specifies that $\\sigma_{\\max}$ will be fitted in gigapascals ($ \\text{GPa} $) and $\\delta_0$ in nanometers ($ \\text{nm} $), and requires $G_c$ in joules per square meter ($ \\text{J/m}^2 $). Let's check the units:\n$$ 1 \\, \\text{J/m}^2 = 1 \\, \\text{N/m} = 1 \\, \\text{Pa} \\cdot \\text{m} $$\nConverting the fitted parameters to SI base units:\n$$ \\sigma_{\\max} [\\text{Pa}] = \\sigma_{\\max, \\text{fit}}[\\text{GPa}] \\times 10^9 $$\n$$ \\delta_0 [\\text{m}] = \\delta_{0, \\text{fit}}[\\text{nm}] \\times 10^{-9} $$\nThe resulting $G_c$ is:\n$$ G_c [\\text{J/m}^2] = e \\cdot (\\sigma_{\\max, \\text{fit}}[\\text{GPa}] \\times 10^9) \\cdot (\\delta_{0, \\text{fit}}[\\text{nm}] \\times 10^{-9}) $$\n$$ G_c [\\text{J/m}^2] = e \\cdot \\sigma_{\\max, \\text{fit}}[\\text{GPa}] \\cdot \\delta_{0, \\text{fit}}[\\text{nm}] $$\nConveniently, the conversion factors $10^9$ and $10^{-9}$ cancel. Thus, we can directly multiply the fitted value of $\\sigma_{\\max}$ in GPa by the fitted value of $\\delta_0$ in nm and by $e$ to obtain $G_c$ in J/m².\n\n3.  **Numerical Implementation Design**\n\nThe algorithmic procedure for each test case is as follows:\na. **Data Generation**: First, we must synthesize the \"measured\" traction-separation data $\\{(\\delta_i, T_i)\\}$ for each test case. The separation points $\\delta_i$ are given. The traction values $T_i$ are computed using the provided formula that combines the true TSL with a deterministic perturbation:\n$$ T_i = \\sigma_{\\max, \\text{true}}\\left(\\frac{\\delta_i}{\\delta_{0, \\text{true}}}\\right)e^{1-\\frac{\\delta_i}{\\delta_{0, \\text{true}}}} + \\alpha\\,\\sigma_{\\max, \\text{true}}\\left(\\frac{\\delta_i}{\\delta_{0, \\text{true}}}\\right)e^{-\\frac{\\delta_i}{\\delta_{0, \\text{true}}}}\\sin\\left(\\beta\\,\\frac{\\delta_i}{\\delta_{0, \\text_true}}}\\right) $$\n\nb. **Initial Guess Estimation**: As required, an initial guess for the optimization routine is formulated. We find the maximum value of the measured traction data, $T_{\\max} = \\max_i T_i$. The initial guess for the cohesive strength is $\\sigma_{\\max}^{(0)} = T_{\\max}$. The initial guess for the characteristic separation, $\\delta_0^{(0)}$, is the separation value $\\delta_k$ at which this maximum traction occurs, i.e., where $T_k = T_{\\max}$.\n\nc. **Constrained Nonlinear Least-Squares Fitting**: The core of the task is to find the parameters $(\\sigma_{\\max}, \\delta_0)$ that minimize the sum of squared residuals, $S$:\n$$ S(\\sigma_{\\max}, \\delta_0) = \\sum_i \\left(T_i - T(\\delta_i; \\sigma_{\\max}, \\delta_0)\\right)^2 $$\nThis is a nonlinear least-squares problem. We will use the `curve_fit` function from the `scipy.optimize` library, which is designed for this purpose. The function will be called with the TSL model function, the data $(\\delta_i, T_i)$, the initial guess $(\\sigma_{\\max}^{(0)}, \\delta_0^{(0)})$, and the constraints $\\sigma_{\\max} > 0$ and $\\delta_0 > 0$. These constraints are imposed via the `bounds` argument, setting the lower bounds to $[0, 0]$ and the upper bounds to $[\\infty, \\infty]$.\n\nd. **Final Calculation and Output**: Once the optimization procedure converges and returns the best-fit parameters $(\\sigma_{\\max, \\text{fit}}, \\delta_{0, \\text{fit}})$, we use the analytical formula derived in step 2 to calculate the fracture energy, $G_{c, \\text{fit}} = e \\cdot \\sigma_{\\max, \\text{fit}} \\cdot \\delta_{0, \\text{fit}}$. The final output for each case will be the pair of values $(\\delta_{0, \\text{fit}}, G_{c, \\text{fit}})$, formatted as specified.\n\nThis procedure integrates the fundamental theory of cohesive zone models with standard numerical optimization techniques to solve the problem as stated.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Fits an exponential TSL to synthetic data and calculates fracture energy.\n    \"\"\"\n    # Euler's number, np.e is an alias for np.exp(1)\n    E_CONST = np.e\n\n    # Define the Traction-Separation Law (TSL) model function\n    def tsl_model(delta, sigma_max, delta_0):\n        \"\"\"\n        Exponential Traction-Separation Law.\n        T(delta) = sigma_max * (delta/delta_0) * exp(1 - delta/delta_0)\n        \"\"\"\n        # Use np.errstate to prevent warnings for delta=0 or delta_0 near zero during iteration\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ratio = delta / delta_0\n            traction = sigma_max * ratio * np.exp(1.0 - ratio)\n        # For delta=0, ratio is 0, so traction is 0.\n        # np.nan_to_num handles any NaNs that might arise if delta_0 is zero.\n        return np.nan_to_num(traction)\n\n    # Define the function to generate synthetic data for each test case\n    def generate_data(true_sigma_max, true_delta_0, delta_points, alpha, beta):\n        \"\"\"\n        Generates synthetic traction-separation data with a deterministic perturbation.\n        \"\"\"\n        # Calculate the true traction based on the TSL model\n        t_true = tsl_model(delta_points, true_sigma_max, true_delta_0)\n        \n        # Calculate the deterministic perturbation\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ratio = delta_points / true_delta_0\n            delta_T = alpha * true_sigma_max * ratio * np.exp(-ratio) * np.sin(beta * ratio)\n        delta_T = np.nan_to_num(delta_T)\n\n        # Measured traction is the sum of true traction and perturbation\n        t_measured = t_true + delta_T\n        \n        # Ensure traction at zero separation is exactly zero\n        if delta_points.size > 0 and delta_points[0] == 0.0:\n            t_measured[0] = 0.0\n            \n        return delta_points, t_measured\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            # Case 1: General case\n            'true_params': {'sigma_max': 4.0, 'delta_0': 0.20},\n            'sampling': {'points': np.arange(0, 25) * 0.05},\n            'perturbation': {'alpha': 0.05, 'beta': 3.0}\n        },\n        {\n            # Case 2: Sharp cohesive response\n            'true_params': {'sigma_max': 9.0, 'delta_0': 0.05},\n            'sampling': {'points': np.arange(0, 51) * 0.01},\n            'perturbation': {'alpha': 0.03, 'beta': 4.0}\n        },\n        {\n            # Case 3: Broad cohesive response\n            'true_params': {'sigma_max': 1.8, 'delta_0': 0.60},\n            'sampling': {'points': np.arange(0, 31) * 0.10},\n            'perturbation': {'alpha': 0.04, 'beta': 2.5}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Generate the synthetic dataset for the current case\n        delta_data, traction_data = generate_data(\n            case['true_params']['sigma_max'],\n            case['true_params']['delta_0'],\n            case['sampling']['points'],\n            case['perturbation']['alpha'],\n            case['perturbation']['beta']\n        )\n\n        # Step 2: Estimate an initial guess for the parameters\n        if len(traction_data) > 0 and np.max(traction_data) > 0:\n            sigma_max_guess = np.max(traction_data)\n            delta_0_guess_index = np.argmax(traction_data)\n            delta_0_guess = delta_data[delta_0_guess_index]\n            # Ensure the initial guess for delta_0 is not zero\n            if delta_0_guess == 0.0:\n                delta_0_guess = 1e-6 # A small positive number\n        else:\n            # Fallback in case of empty or all-zero data\n            sigma_max_guess = 1.0\n            delta_0_guess = 0.1\n        \n        p0 = [sigma_max_guess, delta_0_guess]\n\n        # Step 3: Fit the TSL model to the data via constrained nonlinear least squares\n        # Constraints: sigma_max > 0 and delta_0 > 0\n        bounds = ([0, 0], [np.inf, np.inf])\n        \n        try:\n            p_opt, _ = curve_fit(tsl_model, delta_data, traction_data, p0=p0, bounds=bounds)\n            sigma_max_fit, delta_0_fit = p_opt\n        except RuntimeError:\n            # This should not happen with the provided data, but is good practice\n            sigma_max_fit, delta_0_fit = np.nan, np.nan\n\n        # Step 4: Compute the work of separation (fracture energy) Gc\n        # Gc [J/m^2] = e * sigma_max [GPa] * delta_0 [nm]\n        gc_fit = E_CONST * sigma_max_fit * delta_0_fit\n\n        # Append the fitted delta_0 (in nm) and computed Gc (in J/m^2) to the results list\n        results.append(delta_0_fit)\n        results.append(gc_fit)\n\n    # Final print statement in the exact required format\n    # Using a fixed number of decimal places for consistent output\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once a Traction-Separation Law has been parameterized, the next step is to implement it within a numerical simulation framework, such as the Finite Element Method (FEM). This exercise delves into the fundamental mechanics of a cohesive interface element, guiding you through the process of computing internal nodal forces from nodal displacements . Mastering this procedure is essential for understanding how the abstract constitutive relationship of a TSL is translated into tangible mechanical forces that drive deformation and failure in a discrete model.",
            "id": "3439060",
            "problem": "You are given a two-dimensional interface element with four nodes arranged such that nodes $1$ and $2$ lie on the bottom surface and nodes $3$ and $4$ lie on the top surface. Each node has two displacement components in global coordinates. The element is used to model fracture through a cohesive zone approach with an uncoupled bilinear traction-separation law. The local interface frame at each integration point (Gauss point) is defined by a unit tangential vector and a unit normal vector. Using the principle of virtual work and standard isoparametric interpolation, derive from first principles how to compute the normal and tangential tractions at the Gauss points from the displacement jump, and assemble the element internal force vector on the nodal degrees of freedom.\n\nAssumptions and modeling context:\n- The cohesive response is uncoupled between normal and tangential directions.\n- In the normal direction, only tensile separations generate cohesive tractions; compressive separations generate no cohesive traction.\n- The tangential response can be symmetric with respect to direction, following the sign of tangential separation.\n- The traction-separation law is bilinear: an initial linear elastic segment up to a peak defined by the initial stiffness and a threshold separation, followed by linear softening to zero traction at the critical separation.\n- The out-of-plane thickness is unity-scaled through an explicit thickness parameter.\n\nFundamental bases to use in your derivation:\n- The principle of virtual work for interfaces, which distributes the traction vector across nodal degrees of freedom using shape functions.\n- Linear shape functions for a two-node line segment along the interface, applied independently on the top and bottom surfaces.\n- Standard two-point Gauss integration along the natural coordinate of the interface element.\n- Orthogonality and normalization of the local tangential and normal vectors at Gauss points.\n\nProgramming task:\nImplement a complete program that, for each of the test cases below, performs the following steps:\n1. Interpolate the bottom and top surface displacements at each Gauss point using linear shape functions along the interface coordinate $s \\in [-1,1]$.\n2. Compute the displacement jump at each Gauss point as the difference between the interpolated top and bottom displacements.\n3. Project the displacement jump onto the local frame at that Gauss point to obtain the normal and tangential separations.\n4. Using an uncoupled bilinear traction-separation law with the given parameters (initial stiffness, threshold separation for peak traction, and critical separation at which traction reduces to zero), compute the normal and tangential tractions at each Gauss point. In the normal direction, set traction to zero when the separation is non-positive.\n5. Form the global traction vector at each Gauss point by combining the local normal and tangential tractions with the local frame vectors.\n6. Assemble the element internal force vector by distributing the Gauss point traction contributions to the four nodes with appropriate signs: negative on the bottom nodes and positive on the top nodes, weighted by the shape functions, Gauss weights, Jacobian determinant of the mapping, and thickness.\n7. Produce the final element force vector as a flattened list in the order `[f_{x1}, f_{y1}, f_{x2}, f_{y2}, f_{x3}, f_{y3}, f_{x4}, f_{y4}]`.\n\nUse the following numerical integration scheme:\n- Two Gauss points with abscissas $s_1 = -1/\\sqrt{3}$ and $s_2 = +1/\\sqrt{3}$, and weights $w_1 = w_2 = 1$.\n- Linear shape functions $N_1(s) = (1 - s)/2$ and $N_2(s) = (1 + s)/2$.\n- Jacobian for a linear mapping along the interface is $J = L/2$, where $L$ is the physical length of the element.\n\nUnits:\n- Displacements are given in meters.\n- Initial stiffnesses are given in pascals per meter.\n- Separations are in meters.\n- Tractions are in pascals.\n- Forces must be expressed in newtons. Use the out-of-plane thickness parameter $b$ (in meters) and the interface length $L$ (in meters) to scale tractions to forces via area equal to $b \\times L$ in the numerical integration.\n\nTest suite:\nFor all test cases, the integration scheme described above is used. The final output must be the element force vector expressed in newtons, with no rounding imposed by the instructions other than the natural floating-point representation. The program must hard-code the following four test cases:\n\n- Test case $1$ (moderate tensile and shear in the elastic range):\n  - $u_1 = [0.0, 0.0]$, $u_2 = [0.0, 0.0]$, $u_3 = [1.0\\times 10^{-6}, 2.0\\times 10^{-6}]$, $u_4 = [1.5\\times 10^{-6}, 2.5\\times 10^{-6}]$.\n  - Local frames at both Gauss points: tangential vectors $t^{(1)} = [1.0, 0.0]$, $t^{(2)} = [1.0, 0.0]$; normal vectors $n^{(1)} = [0.0, 1.0]$, $n^{(2)} = [0.0, 1.0]$.\n  - Parameters: $K_n = 1.0\\times 10^{9}$, $K_t = 5.0\\times 10^{8}$, $\\delta_{0n} = 2.0\\times 10^{-5}$, $\\delta_{fn} = 6.0\\times 10^{-5}$, $\\delta_{0t} = 2.5\\times 10^{-5}$, $\\delta_{ft} = 7.0\\times 10^{-5}$.\n  - Geometry: $L = 1.0\\times 10^{-1}$, $b = 1.0\\times 10^{-2}$.\n\n- Test case $2$ (normal compression with small shear):\n  - $u_1 = [0.0, 0.0]$, $u_2 = [0.0, 0.0]$, $u_3 = [1.0\\times 10^{-6}, -3.0\\times 10^{-5}]$, $u_4 = [2.0\\times 10^{-6}, -4.0\\times 10^{-5}]$.\n  - Local frames at both Gauss points: $t^{(1)} = [1.0, 0.0]$, $t^{(2)} = [1.0, 0.0]$; $n^{(1)} = [0.0, 1.0]$, $n^{(2)} = [0.0, 1.0]$.\n  - Parameters: $K_n = 1.0\\times 10^{9}$, $K_t = 5.0\\times 10^{8}$, $\\delta_{0n} = 2.0\\times 10^{-5}$, $\\delta_{fn} = 6.0\\times 10^{-5}$, $\\delta_{0t} = 2.5\\times 10^{-5}$, $\\delta_{ft} = 7.0\\times 10^{-5}$.\n  - Geometry: $L = 1.0\\times 10^{-1}$, $b = 1.0\\times 10^{-2}$.\n\n- Test case $3$ (tangential softening with small normal opening):\n  - $u_1 = [0.0, 0.0]$, $u_2 = [0.0, 0.0]$, $u_3 = [3.0\\times 10^{-5}, 1.0\\times 10^{-6}]$, $u_4 = [4.0\\times 10^{-5}, 1.0\\times 10^{-6}]$.\n  - Local frames at both Gauss points: $t^{(1)} = [1.0, 0.0]$, $t^{(2)} = [1.0, 0.0]$; $n^{(1)} = [0.0, 1.0]$, $n^{(2)} = [0.0, 1.0]$.\n  - Parameters: $K_n = 1.0\\times 10^{9}$, $K_t = 5.0\\times 10^{8}$, $\\delta_{0n} = 2.0\\times 10^{-5}$, $\\delta_{fn} = 6.0\\times 10^{-5}$, $\\delta_{0t} = 2.5\\times 10^{-5}$, $\\delta_{ft} = 7.0\\times 10^{-5}$.\n  - Geometry: $L = 1.0\\times 10^{-1}$, $b = 1.0\\times 10^{-2}$.\n\n- Test case $4$ (rotated frame, normal beyond failure, tangential in softening):\n  - Local frame rotation angle $\\theta = \\pi/6$ in radians, so $t = [\\cos(\\theta), \\sin(\\theta)]$ and $n = [-\\sin(\\theta), \\cos(\\theta)]$; use the same $t$ and $n$ at both Gauss points.\n  - Numerically, $t = [0.8660254037844386, 0.5]$ and $n = [-0.5, 0.8660254037844386]$.\n  - Top nodal displacements are aligned to produce a large normal opening and moderate shear: $\\mathbf{u}_3 = 8.0\\times 10^{-5}\\,\\mathbf{n} + 3.0\\times 10^{-5}\\,\\mathbf{t} = [-1.4019237962155611\\times 10^{-5}, 8.428203230275509\\times 10^{-5}]$, $\\mathbf{u}_4 = 9.0\\times 10^{-5}\\,\\mathbf{n} + 3.5\\times 10^{-5}\\,\\mathbf{t} = [-1.4689111140456177\\times 10^{-5}, 9.544228654700208\\times 10^{-5}]$, and $\\mathbf{u}_1 = [0.0, 0.0]$, $\\mathbf{u}_2 = [0.0, 0.0]$.\n  - Parameters: $K_n = 1.0\\times 10^{9}$, $K_t = 5.0\\times 10^{8}$, $\\delta_{0n} = 2.0\\times 10^{-5}$, $\\delta_{fn} = 6.0\\times 10^{-5}$, $\\delta_{0t} = 2.5\\times 10^{-5}$, $\\delta_{ft} = 7.0\\times 10^{-5}$.\n  - Geometry: $L = 1.0\\times 10^{-1}$, $b = 1.0\\times 10^{-2}$.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result is the element internal force vector flattened as described, expressed in newtons. The final output format must be exactly of the form $[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$ where each inner list contains eight floating-point numbers with no additional text.",
            "solution": "The problem is valid as it is well-posed, scientifically grounded in computational solid mechanics, and provides a complete and consistent set of data and definitions. The task is to derive and implement the calculation of the internal force vector for a four-node cohesive interface element based on the principle of virtual work and a bilinear traction-separation law.\n\n### 1. Theoretical Formulation\n\n**1.1. Element Kinematics and Interpolation**\nThe four-node cohesive element models the separation between two surfaces. Nodes $1$ and $2$ are on the bottom surface, and nodes $3$ and $4$ are on the top surface. The geometry is parameterized by a natural coordinate $s \\in [-1, 1]$. We associate $s = -1$ with nodes $1$ and $3$, and $s = 1$ with nodes $2$ and $4$.\n\nThe displacement vector at any point on the bottom surface, $\\mathbf{u}^b(s)$, and top surface, $\\mathbf{u}^t(s)$, is interpolated from the nodal displacements using linear shape functions $N_1(s)$ and $N_2(s)$:\n$$ N_1(s) = \\frac{1-s}{2}, \\quad N_2(s) = \\frac{1+s}{2} $$\nThe interpolated displacements are:\n$$ \\mathbf{u}^b(s) = N_1(s)\\mathbf{u}_1 + N_2(s)\\mathbf{u}_2 $$\n$$ \\mathbf{u}^t(s) = N_1(s)\\mathbf{u}_3 + N_2(s)\\mathbf{u}_4 $$\nwhere $\\mathbf{u}_i = [u_{ix}, u_{iy}]^T$ is the displacement vector for node $i$.\n\nThe displacement jump (or separation vector) across the interface, $\\boldsymbol{\\delta}(s)$, is the difference between the top and bottom surface displacements:\n$$ \\boldsymbol{\\delta}(s) = \\mathbf{u}^t(s) - \\mathbf{u}^b(s) = N_1(s)(\\mathbf{u}_3 - \\mathbf{u}_1) + N_2(s)(\\mathbf{u}_4 - \\mathbf{u}_2) $$\n\n**1.2. Local Separations**\nAt each integration point (Gauss point) $s_i$, a local coordinate system is defined by an orthonormal basis consisting of a tangential vector $\\mathbf{t}$ and a normal vector $\\mathbf{n}$. The displacement jump vector $\\boldsymbol{\\delta}(s_i)$, which is in the global coordinate system, is projected onto this local basis to obtain the normal separation $\\delta_n$ and tangential separation $\\delta_t$:\n$$ \\delta_n(s_i) = \\boldsymbol{\\delta}(s_i) \\cdot \\mathbf{n}(s_i) = \\mathbf{n}(s_i)^T \\boldsymbol{\\delta}(s_i) $$\n$$ \\delta_t(s_i) = \\boldsymbol{\\delta}(s_i) \\cdot \\mathbf{t}(s_i) = \\mathbf{t}(s_i)^T \\boldsymbol{\\delta}(s_i) $$\n\n**1.3. Uncoupled Bilinear Traction-Separation Law (TSL)**\nThe cohesive tractions are computed based on the local separations. The normal and tangential responses are uncoupled.\n\n*   **Normal Traction ($T_n$)**: Traction is generated only for positive (tensile) separation.\n    $$ T_n(\\delta_n) = \\begin{cases}\n    0 & \\text{if } \\delta_n \\le 0 \\\\\n    K_n \\delta_n & \\text{if } 0 < \\delta_n \\le \\delta_{0n} \\\\\n    K_n \\delta_{0n} \\left( \\frac{\\delta_{fn} - \\delta_n}{\\delta_{fn} - \\delta_{0n}} \\right) & \\text{if } \\delta_{0n} < \\delta_n < \\delta_{fn} \\\\\n    0 & \\text{if } \\delta_n \\ge \\delta_{fn}\n    \\end{cases} $$\n    where $K_n$ is the initial normal stiffness, $\\delta_{0n}$ is the separation at peak traction, and $\\delta_{fn}$ is the critical separation at failure.\n\n*   **Tangential Traction ($T_t$)**: The law is symmetric with respect to the direction of shear.\n    $$ T_t(\\delta_t) = \\begin{cases}\n    K_t \\delta_t & \\text{if } |\\delta_t| \\le \\delta_{0t} \\\\\n    K_t \\delta_{0t} \\left( \\frac{\\delta_{ft} - |\\delta_t|}{\\delta_{ft} - \\delta_{0t}} \\right) \\text{sign}(\\delta_t) & \\text{if } \\delta_{0t} < |\\delta_t| < \\delta_{ft} \\\\\n    0 & \\text{if } |\\delta_t| \\ge \\delta_{ft}\n    \\end{cases} $$\n    where $K_t$ is the initial tangential stiffness, $\\delta_{0t}$ is the separation at peak traction, and $\\delta_{ft}$ is the critical separation at failure. The term $\\text{sign}(\\delta_t) = \\delta_t/|\\delta_t|$ for $\\delta_t \\neq 0$ and is $0$ for $\\delta_t = 0$.\n\n**1.4. Assembly of the Element Internal Force Vector**\nThe principle of virtual work connects the tractions to the nodal forces. The internal virtual work $\\delta W_{int}$ done by the cohesive tractions $\\mathbf{T}$ over a virtual displacement jump $\\delta\\boldsymbol{\\delta}$ is:\n$$ \\delta W_{int} = \\int_A \\mathbf{T}^T \\delta\\boldsymbol{\\delta} \\,dA $$\nThe integral is over the cohesive surface area $A$. The traction vector $\\mathbf{T}$ in the global system is recovered from its local components $T_n$ and $T_t$:\n$$ \\mathbf{T}(s) = T_n(s) \\mathbf{n}(s) + T_t(s) \\mathbf{t}(s) $$\nThe virtual displacement jump is related to the virtual nodal displacements $\\delta\\mathbf{u}^e$ by the shape functions. The resulting expression for the element internal force vector, $\\mathbf{f}_{int}$, is:\n$$ \\mathbf{f}_{int} = \\int_{L} \\mathbf{B}(s)^T \\mathbf{T}(s) b \\,dx $$\nwhere $b$ is the out-of-plane thickness, $L$ is the element length, and $\\mathbf{B}(s)$ is the strain-displacement matrix relating the nodal displacements to the jump. For this element, the force vector components are:\n$$ \\mathbf{f}_{1,2} = -\\int_L \\begin{pmatrix} N_1(s) \\\\ N_2(s) \\end{pmatrix} \\mathbf{T}(s) b \\,dx, \\quad \\mathbf{f}_{3,4} = \\int_L \\begin{pmatrix} N_1(s) \\\\ N_2(s) \\end{pmatrix} \\mathbf{T}(s) b \\,dx $$\nThis corresponds to collecting nodal forces as:\n$$ \\mathbf{f}_1 = -\\int, \\quad \\mathbf{f}_2 = -\\int, \\quad \\mathbf{f}_3 = +\\int, \\quad \\mathbf{f}_4 = +\\int $$\nThe integral is evaluated numerically using Gauss quadrature. For a linear element, the differential length $dx$ is related to the natural coordinate by $dx = J\\,ds$, where the Jacobian $J=L/2$. With a two-point scheme ($s_i = \\pm 1/\\sqrt{3}$, $w_i=1$):\n$$ \\mathbf{f}_{int} = \\sum_{i=1}^{2} w_i \\begin{bmatrix}\n-N_1(s_i)\\mathbf{T}(s_i) \\\\ -N_2(s_i)\\mathbf{T}(s_i) \\\\ N_1(s_i)\\mathbf{T}(s_i) \\\\ N_2(s_i)\\mathbf{T}(s_i)\n\\end{bmatrix} b J $$\nThe resulting $8 \\times 1$ vector is then flattened to $[f_{x1}, f_{y1}, f_{x2}, f_{y2}, f_{x3}, f_{y3}, f_{x4}, f_{y4}]$.\n\n### 2. Implementation Algorithm\nThe implementation proceeds as follows for each test case:\n1.  Initialize an $8 \\times 1$ zero vector for the element internal forces, $\\mathbf{f}_{int}$.\n2.  Define the Gauss points $s_i$ and weights $w_i$ for two-point quadrature.\n3.  Calculate the Jacobian $J = L/2$.\n4.  Loop through each Gauss point $s_i$:\n    a. Evaluate the shape functions $N_1(s_i)$ and $N_2(s_i)$.\n    b. Interpolate displacements $\\mathbf{u}^b(s_i)$ and $\\mathbf{u}^t(s_i)$ to find the global displacement jump vector $\\boldsymbol{\\delta}(s_i)$.\n    c. Project $\\boldsymbol{\\delta}(s_i)$ onto the local frame vectors $(\\mathbf{t}_i, \\mathbf{n}_i)$ to find scalar separations $\\delta_n$ and $\\delta_t$.\n    d. Apply the bilinear traction-separation laws to compute the tractions $T_n$ and $T_t$.\n    e. Reconstruct the global traction vector $\\mathbf{T}(s_i) = T_n \\mathbf{n}_i + T_t \\mathbf{t}_i$.\n    f. Calculate the force contribution at this Gauss point and add it to $\\mathbf{f}_{int}$ using the formula from section 1.4, weighted by $w_i$, $b$, and $J$.\n5. After the loop, the vector $\\mathbf{f}_{int}$ contains the total internal forces for all eight degrees of freedom. This vector is converted to a list for output.",
            "answer": "```python\nimport numpy as np\n\ndef compute_tractions(delta_n, delta_t, params):\n    \"\"\"\n    Computes normal and tangential tractions based on a bilinear traction-separation law.\n\n    Args:\n        delta_n (float): Normal separation.\n        delta_t (float): Tangential separation.\n        params (dict): Dictionary of cohesive material parameters.\n\n    Returns:\n        tuple: A tuple containing the normal traction (Tn) and tangential traction (Tt).\n    \"\"\"\n    Kn, Kt = params['Kn'], params['Kt']\n    d0n, dfn = params['delta_0n'], params['delta_fn']\n    d0t, dft = params['delta_0t'], params['delta_ft']\n\n    # Normal traction (Tn) calculation\n    Tn = 0.0\n    if delta_n > 0:\n        if delta_n <= d0n:\n            Tn = Kn * delta_n\n        elif delta_n < dfn:\n            Tn_max = Kn * d0n\n            Tn = Tn_max * (dfn - delta_n) / (dfn - d0n)\n    # For delta_n <= 0 (compression) or delta_n >= dfn (failure), Tn is 0.\n\n    # Tangential traction (Tt) calculation\n    Tt = 0.0\n    abs_delta_t = abs(delta_t)\n    if abs_delta_t > 1e-15: # Avoid division by zero, floating point safe check for non-zero\n        if abs_delta_t <= d0t:\n            Tt = Kt * delta_t\n        elif abs_delta_t < dft:\n            Tt_max = Kt * d0t\n            Tt = Tt_max * (dft - abs_delta_t) / (dft - d0t) * np.sign(delta_t)\n    # For abs_delta_t = 0 or abs_delta_t >= dft (failure), Tt is 0.\n\n    return Tn, Tt\n\ndef compute_internal_force(case):\n    \"\"\"\n    Computes the element internal force vector for a 4-node cohesive element.\n\n    Args:\n        case (dict): A dictionary containing all data for a single test case.\n\n    Returns:\n        list: The flattened 8-component element internal force vector.\n    \"\"\"\n    u1 = np.array(case['u1'], dtype=float)\n    u2 = np.array(case['u2'], dtype=float)\n    u3 = np.array(case['u3'], dtype=float)\n    u4 = np.array(case['u4'], dtype=float)\n    local_frames = case['local_frames']\n    params = case['params']\n    L, b = case['geometry']['L'], case['geometry']['b']\n\n    # Gauss quadrature: 2-point scheme for a line element\n    gauss_points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    gauss_weights = [1.0, 1.0]\n\n    # Jacobian of the mapping from natural to physical coordinates\n    J = L / 2.0\n\n    # Initialize the element internal force vector [fx1, fy1, fx2, fy2, ...]\n    f_int = np.zeros(8)\n\n    for i, s in enumerate(gauss_points):\n        w = gauss_weights[i]\n\n        # Linear shape functions N1(s) and N2(s)\n        N1 = 0.5 * (1.0 - s)\n        N2 = 0.5 * (1.0 + s)\n\n        # Interpolate displacements on bottom and top surfaces\n        u_bottom = N1 * u1 + N2 * u2\n        u_top = N1 * u3 + N2 * u4\n\n        # Compute displacement jump vector in global coordinates\n        delta_global = u_top - u_bottom\n\n        # Get local frame vectors at the current Gauss point\n        t_vec = np.array(local_frames[i]['t'], dtype=float)\n        n_vec = np.array(local_frames[i]['n'], dtype=float)\n\n        # Project jump to get local normal and tangential separations\n        delta_n = np.dot(delta_global, n_vec)\n        delta_t = np.dot(delta_global, t_vec)\n\n        # Compute tractions using the bilinear constitutive law\n        Tn, Tt = compute_tractions(delta_n, delta_t, params)\n\n        # Form the global traction vector\n        T_global = Tn * n_vec + Tt * t_vec\n\n        # Assemble contribution to the internal force vector\n        factor = w * b * J\n\n        # Force contribution to node 1 (bottom, s=-1 side)\n        f_int[0:2] -= N1 * T_global * factor\n        # Force contribution to node 2 (bottom, s=+1 side)\n        f_int[2:4] -= N2 * T_global * factor\n        # Force contribution to node 3 (top, s=-1 side)\n        f_int[4:6] += N1 * T_global * factor\n        # Force contribution to node 4 (top, s=+1 side)\n        f_int[6:8] += N2 * T_global * factor\n\n    return f_int.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            'u1': [0.0, 0.0], 'u2': [0.0, 0.0],\n            'u3': [1.0e-6, 2.0e-6], 'u4': [1.5e-6, 2.5e-6],\n            'local_frames': [{'t': [1.0, 0.0], 'n': [0.0, 1.0]}, {'t': [1.0, 0.0], 'n': [0.0, 1.0]}],\n            'params': {'Kn': 1.0e9, 'Kt': 5.0e8, 'delta_0n': 2.0e-5, 'delta_fn': 6.0e-5, 'delta_0t': 2.5e-5, 'delta_ft': 7.0e-5},\n            'geometry': {'L': 1.0e-1, 'b': 1.0e-2}\n        },\n        # Test case 2\n        {\n            'u1': [0.0, 0.0], 'u2': [0.0, 0.0],\n            'u3': [1.0e-6, -3.0e-5], 'u4': [2.0e-6, -4.0e-5],\n            'local_frames': [{'t': [1.0, 0.0], 'n': [0.0, 1.0]}, {'t': [1.0, 0.0], 'n': [0.0, 1.0]}],\n            'params': {'Kn': 1.0e9, 'Kt': 5.0e8, 'delta_0n': 2.0e-5, 'delta_fn': 6.0e-5, 'delta_0t': 2.5e-5, 'delta_ft': 7.0e-5},\n            'geometry': {'L': 1.0e-1, 'b': 1.0e-2}\n        },\n        # Test case 3\n        {\n            'u1': [0.0, 0.0], 'u2': [0.0, 0.0],\n            'u3': [3.0e-5, 1.0e-6], 'u4': [4.0e-5, 1.0e-6],\n            'local_frames': [{'t': [1.0, 0.0], 'n': [0.0, 1.0]}, {'t': [1.0, 0.0], 'n': [0.0, 1.0]}],\n            'params': {'Kn': 1.0e9, 'Kt': 5.0e8, 'delta_0n': 2.0e-5, 'delta_fn': 6.0e-5, 'delta_0t': 2.5e-5, 'delta_ft': 7.0e-5},\n            'geometry': {'L': 1.0e-1, 'b': 1.0e-2}\n        },\n        # Test case 4\n        {\n            'u1': [0.0, 0.0], 'u2': [0.0, 0.0],\n            'u3': [-1.4019237962155611e-5, 8.428203230275509e-5],\n            'u4': [-1.4689111140456177e-5, 9.544228654700208e-5],\n            'local_frames': [\n                {'t': [0.8660254037844386, 0.5], 'n': [-0.5, 0.8660254037844386]},\n                {'t': [0.8660254037844386, 0.5], 'n': [-0.5, 0.8660254037844386]}\n            ],\n            'params': {'Kn': 1.0e9, 'Kt': 5.0e8, 'delta_0n': 2.0e-5, 'delta_fn': 6.0e-5, 'delta_0t': 2.5e-5, 'delta_ft': 7.0e-5},\n            'geometry': {'L': 1.0e-1, 'b': 1.0e-2}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        f_int_vector = compute_internal_force(case)\n        results.append(f_int_vector)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Simulating crack propagation in materials where the fracture path is not known in advance requires sophisticated techniques. This practice explores the logic behind \"extrinsic\" cohesive zone models, where cohesive elements are inserted into a mesh dynamically based on the evolving stress field. You will implement a physically-based criterion for crack initiation that considers both the local stress state and its alignment with the finite element mesh . This exercise provides insight into the algorithmic challenges of predicting complex fracture patterns and is central to advanced computational fracture mechanics.",
            "id": "3439069",
            "problem": "You are asked to formalize and implement a decision rule for inserting extrinsic cohesive elements in a two-dimensional quasi-static fracture simulation based on the Cohesive Zone Model (CZM). The fundamental basis must start from the following principles.\n\n- The Cauchy stress tensor in two dimensions is a symmetric matrix, denoted by $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{2 \\times 2}$, whose principal stresses are its eigenvalues and whose principal directions are the corresponding orthonormal eigenvectors. For a symmetric $\\boldsymbol{\\sigma}$, there exist orthonormal eigenvectors $\\{\\boldsymbol{p}_1,\\boldsymbol{p}_2\\}$ and real eigenvalues $\\{\\sigma_1,\\sigma_2\\}$ with $\\sigma_1 \\ge \\sigma_2$ such that $\\boldsymbol{\\sigma}\\boldsymbol{p}_i = \\sigma_i \\boldsymbol{p}_i$.\n- At a given quasi-static load increment, crack advance is driven by local tensile stress. A simple insertion criterion is that a cohesive interface can be inserted along a mesh edge if the local maximum principal stress $\\sigma_1$ exceeds a material threshold $\\sigma_c$ and the mesh edge is sufficiently aligned with the maximum principal direction $\\boldsymbol{p}_1$.\n- Given a mesh edge defined by two nodes with coordinates $\\boldsymbol{x}_i$ and $\\boldsymbol{x}_j$ in $\\mathbb{R}^2$, the unit tangent is $\\boldsymbol{t} = (\\boldsymbol{x}_j - \\boldsymbol{x}_i)/\\|\\boldsymbol{x}_j - \\boldsymbol{x}_i\\|$, and one compatible unit normal is $\\boldsymbol{n} = (-t_y, t_x)$. Because the physical interface is a line without a preferred normal orientation, alignment is tested using the unsigned angle between $\\boldsymbol{n}$ and $\\boldsymbol{p}_1$, which can be computed through the absolute value of the dot product.\n\nYour task is to implement the following algorithmic criterion.\n\n- For each mesh edge $e$ with adjacent element indices $\\mathcal{A}(e)$, compute the maximum principal stress $\\sigma_1^{(k)}$ and corresponding unit eigenvector $\\boldsymbol{p}_1^{(k)}$ for each adjacent element $k \\in \\mathcal{A}(e)$ from its element stress tensor $\\boldsymbol{\\sigma}^{(k)}$.\n- Select the adjacent element index $k^\\star \\in \\mathcal{A}(e)$ that maximizes $\\sigma_1^{(k)}$. If there is a tie, break it deterministically by choosing the first index in $\\mathcal{A}(e)$.\n- Let $\\sigma_1^\\star = \\sigma_1^{(k^\\star)}$ and $\\boldsymbol{p}_1^\\star = \\boldsymbol{p}_1^{(k^\\star)}$. Compute the unit edge normal $\\boldsymbol{n}$ as defined above. Define the unsigned alignment angle $\\theta = \\arccos\\left(|\\boldsymbol{n} \\cdot \\boldsymbol{p}_1^\\star|\\right)$.\n- The insertion criterion is satisfied if and only if all of the following hold simultaneously: (i) $\\sigma_1^\\star \\ge \\sigma_c$, (ii) $\\theta \\le \\gamma_{\\mathrm{tol}}$, and (iii) the edge has not been previously inserted in any earlier increment. Angles must be treated in radians in computations but are specified to you in degrees as input. All stresses and thresholds are specified in megapascal (MPa), and you must treat them as such. \n\nYou must implement a program that applies this criterion to a concrete set of test cases and returns, for each case, the sorted list of zero-based edge indices for which extrinsic cohesive elements must be inserted.\n\nAll inputs for the test suite are described below. All coordinates are in meters (m), all stresses and thresholds are in megapascal (MPa), and all angles provided are in degrees. Your implementation must convert degrees to radians for trigonometric functions. The output is unitless integer indices.\n\nTest Suite:\n\n- Test case $1$ (happy path with interior and boundary edges):\n  - Nodes (index $\\to$ coordinates): $0 \\to (0,0)$, $1 \\to (1,0)$, $2 \\to (1,1)$, $3 \\to (0,1)$.\n  - Elements (triangles as node triples): element $0$: $(0,1,2)$, element $1$: $(0,2,3)$.\n  - Unique edges (index $\\to$ node pair): $0 \\to (0,1)$, $1 \\to (1,2)$, $2 \\to (2,3)$, $3 \\to (3,0)$, $4 \\to (0,2)$.\n  - Edge adjacency $\\mathcal{A}(e)$ (edge index $\\to$ list of adjacent element indices): $0 \\to [0]$, $1 \\to [0]$, $2 \\to [1]$, $3 \\to [1]$, $4 \\to [0,1]$.\n  - Element stresses $\\boldsymbol{\\sigma}^{(k)}$ in MPa: element $0$: $\\begin{bmatrix}130  0\\\\ 0  70\\end{bmatrix}$, element $1$: $\\begin{bmatrix}50  0\\\\ 0  150\\end{bmatrix}$.\n  - Threshold $\\sigma_c = 120$ MPa. Alignment tolerance $\\gamma_{\\mathrm{tol}} = 15$ degrees. Previously inserted edges: none.\n  - Expected behavior: edges aligned with the local maximum principal direction and exceeding threshold should be selected on both a boundary edge and an interior adjacency choice.\n\n- Test case $2$ (below-threshold rejection):\n  - Same nodes, elements, unique edges, and adjacency as test case $1$.\n  - Element stresses $\\boldsymbol{\\sigma}^{(k)}$ in MPa: element $0$: $\\begin{bmatrix}80  0\\\\ 0  10\\end{bmatrix}$, element $1$: $\\begin{bmatrix}50  0\\\\ 0  90\\end{bmatrix}$.\n  - Threshold $\\sigma_c = 120$ MPa. Alignment tolerance $\\gamma_{\\mathrm{tol}} = 15$ degrees. Previously inserted edges: none.\n  - Expected behavior: no edges are selected because the threshold is not met anywhere.\n\n- Test case $3$ (boundary cases for equality and exclusion by history):\n  - Nodes (index $\\to$ coordinates): $0 \\to (0,0)$, $1 \\to (1,0)$, $2 \\to (0,1)$.\n  - Elements: single triangle, element $0$: $(0,1,2)$.\n  - Unique edges (index $\\to$ node pair): $0 \\to (0,1)$, $1 \\to (1,2)$, $2 \\to (2,0)$.\n  - Edge adjacency: $0 \\to [0]$, $1 \\to [0]$, $2 \\to [0]$.\n  - Element stress $\\boldsymbol{\\sigma}^{(0)}$ in MPa: $\\begin{bmatrix}100  0\\\\ 0  20\\end{bmatrix}$.\n  - Threshold $\\sigma_c = 100$ MPa. Alignment tolerance $\\gamma_{\\mathrm{tol}} = 45$ degrees. Previously inserted edges: $\\{2\\}$.\n  - Expected behavior: edges meeting equality cases $\\sigma_1^\\star = \\sigma_c$ and $\\theta = \\gamma_{\\mathrm{tol}}$ are admissible by the criterion, but edge index $2$ must be excluded due to prior insertion.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is the zero-based sorted list of edge indices to insert for the corresponding test case, for example, $[ [\\,\\cdot\\,], [\\,\\cdot\\,], [\\,\\cdot\\,] ]$. The output must not contain any spaces. For the given test suite, your program should print a single line like \"[[e\\_list\\_for\\_case\\_1],[e\\_list\\_for\\_case\\_2],[e\\_list\\_for\\_case\\_3]]\", where each e\\_list is a list of integers.\n\nImplement the algorithm as a complete, runnable program that reads no input and writes exactly one line in the specified format. All geometric calculations must be performed in the Euclidean plane, and all angles must be treated in degrees at the interface but converted to radians internally for trigonometric evaluation. All stresses and thresholds must be interpreted in MPa. The final outputs are unitless integer lists.",
            "solution": "We start from the Cauchy stress tensor $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{2 \\times 2}$, which is symmetric, so it admits an orthonormal eigenbasis with real eigenvalues. The principal stresses are the eigenvalues $\\sigma_1 \\ge \\sigma_2$, and the corresponding principal directions are unit eigenvectors $\\boldsymbol{p}_1$ and $\\boldsymbol{p}_2$. The alignment in two dimensions can be expressed via an angle between unit vectors, computable through a dot product.\n\nGiven a mesh edge with node coordinates $\\boldsymbol{x}_i, \\boldsymbol{x}_j \\in \\mathbb{R}^2$, define the unit tangent $\\boldsymbol{t} = (\\boldsymbol{x}_j - \\boldsymbol{x}_i)/\\|\\boldsymbol{x}_j - \\boldsymbol{x}_i\\|$. A compatible unit normal is $\\boldsymbol{n} = (-t_y, t_x)$. Because a line does not have a unique oriented normal, the absolute dot product with the principal direction yields the cosine of the smallest angle between the edge normal line and the principal direction line:\n$$\n\\theta = \\arccos\\left( \\left| \\boldsymbol{n} \\cdot \\boldsymbol{p}_1 \\right| \\right).\n$$\nThis $\\theta \\in [0,\\pi/2]$ by construction. Using an angle tolerance $\\gamma_{\\mathrm{tol}}$ (given in degrees), the alignment condition is $\\theta \\le \\gamma_{\\mathrm{tol}}$. Since numerical computation is done in radians, we convert $\\gamma_{\\mathrm{tol}}$ from degrees via\n$$\n\\gamma_{\\mathrm{rad}} = \\gamma_{\\mathrm{tol}} \\times \\frac{\\pi}{180}.\n$$\nThen the alignment inequality is equivalently\n$$\n\\left| \\boldsymbol{n} \\cdot \\boldsymbol{p}_1 \\right| \\ge \\cos(\\gamma_{\\mathrm{rad}}).\n$$\n\nNext, for each edge $e$ with adjacent element indices $\\mathcal{A}(e)$, we compute for each $k \\in \\mathcal{A}(e)$ the maximum principal stress $\\sigma_1^{(k)}$ and its direction $\\boldsymbol{p}_1^{(k)}$ via an eigen-decomposition of the symmetric tensor $\\boldsymbol{\\sigma}^{(k)}$. We then select $k^\\star = \\arg\\max_{k \\in \\mathcal{A}(e)} \\sigma_1^{(k)}$, breaking ties deterministically, and denote $\\sigma_1^\\star = \\sigma_1^{(k^\\star)}$ and $\\boldsymbol{p}_1^\\star = \\boldsymbol{p}_1^{(k^\\star)}$. The extrinsic cohesive insertion criterion requires all of the following:\n- Stress threshold: $\\sigma_1^\\star \\ge \\sigma_c$.\n- Alignment: $\\left| \\boldsymbol{n} \\cdot \\boldsymbol{p}_1^\\star \\right| \\ge \\cos(\\gamma_{\\mathrm{rad}})$.\n- History exclusion: the edge is not listed among previously inserted edges.\n\nAlgorithmic steps for each test case:\n1. For each element, compute the eigen-decomposition of $\\boldsymbol{\\sigma}^{(k)}$ using a symmetric solver, obtain $(\\sigma_1^{(k)}, \\boldsymbol{p}_1^{(k)})$ with $\\sigma_1^{(k)}$ the largest eigenvalue and $\\boldsymbol{p}_1^{(k)}$ the corresponding normalized eigenvector.\n2. For each edge, compute the unit tangent $\\boldsymbol{t}$ and unit normal $\\boldsymbol{n}$ from node coordinates. Retrieve the list $\\mathcal{A}(e)$ and select $k^\\star$ with the largest $\\sigma_1^{(k)}$. Form $\\sigma_1^\\star$ and $\\boldsymbol{p}_1^\\star$.\n3. Compute $c = \\left| \\boldsymbol{n} \\cdot \\boldsymbol{p}_1^\\star \\right|$ and the threshold $c_{\\min} = \\cos(\\gamma_{\\mathrm{rad}})$.\n4. If the edge index is not in the history set, and $\\sigma_1^\\star \\ge \\sigma_c$ and $c \\ge c_{\\min}$, mark the edge for insertion.\n5. Return the sorted list of indices.\n\nSoundness and edge cases:\n- Using the absolute value in the dot product ensures invariance under $\\boldsymbol{n} \\mapsto -\\boldsymbol{n}$ and $\\boldsymbol{p}_1 \\mapsto -\\boldsymbol{p}_1$, appropriate for unoriented lines. Because $\\boldsymbol{n}$ and $\\boldsymbol{p}_1^\\star$ are both unit vectors, $c = \\cos(\\theta)$ with $\\theta \\in [0,\\pi/2]$.\n- The use of the maximum $\\sigma_1$ among adjacent elements models a local driving force chosen from the most critical adjacent state, and tie-breaking yields determinism.\n- Boundary edges with a single adjacent element are treated naturally with $|\\mathcal{A}(e)| = 1$.\n\nApplication to the specified test suite:\n\nTest case $1$:\n- Element $0$ has $\\boldsymbol{\\sigma} = \\begin{bmatrix}130  0\\\\ 0  70\\end{bmatrix}$, yielding $\\sigma_1^{(0)} = 130$ with $\\boldsymbol{p}_1^{(0)} = (1,0)^\\top$.\n- Element $1$ has $\\boldsymbol{\\sigma} = \\begin{bmatrix}50  0\\\\ 0  150\\end{bmatrix}$, yielding $\\sigma_1^{(1)} = 150$ with $\\boldsymbol{p}_1^{(1)} = (0,1)^\\top$.\n- With $\\sigma_c = 120$ and $\\gamma_{\\mathrm{tol}} = 15^\\circ$, $c_{\\min} = \\cos(15^\\circ)$.\n  - Edge $1$ is vertical with unit normal aligned with $(\\pm 1,0)^\\top$; adjacent element is $0$ with $\\boldsymbol{p}_1^{(0)} = (1,0)^\\top$ and $\\sigma_1^{(0)} = 130 \\ge 120$. The dot magnitude is $1 \\ge \\cos(15^\\circ)$, so edge $1$ is selected.\n  - Edge $2$ is horizontal with unit normal aligned with $(0,\\pm 1)^\\top$; adjacent element is $1$ with $\\boldsymbol{p}_1^{(1)} = (0,1)^\\top$ and $\\sigma_1^{(1)} = 150 \\ge 120$. The dot magnitude is $1 \\ge \\cos(15^\\circ)$, so edge $2$ is selected.\n  - Other edges fail alignment or the threshold. The diagonal edge $4$ has alignment at $45^\\circ$, which exceeds $15^\\circ$.\n- Result: $[1,2]$.\n\nTest case $2$:\n- Maximum principal stresses are below $\\sigma_c = 120$ MPa. No edges satisfy the stress condition. Result: $[]$.\n\nTest case $3$:\n- Single element with $\\boldsymbol{\\sigma} = \\begin{bmatrix}100  0\\\\ 0  20\\end{bmatrix}$ has $\\sigma_1^{(0)} = 100$ with $\\boldsymbol{p}_1^{(0)} = (1,0)^\\top$. With $\\sigma_c = 100$ MPa and $\\gamma_{\\mathrm{tol}} = 45^\\circ$, both equality cases $\\sigma_1^\\star = \\sigma_c$ and $\\theta = \\gamma_{\\mathrm{tol}}$ are admissible. Edges $1$ and $2$ satisfy alignment ($45^\\circ$ and $0^\\circ$, respectively) and the stress threshold. However, edge $2$ is excluded due to prior insertion history. Result: $[1]$.\n\nTherefore, the expected program output is the single line\n$$\n[[1,2],[],[1]]\n$$\nwith no spaces, aggregating the three test case results. The algorithm is implemented using a symmetric eigen-decomposition for robustness, explicit construction of unit normals and principal directions, and degree-to-radian conversion for trigonometric functions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef max_principal(stress: np.ndarray):\n    \"\"\"\n    Compute the maximum principal stress and corresponding unit eigenvector\n    for a 2x2 symmetric Cauchy stress tensor.\n    \"\"\"\n    # Use eigh for symmetric matrices: returns ascending eigenvalues\n    vals, vecs = np.linalg.eigh(stress)\n    idx = int(np.argmax(vals))\n    sigma1 = float(vals[idx])\n    p1 = vecs[:, idx]\n    # Normalize to unit length (robustness)\n    nrm = np.linalg.norm(p1)\n    if nrm == 0.0:\n        # Fallback: default direction if degenerate (should not occur for SPD or typical stresses)\n        p1 = np.array([1.0, 0.0], dtype=float)\n    else:\n        p1 = p1 / nrm\n    return sigma1, p1\n\ndef unit_normal(node_i: np.ndarray, node_j: np.ndarray):\n    \"\"\"\n    Compute one unit normal to the edge from node_i to node_j.\n    Orientation is irrelevant because we use absolute dot products.\n    \"\"\"\n    v = node_j - node_i\n    lv = np.linalg.norm(v)\n    if lv == 0.0:\n        # Degenerate edge; return a default unit normal\n        return np.array([1.0, 0.0], dtype=float)\n    t = v / lv\n    n = np.array([-t[1], t[0]], dtype=float)\n    # Already unit because t is unit\n    return n\n\ndef select_edges(nodes, elements, edges, edge2elems, stresses, sigma_c, gamma_deg, already_inserted):\n    \"\"\"\n    Apply the extrinsic cohesive insertion criterion and return sorted list of edge indices.\n    \"\"\"\n    # Precompute principal data per element\n    elem_principal = [max_principal(st) for st in stresses]\n    # Precompute cosine threshold\n    gamma_rad = np.deg2rad(gamma_deg)\n    cos_min = float(np.cos(gamma_rad))\n\n    selected = []\n    node_array = np.asarray(nodes, dtype=float)\n\n    already_set = set(already_inserted)\n\n    for e_idx, (i, j) in enumerate(edges):\n        if e_idx in already_set:\n            continue\n        # Build unit normal\n        n = unit_normal(node_array[i], node_array[j])\n\n        # Adjacent elements\n        adj = edge2elems[e_idx]\n        if not adj:\n            # No adjacent elements: cannot decide\n            continue\n\n        # Choose element with max principal stress\n        sigmas = [elem_principal[k][0] for k in adj]\n        max_index_local = int(np.argmax(sigmas))\n        k_star = adj[max_index_local]\n        sigma1_star, p1_star = elem_principal[k_star]\n\n        # Apply criteria\n        if sigma1_star = sigma_c:\n            c = float(abs(np.dot(n, p1_star)))  # both unit vectors\n            if c = cos_min:\n                selected.append(e_idx)\n\n    selected.sort()\n    return selected\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Test case 1\n    nodes1 = np.array([\n        [0.0, 0.0],  # 0\n        [1.0, 0.0],  # 1\n        [1.0, 1.0],  # 2\n        [0.0, 1.0],  # 3\n    ], dtype=float)\n    elements1 = [(0, 1, 2), (0, 2, 3)]\n    edges1 = [(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)]\n    edge2elems1 = [[0], [0], [1], [1], [0, 1]]\n    stresses1 = [\n        np.array([[130.0, 0.0], [0.0, 70.0]], dtype=float),   # element 0\n        np.array([[50.0, 0.0], [0.0, 150.0]], dtype=float),   # element 1\n    ]\n    sigma_c1 = 120.0\n    gamma_deg1 = 15.0\n    already1 = []\n\n    # Test case 2\n    nodes2 = nodes1.copy()\n    elements2 = elements1.copy()\n    edges2 = edges1.copy()\n    edge2elems2 = [lst.copy() for lst in edge2elems1]\n    stresses2 = [\n        np.array([[80.0, 0.0], [0.0, 10.0]], dtype=float),   # element 0\n        np.array([[50.0, 0.0], [0.0, 90.0]], dtype=float),   # element 1\n    ]\n    sigma_c2 = 120.0\n    gamma_deg2 = 15.0\n    already2 = []\n\n    # Test case 3\n    nodes3 = np.array([\n        [0.0, 0.0],  # 0\n        [1.0, 0.0],  # 1\n        [0.0, 1.0],  # 2\n    ], dtype=float)\n    elements3 = [(0, 1, 2)]\n    edges3 = [(0, 1), (1, 2), (2, 0)]\n    edge2elems3 = [[0], [0], [0]]\n    stresses3 = [\n        np.array([[100.0, 0.0], [0.0, 20.0]], dtype=float),\n    ]\n    sigma_c3 = 100.0\n    gamma_deg3 = 45.0\n    already3 = [2]\n\n    test_cases = [\n        (nodes1, elements1, edges1, edge2elems1, stresses1, sigma_c1, gamma_deg1, already1),\n        (nodes2, elements2, edges2, edge2elems2, stresses2, sigma_c2, gamma_deg2, already2),\n        (nodes3, elements3, edges3, edge2elems3, stresses3, sigma_c3, gamma_deg3, already3),\n    ]\n\n    results = []\n    for case in test_cases:\n        nodes, elements, edges, edge2elems, stresses, sigma_c, gamma_deg, already = case\n        sel = select_edges(nodes, elements, edges, edge2elems, stresses, sigma_c, gamma_deg, already)\n        results.append(sel)\n\n    # Format without spaces: e.g., [[1,2],[],[1]]\n    def format_list(lst):\n        return \"[\" + \",\".join(str(int(x)) for x in lst) + \"]\"\n    out = \"[\" + \",\".join(format_list(r) for r in results) + \"]\"\n    print(out)\n\nsolve()\n```"
        }
    ]
}