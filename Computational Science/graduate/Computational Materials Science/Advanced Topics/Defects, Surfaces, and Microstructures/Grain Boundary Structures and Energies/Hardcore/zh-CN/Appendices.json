{
    "hands_on_practices": [
        {
            "introduction": "原子模拟通常在具有周期性边界条件的有限尺寸晶胞中进行，这会引入非物理的相互作用。对于晶界计算，这种相互作用导致计算出的晶界能依赖于模拟体系的尺寸。我们可以利用连续介质弹性理论来为这种相互作用建模，该理论预测误差与体系尺寸 $L$ 成 $1/L$ 的标度关系，这使得我们能够通过在多个尺寸下进行模拟，并将结果外推至无限大尺寸极限，从而获得真实的晶界能。本练习将指导你推导这种修正，并应用它从一组模拟数据点中外推晶界能。",
            "id": "3455328",
            "problem": "考虑一个在周期性边界条件（PBC）下模拟的双晶，该双晶包含两个相同的平面晶界。垂直于晶界平面的双晶长度记为 $L$。在计算材料科学中，计算出的单位面积晶界能（记为 $\\gamma(L)$）中的有限尺寸效应，源于两个晶界及其周期性镜像之间的弹性相互作用。目标是计算几个不同 $L$ 值下的 $\\gamma(L)$，并外推至无限尺寸极限 $L \\to \\infty$，以获得 $\\gamma(\\infty)$。\n\n使用连续、各向同性、线弹性的表示方法来描述晶界。将晶界建模为一个平面弹性偶极子层，其单位面积的有效偶极子密度为 $p$。在双晶板的平面应变极限下进行分析，并设材料的杨氏模量为 $E$，泊松比为 $\\nu$。从各向同性线弹性的基本原理出发：胡克定律 $\\sigma_{ij} = \\lambda \\delta_{ij} \\epsilon_{kk} + 2 \\mu \\epsilon_{ij}$（其中 $\\lambda$ 和 $\\mu$ 为拉梅参数），以及应变能密度 $u = \\tfrac{1}{2} \\sigma_{ij} \\epsilon_{ij}$（隐含爱因斯坦求和约定）。在平面应变条件下，通过 $E^\\star = \\dfrac{E}{1-\\nu^2}$ 定义有效模量 $E^\\star$。基于弹性格林函数框架，推导在各向同性介质中、周期性边界条件下，两个相距为 $L$ 的相同平面偶极子层相互作用的领头阶渐近关系，即对于较大的 $L$，单位面积晶界能的弹性镜像相互作用修正项 $\\Delta \\gamma(L)$ 的依赖关系。将此修正项与内禀（核心）贡献 $\\gamma_{\\mathrm{core}}$ 相结合，得到 $\\gamma(L) = \\gamma_{\\mathrm{core}} + \\Delta \\gamma(L)$，单位为焦耳/平方米。\n\n实现所推导的领头阶修正，并针对指定的测试用例计算 $\\gamma(L)$，然后根据推导出的领头阶定律所对应的预测变量，对 $\\gamma(L)$ 进行基于回归的外推，以估计在无限长度极限下的截距，即 $\\gamma(\\infty)$。明确说明并使用一致的物理单位。将以纳米为单位的 $L$ 转换为米，将以吉帕斯卡为单位的 $E$ 转换为帕斯卡， $p$ 的单位为牛顿/米，能量以焦耳/平方米报告。本问题不使用角度。最终答案以焦耳/平方米表示，并四舍五入至六位小数。\n\n使用以下三个物理上合理的测试用例套件，旨在探究一般情况、边界情况和敏感性情况。对于每个用例，计算所有列出的 $L$ 值的 $\\gamma(L)$，并执行外推以获得单一的 $\\gamma(\\infty)$ 值：\n\n- 用例1：$E = 200$ 吉帕斯卡，$\\nu = 0.30$，$p = 50$ 牛顿/米，$\\gamma_{\\mathrm{core}} = 0.7$ 焦耳/平方米，$L \\in \\{10, 15, 30, 60\\}$ 纳米。\n- 用例2：$E = 70$ 吉帕斯卡，$\\nu = 0.33$，$p = 40$ 牛顿/米，$\\gamma_{\\mathrm{core}} = 0.5$ 焦耳/平方米，$L \\in \\{5, 10, 20\\}$ 纳米。\n- 用例3：$E = 120$ 吉帕斯卡，$\\nu = 0.25$，$p = 0$ 牛顿/米，$\\gamma_{\\mathrm{core}} = 0.4$ 焦耳/平方米，$L \\in \\{10, 20, 40\\}$ 纳米。\n\n您的程序应生成单行输出，其中包含三个外推得到的 $\\gamma(\\infty)$ 值。这些值应放在方括号内，以逗号分隔，每个值都四舍五入至六位小数（例如，$[\\gamma_\\infty^{(1)},\\gamma_\\infty^{(2)},\\gamma_\\infty^{(3)}]$）。不应打印任何其他文本。",
            "solution": "该问题要求推导并应用一个模型来描述计算模拟中晶界能的有限尺寸效应，然后通过基于回归的外推法确定无限系统极限下的能量 $\\gamma(\\infty)$。\n\n### 步骤1：理论推导\n\n该问题在连续各向同性线弹性框架内进行求解。晶界被建模为一个平面弹性偶极子层。在使用周期性边界条件（PBC）的模拟中，沿垂直于晶界平面的方向（我们称之为 $z$ 方向），长度为 $L$ 的双晶包含两个晶界。模拟单元的有限尺寸 $L$ 导致晶界与其周期性镜像之间产生人为的弹性相互作用。这种相互作用能 $\\Delta \\gamma_{el}(L)$ 构成了计算出的总单位面积晶界能 $\\gamma(L)$ 的一部分。\n\n总能量表示为内禀核心能 $\\gamma_{\\mathrm{core}}$（与系统尺寸无关）和依赖于尺寸的弹性相互作用能之和：\n$$ \\gamma(L) = \\gamma_{\\mathrm{core}} + \\Delta \\gamma_{el}(L) $$\n我们的目标是推导当 $L$ 很大时 $\\Delta \\gamma_{el}(L)$ 的领头阶函数形式。\n\n弹性相互作用能源于一个晶界的应力场对另一个晶界的应变场做的功。在周期性系统中，这涉及对所有周期性镜像的相互作用进行求和。当 $L$ 很大时，主要贡献来自最近的镜像晶界，其距离为 $L$。因此，问题可以简化为求解两个相距为 $L$ 的相同平行偶极子层之间的相互作用能。\n\n推导从弹性格林函数开始，它给出了弹性介质中由点力引起的位移场。通过对格林函数及其导数进行积分，可以从任何力密度分布中找到应力场和应变场。晶界作为一个晶格畸变严重的区域，可以用力偶极子的分布来表示。问题指定了一个平面偶极子层，其有效偶极子密度（单位面积的偶极矩）大小为 $p$。\n\n两个此类层之间的单位面积相互作用能 $\\Delta\\gamma_{el}(L)$，通过计算将第二层引入第一层应力场时所做的功来求得。这涉及在整个体积上对第一个晶界的应力张量与第二个晶界的应变张量的乘积进行积分。使用特别适用于周期性系统的傅里叶空间方法，可以计算出这种相互作用能。\n\n对于各向同性材料在平面应变条件下的特定情况，大间距 $L$ 的领头阶结果为：\n$$ \\Delta \\gamma_{el}(L) = \\frac{p^2}{2 \\pi E^\\star L} $$\n这里，$p$ 是有效偶极子密度，$E^\\star$ 是平面应变弹性模量，定义为：\n$$ E^\\star = \\frac{E}{1 - \\nu^2} $$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。对于周期性边界条件下的晶界和位错等缺陷的弹性相互作用，这种 $1/L$ 依赖关系是一个公认的结果。\n\n### 步骤2：外推程序\n\n结合推导出的各项，总晶界能作为系统尺寸 $L$ 的函数为：\n$$ \\gamma(L) = \\gamma_{\\mathrm{core}} + \\frac{p^2}{2 \\pi E^\\star L} $$\n目标是估计 $\\gamma(\\infty)$。从该方程可以明显看出，当 $L \\to \\infty$ 时，相互作用项消失，且 $\\gamma(L) \\to \\gamma_{\\mathrm{core}}$。因此，$\\gamma(\\infty) = \\gamma_{\\mathrm{core}}$。\n\n然而，问题要求我们执行基于回归的外推。这模拟了一个真实场景：拥有一组计算出的数据点 $(\\gamma(L_i))$，并试图找到无限尺寸极限。该模型方程显示了 $\\gamma(L)$ 与预测变量 $x = 1/L$ 之间的线性关系：\n$$ \\gamma(L) = \\gamma(\\infty) + C \\cdot \\frac{1}{L} $$\n其中常数 $C = p^2 / (2 \\pi E^\\star)$ 是斜率，$\\gamma(\\infty)$ 是截距。\n\n因此，指定的过程如下：\n1.  对于每个测试用例和每个给定的长度 $L_i$，使用上面推导的公式和提供的 $\\gamma_{\\mathrm{core}}$ 计算“模拟的”晶界能 $\\gamma(L_i)$。\n2.  创建一组数据对 $(x_i, y_i)$，其中 $x_i = 1/L_i$，$y_i = \\gamma(L_i)$。\n3.  对这些数据点进行线性回归，以拟合模型 $y = mx + b$。\n4.  确定的截距 $b$ 是 $\\gamma(\\infty)$ 的外推估计值。\n\n鉴于数据点是由一个完美的线性模型生成的，线性回归将产生一个截距，在数值精度范围内，该截距与用于生成数据的 $\\gamma_{\\mathrm{core}}$ 值相同。对于 $p=0$ 的特殊情况，相互作用项为零，$\\gamma(L)$ 对所有 $L$ 都是常数，回归将简单地返回这个常数值作为截距。\n\n### 步骤3：计算实现\n\n每个测试用例的算法如下：\n1.  分配输入参数：$E$、$\\nu$、$p$、$\\gamma_{\\mathrm{core}}$ 以及长度列表 $\\{L_i\\}$。\n2.  将单位转换为一致的 SI 基本单位：$E$ 从 GPa 转换为 Pa ($1 \\text{ GPa} = 10^9 \\text{ Pa}$)，$L$ 从 nm 转换为 m ($1 \\text{ nm} = 10^{-9} \\text{ m}$)。\n3.  计算平面应变模量：$E^\\star = E / (1 - \\nu^2)$。\n4.  计算斜率系数：$C = p^2 / (2 \\pi E^\\star)$。\n5.  生成预测变量 $x_i = 1/L_i$ 和响应变量 $y_i = \\gamma_{\\mathrm{core}} + C / L_i$。\n6.  使用数值线性回归工具（例如 `numpy.polyfit`）找到通过点 $(x_i, y_i)$ 的最佳拟合线的截距。\n7.  所得截距即为该用例的 $\\gamma(\\infty)$ 值。每个用例的最终结果按要求四舍五入至六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Note: scipy is listed as available but numpy.polyfit is sufficient for this task.\n# from scipy import stats\n\ndef solve():\n    \"\"\"\n    Solves the grain boundary energy extrapolation problem for the given test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary containing all necessary parameters.\n    test_cases = [\n        {\n            \"E_GPa\": 200, \"nu\": 0.30, \"p_Nm\": 50, \"gamma_core_Jm2\": 0.7,\n            \"L_nm\": [10, 15, 30, 60]\n        },\n        {\n            \"E_GPa\": 70, \"nu\": 0.33, \"p_Nm\": 40, \"gamma_core_Jm2\": 0.5,\n            \"L_nm\": [5, 10, 20]\n        },\n        {\n            \"E_GPa\": 120, \"nu\": 0.25, \"p_Nm\": 0, \"gamma_core_Jm2\": 0.4,\n            \"L_nm\": [10, 20, 40]\n        },\n    ]\n\n    extrapolated_gammas = []\n\n    for case in test_cases:\n        # Step 1: Extract parameters and convert to base SI units.\n        E = case[\"E_GPa\"] * 1e9  # GPa to Pa\n        nu = case[\"nu\"]\n        p = case[\"p_Nm\"]  # Already in N/m\n        gamma_core = case[\"gamma_core_Jm2\"]  # Already in J/m^2\n        L_values = np.array(case[\"L_nm\"]) * 1e-9  # nm to m\n\n        # Step 2: Calculate the plane-strain modulus E*\n        # E_star = E / (1 - nu^2)\n        E_star = E / (1 - nu**2)\n\n        # Step 3: Calculate the coefficient C for the 1/L term.\n        # This coefficient is the slope of the gamma vs. 1/L line.\n        # C = p^2 / (2 * pi * E_star)\n        # Handle the p=0 case to avoid division by zero if E_star were zero.\n        if E_star == 0:\n            C = 0.0\n        else:\n            C = p**2 / (2 * np.pi * E_star)\n\n        # Step 4: Generate the \"simulated\" data points (x, y) for regression.\n        # x is the predictor variable, 1/L.\n        # y is the response variable, gamma(L).\n        x_data = 1 / L_values\n        y_data = gamma_core + C / L_values\n\n        # Step 5: Perform a linear regression (polynomial fit of degree 1).\n        # np.polyfit returns coefficients [slope, intercept].\n        # We need the intercept, which corresponds to gamma(infinity).\n        # Since the data is generated from a perfect line, the regression will\n        # perfectly recover the intercept, which is gamma_core.\n        # The procedure is followed as per the problem statement.\n        if len(x_data)  2:\n            # A regression is not possible with fewer than 2 points.\n            # In this problem, all cases have at least 3 points.\n            # If a single point (L) were given, the only \"estimate\" would be gamma(L) itself.\n            # For a single point, intercept is just the y-value if slope is assumed 0.\n            # Here, we can just use the y-value.\n            gamma_infinity = y_data[0]\n        else:\n            slope, intercept = np.polyfit(x_data, y_data, 1)\n            gamma_infinity = intercept\n        \n        # Step 6: Store the result, rounded to six decimal places.\n        extrapolated_gammas.append(round(gamma_infinity, 6))\n\n    # Final print statement in the exact required format.\n    # The format is a list of comma-separated values in square brackets.\n    # The map(str, ...) converts each float to a string.\n    # The round() has already taken care of the precision. We need to ensure\n    # that trailing zeros are printed correctly for a fixed format.\n    formatted_results = [f\"{val:.6f}\" for val in extrapolated_gammas]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "计算材料科学的一个关键目标是为某个特定的、重要的晶界能量获得一个高置信度的值。我们常常从不同来源获得估算值：各种密度泛函理论（DFT）的泛函、不同的经典势函数以及实验测量。一种稳健的方法是使用统计模型（如随机效应荟萃分析）来整合所有可用信息，该模型既考虑了每种方法内部的不确定性，也考虑了方法之间的系统性差异。本练习涉及使用四种不同的计算模型计算Ni $\\Sigma 3$孪晶界的能量，并将其与源自热刻蚀实验的值进行整合，同时进行严格的不确定性传播分析。",
            "id": "3455409",
            "problem": "您的任务是开发一个完整的、可运行的程序，该程序使用两种密度泛函理论（DFT）泛函和两种经典原子间势来估算面心立方镍（Ni）$\\,\\Sigma 3\\,$共格孪晶界的晶界能，量化源于基础能量输入的不确定度，并通过有原则的模型平均程序，将这些计算结果与热刻蚀测量值进行协调。程序必须从基本定义和经过充分检验的物理关系出发，推导出必要的表达式。最终输出必须以毫焦耳/平方米（mJ/m$^2$）为单位。\n\n计算情景如下：\n- 晶界能定义为单位面积的界面过剩自由能。在一个包含两个相同晶界的周期性双晶超胞中，界面过剩能通过双晶的总能量与等量原子在块体参考态中的能量之差，除以总界面面积和相同界面的数量来获得。\n- 在与晶界相交的自由表面上进行的热刻蚀测量，产生一个几何平衡条件，该条件将晶界能与镍的表面能以及凹槽根部的二面角联系起来。角度单位指定为度。\n\n您的程序必须：\n- 推导计算每种方法的晶界能以及从给定能量输入传播不确定度所需的表达式。\n- 推导从热刻蚀数据计算晶界能所需的关系，并传播其相对于表面能和测量角度的不确定度。\n- 使用一种有统计学原则的加权平均法来协调所有估算值，该方法同时考虑了方法内的不确定度和潜在的方法间离散度。\n\n所有输入均以物理上合理、内部一致的值提供。对于每个测试用例，您将获得双晶面积（单位为平方埃）、双晶中的原子数，以及两种密度泛函理论（DFT）泛函——Perdew–Burke–Ernzerhof（PBE）和Strongly Constrained and Appropriately Normed（SCAN）——以及两种经典势——嵌入原子方法（EAM）和修正嵌入原子方法（MEAM）的能量数据。每种方法都包括双晶总能量、每原子的块体能量（以定义块体参考态），以及这些能量的不确定度。热刻蚀数据集包括镍的表面能及其不确定度、在凹槽交汇处测量的二面角（单位为度）及其不确定度（单位为度）。最终晶界能的单位必须是毫焦耳/平方米（mJ/m$^2$）。\n\n角度单位必须以度为单位处理。您的程序必须仅计算并按指定格式输出所要求的值。\n\n使用以下三个参数集的测试套件：\n\n- 测试用例 $1$：\n  - 双晶几何结构：面积 $A = 800$ $\\text{\\AA}^2$，原子数 $N = 480$。\n  - DFT (PBE)：$E_{\\text{bulk,atom}} = -4.30$ $\\text{eV}$，$E_{\\text{cell}} = -2060.8064$ $\\text{eV}$，$\\sigma_{E_{\\text{cell}}} = 0.015$ $\\text{eV}$，$\\sigma_{E_{\\text{bulk}}} = 0.0001$ $\\text{eV}$。\n  - DFT (SCAN)：$E_{\\text{bulk,atom}} = -4.45$ $\\text{eV}$，$E_{\\text{cell}} = -2132.5072$ $\\text{eV}$，$\\sigma_{E_{\\text{cell}}} = 0.020$ $\\text{eV}$，$\\sigma_{E_{\\text{bulk}}} = 0.0001$ $\\text{eV}$。\n  - EAM：$E_{\\text{bulk,atom}} = -4.44$ $\\text{eV}$，$E_{\\text{cell}} = -2128.4080$ $\\text{eV}$，$\\sigma_{E_{\\text{cell}}} = 0.050$ $\\text{eV}$，$\\sigma_{E_{\\text{bulk}}} = 0.0010$ $\\text{eV}$。\n  - MEAM：$E_{\\text{bulk,atom}} = -4.42$ $\\text{eV}$，$E_{\\text{cell}} = -2118.3072$ $\\text{eV}$，$\\sigma_{E_{\\text{cell}}} = 0.050$ $\\text{eV}$，$\\sigma_{E_{\\text{bulk}}} = 0.0010$ $\\text{eV}$。\n  - 热刻蚀：$\\,\\gamma_s = 1800$ $\\text{mJ/m}^2$，$\\sigma_{\\gamma_s} = 50$ $\\text{mJ/m}^2$，$\\alpha = 178.9$ 度，$\\sigma_{\\alpha} = 0.1$ 度。\n\n- 测试用例 $2$：\n  - 双晶几何结构：面积 $A = 600$ $\\text{\\AA}^2$，原子数 $N = 360$。\n  - DFT (PBE)：$E_{\\text{bulk,atom}} = -4.30$ $\\text{eV}$，$E_{\\text{cell}} = -1546.6524$ $\\text{eV}$，$\\sigma_{E_{\\text{cell}}} = 0.015$ $\\text{eV}$，$\\sigma_{E_{\\text{bulk}}} = 0.0001$ $\\text{eV}$。\n  - DFT (SCAN)：$E_{\\text{bulk,atom}} = -4.45$ $\\text{eV}$，$E_{\\text{cell}} = -1600.5024$ $\\text{eV}$，$\\sigma_{E_{\\text{cell}}} = 0.020$ $\\text{eV}$，$\\sigma_{E_{\\text{bulk}}} = 0.0001$ $\\text{eV}$。\n  - EAM：$E_{\\text{bulk,atom}} = -4.44$ $\\text{eV}$，$E_{\\text{cell}} = -1597.2768$ $\\text{eV}$，$\\sigma_{E_{\\text{cell}}} = 0.050$ $\\text{eV}$，$\\sigma_{E_{\\text{bulk}}} = 0.0010$ $\\text{eV}$。\n  - MEAM：$E_{\\text{bulk,atom}} = -4.42$ $\\text{eV}$，$E_{\\text{cell}} = -1589.5524$ $\\text{eV}$，$\\sigma_{E_{\\text{cell}}} = 0.050$ $\\text{eV}$，$\\sigma_{E_{\\text{bulk}}} = 0.0010$ $\\text{eV}$。\n  - 热刻蚀：$\\,\\gamma_s = 1800$ $\\text{mJ/m}^2$，$\\sigma_{\\gamma_s} = 50$ $\\text{mJ/m}^2$，$\\alpha = 179.5$ 度，$\\sigma_{\\alpha} = 0.2$ 度。\n\n- 测试用例 $3$：\n  - 双晶几何结构：面积 $A = 900$ $\\text{\\AA}^2$，原子数 $N = 520$。\n  - DFT (PBE)：$E_{\\text{bulk,atom}} = -4.30$ $\\text{eV}$，$E_{\\text{cell}} = -2232.2956$ $\\text{eV}$，$\\sigma_{E_{\\text{cell}}} = 0.015$ $\\text{eV}$，$\\sigma_{E_{\\text{bulk}}} = 0.0001$ $\\text{eV}$。\n  - DFT (SCAN)：$E_{\\text{bulk,atom}} = -4.45$ $\\text{eV}$，$E_{\\text{cell}} = -2309.9570$ $\\text{eV}$，$\\sigma_{E_{\\text{cell}}} = 0.020$ $\\text{eV}$，$\\sigma_{E_{\\text{bulk}}} = 0.0001$ $\\text{eV}$。\n  - EAM：$E_{\\text{bulk,atom}} = -4.44$ $\\text{eV}$，$E_{\\text{cell}} = -2305.5438$ $\\text{eV}$，$\\sigma_{E_{\\text{cell}}} = 0.050$ $\\text{eV}$，$\\sigma_{E_{\\text{bulk}}} = 0.0010$ $\\text{eV}$。\n  - MEAM：$E_{\\text{bulk,atom}} = -4.42$ $\\text{eV}$，$E_{\\text{cell}} = -2294.9188$ $\\text{eV}$，$\\sigma_{E_{\\text{cell}}} = 0.050$ $\\text{eV}$，$\\sigma_{E_{\\text{bulk}}} = 0.0010$ $\\text{eV}$。\n  - 热刻蚀：$\\,\\gamma_s = 1800$ $\\text{mJ/m}^2$，$\\sigma_{\\gamma_s} = 50$ $\\text{mJ/m}^2$，$\\alpha = 178.0$ 度，$\\sigma_{\\alpha} = 0.1$ 度。\n\n您的程序必须为每个测试用例实现以下计算步骤：\n- 根据双晶总能量和块体参考态计算每种方法的晶界能，确认双晶胞中包含两个相同的晶界。\n- 将所提供的能量不确定度传播到每种方法的晶界能不确定度。\n- 从热刻蚀数据计算晶界能，并传播其相对于表面能和角度的不确定度（角度必须以度为单位处理）。\n- 对所有五个估算值（两种DFT泛函、两种经典势和热刻蚀）执行随机效应模型平均，以得出协调后的平均值和不确定度，该结果同时考虑了方法内方差和方法间离散度。\n- 将所有晶界能和不确定度以 mJ/m$^2$ 表示。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一个包含三个浮点数的子列表，顺序为 [综合平均值, 综合标准差, 热刻蚀能量]，单位均为 mJ/m$^2$。\n- 所有角度均使用度为单位。\n- 将最终输出中的每个浮点数四舍五入到一位小数。\n- 包含三个测试用例的所需输出格式示例：$[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3]]$，其中所有 $x_i, y_i, z_i$ 均为以 mJ/m$^2$ 为单位的浮点数。\n\n所有计算都必须在不读取外部文件且无任何用户输入的情况下执行。程序必须是确定性的和自包含的。",
            "solution": "该问题要求使用多种理论和实验方法计算镍（Ni）中 $\\Sigma 3$ 共格孪晶界的晶界能，然后使用有统计学原则的模型来协调这些估算值。解决方案分为四个部分：基于原子模拟的晶界能推导、基于热刻蚀实验的推导、用于数据协调的统计模型以及必要的单位转换。\n\n将使用以下物理常数和转换因子：\n- 基本电荷, $e = 1.602176634 \\times 10^{-19}$ C。\n- $1$ eV $= 1.602176634 \\times 10^{-19}$ J。\n- $1$ 埃（$\\text{\\AA}$） = $10^{-10}$ m。\n\n### 1. 基于原子模拟的晶界能计算\n\n晶界能 $\\gamma_{gb}$ 定义为界面的单位面积过剩自由能。对于一个横截面积为 $A$、包含 $N$ 个原子和两个相同晶界的周期性双晶超胞，$\\gamma_{gb}$ 的计算方法是从超胞的总能量（$E_{\\text{cell}}$）中减去等量原子在完美块体晶体中的能量（$N E_{\\text{bulk,atom}}$），然后除以两个界面的总面积（$2A$）。\n\n$$ \\gamma_{gb} = \\frac{E_{\\text{cell}} - N E_{\\text{bulk,atom}}}{2A} $$\n\n在这里，$E_{\\text{bulk,atom}}$ 是块体参考态中每个原子的能量。\n\n$\\gamma_{gb}$ 的不确定度通过传播输入能量的不确定度 $\\sigma_{E_{\\text{cell}}}$ 和 $\\sigma_{E_{\\text{bulk,atom}}}$ 来确定。假设这些不确定度是独立的，$\\gamma_{gb}$ 的方差由标准误差传播公式给出：\n\n$$ \\sigma_{\\gamma_{gb}}^2 = \\left(\\frac{\\partial \\gamma_{gb}}{\\partial E_{\\text{cell}}}\\right)^2 \\sigma_{E_{\\text{cell}}}^2 + \\left(\\frac{\\partial \\gamma_{gb}}{\\partial E_{\\text{bulk,atom}}}\\right)^2 \\sigma_{E_{\\text{bulk,atom}}}^2 $$\n\n偏导数是：\n$$ \\frac{\\partial \\gamma_{gb}}{\\partial E_{\\text{cell}}} = \\frac{1}{2A} $$\n$$ \\frac{\\partial \\gamma_{gb}}{\\partial (N E_{\\text{bulk,atom}})} = -\\frac{1}{2A} \\implies \\frac{\\partial \\gamma_{gb}}{\\partial E_{\\text{bulk,atom}}} = -\\frac{N}{2A} $$\n\n将这些代入方差方程：\n$$ \\sigma_{\\gamma_{gb}}^2 = \\left(\\frac{1}{2A}\\right)^2 \\sigma_{E_{\\text{cell}}}^2 + \\left(-\\frac{N}{2A}\\right)^2 \\sigma_{E_{\\text{bulk,atom}}}^2 $$\n$$ \\sigma_{\\gamma_{gb}}^2 = \\frac{\\sigma_{E_{\\text{cell}}}^2 + N^2 \\sigma_{E_{\\text{bulk,atom}}}^2}{4A^2} $$\n\n标准差是方差的平方根：\n$$ \\sigma_{\\gamma_{gb}} = \\frac{\\sqrt{\\sigma_{E_{\\text{cell}}}^2 + N^2 \\sigma_{E_{\\text{bulk,atom}}}^2}}{2A} $$\n\n这些公式将应用于两种密度泛函理论（DFT）泛函（PBE, SCAN）和两种经典原子间势（EAM, MEAM）的数据。\n\n### 2. 基于热刻蚀的晶界能计算\n\n热刻蚀方法将晶界能 $\\gamma_{gb}$ 与表面能 $\\gamma_s$ 以及在晶界与自由表面相交处的凹槽根部的平衡二面角 $\\alpha$ 联系起来。该关系源于三相线处界面张力的平衡，即对称晶界的 Young-Dupré 方程：\n\n$$ \\gamma_{gb} = 2 \\gamma_s \\cos\\left(\\frac{\\alpha}{2}\\right) $$\n\n角度 $\\alpha$ 以度为单位给出，在用于三角函数时必须转换为弧度。\n\n此方法中 $\\gamma_{gb}$ 的不确定度通过传播 $\\gamma_s$ 和 $\\alpha$ 的不确定度 $\\sigma_{\\gamma_s}$ 和 $\\sigma_{\\alpha}$ 来找到。假设它们是独立的，方差 $\\sigma_{\\gamma_{gb}}^2$ 为：\n\n$$ \\sigma_{\\gamma_{gb}}^2 = \\left(\\frac{\\partial \\gamma_{gb}}{\\partial \\gamma_s}\\right)^2 \\sigma_{\\gamma_s}^2 + \\left(\\frac{\\partial \\gamma_{gb}}{\\partial \\alpha}\\right)^2 \\sigma_{\\alpha}^2 $$\n\n偏导数是：\n$$ \\frac{\\partial \\gamma_{gb}}{\\partial \\gamma_s} = 2 \\cos\\left(\\frac{\\alpha}{2}\\right) $$\n$$ \\frac{\\partial \\gamma_{gb}}{\\partial \\alpha} = 2 \\gamma_s \\left(-\\sin\\left(\\frac{\\alpha}{2}\\right) \\cdot \\frac{1}{2}\\right) = -\\gamma_s \\sin\\left(\\frac{\\alpha}{2}\\right) $$\n\n对于关于 $\\alpha$ 的导数，角度及其不确定度必须是弧度。设 $\\alpha_{rad}$ 和 $\\sigma_{\\alpha,rad}$ 分别为以弧度表示的角度及其不确定度。转换关系为 $\\sigma_{\\alpha,rad} = \\sigma_{\\alpha,deg} \\cdot \\frac{\\pi}{180}$。因此，方差为：\n\n$$ \\sigma_{\\gamma_{gb}}^2 = \\left[2 \\cos\\left(\\frac{\\alpha_{rad}}{2}\\right)\\right]^2 \\sigma_{\\gamma_s}^2 + \\left[-\\gamma_s \\sin\\left(\\frac{\\alpha_{rad}}{2}\\right)\\right]^2 \\sigma_{\\alpha,rad}^2 $$\n\n### 3. 通过随机效应模型进行统计协调\n\n我们有 $k=5$ 个 $\\gamma_{gb}$ 的估算值，记为 $y_i$，每个值都有相应的方差 $v_i = \\sigma_i^2$，其中 $i=1, \\dots, k$。这些估算值来自不同的物理模型和一项实验，因此除了每个估算值内部的统计不确定性外，预计它们之间还存在系统性差异（异质性）。随机效应荟萃分析模型适合合并这些结果。该模型假设每项研究估计的真实值 $\\mu_i$ 略有不同，其中 $\\mu_i$ 来自一个均值为 $\\mu$、方差为 $\\tau^2$ 的共同分布。参数 $\\tau^2$ 代表方法间方差（或离散度）。\n\n程序如下：\n1.  **估计方法间方差（$\\tau^2$）**：使用 DerSimonian-Laird 方法。首先，我们计算 Cochran's $Q$ 统计量，它衡量总加权变异：\n    $$ Q = \\sum_{i=1}^{k} w_i^{FE}(y_i - \\hat{\\mu}_{FE})^2 $$\n    其中 $w_i^{FE} = 1/v_i$ 是固定效应权重，$\\hat{\\mu}_{FE} = \\frac{\\sum w_i^{FE}y_i}{\\sum w_i^{FE}}$ 是固定效应平均值。\n    $\\tau^2$ 的估计量为：\n    $$ \\hat{\\tau}^2 = \\max\\left(0, \\frac{Q - (k-1)}{C}\\right) \\quad \\text{其中} \\quad C = \\sum w_i^{FE} - \\frac{\\sum (w_i^{FE})^2}{\\sum w_i^{FE}} $$\n\n2.  **计算综合平均值和不确定度**：计算新的权重（随机效应权重），其中包含方法内方差（$v_i$）和方法间方差（$\\hat{\\tau}^2$）：\n    $$ w_i^{RE} = \\frac{1}{v_i + \\hat{\\tau}^2} $$\n    综合平均值（随机效应平均值）是使用这些新权重的加权平均值：\n    $$ \\hat{\\mu}_{RE} = \\frac{\\sum_{i=1}^{k} w_i^{RE} y_i}{\\sum_{i=1}^{k} w_i^{RE}} $$\n    该综合平均值的方差为：\n    $$ v_{\\hat{\\mu}_{RE}} = \\frac{1}{\\sum_{i=1}^{k} w_i^{RE}} $$\n    综合标准差为 $\\sigma_{\\hat{\\mu}_{RE}} = \\sqrt{v_{\\hat{\\mu}_{RE}}}$。值 $\\hat{\\mu}_{RE}$ 和 $\\sigma_{\\hat{\\mu}_{RE}}$ 是最终协调后的估算值及其不确定度。\n\n### 4. 单位转换\n\n原子模拟计算得出的 $\\gamma_{gb}$ 单位是 eV/$\\text{\\AA}^2$。最终结果必须以毫焦耳/平方米（mJ/m$^2$）为单位。转换因子推导如下：\n$$ 1 \\frac{\\text{eV}}{\\text{\\AA}^2} = \\frac{1.602176634 \\times 10^{-19} \\text{ J}}{(10^{-10} \\text{ m})^2} = \\frac{1.602176634 \\times 10^{-19} \\text{ J}}{10^{-20} \\text{ m}^2} = 16.02176634 \\frac{\\text{J}}{\\text{m}^2} $$\n要将 J/m$^2$ 转换为 mJ/m$^2$，我们乘以 $1000$：\n$$ 1 \\frac{\\text{eV}}{\\text{\\AA}^2} = 16021.76634 \\frac{\\text{mJ}}{\\text{m}^2} $$\n此转换因子应用于从原子模拟中获得的晶界能值及其标准差。热刻蚀计算使用单位为 mJ/m$^2$ 的 $\\gamma_s$，因此其结果已经处于正确的最终单位。在传递给随机效应模型之前，所有五个估算值的单位都是 mJ/m$^2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the grain boundary energy problem for all test cases.\n    \"\"\"\n    \n    # Fundamental constants and conversion factors\n    EV_PER_A2_TO_MJ_PER_M2 = 16021.76634\n\n    # Test cases as provided in the problem description\n    test_cases = [\n        # Test case 1\n        {\n            \"geometry\": {\"A\": 800.0, \"N\": 480},\n            \"methods\": {\n                \"PBE\": {\"E_bulk_atom\": -4.30, \"E_cell\": -2060.8064, \"sigma_E_cell\": 0.015, \"sigma_E_bulk\": 0.0001},\n                \"SCAN\": {\"E_bulk_atom\": -4.45, \"E_cell\": -2132.5072, \"sigma_E_cell\": 0.020, \"sigma_E_bulk\": 0.0001},\n                \"EAM\": {\"E_bulk_atom\": -4.44, \"E_cell\": -2128.4080, \"sigma_E_cell\": 0.050, \"sigma_E_bulk\": 0.0010},\n                \"MEAM\": {\"E_bulk_atom\": -4.42, \"E_cell\": -2118.3072, \"sigma_E_cell\": 0.050, \"sigma_E_bulk\": 0.0010},\n            },\n            \"grooving\": {\"gamma_s\": 1800.0, \"sigma_gamma_s\": 50.0, \"alpha_deg\": 178.9, \"sigma_alpha_deg\": 0.1},\n        },\n        # Test case 2\n        {\n            \"geometry\": {\"A\": 600.0, \"N\": 360},\n            \"methods\": {\n                \"PBE\": {\"E_bulk_atom\": -4.30, \"E_cell\": -1546.6524, \"sigma_E_cell\": 0.015, \"sigma_E_bulk\": 0.0001},\n                \"SCAN\": {\"E_bulk_atom\": -4.45, \"E_cell\": -1600.5024, \"sigma_E_cell\": 0.020, \"sigma_E_bulk\": 0.0001},\n                \"EAM\": {\"E_bulk_atom\": -4.44, \"E_cell\": -1597.2768, \"sigma_E_cell\": 0.050, \"sigma_E_bulk\": 0.0010},\n                \"MEAM\": {\"E_bulk_atom\": -4.42, \"E_cell\": -1589.5524, \"sigma_E_cell\": 0.050, \"sigma_E_bulk\": 0.0010},\n            },\n            \"grooving\": {\"gamma_s\": 1800.0, \"sigma_gamma_s\": 50.0, \"alpha_deg\": 179.5, \"sigma_alpha_deg\": 0.2},\n        },\n        # Test case 3\n        {\n            \"geometry\": {\"A\": 900.0, \"N\": 520},\n            \"methods\": {\n                \"PBE\": {\"E_bulk_atom\": -4.30, \"E_cell\": -2232.2956, \"sigma_E_cell\": 0.015, \"sigma_E_bulk\": 0.0001},\n                \"SCAN\": {\"E_bulk_atom\": -4.45, \"E_cell\": -2309.9570, \"sigma_E_cell\": 0.020, \"sigma_E_bulk\": 0.0001},\n                \"EAM\": {\"E_bulk_atom\": -4.44, \"E_cell\": -2305.5438, \"sigma_E_cell\": 0.050, \"sigma_E_bulk\": 0.0010},\n                \"MEAM\": {\"E_bulk_atom\": -4.42, \"E_cell\": -2294.9188, \"sigma_E_cell\": 0.050, \"sigma_E_bulk\": 0.0010},\n            },\n            \"grooving\": {\"gamma_s\": 1800.0, \"sigma_gamma_s\": 50.0, \"alpha_deg\": 178.0, \"sigma_alpha_deg\": 0.1},\n        },\n    ]\n    \n    all_results = []\n\n    for case in test_cases:\n        estimates = []\n        uncertainties = []\n\n        # Part 1: Atomistic calculations\n        A = case[\"geometry\"][\"A\"]\n        N = case[\"geometry\"][\"N\"]\n        \n        for method_name, params in case[\"methods\"].items():\n            E_cell = params[\"E_cell\"]\n            E_bulk_atom = params[\"E_bulk_atom\"]\n            sigma_E_cell = params[\"sigma_E_cell\"]\n            sigma_E_bulk = params[\"sigma_E_bulk\"]\n\n            # Calculate gamma_gb in eV/A^2\n            gamma_gb_raw = (E_cell - N * E_bulk_atom) / (2 * A)\n            \n            # Propagate uncertainty for gamma_gb in eV/A^2\n            sigma_gamma_gb_raw = np.sqrt(sigma_E_cell**2 + (N * sigma_E_bulk)**2) / (2 * A)\n            \n            # Convert to mJ/m^2\n            estimates.append(gamma_gb_raw * EV_PER_A2_TO_MJ_PER_M2)\n            uncertainties.append(sigma_gamma_gb_raw * EV_PER_A2_TO_MJ_PER_M2)\n\n        # Part 2: Thermal grooving calculation\n        g = case[\"grooving\"]\n        gamma_s, sigma_gamma_s = g[\"gamma_s\"], g[\"sigma_gamma_s\"]\n        alpha_deg, sigma_alpha_deg = g[\"alpha_deg\"], g[\"sigma_alpha_deg\"]\n        \n        alpha_rad = np.deg2rad(alpha_deg)\n        sigma_alpha_rad = np.deg2rad(sigma_alpha_deg)\n        \n        # Calculate gamma_gb\n        gamma_gb_tg = 2 * gamma_s * np.cos(alpha_rad / 2)\n        \n        # Propagate uncertainty\n        d_gamma_s = 2 * np.cos(alpha_rad / 2)\n        d_alpha = -gamma_s * np.sin(alpha_rad / 2)\n        sigma_gamma_gb_tg = np.sqrt((d_gamma_s * sigma_gamma_s)**2 + (d_alpha * sigma_alpha_rad)**2)\n        \n        estimates.append(gamma_gb_tg)\n        uncertainties.append(sigma_gamma_gb_tg)\n        \n        # Part 3: Random-effects model averaging\n        y = np.array(estimates)\n        sigma = np.array(uncertainties)\n        v = sigma**2\n        k = len(y)\n        \n        # Fixed-effect calculations\n        w_fe = 1 / v\n        mu_fe = np.sum(w_fe * y) / np.sum(w_fe)\n        \n        # Cochran's Q and tau^2\n        q_stat = np.sum(w_fe * (y - mu_fe)**2)\n        \n        c_denom = np.sum(w_fe)\n        c_val = c_denom - (np.sum(w_fe**2) / c_denom)\n\n        if c_val > 0:\n            tau2 = max(0, (q_stat - (k - 1)) / c_val)\n        else:\n            tau2 = 0\n\n        # Random-effects calculations\n        w_re = 1 / (v + tau2)\n        mu_re = np.sum(w_re * y) / np.sum(w_re)\n        v_mu_re = 1 / np.sum(w_re)\n        sigma_mu_re = np.sqrt(v_mu_re)\n        \n        all_results.append([mu_re, sigma_mu_re, gamma_gb_tg])\n\n    # Final print statement in the exact required format.\n    output_str = \",\".join(f\"[{v[0]:.1f},{v[1]:.1f},{v[2]:.1f}]\" for v in all_results)\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "多晶材料的性质取决于大量不同类型晶界的能量。使用像DFT这样的高精度方法来计算所有这些晶界的能量在计算上是不可行的。我们可以通过将一个灵活的函数拟合到一个小的、但具有代表性的覆盖晶界特征5维空间的DFT数据集上来构建一个计算成本低廉的“代理模型”。这个过程的一个关键部分是需要知道模型在何时是可信的，以及何时它在未知领域进行外推。本练习将引导你基于5自由度参数校准一个简单的晶界能代理模型，然后，你将使用马氏距离（Mahalanobis distance）来为新的、未见过的晶界构型建立一个定量的外推风险度量。",
            "id": "3455300",
            "problem": "您将执行一个校准任务，该任务针对一个预测晶界能的代理原子间势模型。晶界由五个自由度表征。这五个自由度以弧度为单位的角度编码：包括取向差角和晶界平面取向。该模型使用基于角度三角函数的线性参数基来预测晶界能。所有能量单位为 $\\mathrm{J}/\\mathrm{m}^2$，所有角度单位为弧度。需要最小化的损失函数是模型预测能量与密度泛函理论（DFT）计算能量之间差值的加权平方和。您的目标是完全通过代码实现以下内容，并解决指定的测试套件。\n\n基本设置：一个晶界构型由一个五元角度元组 $(\\phi_k,\\psi_k,\\omega_k,\\alpha_k,\\beta_k)$ 参数化，所有角度均以弧度为单位。为每个构型 $k$ 定义一个维度为 $5$ 的特征向量，如下所示：\n$$\n\\mathbf{f}_k = \\begin{bmatrix}\n1 \\\\\n\\cos(\\omega_k) \\\\\n\\sin(\\omega_k)\\cos(\\phi_k) \\\\\n\\cos(\\alpha_k - \\phi_k) \\\\\n\\cos(\\beta_k - \\psi_k)\n\\end{bmatrix}.\n$$\n设模型能量为\n$$\n\\gamma_k^{\\mathrm{model}} = \\mathbf{f}_k^\\top \\mathbf{a},\n$$\n其中 $\\mathbf{a}\\in\\mathbb{R}^5$ 是待校准的参数矢量。DFT能量 $\\gamma_k^{\\mathrm{DFT}}$ 和权重 $w_k$ 是给定的。要最小化的加权损失为\n$$\nL(\\mathbf{a}) = \\sum_{k=1}^{K} w_k\\left(\\gamma_k^{\\mathrm{model}} - \\gamma_k^{\\mathrm{DFT}}\\right)^2,\n$$\n其中 $K$ 是训练点的数量。可选地，可以引入一个 Tikhonov 正则化参数 $\\lambda \\ge 0$，通过在损失函数中增加 $\\lambda\\|\\mathbf{a}\\|_2^2$ 项来稳定校准过程。\n\n外推评估：校准 $\\mathbf{a}$ 后，使用特征空间中的加权训练特征分布，通过 Mahalanobis 距离来量化查询构型的外推风险。计算加权平均值\n$$\n\\boldsymbol{\\mu} = \\left(\\sum_{k=1}^{K} w_k\\right)^{-1}\\sum_{k=1}^{K}w_k\\,\\mathbf{f}_k,\n$$\n和加权协方差\n$$\n\\mathbf{S} = \\left(\\sum_{k=1}^{K} w_k\\right)^{-1}\\sum_{k=1}^{K}w_k\\,(\\mathbf{f}_k - \\boldsymbol{\\mu})(\\mathbf{f}_k - \\boldsymbol{\\mu})^\\top,\n$$\n为保证数值稳定性，需要时应对其进行正则化。对于一个查询特征 $\\mathbf{f}$，定义 Mahalanobis 距离为\n$$\nd_M(\\mathbf{f}) = \\sqrt{(\\mathbf{f} - \\boldsymbol{\\mu})^\\top \\mathbf{S}^{-1} (\\mathbf{f} - \\boldsymbol{\\mu})}.\n$$\n给定一个阈值 $\\tau > 0$，如果 $d_M(\\mathbf{f}) > \\tau$，则将外推分类为真，否则为假。\n\n训练数据集：使用下面列出的 $K=10$ 个训练晶界，包括其角度元组 $(\\phi_k,\\psi_k,\\omega_k,\\alpha_k,\\beta_k)$、权重 $w_k$ 和 DFT 能量 $\\gamma_k^{\\mathrm{DFT}}$。每个角度都以弧度为单位，表示为 $\\pi$ 的简单有理数倍，每个能量单位为 $\\mathrm{J}/\\mathrm{m}^2$。\n\n- $k=1$：$(\\phi_1,\\psi_1,\\omega_1,\\alpha_1,\\beta_1) = \\left(0,\\frac{\\pi}{6},\\frac{\\pi}{3},\\frac{\\pi}{4},\\frac{\\pi}{2}\\right)$，$w_1 = 1.0$，$\\gamma_1^{\\mathrm{DFT}} = 0.747785391$。\n- $k=2$：$(\\phi_2,\\psi_2,\\omega_2,\\alpha_2,\\beta_2) = \\left(\\frac{\\pi}{6},\\frac{\\pi}{3},\\frac{\\pi}{2},\\frac{\\pi}{3},\\frac{\\pi}{6}\\right)$，$w_2 = 2.0$，$\\gamma_2^{\\mathrm{DFT}} = 0.700000000$。\n- $k=3$：$(\\phi_3,\\psi_3,\\omega_3,\\alpha_3,\\beta_3) = \\left(\\frac{\\pi}{4},\\frac{\\pi}{4},\\frac{\\pi}{4},\\frac{\\pi}{2},\\frac{\\pi}{4}\\right)$，$w_3 = 1.5$，$\\gamma_3^{\\mathrm{DFT}} = 0.773137085$。\n- $k=4$：$(\\phi_4,\\psi_4,\\omega_4,\\alpha_4,\\beta_4) = \\left(\\frac{\\pi}{3},\\frac{\\pi}{2},\\frac{\\pi}{6},0,\\frac{2\\pi}{3}\\right)$，$w_4 = 1.0$，$\\gamma_4^{\\mathrm{DFT}} = 0.789282032$。\n- $k=5$：$(\\phi_5,\\psi_5,\\omega_5,\\alpha_5,\\beta_5) = \\left(0,\\frac{\\pi}{2},\\frac{2\\pi}{3},\\frac{5\\pi}{6},\\frac{\\pi}{3}\\right)$，$w_5 = 0.7$，$\\gamma_5^{\\mathrm{DFT}} = 0.546076952$。\n- $k=6$：$(\\phi_6,\\psi_6,\\omega_6,\\alpha_6,\\beta_6) = \\left(\\frac{\\pi}{2},0,\\pi,\\frac{\\pi}{2},\\pi\\right)$，$w_6 = 2.0$，$\\gamma_6^{\\mathrm{DFT}} = 0.680000000$。\n- $k=7$：$(\\phi_7,\\psi_7,\\omega_7,\\alpha_7,\\beta_7) = \\left(\\frac{3\\pi}{4},\\frac{\\pi}{4},\\frac{\\pi}{3},\\frac{\\pi}{3},\\frac{\\pi}{4}\\right)$，$w_7 = 1.2$，$\\gamma_7^{\\mathrm{DFT}} = 0.770024040$。\n- $k=8$：$(\\phi_8,\\psi_8,\\omega_8,\\alpha_8,\\beta_8) = \\left(\\frac{\\pi}{6},\\frac{5\\pi}{6},\\frac{\\pi}{6},\\frac{\\pi}{6},\\frac{5\\pi}{6}\\right)$，$w_8 = 1.0$，$\\gamma_8^{\\mathrm{DFT}} = 0.809282032$。\n- $k=9$：$(\\phi_9,\\psi_9,\\omega_9,\\alpha_9,\\beta_9) = \\left(\\frac{\\pi}{2},\\frac{\\pi}{2},\\frac{\\pi}{4},\\frac{\\pi}{2},\\frac{\\pi}{2}\\right)$，$w_9 = 0.8$，$\\gamma_9^{\\mathrm{DFT}} = 0.810710678$。\n- $k=10$：$(\\phi_{10},\\psi_{10},\\omega_{10},\\alpha_{10},\\beta_{10}) = \\left(\\frac{\\pi}{3},\\frac{2\\pi}{3},\\frac{5\\pi}{6},\\frac{\\pi}{2},\\frac{\\pi}{6}\\right)$，$w_{10} = 1.3$，$\\gamma_{10}^{\\mathrm{DFT}} = 0.655358984$。\n\n校准和外推任务：实现加权岭回归，通过最小化 $L(\\mathbf{a}) + \\lambda\\|\\mathbf{a}\\|_2^2$ 来估计 $\\mathbf{a}$，其中 $\\lambda$ 由每个测试用例指定。然后计算训练损失 $L(\\hat{\\mathbf{a}})$，其中 $\\hat{\\mathbf{a}}$ 是最小化向量。使用训练特征计算 $\\boldsymbol{\\mu}$ 和 $\\mathbf{S}$，如果需要，通过添加一个小的对角项来正则化 $\\mathbf{S}$ 以确保其可逆性。对于每个查询构型，计算其特征向量、Mahalanobis 距离 $d_M$ 以及相对于阈值 $\\tau$ 的外推标志。\n\n测试套件：需要执行两个测试用例。\n\n- 测试用例 1：\n  - 正则化 $\\lambda = 0.0$。\n  - 阈值 $\\tau = 2.0$。\n  - 查询：\n    - $Q_{1}$：$(\\phi,\\psi,\\omega,\\alpha,\\beta) = \\left(\\frac{\\pi}{4},\\frac{\\pi}{4},\\frac{\\pi}{3},\\frac{\\pi}{6},\\frac{\\pi}{6}\\right)$。\n    - $Q_{2}$：$(\\phi,\\psi,\\omega,\\alpha,\\beta) = \\left(0,0,0,\\pi,\\pi\\right)$。\n- 测试用例 2：\n  - 正则化 $\\lambda = 0.000001$。\n  - 阈值 $\\tau = 1.0$。\n  - 查询：\n    - $Q_{3}$：$(\\phi,\\psi,\\omega,\\alpha,\\beta) = \\left(\\frac{\\pi}{2},\\frac{\\pi}{2},\\frac{\\pi}{2},\\frac{\\pi}{2},\\frac{\\pi}{2}\\right)$。\n    - $Q_{4}$：$(\\phi,\\psi,\\omega,\\alpha,\\beta) = \\left(\\pi,\\pi,\\pi,0,0\\right)$。\n\n输出规格：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。该列表必须是\n$$\n\\left[ L_1, d_{M}(Q_1), \\mathrm{flag}(Q_1), d_{M}(Q_2), \\mathrm{flag}(Q_2), L_2, d_{M}(Q_3), \\mathrm{flag}(Q_3), d_{M}(Q_4), \\mathrm{flag}(Q_4) \\right],\n$$\n其中 $L_1$ 和 $L_2$ 是训练损失，单位为 $(\\mathrm{J}/\\mathrm{m}^2)^2$，每个都是四舍五入到六位小数的浮点数；$d_M(\\cdot)$ 是 Mahalanobis 距离，每个都是四舍五入到六位小数的浮点数；$\\mathrm{flag}(\\cdot)$ 是根据相应测试用例的 $d_M(\\cdot)\\tau$ 计算出的布尔值。例如，输出格式必须如下所示：$[0.123456,1.234567,True,2.345678,False,0.234567,1.111111,False,3.222222,True]$。",
            "solution": "该问题要求实现一个计算工作流，用于校准晶界能的代理模型，并随后评估该模型对新构型的外推风险。该过程包含两个主要部分：首先，使用加权岭回归进行参数拟合；其次，在特征空间中计算 Mahalanobis 距离以量化外推。\n\n该问题被确定为有效，因为它在科学上基于计算材料科学和机器学习的标准实践，在数学上是适定的，并提供了一套完整且一致的数据和指令。\n\n问题的核心在于线性代数和统计分析。我们将逐步将此过程形式化。\n\n一个晶界由一组五个角度 $(\\phi_k, \\psi_k, \\omega_k, \\alpha_k, \\beta_k)$ 定义。对于每个构型 $k$，我们构建一个 $5$ 维特征向量 $\\mathbf{f}_k$：\n$$\n\\mathbf{f}_k = \\begin{bmatrix}\n1 \\\\\n\\cos(\\omega_k) \\\\\n\\sin(\\omega_k)\\cos(\\phi_k) \\\\\n\\cos(\\alpha_k - \\phi_k) \\\\\n\\cos(\\beta_k - \\psi_k)\n\\end{bmatrix}\n$$\n晶界能模型 $\\gamma_k^{\\mathrm{model}}$ 对参数矢量 $\\mathbf{a} \\in \\mathbb{R}^5$ 是线性的：\n$$\n\\gamma_k^{\\mathrm{model}} = \\mathbf{f}_k^\\top \\mathbf{a} = \\sum_{j=1}^{5} f_{kj} a_j\n$$\n\n第一个任务是通过最小化一个加权和正则化的损失函数来找到最优参数矢量 $\\hat{\\mathbf{a}}$。损失函数是模型预测值 $\\gamma_k^{\\mathrm{model}}$ 与参考的密度泛函理论（DFT）能量 $\\gamma_k^{\\mathrm{DFT}}$ 之间差值的加权平方和，并增加了一个 Tikhonov 正则化项：\n$$\nL_{reg}(\\mathbf{a}) = \\sum_{k=1}^{K} w_k \\left( \\gamma_k^{\\mathrm{model}} - \\gamma_k^{\\mathrm{DFT}} \\right)^2 + \\lambda \\|\\mathbf{a}\\|_2^2\n$$\n其中 $K=10$ 是训练点的数量，$\\lambda \\ge 0$ 是正则化参数。\n\n为解决这个最小化问题，我们将其表示为矩阵形式。设 $F$ 为 $K \\times 5$ 的设计矩阵，其中每一行是一个特征向量 $\\mathbf{f}_k^\\top$。设 $\\mathbf{y}$ 为包含 DFT 能量 $\\gamma_k^{\\mathrm{DFT}}$ 的 $K \\times 1$ 列向量。设 $W$ 为 $K \\times K$ 的对角矩阵，其对角线上的元素为权重 $w_k$。损失函数变为：\n$$\nL_{reg}(\\mathbf{a}) = (\\mathbf{y} - F\\mathbf{a})^\\top W (\\mathbf{y} - F\\mathbf{a}) + \\lambda \\mathbf{a}^\\top \\mathbf{a}\n$$\n这是关于 $\\mathbf{a}$ 的一个二次函数。为了找到最小值，我们对 $\\mathbf{a}$ 求梯度并令其为零：\n$$\n\\nabla_{\\mathbf{a}} L_{reg}(\\mathbf{a}) = -2 F^\\top W (\\mathbf{y} - F\\mathbf{a}) + 2 \\lambda \\mathbf{a} = 0\n$$\n整理各项，我们得到关于最优参数矢量 $\\hat{\\mathbf{a}}$ 的一个线性方程组：\n$$\n(F^\\top W F + \\lambda I) \\hat{\\mathbf{a}} = F^\\top W \\mathbf{y}\n$$\n其中 $I$ 是 $5 \\times 5$ 的单位矩阵。解为：\n$$\n\\hat{\\mathbf{a}} = (F^\\top W F + \\lambda I)^{-1} F^\\top W \\mathbf{y}\n$$\n该系统可以使用标准线性代数库高效求解。如果 $\\lambda > 0$，矩阵 $(F^\\top W F + \\lambda I)$ 保证是可逆的，因为 $F^\\top W F$ 是半正定的。对于 $\\lambda = 0$ 的情况，可逆性要求 $F$ 的列是线性无关的。\n\n一旦确定了 $\\hat{\\mathbf{a}}$，就可以使用未正则化的损失公式计算训练损失 $L(\\hat{\\mathbf{a}})$：\n$$\nL(\\hat{\\mathbf{a}}) = \\sum_{k=1}^{K} w_k \\left( \\mathbf{f}_k^\\top \\hat{\\mathbf{a}} - \\gamma_k^{\\mathrm{DFT}} \\right)^2 = (\\mathbf{y} - F\\hat{\\mathbf{a}})^\\top W (\\mathbf{y} - F\\hat{\\mathbf{a}})\n$$\n\n问题的第二部分是使用 Mahalanobis 距离评估外推风险。这需要对特征空间中训练数据的分布进行表征。我们计算训练特征向量 $\\mathbf{f}_k$ 的加权均值向量 $\\boldsymbol{\\mu}$ 和加权协方差矩阵 $\\mathbf{S}$：\n$$\nW_{sum} = \\sum_{k=1}^{K} w_k\n$$\n$$\n\\boldsymbol{\\mu} = \\frac{1}{W_{sum}} \\sum_{k=1}^{K} w_k \\mathbf{f}_k\n$$\n$$\n\\mathbf{S} = \\frac{1}{W_{sum}} \\sum_{k=1}^{K} w_k (\\mathbf{f}_k - \\boldsymbol{\\mu})(\\mathbf{f}_k - \\boldsymbol{\\mu})^\\top\n$$\n协方差矩阵 $\\mathbf{S}$ 描述了 $5$ 维特征空间中训练数据云的形状和方向。为确保求逆过程中的数值稳定性，可以通过添加一个小的单位矩阵倍数 $\\epsilon I$ 来对 $\\mathbf{S}$ 进行正则化。\n\n对于一个具有特征向量 $\\mathbf{f}_{query}$ 的新查询构型，其到训练数据分布中心的 Mahalanobis 距离 $d_M$ 为：\n$$\nd_M(\\mathbf{f}_{query}) = \\sqrt{(\\mathbf{f}_{query} - \\boldsymbol{\\mu})^\\top \\mathbf{S}^{-1} (\\mathbf{f}_{query} - \\boldsymbol{\\mu})}\n$$\n这个距离衡量了查询点在考虑协方差结构的情况下，距离训练数据均值有多少个标准差。较大的 $d_M$ 表明查询点位于特征空间中训练数据采样稀疏的区域，意味着存在较高的外推风险。如果 $d_M$ 超过给定的阈值 $\\tau$，则该查询被标记为外推。\n\n实现将按以下步骤进行：\n1.  定义训练数据（角度、能量、权重）。\n2.  对于每个测试用例（由 $\\lambda$ 和 $\\tau$ 定义）：\n    a. 构建设计矩阵 $F$、目标向量 $\\mathbf{y}$ 和权重向量（为高效计算，替代矩阵 $W$）。\n    b. 求解加权岭回归系统以得到 $\\hat{\\mathbf{a}}$。\n    c. 计算训练损失 $L(\\hat{\\mathbf{a}})$。\n    d. 计算训练特征的加权均值 $\\boldsymbol{\\mu}$ 和加权协方差矩阵 $\\mathbf{S}$。对 $\\mathbf{S}$ 进行正则化和求逆以得到 $\\mathbf{S}^{-1}$。注意，$\\boldsymbol{\\mu}$ 和 $\\mathbf{S}$ 与 $\\lambda$ 无关，因此只需计算一次。\n    e. 对于测试用例中的每个查询构型：\n        i. 计算其特征向量 $\\mathbf{f}_{query}$。\n        ii. 计算 Mahalanobis 距离 $d_M(\\mathbf{f}_{query})$。\n        iii. 将 $d_M$ 与 $\\tau$ 比较以设置布尔外推标志。\n3.  收集所有结果并按照问题陈述中的规定进行格式化。\n所有计算将使用 `numpy` 库进行数值和线性代数运算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the grain boundary energy model calibration and extrapolation assessment problem.\n    \"\"\"\n    pi = np.pi\n    \n    # Training dataset (K=10)\n    # Each entry: (phi, psi, omega, alpha, beta), weight, dft_energy\n    training_data = [\n        ((0, pi/6, pi/3, pi/4, pi/2), 1.0, 0.747785391),\n        ((pi/6, pi/3, pi/2, pi/3, pi/6), 2.0, 0.700000000),\n        ((pi/4, pi/4, pi/4, pi/2, pi/4), 1.5, 0.773137085),\n        ((pi/3, pi/2, pi/6, 0, 2*pi/3), 1.0, 0.789282032),\n        ((0, pi/2, 2*pi/3, 5*pi/6, pi/3), 0.7, 0.546076952),\n        ((pi/2, 0, pi, pi/2, pi), 2.0, 0.680000000),\n        ((3*pi/4, pi/4, pi/3, pi/3, pi/4), 1.2, 0.770024040),\n        ((pi/6, 5*pi/6, pi/6, pi/6, 5*pi/6), 1.0, 0.809282032),\n        ((pi/2, pi/2, pi/4, pi/2, pi/2), 0.8, 0.810710678),\n        ((pi/3, 2*pi/3, 5*pi/6, pi/2, pi/6), 1.3, 0.655358984),\n    ]\n\n    # Test suite\n    test_cases = [\n        {\n            \"lambda\": 0.0,\n            \"tau\": 2.0,\n            \"queries\": [\n                (pi/4, pi/4, pi/3, pi/6, pi/6),\n                (0, 0, 0, pi, pi)\n            ]\n        },\n        {\n            \"lambda\": 0.000001,\n            \"tau\": 1.0,\n            \"queries\": [\n                (pi/2, pi/2, pi/2, pi/2, pi/2),\n                (pi, pi, pi, 0, 0)\n            ]\n        }\n    ]\n\n    def get_feature_vector(angles):\n        \"\"\"Computes the feature vector for a given set of angles.\"\"\"\n        phi, psi, omega, alpha, beta = angles\n        return np.array([\n            1,\n            np.cos(omega),\n            np.sin(omega) * np.cos(phi),\n            np.cos(alpha - phi),\n            np.cos(beta - psi)\n        ])\n\n    # Prepare training data matrices\n    angles_train = [d[0] for d in training_data]\n    weights_train = np.array([d[1] for d in training_data])\n    y_train = np.array([d[2] for d in training_data])\n    \n    F_train = np.array([get_feature_vector(angs) for angs in angles_train])\n    \n    # --- Pre-calculate stats for Mahalanobis distance (independent of test cases) ---\n    \n    # Weighted mean feature vector mu\n    W_sum = np.sum(weights_train)\n    mu = np.sum(weights_train[:, np.newaxis] * F_train, axis=0) / W_sum\n    \n    # Weighted covariance matrix S\n    F_centered = F_train - mu\n    S = (F_centered.T @ (weights_train[:, np.newaxis] * F_centered)) / W_sum\n    \n    # Regularize and invert S\n    S_reg = S + 1e-10 * np.identity(S.shape[0])\n    try:\n        S_inv = np.linalg.inv(S_reg)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudoinverse if still singular, though regularization should prevent this.\n        S_inv = np.linalg.pinv(S_reg)\n\n    all_results = []\n    \n    for case in test_cases:\n        lambda_reg = case[\"lambda\"]\n        tau = case[\"tau\"]\n        \n        # --- 1. Weighted Ridge Regression ---\n        F_T_W = F_train.T * weights_train # Efficient F.T @ diag(W)\n        A = F_T_W @ F_train + lambda_reg * np.identity(F_train.shape[1])\n        b = F_T_W @ y_train\n        \n        a_hat = np.linalg.solve(A, b)\n        \n        # --- 2. Training Loss Calculation ---\n        y_pred = F_train @ a_hat\n        errors = y_train - y_pred\n        loss = np.sum(weights_train * (errors ** 2))\n        all_results.append(round(loss, 6))\n\n        # --- 3. Extrapolation Assessment for Queries ---\n        for query_angles in case[\"queries\"]:\n            f_query = get_feature_vector(query_angles)\n            f_centered_query = f_query - mu\n            \n            # Mahalanobis distance\n            dM_sq = f_centered_query.T @ S_inv @ f_centered_query\n            dM = np.sqrt(dM_sq)\n            \n            # Extrapolation flag\n            extrap_flag = dM > tau\n            \n            all_results.append(round(dM, 6))\n            all_results.append(extrap_flag)\n            \n    # Format and print the final output\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}