{
    "hands_on_practices": [
        {
            "introduction": "在晶体塑性有限元模型中，精确追踪晶格的旋转是保证运动学一致性的核心。本练习从有限变形理论的乘法分解出发，要求您推导并实现一个能够正确更新晶格旋转的数值方案。通过这个实践，您将掌握如何利用李群和李代数理论，确保旋转矩阵在整个变形过程中始终保持其正交性，这是建立一个稳定且物理真实的模型的关键一步。",
            "id": "3441906",
            "problem": "您需要在一个晶体塑性有限元方法（CPFEM; Crystal Plasticity Finite Element Method）的背景下，推导、实现并测试一个晶格旋转更新方案。从乘法运动学和经典的时间率定义开始，演示反对称晶格自旋是如何产生的。然后构建一个离散积分程序，用于更新晶格旋转，同时保证更新后的旋转矩阵仍在特殊正交群（SO(3); Special Orthogonal Group of degree three）中。\n\n推导任务：\n- 从运动学乘法分解 $F = F^{e} F^{p}$ 开始，其中 $F$ 是变形梯度，$F^{e}$ 是弹性变形梯度，$F^{p}$ 是塑性变形梯度。\n- 使用材料时间导数 $\\,\\dot{(\\cdot)}\\,$ 定义弹性速度梯度 $L^{e} = \\dot{F}^{e} (F^{e})^{-1}$。\n- 引入极分解 $F^{e} = R^{e} U^{e}$，其中 $R^{e} \\in \\mathrm{SO}(3)$ 是晶格旋转，$U^{e}$ 是弹性右拉伸张量，且 $U^{e}$ 是对称正定的。\n- 将晶格自旋推导为弹性速度梯度的反对称部分。您的推导必须明确使用 $R^{e}$ 的正交性和 $U^{e}$ 的对称性，并且必须从上述基本定义出发，不使用这些基础之外的任何简化公式。\n\n积分任务：\n- 构建一个积分方案，用于在一个时间步 $\\Delta t$ 内更新 $R^{e}$，并保证在步末 $R^{e} \\in \\mathrm{SO}(3)$。该方案必须基于应用于晶格自旋的 $\\mathfrak{so}(3)$（SO(3)的李代数）上的矩阵指数，并且可以使用时间步内的自旋的前向估值或中点估值。\n- 更新必须用 $\\mathbb{R}^{3 \\times 3}$ 中的一个反对称矩阵来表示，并且必须从数学上证明为什么该更新能保持 $R^{e}$ 的正交性。\n\n实现与测试组：\n- 在一个程序中实现您的方案，为以下四个测试案例计算旋转更新。角度必须以弧度为单位，时间以秒为单位。\n- 使用的定义：\n    - 对于一个向量 $\\omega \\in \\mathbb{R}^{3}$，定义其相关的斜对称映射 $[\\omega]_{\\times} \\in \\mathbb{R}^{3 \\times 3}$ 为\n      $$[\\omega]_{\\times} = \\begin{bmatrix} 0  -\\omega_{3}  \\omega_{2} \\\\ \\omega_{3}  0  -\\omega_{1} \\\\ -\\omega_{2}  \\omega_{1}  0 \\end{bmatrix}.$$\n    - 定义 $\\operatorname{skw}(A) = \\tfrac{1}{2}(A - A^{\\top})$ 对于任何 $A \\in \\mathbb{R}^{3 \\times 3}$。\n    - $\\mathbb{R}^{3 \\times 3}$ 上的矩阵指数 $\\exp(\\cdot)$ 是线性代数中的标准矩阵指数。\n\n- 测试案例：\n    1. 恒定晶格自旋（理想情况）：$\\omega = [0.1,\\,0.2,\\,-0.05]$，初始条件为 $R^{e}(0) = I$，时间步长 $\\Delta t = 0.01$ s，共 $N = 100$ 步。使用自旋的中点估值；在 $T = N \\Delta t$ 后的精确旋转是 $\\exp(T [\\omega]_{\\times})$。\n    2. 零晶格自旋（边界情况）：$\\omega(t) \\equiv [0,\\,0,\\,0]$，初始条件为 $R^{e}(0) = \\exp(0.3\\,[e_{y}]_{\\times})$，时间步长 $\\Delta t = 0.05$ s，共 $N = 10$ 步。旋转必须保持不变。\n    3. 弹性拉伸与旋转共存（检查 $\\operatorname{skw}(L^{e})$ 的边缘情况）：令 $U^{e}(t) = \\mathrm{diag}(\\exp(\\alpha t),\\,\\exp(\\beta t),\\,\\exp(\\gamma t))$，其中 $(\\alpha,\\beta,\\gamma) = (0.2,-0.1,0.0)$ 单位为 $\\mathrm{s}^{-1}$。令 $R^{e}(t)$ 是一个绕 $e_{z}$ 轴以恒定速率 $\\omega_{z} = 0.5$ $\\mathrm{rad/s}$ 的旋转，因此 $R^{e}(t) = \\exp(t\\,[e_{z}]_{\\times}\\,\\omega_{z})$。定义 $L^{e}(t) = \\dot{F}^{e}(t)\\,(F^{e}(t))^{-1}$，其中 $F^{e}(t) = R^{e}(t)\\,U^{e}(t)$；计算 $\\operatorname{skw}(L^{e}(t))$ 并用它来更新 $R^{e}$。使用 $\\Delta t = 0.02$ s，共 $N = 100$ 步，$R^{e}(0) = I$。在 $T$ 时刻的精确旋转是 $\\exp(T\\,[e_{z}]_{\\times}\\,\\omega_{z})$。\n    4. 绕固定轴的时变晶格自旋（可交换情况，大步长）：$\\omega(t) = [\\omega_{0}\\sin(\\nu t),\\,0,\\,0]$，其中 $\\omega_{0}=1.2$ $\\mathrm{rad/s}$，$\\nu=0.8$ $\\mathrm{rad/s}$，$R^{e}(0) = I$，时间步长 $\\Delta t = 0.2$ s，共 $N = 25$ 步。使用中点估值。在 $T$ 时刻的精确旋转是 $\\exp(\\theta(T)\\,[e_{x}]_{\\times})$，其中 $\\theta(T) = \\int_{0}^{T}\\omega_{0}\\sin(\\nu t)\\,dt = \\frac{\\omega_{0}}{\\nu}\\bigl(1 - \\cos(\\nu T)\\bigr)$。\n\n- 对于每个测试案例，计算并返回两个误差度量：\n    - 数值更新的旋转与最终时间 $T$ 的精确旋转之差的Frobenius范数，即 $\\|R^{e}_{\\text{num}}(T) - R^{e}_{\\text{exact}}(T)\\|_{F}$。\n    - 最终时间 $T$ 的正交性破坏的Frobenius范数，即 $\\|R^{e}_{\\text{num}}(T)^{\\top} R^{e}_{\\text{num}}(T) - I\\|_{F}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试案例贡献一个包含两个浮点数的列表，顺序与上文指定相同。例如，输出格式必须类似于 \"[[e11,e12],[e21,e22],[e31,e32],[e41,e42]]\"，其中 $e_{i1}$ 是测试案例 $i$ 的旋转误差，$e_{i2}$ 是正交性误差。\n\n所有角度必须以弧度为单位，所有时间必须以秒为单位，并且每个误差值必须作为浮点数返回。",
            "solution": "推导始于晶体塑性的运动学框架。变形梯度 $F$ 允许乘法分解 $F = F^{e} F^{p}$，该分解区分了弹性晶格畸变 $F^{e}$ 和塑性畸变 $F^{p}$。弹性速度梯度由 $L^{e} = \\dot{F}^{e} (F^{e})^{-1}$ 定义，其中 $\\dot{(\\cdot)}$ 表示材料时间导数。弹性变形梯度允许极分解 $F^{e} = R^{e} U^{e}$，其中 $R^{e} \\in \\mathrm{SO}(3)$ 是一个 $\\det(R^{e}) = 1$ 的正交旋转，$U^{e}$ 是一个对称正定的右拉伸张量。\n\n对 $F^{e} = R^{e} U^{e}$ 求时间导数得到 $\\dot{F}^{e} = \\dot{R}^{e} U^{e} + R^{e} \\dot{U}^{e}$。右乘 $(F^{e})^{-1} = (U^{e})^{-1} (R^{e})^{\\top}$ 得到\n$$\nL^{e} = \\dot{F}^{e} (F^{e})^{-1} = \\dot{R}^{e} U^{e} (U^{e})^{-1} (R^{e})^{\\top} + R^{e} \\dot{U}^{e} (U^{e})^{-1} (R^{e})^{\\top}\n= \\dot{R}^{e} (R^{e})^{\\top} + R^{e}\\left(\\dot{U}^{e} (U^{e})^{-1}\\right)(R^{e})^{\\top}.\n$$\n第一项 $\\dot{R}^{e} (R^{e})^{\\top}$ 是反对称的。要证明这一点，注意到 $R^{e}$ 的正交性意味着 $(R^{e})^{\\top} R^{e} = I$，对其求导得到 $(\\dot{R}^{e})^{\\top} R^{e} + (R^{e})^{\\top} \\dot{R}^{e} = 0$，所以\n$$\n\\left(\\dot{R}^{e} (R^{e})^{\\top}\\right)^{\\top} = R^{e} (\\dot{R}^{e})^{\\top} = - \\dot{R}^{e} (R^{e})^{\\top}.\n$$\n第二项 $R^{e}\\left(\\dot{U}^{e} (U^{e})^{-1}\\right)(R^{e})^{\\top}$ 是对称的，因为 $U^{e}$ 是对称正定的。确实，$U^{e}$ 允许正交谱分解 $U^{e} = Q \\Lambda Q^{\\top}$，其中 $Q \\in \\mathrm{SO}(3)$ 且 $\\Lambda$ 是正对角矩阵。求导并构造 $\\dot{U}^{e} (U^{e})^{-1}$，在同旋主基中，会得到一个对角算子（主拉伸率除以主拉伸），因此是对称的；通过 $R^{e}$ 的正交合同变换保持对称性。因此，取其反对称部分，\n$$\n\\operatorname{skw}(L^{e}) = \\operatorname{skw}\\bigl(\\dot{R}^{e} (R^{e})^{\\top}\\bigr),\n$$\n晶格自旋被确定为与晶格旋转速率相关的反对称张量。该对象位于由 $3 \\times 3$ 反对称矩阵构成的李代数 $\\mathfrak{so}(3)$ 中。\n\n接下来，$R^{e}$ 的演化遵循旋转运动学。定义角速度张量 $W^{e} = \\operatorname{skw}(L^{e}) \\in \\mathfrak{so}(3)$。与群结构一致的旋转速率方程是\n$$\n\\dot{R}^{e} = W^{e} R^{e}.\n$$\n左乘 $(R^{e})^{\\top}$ 得到 $(R^{e})^{\\top}\\dot{R}^{e} = (R^{e})^{\\top} W^{e} R^{e}$，且左侧是反对称的，因为 $(R^{e})^{\\top}\\dot{R}^{e} = - \\bigl((R^{e})^{\\top}\\dot{R}^{e}\\bigr)^{\\top}$，这与 $W^{e} \\in \\mathfrak{so}(3)$ 一致。在大小为 $\\Delta t$ 的时间步上的解由李群指数更新给出\n$$\nR^{e}(t+\\Delta t) = \\exp\\bigl(\\Delta t\\, W^{e}_{\\star}\\bigr)\\, R^{e}(t),\n$$\n其中 $W^{e}_{\\star}$ 是在该区间上对 $W^{e}$ 的适当选择的近似，例如 $W^{e}(t)$（前向欧拉）或 $W^{e}(t+\\Delta t/2)$（中点法）。因为 $W^{e}_{\\star}$ 是反对称的，所以 $\\exp(\\Delta t\\,W^{e}_{\\star})$ 是一个行列式为1的正交矩阵，因此该更新保持 $R^{e} \\in \\mathrm{SO}(3)$。这源于这样一个事实：对于任何反对称矩阵 $A$，$\\exp(A)$ 是正交的，因为 $\\exp(A)^{\\top}\\exp(A) = \\exp(A^{\\top}) \\exp(A) = \\exp(-A)\\exp(A) = I$，并且 $\\det(\\exp(A)) = \\exp(\\operatorname{tr}(A)) = 1$ 因为 $\\operatorname{tr}(A)=0$。\n\n实现算法设计：\n- 将自旋表示为一个反对称矩阵 $W^{e}(t) \\in \\mathbb{R}^{3 \\times 3}$，它可以通过 $[\\cdot]_{\\times}$ 算子由指定的角速度向量直接生成，或者在 $L^{e}(t)$ 已知时通过 $W^{e}(t) = \\operatorname{skw}(L^{e}(t))$ 生成。\n- 使用中点估值 $W^{e}_{\\star} = W^{e}(t+\\Delta t/2)$ 以提高精度。计算增量旋转 $R_{\\Delta} = \\exp(\\Delta t\\, W^{e}_{\\star})$ 并更新 $R^{e} \\leftarrow R_{\\Delta} R^{e}$。\n- 矩阵指数可以通过标准的线性代数方法进行稳健评估。对于反对称矩阵，可以等效地使用从 $\\mathfrak{so}(3)$ 到 $\\mathrm{SO}(3)$ 的映射推导出的 Rodrigues 公式，但直接的指数方法通用且简洁。\n\n测试案例构建：\n- 测试案例1：恒定自旋，$\\omega = [0.1, 0.2, -0.05]$ 产生 $W^{e}(t) \\equiv [\\omega]_{\\times}$ 且精确解为 $R^{e}(T) = \\exp(T [\\omega]_{\\times})$。\n- 测试案例2：零自旋，初始条件为 $R^{e}(0) = \\exp(0.3\\,[e_{y}]_{\\times})$ 且 $W^{e}(t) \\equiv 0$ 得到 $R^{e}(T) = R^{e}(0)$。\n- 测试案例3：$F^{e}(t) = R^{e}(t)\\,U^{e}(t)$，其中 $R^{e}(t)$ 是绕 $e_{z}$ 的恒定速率旋转，$U^{e}(t) = \\mathrm{diag}(\\exp(\\alpha t),\\,\\exp(\\beta t),\\,\\exp(\\gamma t))$。计算\n$$\nL^{e}(t) = \\dot{R}^{e}(t)\\,(R^{e}(t))^{\\top} + R^{e}(t)\\,\\bigl(\\dot{U}^{e}(t)\\,(U^{e}(t))^{-1}\\bigr)\\,(R^{e}(t))^{\\top},\n$$\n然后计算 $W^{e}(t) = \\operatorname{skw}(L^{e}(t))$。对于所选的对角 $U^{e}$ 和绕 $e_{z}$ 的旋转，第二项是对称的，而第一项是 $\\omega_{z}[e_{z}]_{\\times}$，从而恢复了预期的自旋。\n- 测试案例4：绕 $e_{x}$ 的时变自旋 $\\omega(t) = [\\omega_{0}\\sin(\\nu t), 0, 0]$。由于生成元是固定的，精确的 $R^{e}(T) = \\exp(\\theta(T)\\,[e_{x}]_{\\times})$，其中 $\\theta(T) = \\frac{\\omega_{0}}{\\nu}(1 - \\cos(\\nu T))$。\n\n误差度量：\n- 对每个案例，计算 $\\|R^{e}_{\\text{num}}(T) - R^{e}_{\\text{exact}}(T)\\|_{F}$ 以度量积分精度，计算 $\\|R^{e}_{\\text{num}}(T)^{\\top} R^{e}_{\\text{num}}(T) - I\\|_{F}$ 以度量正交性保持情况。\n- 最终输出是这四个案例的误差对列表，以指定格式打印为单行。\n\n这种方法确保更新尊重旋转的群结构，并将晶格自旋锚定为弹性速度梯度的反对称部分，这是严格从乘法分解和极分解运动学推导出来的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef hat(omega):\n    \"\"\"Return the skew-symmetric matrix [omega]_x for omega in R^3.\"\"\"\n    wx, wy, wz = omega\n    return np.array([[0.0, -wz,  wy],\n                     [wz,  0.0, -wx],\n                     [-wy, wx,  0.0]])\n\ndef skew(A):\n    \"\"\"Return the skew-symmetric part of a 3x3 matrix.\"\"\"\n    return 0.5 * (A - A.T)\n\ndef fro_norm(A):\n    \"\"\"Frobenius norm.\"\"\"\n    return float(np.linalg.norm(A, 'fro'))\n\ndef update_rotation(R0, W_func, dt, N, scheme='midpoint'):\n    \"\"\"\n    Update rotation R in SO(3) using exponential map with midpoint or forward scheme.\n\n    Parameters:\n    - R0: initial 3x3 rotation matrix\n    - W_func: function of time t returning a 3x3 skew-symmetric matrix W^e(t)\n    - dt: time step (seconds)\n    - N: number of steps\n    - scheme: 'midpoint' or 'forward'\n\n    Returns:\n    - R: final rotation matrix after N steps\n    \"\"\"\n    R = R0.copy()\n    t = 0.0\n    for _ in range(N):\n        if scheme == 'midpoint':\n            W = W_func(t + 0.5 * dt)\n        elif scheme == 'forward':\n            W = W_func(t)\n        else:\n            raise ValueError(\"Unknown scheme\")\n        R_delta = expm(dt * W)\n        R = R_delta @ R\n        t += dt\n    return R\n\ndef rotation_about_axis(axis, angle):\n    \"\"\"\n    Return rotation matrix exp(angle * [axis]_x), axis must be a 3-vector.\n    \"\"\"\n    axis = np.asarray(axis, dtype=float)\n    return expm(angle * hat(axis))\n\ndef test_case_1():\n    # Constant lattice spin (happy path)\n    omega = np.array([0.1, 0.2, -0.05])  # rad/s\n    W_const = hat(omega)\n    R0 = np.eye(3)\n    dt = 0.01\n    N = 100\n    T = dt * N\n\n    def W_func(t):\n        return W_const\n\n    R_num = update_rotation(R0, W_func, dt, N, scheme='midpoint')\n    R_exact = expm(T * W_const)\n\n    rot_err = fro_norm(R_num - R_exact)\n    orth_err = fro_norm(R_num.T @ R_num - np.eye(3))\n    return [rot_err, orth_err]\n\ndef test_case_2():\n    # Zero lattice spin (boundary case)\n    def W_func(t):\n        return np.zeros((3, 3))  # W^e(t) = 0\n\n    R0 = rotation_about_axis([0.0, 1.0, 0.0], 0.3)  # initial rotation about y\n    dt = 0.05\n    N = 10\n    T = dt * N\n\n    R_num = update_rotation(R0, W_func, dt, N, scheme='midpoint')\n    R_exact = R0.copy()  # No change expected\n\n    rot_err = fro_norm(R_num - R_exact)\n    orth_err = fro_norm(R_num.T @ R_num - np.eye(3))\n    return [rot_err, orth_err]\n\ndef test_case_3():\n    # Coexistent elastic stretch and rotation (edge case checking skw(L^e))\n    # U^e(t) = diag(exp(alpha t), exp(beta t), exp(gamma t))\n    alpha, beta, gamma = 0.2, -0.1, 0.0  # s^{-1}\n    D_diag = np.array([alpha, beta, gamma])  # Udot U^{-1} in principal frame (constant)\n    D = np.diag(D_diag)  # symmetric\n    omega_z = 0.5  # rad/s\n    ez = np.array([0.0, 0.0, 1.0])\n\n    def R_of_t(t):\n        return expm((omega_z * t) * hat(ez))\n\n    def L_e_of_t(t):\n        # L^e(t) = Rdot R^T + R D R^T\n        # For rotation about ez at constant rate, Rdot R^T = omega_z [ez]_x\n        R = R_of_t(t)\n        W_rot = omega_z * hat(ez)\n        return W_rot + R @ D @ R.T\n\n    def W_func(t):\n        # W^e(t) = skw(L^e(t))\n        return skew(L_e_of_t(t))\n\n    R0 = np.eye(3)\n    dt = 0.02\n    N = 100\n    T = dt * N\n\n    R_num = update_rotation(R0, W_func, dt, N, scheme='midpoint')\n    R_exact = R_of_t(T)\n\n    rot_err = fro_norm(R_num - R_exact)\n    orth_err = fro_norm(R_num.T @ R_num - np.eye(3))\n    return [rot_err, orth_err]\n\ndef test_case_4():\n    # Time-dependent lattice spin about a fixed axis (commuting case, large step)\n    omega0 = 1.2  # rad/s\n    nu = 0.8      # rad/s\n    ex = np.array([1.0, 0.0, 0.0])\n\n    def W_func(t):\n        return hat(np.array([omega0 * np.sin(nu * t), 0.0, 0.0]))\n\n    dt = 0.2\n    N = 25\n    T = dt * N\n\n    R0 = np.eye(3)\n    R_num = update_rotation(R0, W_func, dt, N, scheme='midpoint')\n    # Exact rotation: theta(T) = (omega0/nu) * (1 - cos(nu T))\n    theta_T = (omega0 / nu) * (1.0 - np.cos(nu * T))\n    R_exact = rotation_about_axis(ex, theta_T)\n\n    rot_err = fro_norm(R_num - R_exact)\n    orth_err = fro_norm(R_num.T @ R_num - np.eye(3))\n    return [rot_err, orth_err]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    results = []\n    results.append(test_case_1())\n    results.append(test_case_2())\n    results.append(test_case_3())\n    results.append(test_case_4())\n\n    # Final print statement in the exact required format.\n    # Print as a single line: list of four [rotation_error, orthogonality_error] pairs.\n    # Ensure default string conversion yields comma-separated floats within nested lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "建立了运动学框架后，我们必须为塑性滑移的启动建立物理模型。本练习旨在探讨驱动滑移的本构定律，超越了经典的 Schmid 定律。通过设计一个巧妙的加载路径，您将学会如何区分在传统模型下表现相同的滑移系，从而深刻理解非 Schmid 效应对材料各向异性塑性行为的关键影响。",
            "id": "3441899",
            "problem": "为晶体塑性有限元 (CPFE) 建模构建一个计算基准，该基准旨在分离小应变下滑移激活中非 Schmid 效应的作用。考虑一个具有两个滑移系的单晶，索引为 $\\alpha \\in \\{1,2\\}$。沿指定的偏载荷方向，这两个滑移系的经典 Schmid 贡献相同，但其非 Schmid 敏感性不同。目标是设计一个应力加载路径族，用以区分首先激活的滑移系，并实现一个程序，该程序能为给定的路径预测首先激活的滑移系。\n\n从以下基本原理开始：\n- 柯西应力张量为 $\\boldsymbol{\\sigma}$，静水压力为 $p = \\tfrac{1}{3} \\operatorname{tr}(\\boldsymbol{\\sigma})$。\n- 对于滑移系 $\\alpha$，滑移方向为单位向量 $\\boldsymbol{s}^\\alpha$，滑移面单位法向为 $\\boldsymbol{m}^\\alpha$，且 $\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{m}^\\alpha = 0$。\n- 分解剪应力为 $\\tau^\\alpha = \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{\\sigma} \\cdot \\boldsymbol{m}^\\alpha$。\n- 滑移面上的法向应力为 $\\sigma_{nn}^\\alpha = \\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{\\sigma} \\cdot \\boldsymbol{m}^\\alpha$。\n- 一个用于激活的非 Schmid 增广驱动应力为 $\\psi^\\alpha = \\tau^\\alpha + a^\\alpha p + b^\\alpha \\sigma_{nn}^\\alpha$，其中 $a^\\alpha$ 和 $b^\\alpha$ 是可能取决于 $\\alpha$ 的无量纲非 Schmid 系数。\n- 当 $|\\psi^\\alpha| = g^\\alpha$ 时，滑移系 $\\alpha$ 激活，其中 $g^\\alpha$ 是临界分解剪应力。\n\n将加载设计为一个单参数族，该族混合了一个固定的偏张量和一个可调的静水压力分量。设总应力为\n$$\n\\boldsymbol{\\sigma}(\\lambda; r) = \\lambda \\,\\boldsymbol{D} + r \\,\\lambda \\,\\boldsymbol{I},\n$$\n其中 $\\lambda \\ge 0$ 用于缩放以兆帕为单位的总应力大小，$\\boldsymbol{I}$ 是单位张量，$\\boldsymbol{D}$ 是一个固定的偏张量，$r$ 是一个实值路径比，用于设置静水压力与偏应力的比例。因为 $\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{I} \\cdot \\boldsymbol{m}^\\alpha = \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{m}^\\alpha = 0$，所以静水压力分量对经典的 Schmid 项没有贡献。\n\n使用以下具体、科学上合理的规范：\n- 使用典范偏张量\n$$\n\\boldsymbol{D} = \\operatorname{diag}\\!\\big(1,\\,-\\tfrac{1}{2},\\,-\\tfrac{1}{2}\\big).\n$$\n- 定义两个沿 $\\boldsymbol{D}$ 方向具有相同 Schmid 贡献的滑移系：\n  - 滑移系 1：$\\boldsymbol{m}^1 = \\tfrac{1}{\\sqrt{2}}(1,\\,0,\\,1)$，$\\boldsymbol{s}^1 = \\tfrac{1}{\\sqrt{2}}(1,\\,0,\\,-1)$。\n  - 滑移系 2：$\\boldsymbol{m}^2 = \\tfrac{1}{\\sqrt{2}}(1,\\,0,\\,-1)$，$\\boldsymbol{s}^2 = \\tfrac{1}{\\sqrt{2}}(1,\\,0,\\,1)$。\n- 验证 $ \\boldsymbol{s}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\boldsymbol{s}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2$。\n- 指定非 Schmid 系数和临界分解剪应力：\n  - $a^1 = 0.3$，$b^1 = 0.1$，$g^1 = 50$（单位为兆帕）。\n  - $a^2 = -0.1$，$b^2 = 0.25$，$g^2 = 50$（单位为兆帕）。\n\n在此加载条件下，对于每个滑移系 $\\alpha$，推导线性关系\n$$\n\\psi^\\alpha(\\lambda; r) = \\big[\\, \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha \\,+\\, a^\\alpha r \\,+\\, b^\\alpha \\big(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + r \\big) \\,\\big] \\,\\lambda \\equiv K^\\alpha(r)\\,\\lambda,\n$$\n并计算激活载荷水平\n$$\n\\lambda_c^\\alpha(r) = \\frac{g^\\alpha}{|K^\\alpha(r)|},\n$$\n单位为兆帕。首先激活的滑移系是 $\\lambda_c^\\alpha(r)$ 最小的那个。在极少数情况下，如果 $\\lambda_c^1(r)$ 和 $\\lambda_c^2(r)$ 在数值容差范围内相等，则将其视为精确的平局。\n\n您的程序必须：\n- 使用指定的 $\\boldsymbol{D}$、$\\boldsymbol{s}^\\alpha$、$\\boldsymbol{m}^\\alpha$、$a^\\alpha$、$b^\\alpha$ 和 $g^\\alpha$ 实现上述定义。\n- 对于每个提供的测试用例值 $r$，计算 $K^\\alpha(r)$，然后计算 $\\lambda_c^\\alpha(r)$（单位为兆帕），并确定首先激活的滑移系。\n- 使用以下路径比 $r$ 的测试套件：\n  - 情况 1：$r = 0$。\n  - 情况 2：$r = 0.15$。\n  - 情况 3：$r = 0.5$。\n  - 情况 4：$r = -0.5$。\n- 对 $|\\lambda_c^1(r) - \\lambda_c^2(r)|$ 应用 $\\varepsilon = 10^{-9}$ 的平局容差来判断平局。\n\n最终输出格式：\n- 对于每个测试用例，输出一个整数，表示首先激活的滑移系索引，取值于 $\\{1,2\\}$；如果出现平局，则输出整数 $0$。\n- 您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表，例如，$[2,0,1,2]$ 对应于按顺序排列的四个测试用例。\n- 所有涉及应力大小的中间计算都必须以兆帕为单位进行，但最终报告的整数是无单位的索引。",
            "solution": "问题陈述已经过严格验证，并被确定为**有效**。它以晶体塑性原理为科学基础，问题设定良好，具有完整且一致的参数集，并以客观的方式呈现。该任务是一个明确定义的计算基准设计，是计算材料科学中的一个合理实践。\n\n目标是确定两个滑移系（$\\alpha \\in \\{1,2\\}$）中哪一个在指定的应力路径族下首先激活。首先激活的滑移系是达到其激活阈值所需应力大小 $\\lambda$ 最小的那个。这对应于具有最小临界载荷水平 $\\lambda_c^\\alpha$ 的滑移系。\n\n施加的宏观柯西应力张量 $\\boldsymbol{\\sigma}$ 由以下单参数族给出：\n$$\n\\boldsymbol{\\sigma}(\\lambda; r) = \\lambda \\,\\boldsymbol{D} + r \\,\\lambda \\,\\boldsymbol{I}\n$$\n其中 $\\lambda \\ge 0$ 是以兆帕 (MPa) 为单位的载荷大小，$\\boldsymbol{D}$ 是一个固定的偏张量，$\\boldsymbol{I}$ 是单位张量，$r$ 是一个控制静水应力分量的无量纲路径比。\n\n滑移系 $\\alpha$ 的激活由一个非 Schmid 准则控制，其中驱动应力 $\\psi^\\alpha$ 必须达到一个临界值 $g^\\alpha$。驱动应力定义为：\n$$\n\\psi^\\alpha = \\tau^\\alpha + a^\\alpha p + b^\\alpha \\sigma_{nn}^\\alpha\n$$\n这里，$\\tau^\\alpha = \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{\\sigma} \\cdot \\boldsymbol{m}^\\alpha$ 是分解剪应力，$p = \\frac{1}{3} \\operatorname{tr}(\\boldsymbol{\\sigma})$ 是静水压力，$\\sigma_{nn}^\\alpha = \\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{\\sigma} \\cdot \\boldsymbol{m}^\\alpha$ 是垂直于滑移面的应力分量。系数 $a^\\alpha$ 和 $b^\\alpha$ 是非 Schmid 效应的材料参数。\n\n我们首先用加载参数 $\\lambda$ 和 $r$ 表示驱动应力的分量。\n静水压力为：\n$$\np = \\frac{1}{3} \\operatorname{tr}(\\lambda \\boldsymbol{D} + r\\lambda \\boldsymbol{I}) = \\frac{\\lambda}{3} \\operatorname{tr}(\\boldsymbol{D}) + \\frac{r\\lambda}{3} \\operatorname{tr}(\\boldsymbol{I})\n$$\n由于 $\\boldsymbol{D}$ 是偏张量，$\\operatorname{tr}(\\boldsymbol{D}) = 0$。又因为 $\\operatorname{tr}(\\boldsymbol{I}) = 3$，因此简化为 $p = r\\lambda$。\n\n分解剪应力为：\n$$\n\\tau^\\alpha = \\boldsymbol{s}^\\alpha \\cdot (\\lambda \\boldsymbol{D} + r\\lambda \\boldsymbol{I}) \\cdot \\boldsymbol{m}^\\alpha = \\lambda(\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha) + r\\lambda(\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{I} \\cdot \\boldsymbol{m}^\\alpha)\n$$\n鉴于滑移系的正交性 $\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{m}^\\alpha = 0$，第二项消失，剩下 $\\tau^\\alpha = \\lambda(\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha)$。\n\n滑移面法向应力为：\n$$\n\\sigma_{nn}^\\alpha = \\boldsymbol{m}^\\alpha \\cdot (\\lambda \\boldsymbol{D} + r\\lambda \\boldsymbol{I}) \\cdot \\boldsymbol{m}^\\alpha = \\lambda(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha) + r\\lambda(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{I} \\cdot \\boldsymbol{m}^\\alpha)\n$$\n由于 $\\boldsymbol{m}^\\alpha$ 是单位向量，$\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{m}^\\alpha = 1$，这给出 $\\sigma_{nn}^\\alpha = \\lambda(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + r)$。\n\n将这些代入 $\\psi^\\alpha$ 的表达式中：\n$$\n\\psi^\\alpha(\\lambda; r) = \\lambda(\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha) + a^\\alpha(r\\lambda) + b^\\alpha \\left[\\lambda(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + r)\\right]\n$$\n提出因子 $\\lambda$ 得到 $\\psi^\\alpha(\\lambda; r) = K^\\alpha(r)\\lambda$，其中有效驱动应力系数 $K^\\alpha(r)$ 为：\n$$\nK^\\alpha(r) = \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + a^\\alpha r + b^\\alpha(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + r)\n$$\n这证实了问题陈述中提供的表达式。滑移激活发生在 $|\\psi^\\alpha| = g^\\alpha$ 时，所以 $|\\lambda K^\\alpha(r)| = g^\\alpha$。因此，临界载荷水平为 $\\lambda_c^\\alpha(r) = \\frac{g^\\alpha}{|K^\\alpha(r)|}$。\n\n我们现在使用提供的数据计算恒定的几何因子：\n- 偏张量：$\\boldsymbol{D} = \\operatorname{diag}(1, -1/2, -1/2)$。\n- 滑移系 1：$\\boldsymbol{m}^1 = \\frac{1}{\\sqrt{2}}(1, 0, 1)$，$\\boldsymbol{s}^1 = \\frac{1}{\\sqrt{2}}(1, 0, -1)$。\n- 滑移系 2：$\\boldsymbol{m}^2 = \\frac{1}{\\sqrt{2}}(1, 0, -1)$，$\\boldsymbol{s}^2 = \\frac{1}{\\sqrt{2}}(1, 0, 1)$。\n\n对于滑移系 1：\n- Schmid 因子：$\\boldsymbol{s}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\frac{1}{2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  -1/2  0 \\\\ 0  0  -1/2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1/2 \\end{pmatrix} = \\frac{1}{2}(1 + 1/2) = \\frac{3}{4}$。\n- 法向应力因子：$\\boldsymbol{m}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\frac{1}{2} \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  -1/2  0 \\\\ 0  0  -1/2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1/2 \\end{pmatrix} = \\frac{1}{2}(1 - 1/2) = \\frac{1}{4}$。\n\n对于滑移系 2：\n- Schmid 因子：$\\boldsymbol{s}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2 = \\frac{1}{2} \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  -1/2  0 \\\\ 0  0  -1/2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1/2 \\end{pmatrix} = \\frac{1}{2}(1 + 1/2) = \\frac{3}{4}$。\n- 法向应力因子：$\\boldsymbol{m}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2 = \\frac{1}{2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  -1/2  0 \\\\ 0  0  -1/2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1/2 \\end{pmatrix} = \\frac{1}{2}(1 - 1/2) = \\frac{1}{4}$。\n\n正如所要求的，Schmid 因子是相同的，$\\boldsymbol{s}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\boldsymbol{s}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2 = 0.75$。法向应力因子也恰好相同，$\\boldsymbol{m}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\boldsymbol{m}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2 = 0.25$。激活的差异将完全源于非 Schmid 系数。\n\n我们使用系数 $a^1=0.3$, $b^1=0.1$, $a^2=-0.1$, $b^2=0.25$ 来组装 $K^\\alpha(r)$ 的表达式：\n- $K^1(r) = 0.75 + a^1 r + b^1 (0.25 + r) = 0.75 + 0.3r + 0.1(0.25 + r) = 0.75 + 0.3r + 0.025 + 0.1r = 0.775 + 0.4r$。\n- $K^2(r) = 0.75 + a^2 r + b^2 (0.25 + r) = 0.75 - 0.1r + 0.25(0.25 + r) = 0.75 - 0.1r + 0.0625 + 0.25r = 0.8125 + 0.15r$。\n\n由于 $g^1 = g^2 = 50$ MPa，我们有：\n$\\lambda_c^1(r) = \\frac{50}{|0.775 + 0.4r|}$ 和 $\\lambda_c^2(r) = \\frac{50}{|0.8125 + 0.15r|}$。\n\n我们现在对每个测试用例进行评估：\n\n情况 1：$r = 0$\n- $K^1(0) = 0.775$，$\\lambda_c^1(0) = 50/0.775 \\approx 64.516$ MPa。\n- $K^2(0) = 0.8125$，$\\lambda_c^2(0) = 50/0.8125 \\approx 61.538$ MPa。\n- $\\lambda_c^2(0)  \\lambda_c^1(0)$，所以滑移系 2 首先激活。结果：2。\n\n情况 2：$r = 0.15$\n- $K^1(0.15) = 0.775 + 0.4(0.15) = 0.775 + 0.06 = 0.835$。\n- $K^2(0.15) = 0.8125 + 0.15(0.15) = 0.8125 + 0.0225 = 0.835$。\n- $K^1(0.15) = K^2(0.15)$，这意味着 $\\lambda_c^1(0.15) = \\lambda_c^2(0.15)$。\n- 差值 $|\\lambda_c^1 - \\lambda_c^2| = 0$，小于容差 $\\varepsilon=10^{-9}$。这是一个精确的平局。结果：0。\n\n情况 3：$r = 0.5$\n- $K^1(0.5) = 0.775 + 0.4(0.5) = 0.775 + 0.2 = 0.975$。$\\lambda_c^1(0.5) = 50/0.975 \\approx 51.282$ MPa。\n- $K^2(0.5) = 0.8125 + 0.15(0.5) = 0.8125 + 0.075 = 0.8875$。$\\lambda_c^2(0.5) = 50/0.8875 \\approx 56.338$ MPa。\n- $\\lambda_c^1(0.5)  \\lambda_c^2(0.5)$，所以滑移系 1 首先激活。结果：1。\n\n情况 4：$r = -0.5$\n- $K^1(-0.5) = 0.775 + 0.4(-0.5) = 0.775 - 0.2 = 0.575$。$\\lambda_c^1(-0.5) = 50/0.575 \\approx 86.957$ MPa。\n- $K^2(-0.5) = 0.8125 + 0.15(-0.5) = 0.8125 - 0.075 = 0.7375$。$\\lambda_c^2(-0.5) = 50/0.7375 \\approx 67.796$ MPa。\n- $\\lambda_c^2(-0.5)  \\lambda_c^1(-0.5)$，所以滑移系 2 首先激活。结果：2。\n\n给定测试用例的最终结果序列为 [2, 0, 1, 2]。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the first-activating slip system for a single crystal under\n    various mixed deviatoric-hydrostatic loading paths, considering\n    non-Schmid effects.\n    \"\"\"\n    \n    # Define problem parameters\n    \n    # Deviatoric stress tensor D\n    D = np.diag([1.0, -0.5, -0.5])\n\n    # Parameters for slip system 1\n    m1 = np.array([1.0, 0.0, 1.0]) / np.sqrt(2)\n    s1 = np.array([1.0, 0.0, -1.0]) / np.sqrt(2)\n    a1 = 0.3\n    b1 = 0.1\n    g1 = 50.0  # in MPa\n\n    # Parameters for slip system 2\n    m2 = np.array([1.0, 0.0, -1.0]) / np.sqrt(2)\n    s2 = np.array([1.0, 0.0, 1.0]) / np.sqrt(2)\n    a2 = -0.1\n    b2 = 0.25\n    g2 = 50.0  # in MPa\n    \n    # Test suite of path ratios r\n    test_cases_r = [0.0, 0.15, 0.5, -0.5]\n    \n    # Tie tolerance\n    epsilon = 1e-9\n    \n    results = []\n\n    # Pre-compute constant geometric factors\n    # For system 1\n    tau1_D = np.dot(s1, D @ m1)\n    sigma_nn1_D = np.dot(m1, D @ m1)\n    \n    # For system 2\n    tau2_D = np.dot(s2, D @ m2)\n    sigma_nn2_D = np.dot(m2, D @ m2)\n\n    for r in test_cases_r:\n        # Calculate the effective driving stress coefficient K(r) for each system\n        \n        # System 1: K^1(r) = s^1.D.m^1 + a^1*r + b^1*(m^1.D.m^1 + r)\n        K1_r = tau1_D + a1 * r + b1 * (sigma_nn1_D + r)\n        \n        # System 2: K^2(r) = s^2.D.m^2 + a^2*r + b^2*(m^2.D.m^2 + r)\n        K2_r = tau2_D + a2 * r + b2 * (sigma_nn2_D + r)\n        \n        # Calculate the critical activation load lambda_c = g / |K(r)|\n        # Avoid division by zero, though not expected for these test cases.\n        # If K(r) is zero, the system never activates, so lambda_c is infinite.\n        if abs(K1_r)  epsilon:\n            lambda_c1 = np.inf\n        else:\n            lambda_c1 = g1 / abs(K1_r)\n\n        if abs(K2_r)  epsilon:\n            lambda_c2 = np.inf\n        else:\n            lambda_c2 = g2 / abs(K2_r)\n            \n        # Determine the first-activating system\n        if abs(lambda_c1 - lambda_c2) = epsilon:\n            # Activation thresholds are equal within tolerance: it's a tie.\n            results.append(0)\n        elif lambda_c1  lambda_c2:\n            # System 1 activates at a lower stress magnitude.\n            results.append(1)\n        else:\n            # System 2 activates at a lower stress magnitude.\n            results.append(2)\n\n    # Print the final result in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}