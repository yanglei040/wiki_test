{
    "hands_on_practices": [
        {
            "introduction": "At their core, phase-field models are expressions of thermodynamics, describing a system's evolution towards a state of minimum free energy. This principle of energy dissipation is not just a theoretical curiosity; it is the physical foundation that guarantees the models behave sensibly. This first practice guides you through a fundamental proof, demonstrating that both the Allen-Cahn and Cahn-Hilliard equations are indeed gradient flows that dissipate free energy . You will then confront the practical reality that simple numerical schemes may not automatically respect this crucial physical law, and you will build a diagnostic tool to detect and quantify such non-physical behavior, a critical skill for any computational modeler.",
            "id": "3476385",
            "problem": "Consider a scalar phase field $\\phi(x,t)$ on a one-dimensional periodic domain $\\Omega = [0,L]$ with $L>0$, representing the local order parameter of a two-phase material. The free energy functional is defined by\n$$\nF[\\phi] \\;=\\; \\int_{\\Omega} \\left( \\frac{\\varepsilon^2}{2}\\,|\\nabla \\phi|^2 \\;+\\; \\frac{1}{4}\\,(\\phi^2-1)^2 \\right)\\,dx,\n$$\nwhere $\\varepsilon>0$ is an interface width parameter and $\\nabla$ is the spatial gradient. Let $\\mu = \\frac{\\delta F}{\\delta \\phi}$ denote the variational derivative (chemical potential). The dynamics are given by gradient flows with constant mobility $M>0$ under periodic boundary conditions:\n- The $L^2$ gradient flow (Allen–Cahn equation) is\n$$\n\\partial_t \\phi \\;=\\; -M\\,\\mu,\n$$\n- The $H^{-1}$ gradient flow (Cahn–Hilliard equation) is\n$$\n\\partial_t \\phi \\;=\\; \\nabla\\cdot\\big(M\\,\\nabla \\mu\\big).\n$$\n\nTask A (derivation): Starting from the definitions of the free energy $F[\\phi]$, the chemical potential $\\mu = \\delta F/\\delta \\phi$, and the two gradient flows above, and using only the calculus of variations, the chain rule for functionals, and periodic boundary conditions, derive from first principles that the free energy is nonincreasing in time along smooth solutions of both flows, i.e.,\n$$\n\\frac{dF}{dt} \\;\\le\\; 0\n$$\nfor the $L^2$ gradient flow and for the $H^{-1}$ gradient flow.\n\nTask B (diagnostic design): Design a numerical diagnostic that measures violations of discrete energy dissipation for time-discrete schemes. Consider a forward Euler time discretization with time step $\\Delta t>0$,\n- For the $L^2$ gradient flow (Allen–Cahn): \n$$\n\\phi^{n+1} \\;=\\; \\phi^n \\;-\\; \\Delta t\\, M\\, \\mu^n,\n$$\n- For the $H^{-1}$ gradient flow (Cahn–Hilliard): \n$$\n\\phi^{n+1} \\;=\\; \\phi^n \\;+\\; \\Delta t\\, M\\, \\Delta \\mu^n,\n$$\nwhere $\\mu^n = -\\varepsilon^2 \\Delta \\phi^n + \\phi^n\\big((\\phi^n)^2 - 1\\big)$ and $\\Delta$ is the Laplacian. The diagnostic must compute at each time step the discrete energy values $F^n = F[\\phi^n]$ and the discrete energy slope\n$$\ns^n \\;=\\; \\frac{F^{n+1} - F^n}{\\Delta t},\n$$\nand then report the maximum positive slope over the time horizon and the count of violations defined as the number of steps where $s^n$ exceeds a small nonnegative tolerance $\\tau$ (to avoid false positives due to roundoff). Use the tolerance $\\tau = 10^{-12}$.\n\nNumerical specification: Implement the diagnostic in one spatial dimension with periodic boundary conditions on $\\Omega=[0,L]$. Use a uniform grid with $N_x$ points. Spatial derivatives must be computed spectrally using the Fast Fourier Transform (FFT, Fast Fourier Transform). The energy must be approximated by the composite trapezoidal rule on the uniform grid (which is exact for periodic integrands sampled on uniform grids). The initial condition for nontrivial tests is\n$$\n\\phi(x,0) \\;=\\; 0.2\\,\\sin(2\\pi x/L) \\;+\\; 0.1\\,\\cos(6\\pi x/L),\n$$\nand for the boundary case is $\\phi(x,0)=1$. Use $M=1$ and $\\varepsilon=0.05$ for all tests. All quantities are nondimensional, so no physical units are required.\n\nTest suite: Run the diagnostic for the following parameter sets to test different facets of the scheme. Each test case is described by $(\\text{flow}, N_x, L, \\Delta t, N_{\\text{steps}}, \\text{init})$:\n1. $(\\text{Allen–Cahn},\\; N_x=128,\\; L=1,\\; \\Delta t = 10^{-4},\\; N_{\\text{steps}}=200,\\; \\text{init} = \\text{nontrivial})$ — happy path with small time step.\n2. $(\\text{Allen–Cahn},\\; N_x=128,\\; L=1,\\; \\Delta t = 10^{-2},\\; N_{\\text{steps}}=60,\\; \\text{init} = \\text{nontrivial})$ — large time step that may cause energy increase.\n3. $(\\text{Cahn–Hilliard},\\; N_x=128,\\; L=1,\\; \\Delta t = 10^{-6},\\; N_{\\text{steps}}=300,\\; \\text{init} = \\text{nontrivial})$ — conservative flow with very small time step.\n4. $(\\text{Cahn–Hilliard},\\; N_x=128,\\; L=1,\\; \\Delta t = 10^{-3},\\; N_{\\text{steps}}=100,\\; \\text{init} = \\text{nontrivial})$ — larger time step to expose violations.\n5. $(\\text{Allen–Cahn},\\; N_x=128,\\; L=1,\\; \\Delta t = 10^{-2},\\; N_{\\text{steps}}=40,\\; \\text{init} = \\text{constant } \\phi\\equiv 1)$ — boundary case where the chemical potential is zero and energy should remain constant.\n\nRequired final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output the maximum positive discrete energy slope over all steps (a float) followed by the count of violations (an integer). Aggregate the results across all test cases into a single flat list in the order of the test suite above. For example, the output format must be\n$$\n[\\text{max\\_pos\\_slope\\_case1},\\text{count\\_case1},\\text{max\\_pos\\_slope\\_case2},\\text{count\\_case2},\\ldots,\\text{max\\_pos\\_slope\\_case5},\\text{count\\_case5}].\n$$",
            "solution": "The problem presents two tasks: first, a theoretical derivation of the energy dissipation property for the Allen-Cahn and Cahn-Hilliard equations; second, the design and implementation of a numerical diagnostic to monitor violations of this property in a discrete forward Euler scheme. The problem is well-posed, scientifically sound, and provides all necessary information for a complete solution.\n\n### Task A: Derivation of Energy Dissipation\n\nThe goal is to demonstrate that the free energy $F[\\phi]$ is a nonincreasing function of time $t$ for smooth solutions $\\phi(x,t)$ to both the Allen-Cahn and Cahn-Hilliard equations. The free energy functional is given by:\n$$\nF[\\phi] = \\int_{\\Omega} f(\\phi, \\nabla \\phi) \\,dx = \\int_{\\Omega} \\left( \\frac{\\varepsilon^2}{2}\\,|\\nabla \\phi|^2 + \\frac{1}{4}\\,(\\phi^2-1)^2 \\right)\\,dx\n$$\nWe begin by computing the time derivative of $F[\\phi(t)]$ using the chain rule for functionals.\n$$\n\\frac{dF}{dt} = \\frac{d}{dt} \\int_{\\Omega} f(\\phi(x,t), \\nabla \\phi(x,t)) \\,dx\n$$\nApplying the chain rule and passing the derivative under the integral sign (Leibniz integral rule) yields:\n$$\n\\frac{dF}{dt} = \\int_{\\Omega} \\left( \\frac{\\partial f}{\\partial \\phi} \\frac{\\partial \\phi}{\\partial t} + \\frac{\\partial f}{\\partial \\nabla\\phi} \\cdot \\frac{\\partial (\\nabla\\phi)}{\\partial t} \\right) \\,dx\n$$\nWe can commute the spatial and temporal derivatives in the second term, $\\frac{\\partial (\\nabla\\phi)}{\\partial t} = \\nabla(\\frac{\\partial \\phi}{\\partial t})$. The expression becomes:\n$$\n\\frac{dF}{dt} = \\int_{\\Omega} \\left( \\frac{\\partial f}{\\partial \\phi} \\partial_t\\phi + \\frac{\\partial f}{\\partial \\nabla\\phi} \\cdot \\nabla(\\partial_t\\phi) \\right) \\,dx\n$$\nApplying integration by parts to the second term, $\\int u \\cdot \\nabla v \\,dx = [u \\cdot v]_{\\partial\\Omega} - \\int (\\nabla \\cdot u) v \\,dx$, with $u = \\frac{\\partial f}{\\partial \\nabla\\phi}$ and $v = \\partial_t\\phi$:\n$$\n\\int_{\\Omega} \\frac{\\partial f}{\\partial \\nabla\\phi} \\cdot \\nabla(\\partial_t\\phi) \\,dx = \\left[ \\frac{\\partial f}{\\partial \\nabla\\phi} \\cdot \\partial_t\\phi \\right]_{\\partial\\Omega} - \\int_{\\Omega} \\left( \\nabla \\cdot \\frac{\\partial f}{\\partial \\nabla\\phi} \\right) \\partial_t\\phi \\,dx\n$$\nThe boundary term vanishes due to the specified periodic boundary conditions on $\\Omega = [0,L]$. Substituting this back, we can factor out $\\partial_t\\phi$:\n$$\n\\frac{dF}{dt} = \\int_{\\Omega} \\left( \\frac{\\partial f}{\\partial \\phi} - \\nabla \\cdot \\frac{\\partial f}{\\partial \\nabla\\phi} \\right) \\partial_t\\phi \\,dx\n$$\nThe term in the parenthesis is precisely the definition of the variational derivative (or chemical potential) $\\mu = \\frac{\\delta F}{\\delta \\phi}$. Thus, we arrive at the general relationship for the rate of change of energy:\n$$\n\\frac{dF}{dt} = \\int_{\\Omega} \\mu \\, \\partial_t\\phi \\,dx\n$$\nThis expression is equivalent to the $L^2$ inner product $\\langle \\mu, \\partial_t\\phi \\rangle_{L^2}$. Now we can analyze the two specific gradient flows.\n\n**1. Allen-Cahn ($L^2$ Gradient Flow)**\nThe dynamics are given by $\\partial_t\\phi = -M\\mu$, where $M > 0$ is a constant mobility. Substituting this into our expression for $\\frac{dF}{dt}$:\n$$\n\\frac{dF}{dt} = \\int_{\\Omega} \\mu (-M\\mu) \\,dx = -M \\int_{\\Omega} \\mu^2 \\,dx\n$$\nSince $M > 0$ and the integrand $\\mu^2$ is non-negative, the integral $\\int_{\\Omega} \\mu^2 \\,dx \\ge 0$. Therefore,\n$$\n\\frac{dF}{dt} \\le 0\n$$\nThis confirms that the free energy is nonincreasing along solutions of the Allen-Cahn equation.\n\n**2. Cahn-Hilliard ($H^{-1}$ Gradient Flow)**\nThe dynamics are given by $\\partial_t\\phi = \\nabla \\cdot (M \\nabla \\mu) = M \\Delta\\mu$ for constant $M$. Substituting this into the energy rate equation:\n$$\n\\frac{dF}{dt} = \\int_{\\Omega} \\mu (M \\Delta\\mu) \\,dx = M \\int_{\\Omega} \\mu \\Delta\\mu \\,dx\n$$\nWe again use integration by parts, specifically Green's first identity, $\\int u \\Delta v \\,dx = [u \\nabla v]_{\\partial \\Omega} - \\int \\nabla u \\cdot \\nabla v \\,dx$. With $u=v=\\mu$:\n$$\n\\int_{\\Omega} \\mu \\Delta\\mu \\,dx = [\\mu \\nabla \\mu]_{\\partial \\Omega} - \\int_{\\Omega} |\\nabla\\mu|^2 \\,dx\n$$\nThe boundary term vanishes due to periodic boundary conditions. The expression for the rate of change of energy becomes:\n$$\n\\frac{dF}{dt} = -M \\int_{\\Omega} |\\nabla\\mu|^2 \\,dx\n$$\nSince $M > 0$ and the integrand $|\\nabla\\mu|^2$ is non-negative, the integral $\\int_{\\Omega} |\\nabla\\mu|^2 \\,dx \\ge 0$. Therefore,\n$$\n\\frac{dF}{dt} \\le 0\n$$\nThis confirms that the free energy is also nonincreasing along solutions of the Cahn-Hilliard equation. Both equations represent dissipative dynamics that drive the system towards a state of lower free energy.\n\n### Task B: Numerical Diagnostic Design\n\nThe numerical implementation and diagnostic tool are designed based on the provided specifications.\n\n**Spatial Discretization and Derivatives:**\nThe one-dimensional domain $\\Omega=[0,L]$ is discretized into a uniform grid of $N_x$ points, $x_j = j \\Delta x$ for $j = 0, 1, \\ldots, N_x-1$, with grid spacing $\\Delta x = L/N_x$. Spatial derivatives are computed spectrally using the Fast Fourier Transform (FFT). The $n$-th derivative of a periodic function $\\psi(x)$ is computed in Fourier space via the relation $\\mathcal{F}(\\frac{d^n\\psi}{dx^n}) = (ik)^n \\hat{\\psi}(k)$, where $\\hat{\\psi}(k) = \\mathcal{F}(\\psi(x))$ is the discrete Fourier transform of $\\psi$ and $k$ are the discrete wave numbers. The inverse FFT then returns the derivative in real space. This method is highly accurate for smooth, periodic functions.\n\n**Energy Calculation:**\nThe free energy functional $F[\\phi]$ is an integral, which is numerically approximated using the composite trapezoidal rule. For a periodic function sampled on a uniform grid, this rule simplifies to the sum of the integrand values at the grid points, scaled by the grid spacing $\\Delta x$.\n$$\nF^n = F[\\phi^n] \\approx \\Delta x \\sum_{j=0}^{N_x-1} \\left( \\frac{\\varepsilon^2}{2}\\,|(\\nabla \\phi^n)_j|^2 \\;+\\; \\frac{1}{4}\\,((\\phi_j^n)^2-1)^2 \\right)\n$$\nHere, $(\\nabla \\phi^n)_j$ represents the first spatial derivative of $\\phi^n$ at grid point $j$, computed spectrally.\n\n**Time-Stepping and Diagnostic:**\nThe evolution of the phase field $\\phi$ is simulated using the explicit forward Euler method with a time step $\\Delta t$. The core of the diagnostic is a loop that iterates for $N_{\\text{steps}}$. In each step $n$:\n1.  **Compute Chemical Potential:** Given the current state $\\phi^n$, the chemical potential $\\mu^n$ is calculated at each grid point:\n    $$\n    \\mu^n = -\\varepsilon^2 \\Delta \\phi^n + (\\phi^n)^3 - \\phi^n\n    $$\n    The Laplacian $\\Delta \\phi^n$ is computed spectrally.\n2.  **Update Phase Field:** The field is advanced to the next time step, $\\phi^{n+1}$.\n    -   For Allen-Cahn: $\\phi^{n+1} = \\phi^n - \\Delta t M \\mu^n$.\n    -   For Cahn-Hilliard: $\\phi^{n+1} = \\phi^n + \\Delta t M \\Delta \\mu^n$. The Laplacian of the chemical potential, $\\Delta \\mu^n$, is also computed spectrally.\n3.  **Compute Energies:** The energy of the current state, $F^n=F[\\phi^n]$, and the new state, $F^{n+1}=F[\\phi^{n+1}]$, are computed using the trapezoidal rule described above.\n4.  **Compute Energy Slope:** The discrete rate of energy change, or slope, is calculated as:\n    $$\n    s^n = \\frac{F^{n+1} - F^n}{\\Delta t}\n    $$\n5.  **Update Diagnostics:** The computed slope $s^n$ is compared against the theoretical expectation ($s^n \\le 0$).\n    -   The maximum positive slope observed throughout the simulation is updated: $\\max_{\\text{pos_slope}} \\leftarrow \\max(\\max_{\\text{pos_slope}}, s^n)$.\n    -   If $s^n$ exceeds a small tolerance $\\tau = 10^{-12}$ (to account for floating-point inaccuracies), a \"violation\" of the energy dissipation principle is counted.\n\nThis procedure is repeated for all time steps. The final diagnostic output for each test case consists of the overall maximum positive slope and the total count of violations. The forward Euler scheme is known to be only conditionally stable and is not guaranteed to be energy-dissipative, so violations are expected, particularly for larger time steps. The test cases are designed to expose this numerical instability.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(flow, Nx, L, dt, N_steps, init, M, epsilon, tau):\n    \"\"\"\n    Runs a single phase-field simulation and returns diagnostic results.\n    \"\"\"\n    # 1. Setup grid and wave numbers\n    dx = L / Nx\n    x = np.linspace(0, L, Nx, endpoint=False)\n    k = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n\n    # 2. Set initial condition\n    if init == 'nontrivial':\n        phi_n = 0.2 * np.sin(2 * np.pi * x / L) + 0.1 * np.cos(6 * np.pi * x / L)\n    elif init == 'constant':\n        phi_n = np.ones(Nx)\n    else:\n        raise ValueError(\"Unknown initialization type\")\n\n    # 3. Initialize diagnostic variables\n    max_pos_slope = 0.0\n    violation_count = 0\n\n    # 4. Helper function for energy calculation\n    def compute_energy(phi, k_vec, eps, dx_val):\n        phi_hat = np.fft.fft(phi)\n        \n        # Gradient term in Fourier space\n        grad_phi_hat = 1j * k_vec * phi_hat\n        grad_phi = np.fft.ifft(grad_phi_hat).real\n        \n        # Potential term\n        potential = 0.25 * (phi**2 - 1)**2\n        \n        # Integrate using trapezoidal rule (sum * dx for periodic)\n        energy = dx_val * np.sum(0.5 * eps**2 * grad_phi**2 + potential)\n        return energy\n\n    # Initial energy\n    F_n = compute_energy(phi_n, k, epsilon, dx)\n\n    # 5. Time-stepping loop\n    for _ in range(N_steps):\n        # Calculate chemical potential mu_n\n        phi_n_hat = np.fft.fft(phi_n)\n        \n        # Laplacian of phi\n        lap_phi_n_hat = -(k**2) * phi_n_hat\n        lap_phi_n = np.fft.ifft(lap_phi_n_hat).real\n        \n        # mu_n = -epsilon^2 * Delta(phi_n) + phi_n^3 - phi_n\n        mu_n = -epsilon**2 * lap_phi_n + phi_n**3 - phi_n\n\n        # Update phi_n to phi_np1 based on flow type\n        if flow == 'Allen-Cahn':\n            phi_np1 = phi_n - dt * M * mu_n\n        elif flow == 'Cahn-Hilliard':\n            mu_n_hat = np.fft.fft(mu_n)\n            \n            # Laplacian of mu\n            lap_mu_n_hat = -(k**2) * mu_n_hat\n            lap_mu_n = np.fft.ifft(lap_mu_n_hat).real\n            \n            phi_np1 = phi_n + dt * M * lap_mu_n\n        \n        # Calculate new energy F_{n+1}\n        F_np1 = compute_energy(phi_np1, k, epsilon, dx)\n\n        # Calculate discrete energy slope\n        slope = (F_np1 - F_n) / dt\n\n        # Update diagnostics\n        if slope > tau:\n            violation_count += 1\n        \n        if slope > max_pos_slope:\n            max_pos_slope = slope\n            \n        # Update state for next iteration\n        phi_n = phi_np1\n        F_n = F_np1\n\n    return max_pos_slope, violation_count\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    M = 1.0\n    epsilon = 0.05\n    tau = 1.0e-12\n\n    test_cases = [\n        # (flow, Nx, L, dt, N_steps, init)\n        ('Allen-Cahn', 128, 1.0, 1e-4, 200, 'nontrivial'),\n        ('Allen-Cahn', 128, 1.0, 1e-2, 60, 'nontrivial'),\n        ('Cahn-Hilliard', 128, 1.0, 1e-6, 300, 'nontrivial'),\n        ('Cahn-Hilliard', 128, 1.0, 1e-3, 100, 'nontrivial'),\n        ('Allen-Cahn', 128, 1.0, 1e-2, 40, 'constant'),\n    ]\n\n    results = []\n    for case in test_cases:\n        flow, Nx, L, dt, N_steps, init = case\n        \n        max_slope, v_count = run_simulation(\n            flow, Nx, L, dt, N_steps, init, M, epsilon, tau\n        )\n        \n        results.append(max_slope)\n        results.append(v_count)\n\n    # Final print statement in the exact required format.\n    # We use a custom format function to avoid scientific notation for small numbers.\n    def format_float(f):\n        return f'{f:.16f}'.rstrip('0').rstrip('.') if '.' in f'{f:.16f}' else f'{f:.1f}'\n\n    # Use map(str,...) because some results are int and some are float.\n    # The format required is a simple conversion to string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having established the principle of energy dissipation, we now turn to constructing more physically realistic energy functionals. The simplest phase-field models assume the gradient energy coefficient, $\\kappa$, is a constant, implying that the cost of creating an interface is independent of the compositions it separates. This practice challenges you to move beyond this simplification by considering a composition-dependent gradient energy, $\\kappa(c)$ . You will use the calculus of variations to derive the modified chemical potential and then implement a numerical study to quantitatively investigate how different forms of $\\kappa(c)$ influence measurable properties like interfacial width and energy, providing a direct link between the model's formulation and its physical predictions.",
            "id": "3476377",
            "problem": "You are tasked with deriving and implementing the chemical potential for a composition-dependent gradient energy coefficient within the Cahn-Hilliard framework and then quantitatively testing its impact on one-dimensional planar interfacial profiles. Work entirely in dimensionless units.\n\nBegin from the free energy functional\n$$\n\\mathcal{F}[c] = \\int_{\\Omega} \\left( f(c) + \\frac{1}{2}\\,\\kappa(c)\\,|\\nabla c|^2 \\right)\\, \\mathrm{d}\\mathbf{x},\n$$\nwhere $ c(\\mathbf{x}) $ is the composition field, $ f(c) $ is a local bulk free energy density, and $ \\kappa(c) $ is a composition-dependent gradient energy coefficient. The chemical potential is defined as the variational derivative $ \\mu = \\delta \\mathcal{F}/\\delta c $. Using calculus of variations and fundamental identities, derive the explicit form of $ \\mu $ for the case where $ \\kappa(c) $ is not constant. Then, for a one-dimensional, planar, equilibrium interface connecting two coexisting minima $ c_- $ and $ c_+ $ of the bulk free energy, exploit translational invariance to obtain a first integral that reduces the equilibrium profile condition to a single quadrature in $ c $ and use it to compute two quantitative metrics: a $ 10\\text{–}90 $ interfacial width and the interfacial energy per unit area. Your derivation must start from the provided functional form and established definitions, and it must not assume any shortcut formula without justification.\n\nAssume a symmetric double-well bulk free energy density given by\n$$\nf(c) = \\frac{A}{4}\\,(c^2 - 1)^2,\n$$\nwith $ A > 0 $, so that the two coexisting bulk compositions are $ c_- = -1 $ and $ c_+ = +1 $, and the bulk free energy at either minimum is $ f(c_{\\pm}) = 0 $. All quantities are dimensionless.\n\nImplementation requirements:\n- Use the derived expression for $ \\mu $ and the one-dimensional equilibrium reduction to construct the requisite quadratures for the $ 10\\text{–}90 $ interfacial width\n$$\nw_{10\\text{–}90} = \\int_{c=-0.9}^{c=+0.9} \\sqrt{\\frac{\\kappa(c)}{2\\,f(c)}}\\, \\mathrm{d}c,\n$$\nand the interfacial energy per unit area\n$$\n\\gamma = \\int_{c=-1}^{c=+1} \\sqrt{2\\,f(c)\\,\\kappa(c)}\\, \\mathrm{d}c.\n$$\nThese expressions must be obtained and justified in your solution starting from first principles.\n\n- Write a complete, runnable program that:\n  1. Implements $ f(c) $ and $ \\kappa(c) $ for each test case.\n  2. Evaluates the above quadratures numerically in one dimension.\n  3. Produces the required outputs for the specified test suite.\n\nTest suite:\n- Case $ 1 $ (baseline, “happy path”): constant gradient energy,\n  $ \\kappa(c) = \\kappa_0 $ with $ A = 1.0 $ and $ \\kappa_0 = 1.0 $.\n- Case $ 2 $ (composition-dependent increasing): polynomial increase with composition magnitude,\n  $ \\kappa(c) = \\kappa_0\\,(1 + \\alpha\\,c^2) $ with $ A = 1.0 $, $ \\kappa_0 = 1.0 $, and $ \\alpha = 2.0 $.\n- Case $ 3 $ (composition-dependent decreasing): reciprocal decrease with composition magnitude,\n  $ \\kappa(c) = \\dfrac{\\kappa_0}{1 + \\beta\\,c^2} $ with $ A = 1.0 $, $ \\kappa_0 = 1.0 $, and $ \\beta = 2.0 $.\n\nOutput specification:\n- Your program must compute, for each case, the pair $ [w_{10\\text{–}90}, \\gamma] $ as dimensionless floats.\n- The final output must be a single line containing a comma-separated list of these pairs in the exact format\n$$\n\\texttt{[[w_1,\\gamma_1],[w_2,\\gamma_2],[w_3,\\gamma_3]]}\n$$\nwith no spaces anywhere in the line. Here $ w_i $ and $ \\gamma_i $ denote the results for Case $ i $. Express the outputs as floats. There are no physical units since all quantities are dimensionless.\n\nDesign coverage:\n- The baseline Case $ 1 $ verifies the constant $ \\kappa $ behavior for a symmetric double-well.\n- Case $ 2 $ probes the effect of larger gradient penalties near $ |c| \\approx 1 $, which tends to broaden interfaces and increase interfacial energy.\n- Case $ 3 $ probes the effect of reduced gradient penalties near $ |c| \\approx 1 $, which tends to sharpen interfaces and reduce interfacial energy.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets and structured exactly as described above, for example:\n$$\n\\texttt{[[result\\_w1,result\\_g1],[result\\_w2,result\\_g2],[result\\_w3,result\\_g3]]}.\n$$",
            "solution": "The problem requires the derivation of the chemical potential and equilibrium interface properties for a Cahn-Hilliard system with a composition-dependent gradient energy coefficient, followed by a numerical implementation to compute interfacial width and energy for three specific cases.\n\n### Step 1: Derivation of the Chemical Potential, $ \\mu $\n\nThe system's total free energy is given by the functional:\n$$\n\\mathcal{F}[c] = \\int_{\\Omega} \\left( f(c) + \\frac{1}{2}\\,\\kappa(c)\\,|\\nabla c|^2 \\right)\\, \\mathrm{d}\\mathbf{x}\n$$\nThe chemical potential $ \\mu $ is defined as the variational (or functional) derivative of the free energy functional $ \\mathcal{F} $ with respect to the composition field $ c $, denoted as $ \\mu = \\dfrac{\\delta \\mathcal{F}}{\\delta c} $. The variation $ \\delta \\mathcal{F} $ is defined such that:\n$$\n\\delta \\mathcal{F} = \\int_{\\Omega} \\frac{\\delta \\mathcal{F}}{\\delta c} \\delta c \\, \\mathrm{d}\\mathbf{x} = \\int_{\\Omega} \\mu \\, \\delta c \\, \\mathrm{d}\\mathbf{x}\n$$\nWe compute the variation $ \\delta \\mathcal{F} $ by considering a small perturbation $ \\delta c $ to the field $ c $.\n$$\n\\delta \\mathcal{F} = \\mathcal{F}[c + \\delta c] - \\mathcal{F}[c] = \\int_{\\Omega} \\left[ \\delta f(c) + \\delta \\left( \\frac{1}{2}\\,\\kappa(c)\\,|\\nabla c|^2 \\right) \\right] \\mathrm{d}\\mathbf{x}\n$$\nThe variation of the first term is:\n$$\n\\delta f(c) = f(c + \\delta c) - f(c) = \\frac{\\mathrm{d}f}{\\mathrm{d}c} \\delta c = f'(c) \\, \\delta c\n$$\nThe variation of the second term is found using the product rule:\n$$\n\\delta \\left( \\frac{1}{2}\\,\\kappa(c)\\,|\\nabla c|^2 \\right) = \\frac{1}{2} \\left[ (\\delta \\kappa(c)) |\\nabla c|^2 + \\kappa(c) \\delta(|\\nabla c|^2) \\right]\n$$\nwhere $ |\\nabla c|^2 = \\nabla c \\cdot \\nabla c $. The variations are:\n$$\n\\delta \\kappa(c) = \\frac{\\mathrm{d}\\kappa}{\\mathrm{d}c} \\delta c = \\kappa'(c) \\, \\delta c\n$$\n$$\n\\delta (|\\nabla c|^2) = \\nabla(c+\\delta c) \\cdot \\nabla(c+\\delta c) - \\nabla c \\cdot \\nabla c = 2 \\nabla c \\cdot \\nabla(\\delta c) + O((\\delta c)^2)\n$$\nSubstituting these back into the variation of the second term:\n$$\n\\delta \\left( \\frac{1}{2}\\,\\kappa(c)\\,|\\nabla c|^2 \\right) = \\frac{1}{2} \\left[ \\kappa'(c) |\\nabla c|^2 \\delta c + \\kappa(c) (2 \\nabla c \\cdot \\nabla(\\delta c)) \\right] = \\frac{1}{2}\\kappa'(c) |\\nabla c|^2 \\delta c + \\kappa(c) \\nabla c \\cdot \\nabla(\\delta c)\n$$\nCombining the terms, the total variation $ \\delta \\mathcal{F} $ is:\n$$\n\\delta \\mathcal{F} = \\int_{\\Omega} \\left( f'(c)\\,\\delta c + \\frac{1}{2}\\kappa'(c) |\\nabla c|^2 \\delta c + \\kappa(c) \\nabla c \\cdot \\nabla(\\delta c) \\right) \\mathrm{d}\\mathbf{x}\n$$\nThe last term requires integration by parts. Using the vector identity $ \\nabla \\cdot (\\phi \\mathbf{V}) = (\\nabla \\phi) \\cdot \\mathbf{V} + \\phi (\\nabla \\cdot \\mathbf{V}) $, we can write $ \\nabla(\\delta c) \\cdot (\\kappa(c)\\nabla c) = \\nabla \\cdot (\\delta c \\, \\kappa(c)\\nabla c) - \\delta c \\, \\nabla \\cdot (\\kappa(c)\\nabla c) $. Integrating over the domain $ \\Omega $:\n$$\n\\int_{\\Omega} \\kappa(c) \\nabla c \\cdot \\nabla(\\delta c) \\, \\mathrm{d}\\mathbf{x} = \\int_{\\Omega} \\nabla \\cdot (\\delta c \\, \\kappa(c)\\nabla c) \\, \\mathrm{d}\\mathbf{x} - \\int_{\\Omega} \\delta c \\, \\nabla \\cdot (\\kappa(c)\\nabla c) \\, \\mathrm{d}\\mathbf{x}\n$$\nBy the divergence theorem, the first term on the right becomes a surface integral $ \\int_{\\partial \\Omega} (\\delta c \\, \\kappa(c)\\nabla c) \\cdot \\mathrm{d}\\mathbf{S} $. Assuming natural boundary conditions ($ \\nabla c \\cdot \\mathbf{n} = 0 $ on $ \\partial \\Omega $) or that $ \\delta c = 0 $ on the boundary, this term vanishes. We are left with:\n$$\n\\int_{\\Omega} \\kappa(c) \\nabla c \\cdot \\nabla(\\delta c) \\, \\mathrm{d}\\mathbf{x} = - \\int_{\\Omega} \\delta c \\, \\nabla \\cdot (\\kappa(c)\\nabla c) \\, \\mathrm{d}\\mathbf{x}\n$$\nSubstituting this back into the expression for $ \\delta \\mathcal{F} $:\n$$\n\\delta \\mathcal{F} = \\int_{\\Omega} \\left( f'(c) + \\frac{1}{2}\\kappa'(c) |\\nabla c|^2 - \\nabla \\cdot (\\kappa(c)\\nabla c) \\right) \\delta c \\, \\mathrm{d}\\mathbf{x}\n$$\nBy comparing this with the definition $ \\delta \\mathcal{F} = \\int_{\\Omega} \\mu \\, \\delta c \\, \\mathrm{d}\\mathbf{x} $, we identify the chemical potential:\n$$\n\\mu = f'(c) + \\frac{1}{2}\\kappa'(c) |\\nabla c|^2 - \\nabla \\cdot (\\kappa(c)\\nabla c)\n$$\nLet's expand the divergence term: $ \\nabla \\cdot (\\kappa(c)\\nabla c) = \\nabla\\kappa(c) \\cdot \\nabla c + \\kappa(c) \\nabla^2 c $. Since $ \\kappa $ is a function of $ c $, we have $ \\nabla\\kappa(c) = \\kappa'(c)\\nabla c $, so $ \\nabla \\cdot (\\kappa(c)\\nabla c) = \\kappa'(c)|\\nabla c|^2 + \\kappa(c)\\nabla^2 c $. Substituting this into the expression for $ \\mu $:\n$$\n\\mu = f'(c) + \\frac{1}{2}\\kappa'(c) |\\nabla c|^2 - \\left(\\kappa'(c)|\\nabla c|^2 + \\kappa(c)\\nabla^2 c\\right)\n$$\n$$\n\\mu = f'(c) - \\kappa(c)\\nabla^2 c - \\frac{1}{2}\\kappa'(c)|\\nabla c|^2\n$$\nThis is the final expression for the chemical potential for a composition-dependent gradient energy coefficient.\n\n### Step 2: One-Dimensional Equilibrium and Derivation of Quadratures\n\nFor a one-dimensional, planar interface at equilibrium, the chemical potential must be constant, $ \\mu = \\mu_0 $. The system is at equilibrium with the bulk phases at $ c = c_{\\pm} = \\pm 1 $, where gradients are zero. The bulk chemical potential is $ \\mu_{bulk} = f'(c_{\\pm}) $. For the given bulk free energy $ f(c) = \\frac{A}{4}(c^2 - 1)^2 $, its derivative is $ f'(c) = A c(c^2 - 1) $. At $ c=\\pm 1 $, $ f'(c) = 0 $, so the equilibrium chemical potential is $ \\mu_0 = 0 $.\n\nThe equilibrium condition in one dimension ($ x $) is $ \\mu = 0 $:\n$$\nf'(c) - \\kappa(c)\\frac{\\mathrm{d}^2 c}{\\mathrm{d}x^2} - \\frac{1}{2}\\kappa'(c)\\left(\\frac{\\mathrm{d}c}{\\mathrm{d}x}\\right)^2 = 0\n$$\nTo find a first integral of this second-order ODE, we appeal to the principle of translational invariance in one dimension. For a system described by a Lagrangian $ L(c, c') $ that does not explicitly depend on the spatial coordinate $ x $, there exists a conserved quantity (a first integral) given by $ c' \\frac{\\partial L}{\\partial c'} - L = \\text{const} $. In our case, the integrand of the free energy functional, $ \\mathcal{L} = f(c) + \\frac{1}{2}\\kappa(c)(c')^2 $, acts as the Lagrangian.\n\nWe compute the conserved quantity:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial c'} = \\kappa(c)c'\n$$\nThe conserved quantity is:\n$$\nc'(\\kappa(c)c') - \\left(f(c) + \\frac{1}{2}\\kappa(c)(c')^2\\right) = \\kappa(c)(c')^2 - f(c) - \\frac{1}{2}\\kappa(c)(c')^2 = \\frac{1}{2}\\kappa(c)(c')^2 - f(c)\n$$\nSo, $ \\frac{1}{2}\\kappa(c)\\left(\\frac{\\mathrm{d}c}{\\mathrm{d}x}\\right)^2 - f(c) = \\text{const} $. We determine the constant by evaluating this expression in the bulk, far from the interface, where $ c \\to c_{\\pm} = \\pm 1 $ and $ \\frac{\\mathrm{d}c}{\\mathrm{d}x} \\to 0 $. In the bulk, $ f(c_{\\pm}) = 0 $. Therefore, the constant is $ 0 $, yielding the first integral:\n$$\n\\frac{1}{2}\\kappa(c)\\left(\\frac{\\mathrm{d}c}{\\mathrm{d}x}\\right)^2 = f(c)\n$$\nThis relation connects the gradient of the composition to the local bulk free energy. From this, we solve for $ \\frac{\\mathrm{d}c}{\\mathrm{d}x} $, taking the positive root for an interface where $ c $ increases with $ x $:\n$$\n\\frac{\\mathrm{d}c}{\\mathrm{d}x} = \\sqrt{\\frac{2f(c)}{\\kappa(c)}}\n$$\nThis separable ODE can be written as $ \\mathrm{d}x = \\sqrt{\\frac{\\kappa(c)}{2f(c)}} \\mathrm{d}c $. This allows us to derive the required quadratures.\n\n**Interfacial Width, $ w_{10-90} $**: The $ 10\\text{–}90 $ width is the spatial distance over which the composition changes from $ c=-0.9 $ to $ c=0.9 $. By integrating $ \\mathrm{d}x $ between the corresponding compositions, we get:\n$$\nw_{10\\text{–}90} = \\int_{c=-0.9}^{c=0.9} \\mathrm{d}x = \\int_{-0.9}^{0.9} \\sqrt{\\frac{\\kappa(c)}{2f(c)}} \\mathrm{d}c\n$$\nThis confirms the expression provided in the problem statement.\n\n**Interfacial Energy, $ \\gamma $**: The interfacial energy per unit area is the excess free energy of the interface compared to the bulk. Since the bulk free energy is $ f(c_{\\pm}) = 0 $, this is:\n$$\n\\gamma = \\int_{-\\infty}^{\\infty} \\left( f(c(x)) + \\frac{1}{2}\\kappa(c(x))\\left(\\frac{\\mathrm{d}c}{\\mathrm{d}x}\\right)^2 \\right) \\mathrm{d}x\n$$\nUsing the first integral $ \\frac{1}{2}\\kappa(c)\\left(\\frac{\\mathrm{d}c}{\\mathrm{d}x}\\right)^2 = f(c) $, the integrand simplifies to $ f(c) + f(c) = 2f(c) $.\n$$\n\\gamma = \\int_{-\\infty}^{\\infty} 2f(c(x)) \\mathrm{d}x\n$$\nTo evaluate this integral, we change the integration variable from $ x $ to $ c $, using $ \\mathrm{d}x = \\sqrt{\\frac{\\kappa(c)}{2f(c)}} \\mathrm{d}c $. The integration limits in $ x $ from $ -\\infty $ to $ +\\infty $ correspond to $ c $ from $ -1 $ to $ +1 $.\n$$\n\\gamma = \\int_{-1}^{1} 2f(c) \\sqrt{\\frac{\\kappa(c)}{2f(c)}} \\mathrm{d}c = \\int_{-1}^{1} \\sqrt{4f(c)^2 \\frac{\\kappa(c)}{2f(c)}} \\mathrm{d}c = \\int_{-1}^{1} \\sqrt{2f(c)\\kappa(c)} \\mathrm{d}c\n$$\nThis also confirms the expression provided in the problem statement.\n\n### Step 3: Numerical Evaluation\n\nWe now proceed to the numerical evaluation of the derived integrals for the three test cases using the specified parameters. All cases use $ A=1.0 $. The bulk free energy is $ f(c) = \\frac{1}{4}(c^2-1)^2 $.\n\n**Case 1 (Constant $ \\kappa $):** $ \\kappa(c) = \\kappa_0 = 1.0 $.\n$$\nw_{10\\text{–}90} = \\int_{-0.9}^{0.9} \\sqrt{\\frac{1.0}{2 \\cdot \\frac{1}{4}(c^2-1)^2}} \\mathrm{d}c = \\int_{-0.9}^{0.9} \\frac{\\sqrt{2}}{1-c^2} \\mathrm{d}c\n$$\n$$\n\\gamma = \\int_{-1}^{1} \\sqrt{2 \\cdot \\frac{1}{4}(c^2-1)^2 \\cdot 1.0} \\mathrm{d}c = \\int_{-1}^{1} \\frac{1-c^2}{\\sqrt{2}} \\mathrm{d}c\n$$\n\n**Case 2 (Increasing $ \\kappa $):** $ \\kappa(c) = \\kappa_0(1+\\alpha c^2) = 1.0(1+2.0c^2) $.\n$$\nw_{10\\text{–}90} = \\int_{-0.9}^{0.9} \\sqrt{\\frac{1+2c^2}{2 \\cdot \\frac{1}{4}(c^2-1)^2}} \\mathrm{d}c = \\int_{-0.9}^{0.9} \\frac{\\sqrt{2(1+2c^2)}}{1-c^2} \\mathrm{d}c\n$$\n$$\n\\gamma = \\int_{-1}^{1} \\sqrt{2 \\cdot \\frac{1}{4}(c^2-1)^2 \\cdot (1+2c^2)} \\mathrm{d}c = \\int_{-1}^{1} \\frac{(1-c^2)\\sqrt{1+2c^2}}{\\sqrt{2}} \\mathrm{d}c\n$$\n\n**Case 3 (Decreasing $ \\kappa $):** $ \\kappa(c) = \\frac{\\kappa_0}{1+\\beta c^2} = \\frac{1.0}{1+2.0c^2} $.\n$$\nw_{10\\text{–}90} = \\int_{-0.9}^{0.9} \\sqrt{\\frac{1/(1+2c^2)}{2 \\cdot \\frac{1}{4}(c^2-1)^2}} \\mathrm{d}c = \\int_{-0.9}^{0.9} \\frac{\\sqrt{2}}{(1-c^2)\\sqrt{1+2c^2}} \\mathrm{d}c\n$$\n$$\n\\gamma = \\int_{-1}^{1} \\sqrt{2 \\cdot \\frac{1}{4}(c^2-1)^2 \\cdot \\frac{1}{1+2c^2}} \\mathrm{d}c = \\int_{-1}^{1} \\frac{1-c^2}{\\sqrt{2(1+2c^2)}} \\mathrm{d}c\n$$\nThese integrals are evaluated numerically using Python.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Derives and computes interfacial properties for a Cahn-Hilliard system\n    with composition-dependent gradient energy coefficient.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'name': 'constant', 'A': 1.0, 'k0': 1.0},\n        {'name': 'increasing', 'A': 1.0, 'k0': 1.0, 'alpha': 2.0},\n        {'name': 'decreasing', 'A': 1.0, 'k0': 1.0, 'beta': 2.0},\n    ]\n\n    results = []\n    \n    # Common bulk free energy density function\n    def f(c, A):\n        return (A / 4.0) * (c**2 - 1.0)**2\n\n    # Composition-dependent gradient energy coefficient\n    def kappa(c, case):\n        if case['name'] == 'constant':\n            return case['k0']\n        elif case['name'] == 'increasing':\n            return case['k0'] * (1.0 + case['alpha'] * c**2)\n        elif case['name'] == 'decreasing':\n            return case['k0'] / (1.0 + case['beta'] * c**2)\n        else:\n            raise ValueError(\"Unknown case name\")\n            \n    for case in test_cases:\n        A = case['A']\n        \n        # Integrand for the 10-90 interfacial width\n        def integrand_w(c, case_params):\n            # The denominator has (c^2-1)^2 which becomes (1-c^2)^2 as c is in [-0.9, 0.9]\n            # Sqrt of f(c) contains |c^2 - 1| = 1 - c^2 for c in (-1, 1).\n            # The integrand is sqrt(kappa(c) / (2*f(c)))\n            f_val = f(c, A)\n            # Avoid division by zero at the exact limits, though quad handles it.\n            if f_val == 0.0:\n                return np.inf\n            kappa_val = kappa(c, case_params)\n            return np.sqrt(kappa_val / (2.0 * f_val))\n\n        # Integrand for the interfacial energy\n        def integrand_gamma(c, case_params):\n            # The integrand is sqrt(2 * f(c) * kappa(c))\n            f_val = f(c, A)\n            kappa_val = kappa(c, case_params)\n            return np.sqrt(2.0 * f_val * kappa_val)\n\n        # Numerical integration using scipy.integrate.quad\n        w_10_90, _ = quad(integrand_w, -0.9, 0.9, args=(case,))\n        gamma, _ = quad(integrand_gamma, -1.0, 1.0, args=(case,))\n        \n        results.append(f\"[{w_10_90},{gamma}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Phase-field dynamics are typically categorized as either non-conserved (governed by the Allen-Cahn equation) or conserved (governed by the Cahn-Hilliard equation), depending on whether the total quantity of the order parameter must remain constant. This final practice explores a sophisticated technique that blurs this distinction: enforcing a global conservation law on an intrinsically non-conserved dynamic using a Lagrange multiplier. By deriving the form of this multiplier and implementing a robust numerical scheme, you will not only gain a deeper understanding of the mathematical structure of conservation laws but also acquire a powerful and versatile method for developing advanced, constrained phase-field models .",
            "id": "3476347",
            "problem": "Consider a nonconserved order parameter field $ \\phi(\\mathbf{x},t) $ evolving under an Allen–Cahn type gradient flow derived from a free-energy functional $ F[\\phi] $. To enforce global mass conservation of $ \\phi $, introduce a spatially uniform, time-dependent Lagrange multiplier $ \\lambda(t) $ and modify the dynamics to $ \\partial_t \\phi = -M \\left( \\delta F / \\delta \\phi - \\lambda(t) \\right) $, where $ M > 0 $ is a mobility constant. Assume a one-dimensional periodic domain of length $ L_x $ and consider the free-energy functional\n$$\nF[\\phi] = \\int_0^{L_x} \\left( \\frac{\\kappa}{2} \\left| \\nabla \\phi \\right|^2 + W(\\phi) \\right) \\, dx,\n$$\nwith interfacial stiffness $ \\kappa > 0 $ and a smooth double-well potential $ W(\\phi) = \\frac{1}{4}(\\phi^2 - 1)^2 $. The variational derivative $ \\delta F / \\delta \\phi $ is defined in the standard way via the calculus of variations.\n\nYour task is to derive, from first principles and without relying on any pre-specified closed-form expression, an explicit expression for the Lagrange multiplier $ \\lambda(t) $ that ensures global conservation of $ \\int_0^{L_x} \\phi(x,t) \\, dx $ for all $ t $ under periodic boundary conditions. Then, based on your derivation, design a numerically stable semi-implicit time-stepping scheme in one dimension that treats the linear interfacial term implicitly and the nonlinear bulk term explicitly, using a Fourier pseudospectral discretization for spatial derivatives on a uniform grid of $ N $ points. All quantities are dimensionless; report any computed values in dimensionless units.\n\nImplement a complete program that:\n1. Uses the derived semi-implicit scheme to evolve $ \\phi(x,t) $ in time on a periodic domain.\n2. Computes the absolute mass drift at final time $ T $, defined as $ \\left| \\int_0^{L_x} \\phi(x,T) \\, dx - \\int_0^{L_x} \\phi(x,0) \\, dx \\right| $.\n3. Produces a single line of output containing the absolute mass drift values for each test case in the test suite, as a comma-separated list enclosed in square brackets.\n\nThe test suite parameter sets are:\n\n- Test Case A (general case):\n  - Grid size $ N = 256 $, domain length $ L_x = 1.0 $, mobility $ M = 1.0 $, interfacial stiffness $ \\kappa = 0.01 $, time step $ \\Delta t = 10^{-4} $, final time $ T = 0.02 $.\n  - Initial condition $ \\phi(x,0) = 0.2 + 0.1 \\sin\\left( 2\\pi x / L_x \\right) + 0.05 \\sin\\left( 4\\pi x / L_x \\right) $.\n\n- Test Case B (uniform field boundary case):\n  - Grid size $ N = 128 $, domain length $ L_x = 1.0 $, mobility $ M = 1.0 $, interfacial stiffness $ \\kappa = 0.05 $, time step $ \\Delta t = 10^{-4} $, final time $ T = 0.01 $.\n  - Initial condition $ \\phi(x,0) = 0.3 $ (constant).\n\n- Test Case C (edge case with stronger interfacial stiffness and random initial condition):\n  - Grid size $ N = 256 $, domain length $ L_x = 1.0 $, mobility $ M = 0.5 $, interfacial stiffness $ \\kappa = 0.1 $, time step $ \\Delta t = 5 \\times 10^{-5} $, final time $ T = 0.01 $.\n  - Initial condition $ \\phi(x,0) $ is zero-mean random noise constructed as follows: draw independent samples $ \\eta_j \\sim \\mathcal{N}(0,1) $ for $ j = 0,\\dots,N-1 $ with a fixed pseudorandom seed, set $ \\phi_j = 0.2 \\eta_j $, and then subtract the spatial average so that $ \\int_0^{L_x} \\phi(x,0) \\, dx = 0 $.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $ [r_A,r_B,r_C] $), where each entry is the absolute mass drift for the corresponding test case expressed as a floating-point number in dimensionless units. No other output should be printed.",
            "solution": "The problem requires the derivation and implementation of a numerical solution to a modified Allen-Cahn equation, where a Lagrange multiplier enforces global mass conservation. The solution process is divided into two main parts: the analytical derivation of the Lagrange multiplier and the design of a stable numerical algorithm.\n\n**1. Derivation of the Lagrange Multiplier $ \\lambda(t) $**\n\nThe governing equation for the nonconserved order parameter $ \\phi(x,t) $ is given as\n$$ \\frac{\\partial \\phi}{\\partial t} = -M \\left( \\frac{\\delta F}{\\delta \\phi} - \\lambda(t) \\right) $$\nwhere $ M > 0 $ is a constant mobility and $ \\lambda(t) $ is a spatially uniform Lagrange multiplier. The purpose of $ \\lambda(t) $ is to enforce the global conservation of the total \"mass\" (the spatially integrated order parameter) $ \\mathcal{M}(t) = \\int_0^{L_x} \\phi(x,t) \\, dx $.\n\nThe conservation constraint implies that the time derivative of the total mass must be zero for all time $ t \\ge 0 $:\n$$ \\frac{d\\mathcal{M}}{dt} = \\frac{d}{dt} \\int_0^{L_x} \\phi(x,t) \\, dx = 0 $$\nAssuming that $ \\phi $ is sufficiently smooth to allow the interchange of differentiation and integration (Leibniz integral rule), we have:\n$$ \\int_0^{L_x} \\frac{\\partial \\phi}{\\partial t} \\, dx = 0 $$\nSubstituting the governing equation for $ \\partial \\phi / \\partial t $:\n$$ \\int_0^{L_x} -M \\left( \\frac{\\delta F}{\\delta \\phi} - \\lambda(t) \\right) \\, dx = 0 $$\nSince $ M $ is a positive constant, it can be eliminated from the equation. The integral can then be split into two parts:\n$$ \\int_0^{L_x} \\frac{\\delta F}{\\delta \\phi} \\, dx - \\int_0^{L_x} \\lambda(t) \\, dx = 0 $$\nThe Lagrange multiplier $ \\lambda(t) $ is spatially uniform by definition, so it can be factored out of the second integral:\n$$ \\int_0^{L_x} \\frac{\\delta F}{\\delta \\phi} \\, dx - \\lambda(t) \\int_0^{L_x} \\, dx = 0 $$\nThe remaining integral is simply the length of the domain, $ L_x $.\n$$ \\int_0^{L_x} \\frac{\\delta F}{\\delta \\phi} \\, dx - \\lambda(t) L_x = 0 $$\nSolving for $ \\lambda(t) $ yields the general expression:\n$$ \\lambda(t) = \\frac{1}{L_x} \\int_0^{L_x} \\frac{\\delta F}{\\delta \\phi} \\, dx $$\nThis shows that $ \\lambda(t) $ is the spatial average of the chemical potential, $ \\mu \\equiv \\delta F / \\delta \\phi $.\n\nNext, we find the specific form of the chemical potential. The free-energy functional is\n$$ F[\\phi] = \\int_0^{L_x} \\left( \\frac{\\kappa}{2} \\left( \\frac{\\partial \\phi}{\\partial x} \\right)^2 + W(\\phi) \\right) \\, dx $$\nwhere $ \\kappa > 0 $ and $ W(\\phi) = \\frac{1}{4}(\\phi^2 - 1)^2 $. The variational derivative (or functional derivative) $ \\delta F / \\delta \\phi $ is found by calculating the first variation $ \\delta F $:\n$$ \\delta F = F[\\phi + \\delta\\phi] - F[\\phi] \\approx \\int_0^{L_x} \\left( \\kappa \\frac{\\partial \\phi}{\\partial x} \\frac{\\partial(\\delta\\phi)}{\\partial x} + W'(\\phi) \\delta\\phi \\right) \\, dx $$\nwhere $ W'(\\phi) = \\frac{d W}{d \\phi} = \\phi^3 - \\phi $. Integrating the first term by parts:\n$$ \\int_0^{L_x} \\kappa \\frac{\\partial \\phi}{\\partial x} \\frac{\\partial(\\delta\\phi)}{\\partial x} \\, dx = \\left[ \\kappa \\frac{\\partial \\phi}{\\partial x} \\delta\\phi \\right]_0^{L_x} - \\int_0^{L_x} \\kappa \\frac{\\partial^2 \\phi}{\\partial x^2} \\delta\\phi \\, dx $$\nDue to periodic boundary conditions on the domain $ [0, L_x] $, the boundary term $ \\left[ \\dots \\right]_0^{L_x} $ vanishes. Thus,\n$$ \\delta F = \\int_0^{L_x} \\left( -\\kappa \\frac{\\partial^2 \\phi}{\\partial x^2} + W'(\\phi) \\right) \\delta\\phi \\, dx $$\nBy definition, $ \\delta F = \\int_0^{L_x} (\\delta F / \\delta \\phi) \\delta\\phi \\, dx $, so we can identify the chemical potential:\n$$ \\frac{\\delta F}{\\delta \\phi} = -\\kappa \\frac{\\partial^2 \\phi}{\\partial x^2} + W'(\\phi) = -\\kappa \\nabla^2 \\phi + \\phi^3 - \\phi $$\nSubstituting this into the expression for $ \\lambda(t) $:\n$$ \\lambda(t) = \\frac{1}{L_x} \\int_0^{L_x} \\left( -\\kappa \\frac{\\partial^2 \\phi}{\\partial x^2} + \\phi^3 - \\phi \\right) \\, dx $$\nThe integral of the Laplacian term over a periodic domain is zero:\n$$ \\int_0^{L_x} \\frac{\\partial^2 \\phi}{\\partial x^2} \\, dx = \\left[ \\frac{\\partial \\phi}{\\partial x} \\right]_0^{L_x} = 0 $$\nThis leaves a simplified, explicit expression for the Lagrange multiplier that depends only on the current state of the field $ \\phi(x,t) $:\n$$ \\lambda(t) = \\frac{1}{L_x} \\int_0^{L_x} (\\phi(x,t)^3 - \\phi(x,t)) \\, dx $$\nThis is the spatial average of the nonlinear driving term $ W'(\\phi) $.\n\n**2. Numerical Algorithm: Semi-Implicit Fourier Pseudospectral Method**\n\nWith the derived expression for $ \\lambda(t) $, the full governing equation is:\n$$ \\frac{\\partial \\phi}{\\partial t} = M\\kappa \\nabla^2 \\phi - M(\\phi^3 - \\phi) + M \\lambda(t) $$\nThe term $ M\\kappa \\nabla^2 \\phi $ is linear but contains high-order spatial derivatives, making it stiff. To maintain numerical stability with reasonable time step sizes, this term must be treated implicitly. The term $ - M(\\phi^3 - \\phi) + M \\lambda(t) $ is nonlinear but local in space, and can be treated explicitly. This leads to a semi-implicit time-stepping scheme.\n\nUsing a first-order Euler-based semi-implicit scheme, we discretize in time from $ t_n = n \\Delta t $ to $ t_{n+1} = (n+1) \\Delta t $:\n$$ \\frac{\\phi^{n+1} - \\phi^n}{\\Delta t} = M\\kappa \\nabla^2 \\phi^{n+1} - M\\left((\\phi^n)^3 - \\phi^n\\right) + M \\lambda^n $$\nwhere $ \\phi^n $ represents $ \\phi(x, t_n) $ and $ \\lambda^n $ is computed from $ \\phi^n $:\n$$ \\lambda^n = \\frac{1}{L_x} \\int_0^{L_x} \\left((\\phi^n)^3 - \\phi^n\\right) \\, dx $$\nFor spatial discretization, we use a Fourier pseudospectral method. We represent $ \\phi(x,t) $ on a uniform grid of $ N $ points, $ x_j = j \\Delta x $ where $ \\Delta x = L_x / N $. In Fourier space, the field is represented by its coefficients $ \\hat{\\phi}(k) $, where $ k $ is the wavevector. The derivative operation $ \\nabla^2 $ becomes an algebraic multiplication by $ -k^2 $.\nLet $ \\hat{\\phi}^n(k) = \\mathcal{F}\\{\\phi^n(x)\\} $ be the Fast Fourier Transform (FFT) of $ \\phi^n $. Applying the FFT to the time-discretized equation yields:\n$$ \\frac{\\hat{\\phi}^{n+1} - \\hat{\\phi}^n}{\\Delta t} = M\\kappa (-k^2) \\hat{\\phi}^{n+1} + \\mathcal{F}\\left\\{- M\\left((\\phi^n)^3 - \\phi^n\\right) + M \\lambda^n\\right\\} $$\nLet $ R^n = - M((\\phi^n)^3 - \\phi^n) + M \\lambda^n $ be the explicit part of the right-hand side, computed in real space. The equation in Fourier space becomes:\n$$ \\frac{\\hat{\\phi}^{n+1} - \\hat{\\phi}^n}{\\Delta t} = -M\\kappa k^2 \\hat{\\phi}^{n+1} + \\hat{R}^n $$\nwhere $ \\hat{R}^n = \\mathcal{F}\\{R^n\\} $. We can now algebraically solve for the updated Fourier coefficients $ \\hat{\\phi}^{n+1} $:\n$$ \\hat{\\phi}^{n+1} (1 + \\Delta t M \\kappa k^2) = \\hat{\\phi}^n + \\Delta t \\hat{R}^n $$\n$$ \\hat{\\phi}^{n+1}(k) = \\frac{\\hat{\\phi}^n(k) + \\Delta t \\hat{R}^n(k)}{1 + \\Delta t M \\kappa k^2} $$\nThis equation gives the update rule for the field in Fourier space.\n\n**Summary of the computational procedure for one time step:**\n1. Given $ \\phi^n(x) $ at time $ t_n $.\n2. In real space, compute the nonlinear term $ W'(\\phi^n) = (\\phi^n)^3 - \\phi^n $.\n3. In real space, compute the Lagrange multiplier $ \\lambda^n = \\frac{1}{N} \\sum_{j=0}^{N-1} W'(\\phi_j^n) $, which is the discrete approximation of the spatial average $ \\frac{1}{L_x} \\int W'(\\phi^n) \\, dx $.\n4. In real space, compute the total explicit update term: $ R^n = -M W'(\\phi^n) + M \\lambda^n $.\n5. Transform the current state $ \\phi^n $ and the explicit term $ R^n $ to Fourier space to obtain $ \\hat{\\phi}^n $ and $ \\hat{R}^n $ using an FFT. For a real-valued field, a real FFT (`rfft`) is most efficient.\n6. Apply the update rule in Fourier space for all wavevectors $ k $ to find $ \\hat{\\phi}^{n+1} $.\n7. Transform $ \\hat{\\phi}^{n+1} $ back to real space using an inverse FFT (`irfft`) to obtain $ \\phi^{n+1}(x) $.\n8. Repeat for the desired number of time steps.\n\nThe absolute mass drift is then computed as $ \\left| \\sum_{j=0}^{N-1} \\phi_j(T) \\Delta x - \\sum_{j=0}^{N-1} \\phi_j(0) \\Delta x \\right| $. This scheme ensures that mass is conserved up to machine precision, as the derivation for $ \\lambda(t) $ exactly cancels the non-conserving part of the dynamics at the continuous level. Any observed drift is due to floating-point and time-discretization errors.",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(N, Lx, M, kappa, dt, T, phi_0_func, seed=None):\n    \"\"\"\n    Solves the conserved Allen-Cahn equation using a semi-implicit\n    Fourier pseudospectral method.\n\n    Args:\n        N (int): Number of grid points.\n        Lx (float): Length of the periodic domain.\n        M (float): Mobility constant.\n        kappa (float): Interfacial stiffness.\n        dt (float): Time step size.\n        T (float): Final time.\n        phi_0_func (callable): Function to generate the initial condition.\n        seed (int, optional): Seed for the random number generator.\n\n    Returns:\n        float: The absolute mass drift at the final time.\n    \"\"\"\n    # 1. Initialization\n    dx = Lx / N\n    x = np.linspace(0, Lx, N, endpoint=False)\n    \n    # Wavevectors for real FFT (rfft)\n    k = np.fft.rfftfreq(N, d=dx) * 2 * np.pi\n    k_sq = k**2\n\n    # Set seed if provided (for Test Case C)\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Generate initial condition using the provided function\n    phi = phi_0_func(x, N, Lx)\n\n    # Calculate initial mass\n    mass_initial = np.sum(phi) * dx\n\n    # Time-stepping parameters\n    n_steps = int(T / dt)\n\n    # Pre-compute the denominator for the update step for efficiency\n    update_denominator = 1.0 + dt * M * kappa * k_sq\n\n    # 2. Time-stepping loop\n    for _ in range(n_steps):\n        # a. Nonlinear chemical potential term in real space\n        W_prime = phi**3 - phi\n        \n        # b. Lagrange multiplier (spatial average of W_prime)\n        lambda_t = np.mean(W_prime)\n        \n        # c. Full explicit part of the right-hand side in real space\n        R = -M * W_prime + M * lambda_t\n        \n        # d. Transform to Fourier space\n        phi_hat = np.fft.rfft(phi)\n        R_hat = np.fft.rfft(R)\n        \n        # e. Update in Fourier space\n        phi_hat_new = (phi_hat + dt * R_hat) / update_denominator\n        \n        # f. Transform back to real space, ensuring correct size for odd N\n        phi = np.fft.irfft(phi_hat_new, n=N)\n\n    # 3. Finalization\n    mass_final = np.sum(phi) * dx\n    mass_drift = np.abs(mass_final - mass_initial)\n    \n    return mass_drift\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the results in the\n    specified format.\n    \"\"\"\n\n    # Initial condition functions for each test case\n    def ic_A(x, N, Lx):\n        return 0.2 + 0.1 * np.sin(2 * np.pi * x / Lx) + 0.05 * np.sin(4 * np.pi * x / Lx)\n\n    def ic_B(x, N, Lx):\n        return 0.3 * np.ones_like(x)\n\n    def ic_C(x, N, Lx):\n        # The seed is set in run_simulation before this function is called.\n        # Generate zero-mean random noise as specified.\n        noise = 0.2 * np.random.randn(N)\n        return noise - np.mean(noise)\n\n    test_cases = [\n        # Test Case A\n        {\"N\": 256, \"Lx\": 1.0, \"M\": 1.0, \"kappa\": 0.01, \"dt\": 1e-4, \"T\": 0.02, \"phi_0_func\": ic_A, \"seed\": None},\n        # Test Case B\n        {\"N\": 128, \"Lx\": 1.0, \"M\": 1.0, \"kappa\": 0.05, \"dt\": 1e-4, \"T\": 0.01, \"phi_0_func\": ic_B, \"seed\": None},\n        # Test Case C (using fixed seed 42 as per problem description)\n        {\"N\": 256, \"Lx\": 1.0, \"M\": 0.5, \"kappa\": 0.1, \"dt\": 5e-5, \"T\": 0.01, \"phi_0_func\": ic_C, \"seed\": 42},\n    ]\n\n    results = []\n    for params in test_cases:\n        drift = run_simulation(**params)\n        results.append(drift)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}