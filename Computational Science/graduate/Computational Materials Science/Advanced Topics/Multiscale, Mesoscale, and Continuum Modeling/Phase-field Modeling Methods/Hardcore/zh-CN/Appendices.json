{
    "hands_on_practices": [
        {
            "introduction": "相场模型的核心是自由能泛函，它描述了系统的热力学状态。在基础的Cahn-Hilliard模型中，梯度能系数 $\\kappa$ 通常被假定为常数，但这在真实材料中是一种简化。本练习将引导你探索一个更贴近物理现实的情景：梯度能系数依赖于成分 $\\kappa(c)$，并从变分原理出发，推导在这种情况下化学势的表达式。通过这个练习，你将把抽象的数学公式与可测量的物理量（如界面宽度和界面能）直接联系起来，这是从理论建模到实际应用的关键一步 。",
            "id": "3476377",
            "problem": "您的任务是在 Cahn-Hilliard 框架内推导并实现一个依赖于组分的梯度能量系数的化学势，然后定量测试其对一维平面界面轮廓的影响。请完全在无量纲单位下进行工作。\n\n从自由能泛函开始\n$$\n\\mathcal{F}[c] = \\int_{\\Omega} \\left( f(c) + \\frac{1}{2}\\,\\kappa(c)\\,|\\nabla c|^2 \\right)\\, \\mathrm{d}\\mathbf{x},\n$$\n其中 $ c(\\mathbf{x}) $ 是组分场，$ f(c) $ 是局域体自由能密度，$ \\kappa(c) $ 是一个依赖于组分的梯度能量系数。化学势定义为变分导数 $ \\mu = \\delta \\mathcal{F}/\\delta c $。使用变分法和基本恒等式，推导当 $ \\kappa(c) $ 不为常数时 $ \\mu $ 的显式形式。然后，对于连接体自由能的两个共存极小值 $ c_- $ 和 $ c_+ $ 的一维、平面、平衡界面，利用平移不变性获得一个第一积分，将平衡轮廓条件简化为关于 $ c $ 的单一求积，并用它计算两个定量指标：$ 10\\text{–}90 $ 界面宽度和单位面积界面能。您的推导必须从所提供的泛函形式和既定定义出发，并且不得在没有证明的情况下假设任何快捷公式。\n\n假设一个对称双阱体自由能密度为\n$$\nf(c) = \\frac{A}{4}\\,(c^2 - 1)^2,\n$$\n其中 $ A > 0 $，因此两个共存的体相组分为 $ c_- = -1 $ 和 $ c_+ = +1 $，并且任一极小值处的体自由能为 $ f(c_{\\pm}) = 0 $。所有量均为无量纲。\n\n实现要求：\n- 使用推导出的 $ \\mu $ 表达式和一维平衡简化，为 $ 10\\text{–}90 $ 界面宽度构建必要的求积\n$$\nw_{10\\text{–}90} = \\int_{c=-0.9}^{c=+0.9} \\sqrt{\\frac{\\kappa(c)}{2\\,f(c)}}\\, \\mathrm{d}c,\n$$\n以及单位面积界面能\n$$\n\\gamma = \\int_{c=-1}^{c=+1} \\sqrt{2\\,f(c)\\,\\kappa(c)}\\, \\mathrm{d}c.\n$$\n这些表达式必须在您的解中从第一性原理出发获得并加以证明。\n\n- 编写一个完整的、可运行的程序，该程序：\n  1. 为每个测试案例实现 $ f(c) $ 和 $ \\kappa(c) $。\n  2. 在一维中数值计算上述求积。\n  3. 为指定的测试套件生成所需的输出。\n\n测试套件：\n- 案例 1（基准线，标准情况）：常数梯度能量，\n  $ \\kappa(c) = \\kappa_0 $，其中 $ A = 1.0 $，$ \\kappa_0 = 1.0 $。\n- 案例 2（依赖组分递增）：随组分大小多项式增加，\n  $ \\kappa(c) = \\kappa_0\\,(1 + \\alpha\\,c^2) $，其中 $ A = 1.0 $，$ \\kappa_0 = 1.0 $，$ \\alpha = 2.0 $。\n- 案例 3（依赖组分递减）：随组分大小倒数递减，\n  $ \\kappa(c) = \\dfrac{\\kappa_0}{1 + \\beta\\,c^2} $，其中 $ A = 1.0 $，$ \\kappa_0 = 1.0 $，$ \\beta = 2.0 $。\n\n输出规格：\n- 您的程序必须为每个案例计算一对 $ [w_{10\\text{–}90}, \\gamma] $ 作为无量纲浮点数。\n- 最终输出必须是单行，包含一个逗号分隔的列表，其格式严格如下\n$$\n\\texttt{[[w_1,\\gamma_1],[w_2,\\gamma_2],[w_3,\\gamma_3]]}\n$$\n行中任何地方都不能有空格。这里 $ w_i $ 和 $ \\gamma_i $ 表示案例 $ i $ 的结果。将输出表示为浮点数。由于所有量都是无量纲的，因此没有物理单位。\n\n设计覆盖范围：\n- 基准案例 1 验证了对称双阱的常数 $ \\kappa $ 行为。\n- 案例 2 探讨了在 $ |c| \\approx 1 $ 附近梯度惩罚项增大的效应，这倾向于使界面变宽并增加界面能。\n- 案例 3 探讨了在 $ |c| \\approx 1 $ 附近梯度惩罚项减小的效应，这倾向于使界面变锐并减少界面能。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，其结构应严格如上所述，例如：\n$$\n\\texttt{[[result\\_w1,result\\_g1],[result\\_w2,result\\_g2],[result\\_w3,result\\_g3]]}.\n$$",
            "solution": "该问题要求推导具有依赖于组分的梯度能量系数的 Cahn-Hilliard 系统的化学势和平衡界面性质，然后通过数值实现计算三种特定情况下的界面宽度和能量。\n\n### 第 1 步：化学势 $ \\mu $ 的推导\n\n系统的总自由能由以下泛函给出：\n$$\n\\mathcal{F}[c] = \\int_{\\Omega} \\left( f(c) + \\frac{1}{2}\\,\\kappa(c)\\,|\\nabla c|^2 \\right)\\, \\mathrm{d}\\mathbf{x}\n$$\n化学势 $ \\mu $ 定义为自由能泛函 $ \\mathcal{F} $ 相对于组分场 $ c $ 的变分（或泛函）导数，记为 $ \\mu = \\dfrac{\\delta \\mathcal{F}}{\\delta c} $。变分 $ \\delta \\mathcal{F} $ 的定义如下：\n$$\n\\delta \\mathcal{F} = \\int_{\\Omega} \\frac{\\delta \\mathcal{F}}{\\delta c} \\delta c \\, \\mathrm{d}\\mathbf{x} = \\int_{\\Omega} \\mu \\, \\delta c \\, \\mathrm{d}\\mathbf{x}\n$$\n我们通过考虑对场 $ c $ 的一个微小扰动 $ \\delta c $ 来计算变分 $ \\delta \\mathcal{F} $。\n$$\n\\delta \\mathcal{F} = \\mathcal{F}[c + \\delta c] - \\mathcal{F}[c] = \\int_{\\Omega} \\left[ \\delta f(c) + \\delta \\left( \\frac{1}{2}\\,\\kappa(c)\\,|\\nabla c|^2 \\right) \\right] \\mathrm{d}\\mathbf{x}\n$$\n第一项的变分是：\n$$\n\\delta f(c) = f(c + \\delta c) - f(c) = \\frac{\\mathrm{d}f}{\\mathrm{d}c} \\delta c = f'(c) \\, \\delta c\n$$\n第二项的变分使用乘法法则求得：\n$$\n\\delta \\left( \\frac{1}{2}\\,\\kappa(c)\\,|\\nabla c|^2 \\right) = \\frac{1}{2} \\left[ (\\delta \\kappa(c)) |\\nabla c|^2 + \\kappa(c) \\delta(|\\nabla c|^2) \\right]\n$$\n其中 $ |\\nabla c|^2 = \\nabla c \\cdot \\nabla c $。各项变分为：\n$$\n\\delta \\kappa(c) = \\frac{\\mathrm{d}\\kappa}{\\mathrm{d}c} \\delta c = \\kappa'(c) \\, \\delta c\n$$\n$$\n\\delta (|\\nabla c|^2) = \\nabla(c+\\delta c) \\cdot \\nabla(c+\\delta c) - \\nabla c \\cdot \\nabla c = 2 \\nabla c \\cdot \\nabla(\\delta c) + O((\\delta c)^2)\n$$\n将这些代入第二项的变分中：\n$$\n\\delta \\left( \\frac{1}{2}\\,\\kappa(c)\\,|\\nabla c|^2 \\right) = \\frac{1}{2} \\left[ \\kappa'(c) |\\nabla c|^2 \\delta c + \\kappa(c) (2 \\nabla c \\cdot \\nabla(\\delta c)) \\right] = \\frac{1}{2}\\kappa'(c) |\\nabla c|^2 \\delta c + \\kappa(c) \\nabla c \\cdot \\nabla(\\delta c)\n$$\n合并各项，总变分 $ \\delta \\mathcal{F} $ 为：\n$$\n\\delta \\mathcal{F} = \\int_{\\Omega} \\left( f'(c)\\,\\delta c + \\frac{1}{2}\\kappa'(c) |\\nabla c|^2 \\delta c + \\kappa(c) \\nabla c \\cdot \\nabla(\\delta c) \\right) \\mathrm{d}\\mathbf{x}\n$$\n最后一项需要分部积分。使用矢量恒等式 $ \\nabla \\cdot (\\phi \\mathbf{V}) = (\\nabla \\phi) \\cdot \\mathbf{V} + \\phi (\\nabla \\cdot \\mathbf{V}) $，我们可以写出 $ \\nabla(\\delta c) \\cdot (\\kappa(c)\\nabla c) = \\nabla \\cdot (\\delta c \\, \\kappa(c)\\nabla c) - \\delta c \\, \\nabla \\cdot (\\kappa(c)\\nabla c) $。在定义域 $ \\Omega $ 上积分：\n$$\n\\int_{\\Omega} \\kappa(c) \\nabla c \\cdot \\nabla(\\delta c) \\, \\mathrm{d}\\mathbf{x} = \\int_{\\Omega} \\nabla \\cdot (\\delta c \\, \\kappa(c)\\nabla c) \\, \\mathrm{d}\\mathbf{x} - \\int_{\\Omega} \\delta c \\, \\nabla \\cdot (\\kappa(c)\\nabla c) \\, \\mathrm{d}\\mathbf{x}\n$$\n根据散度定理，右边的第一项变成一个面积分 $ \\int_{\\partial \\Omega} (\\delta c \\, \\kappa(c)\\nabla c) \\cdot \\mathrm{d}\\mathbf{S} $。假设自然边界条件（在 $ \\partial \\Omega $ 上 $ \\nabla c \\cdot \\mathbf{n} = 0 $）或在边界上 $ \\delta c = 0 $，此项为零。我们剩下：\n$$\n\\int_{\\Omega} \\kappa(c) \\nabla c \\cdot \\nabla(\\delta c) \\, \\mathrm{d}\\mathbf{x} = - \\int_{\\Omega} \\delta c \\, \\nabla \\cdot (\\kappa(c)\\nabla c) \\, \\mathrm{d}\\mathbf{x}\n$$\n将此代回 $ \\delta \\mathcal{F} $ 的表达式中：\n$$\n\\delta \\mathcal{F} = \\int_{\\Omega} \\left( f'(c) + \\frac{1}{2}\\kappa'(c) |\\nabla c|^2 - \\nabla \\cdot (\\kappa(c)\\nabla c) \\right) \\delta c \\, \\mathrm{d}\\mathbf{x}\n$$\n通过与定义 $ \\delta \\mathcal{F} = \\int_{\\Omega} \\mu \\, \\delta c \\, \\mathrm{d}\\mathbf{x} $ 进行比较，我们确定化学势为：\n$$\n\\mu = f'(c) + \\frac{1}{2}\\kappa'(c) |\\nabla c|^2 - \\nabla \\cdot (\\kappa(c)\\nabla c)\n$$\n展开散度项：$ \\nabla \\cdot (\\kappa(c)\\nabla c) = \\nabla\\kappa(c) \\cdot \\nabla c + \\kappa(c) \\nabla^2 c $。由于 $ \\kappa $ 是 $ c $ 的函数，我们有 $ \\nabla\\kappa(c) = \\kappa'(c)\\nabla c $，所以 $ \\nabla \\cdot (\\kappa(c)\\nabla c) = \\kappa'(c)|\\nabla c|^2 + \\kappa(c)\\nabla^2 c $。将此代入 $ \\mu $ 的表达式中：\n$$\n\\mu = f'(c) + \\frac{1}{2}\\kappa'(c) |\\nabla c|^2 - \\left(\\kappa'(c)|\\nabla c|^2 + \\kappa(c)\\nabla^2 c\\right)\n$$\n$$\n\\mu = f'(c) - \\kappa(c)\\nabla^2 c - \\frac{1}{2}\\kappa'(c)|\\nabla c|^2\n$$\n这是依赖于组分的梯度能量系数的化学势的最终表达式。\n\n### 第 2 步：一维平衡和求积的推导\n\n对于一维、平面的平衡界面，化学势必须是常数，$ \\mu = \\mu_0 $。系统与体相 $ c = c_{\\pm} = \\pm 1 $ 处于平衡状态，在体相中梯度为零。体相化学势为 $ \\mu_{bulk} = f'(c_{\\pm}) $。对于给定的体自由能 $ f(c) = \\frac{A}{4}(c^2 - 1)^2 $，其导数为 $ f'(c) = A c(c^2 - 1) $。在 $ c=\\pm 1 $ 处，$ f'(c) = 0 $，因此平衡化学势为 $ \\mu_0 = 0 $。\n\n在一维（$ x $）中的平衡条件是 $ \\mu = 0 $：\n$$\nf'(c) - \\kappa(c)\\frac{\\mathrm{d}^2 c}{\\mathrm{d}x^2} - \\frac{1}{2}\\kappa'(c)\\left(\\frac{\\mathrm{d}c}{\\mathrm{d}x}\\right)^2 = 0\n$$\n为了找到这个二阶常微分方程的第一积分，我们利用一维中的平移不变性原理。对于一个由不显式依赖于空间坐标 $ x $ 的拉格朗日量 $ L(c, c') $ 描述的系统，存在一个守恒量（第一积分），由 $ c' \\frac{\\partial L}{\\partial c'} - L = \\text{const} $ 给出。在我们的案例中，自由能泛函的被积函数 $ \\mathcal{L} = f(c) + \\frac{1}{2}\\kappa(c)(c')^2 $ 充当拉格朗日量。\n\n我们计算守恒量：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial c'} = \\kappa(c)c'\n$$\n守恒量是：\n$$\nc'(\\kappa(c)c') - \\left(f(c) + \\frac{1}{2}\\kappa(c)(c')^2\\right) = \\kappa(c)(c')^2 - f(c) - \\frac{1}{2}\\kappa(c)(c')^2 = \\frac{1}{2}\\kappa(c)(c')^2 - f(c)\n$$\n所以，$ \\frac{1}{2}\\kappa(c)\\left(\\frac{\\mathrm{d}c}{\\mathrm{d}x}\\right)^2 - f(c) = \\text{const} $。我们通过在远离界面的体相中评估此表达式来确定常数，在体相中 $ c \\to c_{\\pm} = \\pm 1 $ 并且 $ \\frac{\\mathrm{d}c}{\\mathrm{d}x} \\to 0 $。在体相中，$ f(c_{\\pm}) = 0 $。因此，常数为 $ 0 $，得到第一积分：\n$$\n\\frac{1}{2}\\kappa(c)\\left(\\frac{\\mathrm{d}c}{\\mathrm{d}x}\\right)^2 = f(c)\n$$\n这个关系将组分的梯度与局域体自由能联系起来。由此，我们求解 $ \\frac{\\mathrm{d}c}{\\mathrm{d}x} $，对于 $ c $ 随 $ x $ 增加的界面，取正根：\n$$\n\\frac{\\mathrm{d}c}{\\mathrm{d}x} = \\sqrt{\\frac{2f(c)}{\\kappa(c)}}\n$$\n这个可分离的常微分方程可以写成 $ \\mathrm{d}x = \\sqrt{\\frac{\\kappa(c)}{2f(c)}} \\mathrm{d}c $。这使我们能够推导出所需的求积。\n\n**界面宽度, $ w_{10-90} $**：$ 10\\text{–}90 $ 宽度是组分从 $ c=-0.9 $ 变化到 $ c=0.9 $ 的空间距离。通过在相应组分之间对 $ \\mathrm{d}x $ 进行积分，我们得到：\n$$\nw_{10\\text{–}90} = \\int_{c=-0.9}^{c=0.9} \\mathrm{d}x = \\int_{-0.9}^{0.9} \\sqrt{\\frac{\\kappa(c)}{2f(c)}} \\mathrm{d}c\n$$\n这证实了问题陈述中提供的表达式。\n\n**界面能, $ \\gamma $**：单位面积的界面能是界面相对于体相的过剩自由能。由于体相自由能为 $ f(c_{\\pm}) = 0 $，这便是：\n$$\n\\gamma = \\int_{-\\infty}^{\\infty} \\left( f(c(x)) + \\frac{1}{2}\\kappa(c(x))\\left(\\frac{\\mathrm{d}c}{\\mathrm{d}x}\\right)^2 \\right) \\mathrm{d}x\n$$\n使用第一积分 $ \\frac{1}{2}\\kappa(c)\\left(\\frac{\\mathrm{d}c}{\\mathrm{d}x}\\right)^2 = f(c) $，被积函数简化为 $ f(c) + f(c) = 2f(c) $。\n$$\n\\gamma = \\int_{-\\infty}^{\\infty} 2f(c(x)) \\mathrm{d}x\n$$\n为了计算这个积分，我们将积分变量从 $ x $ 变为 $ c $，使用 $ \\mathrm{d}x = \\sqrt{\\frac{\\kappa(c)}{2f(c)}} \\mathrm{d}c $。$ x $ 从 $ -\\infty $到 $ +\\infty $ 的积分极限对应于 $ c $ 从 $ -1 $ 到 $ +1 $。\n$$\n\\gamma = \\int_{-1}^{1} 2f(c) \\sqrt{\\frac{\\kappa(c)}{2f(c)}} \\mathrm{d}c = \\int_{-1}^{1} \\sqrt{4f(c)^2 \\frac{\\kappa(c)}{2f(c)}} \\mathrm{d}c = \\int_{-1}^{1} \\sqrt{2f(c)\\kappa(c)} \\mathrm{d}c\n$$\n这也证实了问题陈述中提供的表达式。\n\n### 第 3 步：数值计算\n\n我们现在使用指定的参数对三种测试案例的推导积分进行数值计算。所有案例都使用 $ A=1.0 $。体自由能为 $ f(c) = \\frac{1}{4}(c^2-1)^2 $。\n\n**案例 1 (常数 $ \\kappa $):** $ \\kappa(c) = \\kappa_0 = 1.0 $。\n$$\nw_{10\\text{–}90} = \\int_{-0.9}^{0.9} \\sqrt{\\frac{1.0}{2 \\cdot \\frac{1}{4}(c^2-1)^2}} \\mathrm{d}c = \\int_{-0.9}^{0.9} \\frac{\\sqrt{2}}{1-c^2} \\mathrm{d}c\n$$\n$$\n\\gamma = \\int_{-1}^{1} \\sqrt{2 \\cdot \\frac{1}{4}(c^2-1)^2 \\cdot 1.0} \\mathrm{d}c = \\int_{-1}^{1} \\frac{1-c^2}{\\sqrt{2}} \\mathrm{d}c\n$$\n\n**案例 2 (递增 $ \\kappa $):** $ \\kappa(c) = \\kappa_0(1+\\alpha c^2) = 1.0(1+2.0c^2) $。\n$$\nw_{10\\text{–}90} = \\int_{-0.9}^{0.9} \\sqrt{\\frac{1+2c^2}{2 \\cdot \\frac{1}{4}(c^2-1)^2}} \\mathrm{d}c = \\int_{-0.9}^{0.9} \\frac{\\sqrt{2(1+2c^2)}}{1-c^2} \\mathrm{d}c\n$$\n$$\n\\gamma = \\int_{-1}^{1} \\sqrt{2 \\cdot \\frac{1}{4}(c^2-1)^2 \\cdot (1+2c^2)} \\mathrm{d}c = \\int_{-1}^{1} \\frac{(1-c^2)\\sqrt{1+2c^2}}{\\sqrt{2}} \\mathrm{d}c\n$$\n\n**案例 3 (递减 $ \\kappa $):** $ \\kappa(c) = \\frac{\\kappa_0}{1+\\beta c^2} = \\frac{1.0}{1+2.0c^2} $。\n$$\nw_{10\\text{–}90} = \\int_{-0.9}^{0.9} \\sqrt{\\frac{1/(1+2c^2)}{2 \\cdot \\frac{1}{4}(c^2-1)^2}} \\mathrm{d}c = \\int_{-0.9}^{0.9} \\frac{\\sqrt{2}}{(1-c^2)\\sqrt{1+2c^2}} \\mathrm{d}c\n$$\n$$\n\\gamma = \\int_{-1}^{1} \\sqrt{2 \\cdot \\frac{1}{4}(c^2-1)^2 \\cdot \\frac{1}{1+2c^2}} \\mathrm{d}c = \\int_{-1}^{1} \\frac{1-c^2}{\\sqrt{2(1+2c^2)}} \\mathrm{d}c\n$$\n这些积分使用 Python 进行数值计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Derives and computes interfacial properties for a Cahn-Hilliard system\n    with composition-dependent gradient energy coefficient.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'name': 'constant', 'A': 1.0, 'k0': 1.0},\n        {'name': 'increasing', 'A': 1.0, 'k0': 1.0, 'alpha': 2.0},\n        {'name': 'decreasing', 'A': 1.0, 'k0': 1.0, 'beta': 2.0},\n    ]\n\n    results = []\n    \n    # Common bulk free energy density function\n    def f(c, A):\n        return (A / 4.0) * (c**2 - 1.0)**2\n\n    # Composition-dependent gradient energy coefficient\n    def kappa(c, case):\n        if case['name'] == 'constant':\n            return case['k0']\n        elif case['name'] == 'increasing':\n            return case['k0'] * (1.0 + case['alpha'] * c**2)\n        elif case['name'] == 'decreasing':\n            return case['k0'] / (1.0 + case['beta'] * c**2)\n        else:\n            raise ValueError(\"Unknown case name\")\n            \n    for case in test_cases:\n        A = case['A']\n        \n        # Integrand for the 10-90 interfacial width\n        def integrand_w(c, case_params):\n            # The denominator has (c^2-1)^2 which becomes (1-c^2)^2 as c is in [-0.9, 0.9]\n            # Sqrt of f(c) contains |c^2 - 1| = 1 - c^2 for c in (-1, 1).\n            # The integrand is sqrt(kappa(c) / (2*f(c)))\n            f_val = f(c, A)\n            # Avoid division by zero at the exact limits, though quad handles it.\n            if f_val == 0.0:\n                return np.inf\n            kappa_val = kappa(c, case_params)\n            return np.sqrt(kappa_val / (2.0 * f_val))\n\n        # Integrand for the interfacial energy\n        def integrand_gamma(c, case_params):\n            # The integrand is sqrt(2 * f(c) * kappa(c))\n            f_val = f(c, A)\n            kappa_val = kappa(c, case_params)\n            return np.sqrt(2.0 * f_val * kappa_val)\n\n        # Numerical integration using scipy.integrate.quad\n        w_10_90, _ = quad(integrand_w, -0.9, 0.9, args=(case,))\n        gamma, _ = quad(integrand_gamma, -1.0, 1.0, args=(case,))\n        \n        results.append(f\"[{w_10_90},{gamma}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "相场模型的演化方程本质上是热力学定律的体现，它驱动系统向自由能更低的状态演化，即系统的总自由能永不增加，满足 $dF/dt \\le 0$。本练习将带你深入相场动力学的热力学核心：你将首先从第一性原理出发，证明两种最基本的梯度流——非守恒的Allen-Cahn动力学（$L^2$流）和守恒的Cahn-Hilliard动力学（$H^{-1}$流）——都严格遵守此能量耗散定律。随后，你将设计一个数值诊断工具，用于检验你的计算机模拟是否在离散的时间步上忠实地再现了这一物理定律，这是一个连接连续理论与计算实践的重要环节 。",
            "id": "3476385",
            "problem": "考虑一个在一维周期性域 $\\Omega = [0,L]$（其中 $L>0$）上的标量相场 $\\phi(x,t)$，它代表了两相材料的局域有序参数。自由能泛函定义为\n$$\nF[\\phi] \\;=\\; \\int_{\\Omega} \\left( \\frac{\\varepsilon^2}{2}\\,|\\nabla \\phi|^2 \\;+\\; \\frac{1}{4}\\,(\\phi^2-1)^2 \\right)\\,dx,\n$$\n其中 $\\varepsilon>0$ 是一个界面宽度参数，$\\nabla$ 是空间梯度。令 $\\mu = \\frac{\\delta F}{\\delta \\phi}$ 表示变分导数（化学势）。其动力学由具有恒定迁移率 $M>0$ 且满足周期性边界条件的梯度流给出：\n- $L^2$ 梯度流（Allen-Cahn 方程）为\n$$\n\\partial_t \\phi \\;=\\; -M\\,\\mu,\n$$\n- $H^{-1}$ 梯度流（Cahn-Hilliard 方程）为\n$$\n\\partial_t \\phi \\;=\\; \\nabla\\cdot\\big(M\\,\\nabla \\mu\\big).\n$$\n\n任务 A（推导）：从自由能 $F[\\phi]$、化学势 $\\mu = \\delta F/\\delta \\phi$ 以及上述两种梯度流的定义出发，仅使用变分法、泛函链式法则和周期性边界条件，从第一性原理推导：对于两种流的光滑解，自由能随时间非增，即：\n$$\n\\frac{dF}{dt} \\;\\le\\; 0\n$$\n对于 $L^2$ 梯度流和 $H^{-1}$ 梯度流均成立。\n\n任务 B（诊断设计）：设计一个数值诊断工具，用于衡量时间离散格式中离散能量耗散的违背情况。考虑时间步长为 $\\Delta t>0$ 的前向欧拉时间离散化：\n- 对于 $L^2$ 梯度流（Allen-Cahn）：\n$$\n\\phi^{n+1} \\;=\\; \\phi^n \\;-\\; \\Delta t\\, M\\, \\mu^n,\n$$\n- 对于 $H^{-1}$ 梯度流（Cahn-Hilliard）：\n$$\n\\phi^{n+1} \\;=\\; \\phi^n \\;+\\; \\Delta t\\, M\\, \\Delta \\mu^n,\n$$\n其中 $\\mu^n = -\\varepsilon^2 \\Delta \\phi^n + \\phi^n\\big((\\phi^n)^2 - 1\\big)$，$\\Delta$ 是拉普拉斯算子。该诊断工具必须在每个时间步计算离散能量值 $F^n = F[\\phi^n]$ 和离散能量斜率\n$$\ns^n \\;=\\; \\frac{F^{n+1} - F^n}{\\Delta t},\n$$\n然后报告在整个时间范围内的最大正斜率，以及违背次数（定义为 $s^n$ 超过一个小的非负容差 $\\tau$ 的步数，以避免因舍入误差导致的假阳性）。使用容差 $\\tau = 10^{-12}$。\n\n数值规格：在一维空间中实现该诊断工具，在 $\\Omega=[0,L]$上使用周期性边界条件。使用包含 $N_x$ 个点的均匀网格。空间导数必须使用快速傅里叶变换（FFT, Fast Fourier Transform）通过谱方法计算。能量必须在均匀网格上使用复合梯形法则进行近似（对于在均匀网格上采样的周期被积函数，该法则是精确的）。非平凡测试的初始条件为\n$$\n\\phi(x,0) \\;=\\; 0.2\\,\\sin(2\\pi x/L) \\;+\\; 0.1\\,\\cos(6\\pi x/L),\n$$\n边界情况的初始条件为 $\\phi(x,0)=1$。所有测试均使用 $M=1$ 和 $\\varepsilon=0.05$。所有量均为无量纲，因此不需要物理单位。\n\n测试套件：对以下参数集运行诊断工具，以测试格式的不同方面。每个测试用例由 $(\\text{flow}, N_x, L, \\Delta t, N_{\\text{steps}}, \\text{init})$ 描述：\n1. $(\\text{Allen–Cahn},\\; N_x=128,\\; L=1,\\; \\Delta t = 10^{-4},\\; N_{\\text{steps}}=200,\\; \\text{init} = \\text{nontrivial})$ — 时间步长较小的理想路径。\n2. $(\\text{Allen–Cahn},\\; N_x=128,\\; L=1,\\; \\Delta t = 10^{-2},\\; N_{\\text{steps}}=60,\\; \\text{init} = \\text{nontrivial})$ — 可能导致能量增加的大时间步长。\n3. $(\\text{Cahn–Hilliard},\\; N_x=128,\\; L=1,\\; \\Delta t = 10^{-6},\\; N_{\\text{steps}}=300,\\; \\text{init} = \\text{nontrivial})$ — 时间步长非常小的守恒流。\n4. $(\\text{Cahn–Hilliard},\\; N_x=128,\\; L=1,\\; \\Delta t = 10^{-3},\\; N_{\\text{steps}}=100,\\; \\text{init} = \\text{nontrivial})$ — 较大的时间步长以暴露违背情况。\n5. $(\\text{Allen–Cahn},\\; N_x=128,\\; L=1,\\; \\Delta t = 10^{-2},\\; N_{\\text{steps}}=40,\\; \\text{init} = \\text{constant } \\phi\\equiv 1)$ — 边界情况，此时化学势为零，能量应保持恒定。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，输出所有步骤中的最大正离散能量斜率（一个浮点数），后跟违背次数（一个整数）。将所有测试用例的结果按上述测试套件的顺序汇总到一个扁平列表中。例如，输出格式必须是\n$$\n[\\text{max\\_pos\\_slope\\_case1},\\text{count\\_case1},\\text{max\\_pos\\_slope\\_case2},\\text{count\\_case2},\\ldots,\\text{max\\_pos\\_slope\\_case5},\\text{count\\_case5}].\n$$",
            "solution": "该问题提出了两个任务：首先，对 Allen-Cahn 和 Cahn-Hilliard 方程的能量耗散性质进行理论推导；其次，设计并实现一个数值诊断工具，以监控离散前向欧拉格式中对该性质的违背情况。该问题提法明确，科学上合理，并为完整解决提供了所有必要信息。\n\n### 任务 A：能量耗散的推导\n\n目标是证明对于 Allen-Cahn 和 Cahn-Hilliard 方程的光滑解 $\\phi(x,t)$，自由能 $F[\\phi]$ 是时间 $t$ 的非增函数。自由能泛函由下式给出：\n$$\nF[\\phi] = \\int_{\\Omega} f(\\phi, \\nabla \\phi) \\,dx = \\int_{\\Omega} \\left( \\frac{\\varepsilon^2}{2}\\,|\\nabla \\phi|^2 + \\frac{1}{4}\\,(\\phi^2-1)^2 \\right)\\,dx\n$$\n我们首先使用泛函链式法则计算 $F[\\phi(t)]$ 的时间导数。\n$$\n\\frac{dF}{dt} = \\frac{d}{dt} \\int_{\\Omega} f(\\phi(x,t), \\nabla \\phi(x,t)) \\,dx\n$$\n应用链式法则并将导数移到积分号内（Leibniz 积分法则）得到：\n$$\n\\frac{dF}{dt} = \\int_{\\Omega} \\left( \\frac{\\partial f}{\\partial \\phi} \\frac{\\partial \\phi}{\\partial t} + \\frac{\\partial f}{\\partial \\nabla\\phi} \\cdot \\frac{\\partial (\\nabla\\phi)}{\\partial t} \\right) \\,dx\n$$\n我们可以在第二项中交换空间和时间导数，即 $\\frac{\\partial (\\nabla\\phi)}{\\partial t} = \\nabla(\\frac{\\partial \\phi}{\\partial t})$。表达式变为：\n$$\n\\frac{dF}{dt} = \\int_{\\Omega} \\left( \\frac{\\partial f}{\\partial \\phi} \\partial_t\\phi + \\frac{\\partial f}{\\partial \\nabla\\phi} \\cdot \\nabla(\\partial_t\\phi) \\right) \\,dx\n$$\n对第二项应用分部积分法，$\\int u \\cdot \\nabla v \\,dx = [u \\cdot v]_{\\partial\\Omega} - \\int (\\nabla \\cdot u) v \\,dx$，其中 $u = \\frac{\\partial f}{\\partial \\nabla\\phi}$ 且 $v = \\partial_t\\phi$：\n$$\n\\int_{\\Omega} \\frac{\\partial f}{\\partial \\nabla\\phi} \\cdot \\nabla(\\partial_t\\phi) \\,dx = \\left[ \\frac{\\partial f}{\\partial \\nabla\\phi} \\cdot \\partial_t\\phi \\right]_{\\partial\\Omega} - \\int_{\\Omega} \\left( \\nabla \\cdot \\frac{\\partial f}{\\partial \\nabla\\phi} \\right) \\partial_t\\phi \\,dx\n$$\n由于在 $\\Omega = [0,L]$ 上指定了周期性边界条件，边界项为零。将其代回，我们可以提出公因子 $\\partial_t\\phi$：\n$$\n\\frac{dF}{dt} = \\int_{\\Omega} \\left( \\frac{\\partial f}{\\partial \\phi} - \\nabla \\cdot \\frac{\\partial f}{\\partial \\nabla\\phi} \\right) \\partial_t\\phi \\,dx\n$$\n括号中的项正是变分导数（或化学势）$\\mu = \\frac{\\delta F}{\\delta \\phi}$ 的定义。因此，我们得到了能量变化率的一般关系式：\n$$\n\\frac{dF}{dt} = \\int_{\\Omega} \\mu \\, \\partial_t\\phi \\,dx\n$$\n该表达式等价于 $L^2$ 内积 $\\langle \\mu, \\partial_t\\phi \\rangle_{L^2}$。现在我们可以分析两种特定的梯度流。\n\n**1. Allen-Cahn（$L^2$ 梯度流）**\n其动力学由 $\\partial_t\\phi = -M\\mu$ 给出，其中 $M > 0$ 是一个恒定的迁移率。将此代入我们关于 $\\frac{dF}{dt}$ 的表达式中：\n$$\n\\frac{dF}{dt} = \\int_{\\Omega} \\mu (-M\\mu) \\,dx = -M \\int_{\\Omega} \\mu^2 \\,dx\n$$\n由于 $M > 0$ 且被积函数 $\\mu^2$ 是非负的，积分 $\\int_{\\Omega} \\mu^2 \\,dx \\ge 0$。因此，\n$$\n\\frac{dF}{dt} \\le 0\n$$\n这证实了沿 Allen-Cahn 方程的解，自由能是随时间非增的。\n\n**2. Cahn-Hilliard（$H^{-1}$ 梯度流）**\n其动力学由 $\\partial_t\\phi = \\nabla \\cdot (M \\nabla \\mu) = M \\Delta\\mu$ 给出（对于恒定的 $M$）。将此代入能量变化率方程中：\n$$\n\\frac{dF}{dt} = \\int_{\\Omega} \\mu (M \\Delta\\mu) \\,dx = M \\int_{\\Omega} \\mu \\Delta\\mu \\,dx\n$$\n我们再次使用分部积分法，特别是格林第一恒等式 $\\int u \\Delta v \\,dx = [u \\nabla v]_{\\partial \\Omega} - \\int \\nabla u \\cdot \\nabla v \\,dx$。令 $u=v=\\mu$：\n$$\n\\int_{\\Omega} \\mu \\Delta\\mu \\,dx = [\\mu \\nabla \\mu]_{\\partial \\Omega} - \\int_{\\Omega} |\\nabla\\mu|^2 \\,dx\n$$\n由于周期性边界条件，边界项为零。能量变化率的表达式变为：\n$$\n\\frac{dF}{dt} = -M \\int_{\\Omega} |\\nabla\\mu|^2 \\,dx\n$$\n由于 $M > 0$ 且被积函数 $|\\nabla\\mu|^2$ 是非负的，积分 $\\int_{\\Omega} |\\nabla\\mu|^2 \\,dx \\ge 0$。因此，\n$$\n\\frac{dF}{dt} \\le 0\n$$\n这证实了沿 Cahn-Hilliard 方程的解，自由能也是随时间非增的。这两个方程都代表了耗散动力学，将系统驱动向一个更低的自由能状态。\n\n### 任务 B：数值诊断设计\n\n数值实现和诊断工具是根据所提供的规格设计的。\n\n**空间离散化和导数：**\n一维域 $\\Omega=[0,L]$ 被离散化为一个包含 $N_x$ 个点的均匀网格，即 $x_j = j \\Delta x$，其中 $j = 0, 1, \\ldots, N_x-1$，网格间距为 $\\Delta x = L/N_x$。空间导数使用快速傅里叶变换（FFT）通过谱方法计算。周期函数 $\\psi(x)$ 的 $n$ 阶导数通过关系式 $\\mathcal{F}(\\frac{d^n\\psi}{dx^n}) = (ik)^n \\hat{\\psi}(k)$ 在傅里叶空间中计算，其中 $\\hat{\\psi}(k) = \\mathcal{F}(\\psi(x))$ 是 $\\psi$ 的离散傅里叶变换，$k$ 是离散波数。然后，通过逆 FFT 将导数返回到实空间。对于光滑的周期函数，此方法非常精确。\n\n**能量计算：**\n自由能泛函 $F[\\phi]$ 是一个积分，可以使用复合梯形法则进行数值近似。对于在均匀网格上采样的周期函数，该法则简化为在网格点上被积函数值的总和，再乘以网格间距 $\\Delta x$。\n$$\nF^n = F[\\phi^n] \\approx \\Delta x \\sum_{j=0}^{N_x-1} \\left( \\frac{\\varepsilon^2}{2}\\,|(\\nabla \\phi^n)_j|^2 \\;+\\; \\frac{1}{4}\\,((\\phi_j^n)^2-1)^2 \\right)\n$$\n这里，$(\\nabla \\phi^n)_j$ 表示在网格点 $j$ 处 $\\phi^n$ 的一阶空间导数，通过谱方法计算。\n\n**时间步进和诊断：**\n相场 $\\phi$ 的演化使用显式前向欧拉方法进行模拟，时间步长为 $\\Delta t$。诊断的核心是一个迭代 $N_{\\text{steps}}$ 次的循环。在每一步 $n$ 中：\n1.  **计算化学势：** 给定当前状态 $\\phi^n$，在每个网格点上计算化学势 $\\mu^n$：\n    $$\n    \\mu^n = -\\varepsilon^2 \\Delta \\phi^n + (\\phi^n)^3 - \\phi^n\n    $$\n    拉普拉斯算子 $\\Delta \\phi^n$ 通过谱方法计算。\n2.  **更新相场：** 将场推进到下一个时间步 $\\phi^{n+1}$。\n    -   对于 Allen-Cahn：$\\phi^{n+1} = \\phi^n - \\Delta t M \\mu^n$。\n    -   对于 Cahn-Hilliard：$\\phi^{n+1} = \\phi^n + \\Delta t M \\Delta \\mu^n$。化学势的拉普拉斯算子 $\\Delta \\mu^n$ 也通过谱方法计算。\n3.  **计算能量：** 使用上述梯形法则计算当前状态的能量 $F^n=F[\\phi^n]$ 和新状态的能量 $F^{n+1}=F[\\phi^{n+1}]$。\n4.  **计算能量斜率：** 离散的能量变化率，或称斜率，计算如下：\n    $$\n    s^n = \\frac{F^{n+1} - F^n}{\\Delta t}\n    $$\n5.  **更新诊断结果：** 将计算出的斜率 $s^n$ 与理论预期（$s^n \\le 0$）进行比较。\n    -   更新整个模拟过程中观察到的最大正斜率：$\\max_{\\text{pos_slope}} \\leftarrow \\max(\\max_{\\text{pos_slope}}, s^n)$。\n    -   如果 $s^n$ 超过一个小的容差 $\\tau = 10^{-12}$（以考虑浮点数不精确性），则计为一次能量耗散原理的“违背”。\n\n对所有时间步重复此过程。每个测试用例的最终诊断输出包括总的最大正斜率和总的违背次数。众所周知，前向欧拉格式只是有条件稳定的，并且不保证能量耗散，因此预计会出现违背情况，尤其是在时间步长较大时。这些测试用例旨在揭示这种数值不稳定性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(flow, Nx, L, dt, N_steps, init, M, epsilon, tau):\n    \"\"\"\n    Runs a single phase-field simulation and returns diagnostic results.\n    \"\"\"\n    # 1. Setup grid and wave numbers\n    dx = L / Nx\n    x = np.linspace(0, L, Nx, endpoint=False)\n    k = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n\n    # 2. Set initial condition\n    if init == 'nontrivial':\n        phi_n = 0.2 * np.sin(2 * np.pi * x / L) + 0.1 * np.cos(6 * np.pi * x / L)\n    elif init == 'constant':\n        phi_n = np.ones(Nx)\n    else:\n        raise ValueError(\"Unknown initialization type\")\n\n    # 3. Initialize diagnostic variables\n    max_pos_slope = 0.0\n    violation_count = 0\n\n    # 4. Helper function for energy calculation\n    def compute_energy(phi, k_vec, eps, dx_val):\n        phi_hat = np.fft.fft(phi)\n        \n        # Gradient term in Fourier space\n        grad_phi_hat = 1j * k_vec * phi_hat\n        grad_phi = np.fft.ifft(grad_phi_hat).real\n        \n        # Potential term\n        potential = 0.25 * (phi**2 - 1)**2\n        \n        # Integrate using trapezoidal rule (sum * dx for periodic)\n        energy = dx_val * np.sum(0.5 * eps**2 * grad_phi**2 + potential)\n        return energy\n\n    # Initial energy\n    F_n = compute_energy(phi_n, k, epsilon, dx)\n\n    # 5. Time-stepping loop\n    for _ in range(N_steps):\n        # Calculate chemical potential mu_n\n        phi_n_hat = np.fft.fft(phi_n)\n        \n        # Laplacian of phi\n        lap_phi_n_hat = -(k**2) * phi_n_hat\n        lap_phi_n = np.fft.ifft(lap_phi_n_hat).real\n        \n        # mu_n = -epsilon^2 * Delta(phi_n) + phi_n^3 - phi_n\n        mu_n = -epsilon**2 * lap_phi_n + phi_n**3 - phi_n\n\n        # Update phi_n to phi_np1 based on flow type\n        if flow == 'Allen-Cahn':\n            phi_np1 = phi_n - dt * M * mu_n\n        elif flow == 'Cahn-Hilliard':\n            mu_n_hat = np.fft.fft(mu_n)\n            \n            # Laplacian of mu\n            lap_mu_n_hat = -(k**2) * mu_n_hat\n            lap_mu_n = np.fft.ifft(lap_mu_n_hat).real\n            \n            phi_np1 = phi_n + dt * M * lap_mu_n\n        \n        # Calculate new energy F_{n+1}\n        F_np1 = compute_energy(phi_np1, k, epsilon, dx)\n\n        # Calculate discrete energy slope\n        slope = (F_np1 - F_n) / dt\n\n        # Update diagnostics\n        if slope > tau:\n            violation_count += 1\n        \n        if slope > max_pos_slope:\n            max_pos_slope = slope\n            \n        # Update state for next iteration\n        phi_n = phi_np1\n        F_n = F_np1\n\n    return max_pos_slope, violation_count\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    M = 1.0\n    epsilon = 0.05\n    tau = 1.0e-12\n\n    test_cases = [\n        # (flow, Nx, L, dt, N_steps, init)\n        ('Allen-Cahn', 128, 1.0, 1e-4, 200, 'nontrivial'),\n        ('Allen-Cahn', 128, 1.0, 1e-2, 60, 'nontrivial'),\n        ('Cahn-Hilliard', 128, 1.0, 1e-6, 300, 'nontrivial'),\n        ('Cahn-Hilliard', 128, 1.0, 1e-3, 100, 'nontrivial'),\n        ('Allen-Cahn', 128, 1.0, 1e-2, 40, 'constant'),\n    ]\n\n    results = []\n    for case in test_cases:\n        flow, Nx, L, dt, N_steps, init = case\n        \n        max_slope, v_count = run_simulation(\n            flow, Nx, L, dt, N_steps, init, M, epsilon, tau\n        )\n        \n        results.append(max_slope)\n        results.append(v_count)\n\n    # Final print statement in the exact required format.\n    # We use a custom format function to avoid scientific notation for small numbers.\n    def format_float(f):\n        return f'{f:.16f}'.rstrip('0').rstrip('.') if '.' in f'{f:.16f}' else f'{f:.1f}'\n\n    # Use map(str,...) because some results are int and some are float.\n    # The format required is a simple conversion to string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "标准的相场方程功能强大，但并不总是能直接匹配所有物理问题。例如，Allen-Cahn方程描述的是非守恒动力学，我们如何用它来模拟一个总量守恒的系统？本练习将教你一个精巧而实用的建模技巧：引入一个拉格朗日乘子 $\\lambda(t)$，以在全局尺度上强制施加守恒约束。你将亲自推导出演化过程中为维持守恒定律所必需的 $\\lambda(t)$ 的表达式，并将该方法通过高效稳定的半隐式傅里叶谱方法付诸实践，从而掌握如何灵活改造标准模型以适应特定物理需求的能力 。",
            "id": "3476347",
            "problem": "考虑一个非守恒序参量场 $ \\phi(\\mathbf{x},t) $，其演化遵循从一个自由能泛函 $ F[\\phi] $ 导出的 Allen–Cahn 型梯度流。为强制 $ \\phi $ 的全局质量守恒，引入一个空间均匀、随时间变化的拉格朗日乘子 $ \\lambda(t) $，并将动力学方程修改为 $ \\partial_t \\phi = -M \\left( \\delta F / \\delta \\phi - \\lambda(t) \\right) $，其中 $ M > 0 $ 是一个迁移率常数。假设一个长度为 $ L_x $ 的一维周期性区域，并考虑自由能泛函\n$$\nF[\\phi] = \\int_0^{L_x} \\left( \\frac{\\kappa}{2} \\left| \\nabla \\phi \\right|^2 + W(\\phi) \\right) \\, dx,\n$$\n其中界面刚度 $ \\kappa > 0 $，光滑双势阱势为 $ W(\\phi) = \\frac{1}{4}(\\phi^2 - 1)^2 $。变分导数 $ \\delta F / \\delta \\phi $ 通过标准的变分法定义。\n\n你的任务是，从第一性原理出发，且不依赖任何预先给定的封闭形式表达式，推导出一个拉格朗日乘子 $ \\lambda(t) $ 的显式表达式，该表达式在周期性边界条件下确保对所有 $ t $ 都全局守恒 $ \\int_0^{L_x} \\phi(x,t) \\, dx $。然后，基于你的推导，设计一个在数值上稳定的半隐式时间步进格式。该格式在一维空间中，对线性的界面项进行隐式处理，对非线性的体项进行显式处理，并使用傅里叶伪谱法在 $ N $ 个点的均匀网格上离散化空间导数。所有量均为无量纲；报告任何计算值时均使用无量纲单位。\n\n实现一个完整的程序，该程序：\n1. 使用推导出的半隐式格式在周期性区域上对 $ \\phi(x,t) $ 进行时间演化。\n2. 计算最终时刻 $ T $ 的绝对质量漂移，其定义为 $ \\left| \\int_0^{L_x} \\phi(x,T) \\, dx - \\int_0^{L_x} \\phi(x,0) \\, dx \\right| $。\n3. 生成单行输出，其中包含测试套件中每个测试用例的绝对质量漂移值，形式为用方括号括起来的逗号分隔列表。\n\n测试套件参数集如下：\n\n- 测试用例 A (一般情况)：\n  - 网格大小 $ N = 256 $，区域长度 $ L_x = 1.0 $，迁移率 $ M = 1.0 $，界面刚度 $ \\kappa = 0.01 $，时间步长 $ \\Delta t = 10^{-4} $，最终时刻 $ T = 0.02 $。\n  - 初始条件 $ \\phi(x,0) = 0.2 + 0.1 \\sin\\left( 2\\pi x / L_x \\right) + 0.05 \\sin\\left( 4\\pi x / L_x \\right) $。\n\n- 测试用例 B (均匀场边界情况)：\n  - 网格大小 $ N = 128 $，区域长度 $ L_x = 1.0 $，迁移率 $ M = 1.0 $，界面刚度 $ \\kappa = 0.05 $，时间步长 $ \\Delta t = 10^{-4} $，最终时刻 $ T = 0.01 $。\n  - 初始条件 $ \\phi(x,0) = 0.3 $ (常数)。\n\n- 测试用例 C (具有更强界面刚度和随机初始条件的边缘情况)：\n  - 网格大小 $ N = 256 $，区域长度 $ L_x = 1.0 $，迁移率 $ M = 0.5 $，界面刚度 $ \\kappa = 0.1 $，时间步长 $ \\Delta t = 5 \\times 10^{-5} $，最终时刻 $ T = 0.01 $。\n  - 初始条件 $ \\phi(x,0) $ 是按如下方式构造的零均值随机噪声：使用固定的伪随机种子，为 $ j = 0,\\dots,N-1 $ 抽取独立样本 $ \\eta_j \\sim \\mathcal{N}(0,1) $，设置 $ \\phi_j = 0.2 \\eta_j $，然后减去空间平均值，使得 $ \\int_0^{L_x} \\phi(x,0) \\, dx = 0 $。\n\n你的程序应生成单行输出，其中包含结果，形式为用方括号括起来的逗号分隔列表（例如，$ [r_A,r_B,r_C] $），其中每个条目是对应测试用例的绝对质量漂移，表示为无量纲单位的浮点数。不应打印其他任何输出。",
            "solution": "该问题要求推导并实现一个修正的 Allen-Cahn 方程的数值解，其中使用拉格朗日乘子来强制全局质量守恒。求解过程分为两个主要部分：拉格朗日乘子的解析推导和稳定数值算法的设计。\n\n**1. 拉格朗日乘子 $ \\lambda(t) $ 的推导**\n\n非守恒序参量 $ \\phi(x,t) $ 的控制方程为\n$$ \\frac{\\partial \\phi}{\\partial t} = -M \\left( \\frac{\\delta F}{\\delta \\phi} - \\lambda(t) \\right) $$\n其中 $ M > 0 $ 是一个常数迁移率，$ \\lambda(t) $ 是一个空间均匀的拉格朗日乘子。$ \\lambda(t) $ 的目的是强制总“质量”（空间积分的序参量）$ \\mathcal{M}(t) = \\int_0^{L_x} \\phi(x,t) \\, dx $ 的全局守恒。\n\n守恒约束意味着总质量的时间导数在所有时间 $ t \\ge 0 $ 内必须为零：\n$$ \\frac{d\\mathcal{M}}{dt} = \\frac{d}{dt} \\int_0^{L_x} \\phi(x,t) \\, dx = 0 $$\n假设 $ \\phi $ 足够光滑，允许交换微分和积分的顺序（莱布尼茨积分法则），我们有：\n$$ \\int_0^{L_x} \\frac{\\partial \\phi}{\\partial t} \\, dx = 0 $$\n将 $ \\partial \\phi / \\partial t $ 的控制方程代入：\n$$ \\int_0^{L_x} -M \\left( \\frac{\\delta F}{\\delta \\phi} - \\lambda(t) \\right) \\, dx = 0 $$\n由于 $ M $ 是一个正常数，可以从方程中消去。然后积分可以分为两部分：\n$$ \\int_0^{L_x} \\frac{\\delta F}{\\delta \\phi} \\, dx - \\int_0^{L_x} \\lambda(t) \\, dx = 0 $$\n根据定义，拉格朗日乘子 $ \\lambda(t) $ 是空间均匀的，因此可以从第二个积分中提出：\n$$ \\int_0^{L_x} \\frac{\\delta F}{\\delta \\phi} \\, dx - \\lambda(t) \\int_0^{L_x} \\, dx = 0 $$\n剩余的积分就是区域的长度 $ L_x $。\n$$ \\int_0^{L_x} \\frac{\\delta F}{\\delta \\phi} \\, dx - \\lambda(t) L_x = 0 $$\n解出 $ \\lambda(t) $ 得到通用表达式：\n$$ \\lambda(t) = \\frac{1}{L_x} \\int_0^{L_x} \\frac{\\delta F}{\\delta \\phi} \\, dx $$\n这表明 $ \\lambda(t) $ 是化学势 $ \\mu \\equiv \\delta F / \\delta \\phi $ 的空间平均值。\n\n接下来，我们求出化学势的具体形式。自由能泛函为\n$$ F[\\phi] = \\int_0^{L_x} \\left( \\frac{\\kappa}{2} \\left( \\frac{\\partial \\phi}{\\partial x} \\right)^2 + W(\\phi) \\right) \\, dx $$\n其中 $ \\kappa > 0 $ 且 $ W(\\phi) = \\frac{1}{4}(\\phi^2 - 1)^2 $。变分导数（或泛函导数）$ \\delta F / \\delta \\phi $ 通过计算一阶变分 $ \\delta F $ 得到：\n$$ \\delta F = F[\\phi + \\delta\\phi] - F[\\phi] \\approx \\int_0^{L_x} \\left( \\kappa \\frac{\\partial \\phi}{\\partial x} \\frac{\\partial(\\delta\\phi)}{\\partial x} + W'(\\phi) \\delta\\phi \\right) \\, dx $$\n其中 $ W'(\\phi) = \\frac{d W}{d \\phi} = \\phi^3 - \\phi $。对第一项进行分部积分：\n$$ \\int_0^{L_x} \\kappa \\frac{\\partial \\phi}{\\partial x} \\frac{\\partial(\\delta\\phi)}{\\partial x} \\, dx = \\left[ \\kappa \\frac{\\partial \\phi}{\\partial x} \\delta\\phi \\right]_0^{L_x} - \\int_0^{L_x} \\kappa \\frac{\\partial^2 \\phi}{\\partial x^2} \\delta\\phi \\, dx $$\n由于区域 $ [0, L_x] $ 上的周期性边界条件，边界项 $ \\left[ \\dots \\right]_0^{L_x} $ 为零。因此，\n$$ \\delta F = \\int_0^{L_x} \\left( -\\kappa \\frac{\\partial^2 \\phi}{\\partial x^2} + W'(\\phi) \\right) \\delta\\phi \\, dx $$\n根据定义，$ \\delta F = \\int_0^{L_x} (\\delta F / \\delta \\phi) \\delta\\phi \\, dx $，因此我们可以确定化学势：\n$$ \\frac{\\delta F}{\\delta \\phi} = -\\kappa \\frac{\\partial^2 \\phi}{\\partial x^2} + W'(\\phi) = -\\kappa \\nabla^2 \\phi + \\phi^3 - \\phi $$\n将此代入 $ \\lambda(t) $ 的表达式中：\n$$ \\lambda(t) = \\frac{1}{L_x} \\int_0^{L_x} \\left( -\\kappa \\frac{\\partial^2 \\phi}{\\partial x^2} + \\phi^3 - \\phi \\right) \\, dx $$\n拉普拉斯项在周期性区域上的积分为零：\n$$ \\int_0^{L_x} \\frac{\\partial^2 \\phi}{\\partial x^2} \\, dx = \\left[ \\frac{\\partial \\phi}{\\partial x} \\right]_0^{L_x} = 0 $$\n这留下了一个简化的、显式的拉格朗日乘子表达式，它只依赖于场 $ \\phi(x,t) $ 的当前状态：\n$$ \\lambda(t) = \\frac{1}{L_x} \\int_0^{L_x} (\\phi(x,t)^3 - \\phi(x,t)) \\, dx $$\n这就是非线性驱动项 $ W'(\\phi) $ 的空间平均值。\n\n**2. 数值算法：半隐式傅里叶伪谱法**\n\n利用推导出的 $ \\lambda(t) $ 表达式，完整的控制方程为：\n$$ \\frac{\\partial \\phi}{\\partial t} = M\\kappa \\nabla^2 \\phi - M(\\phi^3 - \\phi) + M \\lambda(t) $$\n$ M\\kappa \\nabla^2 \\phi $ 项是线性的，但包含高阶空间导数，使其具有刚性。为了在合理的时间步长下保持数值稳定性，必须对该项进行隐式处理。$ - M(\\phi^3 - \\phi) + M \\lambda(t) $ 项是非线性的，但在空间上是局域的，可以进行显式处理。这就导出了一个半隐式时间步进格式。\n\n使用基于一阶欧拉法的半隐式格式，我们在时间上从 $ t_n = n \\Delta t $ 到 $ t_{n+1} = (n+1) \\Delta t $ 进行离散化：\n$$ \\frac{\\phi^{n+1} - \\phi^n}{\\Delta t} = M\\kappa \\nabla^2 \\phi^{n+1} - M\\left((\\phi^n)^3 - \\phi^n\\right) + M \\lambda^n $$\n其中 $ \\phi^n $ 代表 $ \\phi(x, t_n) $，$ \\lambda^n $ 由 $ \\phi^n $ 计算得出：\n$$ \\lambda^n = \\frac{1}{L_x} \\int_0^{L_x} \\left((\\phi^n)^3 - \\phi^n\\right) \\, dx $$\n对于空间离散化，我们使用傅里叶伪谱法。我们在 $ N $ 个点的均匀网格上表示 $ \\phi(x,t) $，其中 $ x_j = j \\Delta x $ 且 $ \\Delta x = L_x / N $。在傅里叶空间中，场由其系数 $ \\hat{\\phi}(k) $ 表示，其中 $ k $ 是波矢。导数运算 $ \\nabla^2 $ 变为代数乘法 $ -k^2 $。\n令 $ \\hat{\\phi}^n(k) = \\mathcal{F}\\{\\phi^n(x)\\} $ 为 $ \\phi^n $ 的快速傅里叶变换 (FFT)。对时间离散化的方程应用 FFT 得到：\n$$ \\frac{\\hat{\\phi}^{n+1} - \\hat{\\phi}^n}{\\Delta t} = M\\kappa (-k^2) \\hat{\\phi}^{n+1} + \\mathcal{F}\\left\\{- M\\left((\\phi^n)^3 - \\phi^n\\right) + M \\lambda^n\\right\\} $$\n令 $ R^n = - M((\\phi^n)^3 - \\phi^n) + M \\lambda^n $ 为在实空间中计算的右侧显式部分。傅里叶空间中的方程变为：\n$$ \\frac{\\hat{\\phi}^{n+1} - \\hat{\\phi}^n}{\\Delta t} = -M\\kappa k^2 \\hat{\\phi}^{n+1} + \\hat{R}^n $$\n其中 $ \\hat{R}^n = \\mathcal{F}\\{R^n\\} $。我们现在可以代数求解更新后的傅里叶系数 $ \\hat{\\phi}^{n+1} $：\n$$ \\hat{\\phi}^{n+1} (1 + \\Delta t M \\kappa k^2) = \\hat{\\phi}^n + \\Delta t \\hat{R}^n $$\n$$ \\hat{\\phi}^{n+1}(k) = \\frac{\\hat{\\phi}^n(k) + \\Delta t \\hat{R}^n(k)}{1 + \\Delta t M \\kappa k^2} $$\n这个方程给出了傅里叶空间中场的更新规则。\n\n**单个时间步的计算过程摘要：**\n1. 给定时刻 $ t_n $ 的 $ \\phi^n(x) $。\n2. 在实空间中，计算非线性项 $ W'(\\phi^n) = (\\phi^n)^3 - \\phi^n $。\n3. 在实空间中，计算拉格朗日乘子 $ \\lambda^n = \\frac{1}{N} \\sum_{j=0}^{N-1} W'(\\phi_j^n) $，这是空间平均 $ \\frac{1}{L_x} \\int W'(\\phi^n) \\, dx $ 的离散近似。\n4. 在实空间中，计算总的显式更新项：$ R^n = -M W'(\\phi^n) + M \\lambda^n $。\n5. 使用 FFT 将当前状态 $ \\phi^n $ 和显式项 $ R^n $ 变换到傅里叶空间，得到 $ \\hat{\\phi}^n $ 和 $ \\hat{R}^n $。对于实值场，实数 FFT (`rfft`) 效率最高。\n6. 对所有波矢 $ k $，在傅里叶空间中应用更新规则，求得 $ \\hat{\\phi}^{n+1} $。\n7. 使用逆 FFT (`irfft`) 将 $ \\hat{\\phi}^{n+1} $ 变换回实空间，得到 $ \\phi^{n+1}(x) $。\n8. 重复执行所需的时间步数。\n\n然后，绝对质量漂移计算为 $ \\left| \\sum_{j=0}^{N-1} \\phi_j(T) \\Delta x - \\sum_{j=0}^{N-1} \\phi_j(0) \\Delta x \\right| $。该格式确保质量在机器精度范围内守恒，因为 $ \\lambda(t) $ 的推导在连续层面上精确地抵消了动力学中的非守恒部分。任何观测到的漂移都是由浮点和时间离散化误差引起的。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(N, Lx, M, kappa, dt, T, phi_0_func, seed=None):\n    \"\"\"\n    Solves the conserved Allen-Cahn equation using a semi-implicit\n    Fourier pseudospectral method.\n\n    Args:\n        N (int): Number of grid points.\n        Lx (float): Length of the periodic domain.\n        M (float): Mobility constant.\n        kappa (float): Interfacial stiffness.\n        dt (float): Time step size.\n        T (float): Final time.\n        phi_0_func (callable): Function to generate the initial condition.\n        seed (int, optional): Seed for the random number generator.\n\n    Returns:\n        float: The absolute mass drift at the final time.\n    \"\"\"\n    # 1. Initialization\n    dx = Lx / N\n    x = np.linspace(0, Lx, N, endpoint=False)\n    \n    # Wavevectors for real FFT (rfft)\n    k = np.fft.rfftfreq(N, d=dx) * 2 * np.pi\n    k_sq = k**2\n\n    # Set seed if provided (for Test Case C)\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Generate initial condition using the provided function\n    phi = phi_0_func(x, N, Lx)\n\n    # Calculate initial mass\n    mass_initial = np.sum(phi) * dx\n\n    # Time-stepping parameters\n    n_steps = int(T / dt)\n\n    # Pre-compute the denominator for the update step for efficiency\n    update_denominator = 1.0 + dt * M * kappa * k_sq\n\n    # 2. Time-stepping loop\n    for _ in range(n_steps):\n        # a. Nonlinear chemical potential term in real space\n        W_prime = phi**3 - phi\n        \n        # b. Lagrange multiplier (spatial average of W_prime)\n        lambda_t = np.mean(W_prime)\n        \n        # c. Full explicit part of the right-hand side in real space\n        R = -M * W_prime + M * lambda_t\n        \n        # d. Transform to Fourier space\n        phi_hat = np.fft.rfft(phi)\n        R_hat = np.fft.rfft(R)\n        \n        # e. Update in Fourier space\n        phi_hat_new = (phi_hat + dt * R_hat) / update_denominator\n        \n        # f. Transform back to real space, ensuring correct size for odd N\n        phi = np.fft.irfft(phi_hat_new, n=N)\n\n    # 3. Finalization\n    mass_final = np.sum(phi) * dx\n    mass_drift = np.abs(mass_final - mass_initial)\n    \n    return mass_drift\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the results in the\n    specified format.\n    \"\"\"\n\n    # Initial condition functions for each test case\n    def ic_A(x, N, Lx):\n        return 0.2 + 0.1 * np.sin(2 * np.pi * x / Lx) + 0.05 * np.sin(4 * np.pi * x / Lx)\n\n    def ic_B(x, N, Lx):\n        return 0.3 * np.ones_like(x)\n\n    def ic_C(x, N, Lx):\n        # The seed is set in run_simulation before this function is called.\n        # Generate zero-mean random noise as specified.\n        noise = 0.2 * np.random.randn(N)\n        return noise - np.mean(noise)\n\n    test_cases = [\n        # Test Case A\n        {\"N\": 256, \"Lx\": 1.0, \"M\": 1.0, \"kappa\": 0.01, \"dt\": 1e-4, \"T\": 0.02, \"phi_0_func\": ic_A, \"seed\": None},\n        # Test Case B\n        {\"N\": 128, \"Lx\": 1.0, \"M\": 1.0, \"kappa\": 0.05, \"dt\": 1e-4, \"T\": 0.01, \"phi_0_func\": ic_B, \"seed\": None},\n        # Test Case C (using fixed seed 42 as per problem description)\n        {\"N\": 256, \"Lx\": 1.0, \"M\": 0.5, \"kappa\": 0.1, \"dt\": 5e-5, \"T\": 0.01, \"phi_0_func\": ic_C, \"seed\": 42},\n    ]\n\n    results = []\n    for params in test_cases:\n        drift = run_simulation(**params)\n        results.append(drift)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}