{
    "hands_on_practices": [
        {
            "introduction": "多尺度建模中最基本的概念之一是如何将来自不同理论的能量组合成一个统一的描述。量子力学/分子力学 (QM/MM) 方法是这一思想的经典范例，其核心挑战在于如何在利用量子力学 (QM) 的高精度处理关键区域的同时，保持分子力学 (MM) 对大环境的计算效率，并避免重复计算。本练习  通过一个清晰的减法方案，让您亲手实践能量耦合的基本逻辑，为理解更复杂的耦合方法打下基础。",
            "id": "3439662",
            "problem": "一个三原子分子体系为了进行量子力学/分子力学 (QM/MM) 处理，被划分为两个区域：一个量子力学 (QM) 区域和一个分子力学 (MM) 环境。目标是获得一个一致的总能量，该能量用 QM 描述替换 QM 区域的 MM 描述，同时保留整个体系的 MM 描述，并避免对 QM 区域的双重计算。考虑以下在不同模型下计算得到的能量：\n\n- $E_{\\mathrm{QM}}(\\mathrm{QM})=-100.0\\,\\mathrm{kcal/mol}$，在量子力学水平上计算的 QM 区域的能量。\n- $E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM})=-250.0\\,\\mathrm{kcal/mol}$，在分子力学水平上计算的整个体系的能量。\n- $E_{\\mathrm{MM}}(\\mathrm{QM})=-120.0\\,\\mathrm{kcal/mol}$，在分子力学水平上计算的 QM 区域的能量。\n\n从这样一个概念原则出发：所期望的复合能量应反映整个体系的 MM 描述，其中 QM 区域的 MM 能量被其 QM 能量所取代。请推导出一个合适的减法机械嵌入表达式来计算复合能量 $E_{\\mathrm{sub}}$，并对其进行数值计算。然后，解释在减法 QM/MM 嵌入的背景下，$E_{\\mathrm{sub}}$ 的物理意义，及其数值对于 QM 描述与 MM 描述下 QM 区域的相对稳定性意味着什么。以 $\\mathrm{kcal/mol}$ 为单位表示最终能量。无需四舍五入。",
            "solution": "首先对问题进行严格的验证过程。\n\n### 步骤 1：提取已知条件\n提供了以下数据和定义：\n- 在 QM 理论水平上计算的量子力学 (QM) 区域的能量：$E_{\\mathrm{QM}}(\\mathrm{QM}) = -100.0\\,\\mathrm{kcal/mol}$。\n- 在 MM 理论水平上计算的整个体系（QM 区域 + 分子力学 (MM) 区域）的能量：$E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM}) = -250.0\\,\\mathrm{kcal/mol}$。\n- 在 MM 理论水平上计算的 QM 区域的能量：$E_{\\mathrm{MM}}(\\mathrm{QM}) = -120.0\\,\\mathrm{kcal/mol}$。\n- 任务是推导复合能量 $E_{\\mathrm{sub}}$ 的减法机械嵌入表达式，对其进行求值，并解释其物理意义。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据所需标准对问题陈述进行评估。\n- **科学依据**：该问题描述了 QM/MM 计算的减法方案，这是计算化学中多尺度建模的基石。其公式和避免双重计算的概念是标准的且科学合理的。\n- **适定性**：该问题提供了构建和评估标准双层减法 QM/MM 能量所需的所有能量项。目标是计算一个唯一定义的值 $E_{\\mathrm{sub}}$，并提供标准的物理解释。存在一个唯一、稳定且有意义的解。\n- **客观性**：该问题使用计算化学领域的精确标准术语（$E_{\\mathrm{QM}}$、$E_{\\mathrm{MM}}$、QM/MM 等）表述，没有主观或模糊的语言。\n\n### 步骤 3：结论与行动\n该问题科学合理、适定且客观。判定为**有效**。因此，将提供完整解答。\n\n### 解答推导\nQM/MM 计算的目标是用高水平的量子力学理论描述化学活性区域（QM 区域），同时用计算成本较低的分子力学力场处理系统的其余部分（MM 环境）。减法方案是结合这些描述的最简单和最常见的方法之一。\n\n正如问题所述，核心原则是从在低水平（MM）上计算的整个系统的能量开始，然后应用一个校正。这个校正用其准确的高水平描述取代了 QM 区域不准确的低水平描述。\n\n设整个系统表示为 $\\mathrm{S} = \\mathrm{QM} + \\mathrm{MM}$。\n由 MM 力场计算的完整系统的能量为 $E_{\\mathrm{MM}}(\\mathrm{S})$，它等同于 $E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM})$。这一项错误地描述了 QM 区域。\n\n为了校正这一点，我们必须首先减去在 MM 水平上计算的 QM 区域的贡献。这个贡献由 $E_{\\mathrm{MM}}(\\mathrm{QM})$ 给出。从总 MM 能量中移除这一项，就消除了对 QM 部分的不正确描述。\n\n接下来，我们必须加上在 QM 理论水平上正确计算的 QM 区域的能量。这一项由 $E_{\\mathrm{QM}}(\\mathrm{QM})$ 给出。\n\n结合这些步骤，得到减法 QM/MM 能量 $E_{\\mathrm{sub}}$ 的通用表达式：\n$$E_{\\mathrm{sub}} = E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM}) - E_{\\mathrm{MM}}(\\mathrm{QM}) + E_{\\mathrm{QM}}(\\mathrm{QM})$$\n这个表达式避免了对 QM 区域能量的双重计算。它代表了一个模型，其中 QM 区域的内能是量子力学决定的，而其与 MM 环境的相互作用以及 MM 环境自身的内能是经典力学决定的。这种特定的表述方式对应于机械嵌入方案，因为 QM 和 MM 区域之间的耦合完全包含在 $E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM})$ 项中，因此仅在 MM 水平上描述。\n\n现在，我们将给定的数值代入这个表达式：\n- $E_{\\mathrm{QM}}(\\mathrm{QM}) = -100.0\\,\\mathrm{kcal/mol}$\n- $E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM}) = -250.0\\,\\mathrm{kcal/mol}$\n- $E_{\\mathrm{MM}}(\\mathrm{QM}) = -120.0\\,\\mathrm{kcal/mol}$\n\n$$E_{\\mathrm{sub}} = (-250.0\\,\\mathrm{kcal/mol}) - (-120.0\\,\\mathrm{kcal/mol}) + (-100.0\\,\\mathrm{kcal/mol})$$\n$$E_{\\mathrm{sub}} = -250.0 + 120.0 - 100.0\\,\\mathrm{kcal/mol}$$\n$$E_{\\mathrm{sub}} = -130.0 - 100.0\\,\\mathrm{kcal/mol}$$\n$$E_{\\mathrm{sub}} = -230.0\\,\\mathrm{kcal/mol}$$\n\n### 物理解释\n计算出的能量 $E_{\\mathrm{sub}} = -230.0\\,\\mathrm{kcal/mol}$ 是减法 QM/MM 框架内系统的估算总能量。它代表了系统能量的一个近似值，其中 QM 区域由量子力学描述，而 MM 区域及 QM-MM 相互作用由经典力场描述。\n\n$E_{\\mathrm{sub}}$ 的公式可以重排以突出校正项：\n$$E_{\\mathrm{sub}} = E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM}) + \\left[ E_{\\mathrm{QM}}(\\mathrm{QM}) - E_{\\mathrm{MM}}(\\mathrm{QM}) \\right]$$\n方括号中的项 $E_{\\mathrm{QM}}(\\mathrm{QM}) - E_{\\mathrm{MM}}(\\mathrm{QM})$ 代表了从 QM 区域的 MM 描述切换到 QM 描述所产生的能量校正。\n在本例中，校正值为：\n$$\\Delta E_{\\mathrm{correction}} = (-100.0\\,\\mathrm{kcal/mol}) - (-120.0\\,\\mathrm{kcal/mol}) = +20.0\\,\\mathrm{kcal/mol}$$\n这个正值意味着，与更准确的 QM 计算相比，MM 力场将孤立的 QM 区域过度稳定化了 $20.0\\,\\mathrm{kcal/mol}$。QM 水平的计算发现 QM 区域的内在稳定性比 MM 力场预测的要低（能量更高）。减法 QM/MM 能量 $E_{\\mathrm{sub}}$ 包含了这个校正，得到的总能量（$-230.0\\,\\mathrm{kcal/mol}$）比整个系统的纯经典计算（$E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM}) = -250.0\\,\\mathrm{kcal/mol}$）要高（更不稳定）。这种调整对于获得复合体系更符合物理现实的能量至关重要。",
            "answer": "$$\n\\boxed{-230.0}\n$$"
        },
        {
            "introduction": "在将能量混合的概念扩展到空间耦合模型（例如原子-连续介质模型）时，我们面临着新的挑战，即确保两种模型在界面处的物理一致性。“补丁测试” (patch test) 是一种基础的一致性检验，而当耦合方案不满足该检验时，便会出现被称为“伪力” (ghost forces) 的非物理作用力。本练习  将指导您在并发耦合的背景下诊断并修正这些关键的界面伪影，这是掌握并发多尺度方法有效性的核心技能。",
            "id": "3467957",
            "problem": "考虑一个由$N$个节点组成的一维周期性晶格，其参考间距为$a_0$，位置为$\\{x_i\\}_{i=0}^{N-1}$，按模$N$索引。该晶格具有直至次近邻的谐波对相互作用，其刚度分别为$k_1$和$k_2$。定义均匀变形梯度$F$，使得对所有$i$均有$x_i = F a_0 i$。节点$i$处的原子点能量$E_i^{\\text{a}}(x)$通过将键能均等分配到相邻格点来构建：\n$$\nE_i^{\\text{a}}(x) = \\frac{k_1}{4} \\left[(x_i - x_{i-1} - a_0)^2 + (x_{i+1} - x_i - a_0)^2\\right] + \\frac{k_2}{4} \\left[(x_i - x_{i-2} - 2 a_0)^2 + (x_{i+2} - x_i - 2 a_0)^2\\right].\n$$\n连续介质点能量$E_i^{\\text{cb}}(F)$通过柯西-玻恩定则（CB）定义，即代表性晶胞在均匀变形$F$下的原子能量：\n$$\nE_i^{\\text{cb}}(F) = \\frac{k_1}{2} a_0^2 (F - 1)^2 + \\frac{k_2}{2} (2 a_0)^2 (F - 1)^2.\n$$\n考虑一种并发原子-连续介质耦合，其混合权重$w_i \\in [0,1]$在空间上变化，其中$w_i = 1$表示纯原子区域，$w_i = 0$表示纯连续介质区域。混合能量为\n$$\nE^{\\text{blend}}(x;F,w) = \\sum_{i=0}^{N-1} \\left[ w_i E_i^{\\text{a}}(x) + (1 - w_i) E_i^{\\text{cb}}(F) \\right].\n$$\n在均匀变形$F = \\text{const}$下，斑块检验要求内力为零。定义离散内力矢量为\n$$\nf_i^{\\text{ghost}}(F,w) = - \\frac{\\partial E^{\\text{blend}}(x;F,w)}{\\partial x_i} \\bigg|_{x_i = F a_0 i}.\n$$\n在均匀$F$下，这些非零的力被称为鬼力。在一维情况下，定义残余应力矢量与单位横截面积下的力矢量相同。残余应力范数为\n$$\n\\|\\boldsymbol{\\sigma}_{\\text{ghost}}\\| = \\left( \\sum_{i=0}^{N-1} \\left( f_i^{\\text{ghost}} \\right)^2 \\right)^{1/2}.\n$$\n您的任务是：\n1. 从给定的定义和经典力学（力是势能的负梯度）出发，计算在均匀变形$F$下，给定一组耦合权重$\\{w_i\\}$时的$f_i^{\\text{ghost}}(F,w)$。\n2. 提出一种混合能量修正方法，以消除均匀变形下的鬼力。通过添加一个$E^{\\text{corr}}(x)$项来实现最简单的线性鬼力修正，使得\n$$\n- \\frac{\\partial}{\\partial x_i} \\left( E^{\\text{blend}}(x;F,w) + E^{\\text{corr}}(x) \\right) \\bigg|_{x_i = F a_0 i} = 0 \\quad \\text{for all } i,\n$$\n并量化修正后的残余应力范数。\n3. 对每个测试用例，返回以下列表：$[G_{\\text{naive}}, G_{\\text{corrected}}, S_{\\text{naive}}, S_{\\text{corrected}}]$，其中$G_{\\text{naive}}$是未经修正的鬼力矢量的欧几里得范数，$G_{\\text{corrected}}$是施加了所提出的修正后的同一范数，$S_{\\text{naive}} = \\|\\boldsymbol{\\sigma}_{\\text{ghost}}\\|$是未经修正的范数，$S_{\\text{corrected}} = \\|\\boldsymbol{\\sigma}_{\\text{ghost}}\\|$是修正后的范数。在整个计算中使用无量纲单位。\n\n使用以下测试套件，其中权重定义在按模$N$的索引$i \\in \\{0,1,\\dots,N-1\\}$上：\n- 情况A（平滑混合，小应变）：$N = 64$，$a_0 = 1.0$，$k_1 = 1.0$，$k_2 = 0.25$，$F = 1.02$，和一个线性斜坡$w_i$，其中对于$i \\leq 16$，$w_i = 1$；对于$i \\geq 48$，$w_i = 0$；对于$i \\in (16,48)$，$w_i = 1 - \\frac{i - 16}{48 - 16}$。\n- 情况B（平滑混合，较大应变）：$N = 64$，$a_0 = 1.0$，$k_1 = 1.0$，$k_2 = 0.25$，$F = 1.10$，使用与情况A相同的线性斜坡$w_i$。\n- 情况C（尖锐界面）：$N = 64$，$a_0 = 1.0$，$k_1 = 1.0$，$k_2 = 0.25$，$F = 1.05$，和一个阶跃混合$w_i$，其中对于$i  32$，$w_i = 1$；对于$i \\geq 32$，$w_i = 0$。\n- 情况D（小系统，混合相互作用）：$N = 8$，$a_0 = 1.0$，$k_1 = 1.0$，$k_2 = 0.5$，$F = 1.03$，和一个线性斜坡$w_i$，其中对于$i \\leq 2$，$w_i = 1$；对于$i \\geq 6$，$w_i = 0$；对于$i \\in (2,6)$，$w_i = 1 - \\frac{i - 2}{6 - 2}$。\n\n您的程序应生成单行输出，其中包含结果，格式为每个案例一个列表，并以逗号分隔，无空格，用方括号括起来。例如：\"[[rA1,rA2,rA3,rA4],[rB1,rB2,rB3,rB4],...]\"。每个$r$都必须是无量纲单位的浮点数。",
            "solution": "该问题要求分析一维并发原子-连续介质耦合系统中的鬼力。首先，我们必须推导鬼力的解析表达式，鬼力是在耦合方案不保持能量一致性时，在均匀变形下产生的虚假内力。其次，我们必须提出并实施一种修正方法来消除这些力。最后，我们对几个测试用例，量化修正前后这些力的大小。\n\n### 1. 鬼力矢量的推导\n\n系统的总混合能量由下式给出：\n$$\nE^{\\text{blend}}(x;F,w) = \\sum_{i=0}^{N-1} \\left[ w_i E_i^{\\text{a}}(x) + (1 - w_i) E_i^{\\text{cb}}(F) \\right]\n$$\n原子$i$上的内力定义为势能相对于其位置$x_i$的负梯度。鬼力$f_i^{\\text{ghost}}$是在所有原子都根据均匀变形梯度$F$（即对所有$k$都有$x_k = F a_0 k$）发生位移的构型下计算得到的该力。\n$$\nf_i^{\\text{ghost}}(F,w) = - \\frac{\\partial E^{\\text{blend}}(x;F,w)}{\\partial x_i} \\bigg|_{x_k = F a_0 k}\n$$\n连续介质点能量$E_i^{\\text{cb}}(F)$仅取决于全局变形参数$F$，而不取决于单个原子位置$x_k$。因此，它对任何$x_i$的偏导数都为零。计算简化为仅对能量的原子部分求导：\n$$\nf_i^{\\text{ghost}}(F,w) = - \\frac{\\partial}{\\partial x_i} \\left( \\sum_{j=0}^{N-1} w_j E_j^{\\text{a}}(x) \\right) \\bigg|_{x_k = F a_0 k}\n$$\n所提供的原子点能量$E_j^{\\text{a}}(x)$是通过均分键能构建的。总原子势能$U^{\\text{a}}(x) = \\sum_j w_j E_j^{\\text{a}}(x)$可以重新表示为对键的求和。原子$j$和$j+m$（其中$m=1$或$m=2$）之间的键能被分配到格点$j$和$j+m$上。对应于最近邻键的项$(x_{j+1}-x_j-a_0)^2$出现在$E_j^{\\text{a}}$和$E_{j+1}^{\\text{a}}$中。它对$U^{\\text{a}}(x)$的总贡献受到其端点权重平均值$(w_j+w_{j+1})/2$的调制。类似的论证也适用于次近邻。这使我们能够更方便地写出总原子能量：\n$$\nU^{\\text{a}}(x) = \\sum_{j=0}^{N-1} \\left[ \\frac{k_1}{4}(w_j + w_{j+1})(x_{j+1} - x_j - a_0)^2 + \\frac{k_2}{4}(w_j + w_{j+2})(x_{j+2} - x_j - 2a_0)^2 \\right]\n$$\n现在，我们对$U^{\\text{a}}(x)$关于$x_i$求导。变量$x_i$出现在涉及其邻居的项中。对于最近邻相互作用：\n$$\n\\frac{\\partial}{\\partial x_i} \\left[ \\frac{k_1}{4}(w_{i-1}+w_i)(x_i-x_{i-1}-a_0)^2 + \\frac{k_1}{4}(w_i+w_{i+1})(x_{i+1}-x_i-a_0)^2 \\right] \\\\\n= \\frac{k_1}{2}(w_{i-1}+w_i)(x_i-x_{i-1}-a_0) - \\frac{k_1}{2}(w_i+w_{i+1})(x_{i+1}-x_i-a_0)\n$$\n对于次近邻相互作用：\n$$\n\\frac{\\partial}{\\partial x_i} \\left[ \\frac{k_2}{4}(w_{i-2}+w_i)(x_i-x_{i-2}-2a_0)^2 + \\frac{k_2}{4}(w_i+w_{i+2})(x_{i+2}-x_i-2a_0)^2 \\right] \\\\\n= \\frac{k_2}{2}(w_{i-2}+w_i)(x_i-x_{i-2}-2a_0) - \\frac{k_2}{2}(w_i+w_{i+2})(x_{i+2}-x_i-2a_0)\n$$\n我们现在在均匀变形状态$x_k = F a_0 k$下评估这些导数。键伸长量变为：\n$x_{i+m} - x_i - m a_0 = F a_0 (i+m) - F a_0 i - m a_0 = m a_0 (F-1)$。\n将此代入导数中：\n$$\n\\frac{\\partial U^{\\text{a}}}{\\partial x_i}\\bigg|_{x_k=Fa_0k} = \\frac{k_1}{2}(w_{i-1}+w_i)(a_0(F-1)) - \\frac{k_1}{2}(w_i+w_{i+1})(a_0(F-1)) \\\\\n+ \\frac{k_2}{2}(w_{i-2}+w_i)(2a_0(F-1)) - \\frac{k_2}{2}(w_i+w_{i+2})(2a_0(F-1))\n$$\n提出公因子可得：\n$$\n\\frac{\\partial U^{\\text{a}}}{\\partial x_i}\\bigg|_{x_k=Fa_0k} = \\frac{k_1 a_0(F-1)}{2} (w_{i-1} - w_{i+1}) + k_2 a_0(F-1) (w_{i-2} - w_{i+2})\n$$\n鬼力是该表达式的负值：\n$$\nf_i^{\\text{ghost}} = - \\frac{\\partial U^{\\text{a}}}{\\partial x_i}\\bigg|_{x_k=Fa_0k} = a_0(F-1) \\left[ \\frac{k_1}{2}(w_{i+1} - w_{i-1}) + k_2(w_{i+2} - w_{i-2}) \\right]\n$$\n此公式表明，鬼力仅在权重函数$w_i$变化的区域非零，因为力的表达式类似于$w$的导数的有限差分近似。在$w_i$为常数（全原子或全连续介质）的区域，力按要求消失。\n\n### 2. 鬼力修正\n\n如果在均匀变形下内力为零，则通过斑块检验。我们推导出的$f_i^{\\text{ghost}}$在界面区域通常不为零。为了修正这一点，我们引入一个修正能量$E^{\\text{corr}}(x)$，使得总力为零：\n$$\nf_i^{\\text{total}} = - \\frac{\\partial}{\\partial x_i} \\left( E^{\\text{blend}}(x;F,w) + E^{\\text{corr}}(x) \\right) \\bigg|_{x_k = F a_0 k} = 0\n$$\n这意味着来自修正项的力必须精确抵消鬼力：\n$$\nf_i^{\\text{corr}} = - \\frac{\\partial E^{\\text{corr}}(x)}{\\partial x_i} \\bigg|_{x_k=Fa_0k} = -f_i^{\\text{ghost}}\n$$\n问题要求最简单的线性鬼力修正。对于给定的一组参数$\\{F, w_i, k_1, k_2, a_0\\}$，$f_i^{\\text{ghost}}$是常数，因为它们不依赖于动态位置$x_i$。相对于位置为常数的力是由一个位置的线性函数形式的势能产生的。我们定义修正能量为：\n$$\nE^{\\text{corr}}(x) = \\sum_{j=0}^{N-1} f_j^{\\text{ghost}} x_j\n$$\n那么格点$i$处的修正力为：\n$$\nf_i^{\\text{corr}} = - \\frac{\\partial E^{\\text{corr}}}{\\partial x_i} = -f_i^{\\text{ghost}}\n$$\n在修正后的系统中，于均匀变形状态下评估的原子$i$上的总力为：\n$$\nf_i^{\\text{total}} = f_i^{\\text{ghost}} + f_i^{\\text{corr}} = f_i^{\\text{ghost}} - f_i^{\\text{ghost}} = 0\n$$\n因此，修正后的系统通过构造满足了斑块检验。所有原子上的鬼力都恒为零。\n\n### 3. 范数的量化\n\n我们被要求为每个测试用例计算四个量：\n- $G_{\\text{naive}}$：未经修正的鬼力矢量$\\|\\boldsymbol{f}^{\\text{ghost}}\\|$的欧几里得范数。\n- $G_{\\text{corrected}}$：修正后的鬼力矢量的欧几里得范数。\n- $S_{\\text{naive}}$：未经修正的残余应力范数$\\|\\boldsymbol{\\sigma}_{\\text{ghost}}\\|$。\n- $S_{\\text{corrected}}$：修正后的残余应力范数。\n\n根据推导：\n未经修正的鬼力范数为：\n$$\nG_{\\text{naive}} = \\left( \\sum_{i=0}^{N-1} (f_i^{\\text{ghost}})^2 \\right)^{1/2}\n$$\n修正后的鬼力矢量是零矢量，所以其范数为：\n$$\nG_{\\text{corrected}} = 0\n$$\n问题陈述，残余应力矢量与力矢量相同（假设单位横截面积）。因此，应力范数在数值上与力范数相同：\n$$\nS_{\\text{naive}} = G_{\\text{naive}}\n$$\n$$\nS_{\\text{corrected}} = G_{\\text{corrected}} = 0\n$$\n每个案例的最终输出是列表$[G_{\\text{naive}}, 0.0, G_{\\text{naive}}, 0.0]$。我们现在将为指定的测试用例实现$G_{\\text{naive}}$的计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the ghost force norms for several atomistic-continuum coupling scenarios.\n    \"\"\"\n\n    test_cases = [\n        # Case A: Smooth blending, small strain\n        {\n            \"N\": 64, \"a0\": 1.0, \"k1\": 1.0, \"k2\": 0.25, \"F\": 1.02,\n            \"w_type\": \"linear\", \"w_params\": {\"i1\": 16, \"i2\": 48}\n        },\n        # Case B: Smooth blending, larger strain\n        {\n            \"N\": 64, \"a0\": 1.0, \"k1\": 1.0, \"k2\": 0.25, \"F\": 1.10,\n            \"w_type\": \"linear\", \"w_params\": {\"i1\": 16, \"i2\": 48}\n        },\n        # Case C: Sharp interface\n        {\n            \"N\": 64, \"a0\": 1.0, \"k1\": 1.0, \"k2\": 0.25, \"F\": 1.05,\n            \"w_type\": \"step\", \"w_params\": {\"isplit\": 32}\n        },\n        # Case D: Small system, mixed interactions\n        {\n            \"N\": 8, \"a0\": 1.0, \"k1\": 1.0, \"k2\": 0.5, \"F\": 1.03,\n            \"w_type\": \"linear\", \"w_params\": {\"i1\": 2, \"i2\": 6}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a0, k1, k2, F = case[\"N\"], case[\"a0\"], case[\"k1\"], case[\"k2\"], case[\"F\"]\n        \n        # Construct the weight vector w\n        w = np.zeros(N)\n        if case[\"w_type\"] == \"linear\":\n            i1, i2 = case[\"w_params\"][\"i1\"], case[\"w_params\"][\"i2\"]\n            # w_i = 1 for i = i1\n            w[0:i1 + 1] = 1.0\n            # Linear ramp for i in (i1, i2)\n            ramp_indices = np.arange(i1 + 1, i2)\n            w[ramp_indices] = 1.0 - (ramp_indices - i1) / (i2 - i1)\n            # w_i = 0 for i >= i2 is already set by np.zeros initialization\n            \n        elif case[\"w_type\"] == \"step\":\n            isplit = case[\"w_params\"][\"isplit\"]\n            w[0:isplit] = 1.0\n            # The rest are already zero\n            \n        # Calculate ghost forces using a vectorized approach for periodic boundaries\n        # w_{i+1} corresponds to rolling the array left by 1\n        w_ip1 = np.roll(w, -1)\n        w_im1 = np.roll(w, 1)\n        w_ip2 = np.roll(w, -2)\n        w_im2 = np.roll(w, 2)\n        \n        # Formula for ghost force:\n        # f_i^ghost = a0*(F-1) * [ k1/2 * (w_{i+1} - w_{i-1}) + k2 * (w_{i+2} - w_{i-2}) ]\n        f_ghost = a0 * (F - 1) * (0.5 * k1 * (w_ip1 - w_im1) + k2 * (w_ip2 - w_im2))\n        \n        # Task 3: Calculate norms\n        # G_naive is the Euclidean norm of the uncorrected ghost force vector\n        g_naive = np.linalg.norm(f_ghost)\n        \n        # G_corrected is 0 by construction of the linear force correction\n        g_corrected = 0.0\n        \n        # S_naive and S_corrected are numerically identical to G_naive and G_corrected\n        # as per the problem statement (unit cross-sectional area)\n        s_naive = g_naive\n        s_corrected = 0.0\n        \n        results.append([g_naive, g_corrected, s_naive, s_corrected])\n\n    # Format the final output string exactly as required\n    case_strings = []\n    for res_list in results:\n        # Using str() for default floating point representation\n        case_strings.append(f\"[{','.join(map(str, res_list))}]\")\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "除了并发耦合，多尺度建模还包括另一种重要的范式：跨尺度层级建模。与并发方法不同，层级建模侧重于将更精细尺度的物理信息传递上来，以构建或参数化一个更粗糙尺度的模型。本练习  完美地展示了这一过程，您将通过分析离散位错源的统计行为（微观尺度现象），来构建一个能够成功预测宏观“越小越强”尺寸效应的连续介质塑性本构律。这个实践将让您体验如何依次连接不同尺度，解决真实的材料科学问题。",
            "id": "3468017",
            "problem": "考虑一个直径为 $D$ 的面心立方（FCC）微柱，在轴向载荷下被压缩，其晶体取向固定，使得分解剪应力通过 Schmid 定律与轴向应力相关联。目标是构建一个从离散位错源统计出发，到连续介质硬化定律的跨层次连续介质桥梁，然后用它来预测流变应力对微柱直径 $D$ 的依赖关系，证明在固定塑性剪切应变下，流变应力近似按 $1/\\sqrt{D}$ 的比例缩放。所有应力必须以兆帕（MPa）为单位表示。\n\n从以下基本依据和定义出发，您必须使用它们来建立和求解模型：\n\n1. Frank–Read 源的激活和环的产生：一个特征长度为 $L$ 的源产生一个位错环，并为微观结构贡献位错线长度。在小体积中，源长度被微柱直径 $D$ 几何截断。\n\n2. 位错的储存和回复由关于位错密度 $\\rho$ 与塑性剪切应变 $\\gamma$ 的 Kocks–Mecking 型演化定律描述：\n$$\n\\frac{d \\rho}{d \\gamma} = \\frac{k_s(D)}{b\\, \\ell(D)} - k_a \\rho,\n$$\n其中 $b$ 是 Burgers 矢量的大小，$\\ell(D)$ 是微柱中位错的有效平均自由程，$k_s(D)$ 是由离散源统计信息得出的无量纲储存系数，而 $k_a$ 是单位剪切应变的回复系数。\n\n3. Taylor 关系将流变分解剪应力 $\\tau$ 与位错密度联系起来：\n$$\n\\tau = \\alpha\\, G\\, b\\, \\sqrt{\\rho},\n$$\n其中 $\\alpha$ 是一个无量纲的硬化因子，$G$ 是剪切模量。轴向流变应力 $\\sigma$ 通过 Schmid 定律与分解剪应力相关：\n$$\n\\sigma = \\frac{\\tau}{m},\n$$\n其中 $m$ 是给定晶体取向的 Schmid 因子。\n\n将离散源长度 $L$ 建模为 Weibull 分布，并受微柱几何形状截断。设原始 Weibull 概率密度为\n$$\nf_{\\text{raw}}(L; \\lambda, k) = \\frac{k}{\\lambda} \\left(\\frac{L}{\\lambda}\\right)^{k-1} \\exp\\left( - \\left(\\frac{L}{\\lambda}\\right)^k \\right),\n$$\n其中尺度参数为 $\\lambda$，形状参数为 $k$，并且只考虑区间 $[L_{\\min}, D]$ 内的源长度。定义截断平均源长度为\n$$\n\\mathbb{E}[L \\mid L_{\\min} \\le L \\le D] = \\frac{\\int_{L_{\\min}}^{D} L\\, f_{\\text{raw}}(L; \\lambda, k)\\, dL}{F(D;\\lambda,k) - F(L_{\\min};\\lambda,k)},\n$$\n其中 $F(x;\\lambda,k) = 1 - \\exp\\left( - (x/\\lambda)^k \\right)$ 是原始 Weibull 分布的累积分布函数。\n\n为了将离散源统计与连续介质储存系数联系起来，定义\n$$\nR(D) = \\frac{\\mathbb{E}[L \\mid L_{\\min} \\le L \\le D]}{D},\n$$\n并选择一个固定的参考直径 $D_{\\text{ref}}$ 来归一化储存系数，使得\n$$\nk_s(D) = k_{s0}\\, \\frac{R(D)}{R(D_{\\text{ref}})},\n$$\n其中 $k_{s0}$ 是一个常数。假设有效平均自由程为 $\\ell(D) = c_\\ell D$，其中 $c_\\ell$ 是一个捕捉几何约束和内部障碍的常数。\n\n使用以上信息，您必须：\n- 基于给定的 $d\\rho/d\\gamma$ 定律，从第一性原理推导位错密度 $\\rho(\\gamma, D)$，展示其对 $D$ 的依赖关系是如何引入的，然后通过 Taylor 关系和 Schmid 定律计算轴向流变应力 $\\sigma(\\gamma, D)$。\n- 通过使用一对直径计算经验缩放指数 $n$ 来证明近似缩放关系 $\\sigma \\propto 1/\\sqrt{D}$\n$$\nn = -\\frac{\\ln\\left(\\sigma(D_2)/\\sigma(D_1)\\right)}{\\ln\\left(D_2/D_1\\right)}.\n$$\n\n使用的材料和模型参数（除非另有说明，所有常数在所有测试案例中均相同）：\n- 剪切模量 $G = 48 \\times 10^9$ (帕斯卡),\n- Burgers 矢量大小 $b = 0.256 \\times 10^{-9}$ (米),\n- 硬化因子 $\\alpha = 0.3$ (无量纲),\n- 回复系数 $k_a = 4.0$ (每单位剪切应变),\n- 平均自由程系数 $c_\\ell = 0.5$ (无量纲),\n- 初始位错密度 $\\rho_0 = 1.0 \\times 10^{12}$ (米$^{-2}$),\n- 储存归一化常数 $k_{s0} = 1.0$ (无量纲),\n- 参考直径 $D_{\\text{ref}} = 2.0$ (微米)。\n\n单位和转换：\n- 直径 $D$、$D_1$、$D_2$、Weibull 尺度参数 $\\lambda$ 和最小源长度 $L_{\\min}$ 以微米为单位指定，在计算中必须转换为米。\n- 塑性剪切应变 $\\gamma$ 和 Schmid 因子 $m$ 是无量纲的。\n- 最终的轴向流变应力必须以兆帕（MPa）为单位返回。\n\n测试套件：\n为以下参数集计算输出。对于类型为“stress”的案例，返回轴向流变应力 $\\sigma$（单位为 MPa）。对于类型为“exponent”的案例，返回指数 $n$（浮点数）。每个案例都是独立的。\n- 案例 $1$ (应力，正常路径)：$D = 2.0$ (微米)，$\\gamma = 0.2$，$m = 0.5$，$\\lambda = 1.0$ (微米)，$k = 2.0$，$L_{\\min} = 0.1$ (微米)。\n- 案例 $2$ (应力，小直径边界)：$D = 0.5$ (微米)，$\\gamma = 0.2$，$m = 0.5$，$\\lambda = 1.0$ (微米)，$k = 2.0$，$L_{\\min} = 0.1$ (微米)。\n- 案例 $3$ (应力，大直径边界)：$D = 10.0$ (微米)，$\\gamma = 0.2$，$m = 0.5$，$\\lambda = 1.0$ (微米)，$k = 2.0$，$L_{\\min} = 0.1$ (微米)。\n- 案例 $4$ (应力，取向变化)：$D = 2.0$ (微米)，$\\gamma = 0.2$，$m = 0.3$，$\\lambda = 1.0$ (微米)，$k = 2.0$，$L_{\\min} = 0.1$ (微米)。\n- 案例 $5$ (应力，源统计变化)：$D = 2.0$ (微米)，$\\gamma = 0.2$，$m = 0.5$，$\\lambda = 0.5$ (微米)，$k = 1.0$，$L_{\\min} = 0.1$ (微米)。\n- 案例 $6$ (指数，缩放演示)：$(D_1, D_2) = (1.0, 4.0)$ (微米)，$\\gamma = 0.5$，$m = 0.5$，$\\lambda = 1.0$ (微米)，$k = 2.0$，$L_{\\min} = 0.1$ (微米)。使用上述定义为这两个直径计算 $n$，并保持所有其他参数不变。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,\\dots]$，其中 $r_i$ 是按上述顺序列出的案例 $i$ 的浮点数结果。所有轴向应力均以 MPa 表示。不得打印任何其他文本。",
            "solution": "该问题要求构建一个分层多尺度模型，以预测微柱的流变应力 $\\sigma$ 作为其直径 $D$ 的函数。该模型充当了微观尺度上离散位错源统计与宏观尺度上塑性流动的连续介质描述之间的桥梁。推导和计算求解过程分为四个主要步骤。\n\n**1. 位错密度演化**\n\n连续介质模型的基础是关于总位错密度 $\\rho$ 作为塑性剪切应变 $\\gamma$ 函数的 Kocks-Mecking 演化定律：\n$$ \\frac{d \\rho}{d \\gamma} = \\frac{k_s(D)}{b\\, \\ell(D)} - k_a \\rho $$\n这是一个关于 $\\rho(\\gamma)$ 的一阶线性常微分方程。整理各项，我们得到标准形式：\n$$ \\frac{d \\rho}{d \\gamma} + k_a \\rho = \\frac{k_s(D)}{b\\, \\ell(D)} $$\n右侧的项相对于应变 $\\gamma$ 是一个常数。为简化起见，我们可以将其表示为 $C(D) = k_s(D) / (b\\, \\ell(D))$。该方程使用积分因子 $I(\\gamma) = \\exp(\\int k_a d\\gamma) = \\exp(k_a \\gamma)$ 求解。通解的形式为：\n$$ \\rho(\\gamma) = \\frac{C(D)}{k_a} + K e^{-k_a \\gamma} $$\n其中 $K$ 是积分常数。我们通过应用初始条件 $\\rho(\\gamma=0) = \\rho_0$ 来确定 $K$。这得到 $K = \\rho_0 - C(D)/k_a$。将其代回通解，得到位错密度的特解：\n$$ \\rho(\\gamma, D) = \\frac{k_s(D)}{k_a b\\, \\ell(D)} + \\left(\\rho_0 - \\frac{k_s(D)}{k_a b\\, \\ell(D)}\\right) e^{-k_a \\gamma} $$\n该方程描述了随着塑性应变的累积，位错密度如何从初始状态 $\\rho_0$ 向饱和密度 $\\rho_{\\text{sat}}(D) = k_s(D) / (k_a b\\, \\ell(D))$ 演化。\n\n**2. 从离散源到连续介质储存系数**\n\n模型的尺寸敏感性是通过依赖于微柱直径 $D$ 的参数引入的：储存系数 $k_s(D)$ 和位错平均自由程 $\\ell(D)$。\n平均自由程假设与微柱直径成正比，即 $\\ell(D) = c_\\ell D$，这反映了几何限制。\n储存系数 $k_s(D)$ 源自离散位错 Frank-Read 源的统计数据。这些源的长度 $L$ 通过 Weibull 分布建模，但被微柱边界几何截断到区间 $[L_{\\min}, D]$。连接不同尺度的关键量是截断平均源长度 $\\mathbb{E}[L \\mid L_{\\min} \\le L \\le D]$，定义为：\n$$ \\mathbb{E}[L \\mid L_{\\min} \\le L \\le D] = \\frac{\\int_{L_{\\min}}^{D} L\\, f_{\\text{raw}}(L; \\lambda, k)\\, dL}{\\int_{L_{\\min}}^{D} f_{\\text{raw}}(L; \\lambda, k)\\, dL} $$\n分子中的积分是 Weibull 分布的一阶不完全矩，分母表示截断区间 $[L_{\\min}, D]$ 内的概率质量。通过使用下不完全伽马函数 $\\gamma(s,x) = \\int_0^x t^{s-1} e^{-t} dt$ 可以方便地计算该表达式。平均值的解析表达式为：\n$$ \\mathbb{E}[L_D] = \\lambda \\frac{\\gamma\\left(1+\\frac{1}{k}, \\left(\\frac{D}{\\lambda}\\right)^k\\right) - \\gamma\\left(1+\\frac{1}{k}, \\left(\\frac{L_{\\min}}{\\lambda}\\right)^k\\right)}{\\exp\\left(-\\left(\\frac{L_{\\min}}{\\lambda}\\right)^k\\right) - \\exp\\left(-\\left(\\frac{D}{\\lambda}\\right)^k\\right)} $$\n其中我们使用简写 $\\mathbb{E}[L_D]$ 表示 $\\mathbb{E}[L \\mid L_{\\min} \\le L \\le D]$。\n然后通过定义无量纲比率 $R(D) = \\mathbb{E}[L_D] / D$ 来建立与连续介质储存项的联系。该比率捕捉了平均源长度与微柱直径的偏差。$R(D)$ 用于缩放参考储存系数 $k_{s0}$，该系数在参考直径 $D_{\\text{ref}}$ 处定义：\n$$ k_s(D) = k_{s0}\\, \\frac{R(D)}{R(D_{\\text{ref}})} = k_{s0}\\, \\frac{\\mathbb{E}[L_D]/D}{\\mathbb{E}[L_{D_{\\text{ref}}}]/D_{\\text{ref}}} $$\n这种表述确保了随着微柱尺寸 $D$ 的减小，源长度分布的截断变得更加显著，从而改变了平均源长度，并因此改变了位错储存的速率。\n\n**3. 轴向流变应力的计算**\n\n一旦确定了给定应变和直径下的位错密度 $\\rho(\\gamma, D)$，就可以使用 Taylor 关系计算分解剪应力 $\\tau$，该关系将微观位错结构与宏观流变应力联系起来：\n$$ \\tau(\\gamma, D) = \\alpha\\, G\\, b\\, \\sqrt{\\rho(\\gamma, D)} $$\n最后，驱动压缩所需的轴向流变应力 $\\sigma$ 通过 Schmid 定律获得。该定律使用 Schmid 因子 $m$ 将活动滑移系上的分解剪应力投影到加载轴上：\n$$ \\sigma(\\gamma, D) = \\frac{\\tau(\\gamma, D)}{m} = \\frac{\\alpha\\, G\\, b}{m} \\sqrt{\\rho(\\gamma, D)} $$\n为了进行数值计算，所有参数必须用一致的单位制表示，通常是国际单位制（米、帕斯卡等）。轴向应力的最终结果随后通过除以 $10^6$ 从帕斯卡（Pa）转换为兆帕（MPa）。\n\n**4. 尺寸依赖性缩放分析**\n\n该问题假设应力与直径之间存在一个近似的幂律缩放关系，$\\sigma \\propto D^{-n}$，预期指数为 $n \\approx 0.5$。为了在模型内验证这一预测，通过在两个不同直径 $D_1$ 和 $D_2$ 处的两个应力预测值 $\\sigma_1 = \\sigma(\\gamma, D_1)$ 和 $\\sigma_2 = \\sigma(\\gamma, D_2)$ 计算经验缩放指数 $n$。假设该幂律成立：\n$$ \\sigma_1 = C D_1^{-n} \\quad \\text{and} \\quad \\sigma_2 = C D_2^{-n} $$\n取这两个方程的比值消除了常数 $C$：$\\sigma_2/\\sigma_1 = (D_2/D_1)^{-n}$。对两边取自然对数并求解 $n$，得到所提供的公式：\n$$ n = -\\frac{\\ln\\left(\\sigma_2/\\sigma_1\\right)}{\\ln\\left(D_2/D_1\\right)} $$\n该计算提供了对分层模型在指定微柱直径范围内预测的“越小越强”尺寸效应的定量度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammainc, gamma\n\n# --- Model Parameters and Constants ---\n# All values are in base SI units (meters, Pascals, etc.) unless specified otherwise.\nG = 48.0e9  # Shear modulus (Pa)\nb = 0.256e-9  # Burgers vector magnitude (m)\nalpha = 0.3  # Hardening factor (dimensionless)\nka = 4.0  # Recovery coefficient (per unit shear strain)\ncl = 0.5  # Mean free path coefficient (dimensionless)\nrho0 = 1.0e12  # Initial dislocation density (m^-2)\nks0 = 1.0  # Storage normalization constant (dimensionless)\nD_ref = 2.0e-6  # Reference diameter (m)\n\ndef calculate_truncated_mean_L(D_val, L_min_val, lambda_val, k_val):\n    \"\"\"\n    Calculates the truncated mean source length E[L | L_min = L = D].\n    All length inputs must be in meters.\n    \"\"\"\n    if np.isclose(D_val, L_min_val):\n        return L_min_val\n    \n    if D_val  L_min_val:\n        # Physical case of an empty set of possible source lengths.\n        return np.nan\n\n    u_min = (L_min_val / lambda_val)**k_val\n    u_max = (D_val / lambda_val)**k_val\n    s = 1.0 + 1.0 / k_val\n\n    # Numerator is related to the incomplete gamma function.\n    # scipy.special.gammainc is the regularized lower incomplete gamma function P(s, x)\n    # where P(s, x) = gamma(s, x) / Gamma(s).\n    # So, gamma(s, x) = gammainc(s, x) * Gamma(s).\n    gamma_s = gamma(s)\n    gamma_lower_max = gammainc(s, u_max) * gamma_s\n    gamma_lower_min = gammainc(s, u_min) * gamma_s\n    numerator = lambda_val * (gamma_lower_max - gamma_lower_min)\n\n    # Denominator is the probability mass in the truncated interval.\n    denominator = np.exp(-u_min) - np.exp(-u_max)\n    \n    if np.isclose(denominator, 0.0):\n        # This case can occur if u_min and u_max are very large, making both\n        # exponentials numerically zero. This implies L_min >> lambda.\n        # This is not expected for the given test cases but is a possible edge case.\n        # Alternatively, if D is very close to L_min, but np.isclose failed.\n        return np.nan\n\n    return numerator / denominator\n\ndef calculate_stress_mpa(D_um, gamma_strain, m, lambda_um, k, L_min_um):\n    \"\"\"\n    Calculates the axial flow stress in MPa for a given set of parameters.\n    \"\"\"\n    # Convert inputs from micrometers to meters\n    D = D_um * 1e-6\n    lambda_val = lambda_um * 1e-6\n    L_min = L_min_um * 1e-6\n\n    # 1. Calculate truncated mean lengths for the given D and the reference D_ref\n    #    The source statistics (lambda, k, L_min) are the same for both calculations.\n    E_L_D = calculate_truncated_mean_L(D, L_min, lambda_val, k)\n    E_L_D_ref = calculate_truncated_mean_L(D_ref, L_min, lambda_val, k)\n    \n    # 2. Calculate the normalized ratios R(D) and R(D_ref)\n    R_D = E_L_D / D\n    R_D_ref = E_L_D_ref / D_ref\n    \n    # 3. Calculate the diameter-dependent storage coefficient ks(D)\n    ks_D = ks0 * (R_D / R_D_ref)\n    \n    # 4. Solve for dislocation density rho\n    ell_D = cl * D\n    rho_sat = ks_D / (ka * b * ell_D)\n    rho = rho_sat + (rho0 - rho_sat) * np.exp(-ka * gamma_strain)\n    \n    # 5. Calculate stresses\n    # Taylor relation for resolved shear stress\n    tau = alpha * G * b * np.sqrt(rho)\n    # Schmid law for axial stress in Pa\n    sigma_pa = tau / m\n    \n    # 6. Convert final axial stress to MPa\n    sigma_mpa = sigma_pa / 1e6\n    \n    return sigma_mpa\n\ndef calculate_exponent(D1_um, D2_um, gamma_strain, m, lambda_um, k, L_min_um):\n    \"\"\"\n    Calculates the empirical scaling exponent n.\n    \"\"\"\n    # Calculate stresses at diameters D1 and D2.\n    # The units of stress (Pa or MPa) do not matter for the ratio.\n    sigma1 = calculate_stress_mpa(D1_um, gamma_strain, m, lambda_um, k, L_min_um)\n    sigma2 = calculate_stress_mpa(D2_um, gamma_strain, m, lambda_um, k, L_min_um)\n    \n    # The units of diameter (um or m) do not matter for the ratio.\n    n = -np.log(sigma2 / sigma1) / np.log(D2_um / D1_um)\n    \n    return n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (stress): D=2.0, γ=0.2, m=0.5, λ=1.0, k=2.0, Lmin=0.1\n        {'type': 'stress', 'params': {'D_um': 2.0, 'gamma_strain': 0.2, 'm': 0.5, 'lambda_um': 1.0, 'k': 2.0, 'L_min_um': 0.1}},\n        # Case 2 (stress): D=0.5, γ=0.2, m=0.5, λ=1.0, k=2.0, Lmin=0.1\n        {'type': 'stress', 'params': {'D_um': 0.5, 'gamma_strain': 0.2, 'm': 0.5, 'lambda_um': 1.0, 'k': 2.0, 'L_min_um': 0.1}},\n        # Case 3 (stress): D=10.0, γ=0.2, m=0.5, λ=1.0, k=2.0, Lmin=0.1\n        {'type': 'stress', 'params': {'D_um': 10.0, 'gamma_strain': 0.2, 'm': 0.5, 'lambda_um': 1.0, 'k': 2.0, 'L_min_um': 0.1}},\n        # Case 4 (stress): D=2.0, γ=0.2, m=0.3, λ=1.0, k=2.0, Lmin=0.1\n        {'type': 'stress', 'params': {'D_um': 2.0, 'gamma_strain': 0.2, 'm': 0.3, 'lambda_um': 1.0, 'k': 2.0, 'L_min_um': 0.1}},\n        # Case 5 (stress): D=2.0, γ=0.2, m=0.5, λ=0.5, k=1.0, Lmin=0.1\n        {'type': 'stress', 'params': {'D_um': 2.0, 'gamma_strain': 0.2, 'm': 0.5, 'lambda_um': 0.5, 'k': 1.0, 'L_min_um': 0.1}},\n        # Case 6 (exponent): (D1,D2)=(1.0,4.0), γ=0.5, m=0.5, λ=1.0, k=2.0, Lmin=0.1\n        {'type': 'exponent', 'params': {'D1_um': 1.0, 'D2_um': 4.0, 'gamma_strain': 0.5, 'm': 0.5, 'lambda_um': 1.0, 'k': 2.0, 'L_min_um': 0.1}},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'stress':\n            result = calculate_stress_mpa(**case['params'])\n        elif case['type'] == 'exponent':\n            result = calculate_exponent(**case['params'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}