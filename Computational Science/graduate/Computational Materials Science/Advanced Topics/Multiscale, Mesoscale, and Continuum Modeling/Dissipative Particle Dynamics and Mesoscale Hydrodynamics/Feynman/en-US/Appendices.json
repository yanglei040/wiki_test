{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of any valid physical model is its adherence to fundamental conservation laws, which arise from the symmetries of nature. For an isolated system, the isotropy of space dictates that total angular momentum must be conserved. This exercise  provides a direct and practical method for verifying this property in your own particle-based code. By contrasting a rotationally invariant central-force model with a deliberately flawed non-central one, you will quantify the spurious torques and violation of angular momentum conservation that arise from an incorrect implementation, reinforcing the critical link between central forces and rotational invariance.",
            "id": "3446073",
            "problem": "You are asked to validate rotational invariance in a pairwise mesoscale particle model by measuring angular momentum conservation and quantifying spurious torques. Work in reduced dissipative particle dynamics units where all quantities are dimensionless. Consider a system of $N$ point particles in three dimensions with positions $\\mathbf{r}_i \\in \\mathbb{R}^3$, velocities $\\mathbf{v}_i \\in \\mathbb{R}^3$, and equal masses $m$. The time variable is $t$. The goal is to compute the net internal torque $\\boldsymbol{\\tau}(t)$ about the origin and the change in total angular momentum $\\Delta \\mathbf{L} = \\mathbf{L}(t+\\Delta t) - \\mathbf{L}(t)$ across a single explicit Euler time step for two different pairwise interaction models: a rotationally invariant central model and a deliberately non-central model that violates rotational invariance.\n\nStart from the following fundamental base:\n- Newton’s second law for particle $i$: $$m \\frac{d \\mathbf{v}_i}{d t} = \\sum_{j \\neq i} \\mathbf{F}_{ij},$$ where $\\mathbf{F}_{ij}$ is the force on particle $i$ due to particle $j$.\n- Newton’s third law: $$\\mathbf{F}_{ij} = - \\mathbf{F}_{ji}.$$\n- Definition of total angular momentum about the origin: $$\\mathbf{L}(t) = \\sum_{i=1}^{N} m \\, \\mathbf{r}_i(t) \\times \\mathbf{v}_i(t).$$\n- Definition of net internal torque about the origin: $$\\boldsymbol{\\tau}(t) = \\sum_{i=1}^{N} \\mathbf{r}_i(t) \\times \\left( \\sum_{j \\neq i} \\mathbf{F}_{ij}(t) \\right).$$\n\nImplement the following deterministic pairwise force models with a cut-off radius $r_c$, without any stochastic forces:\n\n1. Rotationally invariant central model. For a pair separation vector $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$, separation $r_{ij} = \\|\\mathbf{r}_{ij}\\|$, and unit vector $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / r_{ij}$, define the conservative weight $w_C(r_{ij}) = 1 - r_{ij}/r_c$ for $r_{ij} < r_c$ and $w_C(r_{ij}) = 0$ otherwise. Define $w_D(r_{ij}) = \\left[w_C(r_{ij})\\right]^2$. The conservative and dissipative forces are:\n$$\\mathbf{F}_{ij}^{C} = a \\, w_C(r_{ij}) \\, \\hat{\\mathbf{r}}_{ij}, \\quad \\mathbf{F}_{ij}^{D} = - \\gamma \\, w_D(r_{ij}) \\left( \\left( \\mathbf{v}_i - \\mathbf{v}_j \\right) \\cdot \\hat{\\mathbf{r}}_{ij} \\right) \\hat{\\mathbf{r}}_{ij},$$\nand the total pairwise force is $\\mathbf{F}_{ij} = \\mathbf{F}_{ij}^{C} + \\mathbf{F}_{ij}^{D}$ if $r_{ij} < r_c$, and $\\mathbf{F}_{ij} = \\mathbf{0}$ otherwise.\n\n2. Non-central (bug) model. Use the same $\\mathbf{F}_{ij}^{C}$ as above, but replace the dissipative force by a non-central form\n$$\\mathbf{F}_{ij}^{D,\\mathrm{bug}} = - \\gamma \\, w_D(r_{ij}) \\left( \\mathbf{v}_i - \\mathbf{v}_j \\right),$$\nso that the total pairwise force is $\\mathbf{F}_{ij} = \\mathbf{F}_{ij}^{C} + \\mathbf{F}_{ij}^{D,\\mathrm{bug}}$ if $r_{ij} < r_c$, and $\\mathbf{F}_{ij} = \\mathbf{0}$ otherwise. This model preserves linear momentum (by symmetry) but violates rotational invariance because the dissipative term is not central.\n\nNumerical procedure to be implemented for each test case:\n- Use $m = 1$ for all particles.\n- Compute all pairwise forces at time $t$ from the specified model.\n- Compute the net internal torque $\\boldsymbol{\\tau}(t)$ and its Euclidean norm $\\|\\boldsymbol{\\tau}(t)\\|$.\n- Compute the total angular momentum $\\mathbf{L}(t)$.\n- Advance one explicit Euler step of size $\\Delta t$: for each particle,\n$$\\mathbf{v}_i(t+\\Delta t) = \\mathbf{v}_i(t) + \\Delta t \\, \\frac{\\sum_{j \\neq i} \\mathbf{F}_{ij}(t)}{m}, \\quad \\mathbf{r}_i(t+\\Delta t) = \\mathbf{r}_i(t) + \\Delta t \\, \\mathbf{v}_i(t).$$\n- Compute $\\mathbf{L}(t+\\Delta t)$ and its change $\\Delta \\mathbf{L} = \\mathbf{L}(t+\\Delta t) - \\mathbf{L}(t)$, along with the Euclidean norm $\\|\\Delta \\mathbf{L}\\|$.\n- Report $\\|\\boldsymbol{\\tau}(t)\\|$ and $\\|\\Delta \\mathbf{L}\\|$ as dimensionless floats.\n\nTest suite. Use the following four test cases, all in reduced dissipative particle dynamics units (dimensionless):\n\n- Case $1$ (central model, pair): $N = 2$, $a = 25.0$, $\\gamma = 4.5$, $r_c = 1.0$, $\\Delta t = 0.01$, $\\mathbf{r}_1 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_2 = (0.5, 0.0, 0.0)$, $\\mathbf{v}_1 = (0.0, 1.0, 0.0)$, $\\mathbf{v}_2 = (0.0, -1.0, 0.0)$; use the rotationally invariant central model.\n- Case $2$ (central model, asymmetric triplet): $N = 3$, $a = 25.0$, $\\gamma = 4.5$, $r_c = 1.0$, $\\Delta t = 0.01$, $\\mathbf{r}_1 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_2 = (0.6, 0.2, 0.0)$, $\\mathbf{r}_3 = (0.2, 0.7, 0.0)$, $\\mathbf{v}_1 = (0.1, -0.2, 0.0)$, $\\mathbf{v}_2 = (-0.05, 0.03, 0.0)$, $\\mathbf{v}_3 = (0.02, -0.01, 0.0)$; use the rotationally invariant central model.\n- Case $3$ (non-central bug, same triplet): identical to Case $2$ but using the non-central model for the dissipative term.\n- Case $4$ (no interactions at cut-off): $N = 3$, $a = 25.0$, $\\gamma = 4.5$, $r_c = 1.0$, $\\Delta t = 0.01$, $\\mathbf{r}_1 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_2 = (2.0, 0.0, 0.0)$, $\\mathbf{r}_3 = (0.0, 2.0, 0.0)$, $\\mathbf{v}_1 = (0.3, -0.1, 0.0)$, $\\mathbf{v}_2 = (-0.2, 0.2, 0.0)$, $\\mathbf{v}_3 = (0.0, -0.15, 0.0)$; use the rotationally invariant central model.\n\nYour program must compute, for each case, the two floats $\\|\\boldsymbol{\\tau}(t)\\|$ and $\\|\\Delta \\mathbf{L}\\|$, each rounded to eight decimal places. The final output format is a single line containing a comma-separated list of all these values flattened in the order of the cases, i.e., \n$$[\\|\\boldsymbol{\\tau}\\|_1, \\|\\Delta \\mathbf{L}\\|_1, \\|\\boldsymbol{\\tau}\\|_2, \\|\\Delta \\mathbf{L}\\|_2, \\|\\boldsymbol{\\tau}\\|_3, \\|\\Delta \\mathbf{L}\\|_3, \\|\\boldsymbol{\\tau}\\|_4, \\|\\Delta \\mathbf{L}\\|_4].$$\nNo other text should be printed. All outputs are dimensionless in reduced dissipative particle dynamics units.",
            "solution": "The problem is valid as it is scientifically grounded in classical mechanics, well-posed with all necessary data provided, and objective in its formulation. It presents a standard computational physics exercise to verify the consequences of rotational invariance in a particle-based model.\n\nThe core principle governing the dynamics of angular momentum is the rotational analogue of Newton's second law, which states that the time rate of change of the total angular momentum $\\mathbf{L}$ of a system of particles is equal to the net external torque acting on it. For an isolated system subject only to internal forces, this becomes:\n$$\n\\frac{d\\mathbf{L}}{dt} = \\boldsymbol{\\tau}_{\\text{int}}\n$$\nwhere $\\boldsymbol{\\tau}_{\\text{int}}$ is the net internal torque. The total angular momentum is defined as the sum of individual particle angular momenta about the origin:\n$$\n\\mathbf{L}(t) = \\sum_{i=1}^{N} \\mathbf{L}_i(t) = \\sum_{i=1}^{N} m_i \\left( \\mathbf{r}_i(t) \\times \\mathbf{v}_i(t) \\right)\n$$\nThe net internal torque is the sum of torques produced by all internal forces $\\mathbf{F}_{ij}$ (force on particle $i$ from particle $j$):\n$$\n\\boldsymbol{\\tau}_{\\text{int}}(t) = \\sum_{i=1}^{N} \\mathbf{r}_i(t) \\times \\mathbf{F}_i(t) = \\sum_{i=1}^{N} \\mathbf{r}_i(t) \\times \\left( \\sum_{j \\neq i} \\mathbf{F}_{ij}(t) \\right)\n$$\nAssuming Newton's third law holds ($\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$), the net internal torque can be expressed as a sum over pairs of particles:\n$$\n\\boldsymbol{\\tau}_{\\text{int}} = \\sum_{i<j} \\left( \\mathbf{r}_i \\times \\mathbf{F}_{ij} + \\mathbf{r}_j \\times \\mathbf{F}_{ji} \\right) = \\sum_{i<j} \\left( \\mathbf{r}_i - \\mathbf{r}_j \\right) \\times \\mathbf{F}_{ij} = \\sum_{i<j} \\mathbf{r}_{ij} \\times \\mathbf{F}_{ij}\n$$\nwhere $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$ is the separation vector. This expression shows that the net internal torque is zero if and only if for every pair of interacting particles, the force vector $\\mathbf{F}_{ij}$ is parallel to the separation vector $\\mathbf{r}_{ij}$. Such forces are called **central forces**. A system with only central internal forces will have $\\boldsymbol{\\tau}_{\\text{int}} = \\mathbf{0}$, which implies that its total angular momentum is conserved ($d\\mathbf{L}/dt = \\mathbf{0}$).\n\nThe problem asks us to investigate two models:\n$1$. The **rotationally invariant central model** uses forces $\\mathbf{F}_{ij}^{C} = a \\, w_C(r_{ij}) \\, \\hat{\\mathbf{r}}_{ij}$ and $\\mathbf{F}_{ij}^{D} = - \\gamma \\, w_D(r_{ij}) ((\\mathbf{v}_i - \\mathbf{v}_j) \\cdot \\hat{\\mathbf{r}}_{ij}) \\hat{\\mathbf{r}}_{ij}$. Both components, and thus their sum $\\mathbf{F}_{ij}$, are directed along the unit separation vector $\\hat{\\mathbf{r}}_{ij}$. This is a central force. Therefore, for this model, we can predict that the analytical net internal torque $\\boldsymbol{\\tau}(t)$ will be exactly zero.\n\n$2$. The **non-central (bug) model** uses a modified dissipative force $\\mathbf{F}_{ij}^{D,\\mathrm{bug}} = - \\gamma \\, w_D(r_{ij}) (\\mathbf{v}_i - \\mathbf{v}_j)$. In general, the relative velocity vector $(\\mathbf{v}_i - \\mathbf{v}_j)$ is not parallel to the separation vector $\\mathbf{r}_{ij}$. Consequently, the pairwise force $\\mathbf{F}_{ij}$ is not central, leading to a non-zero torque contribution $\\mathbf{r}_{ij} \\times \\mathbf{F}_{ij} \\neq \\mathbf{0}$. This results in a non-zero net internal torque $\\boldsymbol{\\tau}(t) \\neq \\mathbf{0}$ and a violation of angular momentum conservation.\n\nThe numerical procedure uses a single **explicit Euler integration step**. The equations of motion are discretized as:\n$$\n\\mathbf{v}_i(t+\\Delta t) = \\mathbf{v}_i(t) + \\frac{\\Delta t}{m} \\mathbf{F}_i(t)\n$$\n$$\n\\mathbf{r}_i(t+\\Delta t) = \\mathbf{r}_i(t) + \\Delta t \\, \\mathbf{v}_i(t)\n$$\nThe change in angular momentum over this step is $\\Delta \\mathbf{L} = \\mathbf{L}(t+\\Delta t) - \\mathbf{L}(t)$. From the continuous time evolution, one might approximate $\\Delta \\mathbf{L} \\approx \\boldsymbol{\\tau}(t)\\Delta t$. This relationship is not exact for a finite time step due to numerical integration error.\nFor the central model, we expect $\\|\\boldsymbol{\\tau}(t)\\|$ to be zero (or within machine precision), while $\\|\\Delta \\mathbf{L}\\|$ will be a small, non-zero value representing the integration error of the explicit Euler method, which is not a symplectic integrator and does not perfectly conserve such quantities. For the non-central model, we expect a non-zero $\\|\\boldsymbol{\\tau}(t)\\|$, and $\\|\\Delta \\mathbf{L}\\|$ should be of the order $\\|\\boldsymbol{\\tau}(t)\\| \\Delta t$.\n\nThe computational algorithm for each test case is as follows:\n$1$. Given initial positions $\\mathbf{r}_i$, velocities $\\mathbf{v}_i$, and parameters $m$, $a$, $\\gamma$, $r_c$, and $\\Delta t$.\n$2$. Compute the total force $\\mathbf{F}_i = \\sum_{j \\neq i} \\mathbf{F}_{ij}$ on each particle $i$ by summing over all pairs $(j \\neq i)$, applying the given force law (central or non-central) only if the pair separation $r_{ij} < r_c$.\n$3$. Compute the net internal torque at time $t$ as $\\boldsymbol{\\tau}(t) = \\sum_i \\mathbf{r}_i(t) \\times \\mathbf{F}_i(t)$ and calculate its Euclidean norm $\\|\\boldsymbol{\\tau}(t)\\|$.\n$4$. Compute the total angular momentum at time $t$: $\\mathbf{L}(t) = \\sum_i m (\\mathbf{r}_i(t) \\times \\mathbf{v}_i(t))$.\n$5$. Update the particle positions and velocities to time $t+\\Delta t$ using the explicit Euler formulas specified. Note that the position update uses the velocity at time $t$.\n$6$. Compute the new total angular momentum at time $t+\\Delta t$: $\\mathbf{L}(t+\\Delta t) = \\sum_i m (\\mathbf{r}_i(t+\\Delta t) \\times \\mathbf{v}_i(t+\\Delta t))$.\n$7$. Calculate the change $\\Delta \\mathbf{L} = \\mathbf{L}(t+\\Delta t) - \\mathbf{L}(t)$ and its Euclidean norm $\\|\\Delta \\mathbf{L}\\|$.\n$8$. Report the computed values $\\|\\boldsymbol{\\tau}(t)\\|$ and $\\|\\Delta \\mathbf{L}\\|$, rounded as specified.\n\nCase $4$ provides a sanity check: all particles are initially separated by distances greater than the cutoff radius $r_c=1.0$. Thus, all pairwise forces are zero, so $\\mathbf{F}_i(t) = \\mathbf{0}$ for all $i$. This implies $\\boldsymbol{\\tau}(t) = \\mathbf{0}$. With zero forces, velocities remain constant, and the position update becomes $\\mathbf{r}_i(t+\\Delta t) = \\mathbf{r}_i(t) + \\Delta t \\mathbf{v}_i(t)$. The change in angular momentum is then $\\Delta\\mathbf{L} = \\sum_i m(\\mathbf{r}_i(t+\\Delta t) \\times \\mathbf{v}_i(t) - \\mathbf{r}_i(t) \\times \\mathbf{v}_i(t)) = \\sum_i m(\\Delta t \\mathbf{v}_i(t) \\times \\mathbf{v}_i(t)) = \\mathbf{0}$. Therefore, for Case $4$, both $\\|\\boldsymbol{\\tau}(t)\\|$ and $\\|\\Delta \\mathbf{L}\\|$ must be exactly $0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates rotational invariance in a pairwise mesoscale particle model.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Central model, pair\n        {\n            \"N\": 2, \"a\": 25.0, \"gamma\": 4.5, \"rc\": 1.0, \"dt\": 0.01, \"m\": 1.0,\n            \"r\": np.array([[0.0, 0.0, 0.0], [0.5, 0.0, 0.0]]),\n            \"v\": np.array([[0.0, 1.0, 0.0], [0.0, -1.0, 0.0]]),\n            \"model_type\": 'central'\n        },\n        # Case 2: Central model, asymmetric triplet\n        {\n            \"N\": 3, \"a\": 25.0, \"gamma\": 4.5, \"rc\": 1.0, \"dt\": 0.01, \"m\": 1.0,\n            \"r\": np.array([[0.0, 0.0, 0.0], [0.6, 0.2, 0.0], [0.2, 0.7, 0.0]]),\n            \"v\": np.array([[0.1, -0.2, 0.0], [-0.05, 0.03, 0.0], [0.02, -0.01, 0.0]]),\n            \"model_type\": 'central'\n        },\n        # Case 3: Non-central model, same triplet\n        {\n            \"N\": 3, \"a\": 25.0, \"gamma\": 4.5, \"rc\": 1.0, \"dt\": 0.01, \"m\": 1.0,\n            \"r\": np.array([[0.0, 0.0, 0.0], [0.6, 0.2, 0.0], [0.2, 0.7, 0.0]]),\n            \"v\": np.array([[0.1, -0.2, 0.0], [-0.05, 0.03, 0.0], [0.02, -0.01, 0.0]]),\n            \"model_type\": 'non-central'\n        },\n        # Case 4: No interactions at cut-off\n        {\n            \"N\": 3, \"a\": 25.0, \"gamma\": 4.5, \"rc\": 1.0, \"dt\": 0.01, \"m\": 1.0,\n            \"r\": np.array([[0.0, 0.0, 0.0], [2.0, 0.0, 0.0], [0.0, 2.0, 0.0]]),\n            \"v\": np.array([[0.3, -0.1, 0.0], [-0.2, 0.2, 0.0], [0.0, -0.15, 0.0]]),\n            \"model_type\": 'central'\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        norm_torque, norm_delta_L = run_simulation_step(\n            case[\"N\"], case[\"r\"], case[\"v\"], case[\"m\"],\n            case[\"a\"], case[\"gamma\"], case[\"rc\"], case[\"dt\"],\n            case[\"model_type\"]\n        )\n        results.append(round(norm_torque, 8))\n        results.append(round(norm_delta_L, 8))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation_step(N, r, v, m, a, gamma, rc, dt, model_type):\n    \"\"\"\n    Computes net torque and change in angular momentum for one time step.\n    \n    Args:\n        N (int): Number of particles.\n        r (np.ndarray): (N, 3) array of particle positions.\n        v (np.ndarray): (N, 3) array of particle velocities.\n        m (float): Particle mass.\n        a (float): Conservative force parameter.\n        gamma (float): Dissipative force parameter.\n        rc (float): Cutoff radius.\n        dt (float): Time step size.\n        model_type (str): 'central' or 'non-central'.\n\n    Returns:\n        tuple: (norm_torque, norm_delta_L) as floats.\n    \"\"\"\n    # 1. Compute total angular momentum at time t\n    L_t = np.sum(np.cross(r, v) * m, axis=0)\n\n    # 2. Compute pairwise forces and total force on each particle\n    forces = np.zeros_like(r)\n    for i in range(N):\n        for j in range(i + 1, N):\n            r_ij = r[i] - r[j]\n            r_ij_norm = np.linalg.norm(r_ij)\n\n            # Interact only if within cutoff radius\n            if 0 < r_ij_norm < rc:\n                r_ij_hat = r_ij / r_ij_norm\n                v_ij = v[i] - v[j]\n\n                w_C = 1.0 - r_ij_norm / rc\n                w_D = w_C**2\n\n                F_ij_C = a * w_C * r_ij_hat\n\n                if model_type == 'central':\n                    F_ij_D = -gamma * w_D * np.dot(v_ij, r_ij_hat) * r_ij_hat\n                elif model_type == 'non-central':\n                    F_ij_D = -gamma * w_D * v_ij\n                else:\n                    raise ValueError(\"Unknown model type\")\n\n                F_ij = F_ij_C + F_ij_D\n                \n                forces[i] += F_ij\n                forces[j] -= F_ij\n\n    # 3. Compute net internal torque at time t\n    torque_t = np.sum(np.cross(r, forces), axis=0)\n    norm_torque_t = np.linalg.norm(torque_t)\n\n    # 4. Advance one Explicit Euler step\n    # Position update uses velocity at time t\n    r_new = r + dt * v\n    v_new = v + dt * forces / m\n\n    # 5. Compute total angular momentum at time t+dt\n    L_t_dt = np.sum(np.cross(r_new, v_new) * m, axis=0)\n\n    # 6. Compute change in angular momentum\n    delta_L = L_t_dt - L_t\n    norm_delta_L = np.linalg.norm(delta_L)\n    \n    return norm_torque_t, norm_delta_L\n\nsolve()\n```"
        },
        {
            "introduction": "Dissipative Particle Dynamics models are powerful but require careful parameterization to represent a specific fluid's behavior. A crucial aspect is setting the fluid's compressibility, which governs its equation of state and the speed of sound. This practice  bridges the gap between the microscopic force parameter $a_{ij}$ and macroscopic thermodynamic properties. You will learn to tune $a_{ij}$ to achieve a target speed of sound, a vital skill for minimizing compressibility artifacts and ensuring your simulation operates in the desired low-Mach-number hydrodynamic regime.",
            "id": "3446051",
            "problem": "Consider a single-component Dissipative Particle Dynamics (DPD) fluid in three dimensions with standard conservative interactions. The conservative pairwise force between particles of type $i$ and $j$ is $F_{ij}^{\\mathrm{C}}(r) = a_{ij} w(r)$ acting for $r \\le r_c$, where $a_{ij}$ is the conservative force amplitude and $w(r)$ is a positive weight function. Assume the canonical DPD choice $w(r) = 1 - r/r_c$ for $r \\le r_c$ and $w(r) = 0$ for $r > r_c$. Thermalization is ensured by the dissipative and random forces so that the fluid is isothermal at temperature $T$. Throughout, use DPD reduced units: cutoff length $r_c = 1$ as the length unit, Boltzmann constant $k_{\\mathrm{B}} T = 1$ as the energy scale, particle mass $m = 1$, and time unit $\\tau = r_c \\sqrt{m/(k_{\\mathrm{B}} T)}$. The number density $\\rho$ is expressed in $r_c^{-3}$, pressure in $(k_{\\mathrm{B}} T)/r_c^3$, compressibility in $r_c^3/(k_{\\mathrm{B}} T)$, and speed in $r_c/\\tau$.\n\nFundamental base:\n- Newton’s Second Law and the virial theorem imply that the pressure is the sum of kinetic and interaction virials under homogeneous conditions. With $g(r) \\approx 1$ (mean-field approximation), the virial contribution of the conservative force is\n$$\nP_{\\mathrm{int}} = \\frac{2\\pi}{3} \\rho^2 \\int_{0}^{r_c} r^3 F^{\\mathrm{C}}(r)\\,\\mathrm{d}r .\n$$\n- The total pressure at temperature $T$ is\n$$\nP(\\rho) = \\rho k_{\\mathrm{B}} T + P_{\\mathrm{int}} .\n$$\n- Isothermal compressibility is defined as\n$$\n\\kappa_T = \\frac{1}{\\rho} \\left( \\frac{\\partial \\rho}{\\partial P} \\right)_T = \\frac{1}{\\rho \\left( \\frac{\\partial P}{\\partial \\rho} \\right)_T } .\n$$\n- The long-wavelength static structure factor satisfies the compressibility equation\n$$\nS(0) = \\rho k_{\\mathrm{B}} T \\kappa_T .\n$$\n- Number fluctuations in a grand-canonical control volume with volume $V$ obey\n$$\n\\mathrm{Var}(N) = S(0) \\langle N \\rangle ,\n$$\nso density fluctuations are\n$$\n\\left\\langle (\\delta \\rho)^2 \\right\\rangle = \\frac{\\mathrm{Var}(N)}{V^2} = \\frac{\\rho^2 k_{\\mathrm{B}} T\\,\\kappa_T}{V} .\n$$\n- For an isothermal barotropic fluid, the isothermal speed of sound is\n$$\nc_s^2 = \\left( \\frac{\\partial P}{\\partial \\rho} \\right)_T = \\frac{1}{\\rho \\kappa_T} .\n$$\n- Mach number is $Ma = U/c_s$, with $U$ a characteristic flow speed.\n\nTask 1 (derivation to algorithm):\n1. Using $F^{\\mathrm{C}}(r) = a\\, w(r)$ with $w(r) = 1 - r/r_c$, derive the mean-field conservative virial:\n$$\nP_{\\mathrm{int}} = \\frac{2\\pi}{3}\\rho^2 \\int_{0}^{r_c} r^3 a\\left(1 - \\frac{r}{r_c}\\right)\\,\\mathrm{d}r = a \\rho^2 \\frac{\\pi r_c^4}{30}.\n$$\nThus,\n$$\nP(\\rho) = \\rho k_{\\mathrm{B}} T + a \\rho^2 \\frac{\\pi r_c^4}{30}.\n$$\n2. Show that\n$$\n\\left( \\frac{\\partial P}{\\partial \\rho} \\right)_T = k_{\\mathrm{B}} T + a \\rho \\frac{\\pi r_c^4}{15},\n$$\nand therefore\n$$\nc_s^2 = k_{\\mathrm{B}} T + a \\rho \\frac{\\pi r_c^4}{15}, \\qquad \\kappa_T = \\frac{1}{\\rho\\left( k_{\\mathrm{B}} T + a \\rho \\frac{\\pi r_c^4}{15} \\right)}.\n$$\n3. Combine the compressibility equation with the fluctuation formula to express the density fluctuation:\n$$\n\\left\\langle (\\delta \\rho)^2 \\right\\rangle = \\frac{\\rho^2 k_{\\mathrm{B}} T}{V} \\cdot \\frac{1}{\\rho\\left( k_{\\mathrm{B}} T + a \\rho \\frac{\\pi r_c^4}{15} \\right)} = \\frac{\\rho\\, k_{\\mathrm{B}} T}{V\\left( k_{\\mathrm{B}} T + a \\rho \\frac{\\pi r_c^4}{15} \\right)}.\n$$\n4. Given a target isothermal speed of sound $c_s^{\\mathrm{target}}$ and a maximum allowable Mach number $Ma_{\\max}$ at flow speed $U$, define the required speed of sound as\n$$\nc_s^{\\mathrm{req}} = \\max\\left( c_s^{\\mathrm{target}}, \\frac{U}{Ma_{\\max}} \\right).\n$$\nSolve for the conservative amplitude $a$ that yields $c_s^{\\mathrm{req}}$, respecting $a \\ge 0$:\n$$\na_{\\mathrm{req}} = \\max\\left( 0,\\ \\frac{15}{\\pi r_c^4 \\rho} \\left( \\left( c_s^{\\mathrm{req}} \\right)^2 - k_{\\mathrm{B}} T \\right) \\right).\n$$\n\nTask 2 (program specification):\n- Implement a program that, for each test case, computes:\n    1. The initial isothermal density fluctuation $\\left\\langle (\\delta \\rho)^2 \\right\\rangle$ using the formula above with the given initial $a$.\n    2. The compressibility inferred from fluctuations\n    $$\n    \\kappa_T^{\\mathrm{infer}} = \\frac{ \\left\\langle (\\delta \\rho)^2 \\right\\rangle\\, V }{ \\rho^2 k_{\\mathrm{B}} T } .\n    $$\n    3. The theoretical compressibility\n    $$\n    \\kappa_T^{\\mathrm{theory}} = \\frac{1}{\\rho\\left( k_{\\mathrm{B}} T + a \\rho \\frac{\\pi r_c^4}{15} \\right)} .\n    $$\n    4. The absolute error $|\\kappa_T^{\\mathrm{infer}} - \\kappa_T^{\\mathrm{theory}}|$.\n    5. The required conservative amplitude $a_{\\mathrm{req}}$ to meet $c_s^{\\mathrm{req}}$.\n    6. The tuned speed of sound $c_s^{\\mathrm{tuned}} = \\sqrt{ k_{\\mathrm{B}} T + a_{\\mathrm{req}} \\rho \\frac{\\pi r_c^4}{15} }$.\n    7. The resulting Mach number $Ma^{\\mathrm{actual}} = U / c_s^{\\mathrm{tuned}}$.\n    8. The tuned density fluctuation $\\left\\langle (\\delta \\rho)^2 \\right\\rangle_{\\mathrm{tuned}}$ computed with $a_{\\mathrm{req}}$.\n- Units: report $c_s$ and $U$ in $r_c/\\tau$, $\\kappa_T$ in $r_c^3/(k_{\\mathrm{B}} T)$, $\\left\\langle (\\delta \\rho)^2 \\right\\rangle$ as a dimensionless variance per $r_c^{-6}$, and $Ma$ dimensionless.\n- Final output format: Your program should produce a single line of output containing a list of per-case results, where each case is a list of eight floats in the order specified above. The output must be a single Python list of lists, printed as a single line, for example, \"[[case1_values...],[case2_values...],...]\".\n\nTest suite:\n- Case A (general, moderate compressibility): $\\rho = 5.0$, $V = 50.0$, $a = 25.0$, $U = 0.5$, $Ma_{\\max} = 0.1$, $c_s^{\\mathrm{target}} = 5.0$, $r_c = 1.0$, $k_{\\mathrm{B}} T = 1.0$.\n- Case B (small volume, stronger fluctuations): $\\rho = 5.0$, $V = 5.0$, $a = 25.0$, $U = 0.2$, $Ma_{\\max} = 0.05$, $c_s^{\\mathrm{target}} = 10.0$, $r_c = 1.0$, $k_{\\mathrm{B}} T = 1.0$.\n- Case C (boundary where $c_s^{\\mathrm{target}}$ is below thermal baseline): $\\rho = 3.0$, $V = 30.0$, $a = 10.0$, $U = 0.2$, $Ma_{\\max} = 0.2$, $c_s^{\\mathrm{target}} = 0.8$, $r_c = 1.0$, $k_{\\mathrm{B}} T = 1.0$.\n- Case D (high density, stringent Mach constraint): $\\rho = 10.0$, $V = 100.0$, $a = 80.0$, $U = 1.0$, $Ma_{\\max} = 0.05$, $c_s^{\\mathrm{target}} = 8.0$, $r_c = 1.0$, $k_{\\mathrm{B}} T = 1.0$.\n\nYour program should compute the eight requested quantities for each case and print a single line with the list of lists in the exact order: $\\left[ \\left\\langle (\\delta \\rho)^2 \\right\\rangle, \\kappa_T^{\\mathrm{infer}}, \\kappa_T^{\\mathrm{theory}}, |\\Delta \\kappa_T|, a_{\\mathrm{req}}, c_s^{\\mathrm{tuned}}, Ma^{\\mathrm{actual}}, \\left\\langle (\\delta \\rho)^2 \\right\\rangle_{\\mathrm{tuned}} \\right]$ for Case A, followed by Case B, Case C, and Case D, aggregated into one list.",
            "solution": "We begin from Newton’s equations and the virial theorem. For a homogeneous fluid, the pressure is the sum of ideal (kinetic) and interaction virial contributions. The ideal term is $P_{\\mathrm{ideal}} = \\rho k_{\\mathrm{B}} T$ for an isothermal fluid. The interaction virial with pairwise isotropic conservative force $F^{\\mathrm{C}}(r)$ under the mean-field approximation $g(r) \\approx 1$ is\n$$\nP_{\\mathrm{int}} = \\frac{2\\pi}{3} \\rho^2 \\int_{0}^{r_c} r^3 F^{\\mathrm{C}}(r) \\,\\mathrm{d}r .\n$$\nWith the DPD conservative force $F^{\\mathrm{C}}(r) = a w(r)$ and $w(r) = 1 - r/r_c$ for $r \\le r_c$, we compute the radial integral:\n$$\n\\int_{0}^{r_c} r^3 a\\left(1 - \\frac{r}{r_c}\\right) \\mathrm{d}r = a \\left[ \\int_{0}^{r_c} r^3 \\mathrm{d}r - \\frac{1}{r_c} \\int_{0}^{r_c} r^4 \\mathrm{d}r \\right] = a \\left[ \\frac{r_c^4}{4} - \\frac{r_c^5}{5 r_c} \\right] = a \\left( \\frac{r_c^4}{4} - \\frac{r_c^4}{5} \\right) = a \\frac{r_c^4}{20} .\n$$\nSubstituting into the virial expression yields\n$$\nP_{\\mathrm{int}} = \\frac{2\\pi}{3} \\rho^2 \\left( a \\frac{r_c^4}{20} \\right) = a \\rho^2 \\frac{\\pi r_c^4}{30} .\n$$\nTherefore, the mean-field pressure is\n$$\nP(\\rho) = \\rho k_{\\mathrm{B}} T + a \\rho^2 \\frac{\\pi r_c^4}{30} .\n$$\nWe differentiate with respect to $\\rho$ at constant $T$ to obtain the isothermal stiffness:\n$$\n\\left( \\frac{\\partial P}{\\partial \\rho} \\right)_T = k_{\\mathrm{B}} T + 2 a \\rho \\frac{\\pi r_c^4}{30} = k_{\\mathrm{B}} T + a \\rho \\frac{\\pi r_c^4}{15} .\n$$\nFor an isothermal barotropic fluid, the isothermal speed of sound is given by\n$$\nc_s^2 = \\left( \\frac{\\partial P}{\\partial \\rho} \\right)_T = k_{\\mathrm{B}} T + a \\rho \\frac{\\pi r_c^4}{15} .\n$$\nBy the definition of isothermal compressibility,\n$$\n\\kappa_T = \\frac{1}{\\rho \\left( \\frac{\\partial P}{\\partial \\rho} \\right)_T } = \\frac{1}{\\rho \\left( k_{\\mathrm{B}} T + a \\rho \\frac{\\pi r_c^4}{15} \\right)} .\n$$\nThe compressibility equation relates long-wavelength density fluctuations to $\\kappa_T$ via the static structure factor at zero wavevector:\n$$\nS(0) = \\rho k_{\\mathrm{B}} T \\kappa_T .\n$$\nIn a control volume $V$ with mean occupancy $\\langle N \\rangle = \\rho V$ under grand-canonical conditions, number fluctuations satisfy\n$$\n\\mathrm{Var}(N) = S(0) \\langle N \\rangle = \\left( \\rho k_{\\mathrm{B}} T \\kappa_T \\right) (\\rho V) = \\rho^2 V k_{\\mathrm{B}} T \\kappa_T .\n$$\nConverting to density fluctuations,\n$$\n\\left\\langle (\\delta \\rho)^2 \\right\\rangle = \\frac{ \\mathrm{Var}(N) }{ V^2 } = \\frac{ \\rho^2 V k_{\\mathrm{B}} T \\kappa_T }{V^2} = \\frac{ \\rho^2 k_{\\mathrm{B}} T \\kappa_T}{V} .\n$$\nSubstituting the expression for $\\kappa_T$ yields a closed-form prediction for the density fluctuation:\n$$\n\\left\\langle (\\delta \\rho)^2 \\right\\rangle = \\frac{ \\rho^2 k_{\\mathrm{B}} T }{ V } \\cdot \\frac{1}{ \\rho \\left( k_{\\mathrm{B}} T + a \\rho \\frac{\\pi r_c^4}{15} \\right) } = \\frac{ \\rho k_{\\mathrm{B}} T }{ V \\left( k_{\\mathrm{B}} T + a \\rho \\frac{\\pi r_c^4}{15} \\right) } .\n$$\nThese relations allow a consistent check: inferring $\\kappa_T$ from a measured $\\left\\langle (\\delta \\rho)^2 \\right\\rangle$ via\n$$\n\\kappa_T^{\\mathrm{infer}} = \\frac{ \\left\\langle (\\delta \\rho)^2 \\right\\rangle V }{ \\rho^2 k_{\\mathrm{B}} T }\n$$\nmust match the theoretical $\\kappa_T^{\\mathrm{theory}}$ if the measurement is ideal and the mean-field assumptions hold. The absolute difference\n$$\n|\\Delta \\kappa_T| = \\left| \\kappa_T^{\\mathrm{infer}} - \\kappa_T^{\\mathrm{theory}} \\right|\n$$\nquantifies any discrepancy.\n\nTo tune the conservative amplitude $a$ to achieve a target speed of sound while minimizing acoustic artifacts at a given Mach constraint, we use the fact that compressibility-driven acoustic artifacts in isothermal flows scale as $\\mathcal{O}(Ma^2)$. For a given characteristic speed $U$ and maximum allowable Mach $Ma_{\\max}$, the required speed of sound is\n$$\nc_s^{\\mathrm{req}} = \\max\\left( c_s^{\\mathrm{target}}, \\frac{U}{Ma_{\\max}} \\right) .\n$$\nSolving $c_s^2 = k_{\\mathrm{B}} T + a \\rho \\frac{\\pi r_c^4}{15}$ for $a$ gives\n$$\na = \\frac{15}{\\pi r_c^4 \\rho} \\left( c_s^2 - k_{\\mathrm{B}} T \\right) .\n$$\nImposing the physical constraint of nonnegative DPD repulsion, we take\n$$\na_{\\mathrm{req}} = \\max\\left( 0,\\ \\frac{15}{\\pi r_c^4 \\rho} \\left( \\left( c_s^{\\mathrm{req}} \\right)^2 - k_{\\mathrm{B}} T \\right) \\right) .\n$$\nThe tuned speed of sound is then\n$$\nc_s^{\\mathrm{tuned}} = \\sqrt{ k_{\\mathrm{B}} T + a_{\\mathrm{req}} \\rho \\frac{\\pi r_c^4}{15} } ,\n$$\nand the resulting Mach number is\n$$\nMa^{\\mathrm{actual}} = \\frac{U}{ c_s^{\\mathrm{tuned}} } .\n$$\nFinally, the tuned density fluctuation is computed as\n$$\n\\left\\langle (\\delta \\rho)^2 \\right\\rangle_{\\mathrm{tuned}} = \\frac{ \\rho^2 k_{\\mathrm{B}} T }{V} \\cdot \\frac{1}{ \\rho \\left( k_{\\mathrm{B}} T + a_{\\mathrm{req}} \\rho \\frac{\\pi r_c^4}{15} \\right) } = \\frac{ \\rho k_{\\mathrm{B}} T }{V \\left( k_{\\mathrm{B}} T + a_{\\mathrm{req}} \\rho \\frac{\\pi r_c^4}{15} \\right) } .\n$$\n\nAlgorithmic steps implemented in the program:\n- For each test case $(\\rho, V, a, U, Ma_{\\max}, c_s^{\\mathrm{target}}, r_c, k_{\\mathrm{B}} T)$:\n    1. Compute $\\left( \\frac{\\partial P}{\\partial \\rho} \\right)_T = k_{\\mathrm{B}} T + a \\rho \\frac{\\pi r_c^4}{15}$.\n    2. Compute $\\kappa_T^{\\mathrm{theory}} = \\frac{1}{\\rho \\left( \\frac{\\partial P}{\\partial \\rho} \\right)_T }$.\n    3. Compute $\\left\\langle (\\delta \\rho)^2 \\right\\rangle = \\frac{ \\rho^2 k_{\\mathrm{B}} T }{V} \\kappa_T^{\\mathrm{theory}}$.\n    4. Infer $\\kappa_T^{\\mathrm{infer}} = \\frac{ \\left\\langle (\\delta \\rho)^2 \\right\\rangle V }{ \\rho^2 k_{\\mathrm{B}} T }$ and the absolute error $|\\Delta \\kappa_T|$.\n    5. Determine $c_s^{\\mathrm{req}} = \\max( c_s^{\\mathrm{target}}, U/Ma_{\\max} )$ and compute $a_{\\mathrm{req}}$ with nonnegativity.\n    6. Compute $c_s^{\\mathrm{tuned}}$, $Ma^{\\mathrm{actual}}$, and $\\left\\langle (\\delta \\rho)^2 \\right\\rangle_{\\mathrm{tuned}}$ using $a_{\\mathrm{req}}$.\n- Aggregate the eight outputs into a list per case, and print a single list containing all four case lists on one line, as required.\n\nThis pipeline quantitatively connects compressibility, density fluctuations, and acoustic effects in a DPD fluid, and provides a principled tuning of the conservative force amplitude to achieve target isothermal acoustics under Mach constraints in mesoscale hydrodynamics.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dp_drho_isothermal(rho, a, rc, kBT):\n    # dP/d rho at constant T: kBT + a * rho * pi * rc^4 / 15\n    return kBT + a * rho * np.pi * (rc**4) / 15.0\n\ndef kappa_T_theory(rho, a, rc, kBT):\n    dpdrho = dp_drho_isothermal(rho, a, rc, kBT)\n    return 1.0 / (rho * dpdrho)\n\ndef density_variance(rho, V, a, rc, kBT):\n    # <(delta rho)^2> = rho^2 * kBT * kappa_T / V\n    kappa = kappa_T_theory(rho, a, rc, kBT)\n    return (rho**2) * kBT * kappa / V\n\ndef infer_kappa_T_from_variance(var_rho, rho, V, kBT):\n    # kappa_T_infer = var_rho * V / (rho^2 * kBT)\n    return var_rho * V / (rho**2 * kBT)\n\ndef required_a_for_cs(rho, rc, kBT, cs_req):\n    # a_req = max(0, (15/(pi rc^4 rho)) * (cs_req^2 - kBT))\n    a_raw = (15.0 / (np.pi * (rc**4) * rho)) * (cs_req**2 - kBT)\n    return max(0.0, a_raw)\n\ndef tuned_cs(rho, a, rc, kBT):\n    # cs^2 = kBT + a * rho * pi * rc^4 / 15\n    return np.sqrt(dp_drho_isothermal(rho, a, rc, kBT))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (rho, V, a_initial, U, Ma_max, cs_target, rc, kBT)\n    test_cases = [\n        (5.0, 50.0, 25.0, 0.5, 0.1, 5.0, 1.0, 1.0),   # Case A\n        (5.0, 5.0, 25.0, 0.2, 0.05, 10.0, 1.0, 1.0),  # Case B\n        (3.0, 30.0, 10.0, 0.2, 0.2, 0.8, 1.0, 1.0),   # Case C\n        (10.0, 100.0, 80.0, 1.0, 0.05, 8.0, 1.0, 1.0) # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        rho, V, a_init, U, Ma_max, cs_target, rc, kBT = case\n\n        # Initial theoretical compressibility and density variance\n        dpdrho_init = dp_drho_isothermal(rho, a_init, rc, kBT)\n        kappa_th = 1.0 / (rho * dpdrho_init)\n        var_init = (rho**2) * kBT * kappa_th / V\n\n        # Inferred compressibility from variance\n        kappa_infer = infer_kappa_T_from_variance(var_init, rho, V, kBT)\n        abs_error = abs(kappa_infer - kappa_th)\n\n        # Required speed of sound to satisfy target and Mach constraint\n        cs_req = max(cs_target, U / Ma_max)\n\n        # Compute required a (nonnegative)\n        a_req = required_a_for_cs(rho, rc, kBT, cs_req)\n\n        # Tuned sound speed, Mach number, and tuned variance\n        cs_tuned = tuned_cs(rho, a_req, rc, kBT)\n        Ma_actual = U / cs_tuned\n        # Tuned variance using tuned a\n        var_tuned = density_variance(rho, V, a_req, rc, kBT)\n\n        results.append([\n            var_init,\n            kappa_infer,\n            kappa_th,\n            abs_error,\n            a_req,\n            cs_tuned,\n            Ma_actual,\n            var_tuned\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nsolve()\n```"
        },
        {
            "introduction": "The true power of a mesoscale simulation technique like DPD lies in its ability to correctly capture complex hydrodynamic phenomena. A fundamental validation of any hydrodynamic solver is to reproduce canonical results from fluid mechanics. This practice  challenges you to do just that by simulating the sedimentation of a colloidal particle. You will compute the particle's terminal velocity and validate it against the theoretical prediction of Stokes' law, taking into account the finite-size corrections essential for systems with periodic boundary conditions, thereby confirming the model's ability to reproduce continuum-level hydrodynamics.",
            "id": "3446122",
            "problem": "You are asked to write a complete, runnable program that emulates how Dissipative Particle Dynamics (DPD) recovers mesoscale hydrodynamics for the sedimentation of a spherical colloid in a viscous Newtonian solvent under gravity with cubic periodic boundary conditions. The aim is to compute the terminal settling velocity from first principles and verify the Stokesian prediction once periodic boundary effects are accounted for.\n\nBase your derivation and algorithm strictly on the following fundamental laws and well-tested formulas:\n- Newton’s Second Law states that the time rate of change of momentum equals the sum of forces. At terminal velocity, acceleration is zero and the net force on the particle is zero.\n- The gravitational-buoyant force on a spherical particle of radius $R$ and densities $\\rho_p$ (particle) and $\\rho$ (solvent) under gravitational acceleration $g$ is $F_g = \\frac{4}{3}\\pi R^3 (\\rho_p - \\rho) g$.\n- In the creeping-flow (low Reynolds number) limit with no-slip conditions at the particle surface, the Stokes drag on a sphere moving with speed $U$ in a Newtonian solvent of viscosity $\\eta$ is $F_d = 6\\pi \\eta R U$.\n- In a cubic, triply periodic domain of side length $L$, hydrodynamic long-range interactions modify the mobility. For a single sphere sedimenting under the conditions above, the leading-order periodic correction to the translational mobility is well described by the Hasimoto series. Denote $\\alpha = R/L$. Then the dimensionless mobility factor is $M(\\alpha) = 1 - c_1 \\alpha + c_3 \\alpha^3 + \\mathcal{O}(\\alpha^5)$, with $c_1 = 2.837297$ and $c_3 = 4.19$. This modifies the infinite-domain terminal velocity by the multiplicative factor $M(\\alpha)$.\n\nFrom these bases, derive the infinite-domain terminal velocity by force balance at steady state and then apply the periodic correction factor $M(\\alpha)$ to obtain the predicted terminal velocity in a periodic box. Use this to compare against a provided “measured” terminal velocity, which you should interpret as coming from a DPD simulation that has been time-averaged until steady state.\n\nYour program must:\n- For each test case, compute the infinite-domain terminal velocity in meters per second and then apply the periodic boundary correction described above to obtain the predicted terminal velocity in meters per second.\n- Compute the relative error $e = \\lvert U_{\\text{meas}} - U_{\\text{pred}}\\rvert / U_{\\text{pred}}$ as a decimal. If $U_{\\text{pred}} = 0$, use an absolute error criterion instead: declare the comparison valid if $\\lvert U_{\\text{meas}}\\rvert \\le \\tau_{\\text{abs}}$, where $\\tau_{\\text{abs}}$ is a small absolute threshold in meters per second.\n- Verify Stokes’ law with periodic corrections by checking if $e \\le \\tau_{\\text{rel}}$, where $\\tau_{\\text{rel}}$ is a relative tolerance expressed as a decimal. Use $\\tau_{\\text{rel}} = 0.03$ and $\\tau_{\\text{abs}} = 1\\times 10^{-12}$.\n\nPhysical units and numerical requirements:\n- All inputs must be interpreted in SI units. Radii and lengths are in meters, densities in kilograms per cubic meter, gravitational acceleration in meters per second squared, viscosity in pascal-seconds, and velocities in meters per second.\n- Express all internally computed velocities in meters per second. The relative error is unitless and must be computed as a decimal (for example, $0.02$ for two percent).\n\nTest suite:\nFor each test case below, you are given $(\\rho_p, \\rho, g, R, \\eta, L, U_{\\text{meas}})$.\n\n1. Happy path with moderate periodic correction:\n   - $\\rho_p = 2000\\,\\text{kg/m}^3$, $\\rho = 1000\\,\\text{kg/m}^3$, $g = 9.81\\,\\text{m/s}^2$, $R = 1.0\\times 10^{-6}\\,\\text{m}$, $\\eta = 1.0\\times 10^{-3}\\,\\text{Pa}\\cdot\\text{s}$, $L = 5.0\\times 10^{-5}\\,\\text{m}$, $U_{\\text{meas}} = 2.077930593644\\times 10^{-6}\\,\\text{m/s}$.\n\n2. Large box, negligible periodic correction:\n   - $\\rho_p = 2000\\,\\text{kg/m}^3$, $\\rho = 1000\\,\\text{kg/m}^3$, $g = 9.81\\,\\text{m/s}^2$, $R = 1.0\\times 10^{-6}\\,\\text{m}$, $\\eta = 1.0\\times 10^{-3}\\,\\text{Pa}\\cdot\\text{s}$, $L = 1.0\\times 10^{-3}\\,\\text{m}$, $U_{\\text{meas}} = 2.1629456277627886\\times 10^{-6}\\,\\text{m/s}$.\n\n3. Boundary condition (neutral buoyancy):\n   - $\\rho_p = 1000\\,\\text{kg/m}^3$, $\\rho = 1000\\,\\text{kg/m}^3$, $g = 9.81\\,\\text{m/s}^2$, $R = 1.0\\times 10^{-6}\\,\\text{m}$, $\\eta = 1.0\\times 10^{-3}\\,\\text{Pa}\\cdot\\text{s}$, $L = 1.0\\times 10^{-4}\\,\\text{m}$, $U_{\\text{meas}} = 0.0\\,\\text{m/s}$.\n\n4. Small box, strong periodic correction (edge case with an intentional slight mismatch):\n   - $\\rho_p = 2000\\,\\text{kg/m}^3$, $\\rho = 1000\\,\\text{kg/m}^3$, $g = 9.81\\,\\text{m/s}^2$, $R = 1.0\\times 10^{-6}\\,\\text{m}$, $\\eta = 1.0\\times 10^{-3}\\,\\text{Pa}\\cdot\\text{s}$, $L = 5.0\\times 10^{-6}\\,\\text{m}$, $U_{\\text{meas}} = 1.07697283448\\times 10^{-6}\\,\\text{m/s}$.\n\n5. Different solvent viscosity and particle size:\n   - $\\rho_p = 1500\\,\\text{kg/m}^3$, $\\rho = 1000\\,\\text{kg/m}^3$, $g = 9.81\\,\\text{m/s}^2$, $R = 5.0\\times 10^{-7}\\,\\text{m}$, $\\eta = 2.0\\times 10^{-3}\\,\\text{Pa}\\cdot\\text{s}$, $L = 2.0\\times 10^{-5}\\,\\text{m}$, $U_{\\text{meas}} = 1.2912626475515624\\times 10^{-7}\\,\\text{m/s}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the verification results as a comma-separated Python-style list of booleans in the order of the test cases, for example: $[{\\rm True},{\\rm False},{\\rm True},\\dots]$.",
            "solution": "The problem requires the validation of a mesoscale hydrodynamic prediction for the sedimentation of a single spherical colloid in a periodic domain against simulated \"measured\" data. The validation is performed by deriving the terminal settling velocity from first principles, incorporating corrections for periodic boundary conditions, and comparing this prediction to the provided data within a specified tolerance.\n\nThe analysis proceeds in three stages: first, the derivation of the terminal velocity for an isolated sphere in an infinite fluid ($U_{\\infty}$); second, the application of a correction factor for a cubic periodic domain to obtain the predicted velocity ($U_{\\text{pred}}$); and third, the establishment of a verification protocol to compare $U_{\\text{pred}}$ with the measured velocity ($U_{\\text{meas}}$).\n\nAccording to Newton's Second Law, a particle reaches a constant terminal velocity when the net force acting upon it is zero. In this sedimentation problem, two forces are considered: the gravitational-buoyant force, $F_g$, which drives the sedimentation, and the hydrodynamic drag force, $F_d$, which opposes the motion. At steady state, these forces balance:\n$$\n\\sum F = F_g - F_d = 0 \\implies F_g = F_d\n$$\nThe problem provides the expressions for these forces. The gravitational-buoyant force on a sphere of radius $R$, particle density $\\rho_p$, and solvent density $\\rho$, under gravitational acceleration $g$, is:\n$$\nF_g = \\frac{4}{3}\\pi R^3 (\\rho_p - \\rho) g\n$$\nIn the low Reynolds number (creeping flow) regime, the Stokes drag force on this sphere moving at a velocity $U$ through a solvent of dynamic viscosity $\\eta$ is:\n$$\nF_d = 6\\pi \\eta R U\n$$\nBy equating these two forces, we can solve for the terminal velocity in an infinite, unbounded domain, denoted as $U_{\\infty}$:\n$$\n6\\pi \\eta R U_{\\infty} = \\frac{4}{3}\\pi R^3 (\\rho_p - \\rho) g\n$$\nSolving for $U_{\\infty}$ yields the Stokes settling velocity:\n$$\nU_{\\infty} = \\frac{\\frac{4}{3}\\pi R^3 (\\rho_p - \\rho) g}{6\\pi \\eta R} = \\frac{4 R^2 (\\rho_p - \\rho) g}{18 \\eta} = \\frac{2}{9} \\frac{R^2 (\\rho_p - \\rho) g}{\\eta}\n$$\nThis expression provides the benchmark velocity in the absence of boundary effects. A special case arises when the particle is neutrally buoyant, i.e., $\\rho_p = \\rho$. In this case, $F_g = 0$ and consequently $U_{\\infty} = 0$.\n\nNext, we account for the influence of periodic boundary conditions. In a simulation employing a cubic periodic box of side length $L$, the particle interacts with its own periodic images, which modifies the hydrodynamic drag. This effect is captured by a dimensionless mobility factor, $M(\\alpha)$, which is a function of the ratio $\\alpha = R/L$. The problem specifies the Hasimoto series expansion for this factor, truncated at the $\\alpha^3$ term:\n$$\nM(\\alpha) = 1 - c_1 \\alpha + c_3 \\alpha^3 + \\mathcal{O}(\\alpha^5)\n$$\nThe provided constants are $c_1 = 2.837297$ and $c_3 = 4.19$. The predicted terminal velocity in the periodic system, $U_{\\text{pred}}$, is obtained by multiplying the infinite-domain velocity by this mobility factor:\n$$\nU_{\\text{pred}} = U_{\\infty} \\times M(\\alpha) = \\left( \\frac{2}{9} \\frac{R^2 (\\rho_p - \\rho) g}{\\eta} \\right) \\left( 1 - c_1 \\frac{R}{L} + c_3 \\left(\\frac{R}{L}\\right)^3 \\right)\n$$\nFinally, we must establish a clear criterion for verifying the DPD \"measurement\" $U_{\\text{meas}}$ against our theoretical prediction $U_{\\text{pred}}$. The verification depends on whether the predicted velocity is zero or non-zero.\n\nCase 1: $U_{\\text{pred}} \\ne 0$ (i.e., $\\rho_p \\ne \\rho$).\nThe relative error, $e$, is computed as:\n$$\ne = \\frac{\\lvert U_{\\text{meas}} - U_{\\text{pred}}\\rvert}{\\lvert U_{\\text{pred}}\\rvert}\n$$\nThe verification is successful if this error is within a specified relative tolerance, $\\tau_{\\text{rel}} = 0.03$. That is, the result is `True` if $e \\le 0.03$.\n\nCase 2: $U_{\\text{pred}} = 0$ (i.e., $\\rho_p = \\rho$).\nIn this case, a relative error is undefined. The verification is instead based on an absolute tolerance, $\\tau_{\\text{abs}} = 1 \\times 10^{-12}\\,\\text{m/s}$. The verification is successful if the magnitude of the measured velocity is negligible, i.e., if:\n$$\n\\lvert U_{\\text{meas}} \\rvert \\le \\tau_{\\text{abs}}\n$$\nThe algorithm to be implemented will iterate through each test case, apply these derived formulas to compute $U_{\\text{pred}}$, and then use the appropriate verification criterion to determine a boolean result.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the predicted terminal settling velocity of a spherical colloid in a\n    periodic box and verifies it against a \"measured\" value from a DPD simulation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (rho_p, rho, g, R, eta, L, U_meas)\n    test_cases = [\n        # 1. Happy path with moderate periodic correction\n        (2000.0, 1000.0, 9.81, 1.0e-6, 1.0e-3, 5.0e-5, 2.077930593644e-6),\n        # 2. Large box, negligible periodic correction\n        (2000.0, 1000.0, 9.81, 1.0e-6, 1.0e-3, 1.0e-3, 2.1629456277627886e-6),\n        # 3. Boundary condition (neutral buoyancy)\n        (1000.0, 1000.0, 9.81, 1.0e-6, 1.0e-3, 1.0e-4, 0.0),\n        # 4. Small box, strong periodic correction\n        (2000.0, 1000.0, 9.81, 1.0e-6, 1.0e-3, 5.0e-6, 1.07697283448e-6),\n        # 5. Different solvent viscosity and particle size\n        (1500.0, 1000.0, 9.81, 5.0e-7, 2.0e-3, 2.0e-5, 1.2912626475515624e-7),\n    ]\n\n    # Constants and tolerances\n    c1 = 2.837297\n    c3 = 4.19\n    tau_rel = 0.03\n    tau_abs = 1.0e-12\n\n    results = []\n    for case in test_cases:\n        rho_p, rho, g, R, eta, L, u_meas = case\n        \n        # Check for the neutral buoyancy case first to avoid division by zero later\n        if rho_p == rho:\n            u_pred = 0.0\n            is_valid = abs(u_meas) <= tau_abs\n            results.append(is_valid)\n            continue\n            \n        # Step 1: Calculate the infinite-domain terminal velocity (U_infinity)\n        # U_infinity = (2 * R^2 * (rho_p - rho) * g) / (9 * eta)\n        u_infinity = (2.0 / 9.0) * (R**2 * (rho_p - rho) * g) / eta\n\n        # Step 2: Calculate the periodic correction factor M(alpha)\n        alpha = R / L\n        # M(alpha) = 1 - c1*alpha + c3*alpha^3\n        m_alpha = 1.0 - c1 * alpha + c3 * (alpha**3)\n        \n        # Step 3: Calculate the predicted terminal velocity in the periodic box\n        u_pred = u_infinity * m_alpha\n\n        # Step 4: Verify against the \"measured\" velocity using relative error\n        # e = |U_meas - U_pred| / |U_pred|\n        if u_pred != 0.0:\n            relative_error = abs(u_meas - u_pred) / abs(u_pred)\n            is_valid = relative_error <= tau_rel\n        else:\n            # This branch should not be reached due to the initial check for rho_p == rho,\n            # but is included for logical completeness.\n            is_valid = abs(u_meas) <= tau_abs\n            \n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}