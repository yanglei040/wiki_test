{
    "hands_on_practices": [
        {
            "introduction": "At the heart of most computational plasticity codes lies the stress update algorithm, responsible for integrating the constitutive equations over a discrete time step. This practice focuses on implementing the \"closest-point projection,\" or \"radial return,\" algorithm for the widely used $J_2$ plasticity model with isotropic hardening . Mastering this fundamental algorithm is essential for developing robust finite element simulations of metallic materials and provides a concrete foundation for understanding the numerical treatment of inelasticity.",
            "id": "3439480",
            "problem": "Consider small-strain, isotropic linear elasticity with associative von Mises plasticity based on the second invariant of the deviatoric stress ($J_2$) and linear isotropic hardening. Let the total strain be denoted by $\\boldsymbol{\\epsilon}$, the plastic strain by $\\boldsymbol{\\epsilon}^p$, and the Cauchy stress by $\\boldsymbol{\\sigma}$. The constitutive relation in small strain is $\\boldsymbol{\\sigma} = \\mathbb{C} : (\\boldsymbol{\\epsilon} - \\boldsymbol{\\epsilon}^p)$, where $\\mathbb{C}$ is the fourth-order elasticity tensor defined by the bulk modulus $\\kappa$ and shear modulus $G$. The deviatoric stress is $\\boldsymbol{s} = \\mathrm{dev}(\\boldsymbol{\\sigma})$. The von Mises equivalent stress is $\\sigma_{\\mathrm{eq}} = \\sqrt{\\frac{3}{2}} \\|\\boldsymbol{s}\\|$, where $\\|\\cdot\\|$ is the Frobenius norm and $\\mathrm{dev}(\\cdot)$ denotes the deviatoric projection. The yield function is $f(\\boldsymbol{\\sigma}, \\alpha) = \\sigma_{\\mathrm{eq}} - \\sigma_y(\\alpha)$ with linear isotropic hardening $\\sigma_y(\\alpha) = \\sigma_{y0} + H \\alpha$, where $\\sigma_{y0}$ is the initial yield stress, $H$ is the hardening modulus, and $\\alpha$ is the accumulated equivalent plastic strain. The associated flow rule is $\\dot{\\boldsymbol{\\epsilon}}^p = \\dot{\\lambda} \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}$, where $\\dot{\\lambda} \\ge 0$ is the plastic multiplier. The evolution of $\\alpha$ follows $\\dot{\\alpha} = \\sqrt{\\frac{2}{3}} \\dot{\\lambda}$. The Karush-Kuhn-Tucker (KKT) conditions are $\\dot{\\lambda} \\ge 0$, $f \\le 0$, and $\\dot{\\lambda} f = 0$, together with the consistency condition on the yield surface $\\dot{f} = 0$.\n\nYour task is to implement a closest-point projection (also called radial return mapping) in stress space that updates $\\boldsymbol{\\sigma}$, $\\boldsymbol{\\epsilon}^p$, and $\\alpha$ from step $n$ to $n+1$, starting from the fundamental base above. You must:\n- Derive from first principles (without using shortcut formulas) the algorithm that, given $\\boldsymbol{\\epsilon}_{n+1}$, $\\boldsymbol{\\epsilon}^p_n$, and $\\alpha_n$, returns $\\boldsymbol{\\sigma}_{n+1}$, $\\boldsymbol{\\epsilon}^p_{n+1}$, and $\\alpha_{n+1}$ via a closest-point projection in stress space consistent with the KKT conditions and associated flow.\n- Prove that in plastic loading the updated stress $\\boldsymbol{\\sigma}_{n+1}$ lies on the yield surface, meaning $f(\\boldsymbol{\\sigma}_{n+1}, \\alpha_{n+1}) = 0$ within a specified numerical tolerance.\n- Prove that the computed plastic increment maximizes the dissipation $\\Delta D = \\boldsymbol{\\sigma}_{n+1} : \\Delta \\boldsymbol{\\epsilon}^p$ among all admissible deviatoric plastic increments of fixed norm at the step.\n\nAlgorithmic and numerical details to observe:\n- Use small-strain kinematics with isotropic elasticity. The elasticity constants are given by $E$ and $\\nu$, with $G = \\frac{E}{2(1+\\nu)}$ and $\\kappa = \\frac{E}{3(1-2\\nu)}$.\n- The stress update must preserve the volumetric part under $J_2$ plasticity and only correct the deviatoric part via the return mapping.\n- The numerical tolerance for verifying $f(\\boldsymbol{\\sigma}_{n+1}, \\alpha_{n+1}) = 0$ must be set to $10^{-8}$ in units of $\\mathrm{MPa}$.\n\nPhysical units:\n- Use $\\mathrm{MPa}$ for all stresses and moduli ($E$, $G$, $\\kappa$, $\\sigma_{y0}$, $H$, $\\sigma_{\\mathrm{eq}}$).\n- Strains ($\\boldsymbol{\\epsilon}$, $\\boldsymbol{\\epsilon}^p$) are dimensionless.\n\nAngle units are not involved in this problem.\n\nTest suite:\nImplement your program to run the following test cases. Each test case uses a $3 \\times 3$ symmetric strain input represented in Voigt order $(\\epsilon_{xx}, \\epsilon_{yy}, \\epsilon_{zz}, \\epsilon_{xy}, \\epsilon_{yz}, \\epsilon_{zx})$, where the shear components are the tensorial strains (not engineering shear), and an initial plastic strain in the same format. The initial stress is not provided and must be computed from the constitutive relation. The materials are identical across cases.\n- Material parameters for all cases: $E = 210000 \\, \\mathrm{MPa}$, $\\nu = 0.3$, $\\sigma_{y0} = 400 \\, \\mathrm{MPa}$, $H = 1000 \\, \\mathrm{MPa}$.\n\nDefine $\\epsilon_{xy}^{\\star} = \\frac{\\sigma_{y0}}{2 G \\sqrt{3}}$ using the material parameters above.\n\n- Case $1$ (happy path, purely volumetric elastic): $\\boldsymbol{\\epsilon}_{n+1} = (0.001, 0.001, 0.001, 0, 0, 0)$, $\\boldsymbol{\\epsilon}^p_n = (0, 0, 0, 0, 0, 0)$, $\\alpha_n = 0$.\n- Case $2$ (plastic shear): $\\boldsymbol{\\epsilon}_{n+1} = (0, 0, 0, 1.5 \\, \\epsilon_{xy}^{\\star}, 0, 0)$, $\\boldsymbol{\\epsilon}^p_n = (0, 0, 0, 0, 0, 0)$, $\\alpha_n = 0$.\n- Case $3$ (boundary, at yield): $\\boldsymbol{\\epsilon}_{n+1} = (0, 0, 0, \\epsilon_{xy}^{\\star}, 0, 0)$, $\\boldsymbol{\\epsilon}^p_n = (0, 0, 0, 0, 0, 0)$, $\\alpha_n = 0$.\n- Case $4$ (combined deviatoric and volumetric with prior plasticity): $\\boldsymbol{\\epsilon}_{n+1} = (0.001, -0.0005, 0.0003, 0.025, 0, 0)$. Choose a prior plastic strain and equivalent plastic strain consistent with shear-only history, namely $\\alpha_n = 0.02$ and $\\boldsymbol{\\epsilon}^p_n = (0, 0, 0, \\frac{\\sqrt{3}}{2} \\alpha_n, 0, 0)$.\n\nFor each test case, your program must:\n- Compute the updated stress $\\boldsymbol{\\sigma}_{n+1}$, plastic strain $\\boldsymbol{\\epsilon}^p_{n+1}$, and equivalent plastic strain $\\alpha_{n+1}$ by closest-point projection.\n- Evaluate the yield function $f(\\boldsymbol{\\sigma}_{n+1}, \\alpha_{n+1})$ in $\\mathrm{MPa}$.\n- Verify the yield condition using a boolean $\\mathrm{on\\_or\\_inside}$ defined as: if plastic flow occurs then $|f(\\boldsymbol{\\sigma}_{n+1}, \\alpha_{n+1})| \\le 10^{-8}$, otherwise $f(\\boldsymbol{\\sigma}_{n+1}, \\alpha_{n+1}) \\le 0$.\n- Verify the maximum dissipation principle by comparing the plastic dissipation $\\Delta D = \\boldsymbol{\\sigma}_{n+1} : \\Delta \\boldsymbol{\\epsilon}^p$ against a finite set of random admissible deviatoric increments of the same Frobenius norm as $\\Delta \\boldsymbol{\\epsilon}^p$. Return a boolean $\\mathrm{max\\_dissipation}$ that is true if the computed plastic increment achieves a dissipation greater than or equal to the maximum among sampled directions up to a numerical tolerance of $10^{-12}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, append three items in order: the float $f(\\boldsymbol{\\sigma}_{n+1}, \\alpha_{n+1})$ in $\\mathrm{MPa}$, the boolean $\\mathrm{on\\_or\\_inside}$, and the boolean $\\mathrm{max\\_dissipation}$. The aggregated output over all four test cases must therefore be a flat list of twelve items, for example $[f_1,\\mathrm{on\\_or\\_inside}_1,\\mathrm{max\\_dissipation}_1,f_2,\\mathrm{on\\_or\\_inside}_2,\\mathrm{max\\_dissipation}_2,f_3,\\mathrm{on\\_or\\_inside}_3,\\mathrm{max\\_dissipation}_3,f_4,\\mathrm{on\\_or\\_inside}_4,\\mathrm{max\\_dissipation}_4]$, where each $f_i$ is in $\\mathrm{MPa}$.",
            "solution": "The problem is assessed to be valid. It outlines a standard problem in computational plasticity, providing a complete set of constitutive equations, material parameters, and boundary conditions for a series of test cases. The model is scientifically grounded, well-posed, and based on objective, formalizable statements. The request to use a non-standard hardening evolution law, $\\dot{\\alpha} = \\sqrt{2/3} \\dot{\\lambda}$, is a specific feature of the model to be implemented, not a flaw. A minor inconsistency is noted in the construction of Test Case 4, where the provided initial state $(\\boldsymbol{\\epsilon}^p_n, \\alpha_n)$ is consistent with the standard work-conjugacy definition ($\\alpha_n = \\sqrt{2/3} \\|\\boldsymbol{\\epsilon}^p_n\\|$) rather than the one implied by the problem's own evolution law ($\\alpha_n = (2/3) \\|\\boldsymbol{\\epsilon}^p_n\\|$). This does not impede the solution, as the algorithm operates on the provided state $(\\boldsymbol{\\epsilon}^p_n, \\alpha_n)$ and the incremental laws, regardless of how that state was reached. The solution will proceed by implementing the model as specified.\n\nThe core of the task is to derive and implement a closest-point projection algorithm, also known as a radial return map, for a $J_2$ plasticity model with linear isotropic hardening. The derivation will be based on a backward-Euler integration of the constitutive rate equations.\n\n### Constitutive Model Summary\nThe total strain $\\boldsymbol{\\epsilon}$ is additively decomposed into elastic and plastic parts:\n$$ \\boldsymbol{\\epsilon} = \\boldsymbol{\\epsilon}^e + \\boldsymbol{\\epsilon}^p $$\nThe stress-strain relation is given by Hooke's law:\n$$ \\boldsymbol{\\sigma} = \\mathbb{C} : \\boldsymbol{\\epsilon}^e = \\mathbb{C} : (\\boldsymbol{\\epsilon} - \\boldsymbol{\\epsilon}^p) $$\nFor isotropic linear elasticity, this can be written in terms of bulk modulus $\\kappa$ and shear modulus $G$ as:\n$$ \\boldsymbol{\\sigma} = \\kappa \\mathrm{tr}(\\boldsymbol{\\epsilon}^e) \\boldsymbol{I} + 2G \\mathrm{dev}(\\boldsymbol{\\epsilon}^e) $$\nwhere $\\boldsymbol{I}$ is the second-order identity tensor and $\\mathrm{dev}(\\cdot)$ is the deviatoric projection operator. The deviatoric stress is $\\boldsymbol{s} = \\mathrm{dev}(\\boldsymbol{\\sigma}) = 2G \\mathrm{dev}(\\boldsymbol{\\epsilon}^e)$.\n\nPlastic flow is governed by the von Mises yield criterion with linear isotropic hardening:\n$$ f(\\boldsymbol{\\sigma}, \\alpha) = \\sigma_{\\mathrm{eq}} - (\\sigma_{y0} + H \\alpha) \\le 0 $$\nwhere $\\sigma_{\\mathrm{eq}} = \\sqrt{\\frac{3}{2}\\boldsymbol{s}:\\boldsymbol{s}}$, $\\sigma_{y0}$ is the initial yield stress, $H$ is the hardening modulus, and $\\alpha$ is the accumulated equivalent plastic strain.\n\nThe plastic flow is associative, meaning the plastic strain rate is normal to the yield surface:\n$$ \\dot{\\boldsymbol{\\epsilon}}^p = \\dot{\\lambda} \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\dot{\\lambda} \\frac{3}{2} \\frac{\\boldsymbol{s}}{\\sigma_{\\mathrm{eq}}} $$\nThe plastic multiplier $\\dot{\\lambda}$ must satisfy the Karush-Kuhn-Tucker (KKT) conditions: $\\dot{\\lambda} \\ge 0$, $f \\le 0$, $\\dot{\\lambda}f = 0$.\n\nThe evolution of the hardening variable $\\alpha$ is given by the non-standard relation:\n$$ \\dot{\\alpha} = \\sqrt{\\frac{2}{3}} \\dot{\\lambda} $$\nThis differs from the standard work-conjugate definition, which would yield $\\dot{\\alpha} = \\dot{\\lambda}$.\n\n### Derivation of the Radial Return Algorithm\nWe use an implicit backward-Euler scheme to integrate the flow rules over a time step from $t_n$ to $t_{n+1}$. All rates $\\dot{(\\cdot)}$ are approximated as increments $\\Delta(\\cdot) = (\\cdot)_{n+1} - (\\cdot)_n$.\n\n#### 1. Elastic Predictor\nFirst, we assume the entire strain increment $\\Delta \\boldsymbol{\\epsilon} = \\boldsymbol{\\epsilon}_{n+1} - \\boldsymbol{\\epsilon}_n$ is elastic. This gives a trial stress state, denoted by a `trial` superscript.\nThe trial elastic strain at step $n+1$ is:\n$$ \\boldsymbol{\\epsilon}^{e, \\text{trial}} = \\boldsymbol{\\epsilon}_{n+1} - \\boldsymbol{\\epsilon}^p_n $$\nThe trial stress is computed from Hooke's law:\n$$ \\boldsymbol{\\sigma}^{\\text{trial}} = \\mathbb{C} : (\\boldsymbol{\\epsilon}_{n+1} - \\boldsymbol{\\epsilon}^p_n) $$\nThis relation can be decomposed into volumetric and deviatoric parts:\n$$ \\mathrm{tr}(\\boldsymbol{\\sigma}^{\\text{trial}}) = 3\\kappa \\, \\mathrm{tr}(\\boldsymbol{\\epsilon}_{n+1} - \\boldsymbol{\\epsilon}^p_n) $$\n$$ \\boldsymbol{s}^{\\text{trial}} = 2G \\, \\mathrm{dev}(\\boldsymbol{\\epsilon}_{n+1} - \\boldsymbol{\\epsilon}^p_n) $$\nThe trial equivalent stress is $\\sigma_{\\mathrm{eq}}^{\\text{trial}} = \\sqrt{\\frac{3}{2} \\boldsymbol{s}^{\\text{trial}} : \\boldsymbol{s}^{\\text{trial}}}$.\n\n#### 2. Yield Check\nWe check if this trial stress state violates the yield condition. The yield surface at the beginning of the step is defined by $\\alpha_n$.\n$$ f^{\\text{trial}} = \\sigma_{\\mathrm{eq}}^{\\text{trial}} - (\\sigma_{y0} + H\\alpha_n) $$\n- If $f^{\\text{trial}} \\le 0$, the assumption was correct. The step is elastic. The state variables are updated trivially:\n  $\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}^{\\text{trial}}$, $\\boldsymbol{\\epsilon}^p_{n+1} = \\boldsymbol{\\epsilon}^p_n$, and $\\alpha_{n+1} = \\alpha_n$.\n- If $f^{\\text{trial}} > 0$, the trial stress lies outside the elastic domain. Plastic deformation occurs, and a corrector step is needed.\n\n#### 3. Plastic Corrector\nFor a plastic step, the state at $n+1$ must satisfy a discrete version of the constitutive laws.\nThe stress is:\n$$ \\boldsymbol{\\sigma}_{n+1} = \\mathbb{C} : (\\boldsymbol{\\epsilon}_{n+1} - \\boldsymbol{\\epsilon}^p_{n+1}) = \\mathbb{C} : (\\boldsymbol{\\epsilon}_{n+1} - \\boldsymbol{\\epsilon}^p_n - \\Delta\\boldsymbol{\\epsilon}^p) = \\boldsymbol{\\sigma}^{\\text{trial}} - \\mathbb{C} : \\Delta\\boldsymbol{\\epsilon}^p $$\nThe plastic strain increment $\\Delta\\boldsymbol{\\epsilon}^p$ is deviatoric, so its product with $\\mathbb{C}$ only affects the deviatoric part of stress. The volumetric/hydrostatic stress is preserved from the trial state.\n$$ \\boldsymbol{s}_{n+1} = \\boldsymbol{s}^{\\text{trial}} - 2G \\Delta\\boldsymbol{\\epsilon}^p $$\n$$ \\mathrm{tr}(\\boldsymbol{\\sigma}_{n+1}) = \\mathrm{tr}(\\boldsymbol{\\sigma}^{\\text{trial}}) $$\nThe backward-Euler discrete flow rule is:\n$$ \\Delta\\boldsymbol{\\epsilon}^p = \\Delta\\lambda \\left. \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} \\right|_{n+1} = \\Delta\\lambda \\frac{3}{2} \\frac{\\boldsymbol{s}_{n+1}}{\\sigma_{\\mathrm{eq},n+1}} $$\nwhere $\\Delta\\lambda \\ge 0$ is the consistency parameter. Substituting this into the deviatoric stress update:\n$$ \\boldsymbol{s}_{n+1} = \\boldsymbol{s}^{\\text{trial}} - 2G \\left( \\Delta\\lambda \\frac{3}{2} \\frac{\\boldsymbol{s}_{n+1}}{\\sigma_{\\mathrm{eq},n+1}} \\right) = \\boldsymbol{s}^{\\text{trial}} - 3G \\Delta\\lambda \\frac{\\boldsymbol{s}_{n+1}}{\\sigma_{\\mathrm{eq},n+1}} $$\nRearranging gives:\n$$ \\boldsymbol{s}_{n+1} \\left( 1 + \\frac{3G \\Delta\\lambda}{\\sigma_{\\mathrm{eq},n+1}} \\right) = \\boldsymbol{s}^{\\text{trial}} $$\nThis equation shows that $\\boldsymbol{s}_{n+1}$ and $\\boldsymbol{s}^{\\text{trial}}$ are coaxial. This means the stress is returned \"radially\" toward the origin in the deviatoric stress space.\nTaking the Frobenius norm of both sides and converting to equivalent stress ($\\sigma_{\\mathrm{eq}} = \\sqrt{3/2} \\|\\boldsymbol{s}\\|$):\n$$ \\sigma_{\\mathrm{eq},n+1} \\left( 1 + \\frac{3G \\Delta\\lambda}{\\sigma_{\\mathrm{eq},n+1}} \\right) = \\sigma_{\\mathrm{eq}}^{\\text{trial}} \\implies \\sigma_{\\mathrm{eq},n+1} + 3G \\Delta\\lambda = \\sigma_{\\mathrm{eq}}^{\\text{trial}} $$\nThis is the first equation for our unknowns $\\sigma_{\\mathrm{eq},n+1}$ and $\\Delta\\lambda$. The second comes from the consistency condition, $f(\\boldsymbol{\\sigma}_{n+1}, \\alpha_{n+1}) = 0$:\n$$ \\sigma_{\\mathrm{eq},n+1} = \\sigma_y(\\alpha_{n+1}) = \\sigma_{y0} + H\\alpha_{n+1} $$\nThe discrete hardening law is $\\alpha_{n+1} = \\alpha_n + \\Delta\\alpha = \\alpha_n + \\sqrt{2/3} \\Delta\\lambda$. Substituting this into the yield condition:\n$$ \\sigma_{\\mathrm{eq},n+1} = \\sigma_{y0} + H(\\alpha_n + \\sqrt{2/3} \\Delta\\lambda) = (\\sigma_{y0} + H\\alpha_n) + H\\sqrt{2/3} \\Delta\\lambda $$\nWe now have a system of two linear equations for $\\sigma_{\\mathrm{eq},n+1}$ and $\\Delta\\lambda$. Substituting for $\\sigma_{\\mathrm{eq},n+1}$:\n$$ (\\sigma_{y0} + H\\alpha_n) + H\\sqrt{2/3} \\Delta\\lambda + 3G \\Delta\\lambda = \\sigma_{\\mathrm{eq}}^{\\text{trial}} $$\n$$ \\Delta\\lambda (3G + H\\sqrt{2/3}) = \\sigma_{\\mathrm{eq}}^{\\text{trial}} - (\\sigma_{y0} + H\\alpha_n) $$\nThe right-hand side is precisely $f^{\\text{trial}}$. So, the plastic multiplier is:\n$$ \\Delta\\lambda = \\frac{f^{\\text{trial}}}{3G + H\\sqrt{2/3}} $$\nSince we are in the plastic case, $f^{\\text{trial}} > 0$. As $G > 0$ and $H \\ge 0$, we have $\\Delta\\lambda > 0$.\n\nWith $\\Delta\\lambda$ known, all variables at step $n+1$ can be determined:\n1.  $\\Delta\\lambda = \\frac{\\sigma_{\\mathrm{eq}}^{\\text{trial}} - (\\sigma_{y0} + H\\alpha_n)}{3G + H\\sqrt{2/3}}$\n2.  $\\alpha_{n+1} = \\alpha_n + \\sqrt{2/3}\\Delta\\lambda$\n3.  $\\boldsymbol{s}_{n+1} = \\boldsymbols^{\\text{trial}} \\left( 1 - \\frac{3G\\Delta\\lambda}{\\sigma_{\\mathrm{eq}}^{\\text{trial}}} \\right)$\n4.  $\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{s}_{n+1} + \\frac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma}^{\\text{trial}}) \\boldsymbol{I}$\n5.  $\\Delta \\boldsymbol{\\epsilon}^p = \\Delta\\lambda \\frac{3}{2} \\frac{\\boldsymbol{s}_{n+1}}{\\sigma_{\\mathrm{eq},n+1}}$. Since $\\boldsymbol{s}_{n+1}$ is coaxial with $\\boldsymbol{s}^{\\text{trial}}$, we can also write $\\Delta \\boldsymbol{\\epsilon}^p = \\Delta \\lambda \\frac{3}{2} \\frac{\\boldsymbol{s}^{\\text{trial}}}{\\sigma_{\\mathrm{eq}}^{\\text{trial}}}$.\n6.  $\\boldsymbol{\\epsilon}^p_{n+1} = \\boldsymbol{\\epsilon}^p_n + \\Delta\\boldsymbol{\\epsilon}^p$\n\n### Proof of Yield Condition Satisfaction\nThe problem requires proof that the updated stress $\\boldsymbol{\\sigma}_{n+1}$ lies on the yield surface, i.e., $f(\\boldsymbol{\\sigma}_{n+1}, \\alpha_{n+1})=0$, in a plastic step. This is satisfied by construction. The derivation for $\\Delta\\lambda$ was based on simultaneously enforcing the stress-strain relation and the yield condition. By substituting the expression for $\\Delta\\lambda$ back into the update rules, we can verify this.\nWe have $\\sigma_{\\mathrm{eq},n+1} = \\sigma_{\\mathrm{eq}}^{\\text{trial}} - 3G\\Delta\\lambda$.\nThe updated yield stress is $\\sigma_y(\\alpha_{n+1}) = \\sigma_y(\\alpha_n) + H\\sqrt{2/3}\\Delta\\lambda$.\nWe must show $\\sigma_{\\mathrm{eq},n+1} = \\sigma_y(\\alpha_{n+1})$.\n$$ \\sigma_{\\mathrm{eq}}^{\\text{trial}} - 3G\\Delta\\lambda = \\sigma_y(\\alpha_n) + H\\sqrt{2/3}\\Delta\\lambda $$\n$$ \\sigma_{\\mathrm{eq}}^{\\text{trial}} - \\sigma_y(\\alpha_n) = (3G + H\\sqrt{2/3})\\Delta\\lambda $$\n$$ f^{\\text{trial}} = (3G + H\\sqrt{2/3})\\Delta\\lambda $$\nThis is precisely the equation from which $\\Delta\\lambda$ was derived. Thus, the algorithm guarantees that $\\boldsymbol{\\sigma}_{n+1}$ lies on the updated yield surface $f(\\boldsymbol{\\sigma}_{n+1}, \\alpha_{n+1})=0$ to within numerical precision.\n\n### Proof of Maximum Plastic Dissipation\nThe problem asks to prove that the plastic increment $\\Delta\\boldsymbol{\\epsilon}^p$ maximizes the dissipation increment $\\Delta D = \\boldsymbol{\\sigma}_{n+1} : \\Delta\\boldsymbol{\\epsilon}^p$ among all admissible deviatoric plastic increments of a fixed norm. This is a statement of the principle of maximum plastic dissipation, which is a key feature of associative plasticity.\nThe theory of plasticity postulates (Drucker's stability postulate) that for any external agency that starts from a zero state and applies and then removes a set of forces, the work done by the external agency is non-negative. This leads to the principle of maximum plastic dissipation, which states that for any admissible stress state $\\boldsymbol{\\tau}^*$ (i.e., $f(\\boldsymbol{\\tau}^*, \\alpha) \\le 0$), the following inequality holds:\n$$ (\\boldsymbol{\\sigma} - \\boldsymbol{\\tau}^*) : \\dot{\\boldsymbol{\\epsilon}}^p \\ge 0 $$\nwhere $\\dot{\\boldsymbol{\\epsilon}}^p$ is the plastic strain rate corresponding to the stress state $\\boldsymbol{\\sigma}$. For an associative flow rule, $\\dot{\\boldsymbol{\\epsilon}}^p = \\dot{\\lambda} \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}$. Since the yield surface $f$ is a convex function of $\\boldsymbol{\\sigma}$, this inequality is naturally satisfied.\n\nSpecializing to our problem, we want to show that for our computed $\\Delta\\boldsymbol{\\epsilon}^p = \\Delta\\boldsymbol{\\epsilon}^p_{\\text{calc}}$, the dissipation $\\Delta D = \\boldsymbol{\\sigma}_{n+1} : \\Delta\\boldsymbol{\\epsilon}^p_{\\text{calc}}$ is maximal.\nSince the plastic strain increment is deviatoric, $\\Delta D = \\boldsymbol{s}_{n+1} : \\Delta\\boldsymbol{\\epsilon}^p_{\\text{calc}}$.\nFrom the associative flow rule, $\\Delta\\boldsymbol{\\epsilon}^p_{\\text{calc}}$ is proportional to $\\boldsymbol{s}_{n+1}$, i.e., $\\Delta\\boldsymbol{\\epsilon}^p_{\\text{calc}} = c \\boldsymbol{s}_{n+1}$ for some positive scalar $c = \\frac{3 \\Delta\\lambda}{2 \\sigma_{\\mathrm{eq},n+1}}$.\nSo, $\\Delta D = \\boldsymbol{s}_{n+1} : (c \\boldsymbol{s}_{n+1}) = c \\|\\boldsymbol{s}_{n+1}\\|^2$.\nNow consider any other admissible deviatoric increment $\\Delta\\boldsymbol{\\epsilon}^p_{\\text{other}}$ with the same norm: $\\|\\Delta\\boldsymbol{\\epsilon}^p_{\\text{other}}\\| = \\|\\Delta\\boldsymbol{\\epsilon}^p_{\\text{calc}}\\|$.\nThe dissipation for this other increment is $\\Delta D_{\\text{other}} = \\boldsymbol{s}_{n+1} : \\Delta\\boldsymbol{\\epsilon}^p_{\\text{other}}$.\nBy the Cauchy-Schwarz inequality:\n$$ \\Delta D_{\\text{other}} = \\boldsymbol{s}_{n+1} : \\Delta\\boldsymbol{\\epsilon}^p_{\\text{other}} \\le \\|\\boldsymbol{s}_{n+1}\\| \\|\\Delta\\boldsymbol{\\epsilon}^p_{\\text{other}}\\| $$\nSince $\\|\\Delta\\boldsymbol{\\epsilon}^p_{\\text{other}}\\| = \\|\\Delta\\boldsymbol{\\epsilon}^p_{\\text{calc}}\\| = \\|c \\boldsymbol{s}_{n+1}\\|_F = c \\|\\boldsymbol{s}_{n+1}\\|$, we have:\n$$ \\Delta D_{\\text{other}} \\le \\|\\boldsymbol{s}_{n+1}\\| (c \\|\\boldsymbol{s}_{n+1}\\|) = c \\|\\boldsymbol{s}_{n+1}\\|^2 = \\Delta D $$\nThis proves that the dissipation is maximized by the strain increment collinear with the deviatoric stress, which is exactly what the associative flow rule provides. The numerical part of the task will verify this property by sampling random directions.",
            "answer": "```python\nimport numpy as np\n\ndef voigt_to_matrix(v):\n    \"\"\"Converts a 6-element Voigt strain vector to a 3x3 symmetric matrix.\n    Voigt order: (xx, yy, zz, xy, yz, zx)\n    \"\"\"\n    m = np.zeros((3, 3))\n    m[0, 0] = v[0]\n    m[1, 1] = v[1]\n    m[2, 2] = v[2]\n    m[0, 1] = m[1, 0] = v[3]\n    m[1, 2] = m[2, 1] = v[4]\n    m[0, 2] = m[2, 0] = v[5]\n    return m\n\ndef matrix_to_voigt(m):\n    \"\"\"Converts a 3x3 symmetric matrix to a 6-element Voigt strain vector.\n    Voigt order: (xx, yy, zz, xy, yz, zx)\n    \"\"\"\n    return np.array([m[0, 0], m[1, 1], m[2, 2], m[0, 1], m[1, 2], m[0, 2]])\n\ndef get_deviatoric(tensor):\n    \"\"\"Returns the deviatoric part of a 3x3 tensor.\"\"\"\n    return tensor - (1./3.) * np.trace(tensor) * np.eye(3)\n\ndef solve():\n    # Material parameters\n    E = 210000.0  # MPa\n    nu = 0.3\n    sigma_y0 = 400.0  # MPa\n    H = 1000.0  # MPa\n\n    # Elastic constants\n    G = E / (2.0 * (1.0 + nu))\n    kappa = E / (3.0 * (1.0 - 2.0 * nu))\n\n    # Tolerance\n    yield_tol = 1e-8\n    dissipation_tol = 1e-12\n\n    # Define epsilon_xy_star\n    epsilon_xy_star = sigma_y0 / (2.0 * G * np.sqrt(3.0))\n    \n    alpha_n_case4 = 0.02\n    eps_p_n_voigt_case4 = np.array([0, 0, 0, (np.sqrt(3.0)/2.0) * alpha_n_case4, 0, 0])\n\n    test_cases = [\n        # (eps_n+1_voigt, eps_p_n_voigt, alpha_n)\n        (np.array([0.001, 0.001, 0.001, 0, 0, 0]), np.zeros(6), 0.0),\n        (np.array([0, 0, 0, 1.5 * epsilon_xy_star, 0, 0]), np.zeros(6), 0.0),\n        (np.array([0, 0, 0, epsilon_xy_star, 0, 0]), np.zeros(6), 0.0),\n        (np.array([0.001, -0.0005, 0.0003, 0.025, 0, 0]), eps_p_n_voigt_case4, alpha_n_case4),\n    ]\n\n    results = []\n\n    for eps_n1_voigt, eps_p_n_voigt, alpha_n in test_cases:\n        # Convert Voigt inputs to 3x3 matrices\n        eps_n1 = voigt_to_matrix(eps_n1_voigt)\n        eps_p_n = voigt_to_matrix(eps_p_n_voigt)\n\n        # 1. Elastic Predictor\n        eps_e_trial = eps_n1 - eps_p_n\n        \n        # Decompose trial elastic strain\n        trace_eps_e_trial = np.trace(eps_e_trial)\n        e_e_trial = get_deviatoric(eps_e_trial)\n\n        # Compute trial stress\n        s_trial = 2.0 * G * e_e_trial\n        p_trial = kappa * trace_eps_e_trial\n        sigma_trial = s_trial + (p_trial / 3.0) * np.eye(3)\n\n        # 2. Check Yield Condition\n        s_trial_norm_sq = np.sum(s_trial * s_trial)\n        sigma_eq_trial = np.sqrt(3.0 / 2.0 * s_trial_norm_sq)\n        \n        sigma_y_n = sigma_y0 + H * alpha_n\n        f_trial = sigma_eq_trial - sigma_y_n\n\n        is_plastic = False\n        delta_lambda = 0.0\n\n        if f_trial > yield_tol: # Use a small tolerance to avoid floating point issues at the boundary\n            # 3. Plastic Corrector\n            is_plastic = True\n            \n            # Compute plastic multiplier\n            delta_lambda = f_trial / (3.0 * G + H * np.sqrt(2.0/3.0))\n\n            # Update state variables\n            alpha_n1 = alpha_n + np.sqrt(2.0/3.0) * delta_lambda\n            \n            # Radial return for deviatoric stress\n            s_n1 = s_trial * (1.0 - (3.0 * G * delta_lambda) / sigma_eq_trial)\n            \n            # Hydrostatic stress is unchanged\n            p_n1 = p_trial\n            sigma_n1 = s_n1 + (p_n1 / 3.0) * np.eye(3)\n\n            # Update plastic strain (not strictly needed for stress update but for completion)\n            # Flow direction from trial state\n            if sigma_eq_trial > 1e-12:\n                flow_dir = (3.0 / 2.0) * (s_trial / sigma_eq_trial)\n            else: # Should not happen in plastic case\n                flow_dir = np.zeros((3,3))\n\n            delta_eps_p = delta_lambda * flow_dir\n            eps_p_n1 = eps_p_n + delta_eps_p\n        \n        else:\n            # Elastic step\n            sigma_n1 = sigma_trial\n            eps_p_n1 = eps_p_n\n            alpha_n1 = alpha_n\n            s_n1 = s_trial\n\n        # 4. Verification steps\n        # Evaluate final yield function\n        s_n1_norm_sq = np.sum(s_n1 * s_n1)\n        sigma_eq_n1 = np.sqrt(3.0 / 2.0 * s_n1_norm_sq)\n        sigma_y_n1 = sigma_y0 + H * alpha_n1\n        f_final = sigma_eq_n1 - sigma_y_n1\n        results.append(f_final)\n\n        # Verify on_or_inside condition\n        on_or_inside = False\n        if is_plastic:\n            if abs(f_final) = yield_tol:\n                on_or_inside = True\n        else: # elastic\n            if f_final = yield_tol: # Use tolerance for comparison\n                on_or_inside = True\n        results.append(on_or_inside)\n\n        # Verify max dissipation principle\n        max_dissipation = False\n        if is_plastic:\n            delta_eps_p = eps_p_n1 - eps_p_n\n            dissipation_calc = np.sum(sigma_n1 * delta_eps_p)\n            delta_eps_p_norm = np.linalg.norm(delta_eps_p)\n            \n            # Check for zero plastic strain increment\n            if delta_eps_p_norm  1e-14:\n                max_dissipation = True\n            else:\n                max_diss_so_far = True\n                num_samples = 100\n                np.random.seed(0) # for reproducibility\n                for _ in range(num_samples):\n                    # Generate random symmetric deviatoric tensor\n                    rand_mx = np.random.randn(3, 3)\n                    rand_sym_mx = 0.5 * (rand_mx + rand_mx.T)\n                    rand_dev_mx = get_deviatoric(rand_sym_mx)\n                    rand_dev_norm = np.linalg.norm(rand_dev_mx)\n                    \n                    if rand_dev_norm  1e-14: continue\n\n                    # Scale to same norm as delta_eps_p\n                    rand_dev_mx_scaled = rand_dev_mx * (delta_eps_p_norm / rand_dev_norm)\n                    \n                    dissipation_rand = np.sum(sigma_n1 * rand_dev_mx_scaled)\n                    \n                    if dissipation_calc  dissipation_rand - dissipation_tol:\n                        max_diss_so_far = False\n                        break\n                max_dissipation = max_diss_so_far\n        else: # elastic step\n            max_dissipation = True # Condition is trivially met as no plastic dissipation\n        results.append(max_dissipation)\n\n    # Final print statement\n    output_str = \",\".join(map(lambda x: str(x) if isinstance(x, bool) else f\"{x:.12e}\", results))\n    print(f\"[{output_str}]\".replace(\"True\", \"True\").replace(\"False\", \"False\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "While the radial return algorithm is often presented as a procedural recipe, it possesses a deep and elegant foundation in variational principles. This exercise demonstrates the profound equivalence between the classical, algorithm-based return mapping and the solution of an incremental energy minimization problem for a rate-independent material . By deriving and comparing both approaches in a simplified one-dimensional setting, you will gain a more fundamental understanding of the thermodynamic and mathematical structure that underpins modern plasticity models.",
            "id": "3439497",
            "problem": "Consider uniaxial, small-strain, rate-independent, associative perfect plasticity for a single material point representing a uniform bar segment. Let the total strain at time step $n+1$ be prescribed as $ \\varepsilon_{n+1} \\in \\mathbb{R} $, and let the internal variables at time step $n$ be the plastic strain $ \\varepsilon^p_n \\in \\mathbb{R} $ and the accumulated plastic strain $ \\alpha_n \\in \\mathbb{R}_{\\ge 0} $. Assume the additive strain decomposition $ \\varepsilon = \\varepsilon^e + \\varepsilon^p $ in the small-strain regime, linear elastic free energy density $ W(\\varepsilon^e) = \\tfrac{1}{2} E (\\varepsilon^e)^2 $ with modulus $ E  0 $, a rate-independent dissipation potential $ R(\\Delta \\varepsilon^p) = \\sigma_Y \\lvert \\Delta \\varepsilon^p \\rvert $ with yield stress $ \\sigma_Y  0 $, and the hardening measure update $ \\alpha_{n+1} = \\alpha_n + \\lvert \\varepsilon^p_{n+1} - \\varepsilon^p_n \\rvert $. Optionally, include a linear microforce term $ - b \\, \\alpha_{n+1} $ with a prescribed scalar $ b \\in \\mathbb{R} $; for perfect plasticity in the test suite specified below use $ b = 0 $. All quantities are nondimensional (unitless).\n\nStarting from the principle that rate-independent evolution at discrete time $ n \\to n+1 $ can be characterized by minimizing an incremental potential over admissible internal variables, formulate the local incremental minimization problem for the pair $ (\\varepsilon^p_{n+1}, \\alpha_{n+1}) $ based on\n$$\n\\Pi_{n+1}(\\varepsilon^p_{n+1},\\alpha_{n+1}) = \\tfrac{1}{2} E \\left( \\varepsilon_{n+1} - \\varepsilon^p_{n+1} \\right)^2 \\;+\\; R\\!\\left(\\varepsilon^p_{n+1} - \\varepsilon^p_n\\right) \\;-\\; b\\, \\alpha_{n+1}\n$$\nsubject to the kinematic constraint $ \\alpha_{n+1} = \\alpha_n + \\lvert \\varepsilon^p_{n+1} - \\varepsilon^p_n \\rvert $. Derive the reduced scalar convex minimization problem in terms of the plastic increment $ \\Delta \\varepsilon^p = \\varepsilon^p_{n+1} - \\varepsilon^p_n $ and explain the role of the sign of the elastic trial state. Show how this variational formulation implies a threshold condition and a closed-form update for $ \\varepsilon^p_{n+1} $.\n\nIndependently, starting from the definitions of trial stress and the associative flow for one-dimensional perfect plasticity, derive the classical return mapping algorithm at a single material point. Use the small-strain linear-elastic trial stress $ \\sigma^{\\mathrm{tr}} = E \\left(\\varepsilon_{n+1} - \\varepsilon^p_n\\right) $, the yield function $ f^{\\mathrm{tr}} = \\lvert \\sigma^{\\mathrm{tr}} \\rvert - \\sigma_Y $, and construct the elastic/plastic branch logic with plastic multiplier $ \\Delta \\gamma \\ge 0 $. Provide the stress update $ \\sigma_{n+1} $ and internal variable updates $ \\varepsilon^p_{n+1} $ and $ \\alpha_{n+1} $.\n\nImplement both solution routes in a single program:\n- Route A (variational incremental minimization): solve the reduced scalar convex minimization problem exactly and compute $ \\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^p_{n+1}) $, $ \\varepsilon^p_{n+1} $, and $ \\alpha_{n+1} $.\n- Route B (classical return mapping): implement the trial state, elastic check, and plastic correction to compute the same quantities.\n\nUse the following test suite of $5$ cases, each specified as a tuple $ (E, \\sigma_Y, b, \\varepsilon_{n+1}, \\varepsilon^p_n, \\alpha_n) $:\n- Case $1$: $(200.0, 1.0, 0.0, 0.004, 0.0, 0.0)$\n- Case $2$: $(200.0, 1.0, 0.0, 0.005, 0.0, 0.0)$\n- Case $3$: $(200.0, 1.0, 0.0, 0.010, 0.0, 0.0)$\n- Case $4$: $(200.0, 1.0, 0.0, 0.006, 0.005, 0.005)$\n- Case $5$: $(200.0, 1.0, 0.0, -0.010, 0.005, 0.005)$\n\nFor each case, compute the results by both routes and compare the triplets $ (\\sigma_{n+1}, \\varepsilon^p_{n+1}, \\alpha_{n+1}) $. For numerical comparison use an absolute tolerance of $10^{-10}$. The program must output a single line containing a list of $5$ booleans, where each boolean is $ \\mathrm{True} $ if and only if all three quantities agree within the tolerance for the corresponding case, and $ \\mathrm{False} $ otherwise. The output must be a comma-separated list enclosed in square brackets, for example $[\\mathrm{True},\\mathrm{False},\\dots]$.\n\nAll computations are nondimensional; do not convert units. Angles are not involved. Express all computed values in the program as floating-point numbers. The final output must be exactly one line in the specified format with no additional characters.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the established theory of computational plasticity, well-posed with a unique solution for each case, and formulated with objective and precise language. All necessary data and definitions are provided.\n\nThe problem asks for the derivation and implementation of two equivalent solution procedures for uniaxial, rate-independent perfect plasticity: one based on variational minimization (Route A) and the other on the classical return mapping algorithm (Route B). Both routes aim to find the updated state variables $(\\sigma_{n+1}, \\varepsilon^p_{n+1}, \\alpha_{n+1})$ at time step $n+1$, given the state $(\\varepsilon^p_n, \\alpha_n)$ at step $n$ and a prescribed total strain $\\varepsilon_{n+1}$.\n\nFirst, we define the trial elastic stress, a crucial quantity for both routes. It is the stress that would be obtained if the entire strain increment from step $n$ to $n+1$ were purely elastic:\n$$\n\\sigma^{\\mathrm{tr}} = E (\\varepsilon_{n+1} - \\varepsilon^p_n)\n$$\nwhere $E$ is the Young's modulus.\n\n### Route A: Variational Incremental Minimization\n\nThe evolution is governed by the minimization of an incremental potential $\\Pi_{n+1}$ over the admissible internal variables $\\varepsilon^p_{n+1}$ and $\\alpha_{n+1}$. The potential is given as:\n$$\n\\Pi_{n+1}(\\varepsilon^p_{n+1},\\alpha_{n+1}) = \\tfrac{1}{2} E \\left( \\varepsilon_{n+1} - \\varepsilon^p_{n+1} \\right)^2 \\;+\\; R(\\varepsilon^p_{n+1} - \\varepsilon^p_n) \\;-\\; b\\, \\alpha_{n+1}\n$$\nwith the dissipation potential $R(\\Delta \\varepsilon^p) = \\sigma_Y \\lvert \\Delta \\varepsilon^p \\rvert$ and the yield stress $\\sigma_Y  0$. The evolution of the accumulated plastic strain is kinematically constrained by $\\alpha_{n+1} = \\alpha_n + \\lvert \\varepsilon^p_{n+1} - \\varepsilon^p_n \\rvert$.\n\nSubstituting the constraint and the definition of $R$ into $\\Pi_{n+1}$ allows us to eliminate $\\alpha_{n+1}$:\n$$\n\\Pi_{n+1}(\\varepsilon^p_{n+1}) = \\tfrac{1}{2} E \\left( \\varepsilon_{n+1} - \\varepsilon^p_{n+1} \\right)^2 \\;+\\; \\sigma_Y \\lvert \\varepsilon^p_{n+1} - \\varepsilon^p_n \\rvert \\;-\\; b (\\alpha_n + \\lvert \\varepsilon^p_{n+1} - \\varepsilon^p_n \\rvert)\n$$\n$$\n\\Pi_{n+1}(\\varepsilon^p_{n+1}) = \\tfrac{1}{2} E \\left( \\varepsilon_{n+1} - \\varepsilon^p_{n+1} \\right)^2 \\;+\\; (\\sigma_Y-b) \\lvert \\varepsilon^p_{n+1} - \\varepsilon^p_n \\rvert - b \\alpha_n\n$$\nThe term $-b \\alpha_n$ is constant with respect to the minimization variable $\\varepsilon^p_{n+1}$ and can be dropped. The problem specifies $b=0$ for perfect plasticity, simplifying the potential to:\n$$\n\\Pi_{n+รกรก1}(\\varepsilon^p_{n+1}) = \\tfrac{1}{2} E \\left( \\varepsilon_{n+1} - \\varepsilon^p_{n+1} \\right)^2 \\;+\\; \\sigma_Y \\lvert \\varepsilon^p_{n+1} - \\varepsilon^p_n \\rvert\n$$\nWe define the plastic strain increment $\\Delta \\varepsilon^p = \\varepsilon^p_{n+1} - \\varepsilon^p_n$. The potential can then be written as a function of this single scalar variable:\n$$\n\\Pi_{n+1}(\\Delta \\varepsilon^p) = \\tfrac{1}{2} E \\left( (\\varepsilon_{n+1} - \\varepsilon^p_n) - \\Delta \\varepsilon^p \\right)^2 \\;+\\; \\sigma_Y \\lvert \\Delta \\varepsilon^p \\rvert\n$$\nUsing the definition of the trial stress $\\sigma^{\\mathrm{tr}} = E(\\varepsilon_{n+1} - \\varepsilon^p_n)$, this becomes:\n$$\n\\Pi_{n+1}(\\Delta \\varepsilon^p) = \\tfrac{1}{2} E \\left( \\frac{\\sigma^{\\mathrm{tr}}}{E} - \\Delta \\varepsilon^p \\right)^2 \\;+\\; \\sigma_Y \\lvert \\Delta \\varepsilon^p \\rvert = \\frac{(\\sigma^{\\mathrm{tr}})^2}{2E} - \\sigma^{\\mathrm{tr}} \\Delta \\varepsilon^p + \\frac{1}{2}E(\\Delta \\varepsilon^p)^2 + \\sigma_Y \\lvert \\Delta \\varepsilon^p \\rvert\n$$\nDropping the constant term $\\frac{(\\sigma^{\\mathrm{tr}})^2}{2E}$, the reduced scalar convex minimization problem is to find $\\Delta \\varepsilon^p$ that minimizes:\n$$\n\\Psi(\\Delta \\varepsilon^p) = \\frac{1}{2}E(\\Delta \\varepsilon^p)^2 - \\sigma^{\\mathrm{tr}} \\Delta \\varepsilon^p + \\sigma_Y \\lvert \\Delta \\varepsilon^p \\rvert\n$$\nThis function is convex but non-differentiable at $\\Delta \\varepsilon^p=0$. The optimality condition is found using subdifferential calculus, which requires $0 \\in \\partial \\Psi(\\Delta \\varepsilon^p)$, where $\\partial \\Psi$ is the subdifferential:\n$$\n\\partial \\Psi(\\Delta \\varepsilon^p) = E \\Delta \\varepsilon^p - \\sigma^{\\mathrm{tr}} + \\sigma_Y \\, \\mathrm{sgn}(\\Delta \\varepsilon^p)\n$$\nHere, $\\mathrm{sgn}(0)$ is the interval $[-1, 1]$. We analyze the optimality condition $0 \\in E \\Delta \\varepsilon^p - \\sigma^{\\mathrm{tr}} + \\sigma_Y \\, \\mathrm{sgn}(\\Delta \\varepsilon^p)$:\n\n1.  If we hypothesize an elastic step, $\\Delta \\varepsilon^p = 0$. The condition becomes $0 \\in -\\sigma^{\\mathrm{tr}} + \\sigma_Y [-1, 1]$, which is equivalent to $-\\sigma_Y \\le -\\sigma^{\\mathrm{tr}} \\le \\sigma_Y$, or $|\\sigma^{\\mathrm{tr}}| \\le \\sigma_Y$. If the trial stress is within the yield limits, the optimal solution is indeed $\\Delta \\varepsilon^p = 0$.\n\n2.  If we hypothesize a plastic step with $\\Delta \\varepsilon^p  0$, then $\\mathrm{sgn}(\\Delta \\varepsilon^p)=1$. The optimality condition becomes a standard equation: $E \\Delta \\varepsilon^p - \\sigma^{\\mathrm{tr}} + \\sigma_Y = 0$. This gives $\\Delta \\varepsilon^p = \\frac{\\sigma^{\\mathrm{tr}} - \\sigma_Y}{E}$. This is consistent with the hypothesis $\\Delta \\varepsilon^p  0$ only if $\\sigma^{\\mathrm{tr}}  \\sigma_Y$.\n\n3.  If we hypothesize a plastic step with $\\Delta \\varepsilon^p  0$, then $\\mathrm{sgn}(\\Delta \\varepsilon^p)=-1$. The optimality condition is $E \\Delta \\varepsilon^p - \\sigma^{\\mathrm{tr}} - \\sigma_Y = 0$. This gives $\\Delta \\varepsilon^p = \\frac{\\sigma^{\\mathrm{tr}} + \\sigma_Y}{E}$. This is consistent with the hypothesis $\\Delta \\varepsilon^p  0$ only if $\\sigma^{\\mathrm{tr}}  -\\sigma_Y$.\n\nThese three cases cover all possibilities and demonstrate the threshold behavior. The sign of the trial stress $\\sigma^{\\mathrm{tr}}$ determines the direction of plastic flow: if $\\sigma^{\\mathrm{tr}}\\sigma_Y$, flow is positive; if $\\sigma^{\\mathrm{tr}}-\\sigma_Y$, flow is negative.\n\nThe algorithm for Route A is:\n1.  Compute trial stress: $\\sigma^{\\mathrm{tr}} = E(\\varepsilon_{n+1} - \\varepsilon^p_n)$.\n2.  Check yield condition: If $|\\sigma^{\\mathrm{tr}}| \\le \\sigma_Y$, the step is elastic. $\\Delta \\varepsilon^p = 0$.\n3.  If $|\\sigma^{\\mathrm{tr}}|  \\sigma_Y$, the step is plastic. The plastic increment is $\\Delta \\varepsilon^p = \\frac{\\sigma^{\\mathrm{tr}} - \\sigma_Y \\mathrm{sgn}(\\sigma^{\\mathrm{tr}})}{E}$.\n4.  Update variables:\n    $\\varepsilon^p_{n+1} = \\varepsilon^p_n + \\Delta \\varepsilon^p$\n    $\\alpha_{n+1} = \\alpha_n + |\\Delta \\varepsilon^p|$\n    $\\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^p_{n+1})$\n\n### Route B: Classical Return Mapping Algorithm\n\nThis is a standard algorithm composed of a trial step followed by a check and, if necessary, a plastic correction.\n\n1.  **Trial Step**: Assume the behavior is purely elastic. The trial state is:\n    $\\sigma^{\\mathrm{tr}} = E (\\varepsilon_{n+1} - \\varepsilon^p_n)$\n    $\\varepsilon^{p, \\mathrm{tr}}_{n+1} = \\varepsilon^p_n$\n    $\\alpha^{\\mathrm{tr}}_{n+1} = \\alpha_n$\n\n2.  **Yield Check**: Evaluate the yield function $f(\\sigma) = |\\sigma| - \\sigma_Y$ at the trial stress:\n    $f^{\\mathrm{tr}} = f(\\sigma^{\\mathrm{tr}}) = |\\sigma^{\\mathrm{tr}}| - \\sigma_Y$\n\n3.  **Branch Logic**:\n    a. If $f^{\\mathrm{tr}} \\le 0$: The trial state is admissible (elastic). The assumption was correct. The final state is the trial state: $(\\sigma_{n+1}, \\varepsilon^p_{n+1}, \\alpha_{n+1}) = (\\sigma^{\\mathrm{tr}}, \\varepsilon^p_n, \\alpha_n)$.\n    b. If $f^{\\mathrm{tr}}  0$: The trial state is inadmissible. Plastic flow occurs, and a correction is needed to \"return\" the stress to the yield surface.\n\n4.  **Plastic Correction (Return Mapping)**: The state at $n+1$ must satisfy the full set of plasticity equations:\n    - Elastic law: $\\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^p_{n+1})$\n    - Associative flow rule: $\\Delta \\varepsilon^p = \\varepsilon^p_{n+1} - \\varepsilon^p_n = \\Delta \\gamma \\, \\frac{\\partial f}{\\partial \\sigma}|_{\\sigma_{n+1}} = \\Delta \\gamma \\, \\mathrm{sgn}(\\sigma_{n+1})$\n    - Consistency condition: $f(\\sigma_{n+1}) = |\\sigma_{n+1}| - \\sigma_Y = 0$, which implies $|\\sigma_{n+1}| = \\sigma_Y$.\n\nThe plastic multiplier $\\Delta \\gamma \\ge 0$ is the unknown to be found. From the elastic law, we can write:\n$\\sigma_{n+1} = E(\\varepsilon_{n+1} - (\\varepsilon^p_n + \\Delta \\varepsilon^p)) = E(\\varepsilon_{n+1} - \\varepsilon^p_n) - E \\Delta \\varepsilon^p = \\sigma^{\\mathrm{tr}} - E \\Delta \\varepsilon^p$.\nSubstitute the flow rule: $\\sigma_{n+1} = \\sigma^{\\mathrm{tr}} - E \\Delta \\gamma \\, \\mathrm{sgn}(\\sigma_{n+1})$.\nThe projection of the stress state back to the yield surface implies that the direction of return is normal to the surface, hence $\\mathrm{sgn}(\\sigma_{n+1}) = \\mathrm{sgn}(\\sigma^{\\mathrm{tr}})$.\nSo, $\\sigma_{n+1} = \\sigma^{\\mathrm{tr}} - E \\Delta \\gamma \\, \\mathrm{sgn}(\\sigma^{\\mathrm{tr}})$.\nTaking the magnitude of both sides (and using $\\mathrm{sgn}(\\sigma_{n+1}) = \\mathrm{sgn}(\\sigma^{\\mathrm{tr}})$):\n$|\\sigma_{n+1}| = |\\sigma^{\\mathrm{tr}} - E \\Delta \\gamma \\, \\mathrm{sgn}(\\sigma^{\\mathrm{tr}})| = |\\mathrm{sgn}(\\sigma^{\\mathrm{tr}})(\\sigma^{\\mathrm{tr}}\\mathrm{sgn}(\\sigma^{\\mathrm{tr}}) - E \\Delta \\gamma)| = ||\\sigma^{\\mathrm{tr}}| - E \\Delta \\gamma|$.\nSince $|\\sigma^{\\mathrm{tr}}|  \\sigma_Y$ and intuitively the correction reduces the stress magnitude, we assume $|\\sigma^{\\mathrm{tr}}| - E \\Delta \\gamma \\ge 0$.\nUsing $|\\sigma_{n+1}|=\\sigma_Y$, we get $\\sigma_Y = |\\sigma^{\\mathrm{tr}}| - E \\Delta \\gamma$.\nSolving for the plastic multiplier:\n$$\n\\Delta \\gamma = \\frac{|\\sigma^{\\mathrm{tr}}| - \\sigma_Y}{E}\n$$\nSince $|\\sigma^{\\mathrm{tr}}|  \\sigma_Y$ and $E0$, we have $\\Delta \\gamma  0$, consistent with plastic flow. Note also that $|\\Delta \\varepsilon^p| = |\\Delta \\gamma \\, \\mathrm{sgn}(\\sigma_{n+1})| = \\Delta \\gamma$.\n\nThe updates are:\n- $\\Delta \\varepsilon^p = \\Delta \\gamma \\, \\mathrm{sgn}(\\sigma^{\\mathrm{tr}}) = \\frac{|\\sigma^{\\mathrm{tr}}| - \\sigma_Y}{E} \\mathrm{sgn}(\\sigma^{\\mathrm{tr}}) = \\frac{\\sigma^{\\mathrm{tr}} - \\sigma_Y \\mathrm{sgn}(\\sigma^{\\mathrm{tr}})}{E}$.\n- $\\varepsilon^p_{n+1} = \\varepsilon^p_n + \\Delta \\varepsilon^p$.\n- $\\alpha_{n+1} = \\alpha_n + \\Delta \\gamma = \\alpha_n + |\\Delta \\varepsilon^p|$.\n- $\\sigma_{n+1} = \\sigma_Y \\mathrm{sgn}(\\sigma^{\\mathrm{tr}})$.\n\n### Equivalence of the Two Routes\n\nComparing the final algorithms for Route A and Route B, we find that they are identical. Both begin with the calculation of a trial stress and use its magnitude relative to the yield stress $\\sigma_Y$ as a switch between elastic and plastic behavior. In the plastic case, the closed-form expressions for the plastic strain increment $\\Delta \\varepsilon^p$ and the final stress $\\sigma_{n+1}$ are exactly the same. The variational formulation provides a rigorous mathematical foundation based on energy principles for the classical, algorithmically-motivated return mapping procedure. Therefore, a correct implementation of both routes must yield numerically identical results for all test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a 1D perfect plasticity problem using two equivalent methods:\n    A) Variational incremental minimization\n    B) Classical return mapping algorithm\n    and compares their results for a suite of test cases.\n    \"\"\"\n\n    # Test suite: (E, sigma_Y, b, eps_np1, eps_p_n, alpha_n)\n    # b is the microforce coefficient, set to 0.0 for perfect plasticity.\n    test_cases = [\n        (200.0, 1.0, 0.0, 0.004, 0.0, 0.0),      # Case 1: Elastic loading\n        (200.0, 1.0, 0.0, 0.005, 0.0, 0.0),      # Case 2: Yield point\n        (200.0, 1.0, 0.0, 0.010, 0.0, 0.0),      # Case 3: Plastic loading\n        (200.0, 1.0, 0.0, 0.006, 0.005, 0.005),  # Case 4: Elastic unloading\n        (200.0, 1.0, 0.0, -0.010, 0.005, 0.005), # Case 5: Reverse plastic loading\n    ]\n\n    # Absolute tolerance for numerical comparison\n    tolerance = 1e-10\n\n    results_comparison = []\n\n    for case in test_cases:\n        E, sigma_Y, b, eps_np1, eps_p_n, alpha_n = case\n        \n        # Both routes start by computing the trial stress\n        sigma_tr = E * (eps_np1 - eps_p_n)\n        \n        # --- Route A: Variational Incremental Minimization ---\n        def solve_variational(E, sigma_Y, sigma_tr, eps_p_n, alpha_n):\n            # The minimization problem's solution depends on the trial stress\n            # It implies a threshold condition f_tr = |sigma_tr| - sigma_Y = 0\n            if abs(sigma_tr) = sigma_Y:\n                # Elastic step\n                delta_eps_p = 0.0\n            else:\n                # Plastic step\n                # The solution to min(Psi) is delta_eps_p = (sigma_tr - sigma_Y * sgn(sigma_tr)) / E\n                delta_eps_p = (sigma_tr - sigma_Y * np.sign(sigma_tr)) / E\n            \n            # Update variables\n            eps_p_np1 = eps_p_n + delta_eps_p\n            alpha_np1 = alpha_n + abs(delta_eps_p)\n            sigma_np1 = E * (eps_np1 - eps_p_np1)\n            \n            return sigma_np1, eps_p_np1, alpha_np1\n\n        # --- Route B: Classical Return Mapping Algorithm ---\n        def solve_return_map(E, sigma_Y, sigma_tr, eps_p_n, alpha_n):\n            # 1. Yield check\n            f_tr = abs(sigma_tr) - sigma_Y\n            \n            if f_tr = 0:\n                # Elastic step: final state is the trial state\n                sigma_np1 = sigma_tr\n                eps_p_np1 = eps_p_n\n                alpha_np1 = alpha_n\n            else:\n                # Plastic step: return mapping\n                # Calculate plastic multiplier (consistency parameter)\n                delta_gamma = (abs(sigma_tr) - sigma_Y) / E\n                \n                # Update plastic strain using associative flow rule\n                delta_eps_p = delta_gamma * np.sign(sigma_tr)\n                eps_p_np1 = eps_p_n + delta_eps_p\n                \n                # Update accumulated plastic strain\n                alpha_np1 = alpha_n + delta_gamma\n                \n                # Update stress (return to yield surface)\n                sigma_np1 = sigma_Y * np.sign(sigma_tr)\n\n            return sigma_np1, eps_p_np1, alpha_np1\n\n        # Compute results from both routes\n        res_A = solve_variational(E, sigma_Y, sigma_tr, eps_p_n, alpha_n)\n        res_B = solve_return_map(E, sigma_Y, sigma_tr, eps_p_n, alpha_n)\n        \n        # Compare the triplets (sigma_np1, eps_p_np1, alpha_np1)\n        # Using np.allclose with absolute tolerance, as relative tolerance is not\n        # suitable for values that can be zero (e.g., initial plastic strain).\n        is_close = np.allclose(res_A, res_B, rtol=0.0, atol=tolerance)\n        results_comparison.append(is_close)\n\n    # Format the final output string as specified\n    # The map(str, ...) converts Python's True/False to the required string format \"True\"/\"False\"\n    output_str = f\"[{','.join(map(str, results_comparison))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "When simulations involve large deformations and material rotation, the standard material time derivative of the Cauchy stress is no longer objective, meaning it yields frame-dependent results. This practice explores the critical concept of objective stress rates by comparing the predictions of hypoelastic models that use the Jaumann, Green-Naghdi, and Oldroyd rates under large shear and rotation . Through numerical implementation, you will investigate the phenomenon of spurious shear oscillationsโa well-known artifact of certain objective ratesโand develop a nuanced appreciation for the challenges of formulating constitutive laws in a large-strain context.",
            "id": "3439525",
            "problem": "Consider a three-dimensional, homogeneous, isotropic, incompressible hypoelastic solid. Let the deformation gradient be denoted by $F(t) \\in \\mathbb{R}^{3 \\times 3}$, the velocity gradient by $L(t) \\in \\mathbb{R}^{3 \\times 3}$, with $L(t) = \\dot{F}(t) F(t)^{-1}$. The symmetric part of the velocity gradient is the rate-of-deformation tensor $D(t) = \\frac{1}{2}\\left(L(t) + L(t)^{\\top}\\right)$, and the skew-symmetric part is the vorticity (spin) tensor $W(t) = \\frac{1}{2}\\left(L(t) - L(t)^{\\top}\\right)$. The Cauchy stress is denoted by $\\sigma(t)$, and the Kirchhoff stress by $\\tau(t) = J(t)\\,\\sigma(t)$, where $J(t) = \\det F(t)$. For incompressible motion in this setting, assume $J(t) = 1$ for all time. Let the shear response be governed by a linear isotropic hypoelastic relation with shear modulus $G  0$, such that the elastic stress rate is linear in $D(t)$.\n\nYour task is to compare the stress evolution predicted by three distinct objective stress rates under large-strain kinematics for designed loading paths that expose spurious shear oscillations:\n1. The Jaumann rate of the Cauchy stress, denoted $\\dot{\\sigma}^{\\text{Jaumann}}$.\n2. The GreenโNaghdi rate of the Cauchy stress, denoted $\\dot{\\sigma}^{\\text{Green\\text{-}Naghdi}}$, where the spin is associated with the material rotation from the polar decomposition $F(t) = R(t) U(t)$, with $R(t)$ a proper orthogonal rotation and $U(t)$ the right stretch.\n3. The Upper-Convected Oldroyd rate of the Kirchhoff stress, denoted $\\dot{\\tau}^{\\text{Oldroyd}}$, noting that $\\tau(t) = \\sigma(t)$ here due to incompressibility.\n\nStarting only from kinematics and linear hypoelasticity (no specific shortcut constitutive formulas are to be assumed a priori), derive implementable time-continuous evolution equations for the three objective rates and discretize them into a stable explicit time-stepping algorithm. The GreenโNaghdi spin should be built from the material rotation $R(t)$ obtained via polar decomposition, using a numerically sound approximation of $\\dot{R}(t) R(t)^{\\top}$ consistent with small time steps.\n\nDesign the velocity gradient $L(t)$ to include the following scientifically plausible loading paths (all in plane strain with the $x_3$-direction unaffected), expressed in terms of a prescribed shear rate $\\dot{\\gamma}(t)$ and an optional superposed rigid-body rotation with angular speed $\\omega(t)$:\n- Simple shear component:\n$$\nL_{\\text{shear}}(t) = \\begin{bmatrix}\n0  \\dot{\\gamma}(t)  0\\\\\n0  0  0\\\\\n0  0  0\n\\end{bmatrix},\n\\quad\nD_{\\text{shear}}(t) = \\frac{1}{2}\\begin{bmatrix}\n0  \\dot{\\gamma}(t)  0\\\\\n\\dot{\\gamma}(t)  0  0\\\\\n0  0  0\n\\end{bmatrix},\n\\quad\nW_{\\text{shear}}(t) = \\frac{1}{2}\\begin{bmatrix}\n0  \\dot{\\gamma}(t)  0\\\\\n-\\dot{\\gamma}(t)  0  0\\\\\n0  0  0\n\\end{bmatrix}.\n$$\n- Rigid rotation component (about $x_3$):\n$$\nW_{\\text{rot}}(t) = \\begin{bmatrix}\n0  \\omega(t)  0\\\\\n-\\omega(t)  0  0\\\\\n0  0  0\n\\end{bmatrix}.\n$$\n- Total velocity gradient:\n$$\nL(t) = L_{\\text{shear}}(t) + W_{\\text{rot}}(t).\n$$\n\nAssume $G = 80\\times 10^{9}\\ \\text{Pa}$ (Pascals), time in seconds, and rates in $\\text{s}^{-1}$. Initialize $F(0) = I$ (the identity) and $\\sigma(0) = 0$. Numerically integrate the following three test cases, using a uniform time step $\\Delta t$ sufficiently small to resolve the dynamics and maintain numerical stability:\n\n- Test Case 1 (baseline monotonic simple shear): $\\dot{\\gamma}(t) = 1$ for $t \\in [0,1]$ and $\\omega(t) = 0$; total duration $T = 1\\ \\text{s}$.\n- Test Case 2 (simple shear with superposed oscillatory rigid rotation): $\\dot{\\gamma}(t) = 2$ for $t \\in [0,1]$; $\\omega(t) = 10 \\sin(8 t)$; total duration $T = 1\\ \\text{s}$.\n- Test Case 3 (alternating shear direction, no rigid rotation): $\\dot{\\gamma}(t) = 5 \\sin(2\\pi t)$ for $t \\in [0,2]$; $\\omega(t) = 0$; total duration $T = 2\\ \\text{s}$.\n\nAt each time step, update $F(t)$ with $\\dot{F}(t) = L(t) F(t)$. For the GreenโNaghdi rate, obtain $R(t)$ from the polar decomposition $F(t) = R(t) U(t)$, with $U(t)$ symmetric positive definite given by $U(t) = \\sqrt{F(t)^{\\top} F(t)}$, and approximate the material spin as $\\Omega(t) \\approx \\dot{R}(t) R(t)^{\\top}$ using a consistent finite-difference approximation valid for small $\\Delta t$.\n\nDefine the shear stress time series as $\\sigma_{12}(t)$ for each objective rate. To quantify spurious shear oscillations, define the oscillation index as the number of strict interior local extrema in $\\sigma_{12}(t)$ over the full time interval (excluding endpoints). In practice, compute the discrete first difference of $\\sigma_{12}(t)$ over the time steps, and count sign changes of this discrete derivative after ignoring any exact zeros.\n\nYour program must:\n- Implement the three objective stress-rate integrations coupled to the evolving kinematics.\n- Produce the oscillation indices for each of the three objective rates in each of the test cases.\n- Use the units consistently as specified (stress in Pascals, time in seconds, rates in $\\text{s}^{-1}$).\n\nFinal output format:\nYour program should produce a single line of output containing nine integers, corresponding to the oscillation indices in the order\n$$\n[\\text{Case 1 Jaumann}, \\text{Case 1 GreenโNaghdi}, \\text{Case 1 Oldroyd}, \\text{Case 2 Jaumann}, \\text{Case 2 GreenโNaghdi}, \\text{Case 2 Oldroyd}, \\text{Case 3 Jaumann}, \\text{Case 3 GreenโNaghdi}, \\text{Case 3 Oldroyd}],\n$$\nenclosed in square brackets and separated by commas, for example, $[\\dots]$.",
            "solution": "The problem posed is a well-defined exercise in computational continuum mechanics, requiring the numerical integration of constitutive equations for a hypoelastic solid under large-strain kinematics. The objective is to compare three different objective stress rates by simulating their responses to specific loading paths and quantifying a known artifactโspurious shear oscillations.\n\nThe problem is scientifically grounded, internally consistent, and provides all necessary information for a unique numerical solution. The physical parameters, initial conditions, and loading scenarios are clearly specified. The task is to derive the governing equations, discretize them, and implement a numerical solution. The problem is therefore deemed **valid**.\n\nOur approach will be to first establish the time-continuous ordinary differential equations (ODEs) for the stress tensor components based on the three specified objective rates. We will then discretize these ODEs using an explicit forward Euler scheme, which is suitable for the small time steps mandated by the problem. The kinematic quantities, including the deformation gradient $F(t)$, will be updated concurrently. For the GreenโNaghdi rate, the material spin $\\Omega(t)$ will be computed from the polar decomposition of $F(t)$, as specified. Finally, we will implement this numerical scheme to simulate the three test cases and calculate the oscillation index for the shear stress component $\\sigma_{12}(t)$ for each model.\n\nLet us define the constitutive relation. For a linear, isotropic, incompressible hypoelastic material, the objective rate of the Kirchhoff stress, $\\overset{\\triangledown}{\\tau}$, is linearly proportional to the rate-of-deformation tensor, $D$. Given incompressibility ($J=1$), the Kirchhoff stress $\\tau$ is equal to the Cauchy stress $\\sigma$. The constitutive relation is thus:\n$$\n\\overset{\\circ}{\\sigma} = 2 G D\n$$\nwhere $\\overset{\\circ}{\\sigma}$ represents the chosen objective stress rate and $G$ is the shear modulus. The stress and rate-of-deformation tensors are deviatoric, which is consistent with the plane strain simple shear kinematics where $\\text{tr}(D) = 0$.\n\nThe velocity gradient $L(t)$ is given by:\n$$\nL(t) = \\begin{bmatrix} 0  \\dot{\\gamma}(t) + \\omega(t)  0 \\\\ -\\omega(t)  0  0 \\\\ 0  0  0 \\end{bmatrix}\n$$\nFrom this, we derive the rate-of-deformation tensor $D(t)$ and the vorticity (spin) tensor $W(t)$:\n$$\nD(t) = \\frac{1}{2}(L(t) + L(t)^\\top) = \\begin{bmatrix} 0  \\frac{1}{2}\\dot{\\gamma}(t)  0 \\\\ \\frac{1}{2}\\dot{\\gamma}(t)  0  0 \\\\ 0  0  0 \\end{bmatrix}\n$$\n$$\nW(t) = \\frac{1}{2}(L(t) - L(t)^\\top) = \\begin{bmatrix} 0  \\frac{1}{2}\\dot{\\gamma}(t) + \\omega(t)  0 \\\\ -(\\frac{1}{2}\\dot{\\gamma}(t) + \\omega(t))  0  0 \\\\ 0  0  0 \\end{bmatrix}\n$$\nSince the problem is one of plane strain, all computations can be performed on $2 \\times 2$ matrices, representing the behavior in the $x_1-x_2$ plane.\n\nThe material time derivative of the stress tensor, $\\dot{\\sigma}$, is obtained by rearranging the definition of each objective rate, $\\overset{\\circ}{\\sigma} = \\dot{\\sigma} - (\\text{spin terms})$. This gives $\\dot{\\sigma} = \\overset{\\circ}{\\sigma} + (\\text{spin terms}) = 2GD + (\\text{spin terms})$.\n\n1.  **Jaumann Rate**: The spin is $W(t)$.\n    $\\dot{\\sigma}^{\\text{Jaumann}} = \\dot{\\sigma} - W \\sigma + \\sigma W$.\n    The ODE for stress evolution is:\n    $$ \\dot{\\sigma} = 2 G D + W \\sigma - \\sigma W $$\n\n2.  **Upper-Convected (Oldroyd) Rate**: This rate is defined for the Kirchhoff stress as $\\dot{\\tau}^{\\text{Oldroyd}} = \\dot{\\tau} - L \\tau - \\tau L^\\top$. With $\\tau=\\sigma$, we have:\n    $$ \\dot{\\sigma} = 2 G D + L \\sigma + \\sigma L^\\top $$\n\n3.  **GreenโNaghdi Rate**: The spin is the material spin $\\Omega(t) = \\dot{R}(t)R(t)^\\top$, where $R(t)$ is the rotation tensor from the polar decomposition $F(t) = R(t)U(t)$.\n    $\\dot{\\sigma}^{\\text{Green-Naghdi}} = \\dot{\\sigma} - \\Omega \\sigma + \\sigma \\Omega$.\n    The ODE for stress evolution is:\n    $$ \\dot{\\sigma} = 2 G D + \\Omega \\sigma - \\sigma \\Omega $$\n\nWe will discretize these ODEs in time using a forward Euler method with a small time step $\\Delta t$. Let $\\sigma_n$ be the stress at time $t_n = n \\Delta t$. The stress at the next step is $\\sigma_{n+1} = \\sigma_n + \\Delta t \\cdot \\dot{\\sigma}_n$.\n\nThe kinematics are evolved by integrating $\\dot{F}(t) = L(t)F(t)$. A forward Euler update gives:\n$$ F_{n+1} = F_n + \\Delta t \\, (L_n F_n) = (I + \\Delta t \\, L_n) F_n $$\nwhere $F_n = F(t_n)$ and $L_n = L(t_n)$.\n\nFor the GreenโNaghdi rate, the spin $\\Omega_n$ at time $t_n$ is required. We approximate this using a finite difference on the rotation tensor $R$. We first compute $F_n$ and $F_{n+1}$ using the kinematic update. Then, we perform polar decompositions $F_n = R_n U_n$ and $F_{n+1} = R_{n+1} U_{n+1}$. The incremental rotation is $\\Delta R = R_{n+1} R_n^\\top$. For small $\\Delta t$, we have $\\Delta R \\approx I + \\Delta t \\, \\Omega_n$. To ensure $\\Omega_n$ is skew-symmetric, we take the skew-symmetric part of the approximation:\n$$ \\Omega_n \\approx \\frac{1}{\\Delta t} \\text{skew}(\\Delta R) = \\frac{1}{2\\Delta t}(\\Delta R - \\Delta R^\\top) $$\n\nThe algorithm proceeds as follows for each test case:\n1.  Initialize $F_0 = I$, $\\sigma_0^{\\text{Jaumann}} = \\sigma_0^{\\text{Oldroyd}} = \\sigma_0^{\\text{GN}} = 0$.\n2.  Choose a sufficiently small time step, e.g., $\\Delta t = 10^{-4} \\text{ s}$.\n3.  Iterate from $n=0$ to $N-1$, where $N=T/\\Delta t$:\n    a. Calculate $t_n = n \\Delta t$ and evaluate $\\dot{\\gamma}(t_n)$ and $\\omega(t_n)$.\n    b. Construct the $2 \\times 2$ matrices $L_n$, $D_n$, and $W_n$.\n    c. Update $F_{n+1} = (I + \\Delta t \\, L_n) F_n$.\n    d. For the Jaumann rate, compute $\\dot{\\sigma}_n = 2GD_n + W_n\\sigma_n - \\sigma_n W_n$ and update $\\sigma_{n+1} = \\sigma_n + \\Delta t \\dot{\\sigma}_n$.\n    e. For the Oldroyd rate, compute $\\dot{\\sigma}_n = 2GD_n + L_n\\sigma_n + \\sigma_n L_n^\\top$ and update $\\sigma_{n+1} = \\sigma_n + \\Delta t \\dot{\\sigma}_n$.\n    f. For the GreenโNaghdi rate:\n        i. Perform polar decompositions to find $R_n$ from $F_n$ and $R_{n+1}$ from $F_{n+1}$.\n        ii. Compute $\\Omega_n = \\frac{1}{2\\Delta t}(R_{n+1}R_n^\\top - (R_{n+1}R_n^\\top)^\\top)$.\n        iii. Compute $\\dot{\\sigma}_n = 2GD_n + \\Omega_n\\sigma_n - \\sigma_n \\Omega_n$ and update $\\sigma_{n+1} = \\sigma_n + \\Delta t \\dot{\\sigma}_n$.\n    g. Store the shear stress component $\\sigma_{12}$ for each of the three models.\n4.  After the loop, for each of the three time series of $\\sigma_{12}(t)$, compute the oscillation index by counting the number of sign changes in the sequence of first differences, ignoring zero-valued differences. This counts the number of strict interior local extrema.\n\nThis procedure is implemented for each of the three test cases, and the nine resulting oscillation indices are collected and formatted as per the problem specification.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import polar\n\ndef solve():\n    \"\"\"\n    Solves the computational materials science problem by simulating stress evolution\n    for three objective rates under three different loading scenarios.\n    \"\"\"\n\n    def count_extrema(series):\n        \"\"\"\n        Calculates the oscillation index by counting strict interior local extrema.\n        This is done by counting sign changes in the discrete first difference of the series.\n        \"\"\"\n        diff = np.diff(series)\n        diff_no_zeros = diff[diff != 0]\n        if len(diff_no_zeros)  2:\n            return 0\n        signs = np.sign(diff_no_zeros)\n        sign_changes = np.diff(signs)\n        return np.count_nonzero(sign_changes)\n\n    def run_simulation(case_params):\n        \"\"\"\n        Runs a single simulation for a given test case.\n\n        Args:\n            case_params (dict): A dictionary containing parameters for the test case:\n                - gamma_dot_func (callable): Function for shear rate vs. time.\n                - omega_func (callable): Function for angular speed vs. time.\n                - T (float): Total simulation time.\n                - G (float): Shear modulus.\n                - dt (float): Time step.\n\n        Returns:\n            tuple: A tuple of three integers, representing the oscillation indices for\n                   the Jaumann, Green-Naghdi, and Oldroyd rates, respectively.\n        \"\"\"\n        # Extract parameters\n        gamma_dot_func = case_params['gamma_dot_func']\n        omega_func = case_params['omega_func']\n        T = case_params['T']\n        G = case_params['G']\n        dt = case_params['dt']\n        \n        num_steps = int(T / dt)\n        \n        # Initial conditions (2D)\n        F = np.identity(2)\n        sigma_j = np.zeros((2, 2))\n        sigma_gn = np.zeros((2, 2))\n        sigma_o = np.zeros((2, 2))\n\n        # History storage for sigma_12\n        history_sigma12_j = np.zeros(num_steps + 1)\n        history_sigma12_gn = np.zeros(num_steps + 1)\n        history_sigma12_o = np.zeros(num_steps + 1)\n\n        # Store initial values\n        history_sigma12_j[0] = sigma_j[0, 1]\n        history_sigma12_gn[0] = sigma_gn[0, 1]\n        history_sigma12_o[0] = sigma_o[0, 1]\n        \n        # Time integration loop\n        for i in range(num_steps):\n            t = i * dt\n            \n            # Kinematic-related tensors at time t_i\n            gamma_dot = gamma_dot_func(t)\n            omega = omega_func(t)\n            \n            L = np.array([[0, gamma_dot + omega], [-omega, 0]])\n            D = 0.5 * (L + L.T)\n            W = 0.5 * (L - L.T)\n            \n            # --- Stress updates ---\n            \n            # 1. Jaumann rate\n            dot_sigma_j = 2 * G * D + (W @ sigma_j - sigma_j @ W)\n            sigma_j_next = sigma_j + dt * dot_sigma_j\n            \n            # 2. Oldroyd rate\n            dot_sigma_o = 2 * G * D + (L @ sigma_o + sigma_o @ L.T)\n            sigma_o_next = sigma_o + dt * dot_sigma_o\n            \n            # 3. Green-Naghdi rate\n            # Kinematic update for F\n            F_next = (np.identity(2) + dt * L) @ F\n            \n            # Polar decomposition at n and n+1\n            R, _ = polar(F, side='left')\n            R_next, _ = polar(F_next, side='left')\n\n            # Calculate material spin Omega\n            delta_R = R_next @ R.T\n            Omega = (1.0 / (2.0 * dt)) * (delta_R - delta_R.T)\n            \n            dot_sigma_gn = 2 * G * D + (Omega @ sigma_gn - sigma_gn @ Omega)\n            sigma_gn_next = sigma_gn + dt * dot_sigma_gn\n            \n            # Update state variables for next step\n            sigma_j = sigma_j_next\n            sigma_gn = sigma_gn_next\n            sigma_o = sigma_o_next\n            F = F_next\n            \n            # Store results\n            history_sigma12_j[i + 1] = sigma_j[0, 1]\n            history_sigma12_gn[i + 1] = sigma_gn[0, 1]\n            history_sigma12_o[i + 1] = sigma_o[0, 1]\n\n        # Calculate oscillation indices\n        idx_j = count_extrema(history_sigma12_j)\n        idx_gn = count_extrema(history_sigma12_gn)\n        idx_o = count_extrema(history_sigma12_o)\n        \n        return idx_j, idx_gn, idx_o\n\n    # Problem constants\n    G_val = 80e9\n    \n    # Test cases definition\n    test_cases = [\n        # Case 1: Monotonic simple shear\n        {\n            'gamma_dot_func': lambda t: 1.0,\n            'omega_func': lambda t: 0.0,\n            'T': 1.0,\n            'G': G_val,\n            'dt': 1e-4\n        },\n        # Case 2: Simple shear + oscillatory rigid rotation\n        {\n            'gamma_dot_func': lambda t: 2.0,\n            'omega_func': lambda t: 10.0 * np.sin(8.0 * t),\n            'T': 1.0,\n            'G': G_val,\n            'dt': 1e-4\n        },\n        # Case 3: Alternating shear\n        {\n            'gamma_dot_func': lambda t: 5.0 * np.sin(2 * np.pi * t),\n            'omega_func': lambda t: 0.0,\n            'T': 2.0,\n            'G': G_val,\n            'dt': 1e-4\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = run_simulation(case)\n        all_results.extend(results)\n\n    # Format the final output string\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\nsolve()\n\n```"
        }
    ]
}