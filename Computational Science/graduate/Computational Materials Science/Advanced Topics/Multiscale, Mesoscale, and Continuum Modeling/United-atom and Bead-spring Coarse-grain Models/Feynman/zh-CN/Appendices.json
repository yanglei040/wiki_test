{
    "hands_on_practices": [
        {
            "introduction": "粗粒化建模的一个核心问题是如何确定有效的相互作用势。迭代玻尔兹曼反转（Iterative Boltzmann Inversion, IBI）是一种强大的、基于结构的方法，旨在通过匹配目标径向分布函数 $g(r)$ 来推导势能。然而，一个能够精确再现结构的势能，不一定能同时再现正确的热力学性质（如压力），这是实现“多属性可表征性”时面临的常见挑战。本练习将指导您实现一个基本的IBI流程，并应用一种标准的压力校正方案，以亲身体验在保证结构准确性的同时，如何调整模型以匹配系统的热力学状态 。",
            "id": "3500714",
            "problem": "考虑一个单组分粗粒化流体，该流体可以代表一个联合原子（United-Atom）映射模型或一个珠簧（Bead-Spring）高分子模型，其中粗粒化位点之间的有效相互作用由球对称对势 $U(r)$ 表示。在本问题中，您将检验迭代玻尔兹曼反演（Iterative Boltzmann Inversion, IBI）能否同时再现径向分布函数 $g(r)$ 和热力学压力 $p$，并且您将实现一个形式为 $\\Delta U(r) \\propto r$ 的压力校正，以弥补任何不匹配。请在 Lennard-Jones 约化单位下进行计算：长度单位为 $\\sigma$，能量单位为 $\\varepsilon$，温度单位为 $\\varepsilon/k_B$，压力单位为 $\\varepsilon/\\sigma^3$。所有输出都必须以这些约化单位计算和报告。\n\n使用以下基本依据：\n- 正则系综中的统计力学给出了低密度闭合关系 $g(r) \\approx \\exp(-\\beta U(r))$，其中 $\\beta = 1/(k_B T)$，在约化单位中 $k_B = 1$。\n- 对于各向同性对势，维里定理给出的压力为\n$$\np = \\rho T - \\frac{2\\pi}{3} \\rho^2 \\int_0^{\\infty} g(r)\\, r^3 \\frac{dU(r)}{dr}\\, dr,\n$$\n其中 $\\rho$ 是数密度，$T$ 是温度。\n- Lennard-Jones (LJ) 势为 $U_{\\mathrm{LJ}}(r) = 4 \\varepsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6 \\right]$，其径向导数为 $\\frac{dU_{\\mathrm{LJ}}}{dr} = 4 \\varepsilon \\left[ -12 \\frac{\\sigma^{12}}{r^{13}} + 6 \\frac{\\sigma^6}{r^7} \\right]$。在约化单位中，取 $\\varepsilon=1$ 和 $\\sigma=1$。\n\n目标模型和可观测量：\n- 定义一个截断并移位的目标势 $U_{\\mathrm{true}}(r)$，当 $r \\le r_c^{\\mathrm{true}}$ 时为 $U_{\\mathrm{true}}(r) = U_{\\mathrm{LJ}}(r) - U_{\\mathrm{LJ}}(r_c^{\\mathrm{true}})$，当 $r > r_c^{\\mathrm{true}}$ 时为 $U_{\\mathrm{true}}(r) = 0$。\n- 使用低密度闭合关系定义目标径向分布函数 $g_{\\mathrm{target}}(r) = \\exp(-\\beta U_{\\mathrm{true}}(r))$。\n- 使用包含 $U_{\\mathrm{true}}(r)$ 和 $g_{\\mathrm{target}}(r)$ 的维里表达式定义目标压力 $p_{\\mathrm{target}}$，积分上限为 $r_c^{\\mathrm{true}}$。\n\n仅IBI模型：\n- 通过在粗粒化截断域上使用低密度闭合关系精确匹配 $g(r)$，将区间 $[0, r_c^{\\mathrm{cg}}]$ 上的仅IBI粗粒化势定义为 $U_{\\mathrm{IBI}}(r) = -T \\ln g_{\\mathrm{target}}(r)$。\n- 使用维里表达式计算仅IBI的压力 $p_{\\mathrm{IBI}}$，积分上限为 $r_c^{\\mathrm{cg}}$。\n\n压力校正：\n- 对于 $r \\le r_c^{\\mathrm{cg}}$，实现一个线性压力校正 $\\Delta U(r) = a\\,r$；对于 $r > r_c^{\\mathrm{cg}}$，$\\Delta U(r) = 0$。在区间 $[0, r_c^{\\mathrm{cg}}]$ 上定义 $U_{\\mathrm{corr}}(r) = U_{\\mathrm{IBI}}(r) + a r$。\n- 使用维里恒等式选择 $a$，使得校正后的压力 $p_{\\mathrm{corr}}$ 与 $p_{\\mathrm{target}}$ 相匹配。在低密度闭合关系 $g(r) \\approx \\exp(-\\beta U(r))$ 下，并在粗粒化域内，线性校正使维里积分发生如下变化\n$$\n\\Delta p = -\\frac{2\\pi}{3} \\rho^2 a \\int_0^{r_c^{\\mathrm{cg}}} g(r)\\, r^3\\, dr,\n$$\n由此得到系数\n$$\na = -\\frac{p_{\\mathrm{target}} - p_{\\mathrm{IBI}}}{\\frac{2\\pi}{3} \\rho^2 \\int_0^{r_c^{\\mathrm{cg}}} g(r)\\, r^3\\, dr}。\n$$\n\n数值实现细节：\n- 将 $r$ 在从 $r_{\\min}$ 到相应截断值的均匀网格上进行离散化，其中 $r_{\\min} > 0$ 以避免 $r=0$ 处的奇点。使用 $r_{\\min} = 0.80$ 和足以确保稳定求积的网格尺寸。使用梯形法则来近似积分。\n- 在约化单位中，始终设置 $k_B = 1$。\n- 在任何出现 $g$ 的地方，都使用 $g(r) = \\exp(-\\beta U(r))$。\n\n评估指标：\n- 结构指标：计算模型和目标在 $[r_{\\min}, r_c^{\\mathrm{cg}}]$ 上 $g(r)$ 的均方根偏差\n$$\n\\mathrm{RMS}_g = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N \\left( g_{\\mathrm{model}}(r_i) - g_{\\mathrm{target}}(r_i) \\right)^2 },\n$$\n并要求 $\\mathrm{RMS}_g \\le 0.03$。\n- 压力指标：计算 $|p_{\\mathrm{model}} - p_{\\mathrm{target}}|$ 并要求其 $\\le 0.01$。\n- 对于仅IBI模型，$g_{\\mathrm{model}}(r)$ 在 $[r_{\\min}, r_c^{\\mathrm{cg}}]$ 上即为 $g_{\\mathrm{target}}(r)$；对于压力校正模型，$g_{\\mathrm{model}}(r) = \\exp(-\\beta U_{\\mathrm{corr}}(r))$。\n\n您的程序必须：\n- 对于每个测试用例，计算两个布尔值：一个表示仅IBI模型是否在容差范围内同时匹配 $g(r)$ 和 $p$，另一个表示压力校正模型是否在容差范围内同时匹配 $g(r)$ 和 $p$。\n- 将所有测试用例的布尔值汇总到一个扁平列表中，并按照下面指定的精确格式在一行中打印出来。\n\n测试套件和参数（全部为约化单位）：\n- 测试用例1（理想路径，截断不匹配）：$T = 1.0$, $\\rho = 0.2$, $r_c^{\\mathrm{true}} = 3.0$, $r_c^{\\mathrm{cg}} = 2.0$。\n- 测试用例2（边界情况，极低密度）：$T = 1.0$, $\\rho = 0.01$, $r_c^{\\mathrm{true}} = 3.0$, $r_c^{\\mathrm{cg}} = 2.0$。\n- 测试用例3（边缘情况，无截断不匹配）：$T = 1.0$, $\\rho = 0.2$, $r_c^{\\mathrm{true}} = 2.0$, $r_c^{\\mathrm{cg}} = 2.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个布尔结果，以逗号分隔并用方括号括起，顺序为 [用例1 仅IBI结果, 用例1 校正结果, 用例2 仅IBI结果, 用例2 校正结果, 用例3 仅IBI结果, 用例3 校正结果]。例如，[True,False,True,True,False,True]。",
            "solution": "该问题要求分析两种粗粒化策略——迭代玻尔兹曼反演（IBI）及其压力校正变体，以确定它们是否能同时再现目标系统的结构和压力。目标系统是一种流体，其粒子通过截断并移位的Lennard-Jones（LJ）势相互作用，其性质在低密度近似下确定，其中径向分布函数 $g(r)$ 由对势 $U(r)$ 的玻尔兹曼因子给出。\n\n分析在Lennard-Jones约化单位下进行，其中能量单位为 $\\varepsilon$，长度单位为 $\\sigma$，温度 $T$ 单位为 $\\varepsilon/k_B$，压力 $p$ 单位为 $\\varepsilon/\\sigma^3$。常数设置为 $\\varepsilon=1$、$\\sigma=1$，玻尔兹曼常数 $k_B=1$。因此，势、结构和温度之间的关系为 $g(r) \\approx \\exp(-U(r)/T)$。\n\n压力 $p$ 使用维里定理计算，该定理适用于球对称对势：\n$$\np = \\rho T - \\frac{2\\pi}{3} \\rho^2 \\int_0^{\\infty} g(r)\\, r^3 \\frac{dU(r)}{dr}\\, dr\n$$\n其中 $\\rho$ 是数密度。在数值上，为了避免 $r=0$ 处的奇点，积分使用梯形法则从最小距离 $r_{\\min} = 0.80$ 计算到相应的截断半径。\n\n每个测试用例的逐步过程如下：\n\n1.  **定义目标系统**：\n    基础的Lennard-Jones势是 $U_{\\mathrm{LJ}}(r) = 4(r^{-12} - r^{-6})$。\n    目标系统由一个具有截断半径 $r_c^{\\mathrm{true}}$ 的截断并移位的势 $U_{\\mathrm{true}}(r)$ 定义：\n    $$\n    U_{\\mathrm{true}}(r) = \\begin{cases} U_{\\mathrm{LJ}}(r) - U_{\\mathrm{LJ}}(r_c^{\\mathrm{true}})  \\text{if } r \\le r_c^{\\mathrm{true}} \\\\ 0  \\text{if } r > r_c^{\\mathrm{true}} \\end{cases}\n    $$\n    目标结构由低密度闭合关系给出，$g_{\\mathrm{target}}(r) = \\exp(-U_{\\mathrm{true}}(r)/T)$。\n    目标压力 $p_{\\mathrm{target}}$ 使用包含 $U_{\\mathrm{true}}(r)$ 和 $g_{\\mathrm{target}}(r)$ 的维里表达式计算，积分上限为 $r_c^{\\mathrm{true}}$。其导数 $\\frac{dU_{\\mathrm{true}}}{dr}$ 在 $r \\le r_c^{\\mathrm{true}}$ 时等于 $\\frac{dU_{\\mathrm{LJ}}}{dr}$，否则为0。\n\n2.  **分析仅IBI模型**：\n    IBI方法旨在再现目标结构 $g_{\\mathrm{target}}(r)$。在其最简单的非迭代形式中，势 $U_{\\mathrm{IBI}}(r)$ 是通过在粗粒化域 $[0, r_c^{\\mathrm{cg}}]$ 上反演玻尔兹曼关系得到的：\n    $$\n    U_{\\mathrm{IBI}}(r) = -T \\ln(g_{\\mathrm{target}}(r)) \\quad \\text{for } r \\le r_c^{\\mathrm{cg}}\n    $$\n    给定 $g_{\\mathrm{target}}(r) = \\exp(-U_{\\mathrm{true}}(r)/T)$，可得对于所有 $r \\le r_c^{\\mathrm{cg}}$，有 $U_{\\mathrm{IBI}}(r) = U_{\\mathrm{true}}(r)$。根据这种构造方式，IBI模型的径向分布函数 $g_{\\mathrm{IBI}}(r) = \\exp(-U_{\\mathrm{IBI}}(r)/T)$ 在域 $[0, r_c^{\\mathrm{cg}}]$ 上与 $g_{\\mathrm{target}}(r)$ 相同。因此，对于IBI模型，结构匹配指标 $\\mathrm{RMS}_g$ 恒为零。\n    IBI模型的压力 $p_{\\mathrm{IBI}}$ 使用包含 $U_{\\mathrm{IBI}}(r)$ 和 $g_{\\mathrm{IBI}}(r)$ 的维里定理计算，积分上限为粗粒化截断半径 $r_c^{\\mathrm{cg}}$。\n    如果 $|p_{\\mathrm{IBI}} - p_{\\mathrm{target}}| \\le 0.01$，则认为仅IBI模型是成功的。结构指标根据定义得到满足。\n\n3.  **分析压力校正模型**：\n    当 $p_{\\mathrm{IBI}}$ 与 $p_{\\mathrm{target}}$ 不匹配时，会向势中添加一个校正项。此处，对于 $r \\le r_c^{\\mathrm{cg}}$，使用线性校正 $\\Delta U(r) = a\\,r$。校正后的势为 $U_{\\mathrm{corr}}(r) = U_{\\mathrm{IBI}}(r) + a\\,r$。\n    系数 $a$ 通过近似所需的压力变化来确定。由 $\\Delta U(r)$ 引起的维里贡献的变化近似为 $\\Delta p \\approx -\\frac{2\\pi}{3} \\rho^2 \\int_0^{r_c^{\\mathrm{cg}}} g_{\\mathrm{target}}(r)\\, r^3 \\frac{d(\\Delta U(r))}{dr}\\, dr$。设 $\\Delta p = p_{\\mathrm{target}} - p_{\\mathrm{IBI}}$ 并使用 $\\frac{d(\\Delta U(r))}{dr} = a$，我们解出 $a$：\n    $$\n    a = -\\frac{p_{\\mathrm{target}} - p_{\\mathrm{IBI}}}{\\frac{2\\pi}{3} \\rho^2 \\int_0^{r_c^{\\mathrm{cg}}} g_{\\mathrm{target}}(r)\\, r^3\\, dr}\n    $$\n    这种一次性校正定义了新的势 $U_{\\mathrm{corr}}(r)$。相应的新结构是 $g_{\\mathrm{corr}}(r) = \\exp(-U_{\\mathrm{corr}}(r)/T)$。校正后的压力 $p_{\\mathrm{corr}}$ 使用包含 $U_{\\mathrm{corr}}(r)$ 和 $g_{\\mathrm{corr}}(r)$ 的维里定理计算，积分上限为 $r_c^{\\mathrm{cg}}$。\n    如果校正模型同时满足两个条件，则认为其是成功的：\n    a. 结构匹配：在域 $[r_{\\min}, r_c^{\\mathrm{cg}}]$ 上，$\\mathrm{RMS}_g = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N \\left( g_{\\mathrm{corr}}(r_i) - g_{\\mathrm{target}}(r_i) \\right)^2 } \\le 0.03$。\n    b. 压力匹配：$|p_{\\mathrm{corr}} - p_{\\mathrm{target}}| \\le 0.01$。\n\n此过程应用于每个测试用例，以生成所需的布尔评估结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import trapezoid\n\ndef solve():\n    \"\"\"\n    Solves the coarse-graining problem for the specified test cases.\n\n    This function implements the IBI and pressure-correction models for a coarse-grained\n    fluid. It evaluates whether each model can simultaneously reproduce the target\n    structure (radial distribution function) and pressure within given tolerances.\n    \"\"\"\n    \n    # Define problem constants and tolerances\n    r_min = 0.80\n    rms_g_tol = 0.03\n    p_tol = 0.01\n    \n    # In reduced units, epsilon, sigma, and k_B are 1.\n    epsilon = 1.0\n    sigma = 1.0\n    k_B = 1.0\n    \n    # Define a numerical grid. The maximum r_c_true is 3.0, so this range is sufficient.\n    num_points = 4001 # A fine grid for stable quadrature\n    r_grid = np.linspace(r_min, 3.0, num_points)\n\n    # Define the Lennard-Jones potential and its derivative in reduced units\n    def U_lj(r):\n        r_inv = sigma / r\n        r_inv6 = r_inv**6\n        return 4.0 * epsilon * (r_inv6**2 - r_inv6)\n\n    def dU_lj_dr(r):\n        r_inv = sigma / r\n        r_inv7 = r_inv**7\n        r_inv13 = r_inv**13\n        return 4.0 * epsilon * (-12.0 * r_inv13 / sigma + 6.0 * r_inv7 / sigma)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, ρ, r_c^true, r_c^cg)\n        (1.0, 0.2, 3.0, 2.0),\n        (1.0, 0.01, 3.0, 2.0),\n        (1.0, 0.2, 2.0, 2.0),\n    ]\n\n    results = []\n    \n    for T, rho, r_c_true, r_c_cg in test_cases:\n        beta = 1.0 / (k_B * T)\n        \n        # --- 1. Target Model Calculation ---\n        \n        # Define the truncated-and-shifted target potential U_true(r)\n        U_lj_at_rc_true = U_lj(r_c_true)\n        U_true = np.where(r_grid = r_c_true, U_lj(r_grid) - U_lj_at_rc_true, 0.0)\n        \n        # Define the target radial distribution function g_target(r)\n        g_target = np.exp(-beta * U_true)\n        \n        # Define the derivative of the target potential\n        dU_true_dr = np.where(r_grid = r_c_true, dU_lj_dr(r_grid), 0.0)\n        \n        # Calculate the target pressure p_target\n        integrand_target = g_target * r_grid**3 * dU_true_dr\n        mask_true = r_grid = r_c_true\n        integral_target = trapezoid(integrand_target[mask_true], r_grid[mask_true])\n        p_target = rho * T - (2.0 * np.pi / 3.0) * rho**2 * integral_target\n        \n        # --- 2. IBI-Only Model Calculation  Evaluation ---\n        \n        # By definition, U_ibi(r) = U_true(r) and g_ibi(r) = g_target(r) for r = r_c_cg.\n        # Thus, the RMS_g for the IBI-only model is 0 and always meets the criterion.\n        rms_g_ibi_ok = True\n        \n        # Calculate the IBI-only pressure p_ibi\n        dU_ibi_dr = np.where(r_grid = r_c_cg, dU_lj_dr(r_grid), 0.0)\n        mask_cg = r_grid = r_c_cg\n        integrand_ibi = g_target * r_grid**3 * dU_ibi_dr\n        integral_ibi = trapezoid(integrand_ibi[mask_cg], r_grid[mask_cg])\n        p_ibi = rho * T - (2.0 * np.pi / 3.0) * rho**2 * integral_ibi\n        \n        # Evaluate if p_ibi meets the pressure criterion\n        p_ibi_ok = abs(p_ibi - p_target) = p_tol\n        results.append(rms_g_ibi_ok and p_ibi_ok)\n\n        # --- 3. Pressure-Corrected Model Calculation  Evaluation ---\n        \n        # Calculate the pressure correction coefficient 'a'\n        p_diff = p_target - p_ibi\n        integrand_a_denom = g_target[mask_cg] * r_grid[mask_cg]**3\n        integral_a_denom = trapezoid(integrand_a_denom, r_grid[mask_cg])\n        \n        denom_const = (2.0 * np.pi / 3.0) * rho**2\n        if abs(denom_const * integral_a_denom)  1e-15:\n            a = 0.0\n        else:\n            a = -p_diff / (denom_const * integral_a_denom)\n            \n        # Define the corrected potential and its corresponding RDF\n        U_corr = np.where(mask_cg, U_true + a * r_grid, 0.0)\n        g_corr = np.exp(-beta * U_corr)\n        \n        # Evaluate structure metric for the corrected model\n        g_corr_on_cg = g_corr[mask_cg]\n        g_target_on_cg = g_target[mask_cg]\n        rms_g_corr = np.sqrt(np.mean((g_corr_on_cg - g_target_on_cg)**2))\n        rms_g_corr_ok = rms_g_corr = rms_g_tol\n        \n        # Evaluate pressure metric for the corrected model\n        dU_corr_dr = np.where(mask_cg, dU_lj_dr(r_grid) + a, 0.0)\n        integrand_corr = g_corr * r_grid**3 * dU_corr_dr\n        integral_corr = trapezoid(integrand_corr[mask_cg], r_grid[mask_cg])\n        p_corr = rho * T - (2.0 * np.pi / 3.0) * rho**2 * integral_corr\n        p_corr_ok = abs(p_corr - p_target) = p_tol\n        \n        results.append(rms_g_corr_ok and p_corr_ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当为粗粒化模型选定一个势函数形式（例如Lennard-Jones势）后，我们必须对其进行参数化。此练习探讨了这一过程中的一个关键环节：敏感性分析。通过本练习，您将学习如何计算一个可观测量（径向分布函数 $g(r)$）相对于模型参数（如 $\\varepsilon$ 和 $\\sigma$）的变化率，并揭示这些信息如何帮助我们判断参数是否可以从现有数据中被唯一地确定。这种“结构可辨识性”的概念对于构建稳健和可靠的计算模型至关重要 。",
            "id": "3500725",
            "problem": "给定一个用于简单流体的粗粒化联合原子（UA）模型，其中非键相互作用由一个在有限截断半径处截断且未移动的兰纳-琼斯（Lennard-Jones）对势表示。在经典液态理论的零密度近似中，径向分布函数（RDF）$g(r)$ 通过玻尔兹曼（Boltzmann）因子与对势 $u(r)$ 相关联。您的任务是针对模型参数对 $g(r)$ 进行局部敏感性分析，并确定在给定特定数据的情况下，哪些参数是结构上不可辨识的。所有工作均在约化的兰纳-琼斯单位下进行，并将所有计算视为无量纲的。\n\n基本原理：\n- 在零密度下，径向分布函数与对势之间的关系为 $g(r) = \\exp\\!\\left(-\\beta\\,u(r)\\right)$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$ 是逆热能，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。\n- 截断（未移动）的兰纳-琼斯势为\n$$\nu(r;\\,\\varepsilon,\\sigma,r_{\\mathrm{c}}) =\n\\begin{cases}\n4\\,\\varepsilon\\left[\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^{6}\\right],  \\text{if } r  r_{\\mathrm{c}},\\\\\n0,  \\text{if } r \\ge r_{\\mathrm{c}},\n\\end{cases}\n$$\n其参数 $\\theta = (\\varepsilon,\\sigma)$ 分别代表能量尺度 $\\varepsilon$ 和长度尺度 $\\sigma$，以及截断半径 $r_{\\mathrm{c}}$。\n- $g(r)$ 相对于参数 $\\theta_k$ 的局部敏感性定义为偏导数 $\\dfrac{\\partial g(r)}{\\partial \\theta_k}$，在指定的 $(\\varepsilon,\\sigma,\\beta,r_{\\mathrm{c}})$ 和 $r$ 值处计算。\n\n设计一个程序，对于每个提供的测试用例：\n1. 计算局部敏感性矩阵 $J \\in \\mathbb{R}^{N_r \\times N_\\theta}$，其元素为 $J_{ik} = \\left.\\dfrac{\\partial g(r_i)}{\\partial \\theta_k}\\right|_{\\theta}$，其中 $\\{r_i\\}$ 是提供的 $N_r$ 个径向距离，$\\theta = (\\varepsilon,\\sigma)$ 是 $N_\\theta = 2$ 个参数。\n2. 通过测试 $J$ 的列秩来评估参数的局部结构可辨识性。如果一个参数的敏感性列位于其他列的线性张成空间中，则该参数在给定数据下是结构上不可辨识的，这意味着失去了唯一的局部可估计性。您必须使用数值稳定的秩显方法来确定数值秩以及一个张成列空间的列子集。\n3. 对于每个测试用例，按升序返回结构上不可辨识参数的从零开始的索引列表。使用参数排序约定 $\\theta_0 = \\varepsilon$ 和 $\\theta_1 = \\sigma$。\n\n实现要求：\n- 仅使用基本原理。在需要时使用标准微积分（例如，链式法则），从上述定义中推导出 $\\dfrac{\\partial g(r)}{\\partial \\varepsilon}$ 和 $\\dfrac{\\partial g(r)}{\\partial \\sigma}$ 的表达式。\n- 将所有长度 $r$、$\\sigma$ 和 $r_{\\mathrm{c}}$ 视为以 $\\sigma$ 为单位的约化单位，并将能量尺度 $\\varepsilon$ 视为约化能量单位。使用每个测试用例提供的指定无量纲 $\\beta$ 值进行计算。输出是纯索引，因此是无单位的。\n- 对于秩的评估，请使用一个鲁棒的数值容差。通过奇异值确定数值秩，使用一个与最大奇异值和机器精度成比例的相对阈值。为了将不可辨识性归因于特定参数，请使用秩显列置换，并将在最大无关组之外的列报告为不可辨识。\n\n测试套件：\n对于下方的每个测试用例，模型参数为 $(\\varepsilon,\\sigma)$，逆热能为 $\\beta$，截断半径为 $r_{\\mathrm{c}}$，测量的对分离距离是 $r$ 值的列表。所有数值均为约化的无量纲单位。\n- 测试用例 1（通用覆盖范围，截断范围内的数据）：\n  - $(\\varepsilon,\\sigma) = (1.0, 1.0)$, $\\beta = 1.0$, $r_{\\mathrm{c}} = 2.5$, $r = [0.95, 1.00, 1.10, 1.50, 2.00, 2.49]$。\n- 测试用例 2（边界条件，所有数据均超出截断范围）：\n  - $(\\varepsilon,\\sigma) = (1.0, 1.0)$, $\\beta = 1.0$, $r_{\\mathrm{c}} = 2.5$, $r = [2.60, 3.00]$。\n- 测试用例 3（边缘情况，单点位于 $r = \\sigma$）：\n  - $(\\varepsilon,\\sigma) = (1.0, 1.0)$, $\\beta = 1.0$, $r_{\\mathrm{c}} = 2.5$, $r = [1.00]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，其本身是一个整数列表，按升序给出不可辨识参数的索引。例如，一个包含三个测试用例的有效总输出如下所示\n$[\\,[\\,]\\,,\\,[0,1]\\,,\\,[0]\\,]$,\n这意味着在第一种情况下没有参数是不可辨识的，在第二种情况下两个参数都是不可辨识的，在第三种情况下只有参数索引0是不可辨识的。\n\n您的输出必须与为所提供测试套件指定的结构完全匹配。",
            "solution": "问题陈述具有科学依据，提法恰当且客观。它提出了计算建模中的一个标准任务：局部敏感性和可辨识性分析。所有必要的物理关系、数学定义和数值数据都已提供并且内部一致。该问题是有效的，可以据此构建一个解决方案。\n\n问题的核心是通过分析可观测量——径向分布函数 $g(r)$ 对兰纳-琼斯（Lennard-Jones）参数变化的敏感性，来评估这些参数 $\\theta = (\\varepsilon, \\sigma)$ 的局部结构可辨识性。\n\n首先，我们建立敏感性的解析形式。在给定的逆温度 $\\beta = 1/(k_{\\mathrm{B}} T)$ 下，可观测量 $g(r)$ 通过零密度近似与对势 $u(r)$ 相关联：\n$$\ng(r) = \\exp(-\\beta\\,u(r))\n$$\n截断的兰纳-琼斯（LJ）势由以下公式给出：\n$$\nu(r; \\varepsilon, \\sigma, r_{\\mathrm{c}}) =\n\\begin{cases}\n4\\,\\varepsilon\\left[\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^{6}\\right],  \\text{if } r  r_{\\mathrm{c}} \\\\\n0,  \\text{if } r \\ge r_{\\mathrm{c}}\n\\end{cases}\n$$\n用于敏感性分析的参数是 $\\theta_0 = \\varepsilon$ 和 $\\theta_1 = \\sigma$。$g(r)$ 相对于参数 $\\theta_k$ 的局部敏感性是其偏导数 $\\frac{\\partial g(r)}{\\partial \\theta_k}$。使用链式法则，我们得到：\n$$\n\\frac{\\partial g(r)}{\\partial \\theta_k} = \\frac{\\partial}{\\partial \\theta_k} \\exp(-\\beta\\,u(r)) = \\exp(-\\beta\\,u(r)) \\cdot (-\\beta) \\frac{\\partial u(r)}{\\partial \\theta_k} = -\\beta\\,g(r)\\,\\frac{\\partial u(r)}{\\partial \\theta_k}\n$$\n现在我们必须推导势能 $u(r)$ 相对于 $\\varepsilon$ 和 $\\sigma$ 的偏导数。\n\n对于 $r \\ge r_{\\mathrm{c}}$，$u(r)=0$ 且不依赖于 $\\varepsilon$ 和 $\\sigma$。因此，对于 $r \\ge r_{\\mathrm{c}}$：\n$$\n\\frac{\\partial u(r)}{\\partial \\varepsilon} = 0 \\quad \\text{and} \\quad \\frac{\\partial u(r)}{\\partial \\sigma} = 0\n$$\n这意味着对于 $r \\ge r_{\\mathrm{c}}$，$\\frac{\\partial g(r)}{\\partial \\varepsilon} = 0$ 和 $\\frac{\\partial g(r)}{\\partial \\sigma} = 0$。\n\n对于 $r  r_{\\mathrm{c}}$，我们计算LJ表达式的导数。\n相对于能量参数 $\\varepsilon$ 的敏感性是：\n$$\n\\frac{\\partial u(r)}{\\partial \\varepsilon} = \\frac{\\partial}{\\partial \\varepsilon} \\left( 4\\,\\varepsilon\\left[\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^{6}\\right] \\right) = 4\\left[\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^{6}\\right] = \\frac{u(r)}{\\varepsilon}\n$$\n因此，$g(r)$ 相对于 $\\varepsilon$ 的敏感性是：\n$$\n\\frac{\\partial g(r)}{\\partial \\varepsilon} = -\\beta\\,g(r) \\frac{u(r)}{\\varepsilon}\n$$\n相对于长度参数 $\\sigma$ 的敏感性是：\n$$\n\\frac{\\partial u(r)}{\\partial \\sigma} = \\frac{\\partial}{\\partial \\sigma} \\left( 4\\,\\varepsilon\\left[ \\sigma^{12}r^{-12} - \\sigma^{6}r^{-6} \\right] \\right) = 4\\,\\varepsilon \\left[ 12\\sigma^{11}r^{-12} - 6\\sigma^{5}r^{-6} \\right]\n$$\n通过提取含 $\\sigma$ 的项，可以将其重写为：\n$$\n\\frac{\\partial u(r)}{\\partial \\sigma} = 4\\,\\varepsilon \\frac{6}{\\sigma} \\left[ 2\\frac{\\sigma^{12}}{r^{12}} - \\frac{\\sigma^{6}}{r^{6}} \\right] = \\frac{24\\varepsilon}{\\sigma}\\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]\n$$\n因此，$g(r)$ 相对于 $\\sigma$ 的敏感性是：\n$$\n\\frac{\\partial g(r)}{\\partial \\sigma} = -\\beta\\,g(r) \\left( \\frac{24\\varepsilon}{\\sigma}\\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right] \\right)\n$$\n敏感性矩阵（或雅可比矩阵）$J$ 是一个 $N_r \\times 2$ 的矩阵，其中 $N_r$ 是径向数据点的数量。其列是 $\\varepsilon$ 和 $\\sigma$ 的敏感性向量，在每个点 $r_i$ 处求值：\n$$\nJ = \\begin{pmatrix}\n\\frac{\\partial g(r_1)}{\\partial \\varepsilon}  \\frac{\\partial g(r_1)}{\\partial \\sigma} \\\\\n\\frac{\\partial g(r_2)}{\\partial \\varepsilon}  \\frac{\\partial g(r_2)}{\\partial \\sigma} \\\\\n\\vdots  \\vdots \\\\\n\\frac{\\partial g(r_{N_r})}{\\partial \\varepsilon}  \\frac{\\partial g(r_{N_r})}{\\partial \\sigma}\n\\end{pmatrix}\n$$\n当参数无法从可用数据的局部分析中唯一确定时，就会出现局部结构不可辨识性。在数学上，这对应于敏感性矩阵 $J$ 的列之间存在线性相关性。如果列是线性相关的，则 $J$ 的秩小于参数数量，即 $\\text{rank}(J)  N_\\theta = 2$。\n\n为了评估这一点，我们采用带列主元的秩显QR分解，这是一种数值稳健的方法。此分解将 $J$ 分解为 $J P = Q R$，其中 $P$ 是一个置换矩阵（由列索引向量 $p$ 表示），$Q$ 是一个正交矩阵，$R$ 是一个上梯形矩阵，其对角元素 $|R_{kk}|$ 是非递增的。置换 $p$ 会重新排列 $J$ 的列，将最线性无关的列移到前面。\n\n数值秩 $k$ 是 $R$ 的对角元素中明显大于零的元素数量。用于此检查的标准容差 $\\tau$ 是根据最大对角元素的大小和机器精度进行缩放的：$\\tau = |R_{00}| \\cdot \\max(N_r, N_\\theta) \\cdot \\epsilon_{\\text{machine}}$。秩是 $|R_{ii}| > \\tau$ 的计数。\n\n置换向量 $p$ 直接提供了可辨识性的信息。$p$ 中的前 $k$ 个索引，即 $p[0], \\dots, p[k-1]$，对应于构成最大线性无关集的参数。剩下的 $N_\\theta - k$ 个索引，$p[k], \\dots, p[N_\\theta-1]$，对应于其敏感性位于前 $k$ 个参数的线性张成空间中的参数。这些是结构上不可辨识的参数。最后一步是收集这些索引并按升序排序。\n\n每个测试用例的算法如下：\n1.  给定 $(\\varepsilon, \\sigma, \\beta, r_c)$ 和一组 $N_r$ 个径向点 $\\{r_i\\}$，构建 $N_r \\times 2$ 的敏感性矩阵 $J$。对于每个 $r_i$，使用推导出的表达式计算两个敏感性值，并检查是否 $r_i  r_c$。\n2.  对 $J$ 执行秩显QR分解，以获得 $R$ 和列置换向量 $p$。\n3.  通过计算超过定义容差的 $R$ 的对角元素数量，来确定 $J$ 的数值秩 $k$。\n4.  不可辨识参数的索引由 $p$ 的最后 $2-k$ 个元素给出。\n5.  对这些索引进行排序并返回结果列表。\n此过程应用于提供的三个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef solve():\n    \"\"\"\n    Performs local sensitivity and identifiability analysis for a truncated\n    Lennard-Jones potential model.\n    \"\"\"\n    # Test suite from the problem statement.\n    # Each case is a tuple: (epsilon, sigma, beta, r_cutoff, r_values_list)\n    test_cases = [\n        (1.0, 1.0, 1.0, 2.5, [0.95, 1.00, 1.10, 1.50, 2.00, 2.49]),\n        (1.0, 1.0, 1.0, 2.5, [2.60, 3.00]),\n        (1.0, 1.0, 1.0, 2.5, [1.00]),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        eps, sig, beta, r_c, r_values = case\n        \n        num_r = len(r_values)\n        num_params = 2  # Parameter ordering is [epsilon, sigma]\n\n        # If there are no data points, all parameters are unidentifiable.\n        if num_r == 0:\n            all_results.append([0, 1])\n            continue\n\n        # Initialize the sensitivity (Jacobian) matrix J\n        J = np.zeros((num_r, num_params))\n\n        for i, r in enumerate(r_values):\n            # The sensitivity is non-zero only if r is within the cutoff\n            if r  r_c:\n                # Avoid division by zero, though not present in test cases\n                if r == 0.0 or eps == 0.0 or sig == 0.0:\n                    J[i, :] = 0.0\n                    continue\n\n                # Calculate intermediate terms\n                # sr = sigma / r\n                sr = sig / r\n                # sr^6\n                sr6 = sr**6\n                # sr^12\n                sr12 = sr6**2\n                \n                # Calculate the LJ potential u(r)\n                u_val = 4.0 * eps * (sr12 - sr6)\n                \n                # Calculate the RDF g(r)\n                g_val = np.exp(-beta * u_val)\n                \n                # Sensitivity w.r.t. epsilon (parameter 0)\n                # d(u)/d(epsilon) = u / epsilon\n                du_deps = u_val / eps\n                dg_deps = -beta * g_val * du_deps\n                J[i, 0] = dg_deps\n                \n                # Sensitivity w.r.t. sigma (parameter 1)\n                # d(u)/d(sigma) = (24*eps/sig) * (2*sr^12 - sr^6)\n                du_dsig = (24.0 * eps / sig) * (2.0 * sr12 - sr6)\n                dg_dsig = -beta * g_val * du_dsig\n                J[i, 1] = dg_dsig\n\n            else: # r >= r_c\n                # Potential and its derivatives are zero\n                J[i, 0] = 0.0\n                J[i, 1] = 0.0\n\n        # Assess local structural identifiability using rank-revealing QR\n        if np.allclose(J, 0):\n            # If J is a zero matrix, its rank is 0. All params are unidentifiable.\n            rank = 0\n            # Permutation vector is just the original order.\n            p = np.arange(num_params)\n        else:\n            Q, R, p = qr(J, pivoting=True)\n            \n            # Determine numerical rank from the diagonal of R\n            diag_R = np.abs(np.diag(R))\n            \n            # Tolerance for rank determination, scaled by the largest diagonal\n            # element of R and machine precision.\n            tol = diag_R[0] * max(J.shape) * np.finfo(J.dtype).eps\n            \n            rank = np.sum(diag_R > tol)\n\n        # Indices of unidentifiable parameters are from the tail of the permutation vector\n        unidentifiable_indices = sorted(p[rank:])\n        all_results.append(unidentifiable_indices)\n\n    # Format the final output string as specified\n    output_str = '[' + ','.join([str(res) for res in all_results]) + ']'\n    output_str = output_str.replace(\" \", \"\") # Remove spaces for exact format match\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "粗粒化模拟的一个主要目标是高效地采样大尺度的构象变化，但我们最终的兴趣往往在于原子级别的细节。这就引入了“反向映射”（backmapping）问题：如何从粗粒化表征中恢复被省略的自由度。本练习将通过一个随机反向映射方法，探讨如何重建一个二面角，并展示这一过程如何引入结构性偏差。您将使用Kullback-Leibler散度来量化这种偏差，并探索它如何影响作为关键热力学量的自由能差的计算 。",
            "id": "3500691",
            "problem": "您的任务是形式化并量化从粗粒化珠簧表示到原子级或联合原子结构的随机反向映射如何在二面角分布中引入结构偏差，以及这种偏差如何影响预定义宏观态之间的自由能差。考虑一个由单位圆上的二面角 $\\varphi \\in [-\\pi,\\pi)$ 表示的单一扭转自由度。该系统有一个原子级（联合原子）目标扭转势 $U_{\\mathrm{AT}}(\\varphi)$ 和一个简化的粗粒化珠簧扭转势 $U_{\\mathrm{CG}}(\\varphi)$。随机反向映射通过一个包裹高斯核从粗粒化角度分布构建原子级二面角，从而引入一种可调的偏差。\n\n基本原理：\n- 在绝对温度 $T$ 下，扭转坐标的玻尔兹曼分布为 $p(\\varphi) = Z^{-1} \\exp(-\\beta U(\\varphi))$，其中 $\\beta = 1/(R T)$，$R$ 是理想气体常数，单位为 $\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$，$Z = \\int_{-\\pi}^{\\pi} \\exp(-\\beta U(\\varphi))\\,d\\varphi$ 是配分函数。\n- 一个宏观态 $M \\subset [-\\pi,\\pi)$ 的自由能为 $F_M = - R T \\ln Z_M$，其中 $Z_M = \\int_M p(\\varphi)\\,d\\varphi$，两个宏观态 $A$ 和 $B$ 之间的自由能差为 $\\Delta F = F_B - F_A = -R T \\ln\\left(\\dfrac{Z_B}{Z_A}\\right)$。\n- 圆上的随机反向映射核由一个包裹正态分布建模。对于给定的平均偏差 $b$ 和标准差 $\\sigma$，其核函数为\n$$\nW(\\Delta\\varphi; b, \\sigma) = \\sum_{k=-\\infty}^{\\infty} \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{(\\Delta\\varphi - b + 2\\pi k)^2}{2\\sigma^2}\\right),\n$$\n这确保了 $\\int_{-\\pi}^{\\pi} W(\\Delta\\varphi; b, \\sigma)\\,d\\Delta\\varphi = 1$。\n- 宏观态由角度区间定义：$A$ (顺式-类) 为 $\\{\\varphi: |\\varphi| \\le \\varphi_c\\}$，$B$ (反式-类) 为 $\\{\\varphi: \\min(|\\varphi - \\pi|, |\\varphi + \\pi|) \\le \\varphi_c\\}$。\n\n您的程序必须严格使用上述定义，并在 $[-\\pi,\\pi)$ 的均匀网格上通过数值积分实现以下内容：\n\n1. 构建原子级目标势\n$$\nU_{\\mathrm{AT}}(\\varphi) = k_1\\big(1 - \\cos\\varphi\\big) + k_3\\big(1 - \\cos(3\\varphi)\\big),\n$$\n以及粗粒化势\n$$\nU_{\\mathrm{CG}}(\\varphi) = k_{\\mathrm{CG}}\\big(1 - \\cos\\varphi\\big),\n$$\n其中所有 $k$ 参数的单位为 $\\mathrm{kJ\\,mol^{-1}}$。\n\n2. 在均匀网格上计算归一化的原子级扭转概率密度 $P_{\\mathrm{AT}}(\\varphi) \\propto \\exp(-\\beta U_{\\mathrm{AT}}(\\varphi))$ 和归一化的粗粒化扭转密度 $P_{\\mathrm{CG}}(\\varphi) \\propto \\exp(-\\beta U_{\\mathrm{CG}}(\\varphi))$。\n\n3. 在网格上定义包裹高斯核 $W(\\Delta\\varphi; b, \\sigma)$，并通过循环卷积计算随机反向映射（有偏）的原子级重构密度\n$$\nQ(\\varphi) = \\int_{-\\pi}^{\\pi} P_{\\mathrm{CG}}(\\psi)\\, W(\\varphi - \\psi; b, \\sigma)\\, d\\psi,\n$$\n并进行归一化，使得 $\\int_{-\\pi}^{\\pi} Q(\\varphi)\\,d\\varphi = 1$。\n\n4. 计算三种自由能差：\n   - 真实的原子级自由能差 $\\Delta F_{\\mathrm{true}} = -R T \\ln\\left(\\dfrac{\\int_B P_{\\mathrm{AT}}(\\varphi)\\,d\\varphi}{\\int_A P_{\\mathrm{AT}}(\\varphi)\\,d\\varphi}\\right)$。\n   - 从有偏重构中测得的自由能差 $\\Delta F_{\\mathrm{meas}} = -R T \\ln\\left(\\dfrac{\\int_B Q(\\varphi)\\,d\\varphi}{\\int_A Q(\\varphi)\\,d\\varphi}\\right)$。\n   - 一个使用原子级与粗粒化玻尔兹曼权重之比的近似重加权估计，\n$$\nw(\\varphi) = \\frac{P_{\\mathrm{AT}}(\\varphi)}{P_{\\mathrm{CG}}(\\varphi)},\n$$\n定义为\n$$\n\\Delta F_{\\mathrm{rw}} = -R T \\ln\\left(\\dfrac{\\int_B w(\\varphi)\\, Q(\\varphi)\\, d\\varphi}{\\int_A w(\\varphi)\\, Q(\\varphi)\\, d\\varphi}\\right).\n$$\n\n5. 使用 Kullback–Leibler 散度（相对熵）量化结构偏差\n$$\nD_{\\mathrm{KL}}\\big(Q\\Vert P_{\\mathrm{AT}}\\big) = \\int_{-\\pi}^{\\pi} Q(\\varphi)\\, \\ln\\left(\\frac{Q(\\varphi)}{P_{\\mathrm{AT}}(\\varphi)}\\right)\\, d\\varphi.\n$$\n\n实现说明：\n- 在 $[-\\pi,\\pi)$ 上使用一个均匀的 $N$ 点网格，并保证 $N$ 足够大以精确解析积分；使用等效于均匀网格上黎曼和的梯形法则。循环卷积必须遵守周期性边界条件；为了效率，可通过离散傅里叶变换或直接循环求和来实现。确保所有密度都已归一化。\n- 为保持数值稳定性，在形成比率 $\\dfrac{P_{\\mathrm{AT}}(\\varphi)}{P_{\\mathrm{CG}}(\\varphi)}$ 和计算 $D_{\\mathrm{KL}}$ 中的对数时，在分母和密度中加入一个小的正常数 $\\varepsilon$，以避免除以零和未定义的对数，同时保持 $\\varepsilon$ 相对于单位一可以忽略不计。\n- 所有自由能必须以 $\\mathrm{kJ\\,mol^{-1}}$ 表示，并使用 $R = 8.314462618\\times 10^{-3}\\ \\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$ 计算。角度单位为弧度。\n\n测试套件：\n对于下面的每个参数集 $(T, k_1, k_3, k_{\\mathrm{CG}}, b, \\sigma, \\varphi_c)$，计算 $\\big[D_{\\mathrm{KL}}(Q\\Vert P_{\\mathrm{AT}}),\\ \\Delta F_{\\mathrm{meas}},\\ \\Delta F_{\\mathrm{rw}},\\ \\Delta F_{\\mathrm{true}}\\big]$，其中自由能单位为 $\\mathrm{kJ\\,mol^{-1}}$，并按规定汇总结果。\n\n- 情况 1 (基线，轻度噪声，无偏差): $T = 300$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 2.0$, $b = 0.0$, $\\sigma = 0.2$, $\\varphi_c = 0.3$。\n- 情况 2 (正平均偏差，中度噪声): $T = 300$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 1.5$, $b = 0.4$, $\\sigma = 0.3$, $\\varphi_c = 0.3$。\n- 情况 3 (负平均偏差，较强噪声): $T = 300$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 2.5$, $b = -0.6$, $\\sigma = 0.5$, $\\varphi_c = 0.3$。\n- 情况 4 (强平滑，小宏观态宽度): $T = 300$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 2.0$, $b = 0.0$, $\\sigma = 1.0$, $\\varphi_c = 0.1$。\n- 情况 5 (较高温度，中度偏差): $T = 500$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 2.0$, $b = 0.2$, $\\sigma = 0.4$, $\\varphi_c = 0.3$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身是一个用方括号括起来的逗号分隔列表，对应于上面给出的一个测试用例，顺序相同。例如，\n$[ [d_1, f^{\\mathrm{meas}}_1, f^{\\mathrm{rw}}_1, f^{\\mathrm{true}}_1], [d_2, f^{\\mathrm{meas}}_2, f^{\\mathrm{rw}}_2, f^{\\mathrm{true}}_2], \\dots ]$，\n所有数字均采用浮点表示，自由能单位为 $\\mathrm{kJ\\,mol^{-1}}$。",
            "solution": "用户提供了一个在统计力学和粗粒化建模领域的明确定义的计算问题，在进行求解前需要对其进行验证。\n\n### 步骤 1：问题验证\n\n根据指定标准对问题陈述进行严格评估。\n\n-   **提取的已知条件**：\n    -   **系统**：单一扭转自由度 $\\varphi \\in [-\\pi, \\pi)$。\n    -   **物理模型**：玻尔兹曼统计，概率密度 $p(\\varphi) \\propto \\exp(-\\beta U(\\varphi))$，其中 $\\beta = 1/(R T)$，$R = 8.314462618 \\times 10^{-3}\\ \\mathrm{kJ\\ mol^{-1}\\ K^{-1}}$。\n    -   **势能**：原子级势 $U_{\\mathrm{AT}}(\\varphi) = k_1(1 - \\cos\\varphi) + k_3(1 - \\cos(3\\varphi))$ 和粗粒化势 $U_{\\mathrm{CG}}(\\varphi) = k_{\\mathrm{CG}}(1 - \\cos\\varphi)$。\n    -   **反向映射**：一个随机过程，由包裹正态核 $W(\\Delta\\varphi; b, \\sigma) = \\sum_{k=-\\infty}^{\\infty} \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{(\\Delta\\varphi - b + 2\\pi k)^2}{2\\sigma^2}\\right)$ 建模。反向映射后的分布为 $Q(\\varphi) = \\int_{-\\pi}^{\\pi} P_{\\mathrm{CG}}(\\psi)\\, W(\\varphi - \\psi; b, \\sigma)\\, d\\psi$。\n    -   **宏观态**：$A = \\{\\varphi: |\\varphi| \\le \\varphi_c\\}$，$B = \\{\\varphi: \\min(|\\varphi - \\pi|, |\\varphi + \\pi|) \\le \\varphi_c\\}$。\n    -   **观测量**：\n        1.  自由能差：$\\Delta F = F_B - F_A = -R T \\ln(\\int_B p(\\varphi)d\\varphi / \\int_A p(\\varphi)d\\varphi)$，分别对 $p=P_{\\mathrm{AT}}$（$\\Delta F_{\\mathrm{true}}$）和 $p=Q$（$\\Delta F_{\\mathrm{meas}}$）进行计算。\n        2.  重加权自由能差：$\\Delta F_{\\mathrm{rw}} = -R T \\ln(\\int_B w(\\varphi)Q(\\varphi)d\\varphi / \\int_A w(\\varphi)Q(\\varphi)d\\varphi)$，其中 $w(\\varphi) = P_{\\mathrm{AT}}(\\varphi)/P_{\\mathrm{CG}}(\\varphi)$。\n        3.  Kullback-Leibler 散度：$D_{\\mathrm{KL}}(Q\\Vert P_{\\mathrm{AT}}) = \\int_{-\\pi}^{\\pi} Q(\\varphi)\\, \\ln(Q(\\varphi)/P_{\\mathrm{AT}}(\\varphi))\\, d\\varphi$。\n    -   **数值方法**：在 $[-\\pi, \\pi)$ 上使用均匀网格，采用梯形法则进行积分，循环卷积，并使用一个小的常数 $\\varepsilon$ 以保证数值稳定性。\n    -   **测试数据**：提供了五组参数 $(T, k_1, k_3, k_{\\mathrm{CG}}, b, \\sigma, \\varphi_c)$。\n\n-   **验证结论**：\n    1.  **有科学依据**：该问题基于统计力学的基本原理（玻尔兹曼分布、自由能）和计算化学中的标准技术（粗粒化、重加权）。势能形式和反向映射核都是标准的。该问题在科学上是合理的。\n    2.  **定义明确**：该问题在数学上是明确定义的。所有量都由显式公式指定。给定输入参数，存在唯一且有意义的解。\n    3.  **客观性**：语言精确且无偏见。所有术语都有正式定义。\n    4.  **完整且一致**：提供了所有必要的常数、公式和参数。虽然诸如网格大小 $N$ 和 $W$ 的无穷级数截断等数值细节留给实现者决定，但这对于数值问题是标准的，不构成不完整性。问题是自洽且完整的。\n\n该问题被认定为**有效**。将开发一个解决方案。\n\n### 步骤 2：解决方案设计\n\n解决方案涉及数值计算指定的物理量。这需要将连续自由度 $\\varphi$ 离散化，并实现用于积分和卷积的数值算法。\n\n1.  **离散化**：将连续域 $\\varphi \\in [-\\pi, \\pi)$ 离散化为一个包含 $N$ 个点的均匀网格。设 $\\varphi_j = -\\pi + j \\cdot \\Delta\\varphi$，其中 $j = 0, \\dots, N-1$，网格间距为 $\\Delta\\varphi = 2\\pi/N$。为了保证精度，选择一个足够大的 $N$（例如，$N=4096$）。对于均匀网格上的周期函数，整个周期的梯形积分法则简化为函数值的总和乘以 $\\Delta\\varphi$。\n\n2.  **概率密度**：\n    -   在每个网格点上计算势能 $U_{\\mathrm{AT}}(\\varphi_j)$ 和 $U_{\\mathrm{CG}}(\\varphi_j)$。\n    -   计算相应的未归一化玻尔兹曼概率密度：$p'_{\\mathrm{AT}}(\\varphi_j) = \\exp(-\\beta U_{\\mathrm{AT}}(\\varphi_j))$ 和 $p'_{\\mathrm{CG}}(\\varphi_j) = \\exp(-\\beta U_{\\mathrm{CG}}(\\varphi_j))$，其中 $\\beta = 1/(RT)$。\n    -   通过数值积分计算归一化常数（配分函数），例如，$Z_{\\mathrm{AT}} = \\sum_{j=0}^{N-1} p'_{\\mathrm{AT}}(\\varphi_j) \\Delta\\varphi$。\n    -   然后得到归一化概率密度 $P_{\\mathrm{AT}}(\\varphi_j) = p'_{\\mathrm{AT}}(\\varphi_j) / Z_{\\mathrm{AT}}$ 和 $P_{\\mathrm{CG}}(\\varphi_j) = p'_{\\mathrm{CG}}(\\varphi_j) / Z_{\\mathrm{CG}}$。\n\n3.  **反向映射密度 $Q(\\varphi)$**：\n    -   反向映射密度 $Q(\\varphi)$ 是通过粗粒化密度 $P_{\\mathrm{CG}}(\\varphi)$ 与包裹正态核 $W(\\varphi; b, \\sigma)$ 的循环卷积得到的。\n    -   首先，在网格上计算核函数 $W(\\varphi_j; b, \\sigma)$。其定义中的无穷级数被截断为一个有限范围，例如 $k \\in \\{-5, \\dots, 5\\}$，这对于给定的 $\\sigma$ 值提供了足够的精度。离散化的核也进行归一化以确保其积分为1。\n    -   循环卷积最高效的执行方式是通过卷积定理使用快速傅里叶变换 (FFT)：$\\mathcal{F}\\{f * g\\} = \\mathcal{F}\\{f\\} \\cdot \\mathcal{F}\\{g\\}$。离散卷积积分 $Q(\\varphi_i) \\approx \\sum_j P_{\\mathrm{CG}}(\\varphi_j) W(\\varphi_i - \\varphi_j) \\Delta\\varphi$ 计算为 $Q = \\text{IDFT}(\\text{DFT}(P_{\\mathrm{CG}}) \\cdot \\text{DFT}(W)) \\cdot \\Delta\\varphi$，其中 IDFT 和 DFT 分别表示离散傅里叶逆变换和正变换。结果 $Q$ 是网格上的一个归一化概率密度。\n\n4.  **数值积分与宏观态**：\n    -   宏观态 $A$ 和 $B$ 在网格上用布尔掩码表示。\n        -   $A$: `mask_A` 在 $|\\varphi_j| \\le \\varphi_c$ 的地方为真。\n        -   $B$: `mask_B` 在 $|\\varphi_j| \\ge \\pi - \\varphi_c$ 的地方为真。这等效于在圆上到 $\\pi$ 的距离小于或等于 $\\varphi_c$。\n    -   对宏观态 $M$ 的积分是通过将在 $M$ 内的网格点上的被积函数值求和，然后乘以 $\\Delta\\varphi$ 来计算的。例如，$\\int_A P_{\\mathrm{AT}}(\\varphi)d\\varphi \\approx \\sum_{j \\in A} P_{\\mathrm{AT}}(\\varphi_j) \\Delta\\varphi$。\n\n5.  **自由能和 KL 散度计算**：\n    -   **$\\Delta F_{\\mathrm{true}}$ 和 $\\Delta F_{\\mathrm{meas}}$**：计算 $P_{\\mathrm{AT}}$ 和 $Q$ 在状态 $A$ 和 $B$ 的积分概率，记为 $Z_{A}$ 和 $Z_{B}$。然后使用公式 $\\Delta F = -RT\\ln(Z_B/Z_A)$ 计算自由能差。在对数的参数中加入一个小的常数 $\\varepsilon$ 以防止当某个状态概率为零时出现数值错误。\n    -   **$\\Delta F_{\\mathrm{rw}}$**：计算重加权因子 $w(\\varphi_j) = P_{\\mathrm{AT}}(\\varphi_j) / (P_{\\mathrm{CG}}(\\varphi_j) + \\varepsilon)$。然后，计算乘积 $w(\\varphi)Q(\\varphi)$ 在宏观态 $A$ 和 $B$ 上的积分。使用这些积分值在自由能公式中求得 $\\Delta F_{\\mathrm{rw}}$。\n    -   **$D_{\\mathrm{KL}}(Q\\Vert P_{\\mathrm{AT}})$**：通过在整个网格上数值积分表达式 $Q(\\varphi_j)\\ln((Q(\\varphi_j)+\\varepsilon)/(P_{\\mathrm{AT}}(\\varphi_j)+\\varepsilon))$ 来计算 KL 散度。\n\n这个结构化的数值流程为计算每个测试用例所需的所有量提供了一种稳健的方法。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It iterates through each parameter set, computes the specified quantities,\n    and prints the formatted results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, k1, k3, k_CG, b, sigma, phi_c)\n        (300.0, 2.5, 1.0, 2.0, 0.0, 0.2, 0.3),\n        (300.0, 2.5, 1.0, 1.5, 0.4, 0.3, 0.3),\n        (300.0, 2.5, 1.0, 2.5, -0.6, 0.5, 0.3),\n        (300.0, 2.5, 1.0, 2.0, 0.0, 1.0, 0.1),\n        (500.0, 2.5, 1.0, 2.0, 0.2, 0.4, 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _calculate_observables(case)\n        results.append(result)\n\n    # Format the final output string as a list of lists.\n    # Each sublist is a comma-separated string of numbers.\n    # The final string is a comma-separated list of these sublists.\n    sub_lists_as_strings = []\n    for res in results:\n        sub_list_str = f\"[{','.join([f'{x:.6f}' for x in res])}]\"\n        sub_lists_as_strings.append(sub_list_str)\n    \n    final_output = f\"[{','.join(sub_lists_as_strings)}]\"\n    print(final_output)\n\ndef _wrapped_normal(delta_phi, b, sigma, n_points):\n    \"\"\"\n    Computes the wrapped normal distribution on a grid.\n    The infinite sum is truncated to k in [-5, 5].\n    \"\"\"\n    # Truncation range for the sum\n    k_range = np.arange(-5, 6)\n    \n    # Use broadcasting for efficient computation over the grid and k-range\n    # delta_phi shape: (n_points,) -> (n_points, 1)\n    # k_range shape: (11,) -> (1, 11)\n    numerator = -(delta_phi[:, None] - b + 2.0 * np.pi * k_range[None, :])**2\n    denominator = 2.0 * sigma**2\n    gaussians = np.exp(numerator / denominator)\n    \n    # Sum over the k-dimension\n    summed_gaussians = np.sum(gaussians, axis=1)\n    prefactor = 1.0 / (np.sqrt(2.0 * np.pi) * sigma)\n    \n    return prefactor * summed_gaussians\n\ndef _calculate_observables(params):\n    \"\"\"\n    Performs the full calculation for a single parameter set.\n    \"\"\"\n    T, k1, k3, k_CG, b, sigma, phi_c = params\n    \n    # Constants and numerical parameters\n    R = 8.314462618e-3  # kJ mol^-1 K^-1\n    N = 4096              # Number of grid points\n    epsilon = 1e-16       # Small constant for numerical stability\n\n    beta = 1.0 / (R * T)\n\n    # 1. Discretize the domain\n    phi = np.linspace(-np.pi, np.pi, N, endpoint=False)\n    d_phi = 2.0 * np.pi / N\n\n    # 2. Compute potentials and probability densities\n    # Atomistic (AT) model\n    U_at = k1 * (1.0 - np.cos(phi)) + k3 * (1.0 - np.cos(3.0 * phi))\n    boltz_at = np.exp(-beta * U_at)\n    Z_at_total = np.sum(boltz_at) * d_phi\n    P_at = boltz_at / Z_at_total\n\n    # Coarse-grained (CG) model\n    U_cg = k_CG * (1.0 - np.cos(phi))\n    boltz_cg = np.exp(-beta * U_cg)\n    Z_cg_total = np.sum(boltz_cg) * d_phi\n    P_cg = boltz_cg / Z_cg_total\n\n    # 3. Compute backmapped density Q via circular convolution\n    W_kernel = _wrapped_normal(phi, b, sigma, N)\n    # Ensure kernel is normalized on the discrete grid\n    W_kernel /= (np.sum(W_kernel) * d_phi)\n\n    # FFT-based circular convolution\n    Q_unnormalized = np.real(np.fft.ifft(np.fft.fft(P_cg) * np.fft.fft(W_kernel)))\n    Q = Q_unnormalized * d_phi\n    # Re-normalize Q to be safe against minor numerical drift\n    Q /= (np.sum(Q) * d_phi)\n\n    # 4. Define macrostates and compute integrals for free energies\n    mask_A = np.abs(phi) = phi_c\n    mask_B = np.abs(phi) >= np.pi - phi_c\n\n    # For Delta F_true (from P_at)\n    prob_A_at = np.sum(P_at[mask_A]) * d_phi\n    prob_B_at = np.sum(P_at[mask_B]) * d_phi\n    \n    # For Delta F_meas (from Q)\n    prob_A_q = np.sum(Q[mask_A]) * d_phi\n    prob_B_q = np.sum(Q[mask_B]) * d_phi\n    \n    # For Delta F_rw (reweighting)\n    w = P_at / (P_cg + epsilon)\n    prob_A_rw = np.sum(w[mask_A] * Q[mask_A]) * d_phi\n    prob_B_rw = np.sum(w[mask_B] * Q[mask_B]) * d_phi\n\n    # Compute free energy differences\n    delta_F_true = -R * T * np.log((prob_B_at + epsilon) / (prob_A_at + epsilon))\n    delta_F_meas = -R * T * np.log((prob_B_q + epsilon) / (prob_A_q + epsilon))\n    delta_F_rw = -R * T * np.log((prob_B_rw + epsilon) / (prob_A_rw + epsilon))\n\n    # 5. Compute Kullback-Leibler divergence\n    integrand_kl = Q * np.log((Q + epsilon) / (P_at + epsilon))\n    D_kl = np.sum(integrand_kl) * d_phi\n\n    return [D_kl, delta_F_meas, delta_F_rw, delta_F_true]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}