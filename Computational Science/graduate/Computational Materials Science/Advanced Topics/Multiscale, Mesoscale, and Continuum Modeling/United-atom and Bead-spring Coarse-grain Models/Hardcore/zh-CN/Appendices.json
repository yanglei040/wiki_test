{
    "hands_on_practices": [
        {
            "introduction": "粗粒化建模的核心在于推导出一个能准确反映体系行为的有效势能。然而，一个能够完美再现结构特性（如径向分布函数 $g(r)$）的势能，不一定能同时精确预测热力学性质（如压力 $p$），这是粗粒化力场开发中一个经典的“可表示性”问题。本实践将引导你探索这一挑战，从经典的迭代玻尔兹曼反转（Iterative Boltzmann Inversion, IBI）方法入手，该方法旨在匹配结构，然后实现一个标准压力校正方案，以展示如何在结构和热力学性质之间取得平衡。",
            "id": "3500714",
            "problem": "考虑一个单组分粗粒化流体，它可以表示一个联合原子（United-Atom）映射模型或一个珠簧（Bead-Spring）高分子模型。其中，粗粒化位点之间的有效相互作用由一个球对称的对势 $U(r)$ 来表示。在本问题中，您将检验迭代玻尔兹曼反演（Iterative Boltzmann Inversion, IBI）是否能同时复现径向分布函数 $g(r)$ 和热力学压力 $p$，并且您将实现一个形式为 $\\Delta U(r) \\propto r$ 的压力校正来修正任何不匹配之处。请在 Lennard-Jones 约化单位下进行计算：长度单位为 $σ$，能量单位为 $ε$，温度单位为 $ε/k_B$，压力单位为 $ε/σ^3$。所有输出都必须使用这些约化单位进行计算和报告。\n\n使用以下基本理论基础：\n- 正则系综中的统计力学给出了低密度闭合关系 $g(r) \\approx \\exp(-β U(r))$，其中 $β = 1/(k_B T)$，在约化单位中 $k_B = 1$。\n- 对于各向同性对势，维里定理给出的压力表达式为\n$$\np = ρ T - \\frac{2π}{3} ρ^2 \\int_0^{∞} g(r)\\, r^3 \\frac{dU(r)}{dr}\\, dr,\n$$\n其中 $ρ$ 是数密度，$T$ 是温度。\n- Lennard-Jones (LJ) 势为 $U_{\\mathrm{LJ}}(r) = 4 ε \\left[ \\left(\\frac{σ}{r}\\right)^{12} - \\left(\\frac{σ}{r}\\right)^6 \\right]$，其径向导数为 $\\frac{dU_{\\mathrm{LJ}}}{dr} = 4 ε \\left[ -12 \\frac{σ^{12}}{r^{13}} + 6 \\frac{σ^6}{r^7} \\right]$。在约化单位中，取 $ε=1$ 和 $σ=1$。\n\n目标模型和可观测量：\n- 定义一个截断-移位（truncated-and-shifted）的目标势 $U_{\\mathrm{true}}(r)$，当 $r \\le r_c^{\\mathrm{true}}$ 时为 $U_{\\mathrm{true}}(r) = U_{\\mathrm{LJ}}(r) - U_{\\mathrm{LJ}}(r_c^{\\mathrm{true}})$，当 $r > r_c^{\\mathrm{true}}$ 时为 $U_{\\mathrm{true}}(r) = 0$。\n- 使用低密度闭合关系 $g_{\\mathrm{target}}(r) = \\exp(-β U_{\\mathrm{true}}(r))$ 定义目标径向分布函数 $g_{\\mathrm{target}}(r)$。\n- 使用维里表达式定义目标压力 $p_{\\mathrm{target}}$，其中使用 $U_{\\mathrm{true}}(r)$ 和 $g_{\\mathrm{target}}(r)$，积分上限为 $r_c^{\\mathrm{true}}$。\n\n仅 IBI 的模型：\n- 在 $[0, r_c^{\\mathrm{cg}}]$ 上定义仅 IBI 的粗粒化势为 $U_{\\mathrm{IBI}}(r) = -T \\ln g_{\\mathrm{target}}(r)$，即通过在粗粒化截断域上使用低密度闭合关系精确匹配 $g(r)$。\n- 使用维里表达式计算仅 IBI 的压力 $p_{\\mathrm{IBI}}$，积分上限为 $r_c^{\\mathrm{cg}}$。\n\n压力校正：\n- 当 $r \\le r_c^{\\mathrm{cg}}$ 时，实现一个线性压力校正 $\\Delta U(r) = a\\, r$，当 $r > r_c^{\\mathrm{cg}}$ 时 $\\Delta U(r) = 0$。在 $[0, r_c^{\\mathrm{cg}}]$ 上定义 $U_{\\mathrm{corr}}(r) = U_{\\mathrm{IBI}}(r) + a r$。\n- 使用维里恒等式选择 $a$，使得校正后的压力 $p_{\\mathrm{corr}}$ 与 $p_{\\mathrm{target}}$ 匹配。在低密度闭合 $g(r) \\approx \\exp(-β U(r))$ 和粗粒化域内，线性校正使维里积分发生如下变化\n$$\n\\Delta p = -\\frac{2π}{3} ρ^2 a \\int_0^{r_c^{\\mathrm{cg}}} g(r)\\, r^3\\, dr,\n$$\n由此得到系数\n$$\na = -\\frac{p_{\\mathrm{target}} - p_{\\mathrm{IBI}}}{\\frac{2π}{3} ρ^2 \\int_0^{r_c^{\\mathrm{cg}}} g(r)\\, r^3\\, dr}。\n$$\n\n数值实现细节：\n- 在一个从 $r_{\\min}$ 到相关截断半径的均匀网格上将 $r$ 离散化，其中 $r_{\\min} > 0$ 以避免 $r=0$ 处的奇点。使用 $r_{\\min} = 0.80$，并采用足够大的网格尺寸以确保稳定的数值积分。使用梯形法则来近似计算积分。\n- 在约化单位中，始终设置 $k_B = 1$。\n- 在任何出现 $g$ 的地方，都使用 $g(r) = \\exp(-β U(r))$。\n\n评估指标：\n- 结构度量：在 $[r_{\\min}, r_c^{\\mathrm{cg}}]$ 上计算模型与目标之间 $g(r)$ 的均方根偏差，\n$$\n\\mathrm{RMS}_g = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N \\left( g_{\\mathrm{model}}(r_i) - g_{\\mathrm{target}}(r_i) \\right)^2 },\n$$\n并要求 $\\mathrm{RMS}_g \\le 0.03$。\n- 压力度量：计算 $|p_{\\mathrm{model}} - p_{\\mathrm{target}}|$ 并要求其 $\\le 0.01$。\n- 对于仅 IBI 模型，$g_{\\mathrm{model}}(r)$ 在 $[r_{\\min}, r_c^{\\mathrm{cg}}]$ 上即为 $g_{\\mathrm{target}}(r)$；对于压力校正模型，$g_{\\mathrm{model}}(r) = \\exp(-β U_{\\mathrm{corr}}(r))$。\n\n您的程序必须：\n- 对每个测试用例，计算两个布尔值：一个表示仅 IBI 模型是否在容差范围内同时匹配 $g(r)$ 和 $p$；另一个表示压力校正模型是否在容差范围内同时匹配 $g(r)$ 和 $p$。\n- 将所有测试用例的布尔值聚合到一个扁平列表中，并按下面指定的精确格式单行打印。\n\n测试套件和参数（全部为约化单位）：\n- 测试用例 1（理想路径，截断不匹配）：$T = 1.0$, $ρ = 0.2$, $r_c^{\\mathrm{true}} = 3.0$, $r_c^{\\mathrm{cg}} = 2.0$。\n- 测试用例 2（边界情况，极低密度）：$T = 1.0$, $ρ = 0.01$, $r_c^{\\mathrm{true}} = 3.0$, $r_c^{\\mathrm{cg}} = 2.0$。\n- 测试用例 3（边缘情况，无截断不匹配）：$T = 1.0$, $ρ = 0.2$, $r_c^{\\mathrm{true}} = 2.0$, $r_c^{\\mathrm{cg}} = 2.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个布尔结果，以逗号分隔并用方括号括起来，顺序为 $[$案例1 仅IBI结果, 案例1 校正后结果, 案例2 仅IBI结果, 案例2 校正后结果, 案例3 仅IBI结果, 案例3 校正后结果$]$。例如，$[True,False,True,True,False,True]$。",
            "solution": "该问题要求分析两种粗粒化策略——迭代玻尔兹曼反演（IBI）和其压力校正变体，以确定它们是否能同时复现目标系统的结构和压力。目标系统是一种流体，其粒子通过截断-移位的 Lennard-Jones (LJ) 势相互作用，其性质在低密度近似下确定，其中径向分布函数 $g(r)$ 由对势 $U(r)$ 的玻尔兹曼因子给出。\n\n分析在 Lennard-Jones 约化单位下进行，其中能量单位为 $ε$，长度单位为 $σ$，温度 $T$ 单位为 $ε/k_B$，压力 $p$ 单位为 $ε/σ^3$。常数设置为 $ε=1$、$σ=1$ 以及玻尔兹曼常数 $k_B=1$。因此，势、结构和温度之间的关系为 $g(r) \\approx \\exp(-U(r)/T)$。\n\n压力 $p$ 使用球对称对势的维里定理计算：\n$$\np = ρ T - \\frac{2π}{3} ρ^2 \\int_0^{∞} g(r)\\, r^3 \\frac{dU(r)}{dr}\\, dr\n$$\n其中 $ρ$ 是数密度。在数值上，为了避免 $r=0$ 处的奇点，使用梯形法则从最小距离 $r_{\\min} = 0.80$ 到相关的截断半径进行积分。\n\n每个测试用例的逐步过程如下：\n\n1.  **定义目标系统**：\n    基础的 Lennard-Jones 势为 $U_{\\mathrm{LJ}}(r) = 4(r^{-12} - r^{-6})$。\n    目标系统由一个具有截断半径 $r_c^{\\mathrm{true}}$ 的截断-移位势 $U_{\\mathrm{true}}(r)$ 定义：\n    $$\n    U_{\\mathrm{true}}(r) = \\begin{cases} U_{\\mathrm{LJ}}(r) - U_{\\mathrm{LJ}}(r_c^{\\mathrm{true}})  &\\text{若 } r \\le r_c^{\\mathrm{true}} \\\\ 0  &\\text{若 } r > r_c^{\\mathrm{true}} \\end{cases}\n    $$\n    目标结构由低密度闭合关系给出，$g_{\\mathrm{target}}(r) = \\exp(-U_{\\mathrm{true}}(r)/T)$。\n    目标压力 $p_{\\mathrm{target}}$ 使用维里表达式计算，其中使用 $U_{\\mathrm{true}}(r)$ 和 $g_{\\mathrm{target}}(r)$，积分上限为 $r_c^{\\mathrm{true}}$。导数 $\\frac{dU_{\\mathrm{true}}}{dr}$ 在 $r \\le r_c^{\\mathrm{true}}$ 时等于 $\\frac{dU_{\\mathrm{LJ}}}{dr}$，否则为 $0$。\n\n2.  **分析仅 IBI 模型**：\n    IBI 方法旨在复现目标结构 $g_{\\mathrm{target}}(r)$。在其最简单的非迭代形式中，势 $U_{\\mathrm{IBI}}(r)$ 是通过在粗粒化域 $[0, r_c^{\\mathrm{cg}}]$ 上反演玻尔兹曼关系得到的：\n    $$\n    U_{\\mathrm{IBI}}(r) = -T \\ln(g_{\\mathrm{target}}(r)) \\quad \\text{对于 } r \\le r_c^{\\mathrm{cg}}\n    $$\n    鉴于 $g_{\\mathrm{target}}(r) = \\exp(-U_{\\mathrm{true}}(r)/T)$，可得对于所有 $r \\le r_c^{\\mathrm{cg}}$，有 $U_{\\mathrm{IBI}}(r) = U_{\\mathrm{true}}(r)$。根据此构造，IBI 模型的径向分布函数 $g_{\\mathrm{IBI}}(r) = \\exp(-U_{\\mathrm{IBI}}(r)/T)$ 在域 $[0, r_c^{\\mathrm{cg}}]$ 上与 $g_{\\mathrm{target}}(r)$ 相同。因此，对于 IBI 模型，结构匹配度量 $\\mathrm{RMS}_g$ 恒为零。\n    IBI 模型的压力 $p_{\\mathrm{IBI}}$ 使用维里定理计算，其中使用 $U_{\\mathrm{IBI}}(r)$ 和 $g_{\\mathrm{IBI}}(r)$，积分上限为粗粒化截断半径 $r_c^{\\mathrm{cg}}$。\n    如果 $|p_{\\mathrm{IBI}} - p_{\\mathrm{target}}| \\le 0.01$，则认为仅 IBI 模型是成功的。结构度量根据定义已经满足。\n\n3.  **分析压力校正模型**：\n    当 $p_{\\mathrm{IBI}}$ 与 $p_{\\mathrm{target}}$ 不匹配时，向势中添加一个校正项。这里，对于 $r \\le r_c^{\\mathrm{cg}}$，使用线性校正 $\\Delta U(r) = a\\,r$。校正后的势为 $U_{\\mathrm{corr}}(r) = U_{\\mathrm{IBI}}(r) + a\\,r$。\n    系数 $a$ 是通过近似所需的压力变化来确定的。由于 $\\Delta U(r)$ 引起的维里贡献变化近似为 $\\Delta p \\approx -\\frac{2π}{3} ρ^2 \\int_0^{r_c^{\\mathrm{cg}}} g_{\\mathrm{target}}(r)\\, r^3 \\frac{d(\\Delta U(r))}{dr}\\, dr$。设 $\\Delta p = p_{\\mathrm{target}} - p_{\\mathrm{IBI}}$ 并使用 $\\frac{d(\\Delta U(r))}{dr} = a$，我们解出 $a$：\n    $$\n    a = -\\frac{p_{\\mathrm{target}} - p_{\\mathrm{IBI}}}{\\frac{2π}{3} ρ^2 \\int_0^{r_c^{\\mathrm{cg}}} g_{\\mathrm{target}}(r)\\, r^3\\, dr}\n    $$\n    这个一次性校正定义了新的势 $U_{\\mathrm{corr}}(r)$。相应的新结构是 $g_{\\mathrm{corr}}(r) = \\exp(-U_{\\mathrm{corr}}(r)/T)$。校正后的压力 $p_{\\mathrm{corr}}$ 使用 $U_{\\mathrm{corr}}(r)$ 和 $g_{\\mathrm{corr}}(r)$ 通过维里定理计算，积分上限为 $r_c^{\\mathrm{cg}}$。\n    如果校正模型同时满足以下两个条件，则被认为是成功的：\n    a. 结构匹配：在域 $[r_{\\min}, r_c^{\\mathrm{cg}}]$ 上，$\\mathrm{RMS}_g = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N \\left( g_{\\mathrm{corr}}(r_i) - g_{\\mathrm{target}}(r_i) \\right)^2 } \\le 0.03$。\n    b. 压力匹配：$|p_{\\mathrm{corr}} - p_{\\mathrm{target}}| \\le 0.01$。\n\n此过程应用于每个测试用例，以生成所需的布尔评估结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import trapezoid\n\ndef solve():\n    \"\"\"\n    Solves the coarse-graining problem for the specified test cases.\n\n    This function implements the IBI and pressure-correction models for a coarse-grained\n    fluid. It evaluates whether each model can simultaneously reproduce the target\n    structure (radial distribution function) and pressure within given tolerances.\n    \"\"\"\n    \n    # Define problem constants and tolerances\n    r_min = 0.80\n    rms_g_tol = 0.03\n    p_tol = 0.01\n    \n    # In reduced units, epsilon, sigma, and k_B are 1.\n    epsilon = 1.0\n    sigma = 1.0\n    k_B = 1.0\n    \n    # Define a numerical grid. The maximum r_c_true is 3.0, so this range is sufficient.\n    num_points = 4001 # A fine grid for stable quadrature\n    r_grid = np.linspace(r_min, 3.0, num_points)\n\n    # Define the Lennard-Jones potential and its derivative in reduced units\n    def U_lj(r):\n        r_inv = sigma / r\n        r_inv6 = r_inv**6\n        return 4.0 * epsilon * (r_inv6**2 - r_inv6)\n\n    def dU_lj_dr(r):\n        r_inv = sigma / r\n        r_inv7 = r_inv**7\n        r_inv13 = r_inv**13\n        return 4.0 * epsilon * (-12.0 * r_inv13 / sigma + 6.0 * r_inv7 / sigma)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, ρ, r_c^true, r_c^cg)\n        (1.0, 0.2, 3.0, 2.0),\n        (1.0, 0.01, 3.0, 2.0),\n        (1.0, 0.2, 2.0, 2.0),\n    ]\n\n    results = []\n    \n    for T, rho, r_c_true, r_c_cg in test_cases:\n        beta = 1.0 / (k_B * T)\n        \n        # --- 1. Target Model Calculation ---\n        \n        # Define the truncated-and-shifted target potential U_true(r)\n        U_lj_at_rc_true = U_lj(r_c_true)\n        U_true = np.where(r_grid = r_c_true, U_lj(r_grid) - U_lj_at_rc_true, 0.0)\n        \n        # Define the target radial distribution function g_target(r)\n        g_target = np.exp(-beta * U_true)\n        \n        # Define the derivative of the target potential\n        dU_true_dr = np.where(r_grid = r_c_true, dU_lj_dr(r_grid), 0.0)\n        \n        # Calculate the target pressure p_target\n        integrand_target = g_target * r_grid**3 * dU_true_dr\n        mask_true = r_grid = r_c_true\n        integral_target = trapezoid(integrand_target[mask_true], r_grid[mask_true])\n        p_target = rho * T - (2.0 * np.pi / 3.0) * rho**2 * integral_target\n        \n        # --- 2. IBI-Only Model Calculation  Evaluation ---\n        \n        # By definition, U_ibi(r) = U_true(r) and g_ibi(r) = g_target(r) for r = r_c_cg.\n        # Thus, the RMS_g for the IBI-only model is 0 and always meets the criterion.\n        rms_g_ibi_ok = True\n        \n        # Calculate the IBI-only pressure p_ibi\n        mask_cg = r_grid = r_c_cg\n        dU_ibi_dr = np.where(mask_cg, dU_lj_dr(r_grid), 0.0)\n        integrand_ibi = g_target * r_grid**3 * dU_ibi_dr\n        integral_ibi = trapezoid(integrand_ibi[mask_cg], r_grid[mask_cg])\n        p_ibi = rho * T - (2.0 * np.pi / 3.0) * rho**2 * integral_ibi\n        \n        # Evaluate if p_ibi meets the pressure criterion\n        p_ibi_ok = abs(p_ibi - p_target) = p_tol\n        results.append(rms_g_ibi_ok and p_ibi_ok)\n\n        # --- 3. Pressure-Corrected Model Calculation  Evaluation ---\n        \n        # Calculate the pressure correction coefficient 'a'\n        p_diff = p_target - p_ibi\n        integrand_a_denom = g_target[mask_cg] * r_grid[mask_cg]**3\n        integral_a_denom = trapezoid(integrand_a_denom, r_grid[mask_cg])\n        \n        denom_const = (2.0 * np.pi / 3.0) * rho**2\n        if abs(denom_const * integral_a_denom)  1e-15:\n            a = 0.0\n        else:\n            a = -p_diff / (denom_const * integral_a_denom)\n            \n        # Define the corrected potential and its corresponding RDF\n        U_corr = np.where(mask_cg, U_true + a * r_grid, 0.0)\n        g_corr = np.exp(-beta * U_corr)\n        \n        # Evaluate structure metric for the corrected model\n        g_corr_on_cg = g_corr[mask_cg]\n        g_target_on_cg = g_target[mask_cg]\n        rms_g_corr = np.sqrt(np.mean((g_corr_on_cg - g_target_on_cg)**2))\n        rms_g_corr_ok = rms_g_corr = rms_g_tol\n        \n        # Evaluate pressure metric for the corrected model\n        dU_corr_dr = np.where(mask_cg, dU_lj_dr(r_grid) + a, 0.0)\n        integrand_corr = g_corr * r_grid**3 * dU_corr_dr\n        integral_corr = trapezoid(integrand_corr[mask_cg], r_grid[mask_cg])\n        p_corr = rho * T - (2.0 * np.pi / 3.0) * rho**2 * integral_corr\n        p_corr_ok = abs(p_corr - p_target) = p_tol\n        \n        results.append(rms_g_corr_ok and p_corr_ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了提高计算效率，实际的分子动力学模拟通常需要截断粒子间的相互作用势能，但这会引入截断伪影，尤其是在计算压力等热力学量时。本实践将探讨在势能被截断的系统中如何正确计算压力这一关键问题。你将推导并应用标准的“尾部校正”（tail correction）来补偿被忽略的长程相互作用，并设计一个“切换函数”（switching function）来平滑截断处的势能和力，从而提高模拟的稳定性和准确性。",
            "id": "3500778",
            "problem": "考虑一个由相同的球形位点组成的粗粒化（CG）流体，该流体由具有有限截断的 Lennard-Jones（LJ）对势建模。在联合原子或珠簧粗粒化表示中，位点间的有效对势通常表示为在截断半径 $r_c$ 处截断的 LJ 形式，以降低计算成本。设 LJ 势由 $u(r) = 4 \\varepsilon \\left[\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^6\\right]$ 给出，对于 $r \\ge r_c$ 截断为零，且无位移。在约化 LJ 单位下进行计算，其中能量标度 $\\varepsilon = 1$，长度标度 $\\sigma = 1$，玻尔兹曼常数 $k_{\\mathrm{B}} = 1$，因此温度 $T$ 和数密度 $\\rho$ 是无量纲的，压强以 $\\varepsilon / \\sigma^3$ 为单位表示。\n\n从基本统计力学出发，具有对相互作用的各向同性、均匀流体的压强 $P$ 可以通过维里路径写为\n$$\nP = \\rho T - \\frac{2 \\pi}{3} \\rho^2 \\int_{0}^{\\infty} r^3 \\, u'(r) \\, g(r) \\, dr,\n$$\n其中 $u'(r) = \\dfrac{d u(r)}{dr}$，$g(r)$ 是径向分布函数。在低密度极限下，可以采用经过充分检验的近似 $g(r) \\approx \\exp\\left[-u(r)/T\\right]$。\n\n由于在 CG 模拟中 LJ 势在 $r_c$ 处被截断，维里积分仅计算到 $r_c$ 为止，这改变了计算出的压强。一种常见的补救方法是向状态方程中添加一个“尾部校正”，该校正通过假设对于 $r  r_c$ 有 $g(r) \\approx 1$ 并使用 $P$ 的基本维里表达式来解释 $r_c$ 之外被忽略的长程贡献。此外，为了减轻由尖锐截断（力不连续性）引起的伪影，通常会引入一个平滑的开关函数 $S(r)$，它在 $r_c$ 附近调节力，使得有效力在 $r_c$ 处平滑地变为零。\n\n你的任务是：\n\n1) 使用维里表达式和 $g(r)$ 的低密度近似，计算截断维里压强\n$$\nP_{\\mathrm{trunc}}(\\rho, T, r_c) = \\rho T - \\frac{2 \\pi}{3} \\rho^2 \\int_{0}^{r_c} r^3 \\, u'(r) \\, \\exp\\left[-\\frac{u(r)}{T}\\right] \\, dr.\n$$\n\n2) 从第一性原理出发，推导压强的尾部校正\n$$\nP_{\\mathrm{tail}}(\\rho, r_c) = - \\frac{2 \\pi}{3} \\rho^2 \\int_{r_c}^{\\infty} r^3 \\, u'(r) \\, dr,\n$$\n并假设对于 $r  r_c$ 有 $g(r) \\approx 1$。在约化 LJ 单位下，用 $\\rho$ 和 $r_c$ 表示 $P_{\\mathrm{tail}}$，并用此定义经过尾部校正的状态方程压强 $P_{\\mathrm{eos}} = P_{\\mathrm{trunc}} + P_{\\mathrm{tail}}$。\n\n3) 提出了一个具有以下性质的平滑开关函数 $S(r)$：\n- 对于 $r \\le r_s$，$S(r) = 1$，其中 $r_s  r_c$ 是开关起始半径。\n- 对于 $r \\ge r_c$，$S(r) = 0$。\n- $S(r)$、$S'(r)$ 和 $S''(r)$ 在 $[0, \\infty)$ 上连续，且 $S'(r_s) = S''(r_s) = 0$ 以及 $S'(r_c) = S''(r_c) = 0$。\n找出在 $[r_s, r_c]$ 上满足这些约束条件的最低阶多项式形式，并提供以 $r_s$ 和 $r_c$ 表示的显式系数。\n\n4) 使用 $S(r)$，定义加开关函数的截断维里压强\n$$\nP_{\\mathrm{switch}}(\\rho, T, r_s, r_c) = \\rho T - \\frac{2 \\pi}{3} \\rho^2 \\left[ \\int_{0}^{r_s} r^3 \\, u'(r) \\, \\exp\\left(-\\frac{u(r)}{T}\\right) \\, dr \\;+\\; \\int_{r_s}^{r_c} r^3 \\, S(r) \\, u'(r) \\, \\exp\\left(-\\frac{u(r)}{T}\\right) \\, dr \\right].\n$$\n构建经过尾部校正的开关压强 $P_{\\mathrm{switch+tail}} = P_{\\mathrm{switch}} + P_{\\mathrm{tail}}$。将 $P_{\\mathrm{eos}}$ 与 $P_{\\mathrm{trunc}}$ 和 $P_{\\mathrm{switch+tail}}$ 进行比较。\n\n5) 对于下面测试套件中的每个测试用例，评估引入开关函数是否减小了相对于经过尾部校正的状态方程的绝对误差。具体来说，报告谓词的布尔值\n$$\n\\left| P_{\\mathrm{eos}} - P_{\\mathrm{switch+tail}} \\right|  \\left| P_{\\mathrm{eos}} - P_{\\mathrm{trunc}} \\right|.\n$$\n\n所有计算都必须在约化 LJ 单位下进行，最终程序的输出必须是单行文本，包含所有测试用例的结果，结果为逗号分隔的列表，并用方括号括起来，列表项为布尔值。\n\n测试套件（每个元组为约化 LJ 单位下的 $(\\rho, T, r_s, r_c)$）：\n- $(0.8, 1.2, 2.0, 2.5)$\n- $(0.05, 1.0, 2.0, 2.5)$\n- $(1.2, 0.8, 2.2, 2.5)$\n- $(0.8, 1.2, 1.6, 2.0)$\n- $(0.8, 1.2, 2.5, 2.5)$\n- $(0.8, 1.2, 0.0, 2.5)$\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,...]”）。",
            "solution": "该问题具有科学依据，提法明确且客观。它基于统计力学和计算材料科学的标准原理，特别是关于在粗粒化模拟中使用 Lennard-Jones 势计算压强的问题。所有必要的函数、参数和常数都已提供，任务定义清晰且计算上可行。该问题是有效的。\n\n解决方案按顺序处理每个任务。所有计算均在约化 Lennard-Jones 单位下进行，其中能量标度 $\\varepsilon=1$，长度标度 $\\sigma=1$，玻尔兹曼常数 $k_{\\mathrm{B}}=1$。\n\n**理论框架**\n\n约化单位下的 Lennard-Jones (LJ) 势由下式给出：\n$$ u(r) = 4 \\left( r^{-12} - r^{-6} \\right) $$\n它对 $r$ 的导数是：\n$$ u'(r) = \\frac{du}{dr} = 4 \\left( -12r^{-13} - (-6)r^{-7} \\right) = 24 \\left( r^{-7} - 2r^{-13} \\right) $$\n\n该问题要求评估并比较几种形式的压强方程。比较的核心是以下谓词：\n$$ \\left| P_{\\mathrm{eos}} - P_{\\mathrm{switch+tail}} \\right|  \\left| P_{\\mathrm{eos}} - P_{\\mathrm{trunc}} \\right| $$\n使用定义 $P_{\\mathrm{eos}} = P_{\\mathrm{trunc}} + P_{\\mathrm{tail}}$ 和 $P_{\\mathrm{switch+tail}} = P_{\\mathrm{switch}} + P_{\\mathrm{tail}}$，不等式得以简化。\n左侧（LHS）变为：\n$$ \\text{LHS} = \\left| (P_{\\mathrm{trunc}} + P_{\\mathrm{tail}}) - (P_{\\mathrm{switch}} + P_{\\mathrm{tail}}) \\right| = \\left| P_{\\mathrm{trunc}} - P_{\\mathrm{switch}} \\right| $$\n右侧（RHS）变为：\n$$ \\text{RHS} = \\left| (P_{\\mathrm{trunc}} + P_{\\mathrm{tail}}) - P_{\\mathrm{trunc}} \\right| = \\left| P_{\\mathrm{tail}} \\right| $$\n因此，需要评估的谓词是 $\\left| P_{\\mathrm{trunc}} - P_{\\mathrm{switch}} \\right|  \\left| P_{\\mathrm{tail}} \\right|$。\n\n我们使用积分定义来表示 $P_{\\mathrm{trunc}} - P_{\\mathrm{switch}}$ 和 $P_{\\mathrm{tail}}$。\n设 $I(r, T) = r^3 u'(r) \\exp(-u(r)/T)$。\n$$ P_{\\mathrm{trunc}} = \\rho T - \\frac{2\\pi}{3}\\rho^2 \\int_0^{r_c} I(r, T) dr = \\rho T - \\frac{2\\pi}{3}\\rho^2 \\left( \\int_0^{r_s} I(r, T) dr + \\int_{r_s}^{r_c} I(r, T) dr \\right) $$\n$$ P_{\\mathrm{switch}} = \\rho T - \\frac{2\\pi}{3}\\rho^2 \\left( \\int_0^{r_s} I(r, T) dr + \\int_{r_s}^{r_c} S(r) I(r, T) dr \\right) $$\n差值为：\n$$ P_{\\mathrm{trunc}} - P_{\\mathrm{switch}} = -\\frac{2\\pi}{3}\\rho^2 \\left( \\int_{r_s}^{r_c} I(r, T) dr - \\int_{r_s}^{r_c} S(r) I(r, T) dr \\right) = -\\frac{2\\pi}{3}\\rho^2 \\int_{r_s}^{r_c} (1-S(r)) I(r, T) dr $$\n尾部压强定义为：\n$$ P_{\\mathrm{tail}} = - \\frac{2\\pi}{3}\\rho^2 \\int_{r_c}^{\\infty} r^3 u'(r) dr $$\n将这些代入不等式 $\\left| P_{\\mathrm{trunc}} - P_{\\mathrm{switch}} \\right|  \\left| P_{\\mathrm{tail}} \\right|$ 并消去公因子 $\\frac{2\\pi}{3}\\rho^2$（因为 $\\rho  0$），得到：\n$$ \\left| \\int_{r_s}^{r_c} (1-S(r)) r^3 u'(r) \\exp(-u(r)/T) dr \\right|  \\left| \\int_{r_c}^{\\infty} r^3 u'(r) dr \\right| $$\n\n**任务2：压强尾部校正**\n\n我们首先解析地计算尾部校正的积分。\n$$ \\int r^3 u'(r) dr = \\int r^3 \\cdot 24(r^{-7} - 2r^{-13}) dr = 24 \\int (r^{-4} - 2r^{-10}) dr $$\n$$ = 24 \\left( \\frac{r^{-3}}{-3} - 2\\frac{r^{-9}}{-9} \\right) + C = 24 \\left( -\\frac{1}{3}r^{-3} + \\frac{2}{9}r^{-9} \\right) + C = -8r^{-3} + \\frac{16}{3}r^{-9} + C $$\n计算从 $r_c$ 到 $\\infty$ 的定积分：\n$$ \\int_{r_c}^{\\infty} r^3 u'(r) dr = \\left[ -8r^{-3} + \\frac{16}{3}r^{-9} \\right]_{r_c}^{\\infty} = (0-0) - \\left(-8r_c^{-3} + \\frac{16}{3}r_c^{-9}\\right) = 8r_c^{-3} - \\frac{16}{3}r_c^{-9} $$\n因此，尾部压强的解析表达式为：\n$$ P_{\\mathrm{tail}}(\\rho, r_c) = - \\frac{2\\pi}{3}\\rho^2 \\left( 8r_c^{-3} - \\frac{16}{3}r_c^{-9} \\right) $$\n我们简化后不等式的右侧是该积分的绝对值：$\\left| 8r_c^{-3} - \\frac{16}{3}r_c^{-9} \\right|$。\n\n**任务3：开关函数**\n\n我们需要在 $x \\in [0, 1]$ 上找到一个多项式 $P(x)$，其中 $x = (r-r_s)/(r_c-r_s)$，它满足六个边界条件：$P(0)=1$、$P(1)=0$、$P'(0)=0$、$P'(1)=0$、$P''(0)=0$ 和 $P''(1)=0$。这需要一个至少为 5 阶的多项式。设 $P(x) = ax^5 + bx^4 + cx^3 + dx^2 + ex + f$。\n$x=0$ 处的条件给出：\n$P(0)=f=1$\n$P'(0)=e=0$\n$P''(0)=2d=0 \\implies d=0$。\n所以，$P(x) = ax^5 + bx^4 + cx^3 + 1$。\n$x=1$ 处的条件给出了一个关于 $a, b, c$ 的线性方程组：\n1. $P(1) = a + b + c + 1 = 0$\n2. $P'(1) = 5a + 4b + 3c = 0$\n3. $P''(1) = 20a + 12b + 6c = 0 \\implies 10a + 6b + 3c = 0$\n解此方程组得到 $a=-6$，$b=15$ 和 $c=-10$。\n开关多项式为 $P(x) = -6x^5 + 15x^4 - 10x^3 + 1$。\n开关函数 $S(r)$ 在 $[r_s, r_c]$ 上定义为 $S(r) = P\\left(\\frac{r-r_s}{r_c-r_s}\\right)$。\n\n**最终评估**\n\n任务简化为对每个测试用例数值评估以下不等式：\n$$ \\left| \\int_{r_s}^{r_c} (1 - S(r)) r^3 u'(r) \\exp\\left(-\\frac{u(r)}{T}\\right) dr \\right|  \\left| 8r_c^{-3} - \\frac{16}{3}r_c^{-9} \\right| $$\n左边的积分必须进行数值计算。右边的表达式是解析计算的。对于 $r_s \\geq r_c$ 的特殊情况，积分区间为空，因此积分为 0。不等式变为 $0  \\left| 8r_c^{-3} - \\frac{16}{3}r_c^{-9} \\right|$，这对于任何有限的、非零的 $r_c$ 且参数不为零的情况都成立（在此问题中，对于所有 $r_c  0$ 都成立）。\n\n算法如下：\n1. 对于每个测试用例 $(\\rho, T, r_s, r_c)$：\n2. 计算 RHS 的值：$V_{RHS} = \\left| 8r_c^{-3} - \\frac{16}{3}r_c^{-9} \\right|$。\n3. 如果 $r_s \\geq r_c$，则 LHS 积分为 0。结果为 $0  V_{RHS}$。\n4. 如果 $r_s  r_c$，则数值计算 LHS 积分：$V_{LHS} = \\left| \\int_{r_s}^{r_c} (1-S(r)) r^3 u'(r) \\exp(-u(r)/T) dr \\right|$。\n5. 比较 $V_{LHS}  V_{RHS}$ 并记录布尔结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef u_lj(r):\n    \"\"\"\n    Calculates the Lennard-Jones potential in reduced units (epsilon=1, sigma=1).\n    u(r) = 4 * (r^-12 - r^-6)\n    \"\"\"\n    if not np.isfinite(r) or r = 0:\n        return np.inf\n    r_inv = 1.0 / r\n    r_inv6 = r_inv**6\n    return 4.0 * (r_inv6**2 - r_inv6)\n\ndef du_lj_dr(r):\n    \"\"\"\n    Calculates the derivative of the Lennard-Jones potential w.r.t. r.\n    u'(r) = 24 * (r^-7 - 2*r^-13)\n    \"\"\"\n    if not np.isfinite(r) or r = 0:\n        return -np.inf\n    r_inv = 1.0 / r\n    r_inv7 = r_inv**7\n    return 24.0 * (r_inv7 - 2.0 * r_inv7 * r_inv**6)\n\ndef switching_function(r, rs, rc):\n    \"\"\"\n    Calculates the value of the 5th-degree polynomial switching function.\n    \"\"\"\n    if r = rs:\n        return 1.0\n    if r >= rc:\n        return 0.0\n    \n    # This case is handled by the integration limits, but as a safeguard:\n    if np.isclose(rc, rs):\n        return 0.0\n\n    x = (r - rs) / (rc - rs)\n    # P(x) = a*x^5 + b*x^4 + c*x^3 + 1, with a=-6, b=15, c=-10\n    # Implemented using Horner's method for efficiency.\n    P_x = 1.0 + x**3 * (-10.0 + x * (15.0 - 6.0 * x))\n    return P_x\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # (rho, T, rs, rc)\n        (0.8, 1.2, 2.0, 2.5),\n        (0.05, 1.0, 2.0, 2.5),\n        (1.2, 0.8, 2.2, 2.5),\n        (0.8, 1.2, 1.6, 2.0),\n        (0.8, 1.2, 2.5, 2.5),\n        (0.8, 1.2, 0.0, 2.5),\n    ]\n\n    results = []\n    \n    for rho, T, rs, rc in test_cases:\n        # The inequality to check is:\n        # | integral from rs to rc of (1-S(r)) * integrand |  | analytical tail integral |\n        # where integrand is r^3 * u'(r) * exp(-u(r)/T).\n\n        # Calculate the RHS: | integral of r^3 * u'(r) from rc to infinity |\n        # This is | 8*rc^-3 - (16/3)*rc^-9 |\n        if rc = 0:\n            rhs_val = np.inf\n        else:\n            rc_inv3 = rc**(-3)\n            rc_inv9 = rc**(-9)\n            rhs_val = abs(8.0 * rc_inv3 - (16.0 / 3.0) * rc_inv9)\n\n        # Calculate the LHS: | integral from rs to rc of (1-S(r)) * integrand |\n        lhs_val = 0.0\n        if rs  rc:\n            def lhs_integrand(r):\n                S_val = switching_function(r, rs, rc)\n                u_val = u_lj(r)\n                \n                # The LJ potential is repulsive at short distances, so u(r) is large\n                # and exp(-u(r)/T) is very small. For attractive part, u_min = -1,\n                # so no overflow/underflow issues are expected for typical T.\n                exp_term = np.exp(-u_val / T)\n                \n                return (1.0 - S_val) * (r**3) * du_lj_dr(r) * exp_term\n            \n            # Use SciPy's quad integrator.\n            integral_val, _ = integrate.quad(lhs_integrand, rs, rc, limit=200)\n            lhs_val = abs(integral_val)\n\n        # For rs >= rc, the integral is 0, so lhs_val remains 0.0.\n        \n        # Perform the comparison and store the boolean result.\n        results.append(lhs_val  rhs_val)\n        \n    # Format the final output string as required.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "粗粒化模拟在介观尺度上为我们提供了深刻的洞见，但我们常常需要恢复原子级别的细节以进行更深入的分析或与其他实验数据对比。本实践将深入探讨“反向映射”（backmapping）这一高级主题，即如何从粗粒化构象生成符合物理规律的原子结构。你将实现一种随机重建方法，并使用信息论中的概念来量化此过程中引入的“结构偏差”，进而评估这种偏差对自由能计算的影响。",
            "id": "3500691",
            "problem": "您的任务是形式化并量化从粗粒化珠簧表示到原子级或联合原子结构的随机反向映射过程，如何在二面角分布中引入结构偏差，以及这种偏差如何影响预定义宏观态之间的自由能差。考虑一个由单位圆上的二面角 $\\varphi \\in [-\\pi,\\pi)$ 表示的单一扭转自由度。该系统具有一个原子级（联合原子）目标扭转势 $U_{\\mathrm{AT}}(\\varphi)$ 和一个简化的粗粒化珠簧扭转势 $U_{\\mathrm{CG}}(\\varphi)$。随机反向映射通过环绕高斯核从粗粒化角度分布构建原子级二面角，从而引入一种可调的偏差。\n\n基本原理：\n- 在绝对温度 $T$ 下，扭转坐标的玻尔兹曼分布为 $p(\\varphi) = Z^{-1} \\exp(-\\beta U(\\varphi))$，其中 $\\beta = 1/(R T)$，$R$ 是理想气体常数（单位为 $\\mathrm{kJ\\ mol^{-1}\\ K^{-1}}$），$Z = \\int_{-\\pi}^{\\pi} \\exp(-\\beta U(\\varphi))\\,d\\varphi$ 是配分函数。\n- 宏观态 $M \\subset [-\\pi,\\pi)$ 的自由能为 $F_M = - R T \\ln Z_M$，其中 $Z_M = \\int_M p(\\varphi)\\,d\\varphi$。两个宏观态 $A$ 和 $B$ 之间的自由能差为 $\\Delta F = F_B - F_A = -R T \\ln\\left(\\dfrac{Z_B}{Z_A}\\right)$。\n- 圆上的随机反向映射核由环绕正态分布建模。对于给定的平均偏差 $b$ 和标准差 $\\sigma$，该核函数为\n$$\nW(\\Delta\\varphi; b, \\sigma) = \\sum_{k=-\\infty}^{\\infty} \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{(\\Delta\\varphi - b + 2\\pi k)^2}{2\\sigma^2}\\right),\n$$\n这确保了 $\\int_{-\\pi}^{\\pi} W(\\Delta\\varphi; b, \\sigma)\\,d\\Delta\\varphi = 1$。\n- 宏观态由角度区间定义：$A$（类顺式）为 $\\{\\varphi: |\\varphi| \\le \\varphi_c\\}$，$B$（类反式）为 $\\{\\varphi: \\min(|\\varphi - \\pi|, |\\varphi + \\pi|) \\le \\varphi_c\\}$。\n\n您的程序必须严格使用上述定义，并在 $[-\\pi,\\pi)$ 的均匀网格上通过数值积分实现以下内容：\n\n1. 构建原子级目标势\n$$\nU_{\\mathrm{AT}}(\\varphi) = k_1\\big(1 - \\cos\\varphi\\big) + k_3\\big(1 - \\cos(3\\varphi)\\big),\n$$\n和粗粒化势\n$$\nU_{\\mathrm{CG}}(\\varphi) = k_{\\mathrm{CG}}\\big(1 - \\cos\\varphi\\big),\n$$\n其中所有 $k$ 参数的单位均为 $\\mathrm{kJ\\ mol^{-1}}$。\n\n2. 在均匀网格上计算归一化的原子级扭转概率密度 $P_{\\mathrm{AT}}(\\varphi) \\propto \\exp(-\\beta U_{\\mathrm{AT}}(\\varphi))$ 和归一化的粗粒化扭转密度 $P_{\\mathrm{CG}}(\\varphi) \\propto \\exp(-\\beta U_{\\mathrm{CG}}(\\varphi))$。\n\n3. 在网格上定义环绕高斯核 $W(\\Delta\\varphi; b, \\sigma)$，并通过循环卷积计算随机反向映射（有偏）的原子级重构密度\n$$\nQ(\\varphi) = \\int_{-\\pi}^{\\pi} P_{\\mathrm{CG}}(\\psi)\\, W(\\varphi - \\psi; b, \\sigma)\\, d\\psi,\n$$\n并进行归一化，使得 $\\int_{-\\pi}^{\\pi} Q(\\varphi)\\,d\\varphi = 1$。\n\n4. 计算三种自由能差：\n   - 真实的原子级自由能差 $\\Delta F_{\\mathrm{true}} = -R T \\ln\\left(\\frac{\\int_B P_{\\mathrm{AT}}(\\varphi)\\,d\\varphi}{\\int_A P_{\\mathrm{AT}}(\\varphi)\\,d\\varphi}\\right)$。\n   - 从有偏重构中测得的自由能差 $\\Delta F_{\\mathrm{meas}} = -R T \\ln\\left(\\frac{\\int_B Q(\\varphi)\\,d\\varphi}{\\int_A Q(\\varphi)\\,d\\varphi}\\right)$。\n   - 一种使用原子级与粗粒化玻尔兹曼权重之比的近似重加权估计，\n$$\nw(\\varphi) = \\frac{P_{\\mathrm{AT}}(\\varphi)}{P_{\\mathrm{CG}}(\\varphi)},\n$$\n定义为\n$$\n\\Delta F_{\\mathrm{rw}} = -R T \\ln\\left(\\frac{\\int_B w(\\varphi)\\, Q(\\varphi)\\, d\\varphi}{\\int_A w(\\varphi)\\, Q(\\varphi)\\, d\\varphi}\\right).\n$$\n\n5. 使用Kullback–Leibler散度（相对熵）量化结构偏差\n$$\nD_{\\mathrm{KL}}\\big(Q\\Vert P_{\\mathrm{AT}}\\big) = \\int_{-\\pi}^{\\pi} Q(\\varphi)\\, \\ln\\left(\\frac{Q(\\varphi)}{P_{\\mathrm{AT}}(\\varphi)}\\right)\\, d\\varphi.\n$$\n\n实现说明：\n- 在 $[-\\pi,\\pi)$ 上使用一个均匀的 $N$ 点网格，$N$ 需足够大以精确解析积分；在均匀网格上使用等效于黎曼和的梯形法则。循环卷积必须遵守周期性边界条件；为提高效率，可通过离散傅里叶变换或直接循环求和实现。确保所有密度都已归一化。\n- 为保持数值稳定性，在计算比值 $\\frac{P_{\\mathrm{AT}}(\\varphi)}{P_{\\mathrm{CG}}(\\varphi)}$ 和 $D_{\\mathrm{KL}}$ 中的对数时，向分母和密度中添加一个小的正常数 $\\varepsilon$，以避免除以零和未定义的对数，同时保持 $\\varepsilon$ 相对于1可以忽略不计。\n- 所有自由能必须以 $\\mathrm{kJ\\ mol^{-1}}$ 表示，并使用 $R = 8.314462618 \\times 10^{-3}\\ \\mathrm{kJ\\ mol^{-1}\\ K^{-1}}$ 进行计算。角度以弧度为单位。\n\n测试套件：\n对于下面的每个参数集 $(T, k_1, k_3, k_{\\mathrm{CG}}, b, \\sigma, \\varphi_c)$，计算 $\\big[D_{\\mathrm{KL}}(Q\\Vert P_{\\mathrm{AT}}),\\ \\Delta F_{\\mathrm{meas}},\\ \\Delta F_{\\mathrm{rw}},\\ \\Delta F_{\\mathrm{true}}\\big]$，其中自由能单位为 $\\mathrm{kJ\\ mol^{-1}}$，并按规定汇总结果。\n\n- 情况1（基准，轻度噪声，无偏差）：$T = 300$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 2.0$, $b = 0.0$, $\\sigma = 0.2$, $\\varphi_c = 0.3$。\n- 情况2（正平均偏差，中度噪声）：$T = 300$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 1.5$, $b = 0.4$, $\\sigma = 0.3$, $\\varphi_c = 0.3$。\n- 情况3（负平均偏差，较强噪声）：$T = 300$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 2.5$, $b = -0.6$, $\\sigma = 0.5$, $\\varphi_c = 0.3$。\n- 情况4（强平滑，小宏观态宽度）：$T = 300$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 2.0$, $b = 0.0$, $\\sigma = 1.0$, $\\varphi_c = 0.1$。\n- 情况5（较高温度，中度偏差）：$T = 500$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 2.0$, $b = 0.2$, $\\sigma = 0.4$, $\\varphi_c = 0.3$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是对应于上述一个测试用例的逗号分隔列表（同样用方括号括起），顺序与给定顺序相同。例如：\n$[ [d_1, f^{\\mathrm{meas}}_1, f^{\\mathrm{rw}}_1, f^{\\mathrm{true}}_1], [d_2, f^{\\mathrm{meas}}_2, f^{\\mathrm{rw}}_2, f^{\\mathrm{true}}_2], \\dots ]$，\n所有数值均为浮点表示，自由能单位为 $\\mathrm{kJ\\ mol^{-1}}$。",
            "solution": "The user has provided a well-defined computational problem in the domain of statistical mechanics and coarse-grained modeling, which requires validation before proceeding to a solution.\n\n### Step 1: Problem Validation\n\nThe problem statement is critically evaluated against the specified criteria.\n\n-   **Extracted Givens**:\n    -   **System**: A single torsional degree of freedom $\\varphi \\in [-\\pi, \\pi)$.\n    -   **Physical Model**: Boltzmann statistics with probability density $p(\\varphi) \\propto \\exp(-\\beta U(\\varphi))$, where $\\beta = 1/(R T)$ and $R = 8.314462618 \\times 10^{-3} \\ \\mathrm{kJ\\ mol^{-1}\\ K^{-1}}$.\n    -   **Potentials**: Atomistic potential $U_{\\mathrm{AT}}(\\varphi) = k_1(1 - \\cos\\varphi) + k_3(1 - \\cos(3\\varphi))$ and coarse-grained potential $U_{\\mathrm{CG}}(\\varphi) = k_{\\mathrm{CG}}(1 - \\cos\\varphi)$.\n    -   **Backmapping**: A stochastic process modeled by a wrapped normal kernel $W(\\Delta\\varphi; b, \\sigma) = \\sum_{k=-\\infty}^{\\infty} \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{(\\Delta\\varphi - b + 2\\pi k)^2}{2\\sigma^2}\\right)$. The backmapped distribution is $Q(\\varphi) = \\int_{-\\pi}^{\\pi} P_{\\mathrm{CG}}(\\psi)\\, W(\\varphi - \\psi; b, \\sigma)\\, d\\psi$.\n    -   **Macrostates**: $A = \\{\\varphi: |\\varphi| \\le \\varphi_c\\}$, $B = \\{\\varphi: \\min(|\\varphi - \\pi|, |\\varphi + \\pi|) \\le \\varphi_c\\}$.\n    -   **Observables**:\n        1.  Free energy difference: $\\Delta F = F_B - F_A = -R T \\ln(\\int_B p(\\varphi)d\\varphi / \\int_A p(\\varphi)d\\varphi)$, computed for $p=P_{\\mathrm{AT}}$ ($\\Delta F_{\\mathrm{true}}$) and $p=Q$ ($\\Delta F_{\\mathrm{meas}}$).\n        2.  Reweighted free energy difference: $\\Delta F_{\\mathrm{rw}} = -R T \\ln(\\int_B w(\\varphi)Q(\\varphi)d\\varphi / \\int_A w(\\varphi)Q(\\varphi)d\\varphi)$, with $w(\\varphi) = P_{\\mathrm{AT}}(\\varphi)/P_{\\mathrm{CG}}(\\varphi)$.\n        3.  Kullback-Leibler divergence: $D_{\\mathrm{KL}}(Q\\Vert P_{\\mathrm{AT}}) = \\int_{-\\pi}^{\\pi} Q(\\varphi)\\, \\ln(Q(\\varphi)/P_{\\mathrm{AT}}(\\varphi))\\, d\\varphi$.\n    -   **Numerical Method**: Uniform grid on $[-\\pi, \\pi)$, trapezoidal rule for integration, circular convolution, and use of a small constant $\\varepsilon$ for numerical stability.\n    -   **Test Data**: Five sets of parameters $(T, k_1, k_3, k_{\\mathrm{CG}}, b, \\sigma, \\varphi_c)$ are provided.\n\n-   **Validation Verdict**:\n    1.  **Scientifically Grounded**: The problem is based on fundamental principles of statistical mechanics (Boltzmann distribution, free energy) and standard techniques in computational chemistry (coarse-graining, reweighting). The potential forms and backmapping kernel are standard. The problem is scientifically sound.\n    2.  **Well-Posed**: The problem is mathematically well-defined. All quantities are specified by explicit formulas. Given the input parameters, a unique and meaningful solution exists.\n    3.  **Objective**: The language is precise and unbiased. All terms are formally defined.\n    4.  **Complete and Consistent**: All necessary constants, formulas, and parameters are provided. While numerical details like the grid size $N$ and the truncation of the infinite sum for $W$ are left to the implementer, this is standard for numerical problems and does not constitute incompleteness. The problem is self-contained and consistent.\n\nThe problem is deemed **valid**. A solution will be developed.\n\n### Step 2: Solution Design\n\nThe solution involves numerically computing the specified physical quantities. This requires discretization of the continuous degree of freedom $\\varphi$ and implementation of numerical algorithms for integration and convolution.\n\n1.  **Discretization**: The continuous domain $\\varphi \\in [-\\pi, \\pi)$ is discretized into a uniform grid of $N$ points. Let $\\varphi_j = -\\pi + j \\cdot \\Delta\\varphi$ for $j = 0, \\dots, N-1$, where the grid spacing is $\\Delta\\varphi = 2\\pi/N$. A sufficiently large $N$ (e.g., $N=4096$) is chosen for accuracy. For a periodic function on a uniform grid, the trapezoidal rule for integration over the full period simplifies to a sum of the function values multiplied by $\\Delta\\varphi$.\n\n2.  **Probability Densities**:\n    -   The potentials $U_{\\mathrm{AT}}(\\varphi_j)$ and $U_{\\mathrm{CG}}(\\varphi_j)$ are evaluated at each grid point.\n    -   The corresponding unnormalized Boltzmann probability densities are calculated: $p'_{\\mathrm{AT}}(\\varphi_j) = \\exp(-\\beta U_{\\mathrm{AT}}(\\varphi_j))$ and $p'_{\\mathrm{CG}}(\\varphi_j) = \\exp(-\\beta U_{\\mathrm{CG}}(\\varphi_j))$, with $\\beta = 1/(RT)$.\n    -   The normalization constant (partition function) is computed via numerical integration, e.g., $Z_{\\mathrm{AT}} = \\sum_{j=0}^{N-1} p'_{\\mathrm{AT}}(\\varphi_j) \\Delta\\varphi$.\n    -   The normalized probability densities are then $P_{\\mathrm{AT}}(\\varphi_j) = p'_{\\mathrm{AT}}(\\varphi_j) / Z_{\\mathrm{AT}}$ and $P_{\\mathrm{CG}}(\\varphi_j) = p'_{\\mathrm{CG}}(\\varphi_j) / Z_{\\mathrm{CG}}$.\n\n3.  **Backmapped Density $Q(\\varphi)$**:\n    -   The backmapped density $Q(\\varphi)$ is obtained by the circular convolution of the coarse-grained density $P_{\\mathrm{CG}}(\\varphi)$ with the wrapped normal kernel $W(\\varphi; b, \\sigma)$.\n    -   First, the kernel $W(\\varphi_j; b, \\sigma)$ is evaluated on the grid. The infinite sum in its definition is truncated to a finite range, e.g., $k \\in \\{-5, \\dots, 5\\}$, which provides sufficient accuracy for the given $\\sigma$ values. The discretized kernel is also normalized to ensure its integral is unity.\n    -   The circular convolution is most efficiently performed using the Fast Fourier Transform (FFT) via the convolution theorem: $\\mathcal{F}\\{f * g\\} = \\mathcal{F}\\{f\\} \\cdot \\mathcal{F}\\{g\\}$. The discrete convolution integral $Q(\\varphi_i) \\approx \\sum_j P_{\\mathrm{CG}}(\\varphi_j) W(\\varphi_i - \\varphi_j) \\Delta\\varphi$ is calculated as $Q = \\text{IDFT}(\\text{DFT}(P_{\\mathrm{CG}}) \\cdot \\text{DFT}(W)) \\cdot \\Delta\\varphi$, where IDFT and DFT denote the inverse and forward discrete Fourier transforms, respectively. The result $Q$ is a normalized probability density on the grid.\n\n4.  **Numerical Integration and Macrostates**:\n    -   The macrostates $A$ and $B$ are represented by boolean masks on the grid.\n        -   $A$: `mask_A` is true where $|\\varphi_j| \\le \\varphi_c$.\n        -   $B$: `mask_B` is true where $|\\varphi_j| \\ge \\pi - \\varphi_c$. This is equivalent to the distance on the circle to $\\pi$ being less than or equal to $\\varphi_c$.\n    -   Integrals over a macrostate $M$ are computed by summing the values of the integrand at the grid points within $M$ and multiplying by $\\Delta\\varphi$. For example, $\\int_A P_{\\mathrm{AT}}(\\varphi)d\\varphi \\approx \\sum_{j \\in A} P_{\\mathrm{AT}}(\\varphi_j) \\Delta\\varphi$.\n\n5.  **Free Energy and KL Divergence Calculation**:\n    -   **$\\Delta F_{\\mathrm{true}}$ and $\\Delta F_{\\mathrm{meas}}$**: The integrated probabilities for states $A$ and $B$, denoted $Z_{A}$ and $Z_{B}$, are calculated for both $P_{\\mathrm{AT}}$ and $Q$. The free energy differences are then computed using the formula $\\Delta F = -RT\\ln(Z_B/Z_A)$. A small constant $\\varepsilon$ is added to the arguments of the logarithm to prevent numerical errors if a state has zero probability.\n    -   **$\\Delta F_{\\mathrm{rw}}$**: The reweighting factor $w(\\varphi_j) = P_{\\mathrm{AT}}(\\varphi_j) / (P_{\\mathrm{CG}}(\\varphi_j) + \\varepsilon)$ is computed. Then, the integrals of the product $w(\\varphi)Q(\\varphi)$ over macrostates $A$ and $B$ are calculated. $\\Delta F_{\\mathrm{rw}}$ is found using these integrated values in the free energy formula.\n    -   **$D_{\\mathrm{KL}}(Q\\Vert P_{\\mathrm{AT}})$**: The KL divergence is computed by numerically integrating the expression $Q(\\varphi_j)\\ln((Q(\\varphi_j)+\\varepsilon)/(P_{\\mathrm{AT}}(\\varphi_j)+\\varepsilon))$ over the entire grid.\n\nThis structured numerical procedure provides a robust method for computing all required quantities for each test case.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It iterates through each parameter set, computes the specified quantities,\n    and prints the formatted results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, k1, k3, k_CG, b, sigma, phi_c)\n        (300.0, 2.5, 1.0, 2.0, 0.0, 0.2, 0.3),\n        (300.0, 2.5, 1.0, 1.5, 0.4, 0.3, 0.3),\n        (300.0, 2.5, 1.0, 2.5, -0.6, 0.5, 0.3),\n        (300.0, 2.5, 1.0, 2.0, 0.0, 1.0, 0.1),\n        (500.0, 2.5, 1.0, 2.0, 0.2, 0.4, 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _calculate_observables(case)\n        results.append(result)\n\n    # Format the final output string as a list of lists.\n    # Each sublist is a comma-separated string of numbers.\n    # The final string is a comma-separated list of these sublists.\n    sub_lists_as_strings = []\n    for res in results:\n        sub_list_str = f\"[{','.join([f'{x:.6f}' for x in res])}]\"\n        sub_lists_as_strings.append(sub_list_str)\n    \n    final_output = f\"[{','.join(sub_lists_as_strings)}]\"\n    print(final_output)\n\ndef _wrapped_normal(delta_phi, b, sigma, n_points):\n    \"\"\"\n    Computes the wrapped normal distribution on a grid.\n    The infinite sum is truncated to k in [-5, 5].\n    \"\"\"\n    # Truncation range for the sum\n    k_range = np.arange(-5, 6)\n    \n    # Use broadcasting for efficient computation over the grid and k-range\n    # delta_phi shape: (n_points,) -> (n_points, 1)\n    # k_range shape: (11,) -> (1, 11)\n    numerator = -(delta_phi[:, None] - b + 2.0 * np.pi * k_range[None, :])**2\n    denominator = 2.0 * sigma**2\n    gaussians = np.exp(numerator / denominator)\n    \n    # Sum over the k-dimension\n    summed_gaussians = np.sum(gaussians, axis=1)\n    prefactor = 1.0 / (np.sqrt(2.0 * np.pi) * sigma)\n    \n    return prefactor * summed_gaussians\n\ndef _calculate_observables(params):\n    \"\"\"\n    Performs the full calculation for a single parameter set.\n    \"\"\"\n    T, k1, k3, k_CG, b, sigma, phi_c = params\n    \n    # Constants and numerical parameters\n    R = 8.314462618e-3  # kJ mol^-1 K^-1\n    N = 4096              # Number of grid points\n    epsilon = 1e-16       # Small constant for numerical stability\n\n    beta = 1.0 / (R * T)\n\n    # 1. Discretize the domain\n    phi = np.linspace(-np.pi, np.pi, N, endpoint=False)\n    d_phi = 2.0 * np.pi / N\n\n    # 2. Compute potentials and probability densities\n    # Atomistic (AT) model\n    U_at = k1 * (1.0 - np.cos(phi)) + k3 * (1.0 - np.cos(3.0 * phi))\n    boltz_at = np.exp(-beta * U_at)\n    Z_at_total = np.sum(boltz_at) * d_phi\n    P_at = boltz_at / Z_at_total\n\n    # Coarse-grained (CG) model\n    U_cg = k_CG * (1.0 - np.cos(phi))\n    boltz_cg = np.exp(-beta * U_cg)\n    Z_cg_total = np.sum(boltz_cg) * d_phi\n    P_cg = boltz_cg / Z_cg_total\n\n    # 3. Compute backmapped density Q via circular convolution\n    W_kernel = _wrapped_normal(phi, b, sigma, N)\n    # Ensure kernel is normalized on the discrete grid\n    W_kernel /= (np.sum(W_kernel) * d_phi)\n\n    # FFT-based circular convolution\n    Q_unnormalized = np.real(np.fft.ifft(np.fft.fft(P_cg) * np.fft.fft(W_kernel)))\n    # The convolution result needs to be scaled by the integration element d_phi\n    Q = Q_unnormalized * d_phi\n    # Re-normalize Q to be safe against minor numerical drift\n    Q /= (np.sum(Q) * d_phi)\n\n    # 4. Define macrostates and compute integrals for free energies\n    mask_A = np.abs(phi) = phi_c\n    mask_B = np.abs(phi) >= np.pi - phi_c\n\n    # For Delta F_true (from P_at)\n    prob_A_at = np.sum(P_at[mask_A]) * d_phi\n    prob_B_at = np.sum(P_at[mask_B]) * d_phi\n    \n    # For Delta F_meas (from Q)\n    prob_A_q = np.sum(Q[mask_A]) * d_phi\n    prob_B_q = np.sum(Q[mask_B]) * d_phi\n    \n    # For Delta F_rw (reweighting)\n    w = P_at / (P_cg + epsilon)\n    prob_A_rw = np.sum(w[mask_A] * Q[mask_A]) * d_phi\n    prob_B_rw = np.sum(w[mask_B] * Q[mask_B]) * d_phi\n\n    # Compute free energy differences\n    delta_F_true = -R * T * np.log((prob_B_at + epsilon) / (prob_A_at + epsilon))\n    delta_F_meas = -R * T * np.log((prob_B_q + epsilon) / (prob_A_q + epsilon))\n    delta_F_rw = -R * T * np.log((prob_B_rw + epsilon) / (prob_A_rw + epsilon))\n\n    # 5. Compute Kullback-Leibler divergence\n    integrand_kl = Q * np.log((Q + epsilon) / (P_at + epsilon))\n    D_kl = np.sum(integrand_kl) * d_phi\n\n    return [D_kl, delta_F_meas, delta_F_rw, delta_F_true]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}