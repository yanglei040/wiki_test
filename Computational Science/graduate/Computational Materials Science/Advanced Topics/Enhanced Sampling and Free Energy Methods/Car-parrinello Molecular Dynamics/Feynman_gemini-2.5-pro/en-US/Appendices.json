{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of a successful Car-Parrinello simulation is the proper choice of the fictitious electronic mass, $\\mu$. This parameter must be small enough to ensure the electronic degrees of freedom evolve much faster than the ions, maintaining adiabatic separation, but large enough to allow for a practical integration time step. This first exercise  provides essential practice in calculating the upper bound for $\\mu$ based on the physical properties of the system and a desired level of adiabaticity.",
            "id": "3436526",
            "problem": "Consider a Car-Parrinello molecular dynamics (CPMD) simulation of an insulating solid. The fictitious electronic mass parameter, denoted by $\\mu$, controls the inertia of the electronic degrees of freedom in the Car-Parrinello Lagrangian. To ensure adiabatic decoupling between the fast electronic oscillations and the slower ionic motion, impose a target separation factor of the electronic angular frequency to the highest ionic angular frequency satisfying $\\omega_{e}/\\omega_{\\mathrm{ion}} \\geq 10$. Assume the material has an electronic energy gap $E_g = 3\\,\\mathrm{eV}$ and the highest ionic vibrational wavenumber is $\\tilde{\\nu}_{\\mathrm{ion}} = 1500\\,\\mathrm{cm}^{-1}$. Work in consistent units and treat the ionic frequency as an angular frequency.\n\nUse fundamental principles to derive the upper bound on $\\mu$ implied by the decoupling criterion. Then evaluate this bound numerically using the following constants: the speed of light $c = 2.99792458 \\times 10^{8}\\,\\mathrm{m\\,s^{-1}}$ and the electronvolt-to-joule conversion $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$. Express the final upper bound for $\\mu$ in $\\mathrm{J\\,s^{2}}$. Round your answer to three significant figures.",
            "solution": "The problem statement has been validated and is deemed sound, well-posed, and scientifically grounded. It presents a standard scenario in computational materials science concerning the choice of parameters in a Car-Parrinello molecular dynamics (CPMD) simulation. All necessary data are provided, and the objective is clear. There is a minor ambiguity in the phrasing \"treat the ionic frequency as an angular frequency\" following the provision of a wavenumber. This will be interpreted in the physically correct manner, which is to calculate the angular frequency $\\omega_{\\mathrm{ion}}$ from the given wavenumber $\\tilde{\\nu}_{\\mathrm{ion}}$ using the fundamental relationship $\\omega = 2\\pi c \\tilde{\\nu}$. A direct numerical equivalence would be physically nonsensical as it would correspond to an extremely low vibrational frequency, inconsistent with the provided wavenumber. With this clarification, the problem is entirely valid.\n\nThe Car-Parrinello molecular dynamics method evolves both ionic positions and electronic orbitals simultaneously by introducing a fictitious kinetic energy for the electronic degrees of freedom. This fictitious dynamics is governed by a user-defined parameter, the fictitious mass $\\mu$. The total Lagrangian is of the form:\n$$L_{CP} = \\frac{1}{2}\\mu \\sum_i \\int |\\dot{\\psi}_i(\\mathbf{r},t)|^2 d\\mathbf{r} + \\frac{1}{2}\\sum_I M_I |\\dot{\\mathbf{R}}_I(t)|^2 - E[\\{\\psi_i\\}, \\{\\mathbf{R}_I\\}]$$\nwhere $\\psi_i$ are the electronic orbitals, $\\mathbf{R}_I$ are the ionic positions, and $E[\\{\\psi_i\\}, \\{\\mathbf{R}_I\\}]$ is the total potential energy from density functional theory.\n\nFor the CPMD scheme to be valid, the electronic subsystem must remain close to its ground state for any given ionic configuration. This is the principle of adiabatic decoupling. It requires that the characteristic frequency of the fictitious electronic motion, $\\omega_e$, be significantly higher than the highest frequency of the physical ionic motion, $\\omega_{\\mathrm{ion}}$. The problem specifies this separation with the criterion $\\omega_e / \\omega_{\\mathrm{ion}} \\geq 10$.\n\nFor an insulating system with an electronic energy gap $E_g$ between the highest occupied and lowest unoccupied molecular orbitals (or valence and conduction bands), the lowest frequency of the fictitious electronic dynamics can be shown to be related to $E_g$ and $\\mu$ by:\n$$\\omega_e = \\sqrt{\\frac{2E_g}{\\mu}}$$\nThe unit of the fictitious mass $\\mu$ is energy $\\times$ time$^2$, which is $\\mathrm{J\\,s^2}$ in SI units, ensuring dimensional consistency.\n\nThe highest physical ionic vibrational angular frequency, $\\omega_{\\mathrm{ion}}$, is calculated from the given highest ionic vibrational wavenumber, $\\tilde{\\nu}_{\\mathrm{ion}}$, using the relation:\n$$\\omega_{\\mathrm{ion}} = 2\\pi c \\tilde{\\nu}_{\\mathrm{ion}}$$\nwhere $c$ is the speed of light.\n\nWe can now combine these relationships to find the upper bound on $\\mu$. The adiabaticity condition is:\n$$\\frac{\\omega_e}{\\omega_{\\mathrm{ion}}} \\geq 10$$\nSubstituting the expression for $\\omega_e$:\n$$\\frac{\\sqrt{\\frac{2E_g}{\\mu}}}{\\omega_{\\mathrm{ion}}} \\geq 10$$\nTo find the constraint on $\\mu$, we rearrange the inequality:\n$$\\sqrt{\\frac{2E_g}{\\mu}} \\geq 10\\,\\omega_{\\mathrm{ion}}$$\nSquaring both sides gives:\n$$\\frac{2E_g}{\\mu} \\geq 100\\,\\omega_{\\mathrm{ion}}^2$$\nFinally, solving for $\\mu$ yields the upper bound:\n$$\\mu \\leq \\frac{2E_g}{100\\,\\omega_{\\mathrm{ion}}^2} = \\frac{E_g}{50\\,\\omega_{\\mathrm{ion}}^2}$$\nThus, the maximum allowed value for the fictitious mass is $\\mu_{\\mathrm{max}} = \\frac{E_g}{50\\,\\omega_{\\mathrm{ion}}^2}$.\n\nNext, we substitute the expression for $\\omega_{\\mathrm{ion}}$:\n$$\\mu_{\\mathrm{max}} = \\frac{E_g}{50\\,(2\\pi c \\tilde{\\nu}_{\\mathrm{ion}})^2}$$\n\nWe now evaluate this expression numerically using the provided constants, ensuring all quantities are in base SI units.\nThe given values are:\n- Electronic energy gap: $E_g = 3\\,\\mathrm{eV}$\n- Highest ionic vibrational wavenumber: $\\tilde{\\nu}_{\\mathrm{ion}} = 1500\\,\\mathrm{cm}^{-1}$\n- Speed of light: $c = 2.99792458 \\times 10^{8}\\,\\mathrm{m\\,s^{-1}}$\n- Conversion factor: $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$\n\nFirst, we convert the given values to SI units:\n$$E_g = 3\\,\\mathrm{eV} \\times 1.602176634 \\times 10^{-19}\\,\\frac{\\mathrm{J}}{\\mathrm{eV}} = 4.806529902 \\times 10^{-19}\\,\\mathrm{J}$$\n$$\\tilde{\\nu}_{\\mathrm{ion}} = 1500\\,\\mathrm{cm}^{-1} \\times \\frac{100\\,\\mathrm{cm}}{1\\,\\mathrm{m}} = 1.5 \\times 10^{5}\\,\\mathrm{m}^{-1}$$\n\nNow, we calculate the highest ionic angular frequency, $\\omega_{\\mathrm{ion}}$:\n$$\\omega_{\\mathrm{ion}} = 2\\pi (2.99792458 \\times 10^{8}\\,\\mathrm{m\\,s^{-1}})(1.5 \\times 10^{5}\\,\\mathrm{m}^{-1})$$\n$$\\omega_{\\mathrm{ion}} \\approx 2.82539066 \\times 10^{14}\\,\\mathrm{s}^{-1}$$\n\nWith $\\omega_{\\mathrm{ion}}$, we can calculate its square:\n$$\\omega_{\\mathrm{ion}}^2 \\approx (2.82539066 \\times 10^{14}\\,\\mathrm{s}^{-1})^2 \\approx 7.9828333 \\times 10^{28}\\,\\mathrm{s}^{-2}$$\n\nFinally, we compute the upper bound for $\\mu$:\n$$\\mu_{\\mathrm{max}} = \\frac{E_g}{50\\,\\omega_{\\mathrm{ion}}^2} = \\frac{4.806529902 \\times 10^{-19}\\,\\mathrm{J}}{50 \\times (7.9828333 \\times 10^{28}\\,\\mathrm{s}^{-2})}$$\n$$\\mu_{\\mathrm{max}} = \\frac{4.806529902 \\times 10^{-19}}{3.99141665 \\times 10^{30}}\\,\\mathrm{J\\,s^2}$$\n$$\\mu_{\\mathrm{max}} \\approx 1.204207 \\times 10^{-49}\\,\\mathrm{J\\,s^2}$$\nRounding the result to three significant figures, we get:\n$$\\mu_{\\mathrm{max}} \\approx 1.20 \\times 10^{-49}\\,\\mathrm{J\\,s^2}$$\nThis value represents the maximum fictitious electronic mass that can be used in the simulation while satisfying the specified adiabatic decoupling criterion. A larger value of $\\mu$ would result in slower fictitious electronic dynamics, risking a spurious transfer of energy from the electronic subsystem to the ionic subsystem and a breakdown of the Born-Oppenheimer approximation.",
            "answer": "$$\\boxed{1.20 \\times 10^{-49}}$$"
        },
        {
            "introduction": "While CPMD is powerful for insulating systems, it faces a fundamental challenge with metals, where the vanishing electronic energy gap can lead to a catastrophic breakdown of adiabaticity. This occurs when the fictitious electronic frequency accidentally matches a physical vibrational frequency of the ions, causing a resonant transfer of energy that destabilizes the simulation. This computational experiment  allows you to build a simplified model of this phenomenon, providing direct insight into the mechanism of this failure and the effectiveness of common remedies.",
            "id": "3436495",
            "problem": "You are asked to design and implement a minimal, fully specified computational experiment that captures the essence of Car–Parrinello molecular dynamics (CPMD) breakdown in metallic systems when the energy gap approaches zero. The target phenomenon is resonant energy transfer between ionic and electronic degrees of freedom when the fictitious electronic natural frequency approximately matches the ionic vibrational frequency, and the evaluation of remedies such as fractional occupation smearing and reducing the fictitious electronic mass. The experiment must be formulated as a purely mathematical model, derived from first principles of classical Lagrangian mechanics and linear response, and implemented as a single, runnable program.\n\nStart from the following context-appropriate foundational base:\n- The Car–Parrinello approach introduces a fictitious electronic mass, denoted by $\\mu$, and treats the electronic degrees of freedom dynamically alongside the ionic coordinates to approximate adiabatic separation. The adiabatic separation fails when the system is metallic, that is when the electronic energy gap $E_g$ approaches zero, allowing spurious energy flow from ionic motion into electronic modes.\n- The Euler–Lagrange equations derived from a quadratic Lagrangian with bilinear coupling yield coupled harmonic oscillator equations for the ionic coordinate and an effective electronic coordinate in a linear-response approximation.\n- The natural frequency of a harmonic oscillator with mass $m$ and stiffness $k$ is $\\omega = \\sqrt{k/m}$.\n\nConstruct the following dimensionless surrogate model that captures the resonant mechanism and remedies:\n1. Consider a single ionic coordinate $x(t)$ with mass $M$ and vibrational angular frequency $\\omega_i$ coupled to a single effective electronic coordinate $y(t)$ with fictitious mass $\\mu$ and an intrinsic stiffness proportional to the energy gap $E_g$. In a quadratic expansion of the energy to second order in small deviations, take the potential energy as\n$$\nV(x,y) = \\frac{1}{2} M \\omega_i^2 x^2 + \\frac{1}{2} k_{\\mathrm{el}} y^2 + \\kappa x y,\n$$\nwith the coupling constant $\\kappa$ and $k_{\\mathrm{el}} \\propto E_g$.\n2. Let the electronic stiffness be $k_{\\mathrm{el}} = E_g$ in dimensionless units, so the fictitious electronic angular frequency is\n$$\n\\omega_{\\mathrm{el}} = \\sqrt{\\frac{k_{\\mathrm{el}}}{\\mu}} = \\sqrt{\\frac{E_g}{\\mu}}.\n$$\n3. To represent the effect of fractional occupation smearing $f(\\epsilon)$ at finite electronic temperature, include a phenomenological Rayleigh dissipation function for the electronic mode,\n$$\n\\mathcal{R} = \\frac{1}{2} \\eta \\dot{y}^2,\n$$\nwhere $\\eta$ is an effective damping coefficient that increases monotonically with the smearing width (or electronic temperature). This produces a linear friction term $\\eta \\dot{y}$ in the electronic equation of motion.\n\nUnder these assumptions, and setting $M = 1$ (nondimensionalization), the coupled equations of motion become\n$$\n\\ddot{x} + \\omega_i^2 x + \\frac{\\kappa}{M} y = 0, \\quad \\ddot{y} + \\frac{\\eta}{\\mu} \\dot{y} + \\omega_{\\mathrm{el}}^2 y + \\frac{\\kappa}{\\mu} x = 0,\n$$\nwith the initial conditions\n$$\nx(0) = x_0, \\quad \\dot{x}(0) = v_{x,0}, \\quad y(0) = y_0, \\quad \\dot{y}(0) = v_{y,0}.\n$$\nDefine the instantaneous ionic energy (excluding coupling) as\n$$\nE_i(t) = \\frac{1}{2} M \\dot{x}(t)^2 + \\frac{1}{2} M \\omega_i^2 x(t)^2,\n$$\nand the initial ionic energy $E_i(0)$ accordingly. Define the diagnostic quantity for CP breakdown as the fractional ionic energy transfer\n$$\n\\Phi = \\frac{E_i(0) - \\min_{t \\in [0,T]} E_i(t)}{E_i(0)},\n$$\nover a finite simulation horizon $[0,T]$. Large values of $\\Phi$ indicate significant energy flow from the ionic mode to the electronic mode (CP breakdown), whereas remedies should reduce $\\Phi$.\n\nImplement a fourth-order Runge–Kutta time integration of the above system to compute $\\Phi$ for a set of test cases. Use nondimensional units throughout, with $M = 1$ and $x_0 = 1$, $v_{x,0} = 0$, $y_0 = 0$, $v_{y,0} = 0$. Use a uniform time step $\\Delta t$ and total time $T$ held fixed across cases. If the amplitude in the $E_g \\to 0$ boundary case grows numerically unstable, terminate early when $|x|$ or $|y|$ exceeds a large threshold and report $\\Phi$ computed up to that point.\n\nYour program must compute $\\Phi$ for the following test suite, which probes resonance, remedies, and edge cases:\n- Case A (resonant baseline): $\\omega_i = 0.2$, $E_g = 0.2$, $\\mu = 5.0$, $\\kappa = 0.05$, $\\eta = 0.0$, $T = 50.0$, $\\Delta t = 0.01$. This sets $\\omega_{\\mathrm{el}} \\approx \\omega_i$ and should exhibit strong resonant transfer.\n- Case B (reduced $\\mu$ remedy): $\\omega_i = 0.2$, $E_g = 0.2$, $\\mu = 0.5$, $\\kappa = 0.05$, $\\eta = 0.0$, $T = 50.0$, $\\Delta t = 0.01$. Reducing $\\mu$ increases $\\omega_{\\mathrm{el}}$, detuning resonance.\n- Case C (smearing remedy): $\\omega_i = 0.2$, $E_g = 0.2$, $\\mu = 5.0$, $\\kappa = 0.05$, $\\eta = 0.1$, $T = 50.0$, $\\Delta t = 0.01$. A finite $\\eta$ models damping from fractional occupation smearing $f(\\epsilon)$, reducing resonant transfer.\n- Case D (gapless boundary): $\\omega_i = 0.2$, $E_g = 0.0$, $\\mu = 5.0$, $\\kappa = 0.05$, $\\eta = 0.0$, $T = 50.0$, $\\Delta t = 0.01$. This probes the $E_g \\to 0$ limit; instability can occur.\n- Case E (weak coupling): $\\omega_i = 0.2$, $E_g = 0.2$, $\\mu = 5.0$, $\\kappa = 0.001$, $\\eta = 0.0$, $T = 50.0$, $\\Delta t = 0.01$. This tests that vanishing coupling suppresses transfer even near resonance.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC,resultD,resultE]\"), where each entry is the computed value of $\\Phi$ for the corresponding case, represented as a float. No additional text should be printed. All quantities are nondimensional; no physical units are required.",
            "solution": "The problem presents a valid and well-posed computational experiment to model the breakdown of Car–Parrinello molecular dynamics (CPMD) in metallic systems. It is scientifically grounded in the principles of classical mechanics and linear response theory, providing a simplified yet mechanistically correct surrogate for a complex quantum phenomenon. The problem is self-contained, with all necessary parameters, equations, and initial conditions clearly specified. I will proceed with the solution.\n\nThe core of the problem is to solve a system of coupled linear second-order ordinary differential equations (ODEs) and analyze the energy transfer between the modes. The solution methodology involves four principal steps: formalizing the equations of motion into a state-space representation, numerically integrating these equations over time, calculating the diagnostic quantity representing energy transfer, and applying this procedure to the specified test cases.\n\n### 1. State-Space Formulation of the Equations of Motion\n\nThe provided dynamical system consists of two coupled second-order ODEs for the ionic coordinate $x(t)$ and the fictitious electronic coordinate $y(t)$:\n$$\n\\ddot{x} + \\omega_i^2 x + \\frac{\\kappa}{M} y = 0\n$$\n$$\n\\ddot{y} + \\frac{\\eta}{\\mu} \\dot{y} + \\omega_{\\mathrm{el}}^2 y + \\frac{\\kappa}{\\mu} x = 0\n$$\nwhere $\\omega_{\\mathrm{el}} = \\sqrt{E_g/\\mu}$.\nFor numerical integration, it is standard practice to convert this system into a set of first-order ODEs. We define a state vector $S(t)$ that contains the positions and velocities of both coordinates:\n$$\nS(t) = \\begin{bmatrix} s_0(t) \\\\ s_1(t) \\\\ s_2(t) \\\\ s_3(t) \\end{bmatrix} = \\begin{bmatrix} x(t) \\\\ \\dot{x}(t) \\\\ y(t) \\\\ \\dot{y}(t) \\end{bmatrix}\n$$\nThe time evolution of the system is then described by the matrix equation $\\dot{S}(t) = f(t, S(t))$, where $f$ is a function that returns the time derivative of the state vector. By definition, $\\dot{s}_0 = \\dot{x} = s_1$ and $\\dot{s}_2 = \\dot{y} = s_3$. The second derivatives are given by the equations of motion:\n$$\n\\dot{s}_1 = \\ddot{x} = -\\omega_i^2 s_0 - \\frac{\\kappa}{M} s_2\n$$\n$$\n\\dot{s}_3 = \\ddot{y} = -\\frac{\\kappa}{\\mu} s_0 - \\omega_{\\mathrm{el}}^2 s_2 - \\frac{\\eta}{\\mu} s_3\n$$\nThis gives the complete first-order system to be solved, with the specified initial condition vector $S(0) = [x_0, v_{x,0}, y_0, v_{y,0}]^T = [1, 0, 0, 0]^T$ and $M=1$.\n\n### 2. Numerical Integration via Fourth-Order Runge–Kutta (RK4)\n\nThe time evolution of the state vector $S(t)$ from an initial time $t_n$ to $t_{n+1} = t_n + \\Delta t$ is computed using the fourth-order Runge–Kutta (RK4) method. This is a robust and widely-used numerical scheme that offers high accuracy for a given time step $\\Delta t$. For a generic ODE $\\dot{S} = f(S)$, a single RK4 step is calculated as follows:\n$$\n\\begin{align*}\nk_1 &= \\Delta t \\cdot f(S_n) \\\\\nk_2 &= \\Delta t \\cdot f(S_n + k_1/2) \\\\\nk_3 &= \\Delta t \\cdot f(S_n + k_2/2) \\\\\nk_4 &= \\Delta t \\cdot f(S_n + k_3) \\\\\nS_{n+1} &= S_n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n$$\nThis algorithm is implemented to propagate the state vector $S(t)$ from $t=0$ to the final time $T$ in discrete steps of $\\Delta t$. A check is included to terminate the simulation if the amplitude of either coordinate, $|x(t)|$ or $|y(t)|$, exceeds a large threshold (e.g., $100$), which indicates numerical instability, particularly relevant for the gapless case ($E_g=0$).\n\n### 3. Calculation of the Diagnostic Quantity $\\Phi$\n\nThe primary diagnostic, $\\Phi$, measures the fractional energy transferred away from the ionic oscillator. The instantaneous energy of the ionic mode is defined as:\n$$\nE_i(t) = \\frac{1}{2} M \\dot{x}(t)^2 + \\frac{1}{2} M \\omega_i^2 x(t)^2\n$$\nThe value of $\\Phi$ is calculated over the simulation time $[0, T]$:\n$$\n\\Phi = \\frac{E_i(0) - \\min_{t \\in [0,T]} E_i(t)}{E_i(0)}\n$$\nThe algorithm proceeds as follows:\n1.  Calculate the initial ionic energy, $E_i(0)$, using the initial conditions $x(0)=1, \\dot{x}(0)=0$. This yields $E_i(0) = \\frac{1}{2} M \\omega_i^2$.\n2.  Initialize a variable $\\min E_i$ to $E_i(0)$.\n3.  During the RK4 time-stepping loop, after each step, calculate the current ionic energy $E_i(t)$ using the newly computed state components $x(t)$ and $\\dot{x}(t)$.\n4.  Update $\\min E_i = \\min(\\min E_i, E_i(t))$.\n5.  After the simulation completes (or terminates due to instability), compute the final value of $\\Phi$ using the recorded initial and minimum ionic energies. If $E_i(0)=0$ (which is not the case here), $\\Phi$ would be $0$.\n\n### 4. Implementation for Test Suite\n\nThe above procedure is encapsulated into a function that accepts the physical parameters ($\\omega_i, E_g, \\mu, \\kappa, \\eta$) and simulation parameters ($T, \\Delta t$) as input. This function is then called for each of the five test cases (A-E) specified in the problem statement. The resulting $\\Phi$ value for each case is stored. Finally, the collected results are formatted into a single, comma-separated string enclosed in square brackets as required for the final output. The implementation uses the `numpy` library for efficient vector and matrix operations, which is ideal for the state-space representation and RK4 calculations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the coupled oscillator model for Car-Parrinello breakdown\n    and computes the fractional ionic energy transfer for a suite of test cases.\n    \"\"\"\n\n    def run_simulation(params):\n        \"\"\"\n        Runs a single simulation for a given set of parameters.\n\n        Args:\n            params (tuple): A tuple containing the parameters\n                            (wi, Eg, mu, kappa, eta, T, dt).\n\n        Returns:\n            float: The computed value of the fractional energy transfer Phi.\n        \"\"\"\n        # Unpack parameters from the input tuple\n        wi, Eg, mu, kappa, eta, T, dt = params\n\n        # Fixed physical and initial conditions from the problem statement\n        M = 1.0\n        x0, vx0, y0, vy0 = 1.0, 0.0, 0.0, 0.0\n\n        # Derived parameters for the equations of motion\n        # Handles the case Eg = 0 correctly, where wel_sq = 0.\n        if mu <= 0:\n            # Fictitious mass must be positive.\n            # This case is not in the test suite but is a necessary check.\n            raise ValueError(\"Fictitious mass mu must be positive.\")\n        wel_sq = Eg / mu\n\n        # Define the system of first-order ODEs: S' = f(S)\n        # where S = [x, vx, y, vy]\n        def f(S):\n            x, vx, y, vy = S\n            x_dot = vx\n            vx_dot = -wi**2 * x - (kappa/M) * y\n            y_dot = vy\n            vy_dot = -(kappa/mu) * x - wel_sq * y - (eta/mu) * vy\n            return np.array([x_dot, vx_dot, y_dot, vy_dot])\n\n        # Initial state vector\n        S = np.array([x0, vx0, y0, vy0], dtype=float)\n\n        # Simulation time steps\n        num_steps = int(T / dt)\n\n        # Calculate initial ionic energy\n        E_i_initial = 0.5 * M * vx0**2 + 0.5 * M * wi**2 * x0**2\n        \n        # If initial energy is zero, no transfer can be measured.\n        if E_i_initial == 0:\n            return 0.0\n            \n        min_E_i = E_i_initial\n\n        # Define a large threshold for numerical instability\n        instability_threshold = 100.0\n\n        # Main RK4 integration loop\n        for _ in range(num_steps):\n            # Check for numerical instability before the next step\n            x, _, y, _ = S\n            if abs(x) > instability_threshold or abs(y) > instability_threshold:\n                break\n\n            # Fourth-Order Runge-Kutta (RK4) step\n            k1 = dt * f(S)\n            k2 = dt * f(S + 0.5 * k1)\n            k3 = dt * f(S + 0.5 * k2)\n            k4 = dt * f(S + k3)\n            S += (k1 + 2*k2 + 2*k3 + k4) / 6.0\n            \n            # Extract current ionic position and velocity from state vector\n            x_current, vx_current = S[0], S[1]\n            \n            # Calculate current ionic energy\n            E_i_current = 0.5 * M * vx_current**2 + 0.5 * M * wi**2 * x_current**2\n            \n            # Update the minimum ionic energy observed\n            if E_i_current < min_E_i:\n                min_E_i = E_i_current\n                \n        # Calculate the final diagnostic quantity Phi\n        phi = (E_i_initial - min_E_i) / E_i_initial\n        return phi\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (omega_i, E_g, mu, kappa, eta, T, dt)\n    test_cases = [\n        (0.2, 0.2, 5.0, 0.05, 0.0, 50.0, 0.01),   # Case A: Resonant baseline\n        (0.2, 0.2, 0.5, 0.05, 0.0, 50.0, 0.01),   # Case B: Reduced mu remedy\n        (0.2, 0.2, 5.0, 0.05, 0.1, 50.0, 0.01),   # Case C: Smearing remedy\n        (0.2, 0.0, 5.0, 0.05, 0.0, 50.0, 0.01),   # Case D: Gapless boundary\n        (0.2, 0.2, 5.0, 0.001, 0.0, 50.0, 0.01),  # Case E: Weak coupling\n    ]\n\n    results = []\n    for case_params in test_cases:\n        phi_value = run_simulation(case_params)\n        results.append(phi_value)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A simulation is only as good as the analysis performed on its results. In CPMD, extracting accurate physical observables like free energy differences requires careful correction for artifacts introduced by the simulation method itself. This final practice  guides you through two essential post-processing steps: reweighting the data to remove the effect of a sampling bias potential and subtracting the non-physical kinetic energy of the fictitious electronic degrees of freedom.",
            "id": "3436552",
            "problem": "Consider the estimation of free energy differences between two polymorphs using Car-Parrinello molecular dynamics (CPMD). Car-Parrinello dynamics augments the physical ionic-electronic system with additional fictitious electronic degrees of freedom controlled by a fictitious mass parameter, which introduces a fictitious electronic kinetic energy. To obtain unbiased physical free energies from CPMD sampling that may include a bias potential on a collective variable, one must correct for both the fictitious electronic kinetic energy and the sampling bias.\n\nStarting point and definitions:\n- Car-Parrinello molecular dynamics (CPMD) introduces a fictitious electronic kinetic energy $K_e$ associated with the orbital velocities, which contributes additively to the total energy. The fictitious energy is not a physical contribution to the ionic free energy landscape of interest.\n- In the canonical ensemble at temperature $T$, the inverse thermal energy is $\\beta = 1/(k_B T)$, where $k_B$ is the Boltzmann constant. The free energy difference between two basins $A$ and $B$ for the physical (unbiased) system is defined by $\\Delta F_{B\\leftarrow A} = F_B - F_A = -k_B T \\ln \\left(\\frac{Z_B}{Z_A}\\right)$, where $Z_A$ and $Z_B$ are restricted partition function contributions from basins $A$ and $B$ respectively.\n- When a bias potential $U_{\\text{bias}}(s)$ is applied during sampling as a function of a collective variable $s$, the biased ensemble has modified weights proportional to $\\exp\\left(-\\beta (E_{\\text{phys}} + U_{\\text{bias}}(s))\\right)$. To recover the unbiased ensemble averages from samples generated under the biased Hamiltonian, each sample $n$ with bias $U_{\\text{bias}}(s_n)$ must be reweighted by the factor $\\exp(+\\beta U_{\\text{bias}}(s_n))$.\n- To align with the directive, define $\\Delta E_{\\text{bias}}(n) \\equiv -U_{\\text{bias}}(s_n)$, so that the reweighting factor is $\\exp(-\\beta \\Delta E_{\\text{bias}}(n)) = \\exp(+\\beta U_{\\text{bias}}(s_n))$.\n- The fictitious electronic kinetic energy $K_e$ in CPMD is separable from the physical ionic-electronic configurational energy. In the canonical ensemble, its average contribution $\\langle K_e \\rangle$ per basin acts as an additive shift to the free energy. Therefore, to correct CPMD free energy differences to their physical values, the difference of the basin-averaged fictitious kinetic energies must be subtracted.\n\nFundamental base:\n- Canonical ensemble: $p(x) \\propto \\exp(-\\beta E(x))$ with $E(x)$ the physical energy.\n- Free energy difference: $\\Delta F_{B\\leftarrow A} = -k_B T \\ln\\left(\\frac{Z_B}{Z_A}\\right)$, with $Z_i = \\int_{\\Omega_i} \\mathrm{d}x \\exp(-\\beta E(x))$, where $\\Omega_i$ denotes the basin region $i$ in configuration space.\n- Biased sampling reweighting: If sampling is performed with $E'(x) = E(x) + U_{\\text{bias}}(s(x))$, then an unbiased estimator of the partition sum is $Z_i \\propto \\sum_{n \\in i} \\exp(+\\beta U_{\\text{bias}}(s_n))$, where the sum runs over samples $n$ assigned to basin $i$.\n\nTask:\n- You are given discrete CPMD trajectory samples comprising a collective variable $s_n$, a per-sample bias potential $U_{\\text{bias}}(s_n)$ in electronvolts, and the per-sample fictitious electronic kinetic energy $K_{e,n}$ in electronvolts.\n- Define the two polymorphic basins by a threshold $s_0$ such that basin $A$ contains samples with $s_n < s_0$ and basin $B$ contains samples with $s_n \\ge s_0$.\n- For each test case, compute the corrected free energy difference from $A$ to $B$:\n$$\n\\Delta F_{B\\leftarrow A}^{\\text{corr}} = -k_B T \\left[ \\ln\\left(\\sum_{n \\in B} \\exp(-\\beta \\Delta E_{\\text{bias}}(n))\\right) - \\ln\\left(\\sum_{n \\in A} \\exp(-\\beta \\Delta E_{\\text{bias}}(n))\\right) \\right] - \\left( \\langle K_e \\rangle_B - \\langle K_e \\rangle_A \\right),\n$$\nwith $\\Delta E_{\\text{bias}}(n) \\equiv -U_{\\text{bias}}(s_n)$ and $\\langle K_e \\rangle_i$ the arithmetic mean of $K_{e,n}$ over samples in basin $i$. Use the natural logarithm.\n- Express the final free energy differences in electronvolts (eV), rounded to six decimal places.\n\nAngle unit specification:\n- No angles are used, so no angle unit specification is required.\n\nTest suite:\n- Boltzmann constant: use $k_B = 8.617333262\\times 10^{-5}\\,\\mathrm{eV/K}$.\n- Use $s_0 = 0.5$ for all test cases.\n- Test Case $1$ (happy path): temperature $T = 1000\\,\\mathrm{K}$, samples:\n    - $s$ values: $[0.1, 0.2, 0.3, 0.45, 0.6, 0.7, 0.8, 0.55, 0.4, 0.65, 0.35, 0.75]$.\n    - Bias potential $U_{\\text{bias}}$ in $\\mathrm{eV}$ aligned with $s$: $[0.1, 0.1, 0.1, 0.1, -0.05, -0.05, -0.05, -0.05, 0.1, -0.05, 0.1, -0.05]$.\n    - Fictitious electronic kinetic energy $K_e$ in $\\mathrm{eV}$ aligned with $s$: $[0.038, 0.041, 0.039, 0.040, 0.049, 0.051, 0.050, 0.048, 0.042, 0.052, 0.037, 0.047]$.\n- Test Case $2$ (boundary: zero bias): temperature $T = 800\\,\\mathrm{K}$, samples:\n    - $s$ values: $[0.1, 0.2, 0.6, 0.7, 0.8, 0.4, 0.5, 0.55, 0.35, 0.65]$.\n    - Bias potential $U_{\\text{bias}}$ in $\\mathrm{eV}$ aligned with $s$: $[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]$.\n    - Fictitious electronic kinetic energy $K_e$ in $\\mathrm{eV}$ aligned with $s$: $[0.028, 0.032, 0.050, 0.049, 0.051, 0.031, 0.052, 0.048, 0.029, 0.050]$.\n- Test Case $3$ (edge: very strong bias with zero fictitious kinetic energy): temperature $T = 300\\,\\mathrm{K}$, samples:\n    - $s$ values: $[0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 0.4]$.\n    - Bias potential $U_{\\text{bias}}$ in $\\mathrm{eV}$ aligned with $s$: $[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3]$.\n    - Fictitious electronic kinetic energy $K_e$ in $\\mathrm{eV}$ aligned with $s$: $[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the corrected free energy differences $\\Delta F_{B\\leftarrow A}^{\\text{corr}}$ for Test Cases $1$, $2$, and $3$, in that order, as a comma-separated list enclosed in square brackets, for example, $[x_1,x_2,x_3]$, where each $x_i$ is a float in electronvolts rounded to six decimal places.",
            "solution": "The goal is to design a principled estimator for free energy differences between two polymorphic basins from Car-Parrinello molecular dynamics (CPMD) trajectory data, corrected for both fictitious electronic kinetic energy and sampling bias. The derivation proceeds from classical statistical mechanics and the CPMD formulation.\n\nBegin with the canonical ensemble at temperature $T$. For a physical system with configurational states $x$ and physical energy $E_{\\text{phys}}(x)$, the probability density is $p(x) \\propto \\exp(-\\beta E_{\\text{phys}}(x))$ with $\\beta = 1/(k_B T)$. The free energy restricted to basin $i \\in \\{A,B\\}$ is given by\n$$\nF_i = -k_B T \\ln Z_i + \\text{constant}, \\quad \\text{where} \\quad Z_i = \\int_{\\Omega_i} \\mathrm{d}x\\, \\exp(-\\beta E_{\\text{phys}}(x)),\n$$\nand $\\Omega_i$ denotes the region of configuration space corresponding to basin $i$ defined by the collective variable criterion. The physically meaningful free energy difference is\n$$\n\\Delta F_{B\\leftarrow A} = F_B - F_A = -k_B T \\ln\\left(\\frac{Z_B}{Z_A}\\right),\n$$\nwhich is independent of the additive constants in $F_i$.\n\nIn biased sampling methods, a bias potential $U_{\\text{bias}}(s(x))$ is explicitly added to the Hamiltonian to enhance sampling of certain regions,\n$$\nE'(x) = E_{\\text{phys}}(x) + U_{\\text{bias}}(s(x)).\n$$\nSamples generated under $E'(x)$ are distributed according to $p'(x) \\propto \\exp(-\\beta E'(x)) = \\exp(-\\beta E_{\\text{phys}}(x))\\exp(-\\beta U_{\\text{bias}}(s(x)))$. To recover unbiased ensemble averages, each sample must be reweighted by $\\exp(+\\beta U_{\\text{bias}}(s(x)))$ so that\n$$\nZ_i \\propto \\sum_{n \\in i} \\exp(+\\beta U_{\\text{bias}}(s_n)).\n$$\nTo match the directive notation, define $\\Delta E_{\\text{bias}}(n) \\equiv -U_{\\text{bias}}(s_n)$, yielding the reweighting factor $\\exp(-\\beta \\Delta E_{\\text{bias}}(n)) = \\exp(+\\beta U_{\\text{bias}}(s_n))$.\n\nCar-Parrinello molecular dynamics (CPMD) augments the physical system with fictitious electronic degrees of freedom $\\{\\psi_j\\}$ that carry a fictitious mass. The CPMD Lagrangian includes a fictitious kinetic energy\n$$\nK_e = \\sum_j \\frac{\\mu}{2} \\left\\| \\dot{\\psi}_j \\right\\|^2,\n$$\nwhich is quadratic in the fictitious velocities and separable from $E_{\\text{phys}}(x)$. In the canonical ensemble, separable quadratic degrees of freedom contribute additively to the free energy. Consequently, the total CPMD free energy restricted to basin $i$ is\n$$\nF_i^{\\text{CP}} = F_i^{\\text{phys}} + \\langle K_e \\rangle_i + \\text{constant}.\n$$\nTherefore, the CPMD free energy difference between basins differs from the physical free energy difference by the difference in the basin-averaged fictitious kinetic energy,\n$$\n\\Delta F_{B\\leftarrow A}^{\\text{CP}} = \\Delta F_{B\\leftarrow A}^{\\text{phys}} + \\left( \\langle K_e \\rangle_B - \\langle K_e \\rangle_A \\right).\n$$\nTo correct CPMD estimates and obtain the physical free energy difference, subtract the fictitious kinetic energy difference,\n$$\n\\Delta F_{B\\leftarrow A}^{\\text{corr}} = \\Delta F_{B\\leftarrow A}^{\\text{phys}} = \\Delta F_{B\\leftarrow A}^{\\text{CP}} - \\left( \\langle K_e \\rangle_B - \\langle K_e \\rangle_A \\right).\n$$\n\nCombining the biased sampling reweighting and the fictitious kinetic energy correction, we obtain the computable estimator from discrete samples:\n$$\n\\Delta F_{B\\leftarrow A}^{\\text{corr}} = -k_B T \\left[ \\ln\\left(\\sum_{n \\in B} \\exp(-\\beta \\Delta E_{\\text{bias}}(n))\\right) - \\ln\\left(\\sum_{n \\in A} \\exp(-\\beta \\Delta E_{\\text{bias}}(n))\\right) \\right] - \\left( \\langle K_e \\rangle_B - \\langle K_e \\rangle_A \\right),\n$$\nwhere $\\Delta E_{\\text{bias}}(n) \\equiv -U_{\\text{bias}}(s_n)$ and $\\langle K_e \\rangle_i$ is the arithmetic mean of $K_{e,n}$ over samples assigned to basin $i$.\n\nAlgorithmic design:\n- Partition samples into basins $A$ and $B$ via the threshold $s_0$: $s_n < s_0$ for $A$, $s_n \\ge s_0$ for $B$.\n- Compute $\\beta = 1/(k_B T)$, with $k_B = 8.617333262 \\times 10^{-5}\\,\\mathrm{eV/K}$.\n- For numerical stability, compute the logarithms of sums of exponentials using the log-sum-exp identity. For a set $\\{x_i\\}$,\n$$\n\\ln\\left(\\sum_i \\exp(x_i)\\right) = m + \\ln\\left(\\sum_i \\exp(x_i - m)\\right), \\quad \\text{with} \\quad m = \\max_i x_i,\n$$\nto prevent overflow or underflow when $\\beta U_{\\text{bias}}$ is large in magnitude.\n- Let $x_n^{(i)} = -\\beta \\Delta E_{\\text{bias}}(n) = +\\beta U_{\\text{bias}}(s_n)$ for samples in basin $i$. Compute\n$$\nL_i = \\ln\\left(\\sum_{n \\in i} \\exp(x_n^{(i)})\\right)\n$$\nvia the log-sum-exp method.\n- Compute basin means of the fictitious kinetic energy:\n$$\n\\langle K_e \\rangle_i = \\frac{1}{N_i} \\sum_{n \\in i} K_{e,n}.\n$$\n- Assemble the corrected free energy difference:\n$$\n\\Delta F_{B\\leftarrow A}^{\\text{corr}} = -k_B T \\left( L_B - L_A \\right) - \\left( \\langle K_e \\rangle_B - \\langle K_e \\rangle_A \\right).\n$$\n- Repeat for each test case and present the results in electronvolts rounded to six decimal places in the required single-line format.\n\nTest suite coverage:\n- Test Case $1$ uses moderate positive and negative bias values ensuring both basins are sampled; reweighting alters the apparent population ratio, and the fictitious kinetic energy difference makes a small additive correction.\n- Test Case $2$ uses zero bias, so reweighting factors are unity; the correction arises solely from the fictitious kinetic energy difference.\n- Test Case $3$ uses strong positive bias in basin $A$ at low temperature, creating large exponentials; the log-sum-exp computation ensures numerical stability. The fictitious kinetic energy values are zero, so the correction reduces to pure reweighting.\n\nThe final program implements this estimator deterministically using the provided data and prints the corrected free energy differences in electronvolts for the three test cases as a single comma-separated list enclosed in square brackets, rounded to six decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef logsumexp(x: np.ndarray) -> float:\n    \"\"\"\n    Numerically stable log-sum-exp computation.\n    Returns log(sum(exp(x))) for a 1D array x.\n    \"\"\"\n    if x.size == 0:\n        # Should not happen for provided test cases; return -inf if empty.\n        return -np.inf\n    m = np.max(x)\n    return float(m + np.log(np.sum(np.exp(x - m))))\n\ndef corrected_free_energy(T_K, s0, s_values, U_bias_values, Ke_values):\n    \"\"\"\n    Compute corrected free energy difference ΔF_{B<-A}^{corr} in eV at temperature T_K.\n    Inputs:\n        T_K: temperature in Kelvin\n        s0: threshold defining basins (A: s < s0, B: s >= s0)\n        s_values: list of collective variable samples\n        U_bias_values: list of bias potential energies U_bias(s) in eV, aligned to s_values\n        Ke_values: list of fictitious electronic kinetic energies K_e in eV, aligned to s_values\n    Output:\n        ΔF_corr (float): corrected free energy difference in eV\n    \"\"\"\n    k_B_eV_per_K = 8.617333262e-5  # eV/K\n    kBT = k_B_eV_per_K * T_K\n    beta = 1.0 / kBT\n\n    s = np.array(s_values, dtype=float)\n    U_bias = np.array(U_bias_values, dtype=float)\n    Ke = np.array(Ke_values, dtype=float)\n\n    # Basin masks\n    mask_A = s < s0\n    mask_B = ~mask_A  # s >= s0\n\n    # Reweighting exponent x_n = -beta * ΔE_bias(n) = +beta * U_bias(n)\n    x_A = beta * U_bias[mask_A]\n    x_B = beta * U_bias[mask_B]\n\n    # Log-sum-exp for each basin\n    L_A = logsumexp(x_A)\n    L_B = logsumexp(x_B)\n\n    # Basin-averaged fictitious kinetic energies\n    Ke_A_avg = float(np.mean(Ke[mask_A])) if np.any(mask_A) else 0.0\n    Ke_B_avg = float(np.mean(Ke[mask_B])) if np.any(mask_B) else 0.0\n\n    # Corrected free energy difference ΔF_{B<-A}^{corr}\n    deltaF_corr = -kBT * (L_B - L_A) - (Ke_B_avg - Ke_A_avg)\n    return deltaF_corr\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"T_K\": 1000.0,\n            \"s0\": 0.5,\n            \"s_values\": [0.1, 0.2, 0.3, 0.45, 0.6, 0.7, 0.8, 0.55, 0.4, 0.65, 0.35, 0.75],\n            \"U_bias_values\": [0.1, 0.1, 0.1, 0.1, -0.05, -0.05, -0.05, -0.05, 0.1, -0.05, 0.1, -0.05],\n            \"Ke_values\": [0.038, 0.041, 0.039, 0.040, 0.049, 0.051, 0.050, 0.048, 0.042, 0.052, 0.037, 0.047],\n        },\n        # Test Case 2 (zero bias)\n        {\n            \"T_K\": 800.0,\n            \"s0\": 0.5,\n            \"s_values\": [0.1, 0.2, 0.6, 0.7, 0.8, 0.4, 0.5, 0.55, 0.35, 0.65],\n            \"U_bias_values\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n            \"Ke_values\": [0.028, 0.032, 0.050, 0.049, 0.051, 0.031, 0.052, 0.048, 0.029, 0.050],\n        },\n        # Test Case 3 (strong bias, zero Ke)\n        {\n            \"T_K\": 300.0,\n            \"s0\": 0.5,\n            \"s_values\": [0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 0.4],\n            \"U_bias_values\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3],\n            \"Ke_values\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        deltaF = corrected_free_energy(\n            T_K=case[\"T_K\"],\n            s0=case[\"s0\"],\n            s_values=case[\"s_values\"],\n            U_bias_values=case[\"U_bias_values\"],\n            Ke_values=case[\"Ke_values\"],\n        )\n        # Round to six decimal places\n        results.append(f\"{deltaF:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}