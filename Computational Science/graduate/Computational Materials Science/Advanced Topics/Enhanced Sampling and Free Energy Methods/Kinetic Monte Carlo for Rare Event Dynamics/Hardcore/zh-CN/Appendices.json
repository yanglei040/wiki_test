{
    "hands_on_practices": [
        {
            "introduction": "在动力学蒙特卡洛（KMC）模拟中，事件的发生速率是核心输入，但这些速率并非凭空而来。本练习将指导您完成一个基础而关键的任务：使用谐波过渡态理论（hTST）从第一性原理计算（如密度泛函理论）的结果中推导转变速率。通过这个实践，您将掌握连接微观量子力学计算与介观尺度KMC模拟的桥梁，并分析速率对计算误差的敏感性。",
            "id": "3459864",
            "problem": "固体中的一个稀有事件被建模为在通过密度泛函理论（DFT）计算的势能面上，一个振动极小点与一个一阶鞍点（过渡态）之间的热激活跃迁。动力学蒙特卡洛（KMC）需要跃迁速率作为温度的函数，以便在长时间尺度上演化系统。从经典过渡态理论和关于驻点振动运动的谐振子近似出发，推导、实现并评估单个稀有事件的跃迁速率。然后分析该速率对振动频率和活化能垒误差的敏感性。\n\n假设与要求：\n- 经典谐振子近似在极小点和过渡态附近均成立。\n- 过渡态恰好有一个不稳定模式，该模式被排除在实振动频率集合之外。\n- 极小点和过渡态处的振动简正模式频率已给出，并应解释为以太赫兹（THz）为单位的普通频率，而非角频率。\n- 活化能垒以电子伏特（eV）为单位给出，是过渡态和极小点之间的总能量差。\n- 使用玻尔兹曼常数 $k_{\\mathrm{B}} = 8.617333262145\\times 10^{-5}\\ \\mathrm{eV/K}$。\n- 通过 $1\\ \\mathrm{THz} = 10^{12}\\ \\mathrm{s^{-1}}$ 将太赫兹转换为赫兹。\n- 跃迁速率 $k(T)$ 必须以 $\\mathrm{s^{-1}}$ 为单位表示，并在最终输出中四舍五入到六位有效数字。\n\n任务：\n1. 仅使用基础统计力学和谐振子近似，推导跃迁速率 $k(T)$ 的显式表达式，该表达式用极小点和过渡态（不包括不稳定模式）的振动频率以及活化能垒 $\\Delta E$ 表示，并用代码实现。\n2. 定义一个统一的乘性频率偏差 $(1+\\epsilon_{\\nu})$，它同样地应用于极小点和过渡态的所有振动频率；以及一个加性垒误差 $\\epsilon_{E}$，它加到 $\\Delta E$ 上。对于下面的每个测试用例，计算以下量：\n   - 基准速率 $k(T)$，单位为 $\\mathrm{s^{-1}}$。\n   - 频率偏差敏感性因子 $R_{\\nu} = k(T;\\ (1+\\epsilon_{\\nu})\\times\\{\\nu\\},\\ \\Delta E)\\big/ k(T;\\ \\{\\nu\\},\\ \\Delta E)$。\n   - 能垒误差敏感性因子 $R_{E} = k(T;\\ \\{\\nu\\},\\ \\Delta E+\\epsilon_{E})\\big/ k(T;\\ \\{\\nu\\},\\ \\Delta E)$。\n   - 速率对统一频率缩放因子的对数敏感性，$S_{\\mathrm{scale}} = \\dfrac{\\partial \\ln k}{\\partial \\ln s}\\bigg|_{s=1}$，其中 $s$ 乘以两个驻点处的每个振动频率。\n   - 速率对能垒的对数敏感性，$S_{E} = \\dfrac{\\partial \\ln k}{\\partial \\Delta E}$，单位为 $\\mathrm{eV^{-1}}$。\n3. 所有最终数值输出必须是浮点数。$k(T)$ 以 $\\mathrm{s^{-1}}$ 表示，$R_{\\nu}$ 和 $R_{E}$ 为无单位比率，$S_{\\mathrm{scale}}$ 无单位，$S_{E}$ 以 $\\mathrm{eV^{-1}}$ 表示。\n\n测试套件：\n所有用例使用相同的振动数据集。极小点有 $6$ 个实模式，过渡态在排除单个不稳定模式后有 $5$ 个实模式。频率以 $\\mathrm{THz}$ 给出：\n- 极小点频率：$\\{3.2,\\, 5.1,\\, 7.0,\\, 8.4,\\, 10.0,\\, 12.3\\}$。\n- 过渡态频率（仅实频）：$\\{2.9,\\, 4.7,\\, 6.5,\\, 7.9,\\, 11.5\\}$。\n\n四个测试用例是元组 $(\\Delta E\\ \\mathrm{[eV]},\\ T\\ \\mathrm{[K]},\\ \\epsilon_{\\nu}\\ \\mathrm{[无量纲]},\\ \\epsilon_{E}\\ \\mathrm{[eV]})$：\n- 案例 1：$(0.6,\\ 500,\\ 0.05,\\ 0.05)$\n- 案例 2：$(0.6,\\ 200,\\ 0.05,\\ 0.05)$\n- 案例 3：$(0.6,\\ 1200,\\ 0.05,\\ 0.05)$\n- 案例 4：$(0.05,\\ 500,\\ 0.05,\\ 0.05)$\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个各用例结果的列表，每个用例的结果是一个包含五个浮点数的列表，顺序为 $[k(T),\\ R_{\\nu},\\ R_{E},\\ S_{\\mathrm{scale}},\\ S_{E}]$。\n- 每个浮点数必须四舍五入到六位有效数字。\n- 最终的单行必须是有效的 Python 风格列表字面量，例如：$[[a_1,b_1,c_1,d_1,e_1],[a_2,b_2,c_2,d_2,e_2],\\ldots]$。",
            "solution": "我们将单个稀有事件建模为势能面上振动极小点和一阶鞍点之间的能垒穿越。动力学蒙特卡洛（KMC）需要跃迁速率作为输入，我们通过经典过渡态理论（TST）在谐振子近似下获得该速率。\n\n基本出发点：在经典 TST 中，速率常数由穿过位于过渡态的分隔面的反应通量给出。在谐振子近似中，驻点附近的局域动力学由独立的谐振子描述，其频率源自 Hessian 矩阵（质量加权二阶导数矩阵）。在温度 $T$ 下，对于一组具有频率 $\\{\\nu_{i}\\}$ 的 $n$ 个经典谐振模式，其正则配分函数在高温经典极限下（从完整量子表达式出发）与 $\\prod_{i=1}^{n} \\frac{k_{\\mathrm{B}} T}{h \\nu_{i}}$ 成正比（不计一个与频率无关的乘法常数），或者等效地，当分子和分母中的常数相消时，配分函数之比简化为频率乘积之比。在过渡态，一个不稳定（虚）模式被从对分隔面配分函数有贡献的实振动模式集合中排除。\n\n基于这些基础，通过计算极小点和过渡态（不包括不稳定模式）之间的谐振配分函数之比，并乘以考虑活化能垒的玻尔兹曼因子，便可得到经典谐振 TST 速率的 Vineyard 形式。所得的速率常数为\n$$\nk(T) \\;=\\; \\left(\\frac{\\prod_{i=1}^{N_{\\min}} \\nu^{\\min}_{i}}{\\prod_{j=1}^{N_{\\mathrm{ts}}} \\nu^{\\mathrm{ts}}_{j}}\\right) \\exp\\!\\left(-\\frac{\\Delta E}{k_{\\mathrm{B}} T}\\right),\n$$\n其中 $N_{\\min}$ 是极小点处的实振动模式数，$N_{\\mathrm{ts}}$ 是过渡态处排除不稳定模式后的实振动模式数，$\\nu_{i}^{\\min}$ 是极小点频率，$\\nu_{j}^{\\mathrm{ts}}$ 是过渡态实频，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$\\Delta E$ 是活化能垒。这里的频率是普通频率，单位为 $\\mathrm{s^{-1}}$（而非角频率），并且由于对于一阶鞍点 $N_{\\min} - N_{\\mathrm{ts}} = 1$，指前因子带有 $\\mathrm{s^{-1}}$ 的单位，从而确保乘积之比具有逆时间的单位。\n\n对统一频率缩放因子的敏感性：考虑将两个驻点处的每个振动频率都乘以一个公共因子 $s>0$，即 $\\nu \\mapsto s \\nu$。指前因子随之缩放为\n$$\n\\frac{\\prod_{i=1}^{N_{\\min}} (s \\nu^{\\min}_{i})}{\\prod_{j=1}^{N_{\\mathrm{ts}}} (s \\nu^{\\mathrm{ts}}_{j})}\n= s^{N_{\\min} - N_{\\mathrm{ts}}} \\left(\\frac{\\prod_{i=1}^{N_{\\min}} \\nu^{\\min}_{i}}{\\prod_{j=1}^{N_{\\mathrm{ts}}} \\nu^{\\mathrm{ts}}_{j}}\\right).\n$$\n对于一阶鞍点，$N_{\\min} - N_{\\mathrm{ts}} = 1$，因此指前因子以及速率与 $s$ 呈线性关系。因此，对统一频率缩放因子的对数敏感性为\n$$\nS_{\\mathrm{scale}} \\;\\equiv\\; \\frac{\\partial \\ln k}{\\partial \\ln s} \\;=\\; N_{\\min} - N_{\\mathrm{ts}} \\;=\\; 1.\n$$\n\n对能垒的敏感性：对能垒的依赖性通过玻尔兹曼因子体现，\n$$\n\\ln k(T) \\;=\\; \\ln\\!\\left(\\frac{\\prod_{i=1}^{N_{\\min}} \\nu^{\\min}_{i}}{\\prod_{j=1}^{N_{\\mathrm{ts}}} \\nu^{\\mathrm{ts}}_{j}}\\right) \\;-\\; \\frac{\\Delta E}{k_{\\mathrm{B}} T}.\n$$\n对 $\\Delta E$ 求导得到对数敏感性\n$$\nS_{E} \\;\\equiv\\; \\frac{\\partial \\ln k}{\\partial \\Delta E} \\;=\\; -\\,\\frac{1}{k_{\\mathrm{B}} T},\n$$\n当 $\\Delta E$ 以电子伏特表示，$k_{\\mathrm{B}} T$ 也以电子伏特表示时，其单位为 $\\mathrm{eV^{-1}}$。\n\n有限误差因子：对于应用于所有频率的统一乘性频率偏差 $(1+\\epsilon_{\\nu})$，有限敏感性因子为\n$$\nR_{\\nu} \\;\\equiv\\; \\frac{k(T;\\ (1+\\epsilon_{\\nu})\\times\\{\\nu\\},\\ \\Delta E)}{k(T;\\ \\{\\nu\\},\\ \\Delta E)}\n\\;=\\; (1+\\epsilon_{\\nu})^{N_{\\min} - N_{\\mathrm{ts}}}\n\\;=\\; 1+\\epsilon_{\\nu},\n$$\n对于一阶鞍点。对于一个加性能垒误差 $\\epsilon_{E}$，有限敏感性因子为\n$$\nR_{E} \\;\\equiv\\; \\frac{k(T;\\ \\{\\nu\\},\\ \\Delta E+\\epsilon_{E})}{k(T;\\ \\{\\nu\\},\\ \\Delta E)}\n\\;=\\; \\exp\\!\\left(-\\frac{\\epsilon_{E}}{k_{\\mathrm{B}} T}\\right).\n$$\n\n算法设计：\n1. 使用 $1\\ \\mathrm{THz} = 10^{12}\\ \\mathrm{s^{-1}}$ 将给定的振动频率从 $\\mathrm{THz}$ 转换为 $\\mathrm{s^{-1}}$。\n2. 为保持数值稳定性，计算指前因子的对数：\n   $$\n   \\ln A \\;=\\; \\sum_{i=1}^{N_{\\min}} \\ln \\nu^{\\min}_{i} \\;-\\; \\sum_{j=1}^{N_{\\mathrm{ts}}} \\ln \\nu^{\\mathrm{ts}}_{j},\n   \\quad\n   A \\;=\\; e^{\\ln A}.\n   $$\n3. 评估速率\n   $$\n   k(T) \\;=\\; A \\,\\exp\\!\\left(-\\frac{\\Delta E}{k_{\\mathrm{B}} T}\\right).\n   $$\n4. 通过将每个频率乘以 $(1+\\epsilon_{\\nu})$ 重新计算速率来评估 $R_{\\nu}$。通过将 $\\Delta E \\mapsto \\Delta E+\\epsilon_{E}$ 重新计算速率来评估 $R_{E}$。\n5. 计算 $S_{\\mathrm{scale}} = 1$（来自模式数之差）和 $S_{E} = -1/(k_{\\mathrm{B}} T)$。\n6. 将所有报告的浮点数四舍五入到六位有效数字，并以单行形式打印各用例结果的列表。\n\n科学真实性与解释：\n- 所给频率是固体中吸附物或缺陷模式的典型振动尺度，范围在几到几十 $\\mathrm{THz}$。\n- 能垒值代表了扩散或反应的活化能。\n- 分析强调，在低温下，$\\Delta E$ 的一个小的绝对误差可以通过指数依赖关系主导 $k(T)$ 的不确定性，而统一的频率偏差则线性地影响 $k(T)$，其敏感性由极小点和过渡态的实模式数量之差固定。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef vineyard_rate(freq_min_thz, freq_ts_thz, deltaE_eV, T_K, kB_eV_per_K=8.617333262145e-5):\n    \"\"\"\n    Compute the harmonic Vineyard TST rate:\n        k(T) = (prod_i nu_i^min / prod_j nu_j^ts) * exp(-DeltaE / (kB T))\n    Frequencies are ordinary frequencies (not angular) in THz and converted to Hz.\n    \"\"\"\n    # Convert THz to Hz\n    freq_min_hz = np.array(freq_min_thz, dtype=float) * 1e12\n    freq_ts_hz = np.array(freq_ts_thz, dtype=float) * 1e12\n\n    # Numerical stability: compute log of product difference\n    lnA = np.sum(np.log(freq_min_hz)) - np.sum(np.log(freq_ts_hz))\n    A = np.exp(lnA)  # s^-1\n\n    beta = 1.0 / (kB_eV_per_K * T_K)  # 1/eV\n    k = A * np.exp(-deltaE_eV * beta)\n    return k\n\ndef format_sigfig(x, sig=6):\n    # Format a float to specified significant figures using general format.\n    # Ensure standard 'inf'/'nan' are handled, but they shouldn't occur here.\n    return f\"{x:.{sig}g}\"\n\ndef solve():\n    # Define vibrational datasets (THz)\n    freq_min_thz = [3.2, 5.1, 7.0, 8.4, 10.0, 12.3]\n    freq_ts_thz  = [2.9, 4.7, 6.5, 7.9, 11.5]\n\n    # Test cases: (DeltaE [eV], T [K], eps_nu [dimensionless], eps_E [eV])\n    test_cases = [\n        (0.6, 500.0, 0.05, 0.05),\n        (0.6, 200.0, 0.05, 0.05),\n        (0.6, 1200.0, 0.05, 0.05),\n        (0.05, 500.0, 0.05, 0.05),\n    ]\n\n    kB_eV_per_K = 8.617333262145e-5\n\n    results = []\n    for deltaE_eV, T_K, eps_nu, eps_E in test_cases:\n        # Baseline rate\n        k_base = vineyard_rate(freq_min_thz, freq_ts_thz, deltaE_eV, T_K, kB_eV_per_K)\n\n        # Frequency-bias sensitivity: scale all frequencies by (1 + eps_nu)\n        scale = 1.0 + eps_nu\n        freq_min_scaled = [scale * f for f in freq_min_thz]\n        freq_ts_scaled  = [scale * f for f in freq_ts_thz]\n        k_freq_bias = vineyard_rate(freq_min_scaled, freq_ts_scaled, deltaE_eV, T_K, kB_eV_per_K)\n        R_nu = k_freq_bias / k_base if k_base != 0.0 else np.nan\n\n        # Barrier-error sensitivity: add eps_E to barrier\n        k_E_bias = vineyard_rate(freq_min_thz, freq_ts_thz, deltaE_eV + eps_E, T_K, kB_eV_per_K)\n        R_E = k_E_bias / k_base if k_base != 0.0 else np.nan\n\n        # Logarithmic sensitivities\n        # For first-order saddle: N_min - N_ts = 1\n        S_scale = 1.0\n        S_E = -1.0 / (kB_eV_per_K * T_K)\n\n        results.append([\n            float(format_sigfig(k_base)),\n            float(format_sigfig(R_nu)),\n            float(format_sigfig(R_E)),\n            float(format_sigfig(S_scale)),\n            float(format_sigfig(S_E)),\n        ])\n\n    # Final print statement in the exact required format.\n    # Print as a single Python-style list literal on one line.\n    # Ensure floats are represented without additional quotes.\n    def list_to_str(lst):\n        return \"[\" + \",\".join(map(str, lst)) + \"]\"\n\n    print(\"[\" + \",\".join(list_to_str(case) for case in results) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于真正大规模的模拟，即使是高效的串行算法也可能力不从心，这使得算法设计和并行化成为前沿研究的关键。本练习从具体编码转向高层次的算法设计思维，通过一个“思想实验”来分析不同数据结构实现的优劣，并探讨并行KMC模拟的多种策略。这对于设计和选择适合大规模材料系统研究的KMC代码至关重要。",
            "id": "3459847",
            "problem": "一个用于模拟晶体中稀有事件动力学的格点动力学蒙特卡罗 (KMC) 模拟，维护一个带有速率的动态激活事件集合。考虑一个系统，其包含 $M$ 个格点，每个格点最多有 $d$ 个可能的局域事件，因此当前激活事件的数量为 $N \\leq d M$。设激活事件由 $i=1,\\dots,N$ 索引，其速率为 $r_i > 0$。KMC 步骤要求：以与 $r_i$ 成正比的概率抽样一个事件，将时间推进一个均值为 $1/\\sum_{i=1}^N r_i$ 的指数分布增量，执行该事件，并局域地更新速率。假设相互作用具有局域性：每个执行的事件最多影响 $u$ 个激活事件（插入、删除或修改），由于相互作用半径有限， $u$ 与 $N$ 无关。要求您分析用于支持事件选择和更新的三类数据结构的算法复杂度和内存使用情况，并评估避免或解决并发执行的局域事件之间冲突的并行化策略。\n\n考虑事件集的以下实现选项：\n\n- 数组：一个未排序的数组，用于存储所有激活事件的当前速率 $\\{r_i\\}$。在每个 KMC 步骤中，通过在 $[0,\\sum_{i=1}^N r_i)$ 上抽取一个均匀分布的随机变量，并执行带有动态累积和的线性扫描来找到所选索引，从而选择一个事件。\n- 树：一个平衡二叉树（例如，线段树或芬威克树），它在内部节点上存储部分和，在叶节点上存储 $r_i$，允许通过累积和阈值引导沿树向下遍历来进行抽样。\n- 哈希映射：一个以事件标识符为键的哈希表，用于存储所有激活事件的当前速率 $r_i$。对于事件选择，考虑一个接受-拒绝采样方案，在每次尝试中，从 $N$ 个激活事件中均匀随机选择一个事件，并以概率 $r_i/R_{\\max}$ 接受它，其中 $R_{\\max} = \\max_{1 \\leq i \\leq N} r_i$ 被维持为一个上界。令 $\\bar r = \\frac{1}{N}\\sum_{i=1}^N r_i$ 并定义 $\\rho = R_{\\max}/\\bar r$。\n\n同时考虑在空间区域分解上的并行化，该分解将区域划分为带有幽灵层和最近邻耦合的子域。事件是局域的，影响半径为 $a$，因此如果并发执行的事件具有重叠的影响区域，则会产生冲突。\n\n在这些假设下，选择所有正确的陈述，并严格关注每 KMC 步骤的算法时间、渐近内存，以及保留精确 KMC 统计的并行冲突解决方法：\n\nA. 对于所描述的基于数组的实现，选择和执行一个事件的每步预期时间复杂度为：选择操作 $\\mathcal{O}(N)$ 加上局域更新操作 $\\mathcal{O}(u)$（因此总体为 $\\mathcal{O}(N)$），内存使用量为 $\\mathcal{O}(N)$。\n\nB. 对于部分和的平衡二叉树，事件选择的每步预期时间复杂度为 $\\mathcal{O}(\\log N)$，最多 $u$ 次局域速率更新每次成本为 $\\mathcal{O}(\\log N)$，导致每步总复杂度为 $\\mathcal{O}(\\log N + u \\log N)$；内存使用量为 $\\mathcal{O}(N)$。\n\nC. 对于使用 $R_{\\max}$ 和接受-拒绝采样的哈希映射，每次选择的预期尝试次数为 $\\rho = R_{\\max}/\\bar r$。如果 $\\rho$ 有界且与 $N$ 无关，则预期选择时间为 $\\mathcal{O}(1)$；否则性能可能退化至 $\\mathcal{O}(\\rho)$。内存使用量保持为 $\\mathcal{O}(N)$，但由于哈希开销，其常数因子比数组或树更大。\n\nD. 对子域进行棋盘格图着色，并在固定大小的时间窗口内并发执行一种颜色中的所有激活事件，然后进行同步和幽灵层更新，这种方法对于任何窗口大小都可以在没有其他条件的情况下产生精确的 KMC 统计结果。\n\nE. 一种保守的并行离散事件模拟 (PDES) 策略，它使用带有足够 lookahead 的空消息协议，按非递减时间戳顺序推进局域事件，以保证不会有更小时间戳的事件从邻居到达，这种策略确保了无冲突的并行 KMC 并保持了精确性。\n\nF. 使用原子锁来声明格点，并让每个线程根据其子域内的局域速率独立地触发事件，可以产生无偏的 KMC 动力学，因为局域性意味着独立性；只要声明的格点被锁定，任何冲突都可以被忽略。\n\nG. 一种乐观的 PDES 策略 (Time Warp)，它允许事件的推测执行，在接收到迟滞事件时检测因果关系违背，并通过使用反消息回滚到违规的时间戳来解决冲突，这种策略保留了精确的 KMC 统计结果，但代价是内存开销会随着飞行中的推测事件和保存状态的数量而增长。",
            "solution": "问题陈述全面而准确地描述了动力学蒙特卡罗 (KMC) 方法、其实现挑战以及常见的并行化策略。算法、数据结构和并行计算概念的定义是标准的、科学上合理的。参数和假设，例如相互作用的局域性（$u$ 与 $N$ 无关），定义明确，并且对于计算材料科学中的许多系统来说是物理上现实的。该问题设定良好、客观，并且没有任何科学或逻辑上的缺陷。因此，问题陈述是有效的。我们接下来分析每个陈述。\n\n### 陈述 A 的分析\n\n该陈述涉及使用未排序数组作为事件列表的 KMC 实现的性能。\n\n- **事件选择**：要选择一个事件，必须从区间 $[0, R_{tot})$ 中均匀抽取一个随机数 $\\xi$，其中 $R_{tot} = \\sum_{i=1}^N r_i$。然后，算法必须找到索引 $k$ 使得 $\\sum_{i=1}^{k-1} r_i \\le \\xi < \\sum_{i=1}^{k} r_i$。如果不维护 $R_{tot}$，其计算需要对所有 $N$ 个速率求和，这是一个 $\\mathcal{O}(N)$ 的操作。即使维护了 $R_{tot}$，找到索引 $k$ 也需要对数组进行线性扫描，计算动态累积和。在平均情况下，此扫描将遍历 $N/2$ 个元素，导致时间复杂度为 $\\mathcal{O}(N)$。\n- **事件执行与更新**：一个事件执行后，最多会影响其他 $u$ 个事件的速率。假设这些 $u$ 个事件在数组中的索引是已知的或可以在 $\\mathcal{O}(1)$ 时间内找到（例如，通过一个辅助映射），更新它们的速率需要 $\\mathcal{O}(u)$ 的时间。如果事件被插入或删除，诸如与最后一个元素交换并调整数组有效大小的操作可以在每个事件 $\\mathcal{O}(1)$ 时间内完成，因此总更新时间为 $\\mathcal{O}(u)$。\n- **总体时间复杂度**：每个 KMC 步骤的总时间是选择和更新时间的总和，即 $\\mathcal{O}(N) + \\mathcal{O}(u)$。由于 $N$ 通常远大于常数 $u$，总体复杂度由选择步骤主导，得到 $\\mathcal{O}(N)$。\n- **内存使用**：该实现需要存储 $N$ 个激活事件的速率，这需要一个大小为 $N$ 的数组。因此，内存使用量为 $\\mathcal{O}(N)$。\n\n该陈述的所有主张都是正确的。\n**结论：正确。**\n\n### 陈述 B 的分析\n\n该陈述分析了使用平衡二叉树的部分和实现的 KMC，这是一种被称为 Bortz-Kalos-Lebowitz (BKL) 算法的经典方法。\n\n- **事件选择**：树的叶节点存储单个速率 $r_i$，每个内部节点存储其子树中速率的总和。根节点存储总速率 $R_{tot}$。选择过程通过在 $[0, R_{tot})$ 中抽取 $\\xi$ 并从根节点遍历树来执行。在每个节点，将 $\\xi$ 与左子节点中存储的和进行比较。如果 $\\xi$ 较小，则路径继续到左子节点。否则，$\\xi$ 减去左子节点的和，路径继续到右子节点。对于一个有 $N$ 个叶节点的平衡树，其高度为 $\\mathcal{O}(\\log N)$，因此选择时间为 $\\mathcal{O}(\\log N)$。\n- **事件执行与更新**：当叶节点的速率 $r_i$ 被修改时，其所有祖先节点直到根节点也必须被更新。这些祖先节点的数量等于叶节点的深度，在平衡树中为 $\\mathcal{O}(\\log N)$。由于最多修改 $u$ 个速率，总更新时间最多为 $u \\times \\mathcal{O}(\\log N) = \\mathcal{O}(u \\log N)$。\n- **总体时间复杂度**：每步的总时间是选择和更新时间的总和：$\\mathcal{O}(\\log N) + \\mathcal{O}(u \\log N) = \\mathcal{O}((u+1)\\log N)$。这被正确地表示为 $\\mathcal{O}(\\log N + u \\log N)$。\n- **内存使用**：一个有 $N$ 个叶节点的二叉树有 $N-1$ 个内部节点，总共有 $2N-1$ 个节点。因此，内存使用与事件数量成线性关系，即 $\\mathcal{O}(N)$。\n\n该陈述的所有主张都是正确的。\n**结论：正确。**\n\n### 陈述 C 的分析\n\n该陈述描述了一个带有接受-拒绝采样方案的哈希映射实现。\n\n- **事件选择**：该方法包括重复尝试直到一个事件被接受。在每次尝试中，从 $N$ 个激活事件中均匀随机选择一个事件 $j$，并以概率 $p_{accept|j} = r_j / R_{\\max}$ 接受它。在单次尝试中接受一个事件的总概率是这些条件概率的平均值：\n$$P_{accept} = \\sum_{j=1}^{N} P(\\text{choose } j) \\times P(\\text{accept } | \\text{ chose } j) = \\sum_{j=1}^{N} \\frac{1}{N} \\frac{r_j}{R_{\\max}} = \\frac{1}{N R_{\\max}} \\sum_{j=1}^{N} r_j$$\n使用平均速率的定义 $\\bar{r} = \\frac{1}{N}\\sum_{i=1}^N r_i$，这简化为 $P_{accept} = \\frac{\\bar{r}}{R_{\\max}}$。预期尝试次数遵循几何分布，期望值为 $1/P_{accept} = R_{\\max} / \\bar{r} = \\rho$。陈述的这一部分是正确的。\n- **时间复杂度**：每次尝试需要从哈希映射中选择一个随机键（如果键也存储在动态数组中，平均时间可以是 $\\mathcal{O}(1)$），查找其速率（平均为 $\\mathcal{O}(1)$），并生成一个随机数。因此，一次尝试的平均时间是 $\\mathcal{O}(1)$。选择的总预期时间因此是 $\\mathcal{O}(\\rho)$。陈述正确地指出，如果 $\\rho$ 有界，则为 $\\mathcal{O}(1)$，但如果 $\\rho$ 很大，性能会下降。\n- **内存使用**：一个存储 $N$ 个键值对的哈希映射需要 $\\mathcal{O}(N)$ 的内存。同样正确的是，由于需要管理哈希冲突、保持加载因子低于1以及存储指针，哈希表通常比连续数组或树具有更高的内存开销（更大的常数因子）。\n\n该陈述的所有主张都是正确的。一个潜在未说明的问题是维护 $R_{\\max}$ 的成本，如果最大速率事件的速率降低，这个成本可能是 $\\mathcal{O}(N)$，但陈述本身是合理的。\n**结论：正确。**\n\n### 陈述 D 的分析\n\n该陈述提出了一种使用棋盘格分解和固定时间窗口的并行 KMC 方案。\n\n- **方法**：该方法建议在某个颜色的子域内*并发*执行*所有激活事件*，持续一个*固定大小的时间窗口*。\n- **违反 KMC 统计**：该方案在多个方面违反了 KMC 算法的基本原则。\n    1.  **选择**：一个 KMC 步骤涉及从整个系统中选择并执行*恰好一个*事件，该事件被选择的概率与其速率相对于*总*速率和的比例成正比。在一个子域中执行所有激活事件，或者在每个子域中并发执行一个事件，都抛弃了这种全局竞争。\n    2.  **时间推进**：KMC 时间步长 $\\Delta t$ 是一个随机变量，从均值为 $1/R_{tot}$ 的指数分布中抽取。使用固定大小的时间窗口是一种确定性近似，无法复现底层连续时间马尔可夫链的正确泊松过程统计。\n- **结论**：该方法是一种同步的、时间步进的近似。它不会产生“精确的 KMC 统计结果”。它在某些情况下可能是一种有用的近似，但它不是字面意义上正确的 KMC 模拟。关于“对于任何窗口大小都可以在没有其他条件的情况下”获得精确性的说法是绝对错误的。\n\n该陈述是不正确的。\n**结论：不正确。**\n\n### 陈述 E 的分析\n\n该陈述描述了一种保守的并行离散事件模拟 (PDES) 策略。\n\n- **方法**：在保守的 PDES 中，每个逻辑进程（LP，对应一个子域）严格按照非递减的时间戳顺序处理事件。一个 LP 是“保守的”，因为它在处理时间 $t$ 的事件之前，必须确信没有其他 LP 会向它发送时间戳 $t'  t$ 的消息（事件）。这可以防止因果错误。\n- **空消息协议**：为避免死锁（即 LP 们在一个循环中相互等待而无法前进），LP 可以交换“空消息”。空消息是发送方的一个承诺，即它不会发送任何时间戳早于该空消息时间戳的真实事件消息。这使得接收方的 LP 可以安全地推进其本地时间。“Lookahead”是一个 LP 中的事件影响另一个 LP 所需的最小时间，对该协议的效率至关重要。\n- **精确性**：通过对所有执行的事件强制执行严格的全局时间戳顺序，保守的 PDES 范式保证了并行执行轨迹与某个可能的串行执行轨迹相同。因此，它保留了 KMC 模拟的精确统计。\n\n该陈述正确描述了一种用于精确并行 KMC 的有效方法。\n**结论：正确。**\n\n### 陈述 F 的分析\n\n该陈述提出了一种基于局域事件触发和原子锁的并行化方案。\n\n- **方法**：每个线程管理自己的子域，并根据局域速率触发事件。使用格点上的原子锁来防止数据竞争。\n- **违反 KMC 统计**：这种方法存在根本性缺陷，因为它忽略了 KMC 中事件竞争的全局性。系统中*下一个*发生的*单一*事件的选择必须基于*所有* $N$ 个可能事件的速率。事件 $k$ 被选择的概率是 $P_k = r_k / R_{tot}$。所提出的方案用局域选择代替了这一点，其中线程仅根据其子域内的速率选择事件。这对应于一个不同的、不正确的物理模型。同样，时间推进应该基于 $R_{tot}$，而不是局域速率和。\n- **锁的作用**：原子锁可以防止对同一内存位置的同时写入（数据完整性），但它们无法修复事件选择过程中的统计错误。并行 KMC 中的“冲突”不仅仅是数据竞争，而是全局选择准则的失效。该算法产生的动力学不是无偏的 KMC 动力学。\n\n该陈述是不正确的。\n**结论：不正确。**\n\n### 陈述 G 的分析\n\n该陈述描述了一种乐观的 PDES 策略，即 Time Warp。\n\n- **方法**：在乐观的 PDES 中，LP 推测性地执行事件，而无需等待以确保因果关系。每个 LP 定期保存其状态。如果一个 LP 接收到一个时间戳在其过去的“迟滞”消息，则检测到因果错误。\n- **回滚机制**：为了纠正错误，LP 回滚到迟滞消息时间戳之前的某个已保存状态。它还必须取消其推测执行的影响，这包括发送“反消息”来撤回它已发送给其他 LP 的任何消息。这可能引发级联回滚。\n- **精确性**：尽管有推测执行和回滚，Time Warp 算法已被证明在统计上是精确的。已提交事件的集合（即那些从未被回滚的事件）保证处于正确的全局时间戳顺序，因此代表了一个有效的串行 KMC 轨迹。\n- **开销**：该陈述正确地指出了其主要缺点：存储过去状态和事件队列（用于可能的回滚）所需的内存，以及执行回滚的计算成本。\n\n该陈述正确描述了 Time Warp 机制及其属性。\n**结论：正确。**",
            "answer": "$$\\boxed{ABCEG}$$"
        }
    ]
}