{
    "hands_on_practices": [
        {
            "introduction": "任何前向通量采样（FFS）计算的第一步都是确定初始通量 $\\Phi_0$，即轨迹离开初始状态并穿过第一个界面的速率。本练习侧重于从反应坐标的离散时间序列中提取该值的实际挑战。你将学习通过算法正确识别和计数这些“首次穿越”事件，这是执行 FFS 计算时一项至关重要的数据处理技能 。",
            "id": "3453001",
            "problem": "您的任务是设计并实现一个算法，该算法利用在有限、离散时间步长上采样的连续时间轨迹，来估算 Forward Flux Sampling (FFS) 中穿过第一个界面的正向通量。目标是仅使用离散样本和样本之间连续性的假设，检测并记录源自盆地 $\\mathcal{A}$（定义为 $\\lambda  \\lambda_{\\mathcal{A}}$）的、穿越界面 $\\lambda_0$ 的首次穿越点。正向通量估算必须考虑有限时间步长的离散化问题，通过在一个离散区间内对连续时间的穿越点进行内插来解决。\n\n基本原理：\n- 考虑一个随机轨迹 $x(t)$，它在符合物理现实的动力学（例如，过阻尼 Langevin 动力学）下演化，因此反应坐标 $\\lambda(t) = \\lambda(x(t))$ 在时间 $t$ 上是连续的。\n- 从盆地 $\\mathcal{A}$ 穿过第一个界面 $\\lambda_0$ 的正向通量定义为 $\\Phi_{\\mathcal{A},0} = \\lim_{T \\to \\infty} N_{\\mathrm{fc}}(T)/T$，其中 $N_{\\mathrm{fc}}(T)$ 是在长度为 $T$ 的时间间隔内，源自 $\\mathcal{A}$ 的、穿越 $\\lambda_0$ 的首次穿越事件的数量。\n- 一个首次穿越事件仅在以下情况被计数：系统自上一次计数的首次穿越之后曾返回到盆地 $\\mathcal{A}$，然后在该次返回之后首次从 $\\lambda  \\lambda_0$ 穿越到 $\\lambda \\ge \\lambda_0$。\n- 由于只有离散样本可用，因此假设 $\\lambda(t)$ 在相邻样本之间是连续且近似线性的，以便在每个离散时间步长内解析连续时间的穿越点。\n\n您的程序必须使用上述假设和定义实现以下功能：\n1. 给定一个时间序列 $\\{(t_i, \\lambda_i)\\}_{i=0}^{N-1}$（其时间 $t_0  t_1  \\dots  t_{N-1}$ 严格递增），以及阈值 $\\lambda_{\\mathcal{A}}$ 和 $\\lambda_0$（其中 $\\lambda_{\\mathcal{A}}  \\lambda_0$），检测所有源自 $\\mathcal{A}$ 的、穿越 $\\lambda_0$ 的首次穿越事件。\n2. 通过线性内插处理离散区间 $[t_i, t_{i+1}]$ 内的穿越：如果 $\\lambda_i  \\lambda_0$ 且 $\\lambda_{i+1} \\ge \\lambda_0$ 且轨迹是合格的，则通过以下公式估算连续时间的穿越点：\n$$\nt_{\\mathrm{cross}} = t_i + \\frac{\\lambda_0 - \\lambda_i}{\\lambda_{i+1} - \\lambda_i}\\,(t_{i+1} - t_i).\n$$\n3. 计数首次穿越事件的合格性逻辑必须遵循更新属性：在计数一次首次穿越后，直到轨迹返回盆地 $\\mathcal{A}$ 之前，不要再计数另一次穿越。返回盆地 $\\mathcal{A}$ 发生在任何满足 $\\lambda(t)  \\lambda_{\\mathcal{A}}$ 的时间。在离散时间中，通过设置一个合格性标志来实现此逻辑：如果 $\\lambda_i  \\lambda_{\\mathcal{A}}$ 或者在 $t_i$ 和 $t_{i+1}$ 之间存在一次进入 $\\lambda  \\lambda_{\\mathcal{A}}$ 的线性化穿越，则将该标志设置为真；在计入一次首次穿越后，立即将该标志设置为假。\n4. 输出估算的通量 $\\widehat{\\Phi}_{\\mathcal{A},0} = N_{\\mathrm{fc}}/(t_{N-1}-t_0)$（单位为 $\\mathrm{s}^{-1}$），首次穿越事件的整数数量 $N_{\\mathrm{fc}}$，以及估算的穿越时间列表（以秒为单位）。\n5. 所有时间必须以秒表示，通量以 $\\mathrm{s}^{-1}$ 表示。将所有报告的时间四舍五入到 $10^{-6}$ 秒，通量四舍五入到 $10^{-6}\\ \\mathrm{s}^{-1}$。\n\n测试套件：\n为以下五个测试用例实现您的算法。在每个用例中，使用指定的 $\\lambda_{\\mathcal{A}}$ 和 $\\lambda_0$，按描述构建时间序列 $\\{(t_i,\\lambda_i)\\}$，并计算如上定义的输出。\n\n- 测试用例 1（理想情况，多个良好解析的穿越）：\n    - 阈值：$\\lambda_{\\mathcal{A}} = 0.2$, $\\lambda_0 = 1.0$。\n    - 时间网格：$t_i = i\\,\\Delta t$，对于 $i = 0,1,\\dots,40$ 且 $\\Delta t = 0.5\\ \\mathrm{s}$，所以 $t_0 = 0$ 且 $t_{40} = 20$。\n    - 轨迹：一个在 $-0.3$ 和 $1.3$ 之间振荡的三角波，周期 $P = 4.0\\ \\mathrm{s}$，定义为\n    $$\n    \\lambda(t) = c + A\\left(1 - 4\\,\\left|\\frac{(t \\bmod P)}{P} - \\frac{1}{2}\\right|\\right),\n    $$\n    其中 $A = 0.8$ 且 $c = 0.5$。\n    - 预期行为：每个周期有一次首次穿越；确保在向下穿越时不重复计数。\n\n- 测试用例 2（边界条件：恰好在采样时间发生穿越）：\n    - 阈值：$\\lambda_{\\mathcal{A}} = 0.2$, $\\lambda_0 = 1.0$。\n    - 时间：$t_i = 0, 0.25, 0.5, \\dots, 2.0$ 秒。\n    - 轨迹：先上升后下降，\n    $$\n    \\lambda(t) =\n    \\begin{cases}\n    t,  0 \\le t \\le 1, \\\\\n    2 - t,  1  t \\le 2.\n    \\end{cases}\n    $$\n    - 预期行为：在 $t = 1.0\\ \\mathrm{s}$ 处有一次首次穿越，恰好与一个采样点重合。\n\n- 测试用例 3（通过内插在样本之间检测到穿越）：\n    - 阈值：$\\lambda_{\\mathcal{A}} = 0.2$, $\\lambda_0 = 1.0$。\n    - 时间：$t = [0.0, 0.6, 1.2, 2.0]$ 秒。\n    - 值：$\\lambda = [0.0, 0.9, 1.1, 0.0]$。\n    - 预期行为：通过内插在区间 $[0.6, 1.2]$ 秒内检测到一次首次穿越。\n\n- 测试用例 4（无穿越）：\n    - 阈值：$\\lambda_{\\mathcal{A}} = 0.2$, $\\lambda_0 = 1.0$。\n    - 时间网格：$t_i = i\\,\\Delta t$，对于 $i = 0,1,\\dots,10$ 且 $\\Delta t = 0.5\\ \\mathrm{s}$，所以 $t_0 = 0$ 且 $t_{10} = 5$。\n    - 轨迹：低振幅振荡，始终低于 $\\lambda_0$，\n    $$\n    \\lambda(t) = 0.1 + 0.05\\sin\\left(2\\pi \\frac{t}{2.0}\\right).\n    $$\n\n- 测试用例 5（在未返回 $\\mathcal{A}$ 的情况下再次穿越 $\\lambda_0$；确保不重复计数）：\n    - 阈值：$\\lambda_{\\mathcal{A}} = 0.2$, $\\lambda_0 = 1.0$。\n    - 时间：$t = [0.0, 1.0, 2.0, 3.0, 4.0]$ 秒。\n    - 值：$\\lambda = [0.0, 1.1, 0.8, 1.2, 0.1]$。\n    - 预期行为：仅计数第一次向上穿越；不计数在 $t \\in [2.0, 3.0]$ 处的第二次向上穿越，因为在这两次穿越之间没有返回到 $\\mathcal{A}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个测试用例，输出一个三元列表，形式为 $[\\widehat{\\Phi}_{\\mathcal{A},0}, N_{\\mathrm{fc}}, [t_{\\mathrm{cross},1}, t_{\\mathrm{cross},2}, \\dots]]$，其中通量单位为 $\\mathrm{s}^{-1}$ 并四舍五入到 $10^{-6}$，穿越次数为整数，列表包含以秒为单位且四舍五入到 $10^{-6}$ 的穿越时间。例如：\n\"[ [0.25,5,[0.9,4.9,8.9,12.9,16.9]], [0.5,1,[1.0]], ... ]\"",
            "solution": "该问题要求设计并实现一个算法，用于从反应坐标 $\\lambda(t)$ 的离散时间序列中估算正向通量。问题的核心在于正确识别源自盆地 $\\mathcal{A}$ 且穿越界面 $\\lambda_0$ 的首次穿越事件，同时要考虑到连续时间过程的离散采样问题。\n\n### 第一步：提取已知信息\n- **系统动力学**：具有连续反应坐标 $\\lambda(t) = \\lambda(x(t))$ 的随机轨迹 $x(t)$。\n- **输入数据**：一个时间序列 $\\{(t_i, \\lambda_i)\\}_{i=0}^{N-1}$，其时间 $t_0  t_1  \\dots  t_{N-1}$ 严格递增。\n- **阈值**：一个盆地阈值 $\\lambda_{\\mathcal{A}}$ 和一个界面阈值 $\\lambda_0$，且 $\\lambda_{\\mathcal{A}}  \\lambda_0$。\n- **盆地定义**：盆地 $\\mathcal{A}$ 是 $\\lambda  \\lambda_{\\mathcal{A}}$ 的区域。\n- **正向通量定义**：$\\Phi_{\\mathcal{A},0} = \\lim_{T \\to \\infty} N_{\\mathrm{fc}}(T)/T$，其中 $N_{\\mathrm{fc}}(T)$ 是在时间 $T$ 内的首次穿越事件数。\n- **首次穿越事件**：轨迹在返回盆地 $\\mathcal{A}$ 后，首次从 $\\lambda  \\lambda_0$ 穿越到 $\\lambda \\ge \\lambda_0$。\n- **穿越时间估算**：如果穿越发生在 $[t_i, t_{i+1}]$ 内（即 $\\lambda_i  \\lambda_0$ 且 $\\lambda_{i+1} \\ge \\lambda_0$），则穿越时间通过线性内插估算：\n$$ t_{\\mathrm{cross}} = t_i + \\frac{\\lambda_0 - \\lambda_i}{\\lambda_{i+1} - \\lambda_i}\\,(t_{i+1} - t_i) $$\n- **合格性逻辑（更新属性）**：使用一个合格性标志。在计入一次首次穿越后，该标志设置为假。只有在轨迹返回盆地 $\\mathcal{A}$（当 $\\lambda(t)  \\lambda_{\\mathcal{A}}$ 时检测到）后，才再次设置为真。问题将其具体描述为“或者 $\\lambda_i  \\lambda_{\\mathcal{A}}$，或者在 $t_i$ 和 $t_{i+1}$ 之间存在一次进入 $\\lambda  \\lambda_{\\mathcal{A}}$ 的线性化穿越”。\n- **输出要求**：\n    1. 估算通量：$\\widehat{\\Phi}_{\\mathcal{A},0} = N_{\\mathrm{fc}}/(t_{N-1}-t_0)$，四舍五入到 $10^{-6}\\ \\mathrm{s}^{-1}$。\n    2. 穿越次数：$N_{\\mathrm{fc}}$，一个整数。\n    3. 穿越时间：一个 $t_{\\mathrm{cross}}$ 值的列表，每个值四舍五入到 $10^{-6}\\ \\mathrm{s}$。\n- **测试用例**：提供了五个具体的测试用例，包含定义的参数和轨迹函数或数据点。\n\n### 第二步：使用提取的已知信息进行验证\n根据验证标准评估问题陈述。\n\n- **科学基础**：该问题在计算统计力学的基本原理，特别是用于稀有事件模拟的 Forward Flux Sampling (FFS) 方法上，有坚实的基础。反应坐标、状态盆地（$\\mathcal{A}$）、界面（$\\lambda_0$）以及用于计数独立事件的更新过程等概念，都是该方法的标准且正确的组成部分。使用线性内插是分析离散化轨迹数据的常用且有效的近似方法。\n- **适定性**：该问题是适定的。算法逻辑被明确描述：一个状态（合格性）根据无歧义的条件（$\\lambda_i  \\lambda_0$，$\\lambda_i  \\lambda_{\\mathcal{A}}$ 等）进行维护和更新。每个测试用例的输入被完全指定，所需的输出也被明确定义。这种结构确保可以通过算法确定一个唯一、稳定且有意义的解。\n- **客观性**：语言精确且数学化。所有定义和要求都是客观的，没有歧义或主观解释的余地。\n\n该问题未表现出任何无效性标志：\n1.  **科学/事实不健全**：前提是健全的。\n2.  **非形式化/不相关**：该问题是一个与 FFS 直接相关的形式化算法任务。\n3.  **不完整/矛盾的设置**：要求是完整且内部一致的。\n4.  **不切实际/不可行**：测试用例基于简单、可计算的函数和数据。\n5.  **不适定/结构不良**：问题结构良好。\n6.  **伪深刻/微不足道**：该问题需要仔细实现有状态的逻辑，这是一项非凡的编程任务，准确反映了该领域的实际计算。\n7.  **超出科学可验证范围**：结果是可通过计算验证的。\n\n### 第三步：结论与行动\n问题是**有效的**。将提供一个解决方案。\n\n### 解决方案\n关注的基本量是从盆地 $\\mathcal{A}$ 穿过界面 $\\lambda_0$ 的正向通量 $\\Phi_{\\mathcal{A},0}$。这被定义为独立首次穿越事件的速率。当系统的反应坐标 $\\lambda(t)$ 在正向方向上（即从 $\\lambda  \\lambda_0$ 到 $\\lambda \\ge \\lambda_0$）穿过值 $\\lambda_0$ 时，就记录了一次首次通过或首次穿越事件。关键在于，要使该事件被计数，它必须是自上次计数的穿越事件以来，轨迹访问过盆地 $\\mathcal{A}$（由 $\\lambda  \\lambda_{\\mathcal{A}}$ 定义）之后的*首次*此类穿越。这个更新要求对于确保所计数的事件是统计上独立的跃迁至关重要。\n\n给定一个离散时间序列 $\\{ (t_i, \\lambda_i) \\}_{i=0}^{N-1}$，必须构建一个算法以从采样数据中正确识别这些更新事件。该算法可以严格地概念化为一个有限状态机，它相对于穿越和更新条件跟踪轨迹的历史。该状态机有两个状态：\n\n1.  **$\\mathcal{S}_{\\text{eligible}}$**：系统有资格记录对界面 $\\lambda_0$ 的首次穿越。轨迹在初始时以及每次成功返回盆地 $\\mathcal{A}$ 后进入此状态。\n2.  **$\\mathcal{S}_{\\text{ineligible}}$**：系统刚刚记录了一次对 $\\lambda_0$ 的首次穿越，现在无资格记录另一次，直到它通过返回盆地 $\\mathcal{A}$ 满足更新条件。\n\n处理时间序列的算法过程如下：\n\n**初始化**：\n- 轨迹的总持续时间计算为 $T = t_{N-1} - t_0$。\n- 首次穿越次数 $N_{\\mathrm{fc}}$ 初始化为 $0$。\n- 创建一个空列表来存储计算出的穿越时间 $t_{\\mathrm{cross}}$。\n- 系统状态初始化为 $\\mathcal{S}_{\\text{eligible}}$。这与标准的 FFS 流程一致，在 FFS 中，初始模拟从盆地 $\\mathcal{A}$ 深处开始，因此在第一个事件发生前默认满足更新条件。\n\n**迭代**：\n算法从索引 $i=0$ 到 $i=N-2$ 遍历所有连续的时间点对，分析区间 $[t_i, t_{i+1}]$。在每次迭代中，系统的状态决定了要执行的动作：\n\n- **如果系统处于 $\\mathcal{S}_{\\text{eligible}}$ 状态**：\n    - 算法检查是否存在对界面 $\\lambda_0$ 的正向穿越。如果 $\\lambda_i  \\lambda_0$ 且 $\\lambda_{i+1} \\ge \\lambda_0$，则满足此条件。\n    - 如果检测到穿越：\n        1.  $N_{\\mathrm{fc}}$ 增加 1。\n        2.  通过提供的线性内插公式估算穿越时间 $t_{\\mathrm{cross}}$。这个近似假设 $\\lambda(t)$ 在小区间 $[t_i, t_{i+1}]$ 上呈线性行为：\n            $$ t_{\\mathrm{cross}} = t_i + \\frac{\\lambda_0 - \\lambda_i}{\\lambda_{i+1} - \\lambda_i}\\,(t_{i+1} - t_i) $$\n            这个值被附加到穿越时间列表中。\n        3.  系统状态立即转换到 $\\mathcal{S}_{\\text{ineligible}}$，以防止在更新前计数后续的穿越。\n\n- **如果系统处于 $\\mathcal{S}_{\\text{ineligible}}$ 状态**：\n    - 算法检查更新条件。如果系统在当前区间结束时，其反应坐标被观察到在盆地中，即如果 $\\lambda_{i+1}  \\lambda_{\\mathcal{A}}$，则认为系统已返回盆地 $\\mathcal{A}$。\n    - 如果满足更新条件：\n        1.  系统状态转换回 $\\mathcal{S}_{\\text{eligible}}$。系统现在已准备好检测下一次首次穿越事件。\n\n这种对区间的顺序处理确保了更新逻辑得到严格执行。只有当系统处于 $\\mathcal{S}_{\\text{eligible}}$ 状态时，才会计数对 $\\lambda_0$ 的向上穿越，并且在计数后，状态切换到 $\\mathcal{S}_{\\text{ineligible}}$，直到观察到明确返回盆地 $\\mathcal{A}$ 为止。\n\n**最终处理**：\n- 在对所有时间区间的循环完成后，使用计数的事件总数和总模拟时间计算估算的正向通量：\n$$ \\widehat{\\Phi}_{\\mathcal{A},0} = \\frac{N_{\\mathrm{fc}}}{T} $$\n如果 $T=0$（例如，对于少于2个点的轨迹），则通量定义为 $0$。最终的通量和所有穿越时间都四舍五入到指定的 $10^{-6}$ 精度。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n\n    def compute_crossings(times, lambdas, lambda_A, lambda_0):\n        \"\"\"\n        Computes the forward flux, number of crossings, and crossing times.\n\n        Args:\n            times (np.ndarray): Array of time points.\n            lambdas (np.ndarray): Array of reaction coordinate values.\n            lambda_A (float): Threshold for basin A.\n            lambda_0 (float): Threshold for the first interface.\n\n        Returns:\n            tuple: A tuple containing (flux, num_crossings, crossing_times_list).\n        \"\"\"\n        if len(times)  2:\n            return 0.0, 0, []\n\n        total_time = times[-1] - times[0]\n        num_crossings = 0\n        crossing_times = []\n        \n        # State machine: True if eligible to cross, False if must return to A first.\n        # Start in the eligible state, assuming the simulation originates from A.\n        is_eligible = True\n\n        for i in range(len(times) - 1):\n            t_i, lambda_i = times[i], lambdas[i]\n            t_i_plus_1, lambda_i_plus_1 = times[i+1], lambdas[i+1]\n\n            # 1. Check for a first-crossing event if eligible\n            if is_eligible and lambda_i  lambda_0 and lambda_i_plus_1 >= lambda_0:\n                num_crossings += 1\n                \n                # Linearly interpolate the crossing time\n                # Denominator cannot be zero because lambda_i  lambda_0 = lambda_i_plus_1\n                # implies lambda_i != lambda_i_plus_1.\n                if lambda_i_plus_1 > lambda_i:\n                    t_cross = t_i + (lambda_0 - lambda_i) / (lambda_i_plus_1 - lambda_i) * (t_i_plus_1 - t_i)\n                else: # This case occurs if lambda_i_plus_1 == lambda_i == lambda_0, which is excluded by lambda_i  lambda_0.\n                      # This handles the exact crossing case: lambda_i  lambda_0 and lambda_i_plus_1 == lambda_0.\n                    t_cross = t_i_plus_1\n\n                crossing_times.append(round(t_cross, 6))\n                \n                # After crossing, the system becomes ineligible until it returns to A\n                is_eligible = False\n\n            # 2. Check for return to basin A to reset eligibility\n            if not is_eligible and lambda_i_plus_1  lambda_A:\n                is_eligible = True\n        \n        if total_time > 0:\n            flux = round(num_crossings / total_time, 6)\n        else:\n            flux = 0.0\n\n        return flux, num_crossings, crossing_times\n\n    test_cases = []\n\n    # Test Case 1: Triangular wave\n    lambda_A_1, lambda_0_1 = 0.2, 1.0\n    dt_1 = 0.5\n    times_1 = np.arange(0.0, 20.0 + dt_1 / 2, dt_1)\n    # Correct the endpoint to be exactly 20.0 (41 points from i=0 to 40)\n    times_1 = times_1[times_1 = 20.0]\n    \n    def triangular_wave(t, P, A, c):\n        t_mod_P = t % P\n        return c + A * (1 - 4 * abs(t_mod_P / P - 0.5))\n\n    lambdas_1 = triangular_wave(times_1, P=4.0, A=0.8, c=0.5)\n    test_cases.append((times_1, lambdas_1, lambda_A_1, lambda_0_1))\n    \n    # Test Case 2: Ramp up/down\n    lambda_A_2, lambda_0_2 = 0.2, 1.0\n    times_2 = np.arange(0.0, 2.0 + 0.25/2, 0.25)\n    \n    def ramp_trajectory(t):\n        return np.where(t = 1.0, t, 2.0 - t)\n        \n    lambdas_2 = ramp_trajectory(times_2)\n    test_cases.append((times_2, lambdas_2, lambda_A_2, lambda_0_2))\n\n    # Test Case 3: Interpolation-detected crossing\n    lambda_A_3, lambda_0_3 = 0.2, 1.0\n    times_3 = np.array([0.0, 0.6, 1.2, 2.0])\n    lambdas_3 = np.array([0.0, 0.9, 1.1, 0.0])\n    test_cases.append((times_3, lambdas_3, lambda_A_3, lambda_0_3))\n\n    # Test Case 4: No crossings\n    lambda_A_4, lambda_0_4 = 0.2, 1.0\n    dt_4 = 0.5\n    times_4 = np.arange(0.0, 5.0 + dt_4/2, dt_4)\n    times_4 = times_4[times_4 = 5.0]\n\n    def sine_trajectory(t):\n        return 0.1 + 0.05 * np.sin(2 * np.pi * t / 2.0)\n        \n    lambdas_4 = sine_trajectory(times_4)\n    test_cases.append((times_4, lambdas_4, lambda_A_4, lambda_0_4))\n\n    # Test Case 5: Recrossing without return to A\n    lambda_A_5, lambda_0_5 = 0.2, 1.0\n    times_5 = np.array([0.0, 1.0, 2.0, 3.0, 4.0])\n    lambdas_5 = np.array([0.0, 1.1, 0.8, 1.2, 0.1])\n    test_cases.append((times_5, lambdas_5, lambda_A_5, lambda_0_5))\n\n    results = []\n    for times, lambdas, lambda_A, lambda_0 in test_cases:\n        flux, n_fc, t_cross_list = compute_crossings(times, lambdas, lambda_A, lambda_0)\n        results.append([flux, n_fc, t_cross_list])\n\n    # Format the final output string\n    result_strings = []\n    for res in results:\n        flux_val, n_fc_val, t_list = res\n        t_list_str = f\"[{','.join(map(str, t_list))}]\"\n        result_strings.append(f\"[{flux_val},{n_fc_val},{t_list_str}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在得到初始通量 $\\Phi_0$ 和后续阶段的条件概率 $P(\\lambda_{i+1}|\\lambda_i)$ 后，下一步是将它们组合起来计算整体的稀有事件速率 $k_{AB}$。本问题提供了一套完整的前向通量采样模拟数据，要求你应用核心的 FFS 公式进行计算。这项练习将巩固你对 FFS 如何将一个稀有事件分解为一系列更频繁事件的理解 。",
            "id": "3453002",
            "problem": "考虑一个坐标为 $x$ 的一维过阻尼布朗粒子，在双势阱中运动。该势阱代表了材料从亚稳相 $A$（左势阱）到稳态相 $B$（右势阱）相变的序参量。势能函数为\n$$\nU(x) \\;=\\; \\alpha \\left(x^{2}-\\beta^{2}\\right)^{2} + \\gamma x,\n$$\n参数为 $\\alpha = 2.0\\ \\mathrm{eV}\\ \\mathrm{nm}^{-4}$，$\\beta = 0.30\\ \\mathrm{nm}$，以及 $\\gamma = 0.10\\ \\mathrm{eV}\\ \\mathrm{nm}^{-1}$。令反应坐标为 $\\lambda(x) = x$，并定义一系列分隔 $A$ 和 $B$ 的不相交界面 $\\{\\lambda_{i}\\}$，其位置为 $\\lambda_{0}=-0.20\\ \\mathrm{nm}$，$\\lambda_{1}=-0.10\\ \\mathrm{nm}$，$\\lambda_{2}=0$，$\\lambda_{3}=0.10\\ \\mathrm{nm}$，以及 $\\lambda_{4}=0.20\\ \\mathrm{nm}$。您执行前向通量采样 (Forward Flux Sampling, FFS) 来估算从 $A$ 到 $B$ 的稀有转变速率。\n\n在一条限制在势阱 $A$ 内的长稳态轨迹中（每次首次穿越 $\\lambda_{0}$ 后立即重新插入到 $A$ 中），您在 $A$ 中总计为 $T$ 的累积驻留时间内，记录到 $N$ 次对 $\\lambda_{0}$ 的向上穿越。您还执行了前向试探性运行，以估算连续界面之间的条件穿越概率。具体来说，从每个界面 $\\lambda_{i}$ 处存储的首次穿越构型出发，您发起 $K_{i}$ 次独立试探，并计数在返回 $A$ 之前到达下一个界面的试探次数 $m_{i}$（对于 $i=0,1,2,3$），并从 $\\lambda_{4}$ 出发，计数在返回 $A$ 之前到达 $B$ 的试探次数 $m_{4}$。测量值为：\n- $N = 12000$ 且 $T = 100\\ \\mathrm{s}$，\n- $(K_{0}, m_{0}) = (5000, 400)$，\n- $(K_{1}, m_{1}) = (4000, 480)$，\n- $(K_{2}, m_{2}) = (2000, 200)$，\n- $(K_{3}, m_{3}) = (1000, 70)$，\n- $(K_{4}, m_{4}) = (1000, 60)$。\n\n假设一种材料包含数密度为 $n_{A} = 2.50 \\times 10^{15}\\ \\mathrm{m}^{-3}$ 的统计独立的 $A$ 位点（每个位点都由上述相同的随机动力学和界面描述）。\n\n仅使用通量和条件概率的第一性原理定义，确定：\n1) $A \\to B$ 的单位点转变速率常数 $k_{AB}$，\n2) 材料的宏观单位体积转变速率 $J$。\n\n将 $k_{AB}$ 以 $\\mathrm{s}^{-1}$ 为单位表示，将 $J$ 以 $\\mathrm{m}^{-3}\\ \\mathrm{s}^{-1}$ 为单位表示。将两个最终报告的量均四舍五入至四位有效数字。",
            "solution": "在尝试解答之前，对问题进行验证。\n\n### 步骤 1：提取已知条件\n问题陈述中提供的数据、变量和条件如下：\n- 势能函数：$U(x) = \\alpha (x^{2}-\\beta^{2})^{2} + \\gamma x$\n- 势能参数：$\\alpha = 2.0\\ \\mathrm{eV}\\ \\mathrm{nm}^{-4}$，$\\beta = 0.30\\ \\mathrm{nm}$，$\\gamma = 0.10\\ \\mathrm{eV}\\ \\mathrm{nm}^{-1}$\n- 反应坐标：$\\lambda(x) = x$\n- 界面：$\\lambda_{0}=-0.20\\ \\mathrm{nm}$，$\\lambda_{1}=-0.10\\ \\mathrm{nm}$，$\\lambda_{2}=0$，$\\lambda_{3}=0.10\\ \\mathrm{nm}$，$\\lambda_{4}=0.20\\ \\mathrm{nm}$\n- 势阱 $A$ 是亚稳态（左势阱），势阱 $B$ 是稳态（右势阱）。\n- 在势阱 $A$ 中的稳态模拟数据：$N = 12000$ 次对 $\\lambda_{0}$ 的向上穿越。\n- 在 $A$ 中的总驻留时间：$T = 100\\ \\mathrm{s}$。\n- 前向通量采样 (FFS) 试探数据：\n  - 从 $\\lambda_{0}$：$K_{0} = 5000$ 次试探，$m_{0} = 400$ 次成功（到达 $\\lambda_{1}$）。\n  - 从 $\\lambda_{1}$：$K_{1} = 4000$ 次试探，$m_{1} = 480$ 次成功（到达 $\\lambda_{2}$）。\n  - 从 $\\lambda_{2}$：$K_{2} = 2000$ 次试探，$m_{2} = 200$ 次成功（到达 $\\lambda_{3}$）。\n  - 从 $\\lambda_{3}$：$K_{3} = 1000$ 次试探，$m_{3} = 70$ 次成功（到达 $\\lambda_{4}$）。\n  - 从 $\\lambda_{4}$：$K_{4} = 1000$ 次试探，$m_{4} = 60$ 次成功（到达 $B$）。\n- 材料参数：$A$ 位点的数密度 $n_{A} = 2.50 \\times 10^{15}\\ \\mathrm{m}^{-3}$。\n- 要求解的量：\n  1. 单位点转变速率常数 $k_{AB}$，单位为 $\\mathrm{s}^{-1}$。\n  2. 宏观单位体积转变速率 $J$，单位为 $\\mathrm{m}^{-3}\\ \\mathrm{s}^{-1}$。\n- 最终报告要求：将两个量均四舍五入至四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，描述了一个用布朗动力学在势能中建模的稀有事件的标准情景，并使用成熟的前向通量采样方法进行分析。该问题是适定的，提供了根据 FFS 算法计算速率常数所需的所有数值数据（$N$、$T$、$\\{K_i\\}$、$\\{m_i\\}$）。语言客观而精确。数据是自洽且物理上合理的；例如，随着系统接近过渡态区域，向产物态前进的条件概率通常会降低，这符合预期。势能函数参数（$\\alpha$、$\\beta$、$\\gamma$）用于定义物理背景，但在根据模拟统计数据进行计算时并不直接需要，这是分析模拟输出时的一种常见情况。没有矛盾、歧义或违反科学原理之处。\n\n### 步骤 3：结论与行动\n问题有效。将提供解答。\n\n过程 $A \\to B$ 的转变速率常数 $k_{AB}$ 可以使用前向通量采样 (FFS) 公式计算。该速率是离开初始态 $A$ 穿过第一个界面 $\\lambda_{0}$ 的轨迹通量，与一条穿过 $\\lambda_{0}$ 的轨迹最终到达最终态 $B$ 而不返回 $A$ 的概率的乘积。\n\n$k_{AB} = \\Phi_{0} \\times P(B|\\lambda_{0})$\n\n第一项 $\\Phi_{0}$ 是源于势阱 $A$ 的轨迹首次正向穿越界面 $\\lambda_{0}$ 的速率。根据在势阱 $A$ 中进行的长稳态模拟，该通量估算为 $\\lambda_0$ 的总向上穿越次数 $N$ 除以总模拟时间 $T$。\n\n$$\n\\Phi_{0} = \\frac{N}{T}\n$$\n\n代入给定值：\n$$\n\\Phi_{0} = \\frac{12000}{100\\ \\mathrm{s}} = 120\\ \\mathrm{s}^{-1}\n$$\n\n第二项 $P(B|\\lambda_{0})$ 是一条已到达 $\\lambda_{0}$ 的轨迹将继续前进到状态 $B$ 的条件概率。在 FFS 中，该概率计算为从一个界面 $\\lambda_{i}$ 穿越到下一个界面 $\\lambda_{i+1}$ 的条件概率的乘积：\n\n$$\nP(B|\\lambda_{0}) = P(\\lambda_{1}|\\lambda_{0}) \\times P(\\lambda_{2}|\\lambda_{1}) \\times P(\\lambda_{3}|\\lambda_{2}) \\times P(\\lambda_{4}|\\lambda_{3}) \\times P(B|\\lambda_{4})\n$$\n\n这可以更紧凑地写为：\n$$\nP(B|\\lambda_{0}) = \\left( \\prod_{i=0}^{3} P(\\lambda_{i+1}|\\lambda_{i}) \\right) \\times P(B|\\lambda_{4})\n$$\n\n每个条件概率 $P(\\lambda_{i+1}|\\lambda_{i})$ 都是从 FFS 试探运行中估算的，即成功试探的次数 $m_{i}$（在返回 $A$ 之前到达 $\\lambda_{i+1}$ 的轨迹）与从 $\\lambda_{i}$ 发起的总试探次数 $K_{i}$ 的比值。\n\n$$\nP(\\lambda_{i+1}|\\lambda_{i}) \\approx \\frac{m_{i}}{K_{i}}\n$$\n\n最终概率 $P(B|\\lambda_{4})$ 类似地估算为 $m_{4}/K_{4}$。\n\n我们来计算每个概率：\n$P(\\lambda_{1}|\\lambda_{0}) = \\frac{m_{0}}{K_{0}} = \\frac{400}{5000} = 0.08$\n$P(\\lambda_{2}|\\lambda_{1}) = \\frac{m_{1}}{K_{1}} = \\frac{480}{4000} = 0.12$\n$P(\\lambda_{3}|\\lambda_{2}) = \\frac{m_{2}}{K_{2}} = \\frac{200}{2000} = 0.10$\n$P(\\lambda_{4}|\\lambda_{3}) = \\frac{m_{3}}{K_{3}} = \\frac{70}{1000} = 0.07$\n$P(B|\\lambda_{4}) = \\frac{m_{4}}{K_{4}} = \\frac{60}{1000} = 0.06$\n\n现在，我们计算总条件概率 $P(B|\\lambda_{0})$：\n$$\nP(B|\\lambda_{0}) = 0.08 \\times 0.12 \\times 0.10 \\times 0.07 \\times 0.06\n$$\n$$\nP(B|\\lambda_{0}) = (8 \\times 10^{-2}) \\times (1.2 \\times 10^{-1}) \\times (1 \\times 10^{-1}) \\times (7 \\times 10^{-2}) \\times (6 \\times 10^{-2})\n$$\n$$\nP(B|\\lambda_{0}) = (8 \\times 1.2 \\times 1 \\times 7 \\times 6) \\times 10^{-2-1-1-2-2} = 403.2 \\times 10^{-8} = 4.032 \\times 10^{-6}\n$$\n\n有了 $\\Phi_{0}$ 和 $P(B|\\lambda_{0})$，我们可以计算单位点转变速率常数 $k_{AB}$：\n$$\nk_{AB} = \\Phi_{0} \\times P(B|\\lambda_{0}) = (120\\ \\mathrm{s}^{-1}) \\times (4.032 \\times 10^{-6})\n$$\n$$\nk_{AB} = 483.84 \\times 10^{-6}\\ \\mathrm{s}^{-1} = 4.8384 \\times 10^{-4}\\ \\mathrm{s}^{-1}\n$$\n\n按要求四舍五入到四位有效数字，我们得到：\n$k_{AB} \\approx 4.838 \\times 10^{-4}\\ \\mathrm{s}^{-1}$。\n\n接下来，我们确定宏观单位体积转变速率 $J$。这是通过将单位点速率常数 $k_{AB}$ 乘以 $A$ 位点的数密度 $n_{A}$ 得到的。问题陈述中指出 $A$ 位点是统计独立的。\n\n$$\nJ = k_{AB} \\times n_{A}\n$$\n\n单位是一致的：$k_{AB}$ 的单位是 $\\mathrm{s}^{-1}$，$n_{A}$ 的单位是 $\\mathrm{m}^{-3}$，因此 $J$ 的单位将是 $\\mathrm{m}^{-3}\\ \\mathrm{s}^{-1}$。为了获得更高的精度，使用未四舍五入的 $k_{AB}$ 值：\n$$\nJ = (4.8384 \\times 10^{-4}\\ \\mathrm{s}^{-1}) \\times (2.50 \\times 10^{15}\\ \\mathrm{m}^{-3})\n$$\n$$\nJ = (4.8384 \\times 2.50) \\times 10^{-4+15}\\ \\mathrm{m}^{-3}\\ \\mathrm{s}^{-1}\n$$\n$$\nJ = 12.096 \\times 10^{11}\\ \\mathrm{m}^{-3}\\ \\mathrm{s}^{-1}\n$$\n用标准科学记数法表示：\n$$\nJ = 1.2096 \\times 10^{12}\\ \\mathrm{m}^{-3}\\ \\mathrm{s}^{-1}\n$$\n按要求四舍五入到四位有效数字，我们得到：\n$J \\approx 1.210 \\times 10^{12}\\ \\mathrm{m}^{-3}\\ \\mathrm{s}^{-1}$。\n\n所求的两个量是单位点转变速率常数 $k_{AB}$ 和宏观单位体积转变速率 $J$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 4.838 \\times 10^{-4}  1.210 \\times 10^{12} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "由于前向通量采样依赖于有限次数的随机试验，其计算出的速率 $k_{AB}$ 是一个带有内在统计不确定性的估计值。最后一个练习将演示如何量化这种不确定性。你将学习计算条件概率的标准误差和置信区间，并将其传播以得出最终速率常数的不确定性，这对于严谨地报告 FFS 结果至关重要 。",
            "id": "3452984",
            "problem": "使用前向通量采样 (FFS) 方法研究晶体中从状态 $A$ 到状态 $B$ 的稀有事件转变。设 $\\lambda$ 是一个标量序参量，它定义了从 $A$ 盆地到 $B$ 盆地的一组嵌套界面 $\\lambda_{0}  \\lambda_{1}  \\cdots  \\lambda_{M}$。在 FFS 中，速率常数 $k_{AB}$ 表示为从 $A$ 出发穿过第一个界面的轨迹通量（记为 $\\phi_{0}$）与跨越连续界面的条件穿越概率之积的乘积。\n\n在索引为 $i$ 的特定界面上，您从 $\\lambda_{i}$ 的稳态采样中启动了 $n_{i}=1000$ 次独立的试探轨迹，其中有 $s_{i}=210$ 次在返回到 $A$ 之前到达了 $\\lambda_{i+1}$。将这些试探视为由潜在成功概率 $P_{i}$ 控制的独立同分布的伯努利结果。\n\n任务：\n- 仅使用二项采样的第一性原理和由中心极限定理 (CLT) 证明的渐近正态性，估计条件穿越概率 $\\hat{P}_{i}$ 及其标准误差，并为 $P_{i}$ 构建一个双边 $95\\%$ 置信区间。\n- FFS 速率常数可写作 $k_{AB}=\\phi_{0}\\,\\prod_{j=0}^{M-1}P_{j}$。假设通量为 $\\phi_{0}=5.0\\times 10^{4}\\ \\mathrm{s}^{-1}$，且除第 $i$ 个概率外的所有其他条件概率的乘积已知为 $\\prod_{j\\neq i}P_{j}=3.0\\times 10^{-6}$，其不确定性可忽略不计。使用一阶不确定性传播方法，得到 $k_{AB}$ 的点估计、仅由 $P_{i}$ 的不确定性引起的 $k_{AB}$ 的传播标准误差，以及对应的 $k_{AB}$ 的双边 $95\\%$ 置信区间。\n- 将所有报告的数值四舍五入到四位有效数字。以 $\\mathrm{s}^{-1}$ 为单位表示 $k_{AB}$ 及其不确定性。\n\n按以下顺序报告您的最终答案（一个六元组）：\n$\\left[\\hat{P}_{i},\\ \\mathrm{SE}(\\hat{P}_{i}),\\ \\text{CI}_{\\text{low}}(P_{i}),\\ \\text{CI}_{\\text{high}}(P_{i}),\\ \\hat{k}_{AB},\\ \\mathrm{SE}(\\hat{k}_{AB})\\right]$。",
            "solution": "对问题陈述进行验证。\n\n**第 1 步：提取已知条件**\n-   方法论：使用前向通量采样 (FFS) 研究从状态 $A$ 到状态 $B$ 的稀有事件转变。\n-   序参量：$\\lambda$，定义了界面 $\\lambda_{0}  \\lambda_{1}  \\cdots  \\lambda_{M}$。\n-   速率常数表达式：$k_{AB} = \\phi_{0} \\prod_{j=0}^{M-1} P_{j}$，其中 $\\phi_{0}$ 是跨越 $\\lambda_{0}$ 的通量，$P_{j}$ 是从 $\\lambda_{j}$ 到 $\\lambda_{j+1}$ 的条件穿越概率。\n-   界面 $i$ 的数据：\n    -   试探轨迹数量：$n_{i} = 1000$。\n    -   成功试探次数（到达 $\\lambda_{i+1}$）：$s_{i} = 210$。\n-   统计模型：试探是具有成功概率 $P_{i}$ 的独立同分布伯努利结果。\n-   要求的统计框架：二项采样，用于渐近正态性的中心极限定理 (CLT)。\n-   置信区间：双边 $95\\%$ 置信度。\n-   计算速率常数的附加已知条件：\n    -   通量：$\\phi_{0} = 5.0 \\times 10^{4} \\, \\mathrm{s}^{-1}$。\n    -   其他概率的乘积：$\\prod_{j\\neq i}P_{j} = 3.0 \\times 10^{-6}$，不确定性可忽略。\n-   误差传播方法：一阶不确定性传播。\n-   报告要求：将所有最终数值四舍五入到四位有效数字。报告六元组 $[\\hat{P}_{i}, \\mathrm{SE}(\\hat{P}_{i}), \\text{CI}_{\\text{low}}(P_{i}), \\text{CI}_{\\text{high}}(P_{i}), \\hat{k}_{AB}, \\mathrm{SE}(\\hat{k}_{AB})]$。\n\n**第 2 步：使用提取的已知条件进行验证**\n-   **科学依据：** 该问题牢固地植根于计算统计力学的原理。前向通量采样是研究稀有事件的标准且广泛使用的算法。使用二项分布和中心极限定理对模拟数据进行统计处理是正确且标准的程序。\n-   **提法明确：** 问题提法明确。它提供了所有必要的数据（$n_i$、$s_i$、$\\phi_0$ 等），并指定了要使用的确切统计方法（CLT、$95\\%$ CI、一阶传播）。问题明确无歧义，并能导出一组唯一的数值答案。\n-   **客观性：** 问题以精确、定量和无偏见的语言陈述。\n\n**第 3 步：结论与行动**\n该问题科学合理、自成体系且提法明确。没有可识别的缺陷。因此，问题被认为是**有效的**，并将提供解答。\n\n**解题推导**\n\n按照要求，问题分两部分解决。\n\n**第 1 部分：条件概率 $P_i$ 及其置信区间的估计**\n\n运行 $n_i$ 次试探轨迹的过程，每次都有一个潜在的成功概率 $P_i$，这是一个伯努利试验序列。成功次数 $s_i$ 服从二项分布，即 $s_i \\sim \\mathrm{Bin}(n_i, P_i)$。\n\n未知概率 $P_i$ 的点估计量是样本比例，记作 $\\hat{P}_i$：\n$$\n\\hat{P}_{i} = \\frac{s_{i}}{n_{i}}\n$$\n代入给定值 $s_i = 210$ 和 $n_i = 1000$：\n$$\n\\hat{P}_{i} = \\frac{210}{1000} = 0.21\n$$\n\n该估计量的方差是 $\\mathrm{Var}(\\hat{P}_i) = \\frac{P_i(1-P_i)}{n_i}$。标准误差 $\\mathrm{SE}(\\hat{P}_i)$ 是 $\\hat{P}_i$ 抽样分布的标准差。通过用 $\\hat{P}_i$ 代替 $P_i$ 来估计：\n$$\n\\mathrm{SE}(\\hat{P}_{i}) = \\sqrt{\\frac{\\hat{P}_{i}(1-\\hat{P}_{i})}{n_{i}}}\n$$\n代入数值：\n$$\n\\mathrm{SE}(\\hat{P}_{i}) = \\sqrt{\\frac{0.21(1 - 0.21)}{1000}} = \\sqrt{\\frac{0.21 \\times 0.79}{1000}} = \\sqrt{\\frac{0.1659}{1000}} = \\sqrt{0.0001659} \\approx 0.012880217\n$$\n\n问题要求使用中心极限定理 (CLT)，这是合理的，因为样本量 $n_i = 1000$ 很大，并且满足条件 $n_i \\hat{P}_i = 210 > 5$ 和 $n_i(1-\\hat{P}_i) = 790 > 5$。CLT 意味着 $\\hat{P}_i$ 的抽样分布近似为正态分布：$\\hat{P}_i \\sim \\mathcal{N}(P_i, \\mathrm{SE}(\\hat{P}_i)^2)$。\n\n$P_i$ 的双边 $95\\%$ 置信区间构建如下：\n$$\n\\mathrm{CI}(P_i) = \\hat{P}_i \\pm z_{\\alpha/2} \\mathrm{SE}(\\hat{P}_i)\n$$\n对于 $95\\%$ 的置信水平，$\\alpha = 0.05$，来自标准正态分布的临界值 $z_{\\alpha/2} = z_{0.025}$ 约为 $1.96$。\n误差范围 (ME) 为：\n$$\n\\mathrm{ME} = z_{0.025} \\times \\mathrm{SE}(\\hat{P}_{i}) \\approx 1.96 \\times 0.012880217 \\approx 0.025245226\n$$\n置信区间的下限和上限为：\n$$\n\\mathrm{CI}_{\\text{low}}(P_{i}) = \\hat{P}_i - \\mathrm{ME} \\approx 0.21 - 0.025245226 = 0.184754774\n$$\n$$\n\\mathrm{CI}_{\\text{high}}(P_{i}) = \\hat{P}_i + \\mathrm{ME} \\approx 0.21 + 0.025245226 = 0.235245226\n$$\n\n**第 2 部分：速率常数 $k_{AB}$ 及其不确定性的估计**\n\n速率常数 $k_{AB}$ 由 $k_{AB} = \\phi_{0} \\prod_{j=0}^{M-1}P_{j}$ 给出。我们可以从乘积中分离出 $P_i$ 项：\n$$\nk_{AB} = \\left(\\phi_{0} \\prod_{j\\neq i}P_{j}\\right) P_{i}\n$$\n我们定义一个常数 $C = \\phi_{0} \\prod_{j\\neq i}P_{j}$。问题陈述该组合项的不确定性可以忽略不计。我们可以计算其值：\n$$\nC = (5.0 \\times 10^{4} \\, \\mathrm{s}^{-1}) \\times (3.0 \\times 10^{-6}) = 15.0 \\times 10^{-2} \\, \\mathrm{s}^{-1} = 0.15 \\, \\mathrm{s}^{-1}\n$$\n所以，关系式为 $k_{AB} = C P_i$。\n\n$k_{AB}$ 的点估计通过使用 $P_i$ 的点估计获得：\n$$\n\\hat{k}_{AB} = C \\hat{P}_{i} = 0.15 \\, \\mathrm{s}^{-1} \\times 0.21 = 0.0315 \\, \\mathrm{s}^{-1}\n$$\n\n$\\hat{k}_{AB}$ 的不确定性通过一阶不确定性传播找到。对于函数 $f(x)$，方差约等于 $(\\frac{df}{dx})^2 \\mathrm{Var}(x)$。在这里，$k_{AB}$ 是 $P_i$ 的线性函数，所以传播是精确的：\n$$\n\\mathrm{Var}(\\hat{k}_{AB}) = \\left(\\frac{\\partial k_{AB}}{\\partial P_i}\\right)^2 \\mathrm{Var}(\\hat{P}_i) = C^2 \\mathrm{Var}(\\hat{P}_i)\n$$\n$\\hat{k}_{AB}$ 的标准误差是方差的平方根：\n$$\n\\mathrm{SE}(\\hat{k}_{AB}) = \\sqrt{C^2 \\mathrm{Var}(\\hat{P}_i)} = |C| \\sqrt{\\mathrm{Var}(\\hat{P}_i)} = C \\cdot \\mathrm{SE}(\\hat{P}_i)\n$$\n因为 $C > 0$。\n$$\n\\mathrm{SE}(\\hat{k}_{AB}) = 0.15 \\times \\mathrm{SE}(\\hat{P}_{i}) \\approx 0.15 \\times 0.012880217 \\, \\mathrm{s}^{-1} \\approx 0.001932032 \\, \\mathrm{s}^{-1}\n$$\n\n**最终整理与四舍五入**\n\n六个所需值必须四舍五入到四位有效数字。\n\n1.  $\\hat{P}_i = 0.21 \\rightarrow 0.2100$\n2.  $\\mathrm{SE}(\\hat{P}_i) \\approx 0.012880217 \\rightarrow 0.01288$\n3.  $\\mathrm{CI}_{\\text{low}}(P_{i}) \\approx 0.184754774 \\rightarrow 0.1848$\n4.  $\\mathrm{CI}_{\\text{high}}(P_{i}) \\approx 0.235245226 \\rightarrow 0.2352$\n5.  $\\hat{k}_{AB} = 0.0315 \\, \\mathrm{s}^{-1} \\rightarrow 0.03150 \\, \\mathrm{s}^{-1}$\n6.  $\\mathrm{SE}(\\hat{k}_{AB}) \\approx 0.001932032 \\, \\mathrm{s}^{-1} \\rightarrow 0.001932 \\, \\mathrm{s}^{-1}$\n\n最终的六元组为 $[\\hat{P}_{i}, \\mathrm{SE}(\\hat{P}_{i}), \\mathrm{CI}_{\\text{low}}(P_{i}), \\mathrm{CI}_{\\text{high}}(P_{i}), \\hat{k}_{AB}, \\mathrm{SE}(\\hat{k}_{AB})]$，其值为 $[0.2100, 0.01288, 0.1848, 0.2352, 0.03150, 0.001932]$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.2100  0.01288  0.1848  0.2352  0.03150  0.001932\n\\end{pmatrix}\n}\n$$"
        }
    ]
}