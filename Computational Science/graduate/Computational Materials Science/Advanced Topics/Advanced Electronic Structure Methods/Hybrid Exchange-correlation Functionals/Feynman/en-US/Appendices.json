{
    "hands_on_practices": [
        {
            "introduction": "A deep understanding of any computational method begins with its mathematical foundation. This exercise  provides a foundational drill, guiding you to derive the complete energy expression for a global hybrid functional from first principles. By explicitly writing out each term—from kinetic energy to Hartree-Fock exchange—and analyzing its computational scaling, you will solidify your grasp of the structure and cost of these powerful tools in electronic structure theory.",
            "id": "3457641",
            "problem": "Consider a finite, spin-restricted closed-shell system in atomic units, described within Kohn–Sham Density Functional Theory (DFT). The system has occupied spatial orbitals $\\{\\phi_i\\}_{i=1}^{N_{\\mathrm{occ}}}$, each doubly occupied, with electron density $\\rho(\\mathbf{r}) = 2 \\sum_{i=1}^{N_{\\mathrm{occ}}} |\\phi_i(\\mathbf{r})|^{2}$. The total Kohn–Sham energy is decomposed into the noninteracting kinetic energy, the external potential energy, the classical electron–electron electrostatic (Hartree) energy, and the exchange–correlation energy. A global hybrid exchange–correlation functional mixes a fixed fraction $a \\in [0,1]$ of Hartree–Fock (HF) exchange with semi-local exchange, while keeping semi-local correlation.\n\nStarting only from these core definitions and the general properties of exchange and correlation in DFT and Hartree–Fock theory, do the following:\n\n- Derive the explicit orbital-integral expressions for every term entering the total energy of a global hybrid functional with mixing $a$, namely the noninteracting kinetic energy, external potential energy, Hartree energy, Hartree–Fock exchange energy, semi-local exchange energy, and semi-local correlation energy, all written in terms of $\\{\\phi_i\\}$ and $\\rho(\\mathbf{r})$.\n\n- For each term, state its leading-order scaling with the number of electrons $N = 2 N_{\\mathrm{occ}}$ in a sequence of size-increasing, neutral, closed-shell systems, and its leading-order computational-work scaling with the number of basis functions $M$ in a typical atom-centered Gaussian basis without auxiliary approximations (for example, without density fitting), identifying the dominant operation counts in the evaluation of that term.\n\n- Qualitatively assess how the completeness of the basis (increasing $M$ or, for plane waves, increasing the cutoff) affects the convergence of each energy term to its basis-set limit, highlighting which terms are most sensitive to basis completeness and why.\n\nYour final answer must be a single closed-form analytic expression that combines all terms to give the total energy of the global hybrid functional with mixing $a$ in terms of $\\{\\phi_i\\}$ and $\\rho(\\mathbf{r})$. No numerical evaluation is required. If you introduce any acronym, spell out its full name on first use. Use atomic units throughout.",
            "solution": "We begin from the foundational decomposition of the Kohn–Sham Density Functional Theory (DFT) total energy for a spin-restricted closed-shell system. The Kohn–Sham noninteracting kinetic energy arises from the single-particle orbitals, the external potential energy is the interaction of the density with the nuclear potential, the Hartree energy is the classical electrostatic energy of the density, and the exchange–correlation energy accounts for quantum exchange and correlation effects.\n\nWe use atomic units, where $\\hbar = 1$, electron mass $m_{e} = 1$, and the Coulomb constant is unity. For a spin-restricted closed-shell with occupied spatial orbitals $\\{\\phi_i\\}_{i=1}^{N_{\\mathrm{occ}}}$, the electron density is\n$$\n\\rho(\\mathbf{r}) = 2 \\sum_{i=1}^{N_{\\mathrm{occ}}} |\\phi_i(\\mathbf{r})|^{2}.\n$$\n\nThe Kohn–Sham noninteracting kinetic energy $T_{s}$ is the sum of single-particle kinetic energies for doubly occupied spatial orbitals. In atomic units, for each spatial orbital $\\phi_i(\\mathbf{r})$, the kinetic energy contribution per spin channel is $\\int \\frac{1}{2} |\\nabla \\phi_i(\\mathbf{r})|^{2} \\, d\\mathbf{r}$. Since the orbitals are doubly occupied, the total noninteracting kinetic energy can be written compactly as\n$$\nT_{s}[\\{\\phi_i\\}] = \\sum_{i=1}^{N_{\\mathrm{occ}}} \\int |\\nabla \\phi_i(\\mathbf{r})|^{2} \\, d\\mathbf{r}.\n$$\nThis uses the identity $2 \\times \\frac{1}{2} = 1$ per orbital in atomic units.\n\nThe external potential energy $V_{\\mathrm{ext}}$ is\n$$\nV_{\\mathrm{ext}}[\\rho] = \\int v_{\\mathrm{ext}}(\\mathbf{r}) \\, \\rho(\\mathbf{r}) \\, d\\mathbf{r},\n$$\nwhere $v_{\\mathrm{ext}}(\\mathbf{r})$ is the external (nuclear) potential.\n\nThe Hartree (classical Coulomb) energy of the density is\n$$\nE_{\\mathrm{H}}[\\rho] = \\frac{1}{2} \\iint \\frac{\\rho(\\mathbf{r}) \\, \\rho(\\mathbf{r}')}{|\\mathbf{r} - \\mathbf{r}'|} \\, d\\mathbf{r} \\, d\\mathbf{r}'.\n$$\n\nThe Hartree–Fock (HF) exchange energy for a spin-restricted closed-shell, evaluated with the Kohn–Sham orbitals, can be expressed in terms of the occupied spatial orbitals as\n$$\nE_{x}^{\\mathrm{HF}}[\\{\\phi_i\\}] = - \\sum_{i=1}^{N_{\\mathrm{occ}}} \\sum_{j=1}^{N_{\\mathrm{occ}}} \\iint \\frac{\\phi_i(\\mathbf{r}) \\, \\phi_j(\\mathbf{r}) \\, \\phi_i(\\mathbf{r}') \\, \\phi_j(\\mathbf{r}')}{|\\mathbf{r} - \\mathbf{r}'|} \\, d\\mathbf{r} \\, d\\mathbf{r}',\n$$\nwhere, for simplicity, we assume real orbitals; for complex orbitals, each $\\phi$ should be replaced by its complex conjugate where appropriate.\n\nThe semi-local exchange energy $E_{x}^{\\mathrm{sl}}[\\rho]$ and semi-local correlation energy $E_{c}^{\\mathrm{sl}}[\\rho]$ are functionals of the density (and possibly its gradients and other simple local descriptors). Without specifying a particular form (such as the Local Density Approximation (LDA) or Generalized Gradient Approximation (GGA)), we write them generically as spatial integrals of local energy densities:\n$$\nE_{x}^{\\mathrm{sl}}[\\rho] = \\int e_{x}^{\\mathrm{sl}}\\!\\left(\\rho(\\mathbf{r}), \\nabla \\rho(\\mathbf{r})\\right) \\, d\\mathbf{r},\n\\qquad\nE_{c}^{\\mathrm{sl}}[\\rho] = \\int e_{c}^{\\mathrm{sl}}\\!\\left(\\rho(\\mathbf{r}), \\nabla \\rho(\\mathbf{r})\\right) \\, d\\mathbf{r}.\n$$\n\nA global hybrid exchange–correlation functional mixes a fixed fraction $a \\in [0,1]$ of Hartree–Fock exchange with semi-local exchange and retains semi-local correlation. Therefore, the exchange–correlation energy in a global hybrid is\n$$\nE_{xc}^{\\mathrm{hyb}}[\\{\\phi_i\\},\\rho] = a \\, E_{x}^{\\mathrm{HF}}[\\{\\phi_i\\}] + (1 - a) \\, E_{x}^{\\mathrm{sl}}[\\rho] + E_{c}^{\\mathrm{sl}}[\\rho].\n$$\n\nCombining all terms, the total energy of the global hybrid functional with mixing $a$ is\n$$\nE^{\\mathrm{hyb}}[\\{\\phi_i\\},\\rho] = T_{s}[\\{\\phi_i\\}] + V_{\\mathrm{ext}}[\\rho] + E_{\\mathrm{H}}[\\rho] + a \\, E_{x}^{\\mathrm{HF}}[\\{\\phi_i\\}] + (1 - a) \\, E_{x}^{\\mathrm{sl}}[\\rho] + E_{c}^{\\mathrm{sl}}[\\rho].\n$$\nSubstituting the explicit forms above yields the final closed-form expression in terms of $\\{\\phi_i\\}$ and $\\rho(\\mathbf{r})$.\n\nWe now address the requested scaling analyses.\n\nLeading-order scaling with the number of electrons $N = 2 N_{\\mathrm{occ}}$ in neutral, finite, closed-shell systems:\n- $T_{s}[\\{\\phi_i\\}]$: As $N$ increases at fixed average density and chemical composition, the kinetic energy is extensive and scales as $\\mathcal{O}(N)$.\n- $V_{\\mathrm{ext}}[\\rho]$: For fixed nuclear charge distribution per electron, this scales as $\\mathcal{O}(N)$ (extensive).\n- $E_{\\mathrm{H}}[\\rho]$: The Hartree term counts electron–electron pairs and, in general, scales as $\\mathcal{O}(N^{2})$ in magnitude. For neutral finite systems, long-range cancellation in total energy may reduce net scaling in some contexts, but the bare Hartree contribution itself is pairwise and hence $\\mathcal{O}(N^{2})$.\n- $E_{x}^{\\mathrm{HF}}[\\{\\phi_i\\}]$: Exchange also counts same-spin electron pairs and scales as $\\mathcal{O}(N^{2})$ in magnitude for extended growth of similarly structured systems.\n- $E_{x}^{\\mathrm{sl}}[\\rho]$ and $E_{c}^{\\mathrm{sl}}[\\rho]$: Semi-local functionals integrate local energy densities and are extensive, scaling as $\\mathcal{O}(N)$.\n\nLeading-order computational-work scaling with the number of basis functions $M$ in a typical Gaussian atomic-orbital basis, using standard four-center integrals and no auxiliary approximations:\n- One-electron terms $T_{s}$ and $V_{\\mathrm{ext}}$: Constructing and contracting one-electron matrices with the density matrix scales as $\\mathcal{O}(M^{2})$ in energy evaluation (assuming integrals are precomputed or cheaply available).\n- $E_{\\mathrm{H}}$: Naively, four-center two-electron Coulomb integrals scale as $\\mathcal{O}(M^{4})$ to build, with energy evaluation and Fock-like contractions also $\\mathcal{O}(M^{4})$; with standard approximations (not assumed here), this can be reduced, but the leading naive scaling is $\\mathcal{O}(M^{4})$.\n- $E_{x}^{\\mathrm{HF}}$: The HF exchange energy involves the same class of four-center two-electron integrals and contractions and thus scales naively as $\\mathcal{O}(M^{4})$.\n- Semi-local $E_{x}^{\\mathrm{sl}}$ and $E_{c}^{\\mathrm{sl}}$: Evaluated on a numerical quadrature grid, the dominant cost is obtaining $\\rho(\\mathbf{r})$ and $\\nabla \\rho(\\mathbf{r})$ on the grid and performing grid integrations. If the grid size scales proportionally to $M$, typical contraction cost is between $\\mathcal{O}(M^{2})$ (density matrix to grid) and $\\mathcal{O}(M \\, N_{g})$ depending on implementation; the functional evaluation itself is $\\mathcal{O}(N_{g})$. In analytic AO approaches (less common for GGA), scaling can be kept near $\\mathcal{O}(M^{2})$.\n\nBasis completeness and convergence behavior:\n- $T_{s}$ and $V_{\\mathrm{ext}}$ depend on single-particle orbitals and their smoothness. In atom-centered Gaussian bases with systematically improvable sequences, energies converge rapidly (often near-exponential with increasing cardinality for bound states) as the orbitals are well represented. In plane-wave bases, convergence is controlled by the kinetic-energy cutoff; smooth orbitals yield relatively fast convergence in these terms.\n- $E_{\\mathrm{H}}$ depends on $\\rho(\\mathbf{r})$ and is comparatively less sensitive to subtle high-frequency components of the orbitals; with an accurate density, it converges steadily with basis set improvements or grid refinements. In plane waves, solving Poisson’s equation yields rapid and controllable convergence with cutoff.\n- $E_{x}^{\\mathrm{HF}}$ is nonlocal and depends on products of occupied orbitals at two points, $\\phi_i(\\mathbf{r}) \\phi_j(\\mathbf{r}')$, divided by $|\\mathbf{r}-\\mathbf{r}'|$. Accurate representation of these orbital products requires greater completeness in the underlying orbital product space. Consequently, $E_{x}^{\\mathrm{HF}}$ typically converges more slowly with basis size than the semi-local terms, and is sensitive to completeness in both angular and radial components (for Gaussian bases) or to high cutoff (for plane waves), reflecting its long-range, nonlocal character.\n- Semi-local $E_{x}^{\\mathrm{sl}}$ and $E_{c}^{\\mathrm{sl}}$ depend on $\\rho(\\mathbf{r})$ (and possibly $\\nabla \\rho(\\mathbf{r})$). Because the density is a sum of orbital squares, it is smoother than individual orbitals, and these terms generally converge more rapidly with basis improvements than $E_{x}^{\\mathrm{HF}}$. In plane-wave representations, gradients are well-controlled by the cutoff and converge systematically.\n\nFinally, assembling the explicit orbital-integral form for the total energy in a global hybrid with mixing $a$ yields the required analytic expression.",
            "answer": "$$\\boxed{\\sum_{i=1}^{N_{\\mathrm{occ}}} \\int |\\nabla \\phi_i(\\mathbf{r})|^{2} \\, d\\mathbf{r} \\;+\\; \\int v_{\\mathrm{ext}}(\\mathbf{r}) \\, \\rho(\\mathbf{r}) \\, d\\mathbf{r} \\;+\\; \\frac{1}{2} \\iint \\frac{\\rho(\\mathbf{r}) \\, \\rho(\\mathbf{r}')}{|\\mathbf{r} - \\mathbf{r}'|} \\, d\\mathbf{r} \\, d\\mathbf{r}' \\;+\\; a \\left( - \\sum_{i=1}^{N_{\\mathrm{occ}}} \\sum_{j=1}^{N_{\\mathrm{occ}}} \\iint \\frac{\\phi_i(\\mathbf{r}) \\, \\phi_j(\\mathbf{r}) \\, \\phi_i(\\mathbf{r}') \\, \\phi_j(\\mathbf{r}')}{|\\mathbf{r} - \\mathbf{r}'|} \\, d\\mathbf{r} \\, d\\mathbf{r}' \\right) \\;+\\; (1 - a) \\int e_{x}^{\\mathrm{sl}}\\!\\left(\\rho(\\mathbf{r}), \\nabla \\rho(\\mathbf{r})\\right) \\, d\\mathbf{r} \\;+\\; \\int e_{c}^{\\mathrm{sl}}\\!\\left(\\rho(\\mathbf{r}), \\nabla \\rho(\\mathbf{r})\\right) \\, d\\mathbf{r}}$$"
        },
        {
            "introduction": "Having established the theoretical form of hybrid functionals, we now turn to their practical utility. This exercise  uses a physically-motivated model to demonstrate how hybrid functionals correct one of the most well-known deficiencies of semilocal DFT: the underestimation of semiconductor band gaps. You will implement a model based on perturbation theory to explore the interplay between the exact exchange fraction, dielectric screening, and orbital character in determining the final band gap, connecting abstract theory to a tangible material property.",
            "id": "3457585",
            "problem": "You are asked to construct and implement a physically motivated, first-principles-inspired model that estimates the change in the fundamental band gap of a semiconductor upon introducing a hybrid exchange-correlation term with an exact-exchange mixing parameter $a = 0.25$. The model must be derived from the following foundational base: time-independent, non-degenerate first-order perturbation theory from quantum mechanics and the operator form of hybrid functionals in Kohn-Sham Density Functional Theory (DFT), where a fraction of Hartree-Fock (HF) exact exchange is mixed with a semilocal exchange potential from a Generalized Gradient Approximation (GGA). The goal is to reason from these principles to a computationally implementable expression for the band gap change and then quantify sensitivities to dielectric screening and the orbital character of band-edge states.\n\nStart from these well-tested principles and definitions:\n- In the Kohn-Sham framework of Density Functional Theory (DFT), the introduction of a hybrid exchange-correlation operator can be expressed as an additive perturbation to a reference Hamiltonian constructed with a semilocal functional (for example, a Generalized Gradient Approximation (GGA)). Denote the unperturbed Hamiltonian as $\\hat{H}_{0}$ and the hybrid Hamiltonian as $\\hat{H}(a)$, where $a$ is the fraction of exact exchange.\n- A screened hybrid may be modeled by scaling the exact-exchange perturbation by the high-frequency dielectric constant $\\epsilon_{\\infty}$ to emulate dielectric screening of nonlocal exchange in solids.\n- In time-independent, non-degenerate first-order perturbation theory, the first-order energy correction for a normalized eigenstate $\\lvert \\psi_{i} \\rangle$ of $\\hat{H}_{0}$ due to a perturbation $\\hat{W}$ is $\\Delta \\varepsilon_{i}^{(1)} = \\langle \\psi_{i} \\lvert \\hat{W} \\rvert \\psi_{i} \\rangle$.\n- The hybrid perturbation operator is the difference between the nonlocal Hartree-Fock exchange operator and the semilocal exchange potential, scaled by the mixing $a$ and the dielectric screening $\\epsilon_{\\infty}$.\n\nYou will translate these principles into a numerical model under the following scientifically standard and explicitly stated approximations:\n- The first-order change of the conduction-band minimum and valence-band maximum energies, denoted $\\Delta \\varepsilon_{c}$ and $\\Delta \\varepsilon_{v}$, is computed using first-order perturbation theory with the perturbation operator modeled as the screened exact-exchange-minus-semilocal-exchange difference.\n- The expectation value of this perturbation for a given band-edge state is approximated by an orbital-character-weighted sum over angular-momentum channels $\\ell \\in \\{ s, p, d \\}$:\n  $$\\langle \\psi_{i} \\lvert \\hat{W} \\rvert \\psi_{i} \\rangle \\approx \\sum_{\\ell \\in \\{s,p,d\\}} w_{i,\\ell} \\, M_{i}(\\ell),$$\n  where $w_{i,\\ell}$ are nonnegative weights that sum to unity, and $M_{i}(\\ell)$ are material- and edge-specific reference matrix elements (in electronvolts) tabulated for the unscreened, unit-mixing case ($a = 1$, $\\epsilon_{\\infty} = 1$).\n- For occupied valence states, the exact exchange typically lowers the energy relative to a semilocal reference, while for unoccupied conduction states it raises the energy, thereby opening the band gap. You will reflect this sign difference when forming the band gap change $\\Delta E_{g} = \\Delta \\varepsilon_{c} - \\Delta \\varepsilon_{v}$.\n\nYour program must, for each test case specified below, compute:\n- The band gap change $\\Delta E_{g}$ in electronvolts due to introducing $a = 0.25$ exact exchange with screening by $\\epsilon_{\\infty}$.\n- The sensitivity of the band gap change with respect to $\\epsilon_{\\infty}$, namely the derivative $\\frac{\\partial \\Delta E_{g}}{\\partial \\epsilon_{\\infty}}$, evaluated at the specified $\\epsilon_{\\infty}$.\n- The decomposition of $\\Delta E_{g}$ into contributions from each orbital channel for the conduction-band edge and the valence-band edge, defined as the positive additive terms that sum to $\\Delta E_{g}$:\n  $$C_{c,\\ell} \\;\\text{for}\\; \\ell \\in \\{s,p,d\\}, \\quad C_{v,\\ell} \\;\\text{for}\\; \\ell \\in \\{s,p,d\\}.$$\n\nAll energies must be reported in electronvolts (eV). The derivative $\\frac{\\partial \\Delta E_{g}}{\\partial \\epsilon_{\\infty}}$ must be reported in electronvolts per unit of $\\epsilon_{\\infty}$, where $\\epsilon_{\\infty}$ is dimensionless. Your program must round every reported floating-point number to $6$ decimals before printing.\n\nUse the following fixed parameters for the orbital-channel matrix elements $M_{i}(\\ell)$ (in eV), which represent reference unscreened, unit-mixing expectation values:\n- Conduction-band edge: $M_{c}(s) = 1.0$, $M_{c}(p) = 1.5$, $M_{c}(d) = 3.0$.\n- Valence-band edge: $M_{v}(s) = 1.2$, $M_{v}(p) = 2.0$, $M_{v}(d) = 3.5$.\n\nFor each test case, you are given $\\epsilon_{\\infty}$ and the orbital weight triplets for the conduction- and valence-band edges, $(w_{c,s}, w_{c,p}, w_{c,d})$ and $(w_{v,s}, w_{v,p}, w_{v,d})$. If a triplet does not sum to unity due to roundoff, normalize it so that $\\sum_{\\ell} w_{i,\\ell} = 1$.\n\nTest suite (each case supplies $\\epsilon_{\\infty}$ and the two weight triplets in the order $(w_{c,s}, w_{c,p}, w_{c,d})$ and $(w_{v,s}, w_{v,p}, w_{v,d})$):\n- Case $1$: $\\epsilon_{\\infty} = 4.0$, $(0.6, 0.4, 0.0)$, $(0.2, 0.8, 0.0)$.\n- Case $2$: $\\epsilon_{\\infty} = 15.0$, $(0.6, 0.4, 0.0)$, $(0.2, 0.8, 0.0)$.\n- Case $3$: $\\epsilon_{\\infty} = 1.0$, $(0.6, 0.4, 0.0)$, $(0.2, 0.8, 0.0)$.\n- Case $4$: $\\epsilon_{\\infty} = 5.0$, $(0.0, 0.2, 0.8)$, $(0.1, 0.1, 0.8)$.\n- Case $5$: $\\epsilon_{\\infty} = 7.0$, $(1.0, 0.0, 0.0)$, $(0.0, 1.0, 0.0)$.\n\nRequired output for each case, in this exact order:\n- $\\Delta E_{g}$,\n- $\\frac{\\partial \\Delta E_{g}}{\\partial \\epsilon_{\\infty}}$,\n- $C_{c,s}$, $C_{c,p}$, $C_{c,d}$,\n- $C_{v,s}$, $C_{v,p}$, $C_{v,d}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the values for Case $1$ first, followed by Case $2$, ..., through Case $5$. For example: \"[result1,result2,...,resultN]\". Every number must be rounded to $6$ decimals.",
            "solution": "The problem requires the construction of a model to estimate the change in a semiconductor's fundamental band gap, $\\Delta E_g$, upon the introduction of a hybrid exchange-correlation functional. The model must be derived from first-order perturbation theory and the operator form of hybrid functionals. We will systematically derive the expressions for the band gap change, its sensitivity to dielectric screening, and its decomposition into orbital-channel contributions.\n\nThe foundational principles are:\n1.  The hybrid Hamiltonian $\\hat{H}(a)$ is treated as a perturbation to a semilocal (GGA) Hamiltonian $\\hat{H}_0$. The perturbation operator, $\\hat{W}$, arises from mixing a fraction $a$ of Hartree-Fock (exact) exchange, scaled by the inverse of the high-frequency dielectric constant $1/\\epsilon_{\\infty}$, with the GGA functional.\n2.  The first-order energy correction to a non-degenerate eigenstate $\\lvert\\psi_i\\rangle$ of $\\hat{H}_0$ is given by the expectation value $\\Delta\\varepsilon_i = \\langle\\psi_i\\lvert\\hat{W}\\rvert\\psi_i\\rangle$.\n3.  This expectation value is approximated by a weighted sum over orbital characters $\\ell \\in \\{s, p, d\\}$.\n\nFirst, we formalize the perturbation operator $\\hat{W}$. The problem states that the perturbation involves replacing a fraction $a$ of the semilocal exchange potential, let's denote it $\\hat{V}_x^{\\text{GGA}}$, with the same fraction of the non-local Hartree-Fock (HF) exchange operator, $\\hat{V}_x^{\\text{HF}}$. This difference is then screened by the dielectric constant $\\epsilon_{\\infty}$. The resulting perturbation operator is:\n$$ \\hat{W} = \\frac{a}{\\epsilon_{\\infty}} \\left( \\hat{V}_x^{\\text{HF}} - \\hat{V}_x^{\\text{GGA}} \\right) $$\nThe first-order energy correction for an electronic state $\\lvert\\psi_i\\rangle$ (where $i$ denotes either the conduction band minimum, $c$, or the valence band maximum, $v$) is:\n$$ \\Delta\\varepsilon_i = \\langle\\psi_i\\lvert \\hat{W} \\rvert\\psi_i\\rangle = \\frac{a}{\\epsilon_{\\infty}} \\langle\\psi_i\\lvert \\hat{V}_x^{\\text{HF}} - \\hat{V}_x^{\\text{GGA}} \\rvert\\psi_i\\rangle $$\nThe problem provides a specific approximation for the expectation value, based on reference matrix elements $M_i(\\ell)$ which are defined for the unscreened ($ \\epsilon_{\\infty}=1 $) and unit-mixing ($ a=1 $) case. The expectation value for the unscreened, unit-mixing perturbation is given by:\n$$ \\langle\\psi_i\\lvert \\hat{V}_x^{\\text{HF}} - \\hat{V}_x^{\\text{GGA}} \\rvert\\psi_i\\rangle \\approx \\sum_{\\ell \\in \\{s,p,d\\}} w_{i,\\ell} M_i(\\ell) $$\nwhere $w_{i,\\ell}$ are the normalized orbital weights for state $i$ and channel $\\ell$. Let's define this orbitally-averaged matrix element as $M_i^{\\text{avg}} = \\sum_{\\ell} w_{i,\\ell} M_i(\\ell)$.\n\nThe energy correction $\\Delta\\varepsilon_i$ is thus:\n$$ \\Delta\\varepsilon_i \\approx \\frac{a}{\\epsilon_{\\infty}} M_i^{\\text{avg}} $$\nA crucial physical consideration is the sign of the correction. For an unoccupied conduction state ($i=c$), the introduction of exact exchange raises the energy, so $\\Delta\\varepsilon_c$ is positive. The given $M_c(\\ell)$ values are positive, so this is consistent. For an occupied valence state ($i=v$), exact exchange lowers the energy relative to the self-interaction-prone semilocal approximation, so $\\Delta\\varepsilon_v$ is negative. We must therefore introduce a sign explicitly.\n$$ \\Delta\\varepsilon_c = +\\frac{a}{\\epsilon_{\\infty}} M_c^{\\text{avg}} = +\\frac{a}{\\epsilon_{\\infty}} \\sum_{\\ell} w_{c,\\ell} M_c(\\ell) $$\n$$ \\Delta\\varepsilon_v = -\\frac{a}{\\epsilon_{\\infty}} M_v^{\\text{avg}} = -\\frac{a}{\\epsilon_{\\infty}} \\sum_{\\ell} w_{v,\\ell} M_v(\\ell) $$\nThe change in the band gap, $\\Delta E_g$, is the change in the conduction edge energy minus the change in the valence edge energy:\n$$ \\Delta E_g = \\Delta\\varepsilon_c - \\Delta\\varepsilon_v $$\nSubstituting the expressions for the energy corrections yields:\n$$ \\Delta E_g = \\left(\\frac{a}{\\epsilon_{\\infty}} M_c^{\\text{avg}}\\right) - \\left(-\\frac{a}{\\epsilon_{\\infty}} M_v^{\\text{avg}}\\right) = \\frac{a}{\\epsilon_{\\infty}} \\left( M_c^{\\text{avg}} + M_v^{\\text{avg}} \\right) $$\nThis expression elegantly shows that both the up-shift of the conduction band and the down-shift of the valence band contribute additively to opening the band gap.\n\nNext, we compute the sensitivity of the band gap change with respect to the dielectric constant, $\\frac{\\partial \\Delta E_g}{\\partial \\epsilon_{\\infty}}$. We differentiate the expression for $\\Delta E_g$ with respect to $\\epsilon_{\\infty}$, treating $a$, $w_{i,\\ell}$, and $M_i(\\ell)$ as constants:\n$$ \\frac{\\partial \\Delta E_g}{\\partial \\epsilon_{\\infty}} = \\frac{\\partial}{\\partial \\epsilon_{\\infty}} \\left[ \\frac{a}{\\epsilon_{\\infty}} \\left( M_c^{\\text{avg}} + M_v^{\\text{avg}} \\right) \\right] = a \\left( M_c^{\\text{avg}} + M_v^{\\text{avg}} \\right) \\frac{\\partial}{\\partial \\epsilon_{\\infty}} \\left( \\frac{1}{\\epsilon_{\\infty}} \\right) $$\n$$ \\frac{\\partial \\Delta E_g}{\\partial \\epsilon_{\\infty}} = - \\frac{a}{\\epsilon_{\\infty}^2} \\left( M_c^{\\text{avg}} + M_v^{\\text{avg}} \\right) $$\nBy comparing this with the expression for $\\Delta E_g$, we find the simple relationship:\n$$ \\frac{\\partial \\Delta E_g}{\\partial \\epsilon_{\\infty}} = -\\frac{\\Delta E_g}{\\epsilon_{\\infty}} $$\nFinally, we determine the orbital contributions, $C_{c,\\ell}$ and $C_{v,\\ell}$, defined as the positive additive terms that sum to $\\Delta E_g$. From our expression for $\\Delta E_g$:\n$$ \\Delta E_g = \\frac{a}{\\epsilon_{\\infty}} \\sum_{\\ell} w_{c,\\ell} M_c(\\ell) + \\frac{a}{\\epsilon_{\\infty}} \\sum_{\\ell} w_{v,\\ell} M_v(\\ell) $$\nThe decomposition is straightforward. The contribution from the conduction band edge channel $\\ell$ is:\n$$ C_{c,\\ell} = \\frac{a}{\\epsilon_{\\infty}} w_{c,\\ell} M_c(\\ell) $$\nAnd the contribution from the valence band edge channel $\\ell$ is:\n$$ C_{v,\\ell} = \\frac{a}{\\epsilon_{\\infty}} w_{v,\\ell} M_v(\\ell) $$\nBy construction, $\\sum_{\\ell} (C_{c,\\ell} + C_{v,\\ell}) = \\Delta E_g$.\n\nTo summarize, for each test case with given parameters $a = 0.25$, $\\epsilon_{\\infty}$, and orbital weights $(w_{c,s}, w_{c,p}, w_{c,d})$ and $(w_{v,s}, w_{v,p}, w_{v,d})$, and fixed reference matrix elements $M_c(\\ell)$ and $M_v(\\ell)$, the computational procedure is as follows:\n1.  Normalize the weight triplets $\\{w_{c,\\ell}\\}$ and $\\{w_{v,\\ell}\\}$ to ensure they each sum to $1$.\n2.  Compute the orbitally-averaged matrix elements $M_c^{\\text{avg}} = \\sum_{\\ell} w_{c,\\ell} M_c(\\ell)$ and $M_v^{\\text{avg}} = \\sum_{\\ell} w_{v,\\ell} M_v(\\ell)$.\n3.  Calculate the band gap change $\\Delta E_g = \\frac{a}{\\epsilon_{\\infty}} (M_c^{\\text{avg}} + M_v^{\\text{avg}})$.\n4.  Calculate the sensitivity $\\frac{\\partial \\Delta E_g}{\\partial \\epsilon_{\\infty}} = -\\frac{\\Delta E_g}{\\epsilon_{\\infty}}$.\n5.  Calculate the orbital contributions $C_{c,\\ell} = \\frac{a}{\\epsilon_{\\infty}} w_{c,\\ell} M_c(\\ell)$ and $C_{v,\\ell} = \\frac{a}{\\epsilon_{\\infty}} w_{v,\\ell} M_v(\\ell)$ for $\\ell \\in \\{s, p, d\\}$.\nAll numerical results are to be rounded to $6$ decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the change in a semiconductor's band gap based on a first-principles-inspired model.\n\n    The model uses first-order perturbation theory to estimate the energy shifts of the\n    conduction and valence band edges upon introducing a hybrid exchange-correlation functional.\n    The perturbation is scaled by an exact-exchange mixing fraction 'a' and a dielectric\n    screening constant 'epsilon_infinity'. The model further approximates the perturbation\n    matrix elements using an orbital-character-weighted sum over s, p, and d channels.\n    \"\"\"\n\n    # Fixed parameters from the problem statement\n    A_MIX = 0.25  # Exact-exchange mixing parameter\n    \n    # Reference unscreened, unit-mixing matrix elements M_i(l) in eV\n    # Index 0: s, 1: p, 2: d\n    M_C = np.array([1.0, 1.5, 3.0])  # Conduction-band edge\n    M_V = np.array([1.2, 2.0, 3.5])  # Valence-band edge\n\n    # Test suite: (epsilon_infinity, (wc_s, wc_p, wc_d), (wv_s, wv_p, wv_d))\n    test_cases = [\n        (4.0, (0.6, 0.4, 0.0), (0.2, 0.8, 0.0)),\n        (15.0, (0.6, 0.4, 0.0), (0.2, 0.8, 0.0)),\n        (1.0, (0.6, 0.4, 0.0), (0.2, 0.8, 0.0)),\n        (5.0, (0.0, 0.2, 0.8), (0.1, 0.1, 0.8)),\n        (7.0, (1.0, 0.0, 0.0), (0.0, 1.0, 0.0)),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        eps_inf, w_c_raw, w_v_raw = case\n        \n        # Convert weight tuples to numpy arrays for vector operations\n        w_c = np.array(w_c_raw, dtype=float)\n        w_v = np.array(w_v_raw, dtype=float)\n        \n        # Step 1: Normalize orbital weights if they do not sum to 1\n        sum_w_c = np.sum(w_c)\n        if sum_w_c > 0 and not np.isclose(sum_w_c, 1.0):\n            w_c /= sum_w_c\n            \n        sum_w_v = np.sum(w_v)\n        if sum_w_v > 0 and not np.isclose(sum_w_v, 1.0):\n            w_v /= sum_w_v\n\n        # Step 2: Compute orbitally-averaged matrix elements\n        m_c_avg = np.dot(w_c, M_C)\n        m_v_avg = np.dot(w_v, M_V)\n        \n        # Step 3: Calculate the band gap change\n        delta_eg = (A_MIX / eps_inf) * (m_c_avg + m_v_avg)\n        \n        # Step 4: Calculate the sensitivity derivative\n        d_delta_eg_d_eps = -delta_eg / eps_inf\n        \n        # Step 5: Calculate the decomposition into orbital contributions\n        scale_factor = A_MIX / eps_inf\n        c_c = scale_factor * w_c * M_C\n        c_v = scale_factor * w_v * M_V\n        \n        # Collect and round all results for the current case to 6 decimals\n        results_for_case = [\n            round(delta_eg, 6),\n            round(d_delta_eg_d_eps, 6),\n            round(c_c[0], 6), round(c_c[1], 6), round(c_c[2], 6), # C_c,s,p,d\n            round(c_v[0], 6), round(c_v[1], 6), round(c_v[2], 6), # C_v,s,p,d\n        ]\n        \n        all_results.extend(results_for_case)\n        \n    # Final print statement in the exact required format.\n    # The f-string formatting ensures that trailing zeros are printed,\n    # satisfying the visual representation of 6 decimal places.\n    print(f\"[{','.join(f'{x:.6f}' for x in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The enhanced accuracy of hybrid functionals comes at a significant computational price, primarily due to the non-local exact exchange term. This advanced practice  tackles this critical challenge by guiding you through the implementation of a model linear-scaling algorithm. By leveraging the principle of electronic 'nearsightedness' through spatial cutoffs, you will explore the fundamental trade-off between computational efficiency and accuracy that underpins modern large-scale electronic structure calculations.",
            "id": "3457635",
            "problem": "You are asked to design and implement a complete, runnable program that models and evaluates a linear-scaling algorithm for the Hartree–Fock (HF) exact-exchange energy within hybrid exchange–correlation functionals, using localized orbitals and density-matrix truncation. The goal is to formalize the sparsity versus error trade-offs in large porous frameworks by comparing a dense reference evaluation against a screened, neighbor-list-based linear-scaling algorithm. Your solution must be grounded in first principles and proceed from the standard definition of exchange in Hartree–Fock theory and the nearsightedness of electronic matter.\n\nStart from the following foundational definitions and well-tested facts:\n- The Hartree–Fock (HF) exchange energy can be written in an orthonormal localized basis as\n$$\nE_x^{\\text{HF}} \\;=\\; -\\frac{1}{2}\\sum_{\\mu,\\nu,\\lambda,\\sigma} P_{\\mu\\lambda}\\,P_{\\nu\\sigma}\\,(\\mu\\nu|\\lambda\\sigma),\n$$\nwhere $P$ is the one-particle density matrix and $(\\mu\\nu|\\lambda\\sigma)$ are the two-electron repulsion integrals over the Coulomb kernel.\n- In insulating solids with localized orbitals, the elements of the density matrix $P_{ij}$ decay exponentially with the distance $r_{ij}$ between orbital centers, a manifestation of the nearsightedness of electronic matter.\n- In large porous frameworks, this decay leads to sparsity in the density matrix and in screened Coulomb interactions, enabling linear-scaling algorithms via locality and truncation.\n\nTo keep the computation fully self-contained and tractable while still testing the principles of linear scaling, consider the following model exchange functional that captures the correct qualitative locality of exchange without requiring full four-center integrals:\n$$\nE_x^{\\text{model}} \\;=\\; -\\frac{1}{2}\\sum_{i,j} \\left(P_{ij}\\right)^2\\,K(r_{ij}),\n$$\nwith\n$$\nP_{ij} \\;=\\;\n\\begin{cases}\n1, & i=j,\\\\\n\\exp\\!\\left(-\\left(\\frac{r_{ij}}{\\xi}\\right)^2\\right), & i\\neq j,\n\\end{cases}\n\\quad\\text{and}\\quad\nK(r) \\;=\\; \\dfrac{\\exp\\!\\left(-\\left(\\dfrac{r}{\\lambda}\\right)^2\\right)}{\\sqrt{r^2 + r_0^2}}.\n$$\nHere $r_{ij}$ is the Euclidean distance between centers $i$ and $j$, $\\xi$ is the density-matrix decay length, $\\lambda$ is the interaction screening length, and $r_0$ is a short-distance regularizer that yields a finite self-exchange when $r=0$.\n\nYou must do the following:\n1. Construct three-dimensional atomic frameworks as points on a simple cubic lattice with spacing $a=1$ (dimensionless units), with lattice size $n\\times n\\times n$. Introduce porosity by carving out a spherical pore of radius $R_p$ centered at the geometric center of the cube; retain only lattice sites whose distance from the center is greater than or equal to $R_p$. When $R_p=0$, this reduces to the full dense cube.\n2. For each framework, compute a dense reference value of $E_x^{\\text{model}}$ by evaluating the full double sum over all pairs $(i,j)$ without truncation.\n3. Implement a linear-scaling algorithm that uses a pairwise spatial cutoff and density-matrix truncation:\n   - Use a neighbor-list constructed from a uniform cell grid with cell size equal to the distance cutoff $R_c$ to restrict candidate neighbors $j$ of a site $i$ to those lying within distance $R_c$.\n   - Apply density-matrix truncation by skipping any pair $(i,j)$ for which $\\lvert P_{ij} \\rvert < \\tau$, where $\\tau$ is a non-negative threshold.\n   - Accumulate the sparse approximate energy\n   $$\n   E_x^{\\text{sparse}} \\;=\\; -\\frac{1}{2}\\sum_{(i,j)\\,\\text{kept}} \\left(P_{ij}\\right)^2\\,K(r_{ij}),\n   $$\n   where the sum runs only over the retained pairs under the above truncations. You must count the number of retained ordered pairs $(i,j)$, including $i=j$ when allowed by the cutoff, to quantify sparsity.\n4. For each case, report the relative error\n$$\n\\varepsilon \\;=\\; \\dfrac{\\lvert E_x^{\\text{sparse}} - E_x^{\\text{ref}} \\rvert}{\\lvert E_x^{\\text{ref}} \\rvert}\n$$\nand the retained-pair fraction\n$$\ns \\;=\\; \\dfrac{N_{\\text{kept}}}{N^2},\n$$\nwhere $N$ is the number of sites after porosity filtering and $N_{\\text{kept}}$ is the count of ordered pairs actually evaluated and retained by the sparse algorithm. The dense reference $E_x^{\\text{ref}}$ is the value computed without any truncation.\n\nParameters that define the model and must be used uniformly for all tests:\n- Density-matrix decay length $\\xi = 1.5$.\n- Screening length $\\lambda = 1.0$.\n- Short-distance regularizer $r_0 = 0.5$.\n- Lattice spacing $a = 1$.\n\nAngle units do not apply. There are no physical units; all quantities are dimensionless. Report all outputs as floating-point numbers.\n\nTest suite:\nRun your program on the following six cases, each specified by $(n, R_p, R_c, \\tau)$:\n- Case $1$: $(5, 0.0, 2.0, 10^{-4})$.\n- Case $2$: $(5, 0.0, 3.0, 10^{-6})$.\n- Case $3$: $(5, 0.0, 1.0, 10^{-2})$.\n- Case $4$: $(5, 2.0, 2.0, 10^{-4})$.\n- Case $5$ (boundary condition): $(5, 2.0, 0.0, 0.0)$.\n- Case $6$ (nearly dense sparse evaluation): $(5, 0.0, 10.0, 0.0)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case in the above order, append the two numbers $[\\varepsilon, s]$ to the output list, so the final line contains $12$ floating-point numbers in the order $[\\varepsilon_1, s_1, \\varepsilon_2, s_2, \\ldots, \\varepsilon_6, s_6]$. Print each floating-point number with at least $6$ decimal places. No other text must be printed.",
            "solution": "The problem requires the design and implementation of an algorithm to evaluate a model exchange functional, comparing a dense, exact calculation with a sparse, linear-scaling approximation. The scientific context is the computation of the Hartree-Fock (HF) exchange energy in hybrid exchange-correlation functionals, a cornerstone of modern computational materials science and quantum chemistry. The validity and efficiency of linear-scaling methods are predicated on the principle of \"nearsightedness of electronic matter,\" which states that for systems with a non-zero electronic band gap, the one-particle density matrix elements $P_{ij}$ between two localized orbitals centered at positions $i$ and $j$ decay exponentially with the distance $r_{ij}$ between them. This physical principle is the foundation of the model and the algorithm.\n\nThe problem starts from the formal expression for the HF exchange energy in an orthonormal localized orbital basis $\\{\\phi_{\\mu}\\}$:\n$$\nE_x^{\\text{HF}} = -\\frac{1}{2}\\sum_{\\mu,\\nu,\\lambda,\\sigma} P_{\\mu\\lambda}\\,P_{\\nu\\sigma}\\,(\\mu\\nu|\\lambda\\sigma)\n$$\nwhere $P$ is the density matrix, $P_{\\mu\\lambda} = \\sum_{k}^{\\text{occ}} c_{\\mu k} c_{\\lambda k}^*$, and $(\\mu\\nu|\\lambda\\sigma)$ are the four-center two-electron repulsion integrals, $$(\\mu\\nu|\\lambda\\sigma) = \\iint \\phi_{\\mu}^*(\\mathbf{r}_1) \\phi_{\\nu}(\\mathbf{r}_1) \\frac{1}{|\\mathbf{r}_1 - \\mathbf{r}_2|} \\phi_{\\lambda}^*(\\mathbf{r}_2) \\phi_{\\sigma}(\\mathbf{r}_2) d\\mathbf{r}_1 d\\mathbf{r}_2.$$ The computational cost of evaluating this sum scales as $O(N^4)$ naively, which is prohibitive for large systems.\n\nTo create a tractable yet physically meaningful model, the problem introduces a simplified exchange functional that captures the essential locality. The four-center term is replaced with a two-center screened interaction, and the sum is simplified to run over atomic sites $i$ and $j$:\n$$\nE_x^{\\text{model}} = -\\frac{1}{2}\\sum_{i,j} \\left(P_{ij}\\right)^2\\,K(r_{ij})\n$$\nThe components of this model are defined to mimic physical reality. The density matrix element $P_{ij}$ between sites $i$ and $j$ separated by a Euclidean distance $r_{ij}$ is modeled with a Gaussian decay, consistent with the principle of nearsightedness:\n$$\nP_{ij} =\n\\begin{cases}\n1, & i=j\\\\\n\\exp\\!\\left(-\\left(\\frac{r_{ij}}{\\xi}\\right)^2\\right), & i\\neq j\n\\end{cases}\n$$\nHere, $\\xi=1.5$ is the characteristic decay length. The interaction kernel $K(r)$ represents a screened Coulomb interaction, which also decays with distance:\n$$\nK(r) = \\dfrac{\\exp\\!\\left(-\\left(\\dfrac{r}{\\lambda}\\right)^2\\right)}{\\sqrt{r^2 + r_0^2}}\n$$\nwhere $\\lambda=1.0$ is the screening length and $r_0=0.5$ is a regularizer to prevent divergence at $r=0$, yielding a finite self-exchange energy.\n\nThe structural model consists of points on a simple cubic lattice with spacing $a=1$. Porosity is introduced by removing all lattice points within a sphere of radius $R_p$ from the geometric center of the $n\\times n\\times n$ cube. The geometric center for a cube with integer coordinates from $0$ to $n-1$ is located at $(\\frac{n-1}{2}, \\frac{n-1}{2}, \\frac{n-1}{2})$.\n\nThe core of the task is to compare two computational approaches for $E_x^{\\text{model}}$:\n\n1.  **Dense Reference Calculation**: The reference energy, $E_x^{\\text{ref}}$, is computed by evaluating the full double summation over all $N^2$ ordered pairs of sites $(i,j)$ in the framework. This provides the exact value for the model functional but has a computational complexity of $O(N^2)$, which is not scalable to very large systems.\n\n2.  **Sparse Linear-Scaling Algorithm**: The approximate energy, $E_x^{\\text{sparse}}$, is computed by systematically truncating the sum. The nearsightedness principle implies that pairs of sites $(i,j)$ that are far apart contribute negligibly to the total energy because both $P_{ij}$ and $K(r_{ij})$ decay rapidly with $r_{ij}$. The sparse algorithm leverages this by defining two cutoffs: a spatial distance cutoff $R_c$ and a density-matrix element threshold $\\tau$. A pair $(i,j)$ contributes to the sum only if it satisfies **both** $r_{ij} \\le R_c$ and $|P_{ij}| \\ge \\tau$.\n    To implement this efficiently and achieve linear $O(N)$ scaling, a neighbor-list algorithm based on a uniform cell grid is employed. The simulation domain is partitioned into cubic cells of side length $R_c$. Each site is assigned to a cell. To find neighbors of a site $i$, one only needs to search for sites $j$ within the cell containing $i$ and its $26$ neighboring cells. This drastically reduces the number of pairs to check from $O(N)$ to $O(1)$ for each site, leading to an overall $O(N)$ complexity for building the list of kept pairs.\n\nThe performance of the sparse algorithm is quantified by two metrics:\n-   **Relative Error ($\\varepsilon$)**: Measures the accuracy of the approximation.\n    $$\n    \\varepsilon = \\dfrac{\\lvert E_x^{\\text{sparse}} - E_x^{\\text{ref}} \\rvert}{\\lvert E_x^{\\text{ref}} \\rvert}\n    $$\n-   **Retained-Pair Fraction ($s$)**: Measures the computational savings, or sparsity.\n    $$\n    s = \\dfrac{N_{\\text{kept}}}{N^2}\n    $$\n    where $N$ is the number of sites and $N_{\\text{kept}}$ is the number of ordered pairs that survived the truncation criteria.\n\nThe implemented program follows these principles. It first generates the atomic coordinates for a given case. Then, it computes $E_x^{\\text{ref}}$ via a nested loop over all pairs. Subsequently, it implements the cell-list algorithm to compute $E_x^{\\text{sparse}}$ and $N_{\\text{kept}}$. For the special case where the distance cutoff $R_c=0$, only on-site terms ($i=j$) are considered, which is handled explicitly. Finally, it calculates $\\varepsilon$ and $s$ and formats the results for all test cases as specified. This systematic comparison demonstrates the fundamental trade-off between computational cost and accuracy inherent in linear-scaling methods in computational science.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    # Uniform parameters from the problem statement\n    XI = 1.5\n    LAMBDA = 1.0\n    R0 = 0.5\n    A = 1.0\n\n    def P_ij(r, xi):\n        \"\"\"\n        Calculates the model density matrix element P_ij.\n        \"\"\"\n        if np.isclose(r, 0.0):\n            return 1.0\n        return np.exp(-(r / xi)**2)\n\n    def K_r(r, lambda_, r0):\n        \"\"\"\n        Calculates the model interaction kernel K(r).\n        \"\"\"\n        return np.exp(-(r / lambda_)**2) / np.sqrt(r**2 + r0**2)\n\n    def generate_framework(n, Rp, a):\n        \"\"\"\n        Generates the 3D atomic framework on a simple cubic lattice with a spherical pore.\n        \"\"\"\n        center = np.array([(n - 1) / 2.0, (n - 1) / 2.0, (n - 1) / 2.0]) * a\n        \n        coords = np.array([\n            [i * a, j * a, k * a] \n            for i in range(n) for j in range(n) for k in range(n)\n        ])\n        \n        if Rp > 0:\n            distances_to_center = np.linalg.norm(coords - center, axis=1)\n            sites = coords[distances_to_center >= Rp]\n        else:\n            sites = coords\n            \n        return sites\n\n    def calculate_dense_energy(sites, xi, lambda_, r0):\n        \"\"\"\n        Calculates the dense reference energy E_ref by summing over all pairs.\n        \"\"\"\n        N = sites.shape[0]\n        if N == 0:\n            return 0.0\n        \n        total_energy_term = 0.0\n        for i in range(N):\n            for j in range(N):\n                r_ij = np.linalg.norm(sites[i] - sites[j])\n                p_val = P_ij(r_ij, xi)\n                k_val = K_r(r_ij, lambda_, r0)\n                total_energy_term += p_val**2 * k_val\n                \n        return -0.5 * total_energy_term\n\n    def calculate_sparse_energy(sites, Rc, tau, xi, lambda_, r0):\n        \"\"\"\n        Calculates the sparse energy E_sparse and counts kept pairs using a cell-list algorithm.\n        \"\"\"\n        N = sites.shape[0]\n        if N == 0:\n            return 0.0, 0\n        \n        sparse_energy_term = 0.0\n        N_kept = 0\n\n        # Handle the special case where Rc = 0; only i=j pairs are considered.\n        if np.isclose(Rc, 0.0):\n            for i in range(N):\n                p_val_ii = 1.0  # P_ii is always 1\n                if p_val_ii >= tau:\n                    k_val_0 = K_r(0.0, lambda_, r0)\n                    sparse_energy_term += p_val_ii**2 * k_val_0\n                    N_kept += 1\n            return -0.5 * sparse_energy_term, N_kept\n        \n        # General case with cell list for Rc > 0\n        min_coord = np.min(sites, axis=0)\n        grid = {}\n        for i, site in enumerate(sites):\n            cell_coord = tuple(np.floor((site - min_coord) / Rc).astype(int))\n            if cell_coord not in grid:\n                grid[cell_coord] = []\n            grid[cell_coord].append(i)\n\n        for i in range(N):\n            site_i = sites[i]\n            cell_i_coord_tuple = tuple(np.floor((site_i - min_coord) / Rc).astype(int))\n            \n            # Iterate over the 27 neighboring cells (including the cell itself)\n            for d in itertools.product([-1, 0, 1], repeat=3):\n                neighbor_cell_coord = (\n                    cell_i_coord_tuple[0] + d[0],\n                    cell_i_coord_tuple[1] + d[1],\n                    cell_i_coord_tuple[2] + d[2]\n                )\n                \n                if neighbor_cell_coord in grid:\n                    for j in grid[neighbor_cell_coord]:\n                        site_j = sites[j]\n                        r_ij = np.linalg.norm(site_i - site_j)\n                        \n                        # First cutoff: distance\n                        if r_ij > Rc:\n                            continue\n                        \n                        p_val = P_ij(r_ij, xi)\n                        \n                        # Second cutoff: density matrix value\n                        if abs(p_val) < tau:\n                            continue\n                            \n                        # Pair is kept\n                        N_kept += 1\n                        k_val = K_r(r_ij, lambda_, r0)\n                        sparse_energy_term += p_val**2 * k_val\n\n        return -0.5 * sparse_energy_term, N_kept\n\n    # Test cases from the problem statement.\n    test_cases = [\n        # (n, Rp, Rc, tau)\n        (5, 0.0, 2.0, 1e-4),\n        (5, 0.0, 3.0, 1e-6),\n        (5, 0.0, 1.0, 1e-2),\n        (5, 2.0, 2.0, 1e-4),\n        (5, 2.0, 0.0, 0.0),\n        (5, 0.0, 10.0, 0.0),\n    ]\n\n    results = []\n    for n, Rp, Rc, tau in test_cases:\n        sites = generate_framework(n, Rp, A)\n        N = sites.shape[0]\n        \n        if N == 0:\n            # If no sites, energies are 0. Error is 0, sparsity is ill-defined.\n            # We set s=0 as no pairs are kept from a set of 0 total pairs.\n            eps = 0.0\n            s = 0.0\n        else:\n            E_ref = calculate_dense_energy(sites, XI, LAMBDA, R0)\n            E_sparse, N_kept = calculate_sparse_energy(sites, Rc, tau, XI, LAMBDA, R0)\n            \n            if np.isclose(E_ref, 0.0):\n                # This should only happen if N=0, but as a safeguard:\n                # If E_ref is 0 and E_sparse is also 0, error is 0. Otherwise, it's infinite.\n                eps = 0.0 if np.isclose(E_sparse, 0.0) else np.inf\n            else:\n                eps = np.abs((E_sparse - E_ref) / E_ref)\n                \n            s = N_kept / (N**2)\n        \n        results.extend([eps, s])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.6e}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}