{
    "hands_on_practices": [
        {
            "introduction": "准确计算分子或材料片段之间的相互作用能，是计算材料科学的核心任务之一。然而，在实际计算中，有限基组的使用会引入误差。本练习将引导你剖析相互作用能的总误差，并将其分解为两个物理来源截然不同的部分：基组不完备性误差（BSIE）和基组重叠误差（BSSE）。通过亲手推导和计算，你将深刻理解这两种误差的本质，为后续进行高精度计算和误差修正打下坚实的基础。",
            "id": "3434474",
            "problem": "您的任务是，在计算材料科学的框架内，利用基于波函数的电子结构理论的基本原理，形式化并实现将相互作用能中的总基组误差分解为基组不完备性误差（BSIE）和基组重叠误差（BSSE）。您的推导必须从一个有效的基础出发：Born-Oppenheimer 近似下的非相对论电子薛定谔方程、厄米算符的 Rayleigh-Ritz 变分原理，以及有限基组中相互作用能的定义。目标是推导出这种分解是什么、为什么成立，以及如何通过对仅含片段和超分子的基组进行有针对性的计算来分离出每个分量，然后用代码实现得到的公式。所有能量均以 Hartree 表示，所有结果也必须以 Hartree 输出。\n\n使用以下基本事实和定义：\n- 电子薛定谔方程给出的基态能量 $E$，在实践中通过投影到有限基组 $\\mathcal{B}$ 上来近似，得到能量 $E^\\mathcal{B}$。\n- 在适当条件下，Rayleigh-Ritz 变分原理保证 $E^\\mathcal{B} \\geq E^\\infty$，其中 $E^\\infty$ 表示完备基组极限。\n- 对于由片段 $A$ 和 $B$ 形成的二聚体，在有限基组中的相互作用能定义为\n$$\nE_{\\mathrm{int}}^\\mathcal{B} = E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A} - E_B^{\\mathcal{B}_B},\n$$\n其中 $E_{AB}^{\\mathcal{B}_{AB}}$ 是在超分子基组 $\\mathcal{B}_{AB}$ 中的二聚体能量，而 $E_X^{\\mathcal{B}_X}$ 是在各自仅含片段的基组 $\\mathcal{B}_X$ 中的单体能量（$X \\in \\{A,B\\}$）。\n- 基组重叠误差 (BSSE) 的产生是因为在超分子基组中，$A$ 和 $B$ 可以通过“借用”彼此的基函数来变分地降低自身能量。为了量化这一点，计算 $E_A^{\\mathcal{B}_{AB}}$ 和 $E_B^{\\mathcal{B}_{AB}}$ 作为在超分子基组中（存在另一片段的鬼函数，但没有其电子或原子核）的单体能量，然后构建经 counterpoise 方法校正的相互作用能\n$$\nE_{\\mathrm{int}}^{\\mathrm{CP}} = E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_{AB}} - E_B^{\\mathcal{B}_{AB}}.\n$$\n\n任务：\n- 推导总相互作用能误差的形式化分解\n$$\n\\Delta E_{\\mathrm{int}}^{\\mathrm{tot}} = E_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^\\infty\n$$\n使其成为两个分别对应于基组重叠误差 (BSSE) 和基组不完备性误差 (BSIE) 的可加分量。推导必须从上述定义和基本原理出发，并且不得在没有论证的情况下引入任何快捷公式。\n- 基于该分解，设计并实现一个算法，该算法在给定对仅含片段和超分子基组的有针对性计算结果后，能够明确地分离出 BSSE 和 BSIE 的数值：\n  - 从 $E_{AB}^{\\mathcal{B}_{AB}}, E_A^{\\mathcal{B}_A}, E_B^{\\mathcal{B}_B}$ 计算 $E_{\\mathrm{int}}^\\mathcal{B}$。\n  - 从 $E_{AB}^{\\mathcal{B}_{AB}}, E_A^{\\mathcal{B}_{AB}}, E_B^{\\mathcal{B}_{AB}}$ 计算 $E_{\\mathrm{int}}^{\\mathrm{CP}}$。\n  - 使用一个给定的参考值 $E_{\\mathrm{int}}^\\infty$（来自一个近乎完备的基组），无歧义地数值分离 BSIE 和 BSSE。\n\n测试套件的输入数据：\n对于每个测试用例 $i$，您将获得六个以 Hartree 为单位的实数：\n- $E_{AB}^{\\mathcal{B}_{AB}}$,\n- $E_A^{\\mathcal{B}_A}$,\n- $E_B^{\\mathcal{B}_B}$,\n- $E_A^{\\mathcal{B}_{AB}}$,\n- $E_B^{\\mathcal{B}_{AB}}$,\n- $E_{\\mathrm{int}}^\\infty$.\n\n使用以下参数集（所有值单位均为 Hartree）：\n- 测试用例 1（中等基组重叠误差）：\n  - $E_{AB}^{\\mathcal{B}_{AB}} = -152.345678$\n  - $E_A^{\\mathcal{B}_A} = -76.123456$\n  - $E_B^{\\mathcal{B}_B} = -76.200000$\n  - $E_A^{\\mathcal{B}_{AB}} = -76.130000$\n  - $E_B^{\\mathcal{B}_{AB}} = -76.205000$\n  - $E_{\\mathrm{int}}^\\infty = -0.012000$\n- 测试用例 2（近乎完备的基组，基组重叠误差可忽略不计）：\n  - $E_{AB}^{\\mathcal{B}_{AB}} = -20.000010$\n  - $E_A^{\\mathcal{B}_A} = -10.000000$\n  - $E_B^{\\mathcal{B}_B} = -10.000000$\n  - $E_A^{\\mathcal{B}_{AB}} = -10.000001$\n  - $E_B^{\\mathcal{B}_{AB}} = -10.000001$\n  - $E_{\\mathrm{int}}^\\infty = -0.000008$\n- 测试用例 3（使用最小基组时严重的基组重叠误差）：\n  - $E_{AB}^{\\mathcal{B}_{AB}} = -30.080000$\n  - $E_A^{\\mathcal{B}_A} = -15.000000$\n  - $E_B^{\\mathcal{B}_B} = -15.000000$\n  - $E_A^{\\mathcal{B}_{AB}} = -15.050000$\n  - $E_B^{\\mathcal{B}_{AB}} = -15.020000$\n  - $E_{\\mathrm{int}}^\\infty = -0.015000$\n- 测试用例 4（非对称基组重叠误差，仅存在于片段 A）：\n  - $E_{AB}^{\\mathcal{B}_{AB}} = -21.120000$\n  - $E_A^{\\mathcal{B}_A} = -12.345600$\n  - $E_B^{\\mathcal{B}_B} = -8.765400$\n  - $E_A^{\\mathcal{B}_{AB}} = -12.349000$\n  - $E_B^{\\mathcal{B}_{AB}} = -8.765400$\n  - $E_{\\mathrm{int}}^\\infty = -0.006000$\n\n每个测试用例的所需输出（所有单位均为 Hartree）：\n- 基组重叠误差对相互作用能误差的贡献，定义为在超分子基组中相对于仅含片段基组的单体能量降低量。\n- 经 counterpoise 校正的相互作用能相对于参考完备基组相互作用能的基组不完备性误差贡献。\n- 相对于完备基组参考值的总相互作用能误差。\n- 一个布尔值，如果分解在数值容差内成立，则为 true，否则为 false。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个列表，顺序为 [$\\mathrm{BSSE}$, $\\mathrm{BSIE}$, $\\Delta E_{\\mathrm{int}}^{\\mathrm{tot}}$, 一致性布尔值]。示例形状：$[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$。所有量必须以 Hartree 报告。不涉及角度。不得使用百分比。",
            "solution": "该问题要求对电子结构计算中总相互作用能误差分解为基组重叠误差（BSSE）和基组不完备性误差（BSIE）进行形式化推导和计算实现。推导必须建立在所提供的基本原理和定义之上。\n\n让我们首先建立理论基础。分子体系的基态能量是电子哈密顿算符 $\\hat{H}$ 的最低本征值，由不含时薛定谔方程给出。在实践中，我们采用 Rayleigh-Ritz 变分原理，该原理指出，对于适当希尔伯特空间中的任意试探波函数 $\\Psi$，能量的期望值 $\\langle \\Psi | \\hat{H} | \\Psi \\rangle / \\langle \\Psi | \\Psi \\rangle$ 是真实基态能量 $E^\\infty$ 的一个上界。当我们将波函数表示为来自有限基组 $\\mathcal{B}$ 的函数的线性组合时，该原理保证计算出的能量 $E^\\mathcal{B}$ 是完备基组极限下精确能量 $E^\\infty$ 的一个上界。即 $E^\\mathcal{B} \\ge E^\\infty$。\n\n对于一个由两个相互作用片段 $A$ 和 $B$ 组成的体系，在完备基组（CBS）极限下的相互作用能 $E_{\\mathrm{int}}^\\infty$ 是真实的物理相互作用能，定义为：\n$$\nE_{\\mathrm{int}}^\\infty = E_{AB}^\\infty - E_A^\\infty - E_B^\\infty\n$$\n其中 $E_{AB}^\\infty$、$E_A^\\infty$ 和 $E_B^\\infty$ 分别是二聚体 $AB$ 和单体 $A$、$B$ 在 CBS 极限下的能量。\n\n在用有限基组 $\\mathcal{B}$ 进行的实际计算中，未校正或“原始”的相互作用能定义为：\n$$\nE_{\\mathrm{int}}^\\mathcal{B} = E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A} - E_B^{\\mathcal{B}_B}\n$$\n这里，$E_{AB}^{\\mathcal{B}_{AB}}$ 是在超分子基组 $\\mathcal{B}_{AB} = \\mathcal{B}_A \\cup \\mathcal{B}_B$ 中计算的二聚体能量。单体能量 $E_A^{\\mathcal{B}_A}$ 和 $E_B^{\\mathcal{B}_B}$ 仅使用它们各自以片段为中心的基组 $\\mathcal{B}_A$ 和 $\\mathcal{B}_B$ 计算。\n\n用基组 $\\mathcal{B}$ 计算的相互作用能的总误差是其与 CBS 极限的偏差：\n$$\n\\Delta E_{\\mathrm{int}}^{\\mathrm{tot}} = E_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^\\infty\n$$\n\n我们的目标是将此总误差分解为两个具有物理意义的可加分量。关键的思路是引入经 counterpoise 方法校正的相互作用能 $E_{\\mathrm{int}}^{\\mathrm{CP}}$，该能量旨在减轻一种特定类型的误差。Boys 和 Bernardi (1970) 提出的 counterpoise (CP) 校正方法建议，如果单体能量也在完整的超分子基组 $\\mathcal{B}_{AB}$ 中计算，可以获得更平衡的描述。这是通过在每个单体的计算中，引入另一个单体的基函数（称为“鬼”函数）但去除其原子核和电子来完成的。这些能量记为 $E_A^{\\mathcal{B}_{AB}}$ 和 $E_B^{\\mathcal{B}_{AB}}$。经 CP 校正的相互作用能则为：\n$$\nE_{\\mathrm{int}}^{\\mathrm{CP}} = E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_{AB}} - E_B^{\\mathcal{B}_{AB}}\n$$\n\n定义了 $E_{\\mathrm{int}}^{\\mathrm{CP}}$ 后，我们可以通过加上和减去这个项来分解总误差：\n$$\n\\Delta E_{\\mathrm{int}}^{\\mathrm{tot}} = (E_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^{\\mathrm{CP}}) + (E_{\\mathrm{int}}^{\\mathrm{CP}} - E_{\\mathrm{int}}^\\infty)\n$$\n这纯粹是一个将总误差划分为两个分量的代数操作。让我们分析每个分量。\n\n第一个分量 $(E_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^{\\mathrm{CP}})$ 表示未校正和经 counterpoise 校正的相互作用能之差。让我们用它们的定义展开此项：\n$$\nE_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^{\\mathrm{CP}} = (E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A} - E_B^{\\mathcal{B}_B}) - (E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_{AB}} - E_B^{\\mathcal{B}_{AB}})\n$$\n$$\nE_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^{\\mathrm{CP}} = (E_A^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A}) + (E_B^{\\mathcal{B}_{AB}} - E_B^{\\mathcal{B}_B})\n$$\n项 $(E_A^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A})$ 是当单体 $A$ 的描述因片段 $B$ 的基函数的可用性而得到改善时，其能量的降低量。根据变分原理，由于 $\\mathcal{B}_A \\subseteq \\mathcal{B}_{AB}$，能量 $E_A^{\\mathcal{B}_{AB}}$ 必须小于或等于 $E_A^{\\mathcal{B}_A}$。因此，这个差值为负或零。这种伪能量降低是在 $E_{\\mathrm{int}}^\\mathcal{B}$ 定义中使用的不平衡基组所导致的人为效应；单体 $A$ “借用” $B$ 的函数以更好地描述其自身的电子密度。这种人为的稳定性就是基组重叠误差（BSSE）。因此，BSSE 对总相互作用能误差的贡献正是这个量。我们将此贡献定义为：\n$$\n\\delta_{\\mathrm{BSSE}} = (E_A^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A}) + (E_B^{\\mathcal{B}_{AB}} - E_B^{\\mathcal{B}_B})\n$$\n\n第二个分量 $(E_{\\mathrm{int}}^{\\mathrm{CP}} - E_{\\mathrm{int}}^\\infty)$ 代表剩余的误差。量 $E_{\\mathrm{int}}^{\\mathrm{CP}}$ 被认为是比 $E_{\\mathrm{int}}^\\mathcal{B}$ 更好的 $E_{\\mathrm{int}}^\\infty$ 的近似，因为 BSSE 已被移除。即使在校正了重叠人为效应之后，$E_{\\mathrm{int}}^{\\mathrm{CP}}$ 中仍然存在的误差是由于整个超分子基组 $\\mathcal{B}_{AB}$ 在描述相互作用体系的全部物理过程方面固有的不足或不完备性。因此，这就是基组不完备性误差（BSIE）。我们将其定义为：\n$$\n\\delta_{\\mathrm{BSIE}} = E_{\\mathrm{int}}^{\\mathrm{CP}} - E_{\\mathrm{int}}^\\infty\n$$\n\n因此，总误差的形式化分解为：\n$$\n\\Delta E_{\\mathrm{int}}^{\\mathrm{tot}} = \\delta_{\\mathrm{BSSE}} + \\delta_{\\mathrm{BSIE}}\n$$\n这种分解在构造上是算术精确的，并将误差分离为一个源于不平衡基组描述的分量（BSSE）和一个源于有限基组自身内在局限性的分量（BSIE）。\n\n为了基于此推导实现一个算法，我们将从六个输入能量（$E_{AB}^{\\mathcal{B}_{AB}}$、$E_A^{\\mathcal{B}_A}$、$E_B^{\\mathcal{B}_B}$、$E_A^{\\mathcal{B}_{AB}}$、$E_B^{\\mathcal{B}_{AB}}$、$E_{\\mathrm{int}}^\\infty$）计算以下量：\n\n1.  计算未校正的相互作用能：$E_{\\mathrm{int}}^\\mathcal{B} = E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A} - E_B^{\\mathcal{B}_B}$。\n2.  计算经 counterpoise 校正的相互作用能：$E_{\\mathrm{int}}^{\\mathrm{CP}} = E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_{AB}} - E_B^{\\mathcal{B}_{AB}}$。\n3.  计算总误差：$\\Delta E_{\\mathrm{int}}^{\\mathrm{tot}} = E_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^\\infty$。\n4.  计算对误差的 BSSE 贡献：$\\delta_{\\mathrm{BSSE}} = E_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^{\\mathrm{CP}}$。这等价于 $(E_A^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A}) + (E_B^{\\mathcal{B}_{AB}} - E_B^{\\mathcal{B}_B})$。根据要求，这个量将被报告为 BSSE。\n5.  计算 BSIE 贡献：$\\delta_{\\mathrm{BSIE}} = E_{\\mathrm{int}}^{\\mathrm{CP}} - E_{\\mathrm{int}}^\\infty$。\n6.  验证分解：检查 $\\Delta E_{\\mathrm{int}}^{\\mathrm{tot}} = \\delta_{\\mathrm{BSSE}} + \\delta_{\\mathrm{BSIE}}$ 是否在标准浮点容差内成立。这为计算提供了一致性检查。\n\n此过程将应用于每个测试用例，以得出所需的数值结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of decomposing the total basis error in an interaction\n    energy into Basis Set Incompleteness Error (BSIE) and Basis Set\n    Superposition Error (BSSE).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains:\n    # (E_AB_dimer, E_A_mono, E_B_mono, E_A_ghost, E_B_ghost, E_int_inf)\n    # All values are in Hartree.\n    test_cases = [\n        # Test case 1: moderate Basis Set Superposition Error\n        (\n            -152.345678,  # E_AB_dimer\n            -76.123456,   # E_A_mono\n            -76.200000,   # E_B_mono\n            -76.130000,   # E_A_ghost\n            -76.205000,   # E_B_ghost\n            -0.012000     # E_int_inf\n        ),\n        # Test case 2: near-complete basis, negligible Basis Set Superposition Error\n        (\n            -20.000010,   # E_AB_dimer\n            -10.000000,   # E_A_mono\n            -10.000000,   # E_B_mono\n            -10.000001,   # E_A_ghost\n            -10.000001,   # E_B_ghost\n            -0.000008     # E_int_inf\n        ),\n        # Test case 3: severe Basis Set Superposition Error with minimal basis\n        (\n            -30.080000,   # E_AB_dimer\n            -15.000000,   # E_A_mono\n            -15.000000,   # E_B_mono\n            -15.050000,   # E_A_ghost\n            -15.020000,   # E_B_ghost\n            -0.015000     # E_int_inf\n        ),\n        # Test case 4: asymmetric Basis Set Superposition Error, fragment A only\n        (\n            -21.120000,   # E_AB_dimer\n            -12.345600,   # E_A_mono\n            -8.765400,    # E_B_mono\n            -12.349000,   # E_A_ghost\n            -8.765400,    # E_B_ghost\n            -0.006000     # E_int_inf\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        E_AB_dimer, E_A_mono, E_B_mono, E_A_ghost, E_B_ghost, E_int_inf = case\n\n        # 1. Calculate the uncorrected interaction energy in the finite basis (E_int^B)\n        # E_int^B = E_AB^(B_AB) - E_A^(B_A) - E_B^(B_B)\n        e_int_b = E_AB_dimer - E_A_mono - E_B_mono\n\n        # 2. Calculate the counterpoise-corrected interaction energy (E_int^CP)\n        # E_int^CP = E_AB^(B_AB) - E_A^(B_AB) - E_B^(B_AB)\n        e_int_cp = E_AB_dimer - E_A_ghost - E_B_ghost\n\n        # 3. Calculate the total interaction energy error (Delta E_int^tot)\n        # Delta E_int^tot = E_int^B - E_int^inf\n        total_error = e_int_b - E_int_inf\n\n        # 4. Calculate the Basis Set Superposition Error (BSSE) contribution to the total error.\n        # This is the artificial stabilization from monomer basis functions borrowing.\n        # delta_BSSE = E_int^B - E_int^CP = (E_A^(B_AB) - E_A^(B_A)) + (E_B^(B_AB) - E_B^(B_B))\n        # Note: This contribution is negative, representing an artificial over-binding.\n        bsse_contribution = (E_A_ghost - E_A_mono) + (E_B_ghost - E_B_mono)\n\n        # 5. Calculate the Basis Set Incompleteness Error (BSIE) contribution.\n        # This is the remaining error in the CP-corrected energy.\n        # delta_BSIE = E_int^CP - E_int^inf\n        bsie_contribution = e_int_cp - E_int_inf\n\n        # 6. Perform a consistency check to verify the decomposition.\n        # The decomposition is Delta E_int^tot = delta_BSSE + delta_BSIE.\n        # We use np.isclose for robust floating-point comparison.\n        is_consistent = np.isclose(total_error, bsse_contribution + bsie_contribution)\n\n        # Append the results for the current test case.\n        # Order: [BSSE, BSIE, TotalError, ConsistencyBoolean]\n        results.append([bsse_contribution, bsie_contribution, total_error, is_consistent])\n\n    # Convert the boolean to lowercase string 'true'/'false' for the output.\n    # Then join all results into the final formatted string.\n    formatted_results = []\n    for res in results:\n        # Convert NumPy boolean to Python boolean for json-like string representation\n        bool_val = bool(res[3])\n        formatted_res = f\"[{res[0]},{res[1]},{res[2]},{str(bool_val).lower()}]\"\n        formatted_results.append(formatted_res)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了基组误差的两个主要组成部分之后，下一步自然是学习如何消除或减小它们的影响。本练习将带你探索两种在计算化学和材料科学中广泛应用的强大策略：反向校正（Counterpoise correction, CP）和完备基组极限（Complete Basis Set, CBS）外推。通过对比这两种方法的计算结果，你将学会评估它们在不同情况下的表现，并掌握在有限的计算资源下获得可靠吸附能的关键技能。",
            "id": "3434543",
            "problem": "您需要形式化并实现平衡校正吸附能与完全基组极限之间的比较，该比较应在数学上精确且在算法上可测试。从以下适用于计算材料科学的基本基础开始：玻恩-奥本海默电子能量相对于波函数是变分的，而基组的截断会引入系统性的基组不完备性误差。对于一个整数尺寸参数 $M$ 递增的高斯原子中心轨道基组的基数序列，总能量 $E(M)$ 的渐近收敛行为可以通过一个经过充分检验的经验公式 $E(M)=E_{\\infty}+A M^{-p}$ 来建模，其中 $E_{\\infty}$ 是完全基组极限，$A$ 是一个依赖于体系的前因子，$p>0$ 是一个表征收敛速率的指数。此行为与变分原理一致，因为对于束缚态有 $E(M)\\ge E_{\\infty}$。\n\n需使用的定义：\n- 在给定基组基数 $M$ 下的吸附能定义为 $E_{\\text{ads}}(M)=E_{\\text{AB}}(M)-E_{\\text{A}}(M)-E_{\\text{B}}(M)$，其中 $E_{\\text{AB}}$ 是吸附质-表面体系的总能量，$E_{\\text{A}}$ 是表面片段的能量，$E_{\\text{B}}$ 是吸附质片段的能量。\n- Boys-Bernardi 平衡校正 (counterpoise, CP) 在存在另一片段基函数（鬼函数）的情况下计算单体片段的能量，以减轻基组叠加误差。在固定的 $M$ 下，平衡校正的吸附能为 $E_{\\text{ads}}^{\\text{CP}}(M)=E_{\\text{AB}}(M)-E_{\\text{A}}^{\\text{ghost}}(M)-E_{\\text{B}}^{\\text{ghost}}(M)$，其中 $E_{\\text{A}}^{\\text{ghost}}(M)$ 和 $E_{\\text{B}}^{\\text{ghost}}(M)$ 是在二聚体基组中计算的单体能量（不包含另一片段的电子）。\n- 完全基组极限 (CBS) 吸附能为 $E_{\\text{ads}}^{\\text{CBS}}=E_{\\text{AB},\\infty}-E_{\\text{A},\\infty}-E_{\\text{B},\\infty}$，其中 $E_{X,\\infty}$ 表示体系 $X\\in\\{\\text{AB},\\text{A},\\text{B}\\}$ 的 CBS 极限。\n\n您的任务：\n1. 给定两个基组基数 $M_1$ 和 $M_2$ 以及它们对应的 $\\text{AB}$、$\\text{A}$ 和 $\\text{B}$ 各自的总能量 $E(M_1)$ 和 $E(M_2)$，请仅使用经验渐近公式 $E(M)=E_{\\infty}+A M^{-p}$、变分性质以及对方程组的代数操作，从第一性原理推导出如何消去未知的前因子 $A$ 并推断出 CBS 极限 $E_{\\infty}$。您不能依赖任何快捷公式；相反，必须表达出分离 $E_{\\infty}$ 所需的逻辑步骤。\n2. 实现一个程序，对于每个测试用例，使用 $M_1$ 和 $M_2$ 处的两个能量点和一个给定的指数 $p$ 来外推 $E_{\\text{AB},\\infty}$、$E_{\\text{A},\\infty}$ 和 $E_{\\text{B},\\infty}$，然后计算 $E_{\\text{ads}}^{\\text{CBS}}$。\n3. 使用在 $M_2$ 处提供的鬼基组单体能量，计算 $E_{\\text{ads}}^{\\text{CP}}(M_2)$ 并评估差值 $\\Delta E_{\\text{ads}}=E_{\\text{ads}}^{\\text{CP}}(M_2)-E_{\\text{ads}}^{\\text{CBS}}$。将 $\\Delta E_{\\text{ads}}$ 的符号解释为一个区间图：如果 $\\Delta E_{\\text{ads}}>0$，则平衡校正过度校正（对于通常的放热吸附，校正后的吸附能比 CBS 极限的负值更小），如果 $\\Delta E_{\\text{ads}} < 0$，则平衡校正校正不足（校正后的吸附能比 CBS 极限的负值更大），如果 $\\Delta E_{\\text{ads}}=0$，则校正是平衡的。\n4. 所有能量都必须以电子伏特 (eV) 处理和报告。您的程序必须生成单行输出，其中包含测试套件的 $\\Delta E_{\\text{ads}}$ 值的逗号分隔列表，四舍五入到六位小数，并用方括号括起来，例如 $[x_1,x_2,x_3,x_4]$。\n\n测试套件（每个用例提供 $p$、$M_1$、$M_2$，在 $M_1$ 和 $M_2$ 处用于 $\\text{AB}$、$\\text{A}$、$\\text{B}$ 的两点能量，以及在 $M_2$ 处的鬼基组单体能量；所有能量单位均为 eV）：\n\n- 用例 1（典型收敛，轻度过度校正）：\n  - $p=4$, $M_1=3$, $M_2=4$,\n  - $E_{\\text{AB}}(M_1)=-21.117037037037$, $E_{\\text{AB}}(M_2)=-21.1190625$,\n  - $E_{\\text{A}}(M_1)=-19.796296296296$, $E_{\\text{A}}(M_2)=-19.798828125$,\n  - $E_{\\text{B}}(M_1)=-1.249259259259$, $E_{\\text{B}}(M_2)=-1.249765625$,\n  - $E_{\\text{A}}^{\\text{ghost}}(M_2)=-19.799628125$, $E_{\\text{B}}^{\\text{ghost}}(M_2)=-1.249965625$.\n\n- 用例 2（典型收敛，轻微校正不足）：\n  - $p=4$, $M_1=3$, $M_2=4$,\n  - $E_{\\text{AB}}(M_1)=-15.198148148148$, $E_{\\text{AB}}(M_2)=-15.1994140625$,\n  - $E_{\\text{A}}(M_1)=-13.997777777778$, $E_{\\text{A}}(M_2)=-13.999296875$,\n  - $E_{\\text{B}}(M_1)=-1.11962962963$, $E_{\\text{B}}(M_2)=-1.1198828125$,\n  - $E_{\\text{A}}^{\\text{ghost}}(M_2)=-13.999396875$, $E_{\\text{B}}^{\\text{ghost}}(M_2)=-1.1199028125$.\n\n- 用例 3（边界区间，接近平衡的校正）：\n  - $p=5$, $M_1=3$, $M_2=5$,\n  - $E_{\\text{AB}}(M_1)=-7.319670781893$, $E_{\\text{AB}}(M_2)=-7.3199744$,\n  - $E_{\\text{A}}(M_1)=-6.19975308642$, $E_{\\text{A}}(M_2)=-6.1999808$,\n  - $E_{\\text{B}}(M_1)=-1.09991736227$, $E_{\\text{B}}(M_2)=-1.0999936$,\n  - $E_{\\text{A}}^{\\text{ghost}}(M_2)=-6.1999958$, $E_{\\text{B}}^{\\text{ghost}}(M_2)=-1.0999976$.\n\n- 用例 4（边缘用例，二聚体的表观收敛速度快于单体，导致校正不足）：\n  - $p=3$, $M_1=2$, $M_2=3$,\n  - $E_{\\text{AB}}(M_1)=-34.95$, $E_{\\text{AB}}(M_2)=-34.9851851852$,\n  - $E_{\\text{A}}(M_1)=-33.425$, $E_{\\text{A}}(M_2)=-33.4777777778$,\n  - $E_{\\text{B}}(M_1)=-1.3625$, $E_{\\text{B}}(M_2)=-1.3888888889$,\n  - $E_{\\text{A}}^{\\text{ghost}}(M_2)=-33.4817778$, $E_{\\text{B}}^{\\text{ghost}}(M_2)=-1.3894889$.\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，列表中的每个 $\\Delta E_{\\text{ads}}$ 值（单位为 eV）都四舍五入到六位小数，例如 $[x_1,x_2,x_3,x_4]$。",
            "solution": "该问题是有效的，因为它科学上基于计算材料科学的原理，给出了所有必要的数据和定义，问题表述清晰，并且其构想是客观的。它提出了一个标准且相关的任务，涉及基组收敛、完全基组极限 (CBS) 外推以及基组叠加误差 (BSSE) 的分析。因此，我们可以着手解决。\n\n该问题的核心是分析电子能量随基组大小的收敛性。对于一个体系，使用基数为 $M$ 的基组计算得到的总能量 $E(M)$ 可通过以下经验渐近公式建模：\n$$E(M) = E_{\\infty} + A M^{-p}$$\n在此方程中，$E_{\\infty}$ 代表完全基组极限 (CBS) 能量，即使用无限大基组所能获得的理论能量。$A$ 是一个与体系相关的特定前因子，$p$ 是一个表征收敛速率的指数。量子力学的变分原理是该模型的基础，它确保对于基态，计算出的能量始终是真实能量的一个上界，即 $E(M) \\ge E_{\\infty}$。\n\n**1. 完全基组极限 (CBS) 外推公式的推导**\n\n我们的任务是，在给定一个已知指数 $p$ 的情况下，使用分别以基数 $M_1$ 和 $M_2$ 的基组进行两次能量计算得到的结果 $E(M_1)$ 和 $E(M_2)$，推导出 $E_{\\infty}$ 的表达式。\n\n这两次计算提供了一个包含两个未知数 $E_{\\infty}$ 和 $A$ 的二元方程组：\n$$E(M_1) = E_{\\infty} + A M_1^{-p} \\quad (1)$$\n$$E(M_2) = E_{\\infty} + A M_2^{-p} \\quad (2)$$\n\n我们的目标是消去未知的前因子 $A$ 并求解 $E_{\\infty}$。我们可以通过先重新整理两个方程以分离出含有 $A$ 的项来实现这一点：\n从方程 (1)：\n$$A M_1^{-p} = E(M_1) - E_{\\infty}$$\n$$A = (E(M_1) - E_{\\infty}) M_1^p \\quad (3)$$\n\n从方程 (2)：\n$$A M_2^{-p} = E(M_2) - E_{\\infty}$$\n$$A = (E(M_2) - E_{\\infty}) M_2^p \\quad (4)$$\n\n由于表达式 (3) 和 (4) 都等于 $A$，我们可以将它们设为相等：\n$$(E(M_1) - E_{\\infty}) M_1^p = (E(M_2) - E_{\\infty}) M_2^p$$\n\n接下来，我们展开各项并重新整理方程，将包含 $E_{\\infty}$ 的项归类：\n$$E(M_1) M_1^p - E_{\\infty} M_1^p = E(M_2) M_2^p - E_{\\infty} M_2^p$$\n\n将所有包含 $E_{\\infty}$ 的项移到左侧，所有其他项移到右侧，得到：\n$$E_{\\infty} M_2^p - E_{\\infty} M_1^p = E(M_2) M_2^p - E(M_1) M_1^p$$\n\n然后我们可以提出公因子 $E_{\\infty}$：\n$$E_{\\infty} (M_2^p - M_1^p) = E(M_2) M_2^p - E(M_1) M_1^p$$\n\n最后，假设 $M_1 \\neq M_2$，我们可以通过除以因子 $(M_2^p - M_1^p)$ 来分离出 $E_{\\infty}$：\n$$E_{\\infty} = \\frac{E(M_2) M_2^p - E(M_1) M_1^p}{M_2^p - M_1^p}$$\n这就是用于从两次有限基组计算中估计 CBS 极限能量的、成熟的两点外推公式。\n\n**2. 计算流程**\n\n整个任务是为每个测试用例计算量 $\\Delta E_{\\text{ads}} = E_{\\text{ads}}^{\\text{CP}}(M_2) - E_{\\text{ads}}^{\\text{CBS}}$。这涉及到计算两种不同的吸附能：在基组大小为 $M_2$ 时的平衡校正能量和估计的 CBS 极限能量。\n\n首先，我们计算吸附能的 CBS 极限 $E_{\\text{ads}}^{\\text{CBS}}$。根据其定义：\n$$E_{\\text{ads}}^{\\text{CBS}} = E_{\\text{AB},\\infty} - E_{\\text{A},\\infty} - E_{\\text{B},\\infty}$$\n对于每个物种 $X \\in \\{\\text{AB}, \\text{A}, \\text{B}\\}$，我们使用推导出的外推公式来确定其 CBS 极限能量 $E_{X,\\infty}$：\n$$E_{X,\\infty} = \\frac{E_X(M_2) M_2^p - E_X(M_1) M_1^p}{M_2^p - M_1^p}$$\n该计算需要能量 $E_X(M_1)$ 和 $E_X(M_2)$、基数 $M_1$ 和 $M_2$ 以及指数 $p$，所有这些都在每个测试用例中提供。\n\n其次，我们计算在较大基组水平 $M_2$ 下的平衡校正吸附能 $E_{\\text{ads}}^{\\text{CP}}(M_2)$。其定义为：\n$$E_{\\text{ads}}^{\\text{CP}}(M_2) = E_{\\text{AB}}(M_2) - E_{\\text{A}}^{\\text{ghost}}(M_2) - E_{\\text{B}}^{\\text{ghost}}(M_2)$$\n右侧所需的所有能量——$E_{\\text{AB}}(M_2)$、$E_{\\text{A}}^{\\text{ghost}}(M_2)$ 和 $E_{\\text{B}}^{\\text{ghost}}(M_2)$——都在问题陈述中为每个测试用例直接提供。\"鬼\"基组计算是一种标准技术（Boys-Bernardi 平衡校正），旨在减轻基组叠加误差 (BSSE)，这是一种由于单体在二聚体计算中相互“借用”基函数而产生的人为稳定化效应。\n\n最后，我们计算差值 $\\Delta E_{\\text{ads}}$：\n$$\\Delta E_{\\text{ads}} = E_{\\text{ads}}^{\\text{CP}}(M_2) - E_{\\text{ads}}^{\\text{CBS}}$$\n$\\Delta E_{\\text{ads}}$ 的符号提供了关于在 $M_2$ 水平下的平衡校正相对于真实的 CBS 极限是过度校正还是校正不足的洞见。\n- 如果 $\\Delta E_{\\text{ads}} > 0$，则 $E_{\\text{ads}}^{\\text{CP}}(M_2) > E_{\\text{ads}}^{\\text{CBS}}$。由于吸附能通常为负值，这意味着校正后的能量负值较小（结合较弱），这种情况被称为“过度校正”。\n- 如果 $\\Delta E_{\\text{ads}}  0$，则 $E_{\\text{ads}}^{\\text{CP}}(M_2)  E_{\\text{ads}}^{\\text{CBS}}$。校正后的能量负值较大（结合较强），这种情况被称为“校正不足”。\n- 如果 $\\Delta E_{\\text{ads}} = 0$，则校正完美地平衡了在 $M_2$ 水平下的残余基组不完备性误差。\n\n将实现一个算法，将此完整流程应用于每个测试用例，计算 $\\Delta E_{\\text{ads}}$，将结果四舍五入到六位小数，并将所有结果格式化为指定的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the difference between counterpoise-corrected and CBS-extrapolated\n    adsorption energies for a given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: p=4, M1=3, M2=4\n        {\n            'p': 4, 'M1': 3, 'M2': 4,\n            'E_AB_pts': (-21.117037037037, -21.1190625),\n            'E_A_pts': (-19.796296296296, -19.798828125),\n            'E_B_pts': (-1.249259259259, -1.249765625),\n            'E_A_ghost_M2': -19.799628125,\n            'E_B_ghost_M2': -1.249965625\n        },\n        # Case 2: p=4, M1=3, M2=4\n        {\n            'p': 4, 'M1': 3, 'M2': 4,\n            'E_AB_pts': (-15.198148148148, -15.1994140625),\n            'E_A_pts': (-13.997777777778, -13.999296875),\n            'E_B_pts': (-1.11962962963, -1.1198828125),\n            'E_A_ghost_M2': -13.999396875,\n            'E_B_ghost_M2': -1.1199028125\n        },\n        # Case 3: p=5, M1=3, M2=5\n        {\n            'p': 5, 'M1': 3, 'M2': 5,\n            'E_AB_pts': (-7.319670781893, -7.3199744),\n            'E_A_pts': (-6.19975308642, -6.1999808),\n            'E_B_pts': (-1.09991736227, -1.0999936),\n            'E_A_ghost_M2': -6.1999958,\n            'E_B_ghost_M2': -1.0999976\n        },\n        # Case 4: p=3, M1=2, M2=3\n        {\n            'p': 3, 'M1': 2, 'M2': 3,\n            'E_AB_pts': (-34.95, -34.9851851852),\n            'E_A_pts': (-33.425, -33.4777777778),\n            'E_B_pts': (-1.3625, -1.3888888889),\n            'E_A_ghost_M2': -33.4817778,\n            'E_B_ghost_M2': -1.3894889\n        }\n    ]\n\n    def extrapolate_cbs(e1, m1, e2, m2, p):\n        \"\"\"\n        Calculates the CBS limit energy using the two-point extrapolation formula.\n        E_inf = (E(M2)*M2^p - E(M1)*M1^p) / (M2^p - M1^p)\n        \"\"\"\n        m1_p = np.power(float(m1), float(p))\n        m2_p = np.power(float(m2), float(p))\n        numerator = e2 * m2_p - e1 * m1_p\n        denominator = m2_p - m1_p\n        return numerator / denominator\n\n    results = []\n    for case in test_cases:\n        p = case['p']\n        m1 = case['M1']\n        m2 = case['M2']\n\n        # Unpack energy points\n        e_ab_m1, e_ab_m2 = case['E_AB_pts']\n        e_a_m1, e_a_m2 = case['E_A_pts']\n        e_b_m1, e_b_m2 = case['E_B_pts']\n\n        # 1. Extrapolate to find CBS limit for each component\n        e_ab_inf = extrapolate_cbs(e_ab_m1, m1, e_ab_m2, m2, p)\n        e_a_inf = extrapolate_cbs(e_a_m1, m1, e_a_m2, m2, p)\n        e_b_inf = extrapolate_cbs(e_b_m1, m1, e_b_m2, m2, p)\n\n        # 2. Compute CBS adsorption energy\n        # E_ads_CBS = E_AB_inf - E_A_inf - E_B_inf\n        e_ads_cbs = e_ab_inf - e_a_inf - e_b_inf\n\n        # 3. Compute counterpoise-corrected adsorption energy at M2\n        # E_ads_CP(M2) = E_AB(M2) - E_A_ghost(M2) - E_B_ghost(M2)\n        e_a_ghost_m2 = case['E_A_ghost_M2']\n        e_b_ghost_m2 = case['E_B_ghost_M2']\n        e_ads_cp_m2 = e_ab_m2 - e_a_ghost_m2 - e_b_ghost_m2\n\n        # 4. Compute the difference Delta_E_ads\n        # Delta_E_ads = E_ads_CP(M2) - E_ads_CBS\n        delta_e_ads = e_ads_cp_m2 - e_ads_cbs\n        results.append(delta_e_ads)\n\n    # Final print statement in the exact required format.\n    # The output format string \"{:.6f}\" handles rounding to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "BSSE 的原理是普适的，但它在周期性固态计算中的表现形式和处理方式具有其独特性。本练习将这一概念应用于一个关键的材料科学问题：点缺陷形成能的计算。你将研究 BSSE 如何随着超胞（supercell）尺寸的变化而变化，并学习使用幂律（power-law）模型来拟合和分析这种收敛行为。这不仅能加深你对固态计算中误差来源的理解，还能锻炼你进行数据分析和模型验证的实践能力。",
            "id": "3434554",
            "problem": "考虑在晶体固体中使用以原子为中心的基函数对点缺陷进行周期性超晶胞计算。基组不完备性会导致基组重叠误差（BSSE），当片段或位点相互借用基函数时，这会使计算出的总能量产生偏差。在适用于周期性固体的反向校正方法中，引入了鬼基函数（放置在没有相关电子或原子核的晶格位点上的基函数）来量化这种偏差。缺陷形成能 $E_f$ 由总能量差定义，而 BSSE 通过比较在缺陷位点放置和不放置鬼基函数时计算的 $E_f$ 来分离。对于局域化的缺陷态，由于局域区域的空间限制以及与越来越远的晶格位点上基函数的重叠减少，BSSE 的贡献预计会随着超晶胞线性尺寸 $L$ 的增加而衰减。\n\n从形成能是总能量之差的定义出发，并基于线性尺寸标度通过超晶胞中可用于基组借用的空间域引入的原理，您必须编写一个程序，对每个测试用例执行以下步骤：\n\n1. 对每个超晶胞尺寸 $L$，通过计算不含鬼基函数的形成能与含鬼基函数的形成能之差，来计算对缺陷形成能的 BSSE 贡献，即 $\\Delta E_f^{\\text{BSSE}}(L) = E_f^{\\text{no-ghost}}(L) - E_f^{\\text{ghost}}(L)$。在分析中使用绝对值 $|\\Delta E_f^{\\text{BSSE}}(L)|$。\n2. 将 $|\\Delta E_f^{\\text{BSSE}}(L)|$ 的标度行为建模为幂律 $c L^{-\\alpha}$，这可能源于缺陷态的局域化效应和随距离增加而减弱的基组借用。\n3. 使用与幂律模型一致的、有原则的变换方法，根据提供的 $L$ 数据估算标度指数 $\\alpha$，并报告每个测试用例得出的 $\\alpha$。\n4. 所有能量均已提供，并且必须以电子伏特 (eV) 为单位处理。超晶胞尺寸参数 $L$ 是一个无量纲的线性复制因子（沿一个晶格矢量方向的原胞数量）。\n5. 您的程序必须生成单行输出，其中包含所有测试用例的估算指数，格式为方括号内以逗号分隔的列表，每个浮点数四舍五入到三位小数，例如：“[$\\alpha_1$,$\\alpha_2$,$\\alpha_3$]”。\n\n使用以下测试套件，每个套件包含一组 $L$ 值以及相应的有鬼基函数和无鬼基函数的形成能：\n\n- 测试用例 A（具有三维衰减的局域化缺陷）：\n  - 超晶胞尺寸：$L \\in \\{2,3,4,5,6\\}$。\n  - 含鬼基函数的形成能：$E_f^{\\text{ghost}}(L) = 3.250 \\text{ eV}$（对所有 $L$）。\n  - 不含鬼基函数的形成能：$E_f^{\\text{no-ghost}}(2) = 3.2625 \\text{ eV}$，$E_f^{\\text{no-ghost}}(3) = 3.2537037 \\text{ eV}$，$E_f^{\\text{no-ghost}}(4) = 3.2515625 \\text{ eV}$，$E_f^{\\text{no-ghost}}(5) = 3.2508 \\text{ eV}$，$E_f^{\\text{no-ghost}}(6) = 3.250462962963 \\text{ eV}$。\n\n- 测试用例 B（扩展弹性场引起的较缓衰减特性）：\n  - 超晶胞尺寸：$L \\in \\{4,8,12,16,20\\}$。\n  - 含鬼基函数的形成能：$E_f^{\\text{ghost}}(L) = 5.100 \\text{ eV}$（对所有 $L$）。\n  - 不含鬼基函数的形成能：$E_f^{\\text{no-ghost}}(4) = 5.1125 \\text{ eV}$，$E_f^{\\text{no-ghost}}(8) = 5.10625 \\text{ eV}$，$E_f^{\\text{no-ghost}}(12) = 5.104166666667 \\text{ eV}$，$E_f^{\\text{no-ghost}}(16) = 5.103125 \\text{ eV}$，$E_f^{\\text{no-ghost}}(20) = 5.1025 \\text{ eV}$。\n\n- 测试用例 C（由于细微的基组干涉导致 BSSE 非常小且符号交替；分析使用绝对值）：\n  - 超晶胞尺寸：$L \\in \\{3,5,7,9,11\\}$。\n  - 含鬼基函数的形成能：$E_f^{\\text{ghost}}(L) = 2.000 \\text{ eV}$（对所有 $L$）。\n  - 不含鬼基函数的形成能：$E_f^{\\text{no-ghost}}(3) = 2.00024691358 \\text{ eV}$，$E_f^{\\text{no-ghost}}(5) = 1.999968 \\text{ eV}$，$E_f^{\\text{no-ghost}}(7) = 2.00000832903 \\text{ eV}$，$E_f^{\\text{no-ghost}}(9) = 1.999996952 \\text{ eV}$，$E_f^{\\text{no-ghost}}(11) = 2.000001366 \\text{ eV}$。\n\n算法约束：\n\n- 将任何小于 $10^{-12} \\text{ eV}$ 的 $|\\Delta E_f^{\\text{BSSE}}(L)|$ 值视为数值上可忽略不计，并将其从标度分析中排除，以避免对零取对数。\n- 使用不依赖于随机选择的确定性方法。\n- 以要求的单行格式表示最终输出。每个报告的 $\\alpha$ 必须是四舍五入到三位小数的浮点数。\n\n您的程序应生成单行输出，其中包含结果，格式为方括号内以逗号分隔的列表（例如，“[$\\alpha_{\\text{A}}$,$\\alpha_{\\text{B}}$,$\\alpha_{\\text{C}}$]”）。",
            "solution": "该问题经评估有效。它在科学上基于计算材料科学的原理，特别是关于周期性固体量子化学计算中基组不完备性的问题。该问题提法明确、客观，并提供了推导唯一、有意义解所需的所有数据和约束。\n\n问题的核心是确定基组重叠误差（BSSE）作为超晶胞线性尺寸 $L$ 函数的标度指数 $\\alpha$。BSSE 由一个幂律建模：\n$$\n|\\Delta E_f^{\\text{BSSE}}(L)| = c L^{-\\alpha}\n$$\n其中 $|\\Delta E_f^{\\text{BSSE}}(L)|$ 是 BSSE 对缺陷形成能贡献的大小，$c$ 是一个常数，而 $\\alpha$ 是待确定的标度指数。\n\n为了找到 $\\alpha$，我们可以通过对等式两边取自然对数来线性化这个幂律关系：\n$$\n\\ln\\left(|\\Delta E_f^{\\text{BSSE}}(L)|\\right) = \\ln\\left(c L^{-\\alpha}\\right)\n$$\n利用对数的性质，该表达式可简化为：\n$$\n\\ln\\left(|\\Delta E_f^{\\text{BSSE}}(L)|\\right) = \\ln(c) - \\alpha \\ln(L)\n$$\n该方程是直线形式 $y = mx + b$，其中：\n- 因变量为 $y = \\ln(|\\Delta E_f^{\\text{BSSE}}(L)|)$。\n- 自变量为 $x = \\ln(L)$。\n- 直线的斜率为 $m = -\\alpha$。\n- y轴截距为 $b = \\ln(c)$。\n\n因此，可以通过对数据点 $(\\ln(L), \\ln(|\\Delta E_f^{\\text{BSSE}}(L)|))$ 进行线性回归，并根据得到的斜率 $m$ 计算 $\\alpha = -m$，来确定标度指数 $\\alpha$。\n\n每个测试用例的步骤如下：\n\n1.  **计算 BSSE 贡献**：对于给定测试用例中的每个超晶胞尺寸 $L_i$，使用提供的数据计算对形成能的 BSSE 贡献：\n    $$\n    \\Delta E_f^{\\text{BSSE}}(L_i) = E_f^{\\text{no-ghost}}(L_i) - E_f^{\\text{ghost}}(L_i)\n    $$\n\n2.  **准备回归数据**：\n    - 取 BSSE 的绝对值，$y'_i = |\\Delta E_f^{\\text{BSSE}}(L_i)|$。\n    - 根据问题的约束，筛选掉任何满足 $y'_i  10^{-12} \\text{ eV}$ 的数据对 $(L_i, y'_i)$。\n    - 通过取自然对数来转换剩余的数据点，以创建用于线性回归的数据集：$x_i = \\ln(L_i)$ 和 $y_i = \\ln(y'_i)$。\n\n3.  **执行线性回归**：使用标准数值方法找到数据点 $(x_i, y_i)$ 的最佳拟合线的斜率 $m$。`numpy.polyfit` 函数适合此任务，可拟合一个 1 次多项式。它返回直线 $y = mx + b$ 的系数 $[m, b]$。\n\n4.  **计算指数**：然后通过取斜率的负值来找到标度指数：\n    $$\n    \\alpha = -m\n    $$\n\n该过程将应用于所提供的三个测试用例中的每一个。\n\n**测试用例 A：具有三维衰减的局域化缺陷**\n- 超晶胞尺寸：$L \\in \\{2, 3, 4, 5, 6\\}$。\n- $E_f^{\\text{ghost}}(L) = 3.250 \\text{ eV}$。\n- $|\\Delta E_f^{\\text{BSSE}}(L)|$ 的值计算如下：$|\\Delta E_f^{\\text{BSSE}}(2)| = |3.2625 - 3.250| = 0.0125 \\text{ eV}$，$|\\Delta E_f^{\\text{BSSE}}(3)| = |3.2537037 - 3.250| \\approx 0.0037037 \\text{ eV}$，依此类推。所有计算值都大于 $10^{-12} \\text{ eV}$，并被包含在拟合中。对 $(\\ln(L), \\ln(|\\Delta E_f^{\\text{BSSE}}(L)|))$ 进行线性回归以找到斜率，并计算出 $\\alpha_A$。\n\n**测试用例 B：扩展弹性场引起的较缓衰减特性**\n- 超晶胞尺寸：$L \\in \\{4, 8, 12, 16, 20\\}$。\n- $E_f^{\\text{ghost}}(L) = 5.100 \\text{ eV}$。\n- 计算 $|\\Delta E_f^{\\text{BSSE}}(L)|$ 的值，例如 $|\\Delta E_f^{\\text{BSSE}}(4)| = |5.1125 - 5.100| = 0.0125 \\text{ eV}$。所有值都大于 $10^{-12} \\text{ eV}$。执行线性回归以找到斜率，并计算出 $\\alpha_B$。\n\n**测试用例 C：BSSE 很小且符号交替**\n- 超晶胞尺寸：$L \\in \\{3, 5, 7, 9, 11\\}$。\n- $E_f^{\\text{ghost}}(L) = 2.000 \\text{ eV}$。\n- 计算 $|\\Delta E_f^{\\text{BSSE}}(L)|$ 的值，例如 $|\\Delta E_f^{\\text{BSSE}}(3)| = |2.00024691358 - 2.000| \\approx 2.47 \\times 10^{-4} \\text{ eV}$ 和 $|\\Delta E_f^{\\text{BSSE}}(5)| = |1.999968 - 2.000| = 3.2 \\times 10^{-5} \\text{ eV}$。所有绝对值都大于 $10^{-12} \\text{ eV}$。使用线性回归找到斜率，并计算出 $\\alpha_C$。\n\n最终输出将汇编计算出的指数 $[\\alpha_A, \\alpha_B, \\alpha_C]$，并按要求格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the scaling exponent alpha for BSSE decay in supercell calculations.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"L\": np.array([2, 3, 4, 5, 6]),\n            \"E_ghost\": np.array([3.250, 3.250, 3.250, 3.250, 3.250]),\n            \"E_noghost\": np.array([3.2625, 3.2537037, 3.2515625, 3.2508, 3.250462962963])\n        },\n        {\n            \"name\": \"Case B\",\n            \"L\": np.array([4, 8, 12, 16, 20]),\n            \"E_ghost\": np.array([5.100, 5.100, 5.100, 5.100, 5.100]),\n            \"E_noghost\": np.array([5.1125, 5.10625, 5.104166666667, 5.103125, 5.1025])\n        },\n        {\n            \"name\": \"Case C\",\n            \"L\": np.array([3, 5, 7, 9, 11]),\n            \"E_ghost\": np.array([2.000, 2.000, 2.000, 2.000, 2.000]),\n            \"E_noghost\": np.array([2.00024691358, 1.999968, 2.00000832903, 1.999996952, 2.000001366])\n        }\n    ]\n\n    results = []\n    \n    # Numerical tolerance for filtering data\n    tolerance = 1e-12\n\n    for case in test_cases:\n        # Step 1: Compute the BSSE contribution and take its absolute value\n        delta_E_bsse = np.abs(case[\"E_noghost\"] - case[\"E_ghost\"])\n        L_vals = case[\"L\"]\n\n        # Step 2: Filter out numerically negligible values\n        mask = delta_E_bsse >= tolerance\n        \n        filtered_L = L_vals[mask]\n        filtered_delta_E = delta_E_bsse[mask]\n\n        # Prepare for linear regression by taking logarithms\n        # x = ln(L), y = ln(|delta_E|)\n        log_L = np.log(filtered_L)\n        log_delta_E = np.log(filtered_delta_E)\n\n        # Step 3: Perform linear regression to find the slope m\n        # The model is ln(|delta_E|) = ln(c) - alpha * ln(L)\n        # This is a line y = mx + b, where y = ln(|delta_E|), x = ln(L), and slope m = -alpha.\n        # np.polyfit(x, y, 1) returns [slope, intercept]\n        slope, _ = np.polyfit(log_L, log_delta_E, 1)\n\n        # Step 4: Calculate the scaling exponent alpha\n        alpha = -slope\n        results.append(alpha)\n\n    # Final print statement in the exact required format.\n    # Format each float to three decimal places.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}