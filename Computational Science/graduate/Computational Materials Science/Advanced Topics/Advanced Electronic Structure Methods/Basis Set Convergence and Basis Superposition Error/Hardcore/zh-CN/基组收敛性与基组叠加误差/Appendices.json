{
    "hands_on_practices": [
        {
            "introduction": "在计算相互作用能时，有限基组会引入误差。本练习旨在从第一性原理出发，将总基组误差精确地分解为两个截然不同的部分：基组叠加误差（BSSE）和基组不完备性误差（BSIE）。通过亲手进行这种分解 ，您将深刻理解这些误差的来源以及为何需要发展诸如对位校正之类的技术来有针对性地处理它们。",
            "id": "3434474",
            "problem": "要求您形式化并实现将相互作用能中的总基组误差分解为基组不完备误差（BSIE）和基组重叠误差（BSSE）的过程，此过程需在计算材料科学的框架内，并利用支撑基于波函数的电子结构理论的原理。您的推导必须从一个有效的基础出发：即 Born-Oppenheimer 近似下的非相对论电子薛定谔方程、厄米算符的 Rayleigh-Ritz 变分原理，以及有限基组中相互作用能的定义。目标是推导该分解是什么，为什么成立，以及如何通过使用单独片段基组和超分子基组进行有针对性的计算来分离每个分量，然后用代码实现所得公式。所有能量均以哈特里（Hartree）表示，并且所有结果必须以哈特里（Hartree）为单位输出。\n\n使用以下基本事实和定义：\n- 电子薛定谔方程得到基态能量 $E$，在实践中通过投影到有限基组 $\\mathcal{B}$ 上来近似，从而得到能量 $E^\\mathcal{B}$。\n- Rayleigh-Ritz 变分原理在适当条件下确保 $E^\\mathcal{B} \\geq E^\\infty$，其中 $E^\\infty$ 表示完备基组极限。\n- 对于由片段 $A$ 和 $B$ 形成的二聚体，有限基组中的相互作用能定义为\n$$\nE_{\\mathrm{int}}^\\mathcal{B} = E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A} - E_B^{\\mathcal{B}_B},\n$$\n其中 $E_{AB}^{\\mathcal{B}_{AB}}$ 是在超分子基组 $\\mathcal{B}_{AB}$ 中的二聚体能量，而 $E_X^{\\mathcal{B}_X}$ 是在它们各自的单独片段基组 $\\mathcal{B}_X$ 中的单体能量（对于 $X \\in \\{A,B\\}$）。\n- 基组重叠误差（BSSE）的产生是因为在超分子基组中，$A$ 和 $B$ 可以通过相互借用对方的基函数来变分地降低自身的能量。为了量化这一点，计算 $E_A^{\\mathcal{B}_{AB}}$ 和 $E_B^{\\mathcal{B}_{AB}}$，即在存在另一片段的鬼函数（没有另一片段的电子或原子核）的情况下，在超分子基组中的单体能量，然后构成对位校正的相互作用能\n$$\nE_{\\mathrm{int}}^{\\mathrm{CP}} = E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_{AB}} - E_B^{\\mathcal{B}_{AB}}。\n$$\n\n任务：\n- 推导总相互作用能误差\n$$\n\\Delta E_{\\mathrm{int}}^{\\mathrm{tot}} = E_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^\\infty\n$$\n的形式分解，将其分解为两个分别对应于基组重叠误差（BSSE）和基组不完备误差（BSIE）的加和分量。推导必须从上述定义和基本原理开始，并且不得在没有论证的情况下引入任何快捷公式。\n- 基于该分解，设计并实现一个算法，该算法在给定使用单独片段基组和超分子基组的目标计算后，能够分离出 BSSE 和 BSIE 的数值：\n  - 从 $E_{AB}^{\\mathcal{B}_{AB}}, E_A^{\\mathcal{B}_A}, E_B^{\\mathcal{B}_B}$ 计算 $E_{\\mathrm{int}}^\\mathcal{B}$。\n  - 从 $E_{AB}^{\\mathcal{B}_{AB}}, E_A^{\\mathcal{B}_{AB}}, E_B^{\\mathcal{B}_{AB}}$ 计算 $E_{\\mathrm{int}}^{\\mathrm{CP}}$。\n  - 使用一个给定的参考值 $E_{\\mathrm{int}}^\\infty$（来自一个近乎完备的基组）来明确地分离 BSIE 和 BSSE 的数值。\n\n测试套件的输入数据：\n对于每个测试用例 $i$，您将获得六个以哈特里（Hartree）为单位的实数：\n- $E_{AB}^{\\mathcal{B}_{AB}}$，\n- $E_A^{\\mathcal{B}_A}$，\n- $E_B^{\\mathcal{B}_B}$，\n- $E_A^{\\mathcal{B}_{AB}}$，\n- $E_B^{\\mathcal{B}_{AB}}$，\n- $E_{\\mathrm{int}}^\\infty$。\n\n使用以下参数集（所有值单位均为哈特里）：\n- 测试用例 1（中等基组重叠误差）：\n  - $E_{AB}^{\\mathcal{B}_{AB}} = -152.345678$\n  - $E_A^{\\mathcal{B}_A} = -76.123456$\n  - $E_B^{\\mathcal{B}_B} = -76.200000$\n  - $E_A^{\\mathcal{B}_{AB}} = -76.130000$\n  - $E_B^{\\mathcal{B}_{AB}} = -76.205000$\n  - $E_{\\mathrm{int}}^\\infty = -0.012000$\n- 测试用例 2（近乎完备的基组，基组重叠误差可忽略不计）：\n  - $E_{AB}^{\\mathcal{B}_{AB}} = -20.000010$\n  - $E_A^{\\mathcal{B}_A} = -10.000000$\n  - $E_B^{\\mathcal{B}_B} = -10.000000$\n  - $E_A^{\\mathcal{B}_{AB}} = -10.000001$\n  - $E_B^{\\mathcal{B}_{AB}} = -10.000001$\n  - $E_{\\mathrm{int}}^\\infty = -0.000008$\n- 测试用例 3（使用最小基组，基组重叠误差严重）：\n  - $E_{AB}^{\\mathcal{B}_{AB}} = -30.080000$\n  - $E_A^{\\mathcal{B}_A} = -15.000000$\n  - $E_B^{\\mathcal{B}_B} = -15.000000$\n  - $E_A^{\\mathcal{B}_{AB}} = -15.050000$\n  - $E_B^{\\mathcal{B}_{AB}} = -15.020000$\n  - $E_{\\mathrm{int}}^\\infty = -0.015000$\n- 测试用例 4（不对称的基组重叠误差，仅片段 $A$）：\n  - $E_{AB}^{\\mathcal{B}_{AB}} = -21.120000$\n  - $E_A^{\\mathcal{B}_A} = -12.345600$\n  - $E_B^{\\mathcal{B}_B} = -8.765400$\n  - $E_A^{\\mathcal{B}_{AB}} = -12.349000$\n  - $E_B^{\\mathcal{B}_{AB}} = -8.765400$\n  - $E_{\\mathrm{int}}^\\infty = -0.006000$\n\n每个测试用例的所需输出（所有单位均为哈特里）：\n- 基组重叠误差对相互作用能误差的贡献，定义为在超分子基组中单体能量相对于单独片段基组的能量降低。\n- 对位校正的相互作用能中相对于参考完备基组相互作用能的基组不完备误差贡献。\n- 相对于完备基组参考的总相互作用能误差。\n- 一个布尔值，如果分解在数值公差范围内成立，则为 true，否则为 false。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个列表，顺序为 [$\\mathrm{BSSE}$, $\\mathrm{BSIE}$, $\\Delta E_{\\mathrm{int}}^{\\mathrm{tot}}$, 一致性布尔值]。示例格式：$[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$。所有量必须以哈特里（Hartree）报告。不涉及角度。不得使用百分比。",
            "solution": "该问题要求对电子结构计算中总相互作用能误差分解为基组重叠误差（BSSE）和基组不完备误差（BSIE）进行形式推导和计算实现。推导必须建立在所提供的基本原理和定义之上。\n\n让我们首先建立理论基础。分子系统的基态能量是电子哈密顿算符 $\\hat{H}$ 的最低本征值，由不含时薛定谔方程给出。在实践中，我们采用 Rayleigh-Ritz 变分原理，该原理指出，对于适当希尔伯特空间中的任意试验波函数 $\\Psi$，能量的期望值 $\\langle \\Psi | \\hat{H} | \\Psi \\rangle / \\langle \\Psi | \\Psi \\rangle$ 是真实基态能量 $E^\\infty$ 的一个上界。当我们将波函数表示为有限基组 $\\mathcal{B}$ 中函数的线性组合时，该原理保证计算出的能量 $E^\\mathcal{B}$ 是完备基组极限下精确能量 $E^\\infty$ 的一个上界。即 $E^\\mathcal{B} \\ge E^\\infty$。\n\n对于一个由两个相互作用的片段 $A$ 和 $B$ 组成的系统，完备基组（CBS）极限下的相互作用能 $E_{\\mathrm{int}}^\\infty$ 是真实的物理相互作用能，定义为：\n$$\nE_{\\mathrm{int}}^\\infty = E_{AB}^\\infty - E_A^\\infty - E_B^\\infty\n$$\n其中 $E_{AB}^\\infty$、$E_A^\\infty$ 和 $E_B^\\infty$ 分别是二聚体 $AB$ 和单体 $A$、$B$ 在 CBS 极限下的能量。\n\n在用有限基组 $\\mathcal{B}$ 进行的实际计算中，未校正或“原始”的相互作用能定义为：\n$$\nE_{\\mathrm{int}}^\\mathcal{B} = E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A} - E_B^{\\mathcal{B}_B}\n$$\n在这里，$E_{AB}^{\\mathcal{B}_{AB}}$ 是在超分子基组 $\\mathcal{B}_{AB} = \\mathcal{B}_A \\cup \\mathcal{B}_B$ 中计算的二聚体能量。单体能量 $E_A^{\\mathcal{B}_A}$ 和 $E_B^{\\mathcal{B}_B}$ 仅使用它们各自以片段为中心的基组 $\\mathcal{B}_A$ 和 $\\mathcal{B}_B$ 进行计算。\n\n使用基组 $\\mathcal{B}$ 计算的相互作用能的总误差是其与 CBS 极限的偏差：\n$$\n\\Delta E_{\\mathrm{int}}^{\\mathrm{tot}} = E_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^\\infty\n$$\n\n我们的目标是将这个总误差分解为两个具有物理意义的、可加的分量。关键的思路是引入对位校正的相互作用能 $E_{\\mathrm{int}}^{\\mathrm{CP}}$，它旨在减轻一种特定类型的误差。Boys 和 Bernardi（1970）的对位校正（CP）方法提出，如果单体能量也在完整的超分子基组 $\\mathcal{B}_{AB}$ 中计算，可以获得更均衡的描述。这是通过在每个单体的计算中，包含另一个片段的基函数（称为“鬼”函数），但同时不包含其原子核或电子来完成的。这些能量表示为 $E_A^{\\mathcal{B}_{AB}}$ 和 $E_B^{\\mathcal{B}_{AB}}$。经过对位校正的相互作用能则为：\n$$\nE_{\\mathrm{int}}^{\\mathrm{CP}} = E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_{AB}} - E_B^{\\mathcal{B}_{AB}}\n$$\n\n定义了 $E_{\\mathrm{int}}^{\\mathrm{CP}}$ 后，我们可以通过加上和减去该项来分解总误差：\n$$\n\\Delta E_{\\mathrm{int}}^{\\mathrm{tot}} = (E_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^{\\mathrm{CP}}) + (E_{\\mathrm{int}}^{\\mathrm{CP}} - E_{\\mathrm{int}}^\\infty)\n$$\n这纯粹是一个代数操作，将总误差划分为两个分量。让我们来分析每个分量。\n\n第一个分量 $(E_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^{\\mathrm{CP}})$ 表示未校正和对位校正的相互作用能之间的差异。让我们使用它们的定义来展开这个项：\n$$\nE_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^{\\mathrm{CP}} = (E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A} - E_B^{\\mathcal{B}_B}) - (E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_{AB}} - E_B^{\\mathcal{B}_{AB}})\n$$\n$$\nE_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^{\\mathrm{CP}} = (E_A^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A}) + (E_B^{\\mathcal{B}_{AB}} - E_B^{\\mathcal{B}_B})\n$$\n项 $(E_A^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A})$ 是当单体 $A$ 的描述因片段 $B$ 的基函数可用而改善时，其能量的降低值。根据变分原理，由于 $\\mathcal{B}_A \\subseteq \\mathcal{B}_{AB}$，能量 $E_A^{\\mathcal{B}_{AB}}$ 必须小于或等于 $E_A^{\\mathcal{B}_A}$。因此，这个差值为负或零。这种虚假的能量降低是由于在 $E_{\\mathrm{int}}^\\mathcal{B}$ 的定义中使用了不平衡的基组所产生的人为结果；单体 $A$ “借用” $B$ 的函数来更好地描述自身的电子密度。这种人为的稳定性就是基组重叠误差（BSSE）。因此，BSSE 对总相互作用能误差的贡献就是这个量。我们将此贡献定义为：\n$$\n\\delta_{\\mathrm{BSSE}} = (E_A^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A}) + (E_B^{\\mathcal{B}_{AB}} - E_B^{\\mathcal{B}_B})\n$$\n\n第二个分量 $(E_{\\mathrm{int}}^{\\mathrm{CP}} - E_{\\mathrm{int}}^\\infty)$ 代表剩余的误差。量 $E_{\\mathrm{int}}^{\\mathrm{CP}}$ 被认为是比 $E_{\\mathrm{int}}^\\mathcal{B}$ 更好的 $E_{\\mathrm{int}}^\\infty$ 的近似，因为 BSSE 已经被移除。在 $E_{\\mathrm{int}}^{\\mathrm{CP}}$ 中剩余的误差是由于整个超分子基组 $\\mathcal{B}_{AB}$ 在描述相互作用系统的完整物理过程方面的内在不足或不完备性，即使在校正了重叠伪影之后也是如此。因此，这就是基组不完备误差（BSIE）。我们将其定义为：\n$$\n\\delta_{\\mathrm{BSIE}} = E_{\\mathrm{int}}^{\\mathrm{CP}} - E_{\\mathrm{int}}^\\infty\n$$\n\n因此，总误差的形式分解为：\n$$\n\\Delta E_{\\mathrm{int}}^{\\mathrm{tot}} = \\delta_{\\mathrm{BSSE}} + \\delta_{\\mathrm{BSIE}}\n$$\n此分解在构造上是算术精确的，并将误差分为一个由不平衡基组描述引起的分量（BSSE）和一个由有限基组本身内在局限性引起的分量（BSIE）。\n\n要基于此推导实现一个算法，我们将从六个输入能量（$E_{AB}^{\\mathcal{B}_{AB}}$、$E_A^{\\mathcal{B}_A}$、$E_B^{\\mathcal{B}_B}$、$E_A^{\\mathcal{B}_{AB}}$、$E_B^{\\mathcal{B}_{AB}}$、$E_{\\mathrm{int}}^\\infty$）计算以下量：\n\n1.  计算未校正的相互作用能：$E_{\\mathrm{int}}^\\mathcal{B} = E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A} - E_B^{\\mathcal{B}_B}$。\n2.  计算对位校正的相互作用能：$E_{\\mathrm{int}}^{\\mathrm{CP}} = E_{AB}^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_{AB}} - E_B^{\\mathcal{B}_{AB}}$。\n3.  计算总误差：$\\Delta E_{\\mathrm{int}}^{\\mathrm{tot}} = E_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^\\infty$。\n4.  计算 BSSE 对误差的贡献：$\\delta_{\\mathrm{BSSE}} = E_{\\mathrm{int}}^\\mathcal{B} - E_{\\mathrm{int}}^{\\mathrm{CP}}$。这等价于 $(E_A^{\\mathcal{B}_{AB}} - E_A^{\\mathcal{B}_A}) + (E_B^{\\mathcal{B}_{AB}} - E_B^{\\mathcal{B}_B})$。根据要求，这个量将作为 BSSE 报告。\n5.  计算 BSIE 的贡献：$\\delta_{\\mathrm{BSIE}} = E_{\\mathrm{int}}^{\\mathrm{CP}} - E_{\\mathrm{int}}^\\infty$。\n6.  验证分解：检查 $\\Delta E_{\\mathrm{int}}^{\\mathrm{tot}} = \\delta_{\\mathrm{BSSE}} + \\delta_{\\mathrm{BSIE}}$ 是否在标准浮点公差范围内成立。这为计算提供了一致性检查。\n\n此过程将应用于每个测试用例，以得出所需的数值结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of decomposing the total basis error in an interaction\n    energy into Basis Set Incompleteness Error (BSIE) and Basis Set\n    Superposition Error (BSSE).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains:\n    # (E_AB_dimer, E_A_mono, E_B_mono, E_A_ghost, E_B_ghost, E_int_inf)\n    # All values are in Hartree.\n    test_cases = [\n        # Test case 1: moderate Basis Set Superposition Error\n        (\n            -152.345678,  # E_AB_dimer\n            -76.123456,   # E_A_mono\n            -76.200000,   # E_B_mono\n            -76.130000,   # E_A_ghost\n            -76.205000,   # E_B_ghost\n            -0.012000     # E_int_inf\n        ),\n        # Test case 2: near-complete basis, negligible Basis Set Superposition Error\n        (\n            -20.000010,   # E_AB_dimer\n            -10.000000,   # E_A_mono\n            -10.000000,   # E_B_mono\n            -10.000001,   # E_A_ghost\n            -10.000001,   # E_B_ghost\n            -0.000008     # E_int_inf\n        ),\n        # Test case 3: severe Basis Set Superposition Error with minimal basis\n        (\n            -30.080000,   # E_AB_dimer\n            -15.000000,   # E_A_mono\n            -15.000000,   # E_B_mono\n            -15.050000,   # E_A_ghost\n            -15.020000,   # E_B_ghost\n            -0.015000     # E_int_inf\n        ),\n        # Test case 4: asymmetric Basis Set Superposition Error, fragment A only\n        (\n            -21.120000,   # E_AB_dimer\n            -12.345600,   # E_A_mono\n            -8.765400,    # E_B_mono\n            -12.349000,   # E_A_ghost\n            -8.765400,    # E_B_ghost\n            -0.006000     # E_int_inf\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        E_AB_dimer, E_A_mono, E_B_mono, E_A_ghost, E_B_ghost, E_int_inf = case\n\n        # 1. Calculate the uncorrected interaction energy in the finite basis (E_int^B)\n        # E_int^B = E_AB^(B_AB) - E_A^(B_A) - E_B^(B_B)\n        e_int_b = E_AB_dimer - E_A_mono - E_B_mono\n\n        # 2. Calculate the counterpoise-corrected interaction energy (E_int^CP)\n        # E_int^CP = E_AB^(B_AB) - E_A^(B_AB) - E_B^(B_AB)\n        e_int_cp = E_AB_dimer - E_A_ghost - E_B_ghost\n\n        # 3. Calculate the total interaction energy error (Delta E_int^tot)\n        # Delta E_int^tot = E_int^B - E_int^inf\n        total_error = e_int_b - E_int_inf\n\n        # 4. Calculate the Basis Set Superposition Error (BSSE) contribution to the total error.\n        # This is the artificial stabilization from monomer basis functions borrowing.\n        # delta_BSSE = E_int^B - E_int^CP = (E_A^(B_AB) - E_A^(B_A)) + (E_B^(B_AB) - E_B^(B_B))\n        # Note: This contribution is negative, representing an artificial over-binding.\n        bsse_contribution = (E_A_ghost - E_A_mono) + (E_B_ghost - E_B_mono)\n\n        # 5. Calculate the Basis Set Incompleteness Error (BSIE) contribution.\n        # This is the remaining error in the CP-corrected energy.\n        # delta_BSIE = E_int^CP - E_int^inf\n        bsie_contribution = e_int_cp - E_int_inf\n\n        # 6. Perform a consistency check to verify the decomposition.\n        # The decomposition is Delta E_int^tot = delta_BSSE + delta_BSIE.\n        # We use np.isclose for robust floating-point comparison.\n        is_consistent = np.isclose(total_error, bsse_contribution + bsie_contribution)\n\n        # Append the results for the current test case.\n        # Order: [BSSE, BSIE, TotalError, ConsistencyBoolean]\n        results.append([bsse_contribution, bsie_contribution, total_error, is_consistent])\n\n    # Convert the boolean to lowercase string 'true'/'false' for the output.\n    # Then join all results into the final formatted string.\n    formatted_results = []\n    for res in results:\n        # Convert NumPy boolean to Python boolean for json-like string representation\n        bool_val = bool(res[3])\n        formatted_res = f\"[{res[0]},{res[1]},{res[2]},{str(bool_val).lower()}]\"\n        formatted_results.append(formatted_res)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "为了获得准确的相互作用能，研究者通常采用两种策略：通过对位 (CP) 校正来消除基组叠加误差（BSSE），或者通过外推到完备基组极限（CBS）来消除整个基组不完备性。本练习将引导您直接比较这两种方法的有效性 。您将通过一个具体的吸附能计算案例，分析在何种情况下CP校正会过度或不足地校正BSSE，从而培养对计算结果进行批判性评估的能力。",
            "id": "3434543",
            "problem": "要求您以数学上精确且算法上可测试的方式，形式化并实现对位校正（counterpoise-corrected）吸附能与完备基组极限（complete-basis-set limits）之间的比较。请从以下适用于计算材料科学的基本原理出发：Born-Oppenheimer电子能量相对于波函数是变分的，而基组的截断会引入系统性的基组不完备误差。对于一个基数序列的高斯原子中心轨道基组，其整数尺寸参数$M$递增，总能量$E(M)$的渐近收敛行为可以通过经过充分检验的经验公式$E(M)=E_{\\infty}+A M^{-p}$来建模。其中，$E_{\\infty}$是完备基组极限，$A$是依赖于体系的待定系数，$p0$是表征收敛速率的指数。对于束缚态，该行为与变分原理一致，因为$E(M)\\ge E_{\\infty}$。\n\n需使用的定义：\n- 在给定基数$M$下的吸附能定义为 $E_{\\text{ads}}(M)=E_{\\text{AB}}(M)-E_{\\text{A}}(M)-E_{\\text{B}}(M)$，其中$E_{\\text{AB}}$是吸附质-表面体系的总能量，$E_{\\text{A}}$是表面碎片的能量，$E_{\\text{B}}$是吸附质碎片的能量。\n- Boys-Bernardi对位校正（counterpoise, CP）通过在另一碎片基函数（鬼函数）存在下计算单体碎片的能量，来减小基组重叠误差。在固定的$M$下，经对位校正的吸附能为 $E_{\\text{ads}}^{\\text{CP}}(M)=E_{\\text{AB}}(M)-E_{\\text{A}}^{\\text{ghost}}(M)-E_{\\text{B}}^{\\text{ghost}}(M)$，其中 $E_{\\text{A}}^{\\text{ghost}}(M)$ 和 $E_{\\text{B}}^{\\text{ghost}}(M)$ 是在二聚体基组中（不包含另一碎片的电子）计算得到的单体能量。\n- 完备基组（CBS）吸附能为 $E_{\\text{ads}}^{\\text{CBS}}=E_{\\text{AB},\\infty}-E_{\\text{A},\\infty}-E_{\\text{B},\\infty}$，其中$E_{X,\\infty}$表示体系$X\\in\\{\\text{AB},\\text{A},\\text{B}\\}$的CBS极限。\n\n您的任务：\n1. 给定两个基数$M_1$和$M_2$以及它们各自对应于$\\text{AB}$、$\\text{A}$和$\\text{B}$的总能量$E(M_1)$和$E(M_2)$，请仅使用经验渐近公式$E(M)=E_{\\infty}+A M^{-p}$、变分性质以及对两个方程的代数处理，从第一性原理出发推导如何消除未知待定系数$A$并推断出CBS极限$E_{\\infty}$。您不能依赖任何快捷公式；相反，必须阐明分离出$E_{\\infty}$所需的逻辑步骤。\n2. 针对每个测试用例，实现一个程序，使用$M_1$和$M_2$下的两个能量值以及给定的指数$p$来外推$E_{\\text{AB},\\infty}$、$E_{\\text{A},\\infty}$和$E_{\\text{B},\\infty}$，然后计算$E_{\\text{ads}}^{\\text{CBS}}$。\n3. 使用在$M_2$下提供的鬼基组单体能量，计算$E_{\\text{ads}}^{\\text{CP}}(M_2)$并评估差值$\\Delta E_{\\text{ads}}=E_{\\text{ads}}^{\\text{CP}}(M_2)-E_{\\text{ads}}^{\\text{CBS}}$。将$\\Delta E_{\\text{ads}}$的符号解释为一个区间图：如果$\\Delta E_{\\text{ads}}0$，则对位校正过校（对于典型的放热吸附，校正后的吸附能负值小于CBS极限）；如果$\\Delta E_{\\text{ads}}0$，则对位校正欠校（校正后的吸附能负值大于CBS极限）；如果$\\Delta E_{\\text{ads}}=0$，则校正是平衡的。\n4. 所有能量必须以电子伏特（eV）为单位进行处理和报告。您的程序必须生成单行最终输出，其中包含测试套件的所有$\\Delta E_{\\text{ads}}$值，形式为逗号分隔的列表，并用方括号括起，保留六位小数，例如$[x_1,x_2,x_3,x_4]$。\n\n测试套件（每个用例提供$p$、$M_1$、$M_2$、在$M_1$和$M_2$下$\\text{AB}$、$\\text{A}$、$\\text{B}$的两点能量，以及在$M_2$下的鬼基组单体能量；所有能量单位均为eV）：\n\n- 用例1（典型收敛，轻度过校）：\n  - $p=4$, $M_1=3$, $M_2=4$,\n  - $E_{\\text{AB}}(M_1)=-21.117037037037$, $E_{\\text{AB}}(M_2)=-21.1190625$,\n  - $E_{\\text{A}}(M_1)=-19.796296296296$, $E_{\\text{A}}(M_2)=-19.798828125$,\n  - $E_{\\text{B}}(M_1)=-1.249259259259$, $E_{\\text{B}}(M_2)=-1.249765625$,\n  - $E_{\\text{A}}^{\\text{ghost}}(M_2)=-19.799628125$, $E_{\\text{B}}^{\\text{ghost}}(M_2)=-1.249965625$。\n\n- 用例2（典型收敛，轻度欠校）：\n  - $p=4$, $M_1=3$, $M_2=4$,\n  - $E_{\\text{AB}}(M_1)=-15.198148148148$, $E_{\\text{AB}}(M_2)=-15.1994140625$,\n  - $E_{\\text{A}}(M_1)=-13.997777777778$, $E_{\\text{A}}(M_2)=-13.999296875$,\n  - $E_{\\text{B}}(M_1)=-1.11962962963, $E_{\\text{B}}(M_2)=-1.1198828125$,\n  - $E_{\\text{A}}^{\\text{ghost}}(M_2)=-13.999396875$, $E_{\\text{B}}^{\\text{ghost}}(M_2)=-1.1199028125$。\n\n- 用例3（边界情况，接近平衡的校正）：\n  - $p=5$, $M_1=3$, $M_2=5$,\n  - $E_{\\text{AB}}(M_1)=-7.319670781893$, $E_{\\text{AB}}(M_2)=-7.3199744$,\n  - $E_{\\text{A}}(M_1)=-6.19975308642$, $E_{\\text{A}}(M_2)=-6.1999808$,\n  - $E_{\\text{B}}(M_1)=-1.09991736227, $E_{\\text{B}}(M_2)=-1.0999936$,\n  - $E_{\\text{A}}^{\\text{ghost}}(M_2)=-6.1999958$, $E_{\\text{B}}^{\\text{ghost}}(M_2)=-1.0999976$。\n\n- 用例4（边缘情况，二聚体的表观收敛速度快于单体，导致欠校）：\n  - $p=3$, $M_1=2$, $M_2=3$,\n  - $E_{\\text{AB}}(M_1)=-34.95$, $E_{\\text{AB}}(M_2)=-34.9851851852$,\n  - $E_{\\text{A}}(M_1)=-33.425$, $E_{\\text{A}}(M_2)=-33.4777777778$,\n  - $E_{\\text{B}}(M_1)=-1.3625$, $E_{\\text{B}}(M_2)=-1.3888888889$,\n  - $E_{\\text{A}}^{\\text{ghost}}(M_2)=-33.4817778$, $E_{\\text{B}}^{\\text{ghost}}(M_2)=-1.3894889$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，其中每个$\\Delta E_{\\text{ads}}$值以eV为单位，四舍五入到六位小数，例如$[x_1,x_2,x_3,x_4]$。",
            "solution": "该问题是有效的，因为它科学地植根于计算材料科学的原理，问题陈述清晰，提供了所有必要的数据和定义，并且表述客观。它提出了一个涉及基组收敛、完备基组（CBS）外推以及基组重叠误差（BSSE）分析的标准且相关的任务。因此，我们可以着手解决。\n\n问题的核心是分析电子能量随基组大小变化的收敛性。对于一个体系，使用基数为$M$的基组计算得到的总能量$E(M)$，可以通过以下经验渐近公式进行建模：\n$$E(M) = E_{\\infty} + A M^{-p}$$\n在此方程中，$E_{\\infty}$代表完备基组（CBS）极限能量，即使用无限大基组所能获得的理论能量。$A$是一个与体系相关的待定系数，$p$是表征收敛速率的指数。量子力学的变分原理是该模型的基础，它确保对于基态，计算出的能量始终是真实能量的一个上界，即$E(M) \\ge E_{\\infty}$。\n\n**1. 完备基组（CBS）外推公式的推导**\n\n我们的任务是，利用分别在基数$M_1$和$M_2$的基组下进行的两次数值计算得到的能量$E(M_1)$和$E(M_2)$，以及已知的指数$p$，推导出$E_{\\infty}$的表达式。\n\n这两次计算提供了一个包含两个未知数$E_{\\infty}$和$A$的方程组：\n$$E(M_1) = E_{\\infty} + A M_1^{-p} \\quad (1)$$\n$$E(M_2) = E_{\\infty} + A M_2^{-p} \\quad (2)$$\n\n我们的目标是消去未知的待定系数$A$并求解$E_{\\infty}$。我们可以通过首先重新整理两个方程，以分离出含$A$的项来实现这一目标：\n由方程(1)得：\n$$A M_1^{-p} = E(M_1) - E_{\\infty}$$\n$$A = (E(M_1) - E_{\\infty}) M_1^p \\quad (3)$$\n\n由方程(2)得：\n$$A M_2^{-p} = E(M_2) - E_{\\infty}$$\n$$A = (E(M_2) - E_{\\infty}) M_2^p \\quad (4)$$\n\n由于表达式(3)和(4)都等于$A$，我们可以令它们相等：\n$$(E(M_1) - E_{\\infty}) M_1^p = (E(M_2) - E_{\\infty}) M_2^p$$\n\n接下来，我们展开各项并重新整理方程，将包含$E_{\\infty}$的项归类到一起：\n$$E(M_1) M_1^p - E_{\\infty} M_1^p = E(M_2) M_2^p - E_{\\infty} M_2^p$$\n\n将所有包含$E_{\\infty}$的项移到等式左边，所有其他项移到等式右边，得到：\n$$E_{\\infty} M_2^p - E_{\\infty} M_1^p = E(M_2) M_2^p - E(M_1) M_1^p$$\n\n然后我们可以提出公因子$E_{\\infty}$：\n$$E_{\\infty} (M_2^p - M_1^p) = E(M_2) M_2^p - E(M_1) M_1^p$$\n\n最后，假设$M_1 \\neq M_2$，我们可以通过除以因子$(M_2^p - M_1^p)$来分离出$E_{\\infty}$：\n$$E_{\\infty} = \\frac{E(M_2) M_2^p - E(M_1) M_1^p}{M_2^p - M_1^p}$$\n这就是用于从两次有限基组计算中估算CBS极限能量的、广为接受的两点外推公式。\n\n**2. 计算流程**\n\n总体任务是为每个测试用例计算$\\Delta E_{\\text{ads}} = E_{\\text{ads}}^{\\text{CP}}(M_2) - E_{\\text{ads}}^{\\text{CBS}}$。这涉及计算两种不同的吸附能：在基组大小为$M_2$时的对位校正能量，以及估算的CBS极限能量。\n\n首先，我们计算吸附能的CBS极限值$E_{\\text{ads}}^{\\text{CBS}}$。根据其定义：\n$$E_{\\text{ads}}^{\\text{CBS}} = E_{\\text{AB},\\infty} - E_{\\text{A},\\infty} - E_{\\text{B},\\infty}$$\n对于每个物种$X \\in \\{\\text{AB}, \\text{A}, \\text{B}\\}$，我们采用推导出的外推公式来确定其CBS极限能量$E_{X,\\infty}$：\n$$E_{X,\\infty} = \\frac{E_X(M_2) M_2^p - E_X(M_1) M_1^p}{M_2^p - M_1^p}$$\n此计算需要能量值$E_X(M_1)$和$E_X(M_2)$、基数$M_1$和$M_2$以及指数$p$，所有这些都在每个测试用例中给出。\n\n其次，我们在较大的基组水平$M_2$上计算经对位校正的吸附能$E_{\\text{ads}}^{\\text{CP}}(M_2)$。其定义如下：\n$$E_{\\text{ads}}^{\\text{CP}}(M_2) = E_{\\text{AB}}(M_2) - E_{\\text{A}}^{\\text{ghost}}(M_2) - E_{\\text{B}}^{\\text{ghost}}(M_2)$$\n右侧所需的所有能量——$E_{\\text{AB}}(M_2)$、$E_{\\text{A}}^{\\text{ghost}}(M_2)$和$E_{\\text{B}}^{\\text{ghost}}(M_2)$——均在每个测试用例的问题描述中直接提供。“鬼”基组计算是一种标准技术（Boys-Bernardi对位校正），旨在减小基组重叠误差（BSSE）。BSSE是由于在二聚体计算中，单体相互“借用”对方的基函数而产生的一种对吸附质-表面复合物的人为稳定化效应。\n\n最后，我们计算差值$\\Delta E_{\\text{ads}}$：\n$$\\Delta E_{\\text{ads}} = E_{\\text{ads}}^{\\text{CP}}(M_2) - E_{\\text{ads}}^{\\text{CBS}}$$\n$\\Delta E_{\\text{ads}}$的符号可以揭示在$M_2$水平上的对位校正相对于真实的CBS极限是过校还是欠校了BSSE。\n- 如果$\\Delta E_{\\text{ads}}  0$，则$E_{\\text{ads}}^{\\text{CP}}(M_2)  E_{\\text{ads}}^{\\text{CBS}}$。由于吸附能通常为负值，这意味着校正后的能量负值较小（结合较弱），低于CBS极限，这种情况被称为“过校”。\n- 如果$\\Delta E_{\\text{ads}}  0$，则$E_{\\text{ads}}^{\\text{CP}}(M_2)  E_{\\text{ads}}^{\\text{CBS}}$。校正后的能量负值较大（结合更强），高于CBS极限，这种情况被称为“欠校”。\n- 如果$\\Delta E_{\\text{ads}} = 0$，则校正完美地平衡了$M_2$水平上的残余基组不完备误差。\n\n我们将实现一个算法，将此完整流程应用于每个测试用例，计算$\\Delta E_{\\text{ads}}$，将结果四舍五入至六位小数，并将所有结果格式化为指定的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the difference between counterpoise-corrected and CBS-extrapolated\n    adsorption energies for a given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: p=4, M1=3, M2=4\n        {\n            'p': 4, 'M1': 3, 'M2': 4,\n            'E_AB_pts': (-21.117037037037, -21.1190625),\n            'E_A_pts': (-19.796296296296, -19.798828125),\n            'E_B_pts': (-1.249259259259, -1.249765625),\n            'E_A_ghost_M2': -19.799628125,\n            'E_B_ghost_M2': -1.249965625\n        },\n        # Case 2: p=4, M1=3, M2=4\n        {\n            'p': 4, 'M1': 3, 'M2': 4,\n            'E_AB_pts': (-15.198148148148, -15.1994140625),\n            'E_A_pts': (-13.997777777778, -13.999296875),\n            'E_B_pts': (-1.11962962963, -1.1198828125),\n            'E_A_ghost_M2': -13.999396875,\n            'E_B_ghost_M2': -1.1199028125\n        },\n        # Case 3: p=5, M1=3, M2=5\n        {\n            'p': 5, 'M1': 3, 'M2': 5,\n            'E_AB_pts': (-7.319670781893, -7.3199744),\n            'E_A_pts': (-6.19975308642, -6.1999808),\n            'E_B_pts': (-1.09991736227, -1.0999936),\n            'E_A_ghost_M2': -6.1999958,\n            'E_B_ghost_M2': -1.0999976\n        },\n        # Case 4: p=3, M1=2, M2=3\n        {\n            'p': 3, 'M1': 2, 'M2': 3,\n            'E_AB_pts': (-34.95, -34.9851851852),\n            'E_A_pts': (-33.425, -33.4777777778),\n            'E_B_pts': (-1.3625, -1.3888888889),\n            'E_A_ghost_M2': -33.4817778,\n            'E_B_ghost_M2': -1.3894889\n        }\n    ]\n\n    def extrapolate_cbs(e1, m1, e2, m2, p):\n        \"\"\"\n        Calculates the CBS limit energy using the two-point extrapolation formula.\n        E_inf = (E(M2)*M2^p - E(M1)*M1^p) / (M2^p - M1^p)\n        \"\"\"\n        m1_p = np.power(float(m1), float(p))\n        m2_p = np.power(float(m2), float(p))\n        numerator = e2 * m2_p - e1 * m1_p\n        denominator = m2_p - m1_p\n        return numerator / denominator\n\n    results = []\n    for case in test_cases:\n        p = case['p']\n        m1 = case['M1']\n        m2 = case['M2']\n\n        # Unpack energy points\n        e_ab_m1, e_ab_m2 = case['E_AB_pts']\n        e_a_m1, e_a_m2 = case['E_A_pts']\n        e_b_m1, e_b_m2 = case['E_B_pts']\n\n        # 1. Extrapolate to find CBS limit for each component\n        e_ab_inf = extrapolate_cbs(e_ab_m1, m1, e_ab_m2, m2, p)\n        e_a_inf = extrapolate_cbs(e_a_m1, m1, e_a_m2, m2, p)\n        e_b_inf = extrapolate_cbs(e_b_m1, m1, e_b_m2, m2, p)\n\n        # 2. Compute CBS adsorption energy\n        # E_ads_CBS = E_AB_inf - E_A_inf - E_B_inf\n        e_ads_cbs = e_ab_inf - e_a_inf - e_b_inf\n\n        # 3. Compute counterpoise-corrected adsorption energy at M2\n        # E_ads_CP(M2) = E_AB(M2) - E_A_ghost(M2) - E_B_ghost(M2)\n        e_a_ghost_m2 = case['E_A_ghost_M2']\n        e_b_ghost_m2 = case['E_B_ghost_M2']\n        e_ads_cp_m2 = e_ab_m2 - e_a_ghost_m2 - e_b_ghost_m2\n\n        # 4. Compute the difference Delta_E_ads\n        # Delta_E_ads = E_ads_CP(M2) - E_ads_CBS\n        delta_e_ads = e_ads_cp_m2 - e_ads_cbs\n        results.append(delta_e_ads)\n\n    # Final print statement in the exact required format.\n    # The output format string \"{:.6f}\" handles rounding to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "基组叠加误差不仅存在于分子二聚体中，在周期性固态体系的计算中同样是一个重要问题，尤其是在研究点缺陷时。本练习将模拟一个超胞计算中的缺陷形成能，并量化BSSE如何随超胞尺寸的变化而衰减 。通过对BSSE进行标度分析，您将学习到一种评估和管理周期性计算中有限尺寸效应的强大方法，这是材料科学研究中的一项关键技能。",
            "id": "3434554",
            "problem": "考虑一个在晶体固体中使用原子中心基函数对点缺陷进行的周期性超胞计算。基组不完备性会导致基组重叠误差（BSSE），当分子碎片或格点相互借用基函数时，这会使计算出的总能量产生偏差。在适用于周期性固体的对位校正方法中，引入了鬼基函数（放置在没有相关电子或原子核的晶格位置上的基函数）来量化这种偏差。缺陷形成能 $E_f$ 由总能量差定义，而BSSE通过比较在缺陷位置放置和不放置鬼基函数时计算出的 $E_f$ 来分离。对于局域化的缺陷态，由于局域区域的空间限制以及与越来越远的晶格位置上的基函数重叠逐渐减小，BSSE的贡献预计会随着超胞线性尺寸 $L$ 的增大而衰减。\n\n从形成能是总能量之差的定义出发，并基于线性尺寸标度关系通过超胞中可用于基组借用的空间域引入的原理，您必须编写一个程序，对每个测试用例执行以下步骤：\n\n1. 对每个超胞尺寸 $L$，通过计算不带鬼基函数的形成能与带鬼基函数的形成能之差，来计算BSSE对缺陷形成能的贡献，即 $\\Delta E_f^{\\text{BSSE}}(L) = E_f^{\\text{no-ghost}}(L) - E_f^{\\text{ghost}}(L)$。在分析中使用绝对值 $|\\Delta E_f^{\\text{BSSE}}(L)|$。\n2. 将 $|\\Delta E_f^{\\text{BSSE}}(L)|$ 的标度关系建模为幂律 $c L^{-\\alpha}$，这可能源于缺陷态的局域化效应和基组借用随距离减小的效应。\n3. 使用与幂律模型一致的、基于原理的变换，根据所提供的关于 $L$ 的数据估算标度指数 $\\alpha$，并报告每个测试用例得到的 $\\alpha$。\n4. 所有提供的能量都必须以电子伏特 (eV) 为单位处理。超胞尺寸参数 $L$ 是一个无量纲的线性复制因子（沿一个晶格矢量方向的原胞数量）。\n5. 您的程序必须生成单行输出，其中包含所有测试用例的估算指数，格式为方括号内以逗号分隔的列表，每个浮点数四舍五入到三位小数，例如：“[$\\alpha_1$,$\\alpha_2$,$\\alpha_3$]”。\n\n使用以下测试套件，每个套件包含一组 $L$ 值以及对应的带和不带鬼基函数的形成能：\n\n- 测试用例 A（具有三维衰减的局域化缺陷）：\n  - 超胞尺寸：$L \\in \\{2,3,4,5,6\\}$。\n  - 带鬼基函数的形成能：$E_f^{\\text{ghost}}(L) = 3.250 \\text{ eV}$，对所有 $L$ 均如此。\n  - 不带鬼基函数的形成能：$E_f^{\\text{no-ghost}}(2) = 3.2625 \\text{ eV}$，$E_f^{\\text{no-ghost}}(3) = 3.2537037 \\text{ eV}$，$E_f^{\\text{no-ghost}}(4) = 3.2515625 \\text{ eV}$，$E_f^{\\text{no-ghost}}(5) = 3.2508 \\text{ eV}$，$E_f^{\\text{no-ghost}}(6) = 3.250462962963 \\text{ eV}$。\n\n- 测试用例 B（扩展弹性场导致的较缓衰减特性）：\n  - 超胞尺寸：$L \\in \\{4,8,12,16,20\\}$。\n  - 带鬼基函数的形成能：$E_f^{\\text{ghost}}(L) = 5.100 \\text{ eV}$，对所有 $L$ 均如此。\n  - 不带鬼基函数的形成能：$E_f^{\\text{no-ghost}}(4) = 5.1125 \\text{ eV}$，$E_f^{\\text{no-ghost}}(8) = 5.10625 \\text{ eV}$，$E_f^{\\text{no-ghost}}(12) = 5.104166666667 \\text{ eV}$，$E_f^{\\text{no-ghost}}(16) = 5.103125 \\text{ eV}$，$E_f^{\\text{no-ghost}}(20) = 5.1025 \\text{ eV}$。\n\n- 测试用例 C（由于细微的基组干涉效应导致BSSE值很小且符号交替；分析中使用绝对值）：\n  - 超胞尺寸：$L \\in \\{3,5,7,9,11\\}$。\n  - 带鬼基函数的形成能：$E_f^{\\text{ghost}}(L) = 2.000 \\text{ eV}$，对所有 $L$ 均如此。\n  - 不带鬼基函数的形成能：$E_f^{\\text{no-ghost}}(3) = 2.00024691358 \\text{ eV}$，$E_f^{\\text{no-ghost}}(5) = 1.999968 \\text{ eV}$，$E_f^{\\text{no-ghost}}(7) = 2.00000832903 \\text{ eV}$，$E_f^{\\text{no-ghost}}(9) = 1.999996952 \\text{ eV}$，$E_f^{\\text{no-ghost}}(11) = 2.000001366 \\text{ eV}$。\n\n算法约束：\n\n- 将任何小于 $10^{-12} \\text{ eV}$ 的 $|\\Delta E_f^{\\text{BSSE}}(L)|$ 值视为数值上可忽略不计，并将其从标度分析中排除，以避免对零取对数。\n- 使用不依赖于随机选择的确定性方法。\n- 以要求的单行格式表示最终输出。报告的每个 $\\alpha$ 都必须是四舍五入到三位小数的浮点数。\n\n您的程序应生成一行输出，其中包含一个方括号括起来的、以逗号分隔的结果列表（例如：“[$\\alpha_{\\text{A}}$,$\\alpha_{\\text{B}}$,$\\alpha_{\\text{C}}$]”）。",
            "solution": "该问题被评估为有效。它在科学上基于计算材料科学的原理，特别是关于周期性固体量子化学计算中基组不完备性的问题。该问题提法明确、客观，并提供了所有必要的数据和约束条件，以得出一个唯一的、有意义的解。\n\n问题的核心是确定基组重叠误差（BSSE）作为超胞线性尺寸 $L$ 的函数的标度指数 $\\alpha$。BSSE通过幂律建模：\n$$\n|\\Delta E_f^{\\text{BSSE}}(L)| = c L^{-\\alpha}\n$$\n其中 $|\\Delta E_f^{\\text{BSSE}}(L)|$ 是BSSE对缺陷形成能贡献的大小，$c$ 是一个常数，$\\alpha$ 是待确定的标度指数。\n\n为了求出 $\\alpha$，我们可以通过对等式两边取自然对数来线性化这个幂律关系：\n$$\n\\ln\\left(|\\Delta E_f^{\\text{BSSE}}(L)|\\right) = \\ln\\left(c L^{-\\alpha}\\right)\n$$\n利用对数的性质，该表达式可简化为：\n$$\n\\ln\\left(|\\Delta E_f^{\\text{BSSE}}(L)|\\right) = \\ln(c) - \\alpha \\ln(L)\n$$\n该方程是直线形式 $y = mx + b$，其中：\n- 因变量是 $y = \\ln(|\\Delta E_f^{\\text{BSSE}}(L)|)$。\n- 自变量是 $x = \\ln(L)$。\n- 直线的斜率是 $m = -\\alpha$。\n- y轴截距是 $b = \\ln(c)$。\n\n因此，可以通过对数据点 $(\\ln(L), \\ln(|\\Delta E_f^{\\text{BSSE}}(L)|))$ 进行线性回归，并根据得到的斜率 $m$ 计算出标度指数 $\\alpha = -m$。\n\n每个测试用例的步骤如下：\n\n1.  **计算BSSE贡献**：对于给定测试用例中的每个超胞尺寸 $L_i$，使用提供的数据计算BSSE对形成能的贡献：\n    $$\n    \\Delta E_f^{\\text{BSSE}}(L_i) = E_f^{\\text{no-ghost}}(L_i) - E_f^{\\text{ghost}}(L_i)\n    $$\n\n2.  **准备回归数据**：\n    - 取BSSE的绝对值，$y'_i = |\\Delta E_f^{\\text{BSSE}}(L_i)|$。\n    - 根据问题的约束，筛选掉任何 $y'_i  10^{-12} \\text{ eV}$ 的数据对 $(L_i, y'_i)$。\n    - 通过取自然对数来转换剩余的数据点，以创建用于线性回归的数据集：$x_i = \\ln(L_i)$ 和 $y_i = \\ln(y'_i)$。\n\n3.  **执行线性回归**：使用标准数值方法找到数据点 $(x_i, y_i)$ 的最佳拟合线的斜率 $m$。`numpy.polyfit` 函数适合此任务，可用于拟合1次多项式。它返回直线 $y = mx + b$ 的系数 $[m, b]$。\n\n4.  **计算指数**：然后通过取斜率的负值得到标度指数：\n    $$\n    \\alpha = -m\n    $$\n\n此过程将应用于所提供的三个测试用例中的每一个。\n\n**测试用例 A：具有三维衰减的局域化缺陷**\n- 超胞尺寸：$L \\in \\{2, 3, 4, 5, 6\\}$。\n- $E_f^{\\text{ghost}}(L) = 3.250 \\text{ eV}$。\n- 计算 $|\\Delta E_f^{\\text{BSSE}}(L)|$ 的值，例如 $|\\Delta E_f^{\\text{BSSE}}(2)| = |3.2625 - 3.250| = 0.0125 \\text{ eV}$， $|\\Delta E_f^{\\text{BSSE}}(3)| = |3.2537037 - 3.250| \\approx 0.0037037 \\text{ eV}$，依此类推。所有计算值均大于 $10^{-12} \\text{ eV}$，并包含在拟合中。对 $(\\ln(L), \\ln(|\\Delta E_f^{\\text{BSSE}}(L)|))$ 执行线性回归以找到斜率，并计算出 $\\alpha_A$。\n\n**测试用例 B：扩展弹性场导致的较缓衰减特性**\n- 超胞尺寸：$L \\in \\{4, 8, 12, 16, 20\\}$。\n- $E_f^{\\text{ghost}}(L) = 5.100 \\text{ eV}$。\n- 计算 $|\\Delta E_f^{\\text{BSSE}}(L)|$ 的值，例如 $|\\Delta E_f^{\\text{BSSE}}(4)| = |5.1125 - 5.100| = 0.0125 \\text{ eV}$。所有值均大于 $10^{-12} \\text{ eV}$。执行线性回归以找到斜率，并计算出 $\\alpha_B$。\n\n**测试用例 C：BSSE值很小且符号交替**\n- 超胞尺寸：$L \\in \\{3, 5, 7, 9, 11\\}$。\n- $E_f^{\\text{ghost}}(L) = 2.000 \\text{ eV}$。\n- 计算 $|\\Delta E_f^{\\text{BSSE}}(L)|$ 的值，例如 $|\\Delta E_f^{\\text{BSSE}}(3)| = |2.00024691358 - 2.000| \\approx 2.47 \\times 10^{-4} \\text{ eV}$ 以及 $|\\Delta E_f^{\\text{BSSE}}(5)| = |1.999968 - 2.000| = 3.2 \\times 10^{-5} \\text{ eV}$。所有绝对值均大于 $10^{-12} \\text{ eV}$。使用线性回归找到斜率，并计算出 $\\alpha_C$。\n\n最终输出将编译计算出的指数 $[\\alpha_A, \\alpha_B, \\alpha_C]$，并按要求格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the scaling exponent alpha for BSSE decay in supercell calculations.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"L\": np.array([2, 3, 4, 5, 6]),\n            \"E_ghost\": np.array([3.250, 3.250, 3.250, 3.250, 3.250]),\n            \"E_noghost\": np.array([3.2625, 3.2537037, 3.2515625, 3.2508, 3.250462962963])\n        },\n        {\n            \"name\": \"Case B\",\n            \"L\": np.array([4, 8, 12, 16, 20]),\n            \"E_ghost\": np.array([5.100, 5.100, 5.100, 5.100, 5.100]),\n            \"E_noghost\": np.array([5.1125, 5.10625, 5.104166666667, 5.103125, 5.1025])\n        },\n        {\n            \"name\": \"Case C\",\n            \"L\": np.array([3, 5, 7, 9, 11]),\n            \"E_ghost\": np.array([2.000, 2.000, 2.000, 2.000, 2.000]),\n            \"E_noghost\": np.array([2.00024691358, 1.999968, 2.00000832903, 1.999996952, 2.000001366])\n        }\n    ]\n\n    results = []\n    \n    # Numerical tolerance for filtering data\n    tolerance = 1e-12\n\n    for case in test_cases:\n        # Step 1: Compute the BSSE contribution and take its absolute value\n        delta_E_bsse = np.abs(case[\"E_noghost\"] - case[\"E_ghost\"])\n        L_vals = case[\"L\"]\n\n        # Step 2: Filter out numerically negligible values\n        mask = delta_E_bsse >= tolerance\n        \n        filtered_L = L_vals[mask]\n        filtered_delta_E = delta_E_bsse[mask]\n\n        # Prepare for linear regression by taking logarithms\n        # x = ln(L), y = ln(|delta_E|)\n        log_L = np.log(filtered_L)\n        log_delta_E = np.log(filtered_delta_E)\n\n        # Step 3: Perform linear regression to find the slope m\n        # The model is ln(|delta_E|) = ln(c) - alpha * ln(L)\n        # This is a line y = mx + b, where y = ln(|delta_E|), x = ln(L), and slope m = -alpha.\n        # np.polyfit(x, y, 1) returns [slope, intercept]\n        slope, _ = np.polyfit(log_L, log_delta_E, 1)\n\n        # Step 4: Calculate the scaling exponent alpha\n        alpha = -slope\n        results.append(alpha)\n\n    # Final print statement in the exact required format.\n    # Format each float to three decimal places.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}