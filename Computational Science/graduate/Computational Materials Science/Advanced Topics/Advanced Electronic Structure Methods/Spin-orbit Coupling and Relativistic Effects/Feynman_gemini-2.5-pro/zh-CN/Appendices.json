{
    "hands_on_practices": [
        {
            "introduction": "这项练习将演示如何从第一性原理出发构建紧束缚模型，这是凝聚态物理学中的一项基本技能。我们将为立方钙钛矿铱氧化物构建一个切合实际的哈密顿量——在这类材料中，强自旋轨道耦合效应催生了如$j_{\\mathrm{eff}}=1/2$莫特绝缘态等新奇现象。这项实践融合了轨道对称性、晶体场理论和在位$\\lambda\\,\\mathbf{L}\\cdot\\mathbf{S}$相互作用，并将它们整合到一个计算模型中，同时学习使用投影算符来分析其电子结构 。",
            "id": "3488731",
            "problem": "你需要为一个具有在位自旋轨道耦合 (SOC) 的立方钙钛矿铱氧化物的 $t_{2g}$ 轨道集构建并分析一个对称性约束的紧束缚模型。目标是提取 $j_{\\mathrm{eff}}=1/2$ 能带，并计算一个模拟与密度泛函理论 (DFT) 加 SOC 轨道投影算子进行比较的验证指标。你的最终答案必须是一个完整的、可运行的程序，该程序执行以下任务，为提供的一组参数值测试套件输出指定的指标，并遵循文末描述的输出格式。\n\n从以下具有物理依据的基础开始：\n\n- 相对论性 SOC 源于狄拉克方程，在非相对论极限下，对于中心势中的电子，它产生一个有效的在位 SOC 项 $H_{\\mathrm{SO}}=\\lambda\\,\\mathbf{L}\\cdot\\mathbf{S}$，其中 $\\lambda$ 是一个包含径向信息的有效 SOC 参数（对于固体，这被视为一个唯象的在位参数），$\\mathbf{L}$ 是轨道角动量算符，$\\mathbf{S}$ 是自旋角动量算符。\n- 在理想的立方钙钛矿中，晶体场将 $d$ 轨道集分裂，使得 $t_{2g}$ 轨道 $\\{d_{xy},d_{yz},d_{zx}\\}$ 在费米能级附近占主导地位。在 $t_{2g}$ 子空间内，轨道角动量由一个有效的 $\\ell_{\\mathrm{eff}}=1$ 表示来描述，相对于通常的 $p$-轨道表示，其带有一个总体的负号。\n\n模型定义：\n\n1. 基矢。使用六维局域基矢 $\\{|d_{xy}\\uparrow\\rangle,|d_{yz}\\uparrow\\rangle,|d_{zx}\\uparrow\\rangle,|d_{xy}\\downarrow\\rangle,|d_{yz}\\downarrow\\rangle,|d_{zx}\\downarrow\\rangle\\}$，其中 $\\uparrow$ 和 $\\downarrow$ 表示自旋态。\n\n2. 在位 SOC。实现\n$$\nH_{\\mathrm{SO}}=\\lambda\\sum_{i=x,y,z}L_i\\otimes S_i,\n$$\n其中 $S_i=\\frac{1}{2}\\sigma_i$，$\\sigma_i$ 为泡利矩阵，$L_i$ 是限制在 $t_{2g}$ 子空间内的轨道角动量矩阵。在有序轨道基矢 $\\{|d_{xy}\\rangle,|d_{yz}\\rangle,|d_{zx}\\rangle\\}$ 中，使用\n$$\nL_x=\\begin{pmatrix}\n0  0  0\\\\\n0  0  i\\\\\n0  -i  0\n\\end{pmatrix},\\quad\nL_y=\\begin{pmatrix}\n0  0  -i\\\\\n0  0  0\\\\\ni  0  0\n\\end{pmatrix},\\quad\nL_z=\\begin{pmatrix}\n0  i  0\\\\\n-i  0  0\\\\\n0  0  0\n\\end{pmatrix},\n$$\n这些矩阵包含了适用于 $t_{2g}$ 子空间的有效负号。\n\n3. 对称性约束的跃迁。在一个晶格常数设为 1 的简单立方晶格上，沿着轨道对称性所允许的方向，施加振幅为 $t_\\pi$ 的最近邻跃迁：\n$$\n\\varepsilon_{xy}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_x + \\cos k_y\\right),\\quad\n\\varepsilon_{yz}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_y + \\cos k_z\\right),\\quad\n\\varepsilon_{zx}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_z + \\cos k_x\\right),\n$$\n其中 $\\mathbf{k}=(k_x,k_y,k_z)$ 是晶体动量，所有角度均以弧度表示。\n\n4. 晶体场畸变。包含一个在位晶体场项\n$$\nH_{\\mathrm{CF}}=\\mathrm{diag}(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})\\otimes I_2,\n$$\n其中 $I_2$ 是自旋空间中的 $2\\times 2$ 单位矩阵。对于四方畸变，一个常见的保持对称性的选择是 $\\Delta_{yz}=\\Delta_{zx}=-\\Delta_{xy}/2$，以确保在轨道子空间内迹为零。\n\n总哈密顿量为\n$$\nH(\\mathbf{k})=H_{\\mathrm{hop}}(\\mathbf{k})+H_{\\mathrm{SO}}+H_{\\mathrm{CF}},\n$$\n其中 $H_{\\mathrm{hop}}(\\mathbf{k})=\\mathrm{diag}(\\varepsilon_{xy}(\\mathbf{k}),\\varepsilon_{yz}(\\mathbf{k}),\\varepsilon_{zx}(\\mathbf{k}))\\otimes I_2$。\n\n$j_{\\mathrm{eff}}=1/2$ 能带的提取与验证指标：\n\n- 通过对角化在位 $H_{\\mathrm{SO}}$ 并选择对应于 $j_{\\mathrm{eff}}=1/2$ 二重态的两个本征矢量（对于 $\\lambda>0$ 和 $t_{2g}$ 符号约定，这是能量最高的一对），构建到 $j_{\\mathrm{eff}}=1/2$ 子空间的投影算子 $P_{1/2}$。将这两个归一化本征矢量的外积之和作为 $P_{1/2}$。该投影算子与 $\\mathbf{k}$ 无关。\n- 在立方布里渊区的高对称路径 $\\Gamma\\to X\\to M\\to R$ 上，取一组 $\\mathbf{k}$ 点，其中 $\\Gamma=(0,0,0)$，$X=(\\pi,0,0)$，$M=(\\pi,\\pi,0)$，$R=(\\pi,\\pi,\\pi)$，每段采样 5 个等间距点（包括端点），角度使用弧度。\n- 在每个采样的 $\\mathbf{k}$ 点，对角化 $H(\\mathbf{k})$ 以获得本征值和本征矢量。对每个能带 $n$，计算 $j_{\\mathrm{eff}}=1/2$ 投影权重 $w_n(\\mathbf{k})=\\langle \\psi_n(\\mathbf{k})|P_{1/2}|\\psi_n(\\mathbf{k})\\rangle$。将在每个 $\\mathbf{k}$ 点具有最大投影权重的两个能带识别为 $j_{\\mathrm{eff}}=1/2$ 能带。\n- 为每个参数集定义以下指标：\n  1. 在选定的能带和所有 $\\mathbf{k}$ 点上，$j_{\\mathrm{eff}}=1/2$ 的平均权重：\n  $$\n  \\overline{w}=\\frac{1}{2N_k}\\sum_{\\mathbf{k}}\\sum_{m=1}^{2}w_{m}^{\\mathrm{(sel)}}(\\mathbf{k}),\n  $$\n  其中 $N_k$ 是采样的 $\\mathbf{k}$ 点数，$w_m^{\\mathrm{(sel)}}$ 是两个选定能带的权重。\n  2. 一个模拟与 DFT+SOC 轨道投影算子进行比较的验证误差，计算为所选 $j_{\\mathrm{eff}}=1/2$ 能带与理想投影权重 1 的均方根偏差：\n  $$\n  \\mathrm{RMS}=\\sqrt{\\frac{1}{2N_k}\\sum_{\\mathbf{k}}\\sum_{m=1}^{2}\\left(1-w_{m}^{\\mathrm{(sel)}}(\\mathbf{k})\\right)^2}.\n  $$\n  3. 在 $\\Gamma$ 点，$j_{\\mathrm{eff}}=1/2$ 二重态与 $j_{\\mathrm{eff}}=3/2$ 四重态之间的能量分裂，定义为它们各自在 $\\Gamma$ 点的平均能带能量之差，\n  $$\n  \\Delta E_{\\Gamma}=\\frac{1}{2}\\sum_{m=1}^{2}E_{m}^{(1/2)}(\\Gamma)-\\frac{1}{4}\\sum_{n=1}^{4}E_{n}^{(3/2)}(\\Gamma),\n  $$\n  以电子伏特 (eV) 为单位。这里 $E_{m}^{(1/2)}(\\Gamma)$ 是在 $\\Gamma$ 点具有最大投影权重的两个能带的能量，$E_{n}^{(3/2)}(\\Gamma)$ 是其余四个能带的能量。\n\n测试套件：\n\n为以下参数集计算上述指标，所有能量单位为电子伏特 (eV)，角度单位为弧度：\n\n- 情况 1：$\\lambda=0.4$, $t_\\pi=0.15$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$。\n- 情况 2：$\\lambda=1.0$, $t_\\pi=0.05$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$。\n- 情况 3：$\\lambda=0.05$, $t_\\pi=0.30$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$。\n- 情况 4：$\\lambda=0.4$, $t_\\pi=0.15$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.1,-0.05,-0.05)$。\n\n最终输出格式：\n\n你的程序应生成单行输出，其中包含一个列表的列表，每个子列表按上述顺序包含三个指标。例如，它应该看起来像：\n$$\n[[\\overline{w}_1,\\mathrm{RMS}_1,\\Delta E_{\\Gamma,1}],\\dots,[\\overline{w}_4,\\mathrm{RMS}_4,\\Delta E_{\\Gamma,4}]]\n$$\n每个条目都是一个浮点数。精确打印此单行，不带任何附加文本。",
            "solution": "出发点是自旋轨道耦合的相对论起源。从中心势 $V(r)$ 中的狄拉克方程出发，Foldy–Wouthuysen 变换产生了一个非相对论哈密顿量，其中包含一个与 $\\mathbf{L}\\cdot\\mathbf{S}$ 成正比的 SOC 项。在原子背景下，这表现为我们所熟悉的形式 $H_{\\mathrm{SO}}=\\lambda\\,\\mathbf{L}\\cdot\\mathbf{S}$，其中 $\\lambda$ 包含了径向期望值 $\\lambda\\sim \\frac{\\hbar^2}{2m^2c^2}\\left\\langle \\frac{1}{r}\\frac{dV}{dr}\\right\\rangle$。在固体中，尤其是在 $5d$ 铱氧化物中，$\\lambda$ 在关联子空间内被视为一个有效的在位参数。\n\n在理想的立方钙钛矿中，由周围氧原子产生的晶体场将 $d$ 轨道分裂为 $e_g$ 和 $t_{2g}$ 轨道集，其中 $t_{2g}$ 态（$d_{xy}$、$d_{yz}$、$d_{zx}$）位于费米能级附近。$t_{2g}$ 轨道集可以用一个有效的轨道角动量 $\\ell_{\\mathrm{eff}}=1$ 来表示，且相对于 $p$-轨道表示带有一个总体的负号。这个负号的产生是因为 $t_{2g}$ 子空间在旋转下的变换方式与 $p$-轨道基矢相反，这反映在投影后的 $L_i$ 矩阵的具体形式中。\n\n算法构建：\n\n1. 定义基矢 $\\{|d_{xy}\\uparrow\\rangle,|d_{yz}\\uparrow\\rangle,|d_{zx}\\uparrow\\rangle,|d_{xy}\\downarrow\\rangle,|d_{yz}\\downarrow\\rangle,|d_{zx}\\downarrow\\rangle\\}$。\n\n2. 在有序轨道基矢 $\\{|d_{xy}\\rangle,|d_{yz}\\rangle,|d_{zx}\\rangle\\}$ 中构建轨道角动量矩阵 $L_x$、$L_y$、$L_z$：\n$$\nL_x=\\begin{pmatrix}\n0  0  0\\\\\n0  0  i\\\\\n0  -i  0\n\\end{pmatrix},\\quad\nL_y=\\begin{pmatrix}\n0  0  -i\\\\\n0  0  0\\\\\ni  0  0\n\\end{pmatrix},\\quad\nL_z=\\begin{pmatrix}\n0  i  0\\\\\n-i  0  0\\\\\n0  0  0\n\\end{pmatrix}.\n$$\n这些已经编码了有效的负号（它们是 $-L^{(p)}$）。\n\n3. 构建自旋算符 $S_i=\\frac{1}{2}\\sigma_i$，其中泡利矩阵 $\\sigma_i$ 作用于自旋空间。建立\n$$\nH_{\\mathrm{SO}}=\\lambda\\sum_{i=x,y,z}L_i\\otimes S_i=\\frac{\\lambda}{2}\\left(L_x\\otimes \\sigma_x+L_y\\otimes \\sigma_y+L_z\\otimes \\sigma_z\\right).\n$$\n对角化 $H_{\\mathrm{SO}}$ 会产生两个位于 $+\\lambda$ 的本征值（$j_{\\mathrm{eff}}=1/2$ 二重态）和四个位于 $-\\lambda/2$ 的本征值（$j_{\\mathrm{eff}}=3/2$ 四重态），这与当包含 $t_{2g}$ 子空间的有效负号（$l=1, s=1/2$）时能量表达式 $E_j=-\\frac{\\lambda}{2}\\left[j(j+1)-l(l+1)-s(s+1)\\right]$ 的结果一致。\n\n4. 构建对称性约束的跃迁哈密顿量 $H_{\\mathrm{hop}}(\\mathbf{k})$ 为\n$$\nH_{\\mathrm{hop}}(\\mathbf{k})=\\mathrm{diag}(\\varepsilon_{xy}(\\mathbf{k}),\\varepsilon_{yz}(\\mathbf{k}),\\varepsilon_{zx}(\\mathbf{k}))\\otimes I_2,\n$$\n其中\n$$\n\\varepsilon_{xy}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_x + \\cos k_y\\right),\\quad\n\\varepsilon_{yz}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_y + \\cos k_z\\right),\\quad\n\\varepsilon_{zx}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_z + \\cos k_x\\right).\n$$\n这强制了立方对称性，使得每个 $t_{2g}$ 轨道只允许沿着对称性允许的方向发生跃迁。\n\n5. 包含晶体场项\n$$\nH_{\\mathrm{CF}}=\\mathrm{diag}(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})\\otimes I_2,\n$$\n以捕捉四方畸变。一个保持对称性的选择是 $\\Delta_{yz}=\\Delta_{zx}=-\\Delta_{xy}/2$，以维持迹为零。\n\n6. 总哈密顿量为\n$$\nH(\\mathbf{k})=H_{\\mathrm{hop}}(\\mathbf{k})+H_{\\mathrm{SO}}+H_{\\mathrm{CF}}.\n$$\n对于给定的 $\\mathbf{k}$，对角化 $H(\\mathbf{k})$ 以获得本征值和归一化本征矢量 $\\{E_n(\\mathbf{k}),|\\psi_n(\\mathbf{k})\\rangle\\}$。\n\n7. 通过单独对角化 $H_{\\mathrm{SO}}$ 并将对应于 $+\\lambda$ 本征值的两个本征矢量的投影算子相加，来构建 $j_{\\mathrm{eff}}=1/2$ 投影算子 $P_{1/2}$。由于 $H_{\\mathrm{SO}}$ 与 $\\mathbf{k}$ 无关且是纯在位的，因此 $P_{1/2}$ 是一个固定的 $6\\times 6$ 投影算子。\n\n8. 对于每个本征态 $|\\psi_n(\\mathbf{k})\\rangle$，计算 $j_{\\mathrm{eff}}=1/2$ 的权重\n$$\nw_n(\\mathbf{k})=\\langle \\psi_n(\\mathbf{k})|P_{1/2}|\\psi_n(\\mathbf{k})\\rangle,\n$$\n其值介于 0 和 1 之间。\n\n9. 在沿路径 $\\Gamma\\to X\\to M\\to R$（每段 5 个点，角度以弧度为单位）的每个采样 $\\mathbf{k}$ 点，将具有最大 $w_n(\\mathbf{k})$ 的两个能带识别为该 $\\mathbf{k}$ 点的 $j_{\\mathrm{eff}}=1/2$ 能带。\n\n10. 计算指标：\n- 平均 $j_{\\mathrm{eff}}=1/2$ 权重，\n$$\n\\overline{w}=\\frac{1}{2N_k}\\sum_{\\mathbf{k}}\\sum_{m=1}^{2}w_{m}^{\\mathrm{(sel)}}(\\mathbf{k}).\n$$\n这量化了提取的能带在整个路径上 $j_{\\mathrm{eff}}=1/2$ 意义上的纯度。\n- 模拟 DFT+SOC 投影算子比较的验证误差，即与理想权重 1 的均方根偏差，\n$$\n\\mathrm{RMS}=\\sqrt{\\frac{1}{2N_k}\\sum_{\\mathbf{k}}\\sum_{m=1}^{2}\\left(1-w_{m}^{\\mathrm{(sel)}}(\\mathbf{k})\\right)^2}.\n$$\n对于强 SOC 和弱跃迁，$\\overline{w}\\to 1$ 且 $\\mathrm{RMS}\\to 0$；对于弱 SOC 或强畸变，混合增加，导致 $\\overline{w}$ 减小，$\\mathrm{RMS}$ 增大。\n- 在 $\\Gamma$ 点的能量分裂，\n$$\n\\Delta E_{\\Gamma}=\\frac{1}{2}\\sum_{m=1}^{2}E_{m}^{(1/2)}(\\Gamma)-\\frac{1}{4}\\sum_{n=1}^{4}E_{n}^{(3/2)}(\\Gamma),\n$$\n单位为电子伏特 (eV)。在原子极限下，当 $t_\\pi=0$ 且晶体场畸变为零时，此值简化为 $\\Delta E_{\\Gamma}=\\lambda-\\left(-\\lambda/2\\right)=\\frac{3}{2}\\lambda$，与 $j_{\\mathrm{eff}}$ 分裂一致；跃迁和晶体场项会修正此分裂。\n\n11. 将以上步骤应用于测试套件：\n- 情况 1：$\\lambda=0.4$, $t_\\pi=0.15$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$，代表典型的类铱氧化物情形。\n- 情况 2：$\\lambda=1.0$, $t_\\pi=0.05$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$，强 SOC 极限。\n- 情况 3：$\\lambda=0.05$, $t_\\pi=0.30$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$，强跃迁与弱 SOC，用于探究混合效应。\n- 情况 4：$\\lambda=0.4$, $t_\\pi=0.15$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.1,-0.05,-0.05)$，迹为零的四方畸变，用于测试对称性破缺效应。\n\n所实现的程序遵循这些步骤，为每个情况计算指标，并以要求的单行格式打印它们。这种方法综合了 SOC 的相对论起源、对称性约束的紧束缚描述以及基于投影算子的 $j_{\\mathrm{eff}}=1/2$ 特性提取，为 DFT+SOC 轨道投影算子比较提供了一个有科学依据且可通过算法检验的验证代理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef t2g_L_matrices():\n    \"\"\"Return Lx, Ly, Lz matrices in the t2g orbital basis {xy, yz, zx}.\"\"\"\n    i = 1j\n    Lx = np.array([[0, 0, 0],\n                   [0, 0, i],\n                   [0, -i, 0]], dtype=complex)\n    Ly = np.array([[0, 0, -i],\n                   [0, 0, 0],\n                   [i, 0, 0]], dtype=complex)\n    Lz = np.array([[0, i, 0],\n                   [-i, 0, 0],\n                   [0, 0, 0]], dtype=complex)\n    return Lx, Ly, Lz\n\ndef pauli_matrices():\n    \"\"\"Return Pauli matrices sigma_x, sigma_y, sigma_z.\"\"\"\n    sigma_x = np.array([[0, 1],\n                        [1, 0]], dtype=complex)\n    sigma_y = np.array([[0, -1j],\n                        [1j, 0]], dtype=complex)\n    sigma_z = np.array([[1, 0],\n                        [0, -1]], dtype=complex)\n    return sigma_x, sigma_y, sigma_z\n\ndef kron(A, B):\n    \"\"\"Kronecker product, returning complex dtype.\"\"\"\n    return np.kron(A, B).astype(complex)\n\ndef H_soc(lambda_ev):\n    \"\"\"Construct on-site SOC Hamiltonian H_SO = (lambda/2) sum_i L_i ⊗ sigma_i.\"\"\"\n    Lx, Ly, Lz = t2g_L_matrices()\n    sx, sy, sz = pauli_matrices()\n    H = (lambda_ev / 2.0) * (kron(Lx, sx) + kron(Ly, sy) + kron(Lz, sz))\n    return H\n\ndef H_hop(kx, ky, kz, t_pi):\n    \"\"\"Construct hopping Hamiltonian H_hop(k) = diag(eps_xy, eps_yz, eps_zx) ⊗ I2.\"\"\"\n    eps_xy = -2.0 * t_pi * (np.cos(kx) + np.cos(ky))\n    eps_yz = -2.0 * t_pi * (np.cos(ky) + np.cos(kz))\n    eps_zx = -2.0 * t_pi * (np.cos(kz) + np.cos(kx))\n    eps = np.array([eps_xy, eps_yz, eps_zx], dtype=float)\n    H_orb = np.diag(eps).astype(complex)\n    I2 = np.eye(2, dtype=complex)\n    return kron(H_orb, I2)\n\ndef H_cf(delta_xy, delta_yz, delta_zx):\n    \"\"\"Construct crystal-field Hamiltonian H_CF = diag(Delta_xy, Delta_yz, Delta_zx) ⊗ I2.\"\"\"\n    deltas = np.array([delta_xy, delta_yz, delta_zx], dtype=float)\n    H_orb = np.diag(deltas).astype(complex)\n    I2 = np.eye(2, dtype=complex)\n    return kron(H_orb, I2)\n\ndef j_eff_half_projector():\n    \"\"\"\n    Build the k-independent projector onto j_eff=1/2 subspace by diagonalizing H_SOC (lambda=1).\n    Returns a 6x6 Hermitian projector matrix P.\n    \"\"\"\n    H = H_soc(1.0)  # Eigenvectors independent of lambda scaling for lambda>0\n    evals, evecs = np.linalg.eigh(H)\n    # Identify the two largest eigenvalues (j_eff=1/2 doublet at +lambda)\n    idx_sorted = np.argsort(evals)  # ascending\n    idx_top2 = idx_sorted[-2:]      # last two are the largest\n    P = np.zeros((6, 6), dtype=complex)\n    for idx in idx_top2:\n        v = evecs[:, idx]\n        # Normalize (should already be normalized by eigh)\n        v = v / np.linalg.norm(v)\n        P += np.outer(v, np.conjugate(v))\n    # Ensure Hermitian projector numerically\n    P = (P + P.conjugate().T) / 2.0\n    return P\n\ndef sample_k_path(n_per_segment=5):\n    \"\"\"\n    Sample 5 equally spaced points per segment along Gamma->X->M->R path.\n    Angles in radians. Returns a list of (kx, ky, kz).\n    \"\"\"\n    # Parameter t in [0,1] with n points including endpoints\n    ts = np.linspace(0.0, 1.0, n_per_segment)\n    pts = []\n    # Gamma (0,0,0) to X (pi,0,0)\n    for t in ts:\n        pts.append((np.pi * t, 0.0, 0.0))\n    # X (pi,0,0) to M (pi,pi,0)\n    for t in ts:\n        pts.append((np.pi, np.pi * t, 0.0))\n    # M (pi,pi,0) to R (pi,pi,pi)\n    for t in ts:\n        pts.append((np.pi, np.pi, np.pi * t))\n    # Remove exact duplicates while preserving order\n    unique = []\n    seen = set()\n    for k in pts:\n        key = (round(k[0], 12), round(k[1], 12), round(k[2], 12))\n        if key not in seen:\n            seen.add(key)\n            unique.append(k)\n    return unique\n\ndef compute_metrics(lambda_ev, t_pi, delta_xy, delta_yz, delta_zx):\n    \"\"\"\n    Compute:\n    - average j_eff=1/2 weight over selected bands and k-points,\n    - RMS deviation from ideal projector weight 1,\n    - Gamma-point splitting between j_eff=1/2 and j_eff=3/2 means (in eV).\n    \"\"\"\n    P = j_eff_half_projector()\n    k_list = sample_k_path(n_per_segment=5)\n    weights_selected = []  # collect weights of the two selected bands across all k\n    # For Gamma splitting calculation\n    kx_g, ky_g, kz_g = (0.0, 0.0, 0.0)\n    H_gamma = H_hop(kx_g, ky_g, kz_g, t_pi) + H_soc(lambda_ev) + H_cf(delta_xy, delta_yz, delta_zx)\n    evals_g, evecs_g = np.linalg.eigh(H_gamma)\n    # Compute weights at Gamma\n    weights_g = np.array([np.real(np.conjugate(evecs_g[:, n]).T @ (P @ evecs_g[:, n])) for n in range(6)], dtype=float)\n    # Identify top2 bands at Gamma\n    idx_top2_g = np.argsort(weights_g)[-2:]\n    # j_eff=1/2 energies (mean of two)\n    E_j12_gamma = np.mean(evals_g[idx_top2_g].real)\n    # j_eff=3/2 energies: the remaining four\n    idx_rest_g = np.array([n for n in range(6) if n not in idx_top2_g], dtype=int)\n    E_j32_gamma = np.mean(evals_g[idx_rest_g].real)\n\n    # Loop over k-points for weights and RMS\n    for (kx, ky, kz) in k_list:\n        Hk = H_hop(kx, ky, kz, t_pi) + H_soc(lambda_ev) + H_cf(delta_xy, delta_yz, delta_zx)\n        evals, evecs = np.linalg.eigh(Hk)\n        # Compute projector weights for all bands\n        ws = np.array([np.real(np.conjugate(evecs[:, n]).T @ (P @ evecs[:, n])) for n in range(6)], dtype=float)\n        # Select two bands with largest weights\n        idx_top2 = np.argsort(ws)[-2:]\n        weights_selected.extend(ws[idx_top2].tolist())\n\n    # Metrics\n    weights_selected = np.array(weights_selected, dtype=float)\n    avg_weight = float(np.mean(weights_selected))\n    rms_error = float(np.sqrt(np.mean((1.0 - weights_selected) ** 2)))\n    delta_E_gamma = float(E_j12_gamma - E_j32_gamma)  # in eV\n\n    return [avg_weight, rms_error, delta_E_gamma]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (lambda_ev, t_pi, delta_xy, delta_yz, delta_zx)\n    test_cases = [\n        (0.4, 0.15, 0.0, 0.0, 0.0),        # Case 1\n        (1.0, 0.05, 0.0, 0.0, 0.0),        # Case 2\n        (0.05, 0.30, 0.0, 0.0, 0.0),       # Case 3\n        (0.4, 0.15, 0.1, -0.05, -0.05),    # Case 4 (tetragonal, zero trace)\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_ev, t_pi, dxy, dyz, dzx = case\n        metrics = compute_metrics(lambda_ev, t_pi, dxy, dyz, dzx)\n        results.append(metrics)\n\n    # Final print statement in the exact required format.\n    # Single line: list of lists with floats.\n    # Ensure default Python string formatting without extra text.\n    print(str(results))\n\nsolve()\n```"
        },
        {
            "introduction": "定义模型之后，可靠的数值实现需要仔细考虑收敛性和计算效率。这项实践深入探讨了二维电子气中经典Rashba模型的数值分析，该模型是理解由结构反演不对称性引起的自旋劈裂的基石。你将学习如何实现一个$k$空间哈密顿量，测试$k$点网格的收敛性，利用时间反演对称性降低计算成本，以及通过分析哈密顿量的条件数来诊断潜在的数值不稳定性 。",
            "id": "3488606",
            "problem": "考虑一个在方形晶格上的二维电子气，在无量纲单位下建模，其中晶格常数 $a$ 设为 $1$，约化普朗克常数 $\\hbar$ 设为 $1$，有效质量 $m$ 设为 $1$。该系统表现出由相对论效应引起的自旋轨道耦合。为了计算目的，在动量空间中对该系统建模，其在波矢 $\\mathbf{k} = (k_x,k_y)$ 处的有效哈密顿量如下：\n$$\nH(\\mathbf{k}) = \\frac{k_x^2 + k_y^2}{2}\\, I_2 + \\alpha \\left(k_y\\, \\sigma_x - k_x\\, \\sigma_y \\right) + \\eta\\, I_2,\n$$\n其中 $I_2$ 是 $2 \\times 2$ 单位矩阵，$\\sigma_x$ 和 $\\sigma_y$ 是泡利矩阵，$\\alpha$ 是无量纲的自旋轨道耦合强度，$\\eta$ 是为了减轻数值不稳定性而添加到对角线上的一个小的正则化项。所有量均为无量纲。\n\n从自旋轨道耦合和时间反演对称性的基本原理出发，你必须设计一个程序来：\n$1.$ 对于布里渊区 $k_x, k_y \\in [-\\pi,\\pi]$ 的均匀矩形采样，使用一个均匀的 $N \\times N$ 网格来构造 $H(\\mathbf{k})$。\n$2.$ 对于网格上的每个 $\\mathbf{k}$，计算 $H(\\mathbf{k})$ 的两个本征值 $E_1(\\mathbf{k})$ 和 $E_2(\\mathbf{k})$，并定义能级分裂 $\\Delta(\\mathbf{k}) = |E_1(\\mathbf{k}) - E_2(\\mathbf{k})|$。\n$3.$ 计算完整网格上的平均能级分裂，\n$$\n\\langle \\Delta \\rangle_{N} = \\frac{1}{N^2} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\Delta(k_x^{(i)}, k_y^{(j)}),\n$$\n其中 $k_x^{(i)}$ 和 $k_y^{(j)}$ 是 $[-\\pi,\\pi]$ 内均匀间隔的网格点。\n$4.$ 通过仅在第一象限 $k_x, k_y \\in [0,\\pi]$ 上使用 $N \\times N$ 网格进行采样，实现对称性约化，并通过由时间反演对称性和符号反射引起的权重来重构完整网格的平均值。具体来说，为每个采样点分配一个权重 $w(\\mathbf{k})$ 如下：如果 $k_x = 0$ 且 $k_y = 0$，则使用 $w(\\mathbf{k}) = 1$；如果 $k_x$ 或 $k_y$ 中恰好有一个为零，则使用 $w(\\mathbf{k}) = 2$；否则使用 $w(\\mathbf{k}) = 4$。定义对称性约化后的平均值\n$$\n\\langle \\Delta \\rangle_{N}^{\\mathrm{sym}} = \\frac{\\sum_{i=1}^{N} \\sum_{j=1}^{N} w(k_x^{(i)}, k_y^{(j)}) \\, \\Delta(k_x^{(i)}, k_y^{(j)})}{\\sum_{i=1}^{N} \\sum_{j=1}^{N} w(k_x^{(i)}, k_y^{(j)})},\n$$\n其中现在 $k_x^{(i)}, k_y^{(j)} \\in [0,\\pi]$。\n$5.$ 通过计算 $\\langle \\Delta \\rangle_{N}$ 和 $\\langle \\Delta \\rangle_{2N}$，然后评估\n$$\n\\delta_{\\mathrm{conv}} = \\left| \\langle \\Delta \\rangle_{2N} - \\langle \\Delta \\rangle_{N} \\right|,\n$$\n来测试收敛性，并报告对于给定的容差 $\\varepsilon$，是否有 $\\delta_{\\mathrm{conv}} \\le \\varepsilon$。\n$6.$ 通过计算绝对差\n$$\n\\delta_{\\mathrm{sym}} = \\left| \\langle \\Delta \\rangle_{N} - \\langle \\Delta \\rangle_{N}^{\\mathrm{sym}} \\right|.\n$$\n来测试对称性约化的精度。\n$7.$ 通过在每个 $\\mathbf{k}$ 处计算条件数\n$$\n\\kappa(H(\\mathbf{k})) = \\frac{s_{\\max}(H(\\mathbf{k}))}{s_{\\min}(H(\\mathbf{k}))},\n$$\n来评估数值稳定性，其中 $s_{\\max}$ 和 $s_{\\min}$ 分别是 $H(\\mathbf{k})$ 的最大和最小奇异值。报告对于给定的阈值 $\\kappa_{\\max}$，是否有 $\\max_{\\mathbf{k}} \\kappa(H(\\mathbf{k})) \\le \\kappa_{\\max}$。\n\n你的程序必须实现以上所有内容，并为以下参数集 $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max})$ 的测试套件生成结果：\n$1.$ $(0.0, 25, 10^{-8}, 10^{-9}, 10^{8})$，\n$2.$ $(0.01, 25, 10^{-8}, 10^{-6}, 10^{6})$，\n$3.$ $(0.10, 25, 10^{-8}, 10^{-5}, 10^{6})$，\n$4.$ $(1.00, 25, 10^{-8}, 10^{-5}, 10^{7})$，\n$5.$ $(2.00, 25, 10^{-6}, 10^{-4}, 10^{7})$。\n\n对于每个参数集，你的程序必须按顺序计算并输出三个值：表示带容差收敛性的布尔值（如果 $\\delta_{\\mathrm{conv}} \\le \\varepsilon$ 则为 true），浮点数 $\\delta_{\\mathrm{sym}}$，以及表示稳定性阈值的布尔值（如果 $\\max_{\\mathbf{k}} \\kappa(H(\\mathbf{k})) \\le \\kappa_{\\max}$ 则为 true）。所有计算出的量都是无量纲的。你的程序应该生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为测试用例1的结果，后跟测试用例2的结果，依此类推，总共包含15个条目。例如，输出格式应与 $[v_1,v_2,\\dots,v_{15}]$ 完全一样，其中每个 $v_i$ 是一个布尔值或一个浮点数。",
            "solution": "该问题要求分析方形晶格上的二维电子气，该系统由动量空间中一个特定的有效哈密顿量描述。分析内容包括计算平均能级分裂、测试收敛性、评估对称性约化方案以及评定数值稳定性。\n\n首先，我们验证问题陈述。\n\n### 步骤1：提取给定条件\n- **无量纲单位**：晶格常数 $a=1$，约化普朗克常数 $\\hbar=1$，有效质量 $m=1$。\n- **系统**：具有自旋轨道耦合的方形晶格上的二维电子气。\n- **哈密顿量**：$H(\\mathbf{k}) = \\frac{k_x^2 + k_y^2}{2}\\, I_2 + \\alpha \\left(k_y\\, \\sigma_x - k_x\\, \\sigma_y \\right) + \\eta\\, I_2$，对于波矢 $\\mathbf{k} = (k_x, k_y)$。\n- **定义**：$I_2$ 是 $2 \\times 2$ 单位矩阵，$\\sigma_x$ 和 $\\sigma_y$ 是泡利矩阵，$\\alpha$ 是自旋轨道耦合强度，$\\eta$ 是一个正的正则化参数。\n- **任务1**：为 $k_x, k_y \\in [-\\pi,\\pi]$ 上的均匀 $N \\times N$ 网格构造 $H(\\mathbf{k})$。\n- **任务2**：计算本征值 $E_1(\\mathbf{k})$、$E_2(\\mathbf{k})$ 和能级分裂 $\\Delta(\\mathbf{k}) = |E_1(\\mathbf{k}) - E_2(\\mathbf{k})|$。\n- **任务3**：计算完整网格上的平均值 $\\langle \\Delta \\rangle_{N} = \\frac{1}{N^2} \\sum_{i,j} \\Delta(k_x^{(i)}, k_y^{(j)})$，其中 $(k_x^{(i)}, k_y^{(j)})$ 在 $[-\\pi, \\pi]^2$ 上的 $N \\times N$ 网格上。\n- **任务4**：实现对称性约化。在 $k_x, k_y \\in [0,\\pi]$ 上的 $N \\times N$ 网格上采样。在 $(0,0)$ 处使用权重 $w(\\mathbf{k})=1$，在坐标轴上（不包括原点）使用 $w(\\mathbf{k})=2$，其他地方使用 $w(\\mathbf{k})=4$。计算对称性约化后的平均值 $\\langle \\Delta \\rangle_{N}^{\\mathrm{sym}} = \\frac{\\sum_{i,j} w(k_x^{(i)}, k_y^{(j)}) \\, \\Delta(k_x^{(i)}, k_y^{(j)})}{\\sum_{i,j} w(k_x^{(i)}, k_y^{(j)})}$，其中 $(k_x^{(i)}, k_y^{(j)})$ 在 $[0, \\pi]^2$ 上的 $N \\times N$ 网格上。\n- **任务5**：通过评估 $\\delta_{\\mathrm{conv}} = \\left| \\langle \\Delta \\rangle_{2N} - \\langle \\Delta \\rangle_{N} \\right|$ 并检查是否 $\\delta_{\\mathrm{conv}} \\le \\varepsilon$ 来测试收敛性。\n- **任务6**：通过计算 $\\delta_{\\mathrm{sym}} = \\left| \\langle \\Delta \\rangle_{N} - \\langle \\Delta \\rangle_{N}^{\\mathrm{sym}} \\right|$ 来测试对称性约化的精度。\n- **任务7**：通过在完整网格上找到最大条件数 $\\kappa(H(\\mathbf{k})) = \\frac{s_{\\max}(H(\\mathbf{k}))}{s_{\\min}(H(\\mathbf{k}))}$ 并检查其是否低于阈值 $\\kappa_{\\max}$ 来测试数值稳定性。\n- **测试套件**：\n  1. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (0.0, 25, 10^{-8}, 10^{-9}, 10^{8})$\n  2. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (0.01, 25, 10^{-8}, 10^{-6}, 10^{6})$\n  3. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (0.10, 25, 10^{-8}, 10^{-5}, 10^{6})$\n  4. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (1.00, 25, 10^{-8}, 10^{-5}, 10^{7})$\n  5. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (2.00, 25, 10^{-6}, 10^{-4}, 10^{7})$\n\n### 步骤2：使用提取的给定条件进行验证\n- **科学依据**：该哈密顿量是二维电子气的标准 Rashba 自旋轨道耦合哈密顿量。各项分别代表动能、自旋轨道相互作用和恒定的能量偏移。该模型是固态物理学和计算材料科学的基石。对于自旋1/2系统，使用泡利矩阵是标准做法。该问题在科学上是合理的。\n- **良置性**：所有任务都用明确的数学公式和算法定义。输入被清晰地指定，并且所需的输出是唯一的数值或布尔值。\n- **客观性**：问题以精确、正式的语言陈述，没有任何主观性或模糊性。\n- **缺陷分析**：\n  1.  **科学/事实不准确**：无。该模型在物理上是有效的。\n  2.  **不可形式化/不相关**：无。该问题是一个可形式化的计算任务，与指定主题直接相关。\n  3.  **不完整/矛盾的设置**：无。计算所需的所有必要参数和定义都已提供。网格定义和平均过程是明确的。\n  4.  **不切实际/不可行**：无。参数在此类模型的合理范围内，计算任务是可行的。\n  5.  **病态/结构不良**：无。该问题被构建为一系列定义明确的计算步骤，导向唯一的解决方案。\n  6.  **伪深刻/琐碎**：该问题需要基于物理原理的数值方法的非平凡实现，涵盖了数值积分、对称性、收敛性和稳定性的概念。它并非琐碎问题。\n  7.  **超出科学可验证范围**：无。结果是可以通过计算验证的。\n\n### 步骤3：结论与行动\n问题是有效的。我们继续进行求解。\n\n### 基于原理的设计与求解\n\n问题的核心在于分析哈密顿量 $H(\\mathbf{k})$。让我们首先解析地确定其性质，这将显著简化计算任务。\n\n给定的哈密顿量是：\n$$\nH(\\mathbf{k}) = \\frac{k_x^2 + k_y^2}{2}\\, I_2 + \\alpha \\left(k_y\\, \\sigma_x - k_x\\, \\sigma_y \\right) + \\eta\\, I_2\n$$\n泡利矩阵为 $\\sigma_x = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}$ 和 $\\sigma_y = \\begin{pmatrix} 0  -i \\\\ i  0 \\end{pmatrix}$。将它们代入哈密顿量，得到显式矩阵形式：\n$$\nH(\\mathbf{k}) = \\frac{k_x^2 + k_y^2}{2} \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} + \\alpha \\left( k_y \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix} - k_x \\begin{pmatrix} 0  -i \\\\ i  0 \\end{pmatrix} \\right) + \\eta \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}\n$$\n$$\nH(\\mathbf{k}) = \\begin{pmatrix} \\frac{k_x^2+k_y^2}{2}+\\eta  \\alpha(k_y + ik_x) \\\\ \\alpha(k_y - ik_x)  \\frac{k_x^2+k_y^2}{2}+\\eta \\end{pmatrix}\n$$\n这是一个形如 $\\begin{pmatrix} A  C \\\\ C^*  A \\end{pmatrix}$ 的 $2 \\times 2$ 厄米矩阵。其本征值 $E$ 由特征方程 $\\det(H - E I_2) = 0$ 的解给出，该方程可简化为 $(A - E)^2 - |C|^2 = 0$。因此，本征值为 $E = A \\pm |C|$。\n\n这里，$A = \\frac{k_x^2+k_y^2}{2} + \\eta$ 且 $|C| = |\\alpha(k_y + ik_x)| = |\\alpha|\\sqrt{k_y^2 + k_x^2}$。令 $k = \\sqrt{k_x^2 + k_y^2}$ 为波矢的模。两个本征值为：\n$$\nE_{\\pm}(\\mathbf{k}) = \\frac{k^2}{2} + \\eta \\pm |\\alpha| k\n$$\n这个解析结果至关重要，因为它避免了在网格上每个点对矩阵 $H(\\mathbf{k})$ 进行数值对角化的需要，从而导出一个高效的算法。\n\n**任务2：能级分裂**\n能级分裂 $\\Delta(\\mathbf{k})$ 是两个本征值之间的绝对差：\n$$\n\\Delta(\\mathbf{k}) = |E_{+}(\\mathbf{k}) - E_{-}(\\mathbf{k})| = \\left| \\left(\\frac{k^2}{2} + \\eta + |\\alpha| k\\right) - \\left(\\frac{k^2}{2} + \\eta - |\\alpha| k\\right) \\right| = |2 |\\alpha| k| = 2 |\\alpha| \\sqrt{k_x^2 + k_y^2}\n$$\n\n**任务3：完整网格平均值 $\\langle \\Delta \\rangle_{N}$**\n为了计算平均分裂，我们首先在区域 $[-\\pi, \\pi] \\times [-\\pi, \\pi]$ 中定义一个均匀的 $N \\times N$ 网格点 $(k_x, k_y)$。这是通过分别为 $k_x$ 和 $k_y$ 创建线性间隔点，然后形成一个网格来实现的。对于该网格上的每个点，我们使用推导出的解析公式计算 $\\Delta(\\mathbf{k})$，然后对所有 $N^2$ 个网格点取算术平均值。\n\n**任务4：对称性约化平均值 $\\langle \\Delta \\rangle_{N}^{\\mathrm{sym}}$**\n函数 $\\Delta(\\mathbf{k}) = 2|\\alpha|k$ 仅依赖于模 $k = \\sqrt{k_x^2+k_y^2}$。该函数表现出高度的对称性：$\\Delta(k_x, k_y) = \\Delta(\\pm k_x, \\pm k_y)$。这意味着其值在布里渊区的所有四个象限中都是相同的。因此，可以通过仅在第一象限 $[0, \\pi] \\times [0, \\pi]$ 上进行平均，并对边界上的点进行适当加权，来高效地估计整个区域的平均值。权重考虑了点在反射到其他象限时的重数：\n- 对于 $k_x > 0, k_y > 0$ 的点 $(k_x, k_y)$，在完整区域中有 4 个等效点。权重 $w=4$。\n- 对于坐标轴上的点，即 $k_x > 0$ 的 $(k_x, 0)$ 或 $k_y > 0$ 的 $(0, k_y)$，有 2 个等效点。权重 $w=2$。\n- 原点 $(0,0)$ 是唯一的。权重 $w=1$。\n对称性约化平均值是在第一象限的 $N \\times N$ 网格上的加权平均值，如 $\\langle \\Delta \\rangle_{N}^{\\mathrm{sym}}$ 的公式所指定。\n\n**任务5：收敛性测试**\n$\\langle \\Delta \\rangle_{N}$ 的计算是积分 $I = \\frac{1}{(2\\pi)^2} \\int_{-\\pi}^{\\pi} \\int_{-\\pi}^{\\pi} \\Delta(k_x, k_y) \\,dk_x dk_y$ 的一个数值近似。随着网格变得更密集（即 $N$ 增加），近似值应收敛到积分的真实值。收敛性测试 $\\delta_{\\mathrm{conv}} = |\\langle \\Delta \\rangle_{2N} - \\langle \\Delta \\rangle_{N}| \\le \\varepsilon$ 检查当网格密度加倍时，计算出的平均值的变化是否小于容差 $\\varepsilon$。这是评估数值积分收敛性的标准程序。\n\n**任务6：对称性精度测试**\n量 $\\delta_{\\mathrm{sym}} = |\\langle \\Delta \\rangle_{N} - \\langle \\Delta \\rangle_{N}^{\\mathrm{sym}}|$ 直接比较了完整网格计算与对称性约化计算的结果。虽然 $\\Delta(\\mathbf{k})$ 的对称性是精确的，但这两种数值方案使用的网格可能无法完全对应，从而导致一个虽小但非零的差异。此测试量化了这种特定对称性约化实现的精度。\n\n**任务7：数值稳定性测试**\n矩阵 $M$ 的条件数 $\\kappa(M)$ 衡量了 $Mx=b$ 的解对 $M$ 或 $b$ 中扰动的敏感性。对于像 $H(\\mathbf{k})$ 这样的厄米矩阵，奇异值 $s_i$ 是其本征值的绝对值，即 $s_i = |E_i|$。条件数由下式给出：\n$$\n\\kappa(H(\\mathbf{k})) = \\frac{s_{\\max}}{s_{\\min}} = \\frac{\\max(|E_+|, |E_-|)}{\\min(|E_+|, |E_-|)} = \\frac{|\\frac{k^2}{2} + \\eta + |\\alpha| k|}{|\\frac{k^2}{2} + \\eta - |\\alpha| k|}\n$$\n非常大的条件数表示矩阵是近奇异的，这可能导致数值不稳定性。这通常发生在分母 $|E_-(\\mathbf{k})|$ 接近零时。二次方程 $\\frac{k^2}{2} - |\\alpha|k + \\eta = 0$ 的根位于 $k = |\\alpha| \\pm \\sqrt{\\alpha^2 - 2\\eta}$。如果 $\\alpha^2 \\ge 2\\eta$，则存在实数 $k$ 值使得 $E_-$ 可能为零。参数 $\\eta$ 作为一个正则化项，确保分母保持非零（或不太小），从而使条件数保持有界。该算法计算完整网格上所有点的 $\\kappa(H(\\mathbf{k}))$，并找到最大值，然后与阈值 $\\kappa_{\\max}$ 进行比较。\n\n最终的实现将把这些计算封装在函数中，并为测试套件中的每组参数调用这些函数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_metrics(alpha, N, eta):\n    \"\"\"\n    Computes metrics on a full uniform grid over [-pi, pi] x [-pi, pi].\n    \n    Args:\n        alpha (float): Spin-orbit coupling strength.\n        N (int): Grid dimension (N x N).\n        eta (float): Regularization parameter.\n        \n    Returns:\n        tuple: A tuple containing:\n            - avg_delta (float): The average energy splitting over the grid.\n            - max_kappa (float): The maximum condition number over the grid.\n    \"\"\"\n    if N == 0:\n        return 0.0, 1.0\n    \n    k_range = np.linspace(-np.pi, np.pi, N)\n    kx, ky = np.meshgrid(k_range, k_range)\n    \n    k = np.sqrt(kx**2 + ky**2)\n    \n    # Calculate energy splitting Delta(k)\n    delta = 2.0 * np.abs(alpha) * k\n    avg_delta = np.mean(delta)\n    \n    # Calculate condition number kappa(k)\n    abs_alpha = np.abs(alpha)\n    k_sq_half = 0.5 * k**2\n    \n    # Eigenvalues are E_pm = k^2/2 + eta +/- |alpha|*k\n    # Singular values for a Hermitian matrix are the absolute values of its eigenvalues.\n    s_plus = np.abs(k_sq_half + eta + abs_alpha * k)\n    s_minus = np.abs(k_sq_half + eta - abs_alpha * k)\n    \n    # s_max and s_min must be determined at each point\n    s_max = np.maximum(s_plus, s_minus)\n    s_min = np.minimum(s_plus, s_minus)\n    \n    # Handle division by zero for condition number. If s_min is zero, kappa is infinite.\n    kappa = np.divide(s_max, s_min, out=np.full_like(s_max, np.inf), where=s_min != 0)\n    \n    max_kappa = np.max(kappa)\n    \n    return avg_delta, max_kappa\n\ndef calculate_sym_avg_delta(alpha, N, eta):\n    \"\"\"\n    Computes the average energy splitting using symmetry reduction on a grid over [0, pi] x [0, pi].\n    \n    Args:\n        alpha (float): Spin-orbit coupling strength.\n        N (int): Grid dimension (N x N).\n        eta (float): Regularization parameter (unused in this simplified calc but kept for API consistency).\n\n    Returns:\n        float: The symmetry-reduced average energy splitting.\n    \"\"\"\n    if N == 0:\n        return 0.0\n    if N == 1: # Grid is just the origin\n        return 0.0\n\n    k_range = np.linspace(0, np.pi, N)\n    kx, ky = np.meshgrid(k_range, k_range)\n    \n    k = np.sqrt(kx**2 + ky**2)\n    \n    # Calculate energy splitting Delta(k)\n    delta = 2.0 * np.abs(alpha) * k\n    \n    # Define weights for symmetry reduction\n    weights = np.full((N, N), 4.0)\n    weights[0, :] = 2.0\n    weights[:, 0] = 2.0\n    weights[0, 0] = 1.0\n    \n    # Compute weighted average\n    avg_delta_sym = np.sum(weights * delta) / np.sum(weights)\n\n    return avg_delta_sym\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (0.0, 25, 1e-8, 1e-9, 1e8),\n        (0.01, 25, 1e-8, 1e-6, 1e6),\n        (0.10, 25, 1e-8, 1e-5, 1e6),\n        (1.00, 25, 1e-8, 1e-5, 1e7),\n        (2.00, 25, 1e-6, 1e-4, 1e7)\n    ]\n\n    results = []\n\n    for alpha, N, eta, epsilon, kappa_max in test_cases:\n        # Task 3  7: Full grid calculations for N\n        avg_delta_N, max_kappa_N = calculate_metrics(alpha, N, eta)\n        \n        # Task 5: Convergence test requires calculation at 2N\n        avg_delta_2N, _ = calculate_metrics(alpha, 2 * N, eta)\n        delta_conv = np.abs(avg_delta_2N - avg_delta_N)\n        conv_check = delta_conv = epsilon\n        \n        # Task 4  6: Symmetry reduction test\n        avg_delta_N_sym = calculate_sym_avg_delta(alpha, N, eta)\n        delta_sym = np.abs(avg_delta_N - avg_delta_N_sym)\n        \n        # Task 7: Stability check\n        stability_check = max_kappa_N = kappa_max\n        \n        results.extend([conv_check, delta_sym, stability_check])\n    \n    formatted_results = []\n    for item in results:\n        if isinstance(item, (bool, np.bool_)):\n            formatted_results.append(str(item).lower())\n        else:\n            formatted_results.append(str(item))\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "大规模模拟（如密度泛函理论计算）的准确性，在很大程度上取决于其基础近似（如赝势）的质量。本练习将探讨一个关键的验证步骤：检验包含自旋轨道耦合的赝势是否含有非物理的“鬼态”(ghost states)。通过数值求解径向薛定谔方程并比较全电子波函数与赝波函数的对数微商，你将实践一种标准且至关重要的技术，以确保计算材料科学工具的可靠性 。",
            "id": "3488724",
            "problem": "考虑一个中心场单粒子哈密顿量，其自旋-轨道耦合 (SOC) 源于 Pauli 近似。在原子单位 (其中 $\\hbar=1$, $m=1$, $e=1$)下，对于给定的轨道角动量 $l$ 和总角动量 $j$ 通道，哈密顿量可以分离为一个关于约化径向波函数 $u_{l}^{j}(r)$ 的径向方程：\n$$\n-\\frac{1}{2}\\frac{d^{2}u_{l}^{j}}{dr^{2}} + V_{\\mathrm{eff}}^{(l,j)}(r) \\, u_{l}^{j}(r) = E \\, u_{l}^{j}(r),\n$$\n其中有效势为\n$$\nV_{\\mathrm{eff}}^{(l,j)}(r) = V(r) + \\frac{l(l+1)}{2 r^{2}} + \\frac{1}{2 c^{2}} \\frac{1}{r} \\frac{dV}{dr} \\, \\kappa_{l j},\n$$\n此处，$c$ 是原子单位下的光速，$\\kappa_{l j} = \\frac{1}{2}\\left[j(j+1) - l(l+1) - \\frac{3}{4}\\right]$ 是 $(l,j)$ 通道中轨道-自旋耦合算符 $\\mathbf{L}\\cdot\\mathbf{S}$ 的本征值。\n\n为验证特定 $(l,j)$ 通道的自旋-轨道耦合赝势，需将其与平滑的全电子参考进行对比，并检测非物理的“鬼态”。您需要比较在固定核半径 $r_c$ 处对数导数随能量的变化关系，\n$$\nL_{l}^{j}(E; r_c) = r_c \\, \\frac{u'(r_c)}{u(r_c)},\n$$\n针对两种势：\n1. 一个平滑的全电子参考势\n$$\nV_{\\mathrm{AE}}(r) = -\\frac{Z}{\\sqrt{r^{2} + a^{2}}},\n$$\n参数为 $Z$ (有效核电荷) 和 $a$ (正则化长度)。\n2. 一个自旋-轨道赝势，此处定义为一个局域模型，它在相同的长程参考势基础上，于核区内增加了一个依赖于通道的短程吸引高斯势阱，\n$$\nV_{\\mathrm{PS}}(r) = V_{\\mathrm{AE}}(r) - V_{0} \\, \\exp\\!\\left[-\\left(\\frac{r}{r_{w}}\\right)^{2}\\right],\n$$\n参数为 $V_{0}$ (阱深) 和 $r_{w}$ (阱宽)。自旋-轨道耦合 (SOC) 的贡献项中，赝势使用 $\\frac{dV_{\\mathrm{PS}}}{dr}$，全电子参考使用 $\\frac{dV_{\\mathrm{AE}}}{dr}$。\n\n在赝势验证中，鬼态的一个标准标志是在物理相关的能量窗口内，$L_{l}^{j}(E; r_c)$ 相对于参考势多出一个极点。$L_{l}^{j}(E; r_c)$ 的极点出现在径向方程的正则解（在原点处有限）满足 $u(r_c)=0$ 的能量 $E$ 处，这些能量对应于半径为 $r_c$ 的“球中原子”问题的 Dirichlet 本征值。为检测鬼态，需在指定的能量区间内分别对 $V_{\\mathrm{AE}}$ 和 $V_{\\mathrm{PS}}$ 计算此类能量（极点）的数量；若 $V_{\\mathrm{PS}}$ 的数量更多，则表明存在鬼态。\n\n实现一个程序，该程序：\n- 求解 $u_{l}^{j}(r)$ 的径向方程，并满足正则边界条件 $u(r) \\sim r^{l+1}$ (当 $r \\to 0$ 时)。\n- 在指定区间的均匀能量网格上计算 $u(r_c)$ 和对数导数 $L_{l}^{j}(E; r_c)$。\n- 通过统计 $u(r_c)$ 在连续能量点上的符号变化来检测极点。\n- 对每个测试用例，返回一个布尔值，指示赝势是否表现出鬼态（如果在区间内赝势的极点数严格大于参考势的极点数，则为 True，否则为 False）。\n\n使用以下测试套件，所有距离单位为 Bohr 半径，所有能量单位为 Hartree：\n- 测试用例 1 (基准，无势阱)：$(Z,a,r_c,l,j,V_{0},r_{w},E_{\\min},E_{\\max},N_{E}) = (4, 0.1, 1.0, 1, 3/2, 0.0, 0.5, 0.2, 2.0, 150)$。\n- 测试用例 2 (深势阱，$p_{1/2}$ 通道可能存在鬼态)：$(Z,a,r_c,l,j,V_{0},r_{w},E_{\\min},E_{\\max},N_{E}) = (4, 0.1, 1.0, 1, 1/2, 60.0, 0.3, 0.2, 2.0, 150)$。\n- 测试用例 3 (边界情况，$s$ 通道，自旋-轨道耦合消失)：$(Z,a,r_c,l,j,V_{0},r_{w},E_{\\min},E_{\\max},N_{E}) = (4, 0.1, 1.0, 0, 1/2, 0.0, 0.5, 0.2, 2.0, 150)$。\n\n您的程序必须通过扫描具有 $N_{E}$ 个均匀间隔能量点的区间 $[E_{\\min},E_{\\max}]$ 来计算极点数，然后输出一行，其中包含一个含三个布尔值的列表，每个值对应一个测试用例，顺序如上所示。最终输出必须是格式为 $[b_{1},b_{2},b_{3}]$ 的单行文本，其中每个 $b_{i}$ 为 True 或 False。\n\n您的实现必须使用稳定、自洽的逻辑来数值求解径向方程，并且不得依赖外部数据。最终结果是无单位的布尔值，但所有内部计算都必须遵循上述指定的物理单位。",
            "solution": "用户希望通过检测非物理性的“鬼态”，来验证赝势相对于全电子参考的有效性。这可以通过比较给定能量窗口内径向波函数对数导数的极点数量来实现。如果赝势比全电子参考表现出更多的极点，则识别出鬼态。\n\n这个问题的基础是数值求解中心场中单个粒子的径向 Schrödinger 方程，其中包括通过 Pauli 近似引入的相对论性自旋-轨道耦合 (SOC) 效应。该方程在原子单位下表示为：\n$$\n-\\frac{1}{2}\\frac{d^{2}u_{l}^{j}}{dr^{2}} + V_{\\mathrm{eff}}^{(l,j)}(r) \\, u_{l}^{j}(r) = E \\, u_{l}^{j}(r)\n$$\n其中，$u_{l}^{j}(r)$ 是轨道角动量量子数为 $l$、总角动量量子数为 $j$ 的态的约化径向波函数。该态的能量为 $E$。\n\n有效势 $V_{\\mathrm{eff}}^{(l,j)}(r)$ 包含中心势 $V(r)$、离心势垒和自旋-轨道耦合项：\n$$\nV_{\\mathrm{eff}}^{(l,j)}(r) = V(r) + \\frac{l(l+1)}{2 r^{2}} + \\frac{1}{2 c^{2}} \\frac{1}{r} \\frac{dV}{dr} \\, \\kappa_{l j}\n$$\n此处，$c \\approx 137.036$ 是原子单位下的光速。对于给定的 $(l,j)$ 通道，自旋-轨道耦合 (SOC) 的强度由算符 $\\mathbf{L}\\cdot\\mathbf{S}$ 的本征值 $\\kappa_{l j}$ 决定，其计算公式为：\n$$\n\\kappa_{l j} = \\frac{1}{2}\\left[j(j+1) - l(l+1) - s(s+1)\\right]\n$$\n对于电子，自旋 $s = 1/2$，因此 $s(s+1) = 3/4$。\n\n问题要求比较两种中心势：\n1. 正则化的全电子 (AE) 势：$V_{\\mathrm{AE}}(r) = -Z / \\sqrt{r^2 + a^2}$。\n2. 局域赝势 (PS) 模型：$V_{\\mathrm{PS}}(r) = V_{\\mathrm{AE}}(r) - V_0 \\exp[-(r/r_w)^2]$。\n\n核心任务是找出在固定半径 $r_c$ 处对数导数 $L_{l}^{j}(E; r_c) = r_c \\, u'(r_c)/u(r_c)$ 的极点数量。极点出现在能量 $E$ 处，此时分母 $u(r_c)$ 为零。这些能量是满足 Dirichlet 边界条件 $u(r_c)=0$ 的径向 Schrödinger 方程的本征值。\n\n数值策略如下：\n1. 对每个测试用例，我们定义一个覆盖区间 $[E_{\\min}, E_{\\max}]$ 的能量网格。\n2. 对于网格中的每个能量 $E$，我们求解径向方程以找到波函数在 $r_c$ 处的值 $u(r_c)$。\n3. 我们遍历能量网格，计算 $u(r_c)$ 变号的次数。每次变号表示穿过了一个根（即 $L$ 的一个极点）。\n4. 这个极点计数过程执行两次：一次用于 AE 势（通过设置 $V_0=0$），一次用于 PS 势（使用给定的 $V_0$）。\n5. 如果 PS 的极点数严格大于 AE 参考的极点数，则存在鬼态。\n\n为求解作为二阶常微分方程 (ODE) 的径向方程，我们将其转换为一个一阶 ODE 系统。令 $y_0(r) = u(r)$ 和 $y_1(r) = u'(r)$。该系统为：\n$$\n\\frac{dy_0}{dr} = y_1\n$$\n$$\n\\frac{dy_1}{dr} = 2 [V_{\\mathrm{eff}}(r) - E] y_0\n$$\n该系统进行数值求解。解必须是“正则的”，意味着它在原点处具有良好的物理行为。对于给定的 $l$，正则解在 $r \\to 0$ 时的行为如同 $u(r) \\sim r^{l+1}$。为避免离心项和 SOC 项在 $r=0$ 处的奇点，我们从一个很小的半径 $r_{start}  0$ 开始数值积分。初始条件根据这种渐近行为设置：$u(r_{start}) = r_{start}^{l+1}$ 和 $u'(r_{start}) = (l+1)r_{start}^l$。任意的归一化常数设为 1，因为它不影响 $u(r_c)$ 的符号。\n\n实现中使用 `scipy.integrate.solve_ivp`，这是一个稳健的自适应步长 ODE 求解器，用于将系统从 $r_{start}$ 积分到 $r_c$，并获得每个能量下 $u(r_c)$ 的值。定义了势、其导数以及完整有效势的函数，以处理数学形式并避免在 $r=0$ 附近出现数值问题。每个测试用例的最终布尔结果由条件 `pole_count_PS  pole_count_AE` 决定。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# All calculations are in atomic units (Hartree for energy, Bohr for distance).\n# Speed of light in atomic units\nC_AU = 137.035999084\n\ndef count_poles(Z, a, rc, l, j, V0, rw, E_min, E_max, N_E):\n    \"\"\"\n    Counts the number of poles of the logarithmic derivative in a given energy range.\n    This corresponds to counting the number of sign changes of u(rc) by solving\n    the radial Schrödinger equation over a grid of energies.\n\n    Args:\n        Z (float): Effective nuclear charge.\n        a (float): Regularization length for the AE potential.\n        rc (float): Core radius for evaluation.\n        l (int): Orbital angular momentum quantum number.\n        j (float): Total angular momentum quantum number.\n        V0 (float): Depth of the Gaussian pseudopotential well. If 0, this is an AE calculation.\n        rw (float): Width of the Gaussian pseudopotential well.\n        E_min (float): Minimum of the energy scan window.\n        E_max (float): Maximum of the energy scan window.\n        N_E (int): Number of energy points in the scan.\n\n    Returns:\n        int: The number of poles detected in the energy window.\n    \"\"\"\n    C_AU_SQ = C_AU**2\n    energy_grid = np.linspace(E_min, E_max, N_E)\n    kappa = 0.5 * (j * (j + 1) - l * (l + 1) - 0.75)\n\n    def V_potential(r):\n        v_ae = -Z / np.sqrt(r**2 + a**2)\n        v_ps_add = -V0 * np.exp(-(r / rw)**2)\n        return v_ae + v_ps_add\n\n    def dV_dr(r):\n        if r  1e-9: return 0.0\n        dv_ae_dr = Z * r * (r**2 + a**2)**(-1.5)\n        dv_ps_add_dr = (2 * V0 * r / rw**2) * np.exp(-(r / rw)**2)\n        return dv_ae_dr + dv_ps_add_dr\n\n    def V_effective(r, E):\n        if r  1e-9: return np.inf\n        \n        centrifugal = l * (l + 1) / (2 * r**2)\n        \n        soc_term = 0.0\n        # SOC is non-zero only for l > 0 and kappa != 0\n        if l > 0 and abs(kappa) > 1e-9:\n            soc_term = (1 / (2 * C_AU_SQ)) * (1 / r) * dV_dr(r) * kappa\n            \n        return V_potential(r) + centrifugal + soc_term\n\n    def ode_system(r, y, E):\n        u, u_prime = y\n        try:\n            v_eff_val = V_effective(r, E)\n        except FloatingPointError: # Catch divergence\n            v_eff_val = np.inf\n        \n        u_double_prime = 2 * (v_eff_val - E) * u\n        return [u_prime, u_double_prime]\n\n    pole_count = 0\n    last_u_rc_sign = 0\n\n    for E in energy_grid:\n        r_start = 1e-6\n        # Initial conditions: u(r) ~ r^(l+1) for small r\n        u_start = r_start**(l + 1)\n        u_prime_start = (l + 1) * r_start**l\n        y_start = [u_start, u_prime_start]\n        \n        sol = solve_ivp(\n            fun=lambda r, y: ode_system(r, y, E),\n            t_span=[r_start, rc],\n            y0=y_start,\n            t_eval=[rc],\n            method='RK45',\n            atol=1e-8, rtol=1e-8\n        )\n        \n        if sol.status != 0:\n            continue\n            \n        current_u_rc_val = sol.y[0, -1]\n        current_u_rc_sign = np.sign(current_u_rc_val)\n        \n        if last_u_rc_sign != 0 and current_u_rc_sign != 0 and current_u_rc_sign != last_u_rc_sign:\n            pole_count += 1\n        \n        if current_u_rc_sign != 0:\n            last_u_rc_sign = current_u_rc_sign\n\n    return pole_count\n\n\ndef check_for_ghost_state(Z, a, rc, l, j, V0, rw, E_min, E_max, N_E):\n    \"\"\"\n    Compares pole counts for AE and PS potentials to detect a ghost state.\n    Returns True if the PS potential has strictly more poles than the AE reference.\n    \"\"\"\n    poles_ae = count_poles(Z, a, rc, l, j, 0.0, rw, E_min, E_max, N_E)\n    poles_ps = count_poles(Z, a, rc, l, j, V0, rw, E_min, E_max, N_E)\n    return poles_ps > poles_ae\n\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (Z, a, rc, l, j, V0, rw, Emin, Emax, NE)\n        (4, 0.1, 1.0, 1, 1.5, 0.0, 0.5, 0.2, 2.0, 150),\n        (4, 0.1, 1.0, 1, 0.5, 60.0, 0.3, 0.2, 2.0, 150),\n        (4, 0.1, 1.0, 0, 0.5, 0.0, 0.5, 0.2, 2.0, 150),\n    ]\n\n    results = []\n    for case in test_cases:\n        has_ghost = check_for_ghost_state(*case)\n        results.append(has_ghost)\n\n    # Convert boolean list to lowercase strings for the required output format\n    formatted_results = [str(r).lower() for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}