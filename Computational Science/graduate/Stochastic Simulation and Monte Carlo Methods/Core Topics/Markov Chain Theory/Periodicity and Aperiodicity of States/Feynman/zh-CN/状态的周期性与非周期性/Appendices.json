{
    "hands_on_practices": [
        {
            "introduction": "理解周期性定义的最好方法是亲自动手计算。这个练习提供了一个具体的转移矩阵，要求我们从周期性的基本定义出发，通过分析返回状态的可能路径长度来确定每个状态的周期。通过这个练习，你将深入理解二分图结构是如何自然地导致周期为$2$的马尔可夫链的。",
            "id": "3329415",
            "problem": "考虑一个状态空间为 $\\{1,2,3,4\\}$ 的时间齐次离散时间马尔可夫链，其转移矩阵 $P \\in \\mathbb{R}^{4 \\times 4}$ 由下式给出\n$$\nP \\;=\\;\n\\begin{pmatrix}\n0  \\frac{1}{3}  0  \\frac{2}{3} \\\\\n\\frac{1}{2}  0  \\frac{1}{2}  0 \\\\\n0  \\frac{3}{5}  0  \\frac{2}{5} \\\\\n\\frac{1}{4}  0  \\frac{3}{4}  0\n\\end{pmatrix}.\n$$\n$P$ 的结构是对角线元素为零，而非对角线上的正值元素在两个划分之间交替，形成一个二分交互模式：状态 $\\{1,3\\}$ 只转移到状态 $\\{2,4\\}$，反之亦然。仅使用马尔可夫链理论的基本定义，而不借助任何捷径结论，确定每个状态的周期，并验证该链是否是不可约的。从状态 $i$ 的周期 $d(i)$ 的定义开始，即集合 $\\{n \\geq 1 : (P^{n})_{ii} > 0\\}$ 的最大公约数，以及不可约性的定义，即对于任意一对状态 $i,j$，都存在 $n \\geq 1$ 使得 $(P^{n})_{ij} > 0$。\n\n将最终答案表示为一个使用 LaTeX `pmatrix` 环境的单行矩阵，包含五个条目：按状态顺序 $(1,2,3,4)$ 排列的四个周期，以及一个指示符 $I$（如果链是不可约的，则 $I=1$，否则 $I=0$）。无需四舍五入。",
            "solution": "我们从马尔可夫链的基本定义开始。对于一个具有转移矩阵 $P$ 的时间齐次马尔可夫链，状态 $i$ 的周期 $d(i)$ 定义为\n$$\nd(i) \\;=\\; \\gcd\\big\\{ n \\geq 1 : (P^{n})_{ii} > 0 \\big\\}。\n$$\n该链是不可约的，当且仅当对于所有状态 $i,j$，都存在 $n \\geq 1$ 使得 $(P^{n})_{ij} > 0$。\n\n我们分析 $P$ 的结构。$P$ 的非零项满足：\n- 对于状态 $1$ 和 $3$，转移只发生在状态 $2$ 和 $4$；\n- 对于状态 $2$ 和 $4$，转移只发生在状态 $1$ 和 $3$；\n- 所有对角线元素满足 $(P)_{ii} = 0$。\n\n这导致状态空间被二分划为 $A = \\{1,3\\}$ 和 $B = \\{2,4\\}$，并且每一步都在 $A$ 和 $B$ 之间交替。因此，任何从同一状态开始并结束于该状态的路径必须具有偶数长度。特别地，对于任何状态 $i$，对所有奇数 $n$，都有 $(P^{n})_{ii} = 0$。因此，可能的返回时间属于偶数集合。\n\n为证明对每个 $i$ 都有 $(P^{2})_{ii} > 0$，我们显式地计算 $P^{2} = P \\cdot P$。由于二分结构，$(P^{2})$ 的非零项只存在于同一划分内的状态之间。我们计算对角线元素：\n- 对于 $i = 1$，\n$$\n(P^{2})_{11} = P_{12} P_{21} + P_{14} P_{41} = \\frac{1}{3} \\cdot \\frac{1}{2} + \\frac{2}{3} \\cdot \\frac{1}{4} = \\frac{1}{6} + \\frac{1}{6} = \\frac{1}{3}。\n$$\n- 对于 $i = 2$，\n$$\n(P^{2})_{22} = P_{21} P_{12} + P_{23} P_{32} = \\frac{1}{2} \\cdot \\frac{1}{3} + \\frac{1}{2} \\cdot \\frac{3}{5} = \\frac{1}{6} + \\frac{3}{10} = \\frac{7}{15}。\n$$\n- 对于 $i = 3$，\n$$\n(P^{2})_{33} = P_{32} P_{23} + P_{34} P_{43} = \\frac{3}{5} \\cdot \\frac{1}{2} + \\frac{2}{5} \\cdot \\frac{3}{4} = \\frac{3}{10} + \\frac{3}{10} = \\frac{3}{5}。\n$$\n- 对于 $i = 4$，\n$$\n(P^{2})_{44} = P_{41} P_{14} + P_{43} P_{34} = \\frac{1}{4} \\cdot \\frac{2}{3} + \\frac{3}{4} \\cdot \\frac{2}{5} = \\frac{1}{6} + \\frac{3}{10} = \\frac{7}{15}。\n$$\n因此，对所有 $i \\in \\{1,2,3,4\\}$，都有 $(P^{2})_{ii} > 0$。\n\n接下来，注意到对于所有奇数 $n$，$(P^{n})_{ii} = 0$，因为一步是从 $A$ 移动到 $B$ 或从 $B$ 移动到 $A$，因此返回同一状态需要偶数步。对于 $n = 2$，我们已证明 $(P^{2})_{ii} > 0$；对于 $n = 4$，我们有 $(P^{4}) = (P^{2})^{2}$，并且相同的划分内正性意味着 $(P^{4})_{ii} \\geq (P^{2})_{ii}^{2} > 0$，通过迭代两步转移，对于任何偶数 $n$ 也是类似的。因此，返回状态 $i$ 的时间集合包括所有大于等于2的偶数，并且不包括任何奇数。集合 $\\{2,4,6,\\dots\\}$ 的最大公约数是 $2$。因此，对于每个 $i \\in \\{1,2,3,4\\}$，\n$$\nd(i) \\;=\\; 2.\n$$\n\n我们现在验证不可约性。我们必须证明对于任何状态 $i,j$，都存在 $n \\geq 1$ 使得 $(P^{n})_{ij} > 0$。\n- 如果 $i \\in A$ 且 $j \\in B$（或反之），通过直接观察 $P$ 可知 $(P)_{ij} > 0$：例如，$(P)_{12} = \\frac{1}{3} > 0$，$(P)_{14} = \\frac{2}{3} > 0$，$(P)_{32} = \\frac{3}{5} > 0$，$(P)_{34} = \\frac{2}{5} > 0$，从 $B$ 到 $A$ 的转移也类似。\n- 如果 $i,j$ 位于同一划分中，则 $(P^{2})_{ij} > 0$。例如，$(P^{2})_{13} = P_{12} P_{23} + P_{14} P_{43} = \\frac{1}{3} \\cdot \\frac{1}{2} + \\frac{2}{3} \\cdot \\frac{3}{4} = \\frac{1}{6} + \\frac{1}{2} = \\frac{2}{3} > 0$，以及 $(P^{2})_{24} = P_{21} P_{14} + P_{23} P_{34} = \\frac{1}{2} \\cdot \\frac{2}{3} + \\frac{1}{2} \\cdot \\frac{2}{5} = \\frac{1}{3} + \\frac{1}{5} = \\frac{8}{15} > 0$。类似的计算表明其他同划分状态对也具有正性。\n\n因此，对于每一对 $i,j$，都存在 $n \\in \\{1,2\\}$ 使得 $(P^{n})_{ij} > 0$。这证明了该链是不可约的。\n\n汇总结果，按状态顺序 $(1,2,3,4)$ 的周期都等于 $2$，不可约性指示符 $I$ 等于 $1$。\n\n所要求的最终答案是具有条目 $\\big(d(1), d(2), d(3), d(4), I\\big) = (2,2,2,2,1)$ 的行矩阵。",
            "answer": "$$\\boxed{\\begin{pmatrix} 2  2  2  2  1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "识别出周期性后，下一个自然的问题是：我们如何消除它，以及为什么要这样做？这个练习巧妙地阐释了这一点，它从一个确定性的循环（周期性最强的链）开始，然后展示一个微小的随机“扰动”如何使其变为非周期的。这个练习还将周期性与弛豫时间联系起来，揭示了非周期性对于确保蒙特卡洛方法快速收敛的关键作用。",
            "id": "3329433",
            "problem": "考虑一个定义在有限状态空间 $\\{0,1,\\dots,m-1\\}$ 上的离散时间马尔可夫链，该空间与循环群 $\\mathbb{Z}_{m}$ 等同。设其基准动力学为确定性旋转：从状态 $x$ 以概率 $1$ 转移到状态 $x+1 \\bmod m$。然后，通过引入到特殊状态 $0$ 的随机重置来修改此基准链：在每一步中，从任何当前状态 $x$，链以概率 $\\epsilon \\in (0,1)$ 移动到 $0$，并以概率 $1-\\epsilon$ 移动到 $x+1 \\bmod m$。将基准链的转移矩阵记为 $S$，修改后链的转移矩阵记为 $P$。\n\n使用以下基本定义和事实：\n- 一个离散时间马尔可夫链由一个转移矩阵 $P$ 指定，其元素非负且行和为 $1$，描述了状态之间转移的概率。\n- 状态 $i$ 的周期 $d(i)$ 定义为 $d(i) = \\gcd\\{n \\geq 1 : (P^{n})_{ii} > 0\\}$，其中 $(P^{n})_{ii}$ 是 $n$ 步转移矩阵 $P^{n}$ 的第 $i,i$ 项。在一个不可约链中，所有状态都具有相同的周期。\n- 弛豫时间 $\\tau_{\\mathrm{rel}}$ 通过第二大特征值模 (SLEM) 定义：如果 $1=\\lambda_{1}$ 是 $P$ 的 Perron 根，则 $\\tau_{\\mathrm{rel}} = \\frac{1}{1 - \\max\\{|\\lambda| : \\lambda \\in \\mathrm{spec}(P), \\lambda \\neq 1\\}}$，这里假设 $P$ 可对角化，或者更一般地，将 $\\max\\{|\\lambda| : \\lambda \\neq 1\\}$ 解释为 $P$ 的次主特征值的模。\n\n任务：\n1. 对于基准确定性旋转链 $S$（即 $\\epsilon = 0$），确定任意状态 $i \\in \\mathbb{Z}_{m}$ 的周期 $d(i)$。\n2. 对于修改后的链 $P$（其中 $\\epsilon \\in (0,1)$），证明其不可约性并确定任意状态 $i \\in \\mathbb{Z}_{m}$ 的周期 $d(i)$。\n3. 对于修改后的链 $P$，推导 $P$ 的所有特征值，并由此计算弛豫时间 $\\tau_{\\mathrm{rel}}$，作为 $\\epsilon$ 和 $m$ 的显式函数。\n\n将最终答案以单行矩阵的形式提供，按顺序包含三个条目：基准周期、修改后的周期和修改后的弛豫时间。不需要近似或四舍五入，也不涉及物理单位。",
            "solution": "该问题要求分析定义在状态空间 $\\mathbb{Z}_m = \\{0, 1, \\dots, m-1\\}$ 上的两个离散时间马尔可夫链。在验证问题设置后，我们将依次处理这三个任务。\n\n问题陈述定义明确、数学上合理且自洽。周期和弛豫时间的定义在马尔可夫链理论中是标准的。在从任何状态出发的转移概率之和必须为1的约束下，修改后链的动力学描述是明确的。对于任何状态 $x \\in \\{0, 1, \\dots, m-2\\}$，两个可能的下一个状态 $0$ 和 $x+1$ 是不同的。因此，转移是 $x \\to 0$（概率为 $\\epsilon$）和 $x \\to x+1$（概率为 $1-\\epsilon$）。对于状态 $x=m-1$，在确定性旋转下的下一个状态是 $(m-1)+1 \\pmod m = 0$。在这种情况下，重置和旋转这两种机制都导致相同的状态 $0$。因此，从 $m-1$ 转移到 $0$ 的总概率是 $\\epsilon + (1-\\epsilon) = 1$。因此，该问题是有效的。\n\n**任务1：基准链S的周期**\n\n基准链是 $\\mathbb{Z}_m$ 上的一个确定性旋转。从任何状态 $i$，链以概率 $1$ 移动到状态 $i+1 \\pmod m$。这是一个简单循环 $0 \\to 1 \\to \\dots \\to m-1 \\to 0$。\n\n状态 $i$ 的周期，记为 $d(i)$，由 $d(i) = \\gcd\\{n \\geq 1 : (S^n)_{ii} > 0\\}$ 给出，其中 $(S^n)_{ii}$ 是在恰好 $n$ 步后返回状态 $i$ 的概率。\n\n对于这个确定性循环，从状态 $i$ 开始，链在 $n$ 步后的状态是 $i+n \\pmod m$。为了让链返回到状态 $i$，必须有 $i+n \\equiv i \\pmod m$，这可以简化为 $n \\equiv 0 \\pmod m$。这意味着 $n$ 必须是 $m$ 的倍数。\n\n任何状态 $i$ 的可能返回时间集合是 $\\{m, 2m, 3m, \\dots\\}$。周期是这个集合的最大公约数 (GCD)。\n$$\nd(i) = \\gcd(\\{m, 2m, 3m, \\dots\\}) = m\n$$\n由于这对单个循环成立，所有状态都在一个单一的互通类中，并且它们都具有相同的周期。因此，任何状态 $i$ 的周期都是 $m$。\n\n**任务2：修改后链P的不可约性和周期**\n\n修改后的链的转移定义如下：从状态 $x$，链以概率 $\\epsilon \\in (0,1)$ 移动到 $0$，并以概率 $1-\\epsilon$ 移动到 $x+1 \\pmod m$。正如在验证阶段所确定的，对于 $x=m-1$，转移到状态 $0$ 的概率为 $1$。\n\n为了证明不可约性，我们必须证明可以从任何状态 $i$ 以正概率在有限步内到达任何状态 $j$。\n1.  从任何状态 $i \\in \\{0, 1, \\dots, m-2\\}$，存在一个到状态 $0$ 的转移，其概率为 $P_{i0} = \\epsilon > 0$。从状态 $m-1$，到状态 $0$ 的转移以概率 $P_{m-1,0}=1 > 0$ 发生。因此，状态 $0$ 从任何状态 $i \\in \\mathbb{Z}_m$ 都是可达的。\n2.  从状态 $0$，我们可以以概率 $P_{01}=1-\\epsilon > 0$ 到达状态 $1$。从状态 $1$，我们可以以概率 $P_{12}=1-\\epsilon > 0$ 到达状态 $2$。通过归纳法，我们可以通过连续 $j$ 次“旋转”步（$0 \\to 1 \\to \\dots \\to j$）从状态 $0$ 到达任何状态 $j \\in \\{1, \\dots, m-1\\}$。这条路径的概率是 $(1-\\epsilon)^j > 0$。状态 $0$ 可以以概率 $P_{00}=\\epsilon > 0$ 到达自身。因此，状态 $0$ 可以到达任何状态 $j \\in \\mathbb{Z}_m$。\n\n结合这两点，任何状态 $i$ 都可以通过先转移到状态 $0$（这总是可能的），然后再从状态 $0$ 转移到状态 $j$，从而到达任何其他状态 $j$。因此，该马尔可夫链是不可约的。\n\n对于一个不可约链，所有状态共享相同的周期 $d$。我们可以计算状态 $0$ 的周期。我们需要找到 $d(0) = \\gcd\\{n \\geq 1 : (P^n)_{00} > 0\\}$。\n从状态 $0$ 一步转移到其自身的概率是 $P_{00} = \\epsilon$。因为 $\\epsilon \\in (0,1)$，我们有 $P_{00} > 0$。\n这意味着 $n=1$ 是状态 $0$ 的一个可能的返回时间。返回时间集合 $\\{n \\geq 1: (P^n)_{00}>0\\}$ 包含整数 $1$。任何包含 $1$ 的正整数集合的最大公约数是 $1$。\n因此，$d(0) = \\gcd(\\{1, \\dots\\}) = 1$。\n由于链是不可约的，每个状态的周期都是 $d(i)=1$。周期为 $1$ 的链称为非周期链。\n\n**任务3：修改后链P的特征值和弛豫时间**\n\n修改后链的转移矩阵 $P$ 是：\n$$\nP_{ij} =\n\\begin{cases}\n\\epsilon  &\\text{当 } j=0, i \\in \\{0, \\dots, m-2\\} \\\\\n1-\\epsilon  &\\text{当 } j=i+1, i \\in \\{0, \\dots, m-2\\} \\\\\n1  &\\text{当 } j=0, i=m-1 \\\\\n0  &\\text{其他情况}\n\\end{cases}\n$$\n设 $v = (v_0, v_1, \\dots, v_{m-1})^T$ 是 $P$ 的一个特征向量，其特征值为 $\\lambda$。特征值方程 $Pv = \\lambda v$ 给出以下线性方程组：\n对于 $i \\in \\{0, 1, \\dots, m-2\\}$：$\\epsilon v_0 + (1-\\epsilon)v_{i+1} = \\lambda v_i$。\n对于 $i=m-1$：$v_0 = \\lambda v_{m-1}$。\n\n从 $i \\in \\{0, \\dots, m-2\\}$ 的一般方程，我们可以写出特征向量分量的递推关系：\n$v_{i+1} = \\frac{\\lambda v_i - \\epsilon v_0}{1-\\epsilon}$。\n这是一个关于 $v_i$ 的一阶线性非齐次递推关系。\n我们来分析 $\\lambda-1+\\epsilon = 0$ 的情况，即 $\\lambda = 1-\\epsilon$。递推关系变为 $v_{i+1} - v_i = -\\frac{\\epsilon v_0}{1-\\epsilon}$。这描述了一个等差数列。其解为 $v_i = v_0 - i \\frac{\\epsilon v_0}{1-\\epsilon}$。使用方程组的最后一个方程 $v_0 = \\lambda v_{m-1} = (1-\\epsilon)v_{m-1}$，我们得到 $v_0 = (1-\\epsilon) \\left(v_0 - (m-1)\\frac{\\epsilon v_0}{1-\\epsilon}\\right)$。假设 $v_0 \\neq 0$，我们有 $1 = (1-\\epsilon) - (m-1)\\epsilon = 1 - m\\epsilon$。这意味着 $m\\epsilon=0$，这是不可能的，因为 $m \\geq 1$ 且 $\\epsilon > 0$。因此，$\\lambda=1-\\epsilon$ 不是一个特征值。\n\n对于 $\\lambda \\neq 1-\\epsilon$，递推关系的解形式为 $v_i = A r^i + C$，其中 $r = \\frac{\\lambda}{1-\\epsilon}$ 是齐次部分特征方程的根，而 $C$ 是一个特解。我们求得 $C = \\frac{\\epsilon v_0}{\\lambda-1+\\epsilon}$。常数 $A$ 由 $i=0$ 处的初始条件确定：$v_0 = A+C$，这给出 $A = v_0 - C = v_0\\left(1-\\frac{\\epsilon}{\\lambda-1+\\epsilon}\\right) = v_0\\frac{\\lambda-1}{\\lambda-1+\\epsilon}$。\n所以，特征向量分量的通解是：\n$$\nv_i = v_0 \\frac{\\lambda-1}{\\lambda-1+\\epsilon} \\left(\\frac{\\lambda}{1-\\epsilon}\\right)^i + v_0 \\frac{\\epsilon}{\\lambda-1+\\epsilon}\n$$\n这也必须满足方程组的最后一个方程 $v_0 = \\lambda v_{m-1}$。代入 $i=m-1$ 并除以 $v_0$（假设 $v_0 \\neq 0$）：\n$$\n1 = \\lambda \\left[ \\frac{\\lambda-1}{\\lambda-1+\\epsilon} \\left(\\frac{\\lambda}{1-\\epsilon}\\right)^{m-1} + \\frac{\\epsilon}{\\lambda-1+\\epsilon} \\right]\n$$\n乘以 $\\lambda-1+\\epsilon$：\n$$\n\\lambda-1+\\epsilon = \\lambda (\\lambda-1) \\left(\\frac{\\lambda}{1-\\epsilon}\\right)^{m-1} + \\lambda\\epsilon\n$$\n$$\n(\\lambda-1) - \\epsilon(\\lambda-1) = (\\lambda-1) \\frac{\\lambda^m}{(1-\\epsilon)^{m-1}}\n$$\n$$\n(\\lambda-1)(1-\\epsilon) = (\\lambda-1) \\frac{\\lambda^m}{(1-\\epsilon)^{m-1}}\n$$\n这个方程有两类解。\n首先，如果 $\\lambda-1 = 0$，则 $\\lambda=1$。这是 Perron-Frobenius 特征值，对于任何随机矩阵都必须存在。\n其次，如果 $\\lambda \\neq 1$，我们可以除以 $(\\lambda-1)$：\n$$\n1-\\epsilon = \\frac{\\lambda^m}{(1-\\epsilon)^{m-1}} \\implies \\lambda^m = (1-\\epsilon)^m\n$$\n这个方程的解是 $\\lambda_k = (1-\\epsilon)\\omega^k$，其中 $k \\in \\{0, 1, \\dots, m-1\\}$，$\\omega = \\exp(2\\pi i/m)$ 是一个 $m$ 次单位主根。\n$k=0$ 时的解是 $\\lambda_0 = 1-\\epsilon$。然而，我们已经证明 $\\lambda=1-\\epsilon$ 不是一个特征值，因为它会导致矛盾。这个增根的出现是因为我们对 $v_i$ 的推导假设了 $\\lambda-1+\\epsilon \\neq 0$。\n因此，特征值是 $\\lambda=1$ 和 $\\lambda_k = (1-\\epsilon)\\omega^k$，其中 $k \\in \\{1, 2, \\dots, m-1\\}$。这给出了一组 $m$ 个不同的特征值。\n\n弛豫时间 $\\tau_{\\mathrm{rel}}$ 由第二大特征值模 (SLEM) 定义，它是除 Perron 根 $\\lambda=1$ 之外所有特征值的最大模。\n除 $1$ 以外的特征值是 $\\lambda_k = (1-\\epsilon)\\omega^k$，其中 $k=1, \\dots, m-1$。\n我们计算它们的模：\n$$\n|\\lambda_k| = |(1-\\epsilon)\\omega^k| = |1-\\epsilon| \\cdot |\\omega^k|\n$$\n因为 $\\epsilon \\in (0,1)$，所以 $|1-\\epsilon| = 1-\\epsilon$。因为 $\\omega^k$ 是一个单位根，所以 $|\\omega^k|=1$。\n所以，对于所有 $k \\in \\{1, \\dots, m-1\\}$，都有 $|\\lambda_k| = 1-\\epsilon$。\nSLEM 是 $\\max_{k \\in \\{1, \\dots, m-1\\}} |\\lambda_k| = 1-\\epsilon$。\n\n那么，弛豫时间是：\n$$\n\\tau_{\\mathrm{rel}} = \\frac{1}{1 - \\mathrm{SLEM}} = \\frac{1}{1 - (1-\\epsilon)} = \\frac{1}{\\epsilon}\n$$\n\n结果总结：\n1.  基准周期：$m$。\n2.  修改后周期：$1$。\n3.  修改后弛豫时间：$1/\\epsilon$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} m  1  \\frac{1}{\\epsilon} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在实际应用中，我们往往无法预先知道转移矩阵的完整信息，这使得周期性的分析变得困难。这个练习将理论与实践相结合，要求你设计一个自适应算法，该算法能从模拟路径中“学习”周期性，并在检测到周期性时自动切换到“懒惰”的非周期版本。通过实现这个在线检测和修正机制，你将掌握在现代MCMC方法中构建鲁棒模拟器的核心技术。",
            "id": "3329404",
            "problem": "考虑一个在有限状态空间 $\\mathcal{S} = \\{0,1,\\dots, n-1\\}$ 上的离散时间、时齐马尔可夫链，其转移矩阵为 $P \\in \\mathbb{R}^{n \\times n}$，其中对于所有 $i \\in \\mathcal{S}$，都有 $P(i,j) \\geq 0$ 且 $\\sum_{j=0}^{n-1} P(i,j) = 1$。状态 $i$ 的周期，记作 $d(i)$，定义为所有使得从 $i$ 到自身的 $n$ 步转移概率为正的正整数 $n$ 的最大公约数，即\n$$\nd(i) = \\gcd\\{\\, n \\in \\mathbb{N} \\,:\\, (P^n)(i,i) > 0 \\, \\}.\n$$\n如果 $d(i) = 1$，则状态 $i$ 是非周期的。如果一个马尔可夫链的所有状态都是非周期的（等价地，一个互通类中的所有状态的周期都为 $1$），则该马尔可夫链是非周期的。\n\n在流式模拟中，通常不直接计算 $(P^n)(i,i)$。相反，可以通过在线跟踪每个状态的观测返回时间来检测周期性。假设该链生成一条路径 $X_0, X_1, \\dots, X_T$，其中 $X_t \\in \\mathcal{S}$。对于每个状态 $i$，记录其访问时间 $\\tau_0^{(i)}, \\tau_1^{(i)}, \\dots$，在这些时间点上 $X_{\\tau_k^{(i)}} = i$，并定义观测到的返回时间间隔\n$$\nR_k^{(i)} = \\tau_k^{(i)} - \\tau_{k-1}^{(i)} \\quad \\text{for } k \\geq 1.\n$$\n通过递归定义周期估计 $d(i)$ 的流式更新，使用最大公约数运算\n$$\nd(i) \\leftarrow \\gcd\\big(d(i), R_k^{(i)}\\big),\n$$\n初始化为 $d(i) \\leftarrow 0$，并约定 $\\gcd(0, r) = r$。为减少有限样本效应导致的假阳性，在宣布一个状态为周期性之前，要求对该状态 $i$ 至少已观测到两次返回（即至少三次访问，从而至少有两个时间间隔 $R_k^{(i)}$ 被计入）。当任何状态 $i$ 在此流式更新下满足 $d(i) > 1$ 且至少有两次观测返回时，触发切换到惰性核。\n\n定义惰性核 $P_{\\ell}$ 为\n$$\nP_{\\ell} = \\tfrac{1}{2}\\,I + \\tfrac{1}{2}\\,P,\n$$\n其中 $I$ 是单位矩阵。在模拟时，惰性核意味着：以 $\\tfrac{1}{2}$ 的概率停留在当前状态，以 $\\tfrac{1}{2}$ 的概率根据 $P$ 进行移动。已知这种修改会产生一个非周期链，并保持 $P$ 的平稳分布。\n\n任务：设计并实现一个程序，该程序\n- 对每个测试用例，使用 $P$ 模拟一条路径 $X_0, X_1, \\dots, X_T$，从指定的初始状态 $X_0$ 开始，并在检测到任何状态 $i$ 满足 $d(i) > 1$ 且至少有两次观测返回时，立即切换到惰性核 $P_{\\ell}$。\n- 仅使用上述观测到的返回时间间隔，维护所有状态 $i \\in \\mathcal{S}$ 的流式估计 $d(i)$。\n- 对每个测试用例，报告一个布尔标志，指示是否发生了向 $P_{\\ell}$ 的切换；在切换的确切时刻，触发切换的状态的 $d(i)$ 的整数值（如果没有发生切换，则使用 $0$）；以及模拟结束后所有状态最终 $d(i)$ 值的整数最大值（如果一个状态从未被再次访问，其 $d(i)$ 保持为 $0$，则使用 $0$）。\n\n您必须在马尔可夫链蒙特卡洛（MCMC）的背景下实现此检测器和切换机制，此处理解为从马尔可夫链核进行模拟；当惰性核被激活时，通过将恒等移动与从 $P$ 的移动按规定混合来模拟下一步。\n\n测试套件：\n- 案例 $1$（周期性双状态链）：$P = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}$，$n = 2$，$T = 50$，初始状态 $X_0 = 0$。此链的状态周期为 $2$。\n- 案例 $2$（非周期性双状态链）：$P = \\begin{pmatrix} 0.7  0.3 \\\\ 0.4  0.6 \\end{pmatrix}$，$n = 2$，$T = 400$，初始状态 $X_0 = 0$。此链是不可约的非周期链，每个状态的周期为 $1$。使用固定的随机种子以确保可复现性。\n- 案例 $3$（周期性三状态循环）：$P = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 1  0  0 \\end{pmatrix}$，$n = 3$，$T = 60$，初始状态 $X_0 = 0$。此链的状态周期为 $3$。\n- 案例 $4$（没有返回起点的短时运行）：$P = \\begin{pmatrix} 0  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  1 \\\\ 1  0  0  0 \\end{pmatrix}$，$n = 4$，$T = 3$，初始状态 $X_0 = 0$。运行时间太短，无法再次访问起始状态，因此流式 $d(i)$ 可能保持为 $0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应一个测试用例，并且必须是 $[\\text{toggle\\_flag}, d_{\\text{at\\_toggle}}, \\max\\_d_{\\text{final}}]$ 的形式，其中 $\\text{toggle\\_flag}$ 是布尔值，$d_{\\text{at\\_toggle}}$ 和 $\\max\\_d_{\\text{final}}$ 是整数。例如：$[[\\text{True},2,1],[\\text{False},0,1],\\dots]$。\n\n不涉及物理单位，不适用角度，也不需要百分比；所有数值答案必须按规定表示为整数或布尔值。",
            "solution": "设计一个用于检测马尔可夫链周期性的流式检测器并切换到惰性核的问题是有效的。它在科学上基于随机过程和马尔可夫链蒙特卡洛（MCMC）方法的理论，问题定义良好，具有清晰的算法描述，并使用标准数学形式客观陈述。该问题是自包含的，并为指定的测试用例提供了所有必要的数据。\n\n该解决方案涉及模拟一个离散时间马尔可夫链，并为每个状态维护其周期的在线估计。此估计在每次返回该状态时更新。如果一个状态的估计周期变得大于 $1$ 并且已收集到足够的证据（至少两次返回），则通过从原始转移核 $P$ 切换到惰性核 $P_{\\ell}$ 来改变模拟动态。此过程执行固定的步数 $T$，并报告检测器的最终状态。\n\n### 1. 算法框架\n\n路径 $X_0, X_1, \\dots, X_T$ 的模拟是迭代执行的。对于从 $1$ 到 $T$ 的每个时间步 $t$，下一个状态 $X_t$ 基于当前状态 $X_{t-1}$ 和活动的转移核进行抽样。我们必须维护几个数据结构来跟踪每个状态 $i \\in \\mathcal{S} = \\{0, 1, \\dots, n-1\\}$ 的必要信息：\n\n- **上次访问时间, $\\text{last\\_visit\\_time}[i]$**：存储最近一次访问状态 $i$ 的时间步。对于 $i \\neq X_0$，初始化为 $-1$；对于 $i=X_0$，初始化为 $0$。\n- **访问次数, $\\text{visit\\_counts}[i]$**：计算访问状态 $i$ 的总次数。对所有 $i$ 初始化为 $0$，每次访问时递增。初始状态 $X_0$ 的计数从 $1$ 开始。\n- **估计周期, $d[i]$**：状态 $i$ 周期的流式估计。对所有 $i$ 初始化为 $0$。\n\n一个全局布尔标志 `toggle_flag` 初始化为 `False`，如果满足切换条件，则永久设置为 `True`。\n\n### 2. 模拟步骤与状态转移\n\n在每个时间步 $t \\in \\{1, \\dots, T\\}$，模拟按以下方式进行：\n\n1.  **选择核**：转移核的选择取决于 `toggle_flag`：\n    - 如果 `toggle_flag` 是 `False`，则使用标准转移矩阵 $P$。下一个状态 $X_t$ 从由行 $P(X_{t-1}, \\cdot)$ 给出的概率分布中抽取。\n    - 如果 `toggle_flag` 是 `True`，则使用惰性核 $P_{\\ell} = \\tfrac{1}{2}I + \\tfrac{1}{2}P$。这是通过抽取一个均匀随机数 $u \\in [0,1)$ 来实现的。如果 $u  0.5$，链保持在当前状态（$X_t = X_{t-1}$）。否则（如果 $u \\ge 0.5$），下一个状态 $X_t$ 从分布 $P(X_{t-1}, \\cdot)$ 中抽取。\n\n2.  **更新状态**：链的当前状态更新为 $X_t$。\n\n对于确定性情况（其中 $P$ 中的概率仅为 $0$ 或 $1$），“抽取”仅是选择转移概率为 $1$ 的唯一状态。对于随机性情况，则使用随机数生成器。为确保所有模拟的可复现性，在程序开始时设置一个固定的随机种子。\n\n### 3. 周期性检测与切换\n\n在时间 $t$ 转换到新状态 $X_t = i$ 后，更新状态 $i$ 的跟踪变量。\n\n1.  **更新访问数据**：`visit_counts[i]` 递增。如果这是一次返回访问（即 `visit_counts[i] > 1`），则计算观测到的返回时间间隔 $R^{(i)}$，即当前时间 $t$ 与 `last_visit_time[i]` 之间的差值。\n\n2.  **更新周期估计**：使用最大公约数（GCD）运算更新估计周期 $d[i]$：\n    $$\n    d[i] \\leftarrow \\gcd(d[i], R^{(i)})\n    $$\n    初始值为 $d[i]=0$，我们使用约定 $\\gcd(0, r) = r$ 对任何正整数 $r$ 成立。这确保了第一个观测到的返回时间间隔会初始化周期估计。\n\n3.  **更新上次访问时间**：`last_visit_time[i]` 设置为当前时间 $t$。\n\n4.  **检查切换条件**：如果 `toggle_flag` 仍为 `False`，我们检查当前状态 $i=X_t$ 是否满足切换条件：\n    - 估计周期 $d[i]$ 大于 $1$。\n    - 至少发生了两次对状态 $i$ 的返回，这等同于总访问次数 `visit_counts[i]` 至少为 $3$。\n\n    如果两个条件都满足，`toggle_flag` 设置为 `True`，并将在此时的 $d[i]$ 值记录为 $d_{\\text{at\\_toggle}}$。模拟将从下一步（$t+1$）开始使用惰性核 $P_{\\ell}$。\n\n### 4. 最终输出生成\n\n模拟运行 $T$ 步后，该测试用例的结果被汇编成一个列表 $[\\text{toggle\\_flag}, d_{\\text{at\\_toggle}}, \\max\\_d_{\\text{final}}]$。\n- `toggle_flag`：布尔标志的最终状态，指示是否发生了切换。\n- $d_{\\text{at\\_toggle}}$：在切换发生时，触发切换的状态的周期估计。如果没有发生切换，此值为 $0$。\n- $\\max\\_d_{\\text{final}}$：所有最终估计周期 $\\{d[0], d[1], \\dots, d[n-1]\\}$ 中的最大值。如果一个状态从未被再次访问，其周期估计保持为其初始值 $0$。\n\n对问题陈述中提供的每个测试用例重复整个过程。然后将收集到的结果格式化为所需的单行字符串输出。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # A single fixed random seed for reproducibility of all stochastic parts.\n    np.random.seed(42)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"P\": np.array([[0, 1], [1, 0]], dtype=float),\n            \"n\": 2,\n            \"T\": 50,\n            \"X0\": 0,\n        },\n        {\n            \"P\": np.array([[0.7, 0.3], [0.4, 0.6]], dtype=float),\n            \"n\": 2,\n            \"T\": 400,\n            \"X0\": 0,\n        },\n        {\n            \"P\": np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]], dtype=float),\n            \"n\": 3,\n            \"T\": 60,\n            \"X0\": 0,\n        },\n        {\n            \"P\": np.array([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]], dtype=float),\n            \"n\": 4,\n            \"T\": 3,\n            \"X0\": 0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case[\"P\"], case[\"n\"], case[\"T\"], case[\"X0\"])\n        results.append(result)\n\n    # Format the results into the exact required string format.\n    formatted_results = [f\"[{str(r[0])},{r[1]},{r[2]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_simulation(P, n, T, X0):\n    \"\"\"\n    Simulates a Markov chain with an online periodicity detector.\n\n    Args:\n        P (np.ndarray): The transition matrix.\n        n (int): The number of states.\n        T (int): The total number of simulation steps (path length will be T+1).\n        X0 (int): The initial state.\n\n    Returns:\n        list: A list containing [toggle_flag, d_at_toggle, max_d_final].\n    \"\"\"\n    current_state = X0\n    \n    # Data structures for tracking state visits and period estimates\n    last_visit_time = {i: -1 for i in range(n)}\n    visit_counts = {i: 0 for i in range(n)}\n    estimated_periods = {i: 0 for i in range(n)}\n    \n    # Output variables\n    toggle_flag = False\n    d_at_toggle = 0\n    \n    # Process initial state at t=0\n    last_visit_time[X0] = 0\n    visit_counts[X0] = 1\n    \n    states_range = np.arange(n)\n\n    for t in range(1, T + 1):\n        # 1. Determine next state based on the active kernel\n        if toggle_flag:\n            # Lazy kernel P_l = 0.5*I + 0.5*P\n            if np.random.rand()  0.5:\n                next_state = current_state\n            else:\n                p_dist = P[current_state]\n                next_state = np.random.choice(states_range, p=p_dist)\n        else:\n            # Standard kernel P\n            p_dist = P[current_state]\n            next_state = np.random.choice(states_range, p=p_dist)\n\n        current_state = next_state\n        \n        # 2. Update statistics for the newly visited state\n        i = current_state\n        \n        # Check if it's a return visit to update period estimate\n        if visit_counts[i] > 0:\n            return_interval = t - last_visit_time[i]\n            \n            # The streaming GCD update. math.gcd(0, r) = r, fulfilling the requirement.\n            old_d = estimated_periods[i]\n            if return_interval > 0:\n                estimated_periods[i] = math.gcd(old_d, return_interval)\n\n        last_visit_time[i] = t\n        visit_counts[i] += 1\n\n        # 3. Check for toggle condition if not already toggled\n        if not toggle_flag:\n            # Condition: d(i) > 1 AND at least 2 returns (i.e., 3 visits)\n            num_returns = visit_counts[i] - 1\n            if num_returns >= 2 and estimated_periods[i] > 1:\n                toggle_flag = True\n                d_at_toggle = estimated_periods[i]\n                \n    # 4. Finalize results after the simulation ends\n    max_d_final = 0\n    if estimated_periods:\n        max_d_final = max(estimated_periods.values())\n\n    return [toggle_flag, d_at_toggle, max_d_final]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}