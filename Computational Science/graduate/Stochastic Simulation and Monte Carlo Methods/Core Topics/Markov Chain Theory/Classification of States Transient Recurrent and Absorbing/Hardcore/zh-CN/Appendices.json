{
    "hands_on_practices": [
        {
            "introduction": "现实世界中的许多系统（如队列或种群模型）最好用无限状态空间来描述，但计算机模拟本质上是有限的。这项练习旨在帮助你弥合这一理论与实践的差距，通过分析方法推导截断这种近似所引入的偏差 。通过解决这个问题，你将能够在一个具有挑战性但基础性的情境中，巩固对暂态和吸收概率等核心定义的理解。",
            "id": "3295771",
            "problem": "考虑一个在可数状态空间 $\\{0,1,2,\\dots\\}$ 上的离散时间生灭马尔可夫链，其转移概率定义如下。对于每个状态 $k \\ge 1$，链以概率 $q \\in (1/2,1)$ 移动到 $k-1$，并以概率 $p = 1 - q \\in (0,1/2)$ 移动到 $k+1$。状态 $0$ 是吸收态。根据状态分类的核心定义，论证状态 $0$ 是一个吸收态，并且对于该链，每个状态 $i \\in \\{1,2,\\dots\\}$ 都是暂态的。现在，对于一个固定的有限截断 $N \\in \\mathbb{N}$（其中 $N \\ge 2$），定义一个在 $\\{0,1,\\dots,N\\}$ 上的截断链，该链在 $\\{1,\\dots,N-1\\}$ 上以相同的局部转移概率演化，但将 $0$ 和 $N$ 都视为吸收态。令 $\\alpha_i$ 表示从 $i \\in \\{1,\\dots,N-1\\}$ 开始的无限状态链在 $0$ 处的真实吸收概率，并令 $\\widehat{\\alpha}_i^{(N)}$ 表示从相同的 $i$ 开始的截断链在 $0$ 处的吸收概率。\n\n仅使用首步分析以及无限状态链和截断链之间的单调耦合，推导截断偏差 $\\alpha_i - \\widehat{\\alpha}_i^{(N)}$ 的一个可计算的紧上界 $b_{i,N}$，该上界仅依赖于 $p$, $q$, $i$ 和 $N$。你的界必须表示为单个闭式解析表达式。以 $p$, $q$, $i$ 和 $N$ 的形式提供此界作为你的最终答案。不要给出不等式；只给出可由该耦合论证证明的最小的 $b_{i,N}$ 的表达式。不需要进行数值评估，也不需要四舍五入。",
            "solution": "问题要求验证其前提，如果前提有效，则推导生灭过程截断偏差的一个紧上界。\n\n**问题验证**\n\n首先，对问题陈述进行严格验证。\n\n*   **已知条件：**\n    *   **无限链：** 一个在状态空间 $S = \\{0, 1, 2, \\dots\\}$ 上的离散时间生灭马尔可夫链。\n    *   对于 $k \\ge 1$ 的转移概率：$P(k \\to k-1) = q$ 和 $P(k \\to k+1) = p$，其中 $p=1-q$。\n    *   状态 $0$ 是吸收态：$P(0 \\to 0) = 1$。\n    *   参数约束：$q \\in (1/2, 1)$，意味着 $p \\in (0, 1/2)$。\n    *   **截断链：** 一个在 $S_N = \\{0, 1, \\dots, N\\}$ 上的马尔可夫链，其中 $N \\ge 2$。\n    *   对于 $k \\in \\{1, \\dots, N-1\\}$ 的转移概率与无限链相同。\n    *   状态 $0$ 和 $N$ 是吸收态。\n    *   **关注量：**\n        *   $\\alpha_i$：从状态 $i$ 开始的无限链在状态 $0$ 处的吸收概率。\n        *   $\\widehat{\\alpha}_i^{(N)}$：从状态 $i$ 开始的截断链在状态 $0$ 处的吸收概率。\n        *   $b_{i,N}$：截断偏差 $\\alpha_i - \\widehat{\\alpha}_i^{(N)}$ 的一个紧上界。\n*   **验证结论：** 该问题具有科学依据，提法明确，且客观。它描述了一个标准的生灭过程，这是随机过程理论的基石。指定的漂移条件 $q > p$ 至关重要且定义明确。所有术语都是标准的，目标清晰。这个问题是马尔可夫链分析中一个不平凡但可解的练习，特别涉及到某个过程与其截断版本的比较。它不违反任何无效性标准。因此，该问题被认定为**有效**。\n\n**求解推导**\n\n求解过程将分三个阶段进行：(1) 对无限链的状态进行分类，(2) 使用首步分析推导截断偏差的精确表达式，以及 (3) 结合结果确定最紧的上界。\n\n**1. 无限链中的状态分类**\n\n根据定义，状态 $0$ 是吸收态，因为链一旦进入就无法离开。为了对状态 $i \\in \\{1, 2, \\dots\\}$进行分类，我们确定 $\\alpha_i$，即从状态 $i$ 开始最终被 $0$ 吸收的概率。问题指定使用单调耦合论证。\n\n考虑这样一个无限链族，其由向上转移概率 $p \\in (0, 1/2]$ 参数化。令 $\\alpha_i(p)$ 为参数为 $p$ 的链从 $i$ 开始在 $0$ 处被吸收的概率。设 $p_1, p_2$ 是两个这样的参数，且 $p_1  p_2$。令 $X_n^{(1)}$ 和 $X_n^{(2)}$ 分别是参数为 $p_1$ 和 $p_2$ 的链，两者都从 $X_0^{(1)} = X_0^{(2)} = i$ 开始。我们可以使用一个独立同分布的均匀随机变量序列 $U_n \\sim U(0,1)$ 来耦合它们的演化。从 $k>0$ 的状态更新是 $U_{n+1}$ 的函数：如果 $U_{n+1}  p$ 则为 $+1$，如果 $U_{n+1} \\ge p$ 则为 $-1$。\n由于 $p_1  p_2$，增量 $\\Delta X_n^{(1)}$ 总是小于或等于增量 $\\Delta X_n^{(2)}$。这就为所有 $n \\ge 0$ 建立了一个路径序 $X_n^{(1)} \\le X_n^{(2)}$。\n\n这个序关系意味着向上漂移较小的过程更有可能被 $0$ 吸收。因此，$\\alpha_i(p)$ 是 $p$ 的非增函数。对于 $p=1/2$ 的对称随机游走这一特殊情况，一个标准结果是 $\\{0, 1, \\dots\\}$ 上的链是零常返的，这保证了它将以概率 $1$ 到达状态 $0$。因此，$\\alpha_i(1/2) = 1$。\n\n鉴于 $\\alpha_i(p)$ 是非增的，对于我们的情况 $p = 1-q  1/2$，我们必然有 $\\alpha_i(p) \\ge \\alpha_i(1/2) = 1$。由于 $\\alpha_i(p)$ 是一个概率，它不能超过 $1$。因此，我们得出结论：对于所有 $p \\in (0, 1/2]$，$\\alpha_i(p)=1$。\n\n对于我们的链，这意味着对所有 $i \\ge 1$，都有 $\\alpha_i = 1$。如果从一个状态出发，将来能返回到它的概率小于 $1$，则该状态是暂态的。由于任何状态 $i \\ge 1$ 都以概率 $1$ 被 $0$ 吸收，它只能访问状态 $i$ 有限次。因此，每个状态 $i \\in \\{1, 2, \\dots\\}$ 都是暂态的。\n\n**2. 截断偏差分析**\n\n令截断偏差为 $\\epsilon_i = \\alpha_i - \\widehat{\\alpha}_i^{(N)}$。我们使用首步分析来找到 $\\epsilon_i$ 的表达式。\n对于无限链，吸收概率满足：对于 $i \\ge 1$，$\\alpha_i = p \\alpha_{i+1} + q \\alpha_{i-1}$，边界条件为 $\\alpha_0 = 1$。\n\n对于截断链，在 $0$ 处的吸收概率满足：对于 $i \\in \\{1, \\dots, N-1\\}$，$\\widehat{\\alpha}_i^{(N)} = p \\widehat{\\alpha}_{i+1}^{(N)} + q \\widehat{\\alpha}_{i-1}^{(N)}$，边界条件为 $\\widehat{\\alpha}_0^{(N)} = 1$ 和 $\\widehat{\\alpha}_N^{(N)} = 0$。\n\n对于 $i \\in \\{1, \\dots, N-1\\}$，将第二个方程从第一个方程中减去，得到偏差 $\\epsilon_i$ 的递推关系：\n$\\epsilon_i = p \\epsilon_{i+1} + q \\epsilon_{i-1}$。\n这是相同的齐次递推关系。我们需要确定 $\\epsilon_i$ 的边界条件。\n在 $i=0$ 处：$\\epsilon_0 = \\alpha_0 - \\widehat{\\alpha}_0^{(N)} = 1 - 1 = 0$。\n在 $i=N$ 处：$\\epsilon_N = \\alpha_N - \\widehat{\\alpha}_N^{(N)} = \\alpha_N - 0 = \\alpha_N$。\n\n现在，寻找 $\\epsilon_i$ 的问题等价于状态空间 $\\{0, 1, \\dots, N\\}$ 上的一个经典赌徒破产问题，所求的是“获胜”（在到达状态 $0$ 之前到达状态 $N$）的概率。该递推关系的通解为 $\\epsilon_i = A \\cdot 1^i + B \\cdot (q/p)^i$。\n应用边界条件：\n对于 $i=0$：$A + B = \\epsilon_0 = 0 \\implies A = -B$。\n对于 $i=N$：$A + B(q/p)^N = \\epsilon_N$。\n将 $A=-B$ 代入第二个方程得到：\n$-B + B(q/p)^N = \\epsilon_N \\implies B \\left( (q/p)^N - 1 \\right) = \\epsilon_N \\implies B = \\frac{\\epsilon_N}{(q/p)^N - 1}$。\n因此，偏差的解为：\n$\\epsilon_i = \\frac{\\epsilon_N}{(q/p)^N - 1} \\left( (q/p)^i - 1 \\right)$。\n\n**3. 最终上界表达式**\n\n将 $\\epsilon_N = \\alpha_N$ 代入 $\\epsilon_i$ 的表达式，得到精确的截断偏差：\n$\\alpha_i - \\widehat{\\alpha}_i^{(N)} = \\alpha_N \\frac{(q/p)^i - 1}{(q/p)^N - 1}$。\n这个偏差的表达式是可以通过指定方法证明的。问题要求一个仅依赖于 $p, q, i, N$ 的可计算的紧上界 $b_{i,N}$。为此，我们必须代入 $\\alpha_N$ 的值。\n在第 1 部分，我们使用单调耦合论证严格地证明了对于所有初始状态 $i \\ge 1$，都有 $\\alpha_i=1$。特别地，对于状态 $N \\ge 2$，我们有 $\\alpha_N=1$。\n\n将 $\\alpha_N=1$ 代入精确的偏差公式得到：\n$\\alpha_i - \\widehat{\\alpha}_i^{(N)} = \\frac{(q/p)^i - 1}{(q/p)^N - 1}$。\n这个表达式是截断偏差的精确值。因此，它是偏差可能的最紧上界，并且它只依赖于给定的参数 $p, q, i, N$。这就是所要求的 $b_{i,N}$ 的表达式。\n\n边界 $b_{i,N}$ 的最终表达式：\n令 $\\rho = q/p$。表达式为 $\\frac{\\rho^i - 1}{\\rho^N - 1}$。",
            "answer": "$$\\boxed{\\frac{\\left(\\frac{q}{p}\\right)^i - 1}{\\left(\\frac{q}{p}\\right)^N - 1}}$$"
        },
        {
            "introduction": "在理论分析之后，我们将转向计算实践。这项练习要求你编写代码，根据马尔可夫链的图结构对状态进行分类 。它直面一个常见的实际挑战：数值近似（如欧拉离散化）可能会改变模型的根本性质，甚至产生虚假的人为吸收态，而本练习将教你如何检测这些问题。",
            "id": "3295807",
            "problem": "考虑一个有限状态、连续时间的马尔可夫跳跃过程，其生成元矩阵为 $Q \\in \\mathbb{R}^{n \\times n}$，其中对于 $i \\ne j$ 有 $q_{ij} \\ge 0$，且每行之和为零，即 $\\sum_{j=1}^{n} q_{ij} = 0$。在时间步长 $\\Delta t > 0$ 下的离散时间骨架，其转移矩阵为 $P_{\\mathrm{exact}}(\\Delta t) = \\exp(Q \\Delta t)$，即 $Q \\Delta t$ 的矩阵指数。在实践中，通常使用一阶欧拉离散化 $P_{\\mathrm{raw}}(\\Delta t) = I + \\Delta t \\, Q$。为了强制随机性并处理数值稀疏化，应用了一种带有容差 $\\tau > 0$ 的启发式阈值化-重归一化方案，具体如下：\n- 阈值化：对于每个元素，如果 $(P_{\\mathrm{raw}}(\\Delta t))_{ij}  \\tau$，则将其设置为 $0$。\n- 重归一化：对于每一行 $i$，计算阈值化后的行和 $s_i = \\sum_{j=1}^{n} (P_{\\mathrm{raw}}(\\Delta t))_{ij}$。如果 $s_i > 0$，则设置 $(P_{\\mathrm{EC}})_{ij} = (P_{\\mathrm{raw}}(\\Delta t))_{ij} / s_i$。如果 $s_i = 0$，则将该行设置为第 $i$ 个标准基向量（即 $(P_{\\mathrm{EC}})_{ii} = 1$ 且对于 $j \\ne i$ 有 $(P_{\\mathrm{EC}})_{ij} = 0$）。将得到的矩阵记为 $P_{\\mathrm{EC}}(\\Delta t,\\tau)$。\n\n状态分类的定义如下。\n- 对于具有生成元 $Q$ 的连续时间马尔可夫链 (CTMC)，在 $\\{1,\\dots,n\\}$ 上构建一个有向图，当且仅当对于 $i \\ne j$ 有 $q_{ij} > 0$ 时，存在一条边 $i \\to j$。一个互通类是该图的一个强连通分量。如果一个类中没有任何状态到类外任何状态的边，则该类是闭合的。如果对于所有 $j \\ne i$ 都有 $q_{ij} = 0$（等价于 $q_{ii} = 0$），则状态 $i$ 是吸收的。如果一个状态位于一个闭合的互通类中，则它是常返的；否则它是暂态的。\n- 对于任何具有转移矩阵 $P$ 的离散时间马尔可夫链 (DTMC)（例如，$P_{\\mathrm{exact}}$ 或 $P_{\\mathrm{EC}}$），在 $\\{1,\\dots,n\\}$ 上构建一个有向图，当且仅当 $p_{ij} > 0$ 时，存在一条边 $i \\to j$。使用相同的互通类定义。如果 $p_{ii} = 1$ 且对于所有 $j \\ne i$ 都有 $p_{ij} = 0$，则状态 $i$ 是吸收的。如果一个状态位于一个闭合的互通类中，则它是常返的；否则它是暂态的。\n\n你的任务是实现一个程序，针对给定的几个测试用例，比较 CTMC 及其两种离散化 $P_{\\mathrm{exact}}(\\Delta t)$ 和 $P_{\\mathrm{EC}}(\\Delta t,\\tau)$ 的状态分类，并通过蒙特卡洛模拟估计返回概率，从而实证研究阈值化的影响。\n\n从第一性原理出发：生成元 $Q$ 的定义、骨架 $P_{\\mathrm{exact}}(\\Delta t)$ 的定义，以及基于图论的暂态、常返和吸收状态的分类。除了这些定义之外，不要假设任何简化的分类公式。你必须实现：\n- 一个使用矩阵指数的精确离散化子程序。\n- 按规定实现的带阈值化的欧拉离散化 $P_{\\mathrm{EC}}(\\Delta t,\\tau)$。\n- 一个基于图的分类器，用于将 $Q$ 和任何 $P$ 的每个状态标记为三类之一：吸收态、常返非吸收态或暂态。\n- 一个蒙特卡洛估计器，用于计算在给定 $P$ 的情况下，一条从状态 $1$（状态索引为 $1,2,\\dots,n$）开始的轨迹，在 $N_{\\mathrm{steps}}$ 步的固定时间范围内，在某个时间 $k \\ge 1$ 返回到状态 $1$ 的概率。为了可复现性，请使用固定的路径数 $N_{\\mathrm{paths}}$ 和固定的随机种子。\n\n对于每个测试用例，计算以下三个量：\n1. $k_{\\mathrm{art}}$：在 $P_{\\mathrm{EC}}(\\Delta t,\\tau)$ 下是吸收态，但在 CTMC 生成元 $Q$ 下不是吸收态的状态数量。\n2. $k_{\\mathrm{chg}}$：在 $P_{\\mathrm{EC}}(\\Delta t,\\tau)$ 下的分类标签（在 $\\{\\text{暂态}, \\text{常返非吸收}, \\text{吸收}\\}$ 中）与在 CTMC 生成元 $Q$ 下的分类标签不同的状态数量。\n3. $\\Delta r$：在 $P_{\\mathrm{EC}}(\\Delta t,\\tau)$ 和 $P_{\\mathrm{exact}}(\\Delta t)$ 下，通过蒙特卡洛估计的返回状态 $1$ 的概率之差，即 $\\Delta r = \\widehat{\\mathbb{P}}_{\\mathrm{EC}}(\\text{返回状态 }1) - \\widehat{\\mathbb{P}}_{\\mathrm{exact}}(\\text{返回状态 }1)$。将 $\\Delta r$ 四舍五入到三位小数。\n\n使用以下测试套件。在每种情况下，状态索引为 $1,2,\\dots,n$，其中 $n$ 由 $Q$ 隐式给出：\n- 测试 1（不可约的两状态 CTMC，小时间步长大阈值）：\n  - $Q = \\begin{bmatrix} -3  3 \\\\ 4  -4 \\end{bmatrix}$, $\\Delta t = 0.01$, $\\tau = 0.05$。\n- 测试 2（相同的 CTMC，中等时间步长和微小阈值）：\n  - $Q = \\begin{bmatrix} -3  3 \\\\ 4  -4 \\end{bmatrix}$, $\\Delta t = 0.2$, $\\tau = 0.001$。\n- 测试 3（带有一个真实吸收态的三状态链）：\n  - $Q = \\begin{bmatrix} -1  1  0 \\\\ 0  -1  1 \\\\ 0  0  0 \\end{bmatrix}$, $\\Delta t = 0.1$, $\\tau = 10^{-4}$。\n- 测试 4（相同的三状态链，极小时间步长和大阈值，产生人为的自环）：\n  - $Q = \\begin{bmatrix} -1  1  0 \\\\ 0  -1  1 \\\\ 0  0  0 \\end{bmatrix}$, $\\Delta t = 0.001$, $\\tau = 0.05$。\n\n蒙特卡洛参数必须固定为 $N_{\\mathrm{paths}} = 5000$，$N_{\\mathrm{steps}} = 200$，随机种子为 $12345$。事件“返回状态 $1$”定义为在时间 $0$ 从状态 $1$ 出发后，在任何时间步 $k \\in \\{1,2,\\dots,N_{\\mathrm{steps}}\\}$ 访问状态 $1$。\n\n你的程序应该生成单行输出，其中包含所有测试用例的结果，格式为一个逗号分隔的三元组列表，并用方括号括起来，每个三元组的顺序为 $[k_{\\mathrm{art}}, k_{\\mathrm{chg}}, \\Delta r]$，按测试 1 到 4 的顺序排列，即输出形式为 $[[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot]]$。所有量都是无量纲的，并且必须以数字形式打印（其中 $\\Delta r$ 四舍五入到三位小数）。",
            "solution": "该问题要求对一个连续时间马尔可夫链 (CTMC) 及其两种离散时间近似的状态分类进行比较分析。这涉及到实现基于图的分类算法、数值矩阵运算和蒙特卡洛模拟。该问题具有科学依据，提法明确，并提供了所有必要的参数和定义。我将继续提供完整的解决方案。\n\n问题的核心在于将马尔可夫链的状态正确分类为暂态、常返非吸收或吸收。所提供的定义基于链的图结构。\n\n**1. 状态分类算法**\n\n状态的分类依赖于互通类和闭合类的概念。一个互通类是状态空间图的一个强连通分量 (SCC)。如果一个类中的任何状态都不能转移到该类之外的任何状态，则该类是闭合的。如果一个状态属于一个闭合的互通类，则它是常返的，否则是暂态的。吸收态是常返态的一个特例，它形成一个大小为一的闭合类。\n\n设 $n$ 为状态数。\n对于给定的矩阵（CTMC 的 $Q$ 或 DTMC 的 $P$），算法流程如下：\n1.  **构建邻接表：** 在状态 $\\{1, \\dots, n\\}$ 上构建一个有向图。\n    -   对于 CTMC 生成元 $Q$，当且仅当转移率 $q_{ij} > 0$ ($i \\neq j$) 时，存在一条从状态 $i$ 到 $j$ 的边。\n    -   对于 DTMC 转移矩阵 $P$，当且仅当转移概率 $p_{ij} > 0$ 时，存在一条从 $i$ 到 $j$ 的边。\n2.  **查找强连通分量 (SCCs)：** 我们使用 Tarjan 算法（一种基于深度优先搜索的方法）来查找图的所有 SCC。每个 SCC 都是一个互通类。\n3.  **识别闭合类：** 对于每个 SCC，我们检查它是否是闭合的。如果一个 SCC 中没有任何组成状态到该 SCC 之外的任何状态存在出边，则该 SCC 是闭合的。\n4.  **分类状态：** 根据以下层次结构对每个状态 $i \\in \\{1, \\dots, n\\}$ 进行分类：\n    a.  **吸收态：** 如果状态 $i$ 是一个汇点 (sink)，则它是吸收态。对于 CTMC，这定义为 $q_{ii} = 0$，这意味着对于所有 $j \\neq i$ 都有 $q_{ij} = 0$。对于 DTMC，这定义为 $p_{ii} = 1$。\n    b.  **常返非吸收态：** 如果一个状态 $i$ 不是吸收态，但属于一个闭合的互通类，则它被分类为常返非吸收态。\n    c.  **暂态：** 如果一个状态 $i$ 既不是吸收态也不是常返非吸收态，则它是暂态的。这意味着它属于一个非闭合的互通类，意味着存在一条路径可以离开该类。\n\n**2. 离散化方案**\n\n考虑了两种离散化方案：\n\n-   **精确离散化 ($P_{\\mathrm{exact}}$)：** 在时间步长 $\\Delta t > 0$ 内，离散时间骨架的转移矩阵由矩阵指数给出：\n    $$P_{\\mathrm{exact}}(\\Delta t) = \\exp(Q \\Delta t)$$\n    这可以使用 `scipy.linalg.expm` 来计算。\n\n-   **带修正的欧拉方法 ($P_{\\mathrm{EC}}$)：** 这是一种启发式方案，包括三个步骤：\n    1.  **欧拉步骤：** 进行一阶近似：$P_{\\mathrm{raw}}(\\Delta t) = I + \\Delta t \\, Q$，其中 $I$ 是单位矩阵。\n    2.  **阈值化：** 移除小的元素，这些元素可能是数值噪声或虽小但真实的概率。给定一个容差 $\\tau > 0$，任何小于 $\\tau$ 的元素 $(P_{\\mathrm{raw}})_{ij}$ 都被设置为 $0$。\n    3.  **重归一化：** 为了恢复随机性（行和为 $1$），每一行都被重新归一化。对于每一行 $i$，令 $s_i$ 为其阈值化后的和。\n        -   如果 $s_i > 0$，则行中的每个元素都除以 $s_i$，得到 $(P_{\\mathrm{EC}})_{ij} = (P_{\\mathrm{raw}})_{ij} / s_i$。\n        -   如果 $s_i = 0$（行中的所有元素都被阈值化为零），则该状态变为吸收态：$(P_{\\mathrm{EC}})_{ii} = 1$ 且对于 $j \\neq i$ 有 $(P_{\\mathrm{EC}})_{ij} = 0$。\n\n**3. 返回概率的蒙特卡洛估计**\n\n我们估计从状态 $1$（索引为 $0$）开始的轨迹在任何时间步 $k \\in \\{1, 2, \\dots, N_{\\mathrm{steps}}\\}$ 再次访问状态 $1$ 的概率。这是事件 $\\bigcup_{k=1}^{N_{\\mathrm{steps}}} \\{X_k=1\\} \\mid X_0=1$ 的概率。\n\n该估计通过蒙特卡洛模拟进行，使用 $N_{\\mathrm{paths}}$ 条轨迹，每条轨迹最多模拟 $N_{\\mathrm{steps}}$ 步。\n1.  初始化返回路径的计数器，`return_count = 0`。固定的随机种子确保可复现性。\n2.  对于 $N_{\\mathrm{paths}}$ 次模拟中的每一次：\n    a.  在 `current_state = 0`（对于状态 1）开始轨迹。\n    b.  对于从 $1$ 到 $N_{\\mathrm{steps}}$ 的每个时间步：\n        i.  从由转移矩阵 $P$ 的 `current_state` 行定义的分类分布中抽样 `next_state`。\n        ii. 如果 `next_state` 是 $0$，则轨迹已返回。将此路径标记为成功并中断内循环以开始下一条路径。\n        iii. 更新 `current_state = next_state`。\n    c.  如果路径成功，则增加 `return_count`。\n3.  估计的概率为 $\\widehat{\\mathbb{P}} = \\text{return\\_count} / N_{\\mathrm{paths}}$。\n\n**4. 分析与计算**\n\n对于每个测试用例，我们执行以下计算：\n-   确定 CTMC ($Q$) 和 $P_{\\mathrm{EC}}$ 近似的状态分类数组。\n-   $k_{\\mathrm{art}}$：人为吸收态的数量。这是在 $P_{\\mathrm{EC}}$ 下是吸收态但在 $Q$ 下不是吸收态的状态数。\n-   $k_{\\mathrm{chg}}$：分类发生变化的状态数量。通过逐元素比较 $Q$ 和 $P_{\\mathrm{EC}}$ 的分类数组来找到。\n-   $\\Delta r$：估计的返回概率之差。我们通过蒙特卡洛计算 $\\widehat{\\mathbb{P}}_{\\mathrm{EC}}(\\text{返回})$ 和 $\\widehat{\\mathbb{P}}_{\\mathrm{exact}}(\\text{返回})$，并计算 $\\Delta r = \\widehat{\\mathbb{P}}_{\\mathrm{EC}} - \\widehat{\\mathbb{P}}_{\\mathrm{exact}}$，四舍五入到三位小数。\n\n这些步骤被系统地应用于所提供的四个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef get_classification(M, is_ctmc):\n    \"\"\"\n    Classifies states of a Markov chain as 'absorbing', 'recurrent non-absorbing', or 'transient'.\n\n    Args:\n        M (np.ndarray): The generator matrix Q (if is_ctmc) or transition matrix P.\n        is_ctmc (bool): True for CTMC (Q), False for DTMC (P).\n\n    Returns:\n        list[str]: A list of classification labels for each state.\n    \"\"\"\n    n = M.shape[0]\n\n    # 1. Build adjacency list based on the graph definition\n    adj = [[] for _ in range(n)]\n    if is_ctmc: # Graph from Q\n        for i in range(n):\n            for j in range(n):\n                if i != j and M[i, j] > 0:\n                    adj[i].append(j)\n    else: # Graph from P\n        for i in range(n):\n            for j in range(n):\n                if M[i, j] > 0:\n                    # Self-loops are part of the graph for DTMCs\n                    adj[i].append(j)\n\n    # 2. Find Strongly Connected Components (SCCs) using Tarjan's algorithm\n    ids = [-1] * n\n    low = [-1] * n\n    onStack = [False] * n\n    stack = []\n    at_scc = 0\n    sccs = []\n    \n    def tarjan_dfs(at):\n        nonlocal at_scc\n        stack.append(at)\n        onStack[at] = True\n        ids[at] = low[at] = at_scc\n        at_scc += 1\n\n        for to in adj[at]:\n            if ids[to] == -1:\n                tarjan_dfs(to)\n            if onStack[to]:\n                low[at] = min(low[at], low[to])\n\n        if ids[at] == low[at]:\n            scc = []\n            while stack:\n                node = stack.pop()\n                onStack[node] = False\n                low[node] = ids[at]\n                scc.append(node)\n                if node == at: break\n            sccs.append(scc)\n\n    for i in range(n):\n        if ids[i] == -1:\n            tarjan_dfs(i)\n\n    # 3. Identify closed classes\n    state_to_scc_id = {state: i for i, scc in enumerate(sccs) for state in scc}\n    closed_scc_ids = set()\n    for i, scc in enumerate(sccs):\n        is_closed = True\n        for u in scc:\n            for v in adj[u]:\n                if state_to_scc_id.get(v) != i:\n                    is_closed = False\n                    break\n            if not is_closed:\n                break\n        if is_closed:\n            closed_scc_ids.add(i)\n\n    # 4. Classify states\n    labels = [''] * n\n    for i in range(n):\n        is_absorbing = False\n        if is_ctmc:\n            if np.allclose(M[i, i], 0):\n                is_absorbing = True\n        else: # DTMC\n            if np.allclose(M[i, i], 1.0):\n                # For a stochastic matrix, p_ii=1 implies p_ij=0 for j!=i\n                is_absorbing = True\n\n        if is_absorbing:\n            labels[i] = 'absorbing'\n        else:\n            scc_id = state_to_scc_id[i]\n            if scc_id in closed_scc_ids:\n                labels[i] = 'recurrent non-absorbing'\n            else:\n                labels[i] = 'transient'\n    \n    return labels\n\ndef get_p_ec(Q, dt, tau):\n    \"\"\"\n    Computes the Euler-with-correction discretization P_EC.\n    \"\"\"\n    P_raw = np.eye(Q.shape[0]) + dt * Q\n    P_thresh = np.where(P_raw  tau, 0, P_raw)\n    \n    P_ec = np.zeros_like(P_thresh)\n    row_sums = P_thresh.sum(axis=1)\n    \n    for i in range(Q.shape[0]):\n        if row_sums[i] > 1e-9: # Use a small tolerance for float comparison\n            P_ec[i, :] = P_thresh[i, :] / row_sums[i]\n        else:\n            P_ec[i, i] = 1.0\n            \n    return P_ec\n\ndef monte_carlo_return_prob(P, n_paths, n_steps, seed):\n    \"\"\"\n    Estimates the probability of returning to state 1 (index 0).\n    \"\"\"\n    n = P.shape[0]\n    rng = np.random.default_rng(seed)\n    states = np.arange(n)\n    \n    return_count = 0\n    start_state = 0\n\n    for _ in range(n_paths):\n        current_state = start_state\n        has_returned = False\n        for _ in range(n_steps):\n            probs = P[current_state, :]\n            # Normalize to handle potential float inaccuracies\n            probs_sum = probs.sum()\n            if not np.isclose(probs_sum, 1.0):\n                 probs /= probs_sum\n\n            next_state = rng.choice(states, p=probs)\n            \n            if next_state == start_state:\n                has_returned = True\n                break\n            current_state = next_state\n        \n        if has_returned:\n            return_count += 1\n            \n    return return_count / n_paths\n\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases and produce the final output.\n    \"\"\"\n    # Define test cases from the problem statement.\n    test_cases = [\n        {\n            'Q': np.array([[-3., 3.], [4., -4.]]),\n            'dt': 0.01,\n            'tau': 0.05\n        },\n        {\n            'Q': np.array([[-3., 3.], [4., -4.]]),\n            'dt': 0.2,\n            'tau': 0.001\n        },\n        {\n            'Q': np.array([[-1., 1., 0.], [0., -1., 1.], [0., 0., 0.]]),\n            'dt': 0.1,\n            'tau': 1e-4\n        },\n        {\n            'Q': np.array([[-1., 1., 0.], [0., -1., 1.], [0., 0., 0.]]),\n            'dt': 0.001,\n            'tau': 0.05\n        }\n    ]\n\n    mc_params = {\n        'n_paths': 5000,\n        'n_steps': 200,\n        'seed': 12345\n    }\n\n    results = []\n    for case in test_cases:\n        Q, dt, tau = case['Q'], case['dt'], case['tau']\n        n = Q.shape[0]\n\n        # Classifications\n        class_q = get_classification(Q, is_ctmc=True)\n        \n        P_ec = get_p_ec(Q, dt, tau)\n        class_pec = get_classification(P_ec, is_ctmc=False)\n        \n        P_exact = expm(Q * dt)\n\n        # 1. k_art: artificial absorbing states\n        absorbing_q = {i for i, label in enumerate(class_q) if label == 'absorbing'}\n        absorbing_pec = {i for i, label in enumerate(class_pec) if label == 'absorbing'}\n        k_art = len(absorbing_pec - absorbing_q)\n\n        # 2. k_chg: states with changed classification\n        k_chg = sum(1 for i in range(n) if class_q[i] != class_pec[i])\n\n        # 3. Δr: difference in return probabilities\n        # We use the same seed for both simulations to reduce variance in the *difference* of estimates.\n        prob_ec = monte_carlo_return_prob(P_ec, **mc_params)\n        prob_exact = monte_carlo_return_prob(P_exact, **mc_params)\n        delta_r = round(prob_ec - prob_exact, 3)\n\n        results.append([k_art, k_chg, delta_r])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将超越“暂态或常返”的简单二元标签，探讨“暂态性有多强？”这个问题。本练习引入了结构稳定性的概念 。通过应用矩阵微扰理论，你将计算一个安全边界，即系统在其暂态性质丧失之前可以容忍多大的扰动，从而对状态分类获得更细致、更定量的理解。",
            "id": "3295790",
            "problem": "考虑一个状态空间为 $\\{1,2,3\\}$ 的离散时间有限状态马尔可夫链。其一步转移概率矩阵为\n$$\nP \\;=\\;\n\\begin{pmatrix}\n0.3  0.2  0.5 \\\\\n0.2  0.4  0.4 \\\\\n0  0  1\n\\end{pmatrix}.\n$$\n令暂态类为 $T=\\{1,2\\}$，吸收态为 $\\{3\\}$。记 $Q$ 为对应于 $T$ 内部转移的 $2\\times 2$ 子随机块，$R$ 为对应于从 $T$ 到 $\\{3\\}$ 转移的 $2\\times 1$ 块。可以认为一个基本事实是：一个类 $T$ 是暂态的，当且仅当谱半径 $\\rho(Q)$ 满足 $\\rho(Q)1$。\n\n假设 $P$ 被扰动为 $P' = P + \\Delta P$，其中 $P'$ 在相同的状态空间上仍然是一个有效的随机矩阵，对于 $T=\\{1,2\\}$ 的索引保持不变，并且扰动在谱范数下有界，即 $\\|\\Delta P\\|_{2} \\le \\varepsilon$。令 $\\Delta Q$ 为从 $\\Delta P$ 中提取的 $Q$ 的相应扰动。使用暂态性、矩阵范数以及关于可对角化矩阵特征值的成熟谱扰动界的基本定义，推导上确界一致半径 $\\varepsilon^{\\star}$，使得对于每个满足 $\\|\\Delta P\\|_{2}  \\varepsilon^{\\star}$ 的扰动，类 $T$ 对于 $P'$ 仍然是暂态的。\n\n计算给定 $P$ 的 $\\varepsilon^{\\star}$ 的数值，并将最终答案四舍五入至四位有效数字。无需单位。",
            "solution": "首先验证问题，以确保其科学上合理、良定且完整。\n\n### 步骤 1：提取已知条件\n- 一个状态空间为 $S = \\{1, 2, 3\\}$ 的离散时间有限状态马尔可夫链。\n- 一步转移概率矩阵为 $P = \\begin{pmatrix} 0.3  0.2  0.5 \\\\ 0.2  0.4  0.4 \\\\ 0  0  1 \\end{pmatrix}$。\n- 暂态集为 $T = \\{1, 2\\}$。\n- 吸收态为 $\\{3\\}$。\n- $Q$ 是 $P$ 中对应于 $T$ 内部转移的子矩阵：$Q = \\begin{pmatrix} 0.3  0.2 \\\\ 0.2  0.4 \\end{pmatrix}$。\n- $R$ 是对应于从 $T$ 到 $\\{3\\}$ 转移的子矩阵：$R = \\begin{pmatrix} 0.5 \\\\ 0.4 \\end{pmatrix}$。\n- 一个类 $T$ 是暂态的，当且仅当 $Q$ 的谱半径 $\\rho(Q)$ 满足 $\\rho(Q)  1$。\n- 扰动矩阵 $P' = P + \\Delta P$ 是一个有效的随机矩阵。\n- 扰动在谱范数下有界：$\\|\\Delta P\\|_{2} \\le \\varepsilon$。\n- $\\Delta Q$ 是 $\\Delta P$ 中对应于状态集 $T$ 的子矩阵。\n- 目标是找到上确界一致半径 $\\varepsilon^{\\star}$，使得对于任何满足 $\\|\\Delta P\\|_{2}  \\varepsilon^{\\star}$ 的有效扰动，类 $T$ 对于扰动矩阵 $P'$ 仍然是暂态的。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题是矩阵扰动理论在马尔可夫链稳定性分析中的一个标准应用。所有概念——暂态性、谱半径、谱范数、随机矩阵——在数学和工程学中都有严格的定义。给定的矩阵 $P$ 是一个有效的随机矩阵，因为其元素非负且行和为1。\n- **良定性：** 问题是良定的。它要求计算一个特定的量 $\\varepsilon^{\\star}$，该量在明确的约束下被定义为一个上确界。预期有唯一解。\n- **客观性：** 问题以精确、客观的数学语言陈述。\n\n该问题没有任何科学、逻辑或结构上的缺陷。\n\n### 步骤 3：结论与行动\n该问题被认定为有效。将提供完整解答。\n\n### 解题推导\n状态类 $T = \\{1, 2\\}$ 是暂态的条件是子矩阵 $Q$ 的谱半径严格小于1，即 $\\rho(Q)  1$。对于扰动矩阵 $P'$，其对应于 $T$ 内部转移的子矩阵是 $Q' = Q + \\Delta Q$。在此扰动下，类 $T$ 保持暂态的充要条件是 $\\rho(Q')  1$。\n\n马尔可夫链理论中的一个关键结果指出，类 $T$ 是暂态的当且仅当矩阵 $I-Q$ 是可逆的，其中 $I$ 是适当大小的单位矩阵。矩阵 $N = (I-Q)^{-1}$ 被称为基本矩阵，其元素给出了在被吸收前访问 $T$ 中状态的期望次数。几何级数 $N = \\sum_{k=0}^{\\infty} Q^k$ 的收敛性等价于 $\\rho(Q)  1$。\n\n对于受扰系统，暂态性得以维持当且仅当 $I-Q'$ 是可逆的。我们可以将 $I-Q'$ 写成 $I-Q$ 的一个扰动：\n$$\nI - Q' = I - (Q + \\Delta Q) = (I - Q) - \\Delta Q\n$$\n根据矩阵扰动理论中的一个基本定理，如果矩阵 $A$ 是可逆的，那么只要扰动 $E$ 的范数足够小，矩阵 $A+E$ 也是可逆的。具体来说，如果对于某个矩阵范数，有 $\\|E\\|  \\frac{1}{\\|A^{-1}\\|}$，则 $A+E$ 保证是可逆的。\n\n我们将这个定理应用于 $A = I - Q$ 和扰动 $E = -\\Delta Q$，使用谱范数（诱导2-范数）。由于原始的类 $T$ 是暂态的，矩阵 $I-Q$ 是可逆的。扰动后的矩阵 $I-Q'$ 保持可逆，如果：\n$$\n\\|-\\Delta Q\\|_{2}  \\frac{1}{\\|(I-Q)^{-1}\\|_{2}}\n$$\n由于 $\\|-\\Delta Q\\|_{2} = \\|\\Delta Q\\|_{2}$，该条件为：\n$$\n\\|\\Delta Q\\|_{2}  \\frac{1}{\\|(I-Q)^{-1}\\|_{2}}\n$$\n扰动 $\\Delta Q$ 是完整扰动 $\\Delta P$ 的一个主子矩阵。谱范数的一个标准性质是，任何子矩阵的范数小于或等于完整矩阵的范数。因此，我们有：\n$$\n\\|\\Delta Q\\|_{2} \\le \\|\\Delta P\\|_{2}\n$$\n问题陈述 $\\|\\Delta P\\|_{2}  \\varepsilon^{\\star}$。因此，我们有 $\\|\\Delta Q\\|_{2}  \\varepsilon^{\\star}$。为了保证暂态条件对任何此类扰动都成立，我们必须要求 $\\|\\Delta P\\|_{2}$ 的上界 $\\varepsilon^{\\star}$ 满足：\n$$\n\\varepsilon^{\\star} \\le \\frac{1}{\\|(I-Q)^{-1}\\|_{2}}\n$$\n问题要求的是上确界一致半径 $\\varepsilon^{\\star}$。这个界是紧的，意味着我们可以找到一个范数等于 $1/\\|(I-Q)^{-1}\\|_{2}$ 的扰动，使得 $I-Q'$ 奇异。因此，上确界是：\n$$\n\\varepsilon^{\\star} = \\frac{1}{\\|(I-Q)^{-1}\\|_{2}}\n$$\n现在我们必须计算 $\\|(I-Q)^{-1}\\|_{2}$。矩阵 $Q$ 由 $Q = \\begin{pmatrix} 0.3  0.2 \\\\ 0.2  0.4 \\end{pmatrix}$ 给出。这是一个实对称矩阵。因此，矩阵 $I-Q$ 也是对称的，其逆矩阵 $(I-Q)^{-1}$ 也是对称的。对于对称矩阵，谱范数等于其谱半径（其特征值的最大绝对值）。\n$$\n\\|(I-Q)^{-1}\\|_{2} = \\rho((I-Q)^{-1})\n$$\n$(I-Q)^{-1}$ 的特征值与 $Q$ 的特征值相关。令 $\\lambda_i$ 为 $Q$ 的特征值。那么 $I-Q$ 的特征值是 $1-\\lambda_i$，而 $(I-Q)^{-1}$ 的特征值是 $(1-\\lambda_i)^{-1}$。\n因此：\n$$\n\\rho((I-Q)^{-1}) = \\max_i \\left| \\frac{1}{1-\\lambda_i} \\right|\n$$\n为了求 $Q$ 的特征值，我们求解特征方程 $\\det(Q - \\lambda I) = 0$：\n$$\n\\det \\begin{pmatrix} 0.3-\\lambda  0.2 \\\\ 0.2  0.4-\\lambda \\end{pmatrix} = (0.3-\\lambda)(0.4-\\lambda) - (0.2)(0.2) = 0\n$$\n$$\n\\lambda^2 - 0.7\\lambda + 0.12 - 0.04 = 0\n$$\n$$\n\\lambda^2 - 0.7\\lambda + 0.08 = 0\n$$\n使用二次求根公式，特征值为：\n$$\n\\lambda = \\frac{-(-0.7) \\pm \\sqrt{(-0.7)^2 - 4(1)(0.08)}}{2(1)} = \\frac{0.7 \\pm \\sqrt{0.49 - 0.32}}{2} = \\frac{0.7 \\pm \\sqrt{0.17}}{2}\n$$\n两个特征值是 $\\lambda_1 = \\frac{0.7 + \\sqrt{0.17}}{2}$ 和 $\\lambda_2 = \\frac{0.7 - \\sqrt{0.17}}{2}$。两个特征值都是实数且为正。$Q$ 的谱半径是较大的那个特征值：\n$$\n\\rho(Q) = \\lambda_1 = \\frac{0.7 + \\sqrt{0.17}}{2}\n$$\n数值上，$\\sqrt{0.17} \\approx 0.412$，所以 $\\rho(Q) \\approx \\frac{1.112}{2} = 0.556  1$，这证实了 $T$ 确实是一个暂态类。\n现在，我们求 $(I-Q)^{-1}$ 的谱半径。由于 $0  \\lambda_2  \\lambda_1  1$，表达式 $|(1-\\lambda_i)^{-1}|$ 在 $1-\\lambda_i$ 最小时取最大值，这发生在最大特征值 $\\lambda_1 = \\rho(Q)$ 处。\n$$\n\\rho((I-Q)^{-1}) = \\frac{1}{1 - \\lambda_1} = \\frac{1}{1 - \\rho(Q)}\n$$\n将此代回 $\\varepsilon^{\\star}$ 的表达式中：\n$$\n\\varepsilon^{\\star} = \\frac{1}{\\rho((I-Q)^{-1})} = 1 - \\rho(Q)\n$$\n我们现在可以计算数值：\n$$\n\\varepsilon^{\\star} = 1 - \\frac{0.7 + \\sqrt{0.17}}{2} = \\frac{2 - (0.7 + \\sqrt{0.17})}{2} = \\frac{1.3 - \\sqrt{0.17}}{2}\n$$\n使用计算器，$\\sqrt{0.17} \\approx 0.41231056256$。\n$$\n\\varepsilon^{\\star} = \\frac{1.3 - 0.41231056256}{2} = \\frac{0.88768943744}{2} = 0.44384471872\n$$\n将结果四舍五入至四位有效数字，得到 $0.4438$。",
            "answer": "$$\\boxed{0.4438}$$"
        }
    ]
}