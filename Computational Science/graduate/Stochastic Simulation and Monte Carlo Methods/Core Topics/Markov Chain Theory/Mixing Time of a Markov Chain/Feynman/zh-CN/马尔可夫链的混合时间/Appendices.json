{
    "hands_on_practices": [
        {
            "introduction": "洗牌是马尔可夫链理论的一个经典应用。这项练习将带领我们为一个特定的洗牌方式——“顶牌随机插入”——计算谱隙。我们将借助表示论的工具，这展示了抽象代数如何为分析像置换群这样复杂状态空间上的马尔可夫链提供强大的捷径。",
            "id": "866134",
            "problem": "考虑一个马尔可夫链，其状态空间 $S_N$ 是 $N$ 个标记为 $\\{1, 2, \\dots, N\\}$ 的项目的所有排列。其转移机制是一种“顶端随机”洗牌：在每一步中，位于位置 1 的项目被移除，然后以等概率 $1/N$ 重新插入到 $N$ 个可能的位置之一（从位置 1 到位置 $N$）。设 $P$ 为该马尔可夫链的转移矩阵。\n\n转移矩阵的谱隙 $\\gamma$ 定义为\n$$ \\gamma = 1 - \\max\\{|\\lambda| : \\lambda \\text{ is an eigenvalue of } P \\text{ and } \\lambda \\neq 1\\}. $$\n谱隙是衡量马尔可夫链收敛到其平稳分布速率的指标。对于此问题，你不需要构造完整的转移矩阵 $P$。相反，你可以使用一个来自“顶端随机洗牌代数”表示论的已知结果，它提供了一种计算 $P$ 的特征值的方法。\n\n$P$ 的特征值集合是一组较小矩阵 $\\{M_k\\}_{k=1}^N$ 的特征值的并集。对每个 $k \\in \\{1, \\dots, N\\}$，矩阵 $M_k$ 是一个 $(k-1) \\times (k-1)$ 的复矩阵。设 $I_j$ 是将顶端项目移动到位置 $j$ 的算子。那么 $P = \\frac{1}{N} \\sum_{j=1}^N I_j$。矩阵 $M_k$ 是 $P$ 在该代数的第 $k$ 个单模中的表示，由 $M_k = \\frac{1}{N} \\sum_{j=1}^N \\rho_k(I_j)$ 给出，其中 $\\rho_k$ 是表示映射。矩阵表示 $\\rho_k(I_j)$ 遵循以下规则：\n1.  $\\rho_k(I_1)$ 是 $(k-1) \\times (k-1)$ 的单位矩阵，$Id_{k-1}$。\n2.  对于 $2 \\le j \\le k$，$\\rho_k(I_j) = \\sum_{l=1}^{j-1} E_{j-1,l}$，其中 $E_{r,c}$ 是在第 $r$ 行、第 $c$ 列处为 1，其余位置为 0 的矩阵单位。\n3.  对于 $j > k$，作用由 $\\rho_k(I_j) = \\rho_k(I_k)$ 给出。\n\n你的任务是计算当 $N=4$ 时，顶端随机洗牌的谱隙 $\\gamma$。",
            "solution": "相关定义：\n$$P=\\frac1N\\sum_{j=1}^N I_j,\\qquad M_k=\\frac1N\\sum_{j=1}^N\\rho_k(I_j),\\quad N=4.$$\n$\\rho_k(I_j)$ 在一个 $(k-1)$ 维基上的规则：\n1. $\\rho_k(I_1)=Id_{k-1}$。\n2. 对于 $2\\le j\\le k$，$\\rho_k(I_j)=\\sum_{l=1}^{j-1}E_{j-1,l}$。\n3. 对于 $j>k$，$\\rho_k(I_j)=\\rho_k(I_k)$。\n\n对每个 $k$ 计算：\n\n**k=2（1维）**：\n对于 $j=1,2,3,4$，$\\rho_2(I_j)=[1]$，所以\n$$M_2=\\frac14\\sum_{j=1}^4[1]=[1].$$\n特征值：$1$。\n\n**k=3（2维）**：\n$$\\rho_3(I_1)=\\begin{pmatrix}10\\\\01\\end{pmatrix},\\;\n\\rho_3(I_2)=\\begin{pmatrix}10\\\\00\\end{pmatrix},\\;\n\\rho_3(I_3)=\\begin{pmatrix}00\\\\11\\end{pmatrix},\\;\n\\rho_3(I_4)=\\rho_3(I_3).$$\n求和：\n$$S_3=\\sum_{j=1}^4\\rho_3(I_j)\n=\\begin{pmatrix}20\\\\23\\end{pmatrix},\\quad\nM_3=\\frac14S_3=\\begin{pmatrix}1/20\\\\1/23/4\\end{pmatrix}.$$\n特征值是方程 $(1/2-\\lambda)(3/4-\\lambda)=0$ 的解，所以 $\\lambda\\in\\{1/2,3/4\\}$。\n\n**k=4（3维）**：\n$$\\rho_4(I_1)=I_3,\\;\n\\rho_4(I_2)=\\begin{pmatrix}100\\\\000\\\\000\\end{pmatrix},\\;\n\\rho_4(I_3)=\\begin{pmatrix}000\\\\110\\\\000\\end{pmatrix},\\;\n\\rho_4(I_4)=\\begin{pmatrix}000\\\\000\\\\111\\end{pmatrix}.$$\n求和：\n$$S_4=\\begin{pmatrix}200\\\\120\\\\112\\end{pmatrix},\\quad\nM_4=\\frac14S_4=\\begin{pmatrix}1/200\\\\1/41/20\\\\1/41/41/2\\end{pmatrix}.$$\n由于 $M_4$ 是对角线元素均为 $1/2$ 的下三角矩阵，其特征值均为 $1/2$（重数为3）。\n\n特征值的并集：$\\{1,\\,3/4,\\,1/2\\}$。第二大的特征值是 $3/4$，所以\n$$\\gamma=1-\\frac34=\\frac14.$$",
            "answer": "$$\\boxed{\\frac14}$$"
        },
        {
            "introduction": "图上的随机游走是许多随机过程的基础模型。本练习将探讨在一个循环图上的复合随机游走，这种结构在众多应用中都会出现。我们将运用傅里叶分析这一关键技术，来精确求解转移矩阵的特征值，从而深入理解具有对称性的马尔可夫链的动态行为。",
            "id": "787957",
            "problem": "考虑两个独立的随机游走 $X_t$ 和 $Y_t$，它们在一个循环图 $\\mathbb{Z}_N = \\{0, 1, \\dots, N-1\\}$ 的顶点上进行，其中 $N$ 是 4 的整数倍。\n第一个游走者 $X_t$ 遵循以下规则移动：从其当前位置 $i$，它以概率 $p$ 跳到 $(i+1) \\pmod N$，并以概率 $1-p$ 停留在 $i$。\n第二个游走者 $Y_t$ 按如下方式移动：从其当前位置 $j$，它以概率 $q$ 跳到 $(j-1) \\pmod N$，并以概率 $1-q$ 停留在 $j$。这里 $p, q \\in (0, 1)$ 是常数概率。\n\n定义一个新的随机过程 $Z_t$，为两个游走者位置之差对 $N$ 取模：\n$$Z_t = (X_t - Y_t) \\pmod N$$\n这个过程 $Z_t$ 构成一个状态空间为 $\\mathbb{Z}_N$ 的马尔可夫链。该马尔可夫链收敛到其平稳分布的速度由其转移矩阵的特征值的模决定。\n\n设 $\\lambda_k$（其中 $k \\in \\{0, 1, \\dots, N-1\\}$）是马尔可夫链 $Z_t$ 的转移矩阵的特征值。求特征值 $\\lambda_{N/4}$ 的模的精确值。",
            "solution": "1. $Z_t$ 的转移概率：\n   $Z_t$ 的一步位移 $\\Delta Z$ 由 $X_t$ 和 $Y_t$ 的独立位移 $\\Delta X \\in \\{0,1\\}$ 和 $\\Delta Y \\in \\{0, -1\\}$ 决定。\n   - 位移为 0：$\\Delta Z = 0-0=0$，概率 $P(\\Delta Z=0)=(1-p)(1-q)$。\n   - 位移为 1：$\\Delta Z = (1-0)$ 或 $(0-(-1))$，概率 $P(\\Delta Z=1)=p(1-q)+(1-p)q$。\n   - 位移为 2：$\\Delta Z = 1-(-1)=2$，概率 $P(\\Delta Z=2)=pq$。\n2. 在 $\\mathbb{Z}_N$ 上的特征值公式：\n   $$\\lambda_k = (1-p)(1-q) + \\bigl[p(1-q)+(1-p)q\\bigr]e^{2\\pi i k/N} + pq\\,e^{4\\pi i k/N}.$$\n3. 对于 $k=N/4$，设 $\\theta=2\\pi k/N=\\pi/2$，因此 $e^{i\\theta}=i$，$e^{2i\\theta}=-1$。于是\n   $$\\lambda_{N/4} = (1-p)(1-q) + \\bigl[p(1-q)+(1-p)q\\bigr]\\,i + pq\\,(-1).$$\n4. 写出实部和虚部：\n   $$\\Re(\\lambda_{N/4}) = (1-p)(1-q)-pq = 1 - p - q,\\quad\n     \\Im(\\lambda_{N/4}) = p(1-q)+(1-p)q = p+q-2pq.$$\n5. 模：\n   $$|\\lambda_{N/4}| = \\sqrt{\\bigl(1-p-q\\bigr)^2 + \\bigl(p+q-2pq\\bigr)^2}.$$",
            "answer": "$$\\boxed{\\sqrt{(1-p-q)^2 + (p+q-2pq)^2}}$$"
        },
        {
            "introduction": "对于许多现实世界中的马尔可夫链，我们无法通过解析方法精确计算其特征值。因此，这项练习将我们的重点从解析计算转向数值方法。我们将通过编写代码实现带有“压缩”技术的幂迭代法，来数值估计谱隙，并利用该估计推导出混合时间的一个实用上界。",
            "id": "3283319",
            "problem": "给定一个有限状态马尔可夫链的集合，每个链由一个转移矩阵 $P \\in \\mathbb{R}^{n \\times n}$ 表示，其元素非负且列和为一。在所有提供的测试用例中，$P$ 都是对称且双随机的（行和与列和均为 $1$），因此平稳分布是均匀分布。您的任务是设计并实现一个程序，使用带紧缩的幂法估计谱隙，然后利用此估计计算全变差距离下的混合时间的上界。\n\n从基本事实开始：\n- 一个实对称双随机矩阵 $P$ 的特征值在 $[-1,1]$ 区间内，其最大特征值为 $1$，对应的特征向量与全一向量成比例。根据 Perron–Frobenius 定理，一个非负、不可约的列随机矩阵的主特征值 $\\lambda_1$ 为 $1$。\n- 谱隙定义为 $\\gamma = 1 - \\lambda_\\ast$，其中 $\\lambda_\\ast = \\max\\{|\\lambda| : \\lambda \\in \\sigma(P), \\lambda \\ne 1\\}$ 是除 $1$ 以外谱半径最大的特征值的模。\n- 幂法从一个初始非零向量 $x_0$ 开始迭代 $x_{k+1} = P x_k / \\|P x_k\\|_2$，并收敛到主特征向量。为了估计次主特征值（此处为 $\\lambda_\\ast$），您必须通过将迭代向量投影到与主特征向量正交的子空间上来进行紧缩，使它们收敛到与 $\\lambda_\\ast$ 相关的特征向量。\n- 对于一个可逆、对称、双随机的惰性链，谱分解产生一个由 $\\lambda_\\ast$ 控制的 $L^2$-收缩，且范数满足 $\\|\\cdot\\|_1 \\le \\sqrt{n}\\,\\|\\cdot\\|_2$。全变差距离为 $\\|\\cdot\\|_{\\mathrm{TV}} = \\tfrac{1}{2}\\|\\cdot\\|_1$。使用这些事实，推导在最坏情况初始状态下，达到给定容差 $\\varepsilon$ 内的全变差距离所需的混合时间的上界。\n\n为每个测试用例实现以下步骤：\n1. 使用幂法近似计算 $P$ 的主特征向量 $v_1$ 及其特征值。将 $v_1$ 归一化为单位欧几里得范数。\n2. 使用紧缩幂迭代法：从一个随机非零向量 $x_0$ 开始，使用欧几里得内积使其与 $v_1$ 正交，然后迭代 $x_{k+1} = P x_k$，每次乘法后都与 $v_1$ 正交，然后进行归一化。当 $x$ 收敛时，通过瑞利商 $r(x) = \\frac{x^\\top P x}{x^\\top x}$ 估计次主特征值 $\\lambda_\\ast$。\n3. 计算谱隙 $\\gamma = 1 - \\lambda_\\ast$。\n4. 利用 $\\ell^2$ 中的谱收缩和不等式链 $\\|\\cdot\\|_1 \\le \\sqrt{n}\\,\\|\\cdot\\|_2$，推导当初始分布为点质量（独热向量）时的最坏情况全变差混合时间 $t_{\\mathrm{mix}}(\\varepsilon)$ 的上界，即满足 $\\|\\mu_t - \\pi\\|_{\\mathrm{TV}} \\le \\varepsilon$ 的最小整数 $t$ 的界。您的最终界仅用 $n$、$\\varepsilon$ 和估计的 $\\lambda_\\ast$ 表示。\n\n使用以下以 LaTeX 编写的矩阵和容差测试套件：\n- 情况 A：双状态，强惰性对称链，\n$$\nP_A = \\begin{bmatrix}\n0.95   0.05\\\\\n0.05   0.95\n\\end{bmatrix},\\quad \\varepsilon_A = 0.01.\n$$\n- 情况 B：五状态循环上的惰性随机游走，其中 $S$ 是循环图上的简单随机游走，向每个邻居移动的概率为 $\\tfrac{1}{2}$，否则为 $0$，且 $P_B = \\tfrac{1}{2}I + \\tfrac{1}{2}S$。具体为，\n$$\nS_B = \\begin{bmatrix}\n0   \\tfrac{1}{2}   0   0   \\tfrac{1}{2}\\\\\n\\tfrac{1}{2}   0   \\tfrac{1}{2}   0   0\\\\\n0   \\tfrac{1}{2}   0   \\tfrac{1}{2}   0\\\\\n0   0   \\tfrac{1}{2}   0   \\tfrac{1}{2}\\\\\n\\tfrac{1}{2}   0   0   \\tfrac{1}{2}   0\n\\end{bmatrix},\\quad\nP_B = \\tfrac{1}{2}I + \\tfrac{1}{2}S_B,\\quad \\varepsilon_B = 0.01.\n$$\n- 情况 C：三状态对称、双随机三对角矩阵，\n$$\nP_C = \\begin{bmatrix}\n0.9   0.1   0.0\\\\\n0.1   0.8   0.1\\\\\n0.0   0.1   0.9\n\\end{bmatrix},\\quad \\varepsilon_C = 0.01.\n$$\n- 情况 D：四状态完全图上的惰性随机游走，\n$$\nJ_4 = \\begin{bmatrix}\n1   1   1   1\\\\\n1   1   1   1\\\\\n1   1   1   1\\\\\n1   1   1   1\n\\end{bmatrix},\\quad\nP_D = \\tfrac{1}{2}I + \\tfrac{1}{2}\\tfrac{1}{4}J_4,\\quad \\varepsilon_D = 0.01.\n$$\n\n您的程序必须：\n- 按照所述实现幂法及其紧缩法，使用瑞利商差值小于 $10^{-12}$ 或每阶段最多 $10{,}000$ 次迭代作为停止容差。\n- 对每种情况，假设最坏情况初始化为点质量，计算谱隙 $\\gamma$ 和根据上述原理推导出的混合时间 $t_{\\mathrm{mix}}(\\varepsilon)$ 的上界。\n- 将所有情况的结果汇总到一行。最终输出格式必须是一个逗号分隔的 Python 风格的列表的列表。每个内部列表对应一种情况，包含两个条目 $[\\gamma, t]$，其中 $\\gamma$ 四舍五入到六位小数，而 $t$ 是一个整数界。例如，输出应如下所示：\n$[\\,[\\gamma_A, t_A],[\\gamma_B, t_B],[\\gamma_C, t_C],[\\gamma_D, t_D]\\,]$。\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，\"[[gap1,time1],[gap2,time2],[gap3,time3],[gap4,time4]]\"）。不应读取任何外部输入。不涉及任何物理单位或角度。所有答案必须是指定格式的数值浮点数或整数。",
            "solution": "我们从核心定义和所提供测试矩阵的属性开始。对于一个具有非负项和单位列和的有限状态马尔可夫链，其转移矩阵 $P$ 通过 $\\mu_{t+1} = P\\,\\mu_t$ 作用于列概率向量。在对称、双随机的设定下，$P = P^\\top$ 且行和与列和均为 $1$，这意味着平稳分布是均匀的：$\\pi = \\frac{1}{n}\\mathbf{1}$。$P$ 的谱位于 $[-1,1]$ 区间内，其主特征值为 $\\lambda_1 = 1$，对应的特征向量与 $\\mathbf{1}$ 成比例。\n\n谱隙定义为\n$$\n\\gamma = 1 - \\lambda_\\ast,\\quad \\text{其中}\\quad \\lambda_\\ast = \\max\\{|\\lambda|:\\lambda\\in\\sigma(P), \\lambda\\ne 1\\}.\n$$\n在对称设定下，特征值是实数，对于惰性链（例如，$P = \\tfrac{1}{2}I + \\tfrac{1}{2}S$，其中 $S$ 是列随机的），所有特征值都位于 $[0,1]$ 区间，所以 $\\lambda_\\ast$ 是 $[0,1]$ 中的第二大特征值。\n\n为了近似 $\\lambda_1$ 及其特征向量 $v_1$，我们应用幂法。设 $x_0\\in\\mathbb{R}^n$ 为一个非零向量。定义迭代\n$$\nx_{k+1} = \\frac{P x_k}{\\|P x_k\\|_2}.\n$$\n在 $P$ 是非负、不可约且主特征值 $\\lambda_1=1$ 的模严格大于其他特征值的假设下，序列 $x_k$ 收敛于与 $\\lambda_1$ 相关的特征向量 $v_1$。特征值的数值稳定估计由瑞利商给出，\n$$\n\\rho(x) = \\frac{x^\\top P x}{x^\\top x},\n$$\n当 $x$ 收敛于 $v_1$ 时，该值收敛于 $\\lambda_1$。\n\n为了通过紧缩法计算次主特征值 $\\lambda_\\ast$，我们将迭代限制在与 $v_1$ 正交的子空间内。具体来说，选择一个初始向量 $y_0$，使用欧几里得内积将其投影到 $v_1$ 的正交补上，然后迭代：\n$$\n\\tilde{y}_k = P y_k,\\quad\n\\tilde{y}_k^\\perp = \\tilde{y}_k - (v_1^\\top \\tilde{y}_k) v_1,\\quad\ny_{k+1} = \\frac{\\tilde{y}_k^\\perp}{\\|\\tilde{y}_k^\\perp\\|_2}.\n$$\n在对称情况下，此正交迭代收敛到与 $v_1$ 正交补中最大特征值（即 $\\lambda_\\ast$）相关的特征向量 $v_2$。同样，瑞利商\n$$\n\\rho(y) = \\frac{y^\\top P y}{y^\\top y}\n$$\n在收敛的 $y$ 处的值给出了 $\\lambda_\\ast$ 的精确估计。\n\n我们现在推导全变差距离下的混合时间的上界。对于可逆链（包括对称双随机矩阵），谱分解意味着相对于平稳分布的 $L^2$ 收缩。设 $\\mu_t = P^t \\mu_0$ 是从初始分布 $\\mu_0$ 开始经过 $t$ 步后的分布。将与平稳分布的偏差写为 $d_t = \\mu_t - \\pi$，并设 $\\lambda_\\ast$ 为模小于 $1$ 的最大特征值，我们有 $L^2$ 界\n$$\n\\|d_t\\|_2 \\le \\lambda_\\ast^t \\|d_0\\|_2.\n$$\n使用范数不等式，我们将全变差距离与 $L^2$ 范数联系起来。由于 $\\|\\cdot\\|_1 \\le \\sqrt{n}\\,\\|\\cdot\\|_2$ 且全变差定义为 $\\|\\cdot\\|_{\\mathrm{TV}} = \\tfrac{1}{2}\\|\\cdot\\|_1$，我们得到\n$$\n\\|\\mu_t - \\pi\\|_{\\mathrm{TV}} = \\tfrac{1}{2}\\|d_t\\|_1 \\le \\tfrac{1}{2} \\sqrt{n}\\,\\|d_t\\|_2 \\le \\tfrac{1}{2} \\sqrt{n}\\,\\lambda_\\ast^t \\|d_0\\|_2.\n$$\n对于最坏情况初始化，即点质量，例如 $\\mu_0 = e_i$（第 $i$ 个标准基向量），和平稳均匀分布 $\\pi = \\tfrac{1}{n}\\mathbf{1}$，初始偏差为\n$$\n\\|d_0\\|_2 = \\left\\|e_i - \\tfrac{1}{n}\\mathbf{1}\\right\\|_2 = \\sqrt{1 - \\tfrac{1}{n}}.\n$$\n因此，\n$$\n\\|\\mu_t - \\pi\\|_{\\mathrm{TV}} \\le \\frac{1}{2} \\sqrt{n}\\,\\sqrt{1 - \\frac{1}{n}}\\;\\lambda_\\ast^t.\n$$\n为了达到容差 $\\varepsilon$，选择的 $t$ 只需满足\n$$\n\\lambda_\\ast^t \\le \\frac{2\\varepsilon}{\\sqrt{n}\\,\\sqrt{1 - \\frac{1}{n}}}.\n$$\n求解 $t$ 可得\n$$\nt \\ge \\frac{\\ln\\left(\\frac{2\\varepsilon}{\\sqrt{n}\\,\\sqrt{1 - \\frac{1}{n}}}\\right)}{\\ln(\\lambda_\\ast)}.\n$$\n由于对于惰性链 $\\lambda_\\ast \\in (0,1)$，$\\ln(\\lambda_\\ast)  0$，右侧为正。我们取上取整得到一个整数上界：\n$$\nt_{\\mathrm{mix}}(\\varepsilon) = \\left\\lceil \\frac{\\ln\\left(\\frac{2\\varepsilon}{\\sqrt{n}\\,\\sqrt{1 - \\frac{1}{n}}}\\right)}{\\ln(\\lambda_\\ast)} \\right\\rceil.\n$$\n\n算法设计：\n- 实现一个幂法来近似 $v_1$ 和 $\\lambda_1$，停止准则为瑞利商的变化小于 $10^{-12}$ 或达到 $10{,}000$ 次迭代。\n- 实现紧缩幂迭代法：每步迭代都与 $v_1$ 正交化，进行归一化，并监控瑞利商的收敛以估计 $\\lambda_\\ast$。\n- 计算谱隙 $\\gamma = 1 - \\lambda_\\ast$。\n- 使用推导出的公式，以 $P$ 的维度 $n$ 和估计的 $\\lambda_\\ast$ 计算 $t_{\\mathrm{mix}}(\\varepsilon)$。在数值退化的情况下，当 $\\lambda_\\ast$ 极小（例如，由于机器精度），可以安全地将 $t_{\\mathrm{mix}}(\\varepsilon)$ 界定为 $1$，因为收缩是即时的；但是，所提供的测试套件避免了这种边缘情况。\n\n测试套件矩阵和 $\\varepsilon$ 如下：\n- 情况 A：\n$$\nP_A = \\begin{bmatrix}\n0.95   0.05\\\\\n0.05   0.95\n\\end{bmatrix},\\quad \\varepsilon_A = 0.01.\n$$\n- 情况 B：\n$$\nS_B = \\begin{bmatrix}\n0   \\tfrac{1}{2}   0   0   \\tfrac{1}{2}\\\\\n\\tfrac{1}{2}   0   \\tfrac{1}{2}   0   0\\\\\n0   \\tfrac{1}{2}   0   \\tfrac{1}{2}   0\\\\\n0   0   \\tfrac{1}{2}   0   \\tfrac{1}{2}\\\\\n\\tfrac{1}{2}   0   0   \\tfrac{1}{2}   0\n\\end{bmatrix},\\quad\nP_B = \\tfrac{1}{2}I + \\tfrac{1}{2}S_B,\\quad \\varepsilon_B = 0.01.\n$$\n- 情况 C：\n$$\nP_C = \\begin{bmatrix}\n0.9   0.1   0.0\\\\\n0.1   0.8   0.1\\\\\n0.0   0.1   0.9\n\\end{bmatrix},\\quad \\varepsilon_C = 0.01.\n$$\n- 情况 D：\n$$\nJ_4 = \\begin{bmatrix}\n1   1   1   1\\\\\n1   1   1   1\\\\\n1   1   1   1\\\\\n1   1   1   1\n\\end{bmatrix},\\quad\nP_D = \\tfrac{1}{2}I + \\tfrac{1}{2}\\tfrac{1}{4}J_4,\\quad \\varepsilon_D = 0.01.\n$$\n\n程序为每种情况计算 $[\\gamma, t_{\\mathrm{mix}}(\\varepsilon)]$，并以 $[\\,[\\gamma_A, t_A],[\\gamma_B, t_B],[\\gamma_C, t_C],[\\gamma_D, t_D]\\,]$ 的格式打印单行结果，其中 $\\gamma$ 四舍五入到六位小数， $t$ 是通过上取整得到的整数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef power_method(P, max_iter=10000, tol=1e-12, rng=None):\n    \"\"\"\n    Compute the dominant eigenvector and Rayleigh quotient via the power method.\n    Returns (v1, lambda1).\n    \"\"\"\n    n = P.shape[0]\n    if rng is None:\n        rng = np.random.default_rng(42)\n    x = rng.random(n)\n    x = x / np.linalg.norm(x)\n    prev_rayleigh = None\n    for _ in range(max_iter):\n        y = P @ x\n        ny = np.linalg.norm(y)\n        if ny == 0:\n            # Degenerate case: choose a new random vector\n            x = rng.random(n)\n            x = x / np.linalg.norm(x)\n            continue\n        x = y / ny\n        rayleigh = float(x.T @ (P @ x))\n        if prev_rayleigh is not None and abs(rayleigh - prev_rayleigh)  tol:\n            break\n        prev_rayleigh = rayleigh\n    return x, prev_rayleigh if prev_rayleigh is not None else float(x.T @ (P @ x))\n\ndef deflated_power_method(P, v1, max_iter=10000, tol=1e-12, rng=None):\n    \"\"\"\n    Compute the subdominant eigenvector/eigenvalue by deflating along v1.\n    Returns (v2, lambda2_est).\n    \"\"\"\n    n = P.shape[0]\n    if rng is None:\n        rng = np.random.default_rng(123)\n    # Start with a random vector orthogonal to v1\n    x = rng.random(n)\n    x = x - (v1.T @ x) * v1\n    nx = np.linalg.norm(x)\n    if nx == 0:\n        # If by chance we chose collinear, pick another random\n        x = rng.standard_normal(n)\n        x = x - (v1.T @ x) * v1\n        nx = np.linalg.norm(x)\n        if nx == 0:\n            # Fallback to a fixed vector orthogonal to v1\n            # Construct any vector then subtract projection\n            x = np.ones(n)\n            x = x - (v1.T @ x) * v1\n            nx = np.linalg.norm(x)\n    x = x / nx\n    prev_rayleigh = None\n    for _ in range(max_iter):\n        y = P @ x\n        # Orthogonalize against v1\n        y = y - (v1.T @ y) * v1\n        ny = np.linalg.norm(y)\n        if ny == 0:\n            # Reinitialize if vector collapses\n            x = rng.random(n)\n            x = x - (v1.T @ x) * v1\n            nx = np.linalg.norm(x)\n            if nx == 0:\n                continue\n            x = x / nx\n            prev_rayleigh = None\n            continue\n        x = y / ny\n        rayleigh = float(x.T @ (P @ x))\n        if prev_rayleigh is not None and abs(rayleigh - prev_rayleigh)  tol:\n            break\n        prev_rayleigh = rayleigh\n    lambda2_est = prev_rayleigh if prev_rayleigh is not None else float(x.T @ (P @ x))\n    return x, lambda2_est\n\ndef mixing_time_bound(n, lambda_star, epsilon):\n    \"\"\"\n    Compute the upper bound on mixing time t_mix(epsilon) derived from:\n    ||mu_t - pi||_TV = (1/2) * sqrt(n) * sqrt(1 - 1/n) * lambda_star^t = epsilon\n    Solve for t: t >= ln(2*epsilon / (sqrt(n)*sqrt(1 - 1/n))) / ln(lambda_star)\n    Return ceil of the bound; handle edge cases.\n    \"\"\"\n    # Guard against numerical issues when lambda_star is extremely small or zero\n    if lambda_star = 1e-15:\n        return 1  # immediate contraction\n    numerator = np.log(2.0 * epsilon / (np.sqrt(n) * np.sqrt(1.0 - 1.0 / n)))\n    denominator = np.log(lambda_star)\n    # denominator is negative (since 0  lambda_star  1), numerator is negative\n    t = numerator / denominator\n    # Ensure nonnegative\n    t = max(0.0, t)\n    return int(np.ceil(t))\n\ndef build_case_B_matrix():\n    # Five-state cycle random walk S_B, then lazy P_B = 0.5*I + 0.5*S_B\n    n = 5\n    S = np.zeros((n, n))\n    # Each node transitions to its two neighbors with probability 1/2 each\n    for i in range(n):\n        S[i, (i + 1) % n] = 0.5  # from next\n        S[i, (i - 1) % n] = 0.5  # from previous\n    P = 0.5 * np.eye(n) + 0.5 * S\n    # The problem specifies column-stochastic, so we need to transpose S.\n    return 0.5 * np.eye(n) + 0.5 * S.T\n\ndef solve():\n    # Define the test cases from the problem statement.\n    P_A = np.array([[0.95, 0.05],\n                    [0.05, 0.95]], dtype=float)\n    epsilon_A = 0.01\n\n    P_B = build_case_B_matrix()\n    epsilon_B = 0.01\n\n    P_C = np.array([[0.9, 0.1, 0.0],\n                    [0.1, 0.8, 0.1],\n                    [0.0, 0.1, 0.9]], dtype=float)\n    epsilon_C = 0.01\n\n    J4 = np.ones((4, 4), dtype=float)\n    P_D = 0.5 * np.eye(4) + 0.5 * (J4 / 4.0)\n    epsilon_D = 0.01\n\n    test_cases = [\n        (P_A, epsilon_A),\n        (P_B, epsilon_B),\n        (P_C, epsilon_C),\n        (P_D, epsilon_D),\n    ]\n\n    results = []\n    for P, eps in test_cases:\n        n = P.shape[0]\n        # Dominant eigenpair via power method\n        v1, _ = power_method(P, max_iter=10000, tol=1e-12)\n        # Deflated power method to estimate lambda2\n        v2, lambda2 = deflated_power_method(P, v1, max_iter=10000, tol=1e-12)\n        lambda_star = abs(lambda2)\n        gap = 1.0 - lambda_star\n        t_mix = mixing_time_bound(n, lambda_star, eps)\n        # Round gap to 6 decimals\n        gap_rounded = round(gap, 6)\n        results.append([gap_rounded, t_mix])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```"
        }
    ]
}