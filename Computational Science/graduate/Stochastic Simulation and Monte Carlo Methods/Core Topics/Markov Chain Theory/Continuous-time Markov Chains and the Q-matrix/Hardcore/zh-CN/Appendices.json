{
    "hands_on_practices": [
        {
            "introduction": "在分析随机过程时，一个核心任务是计算关键事件发生的时间。本练习将探讨如何推导连续时间马尔可夫链（CTMC）首次进入吸收态所需时间的完整概率分布。通过直接对主导暂态动力学的子生成元矩阵进行谱分析，您将学习如何计算矩阵指数 $\\exp(Tt)$，并阐明其与吸收时间的生存函数之间的深刻联系。这项实践不仅能提升您运用线性代数解决随机动力学问题的能力，还能让您直观地理解生成元 $Q$ 的特征值如何决定了吸收时间分布中指数混合项的衰减率。",
            "id": "3298780",
            "problem": "考虑一个定义在状态空间 $\\{1,2,3,4\\}$ 上的有限连续时间马尔可夫链 (CTMC)，其生成元（也称为 $Q$ 矩阵）如下，其中状态 $4$ 是一个吸收态。生成元为\n$$\nQ \\;=\\;\n\\begin{pmatrix}\n-2   2   0   0 \\\\\n0   -3   3   0 \\\\\n0   0   -5   5 \\\\\n0   0   0   0\n\\end{pmatrix}.\n$$\n设初始分布集中在状态 $1$，即在 $\\{1,2,3\\}$ 上的初始瞬时态分布为 $\\alpha = (1,0,0)$。令 $\\tau$ 表示吸收时间，即 CTMC 首次进入状态 $4$ 的时间。\n\n从生成元 $Q$ 的基本定义、瞬时块和吸收块的划分，以及通过将 $Q$ 限制在 $\\{1,2,3\\}$ 上得到的瞬时子生成元 $T$ 出发，使用谱分析（$T$ 的对角化）或均匀化方法，推导吸收时间 $\\tau$ 的分布。将你的结果解释为连续时间下的指数分布混合。\n\n你的任务是：提供 $\\tau$ 在 $t \\ge 0$ 时的概率密度函数 $f_{\\tau}(t)$ 的精确解析表达式。不要对你的答案进行四舍五入。",
            "solution": "该问题在连续时间马尔可夫链 (CTMC) 理论框架下是良定的，且具有科学依据。所有必要信息都已提供，目标也已明确陈述。因此，我们可以着手求解。\n\nCTMC 的状态空间为 $S = \\{1, 2, 3, 4\\}$。瞬时态集合为 $\\mathcal{T} = \\{1, 2, 3\\}$，吸收态集合为 $\\mathcal{A} = \\{4\\}$。生成矩阵 $Q$ 可以分块为\n$$\nQ = \\begin{pmatrix} T   R \\\\ 0   0 \\end{pmatrix}\n$$\n其中 $T$ 是瞬时态之间转移的子生成元，而 $R$ 是从瞬时态到吸收态的转移率矩阵。根据给定的 $Q$ 矩阵，我们可以得到\n$$\nT \\;=\\;\n\\begin{pmatrix}\n-2   2   0 \\\\\n0   -3   3 \\\\\n0   0   -5\n\\end{pmatrix}\n\\quad \\text{和} \\quad\nR \\;=\\;\n\\begin{pmatrix}\n0 \\\\\n0 \\\\\n5\n\\end{pmatrix}.\n$$\n吸收时间 $\\tau$ 是过程首次进入吸收态 $4$ 的时间。$\\tau$ 的生存函数 $S_{\\tau}(t) = P(\\tau  t)$ 是指在时间 $t$ 之前过程未被吸收的概率。给定瞬时态上的初始分布 $\\alpha$，该概率由下式给出\n$$\nS_{\\tau}(t) = \\alpha P_{\\mathcal{T}}(t) \\mathbf{1}\n$$\n其中 $P_{\\mathcal{T}}(t) = \\exp(Tt)$ 是瞬时态的转移概率矩阵，$\\mathbf{1}$ 是一个相应维度的全 1 列向量。\n问题陈述该过程从状态 $1$ 开始，这对应于初始瞬时态分布 $\\alpha = (1, 0, 0)$。因此，$S_{\\tau}(t)$ 是矩阵 $\\exp(Tt)$ 第一行元素之和：\n$$\nS_{\\tau}(t) = \\begin{pmatrix} 1  0  0 \\end{pmatrix} \\exp(Tt) \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\sum_{j \\in \\mathcal{T}} [\\exp(Tt)]_{1j}.\n$$\n为了计算 $\\exp(Tt)$，我们使用谱分析。我们求解 $T$ 的特征值和特征向量。由于 $T$ 是一个上三角矩阵，其特征值即为对角线元素：$\\lambda_1 = -2$，$\\lambda_2 = -3$ 和 $\\lambda_3 = -5$。这些特征值互不相同，因此 $T$ 是可对角化的。\n\n我们求出与每个 $\\lambda_i$ 对应的右特征向量 $u_i$，满足 $T u_i = \\lambda_i u_i$。\n对于 $\\lambda_1 = -2$：$(T+2I)u_1=0 \\implies \\begin{pmatrix} 0  2  0 \\\\ 0  -1  3 \\\\ 0  0  -3 \\end{pmatrix} u_1 = 0 \\implies u_1 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n对于 $\\lambda_2 = -3$：$(T+3I)u_2=0 \\implies \\begin{pmatrix} 1  2  0 \\\\ 0  0  3 \\\\ 0  0  -2 \\end{pmatrix} u_2 = 0 \\implies u_2 = \\begin{pmatrix} -2 \\\\ 1 \\\\ 0 \\end{pmatrix}$。\n对于 $\\lambda_3 = -5$：$(T+5I)u_3=0 \\implies \\begin{pmatrix} 3  2  0 \\\\ 0  2  3 \\\\ 0  0  0 \\end{pmatrix} u_3 = 0 \\implies u_3 = \\begin{pmatrix} 2 \\\\ -3 \\\\ 2 \\end{pmatrix}$。\n\n我们用这些特征向量作为列来构造矩阵 $P$：\n$$\nP = \\begin{pmatrix} 1  -2  2 \\\\ 0  1  -3 \\\\ 0  0  2 \\end{pmatrix}.\n$$\n$T$ 的对角化形式为 $T = PDP^{-1}$，其中 $D = \\text{diag}(-2, -3, -5)$。那么矩阵指数为 $\\exp(Tt) = P\\exp(Dt)P^{-1}$。首先，我们计算 $P$ 的逆矩阵：\n$$\nP^{-1} = \\begin{pmatrix} 1  2  2 \\\\ 0  1  3/2 \\\\ 0  0  1/2 \\end{pmatrix}.\n$$\n现在我们可以计算 $\\exp(Tt)$：\n$$\n\\exp(Tt) = P \\begin{pmatrix} \\exp(-2t)  0  0 \\\\ 0  \\exp(-3t)  0 \\\\ 0  0  \\exp(-5t) \\end{pmatrix} P^{-1}.\n$$\n如前所述，我们需要 $\\exp(Tt)$ 第一行元素之和。第一行由 $e_1^T \\exp(Tt)$ 给出，其中 $e_1^T = (1, 0, 0)$。\n$$\ne_1^T \\exp(Tt) = e_1^T P \\exp(Dt) P^{-1} = \\begin{pmatrix} 1  -2  2 \\end{pmatrix} \\begin{pmatrix} \\exp(-2t)  0  0 \\\\ 0  \\exp(-3t)  0 \\\\ 0  0  \\exp(-5t) \\end{pmatrix} P^{-1}\n$$\n$$\n= \\begin{pmatrix} \\exp(-2t)  -2\\exp(-3t)  2\\exp(-5t) \\end{pmatrix} \\begin{pmatrix} 1  2  2 \\\\ 0  1  3/2 \\\\ 0  0  1/2 \\end{pmatrix}\n$$\n这得到了行向量 $( [\\exp(Tt)]_{11}, [\\exp(Tt)]_{12}, [\\exp(Tt)]_{13} )$：\n$$\n\\begin{align*}\n[\\exp(Tt)]_{11} = \\exp(-2t) \\\\\n[\\exp(Tt)]_{12} = 2\\exp(-2t) - 2\\exp(-3t) \\\\\n[\\exp(Tt)]_{13} = 2\\exp(-2t) - 3\\exp(-3t) + \\exp(-5t)\n\\end{align*}\n$$\n生存函数 $S_{\\tau}(t)$ 是这些概率之和：\n$$\nS_{\\tau}(t) = \\exp(-2t) + (2\\exp(-2t) - 2\\exp(-3t)) + (2\\exp(-2t) - 3\\exp(-3t) + \\exp(-5t))\n$$\n$$\nS_{\\tau}(t) = 5\\exp(-2t) - 5\\exp(-3t) + \\exp(-5t)\n$$\n吸收时间 $\\tau$ 的概率密度函数 (PDF) $f_{\\tau}(t)$ 是生存函数关于时间 $t \\ge 0$ 的负导数：\n$$\nf_{\\tau}(t) = -\\frac{d}{dt} S_{\\tau}(t) = -\\frac{d}{dt} (5\\exp(-2t) - 5\\exp(-3t) + \\exp(-5t))\n$$\n$$\nf_{\\tau}(t) = - (5(-2)\\exp(-2t) - 5(-3)\\exp(-3t) + (-5)\\exp(-5t))\n$$\n$$\nf_{\\tau}(t) = - (-10\\exp(-2t) + 15\\exp(-3t) - 5\\exp(-5t))\n$$\n$$\nf_{\\tau}(t) = 10\\exp(-2t) - 15\\exp(-3t) + 5\\exp(-5t)\n$$\n此表达式给出了 $t \\ge 0$ 时的概率密度函数。这一结果可以通过观察 CTMC 的结构 $1 \\to 2 \\to 3 \\to 4$ 来解释，它意味着吸收时间 $\\tau$ 是在状态 $1$、$2$ 和 $3$ 中逗留时间的总和。这些逗留时间是独立的指数随机变量，$T_1 \\sim \\text{Exp}(2)$，$T_2 \\sim \\text{Exp}(3)$ 和 $T_3 \\sim \\text{Exp}(5)$。它们的和 $\\tau = T_1 + T_2 + T_3$ 的分布是亚指数分布。其概率密度函数是指数项的线性组合，可以看作是一种广义混合。推导出的表达式即为此分布的精确形式。",
            "answer": "$$\\boxed{10\\exp(-2t) - 15\\exp(-3t) + 5\\exp(-5t)}$$"
        },
        {
            "introduction": "当我们面对有多个可能最终结局的系统时，一个自然的问题便是“过程将以哪种结局告终？”。本练习将关注点从事件发生的“时间”转移到“是否”发生，旨在计算在到达某个吸收态之前先到达另一个吸收态的概率。您将运用“一步分析”法，通过考察过程在无限小时间步后的状态，为吸收概率建立一个差分方程系统。这项实践揭示了如何利用生成元 $Q$ 所定义的局部转移性质来求解全局概率，是解决随机过程问题的一种基础而强大的思想。",
            "id": "3298791",
            "problem": "考虑一个在有限状态空间 $\\{0,1,2,\\dots,j\\}$ 上的生灭连续时间马尔可夫链 (CTMC)，其生成元（也称为 $Q$ 矩阵）的元素由 $q_{i,i+1}=\\lambda_{i}$，$q_{i,i-1}=\\mu_{i}$，以及对 $1 \\leq i \\leq j-1$ 有 $q_{i,i}=-(\\lambda_{i}+\\mu_{i})$ 给出，而 $q_{0,0}=0$ 和 $q_{j,j}=0$，因此 $0$ 和 $j$ 是吸收态。假设对所有 $1 \\leq i \\leq j-1$ 都有 $\\lambda_{i}  0$ 和 $\\mu_{i}  0$，并且该链是非爆炸的。\n\n令 $T_{A}$ 表示到达集合 $A \\subseteq \\{0,1,\\dots,j\\}$ 的首达时间。对每个 $i \\in \\{0,1,\\dots,j\\}$ 定义\n$$\nh_{i} \\equiv \\mathbb{P}_{i}\\big(T_{\\{j\\}}  T_{\\{0\\}}\\big),\n$$\n即从状态 $i$ 出发，链在到达状态 $0$ 之前先到达目标状态 $j$ 的概率。\n\n任务：\n- 仅从 CTMC 的生成元（$Q$ 矩阵）的定义和第一步分析出发，推导出 $h_{i}$（对于 $1 \\leq i \\leq j-1$）必须满足的后向差分方程，以及在 $i=0$ 和 $i=j$ 处的边界条件。\n- 求解这些方程，以生灭速率之比的形式，获得 $h_{i}$ 的闭式解。您的解必须用这些比率的乘积和求和来明确表示。\n- 最后，将问题特化到齐次情况，即 $\\lambda_{i} \\equiv \\lambda  0$ 和 $\\mu_{i} \\equiv \\mu  0$，且 $\\mu \\neq \\lambda$。定义死亡率与出生率之比 $\\rho \\equiv \\mu/\\lambda$，并用 $i$、$j$ 和 $\\rho$ 来表示 $h_{i}$（对于 $1 \\leq i \\leq j-1$）。\n\n将您的最终答案表示为齐次情况下 $h_{i}$ 作为 $i$、$j$ 和 $\\rho$ 的函数的单一闭式解析表达式。无需数值取整。",
            "solution": "所述问题是连续时间马尔可夫链理论中一个标准的、适定的问题，在数学上和科学上都是合理的。因此，我们可以进行完整的推导。\n\n该问题涉及一个在有限状态空间 $S = \\{0, 1, 2, \\dots, j\\}$ 上的生灭连续时间马尔可夫链。状态 $0$ 和 $j$ 是吸收态，这反映在生成元矩阵的元素 $q_{0,0}=0$ 和 $q_{j,j}=0$ 中。对于瞬态 $i \\in \\{1, 2, \\dots, j-1\\}$，转移速率由 $q_{i, i+1} = \\lambda_i  0$ 和 $q_{i, i-1} = \\mu_i  0$ 给出。对角元素为 $q_{i,i} = -(\\lambda_i + \\mu_i)$，表示离开状态 $i$ 的总速率。\n\n我们需要求出 $h_i \\equiv \\mathbb{P}_{i}(T_{\\{j\\}}  T_{\\{0\\}})$，即过程从状态 $i$ 开始，在状态 $j$ 被吸收而不是在状态 $0$ 被吸收的概率。\n\n**第 1 部分：后向方程的推导**\n\n吸收概率 $h_i$ 在瞬态集 $\\{1, 2, \\dots, j-1\\}$ 上关于生成元 $Q$ 是调和的。这意味着对于此集合中的任何 $i$，都有 $(Qh)(i) = 0$。算子 $(Qh)(i)$ 定义为 $\\sum_{k \\in S} q_{i,k} h_k$。对于状态 $i \\in \\{1, 2, \\dots, j-1\\}$，唯一非零的非对角速率是到状态 $i-1$ 和 $i+1$ 的速率。\n\n条件 $(Qh)(i) = 0$ 可转换为：\n$$ q_{i, i-1} h_{i-1} + q_{i, i} h_i + q_{i, i+1} h_{i+1} = 0 $$\n代入给定的生成元元素：\n$$ \\mu_i h_{i-1} - (\\lambda_i + \\mu_i)h_i + \\lambda_i h_{i+1} = 0 $$\n此方程对 $i \\in \\{1, 2, \\dots, j-1\\}$ 成立。我们可以重新整理它以得到一个后向差分方程。\n$$ \\lambda_i (h_{i+1} - h_i) = \\mu_i (h_i - h_{i-1}) $$\n\n接下来，我们建立 $i=0$ 和 $i=j$ 的边界条件。\n如果过程从状态 $i=0$ 开始，由于此状态是吸收态，过程将永远停留在 $0$。因此，到达状态 $0$ 的首达时间为 $T_{\\{0\\}} = 0$。由于 $j \\neq 0$，到达状态 $j$ 的首达时间必须为 $T_{\\{j\\}}  0$（或无穷大）。因此，事件 $T_{\\{j\\}}  T_{\\{0\\}}$ 是不可能的。其概率为 $0$。\n$$ h_0 = \\mathbb{P}_0(T_{\\{j\\}}  T_{\\{0\\}}) = 0 $$\n如果过程从状态 $i=j$ 开始，它已经处于目标吸收态。首达时间为 $T_{\\{j\\}} = 0$。由于 $j \\neq 0$，$T_{\\{0\\}}  0$。事件 $T_{\\{j\\}}  T_{\\{0\\}}$ 是必然的。其概率为 $1$。\n$$ h_j = \\mathbb{P}_j(T_{\\{j\\}}  T_{\\{0\\}}) = 1 $$\n\n**第 2 部分：一般速率的解**\n\n令 $\\Delta_i = h_i - h_{i-1}$，对于 $i \\in \\{1, 2, \\dots, j\\}$。差分方程变为：\n$$ \\lambda_i \\Delta_{i+1} = \\mu_i \\Delta_i $$\n这给出了差分的递推关系：\n$$ \\Delta_{i+1} = \\frac{\\mu_i}{\\lambda_i} \\Delta_i \\quad \\text{对于 } 1 \\le i \\le j-1 $$\n我们可以通过迭代来求解：\n$$ \\Delta_i = \\left( \\prod_{k=1}^{i-1} \\frac{\\mu_k}{\\lambda_k} \\right) \\Delta_1 \\quad \\text{对于 } i \\ge 2 $$\n我们定义 $\\pi_0 = 1$ 以及对于 $k \\ge 1$，$\\pi_k = \\prod_{l=1}^{k} \\frac{\\mu_l}{\\lambda_l}$。那么该关系可以写成 $\\Delta_i = \\pi_{i-1} \\Delta_1$，对于 $i \\ge 1$。\n\n现在，我们将 $h_i$ 表示为这些差分的和（一个裂项和）：\n$$ h_i = h_0 + \\sum_{k=1}^{i} (h_k - h_{k-1}) = h_0 + \\sum_{k=1}^{i} \\Delta_k $$\n使用边界条件 $h_0=0$：\n$$ h_i = \\sum_{k=1}^{i} \\Delta_k = \\sum_{k=1}^{i} \\pi_{k-1} \\Delta_1 = \\Delta_1 \\sum_{k=0}^{i-1} \\pi_k $$\n为了找到常数 $\\Delta_1 = h_1 - h_0 = h_1$，我们应用第二个边界条件 $h_j=1$：\n$$ h_j = 1 = \\Delta_1 \\sum_{k=0}^{j-1} \\pi_k $$\n这意味着：\n$$ \\Delta_1 = \\frac{1}{\\sum_{k=0}^{j-1} \\pi_k} $$\n将此代回 $h_i$ 的表达式中：\n$$ h_i = \\frac{\\sum_{k=0}^{i-1} \\pi_k}{\\sum_{k=0}^{j-1} \\pi_k} = \\frac{\\sum_{k=0}^{i-1} \\left( \\prod_{l=1}^{k} \\frac{\\mu_l}{\\lambda_l} \\right)}{\\sum_{k=0}^{j-1} \\left( \\prod_{l=1}^{k} \\frac{\\mu_l}{\\lambda_l} \\right)} $$\n其中，空乘积 $\\prod_{l=1}^{0} (\\cdot)$ 被规定为 $1$。这是在一般情况下的闭式解。\n\n**第 3 部分：特化到齐次情况**\n\n我们考虑齐次情况，其中对所有有效的 $i$，有 $\\lambda_i \\equiv \\lambda  0$ 和 $\\mu_i \\equiv \\mu  0$，且 $\\mu \\neq \\lambda$。死亡率与出生率之比是常数：\n$$ \\rho \\equiv \\frac{\\mu}{\\lambda} $$\n$\\pi_k$ 项变为：\n$$ \\pi_k = \\prod_{l=1}^{k} \\frac{\\mu}{\\lambda} = \\rho^k $$\n$h_i$ 的表达式简化为等比级数之比：\n$$ h_i = \\frac{\\sum_{k=0}^{i-1} \\rho^k}{\\sum_{k=0}^{j-1} \\rho^k} $$\n因为问题陈述了 $\\mu \\neq \\lambda$，所以我们有 $\\rho \\neq 1$。我们可以使用有限等比级数的求和公式 $\\sum_{k=0}^{n-1} r^k = \\frac{r^n - 1}{r-1}$。\n将此公式应用于分子和分母：\n$$ \\sum_{k=0}^{i-1} \\rho^k = \\frac{\\rho^i - 1}{\\rho - 1} $$\n$$ \\sum_{k=0}^{j-1} \\rho^k = \\frac{\\rho^j - 1}{\\rho - 1} $$\n将这些代入 $h_i$ 的表达式中：\n$$ h_i = \\frac{\\frac{\\rho^i - 1}{\\rho - 1}}{\\frac{\\rho^j - 1}{\\rho - 1}} = \\frac{\\rho^i - 1}{\\rho^j - 1} $$\n此表达式对 $i \\in \\{1, 2, \\dots, j-1\\}$ 有效。这是在齐次情况下 $h_i$ 作为 $i$、$j$ 和 $\\rho$ 的函数的闭式解。\n为了检验，我们可以验证边界条件。对于 $i=0$，$h_0 = (\\rho^0 - 1)/(\\rho^j - 1) = (1-1)/(\\rho^j-1) = 0$。对于 $i=j$，$h_j = (\\rho^j-1)/(\\rho^j-1)=1$。该公式对边界也成立。",
            "answer": "$$\n\\boxed{\\frac{\\rho^{i} - 1}{\\rho^{j} - 1}}\n$$"
        },
        {
            "introduction": "在许多科学和工程应用中，我们不仅需要分析一个给定的模型，更需要理解模型的输出如何随其参数变化，即模型的“敏感性”。本练习将介绍似然比（或得分函数）方法，这是一种功能强大的蒙特卡洛技术，用于估计期望值对模型参数的导数。您将学习如何通过对从标称参数模拟出的路径进行重加权来计算敏感性，其中的权重来自于路径测度的雷登-尼科迪姆导数。这项实践连接了理论推导与计算统计的实际应用，通过将导数估计问题转化为一个期望值估计问题，展示了该领域的核心思想，并引入了方差缩减等实用技术。",
            "id": "3298796",
            "problem": "考虑一个在有限状态空间 $\\{0,1\\}$ 上的连续时间马尔可夫链 (CTMC) 参数族，其生成元（也称为 $Q$-矩阵）由下式给出\n$$\nQ^\\theta \\;=\\; \\begin{pmatrix}\n-\\theta   \\theta \\\\\n\\beta   -\\beta\n\\end{pmatrix},\n$$\n其中 $\\theta \\in (0,\\infty)$ 是我们感兴趣的参数，而 $\\beta \\in (0,\\infty)$ 是一个固定的常数。令 $\\{X_t^\\theta\\}_{t \\ge 0}$ 表示初始状态为 $X_0^\\theta = x_0 \\in \\{0,1\\}$ 的 CTMC，其遵循标准的 CTMC 构造：在当前状态为 $i \\in \\{0,1\\}$ 的条件下，停留时间服从速率为 $\\lambda_i^\\theta = -q_{ii}^\\theta$ 的指数分布，下一个状态 $j \\ne i$ 以转移概率 $q_{ij}^\\theta / \\lambda_i^\\theta$ 被选择。\n\n设 $T  0$ 为一个固定的时间范围，并定义可观测量 $g(X_T^\\theta) = \\mathbf{1}\\{X_T^\\theta = 1\\}$。目标是使用基于由 $Q^\\theta$ 诱导的路径测度之间的 Radon–Nikodym 导数的似然比（也称为得分函数）方法来估计路径导数 $\\partial_\\theta \\mathbb{E}[g(X_T^\\theta)]$。\n\n使用的基本原理：\n- 由生成元 $Q^\\theta$ 在 $[0,T]$ 上诱导的 CTMC 路径密度具有通常的乘法形式，由所有跳跃的 $q_{X_{t^-},X_t}^\\theta$ 之积，以及乘以负的离开率 $\\lambda_{X_t}^\\theta = -q_{X_t,X_t}^\\theta$ 的时间积分的指数给出。\n- 路径测度的 Radon–Nikodym 导数得出了在参数 $\\theta$ 下一条路径的对数似然，其关于 $\\theta$ 的导数即为得分。\n- 得分函数恒等式（在标准正则性条件下）指出，对于任何可积泛函 $H$，有 $\\partial_\\theta \\mathbb{E}_\\theta[H] = \\mathbb{E}_\\theta[H \\cdot S_T(\\theta)]$，其中 $S_T(\\theta)$ 是在 $[0,T]$ 上观测到的路径的对数似然关于 $\\theta$ 的导数。\n\n任务：\n- 从上述基本原理出发，不使用任何简便公式，推导适用于上述给定 $Q^\\theta$ 的两状态模型的得分 $S_T(\\theta)$ 的显式表达式。你的推导必须用以下项表示：\n  - 截至时间 $T$ 在状态 $0$ 中停留的总时间，记为 $\\int_0^T \\mathbf{1}\\{X_t^\\theta=0\\} \\, dt$。\n  - 截至时间 $T$ 从状态 $0$ 跳到状态 $1$ 的次数，记为 $N_{01}(T)$。\n- 使用得分函数恒等式，为 $\\partial_\\theta \\mathbb{E}[g(X_T^\\theta)]$ 获得一个形如 $\\widehat{\\Delta}_{\\mathrm{LR}} = \\frac{1}{M} \\sum_{m=1}^M g(X_T^{\\theta,(m)}) S_T^{(m)}(\\theta)$ 的似然比估计量，其中样本路径由 $m \\in \\{1,\\dots,M\\}$ 索引且相互独立。\n- 考虑通过基线 $c \\in \\mathbb{R}$ 中心化来减少方差，以构建中心化估计量 $\\widehat{\\Delta}_{\\mathrm{LR}}^{(c)} = \\frac{1}{M} \\sum_{m=1}^M \\bigl(g(X_T^{\\theta,(m)}) - c\\bigr) S_T^{(m)}(\\theta)$。解释为什么中心化能保持无偏性，并实现一个两阶段过程，其中一个预演运行被用来近似最优常数基线 $c^\\star = \\mathrm{Cov}(g(X_T^\\theta), S_T(\\theta))/\\mathrm{Var}(S_T(\\theta))$。\n- 仅使用边际概率 $p_\\theta(t) = \\mathbb{P}(X_t^\\theta=1)$ 的前向方程和初等微积分，推导两状态模型精确敏感度 $\\partial_\\theta \\mathbb{E}[g(X_T^\\theta)]$ 的闭式解。结果需用 $\\theta$、$\\beta$、$T$ 和 $x_0$ 显式表示。\n\n实现要求：\n- 实现一个精确模拟器，用于在时间范围 $[0,T]$ 内模拟给定 $Q^\\theta$ 的 $\\{0,1\\}$ 上的 CTMC 样本路径，并在每次重复中累积 $N_{01}(T)$ 和 $\\int_0^T \\mathbf{1}\\{X_t^\\theta=0\\}\\,dt$ 以及最终状态 $X_T^\\theta$。在各次重复中使用独立同分布的样本。\n- 对下面的每个测试用例，使用两阶段蒙特卡洛计算：\n  - 一个包含 $M_{\\text{pilot}}$ 个样本的预演阶段，用于估计基线 $\\widehat{c}$，公式为 $\\widehat{c} = \\widehat{\\mathrm{Cov}}(g,S)/\\widehat{\\mathrm{Var}}(S)$。\n  - 一个包含 $M_{\\text{main}}$ 个样本的主要阶段，用于估计：\n    - 未中心化的似然比均值 $\\widehat{\\Delta}_{\\mathrm{LR}}$ 和样本方差 $\\widehat{\\mathrm{Var}}(\\text{uncentered})$。\n    - 中心化的似然比均值 $\\widehat{\\Delta}_{\\mathrm{LR}}^{(\\widehat{c})}$ 和样本方差 $\\widehat{\\mathrm{Var}}(\\text{centered})$。\n- 使用你的闭式公式独立计算精确敏感度 $\\partial_\\theta \\mathbb{E}[g(X_T^\\theta)]$，并将其与蒙特卡洛均值进行比较。使用绝对容差 $\\varepsilon = 0.02$ 来判断是否一致。\n\n测试套件：\n- 用例 $\\mathrm{A}$：$\\theta = 1.5$，$\\beta = 2.0$，$T = 1.0$，$x_0 = 0$。\n- 用例 $\\mathrm{B}$：$\\theta = 0.2$，$\\beta = 3.0$，$T = 2.0$，$x_0 = 0$。\n- 用例 $\\mathrm{C}$：$\\theta = 1.0$，$\\beta = 1.0$，$T = 0.0$，$x_0 = 1$。\n- 用例 $\\mathrm{D}$：$\\theta = 4.0$，$\\beta = 0.5$，$T = 5.0$，$x_0 = 0$。\n- 方差增长检查（在两个时间范围内使用相同参数）：\n  - 用例 $\\mathrm{E1}$：$\\theta = 1.5$，$\\beta = 2.0$，$T = 0.5$，$x_0 = 0$。\n  - 用例 $\\mathrm{E2}$：$\\theta = 1.5$，$\\beta = 2.0$，$T = 3.0$，$x_0 = 0$。\n\n量化输出：\n- 对于用例 $\\mathrm{A}$–$\\mathrm{D}$ 中的每一个，输出两个布尔值：\n  - $b_1$：主要阶段的似然比估计（未中心化）与精确敏感度之间的绝对误差是否最多为 $\\varepsilon$。\n  - $b_2$：主要阶段的中心化方差是否小于或等于主要阶段的未中心化方差。\n- 对于使用用例 $\\mathrm{E1}$ 和 $\\mathrm{E2}$ 的方差增长检查，输出一个布尔值：\n  - $b_3$：$T=3.0$ 时的未中心化似然比方差是否大于或等于 $T=0.5$ 时的方差。\n\n蒙特卡洛规模和可复现性：\n- 对每个用例使用 $M_{\\text{pilot}} = 20000$ 和 $M_{\\text{main}} = 120000$，并固定随机种子以确保可复现性。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表。列表必须按如下顺序排列\n$$\n[b_{\\mathrm{A},1}, b_{\\mathrm{A},2}, b_{\\mathrm{B},1}, b_{\\mathrm{B},2}, b_{\\mathrm{C},1}, b_{\\mathrm{C},2}, b_{\\mathrm{D},1}, b_{\\mathrm{D},2}, b_{\\mathrm{E},3}],\n$$\n其中每个 $b_{\\cdot,\\cdot}$ 是如上定义的布尔值。不应打印任何其他文本。",
            "solution": "用户提供的问题经评估和验证，是计算随机建模领域中一个定义明确且科学严谨的练习。所有必要的参数和定义均已提供，理论基础是标准的，目标清晰且可形式化。因此，我们可以着手提供完整的解决方案。\n\n### 第一部分：得分函数 $S_T(\\theta)$ 的推导\n\n得分函数是样本路径的对数似然函数相对于目标参数 $\\theta$ 的导数。在有限状态空间上，一个在区间 $[0, T]$ 内观测的连续时间马尔可夫链 (CTMC) 的路径由初始状态 $X_0$、访问的状态序列以及它们之间的跳跃时间所表征。\n\n一个特定路径实现 $\\omega = (X_s)_{s \\in [0,T]}$ 的似然函数由每次跳跃的转移率和在每个状态中停留时间的生存概率的乘积给出。这可以表示为：\n$$\nL_T(\\theta; \\omega) = \\left( \\prod_{k=1}^{N(T)} q_{X_{t_k^-}, X_{t_k}}^\\theta \\right) \\exp\\left( -\\int_0^T \\lambda_{X_s}^\\theta \\, ds \\right)\n$$\n其中 $N(T)$ 是在 $[0, T]$ 内发生在时间 $t_k$ 的跳跃次数，$q_{ij}^\\theta$ 是从状态 $i$ 到 $j$ 的转移率，$\\lambda_i^\\theta = -q_{ii}^\\theta$ 是从状态 $i$ 的总离开率。\n\n对数似然函数 $\\log L_T(\\theta)$ 为：\n$$\n\\log L_T(\\theta; \\omega) = \\sum_{k=1}^{N(T)} \\log q_{X_{t_k^-}, X_{t_k}}^\\theta - \\int_0^T \\lambda_{X_s}^\\theta \\, ds\n$$\n对于给定的生成元为 $Q^\\theta = \\begin{pmatrix} -\\theta  \\theta \\\\ \\beta  -\\beta \\end{pmatrix}$ 的两状态模型，我们有：\n-   转移率：$q_{01}^\\theta = \\theta$ 和 $q_{10}^\\theta = \\beta$。只有 $q_{01}^\\theta$ 依赖于 $\\theta$。\n-   离开率：$\\lambda_0^\\theta = \\theta$ 和 $\\lambda_1^\\theta = \\beta$。只有 $\\lambda_0^\\theta$ 依赖于 $\\theta$。\n\n令 $N_{01}(T)$ 为在 $[0, T]$ 内从状态 $0$ 到 $1$ 的跳跃次数，$N_{10}(T)$ 为从 $1$ 到 $0$ 的跳跃次数。令 $T_0 = \\int_0^T \\mathbf{1}\\{X_s=0\\} \\, ds$ 和 $T_1 = \\int_0^T \\mathbf{1}\\{X_s=1\\} \\, ds$ 分别为在状态 $0$ 和 $1$ 中停留的总时间。\n\n对于这个特定模型，对数似然函数变为：\n$$\n\\log L_T(\\theta) = N_{01}(T) \\log(\\theta) + N_{10}(T) \\log(\\beta) - T_0 \\theta - T_1 \\beta\n$$\n得分函数 $S_T(\\theta)$ 是 $\\log L_T(\\theta)$ 关于 $\\theta$ 的导数。对于一条固定的样本路径，量 $N_{01}(T)$、$N_{10}(T)$、$T_0$ 和 $T_1$ 都是常数。\n$$\nS_T(\\theta) = \\frac{\\partial}{\\partial \\theta} \\left( N_{01}(T) \\log(\\theta) + N_{10}(T) \\log(\\beta) - T_0 \\theta - T_1 \\beta \\right)\n$$\n求导后，我们发现只有涉及 $\\theta$ 的项有贡献：\n$$\nS_T(\\theta) = \\frac{N_{01}(T)}{\\theta} - T_0\n$$\n这就是用所要求的路径统计量表示的得分函数的显式表达式。\n\n### 第二部分：似然比估计与中心化\n\n得分函数恒等式指出，对于一个适当正则的可观测量 $H$，有 $\\partial_\\theta \\mathbb{E}_\\theta[H] = \\mathbb{E}_\\theta[H \\cdot S_T(\\theta)]$。将此应用于我们的可观测量 $g(X_T^\\theta) = \\mathbf{1}\\{X_T^\\theta = 1\\}$，敏感度为 $\\partial_\\theta \\mathbb{E}[g(X_T^\\theta)] = \\mathbb{E}[g(X_T^\\theta) S_T(\\theta)]$。一个基于 $M$ 条独立路径的蒙特卡洛估计量为：\n$$\n\\widehat{\\Delta}_{\\mathrm{LR}} = \\frac{1}{M} \\sum_{m=1}^M g(X_T^{\\theta,(m)}) S_T^{(m)}(\\theta)\n$$\n为了减少该估计量的方差，可以引入一个基线 $c \\in \\mathbb{R}$，构建中心化估计量：\n$$\n\\widehat{\\Delta}_{\\mathrm{LR}}^{(c)} = \\frac{1}{M} \\sum_{m=1}^M \\bigl(g(X_T^{\\theta,(m)}) - c\\bigr) S_T^{(m)}(\\theta)\n$$\n对于任何常数 $c$，该估计量都保持无偏，因为得分函数的期望为零，即 $\\mathbb{E}[S_T(\\theta)] = 0$。此性质在允许交换微分和积分的正则性条件下成立，而这些条件在此处是满足的。\n中心化估计量的期望为：\n$$\n\\mathbb{E}[\\widehat{\\Delta}_{\\mathrm{LR}}^{(c)}] = \\mathbb{E}[(g(X_T^\\theta) - c) S_T(\\theta)] = \\mathbb{E}[g(X_T^\\theta) S_T(\\theta)] - c \\mathbb{E}[S_T(\\theta)] = \\mathbb{E}[g(X_T^\\theta) S_T(\\theta)] - c \\cdot 0 = \\partial_\\theta \\mathbb{E}[g(X_T^\\theta)]\n$$\n问题指定使用两阶段方法来估计一个基线 $c^\\star = \\mathrm{Cov}(g(X_T^\\theta), S_T(\\theta))/\\mathrm{Var}(S_T(\\theta))$。这是通过使用一个包含 $M_{\\text{pilot}}$ 个样本的预演运行来计算样本估计 $\\widehat{\\mathrm{Cov}}(g,S)$ 和 $\\widehat{\\mathrm{Var}}(S)$，从而获得一个估计值 $\\widehat{c}$，然后在包含 $M_{\\text{main}}$ 个样本的主要运行中使用该估计值。\n\n### 第三部分：通过前向方程计算精确敏感度\n\n精确敏感度可以解析推导。设 $p_1(t) = \\mathbb{P}(X_t^\\theta=1)$。状态概率根据柯尔莫可洛夫前向方程 $\\frac{d\\vec{p}}{dt} = \\vec{p} Q^\\theta$ 演化。对于 $p_1(t)$，这产生以下常微分方程：\n$$\n\\frac{dp_1(t)}{dt} = p_0(t)q_{01}^\\theta + p_1(t)q_{11}^\\theta = (1-p_1(t))\\theta + p_1(t)(-\\beta) = \\theta - (\\theta+\\beta)p_1(t)\n$$\n这是一个一阶线性常微分方程。在初始条件 $p_1(0) = \\mathbf{1}\\{x_0=1\\}$ 下，在时间 $T$ 的解为：\n$$\np_1(T) = \\left(p_1(0) - \\frac{\\theta}{\\theta+\\beta}\\right) e^{-(\\theta+\\beta)T} + \\frac{\\theta}{\\theta+\\beta}\n$$\n我们要求 $p_1(T)$ 关于 $\\theta$ 的导数：\n$$\n\\frac{\\partial p_1(T)}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} \\left[ \\left(p_1(0) - \\frac{\\theta}{\\theta+\\beta}\\right) e^{-(\\theta+\\beta)T} + \\frac{\\theta}{\\theta+\\beta} \\right]\n$$\n使用乘法和除法求导法则，我们得到：\n$$\n\\frac{\\partial p_1(T)}{\\partial \\theta} = \\left(-\\frac{\\beta}{(\\theta+\\beta)^2}\\right)e^{-(\\theta+\\beta)T} + \\left(p_1(0) - \\frac{\\theta}{\\theta+\\beta}\\right)\\left(-T e^{-(\\theta+\\beta)T}\\right) + \\frac{\\beta}{(\\theta+\\beta)^2}\n$$\n这个表达式可以简化为：\n$$\n\\frac{\\partial p_1(T)}{\\partial \\theta} = \\frac{\\beta}{(\\theta+\\beta)^2} \\left(1 - e^{-(\\theta+\\beta)T}\\right) - T \\left(p_1(0) - \\frac{\\theta}{\\theta+\\beta}\\right) e^{-(\\theta+\\beta)T}\n$$\n这个闭式公式提供了精确值，蒙特卡洛估计将以此为基准进行比较。\n实现将遵循这些推导，通过模拟 CTMC 路径来收集统计数据，计算（非中心化和中心化的）似然比估计值，将其与精确值进行比较，并评估所需的布尔条件。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the CTMC sensitivity analysis problem as specified.\n    \n    This function encapsulates all logic, including simulation, analytical calculations,\n    and result aggregation, to produce the final output in the required format.\n    It adheres to the specified Python version and library constraints.\n    \"\"\"\n\n    # Fixed random seed for reproducibility as per problem statement\n    SEED = 42\n    \n    # Monte Carlo simulation parameters\n    M_PILOT = 20000\n    M_MAIN = 120000\n    EPSILON = 0.02\n\n    # Global RNG instance for the entire run\n    RNG = np.random.default_rng(SEED)\n\n    def ctmc_simulator(theta, beta, T, x0):\n        \"\"\"Simulates one path of the 2-state CTMC.\"\"\"\n        current_time = 0.0\n        current_state = x0\n        \n        time_in_state_0 = 0.0\n        jumps_0_to_1 = 0\n\n        if T == 0.0:\n            return x0, 0.0, 0\n        \n        while current_time  T:\n            is_state_0 = (current_state == 0)\n            \n            rate = theta if is_state_0 else beta\n            \n            holding_time = RNG.exponential(1.0 / rate)\n            \n            time_spent_in_state = min(holding_time, T - current_time)\n            \n            if is_state_0:\n                time_in_state_0 += time_spent_in_state\n                \n            current_time += time_spent_in_state\n            \n            if current_time  T: # A jump occurred before T\n                if is_state_0:\n                    jumps_0_to_1 += 1\n                current_state = 1 - current_state\n            # else: process terminates at T, state doesn't change\n            \n        return current_state, time_in_state_0, jumps_0_to_1\n\n    def exact_sensitivity(theta, beta, T, x0):\n        \"\"\"Computes the exact sensitivity using the derived analytical formula.\"\"\"\n        p1_0 = 1.0 if x0 == 1 else 0.0\n        \n        if T == 0.0:\n            return 0.0\n\n        s = theta + beta\n        exp_term = np.exp(-s * T)\n        \n        deriv = (beta / s**2) * (1 - exp_term) - T * (p1_0 - theta / s) * exp_term\n        return deriv\n    \n    def run_simulation_for_case(params):\n        \"\"\"Executes the two-stage MC simulation for a given test case.\"\"\"\n        theta, beta, T, x0 = params\n\n        # Pilot Stage to estimate the baseline c\n        pilot_g = np.zeros(M_PILOT)\n        pilot_S = np.zeros(M_PILOT)\n        \n        for i in range(M_PILOT):\n            final_state, time_in_0, n_01 = ctmc_simulator(theta, beta, T, x0)\n            pilot_g[i] = 1.0 if final_state == 1 else 0.0\n            pilot_S[i] = n_01 / theta - time_in_0\n\n        var_S = np.var(pilot_S, ddof=1)\n        if var_S > 1e-15:\n            # np.cov uses N-1 denominator by default, which is sample covariance\n            cov_matrix = np.cov(pilot_g, pilot_S)\n            cov_g_S = cov_matrix[0, 1]\n            c_hat = cov_g_S / var_S\n        else:\n            # If Score has no variance (e.g., T=0), any baseline works as S=0.\n            c_hat = 0.0\n\n        # Main Stage for estimation\n        uncentered_lr_samples = np.zeros(M_MAIN)\n        centered_lr_samples = np.zeros(M_MAIN)\n\n        for i in range(M_MAIN):\n            final_state, time_in_0, n_01 = ctmc_simulator(theta, beta, T, x0)\n            g = 1.0 if final_state == 1 else 0.0\n            S = n_01 / theta - time_in_0\n\n            uncentered_lr_samples[i] = g * S\n            centered_lr_samples[i] = (g - c_hat) * S\n\n        uncentered_mean = np.mean(uncentered_lr_samples)\n        uncentered_var = np.var(uncentered_lr_samples, ddof=1)\n        \n        centered_var = np.var(centered_lr_samples, ddof=1)\n\n        exact_val = exact_sensitivity(theta, beta, T, x0)\n\n        b1 = np.abs(uncentered_mean - exact_val) = EPSILON\n        b2 = centered_var = uncentered_var\n\n        return b1, b2, uncentered_var\n\n    test_cases = {\n        \"A\": (1.5, 2.0, 1.0, 0),\n        \"B\": (0.2, 3.0, 2.0, 0),\n        \"C\": (1.0, 1.0, 0.0, 1),\n        \"D\": (4.0, 0.5, 5.0, 0),\n        \"E1\": (1.5, 2.0, 0.5, 0),\n        \"E2\": (1.5, 2.0, 3.0, 0)\n    }\n\n    final_results = []\n    \n    # Cases A, B, C, D\n    for case_name in [\"A\", \"B\", \"C\", \"D\"]:\n        params = test_cases[case_name]\n        b1, b2, _ = run_simulation_for_case(params)\n        final_results.extend([b1, b2])\n\n    # Case E for variance growth check\n    _, _, var_e1 = run_simulation_for_case(test_cases[\"E1\"])\n    _, _, var_e2 = run_simulation_for_case(test_cases[\"E2\"])\n    bE3 = var_e2 >= var_e1\n    final_results.append(bE3)\n    \n    # Format the final output as a single line string\n    # Python's str(True) is 'True', which is a standard boolean representation.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}