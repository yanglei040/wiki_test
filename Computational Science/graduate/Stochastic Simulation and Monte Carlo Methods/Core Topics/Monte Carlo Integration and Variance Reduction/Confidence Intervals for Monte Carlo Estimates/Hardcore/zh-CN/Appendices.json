{
    "hands_on_practices": [
        {
            "introduction": "蒙特卡洛置信区间的宽度与估计量的方差直接相关。因此，设计高效模拟的一个主要目标就是减小此方差。本练习将深入探讨分层抽样这一强大的方差缩减技术，并要求你解决一个经典的优化问题：如何在不同层之间最好地分配固定的计算预算，以实现尽可能小的估计量方差，从而获得最窄的置信区间。这个关于奈曼分配（Neyman allocation）的推导是蒙特卡洛方法中高效实验设计的基石。",
            "id": "3298330",
            "problem": "一位计算科学家试图在分层蒙特卡罗设计下估计一个感兴趣量的总体均值。总体被划分为 $H \\geq 2$ 个不相交的层，由 $h \\in \\{1,\\dots,H\\}$ 索引。层的权重已知，由 $\\{p_h\\}_{h=1}^{H}$ 给出，且满足 $\\sum_{h=1}^{H} p_h = 1$ 以及对每个 $h$ 都有 $p_h \\in (0,1)$。在层 $h$ 内，抽样得到独立同分布的随机变量 $\\{X_{h,i}\\}_{i=1}^{n_h}$，其方差为有限值 $\\sigma_h^2 \\in (0,\\infty)$。目标是使用分层蒙特卡罗估计量 $\\hat{\\mu} = \\sum_{h=1}^{H} p_h \\bar{X}_h$（其中 $\\bar{X}_h = n_h^{-1} \\sum_{i=1}^{n_h} X_{h,i}$）来估计全局均值 $\\mu = \\sum_{h=1}^{H} p_h \\mu_h$，其中 $\\mu_h = \\mathbb{E}[X_{h,1}]$。分配 $\\{n_h\\}$ 是设计变量，由科学家在抽样前选择。\n\n在层 $h$ 中抽取的每个样本都会产生一个已知的、正的单位成本 $c_h \\in (0,\\infty)$。可用的总预算是一个固定金额 $C \\in (0,\\infty)$，并且设计必须满足确定性预算约束 $\\sum_{h=1}^{H} c_h n_h = C$。假设为了优化的目的，$n_h$ 被视为实值设计变量，并且 $\\{X_{h,i}\\}$ 在 $h$ 和 $i$ 上是相互独立的。\n\n仅使用基本原理，即：(i) 在每层内独立同分布的条件下，层样本均值的方差为 $\\sigma_h^2 / n_h$，以及 (ii) $\\hat{\\mu}$ 的渐近正态性可由中心极限定理 (CLT) 得出，因此对于固定的 $\\alpha \\in (0,1)$，双侧 $(1-\\alpha)$ 置信区间的半宽与 $\\sqrt{\\operatorname{Var}(\\hat{\\mu})}$ 成正比，推导出在预算约束下最小化渐近置信区间半宽的分配规则 $\\{n_h\\}$。然后，将得到的最小方差 $\\operatorname{Var}(\\hat{\\mu})$ 表示为 $C$, $\\{p_h\\}$, $\\{\\sigma_h\\}$ 和 $\\{c_h\\}$ 的闭式函数。\n\n请以单个闭式解析表达式的形式提供最终答案，该表达式同时指明：(i) 每个层 $h$ 的最优分配 $n_h$，以及 (ii) $\\hat{\\mu}$ 的最小化方差。不需要进行数值计算，也不需要四舍五入。最终答案仅用 $C$, $\\{p_h\\}$, $\\{\\sigma_h\\}$ 和 $\\{c_h\\}$ 表示。",
            "solution": "问题是在分层蒙特卡罗设置中，确定样本的最优分配 $\\{n_h\\}_{h=1}^H$，以在总预算约束下最小化全局均值估计量的方差。如问题中所述，方差的最小化等价于最小化渐近置信区间的半宽。\n\n首先，我们将优化问题形式化。全局均值 $\\mu = \\sum_{h=1}^{H} p_h \\mu_h$ 的估计量由 $\\hat{\\mu} = \\sum_{h=1}^{H} p_h \\bar{X}_h$ 给出。该估计量的方差是我们要最小化的目标函数。\n$$ \\operatorname{Var}(\\hat{\\mu}) = \\operatorname{Var}\\left( \\sum_{h=1}^{H} p_h \\bar{X}_h \\right) $$\n鉴于样本 $\\{X_{h,i}\\}$ 在不同层 $h$ 之间是独立的，和的方差等于方差的和：\n$$ \\operatorname{Var}(\\hat{\\mu}) = \\sum_{h=1}^{H} \\operatorname{Var}(p_h \\bar{X}_h) = \\sum_{h=1}^{H} p_h^2 \\operatorname{Var}(\\bar{X}_h) $$\n问题给出，层 $h$ 内样本均值的方差为 $\\operatorname{Var}(\\bar{X}_h) = \\frac{\\sigma_h^2}{n_h}$。代入此表达式，我们得到目标函数 $V(\\{n_h\\})$：\n$$ V(\\{n_h\\}) = \\sum_{h=1}^{H} \\frac{p_h^2 \\sigma_h^2}{n_h} $$\n此目标函数需要关于分配向量 $\\{n_1, n_2, \\dots, n_H\\}$ 进行最小化，并受制于预算约束：\n$$ \\sum_{h=1}^{H} c_h n_h = C $$\n为了这次优化的目的，我们将样本大小 $n_h$ 视为连续的正实数变量。\n\n这是一个约束优化问题，可以使用拉格朗日乘数法求解。拉格朗日函数 $\\mathcal{L}$ 定义为：\n$$ \\mathcal{L}(\\{n_h\\}, \\lambda) = \\sum_{h=1}^{H} \\frac{p_h^2 \\sigma_h^2}{n_h} + \\lambda \\left( \\sum_{h=1}^{H} c_h n_h - C \\right) $$\n其中 $\\lambda$ 是拉格朗日乘子。为求最小值，我们将 $\\mathcal{L}$ 对每个 $n_k$（对于 $k \\in \\{1,\\dots,H\\}$）的偏导数设为零：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial n_k} = -\\frac{p_k^2 \\sigma_k^2}{n_k^2} + \\lambda c_k = 0 $$\n由于所有的 $p_k, \\sigma_k, c_k$ 都是正数，$\\lambda$ 也必须是正数。重排此方程以求解 $n_k$：\n$$ n_k^2 = \\frac{p_k^2 \\sigma_k^2}{\\lambda c_k} $$\n由于样本大小 $n_k$ 必须为正，我们取正平方根：\n$$ n_k = \\frac{p_k \\sigma_k}{\\sqrt{\\lambda} \\sqrt{c_k}} $$\n这个关系表明，一个层的最优样本大小与其权重 $p_k$ 和标准差 $\\sigma_k$ 成正比，与其抽样成本的平方根 $\\sqrt{c_k}$ 成反比。\n\n为了找到比例常数（其依赖于 $\\lambda$），我们将 $n_k$ 的这个表达式代入预算约束方程：\n$$ \\sum_{k=1}^{H} c_k \\left( \\frac{p_k \\sigma_k}{\\sqrt{\\lambda} \\sqrt{c_k}} \\right) = C $$\n$$ \\frac{1}{\\sqrt{\\lambda}} \\sum_{k=1}^{H} p_k \\sigma_k \\sqrt{c_k} = C $$\n现在我们可以解出项 $1/\\sqrt{\\lambda}$：\n$$ \\frac{1}{\\sqrt{\\lambda}} = \\frac{C}{\\sum_{j=1}^{H} p_j \\sigma_j \\sqrt{c_j}} $$\n将此代回 $n_k$ 的表达式中，得到每个层 $k$ 的显式最优分配规则：\n$$ n_k = \\left( \\frac{C}{\\sum_{j=1}^{H} p_j \\sigma_j \\sqrt{c_j}} \\right) \\frac{p_k \\sigma_k}{\\sqrt{c_k}} = C \\frac{p_k \\sigma_k / \\sqrt{c_k}}{\\sum_{j=1}^{H} p_j \\sigma_j \\sqrt{c_j}} $$\n\n接下来，我们通过将最优分配代回方差公式来推导最小化方差 $\\operatorname{Var}(\\hat{\\mu})_{min}$。一个更直接的方法是使用拉格朗日函数的一阶条件：\n从 $\\lambda c_k = \\frac{p_k^2 \\sigma_k^2}{n_k^2}$，我们可以两边乘以 $n_k$ 得到 $\\lambda c_k n_k = \\frac{p_k^2 \\sigma_k^2}{n_k}$。\n总方差是这些项在所有层上的和：\n$$ \\operatorname{Var}(\\hat{\\mu})_{min} = \\sum_{k=1}^{H} \\frac{p_k^2 \\sigma_k^2}{n_k} = \\sum_{k=1}^{H} \\lambda c_k n_k = \\lambda \\sum_{k=1}^{H} c_k n_k $$\n使用预算约束 $\\sum_{k=1}^{H} c_k n_k = C$，我们发现一个简单的关系：\n$$ \\operatorname{Var}(\\hat{\\mu})_{min} = \\lambda C $$\n为了得到最终表达式，我们需要 $\\lambda$。从我们之前关于 $1/\\sqrt{\\lambda}$ 的结果，我们将两边平方以求得 $1/\\lambda$：\n$$ \\frac{1}{\\lambda} = \\frac{C^2}{\\left( \\sum_{j=1}^{H} p_j \\sigma_j \\sqrt{c_j} \\right)^2} \\implies \\lambda = \\frac{1}{C^2} \\left( \\sum_{j=1}^{H} p_j \\sigma_j \\sqrt{c_j} \\right)^2 $$\n将 $\\lambda$ 的这个表达式代入最小方差的方程中：\n$$ \\operatorname{Var}(\\hat{\\mu})_{min} = \\left( \\frac{1}{C^2} \\left( \\sum_{h=1}^{H} p_h \\sigma_h \\sqrt{c_h} \\right)^2 \\right) C = \\frac{1}{C} \\left( \\sum_{h=1}^{H} p_h \\sigma_h \\sqrt{c_h} \\right)^2 $$\n这就提供了最优分配下最小方差的闭式表达式。\n\n最终答案包含两部分：任意层 $h$ 的最优分配 $n_h$ 的公式，以及估计量 $\\hat{\\mu}$ 的所得最小方差的公式。这些都已按要求表示。",
            "answer": "$$ \\boxed{\\begin{pmatrix} n_h = C \\frac{p_h \\sigma_h / \\sqrt{c_h}}{\\sum_{j=1}^{H} p_j \\sigma_j \\sqrt{c_j}} \\\\ \\operatorname{Var}(\\hat{\\mu}) = \\frac{1}{C} \\left( \\sum_{h=1}^{H} p_h \\sigma_h \\sqrt{c_h} \\right)^2 \\end{pmatrix}} $$"
        },
        {
            "introduction": "在许多实际应用中，例如自归一化重要性抽样，我们希望估计的量是两个期望值的比率，即 $\\rho = \\mu_Y / \\mu_Z$。为这样的比率构建置信区间需要特别小心，因为简单的基于中心极限定理（CLT）的公式不能直接适用。虽然 delta 方法提供了一种流行的一阶近似，但它可能会完全失效，特别是当分母的均值 $\\mu_Z$ 接近于零时。本练习将引导你分析一个 delta 方法给出误导性结果的场景，并介绍费勒方法（Fieller's method）作为一种更稳健的替代方案，用于构建可靠的比率置信区间。",
            "id": "3298323",
            "problem": "考虑一个期望比值的自归一化重要性抽样估计。设 $\\{(Y_i,Z_i)\\}_{i=1}^n$ 是独立同分布的，其中 $Y_i = h(X_i) w(X_i)$ 且 $Z_i = w(X_i)$，$w(X_i)  0$ 几乎必然成立，且 $h$ 是一个实值函数。目标参数是比值 $\\rho = \\mu_Y / \\mu_Z$，其中 $\\mu_Y = \\mathbb{E}[Y_i]$ 和 $\\mu_Z = \\mathbb{E}[Z_i]$。一次 $n = 400$ 次抽样的蒙特卡洛运行产生了以下汇总统计量：\n- 样本均值：$\\bar{Y} = 0.6$ 和 $\\bar{Z} = 0.02$。\n- 样本方差和协方差（以通常的无偏方式计算）：$s_{YY} = 1.0$，$s_{ZZ} = 0.09$，$s_{YZ} = 0.02$。\n\n假设联合中心极限定理（CLT）适用，因此 $\\sqrt{n}\\big((\\bar{Y},\\bar{Z}) - (\\mu_Y,\\mu_Z)\\big)$ 近似服从二元正态分布，其协方差矩阵等于总体协方差矩阵，我们用样本协方差矩阵来估计它。使用大样本正态理论，在 $95\\%$ 置信水平和临界值 $z_{0.975} = 1.96$ 的条件下，基于这些数据比较 $\\rho$ 的 Fieller 置信区间（CI）和 delta 方法置信区间（CI），并找出以下正确的陈述。特别地，分析分母的变异性如何影响 delta 方法置信区间的可靠性。\n\n选择所有适用的选项。\n\nA. $95\\%$ Fieller 置信区间近似为 $(-\\infty,\\,-63.0] \\cup [12.0,\\,\\infty)$，而 delta 方法置信区间近似为 $[-14.0,\\,74.0]$。在这种情况下，delta 方法置信区间可能具有误导性，因为分母与零没有显著差异。\n\nB. Fieller 置信区间和 delta 方法置信区间都是有限且几乎相同的，大约为 $[28.0,\\,32.0]$；因此 delta 方法在这里是可靠的。\n\nC. Fieller 置信区间在 $95\\%$ 置信水平下是整个实数轴，因为相关的二次判别式为负。\n\nD. 如果所有的 $Y_i$ 和 $Z_i$ 都乘以一个共同的正数常数，那么 $\\rho$ 的 Fieller 置信区间和 delta 方法置信区间都保持不变。",
            "solution": "问题要求基于蒙特卡洛模拟提供的样本统计数据，比较期望比值的 Fieller 置信区间（CI）和 delta 方法置信区间（CI）。\n\n### 解答推导\n\n感兴趣的参数是 `\\rho = \\mu_Y / \\mu_Z`，其估计值为 `\\hat{\\rho} = \\bar{Y} / \\bar{Z}`。\n给定数据：\n`\\hat{\\rho} = 0.6 / 0.02 = 30`。\n`n = 400`，`z \\equiv z_{0.975} = 1.96`。\n给出的样本方差为 `s_{YY} = s_Y^2 = 1.0`，`s_{ZZ} = s_Z^2 = 0.09`，样本协方差为 `s_{YZ} = 0.02`。\n\n**1. Delta 方法置信区间**\n\ndelta 方法为随机变量函数的方差提供了一个近似。对于 `\\hat{\\rho} = g(\\bar{Y}, \\bar{Z}) = \\bar{Y} / \\bar{Z}`，大样本方差近似为：\n$$ \\text{Var}(\\hat{\\rho}) \\approx \\frac{1}{n} (\\nabla g)^T \\Sigma (\\nabla g) \\Big|_{(\\mu_Y, \\mu_Z)} $$\n我们通过代入所有未知量的样本估计值来估计该方差：\n$$ \\hat{\\text{Var}}(\\hat{\\rho}) = \\frac{1}{n\\bar{Z}^2} (s_{YY} - 2\\hat{\\rho}s_{YZ} + \\hat{\\rho}^2 s_{ZZ}) $$\n代入给定值：\n$$ \\hat{\\text{Var}}(\\hat{\\rho}) = \\frac{1}{400(0.02)^2} (1.0 - 2(30)(0.02) + (30)^2(0.09)) $$\n$$ \\hat{\\text{Var}}(\\hat{\\rho}) = \\frac{1}{400(0.0004)} (1.0 - 1.2 + 900(0.09)) $$\n$$ \\hat{\\text{Var}}(\\hat{\\rho}) = \\frac{1}{0.16} (1.0 - 1.2 + 81) = \\frac{80.8}{0.16} = 505 $$\n估计值的标准误为 `SE(\\hat{\\rho}) = \\sqrt{505} \\approx 22.472`。\n`95\\%` delta 方法置信区间为 `\\hat{\\rho} \\pm z \\cdot SE(\\hat{\\rho})`：\n$$ CI_{\\text{delta}} = 30 \\pm 1.96 \\times 22.472 $$\n$$ CI_{\\text{delta}} = 30 \\pm 44.045 $$\n$$ CI_{\\text{delta}} \\approx [-14.0, 74.0] $$\n\n**2. Fieller 置信区间**\n\nFieller 方法通过寻找所有使得假设 `H_0: \\rho = \\rho_0` 不被拒绝的 `\\rho_0` 值集合来构建置信区间。这基于统计量 `\\bar{Y} - \\rho\\bar{Z}`，该统计量近似服从正态分布，其均值为 `\\mu_Y - \\rho\\mu_Z = 0`，方差为 `\\frac{1}{n} (\\sigma_Y^2 - 2\\rho\\sigma_{YZ} + \\rho^2\\sigma_Z^2)`。\n`\\rho` 的 `(1-\\alpha)` 置信区间是求解以下不等式的值的集合：\n$$ \\frac{(\\bar{Y} - \\rho\\bar{Z})^2}{\\frac{1}{n} (s_{YY} - 2\\rho s_{YZ} + \\rho^2 s_{ZZ})} \\le z^2 $$\n整理后得到一个二次不等式 `A\\rho^2 + B\\rho + C \\le 0`，其中：\n- `A = n\\bar{Z}^2 - z^2 s_{ZZ}`\n- `B = -2(n\\bar{Y}\\bar{Z} - z^2 s_{YZ})`\n- `C = n\\bar{Y}^2 - z^2 s_{YY}`\n\n我们使用 `z^2 = (1.96)^2 = 3.8416` 计算系数：\n- `A = 400(0.02)^2 - 3.8416(0.09) = 0.16 - 0.345744 = -0.185744`\n- `B = -2(400(0.6)(0.02) - 3.8416(0.02)) = -2(4.8 - 0.076832) = -9.446336`\n- `C = 400(0.6)^2 - 3.8416(1.0) = 144 - 3.8416 = 140.1584`\n\n`A` 的符号至关重要。`A` 小于 0 表示分母的样本均值 `\\bar{Z}` 与零没有显著差异。具体来说，检验 `H_0: \\mu_Z = 0` 的检验统计量是 `t_Z = \\sqrt{n}\\bar{Z}/s_Z`，而 `A` 可以写成 `s_{ZZ}(t_Z^2 - z^2)`。在这里，`t_Z^2 = 400(0.02)^2/0.09 = 0.16/0.09 \\approx 1.778`，小于 `z^2 = 3.8416`，这证实了 `A` 小于 0。这意味着抛物线 `f(\\rho) = A\\rho^2 + B\\rho + C` 开口向下。\n\n接下来，我们通过计算判别式 `D = B^2 - 4AC` 来找到 `A\\rho^2 + B\\rho + C = 0` 的根：\n$$ D = (-9.446336)^2 - 4(-0.185744)(140.1584) $$\n$$ D = 89.233 + 104.149 = 193.382 $$\n由于 `D > 0`，存在两个不同的实根。因为抛物线开口向下（`A` 小于 0），不等式 `A\\rho^2 + B\\rho + C \\le 0` 在根之外的区域成立。\n根是：\n$$ \\rho = \\frac{-B \\pm \\sqrt{D}}{2A} = \\frac{9.446336 \\pm \\sqrt{193.382}}{2(-0.185744)} = \\frac{9.446336 \\pm 13.906186}{-0.371488} $$\n$$ \\rho_1 = \\frac{9.446336 - 13.906186}{-0.371488} = \\frac{-4.45985}{-0.371488} \\approx 12.005 $$\n$$ \\rho_2 = \\frac{9.446336 + 13.906186}{-0.371488} = \\frac{23.352522}{-0.371488} \\approx -62.862 $$\n`95\\%` Fieller 置信区间是集合 `(-\\infty, \\rho_2] \\cup [\\rho_1, \\infty)`，近似为 `(-\\infty, -62.9] \\cup [12.0, \\infty)`。\n\n### 选项评估\n\n**A. $95\\%$ Fieller 置信区间近似为 $(-\\infty,\\,-63.0] \\cup [12.0,\\,\\infty)$，而 delta 方法置信区间近似为 $[-14.0,\\,74.0]$。在这种情况下，delta 方法置信区间可能具有误导性，因为分母与零没有显著差异。**\n我们推导出的 Fieller 置信区间是 `(-\\infty, -62.9] \\cup [12.0, \\infty)`，与提供的区间相符。我们推导出的 delta 方法置信区间是 `[-14.0, 74.0]`，也相符。Fieller 置信区间不连续的原因确实是分母的均值 `\\mu_Z` 在 `5\\%` 水平上与零没有统计学上的显著差异，如 `A` 小于 0 所示。这正是 delta 方法所依赖的线性近似失效的精确场景，导致一个具有误导性的紧凑且有限的置信区间。因此，这个陈述是完全正确的。\n**结论：正确。**\n\n**B. Fieller 置信区间和 delta 方法置信区间都是有限且几乎相同的，大约为 $[28.0,\\,32.0]$；因此 delta 方法在这里是可靠的。**\n这是错误的。我们的计算表明，这两个置信区间在形式和大小上都截然不同。Fieller 置信区间不是有限的，而 delta 方法置信区间是 `[-14.0, 74.0]`，非常宽。区间 `[28.0, 32.0]` 是围绕点估计值 `30` 的一个窄区间，不能反映数据中的巨大不确定性。\n**结论：不正确。**\n\n**C. Fieller 置信区间在 $95\\%$ 置信水平下是整个实数轴，因为相关的二次判别式为负。**\n要使 Fieller 置信区间为整个实数轴，条件是 `A` 小于 0 和 `D \\le 0`。虽然 `A` 确实是负的，但我们计算出判别式 `D \\approx 193.38`，是正的。正判别式意味着二次方程有实根，这些根界定了一个有限区域或其补集。因此，前提（负判别式）和结论（整个实数轴）都是错误的。\n**结论：不正确。**\n\n**D. 如果所有的 $Y_i$ 和 $Z_i$ 都乘以一个共同的正数常数，那么 $\\rho$ 的 Fieller 置信区间和 delta 方法置信区间都保持不变。**\n让我们分析变换 `Y'_i = c Y_i` 和 `Z'_i = c Z_i`（其中 `c  0`）的影响。参数 `\\rho' = \\mathbb{E}[Y'_i] / \\mathbb{E}[Z'_i] = c\\mu_Y / (c\\mu_Z) = \\rho` 是不变的。样本统计量变换如下：`\\bar{Y}' = c\\bar{Y}`，`\\bar{Z}' = c\\bar{Z}`，`s'_{YY} = c^2 s_{YY}`，`s'_{ZZ} = c^2 s_{ZZ}`，以及 `s'_{YZ} = c^2 s_{YZ}`。\n- **Delta 方法：** 点估计 `\\hat{\\rho}' = \\bar{Y}'/\\bar{Z}' = (c\\bar{Y})/(c\\bar{Z}) = \\hat{\\rho}` 是不变的。新的方差是 `\\hat{\\text{Var}}(\\hat{\\rho}') = \\frac{1}{n(\\bar{Z}')^2} (s'_{YY} - 2\\hat{\\rho}'s'_{YZ} + (\\hat{\\rho}')^2 s'_{ZZ}) = \\frac{1}{n(c\\bar{Z})^2} (c^2 s_{YY} - 2\\hat{\\rho}c^2 s_{YZ} + \\hat{\\rho}^2 c^2 s_{ZZ}) = \\frac{c^2}{c^2} \\hat{\\text{Var}}(\\hat{\\rho}) = \\hat{\\text{Var}}(\\hat{\\rho})`。由于 `\\hat{\\rho}` 和其标准误都是不变的，置信区间保持不变。\n- **Fieller 方法：** 二次不等式 `A'\\rho^2 + B'\\rho + C' \\le 0` 的系数变为 `A' = c^2 A`，`B' = c^2 B`，和 `C' = c^2 C`。不等式变为 `c^2(A\\rho^2 + B\\rho + C) \\le 0`。由于 `c^2  0`，这等价于原始不等式 `A\\rho^2 + B\\rho + C \\le 0`。因此 `\\rho` 的解集是相同的。\n两个置信区间都对这种缩放不变。\n**结论：正确。**",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "置信区间的合理性可以由两种不同的理论框架来支持：像中心极限定理（CLT）这样的渐近结果，以及像霍夫丁（Hoeffding）和伯恩斯坦（Bernstein）不等式这样的非渐近集中不等式。基于CLT的区间是渐近精确的，但在小样本量下可能会覆盖不足；而集中不等式则为任何样本量提供有保证的覆盖率，但通常代价是区间更宽。这个动手编程练习要求你实现并凭经验比较这些不同类型的区间，从而让你就它们的相对性能以及在渐近效率和有限样本稳健性之间的权衡建立起实践直觉。",
            "id": "3298410",
            "problem": "给定一个有界独立同分布序列 $\\{X_i\\}_{i=1}^n$，其中 $X_i \\in [a,b]$，且均值 $\\mu = \\mathbb{E}[X_i]$ 有限。均值的蒙特卡洛估计量是样本均值 $\\bar{X}_n = \\frac{1}{n}\\sum_{i=1}^n X_i$。一个 $(1-\\alpha)$ 置信区间是任何以 $\\bar{X}_n$ 为中心，且在数据生成机制下以至少 $1-\\alpha$ 的概率包含真实均值 $\\mu$ 的随机区间。\n\n目标是在有界设定下，比较三种用于 $\\mu$ 的置信区间的经验覆盖属性和平均半宽。这三种置信区间分别基于不同的基本原理构建：一种基于 Hoeffding 不等式，一种基于带有数据驱动方差代理的 Bernstein 不等式，以及一种基于中心极限定理（CLT）使用正态近似。您必须从蒙特卡洛估计量的基础定义、有界随机变量的基本概率不等式以及中心极限定理开始；为每个区间推导出适当的半宽；然后实施一个模拟来估计覆盖概率和平均半宽。\n\n您的程序必须：\n- 为 $\\mu$ 实现三个双边 $(1-\\alpha)$ 置信区间，每个区间都以 $\\bar{X}_n$ 为中心，分别通过以下方式获得：\n  1. 源自 $[a,b]$ 上有界随机变量的 Hoeffding 不等式推导出的界。\n  2. 源自 Bernstein 不等式推导出的界，该不等式包含一个方差项，并通过使用样本方差作为直接代入的代理估计来使其可操作。\n  3. 基于 CLT 的区间，使用正态分位数和样本标准差。\n- 对于每种区间构造方法，凭经验估计其覆盖概率（定义为蒙特卡洛重复实验中区间包含真实均值 $\\mu$ 的次数所占的比例），并计算其在所有重复实验中的平均半宽。\n- 使用固定的随机种子以保证可复现性。\n\n您必须从有界分布中进行模拟，以创建涵盖不同范围、方差、偏度和样本大小的多种情况。使用以下测试套件，其中每个测试用例指定了分布、其参数、界限 $[a,b]$、样本大小 $n$、名义水平 $\\alpha$ 以及蒙特卡洛重复实验的次数 $R$。对于下面的每种情况，真实均值 $\\mu$ 由分布和参数确定，并应用于覆盖率检查。\n\n测试套件（四种情况）：\n1. 情况 U-small：在 $[a,b]$ 上的均匀分布，其中 $a=0, b=1, n=20, \\alpha=0.05, R=5000$。\n2. 情况 T-skew：在 $[a,b]$ 上的三角分布，其中 $a=0, b=1$, 众数 $m=0.9, n=40, \\alpha=0.05, R=5000$。三角分布的密度函数支撑集在 $[a,b]$ 上，众数位于 $m \\in [a,b]$；其均值为 $(a+b+m)/3$。\n3. 情况 B-wide：在 $[0,1]$ 上的贝塔分布，形状参数为 $(\\alpha_{\\text{B}},\\beta_{\\text{B}})=(0.5,3)$，线性缩放到 $[a,b]$，其中 $a=-1, b=2, n=100, \\alpha=0.05, R=5000$。在 $[0,1]$ 上的均值为 $\\alpha_{\\text{B}}/(\\alpha_{\\text{B}}+\\beta_{\\text{B}})$；缩放到 $[a,b]$ 后变为 $a + (b-a)\\, \\alpha_{\\text{B}}/(\\alpha_{\\text{B}}+\\beta_{\\text{B}})$。\n4. 情况 B-large-n：在 $[0,1]$ 上的贝塔分布，参数为 $(\\alpha_{\\text{B}},\\beta_{\\text{B}})=(2,2)$，缩放到 $[a,b]$，其中 $a=-0.5, b=0.5, n=1000, \\alpha=0.05, R=2000$。\n\n实现要求：\n- 对于每次重复实验，根据指定的情况抽取 $n$ 个独立样本 $X_1,\\dots,X_n$，计算 $\\bar{X}_n$，计算自由度为 $n-1$ 的样本方差 $s^2$，并如上所述构造三个区间。\n- 所有模拟都使用固定的随机种子。\n- 对于基于 Bernstein 不等式的区间，在不等式中使用样本方差的直接代入方法来确定半宽。对于基于 CLT 的区间，使用 $(1-\\alpha/2)$ 标准正态分位数和样本标准差。\n- 对于每种情况，返回：\n  - Hoeffding、Bernstein 和 CLT 区间的经验覆盖概率，以三个浮点数表示。\n  - Hoeffding、Bernstein 和 CLT 区间的平均半宽，以三个浮点数表示。\n  - 一个整数代码，表示根据以下规则选择的“更优”方法：在经验覆盖率至少为 $1-\\alpha$ 的区间中，选择平均半宽最小的方法；如果没有方法的覆盖率达到 $1-\\alpha$，则选择经验覆盖率最高的方法，若有并列则选择平均半宽最小的。将 Hoeffding 编码为 $0$，Bernstein 编码为 $1$，CLT 编码为 $2$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，其本身形式为：\n  - $[\\,[\\text{cov}_{\\text{H}},\\text{cov}_{\\text{B}},\\text{cov}_{\\text{C}}],\\,[\\text{hw}_{\\text{H}},\\text{hw}_{\\text{B}},\\text{hw}_{\\text{C}}],\\,\\text{pref}\\,]$\n  - 其中，$\\text{cov}_{\\text{H}}$、$\\text{cov}_{\\text{B}}$、$\\text{cov}_{\\text{C}}$ 分别是 Hoeffding、Bernstein 和 CLT 区间的经验覆盖率（浮点数）；$\\text{hw}_{\\text{H}}$、$\\text{hw}_{\\text{B}}$、$\\text{hw}_{\\text{C}}$ 是平均半宽（浮点数）；$\\text{pref}$ 是偏好代码整数，取值于 $\\{0,1,2\\}$。\n您的程序必须严格按照此格式打印一行，并且不能读取任何输入。",
            "solution": "该问题要求比较三种构建有界随机变量均值 $\\mu$ 的 $(1-\\alpha)$ 置信区间的不同方法，该均值使用蒙特卡洛样本均值 $\\bar{X}_n$ 进行估计。这些方法分别基于 Hoeffding 不等式、Bernstein 不等式和中心极限定理（CLT）。置信区间的形式为 $[\\bar{X}_n - \\epsilon, \\bar{X}_n + \\epsilon]$，其中 $\\epsilon$ 是半宽。任务的核心是为每种方法推导 $\\epsilon$ 的表达式，然后通过模拟凭经验评估其性能（覆盖概率和平均半宽）。\n\n设 $\\{X_i\\}_{i=1}^n$ 为一个独立同分布（i.i.d.）随机变量序列，对于已知的界限 $a$ 和 $b$，有 $X_i \\in [a, b]$。均值 $\\mu = \\mathbb{E}[X_i]$ 的估计量是样本均值 $\\bar{X}_n = \\frac{1}{n}\\sum_{i=1}^n X_i$。一个双边 $(1-\\alpha)$ 置信区间必须满足 $\\mathbb{P}(\\mu \\in [\\bar{X}_n - \\epsilon, \\bar{X}_n + \\epsilon]) \\ge 1-\\alpha$，这等价于控制尾部概率 $\\mathbb{P}(|\\bar{X}_n - \\mu| \\ge \\epsilon) \\le \\alpha$。\n\n### 1. 置信区间推导\n\n#### 1.1. Hoeffding 区间\nHoeffding 不等式为有界随机变量的样本均值与其期望值的偏差提供了一个无分布界。对于独立同分布的 $X_i \\in [a, b]$，该不等式为：\n$$ \\mathbb{P}(|\\bar{X}_n - \\mu| \\ge \\epsilon) \\le 2 \\exp\\left(-\\frac{2n\\epsilon^2}{(b-a)^2}\\right) $$\n为了构建一个 $(1-\\alpha)$ 置信区间，我们将右侧设为 $\\alpha$ 并求解半宽，记为 $\\epsilon_H$：\n$$ 2 \\exp\\left(-\\frac{2n\\epsilon_H^2}{(b-a)^2}\\right) = \\alpha $$\n$$ \\exp\\left(-\\frac{2n\\epsilon_H^2}{(b-a)^2}\\right) = \\frac{\\alpha}{2} $$\n两边取自然对数：\n$$ -\\frac{2n\\epsilon_H^2}{(b-a)^2} = \\ln\\left(\\frac{\\alpha}{2}\\right) = -\\ln\\left(\\frac{2}{\\alpha}\\right) $$\n解出 $\\epsilon_H$：\n$$ \\epsilon_H^2 = \\frac{(b-a)^2}{2n}\\ln\\left(\\frac{2}{\\alpha}\\right) $$\n$$ \\epsilon_H = (b-a) \\sqrt{\\frac{\\ln(2/\\alpha)}{2n}} $$\n这个半宽是确定性的，仅取决于问题参数 $n$、$\\alpha$ 和范围 $(b-a)$，而不取决于观测到的数据。它保证了至少 $(1-\\alpha)$ 的覆盖率，但通常是保守的（即比必要的更宽）。\n\n#### 1.2. Bernstein 区间\nBernstein 不等式是一个更精细的集中不等式，它包含了随机变量的方差，当方差较小时能得到更紧的界。样本均值的 Bernstein 不等式的一种常见形式是：\n$$ \\mathbb{P}(|\\bar{X}_n - \\mu| \\ge \\epsilon) \\le 2 \\exp\\left(-\\frac{n\\epsilon^2}{2(\\sigma^2 + C\\epsilon/3)}\\right) $$\n其中 $\\sigma^2 = \\text{Var}(X_i)$ 且 $C$ 是 $|X_i - \\mu|$ 的一个上界。一个安全但可能宽松的选择是数据范围 $C = b-a$。\n\n由于真实方差 $\\sigma^2$ 未知，问题指定使用样本方差 $s^2 = \\frac{1}{n-1}\\sum_{i=1}^n(X_i - \\bar{X}_n)^2$ 作为“直接代入的代理估计”。这使得最终的半宽 $\\epsilon_B$ 依赖于数据。我们将界设为 $\\alpha$ 并求解 $\\epsilon_B$：\n$$ 2 \\exp\\left(-\\frac{n\\epsilon_B^2}{2(s^2 + (b-a)\\epsilon_B/3)}\\right) = \\alpha $$\n令 $K = \\ln(2/\\alpha)$，上式简化为：\n$$ \\frac{n\\epsilon_B^2}{2(s^2 + (b-a)\\epsilon_B/3)} = K $$\n$$ n\\epsilon_B^2 = 2K(s^2 + (b-a)\\epsilon_B/3) $$\n整理后得到一个关于 $\\epsilon_B$ 的二次方程：\n$$ n\\epsilon_B^2 - \\left(\\frac{2K(b-a)}{3}\\right)\\epsilon_B - 2Ks^2 = 0 $$\n使用二次公式求得此方程的正根，即为半宽：\n$$ \\epsilon_B = \\frac{\\frac{2K(b-a)}{3} + \\sqrt{\\left(\\frac{2K(b-a)}{3}\\right)^2 + 8nKs^2}}{2n} $$\n这个“经验 Bernstein”区间预计会比 Hoeffding 区间更紧，因为它能适应观测到的样本方差。\n\n#### 1.3. 中心极限定理 (CLT) 区间\n中心极限定理指出，对于大的 $n$，标准化样本均值的分布收敛于标准正态分布：\n$$ \\frac{\\bar{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\xrightarrow{d} \\mathcal{N}(0, 1) $$\n这为以下近似提供了依据：\n$$ \\mathbb{P}\\left(-z_{1-\\alpha/2} \\le \\frac{\\bar{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\le z_{1-\\alpha/2}\\right) \\approx 1-\\alpha $$\n其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$-分位数。根据 Slutsky 定理，我们可以用样本标准差 $s = \\sqrt{s^2}$ 替换未知的总体标准差 $\\sigma$，而不会改变其渐近分布。整理不等式得到熟悉的基于 CLT 的置信区间，其半宽为 $\\epsilon_C$：\n$$ \\epsilon_C = z_{1-\\alpha/2} \\frac{s}{\\sqrt{n}} $$\n这个区间是渐近精确的，意味着当 $n \\to \\infty$ 时，其覆盖概率收敛到恰好 $(1-\\alpha)$。然而，对于有限的 $n$，特别是在分布有偏或重尾的情况下，其实际覆盖率可能会偏离名义水平。\n\n### 2. 模拟与评估\n\n该程序实现了一个蒙特卡洛模拟，以评估这一系列测试用例中的这三种区间。对于每个用例，模拟过程如下：\n1.  总共执行 $R$ 次重复实验。\n2.  在每次重复实验中，从指定的分布中抽取一个大小为 $n$ 的随机样本。\n3.  计算样本均值 $\\bar{X}_n$ 和样本方差 $s^2$（自由度为 $n-1$）。\n4.  计算三个半宽——$\\epsilon_H$（常数）、$\\epsilon_B$（依赖于 $s^2$）和 $\\epsilon_C$（依赖于 $s$）。\n5.  对于这三种方法中的每一种，检查其区间是否包含真实均值 $\\mu$（即，是否 $|\\bar{X}_n - \\mu| \\le \\epsilon$）。\n6.  在所有重复实验结束后，每种方法的经验覆盖概率是区间包含 $\\mu$ 的次数所占的比例。平均半宽是所有重复实验中计算出的半宽的均值。\n\n最后，根据一个双层规则选择一个“更优”方法：在达到至少名义覆盖率 $(1-\\alpha)$ 的方法中，选择平均半宽最小的一个。如果没有方法达到此覆盖率，则选择经验覆盖率最高的一个，若有并列则以最小的平均半宽为准。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation study and print results.\n    \"\"\"\n    # Use a fixed random seed for all simulations for reproducibility.\n    # The RNG is created once and passed to the simulation function.\n    rng = np.random.default_rng(12345)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Uniform distribution, small sample size\n        {'dist': 'uniform', 'params': {}, 'a': 0.0, 'b': 1.0, 'n': 20, 'alpha': 0.05, 'R': 5000},\n        # Case 2: Skewed triangular distribution\n        {'dist': 'triangular', 'params': {'mode': 0.9}, 'a': 0.0, 'b': 1.0, 'n': 40, 'alpha': 0.05, 'R': 5000},\n        # Case 3: Scaled and skewed Beta distribution\n        {'dist': 'beta', 'params': {'alpha_B': 0.5, 'beta_B': 3.0}, 'a': -1.0, 'b': 2.0, 'n': 100, 'alpha': 0.05, 'R': 5000},\n        # Case 4: Scaled symmetric Beta distribution, large sample size\n        {'dist': 'beta', 'params': {'alpha_B': 2.0, 'beta_B': 2.0}, 'a': -0.5, 'b': 0.5, 'n': 1000, 'alpha': 0.05, 'R': 2000},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation_for_case(case, rng)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation_for_case(case, rng):\n    \"\"\"\n    Runs the simulation for a single test case.\n    \"\"\"\n    dist, params, a, b, n, alpha, R = case['dist'], case['params'], case['a'], case['b'], case['n'], case['alpha'], case['R']\n    \n    # Calculate the true mean (mu) for the distribution\n    if dist == 'uniform':\n        mu = (a + b) / 2.0\n    elif dist == 'triangular':\n        mu = (a + b + params['mode']) / 3.0\n    elif dist == 'beta':\n        mu_01 = params['alpha_B'] / (params['alpha_B'] + params['beta_B'])\n        mu = a + (b - a) * mu_01\n\n    # Pre-calculate constants for interval calculations\n    z_quantile = norm.ppf(1.0 - alpha / 2.0)\n    hoeffding_hw = (b - a) * np.sqrt(np.log(2.0 / alpha) / (2.0 * n))\n    bernstein_K = np.log(2.0 / alpha)\n    bernstein_C_param = b - a\n\n    # Initialize accumulators for metrics\n    coverage_counts = np.zeros(3)  # [Hoeffding, Bernstein, CLT]\n    hw_sums = np.zeros(3)          # [Hoeffding, Bernstein, CLT]\n\n    for _ in range(R):\n        # 1. Generate a sample of size n from the specified distribution\n        if dist == 'uniform':\n            samples = rng.uniform(low=a, high=b, size=n)\n        elif dist == 'triangular':\n            samples = rng.triangular(left=a, mode=params['mode'], right=b, size=n)\n        elif dist == 'beta':\n            samples_01 = rng.beta(a=params['alpha_B'], b=params['beta_B'], size=n)\n            samples = a + (b - a) * samples_01\n\n        # 2. Compute sample statistics\n        x_bar = np.mean(samples)\n        s_squared = np.var(samples, ddof=1)\n        # Ensure variance is non-negative for robustness\n        s_squared = max(0.0, s_squared)\n        s = np.sqrt(s_squared)\n\n        # 3. Calculate interval half-widths for this sample\n        # Hoeffding half-width is constant\n        \n        # Bernstein half-width\n        quad_A = float(n)\n        quad_B = -2.0 * bernstein_C_param * bernstein_K / 3.0\n        quad_C = -2.0 * s_squared * bernstein_K\n        discriminant = quad_B**2 - 4.0 * quad_A * quad_C\n        bernstein_hw = (-quad_B + np.sqrt(max(0, discriminant))) / (2.0 * quad_A)\n\n        # CLT half-width\n        clt_hw = z_quantile * s / np.sqrt(n)\n        \n        half_widths = [hoeffding_hw, bernstein_hw, clt_hw]\n        hw_sums += half_widths\n\n        # 4. Check coverage for each method\n        deviation = np.abs(x_bar - mu)\n        if deviation = half_widths[0]:\n            coverage_counts[0] += 1\n        if deviation = half_widths[1]:\n            coverage_counts[1] += 1\n        if deviation = half_widths[2]:\n            coverage_counts[2] += 1\n\n    # 5. Calculate final empirical metrics\n    empirical_coverages = (coverage_counts / R).tolist()\n    average_half_widths = (hw_sums / R).tolist()\n\n    # 6. Apply the preference rule\n    methods = [\n        (empirical_coverages[0], average_half_widths[0], 0), # Hoeffding\n        (empirical_coverages[1], average_half_widths[1], 1), # Bernstein\n        (empirical_coverages[2], average_half_widths[2], 2)  # CLT\n    ]\n\n    target_coverage = 1.0 - alpha\n    valid_methods = [m for m in methods if m[0] >= target_coverage]\n    \n    if valid_methods:\n        # Among methods with sufficient coverage, choose the one with the smallest half-width\n        best_method = min(valid_methods, key=lambda x: x[1])\n    else:\n        # If no method has sufficient coverage, choose the one with the highest coverage.\n        # Break ties using the smallest half-width.\n        # max on (coverage, -half_width) is equivalent to sorting by coverage DESC, then half_width ASC.\n        best_method = max(methods, key=lambda x: (x[0], -x[1]))\n\n    pref_code = best_method[2]\n\n    # Format result for this case\n    return [empirical_coverages, average_half_widths, pref_code]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}