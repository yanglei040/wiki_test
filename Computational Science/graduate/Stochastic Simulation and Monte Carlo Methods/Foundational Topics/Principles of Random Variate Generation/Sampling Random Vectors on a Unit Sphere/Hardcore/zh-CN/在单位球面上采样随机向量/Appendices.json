{
    "hands_on_practices": [
        {
            "introduction": "在深入探讨更高级的主题之前，我们首先从基本原理出发，构建并验证两种最核心的单位球面上均匀采样的精确算法。本练习将指导您推导并实现针对三维球面（$S^2$）的角度逆变换采样法，并将其推广到适用于任意维度、应用广泛的高斯归一化方法。通过这个实践，您不仅能掌握具体的采样技术，还将学习如何分析样本的统计特性，例如坐标的边缘分布，从而将几何理论与实际算法和统计验证紧密联系起来。",
            "id": "3337198",
            "problem": "您的任务是设计、分析并凭经验验证算法，用于在 $\\mathbb{R}^d$ 的单位球面上均匀采样随机向量，该球面记为 $S^{d-1} = \\{x \\in \\mathbb{R}^d : \\|x\\|_2 = 1\\}$。您的工作必须从基本定义开始：$S^{d-1}$ 上的曲面面积测度、旋转不变性以及球坐标变换的雅可比行列式。不得假定任何快捷公式。所有角度必须以弧度表示。\n\n您的程序必须实现以下内容，并为每个步骤提供严谨的推导支持：\n\n- A 部分（$S^2$ 上的推导）：从 $S^2$ 上均匀分布的旋转不变性和球坐标的定义出发，推导天顶角 $\\theta \\in [0,\\pi]$ 和方位角 $\\phi \\in [0,2\\pi)$ 的分布。利用此结果推导一个逆变换采样算法，通过首先从简单的基分布中采样 $\\phi$ 和 $\\theta$ 的某个合适函数，然后计算笛卡尔坐标，从而在 $S^2$ 上均匀采样点。\n\n- B 部分（推广到 $S^{d-1}$）：令 $X = (X_1,\\ldots,X_d)$ 在 $S^{d-1}$ 上均匀分布。使用第一性原理和关于 $S^{d-1}$ 切片上曲面测度的余面积（或雅可比）论证，推导 $X_1$ 在 $[-1,1]$ 上的概率密度函数。证明变换后的变量 $U = (X_1+1)/2$ 服从一个具有依赖于 $d$ 的对称参数的贝塔分布；明确指出这些参数是 $d$ 的函数。如果需要，使用此结果为 $X_1$ 构建一个标量逆变换步骤。\n\n- C 部分（角分量的独立性）：通过标准的 $d$ 维球坐标映射，为 $S^{d-1}$ 引入超球坐标 $(\\theta_1,\\ldots,\\theta_{d-2},\\phi)$。推导雅可比行列式，并用它来获得 $(\\theta_1,\\ldots,\\theta_{d-2},\\phi)$ 的联合密度。确定在 $S^{d-1}$ 的均匀分布下，这些角坐标是否相互独立，并完全根据联合密度的分解结构来证明您的答案。\n\n- 需要实现的算法：\n  1. 一个使用 A 部分推导的角逆变换的 $S^2$ 采样器，以笛卡尔坐标输出点。\n  2. 一个适用于任何整数 $d \\ge 2$ 的通用 $S^{d-1}$ 采样器，使用高斯归一化方法：采样 $Y \\sim \\mathcal{N}(0,I_d)$ 并返回 $Y/\\|Y\\|_2$。\n  3. 一个例程，根据一致的约定，从 $\\mathbb{R}^5$ 中的笛卡尔样本中提取超球角 $(\\theta_1,\\theta_2)$，其中 $\\theta_i \\in [0,\\pi]$。\n\n- 需要执行的统计检验：\n  1. 在 $S^2$ 上，使用应用于二维直方图的卡方独立性检验，检验方位角 $\\phi \\in [0,2\\pi)$ 和变量 $\\cos\\theta \\in [-1,1]$ 的独立性。在每个域中使用均匀间距的分箱，并采用 $\\alpha = 0.01$ 的显著性水平。\n  2. 在 $S^{4}$（即 $d=5$）上，使用柯尔莫哥洛夫-斯米尔诺夫检验，在 $\\alpha = 0.01$ 的显著性水平下，检验 $U=(X_1+1)/2$ 的边缘分布是否符合 B 部分推导的贝塔分布。\n  3. 在 $S^{4}$ 上，通过在 $[0,\\pi]\\times[0,\\pi]$ 上具有均匀间距分箱的二维直方图上进行卡方独立性检验，检验 $(\\theta_1,\\theta_2)$ 的独立性，使用 $\\alpha = 0.01$ 的显著性水平。\n  4. 在 $S^{1}$（即 $d=2$）上，通过使用双边单样本 t 检验在 $\\alpha = 0.01$ 的显著性水平下检验原假设 $\\mathbb{E}[X_1]=0$，来验证第一个坐标 $X_1$ 的对称性。\n\n您的程序内部必须使用固定的随机种子以保证可复现性，并且必须只产生一行如下规定的输出。所有角度必须以弧度处理。所有统计决策必须是布尔值，如果对应的 p 值超过指定的 $\\alpha$，则结果为 true。\n\n测试套件和要求输出：\n- 按确切顺序使用以下测试用例，并使用指定的参数：\n  - 测试 1：$S^2$ 角采样器，样本量 $N=200000$，在 $[0,2\\pi)$ 上的直方图分箱数为 $b_\\phi=12$，在 $[-1,1]$ 上的分箱数为 $b_c=12$，在 $\\alpha=0.01$ 下对 $\\phi$ 和 $\\cos\\theta$ 进行卡方独立性检验。输出一个布尔值，表示独立性是否未被拒绝。\n  - 测试 2：通过高斯归一化生成 $S^{4}$ 样本（$d=5$），样本量 $N=250000$。计算 $U=(X_1+1)/2$，并在 $\\alpha=0.01$ 下与 B 部分的贝塔定律进行柯尔莫哥洛夫-斯米尔诺夫检验。输出一个布尔值，表示原假设是否未被拒绝。\n  - 测试 3：通过高斯归一化生成 $S^{4}$ 样本（$d=5$），样本量 $N=250000$，对于 $\\theta_1$ 和 $\\theta_2$，在 $[0,\\pi]$ 上的直方图分箱数均为 $b_{\\theta}=10$。在 $\\alpha=0.01$ 下进行卡方独立性检验；输出一个布尔值，表示独立性是否未被拒绝。\n  - 测试 4：通过高斯归一化生成 $S^{1}$ 样本（$d=2$），样本量 $N=400000$。在 $\\alpha=0.01$ 下对 $\\mathbb{E}[X_1]=0$ 进行双边单样本 t 检验；输出一个布尔值，表示原假设是否未被拒绝。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 `\"[true1,true2,true3,true4]\"`，其中每个 `truei` 按顺序替换为测试 $i$ 的布尔结果。布尔值必须是无修饰的 Python 布尔字面量，不含空格，例如 `\"[True,False,True,True]\"`。",
            "solution": "在 $d$ 维单位球面 $S^{d-1}$ 表面生成均匀分布的随机向量是随机模拟中的一个基本任务，其应用范围从统计物理到计算机图形学。这个任务要求对球体的几何形状以及均匀曲面测度的性质有精确的理解。以下各节根据规定，从第一性原理出发，为所需的算法和统计特性提供了严谨的推导。\n\n### A 部分：$S^2$ 逆变换采样器的推导\n\n单位球面 $S^2 \\subset \\mathbb{R}^3$ 上的一个点可以用球坐标 $(\\theta, \\phi)$ 来参数化，其中 $\\theta \\in [0, \\pi]$ 是极角（天顶角），$\\phi \\in [0, 2\\pi)$ 是方位角。到笛卡尔坐标 $(x_1, x_2, x_3)$ 的标准映射是：\n$$\n\\begin{cases}\nx_1 = \\sin\\theta \\cos\\phi \\\\\nx_2 = \\sin\\theta \\sin\\phi \\\\\nx_3 = \\cos\\theta\n\\end{cases}\n$$\n$S^2$ 上的均匀分布是相对于曲面面积元 $d\\sigma$ 定义的。对于给定的参数化，从球坐标到笛卡尔坐标的变换的雅可比行列式导出的曲面元为 $d\\sigma = \\sin\\theta \\, d\\theta \\, d\\phi$。$S^2$ 的总表面积是 $\\mathcal{A}(S^2) = \\int_0^{2\\pi} \\int_0^{\\pi} \\sin\\theta \\, d\\theta \\, d\\phi = 4\\pi$。\n\n因此，角度 $(\\theta, \\phi)$ 上均匀分布的概率密度函数 (PDF) 是：\n$$\nf(\\theta, \\phi) = \\frac{1}{4\\pi} \\sin\\theta, \\quad \\text{对于 } \\theta \\in [0, \\pi], \\phi \\in [0, 2\\pi)\n$$\n为了推导对 $(\\theta, \\phi)$ 进行采样的算法，我们考察它们的联合分布和边缘分布。联合 PDF 可以分解为：\n$$\nf(\\theta, \\phi) = \\left( \\frac{1}{2\\pi} \\right) \\left( \\frac{1}{2}\\sin\\theta \\right) = f_\\Phi(\\phi) f_\\Theta(\\theta)\n$$\n这种分解表明 $\\Theta$ 和 $\\Phi$ 是独立的随机变量。\n$\\phi$ 的边缘 PDF 是 $f_\\Phi(\\phi) = \\int_0^\\pi \\frac{1}{4\\pi} \\sin\\theta \\, d\\theta = \\frac{1}{2\\pi}$，这是 $[0, 2\\pi)$ 上的均匀分布。因此，可以通过生成 $U_1 \\sim \\mathcal{U}[0,1]$ 并设置 $\\phi = 2\\pi U_1$ 来对 $\\phi$ 进行采样。\n\n$\\theta$ 的边缘 PDF 是 $f_\\Theta(\\theta) = \\int_0^{2\\pi} \\frac{1}{4\\pi} \\sin\\theta \\, d\\phi = \\frac{1}{2}\\sin\\theta$，对于 $\\theta \\in [0,\\pi]$。我们使用逆变换采样法。$\\Theta$ 的累积分布函数 (CDF) 是：\n$$\nF_\\Theta(\\theta') = P(\\Theta \\le \\theta') = \\int_0^{\\theta'} \\frac{1}{2}\\sin\\theta \\, d\\theta = \\frac{1}{2}[-\\cos\\theta]_0^{\\theta'} = \\frac{1}{2}(1 - \\cos\\theta')\n$$\n令 $F_\\Theta(\\theta) = U_2$ 其中 $U_2 \\sim \\mathcal{U}[0,1]$，我们求解 $\\theta$：\n$$\nU_2 = \\frac{1}{2}(1 - \\cos\\theta) \\implies \\cos\\theta = 1 - 2U_2\n$$\n变量 $C = 1 - 2U_2$ 在 $[-1, 1]$ 上均匀分布。在计算和概念上，直接采样变量 $C = \\cos\\theta$ 比采样 $\\theta$ 本身更直接。让我们采样 $U'_2 \\sim\\mathcal{U}[0,1]$ 并设置 $C = 2U'_2-1$，它在 $[-1,1]$ 上是均匀的。然后我们可以设置 $c = \\cos\\theta$。通过将联合密度 $f(\\theta,\\phi)$ 变换到变量 $(\\phi,c)$ 可以证明 $\\phi$ 和 $\\cos\\theta$ 的独立性：\n$$\ng(\\phi, c) = f(\\theta(c), \\phi) \\left| \\frac{d\\theta}{dc} \\right| = \\frac{\\sin(\\arccos(c))}{4\\pi} \\left| \\frac{-1}{\\sqrt{1-c^2}} \\right| = \\frac{\\sqrt{1-c^2}}{4\\pi} \\frac{1}{\\sqrt{1-c^2}} = \\frac{1}{4\\pi}\n$$\n定义域是 $\\phi \\in [0,2\\pi)$ 和 $c \\in [-1,1]$，面积为 $4\\pi$。常数密度证实了 $(\\Phi, C)$ 是联合均匀的，因此是独立的。算法如下：\n1. 采样 $\\phi \\sim \\mathcal{U}[0, 2\\pi)$。\n2. 采样 $c \\sim \\mathcal{U}[-1, 1]$。\n3. 计算笛卡尔坐标：$x_1 = \\sqrt{1-c^2}\\cos\\phi$，$x_2 = \\sqrt{1-c^2}\\sin\\phi$，$x_3 = c$。\n\n### B 部分：$S^{d-1}$ 上一个坐标的边缘分布\n\n令 $X=(X_1, \\ldots, X_d)$ 是在 $S^{d-1}$ 上均匀分布的随机向量。根据旋转对称性，每个坐标 $X_i$ 的边缘分布是相同的。我们推导 $X_1$ 在 $x_1 \\in [-1, 1]$ 上的 PDF。\n\n一个事件的概率与其在球面上所占的表面积成正比。概率密度 $f_{X_1}(x_1)$ 与通过在第一个坐标的固定值 $x_1$ 处对 $S^{d-1}$ 进行切片而形成的 $(d-2)$ 维球体的表面积成正比。该切片的方程为 $x_1^2 + x_2^2 + \\dots + x_d^2 = 1$，这意味着 $\\sum_{i=2}^d x_i^2 = 1 - x_1^2$。这是一个半径为 $r = \\sqrt{1-x_1^2}$ 的 $(d-2)$ 维球面。\n\n半径为 $R$ 的 $k$ 维球面的表面积为 $\\mathcal{A}_k(R) = \\mathcal{A}_k R^k$，其中 $\\mathcal{A}_k = \\frac{2\\pi^{(k+1)/2}}{\\Gamma((k+1)/2)}$ 是 $S^k$ 的面积。该切片的面积是 $\\mathcal{A}_{d-2}(r) = \\mathcal{A}_{d-2}(1-x_1^2)^{(d-2)/2}$。在 $S^{d-1}$ 上，位于 $x_1$ 和 $x_1+dx_1$ 之间的一个薄带的无穷小表面积是该切片面积乘以该带的无穷小弧长宽度 $dl$。弧长与 $dx_1$ 的关系为 $dl = dx_1/\\sqrt{1-x_1^2}$。这一推理思路可以通过余面积公式加以形式化。一个更直接的方法是注意到 $S^{d-1}$ 上的曲面测度可以通过先对固定的 $x_1$ 在 $(d-2)$ 维球面上积分，然后再对 $x_1$ 积分来计算。面积元投影为 $d\\sigma_{d-1} \\propto (1-x_1^2)^{(d-3)/2}dx_1 d\\sigma_{d-2}$。这导致 $X_1$ 的 PDF 与 $(1-x_1^2)^{(d-3)/2}$ 成正比。\n$$\nf_{X_1}(x_1) = K_d (1-x_1^2)^{(d-3)/2}, \\quad x_1 \\in [-1, 1]\n$$\n归一化常数 $K_d$ 通过 $\\int_{-1}^1 f_{X_1}(x_1)dx_1 = 1$ 求得。该积分与贝塔函数有关：$\\int_{-1}^1 (1-x^2)^a dx = B(a+1, 1/2)$。这里 $a = (d-3)/2$。所以积分为 $B(\\frac{d-1}{2}, \\frac{1}{2}) = \\frac{\\Gamma(\\frac{d-1}{2})\\Gamma(\\frac{1}{2})}{\\Gamma(d/2)}$。\n因此，$K_d = \\frac{\\Gamma(d/2)}{\\Gamma(\\frac{1}{2})\\Gamma(\\frac{d-1}{2})}$。\n\n现在，考虑变换 $U = (X_1+1)/2$，它将 $x_1 \\in [-1, 1]$ 映射到 $u \\in [0,1]$。我们有 $x_1=2u-1$ 和 $dx_1=2du$。$U$ 的 PDF 是：\n$$\nf_U(u) = f_{X_1}(2u-1) \\left| \\frac{dx_1}{du} \\right| = 2 K_d (1 - (2u-1)^2)^{(d-3)/2}\n$$\n因为 $1-(2u-1)^2 = 4u(1-u)$，我们有：\n$$\nf_U(u) = 2 K_d (4u(1-u))^{(d-3)/2} = 2 K_d 4^{(d-3)/2} u^{(d-3)/2} (1-u)^{(d-3)/2}\n$$\n$2 \\cdot 4^{(d-3)/2} = 2 \\cdot 2^{d-3} = 2^{d-2}$。为了写成贝塔分布的形式，我们重写指数：\n$$\nf_U(u) = (K_d 2^{d-2}) u^{\\frac{d-1}{2}-1} (1-u)^{\\frac{d-1}{2}-1}\n$$\n这是参数为 $\\alpha = \\beta = (d-1)/2$ 的贝塔分布的形式。$\\operatorname{Beta}(\\alpha, \\beta)$ 的归一化常数是 $1/B(\\alpha, \\beta)$。让我们验证一下 $K_d 2^{d-2} = 1/B(\\frac{d-1}{2}, \\frac{d-1}{2})$。\n使用伽马函数的勒让德倍积公式 $\\Gamma(z)\\Gamma(z+1/2) = 2^{1-2z}\\sqrt{\\pi}\\Gamma(2z)$，我们可以证明：\n$$\nK_d = \\frac{2^{2-d}\\Gamma(d-1)}{\\Gamma((d-1)/2)^2}\n$$\n所以，$K_d 2^{d-2} = \\frac{\\Gamma(d-1)}{(\\Gamma((d-1)/2))^2} = \\frac{1}{B(\\frac{d-1}{2}, \\frac{d-1}{2})}$。这证实了 $U \\sim \\operatorname{Beta}(\\frac{d-1}{2}, \\frac{d-1}{2})$。\n对于 $X_1$ 的逆变换采样，可以从这个贝塔分布中采样 $U$ 并设置 $X_1 = 2U-1$。\n\n### C 部分：超球角分量的独立性\n\n我们对点 $x \\in \\mathbb{R}^d$ 使用标准的超球坐标系：\n$$\n\\begin{aligned}\nx_1 = r \\cos\\theta_1 \\\\\nx_2 = r \\sin\\theta_1 \\cos\\theta_2 \\\\\nx_3 = r \\sin\\theta_1 \\sin\\theta_2 \\cos\\theta_3 \\\\\n\\vdots \\\\\nx_{d-1} = r \\sin\\theta_1 \\cdots \\sin\\theta_{d-2} \\cos\\phi \\\\\nx_d = r \\sin\\theta_1 \\cdots \\sin\\theta_{d-2} \\sin\\phi\n\\end{aligned}\n$$\n其中对于 $i=1,\\dots,d-2$ 有 $\\theta_i \\in [0,\\pi]$，且 $\\phi \\in [0,2\\pi)$。在单位球面 $S^{d-1}$ 上，我们有 $r=1$。该变换的雅可比行列式是一个标准结果：\n$$\n|J| = r^{d-1} \\sin^{d-2}\\theta_1 \\sin^{d-3}\\theta_2 \\cdots \\sin^1\\theta_{d-2}\n$$\n通过设置 $r=1$ 并去掉 $dr$，可以找到 $S^{d-1}$ 上的曲面面积元：\n$$\nd\\sigma = (\\sin^{d-2}\\theta_1) (\\sin^{d-3}\\theta_2) \\cdots (\\sin\\theta_{d-2}) \\cdot d\\theta_1 d\\theta_2 \\cdots d\\theta_{d-2} d\\phi\n$$\n对于 $S^{d-1}$ 上的均匀分布，角度 $(\\theta_1, \\ldots, \\theta_{d-2}, \\phi)$ 的联合概率密度与此表达式成正比。通过总表面积 $\\mathcal{A}(S^{d-1})$ 进行归一化得到 PDF：\n$$\nf(\\theta_1, \\ldots, \\phi) = \\frac{1}{\\mathcal{A}(S^{d-1})} \\left( \\prod_{i=1}^{d-2} \\sin^{d-1-i}\\theta_i \\right)\n$$\n这个联合密度函数是多个函数的乘积，其中每个函数只依赖于一个角变量：\n$$\nf(\\theta_1, \\ldots, \\phi) = C \\cdot g_1(\\theta_1) \\cdot g_2(\\theta_2) \\cdots g_{d-2}(\\theta_{d-2}) \\cdot g_\\phi(\\phi)\n$$\n其中 $g_i(\\theta_i) = \\sin^{d-1-i}\\theta_i$ 且 $g_\\phi(\\phi)=1$。一个可以分解为其单个变量的函数乘积的联合 PDF 意味着这些随机变量是相互独立的。因此，在 $S^{d-1}$ 上的均匀分布下，超球角坐标是相互独立的。\n\n### 实现与统计验证\n\n现在使用推导出的原理来实现指定的采样算法和统计检验。\n- **算法 1（$S^2$ 采样器）：** 实现 A 部分推导的逆变换方法。\n- **算法 2（$S^{d-1}$ 采样器）：** 实现高斯归一化方法，该方法采样 $Y \\sim \\mathcal{N}(0, I_d)$ 并设置 $X=Y/\\|Y\\|_2$。由于多元正态分布的旋转对称性，已知此方法可在 $S^{d-1}$ 上产生均匀分布。\n- **角度提取：** 对于样本 $x \\in S^4 \\subset \\mathbb{R}^5$，通过 $\\theta_1 = \\arccos(x_1)$ 和 $\\theta_2 = \\arccos(x_2/\\sqrt{1-x_1^2})$ 提取角度，这与 C 部分的约定一致。\n- **统计检验：** 使用 `scipy.stats` 的例程执行指定的检验（用于独立性的卡方检验、用于拟合优度的柯尔莫哥洛夫-斯米尔诺夫检验以及用于均值的 t 检验）。固定的随机种子确保可复现性。对于卡方独立性检验，采用使用 `scipy.stats.chi2_contingency` 的标准程序，该程序根据观测数据表的边缘计算期望频率。如果计算出的 p 值超过显著性水平 $\\alpha$，则检验结果被认为是阳性的（原假设未被拒绝）。",
            "answer": "```python\nimport numpy as np\nfrom scipy import stats\nfrom scipy.special import betainc, gamma\n\ndef solve():\n    \"\"\"\n    Main function to run all derivations, algorithms, and statistical tests.\n    \"\"\"\n    RANDOM_SEED = 42\n    np.random.seed(RANDOM_SEED)\n\n    # Test cases as specified in the problem\n    test_cases = [\n        {'test_id': 1, 'd': 3, 'N': 200000, 'bins_phi': 12, 'bins_c': 12, 'alpha': 0.01},\n        {'test_id': 2, 'd': 5, 'N': 250000, 'alpha': 0.01},\n        {'test_id': 3, 'd': 5, 'N': 250000, 'bins_theta': 10, 'alpha': 0.01},\n        {'test_id': 4, 'd': 2, 'N': 400000, 'alpha': 0.01},\n    ]\n\n    results = []\n\n    # --- Helper Functions ---\n\n    def sample_S2_inverse_transform(N):\n        \"\"\"Samples N points on S^2 using inverse transform on angles (Part A).\"\"\"\n        # Sample phi uniformly from [0, 2*pi]\n        phi = np.random.uniform(0, 2 * np.pi, N)\n        # Sample cos(theta) uniformly from [-1, 1]\n        cos_theta = np.random.uniform(-1, 1, N)\n        sin_theta = np.sqrt(1 - cos_theta**2)\n        \n        # Convert to Cartesian coordinates\n        x1 = sin_theta * np.cos(phi)\n        x2 = sin_theta * np.sin(phi)\n        x3 = cos_theta\n        \n        # Return Cartesian points and the sampled angular variables for testing\n        return np.stack([x1, x2, x3], axis=-1), phi, cos_theta\n\n    def sample_Sd_minus_1_gaussian(N, d):\n        \"\"\"Samples N points on S^{d-1} using Gaussian normalization method.\"\"\"\n        Y = np.random.normal(size=(N, d))\n        norms = np.linalg.norm(Y, axis=1, keepdims=True)\n        # Handle potential zero norm, although highly unlikely for d>=2\n        norms[norms == 0] = 1\n        X = Y / norms\n        return X\n\n    def extract_hyperspherical_angles_d5(X):\n        \"\"\"Extracts angles theta_1 and theta_2 from Cartesian points in R^5.\"\"\"\n        x1 = X[:, 0]\n        x2 = X[:, 1]\n        \n        # theta_1 = arccos(x1)\n        theta_1 = np.arccos(np.clip(x1, -1.0, 1.0))\n        \n        # sin(theta_1) = sqrt(1-x1^2)\n        sin_theta_1 = np.sqrt(1 - x1**2)\n        \n        # cos(theta_2) = x2 / sin(theta_1)\n        # Avoid division by zero when sin(theta_1) is 0 (at poles)\n        # and clip to handle floating point inaccuracies\n        cos_theta_2 = np.divide(x2, sin_theta_1, out=np.zeros_like(x2), where=sin_theta_1!=0)\n        theta_2 = np.arccos(np.clip(cos_theta_2, -1.0, 1.0))\n\n        return theta_1, theta_2\n\n    # --- Execute Tests ---\n\n    # Test 1: Chi-square test for independence on S^2\n    case1 = test_cases[0]\n    _, phi_samples, cos_theta_samples = sample_S2_inverse_transform(case1['N'])\n    hist, _, _ = np.histogram2d(\n        phi_samples, cos_theta_samples,\n        bins=[case1['bins_phi'], case1['bins_c']],\n        range=[[0, 2 * np.pi], [-1, 1]]\n    )\n    chi2_stat, p_val, _, _ = stats.chi2_contingency(hist)\n    results.append(p_val > case1['alpha'])\n\n    # Test 2: KS test for marginal distribution on S^4 (d=5)\n    case2 = test_cases[1]\n    X_d5 = sample_Sd_minus_1_gaussian(case2['N'], case2['d'])\n    X1 = X_d5[:, 0]\n    U = (X1 + 1) / 2\n    # From Part B, U should follow Beta((d-1)/2, (d-1)/2) = Beta(2,2) for d=5\n    beta_params = (case2['d'] - 1) / 2\n    ks_stat, p_val = stats.kstest(U, 'beta', args=(beta_params, beta_params))\n    results.append(p_val > case2['alpha'])\n\n    # Test 3: Chi-square test for independence of angles on S^4 (d=5)\n    case3 = test_cases[2]\n    # It's better to regenerate data to keep tests independent\n    X_d5_test3 = sample_Sd_minus_1_gaussian(case3['N'], case3['d'])\n    theta1_samples, theta2_samples = extract_hyperspherical_angles_d5(X_d5_test3)\n    hist, _, _ = np.histogram2d(\n        theta1_samples, theta2_samples,\n        bins=[case3['bins_theta'], case3['bins_theta']],\n        range=[[0, np.pi], [0, np.pi]]\n    )\n    chi2_stat, p_val, _, _ = stats.chi2_contingency(hist)\n    results.append(p_val > case3['alpha'])\n\n    # Test 4: t-test for mean of X1 on S^1 (d=2)\n    case4 = test_cases[3]\n    X_d2 = sample_Sd_minus_1_gaussian(case4['N'], case4['d'])\n    X1 = X_d2[:, 0]\n    # Test H0: E[X1] = 0\n    t_stat, p_val = stats.ttest_1samp(X1, popmean=0)\n    results.append(p_val > case4['alpha'])\n    \n    # Final output formatting\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "掌握了基本的采样算法后，一个自然而然的实际问题是：在不同场景下，哪种算法是最佳选择？本练习旨在对三种不同范式的采样器进行比较研究：基于高斯归一化的直接构造法、基于群论的哈尔（Haar）旋转法，以及一种称为“命中脱离”（Hit-and-Run）的马尔可夫链蒙特卡洛（MCMC）方法。通过对它们的统计准确性、数值稳定性和计算成本进行量化评估，您将学会如何根据具体应用需求，在不同算法之间进行权衡和选择。",
            "id": "3337225",
            "problem": "您需要实现并比较三种随机采样器，这些采样器用于在单位球面 $\\mathbb{S}^{d-1} \\subset \\mathbb{R}^{d}$ 上生成随机向量。这三种方法是：\n\n1. Haar旋转采样器：根据不变Haar测度抽取一个随机旋转矩阵 $R \\in \\mathrm{SO}(d)$，并输出 $\\mathbf{x} = R \\mathbf{e}_{1}$，其中 $\\mathbf{e}_{1}$ 是 $\\mathbb{R}^{d}$ 中的第一个标准基向量。\n2. 归一化高斯采样器：抽取 $\\mathbf{z} \\sim \\mathcal{N}(\\mathbf{0}, I_{d})$，并输出 $\\mathbf{x} = \\mathbf{z} / \\lVert \\mathbf{z} \\rVert_{2}$。\n3. 球面上的Hit-and-run：在 $\\mathbb{S}^{d-1}$ 上构建一个可逆马尔可夫链，其平稳分布等于球面上的均匀分布。从 $\\mathbf{x}_{0} = \\mathbf{e}_{1}$ 开始，在每一步中，在 $\\mathbf{x}_{t}$ 处的切空间中采样一个随机方向，然后沿着由 $\\mathbf{x}_{t}$ 和该方向确定的大圆移动到一个均匀选择的点。\n\n从适用于随机模拟和蒙特卡洛方法的基本原理出发，您的程序必须：\n\n- 实现所有三种采样器。\n- 对于每种采样器和下面的每个测试用例，生成所请求数量的样本，并计算以下诊断指标：\n  - 均匀性诊断 A（一维柯尔莫哥洛夫–斯米尔诺夫统计量）：如果 $\\mathbf{x} = (x_{1}, \\dots, x_{d})$ 在 $\\mathbb{S}^{d-1}$ 上均匀分布，那么 $x_{1}$ 在 $[-1,1]$ 上的密度与 $(1 - s^{2})^{(d-3)/2}$ 成正比，等价地，$Y = (x_{1}+1)/2$ 服从参数为 $\\left(\\frac{d-1}{2}, \\frac{d-1}{2}\\right)$ 的Beta分布。计算 $x_{1}$ 值样本与此理论分布之间的经验柯尔莫哥洛夫–斯米尔诺夫统计量，该统计量表示为经验累积分布函数与由正则化不完全贝塔函数给出的理论累积分布函数之间绝对差值的上确界。\n  - 均匀性诊断 B（协方差各向同性）：对于 $\\mathbb{S}^{d-1}$ 上的均匀分布，有 $\\mathbb{E}[\\mathbf{x}] = \\mathbf{0}$ 和 $\\mathbb{E}[\\mathbf{x}\\mathbf{x}^{\\top}] = \\frac{1}{d} I_{d}$。计算经验协方差矩阵 $\\widehat{\\Sigma} = \\frac{1}{n}\\sum_{i=1}^{n} \\mathbf{x}_{i}\\mathbf{x}_{i}^{\\top} - \\widehat{\\mu}\\widehat{\\mu}^{\\top}$，其中 $\\widehat{\\mu} = \\frac{1}{n}\\sum_{i=1}^{n} \\mathbf{x}_{i}$，并报告弗罗贝尼乌斯范数 $\\lVert \\widehat{\\Sigma} - \\frac{1}{d} I_{d} \\rVert_{\\mathrm{F}}$。\n  - 数值稳定性指标：报告平均绝对范数误差 $\\frac{1}{n}\\sum_{i=1}^{n} \\lvert \\lVert \\mathbf{x}_{i} \\rVert_{2} - 1 \\rvert$ 和最大绝对范数误差 $\\max_{1 \\le i \\le n} \\lvert \\lVert \\mathbf{x}_{i} \\rVert_{2} - 1 \\rvert$。\n- 使用每个样本的两个确定性代理指标来比较计算成本：\n  - 每个样本的随机变量数（根据设计精确计数）：\n    - 归一化高斯：$d$ 个独立的标准正态随机变量。\n    - 通过对一个 $d \\times d$ 标准高斯矩阵进行 $QR$ 分解得到的Haar旋转 $R \\in \\mathrm{SO}(d)$：$d^{2}$ 个独立的标准正态随机变量。\n    - 带有稀疏化参数 $s \\in \\mathbb{N}$ 的球面上Hit-and-run（每个保留样本的步数等于 $s+1$）：每一步使用 $d$ 个独立的标准正态随机变量确定方向，以及一个在 $[-\\pi,\\pi]$ 上的独立均匀随机变量确定角度（角度以弧度为单位）。因此，每个保留样本总共需要 $(s+1) (d + 1)$ 个随机变量。\n  - 浮点运算代理（每个样本的浮点运算单元数，仅考虑比例常数）：\n    - 归一化高斯：$3d$ 个单元（范数计算和归一化）。\n    - 通过 $QR$ 的Haar旋转：$\\tfrac{2}{3} d^{3}$ 个单元（主要的 $QR$ 分解成本）。\n    - 带有稀疏化参数 $s$ 的Hit-and-run：$7d (s+1)$ 个单元（每步的切空间投影、归一化和旋转更新）。\n  这些代理指标用于确定性地比较计算成本，而不依赖于实际运行时间。\n\n实现约束和定义：\n\n- 使用定义球面上和特殊正交群 $\\mathrm{SO}(d)$ 上均匀性的不变性原理作为您的基本依据。除了基本的线性代数和随机变量生成外，不要使用任何直接从 $\\mathrm{SO}(d)$ 或球面上采样的预封装例程。\n- 对于Haar采样器，通过对一个具有独立标准正态条目的 $d \\times d$ 矩阵进行 $QR$ 分解来生成 $R$，调整列的符号以使 $R$ 的对角线为正，如果 $\\det(Q) = -1$，则翻转一列以获得 $\\det(Q) = +1$；然后返回 $\\mathbf{x} = Q \\mathbf{e}_{1}$。\n- 对于球面上的hit-and-run采样器，从 $\\mathbf{x}$ 开始的每一步：\n  1. 抽取 $\\mathbf{v} \\sim \\mathcal{N}(\\mathbf{0}, I_{d})$，设置切线方向 $\\mathbf{u} = \\mathbf{v} - (\\mathbf{v}^{\\top}\\mathbf{x}) \\mathbf{x}$，并进行归一化 $\\mathbf{u} \\leftarrow \\mathbf{u} / \\lVert \\mathbf{u} \\rVert_{2}$。\n  2. 以弧度为单位抽取 $\\phi \\sim \\mathrm{Uniform}([-\\pi,\\pi])$，并设置下一个状态 $\\mathbf{x}^{\\prime} = \\cos(\\phi)\\,\\mathbf{x} + \\sin(\\phi)\\,\\mathbf{u}$，该状态位于 $\\mathbb{S}^{d-1}$ 上。\n  3. 根据指定的预烧期和稀疏化计划重复操作。\n\n测试套件：\n\n您的程序必须使用固定的伪随机种子 $20231011$ 运行以下三个测试用例，以确保可复现性。对于每个用例，请使用指定的维度 $d$、每种采样器的样本数量以及hit-and-run的老化期和稀疏化参数：\n\n- 用例 A：$d = 3$，归一化高斯采样器 $n_{\\mathrm{G}} = 20000$，Haar采样器 $n_{\\mathrm{H}} = 1500$，hit-and-run采样器 $n_{\\mathrm{HR}} = 20000$，老化期 $b = 2000$，稀疏化 $s = 2$。\n- 用例 B：$d = 10$，归一化高斯采样器 $n_{\\mathrm{G}} = 20000$，Haar采样器 $n_{\\mathrm{H}} = 800$，hit-and-run采样器 $n_{\\mathrm{HR}} = 20000$，老化期 $b = 3000$，稀疏化 $s = 5$。\n- 用例 C（小样本边缘情况）：$d = 3$，归一化高斯采样器 $n_{\\mathrm{G}} = 400$，Haar采样器 $n_{\\mathrm{H}} = 60$，hit-and-run采样器 $n_{\\mathrm{HR}} = 400$，老化期 $b = 50$，稀疏化 $s = 1$。\n\n所需输出：\n\n- 对于每个测试用例，为每个采样器计算一个包含六个浮点数的向量：\n  - $S_{\\mathrm{KS}}$：$x_{1}$ 相对于通过 $y = \\frac{x_{1}+1}{2}$ 从 $[-1,1]$ 映射到 $[0,1]$ 的 $\\mathrm{Beta}\\!\\left(\\tfrac{d-1}{2}, \\tfrac{d-1}{2}\\right)$ 模型的柯尔莫哥洛夫–斯米尔诺夫统计量。\n  - $E_{\\mathrm{cov}}$：弗罗贝尼乌斯范数 $\\lVert \\widehat{\\Sigma} - \\tfrac{1}{d} I_{d} \\rVert_{\\mathrm{F}}$。\n  - $\\overline{E}_{\\mathrm{norm}}$：平均绝对范数误差。\n  - $E_{\\mathrm{norm}}^{\\max}$：最大绝对范数误差。\n  - $N_{\\mathrm{rv}}$：每个样本的理论随机变量数（按上述规定精确计数）。\n  - $C_{\\mathrm{flop}}$：每个样本的浮点运算单元代理（按上述规定）。\n- 最终程序输出必须是单行，包含一个长度为 3 的列表（对应三个测试用例）。每个元素本身是一个长度为 3 的列表（按归一化高斯、Haar、hit-and-run排序），每个采样器的条目是按上述顺序排列的 6 个浮点数的列表。该行必须格式化为无空格的逗号分隔列表，例如：\"[[...[six floats]...,[...[six floats]...,[...[six floats]...]],[...],[...]]\"。您的程序必须且仅能产生这样一行输出。\n\n角度必须以弧度为单位。此问题中没有物理单位。\n\n所有随机数生成必须使用固定的种子 $20231011$ 进行，以确保确定性的可复现性。\n\n您的提交必须是最终答案部分指定的完整、可运行的程序。",
            "solution": "生成在单位球面 $\\mathbb{S}^{d-1} = \\{\\mathbf{x} \\in \\mathbb{R}^d : \\lVert\\mathbf{x}\\rVert_2 = 1\\}$ 上均匀分布的随机向量问题，是随机模拟、计算物理学和统计学中的一项基本任务。球面上均匀分布的定义性属性是其旋转不变性：如果 $\\mathbf{x}$ 在 $\\mathbb{S}^{d-1}$ 上均匀分布，那么对于任何正交变换 $M \\in \\mathrm{O}(d)$，向量 $M\\mathbf{x}$ 的分布与 $\\mathbf{x}$ 相同。下文介绍了三种不同采样方法的理论基础和算法实现，随后描述了用于评估其质量和成本的诊断指标。\n\n**1. 归一化高斯采样器**\n\n此方法利用了标准多元正态分布的球对称性。\n\n*   **原理：**从 $\\mathbb{R}^d$ 中的标准正态分布抽取的随机向量 $\\mathbf{z} = (z_1, \\dots, z_d)^\\top$（记为 $\\mathbf{z} \\sim \\mathcal{N}(\\mathbf{0}, I_d)$），其概率密度函数为 $p(\\mathbf{z}) = (2\\pi)^{-d/2} \\exp(-\\frac{1}{2} \\mathbf{z}^\\top \\mathbf{z})$。该密度仅取决于向量的欧几里得范数的平方 $\\lVert \\mathbf{z} \\rVert_2^2$。对于任何旋转矩阵 $R \\in \\mathrm{SO}(d)$，都有 $\\lVert R\\mathbf{z} \\rVert_2 = \\lVert \\mathbf{z} \\rVert_2$，这意味着 $\\mathbf{z}$ 的分布是旋转不变的。这种不变性属性被传递给归一化向量 $\\mathbf{x} = \\mathbf{z} / \\lVert \\mathbf{z} \\rVert_2$。由于 $\\mathbf{x}$ 的分布在旋转下是不变的，且其支撑集是 $\\mathbb{S}^{d-1}$，因此它必定是球面上的均匀分布。\n\n*   **算法：**\n    1.  生成一个向量 $\\mathbf{z} \\in \\mathbb{R}^d$，其中每个分量 $z_i$ 都是从标准正态分布 $\\mathcal{N}(0, 1)$ 中抽取的独立样本。\n    2.  计算欧几里得范数 $r = \\lVert \\mathbf{z} \\rVert_2$。以概率 $1$ 而言，$r > 0$。\n    3.  得到的样本即为归一化向量 $\\mathbf{x} = \\frac{1}{r} \\mathbf{z}$。\n\n**2. Haar旋转采样器**\n\n此方法依赖于特殊正交群 $\\mathrm{SO}(d)$ 在球面上的群作用。\n\n*   **原理：**旋转群 $\\mathrm{SO}(d)$ 在球面 $\\mathbb{S}^{d-1}$ 上传递地作用，这意味着球面上的任何点都可以通过旋转从任何其他点到达。群论中的一个基本结果指出，$\\mathrm{SO}(d)$ 拥有一个唯一的概率测度，即Haar测度，它在群乘法（即旋转）下是不变的。如果从这个Haar测度中采样一个旋转矩阵 $R$，并将其应用于任何固定的单位向量，例如第一个标准基向量 $\\mathbf{e}_1 = (1, 0, \\dots, 0)^\\top$，则得到的向量 $\\mathbf{x} = R \\mathbf{e}_1$ 保证在 $\\mathbb{S}^{d-1}$ 上均匀分布。\n\n*   **算法：**生成一个Haar分布的正交矩阵的标准方法是对一组 $d$ 个线性无关的向量应用Gram-Schmidt过程。如此处所指定的，一种数值上稳定的方法是通过QR分解实现。\n    1.  生成一个 $d \\times d$ 矩阵 $A$，其条目独立地从 $\\mathcal{N}(0, 1)$ 中抽取。其列的联合分布是球对称的。\n    2.  执行QR分解 $A = QR$，其中 $Q$ 是一个正交矩阵（$Q^\\top Q = I_d$），$R$ 是一个上三角矩阵。矩阵 $Q$ 根据正交群 $\\mathrm{O}(d)$ 上的Haar测度分布。\n    3.  为了确保唯一的分解并得到一个属于 $\\mathrm{SO}(d)$（旋转，而非反射）的矩阵，我们进行两次调整。首先，对于 $Q$ 的每一列 $i$，如果对应的对角元素 $R_{ii}$ 为负，我们将 $Q$ 的第 $i$ 列和 $R$ 的第 $i$ 行乘以 $-1$。这使得 $R$ 的所有对角线元素都变为非负，而不改变乘积 $QR$。\n    4.  其次，我们计算调整后 $Q$ 的行列式。如果 $\\det(Q) = -1$，则该矩阵表示一个反射。我们通过将其中的一列（例如第一列）乘以 $-1$ 将其转换为旋转。这样可以得到一个同样是Haar分布的矩阵 $Q' \\in \\mathrm{SO}(d)$。\n    5.  样本是最终旋转矩阵的第一列，$\\mathbf{x} = Q' \\mathbf{e}_1$。\n\n**3. 球面上的Hit-and-run**\n\n这是一种马尔可夫链蒙特卡洛（MCMC）方法，它在球面上构建一个随机游走，其平衡分布是所期望的均匀分布。\n\n*   **原理：**该算法在 $\\mathbb{S}^{d-1}$ 上构建了一个可逆马尔可夫链。如果转移核 $P(\\mathbf{x}, A) = \\int_A p(\\mathbf{x}, \\mathbf{y}) d\\sigma(\\mathbf{y})$ 满足细致平衡条件：对于所有 $\\mathbf{x}, \\mathbf{y} \\in \\mathbb{S}^{d-1}$，$p(\\mathbf{x}, \\mathbf{y}) = p(\\mathbf{y}, \\mathbf{x})$，则球面上的均匀分布 $\\sigma$ 是该链的平稳分布。所指定的采样器满足此条件，因为它提议移动到一个新点，该点是从通过当前点 $\\mathbf{x}_t$ 且方向随机选择的大圆上均匀选择的。由于大圆的选择以及其上点的选择是对称的，因此该过程是可逆的，并收敛到均匀分布。\n\n*   **算法：**从初始点 $\\mathbf{x}_0 = \\mathbf{e}_1$ 开始，每一步 $t \\to t+1$ 按以下方式进行：\n    1.  生成一个随机方向向量 $\\mathbf{v} \\sim \\mathcal{N}(\\mathbf{0}, I_d)$。\n    2.  将此方向投影到当前点 $\\mathbf{x}_t$ 处的切空间上。切空间是与 $\\mathbf{x}_t$ 正交的超平面。投影由 $\\mathbf{v}_{\\perp} = \\mathbf{v} - (\\mathbf{v}^\\top \\mathbf{x}_t) \\mathbf{x}_t$ 给出。$\\mathbf{v}$ 的球对称性确保了得到的切线方向是均匀的。\n    3.  归一化切线方向：$\\mathbf{u} = \\mathbf{v}_{\\perp} / \\lVert \\mathbf{v}_{\\perp} \\rVert_2$。\n    4.  向量 $\\mathbf{x}_t$ 和 $\\mathbf{u}$ 是标准正交的，并定义了一个大圆。通过沿此圆移动一个随机角度来选择一个新点。从 $[-\\pi, \\pi]$ 上的均匀分布中采样一个角度 $\\phi$。\n    5.  下一个状态是 $\\mathbf{x}_{t+1} = \\cos(\\phi) \\mathbf{x}_t + \\sin(\\phi) \\mathbf{u}$。根据构造，$\\lVert \\mathbf{x}_{t+1} \\rVert_2 = 1$。\n    该链会运行一个“老化期”（burn-in）$b$ 步，以使其接近平稳分布。随后，以一个“稀疏化”间隔 $s$ 收集样本，即每 $s+1$ 步存储一个样本，以减少它们之间的自相关性。\n\n**诊断指标与成本代理**\n\n为评估这些采样器，我们计算了一组诊断指标和确定性成本代理。\n\n*   **均匀性诊断 A ($S_{\\mathrm{KS}}$)：**如果 $\\mathbf{x} = (x_1, \\dots, x_d)$ 在 $\\mathbb{S}^{d-1}$ 上均匀分布，其第一个分量 $x_1$ 在 $[-1, 1]$ 上有一个特定的边际分布，其密度与 $(1-t^2)^{(d-3)/2}$ 成正比。变换后的变量 $Y = (x_1+1)/2$ 服从 $\\mathrm{Beta}(\\frac{d-1}{2}, \\frac{d-1}{2})$ 分布。柯尔莫哥洛夫-斯米尔诺夫统计量 $S_{\\mathrm{KS}}$ 衡量了样本的经验累积分布函数（CDF）与理论Beta分布CDF之间的最大差异。值越小表示一致性越好。\n\n*   **均匀性诊断 B ($E_{\\mathrm{cov}}$)：**对于 $\\mathbb{S}^{d-1}$ 上的均匀分布，理论期望为 $\\mathbb{E}[\\mathbf{x}] = \\mathbf{0}$，协方差矩阵是各向同性的：$\\mathbb{E}[\\mathbf{x}\\mathbf{x}^\\top] = \\frac{1}{d}I_d$。我们计算样本均值 $\\widehat{\\mu}$ 和样本协方差矩阵 $\\widehat{\\Sigma}$，并报告差异的弗罗贝尼乌斯范数，$E_{\\mathrm{cov}} = \\lVert \\widehat{\\Sigma} - \\frac{1}{d}I_d \\rVert_{\\mathrm{F}}$。值越小表示样本的二阶矩与理论值越接近。\n\n*   **数值稳定性 ($\\overline{E}_{\\mathrm{norm}}$, $E_{\\mathrm{norm}}^{\\max}$)：**根据定义，所有样本都应位于球面上，即范数为 $1$。计算与 $1$ 的平均和最大绝对偏差 $\\lvert \\lVert \\mathbf{x}_i \\rVert_2 - 1 \\rvert$，以评估数值误差。\n\n*   **计算成本 ($N_{\\mathrm{rv}}$, $C_{\\mathrm{flop}}$)：**我们不使用实际运行时间，而是使用确定性代理。$N_{\\mathrm{rv}}$ 统计每个样本所需的随机变量（例如，来自 $\\mathcal{N}(0,1)$ 或 $\\mathrm{Uniform}$）的数量。$C_{\\mathrm{flop}}$ 是浮点运算次数的代理，根据每种算法的主要计算步骤进行缩放。这些指标为计算开销提供了标准化的比较。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import beta as beta_dist\nimport json\n\ndef get_diagnostics(samples, d):\n    \"\"\"\n    Computes a vector of diagnostics for a given set of samples.\n    Args:\n        samples (np.ndarray): An (n, d) array of n samples in d dimensions.\n        d (int): The dimension.\n    Returns:\n        tuple: (ks_stat, cov_error, mean_norm_error, max_norm_error)\n    \"\"\"\n    n = samples.shape[0]\n    if n == 0:\n        return 0.0, 0.0, 0.0, 0.0\n\n    # Uniformity Diagnostic A: Kolmogorov-Smirnov statistic\n    # The first coordinate x_1 transformed as y = (x_1+1)/2 follows a Beta distribution.\n    x1_samples = samples[:, 0]\n    y_samples = (x1_samples + 1) / 2\n    y_samples.sort()\n    \n    alpha = (d - 1) / 2\n    # For d=1, alpha=0, which is invalid for Beta. But d>=2 always in these cases.\n    cdf_vals = beta_dist.cdf(y_samples, alpha, alpha)\n    \n    i = np.arange(1, n + 1)\n    d_plus = np.max(i / n - cdf_vals)\n    d_minus = np.max(cdf_vals - (i - 1) / n)\n    ks_stat = np.max([d_plus, d_minus])\n    \n    # Uniformity Diagnostic B: Covariance isotropy\n    mu_hat = np.mean(samples, axis=0)\n    mu_hat_reshaped = mu_hat.reshape(-1, 1)\n    sigma_hat = (samples.T @ samples) / n - mu_hat_reshaped @ mu_hat_reshaped.T\n        \n    Id = np.eye(d)\n    cov_error = np.linalg.norm(sigma_hat - (1/d) * Id, 'fro')\n\n    # Numerical Stability Metrics\n    norms = np.linalg.norm(samples, axis=1)\n    abs_norm_errors = np.abs(norms - 1)\n    mean_norm_error = np.mean(abs_norm_errors)\n    max_norm_error = np.max(abs_norm_errors)\n\n    return ks_stat, cov_error, mean_norm_error, max_norm_error\n\ndef normalized_gaussian_sampler(d, n, rng):\n    \"\"\"Normalized Gaussian sampler.\"\"\"\n    z = rng.standard_normal(size=(n, d))\n    norms = np.linalg.norm(z, axis=1, keepdims=True)\n    # Avoid division by zero, although it has probability zero.\n    norms[norms == 0] = 1.0 \n    return z / norms\n\ndef haar_rotation_sampler(d, n, rng):\n    \"\"\"Haar-rotation sampler via QR decomposition.\"\"\"\n    samples = np.zeros((n, d))\n    for i in range(n):\n        A = rng.standard_normal(size=(d, d))\n        Q, R = np.linalg.qr(A)\n        \n        # Adjust signs so diagonal of R is positive\n        s = np.diag(np.sign(np.diag(R)))\n        Q = Q @ s\n        \n        # Ensure determinant is +1\n        if np.linalg.det(Q)  0:\n            Q[:, 0] = -Q[:, 0]\n            \n        samples[i] = Q[:, 0]\n    return samples\n\ndef hit_and_run_sampler(d, n, burn_in, thinning, rng):\n    \"\"\"Hit-and-run sampler on the sphere.\"\"\"\n    samples = np.zeros((n, d))\n    \n    # Initial state\n    x = np.zeros(d)\n    x[0] = 1.0\n\n    total_steps = burn_in + n * (thinning + 1)\n    sample_idx = 0\n    \n    for i in range(total_steps):\n        # 1. Get random tangent direction\n        v = rng.standard_normal(size=d)\n        u = v - np.dot(v, x) * x\n        u_norm = np.linalg.norm(u)\n        if u_norm  1e-15: # Highly unlikely event\n            continue \n        u /= u_norm\n        \n        # 2. Move along great circle\n        phi = rng.uniform(-np.pi, np.pi)\n        x = np.cos(phi) * x + np.sin(phi) * u\n        \n        # 3. Store sample after burn-in and thinning\n        if i >= burn_in and (i - burn_in) % (thinning + 1) == thinning:\n            if sample_idx  n:\n                samples[sample_idx] = x\n                sample_idx += 1\n                \n    return samples\n\ndef solve():\n    # Fixed seed for reproducibility\n    rng = np.random.default_rng(20231011)\n\n    # Test cases: (d, n_G, n_H, n_HR, burn_in, thinning)\n    test_cases = [\n        (3, 20000, 1500, 20000, 2000, 2),\n        (10, 20000, 800, 20000, 3000, 5),\n        (3, 400, 60, 400, 50, 1)\n    ]\n\n    all_results = []\n    \n    for d, n_g, n_h, n_hr, b, s in test_cases:\n        case_results = []\n\n        # 1. Normalized Gaussian Sampler\n        samples_g = normalized_gaussian_sampler(d, n_g, rng)\n        ks_g, cov_g, mean_err_g, max_err_g = get_diagnostics(samples_g, d)\n        n_rv_g = float(d)\n        c_flop_g = float(3 * d)\n        case_results.append([ks_g, cov_g, mean_err_g, max_err_g, n_rv_g, c_flop_g])\n        \n        # 2. Haar Rotation Sampler\n        samples_h = haar_rotation_sampler(d, n_h, rng)\n        ks_h, cov_h, mean_err_h, max_err_h = get_diagnostics(samples_h, d)\n        n_rv_h = float(d**2)\n        c_flop_h = float((2/3) * d**3)\n        case_results.append([ks_h, cov_h, mean_err_h, max_err_h, n_rv_h, c_flop_h])\n\n        # 3. Hit-and-Run Sampler\n        samples_hr = hit_and_run_sampler(d, n_hr, b, s, rng)\n        ks_hr, cov_hr, mean_err_hr, max_err_hr = get_diagnostics(samples_hr, d)\n        n_rv_hr = float((s + 1) * (d + 1))\n        c_flop_hr = float(7 * d * (s + 1))\n        case_results.append([ks_hr, cov_hr, mean_err_hr, max_err_hr, n_rv_hr, c_flop_hr])\n        \n        all_results.append(case_results)\n    \n    # Format the final output string exactly as required\n    print(json.dumps(all_results, separators=(',', ':')))\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "生成样本只是任务的一半，我们还需要工具来严格验证采样器是否按预期工作。本章的最后一个实践将引导您设计并实现一个精密的诊断工具，用于检验样本在球面上的旋转不变性——这是均匀分布的根本性质。您将学习如何利用从哈尔（Haar）测度中抽取的随机旋转，通过比较旋转前后样本点在不同球面冠（spherical caps）内的分布情况，来量化评估采样算法的均匀性。这项实践不仅是一次编程练习，更是一次对问题背后对称性原理的深刻探索。",
            "id": "3337173",
            "problem": "要求您设计并实现一种针对在 $\\mathbb{R}^d$ 的单位球面上均匀采样随机向量的旋转不变性诊断检验。该诊断检验必须从随机模拟的基本原理推导得出，并且必须通过比较随机旋转前后经验球帽的计数来量化单位球面上的均匀性。您必须从一个有效的基础出发，确立一种在球面上采样算法的旋转不变性，然后构建一个可实现的检验统计量。\n\n基本原理：\n- $d$ 维标准多变量正态分布的密度函数为 $f(\\mathbf{z}) = (2\\pi)^{-d/2}\\exp(-\\|\\mathbf{z}\\|_2^2/2)$，该分布具有球面对称性，这意味着对于任何旋转矩阵 $\\mathbf{R}\\in SO(d)$（其中 $SO(d)$ 表示特殊正交群，即行列式为1的 $d\\times d$ 正交矩阵集合），$\\mathbf{R}\\mathbf{z}$ 的分布与 $\\mathbf{z}$ 的分布相同。\n- 在 $SO(d)$ 上唯一的旋转不变概率测度是哈尔测度（紧群上的左右不变概率测度）。\n- 单位球面 $S^{d-1}=\\{\\mathbf{x}\\in\\mathbb{R}^d:\\|\\mathbf{x}\\|_2=1\\}$ 上的一个球帽，以单位向量 $\\mathbf{u}\\in S^{d-1}$ 为中心，半角为 $\\theta\\in[0,\\pi]$（弧度制），其定义为 $C(\\mathbf{u},\\theta)=\\{\\mathbf{x}\\in S^{d-1}:\\arccos(\\mathbf{u}^\\top \\mathbf{x})\\le \\theta\\}$，等价于 $\\{\\mathbf{x}\\in S^{d-1}:\\mathbf{u}^\\top \\mathbf{x}\\ge \\cos\\theta\\}$。\n\n任务：\n- 基于上述原理，推导并论证一个通过变换 $\\mathbb{R}^d$ 中的旋转不变分布来在 $S^{d-1}$ 上采样的算法。\n- 基于哈尔测度的唯一性，推导一个从 $SO(d)$ 中采样随机旋转矩阵 $\\mathbf{R}$ 的实用程序。\n- 定义一个诊断检验，该检验比较对 $S^{d-1}$ 上的一个采样点集应用哈尔分布的随机旋转前后，球帽计数的差异。对于一组 $m$ 个单位方向 $\\{\\mathbf{u}_j\\}_{j=1}^m$ 和一个固定的半角 $\\theta$，计算旋转前计数 $c_{j}^{\\text{pre}}=\\sum_{i=1}^n \\mathbf{1}\\{\\mathbf{u}_j^\\top \\mathbf{x}^{(i)}\\ge \\cos\\theta\\}$ 和旋转后计数 $c_{j}^{\\text{post}}=\\sum_{i=1}^n \\mathbf{1}\\{\\mathbf{u}_j^\\top (\\mathbf{R}\\mathbf{x}^{(i)})\\ge \\cos\\theta\\}$。构建一个标量检验统计量 $T$，它将所有球帽的差异汇总成一个单一、可解释的数值，以反映旋转不变性。您的统计量必须数值稳定，并考虑到采样变异性；角度应以弧度为单位。\n\n实现要求：\n- 使用固定的伪随机种子 $1729$ 以保证可复现性。\n- 实现以下具体选择：\n  - 通过独立抽取 $\\mathbf{z}^{(i)}\\sim \\mathcal{N}(\\mathbf{0},\\mathbf{I}_d)$ 并设置 $\\mathbf{x}^{(i)}=\\mathbf{z}^{(i)}/\\|\\mathbf{z}^{(i)}\\|_2$ 来采样 $\\mathbf{x}^{(i)}$。\n  - 使用与哈尔测度一致的方法采样 $\\mathbf{R}\\in SO(d)$。\n  - 使用相同的球面采样方法，将球帽方向 $\\mathbf{u}_j$ 作为 $S^{d-1}$ 上的独立单位向量进行采样。\n  - 按如下方式定义诊断统计量。对于每个球帽 $j$，令 $\\widehat{p}_j=(c_j^{\\text{pre}}+c_j^{\\text{post}})/(2n)$，合并标准误估计为 $s_j=\\sqrt{2\\widehat{p}_j(1-\\widehat{p}_j)/n}$。定义标准化差异 $z_j=\\begin{cases} \\frac{\\left|c_j^{\\text{pre}}/n - c_j^{\\text{post}}/n\\right|}{s_j},  s_j0\\\\ 0,  s_j=0\\end{cases}$，以及诊断统计量 $T=\\max_{1\\le j\\le m} z_j$。\n\n测试套件：\n- 对于每个测试用例，输入参数为 $(d,n,m,\\theta)$，角度单位为弧度。使用以下 5 个用例在典型、边界和高维情况下检验该诊断：\n  - 用例 1：$(d,n,m,\\theta)=(3,10000,12,0.5)$。\n  - 用例 2：$(d,n,m,\\theta)=(2,15000,16,0.2)$。\n  - 用例 3：$(d,n,m,\\theta)=(10,12000,24,0.3)$。\n  - 用例 4：$(d,n,m,\\theta)=(50,8000,40,0.25)$。\n  - 用例 5：$(d,n,m,\\theta)=(5,300,10,0.4)$。\n- 为保证各用例间的可复现性，使用固定的基础种子 $1729$，并且对于用例索引 $k\\in\\{1,2,3,4,5\\}$，在该用例 $k$ 内的所有随机性操作均使用种子 $1729+k$。\n\n最终输出格式：\n- 您的程序必须输出一行，包含 5 个测试用例的诊断值列表 $[T_1,T_2,T_3,T_4,T_5]$，格式为方括号内用逗号分隔的列表。不允许有其他输出。",
            "solution": "该问题要求推导、论证并实现一个诊断检验，用于测试在 $\\mathbb{R}^d$ 单位球面上均匀采样的随机向量算法的旋转不变性。该解决方案按要求从基本原理构建。\n\n### 1. 在单位球面 $S^{d-1}$ 上的均匀采样\n在单位球面 $S^{d-1} = \\{\\mathbf{x} \\in \\mathbb{R}^d : \\|\\mathbf{x}\\|_2 = 1\\}$ 上进行均匀采样的基本原理是标准多变量正态分布的球面对称性。一个从标准正态分布 $\\mathcal{N}(\\mathbf{0}, \\mathbf{I}_d)$ 中抽取的随机向量 $\\mathbf{z} \\in \\mathbb{R}^d$ 的概率密度函数为 $f(\\mathbf{z}) = (2\\pi)^{-d/2}\\exp(-\\|\\mathbf{z}\\|_2^2/2)$。该密度函数仅依赖于向量的模长 $\\|\\mathbf{z}\\|_2$，而与其方向无关。此性质被称为球面对称性。\n\n这种对称性意味着向量 $\\mathbf{z}$ 的方向，即单位向量 $\\mathbf{x} = \\mathbf{z} / \\|\\mathbf{z}\\|_2$，必然在 $S^{d-1}$ 上均匀分布。为了形式化地说明这一点，考虑任意旋转矩阵 $\\mathbf{R} \\in SO(d)$。由于 $\\mathbf{z}$ 的分布是球面对称的，旋转后的向量 $\\mathbf{Rz}$ 的分布与 $\\mathbf{z}$ 的分布相同。旋转后向量的方向为 $\\mathbf{Rz} / \\|\\mathbf{Rz}\\|_2$。由于旋转是等距变换，$\\|\\mathbf{Rz}\\|_2 = \\|\\mathbf{z}\\|_2$，因此新方向为 $\\mathbf{R}(\\mathbf{z} / \\|\\mathbf{z}\\|_2) = \\mathbf{Rx}$。因为 $\\mathbf{z}$ 和 $\\mathbf{Rz}$ 的分布相同，它们对应的方向向量 $\\mathbf{x}$ 和 $\\mathbf{Rx}$ 的分布也必须相同。在 $S^{d-1}$ 上唯一在所有旋转下保持不变的概率分布是均匀分布。因此，方向向量 $\\mathbf{x}$ 在 $S^{d-1}$ 上是均匀分布的。\n\n由此产生的算法通常归功于 G. E. P. Box 和 M. E. Muller，其步骤如下：\n1. 生成一个 $d$ 维向量 $\\mathbf{z} = (z_1, z_2, \\ldots, z_d)^\\top$，其中每个分量 $z_i$ 都是从标准正态分布 $\\mathcal{N}(0, 1)$ 中独立抽取的。\n2. 计算欧几里得范数 $\\|\\mathbf{z}\\|_2 = \\sqrt{\\sum_{i=1}^d z_i^2}$。对于连续分布，$\\mathbf{z} = \\mathbf{0}$ 的概率为 $0$，因此几乎可以肯定 $\\|\\mathbf{z}\\|_2  0$。\n3. 在 $S^{d-1}$ 上均匀分布的随机向量由归一化得到：$\\mathbf{x} = \\mathbf{z} / \\|\\mathbf{z}\\|_2$。\n\n### 2. 从特殊正交群 $SO(d)$ 中采样随机旋转\n该任务要求根据其唯一的旋转不变概率测度——哈尔测度，从特殊正交群 $SO(d)$ 中采样一个随机旋转矩阵 $\\mathbf{R}$。实现此目标的一种标准且计算高效的方法是利用QR分解。\n\n令 $\\mathbf{A}$ 为一个 $d \\times d$ 矩阵，其元素是来自 $\\mathcal{N}(0, 1)$ 的独立同分布（i.i.d.）随机变量。$\\mathbf{A}$ 的元素的联合分布在 $\\mathbb{R}^{d^2}$ 中是球面对称的。$\\mathbf{A}$ 的QR分解将其表示为乘积 $\\mathbf{A} = \\mathbf{QR}_{\\text{upper}}$，其中 $\\mathbf{Q}$ 是一个正交矩阵（$\\mathbf{Q}^\\top\\mathbf{Q} = \\mathbf{I}_d$），$\\mathbf{R}_{\\text{upper}}$ 是一个上三角矩阵。可以证明，得到的矩阵 $\\mathbf{Q}$ 服从正交群 $O(d)$ 上的哈尔测度。\n\n群 $O(d)$ 由行列式等于 $+1$ 或 $-1$ 的矩阵组成。特殊正交群 $SO(d)$ 是 $O(d)$ 的子群，仅包含行列式为 $+1$ 的矩阵。为了从 $SO(d)$ 中获得一个样本，我们首先从 $O(d)$ 中采样 $\\mathbf{Q}$，然后在必要时将其映射到 $SO(d)$。如果 $\\det(\\mathbf{Q}) = +1$，则 $\\mathbf{Q}$ 已经属于 $SO(d)$。如果 $\\det(\\mathbf{Q}) = -1$，我们可以通过将任意单列（或行）乘以 $-1$ 将其转换为 $SO(d)$ 的元素。此操作会翻转行列式的符号，同时保持 $SO(d)$ 上分布的哈尔测度性质。\n\n采样 $\\mathbf{R} \\in SO(d)$ 的算法如下：\n1. 生成一个 $d \\times d$ 矩阵 $\\mathbf{A}$，其元素为来自 $\\mathcal{N}(0, 1)$ 的独立同分布随机变量。\n2. 对 $\\mathbf{A}$ 进行QR分解，得到正交矩阵 $\\mathbf{Q}$。\n3. 计算行列式 $s = \\det(\\mathbf{Q})$。\n4. 如果 $s  0$，将 $\\mathbf{Q}$ 的第一列乘以 $-1$ 以形成最终的旋转矩阵 $\\mathbf{R}$。否则，令 $\\mathbf{R} = \\mathbf{Q}$。\n\n### 3. 旋转不变性诊断统计量\n该诊断检验旨在验证在 $S^{d-1}$ 上采样的点集 $\\{\\mathbf{x}^{(i)}\\}_{i=1}^n$ 的旋转不变性。如果采样方法真正均匀，那么点集的统计特性在应用一个随机旋转 $\\mathbf{R} \\sim \\text{Haar}(SO(d))$ 后应该保持不变。\n\n我们通过测量落入 $m$ 个固定球帽中的点的数量来探测点的分布。一个球帽 $C_j$ 由一个中心方向 $\\mathbf{u}_j \\in S^{d-1}$ 和一个半角 $\\theta \\in [0, \\pi]$ 定义，即 $C_j = \\{\\mathbf{x} \\in S^{d-1} : \\mathbf{u}_j^\\top \\mathbf{x} \\ge \\cos\\theta\\}$。我们计算旋转前后的计数：\n- 旋转前球帽 $j$ 的计数：$c_{j}^{\\text{pre}} = \\sum_{i=1}^n \\mathbf{1}\\{\\mathbf{u}_j^\\top \\mathbf{x}^{(i)} \\ge \\cos\\theta\\}$\n- 旋转后球帽 $j$ 的计数：$c_{j}^{\\text{post}} = \\sum_{i=1}^n \\mathbf{1}\\{\\mathbf{u}_j^\\top (\\mathbf{R}\\mathbf{x}^{(i)}) \\ge \\cos\\theta\\}$\n\n对于每个球帽 $j$，我们有两个样本比例，$\\hat{p}_j^{\\text{pre}} = c_{j}^{\\text{pre}}/n$ 和 $\\hat{p}_j^{\\text{post}} = c_{j}^{\\text{post}}/n$。零假设 $H_0$ 是底层采样分布具有旋转不变性，这意味着一个点落入球帽 $C_j$ 的真实概率 $p_j$ 对于原始点集和旋转后点集是相同的。这是一个关于比例相等的双样本检验。\n\n诊断统计量 $T$ 的构建如下：\n1. 在 $H_0$ 下，公共比例 $p_j$ 的最佳估计是合并比例：$\\widehat{p}_j = (c_j^{\\text{pre}} + c_j^{\\text{post}}) / (2n)$。\n2. 两个样本比例之差 $\\hat{p}_j^{\\text{pre}} - \\hat{p}_j^{\\text{post}}$ 的方差使用合并比例进行估计。此差异的标准误由 $s_j = \\sqrt{\\frac{\\widehat{p}_j(1-\\widehat{p}_j)}{n} + \\frac{\\widehat{p}_j(1-\\widehat{p}_j)}{n}} = \\sqrt{2\\widehat{p}_j(1-\\widehat{p}_j)/n}$ 给出。\n3. 每个球帽的标准化差异，或称Z分数，为 $z_j = \\frac{|\\hat{p}_j^{\\text{pre}} - \\hat{p}_j^{\\text{post}}|}{s_j} = \\frac{|c_j^{\\text{pre}}/n - c_j^{\\text{post}}/n|}{s_j}$。如果 $s_j=0$（当 $\\widehat{p}_j$ 为 $0$ 或 $1$ 时发生），则分子也为 $0$，我们定义 $z_j = 0$。对于大样本 $n$，在 $H_0$ 下 $z_j$ 近似服从半正态分布。\n4. 为了将所有 $m$ 个球帽的结果汇总成一个单一数值，该诊断统计量定义为观测到的最大Z分数：$T = \\max_{1 \\le j \\le m} z_j$。一个大的 $T$ 值表明在至少一个测试的球帽方向上存在与旋转不变性的显著偏离，从而对采样方法的均匀性提出质疑。由于指定的采样方法在理论上是可靠的，我们预期 $T$ 会很小，与随机波动一致。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_diagnostic_case(d, n, m, theta, seed):\n    \"\"\"\n    Runs the rotational invariance diagnostic for a single test case.\n\n    Args:\n        d (int): Dimension of the space.\n        n (int): Number of points to sample on the sphere.\n        m (int): Number of spherical caps to use for the test.\n        theta (float): Half-angle of the spherical caps in radians.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        float: The computed diagnostic statistic T.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # Helper function to sample k points uniformly on the unit sphere S^(d-1)\n    def sample_sphere(k, dim, random_state):\n        z = random_state.standard_normal(size=(k, dim))\n        norm = np.linalg.norm(z, axis=1, keepdims=True)\n        # Avoid division by zero, though Pr(norm=0) is 0 for continuous dist.\n        norm[norm == 0] = 1.0\n        return z / norm\n\n    # 1. Sample n data points X on S^(d-1)\n    X = sample_sphere(n, d, rng)\n\n    # 2. Sample m cap directions U on S^(d-1)\n    U = sample_sphere(m, d, rng)\n\n    # 3. Sample a random rotation R from SO(d) via QR decomposition\n    A = rng.standard_normal(size=(d, d))\n    Q, _ = np.linalg.qr(A)\n    # Ensure determinant is +1 for SO(d)\n    if np.linalg.det(Q)  0:\n        Q[:, 0] *= -1\n    R = Q\n\n    # 4. Apply the rotation to the data points\n    # For row vectors x in X, the rotated vectors are x @ R.T\n    RX = X @ R.T\n\n    # 5. Compute the diagnostic statistic T\n    cos_theta = np.cos(theta)\n\n    # Vectorized computation of counts\n    # Dot products for pre-rotation points: X @ U.T gives an (n, m) matrix\n    dot_pre = X @ U.T\n    # Dot products for post-rotation points: RX @ U.T gives an (n, m) matrix\n    dot_post = RX @ U.T\n\n    # Counts for each cap (sum over points axis=0) -> vector of size m\n    c_pre_vec = np.sum(dot_pre >= cos_theta, axis=0)\n    c_post_vec = np.sum(dot_post >= cos_theta, axis=0)\n\n    # Pooled proportion estimate for each cap\n    p_hat_vec = (c_pre_vec + c_post_vec) / (2 * n)\n    \n    # Pooled standard error estimate for each cap\n    # The term inside sqrt can be negative due to float precision, so clip at 0.\n    s_vec_numerator = 2 * p_hat_vec * (1 - p_hat_vec) / n\n    s_vec = np.sqrt(np.maximum(0, s_vec_numerator))\n\n    # Difference in proportions for each cap\n    diff_vec = np.abs(c_pre_vec / n - c_post_vec / n)\n\n    # Normalized differences (z-scores)\n    z_vec = np.zeros_like(s_vec)\n    # Avoid division by zero where s_vec is 0\n    # If s_vec is 0, p_hat is 0 or 1, meaning c_pre and c_post were same (0 or n)\n    # so diff_vec is also 0. z_j=0 is correct in this case.\n    nonzero_s_mask = s_vec > 0\n    z_vec[nonzero_s_mask] = diff_vec[nonzero_s_mask] / s_vec[nonzero_s_mask]\n\n    # The final diagnostic is the maximum z-score\n    T = np.max(z_vec)\n    return T\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (d, n, m, theta)\n        (3, 10000, 12, 0.5),   # Case 1\n        (2, 15000, 16, 0.2),   # Case 2\n        (10, 12000, 24, 0.3),  # Case 3\n        (50, 8000, 40, 0.25),  # Case 4\n        (5, 300, 10, 0.4),     # Case 5\n    ]\n    \n    base_seed = 1729\n    results = []\n\n    for i, case in enumerate(test_cases):\n        d, n, m, theta = case\n        case_seed = base_seed + (i + 1)\n        # Using numpy 1.23.5, np.random.seed is legacy. Use default_rng.\n        # The behavior for a given seed is consistent.\n        T = run_diagnostic_case(d, n, m, theta, case_seed)\n        results.append(T)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}