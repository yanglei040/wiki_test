{
    "hands_on_practices": [
        {
            "introduction": "拒绝采样法的效率从根本上取决于提议封套函数 $M g(x)$ 对目标密度函数 $f(x)$ 的包裹紧密程度。一个更紧的封套会带来更高的接受率和更少的浪费提议。这个练习  提供了一个封套设计的基础实践，引导你为普遍存在的标准正态分布构建并优化一个分段指数封套。通过推导切点的最优位置，你将从第一性原理层面理解封套复杂性与采样效率之间的权衡，这也是像自适应拒绝采样（Adaptive Rejection Sampling）这类强大方法背后的核心概念。",
            "id": "3335755",
            "problem": "考虑一个定义在 $\\mathbb{R}$ 上的目标概率密度函数 $f(x)$，该函数是对数凹的，即 $\\log f(x)$ 是一个凹函数。在拒绝采样中，我们构造一个包络函数 $g(x)$，使得对所有 $x$ 都有 $g(x) \\geq f(x)$，从归一化的包络中抽取样本 $X$，并以概率 $f(X)/g(X)$ 接受该样本 $X$。平均接受率 $\\alpha$ 等于 $f$ 的积分与 $g$ 的积分之比。为对数凹目标函数构造高效包络的一种标准方法是，利用 $\\log f$ 的切线来构建一个分段线性的上包络 $u(x)$，然后取包络 $g(x) = \\exp(u(x))$。这就是自适应拒绝采样（Adaptive Rejection Sampling, ARS）背后的核心思想。\n\n您将使用拒绝采样的基本原理，对一个经过充分研究的特定对数凹目标函数和一类受限的包络，分析支撑点（即切线所在点）的数量和位置与最终接受率 $\\alpha$ 之间的权衡关系。\n\n设目标函数为标准正态密度 $f(x) = \\frac{1}{\\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{x^{2}}{2}\\right)$，该函数满足对数凹性。考虑通过在两个对称支撑点 $\\{-a, +a\\}$（其中 $a > 0$）处对 $\\log f(x)$ 取切线，来构造一个分段指数包络 $g(x)$。令 $l(x) = \\log f(x)$，并设 $u_{-a}(x)$ 和 $u_{+a}(x)$ 分别是 $l$ 在 $x = -a$ 和 $x = +a$ 处的切线。定义上包络 $u(x) = \\min\\{u_{-a}(x), u_{+a}(x)\\}$ 并设置 $g(x) = \\exp(u(x))$。由于 $l$ 是凹函数，因此 $u(x) \\geq l(x)$，从而 $g(x) \\geq f(x)$。\n\n从拒绝采样的基本事实出发——即平均接受率等于目标函数和包络函数积分之比——并且仅使用上述定义（不引入任何快捷公式），完成以下任务：\n\n1. 对于由两个对称支撑点 $\\{-a, +a\\}$ 定义的包络 $g$，推导出接受率 $\\alpha(a)$ 作为 $a$ 的函数的闭式表达式。\n2. 根据接受率即积分比率的原理，定义每个接受的样本所需的目标函数评估期望次数为 $J(a) = 1/\\alpha(a)$。这里做一个简化假设：与评估 $f(x)$ 相比，从分段指数包络中采样和确定活动分段的开销可以忽略不计；这突出了由包络紧密性驱动的核心权衡。\n3. 在这类双支撑点包络中，确定使 $J(a)$ 最小化的值 $a^{\\star} > 0$，以及相应的最优接受率 $\\alpha^{\\star} = \\alpha(a^{\\star})$。请以精确表达式的形式提供 $a^{\\star}$ 和 $\\alpha^{\\star}$。\n\n您的最终答案必须是一个包含 $a^{\\star}$ 和 $\\alpha^{\\star}$ 的单行矩阵。不需要进行数值四舍五入，最终表达式中也不应包含单位。根据您的推导，解释支撑点的位置如何影响 $\\alpha$ 以及评估成本 $J$，从而量化这种受限的两点设计中的权衡。并从概念上简要评论，对于通过切线包络构造的对数凹目标，增加支撑点数量通常如何影响 $\\alpha$ 和 $J$，以及一个挤压函数（squeeze function）如何在不改变 $\\alpha$ 的情况下进一步影响评估成本。",
            "solution": "首先验证问题，以确保其科学上合理、内容自洽且提法恰当。\n\n**第1步：提取已知条件**\n-   目标概率密度函数：$f(x) = \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{x^{2}}{2}\\right)$，定义于 $\\mathbb{R}$。\n-   性质：$f(x)$ 是对数凹函数。\n-   包络构造：包络 $g(x)$ 由 $l(x) = \\log f(x)$ 在两个对称支撑点 $\\{-a, +a\\}$（其中 $a > 0$）处的切线构成。\n-   函数定义：\n    -   $l(x) = \\log f(x)$。\n    -   $u_{-a}(x)$ 和 $u_{+a}(x)$ 是 $l(x)$ 在 $x=-a$ 和 $x=+a$ 处的切线。\n    -   $u(x) = \\min\\{u_{-a}(x), u_{+a}(x)\\}$。\n    -   $g(x) = \\exp(u(x))$。\n-   核心原理：平均接受率为 $\\alpha = \\frac{\\int_{-\\infty}^{\\infty} f(x) \\,dx}{\\int_{-\\infty}^{\\infty} g(x) \\,dx}$。\n-   成本函数：每个接受的样本所需的目标函数评估期望次数为 $J(a) = 1/\\alpha(a)$。\n-   目标：\n    1.  推导接受率 $\\alpha(a)$ 的闭式表达式。\n    2.  定义 $J(a)$。\n    3.  找到使 $J(a)$ 最小化的最优值 $a^{\\star} > 0$ 以及相应的最优接受率 $\\alpha^{\\star} = \\alpha(a^{\\star})$。\n\n**第2步：使用提取的已知条件进行验证**\n问题有效。这是一个提法恰当的数学练习，其理论基础牢固地植根于拒绝采样和自适应拒绝采样（ARS）理论。目标函数是标准正态密度，其对数凹性是一个已知性质。从切线构造包络是处理对数凹密度的标准技术。所有术语定义清晰，目标明确，不存在科学或逻辑上的缺陷。关于成本 $J(a)$ 的简化假设被明确陈述，旨在分离出与包络紧密性相关的主要权衡。\n\n**第3步：结论与行动**\n问题有效，将提供完整解答。\n\n**解题推导**\n\n解题过程首先构造包络函数 $g(x)$，然后计算其积分以求得接受率 $\\alpha(a)$，最后对该率关于支撑点参数 $a$ 进行优化。\n\n首先，我们定义目标密度的对数 $l(x)$：\n$$l(x) = \\ln(f(x)) = \\ln\\left(\\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{x^2}{2}\\right)\\right) = -\\frac{1}{2}\\ln(2\\pi) - \\frac{x^2}{2}$$\n需要求导数 $l'(x)$ 来定义切线：\n$$l'(x) = -x$$\n在点 $x_0$ 处，$l(x)$ 的切线方程为 $y(x) = l(x_0) + l'(x_0)(x - x_0)$。我们在支撑点 $x_0 = a$ 和 $x_0 = -a$ 处求两条切线。\n\n对于支撑点 $x_0 = a$：\n$l(a) = -\\frac{1}{2}\\ln(2\\pi) - \\frac{a^2}{2}$\n$l'(a) = -a$\n切线 $u_{+a}(x)$ 是：\n$$u_{+a}(x) = \\left(-\\frac{1}{2}\\ln(2\\pi) - \\frac{a^2}{2}\\right) - a(x-a) = -\\frac{1}{2}\\ln(2\\pi) + \\frac{a^2}{2} - ax$$\n\n对于支撑点 $x_0 = -a$：\n$l(-a) = -\\frac{1}{2}\\ln(2\\pi) - \\frac{a^2}{2}$\n$l'(-a) = -(-a) = a$\n切线 $u_{-a}(x)$ 是：\n$$u_{-a}(x) = \\left(-\\frac{1}{2}\\ln(2\\pi) - \\frac{a^2}{2}\\right) + a(x-(-a)) = -\\frac{1}{2}\\ln(2\\pi) + \\frac{a^2}{2} + ax$$\n\n上包络 $u(x)$ 是这两条线的最小值：\n$$u(x) = \\min\\{u_{-a}(x), u_{+a}(x)\\} = \\min\\left\\{-\\frac{1}{2}\\ln(2\\pi) + \\frac{a^2}{2} + ax, -\\frac{1}{2}\\ln(2\\pi) + \\frac{a^2}{2} - ax\\right\\}$$\n这可以简化为：\n$$u(x) = -\\frac{1}{2}\\ln(2\\pi) + \\frac{a^2}{2} - a|x|$$\n两条切线在 $u_{-a}(x) = u_{+a}(x)$ 时相交，这意味着 $ax = -ax$，即 $2ax=0$。由于 $a>0$，相交点在 $x=0$ 处。对于 $x  0$，$u_{-a}(x)  u_{+a}(x)$；对于 $x > 0$，$u_{+a}(x)  u_{-a}(x)$。\n\n包络函数 $g(x)$ 是上包络 $u(x)$ 的指数：\n$$g(x) = \\exp(u(x)) = \\exp\\left(-\\frac{1}{2}\\ln(2\\pi) + \\frac{a^2}{2} - a|x|\\right) = \\frac{1}{\\sqrt{2\\pi}}\\exp\\left(\\frac{a^2}{2}\\right)\\exp(-a|x|)$$\n\n平均接受率 $\\alpha(a)$ 由 $f(x)$ 和 $g(x)$ 的积分之比给出。根据定义，目标密度 $f(x)$ 在 $\\mathbb{R}$ 上的积分为 $1$：\n$$\\int_{-\\infty}^{\\infty} f(x) \\,dx = 1$$\n接下来，我们计算包络函数 $g(x)$ 的积分：\n$$\\int_{-\\infty}^{\\infty} g(x) \\,dx = \\frac{1}{\\sqrt{2\\pi}}\\exp\\left(\\frac{a^2}{2}\\right) \\int_{-\\infty}^{\\infty} \\exp(-a|x|) \\,dx$$\n可以利用对称性计算 $\\exp(-a|x|)$ 的积分：\n$$\\int_{-\\infty}^{\\infty} \\exp(-a|x|) \\,dx = 2 \\int_{0}^{\\infty} \\exp(-ax) \\,dx = 2 \\left[-\\frac{1}{a}\\exp(-ax)\\right]_{0}^{\\infty} = 2\\left(0 - \\left(-\\frac{1}{a}\\right)\\right) = \\frac{2}{a}$$\n将此结果代回，包络的积分为：\n$$I_g(a) = \\int_{-\\infty}^{\\infty} g(x) \\,dx = \\frac{1}{\\sqrt{2\\pi}}\\exp\\left(\\frac{a^2}{2}\\right) \\frac{2}{a} = \\frac{2}{a\\sqrt{2\\pi}}\\exp\\left(\\frac{a^2}{2}\\right)$$\n\n现在我们可以写出接受率 $\\alpha(a)$ 的表达式：\n$$\\alpha(a) = \\frac{\\int f(x) \\,dx}{\\int g(x) \\,dx} = \\frac{1}{I_g(a)} = \\frac{a\\sqrt{2\\pi}}{2\\exp\\left(\\frac{a^2}{2}\\right)} = \\frac{a\\sqrt{2\\pi}}{2} \\exp\\left(-\\frac{a^2}{2}\\right)$$\n这就是接受率作为 $a$ 的函数的闭式表达式。成本函数为 $J(a) = 1/\\alpha(a)$。\n\n为了找到最优的支撑点位置 $a^{\\star}$，我们必须最小化 $J(a)$，这等价于在 $a > 0$ 的范围内最大化 $\\alpha(a)$。我们计算 $\\alpha(a)$ 关于 $a$ 的导数，并令其为零。\n$$\\frac{d\\alpha}{da} = \\frac{d}{da}\\left[\\frac{\\sqrt{2\\pi}}{2} \\left(a \\exp\\left(-\\frac{a^2}{2}\\right)\\right)\\right]$$\n使用乘法法则：\n$$\\frac{d\\alpha}{da} = \\frac{\\sqrt{2\\pi}}{2} \\left[1 \\cdot \\exp\\left(-\\frac{a^2}{2}\\right) + a \\cdot \\exp\\left(-\\frac{a^2}{2}\\right) \\cdot (-a)\\right] = \\frac{\\sqrt{2\\pi}}{2} (1-a^2) \\exp\\left(-\\frac{a^2}{2}\\right)$$\n令导数为零：\n$$\\frac{d\\alpha}{da} = 0 \\implies (1-a^2) = 0$$\n由于我们要求 $a>0$，唯一的临界点是 $a=1$。为了确认这是一个最大值点，我们检查一阶导数的符号。当 $0  a  1$ 时，$1-a^2 > 0$ 且 $\\frac{d\\alpha}{da} > 0$，因此 $\\alpha(a)$ 是递增的。当 $a > 1$ 时，$1-a^2  0$ 且 $\\frac{d\\alpha}{da}  0$，因此 $\\alpha(a)$ 是递减的。所以，$a=1$ 使得 $\\alpha(a)$ 在 $a>0$ 的范围内取得全局最大值。\n\n因此，最优的支撑点参数是：\n$$a^{\\star} = 1$$\n将 $a^{\\star}=1$ 代入 $\\alpha(a)$ 的表达式，得到相应的最优接受率 $\\alpha^{\\star}$：\n$$\\alpha^{\\star} = \\alpha(1) = \\frac{1 \\cdot \\sqrt{2\\pi}}{2} \\exp\\left(-\\frac{1^2}{2}\\right) = \\frac{\\sqrt{2\\pi}}{2} \\exp\\left(-\\frac{1}{2}\\right) = \\frac{\\sqrt{2\\pi}}{2\\sqrt{e}} = \\sqrt{\\frac{2\\pi}{4e}} = \\sqrt{\\frac{\\pi}{2e}}$$\n\n**权衡分析与扩展**\n\n参数 $a$ 控制支撑点的位置。表达式 $\\alpha(a) = \\frac{a\\sqrt{2\\pi}}{2} \\exp\\left(-\\frac{a^2}{2}\\right)$ 量化了这种权衡。如果 $a$ 非常小（接近 $0$），支撑点会靠近众数。切线几乎是水平的，形成一个松散的包络，其面积很大，导致接受率很低（当 $a \\to 0$ 时 $\\alpha(a) \\to 0$）。相反，如果 $a$ 非常大，支撑点会远在分布的尾部。切线非常陡峭，在尾部拟合得很好，但在 $x=0$ 处形成一个极高且窄的峰。包络的面积主要由这个峰贡献，再次变得很大，接受率也趋近于零（当 $a \\to \\infty$ 时 $\\alpha(a) \\to 0$）。最优值 $a^{\\star}=1$ 代表了一种最佳平衡，将支撑点放置在距离均值一个标准差的位置，这最小化了包络函数 $g(x)$ 下的总面积，从而最大化了接受率 $\\alpha$。这也最小化了为获得一个接受样本所需的期望抽样次数 $J(a)$。\n\n增加支撑点的数量可以得到一个更精细的分段线性上包络 $u(x)$。由于新的上包络是更多切线的最小值，它必定位于两点包络的下方或与之重合：对所有 $x$ 都有 $u_{\\text{new}}(x) \\leq u(x)$。这会产生一个更紧的包络 $g_{\\text{new}}(x) \\leq g(x)$，一个更小的包络积分 $\\int g_{\\text{new}}(x)dx$，从而得到更高的接受率 $\\alpha$。这降低了成本 $J$。这就是自适应拒绝采样的原理，通过迭代增加点来改进包络。\n\n挤压函数（squeeze function）$s(x)$ 是一个对所有 $x$ 都满足 $0 \\le s(x) \\le f(x)$ 的函数。在拒绝采样器中，可以执行一个廉价的预测试：如果一个均匀分布的随机数 $U$ 满足 $U \\cdot g(X) \\le s(X)$，那么样本 $X$ 就可以在不评估 $f(X)$ 的情况下被接受。这是可行的，因为 $s(X) \\le f(X)$ 保证了 $U \\cdot g(X) \\le f(X)$ 也成立。总接受率 $\\alpha$ 保持不变，因为它最终由 $f(x)$ 和 $g(x)$ 下的面积之比决定。然而，挤压函数减少了每个被接受样本*对目标函数 $f(x)$ 的平均评估次数*。通过让一些样本“免费”被接受，一个高效的挤压函数（其积分接近 $f(x)$ 的积分）可以显著降低总计算成本，特别是当 $f(x)$ 的计算成本很高时，而不会改变基本的接受概率 $\\alpha$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 1  \\sqrt{\\frac{\\pi}{2e}} \\end{pmatrix} } $$"
        },
        {
            "introduction": "从理论原理到实际实现的过程揭示了那些微妙但至关重要的挑战。拒绝采样法的核心条件 $f(x) \\le M g(x)$ 是一个精确的数学不等式，但在真实的计算机中，它可能因为浮点运算的舍入误差而被打破，从而可能使你的整个模拟失效。这个练习  挑战你像数值分析师一样思考，要求你制定一个能解释这些误差的稳健验证测试，并设计一种策略来安全地“膨胀”封套常数 $M$，同时将对效率的影响降至最低。",
            "id": "3335791",
            "problem": "考虑经典的拒绝采样设置，用于从一个目标分布中进行模拟。该目标分布在可测域 $\\mathcal{X}$ 上的未归一化密度为 $f(x)$，使用提议密度 $g(x)$ 和一个包络常数 $M > 0$，使得对所有 $x \\in \\mathcal{X}$，精确包络条件 $f(x) \\le M g(x)$ 都成立。当 $f$ 是概率密度且 $g$ 是概率密度时，每次抽样的接受概率为 $1/M$。在符合电子电气工程师协会 754 (IEEE 754) 标准的浮点运算中，如果天真地实现，数值舍入误差可能导致对 $f(x) \\le M g(x)$ 的直接测试不可靠。因此，一个鲁棒的数值验证必须考虑到 $f$ 和 $g$ 求值过程中的舍入误差，以避免破坏包络并损害正确性。\n\n假设以下基本前提：\n- 在 IEEE 754 中，对于实数 $a$ 和 $b$ 上的任何基本算术运算 $\\circ \\in \\{+, -, \\times, \\div\\}$，浮点结果 $\\operatorname{fl}(a \\circ b)$ 满足 $\\operatorname{fl}(a \\circ b) = (a \\circ b)(1 + \\delta)$，其中 $|\\delta| \\le u$，$u$ 是单位舍入（机器精度）。当为初等函数实现后向误差保证时，情况类似。\n- 对于 $f$ 和 $g$ 的复合求值，假设先验分析提供了依赖于数据的相对误差界 $\\varepsilon_f(x)$ 和 $\\varepsilon_g(x)$，使得计算值 $\\hat{f}(x)$ 和 $\\hat{g}(x)$ 满足 $\\hat{f}(x) = f(x)(1 + \\delta_f(x))$ 和 $\\hat{g}(x) = g(x)(1 + \\delta_g(x))$，其中对所有 $x \\in \\mathcal{X}$，有 $|\\delta_f(x)| \\le \\varepsilon_f(x)$ 和 $|\\delta_g(x)| \\le \\varepsilon_g(x)$。这些界限源于经过充分检验的后向误差分析，该分析结合了用于评估 $f$ 和 $g$ 的所有运算中的单位舍入 $u$。\n- 挤压函数 $s(x)$ 是任何满足对所有 $x \\in \\mathcal{X}$ 都有 $0 \\le s(x) \\le f(x)$ 的可计算函数。如果 $U \\sim \\mathrm{Uniform}(0, 1)$ 且 $X \\sim g$，那么只要 $U \\le s(X)/(M g(X))$，就可以在不计算 $f(X)$ 的情况下接受该点，这降低了计算成本，并可以减轻因保守包络造成的效率损失。\n\n您的实现必须在运行时仅使用 $\\hat{f}(x)$、$\\hat{g}(x)$ 以及误差界 $\\varepsilon_f(x)$ 和 $\\varepsilon_g(x)$ 来鲁棒地验证条件 $f(x) \\le M g(x)$。此外，您必须提出一种安全的方法，将 $M$ 膨胀为一个新的包络常数，以防范舍入误差，同时最小化接受率的下降。\n\n在所述假设下，以下哪个选项正确地构建了一个鲁棒的浮点验证测试和一个能最小化效率损失的安全膨胀策略？\n\nA. 使用误差界为 $f(x)$ 构建最坏情况下的上界，为 $M g(x)$ 构建最坏情况下的下界。通过检查以下不等式来验证包络：\n$$\\frac{\\hat{f}(x)}{1 - \\varepsilon_f(x)} \\;\\le\\; M \\,\\frac{\\hat{g}(x)}{1 + \\varepsilon_g(x)}.$$\n如果不希望进行每次求值的验证，则将包络膨胀为一个依赖于数据的局部常数\n$$M'(x) \\;=\\; M \\,\\frac{1 + \\varepsilon_f(x)}{1 - \\varepsilon_g(x)},$$\n或保守地膨胀为一个全局常数\n$$M' \\;=\\; M \\,\\frac{1 + \\varepsilon_f^\\star}{1 - \\varepsilon_g^\\star},$$\n其中 $\\varepsilon_f^\\star \\ge \\sup_{x \\in \\mathcal{X}} \\varepsilon_f(x)$ 和 $\\varepsilon_g^\\star \\ge \\sup_{x \\in \\mathcal{X}} \\varepsilon_g(x)$。这种膨胀是安全的，因为它补偿了对 $f$ 值的最坏情况向上影响和对 $g$ 值的最坏情况向下影响，并且其对接受率的影响被限制在一个乘法因子 $\\frac{1 + \\varepsilon_f^\\star}{1 - \\varepsilon_g^\\star}$。为进一步减少效率损失，引入一个通过向下舍入计算的挤压函数 $s(x)$，使得 $\\hat{s}(x) \\le s(x)$，从而在 $U \\le \\hat{s}(x)/(M' \\hat{g}(x))$ 时无需计算 $f(x)$ 即可接受样本。\n\nB. 通过检查以下不等式来进行验证：\n$$\\hat{f}(x) \\;\\le\\; M \\,\\hat{g}(x)\\,\\bigl(1 + \\varepsilon_f(x) + \\varepsilon_g(x)\\bigr),$$\n并使用以下方式进行膨胀：\n$$M' \\;=\\; M \\,\\bigl(1 + \\varepsilon_f^\\star + \\varepsilon_g^\\star\\bigr).$$\n这种相对误差的加性聚合是充分的，因为误差很小，并且它能最小化接受率的降低。\n\nC. 使用加性容差。通过以下不等式进行验证：\n$$\\hat{f}(x) \\;\\le\\; M \\,\\hat{g}(x) \\;+\\; \\tau(x), \\quad \\text{其中} \\quad \\tau(x) \\;=\\; u \\,\\max\\{\\hat{f}(x),\\,M \\hat{g}(x)\\}.$$\n通过以下方式膨胀 $M$：\n$$M' \\;=\\; M \\;+\\; \\frac{\\tau^\\star}{\\inf_{x \\in \\mathcal{X}} g(x)}, \\quad \\tau^\\star \\;\\ge\\; \\sup_{x \\in \\mathcal{X}} \\tau(x),$$\n以在全局范围内恢复包络。\n\nD. 使用定向舍入，在向正无穷舍入模式下计算 $\\hat{f}^\\uparrow(x)$，在向负无穷舍入模式下计算 $\\hat{g}^\\downarrow(x)$，然后通过以下不等式进行验证：\n$$\\hat{f}^\\uparrow(x) \\;\\le\\; M \\,\\hat{g}^\\downarrow(x).$$\n将 $M$ 膨胀为\n$$M' \\;=\\; M \\,(1 + u)^k,$$\n其中 $k$ 是用于计算 $g$ 的浮点运算次数，这可以安全地覆盖舍入误差，同时保持接受率几乎不变。",
            "solution": "该问题是有效的，可以通过将浮点误差分析的原理应用于控制拒绝采样的不等式来解决。\n\n### I. 鲁棒验证测试的推导\n\n拒绝采样的核心理论条件是对于所有 $x \\in \\mathcal{X}$，有 $f(x) \\le M g(x)$。我们已知计算值 $\\hat{f}(x)$ 和 $\\hat{g}(x)$，以及已知的相对误差界 $\\varepsilon_f(x)$ 和 $\\varepsilon_g(x)$。它们之间的关系是：\n$$\n\\hat{f}(x) = f(x)(1 + \\delta_f(x)), \\quad |\\delta_f(x)| \\le \\varepsilon_f(x) \\\\\n\\hat{g}(x) = g(x)(1 + \\delta_g(x)), \\quad |\\delta_g(x)| \\le \\varepsilon_g(x)\n$$\n由此，我们可以用计算值来表示真实值 $f(x)$ 和 $g(x)$：\n$$\nf(x) = \\frac{\\hat{f}(x)}{1 + \\delta_f(x)} \\quad \\text{和} \\quad g(x) = \\frac{\\hat{g}(x)}{1 + \\delta_g(x)}\n$$\n假设 $\\varepsilon_f(x)  1$ 和 $\\varepsilon_g(x)  1$（这是有意义计算的必要条件），我们可以为真实值建立严格的区间：\n$$\n\\frac{\\hat{f}(x)}{1 + \\varepsilon_f(x)} \\le f(x) \\le \\frac{\\hat{f}(x)}{1 - \\varepsilon_f(x)} \\\\\n\\frac{\\hat{g}(x)}{1 + \\varepsilon_g(x)} \\le g(x) \\le \\frac{\\hat{g}(x)}{1 - \\varepsilon_g(x)}\n$$\n为了鲁棒地验证 $f(x) \\le M g(x)$ 成立，我们必须证明 $f(x)$ 的最坏情况值不大于 $M g(x)$ 的最坏情况值。最坏情况对应于 $f(x)$ 的上界和 $M g(x)$ 的下界。\n$$\nf_{\\text{upper}}(x) = \\frac{\\hat{f}(x)}{1 - \\varepsilon_f(x)} \\\\\n(M g)_{\\text{lower}}(x) = M g_{\\text{lower}}(x) = M \\frac{\\hat{g}(x)}{1 + \\varepsilon_g(x)}\n$$\n因此，为保证条件 $f(x) \\le M g(x)$ 成立，必须为真的鲁棒验证测试是：\n$$\nf_{\\text{upper}}(x) \\le (M g)_{\\text{lower}}(x) \\implies \\frac{\\hat{f}(x)}{1 - \\varepsilon_f(x)} \\le M \\frac{\\hat{g}(x)}{1 + \\varepsilon_g(x)}\n$$\n\n### II. 安全膨胀策略的推导\n\n如果我们不希望对每次求值都执行验证测试，我们可以改用一个能保证正确性的膨胀常数 $M' > M$。采样过程的正确性依赖于实现的接受概率 $\\hat{p}_{acc}(x) = \\frac{\\hat{f}(x)}{M' \\hat{g}(x)}$，使其不大于按 $M/M'$ 缩放的真实接受概率，即 $\\frac{f(x)}{M' g(x)}$。最终，为防止错误接受，我们必须确保任何被浮点算法接受的点也会被精确算法接受。实现的接受条件是对于抽取的 $X \\sim g$ 和 $U \\sim \\mathrm{Uniform}(0,1)$，有 $U \\le \\frac{\\hat{f}(X)}{M' \\hat{g}(X)}$。真实的条件是 $U \\le \\frac{f(X)}{M g(X)}$。\n为保证正确性，实现的接受比率必须是真实比率的一个下界：\n$$\n\\frac{\\hat{f}(x)}{M' \\hat{g}(x)} \\le \\frac{f(x)}{M g(x)}\n$$\n代入关系式 $\\hat{f}(x) = f(x)(1+\\delta_f(x))$ 和 $\\hat{g}(x) = g(x)(1+\\delta_g(x))$：\n$$\n\\frac{f(x)(1+\\delta_f(x))}{M' g(x)(1+\\delta_g(x))} \\le \\frac{f(x)}{M g(x)}\n$$\n$$\n\\frac{1+\\delta_f(x)}{M'(1+\\delta_g(x))} \\le \\frac{1}{M} \\implies M(1+\\delta_f(x)) \\le M'(1+\\delta_g(x))\n$$\n为确保此不等式对所有可能的误差都成立，我们必须找到一个在最坏情况下满足该不等式的 $M'$。项 $\\frac{1+\\delta_f(x)}{1+\\delta_g(x)}$ 在分子 $1+\\delta_f(x)$ 取最大值且分母 $1+\\delta_g(x)$ 取最小值时达到最大值：\n$$\n\\max(\\text{numerator}) = 1 + \\varepsilon_f(x) \\\\\n\\min(\\text{denominator}) = 1 - \\varepsilon_g(x)\n$$\n所以，我们必须选择 $M'$ 使得：\n$$\nM' \\ge M \\frac{1+\\varepsilon_f(x)}{1-\\varepsilon_g(x)}\n$$\n为了最小化对接受率（即 $1/M'$）的影响，我们应选择最小可能的 $M'$。这给出了一个局部的膨胀策略：\n$$\nM'(x) = M \\frac{1+\\varepsilon_f(x)}{1-\\varepsilon_g(x)}\n$$\n对于一个全局常数 $M'$，我们必须取其在所有 $x \\in \\mathcal{X}$ 上的上确界：\n$$\nM' = \\sup_{x \\in \\mathcal{X}} \\left( M \\frac{1+\\varepsilon_f(x)}{1-\\varepsilon_g(x)} \\right) = M \\sup_{x \\in \\mathcal{X}} \\left( \\frac{1+\\varepsilon_f(x)}{1-\\varepsilon_g(x)} \\right)\n$$\n使用保守的全局界 $\\varepsilon_f^\\star \\ge \\sup_x \\varepsilon_f(x)$ 和 $\\varepsilon_g^\\star \\ge \\sup_x \\varepsilon_g(x)$，一个安全的全局常数是：\n$$\nM' = M \\frac{1+\\varepsilon_f^\\star}{1-\\varepsilon_g^\\star}\n$$\n\n### III. 逐项分析\n\n*   **A.** 此选项提出了验证测试 $\\frac{\\hat{f}(x)}{1 - \\varepsilon_f(x)} \\le M \\frac{\\hat{g}(x)}{1 + \\varepsilon_g(x)}$ 和膨胀策略 $M' = M \\frac{1 + \\varepsilon_f^\\star}{1 - \\varepsilon_g^\\star}$。这些与我们的推导完全吻合。它正确地指出对接受率的影响是一个乘法因子。它还正确地说明，对于一个安全的挤压测试，应使用一个保证为 $s(x)$ 下界的计算值 $\\hat{s}(x)$（例如，通过向下舍入），并与膨胀后的包络 $M'\\hat{g}(x)$ 进行比较。此选项的每个部分都与严格的数值分析一致。**正确**。\n\n*   **B.** 此选项提出了一种基于加性误差聚合的验证测试和膨胀策略，例如 $M' = M (1 + \\varepsilon_f^\\star + \\varepsilon_g^\\star)$。这来自一阶近似：$\\frac{1+\\varepsilon_f}{1-\\varepsilon_g} \\approx (1+\\varepsilon_f)(1+\\varepsilon_g) \\approx 1+\\varepsilon_f+\\varepsilon_g$。这不是一个严格的界。“安全”和“鲁棒”的验证需要严格的不等式，而不是近似。高阶项被忽略了，这可能导致一个不安全的、过小的包络常数 $M'$。此外，所提出的验证测试也是基于一个错误的近似。**不正确**。\n\n*   **C.** 此选项引入了一个加性容差 $\\tau(x)$，它不是从给定的相对误差界 $\\varepsilon_f(x)$ 和 $\\varepsilon_g(x)$ 推导出来的。$\\tau(x) = u \\max\\{\\dots\\}$ 的形式是启发式的，并且只考虑了单个操作的误差，而不是复合函数 $f$ 和 $g$ 的误差。加性膨胀策略 $M' = M + \\tau^\\star/\\inf g(x)$ 在量纲上不一致，并且如果 $\\inf g(x)$ 接近于零，可能导致病态的大幅膨胀。该方法与问题的前提不一致。**不正确**。\n\n*   **D.** 此选项建议使用定向舍入，即计算 $f(x)$ 的一个上界 $\\hat{f}^\\uparrow(x)$ 和 $g(x)$ 的一个下界 $\\hat{g}^\\downarrow(x)$。测试 $\\hat{f}^\\uparrow(x) \\le M \\hat{g}^\\downarrow(x)$ 是鲁棒验证的有效方法。然而，问题陈述的前提是可获得具有后验误差界 $\\varepsilon_f, \\varepsilon_g$ 的计算值 $\\hat{f}(x)$ 和 $\\hat{g}(x)$，这意味着使用的是标准（例如，向最近值舍入）算术，而不是特殊的定向舍入模式。因此，此选项提出的是一种不同的实现方法，而不是基于给定工具的解决方案。此外，膨胀策略 $M' = M(1+u)^k$ 是有缺陷的，因为它只考虑了 $g$ 中的前向误差传播，而完全忽略了 $f$ 中的误差。**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在大规模并行计算时代，采样效率不仅仅关乎接受率，更关乎原始的计算吞吐量。这个练习  将重点转移到高性能计算，特别是为 GPU 架构优化拒绝采样。你将学习到如何设计压缩函数和封套函数以直接影响“线程束分化”（warp divergence）——这是 SIMD 执行模型中的一个主要性能瓶颈——并建立一个模型来量化边界紧密程度与最终并行效率之间的权衡。",
            "id": "3335770",
            "problem": "您的任务是设计并分析一种带有提议分布选择、包络和挤压函数的拒绝采样方法，使其适用于图形处理器（GPU）的单指令多数据流（SIMD）执行。\n\n具体设定如下。在 $[0,1]$ 上的目标概率密度函数 $f_{\\alpha}(x)$ 由 Beta 分布族给出，形式为 $f_{\\alpha}(x) = \\alpha x^{\\alpha - 1}$，参数 $\\alpha \\ge 1$。提议分布 $g(x)$ 选择为 $[0,1]$ 上的均匀密度。设 $M$ 是一个有限常数，满足对于所有 $x \\in [0,1]$ 都有 $f_{\\alpha}(x) \\le M g(x)$。考虑以下形式的拒绝采样：采样 $x \\sim g$，采样 $u \\sim \\mathrm{Uniform}(0,1)$，如果 $u \\le f_{\\alpha}(x)/(M g(x))$ 则接受 $x$，否则拒绝。\n\n为了降低计算成本并对齐各线程的分支决策，为 $f_{\\alpha}(x)$ 定义一个下界挤压函数 $s(x)$ 和一个上界包络函数 $e(x)$，使得对所有 $x \\in [0,1]$ 均有 $s(x) \\le f_{\\alpha}(x) \\le e(x)$。然后实现以下在加速拒绝采样中标准的分支结构：\n- 如果 $u \\le s(x)/(M g(x))$，则接受 $x$，无需计算 $f_{\\alpha}(x)$。\n- 否则，如果 $u  e(x)/(M g(x))$，则拒绝 $x$，无需计算 $f_{\\alpha}(x)$。\n- 否则，计算 $f_{\\alpha}(x)$，若 $u \\le f_{\\alpha}(x)/(M g(x))$ 则接受 $x$。\n\n设计 $s(x)$ 和 $e(x)$，通过对定义域进行量化来对齐线程间的分支决策并减少分歧。具体来说，将 $[0,1]$ 划分成 $K$ 个等宽的区间 $B_k = [\\frac{k-1}{K}, \\frac{k}{K}]$（其中 $k \\in \\{1,2,\\dots,K\\}$），并定义 $s(x)$ 和 $e(x)$ 在每个区间上为分段常数，使用 $f_{\\alpha}(x)$ 在各区间上的极值作为挤压函数和包络函数。也就是说，对于 $x \\in B_k$，令 $s(x)$ 等于 $f_{\\alpha}(x)$ 在 $B_k$ 上的最小值，令 $e(x)$ 等于 $f_{\\alpha}(x)$ 在 $B_k$ 上的最大值。在 $g(x)$ 是 $[0,1]$ 上的均匀分布的情况下，这种构造产生的分支概率仅依赖于区间端点和 $\\alpha$。\n\n定义一个大小为 $W$ 的线程束（warp），其中的线程以单指令多数据流（SIMD）的方式锁步执行。设执行每个分支的单线程成本分别为：提早接受分支为 $\\tau_a$，提早拒绝分支为 $\\tau_r$，以及计算 $f_{\\alpha}(x)$ 的中间分支为 $\\tau_m$。各线程独立地抽取其 $(x,u)$ 对。将 SIMD 效率定义为“单线程的期望工作量”与“线程束时间的期望工作量”之比，其中线程束时间会累加线程束中至少有一个线程执行的每个分支所贡献的成本。效率应为一个在 $[0,1]$ 内的数值，并且必须从线程的独立性、拒绝采样的定义以及包络和挤压函数的定义等第一性原理出发进行推导。\n\n您的任务是：\n- 从上述形式化定义出发，在均匀提议分布 $g(x)$ 和分段常数 $s(x)$、$e(x)$ 的构造下，推导出以 $\\alpha$ 和 $K$ 表示的提早接受概率、提早拒绝概率和中间区域概率的表达式。\n- 在线程独立和所述分支结构的条件下，推导出期望 SIMD 效率关于 $\\alpha$、 $K$、 $W$、 $\\tau_a$、 $\\tau_r$ 和 $\\tau_m$ 的解析表达式。推导过程必须从核心定义开始，不得假定任何预先指定的简化公式。\n- 实现一个完整、可运行的程序，用于计算指定测试用例的 SIMD 效率。该程序必须只执行确定性计算，不得使用任何随机性。\n\n使用以下测试套件，每个用例指定为 $(\\alpha, K, W, \\tau_a, \\tau_r, \\tau_m)$：\n- 用例 1：$(1, 64, 32, 1.0, 1.0, 8.0)$，目标分布为均匀分布的边界情况。\n- 用例 2：$(2, 32, 32, 1.0, 1.0, 8.0)$，中等形状和中等区间数量。\n- 用例 3：$(64, 32, 32, 1.0, 1.0, 8.0)$，目标分布急剧增加且区间数量中等。\n- 用例 4：$(4, 1, 32, 1.0, 1.0, 8.0)$，只有一个区间的边缘情况。\n- 用例 5：$(4, 64, 64, 1.0, 1.0, 8.0)$，更大的线程束大小及与之对齐的区间数量。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的浮点数列表，这些浮点数是按上述用例顺序排列的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$）。本问题不涉及任何物理单位或角度单位；所有输出均为无量纲的浮点数。",
            "solution": "本问题要求推导并计算一种加速拒绝采样算法的单指令多数据流（SIMD）效率。推导过程必须从第一性原理出发。\n\n首先，我们对拒绝采样算法的各组成部分进行形式化。\n目标概率密度函数（PDF）来自 Beta 分布族，由 $f_{\\alpha}(x) = \\alpha x^{\\alpha - 1}$ 给出，其中 $x \\in [0,1]$，参数 $\\alpha \\ge 1$。\n提议 PDF 是 $[0,1]$ 上的均匀密度，$g(x) = 1$。\n拒绝采样方法要求存在一个常数 $M$，使得对于所有 $x \\in [0,1]$ 都有 $f_{\\alpha}(x) \\le M g(x)$。给定 $g(x)=1$，该不等式为 $f_{\\alpha}(x) \\le M$。为找到最小的 $M$，我们求 $f_{\\alpha}(x)$ 的最大值。其导数为 $f'_{\\alpha}(x) = \\alpha(\\alpha-1)x^{\\alpha-2}$。由于 $\\alpha \\ge 1$，对于 $x \\in [0,1]$，有 $f'_{\\alpha}(x) \\ge 0$，这意味着 $f_{\\alpha}(x)$ 是一个非递减函数。它在 $[0,1]$ 上的最大值出现在 $x=1$ 处，此时 $f_{\\alpha}(1) = \\alpha(1)^{\\alpha-1} = \\alpha$。我们选择最优常数 $M = \\alpha$。\n核心拒绝条件是 $u \\le \\frac{f_{\\alpha}(x)}{M g(x)}$，其中 $u \\sim \\mathrm{Uniform}(0,1)$。代入我们的函数，该条件变为 $u \\le \\frac{\\alpha x^{\\alpha-1}}{\\alpha \\cdot 1} = x^{\\alpha-1}$。\n\n接下来，我们定义挤压函数 $s(x)$ 和包络函数 $e(x)$。定义域 $[0,1]$ 被划分为 $K$ 个等宽的区间，$B_k = [\\frac{k-1}{K}, \\frac{k}{K}]$，其中 $k \\in \\{1, 2, \\dots, K\\}$。对于任何 $x \\in B_k$，$s(x)$ 和 $e(x)$ 分别定义为 $f_{\\alpha}(x)$ 在 $B_k$ 上的最小值和最大值。由于 $f_{\\alpha}(x)$ 是非递减的，这些极值出现在区间的端点处：\n对于 $x \\in B_k$：\n$s(x) = \\min_{z \\in B_k} f_{\\alpha}(z) = f_{\\alpha}\\left(\\frac{k-1}{K}\\right) = \\alpha \\left(\\frac{k-1}{K}\\right)^{\\alpha-1}$\n$e(x) = \\max_{z \\in B_k} f_{\\alpha}(z) = f_{\\alpha}\\left(\\frac{k}{K}\\right) = \\alpha \\left(\\frac{k}{K}\\right)^{\\alpha-1}$\n\n加速拒绝采样算法使用一个三阶段分支结构。抽取一个样本对 $(x, u)$，其中 $x \\sim g$ 且 $u \\sim \\mathrm{Uniform}(0,1)$。\n$1$. 如果 $u \\le \\frac{s(x)}{M g(x)} = \\frac{s(x)}{\\alpha}$，则提早接受。\n$2$. 如果 $u  \\frac{e(x)}{M g(x)} = \\frac{e(x)}{\\alpha}$，则提早拒绝。\n$3$. 否则进入中间分支，在该分支中计算 $f_{\\alpha}(x)$。\n\n单个线程进入每个分支的概率（$p_a, p_r, p_m$）由 $(x, u)$ 的联合分布决定，该联合分布在单位正方形 $[0,1] \\times [0,1]$ 上是均匀的。这些概率即为相应区域的面积。\n提早接受概率 $p_a$ 为：\n$$p_a = P\\left(u \\le \\frac{s(x)}{\\alpha}\\right) = \\int_0^1 \\frac{s(x)}{\\alpha} dx$$\n由于 $s(x)$ 是分段常数，我们将每个区间上的积分相加：\n$$p_a = \\sum_{k=1}^K \\int_{\\frac{k-1}{K}}^{\\frac{k}{K}} \\frac{1}{\\alpha} \\left(\\alpha \\left(\\frac{k-1}{K}\\right)^{\\alpha-1}\\right) dx = \\sum_{k=1}^K \\frac{1}{K} \\left(\\frac{k-1}{K}\\right)^{\\alpha-1} = \\frac{1}{K^\\alpha} \\sum_{k=1}^K (k-1)^{\\alpha-1}$$\n通过使用 $j=k-1$ 重新索引，我们得到 $p_a = \\frac{1}{K^\\alpha} \\sum_{j=0}^{K-1} j^{\\alpha-1}$。注意，当 $\\alpha=1$ 时，$0^0=1$。\n\n提早拒绝概率 $p_r$ 为：\n$$p_r = P\\left(u  \\frac{e(x)}{\\alpha}\\right) = \\int_0^1 \\left(1 - \\frac{e(x)}{\\alpha}\\right) dx$$\n$$p_r = \\sum_{k=1}^K \\int_{\\frac{k-1}{K}}^{\\frac{k}{K}} \\left(1 - \\frac{1}{\\alpha} \\alpha \\left(\\frac{k}{K}\\right)^{\\alpha-1}\\right) dx = \\sum_{k=1}^K \\frac{1}{K} \\left(1 - \\left(\\frac{k}{K}\\right)^{\\alpha-1}\\right) = 1 - \\frac{1}{K^\\alpha} \\sum_{k=1}^K k^{\\alpha-1}$$\n\n中间分支概率 $p_m$ 对应于挤压函数和包络函数之间的区域。由于这些分支是互斥的且覆盖了所有可能性，所以 $p_m = 1 - p_a - p_r$。\n$$p_m = 1 - \\left(\\frac{1}{K^\\alpha} \\sum_{j=0}^{K-1} j^{\\alpha-1}\\right) - \\left(1 - \\frac{1}{K^\\alpha} \\sum_{k=1}^K k^{\\alpha-1}\\right) = \\frac{1}{K^\\alpha} \\left(\\sum_{k=1}^K k^{\\alpha-1} - \\sum_{j=0}^{K-1} j^{\\alpha-1}\\right)$$\n这两个和的差是 $(1^{\\alpha-1} + \\dots + K^{\\alpha-1}) - (0^{\\alpha-1} + \\dots + (K-1)^{\\alpha-1}) = K^{\\alpha-1} - 0^{\\alpha-1}$。\n因此，$p_m = \\frac{K^{\\alpha-1} - 0^{\\alpha-1}}{K^\\alpha} = \\frac{1}{K} - \\frac{0^{\\alpha-1}}{K^\\alpha}$。对于 $\\alpha1$，$p_m=1/K$。对于 $\\alpha=1$，$0^{\\alpha-1}=0^0=1$，所以 $p_m=0$。\n\n现在，我们推导 SIMD 效率。\n设 $C_i$ 是线程 $i$ 的执行成本，它是一个从 $\\{\\tau_a, \\tau_r, \\tau_m\\}$ 中取值的随机变量。单线程的期望工作量为：\n$$E_{thread} = E[C_i] = \\tau_a p_a + \\tau_r p_r + \\tau_m p_m$$\n如定义所述，线程束时间工作量汇总了在一个大小为 $W$ 的线程束中，至少有一个线程执行的所有分支的成本。设 $A_W$、$R_W$ 和 $M_W$ 为指示变量，如果至少有一个线程分别进入提早接受、提早拒绝或中间分支，则其值为 1。线程束时间工作量为 $C_{warp} = \\tau_a A_W + \\tau_r R_W + \\tau_m M_W$。期望的线程束时间工作量为 $E_{warp} = E[C_{warp}] = \\tau_a E[A_W] + \\tau_r E[R_W] + \\tau_m E[M_W]$。\n指示变量的期望是该事件发生的概率。由于线程是独立的：\n$E[A_W] = P(A_W=1) = 1 - P(\\text{没有线程进入提早接受分支}) = 1 - (1 - p_a)^W$。\n类似地，$E[R_W] = 1 - (1-p_r)^W$ 且 $E[M_W] = 1 - (1-p_m)^W$。\n因此，期望的线程束时间工作量为：\n$$E_{warp} = \\tau_a(1 - (1-p_a)^W) + \\tau_r(1 - (1-p_r)^W) + \\tau_m(1 - (1-p_m)^W)$$\nSIMD 效率 $\\eta$ 被定义为“单线程的期望工作量”与“线程束时间的期望工作量”之比。一种标准的效率解释（其值在 $[0,1]$ 内）是理想工作量与实际使用资源的比率。单个线程的理想工作量是 $E_{thread}$，在线程束模型中每个线程的有效时间成本是 $E_{warp}/W$。一种更直接的解释，等同于每工作单元加速比（$S/W$），是每个线程的平均工作量与线程束总成本的比率。唯一符合问题背景且值保持在 $[0,1]$ 内、物理上有意义的效率定义是 $\\eta = E_{thread} / E_{warp}$。如果所有线程都采用相同的路径（无分歧），则对于某个 $k \\in \\{a,r,m\\}$ 有 $p_k=1$，从而导致 $E_{thread} = \\tau_k$ 和 $E_{warp} = \\tau_k$，因此 $\\eta=1$。\nSIMD 效率的最终表达式是：\n$$\\eta = \\frac{\\tau_a p_a + \\tau_r p_r + \\tau_m p_m}{\\tau_a(1 - (1-p_a)^W) + \\tau_r(1 - (1-p_r)^W) + \\tau_m(1 - (1-p_m)^W)}$$\n这些推导出的表达式被实现用于解决给定的测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the SIMD efficiency for rejection sampling based on a derived analytical formula.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (alpha, K, W, tau_a, tau_r, tau_m)\n    test_cases = [\n        (1.0, 64, 32, 1.0, 1.0, 8.0),   # Case 1\n        (2.0, 32, 32, 1.0, 1.0, 8.0),   # Case 2\n        (64.0, 32, 32, 1.0, 1.0, 8.0),  # Case 3\n        (4.0, 1, 32, 1.0, 1.0, 8.0),    # Case 4\n        (4.0, 64, 64, 1.0, 1.0, 8.0)    # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, K, W, tau_a, tau_r, tau_m = case\n\n        # The derivation of probabilities is robust for alpha = 1, including alpha = 1\n        # where 0^0 is handled as 1 by numpy.power, which is the correct convention here.\n        # No special case for alpha=1 is needed.\n        \n        # Calculate branch probabilities p_a, p_r, p_m\n        \n        # p_a = (1/K^alpha) * sum_{j=0}^{K-1} j^(alpha-1)\n        j = np.arange(K, dtype=np.float64)\n        alpha_minus_1 = alpha - 1.0\n        \n        # Use np.power for robust handling of 0^0\n        sum_for_pa = np.sum(np.power(j, alpha_minus_1))\n        K_to_alpha = np.power(float(K), alpha)\n        \n        p_a = sum_for_pa / K_to_alpha\n\n        # p_r = 1 - (1/K^alpha) * sum_{k=1}^{K} k^(alpha-1)\n        k = np.arange(1, K + 1, dtype=np.float64)\n        sum_for_pr = np.sum(np.power(k, alpha_minus_1))\n        \n        p_r = 1.0 - (sum_for_pr / K_to_alpha)\n        \n        # p_m = 1 - p_a - p_r for numerical stability\n        p_m = 1.0 - p_a - p_r\n        \n        # If K=1, then p_a=0, p_r=0, p_m=1. Let's check for small numerical errors.\n        if K == 1:\n            p_a, p_r, p_m = 0.0, 0.0, 1.0\n        \n        # Calculate expected per-thread work\n        E_thread = tau_a * p_a + tau_r * p_r + tau_m * p_m\n        \n        # If E_thread is zero, efficiency is zero (unless E_warp is also zero)\n        if E_thread == 0.0:\n            results.append(0.0)\n            continue\n\n        # Calculate expected warp-time work\n        # E_warp = tau_a(1-(1-p_a)^W) + tau_r(1-(1-p_r)^W) + tau_m(1-(1-p_m)^W)\n        prob_no_a = np.power(1.0 - p_a, W)\n        prob_no_r = np.power(1.0 - p_r, W)\n        prob_no_m = np.power(1.0 - p_m, W)\n        \n        E_warp = tau_a * (1.0 - prob_no_a) + tau_r * (1.0 - prob_no_r) + tau_m * (1.0 - prob_no_m)\n        \n        # Calculate SIMD efficiency\n        if E_warp == 0.0:\n            # This case occurs if all costs are 0, or if all probabilities are 0, etc.\n            # If E_thread is also 0, efficiency is indeterminate. Let's define it as 1.0 for perfect efficiency.\n            # In our setup, taus are positive, so E_warp  0.\n            eta = 1.0\n        else:\n            eta = E_thread / E_warp\n        \n        results.append(eta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}