{
    "hands_on_practices": [
        {
            "introduction": "在任何蒙特卡洛工作流中，首要任务是验证所使用的伪随机数生成器（PRNG）的质量。本练习将指导您实现卡方拟合优度检验，这是一个用于验证生成器输出是否符合目标均匀分布的基本统计工具 。通过将生成器的输出分箱并比较观测频数与期望频数，您将亲手实践如何量化评估PRNG的均匀性，这是确保模拟结果可靠性的关键一步。",
            "id": "3529430",
            "problem": "考虑一个计算高能物理（HEP）中的蒙特卡洛工作流，其中区间 $[0,1)$ 上的均匀伪随机数被用作基础随机变量来抽样运动学变量。科学有效性的一个基本要求是，伪随机数生成器产生的值必须与 $[0,1)$ 上的均匀分布一致。为了检验这一点，可以将区间 $[0,1)$ 划分为 $k$ 个等宽的分箱，并执行卡方拟合优度检验，以评估观测到的分箱计数是否与均匀性一致。\n\n从一个基本前提开始，在均匀性的原假设下，每次抽取都以概率 $p = 1/k$ 独立地落入任何一个分箱中。因此，分箱计数的向量服从一个多项分布，其参数为 $N$ 和概率 $(p_1, p_2, \\dots, p_k)$，其中对所有 $i$ 都有 $p_i = p$。每个分箱中的期望计数为 $E_i = N p$，而对于每个分箱计数 $O_i$，其方差为 $\\mathrm{Var}(O_i) = N p (1 - p)$。对于大的 $N$ 和固定的 $k$，且期望计数不小的情况下，皮尔逊卡方统计量\n$$\n\\chi^2 = \\sum_{i=1}^{k} \\frac{(O_i - E_i)^2}{E_i}\n$$\n近似服从自由度为 $k - 1$ 的卡方分布。\n\n您的任务是实现一个完整的程序，该程序：\n- 使用指定的生成器类型和种子，在 $[0,1)$ 上生成 $N$ 个伪随机值。\n- 将这些值分入 $[0,1)$ 上的 $k$ 个等宽分箱中。\n- 在多项模型下，计算观测计数 $O_i$、期望计数 $E_i = N/k$（所有分箱相同）以及每箱方差 $\\mathrm{Var}(O_i) = N \\cdot \\frac{1}{k} \\cdot \\left(1 - \\frac{1}{k}\\right)$。\n- 使用自由度为 $k-1$ 的卡方分布，计算皮尔逊卡方统计量 $\\chi^2$ 及相关的p值。\n- 通过将p值与显著性水平 $\\alpha$ 进行比较，决定是否在显著性水平 $\\alpha$ 下拒绝均匀性原假设。\n- 根据常见的经验法则 $E_i \\geq 5$，报告渐近卡方近似是否预期有效。\n\n您的程序必须实现两种生成器类型：\n- “uniform”：通过可复现的种子，从默认的可移植计算机生成器（PCG）获得高质量的伪随机数。\n- “quantized10”：使用相同的高质量生成器，然后进行确定性量化，将每个值 $u$ 映射到 $\\lfloor 10 u \\rfloor / 10$，从而在 $[0,1)$ 中仅产生10个离散水平。\n\n对于每个测试用例，您的程序必须按以下格式输出一个列表：\n$[ \\chi^2, \\text{dof}, p\\text{-value}, \\text{reject}, E, \\mathrm{Var}, \\text{approx\\_valid} ]$，\n其中 $\\chi^2$ 是一个浮点数，$\\text{dof}$ 是一个等于 $k-1$ 的整数，$p\\text{-value}$ 是一个浮点数，$\\text{reject}$ 是一个布尔值，指示 $p\\text{-value}  \\alpha$ 是否成立，$E$ 是每箱的期望计数（一个等于 $N/k$ 的浮点数），$\\mathrm{Var}$ 是每箱的方差（一个等于 $N \\cdot \\frac{1}{k} \\cdot \\left(1 - \\frac{1}{k}\\right)$ 的浮点数），而 $\\text{approx\\_valid}$ 是一个布尔值，指示 $E \\geq 5$ 是否成立。\n\n设计考虑：\n- 分箱必须由位于 $0, \\frac{1}{k}, \\frac{2}{k}, \\dots, 1$ 的箱边定义，对于 $u \\in [0,1)$，值 $u$ 被分配到索引为 $\\lfloor k u \\rfloor$ 的分箱中。\n- 最终输出必须将所有测试用例的结果汇总为单行表示的列表，其中每个子列表对应一个测试用例。\n\n使用以下测试套件来检验问题的不同方面，包括“理想情况”、期望计数的边界条件、许多分箱计数很小或为零的边缘情况，以及一个故意设计的非均匀生成器：\n\n1. $N = 100000$, $k = 100$, $\\alpha = 0.01$, 生成器类型 \"uniform\", 种子 $12345$。\n2. $N = 5000$, $k = 1000$, $\\alpha = 0.05$, 生成器类型 \"uniform\", 种子 $54321$。\n3. $N = 10000$, $k = 5000$, $\\alpha = 0.05$, 生成器类型 \"uniform\", 种子 $1$。\n4. $N = 100$, $k = 10$, $\\alpha = 0.1$, 生成器类型 \"uniform\", 种子 $2025$。\n5. $N = 10000$, $k = 100$, $\\alpha = 0.001$, 生成器类型 \"quantized10\", 种子 $7$。\n6. $N = 1000$, $k = 1000$, $\\alpha = 0.05$, 生成器类型 \"uniform\", 种子 $314159$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素本身也是一个如上所述的列表，并按测试套件的相同顺序出现（例如，$[[\\dots],[\\dots],\\dots]$）。此问题不涉及物理单位或角度单位。",
            "solution": "该问题要求为伪随机数生成器（PRNGs）实现一个统计验证程序，这是计算科学中的一项关键任务，尤其是在高能物理的蒙特卡洛模拟中。任务的核心是执行皮尔逊卡方（$\\chi^2$）拟合优度检验，以评估PRNG的输出是否与区间 $[0,1)$ 上的均匀分布一致。解决方案将基于概率论和统计学的基本原理进行设计。\n\n逻辑步骤如下：\n1. 原假设 $H_0$ 假定生成的数是从 $[0,1)$ 上的连续均匀分布中抽取的。\n2. 为检验此假设，将区间 $[0,1)$ 划分为 $k$ 个连续的、等宽的子区间（分箱）。在 $H_0$ 下，一个随机变量落入任何特定分箱的概率对所有分箱都是相同的，其值为 $p = 1/k$。\n3. 总共生成 $N$ 个随机变量。记录落入每个分箱的变量计数，表示为向量 $(O_1, O_2, \\dots, O_k)$。这个观测计数向量在数学上服从一个多项分布，其参数为 $N$（试验次数）和 $(p_1, p_2, \\dots, p_k)$（事件概率），其中对于所有 $i \\in \\{1, \\dots, k\\}$，都有 $p_i = 1/k$。\n\n从这些基本原理出发，我们推导出检验所需的量。每个分箱 $i$ 的期望计数（记为 $E_i$）由相应边际二项分布的均值给出，即 $E_i = N p_i$。由于所有的 $p_i$ 都等于 $1/k$，因此所有分箱的期望计数是相同的：\n$$\nE = E_i = N \\cdot \\frac{1}{k}\n$$\n单个分箱 $i$ 中计数的方差 $\\mathrm{Var}(O_i)$ 由二项变量的方差给出：\n$$\n\\mathrm{Var}(O_i) = N p_i (1 - p_i) = N \\cdot \\frac{1}{k} \\left(1 - \\frac{1}{k}\\right)\n$$\n该方差量化了分箱计数围绕其均值的预期随机波动。\n\n皮尔逊卡方检验统计量 $\\chi^2$ 用于衡量观测计数 $O_i$ 与原假设下的期望计数 $E$ 之间的总差异。它被定义为平方差的总和，并按期望计数进行归一化：\n$$\n\\chi^2 = \\sum_{i=1}^{k} \\frac{(O_i - E)^2}{E}\n$$\n该统计量的大值表示与期望的均匀分布存在显著偏差。统计学中的一个关键成果，即皮尔逊卡方定理，指出对于足够大的样本量 $N$，此 $\\chi^2$ 统计量近似服从卡方分布。该分布的自由度（$\\text{dof}$）为 $\\nu = k - 1$。由于施加在观测计数上的线性约束，即它们的总和必须等于总样本数 $\\sum_{i=1}^{k} O_i = N$，因此损失了一个自由度。\n\n这种卡方近似的有效性取决于期望计数不能太小。问题中指定的一个广泛使用的启发式法则是，如果每个分箱的期望计数至少为5，即 $E \\ge 5$，则认为该近似是可靠的。\n\n然后通过计算p值来进行假设检验。p值表示在原假设 $H_0$ 为真的前提下，观测到至少与从数据中计算出的 $\\chi^2$ 统计量一样大的值的概率。对于这个右尾检验，其计算公式为：\n$$\np\\text{-value} = P(\\chi^2_{\\nu} \\ge \\chi^2_{\\text{observed}})\n$$\n其中 $\\chi^2_{\\nu}$ 是一个服从自由度为 $\\nu = k-1$ 的卡方分布的随机变量。这个概率是使用卡方分布的生存函数（$1 - \\text{CDF}$）计算的。\n\n最后，通过将p值与预先确定的显著性水平 $\\alpha$ 进行比较来做出决定。如果p值小于 $\\alpha$（$p  \\alpha$），则意味着如果生成器确实是均匀的，那么观测到的数据不太可能偶然发生。因此，我们拒绝原假设，并得出结论：有统计上显著的证据表明该PRNG不是均匀的。如果 $p \\ge \\alpha$，我们则不拒绝原假设。\n\n实现将按以下步骤进行：\n- 对于由参数 $(N, k, \\alpha, \\text{generator\\_type}, \\text{seed})$ 定义的每个测试用例，使用给定的种子初始化一个可复现的 `numpy` PRNG（`PCG64`）。\n- 生成 $N$ 个随机数。对于 `\"uniform\"` 类型，直接使用生成器的输出。对于 `\"quantized10\"` 类型，输出值 $u$ 通过函数 $u \\mapsto \\lfloor 10u \\rfloor / 10$ 进行转换，这通过将值限制在10个离散水平上引入了明显的非均匀性。\n- `numpy.histogram` 函数用于高效地将生成的样本分箱到 $[0,1)$ 上的 $k$ 个等宽分箱中，并获得观测计数 $O_i$。\n- 根据它们的定义计算导出量——$E$、$\\mathrm{Var}(O_i)$、$\\chi^2$ 和自由度 $\\nu$。\n- `scipy.stats.chi2.sf` 函数用于从 $\\chi^2$ 统计量和自由度计算p值。\n- 确定用于拒绝 $H_0$ 和用于判断卡方近似有效性的布尔值。\n- 收集每个测试用例的结果，并将其格式化为最终输出所指定的列表嵌套列表的结构。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, k, alpha, generator_type, seed)\n        (100000, 100, 0.01, \"uniform\", 12345),\n        (5000, 1000, 0.05, \"uniform\", 54321),\n        (10000, 5000, 0.05, \"uniform\", 1),\n        (100, 10, 0.1, \"uniform\", 2025),\n        (10000, 100, 0.001, \"quantized10\", 7),\n        (1000, 1000, 0.05, \"uniform\", 314159),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, k, alpha, gen_type, seed = params\n        result = perform_chi_square_test(N, k, alpha, gen_type, seed)\n        results.append(result)\n\n    # Format the final output string as a list of lists, without extra spaces.\n    # e.g., [[val1,val2,...],[val1,val2,...]]\n    sublist_strs = []\n    for sublist in results:\n        # str(item) for bool produces 'True'/'False' with capital letters, which is standard for Python.\n        item_strs = [str(item) for item in sublist]\n        sublist_strs.append(f\"[{','.join(item_strs)}]\")\n    \n    final_output_str = f\"[{','.join(sublist_strs)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\ndef perform_chi_square_test(N, k, alpha, generator_type, seed):\n    \"\"\"\n    Performs a chi-square goodness-of-fit test for a single test case.\n\n    Args:\n        N (int): Number of pseudo-random values to generate.\n        k (int): Number of bins to partition the [0,1) interval into.\n        alpha (float): Significance level for the hypothesis test.\n        generator_type (str): Type of generator (\"uniform\" or \"quantized10\").\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        list: A list containing the test results in the specified format:\n              [chi^2, dof, p-value, reject, E, Var, approx_valid]\n    \"\"\"\n    # 1. Generate pseudo-random numbers\n    rng = np.random.default_rng(seed)\n    if generator_type == \"uniform\":\n        samples = rng.random(size=N)\n    elif generator_type == \"quantized10\":\n        u_samples = rng.random(size=N)\n        samples = np.floor(10 * u_samples) / 10\n    else:\n        # This case should not be reached with the given problem statement.\n        raise ValueError(f\"Unknown generator type: {generator_type}\")\n\n    # 2. Bin the values to get observed counts\n    # np.histogram bins are [min, max] with bins=k and range=(0,1) resulting in\n    # bins of width 1/k. The last bin is inclusive on the right edge.\n    observed_counts, _ = np.histogram(samples, bins=k, range=(0, 1))\n\n    # 3. Compute expected counts and degrees of freedom\n    expected_count = N / k\n    dof = k - 1\n    \n    # 4. Compute Pearson's chi-square statistic\n    # The case expected_count=0 is only possible if N=0, which is not the case here.\n    # The sum is over all k bins.\n    if expected_count > 0:\n        chi2_stat = np.sum((observed_counts - expected_count)**2 / expected_count)\n    else:\n        chi2_stat = 0.0\n\n    # 5. Calculate p-value\n    # The p-value is the probability of observing a chi-square value as extreme\n    # or more extreme than the one calculated, given the null hypothesis is true.\n    # This is given by the survival function (1 - CDF).\n    p_value = chi2.sf(chi2_stat, dof)\n\n    # 6. Decide whether to reject the null hypothesis\n    reject_null = p_value  alpha\n\n    # 7. Report if the asymptotic chi-square approximation is valid\n    # Based on the common rule-of-thumb E_i >= 5.\n    approx_valid = expected_count >= 5\n\n    # 8. Compute the per-bin variance under the multinomial model\n    variance = N * (1 / k) * (1 - 1 / k)\n\n    return [\n        float(chi2_stat),\n        int(dof),\n        float(p_value),\n        bool(reject_null),\n        float(expected_count),\n        float(variance),\n        bool(approx_valid),\n    ]\n\n# Execute the main function when the script is run.\nsolve()\n```"
        },
        {
            "introduction": "统计检验可以揭示生成器 *存在* 缺陷，但理论分析则能阐明缺陷产生的 *原因*。本练习聚焦于线性同余生成器（LCG）的一种典型失效模式 。您将通过第一性原理推导，揭示在模为2的幂的LCG中，使用低位比特如何导致严重的序列相关性，从而深刻理解不良的生成器设计会如何从根本上破坏模拟的有效性。",
            "id": "3333419",
            "problem": "考虑一个由递推关系 $x_{t+1} \\equiv a x_t + c \\pmod{m}$ 定义的线性同余生成器 (LCG)，其模数 $m = 2^w$，乘数 $a$，增量 $c$。众所周知，在模算术中，同余关系会向下传播到其因数的模余数，因此对于 $k$ 个最低有效位（即模 $2^k$，其中 $k \\leq w$）的递推关系为 $x_{t+1} \\equiv a x_t + c \\pmod{2^k}$。在本问题中，你将分析使用低位比特来形成伪随机变量在随机模拟中的影响。\n\n设 $w = 3$，$a = 1$，$c = 1$，且 $m = 2^w = 8$。通过将 $x_t$ 的 $k = 3$ 个最低有效位映射到单位区间，定义伪随机变量 $U_t$，即 $U_t = (x_t \\bmod 2^k)/2^k$。假设一个未知的种子 $x_0$ 在 $\\{0,1,\\dots,7\\}$ 上均匀分布，并考虑均值的蒙特卡罗估计量 $\\hat{\\mu}_n = \\frac{1}{n} \\sum_{t=1}^{n} U_t$。\n\n你的任务是：\n1. 从 LCG 的定义出发，形式上证明在上述参数下，低位比特变量序列满足 $U_{t+1} \\equiv U_t + 2^{-3} \\pmod{1}$，并由此推断这会导致严重的序列相关性。你的论证必须仅依赖于递推定义、模算术以及从比特到单位区间的映射。\n2. 仅使用相关序列均值方差的基本原理，计算当 $n = 3$ 时 $\\hat{\\mu}_n$ 的精确方差 $\\operatorname{Var}[\\hat{\\mu}_n]$，其中期望是关于均匀种子 $x_0$ 计算的。\n\n将最终答案表示为精确分数。不要四舍五入。",
            "solution": "该问题被认为是有效的，因为它在科学上基于伪随机数生成理论，问题陈述清晰且给定的条件完整一致，并以客观、正式的语言表达。因此，我们可以着手求解。\n\n问题分为两部分。第一部分是为伪随机变量 $U_t$ 建立一个确定性的递推关系。第二部分是计算基于这些变量序列的蒙特卡罗估计量的方差。\n\n**第一部分：$U_t$ 的递推关系**\n\n线性同余生成器 (LCG) 由递推关系 $x_{t+1} \\equiv a x_t + c \\pmod{m}$ 定义。问题给出了具体参数：乘数 $a=1$，增量 $c=1$，以及模数 $m=2^w$，其中 $w=3$，因此 $m=2^3=8$。递推关系因此为：\n$$\nx_{t+1} \\equiv x_t + 1 \\pmod{8}\n$$\n这意味着对于任何整数状态 $x_t \\in \\{0, 1, \\dots, 7\\}$，下一个状态 $x_{t+1}$ 由 $x_{t+1} = (x_t + 1) \\bmod 8$ 给出。\n\n伪随机变量 $U_t$ 的定义是将 $x_t$ 的 $k$ 个最低有效位映射到单位区间 $[0, 1)$。指定的比特数为 $k=3$。映射关系为 $U_t = (x_t \\bmod 2^k)/2^k$。当 $k=3$ 时，这变为：\n$$\nU_t = \\frac{x_t \\bmod 2^3}{2^3} = \\frac{x_t \\bmod 8}{8}\n$$\n由于状态 $x_t$ 本身是模8运算的结果，它们总是在集合 $\\{0, 1, \\dots, 7\\}$ 中。对于任何这样的 $x_t$，我们有 $x_t \\bmod 8 = x_t$。因此，该关系简化为：\n$$\nU_t = \\frac{x_t}{8}\n$$\n这意味着 $x_t = 8 U_t$。我们可以将其代入 $x_t$ 的递推关系。下一个状态由 $x_{t+1} = (x_t + 1) \\bmod 8$ 给出。相应的变量 $U_{t+1}$ 是：\n$$\nU_{t+1} = \\frac{x_{t+1}}{8} = \\frac{(x_t + 1) \\bmod 8}{8}\n$$\n代入 $x_t = 8 U_t$：\n$$\nU_{t+1} = \\frac{(8 U_t + 1) \\bmod 8}{8}\n$$\n运算 $(z \\bmod N)/N$ 给出数字 $z/N$ 的小数部分，可以写作 $\\{z/N\\}$ 或 $z/N \\pmod 1$。应用这一见解，我们得到：\n$$\nU_{t+1} = \\frac{8 U_t + 1}{8} \\pmod 1 = \\left(U_t + \\frac{1}{8}\\right) \\pmod 1\n$$\n由于 $2^{-3} = 1/8$，我们成功证明了变量序列满足关系：\n$$\nU_{t+1} \\equiv U_t + 2^{-3} \\pmod{1}\n$$\n这个递推关系是完全确定性的。给定任何 $U_t$，$U_{t+1}$ 的值是唯一确定的。这表明连续值之间存在完美的线性关系，是序列相关性的一个极端情况。一张点对 $(U_t, U_{t+1})$ 的图会显示这些点仅落在两条平行线上，$y=x+1/8$ 和 $y=x-7/8$，对于一个旨在作为伪随机的序列来说，这是一个灾难性的失败。\n\n**第二部分：$\\hat{\\mu}_3$ 的方差计算**\n\n均值的蒙特卡罗估计量由 $\\hat{\\mu}_n = \\frac{1}{n} \\sum_{t=1}^{n} U_t$ 给出。我们需要计算其在 $n=3$ 时的方差，即 $\\operatorname{Var}[\\hat{\\mu}_3]$。\n$$\n\\operatorname{Var}[\\hat{\\mu}_3] = \\operatorname{Var}\\left[\\frac{1}{3}(U_1 + U_2 + U_3)\\right] = \\frac{1}{9} \\operatorname{Var}[U_1 + U_2 + U_3]\n$$\n随机变量之和的方差由下式给出：\n$$\n\\operatorname{Var}\\left[\\sum_{t=1}^{n} U_t\\right] = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\operatorname{Cov}[U_i, U_j] = \\sum_{t=1}^{n} \\operatorname{Var}[U_t] + 2 \\sum_{1 \\le i  j \\le n} \\operatorname{Cov}[U_i, U_j]\n$$\n对于 $n=3$，这展开为：\n$$\n\\operatorname{Var}[U_1 + U_2 + U_3] = \\operatorname{Var}[U_1] + \\operatorname{Var}[U_2] + \\operatorname{Var}[U_3] + 2(\\operatorname{Cov}[U_1, U_2] + \\operatorname{Cov}[U_1, U_3] + \\operatorname{Cov}[U_2, U_3])\n$$\n期望是关于种子 $x_0$ 的分布来计算的，它在 $\\{0, 1, \\dots, 7\\}$ 上均匀分布。状态序列为 $x_t = (x_0 + t) \\bmod 8$，变量为 $U_t = x_t/8$。\n\n首先，我们确定序列 $\\{U_t\\}$ 的性质。由于 $x_0$ 是在 $\\{0, 1, \\dots, 7\\}$ 上的一个均匀随机变量，且 $t$ 是一个常数，变量 $x_t = (x_0 + t) \\bmod 8$ 对于任何 $t \\ge 1$ 也均匀分布在 $\\{0, 1, \\dots, 7\\}$ 上。因此，每个 $U_t$ 都遵循集合 $\\{0, \\frac{1}{8}, \\frac{2}{8}, \\dots, \\frac{7}{8}\\}$ 上的相同离散均匀分布，其中对于 $i \\in \\{0, \\dots, 7\\}$，$P(U_t = i/8) = 1/8$。这意味着该序列是平稳的，因此 $\\operatorname{E}[U_t]$ 和 $\\operatorname{Var}[U_t]$ 对所有 $t$ 都是常数，且自协方差 $\\operatorname{Cov}[U_t, U_{t+k}]$ 仅取决于滞后 $k$。\n\n我们计算 $U_t$ 的一阶矩和二阶矩：\n$$\n\\operatorname{E}[U_t] = \\sum_{i=0}^{7} \\frac{i}{8} P\\left(x_t = i\\right) = \\frac{1}{8} \\sum_{i=0}^{7} \\frac{i}{8} = \\frac{1}{64} \\frac{7(8)}{2} = \\frac{28}{64} = \\frac{7}{16}\n$$\n$$\n\\operatorname{E}[U_t^2] = \\sum_{i=0}^{7} \\left(\\frac{i}{8}\\right)^2 P\\left(x_t = i\\right) = \\frac{1}{8} \\sum_{i=0}^{7} \\frac{i^2}{64} = \\frac{1}{512} \\sum_{i=0}^{7} i^2 = \\frac{1}{512} \\frac{7(7+1)(2 \\cdot 7+1)}{6} = \\frac{140}{512} = \\frac{35}{128}\n$$\n方差为：\n$$\n\\operatorname{Var}[U_t] = \\operatorname{E}[U_t^2] - (\\operatorname{E}[U_t])^2 = \\frac{35}{128} - \\left(\\frac{7}{16}\\right)^2 = \\frac{35}{128} - \\frac{49}{256} = \\frac{70 - 49}{256} = \\frac{21}{256}\n$$\n所以，$\\operatorname{Var}[U_1] = \\operatorname{Var}[U_2] = \\operatorname{Var}[U_3] = 21/256$。\n\n接下来，我们计算自协方差 $\\gamma(k) = \\operatorname{Cov}[U_t, U_{t+k}]$。\n$\\gamma(k) = \\operatorname{E}[U_t U_{t+k}] - \\operatorname{E}[U_t]\\operatorname{E}[U_{t+k}] = \\operatorname{E}[U_t U_{t+k}] - (7/16)^2$。\n我们有 $U_{t+k} = ((x_t+k)\\pmod 8)/8$。\n$$\n\\operatorname{E}[U_t U_{t+k}] = \\operatorname{E}\\left[\\frac{x_t}{8} \\frac{(x_t+k)\\pmod 8}{8}\\right] = \\frac{1}{64}\\operatorname{E}[x_t ((x_t+k)\\pmod 8)]\n$$\n期望是关于 $x_t \\sim U\\{0, \\dots, 7\\}$ 计算的。\n$$\n\\operatorname{E}[x_t ((x_t+k)\\pmod 8)] = \\frac{1}{8}\\sum_{j=0}^{7} j ((j+k)\\pmod 8)\n$$\n对于滞后 $k=1$：\n$$\n\\frac{1}{8}\\sum_{j=0}^{7} j ((j+1)\\pmod 8) = \\frac{1}{8}(0 \\cdot 1 + 1 \\cdot 2 + 2 \\cdot 3 + 3 \\cdot 4 + 4 \\cdot 5 + 5 \\cdot 6 + 6 \\cdot 7 + 7 \\cdot 0) = \\frac{112}{8} = 14\n$$\n所以 $\\operatorname{E}[U_t U_{t+1}] = 14/64 = 7/32$。\n$\\gamma(1) = \\operatorname{Cov}[U_1, U_2] = \\operatorname{Cov}[U_2, U_3] = \\frac{7}{32} - \\frac{49}{256} = \\frac{56 - 49}{256} = \\frac{7}{256}$。\n\n对于滞后 $k=2$：\n$$\n\\frac{1}{8}\\sum_{j=0}^{7} j ((j+2)\\pmod 8) = \\frac{1}{8}(0 \\cdot 2 + 1 \\cdot 3 + 2 \\cdot 4 + 3 \\cdot 5 + 4 \\cdot 6 + 5 \\cdot 7 + 6 \\cdot 0 + 7 \\cdot 1) = \\frac{92}{8} = \\frac{23}{2}\n$$\n所以 $\\operatorname{E}[U_t U_{t+2}] = (23/2)/64 = 23/128$。\n$\\gamma(2) = \\operatorname{Cov}[U_1, U_3] = \\frac{23}{128} - \\frac{49}{256} = \\frac{46 - 49}{256} = -\\frac{3}{256}$。\n\n现在我们组合求和的方差：\n\\begin{align*} \\operatorname{Var}[U_1 + U_2 + U_3] = 3 \\operatorname{Var}[U_t] + 2(\\operatorname{Cov}[U_1, U_2] + \\operatorname{Cov}[U_2, U_3] + \\operatorname{Cov}[U_1, U_3]) \\\\ = 3 \\operatorname{Var}[U_t] + 2(2\\gamma(1) + \\gamma(2)) \\\\ = 3\\left(\\frac{21}{256}\\right) + 2\\left(2\\left(\\frac{7}{256}\\right) + \\left(-\\frac{3}{256}\\right)\\right) \\\\ = \\frac{63}{256} + 2\\left(\\frac{14 - 3}{256}\\right) \\\\ = \\frac{63}{256} + 2\\left(\\frac{11}{256}\\right) = \\frac{63+22}{256} = \\frac{85}{256} \\end{align*}\n最后，估计量 $\\hat{\\mu}_3$ 的方差是：\n$$\n\\operatorname{Var}[\\hat{\\mu}_3] = \\frac{1}{9} \\operatorname{Var}[U_1 + U_2 + U_3] = \\frac{1}{9} \\cdot \\frac{85}{256} = \\frac{85}{2304}\n$$\n分子是 $85 = 5 \\times 17$，分母是 $2304 = 9 \\times 256 = 3^2 \\times 2^8$，所以这个分数是最简形式。",
            "answer": "$$\n\\boxed{\\frac{85}{2304}}\n$$"
        },
        {
            "introduction": "现代科学计算常常依赖并行处理，这要求我们能够生成多个独立的随机数流。本练习将介绍一种强大而可靠的技术，用于为并行模拟创建可证明无重叠的子流 。您将学习如何将生成器的递推关系表示为矩阵变换，并利用矩阵幂运算实现序列的“跳转”（skip-ahead），这是构建可扩展并行蒙特卡洛模拟的关键技术。",
            "id": "3333414",
            "problem": "考虑由有限代数结构上的线性递推及其作为线性映射的状态转移表示所定义的线性伪随机数生成器。使用以下基本依据：(i) 在模 $m$ 整数环（记作 $\\mathbb{Z}/m\\mathbb{Z}$）和双元素有限域（记作 $\\mathbb{F}_2$）上的线性递推定义，(ii) 将生成器状态演化解释为重复应用一个由矩阵表示的线性变换，以及 (iii) 一个线性映射复合 $k$ 次对应于其矩阵表示的 $k$ 次幂这一事实。基于这些依据，推导一种跳步方法，并设计一种子流构造方案，以确保在底层周期足够大时，生成的定长段不发生重叠。\n\n您必须完成以下任务。\n\n1. 定义一个在 $\\mathbb{Z}/m\\mathbb{Z}$ 上的线性同余生成器（LCG），其递推关系为 $x_{n+1} \\equiv a x_n + c \\pmod{m}$，其中 $x_n \\in \\mathbb{Z}/m\\mathbb{Z}$。展示如何通过用一个常数分量增广状态，将此仿射映射嵌入到一个线性映射中，并推导出 $\\mathbb{Z}/m\\mathbb{Z}$ 中相应的状态转移矩阵，该矩阵的幂可以实现向前跳步 $k$ 步。\n\n2. 基于一个反馈多项式，定义一个在 $\\mathbb{F}_2$ 上次数为 $d$ 的线性反馈移位寄存器（LFSR），并将其更新表示为 $\\mathbb{F}_2^d$ 中 $d$ 维状态向量的线性变换。推导出其伴随式状态转移矩阵，该矩阵的幂可以实现向前跳步 $k$ 步。\n\n3. 为 $\\mathbb{Z}/m\\mathbb{Z}$ 和 $\\mathbb{F}_2$ 上的矩阵实现矩阵乘法和快速平方求幂算法，以便对于任意方阵 $T$ 和非负整数 $k$，您都可以在相应的代数结构中计算 $T^k$，其中所有算术运算分别在模 $m$（对于 $\\mathbb{Z}/m\\mathbb{Z}$）或模 $2$（对于 $\\mathbb{F}_2$）下进行。\n\n4. 实现一种方法，通过选择起始状态 $\\{s_0, s_L, s_{2L}, \\dots\\}$ 并从每个起始状态生成 $L$ 个连续状态，将生成器的流划分为长度为 $L$ 的不重叠子流。用步长为 $L$ 的转移来表示第 $i$ 个起始状态的选择，并指明这些子流不重叠的条件。\n\n您的程序必须针对下面指定的测试套件，通过与朴素迭代进行比较来验证跳步的正确性，并通过检查其状态的集合交集来验证子流的不重叠性。\n\n测试套件：\n\n- $\\mathbb{Z}/m\\mathbb{Z}$ 上的 LCG：\n  - 模数 $m = 10007$，乘数 $a = 173$，增量 $c = 317$，初始种子 $x_0 = 42$。\n  - 跳步验证：$k = 250$。\n  - 子流：子流长度 $L = 50$，子流数量 $N = 3$。\n\n- $\\mathbb{F}_2$ 上的 LFSR：\n  - 次数 $d = 5$，反馈多项式为 $p(x) = x^5 + x^2 + 1$，在 $\\mathbb{F}_2$ 中解释为递推关系 $x_{n+5} = x_{n+2} + x_n$。\n  - 初始状态向量 $s_0 = [1, 0, 0, 0, 0]$（作为 $\\mathbb{F}_2$ 的元素）。\n  - 跳步验证：$k = 13$。\n  - 子流：子流长度 $L = 7$，子流数量 $N = 4$。\n  - 边界验证：\n    - 跳步的单位元性质：$k = 0$ 必须将 $s_0$ 映射到其自身。\n    - 当子流长度等于周期时的重叠检测：令 $P$ 表示从 $s_0$ 开始的 LFSR 的周期；取 $L = P$ 和 $N = 2$，并检查构造的子流是否重叠。\n\n对于以下每项检查，生成一个布尔结果：\n- 对于 $k = 250$，比较基于矩阵的跳步与朴素迭代的 LCG 跳步相等性。\n- 对于 $L = 50, N = 3$ 的 LCG 子流不重叠性。\n- 对于 $k = 13$，比较基于矩阵的跳步与朴素迭代的 LFSR 跳步相等性。\n- 对于 $L = 7, N = 4$ 的 LFSR 子流不重叠性。\n- LFSR 对于 $k = 0$ 的单位元性质。\n- 当 $L = P$ 且 $N = 2$ 时的 LFSR 子流不重叠性（此项应能检测到适用的重叠情况）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按上述顺序列出的六个布尔结果，格式为方括号内的逗号分隔列表（例如，“[True,False,True,True,True,False]”）。不应打印任何其他文本。\n\n该程序必须是自包含的，并且不需要任何输入。它必须可以在任何现代语言中运行，但您的最终答案必须以符合指定执行环境约束的 Python 代码形式提供。",
            "solution": "我们从线性递推及其作为线性映射的表示的定义开始。在模 $m$ 整数环 $\\mathbb{Z}/m\\mathbb{Z}$ 上的线性递推形式为 $x_{n+1} \\equiv a x_n + c \\pmod{m}$，其中 $a, c \\in \\mathbb{Z}/m\\mathbb{Z}$。由于常数项 $c$ 的存在，这个映射是仿射的，而非线性的。将仿射映射表示为线性映射的一个标准方法是用一个常数分量来增广状态。定义增广状态向量 $y_n \\in (\\mathbb{Z}/m\\mathbb{Z})^2$ 为 $y_n = \\begin{bmatrix} x_n \\\\ 1 \\end{bmatrix}$。那么更新可以写成\n$$\ny_{n+1} = \\begin{bmatrix} a  c \\\\ 0  1 \\end{bmatrix} y_n \\pmod{m}。\n$$\n记转移矩阵为 $T = \\begin{bmatrix} a  c \\\\ 0  1 \\end{bmatrix}$。应用递推关系 $k$ 次对应于将变换复合 $k$ 次，从而得到\n$$\ny_{n+k} = T^k y_n \\pmod{m}，\n$$\n且 $y_{n+k}$ 的第一个分量即为所求的跳步值 $x_{n+k}$。\n\n对于有限域 $\\mathbb{F}_2$ 上的线性反馈移位寄存器（LFSR），考虑一个由反馈多项式 $p(x) = x^d + \\sum_{i=0}^{d-1} c_i x^i$（其中 $c_i \\in \\{0, 1\\}$）导出的次数为 $d$ 的递推。其递推关系在 $\\mathbb{F}_2$ 中为 $x_{n+d} = \\sum_{i=0}^{d-1} c_i x_{n+i}$。定义状态向量 $s_n = \\begin{bmatrix} x_n  x_{n+1}  \\cdots  x_{n+d-1} \\end{bmatrix}^\\top \\in \\mathbb{F}_2^d$。更新后的状态 $s_{n+1}$ 可以表示为\n$$\ns_{n+1} = A s_n \\pmod{2}，\n$$\n其中 $A$ 是伴随式矩阵\n$$\nA = \\begin{bmatrix}\n0  1  0  \\cdots  0 \\\\\n0  0  1  \\cdots  0 \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots \\\\\n0  0  0  \\cdots  1 \\\\\nc_0  c_1  c_2  \\cdots  c_{d-1}\n\\end{bmatrix}。\n$$\n对于具体情况 $p(x) = x^5 + x^2 + 1$，我们有 $d = 5$ 和系数 $c_0 = 1, c_1 = 0, c_2 = 1, c_3 = 0, c_4 = 0$。因此，\n$$\nA = \\begin{bmatrix}\n0  1  0  0  0 \\\\\n0  0  1  0  0 \\\\\n0  0  0  1  0 \\\\\n0  0  0  0  1 \\\\\n1  0  1  0  0\n\\end{bmatrix}。\n$$\n同理，向前跳步 $k$ 步可以通过计算 $A^k$ 实现，即 $s_{n+k} = A^k s_n \\pmod{2}$。\n\n为了高效地计算 $\\mathbb{Z}/m\\mathbb{Z}$ 或 $\\mathbb{F}_2$ 上任意方阵 $T$ 的 $T^k$，我们使用平方求幂法。该方法基于恒等式 $T^{2r} = (T^r)^2$ 和 $T^{2r+1} = (T^r)^2 T$。此方法将乘法次数从 $O(k)$ 减少到 $O(\\log k)$。每次乘法中，我们都执行模 $m$（或对于 $\\mathbb{F}_2$ 则为模 $2$）的算术运算，确保操作保持在相应的代数结构内。\n\n对于子流构造，令 $T$ 为相关结构中的状态转移矩阵，$s_0$ 为初始状态向量。定义步长为 $L$ 的转移 $U = T^L$。那么，第 $i$ 个子流的起始状态为 $s^{(i)}_0 = U^i s_0$。第 $i$ 个子流中的第 $j$ 个状态为 $s^{(i)}_j = T^j s^{(i)}_0$。如果对于不同的 $i$，集合 $\\{ s^{(i)}_j : 0 \\le j  L \\}$ 两两不相交，则这些子流是不重叠的。只要生成器的周期 $P$ 满足 $N L \\le P$，并且我们选择以步长 $L$ 划分的连续段，该条件即成立。\n\n程序中的验证方法：\n- 对于 $\\mathbb{Z}/m\\mathbb{Z}$ 上的 LCG，参数为 $m = 10007, a = 173, c = 317, x_0 = 42$，我们用两种方式计算 $x_{250}$：(i) 通过重复应用 $x_{n+1} \\equiv a x_n + c \\pmod{m}$ 进行朴素迭代，以及 (ii) 通过增广状态转移和 $T^{250}$ 进行矩阵跳步。比较两者是否相等，得出一个布尔结果。\n- 对于同一个 LCG，我们构造 $N = 3$ 个长度为 $L = 50$ 的子流（通过步长 $L$），并检查每个子流中的状态集合是否相交。\n- 对于 $\\mathbb{F}_2$ 上次数为 $d = 5$ 且反馈多项式为 $p(x) = x^5 + x^2 + 1$ 的 LFSR，从 $s_0 = [1, 0, 0, 0, 0]$ 开始，我们通过朴素迭代和矩阵跳步 $A^{13}$ 计算 $s_{13}$，并检查两者是否相等。\n- 对于同一个 LFSR，我们构造 $N = 4$ 个长度为 $L = 7$ 的子流，并通过状态的集合交集来验证其不重叠性。\n- 我们通过检查将 $A^0$ 应用于 $s_0$ 是否返回 $s_0$ 来验证单位元性质 $A^0 = I$。\n- 我们通过迭代直到初始状态 $s_0$ 再次出现来确定周期 $P$，然后测试 $L = P, N = 2$ 的情况下的不重叠性，由于其循环性质，这应该会检测到重叠。\n\n程序按顺序输出一行，列出六个布尔值：LCG 跳步相等性、LCG 不重叠性、LFSR 跳步相等性、LFSR 不重叠性、LFSR 在 $k=0$ 时的单位元性质、以及当 $L = P, N = 2$ 时的 LFSR 不重叠性。此格式满足了对可量化答案和清晰可测试输出的要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef mat_mul_mod(A, B, mod):\n    # Multiply two matrices A (n x m) and B (m x p) modulo mod\n    n = len(A)\n    m = len(A[0])\n    assert m == len(B), \"Inner dimensions must match\"\n    p = len(B[0])\n    C = [[0] * p for _ in range(n)]\n    for i in range(n):\n        for k in range(m):\n            aik = A[i][k]\n            if aik == 0:\n                continue\n            for j in range(p):\n                C[i][j] = (C[i][j] + aik * B[k][j]) % mod\n    return C\n\ndef mat_vec_mul_mod(A, v, mod):\n    # Multiply matrix A (n x m) with vector v (m), modulo mod\n    n = len(A)\n    m = len(A[0])\n    assert m == len(v), \"Dimension mismatch in mat-vec multiply\"\n    res = [0] * n\n    for i in range(n):\n        s = 0\n        row = A[i]\n        for j in range(m):\n            s += row[j] * v[j]\n        res[i] = s % mod\n    return res\n\ndef mat_pow_mod(A, k, mod):\n    # Exponentiation by squaring: compute A^k modulo mod\n    n = len(A)\n    assert n == len(A[0]), \"Matrix must be square\"\n    # Identity matrix\n    I = [[0] * n for _ in range(n)]\n    for i in range(n):\n        I[i][i] = 1 % mod\n    if k == 0:\n        return I\n    # Copy A\n    base = [row[:] for row in A]\n    result = I\n    exp = k\n    while exp > 0:\n        if exp  1:\n            result = mat_mul_mod(result, base, mod)\n        base = mat_mul_mod(base, base, mod)\n        exp >>= 1\n    return result\n\ndef lcg_step(x, a, c, m):\n    return (a * x + c) % m\n\ndef generate_lcg_substreams(a, c, m, x0, L, N):\n    # Using augmented matrix T over Z/mZ\n    T = [[a % m, c % m],\n         [0,      1 % m]]\n    s0 = [x0 % m, 1]\n    substreams = []\n    for i in range(N):\n        # compute start state for substream i: T^(i*L) * s0\n        Ti = mat_pow_mod(T, i * L, m)\n        si = mat_vec_mul_mod(Ti, s0, m)\n        # Generate L states by repeatedly applying T\n        states = []\n        curr = si[:]\n        for _ in range(L):\n            states.append(curr[0])  # record x component\n            curr = mat_vec_mul_mod(T, curr, m)\n        substreams.append(states)\n    return substreams\n\ndef lfsr_period(A, s0):\n    # Compute the period of LFSR starting from s0 by detecting when state repeats\n    mod = 2\n    seen = 0\n    s = s0[:]\n    while True:\n        s = mat_vec_mul_mod(A, s, mod)\n        seen += 1\n        if s == s0:\n            return seen\n\ndef generate_lfsr_substreams(A, s0, L, N):\n    mod = 2\n    T = A\n    substreams = []\n    # Precompute U = T^L\n    U = mat_pow_mod(T, L, mod)\n    # Precompute starts\n    # s^(i)_0 = U^i s0\n    # Alternatively compute U^i by exponentiation each time for simplicity given small sizes\n    for i in range(N):\n        Ti = mat_pow_mod(U, i, mod)\n        si = mat_vec_mul_mod(Ti, s0, mod)\n        # Generate L states\n        states = []\n        curr = si[:]\n        for _ in range(L):\n            states.append(tuple(curr))  # record full state vector\n            curr = mat_vec_mul_mod(T, curr, mod)\n        substreams.append(states)\n    return substreams\n\ndef check_nonoverlap(substreams):\n    # Check pairwise that sets of states do not intersect\n    sets = [set(ss) for ss in substreams]\n    for i in range(len(sets)):\n        for j in range(i + 1, len(sets)):\n            if sets[i].intersection(sets[j]):\n                return False\n    return True\n\ndef solve():\n    results = []\n\n    # Test 1: LCG skip-ahead equality\n    m = 10007\n    a = 173\n    c = 317\n    x0 = 42\n    k = 250\n    # Build augmented transition matrix\n    T_lcg = [[a % m, c % m],\n             [0,      1]]\n    s0_lcg = [x0 % m, 1]\n    Tk = mat_pow_mod(T_lcg, k, m)\n    s_skip = mat_vec_mul_mod(Tk, s0_lcg, m)\n    x_skip_matrix = s_skip[0]\n    # Naive iteration\n    x_naive = x0 % m\n    for _ in range(k):\n        x_naive = lcg_step(x_naive, a, c, m)\n    b1 = (x_skip_matrix == x_naive)\n    results.append(b1)\n\n    # Test 2: LCG nonoverlap substreams\n    L = 50\n    N = 3\n    lcg_substreams = generate_lcg_substreams(a, c, m, x0, L, N)\n    b2 = check_nonoverlap(lcg_substreams)\n    results.append(b2)\n\n    # Test 3: LFSR skip-ahead equality\n    d = 5\n    # Companion-like matrix for p(x) = x^5 + x^2 + 1\n    A = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [1, 0, 1, 0, 0],\n    ]\n    s0 = [1, 0, 0, 0, 0]\n    k_lfsr = 13\n    Ak = mat_pow_mod(A, k_lfsr, 2)\n    s_skip_lfsr = mat_vec_mul_mod(Ak, s0, 2)\n    # Naive iteration\n    s_naive = s0[:]\n    for _ in range(k_lfsr):\n        s_naive = mat_vec_mul_mod(A, s_naive, 2)\n    b3 = (s_skip_lfsr == s_naive)\n    results.append(b3)\n\n    # Test 4: LFSR nonoverlap substreams\n    L_lfsr = 7\n    N_lfsr = 4\n    lfsr_substreams = generate_lfsr_substreams(A, s0, L_lfsr, N_lfsr)\n    b4 = check_nonoverlap(lfsr_substreams)\n    results.append(b4)\n\n    # Test 5: LFSR identity property for k = 0\n    A0 = mat_pow_mod(A, 0, 2)\n    s_id = mat_vec_mul_mod(A0, s0, 2)\n    b5 = (s_id == s0)\n    results.append(b5)\n\n    # Test 6: LFSR overlap when L equals the period and N = 2\n    P = lfsr_period(A, s0)\n    L_eq_P = P\n    N_two = 2\n    lfsr_substreams_period = generate_lfsr_substreams(A, s0, L_eq_P, N_two)\n    # Expect overlap due to cycling\n    b6 = check_nonoverlap(lfsr_substreams_period)\n    results.append(b6)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}