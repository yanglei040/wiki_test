{
    "hands_on_practices": [
        {
            "introduction": "The first and most crucial test of any pseudo-random number generator is statistical: do its outputs appear to be drawn from the intended distribution? This practice guides you through implementing one of the most fundamental tools for this task, the Pearson's chi-square goodness-of-fit test . By binning the output of a generator and comparing the observed counts to the expected uniform distribution, you will develop a practical skill for validating PRNGs and learn to interpret the results, including the conditions under which the test itself is reliable.",
            "id": "3529430",
            "problem": "Consider a Monte Carlo workflow in computational High-Energy Physics (HEP) where uniform pseudo-random numbers on the interval $[0,1)$ are used as the base random variates to sample kinematic variables. A foundational requirement for scientific validity is that the pseudo-random number generator produces values that are consistent with the uniform distribution on $[0,1)$. To test this, one can partition the interval $[0,1)$ into $k$ equal-width bins and perform a chi-square goodness-of-fit test to assess whether the observed bin counts are consistent with uniformity.\n\nStarting from the fundamental base that, under the null hypothesis of uniformity, each draw falls independently into any bin with probability $p = 1/k$, the vector of bin counts follows a multinomial distribution with parameters $N$ and probabilities $(p_1, p_2, \\dots, p_k)$, where $p_i = p$ for all $i$. The expected count in each bin is $E_i = N p$, and the per-bin variance is $\\mathrm{Var}(O_i) = N p (1 - p)$ for each bin count $O_i$. For large $N$ with fixed $k$ such that expected counts are not small, the Pearson chi-square statistic\n$$\n\\chi^2 = \\sum_{i=1}^{k} \\frac{(O_i - E_i)^2}{E_i}\n$$\nis approximately distributed as the chi-square distribution with $k - 1$ degrees of freedom.\n\nYour task is to implement a complete program that:\n- Generates $N$ pseudo-random values on $[0,1)$ using a specified generator type and seed.\n- Bins the values into $k$ equal-width bins on $[0,1)$.\n- Computes the observed counts $O_i$, the expected counts $E_i = N/k$ (identical for all bins), and the per-bin variance $\\mathrm{Var}(O_i) = N \\cdot \\frac{1}{k} \\cdot \\left(1 - \\frac{1}{k}\\right)$ under the multinomial model.\n- Computes the Pearson chi-square statistic $\\chi^2$ and the associated $p$-value using the chi-square distribution with $k - 1$ degrees of freedom.\n- Decides whether to reject the null hypothesis of uniformity at significance level $\\alpha$ by comparing the $p$-value to $\\alpha$.\n- Reports whether the asymptotic chi-square approximation is expected to be valid according to the common rule-of-thumb $E_i \\geq 5$.\n\nYour program must implement two generator types:\n- \"uniform\": high-quality pseudo-random numbers from the default portable computer generator (PCG) via a reproducible seed.\n- \"quantized10\": the same high-quality generator followed by a deterministic quantization that maps each value $u$ to $\\lfloor 10 u \\rfloor / 10$, yielding only $10$ discrete levels in $[0,1)$.\n\nFor each test case, your program must output a list in the following format:\n$[ \\chi^2, \\text{dof}, p\\text{-value}, \\text{reject}, E, \\mathrm{Var}, \\text{approx\\_valid} ]$,\nwhere $\\chi^2$ is a float, $\\text{dof}$ is an integer equal to $k-1$, $p\\text{-value}$ is a float, $\\text{reject}$ is a boolean indicating whether $p\\text{-value} < \\alpha$, $E$ is the expected count per bin (a float equal to $N/k$), $\\mathrm{Var}$ is the per-bin variance (a float equal to $N \\cdot \\frac{1}{k} \\cdot \\left(1 - \\frac{1}{k}\\right)$), and $\\text{approx\\_valid}$ is a boolean indicating whether $E \\geq 5$.\n\nDesign considerations:\n- The binning must be defined by bin edges at $0, \\frac{1}{k}, \\frac{2}{k}, \\dots, 1$, with values $u$ assigned to bin index $\\lfloor k u \\rfloor$ for $u \\in [0,1)$.\n- The final output must aggregate the results of all test cases into a single line representation of a list containing one sublist per test case.\n\nUse the following test suite to exercise different facets of the problem, including the \"happy path\" case, boundary conditions on expected counts, and edge cases where many bins have small or zero counts, along with a deliberately nonuniform generator:\n\n1. $N = 100000$, $k = 100$, $\\alpha = 0.01$, generator type \"uniform\", seed $12345$.\n2. $N = 5000$, $k = 1000$, $\\alpha = 0.05$, generator type \"uniform\", seed $54321$.\n3. $N = 10000$, $k = 5000$, $\\alpha = 0.05$, generator type \"uniform\", seed $1$.\n4. $N = 100$, $k = 10$, $\\alpha = 0.1$, generator type \"uniform\", seed $2025$.\n5. $N = 10000$, $k = 100$, $\\alpha = 0.001$, generator type \"quantized10\", seed $7$.\n6. $N = 1000$, $k = 1000$, $\\alpha = 0.05$, generator type \"uniform\", seed $314159$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list as described above and appears in the same order as the test suite (for example, $[[\\dots],[\\dots],\\dots]$). No physical units or angle units apply to this problem.",
            "solution": "The problem requires the implementation of a statistical validation procedure for pseudo-random number generators (PRNGs), a critical task in computational science, particularly for Monte Carlo simulations in high-energy physics. The core of the task is to perform a Pearson's chi-square ($\\chi^2$) goodness-of-fit test to assess whether a PRNG's output is consistent with a uniform distribution on the interval $[0,1)$. The solution will be designed based on fundamental principles of probability and statistics.\n\nThe logical procedure is as follows:\n$1$. The null hypothesis, $H_0$, posits that the generated numbers are drawn from a continuous uniform distribution on $[0,1)$.\n$2$. To test this, the interval $[0,1)$ is partitioned into $k$ contiguous, equal-width subintervals (bins). Under $H_0$, the probability of a random variate falling into any specific bin is identical for all bins, with a value of $p = 1/k$.\n$3$. A total of $N$ random variates are generated. The counts of variates falling into each bin, denoted by the vector $(O_1, O_2, \\dots, O_k)$, are recorded. This vector of observed counts mathematically follows a multinomial distribution with parameters $N$ (number of trials) and $(p_1, p_2, \\dots, p_k)$ (event probabilities), where $p_i = 1/k$ for all $i \\in \\{1, \\dots, k\\}$.\n\nFrom these foundational principles, we derive the necessary quantities for the test. The expected count for each bin $i$, denoted $E_i$, is given by the mean of the corresponding marginal binomial distribution, which is $E_i = N p_i$. Since all $p_i$ are equal to $1/k$, the expected count is the same for all bins:\n$$\nE = E_i = N \\cdot \\frac{1}{k}\n$$\nThe variance of the count in a single bin $i$, $\\mathrm{Var}(O_i)$, is given by the variance of a binomial variable:\n$$\n\\mathrm{Var}(O_i) = N p_i (1 - p_i) = N \\cdot \\frac{1}{k} \\left(1 - \\frac{1}{k}\\right)\n$$\nThis variance quantifies the expected random fluctuation of bin counts around their mean value.\n\nThe Pearson's chi-square test statistic, $\\chi^2$, is constructed to measure the total discrepancy between the observed counts, $O_i$, and the expected counts under the null hypothesis, $E$. It is defined as the sum of the squared differences, normalized by the expected count:\n$$\n\\chi^2 = \\sum_{i=1}^{k} \\frac{(O_i - E)^2}{E}\n$$\nA large value of this statistic indicates a significant deviation from the expected uniform distribution. A key result in statistics, the Pearson's chi-square theorem, states that for a sufficiently large sample size $N$, this $\\chi^2$ statistic is approximately distributed as a chi-square distribution. The number of degrees of freedom ($\\text{dof}$) for this distribution is $\\nu = k - 1$. The one degree of freedom is lost because of the linear constraint imposed on the observed counts, namely that their sum must equal the total number of samples: $\\sum_{i=1}^{k} O_i = N$.\n\nThe validity of this chi-square approximation is contingent on the expected counts not being too small. A widely used heuristic, specified in the problem, is that the approximation is considered reliable if the expected count in every bin is at least $5$, i.e., $E \\ge 5$.\n\nThe hypothesis test is then conducted by calculating the $p$-value. The $p$-value represents the probability of observing a $\\chi^2$ statistic at least as large as the one computed from the data, assuming the null hypothesis $H_0$ is true. For this right-tailed test, it is given by:\n$$\np\\text{-value} = P(\\chi^2_{\\nu} \\ge \\chi^2_{\\text{observed}})\n$$\nwhere $\\chi^2_{\\nu}$ is a random variable following the chi-square distribution with $\\nu = k-1$ degrees of freedom. This probability is computed using the survival function ($1 - \\text{CDF}$) of the chi-square distribution.\n\nFinally, a decision is made by comparing the $p$-value to a pre-determined significance level, $\\alpha$. If the $p$-value is less than $\\alpha$ ($p<\\alpha$), it implies that the observed data is very unlikely to have occurred by chance if the generator were truly uniform. Consequently, we reject the null hypothesis and conclude that there is statistically significant evidence that the PRNG is not uniform. If $p \\ge \\alpha$, we fail to reject the null hypothesis.\n\nThe implementation will proceed as follows:\n- For each test case defined by parameters $(N, k, \\alpha, \\text{generator\\_type}, \\text{seed})$, a reproducible `numpy` PRNG (`PCG64`) is initialized with the given seed.\n- $N$ random numbers are generated. For the `\"uniform\"` type, the generator's output is used directly. For the `\"quantized10\"` type, the output values $u$ are transformed via the function $u \\mapsto \\lfloor 10u \\rfloor / 10$, which introduces a clear non-uniformity by restricting values to $10$ discrete levels.\n- The `numpy.histogram` function is used to efficiently bin the generated samples into $k$ equal-width bins on $[0,1)$ and obtain the observed counts $O_i$.\n- The derived quantities—$E$, $\\mathrm{Var}(O_i)$, $\\chi^2$, and the degrees of freedom $\\nu$—are calculated according to their definitions.\n- The `scipy.stats.chi2.sf` function is used to compute the $p$-value from the $\\chi^2$ statistic and degrees of freedom.\n- The booleans for rejecting $H_0$ and for the validity of the chi-square approximation are determined.\n- The results for each test case are collected and formatted into the specified list-of-lists structure for the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, k, alpha, generator_type, seed)\n        (100000, 100, 0.01, \"uniform\", 12345),\n        (5000, 1000, 0.05, \"uniform\", 54321),\n        (10000, 5000, 0.05, \"uniform\", 1),\n        (100, 10, 0.1, \"uniform\", 2025),\n        (10000, 100, 0.001, \"quantized10\", 7),\n        (1000, 1000, 0.05, \"uniform\", 314159),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, k, alpha, gen_type, seed = params\n        result = perform_chi_square_test(N, k, alpha, gen_type, seed)\n        results.append(result)\n\n    # Format the final output string as a list of lists, without extra spaces.\n    # e.g., [[val1,val2,...],[val1,val2,...]]\n    sublist_strs = []\n    for sublist in results:\n        # str(item) for bool produces 'True'/'False' with capital letters, which is standard for Python.\n        item_strs = [str(item) for item in sublist]\n        sublist_strs.append(f\"[{','.join(item_strs)}]\")\n    \n    final_output_str = f\"[{','.join(sublist_strs)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\ndef perform_chi_square_test(N, k, alpha, generator_type, seed):\n    \"\"\"\n    Performs a chi-square goodness-of-fit test for a single test case.\n\n    Args:\n        N (int): Number of pseudo-random values to generate.\n        k (int): Number of bins to partition the [0,1) interval into.\n        alpha (float): Significance level for the hypothesis test.\n        generator_type (str): Type of generator (\"uniform\" or \"quantized10\").\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        list: A list containing the test results in the specified format:\n              [chi^2, dof, p-value, reject, E, Var, approx_valid]\n    \"\"\"\n    # 1. Generate pseudo-random numbers\n    rng = np.random.default_rng(seed)\n    if generator_type == \"uniform\":\n        samples = rng.random(size=N)\n    elif generator_type == \"quantized10\":\n        u_samples = rng.random(size=N)\n        samples = np.floor(10 * u_samples) / 10\n    else:\n        # This case should not be reached with the given problem statement.\n        raise ValueError(f\"Unknown generator type: {generator_type}\")\n\n    # 2. Bin the values to get observed counts\n    # np.histogram bins are [min, max] with bins=k and range=(0,1) resulting in\n    # bins of width 1/k. The last bin is inclusive on the right edge.\n    observed_counts, _ = np.histogram(samples, bins=k, range=(0, 1))\n\n    # 3. Compute expected counts and degrees of freedom\n    expected_count = N / k\n    dof = k - 1\n    \n    # 4. Compute Pearson's chi-square statistic\n    # The case expected_count=0 is only possible if N=0, which is not the case here.\n    # The sum is over all k bins.\n    chi2_stat = np.sum((observed_counts - expected_count)**2 / expected_count)\n\n    # 5. Calculate p-value\n    # The p-value is the probability of observing a chi-square value as extreme\n    # or more extreme than the one calculated, given the null hypothesis is true.\n    # This is given by the survival function (1 - CDF).\n    p_value = chi2.sf(chi2_stat, dof)\n\n    # 6. Decide whether to reject the null hypothesis\n    reject_null = p_value  alpha\n\n    # 7. Report if the asymptotic chi-square approximation is valid\n    # Based on the common rule-of-thumb E_i >= 5.\n    approx_valid = expected_count >= 5\n\n    # 8. Compute the per-bin variance under the multinomial model\n    variance = N * (1 / k) * (1 - 1 / k)\n\n    return [\n        float(chi2_stat),\n        int(dof),\n        float(p_value),\n        bool(reject_null),\n        float(expected_count),\n        float(variance),\n        bool(approx_valid),\n    ]\n\n# Execute the main function when the script is run.\nsolve()\n```"
        },
        {
            "introduction": "Modern scientific computing relies heavily on parallel processing to tackle large-scale simulations. However, naively running a PRNG with different seeds on parallel processors does not guarantee statistically independent streams. This practice introduces the robust technique of 'skip-ahead' to create verifiably non-overlapping substreams from a single generator sequence . You will explore the elegant connection between linear recurrences and matrix algebra, implementing fast matrix exponentiation to jump forward in a sequence, a cornerstone for building parallel-safe PRNGs.",
            "id": "3333414",
            "problem": "Consider linear pseudo-random number generators defined by linear recurrences on a finite algebraic structure and their state-transition representation as linear maps. Use the following foundational bases: (i) the definition of a linear recurrence over the ring of integers modulo $m$, denoted $\\mathbb{Z}/m\\mathbb{Z}$, and over the finite field with two elements, denoted $\\mathbb{F}_2$, (ii) the interpretation of generator state evolution as repeated application of a linear transformation represented by a matrix, and (iii) the fact that composing a linear map $k$ times corresponds to taking the $k$-th power of its matrix representation. From these bases, derive a skip-ahead method and design a substream construction that ensures nonoverlapping fixed-length segments when the underlying period is sufficiently large.\n\nYou must solve the following tasks.\n\n1. Define a linear congruential generator (LCG) over $\\mathbb{Z}/m\\mathbb{Z}$ with recurrence $x_{n+1} \\equiv a x_n + c \\pmod{m}$, where $x_n \\in \\mathbb{Z}/m\\mathbb{Z}$. Show how to embed the affine map into a linear map by augmenting the state with a constant component, and derive the corresponding state-transition matrix in $\\mathbb{Z}/m\\mathbb{Z}$ whose powers implement skip-ahead by $k$ steps.\n\n2. Define a linear feedback shift register (LFSR) over $\\mathbb{F}_2$ of degree $d$ based on a feedback polynomial and express its update as a linear transformation of the $d$-dimensional state vector in $\\mathbb{F}_2^d$. Derive the companion-like state-transition matrix whose powers implement skip-ahead by $k$ steps.\n\n3. Implement matrix multiplication and fast exponentiation by squaring for matrices over $\\mathbb{Z}/m\\mathbb{Z}$ and over $\\mathbb{F}_2$ so that for any square matrix $T$ and nonnegative integer $k$, you can compute $T^k$ in the respective algebra with all arithmetic performed modulo $m$ (for $\\mathbb{Z}/m\\mathbb{Z}$) or modulo $2$ (for $\\mathbb{F}_2$).\n\n4. Implement a method to partition a generator’s stream into nonoverlapping substreams of fixed length $L$ by selecting starting states $\\{s_0, s_L, s_{2L}, \\dots\\}$ and generating $L$ consecutive states from each start. Express the selection of the $i$-th starting state in terms of the $L$-step transition, and specify the condition under which these substreams are nonoverlapping.\n\nYour program must, for the specified test suite below, verify correctness of skip-ahead versus naive iteration and verify nonoverlap of substreams by checking set intersections of their states.\n\nTest Suite:\n\n- LCG over $\\mathbb{Z}/m\\mathbb{Z}$:\n  - Modulus $m = 10007$, multiplier $a = 173$, increment $c = 317$, initial seed $x_0 = 42$.\n  - Skip-ahead verification: $k = 250$.\n  - Substreams: substream length $L = 50$, number of substreams $N = 3$.\n\n- LFSR over $\\mathbb{F}_2$:\n  - Degree $d = 5$ with feedback polynomial $p(x) = x^5 + x^2 + 1$ interpreted as the recurrence $x_{n+5} = x_{n+2} + x_n$ in $\\mathbb{F}_2$.\n  - Initial state vector $s_0 = [1, 0, 0, 0, 0]$ (as elements of $\\mathbb{F}_2$).\n  - Skip-ahead verification: $k = 13$.\n  - Substreams: substream length $L = 7$, number of substreams $N = 4$.\n  - Boundary verifications:\n    - Identity property for skip-ahead: $k = 0$ must map $s_0$ to itself.\n    - Overlap detection when the substream length equals the period: let $P$ denote the period of the LFSR starting from $s_0$; take $L = P$ and $N = 2$ and check whether the constructed substreams overlap.\n\nFor each of the following checks, produce a boolean result:\n- LCG skip-ahead equality for $k = 250$ comparing matrix-based skip-ahead to naive iteration.\n- LCG substream nonoverlap for $L = 50$, $N = 3$.\n- LFSR skip-ahead equality for $k = 13$ comparing matrix-based skip-ahead to naive iteration.\n- LFSR substream nonoverlap for $L = 7$, $N = 4$.\n- LFSR identity property for $k = 0$.\n- LFSR substream nonoverlap when $L = P$ and $N = 2$ (this should detect overlap as applicable).\n\nFinal Output Format:\nYour program should produce a single line of output containing the six boolean results, in the order listed above, as a comma-separated list enclosed in square brackets (e.g., \"[True,False,True,True,True,False]\"). No additional text should be printed.\n\nThe program must be self-contained and require no input. It must be runnable in any modern language, but your final answer must be provided as Python code conforming to the specified execution environment constraints.",
            "solution": "We start from the definition of linear recurrences and their representation as linear maps. A linear recurrence over the ring of integers modulo $m$, $\\mathbb{Z}/m\\mathbb{Z}$, has the form $x_{n+1} \\equiv a x_n + c \\pmod{m}$, where $a, c \\in \\mathbb{Z}/m\\mathbb{Z}$. This map is affine, not linear, because of the constant term $c$. A standard method to represent affine maps as linear maps is to augment the state with a constant component. Define the augmented state vector $y_n \\in (\\mathbb{Z}/m\\mathbb{Z})^2$ by $y_n = \\begin{bmatrix} x_n \\\\ 1 \\end{bmatrix}$. Then the update can be written as\n$$\ny_{n+1} = \\begin{bmatrix} a  c \\\\ 0  1 \\end{bmatrix} y_n \\pmod{m}.\n$$\nDenote the transition matrix by $T = \\begin{bmatrix} a  c \\\\ 0  1 \\end{bmatrix}$. Applying the recurrence $k$ times corresponds to composing the transformation $k$ times, which yields\n$$\ny_{n+k} = T^k y_n \\pmod{m},\n$$\nand the first component of $y_{n+k}$ is $x_{n+k}$, the desired skip-ahead value.\n\nFor a linear feedback shift register (LFSR) over the finite field $\\mathbb{F}_2$, consider a degree $d$ recurrence induced by a feedback polynomial $p(x) = x^d + \\sum_{i=0}^{d-1} c_i x^i$ with $c_i \\in \\{0, 1\\}$. The recurrence relation is $x_{n+d} = \\sum_{i=0}^{d-1} c_i x_{n+i}$ in $\\mathbb{F}_2$. Define the state vector $s_n = \\begin{bmatrix} x_n  x_{n+1}  \\cdots  x_{n+d-1} \\end{bmatrix}^\\top \\in \\mathbb{F}_2^d$. The update $s_{n+1}$ can be expressed as\n$$\ns_{n+1} = A s_n \\pmod{2},\n$$\nwhere $A$ is the companion-like matrix\n$$\nA = \\begin{bmatrix}\n0  1  0  \\cdots  0 \\\\\n0  0  1  \\cdots  0 \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots \\\\\n0  0  0  \\cdots  1 \\\\\nc_0  c_1  c_2  \\cdots  c_{d-1}\n\\end{bmatrix}.\n$$\nFor the concrete case $p(x) = x^5 + x^2 + 1$, we have $d = 5$ and coefficients $c_0 = 1$, $c_1 = 0$, $c_2 = 1$, $c_3 = 0$, $c_4 = 0$. Thus,\n$$\nA = \\begin{bmatrix}\n0  1  0  0  0 \\\\\n0  0  1  0  0 \\\\\n0  0  0  1  0 \\\\\n0  0  0  0  1 \\\\\n1  0  1  0  0\n\\end{bmatrix}.\n$$\nAs before, the skip-ahead by $k$ steps is implemented by $A^k$, i.e., $s_{n+k} = A^k s_n \\pmod{2}$.\n\nTo compute $T^k$ efficiently for any square matrix $T$ over $\\mathbb{Z}/m\\mathbb{Z}$ or $\\mathbb{F}_2$, we use exponentiation by squaring, which follows from the identity $T^{2r} = (T^r)^2$ and $T^{2r+1} = (T^r)^2 T$. This method reduces the number of multiplications from $O(k)$ to $O(\\log k)$. At each multiplication, we perform arithmetic modulo $m$ (or modulo $2$ for $\\mathbb{F}_2$), ensuring that the operations remain within the appropriate algebraic structure.\n\nFor substream construction, let $T$ be the state-transition matrix in the relevant structure, and $s_0$ the initial state vector. Define the $L$-step transition $U = T^L$. Then the starting state of the $i$-th substream is $s^{(i)}_0 = U^i s_0$. The $j$-th state within the $i$-th substream is $s^{(i)}_j = T^j s^{(i)}_0$. These substreams are nonoverlapping if the sets $\\{ s^{(i)}_j : 0 \\le j  L \\}$ across different $i$ are pairwise disjoint, which holds whenever the generator’s period $P$ satisfies $N L \\le P$ and we choose contiguous segments partitioned by stride $L$.\n\nVerification methodology in the program:\n- For the LCG over $\\mathbb{Z}/m\\mathbb{Z}$ with $m = 10007$, $a = 173$, $c = 317$, $x_0 = 42$, we compute $x_{250}$ in two ways: (i) naive iteration by applying $x_{n+1} \\equiv a x_n + c \\pmod{m}$ repeatedly, and (ii) matrix skip-ahead via the augmented state transition and $T^{250}$. Equality yields a boolean result.\n- For the same LCG, we construct $N = 3$ substreams of length $L = 50$ via stride $L$ and check that the sets of states in each substream do not intersect.\n- For the LFSR over $\\mathbb{F}_2$ of degree $d = 5$ with $p(x) = x^5 + x^2 + 1$, starting from $s_0 = [1, 0, 0, 0, 0]$, we compute $s_{13}$ by naive iteration and by matrix skip-ahead $A^{13}$ and check equality.\n- For the same LFSR, we construct $N = 4$ substreams of length $L = 7$ and verify nonoverlap by set intersection of states.\n- We verify the identity property $A^0 = I$ by checking that applying $A^0$ to $s_0$ returns $s_0$.\n- We determine the period $P$ by iterating until the initial state $s_0$ is revisited and then test the case $L = P$, $N = 2$ for nonoverlap, which should indicate overlap due to the cyclic nature.\n\nThe program outputs a single line listing six booleans, in order: LCG skip-ahead equality, LCG nonoverlap, LFSR skip-ahead equality, LFSR nonoverlap, LFSR identity at $k = 0$, LFSR nonoverlap when $L = P$, $N = 2$. This format satisfies the requirement for quantifiable answers and a clear, testable output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef mat_mul_mod(A, B, mod):\n    # Multiply two matrices A (n x m) and B (m x p) modulo mod\n    n = len(A)\n    m = len(A[0])\n    assert m == len(B), \"Inner dimensions must match\"\n    p = len(B[0])\n    C = [[0] * p for _ in range(n)]\n    for i in range(n):\n        for k in range(m):\n            aik = A[i][k]\n            if aik == 0:\n                continue\n            for j in range(p):\n                C[i][j] = (C[i][j] + aik * B[k][j]) % mod\n    return C\n\ndef mat_vec_mul_mod(A, v, mod):\n    # Multiply matrix A (n x m) with vector v (m), modulo mod\n    n = len(A)\n    m = len(A[0])\n    assert m == len(v), \"Dimension mismatch in mat-vec multiply\"\n    res = [0] * n\n    for i in range(n):\n        s = 0\n        row = A[i]\n        for j in range(m):\n            s += row[j] * v[j]\n        res[i] = s % mod\n    return res\n\ndef mat_pow_mod(A, k, mod):\n    # Exponentiation by squaring: compute A^k modulo mod\n    n = len(A)\n    assert n == len(A[0]), \"Matrix must be square\"\n    # Identity matrix\n    I = [[0] * n for _ in range(n)]\n    for i in range(n):\n        I[i][i] = 1 % mod\n    if k == 0:\n        return I\n    # Copy A\n    base = [row[:] for row in A]\n    result = I\n    exp = k\n    while exp > 0:\n        if exp  1:\n            result = mat_mul_mod(result, base, mod)\n        base = mat_mul_mod(base, base, mod)\n        exp >>= 1\n    return result\n\ndef lcg_step(x, a, c, m):\n    return (a * x + c) % m\n\ndef generate_lcg_substreams(a, c, m, x0, L, N):\n    # Using augmented matrix T over Z/mZ\n    T = [[a % m, c % m],\n         [0,      1 % m]]\n    s0 = [x0 % m, 1]\n    substreams = []\n    for i in range(N):\n        # compute start state for substream i: T^(i*L) * s0\n        Ti = mat_pow_mod(T, i * L, m)\n        si = mat_vec_mul_mod(Ti, s0, m)\n        # Generate L states by repeatedly applying T\n        states = []\n        curr = si[:]\n        for _ in range(L):\n            states.append(curr[0])  # record x component\n            curr = mat_vec_mul_mod(T, curr, m)\n        substreams.append(states)\n    return substreams\n\ndef lfsr_period(A, s0):\n    # Compute the period of LFSR starting from s0 by detecting when state repeats\n    mod = 2\n    seen = 0\n    s = s0[:]\n    while True:\n        s = mat_vec_mul_mod(A, s, mod)\n        seen += 1\n        if s == s0:\n            return seen\n\ndef generate_lfsr_substreams(A, s0, L, N):\n    mod = 2\n    T = A\n    substreams = []\n    # Precompute U = T^L\n    U = mat_pow_mod(T, L, mod)\n    # Precompute starts\n    # s^(i)_0 = U^i s0\n    Ui = [[1 if r == c else 0 for c in range(len(T))] for r in range(len(T))]\n    # Alternatively compute U^i by exponentiation each time for simplicity given small sizes\n    for i in range(N):\n        Ti = mat_pow_mod(U, i, mod)\n        si = mat_vec_mul_mod(Ti, s0, mod)\n        # Generate L states\n        states = []\n        curr = si[:]\n        for _ in range(L):\n            states.append(tuple(curr))  # record full state vector\n            curr = mat_vec_mul_mod(T, curr, mod)\n        substreams.append(states)\n    return substreams\n\ndef check_nonoverlap(substreams):\n    # Check pairwise that sets of states do not intersect\n    sets = [set(ss) for ss in substreams]\n    for i in range(len(sets)):\n        for j in range(i + 1, len(sets)):\n            if sets[i].intersection(sets[j]):\n                return False\n    return True\n\ndef solve():\n    results = []\n\n    # Test 1: LCG skip-ahead equality\n    m = 10007\n    a = 173\n    c = 317\n    x0 = 42\n    k = 250\n    # Build augmented transition matrix\n    T_lcg = [[a % m, c % m],\n             [0,      1]]\n    s0_lcg = [x0 % m, 1]\n    Tk = mat_pow_mod(T_lcg, k, m)\n    s_skip = mat_vec_mul_mod(Tk, s0_lcg, m)\n    x_skip_matrix = s_skip[0]\n    # Naive iteration\n    x_naive = x0 % m\n    for _ in range(k):\n        x_naive = lcg_step(x_naive, a, c, m)\n    b1 = (x_skip_matrix == x_naive)\n    results.append(b1)\n\n    # Test 2: LCG nonoverlap substreams\n    L = 50\n    N = 3\n    lcg_substreams = generate_lcg_substreams(a, c, m, x0, L, N)\n    b2 = check_nonoverlap(lcg_substreams)\n    results.append(b2)\n\n    # Test 3: LFSR skip-ahead equality\n    d = 5\n    # Companion-like matrix for p(x) = x^5 + x^2 + 1\n    A = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [1, 0, 1, 0, 0],\n    ]\n    s0 = [1, 0, 0, 0, 0]\n    k_lfsr = 13\n    Ak = mat_pow_mod(A, k_lfsr, 2)\n    s_skip_lfsr = mat_vec_mul_mod(Ak, s0, 2)\n    # Naive iteration\n    s_naive = s0[:]\n    for _ in range(k_lfsr):\n        s_naive = mat_vec_mul_mod(A, s_naive, 2)\n    b3 = (s_skip_lfsr == s_naive)\n    results.append(b3)\n\n    # Test 4: LFSR nonoverlap substreams\n    L_lfsr = 7\n    N_lfsr = 4\n    lfsr_substreams = generate_lfsr_substreams(A, s0, L_lfsr, N_lfsr)\n    b4 = check_nonoverlap(lfsr_substreams)\n    results.append(b4)\n\n    # Test 5: LFSR identity property for k = 0\n    A0 = mat_pow_mod(A, 0, 2)\n    s_id = mat_vec_mul_mod(A0, s0, 2)\n    b5 = (s_id == s0)\n    results.append(b5)\n\n    # Test 6: LFSR overlap when L equals the period and N = 2\n    P = lfsr_period(A, s0)\n    L_eq_P = P\n    N_two = 2\n    lfsr_substreams_period = generate_lfsr_substreams(A, s0, L_eq_P, N_two)\n    # Expect overlap due to cycling\n    b6 = check_nonoverlap(lfsr_substreams_period)\n    results.append(b6)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While linear generators like XORSHIFT are fast and possess good statistical properties for simulation, their underlying linearity makes them predictable and insecure for cryptography. This exercise delves into the structural analysis of such generators by treating them as linear systems over the finite field $\\mathbb{F}_2$ . You will implement the Berlekamp-Massey algorithm to determine the 'linear complexity' of an output stream and use the concept of an observability matrix to demonstrate how the generator's internal state can be fully reconstructed from a short sequence of its outputs, providing a concrete illustration of their cryptographic weakness.",
            "id": "3333430",
            "problem": "You are given a family of pseudo-random number generators based on Exclusive OR shift (XORSHIFT) updates, modeled as linear transformations over the finite field of two elements. Consider a state consisting of two words of width $w$ bits, denoted by the column vector $S_t \\in \\{0,1\\}^{2w}$ at discrete time $t$. The state update is defined by a linear map over $\\mathbb{F}_2$ as follows. Let $s_{0,t} \\in \\{0,1\\}^w$ and $s_{1,t} \\in \\{0,1\\}^w$ denote the top and bottom halves of the state vector $S_t$. The generator uses three nonnegative integers $(a,b,c)$ with $a \\geq 0$, $b \\geq 0$, $c \\geq 0$, and performs the update\n$$\ns_{0,t+1} := s_{1,t}, \\quad t := s_{0,t} \\oplus (s_{0,t} \\ll a) \\oplus (s_{0,t} \\gg b), \\quad s_{1,t+1} := t \\oplus (s_{1,t} \\gg c),\n$$\nwhere $\\oplus$ denotes bitwise addition modulo $2$, $\\ll$ is a left shift within $w$ bits with zero fill, and $\\gg$ is a right shift within $w$ bits with zero fill. All operations are linear over $\\mathbb{F}_2$. We represent this update as a matrix $A \\in \\{0,1\\}^{2w \\times 2w}$ such that $S_{t+1} = A S_t$ over $\\mathbb{F}_2$. The generator produces a single-bit observation at each step via a known output mask $v \\in \\{0,1\\}^{2w}$:\n$$\nb_t := v^\\top S_t \\in \\{0,1\\},\n$$\nwhere $b_t$ is the observed bit at time $t$.\n\nThe tasks are:\n- Implement the Berlekamp–Massey algorithm (BMA) over $\\mathbb{F}_2$ to estimate the linear complexity profile $L(n)$ of the bitstream $\\{b_t\\}_{t=0}^{n-1}$ for increasing prefix lengths, where the linear complexity $L(n)$ is the length of the shortest Linear Feedback Shift Register (LFSR) that can generate the first $n$ bits of the sequence.\n- Construct the state transition matrix $A$ for the XORSHIFT update above using block matrices over $\\mathbb{F}_2$. Let $I_w$ denote the $w \\times w$ identity matrix, $L_a \\in \\{0,1\\}^{w \\times w}$ denote the left-shift-by-$a$ matrix, and $R_b \\in \\{0,1\\}^{w \\times w}$ denote the right-shift-by-$b$ matrix. Using the definitions of the update, derive the block structure\n$$\nA = \\begin{pmatrix}\n0_w  I_w \\\\\nI_w + L_a + R_b  R_c\n\\end{pmatrix},\n$$\nwhere $0_w$ is the $w \\times w$ zero matrix and addition is modulo $2$.\n- Using the known linearity, form the observability matrix over $\\mathbb{F}_2$,\n$$\n\\mathcal{O}_s = \\begin{pmatrix}\nv^\\top \\\\\nv^\\top A \\\\\nv^\\top A^2 \\\\\n\\vdots \\\\\nv^\\top A^{s-1}\n\\end{pmatrix} \\in \\{0,1\\}^{s \\times 2w},\n$$\nand compute the minimal sample size $s$ such that $\\operatorname{rank}_{\\mathbb{F}_2}(\\mathcal{O}_s) = 2w$ (if such $s$ exists within the available samples). When this rank condition holds, reconstruct the initial state $S_0$ from the first $s$ observed bits by solving the linear system $\\mathcal{O}_s S_0 = \\mathbf{b}$ over $\\mathbb{F}_2$, where $\\mathbf{b} = (b_0,\\dots,b_{s-1})^\\top$.\n\nYou must start from fundamental bases and core definitions relevant to stochastic simulation and Monte Carlo methods, specifically:\n- The definition of linear complexity and its estimation via the Berlekamp–Massey algorithm over $\\mathbb{F}_2$.\n- The state-space representation of linear systems over finite fields, including the construction of observability matrices and rank conditions for reconstructibility.\n\nDo not use shortcut formulas beyond these principles. Derivations must be shown to be consistent with the above definitions.\n\nFor each test case, you must:\n- Generate a bitstream of length $N$ from the specified XORSHIFT instance using its $A$ and $v$.\n- Compute the linear complexity $L(N)$ and the profile $L(n)$ for $n=1,\\dots,N$ using the Berlekamp–Massey algorithm.\n- Determine the minimal $s$ such that $\\operatorname{rank}_{\\mathbb{F}_2}(\\mathcal{O}_s) = 2w$ within the available samples; if no such $s$ exists, report $s=-1$ and do not attempt reconstruction.\n- When possible, reconstruct $S_0$ using exactly $2w$ observed outputs and verify whether the reconstructed state reproduces those $2w$ outputs under the same $A$ and $v$. Report a boolean indicating success.\n\nTest Suite:\n- Test Case $1$ (happy path, parity output):\n  - Word size $w=16$.\n  - Shifts $(a,b,c) = (7,9,13)$.\n  - Initial state words $s_{0,0} = \\text{hex } \\texttt{0xACE1}$, $s_{1,0} = \\text{hex } \\texttt{0xBEEF}$.\n  - Output mask $v$ equals the parity of the second word: the first $w$ entries of $v$ are $0$, the last $w$ entries of $v$ are $1$.\n  - Bitstream length $N=512$.\n- Test Case $2$ (boundary, single-bit output):\n  - Word size $w=8$.\n  - Shifts $(a,b,c) = (3,5,1)$.\n  - Initial state words $s_{0,0} = \\text{hex } \\texttt{0x5D}$, $s_{1,0} = \\text{hex } \\texttt{0xC3}$.\n  - Output mask $v$ selects the least significant bit of the second word: the first $w$ entries of $v$ are $0$, the last $w$ entries of $v$ are $0$ except the least significant bit, which is $1$.\n  - Bitstream length $N=256$.\n- Test Case $3$ (edge case, non-observable output):\n  - Word size $w=8$.\n  - Shifts $(a,b,c) = (3,5,1)$.\n  - Initial state words $s_{0,0} = \\text{hex } \\texttt{0x5D}$, $s_{1,0} = \\text{hex } \\texttt{0xC3}$.\n  - Output mask $v$ is the zero vector of length $2w$, so $b_t = 0$ for all $t$.\n  - Bitstream length $N=64$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output a sub-list $[s^\\star, L(N), \\text{success}]$, where $s^\\star$ is the minimal sample size achieving full observability rank (or $-1$ if none within the provided $N$), $L(N)$ is the linear complexity of the first $N$ bits, and $\\text{success}$ is a boolean indicating whether reconstructing $S_0$ using exactly $2w$ outputs matched those outputs. Example format: $[[s_1,L_1,\\text{True}],[s_2,L_2,\\text{True}],[s_3,L_3,\\text{False}]]$. All outputs are pure numbers or booleans without units.",
            "solution": "The problem requires an analysis of a specific family of XORSHIFT-based pseudo-random number generators from the perspective of linear systems over the finite field $\\mathbb{F}_2$. We must implement algorithms to determine the linear complexity of the output bitstream and to test for state observability, allowing for the potential reconstruction of the generator's initial state. The solution will be built upon first principles of linear algebra over finite fields and linear systems theory.\n\n### 1. State-Space Representation of the XORSHIFT Generator\n\nThe generator's state at time $t$ is a vector $S_t \\in \\{0,1\\}^{2w}$, composed of two $w$-bit words, $s_{0,t}$ and $s_{1,t}$, such that $S_t = \\begin{pmatrix} s_{0,t} \\\\ s_{1,t} \\end{pmatrix}$. The state update is a linear transformation $S_{t+1} = A S_t$ for a matrix $A \\in \\{0,1\\}^{2w \\times 2w}$. We derive the structure of $A$ from the update rules.\n\nThe update for the top half of the state is $s_{0,t+1} = s_{1,t}$. In matrix form, this can be written as:\n$$\ns_{0,t+1} = 0_w s_{0,t} + I_w s_{1,t}\n$$\nwhere $I_w$ is the $w \\times w$ identity matrix and $0_w$ is the $w \\times w$ zero matrix. This gives the top block row of $A$ as $[0_w \\quad I_w]$.\n\nThe update for the bottom half involves an intermediate value $t = s_{0,t} \\oplus (s_{0,t} \\ll a) \\oplus (s_{0,t} \\gg b)$, and then $s_{1,t+1} = t \\oplus (s_{1,t} \\gg c)$. Combining these gives:\n$$\ns_{1,t+1} = s_{0,t} \\oplus (s_{0,t} \\ll a) \\oplus (s_{0,t} \\gg b) \\oplus (s_{1,t} \\gg c)\n$$\nThe bitwise operations (XOR $\\oplus$, left shift $\\ll$, right shift $\\gg$) are linear over $\\mathbb{F}_2$. We can represent them with matrices. Let $L_a$ be the matrix for a left shift by $a$, and $R_b$ be the matrix for a right shift by $b$. An element $(L_a)_{i,j}=1$ if $i=j-a$ and $0$ otherwise. An element $(R_b)_{i,j}=1$ if $i=j+b$ and $0$ otherwise (with $0$-based indexing, assuming zero-fill). The XOR operation corresponds to matrix addition modulo $2$. The update for $s_{1,t+1}$ becomes:\n$$\ns_{1,t+1} = (I_w s_{0,t} + L_a s_{0,t} + R_b s_{0,t}) + R_c s_{1,t} = (I_w + L_a + R_b) s_{0,t} + R_c s_{1,t}\n$$\nThis gives the bottom block row of $A$ as $[I_w + L_a + R_b \\quad R_c]$.\n\nCombining the block rows, the state transition matrix $A$ is precisely as given in the problem statement:\n$$\nA = \\begin{pmatrix}\n0_w  I_w \\\\\nI_w + L_a + R_b  R_c\n\\end{pmatrix}\n$$\nThe output at each step is a single bit $b_t = v^\\top S_t$, where $v \\in \\{0,1\\}^{2w}$ is a fixed output mask vector.\n\n### 2. Linear Complexity and the Berlekamp–Massey Algorithm (BMA)\n\nThe linear complexity $L(n)$ of a binary sequence $\\{b_t\\}_{t=0}^{n-1}$ is the length of the shortest Linear Feedback Shift Register (LFSR) that generates the sequence. An LFSR of length $L$ is defined by a recurrence relation:\n$$\nb_k = \\sum_{i=1}^L c_i b_{k-i} \\pmod 2 \\quad \\text{for } k \\ge L\n$$\nwhere the coefficients $c_i \\in \\{0,1\\}$ define a connection polynomial $C(x) = 1 + \\sum_{i=1}^L c_i x^i$.\n\nThe Berlekamp-Massey algorithm is an efficient iterative method to find $L(n)$ and a corresponding $C(x)$ for a sequence. It processes the sequence bit by bit. At each step $n$, it computes the discrepancy $d$ between the next bit $b_n$ and the bit predicted by the current LFSR. If $d \\neq 0$, the LFSR is incorrect and must be updated. The update rule for the connection polynomial $C(x)$ and length $L$ aims to correct the discrepancy while keeping $L$ minimal.\n\nThe algorithm proceeds as follows:\n1. Initialize linear complexity $L=0$, connection polynomial $C(x)=1$, an auxiliary polynomial $B(x)=1$, and an auxiliary index $m=-1$.\n2. For $n = 0, 1, \\dots, N-1$:\n   a. Calculate the discrepancy: $d = b_n + \\sum_{i=1}^L c_i b_{n-i} \\pmod 2$.\n   b. If $d=1$:\n      i. Store a copy of the current polynomial: $T(x) = C(x)$.\n      ii. Update the connection polynomial: $C(x) \\leftarrow C(x) + x^{n-m}B(x)$.\n      iii. If $2L \\le n$, update the length $L \\leftarrow n+1-L$, update the index $m \\leftarrow n$, and set the auxiliary polynomial $B(x) \\leftarrow T(x)$.\n   c. The linear complexity of the prefix of length $n+1$ is the current value of $L$.\n\n### 3. State Observability and Reconstruction\n\nObservability in a linear system concerns whether the initial state $S_0$ can be uniquely determined from a sequence of outputs. The output sequence is given by $b_t = v^\\top S_t = v^\\top A^t S_0$. Writing this out for the first $s$ outputs gives a system of linear equations:\n$$\n\\begin{pmatrix} b_0 \\\\ b_1 \\\\ \\vdots \\\\ b_{s-1} \\end{pmatrix} = \\begin{pmatrix} v^\\top \\\\ v^\\top A \\\\ \\vdots \\\\ v^\\top A^{s-1} \\end{pmatrix} S_0\n$$\nThis is the system $\\mathbf{b}_s = \\mathcal{O}_s S_0$, where $\\mathcal{O}_s \\in \\{0,1\\}^{s \\times 2w}$ is the observability matrix.\n\nThe state $S_0$ can be uniquely determined if and only if $\\mathcal{O}_s$ has full column rank, i.e., $\\operatorname{rank}_{\\mathbb{F}_2}(\\mathcal{O}_s) = 2w$. A rank of $2w$ requires at least $s \\ge 2w$ observations. The Cayley-Hamilton theorem implies that we do not need to check for $s  2w$ to determine the maximum possible rank of the observability matrix family, but for a given generator the minimal $s$ for which this rank is achieved, denoted $s^\\star$, might be larger. We are tasked to find this minimal $s^\\star$ within the available $N$ samples.\n\nTo reconstruct $S_0$ using exactly $2w$ outputs, we must solve the system $\\mathcal{O}_{2w} S_0 = \\mathbf{b}_{2w}$. A unique solution exists if and only if the square matrix $\\mathcal{O}_{2w}$ is invertible, which is equivalent to $\\operatorname{rank}_{\\mathbb{F}_2}(\\mathcal{O}_{2w}) = 2w$. If this condition holds, we can find the solution $S_0 = (\\mathcal{O}_{2w})^{-1} \\mathbf{b}_{2w}$ by performing Gaussian elimination (or more specifically, Gauss-Jordan elimination) on the augmented matrix $[\\mathcal{O}_{2w} | \\mathbf{b}_{2w}]$ over $\\mathbb{F}_2$ to obtain the form $[I_{2w} | S_0']$. The vector $S_0'$ is the reconstructed state. The rank of any matrix over $\\mathbb{F}_2$ is also determined via Gaussian elimination, by counting the number of non-zero rows (pivots) in the row echelon form.\n\nThe implementation will follow these principles: matrix construction, stream generation, application of the BMA, iterative rank computation of the observability matrix, and solving the linear system for state reconstruction, all performed with arithmetic modulo $2$.",
            "answer": "```python\nimport numpy as np\n\ndef hex_to_vec(hex_str, w):\n    \"\"\"Converts a hex string to a numpy binary vector of specified width.\"\"\"\n    val = int(hex_str, 16)\n    bin_str = bin(val)[2:].zfill(w)\n    return np.array([int(b) for b in bin_str], dtype=np.uint8)\n\ndef build_shift_matrices(w, a, b, c):\n    \"\"\"Builds shift matrices L_a, R_b, R_c.\"\"\"\n    I_w = np.eye(w, dtype=np.uint8)\n    L_a = np.zeros((w, w), dtype=np.uint8)\n    if a > 0:\n        np.fill_diagonal(L_a[:, a:], 1)\n    \n    R_b = np.zeros((w, w), dtype=np.uint8)\n    if b > 0:\n        np.fill_diagonal(R_b[b:, :], 1)\n        \n    R_c = np.zeros((w, w), dtype=np.uint8)\n    if c > 0:\n        np.fill_diagonal(R_c[c:, :], 1)\n        \n    return I_w, L_a, R_b, R_c\n\ndef build_A(w, I_w, L_a, R_b, R_c):\n    \"\"\"Builds the state transition matrix A.\"\"\"\n    dim = 2 * w\n    A = np.zeros((dim, dim), dtype=np.uint8)\n    O_w = np.zeros((w, w), dtype=np.uint8)\n\n    # Top block row: [0_w, I_w]\n    A[0:w, w:dim] = I_w\n    \n    # Bottom block row: [I_w + L_a + R_b, R_c]\n    bottom_left = (I_w + L_a + R_b) % 2\n    A[w:dim, 0:w] = bottom_left\n    A[w:dim, w:dim] = R_c\n    \n    return A\n\ndef generate_stream(A, S0, v, N):\n    \"\"\"Generates a bitstream of length N.\"\"\"\n    S = S0.copy()\n    b_stream = np.zeros(N, dtype=np.uint8)\n    for t in range(N):\n        b_stream[t] = (v.T @ S) % 2\n        S = (A @ S) % 2\n    return b_stream\n\ndef berlekamp_massey(s):\n    \"\"\"\n    Berlekamp-Massey algorithm over F_2.\n    Returns the final linear complexity and the complexity profile.\n    \"\"\"\n    n = len(s)\n    c = [1]  # Connection polynomial C(x)\n    b = [1]  # Auxiliary polynomial B(x)\n    L = 0    # Linear complexity\n    m = -1   # Index of last length change\n    profile = []\n\n    for N_idx in range(n):\n        # Calculate discrepancy\n        d = s[N_idx]\n        if L > 0:\n            d_corr = sum(c[j] * s[N_idx - j] for j in range(1, L + 1))\n            d = (d + d_corr) % 2\n\n        if d == 1:\n            tc = list(c)  # T(x) = C(x)\n            \n            # Update C(x) = C(x) + x^(N_idx - m) * B(x)\n            shift = N_idx - m\n            b_shifted = [0] * shift + b\n            if len(c)  len(b_shifted):\n                c.extend([0] * (len(b_shifted) - len(c)))\n            if len(b_shifted)  len(c):\n                b_shifted.extend([0] * (len(c) - len(b_shifted)))\n            c = [(x + y) % 2 for x, y in zip(c, b_shifted)]\n            \n            # If necessary, update L\n            if 2 * L = N_idx:\n                L = N_idx + 1 - L\n                m = N_idx\n                b = tc\n        profile.append(L)\n\n    return (profile[-1] if profile else 0), profile\n\ndef gauss_jordan_f2(matrix):\n    \"\"\"Performs Gauss-Jordan elimination over F_2, returns RREF and rank.\"\"\"\n    mat = matrix.copy().astype(np.uint8)\n    num_rows, num_cols = mat.shape\n    pivot_row = 0\n    rank = 0\n    for j in range(num_cols):\n        if pivot_row  num_rows:\n            i = pivot_row\n            while i  num_rows and mat[i, j] == 0:\n                i += 1\n            \n            if i  num_rows:\n                mat[[pivot_row, i]] = mat[[i, pivot_row]]\n                \n                for k in range(num_rows):\n                    if k != pivot_row and mat[k, j] == 1:\n                        mat[k, :] = (mat[k, :] + mat[pivot_row, :]) % 2\n                \n                pivot_row += 1\n    rank = pivot_row\n    return mat, rank\n\ndef solve_f2(A, b):\n    \"\"\"Solves Ax = b over F_2 using Gaussian elimination.\"\"\"\n    m, n = A.shape\n    if m != n: return None\n    \n    augmented = np.hstack([A, b.reshape(-1, 1)])\n    rref, rank = gauss_jordan_f2(augmented)\n    \n    if rank  n: \n        return None\n    \n    solution = rref[:, n].reshape(-1, 1).astype(np.uint8)\n    return solution\n\ndef solve():\n    test_cases = [\n        {\n            \"w\": 16, \"abc\": (7, 9, 13), \"N\": 512,\n            \"s0_0\": \"0xACE1\", \"s1_0\": \"0xBEEF\", \"v_type\": \"parity_s1\"\n        },\n        {\n            \"w\": 8, \"abc\": (3, 5, 1), \"N\": 256,\n            \"s0_0\": \"0x5D\", \"s1_0\": \"0xC3\", \"v_type\": \"lsb_s1\"\n        },\n        {\n            \"w\": 8, \"abc\": (3, 5, 1), \"N\": 64,\n            \"s0_0\": \"0x5D\", \"s1_0\": \"0xC3\", \"v_type\": \"zero\"\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        w, (a, b, c), N = case[\"w\"], case[\"abc\"], case[\"N\"]\n        dim = 2 * w\n        \n        # 1. Construct matrices and initial state\n        I_w, L_a, R_b, R_c = build_shift_matrices(w, a, b, c)\n        A = build_A(w, I_w, L_a, R_b, R_c)\n        s0_vec = hex_to_vec(case[\"s0_0\"], w)\n        s1_vec = hex_to_vec(case[\"s1_0\"], w)\n        S0 = np.hstack([s0_vec, s1_vec]).reshape(-1, 1)\n\n        v = np.zeros((dim, 1), dtype=np.uint8)\n        if case[\"v_type\"] == \"parity_s1\":\n            v[w:, 0] = 1\n        elif case[\"v_type\"] == \"lsb_s1\":\n            v[dim - 1, 0] = 1\n        # v_type 'zero' is default\n        \n        # 2. Generate bitstream\n        b_stream = generate_stream(A, S0, v, N)\n\n        # 3. Compute linear complexity\n        L_N, _ = berlekamp_massey(b_stream)\n\n        # 4. Determine minimal sample size for observability\n        s_star = -1\n        v_row = v.T\n        O_rows = [v_row]\n        for s in range(1, N + 1):\n            O_s = np.vstack(O_rows)\n            _, rank = gauss_jordan_f2(O_s)\n            if rank == dim:\n                s_star = s\n                break\n            if s  N:\n                v_row = (v_row @ A) % 2\n                O_rows.append(v_row)\n        \n        # 5. Reconstruct S0 and verify\n        success = False\n        if N >= dim:\n            O_2w = np.vstack(O_rows[:dim])\n            _, rank_2w = gauss_jordan_f2(O_2w)\n            if rank_2w == dim:\n                b_2w = b_stream[:dim].reshape(-1, 1)\n                S0_recon = solve_f2(O_2w, b_2w)\n                if S0_recon is not None:\n                    # Verification\n                    b_recon = ((O_2w @ S0_recon) % 2).flatten()\n                    if np.array_equal(b_recon, b_stream[:dim]):\n                         # Check if reconstructed state is the same as original\n                         if np.array_equal(S0_recon, S0):\n                            success = True\n\n        results.append([s_star, L_N, success])\n    \n    # Format the final output string\n    formatted_results = [f\"[{s},{L},{str(suc)}]\" for s, L, suc in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}