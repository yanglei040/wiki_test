{
    "hands_on_practices": [
        {
            "introduction": "在蒙特卡洛模拟中，伪随机数生成器 (PRNG) 输出的统计质量至关重要。本实践将指导您实现卡方 ($\\chi^2$) 拟合优度检验，这是一个用于评估生成器输出序列是否符合均匀分布的基本工具。通过这个练习，您不仅将学会量化随机数与理想分布的偏差，还将探索该检验在实际应用中的局限性，例如样本大小和分箱数量对检验有效性的影响。",
            "id": "3529430",
            "problem": "考虑一个计算高能物理（HEP）中的蒙特卡洛工作流程，其中区间 $[0,1)$ 上的均匀伪随机数被用作基础随机变量来抽样运动学变量。科学有效性的一个基本要求是，伪随机数生成器产生的值必须与 $[0,1)$ 上的均匀分布一致。为了检验这一点，可以将区间 $[0,1)$ 划分成 $k$ 个等宽的区间（bin），并执行卡方拟合优度检验，以评估观测到的区间计数是否与均匀性一致。\n\n基于一个基本前提：在均匀性的零假设下，每次抽取都以概率 $p = 1/k$ 独立地落入任何一个区间中。因此，区间计数的向量遵循多项分布，其参数为 $N$ 和概率 $(p_1, p_2, \\dots, p_k)$，其中对所有 $i$ 都有 $p_i = p$。每个区间的期望计数为 $E_i = N p$，对于每个区间计数 $O_i$，其区间内方差为 $\\mathrm{Var}(O_i) = N p (1 - p)$。对于大的 $N$ 和固定的 $k$，使得期望计数不小的情况下，Pearson 卡方统计量\n$$\n\\chi^2 = \\sum_{i=1}^{k} \\frac{(O_i - E_i)^2}{E_i}\n$$\n近似服从自由度为 $k - 1$ 的卡方分布。\n\n您的任务是实现一个完整的程序，该程序能够：\n- 使用指定的生成器类型和种子，在 $[0,1)$ 上生成 $N$ 个伪随机值。\n- 将这些值分入 $[0,1)$ 上的 $k$ 个等宽区间中。\n- 在多项模型下，计算观测计数 $O_i$、期望计数 $E_i = N/k$（所有区间相同）以及每个区间的方差 $\\mathrm{Var}(O_i) = N \\cdot \\frac{1}{k} \\cdot \\left(1 - \\frac{1}{k}\\right)$。\n- 使用自由度为 $k - 1$ 的卡方分布，计算 Pearson 卡方统计量 $\\chi^2$ 和相关的 $p$-值。\n- 通过将 $p$-值与显著性水平 $\\alpha$ 进行比较，决定是否在显著性水平 $\\alpha$ 下拒绝均匀性的零假设。\n- 根据常见的经验法则 $E_i \\geq 5$，报告卡方渐近近似是否预期有效。\n\n您的程序必须实现两种生成器类型：\n- “uniform”：通过可复现的种子，从默认的可移植计算机生成器（PCG）获得的高质量伪随机数。\n- “quantized10”：同样的高质量生成器，后跟一个确定性的量化过程，该过程将每个值 $u$ 映射到 $\\lfloor 10 u \\rfloor / 10$，从而在 $[0,1)$ 中仅产生10个离散能级。\n\n对于每个测试用例，您的程序必须以下列格式输出一个列表：\n$[ \\chi^2, \\text{dof}, p\\text{-value}, \\text{reject}, E, \\mathrm{Var}, \\text{approx\\_valid} ]$，\n其中 $\\chi^2$ 是一个浮点数，$\\text{dof}$ 是一个等于 $k-1$ 的整数，$p\\text{-value}$ 是一个浮点数，$\\text{reject}$ 是一个布尔值，指示 `$p\\text{-value}  \\alpha$` 是否成立，$E$ 是每个区间的期望计数（一个等于 $N/k$ 的浮点数），$\\mathrm{Var}$ 是每个区间的方差（一个等于 $N \\cdot \\frac{1}{k} \\cdot \\left(1 - \\frac{1}{k}\\right)$ 的浮点数），以及 $\\text{approx\\_valid}$ 是一个布尔值，指示 $E \\geq 5$ 是否成立。\n\n设计注意事项：\n- 分箱必须由位于 $0, \\frac{1}{k}, \\frac{2}{k}, \\dots, 1$ 的区间边界定义，对于 $u \\in [0,1)$，值 $u$ 被分配到索引为 $\\lfloor k u \\rfloor$ 的区间。\n- 最终输出必须将所有测试用例的结果聚合到单行表示的一个列表中，该列表为每个测试用例包含一个子列表。\n\n使用以下测试套件来检验问题的不同方面，包括“理想路径”情况、期望计数的边界条件、许多区间计数很小或为零的边缘情况，以及一个故意设计的非均匀生成器：\n\n1. $N = 100000$，$k = 100$，$\\alpha = 0.01$，生成器类型 \"uniform\"，种子 $12345$。\n2. $N = 5000$，$k = 1000$，$\\alpha = 0.05$，生成器类型 \"uniform\"，种子 $54321$。\n3. $N = 10000$，$k = 5000$，$\\alpha = 0.05$，生成器类型 \"uniform\"，种子 $1$。\n4. $N = 100$，$k = 10$，$\\alpha = 0.1$，生成器类型 \"uniform\"，种子 $2025$。\n5. $N = 10000$，$k = 100$，$\\alpha = 0.001$，生成器类型 \"quantized10\"，种子 $7$。\n6. $N = 1000$，$k = 1000$，$\\alpha = 0.05$，生成器类型 \"uniform\"，种子 $314159$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身就是如上所述的列表，并按与测试套件相同的顺序出现（例如，$[[\\dots],[\\dots],\\dots]$）。此问题不涉及物理单位或角度单位。",
            "solution": "该问题要求实现一个用于伪随机数生成器（PRNG）的统计验证程序，这是计算科学中的一项关键任务，尤其是在高能物理的蒙特卡洛模拟中。任务的核心是执行 Pearson 卡方（$\\chi^2$）拟合优度检验，以评估 PRNG 的输出是否与区间 $[0,1)$ 上的均匀分布一致。解决方案将基于概率论和统计学的基本原理进行设计。\n\n逻辑步骤如下：\n1. 零假设 $H_0$ 假定生成的数是从 $[0,1)$ 上的连续均匀分布中抽取的。\n2. 为检验此假设，将区间 $[0,1)$ 划分为 $k$ 个连续的、等宽的子区间（bin）。在 $H_0$ 下，一个随机变量落入任何特定区间的概率对所有区间都是相同的，其值为 $p = 1/k$。\n3. 共生成 $N$ 个随机变量。记录落入每个区间的变量计数，用向量 $(O_1, O_2, \\dots, O_k)$ 表示。这个观测计数向量在数学上遵循一个多项分布，其参数为 $N$（试验次数）和 $(p_1, p_2, \\dots, p_k)$（事件概率），其中对于所有 $i \\in \\{1, \\dots, k\\}$，都有 $p_i = 1/k$。\n\n从这些基本原理中，我们推导出检验所需的量。每个区间 $i$ 的期望计数，记为 $E_i$，由相应边际二项分布的均值给出，即 $E_i = N p_i$。由于所有 $p_i$ 都等于 $1/k$，因此所有区间的期望计数是相同的：\n$$\nE = E_i = N \\cdot \\frac{1}{k}\n$$\n单个区间 $i$ 中计数的方差 $\\mathrm{Var}(O_i)$ 由二项变量的方差给出：\n$$\n\\mathrm{Var}(O_i) = N p_i (1 - p_i) = N \\cdot \\frac{1}{k} \\left(1 - \\frac{1}{k}\\right)\n$$\n该方差量化了区间计数围绕其均值的预期随机波动。\n\nPearson 卡方检验统计量 $\\chi^2$ 用于衡量观测计数 $O_i$ 与零假设下的期望计数 $E$ 之间的总差异。它定义为平方差之和，并由期望计数进行归一化：\n$$\n\\chi^2 = \\sum_{i=1}^{k} \\frac{(O_i - E)^2}{E}\n$$\n此统计量的值越大，表示与预期的均匀分布偏差越显著。统计学中的一个关键结果，即 Pearson 卡方定理，指出对于足够大的样本量 $N$，此 $\\chi^2$ 统计量近似服从卡方分布。该分布的自由度（$\\text{dof}$）为 $\\nu = k - 1$。之所以会减少一个自由度，是因为观测计数受到了一个线性约束，即它们的总和必须等于总样本数：$\\sum_{i=1}^{k} O_i = N$。\n\n这种卡方近似的有效性取决于期望计数不能太小。问题中指定了一个广泛使用的启发式规则：如果每个区间的期望计数至少为5，即 $E \\ge 5$，则认为该近似是可靠的。\n\n然后通过计算 $p$-值来进行假设检验。$p$-值表示在零假设 $H_0$ 为真的前提下，观测到至少与从数据中计算出的 $\\chi^2$ 统计量一样大的值的概率。对于这个右尾检验，它由以下公式给出：\n$$\np\\text{-value} = P(\\chi^2_{\\nu} \\ge \\chi^2_{\\text{observed}})\n$$\n其中 $\\chi^2_{\\nu}$ 是一个服从自由度为 $\\nu = k-1$ 的卡方分布的随机变量。这个概率是使用卡方分布的生存函数（$1 - \\text{CDF}$）计算的。\n\n最后，通过将 $p$-值与预先确定的显著性水平 $\\alpha$ 进行比较来做出决策。如果$p$-值小于$\\alpha$（$p  \\alpha$），则意味着如果生成器确实是均匀的，那么观测到的数据通过随机偶然发生是极不可能的。因此，我们拒绝零假设，并得出结论：有统计上显著的证据表明该 PRNG 不是均匀的。如果 $p \\ge \\alpha$，我们则不拒绝零假设。\n\n实现将按以下步骤进行：\n- 对于由参数 $(N, k, \\alpha, \\text{generator\\_type}, \\text{seed})$ 定义的每个测试用例，使用给定的种子初始化一个可复现的 `numpy` PRNG (`PCG64`)。\n- 生成 $N$ 个随机数。对于 `“uniform”` 类型，直接使用生成器的输出。对于 `“quantized10”` 类型，输出值 $u$ 通过函数 $u \\mapsto \\lfloor 10u \\rfloor / 10$ 进行转换，该函数通过将值限制在10个离散级别来引入明显的非均匀性。\n- 使用 `numpy.histogram` 函数将生成的样本高效地分入 $[0,1)$ 上的 $k$ 个等宽区间，并获得观测计数 $O_i$。\n- 根据其定义计算导出量——$E$、$\\mathrm{Var}(O_i)$、$\\chi^2$ 和自由度 $\\nu$。\n- 使用 `scipy.stats.chi2.sf` 函数根据 $\\chi^2$ 统计量和自由度计算 $p$-值。\n- 确定用于拒绝 $H_0$ 和判断卡方近似有效性的布尔值。\n- 收集每个测试用例的结果，并将其格式化为指定的列表的列表结构，作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, k, alpha, generator_type, seed)\n        (100000, 100, 0.01, \"uniform\", 12345),\n        (5000, 1000, 0.05, \"uniform\", 54321),\n        (10000, 5000, 0.05, \"uniform\", 1),\n        (100, 10, 0.1, \"uniform\", 2025),\n        (10000, 100, 0.001, \"quantized10\", 7),\n        (1000, 1000, 0.05, \"uniform\", 314159),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, k, alpha, gen_type, seed = params\n        result = perform_chi_square_test(N, k, alpha, gen_type, seed)\n        results.append(result)\n\n    # Format the final output string as a list of lists, without extra spaces.\n    # e.g., [[val1,val2,...],[val1,val2,...]]\n    sublist_strs = []\n    for sublist in results:\n        # str(item) for bool produces 'True'/'False' with capital letters, which is standard for Python.\n        item_strs = [str(item) for item in sublist]\n        sublist_strs.append(f\"[{','.join(item_strs)}]\")\n    \n    final_output_str = f\"[{','.join(sublist_strs)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\ndef perform_chi_square_test(N, k, alpha, generator_type, seed):\n    \"\"\"\n    Performs a chi-square goodness-of-fit test for a single test case.\n\n    Args:\n        N (int): Number of pseudo-random values to generate.\n        k (int): Number of bins to partition the [0,1) interval into.\n        alpha (float): Significance level for the hypothesis test.\n        generator_type (str): Type of generator (\"uniform\" or \"quantized10\").\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        list: A list containing the test results in the specified format:\n              [chi^2, dof, p-value, reject, E, Var, approx_valid]\n    \"\"\"\n    # 1. Generate pseudo-random numbers\n    rng = np.random.default_rng(seed)\n    if generator_type == \"uniform\":\n        samples = rng.random(size=N)\n    elif generator_type == \"quantized10\":\n        u_samples = rng.random(size=N)\n        samples = np.floor(10 * u_samples) / 10\n    else:\n        # This case should not be reached with the given problem statement.\n        raise ValueError(f\"Unknown generator type: {generator_type}\")\n\n    # 2. Bin the values to get observed counts\n    # np.histogram bins are [min, max] with bins=k and range=(0,1) resulting in\n    # bins of width 1/k. The last bin is inclusive on the right edge.\n    observed_counts, _ = np.histogram(samples, bins=k, range=(0, 1))\n\n    # 3. Compute expected counts and degrees of freedom\n    expected_count = N / k\n    dof = k - 1\n    \n    # 4. Compute Pearson's chi-square statistic\n    # The case expected_count=0 is only possible if N=0, which is not the case here.\n    # The sum is over all k bins.\n    chi2_stat = np.sum((observed_counts - expected_count)**2 / expected_count)\n\n    # 5. Calculate p-value\n    # The p-value is the probability of observing a chi-square value as extreme\n    # or more extreme than the one calculated, given the null hypothesis is true.\n    # This is given by the survival function (1 - CDF).\n    p_value = chi2.sf(chi2_stat, dof)\n\n    # 6. Decide whether to reject the null hypothesis\n    reject_null = p_value  alpha\n\n    # 7. Report if the asymptotic chi-square approximation is valid\n    # Based on the common rule-of-thumb E_i = 5.\n    approx_valid = expected_count >= 5\n\n    # 8. Compute the per-bin variance under the multinomial model\n    variance = N * (1 / k) * (1 - 1 / k)\n\n    return [\n        float(chi2_stat),\n        int(dof),\n        float(p_value),\n        bool(reject_null),\n        float(expected_count),\n        float(variance),\n        bool(approx_valid),\n    ]\n\n# Execute the main function when the script is run.\nsolve()\n```"
        },
        {
            "introduction": "在并行计算环境中，确保不同处理器使用的随机数子流相互独立且不重叠是一项核心挑战。本实践介绍了一种优雅的解决方案——“跳转”（skip-ahead）技术，它适用于线性生成器。在这个练习中，您将学习如何将生成器的递推关系表示为矩阵，并利用矩阵快速幂算法高效地“跳转”到序列的任意位置，从而创建独立的子流。这是高性能科学计算中的一项关键技能。",
            "id": "3333414",
            "problem": "考虑定义在有限代数结构上的线性递推关系的线性伪随机数生成器，以及它们作为线性映射的状态转移表示。请使用以下理论基础：(i) 在整数模 $m$ 环（记为 $\\mathbb{Z}/m\\mathbb{Z}$）和二元有限域（记为 $\\mathbb{F}_2$）上的线性递推定义；(ii) 将生成器状态演化解释为重复应用由矩阵表示的线性变换；以及 (iii) 一个线性映射复合 $k$ 次对应于其矩阵表示的 $k$ 次幂这一事实。基于这些基础，推导一种跳跃（skip-ahead）方法，并设计一种子流构造方案，以确保在底层周期足够大时，生成的定长分段不发生重叠。\n\n你必须解决以下任务。\n\n1. 定义一个在 $\\mathbb{Z}/m\\mathbb{Z}$ 上的线性同余生成器 (LCG)，其递推关系为 $x_{n+1} \\equiv a x_n + c \\pmod{m}$，其中 $x_n \\in \\mathbb{Z}/m\\mathbb{Z}$。展示如何通过增广一个常量分量将此仿射映射嵌入到一个线性映射中，并推导出在 $\\mathbb{Z}/m\\mathbb{Z}$ 中相应的状态转移矩阵，该矩阵的幂可以实现向前跳跃 $k$ 步。\n\n2. 定义一个基于反馈多项式的 $\\mathbb{F}_2$ 上 $d$ 次的线性反馈移位寄存器 (LFSR)，并将其更新表示为 $\\mathbb{F}_2^d$ 中 $d$ 维状态向量的线性变换。推导出其类友矩阵形式的状态转移矩阵，该矩阵的幂可以实现向前跳跃 $k$ 步。\n\n3. 为 $\\mathbb{Z}/m\\mathbb{Z}$ 和 $\\mathbb{F}_2$ 上的矩阵实现矩阵乘法和平方求幂快速算法，以便对于任意方阵 $T$ 和非负整数 $k$，你可以在相应的代数结构中计算 $T^k$，其中所有算术运算分别在模 $m$（对于 $\\mathbb{Z}/m\\mathbb{Z}$）或模 2（对于 $\\mathbb{F}_2$）下执行。\n\n4. 实现一种方法，通过选择起始状态 $\\{s_0, s_L, s_{2L}, \\dots\\}$ 并从每个起始状态生成 $L$ 个连续状态，将生成器的流划分为长度为 $L$ 的不重叠子流。用 $L$ 步转移来表示第 $i$ 个起始状态的选择，并指明这些子流不重叠的条件。\n\n你的程序必须针对下面指定的测试套件，通过将跳跃方法与朴素迭代进行比较来验证其正确性，并通过检查状态集的交集来验证子流的不重叠性。\n\n测试套件：\n\n- 在 $\\mathbb{Z}/m\\mathbb{Z}$ 上的 LCG：\n  - 模数 $m = 10007$，乘数 $a = 173$，增量 $c = 317$，初始种子 $x_0 = 42$。\n  - 跳跃验证：$k = 250$。\n  - 子流：子流长度 $L = 50$，子流数量 $N = 3$。\n\n- 在 $\\mathbb{F}_2$ 上的 LFSR：\n  - 次数 $d = 5$，反馈多项式为 $p(x) = x^5 + x^2 + 1$，解释为在 $\\mathbb{F}_2$ 中的递推关系 $x_{n+5} = x_{n+2} + x_n$。\n  - 初始状态向量 $s_0 = [1, 0, 0, 0, 0]$（作为 $\\mathbb{F}_2$ 的元素）。\n  - 跳跃验证：$k = 13$。\n  - 子流：子流长度 $L = 7$，子流数量 $N = 4$。\n  - 边界验证：\n    - 跳跃的单位元性质：$k = 0$ 必须将 $s_0$ 映射到自身。\n    - 当子流长度等于周期时的重叠检测：令 $P$ 表示从 $s_0$ 开始的 LFSR 周期；取 $L = P$ 和 $N = 2$，并检查构造的子流是否重叠。\n\n对于以下各项检查，生成一个布尔结果：\n- LCG 对 $k = 250$ 的跳跃相等性检查，比较基于矩阵的跳跃与朴素迭代的结果。\n- LCG 对 $L = 50, N = 3$ 的子流不重叠性检查。\n- LFSR 对 $k = 13$ 的跳跃相等性检查，比较基于矩阵的跳跃与朴素迭代的结果。\n- LFSR 对 $L = 7, N = 4$ 的子流不重叠性检查。\n- LFSR 对 $k = 0$ 的单位元性质检查。\n- LFSR 在 $L = P$ 且 $N = 2$ 时的子流不重叠性检查（此项应能检测到适用的重叠情况）。\n\n最终输出格式：\n你的程序应该生成单行输出，其中包含按上述顺序列出的六个布尔结果，以逗号分隔并用方括号括起来（例如，`[True,False,True,True,True,False]`）。输出不应包含任何额外文本。\n\n程序必须是自包含的，并且不需要任何输入。它必须可以在任何现代语言中运行，但你的最终答案必须以符合指定执行环境约束的 Python 代码形式提供。",
            "solution": "我们从线性递推的定义及其作为线性映射的表示开始。在整数模 $m$ 环 $\\mathbb{Z}/m\\mathbb{Z}$ 上的线性递推具有形式 $x_{n+1} \\equiv a x_n + c \\pmod{m}$，其中 $a, c \\in \\mathbb{Z}/m\\mathbb{Z}$。由于存在常数项 $c$，这个映射是仿射的，而非线性的。将仿射映射表示为线性映射的一种标准方法是通过增广一个常量分量来扩展状态。定义增广状态向量 $y_n \\in (\\mathbb{Z}/m\\mathbb{Z})^2$ 为 $y_n = \\begin{bmatrix} x_n \\\\ 1 \\end{bmatrix}$。那么，更新过程可以写成\n$$\ny_{n+1} = \\begin{bmatrix} a  c \\\\ 0  1 \\end{bmatrix} y_n \\pmod{m}.\n$$\n将转移矩阵记为 $T = \\begin{bmatrix} a  c \\\\ 0  1 \\end{bmatrix}$。应用该递推关系 $k$ 次对应于将该变换复合 $k$ 次，从而得到\n$$\ny_{n+k} = T^k y_n \\pmod{m},\n$$\n$y_{n+k}$ 的第一个分量即为 $x_{n+k}$，也就是我们所期望的跳跃值。\n\n对于有限域 $\\mathbb{F}_2$ 上的线性反馈移位寄存器 (LFSR)，考虑由一个反馈多项式 $p(x) = x^d + \\sum_{i=0}^{d-1} c_i x^i$（其中 $c_i \\in \\{0, 1\\}$）导出的 $d$ 次递推。其递推关系为 $x_{n+d} = \\sum_{i=0}^{d-1} c_i x_{n+i}$（在 $\\mathbb{F}_2$ 中）。定义状态向量 $s_n = \\begin{bmatrix} x_n  x_{n+1}  \\cdots  x_{n+d-1} \\end{bmatrix}^\\top \\in \\mathbb{F}_2^d$。那么，状态更新 $s_{n+1}$ 可以表示为\n$$\ns_{n+1} = A s_n \\pmod{2},\n$$\n其中 $A$ 是类友矩阵\n$$\nA = \\begin{bmatrix}\n0  1  0  \\cdots  0 \\\\\n0  0  1  \\cdots  0 \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots \\\\\n0  0  0  \\cdots  1 \\\\\nc_0  c_1  c_2  \\cdots  c_{d-1}\n\\end{bmatrix}.\n$$\n对于具体情况 $p(x) = x^5 + x^2 + 1$，我们有 $d = 5$，系数为 $c_0 = 1, c_1 = 0, c_2 = 1, c_3 = 0, c_4 = 0$。因此，\n$$\nA = \\begin{bmatrix}\n0  1  0  0  0 \\\\\n0  0  1  0  0 \\\\\n0  0  0  1  0 \\\\\n0  0  0  0  1 \\\\\n1  0  1  0  0\n\\end{bmatrix}.\n$$\n和之前一样，向前跳跃 $k$ 步通过 $A^k$ 实现，即 $s_{n+k} = A^k s_n \\pmod{2}$。\n\n为了高效地计算 $\\mathbb{Z}/m\\mathbb{Z}$ 或 $\\mathbb{F}_2$ 上任意方阵 $T$ 的 $k$ 次幂 $T^k$，我们使用平方求幂法，该方法基于恒等式 $T^{2r} = (T^r)^2$ 和 $T^{2r+1} = (T^r)^2 T$。这种方法将乘法次数从 $O(k)$ 减少到 $O(\\log k)$。在每次乘法中，我们都执行模 $m$（对于 $\\mathbb{F}_2$ 则是模 2）的算术运算，以确保运算保持在适当的代数结构内。\n\n对于子流的构造，令 $T$ 为相关结构中的状态转移矩阵，$s_0$ 为初始状态向量。定义 $L$ 步转移为 $U = T^L$。那么第 $i$ 个子流的起始状态为 $s^{(i)}_0 = U^i s_0$。第 $i$ 个子流中的第 $j$ 个状态是 $s^{(i)}_j = T^j s^{(i)}_0$。如果对于不同的 $i$，集合 $\\{ s^{(i)}_j : 0 \\le j  L \\}$ 两两不相交，则这些子流是不重叠的。只要生成器的周期 $P$ 满足 $N L \\le P$，并且我们选择以步长 $L$ 划分的连续段，这个条件就成立。\n\n程序中的验证方法如下：\n- 对于在 $\\mathbb{Z}/m\\mathbb{Z}$ 上的 LCG，参数为 $m = 10007, a = 173, c = 317, x_0 = 42$，我们用两种方法计算 $x_{250}$：(i) 通过重复应用 $x_{n+1} \\equiv a x_n + c \\pmod{m}$ 进行朴素迭代，以及 (ii) 通过增广状态转移和 $T^{250}$ 进行矩阵跳跃。相等性产生一个布尔结果。\n- 对于同一个 LCG，我们通过步长 $L$ 构造 $N = 3$ 个长度为 $L = 50$ 的子流，并检查每个子流中的状态集合不相交。\n- 对于在 $\\mathbb{F}_2$ 上次数为 $d = 5$、多项式为 $p(x) = x^5 + x^2 + 1$ 的 LFSR，从 $s_0 = [1, 0, 0, 0, 0]$ 开始，我们通过朴素迭代和矩阵跳跃 $A^{13}$ 计算 $s_{13}$，并检查相等性。\n- 对于同一个 LFSR，我们构造 $N = 4$ 个长度为 $L = 7$ 的子流，并通过状态的集合交集验证其不重叠性。\n- 我们通过检查应用 $A^0$ 到 $s_0$ 返回 $s_0$ 来验证单位元性质 $A^0 = I$。\n- 我们通过迭代直到初始状态 $s_0$ 再次出现来确定周期 $P$，然后测试 $L = P, N = 2$ 的情况下的不重叠性，由于循环特性，这应该会指示出重叠。\n\n程序输出单行，按顺序罗列六个布尔值：LCG 跳跃相等性、LCG 不重叠性、LFSR 跳跃相等性、LFSR 不重叠性、LFSR 在 $k=0$ 时的单位元性质、LFSR 在 $L = P, N = 2$ 时的不重叠性。此格式满足了对可量化答案和清晰、可测试输出的要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef mat_mul_mod(A, B, mod):\n    # Multiply two matrices A (n x m) and B (m x p) modulo mod\n    n = len(A)\n    m = len(A[0])\n    assert m == len(B), \"Inner dimensions must match\"\n    p = len(B[0])\n    C = [[0] * p for _ in range(n)]\n    for i in range(n):\n        for k in range(m):\n            aik = A[i][k]\n            if aik == 0:\n                continue\n            for j in range(p):\n                C[i][j] = (C[i][j] + aik * B[k][j]) % mod\n    return C\n\ndef mat_vec_mul_mod(A, v, mod):\n    # Multiply matrix A (n x m) with vector v (m), modulo mod\n    n = len(A)\n    m = len(A[0])\n    assert m == len(v), \"Dimension mismatch in mat-vec multiply\"\n    res = [0] * n\n    for i in range(n):\n        s = 0\n        row = A[i]\n        for j in range(m):\n            s += row[j] * v[j]\n        res[i] = s % mod\n    return res\n\ndef mat_pow_mod(A, k, mod):\n    # Exponentiation by squaring: compute A^k modulo mod\n    n = len(A)\n    assert n == len(A[0]), \"Matrix must be square\"\n    # Identity matrix\n    I = [[0] * n for _ in range(n)]\n    for i in range(n):\n        I[i][i] = 1 % mod\n    if k == 0:\n        return I\n    # Copy A\n    base = [row[:] for row in A]\n    result = I\n    exp = k\n    while exp > 0:\n        if exp  1:\n            result = mat_mul_mod(result, base, mod)\n        base = mat_mul_mod(base, base, mod)\n        exp >>= 1\n    return result\n\ndef lcg_step(x, a, c, m):\n    return (a * x + c) % m\n\ndef generate_lcg_substreams(a, c, m, x0, L, N):\n    # Using augmented matrix T over Z/mZ\n    T = [[a % m, c % m],\n         [0,      1 % m]]\n    s0 = [x0 % m, 1]\n    substreams = []\n    for i in range(N):\n        # compute start state for substream i: T^(i*L) * s0\n        Ti = mat_pow_mod(T, i * L, m)\n        si = mat_vec_mul_mod(Ti, s0, m)\n        # Generate L states by repeatedly applying T\n        states = []\n        curr = si[:]\n        for _ in range(L):\n            states.append(curr[0])  # record x component\n            curr = mat_vec_mul_mod(T, curr, m)\n        substreams.append(states)\n    return substreams\n\ndef lfsr_period(A, s0):\n    # Compute the period of LFSR starting from s0 by detecting when state repeats\n    mod = 2\n    seen = 0\n    s = s0[:]\n    while True:\n        s = mat_vec_mul_mod(A, s, mod)\n        seen += 1\n        if s == s0:\n            return seen\n\ndef generate_lfsr_substreams(A, s0, L, N):\n    mod = 2\n    T = A\n    substreams = []\n    # Precompute U = T^L\n    U = mat_pow_mod(T, L, mod)\n    # Precompute starts\n    # s^(i)_0 = U^i s0\n    Ui = [[1 if r == c else 0 for c in range(len(T))] for r in range(len(T))]\n    # Alternatively compute U^i by exponentiation each time for simplicity given small sizes\n    for i in range(N):\n        Ti = mat_pow_mod(U, i, mod)\n        si = mat_vec_mul_mod(Ti, s0, mod)\n        # Generate L states\n        states = []\n        curr = si[:]\n        for _ in range(L):\n            states.append(tuple(curr))  # record full state vector\n            curr = mat_vec_mul_mod(T, curr, mod)\n        substreams.append(states)\n    return substreams\n\ndef check_nonoverlap(substreams):\n    # Check pairwise that sets of states do not intersect\n    sets = [set(ss) for ss in substreams]\n    for i in range(len(sets)):\n        for j in range(i + 1, len(sets)):\n            if sets[i].intersection(sets[j]):\n                return False\n    return True\n\ndef solve():\n    results = []\n\n    # Test 1: LCG skip-ahead equality\n    m = 10007\n    a = 173\n    c = 317\n    x0 = 42\n    k = 250\n    # Build augmented transition matrix\n    T_lcg = [[a % m, c % m],\n             [0,      1]]\n    s0_lcg = [x0 % m, 1]\n    Tk = mat_pow_mod(T_lcg, k, m)\n    s_skip = mat_vec_mul_mod(Tk, s0_lcg, m)\n    x_skip_matrix = s_skip[0]\n    # Naive iteration\n    x_naive = x0 % m\n    for _ in range(k):\n        x_naive = lcg_step(x_naive, a, c, m)\n    b1 = (x_skip_matrix == x_naive)\n    results.append(b1)\n\n    # Test 2: LCG nonoverlap substreams\n    L = 50\n    N = 3\n    lcg_substreams = generate_lcg_substreams(a, c, m, x0, L, N)\n    b2 = check_nonoverlap(lcg_substreams)\n    results.append(b2)\n\n    # Test 3: LFSR skip-ahead equality\n    d = 5\n    # Companion-like matrix for p(x) = x^5 + x^2 + 1\n    A = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [1, 0, 1, 0, 0],\n    ]\n    s0 = [1, 0, 0, 0, 0]\n    k_lfsr = 13\n    Ak = mat_pow_mod(A, k_lfsr, 2)\n    s_skip_lfsr = mat_vec_mul_mod(Ak, s0, 2)\n    # Naive iteration\n    s_naive = s0[:]\n    for _ in range(k_lfsr):\n        s_naive = mat_vec_mul_mod(A, s_naive, 2)\n    b3 = (s_skip_lfsr == s_naive)\n    results.append(b3)\n\n    # Test 4: LFSR nonoverlap substreams\n    L_lfsr = 7\n    N_lfsr = 4\n    lfsr_substreams = generate_lfsr_substreams(A, s0, L_lfsr, N_lfsr)\n    b4 = check_nonoverlap(lfsr_substreams)\n    results.append(b4)\n\n    # Test 5: LFSR identity property for k = 0\n    A0 = mat_pow_mod(A, 0, 2)\n    s_id = mat_vec_mul_mod(A0, s0, 2)\n    b5 = (s_id == s0)\n    results.append(b5)\n\n    # Test 6: LFSR overlap when L equals the period and N = 2\n    P = lfsr_period(A, s0)\n    L_eq_P = P\n    N_two = 2\n    lfsr_substreams_period = generate_lfsr_substreams(A, s0, L_eq_P, N_two)\n    # Expect overlap due to cycling\n    b6 = check_nonoverlap(lfsr_substreams_period)\n    results.append(b6)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "伪随机数生成器的质量与其可预测性密切相关；一个好的生成器应该难以预测。本实践将带您探索线性复杂度，这是衡量序列可预测性的一个关键指标。在这个高级练习中，您将使用 Berlekamp-Massey 算法分析输出比特流，并结合可观测性理论，尝试从输出序列中重构生成器的内部状态，从而揭示伪随机性背后的确定性本质。",
            "id": "3333430",
            "problem": "给定一个基于异或移位（XORSHIFT）更新的伪随机数生成器族，其模型是二元有限域上的线性变换。考虑一个由两个宽度为 $w$ 比特的字组成的状态，在离散时间 $t$ 表示为列向量 $S_t \\in \\{0,1\\}^{2w}$。状态更新由一个在 $\\mathbb{F}_2$ 上的线性映射定义如下。令 $s_{0,t} \\in \\{0,1\\}^w$ 和 $s_{1,t} \\in \\{0,1\\}^w$ 分别表示状态向量 $S_t$ 的上半部分和下半部分。该生成器使用三个非负整数 $(a,b,c)$，其中 $a \\geq 0$，$b \\geq 0$，$c \\geq 0$，并执行以下更新\n$$\ns_{0,t+1} := s_{1,t}, \\quad t := s_{0,t} \\oplus (s_{0,t} \\ll a) \\oplus (s_{0,t} \\gg b), \\quad s_{1,t+1} := t \\oplus (s_{1,t} \\gg c),\n$$\n其中 $\\oplus$ 表示按位模2加法，$\\ll$ 是在 $w$ 比特内的左移位（补零），$\\gg$ 是在 $w$ 比特内的右移位（补零）。所有运算在 $\\mathbb{F}_2$ 上都是线性的。我们将此更新表示为一个矩阵 $A \\in \\{0,1\\}^{2w \\times 2w}$，使得在 $\\mathbb{F}_2$ 上有 $S_{t+1} = A S_t$。生成器在每一步通过一个已知的输出掩码 $v \\in \\{0,1\\}^{2w}$ 产生一个单位比特的观测值：\n$$\nb_t := v^\\top S_t \\in \\{0,1\\},\n$$\n其中 $b_t$ 是在时间 $t$ 观测到的比特。\n\n任务如下：\n- 在 $\\mathbb{F}_2$ 上实现 Berlekamp–Massey 算法（BMA），以估计比特流 $\\{b_t\\}_{t=0}^{n-1}$ 随前缀长度增加的线性复杂度剖面 $L(n)$，其中线性复杂度 $L(n)$ 是能够生成该序列前 $n$ 个比特的最短线性反馈移位寄存器（LFSR）的长度。\n- 使用 $\\mathbb{F}_2$ 上的分块矩阵为上述 XORSHIFT 更新构建状态转移矩阵 $A$。令 $I_w$ 表示 $w \\times w$ 的单位矩阵，$L_a \\in \\{0,1\\}^{w \\times w}$ 表示左移 $a$ 位的矩阵，$R_b \\in \\{0,1\\}^{w \\times w}$ 表示右移 $b$ 位的矩阵。利用更新的定义，推导出分块结构\n$$\nA = \\begin{pmatrix}\n0_w  I_w \\\\\nI_w + L_a + R_b  R_c\n\\end{pmatrix},\n$$\n其中 $0_w$ 是 $w \\times w$ 的零矩阵，加法是模2加法。\n- 利用已知的线性性质，在 $\\mathbb{F}_2$ 上构建可观测性矩阵，\n$$\n\\mathcal{O}_s = \\begin{pmatrix}\nv^\\top \\\\\nv^\\top A \\\\\nv^\\top A^2 \\\\\n\\vdots \\\\\nv^\\top A^{s-1}\n\\end{pmatrix} \\in \\{0,1\\}^{s \\times 2w},\n$$\n并计算使得 $\\operatorname{rank}_{\\mathbb{F}_2}(\\mathcal{O}_s) = 2w$ 的最小样本量 $s$（如果这样的 $s$ 在可用样本内存在）。当此秩条件成立时，通过求解 $\\mathbb{F}_2$ 上的线性系统 $\\mathcal{O}_s S_0 = \\mathbf{b}$（其中 $\\mathbf{b} = (b_0,\\dots,b_{s-1})^\\top$），从前 $s$ 个观测比特重建初始状态 $S_0$。\n\n您必须从与随机模拟和蒙特卡洛方法相关的基本原理和核心定义出发，特别是：\n- 线性复杂度的定义及其通过 $\\mathbb{F}_2$ 上的 Berlekamp–Massey 算法进行估计的方法。\n- 有限域上线性系统的状态空间表示，包括可观测性矩阵的构建和可重构性的秩条件。\n\n除这些原则外，不要使用快捷公式。推导过程必须证明与上述定义一致。\n\n对于每个测试用例，您必须：\n- 使用指定的 XORSHIFT 实例的 $A$ 和 $v$ 生成长度为 $N$ 的比特流。\n- 使用 Berlekamp–Massey 算法计算线性复杂度 $L(N)$ 以及 $n=1,\\dots,N$ 时的剖面 $L(n)$。\n- 在可用样本内，确定使 $\\operatorname{rank}_{\\mathbb{F}_2}(\\mathcal{O}_s) = 2w$ 的最小 $s$；如果不存在这样的 $s$，则报告 $s=-1$ 并且不尝试重构。\n- 在可能的情况下，使用恰好 $2w$ 个观测输出来重构 $S_0$，并验证重构的状态在相同的 $A$ 和 $v$ 下是否能再现这 $2w$ 个输出。报告一个布尔值表示是否成功。\n\n测试套件：\n- 测试用例 1（正常路径，奇偶校验输出）：\n  - 字长 $w=16$。\n  - 移位 $(a,b,c) = (7,9,13)$。\n  - 初始状态字 $s_{0,0} = $`0xACE1`，$s_{1,0} = $`0xBEEF`。\n  - 输出掩码 $v$ 等于第二个字的奇偶校验：$v$ 的前 $w$ 个条目为 $0$，$v$ 的后 $w$ 个条目为 $1$。\n  - 比特流长度 $N=512$。\n- 测试用例 2（边界情况，单位比特输出）：\n  - 字长 $w=8$。\n  - 移位 $(a,b,c) = (3,5,1)$。\n  - 初始状态字 $s_{0,0} = $`0x5D`，$s_{1,0} = $`0xC3`。\n  - 输出掩码 $v$ 选择第二个字的最低有效位：$v$ 的前 $w$ 个条目为 $0$，$v$ 的后 $w$ 个条目除最低有效位为 $1$ 外，其余均为 $0$。\n  - 比特流长度 $N=256$。\n- 测试用例 3（边缘情况，不可观测输出）：\n  - 字长 $w=8$。\n  - 移位 $(a,b,c) = (3,5,1)$。\n  - 初始状态字 $s_{0,0} = $`0x5D`，$s_{1,0} = $`0xC3`。\n  - 输出掩码 $v$ 是长度为 $2w$ 的零向量，因此对所有 $t$ 都有 $b_t=0$。\n  - 比特流长度 $N=64$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，输出一个子列表 $[s^\\star, L(N), \\text{success}]$，其中 $s^\\star$ 是达到完全可观测性秩的最小样本量（如果在提供的 $N$ 范围内不存在，则为 $-1$），$L(N)$ 是前 $N$ 个比特的线性复杂度，而 $\\text{success}$ 是一个布尔值，指示使用恰好 $2w$ 个输出来重构 $S_0$ 是否与这些输出匹配。示例格式：$[[s_1,L_1,\\text{True}],[s_2,L_2,\\text{True}],[s_3,L_3,\\text{False}]]$。所有输出都是纯数字或布尔值，没有单位。",
            "solution": "该问题要求从 $\\mathbb{F}_2$ 有限域上线性系统的角度，对一个特定的基于 XORSHIFT 的伪随机数生成器族进行分析。我们必须实现算法来确定输出比特流的线性复杂度，并测试状态的可观测性，从而可能重建生成器的初始状态。解决方案将建立在有限域上的线性代数和线性系统理论的基本原理之上。\n\n### 1. XORSHIFT 生成器的状态空间表示\n\n生成器在时间 $t$ 的状态是一个向量 $S_t \\in \\{0,1\\}^{2w}$，由两个 $w$ 比特的字 $s_{0,t}$ 和 $s_{1,t}$ 组成，使得 $S_t = \\begin{pmatrix} s_{0,t} \\\\ s_{1,t} \\end{pmatrix}$。状态更新是一个线性变换 $S_{t+1} = A S_t$，其中 $A$ 是一个矩阵 $A \\in \\{0,1\\}^{2w \\times 2w}$。我们从更新规则中推导 $A$ 的结构。\n\n状态上半部分的更新为 $s_{0,t+1} = s_{1,t}$。以矩阵形式，这可以写成：\n$$\ns_{0,t+1} = 0_w s_{0,t} + I_w s_{1,t}\n$$\n其中 $I_w$ 是 $w \\times w$ 的单位矩阵，$0_w$ 是 $w \\times w$ 的零矩阵。这给出了 $A$ 的顶部块行 $[0_w \\quad I_w]$。\n\n下半部分的更新涉及一个中间值 $t = s_{0,t} \\oplus (s_{0,t} \\ll a) \\oplus (s_{0,t} \\gg b)$，然后是 $s_{1,t+1} = t \\oplus (s_{1,t} \\gg c)$。将它们合并得到：\n$$\ns_{1,t+1} = s_{0,t} \\oplus (s_{0,t} \\ll a) \\oplus (s_{0,t} \\gg b) \\oplus (s_{1,t} \\gg c)\n$$\n按位运算（异或 $\\oplus$、左移 $\\ll$、右移 $\\gg$）在 $\\mathbb{F}_2$ 上是线性的。我们可以用矩阵来表示它们。令 $L_a$ 为左移 $a$ 位的矩阵，$R_b$ 为右移 $b$ 位的矩阵。如果 $i=j-a$，则元素 $(L_a)_{i,j}=1$，否则为 $0$。如果 $i=j+b$，则元素 $(R_b)_{i,j}=1$，否则为 $0$（使用基于0的索引，并假设补零）。异或运算对应于模2矩阵加法。$s_{1,t+1}$ 的更新变为：\n$$\ns_{1,t+1} = (I_w s_{0,t} + L_a s_{0,t} + R_b s_{0,t}) + R_c s_{1,t} = (I_w + L_a + R_b) s_{0,t} + R_c s_{1,t}\n$$\n这给出了 $A$ 的底部块行 $[I_w + L_a + R_b \\quad R_c]$。\n\n组合这些块行，状态转移矩阵 $A$ 正如问题描述中所给出的：\n$$\nA = \\begin{pmatrix}\n0_w  I_w \\\\\nI_w + L_a + R_b  R_c\n\\end{pmatrix}\n$$\n每一步的输出是单个比特 $b_t = v^\\top S_t$，其中 $v \\in \\{0,1\\}^{2w}$ 是一个固定的输出掩码向量。\n\n### 2. 线性复杂度与 Berlekamp–Massey 算法 (BMA)\n\n二进制序列 $\\{b_t\\}_{t=0}^{n-1}$ 的线性复杂度 $L(n)$ 是生成该序列的最短线性反馈移位寄存器（LFSR）的长度。长度为 $L$ 的 LFSR 由一个递推关系定义：\n$$\nb_k = \\sum_{i=1}^L c_i b_{k-i} \\pmod 2 \\quad \\text{for } k \\ge L\n$$\n其中系数 $c_i \\in \\{0,1\\}$ 定义了一个连接多项式 $C(x) = 1 + \\sum_{i=1}^L c_i x^i$。\n\nBerlekamp-Massey 算法是一种高效的迭代方法，用于寻找序列的 $L(n)$ 和相应的 $C(x)$。它逐比特地处理序列。在每一步 $n$，它计算下一个比特 $b_n$ 与当前 LFSR 预测的比特之间的差异 $d$。如果 $d \\neq 0$，则 LFSR 不正确，必须更新。连接多项式 $C(x)$ 和长度 $L$ 的更新规则旨在纠正差异，同时保持 $L$ 最小。\n\n该算法流程如下：\n1. 初始化线性复杂度 $L=0$，连接多项式 $C(x)=1$，一个辅助多项式 $B(x)=1$，以及一个辅助索引 $m=-1$。\n2. 对于 $n = 0, 1, \\dots, N-1$：\n   a. 计算差异：$d = b_n + \\sum_{i=1}^L c_i b_{n-i} \\pmod 2$。\n   b. 如果 $d=1$：\n      i. 存储当前多项式的副本：$T(x) = C(x)$。\n      ii. 更新连接多项式：$C(x) \\leftarrow C(x) + x^{n-m}B(x)$。\n      iii. 如果 $2L \\le n$，更新长度 $L \\leftarrow n+1-L$，更新索引 $m \\leftarrow n$，并设置辅助多项式 $B(x) \\leftarrow T(x)$。\n   c. 长度为 $n+1$ 的前缀的线性复杂度是 $L$ 的当前值。\n\n### 3. 状态可观测性与重构\n\n线性系统中的可观测性关系到初始状态 $S_0$ 是否能从一系列输出中唯一确定。输出序列由 $b_t = v^\\top S_t = v^\\top A^t S_0$ 给出。将其写成前 $s$ 个输出的形式，得到一个线性方程组：\n$$\n\\begin{pmatrix} b_0 \\\\ b_1 \\\\ \\vdots \\\\ b_{s-1} \\end{pmatrix} = \\begin{pmatrix} v^\\top \\\\ v^\\top A \\\\ \\vdots \\\\ v^\\top A^{s-1} \\end{pmatrix} S_0\n$$\n这就是系统 $\\mathbf{b}_s = \\mathcal{O}_s S_0$，其中 $\\mathcal{O}_s \\in \\{0,1\\}^{s \\times 2w}$ 是可观测性矩阵。\n\n当且仅当 $\\mathcal{O}_s$ 具有满列秩，即 $\\operatorname{rank}_{\\mathbb{F}_2}(\\mathcal{O}_s) = 2w$ 时，状态 $S_0$ 才能被唯一确定。秩为 $2w$ 要求至少 $s \\ge 2w$ 个观测值。Cayley-Hamilton 定理意味着我们不需要检查 $s  2w$ 来确定可观测性矩阵族的最大可能秩，但对于给定的生成器，达到此秩的最小 $s$（记为 $s^\\star$）可能更大。我们的任务是在可用的 $N$ 个样本内找到这个最小的 $s^\\star$。\n\n要使用恰好 $2w$ 个输出来重构 $S_0$，我们必须求解系统 $\\mathcal{O}_{2w} S_0 = \\mathbf{b}_{2w}$。唯一解存在的充要条件是方阵 $\\mathcal{O}_{2w}$ 可逆，这等价于 $\\operatorname{rank}_{\\mathbb{F}_2}(\\mathcal{O}_{2w}) = 2w$。如果此条件成立，我们可以通过对 $\\mathbb{F}_2$ 上的增广矩阵 $[\\mathcal{O}_{2w} | \\mathbf{b}_{2w}]$ 执行高斯消元（或更具体地，高斯-若尔当消元）来找到解 $S_0 = (\\mathcal{O}_{2w})^{-1} \\mathbf{b}_{2w}$，从而得到 $[I_{2w} | S_0']$ 的形式。向量 $S_0'$ 就是重构的状态。在 $\\mathbb{F}_2$ 上任何矩阵的秩也可以通过高斯消元确定，即计算行阶梯形矩阵中非零行（主元）的数量。\n\n实现将遵循以下原则：矩阵构建、流生成、应用BMA、可观测性矩阵的迭代秩计算，以及为状态重构求解线性系统，所有这些都将在模2算术下执行。",
            "answer": "```python\nimport numpy as np\n\ndef hex_to_vec(hex_str, w):\n    \"\"\"Converts a hex string to a numpy binary vector of specified width.\"\"\"\n    val = int(hex_str, 16)\n    bin_str = bin(val)[2:].zfill(w)\n    return np.array([int(b) for b in bin_str], dtype=np.uint8)\n\ndef build_shift_matrices(w, a, b, c):\n    \"\"\"Builds shift matrices L_a, R_b, R_c.\"\"\"\n    I_w = np.eye(w, dtype=np.uint8)\n    L_a = np.zeros((w, w), dtype=np.uint8)\n    if a > 0:\n        np.fill_diagonal(L_a[:, a:], 1)\n    \n    R_b = np.zeros((w, w), dtype=np.uint8)\n    if b > 0:\n        np.fill_diagonal(R_b[b:, :], 1)\n        \n    R_c = np.zeros((w, w), dtype=np.uint8)\n    if c > 0:\n        np.fill_diagonal(R_c[c:, :], 1)\n        \n    return I_w, L_a, R_b, R_c\n\ndef build_A(w, I_w, L_a, R_b, R_c):\n    \"\"\"Builds the state transition matrix A.\"\"\"\n    dim = 2 * w\n    A = np.zeros((dim, dim), dtype=np.uint8)\n    O_w = np.zeros((w, w), dtype=np.uint8)\n\n    # Top block row: [0_w, I_w]\n    A[0:w, w:dim] = I_w\n    \n    # Bottom block row: [I_w + L_a + R_b, R_c]\n    bottom_left = (I_w + L_a + R_b) % 2\n    A[w:dim, 0:w] = bottom_left\n    A[w:dim, w:dim] = R_c\n    \n    return A\n\ndef generate_stream(A, S0, v, N):\n    \"\"\"Generates a bitstream of length N.\"\"\"\n    S = S0.copy()\n    b_stream = np.zeros(N, dtype=np.uint8)\n    for t in range(N):\n        b_stream[t] = (v.T @ S) % 2\n        S = (A @ S) % 2\n    return b_stream\n\ndef berlekamp_massey(s):\n    \"\"\"\n    Berlekamp-Massey algorithm over F_2.\n    Returns the final linear complexity and the complexity profile.\n    \"\"\"\n    n = len(s)\n    c = [1]  # Connection polynomial C(x)\n    b = [1]  # Auxiliary polynomial B(x)\n    L = 0    # Linear complexity\n    m = -1   # Index of last length change\n    profile = []\n\n    for N_idx in range(n):\n        # Calculate discrepancy\n        d = s[N_idx]\n        if L > 0:\n            d_corr = sum(c[j] * s[N_idx - j] for j in range(1, L + 1))\n            d = (d + d_corr) % 2\n\n        if d == 1:\n            tc = list(c)  # T(x) = C(x)\n            \n            # Update C(x) = C(x) + x^(N_idx - m) * B(x)\n            shift = N_idx - m\n            b_shifted = [0] * shift + b\n            if len(c)  len(b_shifted):\n                c.extend([0] * (len(b_shifted) - len(c)))\n            if len(b_shifted)  len(c):\n                b_shifted.extend([0] * (len(c) - len(b_shifted)))\n            c = [(x + y) % 2 for x, y in zip(c, b_shifted)]\n            \n            # If necessary, update L\n            if 2 * L = N_idx:\n                L = N_idx + 1 - L\n                m = N_idx\n                b = tc\n        profile.append(L)\n\n    return (profile[-1] if profile else 0), profile\n\ndef gauss_jordan_f2(matrix):\n    \"\"\"Performs Gauss-Jordan elimination over F_2, returns RREF and rank.\"\"\"\n    mat = matrix.copy().astype(np.uint8)\n    num_rows, num_cols = mat.shape\n    pivot_row = 0\n    rank = 0\n    for j in range(num_cols):\n        if pivot_row  num_rows:\n            i = pivot_row\n            while i  num_rows and mat[i, j] == 0:\n                i += 1\n            \n            if i  num_rows:\n                mat[[pivot_row, i]] = mat[[i, pivot_row]]\n                \n                for k in range(num_rows):\n                    if k != pivot_row and mat[k, j] == 1:\n                        mat[k, :] = (mat[k, :] + mat[pivot_row, :]) % 2\n                \n                pivot_row += 1\n    rank = pivot_row\n    return mat, rank\n\ndef solve_f2(A, b):\n    \"\"\"Solves Ax = b over F_2 using Gaussian elimination.\"\"\"\n    m, n = A.shape\n    if m != n: return None\n    \n    augmented = np.hstack([A, b.reshape(-1, 1)])\n    rref, rank = gauss_jordan_f2(augmented)\n    \n    if rank  n: \n        return None\n    \n    solution = rref[:, n].reshape(-1, 1).astype(np.uint8)\n    return solution\n\ndef solve():\n    test_cases = [\n        {\n            \"w\": 16, \"abc\": (7, 9, 13), \"N\": 512,\n            \"s0_0\": \"0xACE1\", \"s1_0\": \"0xBEEF\", \"v_type\": \"parity_s1\"\n        },\n        {\n            \"w\": 8, \"abc\": (3, 5, 1), \"N\": 256,\n            \"s0_0\": \"0x5D\", \"s1_0\": \"0xC3\", \"v_type\": \"lsb_s1\"\n        },\n        {\n            \"w\": 8, \"abc\": (3, 5, 1), \"N\": 64,\n            \"s0_0\": \"0x5D\", \"s1_0\": \"0xC3\", \"v_type\": \"zero\"\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        w, (a, b, c), N = case[\"w\"], case[\"abc\"], case[\"N\"]\n        dim = 2 * w\n        \n        # 1. Construct matrices and initial state\n        I_w, L_a, R_b, R_c = build_shift_matrices(w, a, b, c)\n        A = build_A(w, I_w, L_a, R_b, R_c)\n        s0_vec = hex_to_vec(case[\"s0_0\"], w)\n        s1_vec = hex_to_vec(case[\"s1_0\"], w)\n        S0 = np.hstack([s0_vec, s1_vec]).reshape(-1, 1)\n\n        v = np.zeros((dim, 1), dtype=np.uint8)\n        if case[\"v_type\"] == \"parity_s1\":\n            v[w:, 0] = 1\n        elif case[\"v_type\"] == \"lsb_s1\":\n            v[dim - 1, 0] = 1\n        # v_type 'zero' is default\n        \n        # 2. Generate bitstream\n        b_stream = generate_stream(A, S0, v, N)\n\n        # 3. Compute linear complexity\n        L_N, _ = berlekamp_massey(b_stream)\n\n        # 4. Determine minimal sample size for observability\n        s_star = -1\n        v_row = v.T\n        O_rows = [v_row]\n        for s in range(1, N + 1):\n            O_s = np.vstack(O_rows)\n            _, rank = gauss_jordan_f2(O_s)\n            if rank == dim:\n                s_star = s\n                break\n            if s  N:\n                v_row = (v_row @ A) % 2\n                O_rows.append(v_row)\n        \n        # 5. Reconstruct S0 and verify\n        success = False\n        if N >= dim:\n            O_2w = np.vstack(O_rows[:dim])\n            _, rank_2w = gauss_jordan_f2(O_2w)\n            if rank_2w == dim:\n                b_2w = b_stream[:dim].reshape(-1, 1)\n                S0_recon = solve_f2(O_2w, b_2w)\n                if S0_recon is not None:\n                    # Verification\n                    b_recon = ((O_2w @ S0_recon) % 2).flatten()\n                    if np.array_equal(b_recon, b_stream[:dim]):\n                         # Check if reconstructed state is the same as original\n                         if np.array_equal(S0_recon, S0):\n                            success = True\n\n        results.append([s_star, L_N, success])\n    \n    # Format the final output string\n    formatted_results = [f\"[{s},{L},{str(suc)}]\" for s, L, suc in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}