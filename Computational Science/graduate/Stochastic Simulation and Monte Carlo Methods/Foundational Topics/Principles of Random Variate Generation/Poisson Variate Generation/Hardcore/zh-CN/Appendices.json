{
    "hands_on_practices": [
        {
            "introduction": "逆变换法是生成泊松随机变量的基石。通过针对一个给定的随机数，手动追踪算法的执行过程，您能具体地理解其内在机制，亲眼观察累积分布函数（$CDF$）如何被逐步构建直至满足停止条件。在进入自动化实现之前，这个练习  将巩固最核心的原理。",
            "id": "3329682",
            "problem": "考虑通过逆变换法，使用来自$(0,1)$上连续均匀分布的单个实现值$U$，生成一个速率参数为$\\lambda$的泊松分布随机变量。\n\n从第一性原理开始：泊松分布的概率质量函数 (PMF) 为 $p(k)=\\mathbb{P}(X=k)$，累积分布函数 (CDF) 为 $F(k)=\\mathbb{P}(X\\le k)=\\sum_{j=0}^{k}p(j)$。逆变换原理通过 $X=\\min\\{k\\in\\mathbb{Z}_{\\ge 0}:F(k)\\ge U\\}$ 定义了一个随机变量$X$，其中 $U\\sim\\text{Uniform}(0,1)$。\n\n任务：基于上述基本定义，推导一个最小化操作的逆变换序列，该序列需满足：\n- 从基础概率 $p(0)$ 开始，该概率等于零事件的概率，并且\n- 仅使用相邻 PMF 值之间的乘法更新，该更新由连续 PMF 项的比率得到，以更新 $p(k)$ 和运行中的 CDF $F(k)$，\n- 采用一个以 $U$ 和运行中的 CDF 表示的停止准则，该准则在满足逆变换定义的第一个 $k$ 处停止。\n\n然后，将您推导的过程应用于特定情况 $\\lambda=7.3$ 和给定的均匀分布随机变量 $U=0.513$，并执行该序列直到满足停止准则。将返回的样本 $X$ 报告为单个整数。无需四舍五入，也无需单位。",
            "solution": "推导过程始于概率质量函数 (PMF)、累积分布函数 (CDF) 和逆变换原理的定义。对于速率为 $\\lambda$ 的泊松随机变量，其 PMF 为\n$$\np(k)=\\mathbb{P}(X=k)=\\exp(-\\lambda)\\frac{\\lambda^{k}}{k!},\\quad k\\in\\mathbb{Z}_{\\ge 0}.\n$$\nCDF 为\n$$\nF(k)=\\sum_{j=0}^{k}p(j).\n$$\n根据逆变换原理，对于 $U\\sim\\text{Uniform}(0,1)$，随机变量\n$$\nX=\\min\\{k\\in\\mathbb{Z}_{\\ge 0}:\\,F(k)\\ge U\\}\n$$\n具有所期望的分布，因为\n$$\n\\mathbb{P}(X\\le k)=\\mathbb{P}\\big(U\\le F(k)\\big)=F(k),\n$$\n利用了对于 $U\\sim\\text{Uniform}(0,1)$，当 $t\\in[0,1]$ 时有 $\\mathbb{P}(U\\le t)=t$ 这一事实。\n\n为获得最小化操作的逆变换序列，通过利用连续 PMF 值的比率来避免在每一步重新计算阶乘或幂：\n$$\n\\frac{p(k)}{p(k-1)}=\\frac{\\exp(-\\lambda)\\lambda^{k}/k!}{\\exp(-\\lambda)\\lambda^{k-1}/(k-1)!}=\\frac{\\lambda}{k},\\quad k\\ge 1.\n$$\n这得到了乘法更新式\n$$\np(k)=p(k-1)\\frac{\\lambda}{k},\\quad k\\ge 1,\n$$\n其初始值为基础概率\n$$\np(0)=\\exp(-\\lambda).\n$$\n为 CDF 定义一个运行中的部分和，\n$$\nF(k)=F(k-1)+p(k),\\quad F(-1)=0,\n$$\n因此，程序步骤如下：\n- 初始化 $k\\leftarrow 0$, $p\\leftarrow \\exp(-\\lambda)$, $F\\leftarrow p$。\n- 当 $UF$ 时，递增 $k\\leftarrow k+1$，更新 $p\\leftarrow p\\cdot \\lambda/k$，并更新 $F\\leftarrow F+p$。\n- 在第一个满足 $U\\le F$ 的 $k$ 处停止，并返回 $X\\leftarrow k$。\n\n此过程在操作上是最小化的，因为每一步仅使用一次乘法和一次除法从 $p(k-1)$ 获得 $p(k)$，外加一次加法来更新 $F(k)$。\n\n现在将此序列应用于 $\\lambda=7.3$ 和 $U=0.513$。初始化\n$$\np(0)=\\exp(-7.3)\\approx 0.0006754629,\\quad F(0)=0.0006754629.\n$$\n由于 $U=0.513F(0)$，继续。使用 $p(k)=p(k-1)\\cdot \\lambda/k$ 和 $F(k)=F(k-1)+p(k)$：\n- $k=1$: $p(1)=p(0)\\cdot 7.3/1\\approx 0.004930876$, $F(1)\\approx 0.0006754629+0.004930876=0.0056063389$。\n- $k=2$: $p(2)=p(1)\\cdot 7.3/2\\approx 0.017997697$, $F(2)\\approx 0.0236040359$。\n- $k=3$: $p(3)=p(2)\\cdot 7.3/3\\approx 0.043794397$, $F(3)\\approx 0.067398433$。\n- $k=4$: $p(4)=p(3)\\cdot 7.3/4\\approx 0.079924775$, $F(4)\\approx 0.147323208$。\n- $k=5$: $p(5)=p(4)\\cdot 7.3/5\\approx 0.116690171$, $F(5)\\approx 0.264013379$。\n- $k=6$: $p(6)=p(5)\\cdot 7.3/6\\approx 0.141973041$, $F(6)\\approx 0.405986420$。\n- $k=7$: $p(7)=p(6)\\cdot 7.3/7\\approx 0.148057600$, $F(7)\\approx 0.554044020$。\n\n在 $k=6$ 时，$F(6) \\approx 0.405986420  0.513$，循环继续。在 $k=7$ 时， $F(7) \\approx 0.554044020 \\ge 0.513$。此时，逆变换的条件首次满足，因此我们停止并返回 $X=7$。",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "在学习了如何实现一个生成器后，下一个关键问题是：我们如何确保它是正确的？这个练习  将指导您创建一个全面的验证协议，这是任何严肃模拟工作中的关键一步。您将学习不仅使用卡方检验来测试整体的分布形状，还将验证诸如均值和方差等基本属性，以确保您的生成器在统计上是可靠的。",
            "id": "3329708",
            "problem": "您的任务是基于随机模拟和蒙特卡洛方法的第一性原理，为泊松分布的采样器设计并实现一个验证协议。该协议必须同时评估矩的一致性和分布的保真度。您必须在一个完整、可运行的程序中实现以下要求。\n\n被测采样器生成据称遵循参数为 $ \\lambda  0 $ 的泊松分布的独立样本。泊松分布由概率质量函数 $ p(k) = \\mathbb{P}(X = k) = e^{-\\lambda} \\lambda^{k} / k! $ 定义，其中整数 $ k \\ge 0 $。构成基础的数学事实是：$ \\mathbb{E}[X] = \\lambda $ 和 $ \\operatorname{Var}(X) = \\lambda $，并且根据中心极限定理（CLT），归一化的样本均值满足一个极限定理。您必须利用这些基础以及独立同分布（i.i.d.）样本的聚合统计量的渐近行为来推导您的检验。\n\n矩验证：\n- 构造一个关于样本均值 $ \\bar{X} $ 的双边检验，以评估其在中心极限定理下是否与 $ \\lambda $ 一致，使用以小数表示的显著性水平 $ \\alpha_{\\text{mean}} $。您的最终检验必须返回一个布尔值结果，表示接受或拒绝。\n- 构造一个关于样本方差 $ S^{2} $ 的双边检验，使用从四阶中心矩和独立同分布观测值的样本方差的方差推导出的渐近近似，以评估等离散性（方差等于均值）。使用以小数表示的显著性水平 $ \\alpha_{\\text{var}} $。您的最终检验必须返回一个布尔值结果，表示接受或拒绝。\n\n拟合优度验证：\n- 使用皮尔逊卡方统计量实现一个离散拟合优度检验。必须进行分箱。在非负整数上定义分箱，使得在泊松模型下每个箱的期望计数至少为 $ c_{\\min} $，其中 $ c_{\\min} $ 作为整数提供，且必须至少为 $ 5 $。设分箱数量为 $ B $。在计算拟合优度统计量时，将 $ \\lambda $ 视为已知，不从数据中估计它，因此自由度为 $ B - 1 $。\n- 您的分箱规范必须是算法化的：从 $ k = 0 $ 开始，聚合连续的整数类别，直到每个箱都满足期望计数阈值 $ c_{\\min} $。您还必须包含一个最终的尾部箱，该箱聚合所有超出最大显式枚举类别的值。为了使枚举有限，将显式类别列表截断于最小整数 $ K $，使得直到 $ K $ 的累积泊松概率至少为 $ 1 - \\varepsilon $，其中 $ \\varepsilon $ 是以小数形式提供的尾部概率阈值（例如 $ 10^{-12} $）。如果尾部箱的期望计数低于 $ c_{\\min} $，则将其与前一个箱合并。\n- 计算各分箱上的皮尔逊卡方统计量及其使用卡方分布计算出的相关 $ p $ 值。使用以小数表示的显著性水平 $ \\alpha_{\\text{gof}} $。您的最终检验必须返回一个布尔值结果，表示接受或拒绝。\n\n协议决策：\n- 当且仅当所有三个验证（均值检验、方差检验和拟合优度检验）都接受时，整个协议才接受该采样器。\n\n您还必须在您的设计理由中概念性地包含离散柯尔莫哥洛夫-斯米尔诺夫（KS）检验，通过引用其作为替代的离散拟合优度度量的作用，但程序中实现的检验必须是如上所述的卡方检验。\n\n实现约束：\n- 使用逆变换法实现一个泊松采样器：抽取 $ U \\sim \\text{Uniform}(0,1) $，通过递推 $ p(0) = e^{-\\lambda} $ 和 $ p(k+1) = p(k) \\cdot \\lambda / (k+1) $ 来枚举累积分布函数（CDF）$ F(k) = \\sum_{j=0}^{k} p(j) $，并返回满足 $ F(k) \\ge U $ 的最小 $ k $。此采样器必须用于在测试套件中生成“正确”的样本。\n- 此外，实现三个有缺陷的采样器来挑战该协议：\n    1. 一个均值偏移的采样器，它返回来自参数为 $ (1+\\delta)\\lambda $ 的泊松分布的样本，其中 $ \\delta  0 $ 已指定。\n    2. 一个方差膨胀的混合采样器，它从 $ \\text{Poisson}(\\lambda) $ 中抽取一半样本，从 $ \\text{Poisson}(\\lambda+\\Delta) $ 中抽取另一半，其中 $ \\Delta  0 $ 已指定。\n    3. 一个截断采样器，它从 $ \\text{Poisson}(\\lambda) $ 中抽取样本，并将值截断在指定上限 $ k_{\\max} $ 处。\n\n您的程序必须实现验证协议，并将其应用于以下测试套件。为保证可复现性，请使用固定的随机种子。\n\n测试套件参数集：\n- 案例 $ 1 $: $ \\lambda = 3.0 $, 样本量 $ n = 8000 $, 采样器类型 \"correct\", $ \\alpha_{\\text{mean}} = 0.01 $, $ \\alpha_{\\text{var}} = 0.01 $, $ \\alpha_{\\text{gof}} = 0.05 $, $ c_{\\min} = 5 $, $ \\varepsilon = 10^{-12} $。\n- 案例 $ 2 $: $ \\lambda = 20.0 $, 样本量 $ n = 15000 $, 采样器类型 \"correct\", $ \\alpha_{\\text{mean}} = 0.01 $, $ \\alpha_{\\text{var}} = 0.01 $, $ \\alpha_{\\text{gof}} = 0.05 $, $ c_{\\min} = 5 $, $ \\varepsilon = 10^{-12} $。\n- 案例 $ 3 $: $ \\lambda = 0.3 $, 样本量 $ n = 10000 $, 采样器类型 \"correct\", $ \\alpha_{\\text{mean}} = 0.01 $, $ \\alpha_{\\text{var}} = 0.01 $, $ \\alpha_{\\text{gof}} = 0.05 $, $ c_{\\min} = 5 $, $ \\varepsilon = 10^{-12} $。\n- 案例 $ 4 $: $ \\lambda = 5.0 $, 样本量 $ n = 8000 $, 采样器类型 \"mean_shift\"，其中 $ \\delta = 0.1 $, $ \\alpha_{\\text{mean}} = 0.01 $, $ \\alpha_{\\text{var}} = 0.01 $, $ \\alpha_{\\text{gof}} = 0.05 $, $ c_{\\min} = 5 $, $ \\varepsilon = 10^{-12} $。\n- 案例 $ 5 $: $ \\lambda = 10.0 $, 样本量 $ n = 10000 $, 采样器类型 \"variance_mixture\"，其中 $ \\Delta = 4.0 $, $ \\alpha_{\\text{mean}} = 0.01 $, $ \\alpha_{\\text{var}} = 0.01 $, $ \\alpha_{\\text{gof}} = 0.05 $, $ c_{\\min} = 5 $, $ \\varepsilon = 10^{-12} $。\n- 案例 $ 6 $: $ \\lambda = 30.0 $, 样本量 $ n = 8000 $, 采样器类型 \"truncated\"，上限为 $ k_{\\max} = 22 $, $ \\alpha_{\\text{mean}} = 0.01 $, $ \\alpha_{\\text{var}} = 0.01 $, $ \\alpha_{\\text{gof}} = 0.05 $, $ c_{\\min} = 5 $, $ \\varepsilon = 10^{-12} $。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按顺序排列的六个案例的结果，形式为方括号内以逗号分隔的布尔值列表（例如，$ [\\text{True},\\text{False},\\ldots] $）。不应打印任何其他文本。\n\n角度单位不适用。不涉及物理单位。所有显著性水平必须作为小数处理，而不是百分比。确保所有算法选择都与基础事实以及分箱和渐近近似的统计学上合理实践相一致。",
            "solution": "任务是为据称从泊松分布生成随机变量的统计采样器设计并实现一个全面的验证协议。该协议必须基于随机模拟的第一性原理，利用基于矩的检验和拟合优度检验。最终输出是针对多个测试用例的采样器有效性的综合决策。\n\n### 泊松分布的基本原理\n\n泊松分布由其率参数 $\\lambda  0$ 参数化，描述了在固定的时间或空间间隔内发生给定数量事件的概率。其概率质量函数（PMF）由下式给出：\n$$\np(k; \\lambda) = \\mathbb{P}(X = k) = \\frac{e^{-\\lambda} \\lambda^k}{k!} \\quad \\text{for } k \\in \\{0, 1, 2, \\dots\\}\n$$\n泊松分布的一个决定性特征是等离散性，即均值和方差相等：\n$$\n\\mathbb{E}[X] = \\lambda\n$$\n$$\n\\operatorname{Var}(X) = \\sigma^2 = \\lambda\n$$\n这些基本属性构成了我们验证检验的基础。给定一组据称是独立同分布（i.i.d.）的样本 $\\{X_1, X_2, \\dots, X_n\\}$，我们必须检验这些样本源自 $\\text{Poisson}(\\lambda)$ 分布的原假设 $H_0$。\n\n### 1. 矩验证\n\n基于矩的检验用于验证样本矩（均值、方差）在原假设下是否与它们的理论对应值在统计上一致。我们使用从中心极限定理（CLT）推导出的针对大样本量 $n$ 的渐近结果。\n\n#### 1.1. 样本均值检验\n\n原理：中心极限定理指出，对于一个大的独立同分布样本，样本均值 $\\bar{X} = \\frac{1}{n}\\sum_{i=1}^n X_i$ 近似服从正态分布。在 $H_0$ 下，总体均值为 $\\mu = \\lambda$，方差为 $\\sigma^2 = \\lambda$。因此，样本均值的分布为：\n$$\n\\bar{X} \\dot{\\sim} \\mathcal{N}\\left(\\lambda, \\frac{\\lambda}{n}\\right)\n$$\n其中 $\\dot{\\sim}$ 表示“近似服从……分布”。\n\n检验构造：我们可以构造一个服从标准正态分布 $\\mathcal{N}(0, 1)$ 的标准化检验统计量 $Z_{\\text{mean}}$：\n$$\nZ_{\\text{mean}} = \\frac{\\bar{X} - \\mathbb{E}[\\bar{X}]}{\\sqrt{\\operatorname{Var}(\\bar{X})}} = \\frac{\\bar{X} - \\lambda}{\\sqrt{\\lambda/n}}\n$$\n对于显著性水平为 $\\alpha_{\\text{mean}}$ 的双边检验，如果观测到的统计量落在标准正态分布的尾部，我们拒绝 $H_0$。接受域由 $|Z_{\\text{mean}}| \\le z_{1-\\alpha_{\\text{mean}}/2}$ 定义，其中 $z_{q}$ 是 $\\mathcal{N}(0, 1)$ 分布的 $q$-分位数。如果此条件成立，则检验接受，返回 `True`。\n\n#### 1.2. 样本方差检验\n\n原理：与样本均值类似，样本方差 $S^2 = \\frac{1}{n-1}\\sum_{i=1}^n (X_i - \\bar{X})^2$ 对于大的 $n$ 也具有渐近正态分布。$S^2$ 的期望值为 $\\sigma^2$。在 $H_0$ 下，此值为 $\\lambda$。对于大的 $n$，样本方差的方差由下式给出：\n$$\n\\operatorname{Var}(S^2) \\approx \\frac{1}{n} (\\mu_4 - \\sigma^4)\n$$\n其中 $\\mu_4 = \\mathbb{E}[(X-\\mu)^4]$ 是基础分布的四阶中心矩。\n\n检验构造：对于泊松($\\lambda$)分布，四阶中心矩为 $\\mu_4 = \\lambda + 3\\lambda^2$。由于 $\\sigma^2 = \\lambda$，我们有 $\\sigma^4 = \\lambda^2$。因此，样本方差的方差为：\n$$\n\\operatorname{Var}(S^2) \\approx \\frac{1}{n} ((\\lambda + 3\\lambda^2) - \\lambda^2) = \\frac{2\\lambda^2 + \\lambda}{n}\n$$\n我们为样本方差构造一个标准化的检验统计量 $Z_{\\text{var}}$：\n$$\nZ_{\\text{var}} = \\frac{S^2 - \\mathbb{E}[S^2]}{\\sqrt{\\operatorname{Var}(S^2)}} = \\frac{S^2 - \\lambda}{\\sqrt{(2\\lambda^2 + \\lambda)/n}}\n$$\n对于显著性水平为 $\\alpha_{\\text{var}}$ 的双边检验，接受域为 $|Z_{\\text{var}}| \\le z_{1-\\alpha_{\\text{var}}/2}$。如果此条件成立，则检验接受，返回 `True`。此检验直接评估等离散性属性。\n\n### 2. 分布保真度验证（拟合优度）\n\n虽然矩检验是必要的，但它们并非充分条件。一个分布可以有正确的均值和方差，但其形状仍可能偏离目标分布。拟合优度（GOF）检验将样本的经验分布与理论分布进行比较。\n\n#### 2.1. 皮尔逊卡方检验\n\n原理：此检验将样本空间划分为有限数量的箱（$B$），并将每个箱中样本的观测计数 $O_i$ 与原假设下的期望计数 $E_i$ 进行比较。检验统计量为：\n$$\n\\chi^2 = \\sum_{i=1}^{B} \\frac{(O_i - E_i)^2}{E_i}\n$$\n在 $H_0$ 下，并且在期望计数足够大（例如 $E_i \\ge c_{\\min}=5$）的情况下，该统计量服从自由度为 $df$ 的卡方分布 $\\chi^2_{df}$。\n\n检验构造：\n*   自由度：由于参数 $\\lambda$ 由原假设指定，而不是从数据中估计，因此自由度为 $df = B - 1$。\n*   离散分布的分箱：该问题要求采用特定的算法化分箱策略，以确保每个箱具有足够的期望计数，$E_i = n \\cdot P(\\text{bin}_i) \\ge c_{\\min}$。\n    1.  值 $k$ 的范围是无限的。我们首先在一个点 $K$ 处截断显式枚举，使得尾部概率可以忽略不计：$F(K) = \\sum_{j=0}^{K} p(j; \\lambda) \\ge 1 - \\varepsilon$。\n    2.  从 $k=0$ 开始，我们通过分组连续的整数结果来形成箱。一旦当前箱的累积期望计数达到或超过 $c_{\\min}$，就开始一个新的箱。\n    3.  最终的箱包括直到 $K$ 的所有剩余结果以及超出 $K$ 的尾部概率质量。如果这个最终箱的期望计数低于 $c_{\\min}$，则将其与前一个箱合并。\n*   决策规则：我们计算 $p$ 值，即假设 $H_0$ 为真时，观测到与计算值一样极端或更极端的 $\\chi^2$ 统计量的概率：$p\\text{-值} = \\mathbb{P}(\\chi^2_{df} \\ge \\chi^2_{\\text{观测值}})$。如果 $p$ 值大于或等于显著性水平 $\\alpha_{\\text{gof}}$，我们接受 $H_0$。\n\n替代性拟合优度检验：问题陈述中提到了离散柯尔莫哥洛夫-斯米尔诺夫（KS）检验作为一个概念上的替代方案。KS检验评估经验累积分布函数（ECDF）与理论累积分布函数（CDF）之间的最大绝对差。虽然它对连续分布很有效，但其在离散分布上的应用更为复杂，因为标准检验会变得保守（即，更不容易拒绝错误的原假设）。对于本问题的背景，带有强制分箱的卡方检验是一种更标准、更直接的方法。\n\n### 3. 采样器实现\n\n验证协议将针对几个采样器进行测试。\n\n*   正确的采样器（逆变换法）：此方法基于概率积分变换。对于具有累积分布函数 $F(k)$ 的离散分布，我们生成一个均匀随机变量 $U \\sim \\text{Uniform}(0,1)$，并找到满足 $F(k) \\ge U$ 的最小整数 $k$。CDF 通过迭代计算：$p(0) = e^{-\\lambda}$，$p(k+1) = p(k)\\lambda/(k+1)$，以及 $F(k) = F(k-1) + p(k)$。\n*   有缺陷的采样器：\n    1.  均值偏移：从 $\\text{Poisson}((1+\\delta)\\lambda)$ 中采样，这应该会被均值检验检测到。\n    2.  方差膨胀：一个 $50/50$ 的 $\\text{Poisson}(\\lambda)$ 和 $\\text{Poisson}(\\lambda+\\Delta)$ 的混合。该分布将是过度离散的（方差大于均值），这是方差检验旨在检测的属性。\n    3.  截断：从 $\\text{Poisson}(\\lambda)$ 中抽取的样本被限制在最大值 $k_{\\max}$。这会扭曲整个分布，影响均值、方差和形状，并且应该被所有三个检验检测到。\n\n### 4. 整体协议决策\n\n验证协议是毫不妥协的。一个采样器被认为是有效的，当且仅当它通过所有三个独立的检查：均值一致性检验、方差一致性（等离散性）检验和分布拟合优度检验。最终输出是这三个组成部分的布尔结果的逻辑与（AND）。\n$$\n\\text{Accept Sampler} \\iff (\\text{Accept}_{\\text{mean}} \\land \\text{Accept}_{\\text{var}} \\land \\text{Accept}_{\\text{gof}})\n$$\n这种复合结构确保了对采样器正确性的严格评估，既检查了其低阶矩，也检查了其整体分布形状。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm, chi2, poisson\n\ndef poisson_sampler_inversion(lam, n, rng):\n    \"\"\"\n    Generates n samples from a Poisson(lam) distribution using the inversion method.\n    \"\"\"\n    samples = np.zeros(n, dtype=int)\n    for i in range(n):\n        u = rng.uniform(0, 1)\n        k = 0\n        p_k = np.exp(-lam)\n        cdf_k = p_k\n        while u > cdf_k:\n            k += 1\n            # Recurrence relation for PMF: p(k) = p(k-1) * lam / k\n            p_k *= lam / k\n            cdf_k += p_k\n        samples[i] = k\n    return samples\n\ndef run_validation_protocol(samples, lam, alpha_mean, alpha_var, alpha_gof, c_min, eps):\n    \"\"\"\n    Applies the full validation protocol to a set of samples.\n    \"\"\"\n    n = len(samples)\n\n    # 1. Mean Test (CLT-based)\n    sample_mean = np.mean(samples)\n    z_mean = (sample_mean - lam) / np.sqrt(lam / n)\n    critical_value_mean = norm.ppf(1 - alpha_mean / 2)\n    pass_mean = np.abs(z_mean) = critical_value_mean\n\n    # 2. Variance Test (Asymptotic normal approximation for sample variance)\n    sample_var = np.var(samples, ddof=1)\n    # Asymptotic variance of sample variance for Poisson(lam) is (2*lam^2 + lam)/n\n    asymp_var_of_s2 = (2 * lam**2 + lam) / n\n    # Avoid division by zero if lam=0 (though problem states lam > 0)\n    z_var = (sample_var - lam) / np.sqrt(asymp_var_of_s2) if asymp_var_of_s2 > 0 else 0\n    critical_value_var = norm.ppf(1 - alpha_var / 2)\n    pass_var = np.abs(z_var) = critical_value_var\n\n    # 3. Goodness-of-Fit Test (Pearson's Chi-Square)\n    \n    # Determine truncation point K for binning\n    K = poisson.ppf(1 - eps, lam)\n    \n    # Pre-compute PMF values\n    k_vals = np.arange(int(K) + 2)\n    pmf = poisson.pmf(k_vals, lam)\n    \n    # Algorithmic binning\n    bin_boundaries = [0]\n    current_bin_expected_count = 0.0\n    \n    for k in range(int(K) + 1):\n        current_bin_expected_count += n * pmf[k]\n        if current_bin_expected_count >= c_min:\n            bin_boundaries.append(k + 1)\n            current_bin_expected_count = 0.0\n\n    # Handle the tail\n    # The last bin edge should be infinity to capture all remaining values\n    if len(bin_boundaries) == 1 or bin_boundaries[-1] = K:\n        bin_boundaries.append(np.inf)\n    else:\n        bin_boundaries[-1] = np.inf\n         \n    # Merge last bin if its expected count is too low\n    # Calculate probability in the last defined bin\n    if len(bin_boundaries) > 2:\n        last_boundary_int = int(bin_boundaries[-2])\n        prob_in_last_bin = 1.0 - poisson.cdf(last_boundary_int - 1, lam)\n        expected_in_last_bin = n * prob_in_last_bin\n    \n        if expected_in_last_bin  c_min:\n            bin_boundaries.pop(-2) # Merge by removing the second to last boundary\n    \n    # Calculate observed and expected counts\n    observed_counts, _ = np.histogram(samples, bins=bin_boundaries)\n    \n    expected_counts = np.zeros_like(observed_counts, dtype=float)\n    for i in range(len(observed_counts)):\n        lower = int(bin_boundaries[i])\n        upper = bin_boundaries[i+1]\n        \n        if np.isinf(upper):\n            prob_in_bin = 1.0 - poisson.cdf(lower - 1, lam)\n        else:\n            prob_in_bin = poisson.cdf(upper - 1, lam) - poisson.cdf(lower - 1, lam)\n        expected_counts[i] = n * prob_in_bin\n    \n    # Chi-square statistic calculation\n    # Filter out bins with zero expected count (should not happen with proper binning)\n    valid_bins = expected_counts > 0\n    chi2_stat = np.sum((observed_counts[valid_bins] - expected_counts[valid_bins])**2 / expected_counts[valid_bins])\n    \n    # Degrees of freedom = Number of bins - 1 (since lambda is known)\n    B = len(observed_counts)\n    df = B - 1\n    \n    p_value = chi2.sf(chi2_stat, df) if df > 0 else 1.0\n    pass_gof = p_value >= alpha_gof\n\n    # Overall decision\n    return pass_mean and pass_var and pass_gof\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Use a fixed random seed for reproducibility\n    rng = np.random.default_rng(seed=42)\n\n    test_cases = [\n        # Case 1: Correct sampler, moderate lambda\n        {'lam': 3.0, 'n': 8000, 'type': 'correct', 'params': {}, 'alpha_mean': 0.01, 'alpha_var': 0.01, 'alpha_gof': 0.05, 'c_min': 5, 'eps': 1e-12},\n        # Case 2: Correct sampler, high lambda\n        {'lam': 20.0, 'n': 15000, 'type': 'correct', 'params': {}, 'alpha_mean': 0.01, 'alpha_var': 0.01, 'alpha_gof': 0.05, 'c_min': 5, 'eps': 1e-12},\n        # Case 3: Correct sampler, low lambda\n        {'lam': 0.3, 'n': 10000, 'type': 'correct', 'params': {}, 'alpha_mean': 0.01, 'alpha_var': 0.01, 'alpha_gof': 0.05, 'c_min': 5, 'eps': 1e-12},\n        # Case 4: Mean-shifted sampler\n        {'lam': 5.0, 'n': 8000, 'type': 'mean_shift', 'params': {'delta': 0.1}, 'alpha_mean': 0.01, 'alpha_var': 0.01, 'alpha_gof': 0.05, 'c_min': 5, 'eps': 1e-12},\n        # Case 5: Variance-inflated mixture sampler\n        {'lam': 10.0, 'n': 10000, 'type': 'variance_mixture', 'params': {'Delta': 4.0}, 'alpha_mean': 0.01, 'alpha_var': 0.01, 'alpha_gof': 0.05, 'c_min': 5, 'eps': 1e-12},\n        # Case 6: Truncated sampler\n        {'lam': 30.0, 'n': 8000, 'type': 'truncated', 'params': {'k_max': 22}, 'alpha_mean': 0.01, 'alpha_var': 0.01, 'alpha_gof': 0.05, 'c_min': 5, 'eps': 1e-12},\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case['n']\n        lam = case['lam']\n        \n        # Generate samples based on the sampler type\n        if case['type'] == 'correct':\n            samples = poisson_sampler_inversion(lam, n, rng)\n        elif case['type'] == 'mean_shift':\n            delta = case['params']['delta']\n            shifted_lam = lam * (1 + delta)\n            samples = poisson_sampler_inversion(shifted_lam, n, rng)\n        elif case['type'] == 'variance_mixture':\n            Delta = case['params']['Delta']\n            n_half = n // 2\n            samples1 = poisson_sampler_inversion(lam, n_half, rng)\n            samples2 = poisson_sampler_inversion(lam + Delta, n - n_half, rng)\n            samples = np.concatenate([samples1, samples2])\n            rng.shuffle(samples)\n        elif case['type'] == 'truncated':\n            k_max = case['params']['k_max']\n            raw_samples = poisson_sampler_inversion(lam, n, rng)\n            samples = np.minimum(raw_samples, k_max)\n        \n        # Run the validation protocol\n        protocol_result = run_validation_protocol(\n            samples, lam, case['alpha_mean'], case['alpha_var'], \n            case['alpha_gof'], case['c_min'], case['eps']\n        )\n        results.append(protocol_result)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在大规模模拟中，随机变量的生成速度至关重要。本练习  将探讨如何通过向量化（现代处理器中常见的SIMD数据并行形式）来加速基本的逆变换算法。您不仅将实现这一高性能版本，还将分析一个关键挑战：由不同计算通道在不同时间点终止所引起的负载不均衡问题，从而连接统计理论与实际的高性能计算。",
            "id": "3329675",
            "problem": "设计并实现一个完整的、向量化的逆变换算法，该算法使用递推更新，在多个并行通道上生成泊松随机变量。您的任务是从第一性原理推导出该算法，然后将其实现为一个单指令多数据流（SIMD）风格的掩码向量循环。该循环应能同时在所有通道上更新概率递推关系，并处理因各个通道在不同迭代次数完成而导致的通道终止情况。\n\n数学基础与目标：\n- 率参数为 $\\lambda \\gt 0$ 的泊松分布具有概率质量函数\n$$\n\\mathbb{P}(K = k) \\;=\\; e^{-\\lambda}\\,\\frac{\\lambda^k}{k!}, \\quad k \\in \\{0,1,2,\\dots\\}.\n$$\n- 逆变换法抽取 $U \\sim \\mathrm{Uniform}(0,1)$ 并返回满足累积分布函数条件的最小整数 $k$\n$$\n\\sum_{j=0}^{k} e^{-\\lambda}\\,\\frac{\\lambda^j}{j!} \\;\\ge\\; U.\n$$\n- 累积分布可以使用经过充分检验的概率递推关系进行迭代累加\n$$\np(k+1) \\;=\\; p(k)\\,\\frac{\\lambda}{k+1}, \\quad \\text{其中 } p(0) \\;=\\; e^{-\\lambda}.\n$$\n- 您必须通过维护 $p(k)$ 和累积和的逐通道数组，并在所有通道上推进单个迭代索引 $k$ 的方式，对 $L$ 个通道的逆变换过程进行向量化。其中，使用一个布尔活动掩码来仅更新那些尚未终止的通道。\n\n算法要求：\n1. 从上述递推定义出发，推导出一个掩码向量循环，该循环：\n   - 在 $L$ 个通道上统一初始化 $p(0) = e^{-\\lambda}$。\n   - 维护一个逐通道的累积和 $S(k) = \\sum_{j=0}^k p(j)$。\n   - 在 $k=0$ 时，将 $S(0)$ 与每个通道的均匀随机数 $U_\\ell$ 进行比较，以确定立即终止（即 $K_\\ell=0$）的通道。\n   - 对于 $k \\ge 1$，仅通过递推关系 $p(k) = p(k-1)\\,\\lambda/k$ 更新活动（未终止）的通道，增加它们的累积和，并标记那些新满足 $S(k) \\ge U_\\ell$ 条件的通道，同时存储 $K_\\ell = k$。\n   - 当所有通道都终止时停止。定义处理的总迭代次数为\n     $$\n     T \\;=\\; 1 + \\max_{\\ell \\in \\{1,\\dots,L\\}} K_\\ell,\n     $$\n     其中 $+\\,1$ 是为了计入初始的 $k=0$ 步骤。\n2. 将负载均衡效率定义为在所有迭代中活动通道的平均比例：\n   $$\n   \\eta \\;=\\; \\frac{\\sum_{\\ell=1}^{L} \\left(K_\\ell + 1\\right)}{T \\cdot L}.\n   $$\n   在这里，每个通道 $\\ell$ 贡献了 $K_\\ell + 1$ 次活动迭代（从 $k=0$ 到 $k=K_\\ell$，包含两端）。同时，计算总的空闲通道步数，\n   $$\n   I \\;=\\; T\\cdot L \\;-\\; \\sum_{\\ell=1}^{L} \\left(K_\\ell + 1\\right).\n   $$\n   这些定义量化了由不同通道的不同终止深度引起的负载不均衡。\n\n实现约束：\n- 使用掩码更新以向量化的方式实现算法，不得使用逐通道的标量循环。\n- 不要假设任何特殊硬件；使用标准数组操作来模拟SIMD掩码语义。\n-所有答案都是无单位的，并应按指定格式提供为整数或小数。\n\n测试套件：\n使用 $L = 6$ 个通道。对于每个测试用例，给定一个率参数 $\\lambda$ 和一个固定的均匀随机数向量 $U = \\{u_1,u_2,u_3,u_4,u_5,u_6\\}$。对每个测试用例，计算：\n- 逐通道的泊松输出结果 $[K_1,K_2,K_3,K_4,K_5,K_6]$（整数）。\n- 总迭代次数 $T$（整数）。\n- 效率 $\\eta$（四舍五入到恰好六位小数）。\n- 空闲通道步数 $I$（整数）。\n\n为以下四个测试用例提供结果：\n- 案例A：$\\lambda = 0.1$, $U = \\{0.001, 0.1, 0.5, 0.9, 0.999, 0.37\\}$。\n- 案例B：$\\lambda = 5.0$, $U = \\{0.001, 0.1, 0.5, 0.9, 0.999, 0.37\\}$。\n- 案例C：$\\lambda = 30.0$, $U = \\{0.001, 0.1, 0.5, 0.9, 0.999, 0.37\\}$。\n- 案例D：$\\lambda = 0.000001$, $U = \\{0.001, 0.1, 0.5, 0.9, 0.999, 0.37\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。具体来说，输出应为一个包含四个元素（每个测试用例一个）的顶级列表。每个元素都是以下形式的子列表\n$$\n[\\,[K_1,K_2,K_3,K_4,K_5,K_6],\\; T,\\; \\eta,\\; I\\,],\n$$\n其中 $\\eta$ 四舍五入到六位小数。例如，打印出的结构应如下所示\n$$\n[[[\\dots],T,\\eta,I],[[\\dots],T,\\eta,I],[[\\dots],T,\\eta,I],[[\\dots],T,\\eta,I]].\n$$",
            "solution": "该问题是有效的。这是一个在随机模拟领域中定义明确、具有科学依据的问题。它要求基于给定的递推关系，使用标准的逆变换法设计并实现一个用于生成泊松变量的向量化算法。所有定义、约束和测试用例都已提供，构成了一个完整而客观的规范。\n\n### 从第一性原理推导算法\n\n从指定分布生成随机变量是蒙特卡洛方法中的一项基本任务。该问题要求以向量化、类似SIMD的方式实现泊松分布的逆变换法。\n\n**1. 离散分布的逆变换法**\n\n其核心原理是逆变换法（也称为逆变换采样）。对于一个具有累积分布函数（CDF）$F(k) = \\mathbb{P}(K \\le k)$的离散随机变量 $K$，我们可以通过从 $(0,1)$ 上的均匀分布中抽取一个随机数 $U$（记为 $U \\sim \\mathrm{Uniform}(0,1)$），并找到满足 $F(k) \\ge U$ 的最小整数 $k$ 来生成一个变量。\n\n**2. 在泊松分布上的应用**\n\n率参数为 $\\lambda  0$ 的泊松分布具有如下的概率质量函数（PMF）：\n$$\np(k) = \\mathbb{P}(K=k) = e^{-\\lambda} \\frac{\\lambda^k}{k!} \\quad \\text{for } k \\in \\{0, 1, 2, \\dots\\}\n$$\nCDF是这些概率的总和：\n$$\nF(k) = \\sum_{j=0}^{k} p(j) = \\sum_{j=0}^{k} e^{-\\lambda} \\frac{\\lambda^j}{j!}\n$$\n逆变换法要求我们找到满足 $\\sum_{j=0}^{k} p(j) \\ge U$ 的最小整数 $k$。\n\n**3. 迭代标量算法**\n\n由于阶乘和幂次项的存在，为每个 $k$ 直接计算 $F(k)$ 在计算上是昂贵的。一种更高效的方法是迭代地构建这个和。问题为此提供了PMF项的以下递推关系：\n$$\np(k+1) = p(k) \\frac{\\lambda}{k+1}\n$$\n该关系通过观察比率 $p(k+1)/p(k)$ 推导得出。有了基准情况 $p(0) = e^{-\\lambda}$，我们可以顺序生成所有的 $p(k)$。这导出了一个简单的标量算法：\n\n1.  初始化 $k=0$，概率项 $p = e^{-\\lambda}$，以及累积和 $S = p$。\n2.  抽取 $U \\sim \\mathrm{Uniform}(0,1)$。\n3.  当 $S  U$ 时循环：\n    a. 增加 $k \\leftarrow k+1$。\n    b. 更新概率项：$p \\leftarrow p \\cdot \\frac{\\lambda}{k}$。\n    c. 更新累积和：$S \\leftarrow S + p$。\n4.  结果是 $k$ 的最终值。\n\n**4. 向量化（SIMD）算法设计**\n\n任务是为 $L$ 个独立的通道并行执行此生成过程，每个通道都有其自己的均匀随机数 $U_\\ell$。一种朴素的方法是运行标量算法 $L$ 次。然而，要求是实现一个向量化算法，它在单个循环中处理所有通道，以模拟单指令多数据流（SIMD）执行。\n\n这可以通过将每个通道的状态表示为一个向量（数组）并使用掩码来控制每一步更新哪些通道来实现。关键的洞见是循环计数器 $k$ 对所有通道是共用的。一旦通道的终止条件满足，它们就会变为“非活动”状态。\n\n**状态变量（作为大小为 $L$ 的向量）：**\n- $U$: 输入的每个通道的均匀随机数向量。\n- $K$: 用于存储生成的泊松变量的向量。初始化为一个哨兵值（例如 -1）。\n- $p$: 每个通道当前的PMF项 $p(k)$ 的向量。\n- $S$: 每个通道当前的CDF值 $S(k) = \\sum_{j=0}^k p(j)$ 的向量。\n- `active_mask`: 一个布尔向量，指示哪些通道仍在寻找它们的 $k$（即，哪些通道满足 $S_\\ell  U_\\ell$）。\n\n**向量化算法步骤：**\n\n1.  **初始化 ($k=0$):**\n    a. 设置循环计数器 $k=0$。\n    b. 用哨兵值初始化结果向量 $K$。\n    c. 将所有 $L$ 个通道的活动掩码 `active_mask` 初始化为 `True`。\n    d. 计算初始概率 $p_0 = e^{-\\lambda}$。\n    e. 用 $p_0$ 初始化所有通道的概率向量 $p$。\n    f. 用 $p_0$ 初始化所有通道的累积和向量 $S$（因为 $S(0) = p(0)$）。\n\n2.  **初始终止检查 (在 $k=0$ 时):**\n    a. 将初始累积和向量 $S$ 与均匀随机数向量 $U$进行比较。\n    b. 识别出 $S_\\ell \\ge U_\\ell$ 的通道。对于这些通道，结果为 $K_\\ell = 0$。\n    c. 为这些新终止的通道更新结果向量 $K$。\n    d. 将这些通道的 `active_mask` 更新为 `False`。\n\n3.  **主迭代循环 (对于 $k \\ge 1$):**\n    只要仍有任何通道处于活动状态（`any(active_mask)` 为 `True`），循环就继续。\n    a. 增加全局计数器：$k \\leftarrow k+1$。\n    b. **掩码递推更新：** 仅为活动通道使用递推关系更新概率向量 $p$：\n       $$ p_\\ell \\leftarrow p_\\ell \\cdot \\frac{\\lambda}{k} \\quad \\text{对于所有 } \\ell \\text{ 其中 } \\texttt{active\\_mask}_\\ell \\text{ 为 True} $$\n    c. **掩码累积和更新：** 再次仅为活动通道将新的概率项加到累积和中：\n       $$ S_\\ell \\leftarrow S_\\ell + p_\\ell \\quad \\text{对于所有 } \\ell \\text{ 其中 } \\texttt{active\\_mask}_\\ell \\text{ 为 True} $$\n    d. **掩码终止检查：** 识别当前活动通道中哪些现在已满足其终止条件（$S_\\ell \\ge U_\\ell$）。\n    e. 对于任何新终止的通道，在 $K$ 向量的相应元素中存储结果 $k$。\n    f. 将这些通道的 `active_mask` 设置为 `False`。\n\n4.  **终止与指标计算：**\n    a. 当 `active_mask` 全部为 `False` 时，循环终止。此时向量 $K$ 包含所有通道生成的泊松变量。\n    b. 处理的总迭代次数 $T$ 为 $K$ 中找到的最大值加 $1$，以计入初始的 $k=0$ 步骤：$T = 1 + \\max_{\\ell} K_\\ell$。\n    c. 活动通道步数的总和是每个通道运行的迭代次数之和。结果为 $K_\\ell$ 的通道活动了 $k=0, 1, \\dots, K_\\ell$ 共 $K_\\ell+1$ 步。总和为 $\\sum_{\\ell=1}^{L} (K_\\ell + 1)$。\n    d. 可能的总计算槽位是 $T \\cdot L$。\n    e. 负载均衡效率 $\\eta$ 是活动步数与总槽位的比率：$\\eta = \\frac{\\sum_{\\ell=1}^{L} (K_\\ell + 1)}{T \\cdot L}$。\n    f. 空闲通道步数的总数 $I$ 是差值：$I = (T \\cdot L) - \\sum_{\\ell=1}^{L} (K_\\ell + 1)$。\n\n这个向量化设计严格遵守了问题的要求，使用由布尔掩码控制的数组范围操作来模拟SIMD处理，并正确处理异步的通道完成情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the formatted results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.1, [0.001, 0.1, 0.5, 0.9, 0.999, 0.37]),\n        (5.0, [0.001, 0.1, 0.5, 0.9, 0.999, 0.37]),\n        (30.0, [0.001, 0.1, 0.5, 0.9, 0.999, 0.37]),\n        (0.000001, [0.001, 0.1, 0.5, 0.9, 0.999, 0.37])\n    ]\n\n    results = []\n    for lambda_val, u_list in test_cases:\n        result = _generate_poisson_vectorized(lambda_val, u_list)\n        results.append(result)\n\n    # Format the final output as a string representation of a list of lists.\n    # This avoids any potential formatting issues with numpy types in the default print.\n    def format_case(case):\n        k_list, T, eta, I = case\n        eta_str = f\"{eta:.6f}\"\n        return f\"[{k_list}, {T}, {eta_str}, {I}]\"\n\n    output_str = f\"[{','.join(format_case(res) for res in results)}]\"\n    print(output_str)\n\ndef _generate_poisson_vectorized(lambda_val, u_list):\n    \"\"\"\n    Implements the vectorized inversion algorithm for Poisson variate generation.\n    \n    Args:\n        lambda_val (float): The rate parameter lambda of the Poisson distribution.\n        u_list (list[float]): A list of uniform random numbers for each lane.\n\n    Returns:\n        A list containing:\n        - A list of integer Poisson variates [K_1, ..., K_L].\n        - An integer T, the total number of iterations.\n        - A float eta, the load-balancing efficiency, rounded to 6 decimal places.\n        - An integer I, the total idle lane-steps.\n    \"\"\"\n    L = len(u_list)\n    U_lanes = np.array(u_list, dtype=np.float64)\n\n    # State vectors\n    # Using np.int64 to avoid potential overflow on `K_lanes + 1` for large K.\n    K_lanes = np.full(L, -1, dtype=np.int64)\n    active_mask = np.full(L, True, dtype=bool)\n    \n    # Algorithm initialization at k=0\n    k = 0\n    p0 = np.exp(-lambda_val)\n    p_lanes = np.full(L, p0, dtype=np.float64)\n    S_lanes = p_lanes.copy() # Cumulative sum starts with p(0)\n\n    # Initial termination check for k=0\n    # All lanes are active, so no need to use active_mask yet.\n    terminated_at_zero = S_lanes >= U_lanes\n    if np.any(terminated_at_zero):\n        K_lanes[terminated_at_zero] = k\n        active_mask[terminated_at_zero] = False\n\n    # Main vectorized loop\n    while np.any(active_mask):\n        k += 1\n        \n        # Update probability p(k) and cumulative sum S(k) for active lanes only\n        p_lanes[active_mask] = p_lanes[active_mask] * (lambda_val / k)\n        S_lanes[active_mask] += p_lanes[active_mask]\n        \n        # Identify newly terminated lanes from the active set\n        condition_met_mask = S_lanes >= U_lanes\n        newly_terminated_mask = active_mask  condition_met_mask\n        \n        if np.any(newly_terminated_mask):\n            K_lanes[newly_terminated_mask] = k\n            active_mask[newly_terminated_mask] = False\n\n    # All lanes have terminated. Calculate final metrics.\n    # Total iterations T\n    # If all K_lanes are 0, max is 0. If no variates were generated (error), this would fail.\n    # The algorithm guarantees K_lanes is filled, so np.max is safe.\n    max_K = np.max(K_lanes)\n    T = 1 + max_K\n\n    # Sum of active iterations per lane\n    sum_of_active_iterations = np.sum(K_lanes + 1)\n    \n    # Total possible compute slots\n    total_compute_slots = T * L\n    \n    # Efficiency (eta) and Idle Steps (I)\n    eta = sum_of_active_iterations / total_compute_slots\n    I = total_compute_slots - sum_of_active_iterations\n    \n    # Format results for output\n    k_output_list = K_lanes.tolist()\n    eta_rounded = round(eta, 6)\n    \n    return [k_output_list, int(T), eta_rounded, int(I)]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}