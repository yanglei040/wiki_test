{
    "hands_on_practices": [
        {
            "introduction": "第一个练习旨在为你奠定谱检验的坚实理论基础。你将从线性同余生成器 (LCG) 的基本递推关系出发，推导出对偶格的定义条件——这是谱检验的核心研究对象。随后，通过对一个小型实例进行具体计算，你将在抽象定义与具体数值结果之间建立联系，从而牢固掌握谱检验的核心机制 。",
            "id": "3318079",
            "problem": "线性同余生成器（LCG）由递推关系 $X_{n+1} \\equiv a X_n + c \\pmod{m}$ 定义，其中整数 $m \\geq 2$，$0 \\leq a  m$，$0 \\leq c  m$，其归一化输出为 $U_n = X_n/m \\in [0,1)$。在随机模拟和蒙特卡洛方法的背景下，谱检验用于评估由t维输出元组集合 $S_t = \\{(U_n, U_{n+1}, \\dots, U_{n+t-1}) : n \\in \\mathbb{Z}\\}$ 形成的格结构。\n\n仅使用LCG的基本定义以及模算术和线性形式的标准性质，完成以下任务：\n\n1. 严格定义LCG在维度t下的谱检验，包括 $S_t$ 的对偶格的概念，以及基于欧几里得范数下最短非零对偶向量的品质因数。\n2. 从递推关系 $X_{n+1} \\equiv a X_n + c \\pmod{m}$ 和归一化输出 $U_n = X_n/m$ 出发，推导与t元组集合 $(U_n,\\dots,U_{n+t-1})$ 相关联的对偶格，并将其明确表示为 $\\mathbb{Z}^t$ 的一个子集，用 $a$ 和 $m$ 来表达。\n3. 对于参数为 $(m,a,c) = (31,3,0)$ 且维度为 $t=2$ 的特定LCG，计算你推导出的对偶格中最短非零向量的欧几里得范数。提供精确的最终数值（不进行四舍五入），并将其表示为单个实数或单个封闭形式的解析表达式。",
            "solution": "所述问题是有效的。它在科学上基于已建立的伪随机数生成理论，特别是通过谱检验对线性同余生成器（LCG）的分析。该问题提法明确，提供了所有必要的参数和定义，从而能够得出一个唯一且可验证的解。它是客观的，不包含任何形而上学或主观的主张。各项任务逻辑顺序清晰，与随机模拟和蒙特卡洛方法的主题直接相关。\n\n我们将首先定义谱检验，然后推导LCG对偶格的一般形式，最后计算给定特定参数下所需的范数。\n\n### 第1部分：谱检验的定义\n\n线性同余生成器由递推关系 $X_{n+1} \\equiv a X_n + c \\pmod{m}$ 定义，由此获得归一化输出 $U_n = X_n / m$。谱检验通过检查连续输出的t维向量集合 $S_t = \\{(U_n, U_{n+1}, \\dots, U_{n+t-1}) : n \\in \\mathbb{Z}\\}$ 的几何结构来评估LCG的质量。\n\n$S_t$ 中的点并不均匀地填充t维单位超立方体 $[0,1)^t$，而是被限制在有限数量的平行超平面上。这种离散结构是一种称为格的数学对象的体现。满足LCG递推同余式的整向量 $\\mathbf{z} = (z_1, \\dots, z_t)$ 的完整集合构成一个格 $L_t$。LCG的点 $(X_n, \\dots, X_{n+t-1})$ 构成这个格的一个子集（如果 $c \\neq 0$，则是它的一个平移版本）。\n\n谱检验是通过分析**对偶格**（记为 $L_t^*$）来定义的。对偶格 $L_t^*$ 是所有整向量 $\\mathbf{v} = (v_1, \\dots, v_t) \\in \\mathbb{Z}^t$ 的集合，对于 $S_t$ 中的每个向量 $\\mathbf{u}$，其点积 $\\mathbf{v} \\cdot \\mathbf{u}$ 都是一个整数：\n$$L_t^* = \\{\\mathbf{v} \\in \\mathbb{Z}^t \\mid \\forall \\mathbf{u} \\in S_t, \\mathbf{v} \\cdot \\mathbf{u} \\in \\mathbb{Z}\\}$$\n在几何上，一个非零向量 $\\mathbf{v} \\in L_t^*$ 与一族由 $\\mathbf{v} \\cdot \\mathbf{x} = k$（其中k为整数）给出的平行超平面正交，生成器的所有输出点都位于这些超平面上。这族超平面中相邻超平面之间的距离是 $1/||\\mathbf{v}||_2$，其中 $||\\cdot||_2$ 表示欧几里得范数。\n\n要使一个生成器被认为是“好的”，其输出点应尽可能均匀分布，这意味着格结构应该是“细”的而不是“粗”的。这意味着包含所有点的任何平行超平面族之间的最小距离应尽可能大。这等价于在对偶格中找到最短的非零向量。\n\n因此，维度t下谱检验的**品质因数**（记为 $\\nu_t$）是对偶格 $L_t^*$ 中最短非零向量的欧几里得范数：\n$$\\nu_t = \\min \\{ ||\\mathbf{v}||_2 \\mid \\mathbf{v} \\in L_t^*, \\mathbf{v} \\neq \\mathbf{0} \\}$$\n$\\nu_t$ 的值越大，表示LCG在维度t下的格结构越好（越细）。\n\n### 第2部分：对偶格的推导\n\n为了推导对偶格的显式形式，我们从其定义开始。一个向量 $\\mathbf{v} = (v_1, \\dots, v_t) \\in \\mathbb{Z}^t$ 属于 $L_t^*$ 当且仅当对于所有生成的向量 $\\mathbf{U}_n = (U_n, \\dots, U_{n+t-1})$，都有 $\\mathbf{v} \\cdot \\mathbf{U}_n \\in \\mathbb{Z}$。使用归一化 $U_k = X_k/m$，该条件等价于：\n$$\\frac{1}{m} \\sum_{j=1}^{t} v_j X_{n+j-1} \\in \\mathbb{Z}$$\n这又等价于以下同余式：\n$$\\sum_{j=1}^{t} v_j X_{n+j-1} \\equiv 0 \\pmod{m}$$\n该同余式必须对LCG产生的所有整数序列 $(X_n, X_{n+1}, \\dots)$ 成立。\n\n对偶格的结构与生成器格的基本间距有关，后者由递推关系的乘法部分决定。加法常数c仅仅引起整个点格的刚性平移，这不影响对偶格。因此，我们可以通过考虑齐次情况（即c=0）来分析对偶格，即 $X_{n+1} \\equiv a X_n \\pmod{m}$。该递推关系意味着对于任何 $k \\geq 0$ 都有 $X_{n+k} \\equiv a^k X_n \\pmod{m}$。\n\n将此代入我们对对偶格向量的同余条件中：\n$$\\sum_{j=1}^{t} v_j (a^{j-1} X_n) \\equiv 0 \\pmod{m}$$\n$$X_n \\left( \\sum_{j=1}^{t} v_j a^{j-1} \\right) \\equiv 0 \\pmod{m}$$\n对于一个非平凡的生成器（即不产生恒为零的序列），状态 $X_n$ 将取模m下的各种非零值。为了使上述同余式对所有可能的 $X_n$ 值都成立，$X_n$ 的系数必须是m的倍数。因此，我们得到了对偶格的定义条件：\n$$\\sum_{j=1}^{t} v_j a^{j-1} \\equiv 0 \\pmod{m}$$\n因此，对偶格 $L_t^*$ 是满足此线性同余式的所有整向量 $\\mathbf{v} = (v_1, \\dots, v_t)$ 的集合：\n$$L_t^* = \\left\\{ \\mathbf{v} \\in \\mathbb{Z}^t \\mid v_1 + a v_2 + a^2 v_3 + \\dots + a^{t-1} v_t \\equiv 0 \\pmod m \\right\\}$$\n这就是用 $a$ 和 $m$ 表示的对偶格的显式表达式。\n\n### 第3部分：对 $(m,a,c)=(31,3,0)$ 且 $t=2$ 的情况进行计算\n\n我们给定的参数是 $m=31$，$a=3$，$t=2$。我们要求解对偶格 $L_2^*$ 中最短非零向量的欧几里得范数。使用第2部分推导出的 $t=2$ 时的条件：\n$$L_2^* = \\left\\{ (v_1, v_2) \\in \\mathbb{Z}^2 \\mid v_1 + a v_2 \\equiv 0 \\pmod m \\right\\}$$\n代入给定值：\n$$v_1 + 3v_2 \\equiv 0 \\pmod{31}$$\n该同余式意味着 $v_1$ 可以用 $v_2$ 和一个整数k来表示：\n$$v_1 = -3v_2 + 31k, \\quad \\text{for } v_2, k \\in \\mathbb{Z}$$\n对偶格中的向量形式为 $\\mathbf{v} = (-3v_2 + 31k, v_2)$。我们想找到这类向量的最小欧几里得范数，其约束条件为 $\\mathbf{v} \\neq \\mathbf{0}$，这等价于 $(v_2, k) \\neq (0,0)$。\n\n欧几里得范数的平方是：\n$$||\\mathbf{v}||_2^2 = v_1^2 + v_2^2 = (-3v_2 + 31k)^2 + v_2^2$$\n我们现在寻找整数 $v_2$ 和 $k$ 来最小化这个正定二次型。我们通过考虑k的较小整数值来分析该表达式。\n\n情况1：$k=0$。\n范数的平方变为 $||\\mathbf{v}||_2^2 = (-3v_2)^2 + v_2^2 = 9v_2^2 + v_2^2 = 10v_2^2$。\n为了找到最短的非零向量，我们取 $v_2$ 的最小非零整数绝对值，即 $|v_2|=1$。我们选择 $v_2=1$。这得到 $v_1 = -3(1) + 31(0) = -3$。向量是 $(-3, 1)$。\n范数的平方是 $||\\mathbf{v}||_2^2 = 10(1)^2 = 10$。\n\n情况2：$k=1$。\n范数的平方是 $||\\mathbf{v}||_2^2 = (-3v_2 + 31)^2 + v_2^2 = 10v_2^2 - 186v_2 + 961$。\n这是一个关于 $v_2$ 的开口向上的抛物线。其最小值出现在 $v_2 = -(-186)/(2 \\cdot 10) = 9.3$。我们必须检查邻近的整数值，$v_2=9$ 和 $v_2=10$。\n如果 $v_2=9$：$v_1 = -3(9) + 31(1) = -27 + 31 = 4$。向量是 $(4, 9)$。\n$||\\mathbf{v}||_2^2 = 4^2 + 9^2 = 16 + 81 = 97$。\n如果 $v_2=10$：$v_1 = -3(10) + 31(1) = -30 + 31 = 1$。向量是 $(1, 10)$。\n$||\\mathbf{v}||_2^2 = 1^2 + 10^2 = 1 + 100 = 101$。\n对于 $k=1$ 的情况，最小值是 $97$，大于 $10$。\n\n情况3：$k=-1$。\n范数的平方是 $||\\mathbf{v}||_2^2 = (-3v_2 - 31)^2 + v_2^2 = 10v_2^2 + 186v_2 + 961$。\n最小值出现在 $v_2 = -186/20 = -9.3$。我们检查整数 $v_2=-9$ 和 $v_2=-10$。\n如果 $v_2=-9$：$v_1 = -3(-9) + 31(-1) = 27 - 31 = -4$。向量是 $(-4, -9)$。\n$||\\mathbf{v}||_2^2 = (-4)^2 + (-9)^2 = 16 + 81 = 97$。\n这个值也大于 $10$。\n\n对于 $|k| \\geq 2$，仅 $(31k)^2$ 项就至少是 $(31 \\times 2)^2 = 62^2 = 3844$，远大于 $10$。二次型 $10v_2^2 - 186kv_2 + 961k^2$ 的最小值有一个大约为 $96.1k^2$ 的下界，它随着k迅速增长。很明显，更大绝对值的k不会产生更小的范数。\n\n通过比较结果，最小范数平方是 $10$，由向量 $(\\mp 3, \\pm 1)$ 取得。对偶格中最短非零向量的欧几里得范数是这个值的平方根。\n$$\\nu_2 = \\min \\{ ||\\mathbf{v}||_2 \\mid \\mathbf{v} \\in L_2^*, \\mathbf{v} \\neq \\mathbf{0} \\} = \\sqrt{10}$$\n最终答案要求为精确数值。",
            "answer": "$$\\boxed{\\sqrt{10}}$$"
        },
        {
            "introduction": "在建立了理论框架之后，本练习将深入探讨一个关键问题：从谱的角度来看，是什么决定了一个生成器的“好”与“坏”。通过分析两个具有经策略性选择的乘数——一个算术上简单，另一个复杂——的 LCG，你将对乘数的代数性质如何直接决定输出点阵的几何质量形成深刻的直觉。此练习突出了为高质量伪随机数生成选择稳健乘数背后的设计原则 。",
            "id": "3345806",
            "problem": "设 $m$ 是一个大素数，考虑由 $u_{n+1} \\equiv a\\,u_n \\pmod m$ 和 $x_n = u_n/m$ 定义的乘法线性同余生成器（LCG, linear congruential generator）。对每个 $s \\ge 2$，谱检验（spectral test）考察 $s$ 维点集 $\\{(x_n, x_{n+1}, \\dots, x_{n+s-1})\\}$，并为其在 $\\mathbb{R}^s$ 中关联一个格 $L_s$（及其对偶格 $L_s^\\ast$）。谱品质因数（spectral figure of merit）$\\nu_s$ 通过包含所有点的平行超平面之间的最小间距来定义，这等价于通过对偶格 $L_s^\\ast$ 中最短非零向量的长度来定义。一个标准结论是，连续状态之间的整线性关系对应于 $L_s^\\ast$ 中的短向量。\n\n两个 LCG 共享相同的模 $m$，但具有不同的乘数 $a$：\n- 生成器 $\\mathcal{G}_{\\mathrm{sq}}$ 使用乘数 $a_{\\mathrm{sq}} \\equiv r^2 \\pmod m$，其中 $r = \\lfloor \\sqrt{m} \\rfloor$，因此 $a_{\\mathrm{sq}} \\equiv -\\delta \\pmod m$，其中 $\\delta = m - r^2$ 且 $1 \\le \\delta \\ll m^{1/2}$。\n- 生成器 $\\mathcal{G}_{\\mathrm{pr}}$ 使用乘数 $a_{\\mathrm{pr}}$，它是模 $m$ 的一个本原根（因此 $a_{\\mathrm{pr}} \\pmod m$ 的乘法阶为 $m-1$），并且其最小绝对剩余满足 $\\min\\{|a_{\\mathrm{pr}}|, |m-a_{\\mathrm{pr}}|\\} \\ge m/3$。\n\n假设两种情况下 $c=0$，且 $\\mathcal{G}_{\\mathrm{pr}}$ 具有满周期。满足同余式 $h_0 + h_1 a + \\cdots + h_{s-1} a^{s-1} \\equiv 0 \\pmod m$ 的整数 $h_0, \\dots, h_{s-1}$ 对应于 $L_s^\\ast$ 中的非零对偶向量，而最小的此类向量的欧几里得范数决定了超平面间距，即 $\\nu_s$。\n\n选择所有比较 $\\mathcal{G}_{\\mathrm{sq}}$ 和 $\\mathcal{G}_{\\mathrm{pr}}$ 的 $\\nu_s$ 的正确陈述，并使用 $a \\pmod m$ 的乘法阶以及自然对偶基的形状（例如，与 $a$ 的幂对齐的下三角基）来解释其差异：\n\nA. 在维度 $s=2$ 时，$\\mathcal{G}_{\\mathrm{sq}}$ 的 $\\nu_2$ 比 $\\mathcal{G}_{\\mathrm{pr}}$ 小得多，因为 $a_{\\mathrm{sq}} \\equiv -\\delta \\pmod m$ 产生了一个具有非常小系数的精确 1 次关系 $h_0 + h_1 a \\equiv 0 \\pmod m$，从而在 $L_2^\\ast$ 中产生一个非常短的向量，而对于 $a_{\\mathrm{pr}}$，最小绝对剩余很大，相应的最短 1 次对偶向量要长得多。\n\nB. 对于任何固定的 $s \\ge 3$，$\\mathcal{G}_{\\mathrm{sq}}$ 在 $L_s^\\ast$ 中保留了一个来自相同 1 次关系（通过零填充）的非常短的向量，因此 $\\nu_s$ 保持很小；相比之下，本原根的情况不存在系数很小的 1 次关系，并且数几何（geometry of numbers）的启发式方法表明，$L_s^\\ast$ 中最短向量的阶为 $m^{1/s}$，这给出了一个明显更大的 $\\nu_s$。\n\nC. $a \\pmod m$ 的乘法阶本身完全确定了每个 $s$ 的 $\\nu_s$，因此一个本原根及其平方必然具有相同的 $\\nu_2$。\n\nD. 如果 $a$ 是一个本原根，则不存在次数小于 $m-1$ 且具有整数系数的精确多项式同余式 $H(a) \\equiv 0 \\pmod m$，因此对于所有 $s  m-1$，$v_s$ 实际上是无界的（无限的）。\n\nE. 如果 $a$ 是模 $m$ 的一个平方数，则必须存在一个系数为单位的 2 次关系，例如 $a^2 \\pm a \\pm 1 \\equiv 0 \\pmod m$，这将强制 $\\nu_3 \\le \\sqrt{3}$ 对 $m$ 一致成立。\n\n选择所有适用的选项。",
            "solution": "问题要求基于谱检验中的表现，对两个线性同余生成器（LCG）$\\mathcal{G}_{\\mathrm{sq}}$ 和 $\\mathcal{G}_{\\mathrm{pr}}$ 进行分析和比较。其表现由品质因数 $\\nu_s$ 量化，定义为对偶格 $L_s^\\ast$ 中最短的非零向量的长度。较大的 $\\nu_s$ 值表示生成器质量好，因为它对应于一个精细的格结构，其中连续的伪随机数没有强相关性。\n\n对偶格 $L_s^\\ast$ 是所有满足以下同余式的整数向量 $\\mathbf{h} = (h_0, h_1, \\dots, h_{s-1}) \\in \\mathbb{Z}^s$ 的集合：\n$$ \\sum_{i=0}^{s-1} h_i a^i \\equiv 0 \\pmod m $$\n于是品质因数为 $\\nu_s = \\min \\{ ||\\mathbf{h}||_2 \\,:\\, \\mathbf{h} \\in L_s^\\ast, \\mathbf{h} \\neq \\mathbf{0} \\}$。较小的 $\\nu_s$ 是找到了一个分量很小且满足同余式的非零整数向量 $\\mathbf{h}$ 的结果。这表明生成器的连续值之间存在一个简单的、低次的多项式关系，这是伪随机性差的一个标志。\n\n让我们依次分析这两个生成器。\n\n**生成器 $\\mathcal{G}_{\\mathrm{sq}}$：**\n乘数为 $a_{\\mathrm{sq}}$。我们已知 $a_{\\mathrm{sq}} \\equiv -\\delta \\pmod m$，其中 $\\delta = m - \\lfloor \\sqrt{m} \\rfloor^2$ 是一个满足 $1 \\le \\delta \\ll m^{1/2}$ 的小正整数。这个同余式可以重写为 $1 \\cdot a_{\\mathrm{sq}} + \\delta \\cdot 1 \\equiv 0 \\pmod m$。\n\n这是维度 $s=2$ 的对偶格同余式的一个具体实例，即 $h_1 a_{\\mathrm{sq}} + h_0 \\equiv 0 \\pmod m$。我们找到了一个非零整数解向量 $\\mathbf{h} = (h_0, h_1) = (\\delta, 1)$。这个向量的欧几里得范数是：\n$$ ||(\\delta, 1)||_2 = \\sqrt{\\delta^2 + 1^2} = \\sqrt{\\delta^2 + 1} $$\n因为这个向量在 $L_2^\\ast$ 中，所以最短非零向量的长度 $\\nu_2$ 必须小于或等于这个值：\n$$ \\nu_2(\\mathcal{G}_{\\mathrm{sq}}) \\le \\sqrt{\\delta^2 + 1} $$\n鉴于 $\\delta$ 是一个小整数（例如，阶为 $1$ 到 $m^{1/4}$），与 $m$ 的尺度相比，$\\sqrt{\\delta^2+1}$ 是一个非常小的数。例如，如果 $\\delta=1$，则 $\\nu_2(\\mathcal{G}_{\\mathrm{sq}}) \\le \\sqrt{2}$。这表明在 2 维空间中格结构非常差。\n\n**生成器 $\\mathcal{G}_{\\mathrm{pr}}$：**\n乘数 $a_{\\mathrm{pr}}$ 是模 $m$ 的一个本原根，意味着其乘法阶为 $m-1$，确保了最大周期长度。此外，它的选择使得其最小绝对剩余很大，$\\min\\{|a_{\\mathrm{pr}}|, |m-a_{\\mathrm{pr}}|\\} \\ge m/3$。这些是“好”的 LCG 乘数的特征。一个好的乘数不应满足任何简单的线性同余式。对于 $s=2$，关系式 $h_0 + h_1 a_{\\mathrm{pr}} \\equiv 0 \\pmod m$（其中 $h_0, h_1$ 是小整数）将意味着 $a_{\\mathrm{pr}}/m$ 可以被有理数 $-h_0/(h_1 m)$ 很好地近似，这是好的 LCG 设计者试图避免的属性。对于像 $a_{\\mathrm{pr}}$ 这样精心选择的乘数，人们不期望找到满足同余式的小整数系数。$L_2^\\ast(\\mathcal{G}_{\\mathrm{pr}})$ 中最短向量的长度预计在 $m^{1/2}$ 的量级，对于大的 $m$ 来说这是一个很大的值。\n\n现在我们评估每个选项。\n\n**A. 在维度 $s=2$ 时，$\\mathcal{G}_{\\mathrm{sq}}$ 的 $\\nu_2$ 比 $\\mathcal{G}_{\\mathrm{pr}}$ 小得多，因为 $a_{\\mathrm{sq}} \\equiv -\\delta \\pmod m$ 产生了一个具有非常小系数的精确 1 次关系 $h_0 + h_1 a \\equiv 0 \\pmod m$，从而在 $L_2^\\ast$ 中产生一个非常短的向量，而对于 $a_{\\mathrm{pr}}$，最小绝对剩余很大，相应的最短 1 次对偶向量要长得多。**\n这个陈述是我们分析的正确总结。关系式 $a_{\\mathrm{sq}} + \\delta \\equiv 0 \\pmod m$ 对应于 $L_2^\\ast$ 中的向量 $(\\delta, 1)$，其范数为 $\\sqrt{\\delta^2+1}$。因为 $\\delta$ 很小，所以这个范数很小，因此 $\\nu_2(\\mathcal{G}_{\\mathrm{sq}})$ 很小。对于 $\\mathcal{G}_{\\mathrm{pr}}$，其乘数在算术意义上被选择为“复杂”的，因此不存在这样具有小系数的简单关系。$L_2^\\ast(\\mathcal{G}_{\\mathrm{pr}})$ 中最短的向量要长得多，其长度通常在 $m^{1/2}$ 的量级。因此，$\\nu_2(\\mathcal{G}_{\\mathrm{sq}}) \\ll \\nu_2(\\mathcal{G}_{\\mathrm{pr}})$。\n**结论：正确。**\n\n**B. 对于任何固定的 $s \\ge 3$，$\\mathcal{G}_{\\mathrm{sq}}$ 在 $L_s^\\ast$ 中保留了一个来自相同 1 次关系（通过零填充）的非常短的向量，因此 $\\nu_s$ 保持很小；相比之下，本原根的情况不存在系数很小的 1 次关系，并且数几何（geometry of numbers）的启发式方法表明，$L_s^\\ast$ 中最短向量的阶为 $m^{1/s}$，这给出了一个明显更大的 $\\nu_s$。**\n对于 $\\mathcal{G}_{\\mathrm{sq}}$，关系式 $a_{\\mathrm{sq}} + \\delta \\equiv 0 \\pmod m$ 在更高维度中持续存在。对于任何 $s \\ge 2$，我们可以构造向量 $\\mathbf{h} = (\\delta, 1, 0, \\dots, 0) \\in \\mathbb{Z}^s$。这个向量满足 $\\sum_{i=0}^{s-1} h_i a_{\\mathrm{sq}}^i = \\delta \\cdot a_{\\mathrm{sq}}^0 + 1 \\cdot a_{\\mathrm{sq}}^1 + 0 + \\dots = \\delta + a_{\\mathrm{sq}} \\equiv 0 \\pmod m$。因此，对于任何 $s \\ge 2$，$\\mathbf{h}$ 是 $L_s^\\ast(\\mathcal{G}_{\\mathrm{sq}})$ 中的一个非零向量。其范数为 $||\\mathbf{h}||_2 = \\sqrt{\\delta^2 + 1^2 + 0^2 + \\dots} = \\sqrt{\\delta^2+1}$。这为 $\\nu_s$ 提供了一个上界：$\\nu_s(\\mathcal{G}_{\\mathrm{sq}}) \\le \\sqrt{\\delta^2+1}$。对所有维度，该品质因数都保持很小，并被一个小的常数所界定。\n对于 $\\mathcal{G}_{\\mathrm{pr}}$，作为一个好的生成器，期望其点在 $s$ 维空间中分布良好。来自整数格理论（与闵可夫斯基凸体定理相关）的启发式结果表明，对于一个“随机”或“好”的格，最短非零向量的长度大约为 $m^{1/s}$。对于任何固定的 $s$ 和大的 $m$，这个值明显大于小常数 $\\sqrt{\\delta^2+1}$。\n**结论：正确。**\n\n**C. $a \\pmod m$ 的乘法阶本身完全确定了每个 $s$ 的 $\\nu_s$，因此一个本原根及其平方必然具有相同的 $\\nu_2$。**\n这个陈述是错误的。$\\nu_s$ 的值取决于乘数 $a$ 本身，而不仅仅是其乘法阶。我们可以构造一个反例。设 $m=31$。$a_1=3$ 和 $a_2=5$ 都是模 $31$ 的本原根（它们的阶都是 $30$）。\n对于 $a_1=3$，我们寻找最短的向量 $(h_0, h_1)$ 使得 $h_0+3h_1 \\equiv 0 \\pmod{31}$。我们可以选择 $(h_0, h_1) = (-3, 1)$，其长度为 $\\sqrt{10}$。通过检查其他小的值，可以发现这是最短的。所以 $\\nu_2(3) = \\sqrt{10}$。\n对于 $a_2=5$，我们寻找最短的向量 $(h_0, h_1)$ 使得 $h_0+5h_1 \\equiv 0 \\pmod{31}$。我们可以选择 $(-5, 1)$，其长度为 $\\sqrt{26}$。这是最短的。所以 $\\nu_2(5) = \\sqrt{26}$。\n因为 $\\nu_2(3) \\neq \\nu_2(5)$，但两个乘数具有相同的阶，所以前提是错误的。因此，本原根及其平方必须具有相同 $\\nu_2$ 的结论也是没有根据的，并且通常是错误的。\n**结论：不正确。**\n\n**D. 如果 $a$ 是一个本原根，则不存在次数小于 $m-1$ 且具有整数系数的精确多项式同余式 $H(a) \\equiv 0 \\pmod m$，因此对于所有 $s  m-1$，$v_s$ 实际上是无界的（无限的）。**\n这个陈述在两个方面是不正确的。\n首先，如果 $a$ 是素数 $m$ 模下的一个本原根，它在域 $\\mathbb{Z}_m$ 上的最小多项式是分圆多项式 $\\Phi_{m-1}(x)$，其次数为 $\\phi(m-1)$。由于对于任何素数 $m > 3$，$m-1$ 都是合数，所以 $\\phi(m-1)  m-2$。例如，对于 $m=13$，$a=2$ 是一个本原根。$m-1=12$。$\\phi(12) = 12(1-1/2)(1-1/3) = 4$。因此存在一个次数为 $4  12$ 的多项式，使得 $a=2$ 在模 $13$ 下满足该多项式。因此，前提是错误的。\n其次，对于 $s \\ge 1$，对偶格 $L_s^\\ast$ 永远不为空（除了零向量）。对于任何 $a$ 和 $m$，向量 $\\mathbf{h} = (m, 0, \\dots, 0)$ 都在 $L_s^\\ast$ 中，因为 $m \\cdot a^0 + 0 + \\dots = m \\equiv 0 \\pmod m$。这个向量的范数是 $m$。这表明对于所有 $s$，$\\nu_s \\le m$。因此，$\\nu_s$ 总是有限的。声称 $\\nu_s$ 是无界或无限的是错误的。\n**结论：不正确。**\n\n**E. 如果 $a$ 是模 $m$ 的一个平方数，则必须存在一个系数为单位的 2 次关系，例如 $a^2 \\pm a \\pm 1 \\equiv 0 \\pmod m$，这将强制 $\\nu_3 \\le \\sqrt{3}$ 对 $m$ 一致成立。**\n这个陈述的前提是错误的。没有定理表明，如果 $a$ 是模 $m$ 的二次剩余，它就必须满足 $a^2 \\pm a \\pm 1 \\equiv 0 \\pmod m$ 形式的同余式。让我们用 $m=23$ 和 $a=9 \\equiv 3^2 \\pmod{23}$ 来检验。\n$a^2+a+1 = 81+9+1 = 91 = 3 \\cdot 23 + 22 \\equiv 22 \\pmod{23}$。\n$a^2+a-1 = 81+9-1 = 89 = 3 \\cdot 23 + 20 \\equiv 20 \\pmod{23}$。\n$a^2-a+1 = 81-9+1 = 73 = 3 \\cdot 23 + 4 \\equiv 4 \\pmod{23}$。\n$a^2-a-1 = 81-9-1 = 71 = 3 \\cdot 23 + 2 \\equiv 2 \\pmod{23}$。\n这些关系都不成立。即使对于问题中特定的 $a_{\\mathrm{sq}}$，我们有 $a_{\\mathrm{sq}} \\equiv -\\delta \\pmod m$，所以关系式变为 $\\delta^2 \\mp \\delta \\pm 1 \\equiv 0 \\pmod m$。由于 $\\delta$ 很小，$\\delta^2 \\mp \\delta \\pm 1$ 是一个小整数，不可能是大素数 $m$ 的非零倍数。如果表达式为零，即 $\\delta^2 \\mp \\delta \\pm 1=0$。对于 $\\delta \\ge 1$，$\\delta^2 - \\delta + 1 > 0$；对于 $\\delta > (\\sqrt{5}-1)/2 \\approx 0.618$，$\\delta^2+\\delta-1 > 0$。由于 $\\delta \\ge 1$，这些都是非零的。其他情况也是非零的。所以前提是错误的。如果这样的关系确实存在，例如 $a^2-a+1 \\equiv 0 \\pmod m$，它将对应于 $L_3^\\ast$ 中的向量 $(1, -1, 1)$，其范数为 $\\sqrt{1^2+(-1)^2+1^2} = \\sqrt{3}$。这确实意味着 $\\nu_3 \\le \\sqrt{3}$。然而，由于前提没有根据，整个陈述是无效的。\n**结论：不正确。**\n\n总之，只有陈述 A 和 B 是正确的。",
            "answer": "$$\\boxed{AB}$$"
        },
        {
            "introduction": "最后的练习将视角从分析转向综合，要求你解决一个逆向设计问题。你不再是评估一个给定的生成器，而是要去寻找一对 LCG 参数 $(a, m)$，使其刻意地产生一个与预设超平面法向量集相匹配的不良点阵结构。这个创造性的练习将迫使你更深入地运用谱检验的核心同余式，并将其作为一个优化框架中的设计约束，从而提供一个强大而直观的视角来理解 LCG 的内在缺陷 。",
            "id": "3345804",
            "problem": "考虑一个由递推关系 $x_{n+1} \\equiv a x_n \\pmod{m}$ 定义的线性同余生成器 (LCG)，其整数乘数为 $a$，模数为 $m$，且没有加法增量。对于一个固定的维度 $t \\geq 2$，众所周知，在通过 $1/m$ 缩放后，$t$ 个连续输出组成的块会在 $\\mathbb{R}^t$ 空间中构成一个格上的点。谱测试通过检验对偶格来评估此类生成器的质量。对偶格是由整数向量组成的，这些向量定义了点所在的平行超平面族。在本问题中，你将仅使用核心定义和递推属性，以第一性原理为指导，构建并解决一个逆向设计问题。\n\n从递推定义和 $t$ 维点 $(x_n, x_{n+1}, \\ldots, x_{n+t-1})$ 的解释出发，推导一个整数法向量 $h = (h_0, h_1, \\ldots, h_{t-1}) \\in \\mathbb{Z}^t$ 对应于一个超平面族（该超平面族包含给定 $(a,m)$ 的所有此类 $t$ 元组）的充要条件。然后，基于此条件，提出以下逆向问题：\n\n给定一组 $r$ 个期望的超平面法向量 $h^{(1)}, \\ldots, h^{(r)} \\in \\mathbb{Z}^t$，以及整数边界 $2 \\leq a \\leq A_{\\max}$ 和 $2 \\leq m \\leq M_{\\max}$，选择 $(a,m)$，使得每个 $h^{(i)}$ 尽可能接近于成为与该 LCG 关联的对偶格中的一个短向量。将选择 $(a,m)$ 的可行性定义为所有 $h^{(i)}$ 都具有精确的对偶格成员资格，并以无量纲形式（无物理单位）定义一个近似误差，用于衡量每个 $h^{(i)}$ 与满足所推导同余条件的偏离程度。你的推导必须从递推关系 $x_{n+1} \\equiv a x_n \\pmod{m}$ 和 $t$ 维序列点的定义开始，进而得出一个完全用 $(a,m)$ 和 $h^{(i)}$ 的系数表示的条件，且不能借助于任何已有的谱测试公式。\n\n算法任务：\n- 对于每个满足 $2 \\leq a \\leq A_{\\max}$ 的整数 $a$，为每个 $h^{(i)}$ 计算你推导的条件所蕴含的量。在 $2 \\leq m \\leq M_{\\max}$ 的范围内搜索 $m$，以确定：\n  1. 是否存在非平凡的精确解（可行解），即所有 $h^{(i)}$ 都同时满足推导出的条件。\n  2. 如果不可行，找到使 $i=1,\\ldots,r$ 上的最大无量纲近似误差最小化的 $m$，若有多个解，则选择较大的 $m$。\n- 在所有 $a$ 中，如果存在任何可行对，则选择一个可行对；在所有可行对中，优先选择最大的 $m$（若 $m$ 相同，则选择最小的 $a$）。如果不存在可行对，则选择使最大近似误差最小化的对（然后优先选择较大的 $m$，再然后选择较小的 $a$）。\n\n对于每个测试用例，报告：\n- 选定的 $a$（整数）。\n- 选定的 $m$（整数）。\n- 一个可行性标志（布尔值）。\n- 所有 $h^{(i)}$ 中的最大近似误差（浮点数）。\n- 每个 $h^{(i)}$ 的单独近似误差（浮点数），按给定顺序排列。\n\n近似误差是一个纯数，必须以小数形式给出。\n\n测试套件：\n对于下面的每个测试用例，$t$ 是每个法向量的长度。使用提供的 $A_{\\max}$ 和 $M_{\\max}$。\n\n1. 单约束理想情况（保证在多个 $a$ 上存在可行解）：\n   - $t=5$, $r=1$,\n   - $h^{(1)} = (20,-9,1,0,0)$,\n   - $A_{\\max} = 50$, $M_{\\max} = 5000$.\n\n2. 约束冲突情况（不存在非平凡的精确可行解）：\n   - $t=5$, $r=2$,\n   - $h^{(1)} = (20,-9,1,0,0)$, $h^{(2)} = (1,0,0,0,0)$,\n   - $A_{\\max} = 50$, $M_{\\max} = 5000$.\n\n3. 具有非平凡公共结构的多约束情况：\n   - $t=5$, $r=3$,\n   - $h^{(1)} = (0,-1,0,1,0)$, $h^{(2)} = (0,-1,1,0,0)$, $h^{(3)} = (0,0,-1,0,1)$,\n   - $A_{\\max} = 30$, $M_{\\max} = 1000$.\n\n4. 模数最小的边界情况：\n   - $t=4$, $r=1$,\n   - $h^{(1)} = (1,1,1,1)$,\n   - $A_{\\max} = 3$, $M_{\\max} = 2$.\n\n最终输出格式：\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个用方括号括起来的逗号分隔列表。例如，整体形式必须像\n$[ [\\text{case1\\_elements}], [\\text{case2\\_elements}], \\ldots ]$，\n行内无空格。具体来说，每个内部列表必须是\n$[a,m,\\text{feasible},E_{\\max},E_1,\\ldots,E_r]$，其中 $E_{\\max}$ 和 $E_i$ 是小数。\n\n所有角度和物理单位在本问题中均无关；所有报告的量都是无单位的。每个元素只接受布尔、整数或浮点类型。你的程序必须是自包含的，并且在运行时能以所需格式产生确切的单行输出。",
            "solution": "### 第1部分：推导对偶格条件和误差度量\n\n根据问题要求，我们从第一性原理出发。\n1.  **对偶格条件**: 一个整数向量 $h = (h_0, \\ldots, h_{t-1})$ 是对偶格的成员，当且仅当对于所有由 LCG 生成的缩放点 $v_n = (x_n/m, \\ldots, x_{n+t-1}/m)$，其点积 $h \\cdot v_n$ 是一个整数。这等价于 $\\sum_{i=0}^{t-1} h_i x_{n+i} \\equiv 0 \\pmod{m}$。\n    利用递推关系 $x_{n+i} \\equiv a^i x_n \\pmod{m}$，我们得到 $x_n \\left(\\sum_{i=0}^{t-1} h_i a^i\\right) \\equiv 0 \\pmod{m}$。\n    为了使该条件对所有可能的种子 $x_n$ 都成立，括号内的项必须是 $m$ 的倍数。因此，充要条件是：\n    $$ S(h, a) = \\sum_{i=0}^{t-1} h_i a^i \\equiv 0 \\pmod{m} $$\n\n2.  **近似误差**: 当上述条件不满足时，我们需要一个无量纲的误差度量。这个误差衡量了 $S(h, a)$ 与 $m$ 的最近倍数之间的距离，并用 $m$ 进行归一化。令 $rem = S(h, a) \\pmod{m}$。到最近倍数的距离是 $\\min(rem, m - rem)$。因此，无量纲近似误差 $E$ 定义为：\n    $$ E(h, a, m) = \\frac{\\min(S(h, a) \\pmod{m}, m - (S(h, a) \\pmod{m}))}{m} $$\n    该误差值在 $[0, 0.5]$ 范围内。当且仅当 $(a,m)$ 对是可行的（即 $h$ 是对偶格的一个成员）时，$E=0$。\n\n### 第2部分：算法实现\n\n我们实现一个算法来搜索满足给定优化标准的最优 $(a,m)$ 对。\n算法的核心逻辑如下：\n1.  初始化一个全局最优解 `best_sol`，其误差为无穷大。\n2.  遍历所有乘数 $a$ 从 $2$ 到 $A_{\\max}$。\n3.  对于每个 $a$，确定其对应的最优解 `current_a_best_sol`：\n    a.  首先，逆向搜索模数 $m$ 从 $M_{\\max}$ 到 $2$，寻找一个**可行解**。如果找到，第一个找到的（即最大的）$m$ 就是该 $a$ 的最优可行解。\n    b.  如果没有找到可行解，则正向搜索 $m$ 从 $2$ 到 $M_{\\max}$，寻找一个**最佳近似解**。这需要找到使所有给定法向量 $\\{h^{(i)}\\}$ 的最大近似误差 $E_{\\max}$ 最小化的 $m$。如果误差出现平局，则选择较大的 $m$。\n4.  将 `current_a_best_sol` 与 `best_sol` 进行比较，并根据问题的分层规则更新 `best_sol`：\n    - **规则 1 (可行性)**：可行解优于非可行解。\n    - **规则 2 (误差)**：在非可行解之间，误差较小的胜出。\n    - **规则 3 (模数)**：如果前序规则平局，则 $m$ 较大的胜出。\n    - **规则 4 (乘数)**：如果以上全平局，则 $a$ 较小的胜出（这由 $a$ 的升序循环自动处理）。\n5.  在遍历所有 $a$ 之后，`best_sol` 中存储的就是最终答案。我们使用这个最终的 $(a,m)$ 对重新计算所有误差并按要求格式化输出。\n\n以下是实现此逻辑的Python代码。\n\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LCG inverse design problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\"A_max\": 50, \"M_max\": 5000, \"h_vectors\": [np.array([20, -9, 1, 0, 0], dtype=object)]},\n        {\"A_max\": 50, \"M_max\": 5000, \"h_vectors\": [np.array([20, -9, 1, 0, 0], dtype=object), np.array([1, 0, 0, 0, 0], dtype=object)]},\n        {\"A_max\": 30, \"M_max\": 1000, \"h_vectors\": [np.array([0, -1, 0, 1, 0], dtype=object), np.array([0, -1, 1, 0, 0], dtype=object), np.array([0, 0, -1, 0, 1], dtype=object)]},\n        {\"A_max\": 3, \"M_max\": 2, \"h_vectors\": [np.array([1, 1, 1, 1], dtype=object)]}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_single_case(case)\n        all_results.append(result)\n\n    # Format the final output string\n    result_strings = []\n    for res in all_results:\n        # Format floats to have enough precision without being excessive\n        formatted_res = [res[0], res[1], res[2]]\n        for val in res[3:]:\n            formatted_res.append(f\"{val:.16f}\".rstrip('0').rstrip('.')) if isinstance(val, float) else formatted_res.append(val)\n        result_strings.append(f\"[{','.join(map(str, formatted_res))}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef solve_single_case(case):\n    A_max, M_max, h_vectors = case[\"A_max\"], case[\"M_max\"], case[\"h_vectors\"]\n    t_dim = len(h_vectors[0])\n\n    best_sol = {'a': -1, 'm': -1, 'feasible': False, 'error': float('inf')}\n\n    for a in range(2, A_max + 1):\n        s_values = [sum(h[i] * pow(a, i) for i in range(t_dim)) for h in h_vectors]\n\n        # Stage 1: Search for the best feasible solution for this 'a' (largest m)\n        current_a_sol = None\n        for m in range(M_max, 1, -1):\n            is_feasible_for_m = all((s % m == 0) for s in s_values)\n            if is_feasible_for_m:\n                current_a_sol = {'a': a, 'm': m, 'feasible': True, 'error': 0.0}\n                break\n        \n        # Stage 2: If no feasible solution, find best approximate one\n        if not current_a_sol:\n            best_approx_for_a = {'m': -1, 'error': float('inf')}\n            for m in range(2, M_max + 1):\n                errors = [(min(s % m, m - s % m)) / m for s in s_values]\n                max_error = max(errors)\n                if max_error  best_approx_for_a['error']:\n                    best_approx_for_a = {'m': m, 'error': max_error}\n                elif max_error == best_approx_for_a['error'] and m > best_approx_for_a['m']:\n                    best_approx_for_a['m'] = m\n            if best_approx_for_a['m'] != -1:\n                current_a_sol = {'a': a, 'm': best_approx_for_a['m'], 'feasible': False, 'error': best_approx_for_a['error']}\n\n        if not current_a_sol: continue\n        \n        # Update global best solution based on hierarchical criteria\n        # Initialize if it's the first valid solution found\n        if best_sol['a'] == -1:\n            best_sol = current_a_sol\n            continue\n        \n        # Rule 1: Feasibility is paramount\n        if current_a_sol['feasible'] and not best_sol['feasible']:\n            best_sol = current_a_sol\n        elif current_a_sol['feasible'] == best_sol['feasible']:\n            if best_sol['feasible']: # Both feasible\n                # Rule 3: Larger 'm' wins\n                if current_a_sol['m'] > best_sol['m']:\n                    best_sol = current_a_sol\n            else: # Both not feasible\n                # Rule 2: Smaller error wins\n                if current_a_sol['error']  best_sol['error']:\n                    best_sol = current_a_sol\n                elif current_a_sol['error'] == best_sol['error']:\n                    # Rule 3: Larger 'm' wins\n                    if current_a_sol['m'] > best_sol['m']:\n                        best_sol = current_a_sol\n    \n    # After checking all 'a', finalize the result\n    final_a, final_m, final_feasible = best_sol['a'], best_sol['m'], best_sol['feasible']\n    \n    final_errors = []\n    if final_a != -1:\n        final_s_values = [sum(h[i] * pow(final_a, i) for i in range(t_dim)) for h in h_vectors]\n        final_errors = [(min(s % final_m, final_m - s % final_m)) / final_m for s in final_s_values]\n\n    max_final_error = max(final_errors) if final_errors else 0.0\n    \n    return [final_a, final_m, \"true\" if final_feasible else \"false\", max_final_error, *final_errors]\n\n# To make this runnable within the required format, we wrap the call in a main guard\nif __name__ == '__main__':\n    solve()\n```",
            "answer": "[[50,2070,true,0.0,0.0],[4,5000,false,0.0002,0.0,0.0002],[30,870,true,0.0,0.0,0.0,0.0],[3,2,true,0.0,0.0]]"
        }
    ]
}