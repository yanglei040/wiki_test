{
    "hands_on_practices": [
        {
            "introduction": "This first practice is a foundational exercise in translating a generator's algorithm into its underlying mathematical structure. You will deconstruct the update rules of a xorshift generator and reassemble them as a single linear transition matrix over the Galois Field $\\mathbb{F}_2$. Mastering this translation is the gateway to formally analyzing a generator's period and other structural properties .",
            "id": "3320137",
            "problem": "Consider a four-word xorshift generator known as xorshift128. Its internal state at step $n$ is the $128$-bit vector $s_{n} \\in \\{0,1\\}^{128}$, partitioned into four $32$-bit words $x_{n}, y_{n}, z_{n}, w_{n} \\in \\{0,1\\}^{32}$. The bitwise exclusive-or is the group operation in the vector space over the Galois Field $\\mathbb{F}_2$, so all updates are linear over $\\mathbb{F}_2$. Define the left-shift-by-$k$ and right-shift-by-$k$ maps on a $32$-bit word by zero-filling and discarding shifted-out bits. Let $S_{L}(k) \\in \\mathbb{F}_2^{32 \\times 32}$ and $S_{R}(k) \\in \\mathbb{F}_2^{32 \\times 32}$ denote the matrices implementing these maps, so that for any $u \\in \\{0,1\\}^{32}$ one has $(u \\ll k) = S_{L}(k) u$ and $(u \\gg k) = S_{R}(k) u$. Concretely, with indices $i,j \\in \\{0,1,\\dots,31\\}$, take\n$$\n\\big(S_{L}(k)\\big)_{i,j} =\n\\begin{cases}\n1 & \\text{if } j+k = i, \\\\\n0 & \\text{otherwise},\n\\end{cases}\n\\qquad\n\\big(S_{R}(k)\\big)_{i,j} =\n\\begin{cases}\n1 & \\text{if } j = i+k, \\\\\n0 & \\text{otherwise}.\n\\end{cases}\n$$\nConsider the following update rule (with shift parameters $a = 11$, $b = 8$, and $c = 19$):\n$$\nt_{n} = x_{n} \\oplus (x_{n} \\ll a), \\quad\nx_{n+1} = y_{n}, \\quad\ny_{n+1} = z_{n}, \\quad\nz_{n+1} = w_{n}, \\quad\nw_{n+1} = w_{n} \\oplus (w_{n} \\gg c) \\oplus t_{n} \\oplus (t_{n} \\gg b),\n$$\nwhere $\\oplus$ denotes addition in $\\mathbb{F}_2$ and $\\ll, \\gg$ denote the left and right shifts defined above. By stacking the words, represent the state as the column vector\n$$\ns_{n} =\n\\begin{pmatrix}\nx_{n} \\\\\ny_{n} \\\\\nz_{n} \\\\\nw_{n}\n\\end{pmatrix}\n\\in \\mathbb{F}_2^{128}.\n$$\nTasks:\n- Using only linear-algebra primitives over $\\mathbb{F}_2$ and the definitions of $S_{L}(k)$ and $S_{R}(k)$, construct the $\\mathbb{F}_2$-linear transition matrix $M \\in \\mathbb{F}_2^{128 \\times 128}$ such that $s_{n+1} = M s_{n}$, in block form with $32 \\times 32$ blocks. Express the blocks in terms of $I_{32}$, $S_{L}(a)$, and $S_{R}(b), S_{R}(c)$.\n- Compute the characteristic polynomial $p(\\lambda) \\in \\mathbb{F}_2[\\lambda]$ of $M$, expressing it in closed form using a determinant of a $32 \\times 32$ matrix polynomial in $\\lambda$.\n- From first principles of linear recurrences over finite fields, determine the period of the generator on the nonzero state space $\\mathbb{F}_2^{128} \\setminus \\{0\\}$.\n\nProvide your final answer as a single row matrix with three entries: the block expression for $M$, the characteristic polynomial $p(\\lambda)$, and the period expression; entries may be matrix or scalar analytic expressions, and the period must be expressed exactly without numerical approximation. No rounding is required, and no physical units are involved. The answer must be a calculation object as specified.",
            "solution": "The state update is given by the linear transformation $s_{n+1} = M s_n$. We need to find the $128 \\times 128$ matrix $M$ over $\\mathbb{F}_2$ in its $4 \\times 4$ block form, where each block is a $32 \\times 32$ matrix. The state vectors are $s_n = (x_n^T, y_n^T, z_n^T, w_n^T)^T$ and $s_{n+1} = (x_{n+1}^T, y_{n+1}^T, z_{n+1}^T, w_{n+1}^T)^T$.\n\nThe update rules for the first three words are simple shifts in the block vector:\n$x_{n+1} = y_n \\implies x_{n+1} = 0 \\cdot x_n + I_{32} \\cdot y_n + 0 \\cdot z_n + 0 \\cdot w_n$\n$y_{n+1} = z_n \\implies y_{n+1} = 0 \\cdot x_n + 0 \\cdot y_n + I_{32} \\cdot z_n + 0 \\cdot w_n$\n$z_{n+1} = w_n \\implies z_{n+1} = 0 \\cdot x_n + 0 \\cdot y_n + 0 \\cdot z_n + I_{32} \\cdot w_n$\n\nThese equations determine the first three block-rows of the matrix $M$:\n-   Row 1: $[0, I_{32}, 0, 0]$\n-   Row 2: $[0, 0, I_{32}, 0]$\n-   Row 3: $[0, 0, 0, I_{32}]$\n\nNow we analyze the update for $w_{n+1}$. We first express the intermediate term $t_n$ in matrix form:\n$t_n = x_n \\oplus (x_n \\ll a) = I_{32} x_n + S_L(a) x_n = (I_{32} + S_L(a)) x_n$.\n\nNext, we express $w_{n+1}$ in terms of the words at step $n$. All arithmetic is in $\\mathbb{F}_2$.\n$w_{n+1} = w_n \\oplus (w_n \\gg c) \\oplus t_n \\oplus (t_n \\gg b)$\nUsing the linearity of the shift operators, we can write this in matrix form:\n$w_{n+1} = (I_{32} w_n + S_R(c) w_n) + (I_{32} t_n + S_R(b) t_n)$\n$w_{n+1} = (I_{32} + S_R(c)) w_n + (I_{32} + S_R(b)) t_n$\n\nNow substitute the expression for $t_n$:\n$w_{n+1} = (I_{32} + S_R(c)) w_n + (I_{32} + S_R(b)) (I_{32} + S_L(a)) x_n$\n\nThis equation gives the fourth block-row of $M$:\n$w_{n+1} = M_{41} x_n + M_{42} y_n + M_{43} z_n + M_{44} w_n$.\nBy comparing coefficients, we identify the blocks:\n$M_{41} = (I_{32} + S_R(b))(I_{32} + S_L(a))$\n$M_{42} = 0$\n$M_{43} = 0$\n$M_{44} = I_{32} + S_R(c)$\n\nCombining these blocks, the transition matrix $M$ is a block companion matrix:\n$$\nM = \\begin{pmatrix}\n0 & I_{32} & 0 & 0 \\\\\n0 & 0 & I_{32} & 0 \\\\\n0 & 0 & 0 & I_{32} \\\\\n(I_{32} + S_R(b))(I_{32} + S_L(a)) & 0 & 0 & I_{32} + S_R(c)\n\\end{pmatrix}\n$$\n\nThe characteristic polynomial is $p(\\lambda) = \\det(M - \\lambda I_{128})$. Over $\\mathbb{F}_2$, this is equivalent to $p(\\lambda) = \\det(M + \\lambda I_{128})$. Using the standard formula for the characteristic polynomial of a block companion matrix, we get:\n$p(\\lambda) = \\det(\\lambda^4 I_{32} + \\lambda^3 (I_{32} + S_R(c)) + \\lambda^2(0) + \\lambda(0) + (I_{32} + S_R(b))(I_{32} + S_L(a)))$\nThis simplifies to:\n$$\np(\\lambda) = \\det(\\lambda^4 I_{32} + \\lambda^3 (I_{32} + S_R(c)) + (I_{32} + S_R(b))(I_{32} + S_L(a)))\n$$\nThis is a polynomial of degree $4 \\times 32 = 128$ in $\\mathbb{F}_2[\\lambda]$.\n\nThe sequence of states is generated by $s_{n+1} = M s_n$. The all-zero state is a fixed point. For any nonzero initial state $s_0 \\in \\mathbb{F}_2^{128} \\setminus \\{0\\}$, the sequence of states is periodic. The period is the order of the matrix $M$ in the general linear group $GL(128, \\mathbb{F}_2)$.\n\nFrom the theory of linear recurrences over finite fields, the maximum possible period for a $d$-dimensional recurrence is $2^d - 1$. This maximum period is achieved if and only if the characteristic polynomial of the transition matrix, $p(\\lambda)$, is a primitive polynomial of degree $d$ over $\\mathbb{F}_2$. The generator described in this problem is `xorshift128`, which was designed by George Marsaglia by choosing the shift parameters precisely so that the resulting characteristic polynomial is primitive. Applying this principle, the period of the generator on the nonzero state space is $2^{128} - 1$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} \\begin{pmatrix} 0 & I_{32} & 0 & 0 \\\\ 0 & 0 & I_{32} & 0 \\\\ 0 & 0 & 0 & I_{32} \\\\ (I_{32} + S_R(b))(I_{32} + S_L(a)) & 0 & 0 & I_{32} + S_R(c) \\end{pmatrix} & \\det(\\lambda^4 I_{32} + \\lambda^3 (I_{32} + S_R(c)) + (I_{32} + S_R(b))(I_{32} + S_L(a))) & 2^{128} - 1 \\end{pmatrix} } $$"
        },
        {
            "introduction": "High-quality generators are designed for a maximal period, corresponding to an irreducible and primitive characteristic polynomial. This exercise explores the critical alternative: what is the structure of a state space when the characteristic polynomial is reducible? By applying principles related to the Chinese Remainder Theorem, you will analyze how the state space fractures into disjoint cycles of different lengths, a crucial step in identifying and avoiding generators with undesirable short cycles .",
            "id": "3320141",
            "problem": "An abstraction of the Mersenne Twister (MT) state transition is an invertible linear map over the two-element field $\\mathbb{F}_2$, acting on a finite-dimensional $\\mathbb{F}_2$-vector space. Consider a toy Mersenne Twister (MT) state transition $T$ on $\\mathbb{F}_2^{12}$ with the following properties.\n\n1. The characteristic polynomial of $T$ is \n$$\nP(x) \\;=\\; p_{1}(x)\\,p_{2}(x),\n$$\nwhere $p_{1}(x)$ and $p_{2}(x)$ are distinct monic irreducible polynomials over $\\mathbb{F}_2$ of degrees $8$ and $4$, respectively, each with nonzero constant term. Assume $p_{2}(x)=x^{4}+x+1$ and that $p_{1}(x)$ is some fixed degree-$8$ irreducible polynomial. \n\n2. Regard $\\mathbb{F}_2^{12}$ as the $\\mathbb{F}_2[x]$-module obtained from the action of $T$ by $x\\cdot v := T(v)$. By the Chinese Remainder Theorem for modules and coprimeness of $p_{1}$ and $p_{2}$, the space decomposes as an $\\mathbb{F}_2[x]$-module\n$$\n\\mathbb{F}_2^{12} \\;\\cong\\; \\mathbb{F}_2[x]/(p_{1}) \\;\\oplus\\; \\mathbb{F}_2[x]/(p_{2}),\n$$\nwhere the action of $T$ corresponds to multiplication by the residue class of $x$ in each component.\n\n3. Let $m_{i}$ denote the multiplicative order of the residue class of $x$ in the unit group $\\big(\\mathbb{F}_2[x]/(p_{i})\\big)^{\\times}$, which divides $2^{\\deg p_{i}}-1$. It is known that $\\deg p_{2}=4$ and $p_{2}(x)=x^{4}+x+1$ is primitive of order $m_{2}=15$, and that there exists a degree-$8$ irreducible $p_{1}$ for which $m_{1}=17$ (non-primitive). Assume these orders hold for the given $p_{1}$ and $p_{2}$.\n\nUsing only the linearity over $\\mathbb{F}_2$ and the above structural facts, do the following:\n\na) Derive the cycle structure of $T$ on $\\mathbb{F}_2^{12}$ in terms of the four disjoint classes of states corresponding to the pair $(u,v) \\in \\mathbb{F}_2[x]/(p_{1}) \\oplus \\mathbb{F}_2[x]/(p_{2})$ being zero or nonzero on each component. Express the period of a state in each class in terms of $m_{1}$ and $m_{2}$, and justify your conclusions from first principles.\n\nb) Compute the period of a generic nonzero state (meaning both components $u$ and $v$ are nonzero). Also compute how many states have this generic period, and how many cycles of the generic period exist.\n\nc) Define a “short cycle” to be any cycle whose length is strictly less than the generic period. Determine how many short cycles there are in total. Give your final answer as a single integer (no units).",
            "solution": "The problem describes a linear transformation $T$ on the vector space $V = \\mathbb{F}_2^{12}$ over the field of two elements $\\mathbb{F}_2$. The structure of this transformation is given by its characteristic polynomial $P(x) = p_{1}(x)p_{2}(x)$, where $p_{1}(x)$ and $p_{2}(x)$ are distinct irreducible polynomials over $\\mathbb{F}_2$ with degrees $\\deg p_{1} = 8$ and $\\deg p_{2} = 4$.\n\nSince $p_{1}(x)$ and $p_{2}(x)$ are coprime, the Chinese Remainder Theorem implies that the space $V$ decomposes as a direct sum of $T$-invariant subspaces $V_1$ and $V_2$:\n$$\nV \\cong V_1 \\oplus V_2\n$$\nwhere $V_1 = \\ker(p_1(T))$ and $V_2 = \\ker(p_2(T))$. As $\\mathbb{F}_2[x]$-modules, where the action of $x$ corresponds to the action of $T$, this decomposition is given as:\n$$\nV \\cong \\frac{\\mathbb{F}_2[x]}{(p_{1}(x))} \\oplus \\frac{\\mathbb{F}_2[x]}{(p_{2}(x))}\n$$\nThe subspaces $V_1$ and $V_2$ are vector spaces over $\\mathbb{F}_2$ of dimension $\\deg p_1 = 8$ and $\\deg p_2 = 4$, respectively. Thus, $|V_1| = 2^8 = 256$ and $|V_2| = 2^4 = 16$. The total number of states in $V$ is $|V_1| \\times |V_2| = 2^8 \\times 2^4 = 2^{12} = 4096$.\n\nAny state $w \\in V$ can be uniquely represented as a pair $(u, v)$ where $u \\in V_1$ and $v \\in V_2$. The action of $T$ on such a pair is component-wise: $T(w) = T((u, v)) = (T_1(u), T_2(v))$, where $T_1$ and $T_2$ are the restrictions of $T$ to $V_1$ and $V_2$. The period of a state $w=(u,v)$ is the smallest positive integer $k$ such that $T^k(w) = w$, which is equivalent to finding the smallest $k>0$ such that $T_1^k(u) = u$ and $T_2^k(v) = v$.\n\na) To derive the cycle structure, we classify states based on whether their components $u$ and $v$ are zero or nonzero.\n\n1.  **Class 1: $u=0, v=0$**. This corresponds to the zero state $w=(0,0) \\in V$. $T(0,0) = (0,0)$, so the period is $1$. There is exactly $1$ such state, forming a single cycle of length $1$.\n\n2.  **Class 2: $u \\neq 0, v=0$**. The state is $w=(u,0)$ with $u \\in V_1 \\setminus \\{0\\}$. The period $k$ is the smallest integer such that $T_1^k(u) = u$. Since $p_1(x)$ is irreducible, $V_1 \\cong \\mathbb{F}_2[x]/(p_1(x))$ is the field $\\mathbb{F}_{2^8}$. The period is the multiplicative order of the element corresponding to $x$ in this field, given as $m_1 = 17$. Therefore, every state in this class has a period of $17$.\n\n3.  **Class 3: $u=0, v \\neq 0$**. The state is $w=(0,v)$ with $v \\in V_2 \\setminus \\{0\\}$. By identical reasoning, the period is determined by the order of $x$ in the field $V_2 \\cong \\mathbb{F}_2[x]/(p_2(x)) = \\mathbb{F}_{2^4}$. The problem provides that this order is $m_2 = 15$. Thus, every state in this class has a period of $15$.\n\n4.  **Class 4: $u \\neq 0, v \\neq 0$**. The period $k$ must be the smallest positive integer that is a multiple of both the period of $u$ (which is $m_1$) and the period of $v$ (which is $m_2$). Therefore, the period of any state in this class is $\\operatorname{lcm}(m_1, m_2)$.\n\nb) A generic nonzero state is one where both components are nonzero (Class 4).\n\nThe period of a generic state is $\\operatorname{lcm}(m_1, m_2) = \\operatorname{lcm}(17, 15)$. Since $17$ is prime and $15 = 3 \\times 5$, they are coprime. Therefore, the period is $17 \\times 15 = 255$.\n\nThe number of states with this generic period is the number of ways to choose a nonzero $u \\in V_1$ and a nonzero $v \\in V_2$:\nNumber of states = $(|V_1| - 1) \\times (|V_2| - 1) = (2^8 - 1) \\times (2^4 - 1) = 255 \\times 15 = 3825$.\n\nThese states are partitioned into disjoint cycles, each of length $255$. The number of such cycles is the total number of states divided by the cycle length:\nNumber of cycles = $\\frac{3825}{255} = 15$.\n\nc) A \"short cycle\" is a cycle with length strictly less than the generic period of $255$. These correspond to states in Classes 1, 2, and 3. We must count the number of cycles, not the number of states.\n\n-   **Cycles of length 1**: These come from Class 1. There is $1$ such state, $(0,0)$, which forms $1$ cycle of length $1$.\n\n-   **Cycles of length 17**: These come from Class 2. There are $2^8-1 = 255$ such states. Each state lies on a cycle of length $17$. The number of such cycles is $\\frac{255}{17} = 15$.\n\n-   **Cycles of length 15**: These come from Class 3. There are $2^4-1 = 15$ such states. Each state lies on a cycle of length $15$. The number of such cycles is $\\frac{15}{15} = 1$.\n\nThe lengths $1$, $15$, and $17$ are all strictly less than $255$. The total number of short cycles is the sum of the number of cycles of these lengths:\nTotal number of short cycles = (Cycles of length $1$) + (Cycles of length $15$) + (Cycles of length $17$)\nTotal number of short cycles = $1 + 1 + 15 = 17$.",
            "answer": "$$\\boxed{17}$$"
        },
        {
            "introduction": "A long period is a necessary, but not sufficient, condition for a high-quality pseudo-random number generator. This final practice moves from abstract algebraic properties to concrete empirical analysis, tackling the practical issue of transient behavior. You will design and implement a computational experiment to measure how quickly the output sequences of xorshift and Mersenne Twister generators converge to expected statistical norms, particularly when initialized with low-complexity seeds .",
            "id": "3320097",
            "problem": "You are to design and implement a program that empirically studies the Hamming-weight dynamics of two classes of pseudo-random number generators, and evaluates whether low-Hamming-weight seeds induce long transients in the associated Uniform distribution on the unit interval (U(0,1)) output sequence. The two generators are the Mersenne Twister (MT) and a single-step Exclusive-Or shift (xorshift) generator.\n\nStart from the following fundamental base:\n- A pseudo-random number generator (PRNG) is a deterministic map that produces a sequence intended to approximate independent samples from a target distribution, commonly the Uniform distribution on the unit interval (U(0,1)).\n- The state of many PRNGs is naturally modeled over the binary field, and their transitions are linear over the binary field or are compositions of bitwise operations. For a state represented as a $w$-bit word, the Hamming weight $H(x)$ of a word $x$ is the number of positions that are equal to $1$.\n- The Uniform distribution on the unit interval (U(0,1)) mapping for a $w$-bit output $x$ is defined by $u = x / 2^w$.\n\nThe two PRNGs to study are:\n1. Mersenne Twister (MT), whose internal state transition can be written as a linear transformation over the binary field, $x_{n+1} = A x_n$, where $A$ is a fixed matrix determined by the algorithm. In implementation, do not construct $A$; instead, use a reference implementation to generate the $w$-bit outputs and treat the update rule abstractly as linear.\n2. A single-step xorshift generator defined by\n$$\nx_{n+1} = x_n \\oplus (x_n \\ll a) \\oplus (x_n \\gg b),\n$$\nwhere $\\oplus$ denotes bitwise XOR, $\\ll$ denotes left shift, and $\\gg$ denotes right shift. The state is kept to $w$ bits by masking to $2^w - 1$ after each update.\n\nFor both generators:\n- Represent the output word as a $w$-bit unsigned integer and map it to $u_n = x_n / 2^w$ to obtain a value in $[0,1)$.\n- Define the empirical sample mean at time $n$ as $m_n = \\frac{1}{n}\\sum_{k=1}^n u_k$.\n- Define the instantaneous normalized Hamming weight at time $n$ as $r_n = H(x_n)/w$.\n\nDefine the transient length $T$ for a given generator and seed as the smallest index $n^\\star$ such that for the window of indices $j \\in \\{n^\\star, n^\\star+1, \\dots, n^\\star+W-1\\}$ both conditions\n$$\n\\lvert m_j - 0.5 \\rvert \\le \\varepsilon \\quad \\text{and} \\quad \\lvert r_j - 0.5 \\rvert \\le \\delta\n$$\nhold simultaneously, with the additional constraint $n^\\star \\ge n_{\\min}$. If no such $n^\\star$ exists up to $N_{\\max}$, set $T = N_{\\max}$.\n\nUse the following fixed parameters for all tests:\n- Word width $w = 32$.\n- Xorshift parameters $a = 13$ and $b = 17$.\n- Window length $W = 512$.\n- Minimum starting index $n_{\\min} = 64$.\n- Maximum number of steps $N_{\\max} = 100000$.\n- Mean tolerance $\\varepsilon = 0.01$.\n- Hamming-weight tolerance $\\delta = 0.125$.\n- For the mapping to U(0,1), always use $u_n = x_n / 2^w$.\n\nImplement the xorshift update exactly as stated. For Mersenne Twister (MT), use a reference MT19937 implementation to produce $w$-bit outputs and apply the U(0,1) mapping.\n\nTest Suite:\nCompute the transient length $T$ for both generators using the following $w$-bit seeds:\n- $s^{(1)} = 1$ (Hamming weight $1$).\n- $s^{(2)} = 2^{31} + 1$ (Hamming weight $2$).\n- $s^{(3)} = 0x12345678$ (a typical mid-weight pattern).\n- $s^{(4)} = 2^{32} - 1$ (Hamming weight $32$).\n- $s^{(5)} = 0$ (the absorbing state for the xorshift).\n\nFor each seed $s^{(i)}$ in the order $s^{(1)}, s^{(2)}, s^{(3)}, s^{(4)}, s^{(5)}$, compute and report the pair $[T_{\\text{xorshift}}, T_{\\text{MT}}]$.\n\nFinal Output Format:\nYour program should produce a single line of output containing a comma-separated list of the $5$ pairs corresponding to the seeds, enclosed in square brackets, with no spaces. For example,\n$$\n[ [T_{\\text{xorshift}}^{(1)},T_{\\text{MT}}^{(1)}],[T_{\\text{xorshift}}^{(2)},T_{\\text{MT}}^{(2)}],\\dots,[T_{\\text{xorshift}}^{(5)},T_{\\text{MT}}^{(5)}] ]\n$$\nbut rendered without spaces as\n$[[T_{\\text{xorshift}}^{(1)},T_{\\text{MT}}^{(1)}],[T_{\\text{xorshift}}^{(2)},T_{\\text{MT}}^{(2)}],[T_{\\text{xorshift}}^{(3)},T_{\\text{MT}}^{(3)}],[T_{\\text{xorshift}}^{(4)},T_{\\text{MT}}^{(4)}],[T_{\\text{xorshift}}^{(5)},T_{\\text{MT}}^{(5)}]]$.\n\nAll numeric outputs must be integers. The program must be self-contained and require no input.",
            "solution": "The solution requires implementing an empirical study to compute the transient length $T$ for both the xorshift and Mersenne Twister generators. The transient length is determined by analyzing the statistical properties of the output sequence, starting from different seeds.\n\n**1. PRNG Implementations**\n\nTwo generators are implemented according to the problem specification:\n-   **xorshift Generator:** The state update rule $x_{n+1} = x_n \\oplus (x_n \\ll 13) \\oplus (x_n \\gg 17)$ is directly implemented for 32-bit unsigned integers. The initial state is the provided seed. A crucial case is the seed $s=0$, which is a fixed point for this recurrence, resulting in a constant sequence of zeros.\n-   **Mersenne Twister (MT19937):** A standard reference implementation, such as the one available in Python's NumPy library (`numpy.random.MT19937`), is used. This bit generator is seeded, and a `Generator` instance is used to draw 32-bit unsigned integers. High-quality implementations like this correctly handle all seed values, including 0, by using an internal seeding procedure to initialize a valid, non-degenerate state array.\n\n**2. Algorithm for Transient Length ($T$)**\n\nTo efficiently compute the transient length, a single-pass algorithm is used. This avoids a costly nested loop structure. The algorithm proceeds as follows for each generator and seed:\n\n1.  Initialize a counter for consecutive steps meeting the stability criteria, `consecutive_successes`, to zero.\n2.  Initialize a running sum of the uniform deviates, `total_u`, to zero.\n3.  Iterate from $n=1$ to the maximum number of steps, $N_{\\max}=100000$. In each step:\n    a. Generate the next 32-bit value $x_n$ from the PRNG.\n    b. Calculate the derived metrics: the uniform deviate $u_n = x_n / 2^{32}$, the running mean $m_n = (\\sum_{k=1}^n u_k) / n$, and the normalized Hamming weight $r_n = H(x_n)/32$.\n    c. Check if the two stability conditions are met: $|\\,m_n - 0.5\\,| \\le 0.01$ and $|\\,r_n - 0.5\\,| \\le 0.125$.\n    d. If both conditions are true, increment `consecutive_successes`. Otherwise, reset it to zero.\n    e. If `consecutive_successes` reaches the required window length $W=512$, a stable window has been found. The start of this window is $n^\\star = n - W + 1$.\n    f. If this start index $n^\\star$ is also greater than or equal to the minimum index $n_{\\min}=64$, then we have found our transient length. The value $T = n^\\star$ is recorded, and the simulation for this case terminates.\n4.  If the loop completes without finding a qualifying stable window, the transient length is reported as the maximum value, $T = N_{\\max}$.\n\nThis algorithm correctly finds the smallest index $T$ that marks the beginning of the first stable window of length $W$ that occurs at or after step $n_{\\min}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to conduct the PRNG study and produce the final output.\n    \"\"\"\n    \n    # Fixed parameters as specified in the problem statement.\n    W = 512          # Window length\n    N_MIN = 64       # Minimum starting index for T\n    N_MAX = 100000   # Maximum number of steps\n    EPSILON = 0.01   # Mean tolerance\n    DELTA = 0.125    # Hamming-weight tolerance\n    W_BITS = 32      # Word width\n    XOR_A = 13       # Xorshift parameter a\n    XOR_B = 17       # Xorshift parameter b\n\n    # Test suite of seeds.\n    test_cases = [\n        1,\n        2**31 + 1,\n        0x12345678,\n        2**32 - 1,\n        0,\n    ]\n\n    def compute_transient_length(generator_type, seed):\n        \"\"\"\n        Computes the transient length T for a given generator and seed.\n\n        Args:\n            generator_type (str): 'xorshift' or 'mt'.\n            seed (int): The initial seed for the generator.\n\n        Returns:\n            int: The computed transient length T.\n        \"\"\"\n        # Constants for 32-bit arithmetic and normalization.\n        TWO_POW_W = 2**W_BITS\n        MASK = TWO_POW_W - 1\n\n        # Initialize the appropriate generator.\n        if generator_type == 'xorshift':\n            x_state = seed & MASK\n            def next_val():\n                nonlocal x_state\n                # The state updates and the new state is the output value.\n                x_state = (x_state ^ (x_state << XOR_A) ^ (x_state >> XOR_B)) & MASK\n                return x_state\n        elif generator_type == 'mt':\n            bg = np.random.MT19937(seed)\n            rg = np.random.Generator(bg)\n            def next_val():\n                return int(rg.integers(TWO_POW_W, dtype=np.uint32))\n        else:\n            raise ValueError(\"Unknown generator type\")\n\n        total_u = 0.0\n        consecutive_successes = 0\n\n        # Main simulation loop from n=1 to N_MAX.\n        for n in range(1, N_MAX + 1):\n            x_n = next_val()\n\n            # Calculate derived metrics for the current step.\n            u_n = x_n / TWO_POW_W\n            total_u += u_n\n            m_n = total_u / n\n            r_n = bin(x_n).count('1') / W_BITS\n\n            # Check if the stability conditions are met.\n            is_success = (abs(m_n - 0.5) <= EPSILON) and (abs(r_n - 0.5) <= DELTA)\n            \n            if is_success:\n                consecutive_successes += 1\n            else:\n                consecutive_successes = 0\n\n            # Check if a stable window of length W has been found.\n            # The window is [n - W + 1, n]. Its start must be >= N_MIN.\n            if consecutive_successes >= W:\n                n_star = n - W + 1\n                if n_star >= N_MIN:\n                    return n_star # Found the smallest T.\n\n        # If the loop finishes, no such window was found.\n        return N_MAX\n\n    results = []\n    for seed in test_cases:\n        t_xorshift = compute_transient_length('xorshift', seed)\n        t_mt = compute_transient_length('mt', seed)\n        results.append([t_xorshift, t_mt])\n    \n    # Format the final output string exactly as specified.\n    final_output = str(results).replace(' ', '')\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}