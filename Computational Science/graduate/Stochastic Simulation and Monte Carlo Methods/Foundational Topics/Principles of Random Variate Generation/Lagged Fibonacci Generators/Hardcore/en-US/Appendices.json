{
    "hands_on_practices": [
        {
            "introduction": "Theoretical properties are essential, but the true test of a pseudorandom number generator lies in its empirical performance. This first practice invites you to roll up your sleeves and implement a subtractive generator, a common type of Lagged Fibonacci Generator, from its fundamental recurrence relation. By pitting its output against that of a standard Linear Congruential Generator (LCG) and evaluating both with a suite of statistical tests , you will gain direct experience in both the construction and validation of these foundational simulation tools.",
            "id": "2408853",
            "problem": "You are to implement and compare two pseudo-random number generators that are widely discussed in computational physics: a standard linear congruential generator (LCG) and a subtractive generator (a specific case of a lagged Fibonacci generator). Your task is to design a program that generates sequences from both generators under specified parameter sets, evaluates basic statistical properties of the generated sequences, and reports which generator performs better under each test case with respect to the chosen metrics.\n\nBegin from the following fundamental bases:\n\n1. The definition of congruence modulo: integers $a$ and $b$ are congruent modulo $m$ if and only if $m$ divides $a-b$, denoted $a \\equiv b \\pmod m$. Arithmetic operations in the recurrence relations below are to be interpreted modulo $m$.\n2. The concept of a pseudo-random number generator as a deterministic recurrence producing integers $X_n$ which are normalized to real values $U_n = X_n/m$ intended to approximate independent draws from the continuous uniform distribution on $[0,1)$.\n3. The standard empirical statistics for a sequence $\\{U_n\\}_{n=1}^N$: \n   - empirical mean $\\mu = \\frac{1}{N}\\sum_{n=1}^N U_n$,\n   - empirical variance $v = \\frac{1}{N}\\sum_{n=1}^N (U_n - \\mu)^2$,\n   - lag-$1$ empirical autocorrelation coefficient $r_1$ computed from the covariance of $(U_n,U_{n+1})$ divided by $v$,\n   - a simple chi-square uniformity statistic using $K$ equally spaced bins on $[0,1)$ with observed counts $\\{O_k\\}_{k=1}^K$ and expected count $E = N/K$, defined as $\\chi^2 = \\sum_{k=1}^K \\frac{(O_k - E)^2}{E}$. The continuous uniform distribution on $[0,1)$ has theoretical mean $1/2$ and variance $1/12$.\n\nImplement the following, strictly from these definitions:\n\nA. Linear congruential generator (LCG). Generate a sequence $\\{X_n\\}$ by the recurrence\n$$X_{n+1} \\equiv a X_n + c \\pmod m,$$\nwith given integers $m \\ge 2, 0 \\le a  m, 0 \\le c  m$, and initial $X_0$. Convert to $U_n = X_n/m$.\n\nB. Subtractive generator (lagged Fibonacci type). Maintain a state vector of length $L = \\max\\{i,j\\}$ with elements in $\\{0,1,\\dots,m-1\\}$, and generate\n$$X_{n} \\equiv X_{n-i} - X_{n-j} \\pmod m,$$\nfor given lags $i,j$ with $1 \\le i,j \\le L$ and $i \\ne j$. Convert to $U_n = X_n/m$. Initialize the state deterministically using the following rule: given a seed $s_0$, define $V_0 \\equiv s_0 \\pmod m$ and for $k=0,1,\\dots,L-1$ set\n$$V_{k+1} \\equiv a_s V_k + c_s \\pmod m,$$\nwith fixed seeding constants $a_s = 1664525$ and $c_s = 1013904223$, and take the initial state $(X_0,X_1,\\dots,X_{L-1}) = (V_1,V_2,\\dots,V_L)$.\n\nFor each generator and parameter set below, do the following procedural steps:\n\n1. Discard the first $W$ outputs (warm-up) to mitigate initialization bias.\n2. Then generate $N$ values $U_n$ in $[0,1)$.\n3. Compute the four metrics: absolute mean error $|\\mu - 1/2|$, absolute variance error $|v - 1/12|$, absolute lag-$1$ autocorrelation $|r_1|$, and the chi-square statistic $\\chi^2$ with $K$ equally spaced bins.\n\nCompare the two generators by declaring the subtractive generator to be better on a metric if and only if its value for that metric is strictly smaller than the corresponding value for the LCG (for $\\chi^2$, smaller indicates closer to uniformity in this test). No other thresholds are to be used.\n\nUse these fixed evaluation parameters for all test cases: warm-up $W = 1000$, sequence length $N = 50000$, and number of bins $K = 10$.\n\nTest suite (three cases), each specifying $m$, the LCG parameters $(a,c,X_0)$, and the subtractive parameters $(i,j,s_0)$:\n\n- Case $1$ (large prime-like modulus, widely used LCG and well-spaced lags):\n  - $m = 2147483647$, LCG $(a,c,X_0) = (16807,0,12345)$, subtractive $(i,j,s_0) = (24,55,67890)$.\n- Case $2$ (small modulus, poor LCG and small lags stressing edge behavior):\n  - $m = 65536$, LCG $(a,c,X_0) = (5,1,7)$, subtractive $(i,j,s_0) = (1,2,11)$.\n- Case $3$ (power-of-two modulus with commonly used LCG parameters and well-spaced lags):\n  - $m = 4294967296$, LCG $(a,c,X_0) = (1664525,1013904223,42)$, subtractive $(i,j,s_0) = (24,55,13579)$.\n\nFinal output specification:\n\n- For each case, compute four booleans indicating whether the subtractive generator is better than the LCG on, respectively, absolute mean error, absolute variance error, absolute lag-$1$ autocorrelation, and chi-square statistic.\n- Aggregate the booleans for all cases into a single flat list of length $12$ in the order: Case $1$ mean, Case $1$ variance, Case $1$ autocorrelation, Case $1$ chi-square, Case $2$ mean, Case $2$ variance, Case $2$ autocorrelation, Case $2$ chi-square, Case $3$ mean, Case $3$ variance, Case $3$ autocorrelation, Case $3$ chi-square.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces, for example, \"[True,False,True,...]\".\n\nNo physical units or angles are involved in this task. All results are unitless real-valued computations reduced to boolean comparisons as specified. The program must be fully deterministic and self-contained, using only the specified libraries, and must not read any input.",
            "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded, well-posed, and provides a complete and unambiguous specification for implementation and evaluation. It is a standard exercise in computational physics concerning the properties of pseudo-random number generators.\n\nThe task is to implement and compare a Linear Congruential Generator (LCG) and a Subtractive Generator. For three distinct parameter sets, sequences of random numbers are generated, evaluated against four statistical metrics, and a comparison is made to determine which generator performs better on each metric. The solution is thus constructed by first implementing the generators and statistical tests, then executing the specified procedure for all test cases.\n\n**Generator Implementation**\n\n1.  **Linear Congruential Generator (LCG)**: This generator produces a sequence of integers $\\{X_n\\}$ via the recurrence relation:\n    $$X_{n+1} \\equiv a X_n + c \\pmod m$$\n    where $m$ is the modulus, $a$ is the multiplier, $c$ is the increment, and $X_0$ is the initial seed. The implementation involves a loop that iteratively applies this formula. Given an initial state $X_0$, the first $W$ values are generated and discarded for warm-up. Subsequently, $N$ values are generated and stored. Each integer $X_n$ is normalized to a real number $U_n \\in [0, 1)$ by the transformation $U_n = X_n / m$.\n\n2.  **Subtractive Generator**: This generator, a form of a lagged Fibonacci generator, produces a sequence $\\{X_n\\}$ using the recurrence:\n    $$X_{n} \\equiv X_{n-i} - X_{n-j} \\pmod m$$\n    where $i$ and $j$ are the lags. This requires maintaining a state of the previous $L = \\max\\{i, j\\}$ values. The implementation uses a circular buffer (a deque of fixed size $L$) to efficiently manage this state.\n    \n    The initial state $(X_0, X_1, \\dots, X_{L-1})$ is itself generated deterministically using an auxiliary LCG. Starting with a seed $s_0$, we define $V_0 \\equiv s_0 \\pmod m$. Then, for $k=0, 1, \\dots, L-1$, we compute:\n    $$V_{k+1} \\equiv a_s V_k + c_s \\pmod m$$\n    with fixed seeding constants $a_s = 1664525$ and $c_s = 1013904223$. The initial state for the subtractive generator is set to $(X_0, \\dots, X_{L-1}) = (V_1, \\dots, V_L)$.\n    \n    The generation process begins by populating the circular buffer with this initial state. The warm-up and generation loops then proceed. In each step, the new value $X_n$ is computed from the elements at positions corresponding to lags $i$ and $j$ in the buffer. The result of the subtraction $X_{n-i} - X_{n-j}$ can be negative; the modulo operation $x \\pmod m$ is defined consistent with number theory, mapping any integer $x$ to the unique remainder in the set $\\{0, 1, \\dots, m-1\\}$. The newly generated value replaces the oldest value in the circular buffer. As with the LCG, the generated integers are normalized to $U_n = X_n / m$.\n\n**Statistical Evaluation**\n\nFor each generated sequence $\\{U_n\\}_{n=1}^N$ of length $N = 50000$, four performance metrics are computed. These metrics quantify the deviation of the sequence from the properties of a true uniform distribution on $[0,1)$, which has a theoretical mean of $1/2$ and variance of $1/12$. The computations are performed using the `numpy` library for efficiency.\n\n1.  **Absolute Mean Error**: The empirical mean is $\\mu = \\frac{1}{N}\\sum_{n=1}^N U_n$. The metric is $|\\mu - 1/2|$.\n2.  **Absolute Variance Error**: The empirical variance is $v = \\frac{1}{N}\\sum_{n=1}^N (U_n - \\mu)^2$. The metric is $|v - 1/12|$.\n3.  **Absolute Lag-1 Autocorrelation**: The lag-$1$ autocorrelation coefficient $r_1$ measures the correlation between successive values. It is computed as:\n    $$r_1 = \\frac{\\sum_{n=1}^{N-1} (U_n - \\mu)(U_{n+1} - \\mu)}{\\sum_{n=1}^N (U_n - \\mu)^2}$$\n    The metric is the absolute value, $|r_1|$.\n4.  **Chi-Square Uniformity Statistic**: This statistic tests the goodness-of-fit to a uniform distribution. The interval $[0,1)$ is divided into $K=10$ equal bins. The number of values $O_k$ falling into each bin $k$ is counted. The expected count for each bin is $E = N/K$. The statistic is calculated as:\n    $$\\chi^2 = \\sum_{k=1}^K \\frac{(O_k - E)^2}{E}$$\n    A smaller $\\chi^2$ value suggests a better fit to the uniform distribution.\n\n**Procedural Logic**\n\nFor each of the three test cases, the following procedure is executed:\n1.  Both the LCG and the Subtractive Generator are initialized with the specified parameters for the case.\n2.  Each generator discards $W = 1000$ warm-up values.\n3.  Each generator then produces a sequence of $N = 50000$ values.\n4.  The four statistical metrics are computed for both sequences.\n5.  A comparison is made for each metric: the subtractive generator is deemed 'better' if and only if its metric value is strictly smaller than the LCG's corresponding metric value. This yields four boolean results per test case.\n6.  The boolean results from all three cases are aggregated into a single list of $12$ values in the specified order and formatted for the final output. The entire process is deterministic.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef calculate_metrics(sequence, m, N, K):\n    \"\"\"\n    Calculates the four statistical metrics for a given sequence of random numbers.\n    \n    Args:\n        sequence (list): A list of integers X_n generated by a PRNG.\n        m (int): The modulus used for normalization.\n        N (int): The length of the sequence.\n        K (int): The number of bins for the chi-square test.\n\n    Returns:\n        dict: A dictionary containing the four computed metric values.\n    \"\"\"\n    # Normalize sequence to [0, 1)\n    U = np.array(sequence, dtype=np.float64) / m\n\n    # 1. Mean\n    mu = np.mean(U)\n    mean_err = abs(mu - 0.5)\n\n    # 2. Variance\n    v = np.var(U)  # numpy.var uses N in denominator by default (ddof=0)\n    var_err = abs(v - 1.0/12.0)\n\n    # 3. Lag-1 Autocorrelation\n    # r_1 = sum{(U_n - mu)(U_{n+1} - mu)} / sum{(U_n - mu)^2}\n    numerator = np.sum((U[:-1] - mu) * (U[1:] - mu))\n    denominator = N * v\n    r1 = numerator / denominator if denominator != 0 else 0.0\n    abs_r1 = abs(r1)\n\n    # 4. Chi-Square Statistic\n    expected_count = N / K\n    observed_counts, _ = np.histogram(U, bins=K, range=(0.0, 1.0))\n    chi2 = np.sum((observed_counts - expected_count)**2 / expected_count)\n\n    return {\n        'mean_err': mean_err,\n        'var_err': var_err,\n        'abs_r1': abs_r1,\n        'chi2': chi2,\n    }\n\ndef generate_lcg_sequence(m, a, c, x0, N, W):\n    \"\"\"Generates a sequence using the Linear Congruential Generator.\"\"\"\n    sequence = []\n    x = x0\n    # Warm-up phase\n    for _ in range(W):\n        x = (a * x + c) % m\n    # Generation phase\n    for _ in range(N):\n        x = (a * x + c) % m\n        sequence.append(x)\n    return sequence\n\ndef generate_subtractive_sequence(m, i, j, s0, a_s, c_s, N, W):\n    \"\"\"Generates a sequence using the Subtractive Generator.\"\"\"\n    L = max(i, j)\n    \n    # Initialize state vector V\n    V = [0] * (L + 1)\n    V[0] = s0 % m\n    for k in range(L):\n        V[k+1] = (a_s * V[k] + c_s) % m\n        \n    # Initial state buffer for the generator\n    state_buffer = deque(V[1:], maxlen=L)\n    \n    # Warm-up phase\n    for _ in range(W):\n        # NOTE: Python's % operator handles negative results correctly for modulo arithmetic.\n        # x % m gives a result in [0, m-1] for positive m.\n        val_i = state_buffer[L - i]\n        val_j = state_buffer[L - j]\n        new_x = (val_i - val_j) % m\n        state_buffer.append(new_x)\n\n    # Generation phase\n    sequence = []\n    for _ in range(N):\n        val_i = state_buffer[L - i]\n        val_j = state_buffer[L - j]\n        new_x = (val_i - val_j) % m\n        state_buffer.append(new_x)\n        sequence.append(new_x)\n        \n    return sequence\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation, evaluate generators, and print results.\n    \"\"\"\n    \n    # Define fixed evaluation parameters from the problem statement.\n    W = 1000\n    N = 50000\n    K = 10\n    a_s = 1664525\n    c_s = 1013904223\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"m\": 2147483647,\n            \"lcg_params\": (16807, 0, 12345),\n            \"sub_params\": (24, 55, 67890)\n        },\n        # Case 2\n        {\n            \"m\": 65536,\n            \"lcg_params\": (5, 1, 7),\n            \"sub_params\": (1, 2, 11)\n        },\n        # Case 3\n        {\n            \"m\": 4294967296,\n            \"lcg_params\": (1664525, 1013904223, 42),\n            \"sub_params\": (24, 55, 13579)\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        m = case[\"m\"]\n        a, c, x0 = case[\"lcg_params\"]\n        i, j, s0 = case[\"sub_params\"]\n\n        # 1. Generate LCG sequence and compute its metrics\n        lcg_sequence = generate_lcg_sequence(m, a, c, x0, N, W)\n        lcg_metrics = calculate_metrics(lcg_sequence, m, N, K)\n        \n        # 2. Generate Subtractive sequence and compute its metrics\n        sub_sequence = generate_subtractive_sequence(m, i, j, s0, a_s, c_s, N, W)\n        sub_metrics = calculate_metrics(sub_sequence, m, N, K)\n        \n        # 3. Compare metrics and store boolean results\n        # The subtractive generator is better if its metric value is strictly smaller.\n        is_sub_better_mean = sub_metrics['mean_err']  lcg_metrics['mean_err']\n        is_sub_better_var = sub_metrics['var_err']  lcg_metrics['var_err']\n        is_sub_better_corr = sub_metrics['abs_r1']  lcg_metrics['abs_r1']\n        is_sub_better_chi2 = sub_metrics['chi2']  lcg_metrics['chi2']\n        \n        all_results.extend([\n            is_sub_better_mean,\n            is_sub_better_var,\n            is_sub_better_corr,\n            is_sub_better_chi2\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Simple generators can have notable flaws, which led to the development of more advanced variants. This exercise challenges you to implement the Subtract-With-Borrow (SWB) generator, a powerful class of LFG known for its exceptionally long periods. The core of this practice lies in correctly managing the 'borrow' bit, a subtle detail that is critical for a robust implementation and that avoids issues like integer underflow . By developing the generator and verifying its behavior against a precise mathematical invariant, you will appreciate the meticulous engineering required for high-quality random number generation.",
            "id": "3316652",
            "problem": "You are to design, implement, and validate a subtract-with-borrow lagged Fibonacci generator for uniform variates on the unit interval within the framework of stochastic simulation and Monte Carlo methods. Your implementation must be grounded in the following core definitions and facts: random number generation is modeled as a deterministic recurrence over integers modulo a fixed base, and the lagged Fibonacci generator uses delayed terms of the state to define each next term. Specifically, for a base $b \\in \\mathbb{N}$ with $b \\ge 2$, lags $r,s \\in \\mathbb{N}$ with $r > s \\ge 1$, and a state vector $(x_0,\\dots,x_{r-1})$ with each $x_i \\in \\{0,1,\\dots,b-1\\}$ together with a borrow bit $c_0 \\in \\{0,1\\}$, the subtract-with-borrow scheme defines sequences $(x_n)$ and $(c_n)$ by the requirement that for each $n \\ge r$, there exist unique $x_n \\in \\{0,1,\\dots,b-1\\}$ and $c_n \\in \\{0,1\\}$ satisfying the integer identity\n$$\nx_n - b \\, c_n \\;=\\; x_{n-r} \\;-\\; x_{n-s} \\;-\\; c_{n-1}.\n$$\nThe output at step $n$ is the floating-point number $u_n = x_n / b \\in [0,1)$.\n\nYour task is to:\n- Implement a single-step update function that, given integers $a \\in \\{0,\\dots,b-1\\}$, $d \\in \\{0,\\dots,b-1\\}$, and $c \\in \\{0,1\\}$, computes the pair $(x,c')$ such that $x \\in \\{0,\\dots,b-1\\}$, $c' \\in \\{0,1\\}$, and $x - b c' = a - d - c$ holds as an exact integer identity. The design must be correct even on fixed-width integer machines, by maintaining a borrow bit and avoiding any operation whose mathematical value would be negative before reduction; do not use any undefined behavior on underflow.\n- Implement an efficient generator with circular storage for the state of length $r$ that produces successive outputs $u_n$ for given parameters $(r,s,b)$ and initial state $(x_0,\\dots,x_{r-1},c_0)$.\n- Demonstrate and test a nontrivial invariant that can serve as an oracle for correctness: for each update, the exact integer identity $x - b c' = a - d - c$ must hold, together with the range invariants $x \\in \\{0,\\dots,b-1\\}$ and $c' \\in \\{0,1\\}$.\n\nDerive your algorithm starting only from the above definition and basic integer arithmetic. In particular, reason from the requirement that $x$ is the unique representative in the range $\\{0,1,\\dots,b-1\\}$ with an associated borrow bit $c' \\in \\{0,1\\}$ that restores the equality in the ring of integers. Your code should reflect a method that is robust against underflow in languages with fixed-width signed integers, by ensuring all intermediate operations are defined over the nonnegative integers. You must not assume any probabilistic distributional property of the generator beyond what is implied by the recurrence, and you must not rely on external libraries for pseudorandom numbers other than the standard library.\n\nTest Suite and Answer Specification:\nImplement the following test cases and aggregate their results exactly in the order specified below. All parameters, inputs, and outputs are purely numeric, and no physical units apply.\n\n- Test A (Edge borrow updates at a small base). Let $b_e = 97$. For each of the following four triples $(a,d,c)$, compute the update $(x,c')$ and check the expected outcome:\n  1. $(a,d,c) = (0, b_e - 1, 1)$ should yield $(x,c') = (0,1)$.\n  2. $(a,d,c) = (b_e - 1, 0, 0)$ should yield $(x,c') = (b_e - 1,0)$.\n  3. $(a,d,c) = (b_e - 1, b_e - 1, 1)$ should yield $(x,c') = (b_e - 1,1)$.\n  4. $(a,d,c) = (0, 0, 0)$ should yield $(x,c') = (0,0)$.\n  For each case, produce a boolean indicating whether the computed $(x,c')$ equals the expected pair.\n\n- Test B (Randomized identity check). Fix $b = 2^{24}$. Using a deterministic pseudorandom source seeded to $42$, draw $N = 1000$ independent triples $(A_i,D_i,C_i)$ with $A_i$ and $D_i$ uniformly from $\\{0,\\dots,b-1\\}$ and $C_i$ uniformly from $\\{0,1\\}$. For each triple, compute $(X_i,C_i')$ via your update and verify the identity $X_i - b C_i' = A_i - D_i - C_i$. Report two quantities: a boolean that is true if and only if all $N$ checks pass, and the integer count of passing checks.\n\n- Test C (Full generator with classical parameters and invariant verification). Use $b = 2^{24}$, $r = 24$, $s = 10$. Initialize the state $(x_0,\\dots,x_{r-1})$ by transforming outputs of a linear congruential generator with modulus $2^{32}$, multiplier $1664525$, increment $1013904223$, and initial seed $123456789$: let $Y_0 = 123456789$ and for $i \\in \\{0,1,\\dots,r-1\\}$, update $Y_{i+1} = (1664525 \\cdot Y_i + 1013904223) \\bmod 2^{32}$ and set $x_i = \\left\\lfloor \\dfrac{Y_{i+1} \\, b}{2^{32}} \\right\\rfloor$. Set $c_0 = 0$. Run the generator for $N = 10000$ steps to produce $u_n = x_n / b$ for $n \\in \\{r,\\dots,r+N-1\\}$. During the run, verify at every update the exact identity $x_n - b c_n = x_{n-r} - x_{n-s} - c_{n-1}$ and the range invariants $x_n \\in \\{0,\\dots,b-1\\}$ and $c_n \\in \\{0,1\\}$. Report two results: a boolean that is true if and only if all invariants hold for all $N$ updates, and the empirical mean $\\frac{1}{N} \\sum_{k=0}^{N-1} u_{r+k}$ as a floating-point number.\n\n- Test D (Small-parameter stress test). Use $b = 7$, $r = 5$, $s = 2$. Initialize by $x_i = (i^3 + 1) \\bmod b$ for $i \\in \\{0,1,2,3,4\\}$ and $c_0 = 0$. Run $N = 2000$ steps as in Test C. Report two results: a boolean that is true if and only if the invariants hold for all $N$ updates, and the empirical mean $\\frac{1}{N} \\sum_{k=0}^{N-1} u_{r+k}$ as a floating-point number.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n- Four booleans for Test A in the order listed above.\n- One boolean for Test B indicating whether all checks passed.\n- One integer giving the count of passing checks in Test B.\n- One boolean for Test C indicating that all invariants held.\n- One floating-point number giving the empirical mean in Test C.\n- One boolean for Test D indicating that all invariants held.\n- One floating-point number giving the empirical mean in Test D.\n\nFor clarity, the output must thus be a list with $10$ entries: $[A_1,A_2,A_3,A_4,B_{\\mathrm{all}},B_{\\mathrm{count}},C_{\\mathrm{ok}},C_{\\mathrm{mean}},D_{\\mathrm{ok}},D_{\\mathrm{mean}}]$. The program must be self-contained, accept no input, and use no external files or network access.",
            "solution": "The problem statement has been validated and is deemed a sound, well-posed, and objective exercise in computational science. It accurately describes the subtract-with-borrow (SWB) lagged Fibonacci generator, a standard algorithm for pseudorandom number generation, and specifies a set of precise, verifiable test cases. The problem is scientifically grounded, complete, and devoid of ambiguity. I will now proceed with a complete solution.\n\nThe core of the problem is to implement the recurrence relation for the SWB generator. Given a base $b \\in \\mathbb{N}$ ($b \\ge 2$), lags $r, s \\in \\mathbb{N}$ ($r > s \\ge 1$), a state vector $(x_0, \\dots, x_{r-1})$ with $x_i \\in \\{0, \\dots, b-1\\}$, and an initial borrow bit $c_0 \\in \\{0, 1\\}$, the generator produces sequences $(x_n)_{n \\ge r}$ and $(c_n)_{n \\ge r}$ defined by the integer identity for each $n \\ge r$:\n$$\nx_n - b c_n = x_{n-r} - x_{n-s} - c_{n-1}\n$$\nwhere $x_n \\in \\{0, \\dots, b-1\\}$ and $c_n \\in \\{0, 1\\}$ are unique. The output variate is $u_n = x_n/b$.\n\nOur task decomposes into three parts: deriving a robust single-step update function, designing an efficient generator that uses this function, and implementing the specified test suite to validate the implementation.\n\n**1. Derivation of the Single-Step Update Function**\n\nThe fundamental operation is a single update step. Let $a, d \\in \\{0, \\dots, b-1\\}$ and $c \\in \\{0, 1\\}$ be the inputs, corresponding to $x_{n-r}$, $x_{n-s}$, and $c_{n-1}$ respectively. We must find the unique pair $(x, c')$ with $x \\in \\{0, \\dots, b-1\\}$ and $c' \\in \\{0, 1\\}$ satisfying the identity:\n$$\nx - b c' = a - d - c\n$$\nLet $T = a - d - c$. The problem is to find a representation of the integer $T$ in the form $x - b c'$. This is analogous to finding the remainder and quotient, but with specific constraints on the 'quotient' $c'$. The range of the inputs implies that $T$ is in the range $[0 - (b-1) - 1, (b-1) - 0 - 0]$, which is $[-b, b-1]$.\n\nWe analyze two cases based on the sign of $T$:\n- **Case 1: $T \\ge 0$**. Since the maximum value of $T$ is $b-1$, $T$ is already in the required range for $x$. We can choose $c' = 0$, which gives $x = T = a - d - c$. This satisfies $x \\in \\{0, \\dots, b-1\\}$ and $c' \\in \\{0, 1\\}$.\n- **Case 2: $T  0$**. To bring the value into the range $\\{0, \\dots, b-1\\}$, we must add a multiple of $b$. Choosing $c'=0$ would leave $x=T0$, which is invalid. We must choose $c'=1$. This gives $x - b(1) = T$, so $x = T+b$. Since the minimum value of $T$ is $-b$, the resulting $x$ is in the range $[-b+b, -1+b] = [0, b-1]$, which is the required range.\n\nThis case analysis provides a complete and correct mathematical rule:\n$$\n(x, c') =\n\\begin{cases}\n(a-d-c, 0)  \\text{if } a - d - c \\ge 0 \\\\\n(a-d-c+b, 1)  \\text{if } a - d - c  0\n\\end{cases}\n$$\nThe problem demands an implementation that is robust on fixed-width integer machines, avoiding operations that yield mathematically negative values. The condition $a - d - c  0$ is equivalent to $a  d+c$. A direct computation of $d+c$ could overflow if, for instance, $d$ is the maximum value for its integer type. A safer method to evaluate this condition is to split it: `if (c == 0) { return a  d; } else { return a = d; }`.\n\nSimilarly, the calculation of $x$ must be handled carefully. If a borrow occurs ($a-d-c0$), $x$ is $a-d-c+b$. This can be reordered as $(a+b)-d-c$. This avoids negative intermediate values, but care must be taken that $a+b$ does not overflow the integer type. In Python, which supports arbitrary-precision integers, these fixed-width concerns are moot. We can implement the logic directly and correctly as `val = a - d - c`, and then check if `val  0`. This is the most transparent expression of the underlying mathematics.\n\n**2. Design of the Generator**\n\nThe generator must maintain a state of the last $r$ values, $(x_{n-r}, \\dots, x_{n-1})$. A circular buffer of size $r$ is an efficient data structure for this purpose. We implement this using a standard array (or `numpy` array) and two pointers, $i$ and $j$, that traverse the array circularly.\n- The state array, `state`, is initialized with $(x_0, \\dots, x_{r-1})$.\n- Pointer $i$ tracks the location of $x_{n-r}$ (the oldest value).\n- Pointer $j$ tracks the location of $x_{n-s}$.\n- Initially, for the first step ($n=r$), we need $x_0$ and $x_{r-s}$. So we initialize $i=0$ and $j=r-s$.\n- In each step:\n    1. Retrieve $a = \\text{state}[i]$ and $d = \\text{state}[j]$.\n    2. Use the current borrow bit $c$ and apply the `update` function to get the new value $x_{\\text{new}}$ and new borrow bit $c_{\\text{new}}$.\n    3. Overwrite the oldest value in the state: $\\text{state}[i] = x_{\\text{new}}$.\n    4. Update the generator's borrow bit to $c_{\\text{new}}$.\n    5. Advance the pointers for the next step: $i = (i+1) \\pmod r$ and $j = (j+1) \\pmod r$.\nThis two-pointer mechanism correctly cycles through the state, ensuring that the correct historical values are used for each new term.\n\n**3. Test Suite Implementation**\n\nThe provided test cases are implemented as follows:\n- **Test A:** Verifies the `update` function on four specific boundary cases using base $b_e=97$. Each case is a direct call to the update function, and the result is compared to the expected output.\n- **Test B:** A randomized stress test for the `update` function's correctness invariant. For $b=2^{24}$, $N=1000$ random triples $(A_i, D_i, C_i)$ are generated. For each, the update $(X_i, C'_i)$ is computed and the fundamental identity $X_i - b C'_i = A_i - D_i - C_i$ is checked using exact integer arithmetic.\n- **Test C:** A full run of the generator with classical parameters $b=2^{24}$, $r=24$, $s=10$. The initial state is seeded from a Linear Congruential Generator (LCG). The LCG recurrence is $Y_{k+1} = (1664525 \\cdot Y_k + 1013904223) \\pmod{2^{32}}$. The state values are $x_k = \\lfloor Y_{k+1} \\cdot b / 2^{32} \\rfloor$. Since $b=2^{24}$ and the modulus is $2^{32}$, this simplifies to a computationally efficient bit-shift: $x_k = Y_{k+1} \\gg 8$. The generator runs for $N=10000$ steps, and at each step, the correctness invariant ($x_n - b c_n = x_{n-r} - x_{n-s} - c_{n-1}$) and range invariants ($x_n \\in \\{0, \\dots, b-1\\}, c_n \\in \\{0, 1\\}$) are checked. The empirical mean of the output variates is computed.\n- **Test D:** A stress test with a small base ($b=7$) and small lags ($r=5, s=2$), which can reveal periodic behavior or flaws not apparent with large parameters. The initialization is by a simple polynomial rule $x_i = (i^3+1) \\pmod b$. The process is otherwise identical to Test C, running for $N=2000$ steps.\n\nThe implementation combines these components into a single, self-contained program that produces the specified output format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates a subtract-with-borrow lagged Fibonacci generator.\n    \"\"\"\n\n    def update(a, d, c, b):\n        \"\"\"\n        Computes a single step of the subtract-with-borrow recurrence.\n\n        Given a, d in {0..b-1} and c in {0,1}, computes (x, c') such that\n        x in {0..b-1}, c' in {0,1}, and the integer identity x - b*c' = a - d - c holds.\n\n        This implementation is directly based on the mathematical definition and is\n        safe in Python due to its arbitrary-precision integers. For fixed-width\n        integer architectures, care would be needed to check for borrow conditions\n        and perform calculations without causing underflow/overflow, as discussed\n        in the solution text.\n        \"\"\"\n        val = a - d - c\n        if val  0:\n            c_prime = 1\n            x = val + b\n        else:\n            c_prime = 0\n            x = val\n        return int(x), int(c_prime)\n\n    # --- Test A ---\n    b_e = 97\n    test_cases_A = [\n        ((0, b_e - 1, 1), (0, 1)),\n        ((b_e - 1, 0, 0), (b_e - 1, 0)),\n        ((b_e - 1, b_e - 1, 1), (b_e - 1, 1)),\n        ((0, 0, 0), (0, 0)),\n    ]\n    results_A = []\n    for params, expected in test_cases_A:\n        computed = update(params[0], params[1], params[2], b_e)\n        results_A.append(computed == expected)\n    \n    # --- Test B ---\n    b_B = 2**24\n    N_B = 1000\n    seed_B = 42\n    \n    rand_state = np.random.RandomState(seed_B)\n    A_vals = rand_state.randint(0, b_B, size=N_B, dtype=np.int64)\n    D_vals = rand_state.randint(0, b_B, size=N_B, dtype=np.int64)\n    C_vals = rand_state.randint(0, 2, size=N_B, dtype=np.int64)\n\n    passing_checks_B = 0\n    for i in range(N_B):\n        A, D, C = A_vals[i], D_vals[i], C_vals[i]\n        X, C_prime = update(A, D, C, b_B)\n        if (X - b_B * C_prime) == (A - D - C):\n            passing_checks_B += 1\n            \n    all_passed_B = (passing_checks_B == N_B)\n    results_B = [all_passed_B, passing_checks_B]\n\n    class SWBGenerator:\n        \"\"\"Subtract-with-borrow lagged Fibonacci generator.\"\"\"\n        def __init__(self, r, s, b, x_initial, c_initial):\n            if not (r > s >= 1):\n                raise ValueError(\"Lags must satisfy r > s >= 1\")\n            \n            self.r, self.s, self.b = r, s, b\n            # Use np.int64 to be safe with b=2^24, though Python's default int is sufficient.\n            self.state = np.array(x_initial, dtype=np.int64)\n            self.c = c_initial\n            \n            # Pointers for circular buffer access\n            self.p_i = 0  # Pointer for x_{n-r}\n            self.p_j = r - s  # Pointer for x_{n-s}\n\n        def step(self):\n            \"\"\"Performs one step of the generator and returns values for verification.\"\"\"\n            a = self.state[self.p_i]\n            d = self.state[self.p_j]\n            c_prev = self.c\n            \n            x_new, c_new = update(a, d, c_prev, self.b)\n            \n            self.state[self.p_i] = x_new\n            self.c = c_new\n            \n            self.p_i = (self.p_i + 1) % self.r\n            self.p_j = (self.p_j + 1) % self.r\n\n            u_new = x_new / self.b\n            \n            return u_new, x_new, c_new, a, d, c_prev\n\n    # --- Test C ---\n    b_C, r_C, s_C = 2**24, 24, 10\n    N_C = 10000\n    \n    # Initialize state with LCG\n    lcg_mod = 2**32\n    lcg_mult = 1664525\n    lcg_inc = 1013904223\n    y = 123456789\n    \n    x_initial_C = []\n    for _ in range(r_C):\n        y = (lcg_mult * y + lcg_inc)  (lcg_mod - 1)\n        # x_i = floor(y * b / 2^32) = y >> 8\n        x_i = y >> 8\n        x_initial_C.append(x_i)\n        \n    gen_C = SWBGenerator(r_C, s_C, b_C, x_initial_C, c_initial=0)\n    \n    sum_u_C = 0.0\n    invariants_hold_C = True\n    for _ in range(N_C):\n        u, x, c_new, a, d, c_prev = gen_C.step()\n        sum_u_C += u\n        \n        # Invariant checks\n        identity_holds = (x - b_C * c_new) == (a - d - c_prev)\n        range_holds = (0 = x  b_C) and (c_new in [0, 1])\n        if not (identity_holds and range_holds):\n            invariants_hold_C = False\n            \n    mean_C = sum_u_C / N_C\n    results_C = [invariants_hold_C, mean_C]\n\n    # --- Test D ---\n    b_D, r_D, s_D = 7, 5, 2\n    N_D = 2000\n\n    x_initial_D = [(i**3 + 1) % b_D for i in range(r_D)]\n    gen_D = SWBGenerator(r_D, s_D, b_D, x_initial_D, c_initial=0)\n    \n    sum_u_D = 0.0\n    invariants_hold_D = True\n    for _ in range(N_D):\n        u, x, c_new, a, d, c_prev = gen_D.step()\n        sum_u_D += u\n\n        # Invariant checks\n        identity_holds = (x - b_D * c_new) == (a - d - c_prev)\n        range_holds = (0 = x  b_D) and (c_new in [0, 1])\n        if not (identity_holds and range_holds):\n            invariants_hold_D = False\n\n    mean_D = sum_u_D / N_D\n    results_D = [invariants_hold_D, mean_D]\n\n    # Combine all results and format output\n    final_results = results_A + results_B + results_C + results_D\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "High-quality random number streams should exhibit no discernible patterns, yet simple recurrences can hide deep-seated structural regularities. This final practice moves from implementation to theoretical analysis, guiding you to uncover a deterministic flaw inherent in additive LFGs. You will use first-principles reasoning to demonstrate that the output of an additive generator is not truly uniform, but is instead constrained to a small number of hyperplanes in multidimensional space . By deriving the exact, maximal bias for a carefully chosen test function, you will gain a powerful insight into why seemingly random sequences can fail critical tests of dimensionality and independence.",
            "id": "3316692",
            "problem": "Consider a Lagged Fibonacci Generator (LFG) defined over the modulus $2^{w}$ by the additive recurrence\n$$\nX_{n} = \\big(X_{n-j} + X_{n-k}\\big)\\bmod 2^{w},\n$$\nwith fixed lags $j>k\\geq 1$, integer word size $w\\geq 2$, and normalized outputs $U_{n} = X_{n}/2^{w}\\in [0,1)$ used in Monte Carlo (MC) simulation. Work under the usual stochastic simulation convention that an ideal random number source would provide independent and identically distributed (i.i.d.) samples uniformly distributed on $[0,1)$ in every dimension.\n\nStarting from the recurrence and the definition of the modulo operation, use first-principles reasoning in modular arithmetic to identify the deterministic geometric constraint satisfied by the triples $(U_{n},U_{n-j},U_{n-k})$ generated by the LFG. Then, construct a three-dimensional lattice test function $f(U_{n},U_{n-j},U_{n-k})$ that is sensitive to this constraint and produces a deterministic bias when evaluated on the LFG outputs, while having zero expectation under the i.i.d. uniform model.\n\nFor concreteness and to ensure a uniquely defined quantity, take your lattice test function to be the nontrivial Fourier character\n$$\nf(U_{n},U_{n-j},U_{n-k}) \\;=\\; \\exp\\!\\Big(2\\pi i\\big(U_{n} - U_{n-j} - U_{n-k}\\big)\\Big),\n$$\nwhere $i$ denotes the imaginary unit. Define the bias $B$ to be the difference between the expectation of $f$ under the LFG and its expectation under three i.i.d. $\\mathrm{Uniform}(0,1)$ variables:\n$$\nB \\;=\\; \\mathbb{E}_{\\text{LFG}}\\!\\big[f(U_{n},U_{n-j},U_{n-k})\\big] \\;-\\; \\mathbb{E}_{\\text{iid}}\\!\\big[f(U_{n},U_{n-j},U_{n-k})\\big].\n$$\n\nDerive $B$ exactly from the recurrence and modular arithmetic alone, and explain the mechanism that causes the deterministic bias. Your final answer must be the exact value of $B$. No rounding is required.",
            "solution": "The problem requires the derivation of the bias $B$ for a specific statistical test function applied to a Lagged Fibonacci Generator (LFG). The bias $B$ is defined as the difference between the expectation of the test function under the LFG's output distribution and its expectation under an ideal distribution of independent and identically distributed (i.i.d.) uniform random variables.\n$$\nB \\;=\\; \\mathbb{E}_{\\text{LFG}}\\!\\big[f(U_{n},U_{n-j},U_{n-k})\\big] \\;-\\; \\mathbb{E}_{\\text{iid}}\\!\\big[f(U_{n},U_{n-j},U_{n-k})\\big]\n$$\nwhere the test function is\n$$\nf(U_{n},U_{n-j},U_{n-k}) \\;=\\; \\exp\\!\\Big(2\\pi i\\big(U_{n} - U_{n-j} - U_{n-k}\\big)\\Big)\n$$\nWe will compute each expectation term separately.\n\nFirst, let us calculate the expectation under the ideal stochastic model, where the generator produces i.i.d. samples from a $\\mathrm{Uniform}(0,1)$ distribution. Let $V_{1}$, $V_{2}$, and $V_{3}$ be three independent random variables, each with a $\\mathrm{Uniform}(0,1)$ distribution. The expectation $\\mathbb{E}_{\\text{iid}}[f]$ is then given by:\n$$\n\\mathbb{E}_{\\text{iid}}[f] = \\mathbb{E}\\Big[\\exp\\big(2\\pi i (V_{1} - V_{2} - V_{3})\\big)\\Big]\n$$\nDue to the independence of $V_{1}$, $V_{2}$, and $V_{3}$, the expectation of the product of functions of these variables is the product of their individual expectations:\n$$\n\\mathbb{E}_{\\text{iid}}[f] = \\mathbb{E}\\big[\\exp(2\\pi i V_{1})\\big] \\cdot \\mathbb{E}\\big[\\exp(-2\\pi i V_{2})\\big] \\cdot \\mathbb{E}\\big[\\exp(-2\\pi i V_{3})\\big]\n$$\nEach term in this product is an instance of the characteristic function of a $\\mathrm{Uniform}(0,1)$ variable, $\\phi_{V}(t) = \\mathbb{E}[\\exp(itV)]$, evaluated at $t = \\pm 2\\pi$. For a general non-zero integer $s$, let's compute $\\mathbb{E}[\\exp(2\\pi i s V)]$ where $V \\sim \\mathrm{Uniform}(0,1)$:\n$$\n\\mathbb{E}[\\exp(2\\pi i s V)] = \\int_{0}^{1} \\exp(2\\pi i s v) \\, dv = \\left[ \\frac{\\exp(2\\pi i s v)}{2\\pi i s} \\right]_{v=0}^{v=1}\n$$\n$$\n= \\frac{\\exp(2\\pi i s) - \\exp(0)}{2\\pi i s}\n$$\nBy Euler's identity, $\\exp(2\\pi i s) = \\cos(2\\pi s) + i\\sin(2\\pi s)$. Since $s$ is a non-zero integer, $\\cos(2\\pi s) = 1$ and $\\sin(2\\pi s) = 0$, so $\\exp(2\\pi i s) = 1$. The expression becomes:\n$$\n= \\frac{1 - 1}{2\\pi i s} = 0\n$$\nIn our case, the terms correspond to $s=1$, $s=-1$, and $s=-1$, all of which are non-zero integers. Therefore, each expectation is $0$.\n$$\n\\mathbb{E}[\\exp(2\\pi i V_{1})] = 0, \\quad \\mathbb{E}[\\exp(-2\\pi i V_{2})] = 0, \\quad \\mathbb{E}[\\exp(-2\\pi i V_{3})] = 0\n$$\nConsequently, the expectation under the i.i.d. model is:\n$$\n\\mathbb{E}_{\\text{iid}}[f] = 0 \\cdot 0 \\cdot 0 = 0\n$$\nThis result is expected, as the test function is a Fourier character designed to have zero mean for a truly uniform distribution in the unit hypercube.\n\nNext, we calculate the expectation under the LFG model. The LFG is defined by the integer recurrence:\n$$\nX_{n} = \\big(X_{n-j} + X_{n-k}\\big)\\bmod 2^{w}\n$$\nwhere each $X_{m}$ is an integer in the set $\\{0, 1, \\dots, 2^w-1\\}$. The definition of the modulo operator implies that there exists an integer, let's call it $m_{n}$, such that:\n$$\nX_{n-j} + X_{n-k} = m_{n} \\cdot 2^{w} + X_{n}\n$$\nSince $0 \\leq X_{n-j}  2^w$ and $0 \\leq X_{n-k}  2^w$, the sum $X_{n-j} + X_{n-k}$ satisfies $0 \\leq X_{n-j} + X_{n-k} \\leq 2(2^w-1) = 2^{w+1}-2$. The term $m_n$ accounts for the \"wrap-around\" effect of the modular arithmetic. From the equation $m_n 2^w = (X_{n-j} + X_{n-k}) - X_n$, and given the ranges of the $X$ variables, the integer $m_n$ can only take the values $0$ or $1$. Specifically, $m_n=0$ if $X_{n-j} + X_{n-k}  2^w$ and $m_n=1$ if $X_{n-j} + X_{n-k} \\geq 2^w$.\n\nThe normalized outputs $U_n$ are defined as $U_n = X_n / 2^w$. We can translate the integer recurrence into a relation for the normalized outputs by dividing the equation by $2^w$:\n$$\n\\frac{X_{n-j}}{2^{w}} + \\frac{X_{n-k}}{2^{w}} = m_{n} \\cdot \\frac{2^{w}}{2^{w}} + \\frac{X_{n}}{2^{w}}\n$$\nSubstituting the definitions of $U_n$, this becomes:\n$$\nU_{n-j} + U_{n-k} = m_{n} + U_{n}\n$$\nThis equation reveals the deterministic geometric constraint satisfied by any triple $(U_n, U_{n-j}, U_{n-k})$ generated by the LFG. Rearranging the terms, we find:\n$$\nU_{n} - U_{n-j} - U_{n-k} = -m_{n}\n$$\nThis expression is precisely the argument of the complex exponential in the test function $f$. We can now evaluate $f$ for any output of the LFG:\n$$\nf(U_{n},U_{n-j},U_{n-k}) = \\exp\\Big(2\\pi i \\big(U_{n} - U_{n-j} - U_{n-k}\\big)\\Big) = \\exp\\big(2\\pi i (-m_{n})\\big)\n$$\nSince $m_{n}$ is always an integer ($0$ or $1$), the value of $\\exp(-2\\pi i m_{n})$ is always $1$, because $\\exp(-2\\pi i \\cdot 0) = 1$ and $\\exp(-2\\pi i \\cdot 1) = 1$.\nThis means that for every triple of values generated by the LFG, the test function deterministically evaluates to exactly $1$.\n$$\nf(U_{n},U_{n-j},U_{n-k}) = 1\n$$\nThe expectation of a constant value is that constant itself. Therefore, the expectation under the LFG model is:\n$$\n\\mathbb{E}_{\\text{LFG}}[f] = \\mathbb{E}_{\\text{LFG}}[1] = 1\n$$\nThe mechanism for the bias is thus the rigid algebraic structure of the LFG. The additive recurrence over integers forces the normalized outputs to lie on a small set of parallel hyperplanes (in this case, two planes defined by $u_n-u_{n-j}-u_{n-k}=0$ and $u_n-u_{n-j}-u_{n-k}=-1$). The chosen test function, being a Fourier character corresponding to this planar structure, is maximally sensitive to this deviation from uniformity and produces a constant, non-random output.\n\nFinally, we can compute the bias $B$:\n$$\nB = \\mathbb{E}_{\\text{LFG}}[f] - \\mathbb{E}_{\\text{iid}}[f] = 1 - 0 = 1\n$$\nThe bias is $1$, which signifies a complete failure of the LFG under this test and a total breakdown of the assumption of independence and uniformity for the triples $(U_n, U_{n-j}, U_{n-k})$.",
            "answer": "$$\n\\boxed{1}\n$$"
        }
    ]
}