{
    "hands_on_practices": [
        {
            "introduction": "创建独立的并行随机数流是并行蒙特卡洛模拟成功的关键。一种常见的方法是将一个长周期生成器分割成不重叠的子序列。本练习将引导你为线性同余生成器（LCG）推导并实现核心的“跳跃”（skip-ahead）算法，该算法能让你高效地从序列中的任意一点跳转到遥远的未来点，从而为构建独立的并行流奠定基础。",
            "id": "3338260",
            "problem": "考虑由递推关系 $x_{k+1} = (a x_k + c) \\bmod m$ 定义的线性同余生成器 (LCG)，其状态空间为 $\\{0,1,\\dots,m-1\\}$，其中 $m = 2^{48}$，$a = 25214903917$，$c = 11$。在随机模拟和蒙特卡洛方法 (MC) 中，通过确定性的跳步（skip-ahead）来实现种子初始化和流的独立性，以便可以从单个生成器构造出多个在指定窗口内不重叠的独立子流。\n\n从以下基本原理出发：\n- LCG 递推关系 $x_{k+1} = (a x_k + c) \\bmod m$ 定义了环 $\\mathbb{Z}/m\\mathbb{Z}$ 上的一个仿射映射 $f(x) = (a x + c) \\bmod m$。\n- 仿射映射的复合运算具有结合律和封闭性：如果 $f(x) = (A x + C) \\bmod m$ 和 $g(x) = (B x + D) \\bmod m$，那么 $g \\circ f$ 也是 $\\mathbb{Z}/m\\mathbb{Z}$ 上的一个仿射映射。\n- 二进制幂（也称为快速幂）将重复的复合运算次数减少到 $O(\\log t)$ 次。\n\n你的任务是：\n1. 从第一性原理出发，推导出一个算法，该算法使用仿射映射在模 $m$ 下的二进制幂运算，从给定的 $x_n$ 计算任意非负整数 $t$ 对应的 $x_{n+t}$。将你的推导特化至 $t = 10^{12}$ 的情况，并展示如何在不迭代递推关系 $10^{12}$ 次，且不需求解在 $\\mathbb{Z}/2^{48}\\mathbb{Z}$ 中可能不存在的模逆元的情况下，计算出 $x_{n+10^{12}}$。\n2. 分析你的算法关于 $t$ 的时间和空间复杂度，并讨论这如何支持在蒙特卡洛模拟中通过跳步实现流的独立性。\n3. 在一个完整的、可运行的程序中实现该算法，并将其应用于以下测试套件。每个测试用例产生一个布尔值或整数结果：\n   - 测试 1 (与朴素迭代法对比的正确性)：设 $x_n = 42$ 且 $t = 1000$。分别通过你的跳步算法和直接迭代 LCG 计算 $x_{n+t}$，并返回一个布尔值，表示两个结果是否相等。\n   - 测试 2 (单位元边界情况)：设 $x_n = 1234567890123$ 且 $t = 0$。计算并返回 $x_{n+t}$ 的整数值。\n   - 测试 3 (单步边界情况)：设 $x_n = 1$ 且 $t = 1$。计算并返回 $x_{n+t}$ 的整数值。\n   - 测试 4 (从零开始的大步长跳跃)：设 $x_n = 0$ 且 $t = 10^{12}$。计算并返回 $x_{n+t}$ 的整数值。\n   - 测试 5 (在一个窗口内的经验性子流独立性)：使用步长 $S = 10^{12}$ 定义两个子流。设初始种子为 $x_0 = 1234567890123$，通过你的跳步算法定义第二个种子为 $x_0' = x_{0+S}$，然后通过直接迭代生成每个子流的前 $L = 1000$ 个状态。返回一个布尔值，表示两个子流的前 $L$ 个状态集合是否不相交。\n\n你的程序应产生单行输出，其中包含一个由逗号分隔并用方括号括起来的测试结果列表（例如，\"[result1,result2,result3,result4,result5]\"）。不涉及任何物理单位或角度；所有量都是在指定环算术中的纯整数或布尔值。",
            "solution": "该问题要求推导、分析并实现一个高效算法，以便在给定起始状态 $x_n$ 的情况下，计算线性同余生成器 (LCG) 在 $t$ 步之后的状态 $x_{n+t}$，而无需执行 $t$ 次迭代。这种技术被称为跳步 (skip-ahead) 或前向跳转 (jump-ahead)。\n\nLCG 由以下递推关系定义：\n$$x_{k+1} = (a x_k + c) \\bmod m$$\n参数为 $m = 2^{48}$，$a = 25214903917$ 和 $c = 11$。\n\n### 1. 跳步算法的推导\n\n核心原理是将 LCG 递推关系表示为仿射变换的重复应用，然后使用高效算法计算该变换的 $t$ 次幂。\n\n**步骤 1：将 LCG 形式化为仿射映射**\n递推关系 $x_{k+1} = (ax_k + c) \\pmod m$ 可以表示为将函数 $f$ 应用于状态 $x_k$：\n$$x_{k+1} = f(x_k)$$\n其中 $f(x) = (ax + c) \\pmod m$。这是一个在模 $m$ 整数环 $\\mathbb{Z}/m\\mathbb{Z}$ 上的仿射变换。\n要找到 $t$ 步之后的状态 $x_{n+t}$，我们必须将映射 $f$ 对初始状态 $x_n$ 应用总共 $t$ 次：\n$$x_{n+t} = f(f(\\dots f(x_n)\\dots)) = f^t(x_n)$$\n\n**步骤 2：仿射映射复合的代数**\n让我们分析两个此类仿射映射的复合。考虑两个映射，$g(x) = (A'x + C') \\pmod m$ 和 $h(x) = (Ax + C) \\pmod m$。它们的复合 $(g \\circ h)(x)$ 是：\n$$(g \\circ h)(x) = g(h(x)) = A'(Ax + C) + C' = (A'A)x + (A'C + C') \\pmod m$$\n两个仿射映射的复合是另一个仿射映射。我们可以对系数对 $(A, C)$ 定义一个复合运算。如果 $g$ 对应于系数对 $(A', C')$，$h$ 对应于 $(A, C)$，则它们的复合 $g \\circ h$ 对应于一个新的系数对：\n$$(A', C') \\circ (A, C) = (A'A \\pmod m, (A'C + C') \\pmod m)$$\n这个复合运算具有结合律，这是进行幂运算的一个关键性质。\n\n暴力计算 $x_{n+t}$ 的方法是 $f^t(x_n)$，这在计算上是昂贵的。通过归纳法可以找到一个更直接的公式：\n$$x_{n+1} = ax_n + c$$\n$$x_{n+2} = a(ax_n+c)+c = a^2x_n + ac+c$$\n$$x_{n+3} = a(a^2x_n+ac+c)+c = a^3x_n + a^2c+ac+c$$\n$x_{n+t}$ 的一般形式是：\n$$x_{n+t} = \\left(a^t x_n + c \\sum_{i=0}^{t-1} a^i\\right) \\pmod m$$\n其中的和是一个几何级数，其闭式解为 $\\sum_{i=0}^{t-1} a^i = \\frac{a^t-1}{a-1}$。使用这个公式，我们会得到：\n$$x_{n+t} = \\left(a^t x_n + c \\frac{a^t-1}{a-1}\\right) \\pmod m$$\n这个公式需要除以 $a-1$，这意味着我们需要找到 $(a-1) \\pmod m$ 的模乘法逆元。对于 $m=2^{48}$ 和 $a=25214903917$，$a-1=25214903916$，这是一个偶数。由于 $m$ 也是偶数，$\\gcd(a-1, m) \\neq 1$，因此 $(a-1) \\pmod{2^{48}}$ 的模逆元不存在。因此，正如问题陈述中正确指出的那样，这种方法对于给定的参数是无效的。\n\n**步骤 3：仿射映射的二进制幂运算**\n避免使用模逆元的有效方法是，使用复合规则和二进制幂（也称为快速幂）来计算复合映射 $f^t(x) = (A_t x + C_t) \\pmod m$ 的系数。\n\n目标是计算表示 $f^t$ 的系数对 $(A_t, C_t)$。这等同于在复合运算下，计算由其系数对 $(a, c)$ 表示的映射 $f$ 的 $t$ 次幂。\n\n计算 $(A_t, C_t) = (a, c)^t$ 的算法如下：\n设 $t$ 的二进制表示为 $t = \\sum_{i=0}^k b_i 2^i$，其中 $b_i \\in \\{0, 1\\}$。那么 $f^t = \\prod_{i: b_i=1} f^{2^i}$。我们可以迭代地计算这个乘积。\n\n1.  **初始化**：\n    单位映射是 $id(x) = 1 \\cdot x + 0$，所以其系数对是 $(1, 0)$。这将是我们用于最终结果的累加器。\n    设 $(A_{res}, C_{res}) = (1, 0)$。\n    基础映射是 $f^1$，对应于系数对 $(a, c)$。\n    设 $(A_{base}, C_{base}) = (a, c)$。\n\n2.  **迭代**：我们从最低有效位到最高有效位处理 $t$ 的二进制位。\n    当 $t > 0$ 时：\n    a. 如果 $t$ 当前的最低有效位是 $1$，我们将累加结果与当前的基础映射进行复合：\n       $(A_{res}, C_{res}) \\leftarrow (A_{base}, C_{base}) \\circ (A_{res}, C_{res})$。根据复合规则，这变为：\n       - $A_{res, new} = (A_{base} \\cdot A_{res}) \\pmod m$\n       - $C_{res, new} = (A_{base} \\cdot C_{res} + C_{base}) \\pmod m$\n    b. 我们将基础映射自乘（平方）来为下一位做准备，因为 $f^{2^{i+1}} = f^{2^i} \\circ f^{2^i}$：\n       $(A_{base}, C_{base}) \\leftarrow (A_{base}, C_{base}) \\circ (A_{base}, C_{base})$。这变为：\n       - $A_{base, new} = (A_{base} \\cdot A_{base}) \\pmod m$\n       - $C_{base, new} = (A_{base} \\cdot C_{base} + C_{base}) \\pmod m$\n    c. 我们通过右移操作丢弃 $t$ 已处理的位：$t \\leftarrow t \\gg 1$。\n\n3.  **最终确定**：\n    循环结束后，系数对 $(A_{res}, C_{res})$ 将是 $(A_t, C_t)$。\n    最终状态 $x_{n+t}$ 随后通过将此映射应用于 $x_n$ 来计算：\n    $$x_{n+t} = (A_t \\cdot x_n + C_t) \\pmod m$$\n该算法仅使用模乘和模加来计算结果，无需使用逆元。对于 $t = 10^{12}$，此算法极其高效，因为迭代次数与 $\\log_2(10^{12})$ 成正比。\n\n### 2. 复杂度分析及其在流独立性中的应用\n\n**时间复杂度**\n二进制幂算法大约迭代 $\\log_2 t$ 次。在每次迭代内部，执行固定数量的模乘和模加来完成两个复合操作。所涉及的数值以 $m$ 为界，对于固定的 $m$，这些算术运算耗时为常数。因此，计算系数 $(A_t, C_t)$ 的时间复杂度是 $O(\\log t)$。在计算出系数后，应用一次映射需要一次乘法和一次加法，这是一个 $O(1)$ 的操作。因此，跳步算法的总体时间复杂度是 $O(\\log t)$。\n\n**空间复杂度**\n该算法需要固定数量的变量来存储累加器和基础映射的系数，以及输入参数。内存使用量不随 $t$ 变化。因此，空间复杂度是 $O(1)$。\n\n**支持蒙特卡洛模拟中的流独立性**\n在并行蒙特卡洛模拟中，至关重要的是 $P$ 个并行进程中的每一个都生成一个与其他进程统计上独立的随机数序列。单个 LCG 产生一个长状态序列。一种创建独立“子流”的稳健方法是划分这个主序列。\n\n我们可以为进程 $i$（其中 $i \\in \\{0, 1, \\dots, P-1\\}$）分配一个从种子 $x_S^{(i)} = x_{i \\cdot S}$ 开始的子流，其中 $S$ 是一个非常大的跳跃距离或步长。例如，我们可以选择 $S=10^{12}$。\n- 进程 $0$ 从 $x_0$ 开始。\n- 进程 $1$ 从 $x_S$ 开始，通过计算 $f^S(x_0)$ 得到。\n- 进程 $2$ 从 $x_{2S}$ 开始，通过计算 $f^S(x_S)$ 得到。\n- 依此类推，进程 $i$ 从 $x_{iS} = f^S(x_{(i-1)S})$ 开始。\n\n所推导的具有 $O(\\log S)$ 时间复杂度的跳步算法是实现该方法的使能技术。即使对于像 $S=10^{12}$ 这样的巨大步长，计算每个进程的起始种子也几乎是瞬时完成的。没有这个算法，计算 $x_{i \\cdot S}$ 将需要 $i \\cdot S$ 次迭代，这在计算上是不可行的，并且会使并行的目的落空。\n\n通过选择一个远大于任何单个进程将消耗的随机变量数量的 $S$，我们可以确保不同进程使用的子流不重叠，从而为其统计独立性提供了实际的保证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LCG skip-ahead problem by implementing the algorithm derived from\n    first principles and running the specified test cases.\n    \"\"\"\n    # Parameters of the LCG from the problem statement\n    m = 2**48\n    a = 25214903917\n    c = 11\n    # For m=2**k, modulo can be done with a bitwise AND, which is faster.\n    mask = m - 1\n\n    def power_map(t: int, a_base: int, c_base: int, mod_mask: int):\n        \"\"\"\n        Computes the coefficients (A_t, C_t) of the composed affine map f^t,\n        where f^t(x) = (A_t * x + C_t) mod m, using binary exponentiation.\n\n        The composition of g(x)=a1*x+c1 and h(x)=a2*x+c2 is g(h(x)) = (a1*a2)*x + (a1*c2+c1).\n        The corresponding operation on coefficient pairs is (a1, c1) o (a2, c2) -> (a1*a2, a1*c2+c1).\n        \"\"\"\n        if t == 0:\n            # Identity map: x -> 1*x + 0\n            return 1, 0\n\n        # Accumulator for the final map, initialized to identity.\n        final_a, final_c = 1, 0\n\n        # Current power of the base map, starts with f^1 = (a, c).\n        current_a, current_c = a_base, c_base\n        \n        power = t\n        while power > 0:\n            if power % 2 == 1:\n                # Accumulate this power: final_map - current_map o final_map\n                final_a, final_c = (\n                    (current_a * final_a)  mod_mask,\n                    (current_a * final_c + current_c)  mod_mask\n                )\n\n            # Square the current power map: current_map - current_map o current_map\n            current_a, current_c = (\n                (current_a * current_a)  mod_mask,\n                (current_a * current_c + current_c)  mod_mask\n            )\n            \n            power //= 2\n        \n        return final_a, final_c\n\n    def skip_ahead(x_n: int, t: int):\n        \"\"\"\n        Computes x_{n+t} from x_n by finding the composed map f^t and applying it.\n        \"\"\"\n        if t == 0:\n            return x_n\n        \n        A_t, C_t = power_map(t, a, c, mask)\n        return (A_t * x_n + C_t)  mask\n    \n    def lcg_step(x: int):\n        \"\"\"Performs a single step of the LCG.\"\"\"\n        return (a * x + c)  mask\n\n    results = []\n\n    # Test 1: correctness against naive iteration\n    x_n_1, t_1 = 42, 1000\n    res_skip_1 = skip_ahead(x_n_1, t_1)\n    res_iter_1 = x_n_1\n    for _ in range(t_1):\n        res_iter_1 = lcg_step(res_iter_1)\n    results.append(res_skip_1 == res_iter_1)\n\n    # Test 2: identity boundary (t=0)\n    x_n_2, t_2 = 1234567890123, 0\n    res_2 = skip_ahead(x_n_2, t_2)\n    results.append(res_2)\n\n    # Test 3: single-step boundary (t=1)\n    x_n_3, t_3 = 1, 1\n    res_3 = skip_ahead(x_n_3, t_3)\n    results.append(res_3)\n\n    # Test 4: large skip from zero\n    x_n_4, t_4 = 0, 10**12\n    res_4 = skip_ahead(x_n_4, t_4)\n    results.append(res_4)\n\n    # Test 5: empirical substream independence in a window\n    S_5 = 10**12\n    L_5 = 1000\n    x0_5 = 1234567890123\n    \n    # Generate first substream\n    stream1 = []\n    current_x1 = x0_5\n    for _ in range(L_5):\n        stream1.append(current_x1)\n        current_x1 = lcg_step(current_x1)\n        \n    # Find start of second substream and generate it\n    x0_prime_5 = skip_ahead(x0_5, S_5)\n    stream2 = []\n    current_x2 = x0_prime_5\n    for _ in range(L_5):\n        stream2.append(current_x2)\n        current_x2 = lcg_step(current_x2)\n\n    # Check for disjointness using sets for efficiency\n    set1 = set(stream1)\n    set2 = set(stream2)\n    results.append(set1.isdisjoint(set2))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了创建随机数流的技术后，我们必须验证它们的统计质量。本练习將对比两种并行化策略：“跳跃法”（skip-ahead）和通常有缺陷的“蛙跳法”（leapfrog splitting）。通过编程计算并比较两种方法下不同流之间的经验协方差，你将亲手揭示不当并行化方法引入的跨流相关性，从而深刻理解为何选择正确的流创建技术至关重要。",
            "id": "3338230",
            "problem": "您的任务是使用线性同余生成器（LCG）以编程方式诊断并行化伪随机数生成中的跨流相关性。LCG 由以下递推关系定义\n$$\nx_{n+1} = (a x_n + c) \\bmod m,\n$$\n其输出变换为\n$$\nU_n = \\frac{x_n}{m}.\n$$\n我们考虑两种从基础 LCG 创建并行流的标准方法。\n\n1. 跳步法（Leapfrog splitting）：对于固定数量的流 $P$，流 $i$（其中 $0 \\le i  P$）使用子序列 $\\{x_{i}, x_{i+P}, x_{i+2P}, \\dots\\}$，因此其第 $t$ 个输出为 $U^{(i)}_t = x_{i + t P}/m$。\n\n2. 跨步播种法（Skip-ahead seeding）：对于固定的步长 $L$，流 $i$ 从 $x_{iL}$ 开始播种，然后每次前进一个步长，因此其第 $t$ 个输出为 $U^{(i)}_t = x_{iL + t}/m$。\n\n我们采用以下基本定义。\n\n- 对于 $i \\ne j$，两个流 $(U^{(i)}_t)$ 和 $(U^{(j)}_t)$ 的独立性与条件 $\\operatorname{Cov}(U^{(i)}_t, U^{(j)}_t) = 0$ 相容，前提是对于每个固定的 $t$，假设分布相同且方差有限。\n- 对于两个长度为 $T$ 的有限序列 $(u_t)$ 和 $(v_t)$，其经验（无偏）协方差估计量为\n$$\n\\widehat{\\operatorname{Cov}}(u,v) = \\frac{1}{T-1}\\sum_{t=1}^{T} \\left(u_t - \\bar u\\right)\\left(v_t - \\bar v\\right),\n$$\n其中 $\\bar u = \\frac{1}{T}\\sum_{t=1}^{T} u_t$ 且 $\\bar v = \\frac{1}{T}\\sum_{t=1}^{T} v_t$。\n\n您的程序必须为下面列出的每个测试用例，同时使用跳步法和跨步播种法构建索引为 $i=0$ 和 $j=1$ 的两个流。对于每种方法，估计\n$$\n\\widehat{\\operatorname{Cov}}\\left((U^{(0)}_t)_{t=1}^T, (U^{(1)}_t)_{t=1}^T\\right),\n$$\n并将得到的协方差估计值报告为实数。\n\n实现约束与推导要求：\n\n- 您必须通过复合仿射映射来实现 LCG 的通用 $k$ 步跨越。利用以下事实：重复应用仿射更新 $x \\mapsto a x + c \\pmod m$ 可表示为单个仿射映射 $x \\mapsto a_k x + c_k \\pmod m$，其中\n$$\n\\begin{pmatrix}\na_k  c_k\\\\\n0  1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\na  c\\\\\n0  1\n\\end{pmatrix}^{k}\n\\pmod m.\n$$\n您必须使用在模 $m$ 下的重复平方求幂来计算此式，这是有效的，因为矩阵乘法复合了仿射映射，而重复平方求幂是在环下进行幂运算的成熟方法。\n\n- 对于有 $P$ 个流的跳步法，流 $i$ 必须从 $x_i$ 开始，然后重复应用上面推导出的 $P$ 步仿射映射。对于步长为 $L$ 的跨步播种法，流 $i$ 必须从 $x_{iL}$ 开始，然后重复应用 $1$ 步仿射映射。\n\n- 在浮点运算中，通过 $U = x/m$ 将状态转换为均匀分布值。\n\n测试套件：\n\n对于每个测试用例，使用 $P=4$ 个流，并估计索引为 $i=0$ 和 $j=1$ 的两个流之间的协方差。使用长度 $T=200000$。对基础 LCG 使用共同的初始种子 $x_0 = 42$。\n\n- 测试用例 1（理想情况，使用质数模的乘法 LCG）：\n  - $m = 2147483647$, $a = 16807$, $c = 0$\n  - 跨步步长 $L = 10^7$\n\n- 测试用例 2（使用合数模的混合 LCG）：\n  - $m = 2147483648$, $a = 1103515245$, $c = 12345$\n  - 跨步步长 $L = 10^6$\n\n- 测试用例 3（使用 2 的幂次模的全周期混合 LCG）：\n  - $m = 1048576$, $a = 5$, $c = 1$\n  - 跨步步长 $L = 65536$\n\n程序要求：\n\n- 对于每个测试用例，您的程序必须计算两个值：\n  - 使用跳步法时，流 $i=0$ 和 $j=1$ 之间的经验协方差估计值。\n  - 使用跨步播种法时，流 $i=0$ 和 $j=1$ 之间的经验协方差估计值。\n- 最终输出必须是单行，包含一个由方括号括起来的逗号分隔列表，其中按以下确切顺序包含六个浮点数：\n  - $[\\text{跳步法_用例1}, \\text{跨步法_用例1}, \\text{跳步法_用例2}, \\text{跨步法_用例2}, \\text{跳步法_用例3}, \\text{跨步法_用例3}]$\n\n不涉及物理单位。不使用角度。不需要百分比；所有报告的值均为标准十进制形式的实数。",
            "solution": "该问题要求以编程方式诊断线性同余生成器（LCG）的两种并行化策略的跨流相关性。这两种策略是跳步法（leapfrog splitting）和跨步播种法（skip-ahead seeding）。诊断通过估计前两个流（索引为 $i=0$ 和 $j=1$）之间的经验协方差来执行。\n\nLCG 的核心是递推关系：\n$$\nx_{n+1} = (a x_n + c) \\bmod m\n$$\n其中 $x_n$ 是第 $n$ 步的整数状态， $a$、$c$ 和 $m$ 分别是乘数、增量和模数。输出的均匀随机变量为 $U_n = x_n/m$。此递推是在模 $m$ 的整数环上的一个仿射变换。\n\n要将生成器推进 $k$ 步，从 $x_n$ 到 $x_{n+k}$，我们可以将此仿射映射自身复合 $k$ 次。这种复合对应于矩阵求幂。状态更新可以用齐次坐标写成：\n$$\n\\begin{pmatrix} x_{n+1} \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} x_n \\\\ 1 \\end{pmatrix} \\pmod m\n$$\n迭代 $k$ 次可得：\n$$\n\\begin{pmatrix} x_{n+k} \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix}^k \\begin{pmatrix} x_n \\\\ 1 \\end{pmatrix} \\pmod m\n$$\n设 $k$ 步转移矩阵为 $M_k = \\begin{pmatrix} a_k  c_k \\\\ 0  1 \\end{pmatrix}$，其中 $M_k = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix}^k \\pmod m$。那么 $k$ 步更新就是 $x_{n+k} = (a_k x_n + c_k) \\bmod m$。矩阵 $M_k$ 可以通过使用重复平方求幂的方法高效计算，执行模 $m$ 的矩阵乘法。由于第二行始终是 $(0, 1)$，我们只需计算数对 $(a, c)$ 的变换。如果我们有两个这样的变换 $(a', c')$ 和 $(a'', c'')$，它们的复合是：\n$$\n(a', c') \\circ (a'', c'') = (a'a'' \\pmod m, (a'c'' + c') \\pmod m)\n$$\n这对应于它们关联矩阵的乘法。单位变换是 $(1, 0)$。\n\n对于每个测试用例，实现将按以下步骤进行，其中提供了参数 $(m, a, c, L)$ 并固定了 $P=4$、$T=200000$ 和 $x_0=42$。\n\n**1. 跳步法（Leapfrog Splitting）**\n对于这种包含 $P$ 个流的方法，流 $i$ 由序列 $\\{x_i, x_{i+P}, x_{i+2P}, \\dots\\}$ 组成。问题要求我们必须比较流 $i=0$ 和 $j=1$。\n\n- 首先，我们通过计算 $M_P = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix}^P \\pmod m$ 来计算 $P$ 步仿射映射 $(a_P, c_P)$。在这个问题中，$P=4$。\n- 流 0 的种子是 $x_0$。\n- 流 1 的种子是 $x_1 = (a x_0 + c) \\bmod m$。\n- 我们从 $s_0^{(0)} = x_0$ 开始，重复应用 $P$ 步变换：$s_{t+1}^{(0)} = (a_P s_t^{(0)} + c_P) \\bmod m$（其中 $t = 0, \\dots, T-2$），为流 0 生成一个长度为 $T$ 的状态序列。\n- 类似地，我们从 $s_0^{(1)} = x_1$ 开始，应用相同的 $P$ 步变换，为流 1 生成一个长度为 $T$ 的状态序列。\n- 将这两个状态序列除以 $m$，转换为均匀分布的随机变量。\n\n**2. 跨步播种法（Skip-Ahead Seeding）**\n对于这种步长为 $L$ 的方法，流 $i$ 从状态 $x_{iL}$ 开始，并使用原始的 1 步 LCG 进行。我们比较流 $i=0$ 和 $j=1$。\n\n- 流 0 的种子是 $x_{0 \\cdot L} = x_0$。\n- 流 1 的种子是 $x_{1 \\cdot L} = x_L$。为找到此种子，我们通过计算 $M_L = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix}^L \\pmod m$ 来计算 $L$ 步仿射映射 $(a_L, c_L)$。然后种子为 $x_L = (a_L x_0 + c_L) \\bmod m$。\n- 我们从 $s_0^{(0)} = x_0$ 开始，重复应用 1 步变换：$s_{t+1}^{(0)} = (a s_t^{(0)} + c) \\bmod m$（其中 $t = 0, \\dots, T-2$），为流 0 生成一个长度为 $T$ 的状态序列。\n- 我们从 $s_0^{(1)} = x_L$ 开始，应用相同的 1 步变换，为流 1 生成一个长度为 $T$ 的状态序列。\n- 将这两个状态序列除以 $m$，转换为均匀分布的随机变量。\n\n**3. 协方差估计**\n对于这两种方法中的每一种，我们都得到两个长度为 $T$ 的均匀随机变量序列，可以表示为 $(u_t)_{t=1}^T$ 和 $(v_t)_{t=1}^T$。然后我们使用提供的公式计算经验无偏协方差：\n$$\n\\widehat{\\operatorname{Cov}}(u,v) = \\frac{1}{T-1}\\sum_{t=1}^{T} \\left(u_t - \\bar u\\right)\\left(v_t - \\bar v\\right)\n$$\n其中 $\\bar u$ 和 $\\bar v$ 分别是各自序列的样本均值。这将对生成的流进行数值计算。\n\n对所有三个测试用例重复此过程，并报告六个得出的协方差估计值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    # Test cases: (m, a, c, L)\n    test_cases = [\n        (2147483647, 16807, 0, 10**7),\n        (2147483648, 1103515245, 12345, 10**6),\n        (1048576, 5, 1, 65536)\n    ]\n    \n    # Common parameters\n    P = 4\n    T = 200000\n    x0 = 42\n    \n    results = []\n    \n    for m, a, c, L in test_cases:\n        # --- Leapfrog Splitting ---\n        \n        # 1. Compute P-step affine map (a_P, c_P)\n        a_P, c_P = mat_pow((a, c), P, m)\n        \n        # 2. Determine initial seeds for stream 0 and 1\n        seed0_leap = x0\n        seed1_leap = (a * x0 + c) % m\n        \n        # 3. Generate streams\n        stream0_leap = generate_sequence(seed0_leap, T, a_P, c_P, m)\n        stream1_leap = generate_sequence(seed1_leap, T, a_P, c_P, m)\n        \n        # 4. Calculate covariance\n        cov_leapfrog = calculate_covariance(stream0_leap, stream1_leap)\n        results.append(cov_leapfrog)\n        \n        # --- Skip-ahead Seeding ---\n        \n        # 1. Compute L-step affine map to find seed for stream 1\n        a_L, c_L = mat_pow((a, c), L, m)\n        \n        # 2. Determine initial seeds for stream 0 and 1\n        seed0_skip = x0\n        seed1_skip = (a_L * x0 + c_L) % m\n        \n        # 3. Generate streams using 1-step map\n        stream0_skip = generate_sequence(seed0_skip, T, a, c, m)\n        stream1_skip = generate_sequence(seed1_skip, T, a, c, m)\n        \n        # 4. Calculate covariance\n        cov_skipahead = calculate_covariance(stream0_skip, stream1_skip)\n        results.append(cov_skipahead)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef mat_mul(A, B, m):\n    \"\"\"\n    Composes two LCG affine maps represented by (a, c) tuples.\n    This corresponds to multiplying their transformation matrices modulo m.\n    If A is (a1, c1) and B is (a2, c2), the composition of A after B is\n    A(B(x)) = a1(a2x + c2) + c1 = (a1*a2)x + (a1*c2 + c1).\n    So, A o B maps to (a1*a2, a1*c2 + c1).\n    \"\"\"\n    a1, c1 = A\n    a2, c2 = B\n    new_a = (a1 * a2) % m\n    new_c = (a1 * c2 + c1) % m\n    return (new_a, new_c)\n\ndef mat_pow(A, k, m):\n    \"\"\"\n    Computes A^k mod m for an affine map A=(a,c) using exponentiation by squaring.\n    \"\"\"\n    # Identity transformation is (1, 0)\n    res = (1, 0)\n    # The exponentiation by squaring algorithm\n    base = A\n    while k > 0:\n        if k % 2 == 1:\n            res = mat_mul(res, base, m)\n        base = mat_mul(base, base, m)\n        k //= 2\n    return res\n\ndef generate_sequence(seed, length, a, c, m):\n    \"\"\"\n    Generates a sequence of random variates from an LCG.\n    Returns a numpy array of uniform variates in [0, 1).\n    \"\"\"\n    states = np.empty(length, dtype=np.uint64)\n    current_state = seed\n    for i in range(length):\n        states[i] = current_state\n        current_state = (a * current_state + c) % m\n    \n    # Convert states to uniforms\n    return states / m\n\ndef calculate_covariance(u, v):\n    \"\"\"\n    Computes the unbiased sample covariance between two sequences u and v.\n    \"\"\"\n    # ddof=1 for unbiased estimator (N-1 in denominator)\n    # np.cov returns the covariance matrix. We need the off-diagonal element.\n    cov_matrix = np.cov(u, v, ddof=1)\n    return cov_matrix[0, 1]\n\nsolve()\n```"
        },
        {
            "introduction": "对于像梅森旋转算法（Mersenne Twister）这样更复杂的生成器，即使采用了看似合理的并行化策略，也可能存在微妙的相关性。本项高级练习将指导你从第一性原理出发，实现一个多维谱检验（multidimensional spectral test）。这个强大的工具能够探测高维空间中的非显而易见的依赖关系，让你掌握对复杂随机数生成器进行严格质量控制的核心技能。",
            "id": "3338282",
            "problem": "考虑由周期为 $2^{19937}-1$ 的梅森旋转算法变体（通常称为 MT19937）生成的平行流。对于每个整数种子 $s_i = s_0 + i\\Delta$，将流 $i$ 定义为一个序列 $\\{U_t^{(i)}\\}_{t \\ge 1}$，该序列是通过使用种子 $s_i$ 初始化 MT19937 得到的，序列中的每个元素都是单位区间上均匀分布 $\\mathsf{Uniform}(0,1)$ 的独立实现。目标是通过检验二维序列 $\\{(U_t^{(i)}, U_t^{(j)})\\}_{t=1}^T$ 在单位正方形上的联合均匀性，来评估流对 $(i,j)$ 是否独立。\n\n您必须实现一个多维谱检验，其操作如下：\n\n1. 将单位正方形划分为一个 $m \\times m$ 的全等网格单元。对于 $t = 1, \\ldots, T$，将每对 $(U_t^{(i)}, U_t^{(j)})$ 映射到其单元格索引 $(a_t, b_t)$，其中 $a_t = \\lfloor m U_t^{(i)} \\rfloor$ 且 $b_t = \\lfloor m U_t^{(j)} \\rfloor$。\n\n2. 从每个单元格中减去期望的均匀单元格计数值，以形成中心化占据场。计算该中心化场的二维离散傅里叶变换 (DFT)。排除 $(0,0)$（零频）分量。构建一个固定的低频集合 $L \\subset \\{0,1,\\ldots,m-1\\}^2 \\setminus \\{(0,0)\\}$，该集合包含用于探测大规模对齐的小索引。\n\n3. 聚合所选低频分量的能量以获得一个检验统计量。在 $\\{(U_t^{(i)}, U_t^{(j)})\\}$ 是独立同分布于 $\\mathsf{Uniform}([0,1]^2)$ 的假设下，该统计量依分布收敛于一个自由度为 $2|L|$ 的卡方随机变量。使用此渐近分布计算一个 $p$ 值，并决定是否在指定的显著性水平下拒绝独立性假设。\n\n在您的推导和算法设计中，您只能使用以下基本事实：\n- 独立性的定义和单位区间上的均匀分布。\n- 离散傅里叶变换及其在有限网格上的正交性。\n- 适用于独立同分布随机变量之和的多元中心极限定理。\n\n程序必须完全从第一性原理出发实现谱检验，不得调用任何专用的随机数测试库。使用 NumPy 通过其现代随机数生成接口实现的 MT19937 来构建流，且仅可使用 SciPy 来评估卡方生存函数。\n\n谱检验采用以下固定参数：\n- 网格大小 $m = 16$。\n- 低频集合 $L = \\{(k,\\ell) : k \\in \\{0,1,2\\},\\, \\ell \\in \\{0,1,2\\}\\} \\setminus \\{(0,0)\\}$。\n- 显著性水平 $\\alpha = 10^{-3}$。\n\n将基础种子和间距定义为 $s_0 = 987654321$ 和 $\\Delta = 65537$。使用 $s_i = s_0 + i\\Delta$ 构建流。\n\n为了运行测试并评估在不同场景下的检测性能，请实现以下参数集测试套件。对于每种情况，根据指定的模式生成数据对 $\\{(U_t^{(i)}, U_t^{(j)})\\}_{t=1}^T$，然后应用谱检验并报告是否检测到依赖性（即拒绝独立性假设）：\n\n- 情况 1（一般独立情况）：$i=1, j=17, T=100000$，模式 = independent，表示 $U_t^{(i)}$ 和 $U_t^{(j)}$ 分别由使用种子 $s_i$ 和 $s_j$ 初始化的两个独立 MT19937 实例生成。\n- 情况 2（强对齐边缘情况）：$i=5, j=5, T=30000$，模式 = identical，表示对于所有 $t$，$U_t^{(j)} \\equiv U_t^{(i)}$（这模拟了一种病态的流克隆）。\n- 情况 3（微妙对齐场景）：$i=9, j=10, T=80000$，模式 = shifted，表示对于所有 $t$，$U_t^{(j)} = (U_t^{(i)} + 1/m) \\bmod 1$（这模拟了并行化中的一个低位对齐错误，该错误将一个流移动一个恒定的分数偏移量）。\n- 情况 4（小样本边界情况）：$i=2, j=3, T=512$，模式 = independent，同情况 1。\n\n输出规范：\n- 对于每种情况，输出一个布尔值，指示是否检测到依赖性（如果谱检验在水平 $\\alpha$ 下拒绝独立性假设，则为 true，否则为 false）。\n- 您的程序应生成单行输出，其中包含按顺序对应于情况 1-4 的四个布尔值，形式为用方括号括起来的逗号分隔列表，例如“[true,false,true,false]”。在输出中使用 Python 布尔字面量 “True” 和 “False”。\n\n此任务不涉及物理单位。根据变换的数学定义，DFT 中出现的角度以弧度为单位。最终输出是布尔值，不是百分比。\n\n您的实现必须是一个完整、可运行的程序，能够构建指定的流，应用基于第一性原理和多元中心极限定理推导出的谱检验，并打印所需的输出格式。",
            "solution": "该问题要求实现一个多维谱检验，以评估伪随机数流对的独立性。该检验的设计和实现基于第一性原理，即均匀分布的性质、离散傅里叶变换 (DFT) 和多元中心极限定理 (CLT)。\n\n设两个流表示为 $\\{U_t^{(i)}\\}_{t=1}^T$ 和 $\\{U_t^{(j)}\\}_{t=1}^T$。原假设 $H_0$ 设定，数据对 $\\{(U_t^{(i)}, U_t^{(j)})\\}_{t=1}^T$ 是从单位正方形上的均匀分布 $\\mathsf{Uniform}([0,1]^2)$ 中抽取的 $T$ 个独立同分布 (i.i.d.) 的随机样本序列。\n\n1.  **分箱与占据场**\n\n第一步是离散化连续样本空间。单位正方形 $[0,1]^2$ 被划分为一个由 $m \\times m$ 个不相交的方形单元格组成的均匀网格。对于每对随机变量值 $(U_t^{(i)}, U_t^{(j)})$，我们将其对应的单元格索引 $(a_t, b_t)$ 识别为：\n$$\na_t = \\lfloor m U_t^{(i)} \\rfloor, \\quad b_t = \\lfloor m U_t^{(j)} \\rfloor\n$$\n其中 $a_t, b_t \\in \\{0, 1, \\ldots, m-1\\}$。\n\n在 $H_0$ 假设下，任何单点落入特定单元格 $(a,b)$ 的概率为 $p_{a,b} = 1/m^2$。设 $N_{a,b}$ 为大小为 $T$ 的样本中落入单元格 $(a,b)$ 的点的数量。任何单元格的期望计数为：\n$$\nE[N_{a,b}] = T \\cdot p_{a,b} = \\frac{T}{m^2}\n$$\n我们通过从每个单元格的观测计数中减去期望计数，来形成中心化占据场 $X_{a,b}$：\n$$\nX_{a,b} = N_{a,b} - \\frac{T}{m^2}\n$$\n该场中所有元素的总和为零：$\\sum_{a=0}^{m-1} \\sum_{b=0}^{m-1} X_{a,b} = T - m^2(T/m^2) = 0$。\n\n2.  **离散傅里叶变换**\n\n谱检验通过检查中心化场的傅里叶变换来分析占据计数中的周期性。$X_{a,b}$ 的二维 DFT 定义为：\n$$\n\\hat{X}_{k,\\ell} = \\sum_{a=0}^{m-1} \\sum_{b=0}^{m-1} X_{a,b} \\exp\\left(-2\\pi \\mathrm{i} \\left(\\frac{ak}{m} + \\frac{b\\ell}{m}\\right)\\right)\n$$\n其中频率索引 $k, \\ell \\in \\{0, 1, \\ldots, m-1\\}$，$\\mathrm{i}$ 是虚数单位。零频分量 $\\hat{X}_{0,0} = \\sum_{a,b} X_{a,b}$ 恒等于零，因此从分析中排除。\n\n3.  **通过中心极限定理得到的渐近分布**\n\n为了推导检验统计量，我们分析在 $H_0$ 假设下 DFT 系数 $\\hat{X}_{k,\\ell}$ 的统计性质。我们可以将 $\\hat{X}_{k,\\ell}$ 表示为对 $T$ 个样本点的求和。对于 $(k,\\ell) \\neq (0,0)$:\n$$\n\\hat{X}_{k,\\ell} = \\sum_{a,b} \\left( \\sum_{t=1}^T \\mathbb{I}((a,b) = (a_t,b_t)) - \\frac{T}{m^2} \\right) \\omega_{a,b}^{k,\\ell} = \\sum_{t=1}^T \\omega_{a_t, b_t}^{k,\\ell}\n$$\n其中 $\\omega_{a,b}^{k,\\ell} = \\exp\\left(-2\\pi \\mathrm{i} \\left(\\frac{ak}{m} + \\frac{b\\ell}{m}\\right)\\right)$，且 $\\mathbb{I}(\\cdot)$ 是指示函数。之所以能够简化，是因为由于复指数的正交性，对于非零频率，涉及 $T/m^2$ 的求和项为零。\n\n令 $Z_t^{k,\\ell} = \\omega_{a_t, b_t}^{k,\\ell}$。那么 $\\hat{X}_{k,\\ell} = \\sum_{t=1}^T Z_t^{k,\\ell}$。在 $H_0$ 假设下，$\\{Z_t^{k,\\ell}\\}_{t=1}^T$ 是独立同分布的复随机变量。它们的期望对于 $(k,\\ell) \\neq (0,0)$ 为 $E[Z_t^{k,\\ell}] = \\sum_{a,b} (1/m^2) \\omega_{a,b}^{k,\\ell} = 0$。\n\n根据多元中心极限定理，归一化的 DFT 系数向量 $(\\ldots, \\frac{1}{\\sqrt{T}}\\hat{X}_{k,\\ell}, \\ldots)$ 依分布收敛于一个多元复正态分布。$\\frac{1}{\\sqrt{T}}\\hat{X}_{k,\\ell}$ 的实部和虚部是渐近独立的标准正态随机变量。具体来说，对于满足 $(2k, 2\\ell) \\not\\equiv (0,0) \\pmod m$ 的频率 $(k,\\ell)$，可以证明 $Var(\\text{Re}(Z_t^{k,\\ell})) = Var(\\text{Im}(Z_t^{k,\\ell})) = 1/2$ 且它们的协方差为 $0$。\n这意味着对于大的 $T$：\n$$\n\\frac{\\sqrt{2}}{\\sqrt{T}} \\text{Re}(\\hat{X}_{k,\\ell}) \\sim \\mathcal{N}(0,1) \\quad \\text{and} \\quad \\frac{\\sqrt{2}}{\\sqrt{T}} \\text{Im}(\\hat{X}_{k,\\ell}) \\sim \\mathcal{N}(0,1)\n$$\n其中 $\\mathcal{N}(0,1)$ 是标准正态分布。\n\n4.  **检验统计量与假设检验**\n\n这两个独立标准正态变量的平方和服从一个自由度为 $2$ 的卡方分布 ($\\chi^2_2$)。这个量是：\n$$\n\\left(\\frac{\\sqrt{2}}{\\sqrt{T}} \\text{Re}(\\hat{X}_{k,\\ell})\\right)^2 + \\left(\\frac{\\sqrt{2}}{\\sqrt{T}} \\text{Im}(\\hat{X}_{k,\\ell})\\right)^2 = \\frac{2}{T} |\\hat{X}_{k,\\ell}|^2 \\sim \\chi^2_2\n$$\n检验统计量 $S$ 是通过对一个预定义的低频模式集合 $L$ 中的这些贡献求和来构建的，这些模式对大规模相关性很敏感。\n$$\nS = \\sum_{(k,\\ell) \\in L} \\frac{2}{T} |\\hat{X}_{k,\\ell}|^2\n$$\n对于不同的非共轭频率，DFT 系数是渐近独立的。指定的集合 $L = \\{(k,\\ell) : k, \\ell \\in \\{0,1,2\\}\\} \\setminus \\{(0,0)\\}$ 在 $m=16$ 时包含 $|L|=8$ 个频率对，其中没有一个是特殊的（例如，与其共轭频率发生混叠）。因此，根据卡方分布的可加性，$S$ 依分布收敛于一个自由度为 $d = 2|L| = 16$ 的卡方随机变量。\n$$\nS \\xrightarrow{d} \\chi^2_{16}\n$$\n为了做出决策，我们计算统计量的观测值 $S_{obs}$，并计算相关的 $p$ 值。$p$ 值是在 $H_0$ 为真的情况下，观测到至少与 $S_{obs}$ 一样大的统计量的概率：\n$$\np\\text{-value} = P(\\chi^2_{16} \\ge S_{obs})\n$$\n这个值使用卡方分布的生存函数来计算。如果 $p$ 值小于指定的显著性水平 $\\alpha = 10^{-3}$，则拒绝独立性的原假设。\n\n该算法的流程是：为每种情况生成随机变量值，执行分箱，计算中心化场，应用 DFT，为给定的集合 $L$ 计算统计量 $S$，最后确定 $p$ 值以决定是否拒绝 $H_0$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef run_spectral_test(stream1, stream2, T, m, L, alpha):\n    \"\"\"\n    Performs a 2D spectral test on a pair of random number streams.\n\n    Args:\n        stream1 (np.ndarray): The first stream of uniform random numbers.\n        stream2 (np.ndarray): The second stream of uniform random numbers.\n        T (int): The number of points in each stream.\n        m (int): The grid size for binning (m x m).\n        L (set): A set of (k, l) frequency tuples to include in the test.\n        alpha (float): The significance level for the hypothesis test.\n\n    Returns:\n        bool: True if dependence is detected (H0 is rejected), False otherwise.\n    \"\"\"\n    # Step 1: Binning\n    # Create an m x m grid and count the occurrences in each bin.\n    counts = np.zeros((m, m), dtype=np.int32)\n    \n    # Vectorized computation of bin indices for all T points.\n    indices_a = np.floor(m * stream1).astype(int)\n    indices_b = np.floor(m * stream2).astype(int)\n    \n    # Clip to handle the edge case where a uniform variate is exactly 1.0.\n    indices_a = np.clip(indices_a, 0, m - 1)\n    indices_b = np.clip(indices_b, 0, m - 1)\n    \n    # Efficiently increment counts for all points.\n    np.add.at(counts, (indices_a, indices_b), 1)\n\n    # Step 2: Centered Occupancy Field and Discrete Fourier Transform\n    # Subtract the expected count under the null hypothesis of uniformity.\n    expected_count = T / (m * m)\n    centered_counts = counts - expected_count\n    \n    # Compute the 2D DFT of the centered field.\n    dft_coeffs = np.fft.fft2(centered_counts)\n\n    # Step 3: Test Statistic Calculation\n    # Aggregate the energy from the selected low-frequency components.\n    energy_sum = 0.0\n    for k, l in L:\n        coeff = dft_coeffs[k, l]\n        energy_sum += np.abs(coeff)**2\n    \n    # Normalize to form the chi-square statistic.\n    statistic_S = (2.0 / T) * energy_sum\n\n    # Step 4: p-value Calculation and Decision\n    # The degrees of freedom is 2 for each complex frequency pair.\n    dof = 2 * len(L)\n    \n    # Compute the p-value using the survival function (1 - CDF) of the chi-square distribution.\n    p_value = chi2.sf(statistic_S, df=dof)\n    \n    # Reject the null hypothesis if the p-value is below the significance level.\n    return p_value  alpha\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test suite and print results.\n    \"\"\"\n    # Fixed parameters for the spectral test from the problem statement.\n    m = 16\n    L_set = {(k, l) for k in range(3) for l in range(3)} - {(0, 0)}\n    alpha = 1e-3\n    s0 = 987654321\n    delta = 65537\n\n    # Define the four test cases.\n    test_cases = [\n        {'id': 1, 'i': 1, 'j': 17, 'T': 100000, 'mode': 'independent'},\n        {'id': 2, 'i': 5, 'j': 5, 'T': 30000, 'mode': 'identical'},\n        {'id': 3, 'i': 9, 'j': 10, 'T': 80000, 'mode': 'shifted'},\n        {'id': 4, 'i': 2, 'j': 3, 'T': 512, 'mode': 'independent'},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        i, j, T, mode = case['i'], case['j'], case['T'], case['mode']\n        \n        # Initialize random number generators with specified seeds.\n        seed_i = s0 + i * delta\n        rng_i = np.random.Generator(np.random.MT19937(seed_i))\n        \n        # Generate stream(s) based on the test case mode.\n        stream_i = rng_i.uniform(size=T)\n        \n        if mode == 'independent':\n            seed_j = s0 + j * delta\n            rng_j = np.random.Generator(np.random.MT19937(seed_j))\n            stream_j = rng_j.uniform(size=T)\n        elif mode == 'identical':\n            # Pathological case: streams are identical.\n            stream_j = stream_i\n        elif mode == 'shifted':\n            # Pathological case: one stream is a shifted version of the other.\n            stream_j = (stream_i + 1.0 / m) % 1.0\n        else:\n            # This path should not be reached with the given test cases.\n            raise ValueError(f\"Unknown mode specified: {mode}\")\n            \n        # Run the test and store the boolean result.\n        is_dependent = run_spectral_test(stream_i, stream_j, T, m, L_set, alpha)\n        results.append(is_dependent)\n    \n    # Print the final results in the specified format.\n    # The map(str, ...) correctly converts Python booleans to \"True\" and \"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}