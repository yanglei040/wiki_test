{
    "hands_on_practices": [
        {
            "introduction": "构建一个有效的动力学蒙特卡洛（KMC）模拟，其基石是建立一个满足物理一致性的跃迁速率模型。本实践旨在从第一性原理出发，构建一个符合细致平衡条件的KMC生成元矩阵。通过处理给定的、可能不一致的能垒和尝试频率建议值，你将亲手实现从理论到代码的转化，确保模拟能够正确地采样玻尔兹曼分布，这是模拟平衡态性质和计算速率常数的关键一步。",
            "id": "3358266",
            "problem": "考虑一个定义在一维周期性晶格上的连续时间马尔可夫链，该晶格有 $N$ 个格点，标记为 $i \\in \\{0,1,\\dots,N-1\\}$，且具有最近邻连接。连续时间马尔可夫链的生成元矩阵 $Q$ 满足对于每个 $i$，$q_{ii} = -\\sum_{j \\neq i} q_{ij}$，并且对于 $j \\neq i$，$q_{ij} \\ge 0$。非对角线元素 $q_{ij}$ 是跃迁速率 $k_{ij}$。\n\n假设动力学由具有 Arrhenius 形式的过渡态理论 (TST) 控制，其中从态 $i$ 到态 $j$ 的速率由 $k_{ij} = \\nu_{ij} \\exp\\left(-\\frac{E^{\\ddagger}_{ij} - E_i}{k_{\\mathrm{B}} T}\\right)$ 给出，其中 $E_i$ 是态 $i$ 的能量，$E^{\\ddagger}_{ij}$ 是 $i \\to j$ 跃迁的过渡鞍点能量，$\\nu_{ij}$ 是尝试频率，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。微观可逆性要求对于任何一对相邻态 $(i,j)$，两个方向都由相同的鞍点能量控制，即 $E^{\\ddagger}_{ij} = E^{\\ddagger}_{ji}$。\n\n关于玻尔兹曼分布的细致平衡要求存在一个平衡分布 $\\pi$，其中 $\\pi_i \\propto \\exp\\left(-\\frac{E_i}{k_{\\mathrm{B}} T}\\right)$，使得对于所有对 $(i,j)$，都有 $\\pi_i k_{ij} = \\pi_j k_{ji}$。从上述基本定义出发，构建一个生成元 $Q$，该生成元对给定的势垒建议和尝试频率强制执行微观可逆性，并数值验证细致平衡。\n\n对于下方的每个测试用例，您将获得：\n- 晶格大小 $N$ 和 $i$ 与 $(i+1) \\bmod N$ 之间的周期性最近邻连接。\n- 态能量 $E_i$，单位为电子伏特 ($\\mathrm{eV}$)。\n- 正向跃迁 $i \\to (i+1) \\bmod N$ 的势垒建议 $b^{\\mathrm{fwd}}_i$，以及反向跃迁 $(i+1) \\bmod N \\to i$ 的势垒建议 $b^{\\mathrm{bwd}}_i$，单位均为 $\\mathrm{eV}$。\n- 尝试频率 $\\nu^{\\mathrm{fwd}}_i$ 和 $\\nu^{\\mathrm{bwd}}_i$，单位为 $\\mathrm{s}^{-1}$。\n- 温度 $T$，单位为开尔文 ($\\mathrm{K}$)。\n使用玻尔兹曼常数 $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}$ $\\mathrm{eV}/\\mathrm{K}$。\n\n您对每个测试用例的任务：\n1. 根据提供的 $E$、$b^{\\mathrm{fwd}}$、$b^{\\mathrm{bwd}}$、$\\nu^{\\mathrm{fwd}}$ 和 $\\nu^{\\mathrm{bwd}}$，为环构建满足微观可逆性的跃迁速率 $k_{ij}$，并生成一个在温度 $T$ 下相对于玻尔兹曼分布可逆的生成元 $Q$。构建过程必须从提供的基本定义出发，不得假设任何非推导的简化公式。\n2. 构造生成元 $Q$，其中当 $j \\neq i$ 时 $q_{ij} = k_{ij}$，且 $q_{ii} = -\\sum_{j \\neq i} k_{ij}$。\n3. 计算玻尔兹曼平衡权重 $\\pi_i \\propto \\exp\\left(-\\frac{E_i}{k_{\\mathrm{B}} T}\\right)$，并进行归一化，以使 $\\sum_i \\pi_i = 1$。\n4. 计算所有最近邻对的最大绝对细致平衡残差，\n$$\nr_{\\max} = \\max_{i} \\left| \\pi_i k_{i,(i+1)\\bmod N} - \\pi_{(i+1)\\bmod N} k_{(i+1)\\bmod N,i} \\right|.\n$$\n报告每个测试用例的 $r_{\\max}$，单位为 $\\mathrm{s}^{-1}$。\n\n测试套件：\n- 案例 1（理想情况，对称的尝试频率和一致的势垒）：\n    - $N = 4$，\n    - $E = [\\,0.00,\\,0.05,\\,0.10,\\,0.20\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{fwd}} = [\\,0.40,\\,0.45,\\,0.50,\\,0.60\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{bwd}} = [\\,0.40,\\,0.45,\\,0.50,\\,0.60\\,]$ $\\mathrm{eV}$，\n    - $\\nu^{\\mathrm{fwd}} = [\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $\\nu^{\\mathrm{bwd}} = [\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $T = 300.0$ $\\mathrm{K}$。\n- 案例 2（非对称的尝试频率和不对称的势垒建议）：\n    - $N = 5$，\n    - $E = [\\,0.00,\\,0.02,\\,0.08,\\,0.04,\\,0.10\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{fwd}} = [\\,0.35,\\,0.37,\\,0.42,\\,0.40,\\,0.45\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{bwd}} = [\\,0.33,\\,0.39,\\,0.41,\\,0.43,\\,0.44\\,]$ $\\mathrm{eV}$，\n    - $\\nu^{\\mathrm{fwd}} = [\\,1.0 \\times 10^{13},\\,2.0 \\times 10^{13},\\,0.5 \\times 10^{13},\\,1.5 \\times 10^{13},\\,1.0 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $\\nu^{\\mathrm{bwd}} = [\\,0.8 \\times 10^{13},\\,1.8 \\times 10^{13},\\,0.7 \\times 10^{13},\\,1.2 \\times 10^{13},\\,0.9 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $T = 350.0$ $\\mathrm{K}$。\n- 案例 3（高势垒，慢动力学）：\n    - $N = 3$，\n    - $E = [\\,0.00,\\,0.10,\\,0.20\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{fwd}} = [\\,1.00,\\,0.90,\\,1.10\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{bwd}} = [\\,1.00,\\,0.90,\\,1.10\\,]$ $\\mathrm{eV}$，\n    - $\\nu^{\\mathrm{fwd}} = [\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $\\nu^{\\mathrm{bwd}} = [\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $T = 300.0$ $\\mathrm{K}$。\n- 案例 4（简并能量，非均匀的尝试频率和势垒建议）：\n    - $N = 4$，\n    - $E = [\\,0.05,\\,0.05,\\,0.05,\\,0.05\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{fwd}} = [\\,0.25,\\,0.30,\\,0.28,\\,0.27\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{bwd}} = [\\,0.26,\\,0.29,\\,0.31,\\,0.24\\,]$ $\\mathrm{eV}$，\n    - $\\nu^{\\mathrm{fwd}} = [\\,1.0 \\times 10^{13},\\,1.2 \\times 10^{13},\\,0.9 \\times 10^{13},\\,1.1 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $\\nu^{\\mathrm{bwd}} = [\\,0.8 \\times 10^{13},\\,1.3 \\times 10^{13},\\,1.0 \\times 10^{13},\\,1.2 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $T = 400.0$ $\\mathrm{K}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个 $r_{\\max}$ 值的列表（单位为 $\\mathrm{s}^{-1}$），格式为逗号分隔的 Python 风格列表，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 按相同顺序对应于案例 $i$。不应打印任何额外文本。",
            "solution": "该问题陈述经评估有效。它在科学上基于统计力学和随机过程理论，问题设定良好、客观，并包含构建唯一且有意义的解所需的所有必要信息。问题的核心在于根据可能不一致的输入建议构建一个物理上一致的速率模型，这是计算物理和计算化学中一个标准且不简单的任务。\n\n解决方案首先建立理论框架，然后详细说明跃迁速率的构建以及随后的细致平衡残差的计算。\n\n该系统是一个在一维周期性晶格上的连续时间马尔可夫链，晶格有 $N$ 个格点，由 $i \\in \\{0, 1, \\dots, N-1\\}$ 索引。跃迁仅限于最近邻之间。从态 $i$ 到态 $j$ 的跃迁速率 $k_{ij}$ 由过渡态理论推导出的 Arrhenius 形式给出：\n$$\nk_{ij} = \\nu_{ij} \\exp\\left(-\\frac{E^{\\ddagger}_{ij} - E_i}{k_{\\mathrm{B}} T}\\right)\n$$\n其中 $E_i$ 是态 $i$ 的能量，$E^{\\ddagger}_{ij}$ 是 $i$ 和 $j$ 之间的过渡态（鞍点）能量，$\\nu_{ij}$ 是尝试频率，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。\n\n动力学必须满足两个基本原则：微观可逆性和细致平衡。\n\n1.  **微观可逆性**：问题将此原则定义为要求两态 $i$ 和 $j$ 之间的跃迁路径与方向无关。这意味着对于任何连接对 $(i,j)$，存在一个单一的、共享的鞍点能量，即 $E^{\\ddagger}_{ij} = E^{\\ddagger}_{ji}$。\n\n2.  **细致平衡**：对于处于热平衡的系统，任意两态之间的净通量必须为零。这由细致平衡条件表示：\n    $$\n    \\pi_i k_{ij} = \\pi_j k_{ji}\n    $$\n    其中 $\\pi$ 是平衡分布。对于与热库接触的系统，这是玻尔兹曼分布：\n    $$\n    \\pi_i = \\frac{1}{Z} \\exp\\left(-\\frac{E_i}{k_{\\mathrm{B}} T}\\right)\n    $$\n    其中 $Z = \\sum_k \\exp(-\\frac{E_k}{k_{\\mathrm{B}} T})$ 是配分函数。\n\n让我们将速率的 Arrhenius 表达式代入细致平衡方程。令 $\\beta = 1/(k_{\\mathrm{B}}T)$。\n$$\n\\frac{e^{-\\beta E_i}}{Z} \\left( \\nu_{ij} e^{-\\beta(E^{\\ddagger}_{ij} - E_i)} \\right) = \\frac{e^{-\\beta E_j}}{Z} \\left( \\nu_{ji} e^{-\\beta(E^{\\ddagger}_{ji} - E_j)} \\right)\n$$\n简化指数项可得：\n$\n\\nu_{ij} e^{-\\beta E^{\\ddagger}_{ij}} = \\nu_{ji} e^{-\\beta E^{\\ddagger}_{ji}}\n$\n该方程是细致平衡对 TST 参数施加的基本约束。如果我们现在强制执行微观可逆性原则，$E^{\\ddagger}_{ij} = E^{\\ddagger}_{ji}$，指数项会抵消，从而对尝试频率产生一个约束：\n$\n\\nu_{ij} = \\nu_{ji}\n$\n因此，为了构建一个满足这两个原则的物理有效模型，我们必须确保对于每对连接的态 $(i,j)$，存在单一的鞍点能量 $E^{\\ddagger}_{ij}=E^{\\ddagger}_{ji}$ 和单一的尝试频率 $\\nu_{ij}=\\nu_{ji}$。\n\n问题为这些参数从正向和反向角度提供了可能不一致的“建议”。任务是从这些建议中构建一套一致的参数。对于每个最近邻对 $(i, j=(i+1)\\bmod N)$：\n\n-   **鞍点能量构建**：问题提供了正向势垒建议 $b^{\\mathrm{fwd}}_i$ 和反向势垒建议 $b^{\\mathrm{bwd}}_i$。这对应于两个关于绝对鞍点能量的建议：\n    -   正向建议：$E^{\\ddagger, \\mathrm{fwd}}_{ij} = E_i + b^{\\mathrm{fwd}}_i$\n    -   反向建议：$E^{\\ddagger, \\mathrm{bwd}}_{ji} = E_j + b^{\\mathrm{bwd}}_i$\n    为了满足 $E^{\\ddagger}_{ij} = E^{\\ddagger}_{ji}$，我们必须协调这两个值。一个物理上对称且稳健的选择是两个建议的绝对能量的算术平均值。让我们将对 $(i,j)$ 的单一鞍点表示为 $E^{\\ddagger}_{i,(i+1)\\%N}$：\n    $$\n    E^{\\ddagger}_{i,(i+1)\\%N} = \\frac{1}{2} \\left[ (E_i + b^{\\mathrm{fwd}}_i) + (E_{(i+1)\\%N} + b^{\\mathrm{bwd}}_i) \\right]\n    $$\n\n-   **尝试频率构建**：问题提供了正向尝试频率建议 $\\nu^{\\mathrm{fwd}}_i$ 和反向建议 $\\nu^{\\mathrm{bwd}}_i$。为了满足 $\\nu_{ij}=\\nu_{ji}$，我们必须再次协调它们。对于速率和频率，在基础统计理论中它们是乘法结合的，因此几何平均值是合适的平均方法。我们将对 $(i,j)$ 的单一尝试频率定义为：\n    $$\n    \\nu_{i,(i+1)\\%N} = \\sqrt{\\nu^{\\mathrm{fwd}}_i \\nu^{\\mathrm{bwd}}_i}\n    $$\n\n利用这些构建的对称参数，我们可以为每对 $(i, j=(i+1)\\bmod N)$ 定义最终的、一致的正向和反向速率：\n-   正向速率：$k_{i,j} = \\nu_{i,j} \\exp\\left( - \\frac{E^{\\ddagger}_{i,j} - E_i}{k_{\\mathrm{B}} T} \\right)$\n-   反向速率：$k_{j,i} = \\nu_{i,j} \\exp\\left( - \\frac{E^{\\ddagger}_{i,j} - E_j}{k_{\\mathrm{B}} T} \\right)$\n根据构造，这些速率将满足细致平衡条件。数值计算任务是计算每对的残差 $|\\pi_i k_{i,j} - \\pi_j k_{j,i}|$，该值在浮点精度范围内应为零，并报告其最大值。\n\n每个测试用例的算法如下：\n1.  定义常数 $k_{\\mathrm{B}}$ 并计算 $\\beta = 1/(k_{\\mathrm{B}}T)$。\n2.  为速率 $k_{ij}$ 初始化一个空矩阵。\n3.  对于从 $0$ 到 $N-1$ 的每个格点 $i$：\n    a. 确定邻居 $j = (i+1) \\bmod N$。\n    b. 使用建议的算术平均值构建对称的鞍点能量 $E^{\\ddagger}_{i,j}$。\n    c. 使用建议的几何平均值构建对称的尝试频率 $\\nu_{i,j}$。\n    d. 使用这些构建的参数计算正向速率 $k_{ij}$ 和反向速率 $k_{ji}$，并存储它们。\n4.  计算归一化的玻尔兹曼分布 $\\pi_i = \\exp(-\\beta E_i) / \\sum_k \\exp(-\\beta E_k)$。\n5.  初始化 $r_{\\max} = 0$。\n6.  对于从 $0$ 到 $N-1$ 的每个格点 $i$：\n    a. 确定邻居 $j=(i+1)\\bmod N$。\n    b. 计算残差 $r = |\\pi_i k_{ij} - \\pi_j k_{ji}|$。\n    c. 更新 $r_{\\max} = \\max(r_{\\max}, r)$。\n7.  该案例的最终结果是 $r_{\\max}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the problem of constructing a consistent Markov chain generator\n    and verifying detailed balance numerically for several test cases.\n    \"\"\"\n    \n    # Define the Boltzmann constant in eV/K.\n    k_B = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"N\": 4,\n            \"E\": np.array([0.00, 0.05, 0.10, 0.20]),\n            \"b_fwd\": np.array([0.40, 0.45, 0.50, 0.60]),\n            \"b_bwd\": np.array([0.40, 0.45, 0.50, 0.60]),\n            \"nu_fwd\": np.array([1.0e13, 1.0e13, 1.0e13, 1.0e13]),\n            \"nu_bwd\": np.array([1.0e13, 1.0e13, 1.0e13, 1.0e13]),\n            \"T\": 300.0\n        },\n        # Case 2\n        {\n            \"N\": 5,\n            \"E\": np.array([0.00, 0.02, 0.08, 0.04, 0.10]),\n            \"b_fwd\": np.array([0.35, 0.37, 0.42, 0.40, 0.45]),\n            \"b_bwd\": np.array([0.33, 0.39, 0.41, 0.43, 0.44]),\n            \"nu_fwd\": np.array([1.0e13, 2.0e13, 0.5e13, 1.5e13, 1.0e13]),\n            \"nu_bwd\": np.array([0.8e13, 1.8e13, 0.7e13, 1.2e13, 0.9e13]),\n            \"T\": 350.0\n        },\n        # Case 3\n        {\n            \"N\": 3,\n            \"E\": np.array([0.00, 0.10, 0.20]),\n            \"b_fwd\": np.array([1.00, 0.90, 1.10]),\n            \"b_bwd\": np.array([1.00, 0.90, 1.10]),\n            \"nu_fwd\": np.array([1.0e13, 1.0e13, 1.0e13]),\n            \"nu_bwd\": np.array([1.0e13, 1.0e13, 1.0e13]),\n            \"T\": 300.0\n        },\n        # Case 4\n        {\n            \"N\": 4,\n            \"E\": np.array([0.05, 0.05, 0.05, 0.05]),\n            \"b_fwd\": np.array([0.25, 0.30, 0.28, 0.27]),\n            \"b_bwd\": np.array([0.26, 0.29, 0.31, 0.24]),\n            \"nu_fwd\": np.array([1.0e13, 1.2e13, 0.9e13, 1.1e13]),\n            \"nu_bwd\": np.array([0.8e13, 1.3e13, 1.0e13, 1.2e13]),\n            \"T\": 400.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        E = case[\"E\"]\n        b_fwd = case[\"b_fwd\"]\n        b_bwd = case[\"b_bwd\"]\n        nu_fwd = case[\"nu_fwd\"]\n        nu_bwd = case[\"nu_bwd\"]\n        T = case[\"T\"]\n\n        # Calculate thermal energy in eV\n        kT = k_B * T\n\n        # The rate matrix k_matrix will store the off-diagonal elements of the generator Q.\n        k_matrix = np.zeros((N, N))\n\n        for i in range(N):\n            j = (i + 1) % N\n\n            # Construct the single, symmetric saddle energy E_saddle for the pair (i,j)\n            # by taking the arithmetic mean of the suggested absolute saddle energies.\n            suggested_fwd_saddle = E[i] + b_fwd[i]\n            suggested_bwd_saddle = E[j] + b_bwd[i]\n            E_saddle = 0.5 * (suggested_fwd_saddle + suggested_bwd_saddle)\n\n            # Construct the single, symmetric attempt frequency nu_sym for the pair (i,j)\n            # by taking the geometric mean of the suggested frequencies.\n            nu_sym = np.sqrt(nu_fwd[i] * nu_bwd[i])\n\n            # Calculate the forward rate k_ij (i -> j)\n            activation_energy_fwd = E_saddle - E[i]\n            k_ij = nu_sym * np.exp(-activation_energy_fwd / kT)\n            \n            # Calculate the backward rate k_ji (j -> i)\n            activation_energy_bwd = E_saddle - E[j]\n            k_ji = nu_sym * np.exp(-activation_energy_bwd / kT)\n\n            k_matrix[i, j] = k_ij\n            k_matrix[j, i] = k_ji\n        \n        # Calculate the normalized Boltzmann equilibrium distribution pi.\n        pi_unnorm = np.exp(-E / kT)\n        partition_func = np.sum(pi_unnorm)\n        pi = pi_unnorm / partition_func\n\n        # Calculate the maximum absolute detailed-balance residual.\n        max_residual = 0.0\n        for i in range(N):\n            j = (i + 1) % N\n            residual = np.abs(pi[i] * k_matrix[i, j] - pi[j] * k_matrix[j, i])\n            if residual > max_residual:\n                max_residual = residual\n        \n        results.append(max_residual)\n\n    # Final print statement in the exact required format.\n    # The results should be nearly zero due to the construction method.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "过渡路径采样（TPS）的核心是在路径空间中进行蒙特卡洛抽样，以探索从反应物到产物的稀有事件轨迹。本练习将通过实现一个基本但极其重要的TPS移动——“窗口平移”（window-shift）——来引导你入门。你将从第一性原理推导该移动的接受概率，并发现其表达式可以优雅地简化，仅依赖于路径窗口的端点。通过数值实验验证路径空间中的细致平衡条件，你将加深对路径采样算法正确性的理解。",
            "id": "3358214",
            "problem": "考虑一维过阻尼朗之万恒温器中的过渡路径采样 (TPS)。设势能由双阱函数 $$U(x) = \\frac{1}{4}(x^2 - 1)^2$$ 定义，逆温度为 $$\\beta > 0$$。使用时间步长 $$\\Delta t > 0$$ 的过阻尼朗之万（布朗动力学）离散化（欧拉-丸山格式）由从 $$x_k$$ 到 $$x_{k+1}$$ 的马尔可夫跃迁给出：\n$$\nx_{k+1} = x_k - \\Delta t\\, \\nabla U(x_k) + \\sqrt{\\frac{2\\Delta t}{\\beta}}\\,\\xi_k,\n$$\n其中 $$\\xi_k \\sim \\mathcal{N}(0,1)$$ 是独立的标准正态变量，且 $$\\nabla U(x) = x(x^2 - 1)$$。单步的马尔可夫跃迁密度是高斯分布\n$$\np(x_{k+1}\\mid x_k) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp\\left(-\\frac{\\left(x_{k+1} - \\mu(x_k)\\right)^2}{2\\sigma^2}\\right),\n$$\n其中 $$\\mu(x_k) = x_k - \\Delta t\\,\\nabla U(x_k)$$ 且 $$\\sigma^2 = \\frac{2\\Delta t}{\\beta}$$。稳态（正则）密度为\n$$\n\\rho(x) \\propto \\exp\\left(-\\beta U(x)\\right).\n$$\n\n一个长度为 $$L$$ 次跃迁的路径窗由序列 $$\\omega = (x_s, x_{s+1}, \\dots, x_{s+L})$$ 组成，其未归一化的路径权重为\n$$\n\\pi(\\omega) = \\rho(x_s)\\prod_{k=s}^{s+L-1} p(x_{k+1}\\mid x_k).\n$$\n一个 TPS 窗移提议将路径窗前移一个时间步长，得到 $$\\omega' = (x_{s+1}, x_{s+2}, \\dots, x_{s+L+1})$$。使用 Metropolis 接受准则，前移接受概率必须从第一性原理计算得出：\n$$\n\\alpha_{\\mathrm{fwd}}(\\omega \\to \\omega') = \\min\\left(1, \\frac{\\pi(\\omega')}{\\pi(\\omega)}\\right),\n$$\n而逆向的后移接受概率为\n$$\n\\alpha_{\\mathrm{bwd}}(\\omega' \\to \\omega) = \\min\\left(1, \\frac{\\pi(\\omega)}{\\pi(\\omega')}\\right).\n$$\n\n仅从上述定义（马尔可夫性质、显式离散化、稳态密度）出发，推导单步窗移的接受概率，并将其简化为只涉及端点 $$x_s, x_{s+1}, x_{s+L}, x_{s+L+1}$$ 以及模型参数 $$\\Delta t$$ 和 $$\\beta$$ 的可计算量。\n\n然后，实施一个数值实验，以验证在由离散化生成的样本路径上的窗移移动满足细致平衡。对于对称提议（以相同概率选择前移或后移），细致平衡要求对于每一对相邻的窗 $$\\omega$$ 和 $$\\omega'$$，\n$$\n\\pi(\\omega)\\,\\alpha_{\\mathrm{fwd}}(\\omega \\to \\omega') = \\pi(\\omega')\\,\\alpha_{\\mathrm{bwd}}(\\omega' \\to \\omega).\n$$\n你的程序必须生成一条长轨迹，并对每个同时存在 $$\\omega$$ 和 $$\\omega'$$ 的容许起始索引 $$s$$，计算：\n- 前移接受概率 $$\\alpha_{\\mathrm{fwd}}$$ 和后移接受概率 $$\\alpha_{\\mathrm{bwd}}$$，\n- 一个在所有容许的 $$s$$ 上定义的数值细致平衡差异度量，其定义为最大绝对差\n$$\n\\max_s \\left| \\log\\left(\\pi(\\omega)\\,\\alpha_{\\mathrm{fwd}}(\\omega \\to \\omega')\\right) - \\log\\left(\\pi(\\omega')\\,\\alpha_{\\mathrm{bwd}}(\\omega' \\to \\omega)\\right) \\right|.\n$$\n所有对数均为自然对数。\n\n实现要求：\n- 使用指定的过阻尼朗之万恒温器。\n- 对每个测试用例，从 $$x_0 = 0$$ 开始生成一个 $$N$$ 步的轨迹，并使用固定的随机种子以保证可复现性。\n- 对每个容许的窗起始位置 $$s$$（即 $$x_{s+L+1}$$ 存在的位置），仅使用上述定义计算接受概率和细致平衡差异。为避免数值下溢，请以对数形式计算路径权重和差异。\n\n测试套件：\n- 用例 $$1$$: $$\\Delta t = 0.01$$, $$\\beta = 5.0$$, $$L = 25$$, $$N = 4000$$, 随机种子 $$= 12345$$。\n- 用例 $$2$$: $$\\Delta t = 0.05$$, $$\\beta = 1.0$$, $$L = 10$$, $$N = 3000$$, 随机种子 $$= 67890$$。\n- 用例 $$3$$: $$\\Delta t = 0.20$$, $$\\beta = 1.0$$, $$L = 5$$, $$N = 2000$$, 随机种子 $$= 24680$$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。结果必须严格按照以下顺序排列\n$$\n[\\overline{\\alpha}_{\\mathrm{fwd}}^{(1)}, \\overline{\\alpha}_{\\mathrm{bwd}}^{(1)}, D^{(1)}, \\overline{\\alpha}_{\\mathrm{fwd}}^{(2)}, \\overline{\\alpha}_{\\mathrm{bwd}}^{(2)}, D^{(2)}, \\overline{\\alpha}_{\\mathrm{fwd}}^{(3)}, \\overline{\\alpha}_{\\mathrm{bwd}}^{(3)}, D^{(3)}],\n$$\n其中 $$\\overline{\\alpha}_{\\mathrm{fwd}}^{(i)}$$ 是用例 $$i$$ 中所有容许窗的平均前移接受率，$$\\overline{\\alpha}_{\\mathrm{bwd}}^{(i)}$$ 是平均后移接受率，$$D^{(i)}$$ 是如上定义的最大细致平衡差异，所有值均以浮点数形式报告。",
            "solution": "该问题被评估为有效。它在科学上基于统计力学和随机模拟的原理，特别是关于过阻尼朗之万方程和过渡路径采样 (TPS)。该问题是良定的，为理论推导和数值实现提供了所有必要的定义、参数和明确的目标。语言客观，要求明确。\n\n### 第1部分：接受概率比的推导\n\n目标是为过渡路径采样中的单步窗移移动的接受概率推导一个简化表达式。接受概率取决于路径权重的比率 $R = \\frac{\\pi(\\omega')}{\\pi(\\omega)}$，其中 $\\omega$ 是当前路径窗，$\\omega'$ 是提议的路径窗。\n\n一个长度为 $L$ 次跃迁的路径窗由 $\\omega = (x_s, x_{s+1}, \\dots, x_{s+L})$ 给出。其未归一化的路径权重定义为：\n$$\n\\pi(\\omega) = \\rho(x_s)\\prod_{k=s}^{s+L-1} p(x_{k+1}\\mid x_k)\n$$\n其中 $\\rho(x) \\propto \\exp(-\\beta U(x))$ 是稳态密度，而 $p(x_{k+1}|x_k)$ 是马尔可夫跃迁概率密度。\n\n提议的窗 $\\omega'$ 是 $\\omega$ 的单步前移：\n$$\n\\omega' = (x_{s+1}, x_{s+2}, \\dots, x_{s+L+1})\n$$\n这个新路径窗的权重是：\n$$\n\\pi(\\omega') = \\rho(x_{s+1})\\prod_{k=s+1}^{s+L} p(x_{k+1}\\mid x_k)\n$$\n\n因此，路径权重的比率为：\n$$\nR = \\frac{\\pi(\\omega')}{\\pi(\\omega)} = \\frac{\\rho(x_{s+1})\\prod_{k=s+1}^{s+L} p(x_{k+1}\\mid x_k)}{\\rho(x_s)\\prod_{k=s}^{s+L-1} p(x_{k+1}\\mid x_k)}\n$$\n分子和分母中的乘积项共享一个公共因子 $\\prod_{k=s+1}^{s+L-1} p(x_{k+1}\\mid x_k)$。消去这个公共因子可以得到显著的简化：\n$$\nR = \\frac{\\rho(x_{s+1}) \\cdot p(x_{s+L+1}\\mid x_{s+L})}{\\rho(x_s) \\cdot p(x_{s+1}\\mid x_s)}\n$$\n这表明该比率仅取决于原始和提议片段的端点：$x_s$、$x_{s+1}$、$x_{s+L}$ 和 $x_{s+L+1}$。\n\n为保证数值稳定性，我们使用比率的自然对数 $\\log R$。\n$$\n\\log R = \\log\\left(\\frac{\\rho(x_{s+1})}{\\rho(x_s)}\\right) + \\log\\left(\\frac{p(x_{s+L+1}\\mid x_{s+L})}{p(x_{s+1}\\mid x_s)}\\right)\n$$\n代入给定的定义：\n1.  稳态密度之比：由于 $\\rho(x) \\propto \\exp(-\\beta U(x))$，任何归一化常数都会被消掉。\n    $$\n    \\log\\left(\\frac{\\rho(x_{s+1})}{\\rho(x_s)}\\right) = \\log\\left(\\frac{\\exp(-\\beta U(x_{s+1}))}{\\exp(-\\beta U(x_s))}\\right) = -\\beta(U(x_{s+1}) - U(x_s))\n    $$\n2.  跃迁密度之比：跃迁密度是高斯分布 $p(x_{k+1}\\mid x_k) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp\\left(-\\frac{\\left(x_{k+1} - \\mu(x_k)\\right)^2}{2\\sigma^2}\\right)$。归一化常数 $\\frac{1}{\\sqrt{2\\pi\\sigma^2}}$ 在比率中被消掉。\n    $$\n    \\log\\left(\\frac{p(x_{s+L+1}\\mid x_{s+L})}{p(x_{s+1}\\mid x_s)}\\right) = -\\frac{(x_{s+L+1} - \\mu(x_{s+L}))^2}{2\\sigma^2} - \\left(-\\frac{(x_{s+1} - \\mu(x_s))^2}{2\\sigma^2}\\right)\n    $$\n    $$\n    = -\\frac{1}{2\\sigma^2}\\left[ (x_{s+L+1} - \\mu(x_{s+L}))^2 - (x_{s+1} - \\mu(x_s))^2 \\right]\n    $$\n    当 $\\sigma^2 = \\frac{2\\Delta t}{\\beta}$ 时，前置因子变为 $\\frac{1}{2\\sigma^2} = \\frac{\\beta}{4\\Delta t}$。\n\n结合这些项，得到 $\\log R$ 的最终表达式：\n$$\n\\log R = -\\beta(U(x_{s+1}) - U(x_s)) - \\frac{\\beta}{4\\Delta t}\\left[ (x_{s+L+1} - (x_{s+L} - \\Delta t \\nabla U(x_{s+L})))^2 - (x_{s+1} - (x_s - \\Delta t \\nabla U(x_s)))^2 \\right]\n$$\n该表达式仅依赖于端点和给定的模型参数，符合要求。\n\n### 第2部分：细致平衡的验证\n\n对于对称提议（以相同概率选择前移或后移），细致平衡是正确蒙特卡洛模拟的基本要求。其条件是：\n$$\n\\pi(\\omega) P(\\omega \\to \\omega') = \\pi(\\omega') P(\\omega' \\to \\omega)\n$$\n对于 Metropolis 接受准则，跃迁概率是提议概率（它是对称的，因此可以消掉）乘以接受概率。因此，细致平衡简化为：\n$$\n\\pi(\\omega)\\,\\alpha_{\\mathrm{fwd}}(\\omega \\to \\omega') = \\pi(\\omega')\\,\\alpha_{\\mathrm{bwd}}(\\omega' \\to \\omega)\n$$\n其中 $\\alpha_{\\mathrm{fwd}} = \\min(1, R)$ 且 $\\alpha_{\\mathrm{bwd}} = \\min(1, 1/R)$，其中 $R = \\pi(\\omega') / \\pi(\\omega)$。通过考虑 $R \\le 1$ 和 $R > 1$ 的情况，可以证明这个恒等式在解析上是成立的。\n\n数值实验旨在对生成的轨迹验证此恒等式在浮点精度范围内成立。该问题通过对等式两边取自然对数，并计算其在所有可能窗上的最大绝对差来定义一个差异度量：\n$$\nD = \\max_s \\left| \\log\\left(\\pi(\\omega)\\,\\alpha_{\\mathrm{fwd}}(\\omega \\to \\omega')\\right) - \\log\\left(\\pi(\\omega')\\,\\alpha_{\\mathrm{bwd}}(\\omega' \\to \\omega)\\right) \\right|\n$$\n解析上，绝对值内的差为零。数值测试中任何非零值都将归因于浮点运算的限制。\n\n### 第3部分：算法实现\n\n数值验证按以下步骤进行：\n\n1.  **轨迹生成**：对每个测试用例，生成一条长度为 $N+1$ 的轨迹 $(x_0, x_1, \\dots, x_N)$。从 $x_0 = 0$ 开始，后续点使用过阻尼朗之万方程的欧拉-丸山格式计算：\n    $$\n    x_{k+1} = x_k - \\Delta t\\, \\nabla U(x_k) + \\sqrt{\\frac{2\\Delta t}{\\beta}}\\,\\xi_k\n    $$\n    其中 $\\xi_k$ 从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取。固定的随机种子确保了可复现性。\n\n2.  **窗迭代**：算法遍历路径窗 $\\omega = (x_s, \\dots, x_{s+L})$ 的所有容许起始索引 $s$。为了使窗 $\\omega$ 及其后继窗 $\\omega'$ 完全包含在轨迹内，最后一个必需的点是 $x_{s+L+1}$。因此，$s+L+1$ 必须小于或等于轨迹的最大索引 $N$。循环的范围是 $s \\in [0, N-L-1]$。\n\n3.  **对数概率计算**：为避免因乘以许多小概率而导致的数值下溢/上溢，所有路径权重计算都在对数空间中进行。\n    *   对整条轨迹预先计算每一步的对数概率 $\\log p(x_{k+1}|x_k)$。\n    *   对于每个从 $s$ 开始的窗，其对数权重计算如下：\n        $$\n        \\log \\pi(\\omega) = \\log\\rho(x_s) + \\sum_{k=s}^{s+L-1} \\log p(x_{k+1}|x_k)\n        $$\n        此处，我们使用 $\\log\\rho(x) = -\\beta U(x)$，因为任何归一化常数都将在最终的差异计算中被抵消。移位窗的对数权重 $\\log \\pi(\\omega')$ 也以类似方式计算。\n\n4.  **接受与差异**：\n    *   对于每对窗 $(\\omega, \\omega')$，使用第1部分中推导出的高效公式计算对数比 $\\log R$。\n    *   计算接受概率 $\\alpha_{\\mathrm{fwd}} = \\min(1, \\exp(\\log R))$ 和 $\\alpha_{\\mathrm{bwd}} = \\min(1, \\exp(-\\log R))$，并收集它们的值以计算平均值。\n    *   计算对数细致平衡方程的两边，$A = \\log(\\pi(\\omega)) + \\log(\\alpha_{\\mathrm{fwd}})$ 和 $B = \\log(\\pi(\\omega')) + \\log(\\alpha_{\\mathrm{bwd}})$。需要特别注意接受概率下溢为 $0$ 的情况，此时其对数为 $-\\infty$。如果 $A$ 和 $B$ 均为 $-\\infty$，则它们的差为 $0$。\n    *   计算绝对差 $|A-B|$，并在所有 $s$ 上追踪其最大值作为差异 $D$。\n\n5.  **输出**：对于每个测试用例，收集平均前移接受概率、平均后移接受概率和最大细致平衡差异，并将其格式化为最终的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs Transition Path Sampling analysis for a 1D double-well potential.\n    \n    This function implements the full workflow described in the problem:\n    1. Derives and uses the simplified acceptance probability for a window-shift move.\n    2. Verifies detailed balance numerically by calculating a discrepancy metric.\n    3. Runs the analysis for a given set of test cases and formats the output.\n    \"\"\"\n\n    # Helper functions for potential energy and its gradient\n    def U(x):\n        \"\"\"Potential energy U(x) = 1/4 * (x^2 - 1)^2\"\"\"\n        x_sq = x * x\n        term = x_sq - 1.0\n        return 0.25 * term * term\n\n    def grad_U(x):\n        \"\"\"Gradient of potential energy grad_U(x) = x^3 - x\"\"\"\n        return x * (x * x - 1.0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (dt, beta, L, N, seed)\n        (0.01, 5.0, 25, 4000, 12345),\n        (0.05, 1.0, 10, 3000, 67890),\n        (0.20, 1.0, 5, 2000, 24680),\n    ]\n\n    results = []\n    for dt, beta, L, N, seed in test_cases:\n        rng = np.random.default_rng(seed)\n\n        # 1. Generate trajectory of N steps, resulting in N+1 points (x_0, ..., x_N)\n        x = np.zeros(N + 1)\n        x[0] = 0.0\n        \n        force_factor = dt\n        noise_std = np.sqrt(2.0 * dt / beta)\n\n        for k in range(N):\n            force = -grad_U(x[k])\n            noise = rng.normal(0.0, 1.0)\n            x[k+1] = x[k] + force_factor * force + noise_std * noise\n\n        # 2. Initialize statistics collection\n        fwd_alphas = []\n        bwd_alphas = []\n        max_discrepancy = 0.0\n\n        # 3. Pre-compute log transition probabilities log p(x_{k+1}|x_k)\n        sigma_sq = 2.0 * dt / beta\n        log_p_norm_const = -0.5 * np.log(2.0 * np.pi * sigma_sq)\n        log_ps = np.zeros(N)\n        for k in range(N):\n            mu_k = x[k] - dt * grad_U(x[k])\n            log_ps[k] = log_p_norm_const - (x[k+1] - mu_k)**2 / (2.0 * sigma_sq)\n\n        # 4. Iterate over all admissible windows\n        # Admissible s is where s+L+1 = N, so s runs from 0 to N-L-1.\n        num_windows = N - L\n        for s in range(num_windows):\n            # Define window endpoints\n            x_s, x_s1, x_sL, x_sL1 = x[s], x[s+1], x[s+L], x[s+L+1]\n\n            # Calculate log R = log(pi'/pi) using the derived simplified formula\n            mu_s = x_s - dt * grad_U(x_s)\n            mu_sL = x_sL - dt * grad_U(x_sL)\n            \n            U_s1 = U(x_s1)\n            U_s = U(x_s)\n            \n            log_R = -beta * (U_s1 - U_s) \\\n                    - (1.0 / (2.0 * sigma_sq)) * ((x_sL1 - mu_sL)**2 - (x_s1 - mu_s)**2)\n\n            # Calculate and store acceptance probabilities\n            alpha_fwd = min(1.0, np.exp(log_R))\n            alpha_bwd = min(1.0, np.exp(-log_R))\n            fwd_alphas.append(alpha_fwd)\n            bwd_alphas.append(alpha_bwd)\n\n            # Detailed balance check using explicit path weights in log form\n            # log pi(omega) = log rho(x_s) + sum_{k=s..s+L-1} log p(x_{k+1}|x_k)\n            # log rho(x) = -beta * U(x) (unnormalized)\n            \n            log_pi_omega = -beta * U(x_s) + np.sum(log_ps[s:s+L])\n            log_pi_omega_prime = -beta * U(x_s1) + np.sum(log_ps[s+1:s+L+1])\n            \n            # log(alpha) can be -inf if alpha is 0. Handle this to avoid NaN from inf-inf.\n            log_alpha_fwd = np.log(alpha_fwd) if alpha_fwd > 0 else -np.inf\n            log_alpha_bwd = np.log(alpha_bwd) if alpha_bwd > 0 else -np.inf\n\n            log_lhs = log_pi_omega + log_alpha_fwd\n            log_rhs = log_pi_omega_prime + log_alpha_bwd\n            \n            # If both sides are -inf, the discrepancy is 0.\n            if log_lhs == -np.inf and log_rhs == -np.inf:\n                discrepancy = 0.0\n            else:\n                discrepancy = np.abs(log_lhs - log_rhs)\n            \n            if discrepancy > max_discrepancy:\n                max_discrepancy = discrepancy\n        \n        # 5. Aggregate results for the current test case\n        mean_fwd_alpha = np.mean(fwd_alphas)\n        mean_bwd_alpha = np.mean(bwd_alphas)\n        results.extend([mean_fwd_alpha, mean_bwd_alpha, max_discrepancy])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在稀有事件模拟中，一个核心挑战是反应速率常数的计算往往伴随着巨大的统计方差。本练习介绍了一种高级的方差缩减技术，它巧妙地结合了KMC和TPS的思想。你将学习如何使用短时KMC模拟来估计提交者概率（committor probability），并将其作为一个控制变量，嵌入到反应速率的估计器中，从而显著降低统计误差。这项实践不仅展示了不同模拟方法的协同作用，也为你提供了解决复杂系统中速率计算难题的有力工具。",
            "id": "3358229",
            "problem": "考虑一个一维生灭马尔可夫链，其离散状态为 $i \\in \\{0,1,\\dots,N\\}$，其演化过程中的前向和后向转移速率满足关于指定双势阱的细致平衡条件。设左亚稳盆为 $A = \\{0,1,\\dots,a\\}$，右亚稳盆为 $B = \\{b,b+1,\\dots,N\\}$，其中 $0  a  b  N$。定义分割面为从状态 $a$到状态 $a+1$ 的单步跨越。能量景观是一个双势阱，由一个以两个极小值点 $i_{\\mathrm{L}}$ 和 $i_{\\mathrm{R}}$ 为中心的四次多项式形成，其幅度由一个正常数 $\\alpha$ 控制。状态 $i$ 的势能为\n$$\nU(i) = \\alpha \\left(i - i_{\\mathrm{L}}\\right)^2 \\left(i - i_{\\mathrm{R}}\\right)^2,\n$$\n转移速率的构造是为了强制满足关于玻尔兹曼分布的细致平衡，其中无量纲的逆温度已被吸收到 $\\alpha$ 中，采用对称选择\n$$\nr_i^{+} = \\exp\\left(-\\frac{U(i+1) - U(i)}{2}\\right), \\quad r_i^{-} = \\exp\\left(-\\frac{U(i-1) - U(i)}{2}\\right),\n$$\n对于 $1 \\le i \\le N-1$，且 $r_0^{-} = 0$ 和 $r_N^{+} = 0$。平稳分布为\n$$\n\\pi(i) = \\frac{\\exp\\left(-U(i)\\right)}{\\sum_{j=0}^{N} \\exp\\left(-U(j)\\right)}.\n$$\n定义提交者函数 (committor function) $q(i)$ 为从状态 $i$ 开始，动力学过程在到达盆 $A$ 之前先到达盆 $B$ 的概率。对于 $a  i  b$，提交者函数满足后向方程，\n$$\nr_i^{-} \\left[q(i-1) - q(i)\\right] + r_i^{+} \\left[q(i+1) - q(i)\\right] = 0,\n$$\n边界条件为，当 $i \\le a$ 时 $q(i) = 0$，当 $i \\ge b$ 时 $q(i) = 1$。\n\n过渡路径取样 (Transition Path Sampling, TPS) 生成从 $A$ 到 $B$ 的反应轨迹。一个常见的从 $A$ 到 $B$ 的反应速率常数的估计量，是基于将速率分解为跨越分割面的通量与给定出射穿越后提交到 $B$ 的概率的平均乘积。你的任务是构建此反应速率的方差缩减估计量，使用一种控制变量法，该控制变量源自用于估计发射点 (shooting point) 提交者函数的短时动态蒙特卡洛 (Kinetic Monte Carlo, kMC) 猝发。此处的 kMC 动力学简化为具有最近邻跳跃的随机行走，在状态 $i$ 处，跳到 $i+1$ 的概率为\n$$\np_i^{+} = \\frac{r_i^{+}}{r_i^{+} + r_i^{-}}, \\quad p_i^{-} = 1 - p_i^{+}.\n$$\n\n你必须从第一性原理出发：\n\n- 使用提交者函数的定义和可逆马尔可夫链的性质，推导出反应速率常数的表达式，该表达式应以跨越分割面的平稳通量和在刚离开 $A$ 的状态上评估的提交者函数来表示。不要从任何现成的速率公式开始；从通量和首次通过概率的定义推导它。\n- 设计一个基于 TPS 的估计量，其中每条路径都是从发射点 $i = a+1$ 开始，并演化 kMC 动力学，直到在 $A$ 或 $B$ 中被吸收。设 $X$ 为一个抽样轨迹在到达 $A$ 之前先到达 $B$ 的指示变量。\n- 使用 $K$ 个独立的短时 kMC 猝发来估计在 $i = a+1$ 处的提交者函数，这些猝发从 $i = a+1$ 开始，直到触及 $A$ 或 $B$ 为止，得到无偏蒙特卡洛估计量 $Y$，即到达 $B$ 的猝发所占的比例。将 $Y$ 作为控制变量嵌入到反应速率的 TPS 估计量中。使用控制变量形式 $X_{\\mathrm{cv}} = X - c\\,(Y - \\mu)$，其中系数 $c$ 通过在固定无偏性的前提下最小化方差来优化选择，并且 $\\mu = \\mathbb{E}[Y]$ 必须等于在所选初始状态分布（对于 $i = a+1$）下 $Y$ 的精确均值。\n- 通过求解精确的提交者函数 $q(i)$ 并在 $i = a+1$ 处使用后向方程对其进行评估来计算 $\\mu$，然后根据单一发射点的选择进行适当的平均。使用此 $\\mu$ 来保证控制变量的无偏性。\n- 对于下面的每个测试用例，生成 $M$ 条 TPS 路径和相关的控制变量，计算普通反应速率估计值和控制变量反应速率估计值，并报告它们的样本方差。所有量都是无单位浮点数。最终答案必须通过固定每个测试用例中给出的随机种子来保证可复现。\n\n测试套件由三组参数组成。对于每种情况，系统参数由元组 $(N, i_{\\mathrm{L}}, i_{\\mathrm{R}}, \\alpha, a, b, M, K, \\text{seed})$ 给出。使用以下值：\n\n- 情况 1 (中等势垒，理想路径): $(50, 10, 40, 2 \\times 10^{-5}, 12, 38, 8000, 8, 123)$。\n- 情况 2 (更高势垒，更稀有事件): $(50, 10, 40, 4 \\times 10^{-5}, 12, 38, 12000, 8, 456)$。\n- 情况 3 (较低势垒，接近对称的提交概率): $(50, 10, 40, 1 \\times 10^{-5}, 12, 38, 8000, 8, 789)$。\n\n对于每个测试用例：\n\n- 从第一性原理出发，推导并计算在边缘 $i = a \\rightarrow i = a+1$ 处离开 $A$ 并穿过分割面的平稳通量。\n- 计算处于盆 $A$ 中的平稳概率，并将其与通量和提交者函数结合以获得反应速率估计值。\n- 从 $i = a+1$ 开始生成 $M$ 条 TPS 路径，并记录 $X$ 作为在到达 $A$ 之前先到达 $B$ 的指示变量。使用普通估计量估计反应速率，并计算其均值的样本方差。\n- 对于每条抽样路径，独立地从 $i = a+1$ 开始生成 $K$ 个 kMC 猝发，以计算 $Y$ 作为经验提交者估计量。计算在 $i = a+1$ 处的精确提交者函数，并将 $\\mu$ 设置为此值。使用从联合样本中经验确定的最优 $c$ 构建控制变量估计量，并计算其均值的样本方差。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表应为每个测试用例包含一个子列表，每个子列表必须为 $[k_{\\mathrm{plain}}, k_{\\mathrm{cv}}, \\sigma^2_{\\mathrm{plain}}, \\sigma^2_{\\mathrm{cv}}]$ 的形式，其中 $k_{\\mathrm{plain}}$ 和 $k_{\\mathrm{cv}}$ 分别是普通反应速率估计值和控制变量反应速率估计值，$\\sigma^2_{\\mathrm{plain}}$ 和 $\\sigma^2_{\\mathrm{cv}}$ 是它们对应的均值的样本方差。例如，你的输出必须看起来像 $[[k_1^{\\mathrm{plain}},k_1^{\\mathrm{cv}},\\sigma^2_{1,\\mathrm{plain}},\\sigma^2_{1,\\mathrm{cv}}],[k_2^{\\mathrm{plain}},k_2^{\\mathrm{cv}},\\sigma^2_{2,\\mathrm{plain}},\\sigma^2_{2,\\mathrm{cv}}],[k_3^{\\mathrm{plain}},k_3^{\\mathrm{cv}},\\sigma^2_{3,\\mathrm{plain}},\\sigma^2_{3,\\mathrm{cv}}]]$，所有条目均为无单位浮点数。不应打印任何附加文本。",
            "solution": "用户提供了有效的问题陈述。\n\n该问题要求估计一个在一维双势阱上生灭过程的反应速率常数。估计将使用普通的蒙特卡洛方法和一种更高级的、用于方差缩减的控制变量方法来执行。该解决方案涉及解析推导、线性系统数值解和蒙特卡洛模拟的结合。\n\n### 1. 反应速率常数的推导\n\n反应速率常数 $k_{A \\to B}$ 量化了从亚稳反应物盆 $A$ 到产物盆 $B$ 的转变速率。我们基于平稳通量的概念，从第一性原理推导其表达式。\n\n设系统处于由分布 $\\pi(i) = C \\exp(-U(i))$ 描述的平稳状态，其中 $C$ 是一个归一化常数。系统处于反应物盆 $A = \\{0, 1, \\dots, a\\}$ 的总概率为 $P_A = \\sum_{i=0}^{a} \\pi(i)$。\n\n反应事件的速率，定义为从 $A$ 到 $B$ 而不返回 $A$ 的转变，可以表示为离开 $A$ 的轨迹总通量与这些离开的轨迹提交到 $B$ 的概率的乘积。\n\n在这个一维系统中，离开盆 $A$ 的唯一出口是从状态 $i=a$ 到 $i=a+1$ 的转变。产生这种转变的轨迹的平稳通量由处于状态 $a$ 的平稳概率与从 $a$ 出发的前向速率的乘积给出：\n$$\n\\Phi_{A \\to A^c} = \\pi(a) r_a^{+}\n$$\n其中 $A^c$ 是 $A$ 的补集。这里，$r_a^{+}$ 是从状态 $a$ 出发的前向转移速率。\n\n一旦一条轨迹穿过分割面并到达状态 $a+1$，它可能继续前往盆 $B$ 或返回盆 $A$。从状态 $i$ 开始的轨迹在返回 $A$ 之前到达盆 $B$ 的概率由提交者函数 $q(i)$ 给出。因此，一条刚在状态 $a+1$ 离开 $A$ 的轨迹将发生反应并到达 $B$ 的概率是 $q(a+1)$。\n\n反应通量 $J_{A \\to B}$ 是离开 $A$ 的总通量乘以这个提交概率：\n$$\nJ_{A \\to B} = \\Phi_{A \\to A^c} \\cdot q(a+1) = \\pi(a) r_a^{+} q(a+1)\n$$\n速率常数 $k_{A \\to B}$ 定义为反应物态 $A$ 中每单位布居的反应通量。因此，\n$$\nk_{A \\to B} = \\frac{J_{A \\to B}}{P_A} = \\frac{\\pi(a) r_a^{+} q(a+1)}{\\sum_{i=0}^{a} \\pi(i)}\n$$\n这个表达式构成了我们估计量的基础。量 $\\pi(i)$ 和 $r_a^{+}$ 仅依赖于势能 $U(i)$，可以直接计算。需要通过模拟来估计的关键量是提交者函数 $q(a+1)$。\n\n### 2. 精确提交者函数计算\n\n提交者函数 $q(i)$ 可以通过求解其对于中间状态 $i \\in \\{a+1, \\dots, b-1\\}$ 的主导后向主方程来精确确定。该方程反映了这样一个事实：从 $i$ 开始的轨迹，经过一步后，将处于 $i-1$ 或 $i+1$ 状态，而 $i$ 处的提交者值是这些相邻状态提交者值的加权平均。对于连续时间马尔可夫链，这导致：\n$$\nr_i^{-} \\left[q(i-1) - q(i)\\right] + r_i^{+} \\left[q(i+1) - q(i)\\right] = 0\n$$\n这可以重写为：\n$$\nr_i^{-} q(i-1) - (r_i^{-} + r_i^{+}) q(i) + r_i^{+} q(i+1) = 0\n$$\n边界条件由盆定义：任何在 $A$ 中开始的轨迹都已经返回到 $A$（因此它首先到达 $B$ 的概率为 $0$），任何在 $B$ 中开始的轨迹都已经到达了 $B$。\n$$\nq(i) = 0 \\quad \\text{对于 } i \\le a\n$$\n$$\nq(i) = 1 \\quad \\text{对于 } i \\ge b\n$$\n对于 $i = a+1, \\dots, b-1$ 的方程组构成了一个关于未知向量 $\\mathbf{q} = [q(a+1), \\dots, q(b-1)]^T$ 的三对角线性方程组。\n对于 $i = a+1$，方程为 $-(r_{a+1}^{-} + r_{a+1}^{+}) q(a+1) + r_{a+1}^{+} q(a+2) = 0$。\n对于 $i = b-1$，方程为 $r_{b-1}^{-} q(b-2) - (r_{b-1}^{-} + r_{b-1}^{+}) q(b-1) = -r_{b-1}^{+}$。\n该系统可以被高效求解，以找到所有中间状态的提交者函数的精确值，包括关键值 $q(a+1)$，我们将其表示为 $\\mu_q \\equiv q(a+1)$。\n\n### 3. 蒙特卡洛估计方案\n\n我们使用蒙特卡洛模拟来估计 $q(a+1)$。问题中描述的“TPS”方法涉及生成从发射点 $i=a+1$ 开始并根据 kMC 动力学演化的轨迹，直到它们被吸收进盆 $A$ 或 $B$ 中。\n\nkMC 动力学简化为一个离散时间随机行走，其中从状态 $i$ 移动到 $i+1$ 的概率是 $p_i^{+} = r_i^{+} / (r_i^{+} + r_i^{-})$，移动到 $i-1$ 的概率是 $p_i^{-} = 1 - p_i^{+}$。\n\n对于从 $i=a+1$ 开始的 $M$ 条模拟路径中的每一条，我们记录一个指示变量 $X_m$：\n$$\nX_m = \\begin{cases} 1  \\text{如果路径 } m \\text{ 在到达 } A \\text{ 之前先到达 } B \\\\ 0  \\text{如果路径 } m \\text{ 在到达 } B \\text{ 之前先到达 } A \\end{cases}\n$$\n$X_m$ 的期望值恰好是起始点的提交者函数，$\\mathbb{E}[X_m] = q(a+1)$。\n\n#### 3.1. 普通蒙特卡洛估计量\n\n$q(a+1)$ 的普通蒙特卡洛估计量是 $M$ 个路径结果的样本均值：\n$$\n\\hat{q}_{\\text{plain}} = \\frac{1}{M} \\sum_{m=1}^{M} X_m\n$$\n相应的速率常数估计值为：\n$$\nk_{\\text{plain}} = \\frac{\\pi(a) r_a^{+}}{\\sum_{i=0}^{a} \\pi(i)} \\cdot \\hat{q}_{\\text{plain}}\n$$\n\n#### 3.2. 控制变量估计量\n\n为了减少估计的方差，我们引入一个控制变量。对于每个主路径 $m$（它给我们 $X_m$），我们生成 $K$ 个额外的独立短时 kMC 猝发。每个猝发从 $i=a+1$ 开始并运行至被吸收，产生一个结果 $Y_{m,k} \\in \\{0, 1\\}$。我们构成一个辅助变量 $Y_m$：\n$$\nY_m = \\frac{1}{K} \\sum_{k=1}^{K} Y_{m,k}\n$$\n$Y_m$ 是 $q(a+1)$ 的另一个独立估计量。其期望值为 $\\mathbb{E}[Y_m] = q(a+1)$。我们使用从后向方程计算出的精确值 $\\mu_q = q(a+1)$。\n\n用于 $q(a+1)$ 的控制变量估计量构造如下：\n$$\n\\hat{q}_{\\mathrm{cv}} = \\frac{1}{M} \\sum_{m=1}^{M} \\left[ X_m - c(Y_m - \\mu_q) \\right]\n$$\n对于任何 $c$ 的选择，该估计量都是无偏的，因为 $\\mathbb{E}[Y_m - \\mu_q] = 0$。通过选择最优系数可以最小化方差：\n$$\nc^* = \\frac{\\mathrm{Cov}(X, Y)}{\\mathrm{Var}(Y)}\n$$\n在实践中，$c^*$ 从样本中估计：\n$$\n\\hat{c}^* = \\frac{\\sum_{m=1}^{M} (X_m - \\bar{X})(Y_m - \\bar{Y})}{\\sum_{m=1}^{M} (Y_m - \\bar{Y})^2}\n$$\n其中 $\\bar{X}$ 和 $\\bar{Y}$ 是样本均值。由此，$q(a+1)$ 的最终控制变量估计量为：\n$$\n\\hat{q}_{\\mathrm{cv}} = \\bar{X} - \\hat{c}^*(\\bar{Y} - \\mu_q)\n$$\n相应的速率常数估计值为：\n$$\nk_{\\mathrm{cv}} = \\frac{\\pi(a) r_a^{+}}{\\sum_{i=0}^{a} \\pi(i)} \\cdot \\hat{q}_{\\mathrm{cv}}\n$$\n\n### 4. 均值的方差\n\n估计量的性能通过其均值的样本方差进行比较。对于一个基于 $M$ 个样本 $Z_m$ 的估计量 $\\hat{\\theta}$，均值的方差估计为：\n$$\n\\sigma^2_{\\hat{\\theta}} = \\frac{s_Z^2}{M} = \\frac{1}{M(M-1)}\\sum_{m=1}^{M}(Z_m - \\bar{Z})^2\n$$\n对于普通估计量，样本为 $Z_m = X_m$。对于控制变量估计量，样本为 $Z_m = X_m - \\hat{c}^*(Y_m - \\mu_q)$。速率常数估计的方差 $\\sigma^2_{\\text{plain}}$ 和 $\\sigma^2_{\\text{cv}}$，是通过将 $\\hat{q}_{\\text{plain}}$ 和 $\\hat{q}_{\\text{cv}}$ 的方差乘以预因子 $\\mathcal{F} = \\frac{\\pi(a) r_a^{+}}{\\sum_{i=0}^{a} \\pi(i)}$ 的平方得到的。如果 $\\sigma^2_{\\mathrm{cv}}  \\sigma^2_{\\mathrm{plain}}$，则控制变量方法是有效的。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases, calculating reactive rate constants\n    and their variances using plain Monte Carlo and a control variate method.\n    \"\"\"\n    test_cases = [\n        # (N, i_L, i_R, alpha, a, b, M, K, seed)\n        (50, 10, 40, 2e-5, 12, 38, 8000, 8, 123),\n        (50, 10, 40, 4e-5, 12, 38, 12000, 8, 456),\n        (50, 10, 40, 1e-5, 12, 38, 8000, 8, 789),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, iL, iR, alpha, a, b, M, K, seed = case\n        \n        # 1. System setup\n        states = np.arange(N + 1)\n        # Potential energy U(i)\n        U = alpha * ((states - iL)**2) * ((states - iR)**2)\n        \n        # Transition rates r_i^+, r_i^-\n        # Note: rates_fwd[i] = r_i^+, rates_bwd[i] = r_i^-\n        rates_fwd = np.zeros(N + 1)\n        rates_bwd = np.zeros(N + 1)\n        \n        # Symmetric choice for rates\n        rates_fwd[:N] = np.exp(-(U[1:] - U[:-1]) / 2.0)\n        rates_bwd[1:] = np.exp(-(U[:-1] - U[1:]) / 2.0)\n        \n        # Stationary distribution pi(i)\n        # Numerical stability by shifting potential\n        U_shifted = U - np.min(U)\n        pi_unnormalized = np.exp(-U_shifted)\n        pi = pi_unnormalized / np.sum(pi_unnormalized)\n\n        # 2. Exact committor q(i)\n        # Solve the tridiagonal system for q(i) for i in {a+1, ..., b-1}\n        num_unknowns = b - a - 1\n        # Scipy's solve_banded expects matrix in a special format (l, u)\n        # l=1 (sub-diagonal), u=1 (super-diagonal)\n        ab = np.zeros((3, num_unknowns))\n        d = np.zeros(num_unknowns)\n        \n        # Main diagonal\n        ab[1, :] = -(rates_bwd[a+1:b] + rates_fwd[a+1:b])\n        # Super-diagonal (upper)\n        ab[0, 1:] = rates_fwd[a+1:b-1]\n        # Sub-diagonal (lower)\n        ab[2, :-1] = rates_bwd[a+2:b]\n        \n        # RHS vector for boundary conditions\n        # q(a)=0 contributes nothing\n        # q(b)=1 contributes at i=b-1\n        d[-1] = -rates_fwd[b-1] # from r_{b-1}^+ * q(b)\n        \n        q_intermediate = solve_banded((1, 1), ab, d)\n        \n        q = np.zeros(N + 1)\n        q[b:] = 1.0\n        q[a+1:b] = q_intermediate\n        \n        mu_q = q[a+1]\n\n        # 3. Rate prefactor F\n        flux_A_out = pi[a] * rates_fwd[a]\n        pop_A = np.sum(pi[:a+1])\n        F_prefactor = flux_A_out / pop_A\n\n        # 4. Monte Carlo simulation\n        rng = np.random.default_rng(seed)\n        \n        # Pre-calculate jump probabilities\n        p_plus = np.zeros(N + 1)\n        # Denominator can be zero at boundaries if a rate is zero. Handle safely.\n        rate_sum = rates_fwd + rates_bwd\n        # Only interior states are visited in the sim\n        valid_idx = (rate_sum  0)  (np.arange(N + 1)  a)  (np.arange(N + 1)  b)\n        p_plus[valid_idx] = rates_fwd[valid_idx] / rate_sum[valid_idx]\n\n        def run_kmc_path(start_i):\n            i = start_i\n            while a  i  b:\n                if rng.random()  p_plus[i]:\n                    i += 1\n                else:\n                    i -= 1\n            return 1 if i = b else 0\n\n        X_samples = np.zeros(M)\n        Y_samples = np.zeros(M)\n\n        for m in range(M):\n            # Main path for estimator X\n            X_samples[m] = run_kmc_path(a + 1)\n            \n            # K bursts for control variate Y\n            Y_m_bursts = np.zeros(K)\n            for k in range(K):\n                Y_m_bursts[k] = run_kmc_path(a + 1)\n            Y_samples[m] = np.mean(Y_m_bursts)\n\n        # 5. Analysis\n        # Plain estimator\n        q_hat_plain = np.mean(X_samples)\n        k_plain = F_prefactor * q_hat_plain\n        # Variance of the mean\n        var_q_plain = np.var(X_samples, ddof=1) / M\n        sigma2_plain = (F_prefactor**2) * var_q_plain\n\n        # Control variate estimator\n        var_Y = np.var(Y_samples, ddof=1)\n        if var_Y  1e-12:\n            cov_XY = np.cov(X_samples, Y_samples, ddof=1)[0, 1]\n            c_hat = cov_XY / var_Y\n        else: # Handle case of zero variance in Y\n            c_hat = 0.0\n\n        q_hat_cv = q_hat_plain - c_hat * (np.mean(Y_samples) - mu_q)\n        k_cv = F_prefactor * q_hat_cv\n        \n        # Calculate samples for CV estimator to find its variance\n        Z_samples = X_samples - c_hat * (Y_samples - mu_q)\n        var_q_cv = np.var(Z_samples, ddof=1) / M\n        sigma2_cv = (F_prefactor**2) * var_q_cv\n\n        results.append([k_plain, k_cv, sigma2_plain, sigma2_cv])\n\n    # Format the output as specified\n    sub_lists = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(sub_lists)}]\")\n\nsolve()\n```"
        }
    ]
}