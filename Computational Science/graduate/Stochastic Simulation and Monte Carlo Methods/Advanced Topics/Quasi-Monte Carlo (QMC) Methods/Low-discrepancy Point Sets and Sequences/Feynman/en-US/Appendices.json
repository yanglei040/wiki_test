{
    "hands_on_practices": [
        {
            "introduction": "Before constructing sophisticated low-discrepancy point sets, it is essential to have a quantitative tool to measure their uniformity. The star discrepancy, $D_N^*$, provides exactly this by measuring the worst-case deviation between the empirical distribution of a point set and the uniform distribution. This exercise  grounds the abstract definition in a concrete calculation for a simple one-dimensional equispaced point set, revealing the optimal convergence rate of $O(1/N)$ in one dimension.",
            "id": "3318540",
            "problem": "Let $N \\in \\mathbb{N}$ and consider the one-dimensional point set $P_N=\\{u_i\\}_{i=1}^{N}$ with $u_i = i/N$ in the unit interval. The star discrepancy $D_N^{*}(P)$ of a finite point set $P \\subset [0,1]$ in dimension $s=1$ is defined by\n$$\nD_N^{*}(P) \\;=\\; \\sup_{t \\in [0,1]} \\left| \\frac{1}{N} \\sum_{i=1}^{N} \\mathbf{1}\\{u_i \\in [0,t)\\} \\;-\\; t \\right|,\n$$\nwhere $\\mathbf{1}\\{\\cdot\\}$ denotes the indicator function. Starting from this definition and the basic properties of empirical distribution functions, compute the exact value of $D_N^{*}(P_N)$ for the given equispaced set $P_N$. Then, using only first principles about piecewise-constant empirical distribution functions and the fact that $t \\mapsto t$ is continuous, explain why the magnitude of $D_N^{*}(P)$ cannot decay faster than order $N^{-1}$ in one dimension, by proving a universal lower bound of the form $c/N$ for some constant $c > 0$ that does not depend on $P$. Your final numerical answer must be the exact value of $D_N^{*}(P_N)$ expressed as a single closed-form expression in $N$. Do not round.",
            "solution": "The problem asks for two distinct results: first, to compute the exact star discrepancy $D_N^{*}(P_N)$ for a specific one-dimensional equispaced point set $P_N=\\{u_i\\}_{i=1}^{N}$ with $u_i = i/N$; and second, to prove a universal lower bound on the star discrepancy for any one-dimensional point set, demonstrating that its convergence rate cannot be faster than $N^{-1}$.\n\nLet us begin by defining the primary objects. The empirical distribution function for a point set $P = \\{u_i\\}_{i=1}^{N} \\subset [0,1]$ is given by\n$$F_N(t) = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbf{1}\\{u_i \\in [0,t)\\}$$\nwhere $\\mathbf{1}\\{\\cdot\\}$ is the indicator function. The star discrepancy is the supremum norm of the difference between the empirical distribution function and the uniform distribution function $F(t) = t$:\n$$D_N^{*}(P) = \\sup_{t \\in [0,1]} |F_N(t) - t|$$\nLet us denote the discrepancy function as $D(t) = F_N(t) - t$.\n\n**Part 1: Calculation of $D_N^{*}(P_N)$ for the equispaced set**\n\nThe given point set is $P_N = \\{1/N, 2/N, \\dots, N/N=1\\}$. The points are already ordered. Note that the definition of $F_N(t)$ involves counting points $u_i$ in the half-open interval $[0,t)$, i.e., $u_i < t$.\n\nWe analyze the function $F_N(t)$ for $t \\in [0,1]$. The function $F_N(t)$ is a step function that changes its value only when $t$ crosses one of the points $u_i = i/N$. Let's analyze $F_N(t)$ on intervals defined by these points.\n\nLet $k$ be an integer from $0$ to $N$.\nFor $t$ in the interval $[k/N, (k+1)/N)$ for $k \\in \\{0, 1, \\dots, N-1\\}$:\nThe points $u_i = i/N$ from the set $P_N$ that satisfy $u_i < t$ are precisely $\\{1/N, 2/N, \\dots, k/N\\}$. There are $k$ such points. For $k=0$, there are no points.\nThus, for $t \\in [k/N, (k+1)/N)$, the empirical distribution function is $F_N(t) = k/N$.\n\nNow we compute the discrepancy function $D(t) = F_N(t) - t$ on these intervals:\nFor $t \\in [k/N, (k+1)/N)$, we have $D(t) = k/N - t$.\nSince $k/N \\le t < (k+1)/N$, it follows that $k/N - (k+1)/N < D(t) \\le k/N - k/N$, which simplifies to $-1/N < D(t) \\le 0$.\nThe magnitude of the discrepancy function on this interval is $|D(t)| = |k/N - t| = t - k/N$.\nThis is a monotonically increasing function of $t$ on the interval $[k/N, (k+1)/N)$. Therefore, its supremum on this interval is attained as $t$ approaches the right endpoint:\n$$\\sup_{t \\in [k/N, (k+1)/N)} |D(t)| = \\lim_{t \\to ((k+1)/N)^-} (t - k/N) = \\frac{k+1}{N} - \\frac{k}{N} = \\frac{1}{N}$$\nThis result holds for each $k \\in \\{0, 1, \\dots, N-1\\}$.\n\nFinally, we must consider the point $t=1$. At $t=1$, the interval is $[0,1)$, so we count the points $u_i < 1$. These points are $\\{1/N, 2/N, \\dots, (N-1)/N\\}$. There are $N-1$ such points.\nSo, $F_N(1) = (N-1)/N$.\nThe discrepancy at $t=1$ is $|D(1)| = |F_N(1) - 1| = |\\frac{N-1}{N} - 1| = |-\\frac{1}{N}| = \\frac{1}{N}$.\n\nThe star discrepancy $D_N^{*}(P_N)$ is the supremum of $|D(t)|$ over the entire interval $[0,1]$. Since on each subinterval $[k/N, (k+1)/N)$ the supremum of $|D(t)|$ is $1/N$, and the value at $t=1$ is also $1/N$, the overall supremum is\n$$D_N^{*}(P_N) = \\frac{1}{N}$$\n\n**Part 2: Universal Lower Bound for $D_N^{*}(P)$**\n\nNext, we prove that for any one-dimensional point set $P = \\{u_1, u_2, \\dots, u_N\\}$ in $[0,1]$, the star discrepancy $D_N^*(P)$ is bounded below by $c/N$ for some universal constant $c > 0$. We will use first principles regarding the properties of the functions involved.\n\nLet the points of $P$ be sorted, $0 \\le u_1 \\le u_2 \\le \\dots \\le u_N \\le 1$. We add auxiliary points $u_0 = 0$ and $u_{N+1}=1$.\nThe function $F_N(t)$ is a right-continuous step function. It is constant on any interval $[u_i, u_{i+1})$ for $i=0, \\dots, N$, assuming distinct points for simplicity of notation. The argument holds in general.\nAt each point $u_i$ in the set $P$, the function $F_N(t)$ exhibits a jump. Let's analyze the discrepancy function $D(t) = F_N(t) - t$ around one such point $u_i$.\n\nLet us consider the values of $D(t)$ just before and just after a point $u_i$. To handle multiple points at the same location, let $m_i = \\#\\{j : u_j < u_i\\}$ be the number of points strictly to the left of $u_i$, and $m'_i = \\#\\{j : u_j \\le u_i\\}$ be the number of points less than or equal to $u_i$. The number of points exactly at location $u_i$ is $j_i = m'_i - m_i \\ge 1$.\n\nIn the small interval just to the left of $u_i$, say for $t \\in (u_i-\\epsilon, u_i)$, $F_N(t)$ equals $m_i/N$. As $t \\to u_i^-$, the discrepancy function approaches:\n$$D(u_i^-) = \\lim_{t \\to u_i^-} D(t) = \\frac{m_i}{N} - u_i$$\nIn the small interval just to the right of $u_i$, say for $t \\in (u_i, u_i+\\epsilon)$, $F_N(t)$ equals $m'_i/N$. As $t \\to u_i^+$, the discrepancy function approaches:\n$$D(u_i^+) = \\lim_{t \\to u_i^+} D(t) = \\frac{m'_i}{N} - u_i = \\frac{m_i + j_i}{N} - u_i$$\nThe difference between these two limiting values is\n$$D(u_i^+) - D(u_i^-) = \\frac{j_i}{N}$$\n\nLet $K = D_N^*(P) = \\sup_{t \\in [0,1]} |D(t)|$. By the definition of the supremum, the values of $|D(t)|$ for all $t$, including the limits from the left and right at discontinuity points, must be less than or equal to $K$.\nTherefore, we must have:\n$$|D(u_i^-)| \\le K \\quad \\text{and} \\quad |D(u_i^+)| \\le K$$\nLet $x = D(u_i^-)$. Then $D(u_i^+) = x + j_i/N$. The conditions are $|x| \\le K$ and $|x + j_i/N| \\le K$.\n\nUsing the triangle inequality, we can write:\n$$ \\frac{j_i}{N} = \\left| \\frac{j_i}{N} \\right| = \\left| (x + \\frac{j_i}{N}) - x \\right| \\le \\left| x + \\frac{j_i}{N} \\right| + |-x| = \\left| x + \\frac{j_i}{N} \\right| + |x| $$\nApplying the bounds from the definition of $K$:\n$$ \\frac{j_i}{N} \\le K + K = 2K$$\nSince there is at least one point in the set $P$, there is at least one location $u_i$ where a jump occurs, so there exists an $i$ for which $j_i \\ge 1$. For that jump, we have:\n$$ \\frac{1}{N} \\le \\frac{j_i}{N} \\le 2K$$\nThis leads to the inequality $K \\ge 1/(2N)$.\n\nThus, for any $N$-point set $P$ in one dimension, its star discrepancy has the lower bound:\n$$D_N^*(P) \\ge \\frac{1}{2N}$$\nThis demonstrates that the discrepancy cannot decay to zero faster than the order $N^{-1}$. The constant $c$ in the problem description is $1/2$.\nThis completes the required explanation.\n\nThe final answer requested is the exact value of $D_N^*(P_N)$ computed in the first part.",
            "answer": "$$\\boxed{\\frac{1}{N}}$$"
        },
        {
            "introduction": "While measuring discrepancy is crucial, the true power of this field lies in constructing point sets that are provably uniform. Digital nets are a cornerstone of this constructive approach, using linear algebra over finite fields to generate highly regular point distributions. This practice  demystifies the abstract theory by guiding you through the step-by-step construction of a simple $(t,m,s)$-net, connecting the concepts of generating matrices and linear independence to a tangible set of points in the unit square.",
            "id": "3318561",
            "problem": "Consider the construction of a digital net in base $2$ for quasi-Monte Carlo (QMC) methods, using the foundational definition of a digital $(t,m,s)$-net over the Galois Field (GF) of two elements, denoted $\\mathrm{GF}(2)$. A digital $(t,m,s)$-net in base $2$ is specified by $s$ binary generating matrices $C_{1},\\dots,C_{s}$ of size $m \\times m$, and for each integer $n \\in \\{0,1,\\dots,2^{m}-1\\}$ with binary expansion $n = a_{0} + a_{1} 2 + \\cdots + a_{m-1} 2^{m-1}$, the point $\\boldsymbol{x}_{n} \\in [0,1)^{s}$ has coordinates $x_{j} = \\sum_{r=1}^{m} y_{j,r} 2^{-r}$, where $y_{j} = C_{j} a$ is computed over $\\mathrm{GF}(2)$ and $a = (a_{0},\\dots,a_{m-1})^{\\top}$. The $(t,m,s)$-net property is determined by a linear independence condition on initial row blocks of the generating matrices, ensuring coverage regularity of elementary intervals.\n\nUsing only these principles:\n- Construct a specific digital $(t,m,s)$-net with $b=2$, $s=2$, $m=3$, and $t=1$ by choosing explicit binary generating matrices $C_{1}$ and $C_{2}$ of size $3 \\times 3$ over $\\mathrm{GF}(2)$ that satisfy the required linear independence condition for $t=1$.\n- Using your matrices, list the $2^{m} = 8$ points $\\boldsymbol{x}_{n} \\in [0,1)^{2}$ for $n=0,1,\\dots,7$.\n- Finally, determine the exact number of these points lying in the elementary interval $[0,\\tfrac{1}{2}) \\times [0,\\tfrac{1}{2})$.\n\nProvide the count of points in $[0,\\tfrac{1}{2}) \\times [0,\\tfrac{1}{2})$ as your final answer. No rounding is required, and no units are involved.",
            "solution": "The problem requires the construction of a specific digital $(t,m,s)$-net, the generation of its points, and the subsequent counting of points that fall within a specified sub-interval of the unit hypercube. The parameters for the net are given as base $b=2$, dimension $s=2$, resolution $m=3$, and quality parameter $t=1$.\n\nFirst, we formalize the condition for a set of points to be a digital $(t,m,s)$-net. A set of $b^m$ points in $[0,1)^s$ forms a digital $(t,m,s)$-net in base $b$ if every elementary interval of volume $b^{t-m}$ contains exactly $b^t$ points. This property is guaranteed if the $s$ generating matrices, $C_1, \\dots, C_s$, each of size $m \\times m$ over the Galois field $\\mathrm{GF}(b)$, satisfy a specific linear independence condition.\n\nFor the given parameters $b=2$, $s=2$, $m=3$, and $t=1$, the volume of the elementary intervals in question is $b^{t-m} = 2^{1-3} = 2^{-2} = \\frac{1}{4}$. The number of points in each such interval must be $b^t = 2^1 = 2$.\nThe linear independence condition that the generating matrices must satisfy is as follows: for any pair of non-negative integers $(d_1, d_2)$ such that $d_1 + d_2 = m-t = 3-1=2$, the set of vectors consisting of the first $d_1$ rows of matrix $C_1$ and the first $d_2$ rows of matrix $C_2$ must be linearly independent over $\\mathrm{GF}(2)$. The possible pairs $(d_1, d_2)$ satisfying $d_1+d_2=2$ are $(2,0)$, $(1,1)$, and $(0,2)$.\n\nOur first task is to construct two $3 \\times 3$ binary matrices, $C_1$ and $C_2$, that meet these criteria. A standard and valid choice is to select the identity matrix for $C_1$ and then construct a suitable $C_2$. Let us define:\n$$\nC_1 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}, \\quad C_2 = \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 1 & 0 & 0 \\end{pmatrix}\n$$\nWe must verify that this choice satisfies the linear independence conditions:\n1.  For $(d_1, d_2) = (2,0)$: We consider the first $2$ rows of $C_1$. These are the vectors $(1,0,0)$ and $(0,1,0)$. They are linearly independent over $\\mathrm{GF}(2)$.\n2.  For $(d_1, d_2) = (1,1)$: We consider the first row of $C_1$, which is $(1,0,0)$, and the first row of $C_2$, which is $(0,1,0)$. These two vectors are linearly independent over $\\mathrm{GF}(2)$.\n3.  For $(d_1, d_2) = (0,2)$: We consider the first $2$ rows of $C_2$. These are the vectors $(0,1,0)$ and $(0,0,1)$. They are linearly independent over $\\mathrm{GF}(2)$.\nSince all conditions are met, this choice of $C_1$ and $C_2$ generates a valid $(1,3,2)$-net.\n\nNext, we generate the $2^m=2^3=8$ points of the net. For each integer $n \\in \\{0, 1, \\dots, 7\\}$, we first find its binary expansion $n = a_0 + a_1 2^1 + a_2 2^2$, which gives the input vector $a = (a_0, a_1, a_2)^\\top$. The coordinates of the point $\\boldsymbol{x}_n = (x_1, x_2)$ are determined by the vectors $y_1=C_1 a$ and $y_2=C_2 a$, where arithmetic is in $\\mathrm{GF}(2)$.\nFor $y_j = (y_{j,1}, y_{j,2}, y_{j,3})^\\top$, the coordinate is $x_j = \\sum_{r=1}^3 y_{j,r} 2^{-r}$.\nUsing our chosen matrices:\n$y_1 = C_1 a = I a = (a_0, a_1, a_2)^\\top$\n$y_2 = C_2 a = \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 1 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{pmatrix} = \\begin{pmatrix} a_1 \\\\ a_2 \\\\ a_0 \\end{pmatrix}$\n\nWe can now list the $8$ points:\n-   $n=0$: $a=(0,0,0)^\\top$. $y_1=(0,0,0)^\\top \\implies x_1=0$. $y_2=(0,0,0)^\\top \\implies x_2=0$. Point: $(0,0)$.\n-   $n=1$: $a=(1,0,0)^\\top$. $y_1=(1,0,0)^\\top \\implies x_1=\\frac{1}{2}$. $y_2=(0,0,1)^\\top \\implies x_2=\\frac{1}{8}$. Point: $(\\frac{1}{2}, \\frac{1}{8})$.\n-   $n=2$: $a=(0,1,0)^\\top$. $y_1=(0,1,0)^\\top \\implies x_1=\\frac{1}{4}$. $y_2=(1,0,0)^\\top \\implies x_2=\\frac{1}{2}$. Point: $(\\frac{1}{4}, \\frac{1}{2})$.\n-   $n=3$: $a=(1,1,0)^\\top$. $y_1=(1,1,0)^\\top \\implies x_1=\\frac{1}{2}+\\frac{1}{4}=\\frac{3}{4}$. $y_2=(1,0,1)^\\top \\implies x_2=\\frac{1}{2}+\\frac{1}{8}=\\frac{5}{8}$. Point: $(\\frac{3}{4}, \\frac{5}{8})$.\n-   $n=4$: $a=(0,0,1)^\\top$. $y_1=(0,0,1)^\\top \\implies x_1=\\frac{1}{8}$. $y_2=(0,1,0)^\\top \\implies x_2=\\frac{1}{4}$. Point: $(\\frac{1}{8}, \\frac{1}{4})$.\n-   $n=5$: $a=(1,0,1)^\\top$. $y_1=(1,0,1)^\\top \\implies x_1=\\frac{1}{2}+\\frac{1}{8}=\\frac{5}{8}$. $y_2=(0,1,1)^\\top \\implies x_2=\\frac{1}{4}+\\frac{1}{8}=\\frac{3}{8}$. Point: $(\\frac{5}{8}, \\frac{3}{8})$.\n-   $n=6$: $a=(0,1,1)^\\top$. $y_1=(0,1,1)^\\top \\implies x_1=\\frac{1}{4}+\\frac{1}{8}=\\frac{3}{8}$. $y_2=(1,1,0)^\\top \\implies x_2=\\frac{1}{2}+\\frac{1}{4}=\\frac{3}{4}$. Point: $(\\frac{3}{8}, \\frac{3}{4})$.\n-   $n=7$: $a=(1,1,1)^\\top$. $y_1=(1,1,1)^\\top \\implies x_1=\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}=\\frac{7}{8}$. $y_2=(1,1,1)^\\top \\implies x_2=\\frac{7}{8}$. Point: $(\\frac{7}{8}, \\frac{7}{8})$.\n\nFinally, we must determine the number of these points lying in the elementary interval $[0,\\frac{1}{2}) \\times [0,\\frac{1}{2})$. A point $(x_1, x_2)$ is in this interval if and only if $0 \\le x_1 < \\frac{1}{2}$ and $0 \\le x_2 < \\frac{1}{2}$.\nThe condition $x_j < \\frac{1}{2}$ is equivalent to the first fractional binary digit of $x_j$ being $0$. This first digit is $y_{j,1}$. Thus, we are counting the number of points for which $y_{1,1}=0$ and $y_{2,1}=0$.\nFrom our generating formulas, this translates to the conditions:\n$y_{1,1} = a_0 = 0$\n$y_{2,1} = a_1 = 0$\nThe third component of the input vector, $a_2$, is unconstrained and can be either $0$ or $1$. This gives us two possible input vectors $a$:\n1.  $a=(0,0,0)^\\top$: This corresponds to $n=0$, and the point is $\\boldsymbol{x}_0 = (0,0)$.\n2.  $a=(0,0,1)^\\top$: This corresponds to $n=4$, and the point is $\\boldsymbol{x}_4 = (\\frac{1}{8},\\frac{1}{4})$.\n\nBoth points, $\\boldsymbol{x}_0=(0,0)$ and $\\boldsymbol{x}_4=(\\frac{1}{8},\\frac{1}{4})$, satisfy the conditions $x_1< \\frac{1}{2}$ and $x_2< \\frac{1}{2}$. The other six points correspond to cases where $a_0=1$ or $a_1=1$ (or both), leading to $x_1 \\ge \\frac{1}{2}$ or $x_2 \\ge \\frac{1}{2}$.\nTherefore, exactly two points from the constructed set lie in the specified interval. This result confirms the theoretical expectation for a $(1,3,2)$-net, as the interval has volume $2^{t-m}$ and thus must contain $2^t=2$ points.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "Building on the foundational concepts of discrepancy and net construction, this exercise challenges you to implement one of the most famous low-discrepancy sequences: the Sobol' sequence. You will generate points from first principles using direction numbers and Gray codes, and then evaluate their quality using the squared $L^2$ star discrepancy, $D_{N,2}^{*}(P)^2$. This capstone practice  synthesizes theory and implementation, providing you with the practical skills needed to generate and analyze a workhorse of quasi-Monte Carlo methods.",
            "id": "3318583",
            "problem": "You are given the task of constructing a digital net of Sobol’ points in dimension $s=2$ using specified direction numbers and, from those points, estimating the quadratic discrepancy (also known as the $L^2$ star discrepancy) by explicit numerical evaluation of its defining integral. The objective is to start from foundational definitions for digital sequences and discrepancy, derive a principled algorithm, and implement it as a complete program. The final output must adhere to the specified format.\n\nFundamental base:\n- A Sobol’ sequence is a specific type of digital sequence over base $b=2$ characterized by binary direction numbers. For dimension $s=2$, the $j$-th direction number in coordinate $d \\in \\{1,2\\}$ is the rational number $v_{d,j} = m_{d,j} / 2^j$, where the integer $m_{d,j}$ is odd and satisfies $0 < m_{d,j} < 2^j$.\n- The $n$-th point in a Sobol’ sequence is constructed from the Gray code of $n$, denoted $g(n)$, defined by $g(n) = n \\oplus \\lfloor n/2 \\rfloor$ where $\\oplus$ denotes bitwise exclusive-or on nonnegative integers. If $g(n)$ has its $j$-th binary bit equal to $1$, then the $v_{d,j}$ contributes in coordinate $d$ via bitwise composition in the fixed-point binary representation. This yields $x_{n,d} \\in [0,1)$ for $d=1,2$.\n- The $L^2$ star discrepancy of a finite point set $P = \\{x_1,\\dots,x_N\\} \\subset [0,1)^s$, with $x_i = (x_{i,1}, x_{i,2})$, is defined via the empirical distribution function $F_N(u) = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{x_{i,1} < u_1, x_{i,2} < u_2\\}$ for $u \\in [0,1]^2$. The $L^2$ star discrepancy squared is the integral\n$$\nD_{N,2}^{*}(P)^2 \\;=\\; \\int_{[0,1]^2} \\left(F_N(u) - u_1 u_2 \\right)^2 \\, \\mathrm{d}u_1 \\, \\mathrm{d}u_2.\n$$\nYou must evaluate this integral numerically from first principles, without appealing to unproven shortcut formulas.\n\nDirection numbers to be used:\n- For coordinate $d=1$, use $m_{1,j} = 1$ for all $j \\ge 1$, hence $v_{1,j} = 2^{-j}$.\n- For coordinate $d=2$, use the primitive polynomial over the finite field of two elements $\\mathbb{F}_2$ given by $x^2 + x + 1$ and the initial seeds $m_{2,1} = 1$, $m_{2,2} = 1$. For all $j \\ge 3$, define\n$$\nm_{2,j} \\;=\\; \\left(2 \\, m_{2,j-1}\\right) \\;\\oplus\\; m_{2,j-2},\n$$\nand set $v_{2,j} = m_{2,j} / 2^j$. Here, multiplication by $2$ is a left bit-shift by one position and $\\oplus$ denotes bitwise exclusive-or. This recurrence ensures $m_{2,j}$ is odd and $m_{2,j} < 2^j$.\n\nPoint generation:\n- Use the Gray code construction to form the fixed-point binary representation $x_{n,d}$ in $[0,1)$ as the bitwise exclusive-or over direction numbers indexed by the set bits of $g(n)$. Interpret the composed bit-pattern as a fraction in base $2$.\n\nDiscrepancy evaluation:\n- Starting from the definition of $D_{N,2}^{*}(P)^2$ as an integral of squared deviation between the empirical distribution and the volume $u_1 u_2$ of anchored boxes, derive a numerically exact algorithm suitable for deterministic computation. Your derivation must rely only on well-tested facts such as linearity of integration, Fubini’s theorem for product integrals over $[0,1]^2$, and properties of indicator functions of orthants $[0,u)$.\n\nTasks:\n1. Generate the first $N$ Sobol’ points in dimension $s=2$ using the provided direction numbers and the Gray code construction. Your program must support the following test suite of values $N \\in \\{1,2,16\\}$ and output the $L^2$ star discrepancy squared for each $N$.\n2. Evaluate $D_{N,2}^{*}(P)^2$ numerically by reducing the defining integral to expressions computable from the point set $P$. The evaluation must be exact in floating-point arithmetic up to rounding error; do not use Monte Carlo sampling to approximate the integral.\n3. Aggregate results for all test cases into a single line, formatted as a comma-separated list enclosed in square brackets.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3]$, where each $r_i$ is the computed $L^2$ star discrepancy squared for the corresponding $N$ in the order $N=1$, $N=2$, $N=16$.\n\nNo physical units or angle units apply. All numerical quantities in the output must be real numbers (floating-point) in standard decimal notation. The program must be standalone and require no external input.",
            "solution": "## ALGORITHMIC DESIGN AND DERIVATION\n\nThe solution involves two principal components: first, the derivation of a computable formula for the squared $L^2$ star discrepancy from its integral definition, and second, the implementation of an algorithm to generate the required Sobol' points.\n\n### 1. Derivation of the $L^2$ Star Discrepancy Formula\n\nWe start from the definition of the squared $L^2$ star discrepancy for a point set $P = \\{x_1, \\dots, x_N\\} \\subset [0,1)^2$:\n$$ D_{N,2}^{*}(P)^2 = \\int_{[0,1]^2} \\left( F_N(u) - u_1 u_2 \\right)^2 \\, \\mathrm{d}u $$\nwhere $u = (u_1, u_2)$ and $F_N(u) = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{x_i < u\\}$, with $\\mathbf{1}\\{x_i < u\\}$ being an indicator function that is $1$ if $x_{i,d} < u_d$ for all dimensions $d=1, 2$, and $0$ otherwise.\n\nWe expand the integrand:\n$$ \\left( F_N(u) - u_1 u_2 \\right)^2 = F_N(u)^2 - 2 F_N(u) u_1 u_2 + (u_1 u_2)^2 $$\nBy linearity of integration, we can evaluate the integral of each term separately over the unit hypercube $[0,1]^2$.\n\n**Term 1: $\\int_{[0,1]^2} (u_1 u_2)^2 \\, \\mathrm{d}u$**\nThis integral evaluates to:\n$$ \\int_0^1 \\int_0^1 u_1^2 u_2^2 \\, \\mathrm{d}u_1 \\mathrm{d}u_2 = \\left(\\int_0^1 t^2 \\, \\mathrm{d}t\\right) \\left(\\int_0^1 t^2 \\, \\mathrm{d}t\\right) = \\left( \\left[ \\frac{t^3}{3} \\right]_0^1 \\right)^2 = \\left(\\frac{1}{3}\\right)^2 = \\frac{1}{9} $$\n\n**Term 2: $\\int_{[0,1]^2} -2 F_N(u) u_1 u_2 \\, \\mathrm{d}u$**\nSubstituting the definition of $F_N(u)$ and exchanging summation and integration:\n$$ -2 \\int_{[0,1]^2} \\left(\\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{x_i < u\\}\\right) u_1 u_2 \\, \\mathrm{d}u = -\\frac{2}{N} \\sum_{i=1}^N \\int_{[0,1]^2} \\mathbf{1}\\{x_i < u\\} u_1 u_2 \\, \\mathrm{d}u $$\nThe indicator function restricts the integration domain to $[x_{i,1}, 1] \\times [x_{i,2}, 1]$.\n$$ \\int_{x_{i,1}}^1 u_1 \\, \\mathrm{d}u_1 \\cdot \\int_{x_{i,2}}^1 u_2 \\, \\mathrm{d}u_2 = \\left[\\frac{u_1^2}{2}\\right]_{x_{i,1}}^1 \\cdot \\left[\\frac{u_2^2}{2}\\right]_{x_{i,2}}^1 = \\frac{1 - x_{i,1}^2}{2} \\cdot \\frac{1 - x_{i,2}^2}{2} $$\nSumming over all points $i=1, \\dots, N$, this term becomes:\n$$ -\\frac{2}{N} \\sum_{i=1}^N \\frac{(1 - x_{i,1}^2)(1 - x_{i,2}^2)}{4} = -\\frac{1}{2N} \\sum_{i=1}^N (1 - x_{i,1}^2)(1 - x_{i,2}^2) $$\n\n**Term 3: $\\int_{[0,1]^2} F_N(u)^2 \\, \\mathrm{d}u$**\nWe expand $F_N(u)^2$:\n$$ F_N(u)^2 = \\left(\\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{x_i < u\\}\\right) \\left(\\frac{1}{N} \\sum_{j=1}^N \\mathbf{1}\\{x_j < u\\}\\right) = \\frac{1}{N^2} \\sum_{i=1}^N \\sum_{j=1}^N \\mathbf{1}\\{x_i < u\\} \\mathbf{1}\\{x_j < u\\} $$\nThe product of indicators is $\\mathbf{1}\\{x_i < u, x_j < u\\} = \\mathbf{1}\\{\\max(x_{i,1}, x_{j,1}) < u_1, \\max(x_{i,2}, x_{j,2}) < u_2\\}$. The integral becomes:\n$$ \\int_{\\max(x_{i,1}, x_{j,1})}^1 \\mathrm{d}u_1 \\cdot \\int_{\\max(x_{i,2}, x_{j,2})}^1 \\mathrm{d}u_2 = (1 - \\max(x_{i,1}, x_{j,1}))(1 - \\max(x_{i,2}, x_{j,2})) $$\nSumming over all pairs $(i, j)$, the third term is:\n$$ \\frac{1}{N^2} \\sum_{i=1}^N \\sum_{j=1}^N (1 - \\max(x_{i,1}, x_{j,1}))(1 - \\max(x_{i,2}, x_{j,2})) $$\n\n**Final Formula:**\nCombining all three terms, we obtain the numerically computable formula for the squared $L^2$ star discrepancy for $s=2$:\n$$ D_{N,2}^{*}(P)^2 = \\frac{1}{9} - \\frac{1}{2N} \\sum_{i=1}^N (1 - x_{i,1}^2)(1 - x_{i,2}^2) + \\frac{1}{N^2} \\sum_{i=1}^N \\sum_{j=1}^N (1 - \\max(x_{i,1}, x_{j,1}))(1 - \\max(x_{i,2}, x_{j,2})) $$\nThis formula is exact up to floating-point precision and can be implemented directly.\n\n### 2. Sobol' Point Generation Algorithm\nThe generation of the first $N$ Sobol' points $x_1, \\dots, x_N$ in dimension $s=2$ proceeds as follows:\n\n1.  **Pre-computation of Direction Numbers**: The direction numbers $v_{d,j} = m_{d,j}/2^j$ are needed. For computational purposes, we work with integer representations. We choose a number of bits $W$ for precision (e.g., $W=53$ for double-precision floats) and represent each $v_{d,j}$ as an integer $V_{d,j} = m_{d,j} \\cdot 2^{W-j}$.\n    -   **For $d=1$**: $m_{1,j}=1$ for all $j \\ge 1$. The integer direction numbers are $V_{1,j} = 1 \\cdot 2^{W-j}$.\n    -   **For $d=2$**: The integers $m_{2,j}$ are generated via the recurrence $m_{2,j} = (2 \\cdot m_{2,j-1}) \\oplus m_{2,j-2}$ for $j \\ge 3$, with initial seeds $m_{2,1}=1, m_{2,2}=1$. The multiplication by $2$ is a left bit-shift. The integer direction numbers are $V_{2,j} = m_{2,j} \\cdot 2^{W-j}$.\n    These integer vectors $V_1$ and $V_2$ are pre-computed for $j=1, \\dots, W$.\n\n2.  **Point Generation Loop**: We iterate from $n=1$ to $N$. For each $n$, we compute the coordinates $(x_{n,1}, x_{n,2})$.\n    a.  **Gray Code**: Compute the Gray code of $n$, $g(n) = n \\oplus (n \\gg 1)$, where `>>` is the right bit-shift operator, equivalent to $\\lfloor n/2 \\rfloor$.\n    b.  **XOR Sum**: The integer representation of the coordinate $x_{n,d}$ is found by XORing the direction numbers $V_{d,j}$ for which the $j$-th bit of $g(n)$ is $1$. Let $X_{n,d}$ be this integer result.\n    $$ X_{n,d} = \\bigoplus_{j: \\text{bit } j \\text{ of } g(n) \\text{ is } 1} V_{d,j} $$\n    This is implemented by iterating through the bits of $g(n)$.\n    c.  **Conversion to Float**: The final coordinate value is obtained by scaling the integer result back to the $[0,1)$ interval: $x_{n,d} = X_{n,d} / 2^W$.\n\nThis procedure generates the point set $P = \\{x_1, \\dots, x_N\\}$, which is then used as input to the discrepancy calculation function.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _precompute_direction_vectors(s, W):\n    \"\"\"\n    Pre-computes integer direction vectors for Sobol' sequence generation.\n    \n    Args:\n        s (int): The number of dimensions (fixed to 2 in this problem).\n        W (int): The number of bits for precision.\n\n    Returns:\n        A list of numpy arrays, where each array holds the integer direction\n        numbers for one dimension.\n    \"\"\"\n    direction_vectors = []\n\n    # Dimension 1\n    V1 = np.zeros(W, dtype=np.uint64)\n    for j in range(1, W + 1):\n        V1[j-1] = np.uint64(1)  np.uint64(W - j)\n    direction_vectors.append(V1)\n    \n    # Dimension 2\n    # Primitive polynomial: x^2 + x + 1\n    # Recurrence: m_j = (2 * m_{j-1}) XOR m_{j-2}\n    m2 = np.zeros(W + 1, dtype=np.uint64)\n    V2 = np.zeros(W, dtype=np.uint64)\n    # Seeds\n    m2[1], m2[2] = np.uint64(1), np.uint64(1)\n    # Recurrence for m_j\n    for j in range(3, W + 1):\n        m2[j] = (m2[j-1]  np.uint64(1)) ^ m2[j-2]\n    # Create integer direction numbers V_j = m_j * 2^(W-j)\n    for j in range(1, W + 1):\n        V2[j-1] = m2[j]  np.uint64(W - j)\n    direction_vectors.append(V2)\n    \n    return direction_vectors\n\ndef generate_sobol_points(N, s, W, direction_vectors):\n    \"\"\"\n    Generates N Sobol' points in s dimensions.\n\n    Args:\n        N (int): The number of points to generate.\n        s (int): The number of dimensions.\n        W (int): The number of bits for precision.\n        direction_vectors (list): Pre-computed integer direction vectors.\n\n    Returns:\n        A numpy array of shape (N, s) containing the Sobol' points.\n    \"\"\"\n    points = np.zeros((N, s))\n    two_pow_W = 2.0**W\n\n    # Generate points for n = 1, 2, ..., N\n    for n_idx in range(N):\n        n = n_idx + 1\n        gray_code = n ^ (n >> 1)\n        \n        # Start with a zero vector for the integer representation of the point\n        point_as_int = np.zeros(s, dtype=np.uint64)\n        \n        bit_pos = 0\n        while gray_code > 0:\n            if gray_code  1:\n                # If the bit is 1, XOR with the corresponding direction vector\n                for d in range(s):\n                    point_as_int[d] ^= direction_vectors[d][bit_pos]\n            \n            gray_code >>= 1\n            bit_pos += 1\n            \n        points[n_idx, :] = point_as_int.astype(float) / two_pow_W\n        \n    return points\n\ndef calculate_l2_star_discrepancy_squared(points):\n    \"\"\"\n    Calculates the squared L^2 star discrepancy of a 2D point set.\n\n    Args:\n        points (np.ndarray): An array of shape (N, 2) of points in [0,1)^2.\n\n    Returns:\n        float: The calculated squared L^2 star discrepancy.\n    \"\"\"\n    N = points.shape[0]\n    s = points.shape[1]\n\n    # This is a general formula for any s.\n    # Term 1: (1/3)^s\n    term1 = (1.0 / 3.0)**s\n\n    # Term 2: -(2^(1-s)/N) * sum_i prod_d (1-x_id^2)\n    term2_sum = np.sum(np.prod(1.0 - points**2, axis=1))\n    term2 = - (2.0**(1 - s) / N) * term2_sum\n\n    # Term 3: (1/N^2) * sum_{i,j} prod_{d=1..s} (1 - max(x_id, x_jd))\n    term3_sum = 0.0\n    for i in range(N):\n        for j in range(N):\n            max_coords = np.maximum(points[i,:], points[j,:])\n            term3_sum += np.prod(1.0 - max_coords)\n    term3 = term3_sum / (N**2)\n\n    return term1 + term2 + term3\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 16]\n    \n    # Parameters for Sobol' generation\n    s = 2\n    W = 53 # Precision bits, matching double-precision float mantissa\n\n    # Pre-compute direction vectors once\n    direction_vectors = _precompute_direction_vectors(s, W)\n\n    results = []\n    # Use a faster numpy-based calculation for term 3\n    def calculate_l2_star_discrepancy_squared_fast(points):\n        N = points.shape[0]\n        s = points.shape[1]\n        \n        term1 = (1.0 / 3.0)**s\n\n        term2_sum = np.sum(np.prod(1.0 - points**2, axis=1))\n        term2 = - (2.0**(1 - s) / N) * term2_sum\n\n        # Vectorized calculation for Term 3\n        max_coords1 = np.maximum.outer(points[:, 0], points[:, 0])\n        max_coords2 = np.maximum.outer(points[:, 1], points[:, 1])\n        term3_sum = np.sum((1.0 - max_coords1) * (1.0 - max_coords2))\n        term3 = term3_sum / (N**2)\n        \n        return term1 + term2 + term3\n\n    for N in test_cases:\n        # 1. Generate Sobol' points\n        points = generate_sobol_points(N, s, W, direction_vectors)\n\n        # 2. Calculate L^2 star discrepancy squared\n        discrepancy_sq = calculate_l2_star_discrepancy_squared_fast(points)\n        results.append(discrepancy_sq)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}