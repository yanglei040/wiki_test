{
    "hands_on_practices": [
        {
            "introduction": "要真正理解Faure序列，最好的起点是其最简单的一维形式，这在数值上等同于范德科皮特序列（van der Corput sequence）。这个练习将引导你手动计算一个基为$3$的序列的前几个点，从而将整数索引转换为在单位区间上均匀分布的点。通过直接验证其分层特性，你将直观地感受到低差异序列是如何实现其卓越的均匀性保证的。",
            "id": "3308091",
            "problem": "在使用低差异序列（LDS）的准蒙特卡罗（QMC）方法中，一维的 Faure 序列可简化为素数基底下的根倒函数。设基底为 $3$。对于任意非负整数 $n \\in \\mathbb{N}_{0}$，将其写成以 $3$ 为基底的展开式 $n = \\sum_{k=0}^{K} a_{k} 3^{k}$，其中各位数字 $a_{k} \\in \\{0,1,2\\}$。基底为 $3$ 的根倒函数定义为\n$$\n\\phi_{3}(n) = \\sum_{k=0}^{K} a_{k} 3^{-(k+1)}.\n$$\n这种构造是 Faure 序列一维分量的基本组成部分，并用于在 $[0,1)$ 上生成分层样本。\n\n计算当 $n=0,1,2,\\dots,9$ 时 $\\phi_{3}(n)$ 的值。然后，仅使用以 $3$ 为基底的数字表示和上述定义，验证集合 $\\{\\phi_{3}(n) : 0 \\leq n  3^{m}\\}$ 在每个区间\n$$\nI_{j,m} = \\left[\\frac{j}{3^{m}}, \\frac{j+1}{3^{m}}\\right), \\quad j = 0,1,\\dots,3^{m}-1,\n$$\n中恰好放置一个点，对于 $m=1$ 和 $m=2$ 的情况。将区间解释为左闭右开。\n\n在最终答案中，使用 LaTeX 的 $\\texttt{pmatrix}$ 环境，将前 $10$ 个 $\\phi_{3}(n)$ 项按 $n$ 递增的顺序作为一个单行向量报告。无需四舍五入，且不涉及物理单位。",
            "solution": "出发点是基底为 $3$ 的根倒函数 $\\phi_{3}(n)$ 的定义，该函数将 $n$ 的 $3$ 进制数字从整数次幂映射到负数次幂，从而在 $[0,1)$ 中产生一个点。这种数字反转机制是 Faure 序列和 van der Corput 序列一维分量的核心构造。\n\n首先，通过将每个 $n$ 表示为 $3$ 进制来计算当 $n=0,1,\\dots,9$ 时的 $\\phi_{3}(n)$：\n- 对于 $n=0$，其 $3$ 进制展开为 $0$，所以 $a_{0}=0$ 且\n$$\n\\phi_{3}(0) = 0.\n$$\n- 对于 $n=1$，其 $3$ 进制展开为 $1$，所以 $a_{0}=1$ 且\n$$\n\\phi_{3}(1) = \\frac{1}{3}.\n$$\n- 对于 $n=2$，其 $3$ 进制展开为 $2$，所以 $a_{0}=2$ 且\n$$\n\\phi_{3}(2) = \\frac{2}{3}.\n$$\n- 对于 $n=3$，其 $3$ 进制展开为 $10$，所以 $a_{0}=0$，$a_{1}=1$ 且\n$$\n\\phi_{3}(3) = \\frac{0}{3} + \\frac{1}{9} = \\frac{1}{9}.\n$$\n- 对于 $n=4$，其 $3$ 进制展开为 $11$，所以 $a_{0}=1$，$a_{1}=1$ 且\n$$\n\\phi_{3}(4) = \\frac{1}{3} + \\frac{1}{9} = \\frac{4}{9}.\n$$\n- 对于 $n=5$，其 $3$ 进制展开为 $12$，所以 $a_{0}=2$，$a_{1}=1$ 且\n$$\n\\phi_{3}(5) = \\frac{2}{3} + \\frac{1}{9} = \\frac{7}{9}.\n$$\n- 对于 $n=6$，其 $3$ 进制展开为 $20$，所以 $a_{0}=0$，$a_{1}=2$ 且\n$$\n\\phi_{3}(6) = \\frac{0}{3} + \\frac{2}{9} = \\frac{2}{9}.\n$$\n- 对于 $n=7$，其 $3$ 进制展开为 $21$，所以 $a_{0}=1$，$a_{1}=2$ 且\n$$\n\\phi_{3}(7) = \\frac{1}{3} + \\frac{2}{9} = \\frac{5}{9}.\n$$\n- 对于 $n=8$，其 $3$ 进制展开为 $22$，所以 $a_{0}=2$，$a_{1}=2$ 且\n$$\n\\phi_{3}(8) = \\frac{2}{3} + \\frac{2}{9} = \\frac{8}{9}.\n$$\n- 对于 $n=9$，其 $3$ 进制展开为 $100$，所以 $a_{0}=0$，$a_{1}=0$，$a_{2}=1$ 且\n$$\n\\phi_{3}(9) = \\frac{0}{3} + \\frac{0}{9} + \\frac{1}{27} = \\frac{1}{27}.\n$$\n\n因此，前 $10$ 项为\n$$\n\\phi_{3}(n) = 0,\\ \\frac{1}{3},\\ \\frac{2}{3},\\ \\frac{1}{9},\\ \\frac{4}{9},\\ \\frac{7}{9},\\ \\frac{2}{9},\\ \\frac{5}{9},\\ \\frac{8}{9},\\ \\frac{1}{27}\n$$\n分别对应 $n=0,1,\\dots,9$。\n\n接下来，验证对于 $m=1$ 和 $m=2$ 的情况，在长度为 $3^{-m}$ 的区间上的分层属性。考虑 $m \\in \\mathbb{N}$，且 $n$ 限制在 $0 \\leq n  3^{m}$。那么 $n$ 的 $3$ 进制展开最多使用 $m$ 位数字：\n$$\nn = \\sum_{k=0}^{m-1} a_{k} 3^{k}, \\quad a_{k} \\in \\{0,1,2\\}.\n$$\n根据 $\\phi_{3}(n)$ 的定义，\n$$\n\\phi_{3}(n) = \\sum_{k=0}^{m-1} a_{k} 3^{-(k+1)} = \\frac{1}{3^{m}} \\sum_{k=0}^{m-1} a_{k} 3^{m-1-k}.\n$$\n定义整数\n$$\nj(n) = \\sum_{k=0}^{m-1} a_{k} 3^{m-1-k}.\n$$\n由于从数字向量 $(a_{0},a_{1},\\dots,a_{m-1})$ 到 $j$ 的映射是从 $\\{0,1,2\\}^{m}$ 到 $\\{0,1,\\dots,3^{m}-1\\}$ 的一个双射（这正是标准的 $3$ 进制编码，但数字顺序相反），因此每种数字选择都产生一个唯一的 $j \\in \\{0,1,\\dots,3^{m}-1\\}$，反之，每个这样的 $j$ 也产生一个唯一的数字向量。因此，\n$$\n\\phi_{3}(n) = \\frac{j(n)}{3^{m}},\n$$\n并且当 $n$ 遍历 $0,1,\\dots,3^{m}-1$ 时，集合 $\\{\\phi_{3}(n)\\}$ 正是集合 $\\left\\{\\frac{j}{3^{m}} : j = 0,1,\\dots,3^{m}-1\\right\\}$，其中每个值恰好出现一次。\n\n这直接蕴含了分层属性：对于划分为左闭右开区间\n$$\nI_{j,m} = \\left[\\frac{j}{3^{m}}, \\frac{j+1}{3^{m}}\\right), \\quad j = 0,1,\\dots,3^{m}-1,\n$$\n每个区间 $I_{j,m}$ 包含集合 $\\{\\phi_{3}(n) : 0 \\leq n  3^{m}\\}$ 中的恰好一个点，即 $\\frac{j}{3^{m}}$ 本身。\n\n将此应用于所要求的特定情况：\n- 对于 $m=1$，集合 $\\{\\phi_{3}(n) : 0 \\leq n  3\\}$ 为 $\\{0,\\frac{1}{3},\\frac{2}{3}\\}$，区间为 $I_{0,1}=[0,\\frac{1}{3})$, $I_{1,1}=[\\frac{1}{3},\\frac{2}{3})$, $I_{2,1}=[\\frac{2}{3},1)$。在这些值中，每个区间恰好包含其左端点，因此每个区间中恰好有一个点。\n- 对于 $m=2$，集合 $\\{\\phi_{3}(n) : 0 \\leq n  9\\}$ 为 $\\left\\{\\frac{j}{9} : j=0,1,\\dots,8\\right\\}$，具体来说是以某种顺序排列的 $\\{0,\\frac{1}{9},\\frac{2}{9},\\dots,\\frac{8}{9}\\}$。区间 $I_{j,2}=\\left[\\frac{j}{9},\\frac{j+1}{9}\\right)$ 各自恰好包含该集合中的 $\\frac{j}{9}$，因此每个区间中恰好有一个点。\n\n因此，对于 $m=1$ 和 $m=2$，前 $3^m$ 个项在 $[0,1)$ 上对于长度为 $3^{-m}$ 的区间的所谓三进制划分是完美分层的。第十项 $\\phi_{3}(9)=\\frac{1}{27}$ 开始了对应于 $m=3$ 的下一个区块，并且与同样的数字反转原则一致。\n\n所要求的最终报告是按 $n$ 递增顺序排列的前 $10$ 项的行向量。",
            "answer": "$$\\boxed{\\begin{pmatrix}\n0  \\frac{1}{3}  \\frac{2}{3}  \\frac{1}{9}  \\frac{4}{9}  \\frac{7}{9}  \\frac{2}{9}  \\frac{5}{9}  \\frac{8}{9}  \\frac{1}{27}\n\\end{pmatrix}}$$"
        },
        {
            "introduction": "Faure序列的真正威力体现在高维空间中，其卓越的均匀性由$(t,m,s)$-net性质来量化。这个练习将带你深入Faure序列的代数核心，通过在有限域上构建生成矩阵来推导点的位置。你将通过直接计算证明，该序列的前$b^m$个点如何完美地填充了$s$维单位超立方体的每一个基本区间，揭示了其作为$(0,m,s)$-net的完美均匀性。",
            "id": "3308024",
            "problem": "考虑在准蒙特卡罗（QMC）方法中使用的低差异序列的数字构造。设基数为 $b=3$（一个素数），并考虑空间维度 $s=3$ 的 Faure 序列。在阶为 $3$ 的有限域上进行计算，记为 $\\mathbb{F}_{3}$。\n\n使用以下基本定义和事实：\n\n- 基数为 $b$ 的数字序列是通过将 $\\mathbb{F}_{b}$ 上的生成矩阵应用于非负整数索引 $n$ 的 $b$ 基数位向量来定义的。设 $n=\\sum_{k=0}^{\\infty} a_{k} b^{k}$，其中各位数字 $a_{k} \\in \\{0,1,\\dots,b-1\\}$，并将前 $m$ 位数字收集到列向量 $\\boldsymbol{a}=(a_{0},a_{1},\\dots,a_{m-1})^{\\top}$ 中。坐标 $j$ 的数字向量 $\\boldsymbol{y}^{(j)}=(y^{(j)}_{1},\\dots,y^{(j)}_{m})^{\\top}$ 是通过在 $\\mathbb{F}_{b}$ 上计算 $\\boldsymbol{y}^{(j)}=C_{j}\\,\\boldsymbol{a}$ 得到的，其中 $C_{j}$ 是一个下三角生成矩阵。在 $[0,1)$ 中的相应坐标是 $x^{(j)}(n)=\\sum_{r=1}^{m} y^{(j)}_{r}\\,b^{-r}$。\n- 在 $b$ 为素数且 $s \\leq b$ 的 Faure 构造中，矩阵 $C_{j}$ 是 Pascal 矩阵模 $b$ 的幂。设 $P$ 为下三角 Pascal 矩阵，其元素为 $p_{r,k} \\equiv \\binom{k-1}{r-1} \\bmod b$（对于 $1 \\leq r \\leq k \\leq m$），且当 $rk$ 时 $p_{r,k}=0$。则 $C_{j}=P^{j-1}$，其中 $j=1,2,\\dots,s$。\n\n取 $m=3$ 位数字。执行以下任务：\n\n1. 显式构造在 $\\mathbb{F}_{3}$ 上当 $m=3$ 时的矩阵 $P$、$P^{2}$，并由此得到 $C_{1}$、$C_{2}$、$C_{3}$。\n2. 使用这些 $C_{j}$，推导坐标 $x^{(1)}(n)$、$x^{(2)}(n)$、$x^{(3)}(n)$ 关于 $n$ 的基数-3 数字 $(a_{0},a_{1},a_{2})$ 的三位数公式，其中 $n=0,1,\\dots,26$（即对于所有 $\\boldsymbol{a} \\in \\mathbb{F}_{3}^{3}$）。\n3. 考虑在分辨率 $m=3$、等数字深度 $d_{1}=d_{2}=d_{3}=1$ 下，$[0,1)^{3}$中的 $3$-adic 基本盒集合。这些是 $3^{3}$ 个形如 $\\prod_{j=1}^{3} \\left[\\frac{t_{j}}{3},\\frac{t_{j}+1}{3}\\right)$ 的盒子，其中 $(t_{1},t_{2},t_{3}) \\in \\{0,1,2\\}^{3}$。仅使用上述形式化定义，确定 Faure 序列的前 $b^{m}=27$ 个点在这 $3^{3}$ 个盒子中的占据数。\n4. 定义用于检验这 $3^{3}$ 个盒子中均匀占据性的多项卡方统计量为\n$$\n\\chi^{2} \\;=\\; \\sum_{i=1}^{27} \\frac{(O_{i}-E_{i})^{2}}{E_{i}},\n$$\n其中 $O_{i}$ 是盒子 $i$ 中的观测计数，$E_{i}$ 是在完全均匀性下的期望计数。计算上述构造的 $27$ 个点的 $\\chi^{2}$ 值。将最终答案表示为单个实数值。无需四舍五入，不涉及物理单位。",
            "solution": "该问题要求对基数 $b=3$、维度 $s=3$、使用 $m=3$ 位数字的 Faure 序列进行多部分分析。该分析涉及构造生成矩阵、推导坐标公式、确定基本盒中的点分布以及计算卡方统计量。所有计算都在有限域 $\\mathbb{F}_{3}$ 上进行。\n\n**第1部分：生成矩阵的构造**\n\nFaure 序列的生成矩阵由 $C_{j} = P^{j-1}$ 给出，其中 $j=1, 2, \\dots, s$。这里，$s=3$，所以我们需要 $C_{1}$、$C_{2}$ 和 $C_{3}$。这需要计算在 $\\mathbb{F}_{3}$ 上的 $m \\times m = 3 \\times 3$ Pascal 矩阵 $P$ 及其平方 $P^{2}$。\n\n下三角 Pascal 矩阵 $P$ 的元素由 $p_{r,k} \\equiv \\binom{k-1}{r-1} \\pmod b$ 给出，其中 $1 \\le r \\le k \\le m$。当 $b=3$ 和 $m=3$ 时，元素计算如下（全部模 $3$）：\n$p_{1,1} = \\binom{1-1}{1-1} = \\binom{0}{0} = 1$\n$p_{1,2} = \\binom{2-1}{1-1} = \\binom{1}{0} = 1$\n$p_{2,2} = \\binom{2-1}{2-1} = \\binom{1}{1} = 1$\n$p_{1,3} = \\binom{3-1}{1-1} = \\binom{2}{0} = 1$\n$p_{2,3} = \\binom{3-1}{2-1} = \\binom{2}{1} = 2$\n$p_{3,3} = \\binom{3-1}{3-1} = \\binom{2}{2} = 1$\n所有其他元素 $p_{r,k}$（对于 $rk$）均为 $0$。这给出了矩阵：\n$$ P = \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix} $$\n接下来，我们在 $\\mathbb{F}_{3}$ 上计算 $P^{2}$：\n$$ P^{2} = P \\cdot P = \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix} $$\n$$ = \\begin{pmatrix} 1 \\cdot 1 + 1 \\cdot 0 + 1 \\cdot 0  1 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 0  1 \\cdot 1 + 1 \\cdot 2 + 1 \\cdot 1 \\\\ 0 \\cdot 1 + 1 \\cdot 0 + 2 \\cdot 0  0 \\cdot 1 + 1 \\cdot 1 + 2 \\cdot 0  0 \\cdot 1 + 1 \\cdot 2 + 2 \\cdot 1 \\\\ 0 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 0  0 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot 0  0 \\cdot 1 + 0 \\cdot 2 + 1 \\cdot 1 \\end{pmatrix} \\pmod 3 $$\n$$ = \\begin{pmatrix} 1  2  4 \\\\ 0  1  4 \\\\ 0  0  1 \\end{pmatrix} \\pmod 3 = \\begin{pmatrix} 1  2  1 \\\\ 0  1  1 \\\\ 0  0  1 \\end{pmatrix} $$\n对于 $j=1, 2, 3$，生成矩阵 $C_{j}$ 为：\n$C_{1} = P^{1-1} = P^{0} = I = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}$\n$C_{2} = P^{2-1} = P^{1} = P = \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix}$\n$C_{3} = P^{3-1} = P^{2} = \\begin{pmatrix} 1  2  1 \\\\ 0  1  1 \\\\ 0  0  1 \\end{pmatrix}$\n\n**第2部分：坐标公式**\n\n坐标 $j$ 的数字向量 $\\boldsymbol{y}^{(j)} = (y_1^{(j)}, y_2^{(j)}, y_3^{(j)})^{\\top}$ 是通过将 $C_j$ 应用于索引 $n = a_0 + 3a_1 + 9a_2$ 的基数-3 数字向量 $\\boldsymbol{a} = (a_0, a_1, a_2)^{\\top}$ 得到的。坐标值为 $x^{(j)}(n) = \\sum_{r=1}^{3} y_r^{(j)} 3^{-r}$。“三位数公式”是关于 $a_0, a_1, a_2$ 的数字 $y_r^{(j)}$ 的表达式。\n\n对于坐标 $j=1$：\n$\\boldsymbol{y}^{(1)} = C_1 \\boldsymbol{a} = I \\boldsymbol{a} = \\boldsymbol{a}$。\n$y_1^{(1)} = a_0$\n$y_2^{(1)} = a_1$\n$y_3^{(1)} = a_2$\n\n对于坐标 $j=2$：\n$\\boldsymbol{y}^{(2)} = C_2 \\boldsymbol{a} = P \\boldsymbol{a}$。\n$$ \\begin{pmatrix} y_1^{(2)} \\\\ y_2^{(2)} \\\\ y_3^{(2)} \\end{pmatrix} = \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{pmatrix} = \\begin{pmatrix} a_0 + a_1 + a_2 \\\\ a_1 + 2a_2 \\\\ a_2 \\end{pmatrix} \\pmod 3 $$\n\n对于坐标 $j=3$：\n$\\boldsymbol{y}^{(3)} = C_3 \\boldsymbol{a} = P^2 \\boldsymbol{a}$。\n$$ \\begin{pmatrix} y_1^{(3)} \\\\ y_2^{(3)} \\\\ y_3^{(3)} \\end{pmatrix} = \\begin{pmatrix} 1  2  1 \\\\ 0  1  1 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{pmatrix} = \\begin{pmatrix} a_0 + 2a_1 + a_2 \\\\ a_1 + a_2 \\\\ a_2 \\end{pmatrix} \\pmod 3 $$\n\n**第3部分：占据数**\n\n我们考虑 $3^3 = 27$ 个形如 $B_{t_1, t_2, t_3} = \\prod_{j=1}^{3} \\left[\\frac{t_{j}}{3},\\frac{t_{j}+1}{3}\\right)$ 的基本盒，其中 $(t_1, t_2, t_3) \\in \\{0,1,2\\}^3$。\n一个点 $\\boldsymbol{x}(n) = (x^{(1)}(n), x^{(2)}(n), x^{(3)}(n))$ 位于盒子 $B_{t_1, t_2, t_3}$ 中，当且仅当对每个 $j \\in \\{1,2,3\\}$，都有 $\\lfloor 3x^{(j)}(n) \\rfloor = t_j$。\n根据公式 $x^{(j)}(n) = \\frac{y_1^{(j)}}{3} + \\frac{y_2^{(j)}}{9} + \\frac{y_3^{(j)}}{27}$，我们有 $3x^{(j)}(n) = y_1^{(j)} + \\frac{y_2^{(j)}}{3} + \\frac{y_3^{(j)}}{9}$。由于 $y_r^{(j)} \\in \\{0, 1, 2\\}$，小数部分总是小于 $1$，因此 $\\lfloor 3x^{(j)}(n) \\rfloor = y_1^{(j)}$。\n因此，一个点 $\\boldsymbol{x}(n)$ 在盒子 $B_{t_1, t_2, t_3}$ 中，当且仅当其第一位数字的向量 $(y_1^{(1)}, y_1^{(2)}, y_1^{(3)})$ 等于 $(t_1, t_2, t_3)$。\n\n使用第2部分的公式，此条件可转化为关于输入数字 $(a_0, a_1, a_2)$ 在 $\\mathbb{F}_3$ 上的线性方程组：\n$$ y_1^{(1)} = a_0 = t_1 $$\n$$ y_1^{(2)} = a_0 + a_1 + a_2 = t_2 $$\n$$ y_1^{(3)} = a_0 + 2a_1 + a_2 = t_3 $$\n这可以写成矩阵形式 $M \\boldsymbol{a} = \\boldsymbol{t}$：\n$$ \\begin{pmatrix} 1  0  0 \\\\ 1  1  1 \\\\ 1  2  1 \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{pmatrix} = \\begin{pmatrix} t_1 \\\\ t_2 \\\\ t_3 \\end{pmatrix} $$\n给定盒子中的点数对应于相应的 $\\boldsymbol{t} \\in \\mathbb{F}_3^3$ 的解 $\\boldsymbol{a} \\in \\mathbb{F}_3^3$ 的数量。序列的前 $27$ 个点对应于 $n=0, 1, \\dots, 26$，这正好遍历了 $\\mathbb{F}_3^3$ 中所有可能的向量 $\\boldsymbol{a} = (a_0, a_1, a_2)^\\top$ 一次。\n为求得解的数量，我们通过计算其在 $\\mathbb{F}_3$ 上的行列式来检查矩阵 $M$ 是否可逆：\n$$ \\det(M) = 1 \\cdot \\det\\begin{pmatrix} 1  1 \\\\ 2  1 \\end{pmatrix} - 0 + 0 = 1(1 \\cdot 1 - 1 \\cdot 2) = 1 - 2 = -1 \\equiv 2 \\pmod 3 $$\n由于在 $\\mathbb{F}_3$ 中 $\\det(M) = 2 \\neq 0$，矩阵 $M$ 是可逆的。这意味着对于每个目标向量 $\\boldsymbol{t} = (t_1, t_2, t_3) \\in \\mathbb{F}_3^3$，都存在一个唯一解向量 $\\boldsymbol{a} = (a_0, a_1, a_2) \\in \\mathbb{F}_3^3$。\n因此，这 $27$ 个盒子中的每一个都恰好包含序列前 $27$ 个点中的一个点。每个盒子 $i$ 的占据数 $O_i$ 为 $1$。\n\n**第4部分：卡方统计量计算**\n\n多项卡方统计量由 $\\chi^{2} = \\sum_{i=1}^{27} \\frac{(O_{i}-E_{i})^{2}}{E_{i}}$ 给出。\n我们有 $N=27$ 个点分布在 $K=27$ 个盒子中。\n如第3部分所确定，观测计数 $O_i = 1$ 对所有 $i=1, \\dots, 27$ 成立。\n在完全均匀性假设下的期望计数 $E_i = N/K = 27/27 = 1$ 对所有 $i=1, \\dots, 27$ 成立。\n将这些值代入公式：\n$$ \\chi^{2} = \\sum_{i=1}^{27} \\frac{(1-1)^{2}}{1} = \\sum_{i=1}^{27} \\frac{0^2}{1} = \\sum_{i=1}^{27} 0 = 0 $$\n卡方统计量为 $0$，这表示前 $27$ 个 Faure 点的观测分布与这 $27$ 个基本盒上的均匀分布完全一致。这是被称为 $(t,m,s)$-nets 的低差异序列的一个特征。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "理论上的优雅必须与实际应用中的高效计算相结合。这个练习将挑战你从理论转向实践，设计并实现一个用于生成Faure序列的高效算法。通过利用生成矩阵的递推结构，你将学会如何避免计算成本高昂的矩阵幂运算，从而以$O(s m^2)$的复杂度计算出所有$s$个维度的坐标，这是在蒙特卡洛模拟中实际使用这些序列的关键一步。",
            "id": "3308045",
            "problem": "你的任务是构建并分析一个算法，用于在数字序列的框架内计算拟蒙特卡罗 (QMC) 模拟中使用的 Faure 低差异序列的坐标。在维度 $s$ 和基 $b$ 上的 Faure 序列的构造由一系列生成矩阵 $\\{C_j\\}_{j=1}^s$ 定义，这些矩阵源自一个由帕斯卡三角模 $b$ 构建的基矩阵 $B$。非负整数 $n$ 的 $b$ 进制表示写作 $n = \\sum_{k=0}^{m-1} n_k b^k$，其数字为 $(n_0,\\dots,n_{m-1})$，其中每个 $n_k \\in \\{0,1,\\dots,b-1\\}$。坐标 $x_j(n)$ 通过数字构造 $y^{(j)} = C_j \\cdot \\mathbf{n} \\pmod{b}$ 计算得出，其中 $\\mathbf{n} = (n_0,\\dots,n_{m-1})^\\top$，而实数 $x_j(n)$ 是由数字向量 $y^{(j)}$ 构成的 $b$ 进制逆进制函数，即 $x_j(n) = \\sum_{r=0}^{m-1} y^{(j)}_r b^{-(r+1)}$。该系列生成矩阵满足 $C_j = B^{j-1}$（算术运算在模 $b$ 下进行），其中 $B$ 是无限帕斯卡下三角矩阵，为便于计算截断为 $m \\times m$ 项，其项为 $B_{r,k} = \\binom{r}{k} \\bmod b$（对于 $0 \\leq k \\leq r$）否则为 $0$。你的任务是设计一个算法，给定 $n$ 及其 $b$ 进制数字 $(n_0,\\dots,n_{m-1})$，计算所有 $s$ 个坐标 $x_1(n),\\dots,x_s(n)$，仅使用模 $b$ 算术，并达到 $O(s m^2)$ 数量级的操作计数。\n\n仅使用模 $b$ 算术和帕斯卡三角的结构特性来构造 $B$ 并执行所需的矩阵向量乘积。从数字序列和帕斯卡三角的核心定义出发推导算法，并在不援引除定义关系 $C_j = B^{j-1}$ 之外的任何捷径公式的情况下，论证其时间复杂度为 $O(s m^2)$。\n\n将你的算法实现为一个完整的、可运行的程序。程序必须以 $m$ 位数字精度计算坐标向量，并将每个坐标转换为指定的实数 $x_j(n)$。每个实值坐标必须四舍五入到 $12$ 位小数。此问题不涉及物理单位。不涉及角度。不使用百分比。\n\n测试套件：\n对于每个测试用例，$b$ 是一个素数基，$s$ 是维度，$(n_0,\\dots,n_{m-1})$ 是 $n$ 的 $b$ 进制数字（最低有效位在前）。为完整起见，也给出了 $n$，但计算必须只使用其数字。\n\n- 案例 1：$b = 2$, $s = 3$, $m = 5$, 数字 $(n_0,\\dots,n_{4}) = (1,0,1,1,0)$, 整数 $n = 13$。\n- 案例 2：$b = 3$, $s = 4$, $m = 6$, 数字 $(n_0,\\dots,n_{5}) = (2,1,0,2,1,1)$, 整数 $n = 383$。\n- 案例 3：$b = 5$, $s = 1$, $m = 1$, 数字 $(n_0) = (4)$, 整数 $n = 4$。\n- 案例 4：$b = 7$, $s = 5$, $m = 4$, 数字 $(n_0,\\dots,n_{3}) = (6,0,3,1)$, 整数 $n = 496$。\n- 案例 5：$b = 3$, $s = 2$, $m = 3$, 数字 $(n_0,\\dots,n_{2}) = (0,0,0)$, 整数 $n = 0$。\n\n要求的最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果是其坐标在 $m$ 位数字精度下的 $s$ 个浮点数列表。例如，预期的结构是 $[[x_{1}^{(1)},\\dots,x_{s}^{(1)}],[x_{1}^{(2)},\\dots,x_{s}^{(2)}],\\dots]$，程序应精确打印这样的一行。每个浮点数必须四舍五入到 $12$ 位小数。",
            "solution": "该问题要求设计并实现一个算法，用于计算给定整数 $n$ 的 Faure 低差异序列的前 $s$ 个坐标。算法必须在指定的时间复杂度 $O(s m^2)$ 内运行，其中 $s$ 是维度数，$m$ 是用于精度的 $b$ 进制数字位数。解决方案必须从第一性原理出发推导并进行论证。\n\n### 步骤 1：Faure 序列的形式化定义\n\nFaure 序列是一种数字序列。其坐标是使用有限域上的线性代数构造的。\n\n设 $b$ 为素数基。非负整数 $n$ 以 $m$ 位 $b$ 进制数表示，最低有效位在前：\n$$\n\\mathbf{n} = (n_0, n_1, \\dots, n_{m-1})^\\top\n$$\n其中 $n = \\sum_{k=0}^{m-1} n_k b^k$，每个数字 $n_k \\in \\{0, 1, \\dots, b-1\\}$。\n\n序列中第 $n$ 个点的第 $j$ 个坐标，记为 $x_j(n)$，通过两步过程获得：\n1.  **数字置乱**：通过将生成矩阵 $C_j$ 应用于数字向量 $\\mathbf{n}$，计算出一个中间数字向量 $y^{(j)} = (y^{(j)}_0, y^{(j)}_1, \\dots, y^{(j)}_{m-1})^\\top$。所有算术运算都在模 $b$ 下进行：\n    $$\n    y^{(j)} = C_j \\cdot \\mathbf{n} \\pmod{b}\n    $$\n2.  **逆进制**：实值坐标 $x_j(n) \\in [0, 1)$ 是使用 $b$ 进制逆进制函数从 $y^{(j)}$ 的数字构造出来的：\n    $$\n    x_j(n) = \\sum_{r=0}^{m-1} y^{(j)}_r b^{-(r+1)}\n    $$\n\n$s$ 维 Faure 序列的生成矩阵 $\\{C_j\\}_{j=1}^s$ 定义为基矩阵 $B$ 的幂：\n$$\nC_j = B^{j-1} \\pmod{b} \\quad \\text{for } j=1, 2, \\dots, s\n$$\n矩阵 $C_1 = B^0$ 是 $m \\times m$ 的单位矩阵 $I$。\n\n基矩阵 $B$ 是 $m \\times m$ 的帕斯卡下三角矩阵，其元素是模 $b$ 的二项式系数：\n$$\nB_{r,k} = \\binom{r}{k} \\pmod{b} \\quad \\text{for } 0 \\le k \\le r  m\n$$\n且当 $k  r$ 时 $B_{r,k} = 0$。\n\n### 步骤 2：算法设计与复杂度分析\n\n一个直接的方法是先构造 $B$，然后对每个 $j$ 从 $1$到 $s$，计算 $C_j=B^{j-1}$，然后计算 $y^{(j)}=C_j \\mathbf{n}$。\n- 构造 $B$：这需要 $O(m^2)$ 次操作。\n- 计算 $C_j = B^{j-1}$：如果通过重复矩阵乘法（$C_j = B \\cdot C_{j-1}$）完成，每个新矩阵 $C_j$ 的计算成本为 $O(m^3)$。对于所有 $s$ 个维度，这将是 $O(s m^3)$。对于典型的 $m$ 和 $s$ 值，这在计算上是昂贵的，并且超出了要求的 $O(s m^2)$ 复杂度界限。\n\n为了达到期望的复杂度，我们必须避免显式计算每个完整的矩阵 $C_j$。关键的洞见在于重排操作顺序。我们不是先计算矩阵积 $B^{j-1}$，而是将矩阵依次应用于向量 $\\mathbf{n}$。\n\n我们希望计算向量序列 $y^{(1)}, y^{(2)}, \\dots, y^{(s)}$。\n- 对于 $j=1$：\n  $$\n  y^{(1)} = C_1 \\cdot \\mathbf{n} = B^0 \\cdot \\mathbf{n} = I \\cdot \\mathbf{n} = \\mathbf{n}\n  $$\n- 对于 $j1$，我们可以建立一个递推关系：\n  $$\n  y^{(j)} = C_j \\cdot \\mathbf{n} = B^{j-1} \\cdot \\mathbf{n} = B \\cdot (B^{j-2} \\cdot \\mathbf{n})\n  $$\n  认识到 $y^{(j-1)} = B^{j-2} \\cdot \\mathbf{n}$，我们得到：\n  $$\n  y^{(j)} = B \\cdot y^{(j-1)} \\pmod{b}\n  $$\n这个递推关系允许我们通过一次矩阵向量乘法，从前一个数字向量 $y^{(j-1)}$ 计算出每个后续的数字向量 $y^{(j)}$。\n\n### 步骤 3：$O(s m^2)$ 算法\n\n基于上述分析，高效的算法如下：\n\n1.  **构造基矩阵 $B$**：创建 $m \\times m$ 矩阵 $B$，其中 $B_{r,k} = \\binom{r}{k} \\pmod b$。这可以使用帕斯卡恒等式 $\\binom{r}{k} = \\binom{r-1}{k-1} + \\binom{r-1}{k}$ 在 $O(m^2)$ 时间内高效完成，该恒等式对任何整数 $b$ 取模都成立。我们逐行构建矩阵。\n    - 对每一行 $r=0, \\dots, m-1$：\n        - $B_{r,0} = \\binom{r}{0} = 1$。\n        - 对 $k=1, \\dots, r$：$B_{r,k} = (B_{r-1,k-1} + B_{r-1,k}) \\pmod b$。\n\n2.  **初始化**：\n    - 设 $y_{vec}$ 为当前置乱的数字向量。用 $n$ 的输入数字对其进行初始化：$y_{vec} \\leftarrow \\mathbf{n}$。\n    - 创建一个空列表来存储最终的坐标值。\n\n3.  **计算 $j=1$ 的坐标**：\n    - 第一个数字向量是 $y^{(1)} = \\mathbf{n}$。\n    - 计算 $x_1(n) = \\sum_{r=0}^{m-1} y_{vec}[r] \\cdot b^{-(r+1)}$。将此值添加到结果列表中。此步骤需要 $O(m)$ 时间。\n\n4.  **为 $j=2, \\dots, s$ 迭代**：\n    - 使用递推关系更新数字向量：$y_{vec} \\leftarrow B \\cdot y_{vec} \\pmod b$。这是一个矩阵向量乘法，需要 $O(m^2)$ 次操作。\n    - 计算坐标 $x_j(n) = \\sum_{r=0}^{m-1} y_{vec}[r] \\cdot b^{-(r+1)}$。这需要 $O(m)$ 时间。将其添加到结果列表中。\n\n### 步骤 4：最终复杂度论证\n\n该算法的总复杂度是其各部分复杂度之和：\n- 构造矩阵 $B$：$O(m^2)$。\n- 为 $j=2, \\dots, s$ 进行的迭代计算：有 $s-1$ 次迭代。每次迭代主要由矩阵向量乘法主导，成本为 $O(m^2)$。此循环的总成本为 $(s-1) \\times O(m^2) = O(s m^2)$。\n- 逆进制计算：有 $s$ 次这样的计算，每次耗时 $O(m)$。总成本为 $O(sm)$。\n\n总的时间复杂度为 $O(m^2 + s m^2 + sm) = O(s m^2)$，因为通常 $s \\ge 1$。这满足了问题的要求。该算法完全依赖于基本定义和模 $b$ 算术，符合规定。",
            "answer": "```python\nimport numpy as np\n\ndef compute_faure_coordinates(b, s, m, n_digits):\n    \"\"\"\n    Computes the first s coordinates of the Faure sequence for a given n.\n\n    Args:\n        b (int): The prime base.\n        s (int): The dimension of the sequence.\n        m (int): The number of digits for precision.\n        n_digits (tuple): The base-b digits of n, least significant first.\n\n    Returns:\n        list: A list of s float coordinates, rounded to 12 decimal places.\n    \"\"\"\n\n    # Step 1: Construct the m x m Pascal matrix B modulo b.\n    # The matrix B has entries B_rk = C(r, k) mod b.\n    # We use Pascal's identity: C(r, k) = C(r-1, k-1) + C(r-1, k).\n    B = np.zeros((m, m), dtype=int)\n    for r in range(m):\n        B[r, 0] = 1\n        for k in range(1, r + 1):\n            B[r, k] = (B[r - 1, k - 1] + B[r - 1, k]) % b\n\n    # Convert the input digits tuple to a NumPy column vector\n    n_vec = np.array(n_digits, dtype=int)\n\n    # list to store the final coordinate values\n    coordinates = []\n\n    # y_vec will hold the sequence of scrambled digit vectors y^(j)\n    y_vec = n_vec.copy()\n\n    # Step 2  3: Compute coordinate for j=1.\n    # For j=1, C_1 is the identity matrix, so y^(1) = n_vec.\n    # The radical inverse calculation converts the digit vector to a float.\n    if s  0:\n      val = 0.0\n      b_inv_power = 1.0 / b\n      for r in range(m):\n          val += y_vec[r] * b_inv_power\n          b_inv_power /= b\n      coordinates.append(round(val, 12))\n\n    # Step 4: Iterate for j=2 to s.\n    # Each subsequent y^(j) is obtained by multiplying the previous y^(j-1) by B.\n    for _ in range(2, s + 1):\n        # y^(j) = B * y^(j-1) mod b\n        y_vec = (B @ y_vec) % b\n\n        # Radical inverse calculation for the new y_vec\n        val = 0.0\n        b_inv_power = 1.0 / b\n        for r in range(m):\n            val += y_vec[r] * b_inv_power\n            b_inv_power /= b\n        coordinates.append(round(val, 12))\n\n    return coordinates\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: b=2, s=3, m=5, n_digits=(1,0,1,1,0), n=13\n        {'b': 2, 's': 3, 'm': 5, 'n_digits': (1, 0, 1, 1, 0)},\n        # Case 2: b=3, s=4, m=6, n_digits=(2,1,0,2,1,1), n=383\n        {'b': 3, 's': 4, 'm': 6, 'n_digits': (2, 1, 0, 2, 1, 1)},\n        # Case 3: b=5, s=1, m=1, n_digits=(4,), n=4\n        {'b': 5, 's': 1, 'm': 1, 'n_digits': (4,)},\n        # Case 4: b=7, s=5, m=4, n_digits=(6,0,3,1), n=496\n        {'b': 7, 's': 5, 'm': 4, 'n_digits': (6, 0, 3, 1)},\n        # Case 5: b=3, s=2, m=3, n_digits=(0,0,0), n=0\n        {'b': 3, 's': 2, 'm': 3, 'n_digits': (0, 0, 0)},\n    ]\n\n    results = []\n    for case in test_cases:\n        coords = compute_faure_coordinates(\n            case['b'], case['s'], case['m'], case['n_digits']\n        )\n        results.append(coords)\n\n    # Final print statement in the exact required format.\n    # Need to handle the special case of empty list for s=0, though not in test cases\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}