{
    "hands_on_practices": [
        {
            "introduction": "格点规则的误差并非随机，而是由被积函数特定傅里叶系数构成的确定性总和。其关键在于“对偶格”的概念：误差等于对应于此对偶格中非零整数向量的傅里叶系数之和。本练习  将引导你从第一性原理出发，推导这一基本结论。通过显式地枚举出几个最短的对偶格向量并计算它们对误差的贡献，你将具体地理解生成向量的性质是如何控制积分精度的。",
            "id": "3317421",
            "problem": "考虑一个用于二维环面上准蒙特卡罗（QMC）积分的秩-1格点规则，其生成向量为 $g=(1,4)$，点数为 $N=13$。格点集由 $x_{n}=\\{\\frac{n g}{N}\\}$ 定义，其中 $n=0,1,\\dots,12$，且 $\\{\\cdot\\}$ 表示按分量取小数部分。设 $f:[0,1]^{2}\\rightarrow \\mathbb{C}$ 是一个周期函数（在每个坐标上的周期均为 1），其傅里叶展开为 $f(x)=\\sum_{h\\in\\mathbb{Z}^{2}} \\hat{f}(h) \\exp(2\\pi i\\, h\\cdot x)$，其中 $h\\cdot x=h_{1}x_{1}+h_{2}x_{2}$。积分 $\\int_{[0,1]^{2}} f(x)\\,dx$ 的秩-1格点规则近似为 $Q_{N}(f)=\\frac{1}{N}\\sum_{n=0}^{N-1} f(x_{n})$。\n\n从离散指数和 $\\frac{1}{N}\\sum_{n=0}^{N-1}\\exp\\!\\big(2\\pi i\\, n\\, t\\big)$ 在 $t\\in \\mathbb{Z}$ 时等于 1，否则等于 0 这一基本恒等式出发，推导傅里叶模式 $\\exp(2\\pi i\\, h\\cdot x)$ 在该格点规则下发生混叠的条件，并说明求积误差 $Q_{N}(f)-\\int_{[0,1]^2} f(x)\\, dx$ 如何依赖于满足混叠条件的傅里叶系数的子集。\n\n然后，明确地枚举出所有满足对偶同余式 $h\\cdot g\\equiv 0 \\pmod{N}$ 且 $\\|h\\|_{\\infty}\\leq 3$ 的非零整数向量 $h=(h_{1},h_{2})$，其中 $\\|h\\|_{\\infty}=\\max\\{|h_{1}|,|h_{2}|\\}$。最后，假设一个傅里叶衰减模型 $|\\hat{f}(h)|=c\\, \\|h\\|_{2}^{-2}$ 对所有 $h\\neq 0$ 成立，其中 $c>0$ 是一个常数，且 $\\|h\\|_{2}=\\sqrt{h_{1}^{2}+h_{2}^{2}}$。计算来自 $\\|h\\|_{\\infty}\\leq 3$ 的已枚举对偶向量对求积误差大小的绝对贡献之和，并用一个关于 $c$ 的简化解析表达式给出你的最终答案。无需进行四舍五入。",
            "solution": "问题的分析按要求分三个阶段进行：首先，推导秩-1格点规则的求积误差表达式；其次，枚举特定的对偶格向量；第三，根据给定的傅里叶衰减模型计算误差贡献。\n\n函数 $f(x)$ 在单位超立方体 $[0,1]^2$ 上的积分真值由其零阶傅里叶系数 $\\hat{f}(0)$ 给出。这可以通过对傅里叶级数逐项积分得到：\n$$\n\\int_{[0,1]^2} f(x) dx = \\int_{[0,1]^2} \\sum_{h \\in \\mathbb{Z}^2} \\hat{f}(h) \\exp(2\\pi i h \\cdot x) dx = \\sum_{h \\in \\mathbb{Z}^2} \\hat{f}(h) \\int_{[0,1]^2} \\exp(2\\pi i h \\cdot x) dx\n$$\n当 $h=(0,0)$ 时，积分 $\\int_{[0,1]^2} \\exp(2\\pi i h \\cdot x) dx$ 等于 1；当 $h \\in \\mathbb{Z}^2 \\setminus \\{0\\}$ 时，积分等于 0。因此，\n$$\n\\int_{[0,1]^2} f(x) dx = \\hat{f}(0)\n$$\n\n秩-1格点规则近似 $Q_N(f)$ 是函数在 $N$ 个格点 $x_n = \\{\\frac{n g}{N}\\}$（其中 $n=0, 1, \\dots, N-1$）处的函数值的平均值。我们将 $f(x_n)$ 的傅里叶展开代入 $Q_N(f)$ 的定义中：\n$$\nQ_N(f) = \\frac{1}{N} \\sum_{n=0}^{N-1} f(x_n) = \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{h \\in \\mathbb{Z}^2} \\hat{f}(h) \\exp(2\\pi i h \\cdot x_n)\n$$\n格点为 $x_n = \\frac{n g}{N} \\pmod 1$。由于 $h$ 是一个整数向量，项 $\\exp(2\\pi i h \\cdot x)$ 在 $x$ 的每个分量上都以 1 为周期。因此，我们可以忽略由取小数部分运算产生的整数部分，这意味着我们可以写出 $\\exp(2\\pi i h \\cdot x_n) = \\exp(2\\pi i h \\cdot \\frac{n g}{N})$。在傅里叶级数适当的收敛条件下，交换求和顺序是允许的，我们得到：\n$$\nQ_N(f) = \\sum_{h \\in \\mathbb{Z}^2} \\hat{f}(h) \\left( \\frac{1}{N} \\sum_{n=0}^{N-1} \\exp\\left(2\\pi i h \\cdot \\frac{n g}{N}\\right) \\right) = \\sum_{h \\in \\mathbb{Z}^2} \\hat{f}(h) \\left( \\frac{1}{N} \\sum_{n=0}^{N-1} \\exp\\left(2\\pi i n \\frac{h \\cdot g}{N}\\right) \\right)\n$$\n现在我们使用给定的基本恒等式：离散和 $\\frac{1}{N}\\sum_{n=0}^{N-1}\\exp(2\\pi i n t)$ 在 $t$ 是整数时为 1，否则为 0。在我们的表达式中，$t = \\frac{h \\cdot g}{N}$。因此，当且仅当 $\\frac{h \\cdot g}{N}$ 是一个整数时，该和为 1，这等价于同余关系 $h \\cdot g \\equiv 0 \\pmod N$。这个条件定义了对偶格。\n一个傅里叶模式 $\\exp(2\\pi i h \\cdot x)$ 发生混叠，意味着在格点规则的采样方案下，它与常数函数 1 无法区分，这恰好发生在条件 $h \\cdot g \\equiv 0 \\pmod N$ 满足时。\n所有满足此条件的整数向量 $h$ 的集合称为对偶格，记为 $\\mathcal{L}^\\perp = \\{ h \\in \\mathbb{Z}^2 \\mid h \\cdot g \\equiv 0 \\pmod N \\}$。因此，QMC 近似可以写成在对偶格上的求和：\n$$\nQ_N(f) = \\sum_{h \\in \\mathcal{L}^\\perp} \\hat{f}(h)\n$$\n求积误差是近似值与积分真值之间的差：\n$$\nE_N(f) = Q_N(f) - \\int_{[0,1]^2} f(x) dx = \\sum_{h \\in \\mathcal{L}^\\perp} \\hat{f}(h) - \\hat{f}(0)\n$$\n零向量 $h=(0,0)$ 总是满足对偶格条件，$0 \\cdot g = 0 \\equiv 0 \\pmod N$，所以 $h=0$ 始终在 $\\mathcal{L}^\\perp$ 中。因此，我们可以将 $h=0$ 的项从和式中分离出来：\n$$\nE_N(f) = \\left( \\hat{f}(0) + \\sum_{h \\in \\mathcal{L}^\\perp \\setminus \\{0\\}} \\hat{f}(h) \\right) - \\hat{f}(0) = \\sum_{h \\in \\mathcal{L}^\\perp \\setminus \\{0\\}} \\hat{f}(h)\n$$\n这表明求积误差是对应于对偶格中所有非零向量的傅里叶系数之和。\n\n接下来，我们必须枚举出在给定参数 $g=(1,4)$ 和 $N=13$ 以及约束条件 $\\|h\\|_{\\infty} \\leq 3$ 下，满足对偶同余式的特定非零整数向量 $h=(h_1, h_2)$。条件如下：\n1. $h \\in \\mathbb{Z}^2 \\setminus \\{0\\}$\n2. $h_1 \\cdot 1 + h_2 \\cdot 4 \\equiv 0 \\pmod{13}$\n3. $\\|h\\|_{\\infty} = \\max\\{|h_1|, |h_2|\\} \\leq 3$，这意味着 $h_1, h_2 \\in \\{-3, -2, -1, 0, 1, 2, 3\\}$。\n\n同余式为 $h_1 + 4h_2 \\equiv 0 \\pmod{13}$。这意味着 $h_1 + 4h_2$ 必须是 13 的倍数。\n给定 $h_1$ 和 $h_2$ 的取值范围，表达式 $h_1 + 4h_2$ 的值是有界的：\n最小值为 $-3 + 4(-3) = -15$。\n最大值为 $3 + 4(3) = 15$。\n在区间 $[-15, 15]$ 内，13 的整数倍只有 $-13$、 $0$ 和 $13$。\n\n情况1：$h_1 + 4h_2 = 13$。\n我们测试 $h_2$ 在其允许范围内的值：\n如果 $h_2=3$，则 $h_1 + 12 = 13 \\implies h_1 = 1$。$h_1=1$ 和 $h_2=3$ 都在 $[-3, 3]$ 范围内。所以，$h=(1,3)$ 是一个解。\n如果 $h_2=2$，则 $h_1 + 8 = 13 \\implies h_1=5$。这超出了 $h_1$ 的允许范围。\n对于任何 $h_2  2$，$h_1$ 将会更大，因此在这种情况下没有其他解。\n\n情况2：$h_1 + 4h_2 = 0$。\n如果 $h_2=0$，则 $h_1=0$。这得到向量 $h=(0,0)$，但我们正在寻找非零向量，所以这个解被明确排除。对于 $h_2$ 在其范围内的任何其他整数值，$h_1=-4h_2$ 将超出 $h_1$ 的范围。例如，如果 $h_2=1$，$h_1=-4$。\n\n情况3：$h_1 + 4h_2 = -13$。\n我们测试 $h_2$ 的值：\n如果 $h_2=-3$，则 $h_1 - 12 = -13 \\implies h_1 = -1$。$h_1=-1$ 和 $h_2=-3$ 都在 $[-3, 3]$ 范围内。所以，$h=(-1,-3)$ 是一个解。\n如果 $h_2=-2$，则 $h_1 - 8 = -13 \\implies h_1=-5$。这超出了 $h_1$ 的允许范围。\n对于任何 $h_2 > -2$，$h_1$ 的代数值将更大（负得更少），不会产生解。\n\n因此，满足指定条件的非零整数向量 $h$ 的集合是 $\\{ (1,3), (-1,-3) \\}$。\n\n最后，我们计算这些枚举向量对误差的绝对贡献之和。问题提供了一个傅里叶系数大小的衰减模型：$|\\hat{f}(h)| = c \\|h\\|_2^{-2}$ 对于 $h \\neq 0$ 成立，其中 $\\|h\\|_2 = \\sqrt{h_1^2 + h_2^2}$。需要计算的量是 $\\sum_{h \\in \\{(1,3), (-1,-3)\\}} |\\hat{f}(h)|$。\n\n对于 $h=(1,3)$：\n$\\|h\\|_2^2 = 1^2 + 3^2 = 1+9=10$。\n$|\\hat{f}((1,3))| = c \\cdot (10)^{-1} = \\frac{c}{10}$。\n\n对于 $h=(-1,-3)$：\n$\\|h\\|_2^2 = (-1)^2 + (-3)^2 = 1+9=10$。\n$|\\hat{f}((-1,-3))| = c \\cdot (10)^{-1} = \\frac{c}{10}$。\n\n这些绝对贡献的总和是：\n$$\n\\frac{c}{10} + \\frac{c}{10} = \\frac{2c}{10} = \\frac{c}{5}\n$$\n这是最终结果。",
            "answer": "$$\n\\boxed{\\frac{c}{5}}\n$$"
        },
        {
            "introduction": "格点规则的质量在很大程度上取决于其生成向量的选择，一个糟糕的选择即使在点数很多的情况下也可能导致灾难性的误差。一个好的生成向量 $\\boldsymbol{g}$ 的最基本要求之一是其每个分量 $g_{k}$ 都应与点数 $N$ 互质。本练习  探讨了当 $\\gcd(g_{k}, N)  1$ 时的失效情形。你将分析一个公约数如何导致点在特定坐标上聚集，并为一个对该坐标敏感的函数量化由此产生的巨大积分误差，这是诊断和避免格点规则构造中基本但致命缺陷的重要一课。",
            "id": "3317399",
            "problem": "考虑一个维度为$s=3$的等级1格点规则，其点数为$N=12$，生成向量为$\\boldsymbol{g}=(5,3,7)$。设$\\{\\cdot\\}$表示分量小数部分，并定义点集$\\boldsymbol{u}_{i}=\\left\\{\\frac{i\\boldsymbol{g}}{N}\\right\\}$，其中$i=0,1,\\dots,11$。对于被积函数$F:[0,1]^{3}\\to\\mathbb{R}$，其拟蒙特卡罗（QMC）估计量为\n$$\n\\hat{I}_{N}(F)=\\frac{1}{N}\\sum_{i=0}^{N-1}F(\\boldsymbol{u}_{i})，\n$$\n其精确积分为\n$$\nI(F)=\\int_{[0,1]^{3}}F(\\boldsymbol{x})\\,\\mathrm{d}\\boldsymbol{x}。\n$$\n从等级1格点规则的基本定义和$\\gcd$的算术性质出发，分析当$\\gcd(g_{k},N)1$时出现的聚类现象。具体来说：\n\n1. 从基本定义出发证明，当$\\gcd(g_{2},N)1$时，第二个坐标$u_{i,2}$仅取$[0,1)$中$N$个可能网格值的严格子集，并确定出现多少个不同的值以及每个值重复的次数。\n\n2. 对于被积函数$F(\\boldsymbol{x})=\\cos(8\\pi x_{2})$，证明$I(F)$等于$\\cos(8\\pi x)$在$[0,1]$上的一维积分，并计算$I(F)$。\n\n3. 利用由$\\gcd(g_{2},N)1$所暗示的集合$\\{u_{i,2}:i=0,\\dots,11\\}$的结构，计算$\\hat{I}_{N}(F)$，然后计算绝对误差$|\\hat{I}_{N}(F)-I(F)|$。\n\n你的最终答案必须是等于绝对误差的单个实数。无需四舍五入；请提供精确值。",
            "solution": "我们从等级1格点规则的定义和整数模运算的性质开始。点集定义为\n$$\n\\boldsymbol{u}_{i}=\\left\\{\\frac{i\\boldsymbol{g}}{12}\\right\\},\\quad i=0,1,\\dots,11,\\quad \\boldsymbol{g}=(5,3,7).\n$$\n第二个坐标为\n$$\nu_{i,2}=\\left\\{\\frac{i g_{2}}{12}\\right\\}=\\left\\{\\frac{3i}{12}\\right\\}=\\frac{(3i\\bmod 12)}{12}.\n$$\n设$d=\\gcd(g_{2},N)=\\gcd(3,12)=3$。一个标准的数论事实是，余数集合$\\{3i\\bmod 12:i=0,1,\\dots,11\\}$构成$\\mathbb{Z}_{12}$的一个大小为$N'=\\frac{N}{d}=\\frac{12}{3}=4$的循环子群，由$d$的倍数组成。具体来说，\n$$\n3i\\bmod 12\\in\\{0,3,6,9\\}.\n$$\n因此，$u_{i,2}$的不同值为\n$$\n\\left\\{0,\\frac{3}{12},\\frac{6}{12},\\frac{9}{12}\\right\\}=\\left\\{0,\\frac{1}{4},\\frac{1}{2},\\frac{3}{4}\\right\\}.\n$$\n在$\\{u_{i,2}:i=0,\\dots,11\\}$中，每个不同的值都恰好出现$d=3$次，因为映射$i\\mapsto 3i\\bmod 12$将$\\{0,\\dots,11\\}$划分为$d$个陪集，这些陪集在乘以3后都投射到相同的模12剩余类上。因此，步骤1显示了聚类现象：只出现了$N'=\\frac{12}{3}=4$个不同的第二坐标值，每个值的重复度为3。\n\n接下来，考虑被积函数$F(\\boldsymbol{x})=\\cos(8\\pi x_{2})$。由于$F$仅依赖于$x_{2}$，在$[0,1]^{3}$上的精确积分可以分解为：\n$$\nI(F)=\\int_{[0,1]^{3}}\\cos(8\\pi x_{2})\\,\\mathrm{d}\\boldsymbol{x}=\\left(\\int_{0}^{1}\\cos(8\\pi x_{2})\\,\\mathrm{d}x_{2}\\right)\\left(\\int_{0}^{1}\\mathrm{d}x_{1}\\right)\\left(\\int_{0}^{1}\\mathrm{d}x_{3}\\right)=\\int_{0}^{1}\\cos(8\\pi x)\\,\\mathrm{d}x.\n$$\n计算这个一维积分：\n$$\n\\int_{0}^{1}\\cos(8\\pi x)\\,\\mathrm{d}x=\\left.\\frac{1}{8\\pi}\\sin(8\\pi x)\\right|_{0}^{1}=\\frac{1}{8\\pi}\\left(\\sin(8\\pi)-\\sin(0)\\right)=\\frac{1}{8\\pi}(0-0)=0.\n$$\n因此，$I(F)=0$。\n\n现在计算QMC估计量。根据定义，\n$$\n\\hat{I}_{12}(F)=\\frac{1}{12}\\sum_{i=0}^{11}\\cos(8\\pi u_{i,2}).\n$$\n因为$u_{i,2}\\in\\left\\{0,\\frac{1}{4},\\frac{1}{2},\\frac{3}{4}\\right\\}$且每个值都恰好出现3次，我们可以将求和重写为\n$$\n\\hat{I}_{12}(F)=\\frac{1}{12}\\left(3\\cos(8\\pi\\cdot 0)+3\\cos\\!\\left(8\\pi\\cdot\\frac{1}{4}\\right)+3\\cos\\!\\left(8\\pi\\cdot\\frac{1}{2}\\right)+3\\cos\\!\\left(8\\pi\\cdot\\frac{3}{4}\\right)\\right)。\n$$\n计算每个余弦值：\n- $\\cos(8\\pi\\cdot 0)=\\cos(0)=1$,\n- $\\cos\\!\\left(8\\pi\\cdot\\frac{1}{4}\\right)=\\cos(2\\pi)=1$,\n- $\\cos\\!\\left(8\\pi\\cdot\\frac{1}{2}\\right)=\\cos(4\\pi)=1$,\n- $\\cos\\!\\left(8\\pi\\cdot\\frac{3}{4}\\right)=\\cos(6\\pi)=1$.\n因此，\n$$\n\\hat{I}_{12}(F)=\\frac{1}{12}\\left(3\\cdot 1+3\\cdot 1+3\\cdot 1+3\\cdot 1\\right)=\\frac{1}{12}\\cdot 12=1。\n$$\n最后，绝对误差是\n$$\n\\left|\\hat{I}_{12}(F)-I(F)\\right|=|1-0|=1。\n$$\n这量化了由$\\gcd(g_{2},N)1$引起的聚类效应：对于这个仅依赖于$x_{2}$的函数，在不修正公约数的情况下增加$N$并不能改善估计量，且误差可以保持在高达1的水平。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "格点规则优越的误差收敛率在理论上是为光滑的周期函数保证的，然而，实践中遇到的许多函数都是非周期的。为了在这种情况下有效应用格点规则，我们可以使用一种“周期化”变换，它在不改变积分值的情况下将被积函数修改为周期函数。这项编程练习  让你应用经典的“帐篷变换”，并直接比较格点规则在有无此变换时处理非周期函数的性能差异。这项练习将让你亲身体验一项至关重要的实用技术，并展示其在减小积分误差方面的威力，从而连接起优美的理论与实际应用。",
            "id": "3317430",
            "problem": "你需要实现一个基于秩-1格规则和帐篷变换的确定性准蒙特卡罗（QMC）估计量，并将其误差与未变换的被积函数进行比较。被积函数是单位超立方体 $[0,1]^s$ 上的可分离函数 $f(\\boldsymbol{x}) = \\prod_{j=1}^s \\exp(-x_j)$，所有计算都是纯数学的，无单位。\n\n工作必须从基本原理开始：$[0,1]^s$ 上的黎曼积分的定义，具有秩-1格点的确定性QMC规则的概念，以及一种保测度变换，该变换对称地折叠单位区间，以使其在延拓到环面上的意义上周期化一个非周期被积函数。\n\n用作基本基础的定义和约束：\n- 函数 $f$ 在单位超立方体 $[0,1]^s$ 上的积分为 $\\int_{[0,1]^s} f(\\boldsymbol{x})\\,d\\boldsymbol{x}$。\n- 在 $s$ 维空间中具有 $N$ 个点的秩-1格规则使用节点 $\\boldsymbol{u}_i = \\{\\frac{i\\boldsymbol{z}}{N}\\}$，其中 $i \\in \\{0,1,\\dots,N-1\\}$，$\\boldsymbol{z}\\in\\mathbb{Z}^s$ 是一个生成向量，$\\{\\cdot\\}$ 表示逐分量取小数部分。\n- 帐篷变换是 $[0,1]$ 上的一个分段线性映射，它将区间对称地折叠到自身上，保持勒贝格测度，并在 $[0,1]^s$ 上逐分量应用。\n- 根据 $f$ 的可分离性，可以从第一性原理得知 $f$ 的精确积分值，但你必须在解题方案中从一维积分推导出它。\n\n你的程序必须：\n1. 为 $N=64$ 个点（$N$ 必须恰好为 $64$）和测试套件中指定的维度 $s$ 构建秩-1格点。\n2. 除非另有说明，使用由乘子 $a \\in \\mathbb{Z}$（满足 $\\gcd(a,N)=1$）构建的 Korobov 型生成向量 $\\boldsymbol{z}$，其分量为 $z_j \\equiv a^{j-1} \\ (\\mathrm{mod}\\ N)$，其中 $j=1,\\dots,s$。此生成向量的选择必须直接且确定性地实现。\n3. 在节点上逐分量实现帐篷变换，并使用 $f(\\psi(\\boldsymbol{u}_i))$ 评估变换后的估计量，其中 $\\psi$ 是在 $[0,1]^s$ 上逐分量应用的帐篷变换。\n4. 使用 $f(\\boldsymbol{u}_i)$ 计算未变换的格估计量。\n5. 推导并使用 $f$ 的精确积分值来计算两个估计量的绝对误差。\n6. 对每个测试用例，报告三个浮点数：未变换估计量的绝对误差，帐篷变换后估计量的绝对误差，以及帐篷变换后的误差与未变换误差的比率。如果未变换的误差为 $0$，则报告比率为 $+\\infty$。\n\n测试套件：\n- 用例1：$s=1$, $a=3$。\n- 用例2：$s=3$, $a=3$。\n- 用例3：$s=10$, $a=3$。\n- 用例4（退化生成元边缘情况）：$s=3$, $a=2$。\n\n所有角度都无关紧要；不涉及任何物理单位。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身就是一个包含三个浮点数的列表，顺序为 $[e_{\\text{plain}}, e_{\\text{tent}}, e_{\\text{tent}}/e_{\\text{plain}}]$。例如，对于两个用例，输出必须看起来像这样一行：$[[e_{11},e_{12},e_{13}],[e_{21},e_{22},e_{23}]]$。\n\n你的实现必须是完全确定性和自包含的，没有任何随机化组件。所有量都必须以完全双精度计算，不得有舍入或截断指令。",
            "solution": "该问题要求实现并比较两种准蒙特卡罗（QMC）估计量，用于计算函数 $f(\\boldsymbol{x}) = \\prod_{j=1}^s \\exp(-x_j)$ 在 $s$ 维单位超立方体 $[0,1]^s$ 上的积分。这些估计量基于秩-1格规则，其中一个为直接应用，另一个则采用了一种称为帐篷变换的坐标变换。\n\n首先，我们确定积分的精确值，它将作为我们数值估计量的基准。被积函数 $f(\\boldsymbol{x})$ 是可分离的，意味着它是一个单变量函数的乘积。因此，多维积分可以表示为一维积分的乘积：\n$$\nI_s = \\int_{[0,1]^s} f(\\boldsymbol{x})\\,d\\boldsymbol{x} = \\int_{[0,1]^s} \\prod_{j=1}^s e^{-x_j} \\, d\\boldsymbol{x} = \\prod_{j=1}^s \\int_0^1 e^{-x_j} \\, dx_j\n$$\n一维积分是初等的：\n$$\nI_1 = \\int_0^1 e^{-x} \\, dx = \\left[-e^{-x}\\right]_0^1 = -e^{-1} - (-e^0) = 1 - e^{-1}\n$$\n因此，在 $s$ 维空间中积分的精确值为：\n$$\nI_s = (1 - e^{-1})^s\n$$\n\n积分的数值近似是使用QMC估计量进行的，该估计量定义为函数在一组 $N$ 个确定性点 $\\{\\boldsymbol{u}_i\\}_{i=0}^{N-1}$ 上求值的平均值：\n$$\nQ_N(f) = \\frac{1}{N} \\sum_{i=0}^{N-1} f(\\boldsymbol{u}_i)\n$$\n该问题指定了用秩-1格规则来生成这些点。点数固定为 $N=64$。格点 $\\boldsymbol{u}_i \\in [0,1)^s$ 由下式给出：\n$$\n\\boldsymbol{u}_i = \\left\\{ \\frac{i \\boldsymbol{z}}{N} \\right\\} \\quad \\text{for } i \\in \\{0, 1, \\dots, N-1\\}\n$$\n其中 $\\boldsymbol{z} \\in \\mathbb{Z}^s$ 是一个称为生成向量的整数向量，而 $\\{\\cdot\\}$ 表示逐分量取小数部分的操作（即 $x \\pmod 1$）。\n\n生成向量 $\\boldsymbol{z} = (z_1, z_2, \\dots, z_s)$ 是使用 Korobov 方法构造的。对于给定的乘子 $a \\in \\mathbb{Z}$，其分量定义为：\n$$\nz_j \\equiv a^{j-1} \\pmod{N} \\quad \\text{for } j=1, \\dots, s\n$$\n通常，为了使格点具有良好的等分布性质，要求 $\\gcd(a,N)=1$。该问题包含了满足此条件的测试用例，以及一个 $\\gcd(a,N) \\neq 1$ 的退化情况。\n\n比较的核心在于帐篷变换的应用。当被積函数 $f(\\boldsymbol{x})$ 的定义域 $[0,1]^s$ 被视为 $s$ 维环面 $\\mathbb{T}^s$ 时，它不是周期的。例如，$f(0, \\dots, 0) = 1$ 而 $f(1, \\dots, 1) = e^{-s}$，因此在边界上存在不连续性。格规则对于在环面上光滑且周期的函数表现最佳。帐篷变换 $\\psi: [0,1]^s \\to [0,1]^s$ 是一种旨在使被积函数周期化的保测度映射。它通过“折叠”积分域来工作。它是逐分量应用的，其一维映射 $\\psi_1: [0,1] \\to [0,1]$ 定义为：\n$$\n\\psi_1(x) = 1 - |2x - 1| = \\begin{cases} 2x  \\text{if } 0 \\le x  1/2 \\\\ 2-2x  \\text{if } 1/2 \\le x \\le 1 \\end{cases}\n$$\n这个变换使得新的被积函数 $g(\\boldsymbol{x}) = f(\\psi(\\boldsymbol{x}))$ 成为周期函数，因为 $\\psi_1(0) = 0$ 且 $\\psi_1(1) = 0$，所以 $g$ 在超立方体的相对面上取相同的值（例如，$g(0, x_2, \\dots) = g(1, x_2, \\dots)$）。由于 $\\psi$ 是保测度的，变换后函数的积分与原积分相同：$\\int_{[0,1]^s} f(\\psi(\\boldsymbol{x}))d\\boldsymbol{x} = \\int_{[0,1]^s} f(\\boldsymbol{y})d\\boldsymbol{y} = I_s$。\n\n我们将计算两种估计量：\n1.  未变换（普通）估计量：$Q_N^{\\text{plain}}(f) = \\frac{1}{N} \\sum_{i=0}^{N-1} f(\\boldsymbol{u}_i)$。\n2.  帐篷变换后估计量：$Q_N^{\\text{tent}}(f) = \\frac{1}{N} \\sum_{i=0}^{N-1} f(\\psi(\\boldsymbol{u}_i))$。\n\n对于每个测试用例，我们计算每个估计量相对于精确积分值 $I_s$ 的绝对误差：\n$$\ne_{\\text{plain}} = |Q_N^{\\text{plain}}(f) - I_s|\n$$\n$$\ne_{\\text{tent}} = |Q_N^{\\text{tent}}(f) - I_s|\n$$\n最后，我们计算这些误差的比率 $e_{\\text{tent}} / e_{\\text{plain}}$。如果 $e_{\\text{plain}}$ 为零，则该比率报告为无穷大。这个比较将展示帐篷变换在减少这种非周期被积函数的积分误差方面的有效性。\n\n每个测试用例 $(s, a)$ 的计算步骤如下：\n1.  设置 $N=64$。\n2.  计算精确积分 $I_s = (1 - e^{-1})^s$。\n3.  构造 Korobov 生成向量 $\\boldsymbol{z}$，其分量为 $z_j = a^{j-1} \\pmod N$，其中 $j=1, \\dots, s$。\n4.  生成 $N$ 个格点 $\\boldsymbol{u}_i = \\{i\\boldsymbol{z}/N\\}$，其中 $i=0, \\dots, N-1$。\n5.  对所有点评估 $f(\\boldsymbol{u}_i)$，并计算普通估计量 $Q_N^{\\text{plain}}(f)$ 及其误差 $e_{\\text{plain}}$。\n6.  对每个点 $\\boldsymbol{u}_i$ 逐分量应用帐篷变换得到 $\\boldsymbol{v}_i = \\psi(\\boldsymbol{u}_i)$。\n7.  对所有变换后的点评估 $f(\\boldsymbol{v}_i)$，并计算帐篷变换后的估计量 $Q_N^{\\text{tent}}(f)$ 及其误差 $e_{\\text{tent}}$。\n8.  计算比率 $e_{\\text{tent}} / e_{\\text{plain}}$。\n9.  报告三元组 $(e_{\\text{plain}}, e_{\\text{tent}}, e_{\\text{tent}} / e_{\\text{plain}})$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a deterministic QMC estimator based on a rank-1 lattice rule\n    and compares the error with and without a tent transform.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 3),   # s=1, a=3\n        (3, 3),   # s=3, a=3\n        (10, 3),  # s=10, a=3\n        (3, 2)    # s=3, a=2 (degenerate generator)\n    ]\n\n    N = 64\n    results = []\n\n    def integrand(points):\n        \"\"\"\n        Computes the integrand f(x) = prod(exp(-x_j)) for a set of points.\n        `points` is an (N, s) array.\n        \"\"\"\n        return np.prod(np.exp(-points), axis=1)\n\n    def tent_transform(points):\n        \"\"\"\n        Applies the component-wise tent transform psi(x) = 1 - |2x - 1|.\n        `points` is an (N, s) array.\n        \"\"\"\n        return 1.0 - np.abs(2.0 * points - 1.0)\n\n    for s, a in test_cases:\n        # 1. Derive the exact value of the integral\n        exact_integral = (1.0 - np.exp(-1.0))**s\n\n        # 2. Construct the Korobov generating vector z\n        z = np.array([(a**j) % N for j in range(s)], dtype=np.int64)\n\n        # 3. Construct the rank-1 lattice nodes\n        # i is a column vector of shape (N, 1)\n        # z is a row vector of shape (1, s)\n        # Broadcasting i[:, np.newaxis] * z creates an (N, s) matrix\n        i_vec = np.arange(N, dtype=np.int64)\n        points = (i_vec[:, np.newaxis] * z) / N\n        points %= 1.0  # Component-wise fractional part\n\n        # 4. Compute the untransformed lattice estimator and its error\n        f_values_plain = integrand(points)\n        q_plain = np.mean(f_values_plain)\n        e_plain = np.abs(q_plain - exact_integral)\n\n        # 5. Compute the tent-transformed estimator and its error\n        transformed_points = tent_transform(points)\n        f_values_tent = integrand(transformed_points)\n        q_tent = np.mean(f_values_tent)\n        e_tent = np.abs(q_tent - exact_integral)\n\n        # 6. Compute the error ratio\n        if e_plain == 0.0:\n            ratio = np.inf\n        else:\n            ratio = e_tent / e_plain\n        \n        results.append([e_plain, e_tent, ratio])\n\n    # Final print statement in the exact required format.\n    # The format [[e1,e2,e3],[e1,e2,e3]] has no spaces.\n    # The default str() for a list includes spaces, so we remove them.\n    print(str(results).replace(' ', ''))\n\nsolve()\n```"
        }
    ]
}