{
    "hands_on_practices": [
        {
            "introduction": "掌握任何一种算法的第一步都是从一个可控的、理想化的场景开始。这个练习将引导你为退火重要性采样（AIS）构建一个基础模型，连接一个高斯基分布和一个类伊辛模型的能量函数定义的目标分布。通过推导和实现一个在每个阶段都达到完美混合的理想化AIS过程，你将亲手验证增量权重的期望值如何精确地对应于连续两个中间分布配分函数之比 $Z_{\\beta_{k+1}}/Z_{\\beta_k}$，从而深刻理解AIS估算配分函数比率的核心原理。",
            "id": "3288040",
            "problem": "考虑以下退火重要性采样（Annealed Importance Sampling, AIS）的设置，这里正式介绍为带有几何路径的退火重要性采样（AIS）。设目标能量为 $E(x)=\\lambda x^2$，其中 $x\\in\\mathbb{R}$ 且 $\\lambda0$ 是一个固定常数。定义基础分布 $b(x)$ 为一个零均值、方差为 $s^2$ 的高斯分布，即 $b(x)=\\frac{1}{\\sqrt{2\\pi}\\,s}\\exp\\left(-\\frac{x^2}{2s^2}\\right)$，目标分布 $t(x)$ 为与能量 $E(x)$ 相关联的归一化吉布斯分布，由 $t(x)=\\sqrt{\\frac{\\lambda}{\\pi}}\\exp(-\\lambda x^2)$ 给出。考虑由逆温序列 $\\{\\beta_k\\}_{k=0}^K$（其中 $0=\\beta_0  \\beta_1  \\dots  \\beta_K=1$）参数化的中间未归一化密度 $u_\\beta(x)=b(x)^{1-\\beta}t(x)^{\\beta}$ 的几何退火路径。\n\n从重要性采样和归一化常数的基本原理出发：对于任何未归一化的密度 $u(x)$，其归一化常数为 $Z=\\int_\\mathbb{R}u(x)\\,\\mathrm{d}x$，则归一化密度为 $p(x)=\\frac{u(x)}{Z}$。在带有几何路径且每阶段完美混合的AIS中，从阶段 $k$到阶段 $k+1$的期望增量权重等于归一化常数之比 $\\frac{Z_{\\beta_{k+1}}}{Z_{\\beta_k}}$，其中 $Z_\\beta=\\int_\\mathbb{R}u_\\beta(x)\\,\\mathrm{d}x$。您的任务是，从第一性原理出发，为给定的 $b(x)$和 $t(x)$推导归一化常数 $Z_\\beta$，然后实现一个程序，在给定 $(\\lambda,s,\\{\\beta_k\\}_{k=0}^K)$ 的情况下，计算每个阶段的期望增量权重，定义为 $\\frac{Z_{\\beta_{k+1}}}{Z_{\\beta_k}}$，其中 $k=0,1,\\dots,K-1$。\n\n推导必须从 $b(x)$、$t(x)$、几何路径 $u_\\beta(x)$和归一化常数 $Z_\\beta$的定义开始，并且只能使用代数变换和关于高斯积分的公认事实，避免使用任何未在您的解法中推导出的快捷公式。\n\n您的程序必须处理以下参数集测试套件，每个参数集以 $(\\lambda,s,\\text{schedule})$ 的形式提供：\n- 测试用例1：$(\\lambda,s,\\{\\beta_k\\})=\\left(0.7,1.5,\\{0.0,0.2,0.5,0.9,1.0\\}\\right)$。\n- 测试用例2（基础分布等于目标分布的边界情况）：$(\\lambda,s,\\{\\beta_k\\})=\\left(0.5,1.0,\\{0.0,0.3,0.6,0.9,1.0\\}\\right)$。\n- 测试用例3（小能量尺度和宽基础分布）：$(\\lambda,s,\\{\\beta_k\\})=\\left(10^{-6},100.0,\\{0.0,0.01,0.1,0.5,1.0\\}\\right)$。\n- 测试用例4（尖锐目标分布和窄基础分布）：$(\\lambda,s,\\{\\beta_k\\})=\\left(10.0,0.1,\\{0.0,0.4,0.8,1.0\\}\\right)$。\n\n对于每个测试用例，计算期望增量权重列表 $\\left[\\frac{Z_{\\beta_1}}{Z_{\\beta_0}},\\frac{Z_{\\beta_2}}{Z_{\\beta_1}},\\dots,\\frac{Z_{\\beta_K}}{Z_{\\beta_{K-1}}}\\right]$。本问题不涉及物理单位。您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔的列表的列表，不含空格。每个内部列表对应于上面列出的一个测试用例，顺序相同。例如 `[[w_{1,1},w_{1,2}], [w_{2,1},\\dots]]` 但不含空格：`[[w_{1,1},w_{1,2}],[w_{2,1},\\dots]]`。每个 $w$ 必须是十进制表示的浮点数。您的实现必须是一个完整、可运行的程序。",
            "solution": "该问题是有效的，因为它具有科学依据、问题明确、客观且内部一致。它提出了计算统计学领域的一个标准理论练习，特别涉及退火重要性采样（Annealed Importance Sampling, AIS）。所有提供的定义和参数都是标准的，足以推导出唯一解。\n\n任务是为AIS方案中的一个中间分布推导归一化常数 $Z_\\beta$，然后用它来计算期望的增量权重。推导过程按规定从第一性原理开始。\n\n设基础分布为零均值、方差为 $s^2$ 的高斯分布，其概率密度函数（PDF）由下式给出：\n$$\nb(x) = \\frac{1}{\\sqrt{2\\pi}s} \\exp\\left(-\\frac{x^2}{2s^2}\\right)\n$$\n目标分布是能量 $E(x) = \\lambda x^2$（其中 $\\lambda  0$）的归一化吉布斯分布。未归一化的吉布斯分布是 $\\exp(-E(x)) = \\exp(-\\lambda x^2)$。为了归一化它，我们计算积分 $\\int_{-\\infty}^{\\infty} \\exp(-\\lambda x^2) \\mathrm{d}x$。这是一个标准的高斯积分，形式为 $\\int_{-\\infty}^{\\infty} \\exp(-ax^2) \\mathrm{d}x = \\sqrt{\\pi/a}$，当 $a=\\lambda$ 时，结果为 $\\sqrt{\\pi/\\lambda}$。因此，归一化的目标PDF是：\n$$\nt(x) = \\frac{\\exp(-\\lambda x^2)}{\\sqrt{\\pi/\\lambda}} = \\sqrt{\\frac{\\lambda}{\\pi}} \\exp(-\\lambda x^2)\n$$\n这与问题中为 $t(x)$ 提供的表达式相匹配。\n\n几何退火路径为序列 $0 = \\beta_0  \\beta_1  \\dots  \\beta_K = 1$ 定义了一系列未归一化的中间密度 $u_\\beta(x)$：\n$$\nu_\\beta(x) = b(x)^{1-\\beta} t(x)^\\beta\n$$\n我们的第一步是将 $b(x)$ 和 $t(x)$ 的表达式代入此定义中：\n$$\nu_\\beta(x) = \\left[ \\frac{1}{\\sqrt{2\\pi}s} \\exp\\left(-\\frac{x^2}{2s^2}\\right) \\right]^{1-\\beta} \\left[ \\sqrt{\\frac{\\lambda}{\\pi}} \\exp(-\\lambda x^2) \\right]^{\\beta}\n$$\n我们可以将相对于 $x$ 是常数的项与包含 $x$ 的指数项分开：\n$$\nu_\\beta(x) = \\left( (\\sqrt{2\\pi}s)^{-1} \\right)^{1-\\beta} \\left( (\\pi/\\lambda)^{-1/2} \\right)^{\\beta} \\times \\exp\\left(-\\frac{x^2}{2s^2}\\right)^{1-\\beta} \\exp(-\\lambda x^2)^{\\beta}\n$$\n我们分别简化常数前因子和指数部分。常数部分是：\n$$\nC_\\beta = (2\\pi s^2)^{-(1-\\beta)/2} (\\pi/\\lambda)^{-\\beta/2}\n$$\n指数部分是：\n$$\n\\exp\\left( -(1-\\beta)\\frac{x^2}{2s^2} - \\beta\\lambda x^2 \\right) = \\exp\\left( -x^2 \\left[ \\frac{1-\\beta}{2s^2} + \\beta\\lambda \\right] \\right)\n$$\n所以，未归一化的密度 $u_\\beta(x)$ 是一个形式为 $u_\\beta(x) = C_\\beta \\exp(-A_\\beta x^2)$ 的未归一化高斯分布，其中指数中的系数 $A_\\beta$ 是：\n$$\nA_\\beta = \\frac{1-\\beta}{2s^2} + \\beta\\lambda\n$$\n归一化常数 $Z_\\beta$ 定义为 $u_\\beta(x)$ 在其定义域 $\\mathbb{R}$ 上的积分：\n$$\nZ_\\beta = \\int_{-\\infty}^{\\infty} u_\\beta(x) \\, \\mathrm{d}x = \\int_{-\\infty}^{\\infty} C_\\beta \\exp(-A_\\beta x^2) \\, \\mathrm{d}x = C_\\beta \\int_{-\\infty}^{\\infty} \\exp(-A_\\beta x^2) \\, \\mathrm{d}x\n$$\n由于 $\\lambda  0$，$s^2  0$，且 $\\beta \\in [0, 1]$，系数 $A_\\beta$ 总是正的。这允许我们使用前面提到的高斯积分公式 $\\int_{-\\infty}^{\\infty} e^{-ax^2} \\mathrm{d}x = \\sqrt{\\pi/a}$，其中 $a = A_\\beta$：\n$$\nZ_\\beta = C_\\beta \\sqrt{\\frac{\\pi}{A_\\beta}}\n$$\n代入 $C_\\beta$ 的表达式：\n$$\nZ_\\beta = (2\\pi s^2)^{-(1-\\beta)/2} (\\pi/\\lambda)^{-\\beta/2} \\pi^{1/2} A_\\beta^{-1/2}\n$$\n我们来简化这些常数的幂：\n$$\nZ_\\beta = 2^{-(1-\\beta)/2} \\pi^{-(1-\\beta)/2} s^{-(1-\\beta)} \\pi^{-\\beta/2} \\lambda^{\\beta/2} \\pi^{1/2} A_\\beta^{-1/2}\n$$\n$$\nZ_\\beta = 2^{-(1-\\beta)/2} s^{-(1-\\beta)} \\lambda^{\\beta/2} \\pi^{(-1+\\beta-\\beta+1)/2} A_\\beta^{-1/2}\n$$\n$\\pi$ 的指数简化为 $0$，所以 $\\pi^0=1$：\n$$\nZ_\\beta = 2^{-(1-\\beta)/2} s^{-(1-\\beta)} \\lambda^{\\beta/2} A_\\beta^{-1/2}\n$$\n现在，代入 $A_\\beta = \\frac{1-\\beta}{2s^2} + \\beta\\lambda = \\frac{1-\\beta + 2s^2\\beta\\lambda}{2s^2}$ 的表达式：\n$$\nZ_\\beta = 2^{-(1-\\beta)/2} s^{-(1-\\beta)} \\lambda^{\\beta/2} \\left( \\frac{1-\\beta + 2s^2\\beta\\lambda}{2s^2} \\right)^{-1/2}\n$$\n$$\nZ_\\beta = 2^{-(1-\\beta)/2} s^{-(1-\\beta)} \\lambda^{\\beta/2} \\left( \\frac{2s^2}{1-\\beta + 2s^2\\beta\\lambda} \\right)^{1/2}\n$$\n$$\nZ_\\beta = 2^{-1/2+\\beta/2} s^{-1+\\beta} \\lambda^{\\beta/2} \\cdot 2^{1/2} s^1 \\cdot (1-\\beta + 2s^2\\beta\\lambda)^{-1/2}\n$$\n合并同底数的项：\n$$\nZ_\\beta = 2^{\\beta/2} s^\\beta \\lambda^{\\beta/2} (1-\\beta + 2s^2\\beta\\lambda)^{-1/2}\n$$\n$$\nZ_\\beta = (2s^2\\lambda)^{\\beta/2} (1 - \\beta + (2s^2\\lambda)\\beta)^{-1/2}\n$$\n我们定义一个常数 $\\alpha = 2s^2\\lambda$。$Z_\\beta$ 的表达式变得显著简化：\n$$\nZ_\\beta = \\alpha^{\\beta/2} (1 - \\beta + \\alpha\\beta)^{-1/2} = \\sqrt{\\frac{\\alpha^\\beta}{1 + (\\alpha-1)\\beta}}\n$$\n我们验证此公式的边界情况。对于 $\\beta=0$，$u_0(x) = b(x)$，它是归一化的，所以 $Z_0=1$。我们的公式给出 $Z_0 = \\sqrt{\\frac{\\alpha^0}{1+(\\alpha-1)0}} = \\sqrt{\\frac{1}{1}} = 1$。对于 $\\beta=1$，$u_1(x) = t(x)$，它也是归一化的，所以 $Z_1=1$。我们的公式给出 $Z_1 = \\sqrt{\\frac{\\alpha^1}{1+(\\alpha-1)1}} = \\sqrt{\\frac{\\alpha}{1+\\alpha-1}} = \\sqrt{\\frac{\\alpha}{\\alpha}} = 1$。该公式是正确的。\n\n从阶段 $k$ 到阶段 $k+1$ 的期望增量权重是归一化常数之比 $W_k = \\frac{Z_{\\beta_{k+1}}}{Z_{\\beta_k}}$。使用我们推导出的 $Z_\\beta$ 表达式：\n$$\nW_k = \\frac{\\sqrt{\\frac{\\alpha^{\\beta_{k+1}}}{1 + (\\alpha-1)\\beta_{k+1}}}}{\\sqrt{\\frac{\\alpha^{\\beta_k}}{1 + (\\alpha-1)\\beta_k}}} = \\sqrt{\\frac{\\alpha^{\\beta_{k+1}}}{1 + (\\alpha-1)\\beta_{k+1}} \\cdot \\frac{1 + (\\alpha-1)\\beta_k}{\\alpha^{\\beta_k}}}\n$$\n$$\nW_k = \\sqrt{\\alpha^{\\beta_{k+1}-\\beta_k} \\frac{1 + (\\alpha-1)\\beta_k}{1 + (\\alpha-1)\\beta_{k+1}}}\n$$\n这是要实现的最终表达式。项 $\\alpha = 2s^2\\lambda$ 在每个测试用例中计算一次。对于退火序列中从 $\\beta_k$ 到 $\\beta_{k+1}$ 的每一步，权重 $W_k$ 都使用此公式计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the expected incremental weights for Annealed Importance Sampling (AIS)\n    with a geometric path between two Gaussian distributions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda, s, schedule)\n        (0.7, 1.5, [0.0, 0.2, 0.5, 0.9, 1.0]),\n        (0.5, 1.0, [0.0, 0.3, 0.6, 0.9, 1.0]),\n        (1e-6, 100.0, [0.0, 0.01, 0.1, 0.5, 1.0]),\n        (10.0, 0.1, [0.0, 0.4, 0.8, 1.0]),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        lam, s, schedule = case\n        \n        # The derived formula depends on the constant alpha = 2 * s^2 * lambda.\n        alpha = 2.0 * s**2 * lam\n        \n        case_weights = []\n        # Iterate through the annealing schedule to compute each incremental weight.\n        for i in range(len(schedule) - 1):\n            beta_k = schedule[i]\n            beta_k_plus_1 = schedule[i+1]\n            \n            # The incremental weight from beta_k to beta_k_plus_1 is Z_{k+1}/Z_k.\n            # Handle the special case where alpha is 1, which means the base and\n            # target distributions are identical, so all weights are 1.\n            if np.isclose(alpha, 1.0):\n                weight = 1.0\n            else:\n                # Derived formula:\n                # W_k = sqrt(alpha^(beta_{k+1}-beta_k) * (1+(alpha-1)beta_k) / (1+(alpha-1)beta_{k+1}))\n                beta_diff = beta_k_plus_1 - beta_k\n                term1 = alpha**beta_diff\n                \n                numerator = 1.0 + (alpha - 1.0) * beta_k\n                denominator = 1.0 + (alpha - 1.0) * beta_k_plus_1\n                \n                # As derived, with alpha  0 and beta in [0, 1], the denominator is always positive.\n                term2 = numerator / denominator\n                \n                weight = np.sqrt(term1 * term2)\n            \n            case_weights.append(weight)\n        \n        all_results.append(case_weights)\n\n    # Final print statement in the exact required format:\n    # A single line, comma-separated list of lists, with no spaces.\n    # Example: [[w1,w2],[w3,w4,w5]]\n    inner_lists_str = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_lists_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "理论上的理想模型为我们提供了坚实的基础，但在实际应用中，我们常常会遇到标准方法失效的复杂情况。这个练习将带你直面一个AIS中的经典难题：如何从一个轻尾分布（如高斯分布）桥接到一个重尾分布（如学生t分布）。通过分析权重方差的发散条件，你将诊断出标准几何退火路径为何在这种情况下会导致灾难性的权重简并，并探索一种更稳健的“尾部感知”路径设计，这对于处理现实世界中具有异常值或极端事件的模型至关重要。",
            "id": "3288124",
            "problem": "您的任务是研究退火重要性采样 (AIS) 在从指数轻尾基分布过渡到重尾目标分布时的失效模式，并设计一种感知尾部的替代方案。下面所有的数学定义都使用带有未归一化密度的 AIS 标准设置。\n\n设 $d \\in \\mathbb{N}$ 表示维度。考虑 $\\mathbb{R}^d$ 上的一个基密度 $p_0(x) \\propto f_0(x)$ 和一个目标密度 $p_1(x) \\propto f_1(x)$。AIS 构建一个中间未归一化密度序列 $\\{f_k\\}_{k=0}^K$，其中 $f_0=f_0$ 和 $f_K=f_1$，以及相应的归一化密度 $p_k(x) \\propto f_k(x)$。对于一个调度表 $\\{\\beta_k\\}_{k=0}^K$，其中 $\\beta_0=0$，$\\beta_K=1$，且 $\\beta_k$ 是递增的，标准的几何退火是 $f_k(x) = f_0(x)^{1-\\beta_k} f_1(x)^{\\beta_k}$。从 $k$ 到 $k+1$ 的 AIS 增量权重是 $r_{k \\to k+1}(x_k) = f_{k+1}(x_k)/f_k(x_k)$。当某个步骤 $k$ 的二阶矩 $\\mathbb{E}_{p_k}[r_{k \\to k+1}(X)^2]$ 为无穷大时，就会发生灾难性的权重退化，导致重要性权重的方差为无穷大，并在极限情况下使有效样本量任意接近于零。\n\n在这个问题中，您将研究一个重尾目标的情况\n$$\np_1(x) \\propto f_1(x) \\propto \\left(1 + \\lVert x \\rVert^2 \\right)^{-\\nu},\n$$\n其中参数 $\\nu  d/2$ 以确保其可归一化。您将比较两种 AIS 路径：\n\n- 从高斯基分布开始的标准几何退火：\n  $$\n  f_0(x) \\propto \\exp\\!\\left(-\\frac{\\lVert x \\rVert^2}{2}\\right), \\quad f_k(x) = f_0(x)^{1-\\beta_k} f_1(x)^{\\beta_k}, \\quad \\beta_k = \\frac{k}{K}.\n  $$\n- 一种感知尾部的多项式路径，它用一个重尾的类学生t分布密度替换了基分布：\n  $$\n  q_\\kappa(x) \\propto \\left(1 + \\lVert x \\rVert^2 \\right)^{-\\kappa}, \\quad \\kappa  d/2, \\quad \\tilde f_k(x) = q_\\kappa(x)^{1-\\beta_k} f_1(x)^{\\beta_k}, \\quad \\beta_k = \\frac{k}{K}.\n  $$\n\n您的任务纯粹是数学和算法方面的：\n- 从重要性采样矩的基本定义出发，为每条路径推导在最后一步 $k=K-1$ 时增量权重的二阶矩为有限的尾部条件。对于标准几何退火，展示指数因子如何导致发散。对于感知尾部的多项式路径，推导出一个涉及 $d$、$\\nu$、$\\kappa$ 和 $\\beta_{K-1}$ 的有限性条件。\n- 使用这些条件编写一个程序，为每个指定的测试用例计算：\n  1. 一个布尔值，指示标准几何路径下最终增量权重的二阶矩是否为无穷大。\n  2. 一个布尔值，指示感知尾部的多项式路径下最终增量权重的二阶矩是否为无穷大。\n  3. 标准几何路径在最后一步的非负实值“指数发散系数”，定义为\n     $$\n     \\theta_{\\mathrm{geo}} := \\frac{a(\\beta_{K-1})}{2} - a(\\beta_{K}), \\quad a(\\beta) := 1 - \\beta,\n     $$\n     其中 $a(\\beta)$ 参数化了高斯因子 $\\exp(-a(\\beta)\\lVert x \\rVert^2/2)$ 在几何路径中的形式。正的 $\\theta_{\\mathrm{geo}}$ 意味着被积函数指数爆炸且二阶矩为无穷大。\n  4. 感知尾部路径在最后一步的实值“多项式可积性裕度”，定义为\n     $$\n     \\rho_{\\mathrm{poly}} := \\bigl(2 m(\\beta_K) - m(\\beta_{K-1})\\bigr) - \\frac{d}{2}, \\quad m(\\beta) := \\nu \\beta + \\kappa (1 - \\beta).\n     $$\n     正的裕度意味着增量权重平方的积分是有限的；非正值则表示发散或临界发散。\n\n实现细节：\n- 对于给定的整数 $K \\ge 2$，使用线性调度表 $\\beta_k = k/K$。\n- 使用以下测试套件，每个测试用例指定为一个元组 $(d,\\nu,\\kappa,K)$：\n  - 测试用例 1：$(2, 1.1, 1.5, 10)$。\n  - 测试用例 2：$(10, 6.0, 6.0, 20)$。\n  - 测试用例 3：$(50, 26.0, 26.0, 30)$。\n- 对每个测试用例，计算并返回一个包含四个条目的列表，顺序如上所述：$[\\text{geo\\_inf}, \\text{poly\\_inf}, \\theta_{\\mathrm{geo}}, \\rho_{\\mathrm{poly}}]$，其中 $\\text{geo\\_inf}$ 和 $\\text{poly\\_inf}$ 是布尔值，$\\theta_{\\mathrm{geo}}$ 和 $\\rho_{\\mathrm{poly}}$ 是浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，形式为三个按测试用例排列的列表的逗号分隔列表，并用方括号括起来，例如\n$$\n[[\\text{geo\\_inf}_1, \\text{poly\\_inf}_1, \\theta_{\\mathrm{geo},1}, \\rho_{\\mathrm{poly},1}],[\\text{geo\\_inf}_2, \\text{poly\\_inf}_2, \\theta_{\\mathrm{geo},2}, \\rho_{\\mathrm{poly},2}],[\\text{geo\\_inf}_3, \\text{poly\\_inf}_3, \\theta_{\\mathrm{geo},3}, \\rho_{\\mathrm{poly},3}]].\n$$\n不应打印任何附加文本。不涉及任何物理单位。所有角度（如果存在）应以弧度为单位。所有数字必须以Python对浮点数和布尔值的默认字符串转换所固有的标准十进制表示法打印。",
            "solution": "该问题要求通过检查最终增量重要性权重的二阶矩来分析退火重要性采样 (AIS) 的失效模式。该矩的有限性是 AIS 估计器稳定性和效率的关键诊断指标。我们将分析两条退火路径：从轻尾高斯分布到重尾目标的标准几何路径，以及从一个重尾分布到另一个重尾分布的感知尾部路径。\n\n关注的核心量是从中间分布 $p_k$ 到 $p_{k+1}$ 的增量权重更新的二阶矩，由 $\\mathbb{E}_{p_k}[r_{k \\to k+1}(X)^2]$ 给出。增量权重定义为 $r_{k \\to k+1}(x) = f_{k+1}(x)/f_k(x)$，其中对于任何 $j$ 都有 $p_j(x) \\propto f_j(x)$。期望是关于归一化密度 $p_k(x) = f_k(x) / Z_k$ 计算的，其中 $Z_k = \\int f_k(x) dx$。\n\n二阶矩的表达式为：\n$$\n\\mathbb{E}_{p_k}[r_{k \\to k+1}(X)^2] = \\int p_k(x) \\left(\\frac{f_{k+1}(x)}{f_k(x)}\\right)^2 dx = \\int \\frac{f_k(x)}{Z_k} \\frac{f_{k+1}(x)^2}{f_k(x)^2} dx = \\frac{1}{Z_k} \\int \\frac{f_{k+1}(x)^2}{f_k(x)} dx\n$$\n由于 $Z_k$ 是一个有限的归一化常数（假设 $p_k$ 是一个正常分布），二阶矩是有限的当且仅当积分 $\\int \\frac{f_{k+1}(x)^2}{f_k(x)} dx$ 是有限的。我们特别关注退火调度表的最后一步，即从 $k=K-1$ 到 $k=K$。因此需要分析的积分是 $\\int \\frac{f_K(x)^2}{f_{K-1}(x)} dx$。\n\n退火调度表由 $\\{\\beta_k\\}_{k=0}^K$ 给出，其中 $\\beta_0=0$ 和 $\\beta_K=1$。中间密度构造为 $f_k \\propto f_{\\text{base}}^{1-\\beta_k} f_{\\text{target}}^{\\beta_k}$。对于最后一步，$f_K(x) \\propto f_{\\text{base}}^{1-\\beta_K} f_{\\text{target}}^{\\beta_K} = f_{\\text{base}}^{0} f_{\\text{target}}^{1} = f_1(x)$。因此，控制二阶矩的积分简化为：\n$$\nI = \\int \\frac{f_1(x)^2}{f_{K-1}(x)} dx\n$$\n\n我们现在将为指定的两条路径分析这个积分。\n\n### 标准几何退火路径\n对于此路径，基分布和目标分布的未归一化密度为：\n- 基分布: $f_0(x) \\propto \\exp(-\\frac{\\lVert x \\rVert^2}{2})$\n- 目标分布: $f_1(x) \\propto (1 + \\lVert x \\rVert^2)^{-\\nu}$\n\n在步骤 $k=K-1$ 时的中间密度是 $f_{K-1}(x) = f_0(x)^{1-\\beta_{K-1}} f_1(x)^{\\beta_{K-1}}$。\n将其代入积分 $I$：\n$$\nI_{\\text{geo}} = \\int \\frac{f_1(x)^2}{f_0(x)^{1-\\beta_{K-1}} f_1(x)^{\\beta_{K-1}}} dx = \\int f_0(x)^{-(1-\\beta_{K-1})} f_1(x)^{2-\\beta_{K-1}} dx\n$$\n现在，代入 $f_0$ 和 $f_1$ 的函数形式：\n$$\nI_{\\text{geo}} \\propto \\int \\left( \\exp\\left(-\\frac{\\lVert x \\rVert^2}{2}\\right) \\right)^{-(1-\\beta_{K-1})} \\left( (1 + \\lVert x \\rVert^2)^{-\\nu} \\right)^{2-\\beta_{K-1}} dx\n$$\n$$\nI_{\\text{geo}} \\propto \\int \\exp\\left(\\frac{1-\\beta_{K-1}}{2} \\lVert x \\rVert^2\\right) (1 + \\lVert x \\rVert^2)^{-\\nu(2-\\beta_{K-1})} dx\n$$\n为了使积分收敛，被积函数必须在 $\\lVert x \\rVert \\to \\infty$ 时足够快地衰减到零。然而，由于 $\\beta_k$ 是一个递增的调度表且 $\\beta_K=1$，我们有 $\\beta_{K-1}  1$。这意味着指数项中的系数 $1-\\beta_{K-1}$ 是严格为正的。当 $\\lVert x \\rVert \\to \\infty$ 时，项 $\\exp(\\frac{1-\\beta_{K-1}}{2} \\lVert x \\rVert^2)$ 会指数级增长。这种指数增长将永远超过 $(1 + \\lVert x \\rVert^2)^{-\\nu(2-\\beta_{K-1})}$ 的多项式衰减。被积函数发散，因此积分 $I_{\\text{geo}}$ 是无穷大。\n这表明当从轻尾（高斯）基分布过渡到重尾（类学生t）目标时，标准 AIS 会发生灾难性失效。最终增量权重的二阶矩总是无穷大。因此，布尔值 `geo_inf` 总是 `True`。\n\n“指数发散系数”定义为 $\\theta_{\\mathrm{geo}} := \\frac{a(\\beta_{K-1})}{2} - a(\\beta_{K})$。由于 $a(\\beta) = 1-\\beta$，我们有 $a(\\beta_{K-1})=1-\\beta_{K-1}$ 和 $a(\\beta_K)=a(1)=0$。所以，$\\theta_{\\mathrm{geo}} = \\frac{1-\\beta_{K-1}}{2}$。这恰好是发散指数项中 $\\lVert x \\rVert^2$ 的正系数，证实了它在导致积分爆炸中的作用。对于线性调度表 $\\beta_k = k/K$，我们有 $\\beta_{K-1}=(K-1)/K$，所以 $\\theta_{\\mathrm{geo}} = \\frac{1-(K-1)/K}{2} = \\frac{1/K}{2} = \\frac{1}{2K}$。\n\n### 感知尾部的多项式路径\n对于此路径，基分布和目标分布的未归一化密度为：\n- 基分布: $q_\\kappa(x) \\propto (1 + \\lVert x \\rVert^2)^{-\\kappa}$\n- 目标分布: $f_1(x) \\propto (1 + \\lVert x \\rVert^2)^{-\\nu}$\n\n中间密度为 $\\tilde f_{K-1}(x) = q_\\kappa(x)^{1-\\beta_{K-1}} f_1(x)^{\\beta_{K-1}}$。\n需要分析的积分是：\n$$\nI_{\\text{poly}} = \\int \\frac{f_1(x)^2}{\\tilde f_{K-1}(x)} dx = \\int q_\\kappa(x)^{-(1-\\beta_{K-1})} f_1(x)^{2-\\beta_{K-1}} dx\n$$\n代入函数形式：\n$$\nI_{\\text{poly}} \\propto \\int \\left( (1 + \\lVert x \\rVert^2)^{-\\kappa} \\right)^{-(1-\\beta_{K-1})} \\left( (1 + \\lVert x \\rVert^2)^{-\\nu} \\right)^{2-\\beta_{K-1}} dx\n$$\n$$\nI_{\\text{poly}} \\propto \\int (1 + \\lVert x \\rVert^2)^{\\kappa(1-\\beta_{K-1})} (1 + \\lVert x \\rVert^2)^{-\\nu(2-\\beta_{K-1})} dx\n$$\n$$\nI_{\\text{poly}} \\propto \\int (1 + \\lVert x \\rVert^2)^{-\\left[\\nu(2-\\beta_{K-1}) - \\kappa(1-\\beta_{K-1})\\right]} dx\n$$\n这是一个在 $\\mathbb{R}^d$ 上的形式为 $\\int (1+r^2)^{-p} d^d x$ 的积分，其中 $r = \\lVert x \\rVert$。使用超球坐标，该积分是有限的当且仅当被积函数衰减得足够快。对于大的 $r$，渐近行为是 $r^{-2p}$。在 $\\mathbb{R}^d$ 上的积分行为类似于 $\\int^\\infty r^{-2p} r^{d-1} dr = \\int^\\infty r^{d-1-2p} dr$。该积分收敛当且仅当指数小于 $-1$，即 $d-1-2p  -1$，简化为 $2p  d$。\n\n在我们的例子中，指数为 $p = \\nu(2-\\beta_{K-1}) - \\kappa(1-\\beta_{K-1})$。因此，二阶矩有限的条件是：\n$$\n2\\left[\\nu(2-\\beta_{K-1}) - \\kappa(1-\\beta_{K-1})\\right]  d\n$$\n让我们将其与“多项式可积性裕度” $\\rho_{\\mathrm{poly}} := (2 m(\\beta_K) - m(\\beta_{K-1})) - d/2$ 联系起来，其中 $m(\\beta) := \\nu \\beta + \\kappa (1 - \\beta)$。\n展开该项 $2 m(\\beta_K) - m(\\beta_{K-1})$：\n- $m(\\beta_K) = m(1) = \\nu(1) + \\kappa(1-1) = \\nu$。\n- $m(\\beta_{K-1}) = \\nu \\beta_{K-1} + \\kappa (1 - \\beta_{K-1})$。\n- $2 m(\\beta_K) - m(\\beta_{K-1}) = 2\\nu - (\\nu \\beta_{K-1} + \\kappa(1-\\beta_{K-1})) = 2\\nu - \\nu\\beta_{K-1} - \\kappa + \\kappa\\beta_{K-1} = \\nu(2-\\beta_{K-1}) - \\kappa(1-\\beta_{K-1})$。\n这正是我们推导出的指数 $p$。\n\n收敛条件 $2p > d$ 可以重写为 $p > d/2$。代入 $p = 2 m(\\beta_K) - m(\\beta_{K-1})$，条件变为：\n$$\n(2 m(\\beta_K) - m(\\beta_{K-1}))  \\frac{d}{2} \\iff (2 m(\\beta_K) - m(\\beta_{K-1})) - \\frac{d}{2}  0\n$$\n这恰好是条件 $\\rho_{\\mathrm{poly}}  0$。因此，增量权重的二阶矩是有限的当且仅当多项式可积性裕度为正。如果 $\\rho_{\\mathrm{poly}} \\le 0$，则发生发散。如果 $\\rho_{\\mathrm{poly}} \\le 0$，则布尔值 `poly_inf` 为 `True`，否则为 `False`。\n\n有了这些推导，我们现在可以实现一个程序来为给定的测试用例计算所需的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes AIS failure diagnostics for given test cases.\n\n    For each test case (d, nu, kappa, K), this function calculates four values:\n    1. geo_inf: Boolean, True if the second moment of the final incremental weight\n                under the standard geometric path is infinite.\n    2. poly_inf: Boolean, True if the second moment of the final incremental weight\n                 under the tail-aware polynomial path is infinite.\n    3. theta_geo: The exponential divergence coefficient for the geometric path.\n    4. rho_poly: The polynomial integrability margin for the polynomial path.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (d, nu, kappa, K).\n    test_cases = [\n        (2, 1.1, 1.5, 10),\n        (10, 6.0, 6.0, 20),\n        (50, 26.0, 26.0, 30),\n    ]\n\n    results = []\n    for case in test_cases:\n        d, nu, kappa, K = case\n\n        # --- Standard Geometric Path Analysis ---\n        \n        # As derived, bridging a light-tailed exponential base to a heavy-tailed\n        # polynomial target always results in an infinite second moment for the\n        # final importance weight. The integrand contains a term exp(c*||x||^2)\n        # where c  0, which causes divergence.\n        geo_inf = True\n\n        # Calculate the exponential divergence coefficient theta_geo.\n        # beta_k = k / K. beta_{K-1} = (K-1)/K.\n        # theta_geo = (1 - beta_{K-1}) / 2 = (1 - (K-1)/K) / 2 = (1/K) / 2 = 1 / (2*K).\n        theta_geo = 1.0 / (2.0 * K)\n\n        # --- Tail-Aware Polynomial Path Analysis ---\n\n        # Calculate the polynomial integrability margin rho_poly.\n        # beta_K = 1\n        # beta_{K-1} = (K-1)/K\n        # m(beta) = nu*beta + kappa*(1-beta)\n        # m(beta_K) = nu\n        # m(beta_{K-1}) = nu * (K-1)/K + kappa * (1 - (K-1)/K) = nu * (K-1)/K + kappa/K\n        # rho_poly = (2*m(beta_K) - m(beta_{K-1})) - d/2\n        #          = (2*nu - (nu*(K-1)/K + kappa/K)) - d/2\n        #          = nu*(2 - (K-1)/K) - kappa/K - d/2\n        #          = nu*( (2K - K + 1)/K ) - kappa/K - d/2\n        #          = nu*(K+1)/K - kappa/K - d/2\n        \n        rho_poly = nu * (K + 1.0) / K - kappa / K - d / 2.0\n        \n        # The second moment is infinite if and only if rho_poly is non-positive.\n        poly_inf = rho_poly = 0\n\n        # Append the results for the current test case.\n        results.append([geo_inf, poly_inf, theta_geo, rho_poly])\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to its string representation and join them.\n    # Python's default string conversion for bools and floats is used as required.\n    formatted_results = [f\"[{'True' if res[0] else 'False'},{'True' if res[1] else 'False'},{res[2]},{res[3]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了AIS的基本机制和潜在陷阱之后，下一步是学习如何优化其效率。一个固定的退火路径可能在某些“困难”区域浪费大量计算资源，而在“简单”区域又过于保守。这个练习介绍了一种高级的自适应策略，即利用初步运行（pilot runs）获得的信息来智能地调整退火路径的中间点分布。通过学习如何根据每个阶段的有效样本量（$ESS$）来重新分配计算资源，你将掌握一种使AIS算法更加自动化和高效的强大启发式方法。",
            "id": "3288085",
            "problem": "考虑在源分布 $p_0(x)$ 和目标分布 $p_1(x)$ 之间进行退火重要性采样，其退火路径为 $p_t(x) \\propto p_0(x)^{1-t} p_1(x)^t$，其中 $t \\in [0,1]$。给定一个由 $\\{t_k\\}_{k=0}^K$ 定义的调度，其中 $t_0 = 0$ 且 $t_K = 1$。对于每个阶段 $k \\in \\{1,\\dots,K\\}$，状态 $x$ 的增量重要性权重为\n$$\nw_k(x) = \\frac{p_{t_k}(x)}{p_{t_{k-1}}(x)} = \\exp\\!\\big((t_k - t_{k-1}) \\big(\\log p_1(x) - \\log p_0(x)\\big)\\big).\n$$\n假设您运行 $R$ 条预退火重要性采样轨迹，在每个阶段 $k$ 产生增量权重 $\\{w_k^{(i)}\\}_{i=1}^R$。将阶段性有效样本量 (ESS) 定义为\n$$\nESS_k = \\frac{\\left(\\sum_{i=1}^R w_k^{(i)}\\right)^2}{\\sum_{i=1}^R \\left(w_k^{(i)}\\right)^2}.\n$$\n给定总共 $M$ 个中间点的预算，通过细化调度（即将现有区间 $[t_{k-1},t_k]$ 分割为子区间）将这些点分布在路径 $t \\in [0,1]$ 上，以便启发式地确保任何阶段的阶段性 ESS 不低于预设的最小值 $ESS_{\\min}$。目标是选择一种启发式方法，该方法利用预运行信息自适应地将这 $M$ 个中间点重新分配到整个调度中，以达到每个阶段的最小 ESS 目标。\n\n以下哪个选项描述了一种科学上合理的启发式方法，该方法使用预运行的估计值来自适应地细化调度，以达到每个阶段的最小 ESS 目标，同时保持中间点总数等于 $M$？\n\nA. 根据预运行，计算每个阶段 $k$ 的 $\\widehat{ESS}_k$，并设 $\\hat{\\sigma}_k^2 = \\log\\!\\big(R/\\widehat{ESS}_k\\big)$。将 $\\log w_k$ 的方差视为与步长成二次方比例缩放，选择一个局部步长目标\n$$\n\\Delta t_k^\\star = \\Delta t_k \\sqrt{\\frac{\\log\\!\\big(R/ESS_{\\min}\\big)}{\\hat{\\sigma}_k^2}},\n$$\n其中 $\\Delta t_k = t_k - t_{k-1}$ 是当前步长。将 $[t_{k-1},t_k]$ 中的子步数 $m_k$ 按与 $(\\Delta t_k/\\Delta t_k^\\star)$ 成正比的方式分配，即 $m_k \\propto \\sqrt{\\hat{\\sigma}_k^2 / \\log\\!\\big(R/ESS_{\\min}\\big)}$，并重新缩放 $\\{m_k\\}$ 使得 $\\sum_{k=1}^K m_k = M$。将每个区间分割成 $m_k$ 个相等的子区间，以形成细化后的调度。\n\nB. 将 $M$ 个中间点按与 $\\widehat{ESS}_k$ 成正比的方式重新分配到各个阶段，将更多的点分配给 $\\widehat{ESS}_k$ 较大的阶段，因为这些阶段产生更可靠的增量权重，因此应进一步细化。\n\nC. 使用每个阶段（来自预运行）的转移核的平均 Metropolis–Hastings 接受概率作为唯一标准，将更多中间点分配给接受率较低的阶段，而不考虑增量权重，因为改善混合会自动产生更高的有效样本量。\n\nD. 通过在细化后设置 $t_k = k/K$，使 $M$ 个中间点在 $t$ 中等间距分布，并忽略预运行的 ESS 信息，因为等间距可以避免对预运行的偏置和过拟合，从而在各个阶段均匀地保持估计量质量。",
            "solution": "用户要求分析一个关于退火重要性采样（AIS）的自适应调度选择问题。首先，对问题陈述的科学性和逻辑完整性进行验证。\n\n### 问题验证\n\n问题陈述描述了退火重要性采样（AIS）的标准设置，并提出了一个关于设计自适应调度的问题。\n- **已知条件**：\n    - 源分布 $p_0(x)$ 和目标分布 $p_1(x)$。\n    - 对于 $t \\in [0,1]$，退火路径为 $p_t(x) \\propto p_0(x)^{1-t} p_1(x)^t$。\n    - 初始调度 $\\{t_k\\}_{k=0}^K$，其中 $t_0 = 0$ 且 $t_K = 1$。\n    - 增量重要性权重定义为 $w_k(x) = \\exp\\!\\big((t_k - t_{k-1}) \\big(\\log p_1(x) - \\log p_0(x)\\big)\\big)$。这对应于未归一化密度的比率 $\\tilde{p}_{t_k}(x)/\\tilde{p}_{t_{k-1}}(x)$，这在 AIS 中是标准的，尽管记法 $w_k(x) = p_{t_k}(x)/p_{t_{k-1}}(x)$ 可能存在歧义。\n    - $R$ 次预运行在每个阶段 $k$ 产生权重 $\\{w_k^{(i)}\\}_{i=1}^R$。\n    - 阶段性有效样本量 (ESS) 定义为 $ESS_k = \\frac{\\left(\\sum_{i=1}^R w_k^{(i)}\\right)^2}{\\sum_{i=1}^R \\left(w_k^{(i)}\\right)^2}$。这是一个标准定义。\n    - 用于调度细化的 $M$ 个中间点的预算。\n    - 目标最小阶段性 ESS，$ESS_{\\min}$。\n- **验证结论**：该问题在科学上基于蒙特卡洛方法的理论，特别是 AIS。问题提法恰当，要求根据已确立的方差缩减原则评估几种启发式方法。其术语和公式在该领域是标准的。问题是客观的，并包含足够的信息来从选项中确定最合理的一种启发式方法。因此，该问题是**有效的**。\n\n### 正确启发式方法的推导\n\n细化退火调度的主要目标是控制重要性权重的方差。任何阶段权重的高方差都会导致低的有效样本量（ESS），这反过来又会降低配分函数比 $Z_1/Z_0$ 或在 $p_1(x)$ 下的期望的最终估计量的质量。目标是分配中间调度点以均衡所有步骤的难度，这可以通过将阶段性 ESS 保持在某个阈值以上来衡量。\n\n阶段性 $ESS_k$ 与权重 $w_k^{(i)}$ 的相对方差有关。一个更稳定且在理论上更便于分析的量是对数权重的方差。设 $\\sigma_k^2 = \\text{Var}_{x \\sim p_{t_{k-1}}}[\\log w_k(x)]$。假设权重 $w_k$ 近似服从对数正态分布，则 ESS 和对数权重方差之间的关系为：\n$$\nESS_k \\approx R \\exp(-\\sigma_k^2)\n$$\n从这个关系中，我们可以根据预运行的经验 $\\widehat{ESS}_k$ 估计对数权重的方差：\n$$\n\\hat{\\sigma}_k^2 \\approx \\log\\left(\\frac{R}{\\widehat{ESS}_k}\\right)\n$$\n低的 $\\widehat{ESS}_k$ 对应于高的估计方差 $\\hat{\\sigma}_k^2$，表明从 $t_{k-1}$到 $t_k$ 是一个“困难”的过渡。\n\n对数权重由 $\\log w_k(x) = (t_k - t_{k-1})(\\log p_1(x) - \\log p_0(x))$ 给出。设步长为 $\\Delta t_k = t_k - t_{k-1}$，且 $L(x) = \\log p_1(x) - \\log p_0(x)$。那么，对数权重的方差为：\n$$\n\\sigma_k^2 = \\text{Var}_{p_{t_{k-1}}}[\\log w_k(x)] = (\\Delta t_k)^2 \\text{Var}_{p_{t_{k-1}}}[L(x)]\n$$\n这表明对数权重的方差与步长 $\\Delta t_k$ 成二次方比例。$\\text{Var}_{p_{t_{k-1}}}[L(x)]$ 这一项可以被认为是路径在温度 $t_{k-1}$ 时的内在难度。\n\n启发式方法旨在创建一个新的调度，其中每一步都具有大致相同的目标对数权重方差 $\\sigma_{\\min}^2$，该方差对应于目标 $ESS_{\\min}$。根据我们的近似，这个目标方差是 $\\sigma_{\\min}^2 = \\log(R/ESS_{\\min})$。\n\n考虑长度为 $\\Delta t_k$ 的原始第 $k$ 个区间 $[t_{k-1}, t_k]$。我们希望将其细分为 $m_k$ 个更小的区间，每个区间的长度为 $\\delta t_k = \\Delta t_k / m_k$。对于每个新的小步，其对数权重的方差将是：\n$$\n\\sigma_{\\text{new}}^2 \\approx (\\delta t_k)^2 \\text{Var}_{p_{t_{k-1}}}[L(x)]\n$$\n这里，我们使用近似，即内在方差 $\\text{Var}_{p_t}[L(x)]$ 在 $t \\in [t_{k-1}, t_k]$ 上大致恒定。\n从预运行中，我们得到估计值 $\\hat{\\sigma}_k^2 = (\\Delta t_k)^2 \\text{Var}_{p_{t_{k-1}}}[L(x)]$，这意味着 $\\text{Var}_{p_{t_{k-1}}}[L(x)] \\approx \\hat{\\sigma}_k^2 / (\\Delta t_k)^2$。\n将此代入新方差的表达式中：\n$$\n\\sigma_{\\text{new}}^2 \\approx \\left(\\frac{\\Delta t_k}{m_k}\\right)^2 \\frac{\\hat{\\sigma}_k^2}{(\\Delta t_k)^2} = \\frac{\\hat{\\sigma}_k^2}{m_k^2}\n$$\n为了达到目标方差 $\\sigma_{\\min}^2$，我们设置 $\\sigma_{\\text{new}}^2 = \\sigma_{\\min}^2$：\n$$\n\\frac{\\hat{\\sigma}_k^2}{m_k^2} = \\sigma_{\\min}^2 \\implies m_k^2 = \\frac{\\hat{\\sigma}_k^2}{\\sigma_{\\min}^2} \\implies m_k = \\frac{\\hat{\\sigma}_k}{\\sigma_{\\min}}\n$$\n这个结果是自适应启发式方法的核心：在原始区间 $[t_{k-1}, t_k]$ 中放置的子步数 $m_k$ 应与对数权重的估计标准差 $\\hat{\\sigma}_k$ 成正比。\n$$\nm_k \\propto \\hat{\\sigma}_k\n$$\n子步总数受预算 $M$ 的约束（假设 $\\sum m_k = M$），因此最终分配为 $m_k = M \\frac{\\hat{\\sigma}_k}{\\sum_{j=1}^K \\hat{\\sigma}_j}$。这种策略将更多的点分配给观测到具有高方差（低 ESS）的区间，这在科学上是合理的。\n\n### 逐项分析\n\n**A. 根据预运行，计算每个阶段 $k$ 的 $\\widehat{ESS}_k$，并设 $\\hat{\\sigma}_k^2 = \\log\\!\\big(R/\\widehat{ESS}_k\\big)$。将 $\\log w_k$ 的方差视为与步长成二次方比例缩放，选择一个局部步长目标 $\\Delta t_k^\\star = \\Delta t_k \\sqrt{\\frac{\\log\\!\\big(R/ESS_{\\min}\\big)}{\\hat{\\sigma}_k^2}}$，其中 $\\Delta t_k = t_k - t_{k-1}$ 是当前步长。将 $[t_{k-1},t_k]$ 中的子步数 $m_k$ 按与 $(\\Delta t_k/\\Delta t_k^\\star)$ 成正比的方式分配，即 $m_k \\propto \\sqrt{\\hat{\\sigma}_k^2 / \\log\\!\\big(R/ESS_{\\min}\\big)}$，并重新缩放 $\\{m_k\\}$ 使得 $\\sum_{k=1}^K m_k = M$。将每个区间分割成 $m_k$ 个相等的子区间，以形成细化后的调度。**\n\n此选项精确地遵循了推导出的逻辑。\n1.  估计 $\\hat{\\sigma}_k^2 = \\log(R/\\widehat{ESS}_k)$ 是标准的。\n2.  目标步长 $\\Delta t_k^{\\star}$ 被定义为能够产生目标方差 $\\sigma_{\\min}^2 = \\log(R/ESS_{\\min})$ 的步长。如推导所示，理想的子步数是 $m_k = \\hat{\\sigma}_k / \\sigma_{\\min}$。目标步长是 $\\Delta t_k^\\star = \\Delta t_k / m_k = \\Delta t_k \\sigma_{\\min} / \\hat{\\sigma}_k = \\Delta t_k \\sqrt{\\sigma_{\\min}^2 / \\hat{\\sigma}_k^2}$，这与公式相符。\n3.  分配规则 $m_k \\propto (\\Delta t_k / \\Delta t_k^\\star)$ 意味着需要 $m_k$ 个大小为 $\\Delta t_k^\\star$ 的子步来覆盖大小为 $\\Delta t_k$ 的区间。这是正确的。\n4.  比例关系 $m_k \\propto \\sqrt{\\hat{\\sigma}_k^2 / \\log(R/ESS_{\\min})}$ 等价于 $m_k \\propto \\hat{\\sigma}_k / \\sigma_{\\min}$，由于 $\\sigma_{\\min}$ 是一个常数，这可以简化为 $m_k \\propto \\hat{\\sigma}_k$。这与我们的推导完全匹配。\n整个过程是 AIS 中基于方差的合理自适应调度启发式方法的一个教科书般的例子。\n\n**结论：正确**\n\n**B. 将 $M$ 个中间点按与 $\\widehat{ESS}_k$ 成正比的方式重新分配到各个阶段，将更多的点分配给 $\\widehat{ESS}_k$ 较大的阶段，因为这些阶段产生更可靠的增量权重，因此应进一步细化。**\n\n这种启发式方法在根本上是错误的。一个大的 $\\widehat{ESS}_k$ 表示权重方差小，意味着从 $t_{k-1}$ 到 $t_k$ 的步骤是“容易的”。这些阶段需要*更少*的点，而不是更多。相反，$\\widehat{ESS}_k$ 低的阶段是“困难的”，需要被分解成更小的子步（即分配更多的点）。这个选项提出了与正确策略完全相反的策略。\n\n**结论：不正确**\n\n**C. 使用每个阶段（来自预运行）的转移核的平均 Metropolis–Hastings 接受概率作为唯一标准，将更多中间点分配给接受率较低的阶段，而不考虑增量权重，因为改善混合会自动产生更高的有效样本量。**\n\n这种启发式方法解决了 AIS 性能的另一个方面。MCMC 转移核 $T_k(x'|x)$ 用于从 $p_{t_k}(x)$ 生成样本。低接受率确实表明混合不佳，这是一个问题。然而，决定整个 AIS 估计量方差的主导因素是重要性权重乘积的方差。阶段性 ESS 是对方差贡献的直接度量。虽然混合不佳会影响预运行对 ESS 的估计，但这两个量（接受率和权重方差）并不直接等价。如果分布 $p_{t_{k-1}}$ 和 $p_{t_k}$ 非常不同，即使接受率很高，权重方差也可能很大。问题明确要求以每个阶段的最小 ESS 为目标，因此使用 ESS 的直接估计（或其代理 $\\hat{\\sigma}_k^2$）是最科学合理的方法。忽略增量权重是一个严重的错误。\n\n**结论：不正确**\n\n**D. 通过在细化后设置 $t_k = k/K$，使 $M$ 个中间点在 $t$ 中等间距分布，并忽略预运行的 ESS 信息，因为等间距可以避免对预运行的偏置和过拟合，从而在各个阶段均匀地保持估计量质量。**\n\n这描述了一种非自适应或静态的调度。预运行的目的是收集信息以改进调度。忽略这些信息违背了自适应过程的目的。虽然静态调度很简单，但如果退火路径的“难度”不均匀，它们的效率可能会非常低。问题明确要求一种*使用*预运行信息来*自适应地*细化调度的启发式方法。这个选项提议两者都不做。\n\n**结论：不正确**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}