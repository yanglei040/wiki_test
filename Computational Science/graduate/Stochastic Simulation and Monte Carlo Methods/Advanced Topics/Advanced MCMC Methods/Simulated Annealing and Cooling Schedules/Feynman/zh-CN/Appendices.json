{
    "hands_on_practices": [
        {
            "introduction": "在模拟退火中，Metropolis接受准则扮演着核心角色，它决定了算法是接受一个新状态还是停留在当前状态。要精通模拟退火，我们必须首先从数学上理解温度 $T$ 如何调控接受率。这个练习要求您为一个给定的能量变化分布推导出期望接受率的精确解析表达式，从而让您对算法在不同温度下的行为建立起定量的直觉。",
            "id": "3339540",
            "problem": "考虑一个使用 Metropolis 接受准则的模拟退火 (SA) 算法，该算法以概率 $a(\\Delta E, T) = \\min\\{1, \\exp(-\\Delta E/T)\\}$ 接受一个建议的移动，其中 $\\Delta E$ 是建议状态与当前状态之间的能量差，而 $T > 0$ 是当前温度。假设在给定的提议机制下，能量差的分布可以很好地用均值为 $\\mu \\in \\mathbb{R}$、标准差为 $\\sigma > 0$ 的正态分布 $\\Delta E \\sim \\mathcal{N}(\\mu, \\sigma^{2})$ 来近似。仅使用 Metropolis 接受准则和正态分布的定义，推导期望接受率\n$$A(T) = \\mathbb{E}\\big[\\min\\{1, \\exp(-\\Delta E/T)\\}\\big],$$\n的精确闭式表达式，该表达式用 $\\mu$、$\\sigma$、T 和标准正态分布的累积分布函数表示。在您的推导中，从期望的积分表示开始，并使用正态分布的基本性质来证明所有变换的合理性。然后，用文字讨论在极限情况 $T \\to 0^{+}$ 和 $T \\to \\infty$ 下，$A(T)$ 如何依赖于 $T$，无需计算任何导数。提供 $A(T)$ 的最终表达式，不要进行任何四舍五入，也不要包含任何物理单位。将标准正态累积分布函数 $\\Phi(z)$ 定义为 $\\Phi(z) = \\int_{-\\infty}^{z} \\frac{1}{\\sqrt{2\\pi}} \\exp\\big(-\\frac{y^{2}}{2}\\big)\\,dy$。",
            "solution": "该问题是有效的，因为它具有科学依据、良构且客观。这是随机算法研究中的一个标准问题，没有任何事实性错误、歧义或信息缺失。\n\n目标是推导模拟退火算法中期望接受率 $A(T)$ 的闭式表达式。在温度 $T$ 下，能量变化为 $\\Delta E$ 的移动的接受概率由 Metropolis 准则给出：\n$$a(\\Delta E, T) = \\min\\{1, \\exp(-\\Delta E/T)\\}$$\n能量变化 $\\Delta E$ 是一个服从正态分布 $\\Delta E \\sim \\mathcal{N}(\\mu, \\sigma^{2})$ 的随机变量，其概率密度函数 (PDF) 为：\n$$p(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp\\left(-\\frac{(x-\\mu)^{2}}{2\\sigma^{2}}\\right)$$\n期望接受率 $A(T)$ 是 $a(\\Delta E, T)$ 在 $\\Delta E$ 分布上的期望。对于一个连续随机变量，这由以下积分给出：\n$$A(T) = \\mathbb{E}[a(\\Delta E, T)] = \\int_{-\\infty}^{\\infty} \\min\\{1, \\exp(-x/T)\\} p(x) dx$$\n函数 $\\min\\{1, \\exp(-x/T)\\}$ 取决于 $x$ 的符号。\n- 如果 $x \\ge 0$，则 $-x/T \\le 0$，所以 $\\exp(-x/T) \\le 1$。因此，$\\min\\{1, \\exp(-x/T)\\} = \\exp(-x/T)$。\n- 如果 $x  0$，则 $-x/T  0$，所以 $\\exp(-x/T)  1$。因此，$\\min\\{1, \\exp(-x/T)\\} = 1$。\n\n基于这一观察，我们可以在 $x=0$ 处将积分拆分：\n$$A(T) = \\int_{-\\infty}^{0} 1 \\cdot p(x) dx + \\int_{0}^{\\infty} \\exp(-x/T) p(x) dx$$\n让我们分别计算每个积分。\n\n第一个积分 $I_1 = \\int_{-\\infty}^{0} p(x) dx$ 表示能量差 $\\Delta E$ 小于或等于 0 的概率，即 $P(\\Delta E \\le 0)$。我们可以使用标准正态分布的累积分布函数 (CDF) $\\Phi(z)$ 来表示它。我们首先对变量进行标准化：\n$$P(\\Delta E \\le 0) = P\\left(\\frac{\\Delta E - \\mu}{\\sigma} \\le \\frac{0 - \\mu}{\\sigma}\\right)$$\n由于 $Z = (\\Delta E - \\mu)/\\sigma$ 是一个标准正态随机变量，这个概率是：\n$$I_1 = P\\left(Z \\le -\\frac{\\mu}{\\sigma}\\right) = \\Phi\\left(-\\frac{\\mu}{\\sigma}\\right)$$\n\n第二个积分是 $I_2 = \\int_{0}^{\\infty} \\exp(-x/T) p(x) dx$。代入 PDF $p(x)$：\n$$I_2 = \\int_{0}^{\\infty} \\exp(-x/T) \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp\\left(-\\frac{(x-\\mu)^{2}}{2\\sigma^{2}}\\right) dx$$\n我们可以合并指数函数的参数：\n$$I_2 = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\int_{0}^{\\infty} \\exp\\left(-\\frac{x}{T} - \\frac{(x-\\mu)^{2}}{2\\sigma^{2}}\\right) dx$$\n为了求解这个积分，我们对指数中包含 $x$ 的项进行配方法。设指数的参数为 $\\mathcal{E}$。\n$$\\mathcal{E} = -\\frac{1}{2\\sigma^{2}} \\left[ \\frac{2\\sigma^{2}x}{T} + (x-\\mu)^{2} \\right] = -\\frac{1}{2\\sigma^{2}} \\left[ \\frac{2\\sigma^{2}x}{T} + x^{2} - 2\\mu x + \\mu^{2} \\right]$$\n$$\\mathcal{E} = -\\frac{1}{2\\sigma^{2}} \\left[ x^{2} - 2\\left(\\mu - \\frac{\\sigma^{2}}{T}\\right)x + \\mu^{2} \\right]$$\n对 $x^{2} - 2(\\mu - \\sigma^{2}/T)x$ 进行配方：\n$$\\mathcal{E} = -\\frac{1}{2\\sigma^{2}} \\left[ \\left(x - \\left(\\mu - \\frac{\\sigma^{2}}{T}\\right)\\right)^{2} - \\left(\\mu - \\frac{\\sigma^{2}}{T}\\right)^{2} + \\mu^{2} \\right]$$\n$$\\mathcal{E} = -\\frac{\\left(x - (\\mu - \\sigma^{2}/T)\\right)^{2}}{2\\sigma^{2}} + \\frac{1}{2\\sigma^{2}} \\left[ \\left(\\mu - \\frac{\\sigma^{2}}{T}\\right)^{2} - \\mu^{2} \\right]$$\n第二项化简为：\n$$\\frac{1}{2\\sigma^{2}} \\left[ \\mu^{2} - \\frac{2\\mu\\sigma^{2}}{T} + \\frac{\\sigma^{4}}{T^{2}} - \\mu^{2} \\right] = \\frac{1}{2\\sigma^{2}} \\left[ -\\frac{2\\mu\\sigma^{2}}{T} + \\frac{\\sigma^{4}}{T^{2}} \\right] = -\\frac{\\mu}{T} + \\frac{\\sigma^{2}}{2T^{2}}$$\n所以，指数为：\n$$\\mathcal{E} = -\\frac{\\left(x - (\\mu - \\sigma^{2}/T)\\right)^{2}}{2\\sigma^{2}} + \\frac{\\sigma^{2}}{2T^{2}} - \\frac{\\mu}{T}$$\n将此代回 $I_2$ 的积分中：\n$$I_2 = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\int_{0}^{\\infty} \\exp\\left(-\\frac{\\left(x - (\\mu - \\sigma^{2}/T)\\right)^{2}}{2\\sigma^{2}} + \\frac{\\sigma^{2}}{2T^{2}} - \\frac{\\mu}{T}\\right) dx$$\n项 $\\exp(\\sigma^{2}/(2T^{2}) - \\mu/T)$ 相对于 $x$ 是常数，可以被提取出来：\n$$I_2 = \\exp\\left(\\frac{\\sigma^{2}}{2T^{2}} - \\frac{\\mu}{T}\\right) \\int_{0}^{\\infty} \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp\\left(-\\frac{(x - \\mu')^{2}}{2\\sigma^{2}}\\right) dx$$\n其中我们定义了一个新的均值 $\\mu' = \\mu - \\sigma^{2}/T$。该积分是随机变量 $X' \\sim \\mathcal{N}(\\mu', \\sigma^{2})$ 的概率 $P(X' \\ge 0)$。我们对此进行标准化来求概率：\n$$P(X' \\ge 0) = P\\left(\\frac{X' - \\mu'}{\\sigma} \\ge \\frac{0 - \\mu'}{\\sigma}\\right) = P\\left(Z \\ge -\\frac{\\mu'}{\\sigma}\\right)$$\n使用标准正态分布的对称性，$P(Z \\ge -z) = P(Z \\le z) = \\Phi(z)$。因此，该积分的计算结果为 $\\Phi(\\mu'/\\sigma)$。\n将 $\\mu'$ 代回：\n$$\\Phi\\left(\\frac{\\mu'}{\\sigma}\\right) = \\Phi\\left(\\frac{\\mu - \\sigma^{2}/T}{\\sigma}\\right) = \\Phi\\left(\\frac{\\mu}{\\sigma} - \\frac{\\sigma}{T}\\right)$$\n因此，第二个积分是：\n$$I_2 = \\exp\\left(\\frac{\\sigma^{2}}{2T^{2}} - \\frac{\\mu}{T}\\right) \\Phi\\left(\\frac{\\mu}{\\sigma} - \\frac{\\sigma}{T}\\right)$$\n合并 $I_1$ 和 $I_2$，我们得到期望接受率的最终表达式：\n$$A(T) = \\Phi\\left(-\\frac{\\mu}{\\sigma}\\right) + \\exp\\left(\\frac{\\sigma^{2}}{2T^{2}} - \\frac{\\mu}{T}\\right) \\Phi\\left(\\frac{\\mu}{\\sigma} - \\frac{\\sigma}{T}\\right)$$\n\n接下来，我们讨论在极限情况 $T \\to 0^{+}$ 和 $T \\to \\infty$ 下 $A(T)$ 的行为。\n\n对于高温极限 $T \\to \\infty$：\n从物理上看，当温度变得非常大时，对于任何有限的能量变化 $\\Delta E$，项 $-\\Delta E/T$ 趋近于 0。接受概率 $\\exp(-\\Delta E/T)$ 趋近于 $\\exp(0)=1$。因此，$\\min\\{1, \\exp(-\\Delta E/T)\\}$ 趋近于 1，意味着几乎所有建议的移动都被接受。因此，期望接受率 $A(T)$ 应该趋近于 1。\n从数学上看，我们考察我们推导出的表达式的极限：\n$$\\lim_{T\\to\\infty} A(T) = \\lim_{T\\to\\infty} \\left[ \\Phi\\left(-\\frac{\\mu}{\\sigma}\\right) + \\exp\\left(\\frac{\\sigma^{2}}{2T^{2}} - \\frac{\\mu}{T}\\right) \\Phi\\left(\\frac{\\mu}{\\sigma} - \\frac{\\sigma}{T}\\right) \\right]$$\n当 $T \\to \\infty$ 时，我们有 $\\sigma^{2}/(2T^{2}) \\to 0$，$\\mu/T \\to 0$，以及 $\\sigma/T \\to 0$。\n极限变为：\n$$A(\\infty) = \\Phi\\left(-\\frac{\\mu}{\\sigma}\\right) + \\exp(0 - 0) \\Phi\\left(\\frac{\\mu}{\\sigma} - 0\\right) = \\Phi\\left(-\\frac{\\mu}{\\sigma}\\right) + \\Phi\\left(\\frac{\\mu}{\\sigma}\\right)$$\n使用性质 $\\Phi(-z) = 1 - \\Phi(z)$，这可以化简为：\n$$A(\\infty) = \\left(1 - \\Phi\\left(\\frac{\\mu}{\\sigma}\\right)\\right) + \\Phi\\left(\\frac{\\mu}{\\sigma}\\right) = 1$$\n这证实了物理直觉。\n\n对于低温极限 $T \\to 0^{+}$：\n从物理上看，当温度趋近于零时，系统表现得像一个贪婪算法。如果一个建议的移动是“下坡”的（$\\Delta E \\le 0$），那么 $-\\Delta E/T \\to +\\infty$ 并且 $\\exp(-\\Delta E/T) \\to \\infty$，使得接受概率为 1。如果一个移动是“上坡”的（$\\Delta E  0$），那么 $-\\Delta E/T \\to -\\infty$ 并且 $\\exp(-\\Delta E/T) \\to 0$，使得接受概率为 0。因此，在零温度下，只有下坡的移动被接受。期望接受率应收敛到提议一个下坡移动的概率，即 $P(\\Delta E \\le 0)$。\n根据对 $I_1$ 的计算，这个概率是 $P(\\Delta E \\le 0) = \\Phi(-\\mu/\\sigma)$。\n从数学上看，我们考察 $A(T)$ 表达式中第二项的极限：\n$$\\lim_{T\\to 0^{+}} \\exp\\left(\\frac{\\sigma^{2}}{2T^{2}} - \\frac{\\mu}{T}\\right) \\Phi\\left(\\frac{\\mu}{\\sigma} - \\frac{\\sigma}{T}\\right)$$\n当 $T \\to 0^{+}$ 时，$\\Phi$ 的自变量 $z(T) = \\mu/\\sigma - \\sigma/T$ 趋向于 $-\\infty$。因此，$\\Phi(z(T)) \\to 0$。指数的参数 $\\sigma^{2}/(2T^{2}) - \\mu/T$ 趋向于 $+\\infty$，所以指数项发散到 $+\\infty$。这给出了一个 $\\infty \\cdot 0$ 的不定型。\n通过设置 $u=1/T$ 并令 $u \\to \\infty$ 来应用洛必达法则，可以表明这个乘积趋向于 0。正态累积分布函数尾部的指数衰减比前置因子的指数增长更快。因此，第二项在极限下消失。\n$$\\lim_{T\\to 0^{+}} A(T) = \\Phi\\left(-\\frac{\\mu}{\\sigma}\\right) + 0 = \\Phi\\left(-\\frac{\\mu}{\\sigma}\\right)$$\n这个结果证实了物理直觉，即在零温度下，接受率就是提议一个非上坡移动的概率。",
            "answer": "$$\\boxed{\\Phi\\left(-\\frac{\\mu}{\\sigma}\\right) + \\exp\\left(\\frac{\\sigma^{2}}{2T^{2}} - \\frac{\\mu}{T}\\right) \\Phi\\left(\\frac{\\mu}{\\sigma} - \\frac{\\sigma}{T}\\right)}$$"
        },
        {
            "introduction": "掌握了基本的接受机制后，下一个关键是理解降温方案的重要性。一个设计不当、降温过快的方案是模拟退火失败的主要原因之一，因为它可能导致算法在找到全局最优解之前就被“冻结”在局部最小值中。通过一个巧妙设计的思想实验，本练习将这个抽象的风险具体化，要求您计算在指数降温下未能越过能量势垒的精确概率。",
            "id": "3339511",
            "problem": "考虑在马尔可夫链蒙特卡洛 (MCMC) 框架下，由 Metropolis 接受准则驱动的模拟退火 (SA) 算法。在第 $k$ 次迭代时，温度为 $T_k$，一个使能量增加 $\\Delta E$ 的上坡提议以概率 $\\exp\\!\\big(-\\Delta E / T_k\\big)$ 被接受。构建一个一维双阱能量形貌，其中系统最初被困在一个局部最小值中，进入全局最小值吸引盆的唯一方法是接受至少一次使能量恰好增加 $D$ 的上坡移动。假设在每次迭代 $k$ 中，提议机制以概率 $q$ 独立地尝试一次这样的越垒移动，否则提议不改变吸引盆的移动。温度调度是指数形式的，$T_k = T_0 \\alpha^k$，其中 $T_0 = 1$ 且 $\\alpha = \\tfrac{1}{2}$。取 $D = 5$，$q = 0.2$，并假设退火过程运行 $N = 100$ 次迭代。仅使用上述 SA 基础，从第一性原理推导在 $N$ 次迭代内未能越过势垒的概率的精确表达式，并进行数值计算。\n\n将最终数值答案四舍五入至六位有效数字。失败概率是无量纲的；不要在最终答案中包含任何单位。",
            "solution": "在进行求解之前，对问题陈述进行严格验证。\n\n### 步骤 1：提取已知条件\n- **算法**：使用 Metropolis 接受准则的模拟退火 (SA)。\n- **系统**：一维双阱能量形貌。\n- **初始状态**：系统被困在局部最小值中。\n- **越垒条件**：要进入全局最小值的吸引盆，系统必须接受至少一次使能量恰好增加 $\\Delta E = D$ 的上坡移动。\n- **提议机制**：在每次迭代 $k$ 中，以概率 $q$ 提议一次越垒移动（能量增加 $D$）。其他提议的移动不会导致吸引盆的改变。每次迭代的提议是独立的。\n- **接受概率**：在温度 $T_k$ 下，能量增加 $\\Delta E$ 的上坡提议以概率 $\\exp(-\\Delta E / T_k)$ 被接受。\n- **温度调度**：$T_k = T_0 \\alpha^k$，一个指数降温方案。\n- **参数**：\n    - 能垒高度: $D = 5$。\n    - 越垒移动的提议概率: $q = 0.2$。\n    - 总迭代次数: $N = 100$。\n    - 初始温度: $T_0 = 1$。\n    - 降温因子: $\\alpha = \\frac{1}{2}$。\n- **目标**：推导在 $N$ 次迭代内未能越过势垒的概率的精确表达式，并进行数值计算，结果四舍五入至六位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n对问题进行有效性评估：\n- **科学依据**：该问题基于模拟退火、马尔可夫链蒙特卡洛方法和 Metropolis-Hastings 算法等公认的原理。使用简化的双阱势是分析此类算法行为的标准且有效的理论构造。所有概念均来自主流的计算物理学和统计学。\n- **适定性**：所有必要的参数（$D, q, N, T_0, \\alpha$）和函数形式（降温方案、接受概率）都已明确给出。目标定义清晰：计算一个特定的概率。这些条件足以推导出一个唯一的、有意义的解。\n- **客观性**：问题以精确、定量和无偏见的语言陈述。它不含主观论断。\n\n该问题未表现出任何无效性标志。它是科学合理的、形式上完整的和客观的。\n\n### 步骤 3：结论与行动\n该问题被认为是**有效的**。将按要求从第一性原理推导解答。\n\n### 解的推导\n目标是计算系统在 $N$ 次迭代内未能从局部最小值跃迁到全局最小值吸引盆的概率。根据问题陈述，这种跃迁需要接受至少一次能量增加为 $D$ 的特定上坡移动。跃迁失败意味着在 $N$ 次迭代中的任何一次都没有接受这样的移动。\n\n设迭代由 $k$ 索引，其中 $k$ 从 $0$ 到 $N-1$。\n在任意一次迭代 $k$ 中，只有当两个独立事件相继发生时，才可能成功越垒：\n1.  提议一个能量增加为 $D$ 的越垒移动。该事件的概率为 $p_{\\text{propose}} = q$。\n2.  这个提议的移动被接受。该移动是上坡的，能量变化为 $\\Delta E = D$。在温度 $T_k$ 下，Metropolis 接受概率为 $p_{\\text{accept}}(k) = \\exp\\left(-\\frac{\\Delta E}{T_k}\\right) = \\exp\\left(-\\frac{D}{T_k}\\right)$。\n\n第 $k$ 次迭代的温度由指数降温方案给出：$T_k = T_0 \\alpha^k$。\n将其代入接受概率，得到：\n$$p_{\\text{accept}}(k) = \\exp\\left(-\\frac{D}{T_0 \\alpha^k}\\right)$$\n\n在第 $k$ 次迭代成功越垒的概率，我们称之为 $P_k(\\text{cross})$，是提议移动和接受移动的概率之积，因为它们是独立事件：\n$$P_k(\\text{cross}) = p_{\\text{propose}} \\times p_{\\text{accept}}(k) = q \\exp\\left(-\\frac{D}{T_0 \\alpha^k}\\right)$$\n\n问题要求的是*未能*越过势垒的概率。这意味着对于从 $0$ 到 $N-1$ 的每一次迭代 $k$，系统都*没有*越过势垒。在单次迭代 $k$ 中未能越垒的概率是越垒概率的补集：\n$$P_k(\\text{not cross}) = 1 - P_k(\\text{cross}) = 1 - q \\exp\\left(-\\frac{D}{T_0 \\alpha^k}\\right)$$\n\n问题陈述，提议机制在每次迭代中是独立的。因此，在一次迭代中未能越垒的事件与所有其他迭代中的事件是独立的。在所有 $N$ 次迭代中未能越过势垒的总概率 $P(\\text{failure})$，是在每次单独迭代中失败的概率的乘积：\n$$P(\\text{failure}) = \\prod_{k=0}^{N-1} P_k(\\text{not cross})$$\n\n代入 $P_k(\\text{not cross})$ 的表达式，我们得到失败概率的精确解析表达式：\n$$P(\\text{failure}) = \\prod_{k=0}^{N-1} \\left( 1 - q \\exp\\left(-\\frac{D}{T_0 \\alpha^k}\\right) \\right)$$\n\n这就是从第一性原理推导出的所求表达式。现在，我们必须使用给定的参数值进行数值计算：$D=5$，$q=0.2$，$N=100$，$T_0=1$ 和 $\\alpha=\\frac{1}{2}$。\n\n将这些值代入表达式中：\n$$P(\\text{failure}) = \\prod_{k=0}^{100-1} \\left( 1 - 0.2 \\cdot \\exp\\left(-\\frac{5}{1 \\cdot \\left(\\frac{1}{2}\\right)^k}\\right) \\right)$$\n$$P(\\text{failure}) = \\prod_{k=0}^{99} \\left( 1 - 0.2 \\cdot \\exp\\left(-5 \\cdot 2^k\\right) \\right)$$\n\n这是一个包含 100 个项的乘积。我们来分析这些项：\n对于 $k=0$：项为 $1 - 0.2 \\cdot \\exp(-5)$。\n对于 $k=1$：项为 $1 - 0.2 \\cdot \\exp(-10)$。\n对于 $k=2$：项为 $1 - 0.2 \\cdot \\exp(-20)$。\n随着 $k$ 的增加，指数 $-5 \\cdot 2^k$ 变成一个绝对值很大的负数。项 $\\exp(-5 \\cdot 2^k)$ 极快地趋近于 $0$。因此，乘积中的因子非常快地趋近于 $1$，乘积的值仅在几项之后就收敛了。\n\n该乘积的数值计算结果为：\n$$P(\\text{failure}) = (1 - 0.2 \\cdot \\exp(-5)) \\times (1 - 0.2 \\cdot \\exp(-10)) \\times (1 - 0.2 \\cdot \\exp(-20)) \\times \\dots$$\n$$P(\\text{failure}) \\approx (0.99865241) \\times (0.99999092) \\times (0.9999999996) \\times \\dots$$\n$$P(\\text{failure}) \\approx 0.998643339274...$$\n\n将此结果四舍五入至六位有效数字，我们得到 $0.998643$。",
            "answer": "$$\\boxed{0.998643}$$"
        },
        {
            "introduction": "静态的降温方案（如对数或指数降温）虽然经典，但在实践中往往难以针对特定问题进行有效调整。一种更先进和稳健的方法是采用自适应方案，让算法根据其自身表现动态调整温度。这个练习将指导您动手实现一个基于Robbins-Monro随机近似方法的温度控制器，该控制器能自动调节温度以维持一个目标接受率。",
            "id": "3339494",
            "problem": "要求您设计并实现一个用于模拟退火马尔可夫链中温度的随机近似控制器，以使得经验接受率能够被引导至一个用户指定的目标值。该自适应过程由 Robbins–Monro 更新定义\n$$\nT_{k+1} = T_k + \\gamma_k (A^\\ast - \\hat{A}_k),\n$$\n其中 $T_k$ 是第 $k$ 批次后的温度，$A^\\ast$ 是目标接受率，$\\hat{A}_k$ 是在马尔可夫链移动的第 $k$ 批次中观测到的经验接受率，而 $\\gamma_k$ 是一个步长。目标是分析步长序列 $\\{\\gamma_k\\}$ 在引导经验接受率朝向目标值过程中的稳定性和准确性方面的影响。\n\n您的程序必须从第一性原理出发实现以下组件：\n- 一个 Metropolis–Hastings 马尔可夫链，其提议为 $y = x + \\varepsilon$，其中 $\\varepsilon \\sim \\mathcal{N}(0,\\sigma^2)$ 是一个方差为 $\\sigma^2$ 的高斯增量。能量为 $E(x) = \\tfrac{1}{2} x^2$，在温度 $T$ 下的接受概率为\n$$\n\\alpha(x,y;T) = \\min\\left(1, \\exp\\left( -\\frac{E(y) - E(x)}{T} \\right)\\right).\n$$\n- 一个经验接受率估计器 $\\hat{A}_k$，在固定温度 $T_k$ 下，通过一批 $M$ 个提议计算得出。\n- Robbins–Monro 温度更新 $T_{k+1} = T_k + \\gamma_k (A^\\ast - \\hat{A}_k)$，并通过 $T_{k+1} \\leftarrow \\max(T_{\\min}, T_{k+1})$ 强制保持其正性，其中 $T_{\\min}  0$ 是一个很小的下限值。\n\n推导与分析的基础：\n- Metropolis–Hastings 接受概率以及模拟退火温度的定义。\n- 用于在噪声中求解函数根的 Robbins–Monro 随机近似方法，以及经典的步长条件，如 $\\sum_{k=0}^\\infty \\gamma_k = \\infty$ 和 $\\sum_{k=0}^\\infty \\gamma_k^2  \\infty$。\n- 对于对数凹目标和对称提议，期望接受率作为温度 $T$ 的函数的单调性，这意味着对于一个可行的 $A^\\ast \\in (0,1)$，存在唯一的温度解 $A(T) = A^\\ast$。\n\n为确保可复现性和普适性的实现细节：\n- 使用维度 $d = 1$，能量函数为 $E(x) = \\tfrac{1}{2}x^2$，提议方差为 $\\sigma^2 = 1$。在 $x_0 = 0$ 和 $T_0 = 2$ 处初始化。\n- 每批次使用大小为 $M = 30$ 的 Metropolis–Hastings 提议。\n- 每个测试用例运行 $K = 2500$ 个批次。\n- 使用目标接受率 $A^\\ast = 0.4$。\n- 使用固定的伪随机种子，等于 $12345$。\n- 在更新中强制执行 $T_{\\min} = 10^{-8}$ 的最低温度以保持正性。\n- 为评估稳定性和准确性，计算最后 $L = 300$ 个批次的数据：\n  1. 平均接受率 $\\overline{A}_{\\text{last}}$，作为最后 $L$ 个经验接受率的均值。\n  2. 最后 $L$ 个批次中温度的标准差 $\\mathrm{sd}(T)$。\n  3. 所有 $K$ 个批次中的最低和最高温度 $T_{\\min,\\text{obs}}$ 和 $T_{\\max,\\text{obs}}$。\n- 如果以下所有条件均成立，则宣布一个测试用例为“稳定且准确”：\n  1. $|\\overline{A}_{\\text{last}} - A^\\ast| \\le 0.05$,\n  2. $\\mathrm{sd}(T) \\le 0.5$,\n  3. $T_{\\min,\\text{obs}} \\ge 10^{-8}$ 且 $T_{\\max,\\text{obs}} \\le 10$。\n- 使用形式为 $\\gamma_k = c/(k+1)^\\alpha$ 的一系列步长，其中参数为 $(\\alpha,c)$。特殊情况 $\\alpha = 0$ 表示恒定步长 $\\gamma_k \\equiv c$。\n\n测试套件：\n- 情况 1：$(\\alpha, c) = (1.0, 1.5)$。\n- 情况 2：$(\\alpha, c) = (0.6, 0.7)$。\n- 情况 3：$(\\alpha, c) = (0.49, 0.7)$。\n- 情况 4：$(\\alpha, c) = (1.2, 0.1)$。\n- 情况 5：$(\\alpha, c) = (0.0, 0.05)$。\n\n对于每个测试用例，您的程序必须运行上述自适应模拟退火过程，评估三个标准，并返回一个布尔值，指示该用例是否“稳定且准确”。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[ \\text{True}, \\text{False}, \\dots ]$）。不允许有任何额外输出。\n\n角度单位不适用。不涉及物理单位。所有数值输出必须是无量纲实数或指定的布尔值。",
            "solution": "该问题是有效的。它在自适应蒙特卡洛方法领域提出了一个定义良好且有科学依据的任务。所有参数、条件和目标都以足够的精度进行了规定，从而能够得到唯一且可复现的解。该任务是实现一个自适应模拟退火算法，其中温度被动态调整以维持一个目标接受率，并分析其在不同自适应步长参数化下的性能。\n\n解决方案是通过整合三个核心组件来构建的：一个针对特定能量函数的 Metropolis-Hastings 采样器，一个用于温度的 Robbins-Monro 随机近似控制器，以及一个基于已定义稳定性和准确性标准的系统性评估程序。\n\n1.  **Metropolis-Hastings 采样器**\n\n模拟的基础是一个 Metropolis-Hastings (MH) 马尔可夫链，其设计目的是从一个目标概率分布中采样。目标分布的密度正比于 $\\exp(-E(x)/T)$，其中 $E(x)$ 是能量函数，$T$ 是温度。对于本问题，一维状态 $x \\in \\mathbb{R}$ 的能量函数给定为\n$$\nE(x) = \\frac{1}{2}x^2.\n$$\n该能量函数对应的目标分布是一个均值为0、方差为T的高斯分布。\n\nMH 算法通过一个提议-接受机制进行。\n- **提议生成**：使用对称提议分布从当前状态 $x$ 提议一个新状态 $y$。具体来说，提议为 $y = x + \\varepsilon$，其中增量 $\\varepsilon$ 从均值为0、方差为 $\\sigma^2$ 的正态分布中抽取。问题规定 $\\sigma^2 = 1$。\n- **接受概率**：提议的状态 $y$ 以概率 $\\alpha(x, y; T)$ 被接受，定义为\n$$\n\\alpha(x,y;T) = \\min\\left(1, \\exp\\left( -\\frac{E(y) - E(x)}{T} \\right)\\right).\n$$\n如果提议被接受，链的新状态变为 $y$；否则，状态保持为 $x$。提议分布 $\\mathcal{N}(0, \\sigma^2)$ 的对称性简化了接受率，因为 Hastings 项等于1。\n\n2.  **Robbins-Monro 温度控制器**\n\n目标不是在固定温度下采样，而是自适应地调整温度 $T$，使得 MH 采样器的长期平均接受率趋近于一个指定的目标值 $A^\\ast = 0.4$。这是一个随机求根问题：我们寻找能够解方程 $A(T) - A^\\ast = 0$ 的温度 $T$，其中 $A(T)$ 是在温度 $T$ 下的期望接受率。由于我们只能观测到 $A(T)$ 的带噪声估计——来自有限批次的经验接受率 $\\hat{A}_k$——我们使用 Robbins-Monro (RM) 随机近似算法。\n\n在第 $k$ 批次后，温度的 RM 更新规则由下式给出：\n$$\nT_{k+1} = T_k + \\gamma_k (A^\\ast - \\hat{A}_k).\n$$\n此处，$T_k$ 是用于第 $k$ 批次的温度，$\\hat{A}_k$ 是在该批次中观测到的经验接受率（通过 $M=30$ 个 MH 步骤计算），而 $\\gamma_k$ 是一个正步长参数。更新的逻辑是直观的：如果观测到的接受率 $\\hat{A}_k$ 高于目标 $A^\\ast$，则项 $(A^\\ast - \\hat{A}_k)$ 为负，温度会降低。这使得提议更不容易被接受，从而降低接受率。反之，如果 $\\hat{A}_k  A^\\ast$，温度会升高。为确保温度保持物理意义（即为正），更新后的值以一个小的正常数 $T_{\\min} = 10^{-8}$ 为下限。\n\n3.  **步长序列分析**\n\nRM 算法的行为关键地依赖于步长序列 $\\{\\gamma_k\\}$ 的选择。问题指定了一族形式为 $\\gamma_k = c/(k+1)^\\alpha$ 的序列，其中 $k$ 是从0开始的批次索引。RM 的经典收敛条件是：\n$$\n\\sum_{k=0}^\\infty \\gamma_k = \\infty \\quad \\text{和} \\quad \\sum_{k=0}^\\infty \\gamma_k^2  \\infty.\n$$\n- 第一个条件，“无穷和”条件，确保算法有足够的“能量”脱离任何初始状态并达到目标。对于我们选择的形式，当且仅当 $\\alpha \\le 1$ 时，此条件得到满足。\n- 第二个条件，“平方可和”条件，确保步长递减得足够快，以平均掉来自经验估计 $\\hat{A}_k$ 的噪声，从而实现收敛。当且仅当 $\\alpha  0.5$ 时，此条件得到满足。\n\n这些测试用例旨在探究满足或违反这些条件的实际后果：\n- **情况 1**：$(\\alpha,c) = (1.0, 1.5)$。此处 $\\alpha=1.0$ 满足两个条件（对第一个条件是临界满足）。预期会收敛，尽管可能较慢。\n- **情况 2**：$(\\alpha,c) = (0.6, 0.7)$。此处 $0.5  \\alpha \\le 1$，稳健地满足两个条件。这是一个理论上的理想范围，因此预期会有良好性能。\n- **情况 3**：$(\\alpha,c) = (0.49, 0.7)$。此处 $\\alpha  0.5$，违反了平方可和条件。步长衰减不够快，因此预期温度会表现出持续的高幅振荡，无法满足稳定性标准 $\\mathrm{sd}(T) \\le 0.5$。\n- **情况 4**：$(\\alpha,c) = (1.2, 0.1)$。此处 $\\alpha  1$，违反了无穷和条件。步长可能衰减过快，如果初始温度 $T_0=2$ 距离目标较远，这会阻止温度完全收敛到正确的值。这可能导致系统性偏差，无法满足准确性标准 $|\\overline{A}_{\\text{last}} - A^\\ast| \\le 0.05$。\n- **情况 5**：$(\\alpha,c) = (0.0, 0.05)$。这对应于一个恒定步长 $\\gamma_k=0.05$，它违反了平方可和条件。温度不会收敛到一个点，而是在目标周围的一个平稳分布中游走，导致一个不会消失的标准差。这很可能会无法满足稳定性标准 $\\mathrm{sd}(T) \\le 0.5$。\n\n4.  **模拟与评估协议**\n\n对于由一对 $(\\alpha, c)$ 定义的每个测试用例，执行一次包含 $K=2500$ 个批次的模拟运行。模拟以 $x_0 = 0$，$T_0 = 2$ 和一个固定的伪随机种子 $12345$ 进行初始化，以保证可复现性。\n\n每次运行后，使用存储的温度和经验接受率历史记录，根据三个具体标准评估性能：\n1.  **准确性**：最后 $L=300$ 个批次的经验接受率均值 $\\overline{A}_{\\text{last}}$ 必须接近目标：$|\\overline{A}_{\\text{last}} - A^\\ast| \\le 0.05$。\n2.  **稳定性**：最后 $L=300$ 个批次的温度值标准差 $\\mathrm{sd}(T)$ 必须很小：$\\mathrm{sd}(T) \\le 0.5$。\n3.  **边界**：在整个 $K$ 个批次的模拟过程中，温度必须保持在合理范围内：$T_{\\min,\\text{obs}} \\ge 10^{-8}$ 且 $T_{\\max,\\text{obs}} \\le 10$。\n\n当且仅当所有这三个条件都满足时，一个测试用例才被视为“稳定且准确”。最终输出是一个布尔值列表，指示每个用例的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the adaptive simulated annealing simulations for all test cases.\n    \"\"\"\n    # Global parameters defined in the problem statement.\n    D_DIM = 1\n    SIGMA_SQ = 1.0\n    SIGMA = np.sqrt(SIGMA_SQ)\n    X0 = 0.0\n    T0 = 2.0\n    M_BATCH_SIZE = 30\n    K_NUM_BATCHES = 2500\n    L_LAST_BATCHES = 300\n    A_STAR = 0.4\n    T_MIN = 1e-8\n    SEED = 12345\n\n    # Test cases: (alpha, c) parameters for the step size gamma_k = c / (k+1)^alpha.\n    test_cases = [\n        (1.0, 1.5),  # Case 1\n        (0.6, 0.7),  # Case 2\n        (0.49, 0.7), # Case 3\n        (1.2, 0.1),  # Case 4\n        (0.0, 0.05)   # Case 5\n    ]\n\n    results = []\n\n    # Iterate through each test case.\n    for alpha, c in test_cases:\n        # Re-initialize the random number generator for each case to ensure reproducibility.\n        rng = np.random.default_rng(SEED)\n        \n        # Initialize state variables for the simulation.\n        x_current = X0\n        t_current = T0\n        \n        # Arrays to store the history of temperatures and acceptance rates.\n        temp_history = np.zeros(K_NUM_BATCHES)\n        acceptance_rate_history = np.zeros(K_NUM_BATCHES)\n        \n        # Main simulation loop over K batches.\n        for k in range(K_NUM_BATCHES):\n            # Record the temperature for the current batch.\n            temp_history[k] = t_current\n\n            accept_count = 0\n            # Inner loop for M Metropolis-Hastings proposals within a batch.\n            for _ in range(M_BATCH_SIZE):\n                # 1. Propose a new state y from the current state x.\n                # Proposal is y = x + epsilon, where epsilon ~ N(0, sigma^2).\n                epsilon = rng.normal(loc=0.0, scale=SIGMA)\n                y_proposal = x_current + epsilon\n                \n                # 2. Calculate the change in energy E(x) = 0.5 * x^2.\n                e_current = 0.5 * x_current**2\n                e_proposal = 0.5 * y_proposal**2\n                delta_e = e_proposal - e_current\n                \n                # 3. Calculate the acceptance probability.\n                # alpha(x,y;T) = min(1, exp(-delta_E / T))\n                if delta_e = 0:\n                    acceptance_prob = 1.0\n                else:\n                    # Avoid division by zero, though t_current is floored at T_MIN > 0.\n                    acceptance_prob = np.exp(-delta_e / t_current)\n                \n                # 4. Accept or reject the proposal.\n                if rng.uniform(0.0, 1.0)  acceptance_prob:\n                    x_current = y_proposal\n                    accept_count += 1\n            \n            # --- End of Batch ---\n            # Calculate the empirical acceptance rate for the batch.\n            a_hat_k = accept_count / M_BATCH_SIZE\n            acceptance_rate_history[k] = a_hat_k\n            \n            # Calculate the step size gamma_k.\n            gamma_k = c / ((k + 1)**alpha)\n            \n            # Update the temperature using the Robbins-Monro rule.\n            t_next = t_current + gamma_k * (A_STAR - a_hat_k)\n            \n            # Enforce the positivity constraint (temperature floor).\n            t_next = max(T_MIN, t_next)\n            \n            # Set the temperature for the next batch.\n            t_current = t_next\n            \n        # --- Post-Simulation Analysis for the current test case ---\n        \n        # 1. Mean acceptance rate over the last L batches.\n        a_last_mean = np.mean(acceptance_rate_history[-L_LAST_BATCHES:])\n        \n        # 2. Standard deviation of the temperature over the last L batches.\n        t_last_std = np.std(temp_history[-L_LAST_BATCHES:])\n        \n        # 3. Minimum and maximum observed temperatures over all K batches.\n        t_min_obs = np.min(temp_history)\n        t_max_obs = np.max(temp_history)\n        \n        # Evaluate the \"stable and accurate\" criteria.\n        cond1 = np.abs(a_last_mean - A_STAR) = 0.05\n        cond2 = t_last_std = 0.5\n        cond3 = (t_min_obs >= T_MIN) and (t_max_obs = 10.0)\n        \n        # The result for the case is True if all conditions are met.\n        is_stable_and_accurate = cond1 and cond2 and cond3\n        results.append(str(is_stable_and_accurate))\n\n    # Print the final list of results in the required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}