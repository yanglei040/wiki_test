{
    "hands_on_practices": [
        {
            "introduction": "To master Piecewise Deterministic Markov Processes (PDMPs), it is essential to start with the simplest non-trivial example: the Bouncy Particle Sampler (BPS) targeting a multivariate Gaussian distribution. This scenario, corresponding to a quadratic potential $U(x)$, is ideal because the sampler's linear dynamics lead to an event rate that is linear in time, allowing us to calculate event times exactly. This foundational exercise  will guide you through deriving both the particle's geometric reflection rule and the analytical formula for its event times from first principles, building a solid intuition for how these samplers operate.",
            "id": "3323706",
            "problem": "Consider the bouncy particle sampler for a target density proportional to $\\exp(-U(x))$ on $\\mathbb{R}^{d}$, where $U(x)=\\frac{1}{2}x^{\\top}A x$ with $A$ symmetric positive definite. The sampler is a piecewise deterministic Markov process (PDMP) with flow $\\dot{x}=v$ and $\\dot{v}=0$ between events, event (bounce) rate $\\lambda(x,v)=\\max\\{0, v^{\\top}\\nabla U(x)\\}$, and a specular reflection of the velocity at event times across the hyperplane orthogonal to $\\nabla U(x)$ that preserves the component of $v$ tangent to the level set of $U$ and flips the component normal to $\\nabla U(x)$.\n\n1. Using only the geometric characterization of specular reflection across a hyperplane with normal vector $\\nabla U(x)$, derive the explicit expression for the post-bounce velocity $v'$ in terms of $x$ and $v$.\n\n2. Let the process start at $(x(0),v(0))=(x_{0},v)$ with $x_{0}\\in\\mathbb{R}^{d}$ and $v\\in\\mathbb{R}^{d}$ such that $v^{\\top}A x_{0}0$ and $v^{\\top}A v0$. Using the definition of the event rate and the deterministic flow, derive an explicit inverse-transform sampling formula for the first event time $\\tau$, expressed as a deterministic function of a unit-rate exponential random variable $E$. Your derivation must start from the definition of the inhomogeneous Poisson process with rate $t\\mapsto \\lambda(x(t),v(t))$ and the fundamental change-of-variables principle for integrated hazard. Express the final formula for $\\tau$ as a closed-form analytic expression in terms of $A$, $x_{0}$, $v$, and $E$.\n\nState your final answer as the single explicit expression for $\\tau$ as a function of $A$, $x_{0}$, $v$, and $E$. No numerical evaluation is required.",
            "solution": "The problem is evaluated as valid, as it is scientifically grounded, well-posed, and objective. It consists of two parts concerning the Bouncy Particle Sampler (BPS) for a multivariate Gaussian target distribution. We will solve both parts sequentially.\n\nThe target probability density is proportional to $\\exp(-U(x))$ for $x \\in \\mathbb{R}^{d}$, where the potential energy is given by $U(x) = \\frac{1}{2}x^{\\top}A x$. The matrix $A$ is specified as symmetric and positive definite. The gradient of the potential, which will be frequently used, is $\\nabla U(x) = Ax$. The BPS evolves according to the state $(x(t), v(t))$, with deterministic dynamics between discrete bounce events. The flow is defined by $\\dot{x}(t) = v(t)$ and $\\dot{v}(t) = 0$, implying linear motion at a constant velocity between events. The rate of these events is $\\lambda(x,v) = \\max\\{0, v^{\\top}\\nabla U(x)\\}$.\n\nPart 1: Derivation of the post-bounce velocity.\nThe problem describes the bounce event as a specular reflection of the velocity vector $v$ across the hyperplane that is orthogonal to the gradient vector $\\nabla U(x)$. This means the component of $v$ parallel to $\\nabla U(x)$ is inverted, while the component orthogonal to $\\nabla U(x)$ is preserved.\n\nLet $n = \\nabla U(x) = Ax$ be the normal vector to the reflection hyperplane at position $x$. We can decompose the incoming velocity vector $v$ into two components: $v_{\\parallel}$ parallel to $n$, and $v_{\\perp}$ perpendicular to $n$.\n$$v = v_{\\parallel} + v_{\\perp}$$\nThe component parallel to $n$ is the orthogonal projection of $v$ onto $n$:\n$$v_{\\parallel} = \\frac{v^{\\top}n}{n^{\\top}n} n$$\nThe component perpendicular to $n$ is then given by:\n$$v_{\\perp} = v - v_{\\parallel} = v - \\frac{v^{\\top}n}{n^{\\top}n} n$$\nAccording to the rule of specular reflection, the post-bounce velocity $v'$ is obtained by reversing the parallel component and keeping the perpendicular component unchanged:\n$$v' = v_{\\perp} - v_{\\parallel} = \\left(v - v_{\\parallel}\\right) - v_{\\parallel} = v - 2v_{\\parallel}$$\nSubstituting the expression for $v_{\\parallel}$, we get:\n$$v' = v - 2 \\frac{v^{\\top}n}{n^{\\top}n} n$$\nFinally, substituting $n = Ax$, we obtain the explicit expression for the post-bounce velocity $v'$ in terms of $x$, $v$, and $A$:\n$$v' = v - 2 \\frac{v^{\\top}(Ax)}{(Ax)^{\\top}(Ax)} (Ax) = v - 2 \\frac{v^{\\top}Ax}{x^{\\top}A^{\\top}Ax} Ax$$\nSince $A$ is symmetric ($A^{\\top}=A$), this can be written as:\n$$v' = v - 2 \\frac{v^{\\top}Ax}{x^{\\top}A^2 x} Ax$$\nThis completes the derivation for the first part.\n\nPart 2: Derivation of the first event time $\\tau$.\nWe are tasked with deriving a formula to sample the first event time, $\\tau$, using inverse transform sampling. The process starts at $(x(0), v(0)) = (x_0, v)$. Between events, the particle's position evolves as $x(t) = x_0 + vt$. The velocity $v$ remains constant.\n\nThe event rate at time $t$ is given by $\\lambda(t) = \\lambda(x(t), v)$. We substitute the expression for $x(t)$ into the rate function:\n$$\\lambda(t) = \\max\\{0, v^{\\top}\\nabla U(x(t))\\} = \\max\\{0, v^{\\top}A(x_0 + vt)\\}$$\nExpanding the term inside the maximum gives:\n$$\\lambda(t) = \\max\\{0, v^{\\top}Ax_0 + t(v^{\\top}Av)\\}$$\nThe problem provides the initial conditions $v^{\\top}Ax_0  0$ and $v^{\\top}Av  0$. Let us define the constants $a = v^{\\top}Ax_0$ and $b = v^{\\top}Av$. With these definitions, $a0$ and $b0$. The rate function for $t \\ge 0$ simplifies to:\n$$\\lambda(t) = a + bt$$\nThe first event time $\\tau$ of an inhomogeneous Poisson process with rate $\\lambda(t)$ can be sampled using the inverse transform method. The fundamental principle states that the integrated hazard up to time $\\tau$, $\\Lambda(\\tau)$, follows a standard exponential distribution. Let $E$ be a random variable drawn from an exponential distribution with rate $1$. Then we must solve the equation $\\Lambda(\\tau) = E$ for $\\tau$.\n\nThe integrated hazard function $\\Lambda(t)$ is the integral of the rate function from $0$ to $t$:\n$$\\Lambda(t) = \\int_0^t \\lambda(s) ds = \\int_0^t (a + bs) ds = \\left[as + \\frac{1}{2}bs^2\\right]_0^t = at + \\frac{1}{2}bt^2$$\nSetting $\\Lambda(\\tau) = E$, we obtain a quadratic equation for $\\tau$:\n$$a\\tau + \\frac{1}{2}b\\tau^2 = E$$\nRearranging into standard form:\n$$\\frac{b}{2}\\tau^2 + a\\tau - E = 0$$\nWe solve this equation for $\\tau$ using the quadratic formula:\n$$\\tau = \\frac{-a \\pm \\sqrt{a^2 - 4\\left(\\frac{b}{2}\\right)(-E)}}{2\\left(\\frac{b}{2}\\right)} = \\frac{-a \\pm \\sqrt{a^2 + 2bE}}{b}$$\nSince $\\tau$ represents a time, it must be non-negative. We are given $a  0$ and $b  0$, and $E$ is a non-negative random variable. The term under the square root, $\\sqrt{a^2 + 2bE}$, is always greater than or equal to $\\sqrt{a^2} = a$.\nThe root corresponding to the minus sign, $\\frac{-a - \\sqrt{a^2 + 2bE}}{b}$, is always non-positive.\nThe root corresponding to the plus sign, $\\frac{-a + \\sqrt{a^2 + 2bE}}{b}$, is always non-negative.\nTherefore, the physically meaningful solution for the event time $\\tau$ is:\n$$\\tau = \\frac{-a + \\sqrt{a^2 + 2bE}}{b}$$\nSubstituting back the expressions for $a$ and $b$ in terms of $A$, $x_0$, and $v$:\n$$\\tau = \\frac{-(v^{\\top}Ax_0) + \\sqrt{(v^{\\top}Ax_0)^2 + 2(v^{\\top}Av)E}}{v^{\\top}Av}$$\nThis is the final closed-form expression for the first event time $\\tau$.",
            "answer": "$$\n\\boxed{\\frac{-(v^{\\top}Ax_{0}) + \\sqrt{(v^{\\top}Ax_{0})^{2} + 2(v^{\\top}Av)E}}{v^{\\top}Av}}\n$$"
        },
        {
            "introduction": "While analytically tractable models are excellent for learning, most real-world potentials are too complex for the direct calculation of event times. This practice  introduces a powerful and universally applicable technique known as \"thinning\" to overcome this challenge. You will learn to construct a computable upper bound for the BPS event rate using the Lipschitz continuity of the potential's gradient, a cornerstone method that makes PDMPs practical for a wide range of models with general smooth potentials.",
            "id": "3323688",
            "problem": "Consider a continuously differentiable potential $U:\\mathbb{R}^d\\to\\mathbb{R}$ whose gradient $\\nabla U$ is globally Lipschitz with constant $L0$, meaning $\\|\\nabla U(x)-\\nabla U(y)\\|\\le L\\|x-y\\|$ for all $x,y\\in\\mathbb{R}^d$. In the Bouncy Particle Sampler (BPS), a Piecewise Deterministic Markov Process (PDMP) used in nonreversible Markov Chain Monte Carlo (MCMC), the event rate at state $(x,v)$ is $\\lambda(x,v)=\\max\\{0,\\,v\\cdot\\nabla U(x)\\}$, where $v\\in\\mathbb{R}^d$ is the velocity vector. Along the deterministic trajectory $x(t)=x_0+t\\,v$, the instantaneous event rate becomes $\\lambda(t)=\\max\\{0,\\,v\\cdot\\nabla U(x_0+t\\,v)\\}$.\n\nStarting from the Lipschitz property and basic calculus along lines, derive an upper envelope $\\bar{r}(t)$ for the rate $\\lambda(t)$ that is suitable for standard thinning-based simulation of the first event time. Specifically:\n\n1. Use the Lipschitz property of $\\nabla U$ and the definition of directional derivatives to obtain a bound of the form $v\\cdot\\nabla U(x_0+t\\,v)\\le a+b\\,t$ for constants $a$ and $b$ that you must define explicitly in terms of $x_0$, $v$, $L$, and $\\nabla U(x_0)$. Then define the envelope function $\\bar{r}(t)=\\max\\{0,\\,a+b\\,t\\}$ and state precisely its piecewise structure in terms of the time at which $a+b\\,t$ changes sign.\n\n2. Provide explicit formulas for the integrated envelope $\\bar{R}(t)=\\int_0^t\\bar{r}(s)\\,ds$ over time, emphasizing its piecewise quadratic form, and show how to invert $\\bar{R}$ to solve for the first proposed event time $t$ given an exponential variate $E0$ (with $E$ dimensionless). Your inversion formula must handle both branches corresponding to $a\\ge 0$ and $a0$.\n\n3. Give explicit formulas for bound update intervals when the envelope is refreshed at a new anchor point $x_{\\mathrm{anc}}=x_0+s\\,v$. Define the interval length $\\delta$ over which $\\bar{r}$ remains identically zero before becoming positive. Express $\\delta$ in terms of $L$, $v$, and $v\\cdot\\nabla U(x_{\\mathrm{anc}})$.\n\nYour program must implement these constructions and verify their correctness on the following test suite of quadratic potentials $U(x)=\\tfrac{1}{2}x^\\top A x$ in $d=2$, where $A$ is symmetric:\n\n- For each test matrix, the Lipschitz constant is the operator norm of the Hessian, i.e., $L=\\|A\\|_2$, which for symmetric $A$ equals the largest magnitude eigenvalue.\n\nUse the following test cases:\n\n- Test 1 (general case): $A=\\mathrm{diag}(3.0,1.0)$, $x_0=(1.0,-0.5)$, $v=(0.6,-0.8)$. Verify that $\\bar{r}(t)\\ge \\lambda(t)$ for $101$ equally spaced $t\\in[0,1]$. The output is a boolean.\n\n- Test 2 (negative intercept and bound-update interval): $A=\\mathrm{diag}(2.0,2.0)$, $x_0=(-0.2,0.1)$, $v=(0.5,0.5)$. Compute the bound-update interval length $\\delta=\\max\\{0,\\,-a/b\\}$, where $a=v\\cdot\\nabla U(x_0)$ and $b=L\\|v\\|^2$. The output is a float. Use units consistent with time in the PDMP (dimensionless).\n\n- Test 3 (inversion of integrated envelope with initial zero branch): Reuse Test 2 and compute the first proposed event time by solving $\\bar{R}(t)=E$ with $E=0.05$. The output is a float.\n\n- Test 4 (indefinite quadratic but globally Lipschitz gradient): $A=\\mathrm{diag}(3.0,-2.0)$, $x_0=(0.4,0.6)$, $v=(0.5,-0.3)$. Verify $\\bar{r}(t)\\ge \\lambda(t)$ for $101$ equally spaced $t\\in[0,1]$. The output is a boolean.\n\n- Test 5 (tight envelope when $v$ aligns with the largest-eigenvalue direction): $A=\\mathrm{diag}(5.0,1.0)$, $x_0=(0.2,0.1)$, $v=(1.0,0.0)$. Compute the ratio $\\bar{R}(1)/\\int_0^1\\lambda(s)\\,ds$. The output is a float.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\").",
            "solution": "The problem statement is evaluated as scientifically grounded, well-posed, and objective. It is based on established principles of Markov Chain Monte Carlo methods, specifically the Bouncy Particle Sampler, and the mathematical tools used for its analysis, such as Lipschitz continuity and simulation via thinning. The tasks are specified with sufficient detail and formal rigor to admit a unique and verifiable solution. We may therefore proceed with the derivation and implementation.\n\nThe core of the problem is to construct a tractable upper bound for the BPS event rate $\\lambda(t) = \\max\\{0, v \\cdot \\nabla U(x_0+tv)\\}$ along a linear trajectory $x(t) = x_0+tv$. This bound, denoted $\\bar{r}(t)$, facilitates the simulation of event times using the thinning method.\n\n### Part 1: Derivation of the Upper Envelope $\\bar{r}(t)$\n\nWe aim to find a linear upper bound for the quantity $g(t) = v \\cdot \\nabla U(x_0+tv)$. We begin by expressing $g(t)$ in terms of its value at $t=0$:\n$$g(t) = v \\cdot \\nabla U(x_0) + v \\cdot \\left( \\nabla U(x_0+tv) - \\nabla U(x_0) \\right)$$\nBy applying the Cauchy-Schwarz inequality to the second term, we get:\n$$v \\cdot \\left( \\nabla U(x_0+tv) - \\nabla U(x_0) \\right) \\le \\|v\\| \\cdot \\| \\nabla U(x_0+tv) - \\nabla U(x_0) \\|$$\nThe problem states that the gradient $\\nabla U$ is globally Lipschitz with constant $L0$. Applying this property with positions $x = x_0+tv$ and $y=x_0$, we have:\n$$\\| \\nabla U(x_0+tv) - \\nabla U(x_0) \\| \\le L \\|(x_0+tv) - x_0\\| = L |t| \\|v\\|$$\nFor forward time evolution, we consider $t \\ge 0$, so $|t|=t$. Combining these inequalities yields:\n$$v \\cdot \\left( \\nabla U(x_0+tv) - \\nabla U(x_0) \\right) \\le \\|v\\| \\cdot (L t \\|v\\|) = L\\|v\\|^2 t$$\nSubstituting this back into the expression for $g(t)$:\n$$v \\cdot \\nabla U(x_0+tv) \\le v \\cdot \\nabla U(x_0) + L\\|v\\|^2 t$$\nThis gives a linear upper bound on $v \\cdot \\nabla U(x_0+tv)$. We define the constants $a$ and $b$ as:\n$$a = v \\cdot \\nabla U(x_0)$$\n$$b = L\\|v\\|^2$$\nWith these definitions, the inequality is $v \\cdot \\nabla U(x_0+tv) \\le a+bt$. Since the event rate is $\\lambda(t) = \\max\\{0, v \\cdot \\nabla U(x_0+tv)\\}$, a valid upper envelope $\\bar{r}(t)$ is obtained by taking the positive part of our linear bound:\n$$\\bar{r}(t) = \\max\\{0, a+bt\\}$$\nThis envelope has a piecewise structure determined by the sign of $a+bt$. The term $a+bt$ is zero when $t=-a/b$. Since $L0$ and we assume a non-zero velocity $v$, we have $b0$.\n\nThe piecewise structure is as follows:\n- If $a \\ge 0$, then $-a/b \\le 0$. For all $t \\ge 0$, we have $a+bt \\ge 0$, so $\\bar{r}(t) = a+bt$.\n- If $a  0$, then $-a/b  0$. Let $\\delta = -a/b$.\n    - For $t \\in [0, \\delta)$, we have $a+bt  0$, so $\\bar{r}(t)=0$.\n    - For $t \\ge \\delta$, we have $a+bt \\ge 0$, so $\\bar{r}(t)=a+bt$.\n\n### Part 2: Integrated Envelope $\\bar{R}(t)$ and Its Inversion\n\nTo simulate an event time using thinning, we generate a proposed time $t$ by inverting the integrated envelope $\\bar{R}(t) = \\int_0^t \\bar{r}(s)ds$. We draw a standard exponential variate $E \\sim \\mathrm{Exp}(1)$, which is dimensionless, and solve $\\bar{R}(t)=E$ for $t$.\n\nWe analyze the two cases for the structure of $\\bar{r}(t)$:\n\n**Case 1: $a \\ge 0$**\nFor $t \\ge 0$, $\\bar{r}(t) = a+bt$. The integrated rate is:\n$$\\bar{R}(t) = \\int_0^t (a+bs)ds = \\left[as + \\frac{1}{2}bs^2\\right]_0^t = at + \\frac{1}{2}bt^2$$\nTo find the proposed event time, we solve the quadratic equation $\\frac{1}{2}bt^2 + at - E = 0$ for $t  0$. The quadratic formula gives:\n$$t = \\frac{-a \\pm \\sqrt{a^2 - 4(\\frac{1}{2}b)(-E)}}{b} = \\frac{-a \\pm \\sqrt{a^2 + 2bE}}{b}$$\nSince $t$ must be positive and $b0$, we take the positive root:\n$$t = \\frac{-a + \\sqrt{a^2 + 2bE}}{b}$$\n\n**Case 2: $a  0$**\nLet $\\delta = -a/b  0$. The rate $\\bar{r}(s)$ is $0$ for $s \\in [0, \\delta)$ and $a+bs$ for $s \\ge \\delta$.\n- If $t \\in [0, \\delta)$, $\\bar{R}(t) = \\int_0^t 0 ds = 0$.\n- If $t \\ge \\delta$, the integrated rate is:\n$$\\bar{R}(t) = \\int_0^\\delta 0 ds + \\int_\\delta^t (a+bs)ds = \\left[as+\\frac{1}{2}bs^2\\right]_\\delta^t = (at+\\frac{1}{2}bt^2) - (a\\delta+\\frac{1}{2}b\\delta^2)$$\nSubstituting $\\delta = -a/b$, the second term is $a(-a/b) + \\frac{1}{2}b(-a/b)^2 = -a^2/b + a^2/(2b) = -a^2/(2b)$.\nThus, for $t \\ge \\delta$, $\\bar{R}(t) = at + \\frac{1}{2}bt^2 + \\frac{a^2}{2b} = \\frac{1}{2b}(2abt+b^2t^2+a^2) = \\frac{(a+bt)^2}{2b}$.\nA simpler way to derive this is to integrate from $\\delta$: $\\bar{R}(t) = \\int_{\\delta}^t (a+bs)ds$. Let $u=s-\\delta$. Then $s=u+\\delta$ and $ds=du$.\n$$\\bar{R}(t) = \\int_0^{t-\\delta} (a+b(u+\\delta))du = \\int_0^{t-\\delta} (a+b\\delta+bu)du$$\nSince $a+b\\delta=0$, the integral becomes $\\int_0^{t-\\delta} bu du = \\frac{1}{2}b(t-\\delta)^2$.\nTo solve $\\bar{R}(t)=E$, we must have $t \\ge \\delta$. We solve $\\frac{1}{2}b(t-\\delta)^2 = E$:\n$$(t-\\delta)^2 = \\frac{2E}{b} \\implies t-\\delta = \\sqrt{\\frac{2E}{b}} \\quad (\\text{since } t \\ge \\delta)$$\n$$t = \\delta + \\sqrt{\\frac{2E}{b}} = -\\frac{a}{b} + \\sqrt{\\frac{2E}{b}}$$\n\n### Part 3: Bound Update Interval $\\delta$\n\nWhen the BPS simulation advances time without an event, the linear bound on the rate can become loose. It is common practice to refresh the bound at a new anchor point $x_{\\mathrm{anc}} = x_0+s v$. The new bound is constructed for time $\\tau = t-s \\ge 0$ relative to the new anchor point.\nThe new linear bound for the rate is based on the new intercept $a_{\\mathrm{new}} = v \\cdot \\nabla U(x_{\\mathrm{anc}})$ and the same slope parameter $b = L\\|v\\|^2$. The new rate envelope is $\\bar{r}(\\tau) = \\max\\{0, a_{\\mathrm{new}} + b\\tau\\}$.\nThis envelope is identically zero if $a_{\\mathrm{new}}  0$, over the time interval $\\tau \\in [0, -a_{\\mathrm{new}}/b)$. The length of this interval, which we call the bound-update interval, is $\\delta = -a_{\\mathrm{new}}/b$. If $a_{\\mathrm{new}} \\ge 0$, the rate is positive from $\\tau=0$ and this interval has length $0$.\nTherefore, the length of the interval is given by:\n$$\\delta = \\max\\left\\{0, -\\frac{a_{\\mathrm{new}}}{b}\\right\\} = \\max\\left\\{0, -\\frac{v \\cdot \\nabla U(x_{\\mathrm{anc}})}{L\\|v\\|^2}\\right\\}$$\nThis formula precisely matches the quantity requested in Test 2, where the anchor point is $x_0$.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Implements and verifies the BPS rate envelope calculations.\n    \"\"\"\n    results = []\n\n    # ===== Test 1: General case verification =====\n    A1 = np.diag([3.0, 1.0])\n    x0_1 = np.array([1.0, -0.5])\n    v_1 = np.array([0.6, -0.8])\n    \n    L1 = np.max(np.abs(np.linalg.eigvals(A1)))\n    grad_U_x0_1 = A1 @ x0_1\n    a1 = v_1 @ grad_U_x0_1\n    b1 = L1 * (v_1 @ v_1)\n    \n    t_vals = np.linspace(0, 1, 101)\n    lambda_t_1 = np.maximum(0, a1 + t_vals * (v_1 @ A1 @ v_1))\n    r_bar_t_1 = np.maximum(0, a1 + t_vals * b1)\n    \n    # Tiny tolerance for floating point comparisons\n    is_valid_bound_1 = np.all(r_bar_t_1 = lambda_t_1 - 1e-9)\n    results.append(bool(is_valid_bound_1))\n\n    # ===== Test 2: Negative intercept and bound-update interval =====\n    A2 = np.diag([2.0, 2.0])\n    x0_2 = np.array([-0.2, 0.1])\n    v_2 = np.array([0.5, 0.5])\n    \n    L2 = np.max(np.abs(np.linalg.eigvals(A2)))\n    grad_U_x0_2 = A2 @ x0_2\n    a2 = v_2 @ grad_U_x0_2\n    b2 = L2 * (v_2 @ v_2)\n\n    delta_2 = max(0, -a2 / b2)\n    results.append(delta_2)\n\n    # ===== Test 3: Inversion of integrated envelope (from Test 2) =====\n    E3 = 0.05\n    # Using parameters a2, b2 from Test 2. Since a2  0:\n    t3 = (-a2 / b2) + math.sqrt(2 * E3 / b2)\n    results.append(t3)\n    \n    # ===== Test 4: Indefinite quadratic potential =====\n    A4 = np.diag([3.0, -2.0])\n    x0_4 = np.array([0.4, 0.6])\n    v_4 = np.array([0.5, -0.3])\n    \n    L4 = np.max(np.abs(np.linalg.eigvals(A4)))\n    grad_U_x0_4 = A4 @ x0_4\n    a4 = v_4 @ grad_U_x0_4\n    b4 = L4 * (v_4 @ v_4)\n    \n    lambda_t_4 = np.maximum(0, a4 + t_vals * (v_4 @ A4 @ v_4))\n    r_bar_t_4 = np.maximum(0, a4 + t_vals * b4)\n    \n    is_valid_bound_4 = np.all(r_bar_t_4 = lambda_t_4 - 1e-9)\n    results.append(bool(is_valid_bound_4))\n    \n    # ===== Test 5: Tight envelope case =====\n    A5 = np.diag([5.0, 1.0])\n    x0_5 = np.array([0.2, 0.1])\n    v_5 = np.array([1.0, 0.0])\n    \n    L5 = np.max(np.abs(np.linalg.eigvals(A5)))\n    grad_U_x0_5 = A5 @ x0_5\n    a5 = v_5 @ grad_U_x0_5\n    b5 = L5 * (v_5 @ v_5)\n    \n    # Since a5  0, the integrated envelope over [0, 1] is a + b/2.\n    R_bar_1 = a5 * 1.0 + 0.5 * b5 * 1.0**2\n    \n    # The actual rate is lambda(t) = a + t * (v'Av).\n    vTAv5 = v_5 @ A5 @ v_5\n    # Since a5  0 and vTAv5  0, the max(0, ...) is redundant.\n    # Integrated actual rate over [0, 1] is a + (v'Av)/2.\n    R_actual_1 = a5 * 1.0 + 0.5 * vTAv5 * 1.0**2\n    \n    ratio_5 = R_bar_1 / R_actual_1\n    results.append(ratio_5)\n    \n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many modern statistical models, particularly in high-dimensional settings, involve non-smooth potentials such as the L1-norm used in Lasso regression. This practice explores how PDMPs can be adapted to efficiently sample from such targets by exploiting their specific structure . You will develop an algorithm for both the Bouncy Particle and Zig-Zag samplers on piecewise linear potentials, where the event rate becomes piecewise constant. This involves identifying \"breakpoints\" where the gradient changes, revealing a powerful method for exact event simulation that does not rely on the thinning approach.",
            "id": "3323724",
            "problem": "Consider a nonreversible Markov Chain Monte Carlo (MCMC) algorithm in the class of Piecewise Deterministic Markov Processes (PDMPs), specifically the Bouncy Particle Sampler (BPS) and the Zig-Zag Sampler (ZZS). Let the target probability density be proportional to $\\exp(-U(x))$, where the potential $U(x)$ is piecewise linear. Assume a polyhedral representation\n$$\nU(x) = \\max_{j \\in \\{1,\\dots,K\\}} \\varphi_j(x), \\quad \\text{with} \\quad \\varphi_j(x) = a_j^\\top x + b_j,\n$$\nwhere $a_j \\in \\mathbb{R}^d$ and $b_j \\in \\mathbb{R}$ are given constants. In regions where a single index $j^\\star$ is active (i.e., $j^\\star = \\arg\\max_j \\varphi_j(x)$), the gradient is piecewise constant and equal to $\\nabla U(x) = a_{j^\\star}$.\n\nFor the Bouncy Particle Sampler, the event rate is\n$$\n\\lambda_{\\mathrm{BPS}}(x, v) = \\max\\big(0, v^\\top \\nabla U(x)\\big),\n$$\nand for the Zig-Zag Sampler (ZZS), the componentwise event rates are\n$$\n\\lambda_i(x, v) = \\max\\big(0, v_i \\, \\partial_i U(x)\\big), \\quad i \\in \\{1,\\dots,d\\},\n$$\nso the total event rate is\n$$\n\\lambda_{\\mathrm{ZZS}}(x, v) = \\sum_{i=1}^d \\lambda_i(x, v).\n$$\n\nGiven an initial position $x_0 \\in \\mathbb{R}^d$ and velocity $v \\in \\mathbb{R}^d$, the dynamics evolve deterministically along the ray $x(s) = x_0 + s\\, v$ until a random event time $\\tau$. The event time $\\tau$ is defined by the standard PDMP construction via the integrated hazard:\n$$\n\\int_0^\\tau \\lambda\\big(x_0 + s\\, v\\big)\\, ds = E,\n$$\nwhere $E \\sim \\mathrm{Exp}(1)$ is a unit-rate exponential random variable.\n\nYour tasks are:\n- Derive from fundamental PDMP principles how to compute $\\tau$ exactly for piecewise linear potentials, using that $\\nabla U(x)$ is piecewise constant on polyhedral regions and changes only when the active affine function index changes along the ray $x_0 + s\\, v$.\n- Implement an algorithm that computes $\\tau$ exactly by:\n  1. Detecting the breakpoints $s$ at which the active index $j^\\star$ changes (i.e., where $\\varphi_k(x_0 + s\\, v) = \\varphi_{j^\\star}(x_0 + s\\, v)$ for some $k \\neq j^\\star$ and $s  0$),\n  2. Integrating the constant event rate on each segment to accumulate the hazard until it matches $E$,\n  3. Handling edge cases such as zero event rate segments and the absence of future breakpoints.\n- Apply your algorithm to the test suite below and output the event times $\\tau$ as floating-point numbers.\n\nRepresentation of the polyhedral $U(x)$:\n- You are given $K$ affine pieces $\\varphi_j(x) = a_j^\\top x + b_j$ with $a_j \\in \\mathbb{R}^d$ and $b_j \\in \\mathbb{R}$.\n- The active index at a point $x$ is $j^\\star(x) = \\arg\\max_j \\varphi_j(x)$; ties may be broken by choosing the smallest index.\n\nBreakpoints along the ray:\n- A candidate breakpoint where $k$ overtakes the current active $j^\\star$ solves\n$$\n\\varphi_k(x_0 + s\\, v) = \\varphi_{j^\\star}(x_0 + s\\, v),\n$$\nwhich yields\n$$\ns = -\\frac{(a_k - a_{j^\\star})^\\top x_0 + (b_k - b_{j^\\star})}{(a_k - a_{j^\\star})^\\top v}.\n$$\n- Only breakpoints with $(a_k - a_{j^\\star})^\\top v  0$ and $s  0$ are relevant, since they represent indices that will overtake the current active one as $s$ increases.\n- The next breakpoint is the minimum such positive $s$.\n\nEvent time computation:\n- On a segment with constant active index $j^\\star$, the BPS event rate is constant and equal to $\\lambda_{\\mathrm{BPS}} = \\max(0, v^\\top a_{j^\\star})$.\n- On a segment with constant active index $j^\\star$, the ZZS total rate is constant and equal to $\\lambda_{\\mathrm{ZZS}} = \\sum_{i=1}^d \\max(0, v_i \\, a_{j^\\star,i})$.\n- Integrate piecewise constant rates until the accumulated hazard equals the sampled $E$.\n\nUnits and numerical specifications:\n- All quantities are dimensionless.\n- Angles are not used.\n- Exponential draws should be generated as unit-rate exponentials $E \\sim \\mathrm{Exp}(1)$ using fixed random number generator seeds specified in the test suite for reproducibility.\n\nTest suite:\nFor each case, you are given $(a_j, b_j)_{j=1}^K$, $x_0$, $v$, sampler type, and random seed. Use the seed to draw $E \\sim \\mathrm{Exp}(1)$ and compute the exact event time $\\tau$ as described.\n\n- Test case $1$ (BPS, constant active region, positive rate):\n  - Dimension $d = 2$, number of pieces $K = 2$,\n  - $a_1 = (1.0, 0.0)$, $b_1 = 0.1$,\n  - $a_2 = (0.0, 0.5)$, $b_2 = 0.0$,\n  - $x_0 = (0.0, 0.0)$, $v = (1.0, 1.0)$,\n  - Seed $= 12345$.\n- Test case $2$ (BPS, initial zero rate then positive after a breakpoint):\n  - Dimension $d = 2$, number of pieces $K = 2$,\n  - $a_1 = (-1.0, 0.5)$, $b_1 = 0.2$,\n  - $a_2 = (1.0, 0.0)$, $b_2 = 0.0$,\n  - $x_0 = (0.0, 0.0)$, $v = (1.0, 1.0)$,\n  - Seed $= 31415$.\n- Test case $3$ (BPS, multiple breakpoints along the ray):\n  - Dimension $d = 2$, number of pieces $K = 3$,\n  - $a_1 = (2.0, 0.0)$, $b_1 = 0.5$,\n  - $a_2 = (0.5, 0.5)$, $b_2 = 0.6$,\n  - $a_3 = (0.1, 2.0)$, $b_3 = 0.1$,\n  - $x_0 = (0.0, 0.0)$, $v = (1.0, 0.2)$,\n  - Seed $= 27182$.\n- Test case $4$ (BPS, zero rate forever, infinite event time):\n  - Dimension $d = 2$, number of pieces $K = 2$,\n  - $a_1 = (1.0, -1.0)$, $b_1 = 0.0$,\n  - $a_2 = (0.5, -0.5)$, $b_2 = 0.1$,\n  - $x_0 = (0.0, 0.0)$, $v = (0.0, 1.0)$,\n  - Seed $= 16180$.\n- Test case $5$ (ZZS, constant active region, positive total rate):\n  - Dimension $d = 3$, number of pieces $K = 3$,\n  - $a_1 = (1.0, -0.5, 0.25)$, $b_1 = 0.3$,\n  - $a_2 = (0.2, 0.7, -0.4)$, $b_2 = 0.1$,\n  - $a_3 = (-0.3, 0.1, 0.9)$, $b_3 = 0.2$,\n  - $x_0 = (0.0, 0.0, 0.0)$, $v = (1.0, -1.0, 2.0)$,\n  - Seed $= 14142$.\n\nFinal output format:\n- Your program should produce a single line of output containing the event times $\\tau$ for the five test cases as a comma-separated list enclosed in square brackets.\n- Each time should be rounded to $8$ decimal places if finite; if the event time is infinite, print $\\mathrm{inf}$.\n- Example format (with placeholder numbers): \"[0.12345678,0.23456789,0.34567890,inf,0.45678901]\".",
            "solution": "The problem requires the derivation and implementation of an algorithm to compute the exact event time $\\tau$ for two Piecewise Deterministic Markov Processes (PDMPs): the Bouncy Particle Sampler (BPS) and the Zig-Zag Sampler (ZZS). The target distribution has a density proportional to $\\exp(-U(x))$, where the potential $U(x)$ is a piecewise linear function defined as the maximum of $K$ affine functions, $U(x) = \\max_{j \\in \\{1,\\dots,K\\}} (a_j^\\top x + b_j)$.\n\nThe derivation proceeds from fundamental principles of PDMPs.\n\n**1. PDMP Dynamics and Event Time Definition**\n\nA PDMP evolves deterministically between random events. A particle with state $(x, v)$ at time $t=0$ follows a deterministic path $x(s) = x_0 + s v$ for a duration $s \\in [0, \\tau)$, where $\\tau$ is the time of the first event. The event time $\\tau$ is a random variable determined by the event rate $\\lambda(x, v)$ along the path. Its realization is governed by the equation for the integrated hazard:\n$$\n\\int_0^\\tau \\lambda(x_0 + s v, v) ds = E\n$$\nwhere $E$ is a random variable drawn from a unit-rate exponential distribution, $E \\sim \\mathrm{Exp}(1)$. To find $\\tau$, we must evaluate this integral.\n\n**2. Piecewise-Constant Event Rate**\n\nThe key insight is that for the given potential $U(x)$, the event rate $\\lambda(x(s), v)$ is a piecewise-constant function of the path parameter $s$. This is because:\n- The potential is $U(x) = \\max_{j \\in \\{1,\\dots,K\\}} \\varphi_j(x)$ with $\\varphi_j(x) = a_j^\\top x + b_j$.\n- In any open polyhedral region where a single index $j^\\star$ is active (i.e., $\\varphi_{j^\\star}(x)  \\varphi_k(x)$ for all $k \\neq j^\\star$), the gradient of the potential is constant: $\\nabla U(x) = a_{j^\\star}$.\n- The BPS event rate, $\\lambda_{\\mathrm{BPS}}(x, v) = \\max(0, v^\\top \\nabla U(x))$, and the ZZS event rate, $\\lambda_{\\mathrm{ZZS}}(x, v) = \\sum_{i=1}^d \\max(0, v_i \\, \\partial_i U(x))$, depend only on the gradient $\\nabla U(x)$ and the constant velocity $v$.\n- Therefore, as the particle traverses a region where $j^\\star$ is the constant active index, the event rate $\\lambda$ is also constant. The rate only changes when the active index $j^\\star$ switches, which occurs at the boundaries between these polyhedral regions.\n\n**3. Breakpoints Along the Trajectory**\n\nAlong the linear trajectory $x(s) = x_0 + s v$, the boundaries are crossed at specific times $s$, which we call breakpoints. Let the active index at the start of a segment (at time $s_{curr}$) be $j^\\star$. A breakpoint occurs at the smallest time $s_{bp}  s_{curr}$ where another function $\\varphi_k(x(s))$ becomes equal to $\\varphi_{j^\\star}(x(s))$, i.e.,\n$$\n\\varphi_k(x_0 + s_{bp} v) = \\varphi_{j^\\star}(x_0 + s_{bp} v)\n$$\nSubstituting the definitions of $\\varphi_j(x)$, we get a linear equation for $s_{bp}$:\n$$\na_k^\\top (x_0 + s_{bp} v) + b_k = a_{j^\\star}^\\top (x_0 + s_{bp} v) + b_{j^\\star}\n$$\nRearranging for $s_{bp}$ yields:\n$$\ns_{bp} = - \\frac{(a_k - a_{j^\\star})^\\top x_0 + (b_k - b_{j^\\star})}{(a_k - a_{j^\\star})^\\top v}\n$$\nFor a new index $k$ to overtake the current active index $j^\\star$ as $s$ increases, the function $\\varphi_k(x(s))$ must be increasing faster than $\\varphi_{j^\\star}(x(s))$. The rate of change of $\\varphi_j(x(s))$ with respect to $s$ is $\\frac{d}{ds} \\varphi_j(x_0+sv) = a_j^\\top v$. Thus, the condition for $k$ to overtake $j^\\star$ is $a_k^\\top v  a_{j^\\star}^\\top v$, or $(a_k - a_{j^\\star})^\\top v  0$. We only need to consider pairs $(k, j^\\star)$ that satisfy this condition and for which the resulting $s_{bp}$ is positive and greater than the current time. The next breakpoint, $s_{next\\_bp}$, is the minimum of all such valid candidate breakpoints. If no such breakpoint exists, the current active region extends to infinity.\n\n**4. Iterative Algorithm for Event Time Computation**\n\nThe integral for the accumulated hazard can now be computed as a sum over segments between breakpoints. Let the sequence of breakpoints be $0 = s_0  s_1  s_2  \\dots$. The algorithm proceeds as follows:\n\nLet $s_{curr} = 0$, and let $E_{rem} = E$ be the initial total hazard required.\n1.  **Initialization**: Determine the active index $j^\\star$ at the starting point $x_0 = x(s_{curr})$.\n2.  **Iterative Steps**: Loop until the event occurs:\n    a. **Find Next Breakpoint**: From the current time $s_{curr}$ and active index $j^\\star$, calculate the time of the next breakpoint, $s_{next\\_bp}$, by considering all other indices $k \\in \\{1, \\dots, K\\}$. If no future breakpoint exists, set $s_{next\\_bp} = \\infty$.\n    b. **Calculate Segment Rate**: Determine the constant event rate $\\lambda_{seg}$ for the segment $[s_{curr}, s_{next\\_bp})$ using the gradient $a_{j^\\star}$. For BPS, $\\lambda_{seg} = \\max(0, v^\\top a_{j^\\star})$. For ZZS, $\\lambda_{seg} = \\sum_{i=1}^d \\max(0, v_i (a_{j^\\star})_i)$.\n    c. **Check for Event**:\n        i. **Zero Rate**: If $\\lambda_{seg} \\approx 0$: The accumulated hazard on this segment is zero. If $s_{next\\_bp} = \\infty$, the rate will be zero forever, so $\\tau = \\infty$. Otherwise, update $s_{curr} \\leftarrow s_{next\\_bp}$, update $j^\\star$ to the new active index, and continue to the next segment.\n        ii. **Positive Rate**: The total hazard that can be accumulated in this segment is $\\Lambda_{seg} = \\lambda_{seg} \\cdot (s_{next\\_bp} - s_{curr})$.\n            - If $\\Lambda_{seg} \\ge E_{rem}$: The event occurs within this segment. The additional time required is $\\Delta\\tau = E_{rem} / \\lambda_{seg}$. The total event time is $\\tau = s_{curr} + \\Delta\\tau$. The process terminates.\n            - If $\\Lambda_{seg}  E_{rem}$: The particle traverses the entire segment without an event. Update the remaining hazard $E_{rem} \\leftarrow E_{rem} - \\Lambda_{seg}$, update the time $s_{curr} \\leftarrow s_{next\\_bp}$, update $j^\\star$ to the new active index, and repeat the loop for the next segment.\n\nThis algorithm correctly integrates the piecewise-constant hazard function to find the exact event time $\\tau$.",
            "answer": "```python\nimport numpy as np\n\ndef format_result(tau):\n    \"\"\"Formats the final time tau as specified.\"\"\"\n    if np.isinf(tau):\n        return \"inf\"\n    return f\"{tau:.8f}\"\n\ndef compute_tau(A, b, x0, v, sampler_type, seed):\n    \"\"\"\n    Computes the exact event time tau for BPS or ZZS with a piecewise-linear potential.\n\n    Args:\n        A (np.ndarray): Matrix of shape (K, d) containing the gradient vectors a_j.\n        b (np.ndarray): Vector of shape (K,) containing the offsets b_j.\n        x0 (np.ndarray): Initial position vector of shape (d,).\n        v (np.ndarray): Velocity vector of shape (d,).\n        sampler_type (str): Either 'BPS' or 'ZZS'.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        float: The exact event time tau, which can be np.inf.\n    \"\"\"\n    K, d = A.shape\n    rng = np.random.default_rng(seed)\n    E = rng.exponential(1.0)\n    \n    s_curr = 0.0\n    E_rem = E\n    \n    TOL = 1e-12\n\n    # Initial active index at s=0\n    x_at_s_curr = x0 + s_curr * v\n    phi_vals_at_s_curr = A @ x_at_s_curr + b\n    # np.argmax handles the specified tie-breaking rule (smallest index)\n    j_star = np.argmax(phi_vals_at_s_curr)\n\n    # A line can cross each of the K(K-1)/2 hyperplanes at most once.\n    # The number of iterations is bounded. K+1 is a safe upper bound on segments.\n    for _ in range(K + 1): \n        # 1. Find the next breakpoint\n        s_bps = []\n        next_j_candidates = []\n        a_j_star = A[j_star]\n\n        for k in range(K):\n            if k == j_star:\n                continue\n            \n            da = A[k] - a_j_star\n            db = b[k] - b[j_star]\n            \n            denom = da @ v\n            \n            # Condition for k to overtake j_star: its slope along v must be greater\n            if denom  TOL:\n                num = -(da @ x0 + db)\n                s_bp = num / denom\n                \n                # A valid breakpoint must be in the future\n                if s_bp  s_curr + TOL:\n                    s_bps.append(s_bp)\n                    next_j_candidates.append(k)\n\n        if not s_bps:\n            s_next_bp = np.inf\n            k_next = -1 \n        else:\n            min_idx = np.argmin(s_bps)\n            s_next_bp = s_bps[min_idx]\n            k_next = next_j_candidates[min_idx]\n\n        # 2. Calculate event rate for the current segment [s_curr, s_next_bp)\n        lambda_seg = 0.0\n        if sampler_type == 'BPS':\n            lambda_seg = max(0.0, v @ a_j_star)\n        elif sampler_type == 'ZZS':\n            lambda_seg = np.sum(np.maximum(0.0, v * a_j_star))\n        \n        # 3. Check for event in this segment\n        if lambda_seg  TOL:\n            if s_next_bp == np.inf:\n                return np.inf  # Rate is zero forever\n            else:\n                # Move to the next segment\n                s_curr = s_next_bp\n                j_star = k_next\n                continue\n        \n        delta_s = s_next_bp - s_curr\n        hazard_seg = lambda_seg * delta_s\n        \n        if hazard_seg = E_rem:\n            # Event happens in this segment\n            delta_tau = E_rem / lambda_seg\n            tau = s_curr + delta_tau\n            return tau\n        else:\n            # Event does not happen, move to next segment\n            if s_next_bp == np.inf:\n                # This branch is for robustness against floating point issues,\n                # as theoretically hazard_seg would be inf.\n                delta_tau = E_rem / lambda_seg\n                tau = s_curr + delta_tau\n                return tau\n                \n            E_rem -= hazard_seg\n            s_curr = s_next_bp\n            j_star = k_next\n            \n    # Should not be reached in a valid scenario\n    raise RuntimeError(\"Maximum iterations reached, suggesting a logic error.\")\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": np.array([[1.0, 0.0], [0.0, 0.5]]),\n            \"b\": np.array([0.1, 0.0]),\n            \"x0\": np.array([0.0, 0.0]), \"v\": np.array([1.0, 1.0]),\n            \"sampler\": \"BPS\", \"seed\": 12345\n        },\n        {\n            \"A\": np.array([[-1.0, 0.5], [1.0, 0.0]]),\n            \"b\": np.array([0.2, 0.0]),\n            \"x0\": np.array([0.0, 0.0]), \"v\": np.array([1.0, 1.0]),\n            \"sampler\": \"BPS\", \"seed\": 31415\n        },\n        {\n            \"A\": np.array([[2.0, 0.0], [0.5, 0.5], [0.1, 2.0]]),\n            \"b\": np.array([0.5, 0.6, 0.1]),\n            \"x0\": np.array([0.0, 0.0]), \"v\": np.array([1.0, 0.2]),\n            \"sampler\": \"BPS\", \"seed\": 27182\n        },\n        {\n            \"A\": np.array([[1.0, -1.0], [0.5, -0.5]]),\n            \"b\": np.array([0.0, 0.1]),\n            \"x0\": np.array([0.0, 0.0]), \"v\": np.array([0.0, 1.0]),\n            \"sampler\": \"BPS\", \"seed\": 16180\n        },\n        {\n            \"A\": np.array([[1.0, -0.5, 0.25], [0.2, 0.7, -0.4], [-0.3, 0.1, 0.9]]),\n            \"b\": np.array([0.3, 0.1, 0.2]),\n            \"x0\": np.array([0.0, 0.0, 0.0]), \"v\": np.array([1.0, -1.0, 2.0]),\n            \"sampler\": \"ZZS\", \"seed\": 14142\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        tau = compute_tau(\n            case[\"A\"], case[\"b\"], case[\"x0\"], case[\"v\"],\n            case[\"sampler\"], case[\"seed\"]\n        )\n        results.append(format_result(tau))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}