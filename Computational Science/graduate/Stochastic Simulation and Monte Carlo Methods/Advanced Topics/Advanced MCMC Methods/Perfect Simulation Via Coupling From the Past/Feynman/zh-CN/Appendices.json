{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握“从过去耦合”（CFTP）算法，我们必须首先理解其核心构件：单调更新函数。这个练习  将引导您为一个简单的二状态马尔可夫链从第一性原理出发，构建这样一个函数。通过建立一个有效的耦合，并计算其单步合并概率，您将对共享随机性如何强制不同轨迹最终汇合获得基础性的理解。",
            "id": "3328903",
            "problem": "考虑一个在双状态空间 $S=\\{0,1\\}$ 上的时间齐次马尔可夫链，其转移核由 $P(0,1)=a$、$P(0,0)=1-a$、$P(1,0)=b$ 和 $P(1,1)=1-b$ 指定，其中 $a\\in(0,1)$ 和 $b\\in(0,1)$ 满足 $a+b\\leq 1$。条件 $a+b\\leq 1$ 确保该链相对于自然偏序 $0\\leq 1$ 是随机单调的。设 $\\{U_t\\}_{t\\in\\mathbb{Z}}$ 是一个独立同分布 (i.i.d.) 的随机变量序列，对于每个整数时间 $t$，$U_t\\sim \\mathrm{Unif}(0,1)$。你需要通过定义一个在其 $S$ 参数上相对于 $0\\leq 1$ 是单调的更新函数 $F:S\\times(0,1)\\to S$ 来实现一种使用过去耦合 (CFTP) 的完美模拟。\n\n从单调更新函数 $F$ 满足对于所有 $u\\in(0,1)$ 在序关系 $0\\leq 1$ 下有 $F(0,u)\\leq F(1,u)$ 的基本定义出发，为 $F$ 构造一个显式的基于阈值的规则，该规则能够实现给定的转移概率并且是单调的。然后，使用这个 $F$，考虑从两个极端状态 $0$ 和 $1$ 开始，由单个共同的均匀随机变量 $U\\sim \\mathrm{Unif}(0,1)$ 驱动一步的反向耦合。从第一性原理出发，推导精确的一步合并概率 $\\mathbb{P}\\big(F(0,U)=F(1,U)\\big)$ 的闭合形式，作为 $a$ 和 $b$ 的函数。\n\n你的最终答案必须是一步合并概率的闭合形式解析表达式，且不得包含任何单位。无需四舍五入。",
            "solution": "我们从状态空间为 $S=\\{0,1\\}$ 的双状态马尔可夫链开始，其转移概率为 $P(0,1)=a$、$P(0,0)=1-a$、$P(1,0)=b$ 和 $P(1,1)=1-b$，参数 $a\\in(0,1)$ 和 $b\\in(0,1)$ 满足 $a+b\\leq 1$。当 $P(0,\\cdot)$ 被 $P(1,\\cdot)$ 随机占优时，该链在偏序 $0\\leq 1$ 下是随机单调的，这在双状态情况下简化为要求转移到较高状态的概率随着当前状态的增加而不减小。特别地，对于单调性，其充分必要条件是：对于导致从状态0转移到1的随机种子 $u\\in(0,1)$ 集合，是导致从状态1转移到1的随机种子集合的子集。由于 $P(0,1)=a$ 和 $P(1,1)=1-b$，这个子集关系要求 $a\\leq 1-b$，等价于 $a+b\\leq 1$，这是给定条件。\n\n过去耦合 (CFTP) 方法需要一个更新函数 $F:S\\times(0,1)\\to S$，使得对于一个固定的 $u\\in(0,1)$，该函数在状态变量上是单调的。形式上，在序关系 $0\\leq 1$ 下，单调性意味着\n$$\nF(0,u)\\leq F(1,u)\\quad\\text{对所有 }u\\in(0,1).\n$$\n我们使用在 $(0,1)$ 上的阈值规则来构造 $F$，以实现所需的转移概率，同时确保单调性。设 $U\\sim \\mathrm{Unif}(0,1)$ 为一个通用均匀种子。定义集合\n$$\nA:=\\{u\\in(0,1): u  a\\},\\qquad B:=\\{u\\in(0,1): u  1-b\\}.\n$$\n根据假设 $a\\leq 1-b$，我们有 $A\\subseteq B$。现在我们如下定义 $F$：\n$$\nF(0,u):=\\begin{cases}\n1,  u\\in A,\\\\\n0,  u\\in A^{c},\n\\end{cases}\n\\qquad\nF(1,u):=\\begin{cases}\n1,  u\\in B,\\\\\n0,  u\\in B^{c}.\n\\end{cases}\n$$\n这是一个有效的更新函数，因为 $\\mathbb{P}(F(0,U)=1)=\\mathbb{P}(U\\in A)=|A|=a$ 且 $\\mathbb{P}(F(1,U)=1)=\\mathbb{P}(U\\in B)=|B|=1-b$，这与所需的转移概率完全匹配。单调性条件 $F(0,u)\\leq F(1,u)$ 对所有 $u\\in(0,1)$ 均成立，因为 $A\\subseteq B$ 意味着：\n- 如果 $u\\in A$，那么 $u\\in B$，因此 $F(0,u)=1$ 且 $F(1,u)=1$，所以 $F(0,u)\\leq F(1,u)$。\n- 如果 $u\\in B\\setminus A$，那么 $F(0,u)=0$ 且 $F(1,u)=1$，所以 $F(0,u)\\leq F(1,u)$。\n- 如果 $u\\in B^{c}$，那么 $u\\notin A$，因此 $F(0,u)=0$ 且 $F(1,u)=0$，所以 $F(0,u)\\leq F(1,u)$。\n\n构造了 $F$ 之后，我们计算在共同种子 $U\\sim \\mathrm{Unif}(0,1)$ 下，从两个极端状态 $0$ 和 $1$ 开始的一步合并概率。当 $F(0,U)=F(1,U)$ 时，发生一步合并。对于嵌套集合 $A\\subseteq B$，$F$ 的结果仅在 $U\\in B\\setminus A$ 时不一致，此时 $F(0,U)=0$ 且 $F(1,U)=1$。因此，\n$$\n\\mathbb{P}\\big(F(0,U)=F(1,U)\\big)\n=1-\\mathbb{P}\\big(F(0,U)\\neq F(1,U)\\big)\n=1-\\mathbb{P}\\big(U\\in B\\setminus A\\big).\n$$\n由于 $A$ 和 $B$ 是从 $0$ 开始的区间，其长度分别为 $|A|=a$ 和 $|B|=1-b$，集合差 $B\\setminus A$ 的勒贝格测度为 $|B\\setminus A|=|B|-|A|=(1-b)-a$。因此，\n$$\n\\mathbb{P}\\big(F(0,U)=F(1,U)\\big)=1-\\big((1-b)-a\\big)=a+b.\n$$\n这是关于 $a$ 和 $b$ 的闭合形式表达式，并且根据假设 $a+b\\leq 1$，它是一个有效的概率值。",
            "answer": "$$\\boxed{a+b}$$"
        },
        {
            "introduction": "尽管任何有效的单调耦合都能实现完美模拟，但其效率——即合并发生的速度——是至关重要的。这个实践  深入探讨了这一问题，它通过比较一种特定的路径耦合与理论上的最优选择——最大耦合。通过分析它们的合并概率，您将发现一个关于简单系统耦合设计的、既出人意料又富有启发性的结论。",
            "id": "3328948",
            "problem": "考虑一个在双状态空间 $\\{0,1\\}$ 上的时间齐次、不可约的马尔可夫链，其转移矩阵为\n$$\nP \\;=\\; \\begin{pmatrix}\n1-\\alpha  \\alpha \\\\\n\\beta  1-\\beta\n\\end{pmatrix},\n$$\n其中 $\\alpha \\in (0,1)$ 且 $\\beta \\in (0,1)$。您将比较此链的两种耦合，并分析它们的耦合时间，旨在理解通过“过去耦合”（Coupling From The Past, CFTP）进行的完美模拟。\n\n从马尔可夫链理论和耦合的基本原理出发：随机过程的耦合定义，最大耦合的特征（即在给定边缘分布的情况下，实现最大可能一步相等概率的耦合），以及几何分布的基本性质。对于路径耦合，使用一个跨状态共享的随机源，具体来说是一个独立抽取的序列 $\\{U_t\\}_{t \\geq 1}$，其中每个 $U_t$ 均匀分布在 $[0,1]$ 上，以及更新函数 $F:\\{0,1\\} \\times [0,1] \\to \\{0,1\\}$ 定义为\n$$\nF(0,u) \\;=\\; \\mathbf{1}\\{u \\leq \\alpha\\}, \\qquad F(1,u) \\;=\\; \\mathbf{1}\\{u \\leq 1-\\beta\\}.\n$$\n在每个时间步 $t$ 和对于任何当前状态 $x \\in \\{0,1\\}$，下一个状态是 $X_{t+1} = F(x,U_t)$。\n\n假设链的两个副本在时间 $t=0$ 时从不同的状态开始，一个在 $0$，一个在 $1$。对于以下每种耦合，当两个链在该步开始时处于不同状态时，分析推导它们在一步之后相等的概率，然后从初始对 $(0,1)$ 推导出期望耦合时间：\n1. 最大耦合：在每一步，从当前状态 $(0,1)$ 耦合两个转移核，以在保持边缘分布的同时最大化下一步状态相等的概率。\n2. 路径耦合：在每一步，使用共享的均匀随机变量 $U_t$ 和上面定义的更新函数 $F$ 来生成两个链。\n\n使用这些推导来计算期望耦合时间的比率 $\\mathbb{E}[T_{\\text{max}}] / \\mathbb{E}[T_{\\text{path}}]$，其中 $T_{\\text{max}}$ 和 $T_{\\text{path}}$ 分别表示在最大耦合和路径耦合下，从 $t=0$ 时的初始配置 $(0,1)$ 开始的正向耦合时间。\n\n将您的最终答案表示为单个实数或单个封闭形式的符号表达式。无需四舍五入。",
            "solution": "该问题要求计算一个双状态马尔可夫链的两种不同耦合的期望耦合时间之比。设两个耦合链为 $\\{X_t\\}_{t \\geq 0}$ 和 $\\{Y_t\\}_{t \\geq 0}$，从 $X_0=0$ 和 $Y_0=1$ 开始。状态空间为 $S = \\{0,1\\}$，转移矩阵为\n$$\nP = \\begin{pmatrix} 1-\\alpha  \\alpha \\\\ \\beta  1-\\beta \\end{pmatrix}\n$$\n其中 $\\alpha \\in (0,1)$ 且 $\\beta \\in (0,1)$。关于 $\\alpha$ 和 $\\beta$ 的条件确保了该链是不可约和非周期的。\n\n马尔可夫链的耦合是在乘积空间 $S \\times S$ 上的一个随机过程 $\\{(X_t, Y_t)\\}_{t \\geq 0}$，使得在边缘上，$\\{X_t\\}$ 和 $\\{Y_t\\}$ 都根据转移矩阵 $P$ 演化。当两个链相遇时，耦合发生于第一时间 $T$，即 $T = \\inf\\{t \\ge 1 : X_t = Y_t\\}$。我们给定的起始配置为 $(X_0, Y_0) = (0,1)$。\n\n只要链尚未耦合，它们的状态就是 $(X_t, Y_t) = (0,1)$ 或 $(1,0)$。由于问题设置在状态重新标记方面具有对称性，我们只需要考虑链处于不同状态的情况，比如 $(0,1)$。由于马尔可夫链是时间齐次的，给定链当前处于不同状态，下一步耦合的概率是一个常数值 $p_{\\text{coal}}$。因此，耦合时间 $T$ 是一个服从成功参数为 $p_{\\text{coal}}$ 的几何分布的随机变量。期望耦合时间由下式给出\n$$\n\\mathbb{E}[T] = \\frac{1}{p_{\\text{coal}}}\n$$\n我们的任务是计算两种不同耦合方案的这个概率 $p_{\\text{coal}}$，然后求出所得期望时间的比率。\n\n**1. 最大耦合**\n\n对于最大耦合，我们寻求最大化一步耦合概率 $p_{\\text{coal}} = P(X_{t+1}=Y_{t+1}|X_t=0, Y_t=1)$，同时保持边缘转移概率不变。给定当前状态 $X_t=0$ 和 $Y_t=1$，下一个状态的边缘分布由转移矩阵 $P$ 的行给出：\n- 从状态 $0$：转移到 $\\{0,1\\}$ 的概率为 $(P_{00}, P_{01}) = (1-\\alpha, \\alpha)$。\n- 从状态 $1$：转移到 $\\{0,1\\}$ 的概率为 $(P_{10}, P_{11}) = (\\beta, 1-\\beta)$。\n\n根据离散分布的最优耦合理论，从同一有限状态空间 $\\mathcal{S}$ 上的两个不同分布 $\\mu_1$ 和 $\\mu_2$ 获得相同结果的最大可能概率由分布的重叠部分给出：$\\sum_{k \\in \\mathcal{S}} \\min(\\mu_1(k), \\mu_2(k))$。\n\n将此原理应用于我们的情况，最大一步耦合概率，我们记作 $p_{\\text{coal, max}}$，是：\n$$\np_{\\text{coal, max}} = \\sum_{k \\in \\{0,1\\}} \\min(P(X_{t+1}=k|X_t=0), P(X_{t+1}=k|Y_t=1))\n$$\n$$\np_{\\text{coal, max}} = \\min(P_{00}, P_{10}) + \\min(P_{01}, P_{11})\n$$\n代入转移矩阵中的值：\n$$\np_{\\text{coal, max}} = \\min(1-\\alpha, \\beta) + \\min(\\alpha, 1-\\beta)\n$$\n因此，最大耦合下的期望耦合时间 $T_{\\text{max}}$ 为：\n$$\n\\mathbb{E}[T_{\\text{max}}] = \\frac{1}{p_{\\text{coal, max}}} = \\frac{1}{\\min(1-\\alpha, \\beta) + \\min(\\alpha, 1-\\beta)}\n$$\n\n**2. 路径耦合**\n\n这种耦合使用一个共享的独立同分布均匀随机变量序列 $\\{U_t\\}_{t \\ge 1}$，其中 $U_t \\sim \\text{Uniform}[0,1]$。状态更新由函数 $F(x,u)$ 控制：\n$$\nX_{t+1} = F(X_t, U_{t+1}) \\quad \\text{和} \\quad Y_{t+1} = F(Y_t, U_{t+1})\n$$\n其中 $F(0,u) = \\mathbf{1}\\{u \\leq \\alpha\\}$ 且 $F(1,u) = \\mathbf{1}\\{u \\leq 1-\\beta\\}$。从 $(X_t,Y_t)=(0,1)$ 开始，下一个状态是 $X_{t+1} = F(0,U_{t+1})$ 和 $Y_{t+1} = F(1,U_{t+1})$。\n\n如果 $X_{t+1} = Y_{t+1}$，则链在第 $t+1$ 步耦合。这种情况发生在两个链都转移到状态 $0$ 或都转移到状态 $1$ 时。为简单起见，我们省略 $U$ 的时间索引。\n- 两者都转移到 $1$：$X_{t+1}=1$ 和 $Y_{t+1}=1$。这要求 $F(0, U) = 1$ 和 $F(1, U) = 1$。这意味着 $\\mathbf{1}\\{U \\leq \\alpha\\} = 1$ 和 $\\mathbf{1}\\{U \\leq 1-\\beta\\} = 1$，这等价于 $U \\leq \\alpha$ 和 $U \\leq 1-\\beta$。这可以简化为 $U \\leq \\min(\\alpha, 1-\\beta)$。此事件的概率是 $\\min(\\alpha, 1-\\beta)$。\n- 两者都转移到 $0$：$X_{t+1}=0$ 和 $Y_{t+1}=0$。这要求 $F(0, U) = 0$ 和 $F(1, U) = 0$。这意味着 $U > \\alpha$ 和 $U > 1-\\beta$，这可以简化为 $U > \\max(\\alpha, 1-\\beta)$。此事件的概率是 $1 - \\max(\\alpha, 1-\\beta)$。\n\n事件 $\\{U \\leq \\min(\\alpha, 1-\\beta)\\}$ 和 $\\{U > \\max(\\alpha, 1-\\beta)\\}$ 是不相交的。因此，路径耦合的总一步耦合概率 $p_{\\text{coal, path}}$ 是它们概率的总和：\n$$\np_{\\text{coal, path}} = P(U \\leq \\min(\\alpha, 1-\\beta)) + P(U > \\max(\\alpha, 1-\\beta))\n$$\n$$\np_{\\text{coal, path}} = \\min(\\alpha, 1-\\beta) + 1 - \\max(\\alpha, 1-\\beta)\n$$\n路径耦合下的期望耦合时间 $T_{\\text{path}}$ 是：\n$$\n\\mathbb{E}[T_{\\text{path}}] = \\frac{1}{p_{\\text{coal, path}}} = \\frac{1}{\\min(\\alpha, 1-\\beta) + 1 - \\max(\\alpha, 1-\\beta)}\n$$\n\n**比较与比率**\n\n为了找到比率 $\\mathbb{E}[T_{\\text{max}}] / \\mathbb{E}[T_{\\text{path}}]$，我们必须比较 $p_{\\text{coal, max}}$ 和 $p_{\\text{coal, path}}$。我们有：\n$$\np_{\\text{coal, max}} = \\min(1-\\alpha, \\beta) + \\min(\\alpha, 1-\\beta)\n$$\n$$\np_{\\text{coal, path}} = 1 - \\max(\\alpha, 1-\\beta) + \\min(\\alpha, 1-\\beta)\n$$\n为了使这些概率相等，我们必须证明 $\\min(1-\\alpha, \\beta) = 1 - \\max(\\alpha, 1-\\beta)$。\n我们来证明这个等式。我们根据 $\\alpha$ 和 $1-\\beta$ 之间的关系考虑两种情况：\n\n情况 1：$\\alpha \\geq 1-\\beta$。这等价于 $\\alpha + \\beta \\geq 1$。\n- 在这种情况下，$\\max(\\alpha, 1-\\beta) = \\alpha$。\n- 等式的右边变为 $1 - \\alpha$。\n- 条件 $\\alpha \\geq 1-\\beta$ 也等价于 $1-\\alpha \\leq \\beta$。\n- 因此，$\\min(1-\\alpha, \\beta) = 1-\\alpha$。\n- 左边是 $1-\\alpha$。\n- 因此，两边都等于 $1-\\alpha$。\n\n情况 2：$\\alpha  1-\\beta$。这等价于 $\\alpha + \\beta  1$。\n- 在这种情况下，$\\max(\\alpha, 1-\\beta) = 1-\\beta$。\n- 等式的右边变为 $1 - (1-\\beta) = \\beta$。\n- 条件 $\\alpha  1-\\beta$ 也等价于 $1-\\alpha > \\beta$。\n- 因此，$\\min(1-\\alpha, \\beta) = \\beta$。\n- 左边是 $\\beta$。\n- 因此，两边都等于 $\\beta$。\n\n由于等式 $\\min(1-\\alpha, \\beta) = 1 - \\max(\\alpha, 1-\\beta)$ 对所有有效的 $\\alpha, \\beta \\in (0,1)$ 都成立，因此可以得出：\n$$\np_{\\text{coal, max}} = p_{\\text{coal, path}}\n$$\n这表明，对于一个双状态马尔可夫链，使用共享均匀随机变量构建的特定路径耦合实际上是一种最大耦合。\n\n由于一步耦合概率相同，它们对应的期望耦合时间也必须相同：\n$$\n\\mathbb{E}[T_{\\text{max}}] = \\mathbb{E}[T_{\\text{path}}]\n$$\n因此，期望耦合时间的比率为：\n$$\n\\frac{\\mathbb{E}[T_{\\text{max}}]}{\\mathbb{E}[T_{\\text{path}}]} = 1\n$$",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "当应用于那些传统MCMC方法难以判断收敛性的复杂系统时，CFTP的威力才最为彰显。这最后一个实践  将带您从理论走向应用，挑战您为铁磁伊辛模型（Ising model）——统计物理学的基石之一——完整地实现Propp–Wilson算法。通过模拟边界链并凭经验测量合并所需的工作量，您将获得使用这一强大工具生成完美样本的实践经验。",
            "id": "3328974",
            "problem": "您的任务是为小图上的铁磁伊辛模型实现一个单调边界链，并在“过去耦合”（CFTP）框架内使用它来获得完美样本。该边界链应通过在单一、共同的随机源下，同时更新两个分别初始化为全-1和全+1构型的极值链来实现。目标是计算两个极值链合并所需随机位点更新事件的数量，然后根据经验为每个测试案例确定，为使合并以高概率发生所需的最小更新次数。\n\n伊辛模型定义在一个有限无向图上，其节点集为 $\\{0,1,\\dots,n-1\\}$，边集为对称的 $E$。自旋取值为 $\\{-1,+1\\}$。在逆温度 $\\beta \\ge 0$、均匀耦合和零外场条件下，构型 $\\sigma \\in \\{-1,+1\\}^{n}$ 上的铁磁伊辛测度是吉布斯分布，其密度正比于 $\\exp\\left(\\beta \\sum_{(i,j)\\in E}\\sigma_i \\sigma_j\\right)$。单一位点热浴动力学（single-site heat-bath dynamics）随机均匀地选择一个位点 $i$，并通过在吉布斯测度下根据其邻居状态从 $\\sigma_i$ 的条件分布中抽样来更新 $\\sigma_i$。您必须利用构型上的标准偏序关系，以及这样一个事实：对于铁磁相互作用，当对所有链应用一个共同的均匀随机变量时，单一位点热浴更新对于相邻自旋是单调的。边界链的实现方式是演化两个链，一个初始化为全-1的下界链和一个初始化为全+1的上界链，并对两者应用相同的更新序列。当两个链变得相同时，即发生合并。\n\n使用倍增方案（doubling schedule）实现 Propp–Wilson 的“过去耦合”过程：从长度为 $T=1$ 的随机更新带开始，在相同的随机更新带下，将两个极值链从时间 $-T$ 向前模拟到时间 $0$，并检查是否合并。如果未合并，则在前面追加一个相同长度的独立随机更新带（因此总长度加倍），在时间 $-2T$ 重新启动两个极值链，并向前模拟到时间 $0$。重复此过程直到发生合并。将一次 CFTP 运行的合并功（coalescence work）定义为首次合并时更新带的长度 $T$。在离散计算步骤方面，这计算的是处理的随机位点更新事件的数量；不要因为将更新应用于两个链而将此计数加倍。\n\n对于下面的每个测试案例，使用固定的随机种子和指定数量的独立 CFTP 运行进行实证研究。设 $W$ 为表示单次 CFTP 运行的合并功（更新带长度）的随机变量。对于每个测试案例，计算最小整数 $T^{\\star}$，使得 $\\mathbb{P}(W \\le T^{\\star}) \\ge q$，其中 $q$ 是指定的高概率阈值。通过重复运行的经验分位数来估计该值，即对观察到的合并功值进行排序，并选择索引为 $\\lceil q \\cdot m \\rceil - 1$ 的元素，其中 $m$ 是运行次数。所有图的边上都具有单位铁磁耦合和零外场。\n\n使用的基本原理：\n- 伊辛模型的吉布斯分布：一个构型 $\\sigma$ 的概率正比于 $\\exp\\left(\\beta \\sum_{(i,j)\\in E} \\sigma_i \\sigma_j\\right)$。\n- 单一位点热浴动力学的定义：通过在吉布斯测度下从其条件分布中重新抽样来更新一个位点。\n- $\\{-1,+1\\}^{n}$ 上的偏序关系和铁磁伊辛模型的吸引性（单调性）。\n\n精确实现上述内容，并为以下测试套件生成结果。每个测试案例是一个元组 $(n, E, \\beta, q, m, s)$，其中 $n$ 是节点数， $E$ 是边列表， $\\beta$ 是逆温度， $q$ 是概率阈值， $m$ 是独立 CFTP 运行的次数， $s$ 是用于可复现性的伪随机种子。边列表 $E$ 以基于 $0$ 的索引的无序对给出。\n\n- 测试案例 1（一般小图，中等温度）：$n=5$, $E=\\{(0,1),(1,2),(2,3),(3,4)\\}$, $\\beta=0.3$, $q=0.95$, $m=200$, $s=202311$。\n- 测试案例 2（环状图，较低温度区域）：$n=4$, $E=\\{(0,1),(1,2),(2,3),(3,0)\\}$, $\\beta=0.7$, $q=0.95$, $m=200$, $s=202312$。\n- 测试案例 3（星形图，接近有序相变的高温对比，略低的 $q$ 以探测尾部）：$n=5$, $E=\\{(0,1),(0,2),(0,3),(0,4)\\}$, $\\beta=0.9$, $q=0.90$, $m=200$, $s=202313$。\n- 测试案例 4（完全图，中等温度）：$n=4$, $E=\\{(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)\\}$, $\\beta=0.5$, $q=0.95$, $m=200$, $s=202314$。\n- 测试案例 5（边界情况 $\\beta=0$）：$n=3$, $E=\\{(0,1),(1,2)\\}$, $\\beta=0.0$, $q=0.95$, $m=200$, $s=202315$。\n\n您的程序必须：\n- 实现用于伊辛模型的单调边界链，并使用单一位点热浴更新。\n- 实现使用上述倍增方案的 Propp–Wilson“过去耦合”算法。\n- 对于每个测试案例，使用指定的种子（用它来初始化伪随机数生成器）执行 $m$ 次独立的 CFTP 运行，收集合并功值 $W$，并计算经验最小整数 $T^{\\star}$，使得 $W \\le T^{\\star}$ 的运行比例至少为 $q$。\n\n所有计算纯粹是数学上的，不涉及物理单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表的结果（例如，`\"[r_1,r_2,r_3,...]\"`)，其中 $r_k$ 是上述顺序中测试案例 $k$ 的整数 $T^{\\star}$。",
            "solution": "该问题要求为有限图上的铁磁伊辛模型实现“过去耦合”（CFTP）算法。目标是确定以指定的高概率实现边界链合并所需的计算功，该计算功以随机更新事件的数量来衡量。\n\n解决方案分几步进行：首先，我们形式化模型和动力学。其次，我们建立单调性原理，这是CFTP算法的基础。第三，我们详细说明使用倍增方案的Propp-Wilson CFTP算法的具体实现。最后，我们描述用于估计所需合并功的实证过程。\n\n伊辛模型定义在图 $G=(V, E)$ 上，其中有 $n = |V|$ 个位点。系统的构型是一个自旋向量 $\\sigma = (\\sigma_0, \\sigma_1, \\dots, \\sigma_{n-1}) \\in \\{-1, +1\\}^n$。对于一个具有均匀耦合、零外场、逆温度为 $\\beta \\ge 0$ 的铁磁系统，构型 $\\sigma$ 的概率由吉布斯-玻尔兹曼分布给出：\n$$\nP(\\sigma) = \\frac{1}{Z} \\exp\\left(\\beta \\sum_{(i,j) \\in E} \\sigma_i \\sigma_j\\right)\n$$\n其中 $Z$ 是归一化分布的配分函数。\n\n系统根据单一位点热浴动力学演化。在每个时间步，从 $V$ 中随机均匀地选择一个位点 $i$。然后，根据其相邻自旋 $\\sigma_{N(i)}$ 的状态，从其条件概率分布中重新抽样自旋 $\\sigma_i$。$\\sigma_i$ 处于特定状态（例如+1）的条件概率是：\n$$\nP(\\sigma_i = +1 | \\sigma_{N(i)}) = \\frac{\\exp\\left(\\beta \\sum_{j \\in N(i)} \\sigma_j\\right)}{\\exp\\left(\\beta \\sum_{j \\in N(i)} \\sigma_j\\right) + \\exp\\left(-\\beta \\sum_{j \\in N(i)} \\sigma_j\\right)}\n$$\n设 $h_i = \\sum_{j \\in N(i)} \\sigma_j$ 为位点 $i$ 的局域场。该概率简化为：\n$$\np_i^+ \\equiv P(\\sigma_i = +1 | \\sigma_{N(i)}) = \\frac{1}{1 + e^{-2\\beta h_i}}\n$$\n单次更新步骤可以通过随机均匀选择位点 $i$，抽取一个均匀随机数 $U \\in [0, 1]$，如果 $U  p_i^+$ 则将 $\\sigma_i$ 设置为 $+1$，否则设置为 $-1$ 来实现。\n\nCFTP算法依赖于单调性属性。我们在构型空间上定义一个偏序关系：$\\sigma \\le \\tau$ 当且仅当对所有位点 $i \\in V$ 都有 $\\sigma_i \\le \\tau_i$。对于铁磁伊辛模型（$\\beta \\ge 0$），热浴动力学是单调的。这意味着，如果我们从两个构型 $\\sigma$ 和 $\\tau$ 开始，使得 $\\sigma \\le \\tau$，并对两者应用相同的更新序列（相同的位点 $i$ 和随机数 $U$），得到的构型 $\\sigma'$ 和 $\\tau'$ 也将满足 $\\sigma' \\le \\tau'$。要理解这一点，请注意如果 $\\sigma \\le \\tau$，那么局域场满足 $h_i^\\sigma \\le h_i^\\tau$。由于更新概率 $p_i^+$ 是 $h_i$ 的非递减函数（对于 $\\beta \\ge 0$），我们有 $p_i^{+,\\sigma} \\le p_i^{+,\\tau}$。对两个系统应用相同的 $U$ 可确保新的自旋满足 $\\sigma'_i \\le \\tau'_i$，从而保持偏序关系。\n\n这种单调性使我们能够通过仅追踪两个极值链来界定所有可能轨迹的演化：一个下界链 $\\sigma_{\\text{min}}$，初始化为所有自旋均为 $-1$ 的状态；以及一个上界链 $\\sigma_{\\text{max}}$，初始化为所有自旋均为 $+1$ 的状态。对于任何构型 $\\sigma$，我们有 $\\sigma_{\\text{min}} \\le \\sigma \\le \\sigma_{\\text{max}}$。通过使用相同的随机更新序列演化 $\\sigma_{\\text{min}}$ 和 $\\sigma_{\\text{max}}$，我们创建了一个包络，其中包含从任意构型开始的任何链的演化。如果在某个时间 $t$，极值链合并，即 $\\sigma_{\\text{min}}(t) = \\sigma_{\\text{max}}(t)$，这意味着所有可能的链都将合并到这一个构型。通过此过程在合并时抽取的样本是来自平稳吉布斯分布的完美（精确）样本。\n\nPropp-Wilson CFTP算法将此过程形式化。为了在时间 $t=0$ 获得一个样本，我们在过去的某个时间 $-T$ 开始链的演化并向前推进。如果它们在时间 $0$ 之前合并，我们就得到了一个完美样本。如果没有，我们必须从更早的时间开始。倍增方案是找到合适的起始时间 $-T$ 的一种有效方法。该算法过程如下：\n1.  初始化第一次尝试的更新带长度 $L=1$。维护一个随机更新列表，即`tape`，初始为空。\n2.  在一个循环中，生成一个包含 $L$ 个随机更新的新段。每个更新是一个对 $(i, U)$，其中 $i$ 是从 $\\{0, \\dots, n-1\\}$ 中均匀选择的位点，$U$ 从 $\\text{Uniform}[0,1]$ 中抽取。\n3.  将这个新段前置到`tape`中。现在`tape`的总长度为 $T$。\n4.  初始化极值链，$\\sigma_{\\text{min}}$ 为全-1，$\\sigma_{\\text{max}}$ 为全+1。\n5.  将`tape`中的全部 $T$ 个更新序列应用于两个链。\n6.  在结束时检查是否合并：如果 $\\sigma_{\\text{min}} = \\sigma_{\\text{max}}$，则本次运行的算法终止。合并功 $W$ 记录为总更新带长度 $T$。\n7.  如果链没有合并，则设置 $L = T$（下一个要生成的段的大小是当前更新带的长度），并返回到步骤2。此过程在每次不成功的尝试中有效地将总模拟时间范围加倍（$T=1, 2, 4, 8, \\dots$）。\n\n对于每个测试案例，此CFTP过程使用独立的伪随机数流执行 $m$ 次，每次运行由指定的种子 $s$ 初始化。这样可以得到一个包含 $m$ 个合并功值的样本 $\\{W_1, W_2, \\dots, W_m\\}$。为了找到最小整数 $T^\\star$，使得合并功至多为 $T^\\star$ 的经验概率至少为 $q$，我们将收集到的功值按非递减顺序排序。期望的值 $T^\\star$ 便是排序后的、0-索引的功值数组中索引为 $k = \\lceil q \\cdot m \\rceil - 1$ 的元素。这对应于经验 $q$-分位数，为高概率合并所需的时间提供了一个统计估计。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\n# from scipy import ... # No scipy functions are needed.\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define test cases as specified in the problem statement.\n    # Each tuple is (n, E, beta, q, m, s).\n    test_cases = [\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4)], 0.3, 0.95, 200, 202311),\n        (4, [(0, 1), (1, 2), (2, 3), (3, 0)], 0.7, 0.95, 200, 202312),\n        (5, [(0, 1), (0, 2), (0, 3), (0, 4)], 0.9, 0.90, 200, 202313),\n        (4, [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)], 0.5, 0.95, 200, 202314),\n        (3, [(0, 1), (1, 2)], 0.0, 0.95, 200, 202315),\n    ]\n\n    results = []\n    for n, E, beta, q, m, s in test_cases:\n        # Run the experiment for one test case.\n        result = run_cftp_experiment(n, E, beta, q, m, s)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef build_adj_list(n, E):\n    \"\"\"Builds an adjacency list from an edge list.\"\"\"\n    adj = [[] for _ in range(n)]\n    for u, v in E:\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef heat_bath_update(sigma, site_i, U, adj, beta):\n    \"\"\"\n    Performs a single-site heat-bath update for a given spin configuration.\n    \n    Args:\n        sigma (np.ndarray): The current spin configuration.\n        site_i (int): The index of the site to update.\n        U (float): A uniform random number in [0, 1].\n        adj (list): The adjacency list of the graph.\n        beta (float): The inverse temperature.\n\n    Returns:\n        int: The new spin value (+1 or -1).\n    \"\"\"\n    h_i = 0\n    for neighbor in adj[site_i]:\n        h_i += sigma[neighbor]\n    \n    # Probability of spin being +1. For beta=0, this is 0.5.\n    # The expression is numerically stable for the given range of parameters.\n    p_plus = 1.0 / (1.0 + np.exp(-2.0 * beta * h_i))\n\n    if U  p_plus:\n        return 1\n    else:\n        return -1\n\ndef single_cftp_run(n, adj, beta, rng):\n    \"\"\"\n    Performs one complete Coupling From The Past run using a doubling schedule.\n    \n    Returns the coalescence work (the length of the random tape at coalescence).\n    \"\"\"\n    tape = []\n    chunk_size = 1\n\n    while True:\n        # Generate a new chunk of random updates (site index, uniform random number)\n        new_updates = []\n        for _ in range(chunk_size):\n            site = rng.integers(n)\n            u_rand = rng.random()\n            new_updates.append((site, u_rand))\n        \n        # Prepend the new chunk to the tape.\n        tape = new_updates + tape\n        total_length = len(tape)\n\n        # Initialize the extremal chains: all -1s (lower) and all +1s (upper).\n        sigma_min = -np.ones(n, dtype=np.int8)\n        sigma_max = np.ones(n, dtype=np.int8)\n\n        # Evolve both chains from time -T to 0 using the full tape.\n        for site, U in tape:\n            # Update the lower chain\n            sigma_min[site] = heat_bath_update(sigma_min, site, U, adj, beta)\n            # Update the upper chain with the same randomness\n            sigma_max[site] = heat_bath_update(sigma_max, site, U, adj, beta)\n            \n        # Check for coalescence.\n        if np.array_equal(sigma_min, sigma_max):\n            return total_length  # Coalescence work\n\n        # If not coalesced, set the next chunk size to the current tape length.\n        chunk_size = total_length\n\ndef run_cftp_experiment(n, E, beta, q, m, s):\n    \"\"\"\n    Runs m independent CFTP simulations and computes the empirical quantile T*.\n    \"\"\"\n    adj = build_adj_list(n, E)\n    # Initialize the random number generator with the specified seed.\n    rng = np.random.default_rng(s)\n    \n    work_values = []\n    for _ in range(m):\n        work = single_cftp_run(n, adj, beta, rng)\n        work_values.append(work)\n        \n    # Sort the observed coalescence work values.\n    work_values.sort()\n    \n    # Calculate the index for the empirical quantile based on the problem's definition.\n    # The index is ceil(q * m) - 1 for a 0-indexed list.\n    k = math.ceil(q * m) - 1\n    \n    # Ensure the index is within the valid range [0, m-1].\n    # This is a safeguard; with valid q and m, it should be correct.\n    k = max(0, min(k, m - 1))\n        \n    t_star = work_values[k]\n    \n    return t_star\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}