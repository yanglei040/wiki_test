{
    "hands_on_practices": [
        {
            "introduction": "理解无U形转弯采样器（NUTS）的第一步是掌握其核心机制：如何构建和评估哈密顿轨迹。本练习旨在提供一个基础的、动手操作的经验，让你通过代码实现NUTS轨迹构建过程中的关键部分。你将使用蛙跳积分器来模拟哈密顿动力学，并对生成的每个状态应用两个基本检验——切片有效性检验和U形转弯检验，从而具体地观察到NUTS是如何在一个简单的二维高斯目标上逐步构建其探索路径的 。",
            "id": "3355983",
            "problem": "给定一个二维高斯目标分布，其均值向量为 $\\mu \\in \\mathbb{R}^2$，对称正定 (SPD) 精度矩阵为 $\\Sigma^{-1} \\in \\mathbb{R}^{2 \\times 2}$，由此导出势能函数 $U(q)$ 定义为\n$$\nU(q) = \\frac{1}{2} (q - \\mu)^{\\top} \\Sigma^{-1} (q - \\mu),\n$$\n及其梯度\n$$\n\\nabla U(q) = \\Sigma^{-1} (q - \\mu).\n$$\n在哈密顿蒙特卡洛 (HMC) 中，一个对称正定质量矩阵 $M \\in \\mathbb{R}^{2 \\times 2}$ 定义了动能\n$$\nK(p) = \\frac{1}{2} p^{\\top} M^{-1} p,\n$$\n与哈密顿量\n$$\nH(q, p) = U(q) + K(p).\n$$\n步长为 $\\epsilon  0$ 的标准蛙跳积分器通过以下方式更新 $(q, p)$\n$$\np_{\\text{half}} = p - \\frac{\\epsilon}{2} \\nabla U(q), \\quad\nq_{\\text{new}} = q + \\epsilon M^{-1} p_{\\text{half}}, \\quad\np_{\\text{new}} = p_{\\text{half}} - \\frac{\\epsilon}{2} \\nabla U(q_{\\text{new}}).\n$$\n\n考虑在单一方向 $v = +1$、深度为 $j = 2$ 的无U形转弯采样器 (NUTS) 建树过程。该过程从根状态 $(q_0, p_0)$ 开始，执行 $2^j = 4$ 次前向蛙跳步骤，生成 $k \\in \\{1,2,3,4\\}$ 的 $4$ 个叶节点状态 $(q^{(k)}, p^{(k)})$。设切片变量 $u$ 通过根节点确定性地构造，方式如下\n$$\nu = s \\cdot \\exp\\big(-H(q_0, p_0)\\big),\n$$\n其中 $s \\in (0, 1)$ 是给定的切片因子。\n\n对于每个叶节点 $k$，定义位移\n$$\n\\Delta q^{(k)} = q^{(k)} - q_0,\n$$\n并使用标准准则执行无U形转弯检查，该准则根据当前边界状态进行评估，其中负端为根节点，正端为叶节点：\n$$\n\\text{U-turn}^{(k)} = \\Big( \\Delta q^{(k)} \\cdot p_0  0 \\Big) \\ \\text{or} \\ \\Big( \\Delta q^{(k)} \\cdot p^{(k)}  0 \\Big).\n$$\n同时，通过以下方式确定叶节点的切片有效性：\n$$\n\\text{valid}^{(k)} = \\Big( \\exp\\big(-H(q^{(k)}, p^{(k)})\\big) \\ge u \\Big).\n$$\n\n你的任务是为以下每个参数集（测试套件）实现上述针对二维高斯目标分布的两层树构建过程，从根节点开始精确执行 $4$ 次前向蛙跳步骤，并为每个叶节点报告其状态 $(q^{(k)}, p^{(k)})$、其哈密顿量 $H(q^{(k)}, p^{(k)})$、其无U形转弯检查 $\\text{U-turn}^{(k)}$ 和其切片有效性 $\\text{valid}^{(k)}$。\n\n使用以下测试套件，每个案例指定 $(\\mu, \\Sigma^{-1}, M, q_0, p_0, \\epsilon, s)$：\n\n- 案例 1 (理想路径，各向同性目标和质量)：\n  - $\\mu = [0, 0]$\n  - $\\Sigma^{-1} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$\n  - $M = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$\n  - $q_0 = [-0.5, 0.5]$\n  - $p_0 = [0.3, -0.1]$\n  - $\\epsilon = 0.25$\n  - $s = 0.5$\n\n- 案例 2 (各向异性目标和质量，中等步长)：\n  - $\\mu = [0, 0]$\n  - $\\Sigma^{-1} = \\begin{bmatrix} 0.25  0 \\\\ 0  4.0 \\end{bmatrix}$\n  - $M = \\begin{bmatrix} 1.0  0 \\\\ 0  2.0 \\end{bmatrix}$\n  - $q_0 = [1.0, -1.0]$\n  - $p_0 = [-0.2, 0.4]$\n  - $\\epsilon = 0.2$\n  - $s = 0.3$\n\n- 案例 3 (相关目标和非对角质量，小步长；边缘情况覆盖)：\n  - $\\mu = [0, 0]$\n  - $\\Sigma^{-1} = \\begin{bmatrix} 1.0  0.3 \\\\ 0.3  1.5 \\end{bmatrix}$\n  - $M = \\begin{bmatrix} 1.0  0.5 \\\\ 0.5  2.0 \\end{bmatrix}$\n  - $q_0 = [0.7, -2.0]$\n  - $p_0 = [0.8, 0.1]$\n  - $\\epsilon = 0.1$\n  - $s = 0.8$\n\n你的程序必须为每个案例计算包含 $4$ 个叶节点条目的列表。每个叶节点条目必须是列表\n$$\n[q^{(k)}_1, q^{(k)}_2, p^{(k)}_1, p^{(k)}_2, H(q^{(k)}, p^{(k)}), \\text{U-turn}^{(k)}, \\text{valid}^{(k)}],\n$$\n其中 $q^{(k)}_1$ 和 $q^{(k)}_2$ 是 $q^{(k)}$ 的分量，$p^{(k)}_1$ 和 $p^{(k)}_2$ 是 $p^{(k)}$ 的分量。\n\n最终输出格式要求：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。顶层列表必须恰好包含三个元素，每个测试案例一个，并且每个元素都必须是上面描述的四个叶节点条目的列表。例如，打印的字符串必须看起来像\n$$\n[\\text{case1\\_leaves}, \\text{case2\\_leaves}, \\text{case3\\_leaves}],\n$$\n前后不得有任何附加文本。\n\n本问题不涉及物理单位或角度。所有计算均为纯数学计算。",
            "solution": "该问题是有效的。它提出了一个定义明确的计算任务，基于哈密顿蒙特卡洛 (HMC) 和无U形转弯采样器 (NUTS) 算法的可靠原理。所有提供的参数和方程都是标准的、完整的且一致的。我现在将开始解答。\n\n问题的核心是模拟一段有限长度的哈密顿轨迹，并在每一步评估特定准则。我们获得了为一个二维高斯概率分布采样而量身定制的哈密顿系统的基本组成部分。\n\n首先，我们定义数学对象。目标概率密度与 $\\exp(-U(q))$ 成正比，其中 $U(q)$ 是势能。对于均值为 $\\mu$、协方差为 $\\Sigma$（或精度为 $\\Sigma^{-1}$）的多元高斯分布，其势能由负对数密度给出（不计一个可加常数）：\n$$\nU(q) = \\frac{1}{2} (q - \\mu)^{\\top} \\Sigma^{-1} (q - \\mu)\n$$\n模拟动力学所需的势能梯度为：\n$$\n\\nabla U(q) = \\Sigma^{-1} (q - \\mu)\n$$\n系统的动力学通过动量变量 $p$ 得到增广，并通过质量矩阵 $M$ 定义动能：\n$$\nK(p) = \\frac{1}{2} p^{\\top} M^{-1} p\n$$\n系统的总能量是哈密顿量 $H(q, p)$，它是势能和动能之和：\n$$\nH(q, p) = U(q) + K(p) = \\frac{1}{2} (q - \\mu)^{\\top} \\Sigma^{-1} (q - \\mu) + \\frac{1}{2} p^{\\top} M^{-1} p\n$$\n哈密顿方程描述了 $(q, p)$ 随时间的演化，理论上它会保持 $H(q, p)$ 守恒。对于数值模拟，我们使用一个辛积分器，如蛙跳积分器，它能近似哈密顿方程的解，并表现出良好的长期能量守恒特性。步长为 $\\epsilon$ 的蛙跳积分器的单步操作由三个阶段定义：\n1.  动量的半步更新：$p_{\\text{half}} = p - \\frac{\\epsilon}{2} \\nabla U(q)$\n2.  位置的全步更新：$q_{\\text{new}} = q + \\epsilon M^{-1} p_{\\text{half}}$\n3.  动量的最终半步更新：$p_{\\text{new}} = p_{\\text{half}} - \\frac{\\epsilon}{2} \\nabla U(q_{\\text{new}})$\n\n问题要求我们从初始状态 $(q_0, p_0)$ 开始，模拟一条包含 $2^j = 2^2 = 4$ 次前向蛙跳步骤的轨迹。这将生成一个包含 $4$ 个叶节点状态的序列 $(q^{(k)}, p^{(k)})$，其中 $k \\in \\{1, 2, 3, 4\\}$，而 $(q^{(k)}, p^{(k)})$ 是经过 $k$ 次蛙跳步骤后的状态。\n\n对于每个叶节点，我们必须执行两项与 NUTS 算法相关的检查。\n首先，我们确定切片变量 $u$。这是一个阈值，用于确保采样器探索具有足够高概率的区域。它是根据初始状态的能量计算得出的：\n$$\nu = s \\cdot \\exp\\big(-H(q_0, p_0)\\big)\n$$\n其中 $s \\in (0, 1)$ 是一个给定的随机因子，在此处是确定性地提供的。如果一个状态 $(q, p)$ 满足 $\\exp(-H(q, p)) \\ge u$，则认为它相对于该切片是有效的，这等价于 $H(q, p) \\le H(q_0, p_0) - \\log s$。我们对每个叶节点进行此检查：\n$$\n\\text{valid}^{(k)} = \\Big( \\exp\\big(-H(q^{(k)}, p^{(k)})\\big) \\ge u \\Big)\n$$\n其次，无U形转弯条件旨在当路径开始折返时停止轨迹构建过程，因为折返会导致低效探索。问题指定了一个简化的检查，其中每个叶节点状态 $(q^{(k)}, p^{(k)})$ 都与根状态 $(q_0, p_0)$ 进行比较。从根节点出发的位移向量是 $\\Delta q^{(k)} = q^{(k)} - q_0$。如果轨迹在段的开始或结束时朝向其位移的原点移动，则检测到U形转弯。在数学上，这表示为：\n$$\n\\text{U-turn}^{(k)} = \\Big( (\\Delta q^{(k)} \\cdot p_0)  0 \\Big) \\ \\text{or} \\ \\Big( (\\Delta q^{(k)} \\cdot p^{(k)})  0 \\Big)\n$$\n其中 `$\\cdot$` 表示标准点积。请注意，$p_0$ 是初始动量，表示从 $q_0$ 出发的轨迹段的初始行进方向。\n\n每个测试案例的总体算法如下：\n1.  初始化参数：$\\mu, \\Sigma^{-1}, M, q_0, p_0, \\epsilon, s$。\n2.  计算逆质量矩阵 $M^{-1}$。\n3.  计算初始哈密顿量 $H(q_0, p_0)$ 和切片变量 $u$。\n4.  初始化当前状态 $(q_{curr}, p_{curr}) = (q_0, p_0)$。\n5.  从 $1$ 到 $4$ 迭代 $k$：\n    a. 对 $(q_{curr}, p_{curr})$ 应用一个蛙跳步骤以获得新状态，我们将其标记为 $(q^{(k)}, p^{(k)})$。\n    b. 更新 $(q_{curr}, p_{curr}) = (q^{(k)}, p^{(k)})$ 用于下一次迭代。\n    c. 计算哈密顿量 $H(q^{(k)}, p^{(k)})$。\n    d. 计算位移 $\\Delta q^{(k)} = q^{(k)} - q_0$。\n    e. 评估U形转弯条件 $\\text{U-turn}^{(k)}$。\n    f. 评估切片有效性条件 $\\text{valid}^{(k)}$。\n    g. 为当前叶节点 $k$ 存储结果列表 $[q^{(k)}_1, q^{(k)}_2, p^{(k)}_1, p^{(k)}_2, H(q^{(k)}, p^{(k)}), \\text{U-turn}^{(k)}, \\text{valid}^{(k)}]$。\n6.  将 $4$ 个叶节点的结果收集到当前测试案例的列表中。\n7.  对所有测试案例重复此过程，并按指定格式化最终输出。\n\n所有向量和矩阵运算将使用 `numpy` 库实现。$M$ 的逆矩阵通过 `numpy.linalg.inv` 计算，矩阵-向量乘积使用 `@` 运算符。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed for this problem.\n\ndef solve():\n    \"\"\"\n    Implements the NUTS tree-building procedure for a 2D Gaussian target.\n    For each test case, it performs 4 forward leapfrog steps and computes\n    metrics for each of the 4 leaf states.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1\n        {\n            \"mu\": np.array([0.0, 0.0]),\n            \"Sigma_inv\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"M\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"q0\": np.array([-0.5, 0.5]),\n            \"p0\": np.array([0.3, -0.1]),\n            \"epsilon\": 0.25,\n            \"s\": 0.5,\n        },\n        # Case 2\n        {\n            \"mu\": np.array([0.0, 0.0]),\n            \"Sigma_inv\": np.array([[0.25, 0.0], [0.0, 4.0]]),\n            \"M\": np.array([[1.0, 0.0], [0.0, 2.0]]),\n            \"q0\": np.array([1.0, -1.0]),\n            \"p0\": np.array([-0.2, 0.4]),\n            \"epsilon\": 0.2,\n            \"s\": 0.3,\n        },\n        # Case 3\n        {\n            \"mu\": np.array([0.0, 0.0]),\n            \"Sigma_inv\": np.array([[1.0, 0.3], [0.3, 1.5]]),\n            \"M\": np.array([[1.0, 0.5], [0.5, 2.0]]),\n            \"q0\": np.array([0.7, -2.0]),\n            \"p0\": np.array([0.8, 0.1]),\n            \"epsilon\": 0.1,\n            \"s\": 0.8,\n        },\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        mu = case[\"mu\"]\n        Sigma_inv = case[\"Sigma_inv\"]\n        M = case[\"M\"]\n        q0 = case[\"q0\"]\n        p0 = case[\"p0\"]\n        epsilon = case[\"epsilon\"]\n        s = case[\"s\"]\n        \n        M_inv = np.linalg.inv(M)\n\n        def grad_U(q_vec):\n            return Sigma_inv @ (q_vec - mu)\n\n        def U(q_vec):\n            diff = q_vec - mu\n            return 0.5 * diff.T @ Sigma_inv @ diff\n\n        def K(p_vec):\n            return 0.5 * p_vec.T @ M_inv @ p_vec\n\n        def H(q_vec, p_vec):\n            return U(q_vec) + K(p_vec)\n\n        def leapfrog(q_curr, p_curr):\n            p_half = p_curr - (epsilon / 2.0) * grad_U(q_curr)\n            q_new = q_curr + epsilon * (M_inv @ p_half)\n            p_new = p_half - (epsilon / 2.0) * grad_U(q_new)\n            return q_new, p_new\n\n        # Initial calculations\n        H0 = H(q0, p0)\n        u = s * np.exp(-H0)\n\n        case_leaves = []\n        q_current, p_current = q0, p0\n        \n        # Perform 4 leapfrog steps\n        for _ in range(4):\n            q_k, p_k = leapfrog(q_current, p_current)\n            \n            # Update current state for the next iteration\n            q_current, p_current = q_k, p_k\n\n            # Calculate metrics for the leaf\n            H_k = H(q_k, p_k)\n            delta_q_k = q_k - q0\n            \n            # U-Turn check\n            uturn_check = (np.dot(delta_q_k, p0)  0) or (np.dot(delta_q_k, p_k)  0)\n            \n            # Slice validity check\n            valid_slice = (np.exp(-H_k) >= u)\n            \n            leaf_entry = [\n                q_k[0], q_k[1], \n                p_k[0], p_k[1], \n                H_k, \n                uturn_check, \n                valid_slice\n            ]\n            case_leaves.append(leaf_entry)\n            \n        all_results.append(case_leaves)\n\n    # Custom string formatting to match the output requirements precisely\n    def format_list(item):\n        if isinstance(item, list):\n            return f\"[{','.join(map(format_list, item))}]\"\n        if isinstance(item, bool):\n            return str(item)\n        if isinstance(item, float):\n            return f\"{item:.8f}\" # Use a reasonable precision\n        return str(item)\n\n    # The problem asks for a string representation that `str()` on a list would produce.\n    # The provided print statement in the problem skeleton does this.\n    # Let's use it directly.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "从理论到可靠的实现，一个关键的步骤是处理有限精度计算带来的数值稳定性问题。在NUTS中，一个常见的陷阱是在切片检验中直接计算如 $\\exp(-H)$ 这样的项，当哈密顿量 $H$ 很大时，这很容易导致数值下溢。本练习  将通过一个具体的数值场景，揭示这种朴素计算为何会失败，并指导你推导出一个在对数域中操作的、数值上更稳健的切片检验方法。这是所有生产级MCMC软件中都采用的标准技巧。",
            "id": "3356001",
            "problem": "考虑无U形转弯采样器（NUTS），它是哈密顿蒙特卡洛（HMC）的一种自适应扩展。在哈密顿蒙特卡洛（HMC）中，我们处理的是与$\\exp(-H(\\mathbf{q},\\mathbf{p}))$成正比的位置和动量变量的联合密度，其中$H(\\mathbf{q},\\mathbf{p})$是哈密顿量。NUTS中一个常见的接受机制使用一个切片变量$u$，该变量从$(0,\\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0})))$上均匀抽取，其中$(\\mathbf{q}_{0},\\mathbf{p}_{0})$表示轨迹的初始状态。切片检验的要求是，对于轨迹上的一个提议状态$(\\mathbf{q},\\mathbf{p})$，必须满足$u \\leq \\exp(-H(\\mathbf{q},\\mathbf{p}))$。\n\n在有限精度算术（IEEE 754双精度）中，当$H$很大时，$\\exp(-H)$的值可能会下溢为零，而计算诸如$\\exp(-H(\\mathbf{q},\\mathbf{p}))/\\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0}))$之类比率的实现可能会产生不定式$0/0$，这是一个非数值（not-a-number），即使精确的数学检验应该接受，它也可能被错误地标记为发散。\n\n使用以下具体的数值情景：\n- 设$H(\\mathbf{q}_{0},\\mathbf{p}_{0}) = 1000$且$H(\\mathbf{q},\\mathbf{p}) = 1001.5$。\n- 设$U \\sim \\text{Uniform}(0,1)$并假设一次具体的抽样得到$U = 0.2$。\n\n执行以下操作：\n1. 使用切片检验的设置，解释为什么在这种情景下，计算$u = U \\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0}))$并检验$u \\leq \\exp(-H(\\mathbf{q},\\mathbf{p}))$在有限精度下会失败，尽管基于底层数学的精确接受决策是确定的。\n2. 从第一性原理出发，推导一个数值稳定的切片检验，通过在对数域中工作来避免计算$\\exp(-H)$。用$\\ln U$、$H(\\mathbf{q},\\mathbf{p})$和$H(\\mathbf{q}_{0},\\mathbf{p}_{0})$来表示该检验。\n3. 对于给定的数值，计算稳定检验统计量$T = \\ln U + H(\\mathbf{q},\\mathbf{p}) - H(\\mathbf{q}_{0},\\mathbf{p}_{0})$。\n\n将你最终的$T$的数值答案四舍五入到十位有效数字。不需要物理单位，因为所有量都是无量纲的。你的最终答案必须是$T$的单个四舍五入后的值。",
            "solution": "问题陈述具有科学依据，提法恰当且客观。它解决了一个在实现如无U形转弯采样器（NUTS）等复杂蒙特卡洛方法时真实且重要的数值稳定性问题。所有必要的数据和定义都已提供，并且没有矛盾。因此，该问题是有效的，可以构建解决方案。\n\n问题分为三个部分，将按顺序进行解答。\n\n### 第1部分：朴素切片检验的失败\n\n哈密顿蒙特卡洛（HMC）及其变体（如NUTS）中的切片采样机制旨在维持相对于目标分布的细致平衡条件。系统的状态由位置$\\mathbf{q}$和动量$\\mathbf{p}$描述，其哈密顿量为$H(\\mathbf{q},\\mathbf{p})$。目标概率密度与$\\exp(-H(\\mathbf{q},\\mathbf{p}))$成正比。\n\n引入一个切片变量$u$，它从区间$(0, \\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0})))$上的均匀分布中抽取，其中$(\\mathbf{q}_{0},\\mathbf{p}_{0})$是轨迹的初始状态。这等价于首先抽取一个标准均匀随机变量$U \\sim \\text{Uniform}(0,1)$，然后设置$u = U \\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0}))$。\n\n沿着模拟的哈密顿轨迹的一个提议状态$(\\mathbf{q},\\mathbf{p})$，如果它位于由条件$u \\leq \\exp(-H(\\mathbf{q},\\mathbf{p}))$定义的切片内，则被认为是有效的。代入$u$的表达式，接受条件为：\n$$U \\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0})) \\leq \\exp(-H(\\mathbf{q},\\mathbf{p}))$$\n\n让我们使用有限精度算术（具体来说是IEEE 754双精度）以及给定的数值来分析这个条件：$H(\\mathbf{q}_{0},\\mathbf{p}_{0}) = 1000$和$H(\\mathbf{q},\\mathbf{p}) = 1001.5$。\n\n在IEEE 754双精度中，最小的正规格化数约为$2.225 \\times 10^{-308}$。这个数的自然对数是$\\ln(2.225 \\times 10^{-308}) \\approx -708.4$。任何比这个数小的数，例如对于$x  708.4$的$\\exp(-x)$，都会下溢为零。\n\n对于初始状态，我们需要计算$\\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0})) = \\exp(-1000)$。由于$-1000  -708.4$，这个值在双精度算术中下溢为$0$。\n$$ \\exp(-1000) \\to 0.0 $$\n\n对于提议状态，我们需要计算$\\exp(-H(\\mathbf{q},\\mathbf{p})) = \\exp(-1001.5)$。由于$-1001.5  -708.4$，这个值也下溢为$0$。\n$$ \\exp(-1001.5) \\to 0.0 $$\n\n对于给定的抽样$U=0.2$，朴素的有限精度实现的切片检验变为：\n$$ 0.2 \\times \\exp(-1000) \\leq \\exp(-1001.5) $$\n$$ 0.2 \\times 0.0 \\leq 0.0 $$\n$$ 0.0 \\leq 0.0 $$\n这个不等式成立，所以提议状态被接受。\n\n现在，让我们检验精确的数学条件。它等价于$U \\leq \\exp(H(\\mathbf{q}_{0},\\mathbf{p}_{0}) - H(\\mathbf{q},\\mathbf{p}))$。\n$$ 0.2 \\leq \\exp(1000 - 1001.5) $$\n$$ 0.2 \\leq \\exp(-1.5) $$\n由于$\\exp(-1.5) \\approx 0.22313016$，条件是$0.2 \\leq 0.22313016$，这是成立的。\n\n在这个具体案例中，朴素检验和精确检验都得到相同的结果（接受）。然而，朴素方法的失败在于其无差别的行为。考虑一个具有更高哈密顿量的不同提议状态，比如$H(\\mathbf{q}',\\mathbf{p}') = 2000$。\n朴素的有限精度检验将是：\n$$ 0.2 \\times \\exp(-1000) \\leq \\exp(-2000) \\implies 0.0 \\leq 0.0 $$\n这是成立的，导致接受。\n然而，精确的数学检验将是：\n$$ 0.2 \\leq \\exp(1000 - 2000) = \\exp(-1000) $$\n由于$\\exp(-1000)$是一个极小的正数，条件$0.2 \\leq \\exp(-1000)$是错误的。该状态应该被拒绝。\n\n因此，失败之处在于朴素实现会接受*任何*$\\exp(-H)$下溢的状态，完全没有像算法要求的那样惩罚高能量（大$H$）的状态。这破坏了细致平衡条件，并导致一个不正确的采样器。问题中提到的另一种形式，即计算比率$\\exp(-H)/\\exp(-H_0)$，会导致不定式$0/0$，这也是一种实现上的失败。\n\n### 第2部分：数值稳定检验的推导\n\n为了避免与显式计算$\\exp(-H)$相关的数值下溢，我们可以在对数域中工作。接受条件是：\n$$U \\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0})) \\leq \\exp(-H(\\mathbf{q},\\mathbf{p}))$$\n由于$U$、$\\exp(-H_{0})$和$\\exp(-H)$都是严格为正的量，我们可以对不等式两边取自然对数而不改变其方向。自然对数函数$\\ln(x)$在$x0$上是单调递增的。\n$$ \\ln\\left(U \\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0}))\\right) \\leq \\ln\\left(\\exp(-H(\\mathbf{q},\\mathbf{p}))\\right) $$\n使用对数性质$\\ln(ab) = \\ln(a) + \\ln(b)$，左边变为：\n$$ \\ln(U) + \\ln\\left(\\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0}))\\right) \\leq \\ln\\left(\\exp(-H(\\mathbf{q},\\mathbf{p}))\\right) $$\n使用性质$\\ln(\\exp(x)) = x$，我们简化两边：\n$$ \\ln(U) - H(\\mathbf{q}_{0},\\mathbf{p}_{0}) \\leq -H(\\mathbf{q},\\mathbf{p}) $$\n这个不等式就是数值稳定的切片检验。它涉及哈密顿量$H$和$H_0$以及均匀变量的对数$\\ln(U)$，这些都不会遇到指数函数那样的下溢问题。所涉及的数字（$1000$、$1001.5$和$\\ln(0.2)$）都在标准浮点类型的可表示范围内。\n\n为了与问题中给出的检验统计量$T$相匹配，我们可以通过将所有项移到一边来重新排列不等式：\n$$ \\ln(U) + H(\\mathbf{q},\\mathbf{p}) - H(\\mathbf{q}_{0},\\mathbf{p}_{0}) \\leq 0 $$\n这表明稳定的检验是计算统计量$T = \\ln(U) + H(\\mathbf{q},\\mathbf{p}) - H(\\mathbf{q}_{0},\\mathbf{p}_{0})$，并且当且仅当$T \\leq 0$时接受提议状态。\n\n### 第3部分：检验统计量的计算\n\n我们被要求计算在给定数值情景下稳定检验统计量$T$的值。\n公式是：\n$$ T = \\ln U + H(\\mathbf{q},\\mathbf{p}) - H(\\mathbf{q}_{0},\\mathbf{p}_{0}) $$\n给定的值是：\n- $U = 0.2$\n- $H(\\mathbf{q}_{0},\\mathbf{p}_{0}) = 1000$\n- $H(\\mathbf{q},\\mathbf{p}) = 1001.5$\n\n将这些值代入$T$的表达式中：\n$$ T = \\ln(0.2) + 1001.5 - 1000 $$\n$$ T = \\ln(0.2) + 1.5 $$\n$0.2$的自然对数是：\n$$ \\ln(0.2) \\approx -1.60943791243410037 $$\n现在，我们计算$T$：\n$$ T \\approx -1.60943791243410037 + 1.5 $$\n$$ T \\approx -0.10943791243410037 $$\n问题要求将结果四舍五入到十位有效数字。前十位有效数字是$1, 0, 9, 4, 3, 7, 9, 1, 2, 4$。第十一位有效数字是$3$。由于$3  5$，我们向下取整（即截断）。\n$$ T \\approx -0.1094379124 $$\n对于稳定检验，由于$T \\approx -0.1094379124 \\leq 0$，提议状态被正确接受，这与精确数学分析的结论相符。",
            "answer": "$$ \\boxed{-0.1094379124} $$"
        },
        {
            "introduction": "标准的NUTS算法虽然强大，但其默认的欧几里得U形转弯判据在处理具有强各向异性（anisotropic）的目标分布时会遇到困难，即当不同参数维度的尺度差异巨大时，它可能无法有效检测到轨迹的折返。本高级练习  将引导你构建一个清晰的反例，展示这种失效情况，并让你亲手实现一个更通用的、考虑了质量矩阵 $M$ 的停止准则。这不仅能加深你对NUTS局限性的理解，更能让你体会到将问题几何结构融入算法设计的重要性。",
            "id": "3355985",
            "problem": "考虑一个在哈密顿蒙特卡洛（HMC）中用于从高斯目标分布采样的可分离哈密顿系统。该目标分布具有二次势能 $U(\\theta) = \\tfrac{1}{2} \\theta^\\top \\Lambda \\theta$（其中 $\\Lambda$ 是一个正定精度矩阵），以及动能 $K(p) = \\tfrac{1}{2} p^\\top M^{-1} p$（其中 $M$ 是一个正定质量矩阵）。哈密顿方程为 $d\\theta/dt = M^{-1} p$ 和 $dp/dt = -\\Lambda \\theta$。对于对角的 $M$ 和 $\\Lambda$，每个坐标都作为一个谐振子独立演化。无U形转弯采样器（NUTS）使用一个停止准则来防止模拟轨迹发生回溯。经典的欧几里得NUTS准则通过检查轨迹位移与端点动量之间的内积符号来判断。在强各向异性的情况下（例如，当 $M$ 的元素数量级差异巨大时），这个欧几里得准则可能无法检测到实际的回溯，因为它没有考虑质量矩阵如何缩放物理速度。你的任务是构建一个反例来证明这种失效，并实现一个使用由质量矩阵所蕴含的物理速度的广义停止检验。\n\n从上述基本定义出发，在一个完整的、可运行的程序中实现以下步骤：\n\n1. 使用对角 $M$ 和对角 $\\Lambda$ 的线性哈密顿系统的精确解来计算对称轨迹段的端点。令 $\\omega_i = \\sqrt{\\Lambda_i / M_i}$ 表示第 $i$ 个坐标的角频率。对于给定的初始状态 $(\\theta_0, p_0)$ 和积分时间 $T$（在三角函数中作为参数，以弧度为单位），定义在时间 $+T$ 的端点 $(\\theta^+, p^+)$ 和在时间 $-T$ 的端点 $(\\theta^-, p^-)$。同时定义位移 $\\Delta \\theta = \\theta^+ - \\theta^-$。你的程序必须为对角的 $M$ 和对角 $\\Lambda$ 精确计算这些量。\n\n2. 实现两种停止检验：\n   - 欧几里得NUTS停止检验：如果内积 $\\Delta \\theta^\\top p^+$ 或 $\\Delta \\theta^\\top p^-$ 中任意一个严格为负，则宣布“停止”。\n   - 广义M加权停止检验：如果内积 $\\Delta \\theta^\\top M^{-1} p^+$ 或 $\\Delta \\theta^\\top M^{-1} p^-$ 中任意一个严格为负，则宣布“停止”。该检验使用物理速度 $v = M^{-1} p$ 而非原始动量。\n\n3. 构建一个科学上合理的反例，其中 $M$ 的强各向异性导致欧几里得检验未能阻止回溯，而M加权检验能正确检测到它。为该反例使用以下参数值：\n   - $M = \\mathrm{diag}(10^{-4}, 1)$,\n   - $\\Lambda = \\mathrm{diag}(1, 1)$,\n   - $\\theta_0 = [1, 1]^\\top$,\n   - $p_0 = [0.01, 1.262]^\\top$,\n   - $T = \\pi / (2 \\cdot 100)$.\n\n   三角函数内的角度必须以弧度为单位。选择这些值是为了产生差异巨大的角频率，具体来说是 $\\omega_1 = 100$ 和 $\\omega_2 = 1$，这会在动力学中引入强各向异性。\n\n4. 提供两个额外的测试用例以确保覆盖率：\n   - 各向同性的“理想”情况，其中 $M = \\mathrm{diag}(1, 1)$ 和 $\\Lambda = \\mathrm{diag}(1, 1)$，并使用适中的 $T$ 和初始状态，以证明欧几里得检验和M加权检验结果一致：\n     - $M = \\mathrm{diag}(1, 1)$,\n     - $\\Lambda = \\mathrm{diag}(1, 1)$,\n     - $\\theta_0 = [0.3, -0.8]^\\top$,\n     - $p_0 = [0.7, 0.2]^\\top$,\n     - $T = 0.7$.\n   - 极端各向异性的边界情况，但动量仅与慢维度对齐（因此由于积分时间非常短，两种检验都同意并且不会停止）：\n     - $M = \\mathrm{diag}(10^{-6}, 1)$,\n     - $\\Lambda = \\mathrm{diag}(1, 1)$,\n     - $\\theta_0 = [0.0, 1.0]^\\top$,\n     - $p_0 = [0.0, 0.1]^\\top$,\n     - $T = 0.01$.\n\n5. 对于每个测试用例，你的程序必须计算并返回一个包含三个布尔值的列表：\n   - 欧几里得停止决策（如果欧几里得检验要求停止，则为true，否则为false），\n   - M加权停止决策（如果广义检验要求停止，则为true，否则为false），\n   - 一个失败标志，当且仅当欧几里得检验未停止而M加权检验停止时为true。\n\n6. 最终输出格式：你的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，每个测试用例的结果本身也是一个由方括号括起来的、逗号分隔的布尔值列表。例如，对于三个测试用例，输出应类似于 $[[\\text{False},\\text{True},\\text{True}],[\\text{False},\\text{False},\\text{False}],[\\text{False},\\text{False},\\text{False}]]$。\n\n程序不应读取任何用户输入。三角函数内的角度必须以弧度为单位，并且使用的任何数值都必须视为无量纲。所有计算都必须相对于对角 $M$ 和对角 $\\Lambda$ 的闭式解是精确的；请勿在此程序中使用数值积分器。",
            "solution": "该问题要求实现并比较无U形转弯采样器（NUTS）的两种停止准则。NUTS是一种用于哈密顿蒙特卡洛（HMC）的算法。其背景是从一个多元高斯分布中进行采样，该分布的哈密顿动力学具有闭式解。我们必须展示一个场景，其中标准的欧几里得停止准则失效，而一个广义的、能感知质量矩阵的准则成功。\n\n首先，我们建立理论基础。该系统由势能 $U(\\theta) = \\frac{1}{2} \\theta^\\top \\Lambda \\theta$ 和动能 $K(p) = \\frac{1}{2} p^\\top M^{-1} p$ 定义。矩阵 $\\Lambda$（精度）和 $M$（质量）被给定为正定和对角矩阵。哈密顿量为 $H(\\theta, p) = U(\\theta) + K(p)$。哈密顿运动方程为：\n$$\n\\frac{d\\theta}{dt} = \\frac{\\partial H}{\\partial p} = M^{-1} p\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial \\theta} = -\\Lambda \\theta\n$$\n由于 $M$ 和 $\\Lambda$ 是对角矩阵，其元素分别为 $M_i$ 和 $\\Lambda_i$，该系统解耦为每个坐标 $i$ 的一组独立方程：\n$$\n\\frac{d\\theta_i}{dt} = \\frac{p_i}{M_i}\n$$\n$$\n\\frac{dp_i}{dt} = -\\Lambda_i \\theta_i\n$$\n通过将第一个方程对时间 $t$ 求导并代入第二个方程，我们得到了每个坐标 $\\theta_i$ 的简谐振子方程：\n$$\n\\frac{d^2\\theta_i}{dt^2} = \\frac{1}{M_i}\\frac{dp_i}{dt} = -\\frac{\\Lambda_i}{M_i}\\theta_i\n$$\n令 $\\omega_i = \\sqrt{\\Lambda_i / M_i}$ 为第 $i$ 个坐标的角频率，方程变为 $\\ddot{\\theta}_i + \\omega_i^2 \\theta_i = 0$。给定 $t=0$ 时的初始条件 $(\\theta_{i,0}, p_{i,0})$，该系统的精确解是相空间中的一个旋转：\n$$\n\\theta_i(t) = \\theta_{i,0} \\cos(\\omega_i t) + \\frac{p_{i,0}}{M_i \\omega_i} \\sin(\\omega_i t)\n$$\n$$\np_i(t) = p_{i,0} \\cos(\\omega_i t) - M_i \\omega_i \\theta_{i,0} \\sin(\\omega_i t)\n$$\n使用关系式 $\\omega_i = \\sqrt{\\Lambda_i / M_i}$，我们可以写出 $M_i \\omega_i = \\sqrt{M_i \\Lambda_i}$。解可以表示为：\n$$\n\\begin{pmatrix} \\theta_i(t) \\\\ p_i(t) \\end{pmatrix} = \\begin{pmatrix} \\cos(\\omega_i t)  \\frac{1}{\\sqrt{M_i\\Lambda_i}}\\sin(\\omega_i t) \\\\ -\\sqrt{M_i\\Lambda_i}\\sin(\\omega_i t)  \\cos(\\omega_i t) \\end{pmatrix} \\begin{pmatrix} \\theta_{i,0} \\\\ p_{i,0} \\end{pmatrix}\n$$\nNUTS算法构建一个平衡二叉树形式的轨迹段来探索状态空间。当检测到U形转弯时，它会停止扩展轨迹。一个对称的轨迹段是通过从初始状态 $(\\theta_0, p_0)$ 开始，在时间上向前和向后积分 $T$ 的量来定义的。这会产生一个最左点 $(\\theta^-, p^-) = (\\theta(-T), p(-T))$ 和一个最右点 $(\\theta^+, p^+) = (\\theta(T), p(T))$。轨迹段的跨度是向量 $\\Delta \\theta = \\theta^+ - \\theta^-$。\n\n停止准则旨在检测轨迹何时开始折返。\n1.  **欧几里得NUTS停止检验：** 此检验检查轨迹是否在扩张。如果任一端点的动量指向轨迹段的起点，则停止。数学上，如果满足以下条件，则宣布停止：\n    $$\n    (\\Delta \\theta)^\\top p^+  0 \\quad \\text{or} \\quad (\\Delta \\theta)^\\top p^-  0\n    $$\n2.  **广义M加权停止检验：** 在各向异性的设置中（其中 $M$ 的元素差异很大），动量 $p$ 与物理速度 $v = d\\theta/dt$ 并不对齐。需要检查的正确物理量是速度。广义检验在内积中使用 $v = M^{-1}p$。如果满足以下条件，则宣布停止：\n    $$\n    (\\Delta \\theta)^\\top (M^{-1}p^+)  0 \\quad \\text{or} \\quad (\\Delta \\theta)^\\top (M^{-1}p^-)  0\n    $$\n    当 $M$ 是单位矩阵的标量倍数，即 $M = cI$ 时，此检验等同于欧几里得检验，因为 $M^{-1}p = (1/c)p$。然而，在强各向异性的情况下，它们可能产生不同的结果。\n\n程序将为给定的三个测试用例实现 $\\theta(t)$ 和 $p(t)$ 的精确解析解。对于每种情况，它将计算轨迹端点 $(\\theta^\\pm, p^\\pm)$、位移 $\\Delta \\theta$，并应用两种停止检验。主要的反例被构造成使得一个高频坐标完成半圈旋转（$\\omega_1 T = \\pi/2$），导致其动量 $p_1$ 反向。由于质量 $M_1$ 非常小，$p_1$ 的大小也很小。欧几里得内积由另一个慢速移动的坐标主导，因此未能检测到这种反转。M加权检验通过乘以较大的 $M_1^{-1}$ 来缩放 $p_1$，从而揭示出较大的负物理速度 $v_1$，并正确地发出停止信号。另外两种情况作为对照组，一种是各向同性系统，另一种是动力学不会触发停止的各向异性系统。\n\n最终输出将是一个列表的列表，其中每个内部列表包含三个布尔值，分别对应欧几里得检验、M加权检验的结果，以及一个仅在前者失败而后者成功时为真的失败标志。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import constants  # Only for np.pi, not strictly necessary but adheres to library list.\n\ndef solve():\n    \"\"\"\n    Solves the problem by analyzing three test cases for the NUTS stopping criteria.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Counterexample\n        {\n            \"M_diag\": np.array([1e-4, 1.0]),\n            \"Lambda_diag\": np.array([1.0, 1.0]),\n            \"theta0\": np.array([1.0, 1.0]),\n            \"p0\": np.array([0.01, 1.262]),\n            \"T\": np.pi / (2.0 * 100.0),\n        },\n        # Case 2: Isotropic \"happy path\"\n        {\n            \"M_diag\": np.array([1.0, 1.0]),\n            \"Lambda_diag\": np.array([1.0, 1.0]),\n            \"theta0\": np.array([0.3, -0.8]),\n            \"p0\": np.array([0.7, 0.2]),\n            \"T\": 0.7,\n        },\n        # Case 3: Aligned edge case\n        {\n            \"M_diag\": np.array([1e-6, 1.0]),\n            \"Lambda_diag\": np.array([1.0, 1.0]),\n            \"theta0\": np.array([0.0, 1.0]),\n            \"p0\": np.array([0.0, 0.1]),\n            \"T\": 0.01,\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        # Step 1: Compute trajectory endpoints using the exact solution.\n        theta_plus, p_plus, theta_minus, p_minus = solve_hamiltonian(\n            params[\"theta0\"], params[\"p0\"], params[\"M_diag\"], params[\"Lambda_diag\"], params[\"T\"]\n        )\n\n        # Step 2: Implement and run the stopping tests.\n        delta_theta = theta_plus - theta_minus\n        \n        # Euclidean test\n        dot_plus_euc = np.dot(delta_theta, p_plus)\n        dot_minus_euc = np.dot(delta_theta, p_minus)\n        stop_euc = (dot_plus_euc  0) or (dot_minus_euc  0)\n\n        # M-weighted test\n        M_inv_diag = 1.0 / params[\"M_diag\"]\n        v_plus = M_inv_diag * p_plus\n        v_minus = M_inv_diag * p_minus\n        \n        dot_plus_m_w = np.dot(delta_theta, v_plus)\n        dot_minus_m_w = np.dot(delta_theta, v_minus)\n        stop_m_weighted = (dot_plus_m_w  0) or (dot_minus_m_w  0)\n\n        # Step 3: Determine the failure flag.\n        failure = (not stop_euc) and stop_m_weighted\n        \n        results.append([stop_euc, stop_m_weighted, failure])\n    \n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists is '[[], [], []]'\n    # which we can manipulate to match the required output format.\n    formatted_output = str(results).replace(\" \", \"\")\n    print(formatted_output)\n\ndef solve_hamiltonian(theta0, p0, M_diag, Lambda_diag, T):\n    \"\"\"\n    Computes the exact solution of the Hamiltonian system for diagonal M and Lambda.\n\n    Args:\n        theta0 (np.ndarray): Initial position vector.\n        p0 (np.ndarray): Initial momentum vector.\n        M_diag (np.ndarray): Diagonal elements of the mass matrix M.\n        Lambda_diag (np.ndarray): Diagonal elements of the precision matrix Lambda.\n        T (float): Integration time.\n\n    Returns:\n        tuple: A tuple containing (theta+, p+, theta-, p-).\n    \"\"\"\n    # Angular frequencies\n    omega = np.sqrt(Lambda_diag / M_diag)\n    \n    # Precompute trigonometric terms for t = T\n    cos_omega_T = np.cos(omega * T)\n    sin_omega_T = np.sin(omega * T)\n    \n    # Scaling factor for momentum term in theta's solution\n    mom_scaling = 1.0 / (M_diag * omega) # which is 1.0 / np.sqrt(M_diag * Lambda_diag)\n    \n    # Scaling factor for position term in p's solution\n    pos_scaling = M_diag * omega # which is np.sqrt(M_diag * Lambda_diag)\n\n    # Calculate state at t = +T\n    theta_plus = theta0 * cos_omega_T + p0 * mom_scaling * sin_omega_T\n    p_plus = p0 * cos_omega_T - theta0 * pos_scaling * sin_omega_T\n\n    # Calculate state at t = -T\n    # cos(-x) = cos(x), sin(-x) = -sin(x)\n    theta_minus = theta0 * cos_omega_T - p0 * mom_scaling * sin_omega_T\n    p_minus = p0 * cos_omega_T + theta0 * pos_scaling * sin_omega_T\n    \n    return theta_plus, p_plus, theta_minus, p_minus\n\nsolve()\n```"
        }
    ]
}