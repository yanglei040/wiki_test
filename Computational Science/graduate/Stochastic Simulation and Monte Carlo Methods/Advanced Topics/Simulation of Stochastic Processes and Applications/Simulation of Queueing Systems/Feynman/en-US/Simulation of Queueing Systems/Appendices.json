{
    "hands_on_practices": [
        {
            "introduction": "This practice will start by building the engine of our analysis: a discrete-event simulator. We'll focus on a versatile and practical model, the $M/M/1/b$ queue, which incorporates customer \"balking\"—a common behavior in real-world systems where customers turn away if the queue is too long. By implementing this simulation from scratch , you will master the core mechanics of event-driven logic, state management, and the empirical measurement of key performance indicators like throughput, utilization, and waiting times.",
            "id": "3343632",
            "problem": "Consider a single-server queueing system with exponentially distributed inter-arrival and service times and balking. Let $Q(t)$ denote the total number of customers in the system (including any in service) at time $t$. Arrivals form a Poisson process with rate $\\lambda$ (in $\\mathrm{s}^{-1}$), service times are independent and exponentially distributed with rate $\\mu$ (in $\\mathrm{s}^{-1}$), and the server can process one customer at a time. Balking occurs according to the following rule: an arriving customer is admitted only if $Q(t)  b$, where $b$ is a finite capacity threshold; otherwise, the customer balks and departs immediately without entering the system. When $b = \\infty$, there is no balking and the system is the standard $M/M/1$ queue. When $b$ is finite, the system is an $M/M/1/b$ loss/finite-capacity system.\n\nStarting from the fundamental facts that (i) the Poisson process has independent and stationary increments and exponentially distributed inter-arrival times, and (ii) exponential service times are memoryless and independent of arrivals, implement an event-driven stochastic simulation of this system over a finite horizon of length $T$ seconds. For each test case, use a pseudorandom number generator seeded with $s$ and re-seed per case with $s+i$ for case index $i$ starting from $i=0$, so that the results are reproducible.\n\nYour simulation must compute the following performance metrics over the simulation horizon:\n- The estimated effective admitted arrival rate $\\hat{\\lambda}_{\\mathrm{eff}}$ in $\\mathrm{s}^{-1}$, defined as the number of admitted arrivals divided by $T$.\n- The estimated balking fraction $\\hat{p}_{\\mathrm{balk}}$, defined as the number of balked arrivals divided by the total number of arrival attempts (admitted plus balked). This must be reported as a decimal.\n- The estimated server utilization $\\hat{\\rho}$, defined as the fraction of time the server is busy over $[0,T]$.\n- The estimated time-average number in system $\\widehat{E}[Q]$, computed as the integral of $Q(t)$ over $[0,T]$ divided by $T$.\n- The estimated average waiting time in queue $\\widehat{E}[W]$ in seconds, defined as the average of $W_i$, where $W_i$ is the waiting time (arrival to service-start) for admitted customers who start service within $[0,T]$.\n- The estimated average sojourn time $\\widehat{E}[S]$ in seconds, defined as the average of $S_i$, where $S_i$ is the time in system (arrival to departure) for customers who depart within $[0,T]$.\n- The estimated throughput $\\widehat{\\theta}$ in $\\mathrm{s}^{-1}$, defined as the number of departures within $[0,T]$ divided by $T$.\n- A stability indicator $\\mathrm{stable}$ (boolean), defined as `True` if either $b$ is finite (the continuous-time Markov chain is positive recurrent due to finite state space) or, when $b=\\infty$, if $\\lambda  \\mu$ (the standard $M/M/1$ stability condition), and `False` otherwise.\n\nAll times must be reported in seconds and all rates in $\\mathrm{s}^{-1}$. Angles are not applicable. Express the balking fraction as a decimal, not a percentage. Your algorithm must be event-driven: generate the next arrival time as an exponential increment with parameter $\\lambda$, and the next service completion time as an exponential increment with parameter $\\mu$ conditional on the server being busy. Update time-averaged quantities by integrating piecewise-constant trajectories between events. Do not use shortcut formulas for the stationary distribution; derive metrics empirically via simulation.\n\nTest Suite:\nUse the following parameter sets and horizon, with a common base seed $s=314159$:\n1. Case A (happy path, stable $M/M/1$): $\\lambda = 0.8$, $\\mu = 1.0$, $b = \\infty$, $T = 20000$.\n2. Case B (overloaded without balking, stabilized by finite capacity): $\\lambda = 1.2$, $\\mu = 1.0$, $b = 5$, $T = 20000$.\n3. Case C (pure loss system): $\\lambda = 2.0$, $\\mu = 1.0$, $b = 1$, $T = 20000$.\n4. Case D (degenerate zero capacity): $\\lambda = 1.0$, $\\mu = 1.0$, $b = 0$, $T = 20000$.\n5. Case E (fast service, large but finite capacity): $\\lambda = 5.0$, $\\mu = 10.0$, $b = 50$, $T = 20000$.\n\nRequired Final Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must be an ordered list in the following order:\n$[\\hat{\\lambda}_{\\mathrm{eff}}, \\hat{p}_{\\mathrm{balk}}, \\hat{\\rho}, \\widehat{E}[Q], \\widehat{E}[W], \\widehat{E}[S], \\widehat{\\theta}, \\mathrm{stable}]$.\nAggregate all five test case lists into a single list, so the final output is\n$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$\nprinted on a single line.",
            "solution": "The user wants to solve the problem. I will first validate the problem statement.\n\n### Step 1: Extract Givens\n- **System Model**: Single-server queueing system with balking.\n- **Arrival Process**: Poisson process with rate $\\lambda$ ($\\mathrm{s}^{-1}$). Inter-arrival times are independent and exponentially distributed.\n- **Service Process**: Service times are independent and exponentially distributed with rate $\\mu$ ($\\mathrm{s}^{-1}$). Single server.\n- **State Variable**: $Q(t)$ is the total number of customers in the system at time $t$.\n- **Balking Rule**: An arriving customer is admitted only if $Q(t)  b$, where $b$ is a finite capacity threshold. If $Q(t) \\ge b$, the customer balks.\n- **Special Cases**: If $b = \\infty$, the system is a standard $M/M/1$ queue. If $b$ is finite, it is an $M/M/1/b$ queue.\n- **Simulation Parameters**:\n    - Simulation horizon: $T$ seconds.\n    - Pseudorandom number generator base seed: $s=314159$.\n    - Seeding rule: For test case index $i$ (starting from $i=0$), use seed $s+i$.\n- **Performance Metrics to Compute**:\n    1.  $\\hat{\\lambda}_{\\mathrm{eff}}$: Estimated effective admitted arrival rate ($\\mathrm{s}^{-1}$) = (number of admitted arrivals) / $T$.\n    2.  $\\hat{p}_{\\mathrm{balk}}$: Estimated balking fraction = (number of balked arrivals) / (total arrival attempts).\n    3.  $\\hat{\\rho}$: Estimated server utilization = (fraction of time server is busy over $[0,T]$).\n    4.  $\\widehat{E}[Q]$: Estimated time-average number in system = $(\\int_0^T Q(t) dt) / T$.\n    5.  $\\widehat{E}[W]$: Estimated average waiting time in queue (s) = average of $W_i$ for admitted customers who start service within $[0,T]$.\n    6.  $\\widehat{E}[S]$: Estimated average sojourn time (s) = average of $S_i$ for customers who depart within $[0,T]$.\n    7.  $\\widehat{\\theta}$: Estimated throughput ($\\mathrm{s}^{-1}$) = (number of departures within $[0,T]$) / $T$.\n    8.  $\\mathrm{stable}$: Stability indicator (boolean) = `True` if $b$ is finite or ($\\lambda  \\mu$ and $b=\\infty$), `False` otherwise.\n- **Methodology**: Event-driven simulation. Do not use analytical formulas for stationary distributions.\n- **Test Suite**:\n    1.  Case A: $\\lambda = 0.8$, $\\mu = 1.0$, $b = \\infty$, $T = 20000$.\n    2.  Case B: $\\lambda = 1.2$, $\\mu = 1.0$, $b = 5$, $T = 20000$.\n    3.  Case C: $\\lambda = 2.0$, $\\mu = 1.0$, $b = 1$, $T = 20000$.\n    4.  Case D: $\\lambda = 1.0$, $\\mu = 1.0$, $b = 0$, $T = 20000$.\n    5.  Case E: $\\lambda = 5.0$, $\\mu = 10.0$, $b = 50$, $T = 20000$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem describes the simulation of an $M/M/1/b$ queue, a canonical model in queueing theory, which is a well-established field within applied probability and operations research. The methodology of event-driven simulation is the standard and correct approach for analyzing such stochastic systems. All concepts are firmly based on established scientific and mathematical principles.\n2.  **Well-Posed**: The problem is specified with complete and unambiguous information. All necessary parameters ($\\lambda$, $\\mu$, $b$, $T$) and the seeding protocol for the random number generator are provided for each test case. The definitions of the performance metrics are precise. This structure ensures that for a given implementation of the specified random number generator, a unique and meaningful set of results can be obtained.\n3.  **Objective**: The problem statement is written in formal, objective language, free of any subjective or opinion-based claims. All terms are standard and rigorously defined.\n4.  **No Flaws**: The problem is free of the flaws listed in the instructions. It is scientifically sound, fully formalizable, complete, and well-structured. It is a non-trivial computational task that accurately reflects a standard problem in stochastic simulation.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A complete, reasoned solution will be provided.\n\n---\n\nThe problem requires the implementation of an event-driven simulation for a single-server queueing system with balking, known as an $M/M/1/b$ queue. The simulation will be used to estimate several key performance metrics over a finite time horizon $T$.\n\n**1. System Modeling and Simulation Approach**\n\nThe system state is characterized by $Q(t)$, the number of customers in the system. The state changes only at discrete points in time corresponding to two types of events: customer arrivals and service completions (departures). This makes event-driven simulation the natural and efficient methodology. We maintain a simulation clock and an event calendar containing the times of the next scheduled arrival and departure. The simulation proceeds by advancing the clock to the time of the next imminent event.\n\nThe fundamental properties of the Poisson arrival process and exponential service times are crucial.\n- Inter-arrival times are independent and identically distributed (i.i.d.) exponential random variables with mean $1/\\lambda$. This allows us to schedule the next arrival event at time $t_{current} + \\Delta t_A$, where $\\Delta t_A \\sim \\text{Exponential}(\\lambda)$.\n- Service times are i.i.d. exponential random variables with mean $1/\\mu$. The memoryless property of the exponential distribution simplifies the logic: the remaining service time for a customer in service is independent of how long they have already been in service. Thus, when a customer begins service at time $t_{start}$, we can schedule their departure at $t_{start} + S$, where $S \\sim \\text{Exponential}(\\mu)$.\n\n**2. Simulation Algorithm**\n\nThe simulation algorithm is structured as follows:\n\n**Initialization:**\n1.  Initialize the simulation clock, $t_{clock}$, to $0$.\n2.  Initialize the system state: number of customers in the system, $N$, to $0$.\n3.  Initialize statistical accumulators to $0$: number of arrivals (attempted, admitted, balked), number of departures, total server busy time, area under the $Q(t)$ curve, total waiting time, and total sojourn time.\n4.  Initialize an empty First-In-First-Out (FIFO) queue, `customer_arrivals`, to store the arrival times of customers currently in the system. This is essential for calculating waiting and sojourn times.\n5.  Schedule the first arrival: generate an inter-arrival time $\\Delta t_A \\sim \\text{Exponential}(\\lambda)$ and set the next arrival time, $t_{arrival}$, to $t_{clock} + \\Delta t_A$.\n6.  Set the next departure time, $t_{departure}$, to infinity, as the system is initially empty and the server is idle.\n\n**Main Simulation Loop:**\nThe loop continues as long as the next event time is less than the simulation horizon $T$.\n\n1.  Identify the next event: $t_{next\\_event} = \\min(t_{arrival}, t_{departure})$.\n2.  If $t_{next\\_event} \\ge T$, exit the loop.\n3.  Update time-averaged statistics: The state $N$ has been constant during the interval $[t_{last\\_event}, t_{next\\_event}]$.\n    - Update area under $Q(t)$: $\\text{Area}[Q] \\leftarrow \\text{Area}[Q] + N \\times (t_{next\\_event} - t_{clock})$.\n    - Update server busy time: If $N > 0$, $\\text{BusyTime} \\leftarrow \\text{BusyTime} + (t_{next\\_event} - t_{clock})$.\n4.  Advance the clock: $t_{clock} \\leftarrow t_{next\\_event}$.\n5.  Process the event:\n    - **If $t_{clock} = t_{arrival}$ (Arrival Event):**\n        a. Increment the total attempted arrivals counter.\n        b. Check the balking condition: If $N  b$, the customer is admitted.\n            i. Increment admitted arrivals counter.\n            ii. Add the current time, $t_{clock}$, to the `customer_arrivals` queue.\n            iii. Increment the number in system: $N \\leftarrow N + 1$.\n            iv. If the server was idle ($N$ was $0$), the customer starts service immediately. Their waiting time is $0$. Increment the count of customers who started service and schedule a departure: generate service time $S \\sim \\text{Exponential}(\\mu)$ and set $t_{departure} = t_{clock} + S$.\n        c. If $N \\ge b$, the customer balks. Increment the balked arrivals counter. $N$ remains unchanged.\n        d. Schedule the next arrival: generate $\\Delta t_A \\sim \\text{Exponential}(\\lambda)$ and set $t_{arrival} = t_{clock} + \\Delta t_A$.\n    - **If $t_{clock} = t_{departure}$ (Departure Event):**\n        a. Increment the departures counter.\n        b. Retrieve the arrival time of the departing customer by removing the head of the `customer_arrivals` queue. Calculate their sojourn time $S_i = t_{clock} - (\\text{arrival time})$. Add $S_i$ to the total sojourn time accumulator and increment the count of departed customers.\n        c. Decrement the number in system: $N \\leftarrow N - 1$.\n        d. If the system is now empty ($N=0$), the server becomes idle. Set $t_{departure} = \\infty$.\n        e. If the system is not empty ($N>0$), the next customer in the queue begins service.\n            i. Their waiting time is $W_i = t_{clock} - (\\text{arrival time of new customer})$. Add $W_i$ to the total waiting time accumulator and increment the count of customers who started service.\n            ii. Schedule their departure: generate $S \\sim \\text{Exponential}(\\mu)$ and set $t_{departure} = t_{clock} + S$.\n\n**Termination and Final Calculations:**\n1.  After the loop terminates, the last event occurred at $t_{clock}  T$. We must account for the final interval $[t_{clock}, T]$ during which the state $N$ remained constant. Update $\\text{Area}[Q]$ and $\\text{BusyTime}$ for this final duration.\n2.  Compute the final metrics based on their definitions using the accumulated statistics and the horizon $T$:\n    - $\\hat{\\lambda}_{\\mathrm{eff}} = (\\text{admitted arrivals}) / T$\n    - $\\hat{p}_{\\mathrm{balk}} = (\\text{balked arrivals}) / (\\text{total arrivals})$\n    - $\\hat{\\rho} = (\\text{total busy time}) / T$\n    - $\\widehat{E}[Q] = (\\text{Area}[Q]) / T$\n    - $\\widehat{E}[W] = (\\text{total wait time}) / (\\text{customers who started service})$\n    - $\\widehat{E}[S] = (\\text{total sojourn time}) / (\\text{departed customers})$\n    - $\\widehat{\\theta} = (\\text{departures}) / T$\n    - $\\mathrm{stable}$ is `True` if $b  \\infty$ or $\\lambda  \\mu$.\n    Special care is taken for cases where denominators are zero (e.g., no customers departed), in which case the corresponding average is reported as $0$.\n\nThis rigorous, event-by-event simulation approach correctly models the stochastic dynamics of the $M/M/1/b$ system and allows for the empirical estimation of the required performance metrics without relying on analytical steady-state formulas, as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n\n    def simulate(lambda_, mu, b, T, seed):\n        \"\"\"\n        Performs an event-driven simulation of an M/M/1/b queue.\n\n        Args:\n            lambda_ (float): Arrival rate.\n            mu (float): Service rate.\n            b (float or int): System capacity threshold for balking.\n            T (int): Simulation horizon time.\n            seed (int): Seed for the random number generator.\n\n        Returns:\n            list: A list containing the eight calculated performance metrics.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n\n        # State variables\n        clock = 0.0\n        num_in_system = 0\n        time_next_arrival = rng.exponential(scale=1.0/lambda_) if lambda_  0 else float('inf')\n        time_next_departure = float('inf')\n        \n        # FIFO queue for customers in system, storing their arrival times\n        customer_arrival_times = collections.deque()\n\n        # Statistical accumulators\n        last_event_time = 0.0\n        total_arrivals_attempted = 0\n        num_admitted = 0\n        num_balked = 0\n        num_departures = 0\n        \n        total_busy_time = 0.0\n        area_num_in_system = 0.0\n        \n        total_sojourn_time = 0.0\n        num_customers_sojourned = 0\n        \n        total_wait_time = 0.0\n        num_customers_waited = 0\n\n        # Main simulation loop\n        while time_next_arrival  T or time_next_departure  T:\n            \n            next_event_time = min(time_next_arrival, time_next_departure)\n            \n            # Update time-averaged statistics for the interval since the last event\n            time_since_last_event = next_event_time - last_event_time\n            area_num_in_system += num_in_system * time_since_last_event\n            if num_in_system  0:\n                total_busy_time += time_since_last_event\n\n            clock = next_event_time\n\n            # Process the next event\n            if clock == time_next_arrival:  # Arrival Event\n                total_arrivals_attempted += 1\n                \n                if num_in_system  b:\n                    # Customer is admitted\n                    num_admitted += 1\n                    customer_arrival_times.append(clock)\n                    num_in_system += 1\n                    \n                    if num_in_system == 1:  # Server was idle\n                        # Customer starts service immediately, waiting time is 0\n                        total_wait_time += 0.0\n                        num_customers_waited += 1\n                        \n                        service_time = rng.exponential(scale=1.0/mu) if mu  0 else float('inf')\n                        time_next_departure = clock + service_time\n                else:\n                    # Customer balks\n                    num_balked += 1\n                \n                # Schedule next arrival\n                inter_arrival_time = rng.exponential(scale=1.0/lambda_) if lambda_  0 else float('inf')\n                time_next_arrival = clock + inter_arrival_time\n                \n            else:  # Departure Event (clock == time_next_departure)\n                num_departures += 1\n                num_in_system -= 1\n                \n                # Record sojourn time for the departing customer\n                arrival_time_of_departed = customer_arrival_times.popleft()\n                sojourn_time = clock - arrival_time_of_departed\n                total_sojourn_time += sojourn_time\n                num_customers_sojourned += 1\n                \n                if num_in_system  0: # A customer from the queue starts service\n                    # Record waiting time for the customer starting service\n                    arrival_time_new_service = customer_arrival_times[0]\n                    wait_time = clock - arrival_time_new_service\n                    total_wait_time += wait_time\n                    num_customers_waited += 1\n                    \n                    # Schedule new departure\n                    service_time = rng.exponential(scale=1.0/mu) if mu  0 else float('inf')\n                    time_next_departure = clock + service_time\n                else: # System becomes empty\n                    time_next_departure = float('inf')\n\n            last_event_time = clock\n            \n        # Account for the final interval from the last event time to T\n        final_interval = T - last_event_time\n        if final_interval  0:\n            area_num_in_system += num_in_system * final_interval\n            if num_in_system  0:\n                total_busy_time += final_interval\n\n        # Calculate final performance metrics\n        eff_arrival_rate = num_admitted / T\n        balk_fraction = num_balked / total_arrivals_attempted if total_arrivals_attempted  0 else 0.0\n        utilization = total_busy_time / T\n        avg_num_in_system = area_num_in_system / T\n        avg_wait_time = total_wait_time / num_customers_waited if num_customers_waited  0 else 0.0\n        avg_sojourn_time = total_sojourn_time / num_customers_sojourned if num_customers_sojourned  0 else 0.0\n        throughput = num_departures / T\n        \n        is_stable = (b != float('inf')) or (lambda_  mu)\n\n        return [\n            eff_arrival_rate, balk_fraction, utilization,\n            avg_num_in_system, avg_wait_time, avg_sojourn_time,\n            throughput, is_stable\n        ]\n\n    # Define the test cases from the problem statement.\n    base_seed = 314159\n    test_cases = [\n        (0.8, 1.0, float('inf'), 20000), # Case A\n        (1.2, 1.0, 5, 20000),          # Case B\n        (2.0, 1.0, 1, 20000),          # Case C\n        (1.0, 1.0, 0, 20000),          # Case D\n        (5.0, 10.0, 50, 20000),         # Case E\n    ]\n    \n    all_results = []\n    for i, (lambda_val, mu_val, b_val, T_val) in enumerate(test_cases):\n        case_seed = base_seed + i\n        result = simulate(lambda_val, mu_val, b_val, T_val, case_seed)\n        all_results.append(result)\n        \n    formatted_results = []\n    for res in all_results:\n        # Format each inner list as a string without spaces\n        formatted_res = f\"[{','.join(map(str, res))}]\"\n        formatted_results.append(formatted_res)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a working simulator in hand, we can now use it as a computational microscope to explore deeper theoretical principles. This exercise  centers on the celebrated PASTA property (Poisson Arrivals See Time Averages), a cornerstone concept that explains why the Poisson process is so unique in stochastic modeling. You will design an experiment to empirically test this property by comparing the system's state distribution from an outside observer's perspective (time averages) with what an arriving customer sees (arrival-epoch averages), and discover why this equivalence breaks down for non-Poisson arrivals.",
            "id": "3343617",
            "problem": "Consider a single-server queue operating under First-Come First-Served (FCFS) discipline. Let the system state be the number of customers in the system (in service plus in queue) at time $t$, denoted by $Q(t)$. Service times are independent and identically distributed exponential random variables with rate parameter $\\mu$ in $1/\\mathrm{s}$, independent of the arrival process and all history. The arrival process is either a Poisson process with rate $\\lambda$ in $1/\\mathrm{s}$ or a renewal process with a specified interarrival time distribution having mean $1/\\lambda$ seconds.\n\nTask 1 (Statement of Poisson Arrivals See Time Averages (PASTA)): State the Poisson Arrivals See Time Averages (PASTA) property formally for Poisson arrivals, in terms of $Q(t)$ and the distribution observed at arrival epochs. Explicitly define the arrival-epoch observation as $Q(T_n^-)$, where $T_n$ is the time of the $n$-th arrival and $Q(T_n^-)$ denotes the left-limit just before the $n$-th arrival enters the system.\n\nTask 2 (Design and implement a simulation to empirically confirm PASTA): Design and implement an event-driven stochastic simulation that:\n- Simulates the continuous-time evolution of $Q(t)$ for a single-server FCFS queue with exponential service times of rate $\\mu$ in $1/\\mathrm{s}$.\n- For the arrival process, supports three regimes: Poisson with rate $\\lambda$ in $1/\\mathrm{s}$, deterministic interarrival times equal to $1/\\lambda$ seconds, and Erlang-$2$ interarrival times (Gamma with shape parameter $2$ and rate parameter adjusted to give mean $1/\\lambda$ seconds).\n- Uses a warm-up of $N_{\\mathrm{warm}}$ arrivals to reduce transient bias, then collects statistics over the next $N$ arrivals.\n\nDefine the empirical time-average distribution and the empirical arrival-epoch distribution over states as follows. For any integer state $k \\ge 0$:\n- The empirical time-average probability is\n$$\n\\hat{p}_k^{\\mathrm{time}} = \\frac{1}{T_{\\mathrm{obs}}} \\int_{t_0}^{t_0 + T_{\\mathrm{obs}}} \\mathbf{1}\\{Q(t) = k\\}\\, dt,\n$$\nwhere $t_0$ is the time at which data collection starts (immediately after the warm-up ends) and $T_{\\mathrm{obs}}$ is the total observation time in seconds accumulated during the $N$ arrivals used for data collection.\n- The empirical arrival-epoch probability is\n$$\n\\hat{p}_k^{\\mathrm{arr}} = \\frac{1}{N} \\sum_{n=1}^{N} \\mathbf{1}\\{Q(T_{n,\\mathrm{obs}}^-) = k\\},\n$$\nwhere $T_{n,\\mathrm{obs}}$ is the time of the $n$-th arrival counted in the observation window (i.e., after the warm-up).\n\nTo quantify agreement between the two empirical distributions, compute the $\\ell_1$ distance defined as\n$$\nD = \\sum_{k \\in \\mathcal{K}} \\left| \\hat{p}_k^{\\mathrm{time}} - \\hat{p}_k^{\\mathrm{arr}} \\right|,\n$$\nwhere $\\mathcal{K}$ is the union of states observed either in time-average measurement or at arrival epochs during the observation window. $D$ is dimensionless.\n\nTask 3 (Explain failure conditions): Explain, in terms of fundamental stochastic principles, when and why PASTA fails for non-Poisson arrival processes.\n\nPhysical and numerical units: Time must be treated in seconds, arrival rates $\\lambda$ and service rates $\\mu$ in $1/\\mathrm{s}$. All output values must be dimensionless real numbers.\n\nTest suite and required output:\nUse the following three test cases, each specified by $(\\text{arrival type}, \\lambda, \\mu, N_{\\mathrm{warm}}, N, \\text{seed})$, with time expressed in seconds and rates in $1/\\mathrm{s}$:\n1. Case $1$: $(\\text{Poisson}, \\lambda = 0.8, \\mu = 1.0, N_{\\mathrm{warm}} = 10000, N = 100000, \\text{seed} = 12345)$.\n2. Case $2$: $(\\text{Poisson}, \\lambda = 0.95, \\mu = 1.0, N_{\\mathrm{warm}} = 10000, N = 100000, \\text{seed} = 54321)$.\n3. Case $3$: $(\\text{Deterministic}, \\lambda = 0.8, \\mu = 1.0, N_{\\mathrm{warm}} = 10000, N = 100000, \\text{seed} = 67890)$.\n\nFor the Erlang-$2$ interarrival option, the shape is $2$ and the rate is chosen so the mean interarrival time is $1/\\lambda$ seconds; however, this option is not used in the test suite and is provided to generalize your implementation.\n\nYour program should produce a single line of output containing the $\\ell_1$ distances $D$ for the three cases in the given order, as a comma-separated list enclosed in square brackets, for example, $[d_1,d_2,d_3]$. Each $d_i$ must be a floating-point number. No additional text should be printed.",
            "solution": "The user has provided a multi-part problem concerning the Poisson Arrivals See Time Averages (PASTA) property in queueing theory. The tasks involve a formal statement of the property, the design and implementation of a stochastic simulation to verify it empirically, and an explanation for its failure under non-Poisson arrival conditions. The problem is well-defined, scientifically sound, and internally consistent.\n\n### Task 1: Formal Statement of the PASTA Property\n\nThe PASTA property is a fundamental result in queueing theory that connects the perspective of an outside observer watching the system at a random moment in time with the perspective of a customer arriving at the system. It applies specifically to systems with a Poisson arrival process.\n\nFormally, let $Q(t)$ be the number of customers in the system at time $t$. The long-run time-average (or steady-state) probability that the system is in state $k$ is given by:\n$$\n\\pi_k = \\lim_{t \\to \\infty} P(Q(t) = k)\n$$\nprovided this limit exists.\n\nNow, consider the sequence of arrival times $\\{T_n\\}_{n \\ge 1}$. Let $Q(T_n^-)$ be the number of customers in the system as seen by the $n$-th arrival, evaluated at the left-limit just before the arrival occurs. The long-run arrival-epoch probability that an arriving customer finds the system in state $k$ is given by:\n$$\na_k = \\lim_{n \\to \\infty} P(Q(T_n^-) = k)\n$$\nprovided this limit exists.\n\nThe PASTA property states that if the arrival process is a Poisson process, then the two distributions are identical:\n$$\na_k = \\pi_k \\quad \\text{for all states } k \\ge 0\n$$\nIn essence, **P**oisson **A**rrivals **S**ee **T**ime **A**verages. This equivalence arises from the memoryless property of the Poisson process. The probability of an arrival occurring in a small interval $(t, t+dt]$ is $\\lambda dt$, independent of the history of the process and, critically, independent of the current state of the system $Q(t)$. Therefore, arrivals do not \"time\" themselves to coincide with periods of high or low congestion; they effectively sample the system state at truly random moments, yielding the same statistical distribution as a continuous-time observer.\n\n### Task 2: Simulation Design and Implementation\n\nTo empirically investigate the PASTA property, we will construct an event-driven simulation of a single-server queue.\n\n**Core Components of the Simulation:**\n1.  **Simulation Clock ($t_{sim}$):** A variable that tracks the current time in the simulation. It does not advance continuously but jumps from one event time to the next.\n2.  **System State ($N_{sys}$):** An integer variable representing the number of customers in the system, $Q(t)$.\n3.  **Event List (EL):** A priority queue that stores future events, ordered by their scheduled time of occurrence. Each event is a tuple `(event_time, event_type)`, e.g., $(1.23, \\text{ARRIVAL})$.\n\n**Event-Driven Algorithm:**\nThe simulation proceeds by repeatedly executing the following steps:\n1.  Extract the next chronological event from the Event List.\n2.  Advance the simulation clock $t_{sim}$ to the time of this event.\n3.  Update statistics based on the time elapsed since the last event.\n4.  Process the event, which involves changing the system state $N_{sys}$ and scheduling new, future events.\n\n**Event Handling Logic:**\n-   **ARRIVAL Event:**\n    1.  Collect arrival-epoch statistics if within the observation window: record the system state $N_{sys}$ just before this new arrival is added.\n    2.  Increment the system state: $N_{sys} \\leftarrow N_{sys} + 1$.\n    3.  If the system was previously empty ($N_{sys}$ was $0$), the arriving customer immediately enters service. A new DEPARTURE event is scheduled for time $t_{sim} + \\text{service_time}$, where the service time is a random variate drawn from an exponential distribution with rate $\\mu$.\n    4.  Schedule the next ARRIVAL event at time $t_{sim} + \\text{interarrival_time}$. The interarrival time is a random variate drawn from the specified arrival process distribution (Exponential for Poisson, a constant for Deterministic, or Gamma for Erlang).\n\n-   **DEPARTURE Event:**\n    1.  Decrement the system state: $N_{sys} \\leftarrow N_{sys} - 1$.\n    2.  If customers are still waiting in the queue ($N_{sys} > 0$), the next customer in line immediately enters service. A new DEPARTURE event is scheduled for time $t_{sim} + \\text{service_time}$.\n\n**Statistics Collection:**\nThe simulation runs for $N_{\\mathrm{warm}}$ arrivals (warm-up phase) to mitigate transient bias, followed by $N$ arrivals (observation phase).\n-   **Warm-up Phase:** The simulation runs, but no statistics are collected.\n-   **Observation Phase:** This phase begins at the time of the $(N_{\\mathrm{warm}}+1)$-th arrival, let's call it $t_0$, and ends at the time of the $(N_{\\mathrm{warm}}+N)$-th arrival, let's call it $t_f$. The total observation time is $T_{\\mathrm{obs}} = t_f - t_0$.\n    -   **Empirical Arrival-Epoch Probability ($\\hat{p}_k^{\\mathrm{arr}}$):** For each of the $N$ arrivals within the observation phase, we record the system state $N_{sys}$ at the instant of arrival. We maintain a count, $C_k^{\\mathrm{arr}}$, for each state $k$. After the simulation, $\\hat{p}_k^{\\mathrm{arr}} = C_k^{\\mathrm{arr}} / N$.\n    -   **Empirical Time-Average Probability ($\\hat{p}_k^{\\mathrm{time}}$):** We maintain an array or dictionary, $T_k^{\\mathrm{state}}$, which stores the total time the system has spent in each state $k$. Whenever an event occurs at time $t_{new}$, the time elapsed since the previous event at $t_{old}$, which is $\\Delta t = t_{new} - t_{old}$, is added to the entry for the state that was active during that interval. After the simulation, $\\hat{p}_k^{\\mathrm{time}} = T_k^{\\mathrm{state}} / T_{\\mathrm{obs}}$.\n\n**Quantifying Agreement:**\nThe discrepancy between the two empirical distributions is measured by the $\\ell_1$ distance:\n$$\nD = \\sum_{k \\in \\mathcal{K}} \\left| \\hat{p}_k^{\\mathrm{time}} - \\hat{p}_k^{\\mathrm{arr}} \\right|\n$$\nwhere $\\mathcal{K}$ is the set of all unique states observed during the simulation's observation phase. A value of $D$ near $0$ indicates strong agreement, empirically confirming the PASTA property.\n\n### Task 3: Failure of PASTA for Non-Poisson Arrivals\n\nThe PASTA property fails for non-Poisson arrival processes because such processes possess \"memory,\" which creates a statistical correlation between the arrival instants and the state of the queueing system. An arriving customer's view is no longer a \"random sample\" of the system's evolution.\n\n**Mechanism of Failure:**\nThe key is the distribution of interarrival times. For a Poisson process, interarrival times follow an exponential distribution, which is memoryless. For any other renewal process, the interarrival time distribution is not memoryless. This lack of memorylessness is what invalidates PASTA. We can analyze this through the squared coefficient of variation of the interarrival times, $c_A^2$.\n-   **Poisson Process:** The exponential distribution has $c_A^2 = 1$. This is the PASTA case.\n-   **Less Variable Arrivals ($c_A^2  1$):** This includes **Deterministic** arrivals ($c_A^2=0$) and **Erlang** arrivals ($c_A^2 = 1/k  1$ for Erlang-$k$). These processes are more \"regular\" or \"orderly\" than a Poisson process. The regularity tends to space out arrivals, giving the server more opportunity to complete service and reduce the queue length between successive arrivals. Consequently, an arrival is more likely to find the system in a less congested state (or empty) compared to an observer arriving at a random moment in time. This leads to an \"arrival-time bias\" where the arrival-epoch distribution is skewed towards lower queue lengths: $a_k > \\pi_k$ for small $k$ and $a_k  \\pi_k$ for large $k$. Therefore, $a_k \\ne \\pi_k$.\n-   **More Variable Arrivals ($c_A^2 > 1$):** This includes hyperexponential arrivals. These processes are more \"bursty\" than Poisson. Arrivals tend to come in clumps. An arrival is likely to occur shortly after a previous one, before the server has had time to clear the work. This means an arrival is more likely to find the system in a more congested state than a random-time observer would. In this case, the arrival-epoch distribution is skewed towards higher queue lengths: $a_k  \\pi_k$ for small $k$ and $a_k > \\pi_k$ for large $k$. Again, $a_k \\ne \\pi_k$.\n\nIn summary, any deviation from the memoryless property of the Poisson process (quantified by $c_A^2 \\ne 1$) introduces a dependency between the arrival stream and the system state, causing PASTA to fail. The simulation for the deterministic case (Case 3) is expected to yield a non-negligible $\\ell_1$ distance $D$, demonstrating this failure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\nfrom collections import defaultdict\n\ndef simulate_queue(arrival_type, lam, mu, n_warm, n_obs, seed):\n    \"\"\"\n    Simulates a single-server FCFS queue and calculates the L1 distance\n    between time-average and arrival-epoch state distributions.\n    \n    Args:\n        arrival_type (str): 'poisson', 'deterministic', or 'erlang2'.\n        lam (float): Arrival rate.\n        mu (float): Service rate.\n        n_warm (int): Number of warm-up arrivals.\n        n_obs (int): Number of observation arrivals.\n        seed (int): Seed for the random number generator.\n        \n    Returns:\n        float: The L1 distance D.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    def generate_interarrival_time():\n        if arrival_type == 'poisson':\n            return rng.exponential(scale=1.0 / lam)\n        elif arrival_type == 'deterministic':\n            return 1.0 / lam\n        elif arrival_type == 'erlang2':\n            # Erlang-2 is Gamma with shape=2. Mean = shape/rate.\n            # We want mean = 1/lam, so 2/rate = 1/lam - rate = 2*lam.\n            # Numpy's scale is 1/rate.\n            return rng.gamma(shape=2, scale=1.0 / (2.0 * lam))\n        else:\n            raise ValueError(\"Unknown arrival type\")\n\n    def generate_service_time():\n        return rng.exponential(scale=1.0 / mu)\n\n    # Simulation state variables\n    current_time = 0.0\n    last_event_time = 0.0\n    num_in_system = 0\n    event_list = []\n\n    # Statistics collectors\n    time_in_state = defaultdict(float)\n    arrivals_at_state = defaultdict(int)\n    \n    # Simulation control\n    num_arrivals_processed = 0\n    total_arrivals_to_process = n_warm + n_obs\n    \n    t_start_obs = 0.0\n    t_end_obs = 0.0\n\n    # Schedule the first arrival\n    heapq.heappush(event_list, (generate_interarrival_time(), 'ARRIVAL'))\n\n    while event_list:\n        event_time, event_type = heapq.heappop(event_list)\n        \n        # Calculate time delta since last event\n        dt = event_time - last_event_time\n        \n        # If in observation phase, update time-in-state statistics\n        # The check `num_arrivals_processed = n_warm` ensures we only collect\n        # stats after the warmup phase is completed.\n        if num_arrivals_processed = n_warm and dt  0:\n            time_in_state[num_in_system] += dt\n\n        current_time = event_time\n        last_event_time = event_time\n        \n        # --- Event Processing ---\n        if event_type == 'ARRIVAL':\n            # Collect arrival-epoch stats if in observation period\n            if num_arrivals_processed = n_warm:\n                arrivals_at_state[num_in_system] += 1\n\n            # Update state\n            num_in_system += 1\n            \n            # If server was idle, start service and schedule a departure\n            if num_in_system == 1:\n                departure_time = current_time + generate_service_time()\n                heapq.heappush(event_list, (departure_time, 'DEPARTURE'))\n            \n            num_arrivals_processed += 1\n            \n            # Start of observation period\n            if num_arrivals_processed == n_warm:\n                t_start_obs = current_time\n            \n            # End of simulation run\n            if num_arrivals_processed == total_arrivals_to_process:\n                t_end_obs = current_time\n                break\n\n            # Schedule next arrival\n            next_arrival_time = current_time + generate_interarrival_time()\n            heapq.heappush(event_list, (next_arrival_time, 'ARRIVAL'))\n\n        elif event_type == 'DEPARTURE':\n            # Update state\n            num_in_system -= 1\n            \n            # If queue is not empty, start serving next customer\n            if num_in_system  0:\n                departure_time = current_time + generate_service_time()\n                heapq.heappush(event_list, (departure_time, 'DEPARTURE'))\n\n    # --- Post-Processing and Calculation of D ---\n    total_obs_time = t_end_obs - t_start_obs\n    \n    # Time-average probabilities\n    p_time = defaultdict(float)\n    if total_obs_time  0:\n        for k, T_k in time_in_state.items():\n            p_time[k] = T_k / total_obs_time\n            \n    # Arrival-epoch probabilities\n    p_arr = defaultdict(float)\n    if n_obs  0:\n        for k, C_k in arrivals_at_state.items():\n            p_arr[k] = C_k / n_obs\n            \n    # Calculate L1 distance\n    all_states = set(p_time.keys()) | set(p_arr.keys())\n    dist = 0.0\n    for k in all_states:\n        dist += abs(p_time[k] - p_arr[k])\n        \n    return dist\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'arrival_type': 'poisson', 'lam': 0.8, 'mu': 1.0, 'n_warm': 10000, 'n_obs': 100000, 'seed': 12345},\n        {'arrival_type': 'poisson', 'lam': 0.95, 'mu': 1.0, 'n_warm': 10000, 'n_obs': 100000, 'seed': 54321},\n        {'arrival_type': 'deterministic', 'lam': 0.8, 'mu': 1.0, 'n_warm': 10000, 'n_obs': 100000, 'seed': 67890},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = simulate_queue(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The final practice addresses a critical aspect of any simulation study: ensuring the statistical validity of your results. Simply running a simulation and calculating an average is not enough; we must be confident in the precision and independence of our observations. This exercise  introduces the powerful regenerative method, which allows us to collect independent and identically distributed (i.i.d.) data points from a single simulation run. You will learn to identify these \"regenerative cycles\" and apply statistical tests to verify their independence, a fundamental step for constructing valid confidence intervals and drawing rigorous conclusions.",
            "id": "3343660",
            "problem": "Implement an event-driven simulator of a single-server queue that detects regeneration and uses separate random number streams for arrivals and services. A regenerative cycle is defined to be the busy period that starts when an arrival finds the system empty and ends when the system becomes empty again. For each run, collect a sequence of busy-period lengths and test whether these cycle lengths are independent by estimating the sample cross-correlation at lag one (which coincides with the sample autocorrelation at lag one). Independence is assessed by a large-sample normal approximation for the lag-one autocorrelation under the null hypothesis of independence.\n\nStart from the following fundamental base:\n- The arrival process is a Poisson process of rate $\\lambda$, so interarrival times are independent and identically distributed (i.i.d.) exponential random variables with mean $1/\\lambda$.\n- Services proceed under First-Come, First-Served (FCFS) discipline at a single server.\n- For test cases that assume independence of cycles, service times are i.i.d. exponential with rate $\\mu$ and are independent of arrivals.\n- Regeneration occurs at arrivals that find the system empty; the time interval between such consecutive regenerations is a busy period.\n- Under i.i.d. primitives and independence between arrival and service streams, busy periods form an i.i.d. sequence.\n- To evaluate independence empirically, use the sample autocorrelation at lag one of the sequence $\\{X_i\\}_{i=1}^n$ of busy-period lengths:\n$$\nr_1 \\equiv \\frac{\\sum_{i=2}^{n} \\left(X_i - \\bar{X}\\right)\\left(X_{i-1} - \\bar{X}\\right)}{\\sum_{i=1}^{n} \\left(X_i - \\bar{X}\\right)^2},\n$$\nwhere $\\bar{X}$ is the sample mean. Under the null hypothesis of independence with finite variance, for large $n$,\n$$\n\\sqrt{n}\\, r_1 \\approx \\mathcal{N}(0,1),\n$$\nso a two-sided level-$\\alpha$ test rejects independence if $\\left|r_1\\right|  z_{1-\\alpha/2}/\\sqrt{n}$, where $z_{1-\\alpha/2}$ is the standard normal quantile.\n\nYour program must:\n1. Implement an event-driven simulation that detects regeneration and records each busy period length.\n2. Use two statistically independent random number streams: one for arrivals and one for services. Each stream must be explicitly and independently seeded for reproducibility.\n3. For the third test case, intentionally introduce serial dependence into service times across jobs using an autoregressive model on the log scale: let $Z_k$ follow the stationary Autoregressive model of order one (AR(1)) given by $Z_k = \\phi Z_{k-1} + \\sqrt{1-\\phi^2}\\,\\varepsilon_k$, where $\\varepsilon_k \\sim \\mathcal{N}(0,1)$ i.i.d., and define service times by $S_k = \\exp\\left(m + s Z_k\\right)$ where $m$ is chosen so that $\\mathbb{E}[S_k] = 1/\\mu$, i.e., $m = \\log(1/\\mu) - s^2/2$. This creates cross-cycle dependence and should be detectable by the correlation test.\n4. For each test case, compute $r_1$, the number of cycles $n$, and decide whether to accept the independence hypothesis at significance $\\alpha = 0.001$ using the rejection rule $\\left|r_1\\right| \\le z_{1-\\alpha/2}/\\sqrt{n}$ with $z_{1-\\alpha/2} \\approx 3.290526731$.\n5. Return, for each test case, a boolean indicating whether independence is accepted (True means independent cycles are not rejected).\n\nNo physical units are required; treat time in arbitrary consistent units and report unitless statistics. Angles are not used. Percentages are not used.\n\nTest suite parameters:\n- Test case $1$ (happy path, stable and well-mixed): exponential services. Use $\\lambda = 0.8$, $\\mu = 1.5$, target number of cycles $n = 5000$, arrival stream seed $101$, service stream seed $202$.\n- Test case $2$ (boundary condition with heavy traffic but still stable): exponential services. Use $\\lambda = 0.95$, $\\mu = 1.0$, target number of cycles $n = 2000$, arrival stream seed $303$, service stream seed $404$.\n- Test case $3$ (negative control with strong dependence across jobs): lognormal services with AR(1) on the log scale. Use $\\lambda = 0.8$, $\\mu = 1.5$, AR parameter $\\phi = 0.99$, log-scale standard deviation $s = 0.6$, target number of cycles $n = 3000$, arrival stream seed $505$, service stream seed $606$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain one boolean per test case, in the order of the test suite, indicating whether independence is accepted at level $\\alpha = 0.001$. For example, a valid output line looks like: \"[True,True,False]\".",
            "solution": "The problem statement is valid. It is a well-posed, scientifically grounded problem in the field of stochastic simulation, specifically the simulation of queueing systems. It provides all necessary parameters, definitions, and a clear objective, free from ambiguity or contradiction.\n\nThe task is to construct an event-driven simulation for a single-server queueing system, to collect data on the lengths of consecutive busy periods, and to perform a statistical test for the independence of these busy period lengths. A busy period constitutes a regenerative cycle. The simulation and analysis must be conducted for three distinct test cases, which differ in their traffic intensity and service time characteristics.\n\nThe solution is implemented by adhering to the principles of discrete-event simulation and statistical hypothesis testing.\n\n**1. Simulation Model and Event-Driven Logic**\n\nAn event-driven simulation model is advanced by progressing time from one event to the next. For a single-server queue, the only events of interest are customer arrivals and service completions (departures). The state of the system is characterized by a minimal set of variables:\n- The current simulation time, $t$.\n- The number of customers in the system (in service or in queue), $N_{sys}$.\n\nThe simulation is governed by an event calendar, which for this simple system can be maintained with two variables:\n- The time of the next scheduled arrival, $T_{arr}$.\n- The time of the next scheduled departure, $T_{dep}$. If the server is idle, $T_{dep}$ is set to infinity.\n\nThe simulation proceeds as follows:\n1.  Initialize the system to an empty and idle state at $t=0$, with $N_{sys}=0$. Schedule the first arrival.\n2.  Determine the next event by selecting the minimum of $T_{arr}$ and $T_{dep}$. Advance the simulation clock $t$ to this time.\n3.  Process the event:\n    -   If the event is an **Arrival**: Increment $N_{sys}$. Schedule the subsequent arrival by drawing an interarrival time from an exponential distribution with rate $\\lambda$. If the arriving customer finds the system empty ($N_{sys}$ was $0$), the server was idle, so a service completion for this customer is scheduled. This event also marks the beginning of a new busy period.\n    -   If the event is a **Departure**: Decrement $N_{sys}$. If customers are still present in the system ($N_{sys} > 0$), the next customer in the queue immediately enters service, and a new departure event is scheduled. If the system becomes empty ($N_{sys}=0$), the server becomes idle, and $T_{dep}$ is set to infinity. This event marks the end of a busy period.\n\n**2. Random Number Generation**\n\nThe problem correctly mandates the use of separate, independently seeded random number streams for the arrival process and the service process. This is a crucial practice in simulation to ensure that variations in one stochastic process do not confound the analysis of another, and it aids in variance reduction techniques. Two independent pseudo-random number generators are initialized, one for arrivals ($RNG_{arr}$) and one for services ($RNG_{serv}$).\n\n**3. Service Time Models and Regeneration**\n\nA regenerative cycle is defined as a busy period, which starts when an arrival finds the system empty and ends when the system next becomes empty. The length of each such busy period, $X_i$, is recorded.\n\n-   **Cases 1 and 2 (Exponential Service Times)**: Service times are independent and identically distributed (i.i.d.) and drawn from an exponential distribution with rate $\\mu$. In a stable $M/M/1$ queue ($\\rho = \\lambda/\\mu  1$), the theory of regenerative processes guarantees that the sequence of busy period lengths $\\{X_i\\}$ is i.i.d. These cases serve as a control to demonstrate that our test correctly fails to reject the true hypothesis of independence. Service times are generated via the inverse transform method: $S = -\\frac{1}{\\mu} \\log(U)$, where $U$ is a uniform random variate from $RNG_{serv}$.\n\n-   **Case 3 (Correlated Lognormal Service Times)**: To test the detection capability of our method, service times are generated with serial dependence. The logarithm of the service time is modeled as a stationary Autoregressive process of order one (AR(1)):\n    $$\n    Z_k = \\phi Z_{k-1} + \\sqrt{1-\\phi^2}\\,\\varepsilon_k\n    $$\n    where $k$ is the job index, $\\{\\varepsilon_k\\}$ is an i.i.d. sequence of standard normal random variables ($\\mathcal{N}(0,1)$) drawn using $RNG_{serv}$, and $|\\phi|  1$. The state variable $Z_k$ is stationary with mean $0$ and variance $1$. The service time for the $k$-th job, $S_k$, is then given by a lognormal distribution:\n    $$\n    S_k = \\exp(m + s Z_k)\n    $$\n    The parameter $m$ is chosen to ensure the expected service time $\\mathbb{E}[S_k]$ equals the target value of $1/\\mu$. Since for $Z_k \\sim \\mathcal{N}(0,1)$, $\\mathbb{E}[\\exp(sZ_k)] = \\exp(s^2/2)$, the mean is $\\mathbb{E}[S_k] = \\exp(m) \\mathbb{E}[\\exp(sZ_k)] = \\exp(m+s^2/2)$. Setting this to $1/\\mu$ yields $m = \\log(1/\\mu) - s^2/2$. The state of the AR(1) process, $Z_k$, is maintained across all jobs, which intentionally introduces correlation that spans across busy periods. This should lead to a detectable dependence in the sequence of busy period lengths $\\{X_i\\}$.\n\n**4. Statistical Test for Independence**\n\nTo empirically test for independence, the sample autocorrelation at lag one, $r_1$, is computed for the collected sequence of $n$ busy-period lengths $\\{X_i\\}_{i=1}^n$.\nThe null hypothesis is $H_0$: The sequence $\\{X_i\\}$ is i.i.d.\nThe test statistic is:\n$$\nr_1 = \\frac{\\sum_{i=2}^{n} (X_i - \\bar{X})(X_{i-1} - \\bar{X})}{\\sum_{i=1}^{n} (X_i - \\bar{X})^2}\n$$\nwhere $\\bar{X} = \\frac{1}{n} \\sum_{i=1}^n X_i$ is the sample mean. Under $H_0$, for large $n$, the statistic $\\sqrt{n} r_1$ is approximately distributed as a standard normal variable, $\\mathcal{N}(0,1)$.\n\nA two-sided hypothesis test at a significance level $\\alpha$ rejects $H_0$ if the test statistic falls into the tails of the distribution. The decision rule is to not reject independence if $|r_1| \\le z_{1-\\alpha/2}/\\sqrt{n}$, where $z_{1-\\alpha/2}$ is the $(1-\\alpha/2)$-quantile of the standard normal distribution. For the specified $\\alpha = 0.001$, the critical value is $z_{0.9995} \\approx 3.290526731$. The final output for each test case is a boolean value indicating whether the independence hypothesis is accepted (not rejected).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single-server queue simulation to test for independence of busy periods.\n\n    Args:\n        params (dict): A dictionary containing simulation parameters.\n\n    Returns:\n        bool: True if the independence hypothesis is accepted, False otherwise.\n    \"\"\"\n    # Unpack parameters\n    lambda_rate = params['lambda']\n    mu_rate = params['mu']\n    target_cycles = params['n']\n    arrival_seed = params['arrival_seed']\n    service_seed = params['service_seed']\n    service_model = params.get('service_model', 'exponential')\n    \n    # Initialize separate random number generators for arrivals and services\n    rng_arrival = np.random.default_rng(arrival_seed)\n    rng_service = np.random.default_rng(service_seed)\n    \n    # Simulation state variables\n    sim_time = 0.0\n    num_in_system = 0\n    \n    # Event calendar variables\n    time_next_arrival = rng_arrival.exponential(scale=1.0/lambda_rate)\n    time_next_departure = float('inf')\n    \n    # Data collection variables for regenerative analysis\n    busy_periods = []\n    num_cycles_completed = 0\n    start_busy_period_time = 0.0\n    \n    # State for AR(1) correlated service time model\n    z_prev = 0.0\n    if service_model == 'ar1_lognormal':\n        phi = params['phi']\n        s_log = params['s']\n        # Set m such that E[S_k] = 1/mu\n        m_log = np.log(1.0 / mu_rate) - (s_log**2) / 2.0\n    \n    # Main simulation loop\n    while num_cycles_completed  target_cycles:\n        if time_next_arrival  time_next_departure:\n            # --- PROCESS ARRIVAL EVENT ---\n            sim_time = time_next_arrival\n            \n            # Schedule the next arrival\n            time_next_arrival = sim_time + rng_arrival.exponential(scale=1.0/lambda_rate)\n            \n            if num_in_system == 0:\n                # Arrival to an empty system marks the start of a regeneration (busy) period\n                start_busy_period_time = sim_time\n            \n            num_in_system += 1\n            \n            if num_in_system == 1:\n                # The arrival is served immediately as the server was idle\n                if service_model == 'exponential':\n                    service_time = rng_service.exponential(scale=1.0/mu_rate)\n                else:  # 'ar1_lognormal'\n                    epsilon = rng_service.standard_normal()\n                    z_curr = phi * z_prev + np.sqrt(1.0 - phi**2) * epsilon\n                    service_time = np.exp(m_log + s_log * z_curr)\n                    z_prev = z_curr\n                \n                time_next_departure = sim_time + service_time\n                \n        else:\n            # --- PROCESS DEPARTURE EVENT ---\n            sim_time = time_next_departure\n            num_in_system -= 1\n            \n            if num_in_system  0:\n                # The queue is not empty, so start serving the next customer\n                if service_model == 'exponential':\n                    service_time = rng_service.exponential(scale=1.0/mu_rate)\n                else:  # 'ar1_lognormal'\n                    epsilon = rng_service.standard_normal()\n                    z_curr = phi * z_prev + np.sqrt(1.0 - phi**2) * epsilon\n                    service_time = np.exp(m_log + s_log * z_curr)\n                    z_prev = z_curr\n\n                time_next_departure = sim_time + service_time\n            else:\n                # The system has become empty, ending the busy period\n                time_next_departure = float('inf')\n                busy_period_length = sim_time - start_busy_period_time\n                busy_periods.append(busy_period_length)\n                num_cycles_completed += 1\n                \n    # --- POST-SIMULATION ANALYSIS ---\n    X = np.array(busy_periods)\n    n = len(X)\n    X_bar = np.mean(X)\n    \n    # Calculate lag-1 sample autocorrelation (r_1)\n    # r_1 = sum_{i=2 to n}(X_i - X_bar)(X_{i-1} - X_bar) / sum_{i=1 to n}(X_i - X_bar)^2\n    deviations = X - X_bar\n    numerator = np.sum(deviations[1:] * deviations[:-1])\n    denominator = np.sum(deviations**2)\n    \n    r_1 = 0.0 if denominator == 0 else numerator / denominator\n        \n    # Perform the hypothesis test for independence\n    # H_0: The busy period lengths are independent.\n    # Reject H_0 if |r_1|  z_{1-alpha/2} / sqrt(n)\n    z_quantile = 3.290526731  # Given for alpha = 0.001\n    \n    critical_value = z_quantile / np.sqrt(n)\n    \n    accept_independence = np.abs(r_1) = critical_value\n    \n    return accept_independence\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: M/M/1, stable and well-mixed\n        {\n            'lambda': 0.8, 'mu': 1.5, 'n': 5000, \n            'arrival_seed': 101, 'service_seed': 202,\n            'service_model': 'exponential'\n        },\n        # Case 2: M/M/1, heavy traffic but stable\n        {\n            'lambda': 0.95, 'mu': 1.0, 'n': 2000, \n            'arrival_seed': 303, 'service_seed': 404,\n            'service_model': 'exponential'\n        },\n        # Case 3: M/G/1, dependent lognormal services\n        {\n            'lambda': 0.8, 'mu': 1.5, 'n': 3000,\n            'arrival_seed': 505, 'service_seed': 606,\n            'service_model': 'ar1_lognormal',\n            'phi': 0.99, 's': 0.6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}