{
    "hands_on_practices": [
        {
            "introduction": "随机模拟的核心是生成遵循特定概率分布的随机数。逆变换法 (inverse transform method) 是一种从标准均匀分布 $U \\sim \\mathrm{Unif}(0,1)$ 生成随机变量的基础技术。本练习将指导您为指数分布和几何分布推导并实现该方法，这两种分布分别是模拟连续时间和离散时间到达过程的关键，从而将概率论与模拟实践紧密结合。",
            "id": "3303686",
            "problem": "考虑在离散事件模拟中为连续时间到达过程和离散时间到达过程生成到达间隔时间的任务。连续时间过程由率参数为 $\\lambda  0$ 的指数分布建模，离散时间过程由成功概率为 $p \\in (0,1]$ 且支撑集为 $\\{1,2,3,\\dots\\}$ 的几何分布建模，该几何分布被解释为首次到达前的离散时间步数。您需要从基本定义出发，推导逆变换采样公式，并仅使用独立的 $U \\sim \\mathrm{Unif}(0,1)$ 随机数源来实现这些到达间隔时间的生成。\n\n基本基础包括以下核心定义和事实：\n- 一个实值随机变量 $X$ 的累积分布函数 (CDF) $F_X(x)$ 定义为 $F_X(x) = \\mathbb{P}(X \\le x)$。\n- 逆变换采样原理指出，如果 $U \\sim \\mathrm{Unif}(0,1)$ 且 $F_X$ 是一个严格递增的连续累积分布函数，则 $X = F_X^{-1}(U)$ 的累积分布函数为 $F_X$。对于支撑集为正整数的离散分布，逆变换采样使用分位数函数 $Q(u) = \\inf\\{k \\in \\mathbb{N} : F_X(k) \\ge u\\}$，其中 $\\mathbb{N} = \\{1,2,3,\\dots\\}$ 且具有指定的支撑集。\n- 率为 $\\lambda$ 的指数分布是唯一具有无记忆性的连续分布；其分布由生存函数 $S(t) = \\mathbb{P}(T  t)$ 刻画，该函数满足 $S(t+s) = S(t)S(s)$ 和 $S(0) = 1$，其中 $t \\ge 0$ 且 $s \\ge 0$，并且恒定的风险率 $\\lambda$ 意味着对于 $t \\ge 0$ 有 $S(t) = \\exp(-\\lambda t)$。相应的累积分布函数 $F(t)$ 在 $[0,\\infty)$ 上是严格递增的。\n- 在 $\\{1,2,3,\\dots\\}$ 上成功概率为 $p \\in (0,1]$ 的几何分布，其概率质量函数为 $\\mathbb{P}(K = k) = (1-p)^{k-1}p$（对于 $k \\in \\mathbb{N}$），并有一个非递减的累积分布函数 $F(k)$。\n\n任务：\n1. 根据上述定义和事实，推导出将独立抽取的 $U \\sim \\mathrm{Unif}(0,1)$ 映射到以下到达间隔时间所需的显式逆变换采样表达式：\n   - 率为 $\\lambda$ 的指数分布，产生实值到达间隔时间 $T \\ge 0$。\n   - 支撑集为 $\\{1,2,\\dots\\}$ 且成功概率为 $p$ 的几何分布，产生整数值到达间隔步数 $K \\in \\mathbb{N}$。\n   您的推导必须从 CDF 定义和逆变换原理出发，不得使用简便公式。\n\n2. 实现一个程序，该程序使用为每个测试用例设定的种子随机数生成器 (RNG)，通过逆变换采样来生成所需的到达间隔时间。程序不得调用任何直接从指数分布或几何分布采样的库函数；它必须仅使用独立的 $U \\sim \\mathrm{Unif}(0,1)$ 随机数和推导出的公式。\n\n3. 为了在 $U$ 值接近 $0$ 或 $1$ 以及 $p$ 值接近 $0$ 或 $1$ 的情况下保持数值稳定性，您的实现应使用稳定的变换（例如，使用能为小 $x$ 可靠计算 $\\log(1-x)$ 的函数）。\n\n4. 设计并执行以下测试套件。对于每个测试用例，生成恰好 $n$ 个独立样本，并输出该用例生成的到达间隔时间列表：\n   - 测试用例 1：指数分布，$\\lambda = 1.5$，$n = 5$，种子 $42$。\n   - 测试用例 2：几何分布，$p = 0.3$，$n = 5$，种子 $123$。\n   - 测试用例 3：指数分布，$\\lambda = 0.01$，$n = 5$，种子 $7$。\n   - 测试用例 4：几何分布，$p = 0.99$，$n = 10$，种子 $99$。\n   - 测试用例 5：几何分布，$p = 1.0$，$n = 7$，种子 $555$。\n   - 测试用例 6：指数分布，$\\lambda = 10.0$，$n = 8$，种子 $2023$。\n\n5. 最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来。每个结果都应是对应测试用例生成的到达间隔时间列表，按上述顺序排列。例如，输出形式应为 $[L_1,L_2,L_3,L_4,L_5,L_6]$，其中 $L_i$ 是为测试用例 $i$ 生成的 $n$ 个值的列表。所有输出必须是指数分布到达间隔的无单位实数和几何分布到达间隔的无单位整数。",
            "solution": "该问题是有效的，因为它在概率论和随机模拟方面有科学依据，问题设定良好，目标和约束明确，并且使用客观、明确的语言进行表述。解决方案需要推导并实现针对指数分布和几何分布的标准逆变换采样方法。\n\n推导和实现分为两部分，每种分布一部分。\n\n### 1. 指数分布的到达间隔时间\n\n目标是推导从一个率参数为 $\\lambda  0$ 的指数分布中生成随机变量 $T$ 的公式，给定一个均匀随机抽样 $U \\sim \\mathrm{Unif}(0,1)$。\n\n推导从指数分布的基本性质开始。它由其生存函数 $S(t)$ 定义，即事件到时间 $t$ 尚未发生的概率。对于一个具有恒定风险率 $\\lambda$ 的指数过程，生存函数为：\n$$ S(t) = \\mathbb{P}(T  t) = \\exp(-\\lambda t) \\quad \\text{for } t \\ge 0 $$\n累积分布函数 (CDF) $F(t)$ 是事件到时间 $t$ 已经发生的概率。它与生存函数的关系为 $F(t) = \\mathbb{P}(T \\le t) = 1 - \\mathbb{P}(T  t)$。\n代入 $S(t)$ 的表达式：\n$$ F(t) = 1 - \\exp(-\\lambda t) $$\n逆变换采样原理指出，如果 $U$ 是一个在 $(0,1)$ 上均匀分布的随机变量，那么随机变量 $X = F_X^{-1}(U)$ 的 CDF 就是 $F_X$。对于指数分布，我们令 $U = F(T)$ 并求解 $T$：\n$$ U = 1 - \\exp(-\\lambda T) $$\n我们重排方程以分离出 $T$：\n$$ \\exp(-\\lambda T) = 1 - U $$\n对两边取自然对数：\n$$ \\ln(\\exp(-\\lambda T)) = \\ln(1 - U) $$\n$$ -\\lambda T = \\ln(1 - U) $$\n最后，求解 $T$ 得到逆变换公式：\n$$ T = -\\frac{1}{\\lambda} \\ln(1 - U) $$\n由于 $U$ 是一个 $\\mathrm{Unif}(0,1)$ 随机变量，变量 $U' = 1 - U$ 也是一个 $\\mathrm{Unif}(0,1)$ 随机变量。因此，该公式通常简化为 $T = -\\frac{1}{\\lambda} \\ln(U)$。然而，为了从 CDF 进行严格推导并考虑问题中提出的数值稳定性，我们将使用 $T = -\\frac{1}{\\lambda} \\ln(1-U)$ 的形式。在实现时，应使用一个能为小 $x$ 精确计算 $\\ln(1-x)$ 的函数（例如，对于小 `U` 使用 `log1p(-U)`）来保持数值精度，正如问题所建议的。\n\n### 2. 几何分布的到达间隔步数\n\n目标是推导从一个成功概率为 $p \\in (0,1]$、支撑集为正整数 $\\mathbb{N} = \\{1, 2, 3, \\dots\\}$ 的几何分布中生成随机变量 $K$ 的公式。\n\n概率质量函数 (PMF) 给出如下：\n$$ \\mathbb{P}(K = k) = (1-p)^{k-1}p \\quad \\text{for } k \\in \\{1, 2, 3, \\dots\\} $$\nCDF $F(k) = \\mathbb{P}(K \\le k)$ 是从 $j=1$ 到 $k$ 的 PMF 之和：\n$$ F(k) = \\sum_{j=1}^{k} (1-p)^{j-1}p $$\n这是一个有限几何级数。令 $q = 1-p$。和为：\n$$ F(k) = p \\sum_{j=1}^{k} q^{j-1} = p \\left( \\frac{1 - q^k}{1 - q} \\right) $$\n将 $q = 1-p$ 代回分母：\n$$ F(k) = p \\left( \\frac{1 - (1-p)^k}{1 - (1-p)} \\right) = p \\left( \\frac{1 - (1-p)^k}{p} \\right) = 1 - (1-p)^k $$\n对于离散分布，逆变换方法使用分位数函数 $Q(u) = \\inf\\{k \\in \\mathbb{N} : F(k) \\ge u\\}$。我们设 $U \\sim \\mathrm{Unif}(0,1)$ 并找到满足以下不等式的最小整数 $K$：\n$$ F(K) \\ge U $$\n$$ 1 - (1-p)^K \\ge U $$\n重排不等式：\n$$ 1 - U \\ge (1-p)^K $$\n为了求解 $K$，我们对两边取自然对数。由于 $p \\in (0,1]$，我们有 $1-p \\in [0,1)$。自然对数 $\\ln(x)$ 对于 $x0$ 是一个增函数。因此，对于 $1-p \\in (0,1)$，我们有 $\\ln(1-p)  0$。\n取对数：\n$$ \\ln(1 - U) \\ge \\ln((1-p)^K) $$\n$$ \\ln(1 - U) \\ge K \\ln(1-p) $$\n为了分离出 $K$，我们必须除以 $\\ln(1-p)$。由于该项为负，我们必须反转不等号：\n$$ \\frac{\\ln(1 - U)}{\\ln(1-p)} \\le K $$\n所以，$K$ 必须是大于或等于 $\\frac{\\ln(1 - U)}{\\ln(1-p)}$ 的整数。最小的这样的整数由天花板函数（向上取整函数）给出：\n$$ K = \\left\\lceil \\frac{\\ln(1 - U)}{\\ln(1-p)} \\right\\rceil $$\n这是对于 $p \\in (0,1)$ 所需的公式。\n\n对于特殊情况 $p = 1$，PMF 为 $\\mathbb{P}(K=1) = 1$ 且对于 $k  1$ 有 $\\mathbb{P}(K=k) = 0$。对于所有 $k \\ge 1$，CDF 为 $F(k)=1$。条件 $\\inf\\{k \\in \\mathbb{N} : F(k) \\ge U\\}$ 变为 $\\inf\\{k \\in \\mathbb{N} : 1 \\ge U\\}$，对于任何 $U \\in (0,1)$，这总是 $1$。因此，对于 $p=1$，$K=1$。该公式会涉及 $\\ln(0)$，所以在实现中应单独处理这种情况。\n\n为了数值稳定性，特别是当 $p$ 很小时，项 $\\ln(1-U)$ 和 $\\ln(1-p)$ 应使用像 `log1p` 这样的函数来计算，以避免精度损失。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by generating interarrival times for exponential and\n    geometric distributions using the inverse-transform method.\n    \"\"\"\n    test_cases = [\n        {'type': 'exp', 'params': {'lambda': 1.5, 'n': 5, 'seed': 42}},\n        {'type': 'geom', 'params': {'p': 0.3, 'n': 5, 'seed': 123}},\n        {'type': 'exp', 'params': {'lambda': 0.01, 'n': 5, 'seed': 7}},\n        {'type': 'geom', 'params': {'p': 0.99, 'n': 10, 'seed': 99}},\n        {'type': 'geom', 'params': {'p': 1.0, 'n': 7, 'seed': 555}},\n        {'type': 'exp', 'params': {'lambda': 10.0, 'n': 8, 'seed': 2023}},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_type = case['type']\n        params = case['params']\n        n = params['n']\n        seed = params['seed']\n        \n        # Create a new Random Number Generator for each case with the specified seed\n        rng = np.random.default_rng(seed)\n        \n        # Generate n independent draws from Unif(0,1)\n        # The numpy.random.random() function generates numbers in the interval [0.0, 1.0)\n        # For the derivation F^{-1}(U), U should be in (0,1).\n        # A value of U=0 is possible. For exponential, log1p(-0) = 0, T=0.\n        # For geometric, log1p(-0)/log1p(-p) = 0, ceil(0)=0. However, support starts at 1.\n        # The quantile formula inf{k: F(k)=u} handles u=0 correctly if F(k) are positive. F(0)=0.\n        # We will proceed with U in [0,1) as generated by rng.random().\n        \n        U = rng.random(size=n)\n        \n        if case_type == 'exp':\n            lambda_val = params['lambda']\n            # Using T = -(1/lambda) * log(1-U), implemented with numerically stable log1p(-U)\n            # This handles U near 0 gracefully.\n            samples = -(1/lambda_val) * np.log1p(-U)\n            # Convert to a standard Python list for formatting\n            samples_list = samples.tolist()\n\n        elif case_type == 'geom':\n            p_val = params['p']\n            \n            # Handle the special case p=1.0\n            if p_val == 1.0:\n                # Interarrival time is always 1\n                samples = np.ones(n, dtype=int)\n            else:\n                # Using K = ceil(log(1-U)/log(1-p))\n                # Both logarithms are implemented with numerically stable log1p\n                numerator = np.log1p(-U)\n                denominator = np.log1p(-p_val)\n                samples = np.ceil(numerator / denominator)\n                # The result must be integer-valued. A result of 0 is possible if U is very\n                # close to 0 but not exactly 0. The support is {1,2,...}.\n                # If U == 0, num=0, ratio=0, ceil(0)=0. We should ensure results are = 1.\n                # The quantile function is inf{k = 1}, so 0 is not a valid output.\n                # If U == 0, the inequality F(k) = 0 is solved by k=1 for any p1.\n                # So the result should be 1.\n                samples[samples == 0] = 1\n                samples = samples.astype(int)\n\n            # Convert to a standard Python list for formatting\n            samples_list = samples.tolist()\n\n        # Format the list of numbers into a string '[v1,v2,...]' without spaces\n        formatted_list = f\"[{','.join(map(str, samples_list))}]\"\n        all_results.append(formatted_list)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何生成随机事件之后，核心挑战转变为构建模拟器来追踪系统的动态演化。本练习将引导您实现一个 $GI/G/1$ 队列的下一事件模拟，这是分析各种系统的通用模型。通过处理预先设定的到达和服务时间序列，您可以专注于掌握事件调度和状态更新的核心逻辑，这是构建任何复杂离散事件模拟器的基础。",
            "id": "3303619",
            "problem": "您需要实现一个$GI/G/1$类型（独立通用到达过程 / 通用服务时间 / 单服务器）的单服务器排队系统的下一事件离散事件模拟。该系统遵循先到先服务（FCFS）规则，使用由指定的有限到达间隔时间序列和指定的有限服务时间序列构成的预定到达。目标是为每个提供的测试用例计算系统中顾客的经验等待时间分布。\n\n基本原理和定义：$GI/G/1$队列由一个到达过程定义，其中到达间隔时间是独立的，并且可能非同分布；服务时间也是独立的，并且可能非同分布。对于一个给定的有限到达间隔时间序列 $\\{a_1, a_2, \\ldots, a_n\\}$ 和一个有限服务时间序列 $\\{s_1, s_2, \\ldots, s_n\\}$，对于每个 $k \\in \\{1,2,\\ldots,n\\}$，预定到达时间通过累积和 $t_k = \\sum_{i=1}^{k} a_i$ 构建。服务器在FCFS规则下一次只服务一位顾客。顾客 $k$ 的等待时间 $w_k$ 是其预定到达时间 $t_k$ 与其服务开始时间之间的时间段。服务完成时间和由此产生的队列状态由事件调度确定。\n\n事件处理策略：如果一个到达事件和一个离开事件被安排在同一时间，则先处理离开事件，再处理到达事件。这条冲突解决规则确保在时间 $t$ 到达的顾客，如果恰好与时间 $t$ 的预定离开事件重合，会观察到服务器处于空闲状态，并可以立即开始服务。\n\n实现要求：您必须实现一个下一事件模拟，该模拟：\n- 在时间 $0$ 初始化系统，此时服务器空闲，队列为空。\n- 按时间非递减顺序处理事件，总是将模拟时钟跳转到下一事件的时间。\n- 当顾客在时间 $t_k$ 到达时，如果服务器空闲，该顾客的服务在时间 $t_k$ 开始；否则，该顾客加入队列。\n- 当有顾客离开时，如果队列非空，则FCFS顺序中的下一位顾客在离开时间立即开始服务；否则，服务器变为空闲。\n- 记录 $n$ 位顾客中每位的等待时间 $w_k$，其值为服务开始时间减去 $t_k$。\n\n经验分布要求：对于一个给定的有限阈值列表 $\\{x_1, x_2, \\ldots, x_m\\}$，计算在每个阈值处的等待时间经验累积分布函数（ECDF），定义如下：\n$$\\hat{F}(x_j) = \\frac{1}{n} \\sum_{k=1}^{n} \\mathbf{1}\\{w_k \\le x_j\\}, \\quad j = 1,2,\\ldots,m.$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。所有时间量都以任意一致的时间单位计量，经验累积概率必须以小数形式表示。\n\n测试套件：您的程序必须为以下四个参数集计算ECDF值。对于每个测试用例，请使用指定的到达间隔时间序列、服务时间序列和阈值。所有数字都应被视为精确的实数值。\n\n- 测试用例 $1$ (中等变异性，典型负载):\n  到达间隔时间 $\\,[1.0,\\,0.4,\\,0.8,\\,1.5,\\,0.7]$,\n  服务时间 $\\,[0.5,\\,1.2,\\,0.3,\\,0.6,\\,0.9]$,\n  阈值 $\\,[0.0,\\,0.2,\\,0.5,\\,1.0]$.\n\n- 测试用例 $2$ (高负载，持续排队):\n  到达间隔时间 $\\,[0.2,\\,0.2,\\,0.2,\\,0.2,\\,0.2,\\,0.2]$,\n  服务时间 $\\,[0.5,\\,0.7,\\,0.4,\\,0.6,\\,0.8,\\,0.9]$,\n  阈值 $\\,[0.0,\\,0.5,\\,1.0,\\,1.5]$.\n\n- 测试用例 $3$ (空闲间隙与短暂爆发，多次零等待):\n  到达间隔时间 $\\,[3.0,\\,0.1,\\,5.0,\\,0.2]$,\n  服务时间 $\\,[0.5,\\,0.4,\\,0.3,\\,0.2]$,\n  阈值 $\\,[0.0,\\,0.1,\\,0.4,\\,0.8]$.\n\n- 测试用例 $4$ (零服务时间的边界行为):\n  到达间隔时间 $\\,[1.0,\\,1.0,\\,1.0]$,\n  服务时间 $\\,[0.0,\\,0.0,\\,0.0]$,\n  阈值 $\\,[0.0,\\,0.001]$.\n\n输出规范：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须是扁平的，并且必须按顺序连接每个测试用例的ECDF值，这些值按其阈值出现的顺序列出。也就是说，如果测试用例 $i$ 在其阈值处的ECDF值为 $[v_{i,1},\\,v_{i,2},\\,\\ldots,\\,v_{i,m_i}]$，那么最终输出必须是\n$[v_{1,1},\\,v_{1,2},\\,\\ldots,\\,v_{1,m_1},\\,v_{2,1},\\,\\ldots,\\,v_{2,m_2},\\,v_{3,1},\\,\\ldots,\\,v_{3,m_3},\\,v_{4,1},\\,\\ldots,\\,v_{4,m_4}].$",
            "solution": "用户想要模拟一个 $GI/G/1$ 队列。\n\n### 步骤1：提取已知条件\n- **系统模型**：指定为 $GI/G/1$（独立通用到达过程，通用服务时间，单服务器）的单服务器排队系统。\n- **服务规则**：先到先服务 (FCFS)。\n- **输入数据**：一个有限的到达间隔时间序列 $\\{a_1, a_2, \\ldots, a_n\\}$ 和一个有限的服务时间序列 $\\{s_1, s_2, \\ldots, s_n\\}$。\n- **到达时间定义**：顾客 $k$ 的预定到达时间是 $t_k = \\sum_{i=1}^{k} a_i$。\n- **等待时间定义**：顾客 $k$ 的等待时间 $w_k$ 是其预定到达时间 $t_k$ 与其服务开始时间之间的时间段。\n- **初始条件**：在时间 $t=0$ 时，服务器空闲且队列为空。\n- **事件处理冲突解决规则**：如果一个到达事件和一个离开事件被安排在同一时间，则先处理离开事件。\n- **输出要求**：对于给定的阈值集合 $\\{x_j\\}$，计算等待时间的经验累积分布函数 (ECDF)，$\\hat{F}(x_j) = \\frac{1}{n} \\sum_{k=1}^{n} \\mathbf{1}\\{w_k \\le x_j\\}$。\n- **测试用例**：\n    - **测试用例 1**：\n        - 到达间隔时间： $[1.0, 0.4, 0.8, 1.5, 0.7]$\n        - 服务时间： $[0.5, 1.2, 0.3, 0.6, 0.9]$\n        - 阈值： $[0.0, 0.2, 0.5, 1.0]$\n    - **测试用例 2**：\n        - 到达间隔时间： $[0.2, 0.2, 0.2, 0.2, 0.2, 0.2]$\n        - 服务时间： $[0.5, 0.7, 0.4, 0.6, 0.8, 0.9]$\n        - 阈值： $[0.0, 0.5, 1.0, 1.5]$\n    - **测试用例 3**：\n        - 到达间隔时间： $[3.0, 0.1, 5.0, 0.2]$\n        - 服务时间： $[0.5, 0.4, 0.3, 0.2]$\n        - 阈值： $[0.0, 0.1, 0.4, 0.8]$\n    - **测试用例 4**：\n        - 到达间隔时间： $[1.0, 1.0, 1.0]$\n        - 服务时间： $[0.0, 0.0, 0.0]$\n        - 阈值： $[0.0, 0.001]$\n- **输出格式**：单行输出，包含一个由方括号括起来的逗号分隔列表，其中按顺序连接了所有测试用例的所有ECDF值。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了 $GI/G/1$ 队列的模拟，这是排队论和随机模拟中的一个经典模型。所提出的方法（下一事件模拟）和要计算的量（等待时间，ECDF）都是标准且定义明确的。所有概念都牢固地建立在数学和运筹学的既定原则之上。\n- **适定性**：该问题是适定的。给定有限的、确定性的到达间隔时间序列和服务时间序列，系统的演化是确定性的。每个测试用例都存在唯一的等待时间序列，从而得到唯一的ECDF。所有必要的参数和初始条件都已提供。\n- **客观性**：问题以精确、客观的语言陈述。诸如等待时间、FCFS规则和冲突解决规则等关键术语都得到了明确定义，没有留下任何模糊之处。\n- **总体评估**：该问题不违反任何无效性标准。它在离散事件模拟领域是一个完整、一致且科学合理的问题。\n\n### 步骤3：结论与行动\n问题有效。将提供一个解决方案。\n\n该问题要求为一个遵循先到先服务（FCFS）规则的单服务器队列（$GI/G/1$）实现一个下一事件模拟。模拟的目标是为一组有限的 $n$ 个顾客计算经验等待时间分布，这些顾客的到达间隔时间和服务时间是预先确定的。\n\n这种离散事件模拟的核心原理是随时间跟踪系统的状态。对于单服务器队列，最关键的状态变量是服务器变为空闲的时间。我们用 $T_{free}$ 表示这个变量。模拟时钟不是以固定的增量前进，而是从一个事件跳转到下一个事件。由于到达时间是预先安排好的，我们可以按顺序处理从 $k=1, 2, \\ldots, n$ 的顾客。\n\n模拟逻辑如下：\n$1$. **初始化**：系统在时间 $t=0$ 开始，此时队列为空，服务器空闲。这通过将初始服务器空闲时间设置为 $T_{free} = 0$ 来建模。我们还需要为每个顾客 $k$ 计算绝对到达时间 $t_k$。给定到达间隔时间 $\\{a_1, a_2, \\ldots, a_n\\}$，第 $k$ 位顾客的到达时间是 $t_k = \\sum_{i=1}^{k} a_i$。我们可以为所有的 $k$ 预先计算这些值。\n\n$2$. **顺序顾客处理**：我们从 $1$ 到 $n$ 遍历每个顾客 $k$。对于每个顾客 $k$，根据其到达时间 $t_k$ 和服务时间 $s_k$，我们确定其等待时间 $w_k$。\n\n$3$. **等待时间计算**：一个在时间 $t_k$ 到达的顾客 $k$ 只有在两个条件都满足时才能开始服务：顾客已经到达，并且服务器是空闲的。服务器在时间 $T_{free}$（来自前一个顾客，或初始为 $0$）变为空闲。因此，顾客 $k$ 的服务将在时间 $T_{\\text{start},k} = \\max(t_k, T_{free})$ 开始。\n\n等待时间 $w_k$ 定义为顾客到达与其服务开始之间经过的时间。\n$$w_k = T_{\\text{start},k} - t_k$$\n代入 $T_{\\text{start},k}$ 的表达式，我们得到：\n$$w_k = \\max(t_k, T_{free}) - t_k = \\max(0, T_{free} - t_k)$$\n这个表达式正确地表明，一个顾客只有在服务器空闲之前到达（$t_k  T_{free}$）时才会等待（$w_k > 0$）。指定的冲突解决规则（离开先于到达）被自然地处理了：如果一个顾客在服务器变为空闲的精确时刻到达（$t_k = T_{free}$），他们的等待时间是 $w_k = \\max(0, T_{free} - T_{free}) = 0$。\n\n$4$. **状态更新**：一旦顾客 $k$ 在 $T_{\\text{start},k}$ 开始服务，服务器将在其服务时间 $s_k$ 的持续时间内处于忙碌状态。因此，服务器将在新的时间 $T_{\\text{free, new}} = T_{\\text{start},k} + s_k$ 再次变为空闲。这个更新后的 $T_{free}$ 值将被用于下一个顾客 $k+1$。这种迭代更新构成了模拟的核心。对于 $k=1$，初始的 $T_{free}$ 是 $0$，所以 $w_1 = \\max(0, 0 - t_1) = 0$，这是正确的，因为第一个顾客从不等待。\n\n$5$. **经验分布计算**：在遍历所有 $n$ 个顾客并记录了他们的等待时间 $\\{w_1, w_2, \\ldots, w_n\\}$ 之后，我们计算在给定阈值 $\\{x_1, x_2, \\ldots, x_m\\}$ 处的经验累积分布函数（ECDF）。ECDF, $\\hat{F}(x_j)$，是等待时间小于或等于阈值 $x_j$ 的顾客所占的比例。\n$$\\hat{F}(x_j) = \\frac{1}{n} \\sum_{k=1}^{n} \\mathbf{1}\\{w_k \\le x_j\\}$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，如果条件为真则为 $1$，否则为 $0$。对于每个测试用例的每个给定阈值 $x_j$，都会进行此计算。\n对于给定的输入，整个过程是确定性的，并通过对每个测试用例顺序应用这些步骤来实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a GI/G/1 queue simulation and computes ECDF of waiting times\n    for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"interarrivals\": [1.0, 0.4, 0.8, 1.5, 0.7],\n            \"services\": [0.5, 1.2, 0.3, 0.6, 0.9],\n            \"thresholds\": [0.0, 0.2, 0.5, 1.0]\n        },\n        {\n            \"interarrivals\": [0.2, 0.2, 0.2, 0.2, 0.2, 0.2],\n            \"services\": [0.5, 0.7, 0.4, 0.6, 0.8, 0.9],\n            \"thresholds\": [0.0, 0.5, 1.0, 1.5]\n        },\n        {\n            \"interarrivals\": [3.0, 0.1, 5.0, 0.2],\n            \"services\": [0.5, 0.4, 0.3, 0.2],\n            \"thresholds\": [0.0, 0.1, 0.4, 0.8]\n        },\n        {\n            \"interarrivals\": [1.0, 1.0, 1.0],\n            \"services\": [0.0, 0.0, 0.0],\n            \"thresholds\": [0.0, 0.001]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        interarrivals = case[\"interarrivals\"]\n        services = case[\"services\"]\n        thresholds = case[\"thresholds\"]\n\n        num_customers = len(interarrivals)\n        \n        # 1. Calculate absolute arrival times from interarrival times.\n        arrival_times = np.cumsum(interarrivals)\n        \n        # 2. Simulate the queue to get waiting times for each customer.\n        waiting_times = np.zeros(num_customers)\n        server_free_time = 0.0\n        \n        for k in range(num_customers):\n            # Get arrival and service time for customer k.\n            t_k = arrival_times[k]\n            s_k = services[k]\n            \n            # Service begins at the maximum of arrival time and when the server is free.\n            service_start_time = max(t_k, server_free_time)\n            \n            # Waiting time is the delay between arrival and service start.\n            w_k = service_start_time - t_k\n            waiting_times[k] = w_k\n            \n            # Update the time the server will become free for the next customer.\n            server_free_time = service_start_time + s_k\n            \n        # 3. Compute the ECDF for the given thresholds.\n        n_float = float(num_customers)\n        for x_j in thresholds:\n            # Count customers with waiting time = threshold.\n            count = np.sum(waiting_times = x_j)\n            # ECDF is the fraction of such customers.\n            ecdf_value = count / n_float\n            all_results.append(ecdf_value)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了从模拟中高效地获取精确的估计，必须使用方差缩减技术。控制变量法 (control variate method) 是一种强大的高级方法，它利用模拟中某个易于测量且其理论均值已知的变量（控制变量）来提高我们对主要目标性能指标估计的精度。本练习将以经典的 $M/M/1$ 队列为例，向您展示如何使用服务器利用率作为控制变量，来显著降低平均系统延迟估计的方差。",
            "id": "3303623",
            "problem": "考虑一个具有马尔可夫到达和马尔可夫服务时间（M/M/1）的单服务台排队系统，其到达率 $\\lambda = 0.8$ 作业/秒，服务率 $\\mu = 1.0$ 作业/秒。在一次离散事件模拟（Discrete-Event Simulation (DES)）中，您运行了 $m$ 次独立的稳态重复，每次重复都移除了足够长的预热期，并在每次重复 $j$ 中记录了两个统计量：系统中顾客延迟的样本均值，记为 $D_{j}$（单位：秒），以及时间平均服务器繁忙率（服务器利用率），记为 $U_{j}$（无量纲）。令 $\\rho = \\lambda / \\mu$ 表示稳态服务器利用率，该值可由第一性原理得知。\n\n您希望使用控制变量法（Control Variate (CV)）来减小平均延迟 $\\mathbb{E}[D]$ 的蒙特卡洛估计量的方差。定义经控制变量调整的单次重复估计量为 $D^{*}_{j} = D_{j} - c \\left(U_{j} - \\rho\\right)$，其中 $c \\in \\mathbb{R}$ 是一个待选系数。\n\n从期望、方差和协方差的基本定义出发，使用服务器利用率构建控制变量，推导使 $\\operatorname{Var}(D^{*}_{j})$ 最小化的最优系数 $c^{*}$，并表示在 $c = c^{*}$ 条件下可实现的方差缩减比 $R = \\operatorname{Var}(D^{*}_{j}) / \\operatorname{Var}(D_{j})$。\n\n一次包含 $m_{0} = 200$ 次重复的试验性运行得出了以下可靠的重复间汇总统计量：样本方差 $\\widehat{\\operatorname{Var}}(D_{j}) = 9.0$（平方秒），样本方差 $\\widehat{\\operatorname{Var}}(U_{j}) = 0.16$（无量纲的平方），以及样本协方差 $\\widehat{\\operatorname{Cov}}(D_{j}, U_{j}) = 1.0$（秒）。请将这些试验性运行的值作为总体量的置入估计，用于您的推导中，以计算 $c^{*}$（以秒表示）和 $R$（无量纲）。将您最终的数值答案四舍五入至四位有效数字。系数以秒表示，方差缩减比以无量纲小数表示。",
            "solution": "本题要求推导控制变量估计量的最优系数及由此产生的方差缩减，然后使用提供的试验性运行数据进行数值计算。所考虑的系统是一个具有马尔可夫到达和服务时间的单服务台排队系统（M/M/1）。设 $\\lambda$ 为到达率，$\\mu$ 为服务率。\n\n我们感兴趣的量是系统中的平均顾客延迟 $\\mathbb{E}[D]$。来自第 $j$ 次重复的主要估计量是样本平均延迟 $D_j$。引入一个控制变量 $U_j$，即第 $j$ 次重复中的时间平均服务器繁忙率。根据排队论，该控制变量的期望值已知为稳态服务器利用率 $\\rho = \\frac{\\lambda}{\\mu}$。\n\n经控制变量调整的估计量定义为：\n$$D^{*}_{j} = D_{j} - c \\left(U_{j} - \\rho\\right)$$\n其中 $c$ 是一个待优化的系数。\n\n首先，我们验证 $D^{*}_{j}$ 是 $\\mathbb{E}[D_j]$ 的一个无偏估计量。$D^{*}_{j}$ 的期望为：\n$$\\mathbb{E}[D^{*}_{j}] = \\mathbb{E}[D_{j} - c \\left(U_{j} - \\rho\\right)] = \\mathbb{E}[D_{j}] - c \\left(\\mathbb{E}[U_{j}] - \\mathbb{E}[\\rho]\\right)$$\n由于 $U_j$ 是来自稳态重复的样本平均利用率，其期望是真实的稳态利用率，即 $\\mathbb{E}[U_{j}] = \\rho$。由于 $\\rho$ 是一个常数，所以 $\\mathbb{E}[\\rho]=\\rho$。因此：\n$$\\mathbb{E}[D^{*}_{j}] = \\mathbb{E}[D_{j}] - c(\\rho - \\rho) = \\mathbb{E}[D_{j}]$$\n这证实了控制变量估计量是无偏的。\n\n接下来，我们推导 $D^{*}_{j}$ 的方差，以找到使其最小化的最优系数 $c^*$。$D^{*}_{j}$ 的方差是 $c$ 的函数：\n$$\\operatorname{Var}(D^{*}_{j}) = \\operatorname{Var}\\left(D_{j} - c \\left(U_{j} - \\rho\\right)\\right)$$\n由于 $\\rho$ 是一个常数，$\\operatorname{Var}(U_j - \\rho) = \\operatorname{Var}(U_j)$。使用随机变量线性组合的方差公式 $\\operatorname{Var}(X - aY) = \\operatorname{Var}(X) + a^2 \\operatorname{Var}(Y) - 2a \\operatorname{Cov}(X, Y)$，我们有：\n$$\\operatorname{Var}(D^{*}_{j}) = \\operatorname{Var}(D_{j}) + c^2 \\operatorname{Var}(U_{j}) - 2c \\operatorname{Cov}(D_{j}, U_{j})$$\n这个表达式是关于 $c$ 的二次函数。为了找到使该方差最小的 $c$ 值，我们对其关于 $c$ 求导并令其为零：\n$$\\frac{d}{dc} \\operatorname{Var}(D^{*}_{j}) = 2c \\operatorname{Var}(U_{j}) - 2 \\operatorname{Cov}(D_{j}, U_{j})$$\n令导数为零可得：\n$$2c^{*} \\operatorname{Var}(U_{j}) - 2 \\operatorname{Cov}(D_{j}, U_{j}) = 0$$\n解出最优系数 $c^*$：\n$$c^{*} = \\frac{\\operatorname{Cov}(D_{j}, U_{j})}{\\operatorname{Var}(U_{j})}$$\n\n现在我们确定方差缩减比 $R$。首先，我们将 $c^*$ 代入 $\\operatorname{Var}(D^{*}_{j})$ 的表达式中以求得最小方差：\n$$\\operatorname{Var}(D^{*}_{j})|_{c=c^{*}} = \\operatorname{Var}(D_{j}) + \\left(\\frac{\\operatorname{Cov}(D_{j}, U_{j})}{\\operatorname{Var}(U_{j})}\\right)^2 \\operatorname{Var}(U_{j}) - 2 \\left(\\frac{\\operatorname{Cov}(D_{j}, U_{j})}{\\operatorname{Var}(U_{j})}\\right) \\operatorname{Cov}(D_{j}, U_{j})$$\n$$\\operatorname{Var}(D^{*}_{j})|_{c=c^{*}} = \\operatorname{Var}(D_{j}) + \\frac{\\operatorname{Cov}(D_{j}, U_{j})^2}{\\operatorname{Var}(U_{j})} - 2 \\frac{\\operatorname{Cov}(D_{j}, U_{j})^2}{\\operatorname{Var}(U_{j})}$$\n$$\\operatorname{Var}(D^{*}_{j})|_{c=c^{*}} = \\operatorname{Var}(D_{j}) - \\frac{\\operatorname{Cov}(D_{j}, U_{j})^2}{\\operatorname{Var}(U_{j})}$$\n方差缩减比 $R$ 是新方差与原方差之比：\n$$R = \\frac{\\operatorname{Var}(D^{*}_{j})|_{c=c^{*}}}{\\operatorname{Var}(D_{j})} = \\frac{\\operatorname{Var}(D_{j}) - \\frac{\\operatorname{Cov}(D_{j}, U_{j})^2}{\\operatorname{Var}(U_{j})}}{\\operatorname{Var}(D_{j})}$$\n$$R = 1 - \\frac{\\operatorname{Cov}(D_{j}, U_{j})^2}{\\operatorname{Var}(D_{j}) \\operatorname{Var}(U_{j})}$$\n这也可以用相关系数的平方 $\\rho_{DU}^2 = \\frac{\\operatorname{Cov}(D_{j}, U_{j})^2}{\\operatorname{Var}(D_{j})\\operatorname{Var}(U_{j})}$ 来表示，即 $R = 1 - \\rho_{DU}^2$。\n\n题目提供了来自试验性运行的汇总统计量，用作未知总体量的置入估计：\n- 延迟的样本方差：$\\widehat{\\operatorname{Var}}(D_{j}) = 9.0$ 平方秒。\n- 利用率的样本方差：$\\widehat{\\operatorname{Var}}(U_{j}) = 0.16$ 无量纲的平方。\n- 样本协方差：$\\widehat{\\operatorname{Cov}}(D_{j}, U_{j}) = 1.0$ 秒。\n\n现在我们可以计算最优系数 $c^*$ 的数值估计：\n$$c^{*} \\approx \\hat{c}^{*} = \\frac{\\widehat{\\operatorname{Cov}}(D_{j}, U_{j})}{\\widehat{\\operatorname{Var}}(U_{j})} = \\frac{1.0}{0.16} = 6.25 \\text{ 秒}$$\n四舍五入到四位有效数字，我们得到 $c^{*} = 6.250$ 秒。\n\n接下来，我们计算方差缩减比 $R$ 的数值估计：\n$$R \\approx \\hat{R} = 1 - \\frac{\\widehat{\\operatorname{Cov}}(D_{j}, U_{j})^2}{\\widehat{\\operatorname{Var}}(D_{j}) \\widehat{\\operatorname{Var}}(U_{j})} = 1 - \\frac{(1.0)^2}{(9.0)(0.16)} = 1 - \\frac{1.0}{1.44}$$\n$$R \\approx 1 - 0.69444... = 0.30555...$$\n四舍五入到四位有效数字，我们得到 $R = 0.3056$。该值是无量纲的。$R \\approx 0.3056$ 的值意味着使用控制变量将平均延迟估计量的方差减小了约 $1/0.3056 \\approx 3.27$ 倍，或者说方差减少了约 $69.4\\%$。\n\n最终的数值结果是关于最优系数 $c^*$ 和方差缩减比 $R$。\n- 系数 $c^{*}$ 是 $6.250$ 秒。\n- 方差缩减比 $R$ 是 $0.3056$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6.250  0.3056\n\\end{pmatrix}\n}\n$$"
        }
    ]
}