{
    "hands_on_practices": [
        {
            "introduction": "随机模拟从根本上是由随机数序列驱动的。然而，为了模拟现实世界中的现象，如顾客到达或服务时长，我们需要遵循特定概率分布的随机变量。本练习将探讨逆变换法，这是一种通用而巧妙的技术，可以从简单的均匀分布随机数生成器中产生此类变量，从而为我们的模拟构建基础模块。",
            "id": "3303686",
            "problem": "考虑在离散事件模拟中为连续时间到达过程和离散时间到达过程生成到达间隔时间的任务。连续时间过程由速率参数为 $\\lambda > 0$ 的指数分布建模，离散时间过程由成功概率为 $p \\in (0,1]$、支撑集为 $\\{1,2,3,\\dots\\}$ 的几何分布建模，该几何分布被解释为直到首次到达所需的离散时间步数。你需要从基本定义出发，推导逆变换采样公式，并仅使用独立抽样源 $U \\sim \\mathrm{Unif}(0,1)$ 来实现这些到达间隔时间的生成。\n\n基本依据包括以下核心定义和事实：\n- 实值随机变量 $X$ 的累积分布函数 (CDF) $F_X(x)$ 定义为 $F_X(x) = \\mathbb{P}(X \\leq x)$。\n- 逆变换采样原理指出，如果 $U \\sim \\mathrm{Unif}(0,1)$ 且 $F_X$ 是一个严格递增的连续 CDF，则 $X = F_X^{-1}(U)$ 的 CDF 为 $F_X$。对于支撑集为正整数的离散分布，逆变换采样使用分位数函数 $Q(u) = \\inf\\{k \\in \\mathbb{N} : F_X(k) \\geq u\\}$，其中 $\\mathbb{N} = \\{1,2,3,\\dots\\}$ 为指定的支撑集。\n- 速率为 $\\lambda$ 的指数分布是唯一具有无记忆性的连续分布；其分布由生存函数 $S(t) = \\mathbb{P}(T > t)$ 来刻画，该函数满足 $S(t+s) = S(t)S(s)$ 和 $S(0) = 1$，其中 $t \\geq 0$ 且 $s \\geq 0$。恒定的风险率 $\\lambda$ 意味着对于 $t \\geq 0$，有 $S(t) = \\exp(-\\lambda t)$。相应的 CDF $F(t)$ 在 $[0,\\infty)$ 上是严格递增的。\n- 支撑集为 $\\{1,2,3,\\dots\\}$、成功概率为 $p \\in (0,1]$ 的几何分布，其概率质量函数为 $\\mathbb{P}(K = k) = (1-p)^{k-1}p$，其中 $k \\in \\mathbb{N}$，且其 CDF $F(k)$ 是一个非递减函数。\n\n任务：\n1. 根据上述定义和事实，推导将独立抽样 $U \\sim \\mathrm{Unif}(0,1)$ 映射到以下分布的到达间隔时间所需的显式逆变换采样表达式：\n   - 速率为 $\\lambda$ 的指数分布，生成实值到达间隔时间 $T \\geq 0$。\n   - 成功概率为 $p$、支撑集为 $\\{1,2,\\dots\\}$ 的几何分布，生成整数值到达间隔步长 $K \\in \\mathbb{N}$。\n   你的推导必须从 CDF 定义和逆变换原理开始，不得使用简化公式。\n\n2. 实现一个程序，该程序使用为每个测试用例设定的随机数生成器 (RNG) 种子，通过逆变换采样生成所需的到达间隔时间。程序不得调用任何直接从指数分布或几何分布中采样的库函数；它必须仅使用独立抽样 $U \\sim \\mathrm{Unif}(0,1)$ 和推导出的公式。\n\n3. 为了在 $U$ 值接近 $0$ 或 $1$ 以及 $p$ 值接近 $0$ 或 $1$ 的情况下保持数值稳定性，你的实现应使用稳定的变换（例如，使用能为较小的 $x$ 可靠计算 $\\log(1-x)$ 的函数）。\n\n4. 设计并执行以下测试套件。对于每个测试用例，生成恰好 $n$ 个独立样本，并输出该用例生成的到达间隔时间列表：\n   - 测试用例 1：指数分布，$\\lambda = 1.5$，$n = 5$，种子 $42$。\n   - 测试用例 2：几何分布，$p = 0.3$，$n = 5$，种子 $123$。\n   - 测试用例 3：指数分布，$\\lambda = 0.01$，$n = 5$，种子 $7$。\n   - 测试用例 4：几何分布，$p = 0.99$，$n = 10$，种子 $99$。\n   - 测试用例 5：几何分布，$p = 1.0$，$n = 7$，种子 $555$。\n   - 测试用例 6：指数分布，$\\lambda = 10.0$，$n = 8$，种子 $2023$。\n\n5. 最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个结果都是按上述顺序列出的相应测试用例生成的到达间隔时间列表。例如，输出形式应为 $[L_1,L_2,L_3,L_4,L_5,L_6]$，其中 $L_i$ 是为测试用例 $i$ 生成的 $n$ 个值的列表。所有指数分布的到达间隔时间输出必须是无单位的实数，几何分布的到达间隔时间输出必须是无单位的整数。",
            "solution": "该问题是有效的，因为它在科学上基于概率论和随机模拟，问题陈述清晰，具有明确的目标和约束，并以客观、明确的语言表述。解决方案需要推导并实现用于指数分布和几何分布的标准逆变换采样方法。\n\n推导和实现分为两部分，每种分布一部分。\n\n### 1. 指数分布的到达间隔时间\n\n目标是推导一个公式，用于在给定一个均匀随机抽样 $U \\sim \\mathrm{Unif}(0,1)$ 的情况下，从速率参数为 $\\lambda > 0$ 的指数分布中生成一个随机变量 $T$。\n\n推导从指数分布的基本性质开始。它由其生存函数 $S(t)$ 定义，该函数表示事件在时间 $t$ 之前尚未发生的概率。对于具有恒定风险率 $\\lambda$ 的指数过程，生存函数为：\n$$ S(t) = \\mathbb{P}(T > t) = \\exp(-\\lambda t) \\quad \\text{for } t \\geq 0 $$\n累积分布函数 (CDF) $F(t)$ 是事件在时间 $t$ 之前已经发生的概率。它通过 $F(t) = \\mathbb{P}(T \\leq t) = 1 - \\mathbb{P}(T > t)$ 与生存函数相关联。\n代入 $S(t)$ 的表达式：\n$$ F(t) = 1 - \\exp(-\\lambda t) $$\n逆变换采样原理指出，如果 $U$ 是一个在 $(0,1)$ 上均匀分布的随机变量，则随机变量 $X = F_X^{-1}(U)$ 的 CDF 为 $F_X$。对于指数分布，我们设 $U = F(T)$ 并求解 $T$：\n$$ U = 1 - \\exp(-\\lambda T) $$\n我们重新整理方程以分离出 $T$：\n$$ \\exp(-\\lambda T) = 1 - U $$\n对两边取自然对数得到：\n$$ \\ln(\\exp(-\\lambda T)) = \\ln(1 - U) $$\n$$ -\\lambda T = \\ln(1 - U) $$\n最后，求解 $T$ 得到逆变换公式：\n$$ T = -\\frac{1}{\\lambda} \\ln(1 - U) $$\n由于 $U$ 是一个 $\\mathrm{Unif}(0,1)$ 随机变量，变量 $U' = 1 - U$ 也是一个 $\\mathrm{Unif}(0,1)$ 随机变量。因此，该公式通常简化为 $T = -\\frac{1}{\\lambda} \\ln(U)$。然而，为了从 CDF 进行严格推导，并考虑到问题中提出的数值稳定性问题，我们将继续使用 $T = -\\frac{1}{\\lambda} \\ln(1-U)$ 的形式。在实现时，应使用一个能为较小的 $x$ 精确计算 $\\ln(1-x)$ 的函数（例如，对于较小的 `U` 使用 `log1p(-U)`）来保持数值精度，正如问题所建议的。\n\n### 2. 几何分布的到达间隔步长\n\n目标是推导一个公式，用于从成功概率为 $p \\in (0,1]$、支撑集为正整数 $\\mathbb{N} = \\{1, 2, 3, \\dots\\}$ 的几何分布中生成一个随机变量 $K$。\n\n概率质量函数 (PMF) 给出如下：\n$$ \\mathbb{P}(K = k) = (1-p)^{k-1}p \\quad \\text{for } k \\in \\{1, 2, 3, \\dots\\} $$\nCDF，$F(k) = \\mathbb{P}(K \\leq k)$，是 PMF 从 $j=1$ 到 $k$ 的和：\n$$ F(k) = \\sum_{j=1}^{k} (1-p)^{j-1}p $$\n这是一个有限几何级数。设 $q = 1-p$。其和为：\n$$ F(k) = p \\sum_{j=1}^{k} q^{j-1} = p \\left( \\frac{1 - q^k}{1 - q} \\right) $$\n将 $q = 1-p$ 代回分母：\n$$ F(k) = p \\left( \\frac{1 - (1-p)^k}{1 - (1-p)} \\right) = p \\left( \\frac{1 - (1-p)^k}{p} \\right) = 1 - (1-p)^k $$\n对于离散分布，逆变换法使用分位数函数 $Q(u) = \\inf\\{k \\in \\mathbb{N} : F(k) \\geq u\\}$。我们设 $U \\sim \\mathrm{Unif}(0,1)$ 并找到满足以下不等式的最小整数 $K$：\n$$ F(K) \\geq U $$\n$$ 1 - (1-p)^K \\geq U $$\n重新整理不等式：\n$$ 1 - U \\geq (1-p)^K $$\n为了求解 $K$，我们对两边取自然对数。由于 $p \\in (0,1]$，我们有 $1-p \\in [0,1)$。自然对数 $\\ln(x)$ 对于 $x>0$ 是一个增函数。因此，对于 $1-p \\in (0,1)$，我们有 $\\ln(1-p)  0$。取对数：\n$$ \\ln(1 - U) \\geq \\ln((1-p)^K) $$\n$$ \\ln(1 - U) \\geq K \\ln(1-p) $$\n为了分离出 $K$，我们必须除以 $\\ln(1-p)$。由于该项为负，我们必须反转不等号：\n$$ \\frac{\\ln(1 - U)}{\\ln(1-p)} \\leq K $$\n所以，$K$ 必须是大于或等于 $\\frac{\\ln(1 - U)}{\\ln(1-p)}$ 的整数。满足条件的最小整数由向上取整函数（ceiling function）给出：\n$$ K = \\left\\lceil \\frac{\\ln(1 - U)}{\\ln(1-p)} \\right\\rceil $$\n这就是对于 $p \\in (0,1)$ 所需的公式。\n\n对于 $p = 1$ 的特殊情况，PMF 为 $\\mathbb{P}(K=1) = 1$ 且对于 $k > 1$ 有 $\\mathbb{P}(K=k) = 0$。CDF 对于所有 $k \\geq 1$ 均为 $F(k)=1$。条件 $\\inf\\{k \\in \\mathbb{N} : F(k) \\geq U\\}$ 变为 $\\inf\\{k \\in \\mathbb{N} : 1 \\geq U\\}$，对于任何 $U \\in (0,1)$，其结果总是 $1$。因此，当 $p=1$ 时，$K=1$。该公式会涉及 $\\ln(0)$，所以在实现中应单独处理此情况。\n\n为了数值稳定性，特别是当 $p$ 很小时，应使用像 `log1p` 这样的函数来计算 $\\ln(1-U)$ 和 $\\ln(1-p)$，以避免精度损失。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by generating interarrival times for exponential and\n    geometric distributions using the inverse-transform method.\n    \"\"\"\n    test_cases = [\n        {'type': 'exp', 'params': {'lambda': 1.5, 'n': 5, 'seed': 42}},\n        {'type': 'geom', 'params': {'p': 0.3, 'n': 5, 'seed': 123}},\n        {'type': 'exp', 'params': {'lambda': 0.01, 'n': 5, 'seed': 7}},\n        {'type': 'geom', 'params': {'p': 0.99, 'n': 10, 'seed': 99}},\n        {'type': 'geom', 'params': {'p': 1.0, 'n': 7, 'seed': 555}},\n        {'type': 'exp', 'params': {'lambda': 10.0, 'n': 8, 'seed': 2023}},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_type = case['type']\n        params = case['params']\n        n = params['n']\n        seed = params['seed']\n        \n        # Create a new Random Number Generator for each case with the specified seed\n        rng = np.random.default_rng(seed)\n        \n        # Generate n independent draws from Unif(0,1)\n        # The numpy.random.random() function generates numbers in the interval [0.0, 1.0)\n        # For the derivation F^{-1}(U), U should be in (0,1).\n        # A value of U=0 is possible. For exponential, log1p(-0) = 0, T=0.\n        # For geometric, log1p(-0)/log1p(-p) = 0, ceil(0)=0. However, support starts at 1.\n        # The quantile formula inf{k: F(k)>=u} handles u=0 correctly if F(k) are positive. F(0)=0.\n        # We will proceed with U in [0,1) as generated by rng.random().\n        \n        U = rng.random(size=n)\n        \n        if case_type == 'exp':\n            lambda_val = params['lambda']\n            # Using T = -(1/lambda) * log(1-U), implemented with numerically stable log1p(-U)\n            # This handles U near 0 gracefully.\n            samples = -(1/lambda_val) * np.log1p(-U)\n            # Convert to a standard Python list for formatting\n            samples_list = samples.tolist()\n\n        elif case_type == 'geom':\n            p_val = params['p']\n            \n            # Handle the special case p=1.0\n            if p_val == 1.0:\n                # Interarrival time is always 1\n                samples = np.ones(n, dtype=int)\n            else:\n                # Using K = ceil(log(1-U)/log(1-p))\n                # Both logarithms are implemented with numerically stable log1p\n                numerator = np.log1p(-U)\n                denominator = np.log1p(-p_val)\n                samples = np.ceil(numerator / denominator)\n                # The result must be integer-valued. A result of 0 is possible if U is very\n                # close to 0 but not exactly 0. The support is {1,2,...}.\n                # If U == 0, the inequality F(k) >= 0 is solved by k=1 for any p1.\n                # So the result should be 1.\n                samples[samples == 0] = 1\n                samples = samples.astype(int)\n\n            # Convert to a standard Python list for formatting\n            samples_list = samples.tolist()\n\n        # Format the list of numbers into a string '[v1,v2,...]' without spaces\n        formatted_list = f\"[{','.join(map(str, samples_list))}]\"\n        all_results.append(formatted_list)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一旦我们能够生成随机事件时间，下一步就是构建模拟引擎本身。本练习将指导您为一个 $GI/G/1$ 队列构建一个完整的下一事件模拟，这是排队论中代表许多单服务器系统的基石模型。通过跟踪系统状态并在事件之间跳跃时钟，您将实现驱动离散事件模拟的核心逻辑，并计算客户等待时间等关键性能指标。",
            "id": "3303619",
            "problem": "您需要实现一个类型为 $GI/G/1$（一般独立到达过程/一般服务时间/单服务台）的单服务台排队系统的下一事件离散事件模拟，该系统遵循先到先服务（FCFS）原则，使用由指定的有限到达间隔时间序列和指定的有限服务时间序列构成的预定到达。目标是为每个提供的测试用例计算系统中顾客的经验等待时间分布。\n\n基本原理和定义：$GI/G/1$ 队列由一个到达过程定义，其中到达间隔时间是独立的，且可能非同分布；服务时间也是独立的，且可能非同分布。对于一个给定的有限到达间隔时间序列 $\\{a_1, a_2, \\ldots, a_n\\}$ 和一个有限服务时间序列 $\\{s_1, s_2, \\ldots, s_n\\}$，预定的到达时间通过对每个 $k \\in \\{1,2,\\ldots,n\\}$ 计算累积和 $t_k = \\sum_{i=1}^{k} a_i$ 来构建。服务台在 FCFS 原则下一次只服务一位顾客。顾客 $k$ 的等待时间 $w_k$ 是其预定到达时间 $t_k$ 与其服务开始时间之间的时间段。服务完成时间及由此产生的队列状态由事件调度确定。\n\n事件处理策略：如果一个到达事件和一个离开事件被安排在同一时间，则在处理到达事件之前先处理离开事件。此决胜规则确保在时间 $t$ 到达的顾客，若其到达时间与在时间 $t$ 预定的离开事件重合，将观察到服务台为空闲状态，并能立即开始服务。\n\n实现要求：您必须实现一个下一事件模拟，该模拟：\n- 在时间 $0$ 初始化系统，此时服务台空闲且队列为空。\n- 按时间非递减顺序处理事件，总是将模拟时钟跳转到下一个事件的时间。\n- 在时间 $t_k$ 发生到达事件时，如果服务台空闲，顾客的服务在时间 $t_k$ 开始；否则，顾客加入队列。\n- 在发生离开事件时，如果队列非空，则按 FCFS 顺序的下一位顾客在离开事件发生时立即开始服务；否则，服务台变为空闲。\n- 记录 $n$ 位顾客中每位的等待时间 $w_k$，其值为服务开始时间减去 $t_k$。\n\n经验分布要求：对于一个给定的有限阈值列表 $\\{x_1, x_2, \\ldots, x_m\\}$，计算在每个阈值下的等待时间经验累积分布函数（ECDF），定义为\n$$\\hat{F}(x_j) = \\frac{1}{n} \\sum_{k=1}^{n} \\mathbf{1}\\{w_k \\leq x_j\\}, \\quad j = 1,2,\\ldots,m,$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。所有时间量均以任意一致的时间单位计量，经验累积概率必须以小数表示。\n\n测试套件：您的程序必须为以下四个参数集计算 ECDF 值。对于每个测试用例，请使用指定的到达间隔序列、服务序列和阈值。所有数字都应被视为精确实数值。\n\n- 测试用例 $1$（中等变异性，典型负载）：\n  到达间隔时间 $[1.0, 0.4, 0.8, 1.5, 0.7]$，\n  服务时间 $[0.5, 1.2, 0.3, 0.6, 0.9]$，\n  阈值 $[0.0, 0.2, 0.5, 1.0]$。\n\n- 测试用例 $2$（高负载，持续排队）：\n  到达间隔时间 $[0.2, 0.2, 0.2, 0.2, 0.2, 0.2]$，\n  服务时间 $[0.5, 0.7, 0.4, 0.6, 0.8, 0.9]$，\n  阈值 $[0.0, 0.5, 1.0, 1.5]$。\n\n- 测试用例 $3$（空闲间隙与短暂突发，多次零等待）：\n  到达间隔时间 $[3.0, 0.1, 5.0, 0.2]$，\n  服务时间 $[0.5, 0.4, 0.3, 0.2]$，\n  阈值 $[0.0, 0.1, 0.4, 0.8]$。\n\n- 测试用例 $4$（服务时间为零的边界行为）：\n  到达间隔时间 $[1.0, 1.0, 1.0]$，\n  服务时间 $[0.0, 0.0, 0.0]$，\n  阈值 $[0.0, 0.001]$。\n\n输出规格：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须是扁平的，并且必须按顺序连接每个测试用例的 ECDF 值，这些值按其阈值出现的顺序排列。也就是说，如果测试用例 $i$ 在其阈值下的 ECDF 值为 $[v_{i,1}, v_{i,2}, \\ldots, v_{i,m_i}]$，那么最终输出必须是\n$$[v_{1,1},\\,v_{1,2},\\,\\ldots,\\,v_{1,m_1},\\,v_{2,1},\\,\\ldots,\\,v_{2,m_2},\\,v_{3,1},\\,\\ldots,\\,v_{3,m_3},\\,v_{4,1},\\,\\ldots,\\,v_{4,m_4}].$$",
            "solution": "用户想要模拟一个 $GI/G/1$ 队列。\n\n### 步骤 1：提取已知条件\n- **系统模型**：指定为 $GI/G/1$（一般独立到达过程，一般服务时间，单服务台）的单服务台排队系统。\n- **服务原则**：先到先服务（FCFS）。\n- **输入数据**：一个有限的到达间隔时间序列 $\\{a_1, a_2, \\ldots, a_n\\}$ 和一个有限的服务时间序列 $\\{s_1, s_2, \\ldots, s_n\\}$。\n- **到达时间定义**：顾客 $k$ 的预定到达时间为 $t_k = \\sum_{i=1}^{k} a_i$。\n- **等待时间定义**：顾客 $k$ 的等待时间 $w_k$ 是其预定到达时间 $t_k$ 与其服务开始时间之间的时间段。\n- **初始条件**：在时间 $t=0$ 时，服务台空闲且队列为空。\n- **事件处理决胜规则**：如果一个到达事件和一个离开事件被安排在同一时间，则先处理离开事件。\n- **输出要求**：为给定的一组阈值 $\\{x_j\\}$，计算等待时间的经验累积分布函数（ECDF），即 $\\hat{F}(x_j) = \\frac{1}{n} \\sum_{k=1}^{n} \\mathbf{1}\\{w_k \\leq x_j\\}$。\n- **测试用例**：\n    - **测试用例 1**：\n        - 到达间隔时间：$[1.0, 0.4, 0.8, 1.5, 0.7]$\n        - 服务时间：$[0.5, 1.2, 0.3, 0.6, 0.9]$\n        - 阈值：$[0.0, 0.2, 0.5, 1.0]$\n    - **测试用例 2**：\n        - 到达间隔时间：$[0.2, 0.2, 0.2, 0.2, 0.2, 0.2]$\n        - 服务时间：$[0.5, 0.7, 0.4, 0.6, 0.8, 0.9]$\n        - 阈值：$[0.0, 0.5, 1.0, 1.5]$\n    - **测试用例 3**：\n        - 到达间隔时间：$[3.0, 0.1, 5.0, 0.2]$\n        - 服务时间：$[0.5, 0.4, 0.3, 0.2]$\n        - 阈值：$[0.0, 0.1, 0.4, 0.8]$\n    - **测试用例 4**：\n        - 到达间隔时间：$[1.0, 1.0, 1.0]$\n        - 服务时间：$[0.0, 0.0, 0.0]$\n        - 阈值：$[0.0, 0.001]$\n- **输出格式**：一个单行，包含一个逗号分隔的列表，其中包含所有测试用例的所有 ECDF 值，按顺序连接，并用方括号括起。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：问题描述了 $GI/G/1$ 队列的模拟，这是排队论和随机模拟中的一个经典模型。所提出的方法（下一事件模拟）和要计算的量（等待时间，ECDF）都是标准的且定义明确。所有概念都牢固地基于数学和运筹学的既定原则。\n- **良构性**：该问题是良构的。给定有限的、确定性的到达间隔和服务时间序列，系统的演化是确定性的。每个测试用例都存在唯一的等待时间序列，从而产生唯一的 ECDF。所有必要的参数和初始条件都已提供。\n- **客观性**：问题以精确、客观的语言陈述。关键术语如等待时间、FCFS 原则和决胜规则都得到了明确定义，没有留下任何歧义的空间。\n- **总体评估**：该问题没有违反任何无效性标准。它是离散事件模拟领域一个完整、一致且科学合理的问题。\n\n### 步骤 3：结论与行动\n问题有效。将提供解决方案。\n\n该问题要求实现一个单服务台队列（$GI/G/1$）的下一事件模拟，该队列采用先到先服务（FCFS）原则。模拟的目标是为一组有限的 $n$ 个顾客计算经验等待时间分布，这些顾客的到达间隔和服务时间是预先确定的。\n\n这个离散事件模拟的核心原则是随时间跟踪系统的状态。对于单服务台队列，最关键的状态变量是服务台变为空闲的时间。我们将此变量表示为 $T_{free}$。模拟时钟不以固定增量前进，而是从一个事件跳转到下一个事件。由于到达时间是预先安排好的，我们可以从 $k=1, 2, \\ldots, n$ 顺序处理顾客。\n\n模拟逻辑如下：\n1. **初始化**：系统在时间 $t=0$ 时以空队列和空闲服务台开始。这通过将初始服务台空闲时间设置为 $T_{free} = 0$ 来建模。我们还需要为每个顾客 $k$ 计算绝对到达时间 $t_k$。给定到达间隔时间 $\\{a_1, a_2, \\ldots, a_n\\}$，第 $k$ 个顾客的到达时间是 $t_k = \\sum_{i=1}^{k} a_i$。我们可以为所有 $k$ 预先计算这些值。\n\n2. **顺序顾客处理**：我们从 $1$ 到 $n$ 遍历每个顾客 $k$。对于每个顾客 $k$，根据其到达时间 $t_k$ 和服务时间 $s_k$，我们确定其等待时间 $w_k$。\n\n3. **等待时间计算**：在时间 $t_k$ 到达的顾客 $k$ 只有在两个条件都满足时才能开始服务：顾客已到达，且服务台空闲。服务台在时间 $T_{free}$（来自前一个顾客，或初始为 $0$）变为空闲。因此，顾客 $k$ 的服务将在时间 $T_{start,k} = \\max(t_k, T_{free})$ 开始。\n\n等待时间 $w_k$ 定义为顾客到达和服务开始之间的时间差。\n$$w_k = T_{start,k} - t_k$$\n代入 $T_{start,k}$ 的表达式，我们得到：\n$$w_k = \\max(t_k, T_{free}) - t_k = \\max(0, T_{free} - t_k)$$\n这个表达式正确地显示，一个顾客只有当他在服务台空闲之前到达时（$t_k  T_{free}$）才会等待（$w_k > 0$）。指定的决胜规则（离开先于到达）被自然地处理了：如果一个顾客在服务台变为空闲的精确时刻到达（$t_k = T_{free}$），他的等待时间为 $w_k = \\max(0, T_{free} - T_{free}) = 0$。\n\n4. **状态更新**：一旦顾客 $k$ 在 $T_{start,k}$ 开始服务，服务台将在其服务时间 $s_k$ 期间处于忙碌状态。因此，服务台将在新的时间 $T_{free, new} = T_{start,k} + s_k$ 再次变为空闲。这个更新后的 $T_{free}$ 值将用于下一个顾客 $k+1$。这种迭代更新构成了模拟的核心。对于 $k=1$，初始 $T_{free}$ 为 $0$，所以 $w_1 = \\max(0, 0 - t_1) = 0$，这是正确的，因为第一个顾客从不等待。\n\n5. **经验分布计算**：在遍历所有 $n$ 个顾客并记录他们的等待时间 $\\{w_1, w_2, \\ldots, w_n\\}$ 之后，我们计算在给定阈值 $\\{x_1, x_2, \\ldots, x_m\\}$ 下的经验累积分布函数（ECDF）。ECDF $\\hat{F}(x_j)$ 是等待时间小于或等于阈值 $x_j$ 的顾客所占的比例。\n$$\\hat{F}(x_j) = \\frac{1}{n} \\sum_{k=1}^{n} \\mathbf{1}\\{w_k \\leq x_j\\}$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，如果条件为真则为 $1$，否则为 $0$。为每个测试用例的每个给定阈值 $x_j$ 计算此值。\n对于给定的输入，整个过程是确定性的，并通过为每个测试用例顺序应用这些步骤来实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a GI/G/1 queue simulation and computes ECDF of waiting times\n    for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"interarrivals\": [1.0, 0.4, 0.8, 1.5, 0.7],\n            \"services\": [0.5, 1.2, 0.3, 0.6, 0.9],\n            \"thresholds\": [0.0, 0.2, 0.5, 1.0]\n        },\n        {\n            \"interarrivals\": [0.2, 0.2, 0.2, 0.2, 0.2, 0.2],\n            \"services\": [0.5, 0.7, 0.4, 0.6, 0.8, 0.9],\n            \"thresholds\": [0.0, 0.5, 1.0, 1.5]\n        },\n        {\n            \"interarrivals\": [3.0, 0.1, 5.0, 0.2],\n            \"services\": [0.5, 0.4, 0.3, 0.2],\n            \"thresholds\": [0.0, 0.1, 0.4, 0.8]\n        },\n        {\n            \"interarrivals\": [1.0, 1.0, 1.0],\n            \"services\": [0.0, 0.0, 0.0],\n            \"thresholds\": [0.0, 0.001]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        interarrivals = case[\"interarrivals\"]\n        services = case[\"services\"]\n        thresholds = case[\"thresholds\"]\n\n        num_customers = len(interarrivals)\n        \n        # 1. Calculate absolute arrival times from interarrival times.\n        arrival_times = np.cumsum(interarrivals)\n        \n        # 2. Simulate the queue to get waiting times for each customer.\n        waiting_times = np.zeros(num_customers)\n        server_free_time = 0.0\n        \n        for k in range(num_customers):\n            # Get arrival and service time for customer k.\n            t_k = arrival_times[k]\n            s_k = services[k]\n            \n            # Service begins at the maximum of arrival time and when the server is free.\n            service_start_time = max(t_k, server_free_time)\n            \n            # Waiting time is the delay between arrival and service start.\n            w_k = service_start_time - t_k\n            waiting_times[k] = w_k\n            \n            # Update the time the server will become free for the next customer.\n            server_free_time = service_start_time + s_k\n            \n        # 3. Compute the ECDF for the given thresholds.\n        n_float = float(num_customers)\n        for x_j in thresholds:\n            # Count customers with waiting time = threshold.\n            count = np.sum(waiting_times = x_j)\n            # ECDF is the fraction of such customers.\n            ecdf_value = count / n_float\n            all_results.append(ecdf_value)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "运行模拟以获得高精度估计可能需要巨大的计算成本。本练习介绍了一种强大的方差缩减技术——控制变量法，它利用关于系统的已知信息来提高我们估计量的效率。您将使用 M/M/1 队列中理论上已知的服务器利用率来减少平均顾客延迟估计的方差，从而展示统计洞察力如何带来更高效的模拟。",
            "id": "3303623",
            "problem": "考虑一个具有马尔可夫到达和马尔可夫服务时间 (M/M/1) 的单服务台排队系统，其到达率 $\\lambda = 0.8$ 作业/秒，服务率 $\\mu = 1.0$ 作业/秒。在一次离散事件仿真（Discrete-Event Simulation (DES)）中，您运行了 $m$ 次独立的稳态重复实验，每次实验都移除了足够长的预热期。在每次重复实验 $j$ 中，您记录了两个统计量：系统中顾客延迟的样本均值，记为 $D_{j}$（单位：秒），以及服务器繁忙时间的时均比例（服务器利用率），记为 $U_{j}$（无量纲）。令 $\\rho = \\lambda / \\mu$ 表示稳态服务器利用率，该值可从基本原理得知。\n\n您希望使用控制变量法（Control Variate (CV)）来减小平均延迟 $\\mathbb{E}[D]$ 的蒙特卡洛估计量的方差。定义经控制变量调整后的每次重复实验的估计量为 $D^{*}_{j} = D_{j} - c \\left(U_{j} - \\rho\\right)$，其中 $c$ 是一个待选系数。\n\n从期望、方差和协方差的基本定义出发，利用服务器利用率构建控制变量，推导使 $\\operatorname{Var}(D^{*}_{j})$ 最小化的最优系数 $c^{*}$，并表示当 $c = c^{*}$ 时可实现的方差缩减比 $R = \\operatorname{Var}(D^{*}_{j}) / \\operatorname{Var}(D_{j})$。\n\n一次包含 $m_{0} = 200$ 次重复实验的预实验得出了以下可靠的汇总统计量：样本方差 $\\widehat{\\operatorname{Var}}(D_{j}) = 9.0$ (平方秒)，样本方差 $\\widehat{\\operatorname{Var}}(U_{j}) = 0.16$ (无量纲的平方)，以及样本协方差 $\\widehat{\\operatorname{Cov}}(D_{j}, U_{j}) = 1.0$ (秒)。请将这些预实验的值作为总体量的置换估计值代入您的推导中，以计算 $c^{*}$ (单位：秒) 和 $R$ (无单位)。将您的最终数值答案四舍五入到四位有效数字。系数以秒为单位，方差缩减比以无单位的小数表示。",
            "solution": "该问题要求推导控制变量估计量的最优系数及由此产生的方差缩减，然后使用提供的预实验数据进行数值计算。所考虑的系统是一个具有马尔可夫到达和服务时间 (M/M/1) 的单服务台排队系统。令 $\\lambda$ 为到达率，$\\mu$ 为服务率。\n\n关注的量是系统中的平均顾客延迟 $\\mathbb{E}[D]$。来自重复实验 $j$ 的主要估计量是样本平均延迟 $D_j$。引入一个控制变量 $U_j$，即重复实验 $j$ 中的服务器繁忙时间的时均比例。从排队论可知，该控制变量的期望值是稳态服务器利用率 $\\rho = \\frac{\\lambda}{\\mu}$。\n\n经控制变量调整的估计量定义为：\n$$D^{*}_{j} = D_{j} - c \\left(U_{j} - \\rho\\right)$$\n其中 $c$ 是一个待优化的系数。\n\n首先，我们验证 $D^{*}_{j}$ 是 $\\mathbb{E}[D_j]$ 的一个无偏估计量。$D^{*}_{j}$ 的期望是：\n$$\\mathbb{E}[D^{*}_{j}] = \\mathbb{E}[D_{j} - c \\left(U_{j} - \\rho\\right)] = \\mathbb{E}[D_{j}] - c \\left(\\mathbb{E}[U_{j}] - \\mathbb{E}[\\rho]\\right)$$\n由于 $U_j$ 是来自稳态重复实验的样本平均利用率，其期望是真实的稳态利用率，即 $\\mathbb{E}[U_{j}] = \\rho$。因为 $\\rho$ 是一个常数，所以 $\\mathbb{E}[\\rho]=\\rho$。因此：\n$$\\mathbb{E}[D^{*}_{j}] = \\mathbb{E}[D_{j}] - c(\\rho - \\rho) = \\mathbb{E}[D_{j}]$$\n这证实了控制变量估计量是无偏的。\n\n接下来，我们推导 $D^{*}_{j}$ 的方差，以找到使其最小化的最优系数 $c^*$。$D^{*}_{j}$ 的方差是 $c$ 的函数：\n$$\\operatorname{Var}(D^{*}_{j}) = \\operatorname{Var}\\left(D_{j} - c \\left(U_{j} - \\rho\\right)\\right)$$\n由于 $\\rho$ 是一个常数，$\\operatorname{Var}(U_j - \\rho) = \\operatorname{Var}(U_j)$。使用随机变量线性组合的方差公式 $\\operatorname{Var}(X - aY) = \\operatorname{Var}(X) + a^2 \\operatorname{Var}(Y) - 2a \\operatorname{Cov}(X, Y)$，我们有：\n$$\\operatorname{Var}(D^{*}_{j}) = \\operatorname{Var}(D_{j}) + c^2 \\operatorname{Var}(U_{j}) - 2c \\operatorname{Cov}(D_{j}, U_{j})$$\n这个表达式是关于 $c$ 的二次函数。为了找到使该方差最小化的 $c$ 值，我们对其关于 $c$ 求导并令其为零：\n$$\\frac{d}{dc} \\operatorname{Var}(D^{*}_{j}) = 2c \\operatorname{Var}(U_{j}) - 2 \\operatorname{Cov}(D_{j}, U_{j})$$\n将导数设为零，得到：\n$$2c^{*} \\operatorname{Var}(U_{j}) - 2 \\operatorname{Cov}(D_{j}, U_{j}) = 0$$\n解出最优系数 $c^*$:\n$$c^{*} = \\frac{\\operatorname{Cov}(D_{j}, U_{j})}{\\operatorname{Var}(U_{j})}$$\n\n现在我们确定方差缩减比 $R$。首先，我们将 $c^*$ 代入 $\\operatorname{Var}(D^{*}_{j})$ 的表达式中，求出最小方差：\n$$\\operatorname{Var}(D^{*}_{j})|_{c=c^{*}} = \\operatorname{Var}(D_{j}) + \\left(\\frac{\\operatorname{Cov}(D_{j}, U_{j})}{\\operatorname{Var}(U_{j})}\\right)^2 \\operatorname{Var}(U_{j}) - 2 \\left(\\frac{\\operatorname{Cov}(D_{j}, U_{j})}{\\operatorname{Var}(U_{j})}\\right) \\operatorname{Cov}(D_{j}, U_{j})$$\n$$\\operatorname{Var}(D^{*}_{j})|_{c=c^{*}} = \\operatorname{Var}(D_{j}) + \\frac{\\operatorname{Cov}(D_{j}, U_{j})^2}{\\operatorname{Var}(U_{j})} - 2 \\frac{\\operatorname{Cov}(D_{j}, U_{j})^2}{\\operatorname{Var}(U_{j})}$$\n$$\\operatorname{Var}(D^{*}_{j})|_{c=c^{*}} = \\operatorname{Var}(D_{j}) - \\frac{\\operatorname{Cov}(D_{j}, U_{j})^2}{\\operatorname{Var}(U_{j})}$$\n方差缩减比 $R$ 是新方差与原始方差的比率：\n$$R = \\frac{\\operatorname{Var}(D^{*}_{j})|_{c=c^{*}}}{\\operatorname{Var}(D_{j})} = \\frac{\\operatorname{Var}(D_{j}) - \\frac{\\operatorname{Cov}(D_{j}, U_{j})^2}{\\operatorname{Var}(U_{j})}}{\\operatorname{Var}(D_{j})}$$\n$$R = 1 - \\frac{\\operatorname{Cov}(D_{j}, U_{j})^2}{\\operatorname{Var}(D_{j}) \\operatorname{Var}(U_{j})}$$\n这也可以用相关系数的平方 $\\rho_{DU}^2 = \\frac{\\operatorname{Cov}(D_{j}, U_{j})^2}{\\operatorname{Var}(D_{j})\\operatorname{Var}(U_{j})}$ 来表示，即 $R = 1 - \\rho_{DU}^2$。\n\n问题提供了来自预实验的汇总统计数据，用作未知总体量的置换估计值：\n- 延迟的样本方差：$\\widehat{\\operatorname{Var}}(D_{j}) = 9.0$ 平方秒。\n- 利用率的样本方差：$\\widehat{\\operatorname{Var}}(U_{j}) = 0.16$ 无量纲的平方。\n- 样本协方差：$\\widehat{\\operatorname{Cov}}(D_{j}, U_{j}) = 1.0$ 秒。\n\n现在我们可以计算最优系数 $c^*$ 的数值估计：\n$$c^{*} \\approx \\hat{c}^{*} = \\frac{\\widehat{\\operatorname{Cov}}(D_{j}, U_{j})}{\\widehat{\\operatorname{Var}}(U_{j})} = \\frac{1.0}{0.16} = 6.25 \\text{ 秒}$$\n四舍五入到四位有效数字，我们得到 $c^{*} = 6.250$ 秒。\n\n接下来，我们计算方差缩减比 $R$ 的数值估计：\n$$R \\approx \\hat{R} = 1 - \\frac{\\widehat{\\operatorname{Cov}}(D_{j}, U_{j})^2}{\\widehat{\\operatorname{Var}}(D_{j}) \\widehat{\\operatorname{Var}}(U_{j})} = 1 - \\frac{(1.0)^2}{(9.0)(0.16)} = 1 - \\frac{1.0}{1.44}$$\n$$R \\approx 1 - 0.69444... = 0.30555...$$\n四舍五入到四位有效数字，我们得到 $R = 0.3056$。这个值是无单位的。$R \\approx 0.3056$ 的值意味着使用控制变量将平均延迟估计量的方差减小了约 $1/0.3056 \\approx 3.27$ 倍，或者说方差缩减了约 $69.4\\%$。\n\n最终的数值结果是最优系数 $c^*$ 和方差缩减比 $R$。\n- 系数 $c^{*}$ 是 $6.250$ 秒。\n- 方差缩减比 $R$ 是 $0.3056$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6.250  0.3056\n\\end{pmatrix}\n}\n$$"
        }
    ]
}