{
    "hands_on_practices": [
        {
            "introduction": "布朗运动的一个显著特征是其路径的极端不规则性：它们是连续的，但处处不可微。本实践旨在通过计算p阶变差（p-variation）来量化这种“粗糙度”。你将通过模拟来凭经验验证一个核心结论：当 $p=2$ 时，离散变差和收敛到一个有限值（即二次变差），而当 $p \\lt 2$ 时则会发散，这揭示了布朗运动路径的独特几何性质。",
            "id": "3341139",
            "problem": "考虑一个标准布朗运动 $B_t$，定义在区间 $[0,T]$上，且$B_0=0$。它被定义为一个连续时间随机过程，具有独立、平稳的高斯增量，因此对于任意 $t \\ge 0$ 和 $h0$，有 $B_{t+h}-B_t \\sim \\mathcal{N}(0,h)$，并且其路径是连续的。对于 $[0,T]$ 的一个均匀划分，将其分为 $N$ 个子区间，定义 $t_k = kT/N$（其中 $k=0,1,\\dots,N$），以及离散的 $p$-变差和\n$$\nS_p(N) \\;=\\; \\sum_{k=0}^{N-1} \\left|B_{t_{k+1}} - B_{t_k}\\right|^p.\n$$\n您将通过模拟 $B_t$ 的独立样本路径并汇总各路径结果，以经验性地分析当 $N$ 增大时，$S_p(N)$ 对于不同 $p$ 值的行为。您的模拟必须使用基本构造方法，即每个增量 $B_{t_{k+1}}-B_{t_k}$ 都是通过生成一个均值为 $0$、方差为 $t_{k+1}-t_k = T/N$ 的高斯随机变量得到的。\n\n您的程序必须：\n- 针对多种划分大小 $N$，在 $[0,T]$ 上模拟 $M$ 条独立的 $B_t$ 样本路径，且不调用任何关于 $S_p(N)$ 行为的快捷公式。\n- 对于测试套件中给定的每个 $p$ 值，计算在 $M$ 条路径上针对每个划分大小 $N$ 的平均 $p$-变差 $\\overline{S}_p(N)$。\n- 通过对 $\\log \\overline{S}_p(N)$ 与 $\\log N$ 进行简单线性回归拟合，并提取斜率（记为 $b_p$），来估计 $\\overline{S}_p(N)$ 相对于 $N$ 的标度行为。\n- 使用 $b_p$ 来判断序列 $\\overline{S}_p(N)$ 表现为发散（随 $N$ 增大）、近似稳定（不随 $N$ 系统性地增大或减小）还是收敛（随 $N$ 减小）。\n- 对于 $p=2$ 的情况，还需评估在最精细的划分下 $\\overline{S}_2(N)$ 是否接近时间范围 $T$，以验证二次变差的稳定性。\n\n在此任务中，所有量均为无量纲，且不涉及角度。\n\n测试套件规范：\n- 时间范围 $T=1$。\n- 独立路径数量 $M=600$。\n- 划分大小 $N \\in \\{256, 512, 1024, 2048, 4096\\}$。\n- 三个 $p$ 值：$p_1=1.5$，$p_2=2.0$，$p_3=3.0$。\n\n用于产生可量化输出的决策规则：\n- 对于 $p_1=1.5$，如果 $b_{p_1} > 0.1$，则声明“发散”；否则声明“不发散”。\n- 对于 $p_2=2.0$，如果 $\\lvert b_{p_2} \\rvert  0.1$，则声明“稳定标度”；此外，如果 $\\lvert \\overline{S}_{2}(4096) - T \\rvert  0.15$，则声明“二次变差接近 $T$”。\n- 对于 $p_3=3.0$，如果 $b_{p_3}  -0.1$，则声明“收敛”；否则声明“不收敛”。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$$\n[\\text{diverge}_{p_1}, \\text{stable}_{p_2}, \\text{qv\\_close}_{p_2}, \\text{converge}_{p_3}],\n$$\n其中每个条目都是遵循上述决策规则的布尔值，$\\text{diverge}_{p_1}$ 对应于 $p_1=1.5$，$\\text{stable}_{p_2}$ 和 $\\text{qv\\_close}_{p_2}$ 对应于 $p_2=2.0$，而 $\\text{converge}_{p_3}$ 对应于 $p_3=3.0$。例如，输出可能如下所示：\n$$\n[\\text{True},\\text{True},\\text{True},\\text{True}].\n$$",
            "solution": "问题陈述是有效的。它涉及对标准布朗运动路径性质的经验性验证，这是一个定义明确且基础的随机过程。所有参数、方法论和决策标准都已明确指定，构成了一个在随机模拟领域中自洽且科学上合理的计算问题。\n\n问题的核心是分析离散 $p$-变差和的行为：\n$$\nS_p(N) = \\sum_{k=0}^{N-1} \\left|B_{t_{k+1}} - B_{t_k}\\right|^p,\n$$\n对于定义在区间 $[0, T]$ 上的标准布朗运动 $B_t$。时间区间被均匀划分为 $N$ 个长度为 $\\Delta t = T/N$ 的子区间，划分点为 $t_k = k \\Delta t$。\n\n### 1. 模拟原理\n始于 $B_0=0$ 的标准布朗运动 $B_t$ 由其增量来表征。对于任意 $t \\ge 0$ 和 $h  0$，增量 $B_{t+h} - B_t$ 是一个均值为 $0$、方差为 $h$ 的高斯随机变量，记为 $B_{t+h} - B_t \\sim \\mathcal{N}(0, h)$。此外，在不重叠时间区间上的增量是独立的。\n\n我们的模拟策略直接建立在该定义之上。为了在离散网格 $\\{t_k\\}_{k=0}^N$ 上构造样本路径，我们生成增量序列 $\\Delta B_k = B_{t_{k+1}} - B_{t_k}$，其中 $k=0, \\dots, N-1$。由于时间步长是均匀的，$\\Delta t = t_{k+1} - t_k = T/N$，因此每个增量都是从同一分布 $\\Delta B_k \\sim \\mathcal{N}(0, T/N)$ 中独立抽取的。路径本身可以通过 $B_{t_k} = \\sum_{i=0}^{k-1} \\Delta B_i$ 重建，但为了计算 $S_p(N)$，我们只需要增量 $\\Delta B_k$。\n\n该算法生成 $M$ 条独立路径，这意味着我们将生成一整套 $N$ 个增量的过程重复 $M$ 次。对于每条路径和每个指定的 $p$ 值，我们计算 $S_p(N)$。然后将结果在 $M$ 条路径上取平均，得到期望 $\\mathbb{E}[S_p(N)]$ 的一个稳定估计 $\\overline{S}_p(N)$。\n\n### 2. 标度分析\n$S_p(N)$ 在 $N \\to \\infty$ 时的理论行为是随机分析的基石。我们可以预测其期望随 $N$ 的标度关系。令 $Z_k = \\Delta B_k / \\sqrt{T/N}$ 为一个标准正态变量，$Z_k \\sim \\mathcal{N}(0,1)$。\n$p$-变差和的期望值为：\n$$\n\\mathbb{E}[S_p(N)] = \\mathbb{E}\\left[\\sum_{k=0}^{N-1} |\\Delta B_k|^p\\right] = \\sum_{k=0}^{N-1} \\mathbb{E}\\left[\\left|\\sqrt{T/N} Z_k\\right|^p\\right]\n$$\n根据期望的线性性质以及增量是同分布的，\n$$\n\\mathbb{E}[S_p(N)] = N \\cdot \\mathbb{E}\\left[| \\sqrt{T/N} Z |^p\\right] = N \\cdot (T/N)^{p/2} \\cdot \\mathbb{E}[|Z|^p] = N^{1-p/2} \\cdot T^{p/2} \\mathbb{E}[|Z|^p]\n$$\n其中 $Z \\sim \\mathcal{N}(0,1)$。对于给定的 $p$ 和 $T$，项 $T^{p/2} \\mathbb{E}[|Z|^p]$ 是一个常数。因此，期望值随 $N$ 的标度关系为 $\\mathbb{E}[S_p(N)] \\propto N^{1-p/2}$。\n\n对这个关系式取自然对数，得到：\n$$\n\\log(\\mathbb{E}[S_p(N)]) \\approx C_p + (1-p/2) \\log N\n$$\n其中 $C_p$ 是一个常数。这表明 $\\log \\overline{S}_p(N)$（我们对 $\\log \\mathbb{E}[S_p(N)]$ 的经验估计）与 $\\log N$ 之间存在线性关系。这条线的斜率就是标度指数 $b_p = 1 - p/2$。\n\n问题要求我们通过对给定的划分大小 $N \\in \\{256, 512, 1024, 2048, 4096\\}$ 的模拟数据对 $(\\log N, \\log \\overline{S}_p(N))$ 进行简单线性回归来经验性地估计这个斜率 $b_p$。\n\n### 3. 分情况分析\n我们将此框架应用于指定的 $p$ 值：\n\n- **情况 $p_1 = 1.5$**：理论斜率为 $b_{1.5} = 1 - 1.5/2 = 1 - 0.75 = 0.25$。由于 $b_{1.5}  0$，和 $S_{1.5}(N)$ 预期会随 $N$ 增大而增大，表明其发散。发散的经验性检验是 $b_{1.5}  0.1$。\n\n- **情况 $p_2 = 2.0$（二次变差）**：理论斜率为 $b_2 = 1 - 2.0/2 = 0$。这意味着 $S_2(N)$ 不应随 $N$ 发生系统性的标度变化，而应趋于稳定。稳定性的经验性检验是 $|b_2|  0.1$。\n此外，二次变差的理论值恰好为 $T$。让我们来检验其期望：\n$$\n\\mathbb{E}[S_2(N)] = N^{1-2/2} \\cdot T^{2/2} \\mathbb{E}[|Z|^2] = N^0 \\cdot T^1 \\cdot \\mathbb{E}[Z^2]\n$$\n由于 $Z \\sim \\mathcal{N}(0,1)$，其方差为 $\\mathbb{E}[Z^2] - (\\mathbb{E}[Z])^2 = 1$。又因 $\\mathbb{E}[Z]=0$，我们得到 $\\mathbb{E}[Z^2]=1$。因此，$\\mathbb{E}[S_2(N)] = T$。我们的模拟平均值 $\\overline{S}_2(N)$ 对于所有 $N$ 都应近似于 $T$，特别是对于大的 $N$。问题要求验证是否 $|\\overline{S}_2(4096) - T|  0.15$。\n\n- **情况 $p_3 = 3.0$**：理论斜率为 $b_3 = 1 - 3.0/2 = -0.5$。由于 $b_3  0$，和 $S_3(N)$ 预期会随 $N$ 增大而减小，表明其收敛到 $0$。收敛的经验性检验是 $b_3  -0.1$。\n\n### 4. 实现\n程序实现了这一逻辑。对于每个 $p \\in \\{1.5, 2.0, 3.0\\}$，它会遍历指定的 $N$ 值。对于每个 $(p, N)$ 对，它生成一个 $M \\times N$ 的随机数矩阵，这些随机数从 $\\mathcal{N}(0, T/N)$ 分布中抽取，代表了 $M$ 条路径的增量。然后，它计算每条路径的 $p$-变差，并对结果取平均得到 $\\overline{S}_p(N)$。在收集了所有 $N$ 对应的平均值后，它计算对数值并执行线性回归以找到斜率 $b_p$。最后，它应用决策规则来生成所需的布尔值输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Empirically analyzes the p-variation of a simulated Brownian motion.\n    \"\"\"\n    # Test suite specification\n    T = 1.0\n    M = 600\n    N_values = np.array([256, 512, 1024, 2048, 4096])\n    p_values = [1.5, 2.0, 3.0]\n    \n    # Decision thresholds\n    b_diverge_threshold = 0.1\n    b_stable_threshold = 0.1\n    s2_close_threshold = 0.15\n    b_converge_threshold = -0.1\n\n    final_results = []\n\n    # Process p = 1.5\n    p1 = p_values[0]\n    avg_S_p1 = []\n    for N in N_values:\n        dt = T / N\n        std_dev = np.sqrt(dt)\n        # Generate increments for M paths simultaneously\n        increments = np.random.normal(loc=0.0, scale=std_dev, size=(M, N))\n        # Compute p-variation for each path\n        S_p_paths = np.sum(np.abs(increments)**p1, axis=1)\n        # Average across paths\n        avg_S_p1.append(np.mean(S_p_paths))\n\n    log_N = np.log(N_values)\n    log_S_p1 = np.log(avg_S_p1)\n    \n    # Perform linear regression to find the scaling exponent\n    lin_reg_p1 = stats.linregress(log_N, log_S_p1)\n    b_p1 = lin_reg_p1.slope\n    \n    # Apply decision rule for p=1.5\n    diverge_p1 = b_p1  b_diverge_threshold\n    final_results.append(diverge_p1)\n\n    # Process p = 2.0\n    p2 = p_values[1]\n    avg_S_p2 = []\n    for N in N_values:\n        dt = T / N\n        std_dev = np.sqrt(dt)\n        increments = np.random.normal(loc=0.0, scale=std_dev, size=(M, N))\n        # For p=2, abs() is unnecessary but harmless\n        S_p_paths = np.sum(increments**p2, axis=1) \n        avg_S_p2.append(np.mean(S_p_paths))\n\n    log_S_p2 = np.log(avg_S_p2)\n    \n    lin_reg_p2 = stats.linregress(log_N, log_S_p2)\n    b_p2 = lin_reg_p2.slope\n    \n    # Apply decision rules for p=2.0\n    stable_p2 = np.abs(b_p2)  b_stable_threshold\n    final_results.append(stable_p2)\n    \n    S2_at_finest_N = avg_S_p2[-1]\n    qv_close_p2 = np.abs(S2_at_finest_N - T)  s2_close_threshold\n    final_results.append(qv_close_p2)\n    \n    # Process p = 3.0\n    p3 = p_values[2]\n    avg_S_p3 = []\n    for N in N_values:\n        dt = T / N\n        std_dev = np.sqrt(dt)\n        increments = np.random.normal(loc=0.0, scale=std_dev, size=(M, N))\n        S_p_paths = np.sum(np.abs(increments)**p3, axis=1)\n        avg_S_p3.append(np.mean(S_p_paths))\n\n    log_S_p3 = np.log(avg_S_p3)\n    \n    lin_reg_p3 = stats.linregress(log_N, log_S_p3)\n    b_p3 = lin_reg_p3.slope\n    \n    # Apply decision rule for p=3.0\n    converge_p3 = b_p3  b_converge_threshold\n    final_results.append(converge_p3)\n\n    # Print final output in the required format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了布朗路径的内在性质之后，一个自然的问题是我们能多精确地模拟这些路径及其相关的量。本实践将探讨评估随机模拟精度的两种基本范式：强收敛和弱收敛。你将通过模拟三种不同的路径泛函，凭经验估计并比较欧拉-丸山（Euler-Maruyama）格式的强收敛阶和弱收敛阶，从而深入理解路径级精度和统计矩精度之间的关键差异。",
            "id": "3341137",
            "problem": "考虑一个在时间区间 $[0,T]$ 上的标准布朗运动 $B_t$，其中 $B_0 = 0$。Euler–Maruyama (EM) 方法，在此等同于用独立高斯增量模拟布朗运动，通过设置 $\\hat{B}_{t_{k+1}} = \\hat{B}_{t_k} + \\Delta B_k$（其中 $\\Delta B_k \\sim \\mathcal{N}(0,\\Delta t)$ 独立同分布，且 $t_k = k\\Delta t$ for $k=0,1,\\dots,N$），在步长为 $\\Delta t = T/N$ 的粗糙时间网格上构建一条近似路径 $\\hat{B}_t$。对于路径依赖泛函 $F(B_{[0,T]})$，定义强误差为 $\\mathbb{E}\\left[\\,|F(\\hat{B}) - F(B)|\\,\\right]$，弱误差为 $\\left|\\,\\mathbb{E}[F(\\hat{B})] - \\mathbb{E}[F(B)]\\,\\right|$，其中 $B$ 表示真实路径，$\\hat{B}$ 表示粗糙网格上的 EM 近似路径。\n\n从布朗运动的基本性质出发，即其具有独立增量 $\\Delta B_k \\sim \\mathcal{N}(0,\\Delta t)$，$\\mathbb{E}[B_t] = 0$ 且 $\\mathrm{Var}(B_t) = t$，并利用反射原理和对称性，考虑以下三个路径泛函：\n- $F_1(B) = \\int_0^T B_t^2\\,dt$，\n- $F_2(B) = \\sup_{0 \\le t \\le T} B_t$，\n- $F_3(B) = \\int_0^T \\mathbf{1}_{\\{B_t  0\\}}\\,dt$。\n\n这些泛函的精确期望由经过充分检验的事实给出：$\\mathbb{E}[F_1(B)] = \\int_0^T \\mathbb{E}[B_t^2]\\,dt = \\int_0^T t\\,dt = T^2/2$，$\\mathbb{E}[F_2(B)] = \\sqrt{2T/\\pi}$（根据反射原理，$F_2(B)$ 与 $|B_T|$ 具有相同的分布），以及 $\\mathbb{E}[F_3(B)] = T/2$（根据 $B_t$ 关于零的对称性）。\n\n为量化和比较 EM 方法对于这些泛函的强收敛与弱收敛，请按以下步骤进行。使用一个大小为 $N_{\\mathrm{ref}}$（步长为 $\\Delta t_{\\mathrm{ref}} = T/N_{\\mathrm{ref}}$）的高分辨率参考网格来定义真实路径 $B$ 的代理，并通过左黎曼和计算 $F_1$ 和 $F_3$ 的参考值 $F_i(B)$，通过细网格上的最大值计算 $F_2$ 的参考值。对于测试套件中的每个粗糙网格大小 $N$，通过对精细路径进行子采样来计算 EM 近似 $\\hat{B}$，并在粗糙网格上类似地评估 $F_i(\\hat{B})$。通过 $|F_i(\\hat{B}) - F_i(B)|$ 的蒙特卡洛平均值来估计强误差，并通过 $|\\mathbb{E}[F_i(\\hat{B})] - \\mathbb{E}[F_i(B)]|$ 来估计弱误差，其中后者使用上述指定的精确期望值。对于每个泛函，通过对强误差和弱误差相对于 $\\Delta t$ 的对数-对数图进行线性拟合来估计经验收敛率，并报告其斜率。\n\n您的程序必须实现以下测试套件和规范：\n- 使用 $T = 1$，$N_{\\mathrm{ref}} = 4096$，以及 $M = 1500$ 条独立路径的蒙特卡洛样本量。为保证可复现性，使用固定的随机种子 $12345$。\n- 使用粗糙网格大小 $N \\in \\{4,8,16,32,64\\}$，即 $\\Delta t \\in \\{T/4, T/8, T/16, T/32, T/64\\}$。\n- 使用精细网格定义参考量如下：\n  - $F_1(B) \\approx \\sum_{k=0}^{N_{\\mathrm{ref}}-1} B_{t_k}^2 \\,\\Delta t_{\\mathrm{ref}}$,\n  - $F_2(B) \\approx \\max_{0 \\le k \\le N_{\\mathrm{ref}}} B_{t_k}$,\n  - $F_3(B) \\approx \\sum_{k=0}^{N_{\\mathrm{ref}}-1} \\mathbf{1}_{\\{B_{t_k}  0\\}} \\,\\Delta t_{\\mathrm{ref}}$。\n- 在 $\\{t_k\\}_{k=0}^N$ 上类似地定义粗糙网格近似，对 $F_1$ 和 $F_3$ 使用左黎曼和，对 $F_2$ 使用网格最大值。\n- 对于每个泛函 $F_i$，计算在所有粗糙 $N$ 值上的强误差数组 $E^{\\mathrm{str}}_i(N)$ 和弱误差数组 $E^{\\mathrm{weak}}_i(N)$。然后，分别通过对 $\\log(E^{\\mathrm{str}}_i)$ 与 $\\log(\\Delta t)$ 以及 $\\log(E^{\\mathrm{weak}}_i)$ 与 $\\log(\\Delta t)$ 进行最小二乘线性拟合，计算经验强收敛率 $\\alpha_i^{\\mathrm{str}}$ 和弱收敛率 $\\alpha_i^{\\mathrm{weak}}$ 作为拟合直线的斜率。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\alpha_1^{\\mathrm{str}},\\alpha_1^{\\mathrm{weak}},\\alpha_2^{\\mathrm{str}},\\alpha_2^{\\mathrm{weak}},\\alpha_3^{\\mathrm{str}},\\alpha_3^{\\mathrm{weak}}]$，每个条目都是一个浮点数。\n\n覆盖性设计：\n- 泛函 $F_1$ 是一个平滑的积分泛函，代表了弱收敛阶数预期高于强收敛阶数的一般情况。\n- 泛函 $F_2$ 测试对网格点之间路径极值的敏感性。\n- 泛函 $F_3$ 在路径上是不连续的，用于测试跨越边界的行为。\n- 粗糙网格的大小包含小步长和中等大步长，以探究收敛趋势和边界行为。",
            "solution": "该问题要求对 Euler-Maruyama (EM) 方法在模拟标准布朗运动 $B_t$ 的泛函时的收敛性质进行实证研究。我们被要求估计三个特定路径依赖泛函的强收敛率和弱收敛率。验证证实了该问题在科学上是合理的、适定的，并且所有参数和过程都已明确定义。\n\n该方法的核心是蒙特卡洛模拟。为了对误差，特别是强误差，进行稳健的估计，我们需要一条“真实”路径和一个与之耦合的相应数值近似。问题指定了一种标准且计算高效的方法来实现这一点：我们首先模拟一条高分辨率路径，作为真实连续时间路径的足够精确的代理，然后通过子采样获得更粗糙的近似。\n\n**1. 路径生成与耦合**\n\n我们首先生成一组 $M$ 条独立的高分辨率路径。每条路径都是标准布朗运动 $B_t$ 在区间 $[0, T]$ 上的离散时间近似，其中 $B_0 = 0$。我们使用一个具有 $N_{\\mathrm{ref}}$ 步、步长为 $\\Delta t_{\\mathrm{ref}} = T/N_{\\mathrm{ref}}$ 的精细时间网格。路径由递推关系构建：\n$$\nB_{t_{k+1}} = B_{t_k} + \\sqrt{\\Delta t_{\\mathrm{ref}}} \\cdot Z_k, \\quad k = 0, 1, \\dots, N_{\\mathrm{ref}}-1\n$$\n其中 $t_k = k \\Delta t_{\\mathrm{ref}}$，$Z_k$ 是从标准正态分布 $\\mathcal{N}(0, 1)$ 中抽取的独立随机变量。这些记为 $\\{B^{(j)}\\}_{j=1}^M$ 的精细网格路径将作为我们的参考（“真实”）路径。\n\n对于每个粗糙网格大小 $N$（其中 $N$ 是 $N_{\\mathrm{ref}}$ 的一个因子），相应的近似路径 $\\hat{B}$ 是通过对精细路径 $B$ 进行子采样生成的。具体来说，如果抽取因子为 $D = N_{\\mathrm{ref}}/N$，则粗糙路径点取为 $\\hat{B}_{t_k} = B_{t_{k \\cdot D}}$，其中 $k = 0, 1, \\dots, N$。这个过程不仅计算效率高，而且在理论上也是合理的。粗糙路径的增量 $\\hat{B}_{t_{k+1}} - \\hat{B}_{t_k}$，是精细路径上 $D$ 个连续增量的和。根据正态分布的性质，这个和也是一个正态随机变量：\n$$\n\\sum_{i=kD}^{(k+1)D-1} \\sqrt{\\Delta t_{\\mathrm{ref}}} Z_i \\sim \\mathcal{N}\\left(0, \\sum_{i=kD}^{(k+1)D-1} (\\sqrt{\\Delta t_{\\mathrm{ref}}})^2\\right) = \\mathcal{N}(0, D \\cdot \\Delta t_{\\mathrm{ref}})\n$$\n由于 $D \\cdot \\Delta t_{\\mathrm{ref}} = (N_{\\mathrm{ref}}/N) \\cdot (T/N_{\\mathrm{ref}}) = T/N = \\Delta t$，粗糙路径增量 $\\Delta \\hat{B}_k$ 的分布为 $\\mathcal{N}(0, \\Delta t)$，这与 Euler-Maruyama 方法在粗糙网格上的规定完全一致。这种耦合确保了差值 $|F(\\hat{B}) - F(B)|$ 衡量的是在相同的基础噪声实现下，由更粗糙的时间离散化所引起的误差。\n\n**2. 泛函与误差估计**\n\n对于 $M$ 条生成的参考路径 $B^{(j)}$ 中的每一条及其对应的粗糙网格子样本 $\\hat{B}^{(j)}$，我们计算三个泛函的值：\n- $F_1(B) = \\int_0^T B_t^2\\,dt$\n- $F_2(B) = \\sup_{0 \\le t \\le T} B_t$\n- $F_3(B) = \\int_0^T \\mathbf{1}_{\\{B_t  0\\}}\\,dt$\n\n连续操作（积分、上确界）在离散网格上进行近似。按照规定，$F_1$ 和 $F_3$ 的积分使用左黎曼和近似，而 $F_2$ 的上确界则由网格点上的最大值近似。对于一个在具有步长 $\\delta t$ 和 $n$ 个区间的网格上的通用路径 $X$，其近似值为：\n- $F_1(X) \\approx \\sum_{k=0}^{n-1} X_{t_k}^2 \\cdot \\delta t$\n- $F_2(X) \\approx \\max_{0 \\le k \\le n} X_{t_k}$\n- $F_3(X) \\approx \\sum_{k=0}^{n-1} \\mathbf{1}_{\\{X_{t_k}  0\\}} \\cdot \\delta t$\n\n在为 $M$ 个样本中的每一个计算了参考路径 $B$ 和粗糙近似 $\\hat{B}$ 的泛函值后，我们估计强误差和弱误差。\n\n对于给定的粗糙网格大小 $N$，**强误差**通过绝对差的蒙特卡洛平均值来估计：\n$$\nE_i^{\\mathrm{str}}(N) \\approx \\frac{1}{M} \\sum_{j=1}^{M} | F_i(\\hat{B}^{(j)}) - F_i(B^{(j)}) |\n$$\n\n**弱误差**通过将粗糙网格上泛函的蒙特卡洛平均值与其精确的理论期望进行比较来估计：\n$$\nE_i^{\\mathrm{weak}}(N) = \\left| \\left( \\frac{1}{M} \\sum_{j=1}^{M} F_i(\\hat{B}^{(j)}) \\right) - \\mathbb{E}[F_i(B)] \\right|\n$$\n问题给出了精确期望：$\\mathbb{E}[F_1(B)] = T^2/2$，$\\mathbb{E}[F_2(B)] = \\sqrt{2T/\\pi}$，以及 $\\mathbb{E}[F_3(B)] = T/2$。\n\n**3. 收敛率计算**\n\n收敛率 $\\alpha$ 描述了误差 $E$ 如何随时间步长 $\\Delta t$ 变化，通常在 $\\Delta t \\to 0$ 时遵循幂律 $E(\\Delta t) \\approx C (\\Delta t)^\\alpha$，其中 $C$ 为某个常数。为了估计 $\\alpha$，我们可以通过取对数将此关系转换为线性关系：\n$$\n\\log(E(\\Delta t)) \\approx \\log(C) + \\alpha \\log(\\Delta t)\n$$\n该方程形式为 $y = m x + c$，其中 $y = \\log(E)$，$x = \\log(\\Delta t)$，斜率 $m$ 即为收敛率 $\\alpha$。\n\n我们计算每个泛函在指定的粗糙步长 $\\Delta t = T/N$ 套件上的强误差和弱误差数组。然后，对六个误差数组中的每一个，我们对 $(\\log(\\Delta t), \\log(E))$ 数据点执行普通最小二乘线性回归。所得拟合直线的斜率提供了收敛率 $\\alpha$ 的经验估计值。实现中为此使用了 `numpy.polyfit`。最终输出将包含六个估计的斜率：$\\{\\alpha_1^{\\mathrm{str}}, \\alpha_1^{\\mathrm{weak}}, \\alpha_2^{\\mathrm{str}}, \\alpha_2^{\\mathrm{weak}}, \\alpha_3^{\\mathrm{str}}, \\alpha_3^{\\mathrm{weak}}\\}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Estimates the strong and weak convergence rates of the Euler-Maruyama method\n    for three different Brownian path functionals.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    T = 1.0\n    N_ref = 4096\n    M = 1500\n    seed = 12345\n    N_coarse_list = [4, 8, 16, 32, 64]\n\n    # Initialize the random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # --- Step 1: Generate high-resolution reference paths ---\n    dt_ref = T / N_ref\n    # Generate Gaussian increments for M paths with N_ref steps.\n    increments = rng.normal(0.0, np.sqrt(dt_ref), size=(M, N_ref))\n    # Create paths by cumulative summation of increments.\n    # Paths have N_ref + 1 points, from t=0 to t=T.\n    paths_ref = np.zeros((M, N_ref + 1))\n    paths_ref[:, 1:] = np.cumsum(increments, axis=1)\n\n    # --- Step 2: Compute functional values on reference paths ---\n    # These serve as the \"true\" values for error calculation.\n    # F1(B) = integral of B_t^2 dt\n    F1_ref = np.sum(paths_ref[:, :-1]**2, axis=1) * dt_ref\n    # F2(B) = sup_{0=t=T} B_t\n    F2_ref = np.max(paths_ref, axis=1)\n    # F3(B) = integral of 1_{B_t  0} dt\n    F3_ref = np.sum(paths_ref[:, :-1]  0, axis=1) * dt_ref\n\n    # --- Step 3: Define exact expectations for weak error calculation ---\n    E_F1_exact = T**2 / 2.0\n    E_F2_exact = np.sqrt(2 * T / np.pi)\n    E_F3_exact = T / 2.0\n\n    # Dictionaries to store errors for each functional\n    strong_errors = {1: [], 2: [], 3: []}\n    weak_errors = {1: [], 2: [], 3: []}\n    delta_t_vals = []\n\n    # --- Step 4: Loop over coarse grid sizes to compute errors ---\n    for N_coarse in N_coarse_list:\n        dt_coarse = T / N_coarse\n        delta_t_vals.append(dt_coarse)\n\n        # Generate coarse paths by subsampling the fine paths.\n        decimation_factor = N_ref // N_coarse\n        paths_coarse = paths_ref[:, ::decimation_factor]\n        \n        # Compute functional values on the coarse paths.\n        F1_coarse = np.sum(paths_coarse[:, :-1]**2, axis=1) * dt_coarse\n        F2_coarse = np.max(paths_coarse, axis=1)\n        F3_coarse = np.sum(paths_coarse[:, :-1]  0, axis=1) * dt_coarse\n\n        # Estimate strong error (mean absolute difference).\n        strong_errors[1].append(np.mean(np.abs(F1_coarse - F1_ref)))\n        strong_errors[2].append(np.mean(np.abs(F2_coarse - F2_ref)))\n        strong_errors[3].append(np.mean(np.abs(F3_coarse - F3_ref)))\n\n        # Estimate weak error (absolute difference of means).\n        weak_errors[1].append(np.abs(np.mean(F1_coarse) - E_F1_exact))\n        weak_errors[2].append(np.abs(np.mean(F2_coarse) - E_F2_exact))\n        weak_errors[3].append(np.abs(np.mean(F3_coarse) - E_F3_exact))\n\n    # --- Step 5: Compute convergence rates via log-log linear regression ---\n    results = []\n    log_delta_t = np.log(np.array(delta_t_vals))\n\n    for i in range(1, 4):\n        # Strong rate\n        log_E_strong = np.log(np.array(strong_errors[i]))\n        # np.polyfit returns [slope, intercept] for degree 1.\n        slope_strong = np.polyfit(log_delta_t, log_E_strong, 1)[0]\n        results.append(slope_strong)\n\n        # Weak rate\n        log_E_weak = np.log(np.array(weak_errors[i]))\n        slope_weak = np.polyfit(log_delta_t, log_E_weak, 1)[0]\n        results.append(slope_weak)\n\n    # --- Step 6: Print the final results in the specified format ---\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "蒙特卡洛模拟是计算复杂随机模型期望值的有力工具，但其效率往往受制于统计方差。本实践将引导你应用一种强大的方差缩减技术——控制变量法。你将为布朗运动路径的最大值构造一个基于布朗桥理论的控制变量，并通过数值回归计算最优控制系数，从而学习如何显著提高蒙特卡洛估计的效率和准确性。",
            "id": "3341093",
            "problem": "考虑一个扩散系数为 $\\sigma  0$、从 $0$ 开始的一维布朗运动路径，其定义为 $X_t = \\sigma W_t$，其中 $t \\in [0,T]$，$W_t$ 是一个标准布朗运动。设路径最大值为 $S_T = \\sup_{0 \\le t \\le T} X_t$。您的任务是构造一个基于布朗桥条件结构的控制变量，用于估计期望 $\\mathbb{E}[S_T]$，并通过回归计算最优控制系数。\n\n基本原理和定义：\n- 一个标准布朗运动 $W_t$ 具有独立的、平稳的高斯增量，且 $W_0 = 0$，$W_t - W_s \\sim \\mathcal{N}(0, t-s)$ 对于 $0 \\le s  t$。\n- 在 $[0,T]$ 上以端点 $X_0 = 0$ 和 $X_T = x$ 为条件的布朗桥是一个高斯过程 $(X_t \\,|\\, X_T = x)$，其轨迹是连续的，其分布可以由反射原理和以 $X_T$ 为条件推导出来。\n- 反射原理给出了布朗运动游程最大值的分布，并且是给定终点时最大值条件公式的基础。\n- 对于无漂移的布朗运动，$S_T$ 的无条件分布满足 $S_T \\stackrel{d}{=} |X_T|$；因此 $\\mathbb{E}[S_T] = \\sigma \\sqrt{\\frac{2T}{\\pi}}$。\n- 普通最小二乘 (OLS) 回归用于通过最小化样本均方误差来估计最优控制系数。\n\n问题要求：\n1. 使用等距网格，步数为 $n$，$\\Delta t = T/n$，高斯增量为 $\\Delta X_k \\sim \\mathcal{N}(0, \\sigma^2 \\Delta t)$，$k = 1,\\dots,n$，在 $[0,T]$ 上模拟 $N$ 条独立的离散时间布朗运动路径。将离散化路径最大值 $S_T^{(d)} = \\max\\{0, X_{\\Delta t}, X_{2\\Delta t}, \\dots, X_T\\}$ 作为 $S_T$ 的近似。\n2. 使用在 $[0,T]$ 上给定 $X_T = x$ 的条件布朗桥定律，从第一性原理（反射原理和条件化）推导出条件期望 $\\mathbb{E}[S_T \\mid X_T = x]$ 作为 $x$、$\\sigma$ 和 $T$ 的函数的解析表达式。这个量就是控制变量 $C(x)$，通过代入每条路径实现的端点值 $x = X_T$ 来使用。\n3. 证明 $\\mathbb{E}[C(X_T)] = \\mathbb{E}[S_T]$，并使用已知公式 $\\mathbb{E}[S_T] = \\sigma \\sqrt{\\frac{2T}{\\pi}}$ 对控制变量进行中心化。\n4. 通过 OLS 回归（总体最优斜率）计算最优控制系数 $\\beta^\\star$，即 $\\beta^\\star = \\frac{\\operatorname{Cov}(S_T^{(d)}, C(X_T))}{\\operatorname{Var}(C(X_T))}$，对 $S_T^{(d)}$ 和 $C(X_T)$ 使用相同的蒙特卡洛样本。\n5. 使用控制变量构建 $\\mathbb{E}[S_T]$ 的方差缩减估计量：\n$$\n\\widehat{\\mu}_{\\mathrm{cv}} = \\overline{S_T^{(d)}} - \\widehat{\\beta}\\,\\big(\\overline{C(X_T)} - \\sigma \\sqrt{\\tfrac{2T}{\\pi}}\\big),\n$$\n其中上划线表示样本均值，$\\widehat{\\beta}$ 是从样本中得到的 $\\beta^\\star$ 的 OLS 估计值。\n6. 将上述步骤在一个完整的程序中实现。对于每个测试用例，返回浮点数三元组 $[\\overline{S_T^{(d)}}, \\widehat{\\mu}_{\\mathrm{cv}}, \\widehat{\\beta}]$。\n\n测试套件：\n- 使用以下参数集 $(T, \\sigma, N, n, \\text{seed})$：\n  - 案例 A (一般情况): $(T, \\sigma, N, n, \\text{seed}) = (1.0, 1.0, 8000, 1024, 12345)$。\n  - 案例 B (短时间范围): $(T, \\sigma, N, n, \\text{seed}) = (0.1, 1.0, 12000, 512, 23456)$。\n  - 案例 C (高波动率): $(T, \\sigma, N, n, \\text{seed}) = (1.5, 1.8, 6000, 1024, 34567)$。\n  - 案例 D (粗糙网格边界): $(T, \\sigma, N, n, \\text{seed}) = (1.0, 1.0, 10000, 1, 45678)$。\n  - 案例 E (低波动率): $(T, \\sigma, N, n, \\text{seed}) = (1.0, 0.05, 8000, 1024, 56789)$。\n\n输出规范：\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是按 $[\\overline{S_T^{(d)}}, \\widehat{\\mu}_{\\mathrm{cv}}, \\widehat{\\beta}]$ 顺序排列的三个浮点数的列表，并且总输出必须是这些列表的列表，例如：\n$[[\\text{A}_1,\\text{A}_2,\\text{A}_3],[\\text{B}_1,\\text{B}_2,\\text{B}_3],\\dots]$。\n- 不涉及物理单位；所有量都是无量纲的实数。",
            "solution": "该问题是有效的，要求为一维布朗运动最大值的期望 $\\mathbb{E}[S_T]$ 的蒙特卡洛估计构造一个控制变量。解决方案涉及从第一性原理推导控制变量，实现蒙特卡洛模拟以计算最优控制系数，并应用方差缩减技术。\n\n### 步骤 1：控制变量的推导\n\n问题要求给出条件期望 $C(x) = \\mathbb{E}[S_T \\mid X_T = x]$ 的解析表达式。过程为 $X_t = \\sigma W_t$，其中 $W_t$ 是标准布朗运动。路径最大值为 $S_T = \\sup_{0 \\le t \\le T} X_t = \\sigma \\sup_{0 \\le t \\le T} W_t = \\sigma S'_T$，其中 $S'_T = \\sup_{0 \\le t \\le T} W_t$。\n\n条件期望可以按如下方式缩放：\n$$\n\\mathbb{E}[S_T \\mid X_T = x] = \\mathbb{E}[\\sigma S'_T \\mid \\sigma W_T = x] = \\sigma \\mathbb{E}[S'_T \\mid W_T = x/\\sigma]\n$$\n令 $y = x/\\sigma$。我们的任务简化为求 $\\mathbb{E}[S'_T \\mid W_T = y]$。\n\n根据布朗运动的反射原理，给定终点 $W_T=y$ 时，最大值 $S'_T$ 的条件概率分布是已知的。条件生存函数由下式给出：\n$$\nP(S'_T \\ge a \\mid W_T = y) = e^{-2a(a-y)/T} \\quad \\text{for } a \\ge \\max(0, y)\n$$\n对于一个非负随机变量 $Z$，其期望可以通过对其生存函数积分来计算：$\\mathbb{E}[Z] = \\int_0^\\infty P(Z > z) dz$。$S'_T$ 的条件分布的支撑集为 $[\\max(0,y), \\infty)$。\n\n我们根据 $y$ 的符号分两种情况进行分析。\n\n情况 1: $y  0$。\n$S'_T$ 的支撑集是 $[y, \\infty)$。期望由下式给出：\n$$\n\\mathbb{E}[S'_T \\mid W_T = y] = y + \\int_y^\\infty P(S'_T  a \\mid W_T = y) da = y + \\int_y^\\infty e^{-2a(a-y)/T} da\n$$\n为了计算该积分，我们对指数部分进行配方：\n$$-2a(a-y)/T = -\\frac{2}{T}(a^2 - ay) = -\\frac{2}{T}\\left(\\left(a - \\frac{y}{2}\\right)^2 - \\frac{y^2}{4}\\right) = -\\frac{2}{T}\\left(a - \\frac{y}{2}\\right)^2 + \\frac{y^2}{2T}$$\n积分变为：\n$$\n\\int_y^\\infty e^{-2a(a-y)/T} da = e^{y^2/(2T)} \\int_y^\\infty e^{-\\frac{2}{T}(a - y/2)^2} da\n$$\n令 $u = (a - y/2)\\sqrt{2/T}$。则 $da = \\sqrt{T/2}du$。积分下限变为 $u_0 = (y - y/2)\\sqrt{2/T} = y/\\sqrt{2T}$。积分变换为：\n$$\ne^{y^2/(2T)} \\sqrt{T/2} \\int_{y/\\sqrt{2T}}^\\infty e^{-u^2} du = e^{y^2/(2T)} \\sqrt{T/2} \\left(\\frac{\\sqrt{\\pi}}{2} \\operatorname{erfc}\\left(\\frac{y}{\\sqrt{2T}}\\right)\\right) = \\sqrt{\\frac{T\\pi}{8}} e^{y^2/(2T)} \\operatorname{erfc}\\left(\\frac{y}{\\sqrt{2T}}\\right)\n$$\n其中 $\\operatorname{erfc}(z) = \\frac{2}{\\sqrt{\\pi}}\\int_z^\\infty e^{-u^2}du$ 是互补误差函数。\n所以，对于 $y0$：\n$$\n\\mathbb{E}[S'_T \\mid W_T = y] = y + \\sqrt{\\frac{T\\pi}{8}} e^{y^2/(2T)} \\operatorname{erfc}\\left(\\frac{y}{\\sqrt{2T}}\\right)\n$$\n\n情况 2: $y \\le 0$。\n$S'_T$ 的支撑集是 $[0, \\infty)$。期望为：\n$$\n\\mathbb{E}[S'_T \\mid W_T = y] = \\int_0^\\infty P(S'_T  a \\mid W_T=y) da = \\int_0^\\infty e^{-2a(a-y)/T} da\n$$\n使用相同的变量替换，下限变为 $u_0 = (0 - y/2)\\sqrt{2/T} = -y/\\sqrt{2T}$。\n$$\n\\mathbb{E}[S'_T \\mid W_T = y] = \\sqrt{\\frac{T\\pi}{8}} e^{y^2/(2T)} \\operatorname{erfc}\\left(\\frac{-y}{\\sqrt{2T}}\\right)\n$$\n结合两种情况，并代回 $y=x/\\sigma$，我们得到控制变量 $C(x)$：\n$$\nC(x) = \\sigma \\left( \\max(0, \\frac{x}{\\sigma}) + \\sqrt{\\frac{T\\pi}{8}} e^{\\frac{(x/\\sigma)^2}{2T}} \\operatorname{erfc}\\left(\\frac{|x/\\sigma|}{\\sqrt{2T}}\\right) \\right)\n$$\n\n### 步骤 2：对控制变量进行中心化\n\n问题要求证明 $\\mathbb{E}[C(X_T)] = \\mathbb{E}[S_T]$。控制变量 $C(x)$ 被构造为 $\\mathbb{E}[S_T \\mid X_T=x]$。根据全期望定律（塔型性质），条件期望的期望等于无条件期望：\n$$\n\\mathbb{E}[C(X_T)] = \\mathbb{E}[\\mathbb{E}[S_T \\mid X_T]] = \\mathbb{E}[S_T]\n$$\n这证明了所要求的性质。无条件均值的已知解析值为 $\\mathbb{E}[S_T] = \\sigma \\sqrt{2T/\\pi}$，我们用它来对控制变量进行中心化。\n\n### 步骤 3：蒙特卡洛模拟与估计\n\n流程如下：\n1.  在离散时间网格 $t_k = k\\Delta t$（$k=0, \\dots, n$，其中 $\\Delta t=T/n$）上模拟 $N$ 条独立的布朗运动 $X_t$ 路径。每条路径通过对 $n$ 个独立的、服从 $\\mathcal{N}(0, \\sigma^2 \\Delta t)$ 分布的高斯增量 $\\Delta X_k$ 求和来构建。\n$$\nX_{t_k} = \\sum_{j=1}^k \\Delta X_j\n$$\n2.  对于每条模拟路径 $i \\in \\{1, \\dots, N\\}$，我们计算离散化最大值 $S_T^{(d, i)} = \\max\\{0, X_{t_1}^{(i)}, \\dots, X_{t_n}^{(i)}\\}$ 和终端值 $X_T^{(i)} = X_{t_n}^{(i)}$。\n3.  使用终端值，我们利用步骤 1 中推导的公式为每条路径计算控制变量值 $C_i = C(X_T^{(i)})$。\n4.  最优控制系数 $\\beta^\\star$ 是总体 OLS 斜率，可从样本数据中估计得到：\n$$\n\\widehat{\\beta} = \\frac{\\widehat{\\operatorname{Cov}}(S_T^{(d)}, C)}{\\widehat{\\operatorname{Var}}(C)} = \\frac{\\sum_{i=1}^N (S_T^{(d,i)} - \\overline{S_T^{(d)}})(C_i - \\bar{C})}{\\sum_{i=1}^N (C_i - \\bar{C})^2}\n$$\n其中上划线表示样本均值。\n5.  $\\mathbb{E}[S_T]$ 的控制变量方差缩减估计量为：\n$$\n\\widehat{\\mu}_{\\mathrm{cv}} = \\overline{S_T^{(d)}} - \\widehat{\\beta}\\,\\left(\\overline{C} - \\sigma \\sqrt{\\frac{2T}{\\pi}}\\right)\n$$\n该估计量基于控制变量的样本均值与其已知的真实均值之间的差异，来校正粗略的蒙特卡洛估计 $\\overline{S_T^{(d)}}$。\n\n### 步骤 4：算法实现\n\n实现将上述步骤转化为代码。对于由参数 $(T, \\sigma, N, n, \\text{seed})$ 定义的每个测试用例：\n1.  为保证可复现性，设置随机种子。\n2.  生成一个 $N \\times n$ 的随机增量矩阵，这些增量来自 $\\mathcal{N}(0, \\sigma^2 T/n)$。\n3.  沿时间轴（轴 1）计算累积和，以获得 $N$ 条路径。\n4.  通过取每条路径的最大值来计算 $S_T^{(d)}$。在取最大值之前，将一列零连接到路径矩阵，以考虑起始点 $X_0=0$。\n5.  提取终端值 $X_T$。\n6.  利用 NumPy进行数组操作和 `scipy.special.erfc` 计算互补误差函数，对控制变量 $C(X_T)$ 的计算进行向量化。\n7.  计算样本均值、协方差和方差，以计算 $\\widehat{\\beta}$。\n8.  最后，计算粗略的 MC 估计 $\\overline{S_T^{(d)}}$ 和控制变量估计 $\\widehat{\\mu}_{\\mathrm{cv}}$。\n9.  为所有测试用例收集结果 $[\\overline{S_T^{(d)}}, \\widehat{\\mu}_{\\mathrm{cv}}, \\widehat{\\beta}]$，并以指定格式打印。$n=1$ 的特殊情况也自然地被此过程处理。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Computes crude and control variate Monte Carlo estimates for the expected maximum of a Brownian motion.\n    \"\"\"\n    test_cases = [\n        # (T, sigma, N, n, seed)\n        (1.0, 1.0, 8000, 1024, 12345),   # Case A\n        (0.1, 1.0, 12000, 512, 23456),   # Case B\n        (1.5, 1.8, 6000, 1024, 34567),   # Case C\n        (1.0, 1.0, 10000, 1, 45678),     # Case D\n        (1.0, 0.05, 8000, 1024, 56789),  # Case E\n    ]\n\n    all_results = []\n\n    for T, sigma, N, n, seed in test_cases:\n        # Set the seed for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. Simulate N independent discrete-time Brownian motion paths\n        delta_t = T / n\n        # Increments are N(0, sigma^2 * delta_t)\n        increments = rng.normal(loc=0.0, scale=sigma * np.sqrt(delta_t), size=(N, n))\n        \n        # Cumsum to get the paths. Paths start at 0.\n        paths = np.cumsum(increments, axis=1)\n        \n        # S_T^(d) is the maximum of the path including the starting point 0\n        paths_with_zero = np.concatenate((np.zeros((N, 1)), paths), axis=1)\n        s_T_d = np.max(paths_with_zero, axis=1)\n\n        # The endpoint of the path is X_T\n        x_T = paths[:, -1]\n\n        # 2. Derive and compute the control variate C(x) = E[S_T | X_T = x]\n        def control_variate_func(x, t_param, sigma_param):\n            y = x / sigma_param\n            \n            common_term = np.sqrt(t_param * np.pi / 8.0) * \\\n                          np.exp(y**2 / (2.0 * t_param)) * \\\n                          erfc(np.abs(y) / np.sqrt(2.0 * t_param))\n            \n            # Use np.where for vectorized conditional logic\n            cv_unscaled = np.where(y  0, y + common_term, common_term)\n            \n            return sigma_param * cv_unscaled\n\n        C = control_variate_func(x_T, T, sigma)\n\n        # 3. Use known formula for centering\n        mu_C_analytic = sigma * np.sqrt(2.0 * T / np.pi)\n\n        # 4. Compute optimal control coefficient beta_star via OLS\n        # We use sample statistics (ddof=1)\n        # beta_hat = Cov(S, C) / Var(C)\n        cov_matrix = np.cov(s_T_d, C, ddof=1)\n        beta_hat = cov_matrix[0, 1] / cov_matrix[1, 1]\n\n        # 5. Form the variance-reduced estimator\n        s_T_d_mean = np.mean(s_T_d)\n        C_mean = np.mean(C)\n        \n        mu_cv_hat = s_T_d_mean - beta_hat * (C_mean - mu_C_analytic)\n        \n        # 6. Store the triple of floats\n        all_results.append([s_T_d_mean, mu_cv_hat, beta_hat])\n\n    # Format the output as specified\n    # e.g., [[A1,A2,A3],[B1,B2,B3],...]\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}