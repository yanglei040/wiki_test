{
    "hands_on_practices": [
        {
            "introduction": "理论学习的最佳拍档是动手实践。本节将通过一系列练习，帮助你将均匀化方法的抽象概念转化为具体的计算和模拟技能。我们的第一个练习将从第一性原理出发，推导均匀化方法的核心公式。这个练习旨在让你掌握如何计算连续时间马尔可夫链（CTMC）在特定时刻的状态期望值，并将理论与一个具体的计算实例联系起来，同时探讨近似计算中的误差控制问题。",
            "id": "3359512",
            "problem": "考虑一个定义在有限状态空间 $\\mathcal{S}=\\{0,1,2\\}$ 上的连续时间马尔可夫链 (CTMC)，其生成元为 $Q$，初始分布为 $\\pi_0$ (一个行向量)。令 $X_t$ 表示在时间 $t$ 的状态。均匀化方法构造了一个控制速率 $\\lambda>0$ 和一个随机矩阵 $P$，使得 $Q=\\lambda(P-I)$，其中 $I$ 是单位矩阵。均匀化表示将该 CTMC 解释为一个时变换的离散时间马尔可夫链 $Y_n$，其转移矩阵为 $P$，在时间 $t$ 前，其跳跃次数服从泊松分布 Poisson($\\lambda t$)。\n\n从 CTMC 的基本定义、柯尔莫哥洛夫前向方程以及全期望定律出发，推导在均匀化下有界函数 $f:\\mathcal{S}\\to\\mathbb{R}$ 的期望 $E[f(X_t)]$ 的级数表示。然后，针对以下具体实例，计算在特定时间 $E[f(X_t)]$ 的值：\n- 设 $\\lambda=5$ 且\n$$\nP=\\begin{pmatrix}\n0.4  0.6  0 \\\\\n0  0.7  0.3 \\\\\n0  0  1\n\\end{pmatrix},\n\\qquad\nQ=\\lambda(P-I)=5(P-I).\n$$\n- 设初始分布为 $\\pi_0=(0.3,\\,0.2,\\,0.5)$。\n- 设 $f$ 是状态 $0$ 的指示函数，即 $f(0)=1$，$f(1)=0$，$f(2)=0$。\n- 设 $t=0.9$。\n\n你的任务是：\n1. 从第一性原理出发，推导 $E[f(X_t)]$ 的均匀化混合表示，即一个涉及 $P$ 的泊松加权级数。\n2. 利用你能从 $P$ 和 $f$ 推导出的任何结构性质，为给定数据求得 $E[f(X_t)]$ 的一个闭式表达式，并进行数值计算。\n3. 解释如何通过在有限项 $N$ 处截断级数来以可控的绝对误差进行近似，并给出一个明确的 $N$ 值选择，以保证对于给定参数，截断误差至多为 $10^{-6}$。\n\n将你对 $E[f(X_t)]$ 的最终数值答案四舍五入到六位有效数字。不需要物理单位。",
            "solution": "该问题要求完成与一个通过均匀化方法指定的连续时间马尔可夫链 (CTMC) 相关的三个任务：\n1.  推导状态函数期望 $E[f(X_t)]$ 的级数表示。\n2.  针对一个具体案例计算此期望，并获得一个闭式表达式。\n3.  分析该级数表示的截断误差。\n\n我们将按顺序解决每个任务。\n\n在时间 $t$ 的 CTMC 状态，由概率分布行向量 $\\pi_t$ 表示，它受柯尔莫哥洛夫前向方程 $\\frac{d}{dt}\\pi_t = \\pi_t Q$ 的支配，其中 $\\pi_0$ 是初始分布，$Q$ 是生成矩阵。这个微分方程的解由矩阵指数给出：\n$$\n\\pi_t = \\pi_0 \\exp(Qt)\n$$\n有界函数 $f:\\mathcal{S}\\to\\mathbb{R}$ 的期望由 $E[f(X_t)] = \\sum_{s \\in \\mathcal{S}} \\pi_t(s)f(s)$ 给出。设 $\\mathbf{f}$ 是其元素为 $f(s)$ 值的列向量。那么期望可以写成矩阵乘积的形式：\n$$\nE[f(X_t)] = \\pi_t \\mathbf{f} = \\pi_0 \\exp(Qt) \\mathbf{f}\n$$\n\n**任务1：均匀化级数的推导**\n\n均匀化方法基于生成矩阵 $Q$ 的分解 $Q = \\lambda(P-I)$，其中 $\\lambda > 0$ 是一个速率，满足 $\\lambda \\ge \\max_i |q_{ii}|$，$P$ 是一个随机矩阵（嵌入的离散时间链的转移矩阵），$I$ 是单位矩阵。\n\n将此分解代入 $E[f(X_t)]$ 的表达式中：\n$$\nE[f(X_t)] = \\pi_0 \\exp(\\lambda t(P-I)) \\mathbf{f}\n$$\n由于单位矩阵 $I$ 与任何矩阵 $P$ 交换，我们可以分离指数：如果 $AB=BA$，则 $\\exp(A+B) = \\exp(A)\\exp(B)$。这里，$A = \\lambda t P$ 且 $B = -\\lambda t I$。\n$$\n\\exp(\\lambda t(P-I)) = \\exp(\\lambda t P) \\exp(-\\lambda t I)\n$$\n一个标量乘以单位矩阵的指数是直接的：\n$$\n\\exp(-\\lambda t I) = \\sum_{n=0}^{\\infty} \\frac{(-\\lambda t I)^n}{n!} = \\sum_{n=0}^{\\infty} \\frac{(-\\lambda t)^n}{n!} I^n = I \\sum_{n=0}^{\\infty} \\frac{(-\\lambda t)^n}{n!} = \\exp(-\\lambda t) I\n$$\n矩阵 $\\lambda t P$ 的指数由其幂级数定义给出：\n$$\n\\exp(\\lambda t P) = \\sum_{n=0}^{\\infty} \\frac{(\\lambda t P)^n}{n!} = \\sum_{n=0}^{\\infty} \\frac{(\\lambda t)^n}{n!} P^n\n$$\n结合这些结果，我们得到：\n$$\nE[f(X_t)] = \\pi_0 \\left( \\left( \\sum_{n=0}^{\\infty} \\frac{(\\lambda t)^n}{n!} P^n \\right) \\exp(-\\lambda t) I \\right) \\mathbf{f}\n$$\n因为 $\\exp(-\\lambda t)$ 是一个标量且 $I\\mathbf{f} = \\mathbf{f}$，我们可以重新整理表达式：\n$$\nE[f(X_t)] = \\sum_{n=0}^{\\infty} \\exp(-\\lambda t) \\frac{(\\lambda t)^n}{n!} (\\pi_0 P^n \\mathbf{f})\n$$\n这就是所求的级数表示。它有一个深刻的概率解释。项 $\\exp(-\\lambda t) \\frac{(\\lambda t)^n}{n!}$ 是速率为 $\\lambda t$ 的泊松随机变量 $N_t$ 的概率质量函数，即 $P(N_t=n)$。项 $\\pi_0 P^n \\mathbf{f}$ 是期望 $E[f(Y_n)]$，其中 $Y_n$ 是转移矩阵为 $P$、初始分布为 $\\pi_0$ 的离散时间马尔可夫链。因此，该公式表示全期望定律：\n$$\nE[f(X_t)] = \\sum_{n=0}^{\\infty} P(N_t=n) E[f(Y_n)] = E[E[f(Y_{N_t})|N_t]] = E[f(Y_{N_t})]\n$$\n这表明，在时间 $t$ 的 CTMC 的状态分布与嵌入的 DTMC 经过一个服从泊松分布的步数后的状态分布相同。\n\n**任务2：闭式表达式与数值计算**\n\n我们被给予以下具体数据：\n- $\\lambda = 5$\n- $t=0.9$\n- $\\pi_0 = (0.3, 0.2, 0.5)$\n- $P = \\begin{pmatrix} 0.4  0.6  0 \\\\ 0  0.7  0.3 \\\\ 0  0  1 \\end{pmatrix}$\n- $f$ 是状态 $0$ 的指示函数，所以 $f(0)=1$，$f(1)=0$，$f(2)=0$。这对应于列向量 $\\mathbf{f} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n\n我们需要计算 $E[f(X_t)] = \\sum_{n=0}^{\\infty} \\exp(-\\lambda t) \\frac{(\\lambda t)^n}{n!} (\\pi_0 P^n \\mathbf{f})$。\n计算的核心是项 $\\pi_0 P^n \\mathbf{f}$。\n$$\n\\pi_0 P^n \\mathbf{f} = \\begin{pmatrix} 0.3  0.2  0.5 \\end{pmatrix} P^n \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n这个乘积是 $\\pi_0$ 与 $P^n$ 的第一列的点积。\n矩阵 $P$ 的一个关键结构性质是它是上三角矩阵。一个上三角矩阵的 $n$ 次幂也是上三角矩阵，其对角线元素是原始对角线元素的 $n$ 次幂。令 $(M)_{ij}$ 表示矩阵 $M$ 的第 $i$ 行第 $j$ 列的元素。\n$$\nP^n = \\begin{pmatrix} (0.4)^n  (P^n)_{01}  (P^n)_{02} \\\\ 0  (0.7)^n  (P^n)_{12} \\\\ 0  0  1^n \\end{pmatrix}\n$$\n因此，$P^n$ 的第一列是 $\\begin{pmatrix} (0.4)^n \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n将此代入 $\\pi_0 P^n \\mathbf{f}$ 的表达式中：\n$$\n\\pi_0 P^n \\mathbf{f} = \\begin{pmatrix} 0.3  0.2  0.5 \\end{pmatrix} \\begin{pmatrix} (0.4)^n \\\\ 0 \\\\ 0 \\end{pmatrix} = 0.3 \\times (0.4)^n + 0.2 \\times 0 + 0.5 \\times 0 = 0.3 \\times (0.4)^n\n$$\n现在我们将这个简化后的项代回期望的无穷级数中：\n$$\nE[f(X_t)] = \\sum_{n=0}^{\\infty} \\exp(-\\lambda t) \\frac{(\\lambda t)^n}{n!} (0.3 \\times (0.4)^n)\n$$\n我们可以提出常数 $0.3$ 并重新整理：\n$$\nE[f(X_t)] = 0.3 \\exp(-\\lambda t) \\sum_{n=0}^{\\infty} \\frac{(\\lambda t)^n (0.4)^n}{n!} = 0.3 \\exp(-\\lambda t) \\sum_{n=0}^{\\infty} \\frac{(0.4 \\lambda t)^n}{n!}\n$$\n这个和是 $\\exp(0.4 \\lambda t)$ 的泰勒级数展开。这得出了闭式表达式：\n$$\nE[f(X_t)] = 0.3 \\exp(-\\lambda t) \\exp(0.4 \\lambda t) = 0.3 \\exp(-\\lambda t + 0.4 \\lambda t) = 0.3 \\exp(-0.6 \\lambda t)\n$$\n现在，我们代入数值 $\\lambda=5$ 和 $t=0.9$：\n$$\n\\lambda t = 5 \\times 0.9 = 4.5\n$$\n$$\nE[f(X_{0.9})] = 0.3 \\exp(-0.6 \\times 4.5) = 0.3 \\exp(-2.7)\n$$\n对该表达式进行数值计算：\n$$\nE[f(X_{0.9})] \\approx 0.3 \\times 0.0672055126 \\approx 0.02016165378\n$$\n四舍五入到六位有效数字，我们得到 $0.0201617$。\n\n**任务3：截断误差分析**\n\n我们希望用一个部分和来近似整个级数。设近似值为 $S_N = \\sum_{n=0}^{N} p_n$，其中 $p_n = \\exp(-\\lambda t) \\frac{(\\lambda t)^n}{n!} (0.3 \\times (0.4)^n)$。绝对截断误差为 $R_{N+1} = \\left| \\sum_{n=N+1}^{\\infty} p_n \\right|$。由于所有项 $p_n$ 都是正的，所以绝对值是多余的。\n$$\nR_{N+1} = \\sum_{n=N+1}^{\\infty} 0.3 \\exp(-\\lambda t) \\frac{(0.4 \\lambda t)^n}{n!} = 0.3 \\exp(-\\lambda t) \\sum_{n=N+1}^{\\infty} \\frac{(0.4 \\lambda t)^n}{n!}\n$$\n令 $\\mu = 0.4 \\lambda t = 0.4 \\times 4.5 = 1.8$。\n和 $\\sum_{n=N+1}^{\\infty} \\frac{\\mu^n}{n!}$ 是 $\\exp(\\mu)$ 级数的尾部。我们可以将其与泊松分布的尾概率联系起来。设 $Z$ 是一个均值为 $\\mu=1.8$ 的泊松分布的随机变量。\n$$\nP(Z \\geq k) = \\sum_{n=k}^{\\infty} P(Z=n) = \\sum_{n=k}^{\\infty} \\exp(-\\mu) \\frac{\\mu^n}{n!}\n$$\n因此，$\\sum_{n=k}^{\\infty} \\frac{\\mu^n}{n!} = \\exp(\\mu) P(Z \\geq k)$。\n我们的误差项变为：\n$$\nR_{N+1} = 0.3 \\exp(-\\lambda t) \\exp(\\mu) P(Z \\geq N+1) = 0.3 \\exp(-4.5) \\exp(1.8) P(Z \\geq N+1)\n$$\n$$\nR_{N+1} = 0.3 \\exp(-2.7) P(Z \\geq N+1)\n$$\n我们要求误差至多为 $10^{-6}$：\n$$\n0.3 \\exp(-2.7) P(Z \\geq N+1) \\leq 10^{-6}\n$$\n这给出了关于泊松尾概率的一个条件：\n$$\nP(Z \\geq N+1) \\leq \\frac{10^{-6}}{0.3 \\exp(-2.7)} \\approx \\frac{10^{-6}}{0.02016165} \\approx 4.9599 \\times 10^{-5}\n$$\n我们需要找到一个整数 $N$，使得对于 $Z \\sim \\text{Poisson}(1.8)$，有 $P(Z \\geq N+1) \\leq 4.9599 \\times 10^{-5}$。我们可以对尾概率进行界定。对于 $k > \\mu$，一个有用的界是 $\\sum_{i=k}^\\infty \\exp(-\\mu) \\frac{\\mu^i}{i!}  \\frac{\\exp(-\\mu)\\mu^k}{k!} \\frac{k}{k-\\mu}$。\n我们来测试 $N+1$ 的值。\n对于 $N+1=9$：$P(Z=9) = \\exp(-1.8) \\frac{1.8^9}{9!} \\approx 9.0356 \\times 10^{-5}$。尾概率 $P(Z \\geq 9)$ 会比这个值大。\n对于 $N+1=10$：$P(Z=10) = \\exp(-1.8) \\frac{1.8^{10}}{10!} \\approx 1.6264 \\times 10^{-5}$。\n我们来界定尾概率 $P(Z \\geq 10)$：\n$$\nP(Z \\geq 10)  \\frac{P(Z=10)}{1 - \\mu/(N+1)} = \\frac{P(Z=10)}{1 - 1.8/10} = \\frac{P(Z=10)}{0.82} \\approx \\frac{1.6264 \\times 10^{-5}}{0.82} \\approx 1.9834 \\times 10^{-5}\n$$\n因为 $1.9834 \\times 10^{-5}  4.9599 \\times 10^{-5}$，所以选择 $N+1=10$ 是足够的。\n这意味着 $N=9$。因此，在 $N=9$ 处截断级数（即，计算 $\\sum_{n=0}^{9} p_n$）可以保证绝对误差小于 $10^{-6}$。\n一个明确的选择是 $N=9$。",
            "answer": "$$\\boxed{0.0201617}$$"
        },
        {
            "introduction": "在掌握了均匀化的基本计算方法后，我们来探讨一个更实际的问题：模拟效率。均匀化方法虽然在理论上是精确的，但其计算成本，特别是在状态转移速率差异巨大的“刚性”系统中，可能非常高。这个练习将引导你量化“虚拟跳转”（virtual jumps）——即在均匀化过程中状态并未发生实际改变的跳转——的数量，从而深入理解均匀化速率 $\\lambda$ 的选择对模拟效率的影响。",
            "id": "3359521",
            "problem": "考虑一个具有有限状态空间和生成元矩阵 $Q \\in \\mathbb{R}^{n \\times n}$ 的连续时间马尔可夫链 (CTMC)。根据定义，对于 $i \\neq j$，非对角线元素满足 $Q_{ij} \\ge 0$，且每行之和为零，因此 $Q_{ii} = -\\sum_{j \\neq i} Q_{ij} \\le 0$。从状态 $i$ 的离开率为 $a_i \\equiv -Q_{ii}$。均匀化方法通过引入一个速率为 $\\lambda$ 的泊松时钟来模拟样本路径，其中为保证精确性，要求 $\\lambda \\ge \\max_i a_i$。在此泊松时钟的每个滴答时刻，过程根据转移矩阵为 $P = I + Q / \\lambda$ 的离散时间马尔可夫链进行转移；当链在泊松滴答时刻停留在同一状态（即自转移）时，发生一次“虚拟跳跃”。\n\n您的任务是设计一个离开率跨越数个数量级的CTMC，并研究如何选择均匀化速率 $\\lambda$ 以在保持精确性（$\\lambda \\ge \\max_i a_i$）的同时，最小化虚拟跳跃的期望次数。目标是对于给定的CTMC和 $\\lambda$ 选择，计算从给定初始分布开始，在固定时间区间 $[0,T]$ 内虚拟跳跃的期望次数。您必须使用第一性原理解此问题：\n\n- 占有概率行向量 $p(t)$ 根据柯尔莫哥洛夫前向方程 $p'(t) = p(t) Q$ 演化，其中 $p(0) = p_0$。\n- 在时间 $t$ 的瞬时实际跳跃期望速率等于 $\\sum_i p_i(t) a_i$，其中 $a_i = -Q_{ii}$。\n- 在 $[0,T]$ 上的泊松时钟滴答总数的期望值为 $\\lambda T$。\n\n基于这些原理，构建一种方法来计算在 $[0,T]$ 上的期望虚拟跳跃次数。该方法通过对瞬时实际跳跃期望速率进行时间积分，并与泊松时钟滴答的期望总数进行比较。您必须通过矩阵指数 $p(t) = p_0 \\exp(Q t)$ 精确计算 $p(t)$，并对标量函数 $t \\mapsto \\sum_i p_i(t) a_i$ 进行时间上的数值积分来实现此方法。不要对积分使用封闭形式的捷径；在 $[0,T]$ 上执行数值稳健的求积。\n\n测试套件。使用以下三个CTMC，每个都有 $n=5$ 个状态，离开率跨越数个数量级，并具有不同的结构特征。对于每个CTMC，为三种 $\\lambda$ 的选择计算期望的虚拟跳跃次数：$\\lambda_{\\min} \\equiv \\max_i a_i$，$2 \\lambda_{\\min}$ 和 $10 \\lambda_{\\min}$。\n\n- 案例1（高度偏斜的离开率，中等时间范围）：\n    - $Q^{(1)}$ 的行：\n        1. $[Q^{(1)}_{0,1}, Q^{(1)}_{0,2}] = [0.006, 0.004]$, $Q^{(1)}_{0,0} = -(0.006 + 0.004) = -0.01$。\n        2. $[Q^{(1)}_{1,0}, Q^{(1)}_{1,2}] = [0.3, 0.7]$, $Q^{(1)}_{1,1} = -1$。\n        3. $[Q^{(1)}_{2,1}, Q^{(1)}_{2,3}] = [2.5, 7.5]$, $Q^{(1)}_{2,2} = -10$。\n        4. $[Q^{(1)}_{3,2}, Q^{(1)}_{3,4}] = [40, 60]$, $Q^{(1)}_{3,3} = -100$。\n        5. $[Q^{(1)}_{4,1}, Q^{(1)}_{4,3}] = [300, 700]$, $Q^{(1)}_{4,4} = -1000$。\n    - 初始分布 $p_0^{(1)} = [0.7, 0.2, 0.05, 0.04, 0.01]$。\n    - 时间范围 $T^{(1)} = 1$。\n    - $\\lambda_{\\min}^{(1)} = \\max_i a_i = 1000$。\n\n- 案例2（罕见访问的超快状态，较长时间范围）：\n    - $Q^{(2)}$ 的行：\n        1. $[Q^{(2)}_{0,1}, Q^{(2)}_{0,2}] = [0.25, 0.25]$, $Q^{(2)}_{0,0} = -0.5$。\n        2. $[Q^{(2)}_{1,0}, Q^{(2)}_{1,2}] = [0.2, 0.2]$, $Q^{(2)}_{1,1} = -0.4$。\n        3. $[Q^{(2)}_{2,1}, Q^{(2)}_{2,3}] = [0.29, 0.01]$, $Q^{(2)}_{2,2} = -0.3$。\n        4. $[Q^{(2)}_{3,2}, Q^{(2)}_{3,4}] = [0.199999, 0.000001]$, $Q^{(2)}_{3,3} = -0.2$。\n        5. $[Q^{(2)}_{4,0}, Q^{(2)}_{4,3}] = [2000, 8000]$, $Q^{(2)}_{4,4} = -10000$。\n    - 初始分布 $p_0^{(2)} = [0.5, 0.49, 0.01, 0.0, 0.0]$。\n    - 时间范围 $T^{(2)} = 2$。\n    - $\\lambda_{\\min}^{(2)} = \\max_i a_i = 10000$。\n\n- 案例3（存在吸收态，中等时间范围）：\n    - $Q^{(3)}$ 的行：\n        1. $[Q^{(3)}_{0,1}, Q^{(3)}_{0,3}] = [1.2, 0.8]$, $Q^{(3)}_{0,0} = -2$。\n        2. $[Q^{(3)}_{1,0}, Q^{(3)}_{1,2}, Q^{(3)}_{1,3}] = [1.0, 0.5, 0.5]$, $Q^{(3)}_{1,1} = -2$。\n        3. 吸收态：所有非对角线元素为 $0$，$Q^{(3)}_{2,2} = 0$。\n        4. $[Q^{(3)}_{3,2}, Q^{(3)}_{3,4}] = [49, 1]$, $Q^{(3)}_{3,3} = -50$。\n        5. $[Q^{(3)}_{4,3}] = [5]$, $Q^{(3)}_{4,4} = -5$。\n    - 初始分布 $p_0^{(3)} = [0.0, 0.0, 0.0, 1.0, 0.0]$。\n    - 时间范围 $T^{(3)} = 3$。\n    - $\\lambda_{\\min}^{(3)} = \\max_i a_i = 50$。\n\n对于每个案例 $k \\in \\{1,2,3\\}$ 和每个乘数 $m \\in \\{1,2,10\\}$，设置 $\\lambda = m \\lambda_{\\min}^{(k)}$，并使用上述方法计算在 $[0, T^{(k)}]$ 上的期望虚拟跳跃次数。\n\n最终输出格式。您的程序应生成单行输出，其中包含九个结果（每个案例三个，按乘数 $m = 1, 2, 10$ 排序；案例按 $k=1,2,3$ 排序），格式为方括号括起来的逗号分隔列表，例如 $[r_{1,1}, r_{1,2}, r_{1,10}, r_{2,1}, r_{2,2}, r_{2,10}, r_{3,1}, r_{3,2}, r_{3,10}]$，其中每个 $r_{k,m}$ 是一个浮点数。",
            "solution": "问题的核心是计算使用均匀化方法模拟CTMC路径时发生的虚拟跳跃的期望次数。我们将首先从第一性原理推导该数量的控制方程，然后概述其计算的数值步骤。\n\n具有有限状态空间 $\\{0, 1, \\dots, n-1\\}$ 的CTMC由其生成元矩阵 $Q \\in \\mathbb{R}^{n \\times n}$ 表征。对于 $i \\neq j$，非对角线元素 $Q_{ij}$ 表示从状态 $i$ 到状态 $j$ 的转移率，因此 $Q_{ij} \\ge 0$。对角线元素被定义为使每行之和为零：$Q_{ii} = -\\sum_{j \\neq i} Q_{ij}$。量 $a_i \\equiv -Q_{ii}$ 是从状态 $i$ 的总离开率。状态概率分布（由行向量 $p(t) = [p_0(t), \\dots, p_{n-1}(t)]$ 表示）的时间演化由柯尔莫哥洛夫前向方程控制：$p'(t) = p(t)Q$。给定初始分布 $p(0) = p_0$，解由矩阵指数给出：\n$$\np(t) = p_0 \\exp(Q t)\n$$\n\n均匀化方法提供了一种模拟此CTMC样本路径的方法。它引入了一个在所有状态上都均匀的恒定速率 $\\lambda$ 的主泊松过程。为了使模拟精确，该速率必须是所有特定状态离开率的上界，即 $\\lambda \\ge \\max_i a_i$。在此泊松过程的每个事件时刻，会发生一次潜在的状态转移。转移到何处（或是否转移）的决定是根据一个离散时间马尔可夫链作出的，其转移矩阵为 $P$：\n$$\nP = I + \\frac{1}{\\lambda} Q\n$$\n其中 $I$ 是单位矩阵。在泊松滴答时从状态 $i$ 转移到 $j \\neq i$ 的概率是 $P_{ij} = Q_{ij}/\\lambda$。停留在状态 $i$ 的概率是 $P_{ii} = 1 + Q_{ii}/\\lambda = 1 - a_i/\\lambda$。“虚拟跳跃”是在泊松滴答时刻，过程从状态 $i$ 转移到自身的事件。\n\n我们的目标是计算在时间范围 $[0, T]$ 内此类虚拟跳跃的期望次数，记为 $E[V(T)]$。这可以通过总的期望泊松滴答次数与期望的实际（状态改变）跳跃次数之差来求得。\n\n在 $[0, T]$ 期间，来自均匀化泊松过程的总事件数是一个均值为 $\\lambda T$ 的泊松随机变量。因此，潜在转移的期望总数为：\n$$\nE[\\text{Total Jumps}] = \\lambda T\n$$\n\n接下来，我们确定*实际*跳跃的期望次数 $E[A(T)]$。瞬时实际跳跃率取决于系统的当前状态。如果系统在时间 $t$ 处于状态 $i$，则在下一个泊松滴答时发生实际跳跃的概率为 $\\sum_{j \\neq i} P_{ij} = \\sum_{j \\neq i} (Q_{ij}/\\lambda) = a_i/\\lambda$。在时间 $t$ 的总瞬时实际跳跃期望速率是通过对当时的状态概率分布 $p(t)$ 进行平均得到的：\n$$\n\\text{Instantaneous Rate of Actual Jumps} = \\sum_{i=0}^{n-1} p_i(t) \\times a_i\n$$\n这可以用向量表示法紧凑地写出。令 $\\mathbf{a}$ 为离开率的列向量，$\\mathbf{a} = [a_0, a_1, \\dots, a_{n-1}]^T$。则瞬时速率为 $p(t)\\mathbf{a}$。\n\n为了找到在区间 $[0, T]$ 内的期望实际跳跃总数，我们将此瞬时速率对时间进行积分：\n$$\nE[A(T)] = \\int_0^T \\left( \\sum_{i=0}^{n-1} p_i(\\tau) a_i \\right) d\\tau = \\int_0^T p(\\tau)\\mathbf{a} \\, d\\tau\n$$\n\n期望的虚拟跳跃次数是期望的总跳跃次数与期望的实际跳跃次数之差：\n$$\nE[V(T)] = E[\\text{Total Jumps}] - E[A(T)] = \\lambda T - \\int_0^T p(\\tau)\\mathbf{a} \\, d\\tau\n$$\n代入 $p(\\tau)$ 的解，我们得到需要计算的最终表达式：\n$$\nE[V(T)] = \\lambda T - \\int_0^T p_0 \\exp(Q\\tau) \\mathbf{a} \\, d\\tau\n$$\n\n问题现在简化为数值计算。对于由生成元矩阵 $Q$、初始分布 $p_0$ 和时间范围 $T$ 定义的每个测试案例，我们必须为每个指定的均匀化速率 $\\lambda$ 执行以下步骤：\n1.  定义被积函数 $f(\\tau) = p_0 \\exp(Q\\tau) \\mathbf{a}$。离开率向量 $\\mathbf{a}$ 由 $Q$ 的对角线导出，即 $\\mathbf{a}_i = -Q_{ii}$。\n2.  在数值积分程序所需的每个求值点 $\\tau$，计算矩阵指数 $\\exp(Q\\tau)$。\n3.  在区间 $[0, T]$ 上对 $f(\\tau)$ 执行数值求积，以逼近积分 $\\int_0^T f(\\tau) d\\tau$。\n4.  使用推导出的 $E[V(T)]$ 公式计算最终结果。\n\n此过程将为三个指定的CTMC及其相应的参数集实现。对于每个案例，我们将使用 $\\lambda = m \\lambda_{\\min}$，其中 $\\lambda_{\\min} = \\max_i a_i$，乘数 $m$ 的取值为 $\\{1, 2, 10\\}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the CTMC virtual jump problem for the three specified test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Highly skewed exit rates, moderate horizon\n        {\n            \"Q_def\": {\n                0: {1: 0.006, 2: 0.004},\n                1: {0: 0.3, 2: 0.7},\n                2: {1: 2.5, 3: 7.5},\n                3: {2: 40, 4: 60},\n                4: {1: 300, 3: 700}\n            },\n            \"p0\": np.array([0.7, 0.2, 0.05, 0.04, 0.01]),\n            \"T\": 1.0,\n            \"n\": 5\n        },\n        # Case 2: Rarely visited ultra-fast state, longer horizon\n        {\n            \"Q_def\": {\n                0: {1: 0.25, 2: 0.25},\n                1: {0: 0.2, 2: 0.2},\n                2: {1: 0.29, 3: 0.01},\n                3: {2: 0.199999, 4: 0.000001},\n                4: {0: 2000, 3: 8000}\n            },\n            \"p0\": np.array([0.5, 0.49, 0.01, 0.0, 0.0]),\n            \"T\": 2.0,\n            \"n\": 5\n        },\n        # Case 3: Absorbing state present, intermediate horizon\n        {\n            \"Q_def\": {\n                0: {1: 1.2, 3: 0.8},\n                1: {0: 1.0, 2: 0.5, 3: 0.5},\n                2: {},  # Absorbing state\n                3: {2: 49, 4: 1},\n                4: {3: 5}\n            },\n            \"p0\": np.array([0.0, 0.0, 0.0, 1.0, 0.0]),\n            \"T\": 3.0,\n            \"n\": 5\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # 1. Construct the generator matrix Q and exit rate vector a\n        n_states = case[\"n\"]\n        Q = np.zeros((n_states, n_states))\n        for i, transitions in case[\"Q_def\"].items():\n            for j, rate in transitions.items():\n                Q[i, j] = rate\n        \n        for i in range(n_states):\n            Q[i, i] = -np.sum(Q[i, :])\n            \n        exit_rates = -np.diag(Q)\n        \n        # 2. Get other parameters for the case\n        p0 = case[\"p0\"]\n        T = case[\"T\"]\n        \n        # 3. Define the integrand for the expected number of actual jumps\n        # The integrand is f(t) = p(t) * a = (p0 * exp(Q*t)) * a\n        # where a is the column vector of exit rates.\n        def integrand(t, Q_matrix, p0_vec, a_vec):\n            p_t = p0_vec @ expm(Q_matrix * t)\n            return p_t @ a_vec\n\n        # 4. Calculate expected number of actual jumps by numerical integration\n        # quad returns a tuple (integral_value, error_estimate)\n        expected_actual_jumps, _ = quad(integrand, 0, T, args=(Q, p0, exit_rates))\n\n        # 5. Calculate lambda_min and iterate through multipliers\n        lambda_min = np.max(exit_rates)\n        multipliers = [1, 2, 10]\n        \n        for m in multipliers:\n            lambda_rate = m * lambda_min\n            \n            # Expected total jumps (Poisson ticks) = lambda * T\n            expected_total_jumps = lambda_rate * T\n            \n            # Expected virtual jumps = Total - Actual\n            expected_virtual_jumps = expected_total_jumps - expected_actual_jumps\n            results.append(expected_virtual_jumps)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}