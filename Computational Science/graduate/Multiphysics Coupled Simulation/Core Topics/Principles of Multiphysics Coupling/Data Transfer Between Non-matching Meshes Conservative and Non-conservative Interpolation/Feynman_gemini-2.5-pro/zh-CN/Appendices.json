{
    "hands_on_practices": [
        {
            "introduction": "我们将从最基本的原理出发，亲手构建两种核心的一维数据传输算子：一种是守恒的，另一种是非守恒的。通过这个练习，你将直接对比它们在构造上的差异，并量化评估它们在保持总量守恒和数值有界性方面的表现。这为你理解更复杂的多物理场耦合问题中的数据传递奠定了坚实的基础。",
            "id": "3501827",
            "problem": "给定闭区间 $[0,1]$ 上的两个一维网格。一个网格由一个严格递增的单元边坐标列表指定，其相关数据是每个单元上标量场的单元平均值。设源网格有 $N_{\\mathrm{s}}$ 个单元，其边为 $\\{x^{\\mathrm{s}}_{0},x^{\\mathrm{s}}_{1},\\dots,x^{\\mathrm{s}}_{N_{\\mathrm{s}}}\\}$，单元长度为 $L^{\\mathrm{s}}_{i}=x^{\\mathrm{s}}_{i+1}-x^{\\mathrm{s}}_{i}$（其中 $i=0,\\dots,N_{\\mathrm{s}}-1$）。设目标网格有 $N_{\\mathrm{t}}$ 个单元，其边为 $\\{x^{\\mathrm{t}}_{0},x^{\\mathrm{t}}_{1},\\dots,x^{\\mathrm{t}}_{N_{\\mathrm{t}}}\\}$，单元长度为 $L^{\\mathrm{t}}_{j}=x^{\\mathrm{t}}_{j+1}-x^{\\mathrm{t}}_{j}$（其中 $j=0,\\dots,N_{\\mathrm{t}}-1$）。源数据是单元平均值 $\\bar{q}^{\\mathrm{s}}_{i}$，对于某个未知的可积函数 $u(x)$，其定义为 $\\bar{q}^{\\mathrm{s}}_{i}=\\frac{1}{L^{\\mathrm{s}}_{i}}\\int_{x^{\\mathrm{s}}_{i}}^{x^{\\mathrm{s}}_{i+1}}u(x)\\,\\mathrm{d}x$。\n\n你的任务是从第一性原理出发，推导并实现两个线性传输算子，用于在不匹配的网格上将源单元平均值向量映射到目标单元平均值向量：\n\n- 一个保守算子，由源单元和目标单元之间的几何重叠组装而成，当目标域与源域相等时，该算子能精确地保持总积分。仅从单元平均值的定义和总积分必须保持的要求出发，推导如何使用几何信息来组装此算子。\n\n- 一个基于最近单元中心采样的非保守算子，它将包含目标单元中心的源单元所对应的源单元平均值赋给每个目标单元。\n\n对于这两种算子，将它们应用于给定的源单元平均值向量，并评估两个属性：\n\n- 守恒性：$\\sum_{i=0}^{N_{\\mathrm{s}}-1}\\bar{q}^{\\mathrm{s}}_{i}L^{\\mathrm{s}}_{i}$ 是否在指定容差内等于 $\\sum_{j=0}^{N_{\\mathrm{t}}-1}\\bar{q}^{\\mathrm{t}}_{j}L^{\\mathrm{t}}_{j}$。\n\n- 有界性：$\\min_{j}\\bar{q}^{\\mathrm{t}}_{j}\\ge \\min_{i}\\bar{q}^{\\mathrm{s}}_{i}$ 和 $\\max_{j}\\bar{q}^{\\mathrm{t}}_{j}\\le \\max_{i}\\bar{q}^{\\mathrm{s}}_{i}$ 是否在指定容差内成立。\n\n假设目标域与源域相等，且不使用任何单位；将所有量视为无量纲量。\n\n实现一个程序，该程序：\n\n- 仅根据单元边坐标和单元平均值定义所隐含的单元长度归一化来组装保守算子。\n\n- 通过将每个目标单元中心 $c^{\\mathrm{t}}_{j}=\\frac{1}{2}(x^{\\mathrm{t}}_{j}+x^{\\mathrm{t}}_{j+1})$ 映射到包含它的唯一源单元来组装非保守算子。\n\n- 将两种算子应用于提供的源单元平均值向量，并为每种情况返回表示守恒性和有界性的布尔值。\n\n使用以下网格和数据测试套件：\n\n- 情况 A（一般不匹配，平滑到混合数据）：\n    - 源边：$[0.0,\\,0.2,\\,0.5,\\,0.7,\\,1.0]$。\n    - 目标边：$[0.0,\\,0.1,\\,0.4,\\,0.6,\\,0.85,\\,1.0]$。\n    - 源单元平均值：$[0.0,\\,1.0,\\,-0.5,\\,2.0]$。\n\n- 情况 B（边界对齐，恒定数据）：\n    - 源边：$[0.0,\\,0.3,\\,0.6,\\,1.0]$。\n    - 目标边：$[0.0,\\,0.3,\\,0.8,\\,1.0]$。\n    - 源单元平均值：$[1.0,\\,1.0,\\,1.0]$。\n\n- 情况 C（极端尺寸比，振荡数据）：\n    - 源边：$[0.0,\\,0.01,\\,0.02,\\,0.5,\\,1.0]$。\n    - 目标边：$[0.0,\\,0.9,\\,0.95,\\,0.975,\\,1.0]$。\n    - 源单元平均值：$[10.0,\\,-10.0,\\,0.0,\\,1.0]$。\n\n对于每种情况，按顺序计算并返回以下四个布尔值：\n\n- 保守算子：守恒性检查。\n- 保守算子：有界性检查。\n- 非保守算子：守恒性检查。\n- 非保守算子：有界性检查。\n\n对守恒性和有界性检查均使用 $\\varepsilon=10^{-12}$ 的绝对容差。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须包含情况 A、情况 B 和情况 C 的布尔值，每种情况按上述顺序提供四个布尔值。例如，一个有效的输出格式是 $[{\\mathrm{True}},{\\mathrm{False}},{\\mathrm{True}},{\\mathrm{True}},\\dots]$。",
            "solution": "该问题要求推导并实现两个在不匹配的一维网格之间进行数据传输的算子：一个保守算子和一个非保守的最近邻算子。我们将首先从第一性原理出发，推导每个算子的数学公式，并分析其关于守恒性和有界性的属性。\n\n设源网格由区间 $[0, 1]$ 上的一组 $N_{\\mathrm{s}}+1$ 个严格递增的边坐标 $\\{x^{\\mathrm{s}}_{0}, x^{\\mathrm{s}}_{1}, \\dots, x^{\\mathrm{s}}_{N_{\\mathrm{s}}}\\}$ 定义，使得 $x^{\\mathrm{s}}_{0}=0$ 且 $x^{\\mathrm{s}}_{N_{\\mathrm{s}}}=1$。第 $i$ 个源单元是区间 $[x^{\\mathrm{s}}_{i}, x^{\\mathrm{s}}_{i+1}]$（$i=0, \\dots, N_{\\mathrm{s}}-1$），其长度为 $L^{\\mathrm{s}}_{i} = x^{\\mathrm{s}}_{i+1} - x^{\\mathrm{s}}_{i}$。源数据是某个未知可积函数 $u(x)$ 的单元平均值 $\\bar{q}^{\\mathrm{s}}_{i}$，由 $\\bar{q}^{\\mathrm{s}}_{i} = \\frac{1}{L^{\\mathrm{s}}_{i}} \\int_{x^{\\mathrm{s}}_{i}}^{x^{\\mathrm{s}}_{i+1}} u(x) \\, \\mathrm{d}x$ 给出。\n\n类似地，目标网格由 $[0, 1]$ 上的 $N_{\\mathrm{t}}$ 个单元组成，由边 $\\{x^{\\mathrm{t}}_{0}, x^{\\mathrm{t}}_{1}, \\dots, x^{\\mathrm{t}}_{N_{\\mathrm{t}}}\\}$ 定义，其中 $x^{\\mathrm{t}}_{0}=0$ 且 $x^{\\mathrm{t}}_{N_{\\mathrm{t}}}=1$。第 $j$ 个目标单元是 $[x^{\\mathrm{t}}_{j}, x^{\\mathrm{t}}_{j+1}]$，其长度为 $L^{\\mathrm{t}}_{j} = x^{\\mathrm{t}}_{j+1} - x^{\\mathrm{t}}_{j}$。我们的目标是计算目标单元平均值 $\\bar{q}^{\\mathrm{t}}_{j} = \\frac{1}{L^{\\mathrm{t}}_{j}} \\int_{x^{\\mathrm{t}}_{j}}^{x^{\\mathrm{t}}_{j+1}} u(x) \\, \\mathrm{d}x$。\n\n**1. 保守算子**\n\n保守算子的推导始于目标单元平均值 $\\bar{q}^{\\mathrm{t}}_{j}$ 的基本定义：\n$$ \\bar{q}^{\\mathrm{t}}_{j} = \\frac{1}{L^{\\mathrm{t}}_{j}} \\int_{x^{\\mathrm{t}}_{j}}^{x^{\\mathrm{t}}_{j+1}} u(x) \\, \\mathrm{d}x $$\n由于 $u(x)$ 未知，我们必须使用可用的源数据来近似它。在有限体积法中，一个自然地导向保守格式的常见选择是将 $u(x)$ 重建为分段常数函数，其中每个源单元 $i$ 内的常数值为其单元平均值 $\\bar{q}^{\\mathrm{s}}_{i}$。设此重建函数为 $\\tilde{u}(x)$：\n$$ \\tilde{u}(x) = \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} \\cdot \\mathbf{1}_{[x^{\\mathrm{s}}_{i}, x^{\\mathrm{s}}_{i+1}]}(x) $$\n其中 $\\mathbf{1}_{A}(x)$ 是指示函数，如果 $x \\in A$ 则等于 $1$，否则等于 $0$。\n\n在 $\\bar{q}^{\\mathrm{t}}_{j}$ 的积分中用 $\\tilde{u}(x)$ 代替 $u(x)$：\n$$ \\bar{q}^{\\mathrm{t}}_{j} \\approx \\frac{1}{L^{\\mathrm{t}}_{j}} \\int_{x^{\\mathrm{t}}_{j}}^{x^{\\mathrm{t}}_{j+1}} \\left( \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} \\cdot \\mathbf{1}_{[x^{\\mathrm{s}}_{i}, x^{\\mathrm{s}}_{i+1}]}(x) \\right) \\mathrm{d}x $$\n根据积分的线性性质，我们可以交换求和与积分的顺序：\n$$ \\bar{q}^{\\mathrm{t}}_{j} = \\frac{1}{L^{\\mathrm{t}}_{j}} \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} \\int_{x^{\\mathrm{t}}_{j}}^{x^{\\mathrm{t}}_{j+1}} \\mathbf{1}_{[x^{\\mathrm{s}}_{i}, x^{\\mathrm{s}}_{i+1}]}(x) \\, \\mathrm{d}x $$\n积分项表示源单元 $i$ 和目标单元 $j$ 之间交集的长度。设此交集长度为 $\\Delta L_{ij}$：\n$$ \\Delta L_{ij} = \\text{length}([x^{\\mathrm{s}}_{i}, x^{\\mathrm{s}}_{i+1}] \\cap [x^{\\mathrm{t}}_{j}, x^{\\mathrm{t}}_{j+1}]) = \\max(0, \\min(x^{\\mathrm{s}}_{i+1}, x^{\\mathrm{t}}_{j+1}) - \\max(x^{\\mathrm{s}}_{i}, x^{\\mathrm{t}}_{j})) $$\n目标单元平均值的公式变为：\n$$ \\bar{q}^{\\mathrm{t}}_{j} = \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\left( \\frac{\\Delta L_{ij}}{L^{\\mathrm{t}}_{j}} \\right) \\bar{q}^{\\mathrm{s}}_{i} $$\n这是一个从源向量 $\\bar{\\mathbf{q}}^{\\mathrm{s}}$到目标向量 $\\bar{\\mathbf{q}}^{\\mathrm{t}}$ 的线性变换，$\\bar{\\mathbf{q}}^{\\mathrm{t}} = M \\bar{\\mathbf{q}}^{\\mathrm{s}}$，其中传输矩阵 $M$ 的元素为 $M_{ji} = \\frac{\\Delta L_{ij}}{L^{\\mathrm{t}}_{j}}$。\n\n**守恒性分析**：守恒性要求量的总积分保持不变，即 $\\sum_{j=0}^{N_{\\mathrm{t}}-1} \\bar{q}^{\\mathrm{t}}_{j} L^{\\mathrm{t}}_{j} = \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} L^{\\mathrm{s}}_{i}$。\n从左手边开始：\n$$ \\sum_{j=0}^{N_{\\mathrm{t}}-1} \\bar{q}^{\\mathrm{t}}_{j} L^{\\mathrm{t}}_{j} = \\sum_{j=0}^{N_{\\mathrm{t}}-1} L^{\\mathrm{t}}_{j} \\left( \\frac{1}{L^{\\mathrm{t}}_{j}} \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} \\Delta L_{ij} \\right) = \\sum_{j=0}^{N_{\\mathrm{t}}-1} \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} \\Delta L_{ij} $$\n交换求和顺序：\n$$ \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} \\left( \\sum_{j=0}^{N_{\\mathrm{t}}-1} \\Delta L_{ij} \\right) $$\n内部的和 $\\sum_{j=0}^{N_{\\mathrm{t}}-1} \\Delta L_{ij}$ 是源单元 $i$ 与所有目标单元交集长度的总和。由于目标网格覆盖了整个域 $[0, 1]$，这个和恰好是源单元 $i$ 的长度，即 $\\sum_{j=0}^{N_{\\mathrm{t}}-1} \\Delta L_{ij} = L^{\\mathrm{s}}_{i}$。因此：\n$$ \\sum_{j=0}^{N_{\\mathrm{t}}-1} \\bar{q}^{\\mathrm{t}}_{j} L^{\\mathrm{t}}_{j} = \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} L^{\\mathrm{s}}_{i} $$\n因此，该算子在构造上是保守的。\n\n**有界性分析**：有界性要求 $\\min_{j} \\bar{q}^{\\mathrm{t}}_{j} \\ge \\min_{i} \\bar{q}^{\\mathrm{s}}_{i}$ 且 $\\max_{j} \\bar{q}^{\\mathrm{t}}_{j} \\le \\max_{i} \\bar{q}^{\\mathrm{s}}_{i}$。\n公式 $\\bar{q}^{\\mathrm{t}}_{j} = \\sum_{i=0}^{N_{\\mathrm{s}}-1} (\\frac{\\Delta L_{ij}}{L^{\\mathrm{t}}_{j}}) \\bar{q}^{\\mathrm{s}}_{i}$ 将 $\\bar{q}^{\\mathrm{t}}_{j}$ 表示为源值 $\\bar{q}^{\\mathrm{s}}_{i}$ 的加权平均。权重为 $w_{i} = \\frac{\\Delta L_{ij}}{L^{\\mathrm{t}}_{j}}$。\n这些权重是非负的，因为 $\\Delta L_{ij} \\ge 0$ 且 $L^{\\mathrm{t}}_{j} > 0$。\n对于给定的目标单元 $j$，权重之和为：\n$$ \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\frac{\\Delta L_{ij}}{L^{\\mathrm{t}}_{j}} = \\frac{1}{L^{\\mathrm{t}}_{j}} \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\Delta L_{ij} $$\n和 $\\sum_{i} \\Delta L_{ij}$ 是目标单元 $j$ 与所有源单元交集长度的总和，这等于目标单元 $j$ 的长度 $L^{\\mathrm{t}}_{j}$。所以，$\\sum_{i=0}^{N_{\\mathrm{s}}-1} w_{i} = \\frac{L^{\\mathrm{t}}_{j}}{L^{\\mathrm{t}}_{j}} = 1$。\n由于 $\\bar{q}^{\\mathrm{t}}_{j}$ 是值 $\\bar{q}^{\\mathrm{s}}_{i}$ 的凸组合（非负权重之和为 1），其值必须被 $\\bar{q}^{\\mathrm{s}}_{i}$ 值的最小值和最大值所界定。此属性保证了该算子是有界的。\n\n**2. 非保守算子（最近单元中心采样）**\n\n此算子由直接赋值定义。对于每个目标单元 $j$，我们首先计算其中心坐标 $c^{\\mathrm{t}}_{j} = \\frac{1}{2}(x^{\\mathrm{t}}_{j} + x^{\\mathrm{t}}_{j+1})$。然后我们找到包含该点的唯一源单元 $i$，即 $x^{\\mathrm{s}}_{i} \\le c^{\\mathrm{t}}_{j} \\le x^{\\mathrm{s}}_{i+1}$（对于最右边的单元，则为 $x^{\\mathrm{s}}_{i} \\le c^{\\mathrm{t}}_{j} \\le x^{\\mathrm{s}}_{i+1}$）。然后将目标单元的平均值设置为该源单元的平均值：\n$$ \\bar{q}^{\\mathrm{t}}_{j} = \\bar{q}^{\\mathrm{s}}_{i} \\quad \\text{其中 } c^{\\mathrm{t}}_{j} \\in [x^{\\mathrm{s}}_{i}, x^{\\mathrm{s}}_{i+1}] $$\n\n**守恒性分析**：目标网格上的总积分为：\n$$ \\sum_{j=0}^{N_{\\mathrm{t}}-1} \\bar{q}^{\\mathrm{t}}_{j} L^{\\mathrm{t}}_{j} = \\sum_{j=0}^{N_{\\mathrm{t}}-1} \\bar{q}^{\\mathrm{s}}_{\\text{map}(j)} L^{\\mathrm{t}}_{j} $$\n其中 $\\text{map}(j)$ 是包含目标单元 $j$ 中心的源单元的索引。我们可以按源单元索引 $i$ 对各项进行分组：\n$$ \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} \\left( \\sum_{j \\text{ s.t. } \\text{map}(j)=i} L^{\\mathrm{t}}_{j} \\right) $$\n括号中的项是其中心落入源单元 $i$ 内的所有目标单元的长度之和。这个和通常不等于源单元 $i$ 的长度 $L^{\\mathrm{s}}_{i}$。因此，总积分不被保持，该算子是非保守的。\n\n**有界性分析**：对于任何目标单元 $j$，其值 $\\bar{q}^{\\mathrm{t}}_{j}$ 只是源值 $\\bar{q}^{\\mathrm{s}}_{i}$ 之一的副本。这意味着所有目标值的集合 $\\{\\bar{q}^{\\mathrm{t}}_{j}\\}_{j=0}^{N_{\\mathrm{t}}-1}$ 是所有源值的集合 $\\{\\bar{q}^{\\mathrm{s}}_{i}\\}_{i=0}^{N_{\\mathrm{s}}-1}$ 的一个子集。因此，目标值的最小值不能小于源值的最小值，目标值的最大值不能大于源值的最大值。因此，该算子是固有有界的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests conservative and non-conservative\n    interpolation operators between non-matching 1D meshes.\n    \"\"\"\n    test_cases = [\n        # Case A (general non-matching, smooth-to-mixed data)\n        {\n            \"s_edges\": [0.0, 0.2, 0.5, 0.7, 1.0],\n            \"t_edges\": [0.0, 0.1, 0.4, 0.6, 0.85, 1.0],\n            \"s_data\": [0.0, 1.0, -0.5, 2.0],\n        },\n        # Case B (boundary alignment, constant data)\n        {\n            \"s_edges\": [0.0, 0.3, 0.6, 1.0],\n            \"t_edges\": [0.0, 0.3, 0.8, 1.0],\n            \"s_data\": [1.0, 1.0, 1.0],\n        },\n        # Case C (extreme size ratios, oscillatory data)\n        {\n            \"s_edges\": [0.0, 0.01, 0.02, 0.5, 1.0],\n            \"t_edges\": [0.0, 0.9, 0.95, 0.975, 1.0],\n            \"s_data\": [10.0, -10.0, 0.0, 1.0],\n        }\n    ]\n\n    tolerance = 1e-12\n    all_results = []\n\n    for case in test_cases:\n        s_edges = np.array(case[\"s_edges\"], dtype=float)\n        t_edges = np.array(case[\"t_edges\"], dtype=float)\n        s_data = np.array(case[\"s_data\"], dtype=float)\n\n        s_lens = np.diff(s_edges)\n        t_lens = np.diff(t_edges)\n        \n        num_s_cells = len(s_data)\n        num_t_cells = len(t_lens)\n\n        s_integral = np.sum(s_data * s_lens)\n        s_min, s_max = np.min(s_data), np.max(s_data)\n        \n        # 1. Conservative Operator\n        \n        # Assemble transfer matrix M_ji = overlap(s_i, t_j) / L_t_j\n        transfer_matrix_cons = np.zeros((num_t_cells, num_s_cells))\n        for j in range(num_t_cells):\n            t_start, t_end = t_edges[j], t_edges[j+1]\n            for i in range(num_s_cells):\n                s_start, s_end = s_edges[i], s_edges[i+1]\n                \n                # Calculate intersection length\n                overlap = max(0.0, min(s_end, t_end) - max(s_start, t_start))\n                \n                if t_lens[j] > 0:\n                    transfer_matrix_cons[j, i] = overlap / t_lens[j]\n\n        # Apply operator\n        t_data_cons = transfer_matrix_cons @ s_data\n        \n        # Check properties for conservative operator\n        t_integral_cons = np.sum(t_data_cons * t_lens)\n        cons_is_conserved = abs(s_integral - t_integral_cons) = tolerance\n        \n        t_min_cons = np.min(t_data_cons) if t_data_cons.size > 0 else 0\n        t_max_cons = np.max(t_data_cons) if t_data_cons.size > 0 else 0\n        \n        cons_is_bounded = (t_min_cons >= s_min - tolerance) and \\\n                          (t_max_cons = s_max + tolerance)\n\n        all_results.extend([cons_is_conserved, cons_is_bounded])\n\n        # 2. Non-Conservative Operator (Nearest Cell-Center)\n        \n        t_centers = (t_edges[:-1] + t_edges[1:]) / 2.0\n        \n        # Find the index of the source cell containing each target center\n        # np.searchsorted with side='right' finds insertion points to maintain order.\n        # For a value v and array a, it finds i such that a[:i] = v  a[i:].\n        # Subtracting 1 gives the index of the interval.\n        s_indices = np.searchsorted(s_edges, t_centers, side='right') - 1\n        \n        # The above can yield -1 or num_s_cells if t_centers are outside s_edges range.\n        # Although problem states domains match, clip for robustness.\n        s_indices = np.clip(s_indices, 0, num_s_cells - 1)\n        \n        # Apply operator\n        t_data_noncons = s_data[s_indices]\n        \n        # Check properties for non-conservative operator\n        t_integral_noncons = np.sum(t_data_noncons * t_lens)\n        noncons_is_conserved = abs(s_integral - t_integral_noncons) = tolerance\n        \n        t_min_noncons = np.min(t_data_noncons) if t_data_noncons.size > 0 else 0\n        t_max_noncons = np.max(t_data_noncons) if t_data_noncons.size > 0 else 0\n        \n        noncons_is_bounded = (t_min_noncons >= s_min - tolerance) and \\\n                             (t_max_noncons = s_max + tolerance)\n                             \n        all_results.extend([noncons_is_conserved, noncons_is_bounded])\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本原理之后，让我们将其应用于一个具体的多物理场耦合场景：辐射传热。在这个实践中，你将负责在不匹配的表面网格间传递辐射角系数，并验证能量平衡是否得到维持。这个练习旨在揭示，为何守恒插值不仅是一个理想的数学属性，更是确保仿真结果物理真实性的必要条件。",
            "id": "3501781",
            "problem": "考虑一个一维无量纲弧长域 $x \\in [0,1]$ 上的参数化辐射交换，该域代表一个闭合腔体的接收部分。对于每个发射面元 $i$，其方向角系数密度 $f_i(x) \\ge 0$ 被定义为一个非负函数，满足归一化条件\n$$\n\\int_0^1 f_i(x)\\,dx = 1.\n$$\n对于接收域的一个给予区间划分 $\\{I^{(d)}_\\alpha\\}_{\\alpha=1}^{N_d}$ 和一个接收区间划分 $\\{I^{(r)}_\\beta\\}_{\\beta=1}^{N_r}$，给予角系数定义为\n$$\nF^{(d)}_{i\\alpha} = \\int_{I^{(d)}_\\alpha} f_i(x)\\,dx,\n$$\n因此，对于每个发射体 $i$，总量平衡条件成立，\n$$\n\\sum_{\\alpha=1}^{N_d} F^{(d)}_{i\\alpha} = 1.\n$$\n任务是使用两种方法将给予角系数 $\\{F^{(d)}_{i\\alpha}\\}$ 映射到接收划分上，以获得 $\\{F^{(r)}_{i\\beta}\\}$：\n- 非守恒最近单元采样：在给予网格上为 $f_i(x)$ 构建一个分段常数近似 $g_i(x)$，方法是对于 $x \\in I^{(d)}_\\alpha$，设置 $g_i(x) = F^{(d)}_{i\\alpha}/|I^{(d)}_\\alpha|$。对于每个接收区间 $I^{(r)}_\\beta$，令 $c_\\beta$ 为其中心。找到中心最接近 $c_\\beta$ 的给予区间 $I^{(d)}_{\\alpha^\\ast}$，然后将该区间的平均密度乘以接收区间的长度，得到：\n$$\nF^{(r,\\mathrm{NC})}_{i\\beta} = \\left(\\frac{F^{(d)}_{i\\alpha^\\ast}}{|I^{(d)}_{\\alpha^\\ast}|}\\right)\\,|I^{(r)}_\\beta|.\n$$\n- 守恒重叠积分：使用相同的 $g_i(x)$，设置\n$$\nF^{(r,\\mathrm{C})}_{i\\beta} = \\int_{I^{(r)}_\\beta} g_i(x)\\,dx = \\sum_{\\alpha=1}^{N_d} \\left(\\frac{F^{(d)}_{i\\alpha}}{|I^{(d)}_\\alpha|}\\right)\\,\\left|I^{(r)}_\\beta \\cap I^{(d)}_\\alpha\\right|.\n$$\n定义每种方法下发射体 $i$ 的总辐射平衡误差为\n$$\ne^{(\\mathrm{NC})}_i = \\left|\\sum_{\\beta=1}^{N_r} F^{(r,\\mathrm{NC})}_{i\\beta} - 1\\right|,\\quad e^{(\\mathrm{C})}_i = \\left|\\sum_{\\beta=1}^{N_r} F^{(r,\\mathrm{C})}_{i\\beta} - 1\\right|.\n$$\n您的程序必须：\n- 对于下面的每个测试用例，通过在给予区间上对给定的 $f_i(x)$ 进行数值积分来构建 $\\{F^{(d)}_{i\\alpha}\\}_{\\alpha}$，确保对每个 $i$ 都满足归一化条件 $\\int_0^1 f_i(x)\\,dx = 1$。\n- 使用上述定义的非守恒和守恒方法，将 $\\{F^{(d)}_{i\\alpha}\\}$ 映射到 $\\{F^{(r)}_{i\\beta}\\}$。\n- 计算用例中所有发射体 $i$ 的 $e^{(\\mathrm{NC})}_i$ 和 $e^{(\\mathrm{C})}_i$，然后报告每种方法在所有发射体上的最大误差，即 $\\max_i e^{(\\mathrm{NC})}_i$ 和 $\\max_i e^{(\\mathrm{C})}_i$。\n\n全程使用无量纲单位，并将所有输出表示为浮点数。不涉及角度。必须实现以下测试套件：\n\n- 测试用例 $1$：\n  - 给予区间边界：$[0,\\,0.4,\\,1.0]$。\n  - 接收区间边界：$[0,\\,0.3,\\,0.6,\\,1.0]$。\n  - 发射体及其密度：\n    - $f_1(x) = \\exp\\!\\left(-\\dfrac{(x-0.7)^2}{2\\cdot 0.1^2}\\right)$,\n    - $f_2(x) = 1$,\n    - $f_3(x) = x + 0.1$。\n\n- 测试用例 $2$：\n  - 给予区间边界：$[0,\\,0.2,\\,0.4,\\,0.6,\\,0.8,\\,1.0]$。\n  - 接收区间边界：$[0,\\,0.55,\\,1.0]$。\n  - 发射体及其密度：\n    - $f_1(x) = \\sin^2(8\\pi x)$,\n    - $f_2(x) = \\exp\\!\\left(-\\dfrac{(x-0.1)^2}{2\\cdot 0.05^2}\\right)$。\n\n- 测试用例 $3$：\n  - 给予区间边界：$[0,\\,0.15,\\,0.22,\\,0.5,\\,0.51,\\,0.9,\\,1.0]$。\n  - 接收区间边界：$[0,\\,0.02,\\,0.25,\\,0.49,\\,0.76,\\,1.0]$。\n  - 发射体及其密度：\n    - $f_1(x) = 0.5 + 2x(1-x)$,\n    - $f_2(x) = \\exp\\!\\left(-\\dfrac{(x-0.95)^2}{2\\cdot 0.02^2}\\right)$。\n\n- 测试用例 $4$：\n  - 给予区间边界：$[0,\\,0.31,\\,0.32,\\,0.7,\\,1.0]$。\n  - 接收区间边界：$[0,\\,0.29,\\,0.33,\\,0.68,\\,1.0]$。\n  - 发射体及其密度：\n    - $f_1(x) = 1$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个双元素列表，按顺序包含非守恒方法的最大误差和守恒方法的最大误差。例如，您的输出应类似于 $[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]]$，其中 $a_k$ 和 $b_k$ 是测试用例 $k$ 的浮点数。",
            "solution": "该问题要求比较两种不同的数值方案，用于在两个不匹配的一维网格之间传输数据——具体来说，是代表辐射交换的角系数。核心任务是评估每种方案的守恒性质。如果传输到接收网格的总量等于来自给予网格的总量，则该方案被认为是守恒的。\n\n这里所考察的基本原理是在物理量跨离散化域进行数值输运过程中的守恒性。在此背景下，该物理量是来自给定发射体 $i$ 的总角系数，根据条件 $\\int_0^1 f_i(x)\\,dx = 1$，该角系数被归一化为1。给予网格上的总角系数 $\\sum_{\\alpha=1}^{N_d} F^{(d)}_{i\\alpha}$ 和接收网格上的总角系数 $\\sum_{\\beta=1}^{N_r} F^{(r)}_{i\\beta}$ 都必须等于 $1$，以维持能量平衡。误差度量 $e^{(\\mathrm{NC})}_i$ 和 $e^{(\\mathrm{C})}_i$ 量化了每种映射方法与此所需平衡的偏差。\n\n解决此问题对每个发射体 $i$ 的步骤如下：\n\n1.  **密度函数的归一化**：所提供的函数（我们可表示为 $f_{i,\\text{given}}(x)$）与角系数密度成正比。为了作为有效的密度函数，每个函数都必须在域 $x \\in [0,1]$ 上进行归一化。我们计算归一化常数 $C_i = \\int_0^1 f_{i,\\text{given}}(x)\\,dx$。于是，正确且归一化的角系数密度为 $f_i(x) = f_{i,\\text{given}}(x) / C_i$。这确保了 $\\int_0^1 f_i(x)\\,dx = 1$ 这一基本要求。该积分使用高精度求积方法进行数值计算。\n\n2.  **在给予网格上的离散化**：将连续密度 $f_i(x)$ 离散化到给予划分 $\\{I^{(d)}_\\alpha\\}_{\\alpha=1}^{N_d}$ 上。通过在该区间上对归一化密度进行积分来计算每个区间 $I^{(d)}_\\alpha$ 的给予角系数：$F^{(d)}_{i\\alpha} = \\int_{I^{(d)}_\\alpha} f_i(x)\\,dx$。根据构造，这些离散角系数在整个给予网格上的总和为 $\\sum_{\\alpha=1}^{N_d} F^{(d)}_{i\\alpha} = \\sum_{\\alpha=1}^{N_d} \\int_{I^{(d)}_\\alpha} f_i(x)\\,dx = \\int_0^1 f_i(x)\\,dx = 1$。\n\n3.  **分段常数重构**：两种映射方法都基于原始密度函数 $f_i(x)$ 的一个分段常数近似 $g_i(x)$。此近似是根据离散的给予角系数构建的。在每个给予区间 $I^{(d)}_\\alpha$ 上，函数 $g_i(x)$ 被赋予一个等于该区间上平均密度的常数值：对于 $x \\in I^{(d)}_\\alpha$，有 $g_i(x) = F^{(d)}_{i\\alpha} / |I^{(d)}_\\alpha|$。\n\n4.  **映射到接收网格**：然后使用两种指定的方法将离散数据从给予网格传输到接收网格 $\\{I^{(r)}_\\beta\\}_{\\beta=1}^{N_r}$。\n\n    a.  **非守恒最近单元采样**：此方法是一种点采样。对于每个接收区间 $I^{(r)}_\\beta$，定位其中心 $c_\\beta$。然后，我们识别出其中心 $c_{\\alpha^\\ast}$ 最接近 $c_\\beta$ 的给予区间 $I^{(d)}_{\\alpha^\\ast}$。在对应于该给予区间中心的位置对重构函数 $g_i(x)$ 的值进行采样，即 $g_i(c_{\\alpha^\\ast}) = F^{(d)}_{i\\alpha^\\ast}/|I^{(d)}_{\\alpha^\\ast}|$。然后将此采样值视为在整个接收区间 $I^{(r)}_\\beta$ 上是恒定的，从而得到接收角系数 $F^{(r,\\mathrm{NC})}_{i\\beta} = \\left(F^{(d)}_{i\\alpha^\\ast}/|I^{(d)}_{\\alpha^\\ast}|\\right) \\cdot |I^{(r)}_\\beta|$。此方法计算效率高，但通常不守恒，因为总和 $\\sum_{\\beta=1}^{N_r} F^{(r,\\mathrm{NC})}_{i\\beta}$ 不保证等于 $1$。问题陈述中对于当一个接收中心与两个或多个给予中心等距时的处理方法存在轻微的歧义；我们采用一种确定性规则，例如选择索引最小的那个。\n\n    b.  **守恒重叠积分**：此方法通过在接收区间 $I^{(r)}_\\beta$ 上对分段常数函数 $g_i(x)$ 进行积分来计算接收角系数 $F^{(r,\\mathrm{C})}_{i\\beta}$。该积分是作为与 $I^{(r)}_\\beta$ 重叠的每个给予区间 $I^{(d)}_\\alpha$ 的贡献总和来计算的：\n    $$ F^{(r,\\mathrm{C})}_{i\\beta} = \\int_{I^{(r)}_\\beta} g_i(x)\\,dx = \\sum_{\\alpha=1}^{N_d} \\left(\\frac{F^{(d)}_{i\\alpha}}{|I^{(d)}_\\alpha|}\\right)\\,\\left|I^{(r)}_\\beta \\cap I^{(d)}_\\alpha\\right| $$\n    其中 $|I^{(r)}_\\beta \\cap I^{(d)}_\\alpha|$ 是两个区间交集的长度。此方法是内在守恒的，可以通过对接收角系数求和来证明：\n    $$ \\sum_{\\beta=1}^{N_r} F^{(r,\\mathrm{C})}_{i\\beta} = \\sum_{\\beta=1}^{N_r} \\sum_{\\alpha=1}^{N_d} \\left(\\frac{F^{(d)}_{i\\alpha}}{|I^{(d)}_\\alpha|}\\right)\\,\\left|I^{(r)}_\\beta \\cap I^{(d)}_\\alpha\\right| $$\n    通过交换求和顺序：\n    $$ = \\sum_{\\alpha=1}^{N_d} \\frac{F^{(d)}_{i\\alpha}}{|I^{(d)}_\\alpha|} \\sum_{\\beta=1}^{N_r} \\left|I^{(r)}_\\beta \\cap I^{(d)}_\\alpha\\right| $$\n    由于 $\\{I^{(r)}_\\beta\\}$ 构成了域 $[0,1]$ 的一个划分，任何给定给予区间 $I^{(d)}_\\alpha$ 与所有接收区间的交集长度之和等于该给予区间自身的长度：$\\sum_{\\beta=1}^{N_r} |I^{(r)}_\\beta \\cap I^{(d)}_\\alpha| = |I^{(d)}_\\alpha|$。代入此式可得：\n    $$ = \\sum_{\\alpha=1}^{N_d} \\frac{F^{(d)}_{i\\alpha}}{|I^{(d)}_\\alpha|} |I^{(d)}_\\alpha| = \\sum_{\\alpha=1}^{N_d} F^{(d)}_{i\\alpha} = 1 $$\n    因此，总角系数是守恒的，守恒误差 $e^{(\\mathrm{C})}_i$ 预计在浮点精度的限制内为零。\n\n5.  **误差计算**：最后，对于每个发射体 $i$ 和每种方法，对映射后的总角系数求和，并计算其与 $1$ 的绝对差，以得出总辐射平衡误差 $e^{(\\mathrm{NC})}_i$ 和 $e^{(\\mathrm{C})}_i$。报告每个测试用例中所有发射体在每种方法下的最大误差。\n\n实现将利用 `scipy.integrate` 库的数值求积功能进行精确积分，并利用 `numpy` 的数组操作能力来高效地处理网格数据结构和计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing non-conservative and conservative data transfer\n    methods between non-matching meshes.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"d_edges\": [0.0, 0.4, 1.0],\n            \"r_edges\": [0.0, 0.3, 0.6, 1.0],\n            \"funcs\": [\n                lambda x: np.exp(-(x - 0.7)**2 / (2 * 0.1**2)),\n                lambda x: 1.0,\n                lambda x: x + 0.1,\n            ]\n        },\n        {\n            \"d_edges\": [0.0, 0.2, 0.4, 0.6, 0.8, 1.0],\n            \"r_edges\": [0.0, 0.55, 1.0],\n            \"funcs\": [\n                lambda x: np.sin(8 * np.pi * x)**2,\n                lambda x: np.exp(-(x - 0.1)**2 / (2 * 0.05**2)),\n            ]\n        },\n        {\n            \"d_edges\": [0.0, 0.15, 0.22, 0.5, 0.51, 0.9, 1.0],\n            \"r_edges\": [0.0, 0.02, 0.25, 0.49, 0.76, 1.0],\n            \"funcs\": [\n                lambda x: 0.5 + 2 * x * (1 - x),\n                lambda x: np.exp(-(x - 0.95)**2 / (2 * 0.02**2)),\n            ]\n        },\n        {\n            \"d_edges\": [0.0, 0.31, 0.32, 0.7, 1.0],\n            \"r_edges\": [0.0, 0.29, 0.33, 0.68, 1.0],\n            \"funcs\": [\n                lambda x: 1.0,\n            ]\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        d_edges = np.array(case[\"d_edges\"])\n        r_edges = np.array(case[\"r_edges\"])\n        funcs = case[\"funcs\"]\n\n        d_intervals = list(zip(d_edges[:-1], d_edges[1:]))\n        d_lengths = np.diff(d_edges)\n        d_centers = (d_edges[:-1] + d_edges[1:]) / 2.0\n\n        r_intervals = list(zip(r_edges[:-1], r_edges[1:]))\n        r_lengths = np.diff(r_edges)\n        r_centers = (r_edges[:-1] + r_edges[1:]) / 2.0\n\n        max_err_nc = 0.0\n        max_err_c = 0.0\n\n        for f_unnormalized in funcs:\n            # 1. Normalize the density function\n            norm_const, _ = integrate.quad(f_unnormalized, 0, 1)\n            f_normalized = lambda x: f_unnormalized(x) / norm_const\n\n            # 2. Calculate donor view factors F_i_alpha\n            F_d = np.array([integrate.quad(f_normalized, start, end)[0] for start, end in d_intervals])\n\n            # 3. Construct piecewise-constant approximation g_i(x)\n            g_i_vals = F_d / d_lengths\n\n            # 4a. Non-conservative mapping\n            total_F_r_nc = 0.0\n            for r_center, r_len in zip(r_centers, r_lengths):\n                # Find the closest donor center\n                dists = np.abs(d_centers - r_center)\n                alpha_star = np.argmin(dists)\n                \n                F_r_nc_beta = g_i_vals[alpha_star] * r_len\n                total_F_r_nc += F_r_nc_beta\n            \n            err_nc = abs(total_F_r_nc - 1.0)\n            if err_nc > max_err_nc:\n                max_err_nc = err_nc\n\n            # 4b. Conservative mapping\n            total_F_r_c = 0.0\n            for r_int_start, r_int_end in r_intervals:\n                F_r_c_beta = 0.0\n                for alpha_idx, (d_int_start, d_int_end) in enumerate(d_intervals):\n                    # Calculate intersection length\n                    overlap_start = max(r_int_start, d_int_start)\n                    overlap_end = min(r_int_end, d_int_end)\n                    intersection_len = max(0, overlap_end - overlap_start)\n                    \n                    if intersection_len > 0:\n                        F_r_c_beta += g_i_vals[alpha_idx] * intersection_len\n                \n                total_F_r_c += F_r_c_beta\n                \n            err_c = abs(total_F_r_c - 1.0)\n            if err_c > max_err_c:\n                max_err_c = err_c\n        \n        all_results.append([max_err_nc, max_err_c])\n\n    # Final print statement in the exact required format.\n    # The replace(' ', '') is to match the no-space format in the problem example.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "在实际模拟中，我们经常遇到激波或材料界面这类数据急剧变化的间斷情况，简单的数据传递方法此时可能会失效。这项高阶挑战将引导你对比一种高阶插值方法和一种先进的守恒重映（remap）方法。你将直面高阶方法可能引起的非物理Gibbs振荡，并学习如何通过引入单调性限制来抑制这些振荡，同时仍然严格保证物理量的守恒。",
            "id": "3501733",
            "problem": "考虑在多物理场耦合模拟中，跨越两个计算网格之间非匹配界面的一维数据传输。设物理域为闭区间 $[0,1]$。源网格将 $[0,1]$ 剖分为 $N_s$ 个单元，其边为 $\\{x^s_0, x^s_1, \\dots, x^s_{N_s}\\}$，其中 $x^s_0 = 0$， $x^s_{N_s} = 1$；目标网格将 $[0,1]$ 剖分为 $N_t$ 个单元，其边为 $\\{x^t_0, x^t_1, \\dots, x^t_{N_t}\\}$，其中 $x^t_0 = 0$， $x^t_{N_t} = 1$。将源单元 $i$ 表示为 $[x^s_i, x^s_{i+1}]$，目标单元 $j$ 表示为 $[x^t_j, x^t_{j+1}]$。定义源单元中心 $c^s_i = \\frac{1}{2}(x^s_i + x^s_{i+1})$ 和目标单元中心 $c^t_j = \\frac{1}{2}(x^t_j + x^t_{j+1})$，以及单元长度 $\\Delta x^s_i = x^s_{i+1} - x^s_i$，$\\Delta x^t_j = x^t_{j+1} - x^t_j$。\n\n已知的源场以单元平均值 $\\bar{u}^s_i$ 的形式给出，这被解释为底层标量场 $u(x)$ 在每个源单元上的平均值：\n$$\n\\bar{u}^s_i = \\frac{1}{\\Delta x^s_i} \\int_{x^s_i}^{x^s_{i+1}} u(x)\\,dx.\n$$\n对于本问题，设 $u(x)$ 是位于位置 $x_\\star \\in (0,1)$ 的单位 Heaviside 阶跃函数，即当 $x  x_\\star$ 时 $u(x) = 0$，当 $x \\ge x_\\star$ 时 $u(x) = 1$。\n\n必须实现两种不同的数据传输方法：\n\n1. 一种非守恒高阶插值方法，该方法使用拟合数据 $\\{(c^s_i, \\bar{u}^s_i)\\}$ 的自然三次样条 $S(x)$，将定义在源单元中心 $c^s_i$ 上的 $\\bar{u}^s_i$ 映射到目标单元中心 $c^t_j$ 上的点值 $v^t_j$。映射的目标值为 $v^t_j = S(c^t_j)$。为了进行诊断分析，将 $v^t_j$ 视为目标单元的平均值。该方法预计在 $x_\\star$ 处的间断点附近产生 Gibbs 型振荡，并且不满足积分守恒。\n\n2. 一种使用最小模 (minmod) 斜率限制器的分段线性重构的守恒保单调重映方法。通过以下公式在每个源单元中心定义受限斜率 $s_i$：\n$$\ns_i = \\operatorname{minmod}\\left(\\frac{\\bar{u}^s_i - \\bar{u}^s_{i-1}}{c^s_i - c^s_{i-1}},\\; \\frac{\\bar{u}^s_{i+1} - \\bar{u}^s_i}{c^s_{i+1} - c^s_i}\\right),\n$$\n其中边界斜率为 $s_0 = 0$ 和 $s_{N_s-1} = 0$，最小模函数为\n$$\n\\operatorname{minmod}(a,b) = \\begin{cases}\n\\operatorname{sign}(a)\\,\\min(|a|,|b|),  \\text{if } ab > 0,\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n在每个源单元 $i$ 中重构一个线性剖面\n$$\nu_i(x) = \\bar{u}^s_i + s_i \\left(x - c^s_i\\right), \\quad x \\in [x^s_i, x^s_{i+1}],\n$$\n并通过对重构的源剖面进行精确重叠积分来定义目标单元平均值：\n$$\n\\bar{u}^t_j = \\frac{1}{\\Delta x^t_j} \\sum_{i=0}^{N_s-1} \\int_{\\max(x^t_j, x^s_i)}^{\\min(x^t_{j+1}, x^s_{i+1})} u_i(x)\\,dx,\n$$\n约定在空区间上的积分为零。该方法在构造上是积分守恒的，并且由于使用了 minmod 限制器，不会产生新的极值，从而避免了 Gibbs 型振荡。\n\n必须为两种方法计算用于量化界面振荡和守恒性的诊断量：\n\n- 源网格上的离散积分（总质量）：\n$$\nM_s = \\sum_{i=0}^{N_s-1} \\bar{u}^s_i \\,\\Delta x^s_i.\n$$\n- 非守恒方法在目标网格上的离散积分：\n$$\nM_t^{\\mathrm{nc}} = \\sum_{j=0}^{N_t-1} v^t_j \\,\\Delta x^t_j,\n$$\n以及守恒方法的离散积分：\n$$\nM_t^{\\mathrm{c}} = \\sum_{j=0}^{N_t-1} \\bar{u}^t_j \\,\\Delta x^t_j.\n$$\n报告绝对守恒误差 $E^{\\mathrm{nc}} = |M_t^{\\mathrm{nc}} - M_s|$ 和 $E^{\\mathrm{c}} = |M_t^{\\mathrm{c}} - M_s|$。\n\n- 界面附近的振荡幅度（过冲/下冲违背量）按如下方式量化。对于每个目标中心 $c^t_j$，找到最近的源中心的索引 $i^\\star$，并定义局部源包络\n$$\nm_j^- = \\min\\{\\bar{u}^s_{i^\\star-1}, \\bar{u}^s_{i^\\star}, \\bar{u}^s_{i^\\star+1}\\}, \\quad m_j^+ = \\max\\{\\bar{u}^s_{i^\\star-1}, \\bar{u}^s_{i^\\star}, \\bar{u}^s_{i^\\star+1}\\},\n$$\n其中索引被限制在有效范围内。对于非守恒方法，局部违背量为\n$$\n\\delta^{\\mathrm{nc}}_j = \\max\\left(0,\\; v^t_j - m_j^+,\\; m_j^- - v^t_j\\right),\n$$\n对于守恒方法，将 $v^t_j$ 替换为 $\\bar{u}^t_j$ 以获得 $\\delta^{\\mathrm{c}}_j$。报告振荡幅度 $A^{\\mathrm{nc}} = \\max_j \\delta^{\\mathrm{nc}}_j$ 和 $A^{\\mathrm{c}} = \\max_j \\delta^{\\mathrm{c}}_j$。\n\n- 对于序列 $\\{w_k\\}$，离散总变差 (TV) 定义为\n$$\n\\operatorname{TV}(\\{w_k\\}) = \\sum_{k=1}^{K-1} |w_k - w_{k-1}|.\n$$\n计算 $\\operatorname{TV}_s = \\operatorname{TV}(\\{\\bar{u}^s_i\\}_{i=0}^{N_s-1})$、$\\operatorname{TV}_t^{\\mathrm{nc}} = \\operatorname{TV}(\\{v^t_j\\}_{j=0}^{N_t-1})$ 和 $\\operatorname{TV}_t^{\\mathrm{c}} = \\operatorname{TV}(\\{\\bar{u}^t_j\\}_{j=0}^{N_t-1})$。报告 TV 增量 $\\Delta \\operatorname{TV}^{\\mathrm{nc}} = \\operatorname{TV}_t^{\\mathrm{nc}} - \\operatorname{TV}_s$ 和 $\\Delta \\operatorname{TV}^{\\mathrm{c}} = \\operatorname{TV}_t^{\\mathrm{c}} - \\operatorname{TV}_s$。\n\n- 保单调性布尔值 $B^{\\mathrm{nc}}$ 和 $B^{\\mathrm{c}}$，分别表示 $A^{\\mathrm{nc}} = 0$ 和 $A^{\\mathrm{c}} = 0$ 是否在数值容差范围内成立。\n\n为以下测试套件实现上述内容（每个案例指定源网格、目标网格和 $x_\\star$）：\n\n- 案例 1（均匀非匹配网格，界面位于域中间）：源网格为均匀网格，$N_s = 16$；目标网格为均匀网格，$N_t = 21$；阶跃位置 $x_\\star = 0.5$。\n\n- 案例 2（近似棋盘状非匹配网格，偏离中心的界面）：源网格具有交替单元长度模式 $[0.03, 0.07]$，重复此模式以填充 $[0,1]$，并修剪最后一个单元使其恰好在 $1$ 处结束；目标网格具有交替模式 $[0.07, 0.03]$，同样重复并修剪；阶跃位置 $x_\\star = 0.31$。\n\n- 案例 3（均匀网格，界面靠近边界）：源网格为均匀网格，$N_s = 10$；目标网格为均匀网格，$N_t = 12$；阶跃位置 $x_\\star = 0.05$。\n\n对于每个案例，计算并返回列表\n$$\n\\left[ A^{\\mathrm{nc}},\\; E^{\\mathrm{nc}},\\; \\Delta \\operatorname{TV}^{\\mathrm{nc}},\\; B^{\\mathrm{nc}},\\; A^{\\mathrm{c}},\\; E^{\\mathrm{c}},\\; \\Delta \\operatorname{TV}^{\\mathrm{c}},\\; B^{\\mathrm{c}} \\right].\n$$\n你的程序应生成单行输出，其中包含结果，格式为用方括号括起来的逗号分隔列表，每个测试案例的结果本身也是一个用方括号括起来的逗号分隔列表（例如，“[[c1_result1,c1_result2,...],[c2_result1,c2_result2,...],[c3_result1,c3_result2,...]]”）。所有报告的量均为无量纲实数或布尔值；不需要物理单位。无需用户输入；所有参数均如上预先确定。",
            "solution": "该问题要求实现并比较两种在非匹配一维网格之间的数据传输方法：一种是非守恒的三次样条插值，另一种是守恒的、保单调的分段线性重映。这些方法的性能将通过一个间断测试案例（Heaviside 阶跃函数）进行评估，使用一套衡量守恒误差、伪振荡和总变差的诊断标准。\n\n首先，我们建立计算框架。域为区间 $[0, 1]$。源网格由 $N_s+1$ 个边 $\\{x^s_i\\}_{i=0}^{N_s}$ 定义，其中 $x^s_0=0$ 且 $x^s_{N_s}=1$，形成 $N_s$ 个单元。类似地，目标网格由 $N_t+1$ 个边 $\\{x^t_j\\}_{j=0}^{N_t}$ 定义。源单元 $i$ 为 $[x^s_i, x^s_{i+1}]$，其长度为 $\\Delta x^s_i = x^s_{i+1} - x^s_i$，中心为 $c^s_i = (x^s_i + x^s_{i+1}) / 2$。相应地，目标单元 $j$ 为 $[x^t_j, x^t_{j+1}]$，其长度为 $\\Delta x^t_j$，中心为 $c^t_j$。\n\n底层数据场是位于 $x_\\star \\in (0,1)$ 的单位 Heaviside 阶跃函数：\n$$\nU(x) = \\begin{cases} 0,  x  x_\\star \\\\ 1,  x \\ge x_\\star \\end{cases}\n$$\n我们映射算法的输入不是连续函数 $U(x)$，而是其在源网格上的单元平均值 $\\bar{u}^s_i$。这些值是通过在每个源单元上对 $U(x)$ 进行积分计算得出的：\n$$\n\\bar{u}^s_i = \\frac{1}{\\Delta x^s_i} \\int_{x^s_i}^{x^s_{i+1}} U(x)\\,dx = \\frac{\\max(0, x^s_{i+1} - \\max(x^s_i, x_\\star))}{\\Delta x^s_i}\n$$\n对于完全位于 $x_\\star$ 左侧的任何单元 $[x^s_i, x^s_{i+1}]$（即 $x^s_{i+1} \\le x_\\star$），$\\bar{u}^s_i=0$。对于完全位于右侧的任何单元（即 $x^s_i \\ge x_\\star$），$\\bar{u}^s_i=1$。对于包含 $x_\\star$ 的单个单元，使得 $x^s_i  x_\\star  x^s_{i+1}$，其平均值为 $\\bar{u}^s_i = (x^s_{i+1}-x_\\star)/\\Delta x^s_i$，该值严格介于 $0$ 和 $1$ 之间。\n\n第一种传输方法是**非守恒、高阶插值**。我们构建一个自然三次样条，记为 $S(x)$，它插值源数据对 $\\{(c^s_i, \\bar{u}^s_i)\\}_{i=0}^{N_s-1}$。自然样条的定义是其在端点的二阶导数为零，即 $S''(c^s_0)=0$ 和 $S''(c^s_{N_s-1})=0$。当没有其他边界信息已知时，这是一个标准的选择。然后通过在目标单元中心处对样条求值，将数据传输到目标网格：\n$$\nv^t_j = S(c^t_j)\n$$\n为了诊断分析，这些点值 $v^t_j$ 被视为目标网格的单元平均值。众所周知，高阶插值能准确捕捉光滑函数，但通常在间断点附近引入伪振荡（Gibbs 现象），并且通常不守恒积分量。\n\n第二种方法是**守恒、保单调重映**。构建此方法的目的是守恒量的总积分并防止产生新的振荡。它包括三个步骤：重构、积分和平均。首先，在每个源单元 $i$ 中重构数据的分段线性表示 $u_i(x)$：\n$$\nu_i(x) = \\bar{u}^s_i + s_i (x - c^s_i) \\quad \\text{for } x \\in [x^s_i, x^s_{i+1}]\n$$\n为保证单调性，斜率 $s_i$ 使用最小模 (minmod) 限制器计算，该限制器选择左右中心差分斜率中幅值较小的一个，如果两者符号相反则取零。\n$$\ns_i = \\operatorname{minmod}\\left(\\frac{\\bar{u}^s_i - \\bar{u}^s_{i-1}}{c^s_i - c^s_{i-1}}, \\frac{\\bar{u}^s_{i+1} - \\bar{u}^s_i}{c^s_{i+1} - c^s_i}\\right) \\quad \\text{for } i \\in [1, N_s-2]\n$$\n边界斜率为 $s_0 = 0$ 和 $s_{N_s-1} = 0$。minmod 函数定义为：如果 $ab > 0$，则 $\\operatorname{minmod}(a,b) = \\operatorname{sign}(a)\\min(|a|, |b|)$，否则为 $0$。这种重构确保不会产生新的局部极值。\n\n接下来，通过在每个目标单元上对此分段线性源重构进行积分，来获得目标单元平均值 $\\bar{u}^t_j$。这是通过在每个源单元 $i$ 和目标单元 $j$ 的交集上进行精确积分来实现的：\n$$\n\\bar{u}^t_j = \\frac{1}{\\Delta x^t_j} \\sum_{i=0}^{N_s-1} \\int_{x_\\text{start}}^{x_\\text{end}} u_i(x)\\,dx, \\quad \\text{where } [x_\\text{start}, x_\\text{end}] = [x^t_j, x^t_{j+1}] \\cap [x^s_i, x^s_{i+1}]\n$$\n线性函数 $u_i(x)$ 在区间 $[a,b]$ 上的积分为 $[(\\bar{u}^s_i - s_i c^s_i)x + \\frac{1}{2}s_i x^2]_a^b$。对于给定的目标单元 $j$，将其在所有源单元 $i$ 上的积分贡献求和，再除以目标单元长度 $\\Delta x^t_j$，即可完成守恒传输。根据构造，此方法确保在机器精度范围内 $\\sum_j \\bar{u}^t_j \\Delta x^t_j = \\sum_i \\bar{u}^s_i \\Delta x^s_i$ 成立。\n\n最后，我们计算若干诊断量来量化性能。\n- **绝对守恒误差**，$E^{\\mathrm{nc}} = |M_t^{\\mathrm{nc}} - M_s|$ 和 $E^{\\mathrm{c}} = |M_t^{\\mathrm{c}} - M_s|$，用于衡量总积分量的变化，其中 $M_s = \\sum_i \\bar{u}^s_i \\Delta x^s_i$，$M_t = \\sum_j \\bar{u}^t_j \\Delta x^t_j$（对于非守恒情况使用 $v^t_j$）。我们期望 $E^{\\mathrm{c}} \\approx 0$。\n- **振荡幅度**，$A^{\\mathrm{nc}}$ 和 $A^{\\mathrm{c}}$，衡量映射值违背源数据局部界限的程度。对于每个目标单元 $j$，根据目标单元中心邻域内源数据的最小值和最大值确定一个局部源包络 $[m_j^-, m_j^+]$。违背量是目标值超出此包络的量。$A$ 是所有目标单元中的最大违背量。我们期望 $A^{\\mathrm{c}} = 0$，表示保单调性，而 $A^{\\mathrm{nc}} > 0$。相应的布尔值 $B^{\\mathrm{c}}$ 和 $B^{\\mathrm{nc}}$ 将此检查形式化。\n- **总变差 (TV) 的变化**，$\\Delta\\operatorname{TV} = \\operatorname{TV}(\\text{目标数据}) - \\operatorname{TV}(\\text{源数据})$，其中 $\\operatorname{TV}(\\{w_k\\}) = \\sum_{k} |w_{k+1} - w_k|$。保单调格式的总变差预计是不增加的，因此我们期望 $\\Delta\\operatorname{TV}^{\\mathrm{c}} \\le 0$，而振荡的样条方法可能会增加 TV，因此 $\\Delta\\operatorname{TV}^{\\mathrm{nc}} > 0$。\n\n通过将这些方法和诊断标准应用于指定的测试案例，我们可以定量地展示高阶精度与保持守恒和单调性等物理原则之间的基本权衡。",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef generate_mesh(N=None, pattern=None):\n    \"\"\"Generates a mesh on [0,1] either uniformly or from a pattern.\"\"\"\n    if N is not None:  # Uniform mesh\n        edges = np.linspace(0, 1, N + 1)\n    elif pattern is not None:  # Pattern-based mesh\n        edges = [0.0]\n        current_x = 0.0\n        i = 0\n        while current_x  1.0 - 1e-9: # Loop until we are at or past 1.0\n            current_x += pattern[i % len(pattern)]\n            edges.append(current_x)\n            i += 1\n        edges[-1] = 1.0  # Trim the last edge to be exactly 1.0\n        edges = np.array(edges)\n    else:\n        raise ValueError(\"Either N or pattern must be provided.\")\n    \n    centers = 0.5 * (edges[:-1] + edges[1:])\n    lengths = edges[1:] - edges[:-1]\n    return edges, centers, lengths\n\ndef minmod(a, b):\n    \"\"\"The minmod slope limiter function.\"\"\"\n    return np.sign(a) * np.minimum(np.abs(a), np.abs(b)) * (np.sign(a) == np.sign(b))\n\ndef calculate_tv(data):\n    \"\"\"Computes the total variation of a 1D array.\"\"\"\n    return np.sum(np.abs(np.diff(data)))\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a single test case for data transfer between non-matching meshes.\n    \"\"\"\n    source_mesh_def, target_mesh_def, x_star = case_params\n    \n    # 1. Generate meshes and source data\n    x_s, c_s, dx_s = generate_mesh(**source_mesh_def)\n    x_t, c_t, dx_t = generate_mesh(**target_mesh_def)\n    N_s = len(c_s)\n    N_t = len(c_t)\n\n    # Calculate source cell-average data from Heaviside step function\n    u_s_bar = np.maximum(0, x_s[1:] - np.maximum(x_s[:-1], x_star)) / dx_s\n\n    # 2. Method 1: Non-conservative spline interpolation\n    spline = CubicSpline(c_s, u_s_bar, bc_type='natural')\n    v_t = spline(c_t)\n\n    # 3. Method 2: Conservative piecewise linear remap\n    # 3.1. Calculate limited slopes\n    s = np.zeros(N_s)\n    # Slopes are zero for cells not adjacent to the discontinuity\n    disc_idx = np.where( (u_s_bar > 0)  (u_s_bar  1) )[0]\n    if len(disc_idx) > 0:\n        idx = disc_idx[0]\n        # Calculate slopes only around the discontinuity.\n        for i in range(max(1, idx - 1), min(N_s - 1, idx + 2)):\n            slope_L = (u_s_bar[i] - u_s_bar[i-1]) / (c_s[i] - c_s[i-1])\n            slope_R = (u_s_bar[i+1] - u_s_bar[i]) / (c_s[i+1] - c_s[i])\n            s[i] = minmod(slope_L, slope_R)\n\n    # 3.2. Overlap integration\n    u_t_bar = np.zeros(N_t)\n    for j in range(N_t):\n        total_integral = 0.0\n        for i in range(N_s):\n            # Find intersection of source cell i and target cell j\n            x_start = np.maximum(x_t[j], x_s[i])\n            x_end = np.minimum(x_t[j+1], x_s[i+1])\n\n            if x_start  x_end:\n                # Indefinite integral: I(x) = (u_bar - s*c)*x + 0.5*s*x^2\n                const_term = u_s_bar[i] - s[i] * c_s[i]\n                integral_val = (const_term * (x_end - x_start) + \n                                0.5 * s[i] * (x_end**2 - x_start**2))\n                total_integral += integral_val\n        u_t_bar[j] = total_integral / dx_t[j]\n\n    # 4. Diagnostics\n    tol = 1e-12\n    \n    # 4.1. Conservation Error\n    M_s = np.sum(u_s_bar * dx_s)\n    M_t_nc = np.sum(v_t * dx_t)\n    M_t_c = np.sum(u_t_bar * dx_t)\n    \n    E_nc = np.abs(M_t_nc - M_s)\n    E_c = np.abs(M_t_c - M_s)\n\n    # 4.2. Oscillation Amplitude\n    # Find nearest source center for each target center\n    dist_matrix = np.abs(c_s.reshape(-1, 1) - c_t.reshape(1, -1))\n    i_star_indices = np.argmin(dist_matrix, axis=0)\n    \n    delta_nc, delta_c = np.zeros(N_t), np.zeros(N_t)\n    for j in range(N_t):\n        i_star = i_star_indices[j]\n        # Clamp indices to valid range\n        idx_min = max(0, i_star - 1)\n        idx_max = min(N_s - 1, i_star + 1)\n        local_u_s = u_s_bar[idx_min : idx_max + 1]\n        \n        m_j_minus = np.min(local_u_s)\n        m_j_plus = np.max(local_u_s)\n        \n        delta_nc[j] = np.max([0, v_t[j] - m_j_plus, m_j_minus - v_t[j]])\n        delta_c[j] = np.max([0, u_t_bar[j] - m_j_plus, m_j_minus - u_t_bar[j]])\n        \n    A_nc = np.max(delta_nc)\n    A_c = np.max(delta_c)\n\n    # 4.3. Total Variation\n    TV_s = calculate_tv(u_s_bar)\n    TV_t_nc = calculate_tv(v_t)\n    TV_t_c = calculate_tv(u_t_bar)\n    \n    dTV_nc = TV_t_nc - TV_s\n    dTV_c = TV_t_c - TV_s\n\n    # 4.4. Monotonicity Booleans\n    B_nc = (A_nc  tol)\n    B_c = (A_c  tol)\n    \n    return [A_nc, E_nc, dTV_nc, B_nc, A_c, E_c, dTV_c, B_c]\n\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # Case 1: Uniform non-matching, mid-domain interface\n        ({'N': 16}, {'N': 21}, 0.5),\n        # Case 2: Checkerboard non-matching, off-center interface\n        ({'pattern': [0.03, 0.07]}, {'pattern': [0.07, 0.03]}, 0.31),\n        # Case 3: Uniform, interface near boundary\n        ({'N': 10}, {'N': 12}, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(run_case(case))\n    \n    # Format the output as specified: [[r1,r2,...],[r1,r2,...],...]\n    str_results = []\n    for res_list in results:\n        # Format each item in the sublist to string\n        # The problem does not specify float precision, so use default str representation\n        # Booleans will be 'True' or 'False'\n        str_items = [str(item) for item in res_list]\n        str_results.append(f\"[{','.join(str_items)}]\")\n        \n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}