{
    "hands_on_practices": [
        {
            "introduction": "分数步长投影法是计算流体动力学（CFD）的基石之一，广泛用于求解不可压缩的Navier-Stokes方程。该方法的成功在很大程度上取决于如何正确处理速度和压力之间的耦合，尤其是在计算域的边界上。\n\n本练习将指导你推导在出口边界上与速度更新相容的“正确”压力边界条件 。你还将量化一个直观但错误的边界条件所引起的误差（伪反射），从而深刻体会到严格数值分析在保证模拟准确性中的重要性。",
            "id": "3519215",
            "problem": "考虑一种不可压缩牛顿流体，其在占据空间域 $\\Omega = \\{(x,y) \\in \\mathbb{R}^{2} : 0 \\le x \\le L,\\, 0 \\le y \\le H\\}$ 的直通道内，由不可压缩Navier–Stokes方程描述，其密度为 $\\rho$，动力粘度为 $\\mu$。设出口边界 $\\Gamma_{\\text{out}} = \\{x=L\\}$ 处的单位外法向量为 $\\mathbf{n} = \\mathbf{e}_{x}$。流动方向主要与 $\\mathbf{e}_{x}$ 一致，并且在 $\\Gamma_{\\text{out}}$ 处具有一个稳定的出口速度 $U_{b} > 0$。一个一阶压力投影分数步（也称为算子分裂）格式通过以下方式推进速度：\n$$\n\\rho \\frac{\\mathbf{u}^{*} - \\mathbf{u}^{n}}{\\Delta t} = - \\rho (\\mathbf{u}^{n} \\cdot \\nabla)\\mathbf{u}^{n} + \\mu \\nabla^{2}\\mathbf{u}^{n} + \\mathbf{f}^{n},\n$$\n然后通过求解压力子问题来施加不可压缩性约束：\n$$\n\\nabla^{2} p^{n+1} = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^{*},\n$$\n随后进行速度修正：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p^{n+1}.\n$$\n您可以假设解是光滑的，并且在出口处，与对流输运相比，粘性正应力可以忽略不计，这是中到高雷诺数通道出口流的典型工况。\n\n任务1（推导）：从不可压缩Navier–Stokes动量方程和上述分数步框架出发，围绕稳定出口速度 $U_{b}$ 对 $\\Gamma_{\\text{out}}$ 处的动量平衡法向分量进行线性化，并对出口处的速度施加对流辐射条件，\n$$\n\\frac{\\partial u_{n}}{\\partial t} + U_{b}\\frac{\\partial u_{n}}{\\partial n} = 0 \\quad \\text{on } \\Gamma_{\\text{out}},\n$$\n其中 $u_{n} = \\mathbf{u} \\cdot \\mathbf{n}$。在所述假设下，推导在 $\\Gamma_{\\text{out}}$ 处与分数步投影一致的相应压力边界条件，并将其表示为 $p^{n+1}$ 的Neumann条件。\n\n任务2（错误指定条件下伪反射的量化）：考虑沿流向 $x \\in [0,L]$ 的压力子问题的一个一维替代模型，其右端项选择为代表中间速度场散度的单个傅里叶模式，\n$$\n\\frac{\\mathrm{d}^{2} p}{\\mathrm{d} x^{2}} = G \\sin\\!\\left(\\frac{\\pi x}{L}\\right),\n$$\n其中 $G$ 为常数。在入口边界 $x=0$ 处，采用参考压力条件 $p(0) = 0$。对于出口边界 $x=L$：\n- 情况A（物理一致的出口）：施加任务1中推导的Neumann边界条件，并计算 $\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L}$。\n- 情况B（错误指定的出口）：施加Dirichlet条件 $p(L) = 0$ 而不是Neumann条件，并计算 $\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L}$。\n\n将反射系数 $\\mathcal{R}$ 定义为情况B中由错误指定的Dirichlet条件引起的出口法向速度修正的大小与情况A中入口法向速度修正的大小的比值，两者均在边界处测量。使用速度修正关系式\n$$\nu_{n}^{\\text{corr}}(x) = - \\frac{\\Delta t}{\\rho} \\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x},\n$$\n将 $\\mathcal{R}$ 表示为\n$$\n\\mathcal{R} = \\frac{\\left|\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L,\\ \\text{Case B}}\\right|}{\\left|\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=0,\\ \\text{Case A}}\\right|}.\n$$\n\n答案规格：以一个包含两个条目的行矩阵形式提供您的最终答案，按顺序依次为任务1中的出口压力Neumann边界条件值（以在 $x=L$ 处求值的数值或闭式表达式表示）和任务2中的反射系数 $\\mathcal{R}$。无需四舍五入。反射系数是无量纲的。不要在最终的方框答案中包含单位。",
            "solution": "该问题经验证具有科学依据、适定且客观。这是计算流体力学中投影法数值边界条件的一项标准分析。我现在开始解答。\n\n该问题包括两个任务。任务1是为一个使用分数步投影法的通道流模拟，推导其出口边界处的压力Neumann边界条件。任务2是通过一个简化的一维模型，量化因使用不正确的压力边界条件而在出口处引起的伪反射。\n\n### 任务1：出口压力边界条件的推导\n\n目标是在出口边界 $\\Gamma_{\\text{out}} = \\{x=L\\}$ 处，找到一个与所施加的速度对流辐射条件一致的压力 $p^{n+1}$ 边界条件。此边界处的法向量为 $\\mathbf{n} = \\mathbf{e}_{x}$，因此法向对应于 $x$ 方向，法向速度为 $u_{n} = \\mathbf{u} \\cdot \\mathbf{n} = u_{x}$。法向导数为 $\\frac{\\partial}{\\partial n} = \\frac{\\partial}{\\partial x}$。\n\n分数步法的速度修正步骤由下式给出：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p^{n+1}\n$$\n在边界 $\\Gamma_{\\text{out}}$ 处与单位外法向量 $\\mathbf{n}$ 做点积，得到新时间步 $n+1$ 处的法向速度分量：\n$$\nu_{n}^{n+1} = u_{n}^{*} - \\frac{\\Delta t}{\\rho} \\frac{\\partial p^{n+1}}{\\partial n} \\quad \\text{on } \\Gamma_{\\text{out}}\n$$\n该方程将所求的压力Neumann条件 $\\frac{\\partial p^{n+1}}{\\partial n}$ 与边界上的速度联系起来。为了求解它，我们需要一个在 $\\Gamma_{\\text{out}}$ 上关于 $u_n^{n+1}$ 的表达式。\n\n问题对出口处的速度施加了对流辐射条件：\n$$\n\\frac{\\partial u_{n}}{\\partial t} + U_{b}\\frac{\\partial u_{n}}{\\partial n} = 0 \\quad \\text{on } \\Gamma_{\\text{out}}\n$$\n我们可以使用与给定投影格式的总体一阶时间精度相一致的一阶显式格式（时间导数用前向欧拉，空间导数在时间步 $n$ 计算）对该方程进行时间离散化：\n$$\n\\frac{u_{n}^{n+1} - u_{n}^{n}}{\\Delta t} + U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n} = 0\n$$\n求解 $u_{n}^{n+1}$ 得到新时间步下出口处的目标法向速度：\n$$\nu_{n}^{n+1} = u_{n}^{n} - \\Delta t \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\n现在，我们将这个 $u_n^{n+1}$ 的表达式代入速度修正方程的法向分量中：\n$$\nu_{n}^{n} - \\Delta t \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n} = u_{n}^{*} - \\frac{\\Delta t}{\\rho} \\frac{\\partial p^{n+1}}{\\partial n}\n$$\n重新整理以求解压力梯度，可得：\n$$\n\\frac{\\Delta t}{\\rho} \\frac{\\partial p^{n+1}}{\\partial n} = (u_{n}^{*} - u_{n}^{n}) + \\Delta t \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} = \\frac{\\rho}{\\Delta t}(u_{n}^{*} - u_{n}^{n}) + \\rho \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\n项 $(u_{n}^{*} - u_{n}^{n})$ 由动量预测步确定：\n$$\n\\rho \\frac{\\mathbf{u}^{*} - \\mathbf{u}^{n}}{\\Delta t} = - \\rho (\\mathbf{u}^{n} \\cdot \\nabla)\\mathbf{u}^{n} + \\mu \\nabla^{2}\\mathbf{u}^{n} + \\mathbf{f}^{n}\n$$\n取该方程的法向分量可得：\n$$\n\\frac{\\rho}{\\Delta t}(u_{n}^{*} - u_{n}^{n}) = \\left[ - \\rho (\\mathbf{u}^{n} \\cdot \\nabla)\\mathbf{u}^{n} + \\mu \\nabla^{2}\\mathbf{u}^{n} + \\mathbf{f}^{n} \\right] \\cdot \\mathbf{n}\n$$\n将此代入我们关于压力梯度的表达式中：\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} = \\left[ - \\rho (\\mathbf{u}^{n} \\cdot \\nabla)u_{n}^{n} + \\mu (\\nabla^{2}\\mathbf{u}^{n}) \\cdot \\mathbf{n} + f_{n}^{n} \\right] + \\rho \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\n现在，我们应用在时间层 $n$ 和边界 $\\Gamma_{\\text{out}}$ 上评估的问题陈述中提供的假设：\n1.  围绕稳定出口速度 $U_b$ 对对流项进行线性化：$(\\mathbf{u}^{n} \\cdot \\nabla)u_{n}^{n} \\approx U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n}$。\n2.  粘性正应力可忽略不计：这意味着在出口处粘性力项的法向分量可忽略，因此 $\\mu (\\nabla^{2}\\mathbf{u}^{n}) \\cdot \\mathbf{n} \\approx 0$。\n\n将这些假设应用于压力梯度的方程：\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} \\approx \\left[ - \\rho \\left( U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n} \\right) + 0 + f_{n}^{n} \\right] + \\rho \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} = - \\rho \\, U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n} + f_{n}^{n} + \\rho \\, U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\n对流项相互抵消，剩下：\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} = f_{n}^{n}\n$$\n问题没有指定体积力 $\\mathbf{f}^{n}$。在此类典型应用和模型问题中，除非另有说明，否则通常假设体积力为零。为了使结果为一个具体的值，并确保与任务2（其隐含地没有体积力项）的一致性，我们假设 $\\mathbf{f}^{n} = \\mathbf{0}$。因此，$f_n^n = 0$。\n由此得到的出口处压力的Neumann边界条件是：\n$$\n\\left.\\frac{\\partial p^{n+1}}{\\partial x}\\right|_{x=L} = 0\n$$\n\n### 任务2：伪反射的量化\n\n我们分析由以下常微分方程给出的压力一维替代问题：\n$$\n\\frac{\\mathrm{d}^{2} p}{\\mathrm{d} x^{2}} = G \\sin\\left(\\frac{\\pi x}{L}\\right)\n$$\n通解可以通过对 $x$ 积分两次得到：\n$$\n\\frac{\\mathrm{d} p}{\\mathrm{d} x} = \\int G \\sin\\left(\\frac{\\pi x}{L}\\right) \\mathrm{d}x = -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) + C_1\n$$\n$$\np(x) = \\int \\left(-G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) + C_1\\right) \\mathrm{d}x = -G \\left(\\frac{L}{\\pi}\\right)^2 \\sin\\left(\\frac{\\pi x}{L}\\right) + C_1 x + C_2\n$$\n\n**情况A：物理一致的出口**\n边界条件为 $p(0) = 0$（入口）和 $\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L} = 0$（出口，来自任务1）。\n\n应用 $p(0) = 0$：\n$$\np(0) = -G \\left(\\frac{L}{\\pi}\\right)^2 \\sin(0) + C_1(0) + C_2 = 0 \\implies C_2=0\n$$\n应用 $\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L} = 0$：\n$$\n\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L} = -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi L}{L}\\right) + C_1 = -G \\frac{L}{\\pi} \\cos(\\pi) + C_1 = 0\n$$\n$$\n-G \\frac{L}{\\pi} (-1) + C_1 = 0 \\implies C_1 = -G \\frac{L}{\\pi}\n$$\n情况A的压力梯度是 $\\frac{\\mathrm{d} p_A}{\\mathrm{d} x} = -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) - G \\frac{L}{\\pi}$。\n\n**情况B：错误指定的出口**\n边界条件为 $p(0) = 0$（入口）和 $p(L) = 0$（出口）。\n\n应用 $p(0) = 0$ 得到 $C_2 = 0$，和之前一样。\n应用 $p(L) = 0$：\n$$\np(L) = -G \\left(\\frac{L}{\\pi}\\right)^2 \\sin\\left(\\frac{\\pi L}{L}\\right) + C_1 L = -G \\left(\\frac{L}{\\pi}\\right)^2 \\sin(\\pi) + C_1 L = 0\n$$\n$$\n0 + C_1 L = 0 \\implies C_1 = 0\n$$\n情况B的压力梯度是 $\\frac{\\mathrm{d} p_B}{\\mathrm{d} x} = -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right)$。\n\n**反射系数 $\\mathcal{R}$ 的计算**\n反射系数定义为：\n$$\n\\mathcal{R} = \\frac{\\left|\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L,\\ \\text{Case B}}\\right|}{\\left|\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=0,\\ \\text{Case A}}\\right|}\n$$\n首先，我们计算分子：\n$$\n\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L,\\ \\text{Case B}} = \\left. \\left( -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) \\right) \\right|_{x=L} = -G \\frac{L}{\\pi} \\cos(\\pi) = G \\frac{L}{\\pi}\n$$\n接下来，我们计算分母：\n$$\n\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=0,\\ \\text{Case A}} = \\left. \\left( -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) - G \\frac{L}{\\pi} \\right) \\right|_{x=0} = -G \\frac{L}{\\pi} \\cos(0) - G \\frac{L}{\\pi} = -G \\frac{L}{\\pi} - G \\frac{L}{\\pi} = -2G \\frac{L}{\\pi}\n$$\n现在，我们计算它们大小的比值：\n$$\n\\mathcal{R} = \\frac{\\left| G \\frac{L}{\\pi} \\right|}{\\left| -2G \\frac{L}{\\pi} \\right|} = \\frac{|G| \\frac{L}{\\pi}}{2|G| \\frac{L}{\\pi}} = \\frac{1}{2}\n$$\n\n最终答案需要任务1中的出口压力Neumann边界条件值（为 $0$）和任务2中的反射系数 $\\mathcal{R}$（为 $\\frac{1}{2}$）。这些以一个包含两个条目的行矩阵形式提供。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0 & \\frac{1}{2} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "从单一物理场转向多物理场问题时，算子分裂法的复杂性会显著增加。当描述不同物理过程的算子（例如，化学扩散算子 $A$ 和力学变形算子 $B$）不可交换时，即它们的交换子 $[A, B] \\neq 0$，分裂的顺序就至关重要，因为 $A$ 作用于 $B$ 的结果与 $B$ 作用于 $A$ 的结果不同。这种差异被称为分裂误差，它可能导致模拟结果出现物理上的偏差。\n\n在这个实践中，你将探索一个具体的化学-力学耦合模型，其中材料的强度和刚度会随着一种扩散的化学物质浓度而改变 。你需要编程实现两种不同的一阶分裂格式（先扩散后力学 vs. 先力学后扩散），并观察算子的应用顺序如何直接影响材料的预测断裂时间。这个例子生动地展示了分裂误差在实际工程问题中的具体影响。",
            "id": "3519243",
            "problem": "考虑一个占据空间区间 $[0,L]$ 的一维杆，其上存在一个扩散反应物的浓度场 $c(x,t)$ 和一个小应变线性弹性固体的位移场 $u(x,t)$。化学-力学耦合关系为：弹性模量通过 $E(c)=E_0\\,(1-\\alpha\\,c)$ 依赖于浓度，拉伸强度通过 $\\sigma_c(c)=\\sigma_0\\,(1-\\beta\\,c)$ 依赖于浓度。扩散步骤由算子 $A$ 表示，力学平衡步骤由算子 $B$ 表示。您的任务是通过比较在特定参数集下，采用 $AB$ 顺序与 $BA$ 顺序预测的断裂起始时间，来评估一种Lie型算子分裂格式的顺序敏感性。\n\n从以下基本原理出发：\n- 扩散由菲克第二定律（Fick's Second Law）控制（该定律由菲克第一定律和质量守恒共同导出）：$\\partial_t c = D\\,\\partial_{xx} c$，其中 $D$ 是扩散系数。边界条件为 $c(0,t)=c_{\\text{inlet}}$ 和 $c(L,t)=0$，初始条件为 $c(x,0)=0$。\n- 对于准静态加载下的一维杆，小应变线性弹性理论要求力平衡（无体力）为 $\\partial_x \\sigma = 0$，因此柯西应力（Cauchy stress）$\\sigma$ 在每个时刻于空间上是恒定的。位移边界条件为 $u(0,t)=0$ 和 $u(L,t)=U(t)$，其中 $U(t)=\\dot{U}\\,t$ 是一个单调递增的斜坡加载。协调性（Compatibility）得出 $\\int_0^L \\varepsilon(x,t)\\,dx = U(t)$，其中 $\\varepsilon=\\partial_x u$。线性本构关系为 $\\sigma(x,t) = E(c(x,t))\\,\\varepsilon(x,t)$。\n- 利用力平衡（$\\sigma$ 为常数）和协调性，从第一性原理推导出在位移控制下的全局应力为\n$$\n\\sigma(t) \\;=\\; \\frac{U(t)}{\\displaystyle \\int_0^L \\frac{dx}{E(c(x,t))}}。\n$$\n- 断裂起始由以下路径相关准则定义\n$$\n\\sigma(t) \\;\\ge\\; \\min_{x\\in[0,L]} \\sigma_c(c(x,t))。\n$$\n\n定义两种在一时间步长 $\\Delta t$ 内的一阶Lie分裂格式：\n- $AB$ 顺序：首先将扩散推进一个时间步至新时刻 $t^{n+1}$，得到 $c^{n+1}(x)$；然后在新时刻 $t^{n+1}$ 使用 $U^{n+1} = \\dot{U}\\,t^{n+1}$ 和 $c^{n+1}(x)$ 计算力学响应，求得 $\\sigma^{n+1}$，并使用 $\\min_x \\sigma_c(c^{n+1}(x))$ 检查断裂。\n- $BA$ 顺序：首先在新时刻 $t^{n+1}$ 使用 $U^{n+1}=\\dot{U}\\,t^{n+1}$ 但使用 $c^n(x)$ 计算力学响应，求得 $\\sigma^{n+1}$，并使用 $\\min_x \\sigma_c(c^n(x))$ 检查断裂；然后将扩散从 $t^n$ 推进至 $t^{n+1}$。\n\n通过在 $[0,L]$ 上的均匀网格（含 $N$ 个节点，网格间距 $\\Delta x = L/(N-1)$）上使用显式有限差分法和向前欧拉时间步进（forward Euler time stepping）来实现扩散步骤：\n$$\nc_i^{n+1} \\;=\\; c_i^n \\;+\\; D\\,\\frac{\\Delta t}{(\\Delta x)^2}\\,\\big(c_{i-1}^n - 2c_i^n + c_{i+1}^n\\big),\n$$\n此式适用于内部节点 $i=2,\\dots,N-1$。对所有 $n$ 施加狄利克雷（Dirichlet）边界条件 $c_1^n = c_{\\text{inlet}}$ 和 $c_N^n=0$。为确保科学真实性，使用 $0 \\le c \\le 1$ 且参数应保证 $E(c)>0$。请使用指定的 $\\Delta t$ 进行显式格式计算，不要更改时间步长。\n\n通过计算以下各式来实现力学步骤：\n$$\nE_i^n \\;=\\; E_0\\,(1-\\alpha\\,c_i^n),\\quad\n\\Big(\\int_0^L \\frac{dx}{E(c)}\\Big)^n \\;\\approx\\; \\sum_{i=1}^{N} \\frac{\\Delta x}{E_i^n},\\quad\n\\sigma^{n+1} \\;=\\; \\frac{U^{n+1}}{\\sum_{i=1}^{N} \\frac{\\Delta x}{E_i^{\\star}}},\n$$\n其中，对于 $AB$ 顺序，使用 $E_i^{\\star}=E_0(1-\\alpha c_i^{n+1})$；对于 $BA$ 顺序，使用 $E_i^{\\star}=E_0(1-\\alpha c_i^n)$。断裂阈值计算如下：\n$$\n\\sigma_{\\min}^{\\text{th},\\,AB} = \\min_i \\big[\\sigma_0(1-\\beta\\,c_i^{n+1})\\big],\\qquad\n\\sigma_{\\min}^{\\text{th},\\,BA} = \\min_i \\big[\\sigma_0(1-\\beta\\,c_i^{n})\\big].\n$$\n在相应顺序下，若满足 $\\sigma^{n+1} \\ge \\sigma_{\\min}^{\\text{th}}$，则在该最早的时间步 $n$ 触发断裂。如果在最终时刻 $T_{\\max}$ 前未发生断裂，则报告未发生断裂。\n\n数值实现要求：\n- 使用包含 $N$ 个节点的均匀网格。\n- 初始化所有节点的 $c_i^0=0$。\n- 在每个时间步强制执行 $c_1^n = c_{\\text{inlet}}$ 和 $c_N^n=0$。\n- 使用 $U(t)=\\dot{U}\\,t$，其中 $\\dot{U}$ 是指定的。在 $AB$ 和 $BA$ 的比较中，使用相同的 $\\Delta t$。\n- 为保证数值稳健性，如果需要，可将 $E(c)$ 从下方用一个小的正数下限进行限制，以避免除以零，但应确保模型参数满足对所有 $c \\in [0,1]$ 都有 $1-\\alpha c > 0$，从而在正常操作中该下限不会被激活。\n\n测试套件：\n为以下参数集运行您的程序（所有单位均为国际单位制（SI））：\n- 情况 1（一般耦合情况）：\n  - $L=1.0$, $N=101$, $D=1.0\\times 10^{-4}$, $\\Delta t=0.05$, $T_{\\max}=10.0$, $E_0=1.0\\times 10^{11}$, $\\alpha=0.5$, $\\sigma_0=1.0\\times 10^{9}$, $\\beta=0.8$, $c_{\\text{inlet}}=1.0$, $\\dot{U}=1.0\\times 10^{-3}$。\n- 情况 2（无扩散边缘情况）：\n  - $L=1.0$, $N=101$, $D=0.0$, $\\Delta t=0.05$, $T_{\\max}=10.0$, $E_0=1.0\\times 10^{11}$, $\\alpha=0.5$, $\\sigma_0=1.0\\times 10^{9}$, $\\beta=0.8$, $c_{\\text{inlet}}=1.0$, $\\dot{U}=1.0\\times 10^{-3}$。\n- 情况 3（强强度敏感性及更快扩散）：\n  - $L=1.0$, $N=101$, $D=5.0\\times 10^{-4}$, $\\Delta t=0.05$, $T_{\\max}=10.0$, $E_0=1.0\\times 10^{11}$, $\\alpha=0.7$, $\\sigma_0=1.0\\times 10^{9}$, $\\beta=1.2$, $c_{\\text{inlet}}=1.0$, $\\dot{U}=1.0\\times 10^{-3}$。\n- 情况 4（低加载率，可能在时限内不发生断裂）：\n  - $L=1.0$, $N=101$, $D=1.0\\times 10^{-4}$, $\\Delta t=0.05$, $T_{\\max}=5.0$, $E_0=1.0\\times 10^{11}$, $\\alpha=0.3$, $\\sigma_0=1.0\\times 10^{9}$, $\\beta=0.2$, $c_{\\text{inlet}}=1.0$, $\\dot{U}=2.0\\times 10^{-4}$。\n\n对每种情况，计算：\n- 在 $AB$ 顺序下，最早的断裂起始时间（单位：秒）。\n- 在 $BA$ 顺序下，最早的断裂起始时间（单位：秒）。\n- 如果两个断裂时间均为有限值，计算差值 $\\Delta t_{\\text{fract}} = t_{\\text{fract}}^{BA} - t_{\\text{fract}}^{AB}$（单位：秒）；否则，设置 $\\Delta t_{\\text{fract}}=-1.0$。\n\n如果在 $T_{\\max}$ 前某一顺序下未发生断裂，则将相应的时间报告为 $-1.0$ 秒。\n\n您的程序应生成单行输出，其中包含四种情况的结果，格式为由方括号括起的逗号分隔列表，每个内部列表为 $[t_{AB}, t_{BA}, \\Delta t_{\\text{fract}}]$，以浮点数形式表示（单位：秒）。例如：$[[1.234000,1.280000,0.046000],[\\dots],\\dots]$。",
            "solution": "问题陈述经评估有效。它具有科学依据，是适定的、客观的且内部一致的。所用的物理模型虽然经过简化，但基于连续介质力学和输运现象的既定原理。用于扩散的菲克第二定律和用于力学响应的线性弹性理论都是标准模型。化学-力学耦合（其中弹性模量 $E$ 和拉伸强度 $\\sigma_c$ 依赖于浓度场 $c$）代表了多物理场建模中一个有效且常见的场景。应力表达式 $\\sigma(t)$ 的推导是正确的，它直接源于一维准静态力平衡（$\\partial_x \\sigma = 0$）和运动学协调性（$\\int_0^L \\varepsilon(x,t)\\,dx = U(t)$）。用于扩散的显式有限差分法和用于耦合的Lie型算子分裂法构成的数值方案是一种标准方法。每个测试用例的所有参数、边界条件和初始条件都已完全指定，使得问题可解。指定的显式扩散方案的稳定性由Courant-Friedrichs-Lewy (CFL) 条件 $D\\Delta t/(\\Delta x)^2 \\le 0.5$ 定义，所有测试用例均满足此条件，确保数值模拟不会出现非物理振荡。该问题是一个定义明确的练习，旨在实现和比较用于耦合多物理场系统的算子分裂格式。\n\n任务的核心是实现一个时间步进模拟，以求解浓度场 $c(x,t)$ 的演化，并在每一步评估力学应力 $\\sigma(t)$ 并检查是否发生断裂。此过程针对两种不同的算子分裂格式（表示为 $AB$ 和 $BA$）分别执行。\n\n令系统在时间 $t^n = n\\,\\Delta t$ 的状态由离散浓度场 $c^n = \\{c_i^n\\}_{i=1}^N$ 表示。目标是求解下一时间步 $t^{n+1}$ 的状态。\n\n首先，我们定义算子。\n- 算子 $A$：此算子将扩散方程 $\\partial_t c = D\\,\\partial_{xx} c$ 在单个时间步 $\\Delta t$ 内推进。使用给定的时间上向前欧拉和空间上二阶中心差分的离散化，内部节点的更新公式为：\n$$\nc_i^{n+1} = c_i^n + \\frac{D\\,\\Delta t}{(\\Delta x)^2} (c_{i-1}^n - 2c_i^n + c_{i+1}^n) \\quad \\text{for } i=2, \\dots, N-1\n$$\n狄利克雷边界条件被强制为 $c_1^{n+1} = c_{\\text{inlet}}$ 和 $c_N^{n+1} = 0$。\n- 算子 $B$：此算子执行准静态力学分析并检查断裂。它接收一个浓度场 $c(x)$ 和一个施加的位移 $U(t)$，以计算应力 $\\sigma(t)$ 和断裂阈值 $\\sigma_{\\min}^{\\text{th}}$。\n应力计算如下：\n$$\n\\sigma(t) = \\frac{U(t)}{\\displaystyle \\int_0^L \\frac{dx}{E(c(x,t))}} \\approx \\frac{U(t)}{\\displaystyle \\sum_{i=1}^{N} \\frac{\\Delta x}{E_0(1-\\alpha\\,c_i)}}\n$$\n通过将此应力与杆中的最小拉伸强度进行比较来检查断裂准则：\n$$\n\\sigma(t) \\ge \\min_{x \\in [0,L]} \\sigma_c(c(x,t)) \\approx \\min_{i} \\left[ \\sigma_0(1-\\beta\\,c_i) \\right]\n$$\n\n两种Lie分裂格式的区别在于这些算子在一个时间步从 $t^n$ 到 $t^{n+1}$ 内的应用顺序：\n\n**1. $AB$ 顺序（扩散-力学）**\n\n对于每个时间步，从浓度场 $c^n$ 开始：\n1.  **应用算子 A（扩散）：** 通过对 $c^n$ 应用扩散算子，计算出一个中间浓度场，我们称之为 $c^{n+1}$。这代表了在区间 $[t^n, t^{n+1}]$ 内扩散后的状态。\n    $$\n    c^{n+1} = A(c^n)\n    $$\n2.  **应用算子 B（力学）：** 在新时刻 $t^{n+1}$ 评估力学响应。关键是，此评估使用刚计算出的浓度场 $c^{n+1}$ 和新时刻的位移 $U^{n+1} = \\dot{U}\\,t^{n+1}$。\n    - 应力计算为 $\\sigma_{AB}^{n+1} = \\frac{U^{n+1}}{\\sum_{i=1}^{N} \\frac{\\Delta x}{E_0(1-\\alpha\\,c_i^{n+1})}}$。\n    - 断裂阈值为 $\\sigma_{\\min, AB}^{\\text{th}} = \\min_i [\\sigma_0(1-\\beta\\,c_i^{n+1})]$。\n    - 如果 $\\sigma_{AB}^{n+1} \\ge \\sigma_{\\min, AB}^{\\text{th}}$，则发生断裂。首次满足此条件的时刻 $t^{n+1}$ 即为断裂时间 $t_{\\text{fract}}^{AB}$。\n3.  下一时间步的状态是 $c^{n+1}$。\n\n**2. $BA$ 顺序（力学-扩散）**\n\n对于每个时间步，从浓度场 $c^n$ 开始：\n1.  **应用算子 B（力学）：** 在新时刻 $t^{n+1}$ 评估力学响应。然而，此评估使用时间步开始时的旧浓度场 $c^n$，但位移是新时刻的 $U^{n+1} = \\dot{U}\\,t^{n+1}$。这是分裂格式的一个共同特征，即一个算子作用于另一个算子在上一步的状态。\n    - 应力计算为 $\\sigma_{BA}^{n+1} = \\frac{U^{n+1}}{\\sum_{i=1}^{N} \\frac{\\Delta x}{E_0(1-\\alpha\\,c_i^{n})}}$。\n    - 断裂阈值为 $\\sigma_{\\min, BA}^{\\text{th}} = \\min_i [\\sigma_0(1-\\beta\\,c_i^{n})]$。\n    - 如果 $\\sigma_{BA}^{n+1} \\ge \\sigma_{\\min, BA}^{\\text{th}}$，则发生断裂。首次满足此条件的时刻 $t^{n+1}$ 即为断裂时间 $t_{\\text{fract}}^{BA}$。\n2.  **应用算子 A（扩散）：** 使用扩散算子将浓度场从 $c^n$ 推进到 $c^{n+1}$，此步骤与 $AB$ 格式中的相同。\n    $$\n    c^{n+1} = A(c^n)\n    $$\n3.  下一时间步的状态是 $c^{n+1}$。\n\n关键区别在于在时刻 $t^{n+1}$ 进行力学计算时使用了哪个浓度场：$AB$ 格式使用“扩散后”的浓度 $c^{n+1}$，而 $BA$ 格式使用“扩散前”的浓度 $c^n$。这引入了一个时间上的一阶误差，称为分裂误差，目标是量化其对预测断裂时间的影响。\n\n实现将包括一个主循环，遍历所提供的测试用例。对每个用例，运行两个独立的模拟，分别对应两种顺序（$AB$ 和 $BA$）。模拟从 $t=0$ 到 $t=T_{\\max}$ 逐步进行。在每一步中，应用相应的格式，并检查断裂条件。如果检测到断裂，则记录当前时间，并终止该顺序的模拟。如果循环结束而未发生断裂，则记录时间为 $-1.0$。最后，计算断裂时间的差异 $\\Delta t_{\\text{fract}} = t_{\\text{fract}}^{BA} - t_{\\text{fract}}^{AB}$。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(params, ordering):\n    \"\"\"\n    Runs a single chemo-mechanical simulation for a given ordering.\n    \"\"\"\n    L = params['L']\n    N = params['N']\n    D = params['D']\n    dt = params['dt']\n    T_max = params['T_max']\n    E_0 = params['E_0']\n    alpha = params['alpha']\n    sigma_0 = params['sigma_0']\n    beta = params['beta']\n    c_inlet = params['c_inlet']\n    U_dot = params['U_dot']\n\n    # Discretization parameters\n    dx = L / (N - 1)\n    num_steps = int(round(T_max / dt))\n    \n    # CFL constant for diffusion stability\n    cfl = D * dt / dx**2\n    # The problem parameters are chosen such that cfl = 0.5, so the scheme is stable.\n\n    # Initialize concentration array\n    c = np.zeros(N)\n    c[0] = c_inlet  # Enforce BC at t=0\n\n    # Time-stepping loop\n    for n in range(num_steps):\n        t_n_plus_1 = (n + 1) * dt\n        U_n_plus_1 = U_dot * t_n_plus_1\n\n        c_n = c.copy()\n\n        # --- Operator Splitting Logic ---\n        if ordering == 'AB':\n            # A: Diffusion step first\n            c_new = c_n.copy()\n            # Vectorized update for interior nodes\n            c_new[1:-1] = c_n[1:-1] + cfl * (c_n[0:-2] - 2 * c_n[1:-1] + c_n[2:])\n            c_new[0] = c_inlet\n            c_new[-1] = 0.0\n            c = c_new.copy()\n\n            # B: Mechanics step with new concentration c\n            E = E_0 * (1 - alpha * c)\n            # Add a small floor for numerical stability, though parameters should prevent activation\n            E = np.maximum(E, 1e-9) \n            integral_inv_E = np.sum(dx / E)\n            sigma_n_plus_1 = U_n_plus_1 / integral_inv_E\n            sigma_crit = np.min(sigma_0 * (1 - beta * c))\n            \n            if sigma_n_plus_1 >= sigma_crit:\n                return t_n_plus_1\n\n        elif ordering == 'BA':\n            # B: Mechanics step first with old concentration c_n\n            E = E_0 * (1 - alpha * c_n)\n            E = np.maximum(E, 1e-9)\n            integral_inv_E = np.sum(dx / E)\n            sigma_n_plus_1 = U_n_plus_1 / integral_inv_E\n            sigma_crit = np.min(sigma_0 * (1 - beta * c_n))\n\n            fracture_triggered = sigma_n_plus_1 >= sigma_crit\n\n            # A: Diffusion step second\n            c_new = c_n.copy()\n            c_new[1:-1] = c_n[1:-1] + cfl * (c_n[0:-2] - 2 * c_n[1:-1] + c_n[2:])\n            c_new[0] = c_inlet\n            c_new[-1] = 0.0\n            c = c_new.copy()\n\n            if fracture_triggered:\n                return t_n_plus_1\n                \n    # If loop completes without fracture\n    return -1.0\n\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general coupled case)\n        {\n            'L': 1.0, 'N': 101, 'D': 1.0e-4, 'dt': 0.05, 'T_max': 10.0,\n            'E_0': 1.0e11, 'alpha': 0.5, 'sigma_0': 1.0e9, 'beta': 0.8,\n            'c_inlet': 1.0, 'U_dot': 1.0e-3\n        },\n        # Case 2 (no diffusion edge case)\n        {\n            'L': 1.0, 'N': 101, 'D': 0.0, 'dt': 0.05, 'T_max': 10.0,\n            'E_0': 1.0e11, 'alpha': 0.5, 'sigma_0': 1.0e9, 'beta': 0.8,\n            'c_inlet': 1.0, 'U_dot': 1.0e-3\n        },\n        # Case 3 (strong strength sensitivity and faster diffusion)\n        {\n            'L': 1.0, 'N': 101, 'D': 5.0e-4, 'dt': 0.05, 'T_max': 10.0,\n            'E_0': 1.0e11, 'alpha': 0.7, 'sigma_0': 1.0e9, 'beta': 1.2,\n            'c_inlet': 1.0, 'U_dot': 1.0e-3\n        },\n        # Case 4 (low load rate, likely no fracture within horizon)\n        {\n            'L': 1.0, 'N': 101, 'D': 1.0e-4, 'dt': 0.05, 'T_max': 5.0,\n            'E_0': 1.0e11, 'alpha': 0.3, 'sigma_0': 1.0e9, 'beta': 0.2,\n            'c_inlet': 1.0, 'U_dot': 2.0e-4\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        t_ab = run_simulation(params, 'AB')\n        t_ba = run_simulation(params, 'BA')\n\n        if t_ab > 0 and t_ba > 0:\n            dt_fract = t_ba - t_ab\n        else:\n            dt_fract = -1.0\n        \n        all_results.append(f\"[{t_ab:.6f},{t_ba:.6f},{dt_fract:.6f}]\")\n\n    print(f\"[[{all_results[0]}],[{all_results[1]}],[{all_results[2]}],[{all_results[3]}]]\")\n\nsolve()\n```"
        },
        {
            "introduction": "多物理场模拟中的另一个常见挑战是“刚性”（stiffness），即系统中包含多个时间尺度差异巨大的物理过程（例如，缓慢的对流和极快的化学反应）。传统的显式时间积分方法在处理刚性问题时会因稳定性限制而需要极小的时间步长，导致计算成本过高。因此，对刚性部分采用隐式处理变得至关重要，这自然引出了算子分裂法和隐-显（IMEX）积分格式。\n\n在本练习中，你将处理一个含刚性化学反应源项的对流问题 。你将实现并比较算子分裂法与IMEX方法，并分析诸如解的正定性和熵稳定性等关键性质。通过对比，你将理解为何某些方法在刚性问题中能够保持稳健和物理一致性，而另一些方法则可能失效并产生非物理结果。",
            "id": "3519207",
            "problem": "要求您分析并实现一阶算子分裂和隐式-显式（IMEX）积分方法，用于求解模拟单一物种质量分数的一维反应平流方程。该数学模型是在周期性定义域 $x \\in [0,1)$ 上的带有线性弛豫源项的标量守恒律：\n$$\n\\partial_t y(x,t) + a\\,\\partial_x y(x,t) = -k\\,(y(x,t) - y_{\\mathrm{eq}}),\n$$\n其中 $a>0$ 是恒定的平流速度，$k>0$ 是刚度参数，$y_{\\mathrm{eq}}>0$ 是恒定的平衡态。状态量 $y$ 是无量纲的，代表物种的质量分数，因此物理真实性要求 $y \\ge 0$。为评估源项的热力学一致性，使用凸数学熵密度\n$$\n\\eta(y) = y \\ln\\!\\left(\\frac{y}{y_{\\mathrm{eq}}}\\right) - (y - y_{\\mathrm{eq}}), \\quad y > 0,\n$$\n以及离散熵泛函\n$$\nH(\\mathbf{y}) = \\sum_{i=0}^{N-1} \\eta(y_i)\\,\\Delta x,\n$$\n其中 $\\mathbf{y} = (y_0,\\dots,y_{N-1})^\\top$ 是在具有 $N$ 个单元和间距 $\\Delta x = 1/N$ 的均匀周期性网格上的单元平均值向量。\n\n从守恒律的基本原理和标准有限体积离散化出发，按以下步骤进行。\n\n- 使用与 $a$ 符号一致的一阶迎风格式和前向欧拉时间步进法来离散化平流算子 $B$。使用周期性边界条件。\n\n- 使用两种方法离散化刚性化学算子 $A$：后向欧拉法（全隐式）和前向欧拉法（全显式）时间步进，并将它们独立应用于每个单元的线性弛豫常微分方程 $\\dot{y} = -k(y - y_{\\mathrm{eq}})$。\n\n- 在时间步长 $\\Delta t$ 上构建两种一阶 Lie 算子分裂方法：$A \\circ B$，其中化学步骤 $A$ 通过后向欧拉法实现；以及 $A \\circ B$，其中化学步骤 $A$ 通过前向欧拉法实现。在每种情况下，先在 $\\Delta t$ 上应用化学子步，然后在 $\\Delta t$ 上应用平流子步。\n\n- 构建一个一阶 IMEX 欧拉方法，其中在同一个完整时间步长 $\\Delta t$ 内，平流项被显式处理，而化学项被隐式处理。\n\n您的任务：\n\n1) 根据前向欧拉法、后向欧拉法和针对 $a>0$ 的一阶迎风有限体积离散化的定义，推导每种方法（算子分裂和 IMEX）的更新公式，用网格函数值表示。利用以下事实：前向欧拉法应用于 $\\dot{y} = f(y)$ 得到 $y^{n+1} = y^n + \\Delta t\\,f(y^n)$，后向欧拉法得到 $y^{n+1} = y^n + \\Delta t\\,f(y^{n+1})$。证明应用于线性弛豫的后向欧拉法对于 $y^n \\ge 0$ 是无条件保正的，而当前向欧拉法中的 $k \\Delta t$ 相对于 $y^n$ 和 $y_{\\mathrm{eq}}$ 足够大时，可能会产生负值。\n\n2) 证明熵密度 $\\eta$ 对于 $y>0$ 是严格凸的，并在 $y = y_{\\mathrm{eq}}$ 处达到其唯一最小值。由此得出结论，任何对于化学反应而言是朝向 $y_{\\mathrm{eq}}$ 的收缩映射的时间积分器，在该子步上都是熵耗散的（即 $H$ 不会增加）。解释为什么对于线性弛豫，后向欧拉化学步骤对于任何 $\\Delta t>0$ 都是熵稳定的。\n\n3) 在一个均匀周期性网格上实现并比较三种方法，参数为 $N = 100$，$\\Delta x = 1/N$，$a = 0.5$，$y_{\\mathrm{eq}} = 0.05$，最终时间为 $T = 0.2$。使用初始条件\n$$\ny(x,0) = y_{\\mathrm{eq}} + 0.4\\,\\exp\\big(-200\\,(x-0.25)^2\\big) + 0.2\\,\\exp\\big(-400\\,(x-0.75)^2\\big).\n$$\n通过重复大小为 $\\Delta t$ 的步长演化到时间 $T$，如果 $T/\\Delta t$ 不是整数，则使用一个最终缩短的步长，以确保总模拟时间恰好等于 $T$。\n\n4) 对于以下 $(k,\\Delta t)$ 对的测试集，运行所有三种方法：\n   - 情况 A（理想路径）：$(k,\\Delta t) = (1000, 0.001)$。\n   - 情况 B（非常刚性）：$(k,\\Delta t) = (8000, 0.01)$。\n   - 情况 C（CFL 边界）：$(k,\\Delta t) = (500, 0.02)$。\n\n对于每种情况，计算以下七个输出：\n   - $p_{\\mathrm{BE}}$：一个布尔值，表示在使用带后向欧拉化学步骤的算子分裂方法时，所有自由度在最终时间后是否保持非负。\n   - $e_{\\mathrm{BE}}$：一个布尔值，表示在使用后向欧拉化学步骤的整个模拟过程中，每个化学子步之后的离散熵 $H$ 相对于该子步之前是否没有增加。\n   - $p_{\\mathrm{IMEX}}$：一个布尔值，表示在使用 IMEX 欧拉方法时，所有自由度在最终时间后是否保持非负。\n   - $e_{\\mathrm{IMEX}}$：一个布尔值，表示在整个模拟过程中，每个完整的 IMEX 步骤之后的离散熵 $H$ 相对于该步骤之前是否没有增加。\n   - $p_{\\mathrm{EE}}$：一个布尔值，表示在使用带前向欧拉化学步骤的算子分裂方法时，所有自由度在最终时间后是否保持非负。\n   - $e_{\\mathrm{EE}}$：一个布尔值，表示在使用前向欧拉化学步骤的整个模拟过程中，每个前向欧拉化学子步之后的离散熵 $H$ 相对于该子步之前是否没有增加。\n   - $d_{\\mathrm{L1}}$：IMEX 和后向欧拉分裂方法最终状态之间的离散 $\\ell^1$ 差值，定义为 $\\sum_i |y^{\\mathrm{IMEX}}_i - y^{\\mathrm{BE\\mbox{-}split}}_i|\\,\\Delta x$，为一个浮点数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个案例对应一个形式为 $[p_{\\mathrm{BE}}, e_{\\mathrm{BE}}, p_{\\mathrm{IMEX}}, e_{\\mathrm{IMEX}}, p_{\\mathrm{EE}}, e_{\\mathrm{EE}}, d_{\\mathrm{L1}}]$ 的子列表。例如，最终输出格式必须类似于 $[[\\text{情况 A 输出}],[\\text{情况 B 输出}],[\\text{情况 C 输出}]]$。",
            "solution": "该问题提出了一个一维反应平流方程，这是输运现象中的一个标准偏微分方程（PDE）。所有参数、初始条件和数值方法在既有的数学和计算科学文献中都有明确定义。该问题在科学上是合理的、自洽的且适定的。任务涉及对此类方程进行标准推导和实现典型的数值格式（算子分裂，IMEX）。因此，该问题被认为是有效的。\n\n### 任务 1：数值格式的推导\n\n控制偏微分方程为 $\\partial_t y + a\\,\\partial_x y = -k(y - y_{\\mathrm{eq}})$，可以写成 $\\partial_t y = A(y) + B(y)$ 的形式，其中 $A(y) = -k(y - y_{\\mathrm{eq}})$ 是化学算子，$B(y) = -a\\,\\partial_x y$ 是平流算子。\n\n我们将空间域 $[0,1)$ 离散为 $N$ 个宽度为 $\\Delta x = 1/N$ 的单元。设 $y_i(t)$ 为单元 $i$ 中的单元平均值。\n\n**平流算子 ($B$) 的离散化**\n平流算子 $B(y) = -a\\,\\partial_x y$ 使用一阶迎风有限体积法进行离散。由于 $a>0$，单元 $i$ 和 $i+1$ 之间的界面 $i+1/2$ 处的通量为 $F_{i+1/2} = a y_i$。单元 $i$ 的半离散方程为：\n$$\n\\frac{d y_i}{dt} = -\\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x} = -\\frac{a y_i - a y_{i-1}}{\\Delta x}\n$$\n对 方程 $\\dot{\\mathbf{y}} = \\mathcal{B}(\\mathbf{y})$ 在一个时间步长 $\\Delta t$ 上应用前向欧拉法，其中 $\\mathcal{B}$ 是离散的平流算子，得到更新式：\n$$\ny_i^* = y_i^n - \\frac{a \\Delta t}{\\Delta x}(y_i^n - y_{i-1}^n)\n$$\n其中周期性边界条件意味着 $y_{-1}^n = y_{N-1}^n$。\n\n**化学算子 ($A$) 的离散化**\n化学算子 $A(y) = -k(y - y_{\\mathrm{eq}})$ 对应于在每个单元中独立应用的常微分方程（ODE）$\\dot{y} = -k(y-y_{\\mathrm{eq}})$。\n\n- **前向欧拉（FE）离散化**：\n  更新规则为 $y^{n+1} = y^n + \\Delta t \\, f(y^n)$，其中 $f(y) = -k(y - y_{\\mathrm{eq}})$。\n  $$\n  y^{n+1} = y^n + \\Delta t(-k(y^n - y_{\\mathrm{eq}})) = y^n(1 - k \\Delta t) + k \\Delta t y_{\\mathrm{eq}}\n  $$\n  为了保证正性，如果 $y^n \\ge 0$，我们需要 $y^{n+1} \\ge 0$。如果 $k\\Delta t > 1$，则项 $(1-k\\Delta t)$ 为负。正性可能被破坏。例如，如果 $k\\Delta t=2$ 且 $y^n > 2y_{\\mathrm{eq}}$，那么 $y^{n+1} = -y^n+2y_{\\mathrm{eq}} < 0$。因此，针对此反应的 FE 格式不是无条件保正的。\n\n- **后向欧拉（BE）离散化**：\n  更新规则为 $y^{n+1} = y^n + \\Delta t \\, f(y^{n+1})$。\n  $$\n  y^{n+1} = y^n + \\Delta t(-k(y^{n+1} - y_{\\mathrm{eq}}))\n  $$\n  求解 $y^{n+1}$：\n  $y^{n+1}(1 + k \\Delta t) = y^n + k \\Delta t y_{\\mathrm{eq}}$\n  $$\n  y^{n+1} = \\frac{y^n + k \\Delta t y_{\\mathrm{eq}}}{1 + k \\Delta t}\n  $$\n  由于 $y^n \\ge 0$，$k > 0$，$\\Delta t > 0$ 和 $y_{\\mathrm{eq}} > 0$，分子和分母都严格为正。因此，$y^{n+1} > 0$。BE 格式是无条件保正的。\n\n**完整格式的构建**\n\n1.  **算子分裂，后向欧拉化学步骤 ($A \\circ B$)**：\n    这是一种一阶 Lie-Trotter 分裂，其中先应用化学子步，然后是平流子步。\n    -   步骤 1（化学，BE）：对于每个单元 $i=0, \\dots, N-1$：\n        $$\n        y_i^{**} = \\frac{y_i^n + k \\Delta t y_{\\mathrm{eq}}}{1 + k \\Delta t}\n        $$\n    -   步骤 2（平流，FE）：对于每个单元 $i=0, \\dots, N-1$：\n        $$\n        y_i^{n+1} = y_i^{**} - \\frac{a \\Delta t}{\\Delta x}(y_i^{**} - y_{i-1}^{**})\n        $$\n\n2.  **算子分裂，前向欧拉化学步骤 ($A \\circ B$)**：\n    与上述类似，但化学子步使用前向欧拉法。\n    -   步骤 1（化学，FE）：对于每个单元 $i=0, \\dots, N-1$：\n        $$\n        y_i^{**} = y_i^n(1 - k \\Delta t) + k \\Delta t y_{\\mathrm{eq}}\n        $$\n    -   步骤 2（平流，FE）：对于每个单元 $i=0, \\dots, N-1$：\n        $$\n        y_i^{n+1} = y_i^{**} - \\frac{a \\Delta t}{\\Delta x}(y_i^{**} - y_{i-1}^{**})\n        $$\n\n3.  **IMEX 欧拉方法**：\n    IMEX 欧拉方法在单个步骤内显式处理非刚性平流项，隐式处理刚性化学项。\n    $$\n    \\frac{y_i^{n+1} - y_i^n}{\\Delta t} = \\underbrace{-k(y_i^{n+1} - y_{\\mathrm{eq}})}_{\\text{Implicit}} + \\underbrace{\\left(-\\frac{a}{\\Delta x}(y_i^n - y_{i-1}^n)\\right)}_{\\text{Explicit}}\n    $$\n    重新整理以求解 $y_i^{n+1}$：\n    $y_i^{n+1} - y_i^n = -k \\Delta t y_i^{n+1} + k \\Delta t y_{\\mathrm{eq}} - \\frac{a \\Delta t}{\\Delta x}(y_i^n - y_{i-1}^n)$\n    $y_i^{n+1}(1 + k \\Delta t) = y_i^n - \\frac{a \\Delta t}{\\Delta x}(y_i^n - y_{i-1}^n) + k \\Delta t y_{\\mathrm{eq}}$\n    $$\n    y_i^{n+1} = \\frac{1}{1 + k \\Delta t} \\left( y_i^n - \\frac{a \\Delta t}{\\Delta x}(y_i^n - y_{i-1}^n) + k \\Delta t y_{\\mathrm{eq}} \\right)\n    $$\n\n### 任务 2：熵分析\n\n数学熵密度由 $\\eta(y) = y \\ln(y/y_{\\mathrm{eq}}) - (y - y_{\\mathrm{eq}})$ 给出，对于 $y>0$。\n\n**$\\eta(y)$ 的凸性和最小值**\n首先，我们求 $\\eta(y)$ 关于 $y$ 的一阶和二阶导数：\n$$\n\\eta'(y) = \\frac{d}{dy} \\left( y \\ln y - y \\ln y_{\\mathrm{eq}} - y + y_{\\mathrm{eq}} \\right) = (\\ln y + 1) - \\ln y_{\\mathrm{eq}} - 1 = \\ln\\left(\\frac{y}{y_{\\mathrm{eq}}}\\right)\n$$\n$$\n\\eta''(y) = \\frac{d}{dy} \\left( \\ln y - \\ln y_{\\mathrm{eq}} \\right) = \\frac{1}{y}\n$$\n对于质量分数的物理域 $y > 0$，二阶导数 $\\eta''(y) = 1/y$ 严格为正。这证明了 $\\eta(y)$ 对于 $y>0$ 是一个严格凸函数。\n\n严格凸函数的唯一最小值出现在其一阶导数为零的点。\n$$\n\\eta'(y) = 0 \\implies \\ln\\left(\\frac{y}{y_{\\mathrm{eq}}}\\right) = 0 \\implies \\frac{y}{y_{\\mathrm{eq}}} = 1 \\implies y = y_{\\mathrm{eq}}\n$$\n因此，$\\eta(y)$ 在平衡态 $y = y_{\\mathrm{eq}}$ 处达到其唯一的全局最小值。最小值为 $\\eta(y_{\\mathrm{eq}}) = y_{\\mathrm{eq}} \\ln(1) - (y_{\\mathrm{eq}} - y_{\\mathrm{eq}}) = 0$。\n\n**熵耗散与收缩映射**\n离散熵为 $H(\\mathbf{y}) = \\sum_i \\eta(y_i) \\Delta x$。如果在一个步骤中 $H$ 不增加，则该化学 ODE 的积分器是熵耗散的（或熵稳定的）。由于 $\\eta(y)$ 是凸函数且其最小值在 $y_{\\mathrm{eq}}$，任何将状态向 $y_{\\mathrm{eq}}$ 靠近的更新 $y^n \\to y^{n+1}$（即，是朝向 $y_{\\mathrm{eq}}$ 的收缩映射）都将导致 $\\eta(y^{n+1}) \\le \\eta(y^n)$。如果这对所有单元 $i$ 都成立，则 $H(\\mathbf{y}^{n+1}) \\le H(\\mathbf{y}^n)$。\n\n**后向欧拉化学步骤的熵稳定性**\n让我们分析 BE 更新 $y^* = \\frac{y^n + k \\Delta t y_{\\mathrm{eq}}}{1 + k \\Delta t}$ 与平衡点之间的距离。\n$$\ny^* - y_{\\mathrm{eq}} = \\frac{y^n + k \\Delta t y_{\\mathrm{eq}}}{1 + k \\Delta t} - y_{\\mathrm{eq}} = \\frac{y^n + k \\Delta t y_{\\mathrm{eq}} - y_{\\mathrm{eq}}(1 + k \\Delta t)}{1 + k \\Delta t} = \\frac{y^n - y_{\\mathrm{eq}}}{1 + k \\Delta t}\n$$\n取绝对值：\n$$\n|y^* - y_{\\mathrm{eq}}| = \\frac{1}{1 + k \\Delta t} |y^n - y_{\\mathrm{eq}}|\n$$\n由于 $k>0$ 和 $\\Delta t>0$，因子 $1/(1+k\\Delta t)$ 严格小于 $1$。这表明对于任何时间步长 $\\Delta t > 0$，BE 步骤都是一个朝向平衡点 $y_{\\mathrm{eq}}$ 的严格收缩映射。因此，对于任何 $y^n \\neq y_{\\mathrm{eq}}$，有 $\\eta(y^*) < \\eta(y^n)$，而如果 $y^n = y_{\\mathrm{eq}}$，则 $\\eta(y^*) = \\eta(y^n)$。因此，BE 化学步骤是无条件熵稳定的。\n\n对 IMEX 格式的类似分析表明，它可以被解释为一个显式迎风平流步骤（由于 $\\eta$ 的凸性而是熵稳定的），其后跟着一个无条件熵稳定的 BE 反应步骤。因此，我们期望完整的 IMEX 步骤是熵稳定的。然而，显式 FE 化学步骤在 $k \\Delta t > 2$ 时不是一个收缩映射，并且预计在刚性区域会违反熵稳定性。\n\n### 实现与比较\n实现了三种数值方法——带后向欧拉化学步骤的算子分裂法（Split-BE）、带前向欧拉化学步骤的算子分裂法（Split-FE）和 IMEX 欧拉法。系统从指定的初始条件演化到时间 $T=0.2$。对于三个测试案例 $(k, \\Delta t)$ 中的每一个，都用每种方法运行模拟。在模拟过程中，我们跟踪两个属性：\n1. **正性**：解向量 $\\mathbf{y}$ 是否在所有网格点上保持非负。这在最终时间 $T$ 进行检查。\n2. **熵稳定性**：对于每个相关步骤（分裂法中的化学子步，IMEX 中的完整步骤），我们计算步骤前后的离散熵 $H(\\mathbf{y})$，并验证它没有增加。一个初始化为 true 的布尔标志在第一次违反时被设为 false。\n使用离散 $\\ell^1$-范数来比较 Split-BE 和 IMEX 方法的最终状态，以量化它们的差异。根据问题规范，系统地收集每个测试案例的结果。实现细节在最终答案代码块中提供。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reactive advection problem using three different numerical methods\n    and reports on their stability properties and differences.\n    \"\"\"\n    # Global parameters\n    N = 100\n    L = 1.0\n    dx = L / N\n    a = 0.5\n    y_eq = 0.05\n    T = 0.2\n    x = np.linspace(0, L, N, endpoint=False)\n\n    # Initial condition\n    y0 = y_eq + 0.4 * np.exp(-200 * (x - 0.25)**2) + 0.2 * np.exp(-400 * (x - 0.75)**2)\n\n    # Entropy function eta(y)\n    # Define eta(0) = y_eq for continuity as y*ln(y) -> 0 for y->0+\n    def eta(y, y_eq_val):\n        # Use np.where to handle y=0 case to avoid log(0) warnings\n        y_safe = np.where(y > 0, y, 1.0) # a dummy value for log, result not used\n        log_term = np.where(y > 0, y_safe * np.log(y_safe / y_eq_val), 0)\n        return log_term - (y - y_eq_val)\n\n    # Discrete entropy functional H(y)\n    def discrete_entropy(y, y_eq_val, dx_val):\n        return np.sum(eta(y, y_eq_val)) * dx_val\n\n    # --- Method Implementations ---\n\n    def run_split_be(y_init, k, dt, T_final, a_val, y_eq_val, dx_val):\n        y = y_init.copy()\n        cfl = a_val * dt / dx_val\n        entropy_stable = True\n        \n        num_steps = int(T_final / dt)\n        remaining_time = T_final - num_steps * dt\n\n        time_steps = [dt] * num_steps\n        if remaining_time > 1e-12:\n            time_steps.append(remaining_time)\n\n        for t_step in time_steps:\n            # Chemistry substep (Backward Euler)\n            H_before_chem = discrete_entropy(y, y_eq_val, dx_val)\n            y_star = (y + k * t_step * y_eq_val) / (1.0 + k * t_step)\n            H_after_chem = discrete_entropy(y_star, y_eq_val, dx_val)\n            if H_after_chem > H_before_chem + 1e-12: # Check with tolerance\n                entropy_stable = False\n            \n            # Advection substep (Forward Euler, Upwind)\n            cfl_step = a_val * t_step / dx_val\n            y = y_star - cfl_step * (y_star - np.roll(y_star, 1))\n        \n        positivity = np.all(y >= 0)\n        return y, positivity, entropy_stable\n\n    def run_split_fe(y_init, k, dt, T_final, a_val, y_eq_val, dx_val):\n        y = y_init.copy()\n        entropy_stable = True\n\n        num_steps = int(T_final / dt)\n        remaining_time = T_final - num_steps * dt\n\n        time_steps = [dt] * num_steps\n        if remaining_time > 1e-12:\n            time_steps.append(remaining_time)\n\n        for t_step in time_steps:\n            # Chemistry substep (Forward Euler)\n            H_before_chem = discrete_entropy(y, y_eq_val, dx_val)\n            y_star = y * (1.0 - k * t_step) + k * t_step * y_eq_val\n            H_after_chem = discrete_entropy(y_star, y_eq_val, dx_val)\n            if H_after_chem > H_before_chem + 1e-12:\n                entropy_stable = False\n            \n            # Advection substep (Forward Euler, Upwind)\n            cfl_step = a_val * t_step / dx_val\n            y = y_star - cfl_step * (y_star - np.roll(y_star, 1))\n\n        positivity = np.all(y >= 0)\n        return y, positivity, entropy_stable\n\n    def run_imex(y_init, k, dt, T_final, a_val, y_eq_val, dx_val):\n        y = y_init.copy()\n        entropy_stable = True\n        \n        num_steps = int(T_final / dt)\n        remaining_time = T_final - num_steps * dt\n\n        time_steps = [dt] * num_steps\n        if remaining_time > 1e-12:\n            time_steps.append(remaining_time)\n        \n        for t_step in time_steps:\n            H_before = discrete_entropy(y, y_eq_val, dx_val)\n            \n            # IMEX update\n            cfl_step = a_val * t_step / dx_val\n            advection_term = y - cfl_step * (y - np.roll(y, 1))\n            numerator = advection_term + k * t_step * y_eq_val\n            denominator = 1.0 + k * t_step\n            y = numerator / denominator\n            \n            H_after = discrete_entropy(y, y_eq_val, dx_val)\n            if H_after > H_before + 1e-12:\n                entropy_stable = False\n        \n        positivity = np.all(y >= 0)\n        return y, positivity, entropy_stable\n\n    # Test cases\n    test_cases = [\n        (1000, 0.001),  # Case A\n        (8000, 0.01),   # Case B\n        (500, 0.02),    # Case C\n    ]\n    \n    all_results = []\n\n    for k_val, dt_val in test_cases:\n        y_be, p_be, e_be = run_split_be(y0, k_val, dt_val, T, a, y_eq, dx)\n        y_imex, p_imex, e_imex = run_imex(y0, k_val, dt_val, T, a, y_eq, dx)\n        y_ee, p_ee, e_ee = run_split_fe(y0, k_val, dt_val, T, a, y_eq, dx)\n        \n        d_l1 = np.sum(np.abs(y_imex - y_be)) * dx\n        \n        case_results = [p_be, e_be, p_imex, e_imex, p_ee, e_ee, d_l1]\n        all_results.append(case_results)\n\n    # Format output string\n    def format_val(v):\n        if isinstance(v, bool):\n            return str(v)\n        if isinstance(v, np.bool_):\n            return str(v)\n        return f\"{v:.15g}\"\n\n    sublist_strs = []\n    for res in all_results:\n        sublist_strs.append(f\"[{','.join(format_val(v) for v in res)}]\")\n    \n    final_output_str = f\"[{','.join(sublist_strs)}]\"\n\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}