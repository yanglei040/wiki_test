{
    "hands_on_practices": [
        {
            "introduction": "许多多物理场问题通过“分区”迭代方案求解，即各个物理场被分开独立求解。然而，这种整体过程的收敛性并非理所当然，它取决于耦合的特性。本练习对一个简化的热力学耦合问题，就两种常见的分区迭代方案——块雅可比（Block-Jacobi）和块高斯-赛德尔（Block-Gauss-Seidel）方法，进行了基础性的分析。通过该练习，你将掌握如何基于系统属性来解析预测迭代行为的工具。",
            "id": "3504785",
            "problem": "一根长度为 $L$、横截面积为 $A$ 的一维线性热弹性杆，在参考绝对温度 $\\theta_{0}$ 附近，于小应变和小温升的条件下进行建模。该杆左端被夹紧，右端有轴向位移 $u$；温度场假设是均匀的，并由单个自由度 $T$ 表示。力学平衡是准静态的（无惯性），热平衡采用包含热容的傅里叶传导。考虑从时间 $t^{n}$ 到 $t^{n+1}$ 的一个大小为 $\\Delta t$ 的后向（隐式）欧拉时间步，以及一个用于力学和热学的单自由度简化的单个线性两节点杆单元。由此产生的未知数 $(u^{n+1}, T^{n+1})$ 的整体线性系统呈块状形式：\n$$\n\\begin{pmatrix}\nK  -C \\\\\nD_{\\mathrm{eff}}  H\n\\end{pmatrix}\n\\begin{pmatrix}\nu^{n+1} \\\\\nT^{n+1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nr_{u} \\\\\nr_{T}\n\\end{pmatrix},\n$$\n其中\n- $K = E A / L$ 是轴向刚度，\n- $H = c \\rho A L / \\Delta t + \\kappa A / L$ 是热学后向欧拉有效热容加导热系数，\n- $C = E A \\alpha_{\\mathrm{th}}$ 是进入力学方程的热弹性热载荷系数，\n- $D_{\\mathrm{eff}} = \\theta_{0} \\alpha_{\\mathrm{th}} E A / \\Delta t$ 是时间离散化后进入热学方程的有效热弹性耦合项，\n这里 $E$ 是杨氏模量，$\\alpha_{\\mathrm{th}}$ 是热膨胀系数，$\\kappa$ 是热导率， $c$ 是比热，$ \\rho$ 是质量密度。假设右侧项 $(r_{u}, r_{T})$ 有界。\n\n考虑两种分块定点策略来求解这个耦合系统：\n- 块雅可比（Block-Jacobi）（同步）分块迭代：在第 $k+1$ 次迭代中，分别使用右侧的 $T^{k}$ 和 $u^{k}$ 求解力学和热学子问题。\n- 块高斯-赛德尔（Block-Gauss-Seidel）（顺序）分块迭代：在第 $k+1$ 次迭代中，先使用 $T^{k}$ 从力学子问题更新 $u^{k+1}$，然后使用 $u^{k+1}$ 从热学子问题更新 $T^{k+1}$。\n\n任务：\n1) 从以上两种分块迭代和整体块状系统的定义出发，推导迭代误差 $e_{u}^{k} = u^{k} - u^{\\star}$ 和 $e_{T}^{k} = T^{k} - T^{\\star}$ 的线性误差传播映射，其中 $(u^{\\star}, T^{\\star})$ 是整体系统的解。然后，仅使用线性代数和谱半径的定义，用 $K$、$H$、$C$ 和 $D_{\\mathrm{eff}}$ 表示块雅可比和块高斯-赛德尔误差传播矩阵的谱半径 $\\rho_{\\mathrm{J}}$ 和 $\\rho_{\\mathrm{GS}}$。\n2) 使用以下物理上一致的参数\n- $E = 210 \\times 10^{9}$，$A = 10^{-4}$，$L = 1$，$\\alpha_{\\mathrm{th}} = 1.2 \\times 10^{-5}$，\n- $\\kappa = 45$，$c = 450$，$\\rho = 7800$，$\\theta_{0} = 293$，$\\Delta t = 1$，\n计算 $K$、$H$、$C$ 和 $D_{\\mathrm{eff}}$，然后计算 $\\rho_{\\mathrm{J}}$ 和 $\\rho_{\\mathrm{GS}}$ 的数值。\n\n答案规格：\n- 以有序对 $(\\rho_{\\mathrm{J}}, \\rho_{\\mathrm{GS}})$ 的形式提供你的最终答案。\n- 将 $\\rho_{\\mathrm{J}}$ 和 $\\rho_{\\mathrm{GS}}$ 四舍五入到四位有效数字。\n- 最终答案是无量纲的，必须不带单位报告。",
            "solution": "首先通过提取所有给定信息并检查其科学一致性、完整性和清晰度来验证问题。\n\n## 问题验证\n\n### 步骤 1：提取已知条件\n- **系统**：长度为 $L$、面积为 $A$ 的一维线性热弹性杆。\n- **假设**：小应变，围绕 $\\theta_{0}$ 的小温升，准静态力学，带热容的傅里叶传导。\n- **离散化**：单个两节点线性单元，位移 ($u$) 和温度 ($T$) 各一个自由度。单个大小为 $\\Delta t$ 的后向欧拉时间步。\n- **整体系统**：\n$$\n\\begin{pmatrix}\nK   -C \\\\\nD_{\\mathrm{eff}}   H\n\\end{pmatrix}\n\\begin{pmatrix}\nu^{n+1} \\\\\nT^{n+1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nr_{u} \\\\\nr_{T}\n\\end{pmatrix}\n$$\n- **系数定义**：\n  - 刚度：$K = E A / L$\n  - 热有效矩阵：$H = c \\rho A L / \\Delta t + \\kappa A / L$\n  - 力学耦合：$C = E A \\alpha_{\\mathrm{th}}$\n  - 热耦合：$D_{\\mathrm{eff}} = \\theta_{0} \\alpha_{\\mathrm{th}} E A / \\Delta t$\n- **物理参数**：\n  - 杨氏模量：$E = 210 \\times 10^{9}$\n  - 面积：$A = 10^{-4}$\n  - 长度：$L = 1$\n  - 热膨胀系数：$\\alpha_{\\mathrm{th}} = 1.2 \\times 10^{-5}$\n  - 热导率：$\\kappa = 45$\n  - 比热：$c = 450$\n  - 质量密度：$\\rho = 7800$\n  - 参考温度：$\\theta_{0} = 293$\n  - 时间步长：$\\Delta t = 1$\n- **分块格式**：\n  - 块雅可比：使用上一次迭代的 $u^k$ 和 $T^k$ 求解 $u^{k+1}$ 和 $T^{k+1}$。\n  - 块高斯-赛德尔：使用 $T^k$ 求解 $u^{k+1}$，然后使用新的 $u^{k+1}$ 求解 $T^{k+1}$。\n- **任务**：\n  1. 推导误差传播矩阵的谱半径 $\\rho_{\\mathrm{J}}$ 和 $\\rho_{\\mathrm{GS}}$ 的表达式。\n  2. 计算 $\\rho_{\\mathrm{J}}$ 和 $\\rho_{\\mathrm{GS}}$ 的数值。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题描述了一个标准、简化的线性热弹性模型，这是计算多物理场中的一个基本问题。控制方程、系数定义和物理参数与连续介质力学和热传导的既定原理一致。离散化方法（空间上的有限元法，时间上的后向欧拉法）是标准的。提供的参数对于钢材是符合实际的。问题是自洽、适定且客观的。它没有违反任何无效性标准。\n\n### 步骤 3：结论与操作\n问题有效。将提供完整解答。\n\n## 解答\n\n设整体系统的精确解为 $(u^{\\star}, T^{\\star})$。此解满足：\n$$ K u^{\\star} - C T^{\\star} = r_{u} $$\n$$ D_{\\mathrm{eff}} u^{\\star} + H T^{\\star} = r_{T} $$\n第 $k$ 步的迭代误差定义为 $e_{u}^{k} = u^{k} - u^{\\star}$ 和 $e_{T}^{k} = T^{k} - T^{\\star}$。\n\n### 任务 1：谱半径的推导\n\n**块雅可比分块迭代**\n\n块雅可比格式的定义是独立求解对角块，对非对角耦合项使用上一次迭代 $k$ 的值：\n$$ K u^{k+1} = r_{u} + C T^{k} $$\n$$ H T^{k+1} = r_{T} - D_{\\mathrm{eff}} u^{k} $$\n从迭代方程中减去精确解方程，得到误差传播方程：\n$$ K (u^{k+1} - u^{\\star}) = C (T^{k} - T^{\\star}) \\implies K e_{u}^{k+1} = C e_{T}^{k} $$\n$$ H (T^{k+1} - T^{\\star}) = -D_{\\mathrm{eff}} (u^{k} - u^{\\star}) \\implies H e_{T}^{k+1} = -D_{\\mathrm{eff}} e_{u}^{k} $$\n将这些方程整理成关于误差向量 $\\mathbf{e}^{k+1} = \\begin{pmatrix} e_{u}^{k+1}  e_{T}^{k+1} \\end{pmatrix}^T$ 的系统：\n$$ e_{u}^{k+1} = K^{-1} C e_{T}^{k} $$\n$$ e_{T}^{k+1} = -H^{-1} D_{\\mathrm{eff}} e_{u}^{k} $$\n误差传播由矩阵关系 $\\mathbf{e}^{k+1} = G_{\\mathrm{J}} \\mathbf{e}^{k}$ 控制，其中 $G_{\\mathrm{J}}$ 是块雅可比迭代矩阵：\n$$ G_{\\mathrm{J}} = \\begin{pmatrix} 0  K^{-1} C \\\\ -H^{-1} D_{\\mathrm{eff}}  0 \\end{pmatrix} $$\n谱半径 $\\rho_{\\mathrm{J}}$ 是 $G_{\\mathrm{J}}$ 的特征值 $\\lambda$ 的最大绝对值。特征值由特征方程 $\\det(G_{\\mathrm{J}} - \\lambda I) = 0$ 求得：\n$$ \\det \\begin{pmatrix} -\\lambda  K^{-1} C \\\\ -H^{-1} D_{\\mathrm{eff}}  -\\lambda \\end{pmatrix} = (-\\lambda)(-\\lambda) - (K^{-1} C)(-H^{-1} D_{\\mathrm{eff}}) = \\lambda^2 + K^{-1} H^{-1} C D_{\\mathrm{eff}} = 0 $$\n$$ \\lambda^2 = - \\frac{C D_{\\mathrm{eff}}}{K H} $$\n由于所有系数 $K, H, C, D_{\\mathrm{eff}}$ 都是正标量，特征值是纯虚数：\n$$ \\lambda = \\pm i \\sqrt{\\frac{C D_{\\mathrm{eff}}}{K H}} $$\n谱半径是这些特征值的模：\n$$ \\rho_{\\mathrm{J}} = \\left| \\pm i \\sqrt{\\frac{C D_{\\mathrm{eff}}}{K H}} \\right| = \\sqrt{\\frac{C D_{\\mathrm{eff}}}{K H}} $$\n\n**块高斯-赛德尔分块迭代**\n\n块高斯-赛德尔格式按顺序更新变量。首先，使用 $T^k$ 计算 $u^{k+1}$，然后立即使用这个新值 $u^{k+1}$ 来计算 $T^{k+1}$：\n$$ K u^{k+1} = r_{u} + C T^{k} $$\n$$ H T^{k+1} = r_{T} - D_{\\mathrm{eff}} u^{k+1} $$\n再次，我们减去精确解方程来找到误差传播：\n$$ K e_{u}^{k+1} = C e_{T}^{k} \\implies e_{u}^{k+1} = K^{-1} C e_{T}^{k} $$\n$$ H e_{T}^{k+1} = -D_{\\mathrm{eff}} e_{u}^{k+1} $$\n将第一个方程中的 $e_{u}^{k+1}$ 表达式代入第二个方程：\n$$ H e_{T}^{k+1} = -D_{\\mathrm{eff}} (K^{-1} C e_{T}^{k}) \\implies e_{T}^{k+1} = -H^{-1} D_{\\mathrm{eff}} K^{-1} C e_{T}^{k} $$\n误差传播方程可以写成矩阵形式 $\\mathbf{e}^{k+1} = G_{\\mathrm{GS}} \\mathbf{e}^{k}$：\n$$ \\begin{pmatrix} e_{u}^{k+1} \\\\ e_{T}^{k+1} \\end{pmatrix} = \\begin{pmatrix} 0  K^{-1} C \\\\ 0  -H^{-1} D_{\\mathrm{eff}} K^{-1} C \\end{pmatrix} \\begin{pmatrix} e_{u}^{k} \\\\ e_{T}^{k} \\end{pmatrix} $$\n迭代矩阵是：\n$$ G_{\\mathrm{GS}} = \\begin{pmatrix} 0  K^{-1} C \\\\ 0  - \\frac{C D_{\\mathrm{eff}}}{K H} \\end{pmatrix} $$\n由于 $G_{\\mathrm{GS}}$ 是一个上三角矩阵，其特征值即为其对角线元素：$\\lambda_1 = 0$ 和 $\\lambda_2 = - \\frac{C D_{\\mathrm{eff}}}{K H}$。\n谱半径 $\\rho_{\\mathrm{GS}}$ 是它们绝对值的最大值：\n$$ \\rho_{\\mathrm{GS}} = \\max \\left( |0|, \\left|- \\frac{C D_{\\mathrm{eff}}}{K H}\\right| \\right) = \\frac{C D_{\\mathrm{eff}}}{K H} $$\n注意 $\\rho_{\\mathrm{GS}} = (\\rho_{\\mathrm{J}})^2$，这是此类问题的一个已知结果。\n\n### 任务 2：数值计算\n\n首先，我们使用提供的物理参数以国际单位制（SI）计算系数的数值。\n- $K = \\frac{E A}{L} = \\frac{(210 \\times 10^{9}) (10^{-4})}{1} = 2.1 \\times 10^{7}$\n- $C = E A \\alpha_{\\mathrm{th}} = (210 \\times 10^{9}) (10^{-4}) (1.2 \\times 10^{-5}) = 252$\n- $D_{\\mathrm{eff}} = \\frac{\\theta_{0} \\alpha_{\\mathrm{th}} E A}{\\Delta t} = \\frac{293 \\times (1.2 \\times 10^{-5}) (210 \\times 10^{9}) (10^{-4})}{1} = 73836$\n- $H = \\frac{c \\rho A L}{\\Delta t} + \\frac{\\kappa A}{L} = \\frac{450 \\times 7800 \\times 10^{-4} \\times 1}{1} + \\frac{45 \\times 10^{-4}}{1} = 351 + 0.0045 = 351.0045$\n\n接下来，我们计算无量纲耦合参数 $\\gamma = \\frac{C D_{\\mathrm{eff}}}{K H}$：\n$$ \\gamma = \\frac{252 \\times 73836}{(2.1 \\times 10^{7}) \\times 351.0045} = \\frac{18606672}{7371094500} \\approx 0.002524263 $$\n现在我们可以计算谱半径：\n- $\\rho_{\\mathrm{GS}} = \\gamma \\approx 0.002524263$\n- $\\rho_{\\mathrm{J}} = \\sqrt{\\gamma} \\approx \\sqrt{0.002524263} \\approx 0.050242048$\n\n按要求四舍五入到四位有效数字：\n- $\\rho_{\\mathrm{GS}} = 0.002524$\n- $\\rho_{\\mathrm{J}} = 0.05024$\n\n最终答案是有序对 $(\\rho_{\\mathrm{J}}, \\rho_{\\mathrm{GS}})$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.05024  0.002524\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在单个系统分析的基础上，我们现在考虑一个更复杂的场景，它涉及具有不同物理特性的耦合现象（波传播与扩散）。共享时间步长的选择通常受到最严格稳定性极限的约束。本练习探讨如何在遵守系统另一部分施加的稳定性约束的同时，选择合适的数值参数（如库朗数 $S$）以最小化某种类型的误差（例如色散误差）。",
            "id": "3504843",
            "problem": "一个一维线性热声模型将双曲型声波与抛物型热扩散耦合起来，该模型建立在空间步长为 $\\Delta x$、共享时间步长为 $\\Delta t$ 的均匀网格上。声压 $p(x,t)$ 在主阶上满足波动方程 $p_{tt} = c^{2} p_{xx}$，其中 $c$ 是声速；温度 $T(x,t)$ 满足热方程 $T_{t} = \\kappa T_{xx}$，其中 $\\kappa$ 是热扩散系数。耦合项是线性的且是弱的，其意义在于，在小时间步长和小网格间距的极限下，它们不改变任一子系统的主部（最高阶导数项）。采用了一种分区显式格式，其中：\n- 波动分量通过标准的二阶显式三层中心差分格式进行推进，\n$$\np_{j}^{n+1} = 2 p_{j}^{n} - p_{j}^{n-1} + S^{2}\\left(p_{j+1}^{n} - 2 p_{j}^{n} + p_{j-1}^{n}\\right),\n$$\n其中库朗数 $S \\equiv c\\,\\Delta t/\\Delta x$。\n- 扩散分量通过一种使用标准中心二阶空间差分的显式二阶方法进行推进。\n\n假设 von Neumann 分析适用，并且共享时间步长 $\\Delta t$ 必须满足两个子系统的稳定性条件。将波动分量的色散误差定义为，在小无量纲波数 $\\theta \\equiv k\\,\\Delta x$（其中 $k$ 是物理波数）下，数值波与连续波之间的相对相速度误差。\n\n仅从控制方程、库朗数的定义以及上述数值更新格式出发，进行一致性和 von Neumann 分析，以实现以下目标：\n- 推导波动格式相对相速度误差在小 $\\theta$ 情况下的主阶项，并将其表示为 $S$ 的函数。\n- 使用显式扩散更新格式所隐含的稳定性约束来界定 $S$ 的可行集。\n- 结论：可行集内的哪个 $S$ 值能够最小化波动分量的主阶色散误差。\n\n计算并报告最优库朗数 $S_{\\mathrm{opt}}$，将其表示为关于 $c$、$\\kappa$ 和 $\\Delta x$ 的单个闭式解析表达式。最终答案是无量纲的，必须以精确表达式（无舍入）的形式给出。最终答案请勿包含单位。",
            "solution": "问题陈述经评估具有科学依据、适定、客观，并包含足够信息以推导出唯一解，因此被认为是有效的。求解过程通过分别分析波动方程和热方程的数值格式以确定它们各自的性质，然后结合这些约束来找到最优参数。\n\n该过程分为三个主要部分：\n1.  推导波动方程格式的主阶色散误差。\n2.  推导热方程格式的稳定性约束。\n3.  在稳定性约束条件下，确定能最小化波动色散误差的最优库朗数 $S_{\\mathrm{opt}}$。\n\n**1. 波动格式的色散分析**\n\n声压 $p(x,t)$ 的数值格式是显式三层中心差分格式：\n$$p_{j}^{n+1} = 2 p_{j}^{n} - p_{j}^{n-1} + S^{2}\\left(p_{j+1}^{n} - 2 p_{j}^{n} + p_{j-1}^{n}\\right)$$\n其中 $S = c\\,\\Delta t/\\Delta x$ 是库朗数，$j$ 是空间索引，$n$ 是时间索引。\n\n我们通过代入形式为 $p_j^n = \\hat{p}(k) g^n e^{i k x_j}$ 的单个傅里叶模态解来进行 von Neumann 稳定性分析，其中 $x_j = j \\Delta x$，$k$ 是波数，$g$ 是每个时间步长的复放大因子。使用无量纲波数 $\\theta \\equiv k \\Delta x$，试探解为 $p_j^n \\propto g^n e^{i j \\theta}$。将其代入数值格式得到：\n$$g^{n+1} e^{ij\\theta} = 2 g^n e^{ij\\theta} - g^{n-1} e^{ij\\theta} + S^2 \\left(g^n e^{i(j+1)\\theta} - 2 g^n e^{ij\\theta} + g^n e^{i(j-1)\\theta}\\right)$$\n两边同除以 $g^n e^{ij\\theta}$，并使用 $g^{n+1}/g^n=g$ 和 $g^{n-1}/g^n=g^{-1}$：\n$$g = 2 - g^{-1} + S^2 \\left(e^{i\\theta} - 2 + e^{-i\\theta}\\right)$$\n使用恒等式 $e^{i\\theta} + e^{-i\\theta} = 2 \\cos(\\theta)$，我们得到：\n$$g + g^{-1} = 2 + S^2 (2 \\cos(\\theta) - 2) = 2 - 2S^2 (1 - \\cos(\\theta))$$\n使用半角恒等式 $1 - \\cos(\\theta) = 2 \\sin^2(\\theta/2)$：\n$$g + g^{-1} = 2 - 4S^2 \\sin^2(\\theta/2)$$\n两边乘以 $g$ 并整理，得到关于放大因子 $g$ 的二次方程：\n$$g^2 - \\left(2 - 4S^2 \\sin^2(\\theta/2)\\right)g + 1 = 0$$\n对于一个非耗散格式，其根必须是单位圆上的复共轭对，即 $|g|=1$。我们可以写成 $g=e^{-i\\omega_{\\mathrm{num}}\\Delta t}$，其中 $\\omega_{\\mathrm{num}}$ 是数值角频率。对于这样的解，$g+g^{-1} = 2\\cos(\\omega_{\\mathrm{num}}\\Delta t)$。将此与上面的表达式进行比较：\n$$2\\cos(\\omega_{\\mathrm{num}}\\Delta t) = 2 - 4S^2 \\sin^2(\\theta/2)$$\n$$\\cos(\\omega_{\\mathrm{num}}\\Delta t) = 1 - 2S^2 \\sin^2(\\theta/2)$$\n这意味着对于一个稳定的解（$|g|=1$），余弦函数的自变量必须是实数，这要求 $|1-2S^2\\sin^2(\\theta/2)| \\leq 1$。这导出了CFL稳定性条件 $S \\leq 1$。\n\n数值相速度为 $c_{\\mathrm{num}} = \\omega_{\\mathrm{num}}/k$。相对相速度误差为 $\\frac{c_{\\mathrm{num}}}{c}-1$。\n$$\\omega_{\\mathrm{num}} = \\frac{1}{\\Delta t} \\arccos\\left(1 - 2S^2 \\sin^2(\\frac{\\theta}{2})\\right)$$\n$$c_{\\mathrm{num}} = \\frac{\\omega_{\\mathrm{num}}}{k} = \\frac{1}{k \\Delta t} \\arccos\\left(1 - 2S^2 \\sin^2(\\frac{\\theta}{2})\\right)$$\n相对相速度为：\n$$\\frac{c_{\\mathrm{num}}}{c} = \\frac{1}{c k \\Delta t} \\arccos\\left(1 - 2S^2 \\sin^2(\\frac{\\theta}{2})\\right) = \\frac{\\Delta x}{S \\theta} \\arccos\\left(1 - 2S^2 \\sin^2(\\frac{\\theta}{2})\\right)$$\n为了找到小 $\\theta$ 情况下的主阶误差，我们展开各项。令 $\\alpha = \\omega_{\\mathrm{num}}\\Delta t$。则有 $\\cos(\\alpha) = 1 - 2S^2 \\sin^2(\\theta/2)$。\n设 $\\sin(\\alpha/2) = S \\sin(\\theta/2)$ 会更方便。那么 $\\cos(\\alpha) = 1-2\\sin^2(\\alpha/2) = 1-2S^2\\sin^2(\\theta/2)$，这与前面的结果一致。\n从 $\\alpha = 2 \\arcsin(S\\sin(\\theta/2))$ 出发，我们对小 $\\theta$ 进行展开：\n$\\arcsin$ 的自变量是 $S \\sin(\\theta/2) = S \\left( \\frac{\\theta}{2} - \\frac{1}{6}\\left(\\frac{\\theta}{2}\\right)^3 + O(\\theta^5) \\right) = S\\frac{\\theta}{2} - \\frac{S\\theta^3}{48} + O(\\theta^5)$。\n使用展开式 $\\arcsin(z) = z + z^3/6 + O(z^5)$：\n$$\\alpha = 2 \\left[ \\left(S\\frac{\\theta}{2} - \\frac{S\\theta^3}{48}\\right) + \\frac{1}{6}\\left(S\\frac{\\theta}{2}\\right)^3 + O(\\theta^5) \\right]$$\n$$\\alpha = S\\theta - \\frac{S\\theta^3}{24} + \\frac{S^3\\theta^3}{24} + O(\\theta^5) = S\\theta + \\frac{S(S^2-1)}{24}\\theta^3 + O(\\theta^5)$$\n现在我们求相对相速度：\n$$\\frac{c_{\\mathrm{num}}}{c} = \\frac{\\omega_{\\mathrm{num}}/k}{c} = \\frac{\\alpha/\\Delta t}{c k} = \\frac{\\alpha \\Delta x}{c \\Delta t \\theta} = \\frac{\\alpha}{S\\theta}$$\n$$\\frac{c_{\\mathrm{num}}}{c} = \\frac{1}{S\\theta} \\left( S\\theta + \\frac{S(S^2-1)}{24}\\theta^3 + O(\\theta^5) \\right) = 1 + \\frac{S^2-1}{24}\\theta^2 + O(\\theta^4)$$\n相对相速度误差为 $\\frac{c_{\\mathrm{num}}}{c} - 1$。其主阶项为 $\\frac{S^2-1}{24}\\theta^2$。为了最小化此误差的绝对值，必须最小化 $|S^2-1|$。由于稳定性要求 $S \\le 1$，这等价于最小化 $1-S^2$，而这可以通过使 $S$ 尽可能大，即尽可能接近 1 来实现。\n\n**2. 扩散格式的稳定性分析**\n\n问题陈述指出，扩散分量 $T_t = \\kappa T_{xx}$ 是通过一种使用“标准中心二阶空间差分”的显式方法来推进的。这指定了空间算子的离散化为 $\\kappa T_{xx} \\approx \\kappa \\frac{T_{j+1}-2T_j+T_{j-1}}{(\\Delta x)^2}$。对此最简单且最常见的显式时间积分格式是时间向前中心差分（FTCS）方法，该方法在时间上是一阶的，在空间上是二阶的。该格式为：\n$$\\frac{T_j^{n+1} - T_j^n}{\\Delta t} = \\kappa \\frac{T_{j+1}^n - 2T_j^n + T_{j-1}^n}{(\\Delta x)^2}$$\n整理后得到更新规则：\n$$T_j^{n+1} = T_j^n + D \\left( T_{j+1}^n - 2T_j^n + T_{j-1}^n \\right)$$\n其中 $D = \\frac{\\kappa \\Delta t}{(\\Delta x)^2}$ 是数值扩散数。\n使用试探解 $T_j^n \\propto g^n e^{ij\\theta}$ 进行 von Neumann 分析：\n$$g = 1 + D(e^{i\\theta} - 2 + e^{-i\\theta}) = 1 + D(2\\cos\\theta - 2) = 1 - 2D(1-\\cos\\theta) = 1 - 4D \\sin^2(\\frac{\\theta}{2})$$\n为了保证稳定性，放大因子必须对所有 $\\theta \\in [-\\pi, \\pi]$ 满足 $|g| \\le 1$。\n$$|1 - 4D \\sin^2(\\frac{\\theta}{2})| \\le 1$$\n这等价于以下两个不等式：\n1. $1 - 4D \\sin^2(\\frac{\\theta}{2}) \\le 1 \\implies -4D \\sin^2(\\frac{\\theta}{2}) \\le 0$。由于 $D > 0$，此式恒成立。\n2. $-1 \\le 1 - 4D \\sin^2(\\frac{\\theta}{2}) \\implies 4D \\sin^2(\\frac{\\theta}{2}) \\le 2 \\implies D \\sin^2(\\frac{\\theta}{2}) \\le \\frac{1}{2}$。\n此不等式必须对所有 $\\theta$ 成立。$\\sin^2(\\theta/2)$ 的最大值为 1。因此，稳定性条件是：\n$$D \\le \\frac{1}{2} \\implies \\frac{\\kappa \\Delta t}{(\\Delta x)^2} \\le \\frac{1}{2}$$\n这对允许的时间步长施加了一个上界：\n$$\\Delta t \\le \\frac{(\\Delta x)^2}{2\\kappa}$$\n\n**3. 确定最优库朗数**\n\n耦合模拟使用一个共享的时间步长 $\\Delta t$，该步长必须同时满足两个子系统的稳定性条件。波动格式要求 $S \\le 1$，可转化为 $\\Delta t \\le \\frac{\\Delta x}{c}$。扩散格式要求 $\\Delta t \\le \\frac{(\\Delta x)^2}{2\\kappa}$。\n因此，共享时间步长必须满足 $\\Delta t \\le \\min\\left(\\frac{\\Delta x}{c}, \\frac{(\\Delta x)^2}{2\\kappa}\\right)$。\n\n问题要求解库朗数 $S$ 的可行集。我们可以通过代入 $\\Delta t = S \\frac{\\Delta x}{c}$，将扩散稳定性约束用 $S$ 表示：\n$$\\frac{\\kappa}{(\\Delta x)^2} \\left(S \\frac{\\Delta x}{c}\\right) \\le \\frac{1}{2}$$\n$$S \\frac{\\kappa}{c \\Delta x} \\le \\frac{1}{2} \\implies S \\le \\frac{c \\Delta x}{2\\kappa}$$\n$S$ 的可行集是两个格式约束的交集：$S > 0$ 且\n$$S \\le 1 \\quad \\text{和} \\quad S \\le \\frac{c \\Delta x}{2\\kappa}$$\n这可以紧凑地写为 $0  S \\le \\min\\left(1, \\frac{c \\Delta x}{2\\kappa}\\right)$。\n\n我们寻求此可行集中的 $S$ 值，以最小化主阶波动色散误差的绝对值，该误差与 $|S^2-1|$ 成正比。在可行集内，$S \\le 1$，所以 $S^2-1 \\le 0$。其绝对值为 $|S^2-1| = 1-S^2$。为了最小化 $1-S^2$，我们必须最大化 $S$。稳定性约束所允许的 $S$ 的最大值就是最优值 $S_{\\mathrm{opt}}$，它能最小化色散误差。\n$$S_{\\mathrm{opt}} = \\max_S \\left\\{ S \\mid 0  S \\le \\min\\left(1, \\frac{c \\Delta x}{2\\kappa}\\right) \\right\\}$$\n因此，最优库朗数是可行集的上界：\n$$S_{\\mathrm{opt}} = \\min\\left(1, \\frac{c \\Delta x}{2\\kappa}\\right)$$\n此表达式给出了用给定参数 $c$、$\\kappa$ 和 $\\Delta x$ 表示的最优库朗数。",
            "answer": "$$\\boxed{\\min\\left(1, \\frac{c \\Delta x}{2 \\kappa}\\right)}$$"
        },
        {
            "introduction": "在验证数值模拟的准确性时，理解不同误差来源至关重要。在这个实践性的编码练习中，我们将使用“精确解方法”（Method of Manufactured Solutions）来研究不完全迭代求解产生的误差（迭代误差）如何掩盖空间离散化带来的潜在误差（离散误差）。你将学会如何设计一个能够识别和分离这些影响的收敛性研究，这是进行可靠代码验证的一项关键技能。",
            "id": "3504784",
            "problem": "考虑在空间区间 $[0,1]$ 上的一个一维、稳态、双场、线性耦合的反应-扩散系统，其边界条件为齐次 Dirichlet 边界条件。未知场为 $u(x)$ 和 $v(x)$，其控制方程为\n$$\n-\\,u''(x) + a\\,u(x) + b\\,v(x) = s_u(x), \\quad -\\,v''(x) + c\\,v(x) + d\\,u(x) = s_v(x),\n$$\n并且 $u(0)=u(1)=0$ 和 $v(0)=v(1)=0$。假设一个构造的精确解为 $u_e(x) = \\sin(\\pi x)$ 和 $v_e(x) = \\sin(2\\pi x)$。设正的反应系数为 $a=1$ 和 $c=2$，耦合系数为 $b=0.1$ 和 $d=0.2$。源项的构造方式使得构造解满足连续方程：\n$$\ns_u(x) = \\pi^2 \\sin(\\pi x) + a \\sin(\\pi x) + b \\sin(2\\pi x), \\quad s_v(x) = (2\\pi)^2 \\sin(2\\pi x) + c \\sin(2\\pi x) + d \\sin(\\pi x).\n$$\n\n你将使用一个包含 $N$ 个点（包括边界）的均匀网格来离散化空间域，网格间距为 $h=1/(N-1)$，并对扩散算子使用二阶中心差分。对于内部网格点，近似 $-u''$（以及类似地 $-v''$）的离散算子为\n$$\n\\frac{2 u_i - u_{i-1} - u_{i+1}}{h^2},\n$$\n反应项则进行逐点处理。由此产生的针对 $u$ 和 $v$ 的解耦离散算子是三对角的且严格对角占优。为了处理耦合，在代数层面使用分块 Gauss–Seidel (Gauss–Seidel) 迭代法：给定内部网格上的一个迭代值 $(u^{(k)}, v^{(k)})$，通过依次求解以下两个线性系统来计算下一个迭代值，\n$$\nA\\,u^{(k+1)} = s_u - b\\,v^{(k)}, \\quad C\\,v^{(k+1)} = s_v - d\\,u^{(k+1)},\n$$\n其中 $A$ 和 $C$ 分别是 $u$ 和 $v$ 的离散解耦算子，$s_u, s_v$ 是通过在内部网格点上对解析的 $s_u(x), s_v(x)$ 进行采样得到的离散源向量。在内部将 $u^{(0)}=0$ 和 $v^{(0)}=0$ 初始化。迭代的终止条件是基于连续迭代值之间的组合变化量的容差，\n$$\n\\| (u^{(k+1)} - u^{(k)}, v^{(k+1)} - v^{(k)}) \\|_{2,h} \\le \\mathrm{tol},\n$$\n其中内部网格上的离散 $L^2$ 范数定义为\n$$\n\\| (x,y) \\|_{2,h} = \\left( h \\sum_{i} x_i^2 + h \\sum_{i} y_i^2 \\right)^{1/2}.\n$$\n\n核心问题在于离散化误差、相容性和收敛性，以及耦合迭代误差如何掩盖渐进离散化误差。总数值误差（相对于在网格上采样的连续构造解）可以被认为是两个贡献之和，在误差足够小的情况下：\n$$\nE_{\\mathrm{tot}}(h,\\mathrm{tol}) \\approx E_{\\mathrm{disc}}(h) + E_{\\mathrm{iter}}(h,\\mathrm{tol}),\n$$\n其中 $E_{\\mathrm{disc}}(h)$ 是由空间离散化引起的（对于二阶中心差分，在足够光滑的条件下，期望阶数为 $p=2$），而 $E_{\\mathrm{iter}}(h,\\mathrm{tol})$ 是由于耦合迭代的过早终止引起的。如果 $\\mathrm{tol}$ 是固定的（不随 $h$ 缩放），那么当 $h \\to 0$ 时，$E_{\\mathrm{disc}}(h) \\to 0$，而 $E_{\\mathrm{iter}}(h,\\mathrm{tol})$ 近似保持不变，从而掩盖了离散化误差并破坏了观测到的渐进速率。\n\n任务：实现一个程序，通过进行数值实验来量化和分离这些误差贡献。对每次运行，计算 $u$ 和 $v$ 的组合离散 $L^2$ 误差：\n$$\nE_{\\mathrm{tot}}(h,\\mathrm{tol}) = \\left( h \\sum_{i} \\left(u^{(k_{\\mathrm{final})}}_i - u_e(x_i)\\right)^2 + h \\sum_{i} \\left(v^{(k_{\\mathrm{final})}}_i - v_e(x_i)\\right)^2 \\right)^{1/2}.\n$$\n此外，当比较相同 $h$ 下的两次运行时，通过以下方式估计耦合迭代误差\n$$\nE_{\\mathrm{iter,est}}(h) = \\left( h \\sum_{i} \\left(u_{\\mathrm{loose},i} - u_{\\mathrm{tight},i}\\right)^2 + h \\sum_{i} \\left(v_{\\mathrm{loose},i} - v_{\\mathrm{tight},i}\\right)^2 \\right)^{1/2},\n$$\n其中“tight”表示使用极小容差的运行，“loose”表示使用固定容差的运行。\n\n设计一个测试套件，包含三次运行，每次都在三种网格分辨率 $N\\in\\{33,65,129\\}$ 上进行评估：\n\n- 情况 A (严格容差，近似整体收敛)：$\\mathrm{tol} = 10^{-12}$ 且最大迭代次数为 $500$。\n- 情况 B (宽松容差，预期出现掩盖)：$\\mathrm{tol} = 10^{-4}$ 且最大迭代次数为 $500$。\n- 情况 C (迭代严重不足，边缘情况)：$\\mathrm{tol}$ 为任意值，最大迭代次数为 $1$。\n\n对于每种情况，计算每个网格上的总误差，然后使用两个最细的网格估算观测到的精度阶 $p_{\\mathrm{obs}}$：\n$$\np_{\\mathrm{obs}} = \\frac{\\ln\\left( E_{\\mathrm{tot}}(h_2,\\mathrm{tol}) / E_{\\mathrm{tot}}(h_3,\\mathrm{tol}) \\right)}{\\ln\\left( h_2 / h_3 \\right)},\n$$\n其中 $h_2=1/(65-1)$ 和 $h_3=1/(129-1)$。此外，对于最细网格（$N=129$）上的情况 B，计算比率\n$$\nr_{\\mathrm{fine}} = \\frac{E_{\\mathrm{iter,est}}(h_3)}{E_{\\mathrm{tot}}(h_3,\\mathrm{tol}_{\\mathrm{loose}})}.\n$$\n\n你的程序必须产生单行输出，其中包含一个方括号内的逗号分隔列表，该列表包含以下六个条目：\n- 使用两个最细网格计算出的情况 A 的观测阶 $p_{\\mathrm{obs}}$，作为一个浮点数。\n- 使用两个最细网格计算出的情况 B 的观测阶 $p_{\\mathrm{obs}}$，作为一个浮点数。\n- 使用两个最细网格计算出的情况 C 的观测阶 $p_{\\mathrm{obs}}$，作为一个浮点数。\n- 情况 B 在 $N=129$ 时的比率 $r_{\\mathrm{fine}}$，作为一个在 $[0,1]$ 区间内的浮点数。\n- 一个布尔值，指示严格容差下的观测阶是否在 $[1.8,2.2]$ 区间内。\n- 一个布尔值，指示在情况 B 中是否观察到掩盖现象，其定义为同时满足 $p_{\\mathrm{obs}}  1.0$ 和 $r_{\\mathrm{fine}} > 0.5$。\n\n所有量都是无量纲的，因此不需要物理单位。你的程序应产生单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果（例如，$[p_A,p_B,p_C,r_{\\mathrm{fine}},\\mathrm{bool}_A,\\mathrm{bool}_B]$）。程序必须是自包含的，无需任何输入或外部文件即可运行。数值实验必须严格遵守所述的离散化和耦合迭代过程，并逐字使用指定的测试套件参数。",
            "solution": "用户提供了一个有效且适定的问题。本响应提供了解决方案。\n\n### 1. 理论框架\n\n该问题要求对一个耦合的、一维的、稳态的反应-扩散系统进行数值研究。在域 $x \\in [0,1]$ 上，两个场 $u(x)$ 和 $v(x)$ 的控制偏微分方程 (PDE) 为：\n$$\n-\\,u''(x) + a\\,u(x) + b\\,v(x) = s_u(x)\n$$\n$$\n-\\,v''(x) + c\\,v(x) + d\\,u(x) = s_v(x)\n$$\n这些方程服从齐次 Dirichlet 边界条件，$u(0)=u(1)=0$ 和 $v(0)=v(1)=0$。系数给定为 $a=1, c=2, b=0.1, d=0.2$。\n\n为了便于进行定量误差分析，采用了构造解法（Method of Manufactured Solutions）。我们指定精确解析解为 $u_e(x) = \\sin(\\pi x)$ 和 $v_e(x) = \\sin(2\\pi x)$，这些解能方便地满足边界条件。然后，通过将这些精确解代回控制方程，导出源项 $s_u(x)$ 和 $s_v(x)$：\n$$\ns_u(x) = -(-\\pi^2 \\sin(\\pi x)) + a \\sin(\\pi x) + b \\sin(2\\pi x) = \\pi^2 \\sin(\\pi x) + a \\sin(\\pi x) + b \\sin(2\\pi x)\n$$\n$$\ns_v(x) = -(-(2\\pi)^2 \\sin(2\\pi x)) + c \\sin(2\\pi x) + d \\sin(\\pi x) = (2\\pi)^2 \\sin(2\\pi x) + c \\sin(2\\pi x) + d \\sin(\\pi x)\n$$\n有了这些源项，该连续问题便有了一个已知的唯一解，从而提供了一个基准，我们的数值解可以与之进行比较。\n\n### 2. 数值离散化与求解策略\n\n连续域使用一个包含 $N$ 个点的均匀网格进行离散化，$x_i = i \\cdot h$，其中 $i=0, 1, \\dots, N-1$，网格间距为 $h=1/(N-1)$。内部网格点的索引从 $i=1$ 到 $N-2$。\n\n二阶导数项 $-u''$ 和 $-v''$ 使用二阶精度的中心有限差分格式进行近似。对于一个内部网格点 $x_i$，其近似为：\n$$\n-u''(x_i) \\approx \\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2}\n$$\n其中 $u_i$ 是 $u(x_i)$ 的数值近似。将此应用于每个内部点 $i$ 的第一个偏微分方程，可以得到一个线性方程组：\n$$\n\\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2} + a u_i + b v_i = (s_u)_i\n$$\n对 $u$ 场的项进行重新整理，使我们能够以矩阵形式表示离散系统。设 $\\mathbf{u}$ 是未知值向量 $[u_1, u_2, \\dots, u_{N-2}]^T$。$u$ 的解耦算子可以写成一个矩阵 $A$，使得方程变为 $A\\mathbf{u} + b\\mathbf{v} = \\mathbf{s}_u$。矩阵 $A$ 是一个 $(N-2) \\times (N-2)$ 的三对角矩阵，其对角线元素为 $(2/h^2 + a)$，非对角线元素为 $-1/h^2$。由于反应系数 $a=1$ 是正数，矩阵 $A$ 是严格对角占优的，这保证了其可逆性以及数值求解器的稳定性。同样的构造方法可以得到用于 $v$ 场的矩阵 $C$，由于 $c=2 > 0$，该矩阵也是三对角的且严格对角占优。\n\n完全耦合的离散系统是一个分块矩阵系统：\n$$\n\\begin{pmatrix} A  \\mathrm{diag}(b) \\\\ \\mathrm{diag}(d)  C \\end{pmatrix} \\begin{pmatrix} \\mathbf{u} \\\\ \\mathbf{v} \\end{pmatrix} = \\begin{pmatrix} \\mathbf{s}_u \\\\ \\mathbf{s}_v \\end{pmatrix}\n$$\n为求解该系统，采用分块 Gauss-Seidel 迭代格式。从一个初始猜测（通常为 $\\mathbf{u}^{(0)}=\\mathbf{0}$ 和 $\\mathbf{v}^{(0)}=\\mathbf{0}$）开始，该格式通过依次求解两个较小的解耦系统进行迭代（$k=0, 1, 2, \\dots$）：\n1.  **求解** $\\mathbf{u}^{(k+1)}$: $A\\,\\mathbf{u}^{(k+1)} = \\mathbf{s}_u - b\\,\\mathbf{v}^{(k)}$\n2.  **求解** $\\mathbf{v}^{(k+1)}$: $C\\,\\mathbf{v}^{(k+1)} = \\mathbf{s}_v - d\\,\\mathbf{u}^{(k+1)}$\n\n在每个步骤中，都会求解一个三对角线性系统。这可以通过使用专门的算法（如 Thomas 算法）或库函数（如 `scipy.linalg.solve_banded`）来高效地完成。迭代持续进行，直到连续迭代值之间的变化量小于一个指定的容差 $\\mathrm{tol}$（用离散 $L^2$-范数度量）：\n$$\n\\| (\\mathbf{u}^{(k+1)} - \\mathbf{u}^{(k)}, \\mathbf{v}^{(k+1)} - \\mathbf{v}^{(k)}) \\|_{2,h} = \\left( h \\sum_{i=1}^{N-2} (u_i^{(k+1)} - u_i^{(k)})^2 + h \\sum_{i=1}^{N-2} (v_i^{(k+1)} - v_i^{(k)})^2 \\right)^{1/2} \\le \\mathrm{tol}\n$$\n\n### 3. 误差分析与实验设计\n\n目标是区分最终数值解中的两种误差来源：\n1.  **离散化误差 ($E_{\\mathrm{disc}}$)**：这种误差源于用有限差分公式近似连续微分算子。对于所使用的二阶格式，我们期望该误差随网格间距呈二次方减小，即 $E_{\\mathrm{disc}} \\propto h^2$。\n2.  **迭代误差 ($E_{\\mathrm{iter}}$)**：这种误差是由于在迭代式 Gauss-Seidel 求解器完全收敛到离散代数系统的精确解之前就终止了迭代。该误差由容差 $\\mathrm{tol}$ 控制。\n\n总误差 $E_{\\mathrm{tot}}$ 是这些贡献之和：$E_{\\mathrm{tot}}(h,\\mathrm{tol}) \\approx E_{\\mathrm{disc}}(h) + E_{\\mathrm{iter}}(h,\\mathrm{tol})$。如果在细化网格（即 $h \\to 0$）的同时保持容差 $\\mathrm{tol}$ 不变，离散化误差 $E_{\\mathrm{disc}}(h)$ 将会减小。然而，迭代误差 $E_{\\mathrm{iter}}(h,\\mathrm{tol})$ 将大致保持不变，最终成为总误差的主要分量。这种现象被称为**误差掩盖** (error masking)，它会阻止观测到的收敛率达到其理论渐进值 $p=2$。\n\n为证明这一点，在一系列网格（$N \\in \\{33, 65, 129\\}$）上进行了三个数值实验：\n-   **情况 A (严格容差)**：当 $\\mathrm{tol} = 10^{-12}$ 时，迭代误差被降至可忽略的水平。总误差 $E_{\\mathrm{tot}}$ 应主要由离散化误差 $E_{\\mathrm{disc}}$ 主导，观测到的精度阶 $p_{\\mathrm{obs}}$ 应接近理论值 $2$。\n-   **情况 B (宽松容差)**：当 $\\mathrm{tol} = 10^{-4}$ 时，迭代误差是显著的。在粗网格上，它可能小于离散化误差，但在细网格上，它将占主导地位，导致 $p_{\\mathrm{obs}}$ 显著降到 $2$ 以下。\n-   **情况 C (迭代不足)**：仅进行一次迭代，解远未收敛。由此产生的误差很大，“精度阶”的计算预计不会产生有意义的值，这突显了充分迭代的重要性。\n\n观测到的精度阶是根据两个最细网格（$N_2=65, N_3=129$）上的总误差，使用以下公式计算的：\n$$\np_{\\mathrm{obs}} = \\frac{\\ln\\left( E_{\\mathrm{tot}}(h_2,\\mathrm{tol}) / E_{\\mathrm{tot}}(h_3,\\mathrm{tol}) \\right)}{\\ln\\left( h_2 / h_3 \\right)}\n$$\n最后，对于最细的网格，通过将宽松容差解（情况 B）与严格容差解（情况 A，作为精确离散解的代理）进行比较，来直接估计迭代误差。这个估计的迭代误差与宽松情况下总误差的比值 $r_{\\mathrm{fine}}$，量化了误差掩盖的程度。\n\n实现过程将通过系统地运行这些情况、计算误差并推导出最终输出所需的指定量来进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef run_simulation(N, tol, max_iter):\n    \"\"\"\n    Solves the coupled reaction-diffusion system for a given grid size,\n    tolerance, and max iterations.\n    \n    Args:\n        N (int): Number of grid points (including boundaries).\n        tol (float): Convergence tolerance for the Gauss-Seidel iteration.\n        max_iter (int): Maximum number of Gauss-Seidel iterations.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray, float]: Tuple containing the final solution\n        vector u, the final solution vector v, and the total L2 error.\n    \"\"\"\n    # 1. Setup grid and parameters\n    h = 1.0 / (N - 1)\n    x = np.linspace(0, 1, N)\n    x_int = x[1:-1]  # Interior points\n    num_int_pts = N - 2\n    \n    # Coefficients from problem statement\n    a, c = 1.0, 2.0\n    b, d = 0.1, 0.2\n    \n    # 2. Manufactured solution and source terms on the interior grid\n    pi = np.pi\n    u_exact_int = np.sin(pi * x_int)\n    v_exact_int = np.sin(2 * pi * x_int)\n    \n    s_u_int = pi**2 * u_exact_int + a * u_exact_int + b * v_exact_int\n    s_v_int = (2*pi)**2 * v_exact_int + c * v_exact_int + d * u_exact_int\n    \n    # 3. Construct uncoupled operators A and C in banded format for SciPy\n    # The banded format for a tridiagonal matrix (l=1, u=1) requires 3 rows:\n    # row 0: upper diagonal (shifted left)\n    # row 1: main diagonal\n    # row 2: lower diagonal (shifted right)\n    \n    # Matrix A for -u'' + a*u\n    A_banded = np.zeros((3, num_int_pts))\n    A_banded[0, 1:] = -1.0 / h**2\n    A_banded[1, :]  = 2.0 / h**2 + a\n    A_banded[2, :-1] = -1.0 / h**2\n    \n    # Matrix C for -v'' + c*v\n    C_banded = np.zeros((3, num_int_pts))\n    C_banded[0, 1:] = -1.0 / h**2\n    C_banded[1, :]  = 2.0 / h**2 + c\n    C_banded[2, :-1] = -1.0 / h**2\n    \n    # 4. Partitioned Gauss-Seidel Iteration\n    u_k = np.zeros(num_int_pts)\n    v_k = np.zeros(num_int_pts)\n    \n    for k in range(max_iter):\n        u_prev = u_k.copy()\n        v_prev = v_k.copy()\n        \n        # Solve for u^(k+1)\n        rhs_u = s_u_int - b * v_k\n        u_k = solve_banded((1, 1), A_banded, rhs_u)\n        \n        # Solve for v^(k+1)\n        rhs_v = s_v_int - d * u_k\n        v_k = solve_banded((1, 1), C_banded, rhs_v)\n        \n        # Check for convergence\n        diff_u = u_k - u_prev\n        diff_v = v_k - v_prev\n        norm_diff = np.sqrt(h * (np.sum(diff_u**2) + np.sum(diff_v**2)))\n        \n        if norm_diff = tol:\n            break\n            \n    # 5. Calculate total error against the exact manufactured solution\n    err_u = u_k - u_exact_int\n    err_v = v_k - v_exact_int\n    total_error = np.sqrt(h * (np.sum(err_u**2) + np.sum(err_v**2)))\n    \n    return u_k, v_k, total_error\n\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiments and compute the final results.\n    \"\"\"\n    # Define test parameters\n    resolutions = [33, 65, 129]\n    cases = {\n        'A': {'tol': 1e-12, 'max_iter': 500},\n        'B': {'tol': 1e-4,  'max_iter': 500},\n        'C': {'tol': 1e-4,  'max_iter': 1}  # tol is arbitrary for 1 iteration\n    }\n    \n    # Store results from all runs\n    results_data = {}\n    \n    # Run simulations for all cases and resolutions\n    for case_name, params in cases.items():\n        results_data[case_name] = {}\n        for N in resolutions:\n            u, v, error = run_simulation(N, params['tol'], params['max_iter'])\n            results_data[case_name][N] = {'u': u, 'v': v, 'error': error}\n    \n    # ---------- Calculate Final Outputs ----------\n    \n    # 1. Observed order of accuracy (p_obs) for each case\n    h_values = {N: 1.0 / (N - 1) for N in resolutions}\n    p_obs = {}\n    for case_name in cases:\n        err_h2 = results_data[case_name][65]['error']\n        err_h3 = results_data[case_name][129]['error']\n        h2 = h_values[65]\n        h3 = h_values[129]\n        # p_obs = log(E2/E3) / log(h2/h3) where h2/h3 = 2\n        p_obs[case_name] = np.log(err_h2 / err_h3) / np.log(2.0)\n        \n    pA = p_obs['A']\n    pB = p_obs['B']\n    pC = p_obs['C']\n    \n    # 2. Ratio r_fine for Case B at N=129\n    N_fine = 129\n    h_fine = h_values[N_fine]\n    \n    # 'tight' solution is from Case A, 'loose' is from Case B\n    u_tight = results_data['A'][N_fine]['u']\n    v_tight = results_data['A'][N_fine]['v']\n    u_loose = results_data['B'][N_fine]['u']\n    v_loose = results_data['B'][N_fine]['v']\n    \n    # Estimate iteration error as difference between loose and tight solutions\n    diff_u_iter = u_loose - u_tight\n    diff_v_iter = v_loose - v_tight\n    iter_err_est = np.sqrt(h_fine * (np.sum(diff_u_iter**2) + np.sum(diff_v_iter**2)))\n    \n    # Total error for the loose case at the finest grid\n    total_err_loose_fine = results_data['B'][N_fine]['error']\n    \n    r_fine = iter_err_est / total_err_loose_fine\n\n    # 3. Boolean checks\n    # Check if tight-tolerance order is close to theoretical value of 2\n    bool_A = 1.8 = pA = 2.2\n    # Check if error masking is observed in Case B\n    bool_B = (pB  1.0) and (r_fine > 0.5)\n\n    # Compile final results into a list\n    final_list = [pA, pB, pC, r_fine, bool_A, bool_B]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_list))}]\")\n\nsolve()\n```"
        }
    ]
}