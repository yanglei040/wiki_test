{
    "hands_on_practices": [
        {
            "introduction": "The most direct way to impose a known value at a boundary—a Dirichlet condition—is through a technique known as strong enforcement. This practice is fundamental in collocation methods, where the goal is to directly substitute the known boundary information into the system of algebraic equations. In this exercise , you will first derive the justification for this common row-replacement technique and then implement it to solve a boundary value problem, gaining hands-on experience with one of the most common methods for handling Dirichlet data.",
            "id": "3379368",
            "problem": "Consider spectral collocation on the interval $[-1,1]$ using Chebyshev–Gauss–Lobatto points. Let $N \\in \\mathbb{N}$ be the polynomial degree, and define the collocation nodes $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$ for $j=0,1,\\dots,N$. Define the Chebyshev cardinal basis $\\ell_j(x)$ as the Lagrange interpolating polynomials satisfying $\\ell_j(x_k) = \\delta_{jk}$ for all $j,k \\in \\{0,1,\\dots,N\\}$. The spectral differentiation matrix $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ is defined by the property that for any function $u$ interpolated at the nodes, the nodal derivative $(u')_i$ is approximated by $(Du)_i = \\sum_{j=0}^N D_{ij} u_j$, where $u_j = u(x_j)$.\n\nYou are to analyze and implement the enforcement of Dirichlet boundary conditions by replacing boundary rows in the collocation matrix for a second-order linear ordinary differential equation. Consider the boundary value problem\n$$\n-u''(x) + \\alpha\\, u(x) = f(x), \\quad x \\in (-1,1),\n$$\nwith Dirichlet boundary conditions\n$$\nu(-1) = u_L, \\quad u(1) = u_R,\n$$\nwhere $\\alpha \\ge 0$ is a given parameter. The spectral collocation discretization uses the second differentiation matrix $D^{(2)} = D^2$ to approximate $u''(x)$ at the nodes as $(D^{(2)} u)_i$, for $i=0,1,\\dots,N$. The discrete operator matrix $A \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ is\n$$\nA = -D^{(2)} + \\alpha I,\n$$\nand the discrete right-hand side vector is $b$ with entries $b_i = f(x_i)$. To enforce Dirichlet boundary conditions strongly, replace the first and last rows of $A$ by rows that enforce $u_0 = u_R$ and $u_N = u_L$ exactly, and set the corresponding entries of $b$ to $u_R$ and $u_L$, respectively.\n\nStarting from the fundamental base of polynomial interpolation on Chebyshev–Gauss–Lobatto points and the definition of the spectral differentiation matrix via Lagrange cardinal functions, derive why and how replacing the boundary rows in $A$ enforces the Dirichlet conditions consistently while preserving the interior collocation equations. Then implement the resulting numerical scheme.\n\nYour program must:\n- Construct the Chebyshev–Gauss–Lobatto nodes $x_j$, the first differentiation matrix $D$, and the second differentiation matrix $D^{(2)} = D D$.\n- Assemble the discrete operator $A = -D^{(2)} + \\alpha I$.\n- Enforce Dirichlet boundary conditions by replacing the first and last rows of $A$ as described, and set the corresponding entries of the right-hand side $b$.\n- Solve the linear system $A u = b$ for the nodal values $u_j$.\n- Compute the maximum nodal error $E = \\max_{0 \\le j \\le N} |u_j - u(x_j)|$ and the boundary residual $B = \\max\\big(|u_0 - u_R|,\\,|u_N - u_L|\\big)$.\n\nUse the following test suite, where each test case specifies $(N,\\alpha,u(x))$ and the derived $f(x) = -u''(x) + \\alpha u(x)$ and boundary values $u_L = u(-1)$, $u_R = u(1)$:\n- Test case $1$: $N=2$, $\\alpha=0$, $u(x) = 1 - x^2$. Then $u''(x) = -2$, so $f(x) = -(-2) + 0\\cdot u(x) = 2$, $u_L = u(-1) = 0$, $u_R = u(1) = 0$.\n- Test case $2$: $N=8$, $\\alpha=0$, $u(x) = \\sin\\left(\\frac{\\pi}{2}(x+1)\\right)$. Then $u''(x) = -\\left(\\frac{\\pi}{2}\\right)^2 \\sin\\left(\\frac{\\pi}{2}(x+1)\\right)$, so $f(x) = -u''(x) = \\left(\\frac{\\pi}{2}\\right)^2 \\sin\\left(\\frac{\\pi}{2}(x+1)\\right)$, $u_L = 0$, $u_R = 0$.\n- Test case $3$: $N=16$, $\\alpha=1$, $u(x) = e^{x}(1 - x^2)$. Then $u''(x) = e^{x}(-x^2 - 4x - 1)$, so $f(x) = -u''(x) + \\alpha u(x) = e^{x}(x^2 + 4x + 1) + e^{x}(1 - x^2)$, $u_L = u(-1) = 0$, $u_R = u(1) = 0$.\n- Test case $4$: $N=32$, $\\alpha=10$, $u(x) = \\cosh(2x) - \\cosh(2)\\,x^2$. Then $u''(x) = 4\\cosh(2x) - 2\\cosh(2)$, so $f(x) = -u''(x) + \\alpha u(x) = -4\\cosh(2x) + 2\\cosh(2) + 10\\left(\\cosh(2x) - \\cosh(2)\\,x^2\\right)$, $u_L = 0$, $u_R = 0$.\n- Test case $5$: $N=64$, $\\alpha=0$, $u(x) = \\sin\\left(\\frac{\\pi}{2}(x+1)\\right)$, same as test case $2$ but with higher resolution.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result should be a two-element list $[E,B]$ of floating-point numbers for that case, and the overall output should be a list of these lists in the order of the test suite, for example, $[[E_1,B_1],[E_2,B_2],\\dots]$.",
            "solution": "The problem requires the derivation and implementation of a spectral collocation method for solving a second-order linear ordinary differential equation (ODE) with Dirichlet boundary conditions. The core of the task is to justify the procedure of replacing rows in the discrete operator matrix to enforce these boundary conditions.\n\nLet the given boundary value problem be\n$$\n-u''(x) + \\alpha u(x) = f(x), \\quad x \\in (-1,1)\n$$\nwith boundary conditions\n$$\nu(-1) = u_L, \\quad u(1) = u_R.\n$$\nIn the spectral collocation method, we seek an approximate solution in the form of a single global polynomial, $p_N(x)$, of degree $N$. This polynomial is uniquely defined by its values at a set of $N+1$ distinct collocation points. Here, we use the Chebyshev-Gauss-Lobatto (CGL) nodes, given by $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$ for $j=0, 1, \\dots, N$. Note that these points include the boundaries of the interval: $x_0 = 1$ and $x_N = -1$.\n\nThe polynomial interpolant $p_N(x)$ passing through the points $(x_j, u_j)$ can be written in the Lagrange basis as:\n$$\np_N(x) = \\sum_{j=0}^{N} u_j \\ell_j(x),\n$$\nwhere $u_j$ is the approximation to $u(x_j)$, and $\\ell_j(x)$ are the Lagrange cardinal polynomials satisfying $\\ell_j(x_k) = \\delta_{jk}$.\n\nThe collocation method enforces the governing differential equation at the *interior* collocation points, i.e., for $i=1, \\dots, N-1$:\n$$\n-p_N''(x_i) + \\alpha p_N(x_i) = f(x_i).\n$$\nThe derivatives of the interpolating polynomial at the nodes can be computed using the spectral differentiation matrix, $D$. The vector of first derivatives at the nodes, $p_N'(\\mathbf{x})$, is given by the matrix-vector product $D\\mathbf{u}$, where $\\mathbf{u} = [u_0, u_1, \\dots, u_N]^T$. Consequently, the second derivatives are given by $p_N''(\\mathbf{x}) = D(D\\mathbf{u}) = D^2\\mathbf{u} = D^{(2)}\\mathbf{u}$.\n\nSubstituting the matrix representation of the derivatives into the collocation equations for the interior nodes ($i=1, \\dots, N-1$), we get:\n$$\n- \\sum_{j=0}^{N} (D^{(2)})_{ij} u_j + \\alpha u_i = f(x_i).\n$$\nThese $N-1$ equations can be expressed as the interior rows of a full matrix system. Let $A = -D^{(2)} + \\alpha I$ be the $(N+1) \\times (N+1)$ discrete operator matrix, where $I$ is the identity matrix. Let $\\mathbf{b}$ be the right-hand side vector with entries $b_i = f(x_i)$. The interior collocation equations are then equivalent to:\n$$\n(A\\mathbf{u})_i = b_i \\quad \\text{for } i=1, \\dots, N-1.\n$$\nThis gives us $N-1$ linear equations for the $N+1$ unknown nodal values $u_0, \\dots, u_N$. The system is underdetermined. We need two more equations, which are provided by the boundary conditions.\n\nThis leads to the central question of how to incorporate the boundary conditions $u(1)=u_R$ and $u(-1)=u_L$. In our nodal basis, since $x_0=1$ and $x_N=-1$, these conditions translate directly to algebraic constraints on the unknown vector $\\mathbf{u}$:\n$$\nu_0 = u_R \\\\\nu_N = u_L\n$$\nThe original system of equations obtained by collocating the ODE at all $N+1$ points, $(A\\mathbf{u})_i = b_i$ for $i=0, \\dots, N$, is not what we solve. The rows for $i=0$ and $i=N$ represent the ODE being enforced at the boundary. However, the solution at the boundary is not governed by the ODE itself but is *prescribed* by the boundary conditions. Therefore, we must discard the $0$-th and $N$-th rows of the original collocation system and replace them with equations that enforce the boundary constraints.\n\nThis is the justification for the row-replacement method. We replace the equations that are not relevant (the ODE at the boundary) with the equations that are required (the Dirichlet conditions).\n\nThe \"how\" of this replacement is as follows:\n1.  To enforce the condition $u_0 = u_R$, we need a linear equation that is satisfied if and only if $u_0 = u_R$. The simplest such equation is $1 \\cdot u_0 + 0 \\cdot u_1 + \\dots + 0 \\cdot u_N = u_R$. This corresponds to replacing the first row (index $0$) of the matrix $A$ with the vector $[1, 0, \\dots, 0]$ and setting the first element of the right-hand side vector $\\mathbf{b}$ to $u_R$.\n\n2.  Similarly, to enforce $u_N = u_L$, we use the equation $0 \\cdot u_0 + \\dots + 0 \\cdot u_{N-1} + 1 \\cdot u_N = u_L$. This corresponds to replacing the last row (index $N$) of the matrix $A$ with $[0, \\dots, 0, 1]$ and setting the last element of $\\mathbf{b}$ to $u_L$.\n\nThe modified linear system, let's call it $A_{mod} \\mathbf{u} = \\mathbf{b}_{mod}$, now looks like this:\n$$\n\\begin{pmatrix}\n1 & 0 & 0 & \\dots & 0 \\\\\nA_{1,0} & A_{1,1} & A_{1,2} & \\dots & A_{1,N} \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\nA_{N-1,0} & A_{N-1,1} & A_{N-1,2} & \\dots & A_{N-1,N} \\\\\n0 & 0 & 0 & \\dots & 1\n\\end{pmatrix}\n\\begin{pmatrix} u_0 \\\\ u_1 \\\\ \\vdots \\\\ u_{N-1} \\\\ u_N \\end{pmatrix}\n=\n\\begin{pmatrix} u_R \\\\ f(x_1) \\\\ \\vdots \\\\ f(x_{N-1}) \\\\ u_L \\end{pmatrix}\n$$\nThis is a full-rank, $(N+1) \\times (N+1)$ linear system. Solving it yields the unique vector of nodal values $\\mathbf{u}$ that satisfies both the differential equation at the interior collocation points and the Dirichlet conditions at the boundaries. This procedure is consistent because it correctly combines the governing physics/mathematics of the interior domain with the specified constraints at the boundaries.\n\nFor implementation, the first differentiation matrix $D$ on CGL nodes has well-known explicit formulas:\n$$\nD_{jk} = \\begin{cases}\n    \\frac{c_j}{c_k} \\frac{(-1)^{j+k}}{x_j - x_k} & j \\neq k \\\\\n    -\\frac{x_j}{2(1-x_j^2)} & j=k, \\quad j \\in \\{1,\\dots,N-1\\} \\\\\n    \\frac{2N^2+1}{6} & j=k=0 \\\\\n    -\\frac{2N^2+1}{6} & j=k=N\n\\end{cases}\n$$\nwhere the weights are $c_j=1$ for $j \\in \\{1,\\dots,N-1\\}$ and $c_0=c_N=2$. We first construct $D$, then compute $D^{(2)} = D \\cdot D$, assemble the original operator $A = -D^{(2)} + \\alpha I$, and finally modify $A$ and $\\mathbf{b}$ as described above before solving the linear system. The boundary residual $B$ should be zero up to machine precision, as the conditions are enforced strongly.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the Chebyshev-Gauss-Lobatto nodes and the corresponding\n    first differentiation matrix.\n\n    Args:\n        N (int): The polynomial degree.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The array of N+1 Chebyshev nodes.\n            - np.ndarray: The (N+1)x(N+1) differentiation matrix D.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0]), np.array([[0.0]])\n    \n    # Chebyshev-Gauss-Lobatto nodes\n    j = np.arange(N + 1)\n    x = np.cos(np.pi * j / N)\n    \n    # c_j coefficients\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[N] = 2.0\n    \n    D = np.zeros((N + 1, N + 1))\n    \n    # Off-diagonal entries\n    for i in range(N + 1):\n        for k in range(N + 1):\n            if i != k:\n                D[i, k] = (c[i] / c[k]) * ((-1)**(i + k)) / (x[i] - x[k])\n    \n    # Diagonal entries\n    # For interior points\n    for i in range(1, N):\n        D[i, i] = -x[i] / (2 * (1 - x[i]**2))\n        \n    # For boundary points\n    D[0, 0] = (2 * N**2 + 1) / 6.0\n    D[N, N] = -(2 * N**2 + 1) / 6.0\n    \n    return x, D\n\ndef solve():\n    \"\"\"\n    Solves the BVP using spectral collocation for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 2, \"alpha\": 0.0,\n            \"u_func\": lambda x: 1 - x**2,\n            \"upp_func\": lambda x: -2.0 + 0 * x,\n            \"uL\": 0.0, \"uR\": 0.0\n        },\n        {\n            \"N\": 8, \"alpha\": 0.0,\n            \"u_func\": lambda x: np.sin(np.pi / 2 * (x + 1)),\n            \"upp_func\": lambda x: -(np.pi / 2)**2 * np.sin(np.pi / 2 * (x + 1)),\n            \"uL\": 0.0, \"uR\": 0.0\n        },\n        {\n            \"N\": 16, \"alpha\": 1.0,\n            \"u_func\": lambda x: np.exp(x) * (1 - x**2),\n            \"upp_func\": lambda x: np.exp(x) * (-x**2 - 4*x - 1),\n            \"uL\": 0.0, \"uR\": 0.0\n        },\n        {\n            \"N\": 32, \"alpha\": 10.0,\n            \"u_func\": lambda x: np.cosh(2*x) - np.cosh(2) * x**2,\n            \"upp_func\": lambda x: 4*np.cosh(2*x) - 2*np.cosh(2),\n            \"uL\": 0.0, \"uR\": 0.0\n        },\n        {\n            \"N\": 64, \"alpha\": 0.0,\n            \"u_func\": lambda x: np.sin(np.pi / 2 * (x + 1)),\n            \"upp_func\": lambda x: -(np.pi / 2)**2 * np.sin(np.pi / 2 * (x + 1)),\n            \"uL\": 0.0, \"uR\": 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        alpha = case[\"alpha\"]\n        u_func = case[\"u_func\"]\n        upp_func = case[\"upp_func\"]\n        uL = case[\"uL\"]\n        uR = case[\"uR\"]\n\n        # 1. Construct nodes and differentiation matrices\n        x, D = chebyshev_diff_matrix(N)\n        D2 = D @ D\n\n        # 2. Assemble the discrete operator A and RHS b\n        I = np.eye(N + 1)\n        A = -D2 + alpha * I\n        \n        # f(x) = -u''(x) + alpha*u(x)\n        f = -upp_func(x) + alpha * u_func(x)\n        b = f.copy()\n\n        # 3. Enforce Dirichlet boundary conditions by row replacement\n        # Note: x_0 = 1, x_N = -1\n        # First row (i=0) for u(1) = uR\n        A[0, :] = 0.0\n        A[0, 0] = 1.0\n        b[0] = uR\n\n        # Last row (i=N) for u(-1) = uL\n        A[N, :] = 0.0\n        A[N, N] = 1.0\n        b[N] = uL\n\n        # 4. Solve the linear system\n        u_numerical = np.linalg.solve(A, b)\n\n        # 5. Compute error metrics\n        u_exact = u_func(x)\n        \n        # Max nodal error\n        E = np.max(np.abs(u_numerical - u_exact))\n        \n        # Boundary residual\n        # Check u(1) (at index 0) and u(-1) (at index N)\n        B = np.max([np.abs(u_numerical[0] - uR), np.abs(u_numerical[N] - uL)])\n        \n        results.append([E, B])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{e},{b}]\" for e, b in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the principles of strong enforcement, we now turn to boundary conditions involving derivatives, namely the Neumann and Robin conditions. This practice demonstrates how the same row-replacement strategy used for Dirichlet conditions can be powerfully adapted to handle these more complex constraints within a spectral collocation framework. Through this exercise , you will implement a solver for a problem with Robin conditions, verify its spectral accuracy, and explore the important special case where Robin conditions reduce to pure Neumann conditions.",
            "id": "3379336",
            "problem": "Implement a Chebyshev collocation solver for a one-dimensional linear boundary value problem with Robin boundary conditions and use it to assess spectral accuracy. Begin from the following fundamental base: the definition of Chebyshev–Gauss–Lobatto (CGL) nodes, the construction of the Chebyshev first-derivative matrix from those nodes, and the principle of enforcing boundary conditions by replacing equations in a collocation system.\n\nConsider the ordinary differential equation (ODE)\n$$\n-\\,u''(x) + \\lambda\\,u(x) = f(x), \\quad x \\in [-1,1],\n$$\nsubject to Robin boundary conditions at both endpoints,\n$$\nu'(1) + \\alpha_L\\,u(1) = g_L, \\qquad u'(-1) + \\alpha_R\\,u(-1) = g_R.\n$$\nYou will discretize using a spectral collocation method on the Chebyshev–Gauss–Lobatto (CGL) nodes\n$$\nx_j = \\cos\\!\\left(\\frac{\\pi j}{N}\\right), \\quad j=0,1,\\dots,N,\n$$\nwhich include the endpoints $x_0=1$ and $x_N=-1$. Let $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ be the Chebyshev first-derivative differentiation matrix on these nodes, and let $D^{(2)} = D^2$ denote the second-derivative matrix. Form the linear system for the vector of nodal values $\\mathbf{u} = \\big(u(x_0),\\dots,u(x_N)\\big)^\\top$:\n- For interior indices $i=1,2,\\dots,N-1$, enforce the ODE by collocation:\n$$\n\\left(-D^{(2)} + \\lambda I\\right)_{i,:}\\,\\mathbf{u} = f(x_i).\n$$\n- At the first and last indices, replace the equations to enforce the Robin conditions in discrete form:\n$$\n\\big(D_{0,:} + \\alpha_L\\,\\mathbf{e}_0^\\top\\big)\\,\\mathbf{u} = g_L, \\qquad \\big(D_{N,:} + \\alpha_R\\,\\mathbf{e}_N^\\top\\big)\\,\\mathbf{u} = g_R,\n$$\nwhere $\\mathbf{e}_0$ and $\\mathbf{e}_N$ are the standard basis vectors in $\\mathbb{R}^{N+1}$.\n\nTo make the problem fully specified and testable, define $f$, $g_L$, and $g_R$ from a chosen smooth exact solution $u_{\\text{exact}}$ by\n$$\nf(x) = -u_{\\text{exact}}''(x) + \\lambda\\,u_{\\text{exact}}(x), \\quad g_L = u_{\\text{exact}}'(1) + \\alpha_L\\,u_{\\text{exact}}(1), \\quad g_R = u_{\\text{exact}}'(-1) + \\alpha_R\\,u_{\\text{exact}}(-1).\n$$\nFor each test case, compute the maximum-norm error\n$$\nE_N = \\max_{0 \\le j \\le N} \\left|u_{\\text{num}}(x_j) - u_{\\text{exact}}(x_j)\\right|,\n$$\nfor several values of $N$, and then assess spectral accuracy by fitting a straight line to $\\log E_N$ as a function of $N$ via least squares. Specifically, given a set of sizes $\\{N_k\\}$ and corresponding errors $\\{E_{N_k}\\}$, compute the slope $s$ that minimizes\n$$\n\\sum_k \\left(\\log E_{N_k} - (a + s\\,N_k)\\right)^2\n$$\nwith respect to $a$ and $s$, and report this fitted slope $s$. For exponential (spectral) convergence of the form $E_N \\approx C\\,\\rho^{-N}$ with $\\rho>1$, one expects $\\log E_N \\approx \\log C - N \\log \\rho$, so that the fitted slope $s \\approx -\\log \\rho$ is negative and bounded away from $0$ as $N$ grows.\n\nImplement the above and run it on the following three test cases. In each case, use the specified exact solution $u_{\\text{exact}}$, parameters $(\\lambda,\\alpha_L,\\alpha_R)$, and the list of $N$ values.\n\n- Test Case A (general Robin): \n  - $u_{\\text{exact}}(x) = e^{x} + \\cos(3x)$,\n  - $\\lambda = 1$, $\\alpha_L = 0.7$, $\\alpha_R = 1.3$,\n  - $N \\in \\{16,24,32,40\\}$.\n\n- Test Case B (Neumann limit as Robin with $\\alpha_L=\\alpha_R=0$):\n  - $u_{\\text{exact}}(x) = \\sinh(2x) + \\sin(5x)$,\n  - $\\lambda = 1$, $\\alpha_L = 0$, $\\alpha_R = 0$,\n  - $N \\in \\{16,24,32,40\\}$.\n\n- Test Case C (stiffer reaction and stronger Robin):\n  - $u_{\\text{exact}}(x) = \\cosh(x) + \\sin(2x)$,\n  - $\\lambda = 10$, $\\alpha_L = 5$, $\\alpha_R = 2$,\n  - $N \\in \\{16,32,48,64\\}$.\n\nYour program must:\n- Construct the CGL nodes and Chebyshev differentiation matrix $D$ for each $N$,\n- Assemble and solve the collocation system with Robin boundary conditions applied by replacing the first and last equations as specified,\n- Compute $E_N$ for each $N$ in each test case,\n- Fit the least-squares line to $\\log E_N$ as a function of $N$ and return the slope $s$ for each test case.\n\nFinal output format: Your program should produce a single line of output containing a comma-separated list of the three fitted slopes, in the order A, B, C, enclosed in square brackets, for example, $[s_A,s_B,s_C]$. Angles are not used, and there are no physical units to report. All numerical values in the output must be plain decimal numbers. The answer for each test case must be a float. The test suite thus consists of the three cases described above, and the output must aggregate their fitted slopes into the single required line.",
            "solution": "The user wants to implement a Chebyshev collocation solver for a one-dimensional linear boundary value problem with Robin boundary conditions.\n\n### 1. Problem Validation\n\nThe problem is subjected to a rigorous validation process before any attempt at a solution.\n\n#### Step 1: Extract Givens\n- **Governing Equation**: The ordinary differential equation (ODE) is $-\\,u''(x) + \\lambda\\,u(x) = f(x)$ for $x \\in [-1,1]$.\n- **Boundary Conditions (BCs)**: Robin conditions are specified at the endpoints:\n  - $u'(1) + \\alpha_L\\,u(1) = g_L$\n  - $u'(-1) + \\alpha_R\\,u(-1) = g_R$\n- **Discretization**: The domain is discretized using $N+1$ Chebyshev–Gauss–Lobatto (CGL) nodes: $x_j = \\cos(\\frac{\\pi j}{N})$ for $j=0,1,\\dots,N$.\n- **Numerical Method**: A spectral collocation method is to be used. The first-derivative operator is approximated by the Chebyshev differentiation matrix $D$, and the second-derivative by $D^{(2)} = D^2$. The vector of unknowns is $\\mathbf{u}$, representing the function values at the CGL nodes.\n- **System Assembly**: The linear system for $\\mathbf{u}$ is constructed as follows:\n  - For interior nodes ($i=1,\\dots,N-1$), the ODE is enforced: $\\left(-D^{(2)} + \\lambda I\\right)_{i,:}\\,\\mathbf{u} = f(x_i)$.\n  - The first equation (row $i=0$) is replaced to enforce the BC at $x_0=1$: $\\big(D_{0,:} + \\alpha_L\\,\\mathbf{e}_0^\\top\\big)\\,\\mathbf{u} = g_L$.\n  - The last equation (row $i=N$) is replaced to enforce the BC at $x_N=-1$: $\\big(D_{N,:} + \\alpha_R\\,\\mathbf{e}_N^\\top\\big)\\,\\mathbf{u} = g_R$.\n- **Verification (Method of Manufactured Solutions)**: The source term $f(x)$ and boundary data $g_L, g_R$ are defined based on a chosen exact solution $u_{\\text{exact}}(x)$:\n  - $f(x) = -u_{\\text{exact}}''(x) + \\lambda\\,u_{\\text{exact}}(x)$\n  - $g_L = u_{\\text{exact}}'(1) + \\alpha_L\\,u_{\\text{exact}}(1)$\n  - $g_R = u_{\\text{exact}}'(-1) + \\alpha_R\\,u_{\\text{exact}}(-1)$\n- **Error Analysis**: For each $N$ in a given sequence $\\{N_k\\}$, the maximum-norm error $E_N = \\max_{j} |u_{\\text{num}}(x_j) - u_{\\text{exact}}(x_j)|$ is computed.\n- **Convergence Rate**: Spectral accuracy is assessed by finding the slope $s$ of a least-squares line fitted to the points $(N_k, \\log E_{N_k})$.\n- **Test Cases**: Three specific test cases (A, B, C) are provided, each with a unique $u_{\\text{exact}}(x)$, parameters $(\\lambda, \\alpha_L, \\alpha_R)$, and a list of $N$ values.\n\n#### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is a standard, canonical exercise in numerical analysis for partial differential equations. Spectral collocation methods using Chebyshev polynomials are a foundational topic in scientific computing. The problem is mathematically sound and based on established principles.\n- **Well-Posed**: The problem is well-posed. It describes the complete construction of a square linear system of equations. For the given Helmholtz-type equation with Robin boundary conditions (and the specific parameters), a unique solution to the continuous problem exists. The spectral collocation method, when implemented as described, yields a non-singular system matrix, thus ensuring a unique numerical solution.\n- **Objective**: The problem is stated with mathematical precision. All functions, parameters, and procedures are defined unambiguously.\n- **Completeness and Consistency**: The problem is self-contained and provides all necessary information to construct the solver and run the tests. The method of manufactured solutions ensures a consistent setup where the exact solution is known by construction. The notation for the boundary conditions ($L$ at $x=1$ and $R$ at $x=-1$) is unconventional but explicitly defined and must be followed.\n- **Feasibility**: The required computations, including the construction of differentiation matrices, solving linear systems, and performing a least-squares fit, are all standard and computationally feasible.\n\n#### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### 2. Solution Methodology\n\nThe solution involves implementing the Chebyshev collocation method as described. The overall process for each test case is as follows:\n\n1.  **Iterate through $N$ values**: For each polynomial degree $N$ specified in the test case, a numerical solution is computed.\n2.  **Construct Chebyshev Grid and Differentiation Matrix**: For a given $N$, the $N+1$ CGL nodes $x_j$ are generated. The corresponding $(N+1) \\times (N+1)$ first-derivative matrix, $D$, is constructed using a standard, numerically stable formula. The second-derivative matrix is then computed as $D^{(2)} = D^2$.\n3.  **Assemble the Linear System**: An $(N+1) \\times (N+1)$ matrix $A$ and a vector $\\mathbf{b}$ of size $N+1$ are assembled.\n    -   Initially, the matrix $A$ is set to $-D^{(2)} + \\lambda I$, representing the differential operator over all nodes.\n    -   The vector $\\mathbf{b}$ is populated with the values of the source function, $f(x_j) = -u_{\\text{exact}}''(x_j) + \\lambda u_{\\text{exact}}(x_j)$, evaluated at the nodes.\n    -   The first row ($j=0$, corresponding to $x_0=1$) of $A$ and $\\mathbf{b}$ are replaced to enforce the Robin condition at $x=1$. The new row is derived from the discrete form of the boundary operator, $D_{0,:} + \\alpha_L \\mathbf{e}_0^\\top$. This means the first row of $A$ becomes the first row of $D$, with $\\alpha_L$ added to the diagonal element $A_{0,0}$. The first element of $\\mathbf{b}$ is set to $g_L = u_{\\text{exact}}'(1) + \\alpha_L u_{\\text{exact}}(1)$.\n    -   Similarly, the last row ($j=N$, corresponding to $x_N=-1$) is replaced to enforce the condition at $x=-1$. The last row of $A$ becomes the last row of $D$, with $\\alpha_R$ added to the diagonal element $A_{N,N}$. The last element of $\\mathbf{b}$ is set to $g_R = u_{\\text{exact}}'(-1) + \\alpha_R u_{\\text{exact}}(-1)$.\n4.  **Solve and Compute Error**: The linear system $A\\mathbf{u} = \\mathbf{b}$ is solved for the vector of numerical solution values $\\mathbf{u}$. The maximum absolute error $E_N$ between the numerical solution and the exact solution values at the nodes is calculated.\n5.  **Assess Convergence**: After computing the errors $\\{E_{N_k}\\}$ for all specified $\\{N_k\\}$, the natural logarithm of the errors, $\\{\\log E_{N_k}\\}$, is taken. A linear regression is performed on the points $(N_k, \\log E_{N_k})$ to find the best-fit line. The slope $s$ of this line is the measure of the exponential convergence rate. This slope is the final result for the test case.\n\nThis procedure is repeated for all three test cases, and the resulting slopes are collected.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a Chebyshev collocation solver for a 1D linear BVP with Robin boundary conditions,\n    and assesses its spectral accuracy.\n    \"\"\"\n\n    def chebyshev_cgl(N):\n        \"\"\"\n        Computes the Chebyshev-Gauss-Lobatto (CGL) nodes and the \n        first-derivative differentiation matrix.\n        \n        Args:\n            N (int): The polynomial degree. Number of nodes is N+1.\n            \n        Returns:\n            tuple: A tuple containing:\n                - x (np.ndarray): The N+1 CGL nodes.\n                - D (np.ndarray): The (N+1)x(N+1) differentiation matrix.\n        \"\"\"\n        if N == 0:\n            return np.array([0.0]), np.array([[0.0]])\n        \n        # CGL nodes\n        j = np.arange(N + 1)\n        x = np.cos(np.pi * j / N)\n        \n        # Assemble differentiation matrix D\n        c = np.ones(N + 1)\n        c[0] = 2.0\n        c[N] = 2.0\n        \n        # Off-diagonal entries\n        X = np.tile(x, (N + 1, 1))\n        dX = X - X.T\n        \n        # Formula: D_ij = c_i/c_j * (-1)^(i+j) / (x_i - x_j) for i != j\n        # We combine c_i and (-1)^i terms for a compact form\n        c_i_term = c * (-1)**j\n        D = (c_i_term[:, None] / c_i_term[None, :]) / (dX + np.eye(N + 1))\n        \n        # Diagonal entries (using the sum-to-zero property for stability)\n        D -= np.diag(np.sum(D, axis=1))\n        \n        return x, D\n\n    def compute_slope(u_exact, u_prime, u_double_prime, lambda_val, alpha_L, alpha_R, N_vals):\n        \"\"\"\n        Solves the BVP for a range of N, computes errors, and fits a line\n        to (N, log(error)) to find the convergence rate (slope).\n        \"\"\"\n        errors = []\n        for N in N_vals:\n            # Get nodes and differentiation matrices\n            x, D = chebyshev_cgl(N)\n            D2 = D @ D\n\n            # Assemble system matrix A and RHS vector b\n            # Start with the interior equation operator everywhere\n            A = -D2 + lambda_val * np.eye(N + 1)\n            f_vals = -u_double_prime(x) + lambda_val * u_exact(x)\n            b = f_vals.copy()\n\n            # Enforce boundary conditions by replacing rows\n            # Boundary at x = 1 (node j=0)\n            A[0, :] = D[0, :]\n            A[0, 0] += alpha_L\n            g_L = u_prime(1.0) + alpha_L * u_exact(1.0)\n            b[0] = g_L\n\n            # Boundary at x = -1 (node j=N)\n            A[-1, :] = D[-1, :]\n            A[-1, -1] += alpha_R\n            g_R = u_prime(-1.0) + alpha_R * u_exact(-1.0)\n            b[-1] = g_R\n            \n            # Solve the linear system\n            u_num = np.linalg.solve(A, b)\n            \n            # Compute the maximum norm error\n            u_ex_vals = u_exact(x)\n            error = np.max(np.abs(u_num - u_ex_vals))\n            errors.append(error)\n            \n        # Perform least-squares fit on log(error) vs N\n        log_errors = np.log(errors)\n        coeffs = np.polyfit(N_vals, log_errors, 1)\n        slope = coeffs[0]\n        \n        return slope\n\n    test_cases = [\n        # Test Case A\n        {\n            'u_exact': lambda x: np.exp(x) + np.cos(3 * x),\n            'u_prime': lambda x: np.exp(x) - 3 * np.sin(3 * x),\n            'u_double_prime': lambda x: np.exp(x) - 9 * np.cos(3 * x),\n            'lambda_val': 1.0, 'alpha_L': 0.7, 'alpha_R': 1.3,\n            'N_vals': [16, 24, 32, 40]\n        },\n        # Test Case B\n        {\n            'u_exact': lambda x: np.sinh(2 * x) + np.sin(5 * x),\n            'u_prime': lambda x: 2 * np.cosh(2 * x) + 5 * np.cos(5 * x),\n            'u_double_prime': lambda x: 4 * np.sinh(2 * x) - 25 * np.sin(5 * x),\n            'lambda_val': 1.0, 'alpha_L': 0.0, 'alpha_R': 0.0,\n            'N_vals': [16, 24, 32, 40]\n        },\n        # Test Case C\n        {\n            'u_exact': lambda x: np.cosh(x) + np.sin(2 * x),\n            'u_prime': lambda x: np.sinh(x) + 2 * np.cos(2 * x),\n            'u_double_prime': lambda x: np.cosh(x) - 4 * np.sin(2 * x),\n            'lambda_val': 10.0, 'alpha_L': 5.0, 'alpha_R': 2.0,\n            'N_vals': [16, 32, 48, 64]\n        }\n    ]\n\n    slopes = []\n    for case in test_cases:\n        slope = compute_slope(\n            u_exact=case['u_exact'],\n            u_prime=case['u_prime'],\n            u_double_prime=case['u_double_prime'],\n            lambda_val=case['lambda_val'],\n            alpha_L=case['alpha_L'],\n            alpha_R=case['alpha_R'],\n            N_vals=case['N_vals']\n        )\n        slopes.append(slope)\n        \n    print(f\"[{','.join(map(str, slopes))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "We now shift our perspective from the strong enforcement typical of collocation methods to the weak formulation that underpins Finite Element and Spectral Element Methods. In this framework, Neumann and Robin conditions arise naturally as boundary integrals from the integration-by-parts formula. This analytical exercise  tackles the practical challenges of implementing these conditions on curved geometries, requiring you to derive how the geometry's transformation Jacobian and normal vector are incorporated into the weak form. This provides crucial insight into the robust handling of boundary conditions in simulations on realistic, non-rectangular domains.",
            "id": "3379337",
            "problem": "Consider the scalar Poisson problem $-\\nabla \\cdot (\\nabla u) = f$ in a two-dimensional domain with a curved boundary segment that is part of an isoparametric spectral element. Let the boundary segment be the image of the reference edge parameter $\\xi \\in [-1,1]$ under the mapping $\\boldsymbol{x}(\\xi) = (x(\\xi), y(\\xi))$ defined by $x(\\xi) = \\xi$ and $y(\\xi) = 1 + \\varepsilon \\, P_{2}(\\xi)$, where $P_{2}(\\xi) = \\frac{3 \\xi^{2} - 1}{2}$ is the Legendre polynomial of degree $2$. The element is isoparametric, meaning the geometry and the solution approximation share the same polynomial order. Let the outward unit normal be defined by $\\boldsymbol{n}(\\xi) = \\frac{(-y'(\\xi), x'(\\xi))}{\\sqrt{(x'(\\xi))^{2} + (y'(\\xi))^{2}}}$ with $\\boldsymbol{t}(\\xi) = (x'(\\xi), y'(\\xi))$ the tangent, and the boundary line element be $ds = \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi$. Take a single test function on the boundary equal to $v(\\xi) = P_{2}(\\xi)$.\n\nStarting from the variational statement $\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega - \\int_{\\partial \\Omega} v \\, \\boldsymbol{n} \\cdot \\nabla u \\, ds = \\int_{\\Omega} f v \\, d\\Omega$, and the definitions of the isoparametric mapping and the outward unit normal, derive the parametric expression for the weak Neumann boundary contribution on the curved segment $\\Gamma$ in terms of the geometric derivatives $x'(\\xi)$ and $y'(\\xi)$, and show how the boundary Jacobian and the normal vector combine. Then, for a Robin boundary condition $\\boldsymbol{n} \\cdot \\nabla u + \\alpha u = r$ on $\\Gamma$, derive the net weak boundary contribution that replaces $-\\int_{\\Gamma} v \\, \\boldsymbol{n} \\cdot \\nabla u \\, ds$ in the variational statement. Use the following specific data to obtain closed-form values:\n- Choose $\\varepsilon = \\frac{1}{3}$ so that $y'(\\xi) = \\xi$ and hence $\\|\\boldsymbol{t}(\\xi)\\| = \\sqrt{1 + \\xi^{2}}$.\n- Let the exact solution be $u(x,y) = x^{2} + y^{3}$, so that $\\nabla u = (2x, 3y^{2})$.\n- For the Neumann condition, set $g(\\xi) := \\boldsymbol{n}(\\xi) \\cdot \\nabla u(\\boldsymbol{x}(\\xi))$ and compute the weak boundary contribution $I_{N} := \\int_{-1}^{1} v(\\xi) \\, g(\\xi) \\, \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi$ on $\\Gamma$.\n- For the Robin condition, take a constant $\\alpha = 2$ and define $r(\\xi) := \\boldsymbol{n}(\\xi) \\cdot \\nabla u(\\boldsymbol{x}(\\xi)) + \\alpha \\, u(\\boldsymbol{x}(\\xi))$. Compute the net weak boundary contribution $I_{R} := \\left(\\int_{-1}^{1} \\alpha \\, u(\\boldsymbol{x}(\\xi)) \\, v(\\xi) \\, \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi\\right) - \\left(\\int_{-1}^{1} r(\\xi) \\, v(\\xi) \\, \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi\\right)$.\n\nExpress the final numerical values $I_{N}$ and $I_{R}$ exactly (no rounding). Provide your final answer as a $1 \\times 2$ row matrix $\\begin{pmatrix} I_{N} & I_{R} \\end{pmatrix}$.",
            "solution": "The problem statement is subjected to validation.\n\n### Step 1: Extract Givens\n- **Problem**: Scalar Poisson problem $-\\nabla \\cdot (\\nabla u) = f$ in a $2$D domain $\\Omega$.\n- **Boundary Mapping**: A curved boundary segment $\\Gamma$ is the image of $\\xi \\in [-1,1]$ under $\\boldsymbol{x}(\\xi) = (x(\\xi), y(\\xi))$, with $x(\\xi) = \\xi$ and $y(\\xi) = 1 + \\varepsilon \\, P_{2}(\\xi)$.\n- **Polynomials**: $P_{2}(\\xi) = \\frac{3 \\xi^{2} - 1}{2}$ is the Legendre polynomial of degree $2$.\n- **Geometry**: The outward unit normal is $\\boldsymbol{n}(\\xi) = \\frac{(-y'(\\xi), x'(\\xi))}{\\sqrt{(x'(\\xi))^{2} + (y'(\\xi))^{2}}}$, the tangent is $\\boldsymbol{t}(\\xi) = (x'(\\xi), y'(\\xi))$, and the boundary line element is $ds = \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi$.\n- **Test Function**: $v(\\xi) = P_{2}(\\xi)$ on the boundary.\n- **Variational Statement**: $\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega - \\int_{\\partial \\Omega} v \\, \\boldsymbol{n} \\cdot \\nabla u \\, ds = \\int_{\\Omega} f v \\, d\\Omega$.\n- **Robin Condition**: $\\boldsymbol{n} \\cdot \\nabla u + \\alpha u = r$ on $\\Gamma$.\n- **Specific Data**:\n    - $\\varepsilon = \\frac{1}{3}$.\n    - This is stated to imply $y'(\\xi) = \\xi$ and $\\|\\boldsymbol{t}(\\xi)\\| = \\sqrt{1 + \\xi^{2}}$.\n    - Exact solution: $u(x,y) = x^{2} + y^{3}$, with $\\nabla u = (2x, 3y^{2})$.\n- **Quantities to Calculate**:\n    - For Neumann condition, $g(\\xi) := \\boldsymbol{n}(\\xi) \\cdot \\nabla u(\\boldsymbol{x}(\\xi))$. Compute $I_{N} := \\int_{-1}^{1} v(\\xi) \\, g(\\xi) \\, \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi$.\n    - For Robin condition, $\\alpha = 2$ and $r(\\xi) := \\boldsymbol{n}(\\xi) \\cdot \\nabla u(\\boldsymbol{x}(\\xi)) + \\alpha \\, u(\\boldsymbol{x}(\\xi))$. Compute $I_{R} := \\left(\\int_{-1}^{1} \\alpha \\, u(\\boldsymbol{x}(\\xi)) \\, v(\\xi) \\, \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi\\right) - \\left(\\int_{-1}^{1} r(\\xi) \\, v(\\xi) \\, \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi\\right)$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is set within the well-established mathematical framework of the finite element method (specifically, isoparametric spectral elements) and vector calculus for solving partial differential equations. All concepts used are standard in these fields.\n2.  **Well-Posed**: The problem is well-posed. It provides all necessary functions, parameters, and definitions to compute the requested quantities. The tasks are clearly defined.\n3.  **Objective**: The language is precise and mathematical. All terms are formally defined. There are no subjective or opinion-based statements.\n4.  **Completeness and Consistency**: The problem is self-contained. The provided data is consistent. For instance, with $\\varepsilon = \\frac{1}{3}$, $y(\\xi) = 1 + \\frac{1}{3} \\frac{3\\xi^2-1}{2} = 1 + \\frac{\\xi^2}{2} - \\frac{1}{6} = \\frac{5}{6} + \\frac{1}{2}\\xi^2$. Differentiating gives $y'(\\xi) = \\xi$. Then $\\|\\boldsymbol{t}(\\xi)\\| = \\sqrt{(x'(\\xi))^2 + (y'(\\xi))^2} = \\sqrt{1^2 + \\xi^2} = \\sqrt{1+\\xi^2}$. The data is internally consistent.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a standard, albeit computationally intensive, exercise in the application of spectral element methods. The solution will be provided.\n\n***\n\n### Solution\nThe problem requires the derivation of weak boundary terms and their calculation for a specific case involving an isoparametric element.\n\n**1. Parametric Expression for the Weak Neumann Boundary Contribution**\n\nThe weak Neumann boundary contribution in the variational statement is the term $-\\int_{\\Gamma} v \\, \\boldsymbol{n} \\cdot \\nabla u \\, ds$. The boundary segment $\\Gamma$ is parameterized by $\\xi \\in [-1, 1]$. We substitute the given isoparametric definitions:\n- The test function on the boundary is $v(\\boldsymbol{x}(\\xi)) = v(\\xi)$.\n- The differential line element is $ds = \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi$, where $\\|\\boldsymbol{t}(\\xi)\\| = \\sqrt{(x'(\\xi))^2 + (y'(\\xi))^2}$ is the boundary Jacobian.\n- The outward unit normal is $\\boldsymbol{n}(\\xi) = \\frac{(-y'(\\xi), x'(\\xi))}{\\|\\boldsymbol{t}(\\xi)\\|}$.\n\nSubstituting these into the integral gives:\n$$\n-\\int_{\\Gamma} v \\, \\boldsymbol{n} \\cdot \\nabla u \\, ds = -\\int_{-1}^{1} v(\\xi) \\left( \\frac{(-y'(\\xi), x'(\\xi))}{\\|\\boldsymbol{t}(\\xi)\\|} \\cdot \\nabla u(\\boldsymbol{x}(\\xi)) \\right) \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi\n$$\nThe boundary Jacobian $\\|\\boldsymbol{t}(\\xi)\\|$ in the measure $ds$ cancels with the normalization factor in the definition of the unit normal vector $\\boldsymbol{n}(\\xi)$. This is the combination of the boundary Jacobian and the normal vector. The expression simplifies to:\n$$\n-\\int_{\\Gamma} v \\, \\boldsymbol{n} \\cdot \\nabla u \\, ds = -\\int_{-1}^{1} v(\\xi) \\left( -y'(\\xi) \\frac{\\partial u}{\\partial x}(\\boldsymbol{x}(\\xi)) + x'(\\xi) \\frac{\\partial u}{\\partial y}(\\boldsymbol{x}(\\xi)) \\right) d\\xi\n$$\nThis is the parametric expression for the weak Neumann boundary contribution.\n\n**2. Net Weak Contribution for the Robin Boundary Condition**\n\nFor a Robin boundary condition $\\boldsymbol{n} \\cdot \\nabla u + \\alpha u = r$, we can express the flux as $\\boldsymbol{n} \\cdot \\nabla u = r - \\alpha u$. We substitute this into the weak Neumann term:\n$$\n-\\int_{\\Gamma} v \\, \\boldsymbol{n} \\cdot \\nabla u \\, ds = -\\int_{\\Gamma} v (r - \\alpha u) \\, ds = \\int_{\\Gamma} \\alpha u v \\, ds - \\int_{\\Gamma} r v \\, ds\n$$\nThis is the net weak boundary contribution that replaces the original term. In parametric form, this is:\n$$\n\\int_{-1}^{1} \\alpha \\, u(\\boldsymbol{x}(\\xi)) \\, v(\\xi) \\, \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi - \\int_{-1}^{1} r(\\xi) \\, v(\\xi) \\, \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi\n$$\n\n**3. Calculation of the Neumann Integral $I_N$**\n\nThe problem defines $I_N := \\int_{-1}^{1} v(\\xi) \\, g(\\xi) \\, \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi$, where $g(\\xi) = \\boldsymbol{n}(\\xi) \\cdot \\nabla u(\\boldsymbol{x}(\\xi))$. From our previous analysis, this is:\n$$\nI_N = \\int_{-1}^{1} v(\\xi) \\left( -y'(\\xi) \\frac{\\partial u}{\\partial x}(\\boldsymbol{x}(\\xi)) + x'(\\xi) \\frac{\\partial u}{\\partial y}(\\boldsymbol{x}(\\xi)) \\right) d\\xi\n$$\nWe use the specific data provided:\n- $v(\\xi) = P_{2}(\\xi) = \\frac{3\\xi^2 - 1}{2}$.\n- $x(\\xi) = \\xi$, so $x'(\\xi) = 1$.\n- With $\\varepsilon = \\frac{1}{3}$, $y(\\xi) = 1 + \\frac{1}{3}P_2(\\xi) = 1 + \\frac{1}{3}\\left(\\frac{3\\xi^2 - 1}{2}\\right) = \\frac{5}{6} + \\frac{1}{2}\\xi^2$, so $y'(\\xi) = \\xi$.\n- $u(x,y) = x^2 + y^3$, so $\\nabla u = (2x, 3y^2)$.\n- Evaluated on the boundary: $\\frac{\\partial u}{\\partial x}(\\boldsymbol{x}(\\xi)) = 2x(\\xi) = 2\\xi$ and $\\frac{\\partial u}{\\partial y}(\\boldsymbol{x}(\\xi)) = 3(y(\\xi))^2 = 3\\left(\\frac{5}{6} + \\frac{1}{2}\\xi^2\\right)^2$.\n\nThe integrand for $I_N$ is the product of $v(\\xi)$ and the term in the parenthesis:\n$$\n\\text{Integrand} = \\left(\\frac{3\\xi^2 - 1}{2}\\right) \\left[ -(\\xi)(2\\xi) + (1) \\cdot 3\\left(\\frac{5}{6} + \\frac{1}{2}\\xi^2\\right)^2 \\right]\n$$\nLet's simplify the second factor:\n$$\n-2\\xi^2 + 3\\left( \\frac{25}{36} + \\frac{10}{12}\\xi^2 + \\frac{1}{4}\\xi^4 \\right) = -2\\xi^2 + \\frac{25}{12} + \\frac{5}{2}\\xi^2 + \\frac{3}{4}\\xi^4 = \\frac{3}{4}\\xi^4 + \\frac{1}{2}\\xi^2 + \\frac{25}{12}\n$$\nNow multiply by $v(\\xi)$:\n$$\n\\text{Integrand} = \\frac{1}{2}(3\\xi^2 - 1) \\left(\\frac{3}{4}\\xi^4 + \\frac{1}{2}\\xi^2 + \\frac{25}{12}\\right)\n$$\n$$\n= \\frac{1}{2} \\left[ 3\\xi^2\\left(\\frac{3}{4}\\xi^4 + \\frac{1}{2}\\xi^2 + \\frac{25}{12}\\right) - \\left(\\frac{3}{4}\\xi^4 + \\frac{1}{2}\\xi^2 + \\frac{25}{12}\\right) \\right]\n$$\n$$\n= \\frac{1}{2} \\left[ \\left(\\frac{9}{4}\\xi^6 + \\frac{3}{2}\\xi^4 + \\frac{25}{4}\\xi^2\\right) - \\frac{3}{4}\\xi^4 - \\frac{1}{2}\\xi^2 - \\frac{25}{12} \\right]\n$$\n$$\n= \\frac{1}{2} \\left[ \\frac{9}{4}\\xi^6 + \\left(\\frac{3}{2} - \\frac{3}{4}\\right)\\xi^4 + \\left(\\frac{25}{4} - \\frac{1}{2}\\right)\\xi^2 - \\frac{25}{12} \\right] = \\frac{1}{2} \\left[ \\frac{9}{4}\\xi^6 + \\frac{3}{4}\\xi^4 + \\frac{23}{4}\\xi^2 - \\frac{25}{12} \\right]\n$$\nThe integrand is an even function, so $\\int_{-1}^{1} f(\\xi) d\\xi = 2 \\int_{0}^{1} f(\\xi) d\\xi$:\n$$\nI_N = \\int_{0}^{1} \\left( \\frac{9}{4}\\xi^6 + \\frac{3}{4}\\xi^4 + \\frac{23}{4}\\xi^2 - \\frac{25}{12} \\right) d\\xi\n$$\n$$\n= \\left[ \\frac{9}{4} \\frac{\\xi^7}{7} + \\frac{3}{4} \\frac{\\xi^5}{5} + \\frac{23}{4} \\frac{\\xi^3}{3} - \\frac{25}{12}\\xi \\right]_{0}^{1} = \\frac{9}{28} + \\frac{3}{20} + \\frac{23}{12} - \\frac{25}{12}\n$$\n$$\n= \\frac{9}{28} + \\frac{3}{20} - \\frac{2}{12} = \\frac{9}{28} + \\frac{3}{20} - \\frac{1}{6}\n$$\nThe least common multiple of $28$, $20$, and $6$ is $420$.\n$$\nI_N = \\frac{9 \\cdot 15}{420} + \\frac{3 \\cdot 21}{420} - \\frac{1 \\cdot 70}{420} = \\frac{135 + 63 - 70}{420} = \\frac{198 - 70}{420} = \\frac{128}{420} = \\frac{32}{105}\n$$\n\n**4. Calculation of the Robin Integral $I_R$**\n\nThe problem defines $I_R$ as:\n$$\nI_{R} := \\left(\\int_{-1}^{1} \\alpha \\, u(\\boldsymbol{x}(\\xi)) \\, v(\\xi) \\, \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi\\right) - \\left(\\int_{-1}^{1} r(\\xi) \\, v(\\xi) \\, \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi\\right)\n$$\nIt also defines $r(\\xi)$ using the given exact solution $u$:\n$$\nr(\\xi) := \\boldsymbol{n}(\\xi) \\cdot \\nabla u(\\boldsymbol{x}(\\xi)) + \\alpha \\, u(\\boldsymbol{x}(\\xi))\n$$\nLet's substitute this definition of $r(\\xi)$ into the expression for $I_R$:\n$$\nI_R = \\int_{-1}^{1} \\alpha \\, u \\, v \\, \\|\\boldsymbol{t}\\| \\, d\\xi - \\int_{-1}^{1} (\\boldsymbol{n} \\cdot \\nabla u + \\alpha \\, u) \\, v \\, \\|\\boldsymbol{t}\\| \\, d\\xi\n$$\nWe can combine the integrals:\n$$\nI_R = \\int_{-1}^{1} \\left[ \\alpha \\, u \\, v - (\\boldsymbol{n} \\cdot \\nabla u + \\alpha \\, u)v \\right] \\|\\boldsymbol{t}\\| \\, d\\xi\n$$\n$$\nI_R = \\int_{-1}^{1} \\left[ \\alpha u v - (\\boldsymbol{n} \\cdot \\nabla u)v - \\alpha u v \\right] \\|\\boldsymbol{t}\\| \\, d\\xi\n$$\nThe terms involving $\\alpha u v$ cancel out:\n$$\nI_R = -\\int_{-1}^{1} (\\boldsymbol{n} \\cdot \\nabla u) \\, v \\, \\|\\boldsymbol{t}\\| \\, d\\xi\n$$\nRecalling the definition $g(\\xi) = \\boldsymbol{n}(\\xi) \\cdot \\nabla u(\\boldsymbol{x}(\\xi))$, this is:\n$$\nI_R = -\\int_{-1}^{1} g(\\xi) \\, v(\\xi) \\, \\|\\boldsymbol{t}(\\xi)\\| \\, d\\xi\n$$\nThis is precisely the negative of the definition for $I_N$.\n$$\nI_R = -I_N\n$$\nTherefore, using the value calculated for $I_N$:\n$$\nI_R = -\\frac{32}{105}\n$$\nThe final answer requires the values of $I_N$ and $I_R$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{32}{105} & -\\frac{32}{105} \\end{pmatrix}}\n$$"
        }
    ]
}