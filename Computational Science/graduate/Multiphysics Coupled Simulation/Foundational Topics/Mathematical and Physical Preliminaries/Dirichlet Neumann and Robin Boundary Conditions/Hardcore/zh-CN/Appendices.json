{
    "hands_on_practices": [
        {
            "introduction": "我们从最基本的边界条件——狄利克雷（Dirichlet）条件开始，它直接规定了解在边界上的值。这个练习将演示“强加法”，即在离散系统中直接用边界方程替换原有方程。掌握这项技术是构建稳健谱方法求解器的第一步。",
            "id": "3379368",
            "problem": "考虑在区间 $[-1,1]$ 上使用 Chebyshev–Gauss–Lobatto 点的谱配点法。设 $N \\in \\mathbb{N}$ 为多项式次数，定义配点为 $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j=0,1,\\dots,N$。将 Chebyshev 基函数 $\\ell_j(x)$ 定义为满足 $\\ell_j(x_k) = \\delta_{jk}$（对于所有 $j,k \\in \\{0,1,\\dots,N\\}$）的 Lagrange 插值多项式。谱微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 的定义属性是：对于在节点上插值的任意函数 $u$，其节点导数 $(u')_i$ 可由 $(Du)_i = \\sum_{j=0}^N D_{ij} u_j$ 近似，其中 $u_j = u(x_j)$。\n\n您的任务是，对于一个二阶线性常微分方程，通过替换配点矩阵中的边界行来分析并实现 Dirichlet 边界条件的施加。考虑边值问题\n$$\n-u''(x) + \\alpha\\, u(x) = f(x), \\quad x \\in (-1,1),\n$$\n附带 Dirichlet 边界条件\n$$\nu(-1) = u_L, \\quad u(1) = u_R,\n$$\n其中 $\\alpha \\ge 0$ 是一个给定参数。谱配点离散化使用二阶微分矩阵 $D^{(2)} = D^2$ 在节点上近似 $u''(x)$，记为 $(D^{(2)} u)_i$，其中 $i=0,1,\\dots,N$。离散算子矩阵 $A \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 为\n$$\nA = -D^{(2)} + \\alpha I,\n$$\n离散右端向量为 $b$，其元素为 $b_i = f(x_i)$。为强施加 Dirichlet 边界条件，将 $A$ 的第一行和最后一行替换为能精确施加 $u_0 = u_L$ 和 $u_N = u_R$ 的行，并将 $b$ 中相应的元素分别设置为 $u_L$ 和 $u_R$。\n\n从 Chebyshev–Gauss–Lobatto 点上的多项式插值基本原理以及通过 Lagrange 基函数定义谱微分矩阵出发，推导为什么以及如何通过替换 $A$ 中的边界行来一致地施加 Dirichlet 条件，同时保留内部的配点方程。然后实现由此产生的数值方案。\n\n您的程序必须：\n- 构建 Chebyshev–Gauss–Lobatto 节点 $x_j$、一阶微分矩阵 $D$ 和二阶微分矩阵 $D^{(2)} = D D$。\n- 组装离散算子 $A = -D^{(2)} + \\alpha I$。\n- 如上所述，通过替换 $A$ 的第一行和最后一行来施加 Dirichlet 边界条件，并设置右端向量 $b$ 的相应元素。\n- 求解线性系统 $A u = b$ 以求得节点值 $u_j$。\n- 计算最大节点误差 $E = \\max_{0 \\le j \\le N} |u_j - u(x_j)|$ 和边界残差 $B = \\max\\big(|u_0 - u_L|,\\,|u_N - u_R|\\big)$。\n\n使用以下测试套件，每个测试用例指定 $(N,\\alpha,u(x))$ 以及推导出的 $f(x) = -u''(x) + \\alpha u(x)$ 和边界值 $u_L = u(-1)$, $u_R = u(1)$:\n- 测试用例 1：$N=2$，$\\alpha=0$，$u(x) = 1 - x^2$。于是 $u''(x) = -2$，所以 $f(x) = -(-2) + 0\\cdot u(x) = 2$，$u_L = u(-1) = 0$，$u_R = u(1) = 0$。\n- 测试用例 2：$N=8$，$\\alpha=0$，$u(x) = \\sin\\left(\\frac{\\pi}{2}(x+1)\\right)$。于是 $u''(x) = -\\left(\\frac{\\pi}{2}\\right)^2 \\sin\\left(\\frac{\\pi}{2}(x+1)\\right)$，所以 $f(x) = -u''(x) = \\left(\\frac{\\pi}{2}\\right)^2 \\sin\\left(\\frac{\\pi}{2}(x+1)\\right)$，$u_L = 0$，$u_R = 0$。\n- 测试用例 3：$N=16$，$\\alpha=1$，$u(x) = e^{x}(1 - x^2)$。于是 $u''(x) = e^{x}(-x^2 - 4x - 1)$，所以 $f(x) = -u''(x) + \\alpha u(x) = e^{x}(x^2 + 4x + 1) + e^{x}(1 - x^2)$，$u_L = u(-1) = 0$，$u_R = u(1) = 0$。\n- 测试用例 4：$N=32$，$\\alpha=10$，$u(x) = \\cosh(2x) - \\cosh(2)\\,x^2$。于是 $u''(x) = 4\\cosh(2x) - 2\\cosh(2)$，所以 $f(x) = -u''(x) + \\alpha u(x) = -4\\cosh(2x) + 2\\cosh(2) + 10\\left(\\cosh(2x) - \\cosh(2)\\,x^2\\right)$，$u_L = 0$，$u_R = 0$。\n- 测试用例 5：$N=64$，$\\alpha=0$，$u(x) = \\sin\\left(\\frac{\\pi}{2}(x+1)\\right)$，与测试用例 2 相同，但分辨率更高。\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例的结果应是该用例的一个包含两个浮点数 $[E,B]$ 的列表，总体输出应是按测试套件顺序排列的这些列表的列表，例如 $[[E_1,B_1],[E_2,B_2],\\dots]$。",
            "solution": "该问题要求推导并实现一种谱配点法，用以求解带 Dirichlet 边界条件的二阶线性常微分方程（ODE）。任务的核心是证明通过替换离散算子矩阵中的行来施加这些边界条件的程序的合理性。\n\n设给定的边值问题为\n$$\n-u''(x) + \\alpha u(x) = f(x), \\quad x \\in (-1,1)\n$$\n边界条件为\n$$\nu(-1) = u_L, \\quad u(1) = u_R.\n$$\n在谱配点法中，我们寻求一个次数为 $N$ 的单一全局多项式 $p_N(x)$ 形式的近似解。该多项式由其在 $N+1$ 个不同配点上的值唯一确定。这里，我们使用 Chebyshev-Gauss-Lobatto（CGL）节点，由 $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$ 给出，其中 $j=0, 1, \\dots, N$。注意，这些点包括了区间的边界：$x_0 = 1$ 和 $x_N = -1$。\n\n经过点 $(x_j, u_j)$ 的插值多项式 $p_N(x)$ 可以用 Lagrange 基写为：\n$$\np_N(x) = \\sum_{j=0}^{N} u_j \\ell_j(x),\n$$\n其中 $u_j$ 是对 $u(x_j)$ 的近似，$\\ell_j(x)$ 是满足 $\\ell_j(x_k) = \\delta_{jk}$ 的 Lagrange 基多项式。\n\n配点法在*内部*配点（即 $i=1, \\dots, N-1$）上施加控制微分方程：\n$$\n-p_N''(x_i) + \\alpha p_N(x_i) = f(x_i).\n$$\n插值多项式在节点上的导数可以使用谱微分矩阵 $D$ 计算。节点上的一阶导数向量 $p_N'(\\mathbf{x})$ 由矩阵向量乘积 $D\\mathbf{u}$ 给出，其中 $\\mathbf{u} = [u_0, u_1, \\dots, u_N]^T$。因此，二阶导数由 $p_N''(\\mathbf{x}) = D(D\\mathbf{u}) = D^2\\mathbf{u} = D^{(2)}\\mathbf{u}$ 给出。\n\n将导数的矩阵表示代入内部节点（$i=1, \\dots, N-1$）的配点方程，我们得到：\n$$\n- \\sum_{j=0}^{N} (D^{(2)})_{ij} u_j + \\alpha u_i = f(x_i).\n$$\n这 $N-1$ 个方程可以表示为一个完整矩阵系统的内部行。设 $A = -D^{(2)} + \\alpha I$ 为 $(N+1) \\times (N+1)$ 的离散算子矩阵，其中 $I$ 是单位矩阵。设 $\\mathbf{b}$ 为右端向量，其元素为 $b_i = f(x_i)$。那么内部配点方程等价于：\n$$\n(A\\mathbf{u})_i = b_i \\quad \\text{for } i=1, \\dots, N-1.\n$$\n这给了我们关于 $N+1$ 个未知节点值 $u_0, \\dots, u_N$ 的 $N-1$ 个线性方程。该系统是欠定的。我们需要另外两个方程，这两个方程由边界条件提供。\n\n这就引出了一个核心问题：如何引入边界条件 $u(1)=u_R$ 和 $u(-1)=u_L$。在我们的节点基中，由于 $x_0=1$ 和 $x_N=-1$，这些条件直接转化为对未知向量 $\\mathbf{u}$ 的代数约束：\n$$\nu_0 = u_R \\\\\nu_N = u_L\n$$\n通过在所有 $N+1$ 个点上对 ODE 进行配点得到的原始方程组 $(A\\mathbf{u})_i = b_i$ for $i=0, \\dots, N$ 不是我们要解的。索引为 $i=0$ 和 $i=N$ 的行代表在边界上施加的 ODE。然而，边界上的解并非由 ODE 本身决定，而是由边界条件*指定*的。因此，我们必须舍弃原始配点系统的第 0 行和第 N 行，并将它们替换为施加边界约束的方程。\n\n这就是行替换法的合理性所在。我们用所需的方程（Dirichlet 条件）替换不相关的方程（边界上的 ODE）。\n\n替换的“如何”操作如下：\n1.  为施加条件 $u_0 = u_R$，我们需要一个当且仅当 $u_0 = u_R$ 时成立的线性方程。最简单的此类方程是 $1 \\cdot u_0 + 0 \\cdot u_1 + \\dots + 0 \\cdot u_N = u_R$。这对应于将矩阵 $A$ 的第一行（索引 0）替换为向量 $[1, 0, \\dots, 0]$，并将右端向量 $\\mathbf{b}$ 的第一个元素设置为 $u_R$。\n\n2.  类似地，为施加 $u_N = u_L$，我们使用方程 $0 \\cdot u_0 + \\dots + 0 \\cdot u_{N-1} + 1 \\cdot u_N = u_L$。这对应于将矩阵 $A$ 的最后一行（索引 $N$）替换为 $[0, \\dots, 0, 1]$，并将 $\\mathbf{b}$ 的最后一个元素设置为 $u_L$。\n\n修改后的线性系统，我们称之为 $A_{mod} \\mathbf{u} = \\mathbf{b}_{mod}$，其形式如下：\n$$\n\\begin{pmatrix}\n1 & 0 & 0 & \\dots & 0 \\\\\nA_{1,0} & A_{1,1} & A_{1,2} & \\dots & A_{1,N} \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\nA_{N-1,0} & A_{N-1,1} & A_{N-1,2} & \\dots & A_{N-1,N} \\\\\n0 & 0 & 0 & \\dots & 1\n\\end{pmatrix}\n\\begin{pmatrix} u_0 \\\\ u_1 \\\\ \\vdots \\\\ u_{N-1} \\\\ u_N \\end{pmatrix}\n=\n\\begin{pmatrix} u_R \\\\ f(x_1) \\\\ \\vdots \\\\ f(x_{N-1}) \\\\ u_L \\end{pmatrix}\n$$\n这是一个满秩的 $(N+1) \\times (N+1)$ 线性系统。求解该系统可以得到唯一的节点值向量 $\\mathbf{u}$，它既满足内部配点上的微分方程，也满足边界上的 Dirichlet 条件。这个过程是一致的，因为它正确地将内部域的控制物理/数学原理与边界上的指定约束结合了起来。\n\n在实现方面，CGL 节点上的一阶微分矩阵 $D$ 有众所周知地显式公式：\n$$\nD_{jk} = \\begin{cases}\n    \\frac{c_j}{c_k} \\frac{(-1)^{j+k}}{x_j - x_k} & j \\neq k \\\\\n    -\\frac{x_j}{2(1-x_j^2)} & j=k, \\quad j \\in \\{1,\\dots,N-1\\} \\\\\n    \\frac{2N^2+1}{6} & j=k=0 \\\\\n    -\\frac{2N^2+1}{6} & j=k=N\n\\end{cases}\n$$\n其中权重为 $c_j=1$（对于 $j \\in \\{1,\\dots,N-1\\}$）以及 $c_0=c_N=2$。我们首先构建 $D$，然后计算 $D^{(2)} = D \\cdot D$，组装原始算子 $A = -D^{(2)} + \\alpha I$，最后在求解线性系统之前如上所述修改 $A$ 和 $\\mathbf{b}$。边界残差 $B$ 应该在机器精度范围内为零，因为这些条件是强施加的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the Chebyshev-Gauss-Lobatto nodes and the corresponding\n    first differentiation matrix.\n\n    Args:\n        N (int): The polynomial degree.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The array of N+1 Chebyshev nodes.\n            - np.ndarray: The (N+1)x(N+1) differentiation matrix D.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0]), np.array([[0.0]])\n    \n    # Chebyshev-Gauss-Lobatto nodes\n    j = np.arange(N + 1)\n    x = np.cos(np.pi * j / N)\n    \n    # c_j coefficients\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[N] = 2.0\n    \n    D = np.zeros((N + 1, N + 1))\n    \n    # Off-diagonal entries\n    for i in range(N + 1):\n        for k in range(N + 1):\n            if i != k:\n                D[i, k] = (c[i] / c[k]) * ((-1)**(i + k)) / (x[i] - x[k])\n    \n    # Diagonal entries\n    # For interior points\n    for i in range(1, N):\n        D[i, i] = -x[i] / (2 * (1 - x[i]**2))\n        \n    # For boundary points\n    D[0, 0] = (2 * N**2 + 1) / 6.0\n    D[N, N] = -(2 * N**2 + 1) / 6.0\n    \n    return x, D\n\ndef solve():\n    \"\"\"\n    Solves the BVP using spectral collocation for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 2, \"alpha\": 0.0,\n            \"u_func\": lambda x: 1 - x**2,\n            \"upp_func\": lambda x: -2.0 + 0 * x,\n            \"uL\": 0.0, \"uR\": 0.0\n        },\n        {\n            \"N\": 8, \"alpha\": 0.0,\n            \"u_func\": lambda x: np.sin(np.pi / 2 * (x + 1)),\n            \"upp_func\": lambda x: -(np.pi / 2)**2 * np.sin(np.pi / 2 * (x + 1)),\n            \"uL\": 0.0, \"uR\": 0.0\n        },\n        {\n            \"N\": 16, \"alpha\": 1.0,\n            \"u_func\": lambda x: np.exp(x) * (1 - x**2),\n            \"upp_func\": lambda x: np.exp(x) * (-x**2 - 4*x - 1),\n            \"uL\": 0.0, \"uR\": 0.0\n        },\n        {\n            \"N\": 32, \"alpha\": 10.0,\n            \"u_func\": lambda x: np.cosh(2*x) - np.cosh(2) * x**2,\n            \"upp_func\": lambda x: 4*np.cosh(2*x) - 2*np.cosh(2),\n            \"uL\": 0.0, \"uR\": 0.0\n        },\n        {\n            \"N\": 64, \"alpha\": 0.0,\n            \"u_func\": lambda x: np.sin(np.pi / 2 * (x + 1)),\n            \"upp_func\": lambda x: -(np.pi / 2)**2 * np.sin(np.pi / 2 * (x + 1)),\n            \"uL\": 0.0, \"uR\": 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        alpha = case[\"alpha\"]\n        u_func = case[\"u_func\"]\n        upp_func = case[\"upp_func\"]\n        uL = case[\"uL\"]\n        uR = case[\"uR\"]\n\n        # 1. Construct nodes and differentiation matrices\n        x, D = chebyshev_diff_matrix(N)\n        D2 = D @ D\n\n        # 2. Assemble the discrete operator A and RHS b\n        I = np.eye(N + 1)\n        A = -D2 + alpha * I\n        \n        # f(x) = -u''(x) + alpha*u(x)\n        f = -upp_func(x) + alpha * u_func(x)\n        b = f.copy()\n\n        # 3. Enforce Dirichlet boundary conditions by row replacement\n        # Note: x_0 = 1, x_N = -1\n        # First row (i=0) for u(1) = uR\n        A[0, :] = 0.0\n        A[0, 0] = 1.0\n        b[0] = uR\n\n        # Last row (i=N) for u(-1) = uL\n        A[N, :] = 0.0\n        A[N, N] = 1.0\n        b[N] = uL\n\n        # 4. Solve the linear system\n        u_numerical = np.linalg.solve(A, b)\n\n        # 5. Compute error metrics\n        u_exact = u_func(x)\n        \n        # Max nodal error\n        E = np.max(np.abs(u_numerical - u_exact))\n        \n        # Boundary residual\n        # Check u(1) (at index 0) and u(-1) (at index N)\n        B = np.max([np.abs(u_numerical[0] - uR), np.abs(u_numerical[N] - uL)])\n        \n        results.append([E, B])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{e},{b}]\" for e, b in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在上一个练习的基础上，我们现在处理罗宾（Robin）条件，它涉及解的值 $u$ 与其导数 $u'$ 的线性组合。本练习展示了如何优雅地扩展行替换策略以处理包含导数的边界条件。这也自然地涵盖了诺伊曼（Neumann）条件，它可被视为罗宾条件 $u'(x) + \\alpha u(x) = g$ 中比例系数 $\\alpha$ 为零的特例。",
            "id": "3379336",
            "problem": "实现一个用于一维线性边界值问题的 Chebyshev 配置法求解器，该问题具有 Robin 边界条件，并用它来评估谱精度。从以下基本基础开始：Chebyshev–Gauss–Lobatto (CGL) 节点的定义，根据这些节点构建 Chebyshev 一阶微分矩阵，以及通过替换配置系统中的方程来施加边界条件的原理。\n\n考虑常微分方程 (ODE)\n$$\n-\\,u''(x) + \\lambda\\,u(x) = f(x), \\quad x \\in [-1,1],\n$$\n在两个端点处服从 Robin 边界条件，\n$$\nu'(1) + \\alpha_L\\,u(1) = g_L, \\qquad u'(-1) + \\alpha_R\\,u(-1) = g_R.\n$$\n您将使用谱配置法在 Chebyshev–Gauss–Lobatto (CGL) 节点上进行离散化\n$$\nx_j = \\cos\\!\\left(\\frac{\\pi j}{N}\\right), \\quad j=0,1,\\dots,N,\n$$\n这些节点包括端点 $x_0=1$ 和 $x_N=-1$。设 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 为这些节点上的 Chebyshev 一阶微分矩阵，并令 $D^{(2)} = D^2$ 表示二阶微分矩阵。为节点值向量 $\\mathbf{u} = \\big(u(x_0),\\dots,u(x_N)\\big)^\\top$ 构建线性系统：\n- 对于内部索引 $i=1,2,\\dots,N-1$，通过配置法施加 ODE：\n$$\n\\left(-D^{(2)} + \\lambda I\\right)_{i,:}\\,\\mathbf{u} = f(x_i).\n$$\n- 在第一个和最后一个索引处，替换方程以离散形式施加 Robin 条件：\n$$\n\\big(D_{0,:} + \\alpha_L\\,\\mathbf{e}_0^\\top\\big)\\,\\mathbf{u} = g_L, \\qquad \\big(D_{N,:} + \\alpha_R\\,\\mathbf{e}_N^\\top\\big)\\,\\mathbf{u} = g_R,\n$$\n其中 $\\mathbf{e}_0$ 和 $\\mathbf{e}_N$ 是 $\\mathbb{R}^{N+1}$ 中的标准基向量。\n\n为了使问题完全指定且可测试，通过一个选定的光滑精确解 $u_{\\text{exact}}$ 定义 $f$、$g_L$ 和 $g_R$：\n$$\nf(x) = -u_{\\text{exact}}''(x) + \\lambda\\,u_{\\text{exact}}(x), \\quad g_L = u_{\\text{exact}}'(1) + \\alpha_L\\,u_{\\text{exact}}(1), \\quad g_R = u_{\\text{exact}}'(-1) + \\alpha_R\\,u_{\\text{exact}}(-1).\n$$\n对于每个测试用例，计算最大范数误差\n$$\nE_N = \\max_{0 \\le j \\le N} \\left|u_{\\text{num}}(x_j) - u_{\\text{exact}}(x_j)\\right|,\n$$\n对几个 $N$ 值进行计算，然后通过最小二乘法将 $\\log E_N$ 作为 $N$ 的函数拟合成一条直线来评估谱精度。具体来说，给定一组大小 $\\{N_k\\}$ 和相应的误差 $\\{E_{N_k}\\}$，计算斜率 $s$，使\n$$\n\\sum_k \\left(\\log E_{N_k} - (a + s\\,N_k)\\right)^2\n$$\n相对于 $a$ 和 $s$ 最小化，并报告这个拟合斜率 $s$。对于形式为 $E_N \\approx C\\,\\rho^{-N}$（其中 $\\rho>1$）的指数（谱）收敛，我们期望 $\\log E_N \\approx \\log C - N \\log \\rho$，因此随着 $N$ 的增长，拟合斜率 $s \\approx -\\log \\rho$ 为负且有界地远离 0。\n\n实现上述内容，并在以下三个测试用例上运行。在每个案例中，使用指定的精确解 $u_{\\text{exact}}$、参数 $(\\lambda,\\alpha_L,\\alpha_R)$ 和 $N$ 值列表。\n\n- 测试用例 A (一般 Robin)：\n  - $u_{\\text{exact}}(x) = e^{x} + \\cos(3x)$,\n  - $\\lambda = 1$, $\\alpha_L = 0.7$, $\\alpha_R = 1.3$,\n  - $N \\in \\{16,24,32,40\\}$.\n\n- 测试用例 B (Robin 条件下 $\\alpha_L=\\alpha_R=0$ 时的 Neumann 极限)：\n  - $u_{\\text{exact}}(x) = \\sinh(2x) + \\sin(5x)$,\n  - $\\lambda = 1$, $\\alpha_L = 0$, $\\alpha_R = 0$,\n  - $N \\in \\{16,24,32,40\\}$.\n\n- 测试用例 C (更强的反应项和 Robin 条件)：\n  - $u_{\\text{exact}}(x) = \\cosh(x) + \\sin(2x)$,\n  - $\\lambda = 10$, $\\alpha_L = 5$, $\\alpha_R = 2$,\n  - $N \\in \\{16,32,48,64\\}$.\n\n您的程序必须：\n- 为每个 $N$ 构建 CGL 节点和 Chebyshev 微分矩阵 $D$，\n- 按照规定，通过替换第一个和最后一个方程来组装并求解施加了 Robin 边界条件的配置系统，\n- 在每个测试用例中为每个 $N$ 计算 $E_N$，\n- 将最小二乘直线拟合到作为 $N$ 的函数的 $\\log E_N$ 上，并为每个测试用例返回斜率 $s$。\n\n最终输出格式：您的程序应生成单行输出，其中包含三个拟合斜率的逗号分隔列表，按 A、B、C 的顺序排列，并用方括号括起来，例如 $[s_A,s_B,s_C]$。不使用角度，也无需报告物理单位。输出中的所有数值必须是纯十进制数。每个测试用例的答案必须是浮点数。因此，测试套件由上述三个案例组成，输出必须将其拟合斜率汇总到所需的单行中。",
            "solution": "用户希望实现一个用于一维线性边界值问题（具有 Robin 边界条件）的 Chebyshev 配置法求解器。\n\n### 1. 问题验证\n\n在尝试任何解决方案之前，该问题都经过了严格的验证过程。\n\n#### 第 1 步：提取已知信息\n- **控制方程**：常微分方程 (ODE) 为 $-\\,u''(x) + \\lambda\\,u(x) = f(x)$，其中 $x \\in [-1,1]$。\n- **边界条件 (BCs)**：在端点指定了 Robin 条件：\n  - $u'(1) + \\alpha_L\\,u(1) = g_L$\n  - $u'(-1) + \\alpha_R\\,u(-1) = g_R$\n- **离散化**：使用 $N+1$ 个 Chebyshev–Gauss–Lobatto (CGL) 节点对域进行离散化：$x_j = \\cos(\\frac{\\pi j}{N})$，其中 $j=0,1,\\dots,N$。\n- **数值方法**：将使用谱配置法。一阶微分算子由 Chebyshev 微分矩阵 $D$ 近似，二阶微分算子由 $D^{(2)} = D^2$ 近似。未知量向量为 $\\mathbf{u}$，表示在 CGL 节点上的函数值。\n- **系统组装**：$\\mathbf{u}$ 的线性系统构造如下：\n  - 对于内部节点（$i=1,\\dots,N-1$），施加 ODE：$\\left(-D^{(2)} + \\lambda I\\right)_{i,:}\\,\\mathbf{u} = f(x_i)$。\n  - 替换第一个方程（第 $i=0$ 行）以施加在 $x_0=1$ 处的边界条件：$\\big(D_{0,:} + \\alpha_L\\,\\mathbf{e}_0^\\top\\big)\\,\\mathbf{u} = g_L$。\n  - 替换最后一个方程（第 $i=N$ 行）以施加在 $x_N=-1$ 处的边界条件：$\\big(D_{N,:} + \\alpha_R\\,\\mathbf{e}_N^\\top\\big)\\,\\mathbf{u} = g_R$。\n- **验证（人造解法）**：源项 $f(x)$ 和边界数据 $g_L, g_R$ 基于选定的精确解 $u_{\\text{exact}}(x)$ 定义：\n  - $f(x) = -u_{\\text{exact}}''(x) + \\lambda\\,u_{\\text{exact}}(x)$\n  - $g_L = u_{\\text{exact}}'(1) + \\alpha_L\\,u_{\\text{exact}}(1)$\n  - $g_R = u_{\\text{exact}}'(-1) + \\alpha_R\\,u_{\\text{exact}}(-1)$\n- **误差分析**：对于给定序列 $\\{N_k\\}$ 中的每个 $N$，计算最大范数误差 $E_N = \\max_{j} |u_{\\text{num}}(x_j) - u_{\\text{exact}}(x_j)|$。\n- **收敛率**：通过对点 $(N_k, \\log E_{N_k})$ 拟合最小二乘直线来评估谱精度，找到其斜率 $s$。\n- **测试用例**：提供了三个特定的测试用例（A、B、C），每个用例都有唯一的 $u_{\\text{exact}}(x)$、参数 $(\\lambda, \\alpha_L, \\alpha_R)$ 和 $N$ 值列表。\n\n#### 第 2 步：使用提取的已知信息进行验证\n- **科学依据**：该问题是偏微分方程数值分析中的一个标准、典型的练习。使用 Chebyshev 多项式的谱配置法是科学计算中的一个基础课题。该问题在数学上是合理的，并基于已建立的原则。\n- **适定性**：该问题是适定的。它描述了一个方形线性方程组的完整构造。对于给定的 Helmholtz 型方程和 Robin 边界条件（以及具体参数），连续问题存在唯一解。按所述实现的谱配置法会产生一个非奇异的系统矩阵，从而确保了唯一的数值解。\n- **客观性**：问题陈述具有数学上的精确性。所有函数、参数和过程都得到了明确的定义。\n- **完整性和一致性**：问题是自洽的，并提供了构建求解器和运行测试所需的所有必要信息。人造解法确保了一个一致的设置，其中精确解是构造已知的。边界条件的符号（$L$ 在 $x=1$，$R$ 在 $x=-1$）虽然不传统，但已明确定义，必须遵守。\n- **可行性**：所需的计算，包括构造微分矩阵、求解线性系统和执行最小二乘拟合，都是标准且计算上可行的。\n\n#### 第 3 步：结论和行动\n问题有效。将提供完整的解决方案。\n\n### 2. 解决方案方法论\n\n解决方案涉及按所述实现 Chebyshev 配置法。每个测试用例的总体过程如下：\n\n1.  **遍历 $N$ 值**：对于测试用例中指定的每个多项式阶数 $N$，计算一个数值解。\n2.  **构建 Chebyshev 网格和微分矩阵**：对于给定的 $N$，生成 $N+1$ 个 CGL 节点 $x_j$。使用标准的数值稳定公式构造相应的 $(N+1) \\times (N+1)$ 一阶微分矩阵 $D$。然后计算二阶微分矩阵为 $D^{(2)} = D^2$。\n3.  **组装线性系统**：组装一个 $(N+1) \\times (N+1)$ 的矩阵 $A$ 和一个大小为 $N+1$ 的向量 $\\mathbf{b}$。\n    -   最初，矩阵 $A$ 设置为 $-D^{(2)} + \\lambda I$，代表所有节点上的微分算子。\n    -   向量 $\\mathbf{b}$ 用在节点处计算的源函数值 $f(x_j) = -u_{\\text{exact}}''(x_j) + \\lambda u_{\\text{exact}}(x_j)$ 填充。\n    -   $A$ 和 $\\mathbf{b}$ 的第一行（$j=0$，对应于 $x_0=1$）被替换，以施加在 $x=1$ 处的 Robin 条件。新行源自边界算子的离散形式 $D_{0,:} + \\alpha_L \\mathbf{e}_0^\\top$。这意味着 $A$ 的第一行成为 $D$ 的第一行，并将 $\\alpha_L$ 加到对角元素 $A_{0,0}$ 上。$\\mathbf{b}$ 的第一个元素设置为 $g_L = u_{\\text{exact}}'(1) + \\alpha_L u_{\\text{exact}}(1)$。\n    -   类似地，最后一行（$j=N$，对应于 $x_N=-1$）被替换，以施加在 $x=-1$ 处的条件。$A$ 的最后一行成为 $D$ 的最后一行，并将 $\\alpha_R$ 加到对角元素 $A_{N,N}$ 上。$\\mathbf{b}$ 的最后一个元素设置为 $g_R = u_{\\text{exact}}'(-1) + \\alpha_R u_{\\text{exact}}(-1)$。\n4.  **求解并计算误差**：求解线性系统 $A\\mathbf{u} = \\mathbf{b}$ 以获得数值解向量 $\\mathbf{u}$。计算数值解与节点处精确解值之间的最大绝对误差 $E_N$。\n5.  **评估收敛性**：为所有指定的 $\\{N_k\\}$ 计算出误差 $\\{E_{N_k}\\}$ 后，取误差的自然对数 $\\{\\log E_{N_k}\\}$。对点 $(N_k, \\log E_{N_k})$ 进行线性回归，以找到最佳拟合线。该线的斜率 $s$ 是指数收敛率的度量。该斜率是该测试用例的最终结果。\n\n对所有三个测试用例重复此过程，并收集所得的斜率。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a Chebyshev collocation solver for a 1D linear BVP with Robin boundary conditions,\n    and assesses its spectral accuracy.\n    \"\"\"\n\n    def chebyshev_cgl(N):\n        \"\"\"\n        Computes the Chebyshev-Gauss-Lobatto (CGL) nodes and the \n        first-derivative differentiation matrix.\n        \n        Args:\n            N (int): The polynomial degree. Number of nodes is N+1.\n            \n        Returns:\n            tuple: A tuple containing:\n                - x (np.ndarray): The N+1 CGL nodes.\n                - D (np.ndarray): The (N+1)x(N+1) differentiation matrix.\n        \"\"\"\n        if N == 0:\n            return np.array([0.0]), np.array([[0.0]])\n        \n        # CGL nodes\n        j = np.arange(N + 1)\n        x = np.cos(np.pi * j / N)\n        \n        # Assemble differentiation matrix D\n        c = np.ones(N + 1)\n        c[0] = 2.0\n        c[N] = 2.0\n        \n        # Off-diagonal entries\n        X = np.tile(x, (N + 1, 1))\n        dX = X - X.T\n        \n        # Formula: D_ij = c_i/c_j * (-1)^(i+j) / (x_i - x_j) for i != j\n        # We combine c_i and (-1)^i terms for a compact form\n        c_i_term = c * (-1)**j\n        D = (c_i_term[:, None] / c_i_term[None, :]) / (dX + np.eye(N + 1))\n        \n        # Diagonal entries (using the sum-to-zero property for stability)\n        D -= np.diag(np.sum(D, axis=1))\n        \n        return x, D\n\n    def compute_slope(u_exact, u_prime, u_double_prime, lambda_val, alpha_L, alpha_R, N_vals):\n        \"\"\"\n        Solves the BVP for a range of N, computes errors, and fits a line\n        to (N, log(error)) to find the convergence rate (slope).\n        \"\"\"\n        errors = []\n        for N in N_vals:\n            # Get nodes and differentiation matrices\n            x, D = chebyshev_cgl(N)\n            D2 = D @ D\n\n            # Assemble system matrix A and RHS vector b\n            # Start with the interior equation operator everywhere\n            A = -D2 + lambda_val * np.eye(N + 1)\n            f_vals = -u_double_prime(x) + lambda_val * u_exact(x)\n            b = f_vals.copy()\n\n            # Enforce boundary conditions by replacing rows\n            # Boundary at x = 1 (node j=0)\n            A[0, :] = D[0, :]\n            A[0, 0] += alpha_L\n            g_L = u_prime(1.0) + alpha_L * u_exact(1.0)\n            b[0] = g_L\n\n            # Boundary at x = -1 (node j=N)\n            A[-1, :] = D[-1, :]\n            A[-1, -1] += alpha_R\n            g_R = u_prime(-1.0) + alpha_R * u_exact(-1.0)\n            b[-1] = g_R\n            \n            # Solve the linear system\n            u_num = np.linalg.solve(A, b)\n            \n            # Compute the maximum norm error\n            u_ex_vals = u_exact(x)\n            error = np.max(np.abs(u_num - u_ex_vals))\n            errors.append(error)\n            \n        # Perform least-squares fit on log(error) vs N\n        log_errors = np.log(errors)\n        coeffs = np.polyfit(N_vals, log_errors, 1)\n        slope = coeffs[0]\n        \n        return slope\n\n    test_cases = [\n        # Test Case A\n        {\n            'u_exact': lambda x: np.exp(x) + np.cos(3 * x),\n            'u_prime': lambda x: np.exp(x) - 3 * np.sin(3 * x),\n            'u_double_prime': lambda x: np.exp(x) - 9 * np.cos(3 * x),\n            'lambda_val': 1.0, 'alpha_L': 0.7, 'alpha_R': 1.3,\n            'N_vals': [16, 24, 32, 40]\n        },\n        # Test Case B\n        {\n            'u_exact': lambda x: np.sinh(2 * x) + np.sin(5 * x),\n            'u_prime': lambda x: 2 * np.cosh(2 * x) + 5 * np.cos(5 * x),\n            'u_double_prime': lambda x: 4 * np.sinh(2 * x) - 25 * np.sin(5 * x),\n            'lambda_val': 1.0, 'alpha_L': 0.0, 'alpha_R': 0.0,\n            'N_vals': [16, 24, 32, 40]\n        },\n        # Test Case C\n        {\n            'u_exact': lambda x: np.cosh(x) + np.sin(2 * x),\n            'u_prime': lambda x: np.sinh(x) + 2 * np.cos(2 * x),\n            'u_double_prime': lambda x: np.cosh(x) - 4 * np.sin(2 * x),\n            'lambda_val': 10.0, 'alpha_L': 5.0, 'alpha_R': 2.0,\n            'N_vals': [16, 32, 48, 64]\n        }\n    ]\n\n    slopes = []\n    for case in test_cases:\n        slope = compute_slope(\n            u_exact=case['u_exact'],\n            u_prime=case['u_prime'],\n            u_double_prime=case['u_double_prime'],\n            lambda_val=case['lambda_val'],\n            alpha_L=case['alpha_L'],\n            alpha_R=case['alpha_R'],\n            N_vals=case['N_vals']\n        )\n        slopes.append(slope)\n        \n    print(f\"[{','.join(map(str, slopes))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实世界的问题通常在域的不同部分具有不同类型的边界条件。最后一个练习将通过实现一个带有混合狄利克雷和诺伊曼条件的求解器，来综合我们学到的技能。这展示了配置法在处理复杂边值问题时的模块化特性和灵活性。",
            "id": "3379366",
            "problem": "考虑区间 $(0,1)$ 上的一维泊松方程 $-\\Delta u = f$，其中 $\\Delta$ 表示关于 $x$ 的二阶导数算子。该方程受混合边界条件约束：在 $x=0$ 处为狄利克雷边界条件，在 $x=1$ 处为诺伊曼边界条件。具体而言，施加 $u(0) = g_D$ 和 $\\partial_x u(1) = g_N$。目标是构建可制造的解析解 $u$ 和相关的右端项 $f$，使用切比雪夫配置法在切比雪夫-高斯-洛巴托点上离散化该问题，并数值验证谱（指数）收敛性。\n\n必须遵循谱配置法的基本定义。使用 $[-1,1]$ 上的切比雪夫-高斯-洛巴托点 $\\{\\xi_j\\}_{j=0}^N$，其由 $\\xi_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$ 给出；以及 $[-1,1]$ 上的标准切比雪夫微分矩阵 $D$，其由经过充分检验的显式公式定义，元素为\n$$D_{ij} = \\begin{cases}\n\\frac{c_i}{c_j}\\frac{(-1)^{i+j}}{\\xi_i - \\xi_j}, & i \\neq j,\\\\\n-\\sum_{k \\neq i} D_{ik}, & i=j,\n\\end{cases}$$\n其中 $c_0 = 2$，$c_N = 2$，且对于 $j=1,\\dots,N-1$，$c_j = 1$。使用 $x = \\frac{\\xi+1}{2}$ 映射计算域，使得 $\\xi = -1$ 对应于 $x=0$，$\\xi=1$ 对应于 $x=1$。在此映射下，$d/dx = 2\\,d/d\\xi$ 且 $d^2/dx^2 = 4\\,d^2/d\\xi^2$。构建关于 $x$ 的离散二阶导数算子为 $D^{(2)}_x = 4 D^2$。\n\n按如下方式构建配置线性系统。对于内部配置点 ($j=1,\\dots,N-1$)，使用 $-D^{(2)}_x u = f$ 施加强形式 $-u''(x_j) = f(x_j)$。在右端点（$j=0$，对应于 $x=1$），使用离散算子 $2 D u = g_N$ 施加诺伊曼边界条件 $\\partial_x u(1) = g_N$。在左端点（$j=N$，对应于 $x=0$），通过将相应行替换为单位约束来施加狄利克雷边界条件 $u(0) = g_D$。\n\n所有三角函数的角度必须以弧度为单位。\n\n可制造的解析解：\n- 选择 $u_1(x) = e^{x} \\sin(2\\pi x)$，附带 $f_1(x) = -u_1''(x)$，以及边界数据 $g_{D,1} = u_1(0)$ 和 $g_{N,1} = u_1'(1)$。\n- 选择 $u_2(x) = \\cosh(3x) + \\cos(5x)$，附带 $f_2(x) = -u_2''(x)$，以及边界数据 $g_{D,2} = u_2(0)$ 和 $g_{N,2} = u_2'(1)$。\n\n验证目标：\n- 对于解析解 $u$，切比雪夫配置法预期会产生随 $N$ 指数衰减的误差。通过为一系列 $N$ 值计算 $\\log_{10}(\\text{error})$ 相对于 $N$ 的最小二乘斜率 $b$ 和决定系数 $R^2$ 来量化这一点。指数收敛性在数值上表现为一个强负斜率 $b<0$ 和一个接近 $1$ 的高 $R^2$ 值。\n\n误差定义：\n- 在配置网格上使用逐点最大范数：$\\|e\\|_{\\infty} = \\max_j |u_{\\text{num}}(x_j) - u_{\\text{exact}}(x_j)|$。\n\n测试套件和要求输出：\n- 测试用例 $\\mathsf{A}$ (理想情况)：使用 $u_1$ 和 $N \\in \\{8,16,32,64\\}$。计算 $y = \\log_{10}(\\|e\\|_{\\infty})$ 相对于 $N$ 的最小二乘斜率 $b_{\\mathsf{A}}$ 和 $R^2_{\\mathsf{A}}$，并报告最大 $N=64$ 时的 $\\|e\\|_{\\infty}$。\n- 测试用例 $\\mathsf{B}$ (备选解析解)：使用 $u_2$ 和 $N \\in \\{6,12,24,48\\}$。计算 $b_{\\mathsf{B}}$、$R^2_{\\mathsf{B}}$。\n- 测试用例 $\\mathsf{C}$ (边界条件验证)：对于 $u_1$ 和 $N=32$，使用离散算子计算边界处的绝对残差，即 $r_D = |u_{\\text{num}}(0) - g_{D,1}|$ 和 $r_N = |\\partial_x u_{\\text{num}}(1) - g_{N,1}|$，其中 $\\partial_x u_{\\text{num}}(1)$ 是在右端点行处计算为 $2\\,D u$。\n- 测试用例 $\\mathsf{D}$ (边缘情况小 $N$)：对于 $u_1$ 和 $N=4$，计算最大范数误差 $\\|e\\|_{\\infty}$。\n\n您的程序必须数值地组装和求解配置线性系统，并按此确切顺序生成单行输出，该输出包含一个用方括号括起来的逗号分隔列表，其中含有以下八个结果：\n$$[b_{\\mathsf{A}}, R^2_{\\mathsf{A}}, \\|e\\|_{\\infty}\\text{ at }N=64, b_{\\mathsf{B}}, R^2_{\\mathsf{B}}, r_D, r_N, \\|e\\|_{\\infty}\\text{ at }N=4].$$\n所有值都必须是实数。$\\sin$ 和 $\\cos$ 中的角度必须是弧度。由于所有量纲均为无量纲，因此不需要单位。最终输出必须是确切要求格式的单行。",
            "solution": "该问题是有效的。它提出了一个清晰、独立且科学上合理的任务：使用切比雪夫配置谱方法求解具有混合边界条件的一维泊松方程。该方法论，包括使用可制造解进行验证，是计算科学与工程领域的标准实践。所有必需的数据、定义和步骤都已明确指定，没有歧义或矛盾。\n\n该方法的核心是在一组配置点上离散化微分方程和边界条件，将问题转化为一个线性代数方程组。然后通过求解该系统获得解。\n\n首先，我们定义计算域和物理域。问题指定物理域为区间 $x \\in [0, 1]$。我们使用一个标准仿射映射将其关联到典范切比雪夫域 $\\xi \\in [-1, 1]$：\n$$x(\\xi) = \\frac{\\xi + 1}{2}$$\n配置点是切比雪夫-高斯-洛巴托（CGL）点，由 $\\xi_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$ 给出，其中 $j=0, 1, \\dots, N$。请注意，在此标准索引下，$\\xi_0=1$ 对应于 $x=1$，而 $\\xi_N=-1$ 对应于 $x=0$。\n\n关于 $x$ 的导数通过链式法则与关于 $\\xi$ 的导数相关联：\n$$ \\frac{d}{dx} = \\frac{d\\xi}{dx} \\frac{d}{d\\xi} = 2 \\frac{d}{d\\xi} $$\n$$ \\frac{d^2}{dx^2} = 4 \\frac{d^2}{d\\xi^2} $$\n在谱配置法中，微分通过矩阵-向量乘法执行。我们在 CGL 网格 $\\{\\xi_j\\}$ 上构建 $(N+1) \\times (N+1)$ 的切比雪夫微分矩阵 $D$。问题为其元素 $D_{ij}$ 提供了显式公式。物理域中的离散一阶和二阶导数算子 $D^{(1)}_x$ 和 $D^{(2)}_x$ 则由下式给出：\n$$ D^{(1)}_x = 2D $$\n$$ D^{(2)}_x = 4D^2 $$\n\n任务是找到一个近似解值向量 $U$，其中 $U_j \\approx u(x_j)$，在配置点 $x_j = x(\\xi_j)$ 上。该向量是线性系统 $A U = b$ 的解，其中矩阵 $A$ 和向量 $b$ 在配置点上施加控制方程和边界条件。\n\n系统构建如下：\n1.  **内部点 ($j=1, \\dots, N-1$)：** 在这些点上，我们施加泊松方程 $-\\Delta u = f$，即 $-u''(x_j) = f(x_j)$。在离散形式下，这是 $-[D^{(2)}_x U]_j = f(x_j)$。这些方程填充系统 $A U = b$ 的第 $1$ 行到第 $N-1$ 行。\n\n2.  **$x=1$ 处的诺伊曼边界 ($j=0$)：** 在此点，我们施加条件 $\\partial_x u(1) = g_N$。在离散形式下，$[D^{(1)}_x U]_0 = g_N$。该方程填充系统的第 $0$ 行。\n\n3.  **$x=0$ 处的狄利克雷边界 ($j=N$)：** 在此点，我们施加 $u(0) = g_D$。这是通过直接设置未知数的值 $U_N = g_D$ 来完成的。这是通过将矩阵 $A$ 的第 $N$ 行替换为单位行（除第 $N$ 列为 $1$ 外全为零），并将右端向量 $b$ 的相应元素设置为 $g_D$ 来施加的。\n\n在组装 $(N+1) \\times (N+1)$ 矩阵 $A$ 和右端向量 $b$ 之后，使用标准线性求解器求解系统 $A U = b$ 以获得未知向量 $U$。\n\n为验证此方法，我们使用可制造解法。我们选择一个光滑函数 $u(x)$，然后推导相应的源项 $f(x) = -u''(x)$ 和边界数据 $g_D = u(0)$ 和 $g_N=u'(1)$。然后，可以将数值解 $U$ 与在配置点上求值的已知精确解 $u(x)$ 进行比较。对于解析解 $u(x)$，谱方法预期会表现出指数收敛性，即误差 $\\|e\\|_\\infty = \\max_j |U_j - u(x_j)|$ 随 $N$ 指数衰减。通过观察 $\\log_{10}(\\|e\\|_\\infty)$ 近似为 $N$ 的线性函数来验证这一点。我们通过执行最小二乘线性回归来量化此关系，以找到斜率 $b$ 和决定系数 $R^2$。一个大的负斜率和一个接近 $1$ 的 $R^2$ 值证实了指数收敛性。\n\n指定的测试用例涉及两种不同的可制造解、收敛性指标的计算、边界条件残差的检查以及对小 $N$ 值的误差评估。边界残差 $r_D = |u_{\\text{num}}(0) - g_D|$ 和 $r_N = |\\partial_x u_{\\text{num}}(1) - g_N|$ 作为一种合理性检查，以确保线性系统正确地施加了边界条件。考虑到施加方法，这些残差预期会接近机器精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef linear_regression(x_data, y_data):\n    \"\"\"\n    Performs a linear regression y = a + b*x and calculates R^2.\n    \"\"\"\n    x_data = np.asarray(x_data)\n    y_data = np.asarray(y_data)\n\n    # Use numpy.polyfit to get slope and intercept\n    slope, intercept = np.polyfit(x_data, y_data, 1)\n    \n    # Calculate R-squared value\n    y_mean = np.mean(y_data)\n    y_predicted = slope * x_data + intercept\n    ss_total = np.sum((y_data - y_mean)**2)\n    ss_residual = np.sum((y_data - y_predicted)**2)\n    \n    if ss_total == 0:\n        # Handle case where all y_data points are the same\n        r_squared = 1.0 if ss_residual == 0 else 0.0\n    else:\n        r_squared = 1.0 - (ss_residual / ss_total)\n        \n    return slope, r_squared\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the Chebyshev differentiation matrix D on N+1 CGL points.\n    \"\"\"\n    if N == 0:\n        return np.zeros((1, 1))\n    \n    j = np.arange(N + 1)\n    xi = np.cos(np.pi * j / N)\n    \n    c = np.ones(N + 1)\n    c[0] = 2.\n    c[N] = 2.\n    \n    # Off-diagonal entries\n    c_i = c[:, np.newaxis]\n    c_j = c[np.newaxis, :]\n    xi_i = xi[:, np.newaxis]\n    xi_j = xi[np.newaxis, :]\n    d_xi = xi_i - xi_j\n    \n    signs = (-1)**(np.arange(N + 1)[:, np.newaxis] + np.arange(N + 1)[np.newaxis, :])\n    \n    D = (c_i / c_j) * signs / (d_xi + np.eye(N + 1))\n    np.fill_diagonal(D, 0.)\n    \n    # Diagonal entries\n    np.fill_diagonal(D, -np.sum(D, axis=1))\n    \n    return D\n\ndef solve_poisson_1d(N, u_func, f_func, g_D_val, g_N_val):\n    \"\"\"\n    Solves the 1D Poisson BVP using Chebyshev collocation.\n    \"\"\"\n    j = np.arange(N + 1)\n    xi = np.cos(np.pi * j / N)\n    x = (xi + 1.0) / 2.0\n    \n    D = chebyshev_diff_matrix(N)\n    D1x = 2.0 * D\n    D2x = 4.0 * np.dot(D, D)\n\n    A = np.zeros((N + 1, N + 1))\n    b = np.zeros(N + 1)\n    \n    # Interior points: -u'' = f\n    A[1:N, :] = -D2x[1:N, :]\n    b[1:N] = f_func(x[1:N])\n    \n    # Neumann BC at x=1 (j=0)\n    A[0, :] = D1x[0, :]\n    b[0] = g_N_val\n    \n    # Dirichlet BC at x=0 (j=N)\n    A[N, :] = 0.0\n    A[N, N] = 1.0\n    b[N] = g_D_val\n    \n    U_num = np.linalg.solve(A, b)\n    U_exact = u_func(x)\n    \n    error = np.max(np.abs(U_num - U_exact))\n    \n    return {\n        \"error\": error,\n        \"U_num\": U_num,\n        \"D1x\": D1x,\n    }\n\ndef solve():\n    \"\"\"\n    Main function to execute all test cases and print results.\n    \"\"\"\n    # Manufactured solution 1\n    u1 = lambda x: np.exp(x) * np.sin(2. * np.pi * x)\n    u1_prime = lambda x: np.exp(x) * (np.sin(2. * np.pi * x) + 2. * np.pi * np.cos(2. * np.pi * x))\n    f1 = lambda x: -np.exp(x) * ( (1. - 4. * np.pi**2) * np.sin(2. * np.pi * x) + 4. * np.pi * np.cos(2. * np.pi * x) )\n    g_D1 = u1(0.0)\n    g_N1 = u1_prime(1.0)\n\n    # Manufactured solution 2\n    u2 = lambda x: np.cosh(3. * x) + np.cos(5. * x)\n    u2_prime = lambda x: 3. * np.sinh(3. * x) - 5. * np.sin(5. * x)\n    f2 = lambda x: -(9. * np.cosh(3. * x) - 25. * np.cos(5. * x))\n    g_D2 = u2(0.0)\n    g_N2 = u2_prime(1.0)\n    \n    # Test case A: u1, N = {8, 16, 32, 64}\n    Ns_A = np.array([8, 16, 32, 64])\n    errors_A = []\n    for N in Ns_A:\n        result = solve_poisson_1d(N, u1, f1, g_D1, g_N1)\n        errors_A.append(result[\"error\"])\n    log_errors_A = np.log10(np.array(errors_A))\n    b_A, R2_A = linear_regression(Ns_A, log_errors_A)\n    error_N64_A = errors_A[-1]\n\n    # Test case B: u2, N = {6, 12, 24, 48}\n    Ns_B = np.array([6, 12, 24, 48])\n    errors_B = []\n    for N in Ns_B:\n        result = solve_poisson_1d(N, u2, f2, g_D2, g_N2)\n        errors_B.append(result[\"error\"])\n    log_errors_B = np.log10(np.array(errors_B))\n    b_B, R2_B = linear_regression(Ns_B, log_errors_B)\n    \n    # Test case C: u1, N=32, boundary residuals\n    N_C = 32\n    result_C = solve_poisson_1d(N_C, u1, f1, g_D1, g_N1)\n    U_num_C = result_C[\"U_num\"]\n    D1x_C = result_C[\"D1x\"]\n    # Dirichlet residual at x=0 (index N)\n    r_D = np.abs(U_num_C[-1] - g_D1)\n    # Neumann residual at x=1 (index 0)\n    du_dx_at_1_num = (D1x_C @ U_num_C)[0]\n    r_N = np.abs(du_dx_at_1_num - g_N1)\n    \n    # Test case D: u1, N=4, error\n    N_D = 4\n    result_D = solve_poisson_1d(N_D, u1, f1, g_D1, g_N1)\n    error_N4_D = result_D[\"error\"]\n    \n    final_results = [b_A, R2_A, error_N64_A, b_B, R2_B, r_D, r_N, error_N4_D]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}