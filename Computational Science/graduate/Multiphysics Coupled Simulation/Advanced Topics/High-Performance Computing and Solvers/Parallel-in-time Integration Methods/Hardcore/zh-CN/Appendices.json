{
    "hands_on_practices": [
        {
            "introduction": "这个首次实践旨在通过一个具体的数值算例，揭开 Parareal 算法的神秘面纱。通过手动计算一个完整的迭代过程，你将直观地理解粗略 (coarse) 传播算子和精细 (fine) 传播算子如何相互作用，以及校正项如何逐步修正解。这项练习将为你后续学习更抽象的概念打下坚实的基础。",
            "id": "2158974",
            "problem": "Parareal算法是一种时间并行积分方法，旨在加速初值问题（IVP）的求解。该算法将总时间区间 $[T_0, T_{final}]$ 划分为 $N$ 个更小的子区间 $[T_n, T_{n+1}]$，其中 $T_n = T_0 + n \\Delta T$ 且 $\\Delta T = (T_{final}-T_0)/N$。然后，它使用两种数值求解器：一个计算开销小但不精确的粗略求解器 $\\mathcal{G}$，以及一个计算开销大但精确的精细求解器 $\\mathcal{F}$。\n\nParareal方法的核心是一种迭代校正方案。从所有时间点 $T_n$ 处解的初始猜测（记为 $y_n^0$）开始，每次迭代 $k$ 都将解的值从 $y_n^k$ 精化到 $y_n^{k+1}$。在第 $n$ 个子区间末端，解 $y_{n+1}^{k+1}$ 的更新由以下公式给出：\n$$y_{n+1}^{k+1} = \\mathcal{G}(T_{n+1}, T_n, y_n^{k+1}) + \\left[ \\mathcal{F}(T_{n+1}, T_n, y_n^k) - \\mathcal{G}(T_{n+1}, T_n, y_n^k) \\right]$$\n此处，$\\mathcal{S}(T_b, T_a, y_{init})$ 表示在时间区间 $[T_a, T_b]$ 上，以初始条件 $y(T_a) = y_{init}$ 应用求解器 $\\mathcal{S}$ 所得到的结果。方括号中的项是校正项。请注意，右侧的粗略求解器 $\\mathcal{G}$ 是从新计算出的值 $y_n^{k+1}$ 开始进行传播计算的。在迭代 $k=0$ 时，整个轨迹的初始猜测是通过顺序应用粗略求解器生成的：$y_{n+1}^0 = \\mathcal{G}(T_{n+1}, T_n, y_n^0)$，从真实的初始条件 $y_0^0 = y_0$ 开始。\n\n考虑由以下常微分方程给出的逻辑斯谛增长初值问题：\n$$y'(t) = \\rho y(t) \\left(1 - \\frac{y(t)}{K}\\right)$$\n参数为 $\\rho = 0.5$，$K = 100$，初始条件为 $y(0) = 10$。我们需要在时间区间 $[0, 2]$ 上求解此初值问题。\n\n时间区间被划分为 $N=2$ 个子区间：$[0, 1]$ 和 $[1, 2]$。因此，$T_0=0$，$T_1=1$，$T_2=2$，粗略时间步长为 $\\Delta T = 1$。\n\n粗略求解器 $\\mathcal{G}$ 是前向欧拉法，它在每个子区间上进行一个大小为 $\\Delta T$ 的单步计算：\n$$\\mathcal{G}(T_{n+1}, T_n, y_n) = y_n + \\Delta T \\cdot f(T_n, y_n)$$\n其中 $f(t,y) = y'(t)$。\n\n精细求解器 $\\mathcal{F}$ 是经典的四阶龙格-库塔 (RK4) 方法。要跨越一个宽度为 $\\Delta T=1$ 的子区间，它需要走两个步长为 $\\delta t = 0.5$ 的步。从时间 $t_i$ 到 $t_{i+1} = t_i + \\delta t$，值为 $y_i$ 的单个 RK4 步的更新由以下公式给出：\n$$y_{i+1} = y_i + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$\n其中\n$k_1 = \\delta t \\cdot f(t_i, y_i)$\n$k_2 = \\delta t \\cdot f(t_i + \\frac{\\delta t}{2}, y_i + \\frac{k_1}{2})$\n$k_3 = \\delta t \\cdot f(t_i + \\frac{\\delta t}{2}, y_i + \\frac{k_2}{2})$\n$k_4 = \\delta t \\cdot f(t_i + \\delta t, y_i + k_3)$\n\n您的任务是计算在第一次 parareal 校正后，于 $t=T_2=2$ 处的数值解的值，即求出 $y_2^1$ 的值。请将最终答案四舍五入到四位有效数字。",
            "solution": "我们求解初值问题 $y'(t)=\\rho y(t)\\left(1-\\frac{y(t)}{K}\\right)$，其中 $\\rho=0.5$，$K=100$，$y(0)=10$，区间为 $[0,2]$，划分为 $N=2$ 个子区间，$\\Delta T=1$。定义 $f(t,y)=\\rho y\\left(1-\\frac{y}{K}\\right)=0.5y-0.005y^{2}$。Parareal 更新公式为\n$$\ny_{n+1}^{k+1}=\\mathcal{G}(T_{n+1},T_{n},y_{n}^{k+1})+\\left[\\mathcal{F}(T_{n+1},T_{n},y_{n}^{k})-\\mathcal{G}(T_{n+1},T_{n},y_{n}^{k})\\right]\n$$\n其中 $\\mathcal{G}$ 是步长为 $\\Delta T=1$ 的前向欧拉步：\n$$\n\\mathcal{G}(T_{n+1},T_{n},y_{n})=y_{n}+f(T_{n},y_{n})\n$$\n而 $\\mathcal{F}$ 是在每个子区间上使用两步（步长 $\\delta t=0.5$）的 RK4 方法。从 $t_{i}$ 到 $t_{i+1}=t_{i}+\\delta t$，值为 $y_{i}$ 的一个 RK4 步为\n$$\n\\begin{aligned}\nk_{1}=\\delta t\\,f(t_{i},y_{i}) \\\\\nk_{2}=\\delta t\\,f\\!\\left(t_{i}+\\tfrac{\\delta t}{2},\\,y_{i}+\\tfrac{k_{1}}{2}\\right) \\\\\nk_{3}=\\delta t\\,f\\!\\left(t_{i}+\\tfrac{\\delta t}{2},\\,y_{i}+\\tfrac{k_{2}}{2}\\right) \\\\\nk_{4}=\\delta t\\,f\\!\\left(t_{i}+\\delta t,\\,y_{i}+k_{3}\\right) \\\\\ny_{i+1}=y_{i}+\\tfrac{1}{6}\\left(k_{1}+2k_{2}+2k_{3}+k_{4}\\right)\n\\end{aligned}\n$$\n\n第1步：初始粗略轨迹（$k=0$）。当 $y_{0}^{0}=10$ 且 $\\Delta T=1$ 时，\n$$\ny_{1}^{0}=\\mathcal{G}(1,0,10)=10+f(0,10)=10+\\left(0.5\\cdot 10-0.005\\cdot 10^{2}\\right)=10+4.5=14.5\n$$\n$$\n\\begin{aligned}\nf(1,14.5)=0.5\\cdot 14.5-0.005\\cdot(14.5)^{2}=7.25-1.05125=6.19875 \\\\\ny_{2}^{0}=\\mathcal{G}(2,1,14.5)=14.5+6.19875=20.69875\n\\end{aligned}\n$$\n\n第2步：在 $n=0$ 处的第一次 parareal 校正得到\n$$\ny_{1}^{1}=\\mathcal{G}(1,0,y_{0}^{1})+\\left[\\mathcal{F}(1,0,y_{0}^{0})-\\mathcal{G}(1,0,y_{0}^{0})\\right]=\\mathcal{F}(1,0,10)\n$$\n因此我们用具有两个半步长的 RK4 方法来计算 $\\mathcal{F}(1,0,10)$。\n\n子区间 $[0,0.5]$，从 $y=10$ 开始：\n$$\n\\delta t=0.5,\\quad k_{1}=0.5\\,f(0,10)=0.5\\cdot 4.5=2.25\n$$\n$$\nk_{2}=0.5\\,f\\!\\left(0.25,\\,10+\\tfrac{2.25}{2}\\right)=0.5\\,f(11.125)=0.5\\cdot 4.943671875=2.4718359375\n$$\n$$\nk_{3}=0.5\\,f\\!\\left(0.25,\\,10+\\tfrac{2.4718359375}{2}\\right)=0.5\\,f(11.23591796875)\\approx 2.49336486068625\n$$\n$$\nk_{4}=0.5\\,f\\!\\left(0.5,\\,10+2.49336486068625\\right)=0.5\\,f(12.49336486068625)\\approx 2.73313080137868\n$$\n$$\ny(0.5)=10+\\tfrac{1}{6}\\left(2.25+2\\cdot 2.4718359375+2\\cdot 2.49336486068625+2.73313080137868\\right)\\approx 12.4855887329585\n$$\n\n子区间 $[0.5,1]$，从 $y\\approx 12.4855887329585$ 开始：\n$$\nk_{1}=0.5\\,f(12.4855887329585)\\approx 2.73167236817963,\\quad\nk_{2}=0.5\\,f(13.8514249170483)\\approx 2.98320129867894\n$$\n$$\nk_{3}=0.5\\,f(13.9771893822979)\\approx 3.00589278881362,\\quad\nk_{4}=0.5\\,f(15.4914815217721)\\approx 3.27290538106303\n$$\n$$\ny(1)=12.4855887329585+\\tfrac{1}{6}\\left(2.73167236817963+2\\cdot 2.98320129867894+2\\cdot 3.00589278881362+3.27290538106303\\right)\\approx 15.4827163869965\n$$\n因此 $y_{1}^{1}\\approx 15.4827163869965$。\n\n第3步：使用 $y_{1}^{0}=14.5$ 计算在 $[1,2]$ 上的方括号项：\n我们需要计算 $\\mathcal{F}(2,1,14.5)$ 和 $\\mathcal{G}(2,1,14.5)=20.69875$。\n\n从 $y=14.5$ 开始，应用具有两个半步长的 RK4 方法。\n\n子区间 $[1,1.5]$，从 $y=14.5$ 开始：\n$$\nk_{1}=0.5\\,f(14.5)=3.099375,\\quad\nk_{2}=0.5\\,f(16.0496875)\\approx 3.36844070288086\n$$\n$$\nk_{3}=0.5\\,f(16.1842203514404)\\approx 3.39123261690612,\\quad\nk_{4}=0.5\\,f(17.8912326169061)\\approx 3.67256764286451\n$$\n$$\ny(1.5)=14.5+\\tfrac{1}{6}\\left(3.099375+2\\cdot 3.36844070288086+2\\cdot 3.39123261690612+3.67256764286451\\right)\\approx 17.8818815470731\n$$\n\n子区间 $[1.5,2]$，从 $y\\approx 17.8818815470731$ 开始：\n$$\nk_{1}=0.5\\,f(17.8818815470731)\\approx 3.67106616760706,\\quad\nk_{2}=0.5\\,f(19.7174146308766)\\approx 3.95741255839837\n$$\n$$\nk_{3}=0.5\\,f(19.8605878262723)\\approx 3.97903958455471,\\quad\nk_{4}=0.5\\,f(21.8609211316278)\\approx 4.27048060109804\n$$\n$$\ny(2)=17.8818815470731+\\tfrac{1}{6}\\left(3.67106616760706+2\\cdot 3.95741255839837+2\\cdot 3.97903958455471+4.27048060109804\\right)\\approx 21.8509567228416\n$$\n因此 $\\mathcal{F}(2,1,14.5)\\approx 21.8509567228416$ 且方括号中的项为\n$$\n\\mathcal{F}(2,1,14.5)-\\mathcal{G}(2,1,14.5)\\approx 21.8509567228416-20.69875=1.1522067228416\n$$\n\n第4步：在 $n=1$ 处的第一次 parareal 校正：\n计算 $\\mathcal{G}(2,1,y_{1}^{1})=y_{1}^{1}+f(y_{1}^{1})$，其中 $y_{1}^{1}\\approx 15.4827163869965$。\n$$\nf(15.4827163869965)=0.5\\cdot 15.4827163869965-0.005\\cdot(15.4827163869965)^{2}\\approx 6.54278565989877\n$$\n$$\n\\mathcal{G}(2,1,y_{1}^{1})\\approx 15.4827163869965+6.54278565989877=22.0255020468953\n$$\n因此，\n$$\ny_{2}^{1}=\\mathcal{G}(2,1,y_{1}^{1})+\\left[\\mathcal{F}(2,1,y_{1}^{0})-\\mathcal{G}(2,1,y_{1}^{0})\\right]\\approx 22.0255020468953+1.1522067228416=23.1777087697369\n$$\n\n四舍五入到四位有效数字，$y_{2}^{1}\\approx 23.18$。",
            "answer": "$$\\boxed{23.18}$$"
        },
        {
            "introduction": "在理解了 Parareal 算法的运作机制之后，下一个关键问题是：这个算法是否收敛到正确的解？本实践将通过分析其在标准线性测试问题上的行为，深入探讨 Parareal 的收敛理论。通过推导误差放大因子，你将看到粗略和精细求解器的选择如何直接影响迭代的稳定性和收敛速度。",
            "id": "1126848",
            "problem": "Parareal 算法是一种时间并行积分方法，旨在求解形式为 $y'(t) = f(y(t), t)$ 的初值问题 (IVP)。时间域 $[T_0, T_f]$ 被划分为 $N$ 个等长 $\\Delta T = T_{n+1} - T_n$ 的粗略时间区间 $[T_n, T_{n+1}]$。该算法在粗略时间点上迭代逼近解 $U_n \\approx y(T_n)$。\n\n令 $\\mathcal{G}(T_{n+1}, T_n, V)$ 表示一个低成本、低精度的**粗略传播算子**，它从 $T_n$ 处的初值 $V$ 开始，逼近 $T_{n+1}$ 处的解。类似地，令 $\\mathcal{F}(T_{n+1}, T_n, V)$ 表示一个高成本、高精度的**精细传播算子**。Parareal 迭代（以 $k$ 为索引）根据以下公式更新近似解 $U_n^k$：\n$$\nU_{n+1}^{k+1} = \\mathcal{G}(T_{n+1}, T_n, U_n^{k+1}) + \\mathcal{F}(T_{n+1}, T_n, U_n^k) - \\mathcal{G}(T_{n+1}, T_n, U_n^k)\n$$\n迭代从一个初始猜测 $U_n^0$ 开始，该猜测通过串行应用粗略传播算子得到：$U_{n+1}^0 = \\mathcal{G}(T_{n+1}, T_n, U_n^0)$。\n\n考虑将 Parareal 算法应用于线性测试问题 $y'(t) = \\lambda y(t)$，其中 $\\lambda$ 是一个复常数。令粗略传播算子 $\\mathcal{G}$ 为在粗略时间区间 $\\Delta T$ 上的单步**前向欧拉法**。令精细传播算子 $\\mathcal{F}$ 由 $M$ 步**后向欧拉法**组成，每步的精细时间步长为 $\\Delta t = \\Delta T / M$。\n\n该算法的收敛性可以通过研究误差相对于串行计算的精细解 $\\epsilon_n^k = U_n^k - U_n^*$ 的演化来分析。对于线性测试问题，对时间切片索引 $n$ 应用 z 变换（即 $\\hat{\\epsilon}^k(z) = \\sum_{n=0}^{\\infty} \\epsilon_n^k z^{-n}$）表明，误差从一次迭代到下一次迭代根据关系式 $\\hat{\\epsilon}^{k+1}(z) = \\rho(z) \\hat{\\epsilon}^k(z)$ 进行变换。函数 $\\rho(z)$ 是**误差放大因子**，其大小决定了 Parareal 迭代的收敛性。\n\n确定此特定 Parareal 设置的误差放大因子 $\\rho(z)$。请用 z 变换变量 $z$、问题参数 $\\lambda$、粗略时间步长 $\\Delta T$ 和精细步数 $M$ 来表示你的答案。",
            "solution": "1. 对于 $y'= \\lambda y$ 在 $\\Delta T$ 上的粗略和精细传播算子：\n   $$g = \\mathcal{G} = 1 + \\lambda\\,\\Delta T$$\n   $$f = \\mathcal{F} = \\Bigl(1 - \\lambda\\,\\tfrac{\\Delta T}{M}\\Bigr)^{-M}$$\n\n2. 对于 $E_n^k = U_n^k - U_n^*$ 的 Parareal 误差迭代：\n   $$E_{n+1}^{\\,k+1} = g\\,E_n^{\\,k+1} + (f - g)\\,E_n^k$$\n\n3. 进行 z 变换 $\\hat E^k(z)=\\sum_{n\\ge0}E_n^k\\,z^{-n}$，并使用 $E_0^k=0$，\n   $$\n     z \\hat E^{\\,k+1}(z)\n     = g\\,\\hat E^{\\,k+1}(z)\n       + (f-g)\\,\\hat E^k(z)\n   $$\n\n   整理得，\n   $$(z - g)\\,\\hat E^{\\,k+1}(z) = (f-g)\\,\\hat E^k(z)$$\n\n4. 因此，误差放大因子为\n   $$\\rho(z) = \\frac{\\hat E^{\\,k+1}(z)}{\\hat E^k(z)}\n               = \\frac{f-g}{\\,z - g\\,}$$\n\n5. 代入 $f$ 和 $g$，\n   $$\\rho(z)\n     = \\frac{\\,(1 - \\frac{\\lambda\\,\\Delta T}{M})^{-M} - (1 + \\lambda\\,\\Delta T)\\,}\n            {\\,z - (1 + \\lambda\\,\\Delta T)\\,}$$",
            "answer": "$$\\boxed{\\frac{\\bigl(1 - \\tfrac{\\lambda\\Delta T}{M}\\bigr)^{-M} - \\bigl(1 + \\lambda\\Delta T\\bigr)}{z - \\bigl(1 + \\lambda\\Delta T\\bigr)}}$$"
        },
        {
            "introduction": "并行算法的最终目标是实现加速。最后一个实践将我们的焦点从正确性和收敛性转移到性能上。你将推导 Parareal 算法可实现的加速比的理论上限，揭示在传播算子的计算成本、处理器数量以及收敛所需的迭代次数之间的根本权衡。",
            "id": "3329274",
            "problem": "您正在对一个非定常计算流体动力学 (CFD) 模拟进行建模，该模拟的时间区间被划分为 $N_t$ 个连续的时间片。Parareal 算法使用一个粗略传播算子 $G$ 和一个精细传播算子 $F$ 来加速时间积分，其方法是利用跨时间片的并行性。粗略传播算子 $G$ 是一个稳定、低精度的时间积分器，而精细传播算子 $F$ 是一个高精度的时间积分器，它定义了目标串行解。设单次应用 $G$ 推进一个时间片的计算成本为 $t_G$，单次应用 $F$ 的计算成本为 $t_F$，且 $t_F \\gg t_G$。假设一个由 $P=N_t$ 个相同处理器组成的同构平台专用于时间并行执行，通信和同步开销可忽略不计，且负载完美均衡。\n\n(a) 定义在 $N_t$ 个时间片上使用粗略传播算子 $G$ 和精细传播算子 $F$ 的 Parareal 算法，包括表达在第 $k$ 次迭代时迭代量 $\\{y_n^{k}\\}_{n=0}^{N_t}$ 更新的初始化和迭代步骤。\n\n(b) 从并行性能建模的第一性原理出发，使用并行机上加速比 $S$、功 (work) 和跨度 (span) 的标准定义，推导经过 $K$ 次 Parareal 迭代后可实现加速比的一个严格上界。具体来说，从以下几点出发：\n- 仅使用精细算子的串行执行时间，\n- 基于功守恒原理和 $P=N_t$ 个处理器的 Parareal 并行执行时间的下界，\n- 以及算法依赖结构所导致的因果关系约束，\n然后根据需要放宽这个界限，以证明加速比 $S$ 满足\n$$\nS \\leq \\frac{N_t\\, t_F}{\\,t_G + \\frac{t_F}{K}\\,}\n$$\n\n您的推导不得假定任何超出功和依赖约束所隐含的未说明的计算重叠，并且必须明确证明用于放宽界限的每个不等式的合理性。将您的最终答案表示为关于 $N_t$、$t_F$、$t_G$ 和 $K$ 的单个解析表达式。不需要进行数值计算，最终表达式中也无需单位。",
            "solution": "** (a) Parareal 算法的定义**\n\n设问题为对常微分方程组 (ODE) $u'(t) = f(u(t), t)$ 在区间 $[T_0, T_{end}]$ 上进行时间积分，给定初始条件 $u(T_0) = u_0$。该时间区间被划分为 $N_t$ 个连续的子区间，或称时间片，$[T_{n-1}, T_n]$，其中 $n=1, \\dots, N_t$。\n\nParareal 算法使用两个传播算子来近似每个时间片末端的解 $u(T_n)$：\n1.  一个**精细传播算子** $F$，其计算成本高（每个时间片成本为 $t_F$）但保真度高。串行解由 $F$ 的连续应用定义：$y_n = F(y_{n-1})$。\n2.  一个**粗略传播算子** $G$，其计算成本低（每个时间片成本为 $t_G$，且 $t_G \\ll t_F$）但保真度低。\n\n令 $y_n^k$ 为 Parareal 算法第 $k$ 次迭代时解 $u(T_n)$ 的近似值。该算法按以下步骤进行：\n\n**1. 初始化 ($k=0$):**\n使用粗略传播算子顺序计算跨所有时间片的初始近似解。这为迭代校正过程提供了一个初始猜测。\n$$\ny_0^0 = u_0\n$$\n$$\ny_n^0 = G(y_{n-1}^0) \\quad \\text{for } n = 1, 2, \\dots, N_t\n$$\n这一步本质上是串行的，执行了 $N_t$ 次粗略求解。\n\n**2. 迭代 (对于 $k=0, 1, \\dots, K-1$):**\n对于每次迭代 $k$，算法会校正前一次的近似解 $y_n^k$ 以产生新的近似解 $y_n^{k+1}$。这包含两个主要步骤：\n\n*   **步骤 2a (并行精细求解)：** 在所有 $N_t$ 个时间片上同时应用高成本的精细传播算子 $F$。处理器 $n$ 从上一次迭代的解 $y_{n-1}^k$ 开始，计算在时间片 $[T_{n-1}, T_n]$ 上的精细解。由于有 $P=N_t$ 个处理器，每个处理器被分配一个时间片，所有精细求解都并行执行。\n*   **步骤 2b (串行校正)：** 来自并行精细求解的结果用于校正下一次的粗略传播。下一次迭代的状态 $y_n^{k+1}$ 的更新公式为：\n    $$\n    y_n^{k+1} = G(y_{n-1}^{k+1}) + F(y_{n-1}^k) - G(y_{n-1}^k)\n    $$\n    该公式可以解释为用粗略求解器 $G(y_{n-1}^{k+1})$ 传播解，然后加上一个校正项 $F(y_{n-1}^k) - G(y_{n-1}^k)$。该校正项是前一个时间片上更精确的精细解（在步骤 2a 中计算）与用于生成第 $k$ 次迭代量的粗略解之间的差值。注意对 $y_{n-1}^{k+1}$ 的依赖性，这使得该校正步骤在时间片之间是串行的。\n\n经过 $K$ 次迭代后，最终的近似解为 $\\{y_n^K\\}_{n=0}^{N_t}$。\n\n**(b) 加速比上界的推导**\n\n加速比 $S$ 定义为串行执行时间与并行执行时间的比值，即 $S = \\frac{T_{serial}}{T_{par}(K)}$。为了推导 $S$ 的上界，我们需要一个并行执行时间 $T_{par}(K)$ 的下界。\n\n**1. 串行执行时间 ($T_{serial}$):**\n基准串行执行定义为仅使用高保真度的精细传播算子 $F$ 顺序地处理所有 $N_t$ 个时间片。总时间为：\n$$\nT_{serial} = N_t t_F\n$$\n\n**2. 并行执行时间的下界 ($T_{par}(K)$):**\n我们通过首先计算算法所需的总计算功（work），然后应用功守恒原理来建立并行执行时间的下界。\n\n*   **总功 ($W$):** 总功是算法执行的所有任务的计算成本之和。\n    *   **初始化：** 此步骤涉及 $N_t$ 次对粗略传播算子 $G$ 的顺序应用。其功为 $W_{init} = N_t t_G$。\n    *   **K 次迭代：** $K$ 次迭代中的每一次都涉及：\n        *   $N_t$ 次精细传播算子 $F$ 的应用，每个时间片一次。每次迭代中精细求解的总功是 $N_t t_F$。\n        *   在串行校正步骤中 $N_t$ 次粗略传播算子 $G$ 的应用。每次迭代中粗略求解的总功是 $N_t t_G$。\n    $K$ 次迭代的功为 $W_{iters} = K (N_t t_F + N_t t_G)$。\n    *   **总功：** 整个算法的总功是初始化功和迭代功之和。\n        $$\n        W = W_{init} + W_{iters} = N_t t_G + K N_t (t_F + t_G) = N_t (K t_F + (K+1) t_G)\n        $$\n\n*   **来自功守恒的下界：** 并行计算的一个基本原理是，在 $P$ 个处理器上的并行执行时间 $T_{par}$ 不能小于总功 $W$ 除以 $P$。这得出了一个基于每个处理器平均工作负载的下界。给定 $P = N_t$：\n    $$\n    T_{par}(K) \\ge \\frac{W}{P} = \\frac{N_t (K t_F + (K+1) t_G)}{N_t} = K t_F + (K+1) t_G\n    $$\n    这个界限是算法所需的总功和可用处理器数量的直接结果。\n\n**3. 放宽下界：**\n问题要求一个特定形式的加速比界限，它可能比我们直接从功守恒界限推导出的界限更宽松。我们可以通过放宽 $T_{par}(K)$ 的下界来获得所需的形式。我们已经确立：\n$$\nT_{par}(K) \\ge K t_F + (K+1) t_G\n$$\n我们现在证明 $K t_F + (K+1) t_G \\ge t_G + \\frac{t_F}{K}$，从而将 $t_G + \\frac{t_F}{K}$ 确立为 $T_{par}(K)$ 的一个有效（尽管更弱）的下界。\n\n让我们分别检查各项：\n*   对于涉及 $t_F$ 的项：由于算法要执行任何校正，迭代次数 $K$ 必须至少为 $1$，我们有 $K \\ge 1$。这意味着 $K^2 \\ge 1$，因此 $K \\ge \\frac{1}{K}$。两边乘以 $t_F > 0$ 得到 $K t_F \\ge \\frac{t_F}{K}$。\n*   对于涉及 $t_G$ 的项：由于 $K \\ge 0$，我们有 $K+1 \\ge 1$。两边乘以 $t_G > 0$ 得到 $(K+1) t_G \\ge t_G$。\n\n结合这两个不等式，我们可以为我们基于功的不等式的右侧构建一个更弱的下界：\n$$\nK t_F + (K+1) t_G \\ge \\frac{t_F}{K} + t_G\n$$\n因此，我们成功地放宽了并行时间的下界：\n$$\nT_{par}(K) \\ge t_G + \\frac{t_F}{K}\n$$\n\n**4. 加速比上界的推导：**\n使用加速比的定义 $S = \\frac{T_{serial}}{T_{par}(K)}$，并将 $T_{par}(K)$ 的放宽后的下界代入分母，我们得到 $S$ 的一个上界：\n$$\nS = \\frac{N_t t_F}{T_{par}(K)} \\le \\frac{N_t t_F}{t_G + \\frac{t_F}{K}}\n$$\n这就是可实现加速比上界的期望表达式。",
            "answer": "$$\n\\boxed{\\frac{N_t t_F}{t_G + \\frac{t_F}{K}}}\n$$"
        }
    ]
}