{
    "hands_on_practices": [
        {
            "introduction": "本实践旨在奠定多物理场拓扑优化的基础。通过一个简化的热-力耦合杆系统，您将练习如何将基本的物理定律（如胡克定律和傅里叶定律）与基于密度的惩罚方法（SIMP）相结合，构建一个优化模型。这项练习的核心是推导并求解一阶最优性条件，从而解析地找到最优的材料分布，这对于深入理解理论框架至关重要。",
            "id": "3530728",
            "problem": "考虑一个一维、无量纲化的双物理场设计问题，该问题涉及一根被离散为两个相等有限元（索引为 $i \\in \\{1,2\\}$）的杆，每个单元的长度为 $1$，横截面积为 $1$。该杆在线性弹性学中承受准静态端部力 $F$，并在热传导中承受稳态端部热通量 $Q$。任务是通过两个单元设计密度 $\\rho_{1}$ 和 $\\rho_{2}$，采用固体各向同性材料惩罚 (SIMP) 插值法来分配材料，以在全局体积约束下最小化机械柔度和热柔度的加权和。SIMP 法则为：杨氏模量 $E(\\rho_{i})=\\rho_{i}^{p} E_{0}$，热导率 $k(\\rho_{i})=\\rho_{i}^{p} k_{0}$，其中两个物理场使用相同的惩罚指数 $p$。假设 $\\rho_{i}$ 的下限正则化可忽略不计，因此允许内部解。优化在无量纲化下进行，使得 $A=1$，$L_{i}=1$，$E_{0}=1$，$k_{0}=1$，$F=1$，$Q=1$。\n\n从以下基本原理出发：\n- 线性弹性学中的一维线性动量守恒、Hooke 定律和应变能，以及热传导中的 Fourier 定律和稳态能量平衡。\n- 机械柔度定义为 $F$ 乘以端部位移，热柔度定义为 $Q$ 乘以端部温升，两者均可通过单元属性以一维串联形式表示。\n\n利用这些原理，推导用 $\\rho_{i}$ 和 $p$ 表示的机械柔度和热柔度的一维串联表达式，然后建立加权目标函数\n$$\nJ(\\rho_{1},\\rho_{2})=\\sum_{i=1}^{2}\\left(\\alpha\\,w_{i}\\,C_{\\text{mech},i}(\\rho_{i})+\\beta\\,t_{i}\\,C_{\\text{therm},i}(\\rho_{i})\\right),\n$$\n其中 $w_{i}$ 和 $t_{i}$ 是给定的无量纲空间权重，$\\alpha$ 和 $\\beta$ 是正常数。施加体积约束 $\\rho_{1}+\\rho_{2}=1$ 并假设共同的惩罚指数 $p=3$。\n\n给定具体数据 $\\alpha=1$，$\\beta=1$，$w_{1}=4$，$w_{2}=\\frac{1}{6}$，$t_{1}=\\frac{4}{3}$，$t_{2}=\\frac{1}{6}$，$p=3$，以及上述无量纲化条件，执行以下操作：\n- 使用带有单个体积约束乘子的拉格朗日函数，推导 $(\\rho_{1},\\rho_{2})$ 的一阶必要最优性条件。\n- 显式求解这些条件以获得最优的 $\\rho_{1}$。\n\n将最优 $\\rho_{1}$ 的最终答案表示为精确分数。不包含单位，不要报告不等式或方程，只报告数值。无需四舍五入。",
            "solution": "问题验证如下。\n\n**步骤1：提取已知条件**\n- **领域**：一根一维杆，离散为两个相等的有限元，索引为 $i \\in \\{1,2\\}$。\n- **几何**：每个单元的长度 $L_i=1$，横截面积 $A_i=1$。\n- **物理场**：准静态线性弹性和稳态热传导。\n- **载荷**：一个端部力 $F$ 和一个端部热通量 $Q$。\n- **材料模型**：固体各向同性材料惩罚 (SIMP) 法，杨氏模量为 $E(\\rho_{i})=\\rho_{i}^{p} E_{0}$，热导率为 $k(\\rho_{i})=\\rho_{i}^{p} k_{0}$。\n- **设计变量**：单元材料密度 $\\rho_1$ 和 $\\rho_2$。\n- **目标函数**：最小化柔度的加权和 $J(\\rho_{1},\\rho_{2})=\\sum_{i=1}^{2}\\left(\\alpha\\,w_{i}\\,C_{\\text{mech},i}(\\rho_{i})+\\beta\\,t_{i}\\,C_{\\text{therm},i}(\\rho_{i})\\right)$。\n- **约束**：全局体积约束 $\\rho_1 + \\rho_2 = 1$。\n- **常数和参数**：\n  - 无量纲化：$A=1$，$L_i=1$，$E_0=1$，$k_0=1$，$F=1$，$Q=1$。\n  - 惩罚指数：$p=3$。\n  - 权重因子：$\\alpha=1$，$\\beta=1$。\n  - 空间权重：$w_{1}=4$，$w_{2}=\\frac{1}{6}$，$t_{1}=\\frac{4}{3}$，$t_{2}=\\frac{1}{6}$。\n- **基本原理**：\n  - 线性弹性学的线性动量守恒、Hooke 定律和应变能。\n  - 热传导的 Fourier 定律和稳态能量平衡。\n  - 机械柔度（$F$ 乘以端部位移）和热柔度（$Q$ 乘以端部温升）的定义。\n- **任务**：推导一阶必要最优性条件并求解最优的 $\\rho_1$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题基于连续介质力学（线性和弹性热传导）的基本原理以及结构优化中的标准方法（SIMP）。它在科学上是合理的。\n- **良态问题**：该问题是一个约束优化问题。目标函数是形如 $c \\rho^{-p}$ 的函数之和，对于 $\\rho > 0$ 是凸的。约束是线性的。这种结构通常会产生唯一、稳定的解。该问题是良态的。\n- **客观性**：语言精确，所有参数都已明确给出。没有主观或含糊的术语。\n- **其他缺陷**：在学术优化问题的背景下，该问题是自洽、一致且可行的。它不是不重要的或同义反复的。\n\n**步骤3：结论与行动**\n问题有效。将推导解答。\n\n**解答推导**\n\n首先，我们推导单元柔度的表达式。对于一个由两个串联单元组成的系统，在力学问题中，总力 $F$ 会通过每个单元传递；在热学问题中，总热通量 $Q$ 会流过每个单元。\n\n单元 $i$ 的机械柔度贡献与其应变能相关。一维杆单元的刚度为 $k_{\\text{mech},i} = \\frac{A_i E_i}{L_i}$。系统的总机械柔度是各单元贡献的总和，其中单元 $i$ 的贡献由 $C_{\\text{mech},i} = \\frac{F^2 L_i}{A_i E_i}$ 给出。\n使用 SIMP 法则，$E_i = E(\\rho_i) = \\rho_i^p E_0$。\n因此，$C_{\\text{mech},i}(\\rho_i) = \\frac{F^2 L_i}{A_i \\rho_i^p E_0}$。\n\n类似地，一维单元的热导为 $k_{\\text{therm},i} = \\frac{A_i k_i}{L_i}$。总热柔度是各单元贡献的总和，其中单元 $i$ 的贡献为 $C_{\\text{therm},i} = \\frac{Q^2 L_i}{A_i k_i}$。\n使用 SIMP 法则，$k_i = k(\\rho_i) = \\rho_i^p k_0$。\n因此，$C_{\\text{therm},i}(\\rho_i) = \\frac{Q^2 L_i}{A_i \\rho_i^p k_0}$。\n\n我们应用无量纲化：$A_i=1$，$L_i=1$，$E_0=1$，$k_0=1$，$F=1$，$Q=1$。\n柔度表达式简化为：\n$C_{\\text{mech},i}(\\rho_i) = \\frac{1^2 \\cdot 1}{1 \\cdot \\rho_i^p \\cdot 1} = \\frac{1}{\\rho_i^p} = \\rho_i^{-p}$。\n$C_{\\text{therm},i}(\\rho_i) = \\frac{1^2 \\cdot 1}{1 \\cdot \\rho_i^p \\cdot 1} = \\frac{1}{\\rho_i^p} = \\rho_i^{-p}$。\n\n要最小化的目标函数是：\n$J(\\rho_1, \\rho_2) = \\sum_{i=1}^{2} (\\alpha w_i C_{\\text{mech},i}(\\rho_i) + \\beta t_i C_{\\text{therm},i}(\\rho_i))$。\n代入柔度表达式：\n$J(\\rho_1, \\rho_2) = (\\alpha w_1 + \\beta t_1) \\rho_1^{-p} + (\\alpha w_2 + \\beta t_2) \\rho_2^{-p}$。\n让我们定义灵敏度数 $S_i = \\alpha w_i + \\beta t_i$。目标函数变为：\n$J(\\rho_1, \\rho_2) = S_1 \\rho_1^{-p} + S_2 \\rho_2^{-p}$。\n\n优化问题是：\n最小化 $J(\\rho_1, \\rho_2) = S_1 \\rho_1^{-p} + S_2 \\rho_2^{-p}$\n约束条件为 $g(\\rho_1, \\rho_2) = \\rho_1 + \\rho_2 - 1 = 0$。\n\n我们使用拉格朗日乘子法。拉格朗日函数是：\n$\\mathcal{L}(\\rho_1, \\rho_2, \\lambda) = J(\\rho_1, \\rho_2) + \\lambda g(\\rho_1, \\rho_2) = S_1 \\rho_1^{-p} + S_2 \\rho_2^{-p} + \\lambda(\\rho_1 + \\rho_2 - 1)$。\n\n通过将拉格朗日函数对 $\\rho_1$、$\\rho_2$ 和 $\\lambda$ 的偏导数设为零，可得一阶必要最优性条件：\n1. $\\frac{\\partial \\mathcal{L}}{\\partial \\rho_1} = -p S_1 \\rho_1^{-p-1} + \\lambda = 0 \\implies \\lambda = p S_1 \\rho_1^{-p-1}$。\n2. $\\frac{\\partial \\mathcal{L}}{\\partial \\rho_2} = -p S_2 \\rho_2^{-p-1} + \\lambda = 0 \\implies \\lambda = p S_2 \\rho_2^{-p-1}$。\n3. $\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} = \\rho_1 + \\rho_2 - 1 = 0$。\n\n令拉格朗日乘子 $\\lambda$ 的两个表达式相等：\n$p S_1 \\rho_1^{-p-1} = p S_2 \\rho_2^{-p-1}$\n$S_1 \\rho_1^{-p-1} = S_2 \\rho_2^{-p-1}$\n$\\frac{\\rho_2^{-p-1}}{\\rho_1^{-p-1}} = \\frac{S_1}{S_2}$\n$\\left(\\frac{\\rho_1}{\\rho_2}\\right)^{p+1} = \\frac{S_1}{S_2}$\n$\\frac{\\rho_1}{\\rho_2} = \\left(\\frac{S_1}{S_2}\\right)^{\\frac{1}{p+1}}$。\n\n根据约束条件，我们有 $\\rho_2 = 1 - \\rho_1$。将其代入方程：\n$\\frac{\\rho_1}{1 - \\rho_1} = \\left(\\frac{S_1}{S_2}\\right)^{\\frac{1}{p+1}}$。\n令 $R = \\left(\\frac{S_1}{S_2}\\right)^{\\frac{1}{p+1}}$。则 $\\rho_1 = R(1 - \\rho_1) = R - R\\rho_1$。\n$\\rho_1 (1 + R) = R$。\n$\\rho_1 = \\frac{R}{1+R} = \\frac{\\left(\\frac{S_1}{S_2}\\right)^{\\frac{1}{p+1}}}{1+\\left(\\frac{S_1}{S_2}\\right)^{\\frac{1}{p+1}}}$。\n这也可以写成 $\\rho_1 = \\frac{1}{1 + \\left(\\frac{S_2}{S_1}\\right)^{\\frac{1}{p+1}}}$。\n\n现在，我们代入给定的数值：\n$\\alpha=1$，$\\beta=1$，$p=3$。\n$w_1=4$，$w_2=\\frac{1}{6}$。\n$t_1=\\frac{4}{3}$，$t_2=\\frac{1}{6}$。\n\n首先，计算灵敏度 $S_1$ 和 $S_2$：\n$S_1 = \\alpha w_1 + \\beta t_1 = (1)(4) + (1)(\\frac{4}{3}) = 4 + \\frac{4}{3} = \\frac{12}{3} + \\frac{4}{3} = \\frac{16}{3}$。\n$S_2 = \\alpha w_2 + \\beta t_2 = (1)(\\frac{1}{6}) + (1)(\\frac{1}{6}) = \\frac{1}{6} + \\frac{1}{6} = \\frac{2}{6} = \\frac{1}{3}$。\n\n接下来，计算比率 $\\frac{S_2}{S_1}$：\n$\\frac{S_2}{S_1} = \\frac{1/3}{16/3} = \\frac{1}{3} \\cdot \\frac{3}{16} = \\frac{1}{16}$。\n\n指数为 $\\frac{1}{p+1} = \\frac{1}{3+1} = \\frac{1}{4}$。\n现在计算项 $\\left(\\frac{S_2}{S_1}\\right)^{\\frac{1}{p+1}}$：\n$\\left(\\frac{1}{16}\\right)^{\\frac{1}{4}} = \\frac{1^{1/4}}{16^{1/4}} = \\frac{1}{\\sqrt[4]{16}} = \\frac{1}{2}$。\n\n最后，我们计算最优的 $\\rho_1$：\n$\\rho_1 = \\frac{1}{1 + \\frac{1}{2}} = \\frac{1}{\\frac{3}{2}} = \\frac{2}{3}$。\n\n单元 1 的最优密度为 $\\frac{2}{3}$。因此，单元 2 的最优密度为 $\\rho_2 = 1 - \\rho_1 = 1 - \\frac{2}{3} = \\frac{1}{3}$。两者都是有效的内部解（$0  \\rho_i  1$）。",
            "answer": "$$\\boxed{\\frac{2}{3}}$$"
        },
        {
            "introduction": "在掌握了基本的柔度优化后，下一个挑战是如何处理更复杂的性能要求，例如动态响应和稳定性。本练习将引导您解决一个涉及特征值约束的优化问题，目标是在满足结构振动频率下限的同时，最小化热时间常数。通过这个案例，您将学会如何将与系统稳定性相关的特征值约束整合到拓扑优化框架中，这在航空航天和精密仪器设计等领域尤为重要。",
            "id": "3530732",
            "problem": "一个长度为 $L$、横截面积为 $A$ 的均匀杆状设计域被嵌入到一个耦合热弹性装置中。单个伪密度设计变量 $x \\in [0,1]$ 通过带罚函数的固体各向同性材料（SIMP）模型均匀地缩放局部材料分布。弹性模量、质量密度和导热系数分别被建模为 $E(x) = E_{0} x^{p}$、$\\rho(x) = \\rho_{0} x$ 和 $k(x) = k_{0} x^{q}$，其中 $p$ 和 $q$ 是给定的正常数指数。该装置级别的目标是最小化杆的主导热时间常数，同时保证以基本固有频率的下界表示的最小机械振动稳定性裕度。\n\n使用以下基本原理：\n\n- 对于单自由度集总机械振荡器的牛顿第二定律和胡克定律：如果有效刚度为 $k_{m}(x)$ 且有效质量为 $m(x)$，则自由振动方程为 $m(x) \\ddot{u} + k_{m}(x) u = 0$，其谐波解 $u(t) = U \\exp(\\mathrm{i} \\omega t)$ 意味着 $\\omega^{2}(x) = k_{m}(x)/m(x)$。\n\n- 对于一维热传导的能量守恒与傅里叶定律：在 $X \\in (0,L)$ 上，方程为 $\\rho(x) c \\, \\partial T/\\partial t = k(x) \\, \\partial^{2} T/\\partial X^{2}$，并带有齐次狄利克雷边界条件 $T(0,t) = 0$ 和 $T(L,t) = 0$。变量分离法得到指数衰减模式，其衰减率为 $\\lambda_{n}(x) = (k(x)/(\\rho(x)c)) (n \\pi/L)^{2}$，其中 $n \\in \\mathbb{N}$。主导热时间常数为 $\\tau(x) = 1/\\lambda_{1}(x) = (\\rho(x) c L^{2})/(\\pi^{2} k(x))$。\n\n假设一致的一维有限元缩聚产生有效刚度 $k_{m}(x) = k_{m0} x^{p}$ 和有效集总质量 $m(x) = m_{0} x$，其中 $k_{m0}$ 和 $m_{0}$ 为已知的正常数。假设设计必须满足基于特征值的机械稳定性约束 $\\omega(x) \\ge \\omega_{\\min}$。\n\n给定参数 $p = 3$、$q = \\tfrac{1}{2}$、$k_{m0} = 9$、$m_{0} = 1$ 和 $\\omega_{\\min} = 2$（所有机械量均采用一致的相干单位，且 $c$ 和 $L$ 为任意但固定且为正的常数），利用上述基本定律，构建标量拓扑优化问题\n$$\n\\min_{0 \\le x \\le 1} \\ \\tau(x) \\quad \\text{subject to} \\quad \\omega(x) \\ge \\omega_{\\min},\n$$\n然后，确定解决此问题的最优伪密度 $x^{\\star}$。将您的最终答案 $x^{\\star}$ 表示为一个不带单位的精确数。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。所有提供的信息都具有科学依据、自成体系且提法得当。该问题是一个标准的标量约束优化问题，源于力学和传热的基本原理，并应用于使用带罚函数的固体各向同性材料（SIMP）模型的拓扑优化背景中。\n\n任务是找到解决以下问题的最优伪密度 $x^{\\star}$：\n$$\n\\min_{0 \\le x \\le 1} \\ \\tau(x) \\quad \\text{subject to} \\quad \\omega(x) \\ge \\omega_{\\min}\n$$\n\n首先，我们将目标函数（热时间常数 $\\tau(x)$）和约束函数（固有频率 $\\omega(x)$）用设计变量 $x$ 来表示。\n\n热时间常数由下式给出：\n$$\n\\tau(x) = \\frac{\\rho(x) c L^{2}}{\\pi^{2} k(x)}\n$$\n使用 SIMP 关系式 $\\rho(x) = \\rho_{0} x$ 和 $k(x) = k_{0} x^{q}$，我们将它们代入 $\\tau(x)$ 的表达式中：\n$$\n\\tau(x) = \\frac{(\\rho_{0} x) c L^{2}}{\\pi^{2} (k_{0} x^{q})} = \\left(\\frac{\\rho_{0} c L^{2}}{\\pi^{2} k_{0}}\\right) x^{1-q}\n$$\n括号中的项是一个正常数，我们可以将其表示为 $C_{\\tau} = \\frac{\\rho_{0} c L^{2}}{\\pi^{2} k_{0}}$。要找到最优的 $x$，不需要这个常数的具体值。使用给定参数 $q = \\frac{1}{2}$，目标函数变为：\n$$\n\\tau(x) = C_{\\tau} x^{1 - \\frac{1}{2}} = C_{\\tau} x^{\\frac{1}{2}}\n$$\n\n接下来，我们构建约束条件。固有频率的平方由下式给出：\n$$\n\\omega^{2}(x) = \\frac{k_{m}(x)}{m(x)}\n$$\n问题指明了有效刚度 $k_{m}(x) = k_{m0} x^{p}$ 和有效质量 $m(x) = m_{0} x$。代入这些值得到：\n$$\n\\omega^{2}(x) = \\frac{k_{m0} x^{p}}{m_{0} x} = \\frac{k_{m0}}{m_{0}} x^{p-1}\n$$\n固有频率是该表达式的平方根。由于 $x \\in [0,1]$，我们有：\n$$\n\\omega(x) = \\sqrt{\\frac{k_{m0}}{m_{0}}} x^{\\frac{p-1}{2}}\n$$\n现在我们代入给定的参数值 $p=3$、$k_{m0}=9$ 和 $m_{0}=1$：\n$$\n\\omega(x) = \\sqrt{\\frac{9}{1}} x^{\\frac{3-1}{2}} = 3 x^{\\frac{2}{2}} = 3x\n$$\n机械稳定性约束为 $\\omega(x) \\ge \\omega_{\\min}$。当 $\\omega_{\\min} = 2$ 时，这变为：\n$$\n3x \\ge 2 \\implies x \\ge \\frac{2}{3}\n$$\n\n现在，优化问题可以完全用 $x$ 来陈述：\n最小化 $\\tau(x) = C_{\\tau} x^{\\frac{1}{2}}$\n约束条件为：\n1. $x \\ge \\frac{2}{3}$ （来自机械稳定性）\n2. $0 \\le x \\le 1$ （来自设计变量的定义）\n\n这些约束的交集定义了 $x$ 的可行域。即区间 $x \\in [\\frac{2}{3}, 1]$。\n\n为了找到在这个可行域内使目标函数 $\\tau(x) = C_{\\tau} x^{\\frac{1}{2}}$ 最小化的 $x$ 值，我们分析 $\\tau(x)$ 的行为。我们可以考察它关于 $x$ 的导数：\n$$\n\\frac{d\\tau}{dx} = \\frac{d}{dx} \\left( C_{\\tau} x^{\\frac{1}{2}} \\right) = C_{\\tau} \\left( \\frac{1}{2} x^{-\\frac{1}{2}} \\right) = \\frac{C_{\\tau}}{2\\sqrt{x}}\n$$\n由于 $C_{\\tau} > 0$ 且 $x$ 的可行域为 $[\\frac{2}{3}, 1]$，导数 $\\frac{d\\tau}{dx}$ 在整个可行域上严格为正。这意味着目标函数 $\\tau(x)$ 是一个关于 $x$ 的严格单调递增函数。\n\n为了在一个闭区间上最小化一个严格递增的函数，必须选择该区间内变量的最小值。可行区间是 $[\\frac{2}{3}, 1]$。此区间中的最小值为 $\\frac{2}{3}$。\n\n因此，在满足机械稳定性约束的同时最小化热时间常数的最优伪密度 $x^{\\star}$ 是可行集的下界。\n\n$$\nx^{\\star} = \\frac{2}{3}\n$$",
            "answer": "$$\\boxed{\\frac{2}{3}}$$"
        },
        {
            "introduction": "从理论推导走向计算实现是掌握拓扑优化的关键一步。对于复杂的大规模系统，解析解不再可行，高效的数值方法变得不可或缺。本练习要求您为一个离散化的热-弹性耦合系统推导并编程实现伴随法（adjoint method）梯度计算，并将其与有限差分结果进行验证。这项实践将为您提供宝贵的编码经验，帮助您深刻理解在多物理场背景下计算设计敏感度的核心算法。",
            "id": "3530723",
            "problem": "考虑一个稳态、线性的双场耦合系统，该系统模拟了热弹性相互作用，并采用适合拓扑和形状优化的离散形式。设机械位移向量为 $u \\in \\mathbb{R}^{2}$，温度向量为 $T \\in \\mathbb{R}^{2}$。定义状态向量 $y \\in \\mathbb{R}^{4}$ 为 $y = \\begin{bmatrix} u \\\\ T \\end{bmatrix}$。耦合控制方程以残差形式由下式给出\n$$\nF(y,\\rho) = \\begin{bmatrix} K_u(\\rho)  -B \\\\ -S  K_T(\\rho) \\end{bmatrix} \\begin{bmatrix} u \\\\ T \\end{bmatrix} - \\begin{bmatrix} f_{\\mathrm{ext}} \\\\ q_{\\mathrm{ext}} \\end{bmatrix} = 0,\n$$\n其中 $K_u(\\rho) \\in \\mathbb{R}^{2 \\times 2}$ 和 $K_T(\\rho) \\in \\mathbb{R}^{2 \\times 2}$ 分别为力学和热学的类刚度矩阵，它们依赖于设计向量 $\\rho \\in [0,1]^m$（其中 $m=3$），而 $B \\in \\mathbb{R}^{2 \\times 2}$、$S \\in \\mathbb{R}^{2 \\times 2}$ 是固定的耦合矩阵。外部机械载荷向量为 $f_{\\mathrm{ext}} \\in \\mathbb{R}^{2}$，外部热载荷向量为 $q_{\\mathrm{ext}} \\in \\mathbb{R}^{2}$。\n\n类刚度矩阵通过固体各向同性材料惩罚法（SIMP）插值从单元基组装而成。设机械单元基为\n$$\nK_{u,1} = \\begin{bmatrix} 2  -1 \\\\ -1  2 \\end{bmatrix}, \\quad\nK_{u,2} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}, \\quad\nK_{u,3} = \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix},\n$$\n热单元基为\n$$\nK_{T,1} = \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}, \\quad\nK_{T,2} = \\begin{bmatrix} 2  -1 \\\\ -1  2 \\end{bmatrix}, \\quad\nK_{T,3} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}.\n$$\n对每个单元索引 $i \\in \\{1,2,3\\}$，定义 SIMP 插值\n$$\nE_i(\\rho_i) = E_{\\min} + \\rho_i^p \\left(E_0 - E_{\\min}\\right), \\quad\nk_i(\\rho_i) = k_{\\min} + \\rho_i^p \\left(k_0 - k_{\\min}\\right),\n$$\n从而\n$$\nK_u(\\rho) = \\sum_{i=1}^{3} E_i(\\rho_i) K_{u,i}, \\qquad\nK_T(\\rho) = \\sum_{i=1}^{3} k_i(\\rho_i) K_{T,i}.\n$$\n假设 $E_0 > 0$，$k_0 > 0$，$E_{\\min} > 0$，$k_{\\min} > 0$ 且 $p \\ge 1$。\n\n用于拓扑优化的目标泛函是一个类柔度度量，并增加了热二次项和对设计的线性正则化项：\n$$\nJ(y,\\rho) = f_{\\mathrm{ext}}^{\\top} u + \\gamma \\, T^{\\top} W T + \\eta \\sum_{i=1}^{3} \\rho_i,\n$$\n其中 $W \\in \\mathbb{R}^{2 \\times 2}$ 是对称正定矩阵，且 $\\gamma > 0$，$\\eta > 0$。\n\n您的任务是：\n- 从第一性原理推导 $J(y(\\rho),\\rho)$ 相对于设计 $\\rho$ 的离散伴随法梯度，其中 $y(\\rho)$ 是 $F(y,\\rho) = 0$ 的解。使用拉格朗日量 $L(y,\\rho,\\lambda) = J(y,\\rho) + \\lambda^{\\top} F(y,\\rho)$ 和条件\n$$\n\\left(\\frac{\\partial F}{\\partial y}(y,\\rho)\\right)^{\\top} \\lambda + \\frac{\\partial J}{\\partial y}(y,\\rho) = 0\n$$\n来定义伴随向量 $\\lambda \\in \\mathbb{R}^{4}$，并用 $y$、$\\lambda$ 以及 $K_u(\\rho)$ 和 $K_T(\\rho)$ 的导数来表示 $\\nabla_{\\rho} J$。\n- 实现一个程序，针对给定的测试用例，计算伴随梯度，并与有限差分中心近似进行验证。报告每个测试用例中，伴随梯度与有限差分梯度在所有设计分量上的最大绝对差。\n\n为 SIMP 和目标函数使用以下数值参数：\n$$\nE_0 = 1.0,\\quad E_{\\min} = 10^{-3},\\quad k_0 = 1.0,\\quad k_{\\min} = 10^{-3},\\quad p = 3,\\quad \\gamma = 0.1,\\quad \\eta = 0.01,\\quad W = I_2,\n$$\n其中 $I_2$ 表示 $2 \\times 2$ 的单位矩阵。\n\n使用以下包含 4 个测试用例的测试套件，每个用例由 $(\\rho, B, S, f_{\\mathrm{ext}}, q_{\\mathrm{ext}})$ 定义：\n- 情况 1 (一般耦合，中等设计)：\n$$\n\\rho = \\begin{bmatrix} 0.6 \\\\ 0.8 \\\\ 0.3 \\end{bmatrix},\\quad\nB = \\begin{bmatrix} 0.4  0.0 \\\\ 0.0  0.2 \\end{bmatrix},\\quad\nS = \\begin{bmatrix} 0.1  0.05 \\\\ 0.0  0.2 \\end{bmatrix},\\quad\nf_{\\mathrm{ext}} = \\begin{bmatrix} 1.0 \\\\ 0.5 \\end{bmatrix},\\quad\nq_{\\mathrm{ext}} = \\begin{bmatrix} 0.3 \\\\ 0.2 \\end{bmatrix}.\n$$\n- 情况 2 (近奇异设计，由于 $E_{\\min}$ 和 $k_{\\min}$ 仍为适定问题)：\n$$\n\\rho = \\begin{bmatrix} 10^{-3} \\\\ 10^{-3} \\\\ 10^{-3} \\end{bmatrix},\\quad\nB = \\begin{bmatrix} 0.4  0.0 \\\\ 0.0  0.2 \\end{bmatrix},\\quad\nS = \\begin{bmatrix} 0.1  0.05 \\\\ 0.0  0.2 \\end{bmatrix},\\quad\nf_{\\mathrm{ext}} = \\begin{bmatrix} 1.0 \\\\ 0.5 \\end{bmatrix},\\quad\nq_{\\mathrm{ext}} = \\begin{bmatrix} 0.3 \\\\ 0.2 \\end{bmatrix}.\n$$\n- 情况 3 (解耦场)：\n$$\n\\rho = \\begin{bmatrix} 0.5 \\\\ 0.5 \\\\ 0.5 \\end{bmatrix},\\quad\nB = \\begin{bmatrix} 0.0  0.0 \\\\ 0.0  0.0 \\end{bmatrix},\\quad\nS = \\begin{bmatrix} 0.0  0.0 \\\\ 0.0  0.0 \\end{bmatrix},\\quad\nf_{\\mathrm{ext}} = \\begin{bmatrix} 1.0 \\\\ 0.5 \\end{bmatrix},\\quad\nq_{\\mathrm{ext}} = \\begin{bmatrix} 0.3 \\\\ 0.2 \\end{bmatrix}.\n$$\n- 情况 4 (强耦合)：\n$$\n\\rho = \\begin{bmatrix} 0.9 \\\\ 0.1 \\\\ 0.7 \\end{bmatrix},\\quad\nB = \\begin{bmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{bmatrix},\\quad\nS = \\begin{bmatrix} 0.5  0.3 \\\\ 0.3  0.8 \\end{bmatrix},\\quad\nf_{\\mathrm{ext}} = \\begin{bmatrix} 1.0 \\\\ 0.5 \\end{bmatrix},\\quad\nq_{\\mathrm{ext}} = \\begin{bmatrix} 0.3 \\\\ 0.2 \\end{bmatrix}.\n$$\n\n您的程序应针对每个用例执行以下操作：\n- 组装 $K_u(\\rho)$ 和 $K_T(\\rho)$。\n- 求解 $F(y,\\rho) = 0$ 得到 $y(\\rho)$。\n- 构造 $\\dfrac{\\partial J}{\\partial y}(y,\\rho)$ 并求解伴随系统\n$$\n\\left(\\frac{\\partial F}{\\partial y}(y,\\rho)\\right)^{\\top} \\lambda + \\frac{\\partial J}{\\partial y}(y,\\rho) = 0,\n$$\n其中 $\\dfrac{\\partial F}{\\partial y}(y,\\rho) = \\begin{bmatrix} K_u(\\rho)  -B \\\\ -S  K_T(\\rho) \\end{bmatrix}$。\n- 计算伴随梯度 $\\nabla_{\\rho} J = \\dfrac{\\partial J}{\\partial \\rho} + \\lambda^{\\top} \\dfrac{\\partial F}{\\partial \\rho}$，其分量为\n$$\n\\frac{\\partial J}{\\partial \\rho_i} = \\eta, \\qquad\n\\lambda^{\\top} \\frac{\\partial F}{\\partial \\rho_i} = \\lambda_u^{\\top} \\left(\\frac{\\partial K_u}{\\partial \\rho_i}\\right) u + \\lambda_T^{\\top} \\left(\\frac{\\partial K_T}{\\partial \\rho_i}\\right) T,\n$$\n以及\n$$\n\\frac{\\partial K_u}{\\partial \\rho_i} = \\frac{d E_i}{d \\rho_i} K_{u,i}, \\quad \\frac{d E_i}{d \\rho_i} = p \\rho_i^{p-1} \\left(E_0 - E_{\\min}\\right), \\qquad\n\\frac{\\partial K_T}{\\partial \\rho_i} = \\frac{d k_i}{d \\rho_i} K_{T,i}, \\quad \\frac{d k_i}{d \\rho_i} = p \\rho_i^{p-1} \\left(k_0 - k_{\\min}\\right).\n$$\n- 使用扰动 $\\varepsilon = 10^{-8}$ 计算 $\\nabla_{\\rho} J$ 的有限差分中心近似。\n- 对每个用例，返回伴随梯度与有限差分梯度之间的最大绝对差。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_j$ 是用例 $j$ 的最大绝对差。所有报告的值均为无量纲实数。",
            "solution": "我们从离散的多物理场系统的残差形式开始\n$$\nF(y,\\rho) = \\mathcal{A}(\\rho) y - b = 0,\n$$\n其中\n$$\n\\mathcal{A}(\\rho) = \\begin{bmatrix} K_u(\\rho)  -B \\\\ -S  K_T(\\rho) \\end{bmatrix}, \\qquad\nb = \\begin{bmatrix} f_{\\mathrm{ext}} \\\\ q_{\\mathrm{ext}} \\end{bmatrix},\n$$\n$y = \\begin{bmatrix} u \\\\ T \\end{bmatrix}$，其中 $u \\in \\mathbb{R}^{2}$ 和 $T \\in \\mathbb{R}^{2}$，以及 $\\rho = \\begin{bmatrix} \\rho_1 \\\\ \\rho_2 \\\\ \\rho_3 \\end{bmatrix} \\in [0,1]^3$。目标函数为\n$$\nJ(y,\\rho) = f_{\\mathrm{ext}}^{\\top} u + \\gamma \\, T^{\\top} W T + \\eta \\sum_{i=1}^{3} \\rho_i.\n$$\n\n伴随方法论源于拉格朗日量\n$$\nL(y,\\rho,\\lambda) = J(y,\\rho) + \\lambda^{\\top} F(y,\\rho) = J(y,\\rho) + \\lambda^{\\top}\\left(\\mathcal{A}(\\rho) y - b\\right),\n$$\n其中 $\\lambda \\in \\mathbb{R}^{4}$ 是伴随向量。将 $L$ 对 $y$ 求导并令其为零，即可得到伴随方程。具体来说，\n$$\n\\frac{\\partial L}{\\partial y} = \\frac{\\partial J}{\\partial y} + \\left(\\frac{\\partial F}{\\partial y}\\right)^{\\top} \\lambda = 0,\n$$\n即\n$$\n\\left(\\frac{\\partial F}{\\partial y}\\right)^{\\top} \\lambda + \\frac{\\partial J}{\\partial y} = 0.\n$$\n对于我们的残差 $F(y,\\rho) = \\mathcal{A}(\\rho) y - b$，其关于 $y$ 的雅可比矩阵为\n$$\n\\frac{\\partial F}{\\partial y} = \\mathcal{A}(\\rho) = \\begin{bmatrix} K_u(\\rho)  -B \\\\ -S  K_T(\\rho) \\end{bmatrix}.\n$$\n目标函数关于 $y$ 的梯度为\n$$\n\\frac{\\partial J}{\\partial y} = \\begin{bmatrix} \\frac{\\partial J}{\\partial u} \\\\ \\frac{\\partial J}{\\partial T} \\end{bmatrix}\n= \\begin{bmatrix} f_{\\mathrm{ext}} \\\\ 2 \\gamma W T \\end{bmatrix}.\n$$\n因此，伴随方程变为\n$$\n\\mathcal{A}(\\rho)^{\\top} \\lambda + \\begin{bmatrix} f_{\\mathrm{ext}} \\\\ 2 \\gamma W T \\end{bmatrix} = 0.\n$$\n求解这个 $4 \\times 4$ 的线性系统得到 $\\lambda = \\begin{bmatrix} \\lambda_u \\\\ \\lambda_T \\end{bmatrix}$，其中 $\\lambda_u \\in \\mathbb{R}^{2}$ 和 $\\lambda_T \\in \\mathbb{R}^{2}$。\n\n接下来，目标函数 $J(y(\\rho),\\rho)$ 关于 $\\rho$ 的全导数为\n$$\n\\frac{d}{d \\rho_i} J(y(\\rho),\\rho) = \\frac{\\partial J}{\\partial \\rho_i} + \\left(\\frac{\\partial J}{\\partial y}\\right)^{\\top} \\frac{\\partial y}{\\partial \\rho_i}.\n$$\n使用约束 $F(y(\\rho),\\rho) = 0$，我们对其关于 $\\rho_i$ 求导：\n$$\n\\frac{\\partial F}{\\partial y} \\frac{\\partial y}{\\partial \\rho_i} + \\frac{\\partial F}{\\partial \\rho_i} = 0\n\\quad \\Rightarrow \\quad\n\\frac{\\partial y}{\\partial \\rho_i} = - \\left(\\frac{\\partial F}{\\partial y}\\right)^{-1} \\frac{\\partial F}{\\partial \\rho_i}.\n$$\n代入 $\\dfrac{dJ}{d\\rho_i}$ 的表达式中，得到\n$$\n\\frac{dJ}{d\\rho_i} = \\frac{\\partial J}{\\partial \\rho_i} - \\left(\\frac{\\partial J}{\\partial y}\\right)^{\\top} \\left(\\frac{\\partial F}{\\partial y}\\right)^{-1} \\frac{\\partial F}{\\partial \\rho_i}.\n$$\n引入伴随向量 $\\lambda$，通过求解\n$$\n\\left(\\frac{\\partial F}{\\partial y}\\right)^{\\top} \\lambda + \\frac{\\partial J}{\\partial y} = 0\n\\quad \\Rightarrow \\quad\n\\lambda = - \\left(\\frac{\\partial F}{\\partial y}\\right)^{-\\top} \\frac{\\partial J}{\\partial y}.\n$$\n则\n$$\n\\frac{dJ}{d\\rho_i} = \\frac{\\partial J}{\\partial \\rho_i} + \\lambda^{\\top} \\frac{\\partial F}{\\partial \\rho_i}.\n$$\n这就是经典的伴随灵敏度公式：关于设计的梯度等于直接导数加上伴随加权的残差导数。\n\n对于我们的具体问题，请注意 $b$ 不依赖于 $\\rho$，残差关于 $\\rho_i$ 的导数为\n$$\n\\frac{\\partial F}{\\partial \\rho_i} = \\begin{bmatrix} \\frac{\\partial K_u}{\\partial \\rho_i}  0 \\\\ 0  \\frac{\\partial K_T}{\\partial \\rho_i} \\end{bmatrix} \\begin{bmatrix} u \\\\ T \\end{bmatrix}\n= \\begin{bmatrix} \\left(\\frac{\\partial K_u}{\\partial \\rho_i}\\right) u \\\\ \\left(\\frac{\\partial K_T}{\\partial \\rho_i}\\right) T \\end{bmatrix}.\n$$\n因此，\n$$\n\\lambda^{\\top} \\frac{\\partial F}{\\partial \\rho_i} = \\lambda_u^{\\top} \\left(\\frac{\\partial K_u}{\\partial \\rho_i}\\right) u + \\lambda_T^{\\top} \\left(\\frac{\\partial K_T}{\\partial \\rho_i}\\right) T.\n$$\n类刚度矩阵的偏导数为\n$$\n\\frac{\\partial K_u}{\\partial \\rho_i} = \\frac{d E_i}{d \\rho_i} K_{u,i}, \\quad \\frac{d E_i}{d \\rho_i} = p \\rho_i^{p-1} \\left(E_0 - E_{\\min}\\right),\n$$\n以及\n$$\n\\frac{\\partial K_T}{\\partial \\rho_i} = \\frac{d k_i}{d \\rho_i} K_{T,i}, \\quad \\frac{d k_i}{d \\rho_i} = p \\rho_i^{p-1} \\left(k_0 - k_{\\min}\\right).\n$$\n$J$ 关于 $\\rho_i$ 的直接导数很简单\n$$\n\\frac{\\partial J}{\\partial \\rho_i} = \\eta,\n$$\n因为类柔度项 $f_{\\mathrm{ext}}^{\\top} u$ 和热二次项 $\\gamma T^{\\top} W T$ 除了通过 $y(\\rho)$ 之外没有对 $\\rho$ 的显式依赖，而这已由伴随项计入。\n\n每个测试用例的算法流程：\n- 根据基和 SIMP 系数 $E_i(\\rho_i)$ 和 $k_i(\\rho_i)$ 组装 $K_u(\\rho)$ 和 $K_T(\\rho)$。\n- 构建 $4 \\times 4$ 分块矩阵 $\\mathcal{A}(\\rho)$ 和右端项 $b$。\n- 求解正向线性系统 $\\mathcal{A}(\\rho) y = b$ 得到 $y = \\begin{bmatrix} u \\\\ T \\end{bmatrix}$。\n- 构造目标函数关于 $y$ 的梯度 $\\dfrac{\\partial J}{\\partial y} = \\begin{bmatrix} f_{\\mathrm{ext}} \\\\ 2 \\gamma W T \\end{bmatrix}$。\n- 求解伴随系统 $\\mathcal{A}(\\rho)^{\\top} \\lambda = - \\dfrac{\\partial J}{\\partial y}$ 得到 $\\lambda$。\n- 计算伴随梯度分量\n$$\n\\left(\\nabla_{\\rho} J\\right)_i = \\eta + \\lambda_u^{\\top} \\left(\\frac{\\partial K_u}{\\partial \\rho_i}\\right) u + \\lambda_T^{\\top} \\left(\\frac{\\partial K_T}{\\partial \\rho_i}\\right) T, \\quad i = 1,2,3.\n$$\n- 通过有限差分进行验证：对于一个小的 $\\varepsilon = 10^{-8}$，计算中心差分\n$$\n\\left(\\nabla_{\\rho} J\\right)^{\\mathrm{FD}}_i \\approx \\frac{J\\left(y(\\rho + \\varepsilon e_i), \\rho + \\varepsilon e_i\\right) - J\\left(y(\\rho - \\varepsilon e_i), \\rho - \\varepsilon e_i\\right)}{2 \\varepsilon},\n$$\n其中 $e_i$ 是 $\\mathbb{R}^3$ 中的第 $i$ 个单位向量，$y(\\cdot)$ 是通过求解扰动设计下的正向问题得到的。\n- 计算最大绝对差\n$$\nr = \\max_{i \\in \\{1,2,3\\}} \\left| \\left(\\nabla_{\\rho} J\\right)_i - \\left(\\nabla_{\\rho} J\\right)^{\\mathrm{FD}}_i \\right|.\n$$\n\n数值稳定性与物理真实性：\n- SIMP 的下界 $E_{\\min} > 0$ 和 $k_{\\min} > 0$ 确保了 $K_u(\\rho)$ 和 $K_T(\\rho)$ 是对称半正定基的正定组合，因此对于所提供的耦合，分块矩阵 $\\mathcal{A}(\\rho)$ 是非奇异的。\n- 耦合矩阵 $B$ 和 $S$ 代表了线性化的热弹性相互作用。虽然真实的热弹性耦合通常以热膨胀载荷的形式进入机械方程，并通过耗散源进入热方程，但对称分块表示提供了一个数学上合理的耦合线性系统，适合用于伴随灵敏度演示。\n- 中心有限差分步长 $\\varepsilon$ 被选取得足够小，以确保高精度的近似，同时避免双精度算术中过度的舍入误差。\n\n程序实现了上述过程，并针对 4 个测试用例，返回一个无量纲实数列表 $[r_1, r_2, r_3, r_4]$，该列表衡量了伴随梯度与有限差分梯度之间的差异。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simp_coef(rho_i, x0, xmin, p):\n    # E(rho) or k(rho)\n    return xmin + (x0 - xmin) * (rho_i ** p)\n\ndef simp_deriv(rho_i, x0, xmin, p):\n    # derivative dE/drho or dk/drho\n    return p * (rho_i ** (p - 1)) * (x0 - xmin)\n\ndef assemble_matrices(rho, Ku_bases, Kt_bases, E0, Emin, k0, kmin, p):\n    Ku = np.zeros((2, 2))\n    Kt = np.zeros((2, 2))\n    dKu_drho = []\n    dKt_drho = []\n    for i in range(3):\n        Ei = simp_coef(rho[i], E0, Emin, p)\n        ki = simp_coef(rho[i], k0, kmin, p)\n        dEi = simp_deriv(rho[i], E0, Emin, p)\n        dki = simp_deriv(rho[i], k0, kmin, p)\n        Ku += Ei * Ku_bases[i]\n        Kt += ki * Kt_bases[i]\n        dKu_drho.append(dEi * Ku_bases[i])\n        dKt_drho.append(dki * Kt_bases[i])\n    return Ku, Kt, dKu_drho, dKt_drho\n\ndef build_block_matrix(Ku, Kt, B, S):\n    # Assemble 4x4 block matrix A = [[Ku, -B], [-S, Kt]]\n    A = np.zeros((4, 4))\n    A[0:2, 0:2] = Ku\n    A[0:2, 2:4] = -B\n    A[2:4, 0:2] = -S\n    A[2:4, 2:4] = Kt\n    return A\n\ndef solve_forward(rho, Ku_bases, Kt_bases, B, S, fext, qext, E0, Emin, k0, kmin, p):\n    Ku, Kt, dKu_drho, dKt_drho = assemble_matrices(rho, Ku_bases, Kt_bases, E0, Emin, k0, kmin, p)\n    A = build_block_matrix(Ku, Kt, B, S)\n    b = np.hstack([fext, qext])\n    y = np.linalg.solve(A, b)\n    u = y[0:2]\n    T = y[2:4]\n    return u, T, A, dKu_drho, dKt_drho\n\ndef objective(u, T, rho, fext, gamma, W, eta):\n    return float(fext @ u + gamma * (T @ (W @ T)) + eta * np.sum(rho))\n\ndef adjoint_gradient(rho, Ku_bases, Kt_bases, B, S, fext, qext, E0, Emin, k0, kmin, p, gamma, W, eta):\n    # Forward solve\n    u, T, A, dKu_drho, dKt_drho = solve_forward(rho, Ku_bases, Kt_bases, B, S, fext, qext, E0, Emin, k0, kmin, p)\n    # dJ/dy = [fext, 2*gamma*W*T]\n    dJ_du = fext\n    dJ_dT = 2.0 * gamma * (W @ T)\n    dJ_dy = np.hstack([dJ_du, dJ_dT])\n    # Solve adjoint: A^T * lambda = - dJ/dy\n    rhs = -dJ_dy\n    lam = np.linalg.solve(A.T, rhs)\n    lam_u = lam[0:2]\n    lam_T = lam[2:4]\n    # Gradient components\n    grad = np.zeros(3)\n    for i in range(3):\n        term_u = lam_u @ (dKu_drho[i] @ u)\n        term_T = lam_T @ (dKt_drho[i] @ T)\n        grad[i] = eta + term_u + term_T\n    return grad, u, T\n\ndef fd_gradient(rho, Ku_bases, Kt_bases, B, S, fext, qext, E0, Emin, k0, kmin, p, gamma, W, eta, eps=1e-8):\n    grad_fd = np.zeros(3)\n    for i in range(3):\n        rho_plus = rho.copy()\n        rho_minus = rho.copy()\n        rho_plus[i] += eps\n        rho_minus[i] -= eps\n        # clamp to avoid negative rho (though eps is small)\n        rho_plus[i] = max(0.0, min(1.0, rho_plus[i]))\n        rho_minus[i] = max(0.0, min(1.0, rho_minus[i]))\n        # forward solves\n        u_p, T_p, _, _, _ = solve_forward(rho_plus, Ku_bases, Kt_bases, B, S, fext, qext, E0, Emin, k0, kmin, p)\n        J_p = objective(u_p, T_p, rho_plus, fext, gamma, W, eta)\n        u_m, T_m, _, _, _ = solve_forward(rho_minus, Ku_bases, Kt_bases, B, S, fext, qext, E0, Emin, k0, kmin, p)\n        J_m = objective(u_m, T_m, rho_minus, fext, gamma, W, eta)\n        grad_fd[i] = (J_p - J_m) / (rho_plus[i] - rho_minus[i])  # central difference symmetric if bounds not hit\n    return grad_fd\n\ndef run_case(rho, B, S, fext, qext):\n    # SIMP and objective parameters\n    E0 = 1.0\n    Emin = 1e-3\n    k0 = 1.0\n    kmin = 1e-3\n    p = 3\n    gamma = 0.1\n    eta = 0.01\n    W = np.eye(2)\n\n    # Bases\n    Ku_bases = [\n        np.array([[2.0, -1.0], [-1.0, 2.0]]),\n        np.array([[1.0,  0.0], [ 0.0, 1.0]]),\n        np.array([[1.0, -1.0], [-1.0, 1.0]]),\n    ]\n    Kt_bases = [\n        np.array([[1.0, -1.0], [-1.0, 1.0]]),\n        np.array([[2.0, -1.0], [-1.0, 2.0]]),\n        np.array([[1.0,  0.0], [ 0.0, 1.0]]),\n    ]\n\n    grad_adj, u, T = adjoint_gradient(rho, Ku_bases, Kt_bases, B, S, fext, qext, E0, Emin, k0, kmin, p, gamma, W, eta)\n    grad_fd = fd_gradient(rho, Ku_bases, Kt_bases, B, S, fext, qext, E0, Emin, k0, kmin, p, gamma, W, eta, eps=1e-8)\n    max_diff = float(np.max(np.abs(grad_adj - grad_fd)))\n    return max_diff\n\ndef solve():\n    test_cases = [\n        # Case 1\n        (\n            np.array([0.6, 0.8, 0.3]),\n            np.array([[0.4, 0.0],\n                      [0.0, 0.2]]),\n            np.array([[0.1, 0.05],\n                      [0.0, 0.2]]),\n            np.array([1.0, 0.5]),\n            np.array([0.3, 0.2]),\n        ),\n        # Case 2\n        (\n            np.array([1e-3, 1e-3, 1e-3]),\n            np.array([[0.4, 0.0],\n                      [0.0, 0.2]]),\n            np.array([[0.1, 0.05],\n                      [0.0, 0.2]]),\n            np.array([1.0, 0.5]),\n            np.array([0.3, 0.2]),\n        ),\n        # Case 3\n        (\n            np.array([0.5, 0.5, 0.5]),\n            np.array([[0.0, 0.0],\n                      [0.0, 0.0]]),\n            np.array([[0.0, 0.0],\n                      [0.0, 0.0]]),\n            np.array([1.0, 0.5]),\n            np.array([0.3, 0.2]),\n        ),\n        # Case 4\n        (\n            np.array([0.9, 0.1, 0.7]),\n            np.array([[1.0, 0.0],\n                      [0.0, 1.0]]),\n            np.array([[0.5, 0.3],\n                      [0.3, 0.8]]),\n            np.array([1.0, 0.5]),\n            np.array([0.3, 0.2]),\n        ),\n    ]\n\n    results = []\n    for rho, B, S, fext, qext in test_cases:\n        result = run_case(rho, B, S, fext, qext)\n        # Use a reasonable formatting for floating values\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.12e}', results))}]\")\n\nsolve()\n```"
        }
    ]
}