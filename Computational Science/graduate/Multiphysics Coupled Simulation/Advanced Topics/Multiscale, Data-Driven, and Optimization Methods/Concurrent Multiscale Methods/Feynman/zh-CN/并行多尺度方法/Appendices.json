{
    "hands_on_practices": [
        {
            "introduction": "在将多尺度方法应用于实际工程问题之前，验证其准确性是至关重要的一步。本练习旨在通过一个基础但富有启发性的基准问题，建立对并发多尺度方法（FE²）核心思想的直观理解。通过亲手实现一个直接数值模拟（DNS）作为“精确解”，并将其与基于均质化理论的$FE^2$模型进行定量比较，您将深刻体会到均质化的有效性、误差来源以及其适用边界。",
            "id": "3498314",
            "problem": "考虑一个一维小应变线性弹性杆，其刚度在空间上非均匀，并受到分布体力与端部位移约束的作用。设空间坐标为 $x \\in [0,L]$，横截面积为 $A$，位移场为 $u(x)$，应变为 $\\varepsilon(x)$，Cauchy应力为 $\\sigma(x)$。假设准静态平衡，无惯性，无阻尼。控制关系为：线性动量平衡方程 $\\dfrac{\\mathrm{d}}{\\mathrm{d}x} \\left( A \\sigma(x) \\right) + b = 0$，运动学关系 $\\varepsilon(x) = \\dfrac{\\mathrm{d}u}{\\mathrm{d}x}$，以及Hooke型本构定律 $\\sigma(x) = E(x) \\varepsilon(x)$，其中 $E(x)$ 是空间变化的杨氏模量。设边界条件为 $u(0) = 0$ 和 $u(L) = U$，其中 $U$ 是一个指定的端部位移。设体力密度 $b$ 沿 $x$ 为常数。\n\n您将设计一个验证基准，用于将并行多尺度有限元平方 ($FE^2$) 方法与在完全解析的非均匀域上进行的直接数值模拟 (DNS) 进行比较。在 $FE^2$ 方法中，宏观问题在粗网格上求解，其等效本构响应通过从微观非均匀介质的相关代表性体积单元 (RVE) 中获得。对于此基准，考虑沿 $x$ 方向的周期性两相微结构，其周期为 $p$，相模量为 $E_{1}$ 和 $E_{2}$，相分数为 $f \\in (0,1)$，使得在每个周期内，长度为 $fp$ 的区间模量为 $E_{1}$，长度为 $(1-f)p$ 的区间模量为 $E_{2}$。微观非均匀性在 $[0,L]$ 上重复。\n\n任务：\n1. 仅从平衡定律、运动学关系和本构定律出发，形式化适用于具有尺度分离的一维周期性非均匀杆的均匀化概念。在所述条件下，推导杆的均匀化宏观本构关系及等效模量 $E_{\\mathrm{eff}}$。不要使用任何预先给定的均匀化公式；从第一性原理出发，利用周期性微结构和在微观层面保证与宏观场能量一致的适当边界条件，推导 $E_{\\mathrm{eff}}$ 的形式。\n2. 通过将杆离散为 $N$ 个长度为 $h = L/N$ 的均匀有限元来实施DNS，其中 $E(x)$ 根据周期性微结构被完全解析为每个单元上的分段常数函数。使用线性有限元和通过弱形式得到的恒定体力密度 $b$ 来组装全局刚度矩阵。施加Dirichlet边界条件 $u(0) = 0$ 和 $u(L) = U$，求解节点位移，并计算单元应变 $\\varepsilon_{e}$、单元应力 $\\sigma_{e}$ 和总应变能 $$W_{\\mathrm{DNS}} = \\sum_{e} \\tfrac{1}{2} E_{e} A \\varepsilon_{e}^{2} h$$\n3. 通过将同一杆离散为 $M$ 个均匀有限元来实施 $FE^2$ 宏观问题，将 $E(x)$ 替换为任务1中推导的均匀化等效模量 $E_{\\mathrm{eff}}$。在相同的体力密度 $b$ 和边界条件下，组装并求解宏观有限元系统，以获得宏观节点位移 $u_{\\mathrm{FE^2}}(x)$、单元应变、应力 $\\sigma_{\\mathrm{FE^2}}(x)$ 和总应变能 $W_{\\mathrm{FE^2}}$。\n4. 定义定量误差度量以比较 $FE^2$ 与 DNS：\n   - 应力误差：相对 $L^{2}$ 范数 $$e_{\\sigma} = \\dfrac{\\left\\| \\sigma_{\\mathrm{FE^2}} - \\sigma_{\\mathrm{DNS}} \\right\\|_{L^{2}(0,L)}}{\\left\\| \\sigma_{\\mathrm{DNS}} \\right\\|_{L^{2}(0,L)}}$$ 通过在DNS单元中心对 $\\sigma_{\\mathrm{FE^2}}(x)$ 进行采样并使用单元宽度为 $h$ 的复合矩形法则计算。\n   - 位移误差：相对 $L^{2}$ 范数 $$e_{u} = \\dfrac{\\left\\| u_{\\mathrm{FE^2}} - u_{\\mathrm{DNS}} \\right\\|_{L^{2}(0,L)}}{\\left\\| u_{\\mathrm{DNS}} \\right\\|_{L^{2}(0,L)}}$$ 通过在DNS节点处对两个位移进行采样并使用复合梯形法则积分来计算。\n   - 能量误差：相对差异 $$e_{W} = \\dfrac{\\left| W_{\\mathrm{FE^2}} - W_{\\mathrm{DNS}} \\right|}{W_{\\mathrm{DNS}}}$$\n所有应力必须以帕斯卡（pascals）计算，位移以米（meters）计算，能量以焦耳（joules）计算。误差度量必须以小数形式表示。\n\n您的程序必须实现以上内容，并为以下测试套件中的每个参数集生成误差度量。请统一使用以下单位：$L$ 单位为米，$A$ 单位为平方米，$U$ 单位为米，$b$ 单位为牛顿/米，$E_{1}$ 和 $E_{2}$ 单位为帕斯卡，$p$ 单位为米。\n\n测试套件：\n- 案例1（理想路径）：$L = 1.0$, $A = 1.0$, $U = 1.0 \\times 10^{-3}$, $b = 1000.0$, $E_{1} = 100.0 \\times 10^{9}$, $E_{2} = 50.0 \\times 10^{9}$, $f = 0.5$, $p = 0.02$, $M = 10$, $N = 500$。\n- 案例2（近均匀边界情况）：$L = 1.0$, $A = 1.0$, $U = 1.0 \\times 10^{-3}$, $b = 1000.0$, $E_{1} = 80.0 \\times 10^{9}$, $E_{2} = 80.0 \\times 10^{9}$, $f = 0.5$, $p = 0.02$, $M = 10$, $N = 500$。\n- 案例3（强对比度）：$L = 1.0$, $A = 1.0$, $U = 2.0 \\times 10^{-3}$, $b = 5000.0$, $E_{1} = 200.0 \\times 10^{9}$, $E_{2} = 10.0 \\times 10^{9}$, $f = 0.7$, $p = 0.05$, $M = 8$, $N = 800$。\n- 案例4（尺度分离不良）：$L = 1.0$, $A = 1.0$, $U = 1.0 \\times 10^{-3}$, $b = 2000.0$, $E_{1} = 120.0 \\times 10^{9}$, $E_{2} = 30.0 \\times 10^{9}$, $f = 0.4$, $p = 0.25$, $M = 4$, $N = 400$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个条目是对应一个测试案例的三元素列表 $[e_{\\sigma}, e_{u}, e_{W}]$，顺序与测试套件相同（例如，$[[e_{\\sigma 1}, e_{u 1}, e_{W 1}],[e_{\\sigma 2}, e_{u 2}, e_{W 2}],\\dots]$）。",
            "solution": "所提出的问题是针对一维 (1D) 多尺度有限元平方 ($FE^2$) 模型与高保真直接数值模拟 (DNS) 的系统性验证基准。物理系统是一个具有周期性非均匀微结构的线性弹性杆，受到恒定体力和指定端部位移的作用。该问题具有科学依据、是适定的，并为获得唯一的数值解提供了所有必要信息。因此，它被认为是一个有效的问题。求解过程首先从第一性原理推导等效材料属性，然后为DNS和$FE^2$建立数值模型，最后定义和计算用于比较的误差度量。\n\n### 任务1：均匀化等效模量($E_{\\mathrm{eff}}$)的推导\n\n均匀化理论允许用等效的均匀材料替代复杂的非均匀材料，前提是宏观结构和微观非均匀性之间存在明显的尺度分离。这种等效介质的等效属性是通过分析代表性体积单元 (RVE) 的响应来推导的。对于给定的一维周期性微结构，RVE是长度为 $p$ 的单个周期。\n\n宏观应力 $\\Sigma$ 和应变 $\\mathcal{E}$ 定义为其微观对应量 $\\sigma(y)$ 和 $\\varepsilon(y)$ 在RVE上的体积平均值，其中 $y \\in [0,p]$ 是微观坐标：\n$$ \\Sigma = \\langle \\sigma \\rangle = \\frac{1}{p} \\int_0^p \\sigma(y) \\, dy $$\n$$ \\mathcal{E} = \\langle \\varepsilon \\rangle = \\frac{1}{p} \\int_0^p \\varepsilon(y) \\, dy $$\n\n在微观尺度上，我们假设与平衡弹性力的应力梯度相比，体力项可以忽略不计。RVE内的线性动量平衡简化为：\n$$ \\frac{d\\sigma(y)}{dy} = 0 $$\n这意味着微观应力 $\\sigma(y)$ 在整个RVE中必须是恒定的。这就是 **等应力条件**。设这个恒定应力为 $\\sigma_0$。因此，$\\sigma(y) = \\sigma_0$。\n\n微观应变 $\\varepsilon(y)$ 通过空间变化的杨氏模量 $E(y)$ 与应力相关：$\\varepsilon(y) = \\sigma(y)/E(y) = \\sigma_0/E(y)$。该材料由两相组成：\n$$\n\\varepsilon(y) =\n\\begin{cases}\n    \\sigma_0/E_1  & \\text{for } y \\in [0, fp) \\\\\n    \\sigma_0/E_2  & \\text{for } y \\in [fp, p)\n\\end{cases}\n$$\n\n宏观应变 $\\mathcal{E}$ 是微观应变在RVE上的平均值：\n$$ \\mathcal{E} = \\frac{1}{p} \\int_0^p \\varepsilon(y) \\, dy = \\frac{1}{p} \\left[ \\int_0^{fp} \\frac{\\sigma_0}{E_1} \\, dy + \\int_{fp}^{p} \\frac{\\sigma_0}{E_2} \\, dy \\right] $$\n$$ \\mathcal{E} = \\frac{\\sigma_0}{p} \\left( \\frac{fp}{E_1} + \\frac{(p-fp)}{E_2} \\right) = \\sigma_0 \\left( \\frac{f}{E_1} + \\frac{1-f}{E_2} \\right) $$\n\n由于微观应力是恒定的，宏观应力 $\\Sigma = \\langle \\sigma \\rangle = \\sigma_0$。用 $\\Sigma$ 代替 $\\sigma_0$ 得到宏观应变-应力关系：\n$$ \\mathcal{E} = \\Sigma \\left( \\frac{f}{E_1} + \\frac{1-f}{E_2} \\right) $$\n\n等效本构定律为 $\\Sigma = E_{\\mathrm{eff}} \\mathcal{E}$。通过重新排列上述方程，我们得到等效模量的倒数：\n$$ \\frac{1}{E_{\\mathrm{eff}}} = \\frac{\\mathcal{E}}{\\Sigma} = \\frac{f}{E_1} + \\frac{1-f}{E_2} $$\n因此，等效模量是相模量的调和平均值，按各自的体积分数加权：\n$$ E_{\\mathrm{eff}} = \\left( \\frac{f}{E_1} + \\frac{1-f}{E_2} \\right)^{-1} $$\n这个结果是材料沿加载方向串联分层的典型特征。\n\n### 任务2和3：有限元离散化\n\n边值问题的控制强形式是通过将运动学关系和本构关系代入动量平衡方程得到的：\n$$ \\frac{d}{dx} \\left( A E(x) \\frac{du}{dx} \\right) + b = 0 \\quad \\text{for } x \\in (0,L) $$\n边界条件为 $u(0)=0$ 和 $u(L)=U$。\n\n弱形式是通过乘以一个测试函数 $v(x)$（其中 $v(0)=v(L)=0$）并在域上积分推导出来的。经过分部积分后，我们寻找一个位移场 $u(x)$，它满足边界条件和对于所有有效的测试函数 $v(x)$ 的以下方程：\n$$ \\int_0^L A E(x) \\frac{du}{dx} \\frac{dv}{dx} \\, dx = \\int_0^L v(x) b \\, dx $$\n\n此方程使用有限元法（FEM）进行离散化。将域划分为单元，在每个单元内，使用线性形函数来近似位移场。对于长度为 $h_e$ 且具有恒定属性 $A_e$ 和 $E_e$ 的一维线性单元 $e$，其单元刚度矩阵 $K_e$ 和单元体力向量 $F_e$ 为：\n$$ K_e = \\frac{A_e E_e}{h_e} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad F_e = \\frac{b h_e}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} $$\n\n这些单元级矩阵和向量被组装成一个全局线性方程组 $\\mathbf{K}\\mathbf{u} = \\mathbf{F}$。在施加Dirichlet边界条件 $u(0)=0$ 和 $u(L)=U$ 后，求解该系统以获得未知节点位移向量 $\\mathbf{u}$。\n\n**DNS实施（任务2）：**\n域 $[0,L]$ 被离散化为 $N$ 个细网格单元。对于每个单元 $e$，模量 $E_e$ 被赋予与单元中心处材料相对应的微观值（$E_1$ 或 $E_2$）。这就创建了一个解析了材料非均匀性的高保真模型。\n\n**$FE^2$宏观实施（任务3）：**\n域 $[0,L]$ 被离散化为 $M$ 个粗网格单元（$M \\ll N$）。对于所有单元，模量被设置为在任务1中推导的恒定等效模量 $E_{\\mathrm{eff}}$。该模型代表了杆的均匀化宏观行为。\n\n### 任务4：误差度量公式化\n\n为了量化$FE^2$近似的精度，将其解与高保真DNS解进行比较。\n\n**应力误差 ($e_{\\sigma}$):** $FE^2$应力场 $\\sigma_{\\mathrm{FE^2}}$ 在粗网格上是分段常数，而DNS应力 $\\sigma_{\\mathrm{DNS}}$ 在细网格上是分段常数。为了比较它们，$FE^2$应力在每个DNS单元的中心进行采样。然后使用复合矩形法则计算相对 $L^2$ 误差：\n$$ e_{\\sigma} = \\frac{\\left\\| \\sigma_{\\mathrm{FE^2}} - \\sigma_{\\mathrm{DNS}} \\right\\|_{L^{2}}}{\\left\\| \\sigma_{\\mathrm{DNS}} \\right\\|_{L^{2}}} \\approx \\sqrt{ \\frac{\\sum_{i=1}^N (\\sigma_{\\mathrm{FE^2}}(x_{c,i}) - \\sigma_{\\mathrm{DNS},i})^2 h}{\\sum_{i=1}^N (\\sigma_{\\mathrm{DNS},i})^2 h} } = \\sqrt{ \\frac{\\sum_{i=1}^N (\\sigma_{\\mathrm{FE^2}}(x_{c,i}) - \\sigma_{\\mathrm{DNS},i})^2}{\\sum_{i=1}^N (\\sigma_{\\mathrm{DNS},i})^2} } $$\n其中 $\\sigma_{\\mathrm{DNS},i}$ 是DNS单元 $i$ 中的应力，而 $x_{c,i}$ 是其中心。\n\n**位移误差 ($e_{u}$):** $FE^2$节点位移定义在粗网格上。通过线性插值获得连续的分段线性位移场 $u_{\\mathrm{FE^2}}(x)$。然后在DNS节点上对此场进行采样。使用复合梯形法则计算相对 $L^2$ 误差：\n$$ e_{u} = \\frac{\\left\\| u_{\\mathrm{FE^2}} - u_{\\mathrm{DNS}} \\right\\|_{L^{2}}}{\\left\\| u_{\\mathrm{DNS}} \\right\\|_{L^{2}}} = \\sqrt{ \\frac{\\int_0^L (u_{\\mathrm{FE^2}}(x) - u_{\\mathrm{DNS}}(x))^2 dx}{\\int_0^L (u_{\\mathrm{DNS}}(x))^2 dx} } $$\n其中的积分使用精细DNS网格上的节点值进行数值计算。\n\n**能量误差 ($e_{W}$):** 每个模型的总应变能 $W_{\\mathrm{DNS}}$ 和 $W_{\\mathrm{FE^2}}$，是通过对其各自单元中的能量求和来计算的：$W = \\sum_{e} \\frac{1}{2} \\int_e A E_e \\varepsilon_e^2 dx = \\sum_e \\frac{1}{2} A_e E_e \\varepsilon_e^2 h_e$。相对误差是由DNS能量归一化的绝对差值：\n$$ e_{W} = \\frac{\\left| W_{\\mathrm{FE^2}} - W_{\\mathrm{DNS}} \\right|}{W_{\\mathrm{DNS}}} $$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import trapezoid\n\ndef solve_fem(L, A, E_vals, n_elem, b, U_bc):\n    \"\"\"\n    Solves a 1D bar problem using the linear Finite Element Method.\n\n    Args:\n        L (float): Length of the bar.\n        A (float): Cross-sectional area.\n        E_vals (np.array): Array of Young's moduli for each element.\n        n_elem (int): Number of elements.\n        b (float): Constant body force density.\n        U_bc (float): Prescribed displacement at x=L.\n\n    Returns:\n        tuple: A tuple containing:\n            - u (np.array): Nodal displacements of size (n_elem + 1).\n            - sigma (np.array): Element-wise constant stresses of size (n_elem).\n            - W (float): Total strain energy.\n    \"\"\"\n    n_nodes = n_elem + 1\n    h = L / n_elem\n\n    K = np.zeros((n_nodes, n_nodes))\n    F = np.zeros(n_nodes)\n\n    for e in range(n_elem):\n        E_e = E_vals[e]\n        k_e = (A * E_e / h) * np.array([[1, -1], [-1, 1]])\n        f_e = (b * h / 2) * np.array([1, 1])\n        \n        nodes = np.array([e, e + 1])\n        K[np.ix_(nodes, nodes)] += k_e\n        F[nodes] += f_e\n\n    prescribed_dofs = [0, n_nodes - 1]\n    all_dofs = list(range(n_nodes))\n    free_dofs = [dof for dof in all_dofs if dof not in prescribed_dofs]\n    \n    u_bc_vals = np.array([0.0, U_bc])\n    \n    # K_fp @ U_p term\n    F_mod = K[np.ix_(free_dofs, prescribed_dofs)] @ u_bc_vals\n    F_reduced = F[free_dofs] - F_mod\n    K_reduced = K[np.ix_(free_dofs, free_dofs)]\n    \n    u_free = np.linalg.solve(K_reduced, F_reduced)\n    \n    u = np.zeros(n_nodes)\n    u[free_dofs] = u_free\n    u[prescribed_dofs] = u_bc_vals\n    \n    epsilon = (u[1:] - u[:-1]) / h\n    sigma = E_vals * epsilon\n    W = 0.5 * np.sum(A * E_vals * epsilon**2 * h)\n    \n    return u, sigma, W\n\ndef run_benchmark(params):\n    \"\"\"\n    Runs the DNS vs FE^2 benchmark for a given set of parameters.\n    \"\"\"\n    L, A, U, b, E1, E2, f, p, M, N = params\n    \n    # Task 1: Calculate effective modulus\n    if E1 == 0 or E2 == 0:\n        E_eff = 0\n    else:\n        E_eff = 1.0 / (f / E1 + (1 - f) / E2)\n    \n    # Task 2: Direct Numerical Simulation (DNS)\n    h_dns = L / N\n    E_dns = np.zeros(N)\n    for i in range(N):\n        x_center = (i + 0.5) * h_dns\n        if (x_center % p)  f * p:\n            E_dns[i] = E1\n        else:\n            E_dns[i] = E2\n            \n    u_dns, sigma_dns, W_dns = solve_fem(L, A, E_dns, N, b, U)\n\n    # Task 3: FE^2 Macroscopic Simulation\n    E_fe2 = np.full(M, E_eff)\n    u_fe2, sigma_fe2, W_fe2 = solve_fem(L, A, E_fe2, M, b, U)\n\n    # Task 4: Compute Error Metrics\n    h_fe2 = L / M\n\n    # Stress error e_sigma\n    sigma_fe2_sampled = np.zeros(N)\n    for i in range(N):\n        x_center = (i + 0.5) * h_dns\n        macro_elem_idx = min(int(x_center / h_fe2), M - 1)\n        sigma_fe2_sampled[i] = sigma_fe2[macro_elem_idx]\n    \n    num_sigma = np.sum((sigma_fe2_sampled - sigma_dns)**2)\n    den_sigma = np.sum(sigma_dns**2)\n    e_sigma = np.sqrt(num_sigma / den_sigma) if den_sigma > 1e-15 else 0.0\n\n    # Displacement error e_u\n    x_dns = np.linspace(0, L, N + 1)\n    x_fe2 = np.linspace(0, L, M + 1)\n    u_fe2_interp = np.interp(x_dns, x_fe2, u_fe2)\n    \n    num_u = trapezoid((u_fe2_interp - u_dns)**2, x_dns)\n    den_u = trapezoid(u_dns**2, x_dns)\n    e_u = np.sqrt(num_u / den_u) if den_u > 1e-15 else 0.0\n    \n    # Energy error e_W\n    e_W = np.abs(W_fe2 - W_dns) / W_dns if W_dns > 1e-15 else 0.0\n\n    return [e_sigma, e_u, e_W]\n\ndef solve():\n    \"\"\"Main function to run the test suite and print results.\"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        (1.0, 1.0, 1.0e-3, 1000.0, 100.0e9, 50.0e9, 0.5, 0.02, 10, 500),\n        # Case 2 (near-homogeneous boundary case)\n        (1.0, 1.0, 1.0e-3, 1000.0, 80.0e9, 80.0e9, 0.5, 0.02, 10, 500),\n        # Case 3 (strong contrast)\n        (1.0, 1.0, 2.0e-3, 5000.0, 200.0e9, 10.0e9, 0.7, 0.05, 8, 800),\n        # Case 4 (poor scale separation)\n        (1.0, 1.0, 1.0e-3, 2000.0, 120.0e9, 30.0e9, 0.4, 0.25, 4, 400),\n    ]\n\n    results = []\n    for params in test_cases:\n        errors = run_benchmark(params)\n        results.append(errors)\n\n    # Format output as a list of lists of decimals.\n    result_str = \",\".join([f\"[{','.join(map(str, err))}]\" for err in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实材料的行为往往是非线性的，例如金属的弹塑性。本练习将引导您从简单的线弹性模型过渡到更具挑战性的弹塑性材料，并聚焦于求解非线性有限元问题时的一个关键概念：一致切线模量。您将通过推导在微观尺度上由后向欧拉返回映射算法产生的一致切线模量，从而揭示微观积分算法如何直接影响宏观迭代求解的收敛性。",
            "id": "3498329",
            "problem": "考虑一个通过有限元平方 ($FE^2$) 方法求解的双尺度小应变弹塑性问题，其中，宏观尺度问题使用的均质化本构响应，是通过在每个宏观尺度积分点求解一个微观尺度代表性体积单元 (RVE) 的边值问题获得的。假设以下设定。\n\n- 宏观尺度运动学为一维单轴小应变，宏观应变表示为 $\\varepsilon^{M}$，宏观应力表示为 $\\sigma^{M}$。\n- 微观尺度 RVE 是均匀的、一维的，并遵循适用于一维情况的关联 $J_{2}$ 型塑性理论（因此，符号效应由屈服函数中的绝对值来体现）。微观本构方程如下：\n  - 运动学：$\\varepsilon = \\varepsilon^{e} + \\varepsilon^{p}$，其中 $\\varepsilon$、$\\varepsilon^{e}$ 和 $\\varepsilon^{p}$ 分别表示总应变、弹性应变和塑性应变。\n  - 弹性定律：$\\sigma = E\\,\\varepsilon^{e}$，其中 $E$ 是微观弹性模量。\n  - 屈服函数：$f(\\sigma,\\alpha) = |\\sigma| - \\sigma_{y} - H\\,\\alpha$，其中 $\\sigma_{y}$ 是初始屈服应力， $H$ 是与线性各向同性硬化相关的（标量）算法塑性模量，$\\alpha$ 是等效塑性应变。\n  - 流动法则和硬化：$\\dot{\\varepsilon}^{p} = \\dot{\\lambda}\\,\\mathrm{sign}(\\sigma)$ 和 $\\dot{\\alpha} = \\dot{\\lambda}$，其中 $\\dot{\\lambda} \\ge 0$，$f \\le 0$，以及 $\\dot{\\lambda}\\,f = 0$。\n- 在每个宏观增量步中，微观尺度问题通过后向欧拉返回映射算法在均匀运动学边界条件下求解（即，施加的边界位移场强制产生一个等于宏观应变的均匀微观应变：$\\varepsilon = \\varepsilon^{M}$）。当前状态处于塑性加载中，且 $\\sigma > 0$（因此 $\\mathrm{sign}(\\sigma) = +1$）。\n\n从这些基本原理出发，完成以下任务：\n1. 使用应用于微观尺度的后向欧拉返回映射格式以及通过应力体积平均的均质化方法，推导当前积分点宏观一致性切线模量 $E_{\\mathrm{M,alg}} = \\dfrac{\\partial \\sigma^{M}}{\\partial \\varepsilon^{M}}$ 的标量表达式，用微观弹性模量 $E$ 和微观算法塑性模量 $H$ 表示。\n2. 使用您推导的表达式，计算当 $E = 210~\\mathrm{GPa}$ 和 $H = 1.5~\\mathrm{GPa}$ 时的 $E_{\\mathrm{M,alg}}$ 值。将您的最终数值结果四舍五入到四位有效数字。最终答案以 $\\mathrm{GPa}$ 为单位表示。\n3. 仅根据您的推导，解释算法塑性模量 $H$ 如何影响 $FE^2$ 中宏观牛顿迭代的收敛行为，并指出当 $H \\to 0$ 和 $H \\to \\infty$ 时的极限行为。\n\n您最终报告的答案必须是第 2 项中指定的单个实数。最终答案中不要包含任何中间量。",
            "solution": "该问题是有效的，因为它科学地基于计算塑性力学和多尺度力学的原理，问题提法良好，信息充分，可得到唯一解，并且以客观、正式的语言表述。我们可以开始求解。\n\n该问题要求完成三项任务：推导宏观一致性切线模量 $E_{\\mathrm{M,alg}}$，对其进行数值计算，并解释硬化模量 $H$ 对宏观求解器收敛性的影响。\n\n**1. 宏观一致性切线模量 $E_{\\mathrm{M,alg}}$ 的推导**\n\n宏观一致性切线模量定义为 $E_{\\mathrm{M,alg}} = \\frac{\\partial \\sigma^{M}}{\\partial \\varepsilon^{M}}$。在 $FE^2$ 框架下，对于施加了均匀运动学边界条件 (KUBC) 的均匀代表性体积单元 (RVE)，宏观尺度的体积平均量与微观尺度的均匀场直接相关。具体来说，宏观应变 $\\varepsilon^{M}$ 等于微观应变 $\\varepsilon$，宏观应力 $\\sigma^{M}$ 等于微观应力 $\\sigma$。因此，我们需要推导微观一致性切线模量 $E_{\\mathrm{alg}} = \\frac{\\partial \\sigma}{\\partial \\varepsilon}$。\n\n推导从一个通用时间步 $n+1$ 处的后向欧拉返回映射算法的时间离散方程开始。对于给定的总应变增量，状态变量从它们在时间步 $n$ 的已知值更新到在时间步 $n+1$ 的未知值。\n在时间步 $n+1$ 的控制方程是：\n1.  应变增量分解：$\\varepsilon_{n+1} = \\varepsilon_{n+1}^e + \\varepsilon_{n+1}^p$。\n2.  弹性定律：$\\sigma_{n+1} = E\\,\\varepsilon_{n+1}^e$。\n3.  流动法则（后向欧拉）：$\\varepsilon_{n+1}^p = \\varepsilon_n^p + \\Delta\\lambda\\,\\mathrm{sign}(\\sigma_{n+1})$。\n4.  硬化定律（后向欧拉）：$\\alpha_{n+1} = \\alpha_n + \\Delta\\lambda$。\n5.  塑性加载下的屈服条件：$f(\\sigma_{n+1}, \\alpha_{n+1}) = 0$。\n\n问题指明当前状态处于塑性加载中，且 $\\sigma > 0$。这意味着 $\\mathrm{sign}(\\sigma_{n+1}) = +1$，屈服条件变为 $|\\sigma_{n+1}| - \\sigma_y - H\\alpha_{n+1} = \\sigma_{n+1} - \\sigma_y - H\\alpha_{n+1} = 0$。\n\n结合这些方程，我们可以用总应变 $\\varepsilon_{n+1}$ 和时间步 $n$ 的状态来表示最终状态 $(\\sigma_{n+1}, \\varepsilon_{n+1}^p, \\alpha_{n+1})$。为了找到一致性切线模量，我们对这些隐式关系求导。最直接的方法是对该方程组关于总应变 $\\varepsilon_{n+1}$ 进行微分。令 $\\partial(\\cdot)$ 表示微分算子 $\\partial(\\cdot)/\\partial\\varepsilon_{n+1}$。\n\n由弹性定律和应变分解可得：\n$\\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon_{n+1}^p)$\n对 $\\varepsilon_{n+1}$ 求导得到：\n$\\partial\\sigma_{n+1} = E (1 - \\partial\\varepsilon_{n+1}^p)$\n\n由流动法则，针对 $\\sigma > 0$ 的情况：\n$\\varepsilon_{n+1}^p = \\varepsilon_n^p + \\Delta\\lambda$\n对 $\\varepsilon_{n+1}$ 求导（注意 $\\varepsilon_n^p$ 是上一步的常数）：\n$\\partial\\varepsilon_{n+1}^p = \\partial(\\Delta\\lambda)$\n\n由屈服条件，针对 $\\sigma > 0$ 的情况：\n$\\sigma_{n+1} - \\sigma_y - H\\alpha_{n+1} = 0$\n代入硬化定律 $\\alpha_{n+1} = \\alpha_n + \\Delta\\lambda$：\n$\\sigma_{n+1} - \\sigma_y - H(\\alpha_n + \\Delta\\lambda) = 0$\n对 $\\varepsilon_{n+1}$ 求导（注意 $\\sigma_y$ 和 $\\alpha_n$ 是常数）：\n$\\partial\\sigma_{n+1} - H\\,\\partial(\\Delta\\lambda) = 0 \\implies \\partial\\sigma_{n+1} = H\\,\\partial(\\Delta\\lambda)$\n\n现在我们得到一个包含三个微分关系的方程组：\n(i) $\\partial\\sigma_{n+1} = E (1 - \\partial\\varepsilon_{n+1}^p)$\n(ii) $\\partial\\varepsilon_{n+1}^p = \\partial(\\Delta\\lambda)$\n(iii) $\\partial\\sigma_{n+1} = H\\,\\partial(\\Delta\\lambda)$\n\n从 (ii) 和 (iii) 可得塑性应变微分与应力微分之间的关系：\n$\\partial\\varepsilon_{n+1}^p = \\frac{1}{H}\\partial\\sigma_{n+1}$\n\n将此关系代入方程 (i)：\n$\\partial\\sigma_{n+1} = E \\left(1 - \\frac{1}{H}\\partial\\sigma_{n+1}\\right) = E - \\frac{E}{H}\\partial\\sigma_{n+1}$\n\n现在，求解 $\\partial\\sigma_{n+1}$：\n$\\partial\\sigma_{n+1} + \\frac{E}{H}\\partial\\sigma_{n+1} = E$\n$\\partial\\sigma_{n+1} \\left(1 + \\frac{E}{H}\\right) = E$\n$\\partial\\sigma_{n+1} \\left(\\frac{H+E}{H}\\right) = E$\n$\\partial\\sigma_{n+1} = \\frac{EH}{E+H}$\n\n一致性切线模量是应力变化与应变变化之比，即 $\\partial\\sigma_{n+1}/\\partial\\varepsilon_{n+1}$。\n因此，微观算法切线模量为 $E_{\\mathrm{alg}} = \\frac{\\partial\\sigma_{n+1}}{\\partial\\varepsilon_{n+1}} = \\frac{EH}{E+H}$。\n对于这个简单问题，根据均质化法则（$\\sigma^M = \\sigma$, $\\varepsilon^M = \\varepsilon$），宏观一致性切线模量与微观一致性切线模量相同：\n$$E_{\\mathrm{M,alg}} = \\frac{EH}{E+H}$$\n\n该表达式是弹性模量 $E$ 和算法塑性模量 $H$ 的调和平均值。\n\n**2. $E_{\\mathrm{M,alg}}$ 的数值计算**\n\n给定数值 $E = 210~\\mathrm{GPa}$ 和 $H = 1.5~\\mathrm{GPa}$，我们将其代入推导出的表达式中：\n$$E_{\\mathrm{M,alg}} = \\frac{(210~\\mathrm{GPa})(1.5~\\mathrm{GPa})}{210~\\mathrm{GPa} + 1.5~\\mathrm{GPa}} = \\frac{315}{211.5}~\\mathrm{GPa}$$\n$$E_{\\mathrm{M,alg}} \\approx 1.4893617...~\\mathrm{GPa}$$\n四舍五入到四位有效数字，我们得到：\n$$E_{\\mathrm{M,alg}} = 1.489~\\mathrm{GPa}$$\n\n**3. $H$ 对宏观收敛性的影响**\n\n宏观有限元问题是一个非线性代数方程组，通常使用 Newton-Raphson 方法求解。这种迭代方法的收敛速度关键取决于所使用的切线刚度矩阵。为实现二次收敛，该矩阵必须由一致性切线模量构建，它正是残差向量对节点自由度的精确导数。在本问题中，$E_{\\mathrm{M,alg}} = \\frac{EH}{E+H}$ 正是该材料点的一致性切线模量。\n\n算法塑性模量 $H$ 直接影响 $E_{\\mathrm{M,alg}}$ 的值，从而决定了塑性变形过程中的宏观刚度。其数值对于 $FE^2$ 模拟的数值性能至关重要。\n\n- **当 $H \\to 0$ 时的极限行为（理想塑性）：**\n当 $H$ 趋近于 $0$ 时，宏观切线模量变为：\n$$\\lim_{H \\to 0} E_{\\mathrm{M,alg}} = \\lim_{H \\to 0} \\frac{EH}{E+H} = 0$$\n零切线模量意味着在经历塑性流动的积分点处，宏观刚度矩阵变为奇异（或接近奇异）。这给标准的 Newton-Raphson 求解器带来了严重的数值困难，使其无法找到解。这种行为对应于达到极限载荷，需要专门的求解器（例如，弧长法）才能继续求解。\n\n- **当 $H \\to \\infty$ 时的极限行为：**\n当 $H$ 趋近于无穷大时，宏观切线模量变为：\n$$\\lim_{H \\to \\infty} E_{\\mathrm{M,alg}} = \\lim_{H \\to \\infty} \\frac{EH}{E+H} = \\lim_{H \\to \\infty} \\frac{E}{\\frac{E}{H}+1} = \\frac{E}{0+1} = E$$\n无限大的硬化模量意味着需要无限大的应力才能引起进一步的塑性应变。材料的有效行为如同纯弹性体。宏观切线模量恢复为弹性模量 $E$。宏观问题变为线性问题，Newton-Raphson 求解器在一次迭代内收敛。\n\n总而言之，$H$ 的值控制着材料的屈服后刚度。使用正确的、依赖于 $H$ 的 $E_{\\mathrm{M,alg}}$ 可确保宏观牛顿迭代的二次收敛性。$H \\to 0$ 和 $H \\to \\infty$ 的极端情况分别导致病态（奇异）和良态（线弹性）问题。",
            "answer": "$$\\boxed{1.489}$$"
        },
        {
            "introduction": "随着微观结构模型变得日益复杂，手动推导一致切线模量将变得异常繁琐且容易出错。本练习介绍了一种强大而现代的解决方案：自动微分（AD）。通过构建一个基础的前向模式自动微分框架（对偶数）并将其应用于$FE^2$问题，您将学习如何系统地、精确地获得宏观切线，从而为模拟任意复杂的微观力学行为铺平道路。",
            "id": "3498300",
            "problem": "要求您在一个空间维度中，基于平方有限元 ($FE^2$) 范式，实现一个最小并发多尺度演示。您需要使用前向模式自动微分来获得精确的微观层面线性化，并将其传递以得到一致的宏观层面切线。设定为一个长度为 $L$ 的一维代表性体积单元 (RVE)，该单元由2个等长的线性单元离散化，节点位于位置 $x_{0}=0$、$x_{1}=L/2$、$x_{2}=L$。宏观小应变为标量 $E_{\\mathrm{bar}} \\in \\mathbb{R}$。微观运动学施加了 Dirichlet 边界条件，使得节点 $i$ 的总微观位移为 $u_{i}^{\\text{tot}} = E_{\\mathrm{bar}} x_{i} + w_{i}$，其中 $w_{0} = 0$，$w_{2} = 0$，唯一的未知微观涨落自由度是 $w_{1} \\in \\mathbb{R}$。横截面积为 $A=1$，域长度为 $L=1$，二者均以米为单位。\n\n材料在小应变下是超弹性的，其储能密度为 $W(\\varepsilon) = \\tfrac{1}{2} E \\varepsilon^{2} + \\tfrac{1}{4} \\alpha \\varepsilon^{4}$，其中 $\\varepsilon$ 是轴向应变，$E > 0$ 是一个常数，单位为帕斯卡，$\\alpha \\ge 0$ 也是一个常数，单位为帕斯卡。Cauchy 应力为 $\\sigma(\\varepsilon) = \\dfrac{\\partial W}{\\partial \\varepsilon}(\\varepsilon)$，一致（微观）切线为 $c_{\\mu}(\\varepsilon) = \\dfrac{\\partial \\sigma}{\\partial \\varepsilon}(\\varepsilon)$。\n\n对于每个节点为 $\\{i,j\\}$、单元长度为 $\\ell_{e} = L/2$ 的单元 $e \\in \\{0,1\\}$，其单元应变为常数，由 $\\varepsilon_{e} = \\dfrac{u_{j}^{\\text{tot}} - u_{i}^{\\text{tot}}}{\\ell_{e}}$ 给出。单元 $e$ 的内力向量为 $f^{(e)} = \\int_{x_{e}} B^{T} \\sigma(\\varepsilon_{e}) A \\, \\mathrm{d}x$，由于 $B = \\left[-1/\\ell_{e}, \\, 1/\\ell_{e}\\right]$ 是常数且 $A=1$，该式可简化为 $f^{(e)} = \\left[ -\\sigma(\\varepsilon_{e}), \\, \\sigma(\\varepsilon_{e}) \\right]$。内部节点处的标量微观残差是在节点 $x_{1}$ 处组装的内力贡献之和：\n$$\nr(w_{1}, E_{\\mathrm{bar}}) = \\sigma(\\varepsilon_{0}) - \\sigma(\\varepsilon_{1}),\n$$\n其中 $\\varepsilon_{0} = E_{\\mathrm{bar}} + \\dfrac{w_{1}-0}{\\ell_{0}}$ 且 $\\varepsilon_{1} = E_{\\mathrm{bar}} + \\dfrac{0 - w_{1}}{\\ell_{1}}$。\n\n您必须：\n- 实现前向模式自动微分，以评估残差 $r(w_{1}, E_{\\mathrm{bar}})$ 及其关于两个参数的精确雅可比矩阵，即 $\\dfrac{\\partial r}{\\partial w_{1}}$ 和 $\\dfrac{\\partial r}{\\partial E_{\\mathrm{bar}}}$，它们共同代表了残差线性化中出现的微观层面切线 $\\mathbb{c}_{\\mu}$。\n- 通过 Newton 法求解微观平衡 $r(w_{1}, E_{\\mathrm{bar}}) = 0$ 以得到 $w_{1}$，其中使用通过自动微分得到的精确切线 $\\dfrac{\\partial r}{\\partial w_{1}}$。\n- 计算均质化宏观应力，即体积平均值\n$$\n\\Sigma_{\\mathrm{bar}}(w_{1}, E_{\\mathrm{bar}}) = \\frac{1}{L} \\sum_{e=0}^{1} \\sigma(\\varepsilon_{e}) \\, \\ell_{e},\n$$\n并在收敛的微观状态下使用自动微分评估其偏导数 $\\dfrac{\\partial \\Sigma_{\\mathrm{bar}}}{\\partial w_{1}}$ 和 $\\dfrac{\\partial \\Sigma_{\\mathrm{bar}}}{\\partial E_{\\mathrm{bar}}}$。\n- 仅使用基本原理（弱形式下的线性动量平衡、链式法则和隐函数定理），推导并实现一致宏观切线\n$$\n\\mathbb{C} = \\frac{\\mathrm{d} \\Sigma_{\\mathrm{bar}}}{\\mathrm{d} E_{\\mathrm{bar}}},\n$$\n该切线考虑了通过平衡约束产生的诱导相关性 $w_{1}(E_{\\mathrm{bar}})$。\n\n验证方案：\n- 对于每个测试用例，还需通过在 $E_{\\mathrm{bar}} + h$ 和 $E_{\\mathrm{bar}} - h$（其中 $h$ 是一个小量）处重新求解微观平衡来计算 $\\dfrac{\\mathrm{d} \\Sigma_{\\mathrm{bar}}}{\\mathrm{d} E_{\\mathrm{bar}}}$ 的中心差分正割近似，然后构成\n$$\n\\mathbb{C}_{\\text{sec}} \\approx \\frac{\\Sigma_{\\mathrm{bar}}(E_{\\mathrm{bar}}+h) - \\Sigma_{\\mathrm{bar}}(E_{\\mathrm{bar}}-h)}{2h}.\n$$\n\n任务要求：\n- 实现一个完整的程序，使用您自己实现的前向模式自动微分（对偶数或等效方法）来执行上述步骤，不使用任何外部自动微分库。\n- 使用 $L=1$（单位：米）和 $A=1$（单位：平方米）。\n- 所有应力和切线均以帕斯卡表示，并生成由标准双精度行为四舍五入的浮点输出。\n- 不涉及角度。\n- 最终程序必须对所有测试用例执行计算，并打印一行包含一个 Python 风格的数字列表，该列表按顺序包含每个测试用例的三元组 $\\left[\\mathbb{C}, \\mathbb{C}_{\\text{sec}}, |\\mathbb{C} - \\mathbb{C}_{\\text{sec}}|\\right]$，并连接成一个单一列表。不得打印任何其他文本。\n\n测试套件：\n- 案例 1（理想路径，线性）：$E = 1000.0$，$\\alpha = 0.0$，$E_{\\mathrm{bar}} = 0.01$。\n- 案例 2（中度非线性）：$E = 1000.0$，$\\alpha = 500.0$，$E_{\\mathrm{bar}} = 0.1$。\n- 案例 3（零应变边界）：$E = 1000.0$，$\\alpha = 500.0$，$E_{\\mathrm{bar}} = 0.0$。\n- 案例 4（较大应变边缘）：$E = 1000.0$，$\\alpha = 200.0$，$E_{\\mathrm{bar}} = 0.5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $\\left[\\text{result}_{1}, \\text{result}_{2}, \\ldots\\right]$）。",
            "solution": "问题陈述经评估有效。它描述了一个在计算多尺度力学中适定且有科学依据的问题，该问题存在唯一且可验证的解。该问题是平方有限元 ($FE^2$) 方法的一个具体但简化的实例。\n\n$FE^2$ 方法是一种并发多尺度方法，它将宏观材料模型与微观代表性体积单元 (RVE) 的详细响应联系起来。对于每种宏观变形状态，都会在 RVE 上求解一个边界值问题，以确定微观场和相应的均质化宏观应力。此方法的一个关键方面是计算一致宏观切线模量，它正确地将宏观应力相对于宏观应变进行线性化，同时考虑了微观状态的演化。此问题要求为一维 RVE 实现整个过程，并使用前向模式自动微分 (AD) 来获得精确的雅可比矩阵。\n\n**问题公式化**\n\nRVE 是一根长度为 $L=1$ 的一维杆，由 2 个等长的线性有限元离散化。节点位于 $x_{0}=0$、$x_{1}=L/2=0.5$ 和 $x_{2}=L=1$。对于 $e=0,1$，单元长度为 $\\ell_e = L/2 = 0.5$。\n\n**运动学**\n\n节点 $i$ 的总位移 $u_{i}^{\\text{tot}}$ 假定为宏观仿射运动和微观涨落 $w_i$ 的叠加：\n$$u_{i}^{\\text{tot}} = E_{\\mathrm{bar}} x_{i} + w_{i}$$\n其中 $E_{\\mathrm{bar}}$ 是给定的均匀宏观应变。涨落的边界条件为 $w_{0} = 0$ 和 $w_{2} = 0$，代表了小应变设置中的微观周期性。唯一的未知自由度是内部节点处的涨落 $w_{1}$。\n\n在节点为 $\\{i,j\\}$ 的每个单元 $e$ 中的常数应变为：\n$$\\varepsilon_{e} = \\frac{u_{j}^{\\text{tot}} - u_{i}^{\\text{tot}}}{\\ell_{e}}$$\n对于单元 0（节点 0,1）：$\\varepsilon_{0} = \\frac{(E_{\\mathrm{bar}} x_1 + w_1) - (E_{\\mathrm{bar}} x_0 + w_0)}{\\ell_0} = \\frac{E_{\\mathrm{bar}}(L/2) + w_1}{L/2} = E_{\\mathrm{bar}} + \\frac{2w_1}{L}$。\n对于单元 1（节点 1,2）：$\\varepsilon_{1} = \\frac{(E_{\\mathrm{bar}} x_2 + w_2) - (E_{\\mathrm{bar}} x_1 + w_1)}{\\ell_1} = \\frac{E_{\\mathrm{bar}}L - (E_{\\mathrm{bar}}(L/2) + w_1)}{L/2} = E_{\\mathrm{bar}} - \\frac{2w_1}{L}$。\n当 $L=1$ 时，我们有 $\\varepsilon_{0} = E_{\\mathrm{bar}} + 2w_1$ 和 $\\varepsilon_{1} = E_{\\mathrm{bar}} - 2w_1$。\n\n**本构模型**\n\n材料是超弹性的，其储能密度为 $W(\\varepsilon) = \\tfrac{1}{2} E \\varepsilon^{2} + \\tfrac{1}{4} \\alpha \\varepsilon^{4}$。Cauchy 应力 $\\sigma(\\varepsilon)$ 和材料切线 $c_{\\mu}(\\varepsilon)$ 分别为：\n$$\\sigma(\\varepsilon) = \\frac{\\partial W}{\\partial \\varepsilon} = E \\varepsilon + \\alpha \\varepsilon^{3}$$\n$$c_{\\mu}(\\varepsilon) = \\frac{\\partial \\sigma}{\\partial \\varepsilon} = E + 3 \\alpha \\varepsilon^{2}$$\n\n**微观平衡（RVE 问题）**\n\nRVE 的平衡是通过在自由内部节点 $x_1$ 处施加力平衡来找到的。来自单元 $e$ 作用于其节点上的内力由 $f^{(e)} = A \\left[ -\\sigma(\\varepsilon_{e}), \\, \\sigma(\\varepsilon_{e}) \\right]^{T}$ 的组装给出（面积 $A=1$）。节点 1 处的残差 $r$ 是来自单元 0 和单元 1 的力之和：\n$$r(w_1, E_{\\mathrm{bar}}) = \\sigma(\\varepsilon_0) - \\sigma(\\varepsilon_1) = 0$$\n对于任何给定的 $E_{\\mathrm{bar}}$，都必须求解这个非线性标量方程以得到 $w_1$。我们将使用 Newton 法，这需要导数 $\\frac{\\partial r}{\\partial w_1}$。\n\n**均质化与宏观应力**\n\n宏观应力 $\\Sigma_{\\mathrm{bar}}$ 是微观应力的体积平均值：\n$$\\Sigma_{\\mathrm{bar}} = \\frac{1}{V} \\int_V \\sigma(\\varepsilon(x)) \\mathrm{d}V = \\frac{1}{AL} \\sum_{e=0}^{1} \\int_{V_e} \\sigma(\\varepsilon_e) \\mathrm{d}V_e = \\frac{1}{L} \\sum_{e=0}^{1} \\sigma(\\varepsilon_e) \\ell_e$$\n由于 $\\ell_0 = \\ell_1 = L/2$，这可以简化为：\n$$\\Sigma_{\\mathrm{bar}}(w_1, E_{\\mathrm{bar}}) = \\frac{1}{2} \\left[ \\sigma(\\varepsilon_0) + \\sigma(\\varepsilon_1) \\right]$$\n\n**一致切线模量**\n\n主要目标是计算一致宏观切线模量 $\\mathbb{C}$，它定义为宏观应力对宏观应变的全导数：\n$$\\mathbb{C} = \\frac{\\mathrm{d} \\Sigma_{\\mathrm{bar}}}{\\mathrm{d} E_{\\mathrm{bar}}}$$\n由于 $w_1$ 是通过平衡条件 $r(w_1(E_{\\mathrm{bar}}), E_{\\mathrm{bar}}) = 0$ 确定的 $E_{\\mathrm{bar}}$ 的隐函数，我们应用链式法则：\n$$\\mathbb{C} = \\frac{\\partial \\Sigma_{\\mathrm{bar}}}{\\partial E_{\\mathrm{bar}}} + \\frac{\\partial \\Sigma_{\\mathrm{bar}}}{\\partial w_1} \\frac{\\mathrm{d} w_1}{\\mathrm{d} E_{\\mathrm{bar}}}$$\n项 $\\frac{\\mathrm{d} w_1}{\\mathrm{d} E_{\\mathrm{bar}}}$ 是通过使用隐函数定理将平衡方程 $r=0$ 对 $E_{\\mathrm{bar}}$ 求导得到的：\n$$\\frac{\\mathrm{d} r}{\\mathrm{d} E_{\\mathrm{bar}}} = \\frac{\\partial r}{\\partial E_{\\mathrm{bar}}} + \\frac{\\partial r}{\\partial w_1} \\frac{\\mathrm{d} w_1}{\\mathrmd E_{\\mathrm{bar}}} = 0 \\implies \\frac{\\mathrm{d} w_1}{\\mathrmd E_{\\mathrm{bar}}} = - \\left( \\frac{\\partial r}{\\partial w_1} \\right)^{-1} \\frac{\\partial r}{\\partial E_{\\mathrm{bar}}}$$\n将此代入 $\\mathbb{C}$ 的表达式中，得到一致切线公式：\n$$\\mathbb{C} = \\frac{\\partial \\Sigma_{\\mathrm{bar}}}{\\partial E_{\\mathrm{bar}}} - \\frac{\\partial \\Sigma_{\\mathrm{bar}}}{\\partial w_1} \\left( \\frac{\\partial r}{\\partial w_1} \\right)^{-1} \\frac{\\partial r}{\\partial E_{\\mathrm{bar}}}$$\n这是 $FE^2$ 切线的一般表达式。四个偏导数 $\\frac{\\partial \\Sigma_{\\mathrm{bar}}}{\\partial E_{\\mathrm{bar}}}$、$\\frac{\\partial \\Sigma_{\\mathrm{bar}}}{\\partial w_1}$、$\\frac{\\partial r}{\\partial E_{\\mathrm{bar}}}$ 和 $\\frac{\\partial r}{\\partial w_1}$ 将使用自动微分精确计算。\n\n**对称性与简化**\n\n对于特定的问题设置——对称几何（2个相同的单元）和对称的材料定律（$\\sigma(\\varepsilon)$ 是奇函数）——RVE 响应得以简化。平衡方程为 $\\sigma(E_{\\mathrm{bar}} + 2w_1) = \\sigma(E_{\\mathrm{bar}} - 2w_1)$。由于 $\\sigma$ 是严格递增的（$c_{\\mu} > 0$），这意味着 $E_{\\mathrm{bar}} + 2w_1 = E_{\\mathrm{bar}} - 2w_1$，从而得到 $4w_1 = 0$，即 $w_1=0$。因此，对于这个特定的 RVE，无论宏观应变 $E_{\\mathrm{bar}}$ 如何，微观涨落始终为零。\n这意味着 Newton 求解器将从 $w_1=0$ 的初始猜测立即收敛。这也意味着 $\\frac{\\mathrm{d} w_1}{\\mathrm{d} E_{\\mathrm{bar}}} = 0$。因此，一致切线简化为 $\\mathbb{C} = \\frac{\\partial \\Sigma_{\\mathrm{bar}}}{\\partial E_{\\mathrm{bar}}}$。在 $w_1=0$ 时，$\\varepsilon_0 = \\varepsilon_1 = E_{\\mathrm{bar}}$，且 $\\Sigma_{\\mathrm{bar}} = \\sigma(E_{\\mathrm{bar}})$，所以 $\\mathbb{C} = c_{\\mu}(E_{\\mathrm{bar}}) = E + 3\\alpha E_{\\mathrm{bar}}^2$。虽然这是一个实质性的简化，但实现将基于 $\\mathbb{C}$ 的通用公式，以演示完整的方法论。\n\n**算法实现**\n\n该解决方案在 Python 中实现。\n1. **前向模式自动微分：** 实现了一个 `Dual` 数类来表示形式为 $x = x_{\\text{real}} + x_{\\text{dual}}\\epsilon$ 的数，其中 $\\epsilon^2=0$。算术运算（$+,-,*,/,\\text{pow}$）被重载，以根据链式法则传播导数。对于函数 $y=f(x)$，如果我们用输入 $x=x_0 + 1\\epsilon$ 对其求值，结果将是 $y_0 + f'(x_0)\\epsilon$。\n2. **RVE 求解器：** 一个函数 `solve_micro_problem` 实现了 Newton 法来求解 $r(w_1, E_{\\mathrm{bar}})=0$ 以找到 $w_1$。在每一步中，使用 `Dual` 数类计算残差 $r$ 及其雅可比矩阵 $\\frac{\\partial r}{\\partial w_1}$。\n3. **切线计算：** 在收敛状态 $(w_1^{\\text{conv}}, E_{\\mathrm{bar}})$，通过使用适当的对偶数输入调用 `compute_residual` 和 `compute_macro_stress` 函数，来计算 $\\mathbb{C}$ 公式中的四个偏导数。然后将这些导数组装起来得到 $\\mathbb{C}$。\n4. **验证：** 解析切线 $\\mathbb{C}$ 与通过中心差分方案（使用小扰动 $h$）计算的数值切线 $\\mathbb{C}_{\\text{sec}}$ 进行验证：\n$$\\mathbb{C}_{\\text{sec}} \\approx \\frac{\\Sigma_{\\mathrm{bar}}(E_{\\mathrm{bar}}+h) - \\Sigma_{\\mathrm{bar}}(E_{\\mathrm{bar}}-h)}{2h}$$\n这需要再求解两次 RVE 问题，分别在 $E_{\\mathrm{bar}}+h$ 和 $E_{\\mathrm{bar}}-h$ 处。绝对差 $|\\mathbb{C} - \\mathbb{C}_{\\text{sec}}|$ 作为正确性的度量。\n程序遍历所提供的测试用例，为每个用例执行这些计算，并按要求格式化输出。",
            "answer": "```python\nimport numpy as np\n\nclass Dual:\n    \"\"\"A minimal implementation of a dual number for forward-mode AD.\"\"\"\n    def __init__(self, real, dual=0.0):\n        self.real = real\n        self.dual = dual\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.real + other.real, self.dual + other.dual)\n        return Dual(self.real + other, self.dual)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.real - other.real, self.dual - other.dual)\n        return Dual(self.real - other, self.dual)\n\n    def __rsub__(self, other):\n        return Dual(other - self.real, -self.dual)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.real * other.real, self.real * other.dual + self.dual * other.real)\n        return Dual(self.real * other, self.dual * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            val = other.real\n            return Dual(self.real / val, (self.dual * val - self.real * other.dual) / (val**2))\n        return Dual(self.real / other, self.dual / other)\n\n    def __rtruediv__(self, other):\n        val = self.real\n        return Dual(other / val, -other * self.dual / (val**2))\n\n    def __pow__(self, power):\n        # Power must be a scalar (int or float)\n        if self.real == 0.0 and power-1  0: # Handle edge case for derivative\n            return Dual(0.0, float('inf'))\n        return Dual(self.real**power, power * (self.real**(power - 1)) * self.dual)\n\n    def __neg__(self):\n        return Dual(-self.real, -self.dual)\n        \n    def __repr__(self):\n        return f\"({self.real} + {self.dual}ε)\"\n\ndef solve():\n    \"\"\"Main solver function to execute the FE^2 simulation task.\"\"\"\n\n    L = 1.0\n    ell = L / 2.0\n\n    def compute_residual(w1, E_bar, E, alpha):\n        \"\"\"Computes the microscopic residual r, compatible with Dual numbers.\"\"\"\n        epsilon0 = E_bar + w1 / ell\n        epsilon1 = E_bar - w1 / ell\n        \n        sigma0 = E * epsilon0 + alpha * epsilon0**3\n        sigma1 = E * epsilon1 + alpha * epsilon1**3\n        \n        return sigma0 - sigma1\n\n    def compute_macro_stress(w1, E_bar, E, alpha):\n        \"\"\"Computes the homogenized macroscopic stress Sigma_bar, compatible with Dual numbers.\"\"\"\n        epsilon0 = E_bar + w1 / ell\n        epsilon1 = E_bar - w1 / ell\n        \n        sigma0 = E * epsilon0 + alpha * epsilon0**3\n        sigma1 = E * epsilon1 + alpha * epsilon1**3\n        \n        # Volume average simplifies to 0.5 * (sigma0 + sigma1)\n        return 0.5 * (sigma0 + sigma1)\n\n    def solve_micro_problem(E_bar, E, alpha, tol=1e-12, max_iter=20):\n        \"\"\"Solves r(w1, E_bar) = 0 for w1 using Newton's method.\"\"\"\n        w1 = 0.0  # Initial guess\n        \n        for _ in range(max_iter):\n            # Use AD to get residual and its derivative wrt w1\n            r_dual = compute_residual(Dual(w1, 1.0), E_bar, E, alpha)\n            r_val = r_dual.real\n            \n            if abs(r_val)  tol:\n                return w1\n            \n            dr_dw1 = r_dual.dual\n            if abs(dr_dw1)  1e-15: # Avoid division by zero\n                # This case is not expected for the given problem physics\n                break\n                \n            w1 = w1 - r_val / dr_dw1\n            \n        return w1\n\n    def process_case(E, alpha, E_bar):\n        \"\"\"Processes a single test case to find C, C_sec, and the error.\"\"\"\n        # 1. Solve the micro problem to find the equilibrium fluctuation w1\n        w1_conv = solve_micro_problem(E_bar, E, alpha)\n        \n        # 2. Compute the required partial derivatives at the converged state using AD\n        # Derivatives of r and Sigma_bar with respect to w1\n        dr_dw1 = compute_residual(Dual(w1_conv, 1.0), E_bar, E, alpha).dual\n        dsigma_bar_dw1 = compute_macro_stress(Dual(w1_conv, 1.0), E_bar, E, alpha).dual\n        \n        # Derivatives of r and Sigma_bar with respect to E_bar\n        dr_dEbar = compute_residual(w1_conv, Dual(E_bar, 1.0), E, alpha).dual\n        dsigma_bar_dEbar = compute_macro_stress(w1_conv, Dual(E_bar, 1.0), E, alpha).dual\n        \n        # 3. Assemble the consistent macroscopic tangent C\n        # C = d(Sigma_bar)/d(E_bar) - [d(Sigma_bar)/d(w1)] * [d(r)/d(w1)]^-1 * [d(r)/d(E_bar)]\n        C = dsigma_bar_dEbar - dsigma_bar_dw1 * (1.0 / dr_dw1) * dr_dEbar\n        \n        # 4. Compute the numerical tangent C_sec for verification\n        h = 1e-7\n        \n        # Solve at E_bar + h\n        w1_plus = solve_micro_problem(E_bar + h, E, alpha)\n        sigma_bar_plus = compute_macro_stress(w1_plus, E_bar + h, E, alpha)\n\n        # Solve at E_bar - h\n        w1_minus = solve_micro_problem(E_bar - h, E, alpha)\n        sigma_bar_minus = compute_macro_stress(w1_minus, E_bar - h, E, alpha)\n        \n        C_sec = (sigma_bar_plus - sigma_bar_minus) / (2 * h)\n        \n        # 5. Compute the absolute error\n        error = abs(C - C_sec)\n        \n        return C, C_sec, error\n\n    test_cases = [\n        # E, alpha, E_bar\n        (1000.0, 0.0, 0.01),\n        (1000.0, 500.0, 0.1),\n        (1000.0, 500.0, 0.0),\n        (1000.0, 200.0, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        E, alpha, E_bar = case\n        C_val, C_sec_val, error_val = process_case(E, alpha, E_bar)\n        results.extend([C_val, C_sec_val, error_val])\n    \n    print(f\"[{','.join(f'{x:.15g}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}