{
    "hands_on_practices": [
        {
            "introduction": "这个练习是一项基础但至关重要的推导。它将引导您使用拉格朗日方法，从第一性原理出发，为一个通用的线性系统推导出伴随方程和灵敏度表达式。掌握这一推导是理解伴随法为何有效，以及它如何巧妙地避免计算状态灵敏度的关键。",
            "id": "2594547",
            "problem": "考虑一个线性的、参数化的有限元法 (FEM) 模型，其离散状态向量为 $u(p) \\in \\mathbb{R}^{n}$，由以下平衡方程控制\n$$\nK(p)\\,u(p) \\;=\\; f(p),\n$$\n其中 $K(p) \\in \\mathbb{R}^{n \\times n}$ 是一个参数相关的刚度矩阵，对于所关心的参数值是非奇异的，而 $f(p) \\in \\mathbb{R}^{n}$ 是参数相关的载荷向量。令输出泛函为\n$$\nJ(u,p) \\;=\\; \\tfrac{1}{2}\\,u^{T}\\,Q(p)\\,u,\n$$\n其中 $Q(p) \\in \\mathbb{R}^{n \\times n}$ 是对称的，并且关于标量参数 $p \\in \\mathbb{R}$ 充分光滑。假设所有函数均按需可微。\n\n仅使用第一性原理（链式法则、状态方程的线性化和拉格朗日乘子），执行以下操作：\n\n1) 计算偏导数 $\\partial J/\\partial u$。\n\n2) 引入一个伴随向量 $\\lambda(p) \\in \\mathbb{R}^{n}$，以从全导数 $\\mathrm{d}J/\\mathrm{d}p$ 中消除对状态灵敏度 $\\mathrm{d}u/\\mathrm{d}p$ 的依赖。从残差 $R(u,p) = K(p)\\,u - f(p) = 0$ 出发，推导：\n- 一个定义 $\\lambda(p)$ 的伴随方程，以及\n- 一个完全用 $K$、$Q$、$u$ 以及关于 $p$ 的参数导数表示的 $\\mathrm{d}J/\\mathrm{d}p$ 的显式表达式。\n\n不要假设 $K(p)$ 是对称的。您可以使用标准的欧几里得内积来构成对偶配对。\n\n3) 简要解释为什么您最终的梯度表达式不需要求解 $\\mathrm{d}u/\\mathrm{d}p$。\n\n请提供一个关于 $K$、$Q$、$u$、$\\tfrac{\\partial K}{\\partial p}$、$\\tfrac{\\partial f}{\\partial p}$、$\\tfrac{\\partial Q}{\\partial p}$ 以及满足您的伴随方程的伴随向量 $\\lambda$ 的 $\\mathrm{d}J/\\mathrm{d}p$ 的单一闭式解析表达式作为您的最终答案。不需要进行数值代入。您的最终答案必须是一个单一的符号表达式，并且不得包含任何单位。",
            "solution": "在尝试求解之前，对所述问题进行验证。\n\n首先，逐字提取已知条件。\n- 状态方程：$K(p)\\,u(p) \\;=\\; f(p)$，其中 $K(p) \\in \\mathbb{R}^{n \\times n}$ 是非奇异的，$u(p) \\in \\mathbb{R}^{n}$，$f(p) \\in \\mathbb{R}^{n}$。\n- 输出泛函：$J(u,p) \\;=\\; \\tfrac{1}{2}\\,u^{T}\\,Q(p)\\,u$，其中 $Q(p) \\in \\mathbb{R}^{n \\times n}$ 是对称且光滑的。\n- 参数：$p \\in \\mathbb{R}$ 是一个标量。\n- 假设：所有函数均按需可微。矩阵 $K(p)$ 不假设为对称的。\n- 任务：$1$) 计算 $\\partial J/\\partial u$。$2$) 推导伴随方程以及一个消除了对 $\\mathrm{d}u/\\mathrm{d}p$ 依赖的 $\\mathrm{d}J/\\mathrm{d}p$ 表达式。$3$) 解释为何能消除 $\\mathrm{d}u/\\mathrm{d}p$ 项。\n\n其次，根据所需标准对问题进行验证。\n- **科学依据**：该问题是使用伴随方法进行灵敏度分析的一个标准练习，这是优化、最优控制和计算工程中的一项基本技术。它牢固地建立在向量微积分和线性代数的既定原理之上。\n- **适定性**：该问题是适定的。$K(p)$ 是非奇异的先验假设确保了状态向量 $u(p)$ 是唯一定义的。在给定的光滑性假设下，所需的泛函导数和伴随系统是唯一可确定的。\n- **客观性**：该问题以精确、无歧义的数学语言陈述。\n- **完整性与一致性**：该问题提供了所有必要的定义和约束。没有内部矛盾。\n- **可行性与结构**：该问题是一个理论推导，完全可行。其结构逻辑清晰，并指导从第一性原理进行逐步推导。\n\n该问题被认为是有效的，因为它满足所有标准。现在将构建一个解决方案。\n\n**1) 计算 $\\partial J/\\partial u$**\n\n输出泛函由 $J(u,p) = \\frac{1}{2} u^T Q(p) u$ 给出。为了计算标量 $J$ 关于向量 $u$ 的偏导数，我们考虑在固定参数 $p$ 下，对于一个扰动 $\\mathrm{d}u$ 的微分 $\\mathrm{d}J$。\n$$\n\\mathrm{d}J = \\frac{1}{2} (\\mathrm{d}u)^T Q u + \\frac{1}{2} u^T Q (\\mathrm{d}u)\n$$\n由于 $(\\mathrm{d}u)^T Q u$ 是一个标量，它等于其自身的转置：$(\\mathrm{d}u)^T Q u = (u^T Q^T (\\mathrm{d}u))^T = u^T Q^T (\\mathrm{d}u)$。将此代入第一项得到：\n$$\n\\mathrm{d}J = \\frac{1}{2} u^T Q^T (\\mathrm{d}u) + \\frac{1}{2} u^T Q (\\mathrm{d}u) = \\frac{1}{2} u^T (Q^T + Q) \\mathrm{d}u\n$$\n问题陈述矩阵 $Q(p)$ 是对称的，因此 $Q^T = Q$。表达式简化为：\n$$\n\\mathrm{d}J = \\frac{1}{2} u^T (2Q) \\mathrm{d}u = u^T Q \\mathrm{d}u\n$$\n根据定义，微分 $\\mathrm{d}J$ 通过 $\\mathrm{d}J = \\frac{\\partial J}{\\partial u} \\mathrm{d}u$ 与偏导数（一个行向量，或余向量）相关。通过比较，我们确定 $J$ 关于 $u$ 的偏导数为：\n$$\n\\frac{\\partial J}{\\partial u} = u^T Q(p)\n$$\n$J$ 关于 $u$ 的梯度，记作 $\\nabla_u J$，是此行向量的转置，即列向量 $Q(p)u$。\n\n**2) 伴随方程和灵敏度表达式的推导**\n\n目标是求全导数 $\\mathrm{d}J/\\mathrm{d}p$。泛函 $J$ 既通过 $Q(p)$ 显式地依赖于 $p$，也通过状态向量 $u(p)$ 隐式地依赖于 $p$。应用多变量链式法则：\n$$\n\\frac{\\mathrm{d}J}{\\mathrm{d}p} = \\frac{\\partial J}{\\partial p} + \\frac{\\partial J}{\\partial u} \\frac{\\mathrm{d}u}{\\mathrm{d}p}\n$$\n第一项，即显式导数，是通过在保持 $u$ 不变的情况下对 $J$ 关于 $p$ 求导来计算的：\n$$\n\\frac{\\partial J}{\\partial p} = \\frac{\\partial}{\\partial p} \\left( \\frac{1}{2} u^T Q(p) u \\right) = \\frac{1}{2} u^T \\frac{\\partial Q}{\\partial p} u\n$$\n将此结果和第1部分的结果代入，得到全导数的表达式，这被称为直接灵敏度公式：\n$$\n\\frac{\\mathrm{d}J}{\\mathrm{d}p} = \\frac{1}{2} u^T \\frac{\\partial Q}{\\partial p} u + u^T Q \\frac{\\mathrm{d}u}{\\mathrm{d}p}\n$$\n这个表达式依赖于状态灵敏度 $\\mathrm{d}u/\\mathrm{d}p$，其计算成本很高，因为它需要为每个参数求解一个线性系统。伴随方法可以避免这个问题。\n\n我们使用拉格朗日乘子法。约束是状态方程，写成残差形式 $R(u,p) = K(p)u - f(p) = 0$。我们使用一个拉格朗日乘子向量 $\\lambda \\in \\mathbb{R}^n$（我们称之为伴随向量）将约束附加到原始泛函 $J$ 上，从而构成增广泛函 $\\mathcal{L}$。\n$$\n\\mathcal{L}(u, p, \\lambda) = J(u, p) + \\lambda^T R(u, p) = \\frac{1}{2} u^T Q u + \\lambda^T (Ku - f)\n$$\n由于状态方程总是满足的（$R(u(p), p) = 0$），对于任何 $\\lambda$ 的选择，我们都有 $\\mathcal{L} = J$。因此，它们关于 $p$ 的全导数相等：$\\mathrm{d}J/\\mathrm{d}p = \\mathrm{d}\\mathcal{L}/\\mathrm{d}p$。我们将 $\\mathcal{L}$ 视为 $u$、$p$ 和 $\\lambda$ 的函数，并对其应用链式法则来计算 $\\mathrm{d}\\mathcal{L}/\\mathrm{d}p$：\n$$\n\\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}p} = \\frac{\\partial \\mathcal{L}}{\\partial p} + \\frac{\\partial \\mathcal{L}}{\\partial u} \\frac{\\mathrm{d}u}{\\mathrm{d}p} + \\frac{\\partial \\mathcal{L}}{\\partial \\lambda} \\frac{\\mathrm{d}\\lambda}{\\mathrm{d}p}\n$$\n伴随方法的核心是选择 $\\lambda$ 来消去包含状态灵敏度 $\\mathrm{d}u/\\mathrm{d}p$ 的项。这通过将其系数设为零来实现：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial u} = 0\n$$\n我们来计算这个偏导数：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial u} = \\frac{\\partial}{\\partial u} \\left( \\frac{1}{2} u^T Q u + \\lambda^T K u - \\lambda^T f \\right) = u^T Q + \\lambda^T K\n$$\n将其设为零得到条件 $u^T Q + \\lambda^T K = 0$。对该方程进行转置，得到**伴随方程**的标准形式：\n$$\n(u^T Q + \\lambda^T K)^T = 0^T \\implies Q^T u + K^T \\lambda = 0\n$$\n由于 $Q$ 是对称的（$Q^T = Q$），我们有：\n$$\nK^T \\lambda = -Q u\n$$\n这是一个定义了伴随向量 $\\lambda(p)$ 的线性方程组。注意它涉及刚度矩阵的转置 $K^T$，其求解需要状态向量 $u$。\n\n通过对 $\\lambda$ 的这种特定选择，$\\mathrm{d}\\mathcal{L}/\\mathrm{d}p$ 表达式中的项 $\\frac{\\partial \\mathcal{L}}{\\partial u} \\frac{\\mathrm{d}u}{\\mathrm{d}p}$ 变为零。此外，项 $\\frac{\\partial \\mathcal{L}}{\\partial \\lambda}$ 就是 $R^T$。由于状态方程 $R=0$ 必须成立，该项也为零，因此无论 $\\mathrm{d}\\lambda/\\mathrm{d}p$ 为何值，$\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} \\frac{\\mathrm{d}\\lambda}{\\mathrm{d}p} = 0$。\n\n因此，泛函的全导数简化为：\n$$\n\\frac{\\mathrm{d}J}{\\mathrm{d}p} = \\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}p} = \\frac{\\partial \\mathcal{L}}{\\partial p}\n$$\n我们现在计算 $\\mathcal{L}$ 关于 $p$ 的偏导数：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial p} = \\frac{\\partial}{\\partial p} \\left( \\frac{1}{2} u^T Q(p) u + \\lambda^T (K(p)u - f(p)) \\right) = \\frac{1}{2} u^T \\frac{\\partial Q}{\\partial p} u + \\lambda^T \\left( \\frac{\\partial K}{\\partial p} u - \\frac{\\partial f}{\\partial p} \\right)\n$$\n这给出了最终的灵敏度表达式：\n$$\n\\frac{\\mathrm{d}J}{\\mathrm{d}p} = \\frac{1}{2} u^T \\frac{\\partial Q}{\\partial p} u + \\lambda^T \\left( \\frac{\\partial K}{\\partial p} u - \\frac{\\partial f}{\\partial p} \\right)\n$$\n\n**3) 关于消除 $\\mathrm{d}u/\\mathrm{d}p$ 的解释**\n\n梯度 $\\mathrm{d}J/\\mathrm{d}p$ 的最终表达式不需要求解状态灵敏度向量 $\\mathrm{d}u/\\mathrm{d}p$，这是因为伴随问题的特殊构造。通过引入拉格朗日乘子（伴随）向量 $\\lambda$ 并构造增广泛函 $\\mathcal{L}$，我们获得了一个额外的自由度。这个自由度被用来施加伴随方程 $K^T\\lambda = -Qu$。这个方程被专门设计成一个条件，使得 $\\mathrm{d}\\mathcal{L}/\\mathrm{d}p$ 的链式法则展开式中 $\\mathrm{d}u/\\mathrm{d}p$ 项的系数为零。通过满足这个伴随方程，全导数 $\\mathrm{d}J/\\mathrm{d}p$ 对状态灵敏度 $\\mathrm{d}u/\\mathrm{d}p$ 的依赖性在代数上被消除了，只剩下依赖于状态 $u$、伴随状态 $\\lambda$ 以及问题数据（$K$、$f$、$Q$）关于参数 $p$ 的直接偏导数的项。这构成了伴随方法在涉及大量参数的灵敏度分析中的主要优势，因为只需要求解一个状态系统和一个伴随系统，而不是为每个参数的灵敏度求解一个新的系统。",
            "answer": "$$\n\\boxed{\\frac{1}{2} u^T \\frac{\\partial Q}{\\partial p} u + \\lambda^T \\left( \\frac{\\partial K}{\\partial p} u - \\frac{\\partial f}{\\partial p} \\right)}\n$$"
        },
        {
            "introduction": "从理论走向代码，本实践探讨了计算物理学中的一个关键问题：正问题（forward problem）离散化与伴随方程形式之间的一致性。您将实现并比较不同的灵敏度分析方法，亲眼见证为何在伴随方程中忽略数值稳定项（这是离散化连续伴随方程时常犯的错误）会导致错误的结果。这个练习凸显了离散伴随法的稳健性。",
            "id": "3495786",
            "problem": "您需要为一个简化的单体流固耦合系统实现一个程序，该程序使用三种不同的途径计算并比较一个标量关注量相对于一个标量参数的灵敏度：离散伴随法、省略流线迎风Petrov-Galerkin (SUPG) 稳定项的连续伴随法，以及复步法参考解。其目标是揭示当原始（正向）离散残差中存在SUPG稳定化项，但在伴随方程中被省略时所产生的不一致性。所有变量均为无量纲。\n\n从多物理场耦合仿真和伴随法中的以下基本概念开始：\n- 空间离散并施加边界条件后，控制代数系统是一个形式为 $R(x,p)=0$ 的残差方程，其中 $x$ 是耦合的流体和结构未知量向量，$p$ 是一个标量参数。在单体Newton-Krylov求解中，会对 $R(x,p)$ 进行线性化以形成雅可比矩阵 $A=\\partial R/\\partial x$，并使用Krylov方法求解 $A \\Delta x = -R$；这里我们考虑的是线性残差，因此一步Newton迭代即可。\n- 对于一个可微的标量输出 $J(x)$，离散伴随灵敏度通过求解伴随方程 $(\\partial R/\\partial x)^{\\top} \\lambda = (\\partial J/\\partial x)^{\\top}$ 得到，然后计算 $\\mathrm{d}J/\\mathrm{d}p = -\\lambda^{\\top} (\\partial R/\\partial p)$。\n- 复步法通过对一个小的实数 $h$ 计算 $J(x(p+\\mathrm{i}h))$，并以 $\\mathrm{d}J/\\mathrm{d}p \\approx \\mathrm{Im}(J(x(p+\\mathrm{i}h)))/h$ 的方式提供一个参考灵敏度，对于解析的 $R$，该计算可以精确到机器精度。\n\n定义一个一维稳态耦合系统，该系统建立在均匀网格上，流体和结构各有 $N$ 个节点，未知量向量为 $x=[u_{0},\\dots,u_{N-1},d_{0},\\dots,d_{N-1}]^{\\top} \\in \\mathbb{R}^{2N}$，网格间距为 $h=1/(N-1)$，Dirichlet边界条件为 $u_{0}=u_{N-1}=0$ 和 $d_{0}=d_{N-1}=0$。流体的内部节点残差由下式给出：\n$$\nR^{f}_{i}(x,p) \\;=\\; -\\nu\\,\\frac{u_{i+1}-2u_{i}+u_{i-1}}{h^{2}} \\;+\\; a\\,\\frac{u_{i}-u_{i-1}}{h} \\;+\\; k_{c}\\,(u_{i}-d_{i}) \\;-\\; f_{i} \\;+\\; \\tau\\,a^{2}\\,\\frac{u_{i+1}-2u_{i}+u_{i-1}}{h^{2}},\n$$\n对于 $i=1,\\dots,N-2$，其中 $a=p$ 是对流速度，$\\nu$ 是运动粘度，$k_{c}$ 是耦合刚度，$f_{i}$ 是已知的流体强迫项，$\\tau$ 是流线迎风Petrov-Galerkin (SUPG) 稳定化参数。结构的内部节点残差为：\n$$\nR^{s}_{i}(x,p) \\;=\\; -k_{s}\\,\\frac{d_{i+1}-2d_{i}+d_{i-1}}{h^{2}} \\;+\\; k_{c}\\,(d_{i}-u_{i}) \\;-\\; g_{i},\n$$\n对于 $i=1,\\dots,N-2$，其中 $k_{s}$ 是结构刚度，$g_{i}$ 是已知的结构载荷。在Dirichlet边界节点 $i\\in\\{0,N-1\\}$ 处，施加 $R^{f}_{i}(x,p)=u_{i}-0$ 和 $R^{s}_{i}(x,p)=d_{i}-0$。将这些方程组装成一个单体残差 $R(x,p)=A(p,\\tau)\\,x-b$，其中 $b$ 由强迫项向量构成。\n\n将标量关注量定义为流体变量的离散空间平均值，\n$$\nJ(x) \\;=\\; \\frac{1}{N}\\sum_{i=0}^{N-1} u_{i}.\n$$\n\n实现三种灵敏度计算：\n- 复步法参考灵敏度 $\\mathrm{d}J/\\mathrm{d}p$，通过对一个小的实数步长 $h$ 求解参数为 $p \\leftarrow p+\\mathrm{i}h$ 的原始系统，并计算 $\\mathrm{Im}(J)/h$ 得到。\n- 离散伴随灵敏度 $\\mathrm{d}J/\\mathrm{d}p$，使用包含SUPG稳定化贡献的精确雅可比矩阵 $A(p,\\tau)$ 和精确的偏参数导数 $(\\partial R/\\partial p)(x,p) = (\\partial A/\\partial p)(p,\\tau)\\,x$，其中 $(\\partial A/\\partial p)$ 同时包含对流导数和与 $\\tau\\,2a$ 成比例的稳定化导数。\n- 类似连续伴随的灵敏度，其在伴随计算中省略SUPG项，通过构造 $A_{0}(p)=A(p,\\tau=0)$，求解 $A_{0}(p)^{\\top}\\lambda_{c}=(\\partial J/\\partial x)^{\\top}$，并计算 $\\mathrm{d}J/\\mathrm{d}p \\approx -\\lambda_{c}^{\\top} \\left((\\partial A_{0}/\\partial p)(p)\\,x\\right)$，即伴随算子和 $(\\partial R/\\partial p)$ 均排除了稳定化项。\n\n您的程序必须：\n- 使用 $N=10$，$\\nu=0.01$，$k_{c}=5.0$，$k_{s}=10.0$，所有内部流体节点的 $f_{i}=1.0$，所有内部结构节点的 $g_{i}=0.0$，以及如上所述的齐次Dirichlet边界数据。\n- 将所有量视为无量纲；输出中无需物理单位。\n- 实现以下参数对 $(p,\\tau)$ 的测试套件：\n    1. $(p,\\tau)=(1.0,0.0)$，\n    2. $(p,\\tau)=(1.0,0.2)$，\n    3. $(p,\\tau)=(0.0,1.0)$，\n    4. $(p,\\tau)=(-0.7,0.5)$，\n    5. $(p,\\tau)=(2.0,1.0)$。\n- 对于每个测试用例，计算相对于复步法灵敏度的两个绝对误差：离散伴随灵敏度的绝对误差和类似连续伴随的灵敏度的绝对误差。使用复步步长 $h=10^{-30}$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，该列表由10个浮点数组成，这些浮点数对应于离散伴随法和类似连续伴随法的绝对误差，并按测试用例的顺序排列。例如，输出格式必须与 $[e_{d,1},e_{c,1},e_{d,2},e_{c,2},e_{d,3},e_{c,3},e_{d,4},e_{c,4},e_{d,5},e_{c,5}]$ 完全一样，其中 $e_{d,i}$ 表示测试 $i$ 中离散伴随法的绝对误差，$e_{c,i}$ 表示测试 $i$ 中类似连续伴随法的绝对误差。",
            "solution": "该问题要求实现并比较三种应用于简化的、一维、单体流固耦合系统的灵敏度分析方法。问题的核心是展示当数值稳定化项（SUPG）包含在正向（原始）模型中，但在伴随灵敏度计算中被省略时所产生的不一致性。这三种方法是：复步法（用于提供参考解）、离散伴随法（一致的方法），以及一种故意省略稳定化项的“类似连续伴随”的方法。\n\n首先，我们将代数系统形式化。离散化的控制方程构成一个线性系统 $R(x, p) = A(p, \\tau)x - b = 0$，其中 $x \\in \\mathbb{R}^{2N}$ 是由流体速度 $u_i$ 和结构位移 $d_i$ 组成的状态向量，$p$ 是我们关注的标量参数，即对流速度 $a$。状态向量的排序为 $x = [u_0, \\dots, u_{N-1}, d_0, \\dots, d_{N-1}]^{\\top}$。该问题通过计算状态 $x = A(p, \\tau)^{-1}b$ 来求解。\n\n系统矩阵 $A(p, \\tau)$ 和强迫项向量 $b$ 是根据所提供的残差方程组装的。对于一个有 $N$ 个节点且网格间距为 $h=1/(N-1)$ 的网格，矩阵 $A \\in \\mathbb{R}^{2N \\times 2N}$ 和向量 $b \\in \\mathbb{R}^{2N}$ 对于内部节点（$i=1, \\dots, N-2$）有以下非零项：\n\n对于流体残差 $R_i^f$，系统对应的第 $i$ 行为：\n$$\n\\left(\\frac{2(\\nu - \\tau p^2)}{h^2} + \\frac{p}{h} + k_c\\right)u_i + \\left(\\frac{-(\\nu - \\tau p^2)}{h^2} - \\frac{p}{h}\\right)u_{i-1} + \\left(\\frac{-(\\nu - \\tau p^2)}{h^2}\\right)u_{i+1} - k_c d_i = f_i\n$$\n对于结构残差 $R_i^s$，系统对应的第 $N+i$ 行为：\n$$\n\\left(\\frac{2k_s}{h^2} + k_c\\right)d_i + \\left(\\frac{-k_s}{h^2}\\right)d_{i-1} + \\left(\\frac{-k_s}{h^2}\\right)d_{i+1} - k_c u_i = g_i\n$$\n通过将 $A$ 的第 $0, N-1, N, 2N-1$ 行设置为主对角元为1的单位行，并将 $b$ 中对应的项设置为0，来强制施加边界条件 $u_0=u_{N-1}=0$ 和 $d_0=d_{N-1}=0$。\n\n关注量为 $J(x) = \\frac{1}{N}\\sum_{i=0}^{N-1} u_i$。这是 $x$ 的一个线性函数。它关于 $x$ 的梯度是一个常数向量 $\\frac{\\partial J}{\\partial x}$，其元素为：\n$$\n\\left(\\frac{\\partial J}{\\partial x}\\right)_j = \\begin{cases} 1/N  & \\text{for } 0 \\le j < N \\\\ 0  & \\text{for } N \\le j < 2N \\end{cases}\n$$\n\n$J$ 相对于 $p$ 的全导数由伴随公式给出：$\\frac{\\mathrm{d}J}{\\mathrm{d}p} = -\\lambda^{\\top}\\frac{\\partial R}{\\partial p}$。这里，$\\frac{\\partial R}{\\partial p} = \\frac{\\partial}{\\partial p}(A(p,\\tau)x-b) = \\frac{\\partial A}{\\partial p}x$，因为 $b$ 与 $p$ 无关。伴随向量 $\\lambda$ 是线性系统 $(\\frac{\\partial R}{\\partial x})^{\\top}\\lambda = (\\frac{\\partial J}{\\partial x})^{\\top}$ 的解，即 $A(p,\\tau)^{\\top}\\lambda = (\\frac{\\partial J}{\\partial x})^{\\top}$。\n\n矩阵 $\\frac{\\partial A}{\\partial p}$ 是通过将 $A$ 的系数对 $p$求导得出的。唯一的非零项来自于第 $i=1, \\dots, N-2$ 行中的流体对流项和SUPG项：\n$$\n\\frac{\\partial A_{i,i-1}}{\\partial p} = \\frac{2\\tau p}{h^2} - \\frac{1}{h}, \\quad \\frac{\\partial A_{i,i}}{\\partial p} = \\frac{-4\\tau p}{h^2} + \\frac{1}{h}, \\quad \\frac{\\partial A_{i,i+1}}{\\partial p} = \\frac{2\\tau p}{h^2}\n$$\n\n我们现在概述这三种计算过程。\n\n1.  **复步法参考灵敏度**：该方法提供一个高精度的参考值。参数 $p$ 被一个小的虚数步长扰动，$p_{cs} = p + \\mathrm{i}h_{cs}$。求解系统 $A(p_{cs}, \\tau)x_{cs} = b$ 得到复数状态向量 $x_{cs}$。计算关注量 $J_{cs} = J(x_{cs})$。根据Cauchy-Riemann方程，灵敏度可以精确到机器精度，由 $\\frac{\\mathrm{d}J}{\\mathrm{d}p} \\approx \\frac{\\mathrm{Im}(J_{cs})}{h_{cs}}$ 给出。\n\n2.  **离散伴随灵敏度**：这是一种理论上一致的伴随方法。\n    a. 求解实值原始系统 $A(p, \\tau)x = b$ 得到状态 $x$。\n    b. 求解离散伴随系统 $A(p, \\tau)^{\\top}\\lambda = (\\frac{\\partial J}{\\partial x})^{\\top}$ 得到伴随向量 $\\lambda$。该矩阵是原始系统雅可比矩阵的精确转置。\n    c. 计算偏导数项 $\\frac{\\partial R}{\\partial p} = \\frac{\\partial A(p, \\tau)}{\\partial p}x$。\n    d. 灵敏度为 $\\frac{\\mathrm{d}J}{\\mathrm{d}p} = -\\lambda^{\\top} \\frac{\\partial R}{\\partial p}$。\n    对于解析残差，此结果必须与复步法的结果在机器精度上匹配。\n\n3.  **类似连续伴随的灵敏度**：该方法通过在伴随计算中省略所有与SUPG相关的项，故意引入了不一致性。\n    a. 原始状态 $x$ 与离散伴随法中的相同，即完整系统 $A(p, \\tau)x = b$ 的解。\n    b. 定义一个不一致的伴随算子 $A_0(p) = A(p, \\tau=0)$。求解不一致的伴随系统 $A_0(p)^{\\top}\\lambda_c = (\\frac{\\partial J}{\\partial x})^{\\top}$ 得到 $\\lambda_c$。\n    c. 计算一个不一致的偏导数项 $\\left(\\frac{\\partial R}{\\partial p}\\right)_c = \\frac{\\partial A_0(p)}{\\partial p}x$。\n    d. 不一致的灵敏度通过 $\\frac{\\mathrm{d}J}{\\mathrm{d}p} \\approx -\\lambda_c^{\\top} \\left(\\frac{\\partial R}{\\partial p}\\right)_c$ 进行评估。\n\n当 $\\tau \\neq 0$ 时，不一致性源于伴随算子 $A_0(p)^{\\top}$ 并非前向算子 $A(p, \\tau)$ 的真正转置。这模拟了从缺少稳定化项的偏微分方程推导连续伴随方程，然后将其应用于通过稳定化数值格式获得的主问题解时所犯的错误。编程实现将针对几组 $(p, \\tau)$ 参数对，计算方法2和方法3相对于复步法参考解的绝对误差。预计结果将显示，在所有情况下，离散伴随误差都接近于零，而只要SUPG项被激活（即 $\\tau \\neq 0$ 且 $p \\neq 0$），“类似连续伴随”的误差就会很显著。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_system(p, tau, N, h, nu, kc, ks, f_val):\n    \"\"\"\n    Assembles the monolithic system matrix A and forcing vector b.\n    Handles both real and complex-valued parameters p.\n    \"\"\"\n    dtype = np.complex128 if np.iscomplexobj(p) else np.float64\n    A = np.zeros((2 * N, 2 * N), dtype=dtype)\n    b = np.zeros(2 * N, dtype=dtype)\n    h2 = h * h\n    a = p\n\n    # Boundary conditions\n    A[0, 0] = 1.0\n    A[N - 1, N - 1] = 1.0\n    A[N, N] = 1.0\n    A[2 * N - 1, 2 * N - 1] = 1.0\n    # Forcing b for boundaries is 0, which is the default.\n\n    # Interior nodes\n    for i in range(1, N - 1):\n        # Fluid residual R^f_i = 0 in row i\n        eff_nu = nu - tau * a**2\n        A[i, i - 1] = -eff_nu / h2 - a / h\n        A[i, i]     = 2 * eff_nu / h2 + a / h + kc\n        A[i, i + 1] = -eff_nu / h2\n        A[i, N + i] = -kc\n        b[i] = f_val\n\n        # Structure residual R^s_i = 0 in row N + i\n        A[N + i, i]         = -kc\n        A[N + i, N + i - 1] = -ks / h2\n        A[N + i, N + i]     = 2 * ks / h2 + kc\n        A[N + i, N + i + 1] = -ks / h2\n        # Forcing g_i is 0.0, which is the default for b.\n    \n    return A, b\n\ndef assemble_dA_dp(p, tau, N, h):\n    \"\"\"\n    Assembles the derivative of the system matrix A with respect to the parameter p.\n    \"\"\"\n    dtype = np.float64\n    dA_dp = np.zeros((2 * N, 2 * N), dtype=dtype)\n    h2 = h * h\n    a = p\n\n    # Only fluid interior equations depend on p.\n    for i in range(1, N - 1):\n        dA_dp[i, i - 1] = 2 * tau * a / h2 - 1 / h\n        dA_dp[i, i]     = -4 * tau * a / h2 + 1 / h\n        dA_dp[i, i + 1] = 2 * tau * a / h2\n    \n    return dA_dp\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 0.0),\n        (1.0, 0.2),\n        (0.0, 1.0),\n        (-0.7, 0.5),\n        (2.0, 1.0),\n    ]\n\n    # Define constants\n    N = 10\n    nu = 0.01\n    kc = 5.0\n    ks = 10.0\n    f_val = 1.0\n    h_cs = 1e-30  # Complex-step size\n    \n    h = 1.0 / (N - 1)\n\n    # Gradient of the Quantity of Interest J\n    dJ_dx = np.zeros(2 * N)\n    dJ_dx[:N] = 1.0 / N\n    \n    results = []\n    for p_real, tau in test_cases:\n        p = p_real\n\n        # 1. Complex-Step Reference Sensitivity\n        p_cs = p + 1j * h_cs\n        A_cs, b_cs = assemble_system(p_cs, tau, N, h, nu, kc, ks, f_val)\n        x_cs = np.linalg.solve(A_cs, b_cs.astype(np.complex128))\n        J_cs = (1.0 / N) * np.sum(x_cs[:N])\n        sens_ref = J_cs.imag / h_cs\n\n        # --- Primal solve for adjoint methods ---\n        A, b = assemble_system(p, tau, N, h, nu, kc, ks, f_val)\n        x = np.linalg.solve(A, b)\n\n        # 2. Discrete Adjoint Sensitivity\n        dA_dp = assemble_dA_dp(p, tau, N, h)\n        dR_dp = dA_dp @ x\n        adjoint_vec = np.linalg.solve(A.T, dJ_dx)\n        sens_da = -adjoint_vec.T @ dR_dp\n        \n        # 3. \"Continuous-Adjoint-Like\" Sensitivity (inconsistent)\n        A0, _ = assemble_system(p, 0.0, N, h, nu, kc, ks, f_val)\n        dA0_dp = assemble_dA_dp(p, 0.0, N, h)\n        dR0_dp = dA0_dp @ x\n        adjoint_vec_c = np.linalg.solve(A0.T, dJ_dx)\n        sens_ca = -adjoint_vec_c.T @ dR0_dp\n        \n        # 4. Compute and store absolute errors\n        err_da = abs(sens_da - sens_ref)\n        err_ca = abs(sens_ca - sens_ref)\n        \n        results.append(err_da)\n        results.append(err_ca)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "伴随法如何扩展到在并行计算机上求解的大规模实际问题？这项高级实践通过将伴随方法应用于一个使用区域分解法（domain decomposition method）求解的系统来探索答案。您将推导并实现一个在子域间界面上运行的可扩展伴随求解器，展示伴随框架如何与高性能计算技术优雅地集成。",
            "id": "3495730",
            "problem": "考虑一个使用有限元撕裂与连接 (FETI) 或约束平衡区域分解 (BDDC) 方法，通过单个界面连续性约束耦合的线性双子域多物理场离散。设子域未知量为 $u_1 \\in \\mathbb{R}^{n_1}$ 和 $u_2 \\in \\mathbb{R}^{n_2}$，其对称正定刚度矩阵分别为 $A_1(\\theta_1) \\in \\mathbb{R}^{n_1 \\times n_1}$ 和 $A_2(\\theta_2) \\in \\mathbb{R}^{n_2 \\times n_2}$，其中参数 $\\theta_1$ 和 $\\theta_2$ 调节子域的材料属性。设 $B_1 \\in \\mathbb{R}^{m \\times n_1}$ 和 $B_2 \\in \\mathbb{R}^{m \\times n_2}$ 为界面迹算子，通过拉格朗日乘子 $\\lambda \\in \\mathbb{R}^{m}$ 强制实现连续性。耦合平衡条件为鞍点系统\n$$\n\\begin{bmatrix}\nA_1(\\theta_1)  0  B_1^{\\top} \\\\\n0  A_2(\\theta_2)  -B_2^{\\top} \\\\\nB_1  -B_2  0\n\\end{bmatrix}\n\\begin{bmatrix}\nu_1 \\\\ u_2 \\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf_1 \\\\ f_2 \\\\ 0\n\\end{bmatrix},\n$$\n其中 $m = 1$，$B_1$ 选取子域 1 的最后一个自由度，$B_2$ 选取子域 2 的第一个自由度。假设目标函数为\n$$\nJ(u_1,u_2) = \\tfrac{1}{2}\\, u_1^{\\top} W_1 u_1 + \\tfrac{1}{2}\\, u_2^{\\top} W_2 u_2,\n$$\n其中 $W_1 \\in \\mathbb{R}^{n_1 \\times n_1}$ 和 $W_2 \\in \\mathbb{R}^{n_2 \\times n_2}$ 是对称半正定权重矩阵，载荷 $f_1 \\in \\mathbb{R}^{n_1}$ 和 $f_2 \\in \\mathbb{R}^{n_2}$ 不依赖于 $\\theta_1$ 或 $\\theta_2$。假设 $A_1(\\theta_1) = K_{1,0} + \\theta_1 K_{1,1}$ 和 $A_2(\\theta_2) = K_{2,0} + \\theta_2 K_{2,1}$，其中给定的 $K_{1,1}, K_{2,1}$ 是对称半正定的，$K_{1,0}, K_{2,0}$ 是对称正定的；对于下文的每个测试用例，所选参数都使得 $A_1(\\theta_1)$ 和 $A_2(\\theta_2)$ 是对称正定的。\n\n您的任务是：\n\n1) 仅从约束平衡问题的拉格朗日量的平稳性以及线性系统的连续伴随方法的定义出发，推导界面上的子结构化伴随方程，该方程消除了子域伴随未知量。具体来说，推导一个关于界面伴随未知量 $q \\in \\mathbb{R}^{m}$ 的方程，其形式为\n$$\nS(\\theta_1,\\theta_2)\\, q = r_{\\mathrm{adj}}(\\theta_1,\\theta_2),\n$$\n其中 $S(\\theta_1,\\theta_2)$ 是一个可用 $A_1(\\theta_1)^{-1}$、$A_2(\\theta_2)^{-1}$、$B_1$ 和 $B_2$ 表示的界面算子，而 $r_{\\mathrm{adj}}(\\theta_1,\\theta_2)$ 依赖于 $W_1 u_1$ 和 $W_2 u_2$。然后用 $q$、$A_1(\\theta_1)$、$A_2(\\theta_2)$、$W_1 u_1$ 和 $W_2 u_2$ 表示子域伴随变量 $p_1 \\in \\mathbb{R}^{n_1}$ 和 $p_2 \\in \\mathbb{R}^{n_2}$。\n\n2) 使用针对线性残差 $R(x,\\theta) = K(\\theta) x - f$ 和目标函数 $J(x) = \\tfrac{1}{2} x^{\\top} W x$（其中 $x = (u_1,u_2,\\lambda)$ 且 $W$ 仅作用于 $u_1$ 和 $u_2$ 分量）的伴随方法定义，推导一个计算梯度 $\\nabla_{\\theta} J = \\left[\\tfrac{\\partial J}{\\partial \\theta_1}, \\tfrac{\\partial J}{\\partial \\theta_2}\\right]$ 的公式，该公式仅使用子域量、对 $A_1(\\theta_1)$ 和 $A_2(\\theta_2)$ 的局部求解、界面伴随变量 $q$ 以及参数导数矩阵 $K_{1,1}$ 和 $K_{2,1}$。该公式必须避免构造或求解任何全局伴随矩阵。\n\n3) 提出一种可扩展的并行算法，在给定 $\\theta_1$ 和 $\\theta_2$ 的情况下，仅使用以下方式计算 $\\nabla_{\\theta} J$：\n- 对 $A_1(\\theta_1)$ 和 $A_2(\\theta_2)$ 的独立子域求解，\n- 在界面上使用一种利用界面算子的无矩阵应用的克雷洛夫方法，\n- 以及局部向量-矩阵运算。\n您的算法不得组装除 $A_1(\\theta_1)$、$A_2(\\theta_2)$、$B_1$ 和 $B_2$ 之外的任何全局矩阵。\n\n4) 将您的算法实现为一个完整、可运行的程序。对于下述测试套件中的每个测试用例，该程序需组装 $A_1(\\theta_1)$ 和 $A_2(\\theta_2)$，仅使用子域求解和界面上的无矩阵克雷洛夫方法求解原问题状态 $(u_1,u_2,\\lambda)$，仅使用子域求解和无矩阵界面伴随方法求解伴随问题，并返回四舍五入到六位小数的梯度 $\\nabla_{\\theta} J$。您的实现必须严格遵循仅使用界面的方法：不要组装或求逆任何大小为 $(n_1+n_2+m) \\times (n_1+n_2+m)$ 的全局矩阵。\n\n使用以下测试套件（所有数值均为无量纲，无需物理单位）：\n\n- 测试用例 1 (理想情况):\n  - $n_1 = 2$, $n_2 = 2$, $m = 1$, $B_1 = [0\\ \\ 1]$, $B_2 = [1\\ \\ 0]$.\n  - $K_{1,0} = \\begin{bmatrix} 4  -1 \\\\ -1  3 \\end{bmatrix}$, $K_{1,1} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$, $\\theta_1 = 0.3$.\n  - $K_{2,0} = \\begin{bmatrix} 5  -2 \\\\ -2  4 \\end{bmatrix}$, $K_{2,1} = \\begin{bmatrix} 2  0 \\\\ 0  0.5 \\end{bmatrix}$, $\\theta_2 = 1.2$.\n  - $f_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$, $f_2 = \\begin{bmatrix} 0 \\\\ 2 \\end{bmatrix}$.\n  - $W_1 = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$, $W_2 = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$.\n\n- 测试用例 2 (参数边界):\n  - $n_1 = 2$, $n_2 = 2$, $m = 1$, $B_1 = [0\\ \\ 1]$, $B_2 = [1\\ \\ 0]$.\n  - $K_{1,0} = \\begin{bmatrix} 4  -1 \\\\ -1  3 \\end{bmatrix}$, $K_{1,1} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$, $\\theta_1 = 0$.\n  - $K_{2,0} = \\begin{bmatrix} 5  -2 \\\\ -2  4 \\end{bmatrix}$, $K_{2,1} = \\begin{bmatrix} 2  0 \\\\ 0  0.5 \\end{bmatrix}$, $\\theta_2 = 0$.\n  - $f_1 = \\begin{bmatrix} 0.2 \\\\ -0.1 \\end{bmatrix}$, $f_2 = \\begin{bmatrix} -0.3 \\\\ 0.4 \\end{bmatrix}$.\n  - $W_1 = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$, $W_2 = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$.\n\n- 测试用例 3 (各向异性目标权重):\n  - $n_1 = 2$, $n_2 = 2$, $m = 1$, $B_1 = [0\\ \\ 1]$, $B_2 = [1\\ \\ 0]$.\n  - $K_{1,0} = \\begin{bmatrix} 4  -1 \\\\ -1  3 \\end{bmatrix}$, $K_{1,1} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$, $\\theta_1 = 1$.\n  - $K_{2,0} = \\begin{bmatrix} 5  -2 \\\\ -2  4 \\end{bmatrix}$, $K_{2,1} = \\begin{bmatrix} 2  0 \\\\ 0  0.5 \\end{bmatrix}$, $\\theta_2 = 0.5$.\n  - $f_1 = \\begin{bmatrix} 0.5 \\\\ -0.5 \\end{bmatrix}$, $f_2 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}$.\n  - $W_1 = \\begin{bmatrix} 2  0 \\\\ 0  0.5 \\end{bmatrix}$, $W_2 = \\begin{bmatrix} 1  0 \\\\ 0  3 \\end{bmatrix}$.\n\n- 测试用例 4 (零载荷边界情况):\n  - $n_1 = 2$, $n_2 = 2$, $m = 1$, $B_1 = [0\\ \\ 1]$, $B_2 = [1\\ \\ 0]$.\n  - $K_{1,0} = \\begin{bmatrix} 4  -1 \\\\ -1  3 \\end{bmatrix}$, $K_{1,1} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$, $\\theta_1 = 0.5$.\n  - $K_{2,0} = \\begin{bmatrix} 5  -2 \\\\ -2  4 \\end{bmatrix}$, $K_{2,1} = \\begin{bmatrix} 2  0 \\\\ 0  0.5 \\end{bmatrix}$, $\\theta_2 = 0.8$.\n  - $f_1 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$, $f_2 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n  - $W_1 = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$, $W_2 = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$.\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个结果是对应测试用例的双分量列表 $[\\tfrac{\\partial J}{\\partial \\theta_1},\\tfrac{\\partial J}{\\partial \\theta_2}]$，四舍五入到六位小数，例如 $[[a_1,a_2],[b_1,b_2],\\ldots]$。",
            "solution": "该问题是有效的，因为它在计算力学和数值线性代数方面具有科学依据，是适定的、客观且自洽的。所提供的方程描述了一个源于带界面耦合的有限元离散化的标准鞍点系统，其任务涉及使用伴随方法进行灵敏度分析的标准应用。提供了数值实现所需的所有数据和条件。\n\n### 第 1 部分：子结构化伴随方程的推导\n\n耦合平衡条件由线性系统 $K(\\theta)x = F$ 给出，其中：\n$$\nK(\\theta) = \\begin{bmatrix}\nA_1(\\theta_1)  0  B_1^{\\top} \\\\\n0  A_2(\\theta_2)  -B_2^{\\top} \\\\\nB_1  -B_2  0\n\\end{bmatrix}, \\quad\nx = \\begin{bmatrix}\nu_1 \\\\ u_2 \\\\ \\lambda\n\\end{bmatrix}, \\quad\nF = \\begin{bmatrix}\nf_1 \\\\ f_2 \\\\ 0\n\\end{bmatrix}\n$$\n目标函数为 $J(x) = \\frac{1}{2}x^{\\top}Wx$，其中 $W = \\mathrm{diag}(W_1, W_2, 0)$。此约束优化问题的拉格朗日量为 $\\mathcal{L}(x, p, \\theta) = J(x) + p^{\\top}(K(\\theta)x - F)$，其中 $p = [p_1^{\\top}, p_2^{\\top}, q^{\\top}]^{\\top}$ 是伴随变量向量。\n\n连续伴随方法通过将拉格朗日量对状态变量 $x$ 的梯度置零来定义伴随方程：$\\nabla_x \\mathcal{L} = 0$。\n$$\n\\nabla_x J(x) + K(\\theta)^{\\top}p = 0\n$$\n给定 $J(x) = \\frac{1}{2}x^{\\top}Wx$，其梯度为 $\\nabla_x J(x) = Wx$。\n系统矩阵 $K(\\theta)$ 的转置是：\n$$\nK(\\theta)^{\\top} = \\begin{bmatrix}\nA_1(\\theta_1)^{\\top}  0  B_1^{\\top} \\\\\n0  A_2(\\theta_2)^{\\top}  (-B_2)^{\\top} \\\\\n(B_1^{\\top})^{\\top}  (-B_2^{\\top})^{\\top}  0^{\\top}\n\\end{bmatrix} = \\begin{bmatrix}\nA_1(\\theta_1)  0  B_1^{\\top} \\\\\n0  A_2(\\theta_2)  -B_2^{\\top} \\\\\nB_1  -B_2  0\n\\end{bmatrix} = K(\\theta)\n$$\n因为 $A_1$ 和 $A_2$ 是对称的。因此，伴随系统为 $K(\\theta)p = -Wx$：\n$$\n\\begin{bmatrix}\nA_1(\\theta_1)  0  B_1^{\\top} \\\\\n0  A_2(\\theta_2)  -B_2^{\\top} \\\\\nB_1  -B_2  0\n\\end{bmatrix}\n\\begin{bmatrix}\np_1 \\\\ p_2 \\\\ q\n\\end{bmatrix}\n=\n- \\begin{bmatrix}\nW_1  0  0 \\\\\n0  W_2  0 \\\\\n0  0  0\n\\end{bmatrix}\n\\begin{bmatrix}\nu_1 \\\\ u_2 \\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-W_1 u_1 \\\\ -W_2 u_2 \\\\ 0\n\\end{bmatrix}\n$$\n这产生了三个分块方程：\n$1. \\quad A_1(\\theta_1) p_1 + B_1^{\\top} q = -W_1 u_1$\n$2. \\quad A_2(\\theta_2) p_2 - B_2^{\\top} q = -W_2 u_2$\n$3. \\quad B_1 p_1 - B_2 p_2 = 0$\n\n为找到界面伴随未知量 $q$ 的方程，我们消去子域伴随变量 $p_1$ 和 $p_2$。从方程 (1) 和 (2)，我们通过对 (SPD) 矩阵 $A_1$ 和 $A_2$ 求逆来表示 $p_1$ 和 $p_2$：\n$$\np_1 = A_1(\\theta_1)^{-1} (-W_1 u_1 - B_1^{\\top} q) = -A_1(\\theta_1)^{-1}(W_1 u_1 + B_1^{\\top} q)\n$$\n$$\np_2 = A_2(\\theta_2)^{-1} (-W_2 u_2 + B_2^{\\top} q) = -A_2(\\theta_2)^{-1}(W_2 u_2 - B_2^{\\top} q)\n$$\n这些表达式按要求给出了子域伴随变量。将它们代入耦合方程 (3)：\n$$\nB_1 \\left(-A_1(\\theta_1)^{-1}(W_1 u_1 + B_1^{\\top} q)\\right) - B_2 \\left(-A_2(\\theta_2)^{-1}(W_2 u_2 - B_2^{\\top} q)\\right) = 0\n$$\n整理各项以分离出 $q$：\n$$\n-B_1 A_1(\\theta_1)^{-1} B_1^{\\top} q - B_2 A_2(\\theta_2)^{-1} B_2^{\\top} q = B_1 A_1(\\theta_1)^{-1} W_1 u_1 - B_2 A_2(\\theta_2)^{-1} W_2 u_2\n$$\n$$\n(B_1 A_1(\\theta_1)^{-1} B_1^{\\top} + B_2 A_2(\\theta_2)^{-1} B_2^{\\top}) q = -( B_1 A_1(\\theta_1)^{-1} W_1 u_1 - B_2 A_2(\\theta_2)^{-1} W_2 u_2 )\n$$\n这就是所求的方程 $S(\\theta_1, \\theta_2) q = r_{\\mathrm{adj}}(\\theta_1, \\theta_2)$，其中界面舒尔补算子为 $S(\\theta_1, \\theta_2) = B_1 A_1(\\theta_1)^{-1} B_1^{\\top} + B_2 A_2(\\theta_2)^{-1} B_2^{\\top}$，伴随界面右端项为 $r_{\\mathrm{adj}}(\\theta_1, \\theta_2) = -(B_1 A_1(\\theta_1)^{-1} W_1 u_1 - B_2 A_2(\\theta_2)^{-1} W_2 u_2)$。\n\n### 第 2 部分：梯度公式的推导\n\n目标函数 $J$ 关于参数 $\\theta_k$ 的灵敏度由全导数 $\\frac{dJ}{d\\theta_k}$ 给出。使用拉格朗日量，并考虑到平稳性条件 $\\nabla_x \\mathcal{L} = 0$ (伴随) 和 $\\nabla_p \\mathcal{L} = 0$ (原) 已被满足，灵敏度即为拉格朗日量对参数的偏导数：\n$$\n\\frac{dJ}{d\\theta_k} = \\frac{\\partial \\mathcal{L}}{\\partial \\theta_k} = \\frac{\\partial}{\\partial \\theta_k} \\left(J(x) + p^{\\top}(K(\\theta)x - F)\\right)\n$$\n由于 $J$、$x$、$p$ 和 $F$ 并不显式依赖于 $\\theta_k$ (它们的依赖关系通过状态方程是隐式的)，这可以简化为：\n$$\n\\frac{dJ}{d\\theta_k} = p^{\\top} \\frac{\\partial K(\\theta)}{\\partial \\theta_k} x\n$$\n对于我们的特定参数 $\\theta_1$ 和 $\\theta_2$：\n$K(\\theta)$ 对 $\\theta_1$ 的导数是：\n$$\n\\frac{\\partial K}{\\partial \\theta_1} = \\begin{bmatrix}\n\\frac{\\partial A_1}{\\partial \\theta_1}  0  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{bmatrix} = \\begin{bmatrix}\nK_{1,1}  0  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{bmatrix}\n$$\n对 $\\theta_1$ 的灵敏度是：\n$$\n\\frac{\\partial J}{\\partial \\theta_1} = [p_1^{\\top}, p_2^{\\top}, q^{\\top}] \\begin{bmatrix}\nK_{1,1}  0  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{bmatrix} \\begin{bmatrix}\nu_1 \\\\ u_2 \\\\ \\lambda\n\\end{bmatrix} = p_1^{\\top} K_{1,1} u_1\n$$\n类似地，对于 $\\theta_2$：\n$$\n\\frac{\\partial K}{\\partial \\theta_2} = \\begin{bmatrix}\n0  0  0 \\\\\n0  K_{2,1}  0 \\\\\n0  0  0\n\\end{bmatrix} \\implies \\frac{\\partial J}{\\partial \\theta_2} = p_2^{\\top} K_{2,1} u_2\n$$\n为了在不显式构造 $p_1$ 和 $p_2$ 的情况下表示这些梯度，我们代入第 1 部分中它们的定义：\n$$\n\\frac{\\partial J}{\\partial \\theta_1} = \\left(-A_1(\\theta_1)^{-1}(W_1 u_1 + B_1^{\\top} q)\\right)^{\\top} K_{1,1} u_1 = -(W_1 u_1 + B_1^{\\top} q)^{\\top} (A_1(\\theta_1)^{-1})^{\\top} K_{1,1} u_1\n$$\n由于 $A_1$ 是对称的，$A_1^{-1}$ 也是对称的。最终公式为：\n$$\n\\frac{\\partial J}{\\partial \\theta_1} = -(W_1 u_1 + B_1^{\\top} q)^{\\top} \\left( A_1(\\theta_1)^{-1} K_{1,1} u_1 \\right)\n$$\n对于 $\\theta_2$ 也类似：\n$$\n\\frac{\\partial J}{\\partial \\theta_2} = -(W_2 u_2 - B_2^{\\top} q)^{\\top} \\left( A_2(\\theta_2)^{-1} K_{2,1} u_2 \\right)\n$$\n这些公式仅依赖于子域量 ($u_i, q$)、参数导数 ($K_{i,1}$) 和局部子域求解 (例如，通过求解 $A_1 z = v$ 来计算 $A_1^{-1}v$)。\n\n### 第 3 部分：可扩展的并行算法\n\n一个计算 $\\nabla_{\\theta} J$ 的可扩展算法可以分为三个阶段，假设在一个至少有两个进程（每个子域一个）的并行环境中。\n\n**阶段 1：原问题求解**\n1.  **局部组装 (并行)：**\n    - 进程 1：组装 $A_1(\\theta_1) = K_{1,0} + \\theta_1 K_{1,1}$。\n    - 进程 2：组装 $A_2(\\theta_2) = K_{2,0} + \\theta_2 K_{2,1}$。\n2.  **界面求解 $\\lambda$：**\n    - 原问题界面系统为 $S\\lambda = d$，其中 $S = B_1 A_1^{-1} B_1^{\\top} + B_2 A_2^{-1} B_2^{\\top}$ 且 $d = B_1 A_1^{-1} f_1 - B_2 A_2^{-1} f_2$。\n    - 该系统使用像共轭梯度 (CG) 这样的克雷洛夫方法求解，由于 $S$ 是对称正定的，这很合适。\n    - **右端项 $d$ 计算：** 进程 1 通过局部求解计算 $d_1 = B_1 (A_1^{-1}f_1)$。进程 2 通过局部求解计算 $d_2 = -B_2 (A_2^{-1}f_2)$。计算 $d = d_1 + d_2$ 需要通信。\n    - **CG 的矩阵向量积：** $S$ 对向量 $v$ 的作用，$S v$，是以无矩阵方式计算的。进程 1 计算 $B_1(A_1^{-1}(B_1^\\top v))$，进程 2 计算 $B_2(A_2^{-1}(B_2^\\top v))$。结果通过通信相加。\n    - CG 迭代进行直到收敛以找到 $\\lambda$。\n3.  **局部状态恢复 (并行)：**\n    - 进程 1：求解 $A_1 u_1 = f_1 - B_1^{\\top} \\lambda$ 以找到 $u_1$。\n    - 进程 2：求解 $A_2 u_2 = f_2 + B_2^{\\top} \\lambda$ 以找到 $u_2$。\n\n**阶段 2：伴随问题求解**\n1.  **界面求解 $q$：**\n    - 伴随界面系统为 $S q = r_{\\mathrm{adj}}$。刚度算子 $S$ 与原问题中的相同。任何对 $A_i$ 的分解或预条件子都可以重用。\n    - **右端项 $r_{\\mathrm{adj}}$ 计算：** 进程 1 计算 $r_1 = -B_1(A_1^{-1}(W_1 u_1))$。进程 2 计算 $r_2 = B_2(A_2^{-1}(W_2 u_2))$。计算 $r_{\\mathrm{adj}} = r_1+r_2$ 需要通信。\n    - 使用与阶段 1 中相同的 CG 求解器设置，求解界面伴随变量 $q$。\n\n**阶段 3：梯度计算**\n1.  **局部梯度评估 (并行)：**\n    - **进程 1 (对于 $\\theta_1$):**\n        a. 计算 $g_1 = W_1 u_1 + B_1^{\\top} q$。\n        b. 通过局部求解计算 $z_1 = A_1^{-1} (K_{1,1} u_1)$。\n        c. 计算 $\\frac{\\partial J}{\\partial \\theta_1} = -g_1^{\\top} z_1$。\n    - **进程 2 (对于 $\\theta_2$):**\n        a. 计算 $g_2 = W_2 u_2 - B_2^{\\top} q$。\n        b. 通过局部求解计算 $z_2 = A_2^{-1} (K_{2,1} u_2)$。\n        c. 计算 $\\frac{\\partial J}{\\partial \\theta_2} = -g_2^{\\top} z_2$。\n2.  **组合：** 形成梯度向量 $\\nabla_{\\theta} J = [\\frac{\\partial J}{\\partial \\theta_1}, \\frac{\\partial J}{\\partial \\theta_2}]$。该算法避免了构造任何全局 $(n_1+n_2+m) \\times (n_1+n_2+m)$ 矩阵，并且主要由可并行的局部计算主导。\n\n### 第 4 部分：实现\n下面的 Python 代码实现了所推导的算法。对于界面维度 $m=1$ 的特定测试用例，$1 \\times 1$ 界面系统的“克雷洛夫求解器”简化为直接的标量除法。该实现遵循了这一简化，同时严格遵守了基于子域、仅通过界面通信的结构。",
            "answer": "```python\nimport numpy as np\n\ndef compute_gradient_for_case(case_data):\n    \"\"\"\n    使用基于区域分解的伴随方法，为单个测试用例计算目标函数 J \n    关于参数 theta1 和 theta2 的梯度。\n\n    Args:\n        case_data (tuple): 一个包含单个测试用例所有问题数据的元组。\n\n    Returns:\n        list: 一个包含两个梯度分量 [dJ/dtheta1, dJ/dtheta2] 的列表，\n              每个分量都四舍五入到六位小数。\n    \"\"\"\n    # 1. 解包数据并组装子域矩阵\n    (n1, n2, _, b1_list, b2_list, k10_list, k11_list, theta1,\n     k20_list, k21_list, theta2, f1_list, f2_list, w1_list, w2_list) = case_data\n\n    # 将所有输入转换为具有适当形状的 numpy 数组\n    B1 = np.array(b1_list, dtype=float)\n    B2 = np.array(b2_list, dtype=float)\n    K10 = np.array(k10_list, dtype=float)\n    K11 = np.array(k11_list, dtype=float)\n    K20 = np.array(k20_list, dtype=float)\n    K21 = np.array(k21_list, dtype=float)\n    f1 = np.array(f1_list, dtype=float).reshape(n1, 1)\n    f2 = np.array(f2_list, dtype=float).reshape(n2, 1)\n    W1 = np.array(w1_list, dtype=float)\n    W2 = np.array(w2_list, dtype=float)\n\n    A1 = K10 + theta1 * K11\n    A2 = K20 + theta2 * K21\n\n    # 2. 原问题求解 (通过界面问题)\n    # 界面问题是 S * lambda = d\n    # S = B1*A1^-1*B1^T + B2*A2^-1*B2^T\n    # d = B1*A1^-1*f1 - B2*A2^-1*f2\n\n    # 2.1 计算舒尔补 S 和原问题右端项 d\n    # 这些操作代表了局部子域求解。\n    A1_inv_B1T = np.linalg.solve(A1, B1.T)\n    S1 = B1 @ A1_inv_B1T\n    \n    A2_inv_B2T = np.linalg.solve(A2, B2.T)\n    S2 = B2 @ A2_inv_B2T\n    \n    S = S1 + S2\n\n    A1_inv_f1 = np.linalg.solve(A1, f1)\n    d1 = B1 @ A1_inv_f1\n    \n    A2_inv_f2 = np.linalg.solve(A2, f2)\n    d2 = B2 @ A2_inv_f2\n    \n    d = d1 - d2\n    \n    # 2.2 求解界面拉格朗日乘子 lambda\n    # 对于 m=1，这是一个标量除法。对于 m>1，这是一个小型系统求解。\n    lambda_val = np.linalg.solve(S, d)\n    \n    # 2.3 恢复子域原问题状态 u1, u2\n    rhs1_u = f1 - B1.T @ lambda_val\n    u1 = np.linalg.solve(A1, rhs1_u)\n    \n    rhs2_u = f2 + B2.T @ lambda_val\n    u2 = np.linalg.solve(A2, rhs2_u)\n\n    # 3. 伴随问题求解 (通过界面问题)\n    # 伴随界面问题是 S * q = r_adj\n    # r_adj = -(B1*A1^-1*(W1*u1) - B2*A2^-1*(W2*u2))\n\n    # 3.1 计算伴随问题右端项 r_adj\n    g1 = W1 @ u1\n    g2 = W2 @ u2\n    \n    r1_adj_term = B1 @ np.linalg.solve(A1, g1)\n    r2_adj_term = B2 @ np.linalg.solve(A2, g2)\n    \n    r_adj = -(r1_adj_term - r2_adj_term)\n    \n    # 3.2 求解界面伴随变量 q\n    q = np.linalg.solve(S, r_adj)\n\n    # 4. 梯度计算\n    # dJ/d(theta1) = -(W1*u1 + B1^T*q)^T * (A1^-1*K11*u1)\n    v1_grad = K11 @ u1\n    z1_grad = np.linalg.solve(A1, v1_grad)\n    h1_grad = g1 + B1.T @ q\n    dJ_dtheta1 = -(h1_grad.T @ z1_grad)[0, 0]\n    \n    # dJ/d(theta2) = -(W2*u2 - B2^T*q)^T * (A2^-1*K21*u2)\n    v2_grad = K21 @ u2\n    z2_grad = np.linalg.solve(A2, v2_grad)\n    h2_grad = g2 - B2.T @ q\n    dJ_dtheta2 = -(h2_grad.T @ z2_grad)[0, 0]\n    \n    return [round(dJ_dtheta1, 6), round(dJ_dtheta2, 6)]\n\ndef solve():\n    \"\"\"\n    主函数，用于定义测试用例，为每个用例运行求解器，\n    并按指定格式打印结果。\n    \"\"\"\n    test_cases = [\n        # 测试用例 1 (理想情况)\n        (2, 2, 1, [[0, 1]], [[1, 0]], \n         [[4, -1], [-1, 3]], [[1, 0], [0, 1]], 0.3, \n         [[5, -2], [-2, 4]], [[2, 0], [0, 0.5]], 1.2, \n         [1, 0], [0, 2], [[1, 0], [0, 1]], [[1, 0], [0, 1]]),\n        \n        # 测试用例 2 (参数边界)\n        (2, 2, 1, [[0, 1]], [[1, 0]], \n         [[4, -1], [-1, 3]], [[1, 0], [0, 1]], 0.0, \n         [[5, -2], [-2, 4]], [[2, 0], [0, 0.5]], 0.0,\n         [0.2, -0.1], [-0.3, 0.4], [[1, 0], [0, 1]], [[1, 0], [0, 1]]),\n\n        # 测试用例 3 (各向异性目标权重)\n        (2, 2, 1, [[0, 1]], [[1, 0]], \n         [[4, -1], [-1, 3]], [[1, 0], [0, 1]], 1.0, \n         [[5, -2], [-2, 4]], [[2, 0], [0, 0.5]], 0.5,\n         [0.5, -0.5], [1.0, 0.0], [[2, 0], [0, 0.5]], [[1, 0], [0, 3]]),\n\n        # 测试用例 4 (零载荷边界情况)\n        (2, 2, 1, [[0, 1]], [[1, 0]], \n         [[4, -1], [-1, 3]], [[1, 0], [0, 1]], 0.5, \n         [[5, -2], [-2, 4]], [[2, 0], [0, 0.5]], 0.8,\n         [0, 0], [0, 0], [[1, 0], [0, 1]], [[1, 0], [0, 1]]),\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = compute_gradient_for_case(case)\n        results.append(result)\n\n    results_str = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}