{
    "hands_on_practices": [
        {
            "introduction": "为了将扩展有限元法付诸实践，我们必须首先理解其核心的数学构造。第一个练习将引导你完成一个基本但至关重要的计算：为一个被不连续面切割的单元构建增强矩阵。通过对一个由直线不连续面切割的简单四边形单元，使用亥维赛函数（Heaviside function）进行增强，你将亲手计算出增强项对单元矩阵的贡献()。这个练习旨在具体展示单位分解（partition of unity）原理如何通过在标准有限元框架中添加额外的自由度来精确捕捉不连续性。",
            "id": "3506679",
            "problem": "考虑一个在扩展有限元法（XFEM）中使用的单个等参双线性四边形单元，其中，一个标量场（例如，在热弹性多物理场设置中的温度）的近似被富集以捕捉强间断。富集使用 Heaviside 函数，使得富集函数定义为 $\\psi(\\boldsymbol{x}) = H(\\phi(\\boldsymbol{x}))$，其中水平集 $\\phi(\\boldsymbol{x})$ 代表间断。在单元的父（参考）坐标系中，记 $\\boldsymbol{\\xi} = (\\xi,\\eta)$，其中 $\\xi,\\eta \\in [-1,1]$。设间断由直线 $\\phi(\\boldsymbol{\\xi}) = \\xi$ 表示，因此零水平集 $\\phi(\\boldsymbol{\\xi}) = 0$ 将单元划分为两个子域 $\\xi  0$ 和 $\\xi > 0$，并且当 $\\xi \\ge 0$ 时 $H(\\phi(\\boldsymbol{\\xi}))$ 等于 $1$，当 $\\xi  0$ 时等于 $0$。该标量场近似采用单位分解富集\n$$\nu_{h}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{4} N_{i}(\\boldsymbol{\\xi})\\,u_{i} + \\sum_{i=1}^{4} N_{i}(\\boldsymbol{\\xi})\\,a_{i}\\,\\psi(\\boldsymbol{\\xi}),\n$$\n其中 $N_{i}(\\boldsymbol{\\xi})$ 是与四边形四个角节点相关的双线性形函数。\n\n假设该单元通过标准的双线性等参映射将父域 $[-1,1]\\times[-1,1]$ 映射到一个宽度为 $w$、高度为 $h$ 的矩形物理单元，因此雅可比行列式为常数，由 $|J| = \\frac{w h}{4}$ 给出，并且 $d\\Omega = |J|\\,d\\xi\\,d\\eta$。定义富集节点贡献矩阵 $M^{\\mathrm{enr}} \\in \\mathbb{R}^{4\\times 4}$ 为\n$$\n(M^{\\mathrm{enr}})_{ij} \\equiv \\int_{\\Omega_{e}} N_{i}(\\boldsymbol{\\xi})\\,N_{j}(\\boldsymbol{\\xi})\\,\\psi(\\boldsymbol{\\xi})\\,d\\Omega,\n$$\n其中 $i,j \\in \\{1,2,3,4\\}$。\n\n从以上定义出发，仅使用 Heaviside 函数和双线性形函数的基本性质，计算给定直线间断 $\\phi(\\boldsymbol{\\xi}) = \\xi$ 的 $M^{\\mathrm{enr}}$ 的精确封闭形式表达式。此外，根据第一性原理，确定并明确列出在此单元中获得非零富集支持的节点富集自由度 $a_{i}$。将最终矩阵 $M^{\\mathrm{enr}}$ 表示为关于 $w$ 和 $h$ 的解析表达式。不需要数值舍入，最终答案必须是单一的封闭形式解析表达式。",
            "solution": "用户在扩展有限元法（XFEM）的背景下提供了一个适定问题。我将先进行验证，然后给出解答。\n\n### 步骤 1：提取已知条件\n- **方法论**：针对单个等参双线性四边形单元中强间断的扩展有限元法（XFEM）。\n- **标量场近似**：$u_{h}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{4} N_{i}(\\boldsymbol{\\xi})\\,u_{i} + \\sum_{i=1}^{4} N_{i}(\\boldsymbol{\\xi})\\,a_{i}\\,\\psi(\\boldsymbol{\\xi})$，其中 $N_i$ 是双线性形函数，$u_i$ 是标准节点自由度，$a_i$ 是富集节点自由度。\n- **富集函数**：$\\psi(\\boldsymbol{x}) = H(\\phi(\\boldsymbol{x}))$，其中 $H$ 是 Heaviside 函数。\n- **水平集函数**：在父坐标系 $\\boldsymbol{\\xi} = (\\xi,\\eta) \\in [-1,1]\\times[-1,1]$ 中，间断由 $\\phi(\\boldsymbol{\\xi}) = \\xi$ 定义。\n- **Heaviside 函数**：当 $\\xi \\ge 0$ 时，$H(\\phi(\\boldsymbol{\\xi})) = 1$；当 $\\xi  0$ 时，$H(\\phi(\\boldsymbol{\\xi})) = 0$。\n- **等参映射**：父域 $[-1,1]\\times[-1,1]$ 映射到一个宽度为 $w$、高度为 $h$ 的矩形物理单元。\n- **雅可比行列式与面积元**：雅可比行列式为常数， $|J| = \\frac{w h}{4}$，微分面积为 $d\\Omega = |J|\\,d\\xi\\,d\\eta$。\n- **矩阵定义**：富集节点贡献矩阵 $M^{\\mathrm{enr}}$ 定义为 $(M^{\\mathrm{enr}})_{ij} = \\int_{\\Omega_{e}} N_{i}(\\boldsymbol{\\xi})\\,N_{j}(\\boldsymbol{\\xi})\\,\\psi(\\boldsymbol{\\xi})\\,d\\Omega$，其中 $i,j \\in \\{1,2,3,4\\}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学上成立**：该问题基于有限元法及其扩展（XFEM）的既定原理。使用 Heaviside 函数通过单位分解富集来模拟强间断是该方法的基石。所有定义都是标准的。该问题在科学上是合理的。\n- **适定性**：所有必要信息均已提供。函数有定义，积分域已指定，待计算的量已明确给出。该问题是适定的，并存在唯一解。\n- **客观性**：问题陈述使用了精确、无歧义的数学和工程术语，不含主观或基于观点的论断。\n- **结论**：该问题没有任何验证清单中列出的缺陷。它是有效的。\n\n### 步骤 3：判定与行动\n该问题是**有效的**。我将进行完整的、有理据的解答。\n\n### 详细解答\n\n主要任务是计算富集节点贡献矩阵 $M^{\\mathrm{enr}}$，其分量定义为：\n$$ (M^{\\mathrm{enr}})_{ij} = \\int_{\\Omega_{e}} N_{i}(\\boldsymbol{\\xi})\\,N_{j}(\\boldsymbol{\\xi})\\,\\psi(\\boldsymbol{\\xi})\\,d\\Omega $$\n积分在整个单元域 $\\Omega_e$ 上进行。通过将积分变换到父域 $\\boldsymbol{\\xi} \\in [-1,1]\\times[-1,1]$，我们使用 $d\\Omega = |J|\\,d\\xi\\,d\\eta$。代入给定的 $\\psi(\\boldsymbol{\\xi})$ 和 $|J|$ 的表达式，得到：\n$$ (M^{\\mathrm{enr}})_{ij} = \\int_{-1}^{1}\\int_{-1}^{1} N_{i}(\\xi,\\eta)\\,N_{j}(\\xi,\\eta)\\,H(\\xi)\\,\\frac{wh}{4}\\,d\\xi\\,d\\eta $$\nHeaviside 函数 $H(\\xi)$ 在 $\\xi  0$ 时为 $0$，在 $\\xi \\ge 0$ 时为 $1$。此性质将变量 $\\xi$ 的积分域从 $[-1,1]$ 限制到 $[0,1]$。\n$$ (M^{\\mathrm{enr}})_{ij} = \\frac{wh}{4} \\int_{0}^{1}\\int_{-1}^{1} N_{i}(\\xi,\\eta)\\,N_{j}(\\xi,\\eta)\\,d\\eta\\,d\\xi $$\n对于一个 4 节点四边形单元，节点从 $(\\xi,\\eta)=(-1,-1)$ 处的节点 1 开始逆时针编号，其双线性形函数 $N_i(\\xi,\\eta)$ 为：\n$N_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$\n$N_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$\n$N_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$\n$N_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$\n\n两个形函数 $N_i N_j$ 的乘积为：\n$$ N_{i}(\\xi,\\eta) N_{j}(\\xi,\\eta) = \\frac{1}{16} (f_i(\\xi)g_i(\\eta)) (f_j(\\xi)g_j(\\eta)) = \\frac{1}{16} [f_i(\\xi)f_j(\\xi)][g_i(\\eta)g_j(\\eta)] $$\n其中函数 $f_k(\\xi)$ 和 $g_k(\\eta)$ 分别是 $(1\\pm\\xi)$ 或 $(1\\pm\\eta)$。这种可分离性使我们能够将 $(M^{\\mathrm{enr}})_{ij}$ 的积分写成两个一维积分的乘积：\n$$ (M^{\\mathrm{enr}})_{ij} = \\frac{wh}{4} \\frac{1}{16} \\left(\\int_{0}^{1} f_i(\\xi)f_j(\\xi)\\,d\\xi\\right) \\left(\\int_{-1}^{1} g_i(\\eta)g_j(\\eta)\\,d\\eta\\right) $$\n我们来计算这些一维积分。\n对于 $\\eta$ 坐标，在 $[-1,1]$ 上积分：\n$$ \\int_{-1}^{1} (1-\\eta)^2 \\, d\\eta = \\left[-\\frac{(1-\\eta)^3}{3}\\right]_{-1}^{1} = 0 - \\left(-\\frac{2^3}{3}\\right) = \\frac{8}{3} $$\n$$ \\int_{-1}^{1} (1+\\eta)^2 \\, d\\eta = \\left[\\frac{(1+\\eta)^3}{3}\\right]_{-1}^{1} = \\frac{2^3}{3} - 0 = \\frac{8}{3} $$\n$$ \\int_{-1}^{1} (1-\\eta)(1+\\eta) \\, d\\eta = \\int_{-1}^{1} (1-\\eta^2) \\, d\\eta = \\left[\\eta - \\frac{\\eta^3}{3}\\right]_{-1}^{1} = \\left(1-\\frac{1}{3}\\right) - \\left(-1+\\frac{1}{3}\\right) = \\frac{4}{3} $$\n\n对于 $\\xi$ 坐标，在 $[0,1]$ 上积分：\n$$ \\int_{0}^{1} (1-\\xi)^2 \\, d\\xi = \\left[-\\frac{(1-\\xi)^3}{3}\\right]_{0}^{1} = 0 - \\left(-\\frac{1^3}{3}\\right) = \\frac{1}{3} $$\n$$ \\int_{0}^{1} (1+\\xi)^2 \\, d\\xi = \\left[\\frac{(1+\\xi)^3}{3}\\right]_{0}^{1} = \\frac{2^3}{3} - \\frac{1^3}{3} = \\frac{7}{3} $$\n$$ \\int_{0}^{1} (1-\\xi)(1+\\xi) \\, d\\xi = \\int_{0}^{1} (1-\\xi^2) \\, d\\xi = \\left[\\xi - \\frac{\\xi^3}{3}\\right]_{0}^{1} = 1 - \\frac{1}{3} = \\frac{2}{3} $$\n\n现在我们可以计算矩阵 $(M^{\\mathrm{enr}})_{ij}$ 的每个元素。例如，对于 $(1,1)$ 分量：\n$f_1(\\xi) = 1-\\xi$, $g_1(\\eta) = 1-\\eta$.\n$$ (M^{\\mathrm{enr}})_{11} = \\frac{wh}{64} \\left(\\int_{0}^{1} (1-\\xi)^2 \\, d\\xi\\right) \\left(\\int_{-1}^{1} (1-\\eta)^2 \\, d\\eta\\right) = \\frac{wh}{64} \\left(\\frac{1}{3}\\right) \\left(\\frac{8}{3}\\right) = \\frac{8wh}{576} = \\frac{wh}{72} $$\n让我们将所有条目表示为一个公因子的倍数。设 $\\mathbf{m}$ 是积分矩阵，使得 $M^{\\mathrm{enr}} = \\frac{wh}{64} \\mathbf{m}$。\n$$ m_{ij} = \\left(\\int f_i f_j\\right)\\left(\\int g_i g_j\\right) $$\n$m_{11} = (\\frac{1}{3})(\\frac{8}{3}) = \\frac{8}{9}$\n$m_{12} = (\\frac{2}{3})(\\frac{8}{3}) = \\frac{16}{9}$\n$m_{13} = (\\frac{2}{3})(\\frac{4}{3}) = \\frac{8}{9}$\n$m_{14} = (\\frac{1}{3})(\\frac{4}{3}) = \\frac{4}{9}$\n$m_{22} = (\\frac{7}{3})(\\frac{8}{3}) = \\frac{56}{9}$\n$m_{23} = (\\frac{7}{3})(\\frac{4}{3}) = \\frac{28}{9}$\n$m_{24} = (\\frac{2}{3})(\\frac{4}{3}) = \\frac{8}{9}$\n$m_{33} = (\\frac{7}{3})(\\frac{8}{3}) = \\frac{56}{9}$\n$m_{34} = (\\frac{2}{3})(\\frac{8}{3}) = \\frac{16}{9}$\n$m_{44} = (\\frac{1}{3})(\\frac{8}{3}) = \\frac{8}{9}$\n矩阵 $\\mathbf{m}$ 是对称的，因此 $m_{ji}=m_{ij}$。组合成矩阵：\n$$ \\mathbf{m} = \\frac{1}{9} \\begin{pmatrix}\n8  16  8  4 \\\\\n16  56  28  8 \\\\\n8  28  56  16 \\\\\n4  8  16  8\n\\end{pmatrix} = \\frac{4}{9} \\begin{pmatrix}\n2  4  2  1 \\\\\n4  14  7  2 \\\\\n2  7  14  4 \\\\\n1  2  4  2\n\\end{pmatrix} $$\n最后，我们计算 $M^{\\mathrm{enr}}$：\n$$ M^{\\mathrm{enr}} = \\frac{wh}{64} \\mathbf{m} = \\frac{wh}{64} \\frac{4}{9} \\begin{pmatrix}\n2  4  2  1 \\\\\n4  14  7  2 \\\\\n2  7  14  4 \\\\\n1  2  4  2\n\\end{pmatrix} = \\frac{wh}{144} \\begin{pmatrix}\n2  4  2  1 \\\\\n4  14  7  2 \\\\\n2  7  14  4 \\\\\n1  2  4  2\n\\end{pmatrix} $$\n\n关于问题的第二部分，我们必须确定哪些节点富集自由度 $a_i$ 获得非零支持。在处理强间断的标准 XFEM 方法中，富集会应用于任何被间断切割的单元的所有节点。在本问题中，所考虑的单个单元被间断线 $\\phi(\\boldsymbol{\\xi}) = \\xi = 0$ 切割。因此，该单元的所有四个节点都被富集。富集自由度 $a_1$、$a_2$、$a_3$ 和 $a_4$ 都是激活的，并获得非零支持。",
            "answer": "$$ \\boxed{ \\frac{wh}{144} \\begin{pmatrix} 2  4  2  1 \\\\ 4  14  7  2 \\\\ 2  7  14  4 \\\\ 1  2  4  2 \\end{pmatrix} } $$"
        },
        {
            "introduction": "静态不连续面是理解XFEM的良好起点，但该方法的真正威力在于其处理移动和演化界面的能力。本练习将带你进入动态模拟领域，你将为一个由水平集函数（level set function）表示的移动界面，求解其控制方程——标量平流方程。你将通过实现一个半拉格朗日格式来更新界面位置，并重新确定在新的时间步下哪些单元被切割，从而需要被增强()。这项实践对于掌握在流固耦合或相变等问题中追踪动态界面的核心技术至关重要。",
            "id": "3506750",
            "problem": "考虑扩展有限元法 (XFEM)，该方法通过增强标准有限元近似空间来表示不连续性，而无需将网格与界面对齐。在多物理场耦合仿真中，一个重要的步骤是对隐式表示的界面进行稳健的平流输运，并对部分被切割的单元的富集模式进行一致性更新。设界面由水平集函数 $ \\phi(x,y,t) $ 表示，其中零等值线 $ \\phi(x,y,t)=0 $ 定义了移动的界面。控制 $ \\phi $ 在给定速度场 $ v(x,y) $ 下输运的标量平流方程为 $$ \\partial_t \\phi + v \\cdot \\nabla \\phi = 0. $$ 计算区域为单位正方形 $ \\Omega = [0,1] \\times [0,1] $，采用无量纲单位。初始水平集函数是到以 $ (x_0,y_0)=(0.5,0.5) $ 为中心、半径 $ r = 0.25 $ 的圆的符号距离，即 $$ \\phi(x,y,0) = \\sqrt{(x-0.5)^2 + (y-0.5)^2} - 0.25. $$ 使用一个结构化的、均匀的四边形有限元网格，在 $ x $ 方向上有 $ N_x $ 个节点，在 $ y $ 方向上有 $ N_y $ 个节点，均包含边界节点。令 $ \\Delta t $ 表示时间步长。在给定时间，富集模式的定义是：标记那些四个角节点的 $ \\phi $ 值符号不一或包含零的单元为富集单元，这对应于Heaviside型不连续性穿过单元内部。\n\n您的任务是：\n- 从平流方程和特征线法等基本原理出发，在给定的稳态速度场 $ v(x,y) $ 下，实现 $ \\phi $ 在网格节点上从 $ t^n $ 到 $ t^{n+1}=t^n+\\Delta t $ 的物理一致的单步时间推进，假设使用无量纲单位。当出现角度时（例如角速度），必须解释为弧度/单位时间。\n- 推进 $ \\phi $ 后，更新富集模式，标记被更新后的界面切割的单元。这些单元的定义是：在 $ t^{n+1} $ 时刻，其四个角节点上的 $ \\phi $ 值集合中既包含正值也包含负值，或包含任何等于零的值（在数值容差范围内）。\n- 对于测试套件中的每个测试用例，输出更新后时间 $ t^{n+1} $ 的富集单元的整数数量。\n\n您必须编写一个程序，使用以下测试用例套件，每个用例都指定了 $ N_x $、$ N_y $、$ \\Delta t $ 和速度场 $ v(x,y) $：\n\n- 用例A（平移）：$ N_x = 64 $，$ N_y = 64 $，$ \\Delta t = 0.05 $，$ v(x,y) = (0.3, 0.0) $。\n- 用例B（绕区域中心刚体旋转）：$ N_x = 64 $，$ N_y = 64 $，$ \\Delta t = 0.05 $，$ v(x,y) = \\left( -\\omega (y-0.5), \\, \\omega (x-0.5) \\right) $，其中 $ \\omega = 1.0 $ 弧度/单位时间。\n- 用例C（简单剪切）：$ N_x = 64 $，$ N_y = 64 $，$ \\Delta t = 0.05 $，$ v(x,y) = (y, 0.0) $。\n- 用例D（无运动，边界情况）：$ N_x = 64 $，$ N_y = 64 $，$ \\Delta t = 0.05 $，$ v(x,y) = (0.0, 0.0) $。\n\n在数值上，对于回溯后离开区域 $ \\Omega $ 的特征线足点，通过将其钳位到 $ \\Omega $ 内最近的边界点来处理，以确保 $ \\phi $ 的数值插值处处有明确定义。使用一个小的数值容差 $ \\varepsilon $ 来判断用于富集检测的符号和零值，并在您的解决方案中证明该选择的合理性。\n\n您的程序应生成单行输出，其中包含按测试用例套件顺序排列的结果，格式为方括号括起来的逗号分隔列表，例如 $ [\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D] $。每个 $ \\text{result}_\\cdot $ 必须是该用例单次时间更新后富集单元数量的整数。",
            "solution": "用户提供的问题被评估为**有效**。该问题在科学上是合理的、适定的，并为获得唯一的数值解提供了所有必要信息。问题要求在相关的工程背景下，为一偏微分方程实现一种标准的数值方法。\n\n解决方案按以下步骤进行：首先，建立物理和数学原理。其次，基于这些原理设计数值算法。最后，将此算法应用于指定的测试用例。\n\n### 控制原理与特征线法\n\n问题要求解水平集函数 $ \\phi(x,y,t) $ 的标量平流方程：\n$$ \\partial_t \\phi + \\vec{v} \\cdot \\nabla \\phi = 0 $$\n其中 $ \\vec{v}(x,y) $ 是一个给定的稳态速度场。该方程描述了标量 $ \\phi $ 随 $ \\vec{v} $ 定义的流场进行的输运。\n\n特征线法是求解此类一阶双曲型偏微分方程的一种技术。该方程可以解释为，沿着时空中称为特征线的特定曲线，$ \\phi $ 的全导数为零。这些特征曲线 $ \\vec{x}(t) $ 由常微分方程定义：\n$$ \\frac{d\\vec{x}}{dt} = \\vec{v}(\\vec{x}(t)) $$\n沿着这些曲线，$ \\phi $ 的变化率由下式给出：\n$$ \\frac{D\\phi}{Dt} = \\frac{\\partial\\phi}{\\partial t} + \\frac{d\\vec{x}}{dt} \\cdot \\nabla\\phi = \\partial_t \\phi + \\vec{v} \\cdot \\nabla \\phi = 0 $$\n这意味着 $ \\phi $ 沿着一条特征曲线是恒定的。因此，为了找到新时刻 $ t^{n+1} $ 网格点 $ \\vec{x}_p $ 处的 $ \\phi $ 值，我们可以沿其特征曲线向后追溯时间，以找到其在上一时刻 $ t^n $ 的位置。这个起始位置被称为出发点 $ \\vec{x}_d $。该原理给出：\n$$ \\phi(\\vec{x}_p, t^{n+1}) = \\phi(\\vec{x}_d, t^n) $$\n\n### 数值实现：半拉格朗日格式\n\n基于此原理的数值格式称为半拉格朗日法。我们已知在时刻 $ t^n $ 时均匀网格所有节点上的 $ \\phi^n $ 值。为了求出在时刻 $ t^{n+1} = t^n + \\Delta t $ 时这些相同网格节点上的值 $ \\phi^{n+1} $，我们对每个网格节点 $ \\vec{x}_p $ 执行以下步骤：\n\n1.  **回溯**：近似计算出发点 $ \\vec{x}_d $。特征常微分方程 $ d\\vec{x}/dt = \\vec{v} $ 在一个时间步长 $ \\Delta t $ 内向后求解。最简单的方法是一阶显式（后向）欧拉积分：\n    $$ \\vec{x}_d \\approx \\vec{x}_p - \\vec{v}(\\vec{x}_p) \\Delta t $$\n    这种一阶格式是题目所要求的“单步时间推进”的直接和标准实现。虽然存在更高阶的方法（例如，Runge-Kutta）以获得更高精度，但一阶方法已足够，并且与问题陈述一致。\n\n2.  **边界处理**：出发点 $ \\vec{x}_d $ 可能位于计算域 $ \\Omega = [0,1] \\times [0,1] $ 之外。按照规定，我们将其坐标钳位到区域边界：\n    $$ \\vec{x}_{d, \\text{clamped}} = \\text{clip}(\\vec{x}_d, [0,1]) $$\n    这确保了插值步骤保持良定义。\n\n3.  **插值**：出发点 $ \\vec{x}_{d, \\text{clamped}} $ 通常不会与时刻 $ t^n $ 的网格节点重合。因此，必须根据已知的 $ \\phi^n $ 节点值来插值计算 $ \\phi(\\vec{x}_{d, \\text{clamped}}, t^n) $ 的值。对于指定的结构化四边形网格，双线性插值是自然且合适的选择。给定网格单元内的一个点，其值由四个角节点的值插值得到。将整个过程（回溯、钳位和插值）应用于所有网格节点，以计算出完整的场 $ \\phi^{n+1} $。\n\n### 富集模式更新\n\n在计算出更新后的水平集场 $ \\phi^{n+1} $ 后，确定富集单元的集合。一个单元（网格中的一个四边形单元）由四个角节点定义。根据问题陈述，如果一个单元被界面（$ \\phi $ 的零等值线）切割，则该单元被标记为“富集”。其判断标准是：“在 $ t^{n+1} $ 时刻，该单元四个角节点的 $ \\phi $ 值集合中既包含正值也包含负值，或包含任何等于零的值（在数值容差范围内）”。\n\n为了稳健地实现这一点，我们引入一个小的数值容差 $ \\varepsilon $。一个合适的值是 $ \\varepsilon = 10^{-9} $，它足够小，与 $ \\phi $ 的物理尺度相比可以忽略不计，但又足够大，可以处理接近零的浮点数不精确性。对于每个单元，令 $ \\Phi_{\\text{corners}} $ 为 $ \\phi^{n+1} $ 的四个角节点值的集合。如果满足以下条件，则该单元被视为富集单元：\n$$ (\\max(\\Phi_{\\text{corners}}) > \\varepsilon \\text{ and } \\min(\\Phi_{\\text{corners}})  -\\varepsilon) \\quad \\lor \\quad (\\min(|\\phi_i|) \\le \\varepsilon \\text{ for any } \\phi_i \\in \\Phi_{\\text{corners}}) $$\n这个逻辑能正确识别出其角点间存在符号变化的单元，以及界面非常靠近或穿过节点的单元。此类富集单元的总数是每个测试用例所需的输出。\n\n为了提高效率，整个过程都进行了矢量化处理。所有网格节点的出发点和速度都通过数组运算来计算。对所有出发点的插值是使用 SciPy 的 `RegularGridInterpolator` 进行单次调用完成的，该插值器被配置为使用线性插值。",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Solves for the number of enriched elements after one time step of advecting a level set function.\n    The advection is performed using a first-order semi-Lagrangian method on a uniform grid.\n    \"\"\"\n    \n    # Define the test suite of cases.\n    test_cases = [\n        {\n            'name': 'A (translation)',\n            'Nx': 64, \n            'Ny': 64, \n            'dt': 0.05, \n            'v_field': lambda x, y: (0.3 * np.ones_like(x), 0.0 * np.ones_like(y))\n        },\n        {\n            'name': 'B (rotation)',\n            'Nx': 64, \n            'Ny': 64, \n            'dt': 0.05, \n            'v_field': lambda x, y: (-1.0 * (y - 0.5), 1.0 * (x - 0.5))\n        },\n        {\n            'name': 'C (shear)',\n            'Nx': 64, \n            'Ny': 64, \n            'dt': 0.05, \n            'v_field': lambda x, y: (y, 0.0 * np.ones_like(y))\n        },\n        {\n            'name': 'D (no motion)',\n            'Nx': 64, \n            'Ny': 64, \n            'dt': 0.05, \n            'v_field': lambda x, y: (0.0 * np.ones_like(x), 0.0 * np.ones_like(y))\n        },\n    ]\n\n    results = []\n    # Numerical tolerance for checking for zero values.\n    eps = 1e-9\n\n    for case in test_cases:\n        Nx, Ny, dt = case['Nx'], case['Ny'], case['dt']\n        v_field = case['v_field']\n\n        # 1. Create mesh grid and define the initial level set function.\n        # The domain is the unit square [0,1] x [0,1].\n        x_coords = np.linspace(0.0, 1.0, Nx)\n        y_coords = np.linspace(0.0, 1.0, Ny)\n        X, Y = np.meshgrid(x_coords, y_coords, indexing='ij')\n\n        # Initial level set: signed distance to a circle r=0.25 at (0.5, 0.5).\n        phi_initial = np.sqrt((X - 0.5)**2 + (Y - 0.5)**2) - 0.25\n\n        # 2. Advance the level set field one time step.\n        # This is a semi-Lagrangian advection step.\n\n        # Create an interpolator for the initial field phi_initial.\n        # This will be used to find phi at the departure points.\n        # We use linear interpolation, which is bilinear for a 2D grid.\n        interpolator = RegularGridInterpolator(\n            (x_coords, y_coords), phi_initial, \n            method='linear', bounds_error=False, fill_value=None\n        )\n\n        # Calculate the velocity field at all grid points (X, Y).\n        Vx, Vy = v_field(X, Y)\n\n        # Calculate the departure points using first-order Euler back-tracing.\n        Xd = X - Vx * dt\n        Yd = Y - Vy * dt\n\n        # Clamp the departure points to the domain boundaries as per the problem.\n        Xd_clamped = np.clip(Xd, 0.0, 1.0)\n        Yd_clamped = np.clip(Yd, 0.0, 1.0)\n        \n        # Prepare points for the interpolator: a (N, 2) array.\n        departure_points = np.stack([Xd_clamped.ravel(), Yd_clamped.ravel()], axis=-1)\n\n        # Interpolate phi at departure points to find the field at the next time step.\n        phi_next_flat = interpolator(departure_points)\n        phi_next = phi_next_flat.reshape((Nx, Ny))\n\n        # 3. Count the number of enriched elements based on the updated field.\n        enriched_count = 0\n        # Iterate over all elements. An element is defined by its bottom-left node (i, j).\n        for i in range(Nx - 1):\n            for j in range(Ny - 1):\n                # Collect the four corner nodal values of phi_next for the element.\n                corner_values = np.array([\n                    phi_next[i, j],\n                    phi_next[i + 1, j],\n                    phi_next[i, j + 1],\n                    phi_next[i + 1, j + 1]\n                ])\n\n                # Check enrichment criterion: mixed signs or includes a zero (with tolerance).\n                has_pos = np.any(corner_values  eps)\n                has_neg = np.any(corner_values  -eps)\n                has_zero = np.any(np.abs(corner_values) = eps)\n\n                if (has_pos and has_neg) or has_zero:\n                    enriched_count += 1\n        \n        results.append(enriched_count)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在掌握了XFEM的基本构造和界面追踪之后，下一步是将其应用于包含非线性物理过程的复杂问题中。许多界面现象，例如断裂过程中的内聚力行为，本质上是非线性的。本练习将指导你为一个具有非线性内聚力定律的裂纹界面模型，实现一个牛顿-拉弗森（Newton-Raphson）求解器()。通过处理这个涉及多物理场（流体压力和热载荷）耦合的简化模型，你将学习到如何在XFEM框架内建立和求解非线性方程组，这是通向高级计算力学模拟的关键一步。",
            "id": "3506770",
            "problem": "考虑一个使用扩展有限元法（XFEM）建立的、嵌入在一维弹性杆中的单硗裂纹的小应变、准静态界面模型。裂纹由一个双节点富集界面表示，裂纹张开场使用线性形函数在单个积分点上进行插值。所考虑的物理耦合是多物理场：流体压力作用在裂纹表面上以撑开裂纹，热载荷贡献于有效张开力。跨越裂纹的内聚牵引力遵循一个非线性的牵引力-分离位移本构，该本构为张开和压缩情况分段定义。本问题中所有量均为无量纲；不需要物理单位。\n\n从忽略惯性力和体积力的线性动量平衡方程出发，裂纹表面上的牵引力平衡意味着内部内聚牵引力必须与结构阻力和外部裂纹面载荷相平衡。设富集自由度为向量 $w = [w_1, w_2]^T$，表示两个富集节点处的位移跳跃参数。积分点处的裂纹张开位移插值表示为\n$$\nw_g = N_1 w_1 + N_2 w_2,\n$$\n其中线性形函数为 $N_1 = N_2 = \\frac{1}{2}$。定义富集刚度矩阵为\n$$\nK = k_e \\begin{bmatrix}1  \\rho \\\\ \\rho  1\\end{bmatrix},\n$$\n其中 $k_e > 0$ 是富集结构刚度，$0 \\le \\rho  1$ 量化了富集自由度之间的耦合。流体压力载荷 $p \\ge 0$ 均匀作用于裂纹表面，并通过形函数加权对残差产生贡献。热载荷参数 $\\theta \\ge 0$ 作为与形函数成正比的有效张开力产生贡献。\n\n内聚牵引力-分离位移本构定义为\n$$\nT(w_g) = \\begin{cases}\n\\sigma_0 \\left(1 - e^{-\\beta w_g}\\right),  \\text{若 } w_g \\ge 0 \\quad \\text{(张开)}, \\\\\nk_c\\, w_g,  \\text{若 } w_g  0 \\quad \\text{(压缩/接触)},\n\\end{cases}\n$$\n其中 $\\sigma_0 > 0$ 是内聚强度标度，$\\beta > 0$ 表征软化本构的非线性，而 $k_c > 0$ 是压缩时的接触罚刚度。牵引力关于裂纹张开位移的导数为\n$$\n\\frac{dT}{dw_g} = \\begin{cases}\n\\sigma_0 \\beta\\, e^{-\\beta w_g},  \\text{若 } w_g \\ge 0, \\\\\nk_c,  \\text{若 } w_g  0.\n\\end{cases}\n$$\n\n在XFEM中使用Heaviside富集，并在界面积分点应用加权残差法，可得到两个富集自由度的离散非线性残差为\n$$\nR_i(w) = \\sum_{j=1}^{2} K_{ij} w_j + N_i\\, T(w_g) - N_i\\, p - N_i\\, \\theta, \\quad i=1,2,\n$$\n其中 $N_1 = N_2 = \\frac{1}{2}$ 且 $w_g = \\frac{1}{2}(w_1 + w_2)$。\n\n牛顿法所需的一致切线（雅可比）矩阵由残差导出。使用链式法则，\n$$\nJ_{ij}(w) = \\frac{\\partial R_i}{\\partial w_j} = K_{ij} + N_i \\frac{dT}{dw_g} N_j, \\quad i,j=1,2,\n$$\n可以紧凑地写作\n$$\nJ(w) = K + \\frac{dT}{dw_g} \\, (N \\otimes N),\n$$\n其中 $N = \\begin{bmatrix}\\frac{1}{2}  \\frac{1}{2}\\end{bmatrix}^T$ 且 $\\otimes$ 表示外积。\n\n任务：使用上述残差和切线矩阵，为非线性系统 $R(w) = 0$ 实现一个牛顿-拉夫逊求解器，并带有可选的回溯线搜索功能，该功能通过减小步长来确保残差范数减小。牛顿更新步骤为\n$$\nJ(w^{(k)}) \\, \\Delta w^{(k)} = - R(w^{(k)}), \\quad w^{(k+1)} = w^{(k)} + \\lambda^{(k)} \\Delta w^{(k)},\n$$\n其中 $0  \\lambda^{(k)} \\le 1$ 在启用线搜索时由其确定，否则 $\\lambda^{(k)} = 1$。使用残差向量的欧几里得范数来评估收敛性。使用停止准则 $\\|R(w^{(k)})\\| \\le \\varepsilon$，其中 $\\varepsilon > 0$ 是指定的容差，或达到最大迭代次数。\n\n您的程序必须为每个测试用例返回一个包含三个值的列表：\n- 直到终止（收敛或达到最大次数）所执行的牛顿迭代的整数次数。\n- 作为浮点数的最终残差范数。\n- 在所有迭代中应用线搜索步长缩减的总整数次数（如果禁用线搜索则为零）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个结果本身也表示为一个用方括号括起来的、以逗号分隔的列表。例如，两个测试用例的输出格式将是 \"[[n1,r1,ls1],[n2,r2,ls2]]\"。\n\n为以下测试套件实现求解器，该套件探索了一系列行为，包括典型的收敛情况、高载荷、初始压缩状态以及禁用线搜索的效果。所有量均为无量纲。\n\n测试用例1（理想情况）：\n- $k_e = 6.0$, $\\rho = 0.2$, $\\sigma_0 = 5.0$, $\\beta = 4.0$, $k_c = 20.0$, $p = 2.0$, $\\theta = 0.5$。\n- 初始猜测值 $w^{(0)} = [0.0, 0.0]^T$。\n- 启用线搜索。\n- 容差 $\\varepsilon = 10^{-10}$，最大迭代次数 $50$。\n\n测试用例2（高流体压力）：\n- $k_e = 6.0$, $\\rho = 0.2$, $\\sigma_0 = 5.0$, $\\beta = 4.0$, $k_c = 20.0$, $p = 8.0$, $\\theta = 0.0$。\n- 初始猜测值 $w^{(0)} = [0.1, 0.1]^T$。\n- 启用线搜索。\n- 容差 $\\varepsilon = 10^{-10}$，最大迭代次数 $50$。\n\n测试用例3（初始压缩状态）：\n- $k_e = 6.0$, $\\rho = 0.2$, $\\sigma_0 = 5.0$, $\\beta = 4.0$, $k_c = 30.0$, $p = 0.5$, $\\theta = 0.2$。\n- 初始猜测值 $w^{(0)} = [-0.3, -0.1]^T$。\n- 启用线搜索。\n- 容差 $\\varepsilon = 10^{-10}$，最大迭代次数 $50$。\n\n测试用例4（无线性搜索对比）：\n- $k_e = 6.0$, $\\rho = 0.2$, $\\sigma_0 = 5.0$, $\\beta = 4.0$, $k_c = 20.0$, $p = 2.0$, $\\theta = 0.5$。\n- 初始猜测值 $w^{(0)} = [0.0, 0.0]^T$。\n- 禁用线搜索。\n- 容差 $\\varepsilon = 10^{-10}$，最大迭代次数 $50$。\n\n您的程序应生成单行输出，包含四个测试用例的结果列表，格式严格为 \"[[n1,r1,ls1],[n2,r2,ls2],[n3,r3,ls3],[n4,r4,ls4]]\"，其中 $n_i$ 是整数，$r_i$ 是浮点数。本问题不涉及角度；因此，不需要角度单位说明。所有量均为无量纲，因此不需要物理单位说明。程序必须是自包含的，且不要求任何用户输入。",
            "solution": "该问题是有效的，因为它在计算力学领域提出了一个适定的、有科学依据的情景，该情景是自包含的，并且没有矛盾或歧义。任务是实现一个标准的数值方法，即牛顿-拉夫逊算法，来求解从一个裂纹的扩展有限元法（XFEM）模型推导出的非线性方程组。所有必要的方程、参数和边界条件都已提供。\n\n问题的核心是找到满足非线性方程组 $R(w) = 0$ 的富集自由度向量 $w = [w_1, w_2]^T$，其中 $R$ 是残差向量。牛顿-拉夫逊方法是一个迭代过程，用于寻找实值函数根的逐次更好的近似值。该问题的更新法则推导如下。\n\n给定第 $k$ 次迭代的近似解 $w^{(k)}$，我们寻求一个修正量 $\\Delta w^{(k)}$，使得 $w^{(k+1)} = w^{(k)} + \\Delta w^{(k)}$ 是一个更好的近似。我们使用一阶泰勒展开将残差函数 $R(w)$ 在 $w^{(k)}$ 周围线性化：\n$$\nR(w^{(k+1)}) \\approx R(w^{(k)}) + J(w^{(k)}) (w^{(k+1)} - w^{(k)}) = R(w^{(k)}) + J(w^{(k)}) \\Delta w^{(k)})\n$$\n其中 $J(w^{(k)})$ 是 $R$ 在 $w^{(k)}$ 处求值的雅可比矩阵。设 $R(w^{(k+1)}) = 0$，我们得到更新步的线性系统：\n$$\nJ(w^{(k)}) \\Delta w^{(k)} = - R(w^{(k)})\n$$\n一旦计算出 $\\Delta w^{(k)}$，新的近似解为 $w^{(k+1)} = w^{(k)} + \\lambda^{(k)} \\Delta w^{(k)}$，其中 $\\lambda^{(k)} \\in (0, 1]$ 是一个步长参数，由线搜索算法确定，以确保稳健的收敛性。如果不使用线搜索，则 $\\lambda^{(k)} = 1$。重复此过程，直到残差的欧几里得范数 $\\|R(w^{(k)})\\|$ 小于指定的容差 $\\varepsilon$，或达到最大迭代次数。\n\n该问题的算法具体组成部分如下：\n\n1.  **系统变量和参数**:\n    系统由富集自由度向量 $w = [w_1, w_2]^T$ 描述。单个积分点处的裂纹张开位移由 $w_g = \\frac{1}{2}(w_1 + w_2)$ 给出。模型参数包括富集结构刚度 $k_e$、耦合项 $\\rho$、内聚本构参数 $\\sigma_0$、$\\beta$ 和 $k_c$，以及外部载荷参数 $p$ 和 $\\theta$。\n\n2.  **残差向量 $R(w)$**:\n    残差向量是一个 $2 \\times 1$ 的向量，定义为：\n    $$\n    R(w) = K w + N T(w_g) - N(p + \\theta)\n    $$\n    其中 $K = k_e \\begin{bmatrix}1  \\rho \\\\ \\rho  1\\end{bmatrix}$ 是富集刚度矩阵，$N = [\\frac{1}{2}, \\frac{1}{2}]^T$ 是形函数向量，$T(w_g)$ 是分段内聚牵引力：\n    $$\n    T(w_g) = \\begin{cases}\n    \\sigma_0 (1 - e^{-\\beta w_g}),  w_g \\ge 0 \\\\\n    k_c w_g,  w_g  0\n    \\end{cases}\n    $$\n    在每次迭代中，根据当前的 $w^{(k)}$ 计算 $w_g$，这决定了在计算 $T(w_g)$ 时使用牵引力本构的哪个分支。\n\n3.  **雅可比矩阵 $J(w)$**:\n    雅可比矩阵（或一致切线矩阵）是一个 $2 \\times 2$ 矩阵，由下式给出：\n    $$\n    J(w) = K + \\frac{dT}{dw_g} (N \\otimes N)\n    $$\n    其中 $N \\otimes N$ 是外积 $N N^T$，牵引力的导数为：\n    $$\n    \\frac{dT}{dw_g} = \\begin{cases}\n    \\sigma_0 \\beta e^{-\\beta w_g},  w_g \\ge 0 \\\\\n    k_c,  w_g  0\n    \\end{cases}\n    $$\n    项 $\\frac{dT}{dw_g}$ 也使用当前的 $w_g$ 进行求值。最终的雅可比矩阵为：\n    $$\n    J(w) = \\begin{bmatrix} k_e + \\frac{1}{4}\\frac{dT}{dw_g}  k_e \\rho + \\frac{1}{4}\\frac{dT}{dw_g} \\\\ k_e \\rho + \\frac{1}{4}\\frac{dT}{dw_g}  k_e + \\frac{1}{4}\\frac{dT}{dw_g} \\end{bmatrix}\n    $$\n\n4.  **回溯线搜索**:\n    如果启用，则采用回溯线搜索来寻找合适的步长 $\\lambda^{(k)}$。从 $\\lambda^{(k)}=1$ 开始，算法检查建议的更新是否减小了残差范数，即 $\\|R(w^{(k)} + \\lambda^{(k)} \\Delta w^{(k)})\\|  \\|R(w^{(k)})\\|$ 是否成立。如果不满足此条件，则逐次减小 $\\lambda^{(k)}$（例如，减半），直到条件满足或执行了最大缩减次数。记录此类缩减的次数。\n\n**迭代过程：**\n实现的算法对每个测试用例遵循以下步骤：\n\n1.  初始化迭代计数器 $k=0$，总线搜索缩减次数 $ls\\_count = 0$，以及初始猜测值 $w^{(0)}$。构造刚度矩阵 $K$ 和形函数向量 $N$。\n2.  开始主循环，对于 $k$ 从 $0$ 到 `max_iterations-1`：\n    a. 计算 $w_g = N^T w^{(k)}$。\n    b. 计算 $T(w_g)$ 和总外力 $(p+\\theta)$。\n    c. 计算残差向量 $R(w^{(k)}) = K w^{(k)} + N(T(w_g) - p - \\theta)$。\n    d. 计算欧几里得范数 $\\|R(w^{(k)})\\|$。如果 $\\|R(w^{(k)})\\| \\le \\varepsilon$，则达到收敛。循环终止。\n    e. 根据 $w_g$ 计算 $\\frac{dT}{dw_g}$。\n    f. 组装雅可比矩阵 $J(w^{(k)}) = K + \\frac{dT}{dw_g} (N N^T)$。\n    g. 求解线性系统 $J(w^{(k)}) \\Delta w^{(k)} = -R(w^{(k)})$ 以得到 $\\Delta w^{(k)}$。\n    h. 如果启用线搜索：\n        i. 初始化 $\\lambda = 1$ 和此步骤中的缩减计数器。\n        ii. 进入一个循环：计算试探解 $w_{trial} = w^{(k)} + \\lambda \\Delta w^{(k)}$ 和对应的残差 $R_{trial}$。如果 $\\|R_{\\text{trial}}\\|  \\|R(w^{(k)})\\|$，则跳出循环。否则，设置 $\\lambda \\leftarrow \\lambda/2$，增加缩减计数器，并重复。\n        iii. 将缩减次数加到 $ls\\_count$。\n    i. 如果禁用线搜索，则设置 $\\lambda = 1$。\n    j. 更新解：$w^{(k+1)} = w^{(k)} + \\lambda \\Delta w^{(k)}$。\n3.  循环终止后（无论是通过收敛还是达到 `max_iterations`），返回最终的迭代次数、最终的残差范数以及总的线搜索缩减次数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef newton_raphson_solver(params, initial_w, settings):\n    \"\"\"\n    Solves the nonlinear system R(w) = 0 using the Newton-Raphson method.\n\n    Args:\n        params (tuple): Physical parameters (k_e, rho, sigma_0, beta, k_c, p, theta).\n        initial_w (np.ndarray): Initial guess for w = [w1, w2].\n        settings (tuple): Solver settings (tolerance, max_iterations, line_search_enabled).\n\n    Returns:\n        tuple: (iteration_count, final_residual_norm, total_line_search_reductions).\n    \"\"\"\n    k_e, rho, sigma_0, beta, k_c, p, theta = params\n    tolerance, max_iterations, line_search_enabled = settings\n\n    w = np.array(initial_w, dtype=float)\n    \n    K = k_e * np.array([[1.0, rho], [rho, 1.0]])\n    N = np.array([0.5, 0.5])\n    \n    total_ls_reductions = 0\n    residual_norm = float('inf')\n    \n    for i in range(max_iterations):\n        # 1. Calculate crack opening\n        w_g = np.dot(N, w)\n        \n        # 2. Evaluate traction T and its derivative dT/dw_g\n        if w_g = 0:\n            exp_term = np.exp(-beta * w_g)\n            T_wg = sigma_0 * (1.0 - exp_term)\n            dT_dwg = sigma_0 * beta * exp_term\n        else:\n            T_wg = k_c * w_g\n            dT_dwg = k_c\n            \n        # 3. Compute residual vector R\n        F_ext = p + theta\n        R = K @ w + N * (T_wg - F_ext)\n        residual_norm = np.linalg.norm(R)\n        \n        # 4. Check for convergence\n        if residual_norm = tolerance:\n            return i, residual_norm, total_ls_reductions\n            \n        # 5. Assemble Jacobian matrix J\n        N_outer_N = np.outer(N, N)\n        J = K + dT_dwg * N_outer_N\n        \n        # 6. Solve for the update step delta_w\n        try:\n            delta_w = np.linalg.solve(J, -R)\n        except np.linalg.LinAlgError:\n            # Jacobian is singular, cannot proceed\n            return i + 1, residual_norm, total_ls_reductions\n\n        # 7. Apply backtracking line search (if enabled)\n        step_lambda = 1.0\n        if line_search_enabled:\n            current_residual_norm = residual_norm\n            num_reductions = 0\n            max_ls_steps = 10 # Avoid infinite loops\n            \n            for ls_step in range(max_ls_steps):\n                w_trial = w + step_lambda * delta_w\n                w_g_trial = np.dot(N, w_trial)\n                \n                if w_g_trial = 0:\n                    exp_term_trial = np.exp(-beta * w_g_trial)\n                    T_wg_trial = sigma_0 * (1.0 - exp_term_trial)\n                else:\n                    T_wg_trial = k_c * w_g_trial\n                \n                R_trial = K @ w_trial + N * (T_wg_trial - F_ext)\n                trial_residual_norm = np.linalg.norm(R_trial)\n                \n                if trial_residual_norm  current_residual_norm:\n                    break\n                else:\n                    step_lambda /= 2.0\n                    num_reductions += 1\n            total_ls_reductions += num_reductions\n        \n        # 8. Update solution vector w\n        w += step_lambda * delta_w\n        \n    # If loop finishes, max iterations was reached\n    # Re-calculate final residual norm for the last state\n    w_g = np.dot(N, w)\n    if w_g = 0:\n        exp_term = np.exp(-beta * w_g)\n        T_wg = sigma_0 * (1.0 - exp_term)\n    else:\n        T_wg = k_c * w_g\n    F_ext = p + theta\n    R = K @ w + N * (T_wg - F_ext)\n    final_residual_norm = np.linalg.norm(R)\n\n    return max_iterations, final_residual_norm, total_ls_reductions\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"params\": (6.0, 0.2, 5.0, 4.0, 20.0, 2.0, 0.5),\n            \"initial_w\": [0.0, 0.0],\n            \"settings\": (1e-10, 50, True)\n        },\n        {\n            \"params\": (6.0, 0.2, 5.0, 4.0, 20.0, 8.0, 0.0),\n            \"initial_w\": [0.1, 0.1],\n            \"settings\": (1e-10, 50, True)\n        },\n        {\n            \"params\": (6.0, 0.2, 5.0, 4.0, 30.0, 0.5, 0.2),\n            \"initial_w\": [-0.3, -0.1],\n            \"settings\": (1e-10, 50, True)\n        },\n        {\n            \"params\": (6.0, 0.2, 5.0, 4.0, 20.0, 2.0, 0.5),\n            \"initial_w\": [0.0, 0.0],\n            \"settings\": (1e-10, 50, False)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n_iters, final_resid, ls_count = newton_raphson_solver(\n            case[\"params\"],\n            case[\"initial_w\"],\n            case[\"settings\"]\n        )\n        results.append([n_iters, final_resid, ls_count])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}