{
    "hands_on_practices": [
        {
            "introduction": "A primary challenge in computational magnetohydrodynamics (MHD) is maintaining the solenoidal constraint, $\\nabla \\cdot \\mathbf{B} = 0$. One powerful strategy is to reformulate the problem in terms of the magnetic vector potential, $\\mathbf{A}$, where the magnetic field is defined as $\\mathbf{B} = \\nabla \\times \\mathbf{A}$, automatically satisfying the constraint at the analytical level. This exercise  delves into deriving the evolution equation for $\\mathbf{A}$ under the Coulomb gauge and explores how this choice of formulation impacts the mathematical character and numerical stiffness of the problem, a key consideration in developing efficient multiphysics solvers.",
            "id": "3513637",
            "problem": "Consider resistive Magnetohydrodynamics (MHD) in a conducting fluid with constant electrical conductivity $\\sigma$, where the displacement current is negligible (magnetoquasistatic approximation). The electromagnetic fields obey Maxwell–Faraday’s law and Ampère’s law without displacement current, and the charge transport in the fluid obeys the Ohm’s law for moving conductors. Let the magnetic field be represented by the magnetic vector potential $\\mathbf{A}$ via $\\mathbf{B}=\\nabla\\times\\mathbf{A}$, and let the electric field be represented by the electromagnetic potentials as $\\mathbf{E}=-\\partial_t\\mathbf{A}-\\nabla\\phi$. A gauge freedom under the transformation $\\mathbf{A}\\rightarrow\\mathbf{A}+\\nabla\\chi$, $\\phi\\rightarrow\\phi-\\partial_t\\chi$ allows one to impose a gauge condition. In a coupled fluid–electromagnetics solver, the choice of gauge affects the character of the partial differential equations and thus the numerical stiffness.\n\nStarting only from the fundamental laws and definitions described above, and adopting the Coulomb gauge $\\nabla\\cdot\\mathbf{A}=0$, select the option that correctly states the evolution equation for $\\mathbf{A}$ in terms of the fluid velocity $\\mathbf{u}$ and the scalar potential $\\phi$ (with the magnetic diffusivity $\\eta_m=1/(\\mu_0\\sigma)$), and correctly identifies a gauge strategy that minimizes numerical stiffness in multiphysics coupled solvers, with a brief justification.\n\nA. $\\partial_t\\mathbf{A}=\\mathbf{u}\\times(\\nabla\\times\\mathbf{A})+\\eta_m\\,\\nabla^2\\mathbf{A}-\\nabla\\phi$; under the Coulomb gauge one solves an elliptic equation for $\\phi$ that enforces $\\nabla\\cdot\\mathbf{A}=0$, yielding an advection–diffusion–elliptic system for $(\\mathbf{A},\\phi)$ that avoids light-speed electromagnetic waves and is less stiff than Lorenz-type gauges in the magnetoquasistatic regime.\n\nB. $\\partial_t\\mathbf{A}=\\mathbf{u}\\times(\\nabla\\times\\mathbf{A})-\\eta_m\\,\\nabla^2\\mathbf{A}-\\nabla\\phi$ with $\\eta_m=\\mu_0/\\sigma$; the Lorenz gauge $\\nabla\\cdot\\mathbf{A}+(1/c^2)\\,\\partial_t\\phi=0$ minimizes stiffness by rendering the equations purely parabolic in time.\n\nC. $\\partial_t\\mathbf{A}=-\\mathbf{u}\\times(\\nabla\\times\\mathbf{A})+\\eta_m\\,\\nabla^2\\mathbf{A}$ with $\\eta_m=1/(\\mu_0\\sigma)$ when using the Weyl gauge $\\phi=0$ without enforcing any constraint on $\\nabla\\cdot\\mathbf{A}$, which removes constraints and is therefore less stiff than Coulomb gauge.\n\nD. $\\partial_t\\mathbf{A}=\\mathbf{u}\\times(\\nabla\\times\\mathbf{A})-\\frac{1}{\\sigma}\\,\\nabla\\times(\\nabla\\times\\mathbf{A})-\\nabla\\phi$ under the Coulomb gauge; choosing the Lorenz gauge is preferable in magnetoquasistatics to suppress divergence errors without affecting stiffness.\n\nOnly one option is fully correct in both the equation and the gauge–stiffness discussion. Provide your choice.",
            "solution": "The user-provided problem statement is valid. It is scientifically grounded, well-posed, and expressed in objective language. The problem asks for the derivation of the magnetic vector potential evolution equation and an analysis of gauge choices, which are standard topics in computational electromagnetics and MHD.\n\n### Validation and Derivation\n\nThe correct choice is **A**. We derive the evolution equation for the magnetic vector potential $\\mathbf{A}$ from the fundamental laws.\n\n1.  **Fundamental Laws**:\n    *   Ohm's Law for a moving conductor: $\\mathbf{J} = \\sigma(\\mathbf{E} + \\mathbf{u} \\times \\mathbf{B})$\n    *   Ampère's Law (magnetoquasistatic): $\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$\n    *   Potential definitions: $\\mathbf{E} = -\\partial_t \\mathbf{A} - \\nabla \\phi$ and $\\mathbf{B} = \\nabla \\times \\mathbf{A}$\n\n2.  **Combine Laws**: Substitute Ohm's law into Ampère's law to solve for the electric field $\\mathbf{E}$:\n    $$ \\mathbf{J} = \\frac{1}{\\mu_0} \\nabla \\times \\mathbf{B} $$\n    $$ \\frac{1}{\\mu_0} \\nabla \\times \\mathbf{B} = \\sigma(\\mathbf{E} + \\mathbf{u} \\times \\mathbf{B}) $$\n    $$ \\mathbf{E} = -\\mathbf{u} \\times \\mathbf{B} + \\frac{1}{\\sigma\\mu_0} \\nabla \\times \\mathbf{B} $$\n\n3.  **Introduce Magnetic Diffusivity**: Let $\\eta_m = 1/(\\sigma\\mu_0)$. The equation for $\\mathbf{E}$ becomes:\n    $$ \\mathbf{E} = -\\mathbf{u} \\times \\mathbf{B} + \\eta_m (\\nabla \\times \\mathbf{B}) $$\n\n4.  **Equate Expressions for E**: We equate this with the potential definition $\\mathbf{E} = -\\partial_t \\mathbf{A} - \\nabla \\phi$:\n    $$ -\\partial_t \\mathbf{A} - \\nabla \\phi = -\\mathbf{u} \\times \\mathbf{B} + \\eta_m (\\nabla \\times \\mathbf{B}) $$\n\n5.  **Isolate $\\partial_t \\mathbf{A}$**:\n    $$ \\partial_t \\mathbf{A} = \\mathbf{u} \\times \\mathbf{B} - \\eta_m (\\nabla \\times \\mathbf{B}) - \\nabla \\phi $$\n\n6.  **Substitute Potentials and Apply Gauge**: Replace all fields with their potential representations ($\\mathbf{B} = \\nabla \\times \\mathbf{A}$) and use the vector identity $\\nabla \\times (\\nabla \\times \\mathbf{A}) = \\nabla(\\nabla \\cdot \\mathbf{A}) - \\nabla^2 \\mathbf{A}$:\n    $$ \\partial_t \\mathbf{A} = \\mathbf{u} \\times (\\nabla \\times \\mathbf{A}) - \\eta_m (\\nabla(\\nabla \\cdot \\mathbf{A}) - \\nabla^2 \\mathbf{A}) - \\nabla \\phi $$\n    Adopting the Coulomb gauge, $\\nabla \\cdot \\mathbf{A} = 0$, simplifies the equation:\n    $$ \\partial_t \\mathbf{A} = \\mathbf{u} \\times (\\nabla \\times \\mathbf{A}) + \\eta_m \\nabla^2 \\mathbf{A} - \\nabla \\phi $$\n    This is the equation presented in option A.\n\n### Analysis of Options\n\n*   **A. Correct.** The derived equation matches perfectly. The justification regarding numerical stiffness is also correct. The Coulomb gauge results in an advection-diffusion-reaction equation for $\\mathbf{A}$ coupled to a Poisson (elliptic) equation for $\\phi$, which is computationally well-behaved for low-frequency (MQS) problems. It avoids the high-speed wave propagation associated with the speed of light, which would be introduced by a Lorenz-type gauge and would impose severe time-step constraints on explicit solvers.\n\n*   **B. Incorrect.** The sign of the diffusion term is wrong (it should be positive), and the definition of magnetic diffusivity is incorrect ($\\eta_m = 1/(\\mu_0 \\sigma)$, not $\\mu_0/\\sigma$). Furthermore, the Lorenz gauge makes the system hyperbolic (wave-like), not \"purely parabolic,\" and is generally a poor choice for MQS problems due to stiffness.\n\n*   **C. Incorrect.** The sign of the advection term is wrong. Using the Weyl gauge ($\\phi=0$) without enforcing any divergence constraint ($\\nabla \\cdot \\mathbf{A}=0$) is numerically unstable and unphysical, as it allows divergence errors to grow unchecked.\n\n*   **D. Incorrect.** The diffusion term has an incorrect prefactor ($1/\\sigma$ instead of $\\eta_m=1/(\\mu_0\\sigma)$) and a wrong sign relative to the Laplacian form. The claim that the Lorenz gauge is preferable in MQS is false; the Coulomb gauge is standard specifically to *avoid* the stiffness issues the Lorenz gauge creates in this regime.\n\nTherefore, option A is the only one that is entirely correct in both its mathematical formulation and its physical/numerical justification.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "While using a vector potential can help, no numerical method is perfect, and discretization errors will inevitably introduce a non-zero magnetic divergence. This spurious divergence can lead to unphysical forces and catastrophic instabilities, so it must be actively controlled. This practice  introduces a robust technique known as hyperbolic-parabolic divergence cleaning, which corrects these errors by augmenting the MHD equations to transport and damp the divergence. You will derive the governing equation for the divergence error and implement a numerical analysis to see how the cleaning mechanism performs and how it is affected by grid discretization.",
            "id": "3513686",
            "problem": "You are tasked with proposing, deriving, and numerically analyzing a divergence-cleaning mechanism for magnetohydrodynamics (MHD) within a multiphysics coupled simulation context. The mechanism should be of the hyperbolic–parabolic type and should address how divergence errors in the magnetic field arising from spatial discretization propagate and decay. Your derivation and computations must begin from a valid fundamental base consisting of core definitions and well-tested formulas, including the magnetic induction equation, the divergence-free constraint, the Lorentz force, and mathematically consistent augmentation for divergence cleaning. No shortcut formulas may appear in the problem statement; your reasoning must proceed from first principles.\n\nFundamental base to use:\n- Magnetohydrodynamics (MHD) couples the dynamics of a conducting fluid to electromagnetic fields. The magnetic induction equation arises from Faraday’s law and a constitutive relation for the electric field, while the momentum equation includes the Lorentz force as a source term. The divergence-free constraint imposes $\\,\\nabla \\cdot \\mathbf{B} = 0\\,$ for the magnetic field $\\,\\mathbf{B}\\,$.\n- Consider introducing a generalized Lagrange multiplier (GLM) scalar field $\\,\\psi\\,$ to augment the induction equation so that divergence errors $\\,\\delta = \\nabla \\cdot \\mathbf{B}\\,$ are both transported and damped. Work in a context where flow advection and resistive effects are neglected temporarily to isolate divergence-cleaning dynamics, but maintain scientific consistency with MHD.\n\nYour tasks:\n1. Propose a hyperbolic–parabolic divergence-cleaning augmentation that introduces a scalar field $\\,\\psi\\,$ so that divergence errors $\\,\\delta = \\nabla \\cdot \\mathbf{B}\\,$ are both transported and damped in time. The augmentation must be mathematically consistent with the induction equation and the divergence constraint and must be physically meaningful for a conducting fluid. Define the hyperbolic cleaning speed $\\,c_h\\,$ (in $\\mathrm{m/s}$) and the parabolic damping coefficient $\\,\\sigma\\,$ (in $\\mathrm{s^{-1}}$), and explain their roles.\n2. Starting from the augmented system and the divergence constraint, derive a closed-form evolution equation for the divergence error field $\\,\\delta(\\mathbf{x},t)\\,$ that demonstrates how divergence errors propagate and damp. Then argue for the existence of normal-mode solutions of the form $\\,\\delta(x,t) = \\hat{\\delta}\\,e^{i k x}\\,e^{-\\omega t}\\,$ on a one-dimensional domain, with wavenumber $\\,k\\,$ (in $\\mathrm{rad/m}$) and complex rate $\\,\\omega\\,$ (in $\\mathrm{s^{-1}}$). Use only the fundamental base and mathematically correct manipulations to arrive at the appropriate dispersion relation for $\\,\\omega\\,$ as a function of $\\,k\\,$, $\\,c_h\\,$, and $\\,\\sigma\\,$. Do not introduce shortcut formulas or results not derived from the base.\n3. Consider a second-order central-difference spatial discretization of the Laplacian on a uniform one-dimensional grid with spacing $\\,\\Delta x\\,$ (in $\\mathrm{m}$) and periodic boundary conditions. Show how the discrete spatial operator modifies the wavenumber response of the divergence-error evolution compared to the continuous case, and derive the corresponding discrete dispersion relation for $\\,\\omega\\,$. All trigonometric arguments must use radians.\n4. Design and implement a program to compute, for each specified test case, the following quantities in $\\mathrm{s^{-1}}$:\n   - The two branches of the continuous normal-mode rates $\\,\\omega_-(k)\\,$ and $\\,\\omega_+(k)\\,$, reported as their real and imaginary parts.\n   - The two branches of the discrete normal-mode rates $\\,\\omega_-^{\\mathrm{disc}}(k,\\Delta x)\\,$ and $\\,\\omega_+^{\\mathrm{disc}}(k,\\Delta x)\\,$, reported as their real and imaginary parts.\n   All angles are in radians, and all rates must be expressed in $\\mathrm{s^{-1}}$. The imaginary part represents oscillation frequency, while the real part represents damping rate.\n5. Interpret, through the computed values, how discretization modifies propagation speed and damping relative to the continuous model, especially near the grid Nyquist wavenumber.\n\nTest suite:\nProvide computations for the following parameter sets, each given as a tuple $\\,\\left(c_h,\\,\\sigma,\\,\\Delta x,\\,k\\right)\\,$, with $\\,c_h\\,$ in $\\mathrm{m/s}$, $\\,\\sigma\\,$ in $\\mathrm{s^{-1}}$, $\\,\\Delta x\\,$ in $\\mathrm{m}$, and $\\,k\\,$ in $\\mathrm{rad/m}$:\n- Case A (happy path, oscillatory regime): $\\,\\left(1.0 \\times 10^{3},\\,5.0 \\times 10^{1},\\,1.0 \\times 10^{-2},\\,1.0 \\times 10^{2}\\right)\\,$.\n- Case B (boundary condition, zero wavenumber): $\\,\\left(5.0 \\times 10^{2},\\,2.0 \\times 10^{1},\\,1.0 \\times 10^{-1},\\,0\\right)\\,$.\n- Case C (critical damping in the continuous model): $\\,\\left(2,\\,4,\\,1.0 \\times 10^{-1},\\,1\\right)\\,$.\n- Case D (edge case near the discrete Nyquist wavenumber): $\\,\\left(1.0 \\times 10^{1},\\,3.0 \\times 10^{1},\\,5.0 \\times 10^{-2},\\,\\pi / \\Delta x\\right)\\,$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated Python-style list, where each element corresponds to one test case and is itself a list of eight floats in the following order:\n$\\,\\left[\\Re\\omega_-,\\,\\Im\\omega_-,\\,\\Re\\omega_+,\\,\\Im\\omega_+,\\,\\Re\\omega_-^{\\mathrm{disc}},\\,\\Im\\omega_-^{\\mathrm{disc}},\\,\\Re\\omega_+^{\\mathrm{disc}},\\,\\Im\\omega_+^{\\mathrm{disc}}\\right]\\,$.\nFor instance, the output should look like $\\,\\left[\\left[\\dots\\right],\\left[\\dots\\right],\\left[\\dots\\right],\\left[\\dots\\right]\\right]\\,$ with all numeric entries in $\\mathrm{s^{-1}}$ and angles in radians.",
            "solution": "The user-provided problem statement is valid. It is scientifically grounded in the principles of computational magnetohydrodynamics (MHD), is well-posed with a clear objective and sufficient data, and is expressed in objective, formal language. The problem asks for the derivation and analysis of a standard hyperbolic-parabolic divergence-cleaning mechanism (the Generalized Lagrange Multiplier or GLM method), which is a canonical topic in the field. All conditions for a valid problem are met.\n\nHere is the complete, reasoned solution.\n\n### Part 1: Proposed Augmented System for Divergence Cleaning\n\nThe fundamental challenge in the numerical simulation of MHD is to maintain the divergence-free constraint, $\\nabla \\cdot \\mathbf{B} = 0$. Discretization errors inevitably introduce a non-zero divergence, $\\delta = \\nabla \\cdot \\mathbf{B} \\neq 0$, which can lead to unphysical forces and numerical instability. The hyperbolic-parabolic Generalized Lagrange Multiplier (GLM) method addresses this by augmenting the MHD equations. We introduce a scalar field $\\psi$ that couples to the divergence error.\n\nTo isolate the dynamics of the cleaning mechanism, we consider a simplified context where fluid velocity and magnetic resistivity are neglected. The standard induction equation, $\\partial \\mathbf{B} / \\partial t = \\mathbf{0}$, is augmented. The proposed system consists of a modified induction equation and a new evolution equation for $\\psi$:\n$$\n\\frac{\\partial \\mathbf{B}}{\\partial t} + \\nabla \\psi = \\mathbf{0}\n$$\n$$\n\\frac{\\partial \\psi}{\\partial t} + c_h^2 (\\nabla \\cdot \\mathbf{B}) = -\\sigma \\psi\n$$\nHere, $\\mathbf{B}(\\mathbf{x}, t)$ is the magnetic field, and $\\psi(\\mathbf{x}, t)$ is the auxiliary scalar field. The system introduces two parameters:\n1.  $c_h$: The hyperbolic cleaning speed, with units of $\\mathrm{m/s}$. This parameter determines the characteristic speed at which divergence errors $\\delta$ are propagated away from their source as waves. A larger $c_h$ leads to faster transport of these errors.\n2.  $\\sigma$: The parabolic damping coefficient, with units of $\\mathrm{s^{-1}}$. This parameter introduces a dissipative term, causing the amplitudes of both the divergence error $\\delta$ and the auxiliary field $\\psi$ to decay exponentially in time.\n\nThe combination of a hyperbolic transport term (involving $c_h$) and a parabolic damping term (involving $\\sigma$) ensures that divergence errors are actively removed from the computational domain.\n\n### Part 2: Derivation of the Continuous Divergence Error Evolution\n\nTo understand how the divergence error $\\delta = \\nabla \\cdot \\mathbf{B}$ evolves under this augmented system, we seek a single, closed-form equation for $\\delta$.\n\nFirst, take the divergence of the augmented induction equation:\n$$\n\\nabla \\cdot \\left( \\frac{\\partial \\mathbf{B}}{\\partial t} \\right) + \\nabla \\cdot (\\nabla \\psi) = 0\n$$\nAssuming sufficient smoothness of $\\mathbf{B}$, we can commute the spatial and temporal derivatives. Also, by definition, $\\delta = \\nabla \\cdot \\mathbf{B}$ and $\\nabla \\cdot (\\nabla \\psi) = \\nabla^2 \\psi$. This gives:\n$$\n\\frac{\\partial (\\nabla \\cdot \\mathbf{B})}{\\partial t} + \\nabla^2 \\psi = 0 \\implies \\frac{\\partial \\delta}{\\partial t} + \\nabla^2 \\psi = 0\n\\quad \\quad (1)\n$$\nNext, take the time derivative of the evolution equation for $\\psi$:\n$$\n\\frac{\\partial^2 \\psi}{\\partial t^2} + c_h^2 \\frac{\\partial (\\nabla \\cdot \\mathbf{B})}{\\partial t} = -\\sigma \\frac{\\partial \\psi}{\\partial t}\n$$\nSubstituting $\\delta = \\nabla \\cdot \\mathbf{B}$, we get:\n$$\n\\frac{\\partial^2 \\psi}{\\partial t^2} + c_h^2 \\frac{\\partial \\delta}{\\partial t} = -\\sigma \\frac{\\partial \\psi}{\\partial t}\n\\quad \\quad (2)\n$$\nWe now have a system of two equations for $\\delta$ and $\\psi$. To eliminate $\\psi$, we can use equation (1) to express terms involving $\\psi$ in terms of $\\delta$. From (1), we have $\\nabla^2 \\psi = -\\partial \\delta / \\partial t$. Differentiating equation (1) with respect to time gives $\\partial^2 \\delta / \\partial t^2 = -\\nabla^2 (\\partial \\psi / \\partial t)$. To use this, we solve the original $\\psi$ evolution equation for $\\partial \\psi / \\partial t$: $\\partial \\psi / \\partial t = -c_h^2 \\delta - \\sigma \\psi$. However, it is more direct to operate on (2).\n\nApply the Laplacian operator $\\nabla^2$ to the original $\\psi$ evolution equation:\n$$\n\\nabla^2 \\left(\\frac{\\partial \\psi}{\\partial t}\\right) + c_h^2 \\nabla^2 \\delta = -\\sigma \\nabla^2 \\psi\n$$\nCommuting derivatives, this becomes:\n$$\n\\frac{\\partial}{\\partial t}(\\nabla^2 \\psi) + c_h^2 \\nabla^2 \\delta = -\\sigma \\nabla^2 \\psi\n$$\nNow, substitute $\\nabla^2 \\psi = -\\partial \\delta / \\partial t$ from equation (1) into this expression:\n$$\n\\frac{\\partial}{\\partial t}\\left(-\\frac{\\partial \\delta}{\\partial t}\\right) + c_h^2 \\nabla^2 \\delta = -\\sigma \\left(-\\frac{\\partial \\delta}{\\partial t}\\right)\n$$\nThis simplifies to the final evolution equation for the divergence error $\\delta$:\n$$\n\\frac{\\partial^2 \\delta}{\\partial t^2} + \\sigma \\frac{\\partial \\delta}{\\partial t} - c_h^2 \\nabla^2 \\delta = 0\n$$\nThis is a damped wave equation, also known as the telegrapher's equation. It shows that divergence errors propagate with speed $c_h$ while their amplitude is damped by the term proportional to $\\sigma$.\n\nTo find the dispersion relation, we analyze normal-mode solutions in one dimension, $\\delta(x, t) = \\hat{\\delta} e^{i k x} e^{-\\omega t}$, where $k$ is the wavenumber and $\\omega$ is the complex rate. Plugging this into the equation:\n- $\\partial^2 \\delta / \\partial t^2 = (-\\omega)^2 \\delta = \\omega^2 \\delta$\n- $\\partial \\delta / \\partial t = -\\omega \\delta$\n- $\\nabla^2 \\delta = \\partial^2 \\delta / \\partial x^2 = (ik)^2 \\delta = -k^2 \\delta$\n\nSubstituting these into the evolution equation yields:\n$$\n\\omega^2 \\delta - \\sigma \\omega \\delta - c_h^2 (-k^2 \\delta) = 0\n$$\nDividing by $\\delta$ (for a non-trivial solution), we obtain the algebraic equation for $\\omega$:\n$$\n\\omega^2 - \\sigma \\omega + c_h^2 k^2 = 0\n$$\nThis is a quadratic equation for $\\omega$. The roots, which form the continuous dispersion relation, are given by the quadratic formula:\n$$\n\\omega_{\\pm}(k) = \\frac{\\sigma \\pm \\sqrt{\\sigma^2 - 4 c_h^2 k^2}}{2}\n$$\nThe real part of $\\omega$ is the damping rate, and the imaginary part is the oscillation frequency.\n\n### Part 3: Derivation of the Discrete Dispersion Relation\n\nWhen the system is solved numerically on a uniform grid with spacing $\\Delta x$, the continuous spatial derivatives are replaced by finite difference approximations. The second-order central difference approximation for the 1D Laplacian $\\nabla^2 = \\partial^2/\\partial x^2$ is:\n$$\n\\nabla^2 \\delta(x) \\approx \\frac{\\delta(x+\\Delta x) - 2\\delta(x) + \\delta(x-\\Delta x)}{(\\Delta x)^2}\n$$\nApplying this discrete operator to the normal mode $e^{ikx}$ gives:\n$$\n\\frac{e^{ik(x+\\Delta x)} - 2e^{ikx} + e^{ik(x-\\Delta x)}}{(\\Delta x)^2} = \\frac{e^{ikx} (e^{ik\\Delta x} - 2 + e^{-ik\\Delta x})}{(\\Delta x)^2}\n$$\nUsing the identity $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$, this becomes:\n$$\ne^{ikx} \\frac{2\\cos(k\\Delta x) - 2}{(\\Delta x)^2} = -e^{ikx} \\frac{2(1 - \\cos(k\\Delta x))}{(\\Delta x)^2}\n$$\nUsing the half-angle identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$, we get:\n$$\n-e^{ikx} \\frac{4}{(\\Delta x)^2} \\sin^2\\left(\\frac{k\\Delta x}{2}\\right)\n$$\nThus, the discrete Laplacian operator acting on the mode $e^{ikx}$ is equivalent to multiplication by $-k_{\\mathrm{eff}}^2$, where the effective wavenumber squared is:\n$$\nk_{\\mathrm{eff}}^2 = \\frac{4}{(\\Delta x)^2} \\sin^2\\left(\\frac{k\\Delta x}{2}\\right)\n$$\nTo find the discrete dispersion relation, we replace $k^2$ in the continuous relation's quadratic equation with $k_{\\mathrm{eff}}^2$:\n$$\n\\omega^2 - \\sigma \\omega + c_h^2 k_{\\mathrm{eff}}^2 = 0\n$$\nThe roots give the discrete dispersion relation:\n$$\n\\omega_{\\pm}^{\\mathrm{disc}}(k, \\Delta x) = \\frac{\\sigma \\pm \\sqrt{\\sigma^2 - 4 c_h^2 k_{\\mathrm{eff}}^2}}{2} = \\frac{\\sigma \\pm \\sqrt{\\sigma^2 - 4 c_h^2 \\frac{4}{(\\Delta x)^2} \\sin^2\\left(\\frac{k\\Delta x}{2}\\right)}}{2}\n$$\n\n### Part 5: Interpretation of Discretization Effects\n\nThe derived relations for $\\omega(k)$ and $\\omega^{\\mathrm{disc}}(k, \\Delta x)$ allow for a direct comparison between the continuous model and its discrete counterpart.\n\n1.  **Numerical Dispersion**: The phase velocity of the divergence waves is altered by discretization. For long wavelengths ($k\\Delta x \\ll 1$), we have $\\sin(k\\Delta x/2) \\approx k\\Delta x/2$, which makes $k_{\\mathrm{eff}}^2 \\approx k^2$. In this limit, the discrete model accurately reproduces the continuous behavior. However, for shorter wavelengths (larger $k$), $k_{\\mathrm{eff}}$ is always less than $k$. This phenomenon is known as numerical dispersion. The wave propagation speed in the discrete system, which is proportional to $k_{\\mathrm{eff}}$, is lower than in the continuous system. At the Nyquist wavenumber, $k = \\pi/\\Delta x$, the effective wavenumber is $k_{\\mathrm{eff}} = 2/\\Delta x = (2/\\pi)k$. The propagation speed is reduced to approximately $64\\%$ of the continuous speed.\n\n2.  **Damping Behavior**: Discretization can also alter the damping regime. The transition between oscillatory (complex $\\omega$) and overdamped (real $\\omega$) behavior occurs when the discriminant is zero. In the continuous case, this is $\\sigma^2 = 4c_h^2 k^2$. In the discrete case, it is $\\sigma^2 = 4c_h^2 k_{\\mathrm{eff}}^2$. Since $k_{\\mathrm{eff}}^2 \\le k^2$, a mode that is oscillatory in the continuous model might become overdamped or critically damped in the discrete model. For instance, if a mode is critically damped in the continuous model ($\\sigma^2=4c_h^2k^2$), its discrete counterpart will be overdamped, as $4c_h^2k_{\\mathrm{eff}}^2 < \\sigma^2$. This is observed in Test Case C. Conversely, in the oscillatory regime, the damping rate for both continuous and discrete models is $\\Re(\\omega) = \\sigma/2$, which is independent of the wavenumber, so the rate of amplitude decay is unaffected by the numerical dispersion as long as the system remains oscillatory.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the continuous and discrete normal-mode rates for the\n    hyperbolic-parabolic divergence-cleaning mechanism in MHD.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (c_h, sigma, delta_x, k)\n    test_cases = [\n        # Case A: Happy path, oscillatory regime\n        (1.0e3, 5.0e1, 1.0e-2, 1.0e2),\n        # Case B: Boundary condition, zero wavenumber\n        (5.0e2, 2.0e1, 1.0e-1, 0.0),\n        # Case C: Critical damping in the continuous model\n        (2.0, 4.0, 1.0e-1, 1.0),\n        # Case D: Edge case near the discrete Nyquist wavenumber\n        (1.0e1, 3.0e1, 5.0e-2, np.pi / 5.0e-2),\n    ]\n\n    results = []\n    for case in test_cases:\n        ch, sigma, dx, k = case\n        \n        # --- Continuous Case ---\n        # The dispersion relation is ω² - σω + (ch*k)² = 0\n        # Roots are ω = [σ ± sqrt(σ² - 4(ch*k)²)] / 2\n        discriminant_cont = sigma**2 - 4 * ch**2 * k**2\n        \n        if discriminant_cont >= 0:\n            sqrt_disc_cont = np.sqrt(discriminant_cont)\n            omega_minus_cont_val = (sigma - sqrt_disc_cont) / 2.0\n            omega_plus_cont_val = (sigma + sqrt_disc_cont) / 2.0\n        else:\n            sqrt_disc_cont = np.sqrt(-discriminant_cont)\n            # The roots are complex conjugates\n            real_part = sigma / 2.0\n            imag_part = sqrt_disc_cont / 2.0\n            omega_minus_cont_val = complex(real_part, -imag_part)\n            omega_plus_cont_val = complex(real_part, imag_part)\n\n        # --- Discrete Case ---\n        # We replace k² with k_eff² = (4/dx²) * sin²(k*dx/2)\n        # The dispersion relation is ω² - σω + (ch*k_eff)² = 0\n        if dx == 0: # Avoid division by zero, though not in test cases\n             k_eff_sq = k**2\n        else:\n            k_eff_sq = (4.0 / dx**2) * (np.sin(k * dx / 2.0))**2\n\n        discriminant_disc = sigma**2 - 4 * ch**2 * k_eff_sq\n        \n        if discriminant_disc >= 0:\n            sqrt_disc_disc = np.sqrt(discriminant_disc)\n            omega_minus_disc_val = (sigma - sqrt_disc_disc) / 2.0\n            omega_plus_disc_val = (sigma + sqrt_disc_disc) / 2.0\n        else:\n            sqrt_disc_disc = np.sqrt(-discriminant_disc)\n            real_part = sigma / 2.0\n            imag_part = sqrt_disc_disc / 2.0\n            omega_minus_disc_val = complex(real_part, -imag_part)\n            omega_plus_disc_val = complex(real_part, imag_part)\n\n        # Append the 8 required float values for the current test case.\n        # Order: Re(ω-), Im(ω-), Re(ω+), Im(ω+), Re(ω_disc-), Im(ω_disc-), Re(ω_disc+), Im(ω_disc+)\n        case_results = [\n            float(np.real(omega_minus_cont_val)),\n            float(np.imag(omega_minus_cont_val)),\n            float(np.real(omega_plus_cont_val)),\n            float(np.imag(omega_plus_cont_val)),\n            float(np.real(omega_minus_disc_val)),\n            float(np.imag(omega_minus_disc_val)),\n            float(np.real(omega_plus_disc_val)),\n            float(np.imag(omega_plus_disc_val)),\n        ]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The format is a Python-style list of lists.\n    list_of_lists_str = \"[\" + \",\".join(str(res) for res in results) + \"]\"\n    print(list_of_lists_str)\n\nsolve()\n```"
        },
        {
            "introduction": "A cornerstone of verifying any MHD code is to test its ability to correctly simulate the propagation of fundamental waves: the Alfvén wave and the fast and slow magnetosonic waves. Numerical discretization on a grid inevitably introduces errors in wave speed and direction, a phenomenon known as numerical dispersion and anisotropy. This exercise  provides a framework for quantifying these phase errors by comparing the numerical dispersion relation of finite difference schemes with the exact analytical solution. This analysis is essential for understanding the limitations of a simulation and for making informed choices about grid resolution and numerical methods.",
            "id": "3343359",
            "problem": "Consider the linearized, inviscid, perfectly conducting, compressible Ideal Magnetohydrodynamics (MHD) system for a homogeneous equilibrium with uniform mass density $ \\rho_0 $, pressure $ p_0 $, and background magnetic field vector $ \\mathbf{B}_0 $. Let the ratio of specific heats be $ \\gamma $ and the magnetic permeability of free space be $ \\mu_0 $. Under a plane-wave ansatz with physical wavevector $ \\mathbf{k} $ and angular frequency $ \\omega $, the continuous phase speeds for Alfvén and magnetosonic waves are defined in terms of the Alfvén speed $ V_A = \\|\\mathbf{B}_0\\| / \\sqrt{\\mu_0 \\rho_0} $ and the adiabatic sound speed $ c_s = \\sqrt{\\gamma p_0 / \\rho_0} $. For the angle $ \\theta $ between $ \\mathbf{k} $ and $ \\mathbf{B}_0 $, the continuous phase speeds along the physical wavevector direction are:\n- Alfvén wave: $ c_A^{\\text{exact}} = V_A \\cos \\theta $,\n- Fast and slow magnetosonic waves: \n$$\nc_{f,s}^{\\text{exact}} = \\sqrt{ \\tfrac{1}{2} \\left( V_A^2 + c_s^2 \\pm \\sqrt{(V_A^2 + c_s^2)^2 - 4 V_A^2 c_s^2 \\cos^2 \\theta} \\right) }.\n$$\n\nIn a semi-discrete spatial discretization on a Cartesian grid, numerical dispersion and anisotropy arise because discrete differential operators do not reproduce the continuous gradient operator $ \\nabla $ exactly. For a plane wave $ e^{i \\mathbf{k} \\cdot \\mathbf{x}} $ on a grid with spacings $ (\\Delta x, \\Delta y, \\Delta z) $, replacing the continuous symbol $ i \\mathbf{k} $ by a discrete symbol $ i \\tilde{\\mathbf{k}} $, each component $ \\tilde{k}_j $ (for $ j \\in \\{x,y,z\\} $) is given by:\n- Second-order central difference (CD2): $ \\tilde{k}_j = \\dfrac{\\sin(k_j \\Delta_j)}{\\Delta_j} $,\n- Fourth-order central difference (CD4): $ \\tilde{k}_j = \\dfrac{8 \\sin(k_j \\Delta_j) - \\sin(2 k_j \\Delta_j)}{12 \\Delta_j} $.\n\nDefine $ \\hat{\\mathbf{b}} = \\mathbf{B}_0 / \\|\\mathbf{B}_0\\| $, the exact wavevector magnitude $ \\|\\mathbf{k}\\| $, and the discrete wavevector magnitude $ \\|\\tilde{\\mathbf{k}}\\| $. Let $ \\theta_{\\text{exact}} $ be the angle between $ \\mathbf{k} $ and $ \\mathbf{B}_0 $, and $ \\theta_{\\text{num}} $ be the angle between $ \\tilde{\\mathbf{k}} $ and $ \\mathbf{B}_0 $. The semi-discrete angular frequency for the Alfvén wave is $ \\omega_A^{\\text{num}} = V_A (\\hat{\\mathbf{b}} \\cdot \\tilde{\\mathbf{k}}) $, yielding a numerical phase speed along the physical wavevector direction $ c_A^{\\text{num}} = \\omega_A^{\\text{num}} / \\|\\mathbf{k}\\| $. For the magnetosonic waves, the semi-discrete angular frequency is $ \\omega_{f,s}^{\\text{num}} = c_{f,s}(\\theta_{\\text{num}}) \\, \\|\\tilde{\\mathbf{k}}\\| $, where $ c_{f,s}(\\theta) $ is the same functional form as above but evaluated at $ \\theta_{\\text{num}} $. The numerical phase speeds along the physical wavevector direction are $ c_{f,s}^{\\text{num}} = \\omega_{f,s}^{\\text{num}} / \\|\\mathbf{k}\\| $.\n\nDefine a normalization speed $ c_{\\text{ref}} = \\max(V_A, c_s) $. The normalized phase speed errors to be reported are:\n$$\n\\varepsilon_A = \\frac{c_A^{\\text{num}} - c_A^{\\text{exact}}}{c_{\\text{ref}}}, \\quad\n\\varepsilon_f = \\frac{c_f^{\\text{num}} - c_f^{\\text{exact}}}{c_{\\text{ref}}}, \\quad\n\\varepsilon_s = \\frac{c_s^{\\text{num}} - c_s^{\\text{exact}}}{c_{\\text{ref}}}.\n$$\nThese errors are dimensionless. No physical units are required in the final results.\n\nYour task is to implement a program that, for the following test suite, computes $ (\\varepsilon_A, \\varepsilon_f, \\varepsilon_s) $ for each case. Use $ \\mu_0 = 4 \\pi \\times 10^{-7} $ in SI units. Angles are specified via components of $ \\mathbf{k} $ and $ \\mathbf{B}_0 $ directly; do not convert units.\n\nTest suite (each case is a tuple of parameters $ (\\rho_0, p_0, \\gamma, \\mathbf{B}_0, \\mathbf{k}, \\Delta x, \\Delta y, \\Delta z, \\text{scheme}) $):\n1. $ (1.0, 1.0 \\times 10^5, 5/3, (0.5, 0.0, 0.0), (80 \\cos 35^\\circ, 80 \\sin 35^\\circ, 0.0), 0.02, 0.02, 0.02, \\text{CD2}) $,\n2. $ (1.0, 1.0 \\times 10^5, 5/3, (0.5, 0.0, 0.0), (80 \\cos 35^\\circ, 80 \\sin 35^\\circ, 0.0), 0.02, 0.02, 0.02, \\text{CD4}) $,\n3. $ (1.0, 1.0 \\times 10^5, 5/3, (0.5, 0.0, 0.0), (10 \\cos 60^\\circ, 10 \\sin 60^\\circ, 0.0), 0.02, 0.02, 0.02, \\text{CD2}) $,\n4. $ (1.0, 1.0 \\times 10^5, 5/3, (0.5, 0.0, 0.0), (10 \\cos 60^\\circ, 10 \\sin 60^\\circ, 0.0), 0.02, 0.02, 0.02, \\text{CD4}) $,\n5. $ (1.0, 1.0 \\times 10^5, 5/3, (0.5, 0.0, 0.0), (50 \\cos 60^\\circ, 50 \\sin 60^\\circ, 0.0), 0.05, 0.02, 0.02, \\text{CD2}) $,\n6. $ (1.0, 1.0 \\times 10^5, 5/3, (0.5, 0.0, 0.0), (50 \\cos 60^\\circ, 50 \\sin 60^\\circ, 0.0), 0.05, 0.02, 0.02, \\text{CD4}) $,\n7. $ (1.0, 1.0 \\times 10^5, 5/3, (0.5/\\sqrt{2}, 0.5/\\sqrt{2}, 0.0), (70 \\cos 25^\\circ \\cos 30^\\circ, 70 \\cos 25^\\circ \\sin 30^\\circ, 70 \\sin 25^\\circ), 0.03, 0.02, 0.025, \\text{CD2}) $,\n8. $ (1.0, 1.0 \\times 10^5, 5/3, (0.5/\\sqrt{2}, 0.5/\\sqrt{2}, 0.0), (70 \\cos 25^\\circ \\cos 30^\\circ, 70 \\cos 25^\\circ \\sin 30^\\circ, 70 \\sin 25^\\circ), 0.03, 0.02, 0.025, \\text{CD4}) $.\n\nFor each case, compute $ \\varepsilon_A $, $ \\varepsilon_f $, and $ \\varepsilon_s $ as defined above. Your program should produce a single line of output containing the results as a comma-separated list of lists, where each inner list corresponds to one test case and contains three floating-point numbers $ [\\varepsilon_A, \\varepsilon_f, \\varepsilon_s] $. For example:\n$ [[e_{A,1}, e_{f,1}, e_{s,1}], [e_{A,2}, e_{f,2}, e_{s,2}], \\ldots, [e_{A,8}, e_{f,8}, e_{s,8}]] $.",
            "solution": "The user's request is to solve a problem in computational magnetohydrodynamics (MHD) by calculating the numerical dispersion error for MHD waves.\n\n### Step 1: Problem Validation\n\n**Extraction of Givens:**\n-   **Physical System:** Linearized, inviscid, perfectly conducting, compressible Ideal MHD.\n-   **Equilibrium State:** Homogeneous medium with uniform density $ \\rho_0 $, pressure $ p_0 $, and magnetic field $ \\mathbf{B}_0 $.\n-   **Constants:** Ratio of specific heats $ \\gamma $, vacuum permeability $ \\mu_0 = 4 \\pi \\times 10^{-7} $ SI units.\n-   **Fundamental Speeds:** Alfvén speed $ V_A = \\|\\mathbf{B}_0\\| / \\sqrt{\\mu_0 \\rho_0} $ and sound speed $ c_s = \\sqrt{\\gamma p_0 / \\rho_0} $.\n-   **Exact Phase Speeds:** For a plane wave with wavevector $ \\mathbf{k} $ at an angle $ \\theta $ to $ \\mathbf{B}_0 $:\n    -   Alfvén: $ c_A^{\\text{exact}} = V_A \\cos \\theta $.\n    -   Fast/Slow Magnetosonic: $ c_{f,s}^{\\text{exact}} = \\sqrt{ \\tfrac{1}{2} \\left( V_A^2 + c_s^2 \\pm \\sqrt{(V_A^2 + c_s^2)^2 - 4 V_A^2 c_s^2 \\cos^2 \\theta} \\right) } $.\n-   **Numerical Discretization:** On a Cartesian grid with spacings $ (\\Delta x, \\Delta y, \\Delta z) $, the continuous differentiation symbol $ i \\mathbf{k} $ is replaced by a discrete symbol $ i \\tilde{\\mathbf{k}} $.\n-   **Discrete Wavevector $ \\tilde{\\mathbf{k}} $ Components:** For each component $ j \\in \\{x,y,z\\} $:\n    -   CD2 (2nd-order central): $ \\tilde{k}_j = \\dfrac{\\sin(k_j \\Delta_j)}{\\Delta_j} $.\n    -   CD4 (4th-order central): $ \\tilde{k}_j = \\dfrac{8 \\sin(k_j \\Delta_j) - \\sin(2 k_j \\Delta_j)}{12 \\Delta_j} $.\n-   **Numerical Phase Speeds:** Defined as $ c^{\\text{num}} = \\omega^{\\text{num}} / \\|\\mathbf{k}\\| $, where $ \\omega^{\\text{num}} $ is the semi-discrete angular frequency.\n    -   Alfvén: $ \\omega_A^{\\text{num}} = V_A (\\hat{\\mathbf{b}} \\cdot \\tilde{\\mathbf{k}}) $, where $ \\hat{\\mathbf{b}} = \\mathbf{B}_0 / \\|\\mathbf{B}_0\\| $.\n    -   Magnetosonic: $ \\omega_{f,s}^{\\text{num}} = c_{f,s}(\\theta_{\\text{num}}) \\, \\|\\tilde{\\mathbf{k}}\\| $, where $ c_{f,s}(\\theta_{\\text{num}}) $ is the exact speed function evaluated at $ \\theta_{\\text{num}} $, the angle between $ \\tilde{\\mathbf{k}} $ and $ \\mathbf{B}_0 $.\n-   **Error Metrics:** Normalized errors $ \\varepsilon_A = \\frac{c_A^{\\text{num}} - c_A^{\\text{exact}}}{c_{\\text{ref}}} $, $ \\varepsilon_f = \\frac{c_f^{\\text{num}} - c_f^{\\text{exact}}}{c_{\\text{ref}}} $, $ \\varepsilon_s = \\frac{c_s^{\\text{num}} - c_s^{\\text{exact}}}{c_{\\text{ref}}} $, with $ c_{\\text{ref}} = \\max(V_A, c_s) $.\n-   **Task:** Compute the error triplet $ (\\varepsilon_A, \\varepsilon_f, \\varepsilon_s) $ for a provided suite of 8 test cases.\n\n**Validation Verdict:**\nThe problem is **valid**.\n1.  **Scientifically Grounded:** The problem is based on the standard dispersion relation of MHD waves and its numerical counterpart resulting from finite difference methods. These are core concepts in computational plasma physics and fluid dynamics.\n2.  **Well-Posed:** All required constants, parameters, and formulas are provided. The inputs for each test case are complete, and the required outputs are unambiguously defined, leading to a unique solution.\n3.  **Objective:** The problem statement is entirely quantitative and expressed in precise mathematical language.\nThe problem is self-contained, computationally feasible, and free from any of the invalidating flaws listed in the instructions. The formula provided for the \"CD4\" scheme, while containing a denominator of $ 12 \\Delta_j $ instead of the more standard $ 6 \\Delta_j $, is mathematically well-defined and must be implemented as stated. This does not constitute a flaw but a specific instruction for the problem's context.\n\n### Step 2: Solution Design\n\nThe solution will be implemented by creating a program that iterates through each test case and performs the following sequence of calculations:\n\n1.  **Initialization:** For each case, parse the input parameters: $ \\rho_0, p_0, \\gamma, \\mathbf{B}_0, \\mathbf{k}, (\\Delta x, \\Delta y, \\Delta z) $, and the numerical scheme (CD2 or CD4). Evaluate the components of $ \\mathbf{k} $ from the given trigonometric expressions.\n\n2.  **Calculate Fundamental Quantities:**\n    -   Compute the magnitudes $ \\|\\mathbf{B}_0\\| $ and $ \\|\\mathbf{k}\\| $.\n    -   Calculate the Alfvén speed $ V_A = \\|\\mathbf{B}_0\\| / \\sqrt{\\mu_0 \\rho_0} $ and the sound speed $ c_s = \\sqrt{\\gamma p_0 / \\rho_0} $.\n    -   Determine the reference speed $ c_{\\text{ref}} = \\max(V_A, c_s) $.\n\n3.  **Calculate Exact Phase Speeds:**\n    -   Compute the cosine of the angle between the physical wavevector and the magnetic field: $ \\cos \\theta_{\\text{exact}} = (\\mathbf{k} \\cdot \\mathbf{B}_0) / (\\|\\mathbf{k}\\| \\|\\mathbf{B}_0\\|) $.\n    -   Calculate $ c_A^{\\text{exact}} = V_A \\cos \\theta_{\\text{exact}} $.\n    -   Calculate $ c_f^{\\text{exact}} $ and $ c_s^{\\text{exact}} $ using the provided formula with $ \\cos \\theta_{\\text{exact}} $.\n\n4.  **Calculate Numerical Wavevector:**\n    -   Construct the discrete wavevector $ \\tilde{\\mathbf{k}} $ based on the specified scheme (CD2 or CD4). The components $ \\tilde{k}_j $ are calculated using the respective formulas.\n    -   Compute the magnitude $ \\|\\tilde{\\mathbf{k}}\\| $.\n\n5.  **Calculate Numerical Phase Speeds:**\n    -   For the Alfvén wave, compute the numerical angular frequency $ \\omega_A^{\\text{num}} = V_A ( (\\mathbf{B}_0/\\|\\mathbf{B}_0\\|) \\cdot \\tilde{\\mathbf{k}}) $ and then the phase speed $ c_A^{\\text{num}} = \\omega_A^{\\text{num}} / \\|\\mathbf{k}\\| $.\n    -   For magnetosonic waves, first compute the cosine of the numerical angle: $ \\cos \\theta_{\\text{num}} = (\\tilde{\\mathbf{k}} \\cdot \\mathbf{B}_0) / (\\|\\tilde{\\mathbf{k}}\\| \\|\\mathbf{B}_0\\|) $.\n    -   Use $ \\cos \\theta_{\\text{num}} $ in the magnetosonic speed formula to get the intermediate speeds $ c_{f,s}(\\theta_{\\text{num}}) $.\n    -   Calculate the numerical angular frequencies $ \\omega_{f,s}^{\\text{num}} = c_{f,s}(\\theta_{\\text{num}}) \\, \\|\\tilde{\\mathbf{k}}\\| $.\n    -   Finally, compute the numerical phase speeds $ c_{f,s}^{\\text{num}} = \\omega_{f,s}^{\\text{num}} / \\|\\mathbf{k}\\| $.\n\n6.  **Compute Normalized Errors:**\n    -   Calculate the three error metrics $ \\varepsilon_A, \\varepsilon_f, \\varepsilon_s $ by subtracting the exact speeds from the numerical speeds and normalizing by $ c_{\\text{ref}} $.\n\n7.  **Final Output:**\n    -   Collect the error triplets $ [\\varepsilon_A, \\varepsilon_f, \\varepsilon_s] $ for all test cases.\n    -   Format the collected results into a single-line string representing a list of lists, as specified in the problem.\nThe implementation will use the `numpy` library for efficient vector operations and mathematical functions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the numerical dispersion errors for MHD waves for a given test suite.\n    \"\"\"\n    # Define physical constants\n    mu_0 = 4.0 * np.pi * 1e-7\n\n    # Define test cases. The components of k are evaluated from the given expressions.\n    test_cases = [\n        # (rho0, p0, gamma, B0, k, dx, dy, dz, scheme)\n        (1.0, 1.0e5, 5.0/3.0, (0.5, 0.0, 0.0), (80.0 * np.cos(np.deg2rad(35)), 80.0 * np.sin(np.deg2rad(35)), 0.0), 0.02, 0.02, 0.02, \"CD2\"),\n        (1.0, 1.0e5, 5.0/3.0, (0.5, 0.0, 0.0), (80.0 * np.cos(np.deg2rad(35)), 80.0 * np.sin(np.deg2rad(35)), 0.0), 0.02, 0.02, 0.02, \"CD4\"),\n        (1.0, 1.0e5, 5.0/3.0, (0.5, 0.0, 0.0), (10.0 * np.cos(np.deg2rad(60)), 10.0 * np.sin(np.deg2rad(60)), 0.0), 0.02, 0.02, 0.02, \"CD2\"),\n        (1.0, 1.0e5, 5.0/3.0, (0.5, 0.0, 0.0), (10.0 * np.cos(np.deg2rad(60)), 10.0 * np.sin(np.deg2rad(60)), 0.0), 0.02, 0.02, 0.02, \"CD4\"),\n        (1.0, 1.0e5, 5.0/3.0, (0.5, 0.0, 0.0), (50.0 * np.cos(np.deg2rad(60)), 50.0 * np.sin(np.deg2rad(60)), 0.0), 0.05, 0.02, 0.02, \"CD2\"),\n        (1.0, 1.0e5, 5.0/3.0, (0.5, 0.0, 0.0), (50.0 * np.cos(np.deg2rad(60)), 50.0 * np.sin(np.deg2rad(60)), 0.0), 0.05, 0.02, 0.02, \"CD4\"),\n        (1.0, 1.0e5, 5.0/3.0, (0.5/np.sqrt(2), 0.5/np.sqrt(2), 0.0), (70.0 * np.cos(np.deg2rad(25)) * np.cos(np.deg2rad(30)), 70.0 * np.cos(np.deg2rad(25)) * np.sin(np.deg2rad(30)), 70.0 * np.sin(np.deg2rad(25))), 0.03, 0.02, 0.025, \"CD2\"),\n        (1.0, 1.0e5, 5.0/3.0, (0.5/np.sqrt(2), 0.5/np.sqrt(2), 0.0), (70.0 * np.cos(np.deg2rad(25)) * np.cos(np.deg2rad(30)), 70.0 * np.cos(np.deg2rad(25)) * np.sin(np.deg2rad(30)), 70.0 * np.sin(np.deg2rad(25))), 0.03, 0.02, 0.025, \"CD4\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        rho0, p0, gamma, B0_tuple, k_tuple, dx, dy, dz, scheme = case\n\n        B0_vec = np.array(B0_tuple)\n        k_vec = np.array(k_tuple)\n        delta_vec = np.array([dx, dy, dz])\n\n        # --- Calculate Fundamental Quantities ---\n        B0_mag = np.linalg.norm(B0_vec)\n        V_A = B0_mag / np.sqrt(mu_0 * rho0)\n        c_s = np.sqrt(gamma * p0 / rho0)\n        c_ref = max(V_A, c_s)\n        \n        k_mag = np.linalg.norm(k_vec)\n        \n        # Handle trivial cases\n        if B0_mag == 0 or k_mag == 0:\n            results.append([0.0, 0.0, 0.0])\n            continue\n            \n        b_hat = B0_vec / B0_mag\n\n        # --- Calculate Exact Phase Speeds ---\n        cos_theta_exact = np.dot(k_vec, b_hat) / k_mag\n\n        # Alfven Wave\n        c_A_exact = V_A * cos_theta_exact\n        \n        # Magnetosonic Waves\n        term1 = V_A**2 + c_s**2\n        # Ensure argument of sqrt is non-negative due to potential floating point inaccuracies\n        discriminant_val = term1**2 - 4 * V_A**2 * c_s**2 * cos_theta_exact**2\n        discriminant = np.sqrt(max(0, discriminant_val))\n        \n        c_f_exact = np.sqrt(0.5 * (term1 + discriminant))\n        c_s_exact = np.sqrt(0.5 * (term1 - discriminant))\n        \n        # --- Calculate Numerical Wavevector and Phase Speeds ---\n        k_tilde_vec = np.zeros(3)\n        if scheme == \"CD2\":\n            args = k_vec * delta_vec\n            # Handle k_j = 0 case where delta_j might be non-zero\n            k_tilde_vec = np.divide(np.sin(args), delta_vec, out=np.zeros_like(args), where=delta_vec!=0)\n        elif scheme == \"CD4\":\n            args1 = k_vec * delta_vec\n            args2 = 2 * k_vec * delta_vec\n            numerator = 8 * np.sin(args1) - np.sin(args2)\n            denominator = 12 * delta_vec\n            k_tilde_vec = np.divide(numerator, denominator, out=np.zeros_like(numerator), where=denominator!=0)\n        \n        k_tilde_mag = np.linalg.norm(k_tilde_vec)\n        \n        # Alfven Wave\n        omega_A_num = V_A * np.dot(b_hat, k_tilde_vec)\n        c_A_num = omega_A_num / k_mag\n\n        # Magnetosonic Waves\n        if k_tilde_mag == 0:\n            c_f_num = 0.0\n            c_s_num = 0.0\n        else:\n            cos_theta_num = np.dot(k_tilde_vec, b_hat) / k_tilde_mag\n            \n            discriminant_val_num = term1**2 - 4 * V_A**2 * c_s**2 * cos_theta_num**2\n            discriminant_num = np.sqrt(max(0, discriminant_val_num))\n\n            c_f_tilde = np.sqrt(0.5 * (term1 + discriminant_num))\n            c_s_tilde = np.sqrt(0.5 * (term1 - discriminant_num))\n            \n            omega_f_num = c_f_tilde * k_tilde_mag\n            omega_s_num = c_s_tilde * k_tilde_mag\n            \n            c_f_num = omega_f_num / k_mag\n            c_s_num = omega_s_num / k_mag\n            \n        # --- Calculate Normalized Errors ---\n        eps_A = (c_A_num - c_A_exact) / c_ref\n        eps_f = (c_f_num - c_f_exact) / c_ref\n        eps_s = (c_s_num - c_s_exact) / c_ref\n        \n        results.append([eps_A, eps_f, eps_s])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}