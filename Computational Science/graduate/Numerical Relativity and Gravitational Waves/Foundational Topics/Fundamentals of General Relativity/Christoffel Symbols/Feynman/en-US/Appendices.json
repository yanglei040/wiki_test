{
    "hands_on_practices": [
        {
            "introduction": "This first practice is a foundational analytical exercise designed to build fluency with the definition of Christoffel symbols and their application. By working through the calculation for a non-trivial, conformally flat metric, you will solidify your understanding of how these symbols arise from the metric's derivatives and how they are used to compute covariant derivatives, such as the divergence of a vector field . Mastering this process by hand is a crucial prerequisite for appreciating and debugging the numerical implementations that follow.",
            "id": "3467763",
            "problem": "On a $3$-dimensional Cauchy hypersurface $\\Sigma$ used in numerical relativity, consider global Cartesian coordinates $(x,y,z)$ and a conformally flat spatial metric $\\gamma_{ij} = \\psi(x)^{4}\\,\\delta_{ij}$ with conformal factor $\\psi(x) = 1 + \\lambda x^{2}$, where $\\lambda$ is a real constant and $\\delta_{ij}$ is the Kronecker delta. Let a contravariant vector field $V^{i}$ be given by the components $V^{x} = x^{2}y$, $V^{y} = xy^{2}$, and $V^{z} = z^{3}$ in these coordinates. Using only the defining properties of the Levi-Civita connection (torsion-free and metric-compatible) on a Riemannian manifold and the definition of the spatial covariant derivative induced by $\\gamma_{ij}$, compute the Christoffel symbols $\\prescript{(3)}{}{\\Gamma}^{i}{}_{jk}$ of the spatial connection and then use them to evaluate the spatial covariant divergence $D_{i}V^{i}$ of the vector field. Express your final answer as a single exact analytic expression in terms of $x$, $y$, $z$, and $\\lambda$. No units are required.",
            "solution": "The task is to compute the Levi-Civita connection coefficients (Christoffel symbols) for the $3$-metric $\\gamma_{ij}$ and then use them to compute the covariant divergence $D_{i}V^{i}$. The Levi-Civita connection is uniquely characterized by being torsion-free and metric-compatible. In coordinates, this implies the standard formula\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{jk} = \\frac{1}{2}\\,\\gamma^{i\\ell}\\left(\\partial_{j}\\gamma_{k\\ell} + \\partial_{k}\\gamma_{j\\ell} - \\partial_{\\ell}\\gamma_{jk}\\right),\n$$\nwhere $\\gamma^{i\\ell}$ is the inverse of $\\gamma_{i\\ell}$.\n\nStep $1$: Compute the inverse metric and its derivatives. The given metric is $\\gamma_{ij} = \\psi^{4}\\delta_{ij}$ with $\\psi = 1 + \\lambda x^{2}$. Hence the inverse is\n$$\n\\gamma^{ij} = \\psi^{-4}\\delta^{ij}.\n$$\nWe also have\n$$\n\\partial_{j}\\gamma_{k\\ell} = \\partial_{j}\\left(\\psi^{4}\\delta_{k\\ell}\\right) = 4\\psi^{3}(\\partial_{j}\\psi)\\,\\delta_{k\\ell}.\n$$\nBecause $\\psi$ depends only on $x$, the only nonvanishing derivative of $\\psi$ is\n$$\n\\partial_{x}\\psi = 2\\lambda x,\\quad \\partial_{y}\\psi = 0,\\quad \\partial_{z}\\psi = 0.\n$$\n\nStep $2$: Simplify the Christoffel symbols for the conformally flat form. Substitute into the definition:\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{jk}\n= \\frac{1}{2}\\,\\psi^{-4}\\delta^{i\\ell}\\left[4\\psi^{3}(\\partial_{j}\\psi)\\delta_{k\\ell} + 4\\psi^{3}(\\partial_{k}\\psi)\\delta_{j\\ell} - 4\\psi^{3}(\\partial_{\\ell}\\psi)\\delta_{jk}\\right].\n$$\nFactor out $2\\psi^{-1}$ and use $\\delta^{i\\ell}\\delta_{k\\ell} = \\delta^{i}{}_{k}$ and $\\delta^{i\\ell}\\partial_{\\ell}\\psi = \\partial^{i}\\psi$ with $\\partial^{i}\\psi \\equiv \\delta^{i\\ell}\\partial_{\\ell}\\psi$:\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{jk}\n= 2\\psi^{-1}\\left[(\\partial_{j}\\psi)\\delta^{i}{}_{k} + (\\partial_{k}\\psi)\\delta^{i}{}_{j} - \\delta_{jk}\\,\\partial^{i}\\psi\\right].\n$$\nEquivalently, in terms of $\\ln\\psi$,\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{jk}\n= 2\\left[(\\partial_{j}\\ln\\psi)\\delta^{i}{}_{k} + (\\partial_{k}\\ln\\psi)\\delta^{i}{}_{j} - \\delta_{jk}\\,\\partial^{i}\\ln\\psi\\right].\n$$\nSince $\\partial_{x}\\ln\\psi = \\frac{\\partial_{x}\\psi}{\\psi} = \\frac{2\\lambda x}{1+\\lambda x^{2}}$ and $\\partial_{y}\\ln\\psi = \\partial_{z}\\ln\\psi = 0$, let\n$$\nL(x) \\equiv \\partial_{x}\\ln\\psi = \\frac{2\\lambda x}{1+\\lambda x^{2}}.\n$$\nThen the only nonzero Christoffel symbols are obtained by inserting derivatives along $x$. Listing the nonvanishing components explicitly:\n- For $i=x$:\n$$\n\\prescript{(3)}{}{\\Gamma}^{x}{}_{xx} = 2L,\\quad \\prescript{(3)}{}{\\Gamma}^{x}{}_{yy} = -2L,\\quad \\prescript{(3)}{}{\\Gamma}^{x}{}_{zz} = -2L.\n$$\n- For $i=y$:\n$$\n\\prescript{(3)}{}{\\Gamma}^{y}{}_{xy} = \\prescript{(3)}{}{\\Gamma}^{y}{}_{yx} = 2L.\n$$\n- For $i=z$:\n$$\n\\prescript{(3)}{}{\\Gamma}^{z}{}_{xz} = \\prescript{(3)}{}{\\Gamma}^{z}{}_{zx} = 2L.\n$$\nAll other components vanish.\n\nStep $3$: Compute the divergence $D_{i}V^{i}$. By definition,\n$$\nD_{i}V^{i} = \\partial_{i}V^{i} + \\prescript{(3)}{}{\\Gamma}^{i}{}_{ik} V^{k}.\n$$\nFirst compute the partial derivatives of the components of $V^{i}$:\n$$\n\\partial_{x}V^{x} = \\partial_{x}(x^{2}y) = 2xy,\\quad\n\\partial_{y}V^{y} = \\partial_{y}(xy^{2}) = 2xy,\\quad\n\\partial_{z}V^{z} = \\partial_{z}(z^{3}) = 3z^{2}.\n$$\nThus\n$$\n\\partial_{i}V^{i} = 2xy + 2xy + 3z^{2} = 4xy + 3z^{2}.\n$$\nNext evaluate the contraction $\\prescript{(3)}{}{\\Gamma}^{i}{}_{ik}$. From the expression above,\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{ik}\n= 2\\left[(\\partial_{i}\\ln\\psi)\\delta^{i}{}_{k} + (\\partial_{k}\\ln\\psi)\\delta^{i}{}_{i} - \\delta_{ik}\\,\\partial^{i}\\ln\\psi\\right].\n$$\nSumming over $i$ and using $\\delta^{i}{}_{i} = 3$, $\\delta_{ik}\\partial^{i}\\ln\\psi = \\partial_{k}\\ln\\psi$, and $\\sum_{i}(\\partial_{i}\\ln\\psi)\\delta^{i}{}_{k} = \\partial_{k}\\ln\\psi$, we obtain\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{ik} = 6\\,\\partial_{k}\\ln\\psi.\n$$\nSince only $\\partial_{x}\\ln\\psi = L$ is nonzero, we have\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{ix} = 6L,\\quad \\prescript{(3)}{}{\\Gamma}^{i}{}_{iy} = 0,\\quad \\prescript{(3)}{}{\\Gamma}^{i}{}_{iz} = 0.\n$$\nTherefore\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{ik}V^{k} = (6L)\\,V^{x} = 6L\\,x^{2}y = 6\\left(\\frac{2\\lambda x}{1+\\lambda x^{2}}\\right)x^{2}y = \\frac{12\\lambda x^{3}y}{1+\\lambda x^{2}}.\n$$\nCombine both contributions:\n$$\nD_{i}V^{i} = \\left(4xy + 3z^{2}\\right) + \\frac{12\\lambda x^{3}y}{1+\\lambda x^{2}}.\n$$\nThis is the required exact analytic expression in terms of $x$, $y$, $z$, and $\\lambda$.",
            "answer": "$$\\boxed{4xy+3z^{2}+\\frac{12\\lambda x^{3}y}{1+\\lambda x^{2}}}$$"
        },
        {
            "introduction": "Moving from analytical theory to computational practice, this exercise serves as a vital consistency check for any numerical relativity code. You will first derive the fundamental property of metric compatibility, $\\nabla_a g_{bc} = 0$, and then implement a program to verify that your numerical computation of the Christoffel symbols preserves this identity up to expected truncation error . Successfully completing this test for various spacetimes provides confidence that the geometric machinery of your code is correctly implemented.",
            "id": "3467809",
            "problem": "You are given the task of establishing, from first principles, that the covariant derivative of the metric tensor vanishes for the unique torsion-free connection compatible with a given metric, and then to design and implement a numerical consistency check that verifies this identity using finite differences and numerically computed Christoffel symbols. Your work must be expressed in purely mathematical terms and implemented as a program that computes explicit numerical residuals for a small test suite of metrics relevant to numerical relativity and gravitational waves.\n\nDerive, starting from fundamental definitions valid in differential geometry and general relativity, that for the Levi-Civita connection associated with a smooth metric tensor $g_{ab}$ on a $4$-dimensional manifold, the covariant derivative of the metric vanishes, that is $ \\nabla_{a} g_{bc} = 0$. You must base your derivation only on core definitions such as the notion of a symmetric, torsion-free connection, the rules for covariant differentiation acting on tensor fields (including the product rule), and the metric-induced raising and lowering of indices. Do not assume the desired identity $ \\nabla_{a} g_{bc} = 0$ as a premise; instead, show that it follows from the defining properties of the Levi-Civita connection constructed from $g_{ab}$.\n\nThen, design a numerical procedure that verifies the identity $ \\nabla_{a} g_{bc} = 0$ at a single point in each of several coordinate systems and metrics by computing:\n- the partial derivatives $ \\partial_{a} g_{bc}$ via centered finite differences with step size $h$,\n- the Christoffel symbols $ \\Gamma^{a}{}_{bc}$ built from $g_{ab}$ and its partial derivatives,\n- and the covariant derivative $ \\nabla_{a} g_{bc} = \\partial_{a} g_{bc} - \\Gamma^{d}{}_{ab}\\, g_{dc} - \\Gamma^{d}{}_{ac}\\, g_{bd}$ evaluated numerically.\n\nYour program must:\n- Represent coordinates as a vector $x^{a}$ with index ordering $a \\in \\{0,1,2,3\\}$.\n- Use the index convention $0 \\mapsto t$, $1 \\mapsto x$ (or $r$), $2 \\mapsto y$ (or $\\theta$), $3 \\mapsto z$ (or $\\phi$), depending on the chosen coordinate chart for each test case; the program must clearly implement the metric in the declared chart.\n- Compute the partial derivatives $ \\partial_{a} g_{bc}$ using the centered finite-difference stencil $ \\partial_{a} g_{bc}(x) \\approx \\left[g_{bc}(x + h\\, e_{a}) - g_{bc}(x - h\\, e_{a})\\right]/(2h)$, where $e_{a}$ is the unit vector in the $a$-th coordinate direction and $h$ is a small positive real number.\n- Build $ \\Gamma^{a}{}_{bc}$ using the standard Levi-Civita connection formula in terms of $g_{ab}$ and its partial derivatives.\n- Compute the residual as the maximum absolute component of $ \\nabla_{a} g_{bc}$ over all indices $a,b,c \\in \\{0,1,2,3\\}$.\n- Output, for each test case, a single floating-point number equal to that residual. These floats are dimensionless. Where angular coordinates appear, they must be in radians.\n\nTest Suite:\nImplement the following four test cases, each specified by a metric, a coordinate chart, an evaluation point, and a finite-difference step size $h$. For every case, evaluate the residual at the indicated point.\n\n- Case $1$ (Happy path, constant metric in Cartesian coordinates):\n  - Coordinates: $(t,x,y,z)$.\n  - Metric: Minkowski metric with signature $(-,+,+,+)$, $g_{ab} = \\mathrm{diag}(-1, 1, 1, 1)$.\n  - Evaluation point: $(t, x, y, z) = (0.0, 0.0, 0.0, 0.0)$.\n  - Step size: $h = 10^{-5}$.\n\n- Case $2$ (Nontrivial coordinates with flat geometry, spherical polar coordinates):\n  - Coordinates: $(t,r,\\theta,\\phi)$ where $\\theta$ and $\\phi$ are in radians.\n  - Metric: Minkowski metric in spherical polar spatial coordinates, $g_{ab} = \\mathrm{diag}(-1, 1, r^{2}, r^{2}\\sin^{2}\\theta)$.\n  - Evaluation point: $(t, r, \\theta, \\phi) = (0.0, 2.0, 0.7, 1.2)$.\n  - Step size: $h = 10^{-6}$.\n\n- Case $3$ (Weak plane gravitational wave in transverse-traceless gauge):\n  - Coordinates: $(t,x,y,z)$.\n  - Metric: $ds^{2} = -dt^{2} + \\left[1 + h_{+}(u)\\right]dx^{2} + \\left[1 - h_{+}(u)\\right]dy^{2} + 2 h_{\\times}(u)\\,dx\\,dy + dz^{2}$, where $u = t - z$, $h_{+}(u) = A \\cos(k u)$, $h_{\\times}(u) = A \\sin(k u)$ with $A = 10^{-3}$ and $k = 2.0$.\n  - Evaluation point: $(t, x, y, z) = (0.4, 0.1, -0.1, 0.2)$.\n  - Step size: $h = 10^{-6}$.\n\n- Case $4$ (Curved, static spacetime in Cartesian-like coordinates, isotropic Schwarzschild):\n  - Coordinates: $(t,x,y,z)$.\n  - Metric: $ds^{2} = -\\alpha^{2}(r)\\,dt^{2} + \\psi^{4}(r)\\left(dx^{2} + dy^{2} + dz^{2}\\right)$ with $r = \\sqrt{x^{2} + y^{2} + z^{2}}$, $\\psi(r) = 1 + \\dfrac{M}{2r}$, and $\\alpha(r) = \\dfrac{1 - \\dfrac{M}{2r}}{1 + \\dfrac{M}{2r}}$; take $M = 1.0$.\n  - Evaluation point: $(t, x, y, z) = (0.0, 2.0, 1.0, 1.5)$.\n  - Step size: $h = 10^{-6}$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_{1},r_{2},r_{3},r_{4}]$), where $r_{i}$ is the floating-point residual for test case $i$. No additional text should be printed. The angles appearing in the problem are in radians. No physical units are required because all quantities are dimensionless in the constructions above.",
            "solution": "The user-provided problem is assessed to be valid. It is a well-posed, scientifically grounded, and objective problem in the field of computational general relativity. It requires a standard theoretical derivation followed by a numerical implementation to verify a fundamental identity of Riemannian geometry. All definitions, data, and constraints are self-contained and consistent.\n\n### Theoretical Derivation: Metric Compatibility of the Levi-Civita Connection\n\nThe goal is to demonstrate that for the Levi-Civita connection, the covariant derivative of the metric tensor, $\\nabla_{a} g_{bc}$, is identically zero. The Levi-Civita connection is, by definition, the unique connection on a (pseudo-)Riemannian manifold that is both symmetric (torsion-free) and metric-compatible. An alternative, constructive approach defines the connection via its connection coefficients (Christoffel symbols) derived from the metric, and then proves these two properties hold. We will follow the latter path, as directed by the problem: we will assume the standard formula for the Christoffel symbols and prove that metric compatibility, $\\nabla_{a} g_{bc} = 0$, is a direct consequence.\n\nLet $g_{ab}$ be a smooth, symmetric, non-degenerate metric tensor on a $4$-dimensional manifold. The Christoffel symbols of the second kind for the Levi-Civita connection, $\\Gamma^{a}{}_{bc}$, are defined in terms of the metric and its partial derivatives, $\\partial_a g_{bc} \\equiv \\frac{\\partial g_{bc}}{\\partial x^a}$, as:\n$$\n\\Gamma^{a}{}_{bc} = \\frac{1}{2} g^{ad} \\left( \\partial_b g_{dc} + \\partial_c g_{bd} - \\partial_d g_{bc} \\right)\n$$\nHere, $g^{ad}$ is the inverse metric tensor, satisfying $g^{ad}g_{db} = \\delta^{a}_{b}$, where $\\delta^{a}_{b}$ is the Kronecker delta.\n\nThe covariant derivative of a rank-$(0,2)$ tensor field like $g_{bc}$ is given by the formula:\n$$\n\\nabla_{a} g_{bc} = \\partial_{a} g_{bc} - \\Gamma^{d}{}_{ab} g_{dc} - \\Gamma^{d}{}_{ac} g_{bd}\n$$\nOur objective is to substitute the definition of $\\Gamma^{a}{}_{bc}$ into this expression and show that it vanishes identically.\n\nLet's analyze the two terms involving Christoffel symbols:\nThe first term is $\\Gamma^{d}{}_{ab} g_{dc}$. Substituting the formula for $\\Gamma^{d}{}_{ab}$:\n$$\n\\Gamma^{d}{}_{ab} g_{dc} = \\left[ \\frac{1}{2} g^{de} \\left( \\partial_a g_{eb} + \\partial_b g_{ae} - \\partial_e g_{ab} \\right) \\right] g_{dc}\n$$\nUsing the property $g^{de}g_{dc} = \\delta^{e}_{c}$, we contract the indices $d$ and $e$:\n$$\n\\Gamma^{d}{}_{ab} g_{dc} = \\frac{1}{2} \\delta^{e}_{c} \\left( \\partial_a g_{eb} + \\partial_b g_{ae} - \\partial_e g_{ab} \\right) = \\frac{1}{2} \\left( \\partial_a g_{cb} + \\partial_b g_{ac} - \\partial_c g_{ab} \\right)\n$$\n\nThe second term is $\\Gamma^{d}{}_{ac} g_{bd}$. Substituting the formula for $\\Gamma^{d}{}_{ac}$:\n$$\n\\Gamma^{d}{}_{ac} g_{bd} = \\left[ \\frac{1}{2} g^{de} \\left( \\partial_a g_{ec} + \\partial_c g_{ae} - \\partial_e g_{ac} \\right) \\right] g_{bd}\n$$\nUsing the property $g^{de}g_{bd} = \\delta^{e}_{b}$, we contract the indices $d$ and $e$:\n$$\n\\Gamma^{d}{}_{ac} g_{bd} = \\frac{1}{2} \\delta^{e}_{b} \\left( \\partial_a g_{ec} + \\partial_c g_{ae} - \\partial_e g_{ac} \\right) = \\frac{1}{2} \\left( \\partial_a g_{bc} + \\partial_c g_{ab} - \\partial_b g_{ac} \\right)\n$$\n\nNow, we substitute these two results back into the expression for $\\nabla_{a} g_{bc}$:\n$$\n\\nabla_{a} g_{bc} = \\partial_{a} g_{bc} - \\frac{1}{2} \\left( \\partial_a g_{cb} + \\partial_b g_{ac} - \\partial_c g_{ab} \\right) - \\frac{1}{2} \\left( \\partial_a g_{bc} + \\partial_c g_{ab} - \\partial_b g_{ac} \\right)\n$$\nSince the metric tensor is symmetric, $g_{bc} = g_{cb}$. We can distribute the factors of $-1/2$ and collect terms:\n$$\n\\nabla_{a} g_{bc} = \\partial_{a} g_{bc} - \\frac{1}{2} \\partial_{a} g_{bc} - \\frac{1}{2} \\partial_{b} g_{ac} + \\frac{1}{2} \\partial_{c} g_{ab} - \\frac{1}{2} \\partial_{a} g_{bc} - \\frac{1}{2} \\partial_{c} g_{ab} + \\frac{1}{2} \\partial_{b} g_{ac}\n$$\nGrouping like terms together:\n$$\n\\nabla_{a} g_{bc} = \\left( \\partial_{a} g_{bc} - \\frac{1}{2} \\partial_{a} g_{bc} - \\frac{1}{2} \\partial_{a} g_{bc} \\right) + \\left( -\\frac{1}{2} \\partial_{b} g_{ac} + \\frac{1}{2} \\partial_{b} g_{ac} \\right) + \\left( \\frac{1}{2} \\partial_{c} g_{ab} - \\frac{1}{2} \\partial_{c} g_{ab} \\right)\n$$\nAll three parenthesized groups sum to zero:\n$$\n\\nabla_{a} g_{bc} = 0 + 0 + 0 = 0\n$$\nThis completes the derivation, showing that the connection defined by the Christoffel symbol formula is indeed metric-compatible. This identity is fundamental to general relativity, signifying that lengths of vectors and angles between them are preserved under parallel transport.\n\n### Numerical Procedure Design\n\nThe numerical verification of the identity $\\nabla_{a} g_{bc} = 0$ proceeds by calculating each term in the expression for the covariant derivative using numerical methods and then computing a residual. The residual, which is ideally zero, will be a small non-zero number due to finite-precision arithmetic and an approximation error from the finite-difference scheme.\n\nFor each test case, specified by a metric $g_{ab}(x)$, an evaluation point $x_p$, and a step size $h$:\n\n1.  **Define a Metric Function**: For each case, a Python function `metric_func(coords)` is implemented. It takes a $4$-element coordinate vector $x^a = (x^0, x^1, x^2, x^3)$ and returns the $4 \\times 4$ metric tensor $g_{ab}$ as a NumPy array.\n\n2.  **Compute Partial Derivatives**: The partial derivatives $\\partial_a g_{bc}$ at the point $x_p$ are approximated using a second-order centered finite-difference formula. For each coordinate direction $a \\in \\{0,1,2,3\\}$:\n    $$\n    \\partial_{a} g_{bc}(x_p) \\approx \\frac{g_{bc}(x_p + h \\cdot e_{a}) - g_{bc}(x_p - h \\cdot e_{a})}{2h}\n    $$\n    where $e_a$ is the unit vector in the $a$-th direction. This is computed for all $a, b, c$, yielding a $4 \\times 4 \\times 4$ tensor of derivatives, which we denote `dG`.\n\n3.  **Compute Christoffel Symbols**: At the point $x_p$, we first evaluate the metric $g_{ab}$ and its inverse $g^{ab}$. Then, we compute the Christoffel symbols $\\Gamma^{a}{}_{bc}$ using their definition in terms of the metric and the numerically computed partial derivatives:\n    $$\n    \\Gamma^{a}{}_{bc} = \\frac{1}{2} g^{ad} \\left( \\partial_b g_{dc} + \\partial_c g_{bd} - \\partial_d g_{bc} \\right)\n    $$\n    This is calculated for all $a,b,c$, resulting in a $4 \\times 4 \\times 4$ tensor `Gamma`.\n\n4.  **Compute Covariant Derivative**: The components of the tensor $\\nabla_a g_{bc}$ are computed numerically by substituting the results from the previous steps into its defining formula:\n    $$\n    \\nabla_{a} g_{bc} = (\\partial_{a} g_{bc})_{\\text{numerical}} - \\sum_{d=0}^{3} (\\Gamma^{d}{}_{ab})_{\\text{numerical}} (g_{dc})_{\\text{numerical}} - \\sum_{d=0}^{3} (\\Gamma^{d}{}_{ac})_{\\text{numerical}} (g_{bd})_{\\text{numerical}}\n    $$\n    This calculation yields a $4 \\times 4 \\times 4$ tensor `nablaG`, whose components represent the numerical error in the identity $\\nabla_a g_{bc} = 0$.\n\n5.  **Calculate the Residual**: The final residual for the test case is defined as the maximum absolute value among all $4^3 = 64$ components of the computed tensor $\\nabla_a g_{bc}$:\n    $$\n    \\text{Residual} = \\max_{a,b,c} \\left| (\\nabla_{a} g_{bc})_{\\text{numerical}} \\right|\n    $$\n    This scalar value quantifies the overall numerical inconsistency. For a correct implementation, this residual is expected to be small, typically on the order of $O(h^2)$ from the finite-difference error, plus any machine precision limitations.\n\nThis procedure is applied to each of the four specified test cases, and the resulting residuals are collected.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# In this problem, scipy is not required.\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical consistency check for the identity\n    nabla_a g_bc = 0 for four test cases in general relativity.\n    \"\"\"\n\n    # ==========================================================================\n    # Metric Tensor Functions\n    # Each function takes a 4-element coordinate vector and returns the\n    # 4x4 metric tensor g_ab as a NumPy array.\n    # ==========================================================================\n\n    def metric_minkowski_cartesian(coords):\n        \"\"\"\n        Minkowski metric in Cartesian coordinates (t, x, y, z).\n        Signature (-, +, +, +).\n        \"\"\"\n        return np.diag([-1.0, 1.0, 1.0, 1.0])\n\n    def metric_minkowski_spherical(coords):\n        \"\"\"\n        Minkowski metric in spherical polar coordinates (t, r, theta, phi).\n        \"\"\"\n        t, r, theta, phi = coords\n        # Add a small epsilon to r to handle r=0 case gracefully if it ever occurs,\n        # though the test point avoids it.\n        r_safe = r + 1e-30\n        return np.diag([-1.0, 1.0, r_safe**2, (r_safe * np.sin(theta))**2])\n\n    def metric_gw(coords):\n        \"\"\"\n        Weak plane gravitational wave in transverse-traceless gauge.\n        Coordinates are (t, x, y, z).\n        \"\"\"\n        A = 1e-3\n        k = 2.0\n        t, x, y, z = coords\n        u = t - z\n        h_plus = A * np.cos(k * u)\n        h_cross = A * np.sin(k * u)\n        \n        g = np.diag([-1.0, 1.0, 1.0, 1.0])\n        g[1, 1] = 1.0 + h_plus\n        g[2, 2] = 1.0 - h_plus\n        g[1, 2] = h_cross\n        g[2, 1] = h_cross\n        return g\n\n    def metric_schwarzschild_iso(coords):\n        \"\"\"\n        Schwarzschild metric in isotropic coordinates (t, x, y, z).\n        \"\"\"\n        M = 1.0\n        t, x, y, z = coords\n        r = np.sqrt(x**2 + y**2 + z**2)\n        \n        if r < 1e-12: # Avoid division by zero\n            # This case is not hit by the provided test points.\n            # Return a singular-like metric. This is physically ill-defined at r=0.\n            return np.diag([0.0, np.inf, np.inf, np.inf])\n\n        psi = 1.0 + M / (2.0 * r)\n        alpha = (1.0 - M / (2.0 * r)) / psi\n        \n        g = np.zeros((4, 4))\n        g[0, 0] = -alpha**2\n        g[1, 1] = psi**4\n        g[2, 2] = psi**4\n        g[3, 3] = psi**4\n        return g\n\n    # ==========================================================================\n    # Numerical Computation Core\n    # ==========================================================================\n\n    def compute_residual(metric_func, point, h):\n        \"\"\"\n        Computes the residual for the identity nabla_a g_bc = 0.\n\n        Args:\n            metric_func: A function that returns the metric tensor at a point.\n            point: The 4D coordinate vector at which to evaluate.\n            h: The step size for finite differences.\n\n        Returns:\n            The maximum absolute value of the components of nabla_a g_bc.\n        \"\"\"\n        p = np.array(point, dtype=float)\n        dim = 4\n\n        # 1. Compute partial derivatives dG[a, b, c] = \\partial_a g_bc\n        # Uses a centered finite-difference scheme.\n        dG = np.zeros((dim, dim, dim))\n        for a in range(dim):\n            p_plus = p.copy()\n            p_plus[a] += h\n            p_minus = p.copy()\n            p_minus[a] -= h\n            \n            g_plus = metric_func(p_plus)\n            g_minus = metric_func(p_minus)\n            \n            dG[a, :, :] = (g_plus - g_minus) / (2.0 * h)\n            \n        # 2. Compute G and its inverse invG at the central point p\n        G = metric_func(p)\n        invG = np.linalg.inv(G)\n        \n        # 3. Compute Christoffel symbols Gamma^a_bc\n        # Gamma^a_{bc} = 1/2 g^{ad} (d_b g_{dc} + d_c g_{bd} - d_d g_{bc})\n        # Note: dG[k, i, j] represents \\partial_k g_ij\n        Gamma = np.zeros((dim, dim, dim))\n        for a in range(dim):\n            for b in range(dim):\n                for c in range(dim):\n                    s = 0.0\n                    for d in range(dim):\n                        term1 = dG[b, d, c]  # \\partial_b g_{dc}\n                        term2 = dG[c, b, d]  # \\partial_c g_{bd}\n                        term3 = dG[d, b, c]  # \\partial_d g_{bc}\n                        s += 0.5 * invG[a, d] * (term1 + term2 - term3)\n                    Gamma[a, b, c] = s\n        \n        # 4. Compute covariant derivative nabla_a g_bc\n        # nabla_a g_bc = d_a g_bc - Gamma^d_{ab} g_{dc} - Gamma^d_{ac} g_{bd}\n        # Using np.einsum for efficient and readable tensor contraction.\n        term2 = np.einsum('dab,dc->abc', Gamma, G)\n        term3 = np.einsum('dac,db->abc', Gamma, G) # relies on symmetry of G (g_bd = g_db)\n        \n        nablaG = dG - term2 - term3\n\n        # 5. The residual is the maximum absolute component of nablaG\n        residual = np.max(np.abs(nablaG))\n        return residual\n\n    # ==========================================================================\n    # Test Suite Execution\n    # ==========================================================================\n    \n    test_cases = [\n        {'name': 'Minkowski (Cartesian)', 'metric_func': metric_minkowski_cartesian, 'point': (0.0, 0.0, 0.0, 0.0), 'h': 1e-5},\n        {'name': 'Minkowski (Spherical)', 'metric_func': metric_minkowski_spherical, 'point': (0.0, 2.0, 0.7, 1.2), 'h': 1e-6},\n        {'name': 'Gravitational Wave', 'metric_func': metric_gw, 'point': (0.4, 0.1, -0.1, 0.2), 'h': 1e-6},\n        {'name': 'Schwarzschild (Isotropic)', 'metric_func': metric_schwarzschild_iso, 'point': (0.0, 2.0, 1.0, 1.5), 'h': 1e-6}\n    ]\n    \n    results = []\n    for case in test_cases:\n        res = compute_residual(case['metric_func'], case['point'], case['h'])\n        results.append(res)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice connects the computation of Christoffel symbols directly to the physical viability and numerical accuracy of a general relativistic simulation. You will investigate how discretization errors in the Christoffel symbols and the resulting Ricci scalar manifest as violations of the Hamiltonian constraint, a key component of Einstein's equations . This exercise not only highlights the practical consequences of numerical approximations but also introduces convergence testing, an essential technique for validating the accuracy and reliability of numerical solutions.",
            "id": "3467751",
            "problem": "You are given the three-dimensional spatial metric of a constant time slice in the context of the $3+1$ decomposition used in numerical relativity. The spatial metric is conformally flat and given by $ \\gamma_{ij} = \\psi^4 \\delta_{ij} $ on the three-torus $[0,1]^3$ with periodic boundary conditions in each coordinate. The conformal factor is\n$$\n\\psi(x,y,z) = 1 + \\varepsilon \\sin(2\\pi x) \\sin(2\\pi y) \\sin(2\\pi z).\n$$\nThe Hamiltonian constraint for vacuum General Relativity reads\n$$\n\\mathcal{H} \\equiv R + K^2 - K_{ij} K^{ij} = 0,\n$$\nwhere $R$ is the Ricci scalar of the spatial metric $\\gamma_{ij}$, $K_{ij}$ is the extrinsic curvature, and $K = \\gamma^{ij} K_{ij}$ is its trace. For this problem, take $K_{ij} = 0$, so the Hamiltonian constraint reduces to $ \\mathcal{H} = R $.\n\nYour task is to demonstrate how numerical errors in computing the spatial Christoffel symbols lead to nonzero residuals in the Hamiltonian constraint when $R$ is computed numerically from discrete data, and to quantify the convergence of these residuals under grid refinement.\n\nFundamental base and definitions to be used:\n- The Christoffel symbols (Levi-Civita connection) are defined by\n$$\n\\Gamma^{k}{}_{ij} = \\frac{1}{2} \\gamma^{k\\ell} \\left( \\partial_i \\gamma_{j\\ell} + \\partial_j \\gamma_{i\\ell} - \\partial_\\ell \\gamma_{ij} \\right).\n$$\n- The Ricci tensor is defined by\n$$\nR_{ij} = \\partial_k \\Gamma^{k}{}_{ij} - \\partial_j \\Gamma^{k}{}_{ik} + \\Gamma^{k}{}_{ij}\\Gamma^{\\ell}{}_{k\\ell} - \\Gamma^{k}{}_{i\\ell}\\Gamma^{\\ell}{}_{jk},\n$$\nand the Ricci scalar is $ R = \\gamma^{ij} R_{ij} $.\n- You must compute all spatial derivatives appearing in these definitions numerically, using a uniform grid and a second-order accurate centered finite-difference stencil with periodic boundary conditions in all three directions. Let the grid size be $N$ points per dimension and the grid spacing be $h = 1/N$.\n\nFor the purpose of quantifying the error that specifically arises from the numerical computation of the spatial Christoffel symbols and their derivatives, proceed as follows.\n1. Compute a numerical approximation $R_{\\mathrm{num}}$ of the Ricci scalar by:\n   - Constructing $ \\gamma_{ij} $ from $ \\psi $.\n   - Computing the Christoffel symbols $ \\Gamma^{k}{}_{ij} $ via the definition above, using second-order centered differences for all spatial derivatives.\n   - Computing $ R_{ij} $ from $ \\Gamma^{k}{}_{ij} $ and its derivatives using the definition above, again with second-order centered differences.\n   - Contracting to obtain $ R_{\\mathrm{num}} = \\gamma^{ij} R_{ij} $.\n2. Compute the exact Ricci scalar $R_{\\mathrm{exact}}$ by analytically differentiating $ \\psi $ and evaluating the resulting closed-form expression for the Ricci scalar for the given conformally flat metric with $ \\gamma_{ij} = \\psi^4 \\delta_{ij} $, using exact derivatives of $ \\psi $.\n3. Define the pointwise Hamiltonian constraint residual as $ \\mathcal{H}_{\\mathrm{res}} = R_{\\mathrm{num}} - R_{\\mathrm{exact}} $. Quantify it by its discrete root-mean-square norm over the grid:\n$$\n\\|\\mathcal{H}_{\\mathrm{res}}\\|_2 = \\left( \\frac{1}{N^3} \\sum_{i,j,k} \\left[ \\mathcal{H}_{\\mathrm{res}}(x_i,y_j,z_k) \\right]^2 \\right)^{1/2}.\n$$\n\nPerform a convergence study by evaluating $ \\|\\mathcal{H}_{\\mathrm{res}}\\|_2 $ at multiple resolutions and reporting empirical convergence orders computed from successive refinements. Use the following test suite with periodic boundary conditions:\n- Test set A (convergence with nontrivial curvature): $ \\varepsilon = 0.1 $ and $ N \\in \\{16, 32, 64\\} $.\n- Test set B (flat space edge case): $ \\varepsilon = 0.0 $ and $ N = 32 $.\n\nFor test set A, compute the residual norms $E_{16}$, $E_{32}$, and $E_{64}$, and the empirical convergence orders\n$$\np_{16\\rightarrow 32} = \\log_2\\!\\left(\\frac{E_{16}}{E_{32}}\\right), \\quad p_{32\\rightarrow 64} = \\log_2\\!\\left(\\frac{E_{32}}{E_{64}}\\right).\n$$\nFor test set B, compute the residual norm $E_{\\mathrm{flat}}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order and type:\n- $E_{16}$, $E_{32}$, $E_{64}$, $p_{16\\rightarrow 32}$, $p_{32\\rightarrow 64}$, $E_{\\mathrm{flat}}$, all as floating-point numbers.\n\nNo physical units are involved. All angles are in radians. The numerical derivatives must be implemented with second-order centered differences under periodic boundary conditions. The final numerical output must adhere exactly to the specified single-line format, e.g., \"[0.0123,0.0031,0.0008,2.00,1.95,0.0]\".",
            "solution": "The user-provided problem statement has been validated and is deemed **valid**. It is scientifically grounded in the $3+1$ formalism of general relativity, well-posed, objective, and contains all necessary information to proceed with a unique, verifiable solution.\n\nThe problem requires a numerical investigation of the Hamiltonian constraint residual, which arises from discretization errors in the computation of the spatial Ricci scalar $R$. The spatial metric is given as conformally flat, $\\gamma_{ij} = \\psi^4 \\delta_{ij}$, on a 3-torus, with a specific form for the conformal factor $\\psi$. The initial data is time-symmetric ($K_{ij}=0$), simplifying the Hamiltonian constraint to $\\mathcal{H} = R = 0$. However, to quantify numerical error, we compute the residual as the difference between the numerically computed Ricci scalar, $R_{\\mathrm{num}}$, and its exact analytical counterpart, $R_{\\mathrm{exact}}$.\n\n### Principle-Based Solution Design\n\nThe solution is structured into two main parts: the analytical derivation of the exact Ricci scalar $R_{\\mathrm{exact}}$, and the numerical algorithm to compute $R_{\\mathrm{num}}$ and the resulting residual.\n\n#### 1. Analytical Ricci Scalar ($R_{\\mathrm{exact}}$)\n\nFor a conformally flat metric in $n=3$ dimensions, given by $\\gamma_{ij} = \\phi^2 \\delta_{ij}$ where $\\phi$ is the conformal factor, the Ricci scalar $R$ is related to the Ricci scalar of the flat background metric ($R_{\\text{flat}}=0$) by the standard formula $R = \\phi^{-2} [R_{\\text{flat}} - 2(n-1) \\Delta \\ln \\phi - (n-2)(n-1) (\\nabla \\ln \\phi)^k (\\nabla \\ln \\phi)_k]$, where $\\Delta$ and $\\nabla$ are the Laplacian and gradient operators of the flat metric. In our case, the metric is $\\gamma_{ij} = \\psi^4 \\delta_{ij}$, so the conformal factor is $\\phi = \\psi^2$. Substituting $n=3$ and $R_{\\text{flat}}=0$, the formula simplifies to a well-known expression for this specific form of the metric:\n$$\nR = -8 \\psi^{-5} \\Delta \\psi = -8 \\psi^{-5} (\\partial_x^2 + \\partial_y^2 + \\partial_z^2) \\psi\n$$\nThe provided conformal factor is $\\psi(x,y,z) = 1 + \\varepsilon \\sin(2\\pi x) \\sin(2\\pi y) \\sin(2\\pi z)$. Let $S(x,y,z) = \\sin(2\\pi x)\\sin(2\\pi y)\\sin(2\\pi z)$, so $\\psi = 1 + \\varepsilon S$. We compute its second derivatives:\n$$\n\\partial_x^2 \\psi = \\partial_x^2 (1 + \\varepsilon S) = \\varepsilon \\partial_x^2 S = \\varepsilon [-(2\\pi)^2 \\sin(2\\pi x)] \\sin(2\\pi y)\\sin(2\\pi z) = -(2\\pi)^2 \\varepsilon S\n$$\nSimilarly, $\\partial_y^2 \\psi = -(2\\pi)^2 \\varepsilon S$ and $\\partial_z^2 \\psi = -(2\\pi)^2 \\varepsilon S$.\nThe flat-space Laplacian of $\\psi$ is thus:\n$$\n\\Delta\\psi = \\partial_x^2\\psi + \\partial_y^2\\psi + \\partial_z^2\\psi = -3(2\\pi)^2 \\varepsilon S = -3(2\\pi)^2 (\\psi - 1)\n$$\nSubstituting this into the formula for $R$, we obtain the exact analytical expression:\n$$\nR_{\\mathrm{exact}} = -8 \\psi^{-5} [-3(2\\pi)^2 (\\psi - 1)] = 24(2\\pi)^2 \\psi^{-5} (\\psi - 1)\n$$\nThis expression will be evaluated on the numerical grid to provide the reference solution. For the special case $\\varepsilon=0$, we have $\\psi=1$, and thus $R_{\\mathrm{exact}}=0$, corresponding to flat space.\n\n#### 2. Numerical Ricci Scalar ($R_{\\mathrm{num}}$)\n\nThe numerical computation of $R$ follows the chain of definitions provided, using finite differences for all derivatives. The domain $[0,1]^3$ is discretized into a uniform grid of $N \\times N \\times N$ points with spacing $h=1/N$. Periodic boundary conditions are handled using `numpy.roll`, which naturally implements the wrap-around behavior. All derivatives are approximated using a second-order accurate centered finite-difference stencil. For a function $f$ on the grid, its derivative along axis $k$ is:\n$$\n(\\partial_k f)_i \\approx \\frac{f_{i+1} - f_{i-1}}{2h}\n$$\nThe numerical algorithm proceeds as follows:\n\n**Step 2a: Compute Christoffel Symbols $\\Gamma^k{}_{ij}$**\nThe Christoffel symbols are given by $\\Gamma^{k}{}_{ij} = \\frac{1}{2} \\gamma^{k\\ell} \\left( \\partial_i \\gamma_{j\\ell} + \\partial_j \\gamma_{i\\ell} - \\partial_\\ell \\gamma_{ij} \\right)$. Since the metric $\\gamma_{ij} = \\psi^4 \\delta_{ij}$ is diagonal, this formula simplifies considerably. The inverse metric is $\\gamma^{ij} = \\psi^{-4} \\delta^{ij}$. The simplified expression is:\n$$\n\\Gamma^k{}_{ij} = 2 \\psi^{-1} (\\delta_{jk} \\partial_i \\psi + \\delta_{ik} \\partial_j \\psi - \\delta_{ij} \\partial_k \\psi)\n$$\nTo compute this numerically, we first evaluate $\\psi$ on the grid. Then, we compute the first derivatives $\\partial_x \\psi$, $\\partial_y \\psi$, and $\\partial_z \\psi$ using the centered finite-difference operator. Finally, we use these numerical derivatives to construct all $3^3=27$ components of the Christoffel symbol on the grid.\n\n**Step 2b: Compute Ricci Tensor $R_{ij}$**\nThe Ricci tensor is defined as $R_{ij} = \\partial_k \\Gamma^{k}{}_{ij} - \\partial_j \\Gamma^{k}{}_{ik} + \\Gamma^{k}{}_{ij}\\Gamma^{\\ell}{}_{k\\ell} - \\Gamma^{k}{}_{i\\ell}\\Gamma^{\\ell}{}_{jk}$. This computation involves:\n1.  Derivatives of the previously computed numerical Christoffel symbols $\\Gamma^k{}_{ij}$. This second layer of differentiation is also performed using the centered difference stencil.\n2.  Quadratic products of the Christoffel symbols.\nThis step is computationally intensive and requires careful management of tensor indices. Each term in the definition is computed separately for each component $(i,j)$ of the Ricci tensor. The summations over dummy indices $k$ and $\\ell$ are performed explicitly.\n\n**Step 2c: Compute Ricci Scalar $R_{\\mathrm{num}}$**\nThe numerical Ricci scalar is the contraction $R_{\\mathrm{num}} = \\gamma^{ij} R_{ij}$. Since both $\\gamma^{ij}$ and $R_{ij}$ are symmetric, and $\\gamma^{ij}$ is diagonal, this simplifies to:\n$$\nR_{\\mathrm{num}} = \\gamma^{xx}R_{xx} + \\gamma^{yy}R_{yy} + \\gamma^{zz}R_{zz} = \\psi^{-4}(R_{xx} + R_{yy} + R_{zz})\n$$\nwhere $R_{xx}$, $R_{yy}$, and $R_{zz}$ are the diagonal components of the numerically computed Ricci tensor.\n\n#### 3. Residual and Convergence Analysis\n\nThe Hamiltonian constraint residual is defined as the pointwise difference $\\mathcal{H}_{\\mathrm{res}} = R_{\\mathrm{num}} - R_{\\mathrm{exact}}$. The overall error is quantified by its discrete root-mean-square norm over the $N^3$ grid points.\nSince all numerical derivatives are computed with a second-order accurate stencil ($O(h^2)$), and the calculation of $R$ involves two successive applications of the derivative operator (from $\\gamma$ to $\\Gamma$, and from $\\Gamma$ to $R$), the leading-order truncation error in $R_{\\mathrm{num}}$ is expected to be proportional to $h^2$. Consequently, the error norm $\\|\\mathcal{H}_{\\mathrm{res}}\\|_2$ should also scale as $h^2 = (1/N)^2$. When the resolution is doubled (i.e., $N \\to 2N$), the error is expected to decrease by a factor of $4$. The empirical order of convergence, $p = \\log_2(E_N / E_{2N})$, should therefore be close to $2$. This is what will be computed for Test Set A.\n\nFor Test Set B ($\\varepsilon=0$), the space is flat, so $R_{\\mathrm{exact}}=0$. The metric is constant, $\\gamma_{ij}=\\delta_{ij}$. The numerical derivative of a constant is zero. Therefore, all Christoffel symbols and the Ricci tensor will be numerically zero (up to machine floating-point precision). The residual norm is expected to be near zero.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical relativity problem by computing Hamiltonian residuals\n    for a conformally flat metric and performing a convergence study.\n    \"\"\"\n\n    def central_diff(f, h, axis):\n        \"\"\"\n        Computes the second-order centered finite difference of a 3D array `f`\n        with grid spacing `h` along a given `axis` with periodic boundary conditions.\n        \"\"\"\n        return (np.roll(f, -1, axis=axis) - np.roll(f, 1, axis=axis)) / (2.0 * h)\n\n    def compute_hamiltonian_residual(N, epsilon):\n        \"\"\"\n        Computes the RMS norm of the Hamiltonian residual for a given grid size N\n        and perturbation parameter epsilon.\n        \"\"\"\n        # 1. Grid setup\n        h = 1.0 / N\n        grid_pts = np.linspace(0.0, 1.0, N, endpoint=False)\n        # Use 'ij' indexing to match axis order with derivative directions\n        # axis 0 -> x, axis 1 -> y, axis 2 -> z\n        X, Y, Z = np.meshgrid(grid_pts, grid_pts, grid_pts, indexing='ij')\n\n        # 2. Compute analytical psi and R_exact\n        S = np.sin(2.0 * np.pi * X) * np.sin(2.0 * np.pi * Y) * np.sin(2.0 * np.pi * Z)\n        psi = 1.0 + epsilon * S\n\n        if abs(epsilon) < 1e-15: # Case for epsilon = 0.0\n            R_exact = np.zeros((N, N, N))\n        else:\n            # R_exact = 24 * (2*pi)^2 * psi^-5 * (psi-1)\n            psi_minus_1 = epsilon * S\n            R_exact = 24.0 * (2.0 * np.pi)**2 * np.power(psi, -5.0) * psi_minus_1\n\n        # 3. Compute metric components\n        psi_inv = 1.0 / psi\n        gamma_inv_diag = np.power(psi, -4.0)\n        \n        # 4. Compute numerical derivatives of psi\n        dpsi_d = [\n            central_diff(psi, h, 0),  # dpsi/dx\n            central_diff(psi, h, 1),  # dpsi/dy\n            central_diff(psi, h, 2)   # dpsi/dz\n        ]\n\n        # 5. Compute Christoffel symbols Gamma^k_{ij}\n        # Gamma[k, i, j] stores the 3D grid data for Gamma^k_ij\n        GAMMA = np.zeros((3, 3, 3, N, N, N))\n        for k in range(3):\n            for i in range(3):\n                for j in range(3):\n                    # Simplified formula for diagonal conformally flat metric\n                    # Gamma^k_ij = 2/psi * (delta_jk * d_i psi + delta_ik * d_j psi - delta_ij * d_k psi)\n                    term1 = (1.0 if j == k else 0.0) * dpsi_d[i]\n                    term2 = (1.0 if i == k else 0.0) * dpsi_d[j]\n                    term3 = (1.0 if i == j else 0.0) * dpsi_d[k]\n                    GAMMA[k, i, j] = 2.0 * psi_inv * (term1 + term2 - term3)\n\n        # 6. Compute Ricci tensor R_ij\n        # R_ij = d_k Gamma^k_ij - d_j Gamma^k_ik + Gamma^k_ij Gamma^l_kl - Gamma^k_il Gamma^l_jk\n        R_ij = np.zeros((3, 3, N, N, N))\n        \n        # Precompute trace Gamma^l_kl for each k\n        trace_G_k = np.zeros((3, N, N, N))\n        for k_idx in range(3):\n            for l_idx in range(3):\n                trace_G_k[k_idx] += GAMMA[l_idx, k_idx, l_idx]\n                \n        for i in range(3):\n            for j in range(3):\n                # Term 1: partial_k Gamma^k_ij (sum over k)\n                term1 = np.zeros((N, N, N))\n                for k in range(3):\n                    term1 += central_diff(GAMMA[k, i, j], h, k)\n\n                # Term 2: partial_j Gamma^k_ik (sum over k)\n                trace_G_i = np.zeros((N, N, N))\n                for k in range(3):\n                    trace_G_i += GAMMA[k, i, k]\n                term2 = central_diff(trace_G_i, h, j)\n\n                # Term 3: Gamma^k_ij * Gamma^l_kl (sum over k)\n                term3 = np.zeros((N, N, N))\n                for k in range(3):\n                    term3 += GAMMA[k, i, j] * trace_G_k[k]\n                    \n                # Term 4: Gamma^k_il * Gamma^l_jk (sum over k, l)\n                term4 = np.zeros((N, N, N))\n                for k in range(3):\n                    for l in range(3):\n                        term4 += GAMMA[k, i, l] * GAMMA[l, j, k]\n                \n                R_ij[i, j] = term1 - term2 + term3 - term4\n\n        # 7. Compute R_num = gamma^ij R_ij\n        R_num = gamma_inv_diag * (R_ij[0, 0] + R_ij[1, 1] + R_ij[2, 2])\n\n        # 8. Compute residual and its RMS norm\n        H_res = R_num - R_exact\n        norm = np.sqrt(np.mean(H_res**2))\n        return norm\n\n    # --- Main execution ---\n    # Test Set A: Convergence study\n    eps_A = 0.1\n    Ns_A = [16, 32, 64]\n    \n    E16 = compute_hamiltonian_residual(Ns_A[0], eps_A)\n    E32 = compute_hamiltonian_residual(Ns_A[1], eps_A)\n    E64 = compute_hamiltonian_residual(Ns_A[2], eps_A)\n    \n    # Compute convergence orders\n    p16_32 = np.log2(E16 / E32) if E32 > 0 else 0.0\n    p32_64 = np.log2(E32 / E64) if E64 > 0 else 0.0\n    \n    # Test Set B: Flat space case\n    eps_B = 0.0\n    N_B = 32\n    E_flat = compute_hamiltonian_residual(N_B, eps_B)\n    \n    # Format and print the final output\n    results = [E16, E32, E64, p16_32, p32_64, E_flat]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}