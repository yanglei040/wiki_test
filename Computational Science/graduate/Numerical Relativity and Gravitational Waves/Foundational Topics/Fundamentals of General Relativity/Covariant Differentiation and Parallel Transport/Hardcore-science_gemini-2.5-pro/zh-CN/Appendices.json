{
    "hands_on_practices": [
        {
            "introduction": "从理论到实践的第一步是理解协变导数的必要性。这个练习  提供了一个在弯曲背景下进行的具体计算，通过对比坐标无关的协变散度与坐标依赖的朴素散度，突显了克里斯托费尔符号作为修正项的关键作用。通过这个练习，你将亲手验证为何在广义相对论中，简单的偏导数必须被协变导数所取代。",
            "id": "3470740",
            "problem": "在数值相对论中使用的一个空间超曲面上，考虑一个共形平直的三维空间度规 $\\gamma_{ij}$，在标准球坐标 $(r,\\theta,\\phi)$ 中写作 $\\gamma_{ij}=\\psi(r)^{4}\\,\\mathrm{diag}\\!\\left(1,\\,r^{2},\\,r^{2}\\sin^{2}\\theta\\right)$，其共形因子为 $\\psi(r)=1+\\frac{M}{2r}$，其中 $M>0$ 是一个常数。设 $V^{i}$ 是一个矢量场，在坐标基中仅有径向分量，由 $V^{r}(r,\\theta,\\phi)=\\dfrac{A\\,r^{2}}{\\psi(r)^{6}}$ 给出，且 $V^{\\theta}=0$，$V^{\\phi}=0$，其中 $A$ 是一个常数。\n\n仅使用 $\\gamma_{ij}$ 的 Levi-Civita 联络的基本定义和矢量场的协变微分定义，完成以下任务：\n- 计算 $V^{i}$ 在此弯曲三维空间度规上的协变散度 $D_{i}V^{i}$。\n- 计算朴素坐标散度 $\\partial_{i}V^{i}$，并用文字解释为什么它在弯曲或曲线空间流形上不代表一个张量标量，而 $D_{i}V^{i}$ 则是。\n- 你最终报告的结果必须是 $D_{i}V^{i}$ 关于 $A$、$M$ 和 $r$ 的显式闭式解析表达式。不需要进行数值计算。\n\n以 $A$、$M$ 和 $r$ 的单个闭式表达式形式提供你的最终答案。",
            "solution": "### 步骤 1：提取已知条件\n- **空间三维黎曼度规**：$\\gamma_{ij} = \\psi(r)^{4}\\,\\mathrm{diag}\\!\\left(1,\\,r^{2},\\,r^{2}\\sin^{2}\\theta\\right)$，位于球坐标 $(r, \\theta, \\phi)$ 中。\n- **共形因子**：$\\psi(r)=1+\\frac{M}{2r}$，其中 $M>0$ 是一个常数。\n- **矢量场**：$V^{r}(r,\\theta,\\phi)=\\dfrac{A\\,r^{2}}{\\psi(r)^{6}}$，其中 $V^{\\theta}=0$ 且 $V^{\\phi}=0$。$A$ 是一个常数。\n- **任务 1**：计算协变散度 $D_{i}V^{i}$。\n- **任务 2**：计算朴素坐标散度 $\\partial_{i}V^{i}$。\n- **任务 3**：解释为何 $D_{i}V^{i}$ 是一个标量而 $\\partial_{i}V^{i}$ 不是。\n- **约束**：仅使用 Levi-Civita 联络和协变微分的基本定义。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题设置在时空 $3+1$ 分解的背景下，这是数值相对论的基石。该度规是各向同性坐标下 Schwarzschild 时空的等时切片的共形平直表示，是一个标准的教科书例子。协变微分、Levi-Civita 联络和张量性质的概念是微分几何和广义相对论的基础。该问题在科学上是合理的。\n- **适定性**：所有必要信息都已提供。度规 $\\gamma_{ij}$ 和矢量场 $V^i$ 已被明确定义。任务是明确的数学计算和概念性解释。存在唯一且有意义的解。\n- **客观性**：该问题以精确的数学语言表述，没有任何主观性或歧义。\n\n### 步骤 3：结论与行动\n该问题有效。将提供完整的解答。\n\n### 解题推导\n\n根据要求，分析分为三个部分：计算协变散度、计算朴素坐标散度，以及关于其张量性质的概念性解释。\n\n#### 第 1 部分：计算协变散度 $D_{i}V^{i}$\n\n逆变矢量场 $V^i$ 的协变导数的基本定义由下式给出\n$$D_j V^i = \\partial_j V^i + \\Gamma^i_{jk} V^k$$\n其中 $\\partial_j$ 表示对坐标 $x^j$ 的偏导数，$\\Gamma^i_{jk}$ 是与度规 $\\gamma_{ij}$ 相关联的 Christoffel 符号（Levi-Civita 联络的分量）。协变散度是该张量的缩并（迹），通过设置 $j=i$ 得到：\n$$D_i V^i = \\partial_i V^i + \\Gamma^i_{ik} V^k$$\n在这里，重复的指标意味着求和。设坐标为 $(x^1, x^2, x^3) = (r, \\theta, \\phi)$。给定的矢量场是 $V^i = (V^r, 0, 0)$。对 $i$ 和 $k$ 的求和展开为：\n$$D_i V^i = (\\partial_r V^r + \\partial_\\theta V^\\theta + \\partial_\\phi V^\\phi) + (\\Gamma^r_{rk}V^k + \\Gamma^\\theta_{\\theta k}V^k + \\Gamma^\\phi_{\\phi k}V^k)$$\n由于 $V^\\theta=0$ 和 $V^\\phi=0$，并且 $V^r$ 仅是 $r$ 的函数，这大大简化了计算。$V^k$ 的唯一非零分量是 $V^r$（当 $k=r$ 时）。\n$$D_i V^i = \\partial_r V^r + \\Gamma^r_{rr}V^r + \\Gamma^\\theta_{\\theta r}V^r + \\Gamma^\\phi_{\\phi r}V^r$$\n$$D_i V^i = \\partial_r V^r + V^r \\left( \\Gamma^r_{rr} + \\Gamma^\\theta_{\\theta r} + \\Gamma^\\phi_{\\phi r} \\right)$$\n为了继续，我们必须计算给定度规 $\\gamma_{ij}$ 所需的 Christoffel 符号。度规分量为：\n$$\\gamma_{rr} = \\psi(r)^4$$\n$$\\gamma_{\\theta\\theta} = r^2\\psi(r)^4$$\n$$\\gamma_{\\phi\\phi} = r^2\\sin^2\\theta\\,\\psi(r)^4$$\nChristoffel 符号由 $\\Gamma^k_{ij} = \\frac{1}{2}\\gamma^{kl}(\\partial_i \\gamma_{jl} + \\partial_j \\gamma_{il} - \\partial_l \\gamma_{ij})$ 给出。对于对角度规，这会简化。让一撇（'）表示对 $r$ 的导数，例如 $\\psi' = \\frac{d\\psi}{dr}$。我们有 $\\psi(r) = 1 + \\frac{M}{2r}$，所以 $\\psi'(r) = -\\frac{M}{2r^2}$。\n\n所需的 Christoffel 符号是：\n1.  $\\Gamma^r_{rr} = \\frac{1}{2}\\gamma^{rr}(\\partial_r \\gamma_{rr}) = \\frac{1}{2}\\frac{1}{\\psi^4}(4\\psi^3\\psi') = \\frac{2\\psi'}{\\psi}$\n2.  $\\Gamma^\\theta_{\\theta r} = \\frac{1}{2}\\gamma^{\\theta\\theta}(\\partial_r \\gamma_{\\theta\\theta}) = \\frac{1}{2}\\frac{1}{r^2\\psi^4}\\partial_r(r^2\\psi^4) = \\frac{1}{2r^2\\psi^4}(2r\\psi^4 + r^2 \\cdot 4\\psi^3\\psi') = \\frac{1}{r} + \\frac{2\\psi'}{\\psi}$\n3.  $\\Gamma^\\phi_{\\phi r} = \\frac{1}{2}\\gamma^{\\phi\\phi}(\\partial_r \\gamma_{\\phi\\phi}) = \\frac{1}{2}\\frac{1}{r^2\\sin^2\\theta\\,\\psi^4}\\partial_r(r^2\\sin^2\\theta\\,\\psi^4) = \\frac{1}{2r^2\\sin^2\\theta\\,\\psi^4}(2r\\sin^2\\theta\\,\\psi^4 + r^2\\sin^2\\theta \\cdot 4\\psi^3\\psi') = \\frac{1}{r} + \\frac{2\\psi'}{\\psi}$\n\n这些符号的和是：\n$$\\Gamma^r_{rr} + \\Gamma^\\theta_{\\theta r} + \\Gamma^\\phi_{\\phi r} = \\left(\\frac{2\\psi'}{\\psi}\\right) + \\left(\\frac{1}{r} + \\frac{2\\psi'}{\\psi}\\right) + \\left(\\frac{1}{r} + \\frac{2\\psi'}{\\psi}\\right) = \\frac{6\\psi'}{\\psi} + \\frac{2}{r}$$\n接下来，我们计算偏导数 $\\partial_r V^r$：\n$$V^r = \\frac{A r^2}{\\psi^6} = A r^2 \\psi^{-6}$$\n$$\\partial_r V^r = A(2r\\psi^{-6} + r^2(-6)\\psi^{-7}\\psi') = \\frac{2Ar}{\\psi^6} - \\frac{6Ar^2\\psi'}{\\psi^7}$$\n现在，我们组合 $D_i V^i$ 的表达式：\n$$D_i V^i = \\left(\\frac{2Ar}{\\psi^6} - \\frac{6Ar^2\\psi'}{\\psi^7}\\right) + \\left(\\frac{Ar^2}{\\psi^6}\\right)\\left(\\frac{6\\psi'}{\\psi} + \\frac{2}{r}\\right)$$\n$$D_i V^i = \\frac{2Ar}{\\psi^6} - \\frac{6Ar^2\\psi'}{\\psi^7} + \\frac{6Ar^2\\psi'}{\\psi^7} + \\frac{2Ar}{\\psi^6}$$\n包含 $\\psi'$ 的项相互抵消，得到一个简单的结果：\n$$D_i V^i = \\frac{4Ar}{\\psi^6}$$\n为了得到以 $A$、$M$ 和 $r$ 表示的最终表达式，我们代入 $\\psi(r) = 1 + \\frac{M}{2r} = \\frac{2r+M}{2r}$：\n$$D_i V^i = \\frac{4Ar}{\\left(\\frac{2r+M}{2r}\\right)^6} = \\frac{4Ar(2r)^6}{(2r+M)^6} = \\frac{4Ar(64r^6)}{(2r+M)^6} = \\frac{256 A r^7}{(2r+M)^6}$$\n\n#### 第 2 部分：计算朴素坐标散度 $\\partial_{i}V^{i}$\n\n朴素坐标散度就是矢量分量偏导数的和：\n$$\\partial_{i}V^{i} = \\partial_r V^r + \\partial_\\theta V^\\theta + \\partial_\\phi V^\\phi$$\n由于 $V^\\theta=0$ 和 $V^\\phi=0$，这简化为：\n$$\\partial_{i}V^{i} = \\partial_r V^r$$\n我们已经在第 1 部分中计算过这一项：\n$$\\partial_r V^r = \\frac{2Ar}{\\psi^6} - \\frac{6Ar^2\\psi'}{\\psi^7}$$\n代入 $\\psi' = -\\frac{M}{2r^2}$：\n$$\\partial_r V^r = \\frac{2Ar}{\\psi^6} - \\frac{6Ar^2}{\\psi^7}\\left(-\\frac{M}{2r^2}\\right) = \\frac{2Ar}{\\psi^6} + \\frac{3AM}{\\psi^7}$$\n这可以写作：\n$$\\partial_r V^r = \\frac{A}{\\psi^7}(2r\\psi + 3M) = \\frac{A}{\\psi^7}\\left(2r\\left(1+\\frac{M}{2r}\\right) + 3M\\right) = \\frac{A}{\\psi^7}(2r+M+3M) = \\frac{A(2r+4M)}{\\psi^7} = \\frac{2A(r+2M)}{(1+\\frac{M}{2r})^7}$$\n\n#### 第 3 部分：$D_i V^i$ 与 $\\partial_i V^i$ 的张量特性\n\n一个标量（0 阶张量）被定义为一个在坐标变换下其在某点的值不变的量。如果 $x^i$ 和 $x'^j$ 是两个坐标系，一个标量 $S$ 必须满足 $S'(x') = S(x)$。\n\n协变散度 $D_i V^i$ 是一个真正的标量。它是由 (1,1) 阶张量 $D_j V^i$ 的迹构造出来的。张量的缩并总会得到一个更低阶的张量。在这种情况下，对一个 (1,1) 阶张量的指标进行缩并会得到一个 0 阶张量，即一个标量。协变导数的数学定义是经过特殊构造的，使得 $D_j V^i$ 按张量方式变换，因此它的迹 $D_i V^i$ 也按标量方式变换：$D'_i V'^i = D_i V^i$。\n\n相比之下，朴素坐标散度 $\\partial_i V^i$ 在弯曲流形或一般曲线坐标系中不是一个标量。它在某点的值取决于所选择的坐标系。要理解这一点，考虑 $\\partial_i V^i$ 在两个坐标系 $x^i$ 和 $x'^j$ 之间的变换。一个逆变矢量的变换方式为 $V'^j = \\frac{\\partial x'^j}{\\partial x^i} V^i$。应用链式法则，散度的变换方式为：\n$$\\partial'_j V'^j = \\partial'_j \\left(\\frac{\\partial x'^j}{\\partial x^i} V^i\\right) = \\frac{\\partial^2 x'^j}{\\partial x'^j \\partial x^i} V^i + \\frac{\\partial x'^j}{\\partial x^i} \\partial'_j V^i = \\frac{\\partial^2 x'^j}{\\partial x^k \\partial x^i}\\frac{\\partial x^k}{\\partial x'^j} V^i + \\frac{\\partial x'^j}{\\partial x^i} \\frac{\\partial x^k}{\\partial x'^j} \\partial_k V^i$$\n$$\\partial'_j V'^j = \\frac{\\partial x^k}{\\partial x'^j}\\frac{\\partial^2 x'^j}{\\partial x^k \\partial x^i} V^i + \\delta^k_i \\partial_k V^i = \\partial_i V^i + \\left(\\frac{\\partial x^k}{\\partial x'^j}\\frac{\\partial^2 x'^j}{\\partial x^k \\partial x^i}\\right) V^i$$\n变换法则是 $\\partial'_j V'^j = \\partial_i V^i + (\\text{额外项})$。由于存在涉及坐标变换二阶导数的额外项，$\\partial_i V^i$ 不会像标量那样变换。这些项仅在特定类型的变换（平直空间中笛卡尔坐标系之间的仿射变换）下为零。在一般情况下，它们不为零。\n\n协变导数定义中的 Christoffel 符号正是用来解释偏导数的非张量变换性质的。它们充当“修正项”，减去了在曲线或弯曲设定中因基矢量变化而产生的坐标依赖效应。其结果 $D_i V^i$ 是一个与坐标无关的几何对象，代表了矢量场的内禀散度。朴素散度 $\\partial_i V^i$ 由于缺少这种修正，是一个依赖于坐标的人为产物，没有内禀的物理或几何意义。",
            "answer": "$$\\boxed{\\frac{256 A r^7}{(2r+M)^6}}$$"
        },
        {
            "introduction": "在数值相对论中，我们处理的是离散网格上的场，因此必须将连续的数学算符转化为离散的数值格式。这个练习  探讨了如何构建协变导数算符的有限差分格式，并确保该格式在给定的精度阶下，依然能保持度规相容性等连续理论的基本属性。这对于编写稳定且精确的数值相对论代码至关重要。",
            "id": "3470737",
            "problem": "你的任务是推导并实现一个二阶有限差分格式，用于计算三维弯曲黎曼流形上逆变矢量场的协变导数，该流形由空间度规进行数值表示。目标是构建一个协变导数的离散算子，该算子明确地包含离散的 Christoffel 符号，并在均匀笛卡尔网格上保持度规相容性至截断误差阶。你的实现必须是一个完整的程序，它输出一行，汇总了下述测试套件的结果。\n\n从微分几何和数值分析的基本定义开始：\n\n- 对于度规 $\\gamma_{ij}$ 的 Levi-Civita 联络，逆变矢量场 $V^{j}$ 的协变导数定义为 $ \\nabla_{i} V^{j} = \\partial_{i} V^{j} + \\Gamma^{j}_{\\;ik} V^{k} $，其中 $\\Gamma^{j}_{\\;ik}$ 是 Christoffel 符号。\n- 度规 $\\gamma_{ij}$ 的 Levi-Civita 联络系数 (Christoffel 符号) 定义为 $ \\Gamma^{k}_{\\;ij} = \\frac{1}{2} \\gamma^{k\\ell} \\left( \\partial_{i} \\gamma_{\\ell j} + \\partial_{j} \\gamma_{\\ell i} - \\partial_{\\ell} \\gamma_{ij} \\right) $，其中 $\\gamma^{k\\ell}$ 是 $\\gamma_{k\\ell}$ 的逆。\n- Levi-Civita 联络的度规相容性表示为 $ \\nabla_{k} \\gamma_{ij} = 0 $。\n\n你必须为空间导数设计二阶精度的中心差分格式，当用其从度规构建离散 Christoffel 符号时，得到的离散协变导数应保持度规相容性至截断误差阶（即，离散的度规协变导数为 $\\mathcal{O}(h^{2})$，其中 $h$ 是均匀网格间距）。具体来说：\n\n- 在 $x$、$y$ 和 $z$ 方向上使用均匀笛卡尔网格，每个维度有 $N$ 个网格点，间距为 $h$，覆盖立方域 $[-L, L]^{3}$。所有坐标都是无量纲的。使用 $L = 1$ 和 $N = 65$，因此 $h = \\frac{2 L}{N - 1}$。\n- 将网格点上标量场 $f$ 的偏导数的二阶中心差分算子定义为 $D_{i} f = \\frac{f(\\mathbf{x} + h \\hat{e}_{i}) - f(\\mathbf{x} - h \\hat{e}_{i})}{2 h}$，对于 $i \\in \\{x, y, z\\}$，其中 $\\hat{e}_{i}$ 是沿 $i$ 方向的单位矢量。\n- 使用上述定义，从度规分量 $\\gamma_{ij}$ 及其离散导数 $D_{i} \\gamma_{jk}$ 构建离散 Christoffel 符号 $\\Gamma^{k}_{\\;ij}$，其中逆度规 $\\gamma^{ij}$ 在同一网格点上取值。\n- 将矢量 $V^{j}$ 的离散协变导数定义为 $(\\nabla_{i} V^{j})_{\\mathrm{d}} = D_{i} V^{j} + \\Gamma^{j}_{\\;ik} V^{k}$，将度规的离散协变导数定义为 $(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} = D_{k} \\gamma_{ij} - \\Gamma^{\\ell}_{\\;ki} \\gamma_{\\ell j} - \\Gamma^{\\ell}_{\\;kj} \\gamma_{i \\ell}$。\n- 在中心网格点评估所有离散量，以避免边界效应。\n\n你的程序必须实现上述格式并计算以下测试用例。对于每个测试用例，计算指定的标量结果，并按如下规定将结果汇总到单行输出中。不涉及物理单位。\n\n测试套件：\n\n- 测试用例 1 (平直空间，矢量平移保真度)：\n  - 度规：$\\gamma_{ij} = \\delta_{ij}$ (分量 $\\gamma_{xx} = 1$, $\\gamma_{yy} = 1$, $\\gamma_{zz} = 1$，且非对角分量为零)。\n  - 矢量：$V^{x}(x,y,z) = \\sin(x)$, $V^{y}(x,y,z) = \\cos(y)$, $V^{z}(x,y,z) = e^{z}$。\n  - 输出量：设 $(\\nabla_{i} V^{j})_{\\mathrm{d}}$ 为离散协变导数，$(\\nabla_{i} V^{j})_{\\mathrm{a}}$ 为在中心点 $\\mathbf{x} = (0,0,0)$ 处由定义和解析导数计算出的精确连续值。计算 Frobenius 范数误差 $E_{1} = \\left\\| (\\nabla_{i} V^{j})_{\\mathrm{d}} - (\\nabla_{i} V^{j})_{\\mathrm{a}} \\right\\|_{F}$，并将此标量 $E_{1}$ 作为浮点数输出。\n\n- 测试用例 2 (共形平直弯曲度规，度规相容性检查)：\n  - 度规：$\\gamma_{ij} = \\psi^{4} \\delta_{ij}$，其中 $\\psi(x,y,z) = 1 + 0.2 \\,(x + y + z)$。\n  - 输出量：在中心网格点计算 $(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}}$，并返回 $E_{2} = \\max_{i,j,k} \\left| (\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} \\right|$ 作为浮点数。\n\n- 测试用例 3 (对角弯曲度规，度规相容性检查)：\n  - 度规：$\\gamma_{xx}(x,y,z) = 1 + 0.2 \\, x^{2}$，$\\gamma_{yy}(x,y,z) = 1 + 0.1 \\, y^{2}$，$\\gamma_{zz}(x,y,z) = e^{0.1 \\, z}$，所有非对角分量为零。\n  - 输出量：在中心网格点计算 $(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}}$，并返回 $E_{3} = \\max_{i,j,k} \\left| (\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} \\right|$ 作为浮点数。\n\n最终输出格式：\n\n- 你的程序应生成单行输出，其中包含按 $[E_{1}, E_{2}, E_{3}]$ 顺序排列、用逗号分隔并括在方括号中的结果。例如，输出行必须类似于 $[a,b,c]$，其中 $a$、$b$ 和 $c$ 是浮点数。\n\n角度单位不适用，也不使用百分比。所有数值结果都是无单位的纯数。计算必须是完全自包含的，并且只能使用中心网格点，避免使用边界格式。最终输出必须是精确的一行，没有多余的文本。",
            "solution": "该问题要求推导并实现一个用于三维黎曼流形上协变导数的二阶有限差分方案。实现的有效性将通过三个测试用例进行评估：一个测量平直空间中矢量平移的准确性，另外两个验证弯曲时空中度规相容性的保持情况。\n\n基本原理是用离散有限差分算子替代连续偏导数。问题指定了在网格点 $\\mathbf{x}$ 处，标量函数 $f$ 相对于笛卡尔坐标 $x^i$ 的偏导数的二阶精度中心差分算子：\n$$\nD_{i} f(\\mathbf{x}) = \\frac{f(\\mathbf{x} + h \\hat{e}_{i}) - f(\\mathbf{x} - h \\hat{e}_{i})}{2 h}\n$$\n此处，$h$ 是均匀网格间距，$\\hat{e}_{i}$ 是第 $i$ 个方向上的单位矢量。该算子的泰勒级数展开表明 $D_{i} f = \\partial_{i} f + \\mathcal{O}(h^2)$，这表示它具有二阶精度。该算子逐分量地应用于张量场。\n\n协变导数的核心组成部分是第二类 Christoffel 符号 $\\Gamma^{k}_{\\;ij}$，它编码了流形的曲率。对于与度规 $\\gamma_{ij}$ 相关联的 Levi-Civita 联络，它们定义如下：\n$$\n\\Gamma^{k}_{\\;ij} = \\frac{1}{2} \\gamma^{k\\ell} \\left( \\partial_{i} \\gamma_{\\ell j} + \\partial_{j} \\gamma_{\\ell i} - \\partial_{\\ell} \\gamma_{ij} \\right)\n$$\n其中 $\\gamma^{k\\ell}$ 是度规张量 $\\gamma_{k\\ell}$ 的逆，即 $\\gamma^{k\\ell} \\gamma_{\\ell m} = \\delta^{k}_{m}$。为了获得离散 Christoffel 符号 $(\\Gamma^{k}_{\\;ij})_{\\mathrm{d}}$，我们将偏导数算子 $\\partial$ 替换为我们的离散算子 $D$：\n$$\n(\\Gamma^{k}_{\\;ij})_{\\mathrm{d}} = \\frac{1}{2} \\gamma^{k\\ell} \\left( D_{i} \\gamma_{\\ell j} + D_{j} \\gamma_{\\ell i} - D_{\\ell} \\gamma_{ij} \\right)\n$$\n在此表达式中，度规 $\\gamma_{ij}$ 及其逆 $\\gamma^{k\\ell}$ 在计算 Christoffel 符号的网格点上进行评估。诸如 $D_{i} \\gamma_{\\ell j}$ 的导数是使用相邻网格点上的 $\\gamma_{\\ell j}$ 值计算的。\n\n有了离散 Christoffel 符号，我们就可以构建离散协变导数算子。对于逆变矢量场 $V^j$，协变导数 $\\nabla_i V^j$ 定义为：\n$$\n\\nabla_{i} V^{j} = \\partial_{i} V^{j} + \\Gamma^{j}_{\\;ik} V^{k}\n$$\n其离散对应物是通过将偏导数和 Christoffel 符号替换为它们的离散版本来形成的：\n$$\n(\\nabla_{i} V^{j})_{\\mathrm{d}} = D_{i} V^{j} + (\\Gamma^{j}_{\\;ik})_{\\mathrm{d}} V^{k}\n$$\n右侧所有项的评估都在单个网格点上进行。\n\nLevi-Civita 联络的一个关键性质是度规相容性，即 $\\nabla_{k} \\gamma_{ij} = 0$。度规张量协变导数的完整表达式是：\n$$\n\\nabla_{k} \\gamma_{ij} = \\partial_{k} \\gamma_{ij} - \\Gamma^{\\ell}_{\\;ki} \\gamma_{\\ell j} - \\Gamma^{\\ell}_{\\;kj} \\gamma_{i \\ell}\n$$\n其离散版本 $(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}}$ 用于测试我们数值方案的一致性：\n$$\n(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} = D_{k} \\gamma_{ij} - (\\Gamma^{\\ell}_{\\;ki})_{\\mathrm{d}} \\gamma_{\\ell j} - (\\Gamma^{\\ell}_{\\;kj})_{\\mathrm{d}} \\gamma_{i \\ell}\n$$\n一个一致的二阶方案应得出 $(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} = \\mathcal{O}(h^2)$，因为离散化导数和 Christoffel 符号所产生的截断误差会以一种在近似阶内遵循底层几何恒等式的方式组合。\n\n问题指定在域 $[-L, L]^3 = [-1, 1]^3$ 的中心网格点进行评估，该域在每个维度上由 $N=65$ 个点的网格进行剖分。网格间距为 $h = \\frac{2L}{N-1} = \\frac{2}{64} = \\frac{1}{32}$。中心网格点对应坐标 $\\mathbf{x} = (0,0,0)$。\n\n实现过程首先为给定的度规和矢量场定义函数。实现一个通用的有限差分函数，它接受一个场分量和一个方向作为输入。然后使用此函数计算所需的度规分量的一阶导数。根据公式组合这些导数，以产生离散的 Christoffel 符号。最后，为每个测试用例组装并评估矢量和度规的离散协变导数。\n\n**测试用例 1：**度规为 $\\gamma_{ij} = \\delta_{ij}$。由于度规是常数，其所有偏导数都为零，这意味着 $\\Gamma^{k}_{\\;ij} = 0$。协变导数简化为偏导数，$\\nabla_i V^j = \\partial_i V^j$。离散实现必须反映这一点，给出 $(\\nabla_i V^j)_{\\mathrm{d}} = D_i V^j$。误差 $E_1 = \\| (\\nabla_{i} V^{j})_{\\mathrm{d}} - (\\nabla_{i} V^{j})_{\\mathrm{a}} \\|_{F} = \\| D_{i} V^{j} - \\partial_{i} V^{j} \\|_{F}$ 衡量了有限差分算子 $D_i$ 应用于给定矢量场 $V^j$ 时的内在截断误差。我们预计此误差的量级为 $\\mathcal{O}(h^2)$。\n\n**测试用例 2 和 3：**这些用例测试非平凡弯曲时空的度规相容性。对于共形平直度规和对角度规，计算量 $E = \\max_{i,j,k} |(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}}|$。如上所述，对于一个一致的二阶方案，我们预计这个值非零但很小，并按 $\\mathcal{O}(h^2)$ 的比例变化。这可以验证离散 Christoffel 符号的构造方式与应用于度规本身的离散导数是一致的。\n\n数值实现将使用索引约定，其中像 $\\gamma_{ij}$、$\\Gamma^k_{ij}$ 和 $\\nabla_k\\gamma_{ij}$ 这样的张量由多维 `numpy` 数组表示，例如 `gamma[i, j]`、`Gamma[k, i, j]` 和 `nabla_k_gamma_ij[k, i, j]`。对重复指标的求和使用显式循环或 `numpy.einsum` 来执行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing discrete covariant derivatives and\n    verifying metric compatibility for given test cases.\n    \"\"\"\n    # Define grid parameters as per the problem statement\n    L = 1.0\n    N = 65\n    h = 2.0 * L / (N - 1)\n    \n    # All computations are at the central point\n    center_pos = np.array([0.0, 0.0, 0.0])\n\n    # General-purpose second-order central difference operator\n    def D(func, i, pos, h_val):\n        \"\"\"\n        Computes the central finite difference of `func` along direction `i`.\n        `func` is a scalar function of a 3D position vector.\n        `i` is the direction index (0 for x, 1 for y, 2 for z).\n        `pos` is the 3D position vector where the derivative is evaluated.\n        `h_val` is the grid spacing.\n        \"\"\"\n        hp = np.copy(pos)\n        hm = np.copy(pos)\n        hp[i] += h_val\n        hm[i] -= h_val\n        return (func(hp) - func(hm)) / (2.0 * h_val)\n\n    # --- Test Case 1: Flat space, vector transport fidelity ---\n    \n    # Vector field components\n    def V_func(pos):\n        x, y, z = pos\n        return np.array([np.sin(x), np.cos(y), np.exp(z)])\n\n    # Analytic covariant derivative (which is just the partial derivative in flat space)\n    # nabla_i V^j = partial_i V^j\n    nabla_V_analytic = np.zeros((3, 3))\n    # At (0,0,0):\n    # d/dx(sin(x)) = cos(0) = 1\n    nabla_V_analytic[0, 0] = 1.0 \n    # d/dy(cos(y)) = -sin(0) = 0\n    nabla_V_analytic[1, 1] = 0.0\n    # d/dz(exp(z)) = exp(0) = 1\n    nabla_V_analytic[2, 2] = 1.0\n    \n    # Discrete covariant derivative. In flat space, Christoffel symbols are zero.\n    # (nabla_i V^j)_d = D_i V^j\n    nabla_V_discrete = np.zeros((3, 3))\n    for i in range(3):\n        for j in range(3):\n            # D_i applied to the j-th component of V\n            nabla_V_discrete[i, j] = D(lambda p: V_func(p)[j], i, center_pos, h)\n\n    # Compute Frobenius norm of the error\n    E1 = np.linalg.norm(nabla_V_discrete - nabla_V_analytic, 'fro')\n\n    # --- Common function for Test Cases 2 and 3 ---\n    def compute_metric_compatibility_error(metric_func, pos, h_val):\n        \"\"\"\n        Computes the maximum absolute value of the discrete covariant\n        derivative of the metric, (nabla_k gamma_ij)_d.\n        \"\"\"\n        # 1. Get metric and its inverse at the central point\n        gamma = metric_func(pos)\n        gamma_inv = np.linalg.inv(gamma)\n        \n        # 2. Compute discrete Christoffel symbols (Gamma^k_ij)_d\n        Gamma = np.zeros((3, 3, 3)) # indices: k, i, j\n        \n        # Pre-compute all required metric derivatives D_i gamma_jk\n        # Dgamma[i, j, k] = D_i(gamma_jk)\n        Dgamma = np.zeros((3, 3, 3))\n        for i_deriv in range(3):\n            for j_idx in range(3):\n                for k_idx in range(3):\n                    # Define a lambda to get the component gamma_jk from the metric function\n                    component_func = lambda p: metric_func(p)[j_idx, k_idx]\n                    Dgamma[i_deriv, j_idx, k_idx] = D(component_func, i_deriv, pos, h_val)\n        \n        for k in range(3):\n            for i in range(3):\n                for j in range(3):\n                    # Gamma^k_ij = 0.5 * gamma^kl * (d_i gamma_lj + d_j gamma_li - d_l gamma_ij)\n                    term = Dgamma[i, j, :] + Dgamma[j, i, :] - Dgamma[:, i, j]\n                    Gamma[k, i, j] = 0.5 * np.dot(gamma_inv[k, :], term)\n\n        # 3. Compute discrete covariant derivative of the metric\n        # (nabla_k gamma_ij)_d = D_k gamma_ij - Gamma^l_ki * gamma_lj - Gamma^l_kj * gamma_il\n        nabla_k_gamma_ij = np.zeros((3, 3, 3)) # indices: k, i, j\n        \n        # Contract Christoffel symbols with metric\n        # Using numpy.einsum for clarity and efficiency\n        # term1[k,i,j] = sum_l Gamma[l,k,i]gamma[l,j]\n        term1 = np.einsum('lki,lj->kij', Gamma, gamma)\n        # term2[k,i,j] = sum_l Gamma[l,k,j]gamma[i,l]\n        term2 = np.einsum('lkj,il->kij', Gamma, gamma)\n        \n        nabla_k_gamma_ij = Dgamma - term1 - term2\n        \n        return np.max(np.abs(nabla_k_gamma_ij))\n\n    # --- Test Case 2: Conformally flat metric ---\n    def metric_2(pos):\n        x, y, z = pos\n        psi = 1.0 + 0.2 * (x + y + z)\n        return (psi**4) * np.identity(3)\n        \n    E2 = compute_metric_compatibility_error(metric_2, center_pos, h)\n\n    # --- Test Case 3: Diagonal curved metric ---\n    def metric_3(pos):\n        x, y, z = pos\n        gamma = np.zeros((3, 3))\n        gamma[0, 0] = 1.0 + 0.2 * x**2\n        gamma[1, 1] = 1.0 + 0.1 * y**2\n        gamma[2, 2] = np.exp(0.1 * z)\n        return gamma\n\n    E3 = compute_metric_compatibility_error(metric_3, center_pos, h)\n\n    # --- Final Output ---\n    # Print results in the specified format\n    results = [E1, E2, E3]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了将平行输运的抽象概念与其深刻的几何意义联系起来，我们可以通过和乐（holonomy）来直观地“感受”曲率。当一个矢量沿闭合回路平行输运后，其指向无法恢复到初始方向，这种现象正是时空弯曲的直接体现。这个练习  提供了一个动手的数值实验，让你能够测量这种效应，并将其与黎曼曲率张量直接联系起来。",
            "id": "3470813",
            "problem": "考虑一个二维空间切片，其在局域坐标 $(x^{1},x^{2})$ 下的度规分量为 $h_{ij}(x^{1},x^{2})$。设 $v^{i}$ 是一个逆变矢量场，它沿着一个分段光滑闭路通过平行输运的条件进行输运。沿着切矢为 $u^{j} = dx^{j}/ds$ 的参数化曲线的平行输运由协变导数约束 $\\nabla_{u} v^{i} = 0$ 定义，即 $dv^{i}/ds + \\Gamma^{i}{}_{jk} u^{j} v^{k} = 0$，其中克里斯托费尔符号 $\\Gamma^{i}{}_{jk}$ 是由度规构造的 Levi-Civita 联络的符号。对于一个与坐标轴对齐的小矩形闭路，定义一个从基点 $(x^{1}_{0},x^{2}_{0})$ 开始的逆时针遍历：首先沿 $+x^{1}$ 方向移动 $\\Delta x^{1}$，然后沿 $+x^{2}$ 方向移动 $\\Delta x^{2}$，再沿 $-x^{1}$ 方向移动 $\\Delta x^{1}$，最后沿 $-x^{2}$ 方向移动 $\\Delta x^{2}$ 回到基点。净和乐可以通过一个单位矢量的带符号旋转角来表征，该矢量初始时在基点处与 $x^{1}$ 方向对齐，旋转角是相对于在基点处由度规定义的标准正交基测量的，单位为弧度。\n\n从协变微分和 Levi-Civita 联络的定义，以及由 $\\Gamma^{i}{}_{jk}$ 构造的黎曼曲率张量 $R^{i}{}_{jkl}$ 出发，我们知道，对于二维曲面内一个足够小的闭路，其净旋转角的主阶项等于高斯曲率 $K$ 在所围区域上的面积分。在二维情况下，黎曼张量满足 $R^{i}{}_{jkl} = K \\left(\\delta^{i}{}_{k} h_{jl} - \\delta^{i}{}_{l} h_{jk}\\right)$，并且旋转角等于 $\\int_{\\Sigma} K \\, \\sqrt{\\det h} \\, dx^{1} dx^{2}$，其方向与遍历方向一致。此处，$\\sqrt{\\det h}$ 是度规的面积密度。角度必须以弧度为单位报告。\n\n实现一个程序，该程序：\n- 使用一种不假设 $\\Gamma^{i}{}_{jk}$ 为常数的稳定方法，沿着矩形闭路的每条边对平行输运方程进行数值积分。\n- 通过在由 $h_{ij}(x^{1}_{0},x^{2}_{0})$ 定义的标准正交标架中比较初始和最终输运的矢量，计算带符号的和乐角。\n- 通过在基点处计算高斯曲率 $K$ 和面积元 $\\sqrt{\\det h}$，并乘以坐标面积 $\\Delta x^{1} \\Delta x^{2}$，来计算预测的带符号旋转角，其符号由闭路方向决定（逆时针为正，顺时针为负）。\n- 对于每个测试用例，输出数值测量的和乐角与基于曲率的预测值之间的带符号差值。\n\n使用以下测试套件。在所有测试用例中，以弧度报告角度，并将最终输出生成为单行，其中包含一个按测试用例顺序排列的四个浮点数的逗号分隔的 Python 列表。四个测试用例是：\n\n1. 平坦二维空间切片：\n   - 度规在各处均为 $h_{ij} = \\mathrm{diag}(1,1)$。\n   - 基点 $(x^{1}_{0},x^{2}_{0}) = (0,0)$。\n   - 矩形尺寸 $\\Delta x^{1} = 10^{-3}$，$\\Delta x^{2} = 2 \\times 10^{-3}$。\n   - 方向：逆时针。\n\n2. 球坐标 $(\\theta,\\phi)$ 下半径为 $r$ 的二维球面：\n   - 度规为 $h_{ij} = \\mathrm{diag}(r^{2}, r^{2} \\sin^{2}\\theta)$，其中 $r = 1$。\n   - 基点 $(\\theta_{0},\\phi_{0}) = (0.7, 0.0)$，单位为弧度。\n   - 矩形尺寸 $\\Delta \\theta = 2 \\times 10^{-3}$，$\\Delta \\phi = 3 \\times 10^{-3}$。\n   - 方向：逆时针。\n\n3. $\\mathbb{R}^{2}$ 上的共形平坦“高斯凸包”度规：\n   - 度规为 $h_{ij} = \\Omega^{2}(x,y)\\, \\mathrm{diag}(1,1)$，其中 $\\Omega(x,y) = \\exp\\left(\\phi(x,y)\\right)$ 且 $\\phi(x,y) = \\varepsilon \\exp\\left(-\\frac{x^{2}+y^{2}}{\\sigma^{2}}\\right)$，这里 $\\varepsilon = 0.01$ 且 $\\sigma = 0.2$。\n   - 基点 $(x^{1}_{0},x^{2}_{0}) = (0.05,-0.04)$。\n   - 矩形尺寸 $\\Delta x^{1} = 10^{-2}$，$\\Delta x^{2} = 8 \\times 10^{-3}$。\n   - 方向：逆时针。\n\n4. 与情况3相同的共形平坦“高斯凸包”度规：\n   - 基点 $(x^{1}_{0},x^{2}_{0}) = (0.05,-0.04)$。\n   - 矩形尺寸 $\\Delta x^{1} = 10^{-3}$，$\\Delta x^{2} = 10^{-3}$。\n   - 方向：顺时针。\n\n你的程序必须：\n- 使用 $\\Gamma^{i}{}_{jk} = \\frac{1}{2} h^{i\\ell} \\left( \\partial_{j} h_{\\ell k} + \\partial_{k} h_{\\ell j} - \\partial_{\\ell} h_{jk} \\right)$ 从 $h_{ij}$ 构造 $\\Gamma^{i}{}_{jk}$，其中 $h^{i\\ell}$ 是逆度规，$\\partial_{j}$ 表示对 $x^{j}$ 的偏导数。\n- 以足以保证数值稳定性的固定步数，沿每条边积分 $dv^{i}/ds = - \\Gamma^{i}{}_{jk} u^{j} v^{k}$。\n- 计算初始和最终矢量相对于基点度规的标准正交分量，并使用这些分量之间的有向角来评估带符号旋转。\n- 将预测的带符号角计算为 $s \\, K(x^{1}_{0},x^{2}_{0}) \\sqrt{\\det h(x^{1}_{0},x^{2}_{0})} \\, \\Delta x^{1} \\Delta x^{2}$，其中对于逆时针方向 $s = +1$，对于顺时针方向 $s = -1$。\n- 以 \"[d1,d2,d3,d4]\" 的格式，在单行中输出测试用例1到4的测量和乐角与基于曲率的预测值之间的带符号差值。\n\n所有数值角度必须以弧度为单位。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，\"[result1,result2,result3,result4]\"）。",
            "solution": "该问题要求对一个矢量沿小矩形闭路平行输运后的和乐与基于局域高斯曲率的理论近似值进行数值比较。我们将通过实现一个用于平行输运方程的高精度数值求解器，并将其结果与解析预测进行比较来解决此问题。\n\n**1. 基本方程**\n\n一个矢量 $v^i$ 沿参数为 $s$ 且切矢为 $u^j = dx^j/ds$ 的曲线的平行输运由以下常微分方程组（ODE system）控制：\n$$\n\\frac{dv^i}{ds} = -\\Gamma^i{}_{jk} u^j v^k\n$$\n其中 $\\Gamma^i{}_{jk}$ 是第二类克里斯托费尔符号，由度规 $h_{ij}$ 导出：\n$$\n\\Gamma^i{}_{jk} = \\frac{1}{2} h^{il} \\left( \\frac{\\partial h_{lk}}{\\partial x^j} + \\frac{\\partial h_{lj}}{\\partial x^k} - \\frac{\\partial h_{jk}}{\\partial x^l} \\right)\n$$\n对于一个包围坐标面积 $A_{\\text{coord}} = \\Delta x^1 \\Delta x^2$ 的小闭路，其净旋转角（和乐）的一阶近似由高斯曲率 $K$ 在所围曲面元 $d\\Sigma$ 上的积分给出：\n$$\n\\theta_{\\text{predicted}} \\approx s \\int K \\, d\\Sigma = s \\int K \\sqrt{\\det h} \\, dx^1 dx^2 \\approx s \\cdot K(x_0) \\sqrt{\\det h(x_0)} \\cdot \\Delta x^1 \\Delta x^2\n$$\n其中，对于逆时针方向 $s$ 为 $+1$，对于顺时针方向 $s$ 为 $-1$，$x_0$ 是闭路的基点。我们的目标是计算数值积分得到的和乐 $\\theta_{\\text{measured}}$ 与此近似值 $\\theta_{\\text{predicted}}$ 之间的差值。\n\n**2. 数值方案**\n\n我们采用四阶 Runge-Kutta (RK4) 积分器来求解平行输运常微分方程组。对于长度为 $L$、步数为 $N$、步长为 $h=L/N$ 的一段路径，以及形式为 $dy/dt = f(t,y)$ 的常微分方程，单步计算如下：\n$$\n\\begin{align*}\nk_1 = f(t_n, y_n) \\\\\nk_2 = f(t_n + h/2, y_n + h/2 \\cdot k_1) \\\\\nk_3 = f(t_n + h/2, y_n + h/2 \\cdot k_2) \\\\\nk_4 = f(t_n + h, y_n + h \\cdot k_3) \\\\\ny_{n+1} = y_n + \\frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n$$\n该方法依次应用于矩形闭路的四个边段。我们使用足够大的步数（例如，$N=200$）来确保数值误差与所测量的物理效应相比可以忽略不计。\n\n为了最大限度地提高精度，我们对每个测试用例都使用克里斯托费尔符号和 $K\\sqrt{\\det h}$ 项的解析表达式，从而避免了数值微分的需要。\n\n**3. 和乐角计算**\n\n初始矢量 $v^i_{\\text{initial}}$ 选为在基点 $x_0$ 处沿 $x^1$ 方向的单位矢量，即其逆变分量为 $(1/\\sqrt{h_{11}(x_0)}, 0)$。沿闭路输运后，得到最终矢量 $v^i_{\\text{final}}$。\n\n为了测量旋转，我们将 $v^i_{\\text{final}}$ 投影到 $x_0$ 处的标准正交标架上。对于对角度规 $h_{ij} = \\mathrm{diag}(h_{11}, h_{22})$，该标架可以由基矢量 $e_{(\\hat{1})}^i = (1/\\sqrt{h_{11}(x_0)}, 0)$ 和 $e_{(\\hat{2})}^i = (0, 1/\\sqrt{h_{22}(x_0)})$ 定义。最终矢量在该标架中的分量为：\n$$\nV_{(\\hat{1})} = h_{11}(x_0) v^1_{\\text{final}} / \\sqrt{h_{11}(x_0)} = \\sqrt{h_{11}(x_0)} \\, v^1_{\\text{final}}, \\quad V_{(\\hat{2})} = h_{22}(x_0) v^2_{\\text{final}} / \\sqrt{h_{22}(x_0)} = \\sqrt{h_{22}(x_0)} \\, v^2_{\\text{final}}\n$$\n带符号的和乐角则计算为 $\\theta_{\\text{measured}} = \\mathrm{atan2}(V_{(\\hat{2})}, V_{(\\hat{1})})$。\n\n**4. 测试用例细节**\n\n*   **情况1 (平坦空间):** 所有克里斯托费尔符号均为零，且 $K=0$。输运是平凡的（$v^i$ 是常数），测量角和预测角都为零。差值恰好为 $0$。\n*   **情况2 (球面):** 使用球坐标 $(\\theta, \\phi)$ 和度规 $h_{ij} = \\mathrm{diag}(1, \\sin^2\\theta)$，我们使用已知的解析克里斯托费尔符号和 $K=1$。预测角项为 $K\\sqrt{\\det h} = \\sin\\theta$。\n*   **情况3  4 (高斯凸包):** 度规是共形平坦的，$h_{ij} = e^{2\\phi} \\delta_{ij}$。克里斯托费尔符号由 $\\phi(x,y) = \\varepsilon \\exp(-(x^2+y^2)/\\sigma^2)$ 的解析导数计算得出。预测角项 $K\\sqrt{\\det h}$ 简化为 $-\\nabla^2\\phi$，我们同样使用其解析表达式。\n\n该实现为四种情况中的每一种计算了 $\\theta_{\\text{measured}} - \\theta_{\\text{predicted}}$，从而衡量了最低阶曲率近似在多大程度上捕捉了完整的和乐。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the holonomy problem for the four specified test cases.\n    Computes the difference between the numerically measured holonomy angle\n    and the curvature-based prediction.\n    \"\"\"\n\n    # Constants for Case 3 and 4\n    EPSILON = 0.01\n    SIGMA = 0.2\n\n    # ==================================\n    # Christoffel and Curvature Functions\n    # ==================================\n\n    def christoffel_flat(coords):\n        return np.zeros((2, 2, 2))\n\n    def predicted_term_flat(coords):\n        return 0.0\n\n    def christoffel_sphere(coords):\n        theta, _ = coords\n        gamma = np.zeros((2, 2, 2))\n        sin_theta = np.sin(theta)\n        if sin_theta == 0:\n            return gamma\n        cos_theta = np.cos(theta)\n        gamma[0, 1, 1] = -sin_theta * cos_theta\n        gamma[1, 0, 1] = cos_theta / sin_theta\n        gamma[1, 1, 0] = cos_theta / sin_theta\n        return gamma\n\n    def predicted_term_sphere(coords):\n        theta, _ = coords\n        return np.sin(theta)\n\n    def phi_bump(coords):\n        x, y = coords\n        r_sq = x**2 + y**2\n        return EPSILON * np.exp(-r_sq / SIGMA**2)\n\n    def christoffel_bump(coords):\n        x, y = coords\n        gamma = np.zeros((2, 2, 2))\n        p = phi_bump(coords)\n        dp_dx = p * (-2 * x / SIGMA**2)\n        dp_dy =p * (-2 * y / SIGMA**2)\n\n        gamma[0, 0, 0] = dp_dx\n        gamma[1, 0, 0] = -dp_dy\n        gamma[0, 1, 1] = -dp_dx\n        gamma[1, 1, 1] = dp_dy\n        gamma[0, 0, 1] = dp_dy\n        gamma[0, 1, 0] = dp_dy\n        gamma[1, 0, 1] = dp_dx\n        gamma[1, 1, 0] = dp_dx\n        return gamma\n\n    def predicted_term_bump(coords):\n        x, y = coords\n        r_sq = x**2 + y**2\n        p = phi_bump(coords)\n        lap_phi = p * (4 * r_sq / SIGMA**4 - 4 / SIGMA**2)\n        return -lap_phi\n\n    # ==================================\n    # ODE Integrator Framework\n    # ==================================\n\n    def parallel_transport_rhs(v, coords, u, christoffel_func):\n        gamma = christoffel_func(coords)\n        dv = np.zeros(2, dtype=np.float64)\n        for i in range(2):\n            dv[i] = -np.sum(gamma[i, :, :] * np.outer(u, v))\n        return dv\n\n    def rk4_step(f, t, y, h, *f_args):\n        k1 = f(t, y, *f_args)\n        k2 = f(t + h / 2, y + h / 2 * k1, *f_args)\n        k3 = f(t + h / 2, y + h / 2 * k2, *f_args)\n        k4 = f(t + h, y + h * k3, *f_args)\n        return y + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def rhs_segment(s, v, start_point, u, christoffel_func):\n        coords = start_point + s * u\n        return parallel_transport_rhs(v, coords, u, christoffel_func)\n\n    def integrate_segment(v_start, segment_params, christoffel_func, num_steps):\n        v = v_start\n        h = segment_params['len'] / num_steps\n        for i in range(num_steps):\n            s_current = i * h\n            v = rk4_step(rhs_segment, s_current, v, h,\n                         segment_params['start'], segment_params['u'], christoffel_func)\n        return v\n    \n    # ==================================\n    # Main Solver per Case\n    # ==================================\n\n    def solve_case(case_params, num_steps_per_segment=200):\n        name = case_params[\"name\"]\n        base_point = np.array(case_params[\"base_point\"], dtype=np.float64)\n        delta = np.array(case_params[\"delta\"], dtype=np.float64)\n        orientation = case_params[\"orientation\"]\n\n        if name == \"Flat\":\n            metric_func = lambda c: np.identity(2)\n            christoffel_func = christoffel_flat\n            predicted_term_func = predicted_term_flat\n        elif name == \"Sphere\":\n            metric_func = lambda c: np.diag([1.0, np.sin(c[0])**2])\n            christoffel_func = christoffel_sphere\n            predicted_term_func = predicted_term_sphere\n        elif name == \"GaussianBump\":\n            metric_func = lambda c: np.diag([np.exp(2 * phi_bump(c))] * 2)\n            christoffel_func = christoffel_bump\n            predicted_term_func = predicted_term_bump\n        else:\n            raise ValueError(f\"Unknown case name: {name}\")\n\n        predicted_term_at_base = predicted_term_func(base_point)\n        predicted_angle = orientation * predicted_term_at_base * delta[0] * delta[1]\n\n        h0 = metric_func(base_point)\n        v_start = np.array([1.0 / np.sqrt(h0[0, 0]), 0.0], dtype=np.float64)\n\n        p0 = base_point\n        p1 = base_point + np.array([delta[0], 0.0])\n        p2 = base_point + delta\n        p3 = base_point + np.array([0.0, delta[1]])\n\n        if orientation == 1:  # Counter-clockwise\n            segments = [\n                {\"start\": p0, \"u\": np.array([1., 0.]), \"len\": delta[0]},\n                {\"start\": p1, \"u\": np.array([0., 1.]), \"len\": delta[1]},\n                {\"start\": p2, \"u\": np.array([-1., 0.]), \"len\": delta[0]},\n                {\"start\": p3, \"u\": np.array([0., -1.]), \"len\": delta[1]},\n            ]\n        else:  # Clockwise\n            segments = [\n                {\"start\": p0, \"u\": np.array([0., 1.]), \"len\": delta[1]},\n                {\"start\": p3, \"u\": np.array([1., 0.]), \"len\": delta[0]},\n                {\"start\": p2, \"u\": np.array([0., -1.]), \"len\": delta[1]},\n                {\"start\": p1, \"u\": np.array([-1., 0.]), \"len\": delta[0]},\n            ]\n\n        v_current = v_start\n        for seg in segments:\n            v_current = integrate_segment(v_current, seg, christoffel_func, num_steps_per_segment)\n        v_final = v_current\n\n        v_final_ortho = np.array([\n            np.sqrt(h0[0, 0]) * v_final[0],\n            np.sqrt(h0[1, 1]) * v_final[1]\n        ])\n        \n        measured_angle = np.arctan2(v_final_ortho[1], v_final_ortho[0])\n\n        return measured_angle - predicted_angle\n\n    # ==================================\n    # Test Cases Execution\n    # ==================================\n\n    test_cases = [\n        {\n            \"name\": \"Flat\",\n            \"base_point\": (0.0, 0.0),\n            \"delta\": (1e-3, 2e-3),\n            \"orientation\": 1\n        },\n        {\n            \"name\": \"Sphere\",\n            \"base_point\": (0.7, 0.0),\n            \"delta\": (2e-3, 3e-3),\n            \"orientation\": 1\n        },\n        {\n            \"name\": \"GaussianBump\",\n            \"base_point\": (0.05, -0.04),\n            \"delta\": (1e-2, 8e-3),\n            \"orientation\": 1\n        },\n        {\n            \"name\": \"GaussianBump\",\n            \"base_point\": (0.05, -0.04),\n            \"delta\": (1e-3, 1e-3),\n            \"orientation\": -1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        difference = solve_case(case)\n        results.append(difference)\n\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}