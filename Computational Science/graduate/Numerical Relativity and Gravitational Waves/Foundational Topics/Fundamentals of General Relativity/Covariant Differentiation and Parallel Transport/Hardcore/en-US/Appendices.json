{
    "hands_on_practices": [
        {
            "introduction": "The transition from flat to curved space necessitates a new type of derivative that respects the tensorial nature of physical quantities. This first exercise provides a direct, calculational experience contrasting the naive partial derivative with the correctly formulated covariant derivative . By computing the covariant divergence of a vector field on a standard curved background, you will solidify your understanding of why Christoffel symbols are essential for constructing coordinate-independent, physical observables.",
            "id": "3470740",
            "problem": "On a spatial hypersurface used in numerical relativity, consider the conformally flat three-metric $\\gamma_{ij}$ written in standard spherical coordinates $(r,\\theta,\\phi)$ as $\\gamma_{ij}=\\psi(r)^{4}\\,\\mathrm{diag}\\!\\left(1,\\,r^{2},\\,r^{2}\\sin^{2}\\theta\\right)$ with conformal factor $\\psi(r)=1+\\frac{M}{2r}$, where $M>0$ is a constant. Let $V^{i}$ be a vector field with only a radial component in the coordinate basis, given by $V^{r}(r,\\theta,\\phi)=\\dfrac{A\\,r^{2}}{\\psi(r)^{6}}$ and $V^{\\theta}=0$, $V^{\\phi}=0$, where $A$ is a constant.\n\nUsing only the fundamental definition of the Levi-Civita connection of $\\gamma_{ij}$ and the definition of covariant differentiation of a vector field, do the following:\n- Compute the covariant divergence $D_{i}V^{i}$ of $V^{i}$ on this curved three-metric.\n- Compute the naive coordinate divergence $\\partial_{i}V^{i}$ and explain, in words, why it does not represent a tensorial scalar on a curved or curvilinear spatial manifold, whereas $D_{i}V^{i}$ does.\n- Your final reported result must be the explicit closed-form analytic expression for $D_{i}V^{i}$ in terms of $A$, $M$, and $r$. No numerical evaluation is required.\n\nProvide your final answer as a single closed-form expression in terms of $A$, $M$, and $r$.",
            "solution": "### Step 1: Extract Givens\n- **Spatial three-metric**: $\\gamma_{ij} = \\psi(r)^{4}\\,\\mathrm{diag}\\!\\left(1,\\,r^{2},\\,r^{2}\\sin^{2}\\theta\\right)$ in spherical coordinates $(r, \\theta, \\phi)$.\n- **Conformal factor**: $\\psi(r)=1+\\frac{M}{2r}$, where $M>0$ is a constant.\n- **Vector field**: $V^{r}(r,\\theta,\\phi)=\\dfrac{A\\,r^{2}}{\\psi(r)^{6}}$, with $V^{\\theta}=0$ and $V^{\\phi}=0$. $A$ is a constant.\n- **Task 1**: Compute the covariant divergence $D_{i}V^{i}$.\n- **Task 2**: Compute the naive coordinate divergence $\\partial_{i}V^{i}$.\n- **Task 3**: Explain why $D_{i}V^{i}$ is a scalar and $\\partial_{i}V^{i}$ is not.\n- **Constraint**: Use only the fundamental definitions of the Levi-Civita connection and covariant differentiation.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is set in the context of the $3+1$ decomposition of spacetime, a cornerstone of numerical relativity. The metric is the conformally flat representation of a constant-time slice of the Schwarzschild spacetime in isotropic coordinates, a standard textbook example. The concepts of covariant differentiation, Levi-Civita connection, and tensorial properties are fundamental in differential geometry and general relativity. The problem is scientifically sound.\n- **Well-Posed**: All necessary information is provided. The metric $\\gamma_{ij}$ and the vector field $V^i$ are explicitly defined. The tasks are unambiguous mathematical computations and a conceptual explanation. A unique, meaningful solution exists.\n- **Objective**: The problem is formulated in precise mathematical language, free from any subjectivity or ambiguity.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\n\nThe analysis is divided into three parts as requested: computation of the covariant divergence, computation of the naive coordinate divergence, and a conceptual explanation of their tensorial nature.\n\n#### Part 1: Computation of the Covariant Divergence $D_{i}V^{i}$\n\nThe fundamental definition of the covariant derivative of a contravariant vector field $V^i$ is given by\n$$D_j V^i = \\partial_j V^i + \\Gamma^i_{jk} V^k$$\nwhere $\\partial_j$ denotes the partial derivative with respect to the coordinate $x^j$, and $\\Gamma^i_{jk}$ are the Christoffel symbols (components of the Levi-Civita connection) associated with the metric $\\gamma_{ij}$. The covariant divergence is the contraction (trace) of this tensor, obtained by setting $j=i$:\n$$D_i V^i = \\partial_i V^i + \\Gamma^i_{ik} V^k$$\nHere, repeated indices imply summation. Let the coordinates be $(x^1, x^2, x^3) = (r, \\theta, \\phi)$. The given vector field is $V^i = (V^r, 0, 0)$. The summation over $i$ and $k$ expands as:\n$$D_i V^i = (\\partial_r V^r + \\partial_\\theta V^\\theta + \\partial_\\phi V^\\phi) + (\\Gamma^r_{rk}V^k + \\Gamma^\\theta_{\\theta k}V^k + \\Gamma^\\phi_{\\phi k}V^k)$$\nSince $V^\\theta=0$ and $V^\\phi=0$, and $V^r$ is a function of $r$ only, this simplifies significantly. The only non-zero component of $V^k$ is $V^r$ (when $k=r$).\n$$D_i V^i = \\partial_r V^r + \\Gamma^r_{rr}V^r + \\Gamma^\\theta_{\\theta r}V^r + \\Gamma^\\phi_{\\phi r}V^r$$\n$$D_i V^i = \\partial_r V^r + V^r \\left( \\Gamma^r_{rr} + \\Gamma^\\theta_{\\theta r} + \\Gamma^\\phi_{\\phi r} \\right)$$\nTo proceed, we must compute the necessary Christoffel symbols for the given metric $\\gamma_{ij}$. The metric components are:\n$$\\gamma_{rr} = \\psi(r)^4$$\n$$\\gamma_{\\theta\\theta} = r^2\\psi(r)^4$$\n$$\\gamma_{\\phi\\phi} = r^2\\sin^2\\theta\\,\\psi(r)^4$$\nThe Christoffel symbols are given by $\\Gamma^k_{ij} = \\frac{1}{2}\\gamma^{kl}(\\partial_i \\gamma_{jl} + \\partial_j \\gamma_{il} - \\partial_l \\gamma_{ij})$. For a diagonal metric, this simplifies. Let a prime denote a derivative with respect to $r$, e.g., $\\psi' = \\frac{d\\psi}{dr}$. We have $\\psi(r) = 1 + \\frac{M}{2r}$, so $\\psi'(r) = -\\frac{M}{2r^2}$.\n\nThe required Christoffel symbols are:\n1.  $\\Gamma^r_{rr} = \\frac{1}{2}\\gamma^{rr}(\\partial_r \\gamma_{rr}) = \\frac{1}{2}\\frac{1}{\\psi^4}(4\\psi^3\\psi') = \\frac{2\\psi'}{\\psi}$\n2.  $\\Gamma^\\theta_{\\theta r} = \\frac{1}{2}\\gamma^{\\theta\\theta}(\\partial_r \\gamma_{\\theta\\theta}) = \\frac{1}{2}\\frac{1}{r^2\\psi^4}\\partial_r(r^2\\psi^4) = \\frac{1}{2r^2\\psi^4}(2r\\psi^4 + r^2 \\cdot 4\\psi^3\\psi') = \\frac{1}{r} + \\frac{2\\psi'}{\\psi}$\n3.  $\\Gamma^\\phi_{\\phi r} = \\frac{1}{2}\\gamma^{\\phi\\phi}(\\partial_r \\gamma_{\\phi\\phi}) = \\frac{1}{2}\\frac{1}{r^2\\sin^2\\theta\\,\\psi^4}\\partial_r(r^2\\sin^2\\theta\\,\\psi^4) = \\frac{1}{2r^2\\sin^2\\theta\\,\\psi^4}(2r\\sin^2\\theta\\,\\psi^4 + r^2\\sin^2\\theta \\cdot 4\\psi^3\\psi') = \\frac{1}{r} + \\frac{2\\psi'}{\\psi}$\n\nThe sum of these symbols is:\n$$\\Gamma^r_{rr} + \\Gamma^\\theta_{\\theta r} + \\Gamma^\\phi_{\\phi r} = \\left(\\frac{2\\psi'}{\\psi}\\right) + \\left(\\frac{1}{r} + \\frac{2\\psi'}{\\psi}\\right) + \\left(\\frac{1}{r} + \\frac{2\\psi'}{\\psi}\\right) = \\frac{6\\psi'}{\\psi} + \\frac{2}{r}$$\nNext, we compute the partial derivative $\\partial_r V^r$:\n$$V^r = \\frac{A r^2}{\\psi^6} = A r^2 \\psi^{-6}$$\n$$\\partial_r V^r = A(2r\\psi^{-6} + r^2(-6)\\psi^{-7}\\psi') = \\frac{2Ar}{\\psi^6} - \\frac{6Ar^2\\psi'}{\\psi^7}$$\nNow, we assemble the expression for $D_i V^i$:\n$$D_i V^i = \\left(\\frac{2Ar}{\\psi^6} - \\frac{6Ar^2\\psi'}{\\psi^7}\\right) + \\left(\\frac{Ar^2}{\\psi^6}\\right)\\left(\\frac{6\\psi'}{\\psi} + \\frac{2}{r}\\right)$$\n$$D_i V^i = \\frac{2Ar}{\\psi^6} - \\frac{6Ar^2\\psi'}{\\psi^7} + \\frac{6Ar^2\\psi'}{\\psi^7} + \\frac{2Ar}{\\psi^6}$$\nThe terms involving $\\psi'$ cancel, yielding a simple result:\n$$D_i V^i = \\frac{4Ar}{\\psi^6}$$\nTo obtain the final expression in terms of $A$, $M$, and $r$, we substitute $\\psi(r) = 1 + \\frac{M}{2r} = \\frac{2r+M}{2r}$:\n$$D_i V^i = \\frac{4Ar}{\\left(\\frac{2r+M}{2r}\\right)^6} = \\frac{4Ar(2r)^6}{(2r+M)^6} = \\frac{4Ar(64r^6)}{(2r+M)^6} = \\frac{256 A r^7}{(2r+M)^6}$$\n\n#### Part 2: Computation of the Naive Coordinate Divergence $\\partial_{i}V^{i}$\n\nThe naive coordinate divergence is simply the sum of partial derivatives of the vector components:\n$$\\partial_{i}V^{i} = \\partial_r V^r + \\partial_\\theta V^\\theta + \\partial_\\phi V^\\phi$$\nSince $V^\\theta=0$ and $V^\\phi=0$, this reduces to:\n$$\\partial_{i}V^{i} = \\partial_r V^r$$\nWe have already calculated this term in Part 1:\n$$\\partial_r V^r = \\frac{2Ar}{\\psi^6} - \\frac{6Ar^2\\psi'}{\\psi^7}$$\nSubstituting $\\psi' = -\\frac{M}{2r^2}$:\n$$\\partial_r V^r = \\frac{2Ar}{\\psi^6} - \\frac{6Ar^2}{\\psi^7}\\left(-\\frac{M}{2r^2}\\right) = \\frac{2Ar}{\\psi^6} + \\frac{3AM}{\\psi^7}$$\nThis can be written as:\n$$\\partial_r V^r = \\frac{A}{\\psi^7}(2r\\psi + 3M) = \\frac{A}{\\psi^7}\\left(2r\\left(1+\\frac{M}{2r}\\right) + 3M\\right) = \\frac{A}{\\psi^7}(2r+M+3M) = \\frac{A(2r+4M)}{\\psi^7} = \\frac{2A(r+2M)}{(1+\\frac{M}{2r})^7}$$\n\n#### Part 3: Tensorial Character of $D_i V^i$ vs. $\\partial_i V^i$\n\nA scalar quantity (a rank-$0$ tensor) is defined as a quantity whose value at a point is invariant under coordinate transformations. If $x^i$ and $x'^j$ are two coordinate systems, a scalar $S$ must satisfy $S'(x') = S(x)$.\n\nThe covariant divergence $D_i V^i$ is a true scalar. It is constructed as the trace of the rank-$(1,1)$ tensor $D_j V^i$. The contraction of a tensor always results in a tensor of lower rank. In this case, contracting the indices of a rank-$(1,1)$ tensor yields a rank-$0$ tensor, i.e., a scalar. The mathematical definition of the covariant derivative is specifically constructed so that $D_j V^i$ transforms as a tensor, and consequently its trace, $D_i V^i$, transforms as a scalar: $D'_i V'^i = D_i V^i$.\n\nIn contrast, the naive coordinate divergence $\\partial_i V^i$ is not a scalar quantity on a curved manifold or in a general curvilinear coordinate system. Its value at a point depends on the chosen coordinate system. To see this, consider the transformation of $\\partial_i V^i$ between two coordinate systems, $x^i$ and $x'^j$. A contravariant vector transforms as $V'^j = \\frac{\\partial x'^j}{\\partial x^i} V^i$. Applying the chain rule, the divergence transforms as:\n$$\\partial'_j V'^j = \\partial'_j \\left(\\frac{\\partial x'^j}{\\partial x^i} V^i\\right) = \\frac{\\partial^2 x'^j}{\\partial x'^j \\partial x^i} V^i + \\frac{\\partial x'^j}{\\partial x^i} \\partial'_j V^i = \\frac{\\partial^2 x'^j}{\\partial x^k \\partial x^i}\\frac{\\partial x^k}{\\partial x'^j} V^i + \\frac{\\partial x'^j}{\\partial x^i} \\frac{\\partial x^k}{\\partial x'^j} \\partial_k V^i$$\n$$\\partial'_j V'^j = \\frac{\\partial x^k}{\\partial x'^j}\\frac{\\partial^2 x'^j}{\\partial x^k \\partial x^i} V^i + \\delta^k_i \\partial_k V^i = \\partial_i V^i + \\left(\\frac{\\partial x^k}{\\partial x'^j}\\frac{\\partial^2 x'^j}{\\partial x^k \\partial x^i}\\right) V^i$$\nThe transformation law is $\\partial'_j V'^j = \\partial_i V^i + (\\text{extra terms})$. Because of the presence of the extra terms involving second derivatives of the coordinate transformation, $\\partial_i V^i$ does not transform as a scalar. These terms are zero only for a specific class of transformations (affine transformations between Cartesian systems in flat space). In general, they are non-zero.\n\nThe Christoffel symbols in the definition of the covariant derivative are precisely the objects that account for the non-tensorial transformation properties of partial derivatives. They act as \"correction terms\" that subtract out the coordinate-dependent effects arising from the changing basis vectors in a curvilinear or curved setting. The result, $D_i V^i$, is a coordinate-independent, geometric object representing the intrinsic divergence of the vector field. The naive divergence $\\partial_i V^i$, lacking this correction, is a coordinate-dependent artifact with no intrinsic physical or geometric meaning.",
            "answer": "$$\\boxed{\\frac{256 A r^7}{(2r+M)^6}}$$"
        },
        {
            "introduction": "In numerical relativity, continuum equations must be translated into discrete algorithms that can be solved on a computer. This practice focuses on the fundamental task of building a discrete version of the covariant derivative operator using finite-difference stencils . You will implement the discrete Christoffel symbols and verify a crucial property—metric compatibility—to see how foundational geometric principles are maintained in a numerical context.",
            "id": "3470737",
            "problem": "You are tasked with deriving and implementing a second-order finite-difference stencil for the covariant derivative of a contravariant vector field on a three-dimensional curved Riemannian manifold, represented numerically by a spatial metric. The goal is to construct a discrete operator for the covariant derivative that explicitly incorporates discrete Christoffel symbols and preserves metric compatibility to truncation order on a uniform Cartesian grid. Your implementation must be a complete program that outputs a single line aggregating the results from a test suite described below.\n\nBegin from fundamental definitions in differential geometry and numerical analysis:\n\n- The covariant derivative of a contravariant vector field $V^{j}$ with respect to the Levi-Civita connection of a metric $\\gamma_{ij}$ is defined by:\n$$ \\nabla_{i} V^{j} = \\partial_{i} V^{j} + \\Gamma^{j}_{ik} V^{k} $$\nwhere $\\Gamma^{j}_{ik}$ are the Christoffel symbols.\n- The Levi-Civita connection coefficients (Christoffel symbols) for a metric $\\gamma_{ij}$ are defined by:\n$$ \\Gamma^{k}_{ij} = \\frac{1}{2} \\gamma^{k\\ell} \\left( \\partial_{i} \\gamma_{\\ell j} + \\partial_{j} \\gamma_{\\ell i} - \\partial_{\\ell} \\gamma_{ij} \\right) $$\nwhere $\\gamma^{k\\ell}$ is the inverse of $\\gamma_{k\\ell}$.\n- Metric compatibility for the Levi-Civita connection is expressed as:\n$$ \\nabla_{k} \\gamma_{ij} = 0 $$\n\nYou must design second-order accurate, central-difference stencils for spatial derivatives that, when used to build the discrete Christoffel symbols from the metric, yield a discrete covariant derivative that preserves metric compatibility to truncation order (i.e., the discrete metric covariant derivative is $\\mathcal{O}(h^{2})$ where $h$ is the uniform grid spacing). Specifically:\n\n- Use a uniform Cartesian grid in $x$, $y$, and $z$ with $N$ grid points per dimension and spacing $h$, covering the cubic domain $[-L, L]^{3}$. All coordinates are dimensionless. Use $L = 1$ and $N = 65$, so that $h = \\frac{2 L}{N - 1}$.\n- Define the second-order central-difference operator for the partial derivative of a scalar field $f$ at a grid point as:\n$$ D_{i} f = \\frac{f(\\mathbf{x} + h \\hat{e}_{i}) - f(\\mathbf{x} - h \\hat{e}_{i})}{2 h} $$\nfor $i \\in \\{x, y, z\\}$, where $\\hat{e}_{i}$ is the unit vector along direction $i$.\n- Build the discrete Christoffel symbols $\\Gamma^{k}_{ij}$ from the metric components $\\gamma_{ij}$ and their discrete derivatives $D_{i} \\gamma_{jk}$ using the definition above, with the inverse metric $\\gamma^{ij}$ taken at the same grid point.\n- Define the discrete covariant derivative of a vector $V^{j}$ by:\n$$ (\\nabla_{i} V^{j})_{\\mathrm{d}} = D_{i} V^{j} + \\Gamma^{j}_{ik} V^{k} $$\nand the discrete covariant derivative of the metric by:\n$$ (\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} = D_{k} \\gamma_{ij} - \\Gamma^{\\ell}_{ki} \\gamma_{\\ell j} - \\Gamma^{\\ell}_{kj} \\gamma_{i \\ell} $$\n- Evaluate all discrete quantities at the central grid point to avoid boundary effects.\n\nYour program must implement the above stencils and compute the following test cases. For each test case, compute the specified scalar result, and aggregate the results into a single output line as specified below. No physical units are involved.\n\nTest suite:\n\n- Test case $1$ (flat space, vector transport fidelity):\n  - Metric: $\\gamma_{ij} = \\delta_{ij}$ (the components $\\gamma_{xx} = 1$, $\\gamma_{yy} = 1$, $\\gamma_{zz} = 1$, and off-diagonal components vanish).\n  - Vector: $V^{x}(x,y,z) = \\sin(x)$, $V^{y}(x,y,z) = \\cos(y)$, $V^{z}(x,y,z) = e^{z}$.\n  - Quantity to output: Let $(\\nabla_{i} V^{j})_{\\mathrm{d}}$ be the discrete covariant derivative and let $(\\nabla_{i} V^{j})_{\\mathrm{a}}$ denote the exact continuum value at the central point $\\mathbf{x} = (0,0,0)$, computed from the definitions and analytic derivatives. Compute the Frobenius norm error $E_{1} = \\left\\| (\\nabla_{i} V^{j})_{\\mathrm{d}} - (\\nabla_{i} V^{j})_{\\mathrm{a}} \\right\\|_{F}$ and output this scalar $E_{1}$ as a floating-point number.\n\n- Test case $2$ (conformally flat curved metric, metric compatibility check):\n  - Metric: $\\gamma_{ij} = \\psi^{4} \\delta_{ij}$ with $\\psi(x,y,z) = 1 + 0.2 \\,(x + y + z)$.\n  - Quantity to output: Compute $(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}}$ at the central grid point and return $E_{2} = \\max_{i,j,k} \\left| (\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} \\right|$ as a floating-point number.\n\n- Test case $3$ (diagonal curved metric, metric compatibility check):\n  - Metric: $\\gamma_{xx}(x,y,z) = 1 + 0.2 \\, x^{2}$, $\\gamma_{yy}(x,y,z) = 1 + 0.1 \\, y^{2}$, $\\gamma_{zz}(x,y,z) = e^{0.1 \\, z}$, with all off-diagonal components zero.\n  - Quantity to output: Compute $(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}}$ at the central grid point and return $E_{3} = \\max_{i,j,k} \\left| (\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} \\right|$ as a floating-point number.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[E_{1}, E_{2}, E_{3}]$. For example, an output line must look like $[a,b,c]$ where $a$, $b$, and $c$ are floating-point numbers.\n\nAngle units are not applicable, and no percentages are used. All numerical results are pure numbers without units. The computation must be fully self-contained and must use the central grid point only, avoiding boundary stencils. The final output must be exactly one line with no extra text.",
            "solution": "The problem requires the derivation and implementation of a second-order finite-difference scheme for the covariant derivative on a three-dimensional Riemannian manifold. The validity of the implementation will be assessed through three test cases: one measuring the accuracy of vector transport in flat space, and two verifying the preservation of metric compatibility for curved spacetimes.\n\nThe fundamental principle is to replace continuous partial derivatives with discrete finite-difference operators. The problem specifies a second-order accurate central-difference operator for the partial derivative of a scalar function $f$ with respect to a Cartesian coordinate $x^i$, evaluated at a grid point $\\mathbf{x}$:\n$$\nD_{i} f(\\mathbf{x}) = \\frac{f(\\mathbf{x} + h \\hat{e}_{i}) - f(\\mathbf{x} - h \\hat{e}_{i})}{2 h}\n$$\nHere, $h$ is the uniform grid spacing and $\\hat{e}_{i}$ is the unit vector in the $i$-th direction. The Taylor series expansion of this operator reveals that $D_{i} f = \\partial_{i} f + \\mathcal{O}(h^2)$, indicating second-order accuracy. This operator is applied component-wise to tensor fields.\n\nThe central component of the covariant derivative is the set of Christoffel symbols of the second kind, $\\Gamma^{k}_{ij}$, which encode the curvature of the manifold. For the Levi-Civita connection associated with a metric $\\gamma_{ij}$, they are defined as:\n$$\n\\Gamma^{k}_{ij} = \\frac{1}{2} \\gamma^{k\\ell} \\left( \\partial_{i} \\gamma_{\\ell j} + \\partial_{j} \\gamma_{\\ell i} - \\partial_{\\ell} \\gamma_{ij} \\right)\n$$\nwhere $\\gamma^{k\\ell}$ is the inverse of the metric tensor $\\gamma_{k\\ell}$, i.e., $\\gamma^{k\\ell} \\gamma_{\\ell m} = \\delta^{k}_{m}$. To obtain the discrete Christoffel symbols, $(\\Gamma^{k}_{ij})_{\\mathrm{d}}$, we substitute the partial derivative operator $\\partial$ with our discrete operator $D$:\n$$\n(\\Gamma^{k}_{ij})_{\\mathrm{d}} = \\frac{1}{2} \\gamma^{k\\ell} \\left( D_{i} \\gamma_{\\ell j} + D_{j} \\gamma_{\\ell i} - D_{\\ell} \\gamma_{ij} \\right)\n$$\nIn this expression, the metric $\\gamma_{ij}$ and its inverse $\\gamma^{k\\ell}$ are evaluated at the grid point where the Christoffel symbol is being computed. The derivatives, such as $D_{i} \\gamma_{\\ell j}$, are computed using the values of $\\gamma_{\\ell j}$ at neighboring grid points.\n\nWith the discrete Christoffel symbols, we can construct the discrete covariant derivative operator. For a contravariant vector field $V^j$, the covariant derivative $\\nabla_i V^j$ is defined as:\n$$\n\\nabla_{i} V^{j} = \\partial_{i} V^{j} + \\Gamma^{j}_{ik} V^{k}\n$$\nIts discrete counterpart is formed by replacing the partial derivative and the Christoffel symbols with their discrete versions:\n$$\n(\\nabla_{i} V^{j})_{\\mathrm{d}} = D_{i} V^{j} + (\\Gamma^{j}_{ik})_{\\mathrm{d}} V^{k}\n$$\nThe evaluation of all terms on the right-hand side occurs at a single grid point.\n\nA crucial property of the Levi-Civita connection is metric compatibility, $\\nabla_{k} \\gamma_{ij} = 0$. The full expression for the covariant derivative of the metric tensor is:\n$$\n\\nabla_{k} \\gamma_{ij} = \\partial_{k} \\gamma_{ij} - \\Gamma^{\\ell}_{ki} \\gamma_{\\ell j} - \\Gamma^{\\ell}_{kj} \\gamma_{i \\ell}\n$$\nThe discrete version, $(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}}$, is used to test our numerical scheme's consistency:\n$$\n(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} = D_{k} \\gamma_{ij} - (\\Gamma^{\\ell}_{ki})_{\\mathrm{d}} \\gamma_{\\ell j} - (\\Gamma^{\\ell}_{kj})_{\\mathrm{d}} \\gamma_{i \\ell}\n$$\nA consistent second-order scheme should yield $(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} = \\mathcal{O}(h^2)$, because the truncation errors from discretizing the derivatives and the Christoffel symbols combine in a way that respects the underlying geometric identity up to the order of the approximation.\n\nThe problem specifies evaluation at the central grid point of a domain $[-L, L]^3 = [-1, 1]^3$ tessellated by an $N=65$ point grid in each dimension. The grid spacing is $h = \\frac{2L}{N-1} = \\frac{2}{64} = \\frac{1}{32}$. The central grid point corresponds to coordinates $\\mathbf{x} = (0,0,0)$.\n\nThe implementation proceeds by first defining functions for the given metrics and vector fields. A generic finite-difference function, which takes a field component and a direction, is implemented. This function is then used to compute the required first derivatives of the metric components. These derivatives are combined according to the formula to yield the discrete Christoffel symbols. Finally, the discrete covariant derivatives for the vector and the metric are assembled and evaluated for each test case.\n\n**Test Case 1:** The metric is $\\gamma_{ij} = \\delta_{ij}$. Since the metric is constant, all its partial derivatives are zero, which implies $\\Gamma^{k}_{ij} = 0$. The covariant derivative reduces to the partial derivative, $\\nabla_i V^j = \\partial_i V^j$. The discrete implementation must reflect this, giving $(\\nabla_i V^j)_{\\mathrm{d}} = D_i V^j$. The error $E_1 = \\| (\\nabla_{i} V^{j})_{\\mathrm{d}} - (\\nabla_{i} V^{j})_{\\mathrm{a}} \\|_{F} = \\| D_{i} V^{j} - \\partial_{i} V^{j} \\|_{F}$ measures the intrinsic truncation error of the finite-difference operator $D_i$ on the given vector field $V^j$. We expect this error to be of order $\\mathcal{O}(h^2)$.\n\n**Test Cases 2 and 3:** These cases test metric compatibility for non-trivial curved spacetimes. The quantity $E = \\max_{i,j,k} |(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}}|$ is computed for a conformally flat metric and a diagonal metric. As argued above, for a consistent second-order scheme, we expect this value to be non-zero but small, scaling as $\\mathcal{O}(h^2)$. This serves as a verification that the discrete Christoffel symbols have been constructed in a manner consistent with the discrete derivative applied to the metric itself.\n\nThe numerical implementation will use index conventions where tensors like $\\gamma_{ij}$, $\\Gamma^k_{ij}$, and $\\nabla_k\\gamma_{ij}$ are represented by multi-dimensional `numpy` arrays, e.g., `gamma[i, j]`, `Gamma[k, i, j]`, and `nabla_k_gamma_ij[k, i, j]`. Summation over repeated indices is performed using explicit loops or `numpy.einsum`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing discrete covariant derivatives and\n    verifying metric compatibility for given test cases.\n    \"\"\"\n    # Define grid parameters as per the problem statement\n    L = 1.0\n    N = 65\n    h = 2.0 * L / (N - 1)\n    \n    # All computations are at the central point\n    center_pos = np.array([0.0, 0.0, 0.0])\n\n    # General-purpose second-order central difference operator\n    def D(func, i, pos, h_val):\n        \"\"\"\n        Computes the central finite difference of `func` along direction `i`.\n        `func` is a scalar function of a 3D position vector.\n        `i` is the direction index (0 for x, 1 for y, 2 for z).\n        `pos` is the 3D position vector where the derivative is evaluated.\n        `h_val` is the grid spacing.\n        \"\"\"\n        hp = np.copy(pos)\n        hm = np.copy(pos)\n        hp[i] += h_val\n        hm[i] -= h_val\n        return (func(hp) - func(hm)) / (2.0 * h_val)\n\n    # --- Test Case 1: Flat space, vector transport fidelity ---\n    \n    # Vector field components\n    def V_func(pos):\n        x, y, z = pos\n        return np.array([np.sin(x), np.cos(y), np.exp(z)])\n\n    # Analytic covariant derivative (which is just the partial derivative in flat space)\n    # nabla_i V^j = partial_i V^j\n    nabla_V_analytic = np.zeros((3, 3))\n    # At (0,0,0):\n    # d/dx(sin(x)) = cos(0) = 1\n    nabla_V_analytic[0, 0] = 1.0 \n    # d/dy(cos(y)) = -sin(0) = 0\n    nabla_V_analytic[1, 1] = 0.0\n    # d/dz(exp(z)) = exp(0) = 1\n    nabla_V_analytic[2, 2] = 1.0\n    \n    # Discrete covariant derivative. In flat space, Christoffel symbols are zero.\n    # (nabla_i V^j)_d = D_i V^j\n    nabla_V_discrete = np.zeros((3, 3))\n    for i in range(3):\n        for j in range(3):\n            # D_i applied to the j-th component of V\n            nabla_V_discrete[i, j] = D(lambda p: V_func(p)[j], i, center_pos, h)\n\n    # Compute Frobenius norm of the error\n    E1 = np.linalg.norm(nabla_V_discrete - nabla_V_analytic, 'fro')\n\n    # --- Common function for Test Cases 2 and 3 ---\n    def compute_metric_compatibility_error(metric_func, pos, h_val):\n        \"\"\"\n        Computes the maximum absolute value of the discrete covariant\n        derivative of the metric, (nabla_k gamma_ij)_d.\n        \"\"\"\n        # 1. Get metric and its inverse at the central point\n        gamma = metric_func(pos)\n        gamma_inv = np.linalg.inv(gamma)\n        \n        # 2. Compute discrete Christoffel symbols (Gamma^k_ij)_d\n        Gamma = np.zeros((3, 3, 3)) # indices: k, i, j\n        \n        # Pre-compute all required metric derivatives D_i gamma_jk\n        # Dgamma[i, j, k] = D_i(gamma_jk)\n        Dgamma = np.zeros((3, 3, 3))\n        for i_deriv in range(3):\n            for j_idx in range(3):\n                for k_idx in range(3):\n                    # Define a lambda to get the component gamma_jk from the metric function\n                    component_func = lambda p: metric_func(p)[j_idx, k_idx]\n                    Dgamma[i_deriv, j_idx, k_idx] = D(component_func, i_deriv, pos, h_val)\n        \n        for k in range(3):\n            for i in range(3):\n                for j in range(3):\n                    # Gamma^k_ij = 0.5 * gamma^kl * (d_i gamma_lj + d_j gamma_li - d_l gamma_ij)\n                    term = Dgamma[i, j, :] + Dgamma[j, i, :] - Dgamma[:, i, j]\n                    Gamma[k, i, j] = 0.5 * np.dot(gamma_inv[k, :], term)\n\n        # 3. Compute discrete covariant derivative of the metric\n        # (nabla_k gamma_ij)_d = D_k gamma_ij - Gamma^l_ki * gamma_lj - Gamma^l_kj * gamma_il\n        nabla_k_gamma_ij = np.zeros((3, 3, 3)) # indices: k, i, j\n        \n        # Contract Christoffel symbols with metric\n        # Using numpy.einsum for clarity and efficiency\n        # term1[k,i,j] = sum_l Gamma[l,k,i]gamma[l,j]\n        term1 = np.einsum('lki,lj->kij', Gamma, gamma)\n        # term2[k,i,j] = sum_l Gamma[l,k,j]gamma[i,l]\n        term2 = np.einsum('lkj,il->kij', Gamma, gamma)\n        \n        nabla_k_gamma_ij = Dgamma - term1 - term2\n        \n        return np.max(np.abs(nabla_k_gamma_ij))\n\n    # --- Test Case 2: Conformally flat metric ---\n    def metric_2(pos):\n        x, y, z = pos\n        psi = 1.0 + 0.2 * (x + y + z)\n        return (psi**4) * np.identity(3)\n        \n    E2 = compute_metric_compatibility_error(metric_2, center_pos, h)\n\n    # --- Test Case 3: Diagonal curved metric ---\n    def metric_3(pos):\n        x, y, z = pos\n        gamma = np.zeros((3, 3))\n        gamma[0, 0] = 1.0 + 0.2 * x**2\n        gamma[1, 1] = 1.0 + 0.1 * y**2\n        gamma[2, 2] = np.exp(0.1 * z)\n        return gamma\n\n    E3 = compute_metric_compatibility_error(metric_3, center_pos, h)\n\n    # --- Final Output ---\n    # Print results in the specified format\n    results = [E1, E2, E3]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The abstract concept of spacetime curvature has a direct and observable geometric consequence: holonomy. This exercise allows you to numerically explore this phenomenon by parallel transporting a vector around a small closed loop on a curved surface . By comparing the resulting vector's rotation to the theoretical prediction from the Riemann curvature tensor, you will develop a tangible intuition for how curvature is fundamentally linked to the path-dependence of parallel transport.",
            "id": "3470813",
            "problem": "Consider a two-dimensional spatial slice with metric components $h_{ij}(x^{1},x^{2})$ in local coordinates $(x^{1},x^{2})$. Let $v^{i}$ be a contravariant vector field transported along a piecewise-smooth loop by the condition of parallel transport. Parallel transport along a parametrized curve with tangent $u^{j} = dx^{j}/ds$ is defined by the covariant derivative constraint $\\nabla_{u} v^{i} = 0$, i.e., $dv^{i}/ds + \\Gamma^{i}_{jk} u^{j} v^{k} = 0$, where the Christoffel symbols $\\Gamma^{i}_{jk}$ are those of the Levi-Civita connection constructed from the metric. For a small rectangular loop aligned with the coordinate axes, define a counterclockwise traversal starting at a base point $(x^{1}_{0},x^{2}_{0})$, going along $+x^{1}$ by $\\Delta x^{1}$, then $+x^{2}$ by $\\Delta x^{2}$, then $-x^{1}$ by $\\Delta x^{1}$, and then $-x^{2}$ by $\\Delta x^{2}$ back to the base point. The net holonomy can be characterized by the signed rotation angle of a unit vector initially aligned with the $x^{1}$ direction at the base point, measured in radians with respect to an orthonormal basis defined by the metric at the base point.\n\nStarting from the definitions of covariant differentiation and the Levi-Civita connection, and the Riemann curvature tensor $R^{i}_{jkl}$ constructed from $\\Gamma^{i}_{jk}$, recall that for a sufficiently small loop lying in a two-dimensional surface, the leading-order net rotation angle equals the surface integral of the Gaussian curvature $K$ over the enclosed region. In two dimensions, the Riemann tensor satisfies $R^{i}_{jkl} = K \\left(\\delta^{i}_{k} h_{jl} - \\delta^{i}_{l} h_{jk}\\right)$ and the rotation angle equals $\\int_{\\Sigma} K \\, \\sqrt{\\det h} \\, dx^{1} dx^{2}$ for orientation consistent with the traversal. Here, $\\sqrt{\\det h}$ is the area density of the metric. Angles must be reported in radians.\n\nImplement a program that:\n- Numerically integrates the parallel transport equation along each edge of the rectangular loop using a stable method that does not assume constant $\\Gamma^{i}_{jk}$.\n- Computes the signed holonomy angle by comparing the initial and final transported vector at the base point in the orthonormal frame defined by $h_{ij}(x^{1}_{0},x^{2}_{0})$.\n- Computes the predicted signed rotation angle by evaluating the Gaussian curvature $K$ and the area element $\\sqrt{\\det h}$ at the base point and multiplying by the coordinate area $\\Delta x^{1} \\Delta x^{2}$, with the sign determined by the loop orientation (positive for counterclockwise, negative for clockwise).\n- Produces the signed difference between the numerically measured holonomy angle and the curvature-based prediction for each test case.\n\nUse the following test suite. In all test cases, report angles in radians, and produce the final output as a single line containing a comma-separated Python list of four floats in the order of the test cases. The four test cases are:\n\n1. Flat two-dimensional spatial slice:\n   - Metric $h_{ij} = \\mathrm{diag}(1,1)$ everywhere.\n   - Base point $(x^{1}_{0},x^{2}_{0}) = (0,0)$.\n   - Rectangle sizes $\\Delta x^{1} = 10^{-3}$, $\\Delta x^{2} = 2 \\times 10^{-3}$.\n   - Orientation: counterclockwise.\n\n2. Two-sphere of radius $r$ in spherical coordinates $(\\theta,\\phi)$:\n   - Metric $h_{ij} = \\mathrm{diag}(r^{2}, r^{2} \\sin^{2}\\theta)$ with $r = 1$.\n   - Base point $(\\theta_{0},\\phi_{0}) = (0.7, 0.0)$ in radians.\n   - Rectangle sizes $\\Delta \\theta = 2 \\times 10^{-3}$, $\\Delta \\phi = 3 \\times 10^{-3}$.\n   - Orientation: counterclockwise.\n\n3. Conformally flat \"Gaussian bump\" metric on $\\mathbb{R}^{2}$:\n   - Metric $h_{ij} = \\Omega^{2}(x,y)\\, \\mathrm{diag}(1,1)$ with $\\Omega(x,y) = \\exp\\left(\\phi(x,y)\\right)$ and $\\phi(x,y) = \\varepsilon \\exp\\left(-\\frac{x^{2}+y^{2}}{\\sigma^{2}}\\right)$, where $\\varepsilon = 0.01$ and $\\sigma = 0.2$.\n   - Base point $(x^{1}_{0},x^{2}_{0}) = (0.05,-0.04)$.\n   - Rectangle sizes $\\Delta x^{1} = 10^{-2}$, $\\Delta x^{2} = 8 \\times 10^{-3}$.\n   - Orientation: counterclockwise.\n\n4. Same conformally flat \"Gaussian bump\" metric as in case 3:\n   - Base point $(x^{1}_{0},x^{2}_{0}) = (0.05,-0.04)$.\n   - Rectangle sizes $\\Delta x^{1} = 10^{-3}$, $\\Delta x^{2} = 10^{-3}$.\n   - Orientation: clockwise.\n\nYour program must:\n- Construct $\\Gamma^{i}_{jk}$ from $h_{ij}$ using the formula:\n$$ \\Gamma^{i}_{jk} = \\frac{1}{2} h^{i\\ell} \\left( \\partial_{j} h_{\\ell k} + \\partial_{k} h_{\\ell j} - \\partial_{\\ell} h_{jk} \\right) $$\nwhere $h^{i\\ell}$ is the inverse metric and $\\partial_{j}$ denotes partial derivatives with respect to $x^{j}$.\n- Integrate the parallel transport equation:\n$$ \\frac{dv^{i}}{ds} = - \\Gamma^{i}_{jk} u^{j} v^{k} $$\nalong each edge with a fixed number of steps sufficient for numerical stability.\n- Compute the orthonormal components of the initial and final vectors with respect to the metric at the base point, and assess the signed rotation using the oriented angle between these components.\n- Compute the predicted signed angle as:\n$$ s \\, K(x^{1}_{0},x^{2}_{0}) \\sqrt{\\det h(x^{1}_{0},x^{2}_{0})} \\, \\Delta x^{1} \\Delta x^{2} $$\nwhere $s = +1$ for counterclockwise and $s = -1$ for clockwise orientation.\n- Output the signed differences between the measured holonomy angle and the curvature-based prediction for test cases 1 through 4 as a single line in the format \"[d1,d2,d3,d4]\".\n\nAll numerical angles must be in radians. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\").",
            "solution": "The problem requires a numerical comparison between the holonomy of a vector parallel-transported around a small rectangular loop and the theoretical approximation based on the local Gaussian curvature. We will address this by implementing a high-precision numerical solver for the parallel transport equation and comparing its result to the analytical prediction.\n\n**1. Foundational Equations**\n\nThe parallel transport of a vector $v^i$ along a curve with parameter $s$ and tangent $u^j = dx^j/ds$ is governed by the ODE system:\n$$\n\\frac{dv^i}{ds} = -\\Gamma^i{}_{jk} u^j v^k\n$$\nwhere $\\Gamma^i{}_{jk}$ are the Christoffel symbols of the second kind, derived from the metric $h_{ij}$:\n$$\n\\Gamma^i{}_{jk} = \\frac{1}{2} h^{il} \\left( \\frac{\\partial h_{lk}}{\\partial x^j} + \\frac{\\partial h_{lj}}{\\partial x^k} - \\frac{\\partial h_{jk}}{\\partial x^l} \\right)\n$$\nFor a small loop enclosing a coordinate area $A_{\\text{coord}} = \\Delta x^1 \\Delta x^2$, the net rotation angle (holonomy) is approximated to first order by the integral of the Gaussian curvature $K$ over the enclosed surface element $d\\Sigma$:\n$$\n\\theta_{\\text{predicted}} \\approx s \\int K \\, d\\Sigma = s \\int K \\sqrt{\\det h} \\, dx^1 dx^2 \\approx s \\cdot K(x_0) \\sqrt{\\det h(x_0)} \\cdot \\Delta x^1 \\Delta x^2\n$$\nwhere $s$ is $+1$ for counter-clockwise and $-1$ for clockwise orientation, and $x_0$ is the base point of the loop. Our goal is to compute the difference between the numerically integrated holonomy, $\\theta_{\\text{measured}}$, and this approximation, $\\theta_{\\text{predicted}}$.\n\n**2. Numerical Scheme**\n\nA fourth-order Runge-Kutta (RK4) integrator is employed to solve the parallel transport ODE system. For a segment of length $L$ with $N$ steps of size $h=L/N$, and an ODE of the form $dy/dt = f(t,y)$, a single step is:\n$$\n\\begin{align*}\nk_1 &= f(t_n, y_n) \\\\\nk_2 &= f(t_n + h/2, y_n + h/2 \\cdot k_1) \\\\\nk_3 &= f(t_n + h/2, y_n + h/2 \\cdot k_2) \\\\\nk_4 &= f(t_n + h, y_n + h \\cdot k_3) \\\\\ny_{n+1} &= y_n + \\frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n$$\nThis method is applied sequentially to each of the four segments of the rectangular loop. A sufficiently large number of steps (e.g., $N=200$) is used to ensure the numerical error is negligible compared to the physical effect being measured.\n\nTo maximize accuracy, analytical expressions for the Christoffel symbols and the term $K\\sqrt{\\det h}$ are used for each test case, bypassing the need for numerical differentiation.\n\n**3. Holonomy Angle Calculation**\n\nThe initial vector $v^i_{\\text{initial}}$ is chosen to be a unit vector in the $x^1$ direction at the base point $x_0$, i.e., its contravariant components are $(1/\\sqrt{h_{11}(x_0)}, 0)$. After transport around the loop, the final vector $v^i_{\\text{final}}$ is obtained.\n\nTo measure the rotation, we project $v^i_{\\text{final}}$ onto an orthonormal frame at $x_0$. For a diagonal metric $h_{ij} = \\mathrm{diag}(h_{11}, h_{22})$, this frame can be defined by the basis vectors $e_{(\\hat{1})}^i = (1/\\sqrt{h_{11}(x_0)}, 0)$ and $e_{(\\hat{2})}^i = (0, 1/\\sqrt{h_{22}(x_0)})$. The components of the final vector in this frame are:\n$$\nV_{(\\hat{1})} = \\sqrt{h_{11}(x_0)} \\, v^1_{\\text{final}}, \\quad V_{(\\hat{2})} = \\sqrt{h_{22}(x_0)} \\, v^2_{\\text{final}}\n$$\nThe signed holonomy angle is then calculated as $\\theta_{\\text{measured}} = \\mathrm{atan2}(V_{(\\hat{2})}, V_{(\\hat{1})})$.\n\n**4. Test Case Specifics**\n\n*   **Case 1 (Flat):** All Christoffel symbols are zero, and $K=0$. The transport is trivial ($v^i$ is constant), and both the measured and predicted angles are zero. The difference is exactly $0$.\n*   **Case 2 (Sphere):** Using spherical coordinates $(\\theta, \\phi)$ with metric $h_{ij} = \\mathrm{diag}(1, \\sin^2\\theta)$, we use the known analytical Christoffel symbols and $K=1$. The predicted angle term is $K\\sqrt{\\det h} = \\sin\\theta$.\n*   **Cases 3 & 4 (Gaussian Bump):** The metric is conformally flat, $h_{ij} = e^{2\\phi} \\delta_{ij}$. The Christoffel symbols are computed from the analytical derivatives of $\\phi(x,y) = \\varepsilon \\exp(-(x^2+y^2)/\\sigma^2)$. The predicted angle term $K\\sqrt{\\det h}$ simplifies to $-\\nabla^2\\phi$, for which an analytical expression is also used.\n\nThe implementation calculates $\\theta_{\\text{measured}} - \\theta_{\\text{predicted}}$ for each of the four cases, providing a measure of how well the lowest-order curvature approximation captures the full holonomy.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the holonomy problem for the four specified test cases.\n    Computes the difference between the numerically measured holonomy angle\n    and the curvature-based prediction.\n    \"\"\"\n\n    # Constants for Case 3 and 4\n    EPSILON = 0.01\n    SIGMA = 0.2\n\n    # ==================================\n    # Christoffel and Curvature Functions\n    # ==================================\n\n    def christoffel_flat(coords):\n        return np.zeros((2, 2, 2))\n\n    def predicted_term_flat(coords):\n        return 0.0\n\n    def christoffel_sphere(coords):\n        theta, _ = coords\n        gamma = np.zeros((2, 2, 2))\n        sin_theta = np.sin(theta)\n        if sin_theta == 0:\n            return gamma\n        cos_theta = np.cos(theta)\n        gamma[0, 1, 1] = -sin_theta * cos_theta\n        gamma[1, 0, 1] = cos_theta / sin_theta\n        gamma[1, 1, 0] = cos_theta / sin_theta\n        return gamma\n\n    def predicted_term_sphere(coords):\n        theta, _ = coords\n        return np.sin(theta)\n\n    def phi_bump(coords):\n        x, y = coords\n        r_sq = x**2 + y**2\n        return EPSILON * np.exp(-r_sq / SIGMA**2)\n\n    def christoffel_bump(coords):\n        x, y = coords\n        gamma = np.zeros((2, 2, 2))\n        p = phi_bump(coords)\n        dp_dx = p * (-2 * x / SIGMA**2)\n        dp_dy =p * (-2 * y / SIGMA**2)\n\n        gamma[0, 0, 0] = dp_dx\n        gamma[1, 0, 0] = -dp_dy\n        gamma[0, 1, 1] = -dp_dx\n        gamma[1, 1, 1] = dp_dy\n        gamma[0, 0, 1] = dp_dy\n        gamma[0, 1, 0] = dp_dy\n        gamma[1, 0, 1] = dp_dx\n        gamma[1, 1, 0] = dp_dx\n        return gamma\n\n    def predicted_term_bump(coords):\n        x, y = coords\n        r_sq = x**2 + y**2\n        p = phi_bump(coords)\n        lap_phi = p * (4 * r_sq / SIGMA**4 - 4 / SIGMA**2)\n        return -lap_phi\n\n    # ==================================\n    # ODE Integrator Framework\n    # ==================================\n\n    def parallel_transport_rhs(v, coords, u, christoffel_func):\n        gamma = christoffel_func(coords)\n        dv = np.zeros(2, dtype=np.float64)\n        for i in range(2):\n            dv[i] = -np.sum(gamma[i, :, :] * np.outer(u, v))\n        return dv\n\n    def rk4_step(f, t, y, h, *f_args):\n        k1 = f(t, y, *f_args)\n        k2 = f(t + h / 2, y + h / 2 * k1, *f_args)\n        k3 = f(t + h / 2, y + h / 2 * k2, *f_args)\n        k4 = f(t + h, y + h * k3, *f_args)\n        return y + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def rhs_segment(s, v, start_point, u, christoffel_func):\n        coords = start_point + s * u\n        return parallel_transport_rhs(v, coords, u, christoffel_func)\n\n    def integrate_segment(v_start, segment_params, christoffel_func, num_steps):\n        v = v_start\n        h = segment_params['len'] / num_steps\n        for i in range(num_steps):\n            s_current = i * h\n            v = rk4_step(rhs_segment, s_current, v, h,\n                         segment_params['start'], segment_params['u'], christoffel_func)\n        return v\n    \n    # ==================================\n    # Main Solver per Case\n    # ==================================\n\n    def solve_case(case_params, num_steps_per_segment=200):\n        name = case_params[\"name\"]\n        base_point = np.array(case_params[\"base_point\"], dtype=np.float64)\n        delta = np.array(case_params[\"delta\"], dtype=np.float64)\n        orientation = case_params[\"orientation\"]\n\n        if name == \"Flat\":\n            metric_func = lambda c: np.identity(2)\n            christoffel_func = christoffel_flat\n            predicted_term_func = predicted_term_flat\n        elif name == \"Sphere\":\n            metric_func = lambda c: np.diag([1.0, np.sin(c[0])**2])\n            christoffel_func = christoffel_sphere\n            predicted_term_func = predicted_term_sphere\n        elif name == \"GaussianBump\":\n            metric_func = lambda c: np.diag([np.exp(2 * phi_bump(c))] * 2)\n            christoffel_func = christoffel_bump\n            predicted_term_func = predicted_term_bump\n        else:\n            raise ValueError(f\"Unknown case name: {name}\")\n\n        predicted_term_at_base = predicted_term_func(base_point)\n        predicted_angle = orientation * predicted_term_at_base * delta[0] * delta[1]\n\n        h0 = metric_func(base_point)\n        v_start = np.array([1.0 / np.sqrt(h0[0, 0]), 0.0], dtype=np.float64)\n\n        p0 = base_point\n        p1 = base_point + np.array([delta[0], 0.0])\n        p2 = base_point + delta\n        p3 = base_point + np.array([0.0, delta[1]])\n\n        if orientation == 1:  # Counter-clockwise\n            segments = [\n                {\"start\": p0, \"u\": np.array([1., 0.]), \"len\": delta[0]},\n                {\"start\": p1, \"u\": np.array([0., 1.]), \"len\": delta[1]},\n                {\"start\": p2, \"u\": np.array([-1., 0.]), \"len\": delta[0]},\n                {\"start\": p3, \"u\": np.array([0., -1.]), \"len\": delta[1]},\n            ]\n        else:  # Clockwise\n            segments = [\n                {\"start\": p0, \"u\": np.array([0., 1.]), \"len\": delta[1]},\n                {\"start\": p3, \"u\": np.array([1., 0.]), \"len\": delta[0]},\n                {\"start\": p2, \"u\": np.array([0., -1.]), \"len\": delta[1]},\n                {\"start\": p1, \"u\": np.array([-1., 0.]), \"len\": delta[0]},\n            ]\n\n        v_current = v_start\n        for seg in segments:\n            v_current = integrate_segment(v_current, seg, christoffel_func, num_steps_per_segment)\n        v_final = v_current\n\n        v_final_ortho = np.array([\n            np.sqrt(h0[0, 0]) * v_final[0],\n            np.sqrt(h0[1, 1]) * v_final[1]\n        ])\n        \n        measured_angle = np.arctan2(v_final_ortho[1], v_final_ortho[0])\n\n        return measured_angle - predicted_angle\n\n    # ==================================\n    # Test Cases Execution\n    # ==================================\n\n    test_cases = [\n        {\n            \"name\": \"Flat\",\n            \"base_point\": (0.0, 0.0),\n            \"delta\": (1e-3, 2e-3),\n            \"orientation\": 1\n        },\n        {\n            \"name\": \"Sphere\",\n            \"base_point\": (0.7, 0.0),\n            \"delta\": (2e-3, 3e-3),\n            \"orientation\": 1\n        },\n        {\n            \"name\": \"GaussianBump\",\n            \"base_point\": (0.05, -0.04),\n            \"delta\": (1e-2, 8e-3),\n            \"orientation\": 1\n        },\n        {\n            \"name\": \"GaussianBump\",\n            \"base_point\": (0.05, -0.04),\n            \"delta\": (1e-3, 1e-3),\n            \"orientation\": -1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        difference = solve_case(case)\n        results.append(difference)\n\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}