{
    "hands_on_practices": [
        {
            "introduction": "要真正理解协变导数在弯曲空间中的必要性，我们必须首先明白普通偏导数的局限性。此练习 () 旨在让你在一个弯曲流形上计算一个矢量场的协变散度与“朴素”坐标散度。通过比较两者，你将直接面对偏导数的坐标依赖性，并体会到克里斯托费尔符号（Christoffel symbols）如何提供必要的修正，从而定义一个真正的、坐标无关的标量。",
            "id": "3470740",
            "problem": "在一个用于数值相对论的空间超曲面上，考虑共形平坦的三维数 $\\gamma_{ij}$，在标准球坐标 $(r,\\theta,\\phi)$ 中写作 $\\gamma_{ij}=\\psi(r)^{4}\\,\\mathrm{diag}\\!\\left(1,\\,r^{2},\\,r^{2}\\sin^{2}\\theta\\right)$，其共形因子为 $\\psi(r)=1+\\frac{M}{2r}$，其中 $M0$ 是一个常数。设 $V^{i}$ 是一个矢量场，在坐标基中仅有径向分量，由 $V^{r}(r,\\theta,\\phi)=\\dfrac{A\\,r^{2}}{\\psi(r)^{6}}$ 给出，且 $V^{\\theta}=0$，$V^{\\phi}=0$，其中 $A$ 是一个常数。\n\n仅使用 $\\gamma_{ij}$ 的 Levi-Civita 联络的基本定义和矢量场的协变微分的定义，完成以下任务：\n- 计算 $V^{i}$ 在此弯曲三维数上的协变散度 $D_{i}V^{i}$。\n- 计算朴素坐标散度 $\\partial_{i}V^{i}$，并用文字解释为什么它在弯曲或曲线空间流形上不表示一个张量标量，而 $D_{i}V^{i}$ 却表示一个张量标量。\n- 你最终报告的结果必须是 $D_{i}V^{i}$ 关于 $A$、$M$ 和 $r$ 的显式闭式解析表达式。不需要进行数值计算。\n\n请以包含 $A$、$M$ 和 $r$ 的单一闭式表达式给出你的最终答案。",
            "solution": "### 第一步：提取已知条件\n- **空间三维数**：在球坐标 $(r, \\theta, \\phi)$ 中，$\\gamma_{ij} = \\psi(r)^{4}\\,\\mathrm{diag}\\!\\left(1,\\,r^{2},\\,r^{2}\\sin^{2}\\theta\\right)$。\n- **共形因子**：$\\psi(r)=1+\\frac{M}{2r}$，其中 $M0$ 是一个常数。\n- **矢量场**：$V^{r}(r,\\theta,\\phi)=\\dfrac{A\\,r^{2}}{\\psi(r)^{6}}$，且 $V^{\\theta}=0$ 和 $V^{\\phi}=0$。$A$ 是一个常数。\n- **任务1**：计算协变散度 $D_{i}V^{i}$。\n- **任务2**：计算朴素坐标散度 $\\partial_{i}V^{i}$。\n- **任务3**：解释为什么 $D_{i}V^{i}$ 是一个标量而 $\\partial_{i}V^{i}$ 不是。\n- **约束**：仅使用 Levi-Civita 联络和协变微分的基本定义。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学依据**：该问题设置在时空 $3+1$ 分解的背景下，这是数值相对论的基石。该度规是各向同性坐标下史瓦西时空等时切片的共形平坦表示，这是一个标准的教科书示例。协变微分、Levi-Civita 联络和张量性质等概念是微分几何和广义相对论的基础。该问题具有科学合理性。\n- **适定的**：所有必要信息都已提供。度规 $\\gamma_{ij}$ 和矢量场 $V^i$ 都已明确定义。任务是明确的数学计算和概念解释。存在唯一且有意义的解。\n- **客观性**：问题以精确的数学语言表述，没有任何主观性或歧义。\n\n### 第三步：结论与行动\n问题有效。将提供完整的解答。\n\n### 求解推导\n\n根据要求，分析分为三个部分：计算协变散度，计算朴素坐标散度，以及关于它们张量性质的概念性解释。\n\n#### 第一部分：计算协变散度 $D_{i}V^{i}$\n\n逆变矢量场 $V^i$ 的协变导数的基本定义由下式给出\n$$D_j V^i = \\partial_j V^i + \\Gamma^i_{jk} V^k$$\n其中 $\\partial_j$ 表示对坐标 $x^j$ 的偏导数，$\\Gamma^i_{jk}$ 是与度规 $\\gamma_{ij}$ 相关联的 Christoffel 符号（Levi-Civita 联络的分量）。协变散度是该张量的缩并（迹），通过令 $j=i$ 得到：\n$$D_i V^i = \\partial_i V^i + \\Gamma^i_{ik} V^k$$\n这里，重复指标意味着求和。设坐标为 $(x^1, x^2, x^3) = (r, \\theta, \\phi)$。给定的矢量场是 $V^i = (V^r, 0, 0)$。对 $i$ 和 $k$ 的求和展开为：\n$$D_i V^i = (\\partial_r V^r + \\partial_\\theta V^\\theta + \\partial_\\phi V^\\phi) + (\\Gamma^r_{rk}V^k + \\Gamma^\\theta_{\\theta k}V^k + \\Gamma^\\phi_{\\phi k}V^k)$$\n由于 $V^\\theta=0$ 且 $V^\\phi=0$，并且 $V^r$ 仅是 $r$ 的函数，这大大简化了表达式。$V^k$ 唯一非零的分量是 $V^r$（当 $k=r$ 时）。\n$$D_i V^i = \\partial_r V^r + \\Gamma^r_{rr}V^r + \\Gamma^\\theta_{\\theta r}V^r + \\Gamma^\\phi_{\\phi r}V^r$$\n$$D_i V^i = \\partial_r V^r + V^r \\left( \\Gamma^r_{rr} + \\Gamma^\\theta_{\\theta r} + \\Gamma^\\phi_{\\phi r} \\right)$$\n为了继续，我们必须计算给定度规 $\\gamma_{ij}$ 所需的 Christoffel 符号。度规分量为：\n$$\\gamma_{rr} = \\psi(r)^4$$\n$$\\gamma_{\\theta\\theta} = r^2\\psi(r)^4$$\n$$\\gamma_{\\phi\\phi} = r^2\\sin^2\\theta\\,\\psi(r)^4$$\nChristoffel 符号由 $\\Gamma^k_{ij} = \\frac{1}{2}\\gamma^{kl}(\\partial_i \\gamma_{jl} + \\partial_j \\gamma_{il} - \\partial_l \\gamma_{ij})$ 给出。对于对角度规，这会简化。令撇号表示对 $r$ 的导数，例如 $\\psi' = \\frac{d\\psi}{dr}$。我们有 $\\psi(r) = 1 + \\frac{M}{2r}$，所以 $\\psi'(r) = -\\frac{M}{2r^2}$。\n\n所需的 Christoffel 符号为：\n1.  $\\Gamma^r_{rr} = \\frac{1}{2}\\gamma^{rr}(\\partial_r \\gamma_{rr}) = \\frac{1}{2}\\frac{1}{\\psi^4}(4\\psi^3\\psi') = \\frac{2\\psi'}{\\psi}$\n2.  $\\Gamma^\\theta_{\\theta r} = \\frac{1}{2}\\gamma^{\\theta\\theta}(\\partial_r \\gamma_{\\theta\\theta}) = \\frac{1}{2}\\frac{1}{r^2\\psi^4}\\partial_r(r^2\\psi^4) = \\frac{1}{2r^2\\psi^4}(2r\\psi^4 + r^2 \\cdot 4\\psi^3\\psi') = \\frac{1}{r} + \\frac{2\\psi'}{\\psi}$\n3.  $\\Gamma^\\phi_{\\phi r} = \\frac{1}{2}\\gamma^{\\phi\\phi}(\\partial_r \\gamma_{\\phi\\phi}) = \\frac{1}{2}\\frac{1}{r^2\\sin^2\\theta\\,\\psi^4}\\partial_r(r^2\\sin^2\\theta\\,\\psi^4) = \\frac{1}{2r^2\\sin^2\\theta\\,\\psi^4}(2r\\sin^2\\theta\\,\\psi^4 + r^2\\sin^2\\theta \\cdot 4\\psi^3\\psi') = \\frac{1}{r} + \\frac{2\\psi'}{\\psi}$\n\n这些符号的和为：\n$$\\Gamma^r_{rr} + \\Gamma^\\theta_{\\theta r} + \\Gamma^\\phi_{\\phi r} = \\left(\\frac{2\\psi'}{\\psi}\\right) + \\left(\\frac{1}{r} + \\frac{2\\psi'}{\\psi}\\right) + \\left(\\frac{1}{r} + \\frac{2\\psi'}{\\psi}\\right) = \\frac{6\\psi'}{\\psi} + \\frac{2}{r}$$\n接下来，我们计算偏导数 $\\partial_r V^r$：\n$$V^r = \\frac{A r^2}{\\psi^6} = A r^2 \\psi^{-6}$$\n$$\\partial_r V^r = A(2r\\psi^{-6} + r^2(-6)\\psi^{-7}\\psi') = \\frac{2Ar}{\\psi^6} - \\frac{6Ar^2\\psi'}{\\psi^7}$$\n现在，我们组合 $D_i V^i$ 的表达式：\n$$D_i V^i = \\left(\\frac{2Ar}{\\psi^6} - \\frac{6Ar^2\\psi'}{\\psi^7}\\right) + \\left(\\frac{Ar^2}{\\psi^6}\\right)\\left(\\frac{6\\psi'}{\\psi} + \\frac{2}{r}\\right)$$\n$$D_i V^i = \\frac{2Ar}{\\psi^6} - \\frac{6Ar^2\\psi'}{\\psi^7} + \\frac{6Ar^2\\psi'}{\\psi^7} + \\frac{2Ar}{\\psi^6}$$\n包含 $\\psi'$ 的项相互抵消，得到一个简单的结果：\n$$D_i V^i = \\frac{4Ar}{\\psi^6}$$\n为了得到以 $A$、$M$ 和 $r$ 表示的最终表达式，我们代入 $\\psi(r) = 1 + \\frac{M}{2r} = \\frac{2r+M}{2r}$：\n$$D_i V^i = \\frac{4Ar}{\\left(\\frac{2r+M}{2r}\\right)^6} = \\frac{4Ar(2r)^6}{(2r+M)^6} = \\frac{4Ar(64r^6)}{(2r+M)^6} = \\frac{256 A r^7}{(2r+M)^6}$$\n\n#### 第二部分：计算朴素坐标散度 $\\partial_{i}V^{i}$\n\n朴素坐标散度就是矢量分量偏导数的和：\n$$\\partial_{i}V^{i} = \\partial_r V^r + \\partial_\\theta V^\\theta + \\partial_\\phi V^\\phi$$\n由于 $V^\\theta=0$ 且 $V^\\phi=0$，这简化为：\n$$\\partial_{i}V^{i} = \\partial_r V^r$$\n我们已经在第一部分计算过这一项：\n$$\\partial_r V^r = \\frac{2Ar}{\\psi^6} - \\frac{6Ar^2\\psi'}{\\psi^7}$$\n代入 $\\psi' = -\\frac{M}{2r^2}$：\n$$\\partial_r V^r = \\frac{2Ar}{\\psi^6} - \\frac{6Ar^2}{\\psi^7}\\left(-\\frac{M}{2r^2}\\right) = \\frac{2Ar}{\\psi^6} + \\frac{3AM}{\\psi^7}$$\n这可以写成：\n$$\\partial_r V^r = \\frac{A}{\\psi^7}(2r\\psi + 3M) = \\frac{A}{\\psi^7}\\left(2r\\left(1+\\frac{M}{2r}\\right) + 3M\\right) = \\frac{A}{\\psi^7}(2r+M+3M) = \\frac{A(2r+4M)}{\\psi^7} = \\frac{2A(r+2M)}{(1+\\frac{M}{2r})^7}$$\n\n#### 第三部分：$D_i V^i$ 与 $\\partial_i V^i$ 的张量特性\n\n标量（0 阶张量）被定义为一个其在某一点的值在坐标变换下不变的量。如果 $x^i$ 和 $x'^j$ 是两个坐标系，一个标量 $S$ 必须满足 $S'(x') = S(x)$。\n\n协变散度 $D_i V^i$ 是一个真正的标量。它是由 (1,1) 阶张量 $D_j V^i$ 的迹构造而成的。张量的缩并总会产生一个阶数更低的张量。在这种情况下，缩并一个 (1,1) 阶张量的指标会得到一个 0 阶张量，即一个标量。协变导数的数学定义是经过特殊构造的，使得 $D_j V^i$ 作为一个张量进行变换，因此其迹 $D_i V^i$ 作为一个标量进行变换：$D'_i V'^i = D_i V^i$。\n\n相比之下，在弯曲流形或一般曲线坐标系中，朴素坐标散度 $\\partial_i V^i$ 不是一个标量。它在某一点的值取决于所选的坐标系。要理解这一点，考虑 $\\partial_i V^i$ 在两个坐标系 $x^i$ 和 $x'^j$ 之间的变换。逆变矢量的变换方式为 $V'^j = \\frac{\\partial x'^j}{\\partial x^i} V^i$。应用链式法则，散度的变换方式为：\n$$\\partial'_j V'^j = \\partial'_j \\left(\\frac{\\partial x'^j}{\\partial x^i} V^i\\right) = \\frac{\\partial^2 x'^j}{\\partial x'^j \\partial x^i} V^i + \\frac{\\partial x'^j}{\\partial x^i} \\partial'_j V^i = \\frac{\\partial^2 x'^j}{\\partial x^k \\partial x^i}\\frac{\\partial x^k}{\\partial x'^j} V^i + \\frac{\\partial x'^j}{\\partial x^i} \\frac{\\partial x^k}{\\partial x'^j} \\partial_k V^i$$\n$$\\partial'_j V'^j = \\frac{\\partial x^k}{\\partial x'^j}\\frac{\\partial^2 x'^j}{\\partial x^k \\partial x^i} V^i + \\delta^k_i \\partial_k V^i = \\partial_i V^i + \\left(\\frac{\\partial x^k}{\\partial x'^j}\\frac{\\partial^2 x'^j}{\\partial x^k \\partial x^i}\\right) V^i$$\n变换定律是 $\\partial'_j V'^j = \\partial_i V^i + (\\text{额外项})$。由于存在涉及坐标变换二阶导数的额外项，$\\partial_i V^i$ 不会像标量那样变换。这些项仅在特定类型的变换（平直空间中笛卡尔坐标系之间的仿射变换）下为零。在一般情况下，它们不为零。\n\n协变导数定义中的 Christoffel 符号正是用来解释偏导数的非张量变换性质的对象。它们充当“修正项”，减去在曲线或弯曲设定中由于基矢量变化而产生的坐标依赖效应。其结果 $D_i V^i$ 是一个与坐标无关的几何对象，表示矢量场的內蕴散度。而朴素散度 $\\partial_i V^i$ 缺少这种修正，是一个依赖于坐标的人为产物，没有內蕴的物理或几何意义。",
            "answer": "$$\\boxed{\\frac{256 A r^7}{(2r+M)^6}}$$"
        },
        {
            "introduction": "将解析理论应用于计算实践，需要我们在离散网格上表示几何对象。本练习 () 将指导你构建协变导数算符 $\\nabla_i$ 的有限差分近似。你不仅需要离散化偏导数 $\\partial_i$，还需要离散化克里斯托费尔符号 $\\Gamma^k_{\\ ij}$ 本身，并关键性地验证你的离散算符能在预期的精度阶上保持度规相容性 ($\\nabla_k \\gamma_{ij} = 0$) 这一基本属性。",
            "id": "3470737",
            "problem": "您的任务是为一个在三维弯曲黎曼流形上的逆变矢量场推导并实现其协变导数的二阶有限差分模板，该流形由一个空间度规进行数值表示。目标是为协变导数构建一个离散算子，该算子能显式地包含离散的Christoffel符号，并在均匀笛卡尔网格上保持度规兼容性至截断误差阶。您的实现必须是一个完整的程序，该程序输出一行汇总了下述测试套件结果的字符串。\n\n从微分几何和数值分析的基本定义开始：\n\n- 对于度规 $\\gamma_{ij}$ 的Levi-Civita联络，逆变矢量场 $V^{j}$ 的协变导数定义为 $ \\nabla_{i} V^{j} = \\partial_{i} V^{j} + \\Gamma^{j}_{\\;ik} V^{k} $，其中 $\\Gamma^{j}_{\\;ik}$ 是Christoffel符号。\n- 度规 $\\gamma_{ij}$ 的Levi-Civita联络系数（Christoffel符号）定义为 $ \\Gamma^{k}_{\\;ij} = \\frac{1}{2} \\gamma^{k\\ell} \\left( \\partial_{i} \\gamma_{\\ell j} + \\partial_{j} \\gamma_{\\ell i} - \\partial_{\\ell} \\gamma_{ij} \\right) $，其中 $\\gamma^{k\\ell}$ 是 $\\gamma_{k\\ell}$ 的逆。\n- Levi-Civita联络的度规兼容性表示为 $ \\nabla_{k} \\gamma_{ij} = 0 $。\n\n您必须为空间导数设计二阶精度的中心差分模板，当用其从度规构建离散Christoffel符号时，能产生一个离散协变导数，该导数保持度规兼容性至截断误差阶（即，离散度规协变导数为 $\\mathcal{O}(h^{2})$，其中 $h$ 是均匀网格间距）。具体来说：\n\n- 在 $x$、$y$ 和 $z$ 方向上使用均匀笛卡尔网格，每个维度有 $N$ 个网格点，间距为 $h$，覆盖立方体区域 $[-L, L]^{3}$。所有坐标均为无量纲。使用 $L = 1$ 和 $N = 65$，因此 $h = \\frac{2 L}{N - 1}$。\n- 将标量场 $f$ 在一个网格点上的偏导数的二阶中心差分算子定义为 $D_{i} f = \\frac{f(\\mathbf{x} + h \\hat{e}_{i}) - f(\\mathbf{x} - h \\hat{e}_{i})}{2 h}$，对于 $i \\in \\{x, y, z\\}$，其中 $\\hat{e}_{i}$ 是沿 $i$ 方向的单位矢量。\n- 使用上述定义，从度规分量 $\\gamma_{ij}$ 及其离散导数 $D_{i} \\gamma_{jk}$ 构建离散Christoffel符号 $\\Gamma^{k}_{\\;ij}$，其中逆度规 $\\gamma^{ij}$ 在同一网格点上取值。\n- 将矢量 $V^{j}$ 的离散协变导数定义为 $(\\nabla_{i} V^{j})_{\\mathrm{d}} = D_{i} V^{j} + \\Gamma^{j}_{\\;ik} V^{k}$，将度规的离散协变导数定义为 $(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} = D_{k} \\gamma_{ij} - \\Gamma^{\\ell}_{\\;ki} \\gamma_{\\ell j} - \\Gamma^{\\ell}_{\\;kj} \\gamma_{i \\ell}$。\n- 在中心网格点上评估所有离散量，以避免边界效应。\n\n您的程序必须实现上述模板并计算以下测试用例。对每个测试用例，计算指定的标量结果，并按下述规定将结果汇总到单行输出中。不涉及物理单位。\n\n测试套件：\n\n- 测试用例1（平直空间，矢量输运保真度）：\n  - 度规：$\\gamma_{ij} = \\delta_{ij}$（分量 $\\gamma_{xx} = 1$，$\\gamma_{yy} = 1$，$\\gamma_{zz} = 1$，非对角分量为零）。\n  - 矢量：$V^{x}(x,y,z) = \\sin(x)$，$V^{y}(x,y,z) = \\cos(y)$，$V^{z}(x,y,z) = e^{z}$。\n  - 待输出量：令 $(\\nabla_{i} V^{j})_{\\mathrm{d}}$ 为离散协变导数，令 $(\\nabla_{i} V^{j})_{\\mathrm{a}}$ 表示在中心点 $\\mathbf{x} = (0,0,0)$ 处的精确连续值，该值由定义和解析导数计算得出。计算Frobenius范数误差 $E_{1} = \\left\\| (\\nabla_{i} V^{j})_{\\mathrm{d}} - (\\nabla_{i} V^{j})_{\\mathrm{a}} \\right\\|_{F}$ 并将此标量 $E_{1}$ 作为浮点数输出。\n\n- 测试用例2（共形平直的弯曲度规，度规兼容性检验）：\n  - 度规：$\\gamma_{ij} = \\psi^{4} \\delta_{ij}$，其中 $\\psi(x,y,z) = 1 + 0.2 \\,(x + y + z)$。\n  - 待输出量：在中心网格点计算 $(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}}$ 并返回 $E_{2} = \\max_{i,j,k} \\left| (\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} \\right|$ 作为浮点数。\n\n- 测试用例3（对角弯曲度规，度规兼容性检验）：\n  - 度规：$\\gamma_{xx}(x,y,z) = 1 + 0.2 \\, x^{2}$，$\\gamma_{yy}(x,y,z) = 1 + 0.1 \\, y^{2}$，$\\gamma_{zz}(x,y,z) = e^{0.1 \\, z}$，所有非对角分量为零。\n  - 待输出量：在中心网格点计算 $(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}}$ 并返回 $E_{3} = \\max_{i,j,k} \\left| (\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} \\right|$ 作为浮点数。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含按顺序 $[E_{1}, E_{2}, E_{3}]$ 排列、由逗号分隔并用方括号括起来的结果。例如，输出行必须形如 $[a,b,c]$，其中 $a$、$b$ 和 $c$ 是浮点数。\n\n角度单位不适用，也不使用百分比。所有数值结果都是无单位的纯数。计算必须是完全自包含的，并且必须仅使用中心网格点，避免使用边界模板。最终输出必须是严格的一行，没有任何额外文本。",
            "solution": "该问题要求推导并实现一个在三维黎曼流形上计算协变导数的二阶有限差分格式。其实现的有效性将通过三个测试用例进行评估：一个用于衡量平直空间中矢量输运的精度，另外两个用于验证弯曲空间中度规兼容性的保持情况。\n\n基本原理是用离散的有限差分算子替代连续的偏导数。问题指定了用于计算标量函数 $f$ 相对于笛卡尔坐标 $x^i$ 的偏导数的二阶精度中心差分算子，在网格点 $\\mathbf{x}$ 处求值：\n$$\nD_{i} f(\\mathbf{x}) = \\frac{f(\\mathbf{x} + h \\hat{e}_{i}) - f(\\mathbf{x} - h \\hat{e}_{i})}{2 h}\n$$\n这里，$h$ 是均匀网格间距，$\\hat{e}_{i}$ 是第 $i$ 个方向上的单位矢量。该算子的泰勒级数展开表明 $D_{i} f = \\partial_{i} f + \\mathcal{O}(h^2)$，这表示它是二阶精度的。此算子被逐分量地应用于张量场。\n\n协变导数的核心部分是第二类Christoffel符号集合 $\\Gamma^{k}_{\\;ij}$，它编码了流形的曲率。对于与度规 $\\gamma_{ij}$ 相关联的Levi-Civita联络，它们定义如下：\n$$\n\\Gamma^{k}_{\\;ij} = \\frac{1}{2} \\gamma^{k\\ell} \\left( \\partial_{i} \\gamma_{\\ell j} + \\partial_{j} \\gamma_{\\ell i} - \\partial_{\\ell} \\gamma_{ij} \\right)\n$$\n其中 $\\gamma^{k\\ell}$ 是度规张量 $\\gamma_{k\\ell}$ 的逆，即 $\\gamma^{k\\ell} \\gamma_{\\ell m} = \\delta^{k}_{m}$。为了获得离散的Christoffel符号 $(\\Gamma^{k}_{\\;ij})_{\\mathrm{d}}$，我们将偏导数算子 $\\partial$ 替换为我们的离散算子 $D$：\n$$\n(\\Gamma^{k}_{\\;ij})_{\\mathrm{d}} = \\frac{1}{2} \\gamma^{k\\ell} \\left( D_{i} \\gamma_{\\ell j} + D_{j} \\gamma_{\\ell i} - D_{\\ell} \\gamma_{ij} \\right)\n$$\n在此表达式中，度规 $\\gamma_{ij}$ 及其逆 $\\gamma^{k\\ell}$ 都在计算Christoffel符号的那个网格点上进行求值。而诸如 $D_{i} \\gamma_{\\ell j}$ 的导数则使用 $\\gamma_{\\ell j}$ 在相邻网格点上的值来计算。\n\n有了离散的Christoffel符号，我们就可以构建离散协变导数算子。对于逆变矢量场 $V^j$，协变导数 $\\nabla_i V^j$ 定义为：\n$$\n\\nabla_{i} V^{j} = \\partial_{i} V^{j} + \\Gamma^{j}_{\\;ik} V^{k}\n$$\n它的离散对应形式是通过将偏导数和Christoffel符号替换为其离散版本来构成的：\n$$\n(\\nabla_{i} V^{j})_{\\mathrm{d}} = D_{i} V^{j} + (\\Gamma^{j}_{\\;ik})_{\\mathrm{d}} V^{k}\n$$\n右侧所有项的求值都在单个网格点上进行。\n\nLevi-Civita联络的一个关键属性是度规兼容性，即 $\\nabla_{k} \\gamma_{ij} = 0$。度规张量协变导数的完整表达式为：\n$$\n\\nabla_{k} \\gamma_{ij} = \\partial_{k} \\gamma_{ij} - \\Gamma^{\\ell}_{\\;ki} \\gamma_{\\ell j} - \\Gamma^{\\ell}_{\\;kj} \\gamma_{i \\ell}\n$$\n其离散版本 $(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}}$ 用于测试我们数值格式的一致性：\n$$\n(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} = D_{k} \\gamma_{ij} - (\\Gamma^{\\ell}_{\\;ki})_{\\mathrm{d}} \\gamma_{\\ell j} - (\\Gamma^{\\ell}_{\\;kj})_{\\mathrm{d}} \\gamma_{i \\ell}\n$$\n一个一致的二阶格式应得出 $(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}} = \\mathcal{O}(h^2)$，因为来自导数和Christoffel符号离散化的截断误差会以一种尊重底层几何恒等式的方式组合，其精度达到近似的阶。\n\n问题指定在区域 $[-L, L]^3 = [-1, 1]^3$ 的中心网格点进行求值，该区域由每个维度 $N=65$ 个点的网格剖分。网格间距为 $h = \\frac{2L}{N-1} = \\frac{2}{64} = \\frac{1}{32}$。中心网格点对应坐标 $\\mathbf{x} = (0,0,0)$。\n\n实现过程首先是为给定的度规和矢量场定义函数。然后实现一个通用的有限差分函数，该函数接受一个场分量和一个方向作为输入。接着使用此函数计算所需的度规分量的一阶导数。这些导数根据公式组合以产生离散的Christoffel符号。最后，为矢量和度规组装离散协变导数，并对每个测试用例进行求值。\n\n**测试用例1：** 度规为 $\\gamma_{ij} = \\delta_{ij}$。由于度规是常数，其所有偏导数均为零，这意味着 $\\Gamma^{k}_{\\;ij} = 0$。协变导数简化为偏导数，即 $\\nabla_i V^j = \\partial_i V^j$。离散实现必须反映这一点，给出 $(\\nabla_i V^j)_{\\mathrm{d}} = D_i V^j$。误差 $E_1 = \\| (\\nabla_{i} V^{j})_{\\mathrm{d}} - (\\nabla_{i} V^{j})_{\\mathrm{a}} \\|_{F} = \\| D_{i} V^{j} - \\partial_{i} V^{j} \\|_{F}$ 衡量了有限差分算子 $D_i$ 应用于给定矢量场 $V^j$ 时的内在截断误差。我们期望这个误差的量级为 $\\mathcal{O}(h^2)$。\n\n**测试用例2和3：** 这些用例测试了非平凡弯曲空间的度规兼容性。对共形平直度规和对角度规，计算量 $E = \\max_{i,j,k} |(\\nabla_{k} \\gamma_{ij})_{\\mathrm{d}}|$。如上所述，对于一个一致的二阶格式，我们期望这个值非零但很小，并按 $\\mathcal{O}(h^2)$ 的比例缩放。这可以验证离散Christoffel符号的构建方式与应用于度规本身的离散导数是一致的。\n\n数值实现将使用索引约定，其中像 $\\gamma_{ij}$、$\\Gamma^k_{ij}$ 和 $\\nabla_k\\gamma_{ij}$ 这样的张量由多维 `numpy` 数组表示，例如 `gamma[i, j]`、`Gamma[k, i, j]` 和 `nabla_k_gamma_ij[k, i, j]`。对重复指标的求和通过显式循环或 `numpy.einsum` 来执行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing discrete covariant derivatives and\n    verifying metric compatibility for given test cases.\n    \"\"\"\n    # Define grid parameters as per the problem statement\n    L = 1.0\n    N = 65\n    h = 2.0 * L / (N - 1)\n    \n    # All computations are at the central point\n    center_pos = np.array([0.0, 0.0, 0.0])\n\n    # General-purpose second-order central difference operator\n    def D(func, i, pos, h_val):\n        \"\"\"\n        Computes the central finite difference of `func` along direction `i`.\n        `func` is a scalar function of a 3D position vector.\n        `i` is the direction index (0 for x, 1 for y, 2 for z).\n        `pos` is the 3D position vector where the derivative is evaluated.\n        `h_val` is the grid spacing.\n        \"\"\"\n        hp = np.copy(pos)\n        hm = np.copy(pos)\n        hp[i] += h_val\n        hm[i] -= h_val\n        return (func(hp) - func(hm)) / (2.0 * h_val)\n\n    # --- Test Case 1: Flat space, vector transport fidelity ---\n    \n    # Vector field components\n    def V_func(pos):\n        x, y, z = pos\n        return np.array([np.sin(x), np.cos(y), np.exp(z)])\n\n    # Analytic covariant derivative (which is just the partial derivative in flat space)\n    # nabla_i V^j = partial_i V^j\n    nabla_V_analytic = np.zeros((3, 3))\n    # At (0,0,0):\n    # d/dx(sin(x)) = cos(0) = 1\n    nabla_V_analytic[0, 0] = 1.0 \n    # d/dy(cos(y)) = -sin(0) = 0\n    nabla_V_analytic[1, 1] = 0.0\n    # d/dz(exp(z)) = exp(0) = 1\n    nabla_V_analytic[2, 2] = 1.0\n    \n    # Discrete covariant derivative. In flat space, Christoffel symbols are zero.\n    # (nabla_i V^j)_d = D_i V^j\n    nabla_V_discrete = np.zeros((3, 3))\n    for i in range(3):\n        for j in range(3):\n            # D_i applied to the j-th component of V\n            nabla_V_discrete[i, j] = D(lambda p: V_func(p)[j], i, center_pos, h)\n\n    # Compute Frobenius norm of the error\n    E1 = np.linalg.norm(nabla_V_discrete - nabla_V_analytic, 'fro')\n\n    # --- Common function for Test Cases 2 and 3 ---\n    def compute_metric_compatibility_error(metric_func, pos, h_val):\n        \"\"\"\n        Computes the maximum absolute value of the discrete covariant\n        derivative of the metric, (nabla_k gamma_ij)_d.\n        \"\"\"\n        # 1. Get metric and its inverse at the central point\n        gamma = metric_func(pos)\n        gamma_inv = np.linalg.inv(gamma)\n        \n        # 2. Compute discrete Christoffel symbols (Gamma^k_ij)_d\n        Gamma = np.zeros((3, 3, 3)) # indices: k, i, j\n        \n        # Pre-compute all required metric derivatives D_i gamma_jk\n        # Dgamma[i, j, k] = D_i(gamma_jk)\n        Dgamma = np.zeros((3, 3, 3))\n        for i_deriv in range(3):\n            for j_idx in range(3):\n                for k_idx in range(3):\n                    # Define a lambda to get the component gamma_jk from the metric function\n                    component_func = lambda p: metric_func(p)[j_idx, k_idx]\n                    Dgamma[i_deriv, j_idx, k_idx] = D(component_func, i_deriv, pos, h_val)\n        \n        for k in range(3):\n            for i in range(3):\n                for j in range(3):\n                    # Gamma^k_ij = 0.5 * gamma^kl * (d_i gamma_lj + d_j gamma_li - d_l gamma_ij)\n                    term = Dgamma[i, j, :] + Dgamma[j, i, :] - Dgamma[:, i, j]\n                    Gamma[k, i, j] = 0.5 * np.dot(gamma_inv[k, :], term)\n\n        # 3. Compute discrete covariant derivative of the metric\n        # (nabla_k gamma_ij)_d = D_k gamma_ij - Gamma^l_ki * gamma_lj - Gamma^l_kj * gamma_il\n        nabla_k_gamma_ij = np.zeros((3, 3, 3)) # indices: k, i, j\n        \n        # Contract Christoffel symbols with metric\n        # Using numpy.einsum for clarity and efficiency\n        # term1[k,i,j] = sum_l Gamma[l,k,i]gamma[l,j]\n        term1 = np.einsum('lki,lj-kij', Gamma, gamma)\n        # term2[k,i,j] = sum_l Gamma[l,k,j]gamma[i,l]\n        term2 = np.einsum('lkj,il-kij', Gamma, gamma)\n        \n        nabla_k_gamma_ij = Dgamma - term1 - term2\n        \n        return np.max(np.abs(nabla_k_gamma_ij))\n\n    # --- Test Case 2: Conformally flat metric ---\n    def metric_2(pos):\n        x, y, z = pos\n        psi = 1.0 + 0.2 * (x + y + z)\n        return (psi**4) * np.identity(3)\n        \n    E2 = compute_metric_compatibility_error(metric_2, center_pos, h)\n\n    # --- Test Case 3: Diagonal curved metric ---\n    def metric_3(pos):\n        x, y, z = pos\n        gamma = np.zeros((3, 3))\n        gamma[0, 0] = 1.0 + 0.2 * x**2\n        gamma[1, 1] = 1.0 + 0.1 * y**2\n        gamma[2, 2] = np.exp(0.1 * z)\n        return gamma\n\n    E3 = compute_metric_compatibility_error(metric_3, center_pos, h)\n\n    # --- Final Output ---\n    # Print results in the specified format\n    results = [E1, E2, E3]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "曲率不仅仅是一个抽象的数学符号；它具有可触知的几何后果。本练习 () 将展示曲率最直观的表现之一：和乐（holonomy）。通过将一个矢量沿闭合环路进行数值平行输运，你将观察到它在返回起点时方向发生了改变。你将验证这个旋转角与环路所包围的曲率直接相关，从而在局域微分和全局几何之间建立起有力的联系。",
            "id": "3470813",
            "problem": "考虑一个二维空间切片，在局域坐标 $(x^{1},x^{2})$ 中，其度规分量为 $h_{ij}(x^{1},x^{2})$。设 $v^{i}$ 是一个逆变矢量场，它沿着一个分段光滑的闭环，在平行输运的条件下被输运。沿着切矢量为 $u^{j} = dx^{j}/ds$ 的参数化曲线的平行输运由协变导数约束 $\\nabla_{u} v^{i} = 0$ 定义，即 $dv^{i}/ds + \\Gamma^{i}{}_{jk} u^{j} v^{k} = 0$，其中克里斯托费尔符号 $\\Gamma^{i}{}_{jk}$ 是从该度规构造的列维-奇维塔联络的符号。对于一个与坐标轴对齐的微小矩形闭环，定义一个从基点 $(x^{1}_{0},x^{2}_{0})$ 开始的逆时针遍历：首先沿 $+x^{1}$ 方向移动 $\\Delta x^{1}$，然后沿 $+x^{2}$ 方向移动 $\\Delta x^{2}$，再沿 $-x^{1}$ 方向移动 $\\Delta x^{1}$，最后沿 $-x^{2}$ 方向移动 $\\Delta x^{2}$ 回到基点。净和乐可以由一个单位矢量的带符号旋转角来表征。该单位矢量初始时在基点处与 $x^{1}$ 方向对齐，其旋转角是相对于在基点处由度规定义的标准正交基测量的，单位为弧度。\n\n从协变微分和列维-奇维塔联络的定义，以及由 $\\Gamma^{i}{}_{jk}$ 构造的黎曼曲率张量 $R^{i}{}_{jkl}$ 出发，我们知道对于位于二维曲面上的一个足够小的闭环，其主阶净旋转角等于高斯曲率 $K$ 在所围区域上的面积分。在二维情况下，黎曼张量满足 $R^{i}{}_{jkl} = K \\left(\\delta^{i}{}_{k} h_{jl} - \\delta^{i}{}_{l} h_{jk}\\right)$，并且旋转角等于 $\\int_{\\Sigma} K \\, \\sqrt{\\det h} \\, dx^{1} dx^{2}$，其方向与遍历方向一致。此处，$\\sqrt{\\det h}$ 是度规的面积密度。角度必须以弧度为单位报告。\n\n实现一个程序，该程序能够：\n- 使用一种不假设 $\\Gamma^{i}{}_{jk}$ 为常数的稳定方法，沿着矩形闭环的每条边数值积分平行输运方程。\n- 通过在由 $h_{ij}(x^{1}_{0},x^{2}_{0})$ 定义的标准正交标架中比较初始和最终输运的矢量，计算带符号的和乐角。\n- 通过在基点处计算高斯曲率 $K$ 和面积元 $\\sqrt{\\det h}$，并乘以坐标面积 $\\Delta x^{1} \\Delta x^{2}$ 来计算预测的带符号旋转角，其符号由闭环方向决定（逆时针为正，顺时针为负）。\n- 对每个测试用例，输出数值测量的和乐角与基于曲率的预测之间的带符号差值。\n\n使用以下测试套件。在所有测试用例中，以弧度报告角度，并以单行形式输出结果，该行包含一个逗号分隔的 Python 列表，其中包含按测试用例顺序排列的四个浮点数。这四个测试用例是：\n\n1. 平坦二维空间切片：\n   - 度规 $h_{ij} = \\mathrm{diag}(1,1)$ 在所有位置均成立。\n   - 基点 $(x^{1}_{0},x^{2}_{0}) = (0,0)$。\n   - 矩形尺寸 $\\Delta x^{1} = 10^{-3}$，$\\Delta x^{2} = 2 \\times 10^{-3}$。\n   - 方向：逆时针。\n\n2. 球坐标 $(\\theta,\\phi)$ 中半径为 $r$ 的二维球面：\n   - 度规 $h_{ij} = \\mathrm{diag}(r^{2}, r^{2} \\sin^{2}\\theta)$，其中 $r = 1$。\n   - 基点 $(\\theta_{0},\\phi_{0}) = (0.7, 0.0)$，单位为弧度。\n   - 矩形尺寸 $\\Delta \\theta = 2 \\times 10^{-3}$，$\\Delta \\phi = 3 \\times 10^{-3}$。\n   - 方向：逆时针。\n\n3. $\\mathbb{R}^{2}$ 上的共形平坦“高斯凸包”度规：\n   - 度规 $h_{ij} = \\Omega^{2}(x,y)\\, \\mathrm{diag}(1,1)$，其中 $\\Omega(x,y) = \\exp\\left(\\phi(x,y)\\right)$ 且 $\\phi(x,y) = \\varepsilon \\exp\\left(-\\frac{x^{2}+y^{2}}{\\sigma^{2}}\\right)$，这里 $\\varepsilon = 0.01$ 且 $\\sigma = 0.2$。\n   - 基点 $(x^{1}_{0},x^{2}_{0}) = (0.05,-0.04)$。\n   - 矩形尺寸 $\\Delta x^{1} = 10^{-2}$，$\\Delta x^{2} = 8 \\times 10^{-3}$。\n   - 方向：逆时针。\n\n4. 与用例 3 相同的共形平坦“高斯凸包”度规：\n   - 基点 $(x^{1}_{0},x^{2}_{0}) = (0.05,-0.04)$。\n   - 矩形尺寸 $\\Delta x^{1} = 10^{-3}$，$\\Delta x^{2} = 10^{-3}$。\n   - 方向：顺时针。\n\n你的程序必须：\n- 使用 $\\Gamma^{i}{}_{jk} = \\frac{1}{2} h^{i\\ell} \\left( \\partial_{j} h_{\\ell k} + \\partial_{k} h_{\\ell j} - \\partial_{\\ell} h_{jk} \\right)$ 从 $h_{ij}$ 构造 $\\Gamma^{i}{}_{jk}$，其中 $h^{i\\ell}$ 是逆度规，$\\partial_{j}$ 表示对 $x^{j}$ 的偏导数。\n- 使用足以保证数值稳定性的固定步数，沿每条边积分 $dv^{i}/ds = - \\Gamma^{i}{}_{jk} u^{j} v^{k}$。\n- 计算初始和最终矢量相对于基点处度规的标准正交分量，并使用这些分量之间的有向角来评估带符号旋转。\n- 将预测的带符号角计算为 $s \\, K(x^{1}_{0},x^{2}_{0}) \\sqrt{\\det h(x^{1}_{0},x^{2}_{0})} \\, \\Delta x^{1} \\Delta x^{2}$，其中对于逆时针方向 $s = +1$，对于顺时针方向 $s = -1$。\n- 以“[d1,d2,d3,d4]”的格式，将测试用例 1 至 4 的测量和乐角与基于曲率的预测之间的带符号差值输出为单行。\n\n所有数值角度必须以弧度为单位。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4]”）。",
            "solution": "该问题要求对一个矢量沿微小矩形闭环平行输运后的和乐，与基于局域高斯曲率的理论近似值进行数值比较。我们将通过实现一个用于平行输运方程的高精度数值求解器，并将其结果与解析预测进行比较来解决此问题。\n\n**1. 基本方程**\n\n矢量 $v^i$ 沿参数为 $s$、切矢量为 $u^j = dx^j/ds$ 的曲线的平行输运由以下常微分方程（ODE）系统控制：\n$$\n\\frac{dv^i}{ds} = -\\Gamma^i{}_{jk} u^j v^k\n$$\n其中 $\\Gamma^i{}_{jk}$ 是第二类克里斯托费尔符号，由度规 $h_{ij}$ 导出：\n$$\n\\Gamma^i{}_{jk} = \\frac{1}{2} h^{il} \\left( \\frac{\\partial h_{lk}}{\\partial x^j} + \\frac{\\partial h_{lj}}{\\partial x^k} - \\frac{\\partial h_{jk}}{\\partial x^l} \\right)\n$$\n对于一个包围坐标面积 $A_{\\text{coord}} = \\Delta x^1 \\Delta x^2$ 的小闭环，其净旋转角（和乐）在一阶近似下等于高斯曲率 $K$ 在所围面元 $d\\Sigma$ 上的积分：\n$$\n\\theta_{\\text{predicted}} \\approx s \\int K \\, d\\Sigma = s \\int K \\sqrt{\\det h} \\, dx^1 dx^2 \\approx s \\cdot K(x_0) \\sqrt{\\det h(x_0)} \\cdot \\Delta x^1 \\Delta x^2\n$$\n其中，对于逆时针方向 $s$ 为 $+1$，顺时针方向 $s$ 为 $-1$，$x_0$ 是闭环的基点。我们的目标是计算数值积分得到的和乐角 $\\theta_{\\text{measured}}$ 与此近似值 $\\theta_{\\text{predicted}}$ 之间的差值。\n\n**2. 数值方案**\n\n我们采用四阶龙格-库塔（RK4）积分器来求解平行输运常微分方程系统。对于长度为 $L$、步数为 $N$、步长为 $h=L/N$ 的一段路径，以及形式为 $dy/dt = f(t,y)$ 的常微分方程，单步计算如下：\n$$\n\\begin{align*}\nk_1 = f(t_n, y_n) \\\\\nk_2 = f(t_n + h/2, y_n + h/2 \\cdot k_1) \\\\\nk_3 = f(t_n + h/2, y_n + h/2 \\cdot k_2) \\\\\nk_4 = f(t_n + h, y_n + h \\cdot k_3) \\\\\ny_{n+1} = y_n + \\frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n$$\n此方法依次应用于矩形闭环的四个边段。我们使用足够大的步数（例如，$N=200$）以确保数值误差与所测量的物理效应相比可以忽略不计。\n\n为最大化精度，我们对每个测试用例都使用克里斯托费尔符号和 $K\\sqrt{\\det h}$ 项的解析表达式，从而避免了数值微分的需要。\n\n**3. 和乐角计算**\n\n初始矢量 $v^i_{\\text{initial}}$ 被选为在基点 $x_0$ 处 $x^1$ 方向上的单位矢量，即其逆变分量为 $(1/\\sqrt{h_{11}(x_0)}, 0)$。在绕闭环输运一周后，得到最终矢量 $v^i_{\\text{final}}$。\n\n为测量旋转，我们将 $v^i_{\\text{final}}$ 投影到 $x_0$ 处的标准正交标架上。对于对角度规 $h_{ij} = \\mathrm{diag}(h_{11}, h_{22})$，该标架可以由基矢量 $e_{(\\hat{1})}^i = (1/\\sqrt{h_{11}(x_0)}, 0)$ 和 $e_{(\\hat{2})}^i = (0, 1/\\sqrt{h_{22}(x_0)})$ 定义。最终矢量在该标架中的分量为：\n$$\nV_{(\\hat{1})} = \\sqrt{h_{11}(x_0)} \\, v^1_{\\text{final}}, \\quad V_{(\\hat{2})} = \\sqrt{h_{22}(x_0)} \\, v^2_{\\text{final}}\n$$\n然后，带符号的和乐角计算为 $\\theta_{\\text{measured}} = \\mathrm{atan2}(V_{(\\hat{2})}, V_{(\\hat{1})})$。\n\n**4. 测试用例详解**\n\n*   **用例 1 (平坦空间):** 所有克里斯托费尔符号均为零，且 $K=0$。输运是平凡的（$v^i$ 是常数），测量角和预测角都为零。差值恰好为 $0$。\n*   **用例 2 (球面):** 使用球坐标 $(\\theta, \\phi)$ 和度规 $h_{ij} = \\mathrm{diag}(1, \\sin^2\\theta)$，我们使用已知的解析克里斯托费尔符号和 $K=1$。预测角项为 $K\\sqrt{\\det h} = \\sin\\theta$。\n*   **用例 3 和 4 (高斯凸包):** 度规是共形平坦的，$h_{ij} = e^{2\\phi} \\delta_{ij}$。克里斯托费尔符号由 $\\phi(x,y) = \\varepsilon \\exp(-(x^2+y^2)/\\sigma^2)$ 的解析导数计算得出。预测角项 $K\\sqrt{\\det h}$ 简化为 $-\\nabla^2\\phi$，我们同样使用其解析表达式。\n\n该实现计算了四个用例中每一个的 $\\theta_{\\text{measured}} - \\theta_{\\text{predicted}}$，从而衡量了最低阶曲率近似在多大程度上捕捉了完整的和乐。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the holonomy problem for the four specified test cases.\n    Computes the difference between the numerically measured holonomy angle\n    and the curvature-based prediction.\n    \"\"\"\n\n    # Constants for Case 3 and 4\n    EPSILON = 0.01\n    SIGMA = 0.2\n\n    # ==================================\n    # Christoffel and Curvature Functions\n    # ==================================\n\n    def christoffel_flat(coords):\n        return np.zeros((2, 2, 2))\n\n    def predicted_term_flat(coords):\n        return 0.0\n\n    def christoffel_sphere(coords):\n        theta, _ = coords\n        gamma = np.zeros((2, 2, 2))\n        sin_theta = np.sin(theta)\n        if sin_theta == 0:\n            return gamma\n        cos_theta = np.cos(theta)\n        gamma[0, 1, 1] = -sin_theta * cos_theta\n        gamma[1, 0, 1] = cos_theta / sin_theta\n        gamma[1, 1, 0] = cos_theta / sin_theta\n        return gamma\n\n    def predicted_term_sphere(coords):\n        theta, _ = coords\n        return np.sin(theta)\n\n    def phi_bump(coords):\n        x, y = coords\n        r_sq = x**2 + y**2\n        return EPSILON * np.exp(-r_sq / SIGMA**2)\n\n    def christoffel_bump(coords):\n        x, y = coords\n        gamma = np.zeros((2, 2, 2))\n        p = phi_bump(coords)\n        dp_dx = p * (-2 * x / SIGMA**2)\n        dp_dy =p * (-2 * y / SIGMA**2)\n\n        gamma[0, 0, 0] = dp_dx\n        gamma[1, 0, 0] = -dp_dy\n        gamma[0, 1, 1] = -dp_dx\n        gamma[1, 1, 1] = dp_dy\n        gamma[0, 0, 1] = dp_dy\n        gamma[0, 1, 0] = dp_dy\n        gamma[1, 0, 1] = dp_dx\n        gamma[1, 1, 0] = dp_dx\n        return gamma\n\n    def predicted_term_bump(coords):\n        x, y = coords\n        r_sq = x**2 + y**2\n        p = phi_bump(coords)\n        lap_phi = p * (4 * r_sq / SIGMA**4 - 4 / SIGMA**2)\n        return -lap_phi\n\n    # ==================================\n    # ODE Integrator Framework\n    # ==================================\n\n    def parallel_transport_rhs(v, coords, u, christoffel_func):\n        gamma = christoffel_func(coords)\n        dv = np.zeros(2, dtype=np.float64)\n        for i in range(2):\n            dv[i] = -np.sum(gamma[i, :, :] * np.outer(u, v))\n        return dv\n\n    def rk4_step(f, t, y, h, *f_args):\n        k1 = f(t, y, *f_args)\n        k2 = f(t + h / 2, y + h / 2 * k1, *f_args)\n        k3 = f(t + h / 2, y + h / 2 * k2, *f_args)\n        k4 = f(t + h, y + h * k3, *f_args)\n        return y + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def rhs_segment(s, v, start_point, u, christoffel_func):\n        coords = start_point + s * u\n        return parallel_transport_rhs(v, coords, u, christoffel_func)\n\n    def integrate_segment(v_start, segment_params, christoffel_func, num_steps):\n        v = v_start\n        h = segment_params['len'] / num_steps\n        for i in range(num_steps):\n            s_current = i * h\n            v = rk4_step(rhs_segment, s_current, v, h,\n                         segment_params['start'], segment_params['u'], christoffel_func)\n        return v\n    \n    # ==================================\n    # Main Solver per Case\n    # ==================================\n\n    def solve_case(case_params, num_steps_per_segment=200):\n        name = case_params[\"name\"]\n        base_point = np.array(case_params[\"base_point\"], dtype=np.float64)\n        delta = np.array(case_params[\"delta\"], dtype=np.float64)\n        orientation = case_params[\"orientation\"]\n\n        if name == \"Flat\":\n            metric_func = lambda c: np.identity(2)\n            christoffel_func = christoffel_flat\n            predicted_term_func = predicted_term_flat\n        elif name == \"Sphere\":\n            metric_func = lambda c: np.diag([1.0, np.sin(c[0])**2])\n            christoffel_func = christoffel_sphere\n            predicted_term_func = predicted_term_sphere\n        elif name == \"GaussianBump\":\n            metric_func = lambda c: np.diag([np.exp(2 * phi_bump(c))] * 2)\n            christoffel_func = christoffel_bump\n            predicted_term_func = predicted_term_bump\n        else:\n            raise ValueError(f\"Unknown case name: {name}\")\n\n        predicted_term_at_base = predicted_term_func(base_point)\n        predicted_angle = orientation * predicted_term_at_base * delta[0] * delta[1]\n\n        h0 = metric_func(base_point)\n        v_start = np.array([1.0 / np.sqrt(h0[0, 0]), 0.0], dtype=np.float64)\n\n        p0 = base_point\n        p1 = base_point + np.array([delta[0], 0.0])\n        p2 = base_point + delta\n        p3 = base_point + np.array([0.0, delta[1]])\n\n        if orientation == 1:  # Counter-clockwise\n            segments = [\n                {\"start\": p0, \"u\": np.array([1., 0.]), \"len\": delta[0]},\n                {\"start\": p1, \"u\": np.array([0., 1.]), \"len\": delta[1]},\n                {\"start\": p2, \"u\": np.array([-1., 0.]), \"len\": delta[0]},\n                {\"start\": p3, \"u\": np.array([0., -1.]), \"len\": delta[1]},\n            ]\n        else:  # Clockwise\n            segments = [\n                {\"start\": p0, \"u\": np.array([0., 1.]), \"len\": delta[1]},\n                {\"start\": p3, \"u\": np.array([1., 0.]), \"len\": delta[0]},\n                {\"start\": p2, \"u\": np.array([0., -1.]), \"len\": delta[1]},\n                {\"start\": p1, \"u\": np.array([-1., 0.]), \"len\": delta[0]},\n            ]\n\n        v_current = v_start\n        for seg in segments:\n            v_current = integrate_segment(v_current, seg, christoffel_func, num_steps_per_segment)\n        v_final = v_current\n\n        v_final_ortho = np.array([\n            np.sqrt(h0[0, 0]) * v_final[0],\n            np.sqrt(h0[1, 1]) * v_final[1]\n        ])\n        \n        measured_angle = np.arctan2(v_final_ortho[1], v_final_ortho[0])\n\n        return measured_angle - predicted_angle\n\n    # ==================================\n    # Test Cases Execution\n    # ==================================\n\n    test_cases = [\n        {\n            \"name\": \"Flat\",\n            \"base_point\": (0.0, 0.0),\n            \"delta\": (1e-3, 2e-3),\n            \"orientation\": 1\n        },\n        {\n            \"name\": \"Sphere\",\n            \"base_point\": (0.7, 0.0),\n            \"delta\": (2e-3, 3e-3),\n            \"orientation\": 1\n        },\n        {\n            \"name\": \"GaussianBump\",\n            \"base_point\": (0.05, -0.04),\n            \"delta\": (1e-2, 8e-3),\n            \"orientation\": 1\n        },\n        {\n            \"name\": \"GaussianBump\",\n            \"base_point\": (0.05, -0.04),\n            \"delta\": (1e-3, 1e-3),\n            \"orientation\": -1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        difference = solve_case(case)\n        results.append(difference)\n\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}