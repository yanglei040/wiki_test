{
    "hands_on_practices": [
        {
            "introduction": "引力波由两个独立的偏振态，$h_{+}$ 和 $h_{\\times}$，来描述。为了完整地表征引力波的偏振特性，包括其总强度、线偏振和圆偏振的程度，物理学家借鉴了光学的概念，引入了斯托克斯参数（Stokes parameters）。本实践将指导您从数值相对论模拟输出的应变数据 $h_{+}(t)$ 和 $h_{\\times}(t)$ 出发，实现斯托克斯参数的计算，并验证在坐标基旋转下（例如，由进动引起）这些参数的变换性质。通过这个练习，您将掌握分析引力波偏振的核心工具，并加深对引力波自旋-2 特性的理解。",
            "id": "3483111",
            "problem": "在线性化的横向无迹规范（transverse-traceless gauge）中，一个横向传播的弱引力波由两个实应变分量描述，即“+”偏振（plus polarization）$h_{+}(t)$ 和“×”偏振（cross polarization）$h_{\\times}(t)$。在窄带近似下，偏振可以通过一个由 $h_{+}(t)$ 和 $h_{\\times}(t)$ 的复解析表示构建的偏振相干矩阵来表征。从该相干矩阵，可以定义四个实值偏振斯托克斯参数（Stokes parameters）$(I,Q,U,V)$，它们量化了引力波的总强度、线性偏振分量和圆偏振。偏振基绕传播轴旋转一个物理角度 $\\psi(t)$，由于引力波的自旋为2的特性，会引起实应变分量发生两倍角度的变换。稳健的偏振表征要求此变换的不变量得到遵守：总强度和圆偏振应是基不变的，而线性偏振分量应在它们之间旋转，但其大小保持不变。\n\n基于这些基础：\n- $h_{+}(t)$ 和 $h_{\\times}(t)$ 是在横向无迹规范下，单个探测器测得的实值应变。\n- 与实信号 $x(t)$ 相关联的复解析信号 $a(t)$ 定义为 $a(t) = x(t) + i\\,\\mathcal{H}\\{x(t)\\}$，其中 $\\mathcal{H}\\{\\cdot\\}$ 表示希尔伯特变换（Hilbert transform）。\n- 偏振相干矩阵由与 $h_{+}(t)$ 和 $h_{\\times}(t)$ 相关联的解析信号构建。\n- 在旋转角度 $\\psi(t)$（以弧度为单位）下，物理偏振轴旋转 $2\\psi(t)$，影响着作为双分量场的 $(h_{+},h_{\\times})$。\n\n实现一个程序，以科学上自洽的方式执行以下任务：\n\n1. 对于每个提供的测试用例，构建时间序列 $h_{+}(t)$ 和 $h_{\\times}(t)$，采样率为 $f_s = 4096$ 样本/秒，持续时间为 $T = 1$ 秒，即 $t = 0, 1/f_s, 2/f_s, \\dots, T-1/f_s$。所有角度都必须以弧度处理。\n\n2. 计算与 $h_{+}(t)$ 和 $h_{\\times}(t)$ 相关联的复解析信号 $a_{+}(t)$ 和 $a_{\\times}(t)$，构建偏振相干矩阵，并由此计算斯托克斯参数 $(I(t), Q(t), U(t), V(t))$ 的时间序列。\n\n3. 通过使用 $2\\psi(t)$ 的旋转来变换实应变，从而将偏振基旋转一个指定的随时间变化的角度 $\\psi(t)$，并在旋转后的基中重新计算解析信号和斯托克斯参数 $(I'(t), Q'(t), U'(t), V'(t))$。\n\n4. 通过为每个测试用例计算以下无量纲误差度量，来量化在进动（precession）和模式混合（mode-mixing）下的稳健性：\n   $$e_{I} = \\frac{\\max_{t} \\left| I(t) - I'(t) \\right|}{\\max_{t} \\left| I(t) \\right| + \\epsilon}$$\n   $$e_{V} = \\frac{\\max_{t} \\left| V(t) - V'(t) \\right|}{\\max_{t} \\left| V(t) \\right| + \\epsilon}$$\n   $$e_{L} = \\frac{\\max_{t} \\left| \\sqrt{Q(t)^{2} + U(t)^{2}} - \\sqrt{Q'(t)^{2} + U'(t)^{2}} \\right|}{\\max_{t} \\left( \\sqrt{Q(t)^{2} + U(t)^{2}} \\right) + \\epsilon}$$\n   其中 $\\epsilon = 10^{-30}$ 是一个用于避免除以零的小正数常量。这些度量旨在测试在基旋转下强度和圆偏振的不变性，以及在混合 $Q$ 和 $U$ 的旋转下线性偏振大小的不变性。所有输出均为无量纲实数。\n\n5. 使用以下科学上合理的测试套件，该套件旨在探究一个理想路径情况（happy path case）、一个边界情况（boundary case）以及一个带模式混合的边缘情况（edge case）：\n   - 测试用例1（理想路径，缓慢变化的进动，近圆偏振）：\n     - 振幅 $A = 10^{-21}$，\n     - 频率 $f = 150$ 赫兹，\n     - $h_{+}(t) = A \\cos(2\\pi f t)$，\n     - $h_{\\times}(t) = A \\sin(2\\pi f t)$，\n     - 进动角 $\\psi(t) = 0.5 \\sin(2\\pi \\cdot 1 \\cdot t)$ 弧度。\n   - 测试用例2（边界情况，线性偏振）：\n     - 振幅 $A = 10^{-21}$，\n     - 频率 $f = 100$ 赫兹，\n     - $h_{+}(t) = A \\cos(2\\pi f t)$，\n     - $h_{\\times}(t) = 0$，\n     - 旋转角 $\\psi(t) = 0.25\\, t$ 弧度。\n   - 测试用例3（边缘情况，模式混合和更快的进动）：\n     - 基础振幅 $A = 10^{-21}$，\n     - 频率 $f_{1} = 90$ 赫兹 和 $f_{2} = 130$ 赫兹，\n     - 振幅 $A_{1} = A$, $A_{2} = 0.6 A$, $B_{1} = 0.8 A$，\n     - 相位 $\\phi_{2} = 0.3$ 弧度 和 $\\phi_{\\times} = -0.2$ 弧度，\n     - $h_{+}(t) = A_{1} \\cos(2\\pi f_{1} t) + A_{2} \\cos(2\\pi f_{2} t + \\phi_{2})$，\n     - $h_{\\times}(t) = B_{1} \\sin(2\\pi f_{1} t + \\phi_{\\times})$，\n     - 进动角 $\\psi(t) = 0.8 \\sin(2\\pi \\cdot 3 \\cdot t)$ 弧度。\n\n您的程序应生成单行输出，其中包含三个测试用例的结果，形式为方括号括起来的逗号分隔列表，顺序为 `[e_{I}^{(1)}, e_{V}^{(1)}, e_{L}^{(1)}, e_{I}^{(2)}, e_{V}^{(2)}, e_{L}^{(2)}, e_{I}^{(3)}, e_{V}^{(3)}, e_{L}^{(3)}]`，其中上标表示测试用例编号。所有输出都必须表示为无量纲浮点数。角度必须以弧度处理，时间以秒处理。不允许外部输入；测试套件如上所述是固定的，并且必须嵌入到程序中。",
            "solution": "问题陈述已经过评估并被确定为有效。它在科学上基于广义相对论和引力波数据分析的原理，其定义和参数完整、一致，问题是适定的，并且其表述是客观的。因此，我们可以着手解决。\n\n这个问题的核心是验证引力波斯托克斯参数在偏振基旋转下的变换性质。斯托克斯参数 $(I, Q, U, V)$ 提供了对横波偏振状态的完整描述。对于像引力波这样的自旋为2的场，由这些参数构造的某些量在探测器坐标系物理旋转角度 $\\psi(t)$ 时必须保持不变。具体来说，总强度 $I(t)$ 和净圆偏振 $V(t)$ 必须是标量，因此是不变的。线性偏振分量 $Q(t)$ 和 $U(t)$ 在一个概念上的“偏振平面”中形成一个矢量，并预期在它们之间旋转，但这个线性偏振矢量的大小 $L(t) = \\sqrt{Q(t)^2 + U(t)^2}$ 必须是不变的。\n\n对每个测试用例，解决方案框架包括以下步骤序列：\n1.  将连续时间变量 $t$ 离散化。\n2.  生成“+”偏振 $h_+(t)$ 和“×”偏振 $h_\\times(t)$ 的时间序列。\n3.  计算相关的复解析信号 $a_+(t)$ 和 $a_\\times(t)$。\n4.  计算初始的斯托克斯参数集 $(I(t), Q(t), U(t), V(t))$。\n5.  将指定的时间相关旋转应用于应变分量，以获得旋转后的应变 $h'_+(t)$ 和 $h'_\\times(t)$。\n6.  为旋转后的系统重新计算解析信号和斯托克斯参数 $(I'(t), Q'(t), U'(t), V'(t))$。\n7.  计算误差度量 $e_I$、 $e_V$ 和 $e_L$ 以量化理论上不变的量的不变性。\n\n**步骤1：时间离散化**\n连续时间变量 $t$ 在 $T=1$ 秒的持续时间内以 $f_s=4096$ 赫兹的采样频率进行采样。这产生 $N = T \\cdot f_s = 4096$ 个离散时间点。时间向量由 $t_k = k / f_s$ 给出，其中 $k = 0, 1, \\dots, N-1$。\n\n**步骤2：波形生成**\n对于每个测试用例，我们使用提供的函数形式和参数生成离散时间序列 $h_+(t_k)$ 和 $h_\\times(t_k)$。\n\n**步骤3：复解析信号**\n对应于实信号 $x(t)$ 的解析信号 $a(t)$ 是一个复信号，定义为 $a(t) = x(t) + i\\mathcal{H}\\{x(t)\\}$，其中 $\\mathcal{H}\\{\\cdot\\}$ 是希尔伯特变换 (Hilbert transform)。函数的希尔伯特变换可以使用快速傅里叶变换（FFT）高效计算。具体来说，如果 $X(f) = \\mathcal{F}\\{x(t)\\}$ 是 $x(t)$ 的傅里叶变换，那么其希尔伯特变换的傅里叶变换是 $\\mathcal{F}\\{\\mathcal{H}\\{x(t)\\}\\}(f) = -i \\cdot \\operatorname{sgn}(f) \\cdot X(f)$。然后通过对 $f>0$ 时的 $2X(f)$ 和 $f=0$ 时的 $X(f)$（以及 $f<0$ 时的零）进行傅里叶逆变换来构造解析信号。在计算上，这由 `scipy.signal.hilbert` 函数处理。我们从实应变数据 $h_+(t_k)$ 和 $h_\\times(t_k)$ 计算 $a_+(t_k)$ 和 $a_\\times(t_k)$。\n\n**步骤4：斯托克斯参数的计算**\n瞬时斯托克斯参数是根据解析信号 $a_+(t)$ 和 $a_\\times(t)$ 定义的。这些定义源于瞬时偏振相干矩阵的分量。\n- 总强度：$I(t) = |a_+(t)|^2 + |a_\\times(t)|^2$\n- 线性偏振（水平/垂直）：$Q(t) = |a_+(t)|^2 - |a_\\times(t)|^2$\n- 线性偏振（对角）：$U(t) = 2 \\operatorname{Re}[a_+^*(t) a_\\times(t)]$\n- 圆偏振：$V(t) = 2 \\operatorname{Im}[a_+^*(t) a_\\times(t)]$\n\n这里，$a_+^*(t)$ 是 $a_+(t)$ 的复共轭。这些公式应用于时间序列 $a_+(t_k)$ 和 $a_\\times(t_k)$ 以获得 $I(t_k)$、 $Q(t_k)$、 $U(t_k)$ 和 $V(t_k)$ 的离散时间序列。\n\n**步骤5：偏振基的旋转**\n探测器轴围绕波的传播方向物理旋转一个角度 $\\psi(t)$ 会导致应变分量的变换。由于引力场的自旋为2的性质，在新基中测量的分量 $(h'_+, h'_\\times)$ 通过一个旋转角为 $\\theta(t) = 2\\psi(t)$ 的旋转矩阵与原始分量相关联。\n$$\n\\begin{pmatrix} h'_+(t) \\\\ h'_\\times(t) \\end{pmatrix} = \\begin{pmatrix} \\cos(2\\psi(t)) & \\sin(2\\psi(t)) \\\\ -\\sin(2\\psi(t)) & \\cos(2\\psi(t)) \\end{pmatrix} \\begin{pmatrix} h_+(t) \\\\ h_\\times(t) \\end{pmatrix}\n$$\n我们将此变换应用于原始应变时间序列 $h_+(t_k)$ 和 $h_\\times(t_k)$ 以生成旋转后的时间序列 $h'_+(t_k)$ 和 $h'_\\times(t_k)$。\n\n**步骤6：重新计算斯托克斯参数**\n遵循与步骤3和4相同的过程，我们首先计算与旋转后的实应变 $h'_+(t_k)$ 和 $h'_\\times(t_k)$ 相对应的解析信号 $a'_+(t_k)$ 和 $a'_\\times(t_k)$。然后，我们使用相同的公式计算新的斯托克斯参数 $(I'(t_k), Q'(t_k), U'(t_k), V'(t_k))$：\n- $I'(t) = |a'_+(t)|^2 + |a'_\\times(t)|^2$\n- $Q'(t) = |a'_+(t)|^2 - |a'_\\times(t)|^2$\n- $U'(t) = 2 \\operatorname{Re}[a'^*_+(t) a'_\\times(t)]$\n- $V'(t) = 2 \\operatorname{Im}[a'^*_+(t) a'_\\times(t)]$\n\n**步骤7：误差度量的计算**\n最后一步是量化与理论不变量的数值一致性。我们计算三个指定的误差度量，它们测量计算出的不变量的相对偏差。\n- $e_I = \\displaystyle \\frac{\\max_{t} | I(t) - I'(t) |}{\\max_{t} | I(t) | + \\epsilon}$\n- $e_V = \\displaystyle \\frac{\\max_{t} | V(t) - V'(t) |}{\\max_{t} | V(t) | + \\epsilon}$\n- $e_L = \\displaystyle \\frac{\\max_{t} \\left| \\sqrt{Q(t)^2 + U(t)^2} - \\sqrt{Q'(t)^2 + U'(t)^2} \\right|}{\\max_{t} (\\sqrt{Q(t)^2 + U(t)^2}) + \\epsilon}$\n常数 $\\epsilon = 10^{-30}$ 确保在理论上某个量为零（例如，对于纯线性偏振波的 $V(t)$）的情况下具有数值稳定性。预期的结果是这些误差将在机器精度的量级，从而证实斯托克斯参数表述在基旋转下的稳健性。\n\n整个过程为三个测试用例中的每一个都实施，并将得到的九个误差度量收集起来作为最终输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import hilbert\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave polarization problem by generating waveforms,\n    computing Stokes parameters, applying basis rotations, and calculating\n    invariance error metrics for three test cases.\n    \"\"\"\n    \n    # Global parameters\n    f_s = 4096.0  # Sampling rate in Hz\n    T = 1.0       # Duration in seconds\n    epsilon = 1e-30 # Small constant for numerical stability\n\n    # Time vector\n    t = np.arange(0, T, 1 / f_s)\n    \n    # Test case definitions\n    A = 1e-21\n    \n    test_cases = [\n        {\n            \"name\": \"Case 1: Near-circular polarization, slow precession\",\n            \"h_plus_func\": lambda t: A * np.cos(2 * np.pi * 150 * t),\n            \"h_cross_func\": lambda t: A * np.sin(2 * np.pi * 150 * t),\n            \"psi_func\": lambda t: 0.5 * np.sin(2 * np.pi * 1 * t)\n        },\n        {\n            \"name\": \"Case 2: Linear polarization\",\n            \"h_plus_func\": lambda t: A * np.cos(2 * np.pi * 100 * t),\n            \"h_cross_func\": lambda t: np.zeros_like(t),\n            \"psi_func\": lambda t: 0.25 * t\n        },\n        {\n            \"name\": \"Case 3: Mode-mixing, fast precession\",\n            \"h_plus_func\": lambda t: (A * np.cos(2 * np.pi * 90 * t) + \n                                     0.6 * A * np.cos(2 * np.pi * 130 * t + 0.3)),\n            \"h_cross_func\": lambda t: 0.8 * A * np.sin(2 * np.pi * 90 * t - 0.2),\n            \"psi_func\": lambda t: 0.8 * np.sin(2 * np.pi * 3 * t)\n        }\n    ]\n\n    all_results = []\n\n    def compute_stokes(h_plus, h_cross):\n        \"\"\"Computes instantaneous Stokes parameters from real strain data.\"\"\"\n        a_plus = hilbert(h_plus)\n        a_cross = hilbert(h_cross)\n        \n        a_plus_conj = np.conj(a_plus)\n        \n        I = np.abs(a_plus)**2 + np.abs(a_cross)**2\n        Q = np.abs(a_plus)**2 - np.abs(a_cross)**2\n        U = 2 * np.real(a_plus_conj * a_cross)\n        V = 2 * np.imag(a_plus_conj * a_cross)\n        \n        return I, Q, U, V\n\n    for case in test_cases:\n        # 1. Generate original waveforms\n        h_plus = case[\"h_plus_func\"](t)\n        h_cross = case[\"h_cross_func\"](t)\n        \n        # 2. Compute original Stokes parameters\n        I, Q, U, V = compute_stokes(h_plus, h_cross)\n        \n        # 3. Generate rotated waveforms\n        psi = case[\"psi_func\"](t)\n        theta = 2 * psi\n        cos_theta = np.cos(theta)\n        sin_theta = np.sin(theta)\n        \n        h_plus_rot = h_plus * cos_theta + h_cross * sin_theta\n        h_cross_rot = -h_plus * sin_theta + h_cross * cos_theta\n        \n        # 4. Compute rotated Stokes parameters\n        I_rot, Q_rot, U_rot, V_rot = compute_stokes(h_plus_rot, h_cross_rot)\n        \n        # 5. Compute error metrics\n        # Error for I\n        numerator_I = np.max(np.abs(I - I_rot))\n        denominator_I = np.max(np.abs(I)) + epsilon\n        e_I = numerator_I / denominator_I\n        \n        # Error for V\n        numerator_V = np.max(np.abs(V - V_rot))\n        denominator_V = np.max(np.abs(V)) + epsilon\n        e_V = numerator_V / denominator_V\n        \n        # Error for L = sqrt(Q^2 + U^2)\n        L = np.sqrt(Q**2 + U**2)\n        L_rot = np.sqrt(Q_rot**2 + U_rot**2)\n        numerator_L = np.max(np.abs(L - L_rot))\n        denominator_L = np.max(L) + epsilon\n        e_L = numerator_L / denominator_L\n        \n        all_results.extend([e_I, e_V, e_L])\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在了解了如何利用斯托克斯参数分析引力波偏振之后，一个自然的问题是：我们如何从数值相对论模拟中获得高精度的引力波应变信号 $h(t)$ 呢？通常有两种主要方法：直接从度规张量 $g_{ab}$ 中提取，或者对纽曼-彭罗斯（Newman-Penrose）曲率标量 $\\Psi_4$ 进行两次时间积分，因为在真空区域的未来类光无穷远处，它们满足基本关系 $\\Psi_4 = \\ddot{h}(t)$。本实践将引导您实现这两种方法，并处理积分过程中出现的实际数值问题，例如积分常数和长期漂移。通过解决一个最小二乘拟合问题来对齐两种方法得到的结果，您将学会验证和交叉检验数值模拟波形提取过程的关键技术。",
            "id": "3483091",
            "problem": "给定一个在广义相对论（GR）线性化机制下的合成真空平面波引力信号，该信号沿 $z$ 轴传播。在横向无迹（TT）规范中，两个偏振态由应变分量 $h_{+}(t)$ 和 $h_{\\times}(t)$ 表示，复应变定义为 $h(t) = h_{+}(t) - i\\,h_{\\times}(t)$。在未来零无穷处的 Newman-Penrose (NP) 形式体系中，曲率标量 $\\Psi_{4}(t)$ 等于复应变的二阶时间导数，即 $\\Psi_{4}(t) = \\ddot{h}(t)$。您的任务是实现两个独立的流程，从两种数据产品中恢复 $h_{+}(t)$ 和 $h_{\\times}(t)$，并通过相位对齐来调和积分常数和漂移，然后量化其一致性。\n\n基本基础：\n- 真空中的线性化 GR，TT 规范中的平面波解，其中空间度规为 $g_{ij}(t) = \\delta_{ij} + h_{ij}^{\\mathrm{TT}}(t)$，且 $h_{ij}^{\\mathrm{TT}}$ 是无迹和横向的。\n- 对于沿 $z$ 轴传播的情况，在 TT 规范中，$h_{ij}^{\\mathrm{TT}}(t)$ 编码了两个偏振 $h_{+}(t)$ 和 $h_{\\times}(t)$。\n- 未来零无穷处的 Newman-Penrose 标量 $\\Psi_{4}(t)$ 等于复应变 $h(t)$ 的二阶时间导数。\n- 离散时间序列将使用快速傅里叶变换（FFT）及其逆变换（IFFT）处理，通过频域操作执行时间积分和微分。\n\n对于下述三个测试用例，您必须：\n- 合成一个具有指定振幅包络和相位演化的复应变 $h(t)$。\n- 从该应变在 TT 规范下构建空间度规分量 $g_{xx}(t)$、$g_{yy}(t)$、$g_{xy}(t)$。\n- 通过在频域中对复应变应用二阶时间导数来构建 $\\Psi_{4}(t)$。\n- 通过在频域中使用高通正则化进行二次时间积分，从 $\\Psi_{4}(t)$ 中恢复 $h(t)$：对于傅里叶角频率 $\\omega$ 满足 $|\\omega| < \\omega_{\\mathrm{cut}}$ 的情况，将相应的复应变傅里叶模式设置为零；对于 $|\\omega| \\ge \\omega_{\\mathrm{cut}}$ 的情况，除以 $-\\omega^{2}$。使用 $f_{\\mathrm{cut}} = 5$ 赫兹的截止频率，即 $\\omega_{\\mathrm{cut}} = 2\\pi f_{\\mathrm{cut}}$。角度以弧度为单位。\n- 通过识别与沿 $z$ 轴的平面波一致的 TT 分量，直接从度规中恢复 $h(t)$，即从空间度规中提取 $h_{+}(t)$ 和 $h_{\\times}(t)$，并构建 $h(t) = h_{+}(t) - i\\,h_{\\times}(t)$。\n- 通过使用复数最小二乘法将基于曲率的重建 $h_{\\mathrm{curv}}(t)$ 与基于度规的重建 $h_{\\mathrm{metric}}(t)$ 对齐，确定使时域平方误差最小化的复常数 $c_{0}$ 和 $c_{1}$，从而调和积分常数和可能的残余漂移\n$$\n\\sum_{k=0}^{N-1} \\left| \\left(h_{\\mathrm{curv}}(t_{k}) + c_{0} + c_{1}\\,t_{k}\\right) - h_{\\mathrm{metric}}(t_{k}) \\right|^{2},\n$$\n并将对齐后的重建定义为 $h_{\\mathrm{aligned}}(t) = h_{\\mathrm{curv}}(t) + c_{0} + c_{1}\\,t$。\n- 对于每个测试用例，报告最大绝对差\n$$\n\\Delta_{\\infty} = \\max_{k} \\left| h_{\\mathrm{aligned}}(t_{k}) - h_{\\mathrm{metric}}(t_{k}) \\right|.\n$$\n\n合成信号规范（所有振幅均为无量纲；时间单位为秒；频率单位为赫兹；角度单位为弧度）：\n- 复应变由下式给出\n$$\nh(t) = A(t)\\,\\exp\\!\\left( i\\,\\phi(t) \\right)\\,\\exp\\!\\left(-2i\\,\\psi\\right),\n$$\n其中偏振角为 $\\psi$，相位为\n$$\n\\phi(t) = 2\\pi\\left(f_{0}\\,t + \\tfrac{1}{2}\\,\\dot{f}\\,t^{2}\\right) + \\phi_{0},\n$$\n振幅包络为 $A(t) = A_{0}\\,\\left(1 + \\alpha\\,t\\right)$。\n- 通过 $h_{+}(t) = \\operatorname{Re}[h(t)]$ 和 $h_{\\times}(t) = -\\operatorname{Im}[h(t)]$ 构建 TT 空间度规分量\n$g_{xx}(t) = 1 + h_{+}(t)$，$g_{yy}(t) = 1 - h_{+}(t)$，以及 $g_{xy}(t) = h_{\\times}(t)$。\n- 通过在频域中对 $h(t)$ 应用二阶时间导数来构建 $\\Psi_{4}(t)$。\n\n相位对齐与漂移处理：\n- 从 $\\Psi_{4}(t)$ 重建 $h_{\\mathrm{curv}}(t)$ 后，通过最小化上述最小二乘目标函数来确定复常数 $c_{0}$ 和 $c_{1}$，并用它们定义 $h_{\\mathrm{aligned}}(t)$。\n- 对于测试用例 3，通过在比较前向基于度规的应变添加一个复数仿射趋势 $d_{0} + d_{1}\\,t$ 来模拟规范类漂移；此漂移必须在对齐阶段被吸收。\n\n测试套件：\n- 使用以下三组参数来合成数据。设时间样本为 $t_{k} = k\\,\\Delta t$，其中 $k = 0,1,\\dots,N-1$，$N = \\lfloor T/\\Delta t \\rfloor$。\n    1. 测试用例 1（恒定频率，恒定振幅）：\n       - $T = 0.5$, $\\Delta t = 1/4096$, $A_{0} = 1.0\\times 10^{-21}$, $\\alpha = 0.0$, $f_{0} = 100.0$, $\\dot{f} = 0.0$, $\\psi = 0.3$, $\\phi_{0} = 0.2$.\n    2. 测试用例 2（线性啁啾，振幅上升）：\n       - $T = 1.0$, $\\Delta t = 1/4096$, $A_{0} = 5.0\\times 10^{-22}$, $\\alpha = 0.8$, $f_{0} = 50.0$, $\\dot{f} = 120.0$, $\\psi = -0.5$, $\\phi_{0} = 0.1$.\n    3. 测试用例 3（线性啁啾，振幅上升，度规漂移）：\n       - $T = 1.0$, $\\Delta t = 1/4096$, $A_{0} = 8.0\\times 10^{-22}$, $\\alpha = 0.5$, $f_{0} = 80.0$, $\\dot{f} = 80.0$, $\\psi = 0.8$, $\\phi_{0} = -0.3$.\n       - 度规漂移：向基于度规的复应变添加 $d_{0} + d_{1}\\,t$，其中 $d_{0} = 3.0\\times 10^{-23}\\,\\exp(i\\,0.2)$ 和 $d_{1} = 1.0\\times 10^{-23}\\,\\exp(-i\\,0.5)$。\n\n数值方法要求：\n- 对均匀采样的时间序列使用 FFT/IFFT 对，在频域中实现微分和积分。设角频率为 $\\omega_{k} = 2\\pi\\,k/T$，并根据 FFT 频率约定进行映射。\n- 要从 $h(t)$ 构建 $\\Psi_{4}(t)$，将 $h(t)$ 的傅里叶变换乘以 $-\\omega^{2}$，然后应用 IFFT。\n- 要从 $\\Psi_{4}(t)$ 重建 $h(t)$，在 $|\\omega| \\ge \\omega_{\\mathrm{cut}}$ 的地方将 $\\Psi_{4}(t)$ 的傅里叶变换除以 $-\\omega^{2}$，并在 $|\\omega| < \\omega_{\\mathrm{cut}}$ 的地方将模式设置为零，然后应用 IFFT。\n- 通过对整个时间区间进行线性回归，独立求解 $c_{0}$ 和 $c_{1}$ 的实部和虚部，从而执行复数最小二乘对齐。\n\n输出规范：\n- 对于三个测试用例中的每一个，计算如上定义的 $\\Delta_{\\infty}$。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序为测试用例 1、测试用例 2、测试用例 3，例如：“[result1,result2,result3]”。\n- 输出必须是十进制浮点数。不打印单位；在 $G=c=1$ 的几何化单位制中，所有量都是无量纲的，时间单位为秒，角度单位为弧度。",
            "solution": "所提出的问题是有效的。这是一个定义明确、有科学依据的数值相对论和引力波数据分析练习。其前提基于广义相对论线性化理论的既定原则，数值任务定义清晰，并提供了所有必要的参数。我们将提供一个完整的解决方案。\n\n核心任务是从一个合成数据集中调和引力波（GW）应变 $h(t) = h_{+}(t) - i h_{\\times}(t)$ 的两种独立重建。第一种重建 $h_{\\mathrm{metric}}(t)$ 直接从空间度规张量的分量导出。第二种重建 $h_{\\mathrm{curv}}(t)$ 通过对 Newman-Penrose 曲率标量 $\\Psi_{4}(t)$ 进行积分获得。关系式 $\\Psi_{4}(t) = \\ddot{h}(t)$ 对于未来零无穷处的真空中平面波是基础性的。两种重建之间的差异（源于数值方法和引入的漂移）将通过最小二乘对齐程序来解决。最终的一致性通过对齐后信号与基于度规的信号之间的最大绝对差来量化。\n\n该过程针对三个不同的测试用例执行，遵循以下步骤：\n\n1.  **合成信号生成**\n    首先，我们为一个沿 $z$ 轴传播的平面波合成“真实”的复引力波应变 $h_{\\mathrm{true}}(t)$。该信号由其振幅包络 $A(t)$、时间相位 $\\phi(t)$ 和一个恒定的偏振角 $\\psi$ 定义：\n    $$\n    h_{\\mathrm{true}}(t) = A(t) \\exp(i\\phi(t)) \\exp(-2i\\psi)\n    $$\n    振幅包络随时间线性变化，$A(t) = A_{0}(1 + \\alpha t)$，相位代表一个瞬时频率线性变化的信号（“啁啾”），$\\phi(t) = 2\\pi\\left(f_{0}t + \\frac{1}{2}\\dot{f}t^{2}\\right) + \\phi_{0}$。\n    信号在一个均匀的时间网格 $t_k = k\\Delta t$ 上采样，其中 $k = 0, \\dots, N-1$，$N = \\lfloor T/\\Delta t \\rfloor$。\n\n2.  **流程 1：基于度规的应变重建**\n    第一个重建流程使用横向无迹（TT）规范下的空间度规分量。从真实的复应变 $h_{\\mathrm{true}}(t)$，我们定义两个实数偏振分量：\n    $$\n    h_{+}(t) = \\operatorname{Re}[h_{\\mathrm{true}}(t)]\n    $$\n    $$\n    h_{\\times}(t) = -\\operatorname{Im}[h_{\\mathrm{true}}(t)]\n    $$\n    然后，通过组合这些偏振分量来构建基于度规的重建 $h_{\\mathrm{metric}}(t)$，这等同于原始的真实应变 $h_{\\mathrm{true}}(t)$。\n    $$\n    h_{\\mathrm{metric}}(t) = h_{+}(t) - i h_{\\times}(t) = h_{\\mathrm{true}}(t)\n    $$\n    对于测试用例 3，一个合成的复数仿射漂移 $d(t) = d_{0} + d_{1}t$ 被添加到此重建中，以模拟真实数值模拟中可能出现的规范伪影。\n    $$\n    h_{\\mathrm{metric}}(t)|_{\\text{Case 3}} = h_{\\mathrm{true}}(t) + d_{0} + d_{1}t\n    $$\n    这个 $h_{\\mathrm{metric}}(t)$ 作为对齐过程的“基准真相”或目标。\n\n3.  **流程 2：基于曲率的应变重建**\n    第二个流程从 Newman-Penrose 标量 $\\Psi_{4}(t)$ 开始。此标量通过对真实应变 $h_{\\mathrm{true}}(t)$ 取二阶时间导数来构建。此操作最方便在频域中使用快速傅里叶变换（FFT）执行。函数 $f(t)$ 的二阶导数的傅里叶变换与函数本身 $\\tilde{f}(\\omega)$ 的傅里叶变换相关，关系如下：\n    $$\n    \\mathcal{F}[\\ddot{f}(t)](\\omega) = (i\\omega)^2 \\tilde{f}(\\omega) = -\\omega^2 \\tilde{f}(\\omega)\n    $$\n    因此，我们通过对 $h_{\\mathrm{true}}(t)$ 进行 FFT，将结果与离散频谱中的每个角频率 $\\omega_k$ 对应的 $-\\omega^2$ 相乘，然后应用逆 FFT（IFFT）来计算 $\\Psi_{4}(t)$。\n\n    接下来，我们通过逆转此过程来恢复应变 $h_{\\mathrm{curv}}(t)$，即对 $\\Psi_{4}(t)$ 执行二次积分。在频域中，这对应于将 $\\Psi_{4}(t)$ 的傅里叶变换（表示为 $\\tilde{\\Psi}_{4}(\\omega)$）除以 $-\\omega^2$。这种除法在 $\\omega=0$ 处是未定义的，并且会放大低频噪声。为了处理这个问题，我们应用了高通正则化：\n    $$\n    \\tilde{h}_{\\mathrm{curv}}(\\omega) =\n    \\begin{cases}\n    \\tilde{\\Psi}_{4}(\\omega) / (-\\omega^2) & \\text{if } |\\omega| \\ge \\omega_{\\mathrm{cut}} \\\\\n    0 & \\text{if } |\\omega| < \\omega_{\\mathrm{cut}}\n    \\end{cases}\n    $$\n    其中截止角频率为 $\\omega_{\\mathrm{cut}} = 2\\pi f_{\\mathrm{cut}}$，且 $f_{\\mathrm{cut}} = 5$ Hz。对 $\\tilde{h}_{\\mathrm{curv}}(\\omega)$ 应用 IFFT 得到时域波形 $h_{\\mathrm{curv}}(t)$。正则化有效地丢弃了关于积分信号的常数项和线性项的信息，而这些正是二次不定积分的积分常数。\n\n4.  **调和与对齐**\n    由于正则化移除了低频内容，以及 $h_{\\mathrm{metric}}(t)$ 中存在的任何额外低频漂移（如测试用例 3 中），基于曲率的重建 $h_{\\mathrm{curv}}(t)$ 将与基于度规的重建 $h_{\\mathrm{metric}}(t)$ 不同。这些差异预计可以由一个复数仿射函数 $C(t) = c_{0} + c_{1}t$ 很好地近似。我们通过最小化时域平方误差来确定复系数 $c_0$ 和 $c_1$：\n    $$\n    \\min_{c_0, c_1} \\sum_{k=0}^{N-1} \\left| h_{\\mathrm{metric}}(t_k) - (h_{\\mathrm{curv}}(t_k) + c_{0} + c_{1}t_k) \\right|^{2}\n    $$\n    这等效于为残差信号 $\\Delta h(t) = h_{\\mathrm{metric}}(t) - h_{\\mathrm{curv}}(t)$ 找到一条最佳拟合直线 $c_0 + c_1 t$。这个复数线性最小二乘问题可以解耦为两个独立的实数线性最小二乘问题，分别针对系数的实部和虚部：\n    $$\n    \\min_{c_{0r}, c_{1r}} \\sum_{k=0}^{N-1} \\left( \\operatorname{Re}[\\Delta h(t_k)] - (c_{0r} + c_{1r} t_k) \\right)^{2}\n    $$\n    $$\n    \\min_{c_{0i}, c_{1i}} \\sum_{k=0}^{N-1} \\left( \\operatorname{Im}[\\Delta h(t_k)] - (c_{0i} + c_{1i} t_k) \\right)^{2}\n    $$\n    这些问题使用标准的线性回归技术求解。一旦找到 $c_0 = c_{0r} + i c_{0i}$ 和 $c_1 = c_{1r} + i c_{1i}$，对齐后的基于曲率的应变定义为 $h_{\\mathrm{aligned}}(t) = h_{\\mathrm{curv}}(t) + c_0 + c_1 t$。\n\n5.  **一致性量化**\n    最后，两个流程在对齐后的一致性通过计算整个时间序列上的最大绝对差来量化：\n    $$\n    \\Delta_{\\infty} = \\max_{k} \\left| h_{\\mathrm{aligned}}(t_{k}) - h_{\\mathrm{metric}}(t_{k}) \\right|\n    $$\n    该值表示仿射拟合未捕获的最大残差误差的大小，为两种重建方法之间的内在一致性提供了一个度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave strain reconstruction and alignment problem\n    for three test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1 (constant frequency, constant amplitude)\n        {\n            \"T\": 0.5, \"dt\": 1/4096, \"A0\": 1.0e-21, \"alpha\": 0.0,\n            \"f0\": 100.0, \"f_dot\": 0.0, \"psi\": 0.3, \"phi0\": 0.2,\n            \"drift\": None\n        },\n        # Test Case 2 (linear chirp, rising amplitude)\n        {\n            \"T\": 1.0, \"dt\": 1/4096, \"A0\": 5.0e-22, \"alpha\": 0.8,\n            \"f0\": 50.0, \"f_dot\": 120.0, \"psi\": -0.5, \"phi0\": 0.1,\n            \"drift\": None\n        },\n        # Test Case 3 (linear chirp, rising amplitude, metric drift)\n        {\n            \"T\": 1.0, \"dt\": 1/4096, \"A0\": 8.0e-22, \"alpha\": 0.5,\n            \"f0\": 80.0, \"f_dot\": 80.0, \"psi\": 0.8, \"phi0\": -0.3,\n            \"drift\": {\n                \"d0\": 3.0e-23 * np.exp(1j * 0.2),\n                \"d1\": 1.0e-23 * np.exp(1j * -0.5)\n            }\n        },\n    ]\n\n    f_cut = 5.0  # Cutoff frequency in Hz for regularization\n\n    results = []\n    for params in test_cases:\n        # 1. Setup\n        T = params[\"T\"]\n        dt = params[\"dt\"]\n        N = int(T / dt)  # Per problem spec, floor is implicit with int cast\n        t = np.arange(N) * dt\n        \n        # 2. Synthesize Ground Truth Signal\n        A0, alpha = params[\"A0\"], params[\"alpha\"]\n        f0, f_dot = params[\"f0\"], params[\"f_dot\"]\n        psi, phi0 = params[\"psi\"], params[\"phi0\"]\n\n        amplitude = A0 * (1 + alpha * t)\n        phase = 2 * np.pi * (f0 * t + 0.5 * f_dot * t**2) + phi0\n        polarization_phase = -2 * psi\n\n        h_true = amplitude * np.exp(1j * phase) * np.exp(1j * polarization_phase)\n\n        # 3. Pipeline 1: Metric-based Reconstruction\n        h_metric = h_true.copy()\n        if params[\"drift\"]:\n            d0 = params[\"drift\"][\"d0\"]\n            d1 = params[\"drift\"][\"d1\"]\n            h_metric += d0 + d1 * t\n\n        # 4. Pipeline 2: Curvature-based Reconstruction\n        # 4a. Construct Psi4 from h_true\n        freq = np.fft.fftfreq(N, dt)\n        omega = 2 * np.pi * freq\n        \n        h_true_tilde = np.fft.fft(h_true)\n        psi4_tilde = -(omega**2) * h_true_tilde\n        psi4 = np.fft.ifft(psi4_tilde)\n\n        # 4b. Reconstruct h_curv from Psi4\n        psi4_tilde_recomp = np.fft.fft(psi4) # Recompute for clarity\n        omega_cut = 2 * np.pi * f_cut\n\n        # Create integration kernel with regularization\n        integration_kernel = np.zeros_like(omega, dtype=np.complex128)\n        valid_indices = np.abs(omega) >= omega_cut\n        # Use np.divide to handle division by zero safely\n        integration_kernel[valid_indices] = np.divide(\n            -1.0, \n            omega[valid_indices]**2, \n            where=(omega[valid_indices] != 0)\n        )\n\n        h_curv_tilde = psi4_tilde_recomp * integration_kernel\n        h_curv = np.fft.ifft(h_curv_tilde)\n\n        # 5. Reconciliation and Alignment\n        delta_h = h_metric - h_curv\n        \n        # Design matrix for linear fit (constant and linear term)\n        X = np.vstack([np.ones(N), t]).T\n\n        # Solve for real and imaginary parts of coefficients c0, c1\n        c_real, _, _, _ = np.linalg.lstsq(X, np.real(delta_h), rcond=None)\n        c_imag, _, _, _ = np.linalg.lstsq(X, np.imag(delta_h), rcond=None)\n\n        c0 = c_real[0] + 1j * c_imag[0]\n        c1 = c_real[1] + 1j * c_imag[1]\n        \n        h_aligned = h_curv + c0 + c1 * t\n        \n        # 6. Quantify Agreement\n        delta_inf = np.max(np.abs(h_aligned - h_metric))\n        results.append(f\"{delta_inf:.10e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "数值相对论模拟不可避免地在有限的计算区域内进行，这便引入了人工的外部边界。一个关键的挑战是设计出能够让引力波无反射地穿过的“吸收”边界条件。不完美的边界条件会导致一部分出射波被反射回计算区域，从而污染物理信号。本实践通过一个简化的模型，探讨了不同类型的边界条件（如 Sommerfeld 条件和理想的约束保持边界条件）如何导致虚假的偏振反射。您将通过计算一个出射的纯 $h_{+}$ 偏振波在边界处反射回来的 $h_{+}$ 和 $h_{\\times}$ 分量，来量化这种由数值方法引入的偏振混合效应。这个练习有助于深入理解数值模拟中系统误差的一个重要来源。",
            "id": "3483032",
            "problem": "您将实现并分析一个简化但有科学依据的模型，该模型描述了数值相对论中的外部边界条件如何影响引力波的偏振内容。在横向无迹 (TT) 规范下的线性化真空引力框架中进行研究，其中两个独立的偏振振幅 $h_+(z,t)$ 和 $h_\\times(z,t)$ 遵循解耦的一维波动方程。在光速 $c=1$ 的几何单位制中，每个偏振的控制方程为\n$$\n\\partial_t^2 h(z,t) = c^2 \\,\\partial_z^2 h(z,t),\n$$\n单色平面波的色散关系由 $\\omega = c\\,k$ 给出，其中 $\\omega$ 是角频率，$k$ 是波数。考虑一个有限计算域，其外部边界位于位置 $z=L$。\n\n边界条件通过一个线性一阶 (Sommerfeld-型) 算子施加于双分量场矢量 $\\mathbf{h}(z,t) = \\begin{bmatrix}h_+(z,t) \\\\ h_\\times(z,t)\\end{bmatrix}$ 上\n$$\n\\mathcal{B}[\\mathbf{h}](L,t) \\equiv \\partial_t \\mathbf{h}(L,t) + C_b\\,\\partial_z \\mathbf{h}(L,t) = \\mathbf{0},\n$$\n其中 $C_b$ 是一个表征所选边界条件的恒定 $2\\times 2$ 矩阵。将比较以下两类边界条件：\n\n- Sommerfeld 边界条件：为偏振选择一个旋转角为 $\\theta$（以弧度为单位）的旋转基，由矩阵\n$$\nR(\\theta) = \\begin{bmatrix}\n\\cos\\theta & -\\sin\\theta \\\\\n\\sin\\theta & \\cos\\theta\n\\end{bmatrix},\n$$\n定义，并在此旋转基中指定不同的特征边界速度 $c_{b1}$ 和 $c_{b2}$。在物理 $+/\\times$ 基中，这得到\n$$\nC_b = R(\\theta)^\\top \\begin{bmatrix} c_{b1} & 0 \\\\ 0 & c_{b2} \\end{bmatrix} R(\\theta).\n$$\n这模拟了一个真实情况：一个朴素的 Sommerfeld 条件被应用于具有不同有效传播速度的场的混合体，可能同时导致反射和偏振混合。\n\n- 约束保持边界条件 (CPBC)：在这个简化的 TT 模型中，理想的 CPBC 对应于将所有出射引力波特征场与正确的物理速度相匹配，并精确保持约束，这在这里简化为选择\n$$\nC_b = c\\,I,\n$$\n其中 $I$ 是 $2\\times 2$ 单位矩阵。这对平面波解不产生反射，并在边界处保持其 TT 特性。\n\n假设一个振幅矢量为 $\\mathbf{A}_{\\text{out}}$ 的单色出射平面波向边界行进：\n$$\n\\mathbf{h}_{\\text{out}}(z,t) = \\mathbf{A}_{\\text{out}}\\,e^{i(k z - \\omega t)}.\n$$\n向计算域内返回的反射波的振幅矢量为 $\\mathbf{A}_{\\text{in}}$：\n$$\n\\mathbf{h}_{\\text{in}}(z,t) = \\mathbf{A}_{\\text{in}}\\,e^{i(-k z - \\omega t)}.\n$$\n施加 $\\mathcal{B}[\\mathbf{h}_{\\text{out}} + \\mathbf{h}_{\\text{in}}](L,t) = \\mathbf{0}$ 会得到一个关于 $\\mathbf{A}_{\\text{in}}$（用 $\\mathbf{A}_{\\text{out}}$ 表示）的线性系统，该系统可以从第一性原理推导得出。定义反射矩阵\n$$\n\\mathsf{R} \\equiv \\left(-\\omega I - k\\,C_b\\right)^{-1}\\left(\\omega I - k\\,C_b\\right),\n$$\n和边界相位因子 $\\xi \\equiv e^{2 i k L}$。则入射振幅为\n$$\n\\mathbf{A}_{\\text{in}} = \\xi\\,\\mathsf{R}\\,\\mathbf{A}_{\\text{out}}.\n$$\n我们关注的量是反射回计算域的伪偏振。对于一个纯 $+$-偏振的出射波，$\\mathbf{A}_{\\text{out}} = \\begin{bmatrix}A_+ \\\\ 0\\end{bmatrix}$ 且 $A_+ \\neq 0$，定义无量纲反射比\n$$\nr_+ \\equiv \\frac{\\left|(\\mathbf{A}_{\\text{in}})_+\\right|}{|A_+|}, \\qquad r_\\times \\equiv \\frac{\\left|(\\mathbf{A}_{\\text{in}})_\\times\\right|}{|A_+|},\n$$\n它们分别衡量反射的 $+$ 分量的幅值和伪反射的 $\\times$ 分量的幅值，两者都由出射的 $+$ 振幅归一化。由于 $|\\xi|=1$，这些比率仅取决于 $\\mathsf{R}$ 和 $\\mathbf{A}_{\\text{out}}$。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 忠实地实现上述模型。\n- 为下面的每个测试用例计算 $r_+$ 和 $r_\\times$。\n- 以指定格式返回结果。\n\n使用几何单位制，其中 $c$ 和所有速度都是无量纲的；波数 $k$ 的单位是与 $c=1$ 一致的逆长度单位；角度 $\\theta$ 以弧度为单位。所有输出必须是无量纲的。将每个比率表示为十进制数，四舍五入到十位小数。\n\n测试套件：\n- 案例 1 (Sommerfeld，轻度失配和混合)：\n  - $c=1$, $c_{b1}=0.9$, $c_{b2}=1.1$, $\\theta=\\pi/6$, $k=2\\pi$, $L=1$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$。\n- 案例 2 (CPBC，完美匹配)：\n  - $c=1$, $C_b=c\\,I$, $\\theta$ 任意 (未使用), $k=2\\pi$, $L=1$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$。\n- 案例 3 (Sommerfeld，速度正确但基旋转)：\n  - $c=1$, $c_{b1}=1$, $c_{b2}=1$, $\\theta=\\pi/4$, $k=2\\pi$, $L=1$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$。\n- 案例 4 (Sommerfeld，强失配和混合)：\n  - $c=1$, $c_{b1}=0.5$, $c_{b2}=1.5$, $\\theta=\\pi/3$, $k=\\pi$, $L=0.5$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$。\n- 案例 5 (Sommerfeld，在物理基中无混合)：\n  - $c=1$, $c_{b1}=0.8$, $c_{b2}=1.2$, $\\theta=0$, $k=\\pi$, $L=1.25$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$。\n\n您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例必须贡献一个包含两个十进制数 $[r_+,r_\\times]$（四舍五入到十位小数）的列表，因此最终输出必须具有以下形式\n$$\n\\left[\\,[r_+,r_\\times],\\,[r_+,r_\\times],\\,[r_+,r_\\times],\\,[r_+,r_\\times],\\,[r_+,r_\\times]\\,\\right],\n$$\n并且不打印任何额外文本。",
            "solution": "问题陈述被验证为具有科学依据、数学上一致且适定的。它提出了一个来自数值相对论的简化但有物理意义的模型，该模型涉及边界条件对引力波偏振的影响。唯一解所需的所有必要组成部分都已清晰定义和提供。\n\n问题的核心是确定单色平面波在数值边界上的反射。总波场 $\\mathbf{h}(z,t)$ 是出射波 $\\mathbf{h}_{\\text{out}}(z,t)$ 和反射（入射）波 $\\mathbf{h}_{\\text{in}}(z,t)$ 的线性叠加：\n$$\n\\mathbf{h}(z,t) = \\mathbf{h}_{\\text{out}}(z,t) + \\mathbf{h}_{\\text{in}}(z,t) = \\mathbf{A}_{\\text{out}}\\,e^{i(k z - \\omega t)} + \\mathbf{A}_{\\text{in}}\\,e^{i(-k z - \\omega t)}\n$$\n其中 $\\mathbf{A}_{\\text{out}}$ 和 $\\mathbf{A}_{\\text{in}}$ 分别是出射波和入射波的恒定振幅矢量。边界条件由作用在边界 $z=L$ 处总场上的一阶算子 $\\mathcal{B}$ 指定：\n$$\n\\mathcal{B}[\\mathbf{h}](L,t) \\equiv \\partial_t \\mathbf{h}(L,t) + C_b\\,\\partial_z \\mathbf{h}(L,t) = \\mathbf{0}\n$$\n为了应用此条件，我们首先计算 $\\mathbf{h}(z,t)$ 的偏导数：\n$$\n\\partial_t \\mathbf{h}(z,t) = -i\\omega \\left( \\mathbf{A}_{\\text{out}}\\,e^{i(k z - \\omega t)} + \\mathbf{A}_{\\text{in}}\\,e^{i(-k z - \\omega t)} \\right)\n$$\n$$\n\\partial_z \\mathbf{h}(z,t) = ik \\left( \\mathbf{A}_{\\text{out}}\\,e^{i(k z - \\omega t)} - \\mathbf{A}_{\\text{in}}\\,e^{i(-k z - \\omega t)} \\right)\n$$\n在 $z=L$ 处计算这些表达式，并将它们代入边界条件算子，得到：\n$$\n-i\\omega \\left( \\mathbf{A}_{\\text{out}}e^{ikL} + \\mathbf{A}_{\\text{in}}e^{-ikL} \\right)e^{-i\\omega t} + C_b \\left( ik \\left( \\mathbf{A}_{\\text{out}}e^{ikL} - \\mathbf{A}_{\\text{in}}e^{-ikL} \\right) \\right)e^{-i\\omega t} = \\mathbf{0}\n$$\n我们可以消去公共的非零因子 $i e^{-i\\omega t}$，得到：\n$$\n-\\omega \\left( \\mathbf{A}_{\\text{out}}e^{ikL} + \\mathbf{A}_{\\text{in}}e^{-ikL} \\right) + k C_b \\left( \\mathbf{A}_{\\text{out}}e^{ikL} - \\mathbf{A}_{\\text{in}}e^{-ikL} \\right) = \\mathbf{0}\n$$\n这个方程是关于 $\\mathbf{A}_{\\text{in}}$（用 $\\mathbf{A}_{\\text{out}}$ 表示）的线性系统。为了求解它，我们将乘以 $\\mathbf{A}_{\\text{in}}$ 和 $\\mathbf{A}_{\\text{out}}$ 的项组合在一起：\n$$\n(-\\omega I - kC_b) \\mathbf{A}_{\\text{in}}e^{-ikL} = (-\\omega I + kC_b) \\mathbf{A}_{\\text{out}}e^{ikL}\n$$\n其中 $I$ 是 $2 \\times 2$ 单位矩阵。求解 $\\mathbf{A}_{\\text{in}}$，我们发现：\n$$\n\\mathbf{A}_{\\text{in}} = (-\\omega I - kC_b)^{-1} (-\\omega I + kC_b) e^{2ikL} \\mathbf{A}_{\\text{out}}\n$$\n此关系与问题中给出的形式 $\\mathbf{A}_{\\text{in}} = \\xi\\,\\mathsf{R}\\,\\mathbf{A}_{\\text{out}}$ 相匹配，其中相位因子 $\\xi \\equiv e^{2ikL}$，反射矩阵 $\\mathsf{R}$ 定义为 $\\mathsf{R} \\equiv (-\\omega I - kC_b)^{-1} (-\\omega I + kC_b)$。此矩阵可以等价地写为 $\\mathsf{R} = (\\omega I + kC_b)^{-1} (\\omega I - kC_b)$。\n\n在 $c=1$ 的几何单位制下，色散关系简化为 $\\omega=k$。将此代入 $\\mathsf{R}$ 的表达式中可以得到显著简化：\n$$\n\\mathsf{R} = (kI + kC_b)^{-1}(kI - kC_b) = [k(I+C_b)]^{-1}[k(I-C_b)] = (I+C_b)^{-1}(I-C_b)\n$$\n问题要求计算反射比 $r_+$ 和 $r_\\times$，它们是反射波各分量的幅值，并由初始出射波的振幅进行归一化。对于一个纯 $+$-偏振的出射波，我们有 $\\mathbf{A}_{\\text{out}} = \\begin{bmatrix}A_+ \\\\ 0\\end{bmatrix}$。这些比率为：\n$$\nr_+ \\equiv \\frac{\\left|(\\mathbf{A}_{\\text{in}})_+\\right|}{|A_+|}, \\qquad r_\\times \\equiv \\frac{\\left|(\\mathbf{A}_{\\text{in}})_\\times\\right|}{|A_+|}\n$$\n由于相位因子 $\\xi$ 的模为单位长度（$|\\xi|=|e^{2ikL}|=1$），它不影响反射分量的幅值。因此，我们可以从矢量 $\\mathbf{A}'_{\\text{in}} = \\mathsf{R} \\mathbf{A}_{\\text{out}}$ 计算这些比率。不失一般性地，我们可以设置 $A_+=1$，因此 $\\mathbf{A}_{\\text{out}} = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$。那么矢量 $\\mathbf{A}'_{\\text{in}}$ 就是矩阵 $\\mathsf{R}$ 的第一列。如果 $\\mathsf{R}$ 的分量为 $\\mathsf{R}_{ij}$，则 $\\mathbf{A}'_{\\text{in}} = \\begin{bmatrix}\\mathsf{R}_{11}\\\\\\mathsf{R}_{21}\\end{bmatrix}$，并且比率变为 $r_+ = |\\mathsf{R}_{11}|$ 和 $r_\\times = |\\mathsf{R}_{21}|$。\n\n对于每个测试用例，计算算法按如下方式进行：\n1.  构建矩阵 $C_b$。对于 Sommerfeld 条件， $C_b = R(\\theta)^\\top \\operatorname{diag}(c_{b1}, c_{b2}) R(\\theta)$，其中 $R(\\theta) = \\begin{bmatrix}\\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta\\end{bmatrix}$。对于 CPBC， $C_b=cI=I$。\n2.  计算反射矩阵 $\\mathsf{R} = (I+C_b)^{-1}(I-C_b)$。这涉及标准的矩阵代数：加法、求逆和乘法。\n3.  提取 $\\mathsf{R}$ 的第一列，它对应于 $\\mathbf{A}'_{\\text{in}}$。\n4.  计算此列向量各分量的绝对值，以求得 $r_+$ 和 $r_\\times$。\n\n此过程应用于每个测试用例。\n- 对于案例 2 (CPBC) 和案例 3 (Sommerfeld，其中 $c_{b1}=c_{b2}=1$)，$C_b$ 成为单位矩阵 $I$。这导致 $I-C_b=\\mathbf{0}$，使得 $\\mathsf{R}$ 为零矩阵。因此，$r_+$ 和 $r_\\times$ 均为 $0$，表示完美吸收。\n- 对于案例 5 (Sommerfeld，其中 $\\theta=0$)，$R(0)=I$，所以 $C_b$ 是对角矩阵。这使得 $\\mathsf{R}$ 也是对角矩阵，因此 $r_\\times=0$，因为偏振分量之间没有混合。\n- 对于案例 1 和 4，$C_b$ 是一个非对角矩阵，导致反射 ($r_+ > 0$) 和伪偏振混合 ($r_\\times > 0$)。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes spurious polarization reflection ratios for gravitational waves\n    at a numerical boundary.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # Case 1 (Sommerfeld, mild mismatch and mixing)\n        {\n            \"type\": \"sommerfeld\",\n            \"c\": 1, \"k\": 2 * np.pi, \"L\": 1.0,\n            \"bc_params\": {\"cb1\": 0.9, \"cb2\": 1.1, \"theta\": np.pi / 6},\n            \"A_out\": np.array([1.0, 0.0])\n        },\n        # Case 2 (CPBC, perfect match)\n        {\n            \"type\": \"cpbc\",\n            \"c\": 1, \"k\": 2 * np.pi, \"L\": 1.0,\n            \"bc_params\": {\"c\": 1.0},\n            \"A_out\": np.array([1.0, 0.0])\n        },\n        # Case 3 (Sommerfeld, correct speeds but rotated basis)\n        {\n            \"type\": \"sommerfeld\",\n            \"c\": 1, \"k\": 2 * np.pi, \"L\": 1.0,\n            \"bc_params\": {\"cb1\": 1.0, \"cb2\": 1.0, \"theta\": np.pi / 4},\n            \"A_out\": np.array([1.0, 0.0])\n        },\n        # Case 4 (Sommerfeld, strong mismatch and mixing)\n        {\n            \"type\": \"sommerfeld\",\n            \"c\": 1, \"k\": np.pi, \"L\": 0.5,\n            \"bc_params\": {\"cb1\": 0.5, \"cb2\": 1.5, \"theta\": np.pi / 3},\n            \"A_out\": np.array([1.0, 0.0])\n        },\n        # Case 5 (Sommerfeld, no mixing in the physical basis)\n        {\n            \"type\": \"sommerfeld\",\n            \"c\": 1, \"k\": np.pi, \"L\": 1.25,\n            \"bc_params\": {\"cb1\": 0.8, \"cb2\": 1.2, \"theta\": 0.0},\n            \"A_out\": np.array([1.0, 0.0])\n        }\n    ]\n\n    all_results = []\n\n    for i, case in enumerate(test_cases):\n        # Identity matrix\n        I = np.identity(2)\n        \n        # Construct the boundary condition matrix C_b\n        if case[\"type\"] == \"sommerfeld\":\n            p = case[\"bc_params\"]\n            cb1, cb2, theta = p[\"cb1\"], p[\"cb2\"], p[\"theta\"]\n            \n            # Rotation matrix\n            cos_t, sin_t = np.cos(theta), np.sin(theta)\n            R_theta = np.array([[cos_t, -sin_t], [sin_t, cos_t]])\n            \n            # Diagonal matrix of boundary speeds\n            D = np.array([[cb1, 0], [0, cb2]])\n            \n            # C_b = R^T D R\n            C_b = R_theta.T @ D @ R_theta\n            \n        elif case[\"type\"] == \"cpbc\":\n            # C_b = c * I\n            C_b = case[\"bc_params\"][\"c\"] * I\n\n        # Simplified reflection matrix for c=1 (omega=k)\n        # R_mat = (I + C_b)^-1 * (I - C_b)\n        M_inv = np.linalg.inv(I + C_b)\n        R_mat = M_inv @ (I - C_b)\n        \n        # Reflected amplitude (without phase factor, as it doesn't affect magnitude)\n        A_out = case[\"A_out\"]\n        A_in_prime = R_mat @ A_out\n        \n        # Magnitude of the outgoing + polarization amplitude\n        A_plus_mag = np.abs(A_out[0])\n\n        # Calculate reflection ratios\n        # Note: A_plus_mag is 1 for all test cases, but we include it for generality.\n        # This handles cases where A_out could be complex or not normalized.\n        r_plus = np.abs(A_in_prime[0]) / A_plus_mag if A_plus_mag != 0 else 0\n        r_cross = np.abs(A_in_prime[1]) / A_plus_mag if A_plus_mag != 0 else 0\n        \n        all_results.append((r_plus, r_cross))\n\n    # Format the final output string exactly as specified.\n    output_parts = [f\"[{r_p:.10f},{r_x:.10f}]\" for r_p, r_x in all_results]\n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}