{
    "hands_on_practices": [
        {
            "introduction": "在信任任何数值模拟的结果之前，我们必须首先验证我们的代码是否正确地求解了方程。人造解方法（Method of Manufactured Solutions）是实现这一目标的黄金标准，它允许我们将代码的收敛速度与理论预期进行精确比较。这个练习将为您提供使用这种基本验证技术的动手经验，这是数值相对论中代码开发和验证的一个关键环节 。",
            "id": "3469183",
            "problem": "您需要实现并验证离散约束残差的标度（scaling）行为，该模型仿照数值相对论中使用的哈密顿约束和动量约束，在均匀网格加密和可选的约束阻尼条件下进行。在一个三维周期性域中使用人造解测试，以确保连续谱约束恒为零，从而使离散残差能直接度量截断误差。您的任务是计算观测到的精度阶数，并验证预期的 $\\mathcal{O}(\\Delta x^{p})$ 行为，其中 $\\Delta x$ 是网格间距，而 $p$ 是有限差分格式的形式阶数。\n\n基本原理：\n- 对于一个相容的、中心化的、p阶有限差分近似，其光滑导数的离散截断误差的标度行为为 $\\mathcal{O}(\\Delta x^{p})$。\n- 在体积为 $V$ 的域 $\\Omega$ 上，函数 $f$ 的 $L^{2}$ 范数定义为 $\\lVert f \\rVert_{2} = \\left( \\int_{\\Omega} f^{2} \\, dV \\right)^{1/2}$。在三维空间中，对于间距为 $\\Delta x$、总体积为 $V = 1$ 的均匀网格，离散 $L^{2}$ 范数计算为 $\\left( \\sum f^{2} \\Delta x^{3} \\right)^{1/2}$，这等于 $\\left( \\mathrm{mean}(f^{2}) \\right)^{1/2}$。\n- 如果一个约束场 $C$ 满足齐次阻尼定律 $\\partial_{t} C = - \\kappa C$，其在固定的物理时间 $T$ 后的精确解是 $C \\mapsto e^{-\\kappa T} C$，这不会改变其在 $\\Delta x$ 中的渐进阶。\n\n设置：\n- 域：周期性立方体 $[0,1]^{3}$，具有均匀笛卡尔网格间距 $\\Delta x = 1/N$，其中 $N$ 为给定的整数且 $N \\ge 8$。\n- 三角函数中的角度必须以弧度为单位。\n- 人造光滑解析场：\n  1. 标量场 $\\phi(x,y,z) = \\sin(2\\pi x)\\cos(2\\pi y) + \\sin(2\\pi z)$。\n  2. 标量场 $\\pi(x,y,z) = \\exp\\!\\big(\\sin(2\\pi x) + \\cos(2\\pi y) + \\sin(2\\pi z)\\big)$。\n- 定义精确的源场，以使连续谱约束为零：\n  1. $\\phi$ 的精确拉普拉斯算子是 $\\nabla^{2}\\phi = -2(2\\pi)^{2} \\sin(2\\pi x)\\cos(2\\pi y) - (2\\pi)^{2} \\sin(2\\pi z)$。定义 $S(x,y,z)$ 等于此精确拉普拉斯算子，从而使连续谱哈密顿约束 $H \\equiv \\nabla^{2}\\phi - S$ 恒为零。\n  2. $\\pi$ 的精确梯度是 $\\nabla \\pi = \\big(\\partial_{x}\\pi,\\partial_{y}\\pi,\\partial_{z}\\pi\\big)$，其中 $\\partial_{x}\\pi = (2\\pi)\\cos(2\\pi x)\\,\\pi$，$\\partial_{y}\\pi = -(2\\pi)\\sin(2\\pi y)\\,\\pi$，以及 $\\partial_{z}\\pi = (2\\pi)\\cos(2\\pi z)\\,\\pi$。定义精确的矢量源 $J_{i}$ 等于这些分量，从而使连续谱动量约束 $M_{i} \\equiv \\partial_{i}\\pi - J_{i}$ 恒为零。\n- 离散算子：\n  - 令 $D^{(p)}_{i}$ 表示在周期性均匀网格上对一阶导数 $\\partial_{i}$ 的标准中心化、p阶精确的有限差分近似。\n  - 令 $\\Delta^{(p)}$ 表示在周期性均匀网格上对拉普拉斯算子 $\\nabla^{2}$ 的标准中心化、p阶精确的有限差分近似，其构造方式为沿每个轴的二阶导数之和，每个二阶导数都近似到p阶。\n  - 您必须在周期性网格上实现p阶 $\\in \\{2,4\\}$ 的一阶和二阶导数的常用中心格式。不要使用单边格式。\n- 离散残差和范数：\n  - 离散哈密顿残差为 $H_{h} = \\Delta^{(p)} \\phi - S$。\n  - 离散动量残差为 $M_{i,h} = D^{(p)}_{i}\\pi - J_{i}$，其中 $i \\in \\{x,y,z\\}$。\n  - 为 $H_{h}$ 定义标量 $L^{2}$ 范数为 $\\lVert H_{h}\\rVert_{2} = \\left( \\mathrm{mean}(H_{h}^{2}) \\right)^{1/2}$。\n  - 为 $M_{i,h}$ 定义矢量 $L^{2}$ 范数为 $\\lVert \\mathbf{M}_{h}\\rVert_{2} = \\left( \\mathrm{mean}\\big(M_{x,h}^{2} + M_{y,h}^{2} + M_{z,h}^{2}\\big) \\right)^{1/2}$。\n- 可选阻尼：\n  - 在计算 $H_{h}$ 和 $M_{i,h}$ 后，可选择性地应用齐次约束阻尼，固定物理时间 $T = 1$，参数为 $\\kappa \\ge 0$，通过精确的乘法更新 $H_{h} \\mapsto e^{-\\kappa} H_{h}$ 和 $M_{i,h} \\mapsto e^{-\\kappa} M_{i,h}$ 来实现。\n\n标度行为测量：\n- 对于固定的阶数 $p$ 和阻尼参数 $\\kappa$，计算给定列表中的每个网格分辨率 $N$ 的 $\\lVert H_{h}\\rVert_{2}$ 和 $\\lVert \\mathbf{M}_{h}\\rVert_{2}$。令 $\\Delta x = 1/N$。\n- 通过对 $\\log \\lVert H_{h}\\rVert_{2}$ 与 $\\log \\Delta x$ 以及类似的 $\\log \\lVert \\mathbf{M}_{h}\\rVert_{2}$ 进行线性回归，拟合观测到的阶数 $p_{\\mathrm{obs}}$，使得 $\\lVert \\cdot \\rVert_{2} \\approx C \\, (\\Delta x)^{p_{\\mathrm{obs}}}$。\n- 验证标准：如果两个观测到的阶数 $p_{\\mathrm{obs}}(H)$ 和 $p_{\\mathrm{obs}}(M)$ 都满足 $\\lvert p_{\\mathrm{obs}} - p \\rvert \\le \\varepsilon$（其中 $\\varepsilon$ 为容差），则声明成功。\n\n待实现的测试套件：\n- 使用以下四组参数集来计算和验证观测到的阶数。对于每组参数，角度均以弧度为单位，并且如上所述，阻尼更新使用 $T = 1$。\n  1. 情况 1：$p = 2$，$\\kappa = 0$，$N \\in \\{16, 24, 32, 48\\}$。\n  2. 情况 2：$p = 4$，$\\kappa = 0$，$N \\in \\{16, 24, 32, 48\\}$。\n  3. 情况 3：$p = 2$，$\\kappa = 20$，$N \\in \\{16, 24, 32, 48\\}$。\n  4. 情况 4：$p = 4$，$\\kappa = 10$，$N \\in \\{16, 24, 32, 48\\}$。\n- 对所有情况使用容差 $\\varepsilon = 0.2$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、按四种情况顺序排列的逗号分隔列表。每个条目都是一个布尔值，当且仅当该情况下的两个约束都满足验证标准时为 $True$，否则为 $False$。例如，一个有效的输出行形式为 $[b_{1},b_{2},b_{3},b_{4}]$，其中每个 $b_{i}$ 为 $True$ 或 $False$。",
            "solution": "该问题陈述是有效的。它描述了一个适定的数值验证任务，使用了人造解方法，这是偏微分方程和数值分析研究中的一种标准且科学合理的方法。所有参数、方程和步骤都定义精确且相互一致。\n\n解决此问题的方案基于数值分析的几个关键原则：\n\n1.  **人造解方法（Method of Manufactured Solutions）**：为了测试微分方程数值格式的收敛性，我们选择一个光滑的解析函数作为“人造”解。我们将此解代入微分算子中，以计算相应的解析源项。这样就创建了一个已知精确解的问题。因此，通过构造，连续谱约束 $H \\equiv \\nabla^{2}\\phi - S$ 和 $M_{i} \\equiv \\partial_{i}\\pi - J_{i}$ 恒等于零。\n\n2.  **作为残差的截断误差（Truncation Error as the Residual）**：当离散有限差分算子应用于网格上的解析解时，其结果不会与解析源项完全相等。这种差异，被称为离散残差（例如，$H_{h} = \\Delta^{(p)} \\phi - S$），正是有限差分格式的截断误差。对于一个 p 阶方法，该误差预期会以 $\\mathcal{O}(\\Delta x^p)$ 的方式收敛，其中 $\\Delta x$ 是网格间距。\n\n3.  **收敛性分析（Convergence Analysis）**：通过为一系列递减的网格间距 $\\Delta x$ 计算离散残差，我们可以测量观测到的收敛阶数 $p_{\\mathrm{obs}}$。确定 $p_{\\mathrm{obs}}$ 的一种稳健方法是对数数据进行线性回归。关系式 $\\lVert \\text{Error} \\rVert \\approx C(\\Delta x)^p$ 在对数-对数图上变为线性的：$\\log(\\lVert \\text{Error} \\rVert) \\approx p \\log(\\Delta x) + \\log(C)$。这条线的斜率就是收敛阶数 $p$。\n\n4.  **周期性网格上的有限差分算子（Finite-Difference Operators on Periodic Grids）**：微分算子 $\\partial_i$ 和 $\\nabla^2$ 使用中心有限差分格式进行近似。对于周期性域，格式所需的、位于网格外部的点会从另一侧“环绕”回来。这通过数组的滚动操作可以高效实现。格式的具体系数经过选择，以抵消泰勒级数展开中的低阶误差项，从而达到所需的精度阶数 $p$。\n\n解决该问题的算法步骤如下：\n\n对于由阶数 $p$、阻尼参数 $\\kappa$ 和分辨率列表 $N$ 定义的四个测试用例中的每一个：\n\n1.  初始化两个列表，用于存储每个分辨率下计算出的哈密顿残差 $\\lVert H_h \\rVert_2$ 和动量残差 $\\lVert \\mathbf{M}_h \\rVert_2$ 的 $L^2$ 范数。同时，准备一个包含相应网格间距 $\\Delta x = 1/N$ 的列表。\n\n2.  对于指定列表中的每个分辨率 $N$：\n    a. 为域 $[0,1]^3$ 构建一个均匀的三维笛卡尔网格。网格坐标为 $(x_i, y_j, z_k)$，其中 $x_i = i/N, y_j=j/N, z_k=k/N$，且 $i,j,k \\in \\{0, \\dots, N-1\\}$。\n    b. 在该网格的每个点上计算解析场 $\\phi$ 和 $\\pi$，以及相应的源场 $S$ 和 $J_i$，并将它们存储在三维数组中。\n    c. 为指定的阶数 $p \\in \\{2,4\\}$ 实现一阶导数 ($D_i^{(p)}$) 和拉普拉斯算子 ($\\Delta^{(p)} = D_{xx}^{(p)} + D_{yy}^{(p)} + D_{zz}^{(p)}$) 的中心有限差分算子。网格的周期性通过使用数据数组的循环移位（rolls）来处理。\n    \n    格式如下：\n    - $p=2$:\n      - 一阶导数 $D_i^{(2)} f$: $\\frac{f_{i+1} - f_{i-1}}{2\\Delta x}$\n      - 二阶导数 $D_{ii}^{(2)} f$: $\\frac{f_{i+1} - 2f_i + f_{i-1}}{(\\Delta x)^2}$\n    - $p=4$:\n      - 一阶导数 $D_i^{(4)} f$: $\\frac{1}{12\\Delta x}(f_{i-2} - 8f_{i-1} + 8f_{i+1} - f_{i+2})$\n      - 二阶导数 $D_{ii}^{(4)} f$: $\\frac{1}{12(\\Delta x)^2}(-f_{i-2} + 16f_{i-1} - 30f_i + 16f_{i+1} - f_{i+2})$\n    \n    d. 计算离散残差。哈密顿残差为 $H_h = \\Delta^{(p)}\\phi - S$。动量残差为 $M_{i,h} = D_i^{(p)}\\pi - J_i$，其中 $i \\in \\{x,y,z\\}$。\n    e. 根据问题的定义计算残差的 $L^2$ 范数：$\\lVert H_{h}\\rVert_{2} = \\left( \\mathrm{mean}(H_{h}^{2}) \\right)^{1/2}$ 和 $\\lVert \\mathbf{M}_{h}\\rVert_{2} = \\left( \\mathrm{mean}(M_{x,h}^{2} + M_{y,h}^{2} + M_{z,h}^{2}) \\right)^{1/2}$。\n    f. 如果 $\\kappa > 0$，则将计算出的范数乘以阻尼因子 $e^{-\\kappa T}$（其中 $T=1$）来应用阻尼。请注意，这个常数乘法因子不会改变对数-对数误差图的斜率，因此不会影响观测到的收敛阶数。\n    g. 将最终的范数和网格间距 $\\Delta x$ 追加到各自的列表中。\n\n3.  遍历所有分辨率后，对范数的对数与网格间距的对数进行线性回归。哈密顿残差所得直线的斜率即为 $p_{\\mathrm{obs}}(H)$，动量残差同理可得 $p_{\\mathrm{obs}}(M)$。\n\n4.  最后，验证测试用例是否成功。成功的条件是两个观测阶数都接近理论阶数 $p$，即 $| p_{\\mathrm{obs}}(H) - p | \\le \\varepsilon$ 和 $| p_{\\mathrm{obs}}(M) - p | \\le \\varepsilon$，其中给定的容差为 $\\varepsilon = 0.2$。该用例的结果是一个布尔值（成功为 True，失败为 False）。\n\n对所有四个测试用例重复整个过程，最终输出是包含这四个布尔结果的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Implements and verifies the scaling of discrete constraint residuals\n    for a manufactured solution test in numerical relativity.\n    \"\"\"\n\n    # --- Finite Difference Operators ---\n\n    def diff_x_p2(f, dx):\n        \"\"\"Order-2 centered 1st derivative along axis 0.\"\"\"\n        return (np.roll(f, -1, axis=0) - np.roll(f, 1, axis=0)) / (2.0 * dx)\n\n    def diff_y_p2(f, dx):\n        \"\"\"Order-2 centered 1st derivative along axis 1.\"\"\"\n        return (np.roll(f, -1, axis=1) - np.roll(f, 1, axis=1)) / (2.0 * dx)\n\n    def diff_z_p2(f, dx):\n        \"\"\"Order-2 centered 1st derivative along axis 2.\"\"\"\n        return (np.roll(f, -1, axis=2) - np.roll(f, 1, axis=2)) / (2.0 * dx)\n\n    def diff_xx_p2(f, dx):\n        \"\"\"Order-2 centered 2nd derivative along axis 0.\"\"\"\n        return (np.roll(f, -1, axis=0) - 2.0 * f + np.roll(f, 1, axis=0)) / (dx**2)\n\n    def diff_yy_p2(f, dx):\n        \"\"\"Order-2 centered 2nd derivative along axis 1.\"\"\"\n        return (np.roll(f, -1, axis=1) - 2.0 * f + np.roll(f, 1, axis=1)) / (dx**2)\n\n    def diff_zz_p2(f, dx):\n        \"\"\"Order-2 centered 2nd derivative along axis 2.\"\"\"\n        return (np.roll(f, -1, axis=2) - 2.0 * f + np.roll(f, 1, axis=2)) / (dx**2)\n\n    def diff_x_p4(f, dx):\n        \"\"\"Order-4 centered 1st derivative along axis 0.\"\"\"\n        c = [1.0/12.0, -8.0/12.0, 8.0/12.0, -1.0/12.0]\n        return (c[0] * np.roll(f, 2, axis=0) + c[1] * np.roll(f, 1, axis=0) + \n                c[2] * np.roll(f, -1, axis=0) + c[3] * np.roll(f, -2, axis=0)) / dx\n\n    def diff_y_p4(f, dx):\n        \"\"\"Order-4 centered 1st derivative along axis 1.\"\"\"\n        c = [1.0/12.0, -8.0/12.0, 8.0/12.0, -1.0/12.0]\n        return (c[0] * np.roll(f, 2, axis=1) + c[1] * np.roll(f, 1, axis=1) + \n                c[2] * np.roll(f, -1, axis=1) + c[3] * np.roll(f, -2, axis=1)) / dx\n\n    def diff_z_p4(f, dx):\n        \"\"\"Order-4 centered 1st derivative along axis 2.\"\"\"\n        c = [1.0/12.0, -8.0/12.0, 8.0/12.0, -1.0/12.0]\n        return (c[0] * np.roll(f, 2, axis=2) + c[1] * np.roll(f, 1, axis=2) + \n                c[2] * np.roll(f, -1, axis=2) + c[3] * np.roll(f, -2, axis=2)) / dx\n\n    def diff_xx_p4(f, dx):\n        \"\"\"Order-4 centered 2nd derivative along axis 0.\"\"\"\n        c = [-1.0/12.0, 16.0/12.0, -30.0/12.0, 16.0/12.0, -1.0/12.0]\n        return (c[0] * np.roll(f, 2, axis=0) + c[1] * np.roll(f, 1, axis=0) + c[2] * f +\n                c[3] * np.roll(f, -1, axis=0) + c[4] * np.roll(f, -2, axis=0)) / (dx**2)\n\n    def diff_yy_p4(f, dx):\n        \"\"\"Order-4 centered 2nd derivative along axis 1.\"\"\"\n        c = [-1.0/12.0, 16.0/12.0, -30.0/12.0, 16.0/12.0, -1.0/12.0]\n        return (c[0] * np.roll(f, 2, axis=1) + c[1] * np.roll(f, 1, axis=1) + c[2] * f +\n                c[3] * np.roll(f, -1, axis=1) + c[4] * np.roll(f, -2, axis=1)) / (dx**2)\n\n    def diff_zz_p4(f, dx):\n        \"\"\"Order-4 centered 2nd derivative along axis 2.\"\"\"\n        c = [-1.0/12.0, 16.0/12.0, -30.0/12.0, 16.0/12.0, -1.0/12.0]\n        return (c[0] * np.roll(f, 2, axis=2) + c[1] * np.roll(f, 1, axis=2) + c[2] * f +\n                c[3] * np.roll(f, -1, axis=2) + c[4] * np.roll(f, -2, axis=2)) / (dx**2)\n\n    # --- Analytic Functions ---\n    \n    def get_analytic_fields(N):\n        dx = 1.0 / N\n        coords = np.arange(N) * dx\n        x, y, z = np.meshgrid(coords, coords, coords, indexing='ij')\n\n        pi2 = 2.0 * np.pi\n        \n        # Field phi and its Laplacian source S\n        phi = np.sin(pi2 * x) * np.cos(pi2 * y) + np.sin(pi2 * z)\n        S = -2.0 * (pi2**2) * np.sin(pi2 * x) * np.cos(pi2 * y) - (pi2**2) * np.sin(pi2 * z)\n\n        # Field pi and its gradient source J\n        pi_field = np.exp(np.sin(pi2 * x) + np.cos(pi2 * y) + np.sin(pi2 * z))\n        Jx = pi2 * np.cos(pi2 * x) * pi_field\n        Jy = -pi2 * np.sin(pi2 * y) * pi_field\n        Jz = pi2 * np.cos(pi2 * z) * pi_field\n\n        return phi, pi_field, S, Jx, Jy, Jz\n\n    def run_convergence_test(p, kappa, N_list):\n        dx_list = []\n        h_norms = []\n        m_norms = []\n\n        for N in N_list:\n            dx = 1.0 / N\n            dx_list.append(dx)\n\n            phi, pi_field, S, Jx, Jy, Jz = get_analytic_fields(N)\n\n            if p == 2:\n                # Hamiltonian residual\n                lap_phi = diff_xx_p2(phi, dx) + diff_yy_p2(phi, dx) + diff_zz_p2(phi, dx)\n                Hh = lap_phi - S\n                \n                # Momentum residuals\n                Mxh = diff_x_p2(pi_field, dx) - Jx\n                Myh = diff_y_p2(pi_field, dx) - Jy\n                Mzh = diff_z_p2(pi_field, dx) - Jz\n            elif p == 4:\n                # Hamiltonian residual\n                lap_phi = diff_xx_p4(phi, dx) + diff_yy_p4(phi, dx) + diff_zz_p4(phi, dx)\n                Hh = lap_phi - S\n\n                # Momentum residuals\n                Mxh = diff_x_p4(pi_field, dx) - Jx\n                Myh = diff_y_p4(pi_field, dx) - Jy\n                Mzh = diff_z_p4(pi_field, dx) - Jz\n            else:\n                raise ValueError(\"Unsupported order p.\")\n\n            # Calculate L2 norms\n            h_norm = np.sqrt(np.mean(Hh**2))\n            m_norm = np.sqrt(np.mean(Mxh**2 + Myh**2 + Mzh**2))\n            \n            # Apply damping\n            damping_factor = np.exp(-kappa * 1.0)\n            h_norms.append(h_norm * damping_factor)\n            m_norms.append(m_norm * damping_factor)\n\n        # Fit convergence order\n        log_dx = np.log(dx_list)\n        log_h_norm = np.log(h_norms)\n        log_m_norm = np.log(m_norms)\n\n        p_obs_h = stats.linregress(log_dx, log_h_norm).slope\n        p_obs_m = stats.linregress(log_dx, log_m_norm).slope\n        \n        return p_obs_h, p_obs_m\n\n    test_cases = [\n        {'p': 2, 'kappa': 0, 'N_list': [16, 24, 32, 48]},\n        {'p': 4, 'kappa': 0, 'N_list': [16, 24, 32, 48]},\n        {'p': 2, 'kappa': 20, 'N_list': [16, 24, 32, 48]},\n        {'p': 4, 'kappa': 10, 'N_list': [16, 24, 32, 48]},\n    ]\n    tolerance = 0.2\n    \n    final_results = []\n    for case in test_cases:\n        p_expected = case['p']\n        p_obs_h, p_obs_m = run_convergence_test(p_expected, case['kappa'], case['N_list'])\n        \n        h_success = abs(p_obs_h - p_expected) = tolerance\n        m_success = abs(p_obs_m - p_expected) = tolerance\n        \n        final_results.append(h_success and m_success)\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "即使一个数值格式被正确实现，如果它不稳定，仍然可能产生毫无意义的结果。这个练习深入探讨了数值稳定性的核心，分析了时间积分格式如何与约束阻尼项相互作用。通过对一个简单但具有代表性的模型进行稳定性分析，我们可以确定选择稳定模拟参数的“游戏规则”，确保我们的模拟在物理上是可靠的 。",
            "id": "3469189",
            "problem": "在爱因斯坦方程的广义谐和 (GH) 形式中，约束破坏场（为简单起见，用标量代理 $C$ 表示）已知会传播，并通过在演化系统中加入一个系数为 $\\gamma_{0}$ 的线性阻尼项而被阻尼。描述单个傅里叶模式的局域时间约束动力学的标准线性化模型是常微分方程\n$$\n\\frac{dC}{dt} = \\left(-\\gamma_{0} + i\\,\\omega\\right) C,\n$$\n其中 $\\omega$ 是由空间传播决定的实角频率，$i$ 是虚数单位，而负实部 $-\\gamma_{0}$ 模拟阻尼。考虑将空间上的半离散化线方法和时间步长为 $\\Delta t$ 的显式中点 Runge–Kutta 时间积分器（二阶）应用于此线性测试方程。显式中点格式由两个阶段定义，当应用于线性系统 $y'=\\lambda y$ 时，会产生如下更新：\n$$\ny_{n+1} = y_n + \\Delta t\\,\\lambda\\left(y_n + \\frac{\\Delta t}{2}\\,\\lambda\\,y_n\\right),\n$$\n其中 $\\lambda$ 是线性算子的特征值，因此在这里 $\\lambda = -\\gamma_{0} + i\\,\\omega$。使用 von Neumann 分析和该格式的放大因子，通过隔离负实轴上的最坏情况（即，设 $\\omega=0$ 使得 $\\lambda=-\\gamma_{0}$ 为负实数），单独分析阻尼项的稳定性条件。根据此分析，确定无量纲积 $\\gamma_{0}\\Delta t$ 的最大允许值，使得显式中点法对于 GH 约束演化的阻尼部分保持线性稳定，从而确保相对于阻尼的演化是非刚性的。\n\n以代表 $\\gamma_{0}\\Delta t$ 最大允许值的单个实数形式提供答案。无需四舍五入。",
            "solution": "## 问题验证\n\n### 第 1 步：提取已知条件\n- 约束破坏动力学由常微分方程 (ODE) 建模：$\\frac{dC}{dt} = \\left(-\\gamma_{0} + i\\,\\omega\\right) C$。\n- $\\gamma_0$ 是一个实阻尼系数。\n- $\\omega$ 是一个实角频率。\n- $i$ 是虚数单位。\n- 数值方法是显式中点 Runge-Kutta 格式（二阶）。\n- 该格式应用于线性系统 $y'=\\lambda y$ 的更新规则是：$y_{n+1} = y_n + \\Delta t\\,\\lambda\\left(y_n + \\frac{\\Delta t}{2}\\,\\lambda\\,y_n\\right)$。\n- 特征值 $\\lambda$ 对应于 ODE 中的系数：$\\lambda = -\\gamma_{0} + i\\,\\omega$。\n- 分析将仅针对阻尼项进行，这意味着通过设置 $\\omega=0$ 来隔离负实轴上的情况。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据指定标准对问题进行验证。\n\n- **科学依据：** 该问题设置在数值相对论的背景下，特别是广义谐和 (GH) 形式。使用线性测试方程来分析数值方法的稳定性（von Neumann 分析）是研究偏微分方程数值解的标准和基本技术。模型 ODE 和指定的显式中点格式是该领域的标准工具。该问题具有科学合理性。\n- **适定性：** 该问题提供了所有必要信息：ODE、数值格式的更新规则以及要分析的特定情况（$\\omega=0$）。它要求一个单一、明确定义的量（$\\gamma_0 \\Delta t$ 的最大值），该量可以从给定信息中唯一确定。该问题是适定的。\n- **客观性：** 该问题用精确的数学语言陈述。所用术语在数值分析和理论物理学中是标准的。没有主观或模糊的语言。\n\n### 第 3 步：结论和行动\n该问题被判定为**有效**。它是自洽的，在应用于物理学的数值分析方面具有科学依据，并且是适定的。我将继续进行求解。\n\n## 解答\n\n该问题要求我们确定在将显式中点 Runge-Kutta 方法应用于表示阻尼约束破坏的一阶线性常微分方程时的稳定性极限。\n\n单个模式的模型方程由下式给出\n$$\n\\frac{dC}{dt} = \\left(-\\gamma_{0} + i\\,\\omega\\right) C.\n$$\n这是一个标准形式为 $y' = \\lambda y$ 的线性测试方程，其中复特征值为 $\\lambda = -\\gamma_{0} + i\\,\\omega$。\n\n该问题提供了使用显式中点格式进行一个时间步长 $\\Delta t$ 更新的规则：\n$$\ny_{n+1} = y_n + \\Delta t\\,\\lambda\\left(y_n + \\frac{\\Delta t}{2}\\,\\lambda\\,y_n\\right).\n$$\n为了分析该格式的稳定性，我们首先确定其放大因子 $g$。放大因子由关系式 $y_{n+1} = g(\\lambda \\Delta t) y_n$ 定义。我们可以通过从更新规则的右侧提取出 $y_n$ 来找到 $g$：\n$$\ny_{n+1} = \\left[1 + \\Delta t\\,\\lambda\\left(1 + \\frac{\\Delta t}{2}\\,\\lambda\\right)\\right] y_n.\n$$\n将 $\\Delta t\\,\\lambda$ 项展开，我们得到：\n$$\ny_{n+1} = \\left[1 + \\lambda \\Delta t + \\frac{1}{2}(\\lambda \\Delta t)^2\\right] y_n.\n$$\n因此，放大因子 $g$ 作为复变量 $z = \\lambda \\Delta t$ 的函数是\n$$\ng(z) = 1 + z + \\frac{1}{2}z^2.\n$$\n正如对于一个二阶 Runge-Kutta 方法所预期的那样，这是指数函数 $\\exp(z)$ 的二阶泰勒级数展开。\n\n数值格式线性稳定的条件是放大因子的模长不得超过 1，即\n$$\n|g(z)| \\le 1.\n$$\n问题要求我们只分析阻尼项的稳定性条件。这可以通过考虑复平面负实轴上的最坏情况来实现，这对应于将特征值的振荡部分设为零，即 $\\omega=0$。\n当 $\\omega=0$ 时，特征值 $\\lambda$ 变为纯负实数：\n$$\n\\lambda = -\\gamma_{0}.\n$$\n将其代入 $z$ 的表达式，我们得到：\n$$\nz = \\lambda \\Delta t = -\\gamma_{0} \\Delta t.\n$$\n让我们定义无量纲积 $x = \\gamma_{0} \\Delta t$。由于 $\\gamma_{0}$ 代表阻尼，它是非负的（$\\gamma_{0} \\ge 0$），且时间步长 $\\Delta t$ 是正的（$\\Delta t > 0$），所以我们有 $x \\ge 0$。变量 $z$ 于是可以写成 $z = -x$。\n\n稳定性条件 $|g(z)| \\le 1$ 变成了一个关于 $x$ 的条件：\n$$\n|g(-x)| \\le 1.\n$$\n将 $z=-x$ 代入 $g(z)$ 的多项式：\n$$\ng(-x) = 1 + (-x) + \\frac{1}{2}(-x)^2 = 1 - x + \\frac{1}{2}x^2.\n$$\n因为 $x$ 是实数，所以 $g(-x)$ 也是实数。稳定性条件变为：\n$$\n\\left|1 - x + \\frac{1}{2}x^2\\right| \\le 1.\n$$\n这个绝对值不等式等价于以下不等式对：\n$$\n-1 \\le 1 - x + \\frac{1}{2}x^2 \\le 1.\n$$\n我们分别分析每个不等式。\n\n首先，考虑右侧不等式：\n$$\n1 - x + \\frac{1}{2}x^2 \\le 1.\n$$\n两边同时减去 $1$ 得到：\n$$\n-x + \\frac{1}{2}x^2 \\le 0.\n$$\n提取因子 $x$：\n$$\nx\\left(\\frac{1}{2}x - 1\\right) \\le 0.\n$$\n由于我们已确定 $x = \\gamma_0 \\Delta t \\ge 0$，我们只关心非负解。如果 $x=0$，不等式 $0 \\le 0$ 成立。如果 $x>0$，我们可以用 $x$ 除以两边而不改变不等号方向：\n$$\n\\frac{1}{2}x - 1 \\le 0 \\implies \\frac{1}{2}x \\le 1 \\implies x \\le 2.\n$$\n综合这些，第一个不等式给出的范围是 $0 \\le x \\le 2$。\n\n接下来，考虑左侧不等式：\n$$\n-1 \\le 1 - x + \\frac{1}{2}x^2.\n$$\n两边同时加上 $1$ 得到：\n$$\n0 \\le 2 - x + \\frac{1}{2}x^2.\n$$\n我们来分析二次函数 $P(x) = \\frac{1}{2}x^2 - x + 2$。这是一个开口向上的抛物线。要确定它是否总是非负，我们可以通过检查其判别式 $\\Delta = b^2 - 4ac$。对于这个二次函数，$a=\\frac{1}{2}$，$b=-1$，$c=2$。\n$$\n\\Delta = (-1)^2 - 4\\left(\\frac{1}{2}\\right)(2) = 1 - 4 = -3.\n$$\n由于判别式为负（$\\Delta  0$）且首项系数为正（$a=\\frac{1}{2} > 0$），二次函数 $P(x)$ 对所有实数 $x$ 始终为正。因此，不等式 $0 \\le P(x)$ 总是成立。\n\n整体稳定性条件要求两个不等式同时满足。第一个不等式给出 $0 \\le x \\le 2$，而第二个不等式对所有 $x$ 都成立。这些条件的交集就是：\n$$\n0 \\le x \\le 2.\n$$\n问题要求无量纲积 $\\gamma_{0}\\Delta t$ 的最大允许值，我们已将其定义为 $x$。根据分析，$x$ 的最大值是 $2$。\n\n因此，为使显式中点法对于演化的纯阻尼部分保持线性稳定，积 $\\gamma_{0}\\Delta t$ 不得大于 $2$。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "正如上一个练习所示，显式方法虽然简单，但其稳定性通常有严格的限制。当处理“刚性”项时，这会成为一个主要问题，例如在数值相对论中经常使用的强阻尼项。本练习探讨了为什么刚性是一个问题，以及先进的隐式-显式（IMEX）方法如何通过比较显式和隐式格式的稳定性，为此提供一个强大而高效的解决方案 。",
            "id": "3469166",
            "problem": "考虑在数值相对论中一个约束传播子系统的线方法（method-of-lines）离散化，其中主要的刚性项是 $-\\kappa C$ 形式的线性阻尼，其中 $C$ 是一个约束变量，$\\kappa > 0$ 是一个阻尼系数。在空间离散化之后，重点关注 $C$ 的单个傅里叶模式的线性标量常微分方程 (ODE) $dC/dt = -\\kappa C$。在使用广义谐波表述的双黑洞演化中，实际的选择常常使得乘积 $\\kappa \\Delta t$ 不可忽略，其中 $\\Delta t$ 是为满足接近光速的波传播速度的 Courant–Friedrichs–Lewy (CFL) 界限而选择的时间步长。\n\n您将比较一个纯显式的四阶显式 Runge–Kutta 方法 (ERK4) 与一个隐式–显式 (IMEX) 分裂方法。在 IMEX 方法中，刚性阻尼部分通过后向欧拉法隐式处理，而非刚性项则显式处理。为使讨论基于第一性原理，请从应用于线性测试方程 $y' = \\lambda y$（其中 $\\lambda \\in \\mathbb{C}$）的 Runge–Kutta 方法的定义开始，并定义相关的线性稳定性函数 $R(z)$，其中 $z = \\lambda \\Delta t$。对于应用于 $y'=-\\kappa y$ 的 ERK4 方法（因此 $z=-\\kappa \\Delta t$ 位于负实轴上），稳定性要求是 $|R(z)| \\leq 1$。对于仅应用于刚性项的 IMEX 方案的隐式部分（后向欧拉法），其相关的稳定性函数也以类似方式定义。\n\n使用此框架：\n- 从 Runge–Kutta 的阶段方程和更新公式推导线性测试方程的 ERK4 稳定性函数 $R(z)$，不要使用预先记下的稳定性多项式。\n- 将问题具体化到 $z=-x$（其中 $x=\\kappa \\Delta t > 0$），并确定使得显式 ERK4 方法在负实轴上保持线性稳定的最大 $x$ 值，即边界条件 $|R(-x_{\\mathrm{crit}})| = 1$ 在 $x_{\\mathrm{crit}} \\neq 0$ 时的唯一正解 $x_{\\mathrm{crit}}$。\n- 使用从第一性原理推导的后向欧拉稳定性函数，简要解释为什么对刚性项 $-\\kappa C$ 的 IMEX 处理在负实轴上对所有 $x>0$ 都是无条件稳定的。\n\n假设在代码单位下，总质量 $M$ 设为 $M=1$，因此现实参数如 $M/64 \\le \\Delta x \\le M/8$、CFL 数 $0.3 \\le \\nu \\le 0.5$（因此 $\\Delta t = \\nu \\Delta x$）以及阻尼参数 $10 \\le \\kappa \\le 100$ 在计算域的不同区域是合理的。使用这些参数来定性解释典型的 $\\kappa \\Delta t$ 值相对于您推导的显式 ERK4 稳定性区间的位置。\n\n计算 $x_{\\mathrm{crit}}$ 并将您的最终答案表示为一个无量纲数，四舍五入到四位有效数字。",
            "solution": "此问题是有效的。它在科学上基于微分方程数值分析的原理，特别是在数值相对论的背景下。该问题提法恰当、客观，并包含得出唯一解所需的所有必要信息。\n\n主要任务是分析用于求解刚性常微分方程 (ODE) $dC/dt = -\\kappa C$ 的数值方法的稳定性，该方程模拟了数值相对论模拟中的一个约束阻尼项。我们将比较一个全显式方法 (ERK4) 和一个隐式-显式 (IMEX) 方法。\n\n首先，我们推导经典的四阶显式 Runge-Kutta (ERK4) 方法的稳定性函数。一个通用的 Runge-Kutta 方法由其阶段定义。对于经典的 ERK4，这些阶段是：\n$$\nk_1 = f(t_n, y_n) \\\\\nk_2 = f(t_n + \\frac{1}{2}\\Delta t, y_n + \\frac{1}{2}\\Delta t k_1) \\\\\nk_3 = f(t_n + \\frac{1}{2}\\Delta t, y_n + \\frac{1}{2}\\Delta t k_2) \\\\\nk_4 = f(t_n + \\Delta t, y_n + \\Delta t k_3)\n$$\n然后通过以下方式更新解：\n$$\ny_{n+1} = y_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\n为了找到稳定性函数 $R(z)$，我们将此格式应用于线性测试方程 $y' = \\lambda y$，其中 $f(t,y) = \\lambda y$。令 $z = \\lambda \\Delta t$。阶段变为：\n$$\nk_1 = \\lambda y_n \\\\\nk_2 = \\lambda \\left(y_n + \\frac{\\Delta t}{2}(\\lambda y_n)\\right) = \\lambda y_n \\left(1 + \\frac{\\lambda \\Delta t}{2}\\right) = \\lambda y_n \\left(1 + \\frac{z}{2}\\right) \\\\\nk_3 = \\lambda \\left(y_n + \\frac{\\Delta t}{2}k_2\\right) = \\lambda \\left(y_n + \\frac{\\Delta t}{2} \\left[\\lambda y_n \\left(1 + \\frac{z}{2}\\right)\\right]\\right) = \\lambda y_n \\left(1 + \\frac{z}{2}\\left(1 + \\frac{z}{2}\\right)\\right) = \\lambda y_n \\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right) \\\\\nk_4 = \\lambda (y_n + \\Delta t k_3) = \\lambda \\left(y_n + \\Delta t \\left[\\lambda y_n \\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right)\\right]\\right) = \\lambda y_n \\left(1 + z\\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right)\\right) = \\lambda y_n \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\\right)\n$$\n将这些代入更新公式 $y_{n+1} = R(z) y_n$：\n$$\ny_{n+1} = y_n + \\frac{\\Delta t}{6} \\left[\\lambda y_n + 2\\lambda y_n \\left(1 + \\frac{z}{2}\\right) + 2\\lambda y_n \\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right) + \\lambda y_n \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\\right)\\right]\n$$\n两边除以 $y_n$ 并回顾 $z = \\lambda \\Delta t$：\n$$\nR(z) = 1 + \\frac{z}{6} \\left[1 + 2\\left(1 + \\frac{z}{2}\\right) + 2\\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right) + \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\\right)\\right]\n$$\n$$\nR(z) = 1 + \\frac{z}{6} \\left[1 + 2 + z + 2 + z + \\frac{z^2}{2} + 1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\\right]\n$$\n合并括号内的项：\n$$\nR(z) = 1 + \\frac{z}{6} \\left[(1+2+2+1) + (z+z+z) + \\left(\\frac{z^2}{2}+\\frac{z^2}{2}\\right) + \\frac{z^3}{4}\\right]\n$$\n$$\nR(z) = 1 + \\frac{z}{6} \\left[6 + 3z + z^2 + \\frac{z^3}{4}\\right]\n$$\n将 $z/6$ 项分配进去，得到 ERK4 的稳定性函数：\n$$\nR(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}\n$$\n正如预期的那样，这是 $\\exp(z)$ 的四阶泰勒级数展开。\n\n接下来，我们确定该方法在负实轴上的稳定性极限。我们的 ODE 是 $dC/dt = -\\kappa C$，所以 $\\lambda = -\\kappa$。我们定义 $x = \\kappa \\Delta t > 0$，这意味着 $z = \\lambda \\Delta t = -x$。稳定性条件是 $|R(-x)| \\le 1$。\n稳定性函数为：\n$$\nR(-x) = 1 - x + \\frac{x^2}{2} - \\frac{x^3}{6} + \\frac{x^4}{24}\n$$\n负实轴上的稳定区间是 $[-x_{\\mathrm{crit}}, 0]$，其中 $x_{\\mathrm{crit}}$ 是使得对于所有 $x \\in [0, x_{\\mathrm{crit}}]$ 都有 $|R(-x)| \\le 1$ 的最大正 $x$ 值。稳定区域的边界是 $|R(-x)| = 1$。这产生两个条件：$R(-x) = 1$ 或 $R(-x) = -1$。\n情况 1：$R(-x) = 1$\n$$\n1 - x + \\frac{x^2}{2} - \\frac{x^3}{6} + \\frac{x^4}{24} = 1\n$$\n$$\n-x + \\frac{x^2}{2} - \\frac{x^3}{6} + \\frac{x^4}{24} = 0\n$$\n将 $x$ 因子提出（因为我们寻求 $x_{\\mathrm{crit}} \\neq 0$）：\n$$\nx\\left(-1 + \\frac{x}{2} - \\frac{x^2}{6} + \\frac{x^3}{24}\\right) = 0\n$$\n我们必须找到括号内多项式的正根。乘以 $24$：\n$$\nx^3 - 4x^2 + 12x - 24 = 0\n$$\n情况 2：$R(-x) = -1$\n$$\n1 - x + \\frac{x^2}{2} - \\frac{x^3}{6} + \\frac{x^4}{24} = -1\n$$\n$$\n\\frac{x^4}{24} - \\frac{x^3}{6} + \\frac{x^2}{2} - x + 2 = 0\n$$\n函数 $R(-x)$ 从 $R(0)=1$ 开始并初始递减。函数图像显示其最小值为正，因此永远不会达到 $-1$。因此，情况 2 的方程没有实根，稳定性边界完全由情况 1 的非零根定义。\n我们需要求解 $x^3 - 4x^2 + 12x - 24 = 0$ 的正根 $x > 0$。数值方法（例如 Newton-Raphson 法）得出一个唯一的实根。\n$$\nx_{\\mathrm{crit}} \\approx 2.78528178...\n$$\n四舍五入到四位有效数字，$x_{\\mathrm{crit}} = 2.785$。ERK4 在负实轴上的稳定区间约为 $[-2.785, 0]$。这意味着为了保持稳定，我们必须有 $\\kappa \\Delta t \\le 2.785$。\n\n第三，我们分析后向欧拉法的稳定性，该方法被提议用于 IMEX 方案中的刚性项。对于 $y' = f(t,y)$，后向欧拉法是 $y_{n+1} = y_n + \\Delta t f(t_{n+1}, y_{n+1})$。将其应用于测试方程 $y' = \\lambda y$：\n$$\ny_{n+1} = y_n + \\Delta t (\\lambda y_{n+1}) = y_n + z y_{n+1}\n$$\n求解 $y_{n+1}$：\n$$\ny_{n+1}(1-z) = y_n \\implies y_{n+1} = \\frac{1}{1-z}y_n\n$$\n后向欧拉法的稳定性函数是 $R_{\\mathrm{BE}}(z) = \\frac{1}{1-z}$。对于阻尼项，$z = -x = -\\kappa \\Delta t$。\n$$\nR_{\\mathrm{BE}}(-x) = \\frac{1}{1 - (-x)} = \\frac{1}{1+x}\n$$\n稳定性要求是 $|R_{\\mathrm{BE}}(-x)| \\le 1$。因为 $x = \\kappa \\Delta t > 0$，我们有 $1+x > 1$。因此：\n$$\n0  \\frac{1}{1+x}  1\n$$\n这个不等式对所有 $x > 0$ 都成立。因此，后向欧拉法对于这类阻尼项是无条件稳定的。这个特性，被称为 A-稳定性，使其成为在 IMEX 框架内处理刚性项的理想选择，因为它对时间步长 $\\Delta t$ 没有施加稳定性限制。\n\n最后，我们使用提供的在代码单位下（其中 $M=1$）的现实参数来解释这些结果：$M/64 \\le \\Delta x \\le M/8$，$0.3 \\le \\nu \\le 0.5$ 以及 $10 \\le \\kappa \\le 100$。我们关心的参数是 $x = \\kappa \\Delta t = \\kappa \\nu \\Delta x$。\n让我们找出 $x$ 的近似范围。\n最小值出现在 $\\kappa, \\nu, \\Delta x$ 最小的时候：\n$$\nx_{\\mathrm{min}} = 10 \\times 0.3 \\times \\frac{1}{64} = \\frac{3}{64} \\approx 0.047\n$$\n最大值出现在 $\\kappa, \\nu, \\Delta x$ 最大的时候：\n$$\nx_{\\mathrm{max}} = 100 \\times 0.5 \\times \\frac{1}{8} = \\frac{50}{8} = 6.25\n$$\n$x = \\kappa \\Delta t$ 的合理值范围大约是 $[0.047, 6.25]$。\n将此范围与 ERK4 的稳定性极限 $x_{\\mathrm{crit}} \\approx 2.785$ 进行比较：\n- 在参数范围的低端（例如，弱阻尼、高分辨率），$x$ 远在 ERK4 的稳定区域内 ($0.047  2.785$)。\n- 在参数范围的高端（例如，强阻尼、低分辨率），$x$ 会显著超过 ERK4 的稳定性极限 ($6.25 > 2.785$)。\n这一分析表明，对于数值相对论中的许多现实模拟设置，像 ERK4 这样的纯显式方法将被迫采用远小于波传播的 CFL 条件所要求的时间步长，这仅仅是为了满足约束阻尼项的稳定性。这使得显式方法效率低下。IMEX 方法通过隐式处理刚性阻尼项，规避了这种严苛的时间步长限制，并允许根据非刚性项（如引力波传播）的物理特性来选择时间步长，从而实现更高效的计算。\n\n计算出的 $x$ 的临界值为 $x_{\\mathrm{crit}} \\approx 2.785$。",
            "answer": "$$\n\\boxed{2.785}\n$$"
        }
    ]
}