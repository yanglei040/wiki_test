{
    "hands_on_practices": [
        {
            "introduction": "对动力学视界的理解始于掌握其基本几何性质的计算。本练习  聚焦于在 Vaidya 时空中计算零膨胀，这是模拟吸积黑洞的关键模型，旨在识别其中的边缘被困管。这项实践是理解动力学视界几何定义及其在具体时空中应用的基础。",
            "id": "3472237",
            "problem": "考虑用于黑洞增长的数值相对论研究中的球对称内行 Vaidya 时空，\n$$\nds^{2} = -\\left(1 - \\frac{2 M(v)}{r}\\right) dv^{2} + 2\\, dv\\, dr + r^{2} d\\Omega^{2},\n$$\n其中 $M(v)$ 是提前时 $v$ 的一个光滑、非减的质量函数，$d\\Omega^{2}$ 是单位二维球面上的线元。令 $S$ 为一个 $v$ 和 $r$ 恒定的圆形二维球面。边缘被困管 (marginally trapped tube, MTT) 是一个由这样的球面叶状构成的超曲面，在其上，未来指向的向外零法向的膨胀率为零，而未来指向的向内零法向的膨胀率为负。\n\n从适用于动力学视界的基本定义出发：\n- 零法向 $\\ell^{a}$ 和 $n^{a}$ 是未来指向的，与 $S$ 正交，并通过 $\\ell^{a} n_{a} = -1$ 进行归一化。\n- 零法向 $k^{a}$ 的膨胀率 $\\theta_{(k)}$ 定义为 $S$ 的面积沿着 $k^{a}$ 的分数变化率。\n\n推导 $\\theta_{(\\ell)}$ 和 $\\theta_{(n)}$ 关于 $r$ 和 $M(v)$ 的显式表达式，然后在超曲面 $r = 2 M(v)$ 上计算它们的值。明确写出数对 $\\left(\\theta_{(\\ell)}\\big|_{r=2M(v)},\\, \\theta_{(n)}\\big|_{r=2M(v)}\\right)$，并用它来识别 $r=2M(v)$ 处的 MTT。\n\n最终答案请使用几何单位制（$G = c = 1$）。你的最终答案必须是两个计算出的膨胀率的有序对，以单行矩阵的形式呈现。无需四舍五入。",
            "solution": "该问题要求推导内行 Vaidya 时空的零膨胀率，并在超曲面 $r = 2M(v)$ 上计算其值，以将其识别为边缘被困管（MTT）。\n\n内行 Vaidya 度规在提前 Eddington-Finkelstein 类坐标 $(v, r, \\theta, \\phi)$ 中表示为\n$$\nds^{2} = -\\left(1 - \\frac{2 M(v)}{r}\\right) dv^{2} + 2\\, dv\\, dr + r^{2} d\\Omega^{2}\n$$\n其中 $d\\Omega^{2} = d\\theta^2 + \\sin^2\\theta \\, d\\phi^2$。协变度规张量分量 $g_{ab}$ 可以直接从线元中读出：\n$g_{vv} = -\\left(1 - \\frac{2M(v)}{r}\\right)$\n$g_{vr} = g_{rv} = 1$\n$g_{\\theta\\theta} = r^2$\n$g_{\\phi\\phi} = r^2 \\sin^2\\theta$\n所有其他分量均为零。\n\n为了找到零法向量，我们首先需要逆变度规张量 $g^{ab}$，它是 $g_{ab}$ 的逆。对应于 $(v, r)$ 坐标的块是 $\\begin{pmatrix} g_{vv}  g_{vr} \\\\ g_{rv}  g_{rr} \\end{pmatrix} = \\begin{pmatrix} -(1 - 2M(v)/r)  1 \\\\ 1  0 \\end{pmatrix}$。其逆矩阵是 $\\begin{pmatrix} 0  1 \\\\ 1  1 - 2M(v)/r \\end{pmatrix}$。角向部分是对角的，很容易求逆。因此，$g^{ab}$ 的非零分量是：\n$g^{vr} = g^{rv} = 1$\n$g^{rr} = 1 - \\frac{2M(v)}{r}$\n$g^{\\theta\\theta} = \\frac{1}{r^2}$\n$g^{\\phi\\phi} = \\frac{1}{r^2 \\sin^2\\theta}$\n\n曲面 $S$ 是一个 $v$ 和 $r$ 恒定的二维球面。其切空间由 $\\frac{\\partial}{\\partial\\theta}$ 和 $\\frac{\\partial}{\\partial\\phi}$ 张成。零法向 $\\ell^a$ 和 $n^a$ 必须与 $S$ 正交。由于度规的块对角结构，任何只有 $(v, r)$ 分量的向量都与 $S$ 切空间中的任何向量正交。因此我们寻找形式为 $k^a = (k^v, k^r, 0, 0)$ 的零向量。零条件为 $g_{ab} k^a k^b = 0$。\n$$\ng_{vv}(k^v)^2 + 2 g_{vr} k^v k^r + g_{rr}(k^r)^2 = 0\n$$\n$$\n-\\left(1 - \\frac{2M(v)}{r}\\right)(k^v)^2 + 2 k^v k^r = 0\n$$\n$$\nk^v \\left[ 2k^r - \\left(1 - \\frac{2M(v)}{r}\\right)k^v \\right] = 0\n$$\n这个方程产生了两族零方向：\n1. $k^v = 0$：这意味着 $k^a$ 与 $(0, 1, 0, 0)$ 成比例。这个向量 $\\frac{\\partial}{\\partial r}$ 与 $v$ 为常数的零超曲面相切。它代表内行光线。为了指向内部（$r$ 减小），其 $r$ 分量必须为负。这是我们的向内零法向 $n^a$。\n2. $2k^r = \\left(1 - \\frac{2M(v)}{r}\\right)k^v$：这给出了一个与 $\\left(1, \\frac{1}{2}\\left(1 - \\frac{2M(v)}{r}\\right), 0, 0\\right)$ 成比例的向量。对于 $r > 2M(v)$，径向分量为正，表示向外方向。这是我们的向外零法向 $\\ell^a$。\n\n两个向量都必须是未来指向的。在此坐标系中，由于 $v$ 是提前时，如果一个向量 $k^a$ 的 $v$ 分量为正，或者在 $k^v=0$ 的极限情况下，如果它与未来光锥相切，那么它就是未来指向的。对于 $\\ell^a$，我们可以选择一个标度使得 $\\ell^v > 0$。对于 $n^a$，我们有 $n^v=0$；与协变未来指向向量 $dv = (1,0,0,0)_a$ 缩并，我们发现 $n^a (dv)_a = n^v = 0$，所以它位于边界上。我们可以通过检查其与一个类时向量的缩并来验证它是未来指向的，例如，对于一个四维速度为 $T^a \\propto (\\partial/\\partial v)^a$ 的观察者，必须满足条件 $g_{ab}k^a T^b \\le 0$。对于 $n^a \\propto (0,-1,0,0)$，我们有 $g_{ab} n^a T^b \\propto g_{vr}n^r = -1 < 0$。所以两者都是未来指向的。\n\n我们现在使用归一化条件 $\\ell^a n_a = -1$ 和一个典范选择来固定零向量 $\\ell^a$ 和 $n^a$ 的标度。一个标准的选择是选取其中一个向量与一个仿射参数化的零测地线汇相切。让我们分析 $n^a \\propto (0, -1, 0, 0)$。对于切矢为 $k^a$ 的仿射参数化测地线，其测地线方程为 $k^b \\nabla_b k^a = 0$。对于 $n^a = C_n(0, -1, 0, 0) = (0, -C_n, 0, 0)$，加速度为 $n^b\\nabla_b n^a = n^r\\nabla_r n^a = -C_n (\\partial_r n^a + \\Gamma^a_{rb}n^b) = -C_n \\Gamma^a_{rr} n^r$。Christoffel 符号分量 $\\Gamma^a_{rr}$ 由 $\\Gamma^\\lambda_{rr} = g^{\\lambda\\sigma}\\partial_r g_{r\\sigma}$ 给出。由于 $g_{r\\sigma}$ 的所有分量（即 $g_{rv}=1$，$g_{rr}=0$ 等）都与 $r$ 无关，所以 $\\Gamma^a_{rr}=0$。因此，$n^b \\nabla_b n^a = 0$。我们可以做出典范选择 $C_n=1$，所以 $n^a=(0,-1,0,0)$ 是仿射参数化的。\n\n对于 $n^a = (0, -1, 0, 0)$，我们求其协变形式 $n_a = g_{ab} n^b$。\n$n_v = g_{vv}n^v + g_{vr}n^r = (1)(-1) = -1$。\n$n_r = g_{rv}n^v + g_{rr}n^r = 0$。\n所以，$n_a = (-1, 0, 0, 0)$。\n\n现在我们设 $\\ell^a = C_\\ell \\left(1, \\frac{1}{2}\\left(1 - \\frac{2M(v)}{r}\\right), 0, 0\\right)$ 并使用归一化条件：\n$\\ell^a n_a = \\ell^v n_v = C_\\ell(1)(-1) = -C_\\ell = -1$，这意味着 $C_\\ell = 1$。\n因此，我们典范归一化的零向量是：\n$$\n\\ell^a = \\left(1, \\frac{1}{2}\\left(1 - \\frac{2M(v)}{r}\\right), 0, 0\\right)\n$$\n$$\nn^a = \\left(0, -1, 0, 0\\right)\n$$\n\n零向量场 $k^a$ 的膨胀率 $\\theta_{(k)}$ 是曲面 $S$ 面积 $A$ 的分数变化率。半径为 $r$ 的球面 $S$ 的面积是 $A = 4\\pi r^2$。\n$$\n\\theta_{(k)} = \\frac{1}{A} \\mathcal{L}_k A = \\frac{1}{4\\pi r^2} \\mathcal{L}_k (4\\pi r^2) = \\frac{1}{r^2} k^a \\partial_a (r^2) = \\frac{1}{r^2} (2r k^a \\partial_a r) = \\frac{2}{r} k^r\n$$\n使用这个公式，我们可以计算 $\\ell^a$ 和 $n^a$ 的膨胀率。\n对于向外零法向 $\\ell^a$，其径向分量为 $\\ell^r = \\frac{1}{2}\\left(1 - \\frac{2M(v)}{r}\\right)$。膨胀率为：\n$$\n\\theta_{(\\ell)} = \\frac{2}{r} \\ell^r = \\frac{2}{r} \\cdot \\frac{1}{2}\\left(1 - \\frac{2M(v)}{r}\\right) = \\frac{1}{r}\\left(1 - \\frac{2M(v)}{r}\\right)\n$$\n对于向内零法向 $n^a$，其径向分量为 $n^r = -1$。膨胀率为：\n$$\n\\theta_{(n)} = \\frac{2}{r} n^r = \\frac{2}{r}(-1) = -\\frac{2}{r}\n$$\n\n最后，我们在由 $r=2M(v)$ 定义的超曲面上计算这些膨胀率的值。\n$$\n\\theta_{(\\ell)}\\bigg|_{r=2M(v)} = \\frac{1}{2M(v)}\\left(1 - \\frac{2M(v)}{2M(v)}\\right) = \\frac{1}{2M(v)}(1 - 1) = 0\n$$\n$$\n\\theta_{(n)}\\bigg|_{r=2M(v)} = -\\frac{2}{2M(v)} = -\\frac{1}{M(v)}\n$$\n边缘被困管的条件是它由一些曲面叶构成，在这些曲面上，向外零膨胀率为零（$\\theta_{(\\ell)}=0$），而向内零膨胀率为负（$\\theta_{(n)} < 0$）。由于 $M(v)$ 是一个非减的质量函数，我们假设 $M(v)>0$，因此 $\\theta_{(n)} < 0$。我们的结果证实了超曲面 $r=2M(v)$ 确实是一个边缘被困管（具体来说，是一个边缘外被困管，它是一种动力学视界）。\n\n两个计算出的膨胀率的有序对是 $\\left(0, -\\frac{1}{M(v)}\\right)$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0  -\\frac{1}{M(v)} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "超越几何定义，动力学视界的物理学由通量定律主导。本练习  提供了一个动手实践的机会，让学生能够数值验证黑洞力学第一定律的瞬时形式，该定律将视界面积的变化与物质和引力波能量的流入联系起来。这项实践是连接理论与计算验证的重要桥梁。",
            "id": "3472226",
            "problem": "你的任务是通过比较由独立定义构建的两个局域于时间的速率，来检验一个未来外捕获视界上的瞬时第一定律平衡。在 $G=c=1$ 的几何单位制下工作。所有角度均以弧度为单位。请实现一个程序，针对每个给定的案例，计算叶状剖分参数 $v$ 的两个函数：(i) 使用面积 $A(v)$ 的数值导数计算乘积 $Q_1(v) = \\left(\\kappa(v)/8\\pi\\right)\\, dA/dv$，以及 (ii) 从下文定义的通量积分中获得的速率 $Q_2(v) = dE_{\\mathrm{H}}/dv$。然后，为每个案例返回在给定的 $v$ 网格上的最大绝对不匹配度 $\\max_v |Q_1(v)-Q_2(v)|$。\n\n你的工作应仅基于以下基本定义和事实：\n- 面积半径为 $R(v)$ 的球面的横截面积为 $A(v)=4\\pi R(v)^2$。\n- 沿视界叶状剖分的表面引力由一个给定的函数 $v\\mapsto \\kappa(v)$ 给出。\n- 沿视界的瞬时能量累积率由通量积分定义\n  $$\\frac{dE_{\\mathrm{H}}}{dv}(v) = \\int_{S_v} \\mu(\\theta,\\phi;v)\\, dS + \\frac{1}{16\\pi}\\int_{S_v} \\|\\sigma\\|^2(\\theta,\\phi;v)\\, dS,$$\n  其中 $\\mu(\\theta,\\phi;v)$ 是物质能量密度 $\\mu=T_{ab}\\,\\ell^a n^b$，$\\|\\sigma\\|^2(\\theta,\\phi;v)$ 是出射零法向量的剪切的范数平方，球面横截面上的面积元为 $dS = R(v)^2 \\sin\\theta\\, d\\theta\\, d\\phi$。\n- 数值导数 $dA/dv$ 必须根据样本 $A(v_i)$ 计算，内部点使用二阶中心差分，端点使用一阶单边差分。\n\n你的程序必须为以下三个案例计算上述量。在所有案例中，使用相同的角向求积法则：在具有 $N_\\theta=64$ 个极向样本和 $N_\\phi=96$ 个方位向样本的球面网格上使用张量积中点法则。即，令 $\\Delta\\theta=\\pi/N_\\theta$，$\\Delta\\phi=2\\pi/N_\\phi$，并对 $i=0,\\dots,N_\\theta-1$ 取样 $\\theta_i = (i+\\tfrac{1}{2})\\Delta\\theta$，对 $j=0,\\dots,N_\\phi-1$ 取样 $\\phi_j = (j+\\tfrac{1}{2})\\Delta\\phi$。通过权重为 $R(v)^2 \\sin\\theta_i \\Delta\\theta \\Delta\\phi$ 的加权和来近似积分。\n\n在每个案例中，物质和引力波通量密度的角向依赖性是通过在球面上平均值为1的正值形状函数来规定的。具体来说，定义原始形状\n$$G_0(\\theta,\\phi;v) = \\left[1 + a_2(v) P_2(\\cos\\theta) + a_3(v) P_3(\\cos\\theta) + a_4(v) P_4(\\cos\\theta) + b(v)\\,\\sin(m\\phi)\\,\\sin^2\\theta\\right]^2,$$\n$$H_0(\\theta,\\phi;v) = \\left[1 + c_1(v)\\cos\\theta + c_2(v)\\,\\sin^2\\theta\\cos(m'\\phi)\\right]^2,$$\n其中 Legendre 多项式为 $P_2(x)=\\tfrac{1}{2}(3x^2-1)$，$P_3(x)=\\tfrac{1}{2}(5x^3-3x)$ 和 $P_4(x)=\\tfrac{1}{8}(35x^4-30x^2+3)$。使用上述数值求积法将它们归一化，使其在球面上的平均值为1：\n$$g(\\theta,\\phi;v) = \\frac{G_0(\\theta,\\phi;v)}{\\langle G_0\\rangle(v)}, \\quad h(\\theta,\\phi;v) = \\frac{H_0(\\theta,\\phi;v)}{\\langle H_0\\rangle(v)},$$\n其中 $\\langle X\\rangle(v) = \\frac{1}{A(v)}\\int_{S_v} X(\\theta,\\phi;v)\\, dS$。\n\n对于每个案例，物质和引力波密度则为\n$$\\mu(\\theta,\\phi;v) = M_0(v)\\, h(\\theta,\\phi;v), \\qquad \\|\\sigma\\|^2(\\theta,\\phi;v) = S_0(v)\\, g(\\theta,\\phi;v),$$\n其中 $M_0(v)$ 和 $S_0(v)$ 是下文给定的函数。\n\n案例1（真空，强畸变）：\n- 叶状剖分参数网格：$v\\in[0,10]$，在 $N_v=33$ 个点上均匀采样。\n- 面积半径：$R(v) = 5.0 + 0.4 v + 0.7 \\exp\\!\\left(-\\tfrac{1}{2}(v-6)^2\\right) + 0.05 \\sin(2.2 v)$，因此 $A(v)=4\\pi R(v)^2$。\n- 表面引力：$\\kappa(v) = 0.2 + 0.05 \\cos(0.6 v)$。\n- 物质占比：$p(v) = 0$。\n- 系数：$a_2(v)=0.9\\,\\mathrm{sech}\\!\\left(0.5\\,(v-6)\\right)$，$a_3(v)=0.5\\,\\tanh\\!\\left(0.3\\,(v-4)\\right)$，$a_4(v)=0.4\\,\\sin(1.7 v)$，$b(v)=0.8\\,\\sin(0.4 v)$，$m=3$；对于 $H_0$，设置 $c_1(v)=0.3\\,\\sin(0.9 v)$，$c_2(v)=0.2\\,\\cos(1.1 v)$，$m'=2$（这些不影响真空积分，但必须按规定构建）。\n- 振幅：令 $A'(v)$ 表示从 $R(v)$ 解析得到的 $A(v)$ 关于 $v$ 的精确导数。定义总期望通量水平 $F_{\\mathrm{tot}}(v) = \\left(\\kappa(v)/8\\pi\\right) A'(v)$。然后设置 $M_0(v)=p(v)\\,F_{\\mathrm{tot}}(v)/A(v)=0$，以及 $S_0(v) = 16\\pi\\,[1-p(v)]\\,F_{\\mathrm{tot}}(v)/A(v) = 16\\pi\\,F_{\\mathrm{tot}}(v)/A(v)$。\n\n案例2（混合物质和引力波通量，边界敏感）：\n- 叶状剖分参数网格：$v\\in[0,3]$，在 $N_v=41$ 个点上均匀采样。\n- 面积半径：$R(v) = 3.0 + 0.7 v + 0.12 \\sin(3.3 v) + 0.1 \\exp\\!\\left(-(v-1.5)^2\\right)$，因此 $A(v)=4\\pi R(v)^2$。\n- 表面引力：$\\kappa(v) = 0.35 - 0.1\\, v/(1+v)$。\n- 物质占比：$p(v) = 0.5 + 0.3 \\sin(v)$。\n- 系数：$a_2(v)=0.6\\,\\cos(0.7 v)$，$a_3(v)=0.4\\,\\sin(1.1 v)$，$a_4(v)=0.5\\,\\tanh\\!\\left(0.5 (v-1.5)\\right)$，$b(v)=0.5\\,\\cos(0.8 v)$，$m=4$；对于 $H_0$，$c_1(v)=0.4\\,\\cos(1.3 v)$，$c_2(v)=0.35\\,\\sin(1.7 v)$，$m'=3$。\n- 振幅：使用与 $R(v)$ 对应的精确导数 $A'(v)$，定义 $F_{\\mathrm{tot}}(v) = \\left(\\kappa(v)/8\\pi\\right) A'(v)$，然后 $M_0(v)=p(v)\\,F_{\\mathrm{tot}}(v)/A(v)$，以及 $S_0(v)=16\\pi\\,[1-p(v)]\\,F_{\\mathrm{tot}}(v)/A(v)$。\n\n案例3（小表面引力，强驱动）：\n- 叶状剖分参数网格：$v\\in[0,5]$，在 $N_v=37$ 个点上均匀采样。\n- 面积半径：$R(v) = 10.0 + 1.5 v + 0.15 \\sin(4.5 v) + 0.3 \\exp\\!\\left(-0.3\\,(v-2.5)^2\\right)$，因此 $A(v)=4\\pi R(v)^2$。\n- 表面引力：$\\kappa(v) = 0.05 + 0.02 \\cos(1.8 v)$。\n- 物质占比：$p(v) = 0.2 + 0.2 \\sin(0.7 v)$。\n- 系数：$a_2(v)=0.7\\,\\mathrm{sech}\\!\\left(0.4\\,(v-2.5)\\right)$，$a_3(v)=0.5\\,\\cos(1.2 v)$，$a_4(v)=0.6\\,\\sin(1.9 v)$，$b(v)=0.7\\,\\sin(0.9 v)$，$m=5$；对于 $H_0$，$c_1(v)=0.25\\,\\sin(0.8 v)$，$c_2(v)=0.3\\,\\cos(1.4 v)$，$m'=4$。\n- 振幅：使用与 $R(v)$ 对应的精确导数 $A'(v)$，定义 $F_{\\mathrm{tot}}(v) = \\left(\\kappa(v)/8\\pi\\right) A'(v)$，然后 $M_0(v)=p(v)\\,F_{\\mathrm{tot}}(v)/A(v)$，以及 $S_0(v)=16\\pi\\,[1-p(v)]\\,F_{\\mathrm{tot}}(v)/A(v)$。\n\n实现要求：\n- 对于每个案例，在采样的 $A(v_i)$ 值上使用指定的有限差分计算 $Q_1(v_i) = \\left(\\kappa(v_i)/8\\pi\\right) \\left.dA/dv\\right|_{v_i}$。\n- 对于每个案例，通过使用规定的求积法对通量密度进行数值积分来计算 $Q_2(v_i)$，以评估 $dE_{\\mathrm{H}}/dv(v)$ 定义中的两个积分。\n- 对于每个案例，计算单个标量\n  $$\\mathrm{mismatch} = \\max_i \\left| Q_1(v_i) - Q_2(v_i) \\right|,$$\n  以几何单位制下的浮点数形式报告（输出中无单位符号；在 $G=c=1$ 单位制中数值是纯数）。\n- 你的程序应生成单行输出，包含三个案例的结果，格式为方括号内用逗号分隔的列表，例如 $[x_1,x_2,x_3]$，其中每个 $x_k$ 是案例 $k$ 的不匹配度。\n\n测试套件覆盖理由：\n- 案例1考察了具有强时变角向结构的真空、剪切主导的情形。\n- 案例2包含非零物质通量，并要求在 $v$ 网格端点正确处理边界有限差分。\n- 案例3探测了强驱动下的小表面引力情况，以确保在 $A'(v)$ 较大而 $\\kappa(v)$ 较小时的数值稳定性。\n\n所有数值必须按规定以 $G=c=1$ 的几何单位制报告，角度以弧度为单位。输出必须是严格符合 $[x_1,x_2,x_3]$ 格式的单行文本。",
            "solution": "用户提供了一个位于数值相对论领域的计算问题，涉及验证未来外捕获视界（FOTH）（也称为动力学视界）的力学第一定律。该问题是适定的，有科学依据，并包含了推导唯一、可验证解所需的所有信息。它代表了一项数值验证任务，通过比较两个量来检验一个物理定律，其中一个量通过数值微分计算，另一个通过数值积分计算。问题设置的设计使得任何差异主要源于数值导数的截断误差。\n\n问题的核心是为三个指定场景中的每一个计算并比较两个变化率。设 $v$ 是一个参数，用于叶状剖分视界的一系列球面横截面。\n\n第一个量 $Q_1(v)$ 是基于视界面积膨胀的能量变化率的近似。其定义为：\n$$Q_1(v) = \\frac{\\kappa(v)}{8\\pi} \\frac{dA}{dv}$$\n此处，$\\kappa(v)$ 是给定的表面引力，$A(v) = 4\\pi R(v)^2$ 是视界的横截面积，其中 $R(v)$ 是指定的面积半径。导数 $dA/dv$ 是从均匀网格 $v_i$ 上的一组离散样本 $A(v_i)$ 数值计算得出的。根据问题规范，网格的内部点使用二阶中心差分方案，两个端点使用一阶单边差分。这可以使用 `numpy.gradient` 并设置 `edge_order=1` 来高效实现。\n\n第二个量 $Q_2(v)$ 代表能量累积率，定义为穿过视界的物质和引力波的总通量。其定义由曲面积分给出：\n$$Q_2(v) = \\frac{dE_{\\mathrm{H}}}{dv}(v) = \\int_{S_v} \\mu(\\theta,\\phi;v)\\, dS + \\frac{1}{16\\pi}\\int_{S_v} \\|\\sigma\\|^2(\\theta,\\phi;v)\\, dS$$\n其中 $\\mu$ 是物质能量密度，$\\|\\sigma\\|^2$ 是代表引力波能量通量的出射零法向量剪切的范数平方。积分是在球面横截面 $S_v$ 上进行的，面积元为 $dS = R(v)^2 \\sin\\theta\\, d\\theta\\, d\\phi$。\n\n问题为通量密度 $\\mu$ 和 $\\|\\sigma\\|^2$ 提供了详细的规定。它们由振幅函数 $M_0(v)$ 和 $S_0(v)$ 以及归一化的角向形状函数 $g(\\theta,\\phi;v)$ 和 $h(\\theta,\\phi;v)$ 构建而成：\n$$\\mu(\\theta,\\phi;v) = M_0(v)\\, h(\\theta,\\phi;v), \\qquad \\|\\sigma\\|^2(\\theta,\\phi;v) = S_0(v)\\, g(\\theta,\\phi;v)$$\n形状函数 $g$ 和 $h$ 是通过将原始形状 $G_0$ 和 $H_0$ 归一化以使其在球面上具有单位平均值而得到的。平均值定义为 $\\langle X\\rangle(v) = \\frac{1}{A(v)}\\int_{S_v} X dS$。归一化和 $Q_2(v)$ 的最终计算所需的积分都将使用指定的球面网格 $(\\theta_i, \\phi_j)$ 上的张量积中点法则进行数值计算。\n\n问题设计的一个关键方面是振幅 $M_0(v)$ 和 $S_0(v)$ 的定义方式。它们依赖于总通量 $F_{\\mathrm{tot}}(v) = (\\kappa(v)/8\\pi) A'(v)$，其中 $A'(v)$ 是面积函数 $A(v)$ 的**精确解析**导数。然后将振幅设置为 $M_0(v) = p(v)F_{\\mathrm{tot}}(v)/A(v)$ 和 $S_0(v) = 16\\pi[1-p(v)]F_{\\mathrm{tot}}(v)/A(v)$，其中 $p(v)$ 是给定的物质占比。将这些代入 $Q_2(v)$ 的定义中，并利用归一化形状函数对面积 $A(v)$ 积分（即 $\\int_S g dS = \\int_S h dS = A(v)$）这一事实，我们发现：\n$$Q_2(v) = M_0(v)A(v) + \\frac{1}{16\\pi}S_0(v)A(v) = p(v)F_{\\mathrm{tot}}(v) + [1-p(v)]F_{\\mathrm{tot}}(v) = F_{\\mathrm{tot}}(v)$$\n因此，$Q_2(v)$ 在解析上与 $(\\kappa(v)/8\\pi)A'_{\\text{exact}}(v)$ 完全相同。\n\n最终任务是计算两个数值计算量之间的最大绝对不匹配度：\n$$\\mathrm{mismatch} = \\max_i | Q_1(v_i) - Q_2(v_i) |$$\n这种不匹配度主要量化了在 $Q_1(v)$ 中使用有限差分近似 $dA/dv$ 所引入的误差，与 $Q_2(v)$ 的值相比，后者被构建为在数值上非常接近精确的解析表达式。在给定精细的角向网格的情况下，$Q_2$ 计算中的任何微小偏差都将归因于角向求积的浮点精度，预计这比导数的截断误差小得多。\n\n对于每个案例，算法流程如下：\n1.  定义所有特定案例的函数（$R(v)$、$R'(v)$、$\\kappa(v)$等）和参数。\n2.  生成均匀的时间网格 $v_i$。\n3.  计算每个网格点上的面积 $A(v_i)$。\n4.  使用 `numpy.gradient` 计算数值导数 $(dA/dv)_i$，然后计算数组 $Q_1(v_i)$。\n5.  设置角向求积网格 $(\\theta_i, \\phi_j)$ 及相关权重。\n6.  遍历每个时间步 $v_i$：\n    a.  在角向网格上计算角向形状函数 $G_0$ 和 $H_0$。\n    b.  数值计算它们的平均值 $\\langle G_0 \\rangle$ 和 $\\langle H_0 \\rangle$ 并将其归一化以得到 $g$ 和 $h$。\n    c.  计算解析导数 $A'(v_i) = 8\\pi R(v_i) R'(v_i)$。\n    d.  确定振幅 $M_0(v_i)$ 和 $S_0(v_i)$。\n    e.  在角向网格上构建通量密度 $\\mu$ 和 $\\|\\sigma\\|^2$。\n    f.  对通量进行数值积分以求得 $Q_2(v_i)$。\n7.  计算 $Q_1$ 和 $Q_2$ 数组之间的最大绝对差。\n\n对所有三个案例重复此过程，以获得最终的不匹配度值列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum mismatch between two calculations of horizon energy flux\n    for three distinct test cases in numerical relativity.\n    \"\"\"\n\n    def P2(x):\n        return 0.5 * (3 * x**2 - 1)\n\n    def P3(x):\n        return 0.5 * (5 * x**3 - 3 * x)\n\n    def P4(x):\n        return 0.125 * (35 * x**4 - 30 * x**2 + 3)\n\n    def sech(x):\n        return 1.0 / np.cosh(x)\n\n    # Define the three cases with all their specific parameters and functions.\n    test_cases = [\n        # Case 1: Vacuum, strong distortions\n        {\n            \"v_range\": [0, 10], \"N_v\": 33,\n            \"R\": lambda v: 5.0 + 0.4 * v + 0.7 * np.exp(-0.5 * (v - 6)**2) + 0.05 * np.sin(2.2 * v),\n            \"R_prime\": lambda v: 0.4 - 0.7 * (v - 6) * np.exp(-0.5 * (v - 6)**2) + 0.05 * 2.2 * np.cos(2.2 * v),\n            \"kappa\": lambda v: 0.2 + 0.05 * np.cos(0.6 * v),\n            \"p\": lambda v: 0.0,\n            \"a2\": lambda v: 0.9 * sech(0.5 * (v - 6)),\n            \"a3\": lambda v: 0.5 * np.tanh(0.3 * (v - 4)),\n            \"a4\": lambda v: 0.4 * np.sin(1.7 * v),\n            \"b\": lambda v: 0.8 * np.sin(0.4 * v), \"m\": 3,\n            \"c1\": lambda v: 0.3 * np.sin(0.9 * v),\n            \"c2\": lambda v: 0.2 * np.cos(1.1 * v), \"m_prime\": 2,\n        },\n        # Case 2: Mixed flux, boundary-sensitive\n        {\n            \"v_range\": [0, 3], \"N_v\": 41,\n            \"R\": lambda v: 3.0 + 0.7 * v + 0.12 * np.sin(3.3 * v) + 0.1 * np.exp(-(v - 1.5)**2),\n            \"R_prime\": lambda v: 0.7 + 0.12 * 3.3 * np.cos(3.3 * v) - 0.2 * (v - 1.5) * np.exp(-(v - 1.5)**2),\n            \"kappa\": lambda v: 0.35 - 0.1 * v / (1 + v),\n            \"p\": lambda v: 0.5 + 0.3 * np.sin(v),\n            \"a2\": lambda v: 0.6 * np.cos(0.7 * v),\n            \"a3\": lambda v: 0.4 * np.sin(1.1 * v),\n            \"a4\": lambda v: 0.5 * np.tanh(0.5 * (v - 1.5)),\n            \"b\": lambda v: 0.5 * np.cos(0.8 * v), \"m\": 4,\n            \"c1\": lambda v: 0.4 * np.cos(1.3 * v),\n            \"c2\": lambda v: 0.35 * np.sin(1.7 * v), \"m_prime\": 3,\n        },\n        # Case 3: Small surface gravity, strong driving\n        {\n            \"v_range\": [0, 5], \"N_v\": 37,\n            \"R\": lambda v: 10.0 + 1.5 * v + 0.15 * np.sin(4.5 * v) + 0.3 * np.exp(-0.3 * (v - 2.5)**2),\n            \"R_prime\": lambda v: 1.5 + 0.15 * 4.5 * np.cos(4.5 * v) - 0.18 * (v - 2.5) * np.exp(-0.3 * (v - 2.5)**2),\n            \"kappa\": lambda v: 0.05 + 0.02 * np.cos(1.8 * v),\n            \"p\": lambda v: 0.2 + 0.2 * np.sin(0.7 * v),\n            \"a2\": lambda v: 0.7 * sech(0.4 * (v - 2.5)),\n            \"a3\": lambda v: 0.5 * np.cos(1.2 * v),\n            \"a4\": lambda v: 0.6 * np.sin(1.9 * v),\n            \"b\": lambda v: 0.7 * np.sin(0.9 * v), \"m\": 5,\n            \"c1\": lambda v: 0.25 * np.sin(0.8 * v),\n            \"c2\": lambda v: 0.3 * np.cos(1.4 * v), \"m_prime\": 4,\n        }\n    ]\n\n    def solve_case(params):\n        # 1. Setup grids\n        v_grid = np.linspace(params[\"v_range\"][0], params[\"v_range\"][1], params[\"N_v\"])\n        dv = v_grid[1] - v_grid[0]\n        \n        N_theta, N_phi = 64, 96\n        d_theta = np.pi / N_theta\n        d_phi = 2 * np.pi / N_phi\n        theta = (np.arange(N_theta) + 0.5) * d_theta\n        phi = (np.arange(N_phi) + 0.5) * d_phi\n        THETA, PHI = np.meshgrid(theta, phi, indexing='ij')\n\n        # 2. Compute Q1(v)\n        R_v = params[\"R\"](v_grid)\n        A_v = 4 * np.pi * R_v**2\n        kappa_v = params[\"kappa\"](v_grid)\n        \n        dA_dv_numerical = np.gradient(A_v, dv, edge_order=1)\n        Q1 = (kappa_v / (8 * np.pi)) * dA_dv_numerical\n\n        # 3. Compute Q2(v)\n        Q2 = np.zeros_like(v_grid)\n        \n        costheta = np.cos(THETA)\n        sintheta = np.sin(THETA)\n        P2_grid = P2(costheta)\n        P3_grid = P3(costheta)\n        P4_grid = P4(costheta)\n        d_area_element = sintheta * d_theta * d_phi\n\n        for i, v in enumerate(v_grid):\n            # Evaluate coefficients at current v\n            a2, a3, a4, b = params[\"a2\"](v), params[\"a3\"](v), params[\"a4\"](v), params[\"b\"](v)\n            c1, c2 = params[\"c1\"](v), params[\"c2\"](v)\n            m, m_prime = params[\"m\"], params[\"m_prime\"]\n\n            # Compute raw shape functions G0, H0\n            G0 = (1 + a2*P2_grid + a3*P3_grid + a4*P4_grid + b*np.sin(m*PHI)*sintheta**2)**2\n            H0 = (1 + c1*costheta + c2*(sintheta**2)*np.cos(m_prime*PHI))**2\n\n            # Compute normalization factors\n            avg_G0 = (1 / (4 * np.pi)) * np.sum(G0 * d_area_element)\n            avg_H0 = (1 / (4 * np.pi)) * np.sum(H0 * d_area_element)\n            \n            # Normalized shape functions\n            g = G0 / avg_G0\n            h = H0 / avg_H0\n\n            # Compute flux amplitudes M0, S0\n            R_i = R_v[i]\n            # A_i = A_v[i]\n            # using R_i simplifies the expression below and avoids re-accessing A_v array\n            A_i = 4 * np.pi * R_i**2\n            \n            Rp_i = params[\"R_prime\"](v)\n            A_prime_exact = 8 * np.pi * R_i * Rp_i\n            kappa_i = kappa_v[i]\n            p_i = params[\"p\"](v)\n\n            F_tot = (kappa_i / (8 * np.pi)) * A_prime_exact\n            M0 = p_i * F_tot / A_i\n            S0 = 16 * np.pi * (1 - p_i) * F_tot / A_i\n\n            # Construct flux densities on the grid\n            mu = M0 * h\n            sigma_sq = S0 * g\n            \n            # Compute flux integrals for Q2\n            integral_mu_dS = np.sum(mu * R_i**2 * d_area_element)\n            integral_sigma_sq_dS = np.sum(sigma_sq * R_i**2 * d_area_element)\n            \n            Q2[i] = integral_mu_dS + (1 / (16 * np.pi)) * integral_sigma_sq_dS\n            \n        # 4. Compute mismatch\n        mismatch = np.max(np.abs(Q1 - Q2))\n        return mismatch\n\n    results = [solve_case(case) for case in test_cases]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "动力学视界的“质量”有多种定义方式，每种定义都具有不同的属性。这最后一个练习  要求你对三种主要的准局域质量定义进行数值比较。通过检验它们与能量平衡定律及渐近能量收支的一致性，你将深入了解引力物理学中的一个实际问题：在动态情况下，哪种质量定义在物理上最为稳健。",
            "id": "3472235",
            "problem": "你需要编写一个完整的、自包含的程序，该程序针对一组动态视界（DH）的综合但科学一致的场景，计算并比较沿同一DH的三种准局域质量定义，并确定哪一种与平衡定律和渐近收支的吻合度最高。需要比较的三种准局域质量定义是：霍金质量、布朗-约克质量和动力学视界质量。\n\n所有计算都必须在几何单位制中进行，其中$G = c = 1$，因此质量、长度和时间共享相同的单位。\n\n动力学视界表示为一个由高级时间坐标$v$参数化的边缘外陷曲面（MOTS）组成的世界管。离散的几何形状和通量数据以在$v$的均匀网格上采样的函数形式提供。\n\n对于每个测试用例，你的程序必须：\n- 为$v$、MOTS的面积$A(v)$、角动量$J(v)$以及一个在圆球面空间嵌入模型中控制布朗-约克质量的无量纲切片相关因子$\\zeta(v)$构建离散数组。\n- 为穿过DH的引力能流密度（通过剪切平方的面积分编码）和物质能流密度构建离散数组，然后根据动力学视界平衡定律将它们组合成总通量。\n- 根据三种定义中的每一种计算沿DH的准局域质量：霍金质量、布朗-约克质量（使用带有$\\zeta(v)$参数的圆球面模型）和动力学视界质量（包括自旋）。\n- 对每种质量定义，评估两个诊断指标：\n  1. 平衡定律偏差，定义为在初始和最终$v$之间该准局域质量的净变化与在$v$区间上总通量的积分之间的绝对不匹配。\n  2. 渐近收支残差，定义为最终准局域质量加上规定的总辐射能量与该测试用例在空间无穷远处的阿诺维特-德泽尔-米斯纳（ADM）质量之间的绝对不匹配。\n- 将这两个诊断指标组合成一个单一的正误差度量（你可以使用每个非负诊断指标的任何严格递增函数；为明确起见，使用这两个诊断指标的欧几里得范数），并选择最小化此度量的质量定义的索引。\n\n你必须为三种准局域质量定义采用以下索引映射：\n- $0$：霍金质量，\n- $1$：布朗-约克质量，\n- $2$：动力学视界质量。\n\n你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如$[2,0,1]$，其中每个条目是对应测试用例所选的索引。\n\n基础和约束：\n- 从动力学视界（DH）作为由边缘外陷曲面（MOTS）叶构成的类空超曲面的定义出发，并使用面积$A(v)$和角动量$J(v)$来构建面积半径$R(v)$和其他准局域量。\n- 使用与2-曲面相关联的准局域质量的概念，以及关于动力学视界平衡定律的基本事实，该定律将一个合适的质量泛函的变化等同于穿过DH的物质和引力能通量之和。\n- 不要在问题陈述中假设任何预先指定的目标质量或通量公式；在你的解决方案中从第一性原理推导它们。\n\n单位：\n- 所有量都应在几何单位制中处理，其中$G = c = 1$。因此，$A(v)$的单位是$[\\text{长度}]^2$，$J(v)$的单位是$[\\text{长度}]^2$，质量的单位是$[\\text{长度}]$。\n\n角度单位：\n- 测试套件场景中不使用角度。\n\n百分比：\n- 问题中不出现百分比；任何分数都应表示为小数。\n\n测试套件：\n你的程序必须评估以下三个测试用例。在每个案例中，使用一个包含$6$个点的$v$值的均匀网格：$v \\in \\{0.0, 0.2, 0.4, 0.6, 0.8, 1.0\\}$。\n\n对于每个测试用例，按如下方式构建数组。设$M_{\\mathrm{irr}}(v)$表示与面积$A(v)$相关的不可约质量，$J(v)$为角动量，$\\zeta(v)$为无量纲的布朗-约克嵌入因子。\n\n- 测试用例1（一般的缓慢演化的轴对称DH；通量被构造成与动力学视界平衡定律一致）：\n  - $M_{\\mathrm{irr}}(v) = 2.00 + 0.10\\,v$,\n  - $J(v) = 1.20 - 0.40\\,v$,\n  - $\\zeta(v) = 0.10 + 0.01\\,v$,\n  - $E_{\\mathrm{rad}} = 0.15$,\n  - 构建引力剪切平方的面积分和物质流入，使得总通量等于此场景下动力学视界平衡定律预测的变化，并对每个密度施加一个振幅为$10^{-3}$的微小加性噪声以确保数值真实性。\n  - 对于此情况，将$M_{\\mathrm{ADM}}$定义为与通量一致的质量定义的最终质量与$E_{\\mathrm{rad}}$之和。\n\n- 测试用例2（具有消失通量的近平衡边界情况）：\n  - $M_{\\mathrm{irr}}(v) = 2.50$,\n  - $J(v) = 0.00$,\n  - $\\zeta(v) = 0.05$,\n  - $E_{\\mathrm{rad}} = 0.00$,\n  - 对所有$v$，将引力剪切平方的面积分和物质流入恒定地设置为零（总通量消失），\n  - 对于此情况，将$M_{\\mathrm{ADM}}$定义为与通量一致的质量定义（其为常数）的最终质量与$E_{\\mathrm{rad}}$之和。\n\n- 测试用例3（具有外曲率变化的高度动态情况；通量被构造成与为圆球面建模的布朗-约克平衡一致）：\n  - $M_{\\mathrm{irr}}(v) = 1.80 + 0.05\\,v$,\n  - $J(v) = 0.50 - 0.20\\,v$,\n  - $\\zeta(v) = 0.20 - 0.05\\,v$,\n  - $E_{\\mathrm{rad}} = 0.10$,\n  - 构建引力剪切平方的面积分和物质流入，使得总通量等于此场景下布朗-约克圆球面模型预测的变化，并对每个密度施加一个振幅为$10^{-3}$的微小加性噪声以确保数值真实性。\n  - 对于此情况，将$M_{\\mathrm{ADM}}$定义为与通量一致的质量定义的最终质量与$E_{\\mathrm{rad}}$之和。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由三个整数组成的列表，每个测试用例一个，使用上面的索引映射，用方括号括起来并用逗号分隔（例如，$[2,0,1]$）。",
            "solution": "该问题要求在一组综合测试场景中，对动力学视界（DH）的三种准局域质量定义进行比较分析。目标是确定哪种质量定义在根据视界通量平衡定律和时空的渐近能量收支进行评估时，能提供最一致的描述。该分析将在一个数值环境中进行，使用在离散时间网格上采样的数据。所有计算都在几何单位制中执行，其中引力常数$G$和光速$c$被设为单位一，即$G=c=1$。\n\n待评估的三种准局域质量定义是霍金质量（索引0）、布朗-约克质量（索引1）和动力学视界质量（索引2）。\n\n对每个测试用例，程序的核心步骤如下：\n1.  在一个均匀的高级时间$v$网格上，离散化给定的不可约质量$M_{\\mathrm{irr}}(v)$、角动量$J(v)$和布朗-约克因子$\\zeta(v)$的连续函数。\n2.  根据这些基本量，计算三种准局域质量$M_k(v)$随时间的演化。\n3.  构建穿过视界的总能流密度$F(v)$。此通量被设计为与特定“目标”质量定义的平衡定律一致，并包含一个现实的噪声分量。\n4.  对三种质量定义中的每一种，计算两个诊断度量：平衡定律偏差和渐近收支残差。\n5.  将这两个诊断度量组合成一个单一的误差度量，并确定最小化此误差的质量定义。\n\n让我们详细定义这些量和算法。\n\n**1. 准局域质量定义**\n\n动力学视界是由边缘外陷曲面（MOTS）叶构成的，每个曲面都由其面积$A$和角动量$J$来表征。面积半径为$R = \\sqrt{A/(4\\pi)}$，不可约质量为$M_{\\mathrm{irr}} = \\sqrt{A/(16\\pi)} = R/2$。问题提供了$M_{\\mathrm{irr}}(v)$，我们以此为基本构建块。\n\n- **霍金质量（$M_H$，索引0）**：\n  霍金质量为一个2-曲面定义为$M_H = \\sqrt{A/(16\\pi)}$。因此，它与不可约质量相同。\n  $$ M_H(v) = M_{\\mathrm{irr}}(v) $$\n\n- **布朗-约克质量（$M_{BY}$，索引1）**：\n  布朗-约克质量取决于2-曲面在空间超曲面中的嵌入方式。问题提供了一个简化模型，其中这种依赖性由一个无量纲因子$\\zeta(v)$在一个圆球面参考框架内捕获。一个自然的定义是对霍金质量的修正：\n  $$ M_{BY}(v) = M_H(v) \\left(1 + \\zeta(v)\\right) = M_{\\mathrm{irr}}(v) \\left(1 + \\zeta(v)\\right) $$\n\n- **动力学视界质量（$M_{DH}$，索引2）**：\n  这个质量定义将静态克尔黑洞的质量-能量-角动量关系推广到一个准局域的、动力学的语境中。它由下式给出：\n  $$ M_{DH}(v) = \\sqrt{M_{\\mathrm{irr}}(v)^2 + \\frac{J(v)^2}{4 M_{\\mathrm{irr}}(v)^2}} $$\n  这个公式可以看作是，如果一个克尔黑洞的面积和角动量与给定时间$v$的MOTS相匹配，它所具有的质量。\n\n**2. 通量构建与平衡定律**\n\n动力学视界形式主义包含一个平衡定律，它将质量的变化与穿过视界的能量通量联系起来。总通量包括引力能（以引力波形式辐射）和任何落入黑洞的物质能。问题指明，对于每个测试用例，总通量被构建为与某个特定“目标”质量定义$M_{\\text{target}}(v)$的变化率一致。\n\n理想通量密度为$F_{\\text{ideal}}(v) = \\frac{d M_{\\text{target}}(v)}{dv}$。我们使用二阶有限差分格式（内部点使用中心差分，边界点使用单边差分）从数组$M_{\\text{target}}(v_i)$数值计算这个导数。\n\n为了模拟数值噪声，总通量密度$F(v)$由两个分量（引力和物质）构成，每个分量都添加了随机噪声。我们将其建模为：\n$$ F_{\\text{ideal}}(v) = \\frac{dM_{\\text{target}}}{dv} $$\n引力通量密度分量为$F_{\\text{grav}}(v) = \\frac{1}{2} F_{\\text{ideal}}(v) + \\delta_1(v)$，物质通量密度分量为$F_{\\text{matter}}(v) = \\frac{1}{2} F_{\\text{ideal}}(v) + \\delta_2(v)$，其中$\\delta_1$和$\\delta_2$是在$[-\\epsilon, \\epsilon]$（$\\epsilon = 10^{-3}$）上均匀分布的独立随机变量。总通量密度则为：\n$$ F(v) = F_{\\text{grav}}(v) + F_{\\text{matter}}(v) = F_{\\text{ideal}}(v) + \\delta_1(v) + \\delta_2(v) $$\n对于测试用例2，通量被指定为恒等于零，因此$F(v) = 0$。\n\n**3. 诊断度量**\n\n我们使用两个诊断度量来评估每种质量定义$M_k(v)$（其中$k \\in \\{0, 1, 2\\}$）。这需要将总通量密度$F(v)$在时间区间$[v_0, v_f]$上积分。我们使用梯形法则进行数值积分：\n$$ \\mathcal{F}_{\\text{total}} = \\int_{v_0}^{v_f} F(v) dv \\approx \\sum_{i=0}^{N-2} \\frac{F(v_i) + F(v_{i+1})}{2} \\Delta v $$\n其中$N$是网格点数，$\\Delta v$是步长。\n\n- **诊断1：平衡定律偏差（$D_{BL}$）**\n  这个度量衡量了给定质量定义对通量平衡定律的违反程度。它是质量的净变化$\\Delta M_k = M_k(v_f) - M_k(v_0)$与总积分通量之间的绝对差。\n  $$ D_{BL}(k) = \\left| \\Delta M_k - \\mathcal{F}_{\\text{total}} \\right| $$\n\n- **诊断2：渐近收支残差（$D_{AB}$）**\n  这个度量衡量了最终状态（最终准局域质量加上辐射到无穷远的总能量$E_{\\text{rad}}$）与时空的总初始质量，即阿诺维特-德泽尔-米斯纳（ADM）质量$M_{\\text{ADM}}$的匹配程度。\n  $$ D_{AB}(k) = \\left| M_k(v_f) + E_{\\mathrm{rad}} - M_{\\mathrm{ADM}} \\right| $$\n  对于每个测试用例，$M_{\\text{ADM}}$被自洽地定义，使得对于用于构建通量的目标质量定义，此残差为零（在加入噪声前）。\n\n**4. 误差度量与选择**\n\n这两个非负诊断度量被组合成一个单一的误差度量$\\mathcal{E}_k$，定义为它们的欧几里得范数：\n$$ \\mathcal{E}_k = \\sqrt{D_{BL}(k)^2 + D_{AB}(k)^2} $$\n对于每个测试用例，我们计算$\\mathcal{E}_0$、$\\mathcal{E}_1$和$\\mathcal{E}_2$。产生最小误差的质量定义，$k^* = \\arg\\min_k \\mathcal{E}_k$，被选为该用例的获胜者。最终输出是这些获胜索引的列表。",
            "answer": "```python\nimport numpy as np\n\ndef process_case(case_params):\n    \"\"\"\n    Processes a single test case to find the best-fitting quasi-local mass definition.\n\n    Args:\n        case_params (dict): A dictionary containing the parameters for the test case.\n\n    Returns:\n        int: The index (0, 1, or 2) of the mass definition that minimizes the error metric.\n    \"\"\"\n    # Unpack case parameters\n    M_irr_func = case_params[\"M_irr_func\"]\n    J_func = case_params[\"J_func\"]\n    zeta_func = case_params[\"zeta_func\"]\n    E_rad = case_params[\"E_rad\"]\n    flux_target_idx = case_params[\"flux_target_idx\"]\n    is_flux_zero = case_params.get(\"is_flux_zero\", False)\n    noise_amp = 1e-3\n\n    # 1. Construct discrete arrays for v, M_irr, J, zeta\n    v = np.linspace(0.0, 1.0, 6)\n    delta_v = v[1] - v[0]\n    \n    M_irr = M_irr_func(v)\n    J = J_func(v)\n    zeta = zeta_func(v)\n\n    # 2. Compute the three quasi-local mass arrays\n    # Index 0: Hawking mass\n    M_h = M_irr\n    # Index 1: Brown-York mass\n    M_by = M_irr * (1.0 + zeta)\n    # Index 2: Dynamical horizon mass\n    # Add a small epsilon to denominator for stability, though not needed for these cases.\n    M_dh = np.sqrt(M_irr**2 + J**2 / (4 * M_irr**2 + 1e-16))\n    \n    masses = [M_h, M_by, M_dh]\n    \n    # 3. Construct the total energy flux density array F(v)\n    if is_flux_zero:\n        F = np.zeros_like(v)\n    else:\n        M_target = masses[flux_target_idx]\n        # Use np.gradient for robust finite differencing\n        F_ideal = np.gradient(M_target, delta_v)\n        \n        # Add noise from two sources (gravitational and matter)\n        noise1 = np.random.uniform(-noise_amp, noise_amp, size=v.shape)\n        noise2 = np.random.uniform(-noise_amp, noise_amp, size=v.shape)\n        F = F_ideal + noise1 + noise2\n\n    # 4. Evaluate diagnostics for each mass definition\n    # Integrate the total flux using the trapezoidal rule\n    F_total = np.trapz(F, v)\n\n    # Define M_ADM based on the flux-consistent mass definition\n    M_flux_consistent_final = masses[flux_target_idx][-1]\n    M_adm = M_flux_consistent_final + E_rad\n    \n    errors = []\n    for k in range(3):\n        Mk = masses[k]\n        \n        # Diagnostic 1: Balance-law discrepancy\n        delta_Mk = Mk[-1] - Mk[0]\n        D_bl = np.abs(delta_Mk - F_total)\n        \n        # Diagnostic 2: Asymptotic budget residual\n        D_ab = np.abs(Mk[-1] + E_rad - M_adm)\n        \n        # Combine into a single Euclidean error metric\n        error_metric = np.sqrt(D_bl**2 + D_ab**2)\n        errors.append(error_metric)\n        \n    # 5. Find the index that minimizes the error metric\n    return np.argmin(errors)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # It is good practice to seed the random number generator for reproducibility,\n    # although not strictly required by the problem.\n    np.random.seed(42)\n\n    test_cases = [\n        # Test Case 1: General slowly evolving DH\n        {\n            \"M_irr_func\": lambda v: 2.00 + 0.10 * v,\n            \"J_func\": lambda v: 1.20 - 0.40 * v,\n            \"zeta_func\": lambda v: 0.10 + 0.01 * v,\n            \"E_rad\": 0.15,\n            \"flux_target_idx\": 2, # DH mass\n        },\n        # Test Case 2: Near-equilibrium with vanishing fluxes\n        {\n            \"M_irr_func\": lambda v: 2.50 * np.ones_like(v),\n            \"J_func\": lambda v: 0.00 * np.ones_like(v),\n            \"zeta_func\": lambda v: 0.05 * np.ones_like(v),\n            \"E_rad\": 0.00,\n            \"flux_target_idx\": 2, # DH mass, consistent with zero flux\n            \"is_flux_zero\": True,\n        },\n        # Test Case 3: Highly dynamical case\n        {\n            \"M_irr_func\": lambda v: 1.80 + 0.05 * v,\n            \"J_func\": lambda v: 0.50 - 0.20 * v,\n            \"zeta_func\": lambda v: 0.20 - 0.05 * v,\n            \"E_rad\": 0.10,\n            \"flux_target_idx\": 1, # Brown-York mass\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        winner_idx = process_case(case)\n        results.append(winner_idx)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}