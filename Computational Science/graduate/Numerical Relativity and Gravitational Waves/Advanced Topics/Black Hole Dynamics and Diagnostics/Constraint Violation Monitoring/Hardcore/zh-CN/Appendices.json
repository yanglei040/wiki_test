{
    "hands_on_practices": [
        {
            "introduction": "仅仅监测约束违反是一种被动的错误处理方式。一种更主动的策略是周期性地将数值解“投影”回满足约束的子流形上，这是维持长期演化物理有效性的强大技术。这项高级实践  将引导你体验该技术的核心步骤：通过线性化约束方程 $H(\\phi) = 0$ 来推导出一个关于修正量 $\\delta\\phi$ 的椭圆方程，并对其进行数值求解。你将看到，这样一个类似牛顿-拉夫逊方法的单步迭代，便可以显著地减少约束违反，从而亲身体验一种前沿的误差控制机制。",
            "id": "3470034",
            "problem": "考虑广义相对论（GR）中在共形分解下表述的哈密顿约束，其中共形因子中的约束违反通过椭圆求解投影到约束流形上来校正。在一个二维、平直的单位正方形域 $[0,1]\\times[0,1]$ 上的科学一致简化模型中，采用以下模仿共形Lichnerowicz型方程结构的约束泛函：\n$$\nH(\\phi) = -8\\,\\Delta \\phi + \\beta\\,\\phi^5 - S(x,y),\n$$\n其中 $\\phi$ 是共形因子，$\\Delta$ 是 $\\mathbb{R}^2$ 上的拉普拉斯算子，$\\beta \\ge 0$ 是控制非线性的常数参数，而 $S(x,y)$ 是由给定的外在曲率和物质项构造的光滑源项。在 $\\partial([0,1]\\times[0,1])$ 上施加齐次狄利克雷边界条件 $\\phi=0$。\n\n将源项定义为\n$$\nS(x,y) = A\\,\\sin(2\\pi x)\\sin(2\\pi y) + B\\,\\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2+(y-\\tfrac{1}{2})^2}{2\\sigma^2}\\right),\n$$\n参数为 $A$、$B$、$\\sigma>0$。使用每个空间维度有 $N$ 个内部点的均匀网格，因此网格间距为 $h = \\frac{1}{N+1}$，内部网格点为 $(x_i,y_j) = (ih,jh)$，其中 $i,j \\in \\{1,2,\\dots,N\\}$。\n\n令初始共形因子为\n$$\n\\phi_0(x,y) = \\varepsilon\\,\\sin(\\pi x)\\sin(\\pi y),\n$$\n参数为 $\\varepsilon \\ge 0$。目标是提出并实现一个约束投影步骤，该步骤通过求解一个从 $H(\\phi)$ 关于当前 $\\phi$ 的线性化导出的单一椭圆方程来计算校正量 $\\delta\\phi$，然后更新 $\\phi \\leftarrow \\phi + \\delta\\phi$。在此投影之后，评估哈密顿约束的离散范数的减小程度。\n\n从基本定义和原理出发，完成以下任务：\n- 通过对 $H(\\phi)$ 关于 $\\phi$ 求 Fréchet 导数，并在当前 $\\phi$ 处求值，导出作用于校正量 $\\delta\\phi$ 的线性化椭圆算子。使用此算子定义 $\\delta\\phi$ 的约束投影方程，该方程必须在网格上求解，并满足齐次狄利克雷边界条件。\n- 使用针对拉普拉斯算子的标准五点模板，在内部网格上采用二阶中心差分来离散化算子。通过在 $\\partial([0,1]\\times[0,1])$ 上的网格点强制 $\\phi=0$ 来处理边界。\n- 计算内部网格上哈密顿约束残差的离散 $L^2$ 范数，\n$$\n\\lVert H \\rVert_{h} = \\sqrt{h^2 \\sum_{i=1}^N \\sum_{j=1}^N \\left(H_{ij}\\right)^2},\n$$\n在投影步骤前后均进行计算，并报告减小比率\n$$\nr = \\frac{\\lVert H(\\phi_{\\text{after}})\\rVert_{h}}{\\lVert H(\\phi_{\\text{before}})\\rVert_{h}}.\n$$\n如果 $\\lVert H(\\phi_{\\text{before}})\\rVert_{h}$ 在数值上为零（例如，小于某个固定容差，如 $10^{-14}$），则定义 $r=0$。\n\n你的程序必须实现此投影，并为以下每个测试用例计算 $r$，这些用例涵盖了不同情况，包括线性和非线性约束、粗网格和细网格，以及不同的源项振幅。对于每个用例，使用内部网格大小 $N$、初始振幅 $\\varepsilon$、非线性参数 $\\beta$ 以及源项参数 $A$、$B$、$\\sigma$：\n\n1.  $N=32$，$\\varepsilon=0.1$，$\\beta=1.0$， $A=1.0$， $B=0.5$， $\\sigma=0.15$。\n2.  $N=8$，$\\varepsilon=0.1$，$\\beta=1.0$， $A=1.0$， $B=0.5$， $\\sigma=0.15$。\n3.  $N=32$，$\\varepsilon=0.0$，$\\beta=1.0$， $A=1.0$， $B=0.5$， $\\sigma=0.15$。\n4.  $N=32$，$\\varepsilon=0.1$，$\\beta=0.0$， $A=1.0$， $B=0.5$， $\\sigma=0.15$。\n5.  $N=64$，$\\varepsilon=0.2$，$\\beta=10.0$， $A=0.5$， $B=1.0$， $\\sigma=0.10$。\n\n你的程序应产生单行输出，其中包含五个减小比率，格式为方括号内的逗号分隔列表，每个比率表示为小数点后保留六位的小数（例如，$[0.123456,0.000001,0.987654,0.100000,0.250000]$）。此问题不涉及角度或物理单位。使用精确的浮点运算来计算范数和求解由椭圆方程产生的线性系统。通过使用适用于稀疏、对称正定系统的适当方法精确求解线性系统，来确保科学真实性。",
            "solution": "该问题要求为数值相对论中的一个简化哈密顿约束方程实现单步约束投影。此步骤等效于求解非线性椭圆偏微分方程的牛顿-拉夫逊方法的一次迭代。任务的核心是推导并离散化校正量的线性化方程，求解得到的线性系统，并评估约束违反的减小程度。\n\n首先，我们推导校正项 $\\delta\\phi$ 的椭圆方程。哈密顿约束泛函由下式给出\n$$\nH(\\phi) = -8\\,\\Delta \\phi + \\beta\\,\\phi^5 - S(x,y).\n$$\n我们给定共形因子的一个初始状态 $\\phi_0$，它不一定满足约束，即 $H(\\phi_0) \\neq 0$。我们寻求一个校正量 $\\delta\\phi$，使得新场 $\\phi = \\phi_0 + \\delta\\phi$ 是解的一个更好的近似，即 $H(\\phi_0 + \\delta\\phi) \\approx 0$。为了找到 $\\delta\\phi$，我们通过取其 Fréchet 导数将泛函 $H(\\phi)$ 在 $\\phi_0$ 周围线性化。对于小的 $\\delta\\phi$，$H(\\phi_0 + \\delta\\phi)$ 的展开式为：\n$$\nH(\\phi_0 + \\delta\\phi) = -8\\,\\Delta (\\phi_0 + \\delta\\phi) + \\beta\\,(\\phi_0 + \\delta\\phi)^5 - S(x,y).\n$$\n对非线性项使用二项式展开，$(\\phi_0 + \\delta\\phi)^5 = \\phi_0^5 + 5\\phi_0^4\\delta\\phi + \\mathcal{O}((\\delta\\phi)^2)$，并保留到 $\\delta\\phi$ 的一阶项，我们得到：\n$$\nH(\\phi_0 + \\delta\\phi) \\approx \\left(-8\\,\\Delta \\phi_0 + \\beta\\,\\phi_0^5 - S\\right) + \\left(-8\\,\\Delta(\\delta\\phi) + 5\\beta\\,\\phi_0^4\\delta\\phi\\right).\n$$\n这个表达式可以写成 $H(\\phi_0 + \\delta\\phi) \\approx H(\\phi_0) + L_{\\phi_0}[\\delta\\phi]$，其中 $L_{\\phi_0}$ 是作用于校正量 $\\delta\\phi$ 的线性化算子：\n$$\nL_{\\phi_0}[\\delta\\phi] = -8\\,\\Delta(\\delta\\phi) + 5\\beta\\,\\phi_0^4\\delta\\phi.\n$$\n约束投影方程将 $H(\\phi_0 + \\delta\\phi)$ 的线性化表达式设为零：\n$$\nL_{\\phi_0}[\\delta\\phi] = -H(\\phi_0).\n$$\n代入 $L_{\\phi_0}$ 和 $H(\\phi_0)$ 的表达式，我们得到校正量 $\\delta\\phi$ 的椭圆偏微分方程：\n$$\n-8\\,\\Delta(\\delta\\phi) + 5\\beta\\,\\phi_0^4\\,\\delta\\phi = -(-8\\,\\Delta \\phi_0 + \\beta\\,\\phi_0^5 - S) = 8\\,\\Delta \\phi_0 - \\beta\\,\\phi_0^5 + S.\n$$\n这个方程必须在单位正方形域 $[0,1]\\times[0,1]$ 上求解 $\\delta\\phi$，并满足齐次狄利克雷边界条件，即在边界 $\\partial([0,1]\\times[0,1])$ 上 $\\delta\\phi = 0$，因为总场 $\\phi$ 必须在边界上满足 $\\phi=0$，并且初始场 $\\phi_0$ 的构造已满足此条件。\n\n接下来，我们在均匀网格上离散化这个方程。该域在每个维度上用 $N$ 个内部点进行离散化，网格间距为 $h = 1/(N+1)$。内部网格点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{1, \\dots, N\\}$。函数 $f(x,y)$ 由其在此网格上的值 $f_{ij}$ 表示。我们对拉普拉斯算子 $\\Delta$ 使用二阶精度的五点模板：\n$$\n(\\Delta f)_{ij} \\approx \\frac{f_{i+1,j} + f_{i-1,j} + f_{i,j+1} + f_{i,j-1} - 4f_{ij}}{h^2}.\n$$\n将此离散化应用于每个内部点 $(i,j)$ 上的 $\\delta\\phi$ 方程，得到一个包含 $N^2$ 个线性代数方程的系统：\n$$\n-8\\frac{\\delta\\phi_{i+1,j} + \\delta\\phi_{i-1,j} + \\delta\\phi_{i,j+1} + \\delta\\phi_{i,j-1} - 4\\delta\\phi_{ij}}{h^2} + 5\\beta\\,\\phi_{0,ij}^4\\,\\delta\\phi_{ij} = -H(\\phi_0)_{ij}.\n$$\n此处，$\\delta\\phi_{ij}$ 是未知数，$\\phi_{0,ij}$ 是初始场的已知值，而 $H(\\phi_0)_{ij}$ 是原始约束的离散化残差，计算方式为\n$$\nH(\\phi_0)_{ij} = -8(\\Delta\\phi_0)_{ij} + \\beta\\,\\phi_{0,ij}^5 - S_{ij},\n$$\n其中 $(\\Delta\\phi_0)_{ij}$ 也使用五点模板计算。齐次狄利克雷边界条件通过将任何索引 $i$ 或 $j$ 等于 $0$ 或 $N+1$ 时的 $\\phi_0$ 和 $\\delta\\phi$ 设为 $0$ 来强制执行。\n\n这个方程组可以写成矩阵形式 $M \\vec{d} = \\vec{b}$，其中 $\\vec{d}$ 是一个长度为 $N^2$ 的向量，由将未知数网格 $\\delta\\phi_{ij}$ 扁平化形成，$\\vec{b}$ 是一个同样大小的向量，由将 $-H(\\phi_0)_{ij}$ 扁平化形成。矩阵 $M$ 是一个大小为 $N^2 \\times N^2$ 的稀疏、对称、正定矩阵。其结构源于离散化算子 $L_{\\phi_0}$。对角线元素是 $(\\frac{32}{h^2} + 5\\beta\\,\\phi_{0,ij}^4)$，非零的非对角线元素是 $-\\frac{8}{h^2}$，对应于网格上的四个最近邻点。由于其性质，这个线性系统可以被可靠且高效地求解 $\\vec{d}$。\n\n对于给定的参数集，计算减小比率 $r$ 的总体算法如下：\n1.  构建 $N \\times N$ 内部网格，并在每个网格点上计算初始场 $\\phi_{0,ij}$ 和源函数 $S_{ij}$。\n2.  使用填充网格来强制边界条件，计算初始场的离散拉普拉斯算子 $(\\Delta\\phi_0)_{ij}$。\n3.  计算初始哈密顿残差场 $H(\\phi_0)_{ij}$。\n4.  计算初始残差的离散 $L^2$ 范数，$\\lVert H(\\phi_0)\\rVert_h = \\sqrt{h^2 \\sum_{i,j=1}^N (H(\\phi_0)_{ij})^2}$。如果此范数小于容差 $10^{-14}$，则比率 $r$ 定义为 $0$。\n5.  否则，通过扁平化 $-H(\\phi_0)_{ij}$ 构建代表离散化线性算子 $L_{\\phi_0}$ 的 $N^2 \\times N^2$ 稀疏矩阵 $M$ 和右端向量 $\\vec{b}$。\n6.  求解线性系统 $M \\vec{d} = \\vec{b}$ 以得到扁平化的校正向量 $\\vec{d}$。\n7.  将 $\\vec{d}$ 重塑为一个代表校正量 $\\delta\\phi_{ij}$ 的 $N \\times N$ 矩阵。\n8.  计算更新后的场 $\\phi_{\\text{after}, ij} = \\phi_{0,ij} + \\delta\\phi_{ij}$。\n9.  将离散哈密顿算子应用于 $\\phi_{\\text{after}}$ 来计算最终的哈密顿残差 $H(\\phi_{\\text{after}})$。\n10. 计算最终残差的范数 $\\lVert H(\\phi_{\\text{after}})\\rVert_h$。\n11. 减小比率为 $r = \\lVert H(\\phi_{\\text{after}})\\rVert_h / \\lVert H(\\phi_0)\\rVert_h$。\n\n将此程序应用于每个测试用例，以确定约束投影步骤的有效性。对于线性情况 $\\beta=0$，预计此单步能精确求解方程，得到一个近似为零的最终残差和比率，仅受浮点精度限制。对于非线性情况，该比率量化了牛顿-拉夫逊步骤的二次收敛特性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef compute_hamiltonian(phi_interior, S_interior, beta, h, N):\n    \"\"\"Computes the discrete Hamiltonian residual H(phi).\"\"\"\n    phi_padded = np.zeros((N + 2, N + 2))\n    phi_padded[1:-1, 1:-1] = phi_interior\n    \n    # Second-order central difference for the Laplacian\n    lap_phi = (phi_padded[2:, 1:-1] + phi_padded[:-2, 1:-1] +\n               phi_padded[1:-1, 2:] + phi_padded[1:-1, :-2] -\n               4 * phi_interior) / (h**2)\n               \n    # H(phi) = -8*Delta(phi) + beta*phi^5 - S\n    H_val = -8 * lap_phi + beta * (phi_interior**5) - S_interior\n    return H_val\n\ndef compute_norm(H_val, h):\n    \"\"\"Computes the discrete L2 norm of the residual.\"\"\"\n    # norm = sqrt(h^2 * sum(H_ij^2)) = h * ||H||_Frobenius\n    return h * np.linalg.norm(H_val)\n\ndef compute_ratio_for_case(N, epsilon, beta, A, B, sigma):\n    \"\"\"\n    Solves a single test case for the constraint projection problem.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    x = np.linspace(h, 1.0 - h, N)\n    y = np.linspace(h, 1.0 - h, N)\n    xx, yy = np.meshgrid(x, y, indexing='xy')\n\n    # Define initial conformal factor phi_0 and source S on the interior grid\n    phi0_interior = epsilon * np.sin(np.pi * xx) * np.sin(np.pi * yy)\n    S_interior = A * np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy) + \\\n                 B * np.exp(-((xx - 0.5)**2 + (yy - 0.5)**2) / (2 * sigma**2))\n\n    # Calculate Hamiltonian residual and norm before projection\n    H_before = compute_hamiltonian(phi0_interior, S_interior, beta, h, N)\n    norm_before = compute_norm(H_before, h)\n\n    # Handle the case where the initial residual is numerically zero\n    if norm_before  1e-14:\n        return 0.0\n\n    # Set up the linear system M * d_phi = -H_before for the correction d_phi\n    \n    # The matrix M represents the linearized operator L = -8*Delta + 5*beta*phi_0^4\n    # We construct it using the Kronecker product for the 2D Laplacian.\n    N2 = N * N\n    # 1D Laplacian matrix (size N x N)\n    D1_matrix = diags([1, -2, 1], [-1, 0, 1], shape=(N, N))\n    I_N = identity(N)\n    \n    # 2D Laplacian matrix (size N^2 x N^2)\n    Lap_matrix_2D = (kron(I_N, D1_matrix) + kron(D1_matrix, I_N)) / h**2\n    \n    # Operator matrix M\n    M = -8 * Lap_matrix_2D\n    \n    # Add the potential term (diagonal matrix)\n    potential_term_flat = 5 * beta * (phi0_interior.flatten()**4)\n    M += diags(potential_term_flat, 0)\n    \n    # Right-hand side vector\n    b = -H_before.flatten()\n    \n    # Solve the sparse linear system for the correction d_phi\n    delta_phi_flat = spsolve(M, b)\n    delta_phi_interior = delta_phi_flat.reshape((N, N))\n    \n    # Update the field: phi_after = phi_0 + d_phi\n    phi_after_interior = phi0_interior + delta_phi_interior\n    \n    # Calculate Hamiltonian residual and norm after projection\n    H_after = compute_hamiltonian(phi_after_interior, S_interior, beta, h, N)\n    norm_after = compute_norm(H_after, h)\n    \n    # Compute the reduction ratio\n    ratio = norm_after / norm_before\n    \n    return ratio\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, epsilon, beta, A, B, sigma)\n        (32, 0.1, 1.0, 1.0, 0.5, 0.15),\n        (8, 0.1, 1.0, 1.0, 0.5, 0.15),\n        (32, 0.0, 1.0, 1.0, 0.5, 0.15),\n        (32, 0.1, 0.0, 1.0, 0.5, 0.15),\n        (64, 0.2, 10.0, 0.5, 1.0, 0.10)\n    ]\n\n    results = []\n    for case in test_cases:\n        ratio = compute_ratio_for_case(*case)\n        results.append(f\"{ratio:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "验证代码的正确性是数值模拟的基石。一种核心方法是收敛性测试，即检查当网格分辨率提高时，数值解是否以预期的速率逼近连续的真实解。这项实践  旨在通过人造解方法来验证约束违反（例如哈密顿约束 $H$ 和动量约束 $M_i$）的收敛阶，它不仅提供了计算收敛率的动手经验，还巧妙地揭示了设计验证测试时的一个常见陷阱。",
            "id": "3469971",
            "problem": "考虑广义相对论的 Arnowitt–Deser–Misner (ADM) 形式，其中哈密顿约束 $H$ 和动量约束 $M_i$ 在真空中必须为零。用微分几何的术语来说，对于真空初始数据 $(\\gamma_{ij}, K_{ij})$，哈密顿约束由 $H = R + K^2 - K_{ij} K^{ij}$ 给出，动量约束由 $M_i = \\nabla_j (K^j{}_i - \\delta^j{}_i K)$ 给出，其中 $R$ 是空间度规 $\\gamma_{ij}$ 的里奇标量，$K$ 是外部曲率 $K_{ij}$ 的迹，而 $\\nabla_j$ 是关于 $\\gamma_{ij}$ 的协变导数。在数值相对论中，通过 $L^2$ 范数等范数来监控这些约束，以评估演化的保真度和离散化的质量。对于应用于平滑数据的 $p$ 阶精度离散化，局部截断误差预计按 $\\mathcal{O}(h^p)$ 比例缩放，其中 $h$ 是网格间距，这导致残余约束的 $L^2$ 范数在渐近收敛区域内按 $h^p$ 比例缩放。\n\n为了设计一个可测试且独立的预期收敛率验证方法，而无需实现完整的曲率张量，请考虑在单位正方形域 $\\Omega = [0,1]\\times[0,1]$ 上的以下人造代理约束：\n- 令标量场 $\\phi(x,y) = x^3 - 3 x y^2$，它在二维上是调和的，因此连续拉普拉斯算子满足 $\\Delta \\phi = \\partial_{xx} \\phi + \\partial_{yy} \\phi = 0$ 对所有 $(x,y) \\in \\Omega$ 成立。\n- 令流函数 $\\psi(x,y) = x^3 - 3 x y^2$，并通过 $v_x = \\partial_y \\psi$ 和 $v_y = -\\partial_x \\psi$ 定义一个向量场 $v$，这确保了 $\\nabla \\cdot v = \\partial_x v_x + \\partial_y v_y = 0$ 对所有 $(x,y) \\in \\Omega$ 成立。\n\n这些选择产生了恒为零的连续代理约束：\n- 代理哈密顿约束 $H := \\Delta \\phi = 0$。\n- 代理动量约束 $M := \\nabla \\cdot v = 0$。\n\n当在间距为 $h$ 的均匀网格上使用 $p$ 阶有限差分逼近这些微分算子时，由于截断误差，离散残余场 $H_h$ 和 $M_h$ 不为零，它们的 $L^2$ 范数遵循\n$$\n\\|H_h\\|_{L^2(\\Omega)} \\approx C_H h^p, \\quad \\|M_h\\|_{L^2(\\Omega)} \\approx C_M h^p,\n$$\n其中常数 $C_H, C_M$ 取决于场的高阶导数。在两个网格间距为 $h_1$ 和 $h_2$、相应范数为 $E_1$ 和 $E_2$ 的网格之间，观测到的收敛阶 $\\hat{p}$ 通过以下公式估算：\n$$\n\\hat{p} = \\frac{\\ln\\left(E_1 / E_2\\right)}{\\ln\\left(h_1 / h_2\\right)}.\n$$\n\n你的任务是编写一个完整、可运行的程序，该程序能够：\n1. 在单位正方形上构建具有 $N \\times N$ 个点和间距 $h = 1/(N-1)$ 的均匀网格，用于指定的 $N$ 值。\n2. 计算解析场 $\\phi(x,y)$ 和 $v(x,y)$，其中 $v_x(x,y) = -6 x y$ 且 $v_y(x,y) = -3 x^2 + 3 y^2$。\n3. 使用指定阶数 $p_H$（用于拉普拉斯算子）和 $p_M$（用于散度）的中心有限差分，计算代理约束的离散近似值。你必须实现：\n   - 对于拉普拉斯算子 $\\Delta \\phi$，沿每个轴使用阶数 $p \\in \\{2,4\\}$ 的标准中心有限差分模板来计算二阶导数，并将它们相加形成 $\\partial_{xx} \\phi + \\partial_{yy} \\phi$。对于 $p=2$ 阶，使用三点中心模板；对于 $p=4$ 阶，使用五点中心模板，其系数可产生四阶精度。\n   - 对于散度 $\\nabla \\cdot v$，使用阶数 $p \\in \\{2,4\\}$ 的中心有限差分模板来计算一阶导数 $\\partial_x v_x$ 和 $\\partial_y v_y$，并使用相应的三点或五点模板。\n4. 排除因所需模板而点数不足的边界邻近点；在离散化有定义的内部点上计算 $L^2$ 范数。$L^2$ 范数必须按以下方式计算\n$$\n\\|f\\|_{L^2(\\Omega_{\\text{int}})} = \\left( \\sum_{(i,j) \\in \\text{interior}} f_{ij}^2 \\, h^2 \\right)^{1/2},\n$$\n其中 $\\Omega_{\\text{int}}$ 表示模板有效的内部子集。\n5. 对于一系列网格尺寸 $\\{N_k\\}$，计算间距为 $h_k = 1/(N_k-1)$ 的范数数组 $\\{\\|H_{h_k}\\|_{L^2}\\}$ 和 $\\{\\|M_{h_k}\\|_{L^2}\\}$，并使用上述公式估算每对连续的 $(k,k+1)$ 的观测阶数 $\\hat{p}_H^{(k)}$ 和 $\\hat{p}_M^{(k)}$。\n6. 实现一个自适应停止准则，当观测到的收敛率偏离预期的 $p$ 阶缩放时触发该准则。给定一个容差 $\\varepsilon > 0$ 和一个预期阶数 $p_{\\text{exp}}$，如果存在任何连续对 $(k,k+1)$ 使得\n$$\n\\left| \\hat{p}_H^{(k)} - p_{\\text{exp}} \\right| > \\varepsilon \\quad \\text{或} \\quad \\left| \\hat{p}_M^{(k)} - p_{\\text{exp}} \\right| > \\varepsilon,\n$$\n则该准则必须返回布尔值 $\\text{True}$，否则返回 $\\text{False}$。\n\n为了科学上的真实性，请注意，上述人造代理与 ADM 约束的概念结构是一致的：哈密顿约束类似于作用于度规相关场的二阶导数算子，而动量约束类似于作用于曲率相关场的一阶散度类型算子。在网格加密研究中，验证其残差的 $p$ 阶缩放是标准做法。\n\n问题中没有出现角度，也不需要物理单位，因为问题在单位正方形上是纯无量纲的。\n\n测试套件：\n实现以下四个参数案例来检验停止准则：\n- 案例 1（理想路径）：$p_H = 2$, $p_M = 2$, $p_{\\text{exp}} = 2$, $\\varepsilon = 0.3$，网格尺寸 $\\{N_k\\} = \\{33, 65, 129\\}$。\n- 案例 2（阶数不匹配）：$p_H = 4$, $p_M = 4$, $p_{\\text{exp}} = 2$, $\\varepsilon = 0.3$，网格尺寸 $\\{N_k\\} = \\{33, 65, 129\\}$。\n- 案例 3（噪声引起的偏差）：$p_H = 4$, $p_M = 4$, $p_{\\text{exp}} = 4$, $\\varepsilon = 0.2$，网格尺寸 $\\{N_k\\} = \\{33, 65, 129\\}$，并添加固定振幅的约束测量噪声以模拟欠解析污染。在计算范数之前，必须使用为每个测试案例设置种子的确定性伪随机数生成器，将噪声直接添加到离散残余场中，以确保可复现性。\n- 案例 4（动量不匹配）：$p_H = 4$, $p_M = 2$, $p_{\\text{exp}} = 4$, $\\varepsilon = 0.3$，网格尺寸 $\\{N_k\\} = \\{33, 65, 129\\}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含四个案例的停止准则的布尔结果，格式为方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_k$ 为 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "该问题要求为类似于广义相对论 Arnowitt–Deser–Misner (ADM) 形式中的人造代理约束实现一个数值验证测试。核心任务是计算有限差分近似的收敛率，并应用一个自适应停止准则。\n\n首先，我们将问题形式化。我们给定一个标量场 $\\phi(x,y) = x^3 - 3 x y^2$ 和一个从流函数 $\\psi(x,y) = \\phi(x,y)$ 派生出的向量场，其分量为 $v_x(x,y) = \\partial_y \\psi = -6 x y$ 和 $v_y(x,y) = -\\partial_x \\psi = -3 x^2 + 3 y^2$。这些场定义在单位正方形 $\\Omega = [0,1]\\times[0,1]$上。\n\n代理约束是哈密顿约束 $H := \\Delta \\phi = \\partial_{xx} \\phi + \\partial_{yy} \\phi$ 和动量约束 $M := \\nabla \\cdot v = \\partial_x v_x + \\partial_y v_y$。从解析上看，这些约束恒等于零。\n- 对于 $H$：$\\partial_x \\phi = 3x^2 - 3y^2 \\implies \\partial_{xx} \\phi = 6x$。$\\partial_y \\phi = -6xy \\implies \\partial_{yy} \\phi = -6x$。因此，$H = 6x - 6x = 0$。\n- 对于 $M$：$\\partial_x v_x = -6y$。$\\partial_y v_y = 6y$。因此，$M = -6y + 6y = 0$。\n\n任务是在一个均匀的 $N \\times N$ 网格上（间距为 $h = 1/(N-1)$）离散化这些微分算子，并验证数值误差（表现为非零的残余约束 $H_h$ 和 $M_h$）是否以预期速率 $p_{\\text{exp}}$ 收敛到零。\n\n离散化是使用中心有限差分来执行的。\n对于拉普拉斯算子 $\\Delta = \\partial_{xx} + \\partial_{yy}$，二阶导数的近似使用：\n- $p=2$ 阶（3点模板）：\n$$ \\partial_{xx} f(x,y) \\approx \\frac{f(x+h, y) - 2f(x,y) + f(x-h,y)}{h^2} $$\n- $p=4$ 阶（5点模板）：\n$$ \\partial_{xx} f(x,y) \\approx \\frac{-f(x+2h, y) + 16f(x+h,y) - 30f(x,y) + 16f(x-h,y) - f(x-2h,y)}{12h^2} $$\n同样的模板也适用于 $\\partial_{yy}$。\n\n对于散度 $\\nabla \\cdot v = \\partial_x v_x + \\partial_y v_y$，一阶导数的近似使用：\n- $p=2$ 阶（3点模板）：\n$$ \\partial_{x} f(x,y) \\approx \\frac{f(x+h, y) - f(x-h,y)}{2h} $$\n- $p=4$ 阶（5点模板）：\n$$ \\partial_{x} f(x,y) \\approx \\frac{-f(x+2h, y) + 8f(x+h,y) - 8f(x-h,y) + f(x-2h,y)}{12h} $$\n\n此分析中的一个关键步骤是检查将这些模板应用于给定特定多项式时的截断误差。对于一个 $p$ 阶格式，主截断误差与 $h^p$ 和函数的高阶导数成比例。例如，二阶导数的二阶模板的主误差项与 $h^2 \\partial^4 f / \\partial x^4$ 成比例。四阶模板的误差与 $h^4 \\partial^6 f / \\partial x^6$ 成比例。类似地，一阶导数的二阶和四阶模板的主误差项分别与 $h^2 \\partial^3 f / \\partial x^3$ 和 $h^4 \\partial^5 f / \\partial x^5$ 成比例。\n\n让我们计算我们场的相关高阶导数：\n- 对于 $\\phi(x,y) = x^3 - 3xy^2$（一个三次多项式）：所有 4 阶及更高阶的导数均为零。\n- 对于 $v_x(x,y) = -6xy$ 和 $v_y(x,y) = -3x^2+3y^2$（二次多项式）：所有 3 阶及更高阶的导数均为零。\n\n这带来一个深远的影响：所有指定的有限差分格式对于这些特定的多项式都是精确的。主截断误差项，乃至所有后续项，都恒等于零。因此，对于所有网格间距 $h$，离散残差 $H_h$ 和 $M_h$ 在浮点舍入误差范围内应为零。\n\n因此，残差的 $L^2$ 范数，定义为 $\\|f_h\\|_{L^2} = (\\sum_{ij \\in \\text{int}} f_{ij}^2 h^2)^{1/2}$，将不会表现出预期的 $h^p$ 缩放行为。相反，在案例 1、2 和 4 中，它将在机器精度附近徘徊。通过 $\\hat{p} = \\ln(E_1/E_2)/\\ln(h_1/h_2)$ 计算出的观测收敛阶，将被这些接近零的范数的噪声比率所主导，从而产生不接近理论阶数 $p$ 的不可预测值。\n\n这使我们能够预测停止准则检查的结果，该检查在 $|\\hat{p}_H - p_{\\text{exp}}| > \\varepsilon$ 或 $|\\hat{p}_M - p_{\\text{exp}}| > \\varepsilon$ 时触发。\n- **案例 1 ($p_{\\text{exp}}=2, \\varepsilon=0.3$)：** 计算出的速率 $\\hat{p}_H, \\hat{p}_M$ 将是含噪声的，并且不会持续接近 2。预计会触发准则。结果：`True`。\n- **案例 2 ($p_{\\text{exp}}=2, \\varepsilon=0.3$)：** 与案例 1 相同。速率将是含噪声的。预计会触发准则。结果：`True`。\n- **案例 3 ($p_{\\text{exp}}=4, \\varepsilon=0.2$，带噪声)：** 引入了加性噪声基底，其主导了浮点误差。范数 $E_1$ 和 $E_2$ 将近似为常数，与 $h$ 无关。这导致 $E_1/E_2 \\approx 1$，因此 $\\ln(E_1/E_2) \\approx 0$，从而得到观测收敛率 $\\hat{p} \\approx 0$。由于 $|0 - 4| > 0.2$，准则将被触发。结果：`True`。\n- **案例 4 ($p_M=2, p_H=4, p_{\\text{exp}}=4, \\varepsilon=0.3$)：** 两个离散约束都精确为零（在机器精度内）。观测到的速率将是含噪声的，且不接近 4。预计会触发准则。结果：`True`。\n\n这个问题是对验证程序的一个复杂测试，它展示了一个常见的陷阱：人造解对于数值格式来说过于简单，导致收敛测试产生误导（或者在这种情况下，正确地失败）。算法将按规定计算范数并应用准则。\n案例 3 中噪声的实现细节将是使用一个带种子的伪随机数生成器以确保可复现性，将固定小振幅（例如 $10^{-10}$）的值加到离散残差场中。",
            "answer": "```python\nimport numpy as np\n\ndef compute_laplacian(phi, h, p):\n    \"\"\"\n    Computes the discrete Laplacian of a 2D field `phi` with grid spacing `h`\n    using a finite difference scheme of order `p`.\n    \"\"\"\n    laplacian = np.zeros_like(phi)\n    s = p // 2  # Stencil half-width\n\n    if p == 2:\n        # 3-point stencil for second derivative\n        # d2f/dx2 = (f_{i+1} - 2f_i + f_{i-1}) / h^2\n        d2phidx2 = np.zeros_like(phi)\n        d2phidy2 = np.zeros_like(phi)\n        \n        d2phidx2[:, s:-s] = (phi[:, 2*s:] - 2*phi[:, s:-s] + phi[:, :-2*s]) / h**2\n        d2phidy2[s:-s, :] = (phi[2*s:, :] - 2*phi[s:-s, :] + phi[:-2*s, :]) / h**2\n        \n        laplacian = d2phidx2 + d2phidy2\n\n    elif p == 4:\n        # 5-point stencil for second derivative\n        # d2f/dx2 = (-f_{i+2} + 16f_{i+1} - 30f_i + 16f_{i-1} - f_{i-2}) / (12h^2)\n        d2phidx2 = np.zeros_like(phi)\n        d2phidy2 = np.zeros_like(phi)\n\n        d2phidx2[:, s:-s] = (-phi[:, 2*s:] + 16*phi[:, s+1:-s+1] - 30*phi[:, s:-s] + 16*phi[:, s-1:-s-1] - phi[:, :-2*s]) / (12 * h**2)\n        d2phidy2[s:-s, :] = (-phi[2*s:, :] + 16*phi[s+1:-s+1, :] - 30*phi[s:-s, :] + 16*phi[s-1:-s-1, :] - phi[:-2*s, :]) / (12 * h**2)\n        \n        laplacian = d2phidx2 + d2phidy2\n    \n    return laplacian\n\ndef compute_divergence(vx, vy, h, p):\n    \"\"\"\n    Computes the discrete divergence of a 2D vector field (vx, vy) with grid\n    spacing `h` using a finite difference scheme of order `p`.\n    \"\"\"\n    divergence = np.zeros_like(vx)\n    s = p // 2  # Stencil half-width\n\n    if p == 2:\n        # 3-point stencil for first derivative\n        # df/dx = (f_{i+1} - f_{i-1}) / (2h)\n        dvxdx = np.zeros_like(vx)\n        dvydy = np.zeros_like(vy)\n        \n        dvxdx[:, s:-s] = (vx[:, 2*s:] - vx[:, :-2*s]) / (2 * h)\n        dvydy[s:-s, :] = (vy[2*s:, :] - vy[:-2*s, :]) / (2 * h)\n        \n        divergence = dvxdx + dvydy\n\n    elif p == 4:\n        # 5-point stencil for first derivative\n        # df/dx = (-f_{i+2} + 8f_{i+1} - 8f_{i-1} + f_{i-2}) / (12h)\n        dvxdx = np.zeros_like(vx)\n        dvydy = np.zeros_like(vy)\n        \n        dvxdx[:, s:-s] = (-vx[:, 2*s:] + 8*vx[:, s+1:-s+1] - 8*vx[:, s-1:-s-1] + vx[:, :-2*s]) / (12 * h)\n        dvydy[s:-s, :] = (-vy[2*s:, :] + 8*vy[s+1:-s+1, :] - 8*vy[s-1:-s-1, :] + vy[:-2*s, :]) / (12 * h)\n\n        divergence = dvxdx + dvydy\n\n    return divergence\n\ndef run_case(p_H, p_M, p_exp, epsilon, N_values, noise_params=None):\n    \"\"\"\n    Runs a single convergence test case and returns the stop criterion result.\n    \"\"\"\n    h_values = []\n    H_norms = []\n    M_norms = []\n\n    for N in N_values:\n        h = 1.0 / (N - 1)\n        h_values.append(h)\n        \n        # 1. Construct grid and evaluate analytic fields\n        grid_1d = np.linspace(0.0, 1.0, N)\n        x, y = np.meshgrid(grid_1d, grid_1d)\n        \n        phi = x**3 - 3*x*y**2\n        vx = -6*x*y\n        vy = -3*x**2 + 3*y**2\n        \n        # 2. Compute discrete proxy constraints\n        H_h = compute_laplacian(phi, h, p_H)\n        M_h = compute_divergence(vx, vy, h, p_M)\n\n        # 3. Add noise if applicable\n        if noise_params:\n            rng = np.random.default_rng(seed=noise_params['seed'])\n            amp = noise_params['amplitude']\n            H_h += rng.uniform(-amp, amp, size=H_h.shape)\n            M_h += rng.uniform(-amp, amp, size=M_h.shape)\n\n        # 4. Compute L2 norm over interior points\n        s_H = p_H // 2\n        interior_H = H_h[s_H:-s_H, s_H:-s_H]\n        norm_H = np.sqrt(np.sum(interior_H**2) * h**2)\n        H_norms.append(norm_H)\n        \n        s_M = p_M // 2\n        interior_M = M_h[s_M:-s_M, s_M:-s_M]\n        norm_M = np.sqrt(np.sum(interior_M**2) * h**2)\n        M_norms.append(norm_M)\n        \n    # 5. Estimate observed orders and check stop criterion\n    for k in range(len(N_values) - 1):\n        h1, h2 = h_values[k], h_values[k+1]\n        \n        # Avoid division by zero if norms are exactly zero\n        E1_H, E2_H = H_norms[k], H_norms[k+1]\n        p_hat_H = np.log(E1_H / E2_H) / np.log(h1 / h2) if E1_H > 0 and E2_H > 0 else 0\n\n        E1_M, E2_M = M_norms[k], M_norms[k+1]\n        p_hat_M = np.log(E1_M / E2_M) / np.log(h1 / h2) if E1_M > 0 and E2_M > 0 else 0\n        \n        if abs(p_hat_H - p_exp) > epsilon or abs(p_hat_M - p_exp) > epsilon:\n            return True\n            \n    return False\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, expected to fail check due to exactness)\n        {'p_H': 2, 'p_M': 2, 'p_exp': 2, 'eps': 0.3, 'N': [33, 65, 129], 'noise': None},\n        # Case 2 (order mismatch)\n        {'p_H': 4, 'p_M': 4, 'p_exp': 2, 'eps': 0.3, 'N': [33, 65, 129], 'noise': None},\n        # Case 3 (noise-induced deviation)\n        {'p_H': 4, 'p_M': 4, 'p_exp': 4, 'eps': 0.2, 'N': [33, 65, 129], 'noise': {'seed': 3, 'amplitude': 1e-10}},\n        # Case 4 (momentum mismatch)\n        {'p_H': 4, 'p_M': 2, 'p_exp': 4, 'eps': 0.3, 'N': [33, 65, 129], 'noise': None},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case['p_H'], case['p_M'], case['p_exp'], case['eps'], case['N'], case['noise'])\n        results.append(result)\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在验证了代码的收敛性之后，下一步是理解残余误差的物理性质。在广义相对论中，并非所有的数值偏差都有相同的意义；有些是与坐标选择相关的非物理“规范波”，而另一些则代表了真实的物理不一致性。这个练习  教你如何设计特定的监测量来分解总的约束违反范数 $\\|H\\|_{L^2}$，通过比较简单的有限差分计算和更精确的物理源谱方法计算，从而分离和量化由数值伪影（包括规范伪影）引起的误差，这是解读模拟结果的一项关键技能。",
            "id": "3470000",
            "problem": "考虑广义相对论 $3+1$ 形式中关于平直时空线性化的真空约束，其中空间度规为 $g_{ij} = \\delta_{ij} + h_{ij}$（$h_{ij}$ 是一个小微扰），外曲率的贡献在一阶上被忽略。线性化的哈密顿约束为\n$$\nH_{\\text{lin}}(x) = \\partial_i \\partial_j h_{ij}(x) - \\partial^2 h(x),\n$$\n其中 $h(x) = h_{ii}(x)$ 是微扰的迹，且 $\\partial^2 = \\partial_x^2 + \\partial_y^2 + \\partial_z^2$。假设所有场仅依赖于单一空间坐标 $x$，因此 $\\partial_y = \\partial_z = 0$，并在长度为 $L$ 的一维区域上建立周期性边界条件模型。在这种一维依赖的设置下，线性化的哈密顿约束简化为\n$$\nH_{\\text{lin}}(x) = \\partial_x^2 h_{xx}(x) - \\partial_x^2 \\left(h_{xx}(x) + h_{yy}(x) + h_{zz}(x)\\right) = -\\partial_x^2\\left(h_{yy}(x) + h_{zz}(x)\\right).\n$$\n这表明 $h_{xx}$ 中的纵向规范内容对 $H_{\\text{lin}}$ 没有贡献，而标量迹内容 $h_{yy} + h_{zz}$ 则有贡献。一个沿 $x$ 轴传播的物理横向无迹（TT）波具有 $h_{xx} = 0$, $h_{yy} = A \\sin(k(x - t))$, $h_{zz} = -A \\sin(k(x - t))$，因此 $h_{yy} + h_{zz} = 0$，这得出 $H_{\\text{lin}}(x) = 0$。一个由位移为 $\\xi_x(x,t)$ 的无穷小坐标微扰产生的纯规范波具有 $h_{xx}(x,t) = 2 \\partial_x \\xi_x(x,t)$ 和 $h_{yy} = h_{zz} = 0$，这也得出 $H_{\\text{lin}}(x) = 0$。\n\n您的任务是实现一个监控程序，在一个受控的综合实验中，区分哈密顿约束的 $L^2$ 范数 $\\|H\\|_{L^2}$ 中由规范引起的贡献与物理（标量迹）贡献。在一个长度为 $L = 2\\pi$ 的周期性区域上工作，该区域有 $N$ 个等距格点，间距为 $\\Delta x = L/N$。使用 $t = 0$。\n\n在格点 $x_n = n \\Delta x$（对于 $n = 0, 1, \\dots, N-1$）上定义以下综合注入：\n\n- 一个受控的规范波：\n$$\n\\xi_x(x, t) = \\frac{a}{k_{\\mathrm{phys}}}\\cos\\left(k_{\\mathrm{phys}}(x - t)\\right), \\quad h_{xx}^{\\mathrm{gauge}}(x, t) = 2 \\partial_x \\xi_x(x, t) = -2 a \\sin\\left(k_{\\mathrm{phys}}(x - t)\\right),\n$$\n其中 $h_{yy} = 0$, $h_{zz} = 0$。这里 $k_{\\mathrm{phys}} = \\frac{2\\pi m}{L}$ 是对应整数模数 $m$ 的物理波数。\n\n- 一个轻微扰动、违反约束的附加项：\n$$\nh_{yy}^{\\mathrm{pert}}(x, t) = \\varepsilon \\sin\\left(k_{\\mathrm{phys}}(x - t) + \\phi\\right), \\quad h_{zz}^{\\mathrm{pert}}(x, t) = 0,\n$$\n这得出 $h_{yy} + h_{zz} \\neq 0$，因此产生一个非零的 $H_{\\text{lin}}(x)$。\n\n- 一个沿 $x$ 轴传播的物理横向无迹（TT）波：\n$$\nh_{xx}^{\\mathrm{TT}}(x, t) = 0, \\quad h_{yy}^{\\mathrm{TT}}(x, t) = A_p \\sin\\left(k_{\\mathrm{phys}}(x - t)\\right), \\quad h_{zz}^{\\mathrm{TT}}(x, t) = -A_p \\sin\\left(k_{\\mathrm{phys}}(x - t)\\right),\n$$\n这使 $h_{yy} + h_{zz} = 0$ 保持不变。\n\n在同一个格点上构建三个测试案例：\n- 测试案例 1：仅有受控的规范波，其中 $h_{xx} = h_{xx}^{\\mathrm{gauge}}$, $h_{yy} = 0$, $h_{zz} = 0$。\n- 测试案例 2：规范波加上扰动附加项，其中 $h_{xx} = h_{xx}^{\\mathrm{gauge}}$, $h_{yy} = h_{yy}^{\\mathrm{pert}}$, $h_{zz} = 0$。\n- 测试案例 3：规范波加上物理 TT 波，其中 $h_{xx} = h_{xx}^{\\mathrm{gauge}}$, $h_{yy} = h_{yy}^{\\mathrm{TT}}$, $h_{zz} = h_{zz}^{\\mathrm{TT}}$。\n\n为每个测试案例开发并计算以下监控量：\n- 哈密顿约束在格点上的有限差分近似，\n$$\nH_{\\mathrm{fd}}(x_n) = D_{xx} h_{xx}(x_n) - D_{xx}\\left(h_{xx}(x_n) + h_{yy}(x_n) + h_{zz}(x_n)\\right),\n$$\n其中 $D_{xx}$ 是二阶中心有限差分算子，\n$$\nD_{xx} f(x_n) = \\frac{f(x_{n+1}) - 2 f(x_n) + f(x_{n-1})}{\\Delta x^2},\n$$\n使用周期性索引。\n\n- 使用离散傅里叶变换（DFT）对标量迹贡献进行谱方法导数近似：定义 $S(x_n) = h_{yy}(x_n) + h_{zz}(x_n)$。设 $\\widehat{f}(k)$ 是 $f(x)$ 在周期性格点上的 DFT，并让 $k$ 表示傅里叶空间中的角波数。然后计算\n$$\n\\left(-\\partial_x^2 S\\right)_{\\mathrm{sp}}(x) = \\mathcal{F}^{-1}\\left[k^2 \\widehat{S}(k)\\right](x),\n$$\n其中 $\\mathcal{F}^{-1}$ 表示逆 DFT，角波数为 $k_n = \\frac{2\\pi n}{L}$，对于与 DFT 约定匹配的整数 $n$。\n\n- 任何格点场 $f(x_n)$ 的 $L^2$ 范数为\n$$\n\\|f\\|_{L^2} = \\left( \\sum_{n=0}^{N-1} f(x_n)^2 \\Delta x \\right)^{1/2}.\n$$\n\n为每个测试案例计算：\n- $H$ 范数: $\\|H_{\\mathrm{fd}}\\|_{L^2}$。\n- 物理标量监控量: $M_{\\mathrm{phys}} = \\left\\|\\left(-\\partial_x^2 S\\right)_{\\mathrm{sp}}\\right\\|_{L^2}$。\n- 规范污染监控量: $M_{\\mathrm{gauge}} = \\left\\|H_{\\mathrm{fd}} - \\left(-\\partial_x^2 S\\right)_{\\mathrm{sp}}\\right\\|_{L^2}$，它量化了测量的哈密顿约束中不能由标量迹贡献解释的部分，因此可归因于纯规范内容和离散化赝象。\n\n为一个科学上合理且非平凡的测试套件使用以下参数值：\n- 区域长度 $L = 2\\pi$。\n- 格点大小 $N = 256$。\n- 模数 $m = 4$，因此 $k_{\\mathrm{phys}} = \\frac{2\\pi m}{L}$。\n- 规范振幅 $a = 0.1$。\n- 扰动振幅 $\\varepsilon = 0.01$ 和相位 $\\phi = \\pi/5$。\n- 物理 TT 振幅 $A_p = 0.05$。\n- 时间 $t = 0$。\n\n您的程序应生成一行输出，其中按顺序包含九个结果，形式为逗号分隔的列表并用方括号括起来，具体如下\n$$\n[\\|H_{\\mathrm{fd}}\\|_{L^2}^{(1)}, M_{\\mathrm{phys}}^{(1)}, M_{\\mathrm{gauge}}^{(1)}, \\|H_{\\mathrm{fd}}\\|_{L^2}^{(2)}, M_{\\mathrm{phys}}^{(2)}, M_{\\mathrm{gauge}}^{(2)}, \\|H_{\\mathrm{fd}}\\|_{L^2}^{(3)}, M_{\\mathrm{phys}}^{(3)}, M_{\\mathrm{gauge}}^{(3)}],\n$$\n其中上标表示测试案例编号。将所有九个输出表示为浮点数。在这个无量纲的综合实验中不涉及物理单位。将每个打印的浮点数四舍五入到 $8$ 位小数，以使单行输出在不同平台上保持稳定和明确。",
            "solution": "用户的请求是开发一个程序，在一个简化的广义相对论一维线性化情境中监控哈密顿约束违反。其目标是区分约束违反的物理来源和数值赝象，后者可能与规范动力学有关。\n\n### 科学原理与问题建构\n\n该问题根植于广义相对论的 $3+1$ \"ADM\" 形式，其中时空被叶状剖分成一系列空间切片。几何的演化由演化方程决定，但一个切片上的初始数据不能自由选择，必须满足一组四个约束方程。在这里，我们关注线性化的哈密顿约束，对于平直时空周围的度规微扰 $h_{ij}$，其形式为：\n$$\nH_{\\text{lin}} = \\partial_i \\partial_j h_{ij} - \\partial^2 h\n$$\n其中 $h=h_{kk}$ 是微扰的迹，重复指标表示求和。将问题特化为所有场仅依赖于 $x$ 坐标的一维问题（$\\partial_y = \\partial_z = 0$），此约束显著简化为：\n$$\nH_{\\text{lin}}(x) = \\partial_x^2 h_{xx} - \\partial_x^2 (h_{xx} + h_{yy} + h_{zz}) = -\\partial_x^2 (h_{yy} + h_{zz})\n$$\n我们定义标量迹量 $S(x) = h_{yy}(x) + h_{zz}(x)$。因此，哈密顿约束等价于负拉普拉斯算子作用于此标量迹上：\n$$\nH_{\\text{lin}}(x) = -\\partial_x^2 S(x)\n$$\n这个方程揭示了非零的标量迹 $S$ 是哈密顿约束违反的源头。重要的是，纯规范模式（非物理的坐标赝象）和在 $x$ 方向传播的横向无迹（TT）物理引力波被构建为具有 $S=0$ 的特性，因此它们精确地满足哈密顿约束。\n\n### 数值实现与监控策略\n\n任务是为一个周期性一维格点上定义的三个综合测试案例实现并比较此约束的不同数值度量。\n\n**1. 数值算子：**\n\n- **有限差分拉普拉斯算子：** 连续算子 $\\partial_x^2$ 由一个二阶中心有限差分算子 $D_{xx}$ 近似：\n  $$\n  D_{xx} f(x_n) = \\frac{f(x_{n+1}) - 2 f(x_n) + f(x_{n-1})}{\\Delta x^2}\n  $$\n  其中 $\\Delta x$ 是格点间距，索引使用周期性边界条件。哈密顿约束的有限差分近似 $H_{\\text{fd}}$ 按规定计算：\n  $$\n  H_{\\text{fd}} = D_{xx} h_{xx} - D_{xx}(h_{xx} + h_{yy} + h_{zz})\n  $$\n  虽然 $D_{xx} h_{xx}$ 项在数学上会抵消，但在实际模拟中计算它们可能会引入浮点噪声，而问题要求我们按此方式计算。\n\n- **谱方法拉普拉斯算子：** 对于周期函数，一种计算导数的高精度方法是通过傅里叶变换（$\\mathcal{F}$）。傅里叶变换的微分性质表明 $\\mathcal{F}[\\partial_x f(x)] = ik\\mathcal{F}[f(x)]$，其中 $k$ 是角波数。因此，$-\\partial_x^2$ 在傅里叶空间中变为乘以 $k^2$。约束源的谱方法评估为：\n  $$\n  (-\\partial_x^2 S)_{\\mathrm{sp}} = \\mathcal{F}^{-1}[k^2 \\mathcal{F}[S]]\n  $$\n  其中 $\\mathcal{F}^{-1}$ 是逆傅里叶变换。对于在格点上被良好解析的函数，此方法没有截断误差。\n\n**2. 监控量：**\n\n问题定义了三个基于 $L^2$ 范数的监控量，对于格点函数 $f_n$，其范数为 $\\|f\\|_{L^2} = (\\sum_{n=0}^{N-1} f_n^2 \\Delta x)^{1/2}$。\n\n- **总“测量”约束违反：** $\\|H_{\\mathrm{fd}}\\|_{L^2}$。这代表了通过简单的有限差分方法测量的总约束违反。\n\n- **物理标量监控量：** $M_{\\mathrm{phys}} = \\|(-\\partial_x^2 S)_{\\mathrm{sp}}\\|_{L^2}$。这使用谱方法精确地量化源于非零标量迹 $S$ 的“真实”物理约束违反。\n\n- **规范污染监控量：** $M_{\\mathrm{gauge}} = \\|H_{\\mathrm{fd}} - (-\\partial_x^2 S)_{\\mathrm{sp}}\\|_{L^2}$。这度量了有限差分评估与谱方法评估之间的差异。这种差异主要源于有限差分算子的截断误差。在更复杂的场景中，这类差异可能由规范模式引发或放大，因此得名。\n\n### 测试案例分析\n\n- **案例 1 (纯规范)：** 我们将 $h_{xx}$ 设置为规范波，且 $h_{yy} = h_{zz} = 0$。这得到 $S = 0$。因此，解析约束 $H_{\\text{lin}}$ 为零。两个数值近似 $H_{\\text{fd}}$ 和 $(-\\partial_x^2 S)_{\\mathrm{sp}}$ 也将为零（在机器精度范围内）。预计所有三个监控量都为零。\n\n- **案例 2 (规范 + 扰动)：** 我们添加一个违反约束的扰动 $h_{yy}^{\\mathrm{pert}}$，使得 $S \\neq 0$。\n    - $M_{\\mathrm{phys}}$ 将为非零值，提供一个谱方法精确测量的违反量。\n    - $\\|H_{\\mathrm{fd}}\\|_{L^2}$ 也将为非零值。由于 $D_{xx}$ 是一个二阶近似，其结果将接近但不会与谱方法的结果完全相同。\n    - $M_{\\mathrm{gauge}}$ 将很小但非零，精确地量化了在给定格点分辨率和波数下有限差分方法的截断误差。\n\n- **案例 3 (规范 + TT 波)：** 我们添加一个物理横向无迹（TT）引力波。根据定义，TT 波的迹为零，所以对于这个波，$h_{yy}^{\\mathrm{TT}} + h_{zz}^{\\mathrm{TT}} = 0$。这使得总标量迹 $S=0$。因此，从哈密顿约束的角度来看，这个案例与案例 1 相同。预计所有三个监控量都将为零，这表明监控量正确地将此物理波识别为满足约束的解。\n\n实现将通过设置格点，定义数值算子和 $L^2$ 范数的辅助函数，为三个测试案例构建场，计算三个指定的监控量，并格式化结果来进行。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Hamiltonian constraint monitors for three synthetic test cases\n    in linearized 1D gravity.\n    \"\"\"\n    # Define parameters from the problem statement\n    L = 2.0 * np.pi\n    N = 256\n    m = 4\n    a = 0.1\n    epsilon = 0.01\n    phi = np.pi / 5.0\n    Ap = 0.05\n    t = 0.0\n\n    # Grid setup\n    dx = L / N\n    x = np.arange(N) * dx\n    # Since L=2pi, the physical wavenumber k_phys = 2*pi*m/L simplifies to m.\n    k_phys = float(m)\n\n    # --- Helper functions defined within the solver scope ---\n    def D_xx(f, dx_val):\n        \"\"\"Computes the second derivative using a centered finite difference scheme.\"\"\"\n        f_plus_1 = np.roll(f, -1)\n        f_minus_1 = np.roll(f, 1)\n        return (f_plus_1 - 2.0 * f + f_minus_1) / dx_val**2\n\n    def neg_d2_spectral(f, N_val, dx_val):\n        \"\"\"Computes -d^2/dx^2 of a function f using spectral methods (FFT).\"\"\"\n        f_hat = np.fft.fft(f)\n        # Wavenumbers corresponding to the DFT frequencies.\n        # np.fft.fftfreq gives cycles/sample spacing; multiply by 2*pi for angular k.\n        freqs = np.fft.fftfreq(N_val, d=dx_val)\n        k = 2.0 * np.pi * freqs\n        \n        # In Fourier space, -d^2/dx^2 is equivalent to multiplication by k^2.\n        # d/dx -> ik,  d^2/dx^2 -> (ik)^2 = -k^2,  -d^2/dx^2 -> k^2\n        neg_d2f_hat = (k**2) * f_hat\n        \n        # Inverse FFT to get back to spatial domain.\n        # The result must be real; np.real removes negligible imaginary parts.\n        return np.real(np.fft.ifft(neg_d2f_hat))\n\n    def L2_norm(f, dx_val):\n        \"\"\"Computes the L2 norm of a grid function.\"\"\"\n        return np.sqrt(np.sum(np.square(f)) * dx_val)\n\n    # --- Define field components for test cases ---\n    # Common gauge wave component\n    h_xx_gauge = -2.0 * a * np.sin(k_phys * (x - t))\n    \n    # Empty field for convenience\n    zeros = np.zeros(N)\n    \n    # Constraint-violating perturbation component\n    h_yy_pert = epsilon * np.sin(k_phys * (x - t) + phi)\n    \n    # Transverse-Traceless (TT) wave components\n    h_yy_TT = Ap * np.sin(k_phys * (x - t))\n    h_zz_TT = -Ap * np.sin(k_phys * (x - t))\n\n    # --- Define the test cases from the problem statement ---\n    test_cases = [\n        # Case 1: Pure gauge wave\n        (h_xx_gauge, zeros, zeros),\n        # Case 2: Gauge wave + perturbation\n        (h_xx_gauge, h_yy_pert, zeros),\n        # Case 3: Gauge wave + physical TT wave\n        (h_xx_gauge, h_yy_TT, h_zz_TT)\n    ]\n\n    all_results = []\n    for hxx, hyy, hzz in test_cases:\n        # Compute H_fd using the specified formula: H_fd = Dxx(hxx) - Dxx(hxx + hyy + hzz)\n        # This simplifies to -Dxx(hyy + hzz), but we implement the given form.\n        term1 = D_xx(hxx, dx)\n        term2 = D_xx(hxx + hyy + hzz, dx)\n        H_fd = term1 - term2\n\n        # Scalar trace S = hyy + hzz\n        S = hyy + hzz\n\n        # Compute the spectral scalar-trace contribution: (-d^2 S/dx^2)_sp\n        neg_d2S_sp = neg_d2_spectral(S, N, dx)\n\n        # Compute the three monitors for the current case\n        H_norm = L2_norm(H_fd, dx)\n        M_phys = L2_norm(neg_d2S_sp, dx)\n        M_gauge = L2_norm(H_fd - neg_d2S_sp, dx)\n\n        all_results.extend([H_norm, M_phys, M_gauge])\n        \n    # Format and print the final output as a single line with 8 decimal places\n    output_str = \"[\" + \",\".join([f\"{r:.8f}\" for r in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}