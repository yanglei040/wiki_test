{
    "hands_on_practices": [
        {
            "introduction": "黑洞切除技术的基本原理根植于因果性。在事件视界内部，所有未来导向的路径都指向奇点，这意味着信息无法逃逸到外部时空。本练习通过一个简化的特征场演化模型，直观地展示了这一核心概念：将数值边界置于视界内部（可接受的切除）可以确保演化的稳定性，而边界位置不当（不可接受的切除）则会导致数值不稳定性，从而破坏模拟的物理真实性。",
            "id": "3465528",
            "problem": "考虑一个固定的史瓦西黑洞背景在一维球对称约化下的情况，该背景在克尔-希尔德坐标系中表示。在$G=c=1$的几何单位制下工作，并以黑洞质量$M$为单位来度量时间和长度，从而使得所有量均为无量纲量。您的任务是实现一个基于零测地线的切除方案，其中内边界在克尔-希尔德坐标系中沿着入射零测地线运动。您将通过演化两个分别沿着入射和出射零方向传播的解耦特征场来模拟一个对称双曲系统的主部，并评估其稳定性和约束泄漏情况。\n\n出发点与要求的第一性原理推导：\n- 从史瓦西度规的克尔-希尔德形式$g_{\\mu\\nu}$及其3+1分解开始，该分解包含退移函数$\\alpha$、移位矢量$\\beta^i$和空间度规$\\gamma_{ij}$。利用标准性质，即在3+1分解中，类光信号在径向相对于坐标时间的特征速度由$-\\beta^r \\pm \\alpha \\sqrt{\\gamma^{rr}}$给出。请推导分别对应入射和出射零特征的显式径向坐标速度$v_{-}(r)$和$v_{+}(r)$，并将其仅表示为$r$和$M$的函数。\n- 使用零矢量$l^\\mu$（入射）和$n^\\mu$（出射），其相对于$g_{\\mu\\nu}$进行归一化，使得$l^\\mu l_\\mu = n^\\mu n_\\mu = 0$和$l^\\mu n_\\mu = -1$。沿着$l^\\mu$和$n^\\mu$进行特征分解，定义两个分别以速度$v_{-}(r)$和$v_{+}(r)$传播的标量特征变量$w_l$和$w_n$。您的演化模型是如下的解耦一阶双曲系统\n$$\n\\partial_t w_l + v_{-}(r)\\,\\partial_r w_l = 0,\\qquad\n\\partial_t w_n + v_{+}(r)\\,\\partial_r w_n = 0.\n$$\n- 通过使内边界沿着入射零测地线移动来实现基于零测地线的切除。在克尔-希尔德坐标系中，这意味着内边界半径$r_{\\mathrm{in}}(t)$必须满足\n$$\n\\frac{dr_{\\mathrm{in}}}{dt} = v_{-}(r_{\\mathrm{in}}(t)).\n$$\n- 对于$r=r_{\\max}$处的外边界，通过规定没有入射的入射零模式来消除传入的内容，即设置边界条件使得从$r_{\\max}$进入的$w_l$为零。\n\n数值方法要求：\n- 在间距为$\\Delta r$的均匀网格上离散化空间坐标$r$。通过库朗-弗里德里希-列维(CFL)条件选择时间步长$\\Delta t$，使得$\\max_r |v_{\\pm}(r)|\\,\\Delta t/\\Delta r \\leq \\lambda$，其中$0\\lambda1$是给定的库朗因子。使用三阶强稳定性保持(SSP)龙格-库塔方法进行时间积分。\n- 对空间导数使用与特征速度局部符号一致的迎风有限差分。如果内切除边界位于事件视界上或其内部，则它是一个纯粹的出流边界；因此，对于进入计算区域的模式，它不需要边界条件。如果内边界位于事件视界之外，内边界处将会有一个进入计算区域的出射零模式$w_n$；如果在该处不提供数据，该方案可能会变得不稳定。\n- 为了评估约束泄漏，定义一个一阶约化约束的代理量。根据标量场的特征分解重构一个辅助场$\\Phi$，\n$$\n\\Phi(r,t) \\equiv \\frac{w_n(r,t) - w_l(r,t)}{2\\,\\sqrt{\\gamma^{rr}(r)}},\n$$\n然后在网格上通过从内边界开始对$\\Phi$进行离散线积分来构造一个标量势$\\phi(r,t)$。定义离散约束\n$$\nC(r,t) \\equiv \\left(\\partial_r \\phi\\right)_{\\mathrm{num}} - \\Phi(r,t),\n$$\n其中$\\left(\\partial_r \\phi\\right)_{\\mathrm{num}}$是一个相容的有限差分近似。使用活动计算域上的$L^2$范数来测量最终时刻的无量纲泄漏率\n$$\n\\mathcal{R} \\equiv \\frac{\\|C(\\cdot,T)\\|_{2}}{\\|\\Phi(\\cdot,T)\\|_{2}}.\n$$\n\n初始数据与外边界：\n- 将$w_n(r,0)$设置为一个高斯脉冲，其振幅为$A$，中心位于$r=r_0$，宽度为$\\sigma$，即$w_n(r,0) = A \\exp\\left(-\\frac{(r-r_0)^2}{\\sigma^2}\\right)$。\n- 设置$w_l(r,0)=0$。\n- 在$r=r_{\\max}$的外边界上，要求没有入射内容进入计算域：实施一个与$w_l$在计算域外为零相一致的边界条件。\n\n稳定性评估：\n- 令瞬时$L^2$范数为$\\|W(\\cdot,t)\\|_2$，它是根据活动计算域上的$w_l$和$w_n$计算得出，例如，可将其视为由黎曼和近似的$w_l^2+w_n^2$积分的平方根。追踪增长因子\n$$\nG \\equiv \\frac{\\max_{t\\in[0,T]} \\|W(\\cdot,t)\\|_2}{\\|W(\\cdot,0)\\|_2}.\n$$\n- 定义方案为稳定，如果$G \\leq 1.3$，否则为不稳定。\n\n需要在程序中编码的实现细节：\n- 使用$r\\in[r_{\\min}, r_{\\max}]$上的均匀网格，其中$r_{\\min}0$。在每个时间步，根据上面指定的入射零测地线方程推进内切除半径$r_{\\mathrm{in}}(t)$。在时间$t$的活动计算网格是满足$r \\geq r_{\\mathrm{in}}(t)$的点集。\n- 对于$w_l$，始终使用与$v_{-}(r)$一致的迎风导数。对于$w_n$，在内部区域使用与$v_{+}(r)$一致的迎风导数。在外边界处，通过一个与$w_l$在外部为零相一致的单边导数来施加无入射$w_l$的条件。在内边界处，不提供边界数据；当内边界位于事件视界之外以至于$v_{+}(r_{\\mathrm{in}})0$时，对$w_n$的第一个活动点使用形式上的顺风导数，以反映边界数据的缺乏并揭示潜在的不稳定性。\n- 从当前的内边界点开始，通过对$\\Phi$进行离散线积分来计算$\\phi$，然后通过有限差分计算离散梯度$\\left(\\partial_r \\phi\\right)_{\\mathrm{num}}$。\n\n测试套件：\n运行您的程序以执行以下三个测试用例。所有量均使用$M$的单位，并将所有输出表示为纯数字（无量纲小数）：\n1. 情况 A (允许的切除，预期稳定): $M=1$, $A=1$, $r_0=12$, $\\sigma=1$, $r_{\\min}=0.1$, $r_{\\max}=50$, 网格点数 $N=600$, 库朗因子 $\\lambda=0.6$, 最终时间 $T=8$, 内边界初始半径 $r_{\\mathrm{in}}(0)=2.0$。\n2. 情况 B (不允许的切除，预期不稳定): $M=1$, $A=1$, $r_0=10$, $\\sigma=1$, $r_{\\min}=0.1$, $r_{\\max}=30$, $N=500$, $\\lambda=0.6$, $T=6$, $r_{\\mathrm{in}}(0)=2.4$。\n3. 情况 C (允许的切除，库朗因子较紧): $M=1$, $A=1$, $r_0=10$, $\\sigma=1$, $r_{\\min}=0.1$, $r_{\\max}=30$, $N=200$, $\\lambda=0.9$, $T=6$, $r_{\\mathrm{in}}(0)=2.0$。\n\n要求的最终输出格式：\n- 您的程序应输出包含一个列表的列表的单行，每个内部列表对应一个测试用例，格式为$[\\text{stable}, G, \\mathcal{R}]$，其中$\\text{stable}$是一个布尔值，$G$是一个浮点数，$\\mathcal{R}$是一个浮点数。例如，打印的行必须如下所示：\n\"[[True,1.05,0.0123],[False,3.7,0.45],[True,1.12,0.021]]\"\n其中包含您计算得到的实际数值。不应打印任何额外文本。",
            "solution": "该问题是有效的，因为它提出了一个在数值相对论领域内定义明确且具有科学依据的任务。它要求推导基本物理量、实现带有特定边界处理的标准数值方案，以及分析稳定性和误差，所有这些都是计算物理学中的标准实践。\n\n我们的第一步是从球坐标下史瓦西度规的克尔-希尔德形式推导特征速度。线元在几何单位制（$G=c=1$）下由下式给出\n$$\nds^2 = -\\left(1 - \\frac{2M}{r}\\right) dt^2 + \\frac{4M}{r} dt dr + \\left(1 + \\frac{2M}{r}\\right) dr^2 + r^2 d\\Omega^2.\n$$\n这对应于一个一般的3+1分解线元\n$$\nds^2 = (-\\alpha^2 + \\beta_i \\beta^i) dt^2 + 2\\beta_i dt dx^i + \\gamma_{ij} dx^i dx^j.\n$$\n通过比较一维球对称系统（其中空间坐标仅为$r$）的度规分量，我们可以确定退移函数$\\alpha$、径向移位分量（协变和逆变）$\\beta_r$和$\\beta^r$，以及径向空间度规分量（协变和逆变）$\\gamma_{rr}$和$\\gamma^{rr}$。\n从度规中，我们有：\n- 空间度规分量： $\\gamma_{rr} = g_{rr} = 1 + \\frac{2M}{r}$。其逆为 $\\gamma^{rr} = \\left(1 + \\frac{2M}{r}\\right)^{-1} = \\frac{r}{r+2M}$。\n- 协变移位分量： $\\beta_r = g_{tr} = \\frac{2M}{r}$。\n- 逆变移位分量： $\\beta^r = \\gamma^{rr} \\beta_r = \\frac{r}{r+2M} \\cdot \\frac{2M}{r} = \\frac{2M}{r+2M}$。\n- 退移函数： $\\alpha^2 = \\beta_i \\beta^i - g_{tt} = \\beta_r \\beta^r - g_{tt} = \\left(\\frac{2M}{r}\\right)\\left(\\frac{2M}{r+2M}\\right) - \\left(-1 + \\frac{2M}{r}\\right) = \\frac{4M^2}{r(r+2M)} + 1 - \\frac{2M}{r} = \\frac{4M^2 + r(r+2M) - 2M(r+2M)}{r(r+2M)} = \\frac{4M^2 + r^2 + 2Mr - 2Mr - 4M^2}{r(r+2M)} = \\frac{r^2}{r(r+2M)} = \\frac{r}{r+2M}$。所以，$\\alpha = \\sqrt{\\frac{r}{r+2M}}$。\n\n径向特征速度由$v_{\\pm}(r) = -\\beta^r \\pm \\alpha \\sqrt{\\gamma^{rr}}$给出。代入我们推导出的量：\n$$\nv_{\\pm}(r) = -\\frac{2M}{r+2M} \\pm \\sqrt{\\frac{r}{r+2M}} \\sqrt{\\frac{r}{r+2M}} = -\\frac{2M}{r+2M} \\pm \\frac{r}{r+2M} = \\frac{-2M \\pm r}{r+2M}.\n$$\n这给出了入射和出射速度：\n- 入射速度： $v_{-}(r) = \\frac{-2M-r}{r+2M} = -1$。\n- 出射速度： $v_{+}(r) = \\frac{r-2M}{r+2M}$。\n\n显著的结果$v_{-}(r) = -1$表明，在克尔-希尔德坐标系中，入射零测地线具有恒定的坐标速度。内切除边界的演化方程$\\frac{dr_{\\mathrm{in}}}{dt} = v_{-}(r_{\\mathrm{in}}(t))$简化为$\\frac{dr_{\\mathrm{in}}}{dt} = -1$，得出轨迹为$r_{\\mathrm{in}}(t) = r_{\\mathrm{in}}(0) - t$。\n\n该模型包含两个关于特征场$w_l$和$w_n$的解耦线性平流方程：\n$$\n\\partial_t w_l + v_{-}(r)\\,\\partial_r w_l = 0 \\implies \\partial_t w_l - \\partial_r w_l = 0 \\\\\n\\partial_t w_n + v_{+}(r)\\,\\partial_r w_n = 0\n$$\n这些方程在间距为$\\Delta r$的均匀网格$r \\in [r_{\\min}, r_{\\max}]$上求解。CFL条件要求$\\Delta t \\le \\lambda \\frac{\\Delta r}{\\max(|v_{-}|, |v_{+}|)}$。由于对于$r \\ge 0$，$|v_{-}|=1$且$|v_{+}| = |\\frac{r-2M}{r+2M}| \\le 1$，最大速度为$1$。因此，我们选择$\\Delta t = \\lambda \\Delta r$。\n\n数值方案采用：\n1.  **时间积分**：使用三阶强稳定性保持龙格-库塔 (SSP-RK3) 方法来推进时间上的解。\n2.  **空间离散**：对空间导数$\\partial_r w_l$和$\\partial_r w_n$使用一阶迎风有限差分。\n    - 对于$w_l$，速度$v_{-} = -1  0$，因此信息从较大的$r$传播到较小的$r$。迎风格式要求使用向前差分：$(\\partial_r w_l)_i \\approx \\frac{(w_l)_{i+1} - (w_l)_i}{\\Delta r}$。\n    - 对于$w_n$，速度$v_{+}(r)$在事件视界$r=2M$处改变符号。\n        - 如果$r2M$，$v_{+}0$，信息从较小的$r$传播。迎风格式要求使用向后差分：$(\\partial_r w_n)_i \\approx \\frac{(w_n)_i - (w_n)_{i-1}}{\\Delta r}$。\n        - 如果$r \\le 2M$，$v_{+} \\le 0$，信息从较大的$r$传播。迎风格式要求使用向前差分：$(\\partial_r w_n)_i \\approx \\frac{(w_n)_{i+1} - (w_n)_i}{\\Delta r}$。\n\n**边界与切除处理**：\n- **外边界 ($r=r_{\\max}$)**：我们通过在计算域外的影子单元中设置$w_l=0$来施加无入射内容进入的条件。对于最后一个网格点$i=N-1$处的$w_l$导数，这给出$(\\partial_r w_l)_{N-1} \\approx \\frac{0 - (w_l)_{N-1}}{\\Delta r}$。\n- **内切除边界 ($r_{\\mathrm{in}}(t)$)**：计算域被限制在满足$r_i \\ge r_{\\mathrm{in}}(t)$的网格点上。\n    - 该方案的稳定性关键取决于$r_{\\mathrm{in}}(t)$相对于事件视界$r=2M$的位置。\n    - 如果$r_{\\mathrm{in}}(t) \\le 2M$，边界处的所有特征都指向较小的$r$（进入切除区域）。因此，该边界是一个纯粹的出流边界，不需要任何数据。迎风方案自然地处理了这种情况。\n    - 如果$r_{\\mathrm{in}}(t)  2M$，则$v_{+}(r_{\\mathrm{in}})  0$。$w_n$的特征线指向计算域内部。由于我们不提供边界数据，该方案是不适定的。问题指定在第一个活动网格点对$w_n$使用“形式上的顺风”导数（向前差分）。这一选择虽然能让代码运行，但已知是不稳定的，并预期会导致解的指数增长，正如在情况B中所展示的。\n\n**分析度量**：\n- **稳定性**：增长因子$G \\equiv \\frac{\\max_{t\\in[0,T]} \\|W(\\cdot,t)\\|_2}{\\|W(\\cdot,0)\\|_2}$度量了解的总$L^2$范数的放大情况，其中$\\|W\\|_2^2 = \\int (w_l^2+w_n^2)dr$。$G1$（允许一个小的容差，此处为$1.3$）的值表示不稳定。\n- **约束泄漏**：为评估数值误差，定义了一个代理约束$C(r,t) \\equiv \\left(\\partial_r \\phi\\right)_{\\mathrm{num}} - \\Phi(r,t)$。这里，$\\Phi \\equiv \\frac{w_n - w_l}{2\\sqrt{\\gamma^{rr}}}$是一个辅助场，而$\\phi$是它从内边界开始的离散积分。非零的$C$表示数值积分与微分之间的不一致性。泄漏率$\\mathcal{R} \\equiv \\frac{\\|C(\\cdot,T)\\|_{2}}{\\|\\Phi(\\cdot,T)\\|_{2}}$量化了这一误差。\n\n实现遵循这些原则，根据指定的测试用例演化$w_n$的初始高斯脉冲和$w_l$的零场，并报告最终的稳定性和误差度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (admissible excision, expected stable)\n        {'M': 1, 'A': 1, 'r0': 12, 'sigma': 1, 'rmin': 0.1, 'rmax': 50, 'N': 600, 'lambda_': 0.6, 'T': 8, 'r_in0': 2.0},\n        # Case B (inadmissible excision, expected unstable)\n        {'M': 1, 'A': 1, 'r0': 10, 'sigma': 1, 'rmin': 0.1, 'rmax': 30, 'N': 500, 'lambda_': 0.6, 'T': 6, 'r_in0': 2.4},\n        # Case C (admissible excision with tight Courant factor)\n        {'M': 1, 'A': 1, 'r0': 10, 'sigma': 1, 'rmin': 0.1, 'rmax': 30, 'N': 200, 'lambda_': 0.9, 'T': 6, 'r_in0': 2.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        res = run_simulation(**case)\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\ndef run_simulation(M, A, r0, sigma, rmin, rmax, N, lambda_, T, r_in0):\n    \"\"\"\n    Performs a single simulation run for a given set of parameters.\n    \"\"\"\n    r = np.linspace(rmin, rmax, N)\n    dr = r[1] - r[0]\n\n    def v_plus(r_val, M_val):\n        return np.divide(r_val - 2 * M_val, r_val + 2 * M_val)\n    \n    dt = lambda_ * dr\n\n    w_l = np.zeros(N)\n    w_n = A * np.exp(-(r - r0)**2 / sigma**2)\n\n    t = 0.0\n    r_in = r_in0\n\n    def l2_norm_combined(arr1, arr2, i_start, dr_val):\n        if i_start >= len(arr1):\n            return 0.0\n        active_slice = slice(i_start, None)\n        return np.sqrt(np.sum(arr1[active_slice]**2 + arr2[active_slice]**2) * dr_val)\n\n    i_in_initial = np.searchsorted(r, r_in, side='left')\n    initial_norm = l2_norm_combined(w_l, w_n, i_in_initial, dr)\n    if initial_norm == 0: initial_norm = 1.0 # Avoid division by zero\n    max_norm = initial_norm\n\n    def calculate_rhs(wl_in, wn_in, r_grid, dr_val, M_val, i_in_idx):\n        N_pts = len(r_grid)\n        rhs_l = np.zeros(N_pts)\n        rhs_n = np.zeros(N_pts)\n        \n        if i_in_idx >= N_pts: # No active points\n            return rhs_l, rhs_n\n\n        # RHS for w_l (v_minus = -1, upwind is forward difference)\n        for i in range(i_in_idx, N_pts - 1):\n             rhs_l[i] = (wl_in[i+1] - wl_in[i]) / dr_val # -v_minus * deriv, where v_minus=-1\n        \n        # Outer boundary for w_l (ghost point wl=0)\n        rhs_l[N_pts - 1] = (0 - wl_in[N_pts-1]) / dr_val\n        \n        # RHS for w_n\n        vp_grid = v_plus(r_grid, M_val)\n        \n        # Inner boundary for w_n (at i_in_idx)\n        if i_in_idx  N_pts - 1:\n            # Per problem spec, use forward difference to reveal instability.\n            # This is upwind if v_p0, and downwind if v_p>0.\n            deriv_n = (wn_in[i_in_idx+1] - wn_in[i_in_idx]) / dr_val\n            rhs_n[i_in_idx] = -vp_grid[i_in_idx] * deriv_n\n        \n        # Interior points for w_n\n        for i in range(i_in_idx + 1, N_pts - 1):\n            if vp_grid[i] > 0: # Upwind is backward\n                deriv_n = (wn_in[i] - wn_in[i-1]) / dr_val\n            else: # Upwind is forward\n                deriv_n = (wn_in[i+1] - wn_in[i]) / dr_val\n            rhs_n[i] = -vp_grid[i] * deriv_n\n\n        # Outer boundary for w_n (at N_pts - 1)\n        if N_pts - 1 > i_in_idx:\n            i = N_pts - 1\n            if vp_grid[i] > 0: # Upwind is backward (normal case)\n                deriv_n = (wn_in[i] - wn_in[i-1]) / dr_val\n                rhs_n[i] = -vp_grid[i] * deriv_n\n            # else: case v_p=0 not expected at r_max for these problems.\n\n        return rhs_l, rhs_n\n\n    while t  T:\n        current_dt = min(dt, T - t)\n        if current_dt  1e-12: break\n        \n        i_in = np.searchsorted(r, r_in, side='left')\n        \n        # SSP-RK3\n        # Stage 1\n        rhs_l_1, rhs_n_1 = calculate_rhs(w_l, w_n, r, dr, M, i_in)\n        w_l_1 = w_l + current_dt * rhs_l_1\n        w_n_1 = w_n + current_dt * rhs_n_1\n        \n        # Stage 2\n        rhs_l_2, rhs_n_2 = calculate_rhs(w_l_1, w_n_1, r, dr, M, i_in)\n        w_l_2 = 0.75 * w_l + 0.25 * (w_l_1 + current_dt * rhs_l_2)\n        w_n_2 = 0.75 * w_n + 0.25 * (w_n_1 + current_dt * rhs_n_2)\n\n        # Stage 3\n        rhs_l_3, rhs_n_3 = calculate_rhs(w_l_2, w_n_2, r, dr, M, i_in)\n        w_l = (1/3) * w_l + (2/3) * (w_l_2 + current_dt * rhs_l_3)\n        w_n = (1/3) * w_n + (2/3) * (w_n_2 + current_dt * rhs_n_3)\n        \n        t += current_dt\n        r_in -= current_dt # dr_in/dt = -1\n\n        i_in_new = np.searchsorted(r, r_in, side='left')\n        current_norm = l2_norm_combined(w_l, w_n, i_in_new, dr)\n        if current_norm > max_norm:\n            max_norm = current_norm\n    \n    G = max_norm / initial_norm\n    stable = G = 1.3\n    \n    i_in_final = np.searchsorted(r, r_in, side='left')\n    \n    # If all points are excised, constraint error is zero.\n    if i_in_final >= N or r[i_in_final:].size == 0:\n         return [stable, G, 0.0]\n\n    active_slice = slice(i_in_final, None)\n    active_r = r[active_slice]\n    active_wl = w_l[active_slice]\n    active_wn = w_n[active_slice]\n        \n    sqrt_gamma_rr = np.sqrt(np.divide(active_r, active_r + 2 * M))\n    Phi = np.divide(active_wn - active_wl, 2 * sqrt_gamma_rr, out=np.zeros_like(active_wn), where=(sqrt_gamma_rr > 1e-12))\n    \n    phi = np.zeros_like(Phi)\n    # Trapezoidal rule for integration\n    for i in range(1, len(phi)):\n        phi[i] = phi[i-1] + 0.5 * (Phi[i] + Phi[i-1]) * dr\n        \n    d_phi_num = np.zeros_like(phi)\n    if len(phi) > 1:\n        d_phi_num[0] = (phi[1] - phi[0]) / dr # Forward difference\n        d_phi_num[-1] = (phi[-1] - phi[-2]) / dr # Backward difference\n        # Centered difference for interior\n        for i in range(1, len(phi) - 1):\n            d_phi_num[i] = (phi[i+1] - phi[i-1]) / (2 * dr)\n    \n    C = d_phi_num - Phi\n    \n    norm_C = np.sqrt(np.sum(C**2) * dr)\n    norm_Phi = np.sqrt(np.sum(Phi**2) * dr)\n    \n    R = 0.0\n    if norm_Phi > 1e-12:\n        R = norm_C / norm_Phi\n\n    return [stable, float(G), float(R)]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在理解了切除的因果原理后，我们必须在离散的计算网格上实现它，这通常是在笛卡尔坐标系下完成的。本练习探讨了这一过程带来的一个实际后果：切除区域“掩码”的几何形状选择（例如球形与立方体）会引入不同程度的离散化误差。通过定量比较这些掩码，我们可以深入了解在网格上用“阶梯状”结构近似光滑曲面，是如何影响我们模拟的整体精度的。",
            "id": "3465595",
            "problem": "考虑一个各向同性笛卡尔坐标系下单个无自旋黑洞的时间对称初始数据切片，其中物理空间度规是共形平坦的，由 $g_{ij} = \\psi^4 \\delta_{ij}$ 给出，对于一个 Schwarzschild 质量为 $M$ 的黑洞，其共形因子为 $\\psi(\\mathbf{x}) = 1 + \\dfrac{M}{2 r}$，其中 $r = \\sqrt{x^2 + y^2 + z^2}$。在这样的切片上，广义相对论的哈密顿约束简化为要求共形度规的里奇标量在源之外为零，对于共形平坦形式，这意味着平直空间中的拉普拉斯方程 $\\nabla^2 \\psi = 0$（对于 $r  0$）成立。在采用黑洞切除的数值相对论中，为了避免物理奇点，会移除事件视界内部切除掩模（excision mask）内的网格点。在笛卡尔网格上，切除掩模的几何形状和方向可能会在切除边界附近的有限差分导数近似中引入与方向相关的离散化误差。\n\n你的任务是定量比较在与事件视界距离相同的情况下，笛卡尔网格上球形与立方体形切除掩模的差异，并为每种情况报告两个标量：\n- 一个离散哈密顿约束残差范数，计算为在掩模之外所有可用点上离散拉普拉斯算子 $\\nabla^2 \\psi$ 的均方根。\n- 一个与方向相关的度规误差，计算为在紧邻切除边界的点上，数值近似的轴向二阶导数 $\\partial^2 \\psi / \\partial x^2$、$\\partial^2 \\psi / \\partial y^2$、$\\partial^2 \\psi / \\partial z^2$ 与其解析值之间差异的均方根。\n\n需要使用的基本公式和定义：\n- 共形因子为 $\\psi(\\mathbf{x}) = 1 + \\dfrac{M}{2 r}$，其中 $r = \\sqrt{x^2 + y^2 + z^2}$。\n- 在各向同性坐标系中，事件视界位于半径 $r_h = \\dfrac{M}{2}$ 处。\n- 切除掩模半径定义为 $r_{\\mathrm{ex}} = r_h - \\Delta$，其中 $\\Delta  0$ 是到视界的指定距离。切除区域必须满足 $r_{\\mathrm{ex}}  0$。\n- 球形掩模：切除所有满足 $r  r_{\\mathrm{ex}}$ 的点。\n- 立方体掩模：切除所有满足 $\\max\\left(|x'|,|y'|,|z'|\\right)  r_{\\mathrm{ex}}$ 的点，其中 $(x',y',z')$ 是坐标 $(x,y,z)$ 绕 $z$ 轴进行平面内旋转角度 $\\theta$ 后的坐标，由下式给出：\n$$\n\\begin{pmatrix}\nx' \\\\ y' \\\\ z'\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\cos\\theta  \\sin\\theta  0 \\\\\n-\\sin\\theta  \\cos\\theta  0 \\\\\n0  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\nx \\\\ y \\\\ z\n\\end{pmatrix}.\n$$\n此选择使得从原点到立方体掩模的最小距离等于 $r_{\\mathrm{ex}}$，与球形情况相匹配，从而确保了与视界的距离相同。\n\n用于误差评估的 $\\psi$ 的解析二阶导数可由 $1/r$ 的 Hessian 矩阵得出，\n$$\n\\frac{\\partial^2}{\\partial x_i \\partial x_j} \\left(\\frac{1}{r}\\right) = \\frac{3 x_i x_j - r^2 \\delta_{ij}}{r^5}, \\quad r \\neq 0,\n$$\n因此\n$$\n\\frac{\\partial^2 \\psi}{\\partial x^2} = \\frac{M}{2}\\,\\frac{3 x^2 - r^2}{r^5}, \\quad\n\\frac{\\partial^2 \\psi}{\\partial y^2} = \\frac{M}{2}\\,\\frac{3 y^2 - r^2}{r^5}, \\quad\n\\frac{\\partial^2 \\psi}{\\partial z^2} = \\frac{M}{2}\\,\\frac{3 z^2 - r^2}{r^5},\n$$\n且解析拉普拉斯算子 $\\nabla^2 \\psi = 0$（对于 $r \\neq 0$）。\n\n在间距为 $h$ 的均匀笛卡尔网格上需实现的离散化规则：\n- 当沿某个轴的两个直接相邻点都可用且未被切除时，使用二阶中心差分近似计算二阶导数：\n$$\n\\left.\\frac{\\partial^2 \\psi}{\\partial x^2}\\right|_{i,j,k} \\approx \\frac{\\psi_{i+1,j,k} - 2 \\psi_{i,j,k} + \\psi_{i-1,j,k}}{h^2},\n$$\n$y$ 和 $z$ 方向同理。\n- 如果沿某个轴的中心相邻点被切除或在计算域之外，但在该轴的另一侧有两个连续的点可用且未被切除，则使用单侧二阶近似：\n$$\n\\left.\\frac{\\partial^2 \\psi}{\\partial x^2}\\right|_{i,j,k} \\approx \\frac{\\psi_{i,j,k} - 2 \\psi_{i\\pm 1,j,k} + \\psi_{i\\pm 2,j,k}}{h^2},\n$$\n其中符号 $\\pm$ 根据可用的一侧选择向前（$+$）或向后（$-$）方向。如果中心和单侧模板都无法构成，则该点的导数被视为不可用。\n- 仅当某点的三个轴向二阶导数均可用时，该点的离散拉普拉斯算子才是这三个导数的和。\n- 如果一个点未被切除，且其沿任意轴至少有一个直接相邻点被切除，则定义该点为“近边界”点。\n\n每个测试案例需计算并报告的量：\n- 哈密顿约束残差范数，定义为 $\\sqrt{\\dfrac{1}{N}\\sum_{\\mathrm{usable}} \\left(\\nabla^2 \\psi\\right)^2}$，求和遍及掩模外所有三个轴向二阶导数均可用的点（$N$ 为此类点的数量）。\n- 与方向相关的度规误差，定义为在近边界点上，数值和解析轴向二阶导数之间差异的均方根，即：\n$$\n\\sqrt{\\dfrac{1}{N_{\\mathrm{axes}}} \\sum_{\\mathrm{near\\,boundary}} \\sum_{a \\in \\{x,y,z\\}} \\left( D_{aa}^{\\mathrm{num}} - D_{aa}^{\\mathrm{analytic}} \\right)^2 },\n$$\n其中 $D_{aa}^{\\mathrm{num}}$ 是数值轴向二阶导数，$D_{aa}^{\\mathrm{analytic}}$ 是对应的解析值；求和仅包含数值导数可用的轴（$N_{\\mathrm{axes}}$ 统计此类轴的贡献数量）。\n\n角度必须以弧度为单位指定。所有计算输出均为无单位实数。在一个均匀间距为 $h$ 的立方体域 $[-L,L]^3$ 上实现计算。\n\n测试套件：\n- 案例 1：球形掩模，$M = 1.0$, $L = 0.6$, $h = 0.02$, $\\Delta = 0.05$, $\\theta = 0.0$（忽略）。\n- 案例 2：与网格对齐的立方体掩模，$M = 1.0$, $L = 0.6$, $h = 0.02$, $\\Delta = 0.05$, $\\theta = 0.0$。\n- 案例 3：旋转后的立方体掩模，$M = 1.0$, $L = 0.6$, $h = 0.02$, $\\Delta = 0.05$, $\\theta = \\pi/4$。\n\n最终输出格式：\n你的程序应生成单行输出，包含按 $[\\text{C}_1,\\text{E}_1,\\text{C}_2,\\text{E}_2,\\text{C}_3,\\text{E}_3]$ 顺序排列的六个结果，其中 $\\text{C}_i$ 是案例 $i$ 的约束残差范数，$\\text{E}_i$ 是案例 $i$ 的度规误差，形式为一个用方括号括起来的逗号分隔列表（例如，$[0.00123,0.00456,0.00101,0.00480,0.00105,0.00490]$）。所有值必须是无单位的实数。",
            "solution": "所提出的问题是数值相对论中一个定义明确的练习，具体涉及在笛卡尔网格上实现和评估黑洞切除技术。它要求通过计算两个不同的误差度量——哈密顿约束残差范数和与方向相关的度规误差，来定量比较两种常见的切除掩模几何形状（球形和立方体形）。所有给出的物理定义、数学公式和数值规则都是科学上合理的，构成了一个自洽且可解的问题。给定的参数值在物理上和计算上都是合理的。因此，该问题被认为是有效的，并给出完整解答。\n\n任务的核心是将一个已知的解析解——各向同性坐标下 Schwarzschild 黑洞的共形因子——在三维笛卡尔网格上离散化，应用不同的切除掩模，然后计算在所创建的边界附近由有限差分近似产生的误差。\n\n### 基于原理的解决方案设计\n\n解决方案围绕一个主函数构建，该函数通过执行一系列源自数值分析和计算物理原理的步骤来处理每个测试案例。\n\n1.  **网格与场初始化**：在域 $[-L, L]^3$ 上构建一个间距为 $h$ 的均匀三维笛卡尔网格。在此网格上，我们计算解析共形因子 $\\psi(\\mathbf{x}) = 1 + \\frac{M}{2r}$ 及其二阶偏导数 $\\frac{\\partial^2 \\psi}{\\partial x_i^2}$。径向坐标为 $r = \\sqrt{x^2+y^2+z^2}$。为防止在原点（$r=0$）处出现除以零的错误，在计算中给 $r$ 增加一个微小的 epsilon。这无关紧要，因为原点始终在切除区域内（$r_{ex}  0$），因此在所有后续计算中都被排除。\n\n2.  **切除掩模生成**：对每个测试案例，生成一个布尔掩模 `is_excised`。这个三维数组标识了落入切除区域内、应在导数计算中忽略的网格点。\n    *   **球形掩模**：如果一个点坐标为 $(x, y, z)$，其径向距离 $r = \\sqrt{x^2+y^2+z^2}$ 小于切除半径 $r_{\\mathrm{ex}} = \\frac{M}{2} - \\Delta$，则该点被切除。\n    *   **立方体掩模**：如果一个点 $(x, y, z)$ 的坐标在绕 $z$ 轴旋转角度 $\\theta$ 后满足 $\\max(|x'|, |y'|, |z'|)  r_{\\mathrm{ex}}$，则该点被切除。旋转后的坐标由 $x' = x \\cos\\theta + y \\sin\\theta$ 和 $y' = -x \\sin\\theta + y \\cos\\theta$ 给出。\n\n3.  **使用模板层次结构的数值微分**：关键步骤是使用有限差分近似二阶导数。问题指定了要使用的模板层次结构，这是有限差分方法中处理边界的标准做法。对于每个未被切除的点和每个空间方向，我们按以下优先级顺序应用：\n    a.  **二阶中心差分**：$\\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{h^2}$。这是首选的模板，当两个直接相邻点都可用时（即在网格域内且未被切除）使用。\n    b.  **单侧差分（向前）**：如果中心差分模板不可用，我们尝试使用单侧模板。根据指定的公式，向前模板为 $\\frac{\\psi_i - 2\\psi_{i+1} + \\psi_{i+2}}{h^2}$。如果前面的两个相邻点都可用，则尝试此方法。\n    c.  **单侧差分（向后）**：如果中心和向前模板都无法应用，我们尝试向后模板 $\\frac{\\psi_i - 2\\psi_{i-1} + \\psi_{i-2}}{h^2}$，前提是后面的两个相邻点都可用。\n    d.  **不可用导数**：如果这些模板都无法构成，则该点在该轴上的导数被视为不可用，并作相应标记（例如，使用 `NaN`）。\n\n    对三个空间导数 $\\frac{\\partial^2 \\psi}{\\partial x^2}$、$\\frac{\\partial^2 \\psi}{\\partial y^2}$ 和 $\\frac{\\partial^2 \\psi}{\\partial z^2}$ 都实施此逻辑，得到三个数值导数值数组。\n\n4.  **误差度量计算**：在计算出解析和数值导数后，我们可以评估所需的两个误差度量。\n    *   **哈密顿约束残差范数 ($C$)**：通过对三个数值二阶导数求和，计算每个点的离散拉普拉斯算子 $\\nabla^2_h \\psi$。只有当一个点的所有三个轴向导数都可用时，该点才对该计算有贡献。然后，范数是这些拉普拉斯算子值在所有此类可用点上的均方根（RMS）。由于解析拉普拉斯算子为零，该范数直接衡量了哈密顿约束的离散化误差。\n    *   **与方向相关的度规误差 ($E$)**：此误差专门在邻近切除边界的点上计算。首先，我们识别所有“近边界”点，定义为未被切除且至少有一个直接相邻的被切除邻居的点。然后，对于这个点的子集，我们计算数值和解析二阶导数之间差异的均方根，该差异在数值导数可用的所有三个轴上求和。该度量旨在捕捉由切除表面的锯齿状、网格对齐表示法附近的模板选择所引入的局部、与方向相关的误差。\n\n整个过程被封装起来并为三个测试案例中的每一个执行，得到的六个标量值被格式化为所需的输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        {'type': 'spherical', 'M': 1.0, 'L': 0.6, 'h': 0.02, 'Delta': 0.05, 'theta': 0.0},\n        {'type': 'cubical',   'M': 1.0, 'L': 0.6, 'h': 0.02, 'Delta': 0.05, 'theta': 0.0},\n        {'type': 'cubical',   'M': 1.0, 'L': 0.6, 'h': 0.02, 'Delta': 0.05, 'theta': np.pi/4},\n    ]\n\n    results = []\n    for case in test_cases:\n        C, E = solve_case(case)\n        results.extend([C, E])\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_case(params):\n    \"\"\"\n    Solves for a single test case configuration.\n    \"\"\"\n    M, L, h, Delta = params['M'], params['L'], params['h'], params['Delta']\n    mask_type, theta = params['type'], params['theta']\n    \n    r_h = M / 2.0\n    r_ex = r_h - Delta\n\n    # 1. Grid and Field Initialization\n    n_pts = int(2 * L / h) + 1\n    coords_1d = np.linspace(-L, L, n_pts)\n    X, Y, Z = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n\n    # Add a small epsilon to avoid division by zero at r=0.\n    # The origin is always excised as r_ex > 0.\n    R = np.sqrt(X**2 + Y**2 + Z**2)\n    R_safe = R + 1e-15 \n\n    psi = 1.0 + M / (2.0 * R_safe)\n    \n    # Analytic second derivatives\n    R5 = R_safe**5\n    d2psi_dx2_an = (M / 2.0) * (3 * X**2 - R_safe**2) / R5\n    d2psi_dy2_an = (M / 2.0) * (3 * Y**2 - R_safe**2) / R5\n    d2psi_dz2_an = (M / 2.0) * (3 * Z**2 - R_safe**2) / R5\n\n    # 2. Excision Mask Generation\n    if mask_type == 'spherical':\n        is_excised = R  r_ex\n    elif mask_type == 'cubical':\n        cos_t, sin_t = np.cos(theta), np.sin(theta)\n        X_prime = X * cos_t + Y * sin_t\n        Y_prime = -X * sin_t + Y * cos_t\n        Z_prime = Z\n        is_excised = np.maximum(np.abs(X_prime), np.maximum(np.abs(Y_prime), np.abs(Z_prime)))  r_ex\n\n    # 3. Numerical Differentiation\n    d2psi_dx2_num, d2psi_dy2_num, d2psi_dz2_num = compute_numerical_derivatives(psi, h, is_excised)\n\n    # 4. Calculation of Error Metrics\n    \n    # Hamiltonian Constraint Residual Norm (C)\n    laplacian_num = np.full_like(psi, np.nan)\n    valid_lap_mask = ~np.isnan(d2psi_dx2_num)  ~np.isnan(d2psi_dy2_num)  ~np.isnan(d2psi_dz2_num)\n    laplacian_num[valid_lap_mask] = d2psi_dx2_num[valid_lap_mask] + d2psi_dy2_num[valid_lap_mask] + d2psi_dz2_num[valid_lap_mask]\n    \n    usable_laplacians = laplacian_num[~np.isnan(laplacian_num)]\n    if len(usable_laplacians) > 0:\n        constraint_norm = np.sqrt(np.mean(usable_laplacians**2))\n    else:\n        constraint_norm = 0.0\n\n    # Orientation-Dependent Metric Error (E)\n    is_near_boundary = np.zeros_like(psi, dtype=bool)\n    indices = np.argwhere(~is_excised)\n    for i, j, k in indices:\n        for di, dj, dk in [(-1,0,0), (1,0,0), (0,-1,0), (0,1,0), (0,0,-1), (0,0,1)]:\n            ni, nj, nk = i + di, j + dj, k + dk\n            if 0 = ni  n_pts and 0 = nj  n_pts and 0 = nk  n_pts:\n                if is_excised[ni, nj, nk]:\n                    is_near_boundary[i, j, k] = True\n                    break\n\n    sq_errors = []\n    near_boundary_indices = np.argwhere(is_near_boundary)\n    for i, j, k in near_boundary_indices:\n        if not np.isnan(d2psi_dx2_num[i, j, k]):\n            err = d2psi_dx2_num[i, j, k] - d2psi_dx2_an[i, j, k]\n            sq_errors.append(err**2)\n        if not np.isnan(d2psi_dy2_num[i, j, k]):\n            err = d2psi_dy2_num[i, j, k] - d2psi_dy2_an[i, j, k]\n            sq_errors.append(err**2)\n        if not np.isnan(d2psi_dz2_num[i, j, k]):\n            err = d2psi_dz2_num[i, j, k] - d2psi_dz2_an[i, j, k]\n            sq_errors.append(err**2)\n\n    if len(sq_errors) > 0:\n        metric_error = np.sqrt(np.mean(sq_errors))\n    else:\n        metric_error = 0.0\n        \n    return constraint_norm, metric_error\n\n\ndef compute_numerical_derivatives(psi, h, is_excised):\n    \"\"\"\n    Computes all three second partial derivatives using a hierarchical stencil choice.\n    \"\"\"\n    n_pts = psi.shape[0]\n    derivs = []\n    \n    for axis in range(3):  # 0 for x, 1 for y, 2 for z\n        d2psi_d_axis_2 = np.full_like(psi, np.nan)\n        \n        # To handle different axes generically, we transpose the arrays\n        psi_ax = np.transpose(psi, (axis, (axis + 1) % 3, (axis + 2) % 3))\n        is_excised_ax = np.transpose(is_excised, (axis, (axis + 1) % 3, (axis + 2) % 3))\n        \n        indices = np.argwhere(~is_excised_ax)\n        \n        for i, j, k in indices:\n            # Central difference\n            if 0  i  n_pts - 1 and not is_excised_ax[i-1, j, k] and not is_excised_ax[i+1, j, k]:\n                d2psi_d_axis_2[i,j,k] = (psi_ax[i+1, j, k] - 2 * psi_ax[i, j, k] + psi_ax[i-1, j, k]) / h**2\n            # One-sided forward difference\n            elif i  n_pts - 2 and not is_excised_ax[i+1, j, k] and not is_excised_ax[i+2, j, k]:\n                d2psi_d_axis_2[i,j,k] = (psi_ax[i, j, k] - 2 * psi_ax[i+1, j, k] + psi_ax[i+2, j, k]) / h**2\n            # One-sided backward difference\n            elif i > 1 and not is_excised_ax[i-1, j, k] and not is_excised_ax[i-2, j, k]:\n                 d2psi_d_axis_2[i,j,k] = (psi_ax[i, j, k] - 2 * psi_ax[i-1, j, k] + psi_ax[i-2, j, k]) / h**2\n        \n        # Transpose back to original orientation\n        d2psi_d_axis_2 = np.transpose(d2psi_d_axis_2, np.argsort((axis, (axis + 1) % 3, (axis + 2) % 3)))\n        derivs.append(d2psi_d_axis_2)\n        \n    return derivs[0], derivs[1], derivs[2]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在数值相对论中，模拟的长期稳定性至关重要。虽然简单的迎风格式可以为一些模型提供稳定性，但更复杂的系统需要一个在数学上更严谨的框架来处理边界条件。本练习介绍了强大的“分部求和”（Summation-By-Parts, SBP）与“同步近似项”（Simultaneous Approximation Term, SAT）方法，它通过在离散层面模仿连续方程的能量守恒特性，使我们能够严格证明并保证数值方案的稳定性。这是现代高精度数值相对论程序设计的基石之一。",
            "id": "3465576",
            "problem": "考虑一个用于描述黑洞演化在切除面 $r=r_{\\mathrm{exc}}$ 附近的单个线性化约束场 $c(r,t)$ 的一维半离散模型，该模型例如出现在数值相对论的 Baumgarte–Shapiro–Shibata–Nakamura (BSSN) 或广义谐波形式中。假设约束 $c$ 满足一个线性常系数对称双曲平流方程，其输运由沿径向坐标 $r$ 的位移主导，在切除面附近指向切除区域内部，即 $c_{t} + a\\,c_{r} = 0$，其中 $a0$。计算域为 $r \\in [r_{\\mathrm{exc}},r_{\\mathrm{out}}]$，内边界位于 $r=r_{\\mathrm{exc}}$，外边界位于 $r=r_{\\mathrm{out}}$。定义一个均匀间距为 $h$ 的网格，其节点为 $r_{i} = r_{\\mathrm{exc}} + i h$，其中 $i=0,1,\\dots,N$。\n\n对一阶导数 $c_r$ 使用高阶分部求和（SBP）有限差分近似，其具有一个对角范数矩阵 $H$ 和一个半离散导数算子 $D$。对于某个整数 $p \\geq 3$，$D$ 的内部阶为 $2p$，边界阶为 $p$（即高多项式阶）。SBP 性质表述为 $H D + D^{T} H = B$，其中 $B$ 是一个对称矩阵，表示一个与分部积分一致的离散边界算子，$B = - e_{0} e_{0}^{T} + e_{N} e_{N}^{T}$，而 $e_{0}$ 和 $e_{N}$ 分别是选取内外边界网格点的坐标向量。在切除内边界（$i=0$）附近，边界差分格式的宽度为 $s$，其构造需在保持 SBP 性质的同时达到 $p$ 阶相容性，外边界（$i=N$）的情况也类似。\n\n采用同步近似项（SAT）弱边界处理方法。对于齐次保约束边界条件，在内边界（切除面）取 $g_{0}=0$，在外边界取 $g_{N}=0$。该半离散 SBP–SAT 格式为\n$$\nc_{t} = - a\\,D\\,c + H^{-1}\\left[a\\,\\sigma_{0}\\,e_{0}\\left(c_{0} - g_{0}\\right) + a\\,\\sigma_{N}\\,e_{N}\\left(c_{N} - g_{N}\\right)\\right],\n$$\n其中 $\\sigma_{0}$ 和 $\\sigma_{N}$ 是为保证稳定性而选择的常数惩罚参数。\n\n任务：\n- 从线性对称双曲系统的连续能量方法和 SBP 性质出发，推导 $E(t) = c^{T} H c$ 的离散能量估计，并清晰地展示边界通量和 SAT 贡献项。\n- 对于切除内边界（$i=0$），论证一个与物理流出（$a0$）及无传入特征相一致的保约束 SAT 选择。对于外边界（$i=N$），通过 SAT 弱施加齐次约束 $c_{N}=0$。\n- 在不使用任何具体的闭式格式系数，仅依赖于 SBP 性质和 SAT 形式的情况下，确定外部惩罚系数 $\\sigma_{N}$ 的最小值，该值需保证对于任意高多项式阶 $p \\geq 3$ 和所有网格函数 $c$，离散能量 $E(t)$ 都是非增的。给出你的最终答案，形式为一个精确数。\n\n注：你可以假设存在内部阶为 $2p$、边界阶为 $p$ 的对角范数 SBP 算子，并且内边界严格位于视界内部，从而使得在 $r=r_{\\mathrm{exc}}$ 处的所有物理特征速度都指向切除区域内部。",
            "solution": "该问题要求分析一个用于模拟黑洞切除背景下约束场的线性平流方程的半离散分部求和（SBP）和同步近似项（SAT）数值格式的稳定性。分析将分三个阶段进行：首先，推导离散能量估计；其次，论证边界条件的实施；第三，确定保证稳定性的最小惩罚参数 $\\sigma_{N}$。\n\n我们首先推导离散能量估计。系统的离散能量定义为使用 SBP 范数矩阵 $H$ 的二次型：\n$$\nE(t) = c(t)^{T} H c(t)\n$$\n其中 $c(t)$ 是网格函数值 $c_{i}(t)$ 的向量。为了求能量的变化率，我们将 $E(t)$ 对时间 $t$ 求导。利用微分的乘法法则，并注意到向量 $c$ 依赖于时间而矩阵 $H$ 是常数，我们得到：\n$$\n\\frac{dE}{dt} = \\frac{d}{dt}(c^{T} H c) = \\dot{c}^{T} H c + c^{T} H \\dot{c}\n$$\n由于 $H$ 是一个对称矩阵（$H = H^{T}$），这两项是相等的：$(\\dot{c}^{T} H c)^{T} = c^{T} H^{T} \\dot{c} = c^{T} H \\dot{c}$。因此，我们可以写成：\n$$\n\\frac{dE}{dt} = 2 c^{T} H \\dot{c}\n$$\n问题给出了 $\\dot{c}$（我们记作 $c_{t}$）的半离散演化方程：\n$$\n\\dot{c} = - a\\,D\\,c + H^{-1}\\left[a\\,\\sigma_{0}\\,e_{0}\\left(c_{0} - g_{0}\\right) + a\\,\\sigma_{N}\\,e_{N}\\left(c_{N} - g_{N}\\right)\\right]\n$$\n代入齐次边界数据 $g_{0}=0$ 和 $g_{N}=0$，方程简化为：\n$$\n\\dot{c} = - a\\,D\\,c + a\\,H^{-1}\\left[\\sigma_{0}\\,e_{0}c_{0} + \\sigma_{N}\\,e_{N}c_{N}\\right]\n$$\n现在，将这个 $\\dot{c}$ 的表达式代入能量变化率方程：\n$$\n\\frac{dE}{dt} = 2 c^{T} H \\left( - a\\,D\\,c + a\\,H^{-1}\\left[\\sigma_{0}\\,e_{0}c_{0} + \\sigma_{N}\\,e_{N}c_{N}\\right] \\right)\n$$\n将 $2c^{T} H$ 项展开得到：\n$$\n\\frac{dE}{dt} = -2a\\,c^{T} H D c + 2a\\,c^{T} H H^{-1}\\left[\\sigma_{0}\\,e_{0}c_{0} + \\sigma_{N}\\,e_{N}c_{N}\\right]\n$$\n第一项包含表达式 $c^{T} H D c$。我们可以使用 SBP 性质来简化它。该性质表明 $H D + D^{T} H = B$。这使我们能够写出 $2 c^{T} H D c = c^{T} H D c + (c^{T} H D c)^{T} = c^{T} H D c + c^{T} D^{T} H^{T} c$。由于 $H=H^{T}$，这变为 $c^{T}(HD + D^{T}H)c = c^{T}Bc$。\n第二项可简化，因为 $H H^{-1} = I$（单位矩阵）。所以，$c^{T} H H^{-1}[\\dots] = c^{T}[\\dots]$。方括号中的项涉及边界选择向量 $e_{0}$ 和 $e_{N}$。我们利用关系式 $c^{T}e_{0} = c_{0}$ 和 $c^{T}e_{N} = c_{N}$ 得到：\n$$\nc^{T}\\left[\\sigma_{0}\\,e_{0}c_{0} + \\sigma_{N}\\,e_{N}c_{N}\\right] = \\sigma_{0}(c^{T}e_{0})c_{0} + \\sigma_{N}(c^{T}e_{N})c_{N} = \\sigma_{0}c_{0}^{2} + \\sigma_{N}c_{N}^{2}\n$$\n结合这些简化，能量变化率变为：\n$$\n\\frac{dE}{dt} = -a (c^{T} B c) + 2a (\\sigma_{0}c_{0}^{2} + \\sigma_{N}c_{N}^{2})\n$$\n接下来，我们代入给定的边界算子矩阵形式 $B = - e_{0} e_{0}^{T} + e_{N} e_{N}^{T}$。二次型 $c^{T} B c$ 的计算结果为：\n$$\nc^{T} B c = c^{T}(- e_{0} e_{0}^{T} + e_{N} e_{N}^{T})c = -(c^{T}e_{0})(e_{0}^{T}c) + (c^{T}e_{N})(e_{N}^{T}c) = -c_{0}^{2} + c_{N}^{2}\n$$\n将此结果代入能量变化率方程，得到我们能量估计的最终表达式：\n$$\n\\frac{dE}{dt} = -a(-c_{0}^{2} + c_{N}^{2}) + 2a\\sigma_{0}c_{0}^{2} + 2a\\sigma_{N}c_{N}^{2}\n$$\n将对应于每个边界的项分组，我们便得到了离散能量估计，这完成了第一项任务：\n$$\n\\frac{dE}{dt} = a(1+2\\sigma_{0})c_{0}^{2} + a(2\\sigma_{N}-1)c_{N}^{2}\n$$\n\n对于第二项任务，我们论证边界条件的选择。控制偏微分方程为 $c_{t} + a\\,c_{r} = 0$。该方程的特征线是满足 $dr/dt = a$ 的线。由于给定 $a0$，信息沿 $r$ 减小的方向传播。\n在内边界（切除面）$r=r_{\\mathrm{exc}}$（对应于 $i=0$），特征线正离开计算域 $[r_{\\mathrm{exc}}, r_{\\mathrm{out}}]$。这是一个流出边界。对于此类边界，解由域内的数据确定，不应施加外部边界条件。来自此边界的能量变化率贡献为 $a(1+2\\sigma_{0})c_{0}^{2}$。仅 SBP 算子一项就提供了 $ac_{0}^{2}$ 这一项。由于 $a0$，该项为非正，代表了物理上正确的能量流出和一个稳定的贡献。SAT 项 $2a\\sigma_{0}c_{0}^{2}$ 引入了一个惩罚项。为避免在此流出边界上施加人为约束，最自然且保约束的选择是使惩罚项为零。这通过设置 $\\sigma_{0}=0$ 来实现。这个选择是稳定的，因为总贡献 $ac_{0}^{2}$ 保持非正。\n\n在外边界 $r=r_{\\mathrm{out}}$（对应于 $i=N$），特征线正进入计算域。这是一个流入边界，需要指定边界条件以构成一个适定问题。问题指定了施加齐次约束 $c_{N}=0$，这是通过 $g_{N}=0$ 的 SAT 项来弱施加的。来自此边界的能量变化率贡献为 $a(2\\sigma_{N}-1)c_{N}^{2}$。仅来自 SBP 格式的项是 $-ac_{N}^{2}$。由于 $a0$，这个 SBP 项是正的，代表了可能导致不稳定性的能量流入。必须选择 SAT 惩罚项 $2a\\sigma_{N}c_{N}^{2}$ 来控制这种不稳定性。\n\n这就引出了第三项任务：确定保证稳定性（即对任意网格函数 $c$ 都有 $\\frac{dE}{dt} \\le 0$）的 $\\sigma_{N}$ 的最小值。根据我们 $\\sigma_{0}=0$ 的选择，能量变化率简化为：\n$$\n\\frac{dE}{dt} = a c_{0}^{2} + a(2\\sigma_{N}-1)c_{N}^{2}\n$$\n第一项 $a c_{0}^{2}$ 总是非正的，因为 $a0$ 且 $c_{0}^{2} \\ge 0$。为保证 $\\frac{dE}{dt} \\le 0$，第二项对于 $c_N$ 的任何值也必须是非正的：\n$$\na(2\\sigma_{N}-1)c_{N}^{2} \\le 0\n$$\n由于 $a0$ 且 $c_{N}^{2} \\ge 0$，该不等式成立当且仅当剩下的因子大于或等于零：\n$$\n2\\sigma_{N}-1 \\ge 0\n$$\n解出 $\\sigma_{N}$ 得到条件：\n$$\n\\sigma_{N} \\ge \\frac{1}{2}\n$$\n问题要求的是保证能量非增的 $\\sigma_{N}$ 的最小值。这对应于所推导不等式的下界。因此，最小值为 $\\sigma_{N} = \\frac{1}{2}$。值得注意的是，这个结果仅依赖于基本的 SBP 性质和 SAT 的形式，因此与具体的 SBP 算子或其多项式阶 $p$ 无关。通过这个选择，外边界项变为 $a(2(\\frac{1}{2})-1)c_{N}^{2} = 0$，正好抵消了来自 SBP 算子的不稳定能量流入。",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        }
    ]
}