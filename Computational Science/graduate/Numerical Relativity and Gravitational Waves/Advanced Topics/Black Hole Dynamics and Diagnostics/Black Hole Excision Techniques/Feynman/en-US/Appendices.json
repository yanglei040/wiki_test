{
    "hands_on_practices": [
        {
            "introduction": "At the heart of the excision technique is the need to compute spatial derivatives at grid points adjacent to the artificial inner boundary. Standard centered-difference stencils are not viable as they would require data from within the excised region. This exercise guides you through the foundational process of deriving high-order, one-sided finite-difference stencils from first principles, providing the essential mathematical tools for implementing accurate boundary conditions in finite-difference codes. By working through the Taylor series derivation and analyzing the resulting operator's truncation error and stability properties, you will gain a deep understanding of the numerical building blocks of excision .",
            "id": "3465547",
            "problem": "Consider a spherical excision region of radius $R$ centered at the origin in a three-dimensional Cartesian grid with uniform spacing $h$ in each coordinate direction. Let the outward unit normal at a point on the excision surface be $\\mathbf{n} = (n_{x}, n_{y}, n_{z})$ with $|\\mathbf{n}| = 1$. In a first-order symmetric-hyperbolic formulation used in numerical relativity, local outgoing characteristic fields near the excision boundary satisfy a radial advection equation of the form $\\partial_{t} u + c \\,\\partial_{r} u = 0$, where $u(\\mathbf{x},t)$ denotes a scalar characteristic field and $c  0$ is the characteristic speed measured along $\\mathbf{n}$. Because the interior points of the sphere are removed by excision, any finite-difference operator used to approximate spatial derivatives at boundary-adjacent grid points must be one-sided in the outward directions.\n\nStarting from Taylor expansions and the definition of the directional derivative $\\partial_{r} u = \\mathbf{n}\\cdot\\nabla u = n_{x}\\,\\partial_{x} u + n_{y}\\,\\partial_{y} u + n_{z}\\,\\partial_{z} u$, perform the following tasks:\n\n1. Derive a one-dimensional, six-point forward (one-sided) finite-difference stencil on a uniform Cartesian line that approximates $\\partial_{x} u$ at a boundary-adjacent point $x_{0}$ using grid values $\\{u(x_{0}), u(x_{0}+h), \\dots, u(x_{0}+5h)\\}$, with formal accuracy order five. Work from first principles by matching Taylor series coefficients so that the discrete operator reproduces the first derivative of polynomials up to degree five at $x_{0}$.\n\n2. Using the result of part 1 for each Cartesian coordinate direction, write an explicit formula that approximates the radial derivative $\\partial_{r} u$ at a boundary-adjacent grid point as a linear combination of the one-sided operators in the $x$, $y$, and $z$ directions with weights $n_{x}$, $n_{y}$, and $n_{z}$.\n\n3. Determine the leading-order truncation error of the one-dimensional stencil from part 1. Specifically, find the constant multiplying $h^{5} u^{(6)}(x_{0})$ in the error expansion of the discrete approximation to $\\partial_{x} u$, where $u^{(p)}$ denotes the $p$-th derivative with respect to $x$ at $x_{0}$.\n\n4. For the semi-discrete method-of-lines formulation of the linear advection equation $\\partial_{t} u + c \\,\\partial_{r} u = 0$ closed by the one-sided directional operator derived above, integrated in time with the classical fourth-order Runge–Kutta method, provide a sufficient Courant–Friedrichs–Lewy (CFL) stability constraint on the timestep $\\Delta t$ in symbolic form. Express your constraint in terms of $h$, $c$, and the spectral radius of the discrete spatial operator’s Fourier symbol; define any symbols you introduce. Discuss why one-sidedness is mandated by excision and how it affects the spectral properties relevant to stability.\n\nAs your final answer, report only the ordered row of the six stencil weights (from $m=0$ to $m=5$) for the one-dimensional forward approximation to $\\partial_{x} u$ and the leading-order truncation-error constant found in part 3. No rounding is required, and no units should be included in your final answer.",
            "solution": "The problem posed is a well-defined exercise in numerical analysis, specifically in the construction and analysis of finite-difference methods for hyperbolic partial differential equations, framed within the context of numerical relativity. It is scientifically grounded, self-contained, and objective. Therefore, I will proceed with a full solution.\n\n### Part 1: Derivation of the Six-Point, Fifth-Order Forward Difference Stencil\n\nWe seek a finite-difference approximation for the first derivative $\\partial_x u$ at a point $x_0$ of the form:\n$$\nD_x u(x_0) = \\frac{1}{h} \\sum_{m=0}^{5} a_m u(x_0 + m h)\n$$\nThis approximation must have a formal accuracy of order five. This means the operator must be exact for all polynomials of degree up to five. We can achieve this by using Taylor series expansions of $u(x_0 + m h)$ around $x_0$ and matching coefficients.\n\nThe Taylor expansion of $u(x_0 + m h)$ is:\n$$\nu(x_0 + m h) = \\sum_{k=0}^{\\infty} \\frac{(m h)^k}{k!} u^{(k)}(x_0)\n$$\nwhere $u^{(k)}(x_0)$ denotes the $k$-th derivative of $u$ with respect to $x$ evaluated at $x_0$.\n\nSubstituting this into the finite-difference formula:\n\\begin{align*}\nD_x u(x_0) = \\frac{1}{h} \\sum_{m=0}^{5} a_m \\left( \\sum_{k=0}^{\\infty} \\frac{(m h)^k}{k!} u^{(k)}(x_0) \\right) \\\\\n= \\sum_{k=0}^{\\infty} \\frac{h^{k-1}}{k!} \\left( \\sum_{m=0}^{5} a_m m^k \\right) u^{(k)}(x_0) \\\\\n= \\frac{1}{h} \\left( \\sum_{m=0}^{5} a_m \\right) u^{(0)}(x_0) + \\left( \\sum_{m=0}^{5} a_m m \\right) u^{(1)}(x_0) + \\frac{h}{2} \\left( \\sum_{m=0}^{5} a_m m^2 \\right) u^{(2)}(x_0) + \\dots\n\\end{align*}\nFor this expression to approximate $\\partial_x u(x_0) = u^{(1)}(x_0)$ with an error of $\\mathcal{O}(h^5)$, the coefficients of $u^{(k)}(x_0)$ must match those of $u^{(1)}(x_0)$ for $k=0, \\dots, 5$. This leads to the following system of six linear equations for the six coefficients $a_0, \\dots, a_5$:\n\\begin{align*}\n\\sum_{m=0}^{5} a_m m^0 = \\sum_{m=0}^{5} a_m = 0 \\quad (\\text{coefficient of } u^{(0)}) \\\\\n\\sum_{m=0}^{5} a_m m^1 = 1 \\quad (\\text{coefficient of } u^{(1)}) \\\\\n\\sum_{m=0}^{5} a_m m^2 = 0 \\quad (\\text{coefficient of } u^{(2)}) \\\\\n\\sum_{m=0}^{5} a_m m^3 = 0 \\quad (\\text{coefficient of } u^{(3)}) \\\\\n\\sum_{m=0}^{5} a_m m^4 = 0 \\quad (\\text{coefficient of } u^{(4)}) \\\\\n\\sum_{m=0}^{5} a_m m^5 = 0 \\quad (\\text{coefficient of } u^{(5)})\n\\end{align*}\nIn matrix form, this is:\n$$\n\\begin{pmatrix}\n1  1  1  1  1  1 \\\\\n0  1  2  3  4  5 \\\\\n0  1  4  9  16  25 \\\\\n0  1  8  27  64  125 \\\\\n0  1  16  81  256  625 \\\\\n0  1  32  243  1024  3125\n\\end{pmatrix}\n\\begin{pmatrix}\na_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ a_4 \\\\ a_5\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\n\\end{pmatrix}\n$$\nSolving this system of linear equations yields the unique set of rational coefficients:\n$a_0 = -\\frac{137}{60}$\n$a_1 = 5$\n$a_2 = -5$\n$a_3 = \\frac{10}{3}$\n$a_4 = -\\frac{5}{4}$\n$a_5 = \\frac{1}{5}$\n\nThe resulting stencil is:\n$$\nD_x u(x_0) = \\frac{1}{h} \\left( -\\frac{137}{60} u(x_0) + 5 u(x_0+h) - 5 u(x_0+2h) + \\frac{10}{3} u(x_0+3h) - \\frac{5}{4} u(x_0+4h) + \\frac{1}{5} u(x_0+5h) \\right)\n$$\n\n### Part 2: Explicit Formula for the Radial Derivative\n\nThe radial derivative is defined as $\\partial_r u = \\mathbf{n} \\cdot \\nabla u = n_x \\partial_x u + n_y \\partial_y u + n_z \\partial_z u$. We approximate this expression by replacing each partial derivative with its corresponding discrete operator. Let $D_x$, $D_y$, and $D_z$ be the discrete operators for $\\partial_x$, $\\partial_y$, and $\\partial_z$, respectively. A crucial subtlety is that the direction of one-sidedness must be outward from the excision surface. For a normal vector component $n_i > 0$, a forward stencil is used; for $n_i  0$, a backward stencil should be used. The problem, however, instructs us to use \"the result of part 1 for each Cartesian coordinate direction,\" which derived a forward stencil. Following this instruction formally, we define the operators at a point $\\mathbf{x}_0 = (x_0, y_0, z_0)$:\n\nLet $D_x^+$, $D_y^+$, and $D_z^+$ be the forward difference operators based on the stencil from Part 1:\n\\begin{align*}\nD_x^+ u(\\mathbf{x}_0) = \\frac{1}{h} \\sum_{m=0}^{5} a_m u(x_0 + m h, y_0, z_0) \\\\\nD_y^+ u(\\mathbf{x}_0) = \\frac{1}{h} \\sum_{m=0}^{5} a_m u(x_0, y_0 + m h, z_0) \\\\\nD_z^+ u(\\mathbf{x}_0) = \\frac{1}{h} \\sum_{m=0}^{5} a_m u(x_0, y_0, z_0 + m h)\n\\end{align*}\nwhere the coefficients $\\{a_m\\}$ are those derived in Part 1.\n\nThe approximation for the radial derivative, $D_r u$, is then constructed as the same linear combination of these discrete operators:\n$$\nD_r u(\\mathbf{x}_0) = n_x D_x^+ u(\\mathbf{x}_0) + n_y D_y^+ u(\\mathbf{x}_0) + n_z D_z^+ u(\\mathbf{x}_0)\n$$\nSubstituting the explicit forms of the operators, we obtain the formula:\n$$\nD_r u(\\mathbf{x}_0) = \\frac{1}{h} \\left( n_x \\sum_{m=0}^{5} a_m u(x_0+mh, y_0, z_0) + n_y \\sum_{m=0}^{5} a_m u(x_0, y_0+mh, z_0) + n_z \\sum_{m=0}^{5} a_m u(x_0, y_0, z_0+mh) \\right)\n$$\nThis formula uses only forward stencils, as per a literal interpretation of the prompt. A correct implementation would select between forward and backward stencils depending on the sign of $n_x$, $n_y$, and $n_z$.\n\n### Part 3: Leading-Order Truncation Error\n\nThe truncation error of the discrete operator $D_x$ is the difference between the operator applied to the exact solution and the exact derivative, $T = D_x u - \\partial_x u$. We find the leading term of this error by extending the Taylor series analysis from Part 1 to the next non-vanishing term. By construction, the terms involving $u^{(0)}, \\dots, u^{(5)}$ cancel out, except for the $u^{(1)}$ term which gives the derivative itself. The first non-vanishing error term will involve $u^{(6)}(x_0)$.\n\nThe expansion from Part 1 is:\n$$\nD_x u(x_0) = \\sum_{k=0}^{\\infty} \\frac{h^{k-1}}{k!} \\left( \\sum_{m=0}^{5} a_m m^k \\right) u^{(k)}(x_0)\n$$\nUsing the properties of our coefficients $a_m$, this becomes:\n$$\nD_x u(x_0) = u^{(1)}(x_0) + \\frac{h^5}{6!} \\left( \\sum_{m=0}^{5} a_m m^6 \\right) u^{(6)}(x_0) + \\mathcal{O}(h^6)\n$$\nThe leading-order truncation error is the second term on the right-hand side. We must calculate the sum $\\sum_{m=0}^{5} a_m m^6$:\n\\begin{align*}\n\\sum_{m=0}^{5} a_m m^6 = (a_0 \\cdot 0^6) + (a_1 \\cdot 1^6) + (a_2 \\cdot 2^6) + (a_3 \\cdot 3^6) + (a_4 \\cdot 4^6) + (a_5 \\cdot 5^6) \\\\\n= \\left(5\\right) \\cdot 1 + \\left(-5\\right) \\cdot 64 + \\left(\\frac{10}{3}\\right) \\cdot 729 + \\left(-\\frac{5}{4}\\right) \\cdot 4096 + \\left(\\frac{1}{5}\\right) \\cdot 15625 \\\\\n= 5 - 320 + (10 \\cdot 243) - (5 \\cdot 1024) + 3125 \\\\\n= 5 - 320 + 2430 - 5120 + 3125 \\\\\n= 5560 - 5440 = 120\n\\end{align*}\nThe coefficient of the leading error term is $\\frac{1}{6!} \\sum_{m=0}^{5} a_m m^6$. Since $6! = 720$, this is:\n$$\nC = \\frac{120}{720} = \\frac{1}{6}\n$$\nThus, the error expansion of the approximation is:\n$$\nD_x u(x_0) - \\partial_x u(x_0) = \\frac{1}{6} h^5 u^{(6)}(x_0) + \\mathcal{O}(h^6)\n$$\nThe constant multiplying $h^5 u^{(6)}(x_0)$ is $\\frac{1}{6}$.\n\n### Part 4: CFL Stability Constraint and Discussion\n\nThe semi-discrete equation is $\\frac{d\\mathbf{u}}{dt} = -c D_r \\mathbf{u}$, where $\\mathbf{u}$ is the vector of field values at grid points and $D_r$ is the matrix representing the discrete spatial operator from Part 2. The stability of the classical fourth-order Runge-Kutta (RK4) method for this system requires that for every eigenvalue $\\lambda$ of the matrix $-c D_r$, the quantity $z = \\Delta t \\lambda$ must lie within the stability region of RK4, denoted $S_{RK4}$.\n\nIn a von Neumann (Fourier) stability analysis, the eigenvalues of the operator $-c D_r$ are approximated by the values of its Fourier symbol, $\\hat{S}(\\mathbf{k}) = -c \\hat{D}_r(\\mathbf{k})$, where $\\mathbf{k}=(k_x, k_y, k_z)$ is the wavevector. The symbol of the radial derivative operator is:\n$$\n\\hat{D}_r(\\mathbf{k}) = n_x \\hat{D}_x(k_x) + n_y \\hat{D}_y(k_y) + n_z \\hat{D}_z(k_z)\n$$\nwhere $\\hat{D}_x(k_x)$, the symbol of the 1D operator, is:\n$$\n\\hat{D}_x(k_x) = \\frac{1}{h} \\sum_{m=0}^{5} a_m \\exp(i m k_x h)\n$$\nThe stability condition is that $-c \\Delta t \\hat{D}_r(\\mathbf{k}) \\in S_{RK4}$ for all $\\mathbf{k}$. This leads to a constraint on the timestep $\\Delta t$ of the form:\n$$\n\\Delta t \\le \\frac{\\mathcal{C}_{RK4}}{\\rho(-c D_r)}\n$$\nwhere $\\rho(-c D_r)$ is the spectral radius of the operator. Following the problem's suggestion, we use the \"spectral radius of the Fourier symbol\", which we define as $\\rho_{FS} = \\max_{\\mathbf{k}} |-c \\hat{D}_r(\\mathbf{k})| = c \\max_{\\mathbf{k}} |\\hat{D}_r(\\mathbf{k})|$. The constant $\\mathcal{C}_{RK4}$ is the maximum extent of the RK4 stability region along the direction of the scaled spectrum.\nA sufficient CFL stability constraint is therefore:\n$$\n\\Delta t \\le \\frac{\\mathcal{C}_{RK4}}{c \\max_{\\mathbf{k}} |\\hat{D}_r(\\mathbf{k})|}\n$$\nThe constant $\\mathcal{C}_{RK4}$ depends on the geometric properties of the spectrum $\\{ \\hat{D}_r(\\mathbf{k}) \\}$ in the complex plane. If the spectrum were purely imaginary (as for centered differences), $\\mathcal{C}_{RK4} = 2\\sqrt{2}$. For one-sided stencils, the spectrum is not purely imaginary, so $\\mathcal{C}_{RK4}$ takes a different value.\n\n**Discussion:**\nOne-sidedness is mandated by the principle of causality in a domain with an excised interior. At a grid point adjacent to the excision boundary, a finite-difference stencil cannot use points from within the excised region, as they are not part of the computational domain. Since the equation $\\partial_t u + c \\partial_r u = 0$ describes an outgoing wave ($c>0$), the characteristic information propagates in the direction of increasing $r$ (outward). The numerical domain of dependence must encompass the continuum domain of dependence. Thus, to compute the spatial derivative $\\partial_r u$ needed to evolve the solution, one must use points that are further out, leading to a one-sided stencil pointing away from the origin.\n\nThis one-sidedness fundamentally affects the spectral properties of the discrete operator. Whereas centered-difference approximations to first derivatives are anti-symmetric and have purely imaginary Fourier symbols (and eigenvalues), one-sided stencils are not anti-symmetric and have complex symbols. This introduces a non-zero real part to the eigenvalues of the semi-discrete operator. If this real part is non-positive for all modes, the scheme is dissipative, which can be beneficial for stability. However, standard high-order one-sided stencils derived from Taylor series, such as the one in this problem, are not guaranteed to be dissipative and can possess eigenvalues with positive real parts. Such modes are amplified by any explicit time-stepping scheme, leading to unconditional instability. For this reason, practical implementations often employ specially designed Summation-by-Parts (SBP) operators that, when combined with appropriate boundary conditions, guarantee stability by preventing the growth of a discrete energy norm. The formal stability constraint derived above presumes that the spectrum of the operator $-c D_r$ lies entirely within a region of the left half-plane that can be contained within the RK4 stability domain for a sufficiently small $\\Delta t$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -\\frac{137}{60}  5  -5  \\frac{10}{3}  -\\frac{5}{4}  \\frac{1}{5}  \\frac{1}{6} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "On a Cartesian grid, any curved excision surface is approximated by a \"stair-stepped\" collection of cubes, an effect that can introduce grid-orientation-dependent errors. This practical coding exercise allows you to quantitatively explore this issue by comparing a spherical excision mask with a cubical one for a single black hole. You will implement both masks, compute numerical derivatives near the boundary, and measure the resulting errors against a known analytic solution. This practice offers direct insight into a key challenge of Cartesian numerical relativity and highlights how geometric choices in the algorithm can impact the physical accuracy of a simulation [@problem_id:3d465595].",
            "id": "3465595",
            "problem": "Consider a time-symmetric initial data slice for a single non-spinning black hole in isotropic Cartesian coordinates, where the physical spatial metric is conformally flat, given by $g_{ij} = \\psi^4 \\delta_{ij}$, and the conformal factor for a Schwarzschild mass $M$ is $\\psi(\\mathbf{x}) = 1 + \\dfrac{M}{2 r}$ with $r = \\sqrt{x^2 + y^2 + z^2}$. On such a slice, the Hamiltonian constraint of General Relativity reduces to the requirement that the Ricci scalar of the conformal metric be zero outside sources, which, for the conformally flat form, implies the flat-space Laplace equation $\\nabla^2 \\psi = 0$ for $r  0$. In numerical relativity with black hole excision, one removes grid points inside an excision mask contained within the event horizon to avoid the physical singularity. On a Cartesian grid, the geometry and orientation of the excision mask can introduce orientation-dependent discretization errors in finite-difference approximations of derivatives near the excision boundary.\n\nYour task is to quantitatively compare spherical versus cubical excision masks on Cartesian grids, at the same proximity to the event horizon, and to report two scalars for each case:\n- A discrete Hamiltonian constraint residual norm computed as the root-mean-square of the discrete Laplacian $\\nabla^2 \\psi$ over all usable points outside the mask.\n- An orientation-dependent metric error computed as the root-mean-square of the mismatch between numerically approximated axial second derivatives $\\partial^2 \\psi / \\partial x^2$, $\\partial^2 \\psi / \\partial y^2$, $\\partial^2 \\psi / \\partial z^2$ and their analytic values, restricted to points that are adjacent to the excision boundary.\n\nFundamental base and definitions to use:\n- The conformal factor is $\\psi(\\mathbf{x}) = 1 + \\dfrac{M}{2 r}$ with $r = \\sqrt{x^2 + y^2 + z^2}$.\n- The event horizon in isotropic coordinates is at radius $r_h = \\dfrac{M}{2}$.\n- The excision mask radius is defined by $r_{\\mathrm{ex}} = r_h - \\Delta$, where $\\Delta  0$ is the prescribed proximity to the horizon. The excision region must satisfy $r_{\\mathrm{ex}}  0$.\n- Spherical mask: excise all points satisfying $r  r_{\\mathrm{ex}}$.\n- Cubical mask: excise all points satisfying $\\max\\left(|x'|,|y'|,|z'|\\right)  r_{\\mathrm{ex}}$, where $(x',y',z')$ are coordinates after an in-plane rotation of angle $\\theta$ about the $z$-axis, given by\n$$\n\\begin{pmatrix}\nx' \\\\ y' \\\\ z'\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\cos\\theta  \\sin\\theta  0 \\\\\n-\\sin\\theta  \\cos\\theta  0 \\\\\n0  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\nx \\\\ y \\\\ z\n\\end{pmatrix}.\n$$\nThis choice makes the minimal distance from the origin to the cubical mask equal to $r_{\\mathrm{ex}}$, matching the spherical case, hence ensuring the same horizon proximity.\n\nAnalytic second derivatives of $\\psi$ to be used for error evaluation follow from the Hessian of $1/r$,\n$$\n\\frac{\\partial^2}{\\partial x_i \\partial x_j} \\left(\\frac{1}{r}\\right) = \\frac{3 x_i x_j - r^2 \\delta_{ij}}{r^5}, \\quad r \\neq 0,\n$$\nso that\n$$\n\\frac{\\partial^2 \\psi}{\\partial x^2} = \\frac{M}{2}\\,\\frac{3 x^2 - r^2}{r^5}, \\quad\n\\frac{\\partial^2 \\psi}{\\partial y^2} = \\frac{M}{2}\\,\\frac{3 y^2 - r^2}{r^5}, \\quad\n\\frac{\\partial^2 \\psi}{\\partial z^2} = \\frac{M}{2}\\,\\frac{3 z^2 - r^2}{r^5},\n$$\nand the analytic Laplacian $\\nabla^2 \\psi = 0$ for $r \\neq 0$.\n\nDiscretization rules to implement on a uniform Cartesian grid with spacing $h$:\n- Use the second-order central-difference approximation for second derivatives when both immediate neighbors along an axis are available and not excised:\n$$\n\\left.\\frac{\\partial^2 \\psi}{\\partial x^2}\\right|_{i,j,k} \\approx \\frac{\\psi_{i+1,j,k} - 2 \\psi_{i,j,k} + \\psi_{i-1,j,k}}{h^2},\n$$\nand analogously for the $y$ and $z$ directions.\n- If a central neighbor along an axis is excised or outside the domain, but two consecutive points on the opposite side along that axis are available and not excised, use the one-sided second-order approximation:\n$$\n\\left.\\frac{\\partial^2 \\psi}{\\partial x^2}\\right|_{i,j,k} \\approx \\frac{\\psi_{i,j,k} - 2 \\psi_{i\\pm 1,j,k} + \\psi_{i\\pm 2,j,k}}{h^2},\n$$\nwhere the sign $\\pm$ selects forward ($+$) or backward ($-$) direction depending on which side is available. If neither central nor one-sided stencils can be formed, the derivative at that point is considered unusable.\n- The discrete Laplacian at a point is the sum of the three axial second derivatives, using the above rules, only if all three axial second derivatives are usable.\n- Define a point as “near-boundary” if it is not excised and has at least one immediate neighbor along any axis that is excised.\n\nQuantities to compute and report for each test case:\n- The Hamiltonian constraint residual norm, defined as $\\sqrt{\\dfrac{1}{N}\\sum_{\\mathrm{usable}} \\left(\\nabla^2 \\psi\\right)^2}$ over all points outside the mask where all three axial second derivatives are usable ($N$ is the count of such points).\n- The orientation-dependent metric error, defined as the root-mean-square of the mismatch between numerical and analytic axial second derivatives, restricted to near-boundary points, i.e.,\n$$\n\\sqrt{\\dfrac{1}{N_{\\mathrm{axes}}} \\sum_{\\mathrm{near\\,boundary}} \\sum_{a \\in \\{x,y,z\\}} \\left( D_{aa}^{\\mathrm{num}} - D_{aa}^{\\mathrm{analytic}} \\right)^2 },\n$$\nwhere $D_{aa}^{\\mathrm{num}}$ is the numerical axial second derivative and $D_{aa}^{\\mathrm{analytic}}$ is the corresponding analytic value; sum only includes axes for which the numerical derivative is usable ($N_{\\mathrm{axes}}$ counts such axis contributions).\n\nAngles must be specified in radians. All computed outputs are unitless real numbers. Implement the computation on a cubic domain $[-L,L]^3$ with uniform spacing $h$.\n\nTest suite:\n- Case $1$: spherical mask, $M = 1.0$, $L = 0.6$, $h = 0.02$, $\\Delta = 0.05$, $\\theta = 0.0$ (ignored).\n- Case $2$: cubical mask aligned with grid, $M = 1.0$, $L = 0.6$, $h = 0.02$, $\\Delta = 0.05$, $\\theta = 0.0$.\n- Case $3$: cubical mask rotated, $M = 1.0$, $L = 0.6$, $h = 0.02$, $\\Delta = 0.05$, $\\theta = \\pi/4$.\n\nFinal output format:\nYour program should produce a single line of output containing the six results in the order $[\\text{C}_1,\\text{E}_1,\\text{C}_2,\\text{E}_2,\\text{C}_3,\\text{E}_3]$, where $\\text{C}_i$ is the constraint residual norm and $\\text{E}_i$ is the metric error for case $i$, as a comma-separated list enclosed in square brackets (e.g., $[0.00123,0.00456,0.00101,0.00480,0.00105,0.00490]$). All values must be real numbers without any unit.",
            "solution": "The problem posed is a well-defined exercise in numerical relativity, specifically concerning the implementation and evaluation of black hole excision techniques on a Cartesian grid. It requires a quantitative comparison of two common excision mask geometries—spherical and cubical—by calculating two distinct error metrics: a Hamiltonian constraint residual norm and an orientation-dependent metric error. All physical definitions, mathematical formulas, and numerical rules are provided and are scientifically sound, forming a self-contained and solvable problem. The parameter values given are physically and computationally reasonable. Therefore, the problem is deemed valid and a full solution follows.\n\nThe core of the task is to discretize a known analytic solution—the conformal factor for a Schwarzschild black hole in isotropic coordinates—on a 3D Cartesian grid, apply different excision masks, and then compute errors arising from finite-difference approximations near the created boundaries.\n\n### Principle-Based Design of the Solution\n\nThe solution is structured around a main function that processes each test case by performing a sequence of steps derived from the principles of numerical analysis and computational physics.\n\n1.  **Grid and Field Initialization**: A uniform 3D Cartesian grid is constructed over the domain $[-L, L]^3$ with spacing $h$. On this grid, we evaluate the analytic conformal factor $\\psi(\\mathbf{x}) = 1 + \\frac{M}{2r}$ and its second partial derivatives, $\\frac{\\partial^2 \\psi}{\\partial x_i^2}$. The radial coordinate is $r = \\sqrt{x^2+y^2+z^2}$. To prevent division by zero at the origin ($r=0$), a small epsilon is added to $r$ during computation. This is inconsequential as the origin is always within the excision region ($r_{ex} > 0$) and thus excluded from all subsequent calculations.\n\n2.  **Excision Mask Generation**: For each test case, a boolean mask `is_excised` is generated. This 3D array identifies grid points that fall inside the excision region and are to be ignored in derivative calculations.\n    *   **Spherical Mask**: A point at coordinates $(x, y, z)$ is excised if its radial distance $r = \\sqrt{x^2+y^2+z^2}$ is less than the excision radius $r_{\\mathrm{ex}} = \\frac{M}{2} - \\Delta$.\n    *   **Cubical Mask**: A point $(x, y, z)$ is excised if its coordinates, after a rotation by an angle $\\theta$ about the $z$-axis, satisfy $\\max(|x'|, |y'|, |z'|)  r_{\\mathrm{ex}}$. The rotated coordinates are given by $x' = x \\cos\\theta + y \\sin\\theta$ and $y' = -x \\sin\\theta + y \\cos\\theta$.\n\n3.  **Numerical Differentiation with Stencil Hierarchy**: The crucial step is the approximation of second derivatives using finite differences. The problem specifies a hierarchy of stencils to be used, which is a standard practice for handling boundaries in finite-difference methods. For each non-excised point and each spatial direction, we apply the following prioritized sequence:\n    a.  **Second-Order Central Difference**: $\\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{h^2}$. This is the preferred stencil, used whenever both immediate neighbors are available (i.e., within the grid domain and not excised).\n    b.  **One-Sided Difference (Forward)**: If the central difference stencil is unavailable, we attempt to use a one-sided stencil. Following the specified formula, the forward stencil is $\\frac{\\psi_i - 2\\psi_{i+1} + \\psi_{i+2}}{h^2}$. This is attempted if the two forward neighbors are available.\n    c.  **One-Sided Difference (Backward)**: If neither the central nor forward stencil can be applied, we attempt the backward stencil $\\frac{\\psi_i - 2\\psi_{i-1} + \\psi_{i-2}}{h^2}$, provided the two backward neighbors are available.\n    d.  **Unusable Derivative**: If none of these stencils can be formed, the derivative at that point for that axis is considered unusable and marked as such (e.g., with `NaN`).\n\n    This logic is implemented for each of the three spatial derivatives, $\\frac{\\partial^2 \\psi}{\\partial x^2}$, $\\frac{\\partial^2 \\psi}{\\partial y^2}$, and $\\frac{\\partial^2 \\psi}{\\partial z^2}$, resulting in three arrays of numerical derivative values.\n\n4.  **Calculation of Error Metrics**: With both analytic and numerical derivatives computed, we can evaluate the two required error metrics.\n    *   **Hamiltonian Constraint Residual Norm ($C$)**: The discrete Laplacian, $\\nabla^2_h \\psi$, is computed at each point by summing the three numerical second derivatives. A point contributes to this calculation only if all three of its axial derivatives are usable. The norm is then the root-mean-square (RMS) of these Laplacian values over all such usable points. Since the analytic Laplacian is zero, this norm directly measures the discretization error of the Hamiltonian constraint.\n    *   **Orientation-Dependent Metric Error ($E$)**: This error is calculated specifically at points adjacent to the excision boundary. First, we identify all \"near-boundary\" points, defined as non-excised points with at least one immediately adjacent excised neighbor. Then, for this subset of points, we compute the RMS of the difference between the numerical and analytical second derivatives, summed over all three axes where the numerical derivative is usable. This metric is designed to capture the local, orientation-dependent errors introduced by the stencil selection near the jagged, grid-aligned representation of the excision surface.\n\nThe entire procedure is encapsulated and executed for each of the three test cases, and the resulting six scalar values are formatted into the required output.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        {'type': 'spherical', 'M': 1.0, 'L': 0.6, 'h': 0.02, 'Delta': 0.05, 'theta': 0.0},\n        {'type': 'cubical',   'M': 1.0, 'L': 0.6, 'h': 0.02, 'Delta': 0.05, 'theta': 0.0},\n        {'type': 'cubical',   'M': 1.0, 'L': 0.6, 'h': 0.02, 'Delta': 0.05, 'theta': np.pi/4},\n    ]\n\n    results = []\n    for case in test_cases:\n        C, E = solve_case(case)\n        results.extend([C, E])\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_case(params):\n    \"\"\"\n    Solves for a single test case configuration.\n    \"\"\"\n    M, L, h, Delta = params['M'], params['L'], params['h'], params['Delta']\n    mask_type, theta = params['type'], params['theta']\n    \n    r_h = M / 2.0\n    r_ex = r_h - Delta\n\n    # 1. Grid and Field Initialization\n    n_pts = int(2 * L / h) + 1\n    coords_1d = np.linspace(-L, L, n_pts)\n    X, Y, Z = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n\n    # Add a small epsilon to avoid division by zero at r=0.\n    # The origin is always excised as r_ex > 0.\n    R = np.sqrt(X**2 + Y**2 + Z**2)\n    R_safe = R + 1e-15 \n\n    psi = 1.0 + M / (2.0 * R_safe)\n    \n    # Analytic second derivatives\n    R5 = R_safe**5\n    d2psi_dx2_an = (M / 2.0) * (3 * X**2 - R_safe**2) / R5\n    d2psi_dy2_an = (M / 2.0) * (3 * Y**2 - R_safe**2) / R5\n    d2psi_dz2_an = (M / 2.0) * (3 * Z**2 - R_safe**2) / R5\n\n    # 2. Excision Mask Generation\n    if mask_type == 'spherical':\n        is_excised = R  r_ex\n    elif mask_type == 'cubical':\n        cos_t, sin_t = np.cos(theta), np.sin(theta)\n        X_prime = X * cos_t + Y * sin_t\n        Y_prime = -X * sin_t + Y * cos_t\n        Z_prime = Z\n        is_excised = np.maximum(np.abs(X_prime), np.maximum(np.abs(Y_prime), np.abs(Z_prime)))  r_ex\n\n    # 3. Numerical Differentiation\n    d2psi_dx2_num, d2psi_dy2_num, d2psi_dz2_num = compute_numerical_derivatives(psi, h, is_excised)\n\n    # 4. Calculation of Error Metrics\n    \n    # Hamiltonian Constraint Residual Norm (C)\n    laplacian_num = np.full_like(psi, np.nan)\n    valid_lap_mask = ~np.isnan(d2psi_dx2_num)  ~np.isnan(d2psi_dy2_num)  ~np.isnan(d2psi_dz2_num)\n    laplacian_num[valid_lap_mask] = d2psi_dx2_num[valid_lap_mask] + d2psi_dy2_num[valid_lap_mask] + d2psi_dz2_num[valid_lap_mask]\n    \n    usable_laplacians = laplacian_num[~np.isnan(laplacian_num)]\n    if len(usable_laplacians) > 0:\n        constraint_norm = np.sqrt(np.mean(usable_laplacians**2))\n    else:\n        constraint_norm = 0.0\n\n    # Orientation-Dependent Metric Error (E)\n    is_near_boundary = np.zeros_like(psi, dtype=bool)\n    indices = np.argwhere(~is_excised)\n    for i, j, k in indices:\n        for di, dj, dk in [(-1,0,0), (1,0,0), (0,-1,0), (0,1,0), (0,0,-1), (0,0,1)]:\n            ni, nj, nk = i + di, j + dj, k + dk\n            if 0 = ni  n_pts and 0 = nj  n_pts and 0 = nk  n_pts:\n                if is_excised[ni, nj, nk]:\n                    is_near_boundary[i, j, k] = True\n                    break\n\n    sq_errors = []\n    near_boundary_indices = np.argwhere(is_near_boundary)\n    for i, j, k in near_boundary_indices:\n        if not np.isnan(d2psi_dx2_num[i, j, k]):\n            err = d2psi_dx2_num[i, j, k] - d2psi_dx2_an[i, j, k]\n            sq_errors.append(err**2)\n        if not np.isnan(d2psi_dy2_num[i, j, k]):\n            err = d2psi_dy2_num[i, j, k] - d2psi_dy2_an[i, j, k]\n            sq_errors.append(err**2)\n        if not np.isnan(d2psi_dz2_num[i, j, k]):\n            err = d2psi_dz2_num[i, j, k] - d2psi_dz2_an[i, j, k]\n            sq_errors.append(err**2)\n\n    if len(sq_errors) > 0:\n        metric_error = np.sqrt(np.mean(sq_errors))\n    else:\n        metric_error = 0.0\n        \n    return constraint_norm, metric_error\n\n\ndef compute_numerical_derivatives(psi, h, is_excised):\n    \"\"\"\n    Computes all three second partial derivatives using a hierarchical stencil choice.\n    \"\"\"\n    n_pts = psi.shape[0]\n    derivs = []\n    \n    for axis in range(3):  # 0 for x, 1 for y, 2 for z\n        d2psi_d_axis_2 = np.full_like(psi, np.nan)\n        \n        # To handle different axes generically, we transpose the arrays\n        psi_ax = np.transpose(psi, (axis, (axis + 1) % 3, (axis + 2) % 3))\n        is_excised_ax = np.transpose(is_excised, (axis, (axis + 1) % 3, (axis + 2) % 3))\n        \n        indices = np.argwhere(~is_excised_ax)\n        \n        for i, j, k in indices:\n            # Central difference\n            if 0  i  n_pts - 1 and not is_excised_ax[i-1, j, k] and not is_excised_ax[i+1, j, k]:\n                d2psi_d_axis_2[i,j,k] = (psi_ax[i+1, j, k] - 2 * psi_ax[i, j, k] + psi_ax[i-1, j, k]) / h**2\n            # One-sided forward difference\n            elif i  n_pts - 2 and not is_excised_ax[i+1, j, k] and not is_excised_ax[i+2, j, k]:\n                d2psi_d_axis_2[i,j,k] = (psi_ax[i, j, k] - 2 * psi_ax[i+1, j, k] + psi_ax[i+2, j, k]) / h**2\n            # One-sided backward difference\n            elif i > 1 and not is_excised_ax[i-1, j, k] and not is_excised_ax[i-2, j, k]:\n                 d2psi_d_axis_2[i,j,k] = (psi_ax[i, j, k] - 2 * psi_ax[i-1, j, k] + psi_ax[i-2, j, k]) / h**2\n        \n        # Transpose back to original orientation\n        d2psi_d_axis_2 = np.transpose(d2psi_d_axis_2, np.argsort((axis, (axis + 1) % 3, (axis + 2) % 3)))\n        derivs.append(d2psi_d_axis_2)\n        \n    return derivs[0], derivs[1], derivs[2]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "A more sophisticated and physically motivated approach to excision involves creating a dynamic boundary that moves in lockstep with the causal structure of spacetime. By designing the inner boundary to follow ingoing null geodesics (paths of light rays falling into the black hole), we can robustly ensure that no unphysical information can escape from the excised region. This problem guides you through the implementation of such a null-based excision scheme in Kerr-Schild coordinates, where the properties of null geodesics are particularly simple. You will derive the characteristic speeds and build a 1D simulation to test the stability of the method, reinforcing the deep connection between the physics of general relativity and the design of stable numerical algorithms .",
            "id": "3465528",
            "problem": "Consider a one-dimensional spherical-symmetry reduction of a fixed Schwarzschild black hole background expressed in Kerr–Schild coordinates. Work in geometric units where $G=c=1$, and measure time and length in units of the black hole mass $M$ so that all quantities are dimensionless. You are tasked with implementing a null-based excision scheme in which the inner boundary follows ingoing null geodesics in Kerr–Schild coordinates. You will model the principal part of a symmetric-hyperbolic system by evolving two decoupled characteristic fields that propagate along the ingoing and outgoing null directions, respectively, and you will assess stability and constraint leakage.\n\nStarting point and required derivations from first principles:\n- Begin from the Kerr–Schild form of the Schwarzschild metric $g_{\\mu\\nu}$ and its $3+1$ decomposition with lapse $\\alpha$, shift $\\beta^i$, and spatial metric $\\gamma_{ij}$. Use the standard property that in a $3+1$ split, the characteristic speeds of light-like signals in the radial direction with respect to coordinate time are given by $-\\beta^r \\pm \\alpha \\sqrt{\\gamma^{rr}}$. Derive the explicit radial coordinate speeds $v_{-}(r)$ and $v_{+}(r)$ for the ingoing and outgoing null characteristics, respectively, expressed solely as functions of $r$ and $M$.\n- Use the null vectors $l^\\mu$ (ingoing) and $n^\\mu$ (outgoing), normalized so that $l^\\mu l_\\mu = n^\\mu n_\\mu = 0$ and $l^\\mu n_\\mu = -1$ with respect to $g_{\\mu\\nu}$. Perform a characteristic decomposition along $l^\\mu$ and $n^\\mu$ to define two scalar characteristic variables $w_l$ and $w_n$ that propagate with the speeds $v_{-}(r)$ and $v_{+}(r)$, respectively. Your evolution model is the decoupled first-order hyperbolic system\n$$\n\\partial_t w_l + v_{-}(r)\\,\\partial_r w_l = 0,\\qquad\n\\partial_t w_n + v_{+}(r)\\,\\partial_r w_n = 0.\n$$\n- Implement null-based excision by moving the inner boundary along ingoing null geodesics. In Kerr–Schild coordinates, this implies the inner boundary radius $r_{\\mathrm{in}}(t)$ must satisfy\n$$\n\\frac{dr_{\\mathrm{in}}}{dt} = v_{-}(r_{\\mathrm{in}}(t)).\n$$\n- For the outer boundary at $r=r_{\\max}$, eliminate incoming content by prescribing no incoming ingoing-null mode, i.e., set the boundary condition so that $w_l$ entering from $r_{\\max}$ vanishes.\n\nNumerical method requirements:\n- Discretize the spatial coordinate $r$ on a uniform grid with spacing $\\Delta r$. Choose the time step $\\Delta t$ by a Courant–Friedrichs–Lewy (CFL) condition such that $\\max_r |v_{\\pm}(r)|\\,\\Delta t/\\Delta r \\leq \\lambda$, where $0\\lambda1$ is a provided Courant factor. Use a Strong Stability Preserving (SSP) Runge–Kutta method of order three for time integration.\n- Use upwind finite differences for the spatial derivatives consistent with the local sign of the characteristic speed. The inner excision boundary is a pure outflow boundary if it is placed at or inside the horizon; therefore, it requires no boundary condition for incoming-to-domain modes. If the inner boundary lies outside the horizon, there will be an incoming-to-domain outgoing-null mode $w_n$ at the inner boundary; if no data are supplied there, the scheme can become unstable.\n- To assess constraint leakage, define a proxy for a first-order reduction constraint. Reconstruct an auxiliary field $\\Phi$ consistent with the characteristic decomposition of a scalar field,\n$$\n\\Phi(r,t) \\equiv \\frac{w_n(r,t) - w_l(r,t)}{2\\,\\sqrt{\\gamma^{rr}(r)}},\n$$\nand then construct a scalar potential $\\phi(r,t)$ on the grid by discrete line-integration of $\\Phi$ from the inner boundary. Define the discrete constraint\n$$\nC(r,t) \\equiv \\left(\\partial_r \\phi\\right)_{\\mathrm{num}} - \\Phi(r,t),\n$$\nwhere $\\left(\\partial_r \\phi\\right)_{\\mathrm{num}}$ is a consistent finite-difference approximation. Use the $L^2$-norm over the active computational domain to measure the final-time dimensionless leakage ratio\n$$\n\\mathcal{R} \\equiv \\frac{\\|C(\\cdot,T)\\|_{2}}{\\|\\Phi(\\cdot,T)\\|_{2}}.\n$$\n\nInitial data and outer boundary:\n- Set $w_n(r,0)$ to a Gaussian pulse of amplitude $A$, centered at $r=r_0$, with width $\\sigma$, i.e., $w_n(r,0) = A \\exp\\left(-\\frac{(r-r_0)^2}{\\sigma^2}\\right)$.\n- Set $w_l(r,0)=0$.\n- Impose at the outer boundary $r=r_{\\max}$ that no ingoing content enters the domain: implement a boundary condition consistent with $w_l$ vanishing outside the computational domain.\n\nStability assessment:\n- Let the instantaneous $L^2$-norm be $\\|W(\\cdot,t)\\|_2$ computed from $w_l$ and $w_n$ over the active computational domain, e.g., as the square root of the integral of $w_l^2+w_n^2$ approximated by a Riemann sum. Track the growth factor\n$$\nG \\equiv \\frac{\\max_{t\\in[0,T]} \\|W(\\cdot,t)\\|_2}{\\|W(\\cdot,0)\\|_2}.\n$$\n- Define the scheme to be stable if $G \\leq 1.3$, and unstable otherwise.\n\nImplementation details to be encoded in your program:\n- Use a uniform grid on $r\\in[r_{\\min}, r_{\\max}]$ with $r_{\\min}0$. At each time, advance the inner excision radius $r_{\\mathrm{in}}(t)$ according to the ingoing-null geodesic equation specified above. The active computational grid at time $t$ is the set of points with $r \\geq r_{\\mathrm{in}}(t)$.\n- For $w_l$, always use upwind derivatives consistent with $v_{-}(r)$. For $w_n$, use upwind derivatives consistent with $v_{+}(r)$ in the interior. At the outer boundary, impose no incoming $w_l$ by a one-sided derivative consistent with $w_l=0$ outside. At the inner boundary, supply no boundary data; when the inner boundary is outside the horizon so that $v_{+}(r_{\\mathrm{in}})0$, treat the first active point with a formally downwind derivative for $w_n$ to reflect the lack of boundary data and reveal potential instability.\n- Compute $\\phi$ by discrete line-integration of $\\Phi$ starting from the current inner boundary point, and then compute the discrete gradient $\\left(\\partial_r \\phi\\right)_{\\mathrm{num}}$ by finite differences.\n\nTest suite:\nRun your program for the following three test cases. Use all quantities in units of $M$, and express all outputs as pure numbers (dimensionless decimals):\n1. Case A (admissible excision, expected stable): $M=1$, $A=1$, $r_0=12$, $\\sigma=1$, $r_{\\min}=0.1$, $r_{\\max}=50$, number of grid points $N=600$, Courant factor $\\lambda=0.6$, final time $T=8$, inner boundary initial radius $r_{\\mathrm{in}}(0)=2.0$.\n2. Case B (inadmissible excision, expected unstable): $M=1$, $A=1$, $r_0=10$, $\\sigma=1$, $r_{\\min}=0.1$, $r_{\\max}=30$, $N=500$, $\\lambda=0.6$, $T=6$, $r_{\\mathrm{in}}(0)=2.4$.\n3. Case C (admissible excision with tight Courant factor): $M=1$, $A=1$, $r_0=10$, $\\sigma=1$, $r_{\\min}=0.1$, $r_{\\max}=30$, $N=200$, $\\lambda=0.9$, $T=6$, $r_{\\mathrm{in}}(0)=2.0$.\n\nRequired final output format:\n- Your program should produce a single line of output containing a list of lists, one inner list per test case, each inner list in the form $[\\text{stable}, G, \\mathcal{R}]$, where $\\text{stable}$ is a boolean, $G$ is a float, and $\\mathcal{R}$ is a float. For example, the printed line must look like\n\"[ [True,1.05,0.0123],[False,3.7,0.45],[True,1.12,0.021] ]\"\nwith the actual numerical values from your computation. No additional text should be printed.",
            "solution": "The problem is valid as it presents a well-posed, scientifically grounded task in numerical relativity. It requires the derivation of fundamental quantities, the implementation of a standard numerical scheme with specific boundary treatments, and the analysis of stability and error, all of which are standard practices in computational physics.\n\nOur first step is to derive the characteristic speeds from the Kerr-Schild form of the Schwarzschild metric in spherical coordinates. The line element in geometric units ($G=c=1$) is given by\n$$\nds^2 = -\\left(1 - \\frac{2M}{r}\\right) dt^2 + \\frac{4M}{r} dt dr + \\left(1 + \\frac{2M}{r}\\right) dr^2 + r^2 d\\Omega^2.\n$$\nThis corresponds to a general 3+1 decomposed line element\n$$\nds^2 = (-\\alpha^2 + \\beta_i \\beta^i) dt^2 + 2\\beta_i dt dx^i + \\gamma_{ij} dx^i dx^j.\n$$\nBy comparing the metric components for the one-dimensional spherical system (where the spatial coordinate is just $r$), we identify the lapse $\\alpha$, the (co- and contravariant) radial shift component $\\beta_r$ and $\\beta^r$, and the (co- and contravariant) radial spatial metric component $\\gamma_{rr}$ and $\\gamma^{rr}$.\nFrom the metric, we have:\n- Spatial metric component: $\\gamma_{rr} = g_{rr} = 1 + \\frac{2M}{r}$. Its inverse is $\\gamma^{rr} = \\left(1 + \\frac{2M}{r}\\right)^{-1} = \\frac{r}{r+2M}$.\n- Covariant shift component: $\\beta_r = g_{tr} = \\frac{2M}{r}$.\n- Contravariant shift component: $\\beta^r = \\gamma^{rr} \\beta_r = \\frac{r}{r+2M} \\cdot \\frac{2M}{r} = \\frac{2M}{r+2M}$.\n- Lapse function: $\\alpha^2 = \\beta_i \\beta^i - g_{tt} = \\beta_r \\beta^r - g_{tt} = \\left(\\frac{2M}{r}\\right)\\left(\\frac{2M}{r+2M}\\right) - \\left(-1 + \\frac{2M}{r}\\right) = \\frac{4M^2}{r(r+2M)} + 1 - \\frac{2M}{r} = \\frac{4M^2 + r(r+2M) - 2M(r+2M)}{r(r+2M)} = \\frac{4M^2 + r^2 + 2Mr - 2Mr - 4M^2}{r(r+2M)} = \\frac{r^2}{r(r+2M)} = \\frac{r}{r+2M}$. So, $\\alpha = \\sqrt{\\frac{r}{r+2M}}$.\n\nThe radial characteristic speeds are given by $v_{\\pm}(r) = -\\beta^r \\pm \\alpha \\sqrt{\\gamma^{rr}}$. Substituting our derived quantities:\n$$\nv_{\\pm}(r) = -\\frac{2M}{r+2M} \\pm \\sqrt{\\frac{r}{r+2M}} \\sqrt{\\frac{r}{r+2M}} = -\\frac{2M}{r+2M} \\pm \\frac{r}{r+2M} = \\frac{-2M \\pm r}{r+2M}.\n$$\nThis gives the ingoing and outgoing speeds:\n- Ingoing speed: $v_{-}(r) = \\frac{-2M-r}{r+2M} = -1$.\n- Outgoing speed: $v_{+}(r) = \\frac{r-2M}{r+2M}$.\n\nThe remarkable result $v_{-}(r) = -1$ signifies that ingoing null geodesics have a constant coordinate speed in Kerr-Schild coordinates. The evolution equation for the inner excision boundary, $\\frac{dr_{\\mathrm{in}}}{dt} = v_{-}(r_{\\mathrm{in}}(t))$, simplifies to $\\frac{dr_{\\mathrm{in}}}{dt} = -1$, yielding the trajectory $r_{\\mathrm{in}}(t) = r_{\\mathrm{in}}(0) - t$.\n\nThe model consists of two decoupled linear advection equations for the characteristic fields $w_l$ and $w_n$:\n$$\n\\partial_t w_l + v_{-}(r)\\,\\partial_r w_l = 0 \\implies \\partial_t w_l - \\partial_r w_l = 0 \\\\\n\\partial_t w_n + v_{+}(r)\\,\\partial_r w_n = 0\n$$\nThese are solved on a uniform grid $r \\in [r_{\\min}, r_{\\max}]$ with spacing $\\Delta r$. The CFL condition demands $\\Delta t \\le \\lambda \\frac{\\Delta r}{\\max(|v_{-}|, |v_{+}|)}$. Since $|v_{-}|=1$ and $|v_{+}| = |\\frac{r-2M}{r+2M}| \\le 1$ for $r \\ge 0$, the maximum speed is $1$. Thus, we choose $\\Delta t = \\lambda \\Delta r$.\n\nThe numerical scheme employs:\n1.  **Time Integration**: A third-order Strong Stability Preserving Runge-Kutta (SSP-RK3) method is used to advance the solution in time.\n2.  **Spatial Discretization**: First-order upwind finite differences are used for the spatial derivatives $\\partial_r w_l$ and $\\partial_r w_n$.\n    - For $w_l$, the speed $v_{-} = -1  0$, so information propagates from larger $r$ to smaller $r$. Upwinding requires a forward difference: $(\\partial_r w_l)_i \\approx \\frac{(w_l)_{i+1} - (w_l)_i}{\\Delta r}$.\n    - For $w_n$, the speed $v_{+}(r)$ changes sign at the event horizon $r=2M$.\n        - If $r2M$, $v_{+}0$, information propagates from smaller $r$. Upwinding requires a backward difference: $(\\partial_r w_n)_i \\approx \\frac{(w_n)_i - (w_n)_{i-1}}{\\Delta r}$.\n        - If $r \\le 2M$, $v_{+} \\le 0$, information propagates from larger $r$. Upwinding requires a forward difference: $(\\partial_r w_n)_i \\approx \\frac{(w_n)_{i+1} - (w_n)_i}{\\Delta r}$.\n\n**Boundary and Excision Treatment**:\n- **Outer Boundary ($r=r_{\\max}$)**: We impose no incoming ingoing content by setting $w_l=0$ in a ghost cell outside the domain. For the derivative of $w_l$ at the last grid point $i=N-1$, this gives $(\\partial_r w_l)_{N-1} \\approx \\frac{0 - (w_l)_{N-1}}{\\Delta r}$.\n- **Inner Excision Boundary ($r_{\\mathrm{in}}(t)$)**: The computational domain is restricted to grid points where $r_i \\ge r_{\\mathrm{in}}(t)$.\n    - The stability of the scheme critically depends on the position of $r_{\\mathrm{in}}(t)$ relative to the event horizon at $r=2M$.\n    - If $r_{\\mathrm{in}}(t) \\le 2M$, all characteristics at the boundary point towards smaller $r$ (into the excised region). Thus, the boundary is a pure outflow boundary, and no data is needed. The upwind scheme naturally handles this.\n    - If $r_{\\mathrm{in}}(t)  2M$, then $v_{+}(r_{\\mathrm{in}})  0$. The characteristic for $w_n$ is directed into the computational domain. Since we supply no boundary data, the scheme is ill-posed. The problem specifies to use a \"formally downwind\" derivative (a forward difference) for $w_n$ at the first active grid point. This choice, while allowing the code to run, is known to be unstable and is expected to cause exponential growth in the solution, as demonstrated in Case B.\n\n**Analysis Metrics**:\n- **Stability**: The growth factor $G \\equiv \\frac{\\max_{t\\in[0,T]} \\|W(\\cdot,t)\\|_2}{\\|W(\\cdot,0)\\|_2}$ measures the amplification of the total $L^2$-norm of the solution, where $\\|W\\|_2^2 = \\int (w_l^2+w_n^2)dr$. A value of $G1$ (up to a small tolerance, here $1.3$) indicates instability.\n- **Constraint Leakage**: To assess numerical error, a proxy constraint $C(r,t) \\equiv \\left(\\partial_r \\phi\\right)_{\\mathrm{num}} - \\Phi(r,t)$ is defined. Here, $\\Phi \\equiv \\frac{w_n - w_l}{2\\sqrt{\\gamma^{rr}}}$ is an auxiliary field, and $\\phi$ is its discrete integral from the inner boundary. A non-zero $C$ indicates inconsistency between the numerical integration and differentiation. The leakage ratio $\\mathcal{R} \\equiv \\frac{\\|C(\\cdot,T)\\|_{2}}{\\|\\Phi(\\cdot,T)\\|_{2}}$ quantifies this error.\n\nThe implementation follows these principles, evolving the initial Gaussian pulse for $w_n$ and zero field for $w_l$ according to the specified test cases and reporting the resulting stability and error metrics.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (admissible excision, expected stable)\n        {'M': 1, 'A': 1, 'r0': 12, 'sigma': 1, 'rmin': 0.1, 'rmax': 50, 'N': 600, 'lambda_': 0.6, 'T': 8, 'r_in0': 2.0},\n        # Case B (inadmissible excision, expected unstable)\n        {'M': 1, 'A': 1, 'r0': 10, 'sigma': 1, 'rmin': 0.1, 'rmax': 30, 'N': 500, 'lambda_': 0.6, 'T': 6, 'r_in0': 2.4},\n        # Case C (admissible excision with tight Courant factor)\n        {'M': 1, 'A': 1, 'r0': 10, 'sigma': 1, 'rmin': 0.1, 'rmax': 30, 'N': 200, 'lambda_': 0.9, 'T': 6, 'r_in0': 2.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        res = run_simulation(**case)\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\ndef run_simulation(M, A, r0, sigma, rmin, rmax, N, lambda_, T, r_in0):\n    \"\"\"\n    Performs a single simulation run for a given set of parameters.\n    \"\"\"\n    r = np.linspace(rmin, rmax, N)\n    dr = r[1] - r[0]\n\n    def v_plus(r_val, M_val):\n        return np.divide(r_val - 2 * M_val, r_val + 2 * M_val)\n    \n    dt = lambda_ * dr\n\n    w_l = np.zeros(N)\n    w_n = A * np.exp(-(r - r0)**2 / sigma**2)\n\n    t = 0.0\n    r_in = r_in0\n\n    def l2_norm_combined(arr1, arr2, i_start, dr_val):\n        if i_start >= len(arr1):\n            return 0.0\n        active_slice = slice(i_start, None)\n        return np.sqrt(np.sum(arr1[active_slice]**2 + arr2[active_slice]**2) * dr_val)\n\n    i_in_initial = np.searchsorted(r, r_in, side='left')\n    initial_norm = l2_norm_combined(w_l, w_n, i_in_initial, dr)\n    if initial_norm == 0: initial_norm = 1.0 # Avoid division by zero\n    max_norm = initial_norm\n\n    def calculate_rhs(wl_in, wn_in, r_grid, dr_val, M_val, i_in_idx):\n        N_pts = len(r_grid)\n        rhs_l = np.zeros(N_pts)\n        rhs_n = np.zeros(N_pts)\n        \n        if i_in_idx >= N_pts: # No active points\n            return rhs_l, rhs_n\n\n        # RHS for w_l (v_minus = -1, upwind is forward difference)\n        for i in range(i_in_idx, N_pts - 1):\n             rhs_l[i] = (wl_in[i+1] - wl_in[i]) / dr_val # -v_minus * deriv, where v_minus=-1\n        \n        # Outer boundary for w_l (ghost point wl=0)\n        rhs_l[N_pts - 1] = (0 - wl_in[N_pts-1]) / dr_val\n        \n        # RHS for w_n\n        vp_grid = v_plus(r_grid, M_val)\n        \n        # Inner boundary for w_n (at i_in_idx)\n        if i_in_idx  N_pts - 1:\n            # Per problem spec, use forward difference to reveal instability.\n            # This is upwind if v_p0, and downwind if v_p>0.\n            deriv_n = (wn_in[i_in_idx+1] - wn_in[i_in_idx]) / dr_val\n            rhs_n[i_in_idx] = -vp_grid[i_in_idx] * deriv_n\n        \n        # Interior points for w_n\n        for i in range(i_in_idx + 1, N_pts - 1):\n            if vp_grid[i] > 0: # Upwind is backward\n                deriv_n = (wn_in[i] - wn_in[i-1]) / dr_val\n            else: # Upwind is forward\n                deriv_n = (wn_in[i+1] - wn_in[i]) / dr_val\n            rhs_n[i] = -vp_grid[i] * deriv_n\n\n        # Outer boundary for w_n (at N_pts - 1)\n        if N_pts - 1 > i_in_idx:\n            i = N_pts - 1\n            if vp_grid[i] > 0: # Upwind is backward (normal case)\n                deriv_n = (wn_in[i] - wn_in[i-1]) / dr_val\n                rhs_n[i] = -vp_grid[i] * deriv_n\n            # else: case v_p=0 not expected at r_max for these problems.\n\n        return rhs_l, rhs_n\n\n    while t  T:\n        current_dt = min(dt, T - t)\n        if current_dt  1e-12: break\n        \n        i_in = np.searchsorted(r, r_in, side='left')\n        \n        # SSP-RK3\n        # Stage 1\n        rhs_l_1, rhs_n_1 = calculate_rhs(w_l, w_n, r, dr, M, i_in)\n        w_l_1 = w_l + current_dt * rhs_l_1\n        w_n_1 = w_n + current_dt * rhs_n_1\n        \n        # Stage 2\n        rhs_l_2, rhs_n_2 = calculate_rhs(w_l_1, w_n_1, r, dr, M, i_in)\n        w_l_2 = 0.75 * w_l + 0.25 * (w_l_1 + current_dt * rhs_l_2)\n        w_n_2 = 0.75 * w_n + 0.25 * (w_n_1 + current_dt * rhs_n_2)\n\n        # Stage 3\n        rhs_l_3, rhs_n_3 = calculate_rhs(w_l_2, w_n_2, r, dr, M, i_in)\n        w_l = (1/3) * w_l + (2/3) * (w_l_2 + current_dt * rhs_l_3)\n        w_n = (1/3) * w_n + (2/3) * (w_n_2 + current_dt * rhs_n_3)\n        \n        t += current_dt\n        r_in -= current_dt # dr_in/dt = -1\n\n        i_in_new = np.searchsorted(r, r_in, side='left')\n        current_norm = l2_norm_combined(w_l, w_n, i_in_new, dr)\n        if current_norm > max_norm:\n            max_norm = current_norm\n    \n    G = max_norm / initial_norm\n    stable = G = 1.3\n    \n    i_in_final = np.searchsorted(r, r_in, side='left')\n    \n    # If all points are excised, constraint error is zero.\n    if i_in_final >= N or r[i_in_final:].size == 0:\n         return [stable, G, 0.0]\n\n    active_slice = slice(i_in_final, None)\n    active_r = r[active_slice]\n    active_wl = w_l[active_slice]\n    active_wn = w_n[active_slice]\n        \n    sqrt_gamma_rr = np.sqrt(np.divide(active_r, active_r + 2 * M))\n    Phi = np.divide(active_wn - active_wl, 2 * sqrt_gamma_rr, out=np.zeros_like(active_wn), where=(sqrt_gamma_rr > 1e-12))\n    \n    phi = np.zeros_like(Phi)\n    # Trapezoidal rule for integration\n    for i in range(1, len(phi)):\n        phi[i] = phi[i-1] + 0.5 * (Phi[i] + Phi[i-1]) * dr\n        \n    d_phi_num = np.zeros_like(phi)\n    if len(phi) > 1:\n        d_phi_num[0] = (phi[1] - phi[0]) / dr # Forward difference\n        d_phi_num[-1] = (phi[-1] - phi[-2]) / dr # Backward difference\n        # Centered difference for interior\n        for i in range(1, len(phi) - 1):\n            d_phi_num[i] = (phi[i+1] - phi[i-1]) / (2 * dr)\n    \n    C = d_phi_num - Phi\n    \n    norm_C = np.sqrt(np.sum(C**2) * dr)\n    norm_Phi = np.sqrt(np.sum(Phi**2) * dr)\n    \n    R = 0.0\n    if norm_Phi > 1e-12:\n        R = norm_C / norm_Phi\n\n    return [stable, float(G), float(R)]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}