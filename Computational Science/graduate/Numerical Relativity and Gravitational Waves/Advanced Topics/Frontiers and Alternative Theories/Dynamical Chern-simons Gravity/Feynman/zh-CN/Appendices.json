{
    "hands_on_practices": [
        {
            "introduction": "在研究动力学陈-西蒙斯（dCS）引力时，数值模拟是至关重要的工具。然而，在模拟复杂的物理现象之前，我们必须首先确保我们的代码能够准确地求解其基本方程。本练习  将介绍一种强大的代码验证技术——人造解方法（Method of Manufactured Solutions），并将其应用于简化的dCS标量场波动方程，从而为更复杂的计算打下坚实的基础。",
            "id": "3472081",
            "problem": "要求您使用人工解方法 (Method of Manufactured Solutions) 来验证一个用于动力学Chern-Simons (dCS) 引力标量部分的数值演化代码。在平直时空背景下，于动力学Chern-Simons引力的解耦极限中，dCS标量场满足一个有源波动方程，形式为 $\\Box \\vartheta = \\mathcal{S}$，其中 $\\Box$ 是Minkowski时空中的d'Alembert算子，$\\mathcal{S}$ 代表一个有效源（例如，与从背景几何构建的引力Pontryagin密度成正比）。为了进行代码验证，您将在一个空间维度上使用周期性边界条件，并构造一个人工解析解 $\\vartheta(x,t)$，推导出与波动方程一致的相应源 $\\mathcal{S}(x,t)$，然后验证一个二阶精度的有限差分解算器是否达到了预期的收敛率。\n\n推导的基本依据是：带有外部源的Minkowski空间标量波动方程，\n$$\n\\partial_t^2 \\vartheta - c^2 \\partial_x^2 \\vartheta = \\mathcal{S},\n$$\n该方程设置在一个一维周期性域 $x \\in [0,1]$ 上，具有周期性边界条件，并使用无量纲单位，其中 $c$ 是一个无量纲波速。指定的人工解析解为\n$$\n\\vartheta(x,t) = \\sin(k x)\\cos(\\omega t),\n$$\n其中 $k = 2\\pi m$，$m \\in \\mathbb{N}$，角频率 $\\omega > 0$，且 $c > 0$。本问题中的所有量都是无量纲的。\n\n您的任务是：\n- 根据上述人工解和波动方程，推导源 $\\mathcal{S}(x,t)$，并用 $m$、$\\omega$、$c$ 以及 $x$、$t$ 表示。\n- 实现一个空间上二阶精度的有限差分方法和一个二阶精度的时间积分器，以根据以下时间上一阶的系统来演化场量 $(\\vartheta, \\Pi)$，其中 $\\Pi = \\partial_t \\vartheta$：\n$$\n\\partial_t \\vartheta = \\Pi, \\quad \\partial_t \\Pi = c^2 \\partial_x^2 \\vartheta + \\mathcal{S}(x,t).\n$$\n使用一个包含 $N$ 个点的均匀网格，网格间距为 $\\Delta x = 1/N$，并采用周期性边界条件，时间步长为 $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / c$，其中 $\\mathrm{CFL} \\in (0,1)$ 是一个选定的常数。\n- 在 $t=0$ 时，根据人工解进行初始化：$\\vartheta(x,0) = \\sin(k x)$ 和 $\\Pi(x,0) = \\partial_t \\vartheta(x,0) = 0$。\n- 将系统演化至最终时间 $T$，然后计算 $\\vartheta$ 中误差的空间 $L^2$ 范数，\n$$\nE_N = \\left( \\int_0^1 \\left[\\vartheta_N(x,T) - \\vartheta_{\\text{exact}}(x,T)\\right]^2 \\, dx \\right)^{1/2},\n$$\n该范数在均匀网格上使用复合梯形法则进行近似（在周期性均匀网格上，这等于 $\\sqrt{\\Delta x \\sum_j (\\cdot)^2}$）。此处 $\\vartheta_N$ 表示使用 $N$ 个网格点得到的数值解。\n- 对于一个网格加密对 $(N_1, N_2)$，其中 $N_2 = 2 N_1$，计算观测到的收敛阶\n$$\np_{\\mathrm{obs}} = \\frac{\\log(E_{N_1} / E_{N_2})}{\\log(\\Delta x_{N_1} / \\Delta x_{N_2})}.\n$$\n\n角度单位为弧度。所有量均为无量纲。您的程序必须实现解算器，并为以下三个测试案例中的每一个计算 $p_{\\mathrm{obs}}$。对于每个案例，使用 $c = 1$，域 $x \\in [0,1]$，以及周期性边界条件：\n- 案例A（一般源，中等频率）：$m = 1$，$\\omega = 3.0$，$\\mathrm{CFL} = 0.4$，$T = 0.7$，网格对 $(N_1,N_2) = (32,64)$。\n- 案例B（一般源，更高空间频率）：$m = 2$，$\\omega = 5.0$，$\\mathrm{CFL} = 0.4$，$T = 0.5$，网格对 $(N_1,N_2) = (48,96)$。\n- 案例C（齐次波动方程，精确的人工波）：$m = 1$，$\\omega = 2\\pi$，$\\mathrm{CFL} = 0.4$，$T = 0.4$，网格对 $(N_1,N_2) = (24,48)$。\n\n您的程序应产生单行输出，其中包含三个案例的观测收敛阶，形式为方括号括起来的逗号分隔列表，每个值四舍五入到六位小数，例如 $[p_A,p_B,p_C]$，其中每个条目都是一个浮点数。最终答案是无单位的浮点数。\n\n覆盖性设计：\n- 案例A是一个带有非平凡源的典型案例（“理想路径”）。\n- 案例B通过更高的模数 $m$ 对空间分辨率提出了考验。\n- 案例C通过选择 $\\omega = c k$ 将源设置为零，用于测试齐次波情况和边界条件的处理。\n\n重要实现细节：\n- 空间离散化：对 $\\partial_x^2 \\vartheta$ 使用二阶中心有限差分。\n- 时间离散化：将一种二阶精度的显式格式，如两步显式Runge–Kutta方法（Heun方法），应用于上述半离散系统。\n- 在每个测试中，对 $N_1$ 和 $N_2$ 使用相同的 $\\mathrm{CFL}$，以便在加密研究中保持时间离散化误差处于同一阶。\n\n您的程序不得要求用户输入，且必须只在单行上打印最终列表 $[p_A,p_B,p_C]$。所有计算均在无量纲单位下进行，角度量以弧度为单位。最终报告的值必须是四舍五入到六位小数的浮点数。",
            "solution": "该问题已经过细致验证，并被确定为有效。它具有科学依据、是良定的、客观的、自洽的并且是可形式化的。所有构建唯一、可验证解所必需的参数和条件均已提供。\n\n任务是使用人工解方法 (Method of Manufactured Solutions) 验证一个用于有源一维标量波动方程的数值解算器。这包括为给定解析解推导源项，实现一个二阶精度的数值格式，并确认理论收敛率。\n\n首先，我们推导波动方程\n$$\n\\partial_t^2 \\vartheta - c^2 \\partial_x^2 \\vartheta = \\mathcal{S}(x,t)\n$$\n和人工解\n$$\n\\vartheta(x,t) = \\sin(k x)\\cos(\\omega t),\n$$\n(其中 $k=2\\pi m$) 所要求的源项 $\\mathcal{S}(x,t)$。我们计算 $\\vartheta(x,t)$ 的必要偏导数。关于时间 $t$ 的二阶偏导数是：\n$$\n\\partial_t \\vartheta(x,t) = -\\omega \\sin(k x)\\sin(\\omega t)\n$$\n$$\n\\partial_t^2 \\vartheta(x,t) = -\\omega^2 \\sin(k x)\\cos(\\omega t)\n$$\n关于空间 $x$ 的二阶偏导数是：\n$$\n\\partial_x \\vartheta(x,t) = k \\cos(k x)\\cos(\\omega t)\n$$\n$$\n\\partial_x^2 \\vartheta(x,t) = -k^2 \\sin(k x)\\cos(\\omega t)\n$$\n将这些代入波动方程，得到源项 $\\mathcal{S}$：\n$$\n\\mathcal{S}(x,t) = (-\\omega^2 \\sin(k x)\\cos(\\omega t)) - c^2 (-k^2 \\sin(k x)\\cos(\\omega t))\n$$\n$$\n\\mathcal{S}(x,t) = (-\\omega^2 + c^2 k^2) \\sin(k x)\\cos(\\omega t)\n$$\n这是必须在数值解算器中实现的源项的解析表达式。对于案例C，其中 $c=1$, $m=1$, 且 $\\omega=2\\pi$，我们有 $k=2\\pi m = 2\\pi$。前置因子变为 $(-\\omega^2 + c^2 k^2) = (-(2\\pi)^2 + 1^2 (2\\pi)^2) = 0$，因此 $\\mathcal{S}(x,t)=0$，正如预期。\n\n接下来，我们设计数值格式。该问题被表述为时间上的一阶系统：\n$$\n\\partial_t \\vartheta = \\Pi\n$$\n$$\n\\partial_t \\Pi = c^2 \\partial_x^2 \\vartheta + \\mathcal{S}(x,t)\n$$\n我们使用一个包含 $N$ 个点的均匀网格来离散化空间域 $x \\in [0,1]$，其中 $x_j = j \\Delta x$，$j \\in \\{0, 1, ..., N-1\\}$，网格间距为 $\\Delta x = 1/N$。在网格点 $x_j$ 处的二阶空间导数 $\\partial_x^2 \\vartheta$ 使用一个二阶精度的中心有限差分模板进行近似，并遵循周期性边界条件：\n$$\n(\\partial_x^2 \\vartheta)_j \\approx \\frac{\\vartheta_{j+1} - 2\\vartheta_j + \\vartheta_{j-1}}{(\\Delta x)^2}\n$$\n其中索引在模 $N$ 下计算。这种半离散化产生了一个关于网格函数 $\\vec{\\vartheta}(t)$ 和 $\\vec{\\Pi}(t)$ 的常微分方程组 (ODEs)。\n\n对于时间演化，我们采用二阶精度的显式Runge-Kutta方法，具体来说是Heun方法。令状态向量为 $\\mathbf{Y}(t) = (\\vec{\\vartheta}(t), \\vec{\\Pi}(t))^T$。从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的更新是一个两步过程：\n1. 预测步：使用显式欧拉步计算一个中间状态 $\\mathbf{Y}^*$。\n$$\n\\vec{\\vartheta}^* = \\vec{\\vartheta}_n + \\Delta t \\cdot \\vec{\\Pi}_n\n$$\n$$\n\\vec{\\Pi}^* = \\vec{\\Pi}_n + \\Delta t \\cdot \\left(c^2 (\\partial_x^2\\vec{\\vartheta})_n + \\vec{\\mathcal{S}}(t_n)\\right)\n$$\n2. 校正步：使用初始状态和预测状态处导数的平均值计算最终状态 $\\mathbf{Y}_{n+1}$。\n$$\n\\vec{\\vartheta}_{n+1} = \\vec{\\vartheta}_n + \\frac{\\Delta t}{2} (\\vec{\\Pi}_n + \\vec{\\Pi}^*)\n$$\n$$\n\\vec{\\Pi}_{n+1} = \\vec{\\Pi}_n + \\frac{\\Delta t}{2} \\left[ \\left(c^2 (\\partial_x^2\\vec{\\vartheta})_n + \\vec{\\mathcal{S}}(t_n)\\right) + \\left(c^2 (\\partial_x^2\\vec{\\vartheta})^* + \\vec{\\mathcal{S}}(t_{n+1})\\right) \\right]\n$$\n时间步长由Courant-Friedrichs-Lewy (CFL) 条件设定，$\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / c$，这确保了稳定性并将空间和时间分辨率耦合起来。\n\n初始条件在 $t=0$ 时根据人工解设定：$\\vartheta(x,0) = \\sin(k x)$ 和 $\\Pi(x,0) = \\partial_t\\vartheta(x,0) = 0$。将系统演化至最终时间 $T$ 后，我们计算误差。数值解 $\\vartheta_N(x,T)$ 与精确解 $\\vartheta_{\\text{exact}}(x,T)$ 之间误差的空间 $L^2$ 范数在网格上近似为：\n$$\nE_N = \\sqrt{\\Delta x \\sum_{j=0}^{N-1} \\left( \\vartheta_{N,j}(T) - \\vartheta_{\\text{exact}}(x_j, T) \\right)^2}\n$$\n为了验证收敛率，我们使用来自两次模拟（分辨率分别为 $N_1$ 和 $N_2 = 2N_1$）的误差 $E_{N_1}$ 和 $E_{N_2}$ 来计算观测到的收敛阶 $p_{\\mathrm{obs}}$：\n$$\np_{\\mathrm{obs}} = \\frac{\\log(E_{N_1} / E_{N_2})}{\\log(\\Delta x_1 / \\Delta x_2)} = \\frac{\\log(E_{N_1} / E_{N_2})}{\\log(2)}\n$$\n由于空间和时间离散化都是二阶精度的，并且 $\\Delta t \\propto \\Delta x$，我们预期整体方法是二阶的，从而得到 $p_{\\mathrm{obs}} \\approx 2$。以下程序实现了这个过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the dCS wave equation verification problem for three test cases.\n    \"\"\"\n\n    def run_simulation_and_get_error(m, omega, c, cfl, T, N):\n        \"\"\"\n        Runs a single simulation and returns the L2 error.\n        \n        Args:\n            m (int): Mode number for the manufactured solution.\n            omega (float): Angular frequency.\n            c (float): Wave speed.\n            cfl (float): CFL factor.\n            T (float): Final evolution time.\n            N (int): Number of grid points.\n            \n        Returns:\n            float: The L2 norm of the error at time T.\n        \"\"\"\n        k = 2.0 * np.pi * m\n        dx = 1.0 / N\n        x = np.arange(N) * dx\n        dt = cfl * dx / c\n        n_steps = int(round(T / dt))\n\n        # Define analytic source and exact solution functions\n        def source_S(grid_x, t):\n            prefactor = -omega**2 + c**2 * k**2\n            if np.isclose(prefactor, 0.0):\n                return np.zeros_like(grid_x)\n            return prefactor * np.sin(k * grid_x) * np.cos(omega * t)\n\n        def exact_theta(grid_x, t):\n            return np.sin(k * grid_x) * np.cos(omega * t)\n\n        # Initial conditions from exact solution at t=0\n        theta = exact_theta(x, 0.0)\n        # pi = d(theta)/dt = -omega * sin(kx) * sin(wt). At t=0, pi is 0.\n        pi = np.zeros_like(x)\n        t = 0.0\n\n        # Time evolution using Heun's method (RK2)\n        for _ in range(n_steps):\n            # Stage 1: Predictor step (explicit Euler)\n            # RHS at current time t\n            d2x_theta = (np.roll(theta, -1) - 2 * theta + np.roll(theta, 1)) / (dx**2)\n            rhs_pi_t = c**2 * d2x_theta + source_S(x, t)\n            \n            # Predicted state at t + dt\n            theta_star = theta + dt * pi\n            pi_star = pi + dt * rhs_pi_t\n            \n            # Stage 2: Corrector step\n            # RHS at predicted time t + dt\n            t_plus_dt = t + dt\n            d2x_theta_star = (np.roll(theta_star, -1) - 2 * theta_star + np.roll(theta_star, 1)) / (dx**2)\n            rhs_pi_star = c**2 * d2x_theta_star + source_S(x, t_plus_dt)\n            \n            # Update fields using average of slopes\n            theta += 0.5 * dt * (pi + pi_star)\n            pi += 0.5 * dt * (rhs_pi_t + rhs_pi_star)\n            \n            t = t_plus_dt\n\n        # Compute L2 error against exact solution at final time T\n        theta_final_exact = exact_theta(x, T)\n        error_sq_integrand = (theta - theta_final_exact)**2\n        l2_error = np.sqrt(dx * np.sum(error_sq_integrand))\n        \n        return l2_error\n\n    # Define test cases as per the problem statement\n    # Each tuple: (m, omega, CFL, T, (N1, N2))\n    test_cases = [\n        (1, 3.0, 0.4, 0.7, (32, 64)),      # Case A\n        (2, 5.0, 0.4, 0.5, (48, 96)),      # Case B\n        (1, 2 * np.pi, 0.4, 0.4, (24, 48)) # Case C\n    ]\n    \n    c_wave_speed = 1.0\n    observed_orders = []\n\n    for m, omega, cfl, T, (N1, N2) in test_cases:\n        # Run simulations for the grid pair\n        error1 = run_simulation_and_get_error(m, omega, c_wave_speed, cfl, T, N1)\n        error2 = run_simulation_and_get_error(m, omega, c_wave_speed, cfl, T, N2)\n        \n        # Grid spacings\n        dx1 = 1.0 / N1\n        dx2 = 1.0 / N2\n        \n        # Calculate observed order of convergence\n        if error1 > 0 and error2 > 0:\n            p_obs = np.log(error1 / error2) / np.log(dx1 / dx2)\n        else:\n            # Handle cases with zero or near-zero error if they occur\n            p_obs = 0.0\n            \n        observed_orders.append(p_obs)\n\n    # Format and print the final results as specified\n    formatted_results = [f\"{order:.6f}\" for order in observed_orders]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "动力学陈-西蒙斯（dCS）引力的一个关键预测是其对引力波的宇称破缺效应，这会导致所谓的振幅双折射现象。本练习  通过一个简化的模型，将不同偏振的引力波演化为受阻尼或放大的振子，为您提供了一种具体探索该现象的方法。通过求解此模型，您将直接观察到dCS引力是如何区分左旋和右旋偏振的。",
            "id": "3471988",
            "problem": "考虑动态陈-西蒙斯引力 (dCS)，其定义是在爱因斯坦-希尔伯特作用量的基础上，增加一个赝标量场与庞特里亚金密度之间的宇称破缺耦合。在赝标量场被视为给定背景且时空近似为闵可夫斯基时空的解耦极限下，线性化引力波可以表示为具有圆偏振态的平面波。设背景赝标量场是均匀且线性演化的，$\\vartheta(t) = \\vartheta_{0} + \\nu t$，其中 $\\nu$ 为恒定速率。在小耦合机制下，对于一个共动波数为 $k$ 的单一傅里叶模式，圆偏振态 $A \\in \\{+1,-1\\}$ 的振幅演化可以用以下线性常微分方程来建模\n$$\n\\frac{d^{2} a_{A}}{dt^{2}} + 2 \\beta_{A}\\,\\frac{d a_{A}}{dt} + \\omega^{2}\\, a_{A} = 0,\n$$\n其中 $\\beta_{A} = A\\, \\lambda\\, k\\, \\nu$，$\\omega = k$，并且 $\\lambda$ 是一个无量纲参数，它汇集了动态陈-西蒙斯引力中的相关耦合常数和尺度。该模型捕捉了均匀赝标量背景下的螺旋度相关振幅双折射现象。在 $c=1$ 的自然单位制下进行计算，并考虑初始条件 $a_{A}(0)=1$ 和 $\\dot{a}_{A}(0)=0$。所有振幅都是无量纲的，最终要求的输出是无量纲的浮点误差。\n\n你的任务是根据上述方程的解析解，校准和验证其数值时间积分。你编写的程序必须：\n\n- 将系统重写为关于时间的一阶系统，并使用固定步长的四阶龙格-库塔方法对 $a_{A}(t)$ 和 $\\dot{a}_{A}(t)$ 在时间区间 $[0,T]$（其中 $T>0$）上进行积分，从而为该系统实现一个数值积分器。\n- 推导并实现与上述初始条件和参数 $(A,k,\\lambda,\\nu)$ 一致的 $a_{A}(t)$ 的闭式解析解。\n- 对于下面列出的每个测试用例，计算在 $t=T$ 时数值解与解析解之间的绝对误差，即 $\\left|a_{A}^{\\text{num}}(T) - a_{A}^{\\text{ana}}(T)\\right|$。\n- 将所有测试用例的误差汇总到一个列表中，并将该列表作为唯一的输出行打印出来。\n\n使用以下测试套件来检验不同的机制：\n\n- 基准广义相对论 (GR) 极限，耦合消失：$(A,k,\\lambda,\\nu,T) = (+1,\\, 50.0,\\, 0.0,\\, 0.1,\\, 2.0)$。这验证了当 $\\lambda = 0$ 时，模型能恢复到广义相对论的情况，此时 $k=\\omega=50.0$ 且 $T=2.0$。\n- 轻度双折射，欠阻尼右旋模式：$(A,k,\\lambda,\\nu,T) = (+1,\\, 10.0,\\, 0.05,\\, 0.2,\\, 3.0)$，因此 $\\beta_{A} = A \\lambda k \\nu = +0.1$ 且 $\\omega = 10.0$。\n- 伴随增长的轻度双折射，欠阻尼左旋模式：$(A,k,\\lambda,\\nu,T) = (-1,\\, 3.0,\\, 0.2,\\, 0.8,\\, 10.0)$，因此 $\\beta_{A} = -0.48$ 且 $\\omega = 3.0$，用于测试螺旋度相关放大下的稳定性。\n- 高频波与弱双折射：$(A,k,\\lambda,\\nu,T) = (+1,\\, 200.0,\\, 0.001,\\, 0.5,\\, 0.5)$，因此 $\\beta_{A} = +0.1$ 且 $\\omega = 200.0$，用于测试对快速振荡的数值分辨率。\n\n所有量在自然单位制下均被视为无量纲。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[x1,x2,x3,x4]”），其中每个 $x_{i}$ 是对应测试用例的绝对误差，以浮点数表示。不应打印任何其他文本。",
            "solution": "所提出的问题是有效的。它是一个定义明确的初值问题，基于用于研究动态陈-西蒙斯引力现象的标准物理模型。该问题自成体系、科学上合理且计算上可行。\n\n问题的核心是求解以下具有常系数的二阶线性齐次常微分方程 (ODE)：\n$$\n\\frac{d^{2} a_{A}}{dt^{2}} + 2 \\beta_{A}\\,\\frac{d a_{A}}{dt} + \\omega^{2}\\, a_{A} = 0\n$$\n该方程满足初始条件 $a_{A}(0)=1$ 和 $\\dot{a}_{A}(0)=0$。参数由 $\\beta_{A} = A\\, \\lambda\\, k\\, \\nu$ 和 $\\omega = k$ 给出。我们需要将通过四阶龙格-库塔 (RK$4$) 方法获得的数值解与推导出的解析解进行比较。\n\n### 1. 解析解的推导\n\n我们首先求解该常微分方程的特征方程：\n$$\nr^2 + 2 \\beta_{A} r + \\omega^2 = 0\n$$\n根 $r$ 由二次方程求根公式给出：\n$$\nr = \\frac{-2 \\beta_{A} \\pm \\sqrt{(2 \\beta_{A})^2 - 4(1)(\\omega^2)}}{2} = -\\beta_{A} \\pm \\sqrt{\\beta_{A}^2 - \\omega^2}\n$$\n解的性质取决于判别式 $\\Delta = \\beta_{A}^2 - \\omega^2$ 的符号。我们分析三种可能的情况。\n\n**情况1：欠阻尼运动 ($\\beta_{A}^2  \\omega^2$)**\n判别式为负。我们定义一个实角频率 $\\Omega = \\sqrt{\\omega^2 - \\beta_{A}^2}$。根是复共轭的：\n$$\nr_{1,2} = -\\beta_{A} \\pm i\\Omega\n$$\n通解的形式为：\n$$\na_{A}(t) = e^{-\\beta_{A} t} \\left( C_1 \\cos(\\Omega t) + C_2 \\sin(\\Omega t) \\right)\n$$\n我们应用初始条件来求解常数 $C_1$ 和 $C_2$。\n根据 $a_{A}(0)=1$：\n$$\na_{A}(0) = e^{0} (C_1 \\cos(0) + C_2 \\sin(0)) = C_1 \\implies C_1 = 1\n$$\n一阶导数为：\n$$\n\\dot{a}_{A}(t) = -\\beta_{A} e^{-\\beta_{A} t} \\left( \\cos(\\Omega t) + C_2 \\sin(\\Omega t) \\right) + e^{-\\beta_{A} t} \\left( -\\Omega \\sin(\\Omega t) + \\Omega C_2 \\cos(\\Omega t) \\right)\n$$\n根据 $\\dot{a}_{A}(0)=0$：\n$$\n\\dot{a}_{A}(0) = -\\beta_{A}(1) + \\Omega C_2 = 0 \\implies C_2 = \\frac{\\beta_{A}}{\\Omega}\n$$\n因此，欠阻尼情况下的特解是：\n$$\na_{A}(t) = e^{-\\beta_{A} t} \\left( \\cos(\\Omega t) + \\frac{\\beta_{A}}{\\Omega} \\sin(\\Omega t) \\right)\n$$\n问题中提供的所有测试用例都属于这一类，因为对所有用例都有 $\\omega > |\\beta_A|$。这包括 $\\beta_A=0$ 的广义相对论情况，此时解简化为 $a_A(t) = \\cos(\\omega t)$。它也包括 $\\beta_A  0$ 的情况，此时表现为指数增长。\n\n**情况2：临界阻尼运动 ($\\beta_{A}^2 = \\omega^2$)**\n判别式为零，得到一个实根 $r = -\\beta_{A}$。通解为：\n$$\na_{A}(t) = (C_1 + C_2 t) e^{-\\beta_{A} t}\n$$\n应用 $a_{A}(0)=1$ 得到 $C_1=1$。导数为 $\\dot{a}_{A}(t) = C_2 e^{-\\beta_{A} t} - \\beta_A(C_1+C_2 t)e^{-\\beta_A t}$。应用 $\\dot{a}_A(0)=0$ 得到 $C_2 - \\beta_A C_1 = 0 \\implies C_2 = \\beta_A$。解为 $a_A(t) = (1+\\beta_A t)e^{-\\beta_A t}$。\n\n**情况3：过阻尼运动 ($\\beta_{A}^2 > \\omega^2$)**\n判别式为正。设 $q = \\sqrt{\\beta_{A}^2 - \\omega^2}$。根为实数且不相等：$r_{1,2} = -\\beta_A \\pm q$。通解可以写成：\n$$\na_{A}(t) = e^{-\\beta_{A} t} \\left( C_1 \\cosh(q t) + C_2 \\sinh(q t) \\right)\n$$\n应用 $a_{A}(0)=1$ 得到 $C_1=1$。导数为 $\\dot{a}_{A}(t) = -\\beta_A e^{-\\beta_A t}(\\dots) + e^{-\\beta_A t}(q C_1 \\sinh(qt) + q C_2 \\cosh(qt))$。应用 $\\dot{a}_A(0)=0$ 得到 $-\\beta_A C_1 + q C_2 = 0 \\implies C_2 = \\beta_A/q$。解为 $a_A(t) = e^{-\\beta_A t} (\\cosh(qt) + \\frac{\\beta_A}{q}\\sinh(qt))$。\n\n### 2. 数值积分：四阶龙格-库塔 (RK4) 方法\n\n为了应用数值积分器，我们首先将二阶常微分方程转换为一个包含两个一阶常微分方程的方程组。设状态向量为 $\\mathbf{y}(t) = [y_1(t), y_2(t)]^T$，其中 $y_1 = a_A$，$y_2 = \\dot{a}_A$。该系统为：\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})\n$$\n其中\n$$\n\\frac{dy_1}{dt} = y_2\n$$\n$$\n\\frac{dy_2}{dt} = -2\\beta_A y_2 - \\omega^2 y_1\n$$\n因此，$\\mathbf{f}(t, \\mathbf{y}) = \\begin{pmatrix} y_2 \\\\ -2\\beta_A y_2 - \\omega^2 y_1 \\end{pmatrix}$。初始状态为 $\\mathbf{y}(0) = [1, 0]^T$。\n\nRK$4$ 方法使用固定步长 $h$ 将解从时间 $t_n$推进到 $t_{n+1} = t_n + h$：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + 2\\mathbf{k}_4)\n$$\n其中中间斜率为：\n\\begin{align*}\n\\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = \\mathbf{f}(t_n + h/2, \\mathbf{y}_n + h/2 \\cdot \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathbf{f}(t_n + h/2, \\mathbf{y}_n + h/2 \\cdot \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathbf{f}(t_n + h, \\mathbf{y}_n + h \\cdot \\mathbf{k}_3)\n\\end{align*}\n为确保高精度，特别是对于高频 $\\omega=200.0$ 的测试用例，必须选择一个小的步长 $h$。最快振荡的周期是 $P = 2\\pi/\\omega \\approx 0.0314$。步长 $h=10^{-5}$ 在每个周期内提供了超过 $3000$ 个步长，这对于精确的 RK$4$ 积分来说绰绰有余。为确保恰好在最终时间 $T$ 结束，步长可以调整为 $h_{\\text{adj}} = T/N$，其中 $N = \\lceil T/h \\rceil$。\n\n### 3. 误差计算\n\n对于每个测试用例，我们计算解析解 $a_A^{\\text{ana}}(T)$ 和数值解 $a_A^{\\text{num}}(T) = y_1(T)$。最终输出是每种情况的绝对误差：\n$$\n\\text{Error} = |a_A^{\\text{num}}(T) - a_A^{\\text{ana}}(T)|\n$$\n该实现将为每组参数计算此误差，并整理结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the dCS ODE problem by comparing analytic and numerical solutions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (A, k, lambda, nu, T)\n    test_cases = [\n        (1.0, 50.0, 0.0, 0.1, 2.0),\n        (1.0, 10.0, 0.05, 0.2, 3.0),\n        (-1.0, 3.0, 0.2, 0.8, 10.0),\n        (1.0, 200.0, 0.001, 0.5, 0.5),\n    ]\n\n    results = []\n    # Use a fixed step size for the RK4 integrator. This value is chosen to be small\n    # enough to guarantee high accuracy for the highest frequency in the test cases.\n    h = 1e-5\n\n    for case in test_cases:\n        A, k, lam, nu, T = case\n\n        # Calculate model parameters\n        omega = k\n        beta_A = A * lam * k * nu\n\n        # --- Analytic Solution ---\n        # The analytic solution depends on the discriminant of the characteristic equation.\n        # All test cases correspond to the underdamped/growing regime.\n        discriminant = beta_A**2 - omega**2\n\n        if discriminant  0:\n            # Underdamped case (includes undamped and growing modes)\n            Omega_val = np.sqrt(-discriminant)\n            # The analytic solution at time T\n            analytic_val = (np.exp(-beta_A * T) * \n                            (np.cos(Omega_val * T) + (beta_A / Omega_val) * np.sin(Omega_val * T)))\n        elif discriminant == 0:\n            # Critically damped case (not in test suite, but included for completeness)\n            analytic_val = (1 + beta_A * T) * np.exp(-beta_A * T)\n        else: # discriminant > 0\n            # Overdamped case (not in test suite)\n            q = np.sqrt(discriminant)\n            analytic_val = (np.exp(-beta_A * T) *\n                             (np.cosh(q * T) + (beta_A / q) * np.sinh(q * T)))\n\n\n        # --- Numerical Solution (RK4) ---\n        # State vector y = [a, a_dot]\n        y = np.array([1.0, 0.0])\n        \n        # The ODE system dy/dt = f(t, y)\n        def f(t_ignored, y_vec, beta, omega_sq):\n            y1, y2 = y_vec\n            dy1dt = y2\n            dy2dt = -2.0 * beta * y2 - omega_sq * y1\n            return np.array([dy1dt, dy2dt])\n            \n        # Calculate number of steps and adjust step size to land exactly on T\n        num_steps = int(np.ceil(T / h))\n        actual_h = T / num_steps\n        \n        omega_sq = omega**2\n        \n        t = 0.0\n        for _ in range(num_steps):\n            k1 = f(t, y, beta_A, omega_sq)\n            k2 = f(t + actual_h / 2.0, y + actual_h / 2.0 * k1, beta_A, omega_sq)\n            k3 = f(t + actual_h / 2.0, y + actual_h / 2.0 * k2, beta_A, omega_sq)\n            k4 = f(t + actual_h, y + actual_h * k3, beta_A, omega_sq)\n            \n            y += (actual_h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            t += actual_h\n        \n        numerical_val = y[0]\n        \n        # --- Calculate and store the absolute error ---\n        error = np.abs(numerical_val - analytic_val)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "动力学陈-西蒙斯（dCS）引力不仅影响引力波的传播，还会改变旋转黑洞周围的强引力场时空。本练习  将通过计算由dCS引力对参考系拖拽效应的修正所引起的最内稳定圆轨道（ISCO）频率的移动，来探索这种时空结构的改变。通过这项实践，您将深化对修正引力理论如何改变关键天体物理可观测量的理解，并掌握检验理论近似有效性的方法。",
            "id": "3472075",
            "problem": "考虑一个描述旋转黑洞的稳态、轴对称、渐近平坦时空，其质量为 $M$，无量纲自旋参数为 $\\chi \\in [0,1)$。在 $G=c=1$ 的几何化单位中进行计算。重点研究赤道平面圆形类时测地线和最内稳定圆轨道 (ISCO)。在广义相对论中，Kerr 时空提供了一个基准度规。在限制于赤道平面 $\\theta=\\pi/2$ 的 Boyer–Lindquist 坐标系中，相关的 Kerr 度规分量是径向坐标 $r$ 和自旋参数 $a = \\chi M$ 的函数，可以用它们来确定赤道圆形测地线的轨道角频率 $\\Omega$ 和 ISCO 半径 $r_{\\rm ISCO}$。在动力学 Chern-Simons (dCS) 引力（此处定义为广义相对论的宇称破缺扩展，其中一个额外的标量场与 Pontryagin 密度耦合）中，领头阶的慢速旋转、小耦合修正主要修正了编码在 $g_{t\\phi}$ 分量中的标架场拖拽部分。\n\n您的任务是设计并实现一个程序，对于一组指定的 $(\\chi,\\zeta)$ 对，测量一个数值定义的 dCS 对 ISCO 角频率的修正，并将其与一个慢速旋转解析预测进行比较。比较结果必须以无量纲频率 $M\\Omega$ 和无量纲差异的形式报告。请从第一性原理出发，按以下步骤进行：\n\n- 基本基础：\n  - 使用 Kerr 时空作为零阶背景。对于 Kerr 时空中的赤道圆形轨道，顺行轨道频率是测地线运动的一个已知结果：它仅取决于 $r$ 和 $a$。\n  - 顺行 ISCO 半径 $r_{\\rm ISCO}$ 是 $a$ 的唯一函数，通过求解 Kerr 时空中赤道类时圆轨道测地线的临界稳定条件得到。此函数在广义相对论中是精确的，应作为本问题中所有情况的基准 ISCO 位置。\n  - 在动力学 Chern-Simons 引力的慢速旋转、小耦合情况下，对时空的领头阶修正主要通过标架场拖拽部分进入。通过对 $g_{t\\phi}$ 的一个形式为 $\\delta g_{t\\phi}(r) = \\zeta\\, a\\, \\mathcal{C}(r)$ 的加性修正来对此建模，其中 $M=1$ 且\n    $$\\mathcal{C}(r) = c_0\\, r^{-4}\\left(1 + c_1 r^{-1} + c_2 r^{-2}\\right),$$\n    其中 $c_0=\\frac{5}{8}$，$c_1=\\frac{12}{7}$，$c_2=\\frac{27}{10}$。这捕捉了 dCS 引起的标架场拖拽修正的正确定性径向衰减和自旋-耦合标度关系，同时保持在慢速旋转、小耦合情况内。将这些系数视为固定的模型参数。\n- ISCO 频率的 dCS 修正的数值度量：\n  - 通过匹配 $g_{t\\phi}$ 结构，将 $g_{t\\phi}$ 的 dCS 修正解释为在给定半径下自旋参数 $a$ 的有效位移：在赤道 Kerr 时空中，$g_{t\\phi}^{\\rm Kerr} = -2a/r$。通过 $-2 a_{\\rm eff}(r)/r \\equiv -2a/r + \\delta g_{t\\phi}(r)$ 定义一个有效自旋 $a_{\\rm eff}(r)$，因此\n    $$\\delta a_{\\rm eff}(r) \\equiv a_{\\rm eff}(r) - a = -\\frac{r}{2}\\,\\delta g_{t\\phi}(r) = -\\frac{r}{2}\\,\\zeta\\, a\\, \\mathcal{C}(r).$$\n  - 在 Kerr 顺行 ISCO 半径 $r_{\\rm ISCO}(a)$ 处，通过将 $a$ 替换为 $a_{\\rm eff}(r_{\\rm ISCO})$ 来计算顺行 Kerr 轨道频率，从而计算数值 dCS 修正的 ISCO 角频率。将其表示为 $\\Omega_{\\rm dCS,num}$。\n  - 通过在 $r_{\\rm ISCO}(a)$ 处使用未修正的自旋 $a$ 计算顺行 Kerr 轨道频率，来定义 Kerr ISCO 角频率 $\\Omega_{\\rm Kerr}$。\n  - 于是，数值测量的 ISCO 频率的 dCS 修正为\n    $$\\delta\\Omega_{\\rm num}(\\chi,\\zeta) \\equiv \\Omega_{\\rm dCS,num} - \\Omega_{\\rm Kerr}.$$\n- 频率偏移的慢速旋转解析预测：\n  - 在慢速旋转、小耦合情况下，通过将 Kerr 轨道频率在 $a$ 上对有效自旋偏移 $\\delta a_{\\rm eff}$ 作一阶泰勒展开，来近似 dCS 在固定 $r_{\\rm ISCO}(a)$ 处引起的频率偏移：\n    $$\\delta\\Omega_{\\rm ana}(\\chi,\\zeta) \\equiv \\left.\\frac{\\partial \\Omega_{\\rm Kerr}(r,a)}{\\partial a}\\right|_{r=r_{\\rm ISCO}(a)} \\delta a_{\\rm eff}(r_{\\rm ISCO}(a)).$$\n  - 这是要与数值度量 $\\delta\\Omega_{\\rm num}$ 进行比较的解析慢速旋转预测。\n\n实现要求：\n\n- 处处使用 $M=1$，因此所有频率均以 $1/M$ 为单位报告，所有输出均为无量纲数。\n- 对于径向坐标 $r$ 和自旋 $a$ 处的顺行 Kerr 轨道频率，使用广义相对论对赤道圆形轨道所蕴含的精确测地线表达式。对于作为 $a$ 的函数的顺行 Kerr ISCO 半径，使用广义相对论中关于赤道临界稳定性的精确表达式。\n- 对于 dCS 修正模型，使用上面给出的 $\\delta g_{t\\phi}(r)$ 并相应地定义 $\\delta a_{\\rm eff}(r)$。\n- 对于每个测试用例 $(\\chi,\\zeta)$，计算数值修正和解析修正之间的相对差异：\n  $$\\Delta(\\chi,\\zeta) \\equiv \\frac{\\delta\\Omega_{\\rm num}(\\chi,\\zeta) - \\delta\\Omega_{\\rm ana}(\\chi,\\zeta)}{\\max\\left(|\\delta\\Omega_{\\rm ana}(\\chi,\\zeta)|,\\,\\epsilon\\right)},$$\n  其中 $\\epsilon = 10^{-16}$ 仅用于在解析修正为零的情况下避免除以零。每个测试用例的结果是一个无量纲浮点数。\n- 测试套件：\n  - 使用以下 $(\\chi,\\zeta)$ 对：\n    1. $(0.0,\\,10^{-2})$，\n    2. $(0.1,\\,10^{-3})$，\n    3. $(0.5,\\,10^{-2})$，\n    4. $(0.9,\\,2\\times 10^{-2})$。\n  - 这些情况涵盖了无自旋边界情况、小自旋和小耦合、中等自旋以及近极端自旋和小耦合。\n- 最终输出格式：\n  - 您的程序应生成单行输出，其中包含一个包含在方括号中的、以逗号分隔的结果列表，例如，“[result1,result2,result3,result4]”。每个“result”必须是对应测试用例的浮点数 $\\Delta(\\chi,\\zeta)$，并按上面列出的顺序排列。\n\n您的解答必须从广义相对论和动力学 Chern-Simons 引力的基本定律和核心定义出发，解释连接物理修正和计算量的建模假设，并详细说明用于计算输出的算法步骤。所有数学符号必须以 LaTeX 格式呈现。通过保持耦合 $\\zeta$ 较小，将 $\\delta g_{t\\phi}$ 解释为领头阶标架场拖拽修正，并明确以 $1/M$ 为单位报告所有频率，来确保科学真实性。",
            "solution": "本问题要求设计一个程序来计算因动力学 Chern-Simons (dCS) 引力而导致的最内稳定圆轨道 (ISCO) 频率偏移的数值估计和解析近似之间的差异。分析在慢速旋转、小耦合情况下进行。解答从广义相对论 (GR) 的第一性原理和所提供的 dCS 修正模型出发进行推导。\n\n我们首先在 $G=c=1$ 的几何化单位中建立理论基础。黑洞质量归一化为 $M=1$，从而使所有量都无量纲化。黑洞的自旋由无量纲参数 $a = \\chi$ 表征，其中 $\\chi \\in [0,1)$。\n\n### 1. 广义相对论基准：Kerr 时空中的赤道圆形测地线\n\n未扰动背景是 Kerr 时空。对于在赤道平面（$\\theta=\\pi/2$）内圆形、顺行轨道上的类时粒子，由无穷远处的观测者测得的轨道角频率 $\\Omega$ 由下式给出：\n$$\n\\Omega_{\\rm Kerr}(r, a) = \\frac{1}{r^{3/2} + a}\n$$\n此处，$r$ 是无量纲 Boyer-Lindquist 径向坐标，$a$ 是无量纲自旋参数。量 $\\Omega_{\\rm Kerr}$ 对应于无量纲乘积 $M\\Omega$。\n\n最内稳定圆轨道的半径 $r_{\\rm ISCO}$ 是稳定圆轨道存在的最小半径。对于顺行 Kerr 测地线，它是临界稳定条件的解，由以下精确公式给出：\n$$\nr_{\\rm ISCO}(a) = 3 + Z_2 - \\sqrt{(3-Z_1)(3+Z_1+2Z_2)}\n$$\n其中 $Z_1$ 和 $Z_2$ 是自旋 $a$ 的函数：\n$$\nZ_1(a) = 1 + (1-a^2)^{1/3} \\left[ (1+a)^{1/3} + (1-a)^{1/3} \\right]\n$$\n$$\nZ_2(a) = \\sqrt{3a^2 + Z_1^2}\n$$\n该半径 $r_{\\rm ISCO}(a)$ 作为我们评估频率修正的固定位置。\n\n### 2. 动力学 Chern-Simons 修正模型\n\n本问题将领头阶 dCS 修正建模为对度规的标架场拖拽分量 $g_{t\\phi}$ 的修正。在此处使用的无量纲坐标中（其中距离以 $M$ 为单位），Kerr 度规的赤道 $g_{t\\phi}$ 分量是 $g_{t\\phi}^{\\rm Kerr} = -2a/r$。dCS 修改是对该项的加性修正：\n$$\n\\delta g_{t\\phi}(r) = \\zeta\\, a\\, \\mathcal{C}(r)\n$$\n其中 $\\zeta$ 是无量纲 dCS 耦合常数，$\\mathcal{C}(r)$ 是一个径向函数，定义为：\n$$\n\\mathcal{C}(r) = c_0\\, r^{-4}\\left(1 + c_1 r^{-1} + c_2 r^{-2}\\right)\n$$\n其中常数 $c_0=5/8$, $c_1=12/7$, $c_2=27/10$ 已给出。\n\n为了量化此度规修正对测地线频率的影响，我们定义一个有效自旋参数 $a_{\\rm eff}(r)$，它将在 Kerr 度规结构内产生总的 (Kerr + dCS) $g_{t\\phi}$ 值。匹配条件是：\n$$\ng_{t\\phi}^{\\rm total}(r) = g_{t\\phi}^{\\rm Kerr}(r) + \\delta g_{t\\phi}(r) \\equiv -\\frac{2 a_{\\rm eff}(r)}{r}\n$$\n代入度规分量的表达式，我们发现：\n$$\n-\\frac{2 a}{r} + \\zeta\\, a\\, \\mathcal{C}(r) = -\\frac{2 a_{\\rm eff}(r)}{r}\n$$\n这使我们能够解出有效自旋的偏移量 $\\delta a_{\\rm eff}(r) = a_{\\rm eff}(r) - a$：\n$$\n\\delta a_{\\rm eff}(r) = -\\frac{r}{2} \\delta g_{t\\phi}(r) = -\\frac{r}{2} \\zeta\\, a\\, \\mathcal{C}(r)\n$$\n该自旋偏移量概括了在给定半径 $r$ 处对时空标架场拖拽的领头阶 dCS 修正。\n\n### 3. 频率偏移计算与差异\n\n我们现在定义两种方法来计算 dCS 引起的 ISCO 频率偏移。\n\n#### 数值度量\n“数值”度量 $\\delta\\Omega_{\\rm num}$ 是通过计算当自旋参数 $a$ 被有效自旋 $a_{\\rm eff}$ 替换时，Kerr 频率公式的完全变化来求得的。此求值在未扰动的 GR ISCO 半径 $r_{\\rm ISCO}(a)$ 处进行。\n首先，我们求出 ISCO 半径处的有效自旋 $a_{\\rm eff}(r_{\\rm ISCO}(a))$。则 dCS 修正后的频率为：\n$$\n\\Omega_{\\rm dCS,num} = \\Omega_{\\rm Kerr}\\left(r_{\\rm ISCO}(a), a_{\\rm eff}(r_{\\rm ISCO}(a))\\right) = \\Omega_{\\rm Kerr}\\left(r_{\\rm ISCO}(a), a + \\delta a_{\\rm eff}(r_{\\rm ISCO}(a))\\right)\n$$\n数值频率偏移是相对于在 ISCO 处的未扰动 Kerr 频率的差值：\n$$\n\\delta\\Omega_{\\rm num} = \\Omega_{\\rm dCS,num} - \\Omega_{\\rm Kerr}(r_{\\rm ISCO}(a), a)\n$$\n\n#### 解析预测 (线性近似)\n“解析”预测 $\\delta\\Omega_{\\rm ana}$ 是从频率函数 $\\Omega_{\\rm Kerr}(r, a)$ 在固定半径 $r=r_{\\rm ISCO}(a)$ 处对自旋的微小变化 $\\delta a_{\\rm eff}$ 进行一阶泰勒级数展开得到的：\n$$\n\\delta\\Omega_{\\rm ana} = \\left. \\frac{\\partial \\Omega_{\\rm Kerr}(r,a)}{\\partial a} \\right|_{r=r_{\\rm ISCO}(a)} \\delta a_{\\rm eff}(r_{\\rm ISCO}(a))\n$$\n所需的偏导数为：\n$$\n\\frac{\\partial \\Omega_{\\rm Kerr}}{\\partial a} = \\frac{\\partial}{\\partial a} (r^{3/2} + a)^{-1} = - (r^{3/2} + a)^{-2} = -\\left[\\Omega_{\\rm Kerr}(r,a)\\right]^2\n$$\n因此，频率偏移的解析预测为：\n$$\n\\delta\\Omega_{\\rm ana} = -\\left[\\Omega_{\\rm Kerr}(r_{\\rm ISCO}(a), a)\\right]^2 \\delta a_{\\rm eff}(r_{\\rm ISCO}(a))\n$$\n\n#### 相对差异\n中心任务是计算这两种度量之间的相对差异 $\\Delta$。这个量度量了线性近似（“解析”方法）相对于完整函数求值（“数值”方法）的误差。其定义为：\n$$\n\\Delta(\\chi,\\zeta) = \\frac{\\delta\\Omega_{\\rm num}(\\chi,\\zeta) - \\delta\\Omega_{\\rm ana}(\\chi,\\zeta)}{\\max\\left(|\\delta\\Omega_{\\rm ana}(\\chi,\\zeta)|,\\,\\epsilon\\right)}\n$$\n其中 $\\epsilon = 10^{-16}$ 是一个小的正则化参数，用于防止除以零，特别是在无自旋情况 ($\\chi=0$) 下，此时 $\\delta\\Omega_{\\rm ana}=0$。\n\n### 4. 算法实现\n\n对每个给定的 $(\\chi, \\zeta)$ 对的计算过程如下：\n1.  设置无量纲自旋 $a = \\chi$。如果 $a=0$，则差异 $\\Delta$ 解析上为 $0$，因为 dCS 修正消失了。\n2.  使用精确的 GR 公式计算顺行 Kerr ISCO 半径 $r_{\\rm ISCO}(a)$。\n3.  在 $r_{\\rm ISCO}(a)$ 处计算未扰动的 Kerr 轨道频率 $\\Omega_{\\rm Kerr}$。\n4.  在 $r_{\\rm ISCO}(a)$ 处，计算 dCS 径向函数 $\\mathcal{C}(r_{\\rm ISCO})$ 和有效自旋偏移 $\\delta a_{\\rm eff}$。\n5.  通过计算差值 $\\Omega_{\\rm Kerr}(r_{\\rm ISCO}, a+\\delta a_{\\rm eff}) - \\Omega_{\\rm Kerr}(r_{\\rm ISCO}, a)$ 来计算数值偏移 $\\delta\\Omega_{\\rm num}$。\n6.  使用推导出的公式 $-\\Omega_{\\rm Kerr}^2 \\delta a_{\\rm eff}$ 计算解析偏移 $\\delta\\Omega_{\\rm ana}$。\n7.  最后，使用提供的公式计算差异 $\\Delta$。\n\n此过程系统地应用于所有测试用例，以生成最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_isco_radius(a: float) - float:\n    \"\"\"\n    Calculates the dimensionless prograde ISCO radius for a Kerr black hole.\n    M=1, so the spin parameter 'a' is the dimensionless spin 'chi'.\n    \n    Args:\n        a: Dimensionless spin parameter, chi.\n\n    Returns:\n        Dimensionless prograde ISCO radius, r_ISCO/M.\n    \"\"\"\n    if a == 0.0:\n        return 6.0\n    if a == 1.0:\n        return 1.0\n    \n    a2 = a * a\n    # Use np.cbrt for cube roots to handle potential floating point issues,\n    # though x**(1/3) is also fine for non-negative arguments.\n    term1_cbrt = np.cbrt(1.0 - a2)\n    term2_cbrt = np.cbrt(1.0 + a)\n    term3_cbrt = np.cbrt(1.0 - a)\n    \n    z1 = 1.0 + term1_cbrt * (term2_cbrt + term3_cbrt)\n    z2 = np.sqrt(3.0 * a2 + z1 * z1)\n    \n    # The '-' sign in 'mp' corresponds to prograde orbits.\n    r_isco = 3.0 + z2 - np.sqrt((3.0 - z1) * (3.0 + z1 + 2.0 * z2))\n    return r_isco\n\ndef omega_kerr(r: float, a: float) - float:\n    \"\"\"\n    Calculates the dimensionless prograde orbital frequency M*Omega for a\n    circular orbit in the Kerr spacetime.\n    \n    Args:\n        r: Dimensionless radial coordinate, r/M.\n        a: Dimensionless spin parameter, chi.\n\n    Returns:\n        Dimensionless orbital frequency, M*Omega.\n    \"\"\"\n    return 1.0 / (r**1.5 + a)\n\ndef calculate_discrepancy(chi: float, zeta: float) - float:\n    \"\"\"\n    Calculates the relative discrepancy Delta for a given (chi, zeta) pair.\n    \n    Args:\n        chi: Dimensionless spin parameter of the black hole.\n        zeta: Dimensionless dCS coupling constant.\n\n    Returns:\n        The discrepancy value Delta.\n    \"\"\"\n    a = chi  # With M=1, a = chi\n    epsilon = 1e-16\n\n    # For a non-spinning black hole (a=0), the dCS correction as modeled is zero.\n    # This implies delta_a_eff = 0, which makes both delta_omega_num and\n    # delta_omega_ana zero. The discrepancy is thus 0.\n    if a == 0.0:\n        return 0.0\n\n    # Step 1: Calculate the unperturbed Kerr prograde ISCO radius.\n    r_isco = get_isco_radius(a)\n\n    # Step 2: Calculate the unperturbed Kerr orbital frequency at the ISCO.\n    omega_gr = omega_kerr(r_isco, a)\n\n    # Step 3: Calculate the dCS correction terms at the ISCO radius.\n    # dCS model coefficients for the radial function C(r).\n    c0 = 5.0 / 8.0\n    c1 = 12.0 / 7.0\n    c2 = 27.0 / 10.0\n    \n    r_inv = 1.0 / r_isco\n    C_r = c0 * (r_inv**4) * (1.0 + c1 * r_inv + c2 * r_inv**2)\n    \n    # The shift in the effective spin parameter, evaluated at r_isco.\n    delta_a_eff = -0.5 * r_isco * zeta * a * C_r\n\n    # Step 4: Calculate the \"numerical\" frequency shift.\n    # This involves re-evaluating the full frequency formula with the shifted spin.\n    a_eff = a + delta_a_eff\n    omega_dcs_num_val = omega_kerr(r_isco, a_eff)\n    delta_omega_num = omega_dcs_num_val - omega_gr\n    \n    # Step 5: Calculate the \"analytic\" frequency shift (linear approximation).\n    # The derivative d(Omega)/da is -Omega^2.\n    domega_da = -omega_gr**2\n    delta_omega_ana = domega_da * delta_a_eff\n\n    # Step 6: Calculate the final relative discrepancy.\n    numerator = delta_omega_num - delta_omega_ana\n    denominator = max(abs(delta_omega_ana), epsilon)\n    \n    discrepancy = numerator / denominator\n    \n    return discrepancy\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the specified test suite.\n    It calculates the discrepancy for each case and prints the results\n    in the required format.\n    \"\"\"\n    \n    # Test suite: a list of (chi, zeta) pairs.\n    test_cases = [\n        (0.0, 1e-2),\n        (0.1, 1e-3),\n        (0.5, 1e-2),\n        (0.9, 2e-2),\n    ]\n\n    results = []\n    for chi, zeta in test_cases:\n        result = calculate_discrepancy(chi, zeta)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Using exponential notation for consistency and precision.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}