{
    "hands_on_practices": [
        {
            "introduction": "在深入研究自相互作用力的复杂计算之前，首先必须对极端质量比旋（EMRI）系统的基本物理尺度有一个牢固的把握。这个练习旨在通过一个基础的量级估算，来巩固EMRI的核心定义，并揭示其演化的绝热特性。通过计算一个典型EMRI系统的辐射反作用时标，您将亲身体会到为何我们可以将旋进过程近似为一系列受微扰的测地线轨道。",
            "id": "3474004",
            "problem": "极端质量比旋进 (EMRI) 指的是一个质量为 $\\mu$ 的致密天体绕着一个质量为 $M$ 的大质量黑洞运行，其中 $\\mu \\ll M$。请通过阐明以下几点，给出一个关于 EMRI 的简洁、有原则的定义：\n- 特征质量比 $\\mu/M$，\n- 相对于 $M$ 的特征轨道间距尺度，\n- 轨道时间尺度与辐射反作用时间尺度之间的等级关系。\n\n接着，考虑一个质量为 $\\mu = 10 M_{\\odot}$ 的致密天体，在一个质量为 $M = 10^6 M_{\\odot}$ 的 Kerr 黑洞周围，沿着 Boyer–Lindquist 坐标半径为 $r = 10 M$ 的准圆形赤道轨道运行。在极端质量比和慢辐射反作用极限的领头阶下，将运动视为圆形轨道，并使用领头阶引力四极辐射来估算辐射反作用时间尺度\n$$\nT_{\\mathrm{rr}} \\equiv \\left|\\frac{E}{\\,\\mathrm{d}E/\\mathrm{d}t\\,}\\right| \\, ,\n$$\n其中 $E$ 是小天体的轨道束缚能，而 $\\mathrm{d}E/\\mathrm{d}t$ 是引力波光度。在推导过程中，您可以使用几何单位制 $G=c=1$，并在最后恢复物理单位。假设在此阶上，与自旋相关的能量通量修正可以忽略不计。\n\n使用 $1\\,\\mathrm{yr} = 3.15576 \\times 10^7\\,\\mathrm{s}$ 和 $G M_{\\odot}/c^3 = 4.925490947 \\times 10^{-6}\\,\\mathrm{s}$，将最终的 $T_{\\mathrm{rr}}$ 以年为单位表示。请将答案四舍五入到三位有效数字。\n\n只对最终的时间尺度数值进行评分。",
            "solution": "我们首先根据三个特征来定义极端质量比旋进 (EMRI)：\n\n1. 质量比：EMRI 的质量比 $\\mu/M \\ll 1$，通常为 $\\mu/M \\sim 10^{-7}$–$10^{-4}$。对于给定的系统，$\\mu/M = 10 M_{\\odot}/(10^6 M_{\\odot}) = 10^{-5}$。\n\n2. 轨道间距尺度：轨道天体在相对论性轨道上运动，其间距与大质量黑洞的引力半径相当，从 $r \\sim \\mathcal{O}(M)$ 到几十个 $M$。在此问题中，$r = 10 M$ 是一个特征值。\n\n3. 时间尺度等级关系：轨道时间尺度 $T_{\\mathrm{orb}}$ 远小于辐射反作用时间尺度 $T_{\\mathrm{rr}}$，即 $T_{\\mathrm{orb}} \\ll T_{\\mathrm{rr}}$，因此运动是绝热的，可以近似为一系列受辐射反作用扰动的圆形测地线。\n\n为了在领头阶上估算 $T_{\\mathrm{rr}}$，我们采用极端质量比和圆形轨道牛顿极限作为基本出发点。相关要素如下：\n\n- 在围绕质量 $M$ 的圆形轨道上的检验质量的牛顿轨道束缚能：\n$$\nE = -\\frac{\\mu M}{2 r} \\, .\n$$\n\n- 对于总质量为 $M$、折合质量为 $\\mu$ 的准圆形双星系统，其领头阶引力波光度（四极矩公式）为：\n$$\n\\frac{\\mathrm{d}E}{\\mathrm{d}t} = -\\frac{32}{5} \\frac{\\mu^2 M^3}{r^5} \\, .\n$$\n在极端质量比极限下，折合质量为 $\\mu$，量级为 $\\mu/M$ 的分数修正被忽略。\n\n辐射反作用时间尺度，定义为轨道能量变化其自身量级的特征时间尺度，为\n$$\nT_{\\mathrm{rr}} \\equiv \\left| \\frac{E}{\\,\\mathrm{d}E/\\mathrm{d}t\\,} \\right|\n= \\frac{\\mu M/(2 r)}{(32/5)\\, \\mu^2 M^3 / r^5}\n= \\frac{5}{64} \\frac{r^4}{\\mu M^2} \\, .\n$$\n\n对于指定的轨道 $r = 10 M$，我们得到\n$$\nT_{\\mathrm{rr}} = \\frac{5}{64} \\frac{(10 M)^4}{\\mu M^2}\n= \\frac{5}{64} \\times 10^4 \\times \\frac{M^2}{\\mu}\n= 781.25 \\,\\frac{M^2}{\\mu} \\, .\n$$\n\n为了转换到物理时间单位，注意到在几何单位制 $G=c=1$ 中，质量 $X$ 对应于一个时间 $X$；恢复单位后，\n$$\nM \\to \\frac{G M}{c^3} \\, , \\quad \\mu \\to \\frac{G \\mu}{c^3} \\, .\n$$\n将其写作以下形式很方便\n$$\n\\frac{M^2}{\\mu} = M \\left(\\frac{M}{\\mu}\\right) \\, ,\n$$\n这样\n$$\nT_{\\mathrm{rr}} = 781.25 \\, M \\left(\\frac{M}{\\mu}\\right) \\, ,\n$$\n其中右侧的 $M$ 现在是一个时间量。对于给定的系统，\n$$\n\\frac{M}{\\mu} = \\frac{10^6 M_{\\odot}}{10 M_{\\odot}} = 10^5 \\, ,\n$$\n并且\n$$\nM = \\frac{G M}{c^3} = 10^6 \\left(\\frac{G M_{\\odot}}{c^3}\\right)\n= 10^6 \\times \\left(4.925490947 \\times 10^{-6}\\,\\mathrm{s}\\right)\n= 4.925490947\\,\\mathrm{s} \\, .\n$$\n因此，\n$$\nT_{\\mathrm{rr}} = 781.25 \\times 4.925490947\\,\\mathrm{s} \\times 10^5\n= 781.25 \\times 492{,}549.0947\\,\\mathrm{s}\n= 3.84803980234375 \\times 10^8\\,\\mathrm{s} \\, .\n$$\n\n使用 $1\\,\\mathrm{yr} = 3.15576 \\times 10^7\\,\\mathrm{s}$ 将秒转换为年：\n$$\nT_{\\mathrm{rr}} = \\frac{3.84803980234375 \\times 10^8\\,\\mathrm{s}}{3.15576 \\times 10^7\\,\\mathrm{s/yr}}\n\\approx 12.2\\,\\mathrm{yr} \\, .\n$$\n\n按要求四舍五入到三位有效数字，得到 $12.2$ 年。",
            "answer": "$$\\boxed{12.2}$$"
        },
        {
            "introduction": "理解了EMRI的基本时标后，下一步是模拟其轨道动力学及其产生的引力波信号。这个实践练习将引导您构建一个简化的旋进模型，在其中区分耗散效应（能量和角动量损失）和保守效应（轨道形状的进动）。通过编码实现并比较有无保守项的引力波相位累积，您将直接观察到保守自相互作用力（即使在后牛顿近似下）如何对可观测的引力波相位产生关键影响，而精确预测相位正是EMRI探测的核心。",
            "id": "3474038",
            "problem": "考虑一个极端质量比旋进系统，其中一个质量为 $m$ 的致密天体绕着一个质量为 $M$ 的大质量黑洞运行，质量比为 $q = m/M \\ll 1$。目标是通过比较纯耗散自力模型（仅考虑辐射反作用）计算出的引力波相位累积 $\\phi(t)$ 与包含领头阶保守项的自洽演化结果，来检验绝热近似。在以下有物理依据且广泛使用的近似下进行计算：\n\n1. 使用由半长轴 $a(t)$ 和偏心率 $e(t)$ 表征的牛顿束缚开普勒轨道，这些轨道根据 Peters-Mathews 方程因引力辐射反作用而演化。这些耗散演化方程为\n$$\n\\frac{da}{dt} = -\\frac{64}{5} \\frac{G^3 m M (m+M)}{c^5} \\frac{1}{a^3 (1-e^2)^{7/2}} \\left(1 + \\frac{73}{24} e^2 + \\frac{37}{96} e^4 \\right),\n$$\n$$\n\\frac{de}{dt} = -\\frac{304}{15} \\frac{G^3 m M (m+M)}{c^5} \\frac{e}{a^4 (1-e^2)^{5/2}} \\left(1 + \\frac{121}{304} e^2 \\right),\n$$\n其中 $G$ 是引力常数，$c$ 是光速。\n\n2. 瞬时平运动（平近点角中的轨道频率）由开普勒第三定律给出\n$$\nn(a) = \\sqrt{\\frac{G (m+M)}{a^3}}。\n$$\n\n3. 通过束缚轨道的近心点进动，为方位角相位引入一个领头阶保守广义相对论修正。在第一后牛顿 (1PN) 极限下，每条轨道的近心点进动为\n$$\n\\Delta \\varpi = \\frac{6 \\pi G (m+M)}{c^2 a (1 - e^2)},\n$$\n这对应一个方位角频率修正因子\n$$\nk(a,e) = \\frac{3 G (m+M)}{c^2 a (1 - e^2)},\n$$\n使得方位角频率变为\n$$\n\\Omega_{\\phi}(a,e) = n(a) \\left(1 + k(a,e)\\right)。\n$$\n这个保守贡献将与 $a(t)$ 和 $e(t)$ 的耗散演化自洽地结合起来。\n\n4. 对于主导的四极引力波谐波，将相位累积建模为\n$$\n\\phi_{\\text{diss}}(t) = 2 \\int_0^t n\\left(a(\\tau)\\right) \\, d\\tau,\n\\qquad\n\\phi_{\\text{cons}}(t) = 2 \\int_0^t n\\left(a(\\tau)\\right) \\left(1 + k\\left(a(\\tau), e(\\tau)\\right)\\right) d\\tau。\n$$\n定义相位差\n$$\n\\Delta \\phi(t) = \\phi_{\\text{cons}}(t) - \\phi_{\\text{diss}}(t) = 2 \\int_0^t n\\left(a(\\tau)\\right) k\\left(a(\\tau), e(\\tau)\\right) d\\tau。\n$$\n\n假设中心黑洞不自旋（史瓦西黑洞），因此轨道平面倾角不影响领头阶相位动力学；将倾角作为输入参数，其值如下指定，并一致地处理其单位。所有角度必须以度为单位提供；时间必须以秒为单位处理；距离必须以米为单位处理；质量必须以千克为单位处理。所有最终相位差以弧度表示。\n\n从上述基本定律和事实出发，构建一个算法，使用 $a(t)$ 和 $e(t)$ 的耗散方程以及通过 $k(a,e)$ 对相位进行的保守修正，从给定的初始条件演化 $(a(t), e(t), \\Delta \\phi(t))$。演化是绝热的，即 $(a,e)$ 的变化与轨道时间尺度相比是缓慢的。\n\n你的程序必须使用一种科学上可靠的数值方法来实现鲁棒的常微分方程随时间积分。在每次演化结束时，输出 $\\Delta \\phi(T)$ 的值（以弧度为单位）。\n\n使用以下固定的物理常数：\n- $G = 6.67430 \\times 10^{-11} \\ \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$，\n- $c = 299792458 \\ \\mathrm{m \\, s^{-1}}$，\n- $M_{\\odot} = 1.98847 \\times 10^{30} \\ \\mathrm{kg}$。\n\n使用以下全局质量来实现 $q = 10^{-6}$：\n- $M = 10^{6} M_{\\odot}$，\n- $m = 1 M_{\\odot}$。\n\n定义引力半径 $r_g = G M / c^2$，并将初始半长轴值 $a_0$ 设置为 $r_g$ 的倍数。\n\n测试套件：\n提供三个测试用例来检验不同情形。对于每个用例，按如下方式指定 $(a_0, e_0, \\iota, T)$，其中 $\\iota$ 是以度为单位提供的轨道倾角（在史瓦西黑洞的动力学中未使用，但为确保正确的单位处理而包含在内），$a_0$ 以米为单位，$e_0$ 是无量纲的，$T$ 以秒为单位。所有用例的质量比均固定为 $q = 10^{-6}$。\n\n- 用例1（正常路径，中等偏心率和弱场）：\n  - $a_0 = 100 \\, r_g$，\n  - $e_0 = 0.3$，\n  - $\\iota = 25^\\circ$，\n  - $T = 10^{6} \\ \\mathrm{s}$。\n\n- 用例2（边界情况，近圆形轨道）：\n  - $a_0 = 100 \\, r_g$，\n  - $e_0 = 0.0$，\n  - $\\iota = 25^\\circ$，\n  - $T = 10^{5} \\ \\mathrm{s}$。\n\n- 用例3（边缘情况，强场和较高偏心率）：\n  - $a_0 = 50 \\, r_g$，\n  - $e_0 = 0.7$，\n  - $\\iota = 25^\\circ$，\n  - $T = 5 \\times 10^{5} \\ \\mathrm{s}$。\n\n要求的最终输出：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述测试用例顺序排列的结果。每个条目都应是为相应用例计算出的 $\\Delta \\phi(T)$ 的浮点值（以弧度为单位）。例如，输出格式必须是\n$$\n[\\Delta \\phi_1, \\Delta \\phi_2, \\Delta \\phi_3]。\n$$",
            "solution": "用户在引力波天体物理学领域提供了一个定义明确的问题。对问题陈述的验证确认了其具有科学依据、是适定的，并包含了进行求解所需的所有必要信息。未发现不一致、歧义或事实错误。该问题要求通过数值积分一个模拟极端质量比旋进 (EMRI) 双星系统演化的常微分方程 (ODE) 系统，来计算一个特定的物理可观测量——由保守后牛顿效应引起的累积相位差 $\\Delta\\phi$。\n\n该物理系统由状态向量 $\\vec{y}(t) = [a(t), e(t), \\Delta \\phi(t)]$ 建模，其中 $a$ 是轨道半长轴，$e$ 是偏心率，$\\Delta \\phi$ 是我们关心的相位差。此状态的演化由初值问题 $\\frac{d\\vec{y}}{dt} = \\vec{F}(\\vec{y})$ 描述，初始条件为 $\\vec{y}(0) = [a_0, e_0, 0]$。ODE 系统 $\\vec{F}(\\vec{y})$ 的分量由问题中陈述的原理推导得出。\n\n1.  **半长轴 $a(t)$ 的演化**：半长轴的变化率由引力波发射造成的能量损失决定，由 Peters-Mathews 公式给出。\n    $$\n    \\frac{da}{dt} = -\\frac{64}{5} \\frac{G^3 m M (m+M)}{c^5} \\frac{1}{a^3 (1-e^2)^{7/2}} \\left(1 + \\frac{73}{24} e^2 + \\frac{37}{96} e^4 \\right)\n    $$\n    此处，$G$ 是引力常数，$c$ 是光速，$m$ 和 $M$ 是两个天体的质量。这个方程描述了轨道的耗散衰减。\n\n2.  **偏心率 $e(t)$ 的演化**：偏心率的变化同样源自 Peters-Mathews 形式，由轨道角动量损失给引力波驱动。\n    $$\n    \\frac{de}{dt} = -\\frac{304}{15} \\frac{G^3 m M (m+M)}{c^5} \\frac{e}{a^4 (1-e^2)^{5/2}} \\left(1 + \\frac{121}{304} e^2 \\right)\n    $$\n    这个方程通常导致轨道随时间圆化。如果初始偏心率 $e_0$ 为 $0$，则导数 $\\frac{de}{dt}$ 始终为零，因此轨道保持圆形。\n\n3.  **相位差 $\\Delta \\phi(t)$ 的演化**：问题将相位差 $\\Delta \\phi(t)$ 定义为由领头阶保守近心点进动引起的、单位时间内累积的额外相位的积分。因此，其变化率就是被积函数本身：\n    $$\n    \\frac{d(\\Delta \\phi)}{dt} = 2 \\, n(a) \\, k(a,e)\n    $$\n    项 $n(a)$ 和 $k(a,e)$ 分别是轨道平运动和 1PN 近心点进动因子：\n    $$\n    n(a) = \\sqrt{\\frac{G (m+M)}{a^3}}, \\quad k(a,e) = \\frac{3 G (m+M)}{c^2 a (1 - e^2)}\n    $$\n    将这些代入导数，得到相位差的 ODE：\n    $$\n    \\frac{d(\\Delta \\phi)}{dt} = 2 \\left(\\sqrt{\\frac{G (m+M)}{a^3}}\\right) \\left(\\frac{3 G (m+M)}{c^2 a (1 - e^2)}\\right) = \\frac{6 (G(m+M))^{3/2}}{c^2 a^{5/2} (1 - e^2)}\n    $$\n\n这个由三个耦合的一阶 ODE 组成的系统构成了一个可以数值求解的完备初值问题。算法方法如下：\n1.  定义必要的物理常数（$G$, $c$, $M_{\\odot}$）和系统参数（$M$, $m$）。由此计算总质量 $M_{tot} = M+m$ 和主黑洞的引力半径 $r_g = GM/c^2$。\n2.  对于由初始参数 $(a_0, e_0, \\iota, T)$ 指定的每个测试用例：\n    a. 将以 $r_g$ 为单位给出的初始半长轴 $a_0$ 转换为米。\n    b. 设置初始状态向量 $\\vec{y}_0 = [a_0[\\text{m}], e_0, 0]$。初始相位差 $\\Delta\\phi(0)$ 为 $0$。在此简化模型中，倾角 $\\iota$ 与动力学无关。\n    c. 实现一个函数，对于给定的状态 $\\vec{y}=[a, e, \\Delta\\phi]$，计算导数向量 $\\frac{d\\vec{y}}{dt} = [\\frac{da}{dt}, \\frac{de}{dt}, \\frac{d(\\Delta \\phi)}{dt}]$。\n    d. 使用一个鲁棒的数值 ODE 求解器，例如 `scipy.integrate.solve_ivp`，从初始状态 $\\vec{y}_0$ 开始，将系统从时间 $t=0$ 积分到最终时间 $t=T$。\n    e. 从求解器的输出中，提取最终时间 $T$ 时第三个状态变量 $\\Delta\\phi$ 的值。\n3.  将所有测试用例计算出的 $\\Delta\\phi(T)$ 值整理到一个列表中，并以指定格式打印。\n\n这种结构化的方法论确保了得到一个正确且数值稳定的解。使用像 `scipy.integrate.solve_ivp` 中默认的 4(5)阶龙格-库塔方法这样的自适应求解器非常适合此问题，因为随着轨道参数的演化和系统特征时间尺度的变化，它可以调整其步长以保持精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the EMRI evolution problem for a set of test cases.\n    \"\"\"\n    # Physical Constants\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    c = 299792458.0  # m s^-1\n    M_sol = 1.98847e30 # kg\n\n    # System Masses\n    M = 1.0e6 * M_sol  # Primary black hole mass in kg\n    m = 1.0 * M_sol    # Compact object mass in kg\n    M_tot = M + m\n\n    # Pre-calculated common factors for the ODEs to improve performance\n    G3_c5_mM_Mtot = (G**3 / c**5) * m * M * M_tot\n    C_a_coeff = -(64.0 / 5.0) * G3_c5_mM_Mtot\n    C_e_coeff = -(304.0 / 15.0) * G3_c5_mM_Mtot\n    C_phi_coeff = 6.0 * (G * M_tot)**(3.0/2.0) / c**2\n\n    def ode_system(t, y):\n        \"\"\"\n        Defines the system of ordinary differential equations for [a, e, delta_phi].\n        y[0]: a (semi-major axis)\n        y[1]: e (eccentricity)\n        y[2]: delta_phi (phase difference)\n        \"\"\"\n        a, e, _ = y\n        \n        e2 = e * e\n        one_minus_e2 = 1.0 - e2\n        \n        # This condition prevents numerical errors if e approaches 1,\n        # which would signify a breakdown of the bound orbit model.\n        if one_minus_e2 = 1e-12: # Add tolerance for float precision\n            return [0.0, 0.0, 0.0]\n\n        # Pre-calculate powers of a and (1-e^2) for efficiency\n        a3 = a * a * a\n        a4 = a3 * a\n        a_pow_2_5 = a**2.5\n        \n        one_minus_e2_pow_2_5 = one_minus_e2**2.5\n        one_minus_e2_pow_3_5 = one_minus_e2 * one_minus_e2_pow_2_5\n\n        # da/dt: rate of change of semi-major axis\n        f_a_poly = 1.0 + (73.0 / 24.0) * e2 + (37.0 / 96.0) * e2 * e2\n        dadt = C_a_coeff * f_a_poly / (a3 * one_minus_e2_pow_3_5)\n        \n        # de/dt: rate of change of eccentricity\n        # The factor of `e` ensures de/dt = 0 for perfectly circular orbits.\n        f_e_poly = 1.0 + (121.0 / 304.0) * e2\n        dedt = C_e_coeff * e * f_e_poly / (a4 * one_minus_e2_pow_2_5)\n\n        # d(Delta phi)/dt: rate of change of the conservative phase difference\n        d_delta_phi_dt = C_phi_coeff / (a_pow_2_5 * one_minus_e2)\n        \n        return [dadt, dedt, d_delta_phi_dt]\n\n    # Gravitational radius of the central black hole\n    r_g = G * M / c**2\n\n    # Define the test cases from the problem statement.\n    # Format: (initial a in r_g units, initial e, inclination in degrees, total time in seconds)\n    test_cases = [\n        (100.0, 0.3, 25.0, 1.0e6), # Case 1\n        (100.0, 0.0, 25.0, 1.0e5), # Case 2\n        (50.0, 0.7, 25.0, 5.0e5),  # Case 3\n    ]\n\n    results = []\n    for a0_factor, e0, _, T in test_cases:\n        # Set initial conditions for the current case\n        a0 = a0_factor * r_g\n        y0 = [a0, e0, 0.0]  # Initial state vector [a, e, delta_phi]\n        \n        # Time span for the integration\n        t_span = [0, T]\n        \n        # Solve the ODE system using a high-quality adaptive integrator\n        # The default 'RK45' method is suitable. Adding tighter tolerances\n        # for better accuracy in phase, which accumulates over long times.\n        sol = solve_ivp(\n            ode_system, \n            t_span, \n            y0, \n            method='RK45', \n            atol=1e-12, # Absolute tolerance\n            rtol=1e-9   # Relative tolerance\n        )\n        \n        # Extract the final value of delta_phi at time T\n        delta_phi_T = sol.y[2, -1]\n        \n        results.append(delta_phi_T)\n\n    # Print the final results in the exact specified format\n    print(f\"[{','.join(f'{r:.8g}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "精确的EMRI轨道演化模型依赖于对自相互作用力的精确计算，而这通常涉及一个被称为“模式和正则化”的强大技术。在此方法中，自相互作用力被分解为球谐模式的总和，但直接对无穷多的模式求和是不切实际的。这个高级实践练习将带您进入自相互作用力计算的核心，通过设计并实现一个“尾部拟合”程序，来估计由高阶模式构成的无穷级数“尾巴”的贡献，这是确保计算收敛和精度的关键一步。",
            "id": "3474036",
            "problem": "设计并实现一个数值稳健的尾部拟合程序，用于估计极端质量比旋进（EMRI）的引力自作用力（GSF）的模式和正则化（MSR）方法中的无穷模式余项。假设在减去已知的正则化参数后，对于大的多极指数 $\\ell$，剩余的球谐模式 $F_{\\ell}$ 允许一个以 $(\\ell+\\tfrac{1}{2})^{-1}$ 的整数次幂表示的渐近展开，\n$$\nF_{\\ell} \\sim \\sum_{j=1}^{m_{\\text{true}}} c^{\\text{true}}_{j}\\,(\\ell+\\tfrac{1}{2})^{-n^{\\text{true}}_{j}},\n$$\n其中 $n^{\\text{true}}_{j} \\in \\mathbb{N}$ 且 $c^{\\text{true}}_{j} \\in \\mathbb{R}$。目标是估计超出有限截断 $L$ 的无穷尾部，\n$$\nT = \\sum_{\\ell=L+1}^{\\infty} F_{\\ell},\n$$\n仅使用一组有限的、已计算的剩余模式，其 $\\ell \\in \\{\\ell_{\\min},\\ldots,L\\}$。您必须：\n- 为一组选定的指数模型 $\\{n_{j}\\}_{j=1}^{m}$ 构建一个线性最小二乘拟合，以从数据 $\\{F_{\\ell}\\}_{\\ell=\\ell_{\\min}}^{L}$ 中确定系数 $\\{\\hat{c}_{j}\\}$。\n- 使用 Hurwitz zeta 函数的定义 $\\zeta(s,a) = \\sum_{k=0}^{\\infty} (k+a)^{-s}$ 来写出拟合的无穷尾部的解析表达式，\n$$\n\\hat{T} = \\sum_{j=1}^{m} \\hat{c}_{j}\\,\\zeta\\!\\left(n_{j},\\,L+\\tfrac{3}{2}\\right).\n$$\n- 通过将线性最小二乘系数协方差传播到由向量 $g$（其元素为 $g_{j}=\\zeta(n_{j}, L+\\tfrac{3}{2})$）定义的线性泛函，来量化 $\\hat{T}$ 的统计不确定度 $\\sigma_{\\text{stat}}$。\n- 通过嵌套模型比较来控制模型截断误差：引入一个指数集为 $\\{n_{j}\\}_{j=1}^{m+1}$ 的扩展模型，该模型严格包含基础模型；在相同数据上重新拟合，计算 $\\hat{T}_{\\text{ext}}$，并定义截断代理误差 $\\Delta T = |\\hat{T}_{\\text{ext}}-\\hat{T}|$。报告组合不确定度\n$$\n\\sigma_{\\text{comb}}=\\sqrt{\\sigma_{\\text{stat}}^{2}+\\Delta T^{2}}.\n$$\n假设所有量都是无量纲的。角度不出现。该问题必须在以下约束条件下解决。\n\n基本和建模的基本假设：\n- 仅使用以下事实：解析 MSR 后的残差会因局部奇异场的平滑性以及广义相对论中高 $\\ell$ 格林函数尾部的结构而按 $(\\ell+\\tfrac{1}{2})^{-1}$ 的多项式形式衰减。将此视为一个经过充分检验的渐近事实。除了下面测试套件中提供的值之外，不要假设任何特定的指数值。\n- 将有限数据的残差视为由渐近模型加上附加的、独立的、零均值的、标准差已知的（对每个测试用例）高斯噪声生成。\n- 对参数线性的模型矩阵 $A_{\\ell j}=(\\ell+\\tfrac{1}{2})^{-n_{j}}$ 使用普通最小二乘法以获得 $\\hat{c}_{j}$。将残差方差估计为 $\\hat{\\sigma}^{2}=\\text{RSS}/\\nu$，其中 $\\text{RSS}$ 是残差平方和，$\\nu=N-m$，$N$ 是使用的模式数，$m$ 是拟合的系数数。如果 $\\nu \\leq 0$，则设置 $\\hat{\\sigma}^{2}=0$。\n- 当 $(A^{\\mathsf{T}}A)$ 可逆时，使用协方差 $\\text{Cov}(\\hat{c})=\\hat{\\sigma}^{2}(A^{\\mathsf{T}}A)^{-1}$；否则，使用 Moore–Penrose 伪逆代替。\n\n算法要求：\n- 对于每个测试用例，通过使用指定的标准差和固定的种子 $20231105$ 抽取一个高斯噪声向量来生成合成数据。对于 $\\ell \\in \\{\\ell_{\\min},\\ldots,L\\}$，构建 $F_{\\ell}=\\sum_{j} c^{\\text{true}}_{j}(\\ell+\\tfrac{1}{2})^{-n^{\\text{true}}_{j}}+\\text{noise}$。\n- 按照每个测试用例的指定，使用相同的数据拟合基础模型和扩展模型。\n- 计算基础模型的尾部 $\\hat{T}$ 及其统计不确定度 $\\sigma_{\\text{stat}}$，然后计算扩展模型的尾部 $\\hat{T}_{\\text{ext}}$ 以得到 $\\Delta T$，最后计算 $\\sigma_{\\text{comb}}$。\n- 对于每个测试，报告序对 $(\\hat{T},\\sigma_{\\text{comb}})$。\n\n测试套件：\n- 测试 $1$（顺利情况，带有轻度污染的偶次幂指数）：\n  - 真实指数 $[2,4,6]$，真实系数 $[5.0\\times 10^{-1},-3.0\\times 10^{-1},2.0\\times 10^{-1}]$。\n  - $\\ell_{\\min}=10$, $L=25$，噪声标准差 $1.0\\times 10^{-8}$。\n  - 拟合指数 $[2,4]$；扩展指数 $[2,4,6]$。\n- 测试 $2$（数据量少，模型在噪声范围内精确）：\n  - 真实指数 $[2,4]$，真实系数 $[1.0,0.0]$。\n  - $\\ell_{\\min}=5$, $L=8$，噪声标准差 $5.0\\times 10^{-10}$。\n  - 拟合指数 $[2,4]$；扩展指数 $[2,4,6]$。\n- 测试 $3$（模型与奇次幂真实值不匹配）：\n  - 真实指数 $[3,5]$，真实系数 $[1.0\\times 10^{-1},5.0\\times 10^{-2}]$。\n  - $\\ell_{\\min}=8$, $L=20$，噪声标准差 $1.0\\times 10^{-10}$。\n  - 拟合指数 $[2,4]$；扩展指数 $[2,4,6]$。\n- 测试 $4$（大截断，小尾部，模型指定良好）：\n  - 真实指数 $[2,4,6]$，真实系数 $[2.0\\times 10^{-1},1.0\\times 10^{-1},-1.0\\times 10^{-1}]$。\n  - $\\ell_{\\min}=30$, $L=60$，噪声标准差 $1.0\\times 10^{-12}$。\n  - 拟合指数 $[2,4,6]$；扩展指数 $[2,4,6,8]$。\n- 测试 $5$（含噪声的单项情况）：\n  - 真实指数 $[2]$，真实系数 $[5.0\\times 10^{-2}]$。\n  - $\\ell_{\\min}=5$, $L=15$，噪声标准差 $1.0\\times 10^{-4}$。\n  - 拟合指数 $[2]$；扩展指数 $[2,4]$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含每个测试用例的基础模型尾部估计 $\\hat{T}$ 和组合不确定度 $\\sigma_{\\text{comb}}$，对于 $5$ 个测试总共 $10$ 个浮点数。\n- 每个浮点数必须以科学记数法打印，小数点后精确到 $12$ 位。\n- 例如，要求的格式为 $[\\hat{T}_{1},\\sigma_{\\text{comb},1},\\hat{T}_{2},\\sigma_{\\text{comb},2},\\ldots,\\hat{T}_{5},\\sigma_{\\text{comb},5}]$。\n- 程序不得要求任何用户输入，不得访问外部文件或网络，并且必须使用固定的随机种子 $20231105$ 来生成高斯噪声，以使输出可复现。",
            "solution": "该问题要求设计并实现一个数值程序，以估计一个模式和的无穷尾部，这是在模式和正则化（MSR）框架下进行引力自作用力（GSF）计算中的一项常见任务。该程序涉及将一个渐近模型拟合到有限数量的已计算模式上，并利用此拟合将求和外推至无穷大。它还要求对统计不确定度和模型截断不确定度进行仔细的量化。\n\n问题的核心在于，对于大的多极指数 $\\ell$，剩余 GSF 模式 $F_{\\ell}$ 已确立的渐近行为。在减去解析已知的奇异部分（正则化参数）后，已知余项会以多项式形式衰减。问题提出了具体的渐近模型：\n$$\nF_{\\ell} \\sim \\sum_{j=1}^{m_{\\text{true}}} c^{\\text{true}}_{j}\\,(\\ell+\\tfrac{1}{2})^{-n^{\\text{true}}_{j}}\n$$\n其中 $n^{\\text{true}}_{j}$ 是正整数，$c^{\\text{true}}_{j}$ 是实系数。我们得到一组有限的“数据”模式 $\\{F_{\\ell}\\}_{\\ell=\\ell_{\\min}}^{L}$，任务是估计这个和的尾部 $T = \\sum_{\\ell=L+1}^{\\infty} F_{\\ell}$。\n\n估计过程包括三个主要部分：一个用于确定模型系数的线性最小二乘拟合，一个使用 Hurwitz zeta 函数对拟合模型的尾部进行的解析求和，以及一个对总不确定度的稳健估计。\n\n首先，我们进行线性最小二-乘拟合。我们假设一个形式为 $F_{\\ell} \\approx \\sum_{j=1}^{m} \\hat{c}_{j}\\,(\\ell+\\tfrac{1}{2})^{-n_{j}}$ 的拟合模型，其中指数集 $\\{n_{j}\\}_{j=1}^{m}$ 是选定的。该模型在未知系数 $\\hat{c}_{j}$ 上是线性的。我们可以将其表示为矩阵方程 $y \\approx A c$，其中 $y$ 是数据模式的向量 $[F_{\\ell_{\\min}},\\ldots,F_{L}]^{\\mathsf{T}}$，$c$ 是未知系数的向量 $[\\hat{c}_{1},\\ldots,\\hat{c}_{m}]^{\\mathsf{T}}$，$A$ 是设计矩阵。数据点的数量是 $N = L - \\ell_{\\min} + 1$。设计矩阵 $A$ 的维度是 $N \\times m$，其元素为 $A_{ij} = (\\ell_{i}+\\tfrac{1}{2})^{-n_{j}}$，其中 $\\ell_i = \\ell_{\\min} + i - 1$，$i=1, \\dots, N$。使残差平方和 $\\text{RSS}=\\|y - Ac\\|^2$ 最小化的普通最小二乘解由 $\\hat{c} = (A^{\\mathsf{T}}A)^{-1}A^{\\mathsf{T}}y$ 给出。为了数值稳定性和处理 $A^{\\mathsf{T}}A$ 可能病态或奇异的情况，我们使用 Moore-Penrose 伪逆，使得 $\\hat{c} = (A^{\\mathsf{T}}A)^{+}A^{\\mathsf{T}}y$。\n\n其次，一旦确定了系数 $\\hat{c}$，我们通过对拟合函数从 $\\ell=L+1$ 到无穷大求和来估计尾部 $T$。这个无穷和，记为 $\\hat{T}$，可以解析计算：\n$$\n\\hat{T} = \\sum_{\\ell=L+1}^{\\infty} \\sum_{j=1}^{m} \\hat{c}_{j}\\,(\\ell+\\tfrac{1}{2})^{-n_{j}} = \\sum_{j=1}^{m} \\hat{c}_{j} \\left( \\sum_{\\ell=L+1}^{\\infty} (\\ell+\\tfrac{1}{2})^{-n_{j}} \\right)\n$$\n内部的和可以用 Hurwitz zeta 函数 $\\zeta(s,a) = \\sum_{k=0}^{\\infty} (k+a)^{-s}$ 表示。通过更换索引 $k = \\ell - (L+1)$，该和变为：\n$$\n\\sum_{k=0}^{\\infty} (k+L+1+\\tfrac{1}{2})^{-n_j} = \\sum_{k=0}^{\\infty} (k+L+\\tfrac{3}{2})^{-n_j} = \\zeta(n_j, L+\\tfrac{3}{2})\n$$\n因此，估计的尾部是拟合系数的线性组合：\n$$\n\\hat{T} = \\sum_{j=1}^{m} \\hat{c}_{j}\\,\\zeta(n_j, L+\\tfrac{3}{2})\n$$\n\n第三，我们量化此估计中的不确定度。总不确定度来自两个主要来源：输入数据中的噪声引起的统计误差，以及渐近模型截断引起的系统误差。\n统计不确定度 $\\sigma_{\\text{stat}}$ 是通过将拟合系数 $\\hat{c}$ 的不确定度传播到最终值 $\\hat{T}$ 来计算的。由于 $\\hat{T} = g^{\\mathsf{T}}\\hat{c}$，其中 $g$ 是一个元素为 $g_j = \\zeta(n_j, L+\\tfrac{3}{2})$ 的向量，$\\hat{T}$ 的方差由 $\\sigma_{\\text{stat}}^2 = g^{\\mathsf{T}}\\text{Cov}(\\hat{c})g$ 给出。系数的协方差矩阵是 $\\text{Cov}(\\hat{c}) = \\hat{\\sigma}^2 (A^{\\mathsf{T}}A)^{+}$，其中 $\\hat{\\sigma}^2$ 是残差的估计方差。这被计算为 $\\hat{\\sigma}^2 = \\text{RSS}/\\nu$，其中 $\\text{RSS} = \\|y - A\\hat{c}\\|^2$ 是拟合的残差平方和，$\\nu = N-m$ 是自由度数。如果 $\\nu \\le 0$，我们取 $\\hat{\\sigma}^2=0$，这意味着 $\\sigma_{\\text{stat}}=0$。\n\n模型截断误差使用嵌套模型比较来估计。我们定义一个有 $m$ 个指数的基础模型 $\\{n_j\\}_{j=1}^{m}$，和一个有 $m+1$ 个指数的扩展模型 $\\{n_j\\}_{j=1}^{m+1}$，其中扩展集包含基础集。我们将两个模型都拟合到相同的数据上，得到尾部估计 $\\hat{T}$ 和 $\\hat{T}_{\\text{ext}}$。绝对差 $\\Delta T = |\\hat{T}_{\\text{ext}} - \\hat{T}|$ 作为使用有限项逼近真实无限渐近级数所引入的系统误差的代理。\n\n最后，统计误差和系统（截断）误差被正交相加以得出总的组合不确定度：\n$$\n\\sigma_{\\text{comb}} = \\sqrt{\\sigma_{\\text{stat}}^2 + \\Delta T^2}\n$$\n\n对于每个测试用例，总体算法流程如下：\n$1$. 使用指定的种子 $20231105$ 初始化一个单一的随机数生成器。\n$2$. 对于每个测试用例，通过向“真实”模型值添加具有指定标准差的高斯噪声，为 $\\ell \\in \\{\\ell_{\\min}, \\dots, L\\}$ 生成合成数据 $\\{F_{\\ell}\\}$。\n$3$. 一个专门的函数执行拟合和分析。它将数据、$\\ell$ 范围和一组指数作为输入。它构建设计矩阵 $A$，使用稳健的最小二乘求解器求解系数 $\\hat{c}$ 和 RSS，计算尾部估计 $\\hat{T}$，并计算统计不确定度 $\\sigma_{\\text{stat}}$。\n$4$. 首先使用基础模型指数调用此函数，以获得 $\\hat{T}$ 和 $\\sigma_{\\text{stat}}$。\n$5$. 然后使用扩展模型指数调用它，以获得 $\\hat{T}_{\\text{ext}}$。\n$6$. 计算截断误差代理 $\\Delta T$ 和组合不确定度 $\\sigma_{\\text{comb}}$。\n$7$. 存储得到的序对 $(\\hat{T}, \\sigma_{\\text{comb}})$。\n$8$. 处理完所有测试用例后，将收集到的结果格式化并打印为单行文本。这确保了对该问题提供一个完整、可复现且可验证的解决方案。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import zeta\n\ndef solve():\n    \"\"\"\n    Main function to run the tail-fitting procedure for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test 1: Happy path, even exponents with mild contamination\n        {\n            \"true_coeffs\": [5.0e-1, -3.0e-1, 2.0e-1], \"true_exponents\": [2, 4, 6],\n            \"l_min\": 10, \"L\": 25, \"noise_std\": 1.0e-8,\n            \"fit_exponents\": [2, 4], \"ext_fit_exponents\": [2, 4, 6]\n        },\n        # Test 2: Low data count, exact model within noise\n        {\n            \"true_coeffs\": [1.0, 0.0], \"true_exponents\": [2, 4],\n            \"l_min\": 5, \"L\": 8, \"noise_std\": 5.0e-10,\n            \"fit_exponents\": [2, 4], \"ext_fit_exponents\": [2, 4, 6]\n        },\n        # Test 3: Model mismatch with odd-power truth\n        {\n            \"true_coeffs\": [1.0e-1, 5.0e-2], \"true_exponents\": [3, 5],\n            \"l_min\": 8, \"L\": 20, \"noise_std\": 1.0e-10,\n            \"fit_exponents\": [2, 4], \"ext_fit_exponents\": [2, 4, 6]\n        },\n        # Test 4: Large cutoff, small tail, well-specified model\n        {\n            \"true_coeffs\": [2.0e-1, 1.0e-1, -1.0e-1], \"true_exponents\": [2, 4, 6],\n            \"l_min\": 30, \"L\": 60, \"noise_std\": 1.0e-12,\n            \"fit_exponents\": [2, 4, 6], \"ext_fit_exponents\": [2, 4, 6, 8]\n        },\n        # Test 5: Noisy single-term case\n        {\n            \"true_coeffs\": [5.0e-2], \"true_exponents\": [2],\n            \"l_min\": 5, \"L\": 15, \"noise_std\": 1.0e-4,\n            \"fit_exponents\": [2], \"ext_fit_exponents\": [2, 4]\n        }\n    ]\n\n    # Fixed seed for reproducibility across the entire run.\n    rng = np.random.default_rng(20231105)\n    \n    results = []\n\n    for case in test_cases:\n        # Generate synthetic data for the current test case.\n        ell_modes = np.arange(case[\"l_min\"], case[\"L\"] + 1)\n        x_data = ell_modes + 0.5\n        \n        F_true = np.zeros_like(x_data, dtype=float)\n        for c, n in zip(case[\"true_coeffs\"], case[\"true_exponents\"]):\n            F_true += c * x_data**(-n)\n            \n        noise = rng.normal(scale=case[\"noise_std\"], size=len(ell_modes))\n        F_data = F_true + noise\n\n        # Perform fit for base model\n        T_hat, sigma_stat = _perform_fit_and_analysis_single(\n            F_data, ell_modes, case[\"L\"], case[\"fit_exponents\"]\n        )\n\n        # Perform fit for extended model\n        T_hat_ext, _ = _perform_fit_and_analysis_single(\n            F_data, ell_modes, case[\"L\"], case[\"ext_fit_exponents\"]\n        )\n\n        # Calculate truncation error proxy and combined uncertainty\n        delta_T = np.abs(T_hat_ext - T_hat)\n        sigma_comb = np.sqrt(sigma_stat**2 + delta_T**2)\n\n        results.extend([T_hat, sigma_comb])\n\n    # Print results in the specified format\n    print(f\"[{','.join(f'{val:.12e}' for val in results)}]\")\n\n\ndef _perform_fit_and_analysis_single(F_data, ell_modes, L, exponents):\n    \"\"\"\n    Performs a single tail fit and uncertainty analysis for a given model.\n\n    Args:\n        F_data: The array of mode values.\n        ell_modes: The array of l-modes corresponding to F_data.\n        L: The cutoff multipole.\n        exponents: The list of exponents defining the fit model.\n\n    Returns:\n        A tuple (T_hat, sigma_stat) containing the tail estimate and its\n        statistical uncertainty.\n    \"\"\"\n    x_data = ell_modes + 0.5\n    N = len(ell_modes)\n    m = len(exponents)\n\n    # Construct the design matrix A\n    A = np.array([x_data**(-n) for n in exponents]).T\n    \n    # Perform a linear least-squares fit\n    # np.linalg.lstsq is robust and can return the residual sum of squares\n    coeffs, rss_array, rank, s = np.linalg.lstsq(A, F_data, rcond=None)\n\n    # Estimate the tail sum using the Hurwitz zeta function\n    g = np.array([zeta(n, L + 1.5) for n in exponents])\n    T_hat = np.dot(coeffs, g)\n\n    # Calculate the statistical uncertainty\n    nu = N - m\n    \n    if nu > 0 and rss_array.size > 0:\n        rss = rss_array[0]\n        sigma_hat_sq = rss / nu\n    else:  #Handles underdetermined case (N = m) or perfect fit\n        sigma_hat_sq = 0.0\n\n    # Covariance of coefficients: Cov(c) = sigma_hat^2 * (A^T A)^+\n    # np.linalg.pinv is used for the Moore-Penrose pseudoinverse as specified.\n    A_T_A_inv = np.linalg.pinv(A.T @ A)\n    cov_c = sigma_hat_sq * A_T_A_inv\n\n    # Variance of the tail estimate: Var(T_hat) = g^T Cov(c) g\n    var_T = g.T @ cov_c @ g\n    sigma_stat = np.sqrt(var_T)\n\n    return T_hat, sigma_stat\n\nsolve()\n```"
        }
    ]
}