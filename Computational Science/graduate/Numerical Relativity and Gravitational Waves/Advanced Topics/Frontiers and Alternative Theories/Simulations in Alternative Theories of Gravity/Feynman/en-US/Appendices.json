{
    "hands_on_practices": [
        {
            "introduction": "Stable numerical simulations of spacetime require carefully chosen coordinate or 'gauge' conditions. This analytical exercise challenges you to adapt standard gauge choices from general relativity to include source terms from a new scalar field, a common feature in modified gravity theories . By performing a characteristic analysis, you will practice the essential skill of verifying that the resulting system of equations is well-posed, ensuring that all modes propagate at sensible speeds and instabilities are controlled.",
            "id": "3486208",
            "problem": "Consider a scalar-tensor modification of General Relativity in which the gravitational sector is evolved using the Baumgarte–Shapiro–Shibata–Nakamura (BSSN) formulation, and an additional scalar field has canonical dynamics. Denote by $\\alpha$ the lapse, by $\\beta^{i}$ the shift, by $K$ the trace of the extrinsic curvature, by $B^{i}$ an auxiliary driver for the shift, and by $X$ the extra scalar degree of freedom. You are tasked with designing gauge conditions suitable for numerical simulations that incorporate $X$ as a source for the gauge, and then justifying these choices via a principal-part characteristic analysis of the coupled system.\n\nAssume the following fundamental bases:\n- The scalar field $X$ obeys a covariant wave equation whose principal part, linearized about Minkowski spacetime, reduces to $\\partial_{t}^{2} X = c_{X}^{2} \\,\\partial^{j}\\partial_{j} X$, with $c_{X} = 1$.\n- The BSSN principal parts governing the gauge-related curvature variables imply $\\partial_{t} K$ contains $-\\partial^{j}\\partial_{j}\\alpha$ at leading order when linearized about Minkowski spacetime with $\\alpha=1$, $\\beta^{i}=0$, $K=0$, and spatial metric equal to $\\delta_{ij}$.\n- The slicing condition is chosen from the Bona–Massó family, with $f(\\alpha)$ evaluated at $\\alpha=1$ determining the principal gauge mode speed, and the specific choice corresponding to the so-called $1+\\log$ slicing is $f(\\alpha) = 2/\\alpha$.\n- The shift condition is of hyperbolic Gamma-driver type, implemented as a damped wave driver for $\\beta^{i}$ with an auxiliary variable $B^{i}$ controlling damping on the time derivative of the shift.\n\nIntroduce extra-field source terms built from first derivatives of $X$ into both the slicing and shift drivers. Working in one spatial dimension (so $i=x$), and restricting attention to principal parts, adopt general leading-order source couplings of the form $S_{\\alpha} \\propto \\partial_{t} X$ and $S_{\\beta}^{i} \\propto \\partial^{i} X$. Linearize the coupled $(\\alpha, K, \\beta^{x}, B^{x}, X)$ system about Minkowski spacetime, freeze coefficients, and perform a Fourier-mode characteristic analysis with plane waves $\\exp(i(kx - \\omega t))$ to determine the characteristic speeds of the gauge and scalar modes.\n\nYour tasks:\n1. Starting from the Bona–Massó slicing with the $1+\\log$ choice and adding a source proportional to $\\partial_{t} X$, write the explicit leading-order evolution law for $\\alpha$ (keeping advection terms), with a real coupling coefficient $\\kappa_{\\alpha}$.\n2. Starting from a damped-wave Gamma-driver and adding a source proportional to $\\partial^{x} X$, write the explicit leading-order evolution laws for $\\beta^{x}$ and $B^{x}$ with real parameters $c_{\\beta}$ (a desired gauge-wave speed for the shift driver) and $\\eta>0$ (a damping rate), and a real coupling coefficient $\\kappa_{\\beta}$.\n3. Perform the principal-part characteristic analysis of the coupled $(\\alpha, X)$ block and of the $(\\beta^{x}, B^{x})$ driver to obtain the characteristic speeds of the lapse, shift driver, and scalar modes. Impose the requirement that the shift driver speed matches the scalar-field speed, i.e., choose $c_{\\beta}$ so that the shift driver propagates at the same speed as $X$.\n\nProvide the final answer as explicit closed-form analytical expressions for the right-hand sides of the evolution equations from parts 1 and 2 (expressed in terms of $\\alpha$, $\\beta^{x}$, $B^{x}$, $K$, $X$, $\\kappa_{\\alpha}$, $\\kappa_{\\beta}$, and $\\eta$), together with the characteristic speeds of the $(\\alpha, \\beta^{x}, X)$ modes. No numerical approximation or rounding is required. The final answer must be a single analytical object. No physical units are needed.",
            "solution": "### Solution Derivations\n\nThe solution proceeds by first constructing the requested evolution equations and then performing a characteristic analysis on their linearized forms to determine the propagation speeds.\n\n**1. Evolution Equation for the Lapse $\\alpha$**\n\nThe Bona–Massó slicing condition is given by $\\partial_{t} \\alpha - \\beta^{j} \\partial_{j} \\alpha = -\\alpha^2 f(\\alpha) K$.\nFor the $1+\\log$ slicing choice, $f(\\alpha) = 2/\\alpha$. Substituting this into the general form yields:\n$$ \\partial_{t} \\alpha - \\beta^{j} \\partial_{j} \\alpha = -\\alpha^2 \\left(\\frac{2}{\\alpha}\\right) K = -2\\alpha K $$\nThe problem requires adding a source term proportional to $\\partial_{t} X$ with coupling $\\kappa_{\\alpha}$. We add this source term to the right-hand side. In one spatial dimension ($j=x$), the full evolution equation for $\\alpha$ is:\n$$ \\partial_{t} \\alpha = -2\\alpha K + \\beta^{x} \\partial_{x} \\alpha + \\kappa_{\\alpha} \\partial_{t} X $$\nThe requested right-hand side (RHS) of this evolution equation is $-2\\alpha K + \\beta^{x} \\partial_{x} \\alpha + \\kappa_{\\alpha} \\partial_{t} X$.\n\n**2. Evolution Equations for the Shift $\\beta^{x}$ and $B^{x}$**\n\nThe hyperbolic Gamma-driver is a damped wave equation for the shift $\\beta^{i}$. In its first-order-in-time form, it is typically written as a system for $\\beta^{i}$ and an auxiliary variable $B^{i}$. The problem statement does not specify advection terms for this system, so we adopt the simplest standard form, which is also consistent with the fact that certain advective terms (like the Lie derivative of the shift along itself) vanish in one dimension. The system is:\n$$ \\partial_{t}\\beta^{i} = B^{i} $$\n$$ \\partial_{t}B^{i} = c_{\\beta}^{2} \\partial_{j}\\partial^{j}\\beta^{i} - \\eta B^{i} + S_{\\beta}^{i} $$\nThe source term is specified as $S_{\\beta}^{i} = \\kappa_{\\beta} \\partial^{i} X$. In one spatial dimension ($i=x, j=x$, and $\\partial^{x} = \\partial_{x}$ for a flat background metric), the system of evolution equations is:\n$$ \\partial_{t}\\beta^{x} = B^{x} $$\n$$ \\partial_{t}B^{x} = c_{\\beta}^{2} \\partial_{x}^{2} \\beta^{x} - \\eta B^{x} + \\kappa_{\\beta} \\partial_{x} X $$\nThe RHS for $\\partial_{t}\\beta^{x}$ is $B^{x}$. The RHS for $\\partial_{t}B^{x}$ is $c_{\\beta}^{2} \\partial_{x}^{2} \\beta^{x} - \\eta B^{x} + \\kappa_{\\beta} \\partial_{x} X$.\n\n**3. Characteristic Analysis and Speeds**\n\nWe linearize the system around a Minkowski background where $\\alpha=1$, $\\beta^{x}=0$, $K=0$, $B^{x}=0$, and $X=0$. The linearized variables are denoted by $\\delta\\alpha$, $\\delta\\beta^{x}$, etc.\n\n**Analysis of the $(\\alpha, X)$ block:**\nThe relevant linearized equations are:\n1. $\\partial_{t} \\delta\\alpha = -2 \\delta K + \\kappa_{\\alpha} \\partial_{t} \\delta X$ (from the lapse evolution, $\\alpha \\approx 1$)\n2. $\\partial_{t} \\delta K = -\\partial_{x}^{2} \\delta\\alpha$ (from the BSSN principal part)\n3. $\\partial_{t}^{2} \\delta X = \\partial_{x}^{2} \\delta X$ (from the scalar field dynamics, $c_X=1$)\n\nTake the time derivative of equation (1) and substitute (2):\n$$ \\partial_{t}^{2} \\delta\\alpha = -2 \\partial_{t}\\delta K + \\kappa_{\\alpha} \\partial_{t}^{2} \\delta X = -2(-\\partial_{x}^{2} \\delta\\alpha) + \\kappa_{\\alpha} \\partial_{t}^{2} \\delta X = 2\\partial_{x}^{2} \\delta\\alpha + \\kappa_{\\alpha} \\partial_{t}^{2} \\delta X $$\nSubstitute (3) into this result:\n$$ \\partial_{t}^{2} \\delta\\alpha = 2\\partial_{x}^{2} \\delta\\alpha + \\kappa_{\\alpha} \\partial_{x}^{2} \\delta X $$\nThis gives a coupled system for $(\\delta\\alpha, \\delta X)$:\n$$ \\partial_{t}^{2} \\delta\\alpha - 2\\partial_{x}^{2} \\delta\\alpha - \\kappa_{\\alpha} \\partial_{x}^{2} \\delta X = 0 $$\n$$ \\partial_{t}^{2} \\delta X - \\partial_{x}^{2} \\delta X = 0 $$\nTo find the characteristic speeds, we analyze the principal part of this system. We transform the system into the Fourier domain by applying the substitution $\\partial_{t} \\to -i\\omega$ and $\\partial_{x} \\to i k$.\n$$ (-\\omega^{2} + 2k^{2}) \\widehat{\\delta\\alpha} + \\kappa_{\\alpha} k^{2} \\widehat{\\delta X} = 0 $$\n$$ (-\\omega^{2} + k^{2}) \\widehat{\\delta X} = 0 $$\nThis can be written in matrix form:\n$$ \\begin{pmatrix} -\\omega^{2} + 2k^{2} & \\kappa_{\\alpha} k^{2} \\\\ 0 & -\\omega^{2} + k^{2} \\end{pmatrix} \\begin{pmatrix} \\widehat{\\delta\\alpha} \\\\ \\widehat{\\delta X} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} $$\nThe characteristic equation is found by setting the determinant of the matrix to zero:\n$$ (-\\omega^{2} + 2k^{2})(-\\omega^{2} + k^{2}) = 0 $$\nThis yields two dispersion relations:\n- $\\omega^{2} = 2k^{2} \\implies v = \\frac{\\omega}{k} = \\pm\\sqrt{2}$. These are the speeds of the lapse gauge modes, $v_{\\alpha}$.\n- $\\omega^{2} = k^{2} \\implies v = \\frac{\\omega}{k} = \\pm 1$. These are the speeds of the scalar field modes, $v_{X}$.\n\n**Analysis of the $(\\beta^{x}, B^{x})$ driver:**\nThe linearized evolution equations for the shift driver are:\n$$ \\partial_{t}\\delta\\beta^{x} = \\delta B^{x} $$\n$$ \\partial_{t}\\delta B^{x} = c_{\\beta}^{2} \\partial_{x}^{2} \\delta\\beta^{x} - \\eta \\delta B^{x} + \\kappa_{\\beta} \\partial_{x} \\delta X $$\nThe scalar field $\\delta X$ acts as a source term. The characteristic speeds of the driver are determined by the homogeneous part of the system:\n$$ \\partial_{t}\\delta\\beta^{x} = \\delta B^{x} $$\n$$ \\partial_{t}\\delta B^{x} = c_{\\beta}^{2} \\partial_{x}^{2} \\delta\\beta^{x} - \\eta \\delta B^{x} $$\nCombining these gives a single second-order PDE for $\\delta\\beta^{x}$:\n$$ \\partial_{t}^{2}\\delta\\beta^{x} = \\partial_{t}(\\delta B^{x}) = c_{\\beta}^{2} \\partial_{x}^{2} \\delta\\beta^{x} - \\eta (\\partial_{t}\\delta\\beta^{x}) $$\n$$ \\partial_{t}^{2}\\delta\\beta^{x} + \\eta \\partial_{t}\\delta\\beta^{x} - c_{\\beta}^{2} \\partial_{x}^{2} \\delta\\beta^{x} = 0 $$\nThe characteristic speeds are determined by the principal part of this damped wave equation, $\\partial_{t}^{2}\\delta\\beta^{x} - c_{\\beta}^{2} \\partial_{x}^{2} \\delta\\beta^{x} = 0$. This yields speeds $v = \\pm c_{\\beta}$. To find all speeds of the first-order system, we write it as $\\partial_{t}\\vec{u} + A\\partial_{x}\\vec{u} = S$. Let $u_1=\\delta B^x$ and $u_2=\\partial_x \\delta \\beta^x$. The system $\\partial_t u_1 = c_\\beta^2 \\partial_x u_2 - \\eta u_1$ and $\\partial_t u_2 = \\partial_x u_1$ has a characteristic matrix with eigenvalues $0, \\pm c_\\beta$. Thus, the speeds of the shift driver modes are $v_{\\beta} = 0, \\pm c_{\\beta}$.\n\n**Imposing the Speed-Matching Constraint:**\nThe problem requires the shift driver speed to match the scalar field speed: $|v_{\\beta, \\text{propagating}}| = |v_{X}|$.\n$$ c_{\\beta} = c_{X} $$\nGiven $c_{X}=1$, we must set $c_{\\beta} = 1$.\nWith this constraint, the RHS of the $\\partial_{t}B^{x}$ evolution law becomes $\\partial_{x}^{2} \\beta^{x} - \\eta B^{x} + \\kappa_{\\beta} \\partial_{x} X$. The characteristic speeds for the shift driver become $v_{\\beta} = 0, \\pm 1$.\n\n### Summary of Final Results\n1.  **RHS of $\\partial_{t}\\alpha$**: $-2\\alpha K + \\beta^{x} \\partial_{x} \\alpha + \\kappa_{\\alpha} \\partial_{t} X$\n2.  **RHS of $\\partial_{t}\\beta^{x}$**: $B^{x}$\n3.  **RHS of $\\partial_{t}B^{x}$**: $\\partial_{x}^{2} \\beta^{x} - \\eta B^{x} + \\kappa_{\\beta} \\partial_{x} X$\n4.  **Characteristic Speeds of $\\alpha$ modes**: $\\pm\\sqrt{2}$\n5.  **Characteristic Speeds of $\\beta^{x}$ driver modes**: $0, \\pm 1$\n6.  **Characteristic Speeds of $X$ modes**: $\\pm 1$\n\nThese results are collected into a single analytical object for the final answer.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-2\\alpha K + \\beta^{x} \\partial_{x} \\alpha + \\kappa_{\\alpha} \\partial_{t} X \\\\\nB^{x} \\\\\n\\partial_{x}^{2} \\beta^{x} - \\eta B^{x} + \\kappa_{\\beta} \\partial_{x} X \\\\\n\\pm\\sqrt{2} \\\\\n\\begin{pmatrix} 0 & \\pm 1 \\end{pmatrix} \\\\\n\\pm 1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The equations of motion in alternative gravity theories can be numerically 'stiff,' with different terms requiring vastly different time step sizes for a stable solution. This exercise introduces operator splitting, a powerful technique to manage such systems by evolving the 'stiff' and 'non-stiff' parts of the equations separately . Through this hands-on coding problem, you will implement both Lie and Strang splitting, verify their theoretical convergence rates, and understand their importance for creating efficient and accurate evolution codes.",
            "id": "3486184",
            "problem": "Consider a one-dimensional linear model problem that captures the essence of stiff curvature-coupled source terms commonly appearing in alternative theories of gravity, such as scalar-tensor modifications, under the approximation of a prescribed background curvature. Let the unknown field be a scalar surrogate for a gravitational degree of freedom, denoted by $u(x,t)$, on a periodic domain $x \\in [0, 2\\pi)$ with period $2\\pi$. The governing Partial Differential Equation (PDE) is\n$$\n\\partial_t u(x,t) + c \\, \\partial_x u(x,t) \\;=\\; -\\alpha \\, \\mathcal{C}(x) \\, u(x,t),\n$$\nwhere $c$ is a constant advection speed, $\\alpha$ is a stiffness parameter representing the ratio of coupling strength to relaxation time, and $\\mathcal{C}(x)$ is a smooth, prescribed spatially varying curvature surrogate. In the test problem, use $\\mathcal{C}(x) = 1 + a \\sin(x)$ with curvature-amplitude parameter $a$. The initial condition is\n$$\nu(x,0) = u_0(x) = \\sin(3x) + 0.5 \\cos(2x).\n$$\nThe program must implement two operator-splitting time integrators for this PDE:\n- Lie (first-order) splitting over a time step $\\Delta t$ as flow composition $\\exp(\\Delta t \\, \\mathcal{S}) \\circ \\exp(\\Delta t \\, \\mathcal{A})$, where $\\mathcal{A}$ is the advection operator $\\mathcal{A}[u] = -c \\partial_x u$ and $\\mathcal{S}$ is the stiff source operator $\\mathcal{S}[u] = -\\alpha \\mathcal{C}(x) u$. The subflows must each be integrated exactly in their respective subproblems: for $\\mathcal{A}$, use a spectral solution on the periodic domain via Fourier modes; for $\\mathcal{S}$, use the exact pointwise multiplicative update $u \\mapsto u \\, \\exp(-\\alpha \\mathcal{C}(x)\\Delta t)$.\n- Strang (second-order) splitting over a time step $\\Delta t$ as $\\exp\\left(\\frac{\\Delta t}{2}\\mathcal{S}\\right) \\circ \\exp(\\Delta t \\mathcal{A}) \\circ \\exp\\left(\\frac{\\Delta t}{2}\\mathcal{S}\\right)$ with the same exact subsolvers.\n\nFor verification with a manufactured solution, derive and use the exact solution of the full PDE for the chosen $\\mathcal{C}(x)$ via the method of characteristics. Along the characteristic $x(t) = x_0 + c t$ with $x_0 = x - c t$ (interpreted modulo $2\\pi$), one has\n$$\n\\frac{d}{dt}u(x(t),t) = -\\alpha \\, \\mathcal{C}(x(t)) \\, u(x(t),t),\n$$\nwhich integrates to the exact solution\n$$\nu_{\\mathrm{exact}}(x,t) \\;=\\; u_0(x - c t) \\, \\exp\\!\\left(-\\alpha \\int_{0}^{t} \\mathcal{C}(x - c(t-s)) \\, ds \\right).\n$$\nFor $\\mathcal{C}(x) = 1 + a\\sin(x)$, this integral can be evaluated in closed form to yield\n$$\nu_{\\mathrm{exact}}(x,t) \\;=\\; u_0(x - c t) \\, \\exp\\!\\left(-\\alpha \\left[ t + \\frac{a}{c} \\left(\\cos(x - c t) - \\cos(x)\\right) \\right] \\right).\n$$\n\nImplement the following numerical experiment and report quantitative measures of splitting error and convergence:\n\n- Domain and numerics:\n  - Use a periodic grid with $N_x$ equispaced points on $[0,2\\pi)$, where $N_x = 1024$.\n  - Use a spectral update for advection: if $\\widehat{u}_k$ denotes the Fourier coefficient at wavenumber $k$, then $\\widehat{u}_k(t+\\Delta t) = \\widehat{u}_k(t) \\, \\exp(-\\mathrm{i} k c \\Delta t)$, where $k$ is the angular wavenumber.\n  - Use the exact multiplicative update for the stiff source: $u(x) \\mapsto u(x) \\, \\exp(-\\alpha \\mathcal{C}(x)\\Delta t)$.\n\n- Parameters for the variable-curvature test:\n  - Set $c = 1$, $\\alpha = 10$, $a = 0.1$, final time $T = 1$.\n  - Use the time-step test suite $\\Delta t \\in \\{0.1, 0.05, 0.025, 0.0125\\}$. Ensure that $T/\\Delta t$ is an integer for each case by construction.\n  - For each $\\Delta t$, advance from $t=0$ to $t=T$ with Lie splitting and with Strang splitting, starting from $u_0(x)$.\n  - For each $\\Delta t$, compute the discrete $L^2$ error at $t=T$ against the exact solution $u_{\\mathrm{exact}}(x,T)$:\n    $$\n    \\|e\\|_2 \\;=\\; \\left( \\frac{1}{N_x} \\sum_{j=0}^{N_x-1} \\left( u_j^{\\mathrm{num}} - u_{\\mathrm{exact},j} \\right)^2 \\right)^{1/2}.\n    $$\n  - From the error sequences $\\{E_{\\Delta t}\\}$ for Lie and Strang, compute the observed orders between successive refinements via\n    $$\n    p \\;=\\; \\log_2\\!\\left( \\frac{E_{\\Delta t}}{E_{\\Delta t/2}} \\right).\n    $$\n    Report the three orders for the pairs $(0.1 \\to 0.05)$, $(0.05 \\to 0.025)$, and $(0.025 \\to 0.0125)$ for both methods.\n\n- Parameters for the commuting-operators edge test:\n  - Set $a = 0$ (so that $\\mathcal{C}(x) \\equiv 1$) with $c = 1$, $\\alpha = 10$, $T = 1$, and a single step size $\\Delta t = 0.2$.\n  - Because $\\mathcal{S}$ and $\\mathcal{A}$ commute when $\\mathcal{C}(x)$ is constant, both Lie and Strang splittings must be exact up to numerical roundoff. Verify this by computing the $L^2$ error at $t=T$ for both methods and comparing to a tolerance $\\tau = 10^{-12}$. Report two booleans indicating whether the Lie and Strang errors are less than or equal to $\\tau$.\n\nYour program must:\n- Implement the exact spectral advection substep and exact stiff source substep as described.\n- Use the manufactured exact solution above for error evaluation.\n- Produce the following final outputs:\n  - A list of three floats for the observed orders of Lie splitting over the time-step test suite, rounded to three decimal places.\n  - A list of three floats for the observed orders of Strang splitting over the time-step test suite, rounded to three decimal places.\n  - A boolean for the commuting-operators test with constant curvature indicating whether Lie splitting is effectively exact within tolerance $\\tau$.\n  - A boolean for the commuting-operators test with constant curvature indicating whether Strang splitting is effectively exact within tolerance $\\tau$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact format\n  $$\n  \\text{\"[[Lie\\_orders],[Strang\\_orders],Lie\\_const\\_ok,Strang\\_const\\_ok]\"}\n  $$\n  where each orders list contains three floats rounded to three decimal places with no spaces, and the booleans are either $\\text{True}$ or $\\text{False}$. For example,\n  $$\n  \\text{\"[[1.000,1.000,1.000],[2.000,2.000,2.000],True,True]\"}.\n  $$\n\nAll quantities in this problem are nondimensional; no physical units are required. Angles must be understood in radians. The only acceptable outputs are floats and booleans as specified, aggregated in the single-line format above.",
            "solution": "The problem revolves around the numerical solution of the following PDE on a periodic domain $x \\in [0, 2\\pi)$:\n$$\n\\partial_t u(x,t) + c \\, \\partial_x u(x,t) = -\\alpha \\, \\mathcal{C}(x) \\, u(x,t)\n$$\nThis equation can be formally written as $\\partial_t u = (\\mathcal{A} + \\mathcal{S})u$, where $\\mathcal{A}[u] = -c \\partial_x u$ is the advection operator and $\\mathcal{S}[u] = -\\alpha \\mathcal{C}(x) u$ is the stiff source (or reaction) operator. Operator splitting methods approximate the solution operator $\\exp(\\Delta t (\\mathcal{A} + \\mathcal{S}))$ by a composition of the solution operators for the individual subproblems, $\\exp(\\Delta t \\mathcal{A})$ and $\\exp(\\Delta t \\mathcal{S})$.\n\nThe solution will be implemented in several logical stages:\n1.  **Spatial Discretization**: The continuous domain $x \\in [0, 2\\pi)$ is discretized into $N_x = 1024$ equispaced grid points $x_j = j (2\\pi/N_x)$ for $j=0, \\dots, N_x-1$. All continuous functions, such as the initial condition $u_0(x)$ and the curvature surrogate $\\mathcal{C}(x)$, are evaluated on this grid to produce discrete state vectors. The Fourier representation of these grid functions is central to the advection solver. The corresponding angular wavenumbers for a domain of length $2\\pi$ are the integers $k$. For a discrete Fourier transform of size $N_x$, these are represented by the array `k = np.fft.fftfreq(Nx) * Nx`.\n\n2.  **Subproblem Solvers**: The operator splitting methods rely on \"exact\" solvers for the two subproblems over a time step $\\Delta t$:\n    - **Advection Subproblem**: $\\partial_t u = \\mathcal{A}[u] = -c \\partial_x u$. In Fourier space, this equation becomes $\\partial_t \\widehat{u}_k = -i c k \\widehat{u}_k$, where $\\widehat{u}_k$ is the Fourier coefficient for wavenumber $k$. This is a simple ordinary differential equation (ODE) with the exact solution $\\widehat{u}_k(\\Delta t) = \\widehat{u}_k(0) e^{-i c k \\Delta t}$. The numerical algorithm for the advection substep is thus: (i) Forward Fourier Transform the state vector $u$, (ii) multiply each Fourier coefficient $\\widehat{u}_k$ by its corresponding complex exponential propagator, and (iii) Inverse Fourier Transform the result back to physical space.\n    - **Source Subproblem**: $\\partial_t u = \\mathcal{S}[u] = -\\alpha \\mathcal{C}(x) u$. At each spatial point $x_j$, this is a local ODE $du_j/dt = -\\alpha \\mathcal{C}(x_j) u_j$. The solution is $u_j(\\Delta t) = u_j(0) e^{-\\alpha \\mathcal{C}(x_j) \\Delta t}$. The numerical algorithm is a simple pointwise multiplication of the state vector $u$ by the factor $\\exp(-\\alpha \\mathcal{C}(x) \\Delta t)$ evaluated on the grid.\n\n3.  **Operator Splitting Integrators**: Two splitting schemes are implemented:\n    - **Lie Splitting (1st order)**: The evolution over one time step $\\Delta t$ is approximated by $\\exp(\\Delta t \\mathcal{S}) \\circ \\exp(\\Delta t \\mathcal{A})$. This means we first apply the advection solver for a full step $\\Delta t$, and then apply the source solver to the result for a full step $\\Delta t$.\n    - **Strang Splitting (2nd order)**: The evolution is approximated by $\\exp(\\frac{\\Delta t}{2}\\mathcal{S}) \\circ \\exp(\\Delta t \\mathcal{A}) \\circ \\exp(\\frac{\\Delta t}{2}\\mathcal{S})$. This symmetric composition results in a higher order of accuracy. The algorithm is: (i) apply the source solver for a half-step $\\Delta t/2$, (ii) apply the advection solver to the result for a full step $\\Delta t$, and (iii) apply the source solver again to that result for another half-step $\\Delta t/2$.\n\n4.  **Verification and Analysis**:\n    - **Convergence Test**: The numerical solutions are compared against the provided exact analytical solution. The $L^2$ error is calculated for a sequence of decreasing time steps $\\Delta t$. The convergence order $p$ is then computed using the formula $p = \\log_2(E_{\\Delta t}/E_{\\Delta t/2})$, where $E_{\\Delta t}$ is the error for a given step size. We expect $p \\approx 1$ for Lie splitting and $p \\approx 2$ for Strang splitting.\n    - **Commuting Operator Test**: When the curvature is constant ($a=0$), the operators $\\mathcal{A}$ and $\\mathcal{S}$ commute. In this special case, the splitting error vanishes, and both Lie and Strang splitting methods should yield the exact solution up to machine precision. This is verified by computing the $L^2$ error and comparing it against a small tolerance $\\tau = 10^{-12}$.\n\nThe final program structure encapsulates these components into a single `solve()` function. Helper functions are defined for the initial condition, curvature, exact solution, numerical substeps, and full time-stepping integrators. The two distinct experiments are then performed, their results are collected, and the final output is formatted into the precisely specified single-line string.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies operator-splitting methods for a 1D advection-reaction PDE.\n    \"\"\"\n\n    # Helper functions for the physical model and numerical methods.\n    # These are nested to keep the global scope clean and the script self-contained.\n\n    def u0(x: np.ndarray) -> np.ndarray:\n        \"\"\"Defines the initial condition u(x,0).\"\"\"\n        return np.sin(3.0 * x) + 0.5 * np.cos(2.0 * x)\n\n    def C_func(x: np.ndarray, a: float) -> np.ndarray:\n        \"\"\"Defines the curvature surrogate C(x).\"\"\"\n        return 1.0 + a * np.sin(x)\n\n    def u_exact(x: np.ndarray, t: float, c: float, alpha: float, a: float) -> np.ndarray:\n        \"\"\"Computes the exact analytical solution u(x,t).\"\"\"\n        # The provided formula has a/c. It is valid for c!=0.\n        # The problem parameters only use c=1.0.\n        x_char = x - c * t  # Characteristic coordinate x_0 = x - c*t\n        integral_term = t + (a / c) * (np.cos(x_char) - np.cos(x))\n        exponent = -alpha * integral_term\n        return u0(x_char) * np.exp(exponent)\n\n    def advection_substep(u_grid: np.ndarray, dt: float, c: float, k_wavenumbers: np.ndarray) -> np.ndarray:\n        \"\"\"Performs the advection substep in Fourier space.\"\"\"\n        u_hat = np.fft.fft(u_grid)\n        u_hat_new = u_hat * np.exp(-1j * k_wavenumbers * c * dt)\n        return np.fft.ifft(u_hat_new).real\n\n    def source_substep(u_grid: np.ndarray, dt: float, alpha: float, C_grid: np.ndarray) -> np.ndarray:\n        \"\"\"Performs the stiff source substep in physical space.\"\"\"\n        return u_grid * np.exp(-alpha * C_grid * dt)\n\n    def evolve_lie(u_initial: np.ndarray, T: float, dt: float, c: float, alpha: float, C_grid: np.ndarray, k_wavenumbers: np.ndarray) -> np.ndarray:\n        \"\"\"Evolves the PDE using first-order Lie splitting.\"\"\"\n        num_steps = int(round(T / dt))\n        u = u_initial.copy()\n        for _ in range(num_steps):\n            # Lie splitting: S o A (apply A, then S)\n            u_after_A = advection_substep(u, dt, c, k_wavenumbers)\n            u = source_substep(u_after_A, dt, alpha, C_grid)\n        return u\n\n    def evolve_strang(u_initial: np.ndarray, T: float, dt: float, c: float, alpha: float, C_grid: np.ndarray, k_wavenumbers: np.ndarray) -> np.ndarray:\n        \"\"\"Evolves the PDE using second-order Strang splitting.\"\"\"\n        num_steps = int(round(T / dt))\n        u = u_initial.copy()\n        for _ in range(num_steps):\n            # Strang splitting: S/2 o A o S/2\n            u_half_S1 = source_substep(u, dt / 2.0, alpha, C_grid)\n            u_full_A = advection_substep(u_half_S1, dt, c, k_wavenumbers)\n            u = source_substep(u_full_A, dt / 2.0, alpha, C_grid)\n        return u\n        \n    def calculate_l2_error(u_numerical: np.ndarray, u_exact_grid: np.ndarray) -> float:\n        \"\"\"Computes the discrete L2 error.\"\"\"\n        return np.sqrt(np.mean((u_numerical - u_exact_grid)**2))\n\n    def calculate_convergence_orders(errors_list: list) -> list:\n        \"\"\"Computes observed convergence orders from a list of errors.\"\"\"\n        orders = []\n        for i in range(len(errors_list) - 1):\n            # p = log2( E_{dt} / E_{dt/2} )\n            order = np.log2(errors_list[i] / errors_list[i+1])\n            orders.append(order)\n        return orders\n\n    # --- Shared Numerical Setup ---\n    Nx = 1024\n    x_grid = np.linspace(0, 2 * np.pi, Nx, endpoint=False)\n    k_wavenumbers = np.fft.fftfreq(Nx) * Nx\n    u_initial_grid = u0(x_grid)\n    \n    # --- Experiment 1: Variable Curvature and Convergence Test ---\n    c_var = 1.0\n    alpha_var = 10.0\n    a_var = 0.1\n    T_var = 1.0\n    dt_suite = [0.1, 0.05, 0.025, 0.0125]\n    \n    C_grid_var = C_func(x_grid, a_var)\n    u_final_exact_var = u_exact(x_grid, T_var, c_var, alpha_var, a_var)\n    \n    lie_errors = []\n    strang_errors = []\n    \n    for dt in dt_suite:\n        u_final_lie = evolve_lie(u_initial_grid, T_var, dt, c_var, alpha_var, C_grid_var, k_wavenumbers)\n        lie_errors.append(calculate_l2_error(u_final_lie, u_final_exact_var))\n        \n        u_final_strang = evolve_strang(u_initial_grid, T_var, dt, c_var, alpha_var, C_grid_var, k_wavenumbers)\n        strang_errors.append(calculate_l2_error(u_final_strang, u_final_exact_var))\n        \n    lie_orders = calculate_convergence_orders(lie_errors)\n    strang_orders = calculate_convergence_orders(strang_errors)\n    \n    # --- Experiment 2: Commuting Operators Edge Test ---\n    c_const = 1.0\n    alpha_const = 10.0\n    a_const = 0.0\n    T_const = 1.0\n    dt_const = 0.2\n    tolerance = 1e-12\n    \n    C_grid_const = C_func(x_grid, a_const)\n    u_final_exact_const = u_exact(x_grid, T_const, c_const, alpha_const, a_const)\n    \n    u_final_lie_const = evolve_lie(u_initial_grid, T_const, dt_const, c_const, alpha_const, C_grid_const, k_wavenumbers)\n    lie_error_const = calculate_l2_error(u_final_lie_const, u_final_exact_const)\n    lie_const_ok = lie_error_const <= tolerance\n    \n    u_final_strang_const = evolve_strang(u_initial_grid, T_const, dt_const, c_const, alpha_const, C_grid_const, k_wavenumbers)\n    strang_error_const = calculate_l2_error(u_final_strang_const, u_final_exact_const)\n    strang_const_ok = strang_error_const <= tolerance\n    \n    # --- Final Output Formatting ---\n    lie_orders_str = \",\".join([f\"{order:.3f}\" for order in lie_orders])\n    strang_orders_str = \",\".join([f\"{order:.3f}\" for order in strang_orders])\n    \n    print(f\"[[{lie_orders_str}],[{strang_orders_str}],{lie_const_ok},{strang_const_ok}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Every numerical evolution of a compact binary begins with a valid 'snapshot' of the initial spacetime geometry and matter fields, a step known as constructing the initial data. This problem guides you through the practical process of setting up initial data for a binary system in a scalar-tensor theory on a 3D numerical grid . You will compute the residuals of the modified constraint equations and analyze a proxy for binding energy, learning how to programmatically assess the quality and physical implications of your initial setup before launching a full-scale evolution.",
            "id": "3486232",
            "problem": "You are tasked with programmatically assessing the quality of time-symmetric, conformally flat initial data for a compact binary in a scalar-tensor extension of General Relativity (GR), by computing residuals of the modified constraints and comparing a binding-energy proxy to a General Relativity (GR) baseline across several coupling strengths. Work in geometric units with $G=c=1$ so that all quantities are dimensionless.\n\nFundamental base and scenario:\n- Consider a $3$-dimensional initial hypersurface with spatial metric $\\gamma_{ij}=\\psi^4 \\delta_{ij}$, extrinsic curvature $K_{ij}=0$, and a real scalar field $\\phi$ with mass parameter $m_s$. On such a time-symmetric slice, the Hamiltonian constraint of General Relativity (GR) with effective energy density $E$ is $R(\\gamma)=16\\pi E$, where for conformally flat $\\gamma_{ij}$ one has $R(\\gamma)=-8 \\psi^{-5} \\Delta \\psi$ in terms of the flat-space Laplacian $\\Delta$. A weakly coupled scalar-tensor extension modifies the effective source to include a scalar contribution that we model as $E = \\alpha E_{\\phi}$, where $\\alpha \\ge 0$ is a dimensionless coupling strength and $E_{\\phi}$ is the scalar energy density measured by the Eulerian observer. For a time-symmetric slice with vanishing scalar conjugate momentum, the scalar energy density is $E_{\\phi}=\\tfrac{1}{2}\\left(|\\nabla \\phi|^2 + m_s^2 \\phi^2\\right)$, where all derivatives are taken with respect to the flat background.\n- Away from compact sources, the scalar field satisfies the flat-space massive Klein–Gordon equation $\\Delta \\phi - m_s^2 \\phi = 0$. For two point-like compact objects with phenomenological scalar charges $s_1 m_1$ and $s_2 m_2$ located at positions $\\pm d/2$ along the $x$-axis, a widely used weak-field proxy for the scalar field is a superposition of Yukawa profiles $\\phi_0(\\mathbf{x}) = s_1 m_1 e^{-m_s r_1}/r_1 + s_2 m_2 e^{-m_s r_2}/r_2$, where $r_1$ and $r_2$ are the Euclidean distances to the two sources.\n- A simple conformal factor proxy for two time-symmetric nonspinning black holes is the Brill–Lindquist form $\\psi(\\mathbf{x}) = 1 + \\tfrac{m_1}{2 r_1} + \\tfrac{m_2}{2 r_2}$, which solves the General Relativity (GR) Hamiltonian constraint with vacuum matter away from the punctures. In the presence of the scalar source, this $\\psi$ is no longer an exact solution; its Hamiltonian residual thus measures the magnitude of the scalar-induced violation for given $\\alpha$.\n- For a widely used orbital-energy proxy in the weak-field circular-orbit limit, the Newtonian GR baseline binding energy of a binary with component masses $m_1$ and $m_2$ and orbital separation $r$ is $E_{\\mathrm{bind}}^{\\mathrm{GR}} = - \\dfrac{m_1 m_2}{2 r}$. A Yukawa correction to the interbody potential of the form $- \\dfrac{m_1 m_2}{r} \\left(1 + \\alpha s_1 s_2 e^{-m_s r}\\right)$ yields a modified binding-energy proxy $E_{\\mathrm{bind}}^{\\mathrm{alt}} = - \\dfrac{m_1 m_2}{2 r} \\left(1 + \\alpha s_1 s_2 e^{-m_s r}\\right)$, giving a relative deviation from the GR baseline\n$$\n\\eta = \\frac{\\left|E_{\\mathrm{bind}}^{\\mathrm{alt}} - E_{\\mathrm{bind}}^{\\mathrm{GR}}\\right|}{\\left|E_{\\mathrm{bind}}^{\\mathrm{GR}}\\right|} = \\left|\\alpha s_1 s_2 e^{-m_s r}\\right|.\n$$\n\nYour tasks:\n1. On a uniform cubic lattice with $N$ points per direction and spacing $h$, centered at the origin and spanning $[-L/2,L/2]^3$, place two sources at $(x,y,z)=(\\pm d/2,0,0)$. Define distances $r_1=\\sqrt{(x-d/2)^2+y^2+z^2}$ and $r_2=\\sqrt{(x+d/2)^2+y^2+z^2}$. Construct the fields\n   - $\\psi(\\mathbf{x}) = 1 + \\dfrac{m_1}{2 r_1} + \\dfrac{m_2}{2 r_2}$,\n   - $\\phi_0(\\mathbf{x}) = s_1 m_1 \\dfrac{e^{-m_s r_1}}{r_1} + s_2 m_2 \\dfrac{e^{-m_s r_2}}{r_2}$.\n   Exclude a small spherical region around each source by masking points where $r_1 < r_{\\mathrm{cut}}$ or $r_2 < r_{\\mathrm{cut}}$ to avoid singularities.\n2. Using second-order centered finite differences on interior points, compute:\n   - The discrete residual of the modified Hamiltonian constraint,\n     $$\n     \\mathcal{R}_H = \\Delta \\psi + 2\\pi \\alpha \\, \\psi^5 \\, E_{\\phi}, \\quad \\text{with} \\quad E_{\\phi} = \\tfrac{1}{2}\\left(|\\nabla \\phi_0|^2 + m_s^2 \\phi_0^2\\right),\n     $$\n     where $\\Delta$ and $\\nabla$ are the flat-space discrete Laplacian and gradient, respectively.\n   - The discrete residual of the homogeneous massive scalar field equation away from sources,\n     $$\n     \\mathcal{R}_{\\phi} = \\Delta \\phi_0 - m_s^2 \\phi_0.\n     $$\n   Compute the $L^2$ norm (root-mean-square over unmasked interior points) of $\\mathcal{R}_H$ and the $L^{\\infty}$ norm (maximum absolute value over unmasked interior points) of $\\mathcal{R}_{\\phi}$.\n3. For a binding-energy proxy at separation $r=d$, compute the relative deviation $\\eta$ from the GR baseline,\n   $$\n   \\eta = \\left|\\alpha s_1 s_2 e^{-m_s d}\\right|.\n   $$\n4. Implement the above for each coupling strength $\\alpha$ in the test suite. Report, for each $\\alpha$, a list containing three floats: $[\\| \\mathcal{R}_H \\|_{L^2}, \\| \\mathcal{R}_{\\phi} \\|_{L^{\\infty}}, \\eta]$. Round each float to $6$ significant digits.\n\nDiscretization details:\n- Use a standard second-order central difference stencil for the Laplacian on interior grid points:\n$$\n\\Delta f\\big|_{i,j,k} \\approx \\frac{f_{i+1,j,k} + f_{i-1,j,k} + f_{i,j+1,k} + f_{i,j-1,k} + f_{i,j,k+1} + f_{i,j,k-1} - 6 f_{i,j,k}}{h^2}.\n$$\n- Use second-order central differences for the gradient components:\n$$\n\\partial_x f\\big|_{i,j,k} \\approx \\frac{f_{i+1,j,k} - f_{i-1,j,k}}{2h}, \\quad \\partial_y f\\big|_{i,j,k} \\approx \\frac{f_{i,j+1,k} - f_{i,j-1,k}}{2h}, \\quad \\partial_z f\\big|_{i,j,k} \\approx \\frac{f_{i,j,k+1} - f_{i,j,k-1}}{2h}.\n$$\n- Compute norms only over interior points $i,j,k \\in \\{2,\\dots,N-1\\}$ (zero-based indexing shifted accordingly) and exclude masked points.\n\nTest suite and parameters:\n- Grid parameters: $N=41$, $L=20$, so that $h=L/(N-1)$.\n- Binary parameters: $m_1=0.8$, $m_2=0.6$, $d=6$.\n- Scalar sector parameters: $s_1=0.3$, $s_2=0.2$, $m_s=0.15$.\n- Mask radius: $r_{\\mathrm{cut}}=0.75$.\n- Coupling strengths to test: $\\alpha \\in \\{0.0, 0.1, 0.5, 2.0, 5.0\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each per-case result is itself a list of three rounded floats in the order $[\\| \\mathcal{R}_H \\|_{L^2}, \\| \\mathcal{R}_{\\phi} \\|_{L^{\\infty}}, \\eta]$. For example, a valid output structure is\n\"[ [a11,a12,a13],[a21,a22,a23],... ]\" with no spaces required; your actual numbers must be rounded to $6$ significant digits and reflect the computations above for the specified test suite and parameters.",
            "solution": "The solution proceeds by implementing the specified tasks algorithmically. All quantities are dimensionless, adhering to geometric units where $G=c=1$.\n\nFirst, we establish the computational domain. A uniform cubic lattice is defined, centered at the origin and spanning the volume $[-L/2, L/2]^3$, with $N=41$ points in each direction. The grid spacing is therefore $h = L/(N-1) = 20/40 = 0.5$. Three-dimensional coordinate arrays $\\mathbf{x}_{ijk}=(x_i, y_j, z_k)$ are generated for all points on this lattice.\n\nNext, we discretize the physical fields. The two sources, with masses $m_1=0.8$ and $m_2=0.6$, are placed at positions $\\mathbf{x}_1 = (d/2, 0, 0)$ and $\\mathbf{x}_2 = (-d/2, 0, 0)$, where the separation is $d=6$. For each grid point $\\mathbf{x}_{ijk}$, we compute the Euclidean distances to the sources:\n$$\nr_1(\\mathbf{x}_{ijk}) = \\sqrt{(x_i - d/2)^2 + y_j^2 + z_k^2}\n$$\n$$\nr_2(\\mathbf{x}_{ijk}) = \\sqrt{(x_i + d/2)^2 + y_j^2 + z_k^2}\n$$\nUsing these distances, we construct the discrete scalar field $\\phi_0$ and the conformal factor $\\psi$ at each grid point according to the provided proxy formulas:\n$$\n\\phi_0(\\mathbf{x}_{ijk}) = s_1 m_1 \\frac{e^{-m_s r_1}}{r_1} + s_2 m_2 \\frac{e^{-m_s r_2}}{r_2}\n$$\n$$\n\\psi(\\mathbf{x}_{ijk}) = 1 + \\frac{m_1}{2 r_1} + \\frac{m_2}{2 r_2}\n$$\nHere, the scalar parameters are $s_1=0.3$, $s_2=0.2$, and $m_s=0.15$. At the singularity locations where $r_1=0$ or $r_2=0$, the expressions diverge. These points are handled by ensuring they are excluded from all subsequent calculations by a mask.\n\nTo compute the residuals, we require discrete differential operators. We implement the second-order central difference stencils for the flat-space gradient $\\nabla_h$ and Laplacian $\\Delta_h$. For a generic discrete field $f_{ijk}$ on our grid, these are:\n$$\n(\\nabla_h f)_{x, ijk} = \\frac{f_{i+1,j,k} - f_{i-1,j,k}}{2h}\n$$\n$$\n\\Delta_h f_{ijk} = \\frac{f_{i+1,j,k} + f_{i-1,j,k} + f_{i,j+1,k} + f_{i,j-1,k} + f_{i,j,k+1} + f_{i,j,k-1} - 6 f_{i,j,k}}{h^2}\n$$\nThese operators are applied to the discrete fields $\\psi$ and $\\phi_0$ to obtain their derivatives $\\Delta_h \\psi$, $\\Delta_h \\phi_0$, and $\\nabla_h \\phi_0$.\n\nWith the derivatives computed, we formulate the residuals. The residual of the homogeneous scalar field equation, $\\mathcal{R}_{\\phi}$, is computed once, as it is independent of the coupling strength $\\alpha$:\n$$\n\\mathcal{R}_{\\phi} = \\Delta_h \\phi_0 - m_s^2 \\phi_0\n$$\nThe Hamiltonian constraint residual, $\\mathcal{R}_H$, depends on $\\alpha$ and is computed for each specified value in the test suite. It is given by:\n$$\n\\mathcal{R}_H = \\Delta_h \\psi + 2\\pi \\alpha \\, \\psi^5 \\, E_{\\phi}\n$$\nwhere the scalar energy density $E_{\\phi}$ is:\n$$\nE_{\\phi} = \\frac{1}{2}\\left(|\\nabla_h \\phi_0|^2 + m_s^2 \\phi_0^2\\right)\n$$\n\nThe norms of these residuals are calculated over a specific subset of grid points. The problem mandates using \"unmasked interior points\". This means we select points that satisfy two conditions:\n1. They are interior to the grid, i.e., their indices $(i,j,k)$ are in the range $\\{1, \\dots, N-2\\}$ (for 0-based indexing).\n2. They are not 'masked', i.e., their distance to either source is not less than the cutoff radius $r_{\\text{cut}}=0.75$.\nLet $\\mathcal{V}$ be the set of grid points satisfying these conditions. The norms are then computed as:\n$$\n\\| \\mathcal{R}_{\\phi} \\|_{L^{\\infty}} = \\max_{\\mathbf{x}_{ijk} \\in \\mathcal{V}} |\\mathcal{R}_{\\phi}(\\mathbf{x}_{ijk})|\n$$\n$$\n\\| \\mathcal{R}_H \\|_{L^2} = \\sqrt{\\frac{1}{|\\mathcal{V}|} \\sum_{\\mathbf{x}_{ijk} \\in \\mathcal{V}} |\\mathcal{R}_H(\\mathbf{x}_{ijk})|^2}\n$$\nwhere $|\\mathcal{V}|$ is the number of points in the set $\\mathcal{V}$.\n\nFinally, for each value of $\\alpha$, we compute the relative deviation of the binding-energy proxy, $\\eta$, from the General Relativistic baseline:\n$$\n\\eta = \\left|\\alpha s_1 s_2 e^{-m_s d}\\right|\n$$\nThis calculation is performed for each $\\alpha \\in \\{0.0, 0.1, 0.5, 2.0, 5.0\\}$. The resulting triplet of values, $[\\| \\mathcal{R}_H \\|_{L^2}, \\| \\mathcal{R}_{\\phi} \\|_{L^{\\infty}}, \\eta]$, is collected for each $\\alpha$, and each numerical value is rounded to $6$ significant figures before being formatted into the final output structure.",
            "answer": "```python\nimport numpy as np\n\nclass NoSpaceList(list):\n    \"\"\"\n    A list subclass that overrides __str__ to produce a comma-separated string\n    representation without spaces, with each element formatted to 6 significant figures.\n    \"\"\"\n    def __str__(self):\n        # The :.6g format specifier automatically handles rounding to 6 significant digits.\n        formatted_items = [f'{item:.6g}' for item in self]\n        return '[' + ','.join(formatted_items) + ']'\n\ndef solve():\n    \"\"\"\n    Computes constraint residuals and binding energy deviation for a binary\n    system in a scalar-tensor theory of gravity.\n    \"\"\"\n    # Define physical and numerical parameters from the problem statement\n    N = 41\n    L = 20.0\n    m1, m2 = 0.8, 0.6\n    d = 6.0\n    s1, s2 = 0.3, 0.2\n    ms = 0.15\n    r_cut = 0.75\n    alphas = [0.0, 0.1, 0.5, 2.0, 5.0]\n\n    # Set up the computational grid\n    h = L / (N - 1)\n    coords = np.linspace(-L / 2, L / 2, N)\n    # Use 'ij' indexing so that axis 0 corresponds to x, 1 to y, and 2 to z\n    X, Y, Z = np.meshgrid(coords, coords, coords, indexing='ij')\n\n    # Define source locations\n    x1, y1, z1 = d / 2, 0.0, 0.0\n    x2, y2, z2 = -d / 2, 0.0, 0.0\n\n    # Calculate Euclidean distances to each source for all grid points\n    r1 = np.sqrt((X - x1)**2 + (Y - y1)**2 + (Z - z1)**2)\n    r2 = np.sqrt((X - x2)**2 + (Y - y2)**2 + (Z - z2)**2)\n\n    # Construct the proxy fields: conformal factor psi and scalar field phi0\n    # Use np.divide with a 'where' clause to handle division by zero at the\n    # source locations. The results at these points will be masked out later.\n    psi = 1.0\n    psi += np.divide(m1, 2 * r1, out=np.zeros_like(r1), where=(r1 != 0))\n    psi += np.divide(m2, 2 * r2, out=np.zeros_like(r2), where=(r2 != 0))\n    \n    phi0 = np.zeros_like(r1)\n    phi0 += np.divide(s1 * m1 * np.exp(-ms * r1), r1, out=np.zeros_like(r1), where=(r1 != 0))\n    phi0 += np.divide(s2 * m2 * np.exp(-ms * r2), r2, out=np.zeros_like(r2), where=(r2 != 0))\n\n    # Define second-order finite difference operators using numpy.roll for efficiency\n    def laplacian(f, h_grid):\n        lap = -6.0 * f\n        lap += np.roll(f, 1, axis=0) + np.roll(f, -1, axis=0)\n        lap += np.roll(f, 1, axis=1) + np.roll(f, -1, axis=1)\n        lap += np.roll(f, 1, axis=2) + np.roll(f, -1, axis=2)\n        return lap / h_grid**2\n\n    def gradient(f, h_grid):\n        grad_x = (np.roll(f, -1, axis=0) - np.roll(f, 1, axis=0)) / (2 * h_grid)\n        grad_y = (np.roll(f, -1, axis=1) - np.roll(f, 1, axis=1)) / (2 * h_grid)\n        grad_z = (np.roll(f, -1, axis=2) - np.roll(f, 1, axis=2)) / (2 * h_grid)\n        return grad_x, grad_y, grad_z\n\n    # Compute spatial derivatives of the fields\n    lap_psi = laplacian(psi, h)\n    lap_phi0 = laplacian(phi0, h)\n    grad_phi0_x, grad_phi0_y, grad_phi0_z = gradient(phi0, h)\n    grad_phi0_sq = grad_phi0_x**2 + grad_phi0_y**2 + grad_phi0_z**2\n    \n    # Define the mask for valid points for norm calculation\n    # 1. Interior points (not on the grid boundary)\n    interior_mask = np.zeros_like(X, dtype=bool)\n    interior_mask[1:-1, 1:-1, 1:-1] = True\n    # 2. Points outside the excision radius (r_cut)\n    puncture_mask = (r1 < r_cut) | (r2 < r_cut)\n    # The final selection mask combines these conditions\n    selection_mask = interior_mask & ~puncture_mask\n\n    # Calculate the scalar field residual and its norm (independent of alpha)\n    R_phi = lap_phi0 - ms**2 * phi0\n    R_phi_valid = R_phi[selection_mask]\n    \n    if R_phi_valid.size == 0:\n        norm_R_phi_Linf = 0.0\n    else:\n        norm_R_phi_Linf = np.max(np.abs(R_phi_valid))\n\n    # Iterate through coupling strengths to compute residuals and binding energy\n    all_results = []\n    for alpha in alphas:\n        # Calculate the scalar energy density E_phi\n        E_phi = 0.5 * (grad_phi0_sq + ms**2 * phi0**2)\n        # Calculate the Hamiltonian constraint residual R_H\n        R_H = lap_psi + 2 * np.pi * alpha * (psi**5) * E_phi\n        \n        # Select valid points for the norm calculation\n        R_H_valid = R_H[selection_mask]\n        \n        # Calculate the L2 (RMS) norm of the Hamiltonian residual\n        if R_H_valid.size == 0:\n            norm_R_H_L2 = 0.0\n        else:\n            norm_R_H_L2 = np.sqrt(np.mean(R_H_valid**2))\n        \n        # Calculate the relative deviation of the binding energy proxy\n        eta = np.abs(alpha * s1 * s2 * np.exp(-ms * d))\n\n        # Store the triplet of results in a list that will format itself correctly\n        all_results.append(NoSpaceList([norm_R_H_L2, norm_R_phi_Linf, eta]))\n\n    # Print the final output in the specified format \"[[...],[...],...]\"\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}