{
    "hands_on_practices": [
        {
            "introduction": "The process of creating a hybrid waveform requires smoothly joining a Post-Newtonian (PN) inspiral to a Numerical Relativity (NR) merger-ringdown. This \"stitching\" is typically performed in a time-domain window using a tapering function that transitions from the PN to the NR model. This practice explores how this blending procedure, while necessary, can introduce unphysical artifacts in the frequency domain known as spectral leakage. By implementing a simplified hybridization and performing a Fourier analysis, you will directly compare how different common taper functions perform at minimizing these unwanted effects, providing fundamental insight into the signal processing challenges of waveform construction .",
            "id": "3477286",
            "problem": "Consider the construction of a Post-Newtonian–Numerical Relativity (PN–NR) hybrid gravitational waveform for a non-spinning, quasi-circular binary coalescence using a fixed matching window where the two time-domain waveforms are blended by a monotonic taper weight. Let the hybridization be performed on a simplified segment in which the instantaneous gravitational-wave frequency is approximately constant across the matching window, justified by the smallness of the relative frequency drift over short durations for adiabatic inspiral. Let the PN and NR segments be modeled as sinusoidal strains with a small amplitude and phase offset: the Post-Newtonian segment is $h_{\\mathrm{PN}}(t) = A_0 \\cos(2 \\pi f_0 t)$ and the Numerical Relativity segment is $h_{\\mathrm{NR}}(t) = A_0(1+\\delta A)\\cos(2 \\pi f_0 t + \\delta \\phi)$, where $A_0$ is dimensionless strain amplitude, $f_0$ is the gravitational-wave frequency in $\\mathrm{Hz}$, $\\delta A$ is dimensionless, and $\\delta \\phi$ is in radians.\n\nDefine a matching window starting at time $t_m$ of duration $\\tau$, both in $\\mathrm{s}$. The hybrid waveform $h_{\\mathrm{hyb}}(t)$ is constructed by\n- $h_{\\mathrm{hyb}}(t) = h_{\\mathrm{PN}}(t)$ for $t < t_m$,\n- $h_{\\mathrm{hyb}}(t) = (1 - w(x)) h_{\\mathrm{PN}}(t) + w(x) h_{\\mathrm{NR}}(t)$ for $t_m \\le t < t_m + \\tau$, where $x = (t - t_m)/\\tau \\in [0,1]$,\n- $h_{\\mathrm{hyb}}(t) = h_{\\mathrm{NR}}(t)$ for $t \\ge t_m + \\tau$.\n\nThe taper weight $w(x)$ is chosen from three options:\n- Hann raised-cosine taper: \n$$w_{\\mathrm{Hann}}(x) = \\frac{1}{2}\\left(1 - \\cos(\\pi x)\\right) \\quad \\text{for } x \\in [0,1].$$\n- Tukey-like monotonic taper as a convex combination of linear and raised-cosine profiles with parameter $\\alpha \\in [0,1]$: \n$$w_{\\mathrm{Tukey}}(x; \\alpha) = (1 - \\alpha) x + \\alpha \\, \\frac{1}{2}\\left(1 - \\cos(\\pi x)\\right) \\quad \\text{for } x \\in [0,1].$$\n- Planck taper with steepness parameter $\\varepsilon > 0$: \n$$w_{\\mathrm{Planck}}(x; \\varepsilon) = \\left[1 + \\exp\\!\\left(\\varepsilon\\left(\\frac{1}{x} - \\frac{1}{1-x}\\right)\\right)\\right]^{-1} \\quad \\text{for } x \\in (0,1),$$\n and limits $w_{\\mathrm{Planck}}(0;\\varepsilon)=0$, $w_{\\mathrm{Planck}}(1;\\varepsilon)=1$.\n\nLet the time series be sampled at rate $f_s$ in $\\mathrm{Hz}$ over a total duration $T$ in $\\mathrm{s}$, with $N = \\lfloor f_s T \\rfloor$ samples and discrete times $t_n = n/f_s$ for $n=0,1,\\dots,N-1$. Define the one-sided discrete Fourier transform $\\tilde{h}(f_k)$ via the real-valued Fast Fourier Transform with frequencies $f_k = k \\Delta f$ where $\\Delta f = f_s/N$ and $k=0,1,\\dots,\\lfloor N/2 \\rfloor$.\n\nSpectral leakage is induced by the time-localized amplitude and phase modulation introduced by $w(x)$ in the matching window, which, through multiplication in the time domain, corresponds to convolution of spectra in the frequency domain. Quantify leakage by the peak side-lobe ratio,\n$$\n\\mathcal{L} = \\frac{\\max_{k \\in \\mathcal{K}_{\\mathrm{out}}} \\left| \\tilde{h}(f_k) \\right|}{\\max_{k \\in \\mathcal{K}_{\\mathrm{main}}} \\left| \\tilde{h}(f_k) \\right|},\n$$\nwhere $\\mathcal{K}_{\\mathrm{main}}$ is the set of indices within $\\pm K$ bins of the target frequency $f_0$ (inclusive), and $\\mathcal{K}_{\\mathrm{out}}$ is the complement of $\\mathcal{K}_{\\mathrm{main}}$ in the one-sided spectrum excluding $k=0$. Use $K=2$.\n\nYour task is to implement a program that, for each test case below, constructs $h_{\\mathrm{hyb}}(t)$ using each taper $w(x)$, computes $\\left|\\tilde{h}(f)\\right|$, evaluates $\\mathcal{L}$, and determines which taper minimizes the side-lobe levels (i.e., minimizes $\\mathcal{L}$). Map the taper choices to integer codes: Hann $\\rightarrow 0$, Tukey $\\rightarrow 1$, Planck $\\rightarrow 2$.\n\nUse the following test suite, with all quantities in the specified units:\n- Test case $1$ (happy path): $f_s = 4096\\,\\mathrm{Hz}$, $T = 1.0\\,\\mathrm{s}$, $f_0 = 128\\,\\mathrm{Hz}$, $t_m = 0.4\\,\\mathrm{s}$, $\\tau = 0.2\\,\\mathrm{s}$, $A_0 = 1.0$, $\\delta A = 0.05$, $\\delta \\phi = 0.2$ radians, Tukey parameter $\\alpha = 0.5$, Planck parameter $\\varepsilon = 0.1$.\n- Test case $2$ (boundary: very short matching window of one cycle): $f_s = 2048\\,\\mathrm{Hz}$, $T = 1.0\\,\\mathrm{s}$, $f_0 = 64\\,\\mathrm{Hz}$, $t_m = 0.5\\,\\mathrm{s}$, $\\tau = 1/64\\,\\mathrm{s}$, $A_0 = 1.0$, $\\delta A = 0.05$, $\\delta \\phi = 0.4$ radians, $\\alpha = 0.5$, $\\varepsilon = 0.1$.\n- Test case $3$ (edge: steep transition sensitivity): $f_s = 8192\\,\\mathrm{Hz}$, $T = 1.0\\,\\mathrm{s}$, $f_0 = 256\\,\\mathrm{Hz}$, $t_m = 0.3\\,\\mathrm{s}$, $\\tau = 0.1\\,\\mathrm{s}$, $A_0 = 1.0$, $\\delta A = 0.10$, $\\delta \\phi = 0.3$ radians, $\\alpha = 0.1$, $\\varepsilon = 0.05$.\n\nAngle units must be in radians. Frequencies must be in $\\mathrm{Hz}$. Time must be in $\\mathrm{s}$. Amplitudes are dimensionless. Express all computed leakage ratios $\\mathcal{L}$ internally as decimal floats.\n\nFinal output format: Your program should produce a single line of output containing the integer codes for the taper that minimizes side-lobe levels for each test case, in order, as a comma-separated list enclosed in square brackets (e.g., $\\left[0,1,2\\right]$). The program must run without any external input and must adhere to the specified runtime environment.",
            "solution": "The problem presented is a valid and well-posed exercise in signal processing, grounded in the context of gravitational-wave data analysis. Specifically, it addresses the construction of hybrid waveforms, a standard technique in numerical relativity and gravitational-wave physics to combine analytical Post-Newtonian (PN) inspiral waveforms with full numerical relativity (NR) simulations of a binary's merger and ringdown. The problem is a simplified but conceptually sound model to study the spectral artifacts introduced by this hybridization process.\n\nThe solution proceeds algorithmically by first constructing the time-domain hybrid waveform $h_{\\mathrm{hyb}}(t)$ for each specified tapering function. Subsequently, we perform a spectral analysis using the Fast Fourier Transform (FFT) to quantify the spectral leakage, a measure of the spurious spread of power to frequencies adjacent to the signal's central frequency. The taper that results in the minimum leakage is deemed optimal for the given parameters.\n\n**1. Waveform and Hybridization Model**\n\nThe problem provides simplified, single-frequency models for the PN and NR waveforms.\nThe PN waveform is given by:\n$$h_{\\mathrm{PN}}(t) = A_0 \\cos(2 \\pi f_0 t)$$\nThe NR waveform is given by:\n$$h_{\\mathrm{NR}}(t) = A_0(1+\\delta A)\\cos(2 \\pi f_0 t + \\delta \\phi)$$\nHere, $A_0$ is the nominal amplitude, $f_0$ is the frequency, $\\delta A$ is the fractional amplitude difference, and $\\delta \\phi$ is the phase difference between the two models. These differences, $\\delta A$ and $\\delta \\phi$, represent the mismatches that hybridization aims to reconcile.\n\nThe hybrid waveform $h_{\\mathrm{hyb}}(t)$ is constructed in three segments over the total duration $T$:\n-   For $t < t_m$, the waveform is purely PN: $h_{\\mathrm{hyb}}(t) = h_{\\mathrm{PN}}(t)$.\n-   For $t \\ge t_m + \\tau$, the waveform is purely NR: $h_{\\mathrm{hyb}}(t) = h_{\\mathrm{NR}}(t)$.\n-   In the matching window $t_m \\le t < t_m + \\tau$, the two are blended:\n    $$h_{\\mathrm{hyb}}(t) = (1 - w(x)) h_{\\mathrm{PN}}(t) + w(x) h_{\\mathrm{NR}}(t)$$\n    where $x = (t - t_m)/\\tau$ is a normalized time variable that maps the interval $[t_m, t_m+\\tau)$ to $[0, 1)$. The function $w(x)$ is a monotonic tapering function, or window, that smoothly transitions from $w(0)=0$ to $w(1)=1$.\n\n**2. Tapering Functions**\n\nThe choice of $w(x)$ is critical for minimizing discontinuities and their spectral consequences. The problem specifies three options:\n\n-   **Hann Taper**: A raised-cosine function, widely used in signal processing.\n    $$w_{\\mathrm{Hann}}(x) = \\frac{1}{2}\\left(1 - \\cos(\\pi x)\\right), \\quad x \\in [0,1]$$\n-   **Tukey-like Taper**: A convex combination of a linear ramp and a Hann taper, controlled by a parameter $\\alpha \\in [0,1]$.\n    $$w_{\\mathrm{Tukey}}(x; \\alpha) = (1 - \\alpha) x + \\alpha \\, \\frac{1}{2}\\left(1 - \\cos(\\pi x)\\right), \\quad x \\in [0,1]$$\n-   **Planck Taper**: A function with parameter $\\varepsilon > 0$ that allows for a very flat profile at $x=0$ and $x=1$, providing an extremely smooth transition.\n    $$w_{\\mathrm{Planck}}(x; \\varepsilon) = \\left[1 + \\exp\\!\\left(\\varepsilon\\left(\\frac{1}{x} - \\frac{1}{1-x}\\right)\\right)\\right]^{-1}, \\quad x \\in (0,1)$$\n    with the limits $w_{\\mathrm{Planck}}(0;\\varepsilon)=0$ and $w_{\\mathrm{Planck}}(1;\\varepsilon)=1$.\n\nThe blending in the matching window can be rewritten as $h_{\\mathrm{hyb}}(t) = h_{\\mathrm{PN}}(t) + w(x) (h_{\\mathrm{NR}}(t) - h_{\\mathrm{PN}}(t))$. This shows that the hybridization process effectively adds a time-localized \"correction\" signal, $w(x) (h_{\\mathrm{NR}}(t) - h_{\\mathrm{PN}}(t))$, to the PN waveform. Multiplication in the time domain corresponds to convolution in the frequency domain. The spectrum of this correction signal, which is influenced by the spectrally-broad window function $w(x)$, convolves with the spectra of $h_{\\mathrm{PN}}$ and $h_{\\mathrm{NR}}$, spreading power into adjacent frequency bins. This is a classic source of spectral leakage.\n\n**3. Spectral Leakage Quantification**\n\nTo quantify this effect, we use the one-sided discrete Fourier transform $\\tilde{h}(f_k)$ of the time series $h_{\\mathrm{hyb}}(t_n)$, where $t_n=n/f_s$. The peak side-lobe ratio, $\\mathcal{L}$, is defined as:\n$$\n\\mathcal{L} = \\frac{\\max_{k \\in \\mathcal{K}_{\\mathrm{out}}} \\left| \\tilde{h}(f_k) \\right|}{\\max_{k \\in \\mathcal{K}_{\\mathrm{main}}} \\left| \\tilde{h}(f_k) \\right|}\n$$\nThe main lobe, $\\mathcal{K}_{\\mathrm{main}}$, is defined as the frequency bins within $K=2$ bins of the central frequency $f_0$. The side-lobe region, $\\mathcal{K}_{\\mathrm{out}}$, comprises all other frequency bins in the one-sided spectrum, excluding the DC component ($k=0$). A smaller $\\mathcal{L}$ indicates less spectral leakage and a better-behaved hybridization.\n\n**4. Algorithmic Implementation**\n\nFor each test case, the following procedure is executed:\n1.  Discretize the time axis: an array of $N = \\lfloor f_s T \\rfloor$ points $t_n = n/f_s$ is generated.\n2.  For each of the three tapering functions (Hann, Tukey-like, Planck):\n    a.  Construct the full hybrid waveform $h_{\\mathrm{hyb}}(t_n)$ by identifying the indices corresponding to the pre-matching, matching, and post-matching regions and applying the appropriate formula. For the Planck taper, care must be taken at the boundaries $x=0$ and $x=1$ to avoid numerical errors, as specified by the problem's limit definitions.\n    b.  Compute the one-sided FFT of $h_{\\mathrm{hyb}}(t_n)$ using a real FFT algorithm, yielding the complex-valued spectrum $\\tilde{h}(f_k)$.\n    c.  Identify the frequency bin $k_0$ corresponding to $f_0$.\n    d.  Determine the set of main-lobe bins $\\mathcal{K}_{\\mathrm{main}}$ (indices from $k_0-K$ to $k_0+K$) and side-lobe bins $\\mathcal{K}_{\\mathrm{out}}$.\n    e.  Calculate the maximum magnitude in each region and compute their ratio to find $\\mathcal{L}$.\n3.  The values of $\\mathcal{L}$ for the three tapers are compared. The taper corresponding to the minimum $\\mathcal{L}$ is selected, and its integer code (Hann: $0$, Tukey: $1$, Planck: $2$) is recorded.\n4.  This process is repeated for all test cases, and the final list of optimal taper codes is formatted and printed.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the hybrid waveform spectral leakage problem for all test cases.\n    \"\"\"\n    # Test cases as provided in the problem statement.\n    test_cases = [\n        # (fs, T, f0, tm, tau, A0, deltaA, delta_phi, alpha, epsilon)\n        (4096, 1.0, 128, 0.4, 0.2, 1.0, 0.05, 0.2, 0.5, 0.1),\n        (2048, 1.0, 64, 0.5, 1/64, 1.0, 0.05, 0.4, 0.5, 0.1),\n        (8192, 1.0, 256, 0.3, 0.1, 1.0, 0.10, 0.3, 0.1, 0.05),\n    ]\n\n    # Map taper names to their integer codes for the final output.\n    TAPER_CODES = {'Hann': 0, 'Tukey': 1, 'Planck': 2}\n    TAPER_ORDER = ['Hann', 'Tukey', 'Planck']\n    \n    final_results = []\n\n    for case in test_cases:\n        fs, T, f0, tm, tau, A0, deltaA, delta_phi, alpha, epsilon = case\n        K = 2  # Width of the main lobe in bins, as per problem.\n\n        # 1. Time-Domain Waveform Construction\n        N = int(fs * T)\n        t = np.arange(N) / fs\n\n        h_pn = A0 * np.cos(2 * np.pi * f0 * t)\n        h_nr = A0 * (1 + deltaA) * np.cos(2 * np.pi * f0 * t + delta_phi)\n\n        mask_pre = t < tm\n        mask_window = (t >= tm) & (t < tm + tau)\n        mask_post = t >= tm + tau\n        \n        # Normalized time in the window\n        t_window = t[mask_window]\n        x_window = (t_window - tm) / tau\n\n        # 2. Tapering Functions\n        def hann_taper(x):\n            return 0.5 * (1 - np.cos(np.pi * x))\n\n        def tukey_like_taper(x, alpha_param):\n            return (1 - alpha_param) * x + alpha_param * hann_taper(x)\n\n        def planck_taper(x, epsilon_param):\n            w = np.zeros_like(x, dtype=float)\n            \n            # Masks for boundaries and the middle part\n            mask_mid = (x > 0) & (x < 1)\n            \n            # Calculate for the middle part where x is in (0, 1)\n            x_mid = x[mask_mid]\n            # Numpy's float mechanics handle large exponents correctly:\n            # exp(large_pos) -> inf, and 1/(1+inf) -> 0.0\n            # exp(large_neg) -> 0.0, and 1/(1+0) -> 1.0\n            arg = epsilon_param * (1.0/x_mid - 1.0/(1.0 - x_mid))\n            w[mask_mid] = 1.0 / (1.0 + np.exp(arg))\n            \n            # Apply hard-coded boundary conditions from the problem statement\n            w[x == 0] = 0.0\n            w[x >= 1] = 1.0\n            \n            return w\n\n        taper_funcs = {\n            'Hann': lambda x: hann_taper(x),\n            'Tukey': lambda x: tukey_like_taper(x, alpha),\n            'Planck': lambda x: planck_taper(x, epsilon),\n        }\n\n        leakages = []\n\n        for taper_name in TAPER_ORDER:\n            # Generate the taper weight for the window\n            w = taper_funcs[taper_name](x_window)\n            \n            # Construct the hybrid waveform\n            h_hyb = np.zeros(N)\n            h_hyb[mask_pre] = h_pn[mask_pre]\n            h_hyb[mask_post] = h_nr[mask_post]\n            h_hyb[mask_window] = (1 - w) * h_pn[mask_window] + w * h_nr[mask_window]\n\n            # 3. Spectral Leakage Quantification\n            leakage = calculate_leakage(h_hyb, N, fs, f0, K)\n            leakages.append(leakage)\n\n        # 4. Determine which taper minimizes leakage\n        best_taper_index = np.argmin(leakages)\n        best_taper_name = TAPER_ORDER[best_taper_index]\n        final_results.append(TAPER_CODES[best_taper_name])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\n\ndef calculate_leakage(h, N, fs, f0, K):\n    \"\"\"\n    Calculates the peak side-lobe ratio for a given time-domain signal.\n\n    Args:\n        h (np.ndarray): The time-domain signal.\n        N (int): The number of samples in the signal.\n        fs (float): The sampling rate.\n        f0 (float): The target central frequency.\n        K (int): The half-width of the main-lobe region in frequency bins.\n\n    Returns:\n        float: The calculated peak side-lobe ratio.\n    \"\"\"\n    # Compute the one-sided real FFT\n    h_fft = np.fft.rfft(h)\n    fft_mags = np.abs(h_fft)\n    freqs = np.fft.rfftfreq(N, d=1/fs)\n    N_fft = len(freqs)\n\n    # Find the index corresponding to the target frequency f0\n    k0 = np.argmin(np.abs(freqs - f0))\n\n    # Define main lobe and side lobe regions\n    main_lobe_start = max(0, k0 - K)\n    main_lobe_end = min(N_fft - 1, k0 + K)\n\n    main_lobe_max = np.max(fft_mags[main_lobe_start:main_lobe_end + 1])\n    \n    if main_lobe_max == 0:\n        return np.inf  # Avoid division by zero\n\n    # Create a mask for the side-lobe region\n    sidelobe_mask = np.ones(N_fft, dtype=bool)\n    # Exclude DC component\n    sidelobe_mask[0] = False\n    # Exclude the main lobe\n    sidelobe_mask[main_lobe_start:main_lobe_end + 1] = False\n    \n    # If no side-lobes exist (e.g., very coarse spectrum), leakage is zero\n    if not np.any(sidelobe_mask):\n        return 0.0\n\n    sidelobe_max = np.max(fft_mags[sidelobe_mask])\n\n    return sidelobe_max / main_lobe_max\n\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond the mechanics of blending waveforms, a critical strategic decision is choosing *where* to perform the hybridization. This choice represents a delicate trade-off: at low frequencies (early in the inspiral), the analytical PN model is highly accurate, but its errors accumulate and grow towards the merger. Conversely, full NR simulations are essential for the late-inspiral and merger but are computationally expensive and can suffer from their own numerical error sources. This exercise models this fundamental trade-off by positing simple, physically motivated error models for both PN and NR waveforms, allowing you to calculate the optimal matching frequency where their errors are equal and investigate how this sweet spot depends on the binary's mass ratio $q$ .",
            "id": "3477332",
            "problem": "You are tasked with constructing a simple, principled model to estimate the optimal post-Newtonian (PN)–numerical relativity (NR) hybridization frequency by equating a modeled PN phase truncation error with a modeled NR phase error. The purpose is to analyze how increasing the mass ratio pushes the matching window to lower frequencies. You must implement a program that, using the model below, computes the frequency (in Hertz) where the PN phase error equals the NR phase error for three mass ratios and tests the monotonic trend with mass ratio. All physical constants and units must be applied exactly as specified, and the final output format must match exactly the required specification.\n\nFundamental base and modeling assumptions:\n- For quasi-circular inspirals, the orbital speed parameter $v$ relates to the gravitational-wave frequency via $v = (\\pi M f)^{1/3}$, where $M$ is the total mass (in seconds when $G=c=1$) and $f$ is the observed frequency (in Hertz). This follows from the balance law and the leading-order circular-orbit relation connecting phase evolution to velocity, together with the stationary phase approximation connecting orbital and gravitational-wave frequencies.\n- The leading post-Newtonian (PN) phase truncation error scales as a positive power of $v$, representing the dominant missing higher-order term beyond the truncation. For a missing term at effective power $v^{8}$, model the PN phase error by\n$$\n\\Delta \\Phi_{\\text{PN}}(f,q) = A_0 \\left[1 + a_1 \\bigl(1 - 4\\eta(q)\\bigr)^2\\right] \\left(\\pi M f\\right)^{8/3},\n$$\nwhere $q \\ge 1$ is the mass ratio, $\\eta(q) = \\frac{q}{(1+q)^2}$ is the symmetric mass ratio, and $A_0$ and $a_1$ are positive constants.\n- The numerical relativity (NR) phase error increases toward merger and grows with mass ratio due to higher resolution demands. Model it as\n$$\n\\Delta \\Phi_{\\text{NR}}(f,q) = B_0 \\left[1 + b_1 \\frac{q-1}{q+1}\\right] \\left(M f\\right)^{\\beta},\n$$\nwith $\\beta = 1$, and $B_0$, $b_1$ positive constants. This captures a monotonic increase of NR phase uncertainty with frequency and with mass ratio.\n- For the purposes of this problem, use the following fixed constants:\n  - Total mass $M = 60\\,M_\\odot$, converted to seconds using $1\\,M_\\odot = 4.92549095\\times 10^{-6}\\,\\mathrm{s}$ in geometrized units, so $M = 60 \\times 4.92549095\\times 10^{-6}\\,\\mathrm{s}$.\n  - Coefficients $A_0 = 0.03125$, $a_1 = 6.0$, $B_0 = 0.001$, $b_1 = 0.5$, and $\\beta = 1$.\n- Assume non-spinning binaries and quasi-circular inspirals.\n\nTask:\n- For each mass ratio $q \\in \\{1,3,8\\}$, compute the frequency $f_{\\text{match}}(q)$ where the equality\n$$\n\\Delta \\Phi_{\\text{PN}}(f,q) = \\Delta \\Phi_{\\text{NR}}(f,q)\n$$\nholds. Solve for $f$ numerically on the interval $[f_{\\min}, f_{\\max}] = [10\\,\\mathrm{Hz}, 400\\,\\mathrm{Hz}]$. If no solution exists in this interval, return $\\mathrm{NaN}$ for that case.\n- Express all returned frequencies in $\\mathrm{Hz}$, rounded to three decimal places.\n- Also compute a boolean indicating whether the optimal matching frequency decreases strictly with increasing mass ratio, i.e., whether $f_{\\text{match}}(1) > f_{\\text{match}}(3) > f_{\\text{match}}(8)$.\n- Also compute a boolean indicating whether all three solutions lie within the closed interval $[10\\,\\mathrm{Hz}, 400\\,\\mathrm{Hz}]$.\n\nTest suite:\n- Use the three mass ratios $q \\in \\{1,3,8\\}$ as the primary test cases.\n- The monotonicity check $f_{\\text{match}}(1) > f_{\\text{match}}(3) > f_{\\text{match}}(8)$ provides a coverage check that probes the effect of increasing $q$.\n- The in-band check that all $f_{\\text{match}}(q)$ lie in $[10\\,\\mathrm{Hz}, 400\\,\\mathrm{Hz}]$ provides a boundary-condition check for the numerical root finder on the specified interval.\n\nFinal output format:\n- Your program must print a single line containing a Python-style list with no spaces, aggregating the results in the following order:\n  1. $f_{\\text{match}}(1)$ in $\\mathrm{Hz}$, rounded to three decimal places,\n  2. $f_{\\text{match}}(3)$ in $\\mathrm{Hz}$, rounded to three decimal places,\n  3. $f_{\\text{match}}(8)$ in $\\mathrm{Hz}$, rounded to three decimal places,\n  4. a boolean for the strict monotonic decrease with increasing $q$,\n  5. a boolean for the in-band check that all three frequencies are in $[10\\,\\mathrm{Hz}, 400\\,\\mathrm{Hz}]$.\n- Example format: $[68.700,65.000,41.400,True,True]$.",
            "solution": "The user has provided a problem that is scientifically sound, well-posed, and objective. It models a common task in gravitational-wave physics: the hybridization of post-Newtonian (PN) and numerical relativity (NR) waveforms. The provided models for phase error, while simplified, are physically motivated and mathematically consistent. All constants and parameters are clearly defined, and the tasks are specified without ambiguity. The problem is therefore deemed valid and a solution will be provided.\n\nThe core of the problem is to find the gravitational-wave frequency $f$ at which the modeled PN phase error, $\\Delta \\Phi_{\\text{PN}}(f,q)$, equals the modeled NR phase error, $\\Delta \\Phi_{\\text{NR}}(f,q)$, for a given mass ratio $q$. This frequency, $f_{\\text{match}}(q)$, represents an optimal point to switch from the PN approximation to the full NR solution.\n\nThe two error models are given as:\n$$\n\\Delta \\Phi_{\\text{PN}}(f,q) = A_0 \\left[1 + a_1 \\bigl(1 - 4\\eta(q)\\bigr)^2\\right] \\left(\\pi M f\\right)^{8/3}\n$$\n$$\n\\Delta \\Phi_{\\text{NR}}(f,q) = B_0 \\left[1 + b_1 \\frac{q-1}{q+1}\\right] \\left(M f\\right)^{\\beta}\n$$\nwhere $\\beta = 1$. The symmetric mass ratio is $\\eta(q) = \\frac{q}{(1+q)^2}$, and $M$ is the total mass in geometrized units (seconds).\n\nTo find $f_{\\text{match}}(q)$, we set $\\Delta \\Phi_{\\text{PN}}(f,q) = \\Delta \\Phi_{\\text{NR}}(f,q)$ and solve for $f$. Let's define the $q$-dependent coefficients for clarity:\n$$\nC_{\\text{PN}}(q) = A_0 \\left[1 + a_1 \\bigl(1 - 4\\eta(q)\\bigr)^2\\right]\n$$\n$$\nC_{\\text{NR}}(q) = B_0 \\left[1 + b_1 \\frac{q-1}{q+1}\\right]\n$$\nThe equality becomes:\n$$\nC_{\\text{PN}}(q) \\left(\\pi M f\\right)^{8/3} = C_{\\text{NR}}(q) \\left(M f\\right)\n$$\nThis equation has a trivial solution at $f=0$. For $f \\neq 0$, we can rearrange the terms to solve for $f$:\n$$\nf^{8/3 - 1} = \\frac{C_{\\text{NR}}(q) M}{C_{\\text{PN}}(q) (\\pi M)^{8/3}}\n$$\n$$\nf^{5/3} = \\frac{C_{\\text{NR}}(q)}{C_{\\text{PN}}(q)} \\frac{M}{\\pi^{8/3} M^{8/3}} = \\frac{C_{\\text{NR}}(q)}{C_{\\text{PN}}(q)} \\pi^{-8/3} M^{-5/3}\n$$\nThis yields a unique, positive analytical solution for $f$:\n$$\nf_{\\text{match}}(q) = \\left[ \\frac{C_{\\text{NR}}(q)}{C_{\\text{PN}}(q)} \\pi^{-8/3} M^{-5/3} \\right]^{3/5} = \\left[ \\frac{C_{\\text{NR}}(q)}{C_{\\text{PN}}(q)} \\right]^{3/5} \\pi^{-8/5} M^{-1}\n$$\nWhile an analytical solution exists, the problem specifies a numerical solution on the interval $[10\\,\\mathrm{Hz}, 400\\,\\mathrm{Hz}]$. We will implement a numerical root-finding algorithm for the function $g(f,q) = \\Delta \\Phi_{\\text{PN}}(f,q) - \\Delta \\Phi_{\\text{NR}}(f,q) = 0$. The Brent-Dekker method (`scipy.optimize.brentq`) is a robust choice for this task, as it guarantees finding a root within a bracketed interval where the function values at the endpoints have opposite signs.\n\nThe algorithm proceeds as follows:\n1.  Define all physical and model constants, including the total mass $M$ in seconds. $M = 60\\, M_\\odot \\times 4.92549095 \\times 10^{-6}\\,\\mathrm{s}/M_\\odot$.\n2.  For each mass ratio $q \\in \\{1, 3, 8\\}$:\n    a. Define the difference function $g(f,q)$ as specified above.\n    b. Check the signs of $g(10\\,\\mathrm{Hz}, q)$ and $g(400\\,\\mathrm{Hz}, q)$. Since $\\Delta \\Phi_{\\text{PN}} \\propto f^{8/3}$ and $\\Delta \\Phi_{\\text{NR}} \\propto f^1$, $g(f,q)$ will be negative for small $f$ and positive for large $f$, guaranteeing a single root is bracketed if it lies within the interval.\n    c. Use `scipy.optimize.brentq` to find the root $f_{\\text{match}}(q)$ in the interval $[10, 400]$. If the root is not bracketed, `brentq` will raise an error, which we handle by assigning `NaN` as per the problem specification.\n3.  After computing the frequencies for all three mass ratios, perform the two required boolean checks:\n    a. **Monotonicity Check:** Verify if $f_{\\text{match}}(1) > f_{\\text{match}}(3) > f_{\\text{match}}(8)$. This is expected, as the increasing complexity of higher-mass-ratio NR simulations (modeled by the $C_{\\text{NR}}(q)$ term) and the decreasing higher-order PN contributions (modeled by $C_{\\text{PN}}(q)$) tend to push the optimal matching point to earlier times and thus lower frequencies.\n    b. **In-Band Check:** Verify if all three frequencies were successfully found within the specified interval $[10\\,\\mathrm{Hz}, 400\\,\\mathrm{Hz}]$. This is `True` if and only if none of the results are `NaN`.\n4.  Finally, format the results into a single string as a Python-style list: the three frequencies rounded to three decimal places, followed by the two boolean values.\n\nThis systematic approach ensures all constraints of the problem are met, leading to a verifiable and correct solution.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes the PN-NR hybridization frequency and performs validation checks.\n    \"\"\"\n    # Define physical and model constants as specified in the problem statement.\n    M_SOLAR_IN_S = 4.92549095e-6\n    M_TOTAL_SOLAR = 60.0\n    M = M_TOTAL_SOLAR * M_SOLAR_IN_S\n    A0 = 0.03125\n    a1 = 6.0\n    B0 = 0.001\n    b1 = 0.5\n    \n    # Define the mass ratios for the test suite and the frequency search interval.\n    test_cases = [1.0, 3.0, 8.0]  # Mass ratios q\n    f_min, f_max = 10.0, 400.0\n\n    # Helper function to compute the symmetric mass ratio eta.\n    def eta(q):\n        return q / (1.0 + q)**2\n\n    # Define the difference function whose root is the matching frequency.\n    # g(f, q) = ΔΦ_PN(f, q) - ΔΦ_NR(f, q)\n    def difference_function(f, q):\n        \"\"\"Calculates the difference between PN and NR phase error models.\"\"\"\n        # Calculate the PN phase error term.\n        pn_coeff = A0 * (1.0 + a1 * (1.0 - 4.0 * eta(q))**2)\n        pn_error = pn_coeff * (np.pi * M * f)**(8.0/3.0)\n        \n        # Calculate the NR phase error term.\n        nr_coeff = B0 * (1.0 + b1 * (q - 1.0) / (q + 1.0))\n        nr_error = nr_coeff * M * f\n        \n        return pn_error - nr_error\n\n    frequencies_raw = []\n    \n    for q in test_cases:\n        try:\n            # The Brent-Dekker method requires f(a) and f(b) to have opposite signs.\n            # Check if a root is bracketed within the specified interval.\n            val_min = difference_function(f_min, q)\n            val_max = difference_function(f_max, q)\n            if np.sign(val_min) == np.sign(val_max):\n                raise ValueError(\"Root not bracketed in the interval.\")\n            \n            # Find the root numerically.\n            f_match = brentq(difference_function, f_min, f_max, args=(q,))\n            frequencies_raw.append(f_match)\n        except ValueError:\n            # If no root is found in the interval, append NaN as required.\n            frequencies_raw.append(np.nan)\n\n    # Perform the two boolean checks on the computed frequencies.\n    \n    # 1. In-band check: This is true if and only if no NaN values were produced.\n    all_in_band = not any(np.isnan(f) for f in frequencies_raw)\n    \n    # 2. Monotonicity check: f_match must be strictly decreasing with 'q'.\n    # This check is only meaningful if all frequencies were successfully found.\n    is_monotonic = False\n    if all_in_band:\n        if frequencies_raw[0] > frequencies_raw[1] and frequencies_raw[1] > frequencies_raw[2]:\n            is_monotonic = True\n\n    # Assemble the final list for printing, formatting each element as required.\n    output_parts = []\n    for f in frequencies_raw:\n        if np.isnan(f):\n            output_parts.append('NaN')\n        else:\n            # Format frequencies to three decimal places.\n            output_parts.append(f\"{f:.3f}\")\n    \n    output_parts.append(str(is_monotonic))\n    output_parts.append(str(all_in_band))\n\n    # Print the final result in the exact specified format: [f1,f3,f8,mono,in_band]\n    print(f\"[{','.join(output_parts)}]\")\n\n# Execute the solver.\nsolve()\n```"
        },
        {
            "introduction": "The ultimate goal of waveform modeling is to enable precise scientific inference from gravitational-wave data. However, the specific choices made during hybridization—such as the PN model used or the location of the matching window—introduce systematic uncertainties into the final waveform. In this capstone practice, you will build an end-to-end simulation to quantify how these modeling choices propagate into uncertainties in the final, inferred physical parameters of the binary, such as its chirp mass $\\mathcal{M}$. By implementing a Monte Carlo study that randomizes modeling decisions, you will generate a statistical ensemble of hybrid waveforms and measure the resulting spread in the estimated chirp mass, providing a direct, hands-on understanding of the impact of systematic modeling errors on gravitational-wave science .",
            "id": "3477295",
            "problem": "Implement a complete, deterministic Monte Carlo study to quantify the systematic spread in hybrid gravitational-wave frequency-domain waveforms formed by matching post-Newtonian (PN) inspiral models to a simplified numerical relativity (NR)-like surrogate, and report equal-tailed confidence intervals for the chirp mass $\\mathcal{M}$ at a fixed total mass $M$. The task must be solved from first principles using the following foundational base and specifications.\n\nThe physical and mathematical base is as follows. Consider non-spinning, quasi-circular compact binaries in the stationary phase approximation, and write the frequency-domain gravitational-wave phase $\\psi(f)$ for the PN TaylorF2 family as a power series in the characteristic velocity $v = (\\pi M f)^{1/3}$, where $M$ is the total mass in geometric units. Let the symmetric mass ratio be $\\eta = m_1 m_2 / M^2$ with $m_1 \\ge m_2$, and define the chirp mass $\\mathcal{M} = \\eta^{3/5} M$. Use geometric units with $G = c = 1$ internally, with conversion to and from Solar-mass units required where appropriate. The Solar-mass time is $t_{\\odot} = G M_{\\odot}/c^3 = 4.92549095 \\times 10^{-6}\\,\\mathrm{s}$. All frequencies must be in hertz (Hz). All chirp masses reported must be in Solar masses ($M_{\\odot}$).\n\nUse the following well-tested PN TaylorF2 non-spinning phase truncations (the “PN approximants” to be explored), written without the extrinsic coalescence time and phase:\n$$\n\\psi_{\\mathrm{PN}}(f; M, \\eta) \\equiv \\frac{3}{128\\,\\eta}\\,v^{-5}\\,\\left[ 1 + \\alpha_2 v^2 + \\alpha_3 v^3 + \\alpha_4 v^4 \\right],\n$$\nwith $v = (\\pi M f)^{1/3}$ and coefficients\n$$\n\\alpha_2 = \\frac{3715}{756} + \\frac{55}{9}\\eta,\\quad\n\\alpha_3 = -16\\pi,\\quad\n\\alpha_4 = \\frac{15293365}{508032} + \\frac{27145}{504}\\eta + \\frac{3085}{72}\\eta^2.\n$$\nDefine the “approximants” as truncations of the above series: the $0$PN approximant uses only the leading term $\\left[1\\right]$, the $1.5$PN approximant uses $\\left[1 + \\alpha_2 v^2 + \\alpha_3 v^3\\right]$, and the $2$PN approximant uses $\\left[1 + \\alpha_2 v^2 + \\alpha_3 v^3 + \\alpha_4 v^4\\right]$.\n\nDefine a simplified NR-like surrogate in the frequency domain by taking the $2$PN TaylorF2 phase above and adding a smooth, compact high-frequency correction:\n$$\n\\psi_{\\mathrm{NR}}(f; M, \\eta) = \\psi_{\\mathrm{PN,\\,2PN}}(f; M, \\eta) + \\delta\\psi_{\\mathrm{high}}(f),\n$$\nwith\n$$\n\\delta\\psi_{\\mathrm{high}}(f) = \\kappa \\left(\\frac{f}{f_0}\\right)^2 \\exp\\!\\left(-\\frac{f}{f_{\\mathrm{d}}}\\right),\n$$\nwhere $\\kappa = 2.0$ (dimensionless), $f_0 = 150\\,\\mathrm{Hz}$, and $f_{\\mathrm{d}} = 200\\,\\mathrm{Hz}$. Use an amplitude model of the form $A(f) \\propto f^{-7/6}\\, \\exp\\!\\left[-(f/f_{\\mathrm{cut}})^7\\right]$ with $f_{\\mathrm{cut}} = 0.2/M$ (in hertz, using $M$ converted to seconds via $M = M_{\\mathrm{tot}}\\,t_{\\odot}$), but note that amplitude does not enter the chirp-mass estimation procedure specified below.\n\nForm frequency-domain PN-NR hybrids by aligning a selected PN approximant $\\psi_{\\mathrm{PN}}(f)$ to $\\psi_{\\mathrm{NR}}(f)$ over an alignment window $[f_1,f_2]$ (in hertz) by minimizing a least-squares phase difference over a time shift $t_0$ and a phase shift $\\phi_0$:\n$$\n\\min_{t_0,\\phi_0}\\ \\int_{f_1}^{f_2} \\left(\\psi_{\\mathrm{PN}}(f) + 2\\pi f t_0 + \\phi_0 - \\psi_{\\mathrm{NR}}(f)\\right)^2\\,\\mathrm{d}f.\n$$\nUse the optimal $(t_0,\\phi_0)$ to define an aligned PN phase $\\psi_{\\mathrm{PN,\\,aligned}}(f) = \\psi_{\\mathrm{PN}}(f) + 2\\pi f t_0 + \\phi_0$. Define a smooth half-cosine taper to blend between PN and NR phases across the window:\n$$\nw(f) = \n\\begin{cases}\n0,  f \\le f_1, \\\\[4pt]\n\\frac{1}{2}\\left[1 - \\cos\\!\\left(\\pi\\,\\frac{f-f_1}{f_2-f_1}\\right)\\right],  f_1  f  f_2, \\\\[4pt]\n1,  f \\ge f_2\n\\end{cases}\n$$\nand the hybrid phase\n$$\n\\psi_{\\mathrm{hyb}}(f) = \\left[1-w(f)\\right]\\psi_{\\mathrm{PN,\\,aligned}}(f) + w(f)\\,\\psi_{\\mathrm{NR}}(f).\n$$\n\nEstimate the chirp mass from the hybrid phase at low frequency, leveraging the Newtonian-order scaling of the phase with frequency while marginalizing over the extrinsic time and phase. Specifically, at leading order,\n$$\n\\psi_{\\mathrm{LO}}(f) = \\frac{3}{128}\\,(\\pi\\,\\mathcal{M}\\,f)^{-5/3} + 2\\pi f\\,t_c - \\phi_c - \\frac{\\pi}{4},\n$$\nso that fitting $\\psi_{\\mathrm{hyb}}(f)$ in a low-frequency band to the form $\\beta_0 + \\beta_1 f + \\alpha\\,f^{-5/3}$ allows isolation of the coefficient $\\alpha = \\frac{3}{128}(\\pi \\mathcal{M})^{-5/3}$ and hence determination of $\\mathcal{M}$.\n\nDesign a Monte Carlo over alignment window choices and PN approximants to characterize the systematic spread in recovered $\\mathcal{M}$ at fixed total mass $M_{\\mathrm{tot}}$ and mass ratio $q = m_1/m_2 \\ge 1$ with $\\eta = q/(1+q)^2$. For each Monte Carlo trial:\n- Randomly select a PN approximant from the set $\\{0\\mathrm{PN}, 1.5\\mathrm{PN}, 2\\mathrm{PN}\\}$ with equal probability.\n- Randomly choose an alignment window width $w_{\\mathrm{Hz}}$ uniformly from $[30,80]\\,\\mathrm{Hz}$.\n- Randomly choose a starting frequency $f_1$ uniformly from $[f_{\\mathrm{low}} + 60,\\, \\min(f_{\\max} - w_{\\mathrm{Hz}} - 30,\\, f_{\\mathrm{low}}+220)]$, with $f_{\\mathrm{low}} = 20\\,\\mathrm{Hz}$ and $f_{\\max} = \\min(1024\\,\\mathrm{Hz},\\, 0.2/M)$; set $f_2 = f_1 + w_{\\mathrm{Hz}}$.\n- Compute the hybrid phase $\\psi_{\\mathrm{hyb}}(f)$ on a frequency grid with spacing $\\Delta f = 1\\,\\mathrm{Hz}$ from $f_{\\mathrm{low}}$ up to $f_{\\max}$.\n- Estimate $\\mathcal{M}$ by fitting $\\psi_{\\mathrm{hyb}}(f)$ over a low-frequency band $[f_{\\mathrm{low}}+2,\\, \\min(f_1-2,\\, f_{\\mathrm{low}}+40,\\, f_{\\max}-5)]$ to the model $\\beta_0 + \\beta_1 f + \\alpha f^{-5/3}$ using least squares, solve for $\\alpha$, and infer $\\mathcal{M}$.\n\nRepeat for a specified number of trials with a fixed random seed for reproducibility. Compute the equal-tailed $90\\%$ confidence interval for $\\mathcal{M}$ from the empirical $0.05$ and $0.95$ quantiles of the Monte Carlo sample. Express all chirp-mass interval endpoints in Solar masses ($M_{\\odot}$) as decimal numbers rounded to six decimal places.\n\nYour program must implement the above procedure and produce results for the following test suite of four parameter sets:\n- Case 1 (balanced, moderate mass): $M_{\\mathrm{tot}} = 40.0\\,M_{\\odot}$, $q = 1.0$, $N_{\\mathrm{trials}} = 128$, random seed $= 7$.\n- Case 2 (unequal mass, lower total mass): $M_{\\mathrm{tot}} = 20.0\\,M_{\\odot}$, $q = 3.0$, $N_{\\mathrm{trials}} = 128$, random seed $= 11$.\n- Case 3 (high total mass, fewer cycles): $M_{\\mathrm{tot}} = 80.0\\,M_{\\odot}$, $q = 1.2$, $N_{\\mathrm{trials}} = 64$, random seed $= 13$.\n- Case 4 (boundary on Monte Carlo size): $M_{\\mathrm{tot}} = 60.0\\,M_{\\odot}$, $q = 1.0$, $N_{\\mathrm{trials}} = 16$, random seed $= 17$.\n\nFinal Output Format: Your program should produce a single line of output containing the results as a list of lists, one list per test case, each inner list containing the two floating-point interval endpoints $\\left[\\mathcal{M}_{\\mathrm{low}},\\, \\mathcal{M}_{\\mathrm{high}}\\right]$ in Solar masses, rounded to six decimal places, and printed with no additional text. For example: [[m1_low,m1_high],[m2_low,m2_high],[m3_low,m3_high],[m4_low,m4_high]].",
            "solution": "The user-provided problem has been rigorously validated and is determined to be a valid, well-posed scientific task.\n\n### Step 1: Givens Extraction\n- **Physical System**: Non-spinning, quasi-circular compact binaries.\n- **Approximation**: Stationary phase approximation (SPA) for gravitational waves.\n- **Units**: Geometric units ($G=c=1$) for internal calculations. Solar-mass time is $t_{\\odot} = 4.92549095 \\times 10^{-6}\\,\\mathrm{s}$. Frequencies are in Hz. Final chirp mass values are in Solar masses ($M_{\\odot}$).\n- **Parameters**: Total mass $M$ (geometric) or $M_{\\mathrm{tot}}$ ($M_{\\odot}$), symmetric mass ratio $\\eta = m_1 m_2 / M^2$, mass ratio $q = m_1/m_2 \\ge 1$, chirp mass $\\mathcal{M} = \\eta^{3/5} M$, and characteristic velocity $v = (\\pi M f)^{1/3}$.\n- **PN Phase Model (TaylorF2)**:\n$$\n\\psi_{\\mathrm{PN}}(f; M, \\eta) = \\frac{3}{128\\,\\eta}\\,v^{-5}\\,\\left[ 1 + \\alpha_2 v^2 + \\alpha_3 v^3 + \\alpha_4 v^4 \\right]\n$$\nwith coefficients $\\alpha_2 = \\frac{3715}{756} + \\frac{55}{9}\\eta$, $\\alpha_3 = -16\\pi$, and $\\alpha_4 = \\frac{15293365}{508032} + \\frac{27145}{504}\\eta + \\frac{3085}{72}\\eta^2$.\n- **PN Approximants**: $0$PN (leading term only), $1.5$PN (up to $v^3$ term), $2$PN (up to $v^4$ term).\n- **NR Surrogate Model**:\n$$\n\\psi_{\\mathrm{NR}}(f; M, \\eta) = \\psi_{\\mathrm{PN,\\,2PN}}(f; M, \\eta) + \\kappa \\left(\\frac{f}{f_0}\\right)^2 \\exp\\!\\left(-\\frac{f}{f_{\\mathrm{d}}}\\right),\n$$\nwith $\\kappa = 2.0$, $f_0 = 150\\,\\mathrm{Hz}$, $f_{\\mathrm{d}} = 200\\,\\mathrm{Hz}$.\n- **Hybridization**:\n    - **Alignment**: Minimize $\\int_{f_1}^{f_2} \\left(\\psi_{\\mathrm{PN}}(f) + 2\\pi f t_0 + \\phi_0 - \\psi_{\\mathrm{NR}}(f)\\right)^2\\,\\mathrm{d}f$ to find optimal $(t_0, \\phi_0)$ over $[f_1, f_2]$.\n    - **Blending**: Use a half-cosine taper $w(f)$ over $[f_1, f_2]$ to construct the hybrid phase $\\psi_{\\mathrm{hyb}}(f) = \\left[1-w(f)\\right]\\psi_{\\mathrm{PN,\\,aligned}}(f) + w(f)\\,\\psi_{\\mathrm{NR}}(f)$.\n- **Chirp Mass Estimation**:\n    - Fit $\\psi_{\\mathrm{hyb}}(f)$ to the model $\\beta_0 + \\beta_1 f + \\alpha f^{-5/3}$ over a low-frequency band.\n    - Infer $\\mathcal{M}$ from the fitted coefficient $\\alpha = \\frac{3}{128}(\\pi \\mathcal{M})^{-5/3}$.\n- **Monte Carlo Study**:\n    - **Random Variables**: PN approximant from $\\{0\\mathrm{PN}, 1.5\\mathrm{PN}, 2\\mathrm{PN}\\}$; alignment window width $w_{\\mathrm{Hz}} \\sim U[30, 80]\\,\\mathrm{Hz}$; start frequency $f_1 \\sim U[f_{\\mathrm{low}} + 60,\\, \\min(f_{\\max} - w_{\\mathrm{Hz}} - 30,\\, f_{\\mathrm{low}}+220)]$.\n    - **Fixed Parameters**: $f_{\\mathrm{low}} = 20\\,\\mathrm{Hz}$, $\\Delta f = 1\\,\\mathrm{Hz}$, $f_{\\max} = \\min(1024\\,\\mathrm{Hz},\\, 0.2/M)$.\n    - **Fitting Band for $\\mathcal{M}$**: $[f_{\\mathrm{low}}+2,\\, \\min(f_1-2,\\, f_{\\mathrm{low}}+40,\\, f_{\\max}-5)]$.\n    - **Output**: Equal-tailed $90\\%$ confidence interval for $\\mathcal{M}$ ($[q_{0.05}, q_{0.95}]$) in $M_{\\odot}$, rounded to 6 decimal places.\n- **Test Cases**:\n    1. $M_{\\mathrm{tot}} = 40.0\\,M_{\\odot}$, $q = 1.0$, $N_{\\mathrm{trials}} = 128$, seed $= 7$.\n    2. $M_{\\mathrm{tot}} = 20.0\\,M_{\\odot}$, $q = 3.0$, $N_{\\mathrm{trials}} = 128$, seed $= 11$.\n    3. $M_{\\mathrm{tot}} = 80.0\\,M_{\\odot}$, $q = 1.2$, $N_{\\mathrm{trials}} = 64$, seed $= 13$.\n    4. $M_{\\mathrm{tot}} = 60.0\\,M_{\\odot}$, $q = 1.0$, $N_{\\mathrm{trials}} = 16$, seed $= 17$.\n\n### Step 2: Validation Using Extracted Givens\nThe problem is subjected to rigorous validation and is deemed valid.\n- **Scientifically Grounded**: The problem is fundamentally based on established principles of general relativity, specifically the post-Newtonian (PN) approximation for the inspiral of compact binaries and its interface with numerical relativity (NR). The TaylorF2 phase expansion, the hybridization technique, and the method of chirp mass extraction from the low-frequency phase are all standard, well-documented procedures in the field of gravitational-wave astronomy. The NR surrogate, while simplified, is a physically motivated toy model appropriate for such a systematic study.\n- **Well-Posed**: The problem specifies a complete and deterministic computational procedure. All required constants, equations, parameter ranges, and random variable distributions are explicitly defined. The use of a fixed random seed ensures that the Monte Carlo simulation is perfectly reproducible. The objectives and the final output format are unambiguous.\n- **Objective**: The problem is stated in precise, quantitative, and unbiased scientific language, free from any subjective or speculative content.\n\nThe problem does not exhibit any of the invalidity criteria. It is a self-contained, consistent, and scientifically meaningful task that simulates a realistic analysis scenario in gravitational-wave source modeling.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A complete solution will be provided.\n\n### Principle-Based Design\nThe core of this problem is to implement a numerical experiment to assess the systematic uncertainties in constructing hybrid gravitational waveforms. These hybrids are essential for creating complete inspiral-merger-ringdown waveform models used in gravitational-wave detection and parameter estimation. The systematic uncertainty arises from modeling choices, such as which PN approximant to use and which frequency interval to use for matching it to a numerical relativity waveform.\n\n**1. Physical and Mathematical Framework**\nThe foundation of the model is the frequency-domain gravitational-wave phase, $\\psi(f)$, derived from the stationary phase approximation. All calculations are performed in geometric units ($G=c=1$), where mass, time, and length have the same dimension. The conversion factor $t_{\\odot} = G M_{\\odot}/c^3$ is used to relate geometric mass units to Solar masses.\n\nThe inspiral phase is described by the post-Newtonian (PN) TaylorF2 model, which is a power series expansion in the characteristic orbital velocity $v = (\\pi M f)^{1/3}$. The problem specifies three truncated versions of this series, denoted $0$PN, $1.5$PN, and $2$PN, which represent different levels of physical accuracy.\n\nThe \"true\" waveform is represented by a simplified numerical relativity (NR) surrogate. This is constructed by taking the most accurate PN model ($2$PN) and adding a phenomenological high-frequency correction term, $\\delta\\psi_{\\mathrm{high}}(f)$. This term models the complex physics of the late inspiral and merger, which are not captured by the PN expansion.\n\n**2. Hybrid Waveform Construction**\nA hybrid waveform is constructed by smoothly joining a PN model (valid at low frequencies) to the NR surrogate (valid at high frequencies). This process involves two main steps:\n\n- **Alignment**: The PN phase has two unphysical degrees of freedom: an arbitrary time shift ($t_0$) and phase shift ($\\phi_0$). Before blending, the chosen PN approximant, $\\psi_{\\mathrm{PN}}$, must be aligned to the NR surrogate, $\\psi_{\\mathrm{NR}}$. This is achieved by minimizing the least-squares difference between the two phases over a chosen frequency interval $[f_1, f_2]$. The objective function is $\\int_{f_1}^{f_2} (\\psi_{\\mathrm{PN}}(f) + 2\\pi f t_0 + \\phi_0 - \\psi_{\\mathrm{NR}}(f))^2\\,\\mathrm{d}f$. This is a linear least-squares problem for the parameters $\\phi_0$ and $(2\\pi t_0)$, which can be solved efficiently using standard numerical linear algebra techniques, such as polynomial fitting.\n\n- **Blending**: Once the optimal shifts $(t_0, \\phi_0)$ are found, the aligned PN phase is $\\psi_{\\mathrm{PN,\\,aligned}}(f) = \\psi_{\\mathrm{PN}}(f) + 2\\pi f t_0 + \\phi_0$. A smooth transition from the PN to the NR model is created using a tapering function, $w(f)$. The specified half-cosine taper smoothly transitions from $0$ to $1$ across the alignment window $[f_1, f_2]$. The final hybrid phase is a weighted average: $\\psi_{\\mathrm{hyb}}(f) = [1-w(f)]\\psi_{\\mathrm{PN,\\,aligned}}(f) + w(f)\\psi_{\\mathrm{NR}}(f)$.\n\n**3. Chirp Mass Estimation**\nThe chirp mass, $\\mathcal{M}$, is a key physical parameter that predominantly governs the rate of inspiral. Its effect is most cleanly observed in the low-frequency portion of the waveform phase. At the lowest (Newtonian) order, the phase is $\\psi_{\\mathrm{LO}}(f) \\approx \\frac{3}{128}(\\pi \\mathcal{M} f)^{-5/3}$. Including the extrinsic parameters (coalescence time and phase), which appear as terms linear in frequency and a constant offset, the model for the low-frequency phase becomes $\\psi(f) \\approx \\beta_0 + \\beta_1 f + \\alpha f^{-5/3}$. The coefficient of interest is $\\alpha = \\frac{3}{128}(\\pi\\mathcal{M})^{-5/3}$.\n\nTo estimate $\\mathcal{M}$ from a given hybrid waveform $\\psi_{\\mathrm{hyb}}(f)$, we perform a linear least-squares fit of this model to the hybrid phase over a pre-defined low-frequency band. By extracting the best-fit coefficient $\\alpha$, we can algebraically solve for the chirp mass:\n$$\n\\mathcal{M} = \\frac{1}{\\pi} \\left( \\frac{3}{128\\alpha} \\right)^{3/5}.\n$$\nThe result, initially in geometric units, is then converted to Solar masses.\n\n**4. Monte Carlo Simulation and Statistical Analysis**\nThe goal of the study is to quantify how the arbitrary choices made during hybridization affect the final estimated chirp mass. A Monte Carlo simulation is the ideal tool for this. For a binary with fixed physical properties ($M_{\\mathrm{tot}}, q$), we perform numerous trials. In each trial:\n1. We randomly select a PN approximant (simulating model uncertainty).\n2. We randomly select an alignment window $[f_1, f_2]$ (simulating procedural uncertainty).\n3. We follow the hybridization and estimation procedure described above to obtain a single estimate of $\\mathcal{M}$.\n\nBy repeating this process many times ($N_{\\mathrm{trials}}$), we generate a distribution of estimated $\\mathcal{M}$ values. This distribution's spread is a direct measure of the systematic uncertainty introduced by the hybridization procedure. The problem requires reporting the equal-tailed $90\\%$ confidence interval of this distribution, which is obtained by finding the $5^{\\mathrm{th}}$ and $95^{\\mathrm{th}}$ percentiles of the collected samples. Using a fixed random seed ensures that this entire stochastic process is deterministic and its results are reproducible.\n\nThe implementation will rely on the `numpy` library for efficient array computations, random number generation, and solving the linear least-squares systems required for both phase alignment and chirp mass estimation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Monte Carlo study for all specified test cases\n    and print the results in the required format.\n    \"\"\"\n    # Solar mass time in seconds (G*M_sun/c^3)\n    T_SOLAR = 4.92549095e-6\n\n    test_cases = [\n        # (M_tot_sun, q, N_trials, seed)\n        (40.0, 1.0, 128, 7),\n        (20.0, 3.0, 128, 11),\n        (80.0, 1.2, 64, 13),\n        (60.0, 1.0, 16, 17),\n    ]\n\n    all_results = []\n    for m_tot_sun, q, n_trials, seed in test_cases:\n        result = run_single_case(m_tot_sun, q, n_trials, seed, T_SOLAR)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef calculate_pn_phase(f_hz, M_sec, eta, approximant):\n    \"\"\"\n    Calculates the TaylorF2 PN phase for a given approximant.\n    \"\"\"\n    # Avoid division by zero or log of zero if f starts at 0\n    f_hz = np.maximum(f_hz, 1e-9)\n\n    v = (np.pi * M_sec * f_hz)**(1/3)\n    \n    alpha2 = 3715.0/756.0 + 55.0/9.0 * eta\n    alpha3 = -16.0 * np.pi\n    alpha4 = 15293365.0/508032.0 + 27145.0/504.0 * eta + 3085.0/72.0 * eta**2\n\n    pn_poly = 1.0\n    if approximant in ['1.5PN', '2PN']:\n        pn_poly += alpha2 * v**2 + alpha3 * v**3\n    if approximant == '2PN':\n        pn_poly += alpha4 * v**4\n\n    psi = (3.0 / (128.0 * eta)) * v**(-5) * pn_poly\n    return psi\n\ndef calculate_nr_surrogate_phase(f_hz, M_sec, eta):\n    \"\"\"\n    Calculates the NR-like surrogate phase.\n    \"\"\"\n    psi_2pn = calculate_pn_phase(f_hz, M_sec, eta, '2PN')\n    \n    kappa = 2.0\n    f0 = 150.0\n    fd = 200.0\n    \n    delta_psi_high = kappa * (f_hz/f0)**2 * np.exp(-f_hz/fd)\n    \n    return psi_2pn + delta_psi_high\n\ndef taper_window(f_hz, f1, f2):\n    \"\"\"\n    Generates a half-cosine tapering window function.\n    \"\"\"\n    w = np.zeros_like(f_hz)\n    \n    # Region f1  f  f2\n    mask = (f_hz  f1)  (f_hz  f2)\n    f_masked = f_hz[mask]\n    w[mask] = 0.5 * (1 - np.cos(np.pi * (f_masked - f1) / (f2 - f1)))\n    \n    # Region f = f2\n    w[f_hz = f2] = 1.0\n    \n    return w\n\ndef estimate_chirp_mass(f_fit, psi_hyb_fit, T_SOLAR):\n    \"\"\"\n    Estimates chirp mass by fitting the hybrid phase at low frequencies.\n    \"\"\"\n    # Model: psi = beta0 + beta1*f + alpha*f**(-5/3)\n    # Design matrix columns: 1, f, f**(-5/3)\n    f_fit_col = f_fit.reshape(-1, 1)\n    A = np.hstack([np.ones_like(f_fit_col), f_fit_col, f_fit_col**(-5.0/3.0)])\n    \n    # Solve the least squares problem y = A*x for x = [beta0, beta1, alpha]\n    coeffs, _, _, _ = np.linalg.lstsq(A, psi_hyb_fit, rcond=None)\n    alpha = coeffs[2]\n\n    # Infer chirp mass from alpha\n    # alpha = (3/128) * (pi*M_chirp_sec)**(-5/3)\n    # M_chirp_sec = (1/pi) * ( (3)/(128*alpha) )**(3/5)\n    m_chirp_sec = (1.0 / np.pi) * ( (3.0)/(128.0 * alpha) )**(3.0/5.0)\n    \n    # Convert from seconds to solar masses\n    m_chirp_solar = m_chirp_sec / T_SOLAR\n    return m_chirp_solar\n    \ndef run_single_case(M_tot_sun, q, N_trials, seed, T_SOLAR):\n    \"\"\"\n    Runs the full Monte Carlo simulation for a single test case.\n    \"\"\"\n    np.random.seed(seed)\n    \n    # --- Setup constants for the case ---\n    M_sec = M_tot_sun * T_SOLAR\n    eta = q / (1.0 + q)**2\n    \n    f_low = 20.0\n    f_max_unclamped = 0.2 / M_sec\n    f_max = min(1024.0, f_max_unclamped)\n    df = 1.0\n    \n    f_grid = np.arange(f_low, f_max + df, df)\n    \n    # NR surrogate phase is constant for a given case\n    psi_nr = calculate_nr_surrogate_phase(f_grid, M_sec, eta)\n    \n    m_chirp_samples = []\n    \n    # --- Monte Carlo Loop ---\n    for _ in range(N_trials):\n        # 1. Randomly select PN approximant\n        approximant = np.random.choice(['0PN', '1.5PN', '2PN'])\n        \n        # 2. Randomly choose alignment window\n        w_hz = np.random.uniform(30.0, 80.0)\n        f1_upper_bound = min(f_max - w_hz - 30.0, f_low + 220.0)\n        f1 = np.random.uniform(f_low + 60.0, f1_upper_bound)\n        f2 = f1 + w_hz\n        \n        # 3. Calculate PN phase for this trial\n        psi_pn = calculate_pn_phase(f_grid, M_sec, eta, approximant)\n        \n        # 4. Align PN to NR in the alignment window\n        align_mask = (f_grid = f1)  (f_grid = f2)\n        f_align = f_grid[align_mask]\n        \n        # The equation to fit is: psi_nr - psi_pn = phi0 + (2*pi*t0)*f\n        # This is a 1st degree polynomial fit.\n        phase_diff_to_fit = psi_nr[align_mask] - psi_pn[align_mask]\n        poly_coeffs = np.polyfit(f_align, phase_diff_to_fit, 1)\n        two_pi_t0, phi0 = poly_coeffs\n        t0 = two_pi_t0 / (2 * np.pi)\n        \n        psi_pn_aligned = psi_pn + 2 * np.pi * f_grid * t0 + phi0\n        \n        # 5. Create hybrid waveform\n        w = taper_window(f_grid, f1, f2)\n        psi_hyb = (1 - w) * psi_pn_aligned + w * psi_nr\n        \n        # 6. Estimate chirp mass from the hybrid\n        fit_band_upper_trial = min(f1 - 2.0, f_low + 40.0, f_max - 5.0)\n        fit_mask = (f_grid >= f_low + 2.0)  (f_grid = fit_band_upper_trial)\n        f_for_fit = f_grid[fit_mask]\n        psi_hyb_for_fit = psi_hyb[fit_mask]\n\n        m_chirp_est = estimate_chirp_mass(f_for_fit, psi_hyb_for_fit, T_SOLAR)\n        m_chirp_samples.append(m_chirp_est)\n        \n    # --- Statistical Analysis ---\n    m_chirp_samples = np.array(m_chirp_samples)\n    m_low = np.quantile(m_chirp_samples, 0.05)\n    m_high = np.quantile(m_chirp_samples, 0.95)\n    \n    # Return formatted results as a list of two floats\n    return [round(m_low, 6), round(m_high, 6)]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}