{
    "hands_on_practices": [
        {
            "introduction": "The first practical step in gravitational wave extraction is to compute the Weyl scalar $\\Psi_4$ from the fundamental variables of a numerical simulation. This exercise  guides you through constructing a quasi-Kinnersley frame, an adapted coordinate system that aligns with the principal directions of the gravitational field, which is essential for calculating $\\Psi_4$ from the electric and magnetic parts of the Weyl tensor.",
            "id": "3475803",
            "problem": "Consider a three-plus-one ($3+1$) decomposition of a vacuum spacetime, in geometric units where $G=c=1$, with a spatial metric $\\gamma_{ij}$ on a hypersurface, its unit timelike normal $n^a$, and the associated electric and magnetic parts of the Weyl tensor, $E_{ij}$ and $B_{ij}$. Starting from the fundamental definitions of the electric and magnetic parts of the Weyl tensor as spatial, symmetric, trace-free tensors built from the Weyl tensor $C_{abcd}$ via $E_{ij} = C_{i a j b} n^a n^b$ and $B_{ij} = {}^{\\star}C_{i a j b} n^a n^b$ (with ${}^{\\star}C_{abcd}$ the left Hodge dual of $C_{abcd}$), design and implement a practical algorithm to compute the quasi-Kinnersley frame (QKF) from $3+1$ data by constructing a tetrad $\\{\\ell^a, n^a, m^a, \\bar{m}^a\\}$ adapted to principal directions of $E_{ij}$ at an extraction point on a sphere. The algorithm must:\n\n- Construct a spatial principal direction from $E_{ij}$ by diagonalizing $E_{ij}$ and selecting a dominant eigenvector.\n- Orthonormalize a spatial triad $\\{e_r^i, e_\\theta^i, e_\\phi^i\\}$ where $e_r^i$ is aligned with the chosen principal direction, and $e_\\theta^i, e_\\phi^i$ span the tangent space of the extraction sphere at that point.\n- Form a Newman–Penrose (NP) tetrad adapted to the slice normal and the spatial triad via $\\ell^a$, $n^a$, and the complex vector $m^a$, and compute the outgoing gravitational radiation scalar $\\Psi_4$ as the appropriate contraction of the Weyl tensor with this tetrad.\n\nYour program must implement this algorithm for a provided test suite of cases. Treat the spatial metric as Euclidean $\\gamma_{ij} = \\delta_{ij}$ at the extraction point, and assume all quantities are dimensionless in geometric units. For numerical stability, when eigenvalues are degenerate or vanishing, fall back to a rule that chooses the principal direction from $B_{ij}$ in the same manner, and if both $E_{ij}$ and $B_{ij}$ fail to produce a usable direction, use $e_r^i = (0,0,1)$.\n\nInput to your program is implicit: it must internally use the following test suite, where each case provides $E_{ij}$ and $B_{ij}$ as $3 \\times 3$ matrices evaluated at one point on the extraction sphere. All matrices are symmetric and trace-free. The cases are:\n\n- Case A (general nondegenerate case):\n$$\nE^{(A)} = \\begin{pmatrix}\n1.0 & 0.2 & 0.0 \\\\\n0.2 & -1.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0\n\\end{pmatrix},\\quad\nB^{(A)} = \\begin{pmatrix}\n0.0 & 0.3 & 0.0 \\\\\n0.3 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0\n\\end{pmatrix}.\n$$\n\n- Case B (electric part degenerate, magnetic part nonzero):\n$$\nE^{(B)} = \\begin{pmatrix}\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0\n\\end{pmatrix},\\quad\nB^{(B)} = \\begin{pmatrix}\n0.0 & 0.5 & 0.0 \\\\\n0.5 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0\n\\end{pmatrix}.\n$$\n\n- Case C (nearly zero fields, testing numerical fallback):\n$$\nE^{(C)} = \\begin{pmatrix}\n10^{-9} & 0.0 & 0.0 \\\\\n0.0 & -10^{-9} & 0.0 \\\\\n0.0 & 0.0 & 0.0\n\\end{pmatrix},\\quad\nB^{(C)} = \\begin{pmatrix}\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0\n\\end{pmatrix}.\n$$\n\nImplementation requirements and assumptions:\n\n- Use the diagonalization of $E_{ij}$ to obtain its eigenvalues and eigenvectors, and select the eigenvector corresponding to the eigenvalue with the largest absolute value as the principal direction. In the degenerate case where $E_{ij}$ does not provide a usable direction, apply the same procedure to $B_{ij}$.\n- Construct $e_r^i$ as the normalized principal eigenvector, and build $e_\\theta^i$ and $e_\\phi^i$ via Gram–Schmidt orthonormalization against a fixed seed direction in $\\mathbb{R}^3$ that is not collinear with $e_r^i$.\n- Form the complex spatial vector $m^i = (e_\\theta^i + i e_\\phi^i)/\\sqrt{2}$.\n- Compute the outgoing Newman–Penrose scalar $\\Psi_4$ by contracting the appropriate complex combination of $E_{ij}$ and $B_{ij}$ with the complex conjugate components of $m^i$ twice, consistent with the NP definition for outgoing radiation in the chosen tetrad.\n\nYour program should produce a single line of output containing the results for the three cases as a comma-separated list of three two-element lists, each inner list containing the real and imaginary parts of $\\Psi_4$ for that case, in geometric units, for example $[[\\mathrm{Re}(\\Psi_4^{(A)}), \\mathrm{Im}(\\Psi_4^{(A)})], [\\mathrm{Re}(\\Psi_4^{(B)}), \\mathrm{Im}(\\Psi_4^{(B)})], [\\mathrm{Re}(\\Psi_4^{(C)}), \\mathrm{Im}(\\Psi_4^{(C)})]]$. The numerical values must be floating-point numbers. The angle unit is not applicable here. The output is dimensionless.\n\nYour program must be a complete, runnable program and must not require any external input. It must adhere to the execution environment specified in the final answer section. The final output format must be exactly a single line with the nested list described above.",
            "solution": "The problem is scientifically grounded, well-posed, objective, and provides a complete and consistent set of requirements to implement an algorithm for computing the Newman-Penrose scalar $\\Psi_4$ from 3+1 decomposed quantities. The procedure described is a standard technique in numerical relativity for gravitational wave extraction, known as the quasi-Kinnersley frame method. We will proceed with the solution.\n\nThe fundamental goal is to compute the outgoing Weyl scalar $\\Psi_4$, a complex scalar field that, in an asymptotically flat spacetime, encodes the properties of gravitational radiation. In the Newman-Penrose (NP) formalism, $\\Psi_4$ is defined by the contraction of the Weyl tensor $C_{abcd}$ with specific null vectors of an NP tetrad $\\{\\ell^a, n^a, m^a, \\bar{m}^a\\}$:\n$$ \\Psi_4 = C_{abcd} n^a \\bar{m}^b n^c \\bar{m}^d $$\nwhere $n^a$ is the ingoing null vector of the tetrad (distinct from the timelike normal to the spatial slice, which we also call $n^a$ per the problem statement), and $\\bar{m}^a$ is a complex null vector spanning the transverse 2-sphere. For practical computation in a 3+1 decomposition, $\\Psi_4$ can be expressed in terms of the electric ($E_{ij}$) and magnetic ($B_{ij}$) parts of the Weyl tensor, which are spatial, symmetric, and trace-free (SSTF) tensors on the spatial hypersurface. The relation is:\n$$ \\Psi_4 = (E_{ij} - i B_{ij}) \\bar{m}^i \\bar{m}^j $$\nHere, the indices $i, j$ are spatial, and $m^i$ is a complex spatial vector that must be constructed appropriately. The problem specifies an algorithm to construct a suitable triad $\\{e_r^i, e_\\theta^i, e_\\phi^i\\}$ from which $m^i$ is built. This triad defines a quasi-Kinnersley frame, which orients the coordinate system along a principal direction of the Weyl tensor.\n\nThe algorithm proceeds in the following steps:\n1.  **Determine the Principal Radial Direction $e_r^i$**: The principal directions of the Weyl tensor are related to the eigenvectors of the electric and magnetic parts. The algorithm specifies selecting a \"dominant\" direction. We diagonalize the electric part, $E_{ij}$, to find its real eigenvalues and corresponding orthonormal eigenvectors. The principal direction $e_r^i$ is chosen as the normalized eigenvector corresponding to the eigenvalue with the largest absolute value. This aligns $e_r^i$ with a principal axis of the electric part of the Weyl tensor.\n    \n    A numerical stability threshold, $\\epsilon$, is introduced. If the largest absolute eigenvalue of $E_{ij}$ is less than $\\epsilon$, the tensor is considered numerically zero, and the procedure is repeated for the magnetic part, $B_{ij}$. If $B_{ij}$ is also numerically zero, a fixed fallback direction, such as $(0,0,1)$, is used for $e_r^i$. This ensures a well-defined direction is always found.\n\n2.  **Construct an Orthonormal Spatial Triad $\\{e_r^i, e_\\theta^i, e_\\phi^i\\}$**: With $e_r^i$ established, we need to find two other orthonormal vectors, $e_\\theta^i$ and $e_\\phi^i$, that span the plane perpendicular to $e_r^i$. A robust method, based on the Gram-Schmidt process, is employed to ensure a deterministic and right-handed basis.\n    - Start with the normalized vector $v_1 = e_r^i$.\n    - Choose a fixed seed vector $s$, for instance, $s=(0,0,1)$. To avoid linear dependence, if $s$ is nearly collinear with $v_1$, another seed, e.g., $s=(1,0,0)$, is chosen.\n    - A vector $u_2$ orthogonal to $v_1$ is found by projecting $s$ onto $v_1$ and subtracting this projection from $s$: $u_2 = s - (s \\cdot v_1)v_1$. This vector is then normalized to yield $v_2 = e_\\theta^i$.\n    - The third vector, $v_3 = e_\\phi^i$, is constructed using the cross product to complete a right-handed system: $e_\\phi^i = e_r^i \\times e_\\theta^i$. Since $e_r^i$ and $e_\\theta^i$ are orthonormal by construction, $e_\\phi^i$ is also a unit vector and is orthogonal to both.\n\n3.  **Form the Complex Null Vector $m^i$**: From the spatial triad, the complex vector $m^i$ required for the $\\Psi_4$ calculation is defined as:\n    $$ m^i = \\frac{1}{\\sqrt{2}}(e_\\theta^i + i e_\\phi^i) $$\n    This vector is null with respect to the complexified spatial metric. The factor of $1/\\sqrt{2}$ is a standard normalization convention in the NP formalism. The spatial metric is assumed to be Euclidean, $\\gamma_{ij} = \\delta_{ij}$, at the point of extraction, so we do not need to distinguish between upper and lower indices.\n\n4.  **Compute $\\Psi_4$**: Finally, the Weyl scalar $\\Psi_4$ is computed by contracting the complex tensor $W_{ij} = E_{ij} - i B_{ij}$ with the complex conjugate of the vector $m^i$ twice:\n    $$ \\Psi_4 = \\sum_{i,j} W_{ij} \\bar{m}^i \\bar{m}^j $$\n    where $\\bar{m}^i = \\frac{1}{\\sqrt{2}}(e_\\theta^i - i e_\\phi^i)$. In matrix notation, this corresponds to the operation $\\bar{m}^T W \\bar{m}$. This final complex number provides the real part (plus-polarization) and the imaginary part (cross-polarization) of the outgoing gravitational wave strain's second time derivative.",
            "answer": "```python\nimport numpy as np\n\ndef compute_psi4(E, B, tol=1e-8):\n    \"\"\"\n    Computes the Weyl scalar Psi_4 from the electric (E) and magnetic (B)\n    parts of the Weyl tensor.\n    \"\"\"\n    \n    # Step 1: Determine the principal radial direction e_r\n    \n    # Try to find the direction from E\n    evals_E, evecs_E = np.linalg.eigh(E)\n    max_abs_eval_E = np.max(np.abs(evals_E))\n    \n    if max_abs_eval_E > tol:\n        # Use E's dominant eigenvector\n        idx = np.argmax(np.abs(evals_E))\n        e_r = evecs_E[:, idx]\n    else:\n        # E is numerically zero, try B\n        evals_B, evecs_B = np.linalg.eigh(B)\n        max_abs_eval_B = np.max(np.abs(evals_B))\n        \n        if max_abs_eval_B > tol:\n            # Use B's dominant eigenvector\n            idx = np.argmax(np.abs(evals_B))\n            e_r = evecs_B[:, idx]\n        else:\n            # Both E and B are numerically zero, use fallback\n            e_r = np.array([0.0, 0.0, 1.0])\n\n    # Ensure e_r is a unit vector (it should be from eigh, but good practice)\n    e_r = e_r / np.linalg.norm(e_r)\n\n    # Step 2: Construct an orthonormal spatial triad {e_r, e_theta, e_phi}\n    \n    # Choose a seed vector for Gram-Schmidt, avoiding collinearity with e_r\n    seed1 = np.array([0.0, 0.0, 1.0])\n    seed2 = np.array([1.0, 0.0, 0.0])\n    \n    # Check for collinearity with a tolerance\n    if np.abs(np.dot(e_r, seed1)) > 1.0 - 1e-6:\n        s = seed2\n    else:\n        s = seed1\n        \n    # Gram-Schmidt process to find e_theta\n    u_theta = s - np.dot(s, e_r) * e_r\n    e_theta = u_theta / np.linalg.norm(u_theta)\n    \n    # Cross product to find e_phi for a right-handed system\n    e_phi = np.cross(e_r, e_theta)\n    \n    # Step 3: Form the complex null vector m\n    m_vec = (e_theta + 1j * e_phi) / np.sqrt(2.0)\n    \n    # Step 4: Compute Psi_4\n    W_complex = E - 1j * B\n    m_bar = m_vec.conj()\n    \n    # Calculate Psi_4 = m_bar^T * W_complex * m_bar\n    # In numpy, this is sum(m_bar * (W @ m_bar)), as dot() conjugates the first arg.\n    psi4_complex = np.sum(m_bar * (W_complex @ m_bar))\n    \n    return [psi4_complex.real, psi4_complex.imag]\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: General nondegenerate\n        (np.array([[1.0, 0.2, 0.0], [0.2, -1.0, 0.0], [0.0, 0.0, 0.0]]),\n         np.array([[0.0, 0.3, 0.0], [0.3, 0.0, 0.0], [0.0, 0.0, 0.0]])),\n        \n        # Case B: Electric part degenerate, magnetic part nonzero\n        (np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n         np.array([[0.0, 0.5, 0.0], [0.5, 0.0, 0.0], [0.0, 0.0, 0.0]])),\n\n        # Case C: Nearly zero fields, testing fallback\n        (np.array([[1e-9, 0.0, 0.0], [0.0, -1e-9, 0.0], [0.0, 0.0, 0.0]]),\n         np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]))\n    ]\n\n    results = []\n    for E, B in test_cases:\n        result = compute_psi4(E, B)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Once the multipole moments of $\\Psi_4$ have been extracted, they must be converted into the observable strain polarizations, $h_+$ and $h_\\times$, as measured by a distant observer. This foundational exercise  requires you to derive the direct mathematical relationship, starting from the definition that $\\Psi_4$ is the second time-derivative of the strain and applying the appropriate projections using spin-weighted spherical harmonics.",
            "id": "3475833",
            "problem": "In asymptotically flat spacetimes, gravitational radiation measured far from the source can be characterized using the Newman–Penrose (NP) Weyl scalar $\\Psi_4$. Consider a numerical relativity simulation that provides the time series of radiative multipoles $\\Psi_4^{\\ell m}(t)$ for all $\\ell \\geq 2$ and $-\\ell \\leq m \\leq \\ell$ at future null infinity, where the multipoles are defined by the angular decomposition of the field according to\n$$\nr\\,\\Psi_4(t,\\theta,\\phi)=\\sum_{\\ell=2}^{\\infty}\\sum_{m=-\\ell}^{\\ell}\\Psi_4^{\\ell m}(t)\\,{}_{-2}Y_{\\ell m}(\\theta,\\phi),\n$$\nwith ${}_{-2}Y_{\\ell m}$ the spin-weighted spherical harmonics of spin weight $-2$. Assume asymptotic flatness and standard numerical relativity normalization and sign conventions for the NP tetrad, and take $t$ to denote retarded time. Let the complex strain be $h(t,\\theta,\\phi)=h_{+}(t,\\theta,\\phi)-i\\,h_{\\times}(t,\\theta,\\phi)$, and impose physically motivated integration conditions such that $h(t,\\theta,\\phi)\\to 0$ and $\\partial_t h(t,\\theta,\\phi)\\to 0$ as $t\\to -\\infty$ (no pre-existing radiation and no integration drift). Angles are measured in radians.\n\nStarting only from fundamental definitions (the relation between the NP Weyl scalar $\\Psi_4$, the Bondi news, and the metric strain in the radiation zone; the radiative $1/r$ falloff; and the orthonormality and completeness of the spin-weighted spherical harmonics), derive the observer’s gravitational-wave polarizations $h_{+}(t)$ and $h_{\\times}(t)$ at a fixed sky location specified by inclination $\\iota$ and azimuth $\\phi_0$. Include the correct overall $1/r$ scaling appropriate to future null infinity and express your final result in terms of the supplied multipoles $\\Psi_4^{\\ell m}(t)$ and the spin-weighted spherical harmonics evaluated at $(\\iota,\\phi_0)$.\n\nAnswer requirement:\n- Provide a single closed-form analytic expression for the complex strain $h(t;\\iota,\\phi_0)$ that encodes both $h_{+}$ and $h_{\\times}$ for the specified observer, expressed entirely in terms of $\\Psi_4^{\\ell m}(t)$, ${}_{-2}Y_{\\ell m}(\\iota,\\phi_0)$, and $r$.\n- The final answer must be a single analytic expression. Do not provide intermediate steps. Angles are in radians. No numerical rounding is required.",
            "solution": "The problem is to derive an expression for the complex gravitational-wave strain, $h(t;\\iota,\\phi_0)$, for an observer at a specific sky location $(\\iota, \\phi_0)$, given the multipole moments $\\Psi_4^{\\ell m}(t)$ of the Newman–Penrose Weyl scalar $\\Psi_4$. The derivation must begin from fundamental principles.\n\nThe starting point is the fundamental relationship in general relativity between the Weyl scalar $\\Psi_4$ and the complex gravitational-wave strain $h = h_{+} - i h_{\\times}$ in an asymptotically flat spacetime. For outgoing radiation at large distances $r$ from the source, described using a retarded time coordinate $t$, this relationship is given by:\n$$\n\\Psi_4(t,r,\\theta,\\phi) = \\frac{\\partial^2 h(t,r,\\theta,\\phi)}{\\partial t^2}\n$$\nIn the radiation zone, far from the source, both the Weyl scalar and the strain metric perturbation exhibit a characteristic falloff with distance. Their asymptotic expansions in inverse powers of the luminosity distance $r$ are:\n$$\nh(t,r,\\theta,\\phi) = \\frac{h^0(t,\\theta,\\phi)}{r} + \\mathcal{O}(r^{-2})\n$$\n$$\n\\Psi_4(t,r,\\theta,\\phi) = \\frac{\\Psi_4^0(t,\\theta,\\phi)}{r} + \\mathcal{O}(r^{-2})\n$$\nHere, $h^0(t,\\theta,\\phi)$ and $\\Psi_4^0(t,\\theta,\\phi)$ represent the strain and Weyl scalar fields, respectively, at future null infinity ($\\mathcal{I}^{+}$). The quantity $\\Psi_4^0$ is the time derivative of the Bondi news function. The problem provides the multipole decomposition of $r\\,\\Psi_4$, which is precisely $\\Psi_4^0(t,\\theta,\\phi)$.\n\nBy substituting these asymptotic forms into the differential relation and retaining only the leading-order terms (of order $r^{-1}$), we obtain the relationship between the fields at future null infinity:\n$$\n\\Psi_4^0(t,\\theta,\\phi) = \\frac{\\partial^2 h^0(t,\\theta,\\phi)}{\\partial t^2}\n$$\nTo find the strain $h^0$ from $\\Psi_4^0$, we must integrate this ordinary differential equation twice with respect to retarded time $t$. The first integration gives:\n$$\n\\frac{\\partial h^0(t,\\theta,\\phi)}{\\partial t} = \\int_{-\\infty}^{t} \\Psi_4^0(t', \\theta, \\phi) \\,dt' + C_1(\\theta, \\phi)\n$$\nThe problem specifies the boundary condition that $\\partial_t h \\to 0$ as $t \\to -\\infty$, which corresponds to the physical requirement of having no incoming radiation or initial burst of energy flux. This implies $\\frac{\\partial h^0}{\\partial t} \\to 0$ as $t \\to -\\infty$. Applying this condition determines the first integration constant, $C_1(\\theta, \\phi)$:\n$$\n\\lim_{t \\to -\\infty} \\frac{\\partial h^0(t,\\theta,\\phi)}{\\partial t} = \\int_{-\\infty}^{-\\infty} \\Psi_4^0(t', \\theta, \\phi) \\,dt' + C_1(\\theta, \\phi) = 0 + C_1(\\theta, \\phi)\n$$\nThus, we must have $C_1(\\theta, \\phi) = 0$.\n\nIntegrating a second time yields:\n$$\nh^0(t,\\theta,\\phi) = \\int_{-\\infty}^{t} dt' \\left( \\int_{-\\infty}^{t'} \\Psi_4^0(t'', \\theta, \\phi) \\,dt'' \\right) + C_2(\\theta, \\phi)\n$$\nThe second boundary condition, $h \\to 0$ as $t \\to -\\infty$, corresponds to the absence of pre-existing gravitational-wave strain. This implies $h^0 \\to 0$ as $t \\to -\\infty$. Applying this condition fixes the second integration constant, $C_2(\\theta, \\phi)$:\n$$\n\\lim_{t \\to -\\infty} h^0(t,\\theta,\\phi) = \\int_{-\\infty}^{-\\infty} dt' \\left( \\int_{-\\infty}^{t'} \\Psi_4^0(t'', \\theta, \\phi) \\,dt'' \\right) + C_2(\\theta, \\phi) = 0 + C_2(\\theta, \\phi)\n$$\nThis requires $C_2(\\theta, \\phi) = 0$. Consequently, the strain at future null infinity is given uniquely by the double time integral of $\\Psi_4^0$:\n$$\nh^0(t,\\theta,\\phi) = \\int_{-\\infty}^{t} dt' \\int_{-\\infty}^{t'} dt'' \\, \\Psi_4^0(t'', \\theta, \\phi)\n$$\nThe problem provides the multipole decomposition of $\\Psi_4^0(t,\\theta,\\phi) = r\\,\\Psi_4$ in the basis of spin-weighted spherical harmonics ${}_{-2}Y_{\\ell m}(\\theta,\\phi)$ of spin weight $s=-2$:\n$$\n\\Psi_4^0(t,\\theta,\\phi) = \\sum_{\\ell=2}^{\\infty}\\sum_{m=-\\ell}^{\\ell} \\Psi_4^{\\ell m}(t) \\,{}_{-2}Y_{\\ell m}(\\theta,\\phi)\n$$\nSubstituting this series into the integral for $h^0$, we get:\n$$\nh^0(t,\\theta,\\phi) = \\int_{-\\infty}^{t} dt' \\int_{-\\infty}^{t'} dt'' \\, \\left( \\sum_{\\ell=2}^{\\infty}\\sum_{m=-\\ell}^{\\ell} \\Psi_4^{\\ell m}(t'') \\,{}_{-2}Y_{\\ell m}(\\theta,\\phi) \\right)\n$$\nSince the integration is with respect to time only, the time-independent spherical harmonics ${}_{-2}Y_{\\ell m}(\\theta,\\phi)$ can be moved outside the integrals. Assuming the series converges sufficiently well to permit the interchange of summation and integration, we have:\n$$\nh^0(t,\\theta,\\phi) = \\sum_{\\ell=2}^{\\infty}\\sum_{m=-\\ell}^{\\ell} \\left( \\int_{-\\infty}^{t} dt' \\int_{-\\infty}^{t'} dt'' \\, \\Psi_4^{\\ell m}(t'') \\right) {}_{-2}Y_{\\ell m}(\\theta,\\phi)\n$$\nThis expression gives the strain for any direction $(\\theta,\\phi)$. The problem asks for the strain measured by an observer at a fixed sky location $(\\iota, \\phi_0)$. We obtain this by evaluating the angular functions at these specific coordinates:\n$$\nh^0(t; \\iota, \\phi_0) = \\sum_{\\ell=2}^{\\infty}\\sum_{m=-\\ell}^{\\ell} \\left( \\int_{-\\infty}^{t} dt' \\int_{-\\infty}^{t'} dt'' \\, \\Psi_4^{\\ell m}(t'') \\right) {}_{-2}Y_{\\ell m}(\\iota,\\phi_0)\n$$\nFinally, the full complex strain $h(t;\\iota,\\phi_0)$ at a finite, large distance $r$ is obtained by including the $1/r$ falloff factor. The problem's notation $h(t;\\iota,\\phi_0)$ implicitly includes this $r$ dependence. The fully explicit expression is:\n$$\nh(t;\\iota,\\phi_0) = \\frac{1}{r} h^0(t; \\iota, \\phi_0)\n$$\nThis leads to the final analytic expression for the complex strain. This single complex-valued function contains both gravitational wave polarizations, $h_{+}(t) = \\text{Re}[h(t;\\iota,\\phi_0)]$ and $h_{\\times}(t) = -\\text{Im}[h(t;\\iota,\\phi_0)]$.",
            "answer": "$$\n\\boxed{\\frac{1}{r} \\sum_{\\ell=2}^{\\infty}\\sum_{m=-\\ell}^{\\ell} \\left( \\int_{-\\infty}^{t} dt' \\int_{-\\infty}^{t'} dt'' \\, \\Psi_4^{\\ell m}(t'') \\right) {}_{-2}Y_{\\ell m}(\\iota,\\phi_0)}\n$$"
        },
        {
            "introduction": "The theoretical prescription of double time integration presents a significant numerical challenge, as small low-frequency errors in the computed $\\Psi_4$ can be amplified into large, unphysical drifts in the final strain waveform. This computational problem  provides a framework to test and compare practical strategies for fixing integration constants, a critical skill for producing physically reliable waveforms from numerical data.",
            "id": "3475820",
            "problem": "You are given a computational task arising in numerical relativity for extracting gravitational wave strain from the Newman–Penrose Weyl scalar. In an asymptotically flat region and in an appropriate null tetrad, the complex Weyl scalar satisfies the fundamental relation $\\Psi_4(t) = \\ddot{h}(t)$, where $h(t) = h_{+}(t) - i\\,h_{\\times}(t)$ is the complex strain and overdots denote time derivatives with respect to coordinate time $t$. Reconstructing $h(t)$ from $\\Psi_4(t)$ requires two time integrations and therefore introduces two integration constants that, if chosen poorly, can lead to low-frequency drift in $h(t)$. Your goal is to implement and compare strategies for fixing these integration constants and to quantify their impact on low-frequency drift using a synthetic test suite.\n\nYou must use a purely algorithmic setting with a known synthetic “true” real-valued strain $h_{\\mathrm{true}}(t)$ and construct $\\Psi_4(t)$ by numerically differentiating $h_{\\mathrm{true}}(t)$ twice. Then, for specified contaminations of $\\Psi_4(t)$, you must reconstruct an estimate $\\hat{h}(t)$ via double numerical integration and apply different choices of integration constants. Finally, you must evaluate a quantitative drift metric defined below.\n\nBase signal model. Let time be in seconds and angles in radians. Define the baseline strain as a real chirp\n$$\nh_{\\mathrm{chirp}}(t) = A(t)\\cos\\phi(t),\n$$\nwith slowly varying amplitude and phase given by\n$$\nA(t) = A_0\\left(1 + \\beta t\\right), \\quad \\phi(t) = \\phi_0 + \\omega_0 t + \\tfrac{1}{2}\\alpha t^2,\n$$\nfor $t \\in [0,T]$. Optionally, include a nonlinear memory-like step component\n$$\nh_{\\mathrm{mem}}(t) = \\Delta h \\cdot \\tfrac{1}{2}\\left[1 + \\tanh\\left(\\frac{t - t_m}{\\tau}\\right)\\right],\n$$\nso that the total “true” strain is $h_{\\mathrm{true}}(t) = h_{\\mathrm{chirp}}(t) + h_{\\mathrm{mem}}(t)$, where $h_{\\mathrm{mem}}(t)$ can be identically zero if $\\Delta h = 0$. Construct $\\Psi_4(t)$ by numerically approximating $\\ddot{h}_{\\mathrm{true}}(t)$ using a second-order accurate finite-difference scheme.\n\nContamination model. In the test suite, the computed $\\Psi_4(t)$ may be contaminated by an additive constant (a direct current bias) and/or a low-frequency sinusoid:\n$$\n\\Psi_4^{\\mathrm{obs}}(t) = \\ddot{h}_{\\mathrm{true}}(t) + c_{\\mathrm{bias}} + a_{\\mathrm{lf}}\\sin(\\omega_{\\mathrm{lf}} t).\n$$\n\nReconstruction via time-domain double integration. Let $\\hat{v}(t)$ denote the first integral of $\\Psi_4^{\\mathrm{obs}}(t)$ and $\\hat{h}_0(t)$ denote the second integral, both computed numerically by cumulative trapezoidal integration with zero initial conditions, i.e., $\\hat{v}(0) = 0$ and $\\hat{h}_0(0) = 0$. The general reconstructed strain is then\n$$\n\\hat{h}(t) = \\hat{h}_0(t) + a t + b,\n$$\nwhere $a$ and $b$ are the integration constants to be chosen by a strategy.\n\nStrategies for fixing the integration constants:\n- Strategy $\\mathsf{N}$ (naïve zero-initialization): Choose $a = 0$ and $b = 0$; equivalently, use $\\hat{h}(t) = \\hat{h}_0(t)$.\n- Strategy $\\mathsf{Z}$ (zero-mean constraints): Choose $a$ and $b$ such that the time averages over the full analysis window $[0,T]$ satisfy $\\langle \\hat{h}(t)\\rangle = 0$ and $\\langle \\dot{\\hat{h}}(t)\\rangle = 0$. Using $\\hat{v}(t)$ as the numerical approximation of $\\dot{\\hat{h}}_0(t)$, this implies\n$$\na = -\\langle \\hat{v}(t)\\rangle,\\quad b = -(\\langle \\hat{h}_0(t)\\rangle + a\\langle t\\rangle).\n$$\n- Strategy $\\mathsf{M}$ (early-time model matching): Assume an early-time model for the strain $h_{\\mathrm{model}}(t)$ over a short window $t \\in [0,t_{\\mathrm{match}}]$, interpretable as a post-Newtonian inspiral model. Choose $a$ and $b$ that minimize the least-squares misfit\n$$\n\\int_{0}^{t_{\\mathrm{match}}}\\left[\\hat{h}_0(t) + a t + b - h_{\\mathrm{model}}(t)\\right]^2 dt,\n$$\nwhich yields the normal equations for $a$ and $b$:\n$$\n\\begin{bmatrix}\n\\sum t^2 & \\sum t\\\\\n\\sum t & \\sum 1\n\\end{bmatrix}\n\\begin{bmatrix}\na\\\\\nb\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\sum \\left[h_{\\mathrm{model}}(t)-\\hat{h}_0(t)\\right]t\\\\\n\\sum \\left[h_{\\mathrm{model}}(t)-\\hat{h}_0(t)\\right]\n\\end{bmatrix},\n$$\nwhere the sums are discrete Riemann sums over the early-time window.\n\nLow-frequency drift metric. For each reconstruction strategy, compute the error $e(t) = \\hat{h}(t) - h_{\\mathrm{true}}(t)$. Let $\\mathcal{F}\\{e\\}(\\omega)$ denote the discrete Fourier transform (with angular frequency $\\omega$) and apply an ideal low-pass filter with cutoff angular frequency $\\omega_c$ by zeroing the Fourier components with $|\\omega| > \\omega_c$. Denote the inverse transform as $e_{\\mathrm{LF}}(t)$. Define the low-frequency drift metric as the root-mean-square\n$$\nD = \\sqrt{\\langle e_{\\mathrm{LF}}(t)^2\\rangle}.\n$$\n\nImplementation details and parameters. Use uniform sampling with $N$ samples over $[0,T]$, time step $\\Delta t = T/(N-1)$, and discrete Fourier transforms consistent with the sampling. Use the following default parameters, all in International System of Units (SI) unless otherwise stated:\n- Duration $T = 4$, samples $N = 16384$, time step $\\Delta t = T/(N-1)$, early-time matching window $t_{\\mathrm{match}} = 0.5$.\n- Chirp parameters: amplitude $A_0 = 10^{-21}$, amplitude growth rate $\\beta = 0.1$, initial phase $\\phi_0 = 0$, initial angular frequency $\\omega_0 = 40$, angular chirp rate $\\alpha = 30$.\n- Memory parameters: step size $\\Delta h$ and shape parameters $t_m$ and $\\tau$ specified per test case.\n- Contamination parameters: constant bias $c_{\\mathrm{bias}}$, low-frequency sinusoid amplitude $a_{\\mathrm{lf}}$, and angular frequency $\\omega_{\\mathrm{lf}}$ specified per test case.\n- Low-pass cutoff for the metric: $\\omega_c = 20$.\n\nTest suite. Your program must implement the three strategies $\\mathsf{N}$, $\\mathsf{Z}$, and $\\mathsf{M}$ and evaluate the low-frequency drift metric $D$ for each of the following three test cases:\n- Case $\\mathsf{A}$ (clean chirp): $\\Delta h = 0$, $c_{\\mathrm{bias}} = 0$, $a_{\\mathrm{lf}} = 0$.\n- Case $\\mathsf{B}$ (direct current offset in $\\Psi_4$): $\\Delta h = 0$, $c_{\\mathrm{bias}} = 5\\times 10^{-20}$, $a_{\\mathrm{lf}} = 0$.\n- Case $\\mathsf{C}$ (memory and low-frequency contamination): $\\Delta h = 2\\times 10^{-22}$, $t_m = 2$, $\\tau = 0.05$, $c_{\\mathrm{bias}} = 0$, $a_{\\mathrm{lf}} = 3\\times 10^{-20}$, $\\omega_{\\mathrm{lf}} = 5$.\n\nThe early-time model $h_{\\mathrm{model}}(t)$ for strategy $\\mathsf{M}$ must use the chirp part only, i.e., $h_{\\mathrm{model}}(t) = h_{\\mathrm{chirp}}(t)$, and the match must be performed on $t \\in [0,t_{\\mathrm{match}}]$.\n\nNumerical units and angle unit. Express all times in seconds, all angular frequencies in radians per second, and the strain is dimensionless. Angles in trigonometric functions are in radians.\n\nRequired program output. For each case in the order $\\mathsf{A}$, $\\mathsf{B}$, $\\mathsf{C}$, compute the three low-frequency drift metrics $D$ corresponding to strategies $\\mathsf{N}$, $\\mathsf{Z}$, and $\\mathsf{M}$. Your program should produce a single line of output containing a list of three lists, one per case, each inner list containing the three floating-point drift metrics in the order $\\left[D_{\\mathsf{N}}, D_{\\mathsf{Z}}, D_{\\mathsf{M}}\\right]$. For example, a syntactically valid output shape is\n$$\n\\left[\\left[d_{\\mathsf{A,N}}, d_{\\mathsf{A,Z}}, d_{\\mathsf{A,M}}\\right], \\left[d_{\\mathsf{B,N}}, d_{\\mathsf{B,Z}}, d_{\\mathsf{B,M}}\\right], \\left[d_{\\mathsf{C,N}}, d_{\\mathsf{C,Z}}, d_{\\mathsf{C,M}}\\right]\\right],\n$$\nwhere each $d_{\\cdot,\\cdot}$ is a floating-point number.",
            "solution": "The problem requires the implementation and comparison of three distinct strategies for reconstructing a gravitational wave strain signal, $h(t)$, from its second time derivative, represented by the Weyl scalar $\\Psi_4(t)$. The core challenge lies in managing the low-frequency drift introduced by the two required time integrations. The evaluation is performed on a synthetic test suite where the true signal, $h_{\\mathrm{true}}(t)$, is known, allowing for a quantitative assessment of each strategy's performance using a defined low-frequency drift metric, $D$.\n\nThe solution adheres to the following logical steps:\n1.  Generation of the true synthetic strain signal, $h_{\\mathrm{true}}(t)$.\n2.  Numerical computation of its second time derivative, $\\ddot{h}_{\\mathrm{true}}(t)$, and addition of specified contaminations to form the observable $\\Psi_4^{\\mathrm{obs}}(t)$.\n3.  Numerical double integration of $\\Psi_4^{\\mathrm{obs}}(t)$ to obtain an initial reconstructed strain, $\\hat{h}_0(t)$.\n4.  Application of three distinct strategies ($\\mathsf{N}$, $\\mathsf{Z}$, $\\mathsf{M}$) to determine the integration constants, yielding the final reconstructed strain $\\hat{h}(t)$.\n5.  Calculation of the low-frequency drift metric $D$ for each strategy to quantify its efficacy.\n\nThis process is repeated for three test cases with varying signal properties and contamination levels.\n\nFirst, we define the computational grid and the true signal. The analysis is performed on a uniform time grid $t_n = n \\Delta t$ for $n \\in \\{0, 1, \\dots, N-1\\}$, where the total duration is $T$, the number of samples is $N$, and the time step is $\\Delta t = T/(N-1)$.\n\nThe \"true\" strain, $h_{\\mathrm{true}}(t)$, is composed of a chirp component and an optional memory component:\n$$\nh_{\\mathrm{true}}(t) = h_{\\mathrm{chirp}}(t) + h_{\\mathrm{mem}}(t)\n$$\nThe chirp component, $h_{\\mathrm{chirp}}(t)$, represents the oscillatory signal from an inspiraling binary system and is given by:\n$$\nh_{\\mathrm{chirp}}(t) = A(t)\\cos\\phi(t)\n$$\nwith a linearly evolving amplitude $A(t)$ and a quadratically evolving phase $\\phi(t)$:\n$$\nA(t) = A_0(1 + \\beta t), \\quad \\phi(t) = \\phi_0 + \\omega_0 t + \\frac{1}{2}\\alpha t^2\n$$\nThe parameters are amplitude $A_0 = 10^{-21}$, growth rate $\\beta = 0.1$, initial phase $\\phi_0 = 0$, initial angular frequency $\\omega_0 = 40$ rad/s, and chirp rate $\\alpha = 30$ rad/s$^2$.\n\nThe memory component, $h_{\\mathrm{mem}}(t)$, models a persistent offset in the strain and is defined as:\n$$\nh_{\\mathrm{mem}}(t) = \\frac{\\Delta h}{2}\\left[1 + \\tanh\\left(\\frac{t - t_m}{\\tau}\\right)\\right]\n$$\nThis component is present only when its amplitude $\\Delta h$ is non-zero. The parameters $t_m$ and $\\tau$ control the center and width of the transition, respectively. For cases where $\\Delta h=0$, $h_{\\mathrm{mem}}(t)$ is identically zero.\n\nNext, we construct the observable $\\Psi_4^{\\mathrm{obs}}(t)$. The problem states the fundamental relation $\\Psi_4(t) = \\ddot{h}(t)$. We first compute the second time derivative of the sampled true strain, $h_{\\mathrm{true}}(t_n)$, using a second-order accurate numerical differentiation scheme. This is achieved by two successive applications of a second-order central difference formula for interior points, with boundary-appropriate stencils. Then, contaminations are added:\n$$\n\\Psi_4^{\\mathrm{obs}}(t) = \\ddot{h}_{\\mathrm{true}}(t) + c_{\\mathrm{bias}} + a_{\\mathrm{lf}}\\sin(\\omega_{\\mathrm{lf}} t)\n$$\nwhere $c_{\\mathrm{bias}}$ is a constant offset and the second term is a low-frequency sinusoidal noise.\n\nThe reconstruction process begins with double numerical integration of $\\Psi_4^{\\mathrm{obs}}(t)$. We use the cumulative trapezoidal rule. The first integration yields an intermediate quantity $\\hat{v}(t)$, which corresponds to the time derivative of the strain:\n$$\n\\hat{v}(t) = \\int_0^t \\Psi_4^{\\mathrm{obs}}(t') dt'\n$$\nNumerically, we compute $\\hat{v}(t_n)$ with the initial condition $\\hat{v}(0)=0$. The second integration yields the raw reconstructed strain, $\\hat{h}_0(t)$:\n$$\n\\hat{h}_0(t) = \\int_0^t \\hat{v}(t') dt'\n$$\nThis is computed numerically with $\\hat{h}_0(0)=0$. The general form of the reconstructed strain, accounting for the two constants of integration, is a polynomial of degree one:\n$$\n\\hat{h}(t) = \\hat{h}_0(t) + a t + b\n$$\nThe core of the problem is to determine the constants $a$ and $b$ using different strategies.\n\nStrategy $\\mathsf{N}$ (Naïve): This simplest strategy corresponds to assuming zero initial conditions for both integrations. This is equivalent to setting the integration constants to zero: $a=0$ and $b=0$. The reconstructed strain is simply $\\hat{h}(t) = \\hat{h}_0(t)$.\n\nStrategy $\\mathsf{Z}$ (Zero-mean): This strategy imposes physical constraints on the reconstructed strain and its derivative, requiring them to have zero mean over the entire time interval $[0, T]$. This leads to the conditions $\\langle \\hat{h}(t) \\rangle = 0$ and $\\langle \\dot{\\hat{h}}(t) \\rangle = 0$, where $\\langle \\cdot \\rangle$ denotes the discrete time average. Since $\\dot{\\hat{h}}(t) = \\hat{v}(t) + a$, the first condition implies $a = -\\langle \\hat{v}(t) \\rangle$. The second condition $\\langle \\hat{h}_0(t) + a t + b \\rangle = 0$ then determines $b$: $b = -(\\langle \\hat{h}_0(t) \\rangle + a \\langle t \\rangle)$.\n\nStrategy $\\mathsf{M}$ (Model-matching): This strategy leverages prior knowledge of the signal's behavior in an early-time window, $t \\in [0, t_{\\mathrm{match}}]$. It assumes an early-time model, $h_{\\mathrm{model}}(t)$, and finds the constants $a$ and $b$ that minimize the least-squares residual between the reconstructed strain and the model in this window. For this problem, $h_{\\mathrm{model}}(t) = h_{\\mathrm{chirp}}(t)$. Minimizing the functional $\\int_{0}^{t_{\\mathrm{match}}}[\\hat{h}_0(t) + a t + b - h_{\\mathrm{model}}(t)]^2 dt$ leads to a $2 \\times 2$ system of linear normal equations for $(a, b)$:\n$$\n\\begin{bmatrix}\n\\sum t^2 & \\sum t\\\\\n\\sum t & \\sum 1\n\\end{bmatrix}\n\\begin{bmatrix}\na\\\\\nb\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\sum \\left[h_{\\mathrm{model}}(t)-\\hat{h}_0(t)\\right]t\\\\\n\\sum \\left[h_{\\mathrm{model}}(t)-\\hat{h}_0(t)\\right]\n\\end{bmatrix}\n$$\nwhere the sums are discrete sums over the grid points within the time interval $[0, t_{\\mathrm{match}}]$. This system is solved for $a$ and $b$.\n\nFinally, we evaluate the performance of each strategy using the low-frequency drift metric, $D$. For each reconstructed $\\hat{h}(t)$, we first compute the error signal $e(t) = \\hat{h}(t) - h_{\\mathrm{true}}(t)$. We then apply an ideal low-pass filter to this error signal in the frequency domain. This involves:\n1.  Computing the discrete Fourier transform of $e(t)$, denoted $\\mathcal{F}\\{e\\}(\\omega)$.\n2.  Identifying the angular frequencies $\\omega_k$ corresponding to the Fourier coefficients.\n3.  Setting to zero all Fourier coefficients for which $|\\omega_k| > \\omega_c$, where the cutoff frequency is $\\omega_c = 20$ rad/s.\n4.  Computing the inverse discrete Fourier transform of the filtered spectrum to obtain the low-frequency error component, $e_{\\mathrm{LF}}(t)$.\n\nThe drift metric $D$ is the root-mean-square (RMS) value of this low-frequency error:\n$$\nD = \\sqrt{\\langle e_{\\mathrm{LF}}(t)^2 \\rangle}\n$$\nwhere the average is taken over the full time series. This metric quantifies the magnitude of the residual low-frequency drift not corrected by the chosen strategy. The entire procedure is applied to three test cases ($\\mathsf{A}$, $\\mathsf{B}$, $\\mathsf{C}$) with different parameters for memory and contamination, and the resulting nine values of $D$ are reported.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for gravitational wave reconstruction.\n    \"\"\"\n    # Default parameters from the problem statement\n    T = 4.0\n    N = 16384\n    t_match = 0.5\n    A0 = 1e-21\n    beta = 0.1\n    phi0 = 0.0\n    omega0 = 40.0\n    alpha = 30.0\n    omega_c = 20.0\n\n    # Time grid\n    t = np.linspace(0, T, N)\n    dt = T / (N - 1)\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Case A: Clean chirp\n        {\"name\": \"A\", \"delta_h\": 0.0, \"t_m\": 2.0, \"tau\": 0.05, \"c_bias\": 0.0, \"a_lf\": 0.0, \"omega_lf\": 5.0},\n        # Case B: DC offset in Psi4\n        {\"name\": \"B\", \"delta_h\": 0.0, \"t_m\": 2.0, \"tau\": 0.05, \"c_bias\": 5e-20, \"a_lf\": 0.0, \"omega_lf\": 5.0},\n        # Case C: Memory and low-frequency contamination\n        {\"name\": \"C\", \"delta_h\": 2e-22, \"t_m\": 2.0, \"tau\": 0.05, \"c_bias\": 0.0, \"a_lf\": 3e-20, \"omega_lf\": 5.0},\n    ]\n\n    # Model functions\n    def get_h_chirp(t_arr):\n        amp = A0 * (1.0 + beta * t_arr)\n        phase = phi0 + omega0 * t_arr + 0.5 * alpha * t_arr**2\n        return amp * np.cos(phase)\n\n    def get_h_mem(t_arr, delta_h, t_m, tau):\n        if delta_h == 0:\n            return np.zeros_like(t_arr)\n        return delta_h * 0.5 * (1.0 + np.tanh((t_arr - t_m) / tau))\n\n    # Helper function to compute the drift metric D\n    def calculate_drift_metric(h_hat, h_true, t_arr, N_samples, dt_val, omega_c_val):\n        error = h_hat - h_true\n        \n        # Fourier transform\n        error_fft = np.fft.fft(error)\n        omegas = 2 * np.pi * np.fft.fftfreq(N_samples, d=dt_val)\n        \n        # Low-pass filter\n        error_fft[np.abs(omegas) > omega_c_val] = 0.0\n        \n        # Inverse transform\n        e_lf = np.real(np.fft.ifft(error_fft))\n        \n        # RMS value\n        drift_metric = np.sqrt(np.mean(e_lf**2))\n        return drift_metric\n\n    # --- Main Loop ---\n    all_results = []\n    \n    for case_params in test_cases:\n        # 1. Generate true signal and its derivatives\n        h_chirp = get_h_chirp(t)\n        h_mem = get_h_mem(t, case_params[\"delta_h\"], case_params[\"t_m\"], case_params[\"tau\"])\n        h_true = h_chirp + h_mem\n        \n        # 2. Compute Psi4_obs\n        # Numerical second derivative using np.gradient twice\n        h_dot_true = np.gradient(h_true, dt)\n        h_ddot_true = np.gradient(h_dot_true, dt)\n        \n        psi4_obs = h_ddot_true + case_params[\"c_bias\"] + case_params[\"a_lf\"] * np.sin(case_params[\"omega_lf\"] * t)\n\n        # 3. Reconstruct h0_hat via double integration\n        v_hat = cumulative_trapezoid(psi4_obs, dx=dt, initial=0)\n        h0_hat = cumulative_trapezoid(v_hat, dx=dt, initial=0)\n        \n        case_results = []\n\n        # 4. Apply strategies and compute drift metric\n        \n        # Strategy N (Naive)\n        a_n, b_n = 0.0, 0.0\n        h_hat_n = h0_hat + a_n * t + b_n\n        d_n = calculate_drift_metric(h_hat_n, h_true, t, N, dt, omega_c)\n        case_results.append(d_n)\n        \n        # Strategy Z (Zero-mean)\n        a_z = -np.mean(v_hat)\n        b_z = -(np.mean(h0_hat) + a_z * np.mean(t))\n        h_hat_z = h0_hat + a_z * t + b_z\n        d_z = calculate_drift_metric(h_hat_z, h_true, t, N, dt, omega_c)\n        case_results.append(d_z)\n        \n        # Strategy M (Model-matching)\n        match_mask = t <= t_match\n        t_m_arr = t[match_mask]\n        N_m = len(t_m_arr)\n        \n        h_model_m = get_h_chirp(t_m_arr)\n        h0_hat_m = h0_hat[match_mask]\n        \n        # Set up and solve the normal equations\n        sum_t2 = np.sum(t_m_arr**2)\n        sum_t = np.sum(t_m_arr)\n        \n        matrix_A = np.array([[sum_t2, sum_t], [sum_t, N_m]])\n        \n        diff = h_model_m - h0_hat_m\n        vec_y = np.array([np.sum(diff * t_m_arr), np.sum(diff)])\n        \n        try:\n            a_m, b_m = np.linalg.solve(matrix_A, vec_y)\n        except np.linalg.LinAlgError:\n            # Fallback in case of singular matrix, though unlikely here\n            a_m, b_m = 0.0, 0.0\n\n        h_hat_m_full = h0_hat + a_m * t + b_m\n        d_m = calculate_drift_metric(h_hat_m_full, h_true, t, N, dt, omega_c)\n        case_results.append(d_m)\n        \n        all_results.append(case_results)\n    \n    # Format and print the final output\n    outer_list_str = [f\"[{','.join(f'{x:.6e}' for x in inner_list)}]\" for inner_list in all_results]\n    print(f\"[{','.join(outer_list_str)}]\")\n\nsolve()\n```"
        }
    ]
}