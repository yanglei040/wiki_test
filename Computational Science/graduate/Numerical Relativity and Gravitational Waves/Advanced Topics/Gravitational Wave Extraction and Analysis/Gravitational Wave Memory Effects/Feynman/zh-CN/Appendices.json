{
    "hands_on_practices": [
        {
            "introduction": "引力波记忆效应的一种来源是无约束的质量-能量（如中微子或光子）的各向异性辐射，这被称为“线性记忆”。本练习将通过一个伽玛射线暴（GRB）喷流的简化模型，来计算其产生的线性记忆效应的振幅。通过这个实践，你将把抽象的理论与具体的天体物理情景联系起来，并理解记忆效应是如何由源的能量通量所决定的 ()。",
            "id": "3476185",
            "problem": "一个伽玛射线暴（GRB）的中心引擎发射出两个相同的、超相对论性的锥形喷流，其轴线反向平行且与 $\\hat{z}$ 轴对齐。每个喷流的总（经射束修正的）能量为 $E_{\\mathrm{j}}$，由有效无质量的抛射物携带，这些抛射物被限制在半张角为 $\\theta_{\\mathrm{j}} \\ll 1$ 的锥体内，每个锥体内的单位立体角能量是均匀的，而锥体外的能量可以忽略不计。与光穿过源所需的时间相比，辐射在时间尺度上是脉冲式的，因此时域引力波波形可以近似为一个阶跃式变化（即引力波线性记忆效应）。源位于光度距离 $D$ 处，观测者的视线沿 $\\hat{x}$ 轴方向（即垂直于喷流轴线），这使得观测到的记忆效应振幅在所有观测角度中达到最大值。在远区的线性化广义相对论（GR）框架下进行计算，并将出流建模为到达未来类光无穷远的零性能量。\n\n从以流向未来类光无穷远的应力-能量通量为源的线性化爱因斯坦场方程的远区解及其横向无迹（TT）投影出发，推导该观测者所见的、由喷流引起的加极化线性记忆阶跃 $\\Delta h_{+}$ 在小 $\\theta_{\\mathrm{j}}$ 近似下的主导项表达式。保留至 $\\mathcal{O}(\\theta_{\\mathrm{j}}^{2})$ 阶的项，并假设两个喷流的贡献是线性叠加的。然后，使用你的表达式，针对以下典型的GRB喷流参数，计算 $|\\Delta h_{+}|$ 的一个上限值：\n- $E_{\\mathrm{j}} = 1.0 \\times 10^{51}\\ \\mathrm{erg}$，\n- $\\theta_{\\mathrm{j}} = 0.10\\ \\mathrm{rad}$，\n- $D = 1.0\\ \\mathrm{Gpc}$。\n\n将最终的振幅表示为一个纯数（无量纲应变），并将你的答案四舍五入到三位有效数字。",
            "solution": "...",
            "answer": "$$\n\\boxed{2.13 \\times 10^{-25}}\n$$"
        },
        {
            "introduction": "除了由源的抛射物产生的线性记忆外，引力波本身也携带能量和动量，因此它们自身也会产生引力，从而在时空中留下永久的印记，这被称为“非线性记忆”或“Christodoulou记忆”。本练习将提供一个亲手实践的数值模拟体验，通过对引力波能量通量进行积分来计算这种永久性的应变变化。这个过程揭示了记忆效应作为引力波非线性性质的一个深刻后果 ()。",
            "id": "2399205",
            "problem": "要求您编写一个完整、可运行的程序，通过对给定引力波信号的能量通量进行数值积分，以确定测试质量的永久位移，从而模拟类致密双星爆发产生的引力波记忆效应。请从基本且经过充分检验的基础出发：广义相对论（GR）中远场引力波的Isaacson有效应力-能量张量，以及自由臂对“+”偏振应变的准静态变化的测地线偏离响应。不要先验地假设任何记忆效应的专门公式；请从这些基础出发推导出您所需要的内容。\n\n假设和基本原理：\n- 在远场、平面波、横向无迹近似下工作。令 $h_+(t)$ 和 $h_\\times(t)$ 表示在探测器位置沿垂直入射波束测量的两个度规偏振应变。\n- 使用波携带的Isaacson能量通量（单位面积的功率），\n$$\nF(t) \\;=\\; \\frac{c^3}{16\\pi G}\\Big(\\dot{h}_+^2(t)+\\dot{h}_\\times^2(t)\\Big),\n$$\n其中 $G$ 是牛顿引力常数，$c$ 是光速，$\\dot{h}$ 表示 $h$ 的时间导数。\n- 对于与“+”偏振基准对齐的探测器臂，“+”应变的准静态净变化 $\\Delta h_+$ 会产生永久位移 $\\Delta L$，由下式给出\n$$\n\\frac{\\Delta L}{L} \\;=\\; \\frac{1}{2}\\,\\Delta h_+,\n$$\n其中 $L$ 是臂长。假设探测器平面与传播方向正交，且探测器臂与“+”偏振方向完全对齐。\n\n基于上述基础、远场中的 $1/R$ 振幅标度以及零无穷远处的能量守恒，推导最简单的视线方向平面波关系式，该关系式将测得通量的时间积分与沿视线方向的“+”偏振中的非线性（Christodoulou）记忆效应联系起来。使用该关系式计算永久位移 $\\Delta L$。\n\n信号模型和数值规格：\n- 使用均匀时间网格 $t \\in [-0.5,\\,0.5]$ 秒，步长 $\\Delta t = 10^{-4}$ 秒。\n- 对于给定情况，定义\n$$\nh_+(t) \\;=\\; A\\,\\exp\\!\\Big(-\\frac{t^2}{2\\sigma^2}\\Big)\\cos\\!\\big(2\\pi f_0 t\\big),\\qquad\nh_\\times(t) \\;=\\; \\epsilon\\,A\\,\\exp\\!\\Big(-\\frac{t^2}{2\\sigma^2}\\Big)\\sin\\!\\big(2\\pi f_0 t\\big),\n$$\n其中 $A$ 是应变振幅（无量纲），$\\sigma$ 是高斯宽度（单位：秒），$f_0$ 是载波频率（单位：赫兹），$\\epsilon \\in \\{0,1\\}$ 用于切换交叉偏振的存在与否。\n- 计算 $\\dot{h}_+$ 和 $\\dot{h}_\\times$ 相对于时间 $t$（单位：秒）的导数。您可以根据上述公式进行解析计算，或使用稳定的有限差分格式进行数值计算。\n- 使用梯形法则对所有时间积分进行数值积分。\n- 使用以下国际单位制（SI）中的常数：$G = 6.67430\\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$，$c = 2.99792458\\times 10^8\\,\\mathrm{m\\,s^{-1}}$，$1\\,\\mathrm{pc} = 3.085677581491367\\times 10^{16}\\,\\mathrm{m}$。\n\n输出量和单位：\n- 对于每个测试用例，以浮点数形式输出最终的永久位移 $\\Delta L$，单位为米。\n\n测试套件：\n对于所有情况，使用臂长 $L = 4000$ 米和距离 $R = 100$ 百万秒差距，其中 $1\\,\\mathrm{Mpc} = 10^6\\,\\mathrm{pc}$。四个测试用例如下：\n1. 情况 A（圆偏振爆发）：$A = 1.0\\times 10^{-21}$，$f_0 = 150$，$\\sigma = 0.05$，$\\epsilon = 1$，$R = 100$。\n2. 情况 B（无信号）：$A = 0.0$，$f_0 = 150$，$\\sigma = 0.05$，$\\epsilon = 1$，$R = 100$。\n3. 情况 C（仅“+”偏振爆发）：$A = 1.0\\times 10^{-21}$，$f_0 = 150$，$\\sigma = 0.05$，$\\epsilon = 0$，$R = 100$。\n4. 情况 D（更强的圆偏振爆发）：$A = 2.0\\times 10^{-21}$，$f_0 = 150$，$\\sigma = 0.05$，$\\epsilon = 1$，$R = 100$。\n\n所有物理输入均采用国际单位制（SI），除了以百万秒差距为单位的距离，您必须使用上面的秒差距定义将其转换为米。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个结果，形式为方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4]$）。每个 $x_i$ 都必须是一个浮点数，给出以米为单位的 $\\Delta L$ 值。",
            "solution": "所提出的问题是计算物理学中的一个有效练习，它基于广义相对论的原理。它要求对简化的爆发信号进行非线性引力波记忆效应的数值计算。我们将首先建立理论基础和要实现的具体公式，然后按照规定进行数值求解。\n\n该问题要求推导测量的引力波能量通量与应变的永久变化 $\\Delta h_+$（即Christodoulou记忆效应）之间的关系。这种效应源于引力波携带能量和动量，因此其自身也会产生引力。由Isaacson张量描述的波的应力-能量在爱因斯坦场方程中充当源，产生度规微扰的一个二阶非振荡分量，该分量在波通过后仍然存在。\n\nIsaacson能量通量由下式给出：\n$$\nF(t) = \\frac{c^3}{16\\pi G}\\left(\\dot{h}_+^2(t)+\\dot{h}_\\times^2(t)\\right)\n$$\n这表示波携带的单位面积单位时间的总能量。然而，记忆效应对于辐射的各向异性很敏感。对于沿传播路线的观察者来说，“+”偏振应变的永久变化 $\\Delta h_+$ 是由波应力的各向异性部分所产生的。\n\n严格的推导涉及求解以Isaacson张量为源的二阶爱因斯坦方程。这个过程很复杂。然而，问题要求的是“最简单的视线方向平面波关系”。从此类分析中得到的一个公认结果（其合理性可通过启发式方法证明）将记忆效应与两种偏振中“功率”差异的时间积分联系起来。这种表述正确地捕捉了物理预期，即纯圆偏振波（其关于传播方向是轴对称的）不应沿其轴线产生此类记忆效应。\n\n以距离源 $R$ 处测量的应变分量表示的适当关系式为：\n$$\n\\Delta h_+ = \\frac{R}{2c} \\int_{-\\infty}^{\\infty} \\left( \\dot{h}_+^2(t) - \\dot{h}_\\times^2(t) \\right) dt\n$$\n这个公式在量纲上是正确的。应变 $h$ 是无量纲的，所以 $\\dot{h}$ 的单位是 $s^{-1}$。积分的单位是 $s^{-1}$。前置因子 $R/c$ 的单位是 $s$，使得 $\\Delta h_+$ 成为无量纲量。物理标度也是正确的：对于距离为 $R$ 的源，应变振幅 $h \\propto 1/R$，所以 $\\dot{h}^2 \\propto 1/R^2$。因此积分项的标度为 $1/R^2$，总的 $\\Delta h_+ \\propto (R) \\cdot (1/R^2) = 1/R$，这与来自远源的度规微扰的预期相符。\n\n建立了关键公式后，我们进行数值实现。\n信号分量为：\n$$\nh_+(t) = A\\,\\exp\\left(-\\frac{t^2}{2\\sigma^2}\\right)\\cos\\left(\\omega_0 t\\right)\n$$\n$$\nh_\\times(t) = \\epsilon\\,A\\,\\exp\\left(-\\frac{t^2}{2\\sigma^2}\\right)\\sin\\left(\\omega_0 t\\right)\n$$\n其中 $\\omega_0 = 2\\pi f_0$。令包络为 $E(t) = A\\,\\exp(-t^2/(2\\sigma^2))$。\n其时间导数使用乘法法则解析计算得出：\n$$\n\\dot{h}_+(t) = \\dot{E}(t)\\cos(\\omega_0 t) - \\omega_0 E(t)\\sin(\\omega_0 t)\n$$\n$$\n\\dot{h}_\\times(t) = \\epsilon \\left( \\dot{E}(t)\\sin(\\omega_0 t) + \\omega_0 E(t)\\cos(\\omega_0 t) \\right)\n$$\n其中 $\\dot{E}(t) = - \\frac{t}{\\sigma^2} E(t)$。\n\n算法如下：\n1.  定义物理常数 $G$、$c$ 以及从秒差距到米的转换因子。\n2.  建立从 $-0.5\\,s$ 到 $0.5\\,s$ 的时间网格 $t$，步长为 $\\Delta t = 10^{-4}\\,s$。\n3.  对于每个具有参数 $(A, f_0, \\sigma, \\epsilon, R, L)$ 的测试用例：\n    a. 将距离 $R$ 从百万秒差距转换为米。\n    b. 在时间网格上定义包络函数 $E(t)$ 及其导数 $\\dot{E}(t)$。\n    c. 使用上述解析公式计算 $\\dot{h}_+(t)$ 和 $\\dot{h}_\\times(t)$ 的数组。\n    d. 计算被积函数 $I(t) = \\dot{h}_+^2(t) - \\dot{h}_\\times^2(t)$。\n    e. 使用梯形法则在时间网格上对 $I(t)$ 进行数值积分，求得 $\\int I(t) dt$。\n    f. 计算永久应变变化 $\\Delta h_+ = \\frac{R}{2c} \\int I(t) dt$。\n    g. 最后，计算探测器臂的永久位移：$\\Delta L = \\frac{1}{2} L \\Delta h_+$。\n4.  收集所有测试用例的结果，并以指定格式呈现。\n\n对于情况A（圆偏振，$\\epsilon=1$），被积函数 $\\dot{h}_+^2 - \\dot{h}_\\times^2$ 变成由 $\\cos(2\\omega_0 t)$ 和 $\\sin(2\\omega_0 t)$ 调制的项之和。由于载波频率 $f_0=150\\,Hz$ 远高于包络的特征频率（$1/\\sigma = 20\\,Hz$），对这些快速振荡项的积分预期会非常接近于零。同样的情况也适用于情况D。对于情况B，振幅 $A=0$，因此结果显然为零。对于情况C（线性偏振，$\\epsilon=0$），$\\dot{h}_\\times=0$，被积函数就是 $\\dot{h}_+^2$，它是严格非负的。其积分将不为零，从而产生一个可测量的记忆效应。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the gravitational-wave memory effect for several test cases.\n    \"\"\"\n\n    # Physical Constants in SI units\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    c = 2.99792458e8   # m s^-1\n    PC_TO_M = 3.085677581491367e16  # meters per parsec\n\n    # Shared parameters for all test cases\n    L_arm = 4000.0  # meters\n    R_dist_mpc = 100.0  # megaparsecs\n    R_dist_m = R_dist_mpc * 1e6 * PC_TO_M\n\n    # Numerical grid specifications\n    t_start = -0.5  # seconds\n    t_end = 0.5    # seconds\n    dt = 1e-4      # seconds\n    t = np.arange(t_start, t_end + dt, dt)\n\n    # Test suite: (A, f0, sigma, epsilon)\n    test_cases = [\n        # Case A: Circularly polarized burst\n        (1.0e-21, 150.0, 0.05, 1.0),\n        # Case B: No signal\n        (0.0, 150.0, 0.05, 1.0),\n        # Case C: Plus-only burst\n        (1.0e-21, 150.0, 0.05, 0.0),\n        # Case D: Stronger circular burst\n        (2.0e-21, 150.0, 0.05, 1.0),\n    ]\n\n    results = []\n    \n    for A, f0, sigma, epsilon in test_cases:\n        # If amplitude is zero, result is trivially zero\n        if A == 0.0:\n            results.append(0.0)\n            continue\n            \n        omega0 = 2.0 * np.pi * f0\n\n        # Define Gaussian envelope and its derivative\n        # E(t) = A * exp(-t^2 / (2*sigma^2))\n        envelope_t = A * np.exp(-t**2 / (2.0 * sigma**2))\n        \n        # dE/dt = - (t/sigma^2) * E(t)\n        envelope_dot_t = -(t / sigma**2) * envelope_t\n\n        # Calculate time derivatives of h_plus and h_cross\n        # h_plus(t) = envelope(t) * cos(omega0 * t)\n        # h_cross(t) = epsilon * envelope(t) * sin(omega0 * t)\n        \n        cos_t = np.cos(omega0 * t)\n        sin_t = np.sin(omega0 * t)\n        \n        # dh_plus/dt = dE/dt * cos(omega0*t) - omega0 * E(t) * sin(omega0*t)\n        h_plus_dot_t = envelope_dot_t * cos_t - omega0 * envelope_t * sin_t\n        \n        # dh_cross/dt = epsilon * (dE/dt * sin(omega0*t) + omega0 * E(t) * cos(omega0*t))\n        h_cross_dot_t = epsilon * (envelope_dot_t * sin_t + omega0 * envelope_t * cos_t)\n\n        # Integrand for memory calculation\n        # I(t) = (dh_plus/dt)^2 - (dh_cross/dt)^2\n        integrand = h_plus_dot_t**2 - h_cross_dot_t**2\n\n        # Numerically integrate using the trapezoidal rule\n        integral_val = np.trapz(integrand, t, dx=dt)\n        \n        # Calculate the permanent strain change (memory)\n        # Delta_h_plus = (R / (2*c)) * integral_val\n        delta_h_plus = (R_dist_m / (2.0 * c)) * integral_val\n\n        # Calculate the permanent arm displacement\n        # Delta_L = (1/2) * L * Delta_h_plus\n        delta_L = 0.5 * L_arm * delta_h_plus\n        \n        results.append(delta_L)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在理论和观测之间，数值相对论模拟扮演了关键角色，尤其是在预测双黑洞并合等事件的记忆效应时。然而，这些模拟通常不直接输出应变 $h(t)$，而是输出如Newman-Penrose标量 $\\Psi_4$ 等量，它对应于应变的二次时间导数。本练习模拟了从 $\\Psi_4$ 重建应变及其微弱记忆分量的真实挑战，要求你仔细处理积分过程中产生的数值漂移和噪声，这是数值相对论波形提取中的一个核心问题 ()。",
            "id": "3476243",
            "problem": "您的任务是设计并实现一个数值程序，以评估在从 Newman–Penrose 标量重构应变时，由数值漂移引起的引力波记忆污染。相关的物理和数值背景如下。\n\n基本原理与定义：\n- 在横向无迹 (TT) 规范下的未来零无穷远处，Newman–Penrose 标量 $\\,\\Psi_4(u)\\,$ 等于复引力波应变 $\\,h(u) = h_+(u) - i h_\\times(u)\\,$ 的负二次时间导数，即\n$$\\Psi_4(u) \\;=\\; -\\,\\frac{d^2 h(u)}{du^2}.$$\n- 引力波记忆是永久性位移，其特征是应变实部在整个爆发过程中的净变化：\n$$\\Delta h \\;=\\; \\lim_{u\\to +\\infty} \\mathrm{Re}\\,h(u) \\;-\\; \\lim_{u\\to -\\infty} \\mathrm{Re}\\,h(u).$$\n- 在数值相对论中，人们通过双重时间积分从 $\\,\\Psi_4(u)\\,$ 重构 $\\,h(u)\\,$，但未知的积分常数会在重构的应变中引入线性趋势（数值漂移）$\\,d_0 + d_1 u\\,$。一种标准的缓解方法是使用爆发之外的数据（无信号窗口）来拟合并减去此漂移。\n\n您的程序必须：\n1. 从一个包含平滑记忆阶跃和可选振荡分量的、具有物理动机的 $\\,h(u)\\,$ 构建合成测试数据 $\\,\\Psi_4(u)\\,$，然后向 $\\,\\Psi_4(u)\\,$ 添加高斯噪声。\n2. 通过对 $\\,\\Psi_4(u)\\,$ 进行双重积分（初始条件为零，即因果积分，$\\,h(u_0)=0\\,$ 且 $\\,\\dot{h}(u_0)=0\\,$）来重构初步应变 $\\,h_{\\mathrm{raw}}(u)\\,$。\n3. 在排除爆发的两个无信号时间窗口的并集上，使用最小二乘法对 $\\,h_{\\mathrm{raw}}(u)\\,$ 拟合线性漂移模型 $\\,d_0 + d_1 u\\,$ 并将其减去。\n4. 通过后期和早期校正后应变 $\\,h_{\\mathrm{corr}}(u)\\,$ 的平均值之差来估计恢复的记忆，并将恢复的记忆振幅与真实记忆振幅之间的绝对误差量化为污染。\n\n信号模型与构建细节：\n- 使用以秒为单位的推迟时间 $\\,u\\,$，并生成无量纲的应变量。\n- 使用误差函数定义平滑记忆阶跃：\n$$S(u) \\;=\\; \\tfrac{1}{2}\\,\\Bigl[1 + \\mathrm{erf}\\Bigl(\\frac{u-u_c}{\\sqrt{2}\\,\\sigma}\\Bigr)\\Bigr].$$\n设真实记忆为 $\\,\\Delta h\\,$，则应变的记忆贡献为 $\\,h_{\\mathrm{mem}}(u) = \\Delta h\\,S(u)\\,$。其二阶导数为\n$$\\frac{d^2 h_{\\mathrm{mem}}}{du^2}(u) \\;=\\; \\Delta h\\,\\frac{d^2 S}{du^2}(u) \\;=\\; -\\,\\Delta h\\,\\frac{u-u_c}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\sigma^2}\\Bigr),$$\n因此 $\\,\\Psi_4(u)\\,$ 的记忆部分为\n$$\\Psi_{4,\\mathrm{mem}}(u) \\;=\\; -\\,\\frac{d^2 h_{\\mathrm{mem}}}{du^2}(u) \\;=\\; \\Delta h\\,\\frac{u-u_c}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\sigma^2}\\Bigr).$$\n- （可选）在应变中包含一个振荡贡献\n$$h_{\\mathrm{osc}}(u) \\;=\\; A\\,\\sin(\\omega u)\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\Bigr),$$\n其高斯包络的宽度为 $\\,\\tau\\,$。记 $\\,f(u) = \\exp\\!\\bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\bigr)\\,$，$\\,s(u)=\\sin(\\omega u)\\,$，则有 $\\,f'(u) = -\\frac{u-u_c}{\\tau^2} f(u)\\,$ 和 $\\,f''(u) = \\bigl(\\frac{(u-u_c)^2}{\\tau^4}-\\frac{1}{\\tau^2}\\bigr)f(u)\\,$，以及 $\\,s''(u) = -\\omega^2 s(u)\\,$。因此，\n$$\\frac{d^2 h_{\\mathrm{osc}}}{du^2}(u) \\;=\\; A\\Bigl[f''(u)\\,s(u) + 2 f'(u)\\,\\omega\\cos(\\omega u) - \\omega^2 f(u)\\,s(u)\\Bigr],$$\n且 $\\,\\Psi_4(u)\\,$ 的振荡部分为\n$$\\Psi_{4,\\mathrm{osc}}(u) \\;=\\; -\\,\\frac{d^2 h_{\\mathrm{osc}}}{du^2}(u) \\;=\\; -A\\,f''(u)\\,s(u)\\;-\\;2A\\,\\omega f'(u)\\cos(\\omega u)\\;+\\;A\\,\\omega^2 f(u)\\,s(u).$$\n- 总的 $\\,\\Psi_4(u)\\,$ 为\n$$\\Psi_4(u) \\;=\\; \\Psi_{4,\\mathrm{mem}}(u) \\;+\\; \\Psi_{4,\\mathrm{osc}}(u) \\;+\\; n(u),$$\n其中 $\\,n(u)\\,$ 是均值为零、标准差为 $\\,\\sigma_n\\,$ 的高斯噪声，单位为 $\\,\\mathrm{s}^{-2}\\,$。\n\n数值重构与漂移去除：\n- 通过梯形累积积分计算 $\\,v(u) = \\int_{u_0}^u \\Psi_4(u')\\,du'\\,$（设 $\\,v(u_0) = 0\\,$），然后通过第二次梯形累积积分计算\n$$h_{\\mathrm{raw}}(u) \\;=\\; \\int_{u_0}^u v(u')\\,du'$$\n（设 $\\,h_{\\mathrm{raw}}(u_0) = 0\\,$）。由于未知的积分常数，这会引入一个任意的线性趋势 $\\,d_0 + d_1 u\\,$，必须对其进行估计和移除。\n- 对于给定的中心时间 $\\,u_c\\,$ 和排除半宽度 $\\,L\\,$（秒），将无信号窗口定义为 $[u_{\\min},\\,u_c-L]$ 和 $[u_c+L,\\,u_{\\max}]$ 的并集。在这些窗口中，通过最小二乘法将 $\\,d_0 + d_1 u\\,$ 拟合到 $\\,h_{\\mathrm{raw}}(u)\\,$，然后将其减去以获得 $\\,h_{\\mathrm{corr}}(u)\\,$。\n- 通过下式估计恢复的记忆：\n$$\\Delta h_{\\mathrm{rec}} \\;=\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_c+L,\\,u_{\\max}]} \\;-\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_{\\min},\\,u_c-L]},$$\n其中上划线表示在指定区间内的算术平均值。\n- 将记忆污染度量定义为绝对误差\n$$\\varepsilon \\;=\\; \\bigl|\\Delta h_{\\mathrm{rec}} - \\Delta h\\bigr|.$$\n\n实现要求：\n- 所有时间 $\\,u\\,$ 的单位必须是秒，所有输出均为无量纲的应变。三角函数的角度使用弧度。最终答案必须是无量綱的。\n- 使用梯形累积积分法执行数值积分。您可以使用稳健的库例程来进行累积梯形积分。\n- 使用固定的随机数生成器种子，以使噪声可复现。\n\n测试套件：\n为以下四种情况实现上述程序。每种情况都定义了一个均匀的时间网格 $\\,u \\in [u_{\\min}, u_{\\max}]\\,$（间距为 $\\,\\Delta u\\,$），以及信号模型和漂移拟合的参数。所有量均为实值。\n\n- 情况 $\\,1\\,$（理想路径）：\n  - $\\,u_{\\min} = -0.5\\,$, $\\,u_{\\max} = 0.5\\,$, $\\,\\Delta u = 10^{-3}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.02\\,$, $\\,\\Delta h = 2\\times 10^{-22}\\,$.\n  - $\\,A = 5\\times 10^{-22}\\,$, $\\,\\omega = 500\\,$, $\\,\\tau = 0.05\\,$.\n  - $\\,\\sigma_n = 10^{-23}\\,$, $\\,L = 0.08\\,$.\n\n- 情况 $\\,2\\,$（更强的振荡和噪声，更短的窗口）：\n  - $\\,u_{\\min} = -0.2\\,$, $\\,u_{\\max} = 0.2\\,$, $\\,\\Delta u = 5\\times 10^{-4}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.01\\,$, $\\,\\Delta h = 1\\times 10^{-22}\\,$.\n  - $\\,A = 8\\times 10^{-22}\\,$, $\\,\\omega = 800\\,$, $\\,\\tau = 0.03\\,$.\n  - $\\,\\sigma_n = 3\\times 10^{-23}\\,$, $\\,L = 0.04\\,$.\n\n- 情况 $\\,3\\,$（无振荡，更粗的采样，宽窗口）：\n  - $\\,u_{\\min} = -1.0\\,$, $\\,u_{\\max} = 1.0\\,$, $\\,\\Delta u = 2\\times 10^{-3}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.05\\,$, $\\,\\Delta h = 5\\times 10^{-22}\\,$.\n  - $\\,A = 0\\,$, $\\,\\omega = 0\\,$, $\\,\\tau = 0.1\\,$.\n  - $\\,\\sigma_n = 5\\times 10^{-24}\\,$, $\\,L = 0.2\\,$.\n\n- 情况 $\\,4\\,$（窄记忆，高频率，高噪声密度）：\n  - $\\,u_{\\min} = -0.05\\,$, $\\,u_{\\max} = 0.05\\,$, $\\,\\Delta u = 2\\times 10^{-4}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.005\\,$, $\\,\\Delta h = 5\\times 10^{-23}\\,$.\n  - $\\,A = 2\\times 10^{-22}\\,$, $\\,\\omega = 1000\\,$, $\\,\\tau = 0.01\\,$.\n  - $\\,\\sigma_n = 5\\times 10^{-23}\\,$, $\\,L = 0.015\\,$.\n\n最终输出要求：\n- 对每种情况，计算上面定义的污染度量 $\\,\\varepsilon\\,$。\n- 您的程序应生成单行输出，其中包含四个结果，形式为方括号括起来的逗号分隔列表。每个数字必须以科学计数法打印，并保留六位有效数字（例如，$\\,1.234560\\mathrm{e}{-22}\\,$）。输出格式必须为\n$$\\texttt{[}\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4\\texttt{]}.$$\n\n所有计算都必须以浮点运算完成。不允许用户输入；所有参数均如上所述。对高斯噪声使用固定的随机种子，以确保结果是确定性的。",
            "solution": "问题陈述已经过验证，被认为是科学上合理、定义明确且客观的。它提供了一套完整且一致的定义、物理模型、数值程序和参数，用于对引力波记忆污染进行定量分析。该问题与数值相对論领域直接相关，代表了一项标准的数据分析任务。因此，将提供一个解决方案。\n\n目标是实现一个数值程序，用以量化在存在数值漂移和噪声的情况下，从 Newman-Penrose 标量 $\\Psi_4(u)$ 重构应变 $h(u)$ 时，引力波记忆效应 $\\Delta h$ 的污染程度。该程序涉及合成一个真实的引力波信号，通过数值积分重构应变，校正伪影，然后测量恢复记忆中的误差。这个过程将对四个不同的测试案例执行。\n\n程序如下：\n\n1.  **信号合成**：对于每个测试案例，我们首先构建 Newman-Penrose 标量 $\\Psi_4(u)$ 的离散时间序列。\n    时间网格 $u$ 定义在区间 $[u_{\\min}, u_{\\max}]$上，具有均匀间距 $\\Delta u$。\n    总标量 $\\Psi_4(u)$ 是三个分量的和：\n    $$\\Psi_4(u) \\;=\\; \\Psi_{4,\\mathrm{mem}}(u) \\;+\\; \\Psi_{4,\\mathrm{osc}}(u) \\;+\\; n(u)$$\n    -   记忆分量 $\\Psi_{4,\\mathrm{mem}}(u)$ 来自于总振幅为 $\\Delta h$ 的應變中的一个平滑阶跃的二阶导数。其函数形式由以下公式给出：\n        $$\\Psi_{4,\\mathrm{mem}}(u) \\;=\\; \\Delta h\\,\\frac{u-u_c}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\sigma^2}\\Bigr)$$\n        其中 $u_c$ 是中心时间，$\\sigma$ 控制过渡的持续时间。\n    -   振荡分量 $\\Psi_{4,\\mathrm{osc}}(u)$ 模拟了并合事件期间的辐射。它是一个带有高斯包络的正弦信号的负二次时间导数：\n        $$h_{\\mathrm{osc}}(u) \\;=\\; A\\,\\sin(\\omega u)\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\Bigr)$$\n        使用乘法法则求导，并根据提供的包络 $f(u) = \\exp\\!\\bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\bigr)$ 及其导数 $f'(u)$ 和 $f''(u)$ 的定义，$\\Psi_4(u)$ 的振荡部分为：\n        $$\\Psi_{4,\\mathrm{osc}}(u) \\;=\\; -A\\Bigl[f''(u)\\,\\sin(\\omega u) + 2 f'(u)\\,\\omega\\cos(\\omega u) - \\omega^2 f(u)\\,\\sin(\\omega u)\\Bigr]$$\n        对于给定的测试案例，如果振幅 $A$ 为零，则此分量恒为零。\n    -   噪声分量 $n(u)$ 被建模为从均值为 0、标准差为 $\\sigma_n$ 的高斯（正态）分布中抽取的独立随机变量序列。为确保可复现性，对随机数生成器使用固定种子。\n\n2.  **应变重构**：复应变 $h(u)$ 通过 $\\Psi_4(u) = -d^2h/du^2$ 与 $\\Psi_4(u)$ 相关。由于问题指定所有量均为实数，我们只考虑单个实数极化。我们通过执行两次连续的不定积分从 $\\Psi_4(u)$ 重构应变。在存在未知积分常数的情况下，这将得到 $h(u) = -\\iint \\Psi_4(u') du' du' + d_0 + d_1 u$。在数值上，我们将初始条件设置为零，这对应于从 $u_0 = u_{\\min}$ 开始的因果积分。这将产生一个原始的、未校正的应变 $h_{\\mathrm{raw}}(u)$。积分使用累积梯形法则执行。\n    首先，我们计算第一个积分 $v(u)$：\n    $$v(u) = \\int_{u_{\\min}}^u \\Psi_4(u')\\,du'$$\n    然后，我们计算第二个积分，即原始应变 $h_{\\mathrm{raw}}(u)$：\n    $$h_{\\mathrm{raw}}(u) \\;=\\; \\int_{u_{\\min}}^u v(u')\\,du'$$\n    这些积分是使用累积梯形积分例程在数值上执行的。零初始条件 $v(u_{\\min})=0$ 和 $h_{\\mathrm{raw}}(u_{\\min})=0$ 通过选择因果积分边界来隐式处理。\n\n3.  **漂移校正**：原始应变 $h_{\\mathrm{raw}}(u)$ 被一个线性漂移项 $d_0 + d_1 u$ 污染，这是未知真实积分常数造成的伪影。必须估计并移除此漂移。我们对原始应变 $h_{\\mathrm{raw}}(u)$ 执行模型 $y(u) = d_0 + d_1 u$ 的线性最小二乘拟合。拟合仅在“无信号”窗口内的数据上执行，这些窗口被定义为时间区间 $[u_{\\min}, u_c - L]$ 和 $[u_c + L, u_{\\max}]$ 的并集。假设这些区域主要由漂移和噪声主导，因为主要的爆发信号局限于 $u_c$ 附近。\n    设 $(u_i, y_i)$ 为这些窗口中的离散数据对，其中 $y_i = h_{\\mathrm{raw}}(u_i)$。通过最小化残差平方和 $\\sum_i (y_i - (d_0 + d_1 u_i))^2$ 来找到系数 $d_0$ 和 $d_1$。\n    一旦找到最优的 $d_0$ 和 $d_1$，就从整个原始应变时间序列中减去漂移，以获得校正后的应变：\n    $$h_{\\mathrm{corr}}(u) \\;=\\; h_{\\mathrm{raw}}(u) - (d_0 + d_1 u)$$\n\n4.  **记忆恢复与污染测量**：引力波记忆是爆发过去后应变中的永久偏移。我们通过比较校正后应变 $h_{\\mathrm{corr}}(u)$ 在后期时间的平均值与早期时间的平均值来估计它。这些时间区间与用于漂移拟合的无信号窗口相同。\n    恢复的记忆 $\\Delta h_{\\mathrm{rec}}$ 计算如下：\n    $$\\Delta h_{\\mathrm{rec}} \\;=\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_c+L,\\,u_{\\max}]} \\;-\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_{\\min},\\,u_c-L]}$$\n    其中上划线表示算术平均值。\n    最后，污染度量 $\\varepsilon$ 被定义为恢复的记忆与用于生成信号的真实记忆振幅 $\\Delta h$ 之间的绝对误差：\n    $$\\varepsilon \\;=\\; \\bigl|\\Delta h_{\\mathrm{rec}} - \\Delta h\\bigr|$$\n\n这一完整的四步程序被实现并应用于问题陈述中提供的四个测试案例中的每一个，为每个案例得出一个 $\\varepsilon$ 值。最终结果随后按要求格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # A fixed seed for the random number generator ensures reproducibility.\n    rng = np.random.default_rng(42)\n\n    test_cases = [\n        # Case 1\n        {\n            \"u_min\": -0.5, \"u_max\": 0.5, \"du\": 1e-3,\n            \"u_c\": 0.0, \"sigma\": 0.02, \"delta_h\": 2e-22,\n            \"A\": 5e-22, \"omega\": 500.0, \"tau\": 0.05,\n            \"sigma_n\": 1e-23, \"L\": 0.08,\n        },\n        # Case 2\n        {\n            \"u_min\": -0.2, \"u_max\": 0.2, \"du\": 5e-4,\n            \"u_c\": 0.0, \"sigma\": 0.01, \"delta_h\": 1e-22,\n            \"A\": 8e-22, \"omega\": 800.0, \"tau\": 0.03,\n            \"sigma_n\": 3e-23, \"L\": 0.04,\n        },\n        # Case 3\n        {\n            \"u_min\": -1.0, \"u_max\": 1.0, \"du\": 2e-3,\n            \"u_c\": 0.0, \"sigma\": 0.05, \"delta_h\": 5e-22,\n            \"A\": 0.0, \"omega\": 0.0, \"tau\": 0.1,\n            \"sigma_n\": 5e-24, \"L\": 0.2,\n        },\n        # Case 4\n        {\n            \"u_min\": -0.05, \"u_max\": 0.05, \"du\": 2e-4,\n            \"u_c\": 0.0, \"sigma\": 0.005, \"delta_h\": 5e-23,\n            \"A\": 2e-22, \"omega\": 1000.0, \"tau\": 0.01,\n            \"sigma_n\": 5e-23, \"L\": 0.015,\n        },\n    ]\n\n    results = []\n    for case_params in test_cases:\n        epsilon = calculate_memory_contamination(case_params, rng)\n        results.append(epsilon)\n\n    # Format the final output string as specified.\n    output_str = \"[\" + \",\".join([f\"{res:.6e}\" for res in results]) + \"]\"\n    print(output_str)\n\ndef calculate_memory_contamination(params, rng):\n    \"\"\"\n    Performs the full analysis for a single test case.\n    \"\"\"\n    # Unpack parameters for clarity\n    u_min, u_max, du = params[\"u_min\"], params[\"u_max\"], params[\"du\"]\n    u_c, sigma, delta_h = params[\"u_c\"], params[\"sigma\"], params[\"delta_h\"]\n    A, omega, tau = params[\"A\"], params[\"omega\"], params[\"tau\"]\n    sigma_n, L = params[\"sigma_n\"], params[\"L\"]\n\n    # 1. Signal Synthesis\n    # Create time grid\n    num_points = int(round((u_max - u_min) / du)) + 1\n    u = np.linspace(u_min, u_max, num=num_points)\n\n    # Memory component of Psi_4\n    u_rel = u - u_c\n    psi4_mem_prefactor = delta_h / (np.sqrt(2 * np.pi) * sigma**3)\n    psi4_mem = psi4_mem_prefactor * u_rel * np.exp(-u_rel**2 / (2 * sigma**2))\n\n    # Oscillatory component of Psi_4\n    if A != 0:\n        f = np.exp(-u_rel**2 / (2 * tau**2))\n        f_prime = -u_rel / tau**2 * f\n        f_double_prime = (u_rel**2 / tau**4 - 1 / tau**2) * f\n        \n        s = np.sin(omega * u)\n        c = np.cos(omega * u)\n        \n        d2h_osc_du2 = A * (f_double_prime * s + 2 * f_prime * omega * c - omega**2 * f * s)\n        psi4_osc = -d2h_osc_du2\n    else:\n        psi4_osc = np.zeros_like(u)\n\n    # Noise component\n    noise = rng.normal(loc=0.0, scale=sigma_n, size=len(u))\n\n    # Total Psi_4\n    psi4 = psi4_mem + psi4_osc + noise\n\n    # 2. Strain Reconstruction\n    # Double cumulative trapezoidal integration\n    v = cumulative_trapezoid(psi4, x=u, initial=0.0)\n    h_raw = cumulative_trapezoid(v, x=u, initial=0.0)\n\n    # 3. Drift Correction\n    # Define no-signal windows for fitting\n    early_fit_mask = u <= (u_c - L)\n    late_fit_mask = u >= (u_c + L)\n    fit_mask = early_fit_mask | late_fit_mask\n\n    # Get data points for the fit\n    u_fit = u[fit_mask]\n    h_raw_fit = h_raw[fit_mask]\n\n    # Perform linear least-squares fit: h_raw = d0 + d1*u\n    # The model matrix columns correspond to d0 (ones) and d1 (u)\n    A_matrix = np.vstack([np.ones_like(u_fit), u_fit]).T\n    coeffs, _, _, _ = np.linalg.lstsq(A_matrix, h_raw_fit, rcond=None)\n    d0, d1 = coeffs[0], coeffs[1]\n\n    # Subtract the fitted drift\n    h_corr = h_raw - (d0 + d1 * u)\n    \n    # 4. Memory Recovery and Contamination Measurement\n    # The averaging windows are the same as the fit windows\n    mean_early = np.mean(h_corr[early_fit_mask])\n    mean_late = np.mean(h_corr[late_fit_mask])\n    \n    delta_h_rec = mean_late - mean_early\n    \n    # Calculate contamination metric\n    epsilon = np.abs(delta_h_rec - delta_h)\n    \n    return epsilon\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}