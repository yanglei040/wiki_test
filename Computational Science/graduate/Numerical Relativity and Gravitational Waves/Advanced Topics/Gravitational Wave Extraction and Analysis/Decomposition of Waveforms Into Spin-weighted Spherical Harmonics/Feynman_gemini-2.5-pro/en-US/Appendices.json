{
    "hands_on_practices": [
        {
            "introduction": "Accurately projecting a gravitational waveform onto a basis of spin-weighted spherical harmonics hinges on the precise numerical evaluation of integrals over the sphere. This exercise guides you through the process of designing an optimal quadrature grid. By determining the minimal number of sampling points required for exact integration of band-limited functions, you will build a foundational tool for efficient and accurate spectral analysis .",
            "id": "3471575",
            "problem": "You are tasked with constructing and verifying a numerical quadrature on the unit $2$-sphere $S^2$ that exactly integrates the inner products of spin-weighted spherical harmonics up to a maximum harmonic degree. Your program must implement a tensor-product quadrature of the following form: Gauss–Legendre quadrature in polar angle and an equally spaced trapezoidal rule in azimuthal angle. The goal is to determine, by first-principles reasoning, the minimal number of sample points required to guarantee exact numerical evaluation of all inner products of band-limited spin-weighted spherical harmonics up to a specified band-limit, and to verify exactness numerically for a small test suite. All angles must be in radians.\n\nDefinitions and foundational facts to use:\n- Spin-weighted spherical harmonics ${}_sY_{\\ell m}(\\theta,\\phi)$ are eigenfunctions on $S^2$ that generalize scalar spherical harmonics to spin weight $s \\in \\mathbb{Z}$. For any fixed spin weight $s$, they satisfy the orthonormality relation\n$$\n\\int_0^{2\\pi}\\!\\!\\int_0^\\pi {}_sY_{\\ell m}(\\theta,\\phi)\\,{}_sY_{\\ell' m'}^*(\\theta,\\phi)\\,\\sin\\theta\\,d\\theta\\,d\\phi \\;=\\; \\delta_{\\ell\\ell'}\\,\\delta_{mm'}.\n$$\n- The inner product integral separates into an azimuthal ($\\phi$) part involving complex exponentials $e^{i m \\phi}$ and a polar ($\\theta$) part involving associated angle dependence. A uniform trapezoidal rule on $\\phi$ exactly integrates all complex exponentials $e^{i n \\phi}$ up to a given highest frequency when enough points are used. A Gauss–Legendre quadrature on $x=\\cos\\theta$ integrates polynomials in $x$ exactly up to a degree determined by the number of nodes.\n- For products of spin-weighted spherical harmonics bounded by $\\ell\\le\\ell_{\\max}$, the azimuthal dependence is band-limited to frequencies $|m|\\le\\ell_{\\max}$, and the polar dependence of the product can be expressed (after the change of variable $x=\\cos\\theta$) as a polynomial in $x$ of degree at most $2\\ell_{\\max}$.\n\nTasks:\n1. Derive, from the above foundational facts, the minimal number of azimuthal samples $N_\\phi$ and polar samples $N_\\theta$ needed so that the tensor-product quadrature exactly integrates all inner products of ${}_sY_{\\ell m}$ and ${}_sY_{\\ell' m'}^*$ for $|s|\\le \\ell\\le\\ell_{\\max}$ and $-\\ell\\le m\\le \\ell$. The derivation should be purely mathematical and should not rely on shortcut formulas beyond the stated foundational facts. The unit of angle throughout is radians.\n2. Implement a program that:\n   - Constructs the Gauss–Legendre quadrature of order $N_\\theta$ for $x\\in[-1,1]$ corresponding to $\\theta=\\arccos x$.\n   - Constructs an equally spaced azimuthal grid of $N_\\phi$ points on $[0,2\\pi)$ with uniform weights (trapezoidal rule).\n   - Evaluates ${}_sY_{\\ell m}(\\theta,\\phi)$ using the Wigner small-$d$ matrix representation and verifies the numerical exactness of the inner products by computing the discrete quadrature sums\n   $$\n   \\sum_{k=0}^{N_\\phi-1} w_\\phi \\sum_{i=1}^{N_\\theta} w_{\\theta,i}\\;{}_sY_{\\ell m}(\\theta_i,\\phi_k)\\;{}_sY_{\\ell' m'}^*(\\theta_i,\\phi_k),\n   $$\n   and comparing to $\\delta_{\\ell\\ell'}\\,\\delta_{mm'}$. Your program must restrict to $\\ell\\ge |s|$ because ${}_sY_{\\ell m}$ vanish otherwise.\n3. For each test in the suite, your program must report:\n   - The minimal number of sample points $N_{\\text{points}}=N_\\theta N_\\phi$ deduced from your derivation in item $1$.\n   - The maximum absolute error over all inner products tested, computed as the largest absolute difference between the discrete quadrature value and the exact Kronecker delta value.\n\nTest suite parameters:\n- Use the following $(\\ell_{\\max},s)$ pairs to exercise different regimes:\n  - $(\\ell_{\\max},s)=(0,0)$.\n  - $(\\ell_{\\max},s)=(2,-2)$.\n  - $(\\ell_{\\max},s)=(3,1)$.\n  - $(\\ell_{\\max},s)=(4,0)$.\nAll angles must be in radians. Use a numerical tolerance suitable for double precision, and ensure the verification compares floating-point values.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases aggregated as a comma-separated list enclosed in square brackets. Each test case result must be a two-element list of the form $[N_{\\text{points}},\\varepsilon]$, where $N_{\\text{points}}$ is an integer and $\\varepsilon$ is a floating-point number equal to the maximum absolute error as specified above. For example: $[[N_1,\\varepsilon_1],[N_2,\\varepsilon_2],[N_3,\\varepsilon_3],[N_4,\\varepsilon_4]]$.",
            "solution": "The task is to determine the minimal number of quadrature points for the exact integration of inner products of spin-weighted spherical harmonics, ${}_sY_{\\ell m}$, up to a band-limit $\\ell_{\\max}$, and to verify this finding numerically. The specified quadrature is a tensor product of a Gauss-Legendre rule for the polar angle $\\theta$ and an equally-spaced trapezoidal rule for the azimuthal angle $\\phi$.\n\nThe orthonormality integral is given by:\n$$\nI = \\int_0^{2\\pi} d\\phi \\int_0^\\pi d\\theta \\, \\sin\\theta \\, {}_sY_{\\ell m}(\\theta,\\phi) \\, {}_sY_{\\ell' m'}^*(\\theta,\\phi) = \\delta_{\\ell\\ell'} \\delta_{mm'}\n$$\nWe will first derive the minimal required number of points, $N_\\phi$ and $N_\\theta$, based on the foundational facts provided in the problem statement.\n\n**Derivation of Minimal Quadrature Points**\n\nThe derivation proceeds by analyzing the azimuthal and polar parts of the integral separately.\n\n**1. Azimuthal Quadrature ($N_\\phi$)**\n\nThe spin-weighted spherical harmonic has the form ${}_sY_{\\ell m}(\\theta,\\phi) \\propto d^\\ell_{m,s}(\\theta) e^{im\\phi}$, where $d^\\ell_{m,s}(\\theta)$ is the Wigner small-d matrix. The integrand, ${}_sY_{\\ell m}(\\theta,\\phi)\\,{}_sY_{\\ell' m'}^*(\\theta,\\phi)$, therefore has an azimuthal dependence of the form $e^{im\\phi} (e^{im'\\phi})^* = e^{i(m-m')\\phi}$.\n\nThe problem requires a single quadrature grid that is exact for all inner products with $\\ell, \\ell' \\le \\ell_{\\max}$. The harmonic indices $m$ and $m'$ are bounded by $|m| \\le \\ell \\le \\ell_{\\max}$ and $|m'| \\le \\ell' \\le \\ell_{\\max}$. The frequency of the azimuthal integrand is $k = m-m'$. The range of possible frequencies is therefore:\n$$\n-\\ell_{\\max} - \\ell_{\\max} \\le m - m' \\le \\ell_{\\max} - (-\\ell_{\\max}) \\implies -2\\ell_{\\max} \\le k \\le 2\\ell_{\\max}\n$$\nWe must choose the number of trapezoidal points, $N_\\phi$, to exactly integrate any function of the form $e^{ik\\phi}$ for all integer frequencies $k$ in the range $[-2\\ell_{\\max}, 2\\ell_{\\max}]$.\n\nThe $N_\\phi$-point trapezoidal rule approximation of the integral $\\int_0^{2\\pi} f(\\phi) d\\phi$ is $\\frac{2\\pi}{N_\\phi} \\sum_{j=0}^{N_\\phi-1} f(\\phi_j)$, where $\\phi_j = 2\\pi j / N_\\phi$. For the function $f(\\phi) = e^{ik\\phi}$, the exact integral is $\\int_0^{2\\pi} e^{ik\\phi} d\\phi = 2\\pi \\delta_{k0}$. The numerical quadrature yields:\n$$\n\\frac{2\\pi}{N_\\phi} \\sum_{j=0}^{N_\\phi-1} e^{ik(2\\pi j/N_\\phi)} = \\frac{2\\pi}{N_\\phi} \\sum_{j=0}^{N_\\phi-1} \\left(e^{i2\\pi k/N_\\phi}\\right)^j\n$$\nThis geometric series sums to $N_\\phi$ if $k$ is an integer multiple of $N_\\phi$, and to $0$ otherwise. Thus, the numerical integral evaluates to $2\\pi$ if $k=p N_\\phi$ for some integer $p$, and $0$ otherwise.\n\nFor the quadrature to be exact for all frequencies $|k| \\le 2\\ell_{\\max}$, it must match the true integral value ($2\\pi$ for $k=0$, $0$ otherwise). This requires that no non-zero frequency in our range be a multiple of $N_\\phi$. This condition is satisfied if $|k| < N_\\phi$ for all non-zero $k$ in the range. The maximum frequency magnitude is $2\\ell_{\\max}$. Therefore, we must have $N_\\phi > 2\\ell_{\\max}$. The minimal integer number of points is:\n$$\nN_\\phi = 2\\ell_{\\max} + 1\n$$\n\n**2. Polar Quadrature ($N_\\theta$)**\n\nThe polar integral has the form $\\int_0^\\pi F(\\theta) \\sin\\theta d\\theta$. After the change of variables $x = \\cos\\theta$, $dx = -\\sin\\theta d\\theta$, the integral becomes $\\int_{-1}^1 F(\\arccos x) dx$.\n\nThe problem states that the polar part of the integrand, which is proportional to the product $d^\\ell_{m,s}(\\theta) d^{\\ell'}_{m',s}(\\theta)$, can be expressed as a polynomial in $x = \\cos\\theta$ of degree at most $2\\ell_{\\max}$, since $\\ell, \\ell' \\le \\ell_{\\max}$.\n\nA Gauss-Legendre quadrature with $N_\\theta$ points (nodes) is designed to exactly integrate any polynomial of degree up to $2N_\\theta - 1$. To guarantee exactness for our integrand, the degree of polynomial that the rule can handle must be at least the maximal degree of our integrand polynomial. This gives the condition:\n$$\n2N_\\theta - 1 \\ge 2\\ell_{\\max}\n$$\nSolving for $N_\\theta$ yields $2N_\\theta \\ge 2\\ell_{\\max} + 1$, or $N_\\theta \\ge \\ell_{\\max} + 1/2$. Since $N_\\theta$ must be an integer, the minimal number of polar quadrature points is:\n$$\nN_\\theta = \\ell_{\\max} + 1\n$$\n\nIn summary, the minimal number of quadrature points required for the exact integration of all inner products with $\\ell, \\ell' \\le \\ell_{\\max}$ is $N_\\theta = \\ell_{\\max} + 1$ and $N_\\phi = 2\\ell_{\\max} + 1$. The total number of points on the sphere is $N_{\\text{points}} = N_\\theta N_\\phi = (\\ell_{\\max}+1)(2\\ell_{\\max}+1)$.\n\n**Numerical Implementation and Verification**\n\nThe verification algorithm is structured as follows:\n1.  For a given test case $(\\ell_{\\max}, s)$, calculate the required minimal grid sizes $N_\\theta = \\ell_{\\max} + 1$ and $N_\\phi = 2\\ell_{\\max} + 1$.\n2.  Construct the quadrature grid. The $N_\\theta$ polar angles $\\theta_i$ and weights $w_{\\theta, i}$ are derived from the nodes and weights of the $N_\\theta$-point Gauss-Legendre quadrature on $x \\in [-1,1]$. The nodes $x_i$ give $\\theta_i = \\arccos(x_i)$, and the weights $w_{\\theta,i}$ are used directly. The $N_\\phi$ azimuthal angles are $\\phi_k = 2\\pi k / N_\\phi$ for $k=0, \\dots, N_\\phi-1$, with a uniform weight $w_\\phi = 2\\pi/N_\\phi$.\n3.  Implement a function to compute ${}_sY_{\\ell m}(\\theta,\\phi)$. This is based on the Wigner small-d matrix representation:\n    $$\n    {}_sY_{\\ell m}(\\theta,\\phi) = \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,s}(\\theta) e^{im\\phi}\n    $$\n    The Wigner function $d^\\ell_{m,s}(\\theta)$ is computed using its explicit summation formula. To maintain numerical stability with the factorial terms, computations are performed using the logarithm of the gamma function (`gammaln`).\n4.  Iterate through all valid mode combinations: $\\ell, \\ell' \\in [|s|, \\ell_{\\max}]$ and $m \\in [-\\ell, \\ell], m' \\in [-\\ell', \\ell']$.\n5.  For each combination $(\\ell, m, \\ell', m')$, compute the numerical inner product by summing over the quadrature grid:\n    $$\n    I_{\\text{numeric}} = w_\\phi \\sum_{k=0}^{N_\\phi-1} \\sum_{i=1}^{N_\\theta} w_{\\theta,i}\\;{}_sY_{\\ell m}(\\theta_i,\\phi_k)\\;{}_sY_{\\ell' m'}^*(\\theta_i,\\phi_k)\n    $$\n6.  Compare $I_{\\text{numeric}}$ to the exact analytical value, $I_{\\text{exact}} = \\delta_{\\ell\\ell'}\\,\\delta_{mm'}$. The absolute error $|I_{\\text{numeric}} - I_{\\text{exact}}|$ is recorded.\n7.  The maximum absolute error found across all mode combinations is reported for the test case, along with the total number of grid points, $N_{\\text{points}} = N_\\theta N_\\phi$. The expected error should be on the order of floating-point machine precision, confirming the exactness of the quadrature.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre, gammaln\nimport math\n\ndef wigner_d(l, m, s, theta):\n    \"\"\"\n    Computes the Wigner small-d matrix d^l_{m,s}(theta) using the summation formula.\n    Numerically stable implementation using log-gamma for factorials.\n    The angles theta are expected in radians.\n    \"\"\"\n    if np.abs(m) > l or np.abs(s) > l:\n        return np.zeros_like(theta)\n\n    # Use log-gamma to handle large numbers from factorials.\n    # gammaln(n+1) = log(n!)\n    log_prefactor = 0.5 * (gammaln(l + m + 1) + gammaln(l - m + 1) + gammaln(l + s + 1) + gammaln(l - s + 1))\n\n    # Summation range for k\n    k_min = int(max(0, s - m))\n    k_max = int(min(l + s, l - m))\n\n    d_values = np.zeros_like(theta, dtype=float)\n    \n    # Pre-compute trigonometric terms\n    cos_theta_half = np.cos(theta / 2.0)\n    sin_theta_half = np.sin(theta / 2.0)\n    \n    for k in range(k_min, k_max + 1):\n        log_term = (\n            log_prefactor\n            - gammaln(k + 1)\n            - gammaln(l + s - k + 1)\n            - gammaln(l - m - k + 1)\n            - gammaln(m - s + k + 1)\n        )\n        \n        # Power terms. Special handling for base=0 to avoid log(0).\n        # Since theta is from arccos of Legendre roots in (-1,1), theta is in (0,pi).\n        # cos_theta_half and sin_theta_half will be in (0,1).\n        pow1 = 2 * l + s - m - 2 * k\n        pow2 = m - s + 2 * k\n        \n        log_term += pow1 * np.log(cos_theta_half)\n        log_term += pow2 * np.log(sin_theta_half)\n\n        term = (-1)**k * np.exp(log_term)\n        d_values += term\n        \n    return d_values\n\ndef sYlm(s, l, m, theta, phi):\n    \"\"\"\n    Computes spin-weighted spherical harmonic sYlm on a grid of (theta, phi).\n    theta is a 1D array of size N_theta.\n    phi is a 1D array of size N_phi.\n    Returns a 2D array of shape (N_theta, N_phi).\n    \"\"\"\n    norm = math.sqrt((2 * l + 1) / (4 * np.pi))\n    d_vals = wigner_d(l, m, s, theta)\n    exp_vals = np.exp(1j * m * phi)\n    \n    # Use broadcasting to form the 2D grid of Y_lm values\n    return norm * d_vals[:, np.newaxis] * exp_vals[np.newaxis, :]\n\ndef run_verification(l_max, s):\n    \"\"\"\n    Performs the full verification for a given (l_max, s) pair.\n    \"\"\"\n    # 1. Determine minimal grid sizes from derivation\n    if l_max  abs(s): # No valid modes exist\n        return [1, 0.0]\n        \n    n_theta = l_max + 1\n    n_phi = 2 * l_max + 1\n    \n    if l_max == 0:\n        n_phi = 1 # special case, 2*0+1 = 1\n        \n    n_points = n_theta * n_phi\n\n    # 2. Construct quadrature grid and weights\n    # Polar grid (Gauss-Legendre)\n    x_nodes, w_theta = roots_legendre(n_theta)\n    theta_nodes = np.arccos(x_nodes)  # in radians\n\n    # Azimuthal grid (Trapezoidal)\n    phi_nodes = np.linspace(0, 2 * np.pi, n_phi, endpoint=False)\n    w_phi = 2 * np.pi / n_phi\n\n    # 3. Iterate over all mode pairs and check orthonormality\n    max_abs_error = 0.0\n    l_values = range(abs(s), l_max + 1)\n\n    Y_lm_cache = {}\n    \n    for l1 in l_values:\n        for m1 in range(-l1, l1 + 1):\n            if (l1, m1) not in Y_lm_cache:\n                Y_lm_cache[(l1, m1)] = sYlm(s, l1, m1, theta_nodes, phi_nodes)\n            Y1 = Y_lm_cache[(l1, m1)]\n            \n            for l2 in l_values:\n                for m2 in range(-l2, l2 + 1):\n                    if (l2, m2) not in Y_lm_cache:\n                         Y_lm_cache[(l2, m2)] = sYlm(s, l2, m2, theta_nodes, phi_nodes)\n                    Y2 = Y_lm_cache[(l2, m2)]\n\n                    # Compute integrand\n                    integrand = Y1 * np.conj(Y2)\n\n                    # Perform quadrature\n                    # Sum over theta (axis=0) using Gauss-Legendre weights\n                    integral_over_theta = np.sum(integrand * w_theta[:, np.newaxis], axis=0)\n                    \n                    # Sum over phi (remaining axis) using trapezoidal weight\n                    numerical_inner_product = np.sum(integral_over_theta) * w_phi\n\n                    exact_value = 1.0 if (l1 == l2 and m1 == m2) else 0.0\n                    \n                    error = np.abs(numerical_inner_product - exact_value)\n                    if error > max_abs_error:\n                        max_abs_error = error\n    \n    return [n_points, max_abs_error]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (0, 0),\n        (2, -2),\n        (3, 1),\n        (4, 0),\n    ]\n\n    results_for_print = []\n    for l_max, s in test_cases:\n        n_points, max_err = run_verification(l_max, s)\n        results_for_print.append(f\"[{n_points},{max_err}]\")\n\n    print(f\"[{','.join(results_for_print)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Beyond using pre-built library functions, a deeper understanding of spin-weighted spherical harmonics comes from constructing them from first principles. This practice challenges you to numerically implement the spin-lowering operator $\\bar{\\eth}$ to generate ${}_{-2}Y_{\\ell m}$ functions from their scalar counterparts. Verifying their orthonormality on a discrete grid provides crucial insight into the interplay between continuous theory and the realities of finite-difference approximations .",
            "id": "3471619",
            "problem": "Consider the gravitational-wave strain decomposition widely used in numerical relativity, where a complex field of spin weight $s=-2$ on the unit sphere is expanded in spin-weighted spherical harmonics ${}_sY_{\\ell m}(\\theta,\\phi)$. The orthonormality condition states that the continuous inner product satisfies\n$$\n\\int_{0}^{2\\pi}\\!\\!\\mathrm{d}\\phi\\int_{0}^{\\pi}\\!\\!\\mathrm{d}\\theta\\;\\sin\\theta\\;\\,{}_sY_{\\ell m}(\\theta,\\phi)\\,\\,{}_sY^{*}_{\\ell' m'}(\\theta,\\phi) \\;=\\; \\delta_{\\ell\\ell'}\\,\\delta_{mm'} \\quad \\text{for spin weight } s=-2,\n$$\nwhere $\\delta_{\\ell\\ell'}$ and $\\delta_{mm'}$ are Kronecker deltas and $^{*}$ denotes complex conjugation. Starting from the definition of scalar spherical harmonics $Y_{\\ell m}(\\theta,\\phi)$ and the spin-lowering operator $\\bar{\\eth}$ acting on a spin-$s$ function ${}_s f(\\theta,\\phi)$, defined as\n$$\n\\bar{\\eth}\\,\\left({}_s f\\right) \\;=\\; -\\left(\\sin\\theta\\right)^{-s}\\left[\\frac{\\partial}{\\partial\\theta} - i\\,\\csc\\theta\\,\\frac{\\partial}{\\partial\\phi}\\right]\\left[\\left(\\sin\\theta\\right)^{s}\\,{}_s f\\right],\n$$\nyou must construct ${}_{-2}Y_{\\ell m}(\\theta,\\phi)$ numerically by applying $\\bar{\\eth}$ twice to $Y_{\\ell m}(\\theta,\\phi)$ and then normalizing appropriately.\n\nYour task is to write a program that:\n- Constructs ${}_{-2}Y_{\\ell m}(\\theta,\\phi)$ from $Y_{\\ell m}(\\theta,\\phi)$ by applying the spin-lowering operator $\\bar{\\eth}$ twice in sequence, first at spin $s=0$ and then at spin $s=-1$, and multiplying by the normalization factor derived from the defining relation between ${}_sY_{\\ell m}$ and $Y_{\\ell m}$.\n- Evaluates the discrete approximation to the spherical inner product\n$$\nI_{\\ell m,\\ell' m'}(N_\\theta,N_\\phi) \\;=\\; \\sum_{i=1}^{N_\\theta}\\sum_{j=1}^{N_\\phi}\\,\\,{}_{-2}Y_{\\ell m}(\\theta_i,\\phi_j)\\,\\,{}_{-2}Y^{*}_{\\ell' m'}(\\theta_i,\\phi_j)\\,\\sin\\theta_i\\,\\Delta\\theta\\,\\Delta\\phi,\n$$\non a uniform spherical grid with $N_\\theta$ points in the polar angle $\\theta$ and $N_\\phi$ points in the azimuthal angle $\\phi$. Use angles in radians. Choose the grid points as midpoints to avoid the coordinate singularities, i.e., $\\theta_i=\\left(i-\\tfrac{1}{2}\\right)\\Delta\\theta$ for $i=1,\\dots,N_\\theta$ with $\\Delta\\theta=\\pi/N_\\theta$, and $\\phi_j=\\left(j-\\tfrac{1}{2}\\right)\\Delta\\phi$ for $j=1,\\dots,N_\\phi$ with $\\Delta\\phi=2\\pi/N_\\phi$.\n- Approximates $\\partial/\\partial\\theta$ using second-order accurate finite differences in $\\theta$ with one-sided second-order formulas at the boundaries, and approximates $\\partial/\\partial\\phi$ using second-order accurate central finite differences with periodic boundary conditions in $\\phi$.\n- Computes the absolute error\n$$\nE_{\\ell m,\\ell' m'}(N_\\theta,N_\\phi) \\;=\\; \\left|\\,I_{\\ell m,\\ell' m'}(N_\\theta,N_\\phi) \\,-\\, \\delta_{\\ell\\ell'}\\,\\delta_{mm'}\\,\\right|.\n$$\n\nDesign the algorithm from first principles and ensure scientific realism by adhering to the operator definition of $\\bar{\\eth}$ and the standard normalization linking ${}_sY_{\\ell m}$ to $Y_{\\ell m}$. Angles must be in radians. No external input or files are allowed; all parameters must be defined in the program.\n\nImplement the program to evaluate the errors $E_{\\ell m,\\ell' m'}(N_\\theta,N_\\phi)$ for the following test suite of parameter sets, covering diagonal cases, off-diagonal orthogonality, boundary spin cases, coarse-resolution behavior, and convergence with increasing angular resolution:\n- Test $1$: $(\\ell,m,\\ell',m',N_\\theta,N_\\phi)=(2,2,2,2,51,64)$.\n- Test $2$: $(\\ell,m,\\ell',m',N_\\theta,N_\\phi)=(3,1,3,2,61,80)$.\n- Test $3$: $(\\ell,m,\\ell',m',N_\\theta,N_\\phi)=(2,0,3,0,71,96)$.\n- Test $4$: $(\\ell,m,\\ell',m',N_\\theta,N_\\phi)=(4,-1,4,-1,17,16)$.\n- Test $5$: $(\\ell,m,\\ell',m',N_\\theta,N_\\phi)=(5,3,5,3,21,24)$.\n- Test $6$: $(\\ell,m,\\ell',m',N_\\theta,N_\\phi)=(5,3,5,3,41,48)$.\n- Test $7$: $(\\ell,m,\\ell',m',N_\\theta,N_\\phi)=(5,3,5,3,81,96)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite, for example, `[result1,result2,...]`. Each list element must be a real number (float) equal to $E_{\\ell m,\\ell' m'}(N_\\theta,N_\\phi)$ for the corresponding test case. Angles must be treated in radians throughout.",
            "solution": "The problem is valid. It presents a clear, scientifically grounded, and well-posed task in the field of numerical relativity, specifically concerning the numerical construction and verification of properties of spin-weighted spherical harmonics. All provided definitions and parameters are consistent with established theory and practice.\n\nThe core of the problem is to construct the spin-weight $s=-2$ spherical harmonic, denoted ${}_{-2}Y_{\\ell m}(\\theta,\\phi)$, by applying the spin-lowering operator, $\\bar{\\eth}$, twice to the scalar spherical harmonic $Y_{\\ell m}(\\theta,\\phi)$, and then to verify the orthonormality condition via numerical integration.\n\nThe relationship between spin-weighted and scalar spherical harmonics, for $s \\le 0$, is given by applying the $\\bar{\\eth}$ operator $|s|$ times:\n$$\n{}_sY_{\\ell m}(\\theta,\\phi) = (-1)^s \\sqrt{\\frac{(\\ell+s)!}{(\\ell-s)!}} (\\bar{\\eth})^{-s} Y_{\\ell m}(\\theta,\\phi)\n$$\nFor our case, $s=-2$, this becomes:\n$$\n{}_{-2}Y_{\\ell m}(\\theta,\\phi) = \\sqrt{\\frac{(\\ell-2)!}{(\\ell+2)!}} \\bar{\\eth}\\left(\\bar{\\eth}\\left(Y_{\\ell m}(\\theta,\\phi)\\right)\\right)\n$$\nThis relation is valid for $\\ell \\ge |s|$, which is $\\ell \\ge 2$ here. All test cases satisfy this condition. The term $N_{\\ell, s=-2} = \\sqrt{(\\ell-2)!/(\\ell+2)!}$ is the normalization factor.\n\nThe spin-lowering operator, $\\bar{\\eth}$, is defined as:\n$$\n\\bar{\\eth}\\,({}_s f) = -\\left(\\sin\\theta\\right)^{-s}\\left[\\frac{\\partial}{\\partial\\theta} - i\\,\\csc\\theta\\,\\frac{\\partial}{\\partial\\phi}\\right]\\left(\\left(\\sin\\theta\\right)^{s}\\,{}_s f\\right)\n$$\nWe must apply this operator sequentially.\n\nFirst application ($s=0$):\nWe start with the scalar harmonic $Y_{\\ell m}$, which is a function of spin-weight $s=0$. Let's denote it ${}_{0}f = Y_{\\ell m}$.\n$$\n{}_{-1}F \\equiv \\bar{\\eth}({}_0 f) = -\\left(\\sin\\theta\\right)^{0}\\left[\\frac{\\partial}{\\partial\\theta} - i\\,\\csc\\theta\\,\\frac{\\partial}{\\partial\\phi}\\right]\\left(\\left(\\sin\\theta\\right)^{0}\\,{}_0 f\\right) = -\\left(\\frac{\\partial Y_{\\ell m}}{\\partial\\theta} - i\\,\\csc\\theta\\,\\frac{\\partial Y_{\\ell m}}{\\partial\\phi}\\right)\n$$\nThe result, which we denote ${}_{-1}F$, is a function of spin-weight $s=-1$.\n\nSecond application ($s=-1$):\nNow we apply $\\bar{\\eth}$ to ${}_{-1}F$, which has spin-weight $s=-1$.\n$$\n{}_{-2}U \\equiv \\bar{\\eth}({}_{-1}F) = -\\left(\\sin\\theta\\right)^{-(-1)}\\left[\\frac{\\partial}{\\partial\\theta} - i\\,\\csc\\theta\\,\\frac{\\partial}{\\partial\\phi}\\right]\\left(\\left(\\sin\\theta\\right)^{-1}\\,{}_{-1}F\\right)\n$$\nExpanding this gives:\n$$\n{}_{-2}U = -\\sin\\theta \\left[ \\frac{\\partial}{\\partial\\theta}\\left(\\frac{{}_{-1}F}{\\sin\\theta}\\right) - i\\csc\\theta \\frac{\\partial}{\\partial\\phi}\\left(\\frac{{}_{-1}F}{\\sin\\theta}\\right) \\right]\n$$\nSince $\\sin\\theta$ is not a function of $\\phi$, we can simplify the second term:\n$$\n{}_{-2}U = -\\sin\\theta \\left[ \\frac{\\partial}{\\partial\\theta}\\left(\\frac{{}_{-1}F}{\\sin\\theta}\\right) - \\frac{i}{\\sin^2\\theta} \\frac{\\partial {}_{-1}F}{\\partial\\phi} \\right]\n$$\nFinally, we apply the normalization factor to get the desired function:\n$$\n{}_{-2}Y_{\\ell m} = N_{\\ell, s=-2} \\cdot {}_{-2}U\n$$\n\nThe algorithmic procedure to solve the problem is as follows:\n$1$. **Grid Generation**: Construct a $2$D grid of points $(\\theta_i, \\phi_j)$ for $i=1, \\dots, N_\\theta$ and $j=1, \\dots, N_\\phi$, using the specified midpoint rule: $\\theta_i=\\left(i-\\tfrac{1}{2}\\right)\\Delta\\theta$ with $\\Delta\\theta=\\pi/N_\\theta$, and $\\phi_j=\\left(j-\\tfrac{1}{2}\\right)\\Delta\\phi$ with $\\Delta\\phi=2\\pi/N_\\phi$. This grid structure advantageously avoids the coordinate singularities at the poles $\\theta=0$ and $\\theta=\\pi$.\n\n$2$. **Numerical Differentiation**: Implement functions to compute the partial derivatives $\\partial/\\partial\\theta$ and $\\partial/\\partial\\phi$ over the grid.\n    - For $\\partial/\\partial\\theta$, second-order finite differences are used: a three-point central difference for interior grid points, and three-point one-sided (forward and backward) stencils at the $\\theta$ boundaries to maintain second-order accuracy.\n    - For $\\partial/\\partial\\phi$, a second-order central difference is used for all points, leveraging the periodicity in $\\phi$ by wrapping around at the boundaries.\n\n$3$. **Construction of ${}_{-2}Y_{\\ell m}$**: For a given $(\\ell, m)$ pair:\n    a. Evaluate the scalar harmonic $Y_{\\ell m}(\\theta, \\phi)$ on the grid using a standard library function.\n    b. Compute the partial derivatives $\\partial Y_{\\ell m}/\\partial\\theta$ and $\\partial Y_{\\ell m}/\\partial\\phi$ using the numerical methods from step $2$.\n    c. Calculate the intermediate spin-weight $s=-1$ function, ${}_{-1}F$, using its defining formula.\n    d. Form the quantity $h = {}_{-1}F/\\sin\\theta$.\n    e. Compute the partial derivatives $\\partial h/\\partial\\theta$ and $\\partial {}_{-1}F/\\partial\\phi$.\n    f. Calculate the unnormalized spin-weight $s=-2$ function, ${}_{-2}U$, using its defining formula.\n    g. Apply the normalization factor $N_{\\ell, s=-2}$ to obtain the final ${}_{-2}Y_{\\ell m}$ function on the grid.\n\n$4$. **Numerical Integration**: Approximate the inner product integral using a discrete sum over the grid points (the midpoint rule for integration):\n$$\nI_{\\ell m,\\ell' m'} \\approx \\sum_{i=1}^{N_\\theta}\\sum_{j=1}^{N_\\phi}\\,\\,{}_{-2}Y_{\\ell m}(\\theta_i,\\phi_j)\\,\\,{}_{-2}Y^{*}_{\\ell' m'}(\\theta_i,\\phi_j)\\,\\sin\\theta_i\\,\\Delta\\theta\\,\\Delta\\phi\n$$\nThis involves constructing both ${}_{-2}Y_{\\ell m}$ and ${}_{-2}Y_{\\ell' m'}$, taking the complex conjugate of the second, multiplying element-wise, and summing with the appropriate integration weights.\n\n$5$. **Error Calculation**: Compute the absolute error $E_{\\ell m,\\ell' m'} = \\left| I_{\\ell m,\\ell' m'} - \\delta_{\\ell\\ell'}\\delta_{mm'} \\right|$, where $\\delta_{ij}$ is the Kronecker delta. This value quantifies the accuracy of the numerical construction and integration scheme.\n\nThis entire procedure is implemented for each set of parameters provided in the test suite. The results demonstrate the accuracy of the finite-difference approach and its convergence properties.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\nimport math\n\ndef grad_theta(f, delta_theta):\n    \"\"\"\n    Computes the derivative of a 2D array f(theta, phi) with respect to theta.\n    Uses second-order accurate finite differences: central for the interior\n    and one-sided for the boundaries.\n    \"\"\"\n    if f.shape[0]  3:\n        raise ValueError(\"Array must have at least 3 points in the theta direction for second-order derivatives.\")\n    \n    df_dtheta = np.zeros_like(f, dtype=np.complex128)\n    \n    # Central difference for interior points (vectorized over phi)\n    df_dtheta[1:-1, :] = (f[2:, :] - f[:-2, :]) / (2 * delta_theta)\n    \n    # Second-order forward difference for the first point (i=0)\n    df_dtheta[0, :] = (-3 * f[0, :] + 4 * f[1, :] - f[2, :]) / (2 * delta_theta)\n    \n    # Second-order backward difference for the last point (i=N-1)\n    df_dtheta[-1, :] = (3 * f[-1, :] - 4 * f[-2, :] - f[-3, :]) / (2 * delta_theta)\n    # Correction: The formula is (3 f_N - 4 f_{N-1} + f_{N-2}) / 2h\n    df_dtheta[-1, :] = (3 * f[-1, :] - 4 * f[-2, :] + f[-3, :]) / (2 * delta_theta)\n\n    return df_dtheta\n\ndef grad_phi(f, delta_phi):\n    \"\"\"\n    Computes the derivative of a 2D array f(theta, phi) with respect to phi.\n    Uses a second-order accurate central difference with periodic boundary conditions.\n    \"\"\"\n    # np.roll provides an efficient way to implement periodic boundary conditions\n    f_plus_1 = np.roll(f, -1, axis=1)\n    f_minus_1 = np.roll(f, 1, axis=1)\n    \n    df_dphi = (f_plus_1 - f_minus_1) / (2 * delta_phi)\n    \n    return df_dphi\n\ndef construct_sYlm_minus2(ell, em, theta_grid, phi_grid, delta_theta, delta_phi):\n    \"\"\"\n    Constructs the spin-weight s=-2 spherical harmonic -2_Y_lm by applying\n    the bar_eth operator twice to the scalar spherical harmonic Y_lm.\n    \"\"\"\n    # Condition for spin-weighted harmonics: l >= |s|. For s=-2, l must be >= 2.\n    if ell  2:\n        return np.zeros_like(theta_grid, dtype=np.complex128)\n\n    # Step 1: Evaluate the scalar spherical harmonic Y_lm on the grid.\n    # scipy's sph_harm takes (m, l, azimuth, polar).\n    Y_lm = special.sph_harm(em, ell, phi_grid, theta_grid)\n\n    # Pre-compute trigonometric terms for efficiency\n    sin_theta = np.sin(theta_grid)\n    csc_theta = 1.0 / sin_theta\n\n    # Step 2: First application of bar_eth (s=0 -> s=-1)\n    dY_dtheta = grad_theta(Y_lm, delta_theta)\n    dY_dphi = grad_phi(Y_lm, delta_phi)\n    F_minus_1 = -(dY_dtheta - 1j * csc_theta * dY_dphi)\n\n    # Step 3: Second application of bar_eth (s=-1 -> s=-2)\n    h = F_minus_1 * csc_theta\n    dh_dtheta = grad_theta(h, delta_theta)\n    dF_minus_1_dphi = grad_phi(F_minus_1, delta_phi)\n    U_minus_2 = -sin_theta * (dh_dtheta - 1j * csc_theta**2 * dF_minus_1_dphi)\n\n    # Step 4: Normalization\n    # The normalization factor is sqrt((l-s)!/(l+s)!) with s=-2.\n    # We use math.factorial which is suitable for integer arguments.\n    norm_factor = np.sqrt(math.factorial(ell - 2) / math.factorial(ell + 2))\n    sYlm_minus_2 = norm_factor * U_minus_2\n\n    return sYlm_minus_2\n\ndef calculate_error(l, m, l_prime, m_prime, N_theta, N_phi):\n    \"\"\"\n    Calculates the absolute error of the numerically computed inner product\n    of two spin-weighted spherical harmonics.\n    \"\"\"\n    # 1. Setup the numerical grid\n    delta_theta = np.pi / N_theta\n    delta_phi = 2 * np.pi / N_phi\n    \n    # 1D arrays for theta and phi coordinates at midpoints\n    theta = (np.arange(N_theta) + 0.5) * delta_theta\n    phi = (np.arange(N_phi) + 0.5) * delta_phi\n    \n    # Create 2D meshgrid for evaluations\n    phi_grid, theta_grid = np.meshgrid(phi, theta)\n\n    # 2. Construct the two spin-weighted spherical harmonics\n    Y1 = construct_sYlm_minus2(l, m, theta_grid, phi_grid, delta_theta, delta_phi)\n    Y2 = construct_sYlm_minus2(l_prime, m_prime, theta_grid, phi_grid, delta_theta, delta_phi)\n    \n    # 3. Compute the discrete inner product (numerical integral)\n    # The integrand is Y1 * conj(Y2) * sin(theta)\n    # The integration element is d(theta) * d(phi)\n    integrand = Y1 * np.conj(Y2) * np.sin(theta_grid)\n    integral_val = np.sum(integrand) * delta_theta * delta_phi\n\n    # 4. Calculate the expected theoretical value (Kronecker deltas)\n    kronecker_delta = 1.0 if (l == l_prime and m == m_prime) else 0.0\n    \n    # 5. Compute the absolute error\n    error = np.abs(integral_val - kronecker_delta)\n    \n    return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, 2, 2, 2, 51, 64),\n        (3, 1, 3, 2, 61, 80),\n        (2, 0, 3, 0, 71, 96),\n        (4, -1, 4, -1, 17, 16),\n        (5, 3, 5, 3, 21, 24),\n        (5, 3, 5, 3, 41, 48),\n        (5, 3, 5, 3, 81, 96),\n    ]\n\n    results = []\n    for case in test_cases:\n        l, m, l_prime, m_prime, N_theta, N_phi = case\n        result = calculate_error(l, m, l_prime, m_prime, N_theta, N_phi)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "In the continuous domain, the orthonormality of spherical harmonics ensures a perfect separation of modes, but this ideal breaks down in the finite world of numerical simulations and data analysis. This computational experiment allows you to quantify the practical phenomenon of \"spectral leakage,\" where power from one mode appears in the coefficients of others due to discrete sampling. You will also explore how windowing functions can be applied to mitigate these non-ideal effects, a critical skill for interpreting real-world waveform data .",
            "id": "3471549",
            "problem": "You are given the task of quantifying spherical harmonic leakage when projecting a pure spin-weighted spherical harmonic signal onto a finite grid. In gravitational wave extraction in numerical relativity, the complex strain on the sphere is decomposed into spin-weighted spherical harmonics of spin weight $s=-2$. The spin-weighted spherical harmonics ${}_sY_{\\ell m}(\\theta,\\phi)$ form an orthonormal basis on the two-sphere under the inner product induced by the spherical measure, and in the continuum,\n$$\n\\int_0^{2\\pi}\\int_0^\\pi\\ {}_sY_{\\ell m}(\\theta,\\phi)\\ {}_sY_{\\ell' m'}^*(\\theta,\\phi)\\ \\sin\\theta\\ d\\theta\\ d\\phi = \\delta_{\\ell \\ell'}\\delta_{m m'}.\n$$\nFinite-resolution sampling and windowing of the signal modify the effective inner product and can cause leakage of power into neighboring $(\\ell,m)$ modes.\n\nStarting from the fundamental definition that a coefficient of the mode $(\\ell,m)$ in the expansion of a complex field $f(\\theta,\\phi)$ is obtained by the inner product\n$$\nc_{\\ell m} = \\int_0^{2\\pi}\\int_0^\\pi f(\\theta,\\phi)\\ {}_sY_{\\ell m}^*(\\theta,\\phi)\\ \\sin\\theta\\ d\\theta\\ d\\phi,\n$$\nyou must approximate this integral using a rectangular quadrature on a uniform grid in colatitude and azimuth with mid-point sampling in colatitude. Specifically, let $N_\\theta$ and $N_\\phi$ denote the number of samples in colatitude and azimuth, respectively. Define $\\Delta\\theta = \\pi/N_\\theta$ and $\\Delta\\phi = 2\\pi/N_\\phi$, with mid-point colatitude samples $\\theta_i = (i+1/2)\\Delta\\theta$ for $i=0,\\dots,N_\\theta-1$, and azimuth samples $\\phi_j = j\\Delta\\phi$ for $j=0,\\dots,N_\\phi-1$. The discrete approximation to $c_{\\ell m}$ is then\n$$\nc_{\\ell m} \\approx \\sum_{i=0}^{N_\\theta-1}\\sum_{j=0}^{N_\\phi-1} f(\\theta_i,\\phi_j)\\ {}_sY_{\\ell m}^*(\\theta_i,\\phi_j)\\ \\sin\\theta_i\\ \\Delta\\theta\\ \\Delta\\phi.\n$$\n\nConsider the pure input signal\n$$\nf(\\theta,\\phi) = {}_{-2}Y_{2,2}(\\theta,\\phi),\n$$\nand apply a window function $w(\\theta)$ multiplicatively to the signal before projection, producing $f_w(\\theta,\\phi) = w(\\theta)\\ f(\\theta,\\phi)$. The window acts only in colatitude. The window functions to consider are:\n- Rectangular window: $w(\\theta) = 1$.\n- Hann window in colatitude: with $x = \\theta/\\pi$, $w(\\theta) = \\tfrac{1}{2}\\big(1 - \\cos(2\\pi x)\\big)$.\n- Tukey window in colatitude with parameter $\\alpha\\in(0,1]$: with $x=\\theta/\\pi$,\n$$\nw(\\theta) = \\begin{cases}\n\\tfrac{1}{2}\\left[1 + \\cos\\left(\\pi\\left(\\tfrac{2x}{\\alpha} - 1\\right)\\right)\\right],  0 \\le x  \\tfrac{\\alpha}{2},\\\\\n1,  \\tfrac{\\alpha}{2} \\le x \\le 1 - \\tfrac{\\alpha}{2},\\\\\n\\tfrac{1}{2}\\left[1 + \\cos\\left(\\pi\\left(\\tfrac{2(1-x)}{\\alpha} - 1\\right)\\right)\\right],  1 - \\tfrac{\\alpha}{2}  x \\le 1.\n\\end{cases}\n$$\n\nFor each specified sampling grid and window, compute the discrete projection coefficients $c_{\\ell m}$ for the sideband modes $(\\ell,m)\\in\\{(2,1),(3,2),(4,4)\\}$ using angles measured in radians. Define the sideband power fraction for each mode as\n$$\nP_{\\ell m} = \\frac{|c_{\\ell m}|^2}{|c_{2,2}|^2},\n$$\nwhere both numerator and denominator are computed within the same sampling and windowing configuration. The denominator uses the $(\\ell,m)=(2,2)$ mode.\n\nYou must implement the spin-weighted spherical harmonics ${}_sY_{\\ell m}(\\theta,\\phi)$ using the standard Wigner small-$d$ function construction and the azimuthal phase, and perform the discrete summations as specified above. All angles are in radians.\n\nTest Suite:\nUse the following set of parameter values $(N_\\theta, N_\\phi, \\text{window}, \\alpha)$:\n1. $(64, 128, \\text{rect}, 0.0)$\n2. $(8, 16, \\text{rect}, 0.0)$\n3. $(64, 128, \\text{hann\\_theta}, 0.0)$\n4. $(128, 256, \\text{tukey\\_theta}, 0.25)$\n\nFor each test case, compute and return the three sideband power fractions $P_{2,1}$, $P_{3,2}$, and $P_{4,4}$ in that order. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list should be flattened across test cases in order, yielding nine total entries for three test cases and twelve total entries for four test cases. For example, the final output format must be\n$$\n[ P_{2,1}^{(1)}, P_{3,2}^{(1)}, P_{4,4}^{(1)}, P_{2,1}^{(2)}, P_{3,2}^{(2)}, \\dots ]\n$$\nAll computed values must be floating point numbers. Angles must be handled in radians throughout. No physical units are involved in this computation. Ensure numerical stability and scientific realism by correctly implementing the spin-weighted spherical harmonics via their Wigner small-$d$ construction and by using the specified quadrature scheme.",
            "solution": "The user's problem requires the computation of sideband power fractions that arise from the numerical projection of a pure spin-weighted spherical harmonic signal onto a finite grid, under various windowing schemes. This is a standard problem in the analysis of gravitational wave signals from numerical relativity, where spectral leakage due to finite resolution and windowing can corrupt the extracted mode content. The problem is scientifically grounded, well-posed, and all its components are formally defined. Therefore, it is a valid problem.\n\nThe solution is implemented by following these principal steps:\n1.  **Decomposition of the Problem**: The core task is to compute the discrete approximation of the inner product integral $$c_{\\ell m} = \\int_{S^2} f_w(\\theta,\\phi)\\,{}_sY_{\\ell m}^*(\\theta,\\phi)\\ d\\Omega,$$ where $d\\Omega = \\sin\\theta\\ d\\theta\\ d\\phi$. The spin weight for gravitational wave strain is $s=-2$. The input signal is a pure mode, $f(\\theta,\\phi) = {}_{-2}Y_{2,2}(\\theta,\\phi)$, which is then multiplied by a colatitude-dependent window function $w(\\theta)$ to give $f_w(\\theta,\\phi) = w(\\theta)f(\\theta,\\phi)$.\n2.  **Numerical Quadrature**: The integral for $c_{\\ell m}$ is approximated using a rectangular quadrature rule on a uniform grid. The grid has $N_\\theta$ points in colatitude $\\theta$ and $N_\\phi$ points in azimuth $\\phi$. The grid points are $\\theta_i = (i+1/2)\\Delta\\theta$ for $i \\in \\{0, \\dots, N_\\theta-1\\}$ and $\\phi_j = j\\Delta\\phi$ for $j \\in \\{0, \\dots, N_\\phi-1\\}$, where $\\Delta\\theta = \\pi/N_\\theta$ and $\\Delta\\phi = 2\\pi/N_\\phi$. The discretized coefficient is\n    $$c_{\\ell m} \\approx \\sum_{i=0}^{N_\\theta-1}\\sum_{j=0}^{N_\\phi-1} f_w(\\theta_i,\\phi_j)\\,{}_{-2}Y_{\\ell m}^*(\\theta_i,\\phi_j)\\ \\sin\\theta_i\\ \\Delta\\theta\\ \\Delta\\phi.$$\n    The use of mid-point sampling for $\\theta$ avoids singularities at the poles ($\\theta=0,\\pi$).\n3.  **Spin-Weighted Spherical Harmonics Implementation**: A crucial component is the numerical evaluation of the spin-weighted spherical harmonics, ${}_sY_{\\ell m}(\\theta,\\phi)$. These are defined as\n    $${}_sY_{\\ell m}(\\theta,\\phi) = (-1)^s \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,s}(\\theta) e^{im\\phi},$$\n    where $d^\\ell_{m,s}(\\theta)$ are the Wigner small-$d$ functions. To ensure correctness and numerical stability for the required modest values of $\\ell$, an implementation based on the Wigner-Clebsch-Gordan series (Wigner's formula) is chosen. The formula from Varshalovich, Moskalev,  Khersonskii is used for the $d^\\ell_{m',m}(\\beta)$ function, mapping $(m', m) \\to (m, s)$ for our use case:\n    $$d^\\ell_{m,s}(\\theta) = \\left[ (\\ell+m)!(\\ell-m)!(\\ell+s)!(\\ell-s)! \\right]^{1/2} \\sum_z \\frac{(-1)^z}{z!(m-s+z)!(\\ell-m-z)!(\\ell+s-z)!} (\\cos(\\theta/2))^{2\\ell+s-m-2z}(\\sin(\\theta/2))^{m-s+2z}.$$\n    The summation over $z$ includes all integer values for which the arguments of the factorials are non-negative. This can be expressed as a sum from $z_{min} = \\max(0, s-m)$ to $z_{max} = \\min(\\ell-m, \\ell+s)$. To handle potentially large numbers in the factorials, their logarithms are computed using `scipy.special.gammaln`, where $\\ln(n!) = \\text{gammaln}(n+1)$.\n4.  **Projection Kernel**: The projection requires the complex conjugate, ${}_{-2}Y_{\\ell m}^*(\\theta,\\phi)$. Given that the Wigner $d$-functions are real, we have\n    $${}_{-2}Y_{\\ell m}^*(\\theta, \\phi) = (-1)^{-2} \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,-2}(\\theta) e^{-im\\phi} = \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,-2}(\\theta) e^{-im\\phi}.$$\n    This is implemented by computing ${}_{-2}Y_{\\ell m}$ and then taking its complex conjugate.\n5.  **Window Functions**: The specified window functions (Rectangular, Hann, and Tukey) are implemented as functions of colatitude $\\theta$. The Tukey window is parameterized by $\\alpha$.\n6.  **Power Fraction Calculation**: For each test case, specified by $(N_\\theta, N_\\phi, \\text{window}, \\alpha)$, the process is as follows:\n    a. A $2$D grid of $(\\theta, \\phi)$ values is generated.\n    b. The input signal $f(\\theta,\\phi)$ and the projection kernels ${}_{-2}Y_{\\ell m}^*$ for the modes $(\\ell,m) \\in \\{(2,1),(3,2),(4,4),(2,2)\\}$ are evaluated on this grid.\n    c. The appropriate window function $w(\\theta)$ is applied to the input signal.\n    d. The discrete sums for the coefficients $c_{\\ell m}$ are computed.\n    e. The sideband power fractions are calculated as $P_{\\ell m} = |c_{\\ell m}|^2 / |c_{2,2}|^2$ for $(\\ell,m) \\in \\{(2,1),(3,2),(4,4)\\}$.\n7.  **Execution**: A main function iterates through the provided test suite, calls a subroutine to perform the calculations for each case, and aggregates the results into a single list for final output, formatted as specified.\n\nThe algorithmic design is thus a direct and robust implementation of the mathematical prescription in the problem statement, using standard, numerically stable techniques appropriate for the discipline.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef wigner_d(l, m1, m2, theta):\n    \"\"\"\n    Computes the Wigner small-d function d^l_{m1,m2}(theta) using the\n    summation formula from Varshalovich, Moskalev,  Khersonskii.\n    This implementation uses logarithms of factorials for numerical stability.\n    \"\"\"\n    # Wigner d-functions are defined for |m1| = l and |m2| = l.\n    if abs(m1) > l or abs(m2) > l:\n        return np.zeros_like(np.asarray(theta), dtype=float)\n\n    # Convert theta to a numpy array to handle scalar and array inputs uniformly.\n    theta = np.asarray(theta)\n    \n    # Summation limits for z\n    z_min = max(0, m2 - m1)\n    z_max = min(l - m1, l + m2)\n    \n    # Pre-compute the logarithm of the constant square-root factor.\n    log_sqrt_factor = 0.5 * (gammaln(l + m1 + 1) + gammaln(l - m1 + 1) +\n                             gammaln(l + m2 + 1) + gammaln(l - m2 + 1))\n    \n    # Initialize the result array.\n    d_val = np.zeros_like(theta, dtype=float)\n    \n    cos_half_theta = np.cos(theta / 2.0)\n    sin_half_theta = np.sin(theta / 2.0)\n    \n    for z in range(z_min, z_max + 1):\n        # Logarithm of the denominator in the summation term\n        log_denom_z = (gammaln(z + 1) +\n                       gammaln(m1 - m2 + z + 1) +\n                       gammaln(l - m1 - z + 1) +\n                       gammaln(l + m2 - z + 1))\n        \n        # Logarithm of the z-th term's coefficient\n        log_C_z = log_sqrt_factor - log_denom_z\n        C_z = np.exp(log_C_z)\n        \n        # Power exponents for cos and sin terms\n        pow_cos = 2 * l + m2 - m1 - 2 * z\n        pow_sin = m1 - m2 + 2 * z\n        \n        # The grid for theta avoids 0 and pi, so cos_half_theta and sin_half_theta are non-zero.\n        # This prevents issues with 0**negative_power.\n        term_z = C_z * (cos_half_theta**pow_cos) * (sin_half_theta**pow_sin)\n        \n        d_val += (-1)**z * term_z\n            \n    return d_val\n\ndef spin_weighted_Y(s, l, m, theta, phi):\n    \"\"\"\n    Computes the spin-weighted spherical harmonic sYlm(theta, phi).\n    \"\"\"\n    if abs(m) > l or abs(s) > l:\n        if isinstance(theta, np.ndarray):\n            return np.zeros_like(theta, dtype=complex)\n        else:\n            return 0.0 + 0.0j\n\n    # In sYlm, the d-function is d^l_{m,s}. So m1=m, m2=s.\n    d_func = wigner_d(l, m, s, theta)\n    norm = np.sqrt((2 * l + 1) / (4 * np.pi))\n    phase = np.exp(1j * m * phi)\n    \n    return (-1)**s * norm * d_func * phase\n\ndef get_window_function(name, alpha, N_theta):\n    \"\"\"\n    Generates the specified window function array.\n    \"\"\"\n    theta = (np.arange(N_theta) + 0.5) * np.pi / N_theta\n    if name == 'rect':\n        return np.ones(N_theta)\n    \n    x = theta / np.pi\n    if name == 'hann_theta':\n        return 0.5 * (1 - np.cos(2 * np.pi * x))\n    elif name == 'tukey_theta':\n        w = np.ones_like(x)\n        # First section of the Tukey window\n        mask1 = x  alpha / 2.0\n        w[mask1] = 0.5 * (1 + np.cos(np.pi * (2 * x[mask1] / alpha - 1)))\n        # Last section of the Tukey window\n        mask3 = x > 1 - alpha / 2.0\n        w[mask3] = 0.5 * (1 + np.cos(np.pi * (2 * (1 - x[mask3]) / alpha - 1)))\n        return w\n    else:\n        raise ValueError(f\"Unknown window: {name}\")\n\ndef calculate_power_fractions(N_theta, N_phi, window_name, alpha):\n    \"\"\"\n    Performs the full calculation for a single test case.\n    \"\"\"\n    s = -2 # Spin weight\n    \n    # 1. Set up the grid\n    delta_theta = np.pi / N_theta\n    delta_phi = 2 * np.pi / N_phi\n    \n    theta_pts = (np.arange(N_theta) + 0.5) * delta_theta\n    phi_pts = np.arange(N_phi) * delta_phi\n    \n    theta_mesh, phi_mesh = np.meshgrid(theta_pts, phi_pts, indexing='ij')\n\n    # 2. Define the input signal on the grid\n    # f(theta, phi) = -2_Y_2,2(theta, phi)\n    input_signal_grid = spin_weighted_Y(s, 2, 2, theta_mesh, phi_mesh)\n    \n    # 3. Apply the window function\n    window = get_window_function(window_name, alpha, N_theta)\n    # Window is 1D (theta-dependent), broadcast it to the 2D grid\n    windowed_signal_grid = window[:, np.newaxis] * input_signal_grid\n    \n    # 4. Compute projection coefficients\n    modes_to_calculate = [(2, 2), (2, 1), (3, 2), (4, 4)]\n    coeffs = {}\n    \n    d_omega = np.sin(theta_mesh) * delta_theta * delta_phi\n\n    for l_val, m_val in modes_to_calculate:\n        # Kernel is the complex conjugate of sYlm\n        kernel_grid = np.conj(spin_weighted_Y(s, l_val, m_val, theta_mesh, phi_mesh))\n        \n        integrand = windowed_signal_grid * kernel_grid\n        \n        c_lm = np.sum(integrand * d_omega)\n        coeffs[(l_val, m_val)] = c_lm\n\n    # 5. Calculate power fractions\n    c_22_sq = np.abs(coeffs[(2, 2)])**2\n    \n    if c_22_sq == 0:\n        # Avoid division by zero, though it's physically unlikely here.\n        P_21 = P_32 = P_44 = np.inf\n    else:\n        P_21 = np.abs(coeffs[(2, 1)])**2 / c_22_sq\n        P_32 = np.abs(coeffs[(3, 2)])**2 / c_22_sq\n        P_44 = np.abs(coeffs[(4, 4)])**2 / c_22_sq\n        \n    return [P_21, P_32, P_44]\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the result.\n    \"\"\"\n    test_cases = [\n        (64, 128, 'rect', 0.0),\n        (8, 16, 'rect', 0.0),\n        (64, 128, 'hann_theta', 0.0),\n        (128, 256, 'tukey_theta', 0.25),\n    ]\n\n    results = []\n    for case in test_cases:\n        N_theta, N_phi, window_name, alpha = case\n        case_results = calculate_power_fractions(N_theta, N_phi, window_name, alpha)\n        results.extend(case_results)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}