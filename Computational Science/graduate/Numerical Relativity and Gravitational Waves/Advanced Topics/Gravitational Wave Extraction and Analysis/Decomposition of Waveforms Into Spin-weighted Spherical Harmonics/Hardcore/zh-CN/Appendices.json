{
    "hands_on_practices": [
        {
            "introduction": "将波形分解为自旋权球谐函数，其精度关键取决于如何对投影积分进行数值计算。本练习将指导你推导并实现一种最优求积规则，该规则能对带限信号达到理论上的精确度，从而为高保真度分析奠定基石。通过构建一个由极角方向的高斯-勒让德求积和方位角方向的等距梯形规则组成的张量积，你将从第一性原理确定确保精确积分所需的最小采样点数。",
            "id": "3471575",
            "problem": "您的任务是构建并验证一个在单位$2$-球面$S^2$上的数值积分方法，该方法能精确积分直到某一最大谐波阶数的自旋加权球谐函数的内积。您的程序必须实现一种以下形式的张量积求积：在极角上使用高斯-勒让德求积，在方位角上使用等间距梯形法则。目标是通过第一性原理推导，确定为保证精确数值计算所有带限自旋加权球谐函数（直到指定的带限）的内积所需的最少采样点数，并为一个小型测试套件在数值上验证其精确性。所有角度必须使用弧度制。\n\n使用的定义和基本事实：\n- 自旋加权球谐函数 ${}_sY_{\\ell m}(\\theta,\\phi)$ 是 $S^2$ 上的本征函数，它们将标量球谐函数推广到自旋权重 $s \\in \\mathbb{Z}$。对于任何固定的自旋权重 $s$，它们满足正交归一性关系\n$$\n\\int_0^{2\\pi}\\!\\!\\int_0^\\pi {}_sY_{\\ell m}(\\theta,\\phi)\\,{}_sY_{\\ell' m'}^*(\\theta,\\phi)\\,\\sin\\theta\\,d\\theta\\,d\\phi \\;=\\; \\delta_{\\ell\\ell'}\\,\\delta_{mm'}.\n$$\n- 内积积分可分解为一个涉及复指数 $e^{i m \\phi}$ 的方位角（$\\phi$）部分和一个涉及相关角度依赖的极角（$\\theta$）部分。当使用足够多的点时，在 $\\phi$ 上的均匀梯形法则能精确积分所有直到给定最高频率的复指数 $e^{i n \\phi}$。在 $x=\\cos\\theta$ 上的高斯-勒让德求积能精确积分 $x$ 的多项式，其最高次数由节点数决定。\n- 对于以 $\\ell\\le\\ell_{\\max}$ 为界的自旋加权球谐函数的乘积，方位角依赖性是带限的，频率为 $|m|\\le\\ell_{\\max}$，并且乘积的极角依赖性（在变量代换 $x=\\cos\\theta$ 后）可以表示为一个在 $x$ 中次数最多为 $2\\ell_{\\max}$ 的多项式。\n\n任务：\n1. 根据上述基本事实，推导出使张量积求积能对所有 $|s|\\le \\ell\\le\\ell_{\\max}$ 和 $-\\ell\\le m\\le \\ell$ 的 ${}_sY_{\\ell m}$ 和 ${}_sY_{\\ell' m'}^*$ 的内积进行精确积分所需的最少方位角采样点数 $N_\\phi$ 和极角采样点数 $N_\\theta$。推导过程应纯粹是数学上的，并且不应依赖于所述基本事实之外的快捷公式。所有角度的单位均为弧度。\n2. 实现一个程序，该程序：\n   - 构建一个阶为 $N_\\theta$ 的高斯-勒让德求积，用于 $x\\in[-1,1]$，对应于 $\\theta=\\arccos x$。\n   - 构建一个在 $[0,2\\pi)$ 上的 $N_\\phi$ 个点的等间距方位角网格，使用均匀权重（梯形法则）。\n   - 使用 Wigner 小-$d$ 矩阵表示法计算 ${}_sY_{\\ell m}(\\theta,\\phi)$，并通过计算离散求积和\n   $$\n   \\sum_{k=0}^{N_\\phi-1} w_\\phi \\sum_{i=1}^{N_\\theta} w_{\\theta,i}\\;{}_sY_{\\ell m}(\\theta_i,\\phi_k)\\;{}_sY_{\\ell' m'}^*(\\theta_i,\\phi_k),\n   $$\n   来验证内积的数值精确性，并与 $\\delta_{\\ell\\ell'}\\,\\delta_{mm'}$ 进行比较。您的程序必须限制在 $\\ell\\ge |s|$，因为否则 ${}_sY_{\\ell m}$ 为零。\n3. 对于测试套件中的每个测试，您的程序必须报告：\n   - 从您在第1项的推导中得出的最少采样点数 $N_{\\text{points}}=N_\\theta N_\\phi$。\n   - 在所有测试内积中的最大绝对误差，计算为离散求积值与精确的克罗内克δ函数值之间的最大绝对差。\n\n测试套件参数：\n- 使用以下 $(\\ell_{\\max},s)$ 对来检验不同情况：\n  - $(\\ell_{\\max},s)=(0,0)$。\n  - $(\\ell_{\\max},s)=(2,-2)$。\n  - $(\\ell_{\\max},s)=(3,1)$。\n  - $(\\ell_{\\max},s)=(4,0)$。\n所有角度必须使用弧度制。使用适合双精度的数值公差，并确保验证过程比较的是浮点值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，聚合为一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个形式为 $[N_{\\text{points}},\\varepsilon]$ 的双元素列表，其中 $N_{\\text{points}}$ 是一个整数，$\\varepsilon$ 是一个浮点数，等于上述指定的最大绝对误差。例如：$[[N_1,\\varepsilon_1],[N_2,\\varepsilon_2],[N_3,\\varepsilon_3],[N_4,\\varepsilon_4]]$。",
            "solution": "任务是确定用于精确积分自旋加权球谐函数 ${}_sY_{\\ell m}$ 内积（直到带限 $\\ell_{\\max}$）所需的最少求积点数，并数值上验证此发现。指定的求积方法是极角 $\\theta$ 的高斯-勒让德方法和方位角 $\\phi$ 的等间距梯形法则的张量积。\n\n正交归一性积分由下式给出：\n$$\nI = \\int_0^{2\\pi} d\\phi \\int_0^\\pi d\\theta \\, \\sin\\theta \\, {}_sY_{\\ell m}(\\theta,\\phi) \\, {}_sY_{\\ell' m'}^*(\\theta,\\phi) = \\delta_{\\ell\\ell'} \\delta_{mm'}\n$$\n我们将首先根据问题陈述中提供的基本事实，推导所需的最少点数 $N_\\phi$ 和 $N_\\theta$。\n\n**最少求积点数的推导**\n\n推导过程通过分别分析积分的方位角部分和极角部分来进行。\n\n**1. 方位角求积 ($N_\\phi$)**\n\n自旋加权球谐函数的形式为 ${}_sY_{\\ell m}(\\theta,\\phi) \\propto d^\\ell_{m,s}(\\theta) e^{im\\phi}$，其中 $d^\\ell_{m,s}(\\theta)$ 是 Wigner 小-d 矩阵。因此，被积函数 ${}_sY_{\\ell m}(\\theta,\\phi)\\,{}_sY_{\\ell' m'}^*(\\theta,\\phi)$ 具有 $e^{im\\phi} (e^{im'\\phi})^* = e^{i(m-m')\\phi}$ 形式的方位角依赖性。\n\n问题要求一个单一的求积网格，该网格对所有 $\\ell, \\ell' \\le \\ell_{\\max}$ 的内积都精确。谐波指数 $m$ 和 $m'$ 受限于 $|m| \\le \\ell \\le \\ell_{\\max}$ 和 $|m'| \\le \\ell' \\le \\ell_{\\max}$。方位角被积函数的频率为 $k = m-m'$。因此，可能频率的范围是：\n$$\n-\\ell_{\\max} - \\ell_{\\max} \\le m - m' \\le \\ell_{\\max} - (-\\ell_{\\max}) \\implies -2\\ell_{\\max} \\le k \\le 2\\ell_{\\max}\n$$\n我们必须选择梯形法则的点数 $N_\\phi$，以精确积分在 $[-2\\ell_{\\max}, 2\\ell_{\\max}]$ 范围内的所有整数频率 $k$ 的 $e^{ik\\phi}$ 形式的任何函数。\n\n$N_\\phi$ 点梯形法则对积分 $\\int_0^{2\\pi} f(\\phi) d\\phi$ 的近似为 $\\frac{2\\pi}{N_\\phi} \\sum_{j=0}^{N_\\phi-1} f(\\phi_j)$，其中 $\\phi_j = 2\\pi j / N_\\phi$。对于函数 $f(\\phi) = e^{ik\\phi}$，精确积分为 $\\int_0^{2\\pi} e^{ik\\phi} d\\phi = 2\\pi \\delta_{k0}$。数值求积得出：\n$$\n\\frac{2\\pi}{N_\\phi} \\sum_{j=0}^{N_\\phi-1} e^{ik(2\\pi j/N_\\phi)} = \\frac{2\\pi}{N_\\phi} \\sum_{j=0}^{N_\\phi-1} \\left(e^{i2\\pi k/N_\\phi}\\right)^j\n$$\n如果 $k$ 是 $N_\\phi$ 的整数倍，这个几何级数的和为 $N_\\phi$，否则为 $0$。因此，如果 $k=p N_\\phi$（其中 $p$ 是某个整数），则数值积分为 $2\\pi$，否则为 $0$。\n\n为了使求积对所有频率 $|k| \\le 2\\ell_{\\max}$ 都精确，它必须与真实的积分值（$k=0$ 时为 $2\\pi$，否则为 $0$）相匹配。这要求我们范围内的任何非零频率都不是 $N_\\phi$ 的倍数。对于该范围内的所有非零 $k$，如果 $|k|  N_\\phi$，则此条件得到满足。最大频率幅度为 $2\\ell_{\\max}$。因此，我们必须有 $N_\\phi > 2\\ell_{\\max}$。最少的整数点数为：\n$$\nN_\\phi = 2\\ell_{\\max} + 1\n$$\n\n**2. 极角求积 ($N_\\theta$)**\n\n极角积分的形式为 $\\int_0^\\pi F(\\theta) \\sin\\theta d\\theta$。在变量代换 $x = \\cos\\theta$, $dx = -\\sin\\theta d\\theta$ 之后，积分变为 $\\int_{-1}^1 F(\\arccos x) dx$。\n\n问题陈述指出，被积函数的极角部分，它与乘积 $d^\\ell_{m,s}(\\theta) d^{\\ell'}_{m',s}(\\theta)$ 成正比，可以表示为 $x = \\cos\\theta$ 的多项式，其次数最多为 $2\\ell_{\\max}$，因为 $\\ell, \\ell' \\le \\ell_{\\max}$。\n\n具有 $N_\\theta$ 个点（节点）的高斯-勒让德求积旨在精确积分任何次数高达 $2N_\\theta - 1$ 的多项式。为保证我们的被积函数积分的精确性，该规则能处理的多项式次数必须至少为我们被积函数多项式的最大次数。这给出了条件：\n$$\n2N_\\theta - 1 \\ge 2\\ell_{\\max}\n$$\n解出 $N_\\theta$ 得到 $2N_\\theta \\ge 2\\ell_{\\max} + 1$，或 $N_\\theta \\ge \\ell_{\\max} + 1/2$。由于 $N_\\theta$ 必须是整数，最少的极角求积点数为：\n$$\nN_\\theta = \\ell_{\\max} + 1\n$$\n\n总而言之，对于所有 $\\ell, \\ell' \\le \\ell_{\\max}$ 的内积进行精确积分所需的最少求积点数为 $N_\\theta = \\ell_{\\max} + 1$ 和 $N_\\phi = 2\\ell_{\\max} + 1$。球面上的总点数为 $N_{\\text{points}} = N_\\theta N_\\phi = (\\ell_{\\max}+1)(2\\ell_{\\max}+1)$。\n\n**数值实现与验证**\n\n验证算法的结构如下：\n1.  对于给定的测试用例 $(\\ell_{\\max}, s)$，计算所需的最小网格尺寸 $N_\\theta = \\ell_{\\max} + 1$ 和 $N_\\phi = 2\\ell_{\\max} + 1$。\n2.  构建求积网格。$N_\\theta$ 个极角 $\\theta_i$ 和权重 $w_{\\theta, i}$ 从 $N_\\theta$ 点高斯-勒让德求积在 $x \\in [-1,1]$ 上的节点和权重导出。节点 $x_i$ 给出 $\\theta_i = \\arccos(x_i)$，权重 $w_{\\theta,i}$ 直接使用。$N_\\phi$ 个方位角为 $\\phi_k = 2\\pi k / N_\\phi$（$k=0, \\dots, N_\\phi-1$），具有均匀权重 $w_\\phi = 2\\pi/N_\\phi$。\n3.  实现一个计算 ${}_sY_{\\ell m}(\\theta,\\phi)$ 的函数。这基于 Wigner 小-d 矩阵表示法：\n    $$\n    {}_sY_{\\ell m}(\\theta,\\phi) = \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,s}(\\theta) e^{im\\phi}\n    $$\n    Wigner 函数 $d^\\ell_{m,s}(\\theta)$ 使用其显式求和公式计算。为保持阶乘项的数值稳定性，计算使用伽马函数的对数 (`gammaln`) 进行。\n4.  遍历所有有效的模式组合：$\\ell, \\ell' \\in [|s|, \\ell_{\\max}]$ 和 $m \\in [-\\ell, \\ell], m' \\in [-\\ell', \\ell']$。\n5.  对于每个组合 $(\\ell, m, \\ell', m')$，通过在求积网格上求和来计算数值内积：\n    $$\n    I_{\\text{numeric}} = w_\\phi \\sum_{k=0}^{N_\\phi-1} \\sum_{i=1}^{N_\\theta} w_{\\theta,i}\\;{}_sY_{\\ell m}(\\theta_i,\\phi_k)\\;{}_sY_{\\ell' m'}^*(\\theta_i,\\phi_k)\n    $$\n6.  将 $I_{\\text{numeric}}$ 与精确的解析值 $I_{\\text{exact}} = \\delta_{\\ell\\ell'}\\,\\delta_{mm'}$ 进行比较。记录绝对误差 $|I_{\\text{numeric}} - I_{\\text{exact}}|$。\n7.  对于该测试用例，报告在所有模式组合中发现的最大绝对误差，以及总网格点数 $N_{\\text{points}} = N_\\theta N_\\phi$。预期误差应在浮点机器精度量级，从而证实求积的精确性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre, gammaln\nimport math\n\ndef wigner_d(l, m, s, theta):\n    \"\"\"\n    Computes the Wigner small-d matrix d^l_{m,s}(theta) using the summation formula.\n    Numerically stable implementation using log-gamma for factorials.\n    The angles theta are expected in radians.\n    \"\"\"\n    if np.abs(m) > l or np.abs(s) > l:\n        return np.zeros_like(theta)\n\n    # Use log-gamma to handle large numbers from factorials.\n    # gammaln(n+1) = log(n!)\n    log_prefactor = 0.5 * (gammaln(l + m + 1) + gammaln(l - m + 1) + gammaln(l + s + 1) + gammaln(l - s + 1))\n\n    # Summation range for k\n    k_min = int(max(0, s - m))\n    k_max = int(min(l + s, l - m))\n\n    d_values = np.zeros_like(theta, dtype=float)\n    \n    # Pre-compute trigonometric terms\n    cos_theta_half = np.cos(theta / 2.0)\n    sin_theta_half = np.sin(theta / 2.0)\n    \n    for k in range(k_min, k_max + 1):\n        log_term = (\n            log_prefactor\n            - gammaln(k + 1)\n            - gammaln(l + s - k + 1)\n            - gammaln(l - m - k + 1)\n            - gammaln(m - s + k + 1)\n        )\n        \n        # Power terms. Special handling for base=0 to avoid log(0).\n        # Since theta is from arccos of Legendre roots in (-1,1), theta is in (0,pi).\n        # cos_theta_half and sin_theta_half will be in (0,1).\n        pow1 = 2 * l + s - m - 2 * k\n        pow2 = m - s + 2 * k\n        \n        log_term += pow1 * np.log(cos_theta_half)\n        log_term += pow2 * np.log(sin_theta_half)\n\n        term = (-1)**k * np.exp(log_term)\n        d_values += term\n        \n    return d_values\n\ndef sYlm(s, l, m, theta, phi):\n    \"\"\"\n    Computes spin-weighted spherical harmonic sYlm on a grid of (theta, phi).\n    theta is a 1D array of size N_theta.\n    phi is a 1D array of size N_phi.\n    Returns a 2D array of shape (N_theta, N_phi).\n    \"\"\"\n    norm = math.sqrt((2 * l + 1) / (4 * np.pi))\n    d_vals = wigner_d(l, m, s, theta)\n    exp_vals = np.exp(1j * m * phi)\n    \n    # Use broadcasting to form the 2D grid of Y_lm values\n    return norm * d_vals[:, np.newaxis] * exp_vals[np.newaxis, :]\n\ndef run_verification(l_max, s):\n    \"\"\"\n    Performs the full verification for a given (l_max, s) pair.\n    \"\"\"\n    # 1. Determine minimal grid sizes from derivation\n    if l_max  abs(s): # No valid modes exist\n        return [1, 0.0]\n        \n    n_theta = l_max + 1\n    n_phi = 2 * l_max + 1\n    \n    if l_max == 0:\n        n_phi = 1 # special case, 2*0+1 = 1\n        \n    n_points = n_theta * n_phi\n\n    # 2. Construct quadrature grid and weights\n    # Polar grid (Gauss-Legendre)\n    x_nodes, w_theta = roots_legendre(n_theta)\n    theta_nodes = np.arccos(x_nodes)  # in radians\n\n    # Azimuthal grid (Trapezoidal)\n    phi_nodes = np.linspace(0, 2 * np.pi, n_phi, endpoint=False)\n    w_phi = 2 * np.pi / n_phi\n\n    # 3. Iterate over all mode pairs and check orthonormality\n    max_abs_error = 0.0\n    l_values = range(abs(s), l_max + 1)\n\n    Y_lm_cache = {}\n    \n    for l1 in l_values:\n        for m1 in range(-l1, l1 + 1):\n            if (l1, m1) not in Y_lm_cache:\n                Y_lm_cache[(l1, m1)] = sYlm(s, l1, m1, theta_nodes, phi_nodes)\n            Y1 = Y_lm_cache[(l1, m1)]\n            \n            for l2 in l_values:\n                for m2 in range(-l2, l2 + 1):\n                    if (l2, m2) not in Y_lm_cache:\n                         Y_lm_cache[(l2, m2)] = sYlm(s, l2, m2, theta_nodes, phi_nodes)\n                    Y2 = Y_lm_cache[(l2, m2)]\n\n                    # Compute integrand\n                    integrand = Y1 * np.conj(Y2)\n\n                    # Perform quadrature\n                    # Sum over theta (axis=0) using Gauss-Legendre weights\n                    integral_over_theta = np.sum(integrand * w_theta[:, np.newaxis], axis=0)\n                    \n                    # Sum over phi (remaining axis) using trapezoidal weight\n                    numerical_inner_product = np.sum(integral_over_theta) * w_phi\n\n                    exact_value = 1.0 if (l1 == l2 and m1 == m2) else 0.0\n                    \n                    error = np.abs(numerical_inner_product - exact_value)\n                    if error > max_abs_error:\n                        max_abs_error = error\n    \n    return [n_points, max_abs_error]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (0, 0),\n        (2, -2),\n        (3, 1),\n        (4, 0),\n    ]\n\n    results_for_print = []\n    for l_max, s in test_cases:\n        n_points, max_err = run_verification(l_max, s)\n        results_for_print.append(f\"[{n_points},{max_err}]\")\n\n    print(f\"[{','.join(results_for_print)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在理想情况的基础上，本练习将探讨一种更常见的情景：为了计算效率而使用更简单的均匀网格，但这会引入谱泄漏等伪影。你将量化一个纯模式的能量如何“泄漏”到其他模式中，并研究如何使用窗函数来抑制这种效应，这是真实世界数据分析中的一项关键技能。这项实践突出了在数值方法中，计算简便性与精度之间的权衡。",
            "id": "3471549",
            "problem": "给定一项任务，量化在将一个纯自旋加权球谐信号投影到有限网格上时的球谐函数泄漏。在数值相对论的引力波提取中，球面上的复应变被分解为自旋权重 $s=-2$ 的自旋加权球谐函数。自旋加权球谐函数 $\\ {}_sY_{\\ell m}(\\theta,\\phi)$ 在由球面测度诱导的内积下，构成二维球面上的一个标准正交基，在连续统中，\n$$\n\\int_0^{2\\pi}\\int_0^\\pi\\ {}_sY_{\\ell m}(\\theta,\\phi)\\ {}_sY_{\\ell' m'}^*(\\theta,\\phi)\\ \\sin\\theta\\ d\\theta\\ d\\phi = \\delta_{\\ell \\ell'}\\delta_{m m'}.\n$$\n信号的有限分辨率采样和加窗会改变有效内积，并可能导致功率泄漏到相邻的 $(\\ell,m)$ 模中。\n\n从复场 $f(\\theta,\\phi)$ 展开式中模 $(\\ell,m)$ 的系数是通过内积获得的基本定义出发\n$$\nc_{\\ell m} = \\int_0^{2\\pi}\\int_0^\\pi f(\\theta,\\phi)\\ {}_sY_{\\ell m}^*(\\theta,\\phi)\\ \\sin\\theta\\ d\\theta\\ d\\phi,\n$$\n你必须使用在余纬和方位角上均匀网格上的矩形求积来近似这个积分，并在余纬上使用中点采样。具体来说，设 $N_\\theta$ 和 $N_\\phi$ 分别表示余纬和方位角的采样点数。定义 $\\Delta\\theta = \\pi/N_\\theta$ 和 $\\Delta\\phi = 2\\pi/N_\\phi$，其中余纬中点采样为 $\\theta_i = (i+1/2)\\Delta\\theta$（对于 $i=0,\\dots,N_\\theta-1$），方位角采样为 $\\phi_j = j\\Delta\\phi$（对于 $j=0,\\dots,N_\\phi-1$）。$c_{\\ell m}$ 的离散近似则为\n$$\nc_{\\ell m} \\approx \\sum_{i=0}^{N_\\theta-1}\\sum_{j=0}^{N_\\phi-1} f(\\theta_i,\\phi_j)\\ {}_sY_{\\ell m}^*(\\theta_i,\\phi_j)\\ \\sin\\theta_i\\ \\Delta\\theta\\ \\Delta\\phi.\n$$\n\n考虑纯输入信号\n$$\nf(\\theta,\\phi) = {}_{-2}Y_{2,2}(\\theta,\\phi),\n$$\n并在投影前对信号乘上一个窗函数 $w(\\theta)$，产生 $f_w(\\theta,\\phi) = w(\\theta)\\ f(\\theta,\\phi)$。该窗函数仅在余纬方向上起作用。需要考虑的窗函数有：\n- 矩形窗：$w(\\theta) = 1$。\n- 余纬上的汉宁窗：设 $x = \\theta/\\pi$，则 $w(\\theta) = \\tfrac{1}{2}\\big(1 - \\cos(2\\pi x)\\big)$。\n- 余纬上参数为 $\\alpha\\in(0,1]$ 的Tukey窗：设 $x=\\theta/\\pi$，\n$$\nw(\\theta) = \\begin{cases}\n\\tfrac{1}{2}\\left[1 + \\cos\\left(\\pi\\left(\\tfrac{2x}{\\alpha} - 1\\right)\\right)\\right],  0 \\le x  \\tfrac{\\alpha}{2},\\\\\n1,  \\tfrac{\\alpha}{2} \\le x \\le 1 - \\tfrac{\\alpha}{2},\\\\\n\\tfrac{1}{2}\\left[1 + \\cos\\left(\\pi\\left(\\tfrac{2(1-x)}{\\alpha} - 1\\right)\\right)\\right],  1 - \\tfrac{\\alpha}{2}  x \\le 1.\n\\end{cases}\n$$\n\n对于每个指定的采样网格和窗函数，使用以弧度为单位的角度，计算边带模 $(\\ell,m)\\in\\{(2,1),(3,2),(4,4)\\}$ 的离散投影系数 $c_{\\ell m}$。将每个模的边带功率分数定义为\n$$\nP_{\\ell m} = \\frac{|c_{\\ell m}|^2}{|c_{2,2}|^2},\n$$\n其中分子和分母都在相同的采样和加窗配置下计算。分母使用 $(\\ell,m)=(2,2)$ 模。\n\n你必须使用标准的维格纳小d函数构造和方位角相位来实现自旋加权球谐函数 $\\ {}_sY_{\\ell m}(\\theta,\\phi)$，并按照上述规定执行离散求和。所有角度均以弧度为单位。\n\n测试套件：\n使用以下参数值集合 $(N_\\theta, N_\\phi, \\text{window}, \\alpha)$:\n1. $(64, 128, \\text{rect}, 0.0)$\n2. $(8, 16, \\text{rect}, 0.0)$\n3. $(64, 128, \\text{hann\\_theta}, 0.0)$\n4. $(128, 256, \\text{tukey\\_theta}, 0.25)$\n\n对于每个测试用例，按顺序计算并返回三个边带功率分数 $P_{2,1}$、 $P_{3,2}$ 和 $P_{4,4}$。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表应按测试用例的顺序展开，对于四个测试用例，总共会产生十二个条目。例如，最终输出格式必须是\n$$\n[ P_{2,1}^{(1)}, P_{3,2}^{(1)}, P_{4,4}^{(1)}, P_{2,1}^{(2)}, P_{3,2}^{(2)}, P_{4,4}^{(2)}, \\dots ].\n$$\n所有计算值必须是浮点数。在整个计算过程中，角度必须以弧度处理。此计算不涉及任何物理单位。通过正确实现基于维格纳小d函数构造的自旋加权球谐函数并使用指定的求积方案，确保数值稳定性和科学真实性。",
            "solution": "用户的问题要求计算在各种加窗方案下，将一个纯自旋加权球谐信号投影到有限网格上所产生的边带功率分数。这是分析来自数值相对论的引力波信号中的一个标准问题，其中由于有限分辨率和加窗引起的频谱泄漏会污染提取的模态内容。该问题具有科学依据，定义明确，并且其所有组成部分都经过了形式化定义。因此，这是一个有效的问题。\n\n解决方案通过以下主要步骤实现：\n1.  **问题分解**：核心任务是计算内积积分的离散近似 $$c_{\\ell m} = \\int_{S^2} f_w(\\theta,\\phi)\\ {}_sY_{\\ell m}^*(\\theta,\\phi)\\ d\\Omega,$$ 其中 $d\\Omega = \\sin\\theta\\ d\\theta\\ d\\phi$。引力波应变的自旋权重为 $s=-2$。输入信号是一个纯模，$f(\\theta,\\phi) = {}_{-2}Y_{2,2}(\\theta,\\phi)$，然后乘以一个依赖于余纬的窗函数 $w(\\theta)$ 得到 $f_w(\\theta,\\phi) = w(\\theta)f(\\theta,\\phi)$。\n2.  **数值求积**：$c_{\\ell m}$ 的积分使用均匀网格上的矩形求积法则进行近似。该网格在余纬 $\\theta$上有 $N_\\theta$ 个点，在方位角 $\\phi$上有 $N_\\phi$ 个点。网格点为 $\\theta_i = (i+1/2)\\Delta\\theta$ (对于 $i \\in \\{0, \\dots, N_\\theta-1\\}$) 和 $\\phi_j = j\\Delta\\phi$ (对于 $j \\in \\{0, \\dots, N_\\phi-1\\}$)，其中 $\\Delta\\theta = \\pi/N_\\theta$ 和 $\\Delta\\phi = 2\\pi/N_\\phi$。离散化系数为\n    $$c_{\\ell m} \\approx \\sum_{i=0}^{N_\\theta-1}\\sum_{j=0}^{N_\\phi-1} f_w(\\theta_i,\\phi_j)\\ {}_{-2}Y_{\\ell m}^*(\\theta_i,\\phi_j)\\ \\sin\\theta_i\\ \\Delta\\theta\\ \\Delta\\phi.$$\n    对 $\\theta$ 使用中点采样可以避免在极点（$\\theta=0,\\pi$）处的奇点。\n3.  **自旋加权球谐函数的实现**：一个关键组成部分是自旋加权球谐函数 ${}_sY_{\\ell m}(\\theta,\\phi)$ 的数值计算。它们的定义是\n    $${}_sY_{\\ell m}(\\theta,\\phi) = (-1)^s \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,s}(\\theta) e^{im\\phi},$$\n    其中 $d^\\ell_{m,s}(\\theta)$ 是维格纳小d函数。为确保对于所需的适度 $\\ell$ 值具有正确性和数值稳定性，选择了一种基于维格纳-克莱布施-戈登级数（维格纳公式）的实现。使用了来自 Varshalovich, Moskalev, Khersonskii 的 $d^\\ell_{m',m}(\\beta)$ 函数公式，在我们的用例中，将 $(m', m)$ 映射到 $(m, s)$：\n    $$d^\\ell_{m,s}(\\theta) = \\left[ (\\ell+m)!(\\ell-m)!(\\ell+s)!(\\ell-s)! \\right]^{1/2} \\sum_z \\frac{(-1)^z}{z!(m-s+z)!(\\ell-m-z)!(\\ell+s-z)!} (\\cos(\\theta/2))^{2\\ell+s-m-2z}(\\sin(\\theta/2))^{m-s+2z}.$$\n    对 $z$ 的求和包括所有使阶乘参数为非负的整数值。这可以表示为从 $z_{min} = \\max(0, s-m)$ 到 $z_{max} = \\min(\\ell-m, \\ell+s)$ 的和。为了处理阶乘中可能出现的大数，使用 `scipy.special.gammaln` 计算它们的对数，其中 $\\ln(n!) = \\text{gammaln}(n+1)$。\n4.  **投影核**：投影需要复共轭 ${}_{-2}Y_{\\ell m}^*(\\theta,\\phi)$。鉴于维格纳d函数是实数，我们有\n    $${}_{-2}Y_{\\ell m}^*(\\theta, \\phi) = (-1)^{-2} \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,-2}(\\theta) e^{-im\\phi} = \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,-2}(\\theta) e^{-im\\phi}.$$\n    这通过计算 ${}_{-2}Y_{\\ell m}$ 然后取其复共轭来实现。\n5.  **窗函数**：将指定的窗函数（矩形窗、汉宁窗和Tukey窗）实现为余纬 $\\theta$ 的函数。Tukey窗由 $\\alpha$ 参数化。\n6.  **功率分数计算**：对于每个由 $(N_\\theta, N_\\phi, \\text{window}, \\alpha)$ 指定的测试用例，过程如下：\n    a. 生成一个 $(\\theta, \\phi)$ 值的二维网格。\n    b. 在此网格上计算输入信号 $f(\\theta,\\phi)$ 和投影核 ${}_{-2}Y_{\\ell m}^*$（对于模 $(\\ell,m) \\in \\{(2,1),(3,2),(4,4),(2,2)\\}$）。\n    c. 将适当的窗函数 $w(\\theta)$ 应用于输入信号。\n    d. 计算系数 $c_{\\ell m}$ 的离散和。\n    e. 计算边带功率分数 $P_{\\ell m} = |c_{\\ell m}|^2 / |c_{2,2}|^2$（对于 $(\\ell,m) \\in \\{(2,1),(3,2),(4,4)\\}$）。\n7.  **执行**：主函数遍历提供的测试套件，调用一个子程序为每个案例执行计算，并将结果汇总到一个单一列表中以供最终输出，格式如指定。\n\n因此，算法设计是问题陈述中数学规定的直接而稳健的实现，使用了适合该学科的标准的、数值稳定的技术。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef wigner_d(l, m1, m2, theta):\n    \"\"\"\n    Computes the Wigner small-d function d^l_{m1,m2}(theta) using the\n    summation formula from Varshalovich, Moskalev,  Khersonskii.\n    This implementation uses logarithms of factorials for numerical stability.\n    \"\"\"\n    # Wigner d-functions are defined for |m1| = l and |m2| = l.\n    if abs(m1) > l or abs(m2) > l:\n        return np.zeros_like(np.asarray(theta), dtype=float)\n\n    # Convert theta to a numpy array to handle scalar and array inputs uniformly.\n    theta = np.asarray(theta)\n    \n    # Summation limits for z\n    z_min = max(0, m2 - m1)\n    z_max = min(l - m1, l + m2)\n    \n    # Pre-compute the logarithm of the constant square-root factor.\n    log_sqrt_factor = 0.5 * (gammaln(l + m1 + 1) + gammaln(l - m1 + 1) +\n                             gammaln(l + m2 + 1) + gammaln(l - m2 + 1))\n    \n    # Initialize the result array.\n    d_val = np.zeros_like(theta, dtype=float)\n    \n    cos_half_theta = np.cos(theta / 2.0)\n    sin_half_theta = np.sin(theta / 2.0)\n    \n    for z in range(z_min, z_max + 1):\n        # Logarithm of the denominator in the summation term\n        log_denom_z = (gammaln(z + 1) +\n                       gammaln(m1 - m2 + z + 1) +\n                       gammaln(l - m1 - z + 1) +\n                       gammaln(l + m2 - z + 1))\n        \n        # Logarithm of the z-th term's coefficient\n        log_C_z = log_sqrt_factor - log_denom_z\n        C_z = np.exp(log_C_z)\n        \n        # Power exponents for cos and sin terms\n        pow_cos = 2 * l + m2 - m1 - 2 * z\n        pow_sin = m1 - m2 + 2 * z\n        \n        # The grid for theta avoids 0 and pi, so cos_half_theta and sin_half_theta are non-zero.\n        # This prevents issues with 0**negative_power.\n        term_z = C_z * (cos_half_theta**pow_cos) * (sin_half_theta**pow_sin)\n        \n        d_val += (-1)**z * term_z\n            \n    return d_val\n\ndef spin_weighted_Y(s, l, m, theta, phi):\n    \"\"\"\n    Computes the spin-weighted spherical harmonic sYlm(theta, phi).\n    \"\"\"\n    if abs(m) > l or abs(s) > l:\n        if isinstance(theta, np.ndarray):\n            return np.zeros_like(theta, dtype=complex)\n        else:\n            return 0.0 + 0.0j\n\n    # In sYlm, the d-function is d^l_{m,s}. So m1=m, m2=s.\n    d_func = wigner_d(l, m, s, theta)\n    norm = np.sqrt((2 * l + 1) / (4 * np.pi))\n    phase = np.exp(1j * m * phi)\n    \n    return (-1)**s * norm * d_func * phase\n\ndef get_window_function(name, alpha, N_theta):\n    \"\"\"\n    Generates the specified window function array.\n    \"\"\"\n    theta = (np.arange(N_theta) + 0.5) * np.pi / N_theta\n    if name == 'rect':\n        return np.ones(N_theta)\n    \n    x = theta / np.pi\n    if name == 'hann_theta':\n        return 0.5 * (1 - np.cos(2 * np.pi * x))\n    elif name == 'tukey_theta':\n        w = np.ones_like(x)\n        # First section of the Tukey window\n        mask1 = x  alpha / 2.0\n        w[mask1] = 0.5 * (1 + np.cos(np.pi * (2 * x[mask1] / alpha - 1)))\n        # Last section of the Tukey window\n        mask3 = x > 1 - alpha / 2.0\n        w[mask3] = 0.5 * (1 + np.cos(np.pi * (2 * (1 - x[mask3]) / alpha - 1)))\n        return w\n    else:\n        raise ValueError(f\"Unknown window: {name}\")\n\ndef calculate_power_fractions(N_theta, N_phi, window_name, alpha):\n    \"\"\"\n    Performs the full calculation for a single test case.\n    \"\"\"\n    s = -2 # Spin weight\n    \n    # 1. Set up the grid\n    delta_theta = np.pi / N_theta\n    delta_phi = 2 * np.pi / N_phi\n    \n    theta_pts = (np.arange(N_theta) + 0.5) * delta_theta\n    phi_pts = np.arange(N_phi) * delta_phi\n    \n    theta_mesh, phi_mesh = np.meshgrid(theta_pts, phi_pts, indexing='ij')\n\n    # 2. Define the input signal on the grid\n    # f(theta, phi) = -2_Y_2,2(theta, phi)\n    input_signal_grid = spin_weighted_Y(s, 2, 2, theta_mesh, phi_mesh)\n    \n    # 3. Apply the window function\n    window = get_window_function(window_name, alpha, N_theta)\n    # Window is 1D (theta-dependent), broadcast it to the 2D grid\n    windowed_signal_grid = window[:, np.newaxis] * input_signal_grid\n    \n    # 4. Compute projection coefficients\n    modes_to_calculate = [(2, 2), (2, 1), (3, 2), (4, 4)]\n    coeffs = {}\n    \n    d_omega = np.sin(theta_mesh) * delta_theta * delta_phi\n\n    for l_val, m_val in modes_to_calculate:\n        # Kernel is the complex conjugate of sYlm\n        kernel_grid = np.conj(spin_weighted_Y(s, l_val, m_val, theta_mesh, phi_mesh))\n        \n        integrand = windowed_signal_grid * kernel_grid\n        \n        c_lm = np.sum(integrand * d_omega)\n        coeffs[(l_val, m_val)] = c_lm\n\n    # 5. Calculate power fractions\n    c_22_sq = np.abs(coeffs[(2, 2)])**2\n    \n    if c_22_sq == 0:\n        # Avoid division by zero, though it's physically unlikely here.\n        P_21 = P_32 = P_44 = np.inf\n    else:\n        P_21 = np.abs(coeffs[(2, 1)])**2 / c_22_sq\n        P_32 = np.abs(coeffs[(3, 2)])**2 / c_22_sq\n        P_44 = np.abs(coeffs[(4, 4)])**2 / c_22_sq\n        \n    return [P_21, P_32, P_44]\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the result.\n    \"\"\"\n    test_cases = [\n        (64, 128, 'rect', 0.0),\n        (8, 16, 'rect', 0.0),\n        (64, 128, 'hann_theta', 0.0),\n        (128, 256, 'tukey_theta', 0.25),\n    ]\n\n    results = []\n    for case in test_cases:\n        N_theta, N_phi, window_name, alpha = case\n        case_results = calculate_power_fractions(N_theta, N_phi, window_name, alpha)\n        results.extend(case_results)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在每个时间步对波形进行空间分解后，我们得到每个模式系数的时间序列，对于数值相对论的模拟，通常是曲率标量 $\\Psi_4$ 的模式系数。最后的这个练习旨在解决通过两次时间积分恢复应变模式 $h_{\\ell m}(t)$ 时所面临的挑战，即 $\\Psi_{4,\\ell m}(t) = \\frac{d^{2}}{dt^{2}} h_{\\ell m}(t)$，这一过程因其数值不稳定性而臭名昭著。你将比较一种朴素的时域方法和一种稳健的频域正则化方法，以理解如何处理和减轻在实践中至关重要的低频漂移问题。",
            "id": "3471605",
            "problem": "考虑一个在渐近平坦区由致密双星源发出的引力波波形，其复应变为 $h(t) = h_{+}(t) - i h_{\\times}(t)$。在数值相对论中，Newman–Penrose 标量 $\\Psi_{4}(t,\\theta,\\phi)$ 和应变 $h(t,\\theta,\\phi)$ 被分解为自旋权重为 -2 的自旋权重球谐函数，\n$$\n\\Psi_{4}(t,\\theta,\\phi) = \\sum_{\\ell = 2}^{\\infty} \\sum_{m=-\\ell}^{\\ell} \\Psi_{4,\\ell m}(t)\\, {}_{-2}Y_{\\ell m}(\\theta,\\phi), \\quad\nh(t,\\theta,\\phi) = \\sum_{\\ell = 2}^{\\infty} \\sum_{m=-\\ell}^{\\ell} h_{\\ell m}(t)\\, {}_{-2}Y_{\\ell m}(\\theta,\\phi).\n$$\n在辐射区，新闻函数与应变之间的基本关系意味着\n$$\n\\Psi_{4,\\ell m}(t) = \\frac{d^{2}}{dt^{2}} h_{\\ell m}(t).\n$$\n因此，从 $\\Psi_{4,\\ell m}(t)$ 恢复 $h_{\\ell m}(t)$ 需要进行双重时间积分。然而，在存在低频污染和有限时长数据的情况下，直接进行双重积分在数值上是不稳定的，会导致 $h_{\\ell m}(t)$ 出现长期漂移。一个常见的解决方法是使用快速傅里叶变换 (FFT) 在频域中执行该操作，通过除以角频率的平方并在低频处进行正则化。\n\n您的任务是，给定 $\\Psi_{4,\\ell m}(t)$，实现并比较两种用于 $h_{\\ell m}(t)$ 的逐模式重构方法：\n- 一种使用累积梯形积分和零初始条件的朴素时域双重积分法。\n- 一种使用固定频率积分 (FFI) 法则的频域正则化积分法：如果 $\\widehat{\\Psi}_{4,\\ell m}(f)$ 表示频率为 $f$（单位为赫兹）的傅里叶变换，那么\n$$\n\\widehat{h}_{\\ell m}(f) \\approx -\\frac{\\widehat{\\Psi}_{4,\\ell m}(f)}{(2\\pi f)^{2}_{\\mathrm{clip}}},\n$$\n其中\n$$\n(2\\pi f)^{2}_{\\mathrm{clip}} = \\begin{cases}\n(2\\pi f_{0})^{2},  \\text{if } |f|  f_{0}, \\\\\n(2\\pi f)^{2},  \\text{if } |f| \\ge f_{0},\n\\end{cases}\n$$\n且 $f_{0}$ 是一个选定的截止频率。在进行除法运算后，应用逆傅里叶变换以获得 $h_{\\ell m}(t)$。\n\n从以下基本依据出发：\n- 渐进关系 $\\Psi_{4,\\ell m}(t) = d^{2}h_{\\ell m}(t)/dt^{2}$。\n- 对于任何具有傅里叶变换 $\\widehat{x}(f)$ 的足够光滑的函数 $x(t)$，其傅里叶导数性质为 $\\widehat{d^{2}x/dt^{2}}(f) = -(2\\pi f)^{2}\\widehat{x}(f)$，这里使用的约定是 $\\widehat{x}(f) = \\int_{-\\infty}^{\\infty} x(t) e^{-i 2\\pi f t}\\,dt$。\n\n您将使用合成的逐模式数据来测试这两种重构方法，其中基准真相 $h_{\\ell m}(t)$ 由解析式指定，而 $\\Psi_{4,\\ell m}(t)$ 由它生成。所有时间必须以秒表示，所有频率以赫兹表示，所有角度以弧度表示。应变振幅是无量纲的。请使用每个测试用例中指定的离散时间采样间隔 $\\Delta t$。\n\n将重构的 $\\tilde{h}_{\\ell m}(t)$ 和基准真相 $h_{\\ell m}(t)$ 之间的相对误差定义为离散时间 $L^{2}$-范数比\n$$\n\\varepsilon = \\frac{\\left\\| \\tilde{h}_{\\ell m} - h_{\\ell m} \\right\\|_{2}}{\\left\\| h_{\\ell m} \\right\\|_{2}} = \\frac{\\sqrt{\\sum_{n=0}^{N-1} \\left| \\tilde{h}_{\\ell m}(t_{n}) - h_{\\ell m}(t_{n}) \\right|^{2}\\,\\Delta t}}{\\sqrt{\\sum_{n=0}^{N-1} \\left| h_{\\ell m}(t_{n}) \\right|^{2}\\,\\Delta t}},\n$$\n其中 $t_{n} = n\\,\\Delta t$，$N$ 是采样点数。\n\n实现以下三模式测试套件，每个模式都作为一个独立的 $(\\ell,m)$ 模式处理。对于每个模式，构造基准真相 $h_{\\ell m}(t)$，由它生成 $\\Psi_{4,\\ell m}(t)$，然后使用两种方法重构 $h_{\\ell m}(t)$，并报告两种方法的相对误差。\n\n所有常数和参数的数值如下所示：\n- 通用采样间隔和频率单位：\n  - $\\Delta t = 1/4096$ $\\mathrm{s}$。\n  - 角度使用弧度，频率使用赫兹。\n- 测试用例 $1$（单频复指数，名义上为 $(\\ell,m)=(2,2)$ 模式）：\n  - 持续时间 $T = 0.5$ $\\mathrm{s}$。\n  - 振幅 $A = 10^{-21}$。\n  - 载波频率 $f = 150$ $\\mathrm{Hz}$。\n  - 基准真相: $h_{22}(t) = A\\,e^{i\\,2\\pi f t}$。\n  - 导出的源: $\\Psi_{4,22}(t) = \\frac{d^{2}}{dt^{2}} h_{22}(t) = - (2\\pi f)^{2} A\\,e^{i\\,2\\pi f t}$。\n  - FFI 截止频率: $f_{0} = 120$ $\\mathrm{Hz}$。\n- 测试用例 $2$（线性啁啾，名义上为 $(\\ell,m)=(2,2)$ 模式）：\n  - 持续时间 $T = 1.0$ $\\mathrm{s}$。\n  - 振幅 $A = 5\\times 10^{-22}$。\n  - 瞬时相位 $\\theta(t) = 2\\pi \\left(f_{\\mathrm{start}} t + \\frac{1}{2} k t^{2}\\right)$，其中 $f_{\\mathrm{start}} = 30$ $\\mathrm{Hz}$，啁啾率 $k = 200$ $\\mathrm{Hz/s}$。\n  - 基准真相: $h_{22}(t) = A\\,e^{i\\,\\theta(t)}$。\n  - 使用解析关系 $\\frac{d^{2}}{dt^{2}} e^{i\\theta(t)} = \\left(-(\\dot{\\theta}(t))^{2} + i \\ddot{\\theta}(t)\\right) e^{i\\theta(t)}$，其中 $\\dot{\\theta}(t) = 2\\pi \\left(f_{\\mathrm{start}} + k t\\right)$ 且 $\\ddot{\\theta}(t) = 2\\pi k$，来定义 $\\Psi_{4,22}(t) = \\frac{d^{2}}{dt^{2}} h_{22}(t)$。\n  - FFI 截止频率: $f_{0} = 25$ $\\mathrm{Hz}$。\n- 测试用例 $3$（$\\Psi_{4}$ 中带有低频污染的单频信号，用于测试漂移敏感性，名义上为 $(\\ell,m)=(2,2)$ 模式）：\n  - 持续时间 $T = 1.0$ $\\mathrm{s}$。\n  - 振幅 $A = 5\\times 10^{-22}$。\n  - 载波频率 $f = 80$ $\\mathrm{Hz}$。\n  - 基准真相: $h_{22}(t) = A\\,e^{i\\,2\\pi f t}$。\n  - 导出的基准源: $\\Psi_{4,22}^{\\mathrm{base}}(t) = - (2\\pi f)^{2} A\\,e^{i\\,2\\pi f t}$。\n  - 附加的低频污染 (单位 $\\mathrm{s}^{-2}$): $s(t) = c_{0} + c_{1} t$，其中 $c_{0} = 3\\times 10^{-24}$，$c_{1} = 10^{-24}$ $\\mathrm{s}^{-1}$，得到 $\\Psi_{4,22}(t) = \\Psi_{4,22}^{\\mathrm{base}}(t) + s(t)$。\n  - FFI 截止频率: $f_{0} = 60$ $\\mathrm{Hz}$。\n\n对于每个测试用例，计算两个数值：\n- $\\varepsilon_{\\mathrm{TD}}$: 朴素时域双重积分的相对误差。\n- $\\varepsilon_{\\mathrm{FFI}}$: 带截止频率 $f_{0}$ 的频域固定频率积分的相对误差。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n$$\n\\left[ \\varepsilon_{\\mathrm{TD}}^{(1)}, \\varepsilon_{\\mathrm{FFI}}^{(1)}, \\varepsilon_{\\mathrm{TD}}^{(2)}, \\varepsilon_{\\mathrm{FFI}}^{(2)}, \\varepsilon_{\\mathrm{TD}}^{(3)}, \\varepsilon_{\\mathrm{FFI}}^{(3)} \\right],\n$$\n其中上标 $(1)$、$(2)$、$(3)$ 分别指代测试用例 1、2 和 3。所有六个输出都必须是浮点数。输出中不表示任何物理单位；这些数字是无量纲的相对误差。内部计算必须遵守上述指定的单位，所有角度以弧度为单位，所有频率以赫兹为单位。不需要外部输入；所有参数均在此处完全指定。",
            "solution": "该问题要求实现并比较两种从引力波应变模式的二阶时间导数，即 Newman-Penrose 标量模式 $\\Psi_{4,\\ell m}(t)$，重构 $h_{\\ell m}(t)$ 的方法。其基本关系由微分方程 $\\Psi_{4,\\ell m}(t) = d^{2}h_{\\ell m}(t)/dt^{2}$ 给出。这两种方法分别是直接时域双重积分和正则化频域积分。\n\n首先，我们建立离散时间序列的表示方法。对于一个持续时间为 $T$，采样间隔为 $\\Delta t$ 的信号，我们有一个由 $N$ 个时间点组成的序列 $t_n = n \\Delta t$（$n = 0, 1, \\dots, N-1$），其中 $N = \\text{round}(T/\\Delta t)$。连续函数 $h_{\\ell m}(t)$ 和 $\\Psi_{4,\\ell m}(t)$ 由其离散样本 $h_{\\ell m}(t_n)$ 和 $\\Psi_{4,\\ell m}(t_n)$ 表示。\n\n### 方法 1：朴素时域双重积分 ($\\varepsilon_{\\mathrm{TD}}$)\n该方法通过执行连续两次数值积分来直接求解微分方程。\n第一次积分得到应变的一阶时间导数，我们记为 $\\dot{h}_{\\ell m}(t)$：\n$$\n\\dot{h}_{\\ell m}(t) = \\int_{t_0}^{t} \\Psi_{4,\\ell m}(t') \\, dt' + \\dot{h}_{\\ell m}(t_0)\n$$\n第二次积分得到应变本身：\n$$\nh_{\\ell m}(t) = \\int_{t_0}^{t} \\dot{h}_{\\ell m}(t') \\, dt' + h_{\\ell m}(t_0)\n$$\n问题指定使用累积梯形积分和零初始条件，因此我们设置 $\\dot{h}_{\\ell m}(t_0) = 0$ 和 $h_{\\ell m}(t_0) = 0$。\n\n在数值上，给定离散样本 $\\Psi_{4,\\ell m}(t_n)$，我们首先使用累积梯形法则计算一阶导数的样本 $\\dot{h}_{\\ell m}(t_n)$。我们将此操作表示为 $\\text{CumTrapz}$。\n$$\n\\dot{h}_{\\ell m}(t_n) = \\text{CumTrapz}(\\Psi_{4,\\ell m}(t_k))_{k=0}^n\n$$\n然后我们再次应用此操作以获得重构的应变 $\\tilde{h}_{\\ell m}(t_n)$：\n$$\n\\tilde{h}_{\\ell m}^{\\mathrm{TD}}(t_n) = \\text{CumTrapz}(\\dot{h}_{\\ell m}(t_k))_{k=0}^n\n$$\n这种方法被认为是“朴素的”，因为它对输入数据 $\\Psi_{4,\\ell m}(t)$ 中的任何低频误差或偏差都高度敏感。例如，$\\Psi_{4,\\ell m}(t)$ 中一个小的恒定偏移 $c_0$ 会在重构的 $\\tilde{h}_{\\ell m}(t)$ 中导致一个二次漂移项 $\\frac{1}{2} c_0 t^2$，对于长的积分时间，该项会迅速主导真实信号。\n\n### 方法 2：频域固定频率积分 (FFI) ($\\varepsilon_{\\mathrm{FFI}}$)\n该方法利用傅里叶变换的性质来执行积分。傅里叶变换定义为 $\\widehat{x}(f) = \\int_{-\\infty}^{\\infty} x(t) e^{-i 2\\pi f t}\\,dt$，它将微分运算转换为乘法运算。具体来说，二阶导数的傅里叶变换是：\n$$\n\\mathcal{F}\\left\\{\\frac{d^2x}{dt^2}\\right\\}(f) = (-i 2\\pi f)^2 \\widehat{x}(f) = -(2\\pi f)^2 \\widehat{x}(f)\n$$\n将此应用于我们的控制方程，我们得到：\n$$\n\\widehat{\\Psi}_{4,\\ell m}(f) = -(2\\pi f)^2 \\widehat{h}_{\\ell m}(f)\n$$\n对应变的傅里叶变换 $\\widehat{h}_{\\ell m}(f)$ 进行代数求解，可得：\n$$\n\\widehat{h}_{\\ell m}(f) = - \\frac{\\widehat{\\Psi}_{4,\\ell m}(f)}{(2\\pi f)^2}\n$$\n这个表达式揭示了一个数值不稳定性：对于趋近于 0 的频率 $f$，分母也趋于零，这会导致 $\\widehat{\\Psi}_{4,\\ell m}(f)$ 中的任何低频数值噪声或物理内容被巨大放大。\n\n固定频率积分 (FFI) 方法通过在选定的截止频率 $f_0$ 处“裁剪”分母来对该操作进行正则化。传递函数修改如下：\n$$\n\\widehat{\\tilde{h}}_{\\ell m}^{\\mathrm{FFI}}(f) = -\\frac{\\widehat{\\Psi}_{4,\\ell m}(f)}{(2\\pi f)^{2}_{\\mathrm{clip}}}\n$$\n其中裁剪项定义为：\n$$\n(2\\pi f)^{2}_{\\mathrm{clip}} = \\begin{cases}\n(2\\pi f_{0})^{2},  \\text{if } |f|  f_{0} \\\\\n(2\\pi f)^{2},  \\text{if } |f| \\ge f_{0}\n\\end{cases}\n$$\n这个过程可以防止在 $f=0$ 时出现除以零的情况，并通过将小的分母 $(2\\pi f)^2$ 替换为一个恒定的下限 $(2\\pi f_0)^2$ 来减轻对低于截止频率 $f_0$ 的所有频率的低频噪声的放大。\n\n算法如下：\n1.  计算时间序列 $\\Psi_{4,\\ell m}(t_n)$ 的离散傅里叶变换，得到 $\\widehat{\\Psi}_{4,\\ell m}(f_k)$。\n2.  构建离散频率数组 $f_k$。\n3.  对于每个频率 $f_k$，使用给定的 $f_0$ 计算 $(2\\pi f_k)^2_{\\mathrm{clip}}$ 的值。\n4.  计算重构的频域应变 $\\widehat{\\tilde{h}}_{\\ell m}^{\\mathrm{FFI}}(f_k)$。\n5.  计算 $\\widehat{\\tilde{h}}_{\\ell m}^{\\mathrm{FFI}}(f_k)$ 的离散傅里叶逆变换，以获得时域信号 $\\tilde{h}_{\\ell m}^{\\mathrm{FFI}}(t_n)$。\n\n### 误差度量\n每次重构 $\\tilde{h}_{\\ell m}(t)$ 的准确度由相对误差 $\\varepsilon$ 来量化，其定义为重构信号与基准真相信号之差的 $L^2$-范数与基准真相信号的 $L^2$-范数之比。对于一个包含 $N$ 个点的离散时间序列，其表达式为：\n$$\n\\varepsilon = \\frac{\\left\\| \\tilde{h}_{\\ell m} - h_{\\ell m} \\right\\|_{2}}{\\left\\| h_{\\ell m} \\right\\|_{2}} = \\frac{\\sqrt{\\sum_{n=0}^{N-1} \\left| \\tilde{h}_{\\ell m}(t_{n}) - h_{\\ell m}(t_{n}) \\right|^{2}}}{\\sqrt{\\sum_{n=0}^{N-1} \\left| h_{\\ell m}(t_{n}) \\right|^{2}}}\n$$\n注意，在离散 $L^2$-范数的形式化定义中，因子 $\\sqrt{\\Delta t}$ 会从分子和分母中约去，因此在计算中可以省略。这等同于对表示时间序列的复向量使用标准的欧几里得范数。这两种方法都将应用于三个不同的测试用例，以评估它们在不同信号条件下的性能。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for waveform reconstruction.\n    \"\"\"\n\n    def run_reconstruction(\n        T, dt, h_true_func, psi4_func, f0\n    ):\n        \"\"\"\n        Runs one test case for reconstructing h(t) from Psi4(t).\n\n        Args:\n            T (float): Duration of the signal in seconds.\n            dt (float): Sampling interval in seconds.\n            h_true_func (callable): Function to generate the ground-truth h_lm(t).\n            psi4_func (callable): Function to generate the source Psi4_lm(t).\n            f0 (float): Cutoff frequency for the FFI method in Hz.\n\n        Returns:\n            tuple[float, float]: A tuple containing the relative errors\n                                 (err_td, err_ffi).\n        \"\"\"\n        N = int(round(T / dt))\n        t = np.arange(N) * dt\n\n        h_true = h_true_func(t)\n        psi4 = psi4_func(t)\n\n        # Method 1: Time-Domain Double Integration\n        v_td = cumulative_trapezoid(psi4, t, initial=0)\n        h_td = cumulative_trapezoid(v_td, t, initial=0)\n\n        # Method 2: Frequency-Domain Fixed-Frequency Integration (FFI)\n        psi4_hat = np.fft.fft(psi4)\n        freqs = np.fft.fftfreq(N, d=dt)\n        \n        # Calculate the clipped denominator: -(2*pi*f)^2_clip\n        # The problem statement gives h_hat = -psi4_hat / (2*pi*f)^2_clip\n        # which is equivalent to h_hat = psi4_hat / (-(2*pi*f)^2_clip)\n        omega_sq = (2 * np.pi * freqs)**2\n        omega_sq_clip = np.copy(omega_sq)\n        \n        # Apply the cutoff frequency f0\n        mask = np.abs(freqs)  f0\n        cutoff_val = (2 * np.pi * f0)**2\n        omega_sq_clip[mask] = cutoff_val\n\n        # Handle f=0 case explicitly, although mask should cover it.\n        # This prevents division by zero if f0 were 0.\n        if freqs[0] == 0:\n            omega_sq_clip[0] = cutoff_val\n        \n        h_hat_ffi = -psi4_hat / omega_sq_clip\n        h_ffi = np.fft.ifft(h_hat_ffi)\n\n        # Calculate relative errors\n        norm_h_true = np.linalg.norm(h_true)\n        if norm_h_true == 0:\n            return (np.inf, np.inf)\n\n        err_td = np.linalg.norm(h_td - h_true) / norm_h_true\n        err_ffi = np.linalg.norm(h_ffi - h_true) / norm_h_true\n\n        return err_td, err_ffi\n\n    # Common parameters\n    dt = 1 / 4096.0\n\n    # Test Case 1: Single frequency\n    A1 = 1e-21\n    f1 = 150.0\n    T1 = 0.5\n    f0_1 = 120.0\n    h_true_1 = lambda t: A1 * np.exp(1j * 2 * np.pi * f1 * t)\n    psi4_1 = lambda t: -(2 * np.pi * f1)**2 * h_true_1(t)\n\n    # Test Case 2: Linear chirp\n    A2 = 5e-22\n    f_start2 = 30.0\n    k2 = 200.0\n    T2 = 1.0\n    f0_2 = 25.0\n    def h_true_2(t):\n        phase = 2 * np.pi * (f_start2 * t + 0.5 * k2 * t**2)\n        return A2 * np.exp(1j * phase)\n    def psi4_2(t):\n        phase = 2 * np.pi * (f_start2 * t + 0.5 * k2 * t**2)\n        dot_theta = 2 * np.pi * (f_start2 + k2 * t)\n        ddot_theta = 2 * np.pi * k2\n        return (-(dot_theta**2) + 1j * ddot_theta) * A2 * np.exp(1j * phase)\n\n    # Test Case 3: Single frequency with low-frequency contamination\n    A3 = 5e-22\n    f3 = 80.0\n    c0_3 = 3e-24\n    c1_3 = 1e-24\n    T3 = 1.0\n    f0_3 = 60.0\n    h_true_3 = lambda t: A3 * np.exp(1j * 2 * np.pi * f3 * t)\n    def psi4_3(t):\n        psi4_base = -(2 * np.pi * f3)**2 * h_true_3(t)\n        contamination = c0_3 + c1_3 * t\n        return psi4_base + contamination\n\n    # Define test cases\n    test_cases = [\n        {'T': T1, 'dt': dt, 'h_true_func': h_true_1, 'psi4_func': psi4_1, 'f0': f0_1},\n        {'T': T2, 'dt': dt, 'h_true_func': h_true_2, 'psi4_func': psi4_2, 'f0': f0_2},\n        {'T': T3, 'dt': dt, 'h_true_func': h_true_3, 'psi4_func': psi4_3, 'f0': f0_3},\n    ]\n\n    results = []\n    for case in test_cases:\n        err_td, err_ffi = run_reconstruction(**case)\n        results.extend([err_td, err_ffi])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}