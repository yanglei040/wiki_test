{
    "hands_on_practices": [
        {
            "introduction": "In numerical relativity, gravitational waves are typically extracted on a worldtube of finite radius $R$. The simplest method for enforcing an outgoing wave boundary condition is the Sommerfeld condition, which is exact for plane waves but only approximate for the spherical waves characteristic of radiating sources. This practice will guide you through quantifying the leading-order systematic phase error introduced by this approximation and developing a practical extrapolation scheme to recover the correct waveform phase at null infinity, a foundational skill for high-precision data analysis .",
            "id": "3482117",
            "problem": "In numerical relativity for gravitational radiation, wave extraction is often performed on a finite-radius sphere where an outgoing boundary condition is imposed. Consider a far-zone multipolar gravitational waveform mode whose propagation can be modeled, to leading order in the radiation zone, by a solution of the flat-spacetime scalar wave equation for each spherical-harmonic mode, capturing the same radial falloff and outgoing character. The outer boundary implements the Sommerfeld boundary condition (SBC), defined as $(\\partial_{t} + \\partial_{r}) \\psi = 0$ at large radius, and the extracted waveform phase is measured on spheres of radius $R$ with retarded time $u_{R} = t - R$. Assume the dominant mode has spherical-harmonic index $l = 2$ and monochromatic angular frequency $\\omega$ (so the wavenumber satisfies $k = \\omega$ in units with the speed of light equal to one), and that the waveform is represented by a complex mode amplitude that allows a well-defined phase.\n\nStarting from the scalar wave equation in spherical coordinates,\n$$\n\\partial_{t}^{2} \\psi - \\partial_{r}^{2} \\psi - \\frac{2}{r} \\partial_{r} \\psi + \\frac{1}{r^{2}} \\Delta_{\\mathbb{S}^{2}} \\psi = 0,\n$$\nand the spherical-harmonic decomposition $\\psi(t,r,\\Omega) = \\sum_{l,m} \\frac{1}{r} \\chi_{lm}(t,r) Y_{lm}(\\Omega)$ with $\\Delta_{\\mathbb{S}^{2}} Y_{lm}(\\Omega) = - l(l+1) Y_{lm}(\\Omega)$, derive the large-$R$ asymptotic outgoing solution for the $l=2$ monochromatic mode that is consistent with the Sommerfeld boundary condition at leading order. From this asymptotic solution, compute the leading-order systematic phase error $\\Delta \\phi(R)$ between the phase measured at finite radius $R$ and the phase at null infinity, expressed in terms of $\\omega$ and $R$. Finally, design a first-order $1/R$ extrapolation scheme for the phase that recovers the value at null infinity by fitting the finite-radius phase measurements to a polynomial in $1/R$, and write down the explicit two-radius formula for $\\phi_{\\infty}$ in terms of $\\phi(R_{1})$ and $\\phi(R_{2})$ and the corresponding radii $R_{1}$ and $R_{2}$. \n\nYour final answer must be the single closed-form analytic expression for the leading-order systematic phase error $\\Delta \\phi(R)$ in terms of $\\omega$ and $R$ only. No numerical evaluation is required.",
            "solution": "The problem asks for the leading-order systematic phase error in a gravitational waveform mode extracted at a finite radius $R$, compared to its value at null infinity. The waveform mode is modeled as a solution to the scalar wave equation.\n\nFirst, we validate the problem statement.\n\n### Step 1: Extract Givens\n-   **Field Equation**: The scalar wave equation in spherical coordinates is given as:\n    $$\n    \\partial_{t}^{2} \\psi - \\partial_{r}^{2} \\psi - \\frac{2}{r} \\partial_{r} \\psi + \\frac{1}{r^{2}} \\Delta_{\\mathbb{S}^{2}} \\psi = 0\n    $$\n-   **Spherical-Harmonic Decomposition**: The solution is decomposed as:\n    $$\n    \\psi(t,r,\\Omega) = \\sum_{l,m} \\frac{1}{r} \\chi_{lm}(t,r) Y_{lm}(\\Omega)\n    $$\n-   **Angular Eigenvalue Equation**: The spherical harmonics $Y_{lm}(\\Omega)$ are eigenfunctions of the Laplacian on the unit 2-sphere, $\\Delta_{\\mathbb{S}^{2}}$:\n    $$\n    \\Delta_{\\mathbb{S}^{2}} Y_{lm}(\\Omega) = -l(l+1) Y_{lm}(\\Omega)\n    $$\n-   **Mode of Interest**: The dominant mode has spherical-harmonic index $l=2$.\n-   **Time Dependence**: The mode is monochromatic with angular frequency $\\omega$. In units where the speed of light $c=1$, the wavenumber is $k=\\omega$.\n-   **Boundary Condition**: The Sommerfeld boundary condition (SBC) is imposed at large radius: $(\\partial_{t} + \\partial_{r}) \\psi = 0$. This condition formalizes the requirement that the wave is purely outgoing.\n-   **Phase Measurement**: The phase is measured on spheres of radius $R$ at retarded time $u_{R} = t - R$.\n-   **Objective**: Derive the leading-order phase error $\\Delta \\phi(R)$ and an extrapolation formula. The final answer required is the expression for $\\Delta \\phi(R)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It utilizes the standard mathematical physics framework for wave propagation in the far-field, specifically the scalar wave equation, spherical harmonics, and outgoing wave conditions. These are fundamental tools in the study of radiation in general, and their application to gravitational wave extraction in numerical relativity is a standard, albeit simplified, model. The givens are self-contained and consistent. The problem does not violate any physical principles or contain any factual inaccuracies. It is a formalizable and solvable problem within the specified domain.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. We proceed to the solution.\n\nThe provided scalar wave equation is the standard form in spherical coordinates, which can be written as $\\partial_t^2 \\psi - \\nabla^2 \\psi = 0$. For a monochromatic wave of frequency $\\omega$, we assume a time dependence of the form $e^{-i\\omega t}$. The spatial part of the wave function then satisfies the Helmholtz equation, $(\\nabla^2 + k^2)\\psi = 0$, with $k=\\omega$.\n\nFor a single spherical-harmonic mode $(l,m)$, the solution can be written as $\\psi_{lm}(t,r,\\Omega) = \\mathcal{R}_l(r) Y_{lm}(\\Omega) e^{-i\\omega t}$. Substituting this into the Helmholtz equation yields the spherical Bessel differential equation for the radial function $\\mathcal{R}_l(r)$:\n$$\n\\frac{d^2 \\mathcal{R}_l}{dr^2} + \\frac{2}{r} \\frac{d\\mathcal{R}_l}{dr} + \\left(k^2 - \\frac{l(l+1)}{r^2}\\right) \\mathcal{R}_l = 0\n$$\nThe general solutions to this equation are linear combinations of spherical Bessel functions $j_l(kr)$ and $y_l(kr)$. For an outgoing wave solution, which is required physically for radiation problems and is consistent with the Sommerfeld condition at large $r$, the appropriate basis is the spherical Hankel functions. Specifically, the outgoing solution is described by the spherical Hankel function of the first kind, $h_l^{(1)}(kr) = j_l(kr) + i y_l(kr)$.\n\nThus, the outgoing monochromatic $l=2$ mode has the form:\n$$\n\\psi(t,r) \\propto h_2^{(1)}(\\omega r) e^{-i\\omega t}\n$$\nwhere we have suppressed the angular dependence $Y_{2m}(\\Omega)$ as it is constant for a given mode.\n\nTo find the phase error, we must compare the phase of this solution at a finite radius $R$ with its phase at null infinity ($R \\to \\infty$). This requires the asymptotic expansion of the Hankel function for large arguments, $z \\gg l$. The expansion is given by:\n$$\nh_l^{(1)}(z) \\sim \\frac{e^{i(z - (l+1)\\pi/2)}}{z} \\sum_{j=0}^{\\infty} \\frac{i^j}{j!(2z)^j} \\frac{(l+j)!}{(l-j)!}\n$$\nFor $l=2$, the polynomial in the summation terminates at $j=l=2$. The coefficients are non-zero only for $j \\le l$.\n$$\nh_2^{(1)}(z) \\sim \\frac{e^{i(z - 3\\pi/2)}}{z} \\left[ \\frac{i^0}{0!(2z)^0}\\frac{2!}{0!} + \\frac{i^1}{1!(2z)^1}\\frac{3!}{1!} + \\frac{i^2}{2!(2z)^2}\\frac{4!}{0!} \\right]\n$$\n$$\nh_2^{(1)}(z) \\sim \\frac{e^{i(z - 3\\pi/2)}}{z} \\left( 1 + \\frac{6i}{2z} - \\frac{24}{8z^2} \\right) = \\frac{e^{i(z - 3\\pi/2)}}{z} \\left( 1 + \\frac{3i}{z} - \\frac{3}{z^2} \\right)\n$$\nSubstituting $z = \\omega R$, the waveform at large radius $R$ is:\n$$\n\\psi(t,R) \\propto \\frac{e^{i(\\omega R - 3\\pi/2)}}{ \\omega R} \\left( 1 + \\frac{3i}{\\omega R} - \\frac{3}{(\\omega R)^2} \\right) e^{-i\\omega t}\n$$\nThe phase of this complex quantity, $\\phi(R)$, is the sum of the phases of its factors:\n$$\n\\phi(R) = \\arg(\\psi(t,R)) = \\omega R - \\omega t - \\frac{3\\pi}{2} + \\arg\\left(1 + \\frac{3i}{\\omega R} - \\frac{3}{(\\omega R)^2}\\right)\n$$\nThe phase at null infinity, $\\phi_{\\infty}$, is defined by the leading term of this asymptotic expansion, which corresponds to the limit $R \\to \\infty$. In this limit, the argument of the term in parentheses becomes $\\arg(1) = 0$. Therefore, the phase at null infinity is:\n$$\n\\phi_{\\infty} = \\omega R - \\omega t - \\frac{3\\pi}{2}\n$$\nThe phase error $\\Delta \\phi(R)$ is the difference between the phase at finite radius $R$ and the phase at null infinity:\n$$\n\\Delta \\phi(R) = \\phi(R) - \\phi_{\\infty} = \\arg\\left(1 + \\frac{3i}{\\omega R} - \\frac{3}{(\\omega R)^2}\\right)\n$$\nTo evaluate this, we write the complex number in Cartesian form $X+iY$:\n$$\nX = 1 - \\frac{3}{(\\omega R)^2}, \\quad Y = \\frac{3}{\\omega R}\n$$\nThe argument is given by $\\arctan(Y/X)$ since for large $R$, $X>0$ (first quadrant).\n$$\n\\Delta \\phi(R) = \\arctan\\left(\\frac{\\frac{3}{\\omega R}}{1 - \\frac{3}{(\\omega R)^2}}\\right) = \\arctan\\left(\\frac{3\\omega R}{(\\omega R)^2 - 3}\\right)\n$$\nThe problem asks for the *leading-order* systematic phase error. For large $R$, the argument of the arctangent is small. We can use the approximation $\\arctan(x) \\approx x$ for small $x$.\nThe argument of the arctan for large $R$ is:\n$$\n\\frac{3\\omega R}{(\\omega R)^2 - 3} = \\frac{3\\omega R}{(\\omega R)^2\\left(1 - \\frac{3}{(\\omega R)^2}\\right)} \\approx \\frac{3}{\\omega R} \\left(1 + \\frac{3}{(\\omega R)^2} + \\dots\\right) = \\frac{3}{\\omega R} + \\mathcal{O}(R^{-3})\n$$\nThe leading-order behavior is therefore:\n$$\n\\Delta \\phi(R) \\approx \\frac{3}{\\omega R}\n$$\nThis is the required expression.\n\nAs a check, we can derive the extrapolation formula. The result $\\phi(R) \\approx \\phi_\\infty + \\frac{C}{R}$ with $C=3/\\omega$ suggests fitting phase measurements $\\phi(R_1)$ and $\\phi(R_2)$ to a line in $1/R$.\n$$\n\\phi(R_1) = \\phi_\\infty + \\frac{C}{R_1}\n$$\n$$\n\\phi(R_2) = \\phi_\\infty + \\frac{C}{R_2}\n$$\nSolving for $\\phi_\\infty$ gives the two-radius extrapolation formula:\n$$\n\\phi_\\infty = \\frac{R_2 \\phi(R_2) - R_1 \\phi(R_1)}{R_2 - R_1}\n$$\nThis is a standard first-order Richardson extrapolation, confirming the consistency of our derived phase error.",
            "answer": "$$\\boxed{\\frac{3}{\\omega R}}$$"
        },
        {
            "introduction": "Any imperfect outgoing wave boundary condition can be characterized by a frequency-dependent reflection coefficient, $|R(\\omega)|$, which quantifies the amplitude of spurious incoming radiation. This exercise provides a direct, perturbative link between this abstract characterization and its tangible effects on a measured signal. You will learn to predict the resulting amplitude and phase errors in an extracted waveform, a crucial step for validating the accuracy of numerical simulations and understanding data contamination .",
            "id": "3482144",
            "problem": "Consider the asymptotic gravitational radiation extracted from a numerical relativity simulation via the Newman–Penrose scalar $\\Psi_4$. Far from the source, in a region where spacetime curvature is negligible, the radiative degrees of freedom propagate as linear waves that can be modeled, to leading order, by the one-dimensional scalar wave equation\n$$\n\\partial_t^2 \\psi(t,x) - c^2 \\, \\partial_x^2 \\psi(t,x) = 0,\n$$\nwhere $c$ is the speed of light, $t$ is time in seconds, and $x$ is the one-dimensional coordinate in meters. Let an outer computational boundary be placed at a location $x = L$, and a detector be located at $x = x_d$ with $0  x_d  L$. A Sommerfeld-type outgoing boundary condition is imperfect and produces a small reflected wave characterized by a measured frequency-dependent boundary reflection magnitude $\\lvert R(\\omega) \\rvert$, where $\\omega$ is the angular frequency in radians per second. The reflected wave travels from the detector to the boundary and back, yielding a round-trip time delay\n$$\n\\tau = \\frac{2 (L - x_d)}{c},\n$$\nexpressed in seconds. We assume $\\lvert R(\\omega) \\rvert \\ll 1$ so that perturbative analysis is applicable. The detector records a signal composed of the true outgoing component and a small reflected component with the above delay and magnitude.\n\nYour task is to derive, from the scalar wave equation and linear superposition, a perturbative mapping from the measured boundary reflection magnitude $\\lvert R(\\omega) \\rvert$ to the resulting fractional amplitude error and phase error in $\\Psi_4$ at the detector, each as functions of $\\omega$ and $\\tau$. The phase error must be expressed in radians, and the fractional amplitude error must be dimensionless. Then validate the perturbative mapping against a direct time-domain simulation in which, for each angular frequency $\\omega$, the detector time series is modeled as the superposition of a monochromatic true signal and a delayed, reflected component.\n\nFor validation, define the time-domain detector signal for each $\\omega$ by\n$$\ns_{\\text{true}}(t;\\omega) = A \\, \\cos(\\omega t), \\quad s_{\\text{meas}}(t;\\omega) = A \\, \\cos(\\omega t) + A \\, \\lvert R(\\omega) \\rvert \\, \\cos(\\omega (t - \\tau)),\n$$\nwhere $A$ is a constant amplitude (you may set $A = 1$ without loss of generality). For each $\\omega$, extract the complex Fourier coefficient of $s_{\\text{meas}}(t;\\omega)$ at that same angular frequency and compare it to the coefficient for $s_{\\text{true}}(t;\\omega)$ over a finite time window chosen to contain an integer number of cycles for all tested $\\omega$. Use this comparison to obtain the exact fractional amplitude error and exact phase error at the detector. Compare these exact errors to the perturbative predictions you derived, and report the maximum absolute differences across the tested $\\omega$ values.\n\nYou must implement the following test suite. In all cases, use $A = 1$. When constructing the time window for the Fourier extraction, ensure the window length contains an integer number of cycles for every $\\omega$ in the case, and use sufficiently fine sampling to make the numerical integration accurate. All angles must be handled in radians, all times in seconds, and all frequencies in radians per second.\n\nTest Case 1 (happy path, very small reflection):\n- $\\omega$ values: $[100, 200, 300, 400]$ in radians per second.\n- $\\tau = 0.01$ seconds.\n- $\\lvert R(\\omega) \\rvert = 0.01$ (constant in frequency).\n\nTest Case 2 (moderate reflection magnitude):\n- $\\omega$ values: $[100, 400, 700, 1000]$ in radians per second.\n- $\\tau = 0.0125$ seconds.\n- $\\lvert R(\\omega) \\rvert = 0.2$ (constant in frequency).\n\nTest Case 3 (frequency-dependent reflection, larger delay):\n- $\\omega$ values: $[100, 300, 500, 700]$ in radians per second.\n- $\\tau = 0.05$ seconds.\n- $\\lvert R(\\omega) \\rvert = \\dfrac{r_0}{1 + (\\omega/\\omega_c)^2}$ with $r_0 = 0.1$ and $\\omega_c = 200$ radians per second.\n\nTest Case 4 (edge case, zero reflection):\n- $\\omega$ values: $[100, 200, 400, 800]$ in radians per second.\n- $\\tau = 0.02$ seconds.\n- $\\lvert R(\\omega) \\rvert = 0$.\n\nFor each test case, compute:\n1. The perturbative fractional amplitude error and perturbative phase error (in radians) for each $\\omega$ in the case.\n2. The exact fractional amplitude error and exact phase error (in radians) extracted by the time-domain simulation and Fourier analysis for each $\\omega$ in the case.\n3. The maximum absolute difference, over the $\\omega$ values in the case, between the perturbative and exact fractional amplitude errors, and similarly for the phase errors.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist of two floating-point numbers $[\\Delta A_{\\max}, \\Delta \\phi_{\\max}]$ corresponding to the maximum absolute differences for fractional amplitude and phase, respectively. The final format must be:\n[[case1_amp_diff,case1_phase_diff],[case2_amp_diff,case2_phase_diff],[case3_amp_diff,case3_phase_diff],[case4_amp_diff,case4_phase_diff]]",
            "solution": "The problem requires the derivation of a perturbative model for errors in a measured wave signal due to imperfect outgoing wave boundary conditions, and the validation of this model against a direct numerical simulation. The physical context is the measurement of gravitational waves, modeled by a scalar field $\\psi(t,x)$, at a detector.\n\nFirst, we address the derivation of the perturbative mapping. The true signal at the detector, for a single angular frequency $\\omega$, is a purely outgoing monochromatic wave, which we represent in complex form as $\\tilde{s}_{\\text{true}}(t; \\omega) = A e^{i\\omega t}$, where $A$ is a real amplitude. The measured signal, $\\tilde{s}_{\\text{meas}}(t; \\omega)$, is a superposition of this true signal and a reflected component. The reflected component is delayed by a round-trip time $\\tau$ and its amplitude is scaled by the boundary reflection magnitude $|R(\\omega)|$. Thus, the measured signal is given by:\n$$\n\\tilde{s}_{\\text{meas}}(t; \\omega) = A e^{i\\omega t} + A |R(\\omega)| e^{i\\omega (t - \\tau)}\n$$\nWe can factor out the true signal component to identify the complex error factor, $E(\\omega)$, which modifies the true signal's amplitude and phase:\n$$\n\\tilde{s}_{\\text{meas}}(t; \\omega) = A e^{i\\omega t} \\left(1 + |R(\\omega)| e^{-i\\omega\\tau}\\right) = \\tilde{s}_{\\text{true}}(t; \\omega) \\cdot E(\\omega)\n$$\nThe complex error factor is $E(\\omega) = 1 + |R(\\omega)| e^{-i\\omega\\tau}$. Expanding the complex exponential, we have:\n$$\nE(\\omega) = 1 + |R(\\omega)| (\\cos(\\omega\\tau) - i\\sin(\\omega\\tau)) = \\big(1 + |R(\\omega)|\\cos(\\omega\\tau)\\big) - i \\big(|R(\\omega)|\\sin(\\omega\\tau)\\big)\n$$\nThe measured complex amplitude is $A'_{\\text{complex}} = A \\cdot E(\\omega)$. The ratio of the measured amplitude magnitude to the true amplitude is $|E(\\omega)|$, and the phase error is the argument of $E(\\omega)$.\n\nTo find the perturbative errors, we assume $|R(\\omega)| \\ll 1$ and perform a Taylor expansion to first order in $|R(\\omega)|$.\n\nThe fractional amplitude error is $\\frac{|A'|}{A} - 1 = |E(\\omega)| - 1$. The magnitude $|E(\\omega)|$ is:\n$$\n|E(\\omega)| = \\sqrt{\\left(1+|R(\\omega)|\\cos(\\omega\\tau)\\right)^2 + \\left(-|R(\\omega)|\\sin(\\omega\\tau)\\right)^2} = \\sqrt{1 + 2|R(\\omega)|\\cos(\\omega\\tau) + |R(\\omega)|^2}\n$$\nUsing the first-order Taylor expansion $\\sqrt{1+x} \\approx 1 + \\frac{1}{2}x$ for small $x$, where $x = 2|R(\\omega)|\\cos(\\omega\\tau) + |R(\\omega)|^2$, we get:\n$$\n|E(\\omega)| \\approx 1 + \\frac{1}{2}\\left(2|R(\\omega)|\\cos(\\omega\\tau) + |R(\\omega)|^2\\right) \\approx 1 + |R(\\omega)|\\cos(\\omega\\tau) + \\mathcal{O}(|R(\\omega)|^2)\n$$\nThe first-order perturbative fractional amplitude error, $\\delta A_{\\text{frac}}$, is therefore:\n$$\n\\delta A_{\\text{frac}}(\\omega) = |E(\\omega)| - 1 \\approx |R(\\omega)|\\cos(\\omega\\tau)\n$$\nThe phase error, $\\delta\\phi(\\omega)$, is the argument of $E(\\omega)$. Using the first-order Taylor expansion $\\arctan(y) \\approx y$ for small $y$:\n$$\n\\delta\\phi(\\omega) = \\arg(E(\\omega)) = \\arctan\\left(\\frac{-|R(\\omega)|\\sin(\\omega\\tau)}{1+|R(\\omega)|\\cos(\\omega\\tau)}\\right) \\approx \\frac{-|R(\\omega)|\\sin(\\omega\\tau)}{1} + \\mathcal{O}(|R(\\omega)|^2)\n$$\nThus, the first-order perturbative phase error is:\n$$\n\\delta\\phi(\\omega) \\approx -|R(\\omega)|\\sin(\\omega\\tau)\n$$\nThese two expressions form the required perturbative mapping.\n\nNext, we outline the numerical validation procedure. For each angular frequency $\\omega$ in a test case, we must compare the predictions of the perturbative formulas with \"exact\" errors extracted from a time-domain simulation. The problem defines the true and measured real-valued signals as:\n$$\ns_{\\text{true}}(t;\\omega) = A \\cos(\\omega t) \\quad \\text{and} \\quad s_{\\text{meas}}(t;\\omega) = A \\cos(\\omega t) + A |R(\\omega)| \\cos(\\omega (t - \\tau))\n$$\nThe \"exact\" errors are found by extracting the complex amplitude of $s_{\\text{meas}}(t;\\omega)$ at frequency $\\omega$. The complex amplitude, $A'_{\\text{complex}}$, can be obtained by projecting the signal onto the complex basis function $e^{i\\omega t}$ over a time interval $[0, T]$ that contains an integer number of cycles for $\\omega$. The corresponding formula is:\n$$\nA'_{\\text{complex}} = \\frac{2}{T} \\int_0^T s_{\\text{meas}}(t;\\omega) e^{-i\\omega t} dt\n$$\nThis integral is computed numerically. The time duration $T$ is chosen as $T = 2\\pi / \\text{gcd}(\\{\\omega_k\\})$, where $\\{\\omega_k\\}$ are the frequencies in a given test case, ensuring $T$ is an integer multiple of the period for every $\\omega_k$. The time-domain signals are finely sampled to ensure the accuracy of the numerical integration (e.g., using the trapezoidal rule).\n\nThe true signal $s_{\\text{true}}(t;\\omega)$ has a complex amplitude of $A$ (which we set to $1$). The exact fractional amplitude error and phase error are then computed from the numerically obtained $A'_{\\text{complex}}$:\n$$\n\\Delta A_{\\text{frac, exact}} = \\frac{|A'_{\\text{complex}}|}{|A|} - 1, \\quad \\Delta\\phi_{\\text{exact}} = \\arg(A'_{\\text{complex}})\n$$\nFor each test case, we compute these exact errors for each specified $\\omega$ and compare them to the perturbative errors $\\delta A_{\\text{frac}}$ and $\\delta\\phi$. The final reported values are the maximum absolute differences between the exact and perturbative errors across all frequencies in that case:\n$$\n\\Delta A_{\\max} = \\max_{\\omega} |\\Delta A_{\\text{frac, exact}}(\\omega) - \\delta A_{\\text{frac}}(\\omega)|\n$$\n$$\n\\Delta \\phi_{\\max} = \\max_{\\omega} |\\Delta\\phi_{\\text{exact}}(\\omega) - \\delta\\phi(\\omega)|\n$$\nThis procedure validates the accuracy of the perturbative approximation, which is expected to hold well for small $|R(\\omega)|$ and degrade as $|R(\\omega)|$ increases. The following Python code implements this entire validation process.",
            "answer": "```python\nimport numpy as np\nfrom math import gcd\nfrom functools import reduce\n\ndef solve():\n    \"\"\"\n    Derives and validates a perturbative model for errors in a measured wave signal\n    due to imperfect outgoing wave boundary conditions.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (omegas, tau, R_function)\n    # R_function is a callable that returns the reflection magnitude |R(omega)|.\n    test_cases = [\n        # Test Case 1\n        (\n            np.array([100, 200, 300, 400], dtype=int),\n            0.01,\n            lambda omega: 0.01\n        ),\n        # Test Case 2\n        (\n            np.array([100, 400, 700, 1000], dtype=int),\n            0.0125,\n            lambda omega: 0.2\n        ),\n        # Test Case 3\n        (\n            np.array([100, 300, 500, 700], dtype=int),\n            0.05,\n            lambda omega, r0=0.1, wc=200.0: r0 / (1.0 + (omega / wc)**2)\n        ),\n        # Test Case 4\n        (\n            np.array([100, 200, 400, 800], dtype=int),\n            0.02,\n            lambda omega: 0.0\n        )\n    ]\n\n    # The constant amplitude A can be set to 1.0 without loss of generality.\n    A = 1.0\n    all_case_results = []\n\n    for omegas, tau, R_func in test_cases:\n        \n        # Calculate the GCD of all integer frequencies in the case.\n        omega_gcd = reduce(gcd, omegas)\n        \n        # The integration window T must contain an integer number of cycles for all omegas.\n        T = 2.0 * np.pi / omega_gcd\n        \n        # Determine sampling rate for numerical integration.\n        # Ensure high resolution for the highest frequency (shortest period).\n        omega_max = np.max(omegas)\n        samples_per_min_period = 1000  # High number for accuracy\n        num_points = int(omega_max / omega_gcd * samples_per_min_period) + 1\n        t = np.linspace(0, T, num_points)\n\n        max_amp_diff = 0.0\n        max_phase_diff = 0.0\n\n        for omega in omegas:\n            # Reflection magnitude for the current frequency\n            R_val = R_func(omega)\n\n            # 1. Calculate perturbative errors\n            pert_amp_err = R_val * np.cos(omega * tau)\n            pert_phase_err = -R_val * np.sin(omega * tau)\n\n            # 2. Calculate \"exact\" errors from time-domain simulation\n            # Define the measured signal in the time domain.\n            s_meas_t = A * np.cos(omega * t) + A * R_val * np.cos(omega * (t - tau))\n            \n            # Project the signal onto the complex exponential to find the complex amplitude.\n            # The factor 2/T normalizes the result to the physical amplitude.\n            integrand = s_meas_t * np.exp(-1j * omega * t)\n            C_meas_complex = (2.0 / T) * np.trapz(integrand, t)\n            \n            # The true signal's complex amplitude is A.\n            C_true_complex = A\n            \n            # Extract fractional amplitude and phase errors.\n            exact_frac_amp_err = np.abs(C_meas_complex) / np.abs(C_true_complex) - 1.0\n            exact_phase_err = np.angle(C_meas_complex)\n\n            # 3. Compute absolute differences and update maximums for the case.\n            amp_diff = np.abs(exact_frac_amp_err - pert_amp_err)\n            phase_diff = np.abs(exact_phase_err - pert_phase_err)\n            \n            if amp_diff  max_amp_diff:\n                max_amp_diff = amp_diff\n            \n            if phase_diff  max_phase_diff:\n                max_phase_diff = phase_diff\n                \n        all_case_results.append([max_amp_diff, max_phase_diff])\n\n    # Format the final output string as specified in the problem statement.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in all_case_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This practice moves from analysis to design, addressing a common challenge in large-scale simulations: balancing accuracy and computational cost. While perfectly non-reflecting boundary conditions can be formulated, their implementation is computationally expensive. You will explore a practical hybrid strategy that uses these costly, exact conditions only for the dominant, low-order spherical harmonic modes, while relying on a cheaper, approximate condition for the sub-dominant higher-order modes. The task is to perform a cost-benefit analysis to determine the optimal configuration that respects a computational budget while meeting a required accuracy tolerance .",
            "id": "3482103",
            "problem": "Consider the scalar linearized gravitational-wave content of a binary black hole (BBH) simulation in asymptotically flat spacetime, modeled in the far zone by the scalar wave equation in spherical symmetry for each spherical-harmonic multipole. In geometric units (speed of light $c=1$ and total mass scale absorbed into nondimensionalization), each multipole mode indexed by the integer $\\ell \\geq 2$ evolves according to the standard spherical-decomposed wave equation, and the field near the outer spherical boundary at radius $R$ admits a representation as a superposition of outgoing and incoming spherical waves. At the outer boundary $r=R$, you must impose an outgoing-wave boundary condition. Two types of boundary conditions are considered:\n\n- A time-domain exact convolution kernel radiation boundary condition (RBC) that is exact for a given multipole index $\\ell$, which in the frequency domain corresponds to the exact outgoing impedance derived from the spherical Hankel function of the first kind. In the frequency-domain steady-state analysis for a monochromatic component of angular frequency $\\omega$, this exact RBC eliminates reflection for that multipole.\n- A simple Sommerfeld outgoing boundary condition, which in the time domain enforces $\\partial_t u_\\ell + \\partial_r u_\\ell = 0$ at $r=R$. This condition is exact for plane waves but produces a nonzero reflection for spherical multipoles $\\ell \\geq 2$.\n\nYou will implement a hybrid boundary-condition strategy: for low multipoles ($\\ell \\leq \\ell_c$) use the exact convolution kernel RBC, and for high multipoles ($\\ell  \\ell_c$) use the Sommerfeld condition. The design goal is to select the crossover multipole $\\ell_c$ to control spurious reflection while balancing computational cost.\n\nStarting from fundamental definitions:\n\n- The outgoing and incoming frequency-domain spherical solutions are proportional to the spherical Hankel functions $h_\\ell^{(1)}(\\kappa)$ and $h_\\ell^{(2)}(\\kappa)$, respectively, where $\\kappa = k R$ with $k=\\omega$ in geometric units.\n- The Sommerfeld condition at $r=R$ in frequency domain replaces $\\partial_r u_\\ell$ by $i k u_\\ell$.\n- The exact impedance condition for the purely outgoing solution at $r=R$ replaces $\\partial_r u_\\ell$ by $\\left[k \\, h_\\ell^{(1)\\prime}(\\kappa) / h_\\ell^{(1)}(\\kappa)\\right] u_\\ell$.\n\nUsing these facts, derive from first principles the complex reflection amplitude for the Sommerfeld condition at $r=R$ for a given $\\ell$ and $\\kappa$, and define a nonnegative reflection metric $R_\\ell$ that measures the absolute magnitude of this amplitude under the Sommerfeld condition. In contrast, for the exact convolution kernel RBC, assume $R_\\ell = 0$ in the frequency-domain steady-state approximation.\n\nDefine a physically motivated weight $W_\\ell$ for the BBH waveform content across multipoles $\\ell = 2,3,\\dots,L_{\\max}$ by $W_\\ell \\propto \\exp\\left(-\\alpha(\\ell-2)\\right)$ with $\\alpha0$, and normalize $\\{W_\\ell\\}$ so that $\\sum_{\\ell=2}^{L_{\\max}} W_\\ell = 1$. Define the weighted hybrid reflection metric\n$$\nE(\\ell_c) = \\sum_{\\ell=2}^{L_{\\max}} W_\\ell \\, \\tilde{R}_\\ell(\\ell_c),\n$$\nwhere $\\tilde{R}_\\ell(\\ell_c) = 0$ if $\\ell \\leq \\ell_c$ (exact RBC) and $\\tilde{R}_\\ell(\\ell_c) = R_\\ell$ if $\\ell  \\ell_c$ (Sommerfeld).\n\nModel the computational cost as follows. Let $c_00$ be a cost coefficient per convolution kernel degree per multipole, and let $s_00$ be a cost coefficient per multipole for the Sommerfeld condition. Assume the exact convolution kernel RBC for multipole $\\ell$ requires computational work proportional to $\\ell$ per time step, while the Sommerfeld condition has constant cost per multipole. The total cost of the hybrid strategy is\n$$\nC_{\\text{tot}}(\\ell_c) = c_0 \\sum_{\\ell=2}^{\\ell_c} \\ell + s_0 \\sum_{\\ell=\\ell_c+1}^{L_{\\max}} 1 = c_0\\left(\\frac{\\ell_c(\\ell_c+1)}{2} - 1\\right) + s_0\\left(L_{\\max} - \\ell_c\\right).\n$$\n\nGiven a reflection tolerance $\\varepsilon0$ and a computational budget $B0$, the optimization problem is:\n- Find the smallest integer $\\ell_c \\in \\{2,3,\\dots,L_{\\max}\\}$ such that $E(\\ell_c) \\leq \\varepsilon$ and $C_{\\text{tot}}(\\ell_c) \\leq B$.\n- If no such $\\ell_c$ exists, select the integer $\\ell_c \\in \\{2,3,\\dots,L_{\\max}\\}$ that minimizes $E(\\ell_c)$ subject to $C_{\\text{tot}}(\\ell_c) \\leq B$. If there are multiple minimizers, choose the largest such $\\ell_c$.\n\nImplement a program that:\n- Computes $R_\\ell$ for the Sommerfeld boundary condition using the frequency-domain spherical Hankel functions and their derivatives at $\\kappa = \\omega R$.\n- Constructs the normalized weights $W_\\ell$ from the given $\\alpha$ and $L_{\\max}$.\n- Evaluates $E(\\ell_c)$ and $C_{\\text{tot}}(\\ell_c)$ for each $\\ell_c \\in \\{2,3,\\dots,L_{\\max}\\}$.\n- Selects $\\ell_c$ according to the optimization rule above.\n- Returns, for each test case, the pair $[\\ell_c^\\star, E(\\ell_c^\\star)]$ where $\\ell_c^\\star$ is the selected crossover and $E(\\ell_c^\\star)$ is the corresponding weighted reflection metric.\n\nAll quantities are nondimensional and must be treated in geometric units. The final numerical outputs must be real numbers without units. The angle unit is radians. Express answers as decimals. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case’s result encoded as a two-element list $[\\ell_c^\\star, E(\\ell_c^\\star)]$, for example, $[[3,0.012345],[2,0.004321]]$.\n\nUse the following test suite, which spans typical BBH settings, far-boundary behavior, higher-frequency content, and tight budget constraints. Each test case is a tuple $(L_{\\max}, R, \\omega, \\varepsilon, c_0, s_0, B, \\alpha)$:\n\n- Test $1$: $(8, 100, 0.1, 0.05, 10, 1, 300, 0.7)$.\n- Test $2$: $(8, 500, 0.1, 0.01, 10, 1, 150, 0.7)$.\n- Test $3$: $(10, 50, 0.2, 0.02, 8, 1, 120, 0.5)$.\n- Test $4$: $(12, 100, 0.15, 0.015, 12, 2, 80, 0.6)$.\n\nYour program must aggregate the results of these four test cases in the single-line output format described above.",
            "solution": "The problem posed is a well-defined optimization task rooted in the physics of gravitational wave propagation and the numerical methods used to simulate them. It is scientifically sound, internally consistent, and provides all necessary information. I will therefore proceed with a complete solution.\n\nThe core of the problem is to select an optimal crossover multipole, $\\ell_c$, for a hybrid boundary condition strategy in a numerical simulation. This choice must balance the computational cost, $C_{\\text{tot}}(\\ell_c)$, against the physical accuracy, measured by a weighted reflection metric, $E(\\ell_c)$. The solution requires two main components: first, a derivation of the reflection metric $R_\\ell$ from first principles, and second, the implementation of the specified optimization algorithm.\n\n### 1. Derivation of the Reflection Metric $R_\\ell$\n\nThe reflection metric $R_\\ell$ quantifies the error of the simple Sommerfeld boundary condition. It is defined as the absolute magnitude of the complex reflection amplitude, $\\mathcal{R}_\\ell$, for a given spherical-harmonic multipole $\\ell$ and frequency $\\omega$.\n\nIn the frequency domain, a monochromatic wave component with angular frequency $\\omega$ is considered. The radial part of the scalar field, $u_\\ell(r)$, in the far zone near the outer boundary at radius $r=R$ can be expressed as a superposition of a physically outgoing wave and a numerically-generated, unphysical incoming wave:\n$$\nu_\\ell(R) = A_{\\text{out}} h_\\ell^{(1)}(\\kappa) + A_{\\text{in}} h_\\ell^{(2)}(\\kappa)\n$$\nHere, $A_{\\text{out}}$ and $A_{\\text{in}}$ are the complex amplitudes of the outgoing and incoming waves, respectively. The functions $h_\\ell^{(1)}(\\kappa)$ and $h_\\ell^{(2)}(\\kappa)$ are the spherical Hankel functions of the first and second kind, which represent outgoing and incoming spherical waves. The dimensionless parameter $\\kappa$ is defined as $\\kappa = kR = \\omega R$, since we are working in geometric units where the speed of light $c=1$ and thus the wavenumber is $k=\\omega$.\n\nThe radial derivative of the field at $r=R$ is:\n$$\n\\frac{\\partial u_\\ell}{\\partial r}\\bigg|_{r=R} = k \\left( A_{\\text{out}} h_\\ell^{(1)\\prime}(\\kappa) + A_{\\text{in}} h_\\ell^{(2)\\prime}(\\kappa) \\right)\n$$\nwhere the prime denotes differentiation with respect to the argument, and the factor of $k$ arises from the chain rule, $\\partial_r = k \\partial_\\kappa$.\n\nThe Sommerfeld boundary condition in the time domain is $\\partial_t u_\\ell + \\partial_r u_\\ell = 0$. For a monochromatic wave with time dependence $e^{-i\\omega t}$, this transforms to the frequency-domain condition:\n$$\n-i\\omega u_\\ell(R) + \\frac{\\partial u_\\ell}{\\partial r}\\bigg|_{r=R} = 0 \\implies \\frac{\\partial u_\\ell}{\\partial r}\\bigg|_{r=R} = i\\omega u_\\ell(R) = ik u_\\ell(R)\n$$\nSubstituting the expressions for $u_\\ell(R)$ and its derivative into this boundary condition, we get:\n$$\nk \\left( A_{\\text{out}} h_\\ell^{(1)\\prime}(\\kappa) + A_{\\text{in}} h_\\ell^{(2)\\prime}(\\kappa) \\right) = ik \\left( A_{\\text{out}} h_\\ell^{(1)}(\\kappa) + A_{\\text{in}} h_\\ell^{(2)}(\\kappa) \\right)\n$$\nThe factor of $k$ cancels. We can now rearrange the equation to solve for the complex reflection amplitude, $\\mathcal{R}_\\ell = A_{\\text{in}} / A_{\\text{out}}$, which is the ratio of the unphysical incoming wave's amplitude to the outgoing wave's amplitude:\n$$\nA_{\\text{in}} \\left( h_\\ell^{(2)\\prime}(\\kappa) - i h_\\ell^{(2)}(\\kappa) \\right) = -A_{\\text{out}} \\left( h_\\ell^{(1)\\prime}(\\kappa) - i h_\\ell^{(1)}(\\kappa) \\right)\n$$\n$$\n\\mathcal{R}_\\ell = \\frac{A_{\\text{in}}}{A_{\\text{out}}} = - \\frac{h_\\ell^{(1)\\prime}(\\kappa) - i h_\\ell^{(1)}(\\kappa)}{h_\\ell^{(2)\\prime}(\\kappa) - i h_\\ell^{(2)}(\\kappa)}\n$$\nThe problem defines the reflection metric $R_\\ell$ as the absolute magnitude of this complex amplitude:\n$$\nR_\\ell = |\\mathcal{R}_\\ell| = \\left| \\frac{h_\\ell^{(1)\\prime}(\\kappa) - i h_\\ell^{(1)}(\\kappa)}{h_\\ell^{(2)\\prime}(\\kappa) - i h_\\ell^{(2)}(\\kappa)} \\right|\n$$\nThis formula is the basis for our numerical computation of the reflection produced by the Sommerfeld condition for each multipole $\\ell  \\ell_c$. For multipoles $\\ell \\le \\ell_c$ where the exact boundary condition is used, $R_\\ell = 0$ by definition.\n\n### 2. Optimization Algorithm\n\nThe goal is to find the optimal crossover $\\ell_c^\\star$ from the set of integers $\\{2, 3, \\dots, L_{\\max}\\}$ based on a two-tiered optimization rule.\n\nFirst, we must compute all necessary quantities for each possible choice of $\\ell_c$.\nThe multipole weights $W_\\ell$ are calculated as $W_\\ell = N \\exp(-\\alpha(\\ell-2))$ for $\\ell \\in \\{2, \\dots, L_{\\max}\\}$, where $N$ is a normalization constant such that $\\sum_{\\ell=2}^{L_{\\max}} W_\\ell = 1$.\nThe total cost $C_{\\text{tot}}(\\ell_c)$ and the weighted hybrid reflection metric $E(\\ell_c)$ are given by:\n$$\nC_{\\text{tot}}(\\ell_c) = c_0\\left(\\frac{\\ell_c(\\ell_c+1)}{2} - 1\\right) + s_0\\left(L_{\\max} - \\ell_c\\right)\n$$\n$$\nE(\\ell_c) = \\sum_{\\ell=\\ell_c+1}^{L_{\\max}} W_\\ell R_\\ell\n$$\nThe algorithm proceeds as follows:\n1.  For a given test case $(L_{\\max}, R, \\omega, \\varepsilon, c_0, s_0, B, \\alpha)$, we first pre-compute the reflection metrics $R_\\ell$ and weights $W_\\ell$ for all multipoles $\\ell$ from $2$ to $L_{\\max}$. The spherical Hankel functions $h_\\ell^{(1)}, h_\\ell^{(2)}$ and their derivatives are computed using `scipy.special` functions and standard recurrence relations, e.g., $f'_\\ell(z) = f_{\\ell-1}(z) - \\frac{\\ell+1}{z} f_\\ell(z)$, which holds for $j_\\ell, y_\\ell$ and thus for $h_\\ell^{(1,2)}$.\n2.  We iterate through all possible choices of the crossover multipole, $\\ell_c \\in \\{2, 3, \\dots, L_{\\max}\\}$. For each $\\ell_c$, we calculate $C_{\\text{tot}}(\\ell_c)$ and $E(\\ell_c)$.\n3.  **Primary Optimization:** We identify the set of \"valid\" solutions, i.e., all $\\ell_c$ values such that $E(\\ell_c) \\le \\varepsilon$ and $C_{\\text{tot}}(\\ell_c) \\le B$. If this set is non-empty, the optimal choice $\\ell_c^\\star$ is the *smallest* $\\ell_c$ in this set.\n4.  **Secondary Optimization:** If no $\\ell_c$ satisfies both conditions, we retreat to a less-constrained problem. We identify the set of \"budget-compliant\" solutions, i.e., all $\\ell_c$ such that $C_{\\text{tot}}(\\ell_c) \\le B$. From this set, we find the minimum achievable reflection metric, $E_{\\min} = \\min_{\\ell_c} E(\\ell_c)$. The optimal choice $\\ell_c^\\star$ is then the *largest* $\\ell_c$ among those that achieve this minimum error, $E_{\\min}$. This tie-breaking rule favors applying a more accurate boundary condition to more multipoles if the error is the same.\n5.  The final result for the test case is the pair $[\\ell_c^\\star, E(\\ell_c^\\star)]$. This process is repeated for all test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Main function to solve the hybrid boundary condition optimization problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L_max, R, omega, epsilon, c0, s0, B, alpha)\n        (8, 100, 0.1, 0.05, 10, 1, 300, 0.7),\n        (8, 500, 0.1, 0.01, 10, 1, 150, 0.7),\n        (10, 50, 0.2, 0.02, 8, 1, 120, 0.5),\n        (12, 100, 0.15, 0.015, 12, 2, 80, 0.6),\n    ]\n\n    results = []\n    for case in test_cases:\n        L_max, R, omega, epsilon, c0, s0, B, alpha = case\n        \n        # Define the range of multipoles to consider\n        ls = np.arange(2, L_max + 1)\n        kappa = omega * R\n\n        # 1. Pre-compute Reflection Metric R_l and Weights W_l\n        \n        # Compute R_l for l in ls\n        Rs = {}\n        for l_val in ls:\n            # We need h_l and its derivative. The derivative can be found via a\n            # recurrence relation involving h_{l-1}.\n            # h_l'(z) = h_{l-1}(z) - (l+1)/z * h_l(z)\n            \n            # Spherical Hankel function of the first kind, h^(1)_l(kappa)\n            j_l = special.spherical_jn(l_val, kappa)\n            y_l = special.spherical_yn(l_val, kappa)\n            h1_l = j_l + 1j * y_l\n\n            # Spherical Hankel function of the first kind, h^(1)_{l-1}(kappa)\n            j_lm1 = special.spherical_jn(l_val - 1, kappa)\n            y_lm1 = special.spherical_yn(l_val - 1, kappa)\n            h1_lm1 = j_lm1 + 1j * y_lm1\n\n            # Derivative of h^(1)_l(kappa)\n            h1_l_prime = h1_lm1 - ((l_val + 1.0) / kappa) * h1_l\n\n            # Numerator of reflection coefficient formula\n            # Num = h_l^(1)' - i * h_l^(1)\n            num = h1_l_prime - 1j * h1_l\n            \n            # The denominator involves h^(2) and its derivative.\n            # h^(2) is the complex conjugate of h^(1).\n            h2_l = np.conj(h1_l)\n            h2_lm1 = np.conj(h1_lm1)\n            h2_l_prime = h2_lm1 - ((l_val + 1.0) / kappa) * h2_l\n            \n            # Denominator = h_l^(2)' - i * h_l^(2)\n            den = h2_l_prime - 1j * h2_l\n            \n            # Complex reflection amplitude and its magnitude (the metric R_l)\n            reflection_coeff = -num / den\n            Rs[l_val] = np.abs(reflection_coeff)\n\n        # Compute weights W_l for l in ls\n        unnormalized_Ws = np.exp(-alpha * (ls - 2))\n        normalization_factor = np.sum(unnormalized_Ws)\n        Ws = {l: w for l, w in zip(ls, unnormalized_Ws / normalization_factor)}\n        \n        # 2. Iterate through all possible l_c and evaluate cost and error\n        lc_candidates = np.arange(2, L_max + 1)\n        evaluated_options = []\n        for lc in lc_candidates:\n            # Total Cost C_tot(l_c)\n            sum_l = lc * (lc + 1) / 2.0 - 1.0 # Sum of l from 2 to lc\n            cost = c0 * sum_l + s0 * (L_max - lc)\n            \n            # Weighted Hybrid Reflection Metric E(l_c)\n            # Sum is over l > l_c\n            error = 0.0\n            for l_val in range(lc + 1, L_max + 1):\n                error += Ws[l_val] * Rs[l_val]\n\n            evaluated_options.append({'lc': lc, 'error': error, 'cost': cost})\n\n        # 3. Apply the optimization logic to find l_c_star\n\n        # Primary optimization: find smallest lc meeting both criteria\n        pass1_candidates = [opt for opt in evaluated_options if opt['cost'] = B and opt['error'] = epsilon]\n        \n        if pass1_candidates:\n            # Find the minimum lc among the valid candidates\n            best_lc = min(c['lc'] for c in pass1_candidates)\n            best_option = next(opt for opt in pass1_candidates if opt['lc'] == best_lc)\n        else:\n            # Secondary optimization: no candidate met both criteria\n            # Find lc that minimizes error, subject to budget, with tie-breaking\n            pass2_candidates = [opt for opt in evaluated_options if opt['cost'] = B]\n            \n            # This set is guaranteed to be non-empty for the given test cases\n            if not pass2_candidates:\n                # Fallback, though not expected to be reached.\n                # If no lc is within budget, the problem is ill-defined.\n                # For robustness, we could define a failure mode, but will\n                # trust the problem setup.\n                # For this implementation, this branch will not be hit.\n                results.append(None) \n                continue\n\n            # Find the minimum error among budget-compliant options\n            min_error = min(c['error'] for c in pass2_candidates)\n            \n            # Find all candidates that achieve this minimum error\n            min_error_candidates = [c for c in pass2_candidates if np.isclose(c['error'], min_error)]\n            \n            # Tie-breaking: choose the one with the largest lc\n            best_lc = max(c['lc'] for c in min_error_candidates)\n            best_option = next(opt for opt in min_error_candidates if opt['lc'] == best_lc)\n            \n        results.append([best_option['lc'], best_option['error']])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}