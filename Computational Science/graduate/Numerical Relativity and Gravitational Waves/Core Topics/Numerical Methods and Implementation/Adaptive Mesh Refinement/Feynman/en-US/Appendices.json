{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of Adaptive Mesh Refinement (AMR) is the ability to create new, higher-resolution grids and initialize their data from the coarser parent grid. This process, known as prolongation, must be handled carefully to preserve physical realism and numerical stability. This exercise  delves into the crucial technique of piecewise linear reconstruction with slope limiters, a method designed to accurately represent data on the new grid without introducing spurious oscillations, which is essential for simulating sharp features like shockwaves or contact discontinuities.",
            "id": "3503480",
            "problem": "Consider a one-dimensional finite volume representation of density for a compressible flow with a contact discontinuity in a computational astrophysics context. Adaptive Mesh Refinement (AMR) aims to construct fine-level initial data from coarse-level cell averages while preserving conservation and avoiding spurious extrema. The fundamental base is the finite volume definition of a cell average and Total Variation Diminishing (TVD) reconstruction with slope limiters.\n\nLet the coarse-level grid be uniform with cell centers at $x_i$ and width $\\Delta x$. The coarse-level cell-average density is $\\bar{\\rho}_i = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\rho(x)\\,dx$. For prolongation, each coarse cell $i$ is subdivided into $r$ fine subcells indexed by $j \\in \\{0,1,\\dots,r-1\\}$, each of width $\\Delta x / r$. Use a piecewise linear reconstruction within each coarse cell $i$,\n$$\n\\rho_i(x) = \\bar{\\rho}_i + s_i \\frac{x - x_i}{\\Delta x},\n$$\nwhere $s_i$ is a limited slope computed from neighboring coarse averages to enforce the TVD property. Define backward and forward differences\n$$\n\\Delta_- = \\bar{\\rho}_i - \\bar{\\rho}_{i-1}, \\quad \\Delta_+ = \\bar{\\rho}_{i+1} - \\bar{\\rho}_i,\n$$\nand the following slope limiters:\n- Minmod limiter: $\\mathrm{mm}(a,b) = \\begin{cases}\\mathrm{sign}(a)\\min(|a|,|b|), & ab > 0, \\\\ 0, & \\text{otherwise.}\\end{cases}$ with $s_i = \\mathrm{mm}(\\Delta_-,\\Delta_+)$.\n- Monotonized Central (MC) limiter: $s_i = \\mathrm{mm}_3\\left(\\frac{\\Delta_- + \\Delta_+}{2}, 2\\Delta_-, 2\\Delta_+\\right)$ where $\\mathrm{mm}_3(a,b,c)$ returns $\\mathrm{sign}(a)\\min(|a|,|b|,|c|)$ if $ab>0$ and $ac>0$, and $0$ otherwise.\n- Van Leer limiter: $s_i = \\begin{cases}\\frac{2\\Delta_- \\Delta_+}{\\Delta_- + \\Delta_+}, & \\Delta_- \\Delta_+ > 0, \\\\ 0, & \\text{otherwise.}\\end{cases}$.\n\nAt domain boundaries, where a neighbor is unavailable, set $s_i = 0$ to remain conservative. The subcell-average density for subcell $j$ inside coarse cell $i$ is\n$$\n\\bar{\\rho}_{i,j} = \\frac{r}{\\Delta x}\\int_{x_{i-1/2} + \\frac{j}{r}\\Delta x}^{x_{i-1/2} + \\frac{j+1}{r}\\Delta x} \\rho_i(x)\\,dx.\n$$\nFor the piecewise linear $\\rho_i(x)$ above, the subcell average equals the value at the subcell midpoint, yielding\n$$\n\\bar{\\rho}_{i,j} = \\bar{\\rho}_i + s_i\\,c_j,\\quad c_j = \\left(\\frac{j+\\frac{1}{2}}{r} - \\frac{1}{2}\\right).\n$$\nTo avoid spurious extrema at contact discontinuities, impose a bound-preserving clipping for each coarse cell $i$ with local bounds\n$$\n\\rho_{\\min,i} = \\min\\{\\bar{\\rho}_{i-1},\\bar{\\rho}_i,\\bar{\\rho}_{i+1}\\},\\quad \\rho_{\\max,i} = \\max\\{\\bar{\\rho}_{i-1},\\bar{\\rho}_i,\\bar{\\rho}_{i+1}\\},\n$$\nusing only available neighbors at boundaries. Enforce\n$$\n\\bar{\\rho}_{i,j} \\leftarrow \\min\\left(\\rho_{\\max,i}, \\max\\left(\\rho_{\\min,i}, \\bar{\\rho}_{i,j}\\right)\\right).\n$$\n\nImplement a program that:\n1. Computes limited slopes $s_i$ according to a specified limiter.\n2. Computes fine-level subcell averages $\\bar{\\rho}_{i,j}$ for a given refinement ratio $r$ using the formula above.\n3. Applies the bound-preserving clipping per coarse cell.\n4. Outputs the refined subcell averages for each test case as a list of floats.\n\nAll densities are in dimensionless code units; no physical unit conversion is required. Angles are not involved. The program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a bracketed comma-separated list of the refined cell-average densities for the corresponding test case, with no spaces. For example: $[[a_1,a_2,\\dots],[b_1,b_2,\\dots]]$.\n\nUse the following test suite, designed to cover smooth behavior, sharp contact discontinuity, oscillatory patterns, and boundary effects:\n- Test $1$ (smooth monotone increase, Minmod, $r=2$): coarse averages $\\left[\\,1.0,\\,1.1,\\,1.2,\\,1.3\\,\\right]$.\n- Test $2$ (contact discontinuity, MC, $r=2$): coarse averages $\\left[\\,1.0,\\,1.0,\\,5.0,\\,5.0\\,\\right]$.\n- Test $3$ (oscillatory pattern, Van Leer, $r=4$): coarse averages $\\left[\\,3.0,\\,1.0,\\,3.0,\\,1.0\\,\\right]$.\n- Test $4$ (isolated jump with symmetric neighbors, Minmod, $r=2$): coarse averages $\\left[\\,0.5,\\,0.5,\\,2.0,\\,0.5,\\,0.5\\,\\right]$.\n\nFor each test case, the output should be the flattened fine-level list $\\left[\\,\\bar{\\rho}_{0,0},\\dots,\\bar{\\rho}_{0,r-1},\\bar{\\rho}_{1,0},\\dots,\\bar{\\rho}_{1,r-1},\\dots\\,\\right]$ in the specified format. The final output must be a single line of the form $[ \\text{case1\\_list}, \\text{case2\\_list}, \\text{case3\\_list}, \\text{case4\\_list} ]$ with no spaces anywhere.",
            "solution": "The problem statement is assessed as valid. It presents a well-defined computational task grounded in established principles of numerical methods for fluid dynamics, specifically concerning Adaptive Mesh Refinement (AMR). The provided formulas for piecewise linear reconstruction, slope limiters, and subcell averaging are standard and correct. The problem is self-contained, with all necessary data and boundary conditions specified, enabling a unique solution for each test case.\n\nThe procedure to prolong coarse-level cell-average densities, $\\bar{\\rho}_i$, to a refined grid with a refinement ratio $r$ involves three primary steps: slope calculation, subcell average computation, and bound-preserving clipping.\n\n### 1. Limited Slope Calculation\nFor each coarse cell $i$, a slope $s_i$ is computed to define a piecewise linear reconstruction, $\\rho_i(x) = \\bar{\\rho}_i + s_i \\frac{x - x_i}{\\Delta x}$, where $x_i$ is the center of cell $i$ and $\\Delta x$ is its width. To prevent the introduction of spurious oscillations near sharp features (a property known as Total Variation Diminishing or TVD), the slope $s_i$ is limited based on the local data.\n\nThe calculation depends on the cell's position:\n-   **Boundary Cells**: For the first ($i=0$) and last ($i=N-1$) cells in the domain, a full set of neighbors is unavailable. To maintain a conservative and simple treatment, the slope is set to zero, i.e., $s_0 = 0$ and $s_{N-1} = 0$. This corresponds to a piecewise constant reconstruction at the boundaries.\n-   **Interior Cells**: For any interior cell $i$, the slope is determined by its immediate neighbors. We first compute the backward and forward differences:\n    $$\n    \\Delta_- = \\bar{\\rho}_i - \\bar{\\rho}_{i-1} \\quad ; \\quad \\Delta_+ = \\bar{\\rho}_{i+1} - \\bar{\\rho}_i\n    $$\n    These differences are then passed to a slope limiter function. The problem specifies three such limiters:\n\n    1.  **Minmod Limiter**: This is the most dissipative limiter, which strongly suppresses oscillations. The slope is given by:\n        $$\n        s_i = \\mathrm{mm}(\\Delta_-, \\Delta_+) = \\begin{cases}\\mathrm{sign}(\\Delta_-)\\min(|\\Delta_-|,|\\Delta_+|), & \\Delta_- \\Delta_+ > 0 \\\\ 0, & \\text{otherwise}\\end{cases}\n        $$\n        The slope is non-zero only if the data is locally monotonic (i.e., $\\Delta_-$ and $\\Delta_+$ have the same sign). At local extrema, the slope is zero.\n\n    2.  **Monotonized Central (MC) Limiter**: This limiter is designed to be more accurate in smooth regions than Minmod. It is defined using a three-argument minmod function:\n        $$\n        s_i = \\mathrm{mm}_3\\left(\\frac{\\Delta_- + \\Delta_+}{2}, 2\\Delta_-, 2\\Delta_+\\right)\n        $$\n        where $\\mathrm{mm}_3(a,b,c)$ returns $\\mathrm{sign}(a)\\min(|a|,|b|,|c|)$ if $a, b, c$ all have the same sign, and $0$ otherwise. This limiter considers the central difference slope, $(\\Delta_- + \\Delta_+)/2$, and limits it by twice the one-sided differences.\n\n    3.  **Van Leer Limiter**: This limiter offers a smooth transition between the one-sided differences and is known for providing good resolution of contact discontinuities. It is the harmonic mean of the two differences:\n        $$\n        s_i = \\begin{cases}\\frac{2\\Delta_- \\Delta_+}{\\Delta_- + \\Delta_+}, & \\Delta_- \\Delta_+ > 0 \\\\ 0, & \\text{otherwise}\\end{cases}\n        $$\n\n### 2. Subcell Average Prolongation\nOnce the slope $s_i$ for each coarse cell $i$ is known, we can determine the average density, $\\bar{\\rho}_{i,j}$, for each of the $r$ subcells within it. A subcell is indexed by $j \\in \\{0, 1, \\dots, r-1\\}$. The average value of a linear function over an interval is equal to the function's value at the interval's midpoint. This simplifies the integral definition to an algebraic one. The midpoint of subcell $j$ in coarse cell $i$ is offset from the coarse cell center $x_i$ by a distance factor. This leads to the formula:\n$$\n\\bar{\\rho}_{i,j} = \\bar{\\rho}_i + s_i\\,c_j\n$$\nwhere the coefficient $c_j$ depends only on the subcell index $j$ and the refinement ratio $r$:\n$$\nc_j = \\left(\\frac{j+\\frac{1}{2}}{r} - \\frac{1}{2}\\right)\n$$\nThese coefficients represent the normalized distance of each subcell's center from the parent cell's center. For example, for $r=2$, we have $c_0 = -0.25$ and $c_1 = 0.25$.\n\n### 3. Bound-Preserving Clipping\nThe TVD slope limiters are designed to prevent the reconstructed point values at cell interfaces from creating new extrema. However, to strictly enforce that the new *cell averages* also do not create new local extrema, an additional clipping step is applied. For each coarse cell $i$, we define local bounds based on the cell average itself and its available neighbors:\n$$\n\\rho_{\\min,i} = \\min\\{\\bar{\\rho}_{k} \\mid k \\in \\{i-1, i, i+1\\} \\cap [0, N-1]\\}\n$$\n$$\n\\rho_{\\max,i} = \\max\\{\\bar{\\rho}_{k} \\mid k \\in \\{i-1, i, i+1\\} \\cap [0, N-1]\\}\n$$\nFor a boundary cell $i=0$, the neighborhood is $\\{0, 1\\}$. For an interior cell, it is $\\{i-1, i, i+1\\}$.\n\nEach computed subcell average $\\bar{\\rho}_{i,j}$ is then forced to lie within these bounds:\n$$\n\\bar{\\rho}_{i,j} \\leftarrow \\min\\left(\\rho_{\\max,i}, \\max\\left(\\rho_{\\min,i}, \\bar{\\rho}_{i,j}\\right)\\right)\n$$\nThis ensures that the refined data field remains locally bounded by the original coarse data, which is crucial for stability and physical realism, especially at contact discontinuities.\n\n### Example Walkthrough: Test Case 1\n-   **Input**: Coarse averages $\\bar{\\rho} = [1.0, 1.1, 1.2, 1.3]$, Limiter: Minmod, $r=2$.\n-   **Slopes**:\n    -   $s_0 = 0$ (boundary).\n    -   $i=1$: $\\Delta_- = 1.1-1.0=0.1$, $\\Delta_+ = 1.2-1.1=0.1$. $\\mathrm{mm}(0.1, 0.1) = 0.1$. So, $s_1=0.1$.\n    -   $i=2$: $\\Delta_- = 1.2-1.1=0.1$, $\\Delta_+ = 1.3-1.2=0.1$. $\\mathrm{mm}(0.1, 0.1) = 0.1$. So, $s_2=0.1$.\n    -   $s_3 = 0$ (boundary).\n    -   The slope vector is $s = [0, 0.1, 0.1, 0]$.\n-   **Subcell Averages ($r=2 \\implies c_0=-0.25, c_1=0.25$)**:\n    -   $i=0$: $\\bar{\\rho}_{0,0} = 1.0 + 0 \\cdot (-0.25) = 1.0$; $\\bar{\\rho}_{0,1} = 1.0 + 0 \\cdot (0.25) = 1.0$.\n    -   $i=1$: $\\bar{\\rho}_{1,0} = 1.1 + 0.1 \\cdot (-0.25) = 1.075$; $\\bar{\\rho}_{1,1} = 1.1 + 0.1 \\cdot (0.25) = 1.125$.\n    -   $i=2$: $\\bar{\\rho}_{2,0} = 1.2 + 0.1 \\cdot (-0.25) = 1.175$; $\\bar{\\rho}_{2,1} = 1.2 + 0.1 \\cdot (0.25) = 1.225$.\n    -   $i=3$: $\\bar{\\rho}_{3,0} = 1.3 + 0 \\cdot (-0.25) = 1.3$; $\\bar{\\rho}_{3,1} = 1.3 + 0 \\cdot (0.25) = 1.3$.\n-   **Clipping**:\n    -   $i=0$: Bounds are $[\\min(1.0, 1.1), \\max(1.0, 1.1)] = [1.0, 1.1]$. Values $[1.0, 1.0]$ are within bounds.\n    -   $i=1$: Bounds are $[\\min(1.0, 1.1, 1.2), \\max(1.0, 1.1, 1.2)] = [1.0, 1.2]$. Values $[1.075, 1.125]$ are within bounds.\n    -   $i=2$: Bounds are $[\\min(1.1, 1.2, 1.3), \\max(1.1, 1.2, 1.3)] = [1.1, 1.3]$. Values $[1.175, 1.225]$ are within bounds.\n    -   $i=3$: Bounds are $[\\min(1.2, 1.3), \\max(1.2, 1.3)] = [1.2, 1.3]$. Values $[1.3, 1.3]$ are within bounds.\n    -   In this case, the clipping step does not change any values, as the Minmod limiter already ensures the reconstruction is non-oscillatory.\n-   **Final Result**: The flattened list of fine-cell averages is $[1.0, 1.0, 1.075, 1.125, 1.175, 1.225, 1.3, 1.3]$.",
            "answer": "```python\nimport numpy as np\n\ndef minmod_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Minmod limited slope.\"\"\"\n    if delta_minus * delta_plus > 0:\n        return np.sign(delta_minus) * min(abs(delta_minus), abs(delta_plus))\n    return 0.0\n\ndef mm3(a, b, c):\n    \"\"\"Generalized minmod function for three arguments.\"\"\"\n    sa, sb, sc = np.sign(a), np.sign(b), np.sign(c)\n    if sa == sb and sa == sc:\n        return sa * min(abs(a), abs(b), abs(c))\n    return 0.0\n\ndef mc_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Monotonized Central (MC) limited slope.\"\"\"\n    return mm3((delta_minus + delta_plus) / 2.0, 2.0 * delta_minus, 2.0 * delta_plus)\n\ndef van_leer_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Van Leer limited slope.\"\"\"\n    if delta_minus * delta_plus > 0:\n        # The check for d- * d+ > 0 prevents division by zero,\n        # as d- + d+ could only be zero if both were zero.\n        return (2.0 * delta_minus * delta_plus) / (delta_minus + delta_plus)\n    return 0.0\n\ndef process_case(coarse_rho, limiter_name, r):\n    \"\"\"\n    Performs AMR prolongation for a given set of coarse cell averages.\n\n    Args:\n        coarse_rho (list[float]): The coarse-level cell averages.\n        limiter_name (str): The name of the slope limiter to use ('Minmod', 'MC', 'Van Leer').\n        r (int): The refinement ratio.\n\n    Returns:\n        list[float]: The flattened list of fine-level cell averages after clipping.\n    \"\"\"\n    limiter_funcs = {\n        'Minmod': minmod_limiter,\n        'MC': mc_limiter,\n        'Van Leer': van_leer_limiter\n    }\n    \n    n_coarse = len(coarse_rho)\n    slopes = np.zeros(n_coarse)\n    limiter_func = limiter_funcs[limiter_name]\n\n    # 1. Compute limited slopes for interior cells\n    for i in range(1, n_coarse - 1):\n        delta_minus = coarse_rho[i] - coarse_rho[i-1]\n        delta_plus = coarse_rho[i+1] - coarse_rho[i]\n        slopes[i] = limiter_func(delta_minus, delta_plus)\n    # Slopes at boundaries (i=0, i=n_coarse-1) remain 0\n\n    # 2. Compute fine-level subcell averages with bound-preserving clipping\n    c_j_coeffs = (np.arange(r, dtype=float) + 0.5) / r - 0.5\n    fine_rho = []\n    \n    for i in range(n_coarse):\n        # Determine local bounds from available neighbors\n        neighbors = [coarse_rho[i]]\n        if i > 0:\n            neighbors.append(coarse_rho[i-1])\n        if i  n_coarse - 1:\n            neighbors.append(coarse_rho[i+1])\n        \n        rho_min_i = min(neighbors)\n        rho_max_i = max(neighbors)\n\n        # Compute, clip, and store subcell values\n        for j in range(r):\n            # Calculate value from piecewise linear reconstruction\n            val = coarse_rho[i] + slopes[i] * c_j_coeffs[j]\n            # Apply bound-preserving clipping\n            clipped_val = min(rho_max_i, max(rho_min_i, val))\n            fine_rho.append(clipped_val)\n            \n    return fine_rho\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        {'coarse_rho': [1.0, 1.1, 1.2, 1.3], 'limiter': 'Minmod', 'r': 2},\n        {'coarse_rho': [1.0, 1.0, 5.0, 5.0], 'limiter': 'MC', 'r': 2},\n        {'coarse_rho': [3.0, 1.0, 3.0, 1.0], 'limiter': 'Van Leer', 'r': 4},\n        {'coarse_rho': [0.5, 0.5, 2.0, 0.5, 0.5], 'limiter': 'Minmod', 'r': 2},\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        result = process_case(case['coarse_rho'], case['limiter'], case['r'])\n        # Format the list of floats into a string \"[f1,f2,...]\"\n        result_str = '[' + ','.join(map(str, result)) + ']'\n        all_results_str.append(result_str)\n\n    # Combine all case strings into the final output format \"[[...],[...],...]\"\n    # with no spaces.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once a multi-level grid structure is in place, the next challenge is to evolve the simulation in time efficiently and stably. This practice  focuses on the temporal aspect of AMR, requiring the calculation of appropriate time steps for each refinement level based on the fundamental Courant–Friedrichs–Lewy (CFL) condition. You will implement \"subcycling,\" a key optimization where finer grids are advanced with smaller time steps, and determine the synchronization schedule needed to keep all levels in lockstep.",
            "id": "3503472",
            "problem": "Consider a one-dimensional explicit finite-volume solver for a hyperbolic conservation law in a computational astrophysics simulation employing Adaptive Mesh Refinement (AMR). The mesh hierarchy consists of three levels: a coarse level $\\ell = 0$, a finer level $\\ell = 1$ refined by factor $r_{1} = 3$ relative to level $\\ell = 0$, and a finest level $\\ell = 2$ refined by factor $r_{2} = 2$ relative to level $\\ell = 1$. The coarse-level spatial step is $\\Delta x_{0} = 9.6 \\times 10^{9}$ meters, so that $\\Delta x_{1} = \\Delta x_{0}/r_{1}$ and $\\Delta x_{2} = \\Delta x_{1}/r_{2}$. The maximum characteristic speeds (the largest absolute values of eigenvalues of the flux Jacobian) resolved on each level are $a_{0} = 2.0 \\times 10^{7}$ meters per second on level $\\ell = 0$, $a_{1} = 3.3 \\times 10^{7}$ meters per second on level $\\ell = 1$, and $a_{2} = 4.0 \\times 10^{7}$ meters per second on level $\\ell = 2$. The Courant–Friedrichs–Lewy (CFL) number is $C_{\\mathrm{CFL}} = 0.45$.\n\nUsing the Courant–Friedrichs–Lewy stability requirement appropriate to explicit finite-volume discretizations of hyperbolic systems, first compute the allowable time step on each AMR level, denoted $\\Delta t_{\\ell}^{\\max}$ for $\\ell \\in \\{0,1,2\\}$. Then, suppose the coarse level advances by one time step of length $\\Delta t_{0} = \\Delta t_{0}^{\\max}$. Implement level-synchronous subcycling on finer levels by choosing integers $n_{1}$ and $n_{2}$ such that level $\\ell = 1$ takes $n_{1}$ substeps and level $\\ell = 2$ takes $n_{2}$ substeps over the single coarse-level advance, with $\\Delta t_{1} = \\Delta t_{0}/n_{1} \\le \\Delta t_{1}^{\\max}$ and $\\Delta t_{2} = \\Delta t_{0}/n_{2} \\le \\Delta t_{2}^{\\max}$, and with $n_{2}$ being a positive integer multiple of $n_{1}$ to ensure nested synchronization. Among all admissible choices, select the minimal $n_{1}$ and the minimal multiple $n_{2}$ that satisfy these constraints.\n\nDefine the synchronization times within the interval $[0,\\Delta t_{0}]$ as the set of times at which all finer levels have simultaneously completed an integer number of their substeps and thus can perform flux correction with their parent level; under the above constraint that $n_{2}$ is a multiple of $n_{1}$, these are the level $\\ell = 1$ substep boundaries. List these times, including the start and end of the coarse-level step. Express all time quantities in seconds.\n\nProvide, in order, the triple $\\left(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}\\right)$, the actual subcycled time steps $\\left(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}\\right)$, and the ordered synchronization times $\\left(t_{0}, t_{1}, t_{2}, t_{3}, t_{4}, t_{5}\\right)$ over one coarse-level step, as a single row in your final answer. No rounding is required.",
            "solution": "The user has provided a problem in computational astrophysics concerning time-stepping in an Adaptive Mesh Refinement (AMR) simulation. The problem requires the calculation of time steps based on the Courant-Friedrichs-Lewy (CFL) stability condition and the determination of subcycling parameters and synchronization times.\n\nThe problem is first validated against the required criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- AMR levels: $\\ell \\in \\{0, 1, 2\\}$.\n- Refinement factor from level $\\ell=0$ to $\\ell=1$: $r_{1} = 3$.\n- Refinement factor from level $\\ell=1$ to $\\ell=2$: $r_{2} = 2$.\n- Coarse-level spatial step: $\\Delta x_{0} = 9.6 \\times 10^{9}$ meters.\n- Spatial step relations: $\\Delta x_{1} = \\Delta x_{0}/r_{1}$ and $\\Delta x_{2} = \\Delta x_{1}/r_{2}$.\n- Maximum characteristic speeds on each level: $a_{0} = 2.0 \\times 10^{7}$ m/s, $a_{1} = 3.3 \\times 10^{7}$ m/s, $a_{2} = 4.0 \\times 10^{7}$ m/s.\n- Courant-Friedrichs-Lewy (CFL) number: $C_{\\mathrm{CFL}} = 0.45$.\n- Coarse-level time step for the advance: $\\Delta t_{0} = \\Delta t_{0}^{\\max}$.\n- Subcycling constraints:\n  - Level $\\ell=1$ takes $n_{1}$ substeps, with $\\Delta t_{1} = \\Delta t_{0}/n_{1} \\le \\Delta t_{1}^{\\max}$.\n  - Level $\\ell=2$ takes $n_{2}$ substeps, with $\\Delta t_{2} = \\Delta t_{0}/n_{2} \\le \\Delta t_{2}^{\\max}$.\n- Synchronization constraint: $n_{2}$ is a positive integer multiple of $n_{1}$.\n- Minimality constraint: $n_{1}$ is the minimal integer satisfying its constraint, and $n_{2}$ is the minimal multiple of $n_{1}$ satisfying its constraint.\n- Synchronization times: The boundaries of the level $\\ell=1$ substeps within the coarse-level step interval $[0, \\Delta t_{0}]$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Groundedness**: The problem is based on the CFL condition, a fundamental principle for the stability of explicit numerical methods for hyperbolic equations. AMR with subcycling is a standard, scientifically valid technique in computational fluid dynamics and astrophysics. The problem is firmly grounded in established numerical analysis.\n- **Well-Posedness**: All necessary parameters ($\\Delta x_0$, $r_1$, $r_2$, $a_\\ell$, $C_{\\mathrm{CFL}}$) are provided. The constraints on the subcycling integers ($n_1, n_2$) are clearly defined and lead to a unique, minimal solution. The problem is self-contained and mathematically well-posed.\n- **Objectivity**: The problem is formulated using precise, unambiguous mathematical terms and physical quantities. It is free from subjective language.\n\n**Step 3: Verdict and Action**\nThe problem is valid as it is scientifically sound, well-posed, and objective. A complete solution will be provided.\n\n### Solution\n\nThe solution proceeds in several steps:\n1.  Compute the spatial step size $\\Delta x_{\\ell}$ for each level $\\ell$.\n2.  Compute the maximum allowable time step $\\Delta t_{\\ell}^{\\max}$ for each level using the CFL condition.\n3.  Determine the integer subcycling numbers $n_{1}$ and $n_{2}$ that satisfy the given constraints.\n4.  Calculate the actual time steps $\\Delta t_{\\ell}$ used for the subcycled advance.\n5.  List the synchronization times over one coarse-level step.\n\n**1. Spatial Step Sizes**\nThe spatial step sizes for the finer levels are determined by the given refinement factors.\n- Level $\\ell=0$: $\\Delta x_{0} = 9.6 \\times 10^{9} \\, \\text{m}$.\n- Level $\\ell=1$: $\\Delta x_{1} = \\frac{\\Delta x_{0}}{r_{1}} = \\frac{9.6 \\times 10^{9}}{3} = 3.2 \\times 10^{9} \\, \\text{m}$.\n- Level $\\ell=2$: $\\Delta x_{2} = \\frac{\\Delta x_{1}}{r_{2}} = \\frac{3.2 \\times 10^{9}}{2} = 1.6 \\times 10^{9} \\, \\text{m}$.\n\n**2. Maximum Allowable Time Steps**\nThe CFL condition for a one-dimensional explicit finite-volume scheme states that for stability, the time step $\\Delta t$ must satisfy $\\Delta t \\le C_{\\mathrm{CFL}} \\frac{\\Delta x}{a}$, where $a$ is the maximum characteristic speed. The maximum allowable time step on level $\\ell$ is therefore $\\Delta t_{\\ell}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{\\ell}}{a_{\\ell}}$.\n\n- Level $\\ell=0$:\n$$ \\Delta t_{0}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{0}}{a_{0}} = 0.45 \\times \\frac{9.6 \\times 10^{9} \\, \\text{m}}{2.0 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times (4.8 \\times 10^{2} \\, \\text{s}) = 216 \\, \\text{s} $$\n- Level $\\ell=1$:\n$$ \\Delta t_{1}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{1}}{a_{1}} = 0.45 \\times \\frac{3.2 \\times 10^{9} \\, \\text{m}}{3.3 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times \\frac{3.2}{3.3} \\times 10^{2} \\, \\text{s} = \\frac{1.44}{3.3} \\times 10^{2} \\, \\text{s} = \\frac{144}{3.3} \\, \\text{s} = \\frac{1440}{33} \\, \\text{s} = \\frac{480}{11} \\, \\text{s} $$\n- Level $\\ell=2$:\n$$ \\Delta t_{2}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{2}}{a_{2}} = 0.45 \\times \\frac{1.6 \\times 10^{9} \\, \\text{m}}{4.0 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times (0.4 \\times 10^{2} \\, \\text{s}) = 18 \\, \\text{s} $$\nThe first requested set of values is $(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}) = (216, \\frac{480}{11}, 18)$.\n\n**3. Subcycling Integers**\nThe coarse level advances by one step of size $\\Delta t_{0} = \\Delta t_{0}^{\\max} = 216 \\, \\text{s}$.\nFor level $\\ell=1$, the number of substeps $n_{1}$ must satisfy $\\Delta t_{1} = \\frac{\\Delta t_{0}}{n_{1}} \\le \\Delta t_{1}^{\\max}$. This implies:\n$$ n_{1} \\ge \\frac{\\Delta t_{0}}{\\Delta t_{1}^{\\max}} = \\frac{216}{\\frac{480}{11}} = \\frac{216 \\times 11}{480} = \\frac{9 \\times 24 \\times 11}{20 \\times 24} = \\frac{99}{20} = 4.95 $$\nSince $n_{1}$ must be an integer, the minimal value for $n_{1}$ is $\\lceil 4.95 \\rceil = 5$.\n\nFor level $\\ell=2$, the number of substeps $n_{2}$ must satisfy $\\Delta t_{2} = \\frac{\\Delta t_{0}}{n_{2}} \\le \\Delta t_{2}^{\\max}$. This implies:\n$$ n_{2} \\ge \\frac{\\Delta t_{0}}{\\Delta t_{2}^{\\max}} = \\frac{216}{18} = 12 $$\nAdditionally, $n_{2}$ must be a positive integer multiple of $n_{1}=5$. We must find the smallest multiple of $5$ that is greater than or equal to $12$. The relevant multiples of $5$ are $5, 10, 15, \\dots$. The smallest such multiple is $15$.\nThus, the selected subcycling integers are $n_{1} = 5$ and $n_{2} = 15$.\n\n**4. Actual Subcycled Time Steps**\nThe actual time steps for each level are calculated based on the subcycling integers.\n- Level $\\ell=0$: $\\Delta t_{0} = 216 \\, \\text{s}$.\n- Level $\\ell=1$: $\\Delta t_{1} = \\frac{\\Delta t_{0}}{n_{1}} = \\frac{216}{5} = 43.2 \\, \\text{s}$.\n- Level $\\ell=2$: $\\Delta t_{2} = \\frac{\\Delta t_{0}}{n_{2}} = \\frac{216}{15} = \\frac{72}{5} = 14.4 \\, \\text{s}$.\nThe second requested set of values is $(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}) = (216, 43.2, 14.4)$.\n\n**5. Synchronization Times**\nThe synchronization times are the boundaries of the level $\\ell=1$ substeps. Since level $\\ell=1$ takes $n_{1}=5$ substeps of duration $\\Delta t_{1} = 43.2 \\, \\text{s}$, the synchronization times $t_j$ are given by $t_j = j \\cdot \\Delta t_{1}$ for $j=0, 1, \\dots, 5$.\n- $t_{0} = 0 \\times 43.2 = 0 \\, \\text{s}$\n- $t_{1} = 1 \\times 43.2 = 43.2 \\, \\text{s}$\n- $t_{2} = 2 \\times 43.2 = 86.4 \\, \\text{s}$\n- $t_{3} = 3 \\times 43.2 = 129.6 \\, \\text{s}$\n- $t_{4} = 4 \\times 43.2 = 172.8 \\, \\text{s}$\n- $t_{5} = 5 \\times 43.2 = 216.0 \\, \\text{s}$\nThe third requested set of values is $(0, 43.2, 86.4, 129.6, 172.8, 216.0)$.\n\nThese three sets of results are combined into a single row matrix for the final answer.\n- $(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}) = (216, \\frac{480}{11}, 18)$\n- $(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}) = (216, 43.2, 14.4)$\n- $(t_0, \\dots, t_5) = (0, 43.2, 86.4, 129.6, 172.8, 216)$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 216  \\frac{480}{11}  18  216  43.2  14.4  0  43.2  86.4  129.6  172.8  216 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Evolving grids at different temporal rates can lead to a subtle but critical problem: the flux of conserved quantities, such as mass or energy, may not be consistent across coarse-fine interfaces, violating fundamental physical laws. The solution is a \"refluxing\" correction, which enforces strict conservation by reconciling the flux calculations from both levels. This conceptual exercise  explores the underlying principles of refluxing by presenting a special case that reveals the conditions under which a correction is, or is not, required.",
            "id": "3503513",
            "problem": "Consider two-dimensional advection of a passive scalar field $q(x,y,t)$ governed by the conservation law\n$$\n\\frac{\\partial q}{\\partial t} + \\nabla \\cdot (q \\,\\boldsymbol{v}) = 0,\n$$\nwith a constant velocity $\\boldsymbol{v} = (u, 0)$ and $u > 0$. An Adaptive Mesh Refinement (AMR) hierarchy consists of a uniform coarse level with square cells of size $\\Delta x_c = \\Delta y_c$, and a single fine level with refinement ratio $r = 2$ covering the region $y  0$. The coarse–fine interface coincides exactly with the horizontal line $y = 0$, so that its tangent direction is parallel to the $x$-axis and its outward unit normal is $\\pm \\hat{\\boldsymbol{y}}$. Assume that the fine level advances with sub-cycling using time step $\\Delta t_f = \\Delta t_c / r$, where $\\Delta t_c$ is the coarse time step, and both levels use conservative finite-volume Godunov updates with upwind numerical fluxes consistent with the conservation law. Let the initial data $q(x,y,0)$ be arbitrary but sufficiently regular for the schemes to remain stable.\n\nFocus on two adjacent coarse cells $C_1$ and $C_2$ that lie immediately above the interface (their centers are located at $y = +\\Delta y_c/2$), and whose bottom faces lie on the interface for $x \\in [0, \\Delta x_c]$ and $x \\in [\\Delta x_c, 2\\Delta x_c]$, respectively. After one coarse time step $\\Delta t_c$, standard refluxing is applied to enforce conservation across the coarse–fine interface.\n\nUsing only the conservation law and finite-volume principles, compute the reflux correction contributions $(\\delta Q_{C_1}, \\delta Q_{C_2})$ to the cell-averaged scalar $q$ in these two coarse cells due solely to the fluxes across the coarse–fine interface after one coarse time step. Express your final values in the same units as $q$. Provide exact values (no rounding is necessary). Output your final ordered pair as a row vector in the order $(\\delta Q_{C_1}, \\delta Q_{C_2})$.",
            "solution": "The problem asks for the reflux correction contributions, $(\\delta Q_{C_1}, \\delta Q_{C_2})$, to the cell-averaged scalar in two specified coarse cells, $C_1$ and $C_2$, after one coarse time step. The reflux correction is a procedure used in Adaptive Mesh Refinement (AMR) to enforce strict conservation of quantities across the interface between grids of different resolutions.\n\nThe governing equation is the two-dimensional conservation law for a passive scalar $q$:\n$$\n\\frac{\\partial q}{\\partial t} + \\nabla \\cdot (q \\,\\boldsymbol{v}) = 0\n$$\nIn conservative form, this is $\\frac{\\partial q}{\\partial t} + \\nabla \\cdot \\boldsymbol{F} = 0$, where the flux vector is $\\boldsymbol{F} = q\\boldsymbol{v}$.\nGiven the constant velocity field $\\boldsymbol{v} = (u, 0)$ with $u > 0$, the flux vector is $\\boldsymbol{F} = (qu, 0)$.\n\nA finite-volume scheme discretizes this equation by integrating over a cell $C$ of area $A_C$. Let $Q_C(t) = \\frac{1}{A_C} \\int_C q(x,y,t) \\,dA$ be the cell-averaged value of the scalar. The total amount of the scalar in the cell is $M_C(t) = Q_C(t) A_C$. The integral form of the conservation law is:\n$$\n\\frac{dM_C}{dt} + \\oint_{\\partial C} \\boldsymbol{F} \\cdot \\hat{\\boldsymbol{n}} \\,dL = 0\n$$\nwhere $\\partial C$ is the boundary of the cell and $\\hat{\\boldsymbol{n}}$ is the outward unit normal vector. The time-discrete update for the total scalar $M_C$ from time $t^n$ to $t^{n+1} = t^n + \\Delta t$ is:\n$$\nM_C^{n+1} = M_C^n - \\Delta t \\sum_{i \\in \\text{faces}} F_i^* L_i\n$$\nwhere $F_i^*$ is the numerical flux per unit length across face $i$, and $L_i$ is the length of face $i$.\n\nThe refluxing procedure is designed to correct for the mismatch between the flux calculated by the coarse grid across a coarse-fine (C-F) interface and the sum of fluxes calculated by the fine grid across that same interface. The coarse grid performs one step of size $\\Delta t_c$, while the fine grid performs $r$ sub-cycled steps of size $\\Delta t_f = \\Delta t_c / r$.\n\nThe total reflux correction added to a coarse cell $C$ after one coarse time step is the difference between the total scalar mass that the coarse grid calculation says has crossed the C-F interface and the total scalar mass that the fine grid calculations say has crossed the same interface.\nLet $\\mathcal{F}_{\\text{coarse}}$ be the total mass flux across the C-F boundary of cell $C$ as computed on the coarse grid over $\\Delta t_c$. Let $\\mathcal{F}_{\\text{fine}}$ be the sum of mass fluxes across the corresponding fine cell boundaries, summed over the $r$ fine time steps. The reflux correction to the total mass in cell $C$ is $\\delta M_C = \\mathcal{F}_{\\text{coarse}} - \\mathcal{F}_{\\text{fine}}$.\n\nThe key insight to solving this problem lies in the nature of the flux across the C-F interface. The interface is located at the line $y=0$. For the coarse cells $C_1$ and $C_2$, which are located above the interface (in the region $y>0$), their bottom faces lie on this line. The outward unit normal vector for these faces is $\\hat{\\boldsymbol{n}} = (0, -1)$. For the fine cells below the interface, their top faces lie on this line, and their outward unit normal is $\\hat{\\boldsymbol{n}} = (0, 1)$. In general, the normal to the interface is parallel to the $y$-axis.\n\nThe physical flux across this interface is given by the dot product of the flux vector $\\boldsymbol{F}$ and the unit normal $\\hat{\\boldsymbol{n}}$.\n$$\n\\boldsymbol{F} \\cdot \\hat{\\boldsymbol{n}} = (qu, 0) \\cdot (0, \\pm 1) = 0\n$$\nThe physical flux across the horizontal interface is identically zero because the velocity field is purely horizontal, i.e., tangent to the interface. There is no transport of the scalar $q$ in the $y$-direction.\n\nThe problem states that the numerical scheme uses Godunov updates with upwind numerical fluxes that are consistent with the conservation law. For the advection equation, the upwind flux across a cell face with normal $\\hat{\\boldsymbol{n}}$ is proportional to the normal component of the velocity, $v_n = \\boldsymbol{v} \\cdot \\hat{\\boldsymbol{n}}$. The numerical flux is given by $F^* = v_n q_{\\text{upwind}}$, where $q_{\\text{upwind}}$ is the scalar value taken from the upwind side of the interface.\n\nIn this specific problem, the normal component of the velocity at the C-F interface is:\n$$\nv_n = \\boldsymbol{v} \\cdot \\hat{\\boldsymbol{n}} = (u, 0) \\cdot (0, \\pm 1) = 0\n$$\nSince the normal velocity component is zero, the Godunov/upwind numerical flux $F^*$ across the interface at $y=0$ must also be zero.\n$$\nF^* = 0 \\cdot q_{\\text{upwind}} = 0\n$$\nThis holds true for any state $q$ in the cells adjacent to the interface.\n\nNow we can calculate the terms that constitute the reflux correction.\n1.  **Coarse Flux**: The coarse grid calculation for the flux out of cell $C_1$ through its bottom face (length $\\Delta x_c$) over the time step $\\Delta t_c$ is $\\mathcal{F}_{\\text{coarse}, C_1} = F_{\\text{coarse}}^* \\cdot \\Delta x_c \\cdot \\Delta t_c$. Since $F_{\\text{coarse}}^*=0$, we have $\\mathcal{F}_{\\text{coarse}, C_1} = 0$.\n\n2.  **Fine Flux**: The fine grid consists of cells of size $\\Delta x_f = \\Delta x_c/2$. The bottom face of $C_1$ is covered by two fine-cell faces. The total flux from the fine grid perspective is the sum of fluxes across these fine faces, summed over the $r=2$ sub-cycles. For each fine cell face at the interface and for each fine time step, the numerical flux $F_{\\text{fine}}^*$ is calculated. Since the normal velocity $v_n$ is zero at this interface, $F_{\\text{fine}}^*=0$ for all these calculations as well. Therefore, the sum of these fine fluxes, $\\mathcal{F}_{\\text{fine}, C_1}$, is also zero.\n\nThe reflux correction to the total mass in cell $C_1$ is:\n$$\n\\delta M_{C_1} = \\mathcal{F}_{\\text{coarse}, C_1} - \\mathcal{F}_{\\text{fine}, C_1} = 0 - 0 = 0\n$$\nThe exact same logic applies to the adjacent coarse cell $C_2$. Its bottom face also lies on the $y=0$ interface, so the reflux correction to its total mass is also zero:\n$$\n\\delta M_{C_2} = 0\n$$\nThe problem asks for the reflux correction contributions to the cell-averaged scalar quantities, $\\delta Q_{C_1}$ and $\\delta Q_{C_2}$. The change in the cell-averaged quantity is related to the change in the total mass by $\\delta Q_C = \\delta M_C / A_C$, where $A_C = \\Delta x_c \\Delta y_c$ is the area of the coarse cell.\nSince $\\delta M_{C_1} = 0$ and $\\delta M_{C_2} = 0$, we have:\n$$\n\\delta Q_{C_1} = \\frac{0}{A_{C_1}} = 0\n$$\n$$\n\\delta Q_{C_2} = \\frac{0}{A_{C_2}} = 0\n$$\nThus, the reflux correction contributions to the cell-averaged scalars are zero for both cells. This is a direct consequence of the fluid flow being exactly parallel to the coarse-fine interface.\n\nThe final answer is the ordered pair $(\\delta Q_{C_1}, \\delta Q_{C_2})$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  0\n\\end{pmatrix}\n}\n$$"
        }
    ]
}