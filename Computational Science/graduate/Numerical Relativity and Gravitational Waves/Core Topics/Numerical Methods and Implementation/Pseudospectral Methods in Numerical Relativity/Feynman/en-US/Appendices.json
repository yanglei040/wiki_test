{
    "hands_on_practices": [
        {
            "introduction": "A foundational application of pseudospectral methods is the highly accurate computation of global integrals, a frequent task when evaluating conserved quantities in a simulation. This first exercise provides a hands-on implementation of a tensor-product spectral quadrature scheme to integrate a scalar function over a three-dimensional ball . By also calculating the flux of a vector field, you will numerically verify the Divergence Theorem, demonstrating the power of spectral methods in testing fundamental physical laws in a discrete setting.",
            "id": "3484253",
            "problem": "Consider a three-dimensional ball of radius $R$ equipped with standard spherical coordinates $(r,\\theta,\\phi)$ and the change of variables $u=\\cos\\theta$. The solid angle measure is $d\\Omega=\\sin\\theta\\,d\\theta\\,d\\phi=du\\,d\\phi$, and the volume measure is $dV=r^2\\,du\\,d\\phi\\,dr$. In pseudospectral methods, global integrals and conserved quantities are commonly approximated by spectral quadratures. In this problem, you will implement such quadratures in a tensor-product fashion using Gauss–Legendre (GL) quadrature on $[-1,1]$ for both the radial mapping parameter and the $u$-variable, and a uniform trigonometric (composite trapezoidal) quadrature in $\\phi$. Angles must be in radians, and all quantities are dimensionless.\n\nDefine the scalar field\n$$\n\\rho(r,u,\\phi)=A\\,r^{p}\\,e^{-\\alpha r}\\left(B_0+B_2\\,P_2(u)\\right)\\left(C_0+C_m\\cos(m\\phi)+D_m\\sin(m\\phi)\\right),\n$$\nwhere $P_2(u)=\\frac{1}{2}\\left(3u^2-1\\right)$ is the Legendre polynomial of degree $2$, and $A$, $\\alpha$, $p$, $B_0$, $B_2$, $C_0$, $C_m$, $D_m$, $m$ are real parameters. The total integral of $\\rho$ over the ball is\n$$\nI=\\int_{0}^{R}\\int_{-1}^{1}\\int_{0}^{2\\pi}\\rho(r,u,\\phi)\\,r^2\\,du\\,d\\phi\\,dr.\n$$\nYour program must compute:\n1. A pseudospectral approximation $I_{\\mathrm{spec}}$ to $I$ via a tensor-product quadrature:\n   - Radial mapping: $x\\in[-1,1]\\mapsto r(x)=\\frac{R}{2}(1+x)$, with Jacobian $dr=\\frac{R}{2}\\,dx$.\n   - Radial quadrature: Gauss–Legendre nodes and weights $\\{x_j,w^{(x)}_j\\}_{j=1}^{N_r}$ on $[-1,1]$ for the integral in $x$.\n   - Polar quadrature: Gauss–Legendre nodes and weights $\\{u_k,w^{(u)}_k\\}_{k=1}^{N_u}$ on $[-1,1]$ for the integral in $u$.\n   - Azimuthal quadrature: uniform nodes $\\phi_\\ell=\\frac{2\\pi \\ell}{N_\\phi}$ for $\\ell=0,\\dots,N_\\phi-1$ with uniform weights $w^{(\\phi)}=\\frac{2\\pi}{N_\\phi}$.\n   The pseudospectral approximation is\n   $$\n   I_{\\mathrm{spec}}=\\sum_{j=1}^{N_r}\\sum_{k=1}^{N_u}\\sum_{\\ell=0}^{N_\\phi-1} w^{(x)}_j\\,\\frac{R}{2}\\,w^{(u)}_k\\,w^{(\\phi)}\\,\\rho\\!\\left(r(x_j),u_k,\\phi_\\ell\\right)\\,r(x_j)^2.\n   $$\n2. The exact value $I_{\\mathrm{exact}}$ derived analytically from first principles for the given $\\rho(r,u,\\phi)$.\n3. The absolute error $E_1=\\left|I_{\\mathrm{spec}}-I_{\\mathrm{exact}}\\right|$.\n\nAdditionally, consider a purely radial vector field $\\mathbf{F}(r)=F_r(r)\\,\\hat{\\mathbf{r}}$ with\n$$\nF_r(r)=F_0\\,r^{q}\\,e^{-\\beta r},\n$$\nwhere $F_0$, $q$, and $\\beta$ are real parameters, and $q$ is a nonnegative integer. The divergence in spherical coordinates is $\\nabla\\cdot\\mathbf{F}=\\frac{1}{r^2}\\frac{d}{dr}\\left(r^2F_r(r)\\right)$. Your program must compute:\n1. A pseudospectral volume integral\n   $$\n   V_{\\mathrm{spec}}=\\int_{0}^{R}\\int_{-1}^{1}\\int_{0}^{2\\pi}\\left(\\nabla\\cdot\\mathbf{F}\\right)\\,r^2\\,du\\,d\\phi\\,dr\n   $$\n   using the same tensor-product quadrature as above.\n2. A pseudospectral surface integral\n   $$\n   S_{\\mathrm{spec}}=\\int_{-1}^{1}\\int_{0}^{2\\pi}F_r(R)\\,R^2\\,du\\,d\\phi\n   $$\n   using the $u$ and $\\phi$ quadratures only.\n3. The absolute discrepancy $E_2=\\left|V_{\\mathrm{spec}}-S_{\\mathrm{spec}}\\right|$.\n\nImplement your program to produce both $E_1$ and $E_2$ for each of the following test cases. Angles must be in radians. All outputs must be dimensionless floats.\n\nTest suite parameter sets:\n- Case $1$: $R=5.0$, $N_r=33$, $N_u=8$, $N_\\phi=32$, $A=1.2$, $\\alpha=0.7$, $p=3$, $B_0=1.0$, $B_2=0.5$, $C_0=1.0$, $C_m=0.3$, $D_m=-0.2$, $m=5$, $F_0=0.9$, $q=2$, $\\beta=0.6$.\n- Case $2$: $R=2.0$, $N_r=5$, $N_u=2$, $N_\\phi=8$, $A=0.8$, $\\alpha=1.5$, $p=1$, $B_0=1.1$, $B_2=-0.7$, $C_0=1.0$, $C_m=0.5$, $D_m=0.4$, $m=3$, $F_0=1.5$, $q=1$, $\\beta=1.2$.\n- Case $3$: $R=4.0$, $N_r=9$, $N_u=1$, $N_\\phi=7$, $A=2.0$, $\\alpha=0.4$, $p=2$, $B_0=0.9$, $B_2=3.0$, $C_0=1.0$, $C_m=0.0$, $D_m=0.0$, $m=7$, $F_0=0.7$, $q=3$, $\\beta=0.5$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets: $[E_{1,\\text{case 1}},E_{2,\\text{case 1}},E_{1,\\text{case 2}},E_{2,\\text{case 2}},E_{1,\\text{case 3}},E_{2,\\text{case 3}}]$. Angles must be in radians. All values must be printed as floats without additional text.",
            "solution": "The problem requires the computation of two error metrics, $E_1$ and $E_2$, for three distinct test cases. The first metric, $E_1$, quantifies the accuracy of a pseudospectral quadrature for a scalar field integral. The second, $E_2$, measures the numerical discrepancy in the divergence theorem for a given vector field. The solution necessitates both analytical derivations for exact values and numerical implementations of the specified quadrature schemes.\n\n### Part 1: Computation of Error $E_1 = |I_{\\mathrm{spec}} - I_{\\mathrm{exact}}|$\n\nThe first step is to determine the exact value of the integral $I = \\int_{0}^{R}\\int_{-1}^{1}\\int_{0}^{2\\pi}\\rho(r,u,\\phi)\\,r^2\\,du\\,d\\phi\\,dr$. The scalar field $\\rho(r,u,\\phi)$ is separable in its variables:\n$$\n\\rho(r,u,\\phi) = \\underbrace{A\\,r^{p}\\,e^{-\\alpha r}}_{f(r)} \\underbrace{\\left(B_0+B_2\\,P_2(u)\\right)}_{g(u)} \\underbrace{\\left(C_0+C_m\\cos(m\\phi)+D_m\\sin(m\\phi)\\right)}_{h(\\phi)}.\n$$\nConsequently, the integral $I$ can be factored into a product of three one-dimensional integrals:\n$$\nI_{\\mathrm{exact}} = \\left( \\int_0^R f(r) r^2 dr \\right) \\left( \\int_{-1}^1 g(u) du \\right) \\left( \\int_0^{2\\pi} h(\\phi) d\\phi \\right).\n$$\nWe evaluate each integral analytically:\n\n1.  **Radial Integral ($I_r$)**:\n    $I_r = \\int_0^R A r^p e^{-\\alpha r} r^2 dr = A \\int_0^R r^{p+2} e^{-\\alpha r} dr$. This integral is related to the lower incomplete gamma function, $\\gamma(s,x) = \\int_0^x t^{s-1} e^{-t} dt$. With a change of variables $t=\\alpha r$, we find:\n    $$\n    I_r = A \\left(\\frac{1}{\\alpha}\\right)^{p+3} \\int_0^{\\alpha R} t^{p+2} e^{-t} dt = A \\alpha^{-(p+3)} \\gamma(p+3, \\alpha R).\n    $$\n\n2.  **Polar Integral ($I_u$)**:\n    $I_u = \\int_{-1}^1 (B_0+B_2\\,P_2(u)) du$. Using the orthogonality property of Legendre polynomials, $\\int_{-1}^1 P_n(u) P_m(u) du = \\frac{2}{2n+1}\\delta_{nm}$, and noting that $1=P_0(u)$:\n    $$\n    I_u = B_0 \\int_{-1}^1 P_0(u) du + B_2 \\int_{-1}^1 P_2(u) du = B_0 \\int_{-1}^1 P_0(u)P_0(u) du + B_2 \\int_{-1}^1 P_2(u)P_0(u) du = B_0 \\left(\\frac{2}{1}\\right) + B_2 (0) = 2B_0.\n    $$\n\n3.  **Azimuthal Integral ($I_\\phi$)**:\n    $I_\\phi = \\int_0^{2\\pi} (C_0+C_m\\cos(m\\phi)+D_m\\sin(m\\phi)) d\\phi$. For any non-zero integer $m$, the integrals of $\\cos(m\\phi)$ and $\\sin(m\\phi)$ over $[0, 2\\pi]$ are zero.\n    $$\n    I_\\phi = \\int_0^{2\\pi} C_0 d\\phi = 2\\pi C_0.\n    $$\n\nCombining these results, the exact integral is:\n$$\nI_{\\mathrm{exact}} = \\left( A \\alpha^{-(p+3)} \\gamma(p+3, \\alpha R) \\right) \\cdot (2 B_0) \\cdot (2\\pi C_0) = 4\\pi A B_0 C_0 \\alpha^{-(p+3)} \\gamma(p+3, \\alpha R).\n$$\n\nNext, we compute the pseudospectral approximation $I_{\\mathrm{spec}}$ using the provided tensor-product quadrature formula:\n$$\nI_{\\mathrm{spec}}=\\sum_{j=1}^{N_r}\\sum_{k=1}^{N_u}\\sum_{\\ell=0}^{N_\\phi-1} w^{(x)}_j\\,\\frac{R}{2}\\,w^{(u)}_k\\,w^{(\\phi)}\\,\\rho\\!\\left(r(x_j),u_k,\\phi_\\ell\\right)\\,r(x_j)^2.\n$$\nThe implementation involves generating Gauss-Legendre nodes $\\{x_j, w^{(x)}_j\\}$ and $\\{u_k, w^{(u)}_k\\}$, uniform azimuthal nodes $\\phi_\\ell$ and weight $w^{(\\phi)}$, and mapping the radial nodes via $r(x_j) = \\frac{R}{2}(1+x_j)$. The function $\\rho$ is evaluated on the three-dimensional grid of points $(r(x_j), u_k, \\phi_\\ell)$, and the weighted sum is computed.\n\nFinally, the error is $E_1 = |I_{\\mathrm{spec}} - I_{\\mathrm{exact}}|$.\n\n### Part 2: Computation of Error $E_2 = |V_{\\mathrm{spec}} - S_{\\mathrm{spec}}|$\n\nThis part numerically verifies the Divergence Theorem, $\\int_V (\\nabla \\cdot \\mathbf{F}) dV = \\oint_{\\partial V} \\mathbf{F} \\cdot d\\mathbf{S}$, for the radial vector field $\\mathbf{F}(r) = F_r(r)\\hat{\\mathbf{r}}$ in a ball of radius $R$.\n\nThe volume integral is $V_{\\mathrm{spec}}$, an approximation of $\\int_V (\\nabla \\cdot \\mathbf{F}) dV$. The integrand requires the divergence of $\\mathbf{F}$:\n$$\n\\nabla \\cdot \\mathbf{F} = \\frac{1}{r^2}\\frac{d}{dr}(r^2 F_r(r)) = \\frac{1}{r^2}\\frac{d}{dr}(F_0 r^{q+2} e^{-\\beta r}) = F_0 [(q+2)r^{q-1} - \\beta r^q] e^{-\\beta r}.\n$$\nThe integral for $V_{\\mathrm{spec}}$ is over the volume of the ball:\n$$\nV_{\\mathrm{spec}} = \\int_{0}^{R}\\int_{-1}^{1}\\int_{0}^{2\\pi} (\\nabla \\cdot \\mathbf{F}) r^2 du d\\phi dr.\n$$\nThe integrand, $(\\nabla \\cdot \\mathbf{F}) r^2 = F_0 [ (q+2)r^{q+1} - \\beta r^{q+2} ]e^{-\\beta r}$, depends only on $r$. The pseudospectral approximation is computed using the same tensor-product quadrature as for $I_{\\mathrm{spec}}$. As the integrand is independent of $u$ and $\\phi$, the corresponding quadratures yield factors of $\\int_{-1}^1 du = 2$ and $\\int_0^{2\\pi} d\\phi = 2\\pi$.\n\nThe surface integral is $S_{\\mathrm{spec}}$, an approximation of $\\oint_{\\partial V} \\mathbf{F} \\cdot d\\mathbf{S}$. For a sphere of radius $R$, $d\\mathbf{S} = R^2 du d\\phi \\hat{\\mathbf{r}}$.\n$$\nS_{\\mathrm{spec}} = \\int_{-1}^{1}\\int_{0}^{2\\pi} \\mathbf{F}(R) \\cdot (R^2 du d\\phi \\hat{\\mathbf{r}}) = \\int_{-1}^{1}\\int_{0}^{2\\pi} F_r(R) R^2 du d\\phi.\n$$\nThe integrand, $F_r(R)R^2 = F_0 R^{q+2} e^{-\\beta R}$, is constant. The quadratures in $u$ and $\\phi$ are exact and yield factors of $2$ and $2\\pi$ respectively. Thus,\n$$\nS_{\\mathrm{spec}} = (F_0 R^{q+2} e^{-\\beta R}) \\cdot (2) \\cdot (2\\pi) = 4\\pi F_0 R^{q+2} e^{-\\beta R}.\n$$\nThis value is identical to the exact analytical value of the surface integral. The discrepancy $E_2 = |V_{\\mathrm{spec}} - S_{\\mathrm{spec}}|$ therefore measures the error of the radial quadrature used to compute $V_{\\mathrm{spec}}$ against the exact value of the integral which, by the Divergence Theorem, is $S_{\\mathrm{spec}}$.\n\nThe implementation proceeds by computing these quantities for each test case using vectorized `numpy` operations for efficiency.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import gamma, gammainc\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases, calculating errors E1 and E2.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'R': 5.0, 'N_r': 33, 'N_u': 8, 'N_phi': 32, 'A': 1.2, 'alpha': 0.7, 'p': 3.0,\n         'B0': 1.0, 'B2': 0.5, 'C0': 1.0, 'Cm': 0.3, 'Dm': -0.2, 'm': 5,\n         'F0': 0.9, 'q': 2, 'beta': 0.6},\n        # Case 2\n        {'R': 2.0, 'N_r': 5, 'N_u': 2, 'N_phi': 8, 'A': 0.8, 'alpha': 1.5, 'p': 1.0,\n         'B0': 1.1, 'B2': -0.7, 'C0': 1.0, 'Cm': 0.5, 'Dm': 0.4, 'm': 3,\n         'F0': 1.5, 'q': 1, 'beta': 1.2},\n        # Case 3\n        {'R': 4.0, 'N_r': 9, 'N_u': 1, 'N_phi': 7, 'A': 2.0, 'alpha': 0.4, 'p': 2.0,\n         'B0': 0.9, 'B2': 3.0, 'C0': 1.0, 'Cm': 0.0, 'Dm': 0.0, 'm': 7,\n         'F0': 0.7, 'q': 3, 'beta': 0.5},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Unpack parameters for the current test case\n        R, N_r, N_u, N_phi = case['R'], case['N_r'], case['N_u'], case['N_phi']\n        A, alpha, p = case['A'], case['alpha'], case['p']\n        B0, B2 = case['B0'], case['B2']\n        C0, Cm, Dm, m = case['C0'], case['Cm'], case['Dm'], case['m']\n        F0, q, beta = case['F0'], case['q'], case['beta']\n\n        # ==== Part 1: Compute E1 = |I_spec - I_exact| ====\n\n        # 1.1: Calculate I_exact analytically\n        # The integral separates: I = I_r * I_u * I_phi\n        # I_r = A * Integral[r^(p+2) * exp(-alpha*r), {r, 0, R}]\n        s_gamma = p + 3.0\n        x_gamma = alpha * R\n        # scipy.special.gammainc is the regularized lower incomplete gamma function P(s,x)\n        # We need the unregularized version gamma(s,x) = P(s,x) * Gamma(s)\n        gamma_incomplete = gammainc(s_gamma, x_gamma) * gamma(s_gamma)\n        \n        I_r = A * (alpha**(-s_gamma)) * gamma_incomplete\n        I_u = 2.0 * B0 # Integral of B0+B2*P2(u) from -1 to 1\n        I_phi = 2.0 * np.pi * C0 # Integral of C0+Cm*cos(m*phi)+Dm*sin(m*phi) from 0 to 2*pi\n        \n        I_exact = I_r * I_u * I_phi\n\n        # 1.2: Calculate I_spec using tensor-product quadrature\n        # Quadrature nodes and weights\n        x_j, w_x_j = np.polynomial.legendre.leggauss(N_r)\n        u_k, w_u_k = np.polynomial.legendre.leggauss(N_u)\n        phi_l = np.arange(N_phi) * (2.0 * np.pi / N_phi)\n        w_phi = 2.0 * np.pi / N_phi\n\n        # Radial mapping: x in [-1,1] -> r in [0,R]\n        r_j = R / 2.0 * (1.0 + x_j)\n        \n        def P2(u):\n            return 0.5 * (3.0 * u**2 - 1.0)\n\n        def rho(r, u, phi):\n            return (A * r**p * np.exp(-alpha * r) *\n                    (B0 + B2 * P2(u)) *\n                    (C0 + Cm * np.cos(m * phi) + Dm * np.sin(m * phi)))\n        \n        # Vectorized evaluation on the grid using numpy broadcasting\n        r_grid = r_j.reshape(-1, 1, 1)\n        u_grid = u_k.reshape(1, -1, 1)\n        phi_grid = phi_l.reshape(1, 1, -1)\n\n        integrand_vals = rho(r_grid, u_grid, phi_grid) * r_grid**2\n        \n        w_x_grid = w_x_j.reshape(-1, 1, 1)\n        w_u_grid = w_u_k.reshape(1, -1, 1)\n        \n        I_spec = np.sum(w_x_grid * (R / 2.0) * w_u_grid * w_phi * integrand_vals)\n        \n        # 1.3: Compute E1\n        E1 = abs(I_spec - I_exact)\n\n        # ==== Part 2: Compute E2 = |V_spec - S_spec| ====\n\n        # 2.1: Calculate S_spec (pseudospectral surface integral)\n        # This is the exact value of the surface integral as the integrand is constant\n        F_r_at_R = F0 * R**q * np.exp(-beta * R)\n        S_spec = 4.0 * np.pi * R**2 * F_r_at_R\n\n        # 2.2: Calculate V_spec (pseudospectral volume integral)\n        # The integrand for V_spec is (div F) * r^2\n        def divF_times_r2(r):\n            return F0 * ((q + 2.0) * r**(q + 1.0) - beta * r**(q + 2.0)) * np.exp(-beta * r)\n        \n        # The integrand only depends on r, so u and phi quadratures are exact\n        # sum(w_u)=2, sum(w_phi)=2*pi\n        integrand_vals_V = divF_times_r2(r_j)\n        integral_V_r = np.sum(w_x_j * (R / 2.0) * integrand_vals_V)\n        V_spec = 4.0 * np.pi * integral_V_r\n        \n        # 2.3: Compute E2\n        E2 = abs(V_spec - S_spec)\n\n        results.extend([E1, E2])\n    \n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from integration to solving differential equations, we tackle a problem central to setting up initial data in numerical relativity: solving elliptic equations with localized sources. This practice demonstrates how to solve the periodic Poisson equation, a model for the Hamiltonian constraint, in the presence of point-particle sources using Fourier pseudospectral methods . You will implement key techniques such as source regularization through mollification and the proper handling of the zero-frequency mode to ensure a unique, well-posed solution.",
            "id": "3484238",
            "problem": "Consider a one-dimensional periodic domain with coordinate $x \\in [0,2\\pi)$ measured in radians. In the $3{+}1$ decomposition of the Einstein field equations, the Hamiltonian constraint reduces to an elliptic equation in the conformal factor that, in simplified surrogate settings, can be modeled as a Poisson-type equation with source terms coming from compact objects. To focus on the spectral treatment of localized source terms and point particles using pseudospectral methods, study the surrogate periodic Poisson problem\n$$\n- \\partial_x^2 \\phi(x) = \\rho(x),\n$$\non the circle, where $\\rho(x)$ is a superposition of point particles modeled by Dirac delta distributions. On a periodic domain, the right-hand side must have vanishing mean for the equation to be solvable under periodic boundary conditions. In practice, pseudospectral methods handle singular sources by exact spectral projection of distributions and by mollification. Your task is to derive from first principles a spectral algorithm to compute $\\phi(x)$ on a uniform collocation grid using the Fourier pseudospectral method, treating point sources via spectrally projected mollifiers and enforcing the zero-mode constraint.\n\nStart from the following base:\n- Distribution theory for the Dirac delta: on the circle, the periodic Dirac delta centered at $x_0$ has Fourier series coefficients $\\widehat{\\delta}_{k}(x_0) = \\frac{1}{2\\pi} e^{-i k x_0}$ for all integer $k$, and its mean over $[0,2\\pi)$ is $\\frac{1}{2\\pi}$.\n- Fourier series on $[0,2\\pi)$: any sufficiently regular periodic function $f(x)$ has Fourier coefficients $\\widehat{f}_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} f(x) e^{-i k x} \\, dx$ and representation $f(x) = \\sum_{k \\in \\mathbb{Z}} \\widehat{f}_k e^{i k x}$, with $k \\in \\mathbb{Z}$.\n- In Fourier space, the Laplacian acts diagonally: for $k \\neq 0$, $-\\partial_x^2$ maps $\\widehat{\\phi}_k$ to $k^2 \\widehat{\\phi}_k$.\n\nYou must:\n1. Derive the spectral inversion formula that enforces the solvability condition by setting the zero Fourier mode $k=0$ of the solution $\\widehat{\\phi}_0$ to $0$, and for all $k \\neq 0$ compute $\\widehat{\\phi}_k = \\widehat{\\rho}_k / k^2$.\n2. Show how a spectrally projected Gaussian mollifier for each point particle with mass $m_i$ at position $x_i$ alters the source coefficients to $\\widehat{\\rho}_k = \\sum_i m_i \\widehat{G}_k e^{-i k x_i}$, where $\\widehat{G}_k$ are the Fourier coefficients of a normalized periodic Gaussian of width $\\sigma$ that integrates to $1$ over $[0,2\\pi)$. Specify $\\widehat{G}_k$ in closed form, and justify that the $k=0$ mode is handled by removing the mean to satisfy periodic Poisson solvability.\n3. Provide the exact periodic Green’s function for the operator $-\\partial_x^2$ with a single point source and zero-mean enforcement, expressed in real space. That is, for a single source at $x_0$, $\\phi(x)$ must satisfy $- \\partial_x^2 \\phi(x) = \\delta(x-x_0) - \\frac{1}{2\\pi}$ with $\\phi$ periodic and mean zero. Derive a closed-form real-space expression $G(y)$ with $y = (x - x_0) \\bmod 2\\pi \\in [0,2\\pi)$ such that $\\phi(x) = m\\, G(y)$ for a mass $m$, and extend linearly to multiple sources.\n\nYour program must implement the following algorithm:\n- Use a uniform grid with $N$ collocation points $x_j = \\frac{2\\pi j}{N}$ for $j = 0,1,\\dots,N-1$.\n- Construct the discrete frequency array of integer modes $k \\in \\{-\\frac{N}{2}, \\dots, \\frac{N}{2}-1\\}$ in Fast Fourier Transform order.\n- Assemble the Fourier coefficients $\\widehat{\\rho}_k$ of the mollified source distribution. Based on the inversion formula you derived, compute the solution's coefficients by setting $\\widehat{\\phi}_0 = 0$ (to enforce a unique, zero-mean solution) and $\\widehat{\\phi}_k = \\widehat{\\rho}_k / k^2$ for all $k \\neq 0$.\n- Optionally apply an exponential spectral filter of order $p$ with strength parameter $\\alpha$ to $\\widehat{\\phi}_k$ to reduce Gibbs oscillations near discontinuities. The filter should be $F_k = \\exp\\left(-\\alpha \\left(\\frac{|k|}{k_{\\max}}\\right)^p\\right)$ with $k_{\\max} = \\frac{N}{2}$, applied multiplicatively to $\\widehat{\\phi}_k$.\n- Reconstruct $\\phi(x_j)$ by inverse discrete Fourier transform.\n- Compute the exact solution $\\phi_{\\text{exact}}(x_j)$ as the sum over sources of $m_i$ times the periodic Green’s function evaluated at $y_i = (x_j - x_i) \\bmod 2\\pi$.\n- Report the maximum absolute error $E = \\max_j |\\phi(x_j) - \\phi_{\\text{exact}}(x_j)|$.\n\nAngles must be treated in radians. There are no other physical units in this problem. Your program must produce the single line of output containing the results as a comma-separated list enclosed in square brackets.\n\nTest Suite:\n- Case $1$: $N=512$, two sources with masses $[1.0, -0.5]$ at positions $[1.0, 4.0]$, mollifier width $\\sigma=0.05$, exponential filter order $p=18$ and strength $\\alpha=36$.\n- Case $2$: $N=128$, one source with mass $[1.0]$ at position $[2.7]$, mollifier width $\\sigma=0.001$, no filter $p=0$ and $\\alpha=0$.\n- Case $3$: $N=256$, two coincident sources at the same position $[1.0, 1.0]$ with masses $[1.0, -1.0]$, mollifier width $\\sigma=0.02$, filter order $p=24$ and strength $\\alpha=36$.\n- Case $4$: $N=1024$, one source with mass $[2.0]$ at position $[6.0]$, mollifier width $\\sigma=0.01$, filter order $p=36$ and strength $\\alpha=36$.\n- Case $5$: $N=64$, two nearby sources with masses $[1.0, 1.0]$ at positions $[3.14, 3.15]$, mollifier width $\\sigma=0.05$, filter order $p=12$ and strength $\\alpha=36$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of floating-point numbers enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$), where each entry is the maximum absolute error $E$ for the corresponding test case.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, objective, and internally consistent. It poses a standard but non-trivial exercise in applying Fourier pseudospectral methods to solve a periodic Poisson equation with singular sources, a common task in computational physics and numerical relativity. We shall proceed with a full derivation and solution.\n\nThe core of the problem is to solve the one-dimensional periodic Poisson equation:\n$$\n- \\partial_x^2 \\phi(x) = \\rho(x), \\quad x \\in [0, 2\\pi)\n$$\nwhere $\\phi(x)$ is periodic and $\\rho(x)$ represents a collection of point particles. We will use a Fourier pseudospectral method.\n\n### 1. Derivation of the Spectral Inversion Formula\n\nWe represent the solution $\\phi(x)$ and the source $\\rho(x)$ by their Fourier series:\n$$\n\\phi(x) = \\sum_{k \\in \\mathbb{Z}} \\widehat{\\phi}_k e^{i k x}, \\quad \\rho(x) = \\sum_{k \\in \\mathbb{Z}} \\widehat{\\rho}_k e^{i k x}\n$$\nwhere $\\widehat{f}_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} f(x) e^{-i k x} dx$ are the Fourier coefficients. The operator $-\\partial_x^2$ acts diagonally on the Fourier basis functions $e^{ikx}$:\n$$\n- \\partial_x^2 (e^{ikx}) = - (ik)^2 e^{ikx} = k^2 e^{ikx}\n$$\nSubstituting the Fourier series into the Poisson equation yields:\n$$\n- \\partial_x^2 \\left( \\sum_{k \\in \\mathbb{Z}} \\widehat{\\phi}_k e^{i k x} \\right) = \\sum_{k \\in \\mathbb{Z}} k^2 \\widehat{\\phi}_k e^{i k x} = \\sum_{k \\in \\mathbb{Z}} \\widehat{\\rho}_k e^{i k x}\n$$\nBy uniqueness of Fourier series, we can equate the coefficients for each mode $k$:\n$$\nk^2 \\widehat{\\phi}_k = \\widehat{\\rho}_k\n$$\nFor $k \\neq 0$, the solution is straightforward: $\\widehat{\\phi}_k = \\widehat{\\rho}_k / k^2$.\n\nFor the $k=0$ mode (the spatial average), the equation becomes $0 \\cdot \\widehat{\\phi}_0 = \\widehat{\\rho}_0$, which implies $\\widehat{\\rho}_0 = 0$. This is the solvability condition for the periodic Poisson problem: the mean of the source must be zero. If this condition is met, $\\widehat{\\phi}_0$ is unconstrained, reflecting the freedom to add an arbitrary constant to the solution $\\phi(x)$. To obtain a unique solution, we enforce the condition that the solution has zero mean, which corresponds to setting $\\widehat{\\phi}_0 = 0$.\n\nIn practice, the source term $\\rho(x)$ may not have a zero mean ($\\widehat{\\rho}_0 \\neq 0$). The standard procedure, which we adopt here, is to solve the modified problem $-\\partial_x^2 \\phi(x) = \\rho(x) - \\langle\\rho\\rangle$, where $\\langle\\rho\\rangle = \\frac{1}{2\\pi}\\int_0^{2\\pi} \\rho(x) dx = \\widehat{\\rho}_0$. The modified source $\\rho'(x) = \\rho(x) - \\widehat{\\rho}_0$ has coefficients $\\widehat{\\rho'}_k = \\widehat{\\rho}_k$ for $k \\neq 0$ and $\\widehat{\\rho'}_0 = 0$, thus satisfying the solvability condition. The spectral inversion formula is then:\n$$\n\\widehat{\\phi}_k = \\begin{cases} \\widehat{\\rho}_k / k^2 & \\text{if } k \\neq 0 \\\\ 0 & \\text{if } k = 0 \\end{cases}\n$$\nThis procedure yields the unique, zero-mean solution to the modified problem.\n\n### 2. Spectrally Projected Gaussian Mollifier\n\nThe source $\\rho(x)$ is a sum of point particles, which are mathematically Dirac delta distributions. For numerical treatment, these singular distributions are regularized using a mollifier. We use a periodic Gaussian mollifier, $G(x; \\sigma)$, defined by its Fourier coefficients. To approximate a delta function, the mollifier must integrate to $1$ over the domain, i.e., $\\int_0^{2\\pi} G(x; \\sigma) dx = 1$. In Fourier space, this means $2\\pi \\widehat{G}_0 = 1$, or $\\widehat{G}_0 = 1/(2\\pi)$. A suitable choice that is spectrally localized is:\n$$\n\\widehat{G}_k(\\sigma) = \\frac{1}{2\\pi} e^{-k^2 \\sigma^2 / 2}\n$$\nThe mollified source for a set of particles with masses $m_i$ at positions $x_i$ is $\\rho(x) = \\sum_i m_i G(x-x_i; \\sigma)$. The Fourier coefficients $\\widehat{\\rho}_k$ are found by linearity and the shift theorem:\n$$\n\\widehat{\\rho}_k = \\frac{1}{2\\pi} \\int_0^{2\\pi} \\left( \\sum_i m_i G(x-x_i; \\sigma) \\right) e^{-ikx} dx = \\sum_i m_i \\left( e^{-ikx_i} \\widehat{G}_k(\\sigma) \\right)\n$$\nSubstituting the expression for $\\widehat{G}_k(\\sigma)$, we get:\n$$\n\\widehat{\\rho}_k = \\left( \\frac{1}{2\\pi} e^{-k^2 \\sigma^2 / 2} \\right) \\sum_i m_i e^{-ikx_i}\n$$\nFor $k=0$, the mean of the source is $\\widehat{\\rho}_0 = \\frac{1}{2\\pi} \\sum_i m_i$. As established in Part 1, the spectral solution algorithm implicitly handles a non-zero mean by subtracting it from the source, which is equivalent to solving for $\\phi$ using the full $\\widehat{\\rho}_k$ and setting $\\widehat{\\phi}_0=0$.\n\n### 3. Periodic Green's Function\n\nThe exact solution for a single point source is given by the periodic Green's function, which solves:\n$$\n-\\partial_x^2 \\phi(x) = \\delta(x-x_0) - \\frac{1}{2\\pi}\n$$\nThe source term $\\delta(x-x_0) - 1/(2\\pi)$ has zero mean, satisfying the solvability condition. We require the solution $\\phi(x)$ to be periodic and have zero mean. Let us find the Green's function $G(y)$ for a source at $x_0=0$, where $y=x$. Solving $-\\partial_y^2 G(y) = \\delta(y) - 1/(2\\pi)$ in Fourier space gives $k^2 \\widehat{G}_k = \\widehat{(\\delta - 1/2\\pi)}_k$. The Fourier coefficients of the source are $\\frac{1}{2\\pi}$ for $k \\neq 0$ and $0$ for $k=0$. Thus, for $k \\neq 0$, $\\widehat{G}_k = \\frac{1}{2\\pi k^2}$. The zero-mean condition on $G(y)$ dictates $\\widehat{G}_0=0$.\nThe real-space Green's function is obtained by summing the Fourier series:\n$$\nG(y) = \\sum_{k \\in \\mathbb{Z} \\setminus \\{0\\}} \\frac{e^{iky}}{2\\pi k^2} = \\frac{1}{2\\pi} \\left( \\sum_{k=1}^{\\infty} \\frac{e^{iky}}{k^2} + \\sum_{k=1}^{\\infty} \\frac{e^{-iky}}{k^2} \\right) = \\frac{1}{\\pi} \\sum_{k=1}^{\\infty} \\frac{\\cos(ky)}{k^2}\n$$\nThis is a well-known Fourier series whose sum for $y \\in [0, 2\\pi)$ is given by $\\frac{y^2}{4} - \\frac{\\pi y}{2} + \\frac{\\pi^2}{6}$.\nTherefore, the periodic Green's function is:\n$$\nG(y) = \\frac{1}{\\pi} \\left(\\frac{y^2}{4} - \\frac{\\pi y}{2} + \\frac{\\pi^2}{6}\\right) = \\frac{y^2}{4\\pi} - \\frac{y}{2} + \\frac{\\pi}{6}, \\quad \\text{for } y \\in [0, 2\\pi)\n$$\nThe exact solution for multiple sources is obtained by linear superposition:\n$$\n\\phi_{\\text{exact}}(x) = \\sum_i m_i G\\big((x - x_i) \\pmod{2\\pi}\\big)\n$$\nThis provides the benchmark against which we measure the error of our numerical solution.\n\n### Algorithmic Implementation\n\nThe numerical algorithm proceeds as follows:\n1.  Define a uniform grid $x_j = 2\\pi j/N$ and the corresponding integer wavenumbers $k$ in FFT-friendly order.\n2.  Compute the continuous Fourier coefficients $\\widehat{\\rho}_k$ of the mollified source distribution using the formula from Part 2.\n3.  Compute the solution coefficients $\\widehat{\\phi}_k$ using the inversion formula from Part 1, i.e., division by $k^2$ for $k \\neq 0$ and setting the $k=0$ mode to zero.\n4.  Optionally apply an exponential spectral filter to $\\widehat{\\phi}_k$ to damp high-frequency oscillations (Gibbs phenomenon).\n5.  Reconstruct the real-space solution $\\phi(x_j)$ via an inverse Fast Fourier Transform (IFFT). The relation between continuous coefficients and the discrete transform requires a scaling factor of $N$: $\\phi(x_j) \\approx N \\cdot \\text{ifft}(\\{\\widehat{\\phi}_k\\})$.\n6.  Compute the exact solution on the grid using the Green's function from Part 3.\n7.  Calculate the maximum absolute error between the numerical and exact solutions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the periodic Poisson problem using a Fourier pseudospectral method\n    for a series of test cases and computes the maximum absolute error.\n    \"\"\"\n    test_cases = [\n        # Case 1: N=512, two sources with masses [1.0, -0.5] at positions [1.0, 4.0],\n        # mollifier width sigma=0.05, exponential filter order p=18 and strength alpha=36.\n        (512, [1.0, -0.5], [1.0, 4.0], 0.05, 18, 36),\n        # Case 2: N=128, one source with mass [1.0] at position [2.7],\n        # mollifier width sigma=0.001, no filter p=0 and alpha=0.\n        (128, [1.0], [2.7], 0.001, 0, 0),\n        # Case 3: N=256, two coincident sources at the same position [1.0, 1.0] with\n        # masses [1.0, -1.0], mollifier width sigma=0.02, filter order p=24 and strength alpha=36.\n        (256, [1.0, -1.0], [1.0, 1.0], 0.02, 24, 36),\n        # Case 4: N=1024, one source with mass [2.0] at position [6.0],\n        # mollifier width sigma=0.01, filter order p=36 and strength alpha=36.\n        (1024, [2.0], [6.0], 0.01, 36, 36),\n        # Case 5: N=64, two nearby sources with masses [1.0, 1.0] at positions [3.14, 3.15],\n        # mollifier width sigma=0.05, filter order p=12 and strength alpha=36.\n        (64, [1.0, 1.0], [3.14, 3.15], 0.05, 12, 36),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, masses, positions, sigma, p, alpha = case\n        error = solve_poisson_pseudospectral(N, masses, positions, sigma, p, alpha)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\ndef periodic_greens_function(y):\n    \"\"\"\n    Computes the one-dimensional periodic Green's function for -d^2/dx^2.\n    The argument y is assumed to be in the interval [0, 2*pi).\n    G(y) = y^2/(4*pi) - y/2 + pi/6\n    \"\"\"\n    return y**2 / (4 * np.pi) - y / 2.0 + np.pi / 6.0\n\ndef solve_poisson_pseudospectral(N, masses, positions, sigma, p, alpha):\n    \"\"\"\n    Implements the pseudospectral algorithm for a single test case.\n    \"\"\"\n    # 1. Define grid and wavenumbers\n    # Real-space grid points x_j in [0, 2*pi)\n    x = 2 * np.pi * np.arange(N) / N\n    # Integer wavenumbers k in FFT order: [0, 1, ..., N/2-1, -N/2, ..., -1]\n    k = np.fft.fftfreq(N) * N\n\n    # 2. Assemble source term in Fourier space\n    # The term sum_i m_i * exp(-i*k*x_i)\n    source_fourier_sum = np.zeros(N, dtype=np.complex128)\n    for m, x_pos in zip(masses, positions):\n        source_fourier_sum += m * np.exp(-1j * k * x_pos)\n    \n    # Fourier coefficients of the Gaussian mollifier: hat(G)_k = (1/(2pi)) * exp(-k^2*sigma^2/2)\n    mollifier_hat_k = (1.0 / (2.0 * np.pi)) * np.exp(-0.5 * k**2 * sigma**2)\n    \n    # Fourier coefficients of the full mollified source: hat(rho)_k\n    rho_hat = mollifier_hat_k * source_fourier_sum\n\n    # 3. Solve for phi_hat in Fourier space\n    # The equation is k^2 * hat(phi)_k = hat(rho)_k.\n    # We solve for k!=0 and set hat(phi)_0 = 0 for a unique, zero-mean solution.\n    phi_hat = np.zeros(N, dtype=np.complex128)\n    \n    # Create a mask for non-zero wavenumbers\n    nonzero_k_mask = (k != 0)\n    \n    # Invert for non-zero k\n    phi_hat[nonzero_k_mask] = rho_hat[nonzero_k_mask] / (k[nonzero_k_mask]**2)\n    # phi_hat[0] remains 0 by construction.\n\n    # 4. Apply exponential spectral filter\n    # F_k = exp(-alpha * (|k|/k_max)^p)\n    if alpha > 0 and p > 0:\n        k_max = N / 2.0\n        filter_vals = np.exp(-alpha * (np.abs(k) / k_max)**p)\n        phi_hat *= filter_vals\n\n    # 5. Reconstruct the solution phi in real space via inverse FFT\n    # The reconstruction from continuous Fourier coefficients requires multiplication by N.\n    phi_numerical = N * np.fft.ifft(phi_hat)\n    # The solution should be real; the small imaginary part is numerical noise.\n    phi_numerical = phi_numerical.real\n\n    # 6. Compute the exact solution using the Green's function\n    phi_exact = np.zeros(N)\n    for m, x_pos in zip(masses, positions):\n        # Ensure y is in [0, 2*pi)\n        y = (x - x_pos) % (2 * np.pi)\n        phi_exact += m * periodic_greens_function(y)\n\n    # 7. Calculate and return the maximum absolute error\n    error = np.max(np.abs(phi_numerical - phi_exact))\n    return error\n\nsolve()\n```"
        },
        {
            "introduction": "A significant challenge in simulating isolated astrophysical systems, like binary black holes, is the mathematically infinite extent of the spatial domain. This exercise introduces a powerful solution: domain compactification combined with Chebyshev spectral methods . You will approximate a function with a power-law tail, mimicking the late-time behavior of gravitational wave signals, on a semi-infinite domain by mapping it to a finite interval and will compare the effectiveness of a standard versus a boundary-conditioned Chebyshev basis.",
            "id": "3484209",
            "problem": "Consider a massless scalar field on a fixed Schwarzschild background of mass $M$ in $(1+1)$ dimensions after spherical harmonic decomposition and reduction to the Regge–Wheeler equation in the tortoise coordinate. It is a well-tested fact that backscattering off the curvature potential produces late-time power-law tails in time at fixed radius, with the field behaving as $\\psi(t,r)\\sim t^{-p}$ for some exponent $p$ that depends on the angular mode. To focus on the spatial resolution aspect at a large but fixed late time $t$, consider the following toy-model radial profile on the semi-infinite exterior domain $r\\geq 2M$: for $s\\equiv r-2M\\geq 0$, define\n$$\nf_{t,p,\\alpha}(s) \\equiv t^{-p}\\,(1+s)^{-\\alpha}.\n$$\nThis profile encapsulates an outgoing-like $r^{-1}$ scaling when $\\alpha=1$ and steeper algebraic decay when $\\alpha&gt;1$, consistent with asymptotic falloff in the Schwarzschild exterior at late times. Your task is to approximate $f_{t,p,\\alpha}(s)$ spectrally on the semi-infinite interval $s\\in[0,\\infty)$ and quantitatively compare two pseudospectral constructions that are widely used in numerical relativity for semi-infinite domains:\n\n1. A rational Chebyshev compactification using the algebraic map\n$$\nx=\\frac{s-L}{s+L},\\quad s\\in[0,\\infty)\\mapsto x\\in[-1,1),\n$$\nwith a scale parameter $L&gt;0$. In this coordinate, the standard Chebyshev basis $\\{T_n(x)\\}_{n\\geq 0}$ can be used to represent functions of $s$.\n\n2. A boundary-conditioned rational Chebyshev basis that enforces the vanishing of the field at spatial infinity by construction. Specifically, define the basis\n$$\n\\Psi_n(x)\\equiv T_n(x)-T_{n+1}(x),\\quad n\\geq 0,\n$$\nwhich satisfies $\\Psi_n(1)=0$ for all $n$, hence encoding $f_{t,p,\\alpha}(s\\to\\infty)=0$ at the compactified boundary $x=1$.\n\nStarting only from the fundamental definitions of the scalar tail model $f_{t,p,\\alpha}(s)$ and of the Chebyshev polynomials $T_n(x)$ on $[-1,1]$, do the following:\n\n- Derive a practical pseudospectral algorithm to compute a truncated Chebyshev series for $f_{t,p,\\alpha}(s)$ composed with the mapping $x=(s-L)/(s+L)$ using $N+1$ Chebyshev–Gauss–Lobatto collocation points $x_j=\\cos(\\pi j/N)$ for $j=0,1,\\dots,N$. For the standard Chebyshev representation, use the discrete orthogonality at these nodes to compute the coefficients of $\\sum_{n=0}^N a_n T_n(x)$.\n\n- Construct a boundary-conditioned approximation using the basis $\\{\\Psi_n\\}_{n=0}^{N-1}$ with the same collocation grid except for the point $x_0=1$ (which corresponds to $s=\\infty$ and $f_{t,p,\\alpha}=0$). Formulate and solve the resulting linear system so that the approximation matches the data at the $N$ finite collocation points $x_j$ for $j=1,\\dots,N$, and automatically satisfies the asymptotic boundary condition at $x=1$.\n\n- To quantify approximation quality near both the horizon side $s=0$ and the far zone $s\\to\\infty$, evaluate the maximum absolute error (the $L^\\infty$ norm) on a dense Chebyshev-like evaluation grid in $x\\in(-1,1)$ that excludes $x=1$, mapped back to $s$ using the same rational map. Precisely describe how the evaluation grid is chosen and how it probes the far-field behavior $s\\gg 1$.\n\n- For both approximations, extract a scalar measure of spectral coefficient decay: for the standard Chebyshev expansion record the magnitude of the last coefficient $|a_N|$, and for the boundary-conditioned basis record the magnitude of the last coefficient $|b_{N-1}|$ in the expansion $\\sum_{n=0}^{N-1} b_n \\Psi_n(x)$.\n\nYour program must implement the above for the following test suite with $M=1$ and $r-2M=s$:\n\n- Test case 1 (general late-time, balanced mapping): $(\\alpha,p,t,L,N)=(1.0,3.0,50.0,10.0,64)$.\n- Test case 2 (same tail but tighter near-horizon clustering): $(\\alpha,p,t,L,N)=(1.0,3.0,50.0,1.0,64)$.\n- Test case 3 (steeper spatial decay and later time): $(\\alpha,p,t,L,N)=(2.0,5.0,80.0,10.0,64)$.\n\nFor each test case, your program must output four floating-point numbers in the following order:\n- The maximum absolute error of the standard Chebyshev approximation on the evaluation grid.\n- The maximum absolute error of the boundary-conditioned rational Chebyshev approximation on the same grid.\n- The magnitude of the last standard Chebyshev coefficient $|a_N|$.\n- The magnitude of the last boundary-conditioned coefficient $|b_{N-1}|$.\n\nFinal output format: Your program should produce a single line of output containing the concatenated results of all test cases as a comma-separated list enclosed in square brackets, in the order of test cases 1, 2, 3. That is, the line must be\n\"[E_T1,E_R1,C_T1,C_R1,E_T2,E_R2,C_T2,C_R2,E_T3,E_R3,C_T3,C_R3]\"\nwith all quantities as decimal numbers. No units are required, and angles are not used, so no angle unit specification is needed.",
            "solution": "The problem requires a quantitative comparison of two pseudospectral approximation methods for a function defined on a semi-infinite domain, motivated by late-time tails in general relativity. The function is $f_{t,p,\\alpha}(s) = t^{-p}\\,(1+s)^{-\\alpha}$ for $s \\in [0, \\infty)$. The domain is compactified to $x \\in [-1, 1)$ using the rational map $s(x) = L\\frac{1+x}{1-x}$. The function in the compactified coordinate $x$ is denoted $g(x) \\equiv f(s(x))$.\n\nThe task is to compute approximations using a standard rational Chebyshev basis and a boundary-conditioned rational Chebyshev basis, and then to evaluate their respective accuracies and spectral coefficient decay rates.\n\nThe fundamental definitions are:\n- The function to approximate is $f_{t,p,\\alpha}(s) = t^{-p}(1+s)^{-\\alpha}$ on $s\\in[0,\\infty)$.\n- The coordinate map is $x = \\frac{s-L}{s+L}$, with its inverse $s(x) = L\\frac{1+x}{1-x}$.\n- The function in the compactified coordinate is $g(x) = f(s(x)) = t^{-p}\\left(1+L\\frac{1+x}{1-x}\\right)^{-\\alpha} = t^{-p}\\left(\\frac{(L+1)-(L-1)x}{1-x}\\right)^{-\\alpha}$.\n- The Chebyshev polynomials of the first kind are defined by the recurrence relation $T_{n+1}(x) = 2xT_n(x) - T_{n-1}(x)$ with $T_0(x)=1$ and $T_1(x)=x$.\n- The collocation points are the $N+1$ Chebyshev-Gauss-Lobatto (CGL) nodes, $x_j = \\cos(\\frac{\\pi j}{N})$ for $j=0,1,\\dots,N$. Note that $x_0=1$ corresponds to $s\\to\\infty$ and $x_N=-1$ corresponds to $s=0$. The value of the function at spatial infinity is $f(s\\to\\infty)=0$, so we have $g(x_0)=g(1)=0$.\n\nThe analysis proceeds by deriving the algorithms for the two approximation methods.\n\n**Method 1: Standard Rational Chebyshev Approximation**\n\nThis method approximates $g(x)$ by an $N$-th degree Chebyshev polynomial, $p_N(x)$, which interpolates $g(x)$ at the $N+1$ CGL nodes.\n$$\np_N(x) = \\sum_{n=0}^N a_n T_n(x)\n$$\nThe collocation conditions are $p_N(x_j) = g(x_j)$ for $j=0,1,\\dots,N$. The coefficients $a_n$ of this interpolating polynomial can be computed using the property of discrete orthogonality of Chebyshev polynomials on the CGL grid. The explicit formula for the coefficients is:\n$$\na_n = \\frac{2}{N \\bar{c}_n} \\sum_{j=0}^N \\frac{g(x_j)}{\\bar{c}_j} T_n(x_j)\n$$\nwhere $\\bar{c}_k$ are normalization constants defined as $\\bar{c}_0 = \\bar{c}_N = 2$, and $\\bar{c}_k = 1$ for $k=1, \\dots, N-1$. Since $T_n(x_j) = \\cos(\\frac{\\pi nj}{N})$, the formula can be written as:\n$$\na_n = \\frac{2}{N \\bar{c}_n} \\sum_{j=0}^N \\frac{g(\\cos(\\frac{\\pi j}{N}))}{\\bar{c}_j} \\cos\\left(\\frac{\\pi nj}{N}\\right)\n$$\nThis is essentially a Discrete Cosine Transform of type I (DCT-I). This sum can be implemented directly. The required measure of spectral decay for this method is the magnitude of the last coefficient, $|a_N|$.\n\n**Method 2: Boundary-Conditioned Rational Chebyshev Approximation**\n\nThis method uses a basis specifically constructed to enforce the boundary condition $g(1)=0$. The basis functions are $\\Psi_n(x) = T_n(x) - T_{n+1}(x)$ for $n \\ge 0$. Since $T_n(1)=1$ for all $n$, it follows that $\\Psi_n(1) = 1-1=0$. The approximation is written as a truncated sum:\n$$\nq_{N-1}(x) = \\sum_{n=0}^{N-1} b_n \\Psi_n(x)\n$$\nBy construction, $q_{N-1}(1)=0$, automatically matching the function at $s=\\infty$. The unknown coefficients $b_n$ are determined by enforcing collocation at the remaining $N$ CGL nodes, $x_j$ for $j=1, \\dots, N$:\n$$\nq_{N-1}(x_j) = g(x_j), \\quad j=1, \\dots, N\n$$\nThis yields an $N\\times N$ linear system of equations for the coefficients $\\mathbf{b} = (b_0, \\dots, b_{N-1})^T$:\n$$\n\\sum_{n=0}^{N-1} b_n \\Psi_n(x_j) = g(x_j), \\quad j=1, \\dots, N\n$$\nLet this system be written as $A\\mathbf{b} = \\mathbf{g}$, where the matrix elements are $A_{j'n} = \\Psi_n(x_{j'+1})$ and the right-hand side vector elements are $g_{j'} = g(x_{j'+1})$, for Python-style indices $j', n \\in \\{0, \\dots, N-1\\}$. Using $x_j = \\cos(\\pi j/N)$ and $T_n(x_j) = \\cos(\\pi n j/N)$, the matrix elements are:\n$$\nA_{j'n} = \\cos\\left(\\frac{\\pi n (j'+1)}{N}\\right) - \\cos\\left(\\frac{\\pi (n+1) (j'+1)}{N}\\right)\n$$\nThis linear system can be solved for the coefficient vector $\\mathbf{b}$ using a standard linear algebra solver. The measure of spectral decay for this method is the magnitude of the last coefficient, $|b_{N-1}|$.\n\n**Error Evaluation**\n\nTo assess the quality of the approximations, we calculate the maximum absolute error (the $L^\\infty$ norm) on a dense evaluation grid. A suitable grid is a finer CGL-type grid, which clusters points near the boundaries $x=\\pm 1$ ($s=0$ and $s\\to\\infty$), where spectral methods often exhibit larger errors. We choose an evaluation grid $x'_k$ with $N_{eval} = 4N$ points:\n$$\nx'_k = \\cos\\left(\\frac{\\pi k}{N_{eval}}\\right), \\quad k=1, \\dots, N_{eval}-1\n$$\nThis grid lies in the open interval $(-1,1)$, excluding the endpoints as specified. The error for the standard approximation is $E_T = \\max_k |p_N(x'_k) - g(x'_k)|$, and for the boundary-conditioned approximation it is $E_R = \\max_k |q_{N-1}(x'_k) - g(x'_k)|$.\n\nTo evaluate the polynomial sums $p_N(x)$ and $q_{N-1}(x)$ efficiently and accurately, we can use Clenshaw's algorithm. For the standard sum $p_N(x) = \\sum_{n=0}^N a_n T_n(x)$, the algorithm is applied directly. For the boundary-conditioned sum $q_{N-1}(x) = \\sum_{n=0}^{N-1} b_n \\Psi_n(x)$, we first express it as a standard Chebyshev series:\n$$\nq_{N-1}(x) = \\sum_{n=0}^{N-1} b_n (T_n(x) - T_{n+1}(x)) = b_0 T_0(x) + \\sum_{n=1}^{N-1} (b_n - b_{n-1})T_n(x) - b_{N-1}T_N(x)\n$$\nThis is a standard Chebyshev series $\\sum_{n=0}^N c_n T_n(x)$ with coefficients $c_0=b_0$, $c_n=b_n-b_{n-1}$ for $1\\le n \\le N-1$, and $c_N=-b_{N-1}$. Clenshaw's algorithm can then be applied to this equivalent series.\n\nThe implementation will proceed by calculating these quantities for each test case provided.",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef clenshaw_chebyshev(x, c):\n    \"\"\"\n    Evaluates a Chebyshev series sum_n c_n T_n(x) using Clenshaw's algorithm.\n    \"\"\"\n    x = np.atleast_1d(x)\n    c = np.atleast_1d(c)\n    if len(c) == 0:\n        return np.zeros_like(x)\n    if len(c) == 1:\n        return np.full_like(x, c[0])\n    \n    y0 = np.zeros_like(x)\n    y1 = np.zeros_like(x)\n    \n    # Use recurrence y_{k-1} = 2*x*y_k - y_{k+1} + c_{k-1}\n    for i in range(len(c) - 1, 0, -1):\n        y_tmp = y0\n        y0 = c[i] + 2 * x * y0 - y1\n        y1 = y_tmp\n        \n    return c[0] + x * y0 - y1\n\ndef compute_metrics(alpha, p, t, L, N):\n    \"\"\"\n    Computes the four specified metrics for a given test case.\n    \"\"\"\n    # 1. Define function and coordinate map\n    def s_map(x):\n        return L * (1.0 + x) / (1.0 - x)\n\n    def g_func(x):\n        # Handle x=1 case where s -> infinity\n        if isinstance(x, (float, np.floating)) and np.isclose(x, 1.0):\n            return 0.0\n        \n        # Vectorized version\n        res = np.zeros_like(x, dtype=float)\n        # Avoid division by zero\n        non_one_mask = ~np.isclose(x, 1.0)\n        x_safe = x[non_one_mask]\n        \n        s_vals = s_map(x_safe)\n        f_vals = np.power(t, -p) * np.power(1.0 + s_vals, -alpha)\n        res[non_one_mask] = f_vals\n        return res\n\n    # 2. Standard Rational Chebyshev Method\n    # CGL grid\n    j_grid = np.arange(N + 1)\n    x_cgl = np.cos(np.pi * j_grid / N)\n    \n    # Function values on CGL grid\n    v = g_func(x_cgl)\n    \n    # Compute coefficients a_n using direct summation\n    c_bar = np.ones(N + 1)\n    c_bar[0], c_bar[N] = 2.0, 2.0\n    \n    a_n = np.zeros(N + 1)\n    for n in range(N + 1):\n        T_n_xj = np.cos(np.pi * n * j_grid / N)\n        sum_val = np.sum(v * T_n_xj / c_bar)\n        a_n[n] = (2.0 / (N * c_bar[n])) * sum_val\n        \n    last_coeff_std = np.abs(a_n[N])\n\n    # 3. Boundary-Conditioned Method\n    # Collocation on x_j for j=1,...,N\n    j_bc_grid = np.arange(1, N + 1)\n    x_bc = np.cos(np.pi * j_bc_grid / N)\n    g_bc = g_func(x_bc)\n\n    # Build matrix A_jn = Psi_n(x_j)\n    A = np.zeros((N, N))\n    n_basis = np.arange(N)\n    for j_idx, j in enumerate(j_bc_grid):\n        arg = np.pi * j / N\n        A[j_idx, :] = np.cos(n_basis * arg) - np.cos((n_basis + 1) * arg)\n    \n    # Solve system A*b = g\n    try:\n        b_n = linalg.solve(A, g_bc)\n    except linalg.LinAlgError:\n        # Fallback to pseudo-inverse if singular, though unlikely for this setup\n        b_n = linalg.pinv(A) @ g_bc\n\n    last_coeff_bc = np.abs(b_n[N-1])\n    \n    # 4. Error Evaluation\n    N_eval = 4 * N\n    k_eval = np.arange(1, N_eval)\n    x_eval = np.cos(np.pi * k_eval / N_eval)\n    g_exact_eval = g_func(x_eval)\n    \n    # Error for standard method\n    p_N_eval = clenshaw_chebyshev(x_eval, a_n)\n    error_std = np.max(np.abs(p_N_eval - g_exact_eval))\n    \n    # Error for boundary-conditioned method\n    # Convert b_n (Psi_n basis) to c_n (T_n basis)\n    c_n_bc = np.zeros(N + 1)\n    c_n_bc[0] = b_n[0]\n    for n in range(1, N):\n        c_n_bc[n] = b_n[n] - b_n[n-1]\n    c_n_bc[N] = -b_n[N-1]\n    \n    q_N_eval = clenshaw_chebyshev(x_eval, c_n_bc)\n    error_bc = np.max(np.abs(q_N_eval - g_exact_eval))\n    \n    return [error_std, error_bc, last_coeff_std, last_coeff_bc]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and format output.\n    \"\"\"\n    test_cases = [\n        # (alpha, p, t, L, N)\n        (1.0, 3.0, 50.0, 10.0, 64),\n        (1.0, 3.0, 50.0, 1.0, 64),\n        (2.0, 5.0, 80.0, 10.0, 64),\n    ]\n\n    results = []\n    for case in test_cases:\n        metrics = compute_metrics(*case)\n        results.extend(metrics)\n\n    # Format output as specified\n    # Example: [E_T1,E_R1,C_T1,C_R1,E_T2,E_R2,C_T2,C_R2,E_T3,E_R3,C_T3,C_R3]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}