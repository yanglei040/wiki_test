{
    "hands_on_practices": [
        {
            "introduction": "数值模拟的核心产出是一系列数字，而科学家的任务是从这些数据中提取物理意义。此练习旨在培养从原始模拟输出中评估数值解质量的基本技能。通过使用来自三个不同分辨率的假设数据，你将应用理查德森外推法（Richardson extrapolation）来后验性地估计收敛阶数 $p$ 和更精确的连续极限值，这些都是验证代码准确性的关键指标 。这项实践不仅强化了对收敛理论的理解，还让你直面有限精度算术带来的不确定性，这是理解实际计算限制的重要一步。",
            "id": "3470456",
            "problem": "在一个受广义相对论（GR）控制的等质量、无自旋双黑洞并合的数值相对论（NR）模拟中，进行了一项三种分辨率的收敛性检验。该代码使用笛卡尔网格上的有限差分方法离散化，计算了在 $(\\ell=2,m=2)$ 模式引力波振幅峰值处的无量纲辐射能量分数 $E_{\\mathrm{rad}}/M$。设基准网格间距为 $h$，并考虑连续的均匀加密 $h/2$ 和 $h/4$。在这些分辨率下，该可观测量的测量值为 $u_h = 0.03450$、$u_{h/2} = 0.0354375$ 和 $u_{h/4} = 0.03549609375$。假设对于某个常数 $C$ 和阶数 $p$，主阶截断误差按 $C h^p$ 的规律变化，并且浮点运算采用 IEEE 754 双精度，机器精度为 $\\epsilon = 2^{-52}$。将每个报告的 $u$ 值视为受到一个以 $\\epsilon$ 为界的独立相对舍入不确定度的影响。\n\n从截断误差的标度假设和后验收敛性分析的第一性原理出发，确定：\n1) 收敛阶 $p$ 的后验估计。\n2) 通过由 $(h/2, h/4)$ 对构造的 Richardson 外推法得到的可观测量连续极限估计。\n3) 使用相对于 $p$ 估计中所涉及的差值的一阶线性化方法，计算由有限精度引起的 $p$ 的绝对不确定度。\n4) 通过对 $u_{h/4}$、$u_{h/2}$ 的独立舍入界以及 $p$ 的不确定度进行一阶传播，得到由有限精度引起的外推连续极限值的绝对不确定度。\n\n将最终报告的数值四舍五入到四位有效数字。所有量均表示为无量纲数。",
            "solution": "在尝试任何解答之前，需对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **模拟：** 数值相对论（NR），等质量、无自旋双黑洞并合。\n- **基础理论：** 广义相对论（GR）。\n- **可观测量：** 无量纲辐射能量分数 $E_{\\mathrm{rad}}/M$，记为 $u$。\n- **数值格式：** 笛卡尔网格上的有限差分法，三种网格间距：$h$、$h/2$ 和 $h/4$。\n- **测量值：**\n    - $u_h = 0.03450$\n    - $u_{h/2} = 0.0354375$\n    - $u_{h/4} = 0.03549609375$\n- **误差模型：** 主阶截断误差按 $C h^p$ 规律变化，意味着对于某个连续极限值 $u_0$、常数 $C$、阶数 $p$ 以及代表网格间距的 $k$，有 $u_k \\approx u_0 + C k^p$。\n- **精度：** IEEE 754 双精度，机器精度 $\\epsilon = 2^{-52}$。\n- **不确定度模型：** 每次测量 $u$ 都有一个以 $\\epsilon$ 为界的独立相对舍入不确定度，因此绝对不确定度为 $\\delta u \\approx |u|\\epsilon$。\n- **待求量：**\n    1. 收敛阶 $p$ 的后验估计。\n    2. 通过 $(h/2, h/4)$ 进行 Richardson 外推得到的连续极限估计。\n    3. 由有限精度引起的 $p$ 的绝对不确定度 $\\delta p$。\n    4. 由有限精度引起的外推连续极限值的绝对不确定度 $\\delta u_0$。\n- **报告要求：** 将最终数值四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题坚实地植根于计算科学和数值相对论。收敛性检验、Richardson 外推法和舍入误差分析是代码验证和从数值模拟中获得可靠结果的标准、必要程序。物理背景（双黑洞并合）和可观测量（$E_{\\mathrm{rad}}/M$）是该领域的标准内容。\n- **适定性：** 该问题是适定的。它提供了所有必要的数据和一个清晰的误差模型，以唯一地确定所求的量。\n- **客观性：** 该问题以精确、技术性的语言陈述，没有主观或模糊的术语。\n- **完整性和一致性：** 数据和假设是自洽且一致的。提供的数值是收敛的，参数足以进行分析。\n- **真实性：** 辐射能量分数的数值对于双黑洞并合是物理上现实的（占总质能的百分之几）。使用高阶有限差分格式可以达到 $p=4$ 的收敛阶。\n\n### 步骤 3：结论与行动\n该问题在科学上是合理的、适定的和完整的。因此，判定其为 **有效**。将提供详细的解答。\n\n### 解题推导\n\n对于网格间距为 $k$ 的数值解 $u_k$，其基本假设是它与精确连续解 $u_0$ 的关系如下：\n$$u_k \\approx u_0 + C k^p$$\n其中 $C$ 是一个常数，$p$ 是收敛阶。我们得到了在连续加密的三个分辨率下的测量值：$u_h$、$u_{h/2}$ 和 $u_{h/4}$。\n\n**1) 收敛阶 $p$ 的后验估计**\n\n我们写出这三个分辨率下的近似表达式：\n$$u_h \\approx u_0 + C h^p$$\n$$u_{h/2} \\approx u_0 + C \\left(\\frac{h}{2}\\right)^p = u_0 + \\frac{C h^p}{2^p}$$\n$$u_{h/4} \\approx u_0 + C \\left(\\frac{h}{4}\\right)^p = u_0 + \\frac{C h^p}{4^p}$$\n为了求出 $p$，我们构造差分以消去 $u_0$：\n$$u_{h/2} - u_h \\approx \\frac{C h^p}{2^p} - C h^p = C h^p \\left(\\frac{1}{2^p} - 1\\right)$$\n$$u_{h/4} - u_{h/2} \\approx \\frac{C h^p}{4^p} - \\frac{C h^p}{2^p} = \\frac{C h^p}{2^p} \\left(\\frac{1}{2^p} - 1\\right)$$\n取这两个差分的比值，可以消去 $C$ 和项 $(1/2^p - 1)$：\n$$R = \\frac{u_{h/2} - u_h}{u_{h/4} - u_{h/2}} \\approx \\frac{C h^p \\left(\\frac{1}{2^p} - 1\\right)}{\\frac{C h^p}{2^p} \\left(\\frac{1}{2^p} - 1\\right)} = 2^p$$\n这就给出了收敛阶 $p$ 的公式：\n$$p = \\log_2(R) = \\frac{\\ln(R)}{\\ln(2)} = \\frac{\\ln\\left(\\frac{u_{h/2} - u_h}{u_{h/4} - u_{h/2}}\\right)}{\\ln(2)}$$\n代入给定值：\n$$u_{h/2} - u_h = 0.0354375 - 0.03450 = 0.0009375$$\n$$u_{h/4} - u_{h/2} = 0.03549609375 - 0.0354375 = 0.00005859375$$\n$$R = \\frac{0.0009375}{0.00005859375} = 16$$\n$$p = \\log_2(16) = 4$$\n估计的收敛阶恰好为 $p=4$。报告为四位有效数字即为 $p=4.000$。\n\n**2) 通过 Richardson 外推法得到的连续极限估计**\n\nRichardson 外推法提供了对连续极限值 $u_0$ 的一个更高阶的估计。对于加密因子 $r$，通用公式为 $u_0 \\approx u_{\\text{fine}} + \\frac{u_{\\text{fine}} - u_{\\text{coarse}}}{r^p - 1}$。题目指定使用 $(h/2, h/4)$ 对，其网格间距的加密因子为 $r=2$。因此，$u_{\\text{coarse}} = u_{h/2}$ 且 $u_{\\text{fine}} = u_{h/4}$。\n设外推值为 $u_{ext}$。\n$$u_{ext} \\approx u_{h/4} + \\frac{u_{h/4} - u_{h/2}}{2^p - 1}$$\n使用 $p=4$ 和先前计算的差值：\n$$u_{ext} \\approx 0.03549609375 + \\frac{0.00005859375}{2^4 - 1} = 0.03549609375 + \\frac{0.00005859375}{15}$$\n$$u_{ext} \\approx 0.03549609375 + 0.00000390625 = 0.0355$$\n连续极限估计值恰好为 $u_{ext}=0.0355$。报告为四位有效数字即为 $u_{ext}=0.03550$。\n\n**3) 由有限精度引起的 $p$ 的绝对不确定度**\n\n$p$ 的公式为 $p = \\frac{\\ln(A/B)}{\\ln(2)}$，其中 $A = u_{h/2} - u_h$ 且 $B = u_{h/4} - u_{h/2}$。不确定度 $\\delta p$ 通过传播测量值的不确定度来求得。\n$$(\\delta p)^2 = \\left(\\frac{1}{\\ln(2)}\\right)^2 \\left[ \\frac{(\\delta A)^2}{A^2} + \\frac{(\\delta B)^2}{B^2} \\right]$$\n不确定度 $\\delta A$ 和 $\\delta B$ 源于 $u$ 值的不确定度，给定为 $\\delta u_k = u_k \\epsilon$。由于舍入误差是独立的，它们以平方和的形式叠加：\n$$(\\delta A)^2 = (\\delta u_{h/2})^2 + (\\delta u_h)^2 = (u_{h/2}\\epsilon)^2 + (u_h\\epsilon)^2 = \\epsilon^2 (u_{h/2}^2 + u_h^2)$$\n$$(\\delta B)^2 = (\\delta u_{h/4})^2 + (\\delta u_{h/2})^2 = (u_{h/4}\\epsilon)^2 + (u_{h/2}\\epsilon)^2 = \\epsilon^2 (u_{h/4}^2 + u_{h/2}^2)$$\n将这些代入 $(\\delta p)^2$ 的表达式中：\n$$\\delta p = \\frac{\\epsilon}{\\ln(2)} \\sqrt{\\frac{u_{h/2}^2 + u_h^2}{(u_{h/2} - u_h)^2} + \\frac{u_{h/4}^2 + u_{h/2}^2}{(u_{h/4} - u_{h/2})^2}}$$\n我们现在代入数值：\n$$ (u_{h/2}-u_h)^2 = (0.0009375)^2 \\approx 8.78906 \\times 10^{-7} $$\n$$ (u_{h/4}-u_{h/2})^2 = (0.00005859375)^2 \\approx 3.43323 \\times 10^{-9} $$\n$$ u_{h/2}^2 + u_h^2 = (0.0354375)^2 + (0.03450)^2 \\approx 0.0012558 + 0.0011903 = 0.0024461 $$\n$$ u_{h/4}^2 + u_{h/2}^2 = (0.03549609375)^2 + (0.0354375)^2 \\approx 0.00125997 + 0.00125581 = 0.00251578 $$\n$$\\frac{0.0024461}{8.78906 \\times 10^{-7}} \\approx 2783.1$$\n$$\\frac{0.00251578}{3.43323 \\times 10^{-9}} \\approx 732779$$\n$$\\delta p \\approx \\frac{2^{-52}}{\\ln(2)} \\sqrt{2783.1 + 732779} = \\frac{2^{-52}}{\\ln(2)} \\sqrt{735562} \\approx \\frac{2.2204 \\times 10^{-16}}{0.69315} \\times 857.65$$\n$$\\delta p \\approx (3.2033 \\times 10^{-16}) \\times 857.65 \\approx 2.7473 \\times 10^{-13}$$\n保留四位有效数字，$p$ 的绝对不确定度为 $2.747 \\times 10^{-13}$。\n\n**4) 外推连续极限值的绝对不确定度**\n\n外推值为 $u_{ext} = \\frac{2^p u_{h/4} - u_{h/2}}{2^p - 1}$。根据题目结构的说明，我们在不确定度传播中将 $u_{h/4}$、$u_{h/2}$ 和 $p$ 视为独立变量。\n$$(\\delta u_{ext})^2 = \\left(\\frac{\\partial u_{ext}}{\\partial u_{h/4}}\\right)^2 (\\delta u_{h/4})^2 + \\left(\\frac{\\partial u_{ext}}{\\partial u_{h/2}}\\right)^2 (\\delta u_{h/2})^2 + \\left(\\frac{\\partial u_{ext}}{\\partial p}\\right)^2 (\\delta p)^2$$\n偏导数是：\n$$\\frac{\\partial u_{ext}}{\\partial u_{h/4}} = \\frac{2^p}{2^p - 1} = \\frac{16}{15}$$\n$$\\frac{\\partial u_{ext}}{\\partial u_{h/2}} = -\\frac{1}{2^p - 1} = -\\frac{1}{15}$$\n$$\\frac{\\partial u_{ext}}{\\partial p} = \\frac{(\\ln 2) 2^p (u_{h/2} - u_{h/4})}{(2^p - 1)^2} = \\frac{16 \\ln(2) (-0.00005859375)}{15^2} \\approx -2.889 \\times 10^{-6}$$\n不确定度为 $\\delta u_k = u_k \\epsilon$ 以及来自第 3 部分的 $\\delta p$。我们来评估每一项对总方差 $(\\delta u_{ext})^2$ 的贡献。\n第 1 项（来自 $u_{h/4}$）：\n$$\\left(\\frac{16}{15}\\right)^2 (\\delta u_{h/4})^2 = \\left(\\frac{16}{15}\\right)^2 (u_{h/4} \\epsilon)^2 \\approx (1.1378) (0.035496 \\times 2^{-52})^2 \\approx 7.086 \\times 10^{-35}$$\n第 2 项（来自 $u_{h/2}$）：\n$$\\left(-\\frac{1}{15}\\right)^2 (\\delta u_{h/2})^2 = \\left(\\frac{1}{15}\\right)^2 (u_{h/2} \\epsilon)^2 \\approx (0.00444) (0.035438 \\times 2^{-52})^2 \\approx 2.757 \\times 10^{-37}$$\n第 3 项（来自 $p$）：\n$$\\left(\\frac{\\partial u_{ext}}{\\partial p}\\right)^2 (\\delta p)^2 \\approx (-2.889 \\times 10^{-6})^2 (2.747 \\times 10^{-13})^2 \\approx (8.346 \\times 10^{-12}) (7.546 \\times 10^{-26}) \\approx 6.30 \\times 10^{-37}$$\n来自 $u_{h/4}$ 不确定度的贡献是主导的。另外两项小了两个数量级以上，对于此精度水平可以忽略不计。\n$$(\\delta u_{ext})^2 \\approx \\left(\\frac{16}{15}\\right)^2 (u_{h/4}\\epsilon)^2 + \\left(-\\frac{1}{15}\\right)^2 (u_{h/2}\\epsilon)^2 = \\frac{\\epsilon^2}{15^2} [16^2 u_{h/4}^2 + u_{h/2}^2]$$\n$$\\delta u_{ext} \\approx \\frac{\\epsilon}{15} \\sqrt{256 u_{h/4}^2 + u_{h/2}^2} = \\frac{2^{-52}}{15} \\sqrt{256(0.035496...)^2 + (0.0354375)^2}$$\n$$\\delta u_{ext} \\approx \\frac{2^{-52}}{15} \\sqrt{0.32255 + 0.001256} = \\frac{2^{-52}}{15} \\sqrt{0.32381} \\approx \\frac{2.2204 \\times 10^{-16}}{15} \\times 0.56904$$\n$$\\delta u_{ext} \\approx (1.4803 \\times 10^{-17}) \\times 0.56904 \\approx 8.4235 \\times 10^{-18}$$\n保留四位有效数字，$u_{ext}$ 的绝对不确定度为 $8.424 \\times 10^{-18}$。\n\n### 结果总结\n- 估计的收敛阶 $p = 4.000$\n- 外推的连续极限值 $u_{ext} = 0.03550$\n- 阶数的绝对不确定度 $\\delta p = 2.747 \\times 10^{-13}$\n- 外推值的绝对不确定度 $\\delta u_{ext} = 8.424 \\times 10^{-18}$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 4.000 & 0.03550 & 2.747 \\times 10^{-13} & 8.424 \\times 10^{-18} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在掌握了如何分析单个数据点的收敛性之后，下一步是开发能够系统性地、在整个计算区域内评估代码行为的工具。本练习将理论付诸实践，要求你编写一个程序来生成模拟引力波信号的合成数据，并实现一个“可操作的”渐近状态判据 。通过在时空中的每个点上测试收敛行为，并考虑到在强场区域（如黑洞合并时）可能发生的阶数退化等真实世界的复杂性，这项练习让你学会了如何构建和部署强大的验证诊断程序，这是确保复杂模拟结果可靠性的关键一步。",
            "id": "3470415",
            "problem": "您正在验证一个用于求解双黑洞并合的爱因斯坦场方程的数值相对论代码。该代码在几何单位制（$G=c=1$）下运行，其中引力常数和光速均设为1。在渐近离散化区域，对于一个光滑量 $u$，形式阶为 $p$ 的有限差分格式的主导数值截断误差与 $C h^{p}$ 成比例，其中 $C$ 是一个光滑场，$h$ 是特征网格间距。对于一个加密因子 $s$，考虑分别用网格间距 $h$、$h/s$ 和 $h/s^{2}$ 计算出的三个数值解 $u_{h}$、$u_{h/s}$ 和 $u_{h/s^{2}}$。一个可操作的渐近区域判据要求，在固定的时空点上，对一组变量计算出的连续分辨率间差异的范数之比应接近 $s^{p}$。具体来说，在每个时空点 $(t, x)$，定义一个变量矢量 $\\mathbf{u} = \\left(u^{(1)}, u^{(2)}, u^{(3)}\\right)$，它包含三个物理相关场：加号偏振应变 $h_{+}$、叉号偏振应变 $h_{\\times}$ 和一个曲率代理 $\\psi$。对于每个分辨率三元组，计算差分矢量在变量间的欧几里得范数，并检验其比率是否在指定容差内接近 $s^{p}$。\n\n您将在一维空间域和代表并合前、并合时和并合后的三个时间瞬间上构建合成场。使用无量纲的几何单位制；距离和时间以双星系统总质量 $M$ 的倍数来衡量，但最终输出是无量纲的分数，因此不需要单位转换。底层的精确场由一个光滑的包络和相位指定，旨在模拟在并合时刻达到峰值的引力波信号。设空间坐标为 $x \\in [-X_{\\max}, X_{\\max}]$，三个评估时间点为 $t_{\\mathrm{pre}}$、$t_{\\mathrm{merge}}$ 和 $t_{\\mathrm{post}}$。定义包络和相位，\n$$\nA(t) = \\exp\\!\\left(-\\frac{(t - t_{\\mathrm{merge}})^{2}}{2 \\sigma_{t}^{2}}\\right), \\quad\n\\Phi(t) = 2\\pi\\left(f_{0} t + \\frac{\\alpha}{2}(t - t_{\\mathrm{merge}})^{2} + \\frac{\\beta}{3}(t - t_{\\mathrm{merge}})^{3}\\right),\n$$\n以及精确场，\n$$\nh_{+}^{\\mathrm{exact}}(t, x) = A(t)\\,\\cos\\!\\big(\\Phi(t)\\big)\\,\\exp\\!\\left(-\\frac{(x-x_{0})^{2}}{2\\sigma_{x}^{2}}\\right),\n$$\n$$\nh_{\\times}^{\\mathrm{exact}}(t, x) = A(t)\\,\\sin\\!\\big(\\Phi(t)\\big)\\,\\exp\\!\\left(-\\frac{(x-x_{0})^{2}}{2\\sigma_{x}^{2}}\\right),\n$$\n$$\n\\psi^{\\mathrm{exact}}(t, x) = A(t)\\,\\cos\\!\\big(2\\Phi(t) + \\pi/4\\big)\\,\\exp\\!\\left(-\\frac{(x-x_{0})^{2}}{\\sigma_{x}^{2}}\\right).\n$$\n分辨率为 $h$ 的合成数值解是通过向精确场添加受控的截断误差来定义的。设依赖于变量的主导误差振幅为\n$$\nC_{+}(t, x) = A(t)\\left(1 + 0.3\\cos\\!\\big(\\Phi(t)\\big)\\right)\\exp\\!\\left(-\\frac{(x-x_{0})^{2}}{2\\sigma_{x}^{2}}\\right),\n$$\n$$\nC_{\\times}(t, x) = 1.1\\,C_{+}(t, x), \\quad C_{\\psi}(t, x) = 0.9\\,C_{+}(t, x).\n$$\n允许局部有效阶 $p_{\\mathrm{actual}}(t)$ 在并合附近降低，以模拟强场效应：设置\n$$\np_{\\mathrm{actual}}(t) = \\begin{cases}\np_{\\mathrm{degrade}}  \\text{if } A(t) \\ge \\theta,\\\\\np_{\\mathrm{formal}}  \\text{otherwise}.\n\\end{cases}\n$$\n可选地，包含一个指数为 $q = p_{\\mathrm{formal}} + 1$、振幅因子为 $\\gamma$ 的次主导误差项，以探测灵敏度。对于每个变量 $v \\in \\{+, \\times, \\psi\\}$及其对应的振幅 $C_{v}$ 和 $D_{v}$（取 $D_{v}(t, x) = 0.5\\,C_{v}(t, x)$），定义合成数值场\n$$\nu^{(v)}_{h}(t, x) = u^{(v)}_{\\mathrm{exact}}(t, x) + C_{v}(t, x)\\,h^{p_{\\mathrm{actual}}(t)} + \\gamma\\,D_{v}(t, x)\\,h^{q}.\n$$\n使用加密因子 $s$，使得三个分辨率分别为 $h$、$h/s$ 和 $h/s^{2}$。在每个点 $(t, x)$，构建变量差分矢量\n$$\n\\Delta_{1}(t, x) = \\big(u^{(v)}_{h} - u^{(v)}_{h/s}\\big)_{v}, \\qquad\n\\Delta_{2}(t, x) = \\big(u^{(v)}_{h/s} - u^{(v)}_{h/s^{2}}\\big)_{v},\n$$\n计算它们在变量间的欧几里得范数，\n$$\n\\|\\Delta_{1}(t, x)\\|_{2} = \\sqrt{\\sum_{v} \\big(u^{(v)}_{h}(t, x) - u^{(v)}_{h/s}(t, x)\\big)^{2}}, \\quad\n\\|\\Delta_{2}(t, x)\\|_{2} = \\sqrt{\\sum_{v} \\big(u^{(v)}_{h/s}(t, x) - u^{(v)}_{h/s^{2}}(t, x)\\big)^{2}},\n$$\n并将点 $(t, x)$ 处的比率定义为\n$$\nR(t, x) = \\frac{\\|\\Delta_{1}(t, x)\\|_{2}}{\\|\\Delta_{2}(t, x)\\|_{2}}.\n$$\n如果分母安全地非零，并且与形式预测 $s^{p_{\\mathrm{formal}}}$ 的相对偏差在容差 $\\tau$ 之内，则声明点 $(t, x)$ 处于渐近区域：\n$$\n\\|\\Delta_{2}(t, x)\\|_{2} > \\varepsilon \\quad \\text{and} \\quad \\frac{\\big|R(t, x) - s^{p_{\\mathrm{formal}}}\\big|}{s^{p_{\\mathrm{formal}}}} \\le \\tau.\n$$\n对于每个指定时间，计算满足该判据的空间点 $x$ 的分数（一个无单位的浮点数）。每个测试用例的最终输出是一个列表 $\\big[f_{\\mathrm{pre}}, f_{\\mathrm{merge}}, f_{\\mathrm{post}}\\big]$，其中每个条目分别是 $t_{\\mathrm{pre}}$、$t_{\\mathrm{merge}}$ 和 $t_{\\mathrm{post}}$ 时刻的分数。\n\n实现细节和使用的常数：\n- 在 $x \\in [-X_{\\max}, X_{\\max}]$ 上使用一个包含 $N_{x}$ 个点的均匀网格。\n- 使用 $x_{0} = 0$。\n- 使用 $h = 1$ 作为误差缩放的基础间距参数，然后使用 $h/s$ 和 $h/s^{2}$ 作为加密后的间距。\n- 使用一个安全阈值 $\\varepsilon$ 进行分母测试。\n- 时间和空间以 $M$ 的倍数衡量；输出是无量纲的分数。\n\n您的程序必须实现上述模型，并为以下测试套件计算所要求的分数，每个都是一个独立的案例：\n\n- 案例1（通用正常路径，在并合附近有阶数退化）：$s = 1.2$, $p_{\\mathrm{formal}} = 4$, $p_{\\mathrm{degrade}} = 2$, $\\theta = 0.6$, $\\gamma = 0.0$, $t_{\\mathrm{merge}} = 50$, $t_{\\mathrm{pre}} = 30$, $t_{\\mathrm{post}} = 70$, $\\sigma_{t} = 10$, $f_{0} = 0.02$, $\\alpha = 8\\times 10^{-4}$, $\\beta = 5\\times 10^{-5}$, $X_{\\max} = 50$, $\\sigma_{x} = 20$, $N_{x} = 501$, $\\varepsilon = 10^{-12}$, $\\tau = 0.05$。\n- 案例2（边界情况，形式阶和实际阶处处匹配）：$s = 1.2$, $p_{\\mathrm{formal}} = 2$, $p_{\\mathrm{degrade}} = 2$, $\\theta = 0.6$, $\\gamma = 0.0$, $t_{\\mathrm{merge}} = 50$, $t_{\\mathrm{pre}} = 30$, $t_{\\mathrm{post}} = 70$, $\\sigma_{t} = 10$, $f_{0} = 0.02$, $\\alpha = 8\\times 10^{-4}$, $\\beta = 5\\times 10^{-5}$, $X_{\\max} = 50$, $\\sigma_{x} = 20$, $N_{x} = 501$, $\\varepsilon = 10^{-12}$, $\\tau = 0.05$。\n- 案例3（严格容差，带混合阶次主导误差）：$s = 1.2$, $p_{\\mathrm{formal}} = 4$, $p_{\\mathrm{degrade}} = 4$, $\\theta = 0.6$, $\\gamma = 0.15$, $t_{\\mathrm{merge}} = 50$, $t_{\\mathrm{pre}} = 30$, $t_{\\mathrm{post}} = 70$, $\\sigma_{t} = 10$, $f_{0} = 0.02$, $\\alpha = 8\\times 10^{-4}$, $\\beta = 5\\times 10^{-5}$, $X_{\\max} = 50$, $\\sigma_{x} = 20$, $N_{x} = 501$, $\\varepsilon = 10^{-12}$, $\\tau = 0.02$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果，其中每个条目对应一个测试用例，并且其本身是按 $\\big[f_{\\mathrm{pre}}, f_{\\mathrm{merge}}, f_{\\mathrm{post}}\\big]$ 顺序排列的三个浮点数的列表。例如，格式必须完全像 $[[r_{11}, r_{12}, r_{13}],[r_{21}, r_{22}, r_{23}],[r_{31}, r_{32}, r_{33}]]$，不得有任何附加文本。",
            "solution": "用户提供了一个需要通过分析合成数据来验证数值相对论代码的问题。我将首先验证问题陈述本身，然后着手构建一个解决方案。\n\n### 步骤1：问题验证\n\n该问题要求在旨在模拟双黑洞并合引力波信号的合成数据上实现一个特定的数值分析程序。我将根据既定标准验证该问题的有效性。\n\n-   **提取的已知条件**：\n    -   **物理模型**：几何单位制（$G=c=1$）下的双黑洞并合。\n    -   **数值格式**：形式阶为 $p$ 的有限差分，截断误差与 $C h^p$ 成比例。\n    -   **变量**：每个时空点 $(t, x)$ 处的矢量 $\\mathbf{u} = (h_{+}, h_{\\times}, \\psi)$。\n    -   **分辨率**：对应于抽象误差参数 $h_1=1$, $h_2=1/s$, $h_3=1/s^2$ 的三层分辨率。\n    -   **精确场**：提供了函数 $h_{+}^{\\mathrm{exact}}(t,x)$、$h_{\\times}^{\\mathrm{exact}}(t,x)$ 和 $\\psi^{\\mathrm{exact}}(t,x)$，它们基于包络 $A(t)$ 和相位 $\\Phi(t)$。所有参数和函数形式都已明确定义。\n    -   **合成数据模型**：通过向精确解添加受控误差项来生成合成数值解 $u_h(t,x)$：$u^{(v)}_{h} = u^{(v)}_{\\mathrm{exact}} + C_{v} h^{p_{\\mathrm{actual}}} + \\gamma D_{v} h^{q}$。误差系数 $C_v, D_v$ 和有效阶 $p_{\\mathrm{actual}}$ 都有精确定义。\n    -   **收敛性分析**：计算比率 $R(t, x) = \\|\\Delta_{1}\\|_{2} / \\|\\Delta_{2}\\|_{2}$，其中 $\\Delta_1$ 和 $\\Delta_2$ 是变量矢量 $\\mathbf{u}$ 的分辨率间差异。\n    -   **渐近区域判据**：如果 $\\|\\Delta_{2}(t, x)\\|_{2} > \\varepsilon$ 且 $|R(t, x) - s^{p_{\\mathrm{formal}}}| / s^{p_{\\mathrm{formal}}} \\le \\tau$，则认为时空点 $(t,x)$ 处于渐近区域。\n    -   **任务**：对于三个特定时间点（$t_{\\mathrm{pre}}, t_{\\mathrm{merge}}, t_{\\mathrm{post}}$），计算满足该判据的空间点的比例。\n    -   **常数和参数**：为三个不同的测试用例提供了所有必要的数值，包括加密因子 $s$、阶数 $p_{\\mathrm{formal}}, p_{\\mathrm{degrade}}$、阈值 $\\theta, \\varepsilon, \\tau$、次主导误差因子 $\\gamma$、域参数 $X_{\\max}, N_x, x_0$ 以及场参数 $\\sigma_t, \\sigma_x, f_0, \\alpha, \\beta$。\n\n-   **验证结论**：\n    1.  **科学合理性**：问题在科学上是合理的。它使用了数值分析中的既定概念（收敛阶、截断误差），并将其应用于引力波、数值相对论等这类测试是标准做法的领域。使用具有已知属性（一个“精确”解加上受控误差）的合成数据是计算科学中验证和确认的基石。\n    2.  **形式化能力与相关性**：该问题高度形式化，所有组件都由精确的数学表达式定义。它与数值相对论中代码验证这一特定主题直接相关。\n    3.  **完整性与一致性**：问题是自洽和完整的。为每个测试用例提供了所有必要的数据、函数和参数。设置中没有矛盾。\n    4.  **可行性**：该模型是一个模拟，参数在数值计算的合理范围内。任务在计算上是可行的。\n    5.  **适定性**：问题是适定的。说明导致了每个测试用例的唯一、确定性结果。术语是明确的。\n    6.  **平凡性**：问题并非平凡，因为它需要仔细实现多个数学公式和逻辑条件。它代表了计算验证方面一个有意义的练习。\n    7.  **可验证性**：该问题可以通过独立实现所述算法来完全验证。\n\n-   **结论**：问题陈述有效。我将继续生成解决方案。\n\n### 步骤2：解决方案设计\n\n解决方案将是对所述模型的直接实现。算法的核心涉及遍历一组测试用例。对于每个用例，它会遍历三个指定的时间点。在每个时间点，它会为一维空间网格上的所有点计算所需的量。使用 NumPy 库是高效地在空间点数组上执行这些计算的理想选择。\n\n对于单个测试用例在单个时间 $t$ 的逻辑流程如下：\n1.  在 $[-X_{\\max}, X_{\\max}]$ 上定义包含 $N_x$ 个点的空间网格 $x$。\n2.  计算依赖于时间的量：包络 $A(t)$、相位 $\\Phi(t)$ 和实际收敛阶 $p_{\\mathrm{actual}}(t)$。后者通过将 $A(t)$ 与阈值 $\\theta$ 进行比较来确定。\n3.  在给定时间 $t$，计算作为 $x$ 的函数的精确场 $h_{+}^{\\mathrm{exact}}$、$h_{\\times}^{\\mathrm{exact}}$ 和 $\\psi^{\\mathrm{exact}}$。这些是矢量（数组）量。\n4.  在时间 $t$，计算作为 $x$ 的函数的误差振幅场 $C_{+}$、$C_{\\times}$ 和 $C_{\\psi}$。次主导误差振幅 $D_v$ 与 $C_v$ 成正比。\n5.  定义三个分辨率参数 $h_1=1$、$h_2=1/s$ 和 $h_3=1/s^2$。\n6.  对于每个变量 $v \\in \\{+, \\times, \\psi\\}$，通过将指定的误差项添加到精确解中，构建三个合成数值解 $u^{(v)}_{h_1}, u^{(v)}_{h_2}, u^{(v)}_{h_3}$。\n7.  计算差分矢量。对于每个空间点 $x_i$，$\\Delta_1(t, x_i) = (u^{(+)}_{h_1} - u^{(+)}_{h_2}, u^{(\\times)}_{h_1} - u^{(\\times)}_{h_2}, u^{(\\psi)}_{h_1} - u^{(\\psi)}_{h_2})_i$，并类似地使用分辨率 $h_2$ 和 $h_3$ 计算 $\\Delta_2(t, x_i)$。\n8.  对于每个空间点，计算跨变量的欧几里得范数 $\\|\\Delta_1(t, x)\\|_2$ 和 $\\|\\Delta_2(t, x)\\|_2$。这将产生两个长度为 $N_x$ 的数组。\n9.  计算比率 $R(t, x) = \\|\\Delta_1(t, x)\\|_2 / \\|\\Delta_2(t, x)\\|_2$。\n10. 在每个空间点应用渐近区域判据：\n    a. 检查是否 $\\|\\Delta_2(t, x)\\|_2 > \\varepsilon$。\n    b. 对于满足(a)的点，检查相对偏差 $|R(t, x) - s^{p_{\\mathrm{formal}}}|/s^{p_{\\mathrm{formal}}} \\le \\tau$。\n11. 统计同时满足这两个条件的空间点的数量。\n12. 时间 $t$ 的结果是这个计数除以总点数 $N_x$。\n\n对三个时间（$t_{\\mathrm{pre}}, t_{\\mathrm{merge}}, t_{\\mathrm{post}}$）中的每一个重复此过程，以生成该测试用例的三个分数的列表。最终输出汇总了所有三个测试用例的这些列表。\n\n让我们简要分析一下预期的结果：\n-   **案例1**：$p_{\\mathrm{formal}}=4$, $p_{\\mathrm{degrade}}=2$。在 $t_{\\text{pre/post}}$ 时，$p_{\\mathrm{actual}}=4$，所以测量的比率 $R$ 应该是 $s^4$，与形式预测相匹配。在 $t_{\\text{merge}}$ 时，$p_{\\mathrm{actual}}=2$，所以 $R=s^2$，这与 $s^4$ 有显著偏离。我们预期分数接近 [1.0, 0.0, 1.0]。\n-   **案例2**：$p_{\\mathrm{formal}}=2$, $p_{\\mathrm{degrade}}=2$。实际阶 $p_{\\mathrm{actual}}$ 始终为 $2$。比率 $R$ 将始终是 $s^2$，与形式预测 $s^2$ 相匹配。我们预期分数接近 [1.0, 1.0, 1.0]。\n-   **案例3**：$p_{\\mathrm{formal}}=4$, $p_{\\mathrm{degrade}}=4$。实际阶 $p_{\\mathrm{actual}}$ 始终为 $4$。但是，包含了一个 $\\gamma=0.15$ 的次主导误差项。这将导致比率 $R$ 与理想的 $s^4$ 略有偏差。初步计算表明，这种偏差在指定的容差 $\\tau=0.02$ 之内。我们预期分数接近 [1.0, 1.0, 1.0]。\n\n实现将遵循此逻辑，使用 NumPy 进行矢量化计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of validating a numerical relativity code using synthetic data.\n    Computes the fraction of spatial points in the asymptotic regime for three test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: general happy path with degradation near merger\n        {'s': 1.2, 'p_formal': 4, 'p_degrade': 2, 'theta': 0.6, 'gamma': 0.0,\n         't_merge': 50, 't_pre': 30, 't_post': 70, 'sigma_t': 10, 'f0': 0.02,\n         'alpha': 8e-4, 'beta': 5e-5, 'X_max': 50, 'sigma_x': 20, 'N_x': 501,\n         'epsilon': 1e-12, 'tau': 0.05, 'x0': 0},\n        # Case 2: edge case where formal and actual orders match everywhere\n        {'s': 1.2, 'p_formal': 2, 'p_degrade': 2, 'theta': 0.6, 'gamma': 0.0,\n         't_merge': 50, 't_pre': 30, 't_post': 70, 'sigma_t': 10, 'f0': 0.02,\n         'alpha': 8e-4, 'beta': 5e-5, 'X_max': 50, 'sigma_x': 20, 'N_x': 501,\n         'epsilon': 1e-12, 'tau': 0.05, 'x0': 0},\n        # Case 3: strict tolerance with mixed-order subdominant errors\n        {'s': 1.2, 'p_formal': 4, 'p_degrade': 4, 'theta': 0.6, 'gamma': 0.15,\n         't_merge': 50, 't_pre': 30, 't_post': 70, 'sigma_t': 10, 'f0': 0.02,\n         'alpha': 8e-4, 'beta': 5e-5, 'X_max': 50, 'sigma_x': 20, 'N_x': 501,\n         'epsilon': 1e-12, 'tau': 0.02, 'x0': 0}\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Unpack parameters for the current test case\n        s, p_formal, p_degrade, theta, gamma = case['s'], case['p_formal'], case['p_degrade'], case['theta'], case['gamma']\n        t_merge, sigma_t = case['t_merge'], case['sigma_t']\n        f0, alpha, beta = case['f0'], case['alpha'], case['beta']\n        X_max, sigma_x, N_x, x0 = case['X_max'], case['sigma_x'], case['N_x'], case['x0']\n        epsilon, tau = case['epsilon'], case['tau']\n        \n        times = [case['t_pre'], case['t_merge'], case['t_post']]\n\n        # Spatial grid\n        x = np.linspace(-X_max, X_max, N_x)\n        \n        # Resolutions based on the abstract error parameter h=1\n        resolutions_h = [1.0, 1.0 / s, 1.0 / s**2]\n        \n        case_fractions = []\n\n        for t in times:\n            # Calculate time-dependent components\n            A_t = np.exp(-(t - t_merge)**2 / (2 * sigma_t**2))\n            dt = t - t_merge\n            Phi_t = 2 * np.pi * (f0 * t + 0.5 * alpha * dt**2 + beta / 3 * dt**3)\n            \n            p_actual = p_degrade if A_t >= theta else p_formal\n            q = p_formal + 1\n\n            # Calculate spatially-dependent components\n            spatial_gauss_1 = np.exp(-(x - x0)**2 / (2 * sigma_x**2))\n            spatial_gauss_2 = np.exp(-(x - x0)**2 / (sigma_x**2))\n\n            # Define exact fields\n            u_exact = {\n                '+': A_t * np.cos(Phi_t) * spatial_gauss_1,\n                'x': A_t * np.sin(Phi_t) * spatial_gauss_1,\n                'psi': A_t * np.cos(2 * Phi_t + np.pi / 4) * spatial_gauss_2,\n            }\n\n            # Define error amplitudes\n            C_plus = A_t * (1 + 0.3 * np.cos(Phi_t)) * spatial_gauss_1\n            C_v = {\n                '+': C_plus,\n                'x': 1.1 * C_plus,\n                'psi': 0.9 * C_plus,\n            }\n            D_v = {v: 0.5 * C_v[v] for v in C_v}\n\n            # Generate synthetic data for all variables and resolutions\n            u_solutions = {}\n            for v in ['+', 'x', 'psi']:\n                u_solutions[v] = [\n                    u_exact[v] + C_v[v] * h**p_actual + gamma * D_v[v] * h**q\n                    for h in resolutions_h\n                ]\n\n            # Calculate inter-resolution differences\n            diff1 = {v: u_solutions[v][0] - u_solutions[v][1] for v in u_solutions}\n            diff2 = {v: u_solutions[v][1] - u_solutions[v][2] for v in u_solutions}\n\n            # Calculate Euclidean norms of the difference vectors\n            norm_delta1 = np.sqrt(sum(d**2 for d in diff1.values()))\n            norm_delta2 = np.sqrt(sum(d**2 for d in diff2.values()))\n\n            # Calculate the ratio R, handling potential division by zero\n            with np.errstate(divide='ignore', invalid='ignore'):\n                R = norm_delta1 / norm_delta2\n                # Resulting NaNs or Infs will be handled by the criterion logic.\n            \n            # Apply the asymptotic regime criterion\n            s_p_formal = s**p_formal\n            \n            # 1. Denominator must be non-zero (greater than a small epsilon)\n            valid_denominator_mask = norm_delta2 > epsilon\n            \n            # Initialize all points as not satisfying the criterion\n            asymptotic_mask = np.full(N_x, False)\n            \n            # 2. On points with a valid denominator, check the ratio condition\n            if np.any(valid_denominator_mask):\n                relative_deviation = np.abs(R[valid_denominator_mask] - s_p_formal) / s_p_formal\n                asymptotic_mask[valid_denominator_mask] = (relative_deviation = tau)\n            \n            # Calculate the fraction of points satisfying the full criterion\n            asymptotic_count = np.sum(asymptotic_mask)\n            fraction = asymptotic_count / N_x\n            case_fractions.append(fraction)\n            \n        all_results.append(case_fractions)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\".replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "科学计算代码是不断演化的，代码重构和优化是开发过程中的常态。然而，如何确保这些改动不会无意中引入错误或改变模拟的物理结果呢？本练习聚焦于代码验证中的一个关键方面：通过回归测试来确保数值等价性 。你将实现一个波动方程的两个功能等价的求解器，并通过一系列严格的测试——包括比较最终解、能量“校验和”以及收敛阶数——来验证重构后的代码是否在浮点误差容忍范围内保持了数值一致性。这项实践对于培养严谨的科学软件工程素养至关重要，是确保长期项目代码质量和可维护性的基石。",
            "id": "3470480",
            "problem": "要求您验证一个重构后的数值实现，对于数值相对论和引力波中的标准化问题，是否在解值和收敛行为方面保持数值等价性。标准化问题将在无量纲单位下求解，所有报告的量均为无量纲。您的程序必须为一维线性化引力波方程（由带周期性边界条件的标量波动方程建模）构建两个功能等价的求解器，计算指定参数集的解，并使用校验和与收敛率在指定容差范围内评估等价性。最终输出必须是单行，包含一个方括号括起来的逗号分隔的布尔值列表，其中每个布尔值对应一个测试用例，并指明重构是否在规定容差下保持了数值等价性。\n\n基本原理：\n- 标量波动方程 $$u_{tt} = c^2 u_{xx},$$ 用于模拟平直时空中的线性化引力波，其中 $u$ 是度规扰动分量（例如，“正”偏振），$c$ 是特征波速，$t$ 是时间，$x$ 是空间坐标。初始数据为 $u(x,0)$ 和 $u_t(x,0)$，解在周期性定义域 $x \\in [0,L]$ 上求解。\n- 数值分析意义下的收敛性测试评估数值误差 $\\|e_h\\|$ 是否随网格间距 $h$ 的减小而减小，其减小率与方法的格式阶 $p$ 一致，其中 $$p \\approx \\frac{\\log\\left(\\|e_{h_1}\\|/\\|e_{h_2}\\|\\right)}{\\log\\left(h_1/h_2\\right)}.$$\n- 通过校验和进行验证，使用一个不变量或近不变量的诊断量（此处为离散的类能量）来检测数值行为中非预期的变化。\n\n您的程序必须：\n1. 为 $$u_{tt} = c^2 u_{xx}$$ 在均匀周期性网格上实现两个数学上等价的二阶显式有限差分解法器。两个求解器都使用空间二阶中心差分和二阶精度时间步进法来推进离散解。一个求解器代表“原始”代码，第二个代表“重构”代码，后者重组了代数运算，但意图在数值上是等价的。\n2. 对于每个标准化问题，在多个网格分辨率 $N$ 上计算最终时间 $T$ 的数值解，对照解析解评估误差，并使用连续的网格加密来估计观测收敛阶 $p$。\n3. 在最终时间使用离散能量泛函 $$E = \\sum_i \\frac{1}{2}\\left( v_i^2 + c^2 (\\partial_x u_i)^2 \\right)\\Delta x,$$ 计算一个校验和诊断量，其中 $v_i$ 是网格点 $i$ 处 $u_t$ 的离散近似，$(\\partial_x u_i)$ 是 $u_x$ 的离散近似。\n4. 如果一个测试用例满足以下所有条件，则声明重构保持了数值等价性：\n   - 在最精细分辨率下，原始解法器和重构解法器的最终数组之间的相对 $\\ell^2$ 差异满足 $$\\frac{\\|u^{\\text{orig}} - u^{\\text{ref}}\\|_2}{\\|u^{\\text{orig}}\\|_2} \\le \\epsilon_{\\text{arr}},$$ 其中 $$\\epsilon_{\\text{arr}} = 10^{-12}.$$\n   - 在最精细分辨率下，校验和之间的相对差异满足 $$\\frac{|E^{\\text{orig}} - E^{\\text{ref}}|}{\\max\\left(|E^{\\text{orig}}|,|E^{\\text{ref}}|\\right)} \\le \\epsilon_{\\text{chk}},$$ 其中 $$\\epsilon_{\\text{chk}} = 10^{-10}.$$\n   - 原始解法器和重构解法器的观测收敛阶都与目标值 $$p^\\ast = 2$$ 的差距在 $$|p - p^\\ast| \\le 0.2$$ 以内，并且它们之间的差满足 $$|p^{\\text{orig}} - p^{\\text{ref}}| \\le 0.05.$$\n\n离散格式要求：\n- 使用均匀网格 $$x_i = i\\Delta x,$$，其中 $$i = 0,1,\\dots,N-1,$$ 且 $$\\Delta x = L/N.$$ 施加周期性边界条件，使得索引按模 $$N$$ 回绕。\n- 使用 Courant–Friedrichs–Lewy (CFL) 条件定义时间步长 $$\\Delta t$$。令 $$\\lambda = c\\Delta t/\\Delta x$$ 为测试套件中指定的CFL因子。为确保恰好在最终时间 $$T$$ 结束，选择 $$n_{\\text{steps}} = \\text{round}(T/\\Delta t),$$ 然后重置 $$\\Delta t \\leftarrow T/n_{\\text{steps}}.$$\n- 初始化 $$u^0 = u(x,0),$$ $$v^0 = u_t(x,0),$$ 并使用二阶泰勒展开计算 $$u^1$$：$$u^1 = u^0 + \\Delta t\\, v^0 + \\tfrac{1}{2}\\Delta t^2\\, c^2\\, D_{xx} u^0,$$，其中 $$D_{xx}$$ 是标准的二阶周期性离散拉普拉斯算子。然后使用显式二阶中心格式进行推进：$$u^{n+1} = 2u^n - u^{n-1} + (c\\Delta t)^2 D_{xx}u^n.$$\n- 在最终时间层 $$n,$$ 使用中心时间差分计算 $$v^n$$：$$v^n = \\frac{u^{n+1} - u^{n-1}}{2\\Delta t},$$，其中 $$u^{n+1}$$ 是从更新公式中代数求解得到的，而不推进存储的状态。使用标准的二阶周期性中心差分计算 $$\\partial_x u^n$$。\n\n带解析解的标准化问题：\n- 在 $$[0,L]$$ 上的单色平面波，带周期性边界条件：\n  - 振幅为 $$A$$、波数为 $$k$$、频率为 $$\\omega = ck$$ 的解析解是 $$u(x,t) = A\\sin(kx - \\omega t).$$ 初始条件是 $$u(x,0) = A\\sin(kx)$$ 和 $$u_t(x,0) = -\\omega A\\cos(kx).$$\n- 使用达朗贝尔解的零初始速度高斯脉冲：\n  - 令 $$f(x) = A\\exp\\left(-\\frac{d(x,x_0)^2}{2\\sigma^2}\\right),$$ 其中 $$d(x,x_0)$$ 是在 $$[0,L]$$ 上的最小周期距离。解析解是 $$u(x,t) = \\tfrac{1}{2}\\left(f(x-ct) + f(x+ct)\\right).$$ 初始条件是 $$u(x,0) = f(x)$$ 和 $$u_t(x,0) = 0.$$\n\n误差与收敛：\n- 对于测试用例中的每个分辨率 $$N$$，计算数值解 $$u_h(T)$$ 和解析解 $$u_{\\text{exact}}(T).$$ 离散误差在 $\\ell^2$ 范数下度量：$$\\|e_h\\|_2 = \\sqrt{\\sum_i \\left(u_h(x_i,T) - u_{\\text{exact}}(x_i,T)\\right)^2 \\Delta x}.$$ 通过对连续的网格加密应用对数比率公式来估计观测阶 $$p$$。\n\n测试套件：\n- 测试用例 1 (理想路径): 平面波，参数为 $$A = 1,$$ $$L = 1,$$ $$c = 1,$$ $$T = 1,$$ $$k = 2\\pi$$, $$\\omega = c k,$$ 网格尺寸 $$N \\in \\{64,128,256\\},$$ CFL因子 $$\\lambda = 0.9.$$\n- 测试用例 2 (接近CFL边缘): 高斯脉冲，参数为 $$A = 1,$$ $$L = 1,$$ $$c = 1,$$ $$T = 0.5,$$ $$x_0 = 0.25L,$$ $$\\sigma = 0.05L,$$ 网格尺寸 $$N \\in \\{64,128,256\\},$$ CFL因子 $$\\lambda = 0.999.$$\n- 测试用例 3 (粗网格边界): 平面波，参数为 $$A = 1,$$ $$L = 1,$$ $$c = 1,$$ $$T = 0.5,$$ $$k = 2\\pi,$$ $$\\omega = c k,$$ 网格尺寸 $$N \\in \\{16,32,64\\},$$ CFL因子 $$\\lambda = 0.9.$$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，格式为 $$[b_1,b_2,b_3],$$，其中每个 $$b_j$$ 是一个布尔值，表示测试用例 $$j$$ 是否在指定容差下保持了数值等价性。",
            "solution": "我们从周期性定义域 $$x \\in [0,L]$$ 上的标量波动方程 $$u_{tt} = c^2 u_{xx}$$ 开始。该方程是 Minkowski 时空中线性化引力波的一个经过充分检验的模型，其中度规扰动分量遵循一个特征速度为 $$c$$ 的波动方程。为了进行数值验证，我们通过检查离散解及其收敛行为是否在严格的容差范围内保持不变，来检验一次重构是否保持了数值等价性。\n\n离散化原理：我们使用一个均匀网格 $$x_i = i\\Delta x$$，其中 $$\\Delta x = L/N$$，并采用周期性边界条件，因此索引按模 $$N$$ 计算。对于时间积分，我们采用一个从泰勒展开和方程本身推导出的二阶中心格式。\n\n二阶精度的初始化构造如下。给定初始数据 $$u(x,0) = u^0(x)$$ 和 $$u_t(x,0) = v^0(x),$$ 我们构建离散向量 $$u^0_i = u^0(x_i),$$ $$v^0_i = v^0(x_i).$$ 离散拉普拉斯算子 $$D_{xx}$$ 定义为\n$$\n(D_{xx} u)_i = \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2},\n$$\n带周期性回绕。使用时间上的泰勒展开以及 $$u_{tt}(x,0) = c^2 u_{xx}(x,0),$$ 我们得到\n$$\nu^1 = u^0 + \\Delta t\\, v^0 + \\tfrac{1}{2}\\Delta t^2 c^2 D_{xx}u^0.\n$$\n对于 $$n \\ge 1,$$ 更新采用标准的二阶中心格式\n$$\nu^{n+1} = 2u^n - u^{n-1} + (c\\Delta t)^2 D_{xx}u^n.\n$$\n该格式与波动方程是一致的，并满足 Courant–Friedrichs–Lewy (CFL) 条件，其因子 $$\\lambda = c\\Delta t/\\Delta x \\le 1.$$ 为确保恰好在最终时间 $$T$$ 结束，我们计算 $$n_{\\text{steps}} = \\text{round}(T/\\Delta t)$$ 并重置 $$\\Delta t = T/n_{\\text{steps}}.$$\n\n重构与数值等价性：“原始”求解器在一个向量化表达式中计算更新。 “重构”求解器计算相同的更新，但在代数上重排了离散拉普拉斯算子的计算，并将更新分解为中间数组。在精确算术中，这两者是相同的，因为实数域上的加法和标量乘法满足结合律和交换律，且 $$D_{xx}$$ 是线性的。在浮点算术中，重排会改变机器精度级别的舍入误差。因此，数值等价性不是通过完全相同来确立的，而是通过对诊断量的严格容差来确立，对于正确重构的代码，这些诊断量必须一致。\n\n诊断量：\n1. 最终状态数组的邻近度。我们测量最精细分辨率下最终数组之间的相对 $\\ell^2$ 差异：\n$$\n\\delta_{\\text{arr}} = \\frac{\\|u^{\\text{orig}} - u^{\\text{ref}}\\|_2}{\\|u^{\\text{orig}}\\|_2},\n\\quad\n\\|w\\|_2 = \\sqrt{\\sum_i w_i^2 \\Delta x}.\n$$\n我们要求 $$\\delta_{\\text{arr}} \\le \\epsilon_{\\text{arr}}$$，其中 $$\\epsilon_{\\text{arr}} = 10^{-12},$$ 这比机器精度大得多，但又足够小以检测非预期的变化。\n\n2. 通过离散能量计算校验和。离散梯度定义为\n$$\n(\\partial_x u)_i = \\frac{u_{i+1} - u_{i-1}}{2\\Delta x}.\n$$\n在最终时间层 $$n,$$ 通过代数方式从更新公式中计算 $$u^{n+1}$$ 以避免改变存储状态，然后使用中心时间差分\n$$\nv^n = \\frac{u^{n+1} - u^{n-1}}{2\\Delta t}.\n$$\n定义类能量校验和\n$$\nE = \\sum_i \\frac{1}{2}\\left( (v^n_i)^2 + c^2 \\left((\\partial_x u^n)_i\\right)^2 \\right)\\Delta x.\n$$\n我们要求原始代码和重构代码所得能量之间的相对差异满足\n$$\n\\frac{|E^{\\text{orig}} - E^{\\text{ref}}|}{\\max(|E^{\\text{orig}}|,|E^{\\text{ref}}|)} \\le \\epsilon_{\\text{chk}},\n\\quad\n\\epsilon_{\\text{chk}} = 10^{-10}.\n$$\n\n3. 收敛行为。对于每个分辨率 $$N,$$ 我们计算在 $$T$$ 时的离散误差：\n$$\n\\|e_h\\|_2 = \\sqrt{\\sum_i \\left(u_h(x_i,T) - u_{\\text{exact}}(x_i,T)\\right)^2 \\Delta x},\n\\quad h = \\Delta x.\n$$\n对于连续的加密 $$h_1  h_2,$$ 观测阶通过以下公式计算\n$$\np = \\frac{\\log(\\|e_{h_1}\\|_2/\\|e_{h_2}\\|_2)}{\\log(h_1/h_2)}.\n$$\n我们对连续的网格对进行汇总，为每个求解器生成一个代表性的 $$p$$。我们要求 $$p^{\\text{orig}}$$ 和 $$p^{\\text{ref}}$$ 都位于 $$p^\\ast = 2$$ 的 $$|p - p^\\ast| \\le 0.2$$ 范围内，并且它们之间的差满足 $$|p^{\\text{orig}} - p^{\\text{ref}}| \\le 0.05.$$\n\n标准化问题的解析解：\n- 平面波：$$u(x,t) = A\\sin(kx - \\omega t),\\quad \\omega = ck.$$\n初始数据为 $$u(x,0) = A\\sin(kx),\\quad u_t(x,0) = -\\omega A\\cos(kx).$$\n- 具有零初始速度和通过最小距离 $$d(x,x_0)$$ 进行周期性包裹的高斯脉冲：\n$$\nf(x) = A\\exp\\left(-\\frac{d(x,x_0)^2}{2\\sigma^2}\\right),\n\\quad\nu(x,t) = \\tfrac{1}{2}\\left(f(x-ct) + f(x+ct)\\right),\n\\quad\nu_t(x,0) = 0.\n$$\n\n第一性原理证明：该格式通过在空间和时间上一致的二阶离散化直接从波动方程导出。周期性离散算子是线性的，并模仿了连续介质中的导数。类能量校验和的动机源于波动方程的哈密顿结构，其中 $$\\int \\tfrac{1}{2}(u_t^2 + c^2 u_x^2)\\,dx$$ 在连续情况下是守恒的；在离散情况下，它作为一个稳健的诊断量，对相移不敏感，但对系统性漂移敏感。对于光滑解，二阶方法预期会以 $$p \\approx 2$$ 的阶收敛；平面波和高斯脉冲满足光滑性要求。因此，如果重构保留了更新和初始化的代数运算，则差异必须受限于浮点舍入误差，并且诊断量必须在严格的容差范围内匹配。该程序通过计算两个版本、测量差异并确认预期阶数来体现这一原则。\n\n测试套件覆盖范围：\n- 测试用例 1 验证了远离 CFL 极限的光滑周期解的理想路径。\n- 测试用例 2 探测了在稳定性边界附近（$$\\lambda = 0.999$$）的数值行为，确保在紧凑的时间步长下等价性的稳健性。\n- 测试用例 3 强调了粗离散化，以验证即使在较大的 $$\\Delta x$$ 下，观测到的阶数和校验和也保持一致。\n\n最终输出必须是严格格式为 $$[b_1,b_2,b_3]$$ 的单行，包含三个布尔值。每个 $$b_j$$ 为真的条件是当且仅当测试用例 $$j$$ 满足所有三个标准（数组邻近度、校验和差异和收敛阶一致性）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dxx_periodic(u, dx):\n    # Second-order periodic discrete Laplacian\n    return (np.roll(u, -1) - 2.0*u + np.roll(u, 1)) / (dx*dx)\n\ndef dx_periodic(u, dx):\n    # Second-order periodic central difference gradient\n    return (np.roll(u, -1) - np.roll(u, 1)) / (2.0*dx)\n\ndef plane_wave_initial(x, A, k, omega):\n    u0 = A * np.sin(k * x)\n    v0 = -omega * A * np.cos(k * x)\n    return u0, v0\n\ndef plane_wave_exact(x, A, k, omega, t):\n    return A * np.sin(k * x - omega * t)\n\ndef periodic_distance(x, x0, L):\n    # Minimal periodic distance on [0,L]\n    d = (x - x0 + L/2.0) % L - L/2.0\n    return d\n\ndef gaussian_f_periodic(x, A, x0, sigma, L):\n    d = periodic_distance(x, x0, L)\n    return A * np.exp(-(d*d) / (2.0 * sigma * sigma))\n\ndef gaussian_exact_u(x, A, x0, sigma, L, c, t):\n    # d'Alembert with periodic wrap using minimal periodic distance\n    return 0.5 * (gaussian_f_periodic((x - c*t) % L, A, x0, sigma, L) +\n                  gaussian_f_periodic((x + c*t) % L, A, x0, sigma, L))\n\ndef initialize_u1(u0, v0, c, dt, dx):\n    return u0 + dt * v0 + 0.5 * (c * c) * (dt * dt) * dxx_periodic(u0, dx)\n\ndef advance_original(u0, v0, c, L, N, CFL, T):\n    # Grid and time step\n    dx = L / N\n    dt = CFL * dx / c\n    nsteps = int(round(T / dt))\n    dt = T / nsteps  # Adjust to hit final time exactly\n    # Initialize\n    u_prev = u0.copy()\n    u_curr = initialize_u1(u0, v0, c, dt, dx)\n    # Time stepping\n    for _ in range(1, nsteps):\n        # Single-expression update\n        u_next = 2.0 * u_curr - u_prev + (c * dt) ** 2 * dxx_periodic(u_curr, dx)\n        u_prev, u_curr = u_curr, u_next\n    # Compute v at final time using centered time difference (predict u_next)\n    u_next_pred = 2.0 * u_curr - u_prev + (c * dt) ** 2 * dxx_periodic(u_curr, dx)\n    v_final = (u_next_pred - u_prev) / (2.0 * dt)\n    return u_curr, v_final, dx, dt\n\ndef advance_refactored(u0, v0, c, L, N, CFL, T):\n    # Grid and time step\n    dx = L / N\n    dt = CFL * dx / c\n    nsteps = int(round(T / dt))\n    dt = T / nsteps  # Adjust to hit final time exactly\n    # Initialize\n    u_prev = u0.copy()\n    # Refactored: compute Laplacian separately and reuse\n    lap_u0 = dxx_periodic(u0, dx)\n    u_curr = u0 + dt * v0 + 0.5 * (c * c) * (dt * dt) * lap_u0\n    # Time stepping\n    for _ in range(1, nsteps):\n        lap = dxx_periodic(u_curr, dx)\n        term = (c * dt) ** 2 * lap\n        u_next = (2.0 * u_curr + term) - u_prev  # Reordered update\n        # Rotate state\n        u_prev, u_curr = u_curr, u_next\n    # Compute v at final time using centered time difference (predict u_next)\n    lap_final = dxx_periodic(u_curr, dx)\n    u_next_pred = (2.0 * u_curr + (c * dt) ** 2 * lap_final) - u_prev\n    v_final = (u_next_pred - u_prev) / (2.0 * dt)\n    return u_curr, v_final, dx, dt\n\ndef energy_checksum(u, v, c, dx):\n    grad = dx_periodic(u, dx)\n    return 0.5 * np.sum(v*v + (c*c) * grad*grad) * dx\n\ndef l2_error(u_num, u_exact, dx):\n    diff = u_num - u_exact\n    return np.sqrt(np.sum(diff*diff) * dx)\n\ndef observed_order(errors, hs):\n    # Compute p across successive pairs and average\n    ps = []\n    for i in range(len(errors) - 1):\n        e1, e2 = errors[i], errors[i+1]\n        h1, h2 = hs[i], hs[i+1]\n        if e1 > 0 and e2 > 0:\n            ps.append(np.log(e1/e2) / np.log(h1/h2))\n    if len(ps) == 0:\n        return float('nan')\n    return float(np.mean(ps))\n\ndef run_test_case_plane_wave(A, L, c, T, k, N_levels, CFL):\n    errors_orig, errors_ref = [], []\n    hs = []\n    finest_data = None\n    for N in N_levels:\n        x = np.linspace(0.0, L, N, endpoint=False)\n        omega = c * k\n        u0, v0 = plane_wave_initial(x, A, k, omega)\n        u_orig, v_orig, dx, dt = advance_original(u0, v0, c, L, N, CFL, T)\n        u_ref, v_ref, dx2, dt2 = advance_refactored(u0, v0, c, L, N, CFL, T)\n        assert abs(dx - dx2)  1e-14 and abs(dt - dt2)  1e-14\n        u_ex = plane_wave_exact(x, A, k, omega, T)\n        e_orig = l2_error(u_orig, u_ex, dx)\n        e_ref = l2_error(u_ref, u_ex, dx)\n        errors_orig.append(e_orig)\n        errors_ref.append(e_ref)\n        hs.append(dx)\n        if N == N_levels[-1]:\n            E_orig = energy_checksum(u_orig, v_orig, c, dx)\n            E_ref = energy_checksum(u_ref, v_ref, c, dx)\n            finest_data = (u_orig, u_ref, E_orig, E_ref, dx)\n    p_orig = observed_order(errors_orig, hs)\n    p_ref = observed_order(errors_ref, hs)\n    return p_orig, p_ref, finest_data\n\ndef run_test_case_gaussian(A, L, c, T, x0, sigma, N_levels, CFL):\n    errors_orig, errors_ref = [], []\n    hs = []\n    finest_data = None\n    for N in N_levels:\n        x = np.linspace(0.0, L, N, endpoint=False)\n        u0 = gaussian_f_periodic(x, A, x0, sigma, L)\n        v0 = np.zeros_like(u0)\n        u_orig, v_orig, dx, dt = advance_original(u0, v0, c, L, N, CFL, T)\n        u_ref, v_ref, dx2, dt2 = advance_refactored(u0, v0, c, L, N, CFL, T)\n        assert abs(dx - dx2)  1e-14 and abs(dt - dt2)  1e-14\n        u_ex = gaussian_exact_u(x, A, x0, sigma, L, c, T)\n        e_orig = l2_error(u_orig, u_ex, dx)\n        e_ref = l2_error(u_ref, u_ex, dx)\n        errors_orig.append(e_orig)\n        errors_ref.append(e_ref)\n        hs.append(dx)\n        if N == N_levels[-1]:\n            E_orig = energy_checksum(u_orig, v_orig, c, dx)\n            E_ref = energy_checksum(u_ref, v_ref, c, dx)\n            finest_data = (u_orig, u_ref, E_orig, E_ref, dx)\n    p_orig = observed_order(errors_orig, hs)\n    p_ref = observed_order(errors_ref, hs)\n    return p_orig, p_ref, finest_data\n\ndef equivalence_check(p_orig, p_ref, finest_data,\n                      p_target=2.0, p_tol=0.2, p_match_tol=0.05,\n                      arr_tol=1e-12, chk_tol=1e-10):\n    u_orig, u_ref, E_orig, E_ref, dx = finest_data\n    # Relative L2 difference of final arrays\n    norm_orig = np.sqrt(np.sum(u_orig*u_orig) * dx)\n    rel_arr = np.sqrt(np.sum((u_orig - u_ref)**2) * dx) / (norm_orig + 1e-300)\n    arrays_close = rel_arr = arr_tol\n    # Relative checksum difference\n    denom = max(abs(E_orig), abs(E_ref)) + 1e-300\n    rel_chk = abs(E_orig - E_ref) / denom\n    checksums_close = rel_chk = chk_tol\n    # Convergence orders\n    p_ok_orig = abs(p_orig - p_target) = p_tol\n    p_ok_ref = abs(p_ref - p_target) = p_tol\n    p_match = abs(p_orig - p_ref) = p_match_tol\n    return arrays_close and checksums_close and p_ok_orig and p_ok_ref and p_match\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Plane wave happy path\n        (\"plane\", {\"A\":1.0, \"L\":1.0, \"c\":1.0, \"T\":1.0, \"k\":2.0*np.pi,\n                   \"N_levels\":[64,128,256], \"CFL\":0.9}),\n        # Test case 2: Gaussian near-CFL edge\n        (\"gaussian\", {\"A\":1.0, \"L\":1.0, \"c\":1.0, \"T\":0.5, \"x0\":0.25, \"sigma\":0.05,\n                      \"N_levels\":[64,128,256], \"CFL\":0.999}),\n        # Test case 3: Plane wave coarse-grid boundary\n        (\"plane\", {\"A\":1.0, \"L\":1.0, \"c\":1.0, \"T\":0.5, \"k\":2.0*np.pi,\n                   \"N_levels\":[16,32,64], \"CFL\":0.9}),\n    ]\n\n    results = []\n    for kind, params in test_cases:\n        if kind == \"plane\":\n            p_orig, p_ref, finest_data = run_test_case_plane_wave(\n                A=params[\"A\"], L=params[\"L\"], c=params[\"c\"], T=params[\"T\"],\n                k=params[\"k\"], N_levels=params[\"N_levels\"], CFL=params[\"CFL\"]\n            )\n        else:\n            p_orig, p_ref, finest_data = run_test_case_gaussian(\n                A=params[\"A\"], L=params[\"L\"], c=params[\"c\"], T=params[\"T\"],\n                x0=params[\"x0\"] * params[\"L\"], sigma=params[\"sigma\"] * params[\"L\"],\n                N_levels=params[\"N_levels\"], CFL=params[\"CFL\"]\n            )\n        ok = equivalence_check(\n            p_orig, p_ref, finest_data,\n            p_target=2.0, p_tol=0.2, p_match_tol=0.05,\n            arr_tol=1e-12, chk_tol=1e-10\n        )\n        results.append(ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}