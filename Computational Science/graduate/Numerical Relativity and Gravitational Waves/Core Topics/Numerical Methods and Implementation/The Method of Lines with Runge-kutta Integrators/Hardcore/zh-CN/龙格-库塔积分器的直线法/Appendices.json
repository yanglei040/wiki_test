{
    "hands_on_practices": [
        {
            "introduction": "将偏微分方程转化为常微分方程组是应用线方法 (Method of Lines, MOL) 的第一步。本练习提供了一个基础的动手实践，让您体验如何将经典四阶龙格-库塔 (RK4) 这种标准高阶时间积分器应用于一个半离散化的方程 。通过显式推导更新模板，您将具体地理解龙格-库塔方法的抽象分步如何与空间差分算子相结合，最终形成一个高阶的单步更新法则。",
            "id": "3493026",
            "problem": "在数值相对论中使用的许多爱因斯坦场方程的双曲型表述中，某些特征场会沿着由规范设定的优选方向，近似地作为平流输运量传播。作为一个与一维均匀空间网格上的线性化引力波相关的出射特征的简化模型，考虑一个标量场 $h(t,x)$，它满足常系数平流方程 $\\partial_{t} h + v \\,\\partial_{x} h = 0$，其中 $v$ 是一个正常数速度。使用线方法 (MOL)，在均匀网格 $x_{i} = i\\,\\Delta x$ 上对空间进行离散化，并在时间层 $t^{n} = t^{0} + n\\,\\Delta t$ 上定义网格函数 $u_{i}^{n} \\approx h(t^{n}, x_{i})$。使用由 $D_{0} u_{i} = \\big(u_{i+1} - u_{i-1}\\big)/(2\\,\\Delta x)$ 定义的中心差分算子 $D_{0}$ 来近似空间导数，因此半离散系统在一个充分扩展或周期性的域上可以写作 $\\frac{d}{dt}\\,\\mathbf{u}(t) = -\\,v\\,D_{0}\\,\\mathbf{u}(t)$，该域使得所有必需的模板点都有良好定义。\n\n应用经典的四阶龙格—库塔 (RK) 方法，将时间从 $t^{n}$ 推进一个时间步到 $t^{n+1} = t^{n} + \\Delta t$。从基本平流定律和中心差分半离散化出发，根据第一性原理推导网格函数 $\\mathbf{u}^{n}$ 的四阶段更新，并简化结果，以获得每个分量 $u_{i}^{n+1}$ 的单步更新表达式，该表达式完全用 $\\{u_{i+k}^{n}\\}_{k=-4}^{4}$ 和无量纲库朗数 $\\lambda = v\\,\\Delta t/\\Delta x$ 表示。\n\n请将您的最终结果以一个关于 $u_{i}^{n+1}$ 的闭式解析表达式的形式给出，该表达式用 $\\lambda$ 和 RK4 模板上 $u^{n}$ 的相邻值表示。不需要进行数值计算或舍入，最终表达式中不应包含任何物理单位。",
            "solution": "用户提供了一个有效的问题陈述。任务是为一个使用线方法 (MOL)、中心空间差分和经典四阶龙格—库塔 (RK4) 时间积分器离散化的一维平流方程，推导其单步更新法则。\n\n控制偏微分方程 (PDE) 是关于标量场 $h(t,x)$ 的常系数平流方程：\n$$\n\\partial_{t} h + v \\,\\partial_{x} h = 0\n$$\n其中 $v$ 是一个正常数速度。\n\n问题指定了在均匀网格 $x_{i} = i\\,\\Delta x$ 上使用线方法进行半离散化。空间导数 $\\partial_x h$ 由二阶中心差分算子 $D_0$ 近似：\n$$\nD_{0} u_{i} = \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x}\n$$\n其中 $u_i(t) \\approx h(t, x_i)$。这对网格函数 $u_i(t)$ 产生了一个常微分方程组 (ODEs)：\n$$\n\\frac{d u_i}{dt} = -v D_0 u_i = -v \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x}\n$$\n该系统是线性的，可以写成向量形式 $\\frac{d}{dt}\\mathbf{u}(t) = L\\mathbf{u}(t)$，其中 $L$ 是表示右侧项的线性算子，$L = -v D_0$。\n\n使用经典的四阶龙格—库塔 (RK4) 方法将解从时间 $t^n$ 推进到 $t^{n+1} = t^n + \\Delta t$。对于线性、时不变的常微分方程组 $\\frac{d\\mathbf{u}}{dt} = L\\mathbf{u}$，RK4 更新公式等价于矩阵指数算子 $\\exp(\\Delta t L)$ 的截断泰勒级数展开：\n$$\n\\mathbf{u}^{n+1} = \\left( I + \\Delta t L + \\frac{(\\Delta t L)^2}{2!} + \\frac{(\\Delta t L)^3}{3!} + \\frac{(\\Delta t L)^4}{4!} \\right) \\mathbf{u}^{n}\n$$\n其中 $I$ 是单位算子。我们定义无量纲库朗数 $\\lambda = v\\,\\Delta t/\\Delta x$。我们可以用 $\\lambda$ 和一个纯几何的差分算子来表示算子 $\\Delta t L$。设 $D_c$ 是中心差分算子，使得 $D_c u_i = u_{i+1} - u_{i-1}$。那么，\n$$\n\\Delta t L = -v \\Delta t D_0 = -v \\Delta t \\frac{D_c}{2 \\Delta x} = -\\frac{v \\Delta t}{2 \\Delta x} D_c = -\\frac{\\lambda}{2} D_c\n$$\n我们记算子 $A = \\Delta t L = -\\frac{\\lambda}{2} D_c$。单个网格点 $u_i$ 的更新法则是：\n$$\nu_i^{n+1} = \\left( I + A + \\frac{A^2}{2} + \\frac{A^3}{6} + \\frac{A^4}{24} \\right) u_i^n\n$$\n为了找到显式公式，我们需要计算算子 $A$ 的各次幂作用在 $u_i^n$ 上的结果。这需要计算差分算子 $D_c$ 的各次幂：\n\\begin{itemize}\n    \\item $A u_i^n = -\\frac{\\lambda}{2} D_c u_i^n = -\\frac{\\lambda}{2} (u_{i+1}^n - u_{i-1}^n)$\n    \\item $A^2 u_i^n = \\left(-\\frac{\\lambda}{2}\\right)^2 D_c^2 u_i^n = \\frac{\\lambda^2}{4} D_c(u_{i+1}^n - u_{i-1}^n) = \\frac{\\lambda^2}{4} \\left( (u_{i+2}^n - u_i^n) - (u_i^n - u_{i-2}^n) \\right) = \\frac{\\lambda^2}{4} (u_{i+2}^n - 2u_i^n + u_{i-2}^n)$\n    \\item $A^3 u_i^n = \\left(-\\frac{\\lambda}{2}\\right)^3 D_c^3 u_i^n = -\\frac{\\lambda^3}{8} D_c(u_{i+2}^n - 2u_i^n + u_{i-2}^n) = -\\frac{\\lambda^3}{8} (u_{i+3}^n - 3u_{i+1}^n + 3u_{i-1}^n - u_{i-3}^n)$\n    \\item $A^4 u_i^n = \\left(-\\frac{\\lambda}{2}\\right)^4 D_c^4 u_i^n = \\frac{\\lambda^4}{16} D_c(u_{i+3}^n - 3u_{i+1}^n + 3u_{i-1}^n - u_{i-3}^n) = \\frac{\\lambda^4}{16} (u_{i+4}^n - 4u_{i+2}^n + 6u_i^n - 4u_{i-2}^n + u_{i-4}^n)$\n\\end{itemize}\n现在我们将这些表达式代入 RK4 更新公式中：\n$$\nu_i^{n+1} = u_i^n + A u_i^n + \\frac{1}{2}A^2 u_i^n + \\frac{1}{6}A^3 u_i^n + \\frac{1}{24}A^4 u_i^n\n$$\n$$\n\\begin{aligned}\nu_i^{n+1} = u_i^n  - \\frac{\\lambda}{2} (u_{i+1}^n - u_{i-1}^n) \\\\\n + \\frac{1}{2}\\frac{\\lambda^2}{4} (u_{i+2}^n - 2u_i^n + u_{i-2}^n) \\\\\n - \\frac{1}{6}\\frac{\\lambda^3}{8} (u_{i+3}^n - 3u_{i+1}^n + 3u_{i-1}^n - u_{i-3}^n) \\\\\n + \\frac{1}{24}\\frac{\\lambda^4}{16} (u_{i+4}^n - 4u_{i+2}^n + 6u_i^n - 4u_{i-2}^n + u_{i-4}^n)\n\\end{aligned}\n$$\n简化每一项的系数：\n$$\n\\begin{aligned}\nu_i^{n+1} = u_i^n  - \\frac{\\lambda}{2} (u_{i+1}^n - u_{i-1}^n) \\\\\n + \\frac{\\lambda^2}{8} (u_{i+2}^n - 2u_i^n + u_{i-2}^n) \\\\\n - \\frac{\\lambda^3}{48} (u_{i+3}^n - 3u_{i+1}^n + 3u_{i-1}^n - u_{i-3}^n) \\\\\n + \\frac{\\lambda^4}{384} (u_{i+4}^n - 4u_{i+2}^n + 6u_i^n - 4u_{i-2}^n + u_{i-4}^n)\n\\end{aligned}\n$$\n最后一步是收集每个网格点值 $u_{i+k}^n$（其中 $k \\in \\{-4, -3, \\dots, 3, 4\\}$）的系数。\n\\begin{itemize}\n    \\item $u_{i+4}^n$ 的系数：来自 $\\lambda^4$ 项，我们得到 $\\frac{\\lambda^4}{384}$。\n    \\item $u_{i+3}^n$ 的系数：来自 $\\lambda^3$ 项，我们得到 $-\\frac{\\lambda^3}{48}$。\n    \\item $u_{i+2}^n$ 的系数：来自 $\\lambda^2$ 和 $\\lambda^4$ 项，我们得到 $\\frac{\\lambda^2}{8} + \\frac{\\lambda^4}{384}(-4) = \\frac{\\lambda^2}{8} - \\frac{\\lambda^4}{96}$。\n    \\item $u_{i+1}^n$ 的系数：来自 $\\lambda$ 和 $\\lambda^3$ 项，我们得到 $-\\frac{\\lambda}{2} - \\frac{\\lambda^3}{48}(-3) = -\\frac{\\lambda}{2} + \\frac{\\lambda^3}{16}$。\n    \\item $u_i^n$ 的系数：来自初始项、$\\lambda^2$ 和 $\\lambda^4$ 项，我们得到 $1 + \\frac{\\lambda^2}{8}(-2) + \\frac{\\lambda^4}{384}(6) = 1 - \\frac{\\lambda^2}{4} + \\frac{\\lambda^4}{64}$。\n    \\item $u_{i-1}^n$ 的系数：来自 $\\lambda$ 和 $\\lambda^3$ 项，我们得到 $-\\frac{\\lambda}{2}(-1) - \\frac{\\lambda^3}{48}(3) = \\frac{\\lambda}{2} - \\frac{\\lambda^3}{16}$。\n    \\item $u_{i-2}^n$ 的系数：来自 $\\lambda^2$ 和 $\\lambda^4$ 项，我们得到 $\\frac{\\lambda^2}{8}(1) + \\frac{\\lambda^4}{384}(-4) = \\frac{\\lambda^2}{8} - \\frac{\\lambda^4}{96}$。\n    \\item $u_{i-3}^n$ 的系数：来自 $\\lambda^3$ 项，我们得到 $-\\frac{\\lambda^3}{48}(-1) = \\frac{\\lambda^3}{48}$。\n    \\item $u_{i-4}^n$ 的系数：来自 $\\lambda^4$ 项，我们得到 $\\frac{\\lambda^4}{384}$。\n\\end{itemize}\n将这些系数组合起来，得到 $u_i^{n+1}$ 的最终单步更新公式。",
            "answer": "$$\n\\boxed{u_i^{n+1} = \\left(1 - \\frac{\\lambda^2}{4} + \\frac{\\lambda^4}{64}\\right)u_i^n + \\left(-\\frac{\\lambda}{2} + \\frac{\\lambda^3}{16}\\right)u_{i+1}^n + \\left(\\frac{\\lambda}{2} - \\frac{\\lambda^3}{16}\\right)u_{i-1}^n + \\left(\\frac{\\lambda^2}{8} - \\frac{\\lambda^4}{96}\\right)(u_{i+2}^n + u_{i-2}^n) + \\left(-\\frac{\\lambda^3}{48}\\right)u_{i+3}^n + \\left(\\frac{\\lambda^3}{48}\\right)u_{i-3}^n + \\left(\\frac{\\lambda^4}{384}\\right)(u_{i+4}^n + u_{i-4}^n)}\n$$"
        },
        {
            "introduction": "虽然内部格式至关重要，但数值模拟的稳定性往往取决于边界条件的正确处理。本练习深入探讨了现代且稳健的同时逼近项求和分部 (SBP-SAT) 技术，该技术用于在双曲系统中施加边界数据 。通过应用离散能量方法，您将学会如何推导出一个能保证半离散格式稳定性的惩罚参数，这对于理解如何防止从计算区域边界产生的非物理误差增长至关重要。",
            "id": "3492982",
            "problem": "考虑一维线性平流方程 $u_{t} + a\\,u_{x} = 0$，其中常数平流速度 $a>0$，空间区间为 $[0,L]$，入流边界位于 $x=0$。在数值相对论和引力波领域，通过线方法获得的半离散格式使用显式 Runge–Kutta 方法进行时间积分，其稳定性通过构造基于分部求和（SBP）空间算子和用于边界实施的同步近似项（SAT）的半离散能量估计来保证。\n\n令 $\\{x_{i}\\}_{i=0}^{N}$ 为 $[0,L]$ 上的一个网格。令 $D$ 为一个一阶导数 SBP 算子，其范数矩阵 $H$ 为对角、对称、正定矩阵，令边界矩阵为 $B=\\mathrm{diag}(-1,0,\\dots,0,1)$。假设 SBP 性质以典范形式 $H D = Q + \\frac{1}{2} B$ 成立，其中 $Q^{T}=-Q$，因此对于任意网格函数 $v$，都有 $v^{T} H D v = \\frac{1}{2} v^{T} B v = \\frac{1}{2}\\left(v_{N}^{2}-v_{0}^{2}\\right)$。考虑带有 SAT 边界项的半离散线方法系统，该边界项在 $x=0$ 处实施给定的入流数据 $g(t)$：\n$$\nu_{t} = -a\\,D u \\;+\\; H^{-1} e_{0}\\,\\tau\\left(g(t) - u_{0}(t)\\right),\n$$\n其中 $e_{0}=(1,0,\\dots,0)^{T}$ 用于选择左边界分量，$u_{0}(t)$ 是 $x_{0}$ 处的离散解值，$\\tau$ 是一个标量 SAT 罚系数。\n\n从 SBP 性质和离散能量 $\\|u\\|_{H}^{2} = u^{T} H u$ 的定义出发，推导上述系统的半离散能量平衡，并确定罚系数 $\\tau$ 的选择，使得离散能量估计的形式为\n$$\n\\frac{1}{2}\\frac{d}{dt}\\|u\\|_{H}^{2} \\;\\le\\; C(g(t)) \\,-\\, D(u(t)),\n$$\n其中 $C(g(t))$ 是一个非负的数据相关项，$D(u(t))$ 是一个非负的耗散项，且与 $x=0$ 处的入流和 $x=L$ 处的出流一致。您的答案必须是罚系数 $\\tau$ 以 $a$ 表示的单一、闭式解析表达式。不要包含单位。",
            "solution": "该问题要求推导同步近似项（SAT）的罚系数 $\\tau$，以确保线性平流方程半离散格式的稳定性。稳定性将通过能量方法建立，目标是获得特定形式的半离散能量平衡。\n\n出发点是离散能量的定义，即解向量 $u(t) \\in \\mathbb{R}^{N+1}$ 的 $H$-范数的平方：\n$$\n\\|u\\|_{H}^{2} = u^{T} H u\n$$\n为了找到能量平衡，我们将此量对时间 $t$ 求导。鉴于范数矩阵 $H$ 是常数且对称的（$H^{T}=H$），时间导数为：\n$$\n\\frac{d}{dt}\\|u\\|_{H}^{2} = \\frac{d u^{T}}{dt} H u + u^{T} H \\frac{d u}{dt} = 2 u^{T} H \\frac{d u}{dt}\n$$\n问题给出了描述解向量 $u(t)$ 时间演化的线方法常微分方程（ODE）系统，我们将其表示为 $u_{t}$：\n$$\nu_{t} = \\frac{d u}{dt} = -a\\,D u \\;+\\; H^{-1} e_{0}\\,\\tau\\left(g(t) - u_{0}(t)\\right)\n$$\n将此 ODE 系统代入能量演化方程，得到：\n$$\n\\frac{d}{dt}\\|u\\|_{H}^{2} = 2 u^{T} H \\left( -a\\,D u \\;+\\; H^{-1} e_{0}\\,\\tau\\left(g(t) - u_{0}(t)\\right) \\right)\n$$\n我们可以分配右侧的项：\n$$\n\\frac{d}{dt}\\|u\\|_{H}^{2} = -2a\\, u^{T} H D u \\;+\\; 2 \\tau\\, u^{T} H H^{-1} e_{0} \\left(g(t) - u_{0}(t)\\right)\n$$\n让我们分别分析这两项。\n\n对于涉及空间导数算子 $D$ 的第一项，我们使用给定的分部求和（SBP）性质 $v^{T} H D v = \\frac{1}{2}\\left(v_{N}^{2}-v_{0}^{2}\\right)$，这代表了分部积分的离散模拟。将其应用于我们的解向量 $u(t)$：\n$$\n-2a\\, u^{T} H D u = -2a \\left( \\frac{1}{2}\\left(u_{N}^{2}-u_{0}^{2}\\right) \\right) = -a\\left(u_{N}^{2}-u_{0}^{2}\\right) = a u_{0}^{2} - a u_{N}^{2}\n$$\n此处，$u_{0}$ 和 $u_{N}$ 分别是解在边界 $x_{0}=0$ 和 $x_{N}=L$ 处的值。\n\n对于代表 SAT 惩罚的第二项，我们简化矩阵-向量乘积。乘积 $H H^{-1}$ 是单位矩阵。向量 $e_{0}=(1,0,\\dots,0)^{T}$ 的定义使得对于任何向量 $v$，乘积 $v^{T}e_{0}$ 选择其第一个分量 $v_{0}$。因此，$u^{T} e_{0} = u_{0}$。第二项简化为：\n$$\n2 \\tau\\, u^{T} e_{0} \\left(g - u_{0}\\right) = 2 \\tau\\, u_{0} \\left(g - u_{0}\\right) = 2\\tau g u_{0} - 2\\tau u_{0}^{2}\n$$\n结合两项的简化表达式，我们得到完整的能量速率方程：\n$$\n\\frac{d}{dt}\\|u\\|_{H}^{2} = \\left(a u_{0}^{2} - a u_{N}^{2}\\right) + \\left(2\\tau g u_{0} - 2\\tau u_{0}^{2}\\right)\n$$\n问题要求对 $\\frac{1}{2}\\frac{d}{dt}\\|u\\|_{H}^{2}$ 进行估计。除以 2 并收集与入流边界（$x=0$）和出流边界（$x=L$）相关的项，得到：\n$$\n\\frac{1}{2}\\frac{d}{dt}\\|u\\|_{H}^{2} = \\left(\\frac{a}{2} - \\tau\\right)u_{0}^{2} + \\tau g u_{0} - \\frac{a}{2} u_{N}^{2}\n$$\n我们需要确定 $\\tau$，使得该表达式具有 $\\le C(g(t)) - D(u(t))$ 的形式，其中 $C(g(t)) \\ge 0$ 且 $D(u(t)) \\ge 0$。\n$-\\frac{a}{2} u_{N}^{2}$ 项对应于 $x=L$ 处的出流边界。由于 $a>0$，该项是非正的，代表能量离开域。它本质上是稳定的，可以作为非负耗散项 $D(u(t))$ 的一部分，即 $D_{outflow}(u) = \\frac{a}{2}u_N^2 \\ge 0$。\n\n其余项与 $x=0$ 处的入流边界相关：\n$$\nT_{0} = \\left(\\frac{a}{2} - \\tau\\right)u_{0}^{2} + \\tau g u_{0}\n$$\n为确保稳定性，解的二次项（例如 $u_0^2$）不能导致能量增长。我们可以通过对 $u_0$ 配方，将 $T_0$ 表示为所需的形式 $C(g) - D(u)$。为了使 $u_0$ 的二次项结果是耗散的（即非正），我们必须有 $\\frac{a}{2} - \\tau \\le 0$，即 $\\tau \\ge \\frac{a}{2}$。假设 $\\tau > a/2$，我们可以写出：\n$$\nT_{0} = -\\left(\\tau - \\frac{a}{2}\\right)\\left[u_{0}^{2} - \\frac{\\tau}{\\tau-\\frac{a}{2}} g u_{0}\\right]\n$$\n對方括号中的表达式进行配方，得到：\n$$\nT_{0} = -\\left(\\tau - \\frac{a}{2}\\right)\\left[ \\left(u_{0} - \\frac{\\tau g}{2(\\tau-\\frac{a}{2})}\\right)^{2} - \\left(\\frac{\\tau g}{2(\\tau-\\frac{a}{2})}\\right)^{2} \\right] = \\frac{\\tau^{2}}{4(\\tau-\\frac{a}{2})}g^{2} - \\left(\\tau - \\frac{a}{2}\\right)\\left(u_{0} - \\frac{\\tau g}{2(\\tau-\\frac{a}{2})}\\right)^{2}\n$$\n这种形式 $C(g) - D(u,g)$ 为任何 $\\tau > a/2$ 提供了一个稳定的估计。然而，问题要求的是 τ 的“那个”选择，暗示着一个唯一的、规范的值。SAT 项的物理目的是实施边界条件 $u(0,t)=g(t)$。因此，一个物理上一致的惩罚应该耗散与数值解 $u_0$ 和边界数据 $g$ 之间的误差成比例的能量，即与 $(u_0-g)^2$ 成比例。我们 $T_0$ 表达式的耗散部分与 $(u_0 - K g)^2$ 成比例，其中 $K = \\frac{\\tau}{2(\\tau-\\frac{a}{2})}$。为了物理上的一致性，我们必须要求 $K=1$。\n$$\n\\frac{\\tau}{2(\\tau-\\frac{a}{2})} = 1 \\implies \\tau = 2\\tau - a \\implies \\tau = a\n$$\n$\\tau$ 的这个唯一选择确保了 SAT 项惩罚的是边界处的实际误差。这个选择满足稳定性条件 $\\tau > a/2$，因为 $a>0$ 意味着 $a > a/2$。\n让我们验证 $\\tau=a$ 时的能量平衡结果。入流项 $T_0$ 变为：\n$$\nT_0 = \\left(\\frac{a}{2} - a\\right)u_{0}^{2} + a g u_{0} = -\\frac{a}{2}u_{0}^{2} + a g u_{0} = -\\frac{a}{2}(u_0^2 - 2gu_0) = -\\frac{a}{2}((u_0-g)^2 - g^2) = \\frac{a}{2}g^2 - \\frac{a}{2}(u_0-g)^2\n$$\n因此，完整的半离散能量平衡是：\n$$\n\\frac{1}{2}\\frac{d}{dt}\\|u\\|_{H}^{2} = \\frac{a}{2}g(t)^{2} - \\frac{a}{2}(u_{0}(t)-g(t))^{2} - \\frac{a}{2}u_{N}(t)^{2}\n$$\n该表达式与所需形式完美匹配，其中 $C(g(t)) = \\frac{a}{2}g(t)^{2} \\ge 0$ 且 $D(u(t)) = \\frac{a}{2}(u_{0}(t)-g(t))^{2} + \\frac{a}{2}u_{N}(t)^{2} \\ge 0$。\n\n因此，正确的罚系数是 $\\tau=a$。",
            "answer": "$$\n\\boxed{a}\n$$"
        },
        {
            "introduction": "在数值相对论中，特别是模拟致密双星系统的引力波时，在极长的时间尺度上保持高保真度至关重要。这个动手编程练习旨在探究长期轨道模拟中的累积相位误差，这是引力波建模中的一个核心挑战 。通过实现并比较一个标准的自适应龙格-库塔积分器和一个保持系统结构的辛积分器，您将深刻理解如何为那些需要在数百万步的演化中保持物理不变量的模拟选择合适的数值工具。",
            "id": "3493030",
            "problem": "设计并实现一个完整且可运行的程序，该程序在一个哈密顿测地线玩具模型中量化由龙格-库塔 (Runge–Kutta, RK) 时间积分引起的累积轨道相位误差，并将其与一个时间对称辛积分器进行比较，旨在评估与数值相对论中引力波 (Gravitational Wave, GW) 建模相关的长期相位保真度。这些积分器必须在线条法 (Method of Lines, MoL) 的视角下应用，其中时间上的连续演化由一个 RK 格式执行。此比较必须基于第一性原理，并能在指定的测试套件上产生数值可验证的输出。\n\n从以下基本基础开始。考虑一个牛顿检验质量测地线玩具模型，用于束缚赤道轨道（固定背景下圆形测地线的代理），其哈密顿量为\n$$\nH(r,p_r;\\phi,L) \\;=\\; \\frac{p_r^2}{2} \\;+\\; \\frac{L^2}{2\\,r^2} \\;-\\; \\frac{\\mu}{r},\n$$\n其中 $r$ 是径向坐标，$p_r$ 是径向正则动量，$\\phi$ 是轨道相位，$L$ 是守恒角动量，$\\mu$ 是引力参数。正则哈密顿方程为\n$$\n\\frac{dr}{dt} \\;=\\; \\frac{\\partial H}{\\partial p_r} \\;=\\; p_r,\\qquad\n\\frac{dp_r}{dt} \\;=\\; -\\,\\frac{\\partial H}{\\partial r} \\;=\\; \\frac{L^2}{r^3} \\;-\\; \\frac{\\mu}{r^2},\\qquad\n\\frac{d\\phi}{dt} \\;=\\; \\frac{\\partial H}{\\partial L} \\;=\\; \\frac{L}{r^2},\\qquad\n\\frac{dL}{dt} \\;=\\; 0.\n$$\n对于半径为 $r_0$ 的圆形轨道，精确的圆频率为\n$$\n\\omega \\;=\\; \\sqrt{\\frac{\\mu}{r_0^3}},\n$$\n在时间 $T$ 后的精确相位为\n$$\n\\phi_{\\mathrm{exact}}(T) \\;=\\; \\omega\\,T,\n$$\n因此，在整数个周期 $N$ 之后，精确相位为 $\\phi_{\\mathrm{exact}}(T)=2\\pi N$，其中 $T = \\frac{2\\pi N}{\\omega}$。\n\n任务要求：\n\n- 为上述常微分方程 (ODE) 系统实现两个时间积分器：\n  1. 一种带局部误差控制的误差控制嵌入式龙格-库塔方法（使用经典的二阶嵌入对，有时称为霍恩-欧拉法 (Heun–Euler)，其中1阶的欧拉法嵌入在2阶的梯形龙格-库塔方法中）。这通过使用 RK 积分器对半离散系统进行时间积分，实现了线条法 (MoL) 的观点。该积分器必须使用相对容差 $rtol$ 基于标量误差范数自适应其步长。为确保评估覆盖长期累积效应，对步长 $h_{\\max}$ 施加硬性上限，以使接受的步数至少达到预设的目标值。必须实现局部误差的接受/拒绝逻辑。\n  2. 在具有有效势 $V_{\\mathrm{eff}}(r)=\\frac{L^2}{2r^2}-\\frac{\\mu}{r}$ 的简化 $(r,p_r)$ 子系统上应用一个二阶时间对称辛格式，即斯托默-韦尔莱 (Störmer–Verlet) 方法（也称为速度-韦尔莱 (Velocity–Verlet) 方法）：\n     - 半步推进：$p_r \\leftarrow p_r - \\frac{\\partial V_{\\mathrm{eff}}}{\\partial r}\\,\\frac{h}{2}$，\n     - 漂移：$r \\leftarrow r + p_r\\,h$，\n     - 半步推进：$p_r \\leftarrow p_r - \\frac{\\partial V_{\\mathrm{eff}}}{\\partial r}\\,\\frac{h}{2}$。\n    相位 $\\phi$ 必须在漂移过程中使用长度为 $h$ 的步长上的二阶精度求积法进行一致地推进，例如采用辛普森型更新\n    $$\n    \\Delta\\phi \\;\\approx\\; \\frac{h\\,L}{6}\\left(\\frac{1}{r_{\\mathrm{before}}^2} + \\frac{4}{r_{\\mathrm{mid}}^2} + \\frac{1}{r_{\\mathrm{after}}^2}\\right),\n    $$\n    其中 $r_{\\mathrm{before}}$ 和 $r_{\\mathrm{after}}$ 是漂移前后的半径，$r_{\\mathrm{mid}}$ 是漂移的中点半径。\n\n- 使用无量纲单位，除非另有说明，$\\mu=1$。所有角度必须以弧度为单位。以弧度报告相位误差。不使用其他物理单位。\n\n- 初始数据必须设置为 $t=0$ 时的精确圆形轨道条件：$r(0)=r_0$, $p_r(0)=0$, $L=\\sqrt{\\mu r_0}$，以及 $\\phi(0)=0$。\n\n- 对于每个测试，积分到 $T=\\frac{2\\pi N}{\\omega}$（其中 $\\omega=\\sqrt{\\mu/r_0^3}$），并计算绝对相位误差\n  $$\n  \\Delta\\phi \\;=\\; \\min_{k\\in\\mathbb{Z}} \\left| \\phi_{\\mathrm{num}}(T) \\;-\\; \\phi_{\\mathrm{exact}}(T) \\;-\\; 2\\pi k \\right| \\;\\in\\; [0,\\pi],\n  $$\n  即，模 $2\\pi$ 的最小绝对差。将此误差与一个受 GW 启发的累积相位预算目标 $\\Delta\\phi_{\\max}$ 进行比较，其中你必须使用 $\\Delta\\phi_{\\max}=0.1$。\n\n- 带误差控制的 RK 方法必须使用一个相对容差 $rtol$ 和一个时间步长的硬性上限 $h_{\\max}$。辛方法必须使用固定的步数 $n_{\\mathrm{symp}}$，步长为 $h=T/n_{\\mathrm{symp}}$。\n\n测试套件：\n\n为以下参数集提供结果，作为三个测试用例，每个用例以元组 $\\left(r_0,\\mu,N,rtol,\\mathrm{target\\_steps}_{\\mathrm{RK}},n_{\\mathrm{symp}}\\right)$ 的形式给出：\n\n- 用例 A (理想路径): $(10.0,\\,1.0,\\,200,\\,10^{-8},\\,300000,\\,262144)$,\n- 用例 B (更紧密的轨道，不同容差): $(1.0,\\,1.0,\\,500,\\,10^{-6},\\,200000,\\,131072)$,\n- 用例 C (长期累积，超过 $10^6$ 步): $(7.0,\\,1.0,\\,4000,\\,10^{-7},\\,1024000,\\,1048576)$。\n\n对于每个用例中的带误差控制的 RK 方法，将硬性上限设置为 $h_{\\max}=T/\\mathrm{target\\_steps}_{\\mathrm{RK}}$。对于辛方法，设置 $h=T/n_{\\mathrm{symp}}$。在所有情况下，计算两种积分器在 $t=T$ 时的绝对相位误差 $\\Delta\\phi$，并确定每种误差是否满足 GW 相位预算 $\\Delta\\phi \\le \\Delta\\phi_{\\max}$。\n\n最终输出规范：\n\n- 您的程序必须生成单行输出，其中包含一个列表，按以下顺序汇总所有三个测试用例的结果：\n  $[\\Delta\\phi_{\\mathrm{RK}}^{(A)},\\Delta\\phi_{\\mathrm{SV}}^{(A)},\\mathrm{ok}_{\\mathrm{RK}}^{(A)},\\mathrm{ok}_{\\mathrm{SV}}^{(A)},\\Delta\\phi_{\\mathrm{RK}}^{(B)},\\Delta\\phi_{\\mathrm{SV}}^{(B)},\\mathrm{ok}_{\\mathrm{RK}}^{(B)},\\mathrm{ok}_{\\mathrm{SV}}^{(B)},\\Delta\\phi_{\\mathrm{RK}}^{(C)},\\Delta\\phi_{\\mathrm{SV}}^{(C)},\\mathrm{ok}_{\\mathrm{RK}}^{(C)},\\mathrm{ok}_{\\mathrm{SV}}^{(C)}]$。\n- 每个 $\\Delta\\phi$ 必须是一个以弧度为单位的浮点数，每个 $\\mathrm{ok}$ 必须是一个布尔值，指示相应方法是否满足相位预算 $\\Delta\\phi_{\\max}=0.1$。\n- 不得打印任何其他文本。\n\n您的实现必须是完全自包含的，不使用外部输入，并且在科学上是合理的，在数值上与所述方程一致。只要遵守指定的约束，该程序必须能使用任何现代 Python 环境运行。",
            "solution": "用户提供了一个问题陈述，在尝试解决方案之前需要对其进行验证。\n\n### 步骤1：提取给定信息\n问题陈述提供了以下数据、定义和约束：\n- **哈密顿量**: $H(r,p_r;\\phi,L) = \\frac{p_r^2}{2} + \\frac{L^2}{2\\,r^2} - \\frac{\\mu}{r}$。\n- **状态变量**: 径向坐标 $r$，径向正则动量 $p_r$，轨道相位 $\\phi$，守恒角动量 $L$。\n- **引力参数**: $\\mu$。\n- **哈密顿方程**:\n  $$\n  \\frac{dr}{dt} = \\frac{\\partial H}{\\partial p_r} = p_r, \\qquad\n  \\frac{dp_r}{dt} = -\\frac{\\partial H}{\\partial r} = \\frac{L^2}{r^3} - \\frac{\\mu}{r^2}, \\qquad\n  \\frac{d\\phi}{dt} = \\frac{\\partial H}{\\partial L} = \\frac{L}{r^2}, \\qquad\n  \\frac{dL}{dt} = 0.\n  $$\n- **圆形轨道条件**: 对于半径为 $r_0$ 的圆形轨道，精确圆频率为 $\\omega = \\sqrt{\\frac{\\mu}{r_0^3}}$。\n- **精确相位演化**: 时间 $T$ 后的精确相位为 $\\phi_{\\mathrm{exact}}(T) = \\omega T$。\n- **总积分时间**: $T = \\frac{2\\pi N}{\\omega}$，其中 $N$ 为整数周期数。\n- **积分器1 (RK)**: 一种带误差控制的嵌入式龙格-库塔方法 (霍恩-欧拉法，RK2(1))，具有相对容差 $rtol$ 和最大步长 $h_{\\max}$。\n- **积分器2 (辛方法)**: 在 $(r,p_r)$ 子系统上的一个二阶时间对称斯托默-韦尔莱方法，并对相位 $\\phi$ 使用辛普森型求积法：\n  - 斯托默-韦尔莱法: 1. 半步推进: $p_r \\leftarrow p_r - \\frac{\\partial V_{\\mathrm{eff}}}{\\partial r}\\,\\frac{h}{2}$; 2. 漂移: $r \\leftarrow r + p_r\\,h$; 3. 半步推进: $p_r \\leftarrow p_r - \\frac{\\partial V_{\\mathrm{eff}}}{\\partial r}\\,\\frac{h}{2}$，其中 $V_{\\mathrm{eff}}(r)=\\frac{L^2}{2r^2}-\\frac{\\mu}{r}$。\n  - 相位更新: $\\Delta\\phi \\approx \\frac{h\\,L}{6}\\left(\\frac{1}{r_{\\mathrm{before}}^2} + \\frac{4}{r_{\\mathrm{mid}}^2} + \\frac{1}{r_{\\mathrm{after}}^2}\\right)$。\n- **单位**: 无量纲，$\\mu=1$。角度以弧度为单位。\n- **初始条件**: 在 $t=0$ 时，$r(0)=r_0$，$p_r(0)=0$，$L=\\sqrt{\\mu r_0}$，$\\phi(0)=0$。\n- **相位误差计算**: $\\Delta\\phi = \\min_{k\\in\\mathbb{Z}} \\left| \\phi_{\\mathrm{num}}(T) - \\phi_{\\mathrm{exact}}(T) - 2\\pi k \\right|$，得到一个在 $[0,\\pi]$ 内的值。\n- **相位预算**: 计算出的相位误差 $\\Delta\\phi$ 必须与最大允许误差 $\\Delta\\phi_{\\max}=0.1$ 进行比较。\n- **步长设置**:\n  - RK: $h_{\\max}=T/\\mathrm{target\\_steps}_{\\mathrm{RK}}$。\n  - 辛方法: $h=T/n_{\\mathrm{symp}}$。\n- **测试套件**: 提供了三个用例，形式为元组 $(r_0,\\mu,N,rtol,\\mathrm{target\\_steps}_{\\mathrm{RK}},n_{\\mathrm{symp}})$:\n  - 用例 A: $(10.0, 1.0, 200, 10^{-8}, 300000, 262144)$\n  - 用例 B: $(1.0, 1.0, 500, 10^{-6}, 200000, 131072)$\n  - 用例 C: $(7.0, 1.0, 4000, 10^{-7}, 1024000, 1048576)$\n- **输出格式**: 一个单行的列表字符串表示：$[\\Delta\\phi_{\\mathrm{RK}}^{(A)}, \\Delta\\phi_{\\mathrm{SV}}^{(A)}, \\mathrm{ok}_{\\mathrm{RK}}^{(A)}, \\mathrm{ok}_{\\mathrm{SV}}^{(A)}, \\ldots]$。\n\n### 步骤2：使用提取的给定信息进行验证\n根据验证标准评估问题陈述：\n- **科学基础**: 该问题基于牛顿力学和哈密顿动力学，这是经典物理学的基石。这些方程是二体问题简化形式的标准方程。数值方法（龙格-库塔法、斯托默-韦尔莱法）是计算科学中的经典方法。其应用背景（为引力波建模提供长期相位精度）是数值相对论中一个合理且重要的关注点，尽管模型本身是一个简化的牛顿模拟。该问题在科学上是合理的。\n- **适定性**: 问题描述了一个常微分方程组的适定初值问题。定义动力学的函数在 $r>0$ 时是光滑的，对于所考虑的束缚轨道，此条件始终满足。对于给定的初始数据，存在唯一解。数值任务有明确规定，评估标准是客观和定量的。\n- **客观性**: 问题以精确的数学和计算术语陈述。所有参数都已定义，目标是定量的。没有主观或基于意见的语言。\n- **完整性与一致性**: 问题是自包含的。它提供了物理模型、运动方程、初始条件、数值方法、测试参数以及最终输出的精确格式。各元素内部一致；例如，圆形轨道的条件 ($L=\\sqrt{\\mu r_0}$) 是从所提供的哈密顿量和动力学方程正确推导出来的。数值方法的描述虽然简洁，但足以进行标准实现。例如，斯托默-韦尔莱方法是标准的，而用于相位求积的辛普森法则，虽然需要对 $r_{\\mathrm{mid}}$ 进行解释，但这是一个可以一致实现的明确数值任务。\n- **可行性与现实性**: 如问题所述，这是一个“玩具模型”，这是一种有效的科学工具。为测试用例选择的参数值在数值上是可处理的，旨在测试积分器在相关条件下的性能（例如，长积分时间、变化的容差）。计算任务在标准硬件上可在合理的时间内完成。\n\n### 步骤3：结论与行动\n该问题有效。它在科学上是合理的、适定的、客观的和完整的。我现在将提供一个完整的解决方案。\n\n问题的核心是实现并比较两种用于描述检验质量轨道的哈密顿系统的数值积分器。待求解的常微分方程 (ODE) 系统由状态向量 $\\mathbf{y} = [r, p_r, \\phi]^T$ 给出：\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y}) =\n\\begin{pmatrix}\np_r \\\\\nL^2/r^3 - \\mu/r^2 \\\\\nL/r^2\n\\end{pmatrix}\n$$\n参数 $L$ 和 $\\mu$ 在整个积分过程中保持不变。对于每个测试用例，我们首先计算派生常数：角动量 $L = \\sqrt{\\mu r_0}$、轨道频率 $\\omega = \\sqrt{\\mu/r_0^3}$ 和总积分时间 $T = 2\\pi N / \\omega$。\n\n**积分器1：自适应嵌入式龙格-库塔 RK2(1)**\n该方法使用两个对新时刻解的估计（一个为 $p=2$ 阶，另一个为 $p-1=1$ 阶），将解从时间 $t_n$ 推进到 $t_{n+1} = t_n + h$。我们使用霍恩-欧拉对。\n设 $\\mathbf{y}_n$ 是时间 $t_n$ 时的状态。步骤如下：\n1. 计算一阶（欧拉）阶段：\n$$ \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n) $$\n2. 计算第二阶段：\n$$ \\mathbf{k}_2 = \\mathbf{f}(t_n + h, \\mathbf{y}_n + h \\mathbf{k}_1) $$\n3. 高阶（2阶，霍恩法）解为：\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{2}(\\mathbf{k}_1 + \\mathbf{k}_2) $$\n4. 低阶（1阶，欧拉法）解为：\n$$ \\hat{\\mathbf{y}}_{n+1} = \\mathbf{y}_n + h \\mathbf{k}_1 $$\n5. 局部误差估计是这两者之差：\n$$ \\mathbf{E} = \\mathbf{y}_{n+1} - \\hat{\\mathbf{y}}_{n+1} = \\frac{h}{2}(\\mathbf{k}_2 - \\mathbf{k}_1) $$\n6. 步长控制：如果误差的标量范数在指定容差内，则接受该步。我们对动力学变量 $(r,p_r)$ 使用相对误差准则，因为它们的精度决定了轨道路径。设 $\\mathbf{E}_{dyn} = (E_r, E_{p_r})$。误差通过要求 $\\Vert\\mathbf{E}_{dyn}\\Vert_2 \\le rtol \\cdot \\Vert(r_n, p_{r,n})\\Vert_2$ 来控制。\n如果接受该步，则新步长 $h_{\\text{new}}$ 计算如下：\n$$ h_{\\text{new}} = S \\cdot h_{\\text{old}} \\left( \\frac{rtol \\cdot \\Vert(r_n, p_{r,n})\\Vert_2}{\\Vert\\mathbf{E}_{dyn}\\Vert_2} \\right)^{1/2} $$\n其中 $S=0.9$ 是一个安全因子。如果拒绝，则使用这个较小的 $h_{\\text{new}}$ 重新执行该步。步长始终被限制在 $h_{\\max}$ 以下。\n\n**积分器2：辛斯托默-韦尔莱方法**\n此方法应用于可分离的哈密顿量 $H = T(p_r) + V_{\\mathrm{eff}}(r)$。它使用固定步长 $h = T / n_{\\mathrm{symp}}$。力为 $F(r) = - \\frac{dV_{\\mathrm{eff}}}{dr} = \\frac{L^2}{r^3} - \\frac{\\mu}{r^2}$。从状态 $(r_n, p_{r,n})$ 到 $(r_{n+1}, p_{r,n+1})$ 的更新是一个“推进-漂移-推进”序列：\n1. 第一次动量半步推进：\n$$ p_{r, n+1/2} = p_{r,n} + F(r_n) \\frac{h}{2} $$\n2. 使用半步动量进行位置的全步漂移：\n$$ r_{n+1} = r_n + p_{r, n+1/2} h $$\n3. 第二次动量半步推进：\n$$ p_{r, n+1} = p_{r, n+1/2} + F(r_{n+1}) \\frac{h}{2} $$\n相位 $\\phi$ 通过对 $\\int_{t_n}^{t_{n+1}} \\frac{L}{r(t)^2} dt$ 使用二阶精度的辛普森法则求积法同时积分。这需要步长开始、中间和结束时的半径。我们有 $r_{\\mathrm{before}} = r_n$ 和 $r_{\\mathrm{after}} = r_{n+1}$。通过半步漂移可以获得中点半径的一致二阶估计：\n$$ r_{\\mathrm{mid}} = r_n + p_{r, n+1/2} \\frac{h}{2} $$\n相位更新则为：\n$$ \\phi_{n+1} = \\phi_n + \\frac{hL}{6} \\left( \\frac{1}{r_n^2} + \\frac{4}{r_{\\mathrm{mid}}^2} + \\frac{1}{r_{n+1}^2} \\right) $$\n对于适当选择的步长，该格式能保持 $(r, p_r)$ 子系统的辛结构，这以其出色的长期能量守恒性而闻名。\n\n**最终相位误差计算**\n对于两种方法，在积分到时间 $T$ 后，我们得到数值相位 $\\phi_{\\mathrm{num}}(T)$。精确相位是 $\\phi_{\\mathrm{exact}}(T) = \\omega T = 2\\pi N$。相位误差是在圆上的最小差值，计算为 $\\Delta\\phi = |\\text{mod}(\\phi_{\\mathrm{num}} - \\phi_{\\mathrm{exact}} + \\pi, 2\\pi) - \\pi|$。这将原始差值映射到 $[-\\pi, \\pi]$，然后取绝对值，确保结果在 $[0, \\pi]$ 区间内，如要求所述。然后将此值与 $\\Delta\\phi_{\\max}=0.1$ 进行比较，以确定是否满足相位保真度预算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function that executes the test suite and prints the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (r0, mu, N, rtol, target_steps_RK, n_symp)\n    test_cases = [\n        (10.0, 1.0, 200, 1e-8, 300000, 262144),      # Case A\n        (1.0, 1.0, 500, 1e-6, 200000, 131072),       # Case B\n        (7.0, 1.0, 4000, 1e-7, 1024000, 1048576),    # Case C\n    ]\n\n    # Maximum allowed phase error for Gravitational Wave budget\n    delta_phi_max = 0.1\n    \n    results = []\n\n    for case in test_cases:\n        r0, mu, N, rtol, target_steps_rk, n_symp = case\n\n        # --- Calculate orbit constants ---\n        L = math.sqrt(mu * r0)\n        omega = math.sqrt(mu / r0**3)\n        T_final = (2.0 * math.pi * N) / omega\n        \n        # --- Initial Conditions ---\n        y0 = np.array([r0, 0.0, 0.0])  # [r, p_r, phi]\n\n        # --- Run RK Integrator ---\n        h_max_rk = T_final / target_steps_rk\n        phi_rk = integrate_rk_adaptive(y0, T_final, L, mu, rtol, h_max_rk)\n        \n        # --- Run Symplectic Integrator ---\n        phi_sv = integrate_symplectic(y0, T_final, n_symp, L, mu)\n\n        # --- Calculate Phase Errors ---\n        phi_exact = omega * T_final\n        \n        # Calculate phase error for RK, wrapped to [0, pi]\n        err_rk_raw = phi_rk - phi_exact\n        delta_phi_rk = abs( (err_rk_raw + math.pi) % (2.0 * math.pi) - math.pi )\n        \n        # Calculate phase error for Symplectic, wrapped to [0, pi]\n        err_sv_raw = phi_sv - phi_exact\n        delta_phi_sv = abs( (err_sv_raw + math.pi) % (2.0 * math.pi) - math.pi )\n\n        # --- Check against budget ---\n        ok_rk = (delta_phi_rk = delta_phi_max)\n        ok_sv = (delta_phi_sv = delta_phi_max)\n        \n        results.extend([delta_phi_rk, delta_phi_sv, ok_rk, ok_sv])\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\n\ndef get_rhs(y, L, mu):\n    \"\"\"Computes the right-hand side of the ODE system.\"\"\"\n    r, p_r, _ = y\n    dr_dt = p_r\n    dp_r_dt = (L**2 / r**3) - (mu / r**2)\n    dphi_dt = L / r**2\n    return np.array([dr_dt, dp_r_dt, dphi_dt])\n\n\ndef integrate_rk_adaptive(y0, T_final, L, mu, rtol, h_max):\n    \"\"\"\n    Integrates the ODE system using an adaptive RK2(1) embedded method (Heun-Euler).\n    \"\"\"\n    y = np.copy(y0)\n    t = 0.0\n    h = h_max  # Initial step size guess\n    safety_factor = 0.9\n    \n    while t  T_final:\n        if t + h > T_final:\n            h = T_final - t\n\n        while True:\n            # Embedded RK2(1) / Heun-Euler method\n            k1 = get_rhs(y, L, mu)\n            \n            # Use k1 to step forward to get y at t+h for k2\n            y_temp = y + h * k1\n            # Prevent r from becoming non-positive in a bad step\n            if y_temp[0] = 0:\n                h *= 0.5\n                continue\n\n            k2 = get_rhs(y_temp, L, mu)\n            \n            # Higher-order (2nd) estimate\n            y_next = y + 0.5 * h * (k1 + k2)\n            \n            # Lower-order (1st) estimate is simply the Euler step\n            # Note: y_temp is the Euler step proposal\n            \n            # Estimate local error as the difference between the two\n            # We only control error on the dynamical variables r and p_r\n            error_est_vec = y_next - y_temp\n            error_norm = np.linalg.norm(error_est_vec[:2])\n\n            # Desired error based on relative tolerance\n            # Add a small absolute tolerance to prevent division by zero for p_r=0\n            scale = rtol * np.linalg.norm(y[:2]) + 1e-12 \n            \n            if error_norm  scale:\n                # Step is accepted\n                t += h\n                y = y_next\n                # Update next step size\n                if error_norm > 0:\n                    h_new = h * safety_factor * (scale / error_norm)**0.5\n                else: # Error is zero, can afford to increase step size\n                    h_new = h * 2.0\n                h = min(h_new, h_max)\n                break\n            else:\n                # Step is rejected, reduce step size and retry\n                h_new = h * safety_factor * (scale / error_norm)**0.5\n                h = max(h_new, 1e-9) # Prevent h from becoming too small\n                if t + h > T_final:\n                    h = T_final-t\n                    if h = 0: # If we are too close to end, finish\n                        return y[2]\n\n    return y[2]\n\n\ndef get_force(r, L, mu):\n    \"\"\"Computes the radial force F(r) = -dV_eff/dr.\"\"\"\n    return (L**2 / r**3) - (mu / r**2)\n    \n\ndef integrate_symplectic(y0, T_final, n_steps, L, mu):\n    \"\"\"\n    Integrates the ODE system using a 2nd order Störmer-Verlet method\n    with a Simpson-rule quadrature for the phase.\n    \"\"\"\n    r, p_r, phi = y0\n    h = T_final / n_steps\n\n    for _ in range(n_steps):\n        r_before = r\n        \n        # First half-kick for momentum\n        p_mid = p_r + 0.5 * h * get_force(r, L, mu)\n        \n        # Calculate midpoint radius for phase integration\n        r_mid = r + 0.5 * h * p_mid\n\n        # Full drift for position\n        r_after = r + h * p_mid\n        \n        # Second half-kick for momentum\n        p_r = p_mid + 0.5 * h * get_force(r_after, L, mu)\n        r = r_after\n        \n        # Update phase using Simpson's rule\n        delta_phi = (h * L / 6.0) * (1.0 / r_before**2 + 4.0 / r_mid**2 + 1.0 / r_after**2)\n        phi += delta_phi\n\n    return phi\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}