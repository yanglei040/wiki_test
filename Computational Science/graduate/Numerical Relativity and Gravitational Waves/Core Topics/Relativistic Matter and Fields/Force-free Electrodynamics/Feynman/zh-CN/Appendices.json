{
    "hands_on_practices": [
        {
            "introduction": "在广义相对论中，任何稳定的数值模拟都必须尊重时空的因果结构。Courant-Friedrichs-Lewy (CFL) 条件是这一原则的数学体现，它确保数值计算的区域能够覆盖物理信号传播的区域。本练习将引导你从第一性原理出发，在 3+1 分解的时空中推导 CFL 条件，将直减率 (lapse) $\\alpha$ 和移位矢量 (shift vector) $\\beta^i$ 等抽象概念与模拟的最大稳定时间步长直接联系起来。",
            "id": "3474662",
            "problem": "考虑在数值相对论中的一次无力电动力学演化，其中电磁场在一个固定的时空上通过 $3+1$ 分解进行演化，该分解使用直减率 $\\alpha$ 和移位矢量 $\\beta^{i}$。无力约束条件为 $E \\cdot B = 0$ 和 $B^{2} - E^{2} > 0$。假设一个均匀背景场，其中 $E = 0$ 且 $B = B_{0} \\hat{z}$，因此演化系统的主要（双曲）部分由弯曲时空中的麦克斯韦方程组控制，并采用几何化单位，其中 $c=1$。数值格式是一种有限体积、直线法离散，在每个空间方向上使用局部 Lax-Friedrichs (LLF) 通量，并结合一个三阶强保稳 Runge-Kutta (SSP RK) 时间积分器。空间网格是均匀的，间距为 $\\Delta x$、$\\Delta y$ 和 $\\Delta z$。\n\n在与 $3+1$ 叶状结构相关的局部标准正交标架中，电磁扰动以光速传播。在适应于叶状结构的坐标系中，方向 $i \\in \\{x,y,z\\}$ 上的坐标特征速度由直减率 $\\alpha$ 和移位矢量分量 $\\beta^{i}$ 的组合给出。每个方向上的 LLF 通量使用该方向上特征速度的最大绝对值作为其耗散参数。\n\n仅使用基本定律和核心定义，且不借助任何预先推导的稳定性公式，从第一性原理推导所述显式格式的 Courant-Friedrichs-Lewy (CFL) 条件对时间步长 $\\Delta t$ 的稳定性限制。然后，对于特定情况 $\\alpha = 0.8$, $\\beta^{x} = 0.1$, $\\beta^{y} = -0.05$, $\\beta^{z} = 0.0$, $\\Delta x = 0.25$, $\\Delta y = 0.20$, 以及 $\\Delta z = 0.50$，计算最大稳定时间步长 $\\Delta t_{\\max}$。\n\n将您的最终数值答案四舍五入到四位有效数字。以与质量标度 $M$ 相关联的几何单位表示时间。",
            "solution": "该问题要求推导用于在弯曲时空中求解无力电动力学方程的特定数值格式的 Courant-Friedrichs-Lewy (CFL) 稳定性条件，然后为给定的一组参数计算最大允许时间步长 $\\Delta t_{\\max}$。推导将基于第一性原理。\n\nCFL 条件是双曲型偏微分方程的显式时间积分格式稳定性的一个必要条件。它确保了网格点的数值依赖域包含物理依赖域。对于三维笛卡尔网格上的直线法，这一原则体现为对时间步长 $\\Delta t$ 的约束。网格点 $(i,j,k)$ 处的数值信息使用来自相邻点的信息进行更新。然而，物理信息以系统的特征速度传播。稳定性要求在一个时间步长内，任何物理信号的传播距离都不能超过数值模板的空间范围。\n\n对于一个在间距为 $\\Delta x$、$\\Delta y$、$\\Delta z$ 的网格上使用来自紧邻点的通量的有限体积格式，并结合一个显式时间积分器，其稳定性条件由下式给出：\n$$\n\\Delta t \\left( \\frac{\\lambda_{\\max}^x}{\\Delta x} + \\frac{\\lambda_{\\max}^y}{\\Delta y} + \\frac{\\lambda_{\\max}^z}{\\Delta z} \\right) \\le C_{\\text{CFL}}\n$$\n此处，$\\lambda_{\\max}^i$ 代表系统在坐标方向 $i$ 上的特征速度的最大绝对值，而 $C_{\\text{CFL}}$ 是 CFL 数，它是一个由所选时间积分格式的稳定域决定的常数。\n\n问题陈述中提到使用了一个三阶强保稳 Runge-Kutta (SSP RK3) 方法。标准的 SSP RK3 格式在与像所指定的局部 Lax-Friedrichs (LLF) 通量这样的一阶精度空间离散方法一起使用时，其一个基本性质是它的 CFL 数为 $C_{\\text{CFL}} = 1$。\n\n下一步是推导最大特征速度 $\\lambda_{\\max}^i$ 的表达式。演化系统的主要部分由麦克斯韦方程组控制。在广义相对论背景下，电磁扰动（光波）沿着零性测地线传播，对于零性测地线，时空间隔 $ds^2$ 为零。时空的几何由 $3+1$ 分解度规描述：\n$$\nds^2 = -\\alpha^2 dt^2 + \\gamma_{ij} (dx^i + \\beta^i dt)(dx^j + \\beta^j dt)\n$$\n其中 $\\alpha$ 是直减率，$\\beta^i$ 是移位矢量，而 $\\gamma_{ij}$ 是空间超曲面上的三维度规。\n\n对于零性轨迹，令 $ds^2=0$ 并除以 $(dt)^2$，我们得到扰动的坐标速度 $v^i = \\frac{dx^i}{dt}$ 的方程：\n$$\n\\alpha^2 = \\gamma_{ij} \\left(\\frac{dx^i}{dt} + \\beta^i\\right) \\left(\\frac{dx^j}{dt} + \\beta^j\\right) = \\gamma_{ij} (v^i + \\beta^i)(v^j + \\beta^j)\n$$\n问题指定了一个间距为 $\\Delta x$、$\\Delta y$ 和 $\\Delta z$ 的均匀网格。这意味着使用了一个局部笛卡尔坐标系，其中空间度规是欧几里得的，即 $\\gamma_{ij} = \\delta_{ij}$。经过此简化，方程变为：\n$$\n\\alpha^2 = \\sum_{i=1}^3 (v^i + \\beta^i)^2\n$$\n让我们定义一个新矢量 $V^i = v^i + \\beta^i$。方程则为 $\\sum_i (V^i)^2 = \\alpha^2$，这意味着矢量 $\\mathbf{V}$ 的大小等于直减率 $\\alpha$。我们可以将该矢量表示为 $\\mathbf{V} = \\alpha \\mathbf{n}$，其中 $\\mathbf{n}$ 是一个任意单位矢量 ($|\\mathbf{n}|=1$)。因此，坐标速度 $\\mathbf{v}$ 由下式给出：\n$$\nv^i = \\alpha n^i - \\beta^i\n$$\nCFL 条件所需的量 $\\lambda_{\\max}^x$ 是在考虑所有可能的传播方向 $\\mathbf{n}$ 的情况下，$x$ 方向坐标速度分量的最大可能绝对值：\n$$\n\\lambda_{\\max}^x = \\max_{|\\mathbf{n}|=1} |v^x| = \\max_{|\\mathbf{n}|=1} |\\alpha n^x - \\beta^x|\n$$\n单位矢量 $\\mathbf{n}$ 的分量满足 $(n^x)^2 + (n^y)^2 + (n^z)^2 = 1$，这意味着 $|n^x| \\le 1$。表达式 $|\\alpha n^x - \\beta^x|$ 的最大值出现在 $n^x$ 允许范围的边界上，即 $n^x = \\pm 1$。因此，最大值为 $\\max(|\\alpha - \\beta^x|, |-\\alpha - \\beta^x|) = \\max(|\\alpha - \\beta^x|, |\\alpha + \\beta^x|)$。由于对于一个有效的时空叶状结构，直减率 $\\alpha$ 必须为正，这可以简化为：\n$$\n\\lambda_{\\max}^x = \\alpha + |\\beta^x|\n$$\n根据对称性，$y$ 和 $z$ 方向上的最大特征速度为：\n$$\n\\lambda_{\\max}^y = \\alpha + |\\beta^y|\n$$\n$$\n\\lambda_{\\max}^z = \\alpha + |\\beta^z|\n$$\n将这些表达式和 $C_{\\text{CFL}} = 1$ 代回到 CFL 条件中，我们得到对时间步长的稳定性限制：\n$$\n\\Delta t \\le \\frac{1}{\\frac{\\alpha + |\\beta^x|}{\\Delta x} + \\frac{\\alpha + |\\beta^y|}{\\Delta y} + \\frac{\\alpha + |\\beta^z|}{\\Delta z}}\n$$\n当等式成立时，达到最大稳定时间步长 $\\Delta t_{\\max}$。\n\n现在我们为所提供的特定情况计算 $\\Delta t_{\\max}$ 的值：\n$\\alpha = 0.8$, $\\beta^{x} = 0.1$, $\\beta^{y} = -0.05$, $\\beta^{z} = 0.0$, $\\Delta x = 0.25$, $\\Delta y = 0.20$, 以及 $\\Delta z = 0.50$。\n\n首先，我们计算分母中的各项：\n$$\n\\frac{\\alpha + |\\beta^x|}{\\Delta x} = \\frac{0.8 + |0.1|}{0.25} = \\frac{0.9}{0.25} = 3.6\n$$\n$$\n\\frac{\\alpha + |\\beta^y|}{\\Delta y} = \\frac{0.8 + |-0.05|}{0.20} = \\frac{0.8 + 0.05}{0.20} = \\frac{0.85}{0.20} = 4.25\n$$\n$$\n\\frac{\\alpha + |\\beta^z|}{\\Delta z} = \\frac{0.8 + |0.0|}{0.50} = \\frac{0.8}{0.50} = 1.6\n$$\n这些项的和为：\n$$\nS = 3.6 + 4.25 + 1.6 = 9.45\n$$\n最大稳定时间步长是这个和的倒数：\n$$\n\\Delta t_{\\max} = \\frac{1}{S} = \\frac{1}{9.45} \\approx 0.1058201058...\n$$\n按要求四舍五入到四位有效数字，我们得到：\n$$\n\\Delta t_{\\max} \\approx 0.1058\n$$\n这个时间以几何化单位表示，通常由一个特征质量标度 $M$ 归一化，与问题的背景一致。",
            "answer": "$$\n\\boxed{0.1058}\n$$"
        },
        {
            "introduction": "编写代码相对容易，但编写*正确*的代码却充满挑战。本练习介绍“人造解方法” (method of manufactured solutions)，这是一种验证数值代码能否精确求解目标偏微分方程的关键技术。通过将代码运行结果与已知的解析解进行比较，我们可以衡量收敛率，从而对微分算子和约束方程的实现建立信心。",
            "id": "3474692",
            "problem": "您需要为一个在数值相对论背景下的二维无力电动力学（Force-Free Electrodynamics, FFE）切片实现一套完整的数值诊断、约束监控和收敛性评估。目标是从一个含时矢势构造出人工的电磁场，并在网格加密的情况下评估关键约束及其经验收敛阶。您的程序必须使用二阶中心有限差分和周期性边界条件来计算这些诊断量，并且必须为提供的一套参数集测试套件输出所要求的结果。\n\n从以下基本原理出发：\n- 在真空中以电场 $\\mathbf{E}$ 和磁场 $\\mathbf{B}$ 表示的 Maxwell 方程，特别是 Faraday 定律 $\\partial_t \\mathbf{B} = - \\nabla \\times \\mathbf{E}$ 和无散条件 $\\nabla \\cdot \\mathbf{B} = 0$。\n- FFE 简并条件 $\\mathbf{E} \\cdot \\mathbf{B} = 0$ 和磁主导不等式 $B^2 - E^2 \\ge 0$，其中 $B^2 = \\mathbf{B} \\cdot \\mathbf{B}$，$E^2 = \\mathbf{E} \\cdot \\mathbf{E}$。\n- 周期性的空间域，角度以弧度为单位，以及从光滑的矢势构造的人工场，以便进行系统性的收敛性测试。\n\n场的构造：\n- 考虑一个周期性方形区域 $[0, 2\\pi) \\times [0, 2\\pi)$，坐标为 $(x,y)$。\n- 定义一个标量势分量 $A_z(x,y,t)$ 并设置矢势 $\\mathbf{A}(x,y,t) = (0,0,A_z)$。使用以下光滑的拟设形式\n$$\nA_z(x,y,t) = \\frac{A_0}{k_x k_y} \\sin(k_x x)\\,\\sin(k_y y)\\,\\cos(\\omega t),\n$$\n其中 $A_0$、$k_x$、$k_y$ 和 $\\omega$ 是实数参数，且 $k_x > 0$ 和 $k_y > 0$。角度以弧度为单位。\n- 定义磁场为 $\\mathbf{B} = \\nabla \\times \\mathbf{A}$，电场为 $\\mathbf{E} = -\\partial_t \\mathbf{A}$。为 $\\mathbf{B}$ 的 $x$ 分量增加一个均匀、恒定的背景场 $B_{0}$，以保证 $\\nabla \\cdot \\mathbf{B} = 0$，同时确保 $|\\mathbf{B}|$ 有一个可调的下限：\n$$\n\\begin{aligned}\nB_x(x,y,t) = B_{0} + \\frac{A_0}{k_x} \\sin(k_x x)\\,\\cos(k_y y)\\,\\cos(\\omega t),\\\\\nB_y(x,y,t) = -\\frac{A_0}{k_y} \\cos(k_x x)\\,\\sin(k_y y)\\,\\cos(\\omega t),\\\\\nB_z(x,y,t) = 0,\\\\\nE_x(x,y,t) = 0,\\quad E_y(x,y,t)=0,\\quad E_z(x,y,t) = \\frac{A_0\\omega}{k_x k_y}\\sin(k_x x)\\,\\sin(k_y y)\\,\\sin(\\omega t).\n\\end{aligned}\n$$\n这些场在解析上满足 $\\mathbf{E}\\cdot \\mathbf{B} = 0$。恒定的背景场 $B_0$ 保持了 $\\nabla \\cdot \\mathbf{B}=0$。\n\n在固定时间 $t=t_0$ 计算的诊断量：\n1. 使用中心有限差分计算磁场的散度约束残差：\n   - 在一个大小为 $N \\times N$、具有周期性边界的均匀网格上，使用二阶中心有限差分计算 $\\partial_x$ 和 $\\partial_y$，从而计算离散散度 $\\nabla \\cdot \\mathbf{B} \\approx \\partial_x B_x + \\partial_y B_y$。\n   - 定义标量残差 $r_{\\mathrm{div}} = \\nabla \\cdot \\mathbf{B}$ 的均方根（RMS）$L^2$ 范数\n   $$\n   \\|r_{\\mathrm{div}}\\|_2 = \\sqrt{\\frac{1}{N^2}\\sum_{i,j} r_{\\mathrm{div}}(x_i,y_j)^2}.\n   $$\n2. 使用解析时间导数和有限差分空间旋度计算 Faraday 定律残差：\n   - 根据给定的场定义，在 $t=t_0$ 时刻计算解析的时间偏导数 $\\partial_t B_x$ 和 $\\partial_t B_y$。\n   - 使用二阶中心有限差分和周期性边界计算离散旋度分量 $(\\nabla \\times \\mathbf{E})_x \\approx \\partial_y E_z$ 和 $(\\nabla \\times \\mathbf{E})_y \\approx -\\partial_x E_z$。\n   - 构造矢量残差\n   $$\n   \\mathbf{r}_{\\mathrm{Faraday}} = \\partial_t \\mathbf{B} + \\nabla \\times \\mathbf{E},\n   $$\n   其分量为 $r_x = \\partial_t B_x + \\partial_y E_z$、$r_y = \\partial_t B_y - \\partial_x E_z$ 和 $r_z = 0$。计算其 RMS $L^2$ 范数\n   $$\n   \\|\\mathbf{r}_{\\mathrm{Faraday}}\\|_2 = \\sqrt{\\frac{1}{N^2}\\sum_{i,j} \\left(r_x(x_i,y_j)^2 + r_y(x_i,y_j)^2\\right)}.\n   $$\n3. 磁主导检验：\n   - 在每个网格点上计算 $B^2 - E^2$，其中 $B^2 = B_x^2 + B_y^2 + B_z^2$，$E^2 = E_x^2 + E_y^2 + E_z^2$。\n   - 定义一个布尔诊断量 $\\mathrm{mag\\_ok}$，如果 $\\min(B^2 - E^2) \\ge -\\varepsilon$ 则为真，否则为假，其中 $\\varepsilon$ 是一个很小的数值容差。使用尺度敏感的容差 $\\varepsilon = 10^{-12} \\max\\{\\langle B^2\\rangle, 1\\}$，其中 $\\langle B^2\\rangle$ 是 $B^2$ 在整个网格上的平均值。\n\n网格加密下的收敛性评估：\n- 对每个参数集，在三个相继加密的网格（大小分别为 $N$、$2N$ 和 $4N$，均匀间距分别为 $\\Delta x = \\Delta y = 2\\pi/N$、$\\pi/N$ 和 $\\pi/(2N)$）上评估范数 $\\|r_{\\mathrm{div}}\\|_2$ 和 $\\|\\mathbf{r}_{\\mathrm{Faraday}}\\|_2$。\n- 使用标准的加密比率估计经验收敛阶 $p_{\\mathrm{div}}$ 和 $p_{\\mathrm{Faraday}}$\n$$\np = \\log_2\\left(\\frac{E_{\\text{coarse}}}{E_{\\text{fine}}}\\right),\n$$\n应用于 $(N \\to 2N)$ 和 $(2N \\to 4N)$ 对，并为了稳定性，报告两个估计值的平均值。这里的 $E$ 表示相应的 RMS 范数。如果任何一对的范数低于数值下溢阈值，请优雅地处理。\n\n实现细节和数值要求：\n- 对所有空间导数使用二阶中心有限差分，周期性边界条件通过索引回绕实现。\n- 使用 $t_0 = 0.3$。\n- 所有三角函数使用弧度参数。\n- 所有量都是无量纲的；所有数值输出均报告为无量纲数。\n\n测试套件：\n对于每种情况，参数为 $(N_0, k_x, k_y, \\omega, A_0, B_0)$，程序必须在 $N_0$、$2N_0$ 和 $4N_0$ 的网格上进行计算。\n- 情况 1: $(N_0, k_x, k_y, \\omega, A_0, B_0) = (32, 1, 2, 0.4, 1.0, 0.8)$。\n- 情况 2: $(N_0, k_x, k_y, \\omega, A_0, B_0) = (24, 5, 4, 3.9, 1.0, 0.05)$。\n- 情况 3: $(N_0, k_x, k_y, \\omega, A_0, B_0) = (20, 2, 5, 0.3, 0.7, 0.1)$。\n\n要求的最终输出格式：\n- 对于每种情况，返回一个形式为 $[p_{\\mathrm{div}}, p_{\\mathrm{Faraday}}, \\mathrm{mag\\_ok}]$ 的列表，其中 $p_{\\mathrm{div}}$ 和 $p_{\\mathrm{Faraday}}$ 是浮点数，$\\mathrm{mag\\_ok}$ 是布尔值。\n- 您的程序应生成单行输出，其中包含三种情况的结果，格式为这些单情况列表的逗号分隔列表，不含空格，例如：\n\"[[pdiv1,pfar1,True],[pdiv2,pfar2,False],[pdiv3,pfar3,True]]\"。",
            "solution": "用户提供了一个数值相对论和无力电动力学（FFE）领域的问题。对问题陈述的严格验证表明，它在科学上是合理的、适定的且内部一致的。这是一个基于人造解方法的标准代码验证练习。因此，我将提供一个完整的解决方案。\n\n核心任务是为一个人造的电磁场构型实现一套数值诊断，并评估数值格式的收敛性。该解决方案分为几个逻辑步骤：网格和场的生成、数值导数的实现、物理约束残差的计算以及收敛性质的分析。\n\n**1. 解析框架与场的构造**\n\n该问题设定在一个二维周期性方形区域 $(x, y) \\in [0, 2\\pi) \\times [0, 2\\pi)$ 上。我们首先构造出在设计上就满足相关 FFE 条件的解析电磁场。这些场源于一个只有一个非零分量的含时矢势 $\\mathbf{A}(x,y,t) = (0, 0, A_z(x,y,t))$：\n$$\nA_z(x,y,t) = \\frac{A_0}{k_x k_y} \\sin(k_x x)\\,\\sin(k_y y)\\,\\cos(\\omega t)\n$$\n磁场 $\\mathbf{B}$ 和电场 $\\mathbf{E}$ 通过势定义为 $\\mathbf{B} = \\nabla \\times \\mathbf{A}$ 和 $\\mathbf{E} = -\\partial_t \\mathbf{A}$。这种构造从解析上保证了两个齐次 Maxwell 方程 $\\nabla \\cdot \\mathbf{B} = 0$ 和 $\\partial_t \\mathbf{B} + \\nabla \\times \\mathbf{E} = 0$ 的满足。\n\n问题指定了场的显式形式，包括加到 $B_x$ 上的一个恒定背景分量 $B_0$：\n$$\n\\begin{aligned}\nB_x(x,y,t) = B_{0} + \\frac{A_0}{k_x} \\sin(k_x x)\\,\\cos(k_y y)\\,\\cos(\\omega t) \\\\\nB_y(x,y,t) = -\\frac{A_0}{k_y} \\cos(k_x x)\\,\\sin(k_y y)\\,\\cos(\\omega t) \\\\\nB_z(x,y,t) = 0 \\\\\nE_x(x,y,t) = 0 \\\\\nE_y(x,y,t) = 0 \\\\\nE_z(x,y,t) = \\frac{A_0\\omega}{k_x k_y}\\sin(k_x x)\\,\\sin(k_y y)\\,\\sin(\\omega t)\n\\end{aligned}\n$$\n这些场也恒等地满足 FFE 简并条件 $\\mathbf{E} \\cdot \\mathbf{B} = 0$，因为 $\\mathbf{E}$ 纯粹在 $\\hat{z}$ 方向，而 $\\mathbf{B}$ 位于 $xy$ 平面内。所有场分量都在一个均匀的 $N \\times N$ 网格上、于固定时间 $t_0 = 0.3$ 进行计算。\n\n**2. 数值离散化与导数**\n\n诊断需要计算网格化场的空间导数。这些导数使用二阶中心有限差分来近似。对于一个在均匀间距 $h = \\Delta x = \\Delta y$ 网格上的标量场 $f(x_i, y_j)$，其偏导数为：\n$$\n\\left.\\frac{\\partial f}{\\partial x}\\right|_{i,j} \\approx \\frac{f_{i+1,j} - f_{i-1,j}}{2h}, \\quad \\left.\\frac{\\partial f}{\\partial y}\\right|_{i,j} \\approx \\frac{f_{i,j+1} - f_{i,j-1}}{2h}\n$$\n周期性边界条件通过索引回绕来处理，使得 $f_{N,j} = f_{0,j}$ 和 $f_{-1,j} = f_{N-1,j}$。在实现中，这可以通过 `numpy.roll` 高效实现，它可以在数组轴上执行循环移位。\n\n**3. 诊断量计算**\n\n在离散场上，于时间 $t_0$ 计算三个主要诊断量。\n\n**a. 散度约束残差：**\n解析上，$\\nabla \\cdot \\mathbf{B} = 0$。数值残差 $r_{\\mathrm{div}} = \\nabla \\cdot \\mathbf{B}$ 通过应用有限差分算子计算得出：\n$$\nr_{\\mathrm{div}}(x_i, y_j) \\approx \\frac{B_x(x_{i+1}, y_j) - B_x(x_{i-1}, y_j)}{2h} + \\frac{B_y(x_i, y_{j+1}) - B_y(x_i, y_{j-1})}{2h}\n$$\n违反的程度通过均方根 (RMS) $L^2$ 范数来量化：\n$$\n\\|r_{\\mathrm{div}}\\|_2 = \\sqrt{\\frac{1}{N^2}\\sum_{i,j=0}^{N-1} r_{\\mathrm{div}}(x_i,y_j)^2}\n$$\n\n**b. Faraday 定律残差：**\n解析上，$\\partial_t \\mathbf{B} + \\nabla \\times \\mathbf{E} = 0$。数值残差矢量 $\\mathbf{r}_{\\mathrm{Faraday}}$ 由 $\\mathbf{B}$ 的解析时间导数与数值计算的 $\\mathbf{E}$ 的旋度组合而成：\n$$\n\\mathbf{r}_{\\mathrm{Faraday}} = \\partial_t \\mathbf{B} + (\\nabla \\times \\mathbf{E})_{\\text{numerical}}\n$$\n给定 $\\mathbf{E} = (0, 0, E_z)$，其旋度为 $(\\nabla \\times \\mathbf{E}) = (\\partial_y E_z, -\\partial_x E_z, 0)$。残差分量为：\n$$\nr_x(x_i, y_j) = \\partial_t B_x(x_i, y_j, t_0) + \\frac{E_z(x_i, y_{j+1}) - E_z(x_i, y_{j-1})}{2h} \\\\\nr_y(x_i, y_j) = \\partial_t B_y(x_i, y_j, t_0) - \\frac{E_z(x_{i+1}, y_j) - E_z(x_{i-1}, y_j)}{2h}\n$$\n解析时间导数 $\\partial_t B_x$ 和 $\\partial_t B_y$ 根据其定义直接求值。然后计算该矢量残差的 RMS $L^2$ 范数。\n\n**c. 磁主导检验：**\n必须满足 FFE 条件 $B^2 - E^2 \\ge 0$。这在每个网格点上进行检验。为考虑浮点数的不精确性，条件放宽为 $\\min(B^2 - E^2) \\ge -\\varepsilon$，其中 $\\varepsilon$ 是一个小的、尺度敏感的容差，定义为 $\\varepsilon = 10^{-12} \\max\\{\\langle B^2\\rangle, 1\\}$，$\\langle B^2\\rangle$ 是 $B^2$ 的网格平均值。一个布尔值 $\\mathrm{mag\\_ok}$ 报告此检验的结果。\n\n**4. 收敛性分析**\n\n验证的核心是测量经验收敛阶 $p$。对于一个截断误差与 $h^k$ 成正比的数值方法，测得的误差范数 $E$ 应满足 $E \\propto h^k = (2\\pi/N)^k$。当分辨率加倍（$N \\to 2N$）时，误差应减少 $2^k$ 倍。收敛阶 $p$（应近似于 $k$）可以从粗网格（$E_{\\text{coarse}}$）和细网格（$E_{\\text{fine}}$）上的误差估计得出：\n$$\np = \\log_2\\left(\\frac{E_{\\text{coarse}}}{E_{\\text{fine}}}\\right)\n$$\n此分析对 $\\|r_{\\mathrm{div}}\\|_2$ 和 $\\|\\mathbf{r}_{\\mathrm{Faraday}}\\|_2$ 使用三种网格分辨率进行：$N_0$、$2N_0$ 和 $4N_0$。计算出 $p$ 的两个估计值（来自对 $(N_0, 2N_0)$ 和 $(2N_0, 4N_0)$），并报告它们的平均值。对于所使用的二阶有限差分格式，预期的收敛阶为 $p=2$。\n\n**5. 算法总结**\n\n最终的程序结构如下：\n1.  一个主函数遍历所提供的测试用例。\n2.  对每个用例，一个辅助函数被调用三次，分别对应网格大小 $N_0, 2N_0, 4N_0$。\n3.  辅助函数 `compute_diagnostics_for_res` 设置网格，计算解析场，计算数值导数，并计算两个残差范数和布尔磁主导检验。\n4.  主函数收集来自三个分辨率的范数。\n5.  然后通过对加密对的结果进行平均，计算出两个收敛率 $p_{\\mathrm{div}}$ 和 $p_{\\mathrm{Faraday}}$。\n6.  每个用例的最终结果 `[`$p_{\\mathrm{div}}, p_{\\mathrm{Faraday}}, \\mathrm{mag\\_ok}`$]` 被组装起来（使用最高分辨率 $4N_0$ 的 $\\mathrm{mag\\_ok}$ 值），并且所有用例的结果被格式化为指定的一个字符串。",
            "answer": "```python\nimport numpy as np\n\ndef compute_diagnostics_for_res(N, kx, ky, omega, A0, B0, t0):\n    \"\"\"\n    Computes FFE diagnostics for a given set of parameters and grid resolution.\n\n    Args:\n        N (int): Grid size (N x N).\n        kx, ky, omega, A0, B0 (float): Physical parameters for the fields.\n        t0 (float): Time at which to evaluate the fields.\n\n    Returns:\n        dict: A dictionary containing the computed norms and magnetic dominance check.\n    \"\"\"\n    L = 2.0 * np.pi\n    h = L / N\n\n    # Create a 2D grid\n    x = np.linspace(0, L, N, endpoint=False)\n    y = np.linspace(0, L, N, endpoint=False)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # Pre-compute trigonometric terms for efficiency\n    sin_kx_x = np.sin(kx * xx)\n    cos_kx_x = np.cos(kx * xx)\n    sin_ky_y = np.sin(ky * yy)\n    cos_ky_y = np.cos(ky * yy)\n    cos_om_t = np.cos(omega * t0)\n    sin_om_t = np.sin(omega * t0)\n\n    # Evaluate analytic fields on the grid\n    Bx_grid = B0 + (A0 / kx) * sin_kx_x * cos_ky_y * cos_om_t\n    By_grid = -(A0 / ky) * cos_kx_x * sin_ky_y * cos_om_t\n    Bz_grid = np.zeros_like(xx)\n    \n    Ex_grid = np.zeros_like(xx)\n    Ey_grid = np.zeros_like(xx)\n    Ez_grid = (A0 * omega / (kx * ky)) * sin_kx_x * sin_ky_y * sin_om_t\n\n    # Evaluate analytic time derivatives of B on the grid\n    dtBx_grid = -(A0 * omega / kx) * sin_kx_x * cos_ky_y * sin_om_t\n    dtBy_grid = (A0 * omega / ky) * cos_kx_x * sin_ky_y * sin_om_t\n\n    # --- Finite Difference Operators (2nd order centered, periodic) ---\n    def d_dx(field):\n        return (np.roll(field, -1, axis=0) - np.roll(field, 1, axis=0)) / (2 * h)\n\n    def d_dy(field):\n        return (np.roll(field, -1, axis=1) - np.roll(field, 1, axis=1)) / (2 * h)\n\n    # --- Diagnostic 1: Divergence Constraint Residual ---\n    d_dx_Bx = d_dx(Bx_grid)\n    d_dy_By = d_dy(By_grid)\n    r_div_grid = d_dx_Bx + d_dy_By\n    div_norm = np.sqrt(np.mean(r_div_grid**2))\n\n    # --- Diagnostic 2: Faraday Law Residual ---\n    d_dy_Ez = d_dy(Ez_grid)\n    d_dx_Ez = d_dx(Ez_grid)\n    \n    # Residual vector r = dt(B) + curl(E)\n    r_faraday_x = dtBx_grid + d_dy_Ez\n    r_faraday_y = dtBy_grid - d_dx_Ez\n    faraday_norm = np.sqrt(np.mean(r_faraday_x**2 + r_faraday_y**2))\n\n    # --- Diagnostic 3: Magnetic Dominance Check ---\n    B2_grid = Bx_grid**2 + By_grid**2\n    E2_grid = Ez_grid**2\n    B2_minus_E2 = B2_grid - E2_grid\n    \n    mean_B2 = np.mean(B2_grid)\n    epsilon = 1e-12 * np.maximum(mean_B2, 1.0)\n    \n    mag_ok = bool(np.min(B2_minus_E2) >= -epsilon)\n\n    return {'div_norm': div_norm, 'faraday_norm': faraday_norm, 'mag_ok': mag_ok}\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (32, 1, 2, 0.4, 1.0, 0.8),\n        (24, 5, 4, 3.9, 1.0, 0.05),\n        (20, 2, 5, 0.3, 0.7, 0.1),\n    ]\n    t0 = 0.3\n\n    all_case_results = []\n\n    for case in test_cases:\n        N0, kx, ky, omega, A0, B0 = case\n        resolutions = [N0, 2 * N0, 4 * N0]\n        \n        results_by_res = []\n        for N in resolutions:\n            res = compute_diagnostics_for_res(N, kx, ky, omega, A0, B0, t0)\n            results_by_res.append(res)\n        \n        div_norms = [r['div_norm'] for r in results_by_res]\n        faraday_norms = [r['faraday_norm'] for r in results_by_res]\n\n        # Handle cases where norms are extremely small (at machine precision floor)\n        # to prevent division by zero or NaN in log2. Replace with 0 convergence.\n        if div_norms[1] == 0 or div_norms[0] == 0:\n            p_div_12 = 0.0\n        else:\n            p_div_12 = np.log2(div_norms[0] / div_norms[1])\n            \n        if div_norms[2] == 0 or div_norms[1] == 0:\n            p_div_23 = 0.0\n        else:\n            p_div_23 = np.log2(div_norms[1] / div_norms[2])\n\n        p_div = (p_div_12 + p_div_23) / 2.0\n\n        if faraday_norms[1] == 0 or faraday_norms[0] == 0:\n            p_faraday_12 = 0.0\n        else:\n            p_faraday_12 = np.log2(faraday_norms[0] / faraday_norms[1])\n            \n        if faraday_norms[2] == 0 or faraday_norms[1] == 0:\n            p_faraday_23 = 0.0\n        else:\n            p_faraday_23 = np.log2(faraday_norms[1] / faraday_norms[2])\n        \n        p_faraday = (p_faraday_12 + p_faraday_23) / 2.0\n        \n        mag_ok = results_by_res[2]['mag_ok']\n        \n        all_case_results.append([p_div, p_faraday, mag_ok])\n\n    # Format the final output string exactly as specified\n    result_str_parts = []\n    for res in all_case_results:\n        part = f\"[{res[0]},{res[1]},{str(res[2])}]\"\n        result_str_parts.append(part)\n    \n    final_output_str = f\"[{','.join(result_str_parts)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "拥有一个稳定且经过验证的代码后，我们便可以着手处理有趣的物理情景，例如旋转黑洞的磁层。这个高级练习旨在比较两种在数值上维持磁场无散约束 $\\nabla \\cdot \\mathbf{B} = 0$ 的常用方法：约束输运 (Constrained Transport, CT) 和广义拉格朗日乘子 (Generalized Lagrange Multiplier, GLM) 清洗法。本练习将揭示数值方法的选择如何影响模拟的物理保真度，尤其是在时空曲率强的区域。",
            "id": "3474680",
            "problem": "您的任务是在一个简化的、但科学上合理的紧凑天体附近的无力电动力学模型中，使用轴对称旋转磁层作为驱动配置，实现并基准测试两种散度控制方案。该问题在广义相对论 (GR) 的 $3+1$ 分解以及无力电动力学 (FFE) 约束的框架内进行表述，并要求您在一个代表赤道切片的二维网格上演化电磁场。该基准测试必须比较约束输运 (CT) 与广义拉格朗日乘子 (GLM) 散度清理方案，跟踪在强曲率梯度下 FFE 约束 $E\\cdot B = 0$ 和 $B^2 - E^2 > 0$ 的保持情况。\n\n基本框架：\n\n- 对于欧拉观测者，在 $3+1$ GR 中的麦克斯韦方程组，其中直减率 (lapse) 为 $\\alpha$，移位矢量 (shift) 为 $\\beta^i$，空间度规为 $\\gamma_{ij}$：\n$$\\partial_t B^i = - \\epsilon^{ijk} \\partial_j\\left(\\alpha E_k - \\epsilon_{klm}\\beta^l B^m\\right),$$\n$$\\partial_t E^i = \\epsilon^{ijk} \\partial_j\\left(\\alpha B_k - \\epsilon_{klm}\\beta^l E^m\\right) - \\alpha J^i - \\alpha S^i,$$\n其中 $J^i$ 是电流密度，$S^i$ 集合了由曲率和电荷产生的源项。在本问题中，设置 $\\beta^i = 0$，在演化步骤中忽略 $J^i$ 和 $S^i$，并在每次更新后代数地强制施加 FFE 约束。\n\n- 无力电动力学 (Force-Free Electrodynamics) 约束：\n$$E\\cdot B = 0,$$\n$$B^2 - E^2 > 0,$$\n内积和范数使用空间度规 $\\gamma_{ij}$ 计算：$E\\cdot B = \\gamma_{ij} E^i B^j,\\quad E^2 = \\gamma_{ij} E^i E^j,\\quad B^2 = \\gamma_{ij} B^i B^j.$\n\n- 用于强曲率建模的静态时空中的各向同性 Schwarzschild 度规（设置 $G=c=1$），具有共形平直空间度规和直减率：\n$$\\psi(r) = 1 + \\frac{M}{2r},\\quad \\alpha(r) = \\frac{1 - \\frac{M}{2r}}{1 + \\frac{M}{2r}},\\quad \\gamma_{ij} = \\psi^4 \\delta_{ij},$$\n其中 $M$ 是质量参数，$r$ 是各向同性径向坐标。\n\n轴对称旋转体设置与更新：\n\n- 考虑一个二维周期性笛卡尔网格 $(x,y)$，它代表一个赤道切片 ($z=0$)，有 $N\\times N$ 个单元格，半域尺寸为 $L$，恒星半径为 $R$。初始化一个与 $z$ 轴对齐的偶极磁场，在平面内近似为 $B_z(x,y) = m/(r^3 + \\epsilon_0^3)$ 且 $B_x = B_y = 0$，其中磁矩为 $m$，$\\epsilon_0$ 是一个小的正则化参数。共转电场由理想共转关系给定\n$E = -(\\Omega \\times r)\\times B,$\n其中角速度 $\\Omega$ 指向 $+\\hat{z}$ 方向；具体来说，在赤道平面上，\n$$v = \\Omega\\,(-y,\\,x,\\,0),\\quad E = -v\\times B = (-\\Omega x B_z,\\,-\\Omega y B_z,\\,0).$$\n在恒星内部 ($r\\le R$)，每个时间步施加固定的共转边界数据；在外部，则演化场。\n\n- 使用 $2.5$ 维演化：演化 $B_x$、$B_y$ 和 $B_z$ 以及 $E_x$、$E_y$ 和 $E_z$，空间导数仅在 $x$ 和 $y$ 方向上计算，并设置 $\\partial_z\\equiv 0$。采用以下简化的 $3+1$ GR 麦克斯韦更新方程（其中 $\\beta^i=0$），使用直减率 $\\alpha(r)$ 作为旋度中的乘法因子：\n$$\\partial_t B_x = -\\partial_y\\left(\\alpha E_z\\right),\\quad \\partial_t B_y = +\\partial_x\\left(\\alpha E_z\\right),$$\n$$\\partial_t B_z = -\\left[\\partial_x\\left(\\alpha E_y\\right) - \\partial_y\\left(\\alpha E_x\\right)\\right],$$\n$$\\partial_t E_x = +\\partial_y\\left(\\alpha B_z\\right),\\quad \\partial_t E_y = -\\partial_x\\left(\\alpha B_z\\right),$$\n$$\\partial_t E_z = +\\left[\\partial_x\\left(\\alpha B_y\\right) - \\partial_y\\left(\\alpha B_x\\right)\\right].$$\n\n- 散度控制方案：\n\n(1) 约束输运 (Constrained Transport, CT)：使用 $\\alpha E$ 的离散旋度来更新 $B$，其差分格式在周期性边界条件下，当离散散度 $\\nabla\\cdot B$ 以中心差分 $\\partial_x B_x + \\partial_y B_y$ 计算时，能够精确保持其为零。\n\n(2) 广义拉格朗日乘子 (Generalized Lagrange Multiplier, GLM) 清理：通过一个服从电报方程的标量清理场 $\\psi$ 来增强 $B$ 的演化，\n$$\\partial_t \\psi + c_h^2 \\,\\nabla\\cdot B = - c_p^2 \\,\\psi,$$\n并通过增加项 $-\\nabla\\psi$ 来修正磁场的更新：\n$$\\partial_t B_x \\leftarrow \\partial_t B_x - \\partial_x \\psi,\\quad \\partial_t B_y \\leftarrow \\partial_t B_y - \\partial_y \\psi.$$\n此处 $c_h$ 是清理波速，$c_p$ 是阻尼参数。\n\n- 在每个演化步骤后通过代数投影强制施加 FFE 约束：\n(1) 正交性：设置 $E \\leftarrow E - \\lambda B$，其中 $\\lambda = (E\\cdot B)/(B\\cdot B)$，内积使用 $\\gamma_{ij}$ 计算。对于共形平直度规 $\\gamma_{ij}=\\psi^4\\delta_{ij}$，这简化为欧几里得比率 $\\lambda = (E_x B_x + E_y B_y + E_z B_z)/(B_x^2 + B_y^2 + B_z^2)$。\n(2) 磁主导上限：如果 $E^2 > B^2$（使用 $\\gamma_{ij}$ 计算），则将 $E$ 重新缩放为 $E \\leftarrow E \\sqrt{(B^2-\\varepsilon)/(E^2)}$，其中 $\\varepsilon > 0$ 是一个小数，以避免除以零。\n\n- 时间步进：使用由 Courant–Friedrichs–Lewy (CFL) 条件设定的均匀时间步长 $dt$，\n$dt = C_{\\mathrm{CFL}}\\,\\Delta x\\,\\min_{x,y} \\alpha(x,y),$\n其中 $C_{\\mathrm{CFL}}$ 在 $(0,1)$ 范围内，且 $\\Delta x = \\Delta y$。\n\n约束跟踪：\n\n- 为了评估每种散度控制方案在弯曲时空中保持 FFE 不变量的自然趋势，您必须在每个时间步进行代数 FFE 投影之前立即跟踪其违背情况。具体定义如下：\n(1) 最大正交性违背值\n$$\\mathcal{V}_\\mathrm{dot} = \\max_{t,\\,x,\\,y}\\left|E\\cdot B\\right|,$$\n使用 $\\gamma_{ij}$ 计算。\n(2) 最小磁主导余量\n$$\\mathcal{V}_\\mathrm{mag} = \\min_{t,\\,x,\\,y}\\left(B^2 - E^2\\right),$$\n使用 $\\gamma_{ij}$ 计算。$\\mathcal{V}_\\mathrm{mag}$ 的值越大越好；负值表示违背。\n\n基准测试标准：\n\n- 对于每个测试用例，当且仅当对于相同的演化，CT 产生的 $\\mathcalV_\\mathrm{dot}$ 严格小于 GLM 产生的 $\\mathcal{V}_\\mathrm{dot}$，且 $\\mathcal{V}_\\mathrm{mag}$ 严格大于 GLM 产生的 $\\mathcal{V}_\\mathrm{mag}$ 时，才判定 CT 优于 GLM。\n\n数值设置、参数和单位：\n\n- 在 $x$ 和 $y$ 方向上均使用周期性边界条件。\n- 采用自然单位制，其中 $G=c=1$；在此设置中所有量都是无量纲的。角速度 $\\Omega$ 以弧度/单位时间为单位指定。输出由布尔值组成，因此是无单位的。\n\n测试套件：\n\n- 使用磁矩 $m = 1$，恒星半径 $R = 0.5$，半域尺寸 $L = 2.0$，正则化参数 $\\epsilon_0 = 0.025$，以及 Courant 因子 $C_{\\mathrm{CFL}} = 0.3$。清理参数为 $c_h$ 和 $c_p$。必须实现以下测试用例：\n\n(1) 中等曲率和旋转情况：$(M,\\,\\Omega,\\,N,\\,N_t,\\,c_h,\\,c_p) = (0.2,\\,0.2,\\,64,\\,40,\\,1.0,\\,0.2)$。\n\n(2) 紧凑天体附近的强曲率情况：$(M,\\,\\Omega,\\,N,\\,N_t,\\,c_h,\\,c_p) = (0.8,\\,0.2,\\,64,\\,40,\\,1.0,\\,0.2)$。\n\n(3) 接近光柱区域的较高转速情况：$(M,\\,\\Omega,\\,N,\\,N_t,\\,c_h,\\,c_p) = (0.4,\\,0.6,\\,64,\\,40,\\,1.0,\\,0.2)$。\n\n答案规范和输出格式：\n\n- 对于每个测试用例，您必须计算一个布尔值 $b$。如果根据基准测试标准 CT 优于 GLM，则 $b$ 为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。例如，如果三个布尔值是 $b_1$、$b_2$ 和 $b_3$，则输出：$[b_1,b_2,b_3]$。\n\n角度单位规范：\n\n- 角速度 $\\Omega$ 必须解释为弧度/单位时间。\n\n无输入：\n\n- 您的程序必须在没有任何外部输入、文件或网络访问的情况下运行，并且只能使用指定的库。",
            "solution": "用户提供的问题经分析和验证，是科学上合理、适定且客观的。它概述了一个详细的数值基准测试，用于在紧凑天体周围的无力电动力学 (FFE) 背景下，比较两种散度控制方案：约束输运 (CT) 和广义拉格朗日乘子 (GLM)。物理模型、数学方程、数值方法和基准测试标准都得到了足够严格的规定，可以直接实现。该问题是计算天体物理学和数值相对论中一个不平凡但标准的练习，没有问题验证协议中列出的任何使其无效的缺陷。因此，提供了一个完整的解决方案。\n\n解决方案的核心在于实现一个数值求解器，用于求解广义相对论 $3+1$ 框架下的一组简化麦克斯韦方程组。该求解器专用于静态球对称时空（各向同性坐标下的 Schwarzschild 度规）和一个 2.5 维设置（在二维网格上对所有三个矢量分量进行演化，并假设在 $z$ 方向上没有变化）。\n\n**1. 网格与度规设置**\n\n首先，建立一个代表赤道平面的均匀笛卡尔网格。对于一个尺寸为 $N \\times N$、跨越 $[-L, L] \\times [-L, L]$ 区域的网格，生成其单元中心坐标 $(x,y)$。在该网格上，计算并存储从各向同性 Schwarzschild 度规导出的静态几何量。这些量是直减率函数 $\\alpha(r)$ 和共形因子 $\\psi(r)$，其中 $r = \\sqrt{x^2 + y^2}$ 是各向同性径向坐标。空间度规为 $\\gamma_{ij} = \\psi^4(r) \\delta_{ij}$。直减率 $\\alpha$ 充当可变光速，其在网格上的最小值通过 Courant–Friedrichs–Lewy (CFL) 条件决定了稳定的时间步长 $dt$：$dt = C_{\\mathrm{CFL}} \\Delta x \\min(\\alpha)$。\n\n**2. 初始条件**\n\n模拟始于一个轴对称磁偶极场，近似为 $B_z = m/(r^3 + \\epsilon_0^3)$ 和 $B_x=B_y=0$，其中 $m$ 是磁矩，$\\epsilon_0$ 是一个小的正则化常数，以避免原点的奇点。初始电场由理想共转条件确定，该条件适用于一个沿 $z$ 轴以角速度 $\\Omega$ 旋转的恒星：$E = -(\\Omega \\times r)\\times B$。这会产生非零的 $E_x$ 和 $E_y$ 分量。\n\n**3. 时间演化**\n\n偏微分方程组使用二阶 Runge-Kutta (RK2) 方法进行时间推进，该方法在精度和简单性之间取得了良好的平衡。演化方程为：\n$$\n\\partial_t \\vec{B} = -\\nabla \\times (\\alpha \\vec{E})\n$$\n$$\n\\partial_t \\vec{E} = +\\nabla \\times (\\alpha \\vec{B})\n$$\n计算这些方程右侧 (RHS) 所需的空间导数（旋度和散度）使用二阶中心有限差分进行近似。这一选择对于 CT 方案至关重要。\n\n**4. 散度控制方案**\n\n基准测试的核心是实现两种处理 $\\nabla \\cdot B = 0$ 约束的不同方法。\n\n-   **约束输运 (CT)**：在我们使用同位网格（collocated grid）的实现中，对 $\\vec{B}$ 演化中的旋度算子和散度算子均使用中心差分，这确保了如果 $\\nabla \\cdot B$ 初始为零，则在整个演化过程中它将保持在机器精度内为零（$\\partial_t(\\nabla \\cdot B) = \\nabla \\cdot (\\partial_t \\vec{B}) = -\\nabla \\cdot (\\nabla \\times (\\alpha \\vec{E})) \\equiv 0$）。这是通过使用未经修改的麦克斯韦方程组来实现的。\n\n-   **广义拉格朗日乘子 (GLM)**：该方法引入一个辅助标量场 $\\psi$，它通过一个阻尼波动方程（电报方程）进行演化。磁场的演化通过增加一个与该场梯度成正比的源项 $-\\nabla \\psi$ 来修正。该项的作用是将散度误差输运出计算域并将其阻尼掉。演化方程变为：\n    $$ \\partial_t \\vec{B} = -\\nabla \\times (\\alpha \\vec{E}) - \\nabla \\psi $$\n    $$ \\partial_t \\psi + c_h^2 (\\nabla \\cdot B) = - c_p^2 \\psi $$\n    其中 $c_h$ 和 $c_p$ 分别是散度误差的传播速度和阻尼率。\n\n**5. 约束强制与边界条件**\n\n在每个完整的时间步之后（即，在最终的 RK2 阶段之后），强制执行几个关键的物理和数值条件。\n\n-   **FFE 约束违背**：在应用任何校正之前，分析场的状态以量化 FFE 约束的违背程度。在网格上计算最大正交性违背值 $\\mathcal{V}_\\mathrm{dot} = \\max|E\\cdot B|$ 和最小磁主导余量 $\\mathcal{V}_\\mathrm{mag} = \\min(B^2 - E^2)$，并随时间更新。这些内积使用完整的空间度规 $\\gamma_{ij}$ 计算。\n\n-   **FFE 代数投影**：为防止数值解偏离 FFE 条件太远，对电场进行代数投影。首先，使其与磁场正交：$E \\leftarrow E - (E \\cdot B / B \\cdot B) B$。其次，如果磁主导条件 $B^2 > E^2$ 被违背，则重新缩放电场以恢复该条件：$E \\leftarrow E \\sqrt{(B^2 - \\varepsilon)/E^2}$。\n\n-   **边界条件**：问题指定了计算域外边缘的周期性边界条件，这通过有限差分格式自然处理。在恒星内部（对于 $r \\le R$），通过在每个时间步后将场值重置为其初始共转状态来施加“固定”边界条件。\n\n**6. 基准测试执行**\n\n对于测试套件中的每组参数，执行两个独立的模拟：一个使用 CT 方法，另一个使用 GLM 方法。两个模拟都完成后，比较它们记录的峰值违背度量（$\\mathcal{V}_\\mathrm{dot}$ 和 $\\mathcal{V}_\\mathrm{mag}$）。根据给定的严格标准，当且仅当 CT 产生的正交性违背值严格更小，且磁主导余量严格更大时，才判定 CT “更优”（$\\mathrm{True}$）。否则，判定为“非更优”（$\\mathrm{False}$）。收集所有测试用例的布尔结果，并按指定格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants from the problem specification\nM_MOMENT = 1.0\nR_STAR = 0.5\nL_DOMAIN = 2.0\nEPSILON_0 = 0.025\nCFL = 0.3\nEPSILON_FFE = 1e-10  # Small number for FFE projection to avoid sqrt(0)\nSAFETY_DENOM = 1e-30 # Small number for division safety\n\ndef compute_rhs(fields, method, grid_params, sim_params):\n    \"\"\"Computes the right-hand side of the evolution equations.\"\"\"\n    Bx, By, Bz, Ex, Ey, Ez = fields[:6]\n    psi_glm = fields[6] if method == 'GLM' else None\n\n    alpha, _, dx, dy = grid_params\n    _, _, _, _, ch, cp = sim_params\n\n    # Helper for periodic second-order centered differences\n    def d_dx(F):\n        return (np.roll(F, -1, axis=1) - np.roll(F, 1, axis=1)) / (2 * dx)\n    def d_dy(F):\n        return (np.roll(F, -1, axis=0) - np.roll(F, 1, axis=0)) / (2 * dy)\n\n    # Simplified Maxwell equations from the problem statement\n    dt_Bx = -d_dy(alpha * Ez)\n    dt_By = d_dx(alpha * Ez)\n    dt_Bz = -(d_dx(alpha * Ey) - d_dy(alpha * Ex))\n\n    dt_Ex = d_dy(alpha * Bz)\n    dt_Ey = -d_dx(alpha * Bz)\n    dt_Ez = d_dx(alpha * By) - d_dy(alpha * Bx)\n    \n    if method == 'GLM':\n        dpsi_dx = d_dx(psi_glm)\n        dpsi_dy = d_dy(psi_glm)\n        \n        # Modify B-field evolution with GLM source terms\n        dt_Bx -= dpsi_dx\n        dt_By -= dpsi_dy\n\n        # Evolve the GLM scalar field psi\n        div_B = d_dx(Bx) + d_dy(By) # In 2.5D, div_B = d(Bx)/dx + d(By)/dy\n        dt_psi_glm = -ch**2 * div_B - cp**2 * psi_glm\n        \n        return (dt_Bx, dt_By, dt_Bz, dt_Ex, dt_Ey, dt_Ez, dt_psi_glm)\n\n    return (dt_Bx, dt_By, dt_Bz, dt_Ex, dt_Ey, dt_Ez)\n\ndef evolve(method, M, Omega, N, Nt, ch, cp):\n    \"\"\"\n    Runs a single simulation for a given method and parameters.\n    Returns the max orthogonality violation and min magnetic margin.\n    \"\"\"\n    # Grid setup\n    dx = (2 * L_DOMAIN) / N\n    dy = dx\n    x_coords = np.linspace(-L_DOMAIN, L_DOMAIN, N, endpoint=False) + dx / 2\n    y_coords = x_coords\n    x, y = np.meshgrid(x_coords, y_coords)\n    r = np.sqrt(x**2 + y**2)\n    \n    # Metric quantities (using r_safe to avoid division by zero at origin)\n    r_safe = r + SAFETY_DENOM\n    psi_conf = 1 + M / (2 * r_safe)\n    alpha = (1 - M / (2 * r_safe)) / (1 + M / (2 * r_safe))\n    psi_conf_4 = psi_conf**4\n    \n    grid_params = (alpha, psi_conf_4, dx, dy)\n    sim_params = (M, Omega, N, Nt, ch, cp)\n\n    # Time step from CFL condition\n    dt = CFL * dx * np.min(alpha)\n\n    # Initial conditions for aligned rotator\n    Bz0 = M_MOMENT / (r**3 + EPSILON_0**3)\n    Bx0 = np.zeros_like(x)\n    By0 = np.zeros_like(y)\n    Ex0 = -Omega * x * Bz0\n    Ey0 = -Omega * y * Bz0\n    Ez0 = np.zeros_like(x)\n\n    # Initialize field list\n    fields = [Bx0.copy(), By0.copy(), Bz0.copy(), Ex0.copy(), Ey0.copy(), Ez0.copy()]\n    if method == 'GLM':\n        fields.append(np.zeros_like(x)) # Initialize psi_glm = 0\n\n    # Mask for inner boundary\n    inner_mask = r = R_STAR\n\n    # Violation trackers\n    max_V_dot = 0.0\n    min_V_mag = float('inf')\n\n    # Main evolution loop with RK2 integrator\n    for _ in range(Nt):\n        current_fields_np = np.array(fields, dtype=float)\n        \n        # RK2 Step 1 (Predictor)\n        k1_tuple = compute_rhs(fields, method, grid_params, sim_params)\n        k1 = np.array(k1_tuple, dtype=float)\n        mid_fields = [f for f in (current_fields_np + 0.5 * dt * k1)]\n\n        # RK2 Step 2 (Corrector)\n        k2_tuple = compute_rhs(mid_fields, method, grid_params, sim_params)\n        k2 = np.array(k2_tuple, dtype=float)\n\n        new_fields_np = current_fields_np + dt * k2\n        fields = [f for f in new_fields_np]\n        Bx, By, Bz, Ex, Ey, Ez = fields[:6]\n\n        # --- Track violations (before FFE projection and BCs) ---\n        E_dot_B_euc = Ex * Bx + Ey * By + Ez * Bz\n        V_dot_local = np.abs(psi_conf_4 * E_dot_B_euc)\n        max_V_dot = max(max_V_dot, np.max(V_dot_local[r > R_STAR]))\n\n        B2_euc = Bx**2 + By**2 + Bz**2\n        E2_euc = Ex**2 + Ey**2 + Ez**2\n        V_mag_local = psi_conf_4 * (B2_euc - E2_euc)\n        min_V_mag = min(min_V_mag, np.min(V_mag_local[r > R_STAR]))\n        \n        # --- Apply FFE projections and BCs ---\n        # 1. Orthogonality projection\n        B2_euc_safe = B2_euc + SAFETY_DENOM\n        lambda_p = E_dot_B_euc / B2_euc_safe\n        Ex_ortho = Ex - lambda_p * Bx\n        Ey_ortho = Ey - lambda_p * By\n        Ez_ortho = Ez - lambda_p * Bz\n        \n        # 2. Magnetic dominance projection\n        E2_ortho_euc = Ex_ortho**2 + Ey_ortho**2 + Ez_ortho**2\n        rescale_mask = E2_ortho_euc > B2_euc\n        scaling_factor = np.sqrt((B2_euc - EPSILON_FFE) / (E2_ortho_euc + SAFETY_DENOM))\n        \n        Ex_final = np.where(rescale_mask, Ex_ortho * scaling_factor, Ex_ortho)\n        Ey_final = np.where(rescale_mask, Ey_ortho * scaling_factor, Ey_ortho)\n        Ez_final = np.where(rescale_mask, Ez_ortho * scaling_factor, Ez_ortho)\n        \n        fields[3], fields[4], fields[5] = Ex_final, Ey_final, Ez_final\n\n        # Apply inner boundary condition (fixed corotation)\n        for i, field0 in enumerate([Bx0, By0, Bz0, Ex0, Ey0, Ez0]):\n            fields[i][inner_mask] = field0[inner_mask]\n\n    return max_V_dot, min_V_mag\n\ndef solve():\n    \"\"\"Main function to run the benchmark for all test cases and print results.\"\"\"\n    test_cases = [\n        # (M, Omega, N, Nt, c_h, c_p)\n        (0.2, 0.2, 64, 40, 1.0, 0.2),  # Moderate curvature and rotation\n        (0.8, 0.2, 64, 40, 1.0, 0.2),  # Strong curvature\n        (0.4, 0.6, 64, 40, 1.0, 0.2),  # High rotation\n    ]\n    \n    results = []\n\n    for case in test_cases:\n        M, Omega, N, Nt, ch, cp = case\n        \n        # Run CT simulation\n        V_dot_CT, V_mag_CT = evolve('CT', M, Omega, N, Nt, ch, cp)\n        \n        # Run GLM simulation\n        V_dot_GLM, V_mag_GLM = evolve('GLM', M, Omega, N, Nt, ch, cp)\n\n        # Apply the benchmark criterion\n        is_ct_better = (V_dot_CT  V_dot_GLM) and (V_mag_CT > V_mag_GLM)\n        results.append(is_ct_better)\n        \n    # Print final output in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}