{
    "hands_on_practices": [
        {
            "introduction": "The core of the Hybrid Monte Carlo algorithm is the numerical integration of Hamiltonian dynamics, which proposes new gauge configurations. This first practice focuses on the fundamental building block of this process: a single step of the leapfrog integrator . By working with the gauge group $\\mathrm{SU}(2)$, you will derive the equations of motion from first principles, implement the update for a single gauge link, and numerically verify the integrator's theoretical error scaling, providing a solid foundation for more complex systems.",
            "id": "3516854",
            "problem": "Implement, analyze, and test a single-step symmetric leapfrog update for one gauge link in a Hybrid Monte Carlo (HMC) integrator for Lattice Quantum Chromodynamics (QCD), specialized to the special unitary group of degree two ($\\mathrm{SU}(2)$). You must derive the force from first principles and quantify the leading local error of the integrator in terms of the Hamiltonian drift after a single step.\n\nStart from the following fundamental base:\n- The gauge link $U$ is an element of $\\mathrm{SU}(2)$, i.e., a $2\\times 2$ complex unitary matrix with determinant $1$.\n- The conjugate momentum $P$ is an element of the Lie algebra $\\mathfrak{su}(2)$, i.e., a $2\\times 2$ traceless anti-Hermitian matrix.\n- The Hamiltonian is separable: $H(U,P) = T(P) + S(U)$ with kinetic term $T(P) = -\\frac{1}{2}\\operatorname{Re}\\operatorname{Tr}(P^{2})$ (induced by the right-invariant metric $\\langle A,B\\rangle = -\\operatorname{Re}\\operatorname{Tr}(A B)$ on $\\mathfrak{su}(2)$) and potential term $S(U) = -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(U M^{\\dagger})$, where $\\alpha > 0$ is a real coupling and $M\\in \\mathrm{SU}(2)$ is a fixed staple-like matrix.\n- Variations of $U$ are of the form $\\delta U = A U$ with $A\\in \\mathfrak{su}(2)$, and the force $F(U)\\in \\mathfrak{su}(2)$ is defined by $\\delta S = \\langle F(U), A\\rangle$ for all such $A$.\n- Symplectic dynamics on the group manifold follow Hamilton’s equations: $\\dot U = P U$ and $\\dot P = -F(U)$.\n- The symmetric leapfrog (also known as velocity Verlet) update with step size $\\epsilon$ is the composition of a half momentum kick, a full link drift, and a half momentum kick.\n\nTasks:\n1) Derive from the above base an explicit expression for the force $F(U)$ in terms of $U$ and $M$, making clear use of the inner product $\\langle \\cdot,\\cdot\\rangle$ and the projection onto $\\mathfrak{su}(2)$. You must use only the properties that $\\delta U = A U$ with $A\\in \\mathfrak{su}(2)$ and that $\\mathrm{SU}(2)$ is a subgroup of the unitary group with the given inner product. Your final expression must be a projection of a matrix built only from $U$ and $M$ onto $\\mathfrak{su}(2)$.\n2) Using the derived force, implement a single symmetric leapfrog step:\n- Half kick: $P \\leftarrow P - \\frac{\\epsilon}{2} F(U)$.\n- Drift: $U \\leftarrow \\exp(\\epsilon P)\\, U$, where the exponential is the matrix exponential mapping $\\mathfrak{su}(2)$ to $\\mathrm{SU}(2)$.\n- Half kick: $P \\leftarrow P - \\frac{\\epsilon}{2} F(U)$.\nEnsure $U\\in \\mathrm{SU}(2)$ and $P\\in \\mathfrak{su}(2)$ are preserved up to numerical roundoff. You may use the closed-form exponential in $\\mathrm{SU}(2)$ or a general matrix exponential.\n3) For each test case below, compute the Hamiltonian value $H_{\\text{before}} = H(U,P)$ at the initial state and $H_{\\text{after}} = H(U',P')$ after one leapfrog step. Define the local energy error $\\Delta H = H_{\\text{after}} - H_{\\text{before}}$. Estimate the leading $\\mathcal{O}(\\epsilon^{3})$ error coefficient by the scaled quantity $C \\approx \\frac{\\Delta H}{\\epsilon^{3}}$.\n4) Angles must be interpreted and computed in radians.\n5) Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, i.e., $[C_{1},C_{2},C_{3}]$, where $C_{k}$ is the float for test case $k$.\n\nTest suite specification. Use the Pauli matrices $\\sigma_{1},\\sigma_{2},\\sigma_{3}$ and the parametrizations:\n- For any real axis vector $\\mathbf{n}$ with $\\lVert \\mathbf{n}\\rVert=1$ and angle $\\theta$, define $U(\\theta,\\mathbf{n}) = \\exp\\!\\big(i\\,\\theta\\, \\mathbf{n}\\cdot \\boldsymbol{\\sigma}\\big) = \\cos(\\theta)\\,\\mathbf{1}_{2} + i \\sin(\\theta)\\,\\mathbf{n}\\cdot \\boldsymbol{\\sigma}$, which lies in $\\mathrm{SU}(2)$.\n- For any real vector $\\mathbf{w}$, define $P(\\mathbf{w}) = i\\,\\mathbf{w}\\cdot \\boldsymbol{\\sigma}\\in \\mathfrak{su}(2)$.\n\nImplement and evaluate the following three cases:\n- Case $1$ (general case):\n  - $\\alpha = 1.1$, $\\epsilon = 0.05$.\n  - $U = U(\\theta_{U}, \\mathbf{n}_{U})$ with $\\theta_{U} = 0.8$, $\\mathbf{n}_{U} = \\frac{(1,2,3)}{\\lVert(1,2,3)\\rVert}$.\n  - $M = U(\\theta_{M}, \\mathbf{n}_{M})$ with $\\theta_{M} = 0.3$, $\\mathbf{n}_{M} = (0,1,0)$.\n  - $P = P(\\mathbf{w})$ with $\\mathbf{w} = 0.4\\,(1,0,0)$.\n- Case $2$ (small step size to probe scaling):\n  - $\\alpha = 0.9$, $\\epsilon = 0.01$.\n  - $U = U(\\theta_{U}, \\mathbf{n}_{U})$ with $\\theta_{U} = 1.2$, $\\mathbf{n}_{U} = \\frac{(0.3,0.4,0.5)}{\\lVert(0.3,0.4,0.5)\\rVert}$.\n  - $M = U(\\theta_{M}, \\mathbf{n}_{M})$ with $\\theta_{M} = 0.7$, $\\mathbf{n}_{M} = (0,0,1)$.\n  - $P = P(\\mathbf{w})$ with $\\mathbf{w} = 0.2\\,\\frac{(0.2,0.8,0.5)}{\\lVert(0.2,0.8,0.5)\\rVert}$.\n- Case $3$ (edge case with zero initial momentum):\n  - $\\alpha = 1.5$, $\\epsilon = 0.02$.\n  - $U = U(\\theta_{U}, \\mathbf{n}_{U})$ with $\\theta_{U} = 0.5$, $\\mathbf{n}_{U} = \\frac{(0,1,1)}{\\lVert(0,1,1)\\rVert}$.\n  - $M = U(\\theta_{M}, \\mathbf{n}_{M})$ with $\\theta_{M} = 1.0$, $\\mathbf{n}_{M} = (1,0,0)$.\n  - $P = P(\\mathbf{w})$ with $\\mathbf{w} = (0,0,0)$.\n\nFinal output format:\n- Your program must print exactly one line of the form $[C_{1},C_{2},C_{3}]$, where each $C_{k}$ is the floating-point estimate of $\\Delta H/\\epsilon^{3}$ for the corresponding case, with no additional text.",
            "solution": "We base the construction on Hamiltonian dynamics on the Lie group $\\mathrm{SU}(2)$ with right-invariant kinetic energy and a gauge-like potential. The fundamental definitions are:\n- The link $U\\in \\mathrm{SU}(2)$ evolves via $\\dot U = P U$, where $P\\in \\mathfrak{su}(2)$ is the right-invariant momentum.\n- The momentum evolves via $\\dot P = -F(U)$, where the force $F(U)$ is the variational derivative of the potential $S(U)$ with respect to the right-invariant metric $\\langle A,B\\rangle = -\\operatorname{Re}\\operatorname{Tr}(A B)$ on $\\mathfrak{su}(2)$.\n\nDerivation of the force. Let the action be $S(U) = -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(U M^{\\dagger})$ with given $M\\in \\mathrm{SU}(2)$ and $\\alpha>0$. A general variation of $U$ tangent to $\\mathrm{SU}(2)$ at $U$ is $\\delta U = A U$ with $A\\in \\mathfrak{su}(2)$. Compute the first variation:\n\n$$\n\\delta S \\;=\\; -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(\\delta U\\, M^{\\dagger})\n\\;=\\; -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(A\\, U M^{\\dagger}).\n$$\n\nWe want to express $\\delta S$ in the form $\\delta S = \\langle F(U), A\\rangle = -\\operatorname{Re}\\operatorname{Tr}(F(U)\\, A)$ that holds for all $A\\in \\mathfrak{su}(2)$. Note the two facts:\n- For any $A\\in \\mathfrak{su}(2)$ and any matrix $X$, $\\operatorname{Re}\\operatorname{Tr}(A X) = \\operatorname{Re}\\operatorname{Tr}\\big(A\\, \\frac{1}{2}(X - X^{\\dagger})\\big)$ since $A$ is anti-Hermitian and pairs to zero with the Hermitian part in the real trace.\n- If we add any multiple of the identity to $F(U)$, it pairs to zero with $A$ because $\\operatorname{Tr}(A) = 0$.\n\nTherefore, for $\\delta S = -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(A\\, U M^{\\dagger})$ to equal $-\\operatorname{Re}\\operatorname{Tr}(F(U) A)$ for all $A\\in \\mathfrak{su}(2)$, it suffices to choose $F(U)$ to be the projection of $\\alpha\\, U M^{\\dagger}$ onto $\\mathfrak{su}(2)$ using the inner product induced by $-\\operatorname{Re}\\operatorname{Tr}(\\cdot\\,\\cdot)$. Writing the anti-Hermitian projection as $\\mathrm{AH}(X) = \\frac{1}{2}(X - X^{\\dagger})$ and then removing trace, the force is\n\n$$\nF(U) \\;=\\; \\mathrm{proj}_{\\mathfrak{su}(2)}\\!\\big(\\alpha\\, U M^{\\dagger}\\big)\n\\;=\\; \\alpha\\left[\\frac{1}{2}\\big( U M^{\\dagger} - M U^{\\dagger}\\big) \\;-\\; \\frac{1}{2}\\operatorname{Tr}\\!\\left(\\frac{1}{2}\\big( U M^{\\dagger} - M U^{\\dagger}\\big)\\right)\\mathbf{1}_{2}\\right].\n$$\n\nBy construction, $F(U)\\in \\mathfrak{su}(2)$ and satisfies $\\delta S = -\\operatorname{Re}\\operatorname{Tr}(F(U) A)$ for all $A\\in \\mathfrak{su}(2)$, so the Hamilton equation $\\dot P = -F(U)$ follows.\n\nLeapfrog integrator. For a separable Hamiltonian $H(U,P)=T(P)+S(U)$, the symmetric leapfrog with step size $\\epsilon$ composes the exact flows of $T$ and $S$ in a Strang splitting:\n- Half kick under $S$: $P \\leftarrow P - \\frac{\\epsilon}{2} F(U)$ with $U$ fixed.\n- Drift under $T$: $U \\leftarrow \\exp(\\epsilon P)\\, U$ with $P$ fixed.\n- Half kick under $S$: $P \\leftarrow P - \\frac{\\epsilon}{2} F(U)$ with updated $U$.\n\nOn $\\mathrm{SU}(2)$, if $P\\in \\mathfrak{su}(2)$ is anti-Hermitian traceless, then $P = i\\,\\mathbf{w}\\cdot \\boldsymbol{\\sigma}$ for some $\\mathbf{w}\\in \\mathbb{R}^{3}$ and $P^{2} = -\\lVert \\mathbf{w}\\rVert^{2}\\,\\mathbf{1}_{2}$. Hence the exponential has a closed form\n\n$$\n\\exp(\\epsilon P) \\;=\\; \\cos(\\epsilon \\lVert \\mathbf{w}\\rVert)\\,\\mathbf{1}_{2} \\;+\\; \\frac{\\sin(\\epsilon \\lVert \\mathbf{w}\\rVert)}{\\lVert \\mathbf{w}\\rVert}\\, P,\n$$\n\nwith the limiting value $\\mathbf{1}_{2} + \\epsilon P$ as $\\lVert \\mathbf{w}\\rVert \\to 0$. This guarantees that the drift stays on $\\mathrm{SU}(2)$ up to floating-point error, provided $P$ is kept in $\\mathfrak{su}(2)$ by construction of the kicks.\n\nHamiltonian and local error. With $T(P) = -\\frac{1}{2}\\operatorname{Re}\\operatorname{Tr}(P^{2})$ and $S(U) = -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(U M^{\\dagger})$, the Hamiltonian evaluated before and after one leapfrog step yields\n\n$$\n\\Delta H \\;=\\; H_{\\text{after}} - H_{\\text{before}}.\n$$\n\nBecause the leapfrog method is a second-order, symmetric, symplectic integrator, its local energy error per step scales as $\\mathcal{O}(\\epsilon^{3})$ for smooth $H$. One can estimate the leading coefficient by computing $C \\approx \\frac{\\Delta H}{\\epsilon^{3}}$ for a given small $\\epsilon$. For symmetric splittings, the modified (shadow) Hamiltonian that is exactly conserved differs from the true $H$ by $\\mathcal{O}(\\epsilon^{2})$ terms, and the observed one-step drift in $H$ itself is $\\mathcal{O}(\\epsilon^{3})$ due to cancellation of even-order terms in a single-step symmetric update.\n\nNumerical implementation details:\n- Parameterization of $U$ as $U(\\theta,\\mathbf{n}) = \\cos(\\theta)\\,\\mathbf{1}_{2} + i \\sin(\\theta)\\,\\mathbf{n}\\cdot \\boldsymbol{\\sigma}$ for unit $\\mathbf{n}$ ensures $U\\in \\mathrm{SU}(2)$.\n- Parameterization of $P$ as $P(\\mathbf{w}) = i\\,\\mathbf{w}\\cdot \\boldsymbol{\\sigma}$ ensures $P\\in \\mathfrak{su}(2)$.\n- The projection $\\mathrm{proj}_{\\mathfrak{su}(2)}(X)$ is implemented as $\\frac{1}{2}(X - X^{\\dagger})$ followed by removal of the trace by subtracting $\\frac{1}{2}\\operatorname{Tr}(\\cdot)\\,\\mathbf{1}_{2}$.\n- The drift uses the closed form exponential on $\\mathrm{SU}(2)$ with careful handling of the small-norm limit.\n- The Hamiltonian terms are scalars computed via real parts of traces, with no physical units and all angles in radians as required.\n\nTest suite coverage:\n- Case $1$ uses moderate noncommuting $U$, $M$, and nonzero $P$ with $\\epsilon = 0.05$ to test the general path.\n- Case $2$ uses a smaller $\\epsilon = 0.01$ to highlight the $\\epsilon^{3}$ scaling.\n- Case $3$ uses zero initial momentum $P=0$ and nontrivial $U$, $M$ to probe the correctness of force kicks from rest.\n\nThe program computes $C_{k} = \\Delta H_{k}/\\epsilon_{k}^{3}$ for all three cases and prints a single line $[C_{1},C_{2},C_{3}]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Pauli matrices\nsigma1 = np.array([[0, 1], [1, 0]], dtype=complex)\nsigma2 = np.array([[0, -1j], [1j, 0]], dtype=complex)\nsigma3 = np.array([[1, 0], [0, -1]], dtype=complex)\npaulis = np.array([sigma1, sigma2, sigma3], dtype=complex)\nI2 = np.eye(2, dtype=complex)\n\ndef su2_from_axis_angle(theta: float, axis: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Construct U = cos(theta) I + i sin(theta) (n · sigma), for unit axis n.\n    \"\"\"\n    axis = np.asarray(axis, dtype=float)\n    nrm = np.linalg.norm(axis)\n    if nrm == 0.0:\n        return I2.copy()\n    n = axis / nrm\n    H = n[0] * sigma1 + n[1] * sigma2 + n[2] * sigma3  # Hermitian\n    return np.cos(theta) * I2 + 1j * np.sin(theta) * H\n\ndef p_from_vec(w: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Construct P = i (w · sigma), which is anti-Hermitian and traceless.\n    \"\"\"\n    w = np.asarray(w, dtype=float)\n    H = w[0] * sigma1 + w[1] * sigma2 + w[2] * sigma3  # Hermitian traceless\n    return 1j * H\n\ndef proj_su2(X: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Project a 2x2 complex matrix X onto su(2) using the inner product -Re Tr(A B).\n    This is the anti-Hermitian part with trace removed.\n    \"\"\"\n    AH = 0.5 * (X - X.conj().T)  # anti-Hermitian\n    tr = 0.5 * np.trace(AH)      # complex scalar; for su(2), subtract (tr)*I\n    return AH - tr * I2\n\ndef exp_su2(eps: float, P: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute exp(eps * P) for P in su(2) using the closed form:\n    exp(eps P) = cos(eps*|w|) I + (sin(eps*|w|)/|w|) P with P = i w·sigma.\n    Handles the small-norm limit stably.\n    \"\"\"\n    # Norm |w| satisfies: P^2 = -|w|^2 I, and -Tr(P^2)/2 = |w|^2\n    P2 = P @ P\n    # Tr(P^2) should be negative real\n    trP2 = np.trace(P2)\n    # Use real part for safety\n    w2 = -np.real(trP2) / 2.0\n    # Numerical guard\n    if w2 < 0:\n        # Clamp tiny negative due to numerical rounding\n        if w2 > -1e-14:\n            w2 = 0.0\n        else:\n            raise RuntimeError(\"Encountered negative w^2 beyond rounding.\")\n    wnorm = np.sqrt(w2)\n    if wnorm < 1e-14:\n        # Use series expansion: exp(eps P) ≈ I + eps P + (eps^2/2) P^2\n        return I2 + eps * P + 0.5 * (eps ** 2) * (P2)\n    c = np.cos(eps * wnorm)\n    s_over_w = np.sin(eps * wnorm) / wnorm\n    return c * I2 + s_over_w * P\n\ndef force(U: np.ndarray, alpha: float, M: np.ndarray) -> np.ndarray:\n    \"\"\"\n    F(U) = proj_su2(alpha * U * M†)\n    \"\"\"\n    return proj_su2(alpha * (U @ M.conj().T))\n\ndef kinetic(P: np.ndarray) -> float:\n    # T(P) = -0.5 Re Tr(P^2)\n    return float(-0.5 * np.real(np.trace(P @ P)))\n\ndef potential(U: np.ndarray, alpha: float, M: np.ndarray) -> float:\n    # S(U) = - alpha Re Tr(U M†)\n    return float(-alpha * np.real(np.trace(U @ M.conj().T)))\n\ndef hamiltonian(U: np.ndarray, P: np.ndarray, alpha: float, M: np.ndarray) -> float:\n    return kinetic(P) + potential(U, alpha, M)\n\ndef leapfrog_step(U: np.ndarray, P: np.ndarray, alpha: float, M: np.ndarray, eps: float):\n    \"\"\"\n    Perform one symmetric leapfrog step:\n    P <- P - (eps/2) F(U)\n    U <- exp(eps P) U\n    P <- P - (eps/2) F(U)\n    \"\"\"\n    # Half-kick\n    F = force(U, alpha, M)\n    P_half = P - 0.5 * eps * F\n    # Drift\n    R = exp_su2(eps, P_half)\n    U_new = R @ U\n    # Half-kick\n    F_new = force(U_new, alpha, M)\n    P_new = P_half - 0.5 * eps * F_new\n    return U_new, P_new\n\ndef case_general():\n    alpha = 1.1\n    eps = 0.05\n    # U: theta=0.8, axis=(1,2,3)/||...||\n    axis_U = np.array([1.0, 2.0, 3.0])\n    axis_U /= np.linalg.norm(axis_U)\n    U = su2_from_axis_angle(0.8, axis_U)\n    # M: theta=0.3, axis=(0,1,0)\n    M = su2_from_axis_angle(0.3, np.array([0.0, 1.0, 0.0]))\n    # P: w=0.4*(1,0,0)\n    P = p_from_vec(np.array([0.4, 0.0, 0.0]))\n    return U, P, alpha, M, eps\n\ndef case_small_step():\n    alpha = 0.9\n    eps = 0.01\n    # U: theta=1.2, axis=(0.3,0.4,0.5)/||...||\n    axis = np.array([0.3, 0.4, 0.5])\n    axis /= np.linalg.norm(axis)\n    U = su2_from_axis_angle(1.2, axis)\n    # M: theta=0.7, axis=(0,0,1)\n    M = su2_from_axis_angle(0.7, np.array([0.0, 0.0, 1.0]))\n    # P: w=0.2 * normalized (0.2,0.8,0.5)\n    w = np.array([0.2, 0.8, 0.5])\n    w = 0.2 * w / np.linalg.norm(w)\n    P = p_from_vec(w)\n    return U, P, alpha, M, eps\n\ndef case_zero_momentum():\n    alpha = 1.5\n    eps = 0.02\n    # U: theta=0.5, axis=(0,1,1)/||...||\n    axis = np.array([0.0, 1.0, 1.0])\n    axis /= np.linalg.norm(axis)\n    U = su2_from_axis_angle(0.5, axis)\n    # M: theta=1.0, axis=(1,0,0)\n    M = su2_from_axis_angle(1.0, np.array([1.0, 0.0, 0.0]))\n    # P: zero\n    P = np.zeros((2, 2), dtype=complex)\n    return U, P, alpha, M, eps\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        case_general(),\n        case_small_step(),\n        case_zero_momentum(),\n    ]\n\n    results = []\n    for U, P, alpha, M, eps in test_cases:\n        # Compute initial Hamiltonian\n        H_before = hamiltonian(U, P, alpha, M)\n        # One leapfrog step\n        U_new, P_new = leapfrog_step(U, P, alpha, M, eps)\n        # Compute final Hamiltonian\n        H_after = hamiltonian(U_new, P_new, alpha, M)\n        dH = H_after - H_before\n        # Estimate leading O(eps^3) coefficient\n        if eps == 0:\n            c = float('nan')\n        else:\n            c = dH / (eps ** 3)\n        results.append(c)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Having constructed a basic integrator, we now address the crucial issue of computational efficiency. In realistic lattice QCD simulations, the forces from the gauge and fermion components of the action have vastly different computational costs, making a multiple time-scale integration scheme essential . This exercise guides you through the process of optimizing such an integrator, determining the ideal ratio of step sizes to minimize the overall energy violation under a fixed computational budget.",
            "id": "3516754",
            "problem": "Consider the Hybrid Monte Carlo (HMC) algorithm for lattice Quantum Chromodynamics (QCD), where the action is split into a gauge part $S_{g}$ and a pseudofermion part $S_{f}$. In a two-level multiple time scale integrator (Sexton–Weingarten scheme) using a reversible, symplectic, second-order update, suppose the molecular dynamics trajectory length is fixed to $\\tau = 1$ (in molecular dynamics time units). Let the number of coarse steps for the fermion force be $N_{f}$ with step size $h_{f} = \\tau / N_{f}$, and the number of fine steps for the gauge force be $N_{g}$ with step size $h_{g} = \\tau / N_{g}$. Define the time-scale ratio by $m = N_{g}/N_{f}$, so that $h_{g} = h_{f}/m$.\n\nAssume the leading-order (in the step sizes) model for the expected energy violation is\n$$\n\\langle \\Delta H \\rangle \\approx C_{g}\\, h_{g}^{2} + C_{f}\\, h_{f}^{2},\n$$\nwhere the effective coefficients are given by $C_{i} = \\zeta_{i}\\, \\|F_{i}\\|^{2}$, $i \\in \\{g,f\\}$, with $\\|F_{g}\\|$ and $\\|F_{f}\\|$ denoting measured $\\ell_{2}$ norms of the gauge and fermion forces, respectively, and $\\zeta_{g}$ and $\\zeta_{f}$ are measured positive constants that encapsulate the integrator’s leading commutator structure and the geometry of the flow.\n\nYou have performed short calibration runs and measured\n- $\\|F_{g}\\| = 0.75$,\n- $\\|F_{f}\\| = 0.30$,\n- $\\zeta_{g} = 1.8$,\n- $\\zeta_{f} = 2.5$.\n\nThe computational cost per force evaluation is $c_{g} = 1$ for the gauge force and $c_{f} = 40$ for the fermion force. For a single trajectory, you have a fixed total force evaluation budget $B = 400$, which imposes the constraint\n$$\nN_{g}\\, c_{g} + N_{f}\\, c_{f} = B.\n$$\n\nUnder these assumptions, determine the optimal real-valued ratio $m = N_{g}/N_{f}$ that minimizes the leading-order model of $\\langle \\Delta H \\rangle$ subject to the budget constraint. Express your final answer as a single number, rounded to four significant figures. The ratio $m$ is dimensionless, so no units are required.",
            "solution": "The user wants me to solve a constrained optimization problem derived from the context of the Hybrid Monte Carlo (HMC) algorithm for lattice Quantum Chromodynamics (QCD).\n\n### Problem Validation\n\n#### Step 1: Extract Givens\n\n-   **Algorithm Context**: Hybrid Monte Carlo (HMC) for lattice QCD.\n-   **Action Splitting**: $S = S_g + S_f$, where $S_g$ is the gauge part and $S_f$ is the pseudofermion part.\n-   **Integrator Scheme**: Two-level multiple time scale (Sexton–Weingarten) using a reversible, symplectic, second-order update.\n-   **Trajectory Length**: $\\tau = 1$ (molecular dynamics time units).\n-   **Step Counts**: $N_f$ for coarse steps (fermion force), $N_g$ for fine steps (gauge force).\n-   **Step Sizes**: $h_f = \\tau / N_f$, $h_g = \\tau / N_g$.\n-   **Time-Scale Ratio**: $m = N_g / N_f$, which implies $h_g = h_f / m$.\n-   **Energy Violation Model**: $\\langle \\Delta H \\rangle \\approx C_{g}\\, h_{g}^{2} + C_{f}\\, h_{f}^{2}$.\n-   **Effective Coefficients**: $C_{i} = \\zeta_{i}\\, \\|F_{i}\\|^{2}$ for $i \\in \\{g,f\\}$.\n-   **Measured Calibration Data**:\n    -   $\\|F_{g}\\| = 0.75$\n    -   $\\|F_{f}\\| = 0.30$\n    -   $\\zeta_{g} = 1.8$\n    -   $\\zeta_{f} = 2.5$\n-   **Computational Costs**: $c_{g} = 1$ per gauge force evaluation, $c_{f} = 40$ per fermion force evaluation.\n-   **Computational Budget**: The total cost for a single trajectory is fixed by the budget $B = 400$.\n-   **Budget Constraint**: $N_{g}\\, c_{g} + N_{f}\\, c_{f} = B$.\n-   **Objective**: Determine the optimal real-valued ratio $m = N_g/N_f$ that minimizes $\\langle \\Delta H \\rangle$ subject to the budget constraint.\n-   **Output Requirement**: The final answer for $m$ must be rounded to four significant figures.\n\n#### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded**: The problem is well-grounded in computational high-energy physics. The Sexton–Weingarten scheme is a standard multiple time-scale integrator used in HMC simulations. The leading-order error model for the energy violation, $\\langle \\Delta H \\rangle$, scaling as the square of the step sizes ($h_g^2, h_f^2$), is characteristic of second-order symplectic integrators. The formulation of computational cost and the optimization thereof is a central and practical task in large-scale simulations. All premises are scientifically sound.\n-   **Well-Posed**: The problem provides a clear objective function to minimize ($\\langle \\Delta H \\rangle$), a well-defined constraint (budget $B$), and all necessary constants and relationships between variables. This structure allows for a unique solution.\n-   **Objective**: The problem is stated using precise mathematical and physical terminology, free of subjective or ambiguous language.\n\nThe problem does not exhibit any of the invalidity flaws. It is a standard, well-defined, and scientifically relevant constrained optimization problem.\n\n#### Step 3: Verdict and Action\n\nThe problem statement is **valid**. Proceeding to the solution.\n\n### Solution\n\nThe objective is to minimize the expected energy violation, $\\langle \\Delta H \\rangle$, subject to a fixed computational budget. The problem can be formulated as a constrained optimization problem.\n\nThe quantity to be minimized is the energy violation, which we will denote by $E$:\n$$ E = C_{g}\\, h_{g}^{2} + C_{f}\\, h_{f}^{2} $$\nThe step sizes are related to the number of steps and the trajectory length $\\tau=1$:\n$$ h_{f} = \\frac{\\tau}{N_{f}} = \\frac{1}{N_{f}} \\quad \\text{and} \\quad h_{g} = \\frac{\\tau}{N_{g}} = \\frac{1}{N_{g}} $$\nSubstituting these into the expression for $E$ gives the objective function in terms of $N_f$ and $N_g$:\n$$ E(N_f, N_g) = \\frac{C_g}{N_g^2} + \\frac{C_f}{N_f^2} $$\nThis minimization is subject to the computational budget constraint:\n$$ N_{g}\\, c_{g} + N_{f}\\, c_{f} = B $$\nWe first compute the numerical values for the coefficients $C_g$ and $C_f$ using the provided data:\n$C_{g} = \\zeta_{g}\\, \\|F_{g}\\|^{2} = 1.8 \\times (0.75)^{2} = 1.8 \\times 0.5625 = 1.0125$.\n$C_{f} = \\zeta_{f}\\, \\|F_{f}\\|^{2} = 2.5 \\times (0.30)^{2} = 2.5 \\times 0.09 = 0.225$.\n\nTo solve this constrained optimization problem, we use the method of Lagrange multipliers. The Lagrangian $\\mathcal{L}$ is:\n$$ \\mathcal{L}(N_f, N_g, \\lambda) = \\left( \\frac{C_g}{N_g^2} + \\frac{C_f}{N_f^2} \\right) + \\lambda (N_{g}\\, c_{g} + N_{f}\\, c_{f} - B) $$\nTo find the extremum, we set the partial derivatives of $\\mathcal{L}$ with respect to $N_f$, $N_g$, and $\\lambda$ to zero. We are primarily interested in the relationship between $N_f$ and $N_g$ that minimizes $E$.\n$$ \\frac{\\partial \\mathcal{L}}{\\partial N_g} = -\\frac{2 C_g}{N_g^3} + \\lambda c_g = 0 \\implies \\lambda c_g = \\frac{2 C_g}{N_g^3} $$\n$$ \\frac{\\partial \\mathcal{L}}{\\partial N_f} = -\\frac{2 C_f}{N_f^3} + \\lambda c_f = 0 \\implies \\lambda c_f = \\frac{2 C_f}{N_f^3} $$\nWe can solve for the Lagrange multiplier $\\lambda$ in both equations:\n$$ \\lambda = \\frac{2 C_g}{c_g N_g^3} \\quad \\text{and} \\quad \\lambda = \\frac{2 C_f}{c_f N_f^3} $$\nEquating the two expressions for $\\lambda$ gives the condition for optimality:\n$$ \\frac{2 C_g}{c_g N_g^3} = \\frac{2 C_f}{c_f N_f^3} $$\n$$ \\frac{C_g}{c_g N_g^3} = \\frac{C_f}{c_f N_f^3} $$\nWe want to find the optimal ratio $m = N_g/N_f$. Rearranging the equation to solve for $N_g/N_f$:\n$$ \\frac{N_g^3}{N_f^3} = \\frac{C_g c_f}{C_f c_g} $$\n$$ \\left(\\frac{N_g}{N_f}\\right)^3 = \\frac{c_f C_g}{c_g C_f} $$\nTaking the cube root of both sides yields the expression for the optimal ratio $m$:\n$$ m = \\left( \\frac{c_f C_g}{c_g C_f} \\right)^{1/3} $$\nNow we substitute the given numerical values:\n-   $c_g = 1$\n-   $c_f = 40$\n-   $C_g = 1.0125$\n-   $C_f = 0.225$\n\n$$ m = \\left( \\frac{40 \\times 1.0125}{1 \\times 0.225} \\right)^{1/3} $$\n$$ m = \\left( \\frac{40.5}{0.225} \\right)^{1/3} $$\nTo simplify the fraction:\n$$ \\frac{40.5}{0.225} = \\frac{40500}{225} = 180 $$\nSo, the optimal ratio is:\n$$ m = (180)^{1/3} $$\nWe are asked to provide this value rounded to four significant figures.\n$$ m \\approx 5.646237 \\dots $$\nRounding to four significant figures gives $m = 5.646$.\nNote that the budget $B=400$ is not needed to find the optimal ratio $m$, but would be required to find the actual values of $N_f$ and $N_g$:\n$N_g = m N_f \\implies (m c_g + c_f)N_f = B \\implies N_f = B / (m c_g + c_f)$.",
            "answer": "$$\\boxed{5.646}$$"
        },
        {
            "introduction": "The theoretical guarantees of the HMC algorithm, particularly the satisfaction of detailed balance, rely on the perfect time-reversibility of the molecular dynamics integrator. In practice, approximations—most notably the use of iterative solvers for the fermion force—break this crucial symmetry and can introduce subtle biases . This final practice introduces a vital diagnostic tool, the forward-backward reversibility test, allowing you to quantify the degree of this violation and understand its scaling with solver precision.",
            "id": "3516849",
            "problem": "Given a Hybrid Monte Carlo (HMC) algorithm for Lattice Quantum Chromodynamics (QCD), consider a simplified Abelian lattice gauge model where the gauge field on each site is an angle variable. Let a configuration be represented by a vector of angles $U \\in \\mathbb{R}^{V}$ with $V$ sites, and conjugate momenta $P \\in \\mathbb{R}^{V}$. Use the Wilson gauge action for a one-link approximation,\n$$\nS_{\\text{g}}[U] = \\beta \\sum_{i=1}^{V} \\left(1 - \\cos U_i\\right),\n$$\nand define the Hamiltonian\n$$\nH(U,P) = S_{\\text{g}}[U] + \\frac{1}{2} \\sum_{i=1}^{V} P_i^2.\n$$\nThe exact gauge force is\n$$\nF(U) = \\frac{\\partial S_{\\text{g}}}{\\partial U} = \\beta \\, \\sin U,\n$$\napplied component-wise. Hamilton's equations are\n$$\n\\frac{dU}{d\\tau} = \\frac{\\partial H}{\\partial P} = P, \\quad \\frac{dP}{d\\tau} = -\\frac{\\partial H}{\\partial U} = -F(U).\n$$\nUse the standard leapfrog integrator with step size $\\delta \\tau$ and $L$ steps:\n1. Half-step update of momenta: $P \\leftarrow P - \\frac{\\delta \\tau}{2} \\tilde{F}(U;\\epsilon)$.\n2. For $s = 1,\\dots,L-1$ do:\n   a. Full-step update of coordinates: $U \\leftarrow U + \\delta \\tau \\, P$.\n   b. Full-step update of momenta: $P \\leftarrow P - \\delta \\tau \\, \\tilde{F}(U;\\epsilon)$.\n3. Final full-step update of coordinates: $U \\leftarrow U + \\delta \\tau \\, P$.\n4. Final half-step update of momenta: $P \\leftarrow P - \\frac{\\delta \\tau}{2} \\tilde{F}(U;\\epsilon)$.\n\nIn exact arithmetic with exact forces, the leapfrog map is time-reversible. However, in realistic HMC with fermions, an inexact linear solve introduces a finite residual $\\epsilon$ that contaminates the force. Model this finite-precision and solver-residual contamination by an approximate force\n$$\n\\tilde{F}(U;\\epsilon) = F(U) + \\epsilon \\, \\lVert F(U) \\rVert_2 \\, \\hat{r},\n$$\nwhere $\\hat{r}$ is a unit vector constructed deterministically from a pseudorandom number generator seed and changes with each force evaluation, and $\\lVert \\cdot \\rVert_2$ is the Euclidean norm. This mimics the effect that a Conjugate Gradient (CG) method with residual tolerance $\\epsilon$ introduces a force error proportional to $\\epsilon$ times a norm of the true force. The forward-backward reversibility test uses the following cycle:\n- Start from $(U_0, P_0)$ and compute $H_0 = H(U_0,P_0)$.\n- Run a forward trajectory using $\\tilde{F}(U;\\epsilon)$ for $L$ steps to get $(U_1, P_1)$.\n- Flip the momentum, $(U_1, -P_1)$, and run a backward trajectory using $\\tilde{F}(U;\\epsilon)$ for $L$ steps to obtain $(U_2, P_2)$.\n- Compute the cycle energy difference\n$$\n\\Delta H_{\\text{cycle}} = H(U_2, P_2) - H(U_0, P_0).\n$$\n\nYour task is to implement this model and quantify reversibility violations due to finite precision by measuring $\\Delta H_{\\text{cycle}}$ as a function of the linear solver residual $\\epsilon$. Map and verify the scaling trend $\\Delta H_{\\text{cycle}} \\propto \\epsilon \\times \\lVert \\partial H/\\partial U \\rVert_2$ within this toy model, where $\\partial H/\\partial U = F(U)$.\n\nImplementation requirements:\n- Use the leapfrog integrator defined above.\n- Use the approximate force model $\\tilde{F}(U;\\epsilon)$.\n- Use a deterministic pseudorandom number generator with specified integer seeds for:\n  - Initial momenta (Gaussian components with zero mean and unit variance).\n  - Construction of the unit vector $\\hat{r}$ at each force call. Use one seed for the forward trajectory and a different seed for the backward trajectory to emulate direction-dependent finite precision differences.\n- Compute $\\lVert \\partial H/\\partial U \\rVert_2$ at the starting configuration $(U_0,P_0)$ as $\\lVert F(U_0) \\rVert_2$ for diagnostic purposes in the solution. The program's final output is only the list of $\\Delta H_{\\text{cycle}}$ across the test suite.\n\nUnits:\n- All quantities are dimensionless. No physical units are required.\n\nTest suite:\nProvide results for the following parameter sets, each producing a single scalar $\\Delta H_{\\text{cycle}}$ (a float):\n1. General case with moderate residual:\n   - $V = 128$, $\\beta = 5.7$, $\\delta \\tau = 0.1$, $L = 50$, $\\epsilon = 10^{-8}$, initial $U_0$ drawn i.i.d. from a normal distribution with mean $0$ and standard deviation $1$ using seed $123456$, initial $P_0$ drawn i.i.d. from a normal distribution with mean $0$ and standard deviation $1$ using seed $123457$, forward force-noise seed $987650$, backward force-noise seed $987651$.\n2. Boundary case with exact force (no residual):\n   - $V = 128$, $\\beta = 5.7$, $\\delta \\tau = 0.1$, $L = 50$, $\\epsilon = 0$, initial $U_0$ seed $123456$, initial $P_0$ seed $123457$, forward seed $111111$, backward seed $222222$.\n3. Small residual:\n   - $V = 128$, $\\beta = 5.7$, $\\delta \\tau = 0.1$, $L = 50$, $\\epsilon = 10^{-10}$, initial $U_0$ seed $123456$, initial $P_0$ seed $123457$, forward seed $333333$, backward seed $444444$.\n4. Larger residual:\n   - $V = 128$, $\\beta = 5.7$, $\\delta \\tau = 0.1$, $L = 50$, $\\epsilon = 10^{-6}$, initial $U_0$ seed $123456$, initial $P_0$ seed $123457$, forward seed $555555$, backward seed $666666$.\n5. Edge case with vanishing gauge-force norm at the start:\n   - $V = 128$, $\\beta = 5.7$, $\\delta \\tau = 0.1$, $L = 50$, $\\epsilon = 10^{-8}$, initial $U_0$ set to the zero vector, initial $P_0$ seed $777777$, forward seed $888888$, backward seed $999999$.\n\nFinal output format:\nYour program should produce a single line of output containing the $\\Delta H_{\\text{cycle}}$ results for the five test cases as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$). The $r_i$ must be printed as standard Python floats. No additional text should be printed before or after this line.",
            "solution": "The problem requires an implementation and analysis of a toy model for reversibility violations in the Hybrid Monte Carlo (HMC) algorithm, which is a cornerstone of modern lattice Quantum Chromodynamics (QCD) simulations. The HMC algorithm generates configurations $U$ distributed according to a probability density proportional to $e^{-S[U]}$, where $S[U]$ is the action. It achieves this by introducing fictitious momenta $P$ and simulating Hamiltonian dynamics in the phase space $(U, P)$, followed by a Metropolis-Hastings acceptance step. The validity of this acceptance step relies crucially on the properties of the numerical integrator used for the molecular dynamics (MD) trajectory, specifically its time-reversibility and area-preservation (symplecticity).\n\nThe provided model simplifies the complex dynamics of QCD to an Abelian gauge model on $V$ sites, where the configuration is described by a vector of angles $U = (U_1, \\dots, U_V)$. The system's evolution is governed by the Hamiltonian:\n$$\nH(U,P) = S_{\\text{g}}[U] + \\frac{1}{2} \\sum_{i=1}^{V} P_i^2\n$$\nwhere $S_{\\text{g}}[U] = \\beta \\sum_{i=1}^{V} (1 - \\cos U_i)$ is the Wilson gauge action and the second term is the kinetic energy. The equations of motion are given by Hamilton's equations:\n$$\n\\frac{dU_i}{d\\tau} = \\frac{\\partial H}{\\partial P_i} = P_i\n$$\n$$\n\\frac{dP_i}{d\\tau} = -\\frac{\\partial H}{\\partial U_i} = -\\frac{\\partial S_{\\text{g}}}{\\partial U_i} = -\\beta \\sin U_i = -F_i(U)\n$$\nHere, $\\tau$ is the fictitious simulation time, and $F(U)$ is the gauge force.\n\nThese equations are solved numerically using the leapfrog integrator, a second-order symplectic method. A single step of the leapfrog integrator from time $\\tau$ to $\\tau + \\delta\\tau$ can be written as a composition of operators: a half-step drift in momentum, a full-step drift in position, and another half-step drift in momentum. Being symplectic ensures that it preserves phase space volume. Crucially, it is also time-reversible. If we denote the map from $(U(\\tau), P(\\tau))$ to $(U(\\tau+\\delta\\tau), P(\\tau+\\delta\\tau))$ as $\\Phi_{\\delta\\tau}$, then reversing the time step, $\\delta\\tau \\to -\\delta\\tau$, is equivalent to inverting the map: $\\Phi_{-\\delta\\tau} = \\Phi_{\\delta\\tau}^{-1}$. A practical test of reversibility involves running a trajectory forward for a total time $T = L\\delta\\tau$, flipping the final momentum $P \\to -P$, and running the trajectory backward for the same duration. For a perfectly reversible integrator, the system returns to its exact initial state, $(U_0, P_0)$.\n\nIn realistic HMC simulations, particularly those including dynamical fermions, the force calculation is computationally expensive. It requires solving a large sparse linear system of the form $D\\psi = \\eta$, where $D$ is the fermion matrix. This is typically done with iterative solvers like the Conjugate Gradient (CG) algorithm, which is terminated when the norm of the residual reaches a certain tolerance, $\\epsilon$. This introduces a small, effectively random error into the force calculation. The problem models this with an approximate force:\n$$\n\\tilde{F}(U;\\epsilon) = F(U) + \\epsilon \\, \\lVert F(U) \\rVert_2 \\, \\hat{r}\n$$\nwhere $F(U)$ is the exact gauge force, $\\lVert F(U) \\rVert_2$ is its Euclidean norm, and $\\hat{r}$ is a randomly oriented unit vector that changes at each force evaluation. The magnitude of the error is proportional to the solver tolerance $\\epsilon$ and the force magnitude, which is a realistic model.\n\nThe introduction of this error term $\\epsilon \\, \\lVert F(U) \\rVert_2 \\, \\hat{r}$ breaks the time-reversibility of the leapfrog integrator. The error vector $\\hat{r}$ is generated from a pseudorandom number generator (PRNG). When the trajectory is reversed by flipping the momentum, the sequence of states $U$ traced in the backward path is approximately the same as in the forward path, but the PRNG continues to advance. It generates a new, independent sequence of random vectors $\\hat{r}$. The errors from the forward trajectory are not canceled by the errors in the backward trajectory, leading to a deviation from the initial state.\n\nThe task is to quantify this violation by measuring the change in the Hamiltonian over a full forward-backward cycle, $\\Delta H_{\\text{cycle}} = H(U_2, P_2) - H(U_0, P_0)$. The deviation of the final state from the initial state, $(U_2 - U_0, P_2 - P_0)$, is expected to be of order $\\mathcal{O}(\\epsilon)$. By Taylor expansion, the change in Hamiltonian is $\\Delta H_{\\text{cycle}} \\approx \\nabla H \\cdot (U_2 - U_0, P_2 - P_0)$, which implies $\\Delta H_{\\text{cycle}}$ should also be of order $\\mathcal{O}(\\epsilon)$. The problem further suggests a specific scaling relationship, $\\Delta H_{\\text{cycle}} \\propto \\epsilon \\times \\lVert F(U_0) \\rVert_2$, which we will investigate.\n\nThe implementation will consist of the following components:\n1.  Functions to calculate the action $S_{\\text{g}}[U]$ and the total Hamiltonian $H(U, P)$.\n2.  A function to calculate the approximate force $\\tilde{F}(U; \\epsilon)$, which internally computes the exact force $F(U) = \\beta \\sin U$ and adds the error term. This function will take a PRNG object as an argument to correctly manage the state of the random number sequence.\n3.  A function for the leapfrog integrator, as specified in the problem, which performs $L$ integration steps of size $\\delta\\tau$.\n4.  A main routine that executes the full reversibility test for each parameter set:\n    a. Initialize phase space coordinates $(U_0, P_0)$ using the specified seeds.\n    b. Calculate the initial energy $H_0$.\n    c. Run a forward MD trajectory of $L$ steps starting from $(U_0, P_0)$ to get $(U_1, P_1)$, using a specific PRNG seed for the force noise.\n    d. Run a backward MD trajectory of $L$ steps starting from $(U_1, -P_1)$ to get $(U_2, P_2)$, using a different PRNG seed for the force noise.\n    e. Calculate the final energy $H_2 = H(U_2, P_2)$ and the difference $\\Delta H_{\\text{cycle}} = H_2 - H_0$.\n\nThe test suite is designed to probe the behavior of $\\Delta H_{\\text{cycle}}$:\n-   Case 1 ($V=128$, $\\beta=5.7$, $\\epsilon=10^{-8}$): A typical scenario that should yield a small but measurable reversibility violation.\n-   Case 2 ($\\epsilon=0$): The control case. With an exact force, the leapfrog integrator is reversible up to standard floating-point arithmetic errors. $\\Delta H_{\\text{cycle}}$ should be close to zero (e.g., $\\approx 10^{-14}$ or smaller).\n-   Cases 3 and 4 ($\\epsilon=10^{-10}$ and $\\epsilon=10^{-6}$): These, along with Case 1, test the linear scaling of $\\Delta H_{\\text{cycle}}$ with $\\epsilon$. We expect the results to scale by factors of $10^{-2}$ and $10^2$ relative to Case 1.\n-   Case 5 ($U_0 = \\vec{0}$): An edge case where the initial force is zero, $\\lVert F(U_0) \\rVert_2 = 0$. This implies the error term is also zero at the very first step. However, as the system evolves under the influence of the non-zero initial momenta $P_0$, $U$ becomes non-zero, leading to a non-zero force and subsequent accumulation of reversibility-breaking errors. This case demonstrates that the simple propoosed scaling with $\\lVert F(U_0) \\rVert_2$ can be misleading; a more accurate scaling relation would depend on the integrated force norm over the whole trajectory. The result should still be non-zero and roughly proportional to $\\epsilon$.\n\nBy executing these tests, we can numerically verify the theoretical understanding of how solver inaccuracies in HMC manifest as violations of fundamental conservation laws and symmetries.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_action(U, beta):\n    \"\"\"Calculates the Wilson gauge action for the U(1) model.\"\"\"\n    return beta * np.sum(1.0 - np.cos(U))\n\ndef calculate_hamiltonian(U, P, beta):\n    \"\"\"Calculates the Hamiltonian for the system.\"\"\"\n    action = calculate_action(U, beta)\n    kinetic_energy = 0.5 * np.sum(P**2)\n    return action + kinetic_energy\n\ndef exact_force(U, beta):\n    \"\"\"Calculates the exact gauge force F(U) = beta * sin(U).\"\"\"\n    return beta * np.sin(U)\n\ndef approximate_force(U, beta, epsilon, rng):\n    \"\"\"\n    Calculates the approximate force, including a modeled error term.\n    F_tilde = F(U) + epsilon * ||F(U)||_2 * r_hat\n    \"\"\"\n    F = exact_force(U, beta)\n    if epsilon == 0.0:\n        return F\n    \n    F_norm = np.linalg.norm(F)\n    if F_norm == 0.0:\n        return F\n        \n    # Generate a random vector and normalize it to get the unit vector r_hat\n    r = rng.standard_normal(size=U.shape)\n    r_norm = np.linalg.norm(r)\n    \n    # Handle the unlikely case where the random vector is zero\n    if r_norm == 0.0:\n      r_hat = np.zeros_like(r)\n    else:\n      r_hat = r / r_norm\n    \n    # Calculate the contaminated force\n    F_tilde = F + epsilon * F_norm * r_hat\n    return F_tilde\n\ndef leapfrog_integrator(U_start, P_start, dt, L, beta, epsilon, force_rng):\n    \"\"\"\n    Performs a molecular dynamics trajectory using the leapfrog algorithm.\n    \"\"\"\n    U = U_start.copy()\n    P = P_start.copy()\n\n    # Initial half-step for momentum (\"P-U-P\" scheme)\n    P -= 0.5 * dt * approximate_force(U, beta, epsilon, force_rng)\n\n    # L-1 full steps for position and momentum\n    for _ in range(L - 1):\n        U += dt * P\n        P -= dt * approximate_force(U, beta, epsilon, force_rng)\n\n    # Final full step for position\n    U += dt * P\n    \n    # Final half-step for momentum\n    P -= 0.5 * dt * approximate_force(U, beta, epsilon, force_rng)\n\n    return U, P\n\ndef run_reversibility_test(V, beta, dt, L, epsilon, u0_seed, p0_seed, fwd_seed, bwd_seed, u0_is_zero=False):\n    \"\"\"\n    Runs the full forward-backward reversibility test for a given set of parameters.\n    \"\"\"\n    # 1. Initialize initial conditions\n    p0_rng = np.random.default_rng(p0_seed)\n    \n    if u0_is_zero:\n        U0 = np.zeros(V, dtype=np.float64)\n    else:\n        u0_rng = np.random.default_rng(u0_seed)\n        U0 = u0_rng.normal(loc=0.0, scale=1.0, size=V)\n    \n    P0 = p0_rng.normal(loc=0.0, scale=1.0, size=V)\n\n    # 2. Calculate the initial Hamiltonian\n    H0 = calculate_hamiltonian(U0, P0, beta)\n\n    # 3. Run the forward trajectory\n    fwd_rng = np.random.default_rng(fwd_seed)\n    U1, P1 = leapfrog_integrator(U0, P0, dt, L, beta, epsilon, fwd_rng)\n\n    # 4. Run the backward trajectory with flipped momentum\n    bwd_rng = np.random.default_rng(bwd_seed)\n    U2, P2 = leapfrog_integrator(U1, -P1, dt, L, beta, epsilon, bwd_rng)\n    \n    # 5. Calculate the final Hamiltonian and the cycle energy difference\n    H2 = calculate_hamiltonian(U2, P2, beta)\n    delta_H_cycle = H2 - H0\n    \n    return delta_H_cycle\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (V, beta, dt, L, epsilon, u0_seed, p0_seed, fwd_seed, bwd_seed, u0_is_zero)\n        (128, 5.7, 0.1, 50, 1e-8, 123456, 123457, 987650, 987651, False),\n        (128, 5.7, 0.1, 50, 0.0, 123456, 123457, 111111, 222222, False),\n        (128, 5.7, 0.1, 50, 1e-10, 123456, 123457, 333333, 444444, False),\n        (128, 5.7, 0.1, 50, 1e-6, 123456, 123457, 555555, 666666, False),\n        (128, 5.7, 0.1, 50, 1e-8, 0, 777777, 888888, 999999, True), \n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_reversibility_test(*params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}