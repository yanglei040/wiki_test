{
    "hands_on_practices": [
        {
            "introduction": "混合蒙特卡罗（HMC）算法的核心是模拟哈密顿动力学的数值积分器。为了确保算法的正确性，这个积分器必须满足时间反演对称性和辛性，而蛙跳（leapfrog）算法正是实现这些性质的理论保证。本练习将指导你从第一性原理出发，为一个 $SU(2)$ 规范链接构建一个基本的蛙跳积分步骤，推导作用力并验证积分器的理论误差阶，从而加深你对HMC核心机制的理解 。",
            "id": "3516854",
            "problem": "为格点量子色动力学 (Lattice Quantum Chromodynamics, QCD) 中的混合蒙特卡洛 (Hybrid Monte Carlo, HMC) 积分器，实现、分析并测试一个单规范链的单步对称蛙跳更新，该更新专门针对二阶特殊酉群 ($\\mathrm{SU}(2)$)。您必须从第一性原理出发推导力，并根据单步之后的哈密顿量漂移来量化积分器的主导局域误差。\n\n从以下基本设定出发：\n- 规范链 $U$ 是 $\\mathrm{SU}(2)$ 的一个元素，即一个行列式为 $1$ 的 $2\\times 2$ 复酉矩阵。\n- 共轭动量 $P$ 是李代数 $\\mathfrak{su}(2)$ 的一个元素，即一个 $2\\times 2$ 的无迹反厄米矩阵。\n- 哈密顿量是可分的：$H(U,P) = T(P) + S(U)$，其中动能项为 $T(P) = -\\tfrac{1}{2}\\operatorname{Re}\\operatorname{Tr}(P^{2})$（由 $\\mathfrak{su}(2)$ 上的右不变度规 $\\langle A,B\\rangle = -\\operatorname{Re}\\operatorname{Tr}(A B)$ 导出），势能项为 $S(U) = -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(U M^{\\dagger})$，其中 $\\alpha > 0$ 是一个实数耦合常数，$M\\in \\mathrm{SU}(2)$ 是一个固定的钉状矩阵 (staple-like matrix)。\n- $U$ 的变分形式为 $\\delta U = A U$，其中 $A\\in \\mathfrak{su}(2)$，力 $F(U)\\in \\mathfrak{su}(2)$ 由 $\\delta S = \\langle F(U), A\\rangle$ 对所有此类 $A$ 定义。\n- 群流形上的辛动力学遵循哈密顿方程：$\\dot U = P U$ 和 $\\dot P = -F(U)$。\n- 步长为 $\\epsilon$ 的对称蛙跳法（也称为速度Verlet算法）更新是由一次半步动量更新、一次整步规范链漂移和一次半步动量更新复合而成。\n\n任务：\n1) 基于以上设定，推导出关于 $U$ 和 $M$ 的力 $F(U)$ 的显式表达式，清晰地使用内积 $\\langle \\cdot,\\cdot\\rangle$ 和到 $\\mathfrak{su}(2)$ 上的投影。您必须仅使用 $\\delta U = A U$（其中 $A\\in \\mathfrak{su}(2)$）和 $\\mathrm{SU}(2)$ 是具有给定内积的酉群子群这些性质。您的最终表达式必须是一个仅由 $U$ 和 $M$ 构建的矩阵到 $\\mathfrak{su}(2)$ 上的投影。\n2) 使用推导出的力，实现一个单步对称蛙跳更新：\n- 半步更新：$P \\leftarrow P - \\tfrac{\\epsilon}{2} F(U)$。\n- 漂移：$U \\leftarrow \\exp(\\epsilon P)\\, U$，其中指数函数是将 $\\mathfrak{su}(2)$ 映射到 $\\mathrm{SU}(2)$ 的矩阵指数。\n- 半步更新：$P \\leftarrow P - \\tfrac{\\epsilon}{2} F(U)$。\n确保 $U\\in \\mathrm{SU}(2)$ 和 $P\\in \\mathfrak{su}(2)$ 在数值舍入误差范围内得以保持。您可以使用 $\\mathrm{SU}(2)$ 中的闭合形式指数函数或通用的矩阵指数函数。\n3) 对于下方的每个测试案例，计算初始状态的哈密顿量值 $H_{\\text{before}} = H(U,P)$ 和经过一步蛙跳更新后的 $H_{\\text{after}} = H(U',P')$。定义局域能量误差 $\\Delta H = H_{\\text{after}} - H_{\\text{before}}$。通过缩放量 $C \\approx \\Delta H/\\epsilon^{3}$ 估计主导的 $\\mathcal{O}(\\epsilon^{3})$ 误差系数。\n4) 角度必须以弧度进行解释和计算。\n5) 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，即 $[C_{1},C_{2},C_{3}]$，其中 $C_{k}$ 是测试案例 $k$ 的浮点数值。\n\n测试套件规范。使用泡利矩阵 $\\sigma_{1},\\sigma_{2},\\sigma_{3}$ 和以下参数化：\n- 对于任意单位实轴向量 $\\mathbf{n}$（$\\lVert \\mathbf{n}\\rVert=1$）和角度 $\\theta$，定义 $U(\\theta,\\mathbf{n}) = \\exp\\!\\big(i\\,\\theta\\, \\mathbf{n}\\cdot \\boldsymbol{\\sigma}\\big) = \\cos(\\theta)\\,\\mathbf{1}_{2} + i \\sin(\\theta)\\,\\mathbf{n}\\cdot \\boldsymbol{\\sigma}$，它位于 $\\mathrm{SU}(2)$ 中。\n- 对于任意实向量 $\\mathbf{w}$，定义 $P(\\mathbf{w}) = i\\,\\mathbf{w}\\cdot \\boldsymbol{\\sigma}\\in \\mathfrak{su}(2)$。\n\n实现并评估以下三个案例：\n- 案例1（一般情况）：\n  - $\\alpha = 1.1$, $\\epsilon = 0.05$。\n  - $U = U(\\theta_{U}, \\mathbf{n}_{U})$，其中 $\\theta_{U} = 0.8$, $\\mathbf{n}_{U} = \\frac{(1,2,3)}{\\lVert(1,2,3)\\rVert}$。\n  - $M = U(\\theta_{M}, \\mathbf{n}_{M})$，其中 $\\theta_{M} = 0.3$, $\\mathbf{n}_{M} = (0,1,0)$。\n  - $P = P(\\mathbf{w})$，其中 $\\mathbf{w} = 0.4\\,(1,0,0)$。\n- 案例2（小步长以探测缩放行为）：\n  - $\\alpha = 0.9$, $\\epsilon = 0.01$。\n  - $U = U(\\theta_{U}, \\mathbf{n}_{U})$，其中 $\\theta_{U} = 1.2$, $\\mathbf{n}_{U} = \\frac{(0.3,0.4,0.5)}{\\lVert(0.3,0.4,0.5)\\rVert}$。\n  - $M = U(\\theta_{M}, \\mathbf{n}_{M})$，其中 $\\theta_{M} = 0.7$, $\\mathbf{n}_{M} = (0,0,1)$。\n  - $P = P(\\mathbf{w})$，其中 $\\mathbf{w} = 0.2\\,\\frac{(0.2,0.8,0.5)}{\\lVert(0.2,0.8,0.5)\\rVert}$。\n- 案例3（初始动量为零的边界情况）：\n  - $\\alpha = 1.5$, $\\epsilon = 0.02$。\n  - $U = U(\\theta_{U}, \\mathbf{n}_{U})$，其中 $\\theta_{U} = 0.5$, $\\mathbf{n}_{U} = \\frac{(0,1,1)}{\\lVert(0,1,1)\\rVert}$。\n  - $M = U(\\theta_{M}, \\mathbf{n}_{M})$，其中 $\\theta_{M} = 1.0$, $\\mathbf{n}_{M} = (1,0,0)$。\n  - $P = P(\\mathbf{w})$，其中 $\\mathbf{w} = (0,0,0)$。\n\n最终输出格式：\n- 您的程序必须精确打印一行形如 $[C_{1},C_{2},C_{3}]$ 的内容，其中每个 $C_{k}$ 是对应案例的 $\\Delta H/\\epsilon^{3}$ 的浮点估计值，无任何附加文本。",
            "solution": "我们将构造基于李群 $\\mathrm{SU}(2)$ 上的哈密顿动力学，该动力学具有右不变动能和类规范势能。基本定义如下：\n- 规范链 $U\\in \\mathrm{SU}(2)$ 通过 $\\dot U = P U$ 演化，其中 $P\\in \\mathfrak{su}(2)$ 是右不变动量。\n- 动量通过 $\\dot P = -F(U)$ 演化，其中力 $F(U)$ 是势能 $S(U)$ 关于 $\\mathfrak{su}(2)$ 上的右不变度规 $\\langle A,B\\rangle = -\\operatorname{Re}\\operatorname{Tr}(A B)$ 的变分导数。\n\n力的推导。设作用量为 $S(U) = -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(U M^{\\dagger})$，其中给定 $M\\in \\mathrm{SU}(2)$ 且 $\\alpha>0$。$U$ 处切于 $\\mathrm{SU}(2)$ 的一般变分是 $\\delta U = A U$，其中 $A\\in \\mathfrak{su}(2)$。计算一阶变分：\n\n$$\n\\delta S \\;=\\; -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(\\delta U\\, M^{\\dagger})\n\\;=\\; -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(A\\, U M^{\\dagger}).\n$$\n\n我们希望将 $\\delta S$ 表示为 $\\delta S = \\langle F(U), A\\rangle = -\\operatorname{Re}\\operatorname{Tr}(F(U)\\, A)$ 的形式，该形式对所有 $A\\in \\mathfrak{su}(2)$ 成立。请注意以下两个事实：\n- 对于任意 $A\\in \\mathfrak{su}(2)$ 和任意矩阵 $X$，$\\operatorname{Re}\\operatorname{Tr}(A X) = \\operatorname{Re}\\operatorname{Tr}\\big(A\\, \\tfrac{1}{2}(X - X^{\\dagger})\\big)$，因为 $A$ 是反厄米矩阵，在实迹中与厄米部分的配对为零。\n- 如果我们给 $F(U)$ 加上单位矩阵的任意倍数，它与 $A$ 的配对为零，因为 $\\operatorname{Tr}(A) = 0$。\n\n因此，要使 $\\delta S = -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(A\\, U M^{\\dagger})$ 对所有 $A\\in \\mathfrak{su}(2)$ 都等于 $-\\operatorname{Re}\\operatorname{Tr}(F(U) A)$，只需选择 $F(U)$ 为 $\\alpha\\, U M^{\\dagger}$ 在由 $-\\operatorname{Re}\\operatorname{Tr}(\\cdot\\,\\cdot)$ 导出的内积下到 $\\mathfrak{su}(2)$ 上的投影即可。将反厄米投影写为 $\\mathrm{AH}(X) = \\tfrac{1}{2}(X - X^{\\dagger})$，然后移除迹，力即为\n\n$$\nF(U) \\;=\\; \\mathrm{proj}_{\\mathfrak{su}(2)}\\!\\big(\\alpha\\, U M^{\\dagger}\\big)\n\\;=\\; \\alpha\\left[\\tfrac{1}{2}\\big( U M^{\\dagger} - M U^{\\dagger}\\big) \\;-\\; \\tfrac{1}{2}\\operatorname{Tr}\\!\\left(\\tfrac{1}{2}\\big( U M^{\\dagger} - M U^{\\dagger}\\big)\\right)\\mathbf{1}_{2}\\right].\n$$\n\n根据构造，$F(U)\\in \\mathfrak{su}(2)$ 并且满足 $\\delta S = -\\operatorname{Re}\\operatorname{Tr}(F(U) A)$ 对所有 $A\\in \\mathfrak{su}(2)$ 成立，因此哈密顿方程 $\\dot P = -F(U)$ 成立。\n\n蛙跳积分器。对于可分的哈密顿量 $H(U,P)=T(P)+S(U)$，步长为 $\\epsilon$ 的对称蛙跳法在一个Strang分裂中复合了 $T$ 和 $S$ 的精确流：\n- $S$ 下的半步动量更新：$P \\leftarrow P - \\tfrac{\\epsilon}{2} F(U)$，其中 $U$ 固定。\n- $T$ 下的漂移：$U \\leftarrow \\exp(\\epsilon P)\\, U$，其中 $P$ 固定。\n- $S$ 下的半步动量更新：$P \\leftarrow P - \\tfrac{\\epsilon}{2} F(U)$，其中 $U$ 已更新。\n\n在 $\\mathrm{SU}(2)$ 上，如果 $P\\in \\mathfrak{su}(2)$ 是反厄米无迹的，则对某个 $\\mathbf{w}\\in \\mathbb{R}^{3}$ 有 $P = i\\,\\mathbf{w}\\cdot \\boldsymbol{\\sigma}$，且 $P^{2} = -\\lVert \\mathbf{w}\\rVert^{2}\\,\\mathbf{1}_{2}$。因此，指数函数有闭合形式\n\n$$\n\\exp(\\epsilon P) \\;=\\; \\cos(\\epsilon \\lVert \\mathbf{w}\\rVert)\\,\\mathbf{1}_{2} \\;+\\; \\frac{\\sin(\\epsilon \\lVert \\mathbf{w}\\rVert)}{\\lVert \\mathbf{w}\\rVert}\\, P,\n$$\n\n当 $\\lVert \\mathbf{w}\\rVert \\to 0$ 时，其极限值为 $\\mathbf{1}_{2} + \\epsilon P$。这保证了漂移在浮点误差范围内保持在 $\\mathrm{SU}(2)$ 上，前提是通过动量更新的构造使 $P$ 保持在 $\\mathfrak{su}(2)$ 中。\n\n哈密顿量与局域误差。对于 $T(P) = -\\tfrac{1}{2}\\operatorname{Re}\\operatorname{Tr}(P^{2})$ 和 $S(U) = -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(U M^{\\dagger})$，在一步蛙跳更新前后计算的哈密顿量得到\n\n$$\n\\Delta H \\;=\\; H_{\\text{after}} - H_{\\text{before}}.\n$$\n\n因为蛙跳法是一种二阶、对称、辛积分器，所以对于光滑的 $H$，其每步的局域能量误差按 $\\mathcal{O}(\\epsilon^{3})$ 比例缩放。对于给定的微小 $\\epsilon$，可以通过计算 $C \\approx \\Delta H / \\epsilon^{3}$ 来估计主导系数。对于对称分裂，被精确守恒的修正（影子）哈密顿量与真实的 $H$ 相差 $\\mathcal{O}(\\epsilon^{2})$ 项，而观察到的 $H$ 本身的单步漂移为 $\\mathcal{O}(\\epsilon^{3})$，这是由于单步对称更新中偶数阶项的抵消所致。\n\n数值实现细节：\n- 将 $U$ 参数化为 $U(\\theta,\\mathbf{n}) = \\cos(\\theta)\\,\\mathbf{1}_{2} + i \\sin(\\theta)\\,\\mathbf{n}\\cdot \\boldsymbol{\\sigma}$（对于单位向量 $\\mathbf{n}$）确保了 $U\\in \\mathrm{SU}(2)$。\n- 将 $P$ 参数化为 $P(\\mathbf{w}) = i\\,\\mathbf{w}\\cdot \\boldsymbol{\\sigma}$ 确保了 $P\\in \\mathfrak{su}(2)$。\n- 投影 $\\mathrm{proj}_{\\mathfrak{su}(2)}(X)$ 通过计算 $\\tfrac{1}{2}(X - X^{\\dagger})$，然后减去 $\\tfrac{1}{2}\\operatorname{Tr}(\\cdot)\\,\\mathbf{1}_{2}$ 来移除迹的方式实现。\n- 漂移使用 $\\mathrm{SU}(2)$ 上的闭合形式指数函数，并仔细处理小范数极限。\n- 哈密顿量项是通过迹的实部计算的标量，没有物理单位，所有角度均按要求以弧度为单位。\n\n测试套件覆盖范围：\n- 案例1使用中等大小的非对易 $U$、$M$ 和非零 $P$，以及 $\\epsilon = 0.05$，来测试一般路径。\n- 案例2使用更小的 $\\epsilon = 0.01$ 来突显 $\\epsilon^{3}$ 缩放行为。\n- 案例3使用零初始动量 $P=0$ 和非平凡的 $U$、$M$，来探测从静止开始的力更新的正确性。\n\n该程序计算所有三个案例的 $C_{k} = \\Delta H_{k}/\\epsilon_{k}^{3}$ 并打印单行 $[C_{1},C_{2},C_{3}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Pauli matrices\nsigma1 = np.array([[0, 1], [1, 0]], dtype=complex)\nsigma2 = np.array([[0, -1j], [1j, 0]], dtype=complex)\nsigma3 = np.array([[1, 0], [0, -1]], dtype=complex)\npaulis = np.array([sigma1, sigma2, sigma3], dtype=complex)\nI2 = np.eye(2, dtype=complex)\n\ndef su2_from_axis_angle(theta: float, axis: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Construct U = cos(theta) I + i sin(theta) (n · sigma), for unit axis n.\n    \"\"\"\n    axis = np.asarray(axis, dtype=float)\n    nrm = np.linalg.norm(axis)\n    if nrm == 0.0:\n        return I2.copy()\n    n = axis / nrm\n    H = n[0] * sigma1 + n[1] * sigma2 + n[2] * sigma3  # Hermitian\n    return np.cos(theta) * I2 + 1j * np.sin(theta) * H\n\ndef p_from_vec(w: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Construct P = i (w · sigma), which is anti-Hermitian and traceless.\n    \"\"\"\n    w = np.asarray(w, dtype=float)\n    H = w[0] * sigma1 + w[1] * sigma2 + w[2] * sigma3  # Hermitian traceless\n    return 1j * H\n\ndef proj_su2(X: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Project a 2x2 complex matrix X onto su(2) using the inner product -Re Tr(A B).\n    This is the anti-Hermitian part with trace removed.\n    \"\"\"\n    AH = 0.5 * (X - X.conj().T)  # anti-Hermitian\n    tr = 0.5 * np.trace(AH)      # complex scalar; for su(2), subtract (tr)*I\n    return AH - tr * I2\n\ndef exp_su2(eps: float, P: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute exp(eps * P) for P in su(2) using the closed form:\n    exp(eps P) = cos(eps*|w|) I + (sin(eps*|w|)/|w|) P with P = i w·sigma.\n    Handles the small-norm limit stably.\n    \"\"\"\n    # Norm |w| satisfies: P^2 = -|w|^2 I, and -Tr(P^2)/2 = |w|^2\n    P2 = P @ P\n    # Tr(P^2) should be negative real\n    trP2 = np.trace(P2)\n    # Use real part for safety\n    w2 = -np.real(trP2) / 2.0\n    # Numerical guard\n    if w2  0:\n        # Clamp tiny negative due to numerical rounding\n        if w2 > -1e-14:\n            w2 = 0.0\n        else:\n            raise RuntimeError(\"Encountered negative w^2 beyond rounding.\")\n    wnorm = np.sqrt(w2)\n    if wnorm  1e-14:\n        # Use series expansion: exp(eps P) ≈ I + eps P + (eps^2/2) P^2\n        return I2 + eps * P + 0.5 * (eps ** 2) * (P2)\n    c = np.cos(eps * wnorm)\n    s_over_w = np.sin(eps * wnorm) / wnorm\n    return c * I2 + s_over_w * P\n\ndef force(U: np.ndarray, alpha: float, M: np.ndarray) - np.ndarray:\n    \"\"\"\n    F(U) = proj_su2(alpha * U * M†)\n    \"\"\"\n    return proj_su2(alpha * (U @ M.conj().T))\n\ndef kinetic(P: np.ndarray) - float:\n    # T(P) = -0.5 Re Tr(P^2)\n    return float(-0.5 * np.real(np.trace(P @ P)))\n\ndef potential(U: np.ndarray, alpha: float, M: np.ndarray) - float:\n    # S(U) = - alpha Re Tr(U M†)\n    return float(-alpha * np.real(np.trace(U @ M.conj().T)))\n\ndef hamiltonian(U: np.ndarray, P: np.ndarray, alpha: float, M: np.ndarray) - float:\n    return kinetic(P) + potential(U, alpha, M)\n\ndef leapfrog_step(U: np.ndarray, P: np.ndarray, alpha: float, M: np.ndarray, eps: float):\n    \"\"\"\n    Perform one symmetric leapfrog step:\n    P - P - (eps/2) F(U)\n    U - exp(eps P) U\n    P - P - (eps/2) F(U)\n    \"\"\"\n    # Half-kick\n    F = force(U, alpha, M)\n    P_half = P - 0.5 * eps * F\n    # Drift\n    R = exp_su2(eps, P_half)\n    U_new = R @ U\n    # Half-kick\n    F_new = force(U_new, alpha, M)\n    P_new = P_half - 0.5 * eps * F_new\n    return U_new, P_new\n\ndef case_general():\n    alpha = 1.1\n    eps = 0.05\n    # U: theta=0.8, axis=(1,2,3)/||...||\n    axis_U = np.array([1.0, 2.0, 3.0])\n    axis_U /= np.linalg.norm(axis_U)\n    U = su2_from_axis_angle(0.8, axis_U)\n    # M: theta=0.3, axis=(0,1,0)\n    M = su2_from_axis_angle(0.3, np.array([0.0, 1.0, 0.0]))\n    # P: w=0.4*(1,0,0)\n    P = p_from_vec(np.array([0.4, 0.0, 0.0]))\n    return U, P, alpha, M, eps\n\ndef case_small_step():\n    alpha = 0.9\n    eps = 0.01\n    # U: theta=1.2, axis=(0.3,0.4,0.5)/||...||\n    axis = np.array([0.3, 0.4, 0.5])\n    axis /= np.linalg.norm(axis)\n    U = su2_from_axis_angle(1.2, axis)\n    # M: theta=0.7, axis=(0,0,1)\n    M = su2_from_axis_angle(0.7, np.array([0.0, 0.0, 1.0]))\n    # P: w=0.2 * normalized (0.2,0.8,0.5)\n    w = np.array([0.2, 0.8, 0.5])\n    w = 0.2 * w / np.linalg.norm(w)\n    P = p_from_vec(w)\n    return U, P, alpha, M, eps\n\ndef case_zero_momentum():\n    alpha = 1.5\n    eps = 0.02\n    # U: theta=0.5, axis=(0,1,1)/||...||\n    axis = np.array([0.0, 1.0, 1.0])\n    axis /= np.linalg.norm(axis)\n    U = su2_from_axis_angle(0.5, axis)\n    # M: theta=1.0, axis=(1,0,0)\n    M = su2_from_axis_angle(1.0, np.array([1.0, 0.0, 0.0]))\n    # P: zero\n    P = np.zeros((2, 2), dtype=complex)\n    return U, P, alpha, M, eps\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        case_general(),\n        case_small_step(),\n        case_zero_momentum(),\n    ]\n\n    results = []\n    for U, P, alpha, M, eps in test_cases:\n        # Compute initial Hamiltonian\n        H_before = hamiltonian(U, P, alpha, M)\n        # One leapfrog step\n        U_new, P_new = leapfrog_step(U, P, alpha, M, eps)\n        # Compute final Hamiltonian\n        H_after = hamiltonian(U_new, P_new, alpha, M)\n        dH = H_after - H_before\n        # Estimate leading O(eps^3) coefficient\n        if eps == 0:\n            c = float('nan')\n        else:\n            c = dH / (eps ** 3)\n        results.append(c)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在理想情况下，蛙跳积分器是完全时间可逆的。然而在真实的格点QCD计算中，费米子力的计算依赖于迭代求解器，这不可避免地会引入数值误差，从而破坏积分器完美的时间反演对称性。本练习通过一个简化的玩具模型来模拟这一效应，要求你量化这种对称性破缺的程度，将求解器精度这一抽象概念与HMC算法有效性的一个关键可观测量联系起来 。",
            "id": "3516849",
            "problem": "给定一个用于格点量子色动力学 (Lattice Quantum Chromodynamics, QCD) 的混合蒙特卡洛 (Hybrid Monte Carlo, HMC) 算法，考虑一个简化的阿贝尔格点规范模型，其中每个格点上的规范场是一个角度变量。设一个组态由一个包含 $V$ 个格点的角度向量 $U \\in \\mathbb{R}^{V}$ 和共轭动量 $P \\in \\mathbb{R}^{V}$ 表示。使用单链近似的 Wilson 规范作用量，\n$$\nS_{\\text{g}}[U] = \\beta \\sum_{i=1}^{V} \\left(1 - \\cos U_i\\right),\n$$\n并定义哈密顿量\n$$\nH(U,P) = S_{\\text{g}}[U] + \\frac{1}{2} \\sum_{i=1}^{V} P_i^2.\n$$\n精确规范力为\n$$\nF(U) = \\frac{\\partial S_{\\text{g}}}{\\partial U} = \\beta \\, \\sin U,\n$$\n该力逐分量地施加。哈密顿方程为\n$$\n\\frac{dU}{d\\tau} = \\frac{\\partial H}{\\partial P} = P, \\quad \\frac{dP}{d\\tau} = -\\frac{\\partial H}{\\partial U} = -F(U).\n$$\n使用步长为 $\\delta \\tau$ 且有 $L$ 步的标准蛙跳积分器：\n1. 动量的半步更新：$P \\leftarrow P - \\frac{\\delta \\tau}{2} \\tilde{F}(U;\\epsilon)$。\n2. 对于 $s = 1,\\dots,L-1$ 执行：\n   a. 坐标的全步更新：$U \\leftarrow U + \\delta \\tau \\, P$。\n   b. 动量的全步更新：$P \\leftarrow P - \\delta \\tau \\, \\tilde{F}(U;\\epsilon)$。\n3. 坐标的最后全步更新：$U \\leftarrow U + \\delta \\tau \\, P$。\n4. 动量的最后半步更新：$P \\leftarrow P - \\frac{\\delta \\tau}{2} \\tilde{F}(U;\\epsilon)$。\n\n在精确算术和精确力的情况下，蛙跳映射是时间可逆的。然而，在包含费米子的实际 HMC 中，非精确的线性求解会引入一个有限残差 $\\epsilon$，该残差会污染力。通过一个近似力来模拟这种有限精度和求解器残差的污染\n$$\n\\tilde{F}(U;\\epsilon) = F(U) + \\epsilon \\, \\lVert F(U) \\rVert_2 \\, \\hat{r},\n$$\n其中 $\\hat{r}$ 是一个根据伪随机数生成器种子确定性地构造的单位向量，并且在每次力的计算中都会改变，$\\lVert \\cdot \\rVert_2$ 是欧几里得范数。这模仿了残差容忍度为 $\\epsilon$ 的共轭梯度 (Conjugate Gradient, CG) 方法所引入的力误差，该误差与 $\\epsilon$ 乘以真实力的某个范数成正比。前向-后向可逆性测试使用以下循环：\n- 从 $(U_0, P_0)$ 开始，计算 $H_0 = H(U_0,P_0)$。\n- 使用 $\\tilde{F}(U;\\epsilon)$ 运行一个 $L$ 步的前向轨迹，得到 $(U_1, P_1)$。\n- 翻转动量，即 $(U_1, -P_1)$，并使用 $\\tilde{F}(U;\\epsilon)$ 运行一个 $L$ 步的后向轨迹，得到 $(U_2, P_2)$。\n- 计算循环能量差\n$$\n\\Delta H_{\\text{cycle}} = H(U_2, P_2) - H(U_0, P_0).\n$$\n\n您的任务是实现此模型，并通过测量 $\\Delta H_{\\text{cycle}}$ 作为线性求解器残差 $\\epsilon$ 的函数，来量化由有限精度引起的可逆性破坏。在此玩具模型中，绘制并验证标度趋势 $\\Delta H_{\\text{cycle}} \\propto \\epsilon \\times \\lVert \\partial H/\\partial U \\rVert_2$，其中 $\\partial H/\\partial U = F(U)$。\n\n实现要求：\n- 使用上面定义的蛙跳积分器。\n- 使用近似力模型 $\\tilde{F}(U;\\epsilon)$。\n- 对以下项使用具有指定整数种子的确定性伪随机数生成器：\n  - 初始动量（均值为零、单位方差的高斯分量）。\n  - 每次调用力函数时构造单位向量 $\\hat{r}$。前向轨迹和后向轨迹使用不同的种子，以模拟与方向相关的有限精度差异。\n- 在起始组态 $(U_0,P_0)$ 处计算 $\\lVert \\partial H/\\partial U \\rVert_2$ 作为 $\\lVert F(U_0) \\rVert_2$，用于解题中的诊断目的。程序的最终输出仅为测试套件中所有 $\\Delta H_{\\text{cycle}}$ 的列表。\n\n单位：\n- 所有量都是无量纲的。不需要物理单位。\n\n测试套件：\n为以下参数集提供结果，每个参数集产生一个标量 $\\Delta H_{\\text{cycle}}$ (一个浮点数)：\n1. 中等残差的一般情况：\n   - $V = 128$，$\\beta = 5.7$，$\\delta \\tau = 0.1$，$L = 50$，$\\epsilon = 10^{-8}$，初始 $U_0$ 从均值为 $0$、标准差为 $1$ 的正态分布中独立同分布抽取，使用种子 $123456$，初始 $P_0$ 从均值为 $0$、标准差为 $1$ 的正态分布中独立同分布抽取，使用种子 $123457$，前向力噪声种子 $987650$，后向力噪声种子 $987651$。\n2. 精确力（无残差）的边界情况：\n   - $V = 128$，$\\beta = 5.7$，$\\delta \\tau = 0.1$，$L = 50$，$\\epsilon = 0$，初始 $U_0$ 种子 $123456$，初始 $P_0$ 种子 $123457$，前向种子 $111111$，后向种子 $222222$。\n3. 小残差：\n   - $V = 128$，$\\beta = 5.7$，$\\delta \\tau = 0.1$，$L = 50$，$\\epsilon = 10^{-10}$，初始 $U_0$ 种子 $123456$，初始 $P_0$ 种子 $123457$，前向种子 $333333$，后向种子 $444444$。\n4. 较大残差：\n   - $V = 128$，$\\beta = 5.7$，$\\delta \\tau = 0.1$，$L = 50$，$\\epsilon = 10^{-6}$，初始 $U_0$ 种子 $123456$，初始 $P_0$ 种子 $123457$，前向种子 $555555$，后向种子 $666666$。\n5. 初始规范力范数消失的边缘情况：\n   - $V = 128$，$\\beta = 5.7$，$\\delta \\tau = 0.1$，$L = 50$，$\\epsilon = 10^{-8}$，初始 $U_0$ 设置为零向量，初始 $P_0$ 种子 $777777$，前向种子 $888888$，后向种子 $999999$。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含五个测试用例的 $\\Delta H_{\\text{cycle}}$ 结果，形式为方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$）。$r_i$ 必须打印为标准的 Python 浮点数。此行前后不应打印任何其他文本。",
            "solution": "该问题要求实现并分析一个玩具模型，用于研究混合蒙特卡洛 (Hybrid Monte Carlo, HMC) 算法中的可逆性破坏。HMC 算法是现代格点量子色动力学 (Lattice Quantum Chromodynamics, QCD) 模拟的基石。HMC 算法通过生成服从概率密度正比于 $e^{-S[U]}$ 的组态 $U$ 来实现其目的，其中 $S[U]$ 是作用量。它通过引入虚构动量 $P$ 并在相空间 $(U, P)$ 中模拟哈密顿动力学，然后执行一个 Metropolis-Hastings 接受步骤来达成这一目标。此接受步骤的有效性关键依赖于用于分子动力学 (MD) 轨迹的数值积分器的属性，特别是其时间可逆性和面积保持性（辛性）。\n\n所提供的模型将 QCD 的复杂动力学简化为一个 $V$ 格点上的阿贝尔规范模型，其中组态由一个角度向量 $U = (U_1, \\dots, U_V)$ 描述。系统的演化由哈密顿量控制：\n$$\nH(U,P) = S_{\\text{g}}[U] + \\frac{1}{2} \\sum_{i=1}^{V} P_i^2\n$$\n其中 $S_{\\text{g}}[U] = \\beta \\sum_{i=1}^{V} (1 - \\cos U_i)$ 是 Wilson 规范作用量，第二项是动能。运动方程由哈密顿方程给出：\n$$\n\\frac{dU_i}{d\\tau} = \\frac{\\partial H}{\\partial P_i} = P_i\n$$\n$$\n\\frac{dP_i}{d\\tau} = -\\frac{\\partial H}{\\partial U_i} = -\\frac{\\partial S_{\\text{g}}}{\\partial U_i} = -\\beta \\sin U_i = -F_i(U)\n$$\n这里，$\\tau$ 是虚构模拟时间，$F(U)$ 是规范力。\n\n这些方程使用蛙跳积分器进行数值求解，这是一种二阶辛方法。蛙跳积分器从时间 $\\tau$ 到 $\\tau + \\delta\\tau$ 的单步可以写成算符的复合：动量的半步漂移、位置的全步漂移，以及动量的另一次半步漂移。作为辛方法，它能保证相空间体积的守恒。关键是，它也是时间可逆的。如果我们将从 $(U(\\tau), P(\\tau))$ 到 $(U(\\tau+\\delta\\tau), P(\\tau+\\delta\\tau))$ 的映射表示为 $\\Phi_{\\delta\\tau}$，那么反转时间步长 $\\delta\\tau \\to -\\delta\\tau$ 等价于对映射求逆：$\\Phi_{-\\delta\\tau} = \\Phi_{\\delta\\tau}^{-1}$。一个实用的可逆性测试包括：向前运行一条总时长为 $T = L\\delta\\tau$ 的轨迹，翻转最终动量 $P \\to -P$，然后向后运行相同时间的轨迹。对于一个完美可逆的积分器，系统会精确地返回其初始状态 $(U_0, P_0)$。\n\n在实际的 HMC 模拟中，特别是那些包含动力学费米子的模拟，力的计算成本非常高昂。它需要求解一个大型稀疏线性系统，形式为 $D\\psi = \\eta$，其中 $D$ 是费米子矩阵。这通常使用诸如共轭梯度 (Conjugate Gradient, CG) 算法之类的迭代求解器来完成，当残差的范数达到某个容忍度 $\\epsilon$ 时，该算法会终止。这在力的计算中引入了一个小的、等效的随机误差。该问题用一个近似力来对此进行建模：\n$$\n\\tilde{F}(U;\\epsilon) = F(U) + \\epsilon \\, \\lVert F(U) \\rVert_2 \\, \\hat{r}\n$$\n其中 $F(U)$ 是精确的规范力，$\\lVert F(U) \\rVert_2$ 是其欧几里得范数，$\\hat{r}$ 是一个随机朝向的单位向量，在每次力的计算时都会改变。误差的大小与求解器容忍度 $\\epsilon$ 和力的大小成正比，这是一个符合实际的模型。\n\n引入这个误差项 $\\epsilon \\, \\lVert F(U) \\rVert_2 \\, \\hat{r}$ 破坏了蛙跳积分器的时间可逆性。误差向量 $\\hat{r}$ 由一个伪随机数生成器 (PRNG) 生成。当通过翻转动量来反转轨迹时，后向路径上追踪的 $U$ 状态序列与前向路径上的近似相同，但 PRNG 会继续前进。它会生成一个新的、独立的随机向量序列 $\\hat{r}$。前向轨迹中的误差不会被后向轨迹中的误差抵消，从而导致偏离初始状态。\n\n任务是通过测量完整前向-后向循环中的哈密顿量变化 $\\Delta H_{\\text{cycle}} = H(U_2, P_2) - H(U_0, P_0)$ 来量化这种破坏。最终状态与初始状态的偏差 $(U_2 - U_0, P_2 - P_0)$ 预期为 $\\mathcal{O}(\\epsilon)$ 阶。通过泰勒展开，哈密顿量的变化为 $\\Delta H_{\\text{cycle}} \\approx \\nabla H \\cdot (U_2 - U_0, P_2 - P_0)$，这意味着 $\\Delta H_{\\text{cycle}}$ 也应为 $\\mathcal{O}(\\epsilon)$ 阶。问题进一步提出了一个特定的标度关系 $\\Delta H_{\\text{cycle}} \\propto \\epsilon \\times \\lVert F(U_0) \\rVert_2$，我们将对此进行研究。\n\n实现将包括以下组件：\n1.  用于计算作用量 $S_{\\text{g}}[U]$ 和总哈密顿量 $H(U, P)$ 的函数。\n2.  一个计算近似力 $\\tilde{F}(U; \\epsilon)$ 的函数，该函数内部计算精确力 $F(U) = \\beta \\sin U$ 并添加误差项。此函数将接受一个 PRNG 对象作为参数，以正确管理随机数序列的状态。\n3.  一个实现蛙跳积分器的函数，如问题中所述，执行 $L$ 个大小为 $\\delta\\tau$ 的积分步骤。\n4.  一个主程序，为每个参数集执行完整的可逆性测试：\n    a. 使用指定的种子初始化相空间坐标 $(U_0, P_0)$。\n    b. 计算初始能量 $H_0$。\n    c. 从 $(U_0, P_0)$ 开始，使用特定的 PRNG 种子进行力噪声计算，运行一条 $L$ 步的前向 MD 轨迹，得到 $(U_1, P_1)$。\n    d. 从 $(U_1, -P_1)$ 开始，使用不同的 PRNG 种子进行力噪声计算，运行一条 $L$ 步的后向 MD 轨迹，得到 $(U_2, P_2)$。\n    e. 计算最终能量 $H_2 = H(U_2, P_2)$ 和差值 $\\Delta H_{\\text{cycle}} = H_2 - H_0$。\n\n测试套件旨在探究 $\\Delta H_{\\text{cycle}}$ 的行为：\n-   案例 1 ($V=128$, $\\beta=5.7$, $\\epsilon=10^{-8}$): 一个典型场景，应产生一个微小但可测量的可逆性破坏。\n-   案例 2 ($\\epsilon=0$): 控制案例。使用精确力，蛙跳积分器在标准浮点算术误差范围内是可逆的。$\\Delta H_{\\text{cycle}}$ 应接近于零（例如，约 $10^{-14}$ 或更小）。\n-   案例 3 和 4 ($\\epsilon=10^{-10}$ 和 $\\epsilon=10^{-6}$): 这些案例与案例 1 一起，用于测试 $\\Delta H_{\\text{cycle}}$ 与 $\\epsilon$ 的线性标度关系。我们预期结果相对于案例 1 分别按 $10^{-2}$ 和 $10^2$ 的因子进行缩放。\n-   案例 5 ($U_0 = \\vec{0}$): 一个边缘案例，其中初始力为零，$\\lVert F(U_0) \\rVert_2 = 0$。这意味着在第一步时误差项也为零。然而，当系统在非零初始动量 $P_0$ 的影响下演化时，$U$ 会变得非零，导致非零的力以及随后破坏可逆性的误差累积。此案例表明，与 $\\lVert F(U_0) \\rVert_2$ 成正比的简单标度关系可能具有误导性；一个更准确的标度关系将依赖于整个轨迹上的力的范数的积分。结果仍应非零，并大致与 $\\epsilon$ 成正比。\n\n通过执行这些测试，我们可以数值上验证关于 HMC 中求解器不精确性如何表现为对基本守恒律和对称性的破坏的理论理解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_action(U, beta):\n    \"\"\"Calculates the Wilson gauge action for the U(1) model.\"\"\"\n    return beta * np.sum(1.0 - np.cos(U))\n\ndef calculate_hamiltonian(U, P, beta):\n    \"\"\"Calculates the Hamiltonian for the system.\"\"\"\n    action = calculate_action(U, beta)\n    kinetic_energy = 0.5 * np.sum(P**2)\n    return action + kinetic_energy\n\ndef exact_force(U, beta):\n    \"\"\"Calculates the exact gauge force F(U) = beta * sin(U).\"\"\"\n    return beta * np.sin(U)\n\ndef approximate_force(U, beta, epsilon, rng):\n    \"\"\"\n    Calculates the approximate force, including a modeled error term.\n    F_tilde = F(U) + epsilon * ||F(U)||_2 * r_hat\n    \"\"\"\n    F = exact_force(U, beta)\n    if epsilon == 0.0:\n        return F\n    \n    F_norm = np.linalg.norm(F)\n    if F_norm == 0.0:\n        return F\n        \n    # Generate a random vector and normalize it to get the unit vector r_hat\n    r = rng.standard_normal(size=U.shape)\n    r_norm = np.linalg.norm(r)\n    \n    # Handle the unlikely case where the random vector is zero\n    if r_norm == 0.0:\n      r_hat = np.zeros_like(r)\n    else:\n      r_hat = r / r_norm\n    \n    # Calculate the contaminated force\n    F_tilde = F + epsilon * F_norm * r_hat\n    return F_tilde\n\ndef leapfrog_integrator(U_start, P_start, dt, L, beta, epsilon, force_rng):\n    \"\"\"\n    Performs a molecular dynamics trajectory using the leapfrog algorithm.\n    \"\"\"\n    U = U_start.copy()\n    P = P_start.copy()\n\n    # Initial half-step for momentum (\"P-U-P\" scheme)\n    P -= 0.5 * dt * approximate_force(U, beta, epsilon, force_rng)\n\n    # L-1 full steps for position and momentum\n    for _ in range(L - 1):\n        U += dt * P\n        P -= dt * approximate_force(U, beta, epsilon, force_rng)\n\n    # Final full step for position\n    U += dt * P\n    \n    # Final half-step for momentum\n    P -= 0.5 * dt * approximate_force(U, beta, epsilon, force_rng)\n\n    return U, P\n\ndef run_reversibility_test(V, beta, dt, L, epsilon, u0_seed, p0_seed, fwd_seed, bwd_seed, u0_is_zero=False):\n    \"\"\"\n    Runs the full forward-backward reversibility test for a given set of parameters.\n    \"\"\"\n    # 1. Initialize initial conditions\n    p0_rng = np.random.default_rng(p0_seed)\n    \n    if u0_is_zero:\n        U0 = np.zeros(V, dtype=np.float64)\n    else:\n        u0_rng = np.random.default_rng(u0_seed)\n        U0 = u0_rng.normal(loc=0.0, scale=1.0, size=V)\n    \n    P0 = p0_rng.normal(loc=0.0, scale=1.0, size=V)\n\n    # 2. Calculate the initial Hamiltonian\n    H0 = calculate_hamiltonian(U0, P0, beta)\n\n    # 3. Run the forward trajectory\n    fwd_rng = np.random.default_rng(fwd_seed)\n    U1, P1 = leapfrog_integrator(U0, P0, dt, L, beta, epsilon, fwd_rng)\n\n    # 4. Run the backward trajectory with flipped momentum\n    bwd_rng = np.random.default_rng(bwd_seed)\n    U2, P2 = leapfrog_integrator(U1, -P1, dt, L, beta, epsilon, bwd_rng)\n    \n    # 5. Calculate the final Hamiltonian and the cycle energy difference\n    H2 = calculate_hamiltonian(U2, P2, beta)\n    delta_H_cycle = H2 - H0\n    \n    return delta_H_cycle\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (V, beta, dt, L, epsilon, u0_seed, p0_seed, fwd_seed, bwd_seed, u0_is_zero)\n        (128, 5.7, 0.1, 50, 1e-8, 123456, 123457, 987650, 987651, False),\n        (128, 5.7, 0.1, 50, 0.0, 123456, 123457, 111111, 222222, False),\n        (128, 5.7, 0.1, 50, 1e-10, 123456, 123457, 333333, 444444, False),\n        (128, 5.7, 0.1, 50, 1e-6, 123456, 123457, 555555, 666666, False),\n        (128, 5.7, 0.1, 50, 1e-8, 0, 777777, 888888, 999999, True), \n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_reversibility_test(*params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "HMC模拟的计算成本极高，因此性能优化至关重要。一个关键的观察是，哈密顿量中不同部分（如规范场和费米子）产生的作用力，其大小和计算成本差异巨大。本练习将介绍Sexton-Weingarten多时间尺度积分方案，这是一种利用这种差异来显著提高模拟效率的高级技巧。你将通过一个实际的成本效益分析问题，学习如何寻找最优的积分参数设置 。",
            "id": "3516754",
            "problem": "考虑用于格点量子色动力学 (QCD) 的混合蒙特卡洛 (HMC) 算法，其中作用量被分为规范部分 $S_{g}$ 和赝费米子部分 $S_{f}$。在一个采用可逆、辛、二阶更新的双层多重时间尺度积分器（Sexton–Weingarten 方案）中，假设分子动力学轨迹长度固定为 $\\tau = 1$（以分子动力学时间为单位）。设费米子力的粗略步数为 $N_{f}$，步长为 $h_{f} = \\tau / N_{f}$；规范力的精细步数为 $N_{g}$，步长为 $h_{g} = \\tau / N_{g}$。定义时间尺度比为 $m = N_{g}/N_{f}$，因此 $h_{g} = h_{f}/m$。\n\n假设期望能量差的领头阶（关于步长）模型为\n$$\n\\langle \\Delta H \\rangle \\approx C_{g}\\, h_{g}^{2} + C_{f}\\, h_{f}^{2},\n$$\n其中有效系数由 $C_{i} = \\zeta_{i}\\, \\|F_{i}\\|^{2}$ 给出，$i \\in \\{g,f\\}$，$\\|F_{g}\\|$ 和 $\\|F_{f}\\|$ 分别表示测得的规范力和费米子力的 $\\ell_{2}$ 范数，$\\zeta_{g}$ 和 $\\zeta_{f}$ 是测得的正常数，它们包含了积分器的领头对易子结构和流的几何信息。\n\n您已经执行了简短的校准运行并测量得到：\n- $\\|F_{g}\\| = 0.75$，\n- $\\|F_{f}\\| = 0.30$，\n- $\\zeta_{g} = 1.8$，\n- $\\zeta_{f} = 2.5$。\n\n规范力的单次计算成本为 $c_{g} = 1$，费米子力的单次计算成本为 $c_{f} = 40$。对于单条轨迹，您有固定的总力计算预算 $B = 400$，这构成了以下约束条件：\n$$\nN_{g}\\, c_{g} + N_{f}\\, c_{f} = B.\n$$\n\n在这些假设下，确定最优实数值比率 $m = N_{g}/N_{f}$，该比率在预算约束下最小化 $\\langle \\Delta H \\rangle$ 的领头阶模型。将您的最终答案表示为一个四舍五入到四位有效数字的数值。比率 $m$ 是无量纲的，因此不需要单位。",
            "solution": "用户希望我解决一个源自格点量子色动力学 (QCD) 的混合蒙特卡洛 (HMC) 算法背景下的约束优化问题。\n\n### 问题验证\n\n#### 第1步：提取已知条件\n\n-   **算法背景**：用于格点 QCD 的混合蒙特卡洛 (HMC)。\n-   **作用量拆分**：$S = S_g + S_f$，其中 $S_g$ 是规范部分，$S_f$ 是赝费米子部分。\n-   **积分器方案**：使用可逆、辛、二阶更新的双层多重时间尺度（Sexton–Weingarten）方案。\n-   **轨迹长度**：$\\tau = 1$（分子动力学时间单位）。\n-   **步数**：$N_f$ 用于粗略步（费米子力），$N_g$ 用于精细步（规范力）。\n-   **步长**：$h_f = \\tau / N_f$，$h_g = \\tau / N_g$。\n-   **时间尺度比**：$m = N_g / N_f$，这意味着 $h_g = h_f / m$。\n-   **能量差模型**：$\\langle \\Delta H \\rangle \\approx C_{g}\\, h_{g}^{2} + C_{f}\\, h_{f}^{2}$。\n-   **有效系数**：$C_{i} = \\zeta_{i}\\, \\|F_{i}\\|^{2}$，对于 $i \\in \\{g,f\\}$。\n-   **测量的校准数据**：\n    -   $\\|F_{g}\\| = 0.75$\n    -   $\\|F_{f}\\| = 0.30$\n    -   $\\zeta_{g} = 1.8$\n    -   $\\zeta_{f} = 2.5$\n-   **计算成本**：每次规范力计算为 $c_{g} = 1$，每次费米子力计算为 $c_{f} = 40$。\n-   **计算预算**：单条轨迹的总成本由预算 $B = 400$ 固定。\n-   **预算约束**：$N_{g}\\, c_{g} + N_{f}\\, c_{f} = B$。\n-   **目标**：确定在预算约束下最小化 $\\langle \\Delta H \\rangle$ 的最优实数值比率 $m = N_g/N_f$。\n-   **输出要求**：$m$ 的最终答案必须四舍五入到四位有效数字。\n\n#### 第2步：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题在计算高能物理领域有充分的依据。Sexton–Weingarten 方案是 HMC 模拟中使用的标准多重时间尺度积分器。能量差 $\\langle \\Delta H \\rangle$ 的领头阶误差模型随步长的平方（$h_g^2, h_f^2$）缩放，这是二阶辛积分器的典型特征。计算成本的制定及其优化是大规模模拟中的核心和实际任务。所有前提都具有科学合理性。\n-   **适定性**：该问题提供了一个明确的待最小化目标函数（$\\langle \\Delta H \\rangle$）、一个明确定义的约束条件（预算 $B$），以及所有必要的常数和变量之间的关系。这种结构允许存在唯一解。\n-   **客观性**：该问题使用精确的数学和物理术语陈述，没有主观或模糊的语言。\n\n该问题没有任何无效性缺陷。它是一个标准的、定义明确且具有科学意义的约束优化问题。\n\n#### 第3步：结论与行动\n\n问题陈述是**有效的**。开始求解。\n\n### 求解过程\n\n目标是在固定的计算预算下，最小化期望的能量差 $\\langle \\Delta H \\rangle$。该问题可以被表述为一个约束优化问题。\n\n要最小化的量是能量差，我们将其表示为 $E$：\n$$ E = C_{g}\\, h_{g}^{2} + C_{f}\\, h_{f}^{2} $$\n步长与步数和轨迹长度 $\\tau=1$ 相关：\n$$ h_{f} = \\frac{\\tau}{N_{f}} = \\frac{1}{N_{f}} \\quad \\text{且} \\quad h_{g} = \\frac{\\tau}{N_{g}} = \\frac{1}{N_{g}} $$\n将这些代入 $E$ 的表达式，得到以 $N_f$ 和 $N_g$ 为变量的目标函数：\n$$ E(N_f, N_g) = \\frac{C_g}{N_g^2} + \\frac{C_f}{N_f^2} $$\n此最小化问题受计算预算约束：\n$$ N_{g}\\, c_{g} + N_{f}\\, c_{f} = B $$\n我们首先使用所提供的数据计算系数 $C_g$ 和 $C_f$ 的数值：\n$C_{g} = \\zeta_{g}\\, \\|F_{g}\\|^{2} = 1.8 \\times (0.75)^{2} = 1.8 \\times 0.5625 = 1.0125$。\n$C_{f} = \\zeta_{f}\\, \\|F_{f}\\|^{2} = 2.5 \\times (0.30)^{2} = 2.5 \\times 0.09 = 0.225$。\n\n为了解决这个约束优化问题，我们使用拉格朗日乘数法。拉格朗日函数 $\\mathcal{L}$ 为：\n$$ \\mathcal{L}(N_f, N_g, \\lambda) = \\left( \\frac{C_g}{N_g^2} + \\frac{C_f}{N_f^2} \\right) + \\lambda (N_{g}\\, c_{g} + N_{f}\\, c_{f} - B) $$\n为了找到极值，我们将 $\\mathcal{L}$ 对 $N_f$、$N_g$ 和 $\\lambda$ 的偏导数设为零。我们主要关心最小化 $E$ 的 $N_f$ 和 $N_g$ 之间的关系。\n$$ \\frac{\\partial \\mathcal{L}}{\\partial N_g} = -\\frac{2 C_g}{N_g^3} + \\lambda c_g = 0 \\implies \\lambda c_g = \\frac{2 C_g}{N_g^3} $$\n$$ \\frac{\\partial \\mathcal{L}}{\\partial N_f} = -\\frac{2 C_f}{N_f^3} + \\lambda c_f = 0 \\implies \\lambda c_f = \\frac{2 C_f}{N_f^3} $$\n我们可以从两个方程中解出拉格朗日乘数 $\\lambda$：\n$$ \\lambda = \\frac{2 C_g}{c_g N_g^3} \\quad \\text{且} \\quad \\lambda = \\frac{2 C_f}{c_f N_f^3} $$\n令两个 $\\lambda$ 的表达式相等，得到最优性条件：\n$$ \\frac{2 C_g}{c_g N_g^3} = \\frac{2 C_f}{c_f N_f^3} $$\n$$ \\frac{C_g}{c_g N_g^3} = \\frac{C_f}{c_f N_f^3} $$\n我们想要找到最优比率 $m = N_g/N_f$。重新整理方程以求解 $N_g/N_f$：\n$$ \\frac{N_g^3}{N_f^3} = \\frac{C_g c_f}{C_f c_g} $$\n$$ \\left(\\frac{N_g}{N_f}\\right)^3 = \\frac{c_f C_g}{c_g C_f} $$\n对两边取立方根，得到最优比率 $m$ 的表达式：\n$$ m = \\left( \\frac{c_f C_g}{c_g C_f} \\right)^{1/3} $$\n现在我们代入给定的数值：\n-   $c_g = 1$\n-   $c_f = 40$\n-   $C_g = 1.0125$\n-   $C_f = 0.225$\n\n$$ m = \\left( \\frac{40 \\times 1.0125}{1 \\times 0.225} \\right)^{1/3} $$\n$$ m = \\left( \\frac{40.5}{0.225} \\right)^{1/3} $$\n化简分数：\n$$ \\frac{40.5}{0.225} = \\frac{40500}{225} = 180 $$\n因此，最优比率为：\n$$ m = (180)^{1/3} $$\n题目要求我们将此值四舍五入到四位有效数字。\n$$ m \\approx 5.646237 \\dots $$\n四舍五入到四位有效数字得到 $m = 5.646$。\n请注意，寻找最优比率 $m$ 并不需要预算 $B=400$，但若要计算 $N_f$ 和 $N_g$ 的实际值则需要它：$N_g = m N_f \\implies (m c_g + c_f)N_f = B \\implies N_f = B / (m c_g + c_f)$。",
            "answer": "$$\\boxed{5.646}$$"
        }
    ]
}