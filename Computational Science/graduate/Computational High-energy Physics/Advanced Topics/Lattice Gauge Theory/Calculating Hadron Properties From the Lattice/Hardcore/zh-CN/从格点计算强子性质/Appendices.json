{
    "hands_on_practices": [
        {
            "introduction": "计算格点上的强子关联函数是所有格点QCD计算的核心。为了实际计算这些关联函数，我们必须首先将由夸克和胶子场构成的强子插值算符表达式，通过维克定理展开成一系列夸克传播子的乘积。这个练习  将带你动手实践这一关键步骤，通过质子这个典型的例子，让你掌握进行维克收缩和处理伴随的$SU(3)$色代数的必要技能。",
            "id": "3507023",
            "problem": "考虑欧几里得空间中的量子色动力学 (QCD)，其色群为3阶特殊幺正群 (SU(3))。令 $u(x)$ 和 $d(x)$ 表示格拉斯曼值的上夸克场和下夸克场，其色指标为 $a,b,c \\in \\{1,2,3\\}$，狄拉克旋量指标已省略。定义在时空点 $x$ 处的标准局域质子内插算符为，\n$$\nO_{p}(x) \\equiv \\epsilon^{abc} \\left( u^{a}(x) \\right)^{T} C \\gamma_{5} d^{b}(x)\\, u^{c}(x),\n$$\n其中 $\\epsilon^{abc}$ 是色空间中的全反对称列维-奇维塔符号，$\\gamma_{5}$ 是欧几里得手征矩阵，$C$ 是电荷共轭矩阵，满足 $C \\gamma_{\\mu} C^{-1} = - \\gamma_{\\mu}^{T}$ 和 $C^{T} = - C$。在原点处的共轭算符为\n$$\n\\bar{O}_{p}(0) \\equiv \\epsilon^{a'b'c'}\\, \\bar{u}^{c'}(0)\\, \\bar{d}^{b'}(0)\\, \\gamma_{5} C \\left( \\bar{u}^{a'}(0) \\right)^{T}.\n$$\n零动量欧几里得两点关联函数为\n$$\nC(t) \\equiv \\sum_{\\vec{x}} \\left\\langle O_{p}(\\vec{x},t)\\, \\bar{O}_{p}(\\vec{0},0) \\right\\rangle,\n$$\n其中路径积分平均是对规范场和费米子场进行的，并且通常的费米子Wick收缩产生夸克传播子 $S_{f}(x,0) \\equiv \\left\\langle f(x)\\, \\bar{f}(0) \\right\\rangle$，味 $f \\in \\{u,d\\}$。\n\n从格拉斯曼场的Wick定理和 $\\epsilon^{abc}$ 的反对称性出发，对 $O_{p}(\\vec{x},t)$ 和 $\\bar{O}_{p}(\\vec{0},0)$ 中的场进行Wick收缩，并仔细考虑：\n- 两个相同的上夸克场和两个相同的反上夸克场，它们允许 $2!$ 种不同的配对方式，以及\n- 实现每种配对时因费米子反对易而产生的置换符号。\n\n然后，执行由收缩产生的列维-奇维塔符号和克罗内克δ函数的乘积所蕴含的色指标代数运算，并对色指标求和。所有狄拉克旋量结构和伽马矩阵都保持不求值；在色求和完成后，仅关注乘以旋量空间收缩的总色系数。\n\n计算最终的总色因子 $F_{\\text{color}}$，其结果为一个整数。不需要四舍五入，$F_{\\text{color}}$ 也没有物理单位；请将 $F_{\\text{color}}$ 作为纯数报告。",
            "solution": "基本依据是格拉斯曼场的Wick定理以及费米子场和列维-奇维塔符号的反对称性质。我们在欧几里得空间中进行计算，并且只执行色代数运算，而将包含 $\\gamma_{5}$ 和 $C$ 的旋量结构保持隐式。\n\n我们从关联函数内部算符的显式乘积开始，\n$$\nO_{p}(\\vec{x},t)\\, \\bar{O}_{p}(\\vec{0},0) = \\epsilon^{abc}\\, \\epsilon^{a'b'c'} \\left( u^{a} \\right)^{T} C \\gamma_{5} d^{b}\\, u^{c}\\, \\bar{u}^{c'}\\, \\bar{d}^{b'}\\, \\gamma_{5} C \\left( \\bar{u}^{a'} \\right)^{T},\n$$\n其中所有场都在相应的时空点上取值，为简洁起见，我们省略了显式变量。根据格拉斯曼场的Wick定理，关联函数是 $u$ 与 $\\bar{u}$ 以及 $d$ 与 $\\bar{d}$ 的所有完全配对的和，每种配对贡献一个传播子乘积，并乘以一个符号，该符号由将场带入收缩对所需的置换宇称确定。\n\n对于 $d$ 场，存在唯一的配对：$d^{b}$ 与 $\\bar{d}^{b'}$ 配对。对于 $u$ 场，有两个相同的上夸克场 $u^{a}$ 和 $u^{c}$ 以及两个对应的反上夸克场 $\\bar{u}^{a'}$ 和 $\\bar{u}^{c'}$。因此，存在 $2! = 2$ 种不同的配对：\n- 直接配对：$u^{a}$ 与 $\\bar{u}^{a'}$ 收缩，$u^{c}$ 与 $\\bar{u}^{c'}$ 收缩。\n- 交换配对：$u^{a}$ 与 $\\bar{u}^{c'}$ 收缩，$u^{c}$ 与 $\\bar{u}^{a'}$ 收缩。\n\n每次收缩都会在被收缩场的色指标之间产生一个色空间中的克罗内克δ函数。对于 $d$ 场，我们得到 $\\delta_{bb'}$。对于 $u$ 场，直接配对产生 $\\delta_{aa'}\\, \\delta_{cc'}$，而交换配对产生 $\\delta_{ac'}\\, \\delta_{ca'}$。\n\n因此，两种配对的色结构为\n$$\n\\text{直接配对:}\\quad \\epsilon^{abc}\\, \\epsilon^{a'b'c'}\\, \\delta_{aa'}\\, \\delta_{bb'}\\, \\delta_{cc'},\n$$\n和\n$$\n\\text{交换配对:}\\quad \\epsilon^{abc}\\, \\epsilon^{a'b'c'}\\, \\delta_{ac'}\\, \\delta_{bb'}\\, \\delta_{ca'}.\n$$\n\n我们现在进行色求和。对于直接配对，\n$$\n\\sum_{a,b,c,a',b',c'} \\epsilon^{abc}\\, \\epsilon^{a'b'c'}\\, \\delta_{aa'}\\, \\delta_{bb'}\\, \\delta_{cc'} = \\sum_{a,b,c} \\epsilon^{abc}\\, \\epsilon^{abc}.\n$$\n使用标准恒等式\n$$\n\\sum_{a,b,c=1}^{3} \\epsilon^{abc}\\, \\epsilon^{abc} = 3! = 6,\n$$\n我们发现直接色因子等于 $6$。\n\n对于交换配对，\n$$\n\\sum_{a,b,c,a',b',c'} \\epsilon^{abc}\\, \\epsilon^{a'b'c'}\\, \\delta_{ac'}\\, \\delta_{bb'}\\, \\delta_{ca'} = \\sum_{a,b,c} \\epsilon^{abc}\\, \\epsilon^{cba}.\n$$\n映射 $(a,b,c) \\mapsto (c,b,a)$ 是一次对换（交换 $a$ 和 $c$），是奇置换。因此，\n$$\n\\epsilon^{cba} = -\\, \\epsilon^{abc},\n$$\n从而\n$$\n\\sum_{a,b,c} \\epsilon^{abc}\\, \\epsilon^{cba} = - \\sum_{a,b,c} \\epsilon^{abc}\\, \\epsilon^{abc} = - 6.\n$$\n所以，由 $\\epsilon$ 收缩和克罗内克δ函数得到的交换色因子为 $-6$。\n\n我们还必须考虑与实现相同上夸克场的交换配对所需的置换相关的费米子符号。格拉斯曼场的Wick定理规定，交换相同费米子的配对会在直接配对和交换配对之间引入一个相对负号。因此，相对于直接项，交换贡献从费米子置换宇称中获得一个额外的 $-1$ 因子。\n\n将费米子符号与交换配对的色代数结合起来，得到\n$$\n(+\\text{直接配对的费米子符号}) \\times 6 \\quad\\text{和}\\quad (-\\text{交换配对的费米子符号}) \\times (-6) = +6.\n$$\n因此，两种配对都对总色因子贡献 $+6$。对两种配对求和，\n$$\nF_{\\text{color}} = 6 + 6 = 12.\n$$\n\n这个 $F_{\\text{color}}$ 乘以由 $C \\gamma_{5}$ 插入和传播子的旋量指标产生的任何旋量空间结构；我们已按要求保持这些结构不被求值。最终的总色因子是纯数 $12$。",
            "answer": "$$\\boxed{12}$$"
        },
        {
            "introduction": "从格点计算得到的原始关联函数数据不仅包含了我们感兴趣的基态信息，还混杂了其所有更重的激发态的贡献。这个练习  旨在演示一种强大的技术——算符“涂抹”（smearing），它能够有效地增强基态信号并压低激发态污染。通过定量比较不同涂抹策略的效果，你将获得关于如何设计高效、精确的格点计算的实用见解。",
            "id": "3507002",
            "problem": "考虑由强子的内插算符构建的格点量子色动力学 (LQCD) 两点欧几里得关联函数。零动量下强子的关联函数可以表示为源于传输矩阵形式的谱分解。在反射正定性和有限格点上离散谱的标准假设下，该关联函数的形式为\n$$\nC(t) = \\sum_{n=0}^{N-1} A_n \\exp\\left(-E_n \\frac{t\\,a}{\\hbar c}\\right),\n$$\n其中 $t$ 是以格点时间步长为单位的欧几里得时间间隔，$a$ 是以飞米为单位的格点间距，$\\hbar c$ 是普朗克常数乘以光速，单位为 $\\mathrm{GeV\\,fm}$，$E_n$ 是以 $\\mathrm{GeV}$ 为单位的能级，而 $A_n$ 是由下式给出的非负振幅\n$$\nA_n = Z_n^{(\\mathrm{src})} Z_n^{(\\mathrm{sink})},\n$$\n$Z_n^{(\\mathrm{src})}$ 和 $Z_n^{(\\mathrm{sink})}$ 分别是第 $n$ 个能量本征态与源算符和汇算符的重叠因子。所有 $Z$-重叠因子均被视为无量纲的，且 $C(t)$ 的归一化由这些重叠因子控制。\n\n你需要通过分析重叠因子 $Z_n$ 和由此产生的激发态污染，比较在固定反演成本下，两种用于介子与重子的算符涂抹策略。这两种策略是：\n1. 仅源涂抹 (SSO)：源针对基态进行优化，而汇是局域的（未涂抹）。\n2. 汇涂抹 (SS)：源被适度涂抹，而汇被涂抹以增强基态重叠并抑制激发态重叠。\n\n假设反演成本预算固定，其中两种策略对每种强子类别都使用单次反演，且汇涂抹在收缩步骤中应用，无需额外反演。为进行物理上合理的比较，请使用以下常数：\n- 格点间距 $a = 0.09\\,\\mathrm{fm}$，\n- $\\hbar c = 0.1973269804\\,\\mathrm{GeV\\,fm}$。\n\n对每种强子类型和策略，使用以下能谱（单位为 $\\mathrm{GeV}$）和重叠因子：\n- 介子能级：$E_0 = 0.77$, $E_1 = 1.40$, $E_2 = 1.80$。\n  - 介子 SSO：$Z^{(\\mathrm{src})} = [1.0, 0.25, 0.10]$，$Z^{(\\mathrm{sink})} = [0.80, 0.70, 0.60]$。\n  - 介子 SS：$Z^{(\\mathrm{src})} = [0.80, 0.50, 0.30]$，$Z^{(\\mathrm{sink})} = [1.20, 0.40, 0.20]$。\n- 重子能级：$E_0 = 0.94$, $E_1 = 1.50$, $E_2 = 1.90$。\n  - 重子 SSO：$Z^{(\\mathrm{src})} = [1.0, 0.35, 0.20]$，$Z^{(\\mathrm{sink})} = [0.60, 0.70, 0.65]$。\n  - 重子 SS：$Z^{(\\mathrm{src})} = [0.80, 0.50, 0.30]$，$Z^{(\\mathrm{sink})} = [1.00, 0.50, 0.30]$。\n\n将在欧几里得时间 $t$ 处的激发态污染分数定义为\n$$\nf_{\\mathrm{exc}}(t) = \\frac{C(t) - A_0 \\exp\\left(-E_0 \\frac{t\\,a}{\\hbar c}\\right)}{A_0 \\exp\\left(-E_0 \\frac{t\\,a}{\\hbar c}\\right)},\n$$\n该值为无量纲，并将有效质量定义为\n$$\nm_{\\mathrm{eff}}(t) = \\frac{\\hbar c}{a} \\ln\\left(\\frac{C(t)}{C(t+1)}\\right),\n$$\n其单位为 $\\mathrm{GeV}$。有效质量偏差定义为\n$$\n\\Delta m(t) = m_{\\mathrm{eff}}(t) - E_0,\n$$\n应以 $\\mathrm{GeV}$ 为单位报告。\n\n你的任务是实现一个程序，该程序针对一个指定的测试套件，为每个案例计算 $f_{\\mathrm{exc}}(t)$ 和 $\\Delta m(t)$，将污染分数报告为无量纲浮点数，并将有效质量偏差以 $\\mathrm{GeV}$ 为单位报告。所有报告的浮点数必须四舍五入到六位小数。\n\n测试套件（每个项目是强子类型、策略和欧几里得时间 $t$ 的元组）：\n- 案例 $1$：介子，SSO，$t = 8$。\n- 案例 $2$：介子，SS，$t = 8$。\n- 案例 $3$：重子，SSO，$t = 8$。\n- 案例 $4$：重子，SS，$t = 8$。\n- 案例 $5$：介子，SS，$t = 2$。\n- 案例 $6$：重子，SSO，$t = 1$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每个测试案例，首先输出 $f_{\\mathrm{exc}}(t)$（无量纲），然后输出 $\\Delta m(t)$（单位为 $\\mathrm{GeV}$），两者都四舍五入到六位小数。该列表必须按照上面列出的顺序将所有测试案例的结果展平。例如，输出必须看起来像\n$[f_1,\\Delta m_1,f_2,\\Delta m_2,\\dots,f_6,\\Delta m_6]$,\n其中每个 $f_i$ 和 $\\Delta m_i$ 都是四舍五入到六位小数的浮点数。",
            "solution": "该问题要求计算格点量子色动力学 (LQCD) 分析中的两个关键量：激发态污染分数 $f_{\\mathrm{exc}}(t)$ 和有效质量偏差 $\\Delta m(t)$，这些计算是针对一组指定的强子态、涂抹策略和欧几里得时间。解决方案的步骤是首先验证问题的科学和数学合理性，然后基于所提供的理论框架实施直接计算。\n\n该问题被认为是有效的，因为它在科学上基于 LQCD 的原理，特别是欧几里得两点关联函数的谱分解。所有提供的公式、常数和数据都与该领域的既定实践一致，并且足以得出一个唯一的、适定的解。\n\n基本量是零动量下的两点关联函数，由以下谱表示给出：\n$$\nC(t) = \\sum_{n=0}^{N-1} A_n \\exp\\left(-E_n \\frac{t\\,a}{\\hbar c}\\right)\n$$\n这里，$t$ 是离散的欧几里得时间，$a$ 是格点间距，$\\hbar c$ 是物理转换常数，$E_n$ 是系统的能量本征态，$A_n$ 是振幅。问题指定了三个能量态（$n=0, 1, 2$），因此总和是对 $N=3$ 个态进行的。振幅 $A_n$ 是源和汇重叠因子的乘积，$A_n = Z_n^{(\\mathrm{src})} Z_n^{(\\mathrm{sink})}$。所有必要的参数（$a$、$\\hbar c$、$E_n$、$Z_n$）都已提供。\n\n计算过程如下：\n\n1.  **常数和数据初始化**：定义物理常数：$a = 0.09\\,\\mathrm{fm}$ 和 $\\hbar c = 0.1973269804\\,\\mathrm{GeV\\,fm}$。无量纲比率 $\\frac{a}{\\hbar c}$ 作为转换因子，用于将物理能量单位（$\\mathrm{GeV}$）转换为指数衰减中的无量纲格点单位。将问题中提供的介子和重子在仅源涂抹 (SSO) 和汇涂抹 (SS) 策略下的能谱和重叠因子组织成一个合适的数据结构以便查找。\n\n2.  **关联函数**：实现一个函数，用于计算在任何给定整数时间 $t$ 和一组参数（$E_n, A_n, a, \\hbar c$）下的 $C(t)$。该函数对每种情况下提供的 $N=3$ 个态进行求和。\n\n3.  **激发态污染分数, $f_{\\mathrm{exc}}(t)$**：该量衡量在给定时间 $t$ 时所有激发态相对于基态的分数贡献。其定义为：\n    $$\n    f_{\\mathrm{exc}}(t) = \\frac{C(t) - C_0(t)}{C_0(t)} = \\frac{\\sum_{n=1}^{N-1} A_n \\exp\\left(-E_n \\frac{t\\,a}{\\hbar c}\\right)}{A_0 \\exp\\left(-E_0 \\frac{t\\,a}{\\hbar c}\\right)}\n    $$\n    其中 $C_0(t) = A_0 \\exp\\left(-E_0 \\frac{t\\,a}{\\hbar c}\\right)$ 是关联函数的基态贡献。计算过程是首先计算完整的关联函数 $C(t)$ 和基态项 $C_0(t)$，然后应用该公式。\n\n4.  **有效质量偏差, $\\Delta m(t)$**：有效质量 $m_{\\mathrm{eff}}(t)$ 是基态能量 $E_0$ 的一个估计量。其与 $E_0$ 的偏差即为偏差量 $\\Delta m(t)$。其定义是：\n    $$\n    m_{\\mathrm{eff}}(t) = \\frac{\\hbar c}{a} \\ln\\left(\\frac{C(t)}{C(t+1)}\\right)\n    $$\n    为计算此值，必须在两个相邻的时间步 $t$ 和 $t+1$ 上评估关联函数。在计算出 $m_{\\mathrm{eff}}(t)$ 后，通过下式求得偏差：\n    $$\n    \\Delta m(t) = m_{\\mathrm{eff}}(t) - E_0\n    $$\n    其中 $E_0$ 是特定强子通道的已知基态能量。\n\n5.  **测试套件执行**：算法遍历提供的六个测试案例。对于每个由（强子类型、策略、时间 $t$）指定的案例，检索相应的参数。如上所述计算量 $f_{\\mathrm{exc}}(t)$ 和 $\\Delta m(t)$。根据要求，最终的数值结果四舍五入到六位小数。然后将每个案例的一对结果按指定顺序附加到列表中。最终输出是这些值的展平列表，并格式化为所需的字符串表示形式。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LQCD correlator analysis problem by calculating excited-state\n    contamination and effective mass bias for a given test suite.\n    \"\"\"\n    # Define physical constants\n    a = 0.09  # lattice spacing in fm\n    hbar_c = 0.1973269804  # conversion constant in GeV*fm\n    \n    # Define energy spectra and overlap factors from the problem statement\n    data = {\n        'meson': {\n            'energies': np.array([0.77, 1.40, 1.80]),\n            'SSO': {\n                'Z_src': np.array([1.0, 0.25, 0.10]),\n                'Z_sink': np.array([0.80, 0.70, 0.60])\n            },\n            'SS': {\n                'Z_src': np.array([0.80, 0.50, 0.30]),\n                'Z_sink': np.array([1.20, 0.40, 0.20])\n            }\n        },\n        'baryon': {\n            'energies': np.array([0.94, 1.50, 1.90]),\n            'SSO': {\n                'Z_src': np.array([1.0, 0.35, 0.20]),\n                'Z_sink': np.array([0.60, 0.70, 0.65])\n            },\n            'SS': {\n                'Z_src': np.array([0.80, 0.50, 0.30]),\n                'Z_sink': np.array([1.00, 0.50, 0.30])\n            }\n        }\n    }\n    \n    # Define the test suite\n    test_cases = [\n        ('meson', 'SSO', 8),\n        ('meson', 'SS', 8),\n        ('baryon', 'SSO', 8),\n        ('baryon', 'SS', 8),\n        ('meson', 'SS', 2),\n        ('baryon', 'SSO', 1),\n    ]\n\n    def get_correlator(t, energies, amplitudes, a_val, hbar_c_val):\n        \"\"\"Calculates the correlator C(t) for a given time t.\"\"\"\n        exponent_arg = -energies * (t * a_val / hbar_c_val)\n        return np.sum(amplitudes * np.exp(exponent_arg))\n\n    results = []\n    for hadron_type, strategy, t in test_cases:\n        # Retrieve parameters for the current case\n        params = data[hadron_type]\n        energies = params['energies']\n        E0 = energies[0]\n        \n        strategy_params = params[strategy]\n        Z_src = strategy_params['Z_src']\n        Z_sink = strategy_params['Z_sink']\n        \n        # Calculate amplitudes A_n = Z_n^(src) * Z_n^(sink)\n        amplitudes = Z_src * Z_sink\n        A0 = amplitudes[0]\n\n        # --- Calculate excited-state contamination fraction f_exc(t) ---\n        C_t = get_correlator(t, energies, amplitudes, a, hbar_c)\n        C0_t = A0 * np.exp(-E0 * (t * a / hbar_c))\n        f_exc = (C_t - C0_t) / C0_t\n\n        # --- Calculate effective mass bias Delta_m(t) ---\n        # Note: get_correlator is called for C(t) again, but this is clear\n        # and avoids storing a large number of intermediate values.\n        C_t_plus_1 = get_correlator(t + 1, energies, amplitudes, a, hbar_c)\n        m_eff = (hbar_c / a) * np.log(C_t / C_t_plus_1)\n        delta_m = m_eff - E0\n\n        # Round results to six decimal places and append\n        results.extend([round(f_exc, 6), round(delta_m, 6)])\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "任何格点计算都是在具有有限格距 $a$ 的格子上进行的，这必然会引入离散化误差。为了得到对应于真实物理世界的结果，我们必须在多个不同的格距下进行计算，并将结果外推到 $a \\to 0$ 的连续极限。这个练习  让你亲身体验这最后也是至关重要的一步，利用核子质量数据来展示如何运用Symanzik有效理论指导我们进行连续极限外推。",
            "id": "3507086",
            "problem": "在格点量子色动力学 (LQCD) 中，Symanzik 有效理论预测，可观测量中的离散化赝象会随着格点间距 $a$ 的幂次进行标度。对于 Wilson 费米子，领头阶离散化误差的标度行为是 $\\mathcal{O}(a)$，而非微扰地调节 Sheikholeslami-Wohlert (SW) 系数 $c_{\\text{SW}}$ 可以消除 $\\mathcal{O}(a)$ 项，只留下 $\\mathcal{O}(a^2)$ 的赝象。考虑在几个不同的格点间距下测得的核子质量 $M_N(a)$，单位为吉电子伏特 (GeV)，其统计不确定度假定为高斯分布且不相关。分别地，由 $\\mathcal{O}(a)$ 主导的标度模型和由 $\\mathcal{O}(a^2)$ 主导的标度模型为：$$M_N(a) = M_0 + c_1 a + c_2 a^2$$ 和 $$M_N(a) = M_0 + c_2 a^2,$$ 其中 $M_0$ 是连续极限下的核子质量，$c_1$ 和 $c_2$ 是冗余参数，$a$ 的单位是飞米 (fm)。加权最小二乘估计（在高斯噪声下等价于最大似然估计）旨在最小化以下目标函数：$$\\chi^2 = \\sum_i \\frac{\\left[y_i - M_N(a_i)\\right]^2}{\\sigma_i^2},$$ 其中 $y_i$ 是在格点间距 $a_i$ 处测得的质量，其不确定度为 $\\sigma_i$。\n\n基于 Symanzik 展开将格点赝象按 $a$ 的幂次进行组织以及高斯误差模型意味着加权最小二乘法具有最优性这两个基本原理，请实现以下任务：\n\n1. 对每个测试用例，使用加权最小二乘法将未改进的测量值（对应于未经非微扰调节 Sheikholeslami-Wohlert (SW) 系数 $c_{\\text{SW}}$ 的 Wilson 作用量）拟合到 $\\mathcal{O}(a)$ 标度模型 $M_N(a) = M_0 + c_1 a + c_2 a^2$，并提取连续极限质量 $M_0$ (以 GeV 为单位)。\n2. 对每个测试用例，使用加权最小二乘法将改进的测量值（对应于对 $c_{\\text{SW}}$ 进行了非微扰调节）拟合到 $\\mathcal{O}(a^2)$ 标度模型 $M_N(a) = M_0 + c_2 a^2$，并提取连续极限质量 $M_0$ (以 GeV 为单位)。\n3. 对每个测试用例的改进数据集，使用赤池信息准则 (AIC) 来定量比较 $\\mathcal{O}(a)$ 模型与 $\\mathcal{O}(a^2)$ 模型。在高斯误差下，使用 $$\\mathrm{AIC}' = \\chi^2 + 2k,$$，其中 $k$ 是拟合参数的数量。如果 $\\mathcal{O}(a^2)$ 模型在改进数据集上更优（即 $\\mathrm{AIC}'$ 更小），则报告 $1$，否则报告 $0$。\n4. 对每个测试用例，计算效应量，即差值 $\\Delta M_0 = M_{0,\\text{unimproved}} - M_{0,\\text{improved}}$ (以 GeV 为单位)，并四舍五入到六位小数。\n\n您的程序必须生成以下格式的单行最终输出：一个由方括号括起来的逗号分隔的扁平列表，按顺序汇总每个测试用例的四个输出，即 $M_{0,\\text{unimproved}}$、$M_{0,\\text{improved}}$、$\\Delta M_0$ 和 AIC 偏好指示符。因此，对于三个测试用例，程序必须按用例 1 (四个值)、用例 2 (四个值)、用例 3 (四个值) 的顺序打印十二个值。所有质量都必须以 GeV 表示，并四舍五入到六位小数。AIC 偏好指示符必须是整数 ($1$ 或 $0$)。\n\n使用以下测试套件，其中格点间距 $a$ 的单位是飞米 (fm)，质量 $y$ 的单位是吉电子伏特 (GeV)，不确定度 $\\sigma$ 的单位是 GeV：\n\n- 测试用例 1：\n  - 未改进：$a = \\{0.12, 0.09, 0.06, 0.045\\}\\,\\mathrm{fm}$，$y = \\{0.9680, 0.9590, 0.9510, 0.9480\\}\\,\\mathrm{GeV}$，$\\sigma = \\{0.0040, 0.0035, 0.0030, 0.0030\\}\\,\\mathrm{GeV}$。\n  - 改进：$a = \\{0.12, 0.09, 0.06, 0.045\\}\\,\\mathrm{fm}$，$y = \\{0.9420, 0.9400, 0.9390, 0.9385\\}\\,\\mathrm{GeV}$，$\\sigma = \\{0.0040, 0.0035, 0.0030, 0.0030\\}\\,\\mathrm{GeV}$。\n- 测试用例 2：\n  - 未改进：$a = \\{0.08, 0.06, 0.04, 0.03\\}\\,\\mathrm{fm}$，$y = \\{0.9530, 0.9490, 0.9450, 0.9440\\}\\,\\mathrm{GeV}$，$\\sigma = \\{0.0030, 0.0025, 0.0020, 0.0020\\}\\,\\mathrm{GeV}$。\n  - 改进：$a = \\{0.08, 0.06, 0.04, 0.03\\}\\,\\mathrm{fm}$，$y = \\{0.9405, 0.9397, 0.9393, 0.9392\\}\\,\\mathrm{GeV}$，$\\sigma = \\{0.0030, 0.0025, 0.0020, 0.0020\\}\\,\\mathrm{GeV}$。\n- 测试用例 3：\n  - 未改进：$a = \\{0.15, 0.12, 0.10\\}\\,\\mathrm{fm}$，$y = \\{0.9870, 0.9750, 0.9680\\}\\,\\mathrm{GeV}$，$\\sigma = \\{0.0050, 0.0040, 0.0040\\}\\,\\mathrm{GeV}$。\n  - 改进：$a = \\{0.15, 0.12, 0.10\\}\\,\\mathrm{fm}$，$y = \\{0.9460, 0.9430, 0.9420\\}\\,\\mathrm{GeV}$，$\\sigma = \\{0.0050, 0.0040, 0.0040\\}\\,\\mathrm{GeV}$。\n\n所有计算都必须以双精度进行。此问题不涉及角度。最终输出必须是形如 `$$[x_1,x_2,\\dots,x_{12}],$$` 的单行文本，其中每个 $x_i$ 是指定的浮点数（以 GeV 为单位，保留六位小数）或整数（$0$ 或 $1$）之一。",
            "solution": "该问题要求对格点量子色动力学 (LQCD) 中模拟的核子质量数据进行连续极限外推。这是一个标准流程，用于消除离散化赝象，即用离散格点近似连续时空所产生的误差。Symanzik 有效理论为此提供了一个系统性的框架，它预测对于格点间距 $a$，像核子质量 $M_N(a)$ 这样的可观测量会以 $a$ 的幂级数形式趋近其连续极限值 $M_0$。\n\n问题的核心是使用加权最小二乘法将数值数据拟合到两个不同的理论模型。对于具有已知、不相关高斯不确定度的数据点，该方法在统计上是最优的。目标是找到一组模型参数 $\\vec{p}$，以最小化卡方函数 $\\chi^2$：\n$$\n\\chi^2(\\vec{p}) = \\sum_{i=1}^{N} \\frac{\\left[y_i - f(a_i; \\vec{p})\\right]^2}{\\sigma_i^2}\n$$\n其中 $\\{y_i\\}$ 是在相应格点间距 $\\{a_i\\}$ 处测得的 $N$ 个质量值，$\\{\\sigma_i\\}$ 是它们的统计不确定度，$f(a; \\vec{p})$ 是理论模型。\n\n这两个模型对其参数是线性的，这使我们能够将问题表述为一个加权线性最小二乘问题。我们为每个数据点定义权重 $w_i = 1/\\sigma_i$。最小化 $\\chi^2$ 等价于对加权量 $y'_i = y_i w_i$ 和 $f'(a_i; \\vec{p}) = f(a_i; \\vec{p}) w_i$ 求解普通最小二乘问题。\n\n以矩阵形式，我们希望求解系统 $\\mathbf{A} \\vec{p} \\approx \\vec{Y}$，其中 $\\vec{Y}$ 是加权测量值向量，其元素为 $Y_i = y_i / \\sigma_i$，$\\vec{p}$ 是待定参数向量，而 $\\mathbf{A}$ 是加权设计矩阵。最小化平方范数 $||\\mathbf{A} \\vec{p} - \\vec{Y}||^2$（这正是 $\\chi^2$）的解由正规方程给出：\n$$\n\\vec{p} = (\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{A}^T \\vec{Y}\n$$\n这个问题可以使用线性代数程序（例如 `numpy.linalg.lstsq` 提供的程序）进行数值上和鲁棒的求解，这些程序通常采用奇异值分解 (SVD) 等方法。\n\n每个测试用例的四个任务执行如下：\n\n**1. 未改进数据的连续极限外推：**\n“未改进”数据来自 Wilson 型作用量，受 $\\mathcal{O}(a)$ 的领头阶离散化误差影响，需要拟合到相应的标度模型：\n$$\nM_N(a) = M_0 + c_1 a + c_2 a^2\n$$\n待定参数为 $\\vec{p} = (M_0, c_1, c_2)^T$。加权设计矩阵 $\\mathbf{A}_{\\text{unimp}}$ 的行由 $(1/\\sigma_i, a_i/\\sigma_i, a_i^2/\\sigma_i)$ 给出。求解该线性系统得到参数向量，从中我们提取连续极限质量 $M_{0,\\text{unimproved}} = p_1$。\n\n**2. 改进数据的连续极限外推：**\n“改进”数据通过非微扰地调节 Sheikholeslami-Wohlert (SW) 系数 $c_{\\text{SW}}$ 移除了 $\\mathcal{O}(a)$ 赝象，因此其领头误差预计为 $\\mathcal{O}(a^2)$。因此，我们将其拟合到更简单的模型：\n$$\nM_N(a) = M_0 + c_2 a^2\n$$\n此处，参数为 $\\vec{p} = (M_0, c_2)^T$。加权设计矩阵 $\\mathbf{A}_{\\text{imp}}$ 的行由 $(1/\\sigma_i, a_i^2/\\sigma_i)$ 给出。求解该系统得到一个新的参数向量，从中我们提取改进后的连续极限质量 $M_{0,\\text{improved}} = p_1$。\n\n**3. 使用 AIC 进行模型比较：**\n为了定量评估对于“改进”数据集移除 $c_1 a$ 项是否合理，我们使用赤池信息准则 (AIC)。一个适用于高斯误差下最小二乘拟合的简化版本是 $\\mathrm{AIC}' = \\chi^2_{\\text{min}} + 2k$，其中 $\\chi^2_{\\text{min}}$ 是拟合得到的最小 $\\chi^2$ 值，$k$ 是模型中参数的数量。较低的 AIC' 值表示模型更好，因为它在拟合优度与模型简单性之间取得了平衡。\n\n我们对改进数据集执行两次拟合：\n- 拟合到 $\\mathcal{O}(a)$ 模型 ($M_N(a) = M_0 + c_1 a + c_2 a^2$)：参数数量 $k_a = 3$。我们计算其最小卡方值 $\\chi^2_a$ 及其 AIC 分数 $\\mathrm{AIC}'_a = \\chi^2_a + 2k_a = \\chi^2_a + 6$。\n- 拟合到 $\\mathcal{O}(a^2)$ 模型 ($M_N(a) = M_0 + c_2 a^2$)：参数数量 $k_{a^2} = 2$。我们计算其最小卡方值 $\\chi^2_{a^2}$ 及其 AIC 分数 $\\mathrm{AIC}'_{a^2} = \\chi^2_{a^2} + 2k_{a^2} = \\chi^2_{a^2} + 4$。\n\n问题要求一个指示符：如果 $\\mathcal{O}(a^2)$ 模型更优（即 $\\mathrm{AIC}'_{a^2}  \\mathrm{AIC}'_a$），则为 $1$，否则为 $0$。\n\n**4. 计算效应量：**\n计算差值 $\\Delta M_0 = M_{0,\\text{unimproved}} - M_{0,\\text{improved}}$。这个量代表了由于改进格点作用量（即移除主导的 $\\mathcal{O}(a)$ 离散化赝象）而在确定的连续极限质量中产生的系统性偏移。\n\n具体实现将通过构建适当的设计矩阵和响应向量来处理每个测试用例，调用数值最小二乘求解器以找到参数和残差平方和（即 $\\chi^2$），然后使用这些结果计算所需的四个量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Lattice QCD continuum extrapolation problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"a\": [0.12, 0.09, 0.06, 0.045],\n            \"unimproved\": {\n                \"y\": [0.9680, 0.9590, 0.9510, 0.9480],\n                \"sigma\": [0.0040, 0.0035, 0.0030, 0.0030]\n            },\n            \"improved\": {\n                \"y\": [0.9420, 0.9400, 0.9390, 0.9385],\n                \"sigma\": [0.0040, 0.0035, 0.0030, 0.0030]\n            }\n        },\n        {\n            \"a\": [0.08, 0.06, 0.04, 0.03],\n            \"unimproved\": {\n                \"y\": [0.9530, 0.9490, 0.9450, 0.9440],\n                \"sigma\": [0.0030, 0.0025, 0.0020, 0.0020]\n            },\n            \"improved\": {\n                \"y\": [0.9405, 0.9397, 0.9393, 0.9392],\n                \"sigma\": [0.0030, 0.0025, 0.0020, 0.0020]\n            }\n        },\n        {\n            \"a\": [0.15, 0.12, 0.10],\n            \"unimproved\": {\n                \"y\": [0.9870, 0.9750, 0.9680],\n                \"sigma\": [0.0050, 0.0040, 0.0040]\n            },\n            \"improved\": {\n                \"y\": [0.9460, 0.9430, 0.9420],\n                \"sigma\": [0.0050, 0.0040, 0.0040]\n            }\n        }\n    ]\n\n    def perform_weighted_fit(a, y, sigma, basis_functions):\n        \"\"\"\n        Performs a weighted linear least-squares fit.\n\n        Args:\n            a (np.ndarray): Independent variable values.\n            y (np.ndarray): Dependent variable values.\n            sigma (np.ndarray): Uncertainties on y.\n            basis_functions (list of callables): Basis functions for the model.\n\n        Returns:\n            tuple: A tuple containing the fitted parameters and the minimum chi-squared.\n        \"\"\"\n        weights = 1.0 / sigma\n        Y_weighted = y * weights\n        \n        A_weighted = np.zeros((len(a), len(basis_functions)))\n        for i, func in enumerate(basis_functions):\n            A_weighted[:, i] = func(a) * weights\n            \n        params, residuals, _, _ = np.linalg.lstsq(A_weighted, Y_weighted, rcond=None)\n        \n        # residuals is an array with one element, the sum of squared residuals,\n        # which is the chi-squared value for the fit.\n        chi_squared = residuals[0] if residuals.size > 0 else 0.0\n        \n        return params, chi_squared\n\n    all_results = []\n    \n    # Define the basis functions for the two models\n    o_a_basis = [lambda x: 1.0, lambda x: x, lambda x: x**2]\n    o_a2_basis = [lambda x: 1.0, lambda x: x**2]\n\n    for case in test_cases:\n        a_vals = np.array(case['a'], dtype=np.float64)\n        \n        # --- Task 1: Fit unimproved data with O(a) model ---\n        unimp_y = np.array(case['unimproved']['y'], dtype=np.float64)\n        unimp_sigma = np.array(case['unimproved']['sigma'], dtype=np.float64)\n        params_unimp, _ = perform_weighted_fit(a_vals, unimp_y, unimp_sigma, o_a_basis)\n        m0_unimproved = params_unimp[0]\n\n        # --- Task 2: Fit improved data with O(a^2) model ---\n        imp_y = np.array(case['improved']['y'], dtype=np.float64)\n        imp_sigma = np.array(case['improved']['sigma'], dtype=np.float64)\n        params_imp_a2, chi2_a2_on_imp = perform_weighted_fit(a_vals, imp_y, imp_sigma, o_a2_basis)\n        m0_improved = params_imp_a2[0]\n\n        # --- Task 3: Compare models on improved data using AIC ---\n        # Fit 1: O(a) model on improved data\n        k_a = len(o_a_basis)\n        _, chi2_a_on_imp = perform_weighted_fit(a_vals, imp_y, imp_sigma, o_a_basis)\n        aic_a = chi2_a_on_imp + 2 * k_a\n\n        # Fit 2: O(a^2) model on improved data (already done)\n        k_a2 = len(o_a2_basis)\n        aic_a2 = chi2_a2_on_imp + 2 * k_a2\n        \n        # Report 1 if O(a^2) model is preferred (smaller AIC)\n        aic_indicator = 1 if aic_a2  aic_a else 0\n\n        # --- Task 4: Compute effect size ---\n        delta_m0 = m0_unimproved - m0_improved\n\n        # --- Aggregate and format results for this case ---\n        all_results.extend([\n            f\"{m0_unimproved:.6f}\",\n            f\"{m0_improved:.6f}\",\n            f\"{delta_m0:.6f}\",\n            str(aic_indicator)\n        ])\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}