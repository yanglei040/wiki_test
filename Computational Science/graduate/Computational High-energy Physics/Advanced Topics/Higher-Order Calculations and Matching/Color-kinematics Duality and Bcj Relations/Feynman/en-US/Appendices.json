{
    "hands_on_practices": [
        {
            "introduction": "Before exploring the consequences of color-kinematics duality, one must first become fluent with the objects it relates: the cubic graphs that form the backbone of the amplitude representation. This exercise grounds your understanding by asking you to construct the five-point color-ordered amplitude from its constituent planar graphs and to enumerate the full set of graphs and their constraining Jacobi relations . Mastering this foundational skill is essential for building intuition about the combinatorial and algebraic structures at play.",
            "id": "3508621",
            "problem": "Consider a tree-level five-point color-ordered partial amplitude $A_{5}(1,2,3,4,5)$ in a non-Abelian gauge theory. Use the color-stripped representation in which the interaction is entirely cubic, and each diagram contributes a product of two scalar propagators multiplying a kinematic numerator. Begin from the fundamental decomposition that tree amplitudes in Yang–Mills theory can be represented as a sum over cubic graphs with kinematic numerators $n_{g}$ and scalar propagators built from Mandelstam invariants. The Lie algebra structure constants $f^{a b c}$ obey the Jacobi identity $f^{a b e} f^{e c d} + f^{b c e} f^{e a d} + f^{c a e} f^{e b d} = 0$, and color-kinematics duality requires that the kinematic numerators exhibit the same triplet constraints.\n\nTask 1. Construct the cubic representation of the color-ordered amplitude $A_{5}(1,2,3,4,5)$ as a sum of the five planar cubic graphs consistent with the fixed cyclic ordering $1,2,3,4,5$. Write your expression using two-particle Mandelstam invariants $s_{i\\,i+1} = (p_{i} + p_{i+1})^{2}$ (with indices understood modulo $5$) and kinematic numerators $n_{i\\,i+1\\,|\\,j\\,j+1}$ attached to each planar cubic graph.\n\nTask 2. Now consider the full set of cubic tree graphs with the external legs labelled $\\{1,2,3,4,5\\}$, without imposing planarity. Using first-principles combinatorics of cubic trees together with the fact that each internal edge defines a unique Jacobi triplet of graphs, determine:\n- the total number of distinct cubic graphs, and\n- the total number of distinct Jacobi triplets that constrain the kinematic numerators in a color-kinematics dual representation at five points.\n\nExpress your final answer as a single row matrix containing the two integers $(N_{\\text{graphs}}, N_{\\text{Jacobi}})$. No rounding is required and no units are to be reported in the final answer.",
            "solution": "The problem asks for two tasks related to the structure of five-point tree-level amplitudes in a non-Abelian gauge theory, within the framework of color-kinematics duality.\n\nTo begin, we formalize the concepts given. A tree-level scattering amplitude with $n$ external particles (legs) can be decomposed into a sum over all distinct cubic tree graphs with $n$ labeled external legs. The full amplitude is given by\n$$ \\mathcal{A}_n = g^{n-2} \\sum_{g} \\frac{c_g n_g}{D_g} $$\nwhere the sum is over the set of cubic graphs, indexed by $g$. The term $g$ in the prefactor $g^{n-2}$ is the coupling constant. The color factors $c_g$ are constructed from Lie algebra structure constants $f^{abc}$, $n_g$ are kinematic numerators depending on momenta and polarizations, and $D_g$ is the product of inverse propagators (the denominator). For a cubic graph, all vertices have degree $3$. An $n$-point cubic graph has $n$ external legs, $n-2$ internal vertices, and $n-3$ internal edges (propagators). For $n=5$, there are $5-3=2$ internal propagators.\n\nThe color factors $c_g$ satisfy Jacobi identities of the form $c_i+c_j+c_k=0$ for any triplet of graphs $(i,j,k)$ that are related by a specific structural transformation. Color-kinematics duality posits that it is possible to find a representation of kinematic numerators $n_g$ such that they obey the same Jacobi identities, i.e., $n_i+n_j+n_k=0$.\n\nA color-ordered partial amplitude, such as $A_{5}(1,2,3,4,5)$, is obtained by summing only over the cubic graphs that are planar with respect to the specified cyclic ordering of external legs.\n\nTask 1. Construct the cubic representation of the color-ordered amplitude $A_{5}(1,2,3,4,5)$.\n\nFor a five-point amplitude with a fixed cyclic ordering of external legs $(1,2,3,4,5)$, there are five corresponding planar cubic graphs. Each graph has $5-3=2$ propagators. The topology of these graphs can be visualized by placing the external legs on a circle and connecting vertices with internal lines that do not cross. For $n=5$, the five planar graphs are all topologically equivalent up to a cyclic permutation of the leg labels.\n\nLet's describe the topology of one such graph. Two adjacent legs, say $1$ and $2$, meet at a vertex. Another pair of adjacent legs, $4$ and $5$, meet at a second vertex. The internal lines from these two vertices, along with the remaining leg $3$, meet at a third vertex.\nThe propagators for this graph are associated with the internal lines. The momenta flowing through them are $p_1+p_2$ and $p_4+p_5$. The corresponding denominator is $1/((p_1+p_2)^2 (p_4+p_5)^2)$. Using the two-particle Mandelstam invariant notation $s_{ij} = (p_i+p_j)^2$, the denominator product is $s_{12}s_{45}$. The problem denotes the numerator for this graph as $n_{i\\,i+1\\,|\\,j\\,j+1}$. For this specific graph, we have adjacent pairs $(1,2)$ and $(4,5)$, so we can set $i=1$ and $j=4$. The numerator is thus $n_{12|45}$.\n\nThe five planar graphs for the ordering $(1,2,3,4,5)$ are obtained by cyclically permuting the labels $1 \\to 2 \\to 3 \\to 4 \\to 5 \\to 1$.\nThe five graphs and their contributions are:\n1.  Legs $(1,2)$ and $(4,5)$ are paired. Propagators: $s_{12}, s_{45}$. Contribution: $\\frac{n_{12|45}}{s_{12}s_{45}}$.\n2.  Legs $(2,3)$ and $(5,1)$ are paired. Propagators: $s_{23}, s_{51}$. Contribution: $\\frac{n_{23|51}}{s_{23}s_{51}}$.\n3.  Legs $(3,4)$ and $(1,2)$ are paired. Propagators: $s_{34}, s_{12}$. Contribution: $\\frac{n_{34|12}}{s_{34}s_{12}}$.\n4.  Legs $(4,5)$ and $(2,3)$ are paired. Propagators: $s_{45}, s_{23}$. Contribution: $\\frac{n_{45|23}}{s_{45}s_{23}}$.\n5.  Legs $(5,1)$ and $(3,4)$ are paired. Propagators: $s_{51}, s_{34}$. Contribution: $\\frac{n_{51|34}}{s_{51}s_{34}}$.\n\nSumming these contributions gives the color-ordered amplitude:\n$$ A_{5}(1,2,3,4,5) = \\frac{n_{12|45}}{s_{12}s_{45}} + \\frac{n_{23|51}}{s_{23}s_{51}} + \\frac{n_{34|12}}{s_{34}s_{12}} + \\frac{n_{45|23}}{s_{45}s_{23}} + \\frac{n_{51|34}}{s_{51}s_{34}} $$\nThis expression fulfills the requirements of the first task.\n\nTask 2. Determine the total number of distinct cubic graphs ($N_{\\text{graphs}}$) and the total number of distinct Jacobi triplets ($N_{\\text{Jacobi}}$) for five points.\n\nTotal number of distinct cubic graphs, $N_{\\text{graphs}}$:\nThe problem of counting the number of distinct cubic tree graphs with $n$ labeled external legs is equivalent to counting the number of unrooted binary trees with $n$ labeled leaves. This is a standard result in combinatorics. The number of such trees is given by the double factorial $(2n-5)!!$.\nFor $n=5$ legs, the total number of distinct cubic graphs is:\n$$ N_{\\text{graphs}} = (2 \\cdot 5 - 5)!! = 5!! = 5 \\cdot 3 \\cdot 1 = 15 $$\nThese $15$ graphs include both planar and non-planar topologies. A graph is specified by its two propagators, which correspond to partitioning the 5 legs into two pairs and a singlet, e.g., $(\\{i,j\\}, \\{k,l\\}, \\{m\\})$. The number of ways to do this is $\\binom{5}{4} \\times 3 = 15$, confirming the formula.\n\nTotal number of distinct Jacobi triplets, $N_{\\text{Jacobi}}$:\nA Jacobi identity for kinematic numerators, $n_i+n_j+n_k=0$, relates a triplet of graphs. A triplet of graphs $(g_i, g_j, g_k)$ that participate in a Jacobi identity is structurally defined by how four sub-trees are connected to a central 4-point-like vertex structure. The identity arises from the three ways of connecting these four sub-trees, corresponding to s, t, and u-channels of a 4-point function.\nTherefore, the number of distinct Jacobi identities is the number of ways to partition the $n$ external legs into four non-empty sets, which represent the sets of leaves for the four sub-trees.\nFor $n=5$ legs, we need to find the number of ways to partition the set of labels $\\{1,2,3,4,5\\}$ into $4$ non-empty subsets. The only possible structure for such a partition is to have one subset of size $2$ and three subsets of size $1$. For example, a partition of this type is $\\{\\{1,2\\}, \\{3\\}, \\{4\\}, \\{5\\}\\}$.\nThe number of such partitions is determined by the number of ways to choose the two legs that will form the pair. The remaining three legs will automatically form the singleton sets. The number of ways to choose $2$ legs from a set of $5$ is given by the binomial coefficient $\\binom{5}{2}$.\n$$ N_{\\text{Jacobi}} = \\binom{5}{2} = \\frac{5!}{2!(5-2)!} = \\frac{5 \\cdot 4}{2} = 10 $$\nEach of these $10$ partitions defines a unique Jacobi triplet of numerators. For instance, the partition $\\{\\{1,2\\}, \\{3\\}, \\{4\\}, \\{5\\}\\}$ corresponds to a relation between the numerators of the three graphs with propagator pairs $(s_{12},s_{34})$, $(s_{12},s_{35})$, and $(s_{12},s_{45})$, assuming the relation is constructed by fixing one propagator channel. More precisely, the relation links the numerators of graphs corresponding to the pairings $((\\{1,2\\},\\{3\\}),(\\{4\\},\\{5\\}))$, $((\\{1,2\\},\\{4\\}),(\\{3\\},\\{5\\}))$, and $((\\{1,2\\},\\{5\\}),(\\{3\\},\\{4\\}))$, where the notation indicates how the four groups are paired up.\nThus, there are $10$ distinct Jacobi triplets that constrain the kinematic numerators.\n\nThe final answer comprises the two integers $(N_{\\text{graphs}}, N_{\\text{Jacobi}})$.\n$N_{\\text{graphs}} = 15$\n$N_{\\text{Jacobi}} = 10$\n\nFinal Answer: $(15, 10)$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 15 & 10 \\end{pmatrix} } $$"
        },
        {
            "introduction": "A profound consequence of color-kinematics duality is the emergence of linear relations among color-ordered amplitudes, known as the Bern-Carrasco-Johansson (BCJ) relations. This practice provides a direct, hands-on verification of one such fundamental relation for a five-point Maximally Helicity Violating (MHV) amplitude . By applying the celebrated Parke-Taylor formula within the spinor-helicity formalism, you will see how these seemingly abstract algebraic constraints manifest as remarkable cancellations at the level of physical, on-shell amplitudes.",
            "id": "3508625",
            "problem": "Consider tree-level pure Yang–Mills theory with five distinct external gluons carrying massless momenta $\\{p_{1},p_{2},p_{3},p_{4},p_{5}\\}$ satisfying $\\sum_{i=1}^{5} p_{i}=0$. Work with color-stripped partial amplitudes $A(1,2,3,4,5)$ organized in a cubic-graph representation. In this representation, the amplitude is written as a sum over cubic graphs $i$ with color factors $c_{i}$, kinematic numerators $n_{i}$, and propagator denominators $D_{i}$, such that\n$$\n\\mathcal{A}_{\\text{tree}}=\\sum_{i} \\frac{c_{i}\\,n_{i}}{D_{i}}.\n$$\nThe color factors $c_{i}$ satisfy antisymmetry and the Jacobi identity. Color–kinematics duality (CK duality) requires the kinematic numerators $n_{i}$ to obey the same antisymmetry and Jacobi identities. Locality of the numerators means that each $n_{i}$ is a polynomial in the momenta and polarization vectors and introduces no additional poles in Mandelstam invariants beyond those in $D_{i}$. One way to ensure locality while preserving CK duality is to build numerators from linearized field strengths $F_{i}^{\\mu\\nu}=p_{i}^{\\mu}\\,\\varepsilon_{i}^{\\nu}-p_{i}^{\\nu}\\,\\varepsilon_{i}^{\\mu}$ and Mandelstam invariants $s_{ij}=(p_{i}+p_{j})^{2}$, avoiding any inverse powers of $s_{ij}$.\n\nAt five points, choose a half-ladder master graph whose ordered external legs follow $1\\!-\\!2\\!-\\!3\\!-\\!4\\!-\\!5$ along the chain and denote its numerator by $n_{12|3|45}$. Construct an explicit local ansatz\n$$\nn_{12|3|45}= \\alpha\\, s_{12}\\, s_{45}\\, \\operatorname{tr}\\!\\big(F_{1} F_{2} F_{3} F_{4} F_{5}\\big),\n$$\nwith a constant $\\alpha$ to be fixed by matching to the physical amplitude, and generate all other numerators by antisymmetry at cubic vertices and Jacobi relations on internal edges so that CK duality holds for the full set $\\{n_{i}\\}$. Assume the helicity configuration $(1^{-},2^{-},3^{+},4^{+},5^{+})$ and use the spinor-helicity formalism with $\\langle i j\\rangle$ and $[i j]$ brackets, where $s_{ij}=\\langle i j\\rangle [j i]$.\n\nStarting from the cubic representation, explain how the locality of the ansatz prevents non-local terms and how CK duality imposed on the local ansatz leads to a linear relation among color-ordered amplitudes, known as the fundamental Bern–Carrasco–Johansson (BCJ) relation. Then, using the maximally helicity violating (MHV) Parke–Taylor formula for the color-ordered amplitudes in the given helicity configuration,\n$$\nA(\\sigma(1^{-},2^{-},3^{+},4^{+},5^{+}))= \\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle \\sigma(1)\\sigma(2)\\rangle\\,\\langle \\sigma(2)\\sigma(3)\\rangle\\,\\langle \\sigma(3)\\sigma(4)\\rangle\\,\\langle \\sigma(4)\\sigma(5)\\rangle\\,\\langle \\sigma(5)\\sigma(1)\\rangle},\n$$\nevaluate the following linear combination of color-ordered amplitudes,\n$$\nL \\equiv s_{12}\\,A(2,1,3,4,5)+\\big(s_{12}+s_{13}\\big)\\,A(2,3,1,4,5)+\\big(s_{12}+s_{13}+s_{14}\\big)\\,A(2,3,4,1,5),\n$$\nand provide its exact value. The final answer must be a single real-valued number or a closed-form analytic expression with no units. If any approximation is needed, round to four significant figures; otherwise, give the exact value.",
            "solution": "The cubic-graph representation of a tree-level Yang–Mills amplitude organizes contributions such that each term has a color factor $c_{i}$, a kinematic numerator $n_{i}$, and a product of propagators $D_{i}$. The color factors are constructed from structure constants $f^{abc}$ of the gauge group and obey antisymmetry under exchanging legs at a vertex and the Jacobi identity $c_{i}+c_{j}+c_{k}=0$ for any triplet of graphs differing by a single edge flip. Color–kinematics duality requires the kinematic numerators $n_{i}$ to satisfy the same algebraic properties:\n- Kinematic antisymmetry: $n_{i}$ flips sign under exchange of two legs attached to a cubic vertex.\n- Kinematic Jacobi: for any triplet $(i,j,k)$ related by an edge flip, $n_{i}+n_{j}+n_{k}=0$.\n\nLocality in this context means that the numerators $n_{i}$ do not contain inverse powers of Mandelstam invariants $s_{ij}$; all poles in the amplitude should arise from the propagator denominators $D_{i}$. A robust way to enforce locality while preserving gauge invariance is to construct numerators from linearized field strengths $F_{i}^{\\mu\\nu}=p_{i}^{\\mu}\\,\\varepsilon_{i}^{\\nu}-p_{i}^{\\nu}\\,\\varepsilon_{i}^{\\mu}$, which are manifestly gauge invariant under $\\varepsilon_{i}^{\\mu}\\rightarrow \\varepsilon_{i}^{\\mu}+ \\beta\\, p_{i}^{\\mu}$ and are local polynomials in the momenta and polarization vectors.\n\nAt five points, consider the half-ladder master graph with external legs in the chain $1\\!-\\!2\\!-\\!3\\!-\\!4\\!-\\!5$. A local and gauge-invariant ansatz for its numerator is\n$$\nn_{12|3|45}= \\alpha\\, s_{12}\\, s_{45}\\, \\operatorname{tr}\\!\\big(F_{1} F_{2} F_{3} F_{4} F_{5}\\big),\n$$\nwhere the trace is taken with the Minkowski metric contracting adjacent indices of the field strengths, and $\\alpha$ is a constant to be determined by matching the computed amplitude to known color-ordered amplitudes. This ansatz:\n1. Is local, since it contains only polynomial dependence on $p_{i}$ and $\\varepsilon_{i}$ and no inverse Mandelstam invariants.\n2. Is gauge invariant, since $F_{i}$ are gauge invariant and the trace of their product is gauge invariant.\n3. Can be arranged to satisfy antisymmetry and Jacobi relations by generating the remaining numerators through vertex antisymmetry and by imposing Jacobi constraints on internal edge flips. The cyclicity and commutator structure implicit in traces of $F_{i}$, together with momentum conservation and the Bianchi identity $p_{i[\\mu}F_{i\\nu\\rho]}=0$, provide sufficient freedom to adjust contact terms so that all kinematic Jacobi identities are satisfied without introducing non-localities. The coefficients that multiply different tensor structures in more general ansätze can be chosen to eliminate any potential non-local terms while maintaining the Jacobi identities. In other words, contact terms are used to move between equivalent local representations that are “BCJ gauges,” where CK duality holds.\n\nOnce kinematic Jacobi identities hold for a set of local numerators, an amplitude-level consequence is a linear relation among color-ordered amplitudes known as the fundamental Bern–Carrasco–Johansson (BCJ) relation. This relation can be derived by writing the full amplitude in two equivalent ways (using different color bases) and using the kinematic Jacobi identities to express one set of numerators in terms of another in a manner that mirrors the color Jacobi rearrangements. The mismatches between different color orderings cancel when the numerators obey the duality, leading to a linear identity with kinematic coefficients that are sums of Mandelstam invariants attached to the leg being moved along the color chain.\n\nFor $n=5$, with the leg $1$ inserted into different positions among $(2,3,4,5)$, the fundamental BCJ relation yields the specific linear combination\n$$\nL \\equiv s_{12}\\,A(2,1,3,4,5)+\\big(s_{12}+s_{13}\\big)\\,A(2,3,1,4,5)+\\big(s_{12}+s_{13}+s_{14}\\big)\\,A(2,3,4,1,5),\n$$\nwhich must vanish when the numerators satisfy CK duality and are local. To check this explicitly in the maximally helicity violating configuration $(1^{-},2^{-},3^{+},4^{+},5^{+})$, we use the Parke–Taylor formula. For any ordering $\\sigma$, the color-ordered MHV amplitude with negative helicities at legs $1$ and $2$ is\n$$\nA(\\sigma)= \\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle \\sigma(1)\\sigma(2)\\rangle\\,\\langle \\sigma(2)\\sigma(3)\\rangle\\,\\langle \\sigma(3)\\sigma(4)\\rangle\\,\\langle \\sigma(4)\\sigma(5)\\rangle\\,\\langle \\sigma(5)\\sigma(1)\\rangle}.\n$$\nThus,\n\\begin{align*}\nA(2,1,3,4,5)&=\\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle 2 1\\rangle\\,\\langle 1 3\\rangle\\,\\langle 3 4\\rangle\\,\\langle 4 5\\rangle\\,\\langle 5 2\\rangle},\\\\\nA(2,3,1,4,5)&=\\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle 2 3\\rangle\\,\\langle 3 1\\rangle\\,\\langle 1 4\\rangle\\,\\langle 4 5\\rangle\\,\\langle 5 2\\rangle},\\\\\nA(2,3,4,1,5)&=\\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle 2 3\\rangle\\,\\langle 3 4\\rangle\\,\\langle 4 1\\rangle\\,\\langle 1 5\\rangle\\,\\langle 5 2\\rangle}.\n\\end{align*}\nForm $L$ by multiplying these amplitudes by their respective kinematic coefficients. Use $s_{ij}=\\langle i j\\rangle [j i]$ and the antisymmetry $\\langle i j\\rangle=-\\langle j i\\rangle$ to rewrite all terms so that they share the common denominator $\\langle 2 3\\rangle\\,\\langle 3 4\\rangle\\,\\langle 4 5\\rangle\\,\\langle 5 2\\rangle$ and a factor $\\mathrm{i}\\,\\langle 1 2\\rangle^{3}$, for instance by multiplying numerator and denominator of each term appropriately. After bringing $L$ over a common denominator, the numerator becomes a sum of terms linear in spinor products multiplied by $[j i]$ factors coming from the $s_{ij}$. These terms cancel pairwise due to Schouten identities among angle brackets, e.g.,\n$$\n\\langle a b\\rangle \\langle c d\\rangle + \\langle b c\\rangle \\langle a d\\rangle + \\langle c a\\rangle \\langle b d\\rangle = 0,\n$$\nand momentum-conservation identities such as $\\sum_{k} |k]\\langle k|=0$, together with relabeling symmetries of the ordered chains. The detailed algebra mirrors the cancellations guaranteed at the integrand level by CK duality and produces an identically vanishing numerator for $L$. Therefore,\n$$\nL=0.\n$$\nThis explicit check is consistent with the general derivation from local CK-dual numerators: enforcing the kinematic Jacobi identities for a local set of numerators implies that the fundamental BCJ combination of color-ordered amplitudes vanishes. The locality of the numerator ansatz is essential; non-local terms (inverse Mandelstam invariants) would spoil the matching of pole structures required for the derivation, obstructing the cancellation that leads to the amplitude-level BCJ relations.\n\nHence, for the five-point MHV configuration and any local CK-dual representation, the value of $L$ defined above is exactly zero.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "Modern scattering amplitude calculations have been revolutionized by computational techniques that leverage algebraic constraints to construct complex integrands from simpler, on-shell data. This problem places you at the forefront of these methods by tasking you with the implementation of a numerical integrand reconstruction . By building a solver over a finite field, you will see how generalized unitarity cuts and the constraints of color-kinematics duality are transformed into a solvable system of linear equations, providing a powerful engine for discovering new theoretical results.",
            "id": "3508572",
            "problem": "You are asked to implement a complete, finite-field, multivariate interpolation and linear-constraint reconstruction of kinematic numerators for a toy subset of $5$-point, $2$-loop cubic graphs constrained by Color-Kinematics (CK) duality and generalized unitarity cuts. The program you write must reconstruct unknown polynomial numerator coefficients modulo a prime and verify Jacobi-identity constraints and cut-consistency across independent validation points. The final output must be a single line containing a list of booleans indicating success per test case.\n\nBegin from the following fundamental base and core definitions:\n\n- Color-Kinematics duality (CK) states that for cubic graphs with color factors obeying the Lie-algebra Jacobi identities, there exist kinematic numerators that obey isomorphic Jacobi relations, specifically $n_s + n_t + n_u = 0$ for each triplet of graphs whose color factors satisfy $c_s + c_t + c_u = 0$.\n\n- The Bern-Carrasco-Johansson (BCJ) relations (Bern-Carrasco-Johansson, BCJ) are consequences of CK duality at the amplitude level, where rearrangements of kinematic numerators consistent with Jacobi relations leave the physical amplitudes invariant.\n\n- Generalized unitarity cuts reconstruct integrands from on-shell conditions by matching products of trees. On maximal cuts that isolate a graph’s topology, the cut data directly constrain that graph’s numerator values at specific kinematic points.\n\nYour task is to reconstruct, over a finite field with prime modulus $p$, two independent numerator polynomials $n_a(x)$ and $n_b(x)$ for two graphs in a Jacobi triplet, and to use CK duality to eliminate the third numerator $n_c(x)$ via the coefficient-level identity $c_c = -c_a - c_b$. Here each numerator is modeled as a polynomial in the kinematic variables\n$$\nx = (s_{12}, s_{23}, s_{34}, \\ell_1, \\ell_2)\n$$\nusing the monomial basis\n$$\nM(x) = \\big(1,\\, s_{12},\\, s_{23},\\, s_{34},\\, \\ell_1,\\, \\ell_2\\big).\n$$\nThus, each numerator is parameterized as\n$$\nn_g(x) = \\sum_{j=1}^{6} c_{g,j}\\, M_j(x),\n$$\nfor $g \\in \\{a,b,c\\}$ with unknown coefficient vectors $c_a, c_b, c_c \\in \\mathbb{F}_p^6$. CK duality enforces\n$$\nc_c = -c_a - c_b \\quad \\text{over} \\quad \\mathbb{F}_p.\n$$\nGeneralized unitarity provides cut data $y_{g,i}$ at sampled points $x_i$, which for the toy maximal-cut model used here directly equals the numerator evaluation modulo $p$:\n$$\ny_{g,i} \\equiv n_g(x_i) \\pmod{p}.\n$$\n\nYou must implement a finite-field solver that:\n- Constructs a linear system from the sample equations\n$$\nM(x_i)\\cdot c_a = y_{a,i}, \\quad M(x_i)\\cdot c_b = y_{b,i}, \\quad M(x_i)\\cdot c_c = y_{c,i},\n$$\nand eliminates $c_c$ using CK duality to yield the constraint\n$$\n-M(x_i)\\cdot c_a - M(x_i)\\cdot c_b = y_{c,i}.\n$$\n- Solves the resulting (possibly overdetermined) linear system modulo $p$ via Gaussian elimination with modular arithmetic to obtain $c_a$ and $c_b$.\n- Recovers $c_c$ via $c_c = -c_a - c_b$ and validates:\n    1. The Jacobi identity $n_a(x) + n_b(x) + n_c(x) \\equiv 0 \\pmod{p}$ on independent validation points.\n    2. The cut consistency $n_g(x) \\equiv y_{g}(x) \\pmod{p}$ for $g \\in \\{a,b,c\\}$ on additional validation points.\n\nAll arithmetic must be done in the finite field $\\mathbb{F}_p$ with a prime modulus $p$. You must implement modular inversion and modular row-reduction. Do not use floating-point arithmetic; all quantities must be integers reduced modulo $p$.\n\nUnit specification: No physical units are involved; all quantities are pure integers modulo a prime. Angles are not used.\n\nTest suite and final output specification:\n- Use the following monomial basis $M(x) = \\big(1,\\, s_{12},\\, s_{23},\\, s_{34},\\, \\ell_1,\\, \\ell_2\\big)$ for all graphs and all test cases.\n- For each test case, a fixed prime $p$ is provided alongside a set of sample points and a set of validation points. At each point, $x=(s_{12},s_{23},s_{34},\\ell_1,\\ell_2)$, apply the equations above. The cut data $y_{g,i}$ is synthetically generated in-program from a hidden oracle numerator that is fixed across all test cases (the program will define and use it deterministically so the results are reproducible).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each result is a boolean indicating whether, for that test case, the reconstructed coefficients pass both the Jacobi identity and cut-consistency validations on the provided validation points.\n\nTest cases to implement:\n- Test case $1$ (happy path):\n    - Prime modulus: $p=101$.\n    - Sample points for reconstruction ($6$ points, minimal determined):\n        1. $(s_{12},s_{23},s_{34},\\ell_1,\\ell_2)=(1,0,0,0,0)$,\n        2. $(0,1,0,0,0)$,\n        3. $(0,0,1,0,0)$,\n        4. $(0,0,0,1,0)$,\n        5. $(0,0,0,0,1)$,\n        6. $(2,2,2,2,2)$.\n    - Validation points ($3$ points):\n        1. $(3,1,4,1,5)$,\n        2. $(9,2,6,5,3)$,\n        3. $(10,20,30,40,50)$.\n- Test case $2$ (overdetermined system and robustness):\n    - Prime modulus: $p=97$.\n    - Sample points for reconstruction ($8$ points, overdetermined):\n        1. $(1,0,0,0,0)$,\n        2. $(0,1,0,0,0)$,\n        3. $(0,0,1,0,0)$,\n        4. $(0,0,0,1,0)$,\n        5. $(0,0,0,0,1)$,\n        6. $(2,2,2,2,2)$,\n        7. $(4,5,6,7,8)$,\n        8. $(10,9,8,7,6)$.\n    - Validation points ($3$ points):\n        1. $(3,5,7,11,13)$,\n        2. $(6,5,4,3,2)$,\n        3. $(8,13,21,34,55)$.\n- Test case $3$ (edge values including zeros):\n    - Prime modulus: $p=89$.\n    - Sample points for reconstruction ($6$ points):\n        1. $(0,0,0,0,0)$,\n        2. $(1,0,0,0,0)$,\n        3. $(0,1,0,0,0)$,\n        4. $(0,0,1,0,0)$,\n        5. $(0,0,0,1,0)$,\n        6. $(0,0,0,0,1)$.\n    - Validation points ($3$ points):\n        1. $(2,3,5,7,11)$,\n        2. $(13,17,19,23,29)$,\n        3. $(1,1,1,1,1)$.\n\nYour program must:\n- Construct the augmented linear system over $\\mathbb{F}_p$ that includes equations for graphs $a$ and $b$ and CK-reduced equations for graph $c$.\n- Solve for $c_a$ and $c_b$ via finite-field Gaussian elimination with full pivoting over rows (column-wise forward selection is sufficient).\n- Recover $c_c$ using CK duality.\n- Validate both CK Jacobi and cut consistency at the validation points.\n- Print a single line of the form \"[bool1,bool2,bool3]\".\n\nNo external inputs, files, or network access are allowed. The code must be fully self-contained and deterministic.",
            "solution": "The posed problem is a well-defined computational task in theoretical high-energy physics. It asks for the reconstruction of kinematic numerator polynomials for a set of Feynman diagrams, subject to constraints from Color-Kinematics (CK) duality. The reconstruction is to be performed over a finite field $\\mathbb{F}_p$ using a set of sample data points provided by generalized unitarity cuts. The validity of the reconstruction is then tested on a separate set of validation points. The problem is scientifically grounded, mathematically consistent, and computationally feasible. It is therefore deemed valid.\n\nThe solution proceeds in four main stages:\n1.  **System Formulation**: We translate the physical constraints into a system of linear equations over the finite field $\\mathbb{F}_p$.\n2.  **Data Generation**: We define an oracle, as required, to synthetically generate the cut data for both reconstruction and validation.\n3.  **System Solution**: We implement a solver for this linear system using Gauss-Jordan elimination with modular arithmetic.\n4.  **Reconstruction and Validation**: We use the solution to reconstruct the numerator polynomials and validate them against the required physical consistency conditions.\n\n### 1. Theoretical Formulation and Linear System Construction\n\nThe problem specifies two independent numerators, $n_a(x)$ and $n_b(x)$, and a third, $n_c(x)$, which is dependent on the others through the Jacobi identity $n_a(x) + n_b(x) + n_c(x) = 0$. The kinematic variables are given by the vector $x = (s_{12}, s_{23}, s_{34}, \\ell_1, \\ell_2)$. Each numerator is parameterized as a linear combination of monomials from the basis $M(x) = (1, s_{12}, s_{23}, s_{34}, \\ell_1, \\ell_2)$.\nA numerator $n_g(x)$ for a graph $g \\in \\{a,b,c\\}$ is written as:\n$$n_g(x) = \\sum_{j=1}^{6} c_{g,j} M_j(x) = M(x) \\cdot c_g$$\nwhere $c_g = (c_{g,1}, \\dots, c_{g,6})^T$ is the vector of unknown coefficients in $\\mathbb{F}_p$. The Jacobi identity $n_a+n_b+n_c=0$ implies a constraint on the coefficients:\n$$M(x) \\cdot c_a + M(x) \\cdot c_b + M(x) \\cdot c_c = 0$$\nSince this must hold for all $x$, and the monomials in $M(x)$ are linearly independent, this requires a coefficient-level identity:\n$$c_a + c_b + c_c = 0 \\quad \\implies \\quad c_c = -c_a - c_b \\pmod p$$\nThe unknown coefficients to be solved for are the $6$ components of $c_a$ and the $6$ components of $c_b$, making a total of $12$ unknowns. Let us define a single vector of unknowns $C \\in \\mathbb{F}_p^{12}$ as the concatenation of $c_a$ and $c_b$:\n$$C = (c_{a,1}, \\dots, c_{a,6}, c_{b,1}, \\dots, c_{b,6})^T$$\nGeneralized unitarity cuts provide sample data $(x_i, y_{a,i}, y_{b,i}, y_{c,i})$ for a set of kinematic points $x_i$, where $y_{g,i} \\equiv n_g(x_i) \\pmod p$. These relations furnish a system of linear equations. For each sample point $x_i$:\n1.  $M(x_i) \\cdot c_a = y_{a,i}$\n2.  $M(x_i) \\cdot c_b = y_{b,i}$\n3.  $M(x_i) \\cdot c_c = y_{c,i}$\n\nSubstituting $c_c = -c_a - c_b$ into the third equation gives:\n$$-M(x_i) \\cdot c_a - M(x_i) \\cdot c_b = y_{c,i}$$\nFor each sample point $i$, we obtain a set of simultaneous equations for the combined unknown vector $C$. Let $M_i$ be the $1 \\times 6$ row vector for the monomial basis evaluated at $x_i$. The equations can be written in matrix form. For a single point $x_i$, we have:\n$$\n\\begin{pmatrix}\nM_i & \\mathbf{0}_{1 \\times 6} \\\\\n\\mathbf{0}_{1 \\times 6} & M_i \\\\\n-M_i & -M_i\n\\end{pmatrix}\n\\begin{pmatrix} c_a \\\\ c_b \\end{pmatrix}\n=\n\\begin{pmatrix} y_{a,i} \\\\ y_{b,i} \\\\ y_{c,i} \\end{pmatrix}\n$$\nStacking these equations for all $k$ sample points results in a single large linear system $A_{sys} \\cdot C = Y_{sys}$, where $A_{sys}$ is a $(3k) \\times 12$ matrix and $Y_{sys}$ is a $(3k) \\times 1$ vector.\n\n### 2. Oracle Data Generation\n\nThe problem states that the cut data $y_{g,i}$ must be generated from a fixed, hidden oracle. We define these oracle numerators by choosing fixed integer coefficient vectors. Let us choose:\n-   $c_a^{\\text{true}} = (3, 5, -2, 1, 8, 4)$\n-   $c_b^{\\text{true}} = (7, -1, 0, 6, -3, 2)$\n\nThe third coefficient vector is determined by the Jacobi identity:\n-   $c_c^{\\text{true}} = -c_a^{\\text{true}} - c_b^{\\text{true}} = (-10, -4, 2, -7, -5, -6)$\n\nFor any given kinematic point $x_i$ and prime $p$, the cut data is generated as $y_{g,i} = (M(x_i) \\cdot c_g^{\\text{true}}) \\pmod p$. This ensures that the provided input data is internally consistent with the underlying CK-dual structure.\n\n### 3. Finite Field Linear System Solver\n\nTo solve $A_{sys} \\cdot C = Y_{sys}$ modulo a prime $p$, we implement Gauss-Jordan elimination. This algorithm transforms the augmented matrix $[A_{sys} | Y_{sys}]$ into its reduced row echelon form (RREF), from which the solution can be directly extracted. All arithmetic operations (addition, subtraction, multiplication, division) are performed modulo $p$. Division by an element $d$ is replaced by multiplication by its modular multiplicative inverse, $d^{-1} \\pmod p$. Since $p$ is prime, Fermat's Little Theorem guarantees that $d^{-1} \\equiv d^{p-2} \\pmod p$ for any $d \\not\\equiv 0 \\pmod p$.\n\nThe algorithm proceeds column by column, using row-pivoting (swapping a row to bring a non-zero element to the pivot position) to ensure a non-zero pivot is used for elimination. After transforming the system to RREF:\n-   For a uniquely determined system (number of independent equations equals number of variables), the left part of the augmented matrix becomes the $12 \\times 12$ identity matrix, and the right part contains the unique solution for $C$.\n-   For a consistent overdetermined system (more independent equations than variables), the RREF will have zero-rows at the bottom of the coefficient matrix part. Consistency requires the corresponding entries in the augmented part to also be zero. The unique solution is read from the non-zero rows.\n-   An inconsistent system would yield a row of the form $(0, \\dots, 0 | d)$ with $d \\not\\equiv 0 \\pmod p$, indicating no solution.\n\n### 4. Reconstruction and Validation\n\nOnce the solver returns the coefficient vector $C$, we extract the reconstructed coefficients $c_a^{\\text{recon}}$, $c_b^{\\text{recon}}$. We then compute $c_c^{\\text{recon}} = -c_a^{\\text{recon}} - c_b^{\\text{recon}} \\pmod p$. These three vectors define the reconstructed numerator polynomials $n_g^{\\text{recon}}(x)$.\n\nValidation is performed on a separate set of points $x_v$. For each validation point, we perform two checks:\n1.  **Cut Consistency**: We compute the value of our reconstructed numerators, $n_g^{\\text{recon}}(x_v)$, and compare them to the oracle values, $y_g(x_v) = (M(x_v) \\cdot c_g^{\\text{true}}) \\pmod p$. The reconstruction is valid only if $n_g^{\\text{recon}}(x_v) \\equiv y_g(x_v) \\pmod p$ for all $g \\in \\{a,b,c\\}$ and for all validation points.\n2.  **Jacobi Identity**: We verify that the sum of the reconstructed numerators is zero modulo $p$: $(n_a^{\\text{recon}}(x_v) + n_b^{\\text{recon}}(x_v) + n_c^{\\text{recon}}(x_v)) \\equiv 0 \\pmod p$. By our construction of $c_c^{\\text{recon}}$, this algebraic identity is guaranteed to hold for the polynomials themselves and thus at any evaluation point. This check serves as a verification of the internal logic of the reconstruction process.\n\nA test case is considered successful (evaluates to `True`) if and only if all validation points pass both checks.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases for numerator reconstruction and validation.\n    \"\"\"\n\n    # Oracle Definition: Hidden, true coefficient vectors for the numerators.\n    # These are fixed for all test cases to ensure reproducibility.\n    TRUE_CA = np.array([3, 5, -2, 1, 8, 4], dtype=np.int64)\n    TRUE_CB = np.array([7, -1, 0, 6, -3, 2], dtype=np.int64)\n    TRUE_CC = -(TRUE_CA + TRUE_CB)\n\n    def monomial_basis_eval(x_point):\n        \"\"\"Evaluates the monomial basis M(x) at a given point x.\"\"\"\n        s12, s23, s34, l1, l2 = x_point\n        return np.array([1, s12, s23, s34, l1, l2], dtype=np.int64)\n\n    def evaluate_numerator(coeffs, x_point, p):\n        \"\"\"Evaluates a numerator polynomial n(x) = M(x) . c at a point x mod p.\"\"\"\n        m_vec = monomial_basis_eval(x_point)\n        # Use Python's arbitrary-precision integers for dot product before modulo\n        val = np.dot(m_vec, coeffs)\n        return int(val % p)\n\n    def generate_cut_data(x_point, p):\n        \"\"\"Generates oracle cut data (y_a, y_b, y_c) for a given point x and prime p.\"\"\"\n        y_a = evaluate_numerator(TRUE_CA, x_point, p)\n        y_b = evaluate_numerator(TRUE_CB, x_point, p)\n        y_c = evaluate_numerator(TRUE_CC, x_point, p)\n        return y_a, y_b, y_c\n\n    def mod_inv(n, p):\n        \"\"\"Computes the modular multiplicative inverse of n modulo p using Fermat's Little Theorem.\"\"\"\n        return pow(n, p - 2, p)\n\n    def solve_modular_linear_system(A, b, p):\n        \"\"\"\n        Solves the linear system Ax = b over the finite field F_p using Gauss-Jordan elimination.\n        A is an m x n matrix, b is an m-element vector.\n        Returns the solution vector x if a unique solution exists, otherwise None.\n        \"\"\"\n        m, n = A.shape\n        # Use python lists of lists of standard ints for safe modular arithmetic\n        aug = [list(map(int, A[i])) + [int(b[i])] for i in range(m)]\n\n        pivot_row = 0\n        for j in range(n):  # Iterate through columns (variables)\n            if pivot_row == m:\n                break\n\n            # Find a row with a non-zero pivot in the current column\n            i = pivot_row\n            while i < m and aug[i][j] == 0:\n                i += 1\n\n            if i < m:  # Pivot found\n                aug[pivot_row], aug[i] = aug[i], aug[pivot_row]  # Swap rows\n\n                # Normalize the pivot row\n                pivot_val = aug[pivot_row][j]\n                inv_pivot = mod_inv(pivot_val, p)\n                for k in range(j, n + 1):\n                    aug[pivot_row][k] = (aug[pivot_row][k] * inv_pivot) % p\n\n                # Eliminate other entries in the current column\n                for i in range(m):\n                    if i != pivot_row:\n                        factor = aug[i][j]\n                        if factor == 0: continue\n                        for k in range(j, n + 1):\n                            aug[i][k] = (aug[i][k] - factor * aug[pivot_row][k]) % p\n                \n                pivot_row += 1\n        \n        # Check for inconsistencies in overdetermined systems\n        for i in range(pivot_row, m):\n            if aug[i][n] != 0:\n                return None  # No solution\n\n        # Check for unique solution (RREF should be [I_n; 0 | solution; 0])\n        if pivot_row < n:\n            return None # Not a unique solution\n        \n        solution = np.zeros(n, dtype=np.int64)\n        for i in range(n):\n            solution[i] = aug[i][n]\n            \n        return solution\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"p\": 101,\n            \"samples\": [(1,0,0,0,0), (0,1,0,0,0), (0,0,1,0,0), (0,0,0,1,0), (0,0,0,0,1), (2,2,2,2,2)],\n            \"validations\": [(3,1,4,1,5), (9,2,6,5,3), (10,20,30,40,50)],\n        },\n        {\n            \"p\": 97,\n            \"samples\": [(1,0,0,0,0), (0,1,0,0,0), (0,0,1,0,0), (0,0,0,1,0), (0,0,0,0,1), (2,2,2,2,2), (4,5,6,7,8), (10,9,8,7,6)],\n            \"validations\": [(3,5,7,11,13), (6,5,4,3,2), (8,13,21,34,55)],\n        },\n        {\n            \"p\": 89,\n            \"samples\": [(0,0,0,0,0), (1,0,0,0,0), (0,1,0,0,0), (0,0,1,0,0), (0,0,0,1,0), (0,0,0,0,1)],\n            \"validations\": [(2,3,5,7,11), (13,17,19,23,29), (1,1,1,1,1)],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p = case[\"p\"]\n        sample_points = case[\"samples\"]\n        validation_points = case[\"validations\"]\n        \n        num_samples = len(sample_points)\n        num_unknowns = 12\n        \n        A_sys = np.zeros((3 * num_samples, num_unknowns), dtype=np.int64)\n        Y_sys = np.zeros(3 * num_samples, dtype=np.int64)\n\n        for i, point in enumerate(sample_points):\n            m_vec = monomial_basis_eval(point)\n            y_a, y_b, y_c = generate_cut_data(point, p)\n\n            # Equation for n_a: M(x_i) . c_a = y_a_i\n            A_sys[3*i, 0:6] = m_vec\n            Y_sys[3*i] = y_a\n\n            # Equation for n_b: M(x_i) . c_b = y_b_i\n            A_sys[3*i+1, 6:12] = m_vec\n            Y_sys[3*i+1] = y_b\n            \n            # Equation for n_c via CK: -M(x_i).c_a - M(x_i).c_b = y_c_i\n            A_sys[3*i+2, 0:6] = -m_vec\n            A_sys[3*i+2, 6:12] = -m_vec\n            Y_sys[3*i+2] = y_c\n            \n        C_recon = solve_modular_linear_system(A_sys, Y_sys, p)\n\n        if C_recon is None:\n            results.append(False)\n            continue\n            \n        c_a_recon = C_recon[0:6]\n        c_b_recon = C_recon[6:12]\n        c_c_recon = (-(c_a_recon + c_b_recon)) % p\n\n        case_is_valid = True\n        for point in validation_points:\n            # Oracle values at validation point\n            y_a_val, y_b_val, y_c_val = generate_cut_data(point, p)\n            \n            # Reconstructed numerator values at validation point\n            n_a_recon = evaluate_numerator(c_a_recon, point, p)\n            n_b_recon = evaluate_numerator(c_b_recon, point, p)\n            n_c_recon = evaluate_numerator(c_c_recon, point, p)\n            \n            # 1. Cut consistency check\n            if not (n_a_recon == y_a_val and n_b_recon == y_b_val and n_c_recon == y_c_val):\n                case_is_valid = False\n                break\n                \n            # 2. Jacobi identity check\n            if (n_a_recon + n_b_recon + n_c_recon) % p != 0:\n                case_is_valid = False\n                break\n        \n        if not case_is_valid:\n            results.append(False)\n            continue\n\n        results.append(True)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}