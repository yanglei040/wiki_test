{
    "hands_on_practices": [
        {
            "introduction": "在任何多圈微扰计算中，第一步都是识别哪些费曼图会产生紫外发散。本练习将通过基本的幂次计数原理，引导你推导一个关键工具——表面发散度（superficial degree of divergence）。通过将这个概念应用于标量 $\\phi^4$ 理论中的具体振幅，你将能够系统性地预测哪些格林函数在单圈水平上需要引入抵消项，从而为理解重整化的必要性奠定坚实的基础。",
            "id": "3530976",
            "problem": "考虑一个具有四次自相互作用的实标量场理论，其裸拉格朗日密度由下式定义\n$$\n\\mathcal{L}_{0} = \\frac{1}{2} (\\partial_{\\mu} \\phi_{0})(\\partial^{\\mu} \\phi_{0}) - \\frac{1}{2} m_{0}^{2} \\phi_{0}^{2} - \\frac{\\lambda_{0}}{4!} \\phi_{0}^{4}\n$$\n在时空维度 $d = 4 - 2 \\epsilon$ 下，使用维度正规化进行调节。其中 $\\phi_{0}$、$m_{0}$ 和 $\\lambda_{0}$ 是裸量。该理论中的单粒子不可约（1PI）图由动量空间中与 $p^{-2}$ 成比例的传播子和不含导数的点状相互作用顶点构成。\n\n仅使用幂次计数的基本原理以及连通 1PI 图中内线、顶点、圈和外腿之间的拓扑关系，推导单圈情况下通用 $E$ 点振幅的表观发散度 $\\omega$，然后显式计算 1PI 两点（$E=2$）、四点（$E=4$）和六点（$E=6$）振幅的 $\\omega$ 值。根据结果以及维度正规化中最小减除（MS）方案下抵消项的定义，确定在单圈水平上，哪些振幅需要紫外抵消项。\n\n你的最终输出必须是一个 $2 \\times 3$ 的矩阵。第一行必须包含单圈情况下 $E=2, 4, 6$ 时表观发散度 $\\omega$ 关于 $\\epsilon$ 的表达式，第二行必须包含二进制指示符，用于表示相应振幅是否在最小减除（MS）方案下需要单圈抵消项，其中 $1$ 表示“需要抵消项”，$0$ 表示“不需要抵消项”。",
            "solution": "问题要求计算标量 $\\phi^4$ 理论中，单圈水平下，单粒子不可约（1PI）两点（$E=2$）、四点（$E=4$）和六点（$E=6$）振幅的表观发散度 $\\omega$，并确定其中哪些需要抵消项。分析将基于 $d = 4 - 2\\epsilon$ 时空维度下费曼图的幂次计数和拓扑关系。\n\n对于一个普遍的费曼图，其表观发散度 $\\omega$ 由以下公式给出：\n$$\n\\omega = Ld - 2I + \\sum_{V} n_V \\delta_V\n$$\n其中 $L$ 是独立圈的数量，$d$ 是时空维度，$I$ 是内传播子的数量，$n_V$ 是 $V$ 型顶点的数量，$\\delta_V$ 是与 $V$ 型顶点相关的动量幂次。\n\n在给定理论中，拉格朗日密度为 $\\mathcal{L}_{0} = \\frac{1}{2} (\\partial_{\\mu} \\phi_{0})(\\partial^{\\mu} \\phi_{0}) - \\frac{1}{2} m_{0}^{2} \\phi_{0}^{2} - \\frac{\\lambda_{0}}{4!} \\phi_{0}^{4}$。它只有一种类型的相互作用顶点，对应于 $\\phi_{0}^{4}$ 项。该顶点是点状的，不涉及导数，意味着它不引入任何动量幂次。因此，$\\delta_V = 0$。$\\omega$ 的公式简化为：\n$$\n\\omega = Ld - 2I\n$$\n\n为了将 $\\omega$ 表示为外腿数 $E$ 和圈数 $L$ 的函数，我们使用两个关于连通图的基本拓扑关系。设 $V$ 为顶点总数。\n第一个关系连接了圈数、内线数和顶点数：\n$$\nL = I - V + 1\n$$\n第二个关系说明了线如何连接到顶点。在 $\\phi^4$ 理论中，每个顶点连接四条线。这些线要么是内传播子，要么是外腿。由于每条内线连接两个顶点，所有顶点的线端总数 $4V$ 必须等于外腿数 $E$ 加上两倍的内线数 $2I$：\n$$\n4V = E + 2I \\implies V = \\frac{E + 2I}{4}\n$$\n\n我们现在求解这个方程组来找到 $\\omega(E, L, d)$。将 $V$ 的表达式代入圈数关系式中：\n$$\nL = I - \\left( \\frac{E + 2I}{4} \\right) + 1\n$$\n$$\n4L = 4I - (E + 2I) + 4\n$$\n$$\n4L = 2I - E + 4\n$$\n求解出现在 $\\omega$ 公式中的 $2I$：\n$$\n2I = 4L + E - 4\n$$\n现在，将 $2I$ 的这个表达式代入 $\\omega$ 的公式中：\n$$\n\\omega = Ld - (4L + E - 4) = Ld - 4L - E + 4\n$$\n$$\n\\omega(E, L, d) = L(d - 4) - E + 4\n$$\n\n题目指定了时空维度 $d = 4 - 2\\epsilon$ 并要求计算单圈（$L=1$）振幅。将这些值代入 $\\omega$ 的通用公式中：\n$$\n\\omega(E, L=1) = 1 \\cdot ((4 - 2\\epsilon) - 4) - E + 4\n$$\n$$\n\\omega(E, L=1) = -2\\epsilon - E + 4 = 4 - E - 2\\epsilon\n$$\n这就是该理论中单圈、$E$ 点 1PI 振幅的表观发散度。\n\n现在，我们针对指定的外腿数计算 $\\omega$：\n1.  对于 1PI 两点函数（$E=2$）：\n$$\n\\omega(E=2) = 4 - 2 - 2\\epsilon = 2 - 2\\epsilon\n$$\n2.  对于 1PI 四点函数（$E=4$）：\n$$\n\\omega(E=4) = 4 - 4 - 2\\epsilon = -2\\epsilon\n$$\n3.  对于 1PI 六点函数（$E=6$）：\n$$\n\\omega(E=6) = 4 - 6 - 2\\epsilon = -2 - 2\\epsilon\n$$\n\n最后一步是确定这些振幅中哪些需要紫外（UV）抵消项。在维度正规化中，如果一个振幅的表观发散度 $\\omega$ 在调节子 $\\epsilon$ 趋于零的极限下为非负，则该振幅是紫外发散的。一个发散的振幅需要一个抵消项来抵消其发散（表现为 $\\epsilon$ 的一个极点）。\n我们对每种情况考察 $\\epsilon \\to 0$ 的极限：\n1.  对于 $E=2$：$\\lim_{\\epsilon \\to 0} \\omega = \\lim_{\\epsilon \\to 0} (2 - 2\\epsilon) = 2$。由于 $2 > 0$，该振幅是二次发散的。它需要抵消项，特别是针对质量（$\\delta m$）和波函数重整化（$\\delta_Z$）。因此，需要一个抵消项（$1$）。\n2.  对于 $E=4$：$\\lim_{\\epsilon \\to 0} \\omega = \\lim_{\\epsilon \\to 0} (-2\\epsilon) = 0$。由于 $0 \\ge 0$，该振幅是对数发散的。它需要一个针对耦合常数（$\\delta_\\lambda$）的抵消项。因此，需要一个抵消项（$1$）。\n3.  对于 $E=6$：$\\lim_{\\epsilon \\to 0} \\omega = \\lim_{\\epsilon \\to 0} (-2 - 2\\epsilon) = -2$。由于 $-2  0$，该振幅是紫外有限的。它不需要一个原始的单圈抵消项。因此，不需要抵消项（$0$）。\n\n我们现在可以将最终答案组合成一个 $2 \\times 3$ 的矩阵。第一行包含 $\\omega$ 的表达式，第二行包含表示是否需要抵消项的二进制指示符（$1$ 表示是，$0$ 表示否）。\n第一行是：$\\omega(E=2)=2-2\\epsilon$，$\\omega(E=4)=-2\\epsilon$，$\\omega(E=6)=-2-2\\epsilon$。\n第二行是：$1$，$1$，$0$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2 - 2\\epsilon  -2\\epsilon  -2 - 2\\epsilon \\\\\n1  1  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "重整化并非简单地减去无穷大；它必须严格遵守理论的内在对称性，例如规范不变性。这个练习将理论与计算实践相结合，让你通过编写代码来数值验证量子电动力学（QED）中的一个深刻结果：物理可观测量与协变规范中非物理的规范参数 $\\xi$ 无关。通过具体计算并验证不同项的规范依赖部分如何精确抵消，你将亲身体验到沃德-高桥恒等式（Ward-Takahashi identity）在确保理论自洽性方面的强大威力。",
            "id": "3531042",
            "problem": "考虑一个具有规范参数 $\\xi$ 的通用协变规范下的量子电动力学（QED），其中规范固定项已添加到拉格朗日密度中，因此自由光子传播子被修正为\n$$\nD_{\\mu\\nu}(k) = \\frac{-i}{k^2 + i0} \\left( g_{\\mu\\nu} - \\xi \\frac{k_\\mu k_\\nu}{k^2} \\right).\n$$\n在单圈水平上，电子自能和电子-光子顶点都接收到修正。光子传播子的纵向部分（与 $\\xi$ 成比例）是这些单圈量中显式 $\\xi$ 依赖性的唯一来源。当应用适当的抵消项和重整化方案时，重整化的 S 矩阵元必须与规范参数无关。在阿贝尔理论的情况下，Slavnov–Taylor 恒等式简化为 Ward–Takahashi 恒等式，这意味着在单圈水平上，电子场重整化常数与顶点重整化常数相等。\n\n从单圈电子自能 $\\Sigma(p)$ 和单圈顶点函数 $\\Gamma_\\mu(p,p')$ 的定义（用传播子和相互作用顶点表示）出发，并使用标准的 Feynman 参数化和迹/投影方法，推导出以下各项的规范参数依赖部分的一维积分表示：\n- 电子场重整化常数 $\\delta Z_\\psi(\\xi)$，通过在 $p^2 = m^2$ 处将 $\\partial \\Sigma/\\partial \\not p$ 的 $\\not p$ 分量投影，从在壳残数条件获得。\n- 在零动量转移下，在壳电荷形状因子的规范参数依赖部分 $\\delta F_1^{(\\xi)}(0)$，通过在 $q^2 = 0$ 处将顶点修正投影到 $\\gamma_\\mu$ 结构上提取。\n\n证明这两个规范参数依赖的部分都可以通过相同的标量积分\n$$\nJ(m) = \\int_0^1 dx \\, \\ln\\!\\left(\\frac{m^2}{m^2 - x(1-x) m^2}\\right) = \\int_0^1 dx \\, \\ln\\!\\left(\\frac{1}{1 - x + x^2}\\right),\n$$\n来表示，并且它们符号相反：\n$$\n\\delta Z_\\psi(\\xi) = \\frac{\\alpha \\, \\xi}{4\\pi} \\, J(m), \\qquad \\delta F_1^{(\\xi)}(0) = -\\frac{\\alpha \\, \\xi}{4\\pi} \\, J(m),\n$$\n其中 $\\alpha$ 是精细结构常数，而 $m$ 是电子质量。使用这些，零动量转移下在壳电荷形状因子的重整化振幅\n$$\nA_R^{(\\xi)} = \\delta F_1^{(\\xi)}(0) + \\delta Z_\\psi(\\xi),\n$$\n在单圈水平上必须与 $\\xi$ 无关。这在此背景下验证了阿贝尔 Slavnov–Taylor 恒等式（Ward–Takahashi 恒等式），该恒等式意味着对于规范依赖部分，在单圈水平上 $Z_1(\\xi) = Z_\\psi(\\xi)$。\n\n实现两种场重整化方案：\n- 在壳（OS）：在物理极点 $p^2 = m^2$ 处固定电子传播子的质量和残数。\n- 修正最小减除（$\\overline{\\mathrm{MS}}$）：仅减去紫外发散和与维度正则化相关的普适常数，保留有限部分不变。\n\n通过求积法数值计算 $J(m)$，并为一系列规范参数 $\\xi$ 验证 $A_R^{(\\xi)}$ 的 $\\xi$ 无关性。取精细结构常数 $\\alpha = 1/137$ 和一个任意一致单位的电子质量参数 $m$（最终检查是无量纲的，因此不需要明确的单位输出）。角度不出现。不使用百分比。\n\n你的程序必须实现 $J(m)$ 的积分，计算 $\\delta Z_\\psi(\\xi)$ 和 $\\delta F_1^{(\\xi)}(0)$，并在 OS 和 $\\overline{\\mathrm{MS}}$ 两种方案中验证 $A_R^{(\\xi)}$ 的单圈 $\\xi$ 无关性。此外，通过证明对于规范依赖部分 $\\delta Z_\\psi(\\xi) + \\delta F_1^{(\\xi)}(0) = 0$ 来确认恒等式 $Z_1(\\xi) = Z_\\psi(\\xi)$。\n\n测试套件：\n- 情况 1（正常路径，Landau 规范）：$\\xi = 0.0$，方案 OS，$m = 0.511$，$\\alpha = 1/137$。\n- 情况 2（Feynman 规范）：$\\xi = 1.0$，方案 OS，$m = 0.511$，$\\alpha = 1/137$。\n- 情况 3（大规范参数）：$\\xi = 3.0$，方案 OS，$m = 0.511$，$\\alpha = 1/137$。\n- 情况 4（方案变化）：$\\xi = 1.0$，方案 $\\overline{\\mathrm{MS}}$，$m = 0.511$，$\\alpha = 1/137$。\n- 情况 5（恒等式检查）：对于 $\\xi = 2.5$，方案 OS，$m = 0.511$，$\\alpha = 1/137$，验证 $\\delta Z_\\psi(\\xi) + \\delta F_1^{(\\xi)}(0) \\approx 0$。\n\n对于每种情况，返回一个布尔值，指示相应的检查是否在 $10^{-10}$ 的绝对容差内通过。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”）。",
            "solution": "该问题陈述是计算高能物理学中的一个有效练习，要求在单圈水平上数值验证量子电动力学（QED）中规范不变性的一个关键推论。我将首先建立理论背景，然后详细说明数值验证过程。\n\n该问题要求验证在电子与光子相互作用的单圈修正中，与规范参数相关的项相互抵消。在 QED 中，引入规范固定项对于以协变方式量子化理论是必要的。此过程将一个非物理的规范参数（通常表示为 $\\xi$）引入到中间计算中，例如光子传播子 $D_{\\mu\\nu}(k)$：\n$$\nD_{\\mu\\nu}(k) = \\frac{-i}{k^2 + i0} \\left( g_{\\mu\\nu} - \\xi \\frac{k_\\mu k_\\nu}{k^2} \\right)\n$$\n物理可观测量，如 S 矩阵元，必须与 $\\xi$ 无关。这种无关性由理论的内在规范对称性保证，该对称性通过格林函数之间的关系（称为 Slavnov-Taylor 恒等式）体现出来。对于像 QED 这样的阿贝尔理论，这些恒等式简化为 Ward-Takahashi 恒等式。\n\n在单圈水平上，电子自能 $\\Sigma(p)$ 和电子-光子顶点函数 $\\Gamma_\\mu(p, p')$ 会收到依赖于 $\\xi$ 的发散修正。重整化是通过重新定义理论的场和参数（如电子场重整化常数 $Z_\\psi$ 和顶点重整化常数 $Z_1$）来吸收这些发散的过程。QED 的 Ward-Takahashi 恒等式暗示了这两个常数之间的一个关键关系：$Z_1 = Z_\\psi$。\n\n问题聚焦于单圈修正的规范依赖部分。设 $\\delta Z_\\psi = Z_\\psi - 1$ 和 $\\delta Z_1 = Z_1 - 1$ 为抵消项。我们可以将它们分解为一个规范无关部分和一个规范依赖部分，例如 $\\delta Z_\\psi = \\delta Z_\\psi^{(\\text{inv})} + \\delta Z_\\psi(\\xi)$。Ward-Takahashi 恒等式 $Z_1 = Z_\\psi$ 必须对这两部分分别成立，因此 $\\delta Z_1(\\xi) = \\delta Z_\\psi(\\xi)$。\n\n在壳顶点函数 $\\Gamma_\\mu$ 由形状因子参数化，主要是电荷形状因子 $F_1(q^2)$，其中 $q=p'-p$。值 $F_1(0)$ 对重整化电荷的定义有贡献。$F_1(q^2)$ 的单圈贡献也有一个规范依赖的部分，我们记作 $\\delta F_1^{(\\xi)}(q^2)$。为使物理电荷与规范无关，在零动量转移下，对顶点的完整单圈修正的规范依赖部分必须为零。这个修正由圈图部分 $F_1(0)$ 和抵消项部分 $\\delta Z_1$ 组成。因此，它们的规范依赖部分之和必须为零：\n$$\n\\delta F_1^{(\\xi)}(0) + \\delta Z_1(\\xi) = 0\n$$\n利用 Ward-Takahashi 恒等式，这变为：\n$$\n\\delta F_1^{(\\xi)}(0) + \\delta Z_\\psi(\\xi) = 0\n$$\n这是需要验证的核心恒等式。问题给出了这些 $\\xi$ 依赖部分的单圈计算结果：\n$$\n\\delta Z_\\psi(\\xi) = \\frac{\\alpha \\, \\xi}{4\\pi} \\, J(m)\n$$\n$$\n\\delta F_1^{(\\xi)}(0) = -\\frac{\\alpha \\, \\xi}{4\\pi} \\, J(m)\n$$\n其中 $\\alpha$ 是精细结构常数，而 $J(m)$ 是一个特定的标量积分。它们的和，在问题中定义为 $A_R^{(\\xi)} = \\delta F_1^{(\\xi)}(0) + \\delta Z_\\psi(\\xi)$，显然为零，这证实了理论上的预期。\n\n积分 $J(m)$ 给出为：\n$$\nJ(m) = \\int_0^1 dx \\, \\ln\\!\\left(\\frac{m^2}{m^2 - x(1-x) m^2}\\right)\n$$\n这个表达式可以通过消去质量参数 $m$ 来简化：\n$$\nJ(m) = \\int_0^1 dx \\, \\ln\\!\\left(\\frac{m^2}{m^2(1 - (x-x^2))}\\right) = \\int_0^1 dx \\, \\ln\\!\\left(\\frac{1}{1 - x + x^2}\\right)\n$$\n这表明积分 $J$ 实际上是一个普适常数，与电子质量 $m$ 无关。被积函数的分母 $1-x+x^2$ 对于 $x \\in [0, 1]$ 严格为正，因此积分是良定义的。我们将数值计算这个定积分。\n\n问题提到了两种重整化方案，在壳（OS）和修正最小减除（$\\overline{\\mathrm{MS}}$）。这些方案在它们定义的抵消项的有限、规范无关部分上有所不同。然而，规范依赖的部分 $\\delta Z_\\psi(\\xi)$ 和 $\\delta F_1^{(\\xi)}(0)$ 完全由规范固定项和理论的结构决定，因此与重整化方案的选择无关。因此，验证抵消关系 $\\delta F_1^{(\\xi)}(0) + \\delta Z_\\psi(\\xi) = 0$ 在任何有效的方案中都是相同的，这是通过包含 OS 和 $\\overline{\\mathrm{MS}}$ 两种情况来测试的一个概念点。\n\n数值任务是为测试套件实现计算。对于每种情况，我们将：\n1. 使用求积法数值计算常数 $J = \\int_0^1 \\ln(1 / (1 - x + x^2)) dx$ 的值。\n2. 使用给定的精细结构常数 $\\alpha = 1/137$ 和规范参数 $\\xi$ 的值。\n3. 使用提供的公式计算 $\\delta Z_\\psi(\\xi)$ 和 $\\delta F_1^{(\\xi)}(0)$。\n4. 在 $10^{-10}$ 的数值容差内验证它们的和为零。对于检查“$\\xi$-无关性”的测试用例，这等同于检查和 $A_R^{(\\xi)}$ 是否为零，因为如果抵消成立，该量本身就被构造成零。恒等式 $Z_1(\\xi) = Z_\\psi(\\xi)$ 通过证明 $\\delta Z_\\psi(\\xi) + \\delta F_1^{(\\xi)}(0) = 0$ 来确认。\n\n该实现将使用 `scipy.integrate.quad` 进行精确的数值积分。程序结构将遍历五个测试用例，执行计算，并根据容差检查附加一个布尔结果。所有测试用例都预期会通过，因为它们代表了 QED 的一个基本一致性检查。对于 $\\xi=0$，这些量显然为零；对于其他 $\\xi$ 值，它们相互抵消，展示了理论结构的稳健性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Numerically verifies the cancellation of gauge-parameter-dependent terms\n    in one-loop QED corrections, as a consequence of the Ward-Takahashi identity.\n    \"\"\"\n\n    # Define the integrand for the scalar integral J.\n    # J = integral from 0 to 1 of ln(1 / (1 - x + x^2)) dx\n    def integrand(x):\n        return np.log(1.0 / (1.0 - x + x**2))\n\n    # Numerically evaluate the integral J. The result is a constant.\n    # The integration error is negligible for this problem's tolerance.\n    J_val, _ = integrate.quad(integrand, 0, 1)\n\n    # Define constants from the problem statement.\n    alpha = 1.0 / 137.0\n    pi = np.pi\n    tolerance = 1e-10\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (xi, scheme, m). Note: scheme and m do not affect the calculation\n    # of the gauge-dependent pieces, as explained in the solution.\n    test_cases = [\n        (0.0, 'OS', 0.511),         # Case 1: Landau gauge\n        (1.0, 'OS', 0.511),         # Case 2: Feynman gauge\n        (3.0, 'OS', 0.511),         # Case 3: Large gauge parameter\n        (1.0, 'MS_bar', 0.511),     # Case 4: Scheme variation (conceptual check)\n        (2.5, 'OS', 0.511)          # Case 5: Explicit identity check\n    ]\n\n    results = []\n\n    for i, case in enumerate(test_cases):\n        xi, scheme, m = case\n\n        # Calculate the gauge-parameter-dependent parts of the electron field\n        # renormalization constant and the charge form factor.\n        # delta Z_psi(xi) = (alpha * xi / (4 * pi)) * J\n        delta_Z_psi_xi = (alpha * xi / (4.0 * pi)) * J_val\n\n        # delta F_1^(xi)(0) = -(alpha * xi / (4 * pi)) * J\n        delta_F1_xi_0 = -(alpha * xi / (4.0 * pi)) * J_val\n\n        # The quantity A_R^(xi) is the sum of these two, which must be independent\n        # of xi, implying it must be zero for the cancellation to hold.\n        # This check is the same for all test cases.\n        # For cases 1-4, we verify xi-independence by checking if the sum is zero.\n        # For case 5, we explicitly check if the sum is approximately zero.\n        # The logic is identical for all five cases.\n        \n        sum_of_gauge_parts = delta_Z_psi_xi + delta_F1_xi_0\n\n        # Check if the absolute value of the sum is within the given tolerance.\n        check_passed = np.abs(sum_of_gauge_parts)  tolerance\n        results.append(check_passed)\n        \n    # Convert numpy.bool_ to standard Python bool for printing \"True\" or \"False\"\n    # and format the output as a comma-separated list in brackets.\n    # str() on a bool gives capitalized 'True'/'False' which is fine, no need for special mapping.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然所有重整化方案都必须消除紫外发散，但它们在如何处理抵消项的有限部分上有所不同，这导致了最小减除（MS）、修正最小减除（$\\overline{\\mathrm{MS}}$）等不同方案的存在。本练习旨在让你深入理解方案选择的本质，通过构建一个玩具模型下的自动化代码生成器来实践这一概念。你将设计一个系统，它能自动识别发散的子图，并以一种方案无关的方式插入抵消项，将有限部分的选择推迟到用户指定的后处理层，从而清晰地分离重整化中的普适结构与方案依赖的约定。",
            "id": "3531050",
            "problem": "您需要实现一个程序，该程序能够自动标记紫外发散子图，构造一个与方案无关的对消项插入，并将所有有限的方案选择推迟到一个后处理层，该层强制执行用户指定的重整化条件。目标场论是具有四次自相互作用的实标量场。您的设计必须从第一性原理和公认的定义出发，如下所述。\n\n从以下基本原理开始。\n\n- 在 $d = 4 - 2\\epsilon$ 维（其中 $\\epsilon \\to 0^{+}$）中使用维数正规化。一个费曼振幅表示为关于 $\\epsilon$ 的洛朗级数，所有紫外 (UV) 发散都表现为 $\\epsilon$ 的极点。\n- 在 $d=4$ 维的标量 $\\phi^{4}$ 理论中，对于一个具有 $E$ 条外腿的连通子图，其表观发散度为 $\\omega = 4 - E$。因此，具有 $E \\in \\{0,2,4\\}$ 的子图是表观紫外发散的，而那些具有 $E \\ge 6$ 的子图是表观收敛的。\n- 通过对消项的重整化，利用 Bogoliubov-Parasiuk-Hepp-Zimmermann (BPHZ) 森林公式在局域上减去紫外发散。在维数正规化中，最小减除 (MS) 只移除 $\\epsilon$ 中的极点项，而其他方案则在有限部分上有所不同。一个与方案无关的对消项表示必须通过局域性和幂次计数来保持极点部分固定，而将有限部分作为方案参数，留待在后处理步骤中通过重整化条件来确定。\n\n为了使任务在计算上明确，同时忠实于上述原理，我们对特定的单圈原初拓扑结构和复合双圈拓扑结构的振幅采用以下玩具但结构正确的模型。\n\n- 定义一个原初单圈两点子图（类蝌蚪图修正），其振幅为\n  $$A_{2}^{(1)}(\\lambda, m^{2}) = \\lambda\\, m^{2}\\left(\\frac{c_{2}}{\\epsilon} + f_{2}\\right),$$\n  其中 $\\lambda$ 是四次耦合常数，$m^{2}$ 是质量参数，$c_{2} = \\tfrac{1}{2}$ 是一个固定的极点系数，$f_{2}$ 是作为输入数据提供的有限余项。\n- 定义一个原初单圈四点子图（单个气泡图），其振幅为\n  $$A_{4}^{(1)}(\\lambda) = \\lambda^{2}\\left(\\frac{c_{4}}{\\epsilon} + f_{4}\\right),$$\n  其中 $c_{4} = 3$ 是一个固定的极点系数，$f_{4}$ 是作为输入数据提供的有限余项。\n- 定义一个复合双圈四点“双气泡”拓扑结构，其未重整化振幅模型为\n  $$A_{4,\\mathrm{db}}^{(2)}(\\lambda) = \\lambda^{3}\\left(\\frac{c_{4}}{\\epsilon} + f_{4}\\right)^{2}.$$\n  这个复合图包含两个相同的单圈四点子发散。在一个与方案无关的对消项插入中，您必须局域地减去每个发散的单圈四点子图，使得复合有限余项成为所选有限方案参数的函数。\n\n您的程序必须为每个输入图实例执行以下步骤。\n\n1) 标记紫外发散子图。给定每个子图的外腿数 $E$ 和圈数 $L$，计算 $\\omega = 4 - E$。如果 $\\omega \\ge 0$ 且 $L \\ge 1$，则将该子图标记为紫外发散。\n\n2) 构造一个与方案无关的中间表示 (IR)。对于每个标记的紫外发散子图，将其对消项符号化地表示为其极点部分的减除加上一个未定的有限参数。具体来说，为两点子图引入有限参数 $\\alpha_{m}$，为四点子图引入 $\\alpha_{\\lambda}$，并定义对消项\n   - 对于单圈两点：$$\\delta m^{2} = -\\lambda\\, m^{2}\\left(\\frac{c_{2}}{\\epsilon} + \\alpha_{m}\\right).$$\n   - 对于单圈四点：$$\\delta \\lambda = -\\lambda^{2}\\left(\\frac{c_{4}}{\\epsilon} + \\alpha_{\\lambda}\\right).$$\n   在这个与方案无关的 IR 中，这些 $\\alpha$ 参数尚未确定。\n\n3) 森林减除和重整化振幅。实现 $R'$-操作，通过在每个标记的子图处插入上述对消项来减除所有子发散。在这个玩具模型中，这将每个原初单圈子图简化为其有限余项\n   - 单圈两点有限余项：$$F_{2}^{(1)} = \\lambda\\, m^{2}\\left(f_{2} - \\alpha_{m}\\right).$$\n   - 单圈四点有限余项：$$F_{4}^{(1)} = \\lambda^{2}\\left(f_{4} - \\alpha_{\\lambda}\\right).$$\n   对于复合双圈双气泡图，减去两个子发散后，重整化的有限余项为\n   $$F_{4,\\mathrm{db}}^{(2)} = \\lambda^{3}\\left(f_{4} - \\alpha_{\\lambda}\\right)^{2}.$$\n   在此模型中，一旦所有子发散被减去，就不会留下额外的整体发散；因此该复合图不需要额外的整体对消项。\n\n4) 用于固定方案的后处理层。有限参数 $\\alpha_{m}$ 和 $\\alpha_{\\lambda}$ 在与方案无关的构造完成后，根据用户指定的条件来选择。实现以下三类条件：\n   - 最小减除 (MS)：设置 $\\alpha_{m} = 0$ 和 $\\alpha_{\\lambda} = 0$。\n   - 自定义有限平移：当指定时，使用为 $\\alpha_{m}$ 和 $\\alpha_{\\lambda}$ 提供的数值；任何未指定的 $\\alpha$ 默认为 $0$。\n   - 针对单圈四点函数的类动量减除条件 (MOM4\\_ZERO)：要求单圈四点重整化修正在选定的运动学点上为零，此处通过设置 $\\alpha_{\\lambda} = f_{4}$ 来实现，并且除非另有规定，取 $\\alpha_{m} = 0$。\n\n实现要求。\n\n- 您必须实现：\n  - 一个计算 $\\omega = 4 - E$ 并将 $\\omega \\ge 0$ 且 $L \\ge 1$ 的子图标记为紫外发散的函数。\n  - 一个与方案无关的 IR 构建器，它将每个标记的子图替换为其对消项符号 $(\\text{极点} + \\alpha)$，并推迟 $\\alpha$ 的选择。\n  - 一个后处理层，它在给定方案规范的情况下，确定 $(\\alpha_{m}, \\alpha_{\\lambda})$ 并计算重整化的有限余项 $F_{2}^{(1)}$、$F_{4}^{(1)}$ 和 $F_{4,\\mathrm{db}}^{(2)}$。\n- 在所有情况下均使用固定的极点系数 $c_{2} = \\tfrac{1}{2}$ 和 $c_{4} = 3$。\n- 所有返回的数值答案必须是实数，不需要物理单位。\n\n测试套件。\n\n对于以下每个测试用例，在应用指定的方案条件后，计算指定图形的重整化有限余项。您的程序必须嵌入这些测试用例，并以指定格式生成最终输出。\n\n- 测试 A (单圈四点, MS):\n  - 图：单圈四点子图，具有 $E = 4$, $L = 1$。\n  - 输入：$\\lambda = 0.1$, $f_{4} = 1.25$。\n  - 方案：最小减除 ($\\alpha_{\\lambda} = 0$)。\n  - 输出：单个数字 $F_{4}^{(1)} = \\lambda^{2}\\left(f_{4} - \\alpha_{\\lambda}\\right)$。\n- 测试 B (单圈两点, 自定义有限质量平移):\n  - 图：单圈两点子图，具有 $E = 2$, $L = 1$。\n  - 输入：$\\lambda = 0.2$, $m^{2} = 2.0$, $f_{2} = 0.5$，并有自定义有限选择 $\\alpha_{m} = 0.75$。\n  - 方案：自定义有限质量平移。\n  - 输出：单个数字 $F_{2}^{(1)} = \\lambda\\, m^{2}\\left(f_{2} - \\alpha_{m}\\right)$。\n- 测试 C (双圈四点双气泡, 类MOM条件):\n  - 图：双圈四点双气泡图，具有两个相同的单圈四点子发散，整体 $E = 4$, $L = 2$。\n  - 输入：$\\lambda = 0.3$, $f_{4} = 0.8$。\n  - 方案：MOM4\\_ZERO，即选择 $\\alpha_{\\lambda} = f_{4}$。\n  - 输出：单个数字 $F_{4,\\mathrm{db}}^{(2)} = \\lambda^{3}\\left(f_{4} - \\alpha_{\\lambda}\\right)^{2}$。\n- 测试 D (单圈四点, 自定义有限耦合平移):\n  - 图：单圈四点子图，具有 $E = 4$, $L = 1$。\n  - 输入：$\\lambda = 0.5$, $f_{4} = 0.2$，并有自定义有限选择 $\\alpha_{\\lambda} = -0.5$。\n  - 方案：自定义有限耦合平移。\n  - 输出：单个数字 $F_{4}^{(1)} = \\lambda^{2}\\left(f_{4} - \\alpha_{\\lambda}\\right)$。\n\n最终输出格式。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。输出的顺序必须遵循测试 A、B、C、D。例如，包含四个结果的输出行应如下所示\n`[xA,xB,xC,xD]`。\n每个 $x$ 都必须是标准表示法的浮点小数（不要求使用科学记数法，但标准的 Python 格式是可接受的）。",
            "solution": "目标是设计一种算法和实现，将与方案无关的紫外减除与依赖于方案的有限选择分离开来。其物理基础是标量 $\\phi^{4}$ 理论中的发散结构以及维数正规化中重整化的标准实践。我们将逐步解释设计过程，将原理映射到计算。\n\n基本原理。\n\n- 在 $d = 4 - 2\\epsilon$ 的维数正规化中，紫外发散表现为 $\\epsilon$ 的极点。在 $\\epsilon = 0$ 附近的洛朗展开是其规范的解析表示。对消项必须抵消这些极点以使振幅有限。\n- 在 $\\phi^{4}$ 理论中，幂次计数给出具有 $E$ 条外腿的连通子图的表观发散度为 $\\omega = 4 - E$。这一事实源于圈、内线和顶点之间的一般关系（拓扑恒等式），并且是四维可重整化理论中一个经过充分检验的特性。因此，具有 $E \\in \\{0,2,4\\}$ 的子图可能发散，而 $E \\ge 6$ 的子图是表观收敛的。\n- Bogoliubov-Parasiuk-Hepp-Zimmermann (BPHZ) 森林公式指示我们，在减去任何整体发散之前，必须先减去所有的子发散（由发散子图的森林编码）。在维数正规化中，最小减除只移除极点部分，而其他方案也会调整有限部分。因此，一个与方案无关的阶段可以通过局域性和幂次计数唯一地确定极点部分，将有限部分作为符号参数留待以后确定。\n\n玩具振幅模型及其理由。\n\n我们局限于一个最小但结构上忠实的图拓扑集合，并使用已知的单圈系数作为极点项：\n\n- 单圈两点原初图（类蝌蚪图）：\n  $$A_{2}^{(1)}(\\lambda, m^{2}) = \\lambda\\, m^{2}\\left(\\frac{c_{2}}{\\epsilon} + f_{2}\\right),\\quad c_{2} = \\frac{1}{2}.$$\n  系数 $c_{2} = \\tfrac{1}{2}$ 与 $\\lambda \\phi^{4}/4!$ 理论中蝌蚪图积分乘以对称因子的标准归一化一致，这在我们的单位制吸收了一个常规的 $(16\\pi^{2})^{-1}$ 因子后是成立的。有限余项 $f_{2}$ 取决于重整化标度和运动学，我们将其视为一个提供的输入数值。\n- 单圈四点原初图（单个气泡图）：\n  $$A_{4}^{(1)}(\\lambda) = \\lambda^{2}\\left(\\frac{c_{4}}{\\epsilon} + f_{4}\\right),\\quad c_{4} = 3.$$\n  因子 $c_{4} = 3$ 编码了对 $s$、$t$ 和 $u$ 三个通道的求和，这是 $\\phi^{4}$ 理论中单圈四点函数的典型特征，同样，其归一化方式吸收了普适常数。有限余项 $f_{4}$ 作为输入提供。\n- 双圈四点双气泡复合图：\n  $$A_{4,\\mathrm{db}}^{(2)}(\\lambda) = \\lambda^{3}\\left(\\frac{c_{4}}{\\epsilon} + f_{4}\\right)^{2}.$$\n  这个复合图包含两个相同的单圈四点子发散子图。在严格的场论计算中，除了子发散之外，还可能存在整体发散；然而，我们的玩具模型专注于局域子发散减除的算法执行，并将在所有子发散被移除后将剩余部分视为有限。\n\n与方案无关的对消项构造。\n\n对于一个标记的紫外发散子图，我们引入一个对消项，它移除其极点和一个未定的有限部分。与方案无关的对消项是\n\n- 单圈两点：\n  $$\\delta m^{2} = -\\lambda\\, m^{2}\\left(\\frac{c_{2}}{\\epsilon} + \\alpha_{m}\\right),$$\n  其中 $\\alpha_{m}$ 是一个稍后设定的方案参数。\n- 单圈四点：\n  $$\\delta \\lambda = -\\lambda^{2}\\left(\\frac{c_{4}}{\\epsilon} + \\alpha_{\\lambda}\\right),$$\n  其中 $\\alpha_{\\lambda}$ 是一个稍后设定的方案参数。\n\n减去子发散后，得到原初图的重整化有限余项：\n\n- 单圈两点重整化有限余项：\n  $$F_{2}^{(1)} = \\lambda\\, m^{2}\\left(f_{2} - \\alpha_{m}\\right).$$\n- 单圈四点重整化有限余项：\n  $$F_{4}^{(1)} = \\lambda^{2}\\left(f_{4} - \\alpha_{\\lambda}\\right).$$\n\n对于双圈双气泡图，减去每个相同的单圈四点子发散后得到\n\n$$F_{4,\\mathrm{db}}^{(2)} = \\lambda^{3}\\left(f_{4} - \\alpha_{\\lambda}\\right)^{2}.$$\n\n这在我们的模型中实现了针对子发散的 $R'$-操作（森林减除）。\n\n后处理层（方案固定）。\n\n有限参数 $(\\alpha_{m}, \\alpha_{\\lambda})$ 通过后处理条件来设定：\n\n- 最小减除 (MS)：只移除极点，因此\n  $$\\alpha_{m} = 0,\\quad \\alpha_{\\lambda} = 0.$$\n- 自定义有限平移：对 $(\\alpha_{m}, \\alpha_{\\lambda})$ 的任何子集使用用户指定的值，并将未指定的参数默认为 0。\n- 针对单圈四点函数的类动量减除条件 (MOM4\\_ZERO)：通过设置以下条件来强制单圈四点重整化修正在选定的运动学点上为零\n  $$\\alpha_{\\lambda} = f_{4},\\quad \\alpha_{m} = 0.$$\n\n算法步骤。\n\n1) 对于给定的图，识别所有 $L \\ge 1$ 且 $E \\in \\{2,4\\}$ 的子图，并使用 $\\omega = 4 - E \\ge 0$ 将它们标记为紫外发散。\n2) 建立一个中间表示，其中每个标记子图的振幅表示为一个序对 $(\\text{极点系数}, \\text{有限余项})$，连同其类型（$E=2$ 或 $E=4$），并附加一个相应的有限方案参数 $\\alpha_{m}$ 或 $\\alpha_{\\lambda}$。\n3) 应用 $R'$-操作：将每个原初子图替换为其重整化的有限余项 $f - \\alpha$，对于双气泡复合图，使用乘积结构 $\\lambda^{3}(f_{4} - \\alpha_{\\lambda})^{2}$。\n4) 在后处理中，根据所选方案评估 $(\\alpha_{m}, \\alpha_{\\lambda})$ 并计算最终的数值。\n\n在测试套件上进行验证。\n\n- 测试 A：\n  输入：$\\lambda = 0.1$, $f_{4} = 1.25$，MS 方案所以 $\\alpha_{\\lambda} = 0$。\n  $$F_{4}^{(1)} = \\lambda^{2}\\left(f_{4} - \\alpha_{\\lambda}\\right) = (0.1)^{2} \\times (1.25 - 0) = 0.0125.$$\n- 测试 B：\n  输入：$\\lambda = 0.2$, $m^{2} = 2.0$, $f_{2} = 0.5$，自定义 $\\alpha_{m} = 0.75$。\n  $$F_{2}^{(1)} = \\lambda\\, m^{2}\\left(f_{2} - \\alpha_{m}\\right) = 0.2 \\times 2.0 \\times (0.5 - 0.75) = -0.1.$$\n- 测试 C：\n  输入：$\\lambda = 0.3$, $f_{4} = 0.8$，MOM4\\_ZERO 方案所以 $\\alpha_{\\lambda} = f_{4} = 0.8$。\n  $$F_{4,\\mathrm{db}}^{(2)} = \\lambda^{3}\\left(f_{4} - \\alpha_{\\lambda}\\right)^{2} = (0.3)^{3} \\times 0^{2} = 0.$$\n- 测试 D：\n  输入：$\\lambda = 0.5$, $f_{4} = 0.2$，自定义 $\\alpha_{\\lambda} = -0.5$。\n  $$F_{4}^{(1)} = \\lambda^{2}\\left(f_{4} - \\alpha_{\\lambda}\\right) = (0.5)^{2} \\times (0.2 - (-0.5)) = 0.25 \\times 0.7 = 0.175.$$\n\n因此，程序应生成单个输出行：\n$$[0.0125,-0.1,0.0,0.175].$$\n\n下面的实现完成了这些步骤，包括对指定测试的显式标记、中间表示、方案解析和求值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Constants for pole coefficients in the toy model\nC2 = 0.5  # c2 for one-loop 2-point primitive\nC4 = 3.0  # c4 for one-loop 4-point primitive\n\n# Enumerations for clarity\nE_TWO_POINT = 2\nE_FOUR_POINT = 4\n\nclass Subgraph:\n    \"\"\"\n    Represents a subgraph with given external legs (E),\n    loop order (L), and a type tag for behavior.\n    \"\"\"\n    def __init__(self, E: int, L: int, tag: str):\n        self.E = E\n        self.L = L\n        self.tag = tag  # 'G2_1L', 'G4_1L'\n\n    def superficial_degree(self) - int:\n        # omega = 4 - E in phi^4 theory in 4D\n        return 4 - self.E\n\n    def is_uv_divergent(self) - bool:\n        # UV divergent if omega = 0 and L = 1\n        return (self.superficial_degree() = 0) and (self.L = 1)\n\nclass Graph:\n    \"\"\"\n    Represents a graph topology with possible subdivergences.\n    type_tag: 'G2_1L', 'G4_1L', 'G4_2L_db'\n    subgraphs: list of Subgraph (for tagging)\n    \"\"\"\n    def __init__(self, type_tag: str, subgraphs):\n        self.type_tag = type_tag\n        self.subgraphs = subgraphs\n\n    def tag_uv_subgraphs(self):\n        # Return list of indices (or subgraphs) that are UV-divergent\n        tags = []\n        for sg in self.subgraphs:\n            if sg.is_uv_divergent():\n                tags.append(sg)\n        return tags\n\ndef scheme_postprocess(scheme: str, params: dict) - dict:\n    \"\"\"\n    Given a scheme name and input parameters, determine the finite scheme parameters alpha_m and alpha_lam.\n    - scheme 'MS': alpha_m = 0, alpha_lam = 0\n    - scheme 'CUSTOM': read alpha_m and alpha_lam from params if present, else default 0\n    - scheme 'MOM4_ZERO': alpha_lam = f4, alpha_m = 0 (unless provided)\n    \"\"\"\n    alpha_m = 0.0\n    alpha_lam = 0.0\n    scheme_upper = scheme.upper()\n    if scheme_upper == 'MS':\n        alpha_m = 0.0\n        alpha_lam = 0.0\n    elif scheme_upper == 'CUSTOM':\n        alpha_m = float(params.get('alpha_m', 0.0))\n        alpha_lam = float(params.get('alpha_lam', 0.0))\n    elif scheme_upper == 'MOM4_ZERO':\n        # Enforce one-loop 4-point correction to vanish: alpha_lam = f4\n        if 'f4' not in params:\n            raise ValueError(\"MOM4_ZERO scheme requires parameter 'f4'.\")\n        alpha_lam = float(params['f4'])\n        alpha_m = float(params.get('alpha_m', 0.0))\n    else:\n        raise ValueError(f\"Unknown scheme: {scheme}\")\n    return {'alpha_m': alpha_m, 'alpha_lam': alpha_lam}\n\ndef evaluate_graph(graph: Graph, params: dict, scheme: str) - float:\n    \"\"\"\n    Evaluate the renormalized finite remainder of the graph under the specified scheme.\n    Uses the toy amplitude model and R'-operation for subdivergences.\n    \"\"\"\n    # Determine finite scheme parameters\n    alphas = scheme_postprocess(scheme, params)\n    alpha_m = alphas['alpha_m']\n    alpha_lam = alphas['alpha_lam']\n\n    # Tagging step (for completeness; not directly used in arithmetic except to validate)\n    uv_tags = graph.tag_uv_subgraphs()\n    # Proceed with evaluation based on topology\n    lam = float(params.get('lambda', 0.0))\n    if graph.type_tag == 'G4_1L':\n        # Requires f4\n        f4 = float(params['f4'])\n        # Finite remainder after counterterm: lam^2 * (f4 - alpha_lam)\n        result = lam**2 * (f4 - alpha_lam)\n        return float(result)\n    elif graph.type_tag == 'G2_1L':\n        # Requires f2 and m2\n        f2 = float(params['f2'])\n        m2 = float(params['m2'])\n        # Finite remainder after counterterm: lam * m2 * (f2 - alpha_m)\n        result = lam * m2 * (f2 - alpha_m)\n        return float(result)\n    elif graph.type_tag == 'G4_2L_db':\n        # Requires f4\n        f4 = float(params['f4'])\n        # Two identical one-loop 4-pt subdivergences, R'-subtracted:\n        # Finite remainder: lam^3 * (f4 - alpha_lam)^2\n        result = lam**3 * (f4 - alpha_lam)**2\n        return float(result)\n    else:\n        raise ValueError(f\"Unknown graph type: {graph.type_tag}\")\n\ndef build_graph(type_tag: str) - Graph:\n    \"\"\"\n    Construct a Graph instance with appropriate subgraphs for tagging purposes.\n    \"\"\"\n    if type_tag == 'G4_1L':\n        # One primitive 4-point one-loop subgraph\n        subgraphs = [Subgraph(E=E_FOUR_POINT, L=1, tag='G4_1L')]\n    elif type_tag == 'G2_1L':\n        # One primitive 2-point one-loop subgraph\n        subgraphs = [Subgraph(E=E_TWO_POINT, L=1, tag='G2_1L')]\n    elif type_tag == 'G4_2L_db':\n        # Two identical one-loop 4-point subdivergences\n        subgraphs = [\n            Subgraph(E=E_FOUR_POINT, L=1, tag='G4_1L'),\n            Subgraph(E=E_FOUR_POINT, L=1, tag='G4_1L'),\n        ]\n    else:\n        subgraphs = []\n    return Graph(type_tag=type_tag, subgraphs=subgraphs)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (graph_type, params dict, scheme string)\n    test_cases = [\n        # Test A: one-loop 4-point, MS\n        ('G4_1L', {'lambda': 0.1, 'f4': 1.25}, 'MS'),\n        # Test B: one-loop 2-point, custom alpha_m\n        ('G2_1L', {'lambda': 0.2, 'm2': 2.0, 'f2': 0.5, 'alpha_m': 0.75}, 'CUSTOM'),\n        # Test C: two-loop 4-point double-bubble, MOM4_ZERO\n        ('G4_2L_db', {'lambda': 0.3, 'f4': 0.8}, 'MOM4_ZERO'),\n        # Test D: one-loop 4-point, custom alpha_lam\n        ('G4_1L', {'lambda': 0.5, 'f4': 0.2, 'alpha_lam': -0.5}, 'CUSTOM'),\n    ]\n\n    results = []\n    for gtype, params, scheme in test_cases:\n        graph = build_graph(gtype)\n        res = evaluate_graph(graph, params, scheme)\n        # Ensure standard float formatting (not scientific) where reasonable\n        # Convert small -0.0 to 0.0\n        if abs(res) == 0.0:\n            res = 0.0\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    # Join without spaces, Python default str(float) formatting\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}