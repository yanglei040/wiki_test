{
    "hands_on_practices": [
        {
            "introduction": "Before matrix elements for different jet multiplicities can be consistently combined, we must first establish a clear definition of what constitutes a \"jet\" at the parton level. This is achieved by applying a sequential recombination algorithm, which reconstructs a plausible branching history for a given set of final-state partons. This exercise provides foundational practice in implementing the longitudinally invariant $k_T$ algorithm, a cornerstone of modern jet physics, to generate the ordered sequence of momentum scales that are essential for procedures like CKKW merging. ",
            "id": "3522316",
            "problem": "You are given four massless partons in each test case, specified by transverse momentum $p_T$ in $\\mathrm{GeV}$, rapidity $y$ (dimensionless), and azimuthal angle $\\phi$ in radians. Starting from these input momenta, your task is to implement the longitudinally invariant $k_T$ jet algorithm to compute the full clustering sequence and to reconstruct the ordered branching history required for Catani–Krauss–Kuhn–Webber (CKKW) merging. Use an $E$-scheme recombination (four-vector addition) when merging two pseudo-particles. The angle unit is radians, and all momentum-related quantities should be in $\\mathrm{GeV}$. The jet radius parameter is fixed to $R=0.6$.\n\nFundamental definitions to be used:\n- For each pseudo-particle $i$, define its transverse momentum $p_{T,i} = \\sqrt{p_{x,i}^2 + p_{y,i}^2}$, azimuth $\\phi_i = \\mathrm{atan2}(p_{y,i}, p_{x,i})$, and rapidity $y_i = \\frac{1}{2}\\ln\\left(\\frac{E_i + p_{z,i}}{E_i - p_{z,i}}\\right)$.\n- The pairwise distance for the longitudinally invariant $k_T$ algorithm with parameter $p=1$ is\n$$\nd_{ij} = \\min\\left(p_{T,i}^2,\\, p_{T,j}^2\\right)\\,\\frac{\\Delta R_{ij}^2}{R^2},\n$$\nwhere $\\Delta R_{ij}^2 = (y_i - y_j)^2 + \\Delta\\phi_{ij}^2$ and $\\Delta\\phi_{ij}$ is taken in $[-\\pi,\\pi]$ via standard wrapping.\n- The beam distance is\n$$\nd_{iB} = p_{T,i}^2.\n$$\n- At each iteration, identify the smallest distance among all $\\{d_{ij}\\}$ and $\\{d_{iB}\\}$. If the minimum is $d_{ij}$, merge $i$ and $j$ using four-vector addition $(E, \\vec{p}) \\rightarrow (E_i + E_j, \\vec{p}_i + \\vec{p}_j)$ and record this merge event. If the minimum is $d_{iB}$, declare $i$ a final jet and remove it without recording a merge event.\n- Continue until no pseudo-particles remain.\n- For the CKKW history, the branching scale associated with a merge of $i$ and $j$ is defined as $k_T = \\sqrt{d_{ij}}$. Order the recorded merges by descending $k_T$ and provide the branching history as an ordered list.\n\nRepresent each merge event by a list $[\\,[\\text{orig}_i],\\,[\\text{orig}_j],\\,k_T\\,]$, where $[\\text{orig}_i]$ and $[\\text{orig}_j]$ are lists of original parton indices (starting at $0$ for the first parton in each test case) contained in the two merging clusters, and $k_T$ is a floating-point number. Order the merge events by descending $k_T$. If no merges occur, return an empty list for that test case. Express all $k_T$ values rounded to $6$ decimal places. Angles must be in radians, and all momentum components must be in $\\mathrm{GeV}$. For massless partons, construct the input four-vectors via\n$$\nE = p_T\\,\\cosh(y),\\quad p_x = p_T\\cos(\\phi),\\quad p_y = p_T\\sin(\\phi),\\quad p_z = p_T\\,\\sinh(y).\n$$\n\nTest Suite (each test case is a list of four triples $(p_T, y, \\phi)$):\n- Test Case $1$ (general clustering behavior):\n  $[(50.0,\\,0.1,\\,0.0),\\,(48.0,\\,0.12,\\,0.15),\\,(40.0,\\,1.5,\\,2.0),\\,(30.0,\\,-1.2,\\,-2.5)]$.\n- Test Case $2$ (azimuthal wrapping near $\\pm\\pi$):\n  $[(35.0,\\,0.0,\\,3.10),\\,(33.0,\\,0.0,\\,-3.08),\\,(20.0,\\,0.5,\\,1.0),\\,(10.0,\\,-0.5,\\,-1.0)]$.\n- Test Case $3$ (soft particle immediately becoming a jet via beam distance):\n  $[(100.0,\\,0.0,\\,0.5),\\,(80.0,\\,0.3,\\,-0.2),\\,(5.0,\\,2.0,\\,1.0),\\,(60.0,\\,-1.0,\\,2.0)]$.\n- Test Case $4$ (nearly collinear soft pair):\n  $[(15.0,\\,0.2,\\,0.2),\\,(14.0,\\,0.201,\\,0.201),\\,(50.0,\\,-2.0,\\,0.5),\\,(45.0,\\,2.0,\\,-0.5)]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in the same order as above. Each element must be the ordered list of merge events for that test case as specified. For example, a valid output for four test cases has the form\n$[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$,\nwhere each inner list is the ordered branching history of the corresponding test case. No additional text should be printed.",
            "solution": "The problem is valid and requires the implementation of the longitudinally invariant $k_T$ jet clustering algorithm to determine the CKKW merging history for sets of four massless partons. The solution is structured as a step-by-step algorithmic procedure, followed by a Python implementation.\n\n**Principle-Based Algorithmic Design**\n\nThe core of the solution is an iterative algorithm that progressively groups an initial list of partons into jets. The process is governed by a distance measure that determines which particles are \"closest\" in momentum space at each step.\n\n**1. State Representation: Pseudo-Particles**\nWe begin by defining a computational representation for each parton or intermediate cluster, which we term a \"pseudo-particle\". Each pseudo-particle object encapsulates two key pieces of information:\n- Its four-momentum, $P^\\mu = (E, p_x, p_y, p_z)$, stored as a $4$-component vector. All subsequent kinematic properties are derived from this.\n- A list of the original, $0$-indexed partons that have been merged to form this pseudo-particle.\n\nInitially, for each input parton $i$ with kinematics $(p_{T,i}, y_i, \\phi_i)$, we construct its four-momentum using the relations for a massless particle:\n$$\nE_i = p_{T,i}\\,\\cosh(y_i)\n$$\n$$\np_{x,i} = p_{T,i}\\cos(\\phi_i)\n$$\n$$\np_{y,i} = p_{T,i}\\sin(\\phi_i)\n$$\n$$\np_{z,i} = p_{T,i}\\,\\sinh(y_i)\n$$\nThis creates the initial set of pseudo-particles, each object containing a single original parton index. From the four-momentum $P^\\mu=(E, p_x, p_y, p_z)$ of any pseudo-particle, its transverse momentum $p_T$, rapidity $y$, and azimuth $\\phi$ are re-calculated as needed:\n$$\np_T = \\sqrt{p_x^2 + p_y^2}\n$$\n$$\ny = \\frac{1}{2}\\ln\\left(\\frac{E + p_z}{E - p_z}\\right)\n$$\n$$\n\\phi = \\mathrm{atan2}(p_y, p_x)\n$$\n\n**2. The Iterative Clustering Loop**\nThe algorithm proceeds in a loop that continues until the list of active pseudo-particles is empty. In each iteration, a single decision is made based on a set of calculated distances.\n\n**2a. Distance Calculations**\nTwo types of distances are computed for the current set of $N$ pseudo-particles:\n- **Pairwise Distances ($d_{ij}$)**: For every unique pair of pseudo-particles $(i, j)$, a distance is calculated. This metric quantifies their separation in momentum space. For the longitudinally invariant $k_T$ algorithm with parameter $p=1$, the formula is:\n$$\nd_{ij} = \\min\\left(p_{T,i}^2,\\, p_{T,j}^2\\right)\\,\\frac{\\Delta R_{ij}^2}{R^2}\n$$\nwhere $R=0.6$ is the jet radius parameter, and $\\Delta R_{ij}^2$ is the squared separation in the rapidity-azimuth plane:\n$$\n\\Delta R_{ij}^2 = (y_i - y_j)^2 + (\\Delta\\phi_{ij})^2\n$$\nThe azimuthal angle difference, $\\Delta\\phi_{ij} = \\phi_i - \\phi_j$, must be carefully handled to respect its periodic nature, ensuring it lies in the interval $[-\\pi, \\pi]$.\n\n- **Beam Distances ($d_{iB}$)**: For each pseudo-particle $i$, a beam distance is calculated. This metric represents the \"hardness\" of the particle and its propensity to be an independent jet rather than part of a larger one. It is defined as:\n$$\nd_{iB} = p_{T,i}^2\n$$\n\n**2b. Finding the Minimum Distance**\nAfter computing all $N(N-1)/2$ pairwise distances $\\{d_{ij}\\}$ and all $N$ beam distances $\\{d_{iB}\\}$, the algorithm identifies the global minimum value, $d_{\\min} = \\min(\\min_{\\{i,j\\}} d_{ij}, \\min_k d_{kB})$.\n\n**2c. Action: Merge or Finalize**\nThe action taken depends on whether $d_{\\min}$ was a pairwise distance or a beam distance:\n- **If $d_{\\min} = d_{ij}$ (Pair Merge):** This indicates that particles $i$ and $j$ are the closest pair. They are merged into a new, single pseudo-particle.\n    - **Recombination:** The $E$-scheme recombination rule dictates that the four-momenta are summed: $P_{new}^\\mu = P_i^\\mu + P_j^\\mu$. The list of original parton indices is concatenated: $\\text{orig}_{new} = \\text{orig}_i \\cup \\text{orig}_j$.\n    - **Recording:** This merge event is a branching in the CKKW history. We record it as a triplet $[\\,[\\text{orig}_i],\\,[\\text{orig}_j],\\,k_T\\,]$, where $[\\text{orig}_i]$ and $[\\text{orig}_j]$ are the sorted lists of original indices and $k_T = \\sqrt{d_{ij}}$ is the characteristic transverse momentum scale of the splitting.\n    - **State Update:** Particles $i$ and $j$ are removed from the active list, and the new merged particle is added.\n\n- **If $d_{\\min} = d_{iB}$ (Finalize Jet):** This indicates that particle $i$ is \"harder\" (i.e., has a larger $p_T^2$) than it is \"close\" to any other particle. It is therefore declared a final-state jet.\n    - **State Update:** The particle $i$ is removed from the active list. No merge event is recorded for this action.\n\n**3. Termination and Output Generation**\nThe loop terminates when no pseudo-particles remain. The final step is to prepare the output. The collected list of merge events is sorted in descending order of the branching scale $k_T$. This sorted list represents the CKKW branching history, showing the sequence of splittings from the hardest to the softest. The $k_T$ values in the final output are rounded to $6$ decimal places as specified. If no merges occurred throughout the process (e.g., all initial partons were immediately declared as jets), an empty list is returned for that test case.",
            "answer": "```python\nimport numpy as np\n\nclass PseudoParticle:\n    \"\"\"A class to represent a pseudo-particle in the jet clustering process.\"\"\"\n    def __init__(self, E, px, py, pz, original_indices):\n        \"\"\"\n        Initializes a pseudo-particle with its 4-momentum and original parton indices.\n        \n        Args:\n            E (float): Energy.\n            px (float): Momentum in x-direction.\n            py (float): Momentum in y-direction.\n            pz (float): Momentum in z-direction.\n            original_indices (list[int]): List of 0-indexed original partons.\n        \"\"\"\n        self.four_vector = np.array([E, px, py, pz], dtype=np.float64)\n        # Keep original indices sorted for canonical representation\n        self.original_indices = sorted(original_indices)\n        self.update_kinematics()\n\n    def update_kinematics(self):\n        \"\"\"Calculates pT, rapidity (y), and azimuth (phi) from the 4-momentum.\"\"\"\n        E, px, py, pz = self.four_vector\n        self.pT = np.sqrt(px**2 + py**2)\n        \n        if self.pT < 1e-12: # Effectively zero transverse momentum\n            self.phi = 0.0\n            # Rapidity is singular for massless particles with pT=0.\n            # Handle this case, although unlikely with E-scheme recombination.\n            if abs(E - abs(pz)) < 1e-9:\n                self.y = np.sign(pz) * 1e9 if pz != 0 else 0.0\n            else:\n                self.y = 0.5 * np.log((E + pz) / (E - pz))\n        else:\n            self.phi = np.arctan2(py, px)\n            # This formula is robust for massive particles (E-pz > 0 for E^2 > p^2)\n            self.y = 0.5 * np.log((E + pz) / (E - pz))\n\ndef run_kt_algorithm(initial_partons_data, R):\n    \"\"\"\n    Implements the longitudinally invariant kt jet algorithm.\n\n    Args:\n        initial_partons_data (list[tuple]): List of (pT, y, phi) for each initial parton.\n        R (float): The jet radius parameter.\n\n    Returns:\n        list: The ordered list of merge events, sorted by descending kT.\n    \"\"\"\n    particles = []\n    for i, (pT, y, phi) in enumerate(initial_partons_data):\n        E = pT * np.cosh(y)\n        px = pT * np.cos(phi)\n        py = pT * np.sin(phi)\n        pz = pT * np.sinh(y)\n        particles.append(PseudoParticle(E, px, py, pz, [i]))\n\n    merges = []\n    R2 = R**2\n\n    while particles:\n        num_particles = len(particles)\n        if num_particles == 0:\n            break\n\n        min_dist = float('inf')\n        min_type = None\n        min_indices = None\n\n        # Calculate pairwise distances (d_ij)\n        for i in range(num_particles):\n            for j in range(i + 1, num_particles):\n                p_i, p_j = particles[i], particles[j]\n                \n                delta_y = p_i.y - p_j.y\n                delta_phi = p_i.phi - p_j.phi\n                # Wrap delta_phi to the range [-pi, pi]\n                delta_phi = (delta_phi + np.pi) % (2 * np.pi) - np.pi\n                \n                delta_R2 = delta_y**2 + delta_phi**2\n                d_ij = min(p_i.pT**2, p_j.pT**2) * delta_R2 / R2\n\n                if d_ij < min_dist:\n                    min_dist = d_ij\n                    min_type = 'pair'\n                    min_indices = (i, j)\n        \n        # Calculate beam distances (d_iB)\n        for i in range(num_particles):\n            d_iB = particles[i].pT**2\n            if d_iB < min_dist:\n                min_dist = d_iB\n                min_type = 'beam'\n                min_indices = (i,)\n\n        # Perform the action corresponding to the minimum distance\n        if min_type == 'pair':\n            i, j = min_indices\n            \n            # Ensure i < j for easier list removal\n            if i > j: i, j = j, i\n            \n            p_i, p_j = particles[i], particles[j]\n\n            # Record the merge event for CKKW history\n            kT = np.sqrt(min_dist)\n            orig_i, orig_j = p_i.original_indices, p_j.original_indices\n            \n            # Ensure canonical ordering of original index lists for deterministic output\n            if orig_i > orig_j: orig_i, orig_j = orig_j, orig_i\n            \n            merges.append([orig_i, orig_j, kT])\n\n            # Merge particles using E-scheme recombination (4-vector addition)\n            new_4vec = p_i.four_vector + p_j.four_vector\n            new_orig_indices = p_i.original_indices + p_j.original_indices\n            new_particle = PseudoParticle(new_4vec[0], new_4vec[1], new_4vec[2], new_4vec[3], new_orig_indices)\n\n            # Remove old particles (higher index first) and add the new one\n            del particles[j]\n            del particles[i]\n            particles.append(new_particle)\n            \n        elif min_type == 'beam':\n            i = min_indices[0]\n            del particles[i] # Declare particle as a jet and remove\n        elif num_particles == 1: # Handle the last remaining particle\n            del particles[0]\n        else: # Should not occur\n            break\n\n    # Sort merges by k_T in descending order\n    merges.sort(key=lambda x: x[2], reverse=True)\n    \n    # Format the final list with rounded k_T\n    formatted_merges = [[m[0], m[1], round(m[2], 6)] for m in merges]\n        \n    return formatted_merges\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final result.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        [(50.0, 0.1, 0.0), (48.0, 0.12, 0.15), (40.0, 1.5, 2.0), (30.0, -1.2, -2.5)],\n        # Test Case 2\n        [(35.0, 0.0, 3.10), (33.0, 0.0, -3.08), (20.0, 0.5, 1.0), (10.0, -0.5, -1.0)],\n        # Test Case 3\n        [(100.0, 0.0, 0.5), (80.0, 0.3, -0.2), (5.0, 2.0, 1.0), (60.0, -1.0, 2.0)],\n        # Test Case 4\n        [(15.0, 0.2, 0.2), (14.0, 0.201, 0.201), (50.0, -2.0, 0.5), (45.0, 2.0, -0.5)],\n    ]\n    \n    JET_RADIUS = 0.6\n    \n    all_results = []\n    for case in test_cases:\n        result = run_kt_algorithm(case, JET_RADIUS)\n        all_results.append(result)\n    \n    # Convert the list of results to a string, removing spaces for a compact format.\n    final_output_string = str(all_results).replace(\" \", \"\")\n    \n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "With a branching history established, the crucial step in merging is to seamlessly connect the fixed-order matrix element calculation with the all-orders resummation provided by the parton shower, ensuring no double-counting of radiation. This is accomplished through a \"vetoed shower,\" where emissions generated by the shower are accepted only if they fall below a certain merging scale, $t_{\\mathrm{merge}}$. This practice will guide you through a simplified, yet physically representative, model of this veto procedure, using the Sudakov form factor to calculate the probability that a matrix-element event survives the veto and is accepted into the final event sample. ",
            "id": "3522333",
            "problem": "You are given a simplified computational model to study the Catani-Krauss-Kuhn-Webber with Lönnblad variant (CKKW-L) merging for multi-jet processes. Consider proton-proton (pp) collisions producing a $Z$ boson plus two partons, denoted $pp \\to Z + 2$ partons. In the CKKW-L framework, each event from the matrix element generator is assigned clustering node scales, interpreted as shower starting scales for the colored legs. A vetoed parton shower is then performed from each node scale down to a merging scale, and events are rejected if any shower emission occurs with an evolution scale above the merging scale. Your task is to implement a program that computes, for specified event samples and merging scales, the fraction of events rejected by the CKKW-L veto.\n\nFundamental base and modeling assumptions:\n- Assume Quantum Chromodynamics (QCD) soft-collinear emissions with an evolution variable identified with a transverse-momentum-like scale $t$ (in $\\mathrm{GeV}$). The leading approximation to the emission rate per unit $\\ln t$ is modeled by\n$$ \\mathrm{d} \\mathcal{P} \\approx \\frac{\\alpha_s(t) \\, C}{\\pi} \\, \\frac{\\mathrm{d}t}{t}, $$\nwhere $C$ is a color factor. For quark legs, take $C = C_F = \\frac{4}{3}$.\n- Use one-loop running for the strong coupling with $n_f$ active flavors and the Landau pole at $\\Lambda_{\\mathrm{QCD}}$:\n$$ \\alpha_s(Q) = \\frac{4 \\pi}{\\beta_0 \\ln\\left(\\frac{Q^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)}, \\quad \\beta_0 = 11 - \\frac{2 n_f}{3}. $$\n- The no-emission probability (Sudakov form factor) between an upper scale $t_{\\mathrm{upper}}$ and a lower scale $t_{\\mathrm{lower}}$ is\n$$ \\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}}) = \\exp\\left(- \\int_{t_{\\mathrm{lower}}}^{t_{\\mathrm{upper}}} \\frac{\\alpha_s(t) \\, C}{\\pi} \\, \\frac{\\mathrm{d}t}{t} \\right). $$\nWith the above one-loop $\\alpha_s$, this integral yields the analytic expression\n$$ \\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}}) = \\left( \\frac{\\ln\\!\\left(\\frac{t_{\\mathrm{lower}}^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)}{\\ln\\!\\left(\\frac{t_{\\mathrm{upper}}^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)} \\right)^{\\frac{2 C}{\\beta_0}}, \\quad \\text{for } t_{\\mathrm{upper}} > t_{\\mathrm{lower}} > \\Lambda_{\\mathrm{QCD}}, $$\nand $\\Delta = 1$ if $t_{\\mathrm{upper}} \\le t_{\\mathrm{lower}}$.\n- For a $pp \\to Z + 2$ partons event, model two colored legs, each starting at its node scale $t_i$ (in $\\mathrm{GeV}$). The event is accepted by the vetoed shower if neither leg emits above the merging scale $t_{\\mathrm{merge}}$ (in $\\mathrm{GeV}$). In the simplified analytic model, the acceptance probability for the event is the product of Sudakov factors\n$$ P_{\\mathrm{acc}} = \\prod_{i=1}^{2} \\Delta(t_i, t_{\\mathrm{merge}}), \\quad \\text{with the convention } \\Delta(t_i, t_{\\mathrm{merge}}) = 1 \\text{ if } t_i \\le t_{\\mathrm{merge}}. $$\nThe rejection probability is $P_{\\mathrm{rej}} = 1 - P_{\\mathrm{acc}}$.\n- You must use $n_f = 5$, $\\Lambda_{\\mathrm{QCD}} = 0.2~\\mathrm{GeV}$, and $C = C_F = \\frac{4}{3}$ for all colored legs. All energy scales must be handled in $\\mathrm{GeV}$.\n\nYour program must compute, for each test case below, the fraction of events rejected by the CKKW-L veto:\n$$ R = \\frac{1}{N} \\sum_{e=1}^{N} \\left( 1 - \\prod_{i=1}^{2} \\Delta(t_{e,i}, t_{\\mathrm{merge}}) \\right), $$\nwhere $t_{e,i}$ are the node scales for leg $i$ in event $e$, and $N$ is the number of events in the sample for that test case.\n\nTest suite:\n- Test Case $1$ (happy path): merging scale $t_{\\mathrm{merge}} = 15~\\mathrm{GeV}$, sample of $N = 5$ events with node scales (in $\\mathrm{GeV}$):\n    - Event $1$: $[35.0, 25.0]$\n    - Event $2$: $[40.0, 18.0]$\n    - Event $3$: $[22.0, 21.0]$\n    - Event $4$: $[30.0, 16.0]$\n    - Event $5$: $[15.0, 50.0]$\n- Test Case $2$ (boundary conditions with equality and below-cut legs): merging scale $t_{\\mathrm{merge}} = 20~\\mathrm{GeV}$, sample of $N = 5$ events:\n    - Event $1$: $[20.0, 50.0]$\n    - Event $2$: $[20.0, 20.0]$\n    - Event $3$: $[25.0, 20.0]$\n    - Event $4$: $[21.0, 19.5]$\n    - Event $5$: $[100.0, 35.0]$\n- Test Case $3$ (near-infrared edge case with low merging scale): merging scale $t_{\\mathrm{merge}} = 0.5~\\mathrm{GeV}$, sample of $N = 5$ events:\n    - Event $1$: $[30.0, 25.0]$\n    - Event $2$: $[80.0, 60.0]$\n    - Event $3$: $[22.0, 21.0]$\n    - Event $4$: $[100.0, 35.0]$\n    - Event $5$: $[15.0, 50.0]$\n\nAnswer specification:\n- All computations must be in $\\mathrm{GeV}$.\n- For each test case, output the fraction $R$ as a float in the interval $[0, 1]$.\n- Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3]$, where each $r_i$ is the float result for the corresponding test case.",
            "solution": "The user-provided problem is valid. It is a well-posed, scientifically-grounded problem from the field of computational high-energy physics. All necessary data, constants, and formulas are provided, and there are no internal contradictions or ambiguities. The model, while simplified, is based on established principles of Quantum Chromodynamics (QCD), specifically the CKKW-L merging procedure.\n\nThe task is to compute the average rejection fraction, $R$, for several samples of simulated $pp \\to Z + 2$ parton events. The rejection fraction is the mean of the individual event rejection probabilities, $P_{\\mathrm{rej}, e}$, over a sample of $N$ events:\n$$ R = \\frac{1}{N} \\sum_{e=1}^{N} P_{\\mathrm{rej}, e} $$\nThe rejection of an event is governed by a vetoed parton shower. An event is accepted only if no parton emissions occur from its colored legs between their respective starting scales, $t_i$, and a common merging scale, $t_{\\mathrm{merge}}$. The probability of no emissions between two scales is given by the Sudakov form factor, $\\Delta$. For the specified process with $2$ colored legs starting at scales $t_1$ and $t_2$, the overall event acceptance probability is the product of the individual non-emission probabilities, assuming independent emissions:\n$$ P_{\\mathrm{acc}} = \\Delta(t_1, t_{\\mathrm{merge}}) \\cdot \\Delta(t_2, t_{\\mathrm{merge}}) $$\nThe rejection probability for a single event is therefore $P_{\\mathrm{rej}} = 1 - P_{\\mathrm{acc}}$.\n\nThe central component of this calculation is the Sudakov form factor, $\\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}})$. The problem provides its analytic expression, derived from a one-loop running of the strong coupling, $\\alpha_s(t)$:\n$$ \\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}}) = \\left( \\frac{\\ln\\left(\\frac{t_{\\mathrm{lower}}^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)}{\\ln\\left(\\frac{t_{\\mathrm{upper}}^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)} \\right)^{\\frac{2 C}{\\beta_0}} $$\nThis formula is applicable for the condition $t_{\\mathrm{upper}} > t_{\\mathrm{lower}} > \\Lambda_{\\mathrm{QCD}}$. As specified by the CKKW-L rules, if the starting scale $t_{\\mathrm{upper}}$ is already at or below the merging scale $t_{\\mathrm{lower}}$, the interval for showering is non-existent. In this case, no vetoable emissions can occur, and the non-emission probability is unity, i.e., $\\Delta = 1$ for $t_{\\mathrm{upper}} \\le t_{\\mathrm{lower}}$.\n\nTo implement the calculation, we first determine the numerical values of the required physical constants.\nThe number of active quark flavors is given as $n_f = 5$.\nThe QCD scale parameter is specified as $\\Lambda_{\\mathrm{QCD}} = 0.2~\\mathrm{GeV}$.\nThe color factor for a quark leg (the intended parton type here) is the Casimir invariant $C = C_F = \\frac{4}{3}$.\nUsing these inputs, we calculate the leading-order coefficient of the QCD beta function:\n$$ \\beta_0 = 11 - \\frac{2 n_f}{3} = 11 - \\frac{2 \\cdot 5}{3} = 11 - \\frac{10}{3} = \\frac{23}{3} $$\nThe exponent in the Sudakov formula can now be pre-computed as a single constant value:\n$$ \\frac{2 C}{\\beta_0} = \\frac{2 \\cdot \\frac{4}{3}}{\\frac{23}{3}} = \\frac{\\frac{8}{3}}{\\frac{23}{3}} = \\frac{8}{23} $$\nFor improved numerical stability and computational efficiency, the Sudakov formula can be simplified using the logarithmic property $\\ln(x^2) = 2 \\ln(x)$:\n$$ \\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}}) = \\left( \\frac{2 \\ln(t_{\\mathrm{lower}}/\\Lambda_{\\mathrm{QCD}})}{2 \\ln(t_{\\mathrm{upper}}/\\Lambda_{\\mathrm{QCD}})} \\right)^{\\frac{8}{23}} = \\left( \\frac{\\ln(t_{\\mathrm{lower}}/\\Lambda_{\\mathrm{QCD}})}{\\ln(t_{\\mathrm{upper}}/\\Lambda_{\\mathrm{QCD}})} \\right)^{\\frac{8}{23}} $$\nThis is the form that will be implemented.\n\nThe algorithmic procedure to solve the problem for each test case is as follows:\n$1$. For each test case, defined by a merging scale $t_{\\mathrm{merge}}$ and a sample of $N$ events, initialize a list to store the rejection probability of each event.\n$2$. Iterate through each event $e$ in the sample. Each event is described by two node scales, $t_{e,1}$ and $t_{e,2}$.\n$3$. For the current event, calculate its acceptance probability, $P_{\\mathrm{acc}, e}$.\n    a. For the first leg, calculate the Sudakov factor $\\Delta_1 = \\Delta(t_{e,1}, t_{\\mathrm{merge}})$. The calculation first checks if $t_{e,1} \\le t_{\\mathrm{merge}}$. If this condition is true, $\\Delta_1 = 1$. Otherwise, the analytic formula is used.\n    b. Similarly, for the second leg, calculate its Sudakov factor $\\Delta_2 = \\Delta(t_{e,2}, t_{\\mathrm{merge}})$.\n    c. The total acceptance probability for the event is the product of the factors for the independent legs: $P_{\\mathrm{acc}, e} = \\Delta_1 \\cdot \\Delta_2$.\n$4$. Calculate the event's rejection probability as $P_{\\mathrm{rej}, e} = 1 - P_{\\mathrm{acc}, e}$.\n$5$. Store this value, $P_{\\mathrm{rej}, e}$.\n$6$. After iterating through all $N$ events in the sample, the final rejection fraction $R$ for the test case is computed by taking the arithmetic mean of all stored $P_{\\mathrm{rej}, e}$ values.\n$7$. This procedure is repeated for all three test cases, and the resulting values of $R$ are collected for the final output.\n\nThis step-by-step logic is implemented in the provided Python program. A dedicated function calculates the Sudakov factor, correctly handling the boundary conditions. Another function orchestrates the calculation of the average rejection fraction for an entire event sample. The main `solve` function sets up the test case data, calls the calculation logic for each, and formats the results into the precise output string specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Define global constants based on the problem statement.\n# All scales are in GeV.\nLAMBDA_QCD = 0.2  # QCD scale parameter\nN_F = 5          # Number of active flavors\nC_F = 4.0 / 3.0  # Casimir color factor for quarks\n\n# Pre-calculate derived constants for efficiency.\nBETA_0 = 11.0 - (2.0 * N_F / 3.0)  # Leading-order beta function coefficient\nSUDOKOV_EXPONENT = (2.0 * C_F) / BETA_0   # Exponent for the Sudakov form factor\n\ndef sudakov(t_upper, t_lower):\n    \"\"\"\n    Calculates the Sudakov form factor (no-emission probability)\n    between an upper scale t_upper and a lower scale t_lower.\n\n    Args:\n        t_upper (float): The shower starting scale (node scale).\n        t_lower (float): The lower scale cutoff (merging scale).\n\n    Returns:\n        float: The no-emission probability Delta(t_upper, t_lower).\n    \"\"\"\n    # Per the CKKW-L convention, if the starting scale is at or below the\n    # merging scale, there is no phase space for a vetoable emission.\n    # The no-emission probability is therefore 1.\n    if t_upper <= t_lower:\n        return 1.0\n\n    # The analytic formula is valid for scales > Lambda_QCD. Here we apply\n    # the simplified and more numerically stable version of the formula.\n    log_arg_lower = t_lower / LAMBDA_QCD\n    log_arg_upper = t_upper / LAMBDA_QCD\n\n    base = np.log(log_arg_lower) / np.log(log_arg_upper)\n    \n    return base ** SUDOKOV_EXPONENT\n\ndef calculate_rejection_fraction(t_merge, event_sample):\n    \"\"\"\n    Calculates the average rejection fraction for a sample of events.\n\n    Args:\n        t_merge (float): The merging scale.\n        event_sample (list of lists of floats): A list of events, where each\n                                                event is a list of node scales.\n\n    Returns:\n        float: The average rejection fraction for the sample.\n    \"\"\"\n    rejection_probabilities = []\n    for node_scales in event_sample:\n        # For each event, calculate acceptance probability as the product of\n        # Sudakov factors for each of its two colored legs.\n        p_acc = 1.0\n        for t_node in node_scales:\n            p_acc *= sudakov(t_node, t_merge)\n        \n        # The rejection probability is 1 - acceptance probability.\n        p_rej = 1.0 - p_acc\n        rejection_probabilities.append(p_rej)\n    \n    # The rejection fraction is the average of rejection probabilities over the sample.\n    return np.mean(rejection_probabilities)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (merging_scale, list_of_events)\n    # Each event is a list of its node scales.\n    test_cases = [\n        (15.0, [\n            [35.0, 25.0],\n            [40.0, 18.0],\n            [22.0, 21.0],\n            [30.0, 16.0],\n            [15.0, 50.0]\n        ]),\n        (20.0, [\n            [20.0, 50.0],\n            [20.0, 20.0],\n            [25.0, 20.0],\n            [21.0, 19.5],\n            [100.0, 35.0]\n        ]),\n        (0.5, [\n            [30.0, 25.0],\n            [80.0, 60.0],\n            [22.0, 21.0],\n            [100.0, 35.0],\n            [15.0, 50.0]\n        ])\n    ]\n\n    results = []\n    for t_merge, event_sample in test_cases:\n        rejection_fraction = calculate_rejection_fraction(t_merge, event_sample)\n        results.append(rejection_fraction)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A correctly implemented merging algorithm must not only produce physically sensible distributions but also satisfy fundamental theoretical constraints, chief among them being unitarity—the conservation of total probability. This means the sum of all exclusive $n$-jet cross-sections must equal the total inclusive cross-section. This final exercise elevates the perspective from algorithmic mechanics to a high-level consistency check, allowing you to quantify how imperfections in the merging procedure can lead to a violation of unitarity within a controlled toy model. ",
            "id": "3522327",
            "problem": "Consider electron-positron annihilation into hadrons, $e^+ e^- \\to$ hadrons, at center-of-mass energy $Q$. In Quantum Chromodynamics (QCD), the exclusive $n$-jet rates at a given jet resolution or merging scale $Q_{\\text{cut}}$ can be modeled in the leading-logarithmic approximation (LLA) by treating emissions above $Q_{\\text{cut}}$ as a Poisson process with a mean number of emissions $\\lambda(Q,Q_{\\text{cut}})$ determined by the integrated strong coupling. In a unitary merging of multi-jet matrix elements (ME) with a parton shower (PS), the sum over all exclusive $n$-jet cross sections equals the total inclusive cross section. Your task is to demonstrate a unitarity check using a merged sample: sum exclusive $n$-jet rates over $n$ and compare to the total cross section (normalized to unity), and quantify deviations in a controlled toy model.\n\nFundamental definitions and assumptions:\n- Use Leading Logarithmic Approximation (LLA) with independent emissions and a Sudakov form factor for no-emission probabilities.\n- The number of resolvable emissions $m$ above $Q_{\\text{cut}}$ follows a Poisson distribution with mean $\\lambda$, and the exclusive $n$-jet final state corresponds to exactly $m = n - 2$ emissions.\n- Work with normalized cross sections, i.e., set the total inclusive cross section to $\\sigma_{\\text{tot}} = 1$ (dimensionless).\n- The mean number of emissions $\\lambda(Q,Q_{\\text{cut}})$ is defined by\n$$\n\\lambda(Q,Q_{\\text{cut}}) \\equiv \\frac{2 C_F}{\\pi} \\int_{Q_{\\text{cut}}}^{Q} \\frac{\\alpha_s(\\mu)}{\\mu} \\, d\\mu,\n$$\nwhere $C_F = \\frac{4}{3}$ is the quadratic Casimir for the fundamental representation of $\\mathrm{SU}(3)$ and the strong coupling $\\alpha_s(\\mu)$ follows one-loop running,\n$$\n\\alpha_s(\\mu) = \\frac{4\\pi}{\\beta_0 \\ln\\left(\\frac{\\mu^2}{\\Lambda^2}\\right)}, \\quad \\beta_0 = 11 - \\frac{2}{3} n_f, \\quad n_f = 5, \\quad \\Lambda = 0.2 \\ \\mathrm{GeV}.\n$$\nAssume $Q > Q_{\\text{cut}} > \\Lambda$ so that all logarithms are defined.\n\nExclusive probabilities:\n- The probability to have exactly $m$ emissions above $Q_{\\text{cut}}$ is\n$$\nP(m; \\lambda) = \\frac{e^{-\\lambda} \\lambda^m}{m!}.\n$$\n- The exclusive $n$-jet rate is $R_n = P(n-2; \\lambda)$, with $n \\ge 2$.\n\nMerged sample model:\n- Suppose matrix elements are merged up to a maximum of $N_{\\mathrm{ME}}$ jets. This means up to $m_{\\mathrm{ME}} = N_{\\mathrm{ME}} - 2$ emissions are corrected by ME-based reweighting, while $m > m_{\\mathrm{ME}}$ emissions remain described by the PS.\n- Model residual merging distortions by introducing a weight factor for the ME-corrected multiplicities:\n$$\nw(m) = 1 + \\varepsilon \\, g(m), \\quad \\text{for } m \\le m_{\\mathrm{ME}},\n$$\nand $w(m) = 1$ for $m > m_{\\mathrm{ME}}$. Here $\\varepsilon$ is a tunable real parameter controlling the distortion magnitude, and $g(m)$ is a fixed shape function that captures typical ME-PS tension patterns. Use the explicit functional form\n$$\ng(m) = \\exp\\!\\left(-\\frac{m}{m_0}\\right) - c, \\quad m_0 = 1.5, \\quad c = 0.4,\n$$\napplied only for $m \\le m_{\\mathrm{ME}}$ and $g(m)=0$ for $m > m_{\\mathrm{ME}}$.\n\nUnitarity check:\n- The merged exclusive sum $S$ is\n$$\nS(Q,Q_{\\text{cut}},N_{\\mathrm{ME}},\\varepsilon) = \\sum_{m=0}^{\\infty} P(m;\\lambda(Q,Q_{\\text{cut}})) \\, w(m).\n$$\n- Unitarity in the ideal limit implies $S = 1$. Define the fractional deviation (dimensionless) as\n$$\n\\Delta \\equiv S - 1.\n$$\n\nAlgorithmic requirements:\n- Compute $\\lambda(Q,Q_{\\text{cut}})$ using the integral above with one-loop running $\\alpha_s$, $C_F = \\frac{4}{3}$, $n_f = 5$, and $\\Lambda = 0.2 \\ \\mathrm{GeV}$.\n- Compute $P(m;\\lambda)$ for $m = 0,1,2,\\dots$ until the neglected tail $\\sum_{m=M_{\\max}+1}^{\\infty} P(m;\\lambda)$ is smaller than a tolerance $10^{-12}$; you may cap $M_{\\max}$ if needed.\n- Apply the merging weights $w(m)$ to obtain $S$ and then $\\Delta$.\n- Return $\\Delta$ rounded to $8$ decimal places as a decimal number (no percentage sign). All quantities are dimensionless.\n\nTest suite:\nProvide results for the following parameter sets $(Q, Q_{\\text{cut}}, N_{\\mathrm{ME}}, \\varepsilon)$, where energies are in $\\mathrm{GeV}$:\n- Case $1$: $(Q = 91.1876, Q_{\\text{cut}} = 5.0, N_{\\mathrm{ME}} = 6, \\varepsilon = 0.0)$, a \"happy path\" case with perfect unitarity expected.\n- Case $2$: $(Q = 91.1876, Q_{\\text{cut}} = 5.0, N_{\\mathrm{ME}} = 4, \\varepsilon = 0.5)$, moderate merging distortion in the low-multiplicity region.\n- Case $3$: $(Q = 91.1876, Q_{\\text{cut}} = 1.0, N_{\\mathrm{ME}} = 5, \\varepsilon = 0.2)$, lower $Q_{\\text{cut}}$ increases the mean number of emissions.\n- Case $4$: $(Q = 200.0, Q_{\\text{cut}} = 20.0, N_{\\mathrm{ME}} = 4, \\varepsilon = -0.3)$, higher energy and negative distortion parameter to probe suppression.\n- Case $5$: $(Q = 91.1876, Q_{\\text{cut}} = 80.0, N_{\\mathrm{ME}} = 6, \\varepsilon = 1.0)$, near-boundary with $Q_{\\text{cut}}$ close to $Q$ yielding a small mean number of emissions.\n\nFinal output format:\nYour program should produce a single line of output containing the fractional deviations $\\Delta$ for the five test cases as a comma-separated list enclosed in square brackets, for example, $\\left[\\delta_1,\\delta_2,\\delta_3,\\delta_4,\\delta_5\\right]$, where each $\\delta_i$ is rounded to $8$ decimal places. All outputs are dimensionless decimals.",
            "solution": "The objective of this problem is to compute the fractional deviation from unitarity, $\\Delta$, in a simplified model of merging multi-jet matrix elements (ME) with a parton shower (PS). Unitarity requires that the sum of all exclusive jet rates equals the total inclusive cross section. In this normalized framework, the sum should be equal to $1$. The deviation $\\Delta$ quantifies violations of this principle introduced by a toy model of ME corrections.\n\nThe calculation proceeds in two main stages: first, we derive an analytical expression for the mean number of emissions, $\\lambda(Q, Q_{\\text{cut}})$; second, we use this to derive a computationally efficient, exact formula for the deviation $\\Delta$.\n\n**1. Calculation of the Mean Number of Emissions $\\lambda(Q, Q_{\\text{cut}})$**\n\nThe mean number of emissions, $\\lambda$, is defined by the integral of the strong coupling $\\alpha_s(\\mu)$ over the emission scale $\\mu$:\n$$\n\\lambda(Q,Q_{\\text{cut}}) \\equiv \\frac{2 C_F}{\\pi} \\int_{Q_{\\text{cut}}}^{Q} \\frac{\\alpha_s(\\mu)}{\\mu} \\, d\\mu\n$$\nThe one-loop running strong coupling is given by:\n$$\n\\alpha_s(\\mu) = \\frac{4\\pi}{\\beta_0 \\ln\\left(\\frac{\\mu^2}{\\Lambda^2}\\right)}\n$$\nwhere $\\beta_0 = 11 - \\frac{2}{3} n_f$. With $n_f = 5$, we have $\\beta_0 = 11 - \\frac{10}{3} = \\frac{23}{3}$. The quadratic Casimir for the fundamental representation is $C_F = \\frac{4}{3}$.\n\nSubstituting the expression for $\\alpha_s(\\mu)$ into the integral for $\\lambda$:\n$$\n\\lambda = \\frac{2 C_F}{\\pi} \\int_{Q_{\\text{cut}}}^{Q} \\left( \\frac{4\\pi}{\\beta_0 \\ln\\left(\\frac{\\mu^2}{\\Lambda^2}\\right)} \\right) \\frac{d\\mu}{\\mu} = \\frac{8 C_F}{\\beta_0} \\int_{Q_{\\text{cut}}}^{Q} \\frac{1}{\\ln\\left(\\frac{\\mu^2}{\\Lambda^2}\\right)} \\frac{d\\mu}{\\mu}\n$$\nUsing the logarithm property $\\ln(a^b) = b \\ln(a)$, the denominator can be written as $2\\ln(\\mu/\\Lambda)$.\n$$\n\\lambda = \\frac{8 C_F}{\\beta_0} \\int_{Q_{\\text{cut}}}^{Q} \\frac{1}{2\\ln(\\mu/\\Lambda)} \\frac{d\\mu}{\\mu} = \\frac{4 C_F}{\\beta_0} \\int_{Q_{\\text{cut}}}^{Q} \\frac{1}{\\ln(\\mu/\\Lambda)} \\frac{d\\mu}{\\mu}\n$$\nTo solve this integral, we perform a change of variables. Let $u = \\ln(\\mu/\\Lambda)$. The differential is $du = \\frac{1}{\\mu/\\Lambda} \\cdot \\frac{1}{\\Lambda} d\\mu = \\frac{d\\mu}{\\mu}$. The integration limits change from $\\mu \\in [Q_{\\text{cut}}, Q]$ to $u \\in [\\ln(Q_{\\text{cut}}/\\Lambda), \\ln(Q/\\Lambda)]$.\nThe integral becomes:\n$$\n\\lambda = \\frac{4 C_F}{\\beta_0} \\int_{\\ln(Q_{\\text{cut}}/\\Lambda)}^{\\ln(Q/\\Lambda)} \\frac{1}{u} \\, du = \\frac{4 C_F}{\\beta_0} \\left[ \\ln u \\right]_{\\ln(Q_{\\text{cut}}/\\Lambda)}^{\\ln(Q/\\Lambda)}\n$$\nEvaluating the definite integral gives the final analytical expression for $\\lambda$:\n$$\n\\lambda(Q, Q_{\\text{cut}}) = \\frac{4 C_F}{\\beta_0} \\left( \\ln\\left(\\ln\\frac{Q}{\\Lambda}\\right) - \\ln\\left(\\ln\\frac{Q_{\\text{cut}}}{\\Lambda}\\right) \\right) = \\frac{4 C_F}{\\beta_0} \\ln\\left( \\frac{\\ln(Q/\\Lambda)}{\\ln(Q_{\\text{cut}}/\\Lambda)} \\right)\n$$\nSubstituting the numerical values for $C_F$ and $\\beta_0$:\n$$\n\\frac{4 C_F}{\\beta_0} = \\frac{4 \\cdot (4/3)}{23/3} = \\frac{16/3}{23/3} = \\frac{16}{23}\n$$\nThus, we have a closed-form solution for $\\lambda$ dependent only on the energy scales $Q$, $Q_{\\text{cut}}$, and $\\Lambda$.\n\n**2. Calculation of the Fractional Deviation $\\Delta$**\n\nThe total merged exclusive sum, $S$, is defined as the sum over all possible numbers of emissions $m$, weighted by the Poisson probability $P(m;\\lambda)$ and the merging weight factor $w(m)$:\n$$\nS = \\sum_{m=0}^{\\infty} P(m; \\lambda) w(m)\n$$\nThe weight factor $w(m)$ is defined piecewise:\n$$\nw(m) = \\begin{cases} 1 + \\varepsilon \\, g(m) & \\text{for } m \\le m_{\\mathrm{ME}} \\\\ 1 & \\text{for } m > m_{\\mathrm{ME}} \\end{cases}\n$$\nwhere $m_{\\mathrm{ME}} = N_{\\mathrm{ME}} - 2$ is the maximum number of emissions corrected by matrix elements.\n\nWe can split the sum for $S$ into two parts:\n$$\nS = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) w(m) + \\sum_{m=m_{\\mathrm{ME}}+1}^{\\infty} P(m; \\lambda) \\cdot 1\n$$\nThe second term is the tail of the Poisson distribution. The fundamental property of the Poisson distribution is that it is normalized to unity: $\\sum_{m=0}^{\\infty} P(m; \\lambda) = 1$. This implies that the second term can be expressed as:\n$$\n\\sum_{m=m_{\\mathrm{ME}}+1}^{\\infty} P(m; \\lambda) = 1 - \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda)\n$$\nSubstituting this back into the expression for $S$:\n$$\nS = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) w(m) + \\left( 1 - \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) \\right)\n$$\nThe fractional deviation is defined as $\\Delta \\equiv S - 1$.\n$$\n\\Delta = S - 1 = \\left( \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) w(m) + 1 - \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) \\right) - 1\n$$\n$$\n\\Delta = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) w(m) - \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) (w(m) - 1)\n$$\nFrom the definition of $w(m)$, we have $w(m) - 1 = \\varepsilon g(m)$ for $m \\le m_{\\mathrm{ME}}$. This yields the final exact expression for $\\Delta$:\n$$\n\\Delta = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) (\\varepsilon g(m)) = \\varepsilon \\sum_{m=0}^{m_{\\mathrm{ME}}} \\frac{e^{-\\lambda} \\lambda^m}{m!} \\left( \\exp\\left(-\\frac{m}{m_0}\\right) - c \\right)\n$$\nThis result is a finite sum from $m=0$ to $m_{\\mathrm{ME}} = N_{\\mathrm{ME}}-2$. This is computationally advantageous as it obviates the need for approximating an infinite series and managing truncation errors. The problem's description of summing until a tolerance is met corresponds to a numerical brute-force evaluation of $S$, whereas this analytical simplification provides the exact result directly.\n\n**3. Algorithmic Procedure**\n\nFor each test case given by the parameter set $(Q, Q_{\\text{cut}}, N_{\\mathrm{ME}}, \\varepsilon)$, the calculation of $\\Delta$ proceeds as follows:\n1.  Define the physical and model constants: $\\Lambda = 0.2 \\ \\mathrm{GeV}$, $C_F = 4/3$, $n_f = 5$, $m_0 = 1.5$, and $c = 0.4$.\n2.  Calculate $\\beta_0 = 11 - 2/3 \\cdot n_f = 23/3$.\n3.  Calculate the mean number of emissions $\\lambda$ using the derived analytical formula:\n    $$ \\lambda = \\frac{16}{23} \\ln\\left( \\frac{\\ln(Q/\\Lambda)}{\\ln(Q_{\\text{cut}}/\\Lambda)} \\right) $$\n4.  Determine the maximum corrected multiplicity $m_{\\mathrm{ME}} = N_{\\mathrm{ME}} - 2$.\n5.  If $\\varepsilon = 0$, the deviation $\\Delta$ is immediately $0$. Otherwise, compute the finite sum for $\\Delta$.\n6.  Initialize a variable for the sum, $\\Delta_{\\text{sum}} = 0$.\n7.  Iterate for $m$ from $0$ to $m_{\\mathrm{ME}}$. In each step:\n    a.  Calculate the Poisson probability $P(m; \\lambda) = \\frac{e^{-\\lambda}\\lambda^m}{m!}$. To maintain numerical stability, it is best to compute this iteratively: $P(m;\\lambda) = P(m-1;\\lambda) \\cdot \\frac{\\lambda}{m}$, with $P(0;\\lambda) = e^{-\\lambda}$.\n    b.  Calculate the distortion term $g(m) = \\exp(-m/m_0) - c$.\n    c.  Add the product $P(m; \\lambda) \\cdot g(m)$ to the running sum $\\Delta_{\\text{sum}}$.\n8.  The final deviation is $\\Delta = \\varepsilon \\cdot \\Delta_{\\text{sum}}$.\n9.  Round the final result for $\\Delta$ to $8$ decimal places as required.\nThis procedure will be implemented for each of the five test cases specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the unitarity deviation problem for the given test cases.\n    \"\"\"\n\n    # Define physical and model constants from the problem statement.\n    LAMBDA_QCD = 0.2  # GeV\n    C_F = 4.0 / 3.0\n    N_F = 5.0\n    BETA_0 = 11.0 - (2.0 / 3.0) * N_F\n    \n    # Distortion function parameters\n    M0 = 1.5\n    C_G = 0.4\n\n    # Define the test cases from the problem statement.\n    # Format: (Q [GeV], Q_cut [GeV], N_ME, epsilon)\n    test_cases = [\n        (91.1876, 5.0, 6, 0.0),   # Case 1\n        (91.1876, 5.0, 4, 0.5),   # Case 2\n        (91.1876, 1.0, 5, 0.2),   # Case 3\n        (200.0, 20.0, 4, -0.3),  # Case 4\n        (91.1876, 80.0, 6, 1.0),   # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        q, q_cut, n_me_jets, epsilon = case\n        \n        # Calculate the fractional deviation Delta.\n        delta = calculate_deviation(q, q_cut, n_me_jets, epsilon,\n                                    LAMBDA_QCD, C_F, BETA_0, M0, C_G)\n        \n        # Round the result to 8 decimal places.\n        results.append(round(delta, 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef calculate_deviation(q, q_cut, n_me_jets, epsilon,\n                        lambda_qcd, c_f, beta_0, m0, c_g):\n    \"\"\"\n    Calculates the fractional deviation Delta for a single parameter set.\n    \n    The calculation uses the analytical formula derived in the solution:\n    Delta = epsilon * sum_{m=0 to m_ME} P(m; lambda) * g(m)\n    \"\"\"\n    # A merging distortion of size epsilon=0 leads to perfect unitarity, Delta=0.\n    if epsilon == 0.0:\n        return 0.0\n\n    # Calculate the mean number of emissions, lambda.\n    # lambda = (4*C_F/beta_0) * ln( ln(Q/Lambda)/ln(Q_cut/Lambda) )\n    prefactor = (4.0 * c_f) / beta_0\n    log_arg = np.log(q / lambda_qcd) / np.log(q_cut / lambda_qcd)\n    lambda_val = prefactor * np.log(log_arg)\n    \n    # Maximum number of ME-corrected emissions.\n    m_me = n_me_jets - 2\n\n    # Calculate the sum part of the Delta formula.\n    # sum_{m=0 to m_ME} (P(m; lambda) * g(m))\n    delta_sum = 0.0\n    \n    # To avoid large numbers in lambda^m and m!, calculate Poisson probabilities\n    # iteratively: P(m) = P(m-1) * lambda / m\n    poisson_prob = np.exp(-lambda_val)  # P(0; lambda)\n    \n    for m in range(m_me + 1):\n        # For m=0, poisson_prob is already P(0).\n        # For m > 0, it was updated in the previous iteration's end.\n        \n        # Calculate distortion function g(m)\n        g_m = np.exp(-m / m0) - c_g\n        \n        # Add term to the sum\n        delta_sum += poisson_prob * g_m\n        \n        # Update Poisson probability for the next iteration m+1\n        if m < m_me: # No need to update after the last term.\n          poisson_prob *= lambda_val / (m + 1.0)\n            \n    # Final deviation is epsilon times the sum.\n    delta = epsilon * delta_sum\n    \n    return delta\n\nsolve()\n```"
        }
    ]
}