{
    "hands_on_practices": [
        {
            "introduction": "Before calculating decay rates, we must first define the space of all possible outcomes. This exercise  guides you through the fundamental principles that constrain the kinematics of a three-body decay, forming the basis of the famous Dalitz plot. By implementing checks based on conservation laws and the geometric properties of three-momenta, you will build a robust tool to distinguish physically allowed configurations from unphysical ones.",
            "id": "3532984",
            "problem": "Implement a program that, for a given three-body decay in the parent rest frame, determines whether specified pairwise invariant masses correspond to a physically allowed kinematic configuration by enforcing kinematic constraints derived from first principles. You must check three independent necessary and sufficient conditions for physicality: triangle inequalities for pairwise invariant masses, positivity of individual energies, and non-negative three-momentum Gram determinant. All input quantities are to be interpreted in the parent rest frame.\n\nYou are given a parent particle with mass $M$ decaying into three daughters with masses $m_1$, $m_2$, and $m_3$. Define the pairwise invariant masses squared as $s_{ij} \\equiv m_{ij}^2 = (p_i + p_j)^2$, where $p_i$ are the daughter four-momenta satisfying the on-shell conditions $p_i^2 = m_i^2$, and total four-momentum $P = p_1 + p_2 + p_3$ with $P^2 = M^2$. In the parent rest frame, $P = (M,\\mathbf{0})$. For any two chosen invariants $s_{12}$ and $s_{23}$, the third invariant $s_{13}$ is fixed by conservation laws:\n$$\ns_{13} = M^2 + m_1^2 + m_2^2 + m_3^2 - s_{12} - s_{23}.\n$$\nA point $(s_{12}, s_{23})$ is physically allowed if and only if all of the following hold:\n- Triangle inequalities for each pair: for each pair $(i,j)$, \n$$\ns_{ij} \\ge (m_i + m_j)^2.\n$$\n- Positivity of energies and real three-momenta for each daughter $i$ in the parent rest frame, where\n$$\nE_i = \\frac{M^2 + m_i^2 - s_{jk}}{2 M}, \\quad \\text{with } \\{i,j,k\\} = \\{1,2,3\\},\n$$\nmust satisfy $E_i \\ge m_i$, implying $E_i \\ge 0$ and $E_i^2 - m_i^2 \\ge 0$.\n- Non-negative three-momentum Gram determinant $G \\ge 0$, where $G$ is the determinant of the $3 \\times 3$ Euclidean Gram matrix $\\mathcal{G}$ of daughter three-momenta in the Center-of-Mass (COM) frame of the parent. Let $\\mathbf{p}_i$ be the three-momentum of particle $i$ with magnitude $|\\mathbf{p}_i|^2 = E_i^2 - m_i^2$. The off-diagonal entries of $\\mathcal{G}$ are determined purely from invariants and energies, without needing explicit angles, via\n$$\n\\mathcal{G}_{ii} = |\\mathbf{p}_i|^2, \\quad \\mathcal{G}_{ij} = E_i E_j - \\frac{s_{ij} - m_i^2 - m_j^2}{2} \\quad \\text{for } i \\ne j,\n$$\nso that $G = \\det \\mathcal{G} \\ge 0$ ensures that three real vectors with those mutual scalar products and magnitudes exist in three-dimensional space. Numerical checks must be tolerant to floating-point roundoff; treat values within a small tolerance $\\varepsilon$ of a bound as satisfying the bound.\n\nYour task is to write a complete program that applies these checks to a fixed test suite. All masses must be specified in gigaelectronvolts ($\\mathrm{GeV}$). All invariant masses squared must be specified in $\\mathrm{GeV}^2$. The output for each test case is a boolean indicating whether the input corresponds to a physical kinematic configuration under these criteria.\n\nTest suite (each case is $(M, [m_1,m_2,m_3], s_{12}, s_{23})$):\n- Case 1 (happy path, interior point): $(3.0, [0.5, 0.4, 0.3], 1.01, 4.0)$.\n- Case 2 (boundary with a daughter at rest; Gram determinant zero): $(3.0, [0.5, 0.4, 0.3], 7.29, 1.05)$, noting $7.29 = (3.0 - 0.3)^2$ and this choice implies $s_{13} = 1.16$ by conservation.\n- Case 3 (violates triangle inequality): $(3.0, [0.5, 0.4, 0.3], 0.80, 4.0)$.\n- Case 4 (violates energy positivity for particle $1$): $(3.0, [0.5, 0.4, 0.3], 1.01, 6.3)$.\n- Case 5 (violates Gram determinant while triangle bounds hold): $(3.0, [0.5, 0.4, 0.3], 1.01, 6.0)$.\n- Case 6 (massless daughters, boundary point): $(1.0, [0.0, 0.0, 0.0], 0.2, 0.3)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\"). For the given test suite, the output should be a list of six booleans in the same order as the cases above. Angles are not required and must not be used; all computations must be in terms of the invariants, masses, and the parent mass, using the COM frame definitions given. Use a numerical tolerance $\\varepsilon = 10^{-10}$ when comparing to bounds to account for floating-point error. All values must be treated as having the units specified above, and no other units should be used. The output booleans must be the native boolean values produced by the programming language, not strings.",
            "solution": "The problem of determining the physical region for a three-body decay is a classic exercise in relativistic kinematics. The solution hinges on the principles of four-momentum conservation and the geometric properties of vectors in three-dimensional Euclidean space. We are given a parent particle of mass $M$ decaying into three daughters of masses $m_1, m_2, m_3$. The entire analysis is conducted in the rest frame of the parent particle, where its four-momentum is $P = (M, \\mathbf{0})$. The daughters' four-momenta are denoted by $p_i = (E_i, \\mathbf{p}_i)$, where $E_i$ and $\\mathbf{p}_i$ are their respective energies and three-momenta.\n\nFour-momentum conservation dictates that $P = p_1 + p_2 + p_3$. A crucial consequence of this is that the kinematic configuration of the decay is not arbitrary. The phase space of possible outcomes is constrained. For a three-body decay, this phase space can be described by two independent variables. A convenient choice is two of the three possible pairwise invariant mass squares, denoted as $s_{ij} = (p_i + p_j)^2$. The problem specifies $s_{12}$ and $s_{23}$ as the independent variables.\n\nThe third invariant mass square, $s_{13}$, is then fixed by the conservation law. This can be derived by summing all three pairwise invariants:\n$$\ns_{12} + s_{13} + s_{23} = (p_1+p_2)^2 + (p_1+p_3)^2 + (p_2+p_3)^2\n$$\nExpanding the squares and using the on-shell condition $p_i^2=m_i^2$, we get:\n$$\ns_{12} + s_{13} + s_{23} = 2(m_1^2+m_2^2+m_3^2) + 2(p_1\\cdot p_2 + p_1\\cdot p_3 + p_2\\cdot p_3)\n$$\nFrom total momentum conservation, $P^2 = (p_1+p_2+p_3)^2$, we have:\n$$\nM^2 = m_1^2+m_2^2+m_3^2 + 2(p_1\\cdot p_2 + p_1\\cdot p_3 + p_2\\cdot p_3)\n$$\nCombining these two results yields the relation $s_{12} + s_{13} + s_{23} = M^2 + m_1^2 + m_2^2 + m_3^2$. Solving for $s_{13}$ gives the formula provided in the problem statement:\n$$\ns_{13} = M^2 + m_1^2 + m_2^2 + m_3^2 - s_{12} - s_{23}\n$$\nA given point $(s_{12}, s_{23})$ is physically allowed if and only if it satisfies three independent sets of necessary and sufficient conditions. Our algorithm will check each of these conditions in sequence.\n\nFirst, we check the **triangle inequalities**. The quantity $\\sqrt{s_{ij}}$ represents the total energy of the daughter pair $(i, j)$ in their combined center-of-mass frame. For the particles to be produced, this energy must be at least the sum of their rest masses. Therefore, for each pair $(i,j)$, we must have $\\sqrt{s_{ij}} \\ge m_i + m_j$. Squaring both sides gives the condition stated:\n$$\ns_{ij} \\ge (m_i + m_j)^2\n$$\nWe must verify this for all three pairs: $(1,2)$, $(2,3)$, and $(1,3)$.\n\nSecond, we check the **positivity of energies**. The energy $E_i$ of each daughter particle in the parent's rest frame must be at least its rest mass $m_i$, i.e., $E_i \\ge m_i$. This ensures that its kinetic energy is non-negative and its three-momentum magnitude $|\\mathbf{p}_i| = \\sqrt{E_i^2 - m_i^2}$ is a real number. The formula for $E_i$ is derived from the definition of $s_{jk}$:\n$$\ns_{jk} = (p_j+p_k)^2 = (P-p_i)^2 = P^2 - 2P \\cdot p_i + p_i^2\n$$\nIn the parent rest frame, $P=(M, \\mathbf{0})$ and $p_i=(E_i, \\mathbf{p}_i)$, so $P \\cdot p_i = M E_i$. Substituting this and the on-shell conditions $P^2=M^2$ and $p_i^2 = m_i^2$ gives $s_{jk} = M^2 - 2ME_i + m_i^2$. Solving for $E_i$ yields the provided formula, which must be checked for each daughter $i=1,2,3$:\n$$\nE_i = \\frac{M^2 + m_i^2 - s_{jk}}{2M} \\ge m_i\n$$\n\nThird, we check the **non-negativity of the three-momentum Gram determinant**. In the parent rest frame, the three daughter momenta must sum to zero: $\\mathbf{p}_1 + \\mathbf{p}_2 + \\mathbf{p}_3 = \\mathbf{0}$. This means the three vectors are linearly dependent and must therefore be coplanar. A fundamental result from linear algebra states that a set of vectors can be embedded in $n$-dimensional Euclidean space if and only if their Gram determinant is non-negative. For our three vectors $\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3$ in 3D space, the Gram matrix $\\mathcal{G}$ has elements $\\mathcal{G}_{ij} = \\mathbf{p}_i \\cdot \\mathbf{p}_j$. Its determinant $G = \\det(\\mathcal{G})$ must be greater than or equal to zero. As the three vectors are coplanar, the determinant must be exactly zero for any physical configuration. A negative determinant implies that no set of real vectors $\\mathbf{p}_i$ in 3D space can satisfy the specified magnitudes and mutual dot products, making the configuration unphysical. The elements of $\\mathcal{G}$ are computed from the invariants and energies, as specified. The diagonal elements are the squared magnitudes $|\\mathbf{p}_i|^2 = E_i^2 - m_i^2$. The off-diagonal elements are derived from the four-vector dot product $p_i \\cdot p_j = E_i E_j - \\mathbf{p}_i \\cdot \\mathbf{p}_j$ and the invariant mass definition $s_{ij} = m_i^2 + m_j^2 + 2p_i \\cdot p_j$:\n$$\n\\mathcal{G}_{ij} = \\mathbf{p}_i \\cdot \\mathbf{p}_j = E_i E_j - \\frac{s_{ij} - m_i^2 - m_j^2}{2}\n$$\nWe construct the $3 \\times 3$ matrix $\\mathcal{G}$ and compute its determinant $G$. The configuration is physical only if $G \\ge 0$. Due to floating-point arithmetic, we check if $G \\ge -\\varepsilon$, where $\\varepsilon$ is a small tolerance.\n\nThe overall algorithm is to take the inputs $(M, [m_1,m_2,m_3], s_{12}, s_{23})$, compute $s_{13}$, and then sequentially apply the three sets of checks. If any check fails, the kinematic point is unphysical and we conclude immediately. If all checks pass, the point is physical.\nA numerical tolerance $\\varepsilon = 10^{-10}$ is used for all inequality comparisons to robustly handle floating-point inaccuracies, especially at the boundaries of the physical region.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_physical(M, masses, s12, s23, tol=1e-10):\n    \"\"\"\n    Checks if a given kinematic configuration for a three-body decay is physical.\n\n    Args:\n        M (float): Mass of the parent particle.\n        masses (list[float]): List of the three daughter masses [m1, m2, m3].\n        s12 (float): Invariant mass squared of the pair (1, 2).\n        s23 (float): Invariant mass squared of the pair (2, 3).\n        tol (float): Numerical tolerance for floating-point comparisons.\n\n    Returns:\n        bool: True if the configuration is physical, False otherwise.\n    \"\"\"\n    m1, m2, m3 = masses\n    m1_sq, m2_sq, m3_sq = m1**2, m2**2, m3**2\n    M_sq = M**2\n\n    # Step 1: Calculate the dependent invariant mass squared, s13, from conservation.\n    s13 = M_sq + m1_sq + m2_sq + m3_sq - s12 - s23\n\n    # Step 2: Check the triangle inequalities for all three pairs.\n    # The condition is s_ij >= (m_i + m_j)^2.\n    if s12 < (m1 + m2)**2 - tol:\n        return False\n    if s23 < (m2 + m3)**2 - tol:\n        return False\n    if s13 < (m1 + m3)**2 - tol:\n        return False\n\n    # Step 3: Calculate daughter energies and check the energy positivity condition.\n    # The condition is E_i >= m_i, which ensures a real-valued three-momentum.\n    # This also implicitly enforces the upper bounds on s_ij, e.g., s23 <= (M-m1)^2.\n    \n    # Division by zero check for M\n    if M <= 0:\n        return False\n        \n    E1 = (M_sq + m1_sq - s23) / (2 * M)\n    if E1 < m1 - tol:\n        return False\n\n    E2 = (M_sq + m2_sq - s13) / (2 * M)\n    if E2 < m2 - tol:\n        return False\n\n    E3 = (M_sq + m3_sq - s12) / (2 * M)\n    if E3 < m3 - tol:\n        return False\n\n    # Step 4: Check if the three-momentum Gram determinant is non-negative.\n    # Calculate diagonal elements of the Gram matrix: G_ii = |p_i|^2 = E_i^2 - m_i^2\n    # The energy checks above ensure these are non-negative.\n    p1_sq = E1**2 - m1_sq\n    p2_sq = E2**2 - m2_sq\n    p3_sq = E3**2 - m3_sq\n\n    # Calculate off-diagonal elements: G_ij = p_i . p_j\n    p1_dot_p2 = E1 * E2 - (s12 - m1_sq - m2_sq) / 2\n    p1_dot_p3 = E1 * E3 - (s13 - m1_sq - m3_sq) / 2\n    p2_dot_p3 = E2 * E3 - (s23 - m2_sq - m3_sq) / 2\n\n    # Construct the Gram matrix and calculate its determinant.\n    gram_matrix = np.array([\n        [p1_sq,     p1_dot_p2, p1_dot_p3],\n        [p1_dot_p2, p2_sq,     p2_dot_p3],\n        [p1_dot_p3, p2_dot_p3, p3_sq]\n    ])\n    \n    det_G = np.linalg.det(gram_matrix)\n\n    # A negative determinant is unphysical.\n    if det_G < -tol:\n        return False\n\n    # If all checks pass, the configuration is physical.\n    return True\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Format: (M, [m1, m2, m3], s12, s23)\n    test_cases = [\n        (3.0, [0.5, 0.4, 0.3], 1.01, 4.0),\n        (3.0, [0.5, 0.4, 0.3], 7.29, 1.05),\n        (3.0, [0.5, 0.4, 0.3], 0.80, 4.0),\n        (3.0, [0.5, 0.4, 0.3], 1.01, 6.3),\n        (3.0, [0.5, 0.4, 0.3], 1.01, 6.0),\n        (1.0, [0.0, 0.0, 0.0], 0.2, 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        M, masses, s12, s23 = case\n        result = is_physical(M, masses, s12, s23)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) converts boolean True/False to \"True\"/\"False\" string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many physical processes are dominated by the production of intermediate resonances, leading to sharply peaked features in the phase space. This practice  introduces importance sampling, a critical Monte Carlo technique for efficiently integrating over these resonant structures. You will derive and implement a custom sampler for a Breit-Wigner distribution, learning how to generate events according to their likelihood and compute unbiased rate estimates.",
            "id": "3532946",
            "problem": "You are to design and implement an importance sampling scheme for the intermediate invariant mass-squared variable $m_{12}^2$ whose distribution is shaped by a resonant propagator. The goal is to integrate functions of the form\n$$\nI = \\int_{s_{\\min}}^{s_{\\max}} \\mathrm{d}x \\;\\frac{R(x)}{(x - M^2)^2 + (M\\Gamma)^2},\n$$\nwhere $x \\equiv m_{12}^2$, $M$ is a resonance mass parameter, $\\Gamma$ is a width parameter, and $R(x)$ is a bounded, nonnegative function that may vary across $[s_{\\min}, s_{\\max}]$. All quantities are to be treated as dimensionless.\n\nBase your derivation and algorithm on the following foundational principles only:\n- Monte Carlo integration and importance sampling: for a target integral $I = \\int \\mathrm{d}x \\, H(x)$ and a normalized proposal density $g(x)$ with support covering the domain of integration, the unbiased estimator is $\\hat{I} = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{H(x_i)}{g(x_i)}$ with $x_i \\sim g$ independently and identically distributed.\n- The Cauchy distribution: a standard Cauchy probability density function with location $a$ and scale $b$ has density $f(x; a, b) = \\frac{1}{\\pi}\\frac{b}{(x-a)^2 + b^2}$ and cumulative distribution function $F(x; a, b) = \\frac{1}{\\pi}\\arctan\\!\\left(\\frac{x-a}{b}\\right) + \\frac{1}{2}$.\n\nTasks you must complete:\n1. Construct a normalized proposal density $g(x)$ proportional to a Cauchy (Breit-Wigner) function on the finite interval $[s_{\\min}, s_{\\max}]$, with location $a = M^2$ and scale $b = M\\Gamma$. The construction must use truncation of the Cauchy distribution to $[s_{\\min}, s_{\\max}]$. Your implementation must use an inverse-transform sampling scheme to generate samples $x$ from this truncated proposal.\n2. Derive, from first principles, the corresponding event weight $w(x)$ such that the Monte Carlo estimator for $I$ remains unbiased under sampling from $g(x)$. Your derivation must start from the base principles stated above and not from any specialized shortcut formula.\n3. Implement a program that:\n   - Generates $N$ independent samples from the proposal $g(x)$ for each test case using inverse-transform sampling.\n   - Computes the Monte Carlo estimate of $I$ for each test case using the derived event weights.\n   - Computes a high-accuracy reference value of $I$ using numerical quadrature over $[s_{\\min}, s_{\\max}]$.\n   - Uses a fixed random seed so the results are deterministic and repeatable.\n\nAngle unit convention: if any inverse trigonometric function appears in your derivation or implementation, it must be interpreted in radians.\n\nTest suite:\n- Case $1$ (happy path, moderate width, centered in range):\n  - $M = 1.0$, $\\Gamma = 0.05$ so $a = M^2 = 1.0$, $b = M\\Gamma = 0.05$.\n  - $s_{\\min} = 0.5$, $s_{\\max} = 1.5$.\n  - $R(x) = 1$.\n  - $N = 200000$ samples.\n- Case $2$ (varying numerator):\n  - $M =  \\sqrt{2.0}$, $\\Gamma = 0.1414213562373095$ so $a = M^2 = 2.0$, $b = M\\Gamma = 0.2$.\n  - $s_{\\min} = 1.0$, $s_{\\max} = 3.0$.\n  - $R(x) = x$.\n  - $N = 200000$ samples.\n- Case $3$ (resonance center outside the integration range):\n  - $M = \\sqrt{1.5}$, $\\Gamma = 0.08164965809277261$ so $a = M^2 = 1.5$, $b = M\\Gamma = 0.1224744871391589$; for this test use $b = 0.1$ exactly.\n  - $s_{\\min} = 1.7$, $s_{\\max} = 2.0$.\n  - $R(x) = 1 + x^2$.\n  - $N = 200000$ samples.\n- Case $4$ (narrow width edge case on a wide interval):\n  - $M = 3.0$, $\\Gamma = 0.005$ so $a = M^2 = 9.0$, $b = M\\Gamma = 0.015$.\n  - $s_{\\min} = 0.0$, $s_{\\max} = 20.0$.\n  - $R(x) = \\exp(-0.1 x)$.\n  - $N = 200000$ samples.\n\nImplementation details:\n- Use a single fixed random seed of $12345$ for all pseudorandom number generation.\n- For the inverse-transform sampler for the truncated Cauchy on $[s_{\\min}, s_{\\max}]$, use the standard Cauchy cumulative distribution function $F(x; a, b)$ and its inverse. Ensure numerical robustness by avoiding the exact endpoints where the tangent diverges.\n- The high-accuracy reference integral must be computed numerically over $[s_{\\min}, s_{\\max}]$.\n\nRequired outputs:\n- For each test case, compute two floats:\n  - The Monte Carlo estimate of $I$ using your importance sampling weights.\n  - The absolute error between the Monte Carlo estimate and the high-accuracy numerical quadrature reference.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The order must be\n  $[\\hat{I}_1, \\Delta_1, \\hat{I}_2, \\Delta_2, \\hat{I}_3, \\Delta_3, \\hat{I}_4, \\Delta_4]$,\n  where $\\hat{I}_k$ is the Monte Carlo estimate for case $k$ and $\\Delta_k$ is the absolute error for case $k$.\n- All outputs are dimensionless real numbers. No units should be included. Angles, where applicable internally, are in radians.",
            "solution": "The problem requires the design and implementation of an importance sampling scheme to compute integrals of the form\n$$\nI = \\int_{s_{\\min}}^{s_{\\max}} \\mathrm{d}x \\;\\frac{R(x)}{(x - M^2)^2 + (M\\Gamma)^2}\n$$\nwhere the integrand is dominated by a resonant (Breit-Wigner) propagator. Let the location parameter be $a = M^2$ and the scale parameter be $b = M\\Gamma$. The integral can be written as $I = \\int_{s_{\\min}}^{s_{\\max}} H(x) \\, \\mathrm{d}x$, with the integrand $H(x) = \\frac{R(x)}{(x-a)^2 + b^2}$.\n\nThe core principle of importance sampling is to draw samples $x_i$ from a proposal probability density function (PDF) $g(x)$ that is similar in shape to the integrand $H(x)$, and then compute the integral estimate as the average of weighted samples:\n$$\n\\hat{I} = \\frac{1}{N} \\sum_{i=1}^{N} w(x_i) \\quad \\text{where} \\quad w(x_i) = \\frac{H(x_i)}{g(x_i)}\n$$\n\n**1. Derivation of the Proposal Density $g(x)$**\n\nA suitable proposal density $g(x)$ should be proportional to the part of the integrand $H(x)$ that causes large variations, which is the Breit-Wigner term. We define an un-normalized proposal function $p(x)$ for $x \\in [s_{\\min}, s_{\\max}]$:\n$$\np(x) = \\frac{1}{(x-a)^2 + b^2}\n$$\nTo obtain a normalized PDF $g(x)$, we must divide $p(x)$ by its integral over the domain $[s_{\\min}, s_{\\max}]$. Let this normalization constant be $\\mathcal{N}_p$.\n$$\n\\mathcal{N}_p = \\int_{s_{\\min}}^{s_{\\max}} p(x) \\, \\mathrm{d}x = \\int_{s_{\\min}}^{s_{\\max}} \\frac{1}{(x-a)^2 + b^2} \\, \\mathrm{d}x\n$$\nThe integral is a standard form:\n$$\n\\int \\frac{1}{(x-a)^2 + b^2} \\, \\mathrm{d}x = \\frac{1}{b} \\arctan\\left(\\frac{x-a}{b}\\right) + C\n$$\nEvaluating this at the limits of integration gives the normalization constant:\n$$\n\\mathcal{N}_p = \\frac{1}{b} \\left[ \\arctan\\left(\\frac{s_{\\max}-a}{b}\\right) - \\arctan\\left(\\frac{s_{\\min}-a}{b}\\right) \\right]\n$$\nThe normalized proposal PDF $g(x)$ is therefore defined as:\n$$\ng(x) = \\frac{p(x)}{\\mathcal{N}_p} = \\frac{1}{\\mathcal{N}_p} \\frac{1}{(x-a)^2 + b^2} \\quad \\text{for } x \\in [s_{\\min}, s_{\\max}]\n$$\nand $g(x)=0$ otherwise.\n\n**2. Derivation of the Inverse Transform Sampler**\n\nTo generate random variates from $g(x)$, we use the inverse transform sampling method. This requires finding the inverse of the cumulative distribution function (CDF) of $g(x)$, which we denote as $G(x)$. For $x \\in [s_{\\min}, s_{\\max}]$, the CDF is:\n$$\nG(x) = \\int_{s_{\\min}}^x g(t) \\, \\mathrm{d}t = \\frac{1}{\\mathcal{N}_p} \\int_{s_{\\min}}^x \\frac{1}{(t-a)^2 + b^2} \\, \\mathrm{d}t\n$$\nUsing the antiderivative from the previous step:\n$$\nG(x) = \\frac{1}{\\mathcal{N}_p b} \\left[ \\arctan\\left(\\frac{x-a}{b}\\right) - \\arctan\\left(\\frac{s_{\\min}-a}{b}\\right) \\right]\n$$\nSubstituting the expression for $\\mathcal{N}_p$:\n$$\nG(x) = \\frac{\\arctan\\left(\\frac{x-a}{b}\\right) - \\arctan\\left(\\frac{s_{\\min}-a}{b}\\right)}{\\arctan\\left(\\frac{s_{\\max}-a}{b}\\right) - \\arctan\\left(\\frac{s_{\\min}-a}{b}\\right)}\n$$\nTo find the inverse function $x=G^{-1}(u)$, we set $G(x) = u$, where $u$ is a random variable sampled from a uniform distribution $\\mathcal{U}(0, 1)$. We then solve for $x$. Let $\\theta_y = \\arctan\\left(\\frac{y-a}{b}\\right)$. The equation becomes:\n$$\nu = \\frac{\\theta_x - \\theta_{s_{\\min}}}{\\theta_{s_{\\max}} - \\theta_{s_{\\min}}}\n$$\nSolving for $\\theta_x$:\n$$\n\\theta_x = \\theta_{s_{\\min}} + u (\\theta_{s_{\\max}} - \\theta_{s_{\\min}})\n$$\nSubstituting back $\\theta_x = \\arctan\\left(\\frac{x-a}{b}\\right)$:\n$$\n\\arctan\\left(\\frac{x-a}{b}\\right) = \\theta_{s_{\\min}} + u (\\theta_{s_{\\max}} - \\theta_{s_{\\min}})\n$$\nFinally, solving for $x$ yields the sampling formula:\n$$\nx(u) = a + b \\tan\\left( \\theta_{s_{\\min}} + u (\\theta_{s_{\\max}} - \\theta_{s_{\\min}}) \\right)\n$$\nThis formula allows us to generate a sample $x$ distributed according to $g(x)$ from a uniform random number $u$.\n\n**3. Derivation of the Event Weight $w(x)$**\n\nThe event weight $w(x)$ is defined as the ratio of the original integrand $H(x)$ to the proposal PDF $g(x)$.\n$$\nw(x) = \\frac{H(x)}{g(x)} = \\frac{\\frac{R(x)}{(x-a)^2 + b^2}}{\\frac{1}{\\mathcal{N}_p} \\frac{1}{(x-a)^2 + b^2}}\n$$\nThe denominator term $(x-a)^2 + b^2$ cancels, which is the primary benefit of this choice of importance sampling. This cancellation removes the dominant source of variance, leaving a much smoother function to integrate. The weight simplifies to:\n$$\nw(x) = R(x) \\cdot \\mathcal{N}_p\n$$\nSubstituting the expression for $\\mathcal{N}_p$:\n$$\nw(x) = R(x) \\cdot \\frac{1}{b} \\left[ \\arctan\\left(\\frac{s_{\\max}-a}{b}\\right) - \\arctan\\left(\\frac{s_{\\min}-a}{b}\\right) \\right]\n$$\nThe Monte Carlo estimator for the integral $I$ is the average of these weights over $N$ samples:\n$$\n\\hat{I}_N = \\frac{1}{N} \\sum_{i=1}^N w(x_i)\n$$\nSince the part of the weight involving the arctan functions and $b$ is a constant, let's call it $W_{const} = \\mathcal{N}_p$, the estimator can be written efficiently as:\n$$\n\\hat{I}_N = W_{const} \\cdot \\left( \\frac{1}{N} \\sum_{i=1}^N R(x_i) \\right) = W_{const} \\cdot \\langle R(x) \\rangle\n$$\nThis expression is implemented to find the Monte Carlo estimate. The reference value for the integral is computed using high-precision numerical quadrature, and the absolute error is the absolute difference between the Monte Carlo estimate and the reference value.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the importance sampling problem for the given test cases.\n    \"\"\"\n\n    # Fixed random seed for reproducibility\n    SEED = 12345\n    rng = np.random.default_rng(SEED)\n\n    # Test cases defined in the problem statement.\n    # Structure: (M, Gamma, s_min, s_max, R_func, N, (optional_a, optional_b))\n    test_cases = [\n        (1.0, 0.05, 0.5, 1.5, lambda x: np.ones_like(x), 200000, None),\n        (np.sqrt(2.0), 0.1414213562373095, 1.0, 3.0, lambda x: x, 200000, None),\n        # For Case 3, a and b are specified explicitly in the problem.\n        # M and Gamma are for context. a=M^2=1.5, b=0.1\n        (np.sqrt(1.5), 0.08164965809277261, 1.7, 2.0, lambda x: 1 + x**2, 200000, (1.5, 0.1)),\n        (3.0, 0.005, 0.0, 20.0, lambda x: np.exp(-0.1 * x), 200000, None),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        M, Gamma, s_min, s_max, R_func, N, overrides = case\n\n        # Set resonance parameters a and b\n        if overrides:\n            a, b = overrides\n        else:\n            a = M**2\n            b = M * Gamma\n\n        # --- Importance Sampling ---\n\n        # 1. Calculate constants for sampling and weighting\n        theta_min = np.arctan((s_min - a) / b)\n        theta_max = np.arctan((s_max - a) / b)\n        \n        # 2. Generate N samples using inverse transform sampling\n        u = rng.uniform(size=N)\n        theta_samples = theta_min + u * (theta_max - theta_min)\n        x_samples = a + b * np.tan(theta_samples)\n        \n        # 3. Calculate constant part of the weight (the normalization constant N_p)\n        W_const = (theta_max - theta_min) / b\n\n        # 4. Compute the Monte Carlo estimate\n        R_values = R_func(x_samples)\n        I_hat = W_const * np.mean(R_values)\n        \n        # --- High-Accuracy Reference Calculation ---\n        \n        # Define the full integrand for numerical quadrature\n        integrand = lambda x: R_func(x) / ((x - a)**2 + b**2)\n        \n        # 5. Compute the reference integral using scipy.integrate.quad\n        I_ref, _ = integrate.quad(integrand, s_min, s_max, epsabs=1e-12, limit=200)\n\n        # 6. Calculate the absolute error\n        delta = abs(I_hat - I_ref)\n        \n        results.extend([I_hat, delta])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While numerical integration is a powerful tool, analytical approximations often provide deeper physical insight and are computationally far less expensive. The Narrow-Width Approximation (NWA) is a cornerstone of theoretical predictions involving sharp resonances. In this final practice , you will quantify the accuracy of the NWA by confronting it with a direct numerical calculation, thereby gaining a practical understanding of its domain of validity and the impact of realistic effects like energy-dependent widths.",
            "id": "3532954",
            "problem": "Consider a single narrow resonance of mass $M$ and total width $\\Gamma(s)$ that contributes to a cross section through the resonant propagator. In the relativistic normalization, the squared propagator near the resonance appears as the factor\n$$\n\\frac{1}{(s - M^2)^2 + \\left(M\\,\\Gamma(s)\\right)^2},\n$$\nwith $s$ the squared center-of-mass energy. The convolution of this resonant shape with a slowly varying production factor $\\sigma(s)$ controls the resonant contribution to an inclusive rate. The Narrow-Width Approximation (NWA) assumes that the width is effectively constant over the resonance region, $\\Gamma(s) \\approx \\Gamma(M^2)$, and that the production factor is slowly varying, so that the following replacement holds to leading order:\n$$\n\\int_{-\\infty}^{+\\infty} ds\\, \\frac{\\sigma(s)}{(s - M^2)^2 + \\left(M\\,\\Gamma(M^2)\\right)^2} \\approx \\sigma(M^2)\\,\\frac{\\pi}{M\\,\\Gamma(M^2)}.\n$$\nYou will test the validity of this approximation when the width is energy dependent via two-body phase space.\n\nFundamental base and definitions:\n1. The resonance shape is defined by the squared propagator factor above.\n2. The energy-dependent width $\\Gamma(s)$ for a two-body decay to identical daughters of mass $m$ is modeled as\n$$\n\\Gamma(s) = \\Gamma_0 \\left(\\frac{\\beta(s)}{\\beta(M^2)}\\right)^p \\left(\\frac{s}{M^2}\\right)^q\\,\\Theta\\left(s - 4 m^2\\right),\n$$\nwhere $\\Gamma_0 \\equiv \\Gamma(M^2)$, $\\beta(s) \\equiv \\sqrt{1 - \\frac{4 m^2}{s}}$ is the usual two-body velocity factor, $p$ and $q$ are dimensionless exponents parametrizing angular momentum and phase-space scaling, and $\\Theta$ is the Heaviside step function.\n3. The production factor is modeled as a slowly varying function\n$$\n\\sigma(s) = \\sigma_0\\left[1 + a \\frac{s - M^2}{M^2}\\right]\\Theta\\left(s - 4 m^2\\right),\n$$\nwith $\\sigma_0$ a constant in picobarns, and $a$ a dimensionless slope parameter controlling mild variation in $s$.\n\nYour tasks:\n1. Implement the numerical convolution\n$$\nI \\equiv \\int_{s_{\\min}}^{s_{\\max}} ds\\, \\frac{\\sigma(s)}{(s - M^2)^2 + \\left(M\\,\\Gamma(s)\\right)^2},\n$$\nwhere the integration bounds are chosen wide enough around the resonance peak to capture the contribution while maintaining numerical stability. Use\n$$\ns_{\\min} = \\max\\left(4 m^2,\\,M^2 - L\\right),\\quad s_{\\max} = M^2 + L,\\quad L = 50\\,M\\,\\Gamma_0,\n$$\nand ensure that the numerical integral uses absolute tolerance $10^{-9}$ and relative tolerance $10^{-7}$. Note that $s$ is in $\\mathrm{GeV}^2$, $M$ and $\\Gamma$ are in $\\mathrm{GeV}$, and $\\sigma$ is in $\\mathrm{pb}$.\n2. Compute the Narrow-Width Approximation estimate\n$$\nI_{\\mathrm{NWA}} \\equiv \\sigma(M^2)\\,\\frac{\\pi}{M\\,\\Gamma_0}.\n$$\n3. For each test case, report the dimensionless relative deviation\n$$\n\\delta \\equiv \\frac{\\left|I - I_{\\mathrm{NWA}}\\right|}{I_{\\mathrm{NWA}}}.\n$$\n\nTest suite:\nUse the following four parameter sets, each expressed in scientifically consistent units:\n- Case A (moderately narrow, massless daughters, mild slope): $M = 91\\,\\mathrm{GeV}$, $\\Gamma_0 = 2.5\\,\\mathrm{GeV}$, $m = 0\\,\\mathrm{GeV}$, $p = 1$, $q = 1$, $\\sigma_0 = 1.0\\,\\mathrm{pb}$, $a = 0.05$.\n- Case B (narrow, massive daughters, flat production): $M = 100\\,\\mathrm{GeV}$, $\\Gamma_0 = 0.5\\,\\mathrm{GeV}$, $m = 10\\,\\mathrm{GeV}$, $p = 1$, $q = 0.5$, $\\sigma_0 = 3.0\\,\\mathrm{pb}$, $a = 0$.\n- Case C (near threshold distortion, moderate width, rising production): $M = 30\\,\\mathrm{GeV}$, $\\Gamma_0 = 3.0\\,\\mathrm{GeV}$, $m = 14\\,\\mathrm{GeV}$, $p = 1$, $q = 0.5$, $\\sigma_0 = 2.0\\,\\mathrm{pb}$, $a = 0.5$.\n- Case D (broad resonance, massless daughters, falling production): $M = 50\\,\\mathrm{GeV}$, $\\Gamma_0 = 20.0\\,\\mathrm{GeV}$, $m = 0\\,\\mathrm{GeV}$, $p = 0$, $q = 0$, $\\sigma_0 = 1.5\\,\\mathrm{pb}$, $a = -0.2$.\n\nAnswer specification:\n- Your program must produce a single line of output containing the four relative deviations $\\delta$ for the cases A, B, C, D as a comma-separated list enclosed in square brackets, in the order listed above. Express the results as decimal floats. For example, an acceptable output format is $[\\delta_A,\\delta_B,\\delta_C,\\delta_D]$.\n\nAngle units do not apply, and no angles are present. Physical units are as stated above. Ensure that all computations respect these units and definitions.",
            "solution": "The problem statement has been validated and is deemed sound, well-posed, and scientifically grounded. It presents a standard computational exercise in high-energy physics, investigating the limits of the Narrow-Width Approximation (NWA). We may therefore proceed with the solution.\n\nThe core task is to compute the relative deviation, $\\delta$, between a numerically calculated integral, $I$, representing a resonant cross section, and its analytical estimate under the NWA, $I_{\\mathrm{NWA}}$. The deviation is defined as:\n$$\n\\delta \\equiv \\frac{\\left|I - I_{\\mathrm{NWA}}\\right|}{I_{\\mathrm{NWA}}}\n$$\n\nThe solution requires implementing the necessary physics functions, performing a numerical integration, and evaluating a simple analytical formula for four distinct test cases.\n\n**1. Definition of Physical Functions**\n\nThe integrand for the numerical convolution is given by\n$$\nf(s) = \\frac{\\sigma(s)}{(s - M^2)^2 + \\left(M\\,\\Gamma(s)\\right)^2}\n$$\nwhere $\\sigma(s)$ is the production factor and $\\Gamma(s)$ is the energy-dependent decay width of the resonance. The resonance has a mass $M$. All calculations are performed with consistent units where masses and widths are in $\\mathrm{GeV}$, their squares are in $\\mathrm{GeV}^2$, and the cross section $\\sigma$ is in $\\mathrm{pb}$.\n\n**1.1. Energy-Dependent Width $\\Gamma(s)$**\n\nThe width $\\Gamma(s)$ is modeled based on two-body decay kinematics. Its form is:\n$$\n\\Gamma(s) = \\Gamma_0 \\left(\\frac{\\beta(s)}{\\beta(M^2)}\\right)^p \\left(\\frac{s}{M^2}\\right)^q\\,\\Theta\\left(s - 4 m^2\\right)\n$$\nHere, $\\Gamma_0$ is the width evaluated at the resonance peak, $s=M^2$. The exponents $p$ and $q$ parametrize model-dependent scaling behaviors. The mass of each of the two identical decay products is $m$. The Heaviside step function, $\\Theta$, ensures the width is non-zero only above the production threshold $s = 4m^2$.\n\nThe key kinematic quantity is the velocity factor $\\beta(s)$, defined as:\n$$\n\\beta(s) \\equiv \\sqrt{1 - \\frac{4 m^2}{s}}\n$$\nThis factor is real-valued only for $s \\ge 4m^2$. The term $\\beta(M^2)$ in the denominator requires the resonance mass $M$ to be greater than the threshold for producing the daughters, i.e., $M > 2m$. All test cases satisfy this condition. For the special case of massless daughters ($m=0$), $\\beta(s)=1$ for all $s > 0$.\n\n**1.2. Production Factor $\\sigma(s)$**\n\nThe production factor $\\sigma(s)$ models the underlying process that creates the resonance. It is approximated as a function that varies linearly with $s$ around the resonance mass squared $M^2$:\n$$\n\\sigma(s) = \\sigma_0\\left[1 + a \\frac{s - M^2}{M^2}\\right]\\Theta\\left(s - 4 m^2\\right)\n$$\nHere, $\\sigma_0$ is a constant cross section in picobarns ($\\mathrm{pb}$), and $a$ is a dimensionless slope parameter. The Heaviside function enforces the same kinematic threshold as for the width.\n\n**2. Numerical Convolution Integral $I$**\n\nThe integral $I$ is computed numerically:\n$$\nI \\equiv \\int_{s_{\\min}}^{s_{\\max}} ds\\, \\frac{\\sigma(s)}{(s - M^2)^2 + \\left(M\\,\\Gamma(s)\\right)^2}\n$$\nThe integration limits are chosen to be wide enough to encompass the entire resonance shape. They are defined as:\n$$\nL = 50\\,M\\,\\Gamma_0\n$$\n$$\ns_{\\min} = \\max\\left(4 m^2,\\,M^2 - L\\right)\n$$\n$$\ns_{\\max} = M^2 + L\n$$\nThe choice of $s_{\\min}$ correctly accounts for the physical production threshold at $s=4m^2$. The numerical integration will be performed using a standard quadrature algorithm, specifically `scipy.integrate.quad`, with a relative tolerance of $10^{-7}$ and an absolute tolerance of $10^{-9}$ as specified. The functions $\\sigma(s)$ and $\\Gamma(s)$ (without the explicit Heaviside factor, which is handled by the integration limit $s_{\\min}$) will be passed to the numerical integrator.\n\n**3. Narrow-Width Approximation $I_{\\mathrm{NWA}}$**\n\nThe NWA simplifies the integral by making two key assumptions:\n1. The width $\\Gamma(s)$ is approximately constant and equal to its value at the peak, $\\Gamma(s) \\approx \\Gamma(M^2) \\equiv \\Gamma_0$.\n2. The production factor $\\sigma(s)$ is slowly varying and can be evaluated at the peak, $\\sigma(s) \\approx \\sigma(M^2)$.\n\nUnder these assumptions, the integral can be extended to $(-\\infty, \\infty)$ and solved analytically:\n$$\n\\int_{-\\infty}^{+\\infty} ds\\, \\frac{\\sigma(M^2)}{(s - M^2)^2 + (M\\Gamma_0)^2} = \\sigma(M^2)\\,\\frac{1}{M\\Gamma_0} \\left[ \\arctan\\left(\\frac{s-M^2}{M\\Gamma_0}\\right) \\right]_{-\\infty}^{+\\infty} = \\sigma(M^2)\\,\\frac{\\pi}{M\\Gamma_0}\n$$\nFrom the definition of $\\sigma(s)$, we have $\\sigma(M^2) = \\sigma_0$. Therefore, the NWA estimate is:\n$$\nI_{\\mathrm{NWA}} \\equiv \\sigma_0\\,\\frac{\\pi}{M\\,\\Gamma_0}\n$$\nThis is a simple algebraic calculation for each test case.\n\n**4. Calculation Procedure**\n\nFor each of the four test cases (A, B, C, D), we will perform the following steps:\n1.  Define the parameters $M, \\Gamma_0, m, p, q, \\sigma_0, a$.\n2.  Implement the functions $\\Gamma(s)$ and $\\sigma(s)$ based on these parameters. These implementations are valid for $s \\ge 4m^2$.\n3.  Combine these into the full integrand $f(s)$.\n4.  Calculate the NWA value $I_{\\mathrm{NWA}}$ using the formula above.\n5.  Determine the integration limits $s_{\\min}$ and $s_{\\max}$.\n6.  Numerically compute the integral $I$ by applying the quadrature routine to $f(s)$ over the interval $[s_{\\min}, s_{\\max}]$.\n7.  Calculate the final relative deviation $\\delta = |I - I_{\\mathrm{NWA}}| / I_{\\mathrm{NWA}}$.\n\nThis procedure will be systematically applied to generate the four required deviation values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing a numerical resonance convolution with the\n    Narrow-Width Approximation (NWA).\n    \"\"\"\n\n    # Test cases as per the problem statement.\n    # Each tuple contains: (M, Gamma0, m, p, q, sigma0, a)\n    test_cases = [\n        # Case A: moderately narrow, massless daughters, mild slope\n        (91.0, 2.5, 0.0, 1.0, 1.0, 1.0, 0.05),\n        # Case B: narrow, massive daughters, flat production\n        (100.0, 0.5, 10.0, 1.0, 0.5, 3.0, 0.0),\n        # Case C: near threshold distortion, moderate width, rising production\n        (30.0, 3.0, 14.0, 1.0, 0.5, 2.0, 0.5),\n        # Case D: broad resonance, massless daughters, falling production\n        (50.0, 20.0, 0.0, 0.0, 0.0, 1.5, -0.2),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        M, Gamma0, m, p, q, sigma0, a = case\n        \n        M2 = M**2\n        threshold_s = 4.0 * m**2\n\n        # Define physics functions valid for s >= threshold_s\n        \n        def beta(s_val, m_val):\n            \"\"\"Calculates the velocity factor beta(s).\"\"\"\n            if m_val == 0.0:\n                return 1.0\n            # s_val is guaranteed to be >= 4*m_val**2 by the integration limits\n            return np.sqrt(1.0 - 4.0 * m_val**2 / s_val)\n\n        beta_M2_val = beta(M2, m)\n\n        def gamma_s(s_val):\n            \"\"\"Calculates the energy-dependent width Gamma(s).\"\"\"\n            if s_val < threshold_s:\n                return 0.0\n\n            if beta_M2_val == 0.0:\n                # This case is avoided by M > 2m, but included for robustness\n                # In this limit, the ratio becomes ill-defined.\n                # A proper treatment would involve L'Hopital's rule, but not needed here.\n                # For a very sharp turn-on, the width would be large. Let's return infinity\n                # to signify a problem, though it won't be triggered.\n                if beta(s_val, m) > 0:\n                   return np.inf\n                else:\n                   return 0.0\n\n            beta_s_val = beta(s_val, m)\n            \n            # Handle the m=0 case where beta terms are 1.\n            # (beta_s/beta_M2)^p term\n            if beta_M2_val == 1.0: # m=0 case\n                beta_ratio_pow_p = 1.0\n            else:\n                 beta_ratio_pow_p = (beta_s_val / beta_M2_val)**p\n\n            # (s/M^2)^q term\n            s_ratio_pow_q = (s_val / M2)**q\n            \n            return Gamma0 * beta_ratio_pow_p * s_ratio_pow_q\n\n        def sigma_s(s_val):\n            \"\"\"Calculates the production factor sigma(s).\"\"\"\n            if s_val < threshold_s:\n                return 0.0\n            return sigma0 * (1.0 + a * (s_val - M2) / M2)\n\n        def integrand(s_val):\n            \"\"\"The full integrand for the numerical convolution.\"\"\"\n            numerator = sigma_s(s_val)\n            denominator = (s_val - M2)**2 + (M * gamma_s(s_val))**2\n            # Avoid division by zero, although denominator is always positive\n            if denominator == 0.0:\n                return np.inf\n            return numerator / denominator\n\n        # 2. Compute the Narrow-Width Approximation estimate\n        # sigma(M^2) = sigma0 since the (s-M^2) term is zero\n        I_nwa = sigma0 * np.pi / (M * Gamma0)\n\n        # 1. Compute the numerical convolution\n        L = 50.0 * M * Gamma0\n        s_min = max(threshold_s, M2 - L)\n        s_max = M2 + L\n\n        # Perform numerical integration\n        I_integral, _ = integrate.quad(\n            integrand, \n            s_min, \n            s_max, \n            epsabs=1e-9, \n            epsrel=1e-7\n        )\n\n        # 3. Compute the relative deviation\n        if I_nwa == 0:\n            # Should not happen with the given parameters\n            deviation = np.inf if I_integral != 0 else 0.0\n        else:\n            deviation = np.abs(I_integral - I_nwa) / I_nwa\n        \n        results.append(deviation)\n\n    # Format the final output as specified\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}