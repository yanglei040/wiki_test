{
    "hands_on_practices": [
        {
            "introduction": "在深入探讨物理现象之前，我们必须首先掌握其数学语言。规范场论的语言根植于李代数。这项实践将指导您以计算的方式构建标准模型中弱电和强相互作用所基于的 $SU(2)$ 和 $SU(3)$ 李代数的生成元和结构常数。通过这个练习，您将巩固对李代数基本性质的理解，正是这些性质决定了规范玻色子之间的相互作用形式，并为整个标准模型的结构奠定了基础。",
            "id": "3537670",
            "problem": "要求您为粒子物理标准模型中出现的特殊酉群 ($SU$) 规范群因子构建李代数生成元和结构常数，特别是用于电弱（EW）部分的 $SU(2)$ 和用于量子色动力学（QCD）的 $SU(3)$，并在基本表示中数值验证它们的定义性质。请在物理学惯例下工作，即李代数生成元是厄米矩阵。您可以假设的基本依据包括以下经过充分检验的事实和定义：\n\n- 特殊酉群 $SU(N)$ 是由行列式为 $1$ 的 $N \\times N$ 酉矩阵构成的群。\n- 其李代数由满足对易关系 $$[T^a, T^b] = i f^{abc} T^c,$$ 的厄米、无迹生成元 $T^a$ 张成，其中 $f^{abc}$ 是代数的实结构常数，重复指标遵循求和约定。\n- 生成元可以被归一化以满足 $$\\mathrm{Tr}(T^a T^b) = \\tfrac{1}{2}\\,\\delta^{ab},$$ 其中 $\\mathrm{Tr}$ 表示矩阵的迹，$\\delta^{ab}$ 是克罗内克δ函数。\n\n您的程序必须：\n- 使用标准矩阵基（Pauli 矩阵和 Gell-Mann 矩阵）为 $SU(2)$ 和 $SU(3)$ 构建基本表示生成元 $\\{T^a\\}$，并进行缩放以满足上述迹归一化条件。\n- 直接根据对易关系和迹内积计算结构常数 $f^{abc}$，不使用任何预先制表的值。\n- 通过从计算出的 $f^{abc}$ 重构对易子 $[T^a, T^b]$ 并与直接的矩阵对易子进行比较来验证对易关系，并为选定的对验证迹归一化。\n\n数值比较必须使用弗罗贝尼乌斯范数和 $\\epsilon = 10^{-12}$ 的容差。\n\n矩阵 $A$ 的弗罗贝尼乌斯范数定义为 $$\\|A\\|_F = \\sqrt{\\sum_{ij} |A_{ij}|^2}.$$\n\n测试套件：\n实现并评估以下五个测试用例，以产生布尔输出。如果所述条件在容差 $\\epsilon$ 内成立，则每个输出为真，否则为假。\n\n- 测试用例 $1$：群 $SU(2)$，对索引 $(a,b) = (1,2)$ 进行对易关系验证。检查 $$\\left\\|[T^1, T^2] - i \\sum_{c=1}^{3} f^{12c} T^c \\right\\|_F  \\epsilon.$$\n- 测试用例 $2$：群 $SU(3)$，对索引 $(a,b) = (1,2)$ 进行对易关系验证。检查 $$\\left\\|[T^1, T^2] - i \\sum_{c=1}^{8} f^{12c} T^c \\right\\|_F  \\epsilon.$$\n- 测试用例 $3$：群 $SU(2)$，对相同索引 $(a,b) = (1,1)$ 的边缘情况对易子进行验证。检查 $$\\left\\|[T^1, T^1]\\right\\|_F  \\epsilon.$$\n- 测试用例 $4$：群 $SU(3)$，对 $(a,b) = (4,4)$ 进行迹归一化验证。检查 $$\\left|\\mathrm{Tr}(T^4 T^4) - \\tfrac{1}{2}\\right|  \\epsilon.$$\n- 测试用例 $5$：群 $SU(3)$，对 $(a,b) = (4,5)$ 进行迹归一化验证。检查 $$\\left|\\mathrm{Tr}(T^4 T^5) - 0\\right|  \\epsilon.$$\n\n最终输出格式：\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,result_3,result_4,result_5]$），其中每个条目是对应测试用例的布尔值。此问题不涉及任何物理单位或角度。",
            "solution": "问题陈述已经过验证，被认为是具有科学依据、提法明确、客观且自洽的。它提出了一个粒子物理学中的标准计算练习，内容涉及与标准模型相关的 $SU(N)$ 规范群的李代数。所有定义、惯例和要求都陈述清晰，并与既有理论一致。因此，可以提供一个解决方案。\n\n任务是为群 $SU(2)$ 和 $SU(3)$ 在基本表示中构建李代数生成元 $T^a$，计算相应的结构常数 $f^{abc}$，并数值验证它们的定义性质。要求生成元是厄米且无迹的，满足对易关系 $[T^a, T^b] = i f^{abc} T^c$ 和归一化条件 $\\mathrm{Tr}(T^a T^b) = \\frac{1}{2}\\delta^{ab}$。\n\n首先，我们构建生成元。$SU(N)$ 的李代数，记为 $\\mathfrak{su}(N)$，其维度为 $N^2-1$。生成元由一个标准的厄米、无迹矩阵基构建，然后进行缩放以满足所需的归一化。\n\n对于 $SU(2)$，代数 $\\mathfrak{su}(2)$ 是 $3$ 维的。一个标准基由 Pauli 矩阵 $\\sigma^a$ 给出：\n$$\n\\sigma^1 = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}, \\quad\n\\sigma^2 = \\begin{pmatrix} 0  -i \\\\ i  0 \\end{pmatrix}, \\quad\n\\sigma^3 = \\begin{pmatrix} 1  0 \\\\ 0  -1 \\end{pmatrix}\n$$\nPauli 矩阵满足关系 $\\mathrm{Tr}(\\sigma^a \\sigma^b) = 2\\delta^{ab}$。为了满足所需的归一化 $\\mathrm{Tr}(T^a T^b) = \\frac{1}{2}\\delta^{ab}$，我们将生成元 $T^a$ 定义为 $T^a = k\\sigma^a$。迹条件变为 $\\mathrm{Tr}((k\\sigma^a)(k\\sigma^b)) = k^2 \\mathrm{Tr}(\\sigma^a\\sigma^b) = k^2(2\\delta^{ab})$。将其设为等于 $\\frac{1}{2}\\delta^{ab}$，得到 $2k^2 = \\frac{1}{2}$，从而得出缩放因子 $k = \\frac{1}{2}$。因此，$SU(2)$ 的生成元是 $T^a = \\frac{1}{2}\\sigma^a$。\n\n对于 $SU(3)$，代数 $\\mathfrak{su}(3)$ 是 $8$ 维的。一个标准基由 Gell-Mann 矩阵 $\\lambda^a$ 提供：\n$$\n\\lambda^1 = \\begin{pmatrix} 0  1  0 \\\\ 1  0  0 \\\\ 0  0  0 \\end{pmatrix}, \\quad\n\\lambda^2 = \\begin{pmatrix} 0  -i  0 \\\\ i  0  0 \\\\ 0  0  0 \\end{pmatrix}, \\quad\n\\lambda^3 = \\begin{pmatrix} 1  0  0 \\\\ 0  -1  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\n$$\n\\lambda^4 = \\begin{pmatrix} 0  0  1 \\\\ 0  0  0 \\\\ 1  0  0 \\end{pmatrix}, \\quad\n\\lambda^5 = \\begin{pmatrix} 0  0  -i \\\\ 0  0  0 \\\\ i  0  0 \\end{pmatrix}, \\quad\n\\lambda^6 = \\begin{pmatrix} 0  0  0 \\\\ 0  0  1 \\\\ 0  1  0 \\end{pmatrix}\n$$\n$$\n\\lambda^7 = \\begin{pmatrix} 0  0  0 \\\\ 0  0  -i \\\\ 0  i  0 \\end{pmatrix}, \\quad\n\\lambda^8 = \\frac{1}{\\sqrt{3}}\\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  -2 \\end{pmatrix}\n$$\n这些矩阵也满足关系 $\\mathrm{Tr}(\\lambda^a \\lambda^b) = 2\\delta^{ab}$。与 $SU(2)$ 的逻辑相同，对于 $SU(3)$，正确归一化的生成元是 $T^a = \\frac{1}{2}\\lambda^a$。\n\n接下来，我们设计一种直接从生成元计算结构常数 $f^{abc}$ 的方法。从对易关系 $[T^a, T^b] = i f^{abc} T^c$（对 $c$ 求和）开始，我们可以利用生成元的正交归一性来分离出特定的结构常数，例如 $f^{abk}$。我们将两边乘以 $T^k$ 并取迹：\n$$\n\\mathrm{Tr}([T^a, T^b] T^k) = \\mathrm{Tr}(i f^{abc} T^c T^k) = i \\sum_c f^{abc} \\mathrm{Tr}(T^c T^k)\n$$\n使用归一化条件 $\\mathrm{Tr}(T^c T^k) = \\frac{1}{2}\\delta^{ck}$：\n$$\n\\mathrm{Tr}([T^a, T^b] T^k) = i \\sum_c f^{abc} (\\tfrac{1}{2}\\delta^{ck}) = i \\tfrac{1}{2} f^{abk}\n$$\n解出 $f^{abk}$：\n$$\nf^{abk} = \\frac{2}{i} \\mathrm{Tr}([T^a, T^b] T^k) = -2i \\, \\mathrm{Tr}([T^a, T^b] T^k)\n$$\n由于生成元 $T^a$ 是厄米矩阵，对易子 $[T^a, T^b]$ 是反厄米矩阵。一个反厄米矩阵与一个厄米矩阵相乘的迹是纯虚数。因此，乘以 $-2i$ 会得到所要求的实值结构常数 $f^{abc}$。这个公式允许通过遍历所有索引 $a$、$b$ 和 $c$ 来直接计算所有结构常数。\n\n最后一步是执行测试套件中指定的数值验证。这涉及在代码中实现所述的构造和计算。\n创建一个函数来生成 $N=2$ 和 $N=3$ 的 $SU(N)$ 的性质。该函数首先构造缩放后的生成元矩阵 $\\{T^a\\}$。然后，它遍历所有索引组合，使用推导出的公式计算结构常数张量 $f^{abc}$。\n\n然后评估五个测试用例：\n1.  对于 $SU(2)$ 和索引 $(a,b)=(1,2)$，我们计算差分矩阵 $D = [T^1, T^2] - i \\sum_{c=1}^{3} f^{12c} T^c$，并验证其弗罗贝尼乌斯范数 $\\|D\\|_F$ 小于容差 $\\epsilon = 10^{-12}$。弗罗贝尼乌斯范数定义为 $\\|A\\|_F = \\sqrt{\\sum_{i,j} |A_{ij}|^2}$。\n2.  对 $SU(3)$ 和索引 $(a,b)=(1,2)$ 进行相同的验证，其中求和现在从 $c=1$ 到 $8$。\n3.  对于 $SU(2)$ 和 $(a,b)=(1,1)$，我们通过检查 $\\|[T^1, T^1]\\|_F  \\epsilon$ 来验证对易子 $[T^1, T^1]$ 在数值上是零矩阵。\n4.  对于 $SU(3)$ 和 $(a,b)=(4,4)$，我们通过验证 $|\\mathrm{Tr}(T^4 T^4) - \\frac{1}{2}|  \\epsilon$ 来测试迹归一化。\n5.  对于 $SU(3)$ 和 $(a,b)=(4,5)$，我们通过验证 $|\\mathrm{Tr}(T^4 T^5) - 0|  \\epsilon$ 来测试迹正交性。\n\n该实现利用 `numpy` 进行复数矩阵代数运算。问题陈述中的索引是基于1的，在代码中为了数组访问被转换为基于0的索引。",
            "answer": "```python\nimport numpy as np\n\ndef get_su_n_properties(N, cache):\n    \"\"\"\n    Constructs generators and structure constants for SU(N).\n    Results are cached to avoid recomputation.\n    \"\"\"\n    if N in cache:\n        return cache[N]\n\n    if N == 2:\n        dim = 3\n        # Pauli matrices\n        s1 = np.array([[0, 1], [1, 0]], dtype=complex)\n        s2 = np.array([[0, -1j], [1j, 0]], dtype=complex)\n        s3 = np.array([[1, 0], [0, -1]], dtype=complex)\n        # Scale to satisfy Tr(T^a T^b) = 0.5 * delta_ab\n        generators = [0.5 * s1, 0.5 * s2, 0.5 * s3]\n    elif N == 3:\n        dim = 8\n        # Gell-Mann matrices\n        l1 = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 0]], dtype=complex)\n        l2 = np.array([[0, -1j, 0], [1j, 0, 0], [0, 0, 0]], dtype=complex)\n        l3 = np.array([[1, 0, 0], [0, -1, 0], [0, 0, 0]], dtype=complex)\n        l4 = np.array([[0, 0, 1], [0, 0, 0], [1, 0, 0]], dtype=complex)\n        l5 = np.array([[0, 0, -1j], [0, 0, 0], [1j, 0, 0]], dtype=complex)\n        l6 = np.array([[0, 0, 0], [0, 0, 1], [0, 1, 0]], dtype=complex)\n        l7 = np.array([[0, 0, 0], [0, 0, -1j], [0, 1j, 0]], dtype=complex)\n        l8 = np.array([[1, 0, 0], [0, 1, 0], [0, 0, -2]], dtype=complex) / np.sqrt(3)\n        gell_mann_matrices = [l1, l2, l3, l4, l5, l6, l7, l8]\n        # Scale to satisfy Tr(T^a T^b) = 0.5 * delta_ab\n        generators = [0.5 * lm for lm in gell_mann_matrices]\n    else:\n        raise NotImplementedError(\"Only SU(2) and SU(3) are supported.\")\n\n    # Compute structure constants f^abc = -2i * Tr([T^a, T^b] T^c)\n    f_abc = np.zeros((dim, dim, dim), dtype=float)\n    for a in range(dim):\n        for b in range(dim):\n            # Commutator [T^a, T^b]\n            comm = generators[a] @ generators[b] - generators[b] @ generators[a]\n            if np.linalg.norm(comm)  1e-15:  # Avoid computation for zero commutators\n                for c in range(dim):\n                    # The result of the trace is purely imaginary\n                    val = -2j * np.trace(comm @ generators[c])\n                    # Structure constants are real\n                    f_abc[a, b, c] = np.real(val)\n\n    result = {\n        \"N\": N,\n        \"dim\": dim,\n        \"generators\": generators,\n        \"structure_constants\": f_abc,\n    }\n    cache[N] = result\n    return result\n\ndef solve():\n    \"\"\"\n    Main function to construct SU(N) properties and run verification tests.\n    \"\"\"\n    epsilon = 1e-12\n    su_n_cache = {}\n    results = []\n\n    # Test case 1: SU(2), commutation verification for (a,b) = (1,2)\n    su2 = get_su_n_properties(2, su_n_cache)\n    T = su2[\"generators\"]\n    f = su2[\"structure_constants\"]\n    a, b = 1 - 1, 2 - 1  # 0-based indices\n    lhs1 = T[a] @ T[b] - T[b] @ T[a]\n    rhs1_sum_term = np.zeros((2, 2), dtype=complex)\n    for c in range(su2[\"dim\"]):\n        rhs1_sum_term += f[a, b, c] * T[c]\n    rhs1 = 1j * rhs1_sum_term\n    norm1 = np.linalg.norm(lhs1 - rhs1, 'fro')\n    results.append(norm1  epsilon)\n    \n    # Test case 2: SU(3), commutation verification for (a,b) = (1,2)\n    su3 = get_su_n_properties(3, su_n_cache)\n    T = su3[\"generators\"]\n    f = su3[\"structure_constants\"]\n    a, b = 1 - 1, 2 - 1  # 0-based indices\n    lhs2 = T[a] @ T[b] - T[b] @ T[a]\n    rhs2_sum_term = np.zeros((3, 3), dtype=complex)\n    for c in range(su3[\"dim\"]):\n        rhs2_sum_term += f[a, b, c] * T[c]\n    rhs2 = 1j * rhs2_sum_term\n    norm2 = np.linalg.norm(lhs2 - rhs2, 'fro')\n    results.append(norm2  epsilon)\n\n    # Test case 3: SU(2), edge-case commutator for (a,b) = (1,1)\n    T = su2[\"generators\"]\n    a = 1 - 1  # 0-based index\n    comm3 = T[a] @ T[a] - T[a] @ T[a]\n    norm3 = np.linalg.norm(comm3, 'fro')\n    results.append(norm3  epsilon)\n\n    # Test case 4: SU(3), trace normalization for (a,b) = (4,4)\n    T = su3[\"generators\"]\n    a, b = 4 - 1, 4 - 1  # 0-based indices\n    trace4 = np.trace(T[a] @ T[b])\n    results.append(np.abs(trace4 - 0.5)  epsilon)\n    \n    # Test case 5: SU(3), trace normalization for (a,b) = (4,5)\n    T = su3[\"generators\"]\n    a, b = 4 - 1, 5 - 1  # 0-based indices\n    trace5 = np.trace(T[a] @ T[b])\n    results.append(np.abs(trace5 - 0.0)  epsilon)\n\n    # Format and print the final output as a list of booleans.\n    # Python's str(True) is 'True', which is acceptable.\n    # To get 'true', map {True: 'true', False: 'false'}.get\n    # For this problem, 'True'/'False' seems fine.\n    print(f\"[{','.join(map(lambda x: str(x).lower(), results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "希格斯机制是标准模型的核心，它解释了基本粒子质量的起源。这项核心实践将引导您从拉格朗日量出发，自动推导在电弱对称性破缺后规范玻色子和费米子的质量矩阵。通过对这些矩阵进行数值对角化，您不仅能计算出粒子质量，还将揭示夸克和轻子领域中味道混合的根源——即 CKM 和 PMNS 矩阵的由来，这是粒子物理现象学的基石。",
            "id": "3537729",
            "problem": "设计并实现一个程序，从粒子物理标准模型的对称性结构和相互作用内容出发，自动提取电弱对称性破缺后的质量矩阵和物理混合矩阵。目标是计算上实现以下推理链：\n1. 利用规范群为 $\\mathrm{SU}(2)_L \\times \\mathrm{U}(1)_Y$ 的标准模型的规范对称性结构以及复标量希格斯二重态的存在，确定规范玻色子在自发对称性破缺后如何获得质量。\n2. 利用具有三代费米子的标准模型的广义复数汤川扇形，确定在希格斯场获得真空期望值后费米子如何获得质量。\n3. 对于广义复数汤川耦合矩阵，执行适当的双幺正对角化，以获得费米子质量本征值以及夸克和轻子扇形中的物理味混合矩阵：Cabibbo–Kobayashi–Maskawa (CKM) 矩阵和 Pontecorvo–Maki–Nakagawa–Sakata (PMNS) 矩阵。\n\n您的程序必须仅使用线性代数运算和基于拉格朗日量的定义来实现以下内容：\n- 从希格斯二重态的规范不变动能项和协变导数出发，推导希格斯二重态获得真空期望值后的规范玻色子质量项，并计算有质量本征态及其质量。您必须计算带电弱玻色子 $W^\\pm$ 和中性弱玻色子 $Z$ 的质量，并验证由底层对称性破缺模式得出的树图级电弱关系。\n- 从包含上型夸克、下型夸克、带电轻子和中微子（此处视为狄拉克费米子）三代费米子的广义汤川扇形出发，推导电弱对称性破缺后的费米子质量矩阵，并对每个扇形执行双幺正对角化以获得质量本征值和左手幺正变换。使用这些左手变换构造 CKM 和 PMNS 矩阵。\n- 定量测试 CKM 和 PMNS 矩阵的幺正性，并为每个矩阵计算一个 $\\mathcal{CP}$ 破坏的重定相位不变量度（Jarlskog 不变量）。\n\n您在此任务中必须遵守的物理和数学约束：\n- 使用以 $\\mathrm{GeV}$ 为单位的希格斯真空期望值 $v$，无量纲参数的规范耦合 $g$ 和 $g'$，以及无量纲的 $3 \\times 3$ 复数矩阵的汤川矩阵。所得的规范玻色子质量必须以 $\\mathrm{GeV}$ 表示。\n- 希格斯场是一个超荷为 $Y = 1/2$ 的复 $\\mathrm{SU}(2)_L$ 二重态。作用于希格斯二重态的协变导数为 $D_\\mu = \\partial_\\mu - i g T^a W_\\mu^a - i g' Y B_\\mu$，其中 $T^a$ 是基本表示中的 $\\mathrm{SU}(2)$ 生成元，$B_\\mu$ 是 $\\mathrm{U}(1)_Y$ 规范玻色子。\n- 汤川扇形包含与规范不变性一致的最广义的 $3 \\times 3$ 复数耦合矩阵。\n- 以数值方式执行所有对角化。味混合所需的左手幺正矩阵应从每个汤川矩阵的双幺正对角化中获得。\n\n算法设计所需的定义：\n- 令 $Y_u$、$Y_d$、$Y_e$ 和 $Y_\\nu$ 表示 $3 \\times 3$ 复数汤川矩阵，令 $v$ 表示希格斯真空期望值。电弱对称性破缺后，费米子质量矩阵与汤川矩阵成正比，对每个汤川矩阵进行双幺正对角化可得到定义可观测味混合的左手幺正矩阵。CKM 矩阵定义为 $V_\\mathrm{CKM} = U_{u,L}^\\dagger U_{d,L}$，PMNS 矩阵定义为 $U_\\mathrm{PMNS} = U_{e,L}^\\dagger U_{\\nu,L}$，其中 $U_{f,L}$ 表示对 $f$ 型费米子的汤川矩阵进行双幺正对角化得到的左手幺正因子。\n- Jarlskog 不变量可以从任意一组指标计算得出，即混合矩阵的四个矩阵元的虚部，例如，对于夸克扇形为 $J = \\mathrm{Im}\\!\\left(V_{11} V_{22} V_{12}^\\ast V_{21}^\\ast\\right)$，对于轻子扇形也类似。该量在费米子场的重定相位下是不变的。\n- 弱混合角定义为 $\\cos\\theta_W = g / \\sqrt{g^2 + g'^2}$。由对称性破缺模式所蕴含的树图级电弱关系由比值 $\\rho \\equiv m_W / \\left(m_Z \\cos\\theta_W\\right)$ 编码。\n\n数值和输出要求：\n- 对下面的每个测试用例，计算：\n  1. 质量 $m_W$ 和 $m_Z$（单位为 $\\mathrm{GeV}$），四舍五入到三位小数。\n  2. 一个布尔值，指示树图级关系 $\\rho = 1$ 是否在 $10^{-12}$ 的绝对容差内成立。\n  3. 一个布尔值，指示 $V_\\mathrm{CKM}$ 是否在 $10^{-12}$ 的容差内是幺正的，通过弗罗贝尼乌斯范数 $\\left\\|V^\\dagger V - \\mathbb{1}\\right\\|_F$ 进行量化。\n  4. 一个布尔值，指示 $U_\\mathrm{PMNS}$ 是否在 $10^{-12}$ 的容差内是幺正的。\n  5. CKM 矩阵和 PMNS 矩阵的 Jarlskog 不变量，每个都四舍五入到十位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个条目对应一个测试用例，本身是按以下顺序排列的列表：$[m_W, m_Z, \\text{rho\\_ok}, \\text{ckm\\_unitary}, \\text{pmns\\_unitary}, J_\\mathrm{CKM}, J_\\mathrm{PMNS}]$。\n- 所有角度（如果在内部使用）必须以弧度为单位。所有报告的质量必须以 $\\mathrm{GeV}$ 为单位。\n\n测试套件：\n提供以下三个测试用例的结果。每个测试用例是一个元组 $(v, g, g', Y_u, Y_d, Y_e, Y_\\nu)$。\n\n- 测试用例 A（广义复数汤川矩阵，典型的电弱尺度参数）：\n  - $v = 246.0\\ \\mathrm{GeV}$，$g = 0.65$，$g' = 0.36$。\n  - $Y_u = \\begin{pmatrix}\n  1.20\\times 10^{-5}  3.10\\times 10^{-3}(1+0.5 i)  -1.50\\times 10^{-2} i \\\\\n  2.50\\times 10^{-5}(1-0.3 i)  7.50\\times 10^{-3}  1.20\\times 10^{-2}(1+0.2 i) \\\\\n  1.10\\times 10^{-4}  -2.20\\times 10^{-2}(1-0.4 i)  9.50\\times 10^{-1}\n  \\end{pmatrix}$。\n  - $Y_d = \\begin{pmatrix}\n  1.00\\times 10^{-5}  2.00\\times 10^{-4}(1-0.2 i)  -3.00\\times 10^{-4} i \\\\\n  4.00\\times 10^{-5}(1+0.1 i)  6.00\\times 10^{-4}  3.50\\times 10^{-3}(1-0.1 i) \\\\\n  2.00\\times 10^{-4}  -5.00\\times 10^{-3}(1+0.3 i)  2.50\\times 10^{-2}\n  \\end{pmatrix}$。\n  - $Y_e = \\begin{pmatrix}\n  3.00\\times 10^{-6}(1+0.1 i)  1.00\\times 10^{-5}  -2.00\\times 10^{-5} i \\\\\n  2.00\\times 10^{-6}(1-0.2 i)  6.00\\times 10^{-4}  1.00\\times 10^{-3}(1+0.3 i) \\\\\n  1.00\\times 10^{-5}  -2.00\\times 10^{-3}(1-0.1 i)  1.02\\times 10^{-2}\n  \\end{pmatrix}$。\n  - $Y_\\nu = \\begin{pmatrix}\n  1.00\\times 10^{-8}  2.00\\times 10^{-8}(1+0.4 i)  -1.00\\times 10^{-8} i \\\\\n  3.00\\times 10^{-8}(1-0.5 i)  5.00\\times 10^{-8}  2.00\\times 10^{-7}(1+0.1 i) \\\\\n  1.00\\times 10^{-7}  -4.00\\times 10^{-7}(1-0.2 i)  1.00\\times 10^{-6}\n  \\end{pmatrix}$。\n\n- 测试用例 B（边界情况，超荷耦合为零且汤川矩阵为对角实数）：\n  - $v = 246.0\\ \\mathrm{GeV}$，$g = 0.70$，$g' = 0.0$。\n  - $Y_u = \\mathrm{diag}(1.30\\times 10^{-5}, 6.30\\times 10^{-3}, 9.90\\times 10^{-1})$。\n  - $Y_d = \\mathrm{diag}(2.50\\times 10^{-5}, 5.00\\times 10^{-4}, 2.00\\times 10^{-2})$。\n  - $Y_e = \\mathrm{diag}(2.80\\times 10^{-6}, 5.90\\times 10^{-4}, 1.00\\times 10^{-2})$。\n  - $Y_\\nu = \\mathrm{diag}(1.00\\times 10^{-8}, 2.00\\times 10^{-8}, 3.00\\times 10^{-8})$。\n\n- 测试用例 C（数值稳定性，具有近简并和小复数非对角元）：\n  - $v = 100.0\\ \\mathrm{GeV}$，$g = 0.50$，$g' = 0.50$。\n  - $Y_u = \\begin{pmatrix}\n  1.000000\\times 10^{-1}  1.00\\times 10^{-5}(1+0.2 i)  -2.00\\times 10^{-5} i \\\\\n  1.00\\times 10^{-5}(1-0.3 i)  1.000002\\times 10^{-1}  3.00\\times 10^{-5}(1+0.1 i) \\\\\n  2.00\\times 10^{-5}  -1.00\\times 10^{-5}(1-0.4 i)  5.00\\times 10^{-1}\n  \\end{pmatrix}$。\n  - $Y_d = \\begin{pmatrix}\n  2.00\\times 10^{-2}  5.00\\times 10^{-6}(1-0.2 i)  0 \\\\\n  5.00\\times 10^{-6}(1+0.3 i)  2.000010\\times 10^{-2}  1.00\\times 10^{-5}(1-0.1 i) \\\\\n  0  2.00\\times 10^{-5}(1+0.2 i)  1.00\\times 10^{-1}\n  \\end{pmatrix}$。\n  - $Y_e = \\mathrm{diag}(3.00\\times 10^{-4}, 6.00\\times 10^{-3}, 1.00\\times 10^{-2})$。\n  - $Y_\\nu = \\begin{pmatrix}\n  1.00\\times 10^{-5}  2.00\\times 10^{-5}(1+0.5 i)  -3.00\\times 10^{-6} i \\\\\n  2.00\\times 10^{-5}(1-0.1 i)  3.00\\times 10^{-5}  1.00\\times 10^{-5}(1+0.2 i) \\\\\n  -1.00\\times 10^{-5} i  2.00\\times 10^{-5}(1-0.3 i)  4.00\\times 10^{-5}\n  \\end{pmatrix}$。\n\n最终输出格式：\n- 您的程序必须输出一行，其中包含一个含三个条目（每个测试用例一个）的列表。每个条目必须是一个严格按以下顺序排列的列表：\n  - $m_W$（单位为 $\\mathrm{GeV}$），四舍五入到三位小数，\n  - $m_Z$（单位为 $\\mathrm{GeV}$），四舍五入到三位小数，\n  - $\\text{rho\\_ok}$，布尔值，\n  - $\\text{ckm\\_unitary}$，布尔值，\n  - $\\text{pmns\\_unitary}$，布尔值，\n  - $J_\\mathrm{CKM}$，四舍五入到十位小数，\n  - $J_\\mathrm{PMNS}$，四舍五入到十位小数。\n例如，最终打印的行应类似于：\n[[mW_A,mZ_A,True,True,True,Jckm_A,Jpmns_A],[mW_B,mZ_B,True,True,True,Jckm_B,Jpmns_B],[mW_C,mZ_C,True,True,True,Jckm_C,Jpmns_C]]",
            "solution": "该问题要求设计并实现一个算法，从标准模型拉格朗日量的基本参数出发，计算规范玻色子质量、费米子混合矩阵（CKM 和 PMNS）以及相关的物理量。该过程遵循电弱对称性破缺的推论。\n\n**1. 规范玻色子质量的生成**\n\n规范玻色子的质量来源于希格斯二重态的动能项 $\\mathcal{L}_{\\text{Higgs, kin}} = (D_\\mu \\Phi)^\\dagger (D^\\mu \\Phi)$，当希格斯场 $\\Phi$ 获得一个非零的真空期望值 (VEV) 时。希格斯场是一个弱超荷为 $Y = 1/2$ 的 $\\mathrm{SU}(2)_L$ 二重态。其协变导数由下式给出：\n$$\nD_\\mu = \\partial_\\mu - i g T^a W_\\mu^a - i g' Y B_\\mu\n$$\n其中 $g$ 和 $g'$ 分别是 $\\mathrm{SU}(2)_L$ 和 $\\mathrm{U}(1)_Y$ 的规范耦合，$W_\\mu^a$ ($a=1,2,3$) 是 $\\mathrm{SU}(2)_L$ 规范场，$B_\\mu$ 是 $\\mathrm{U}(1)_Y$ 规范场，$T^a = \\sigma^a/2$ 是 $\\mathrm{SU}(2)$ 生成元（其中 $\\sigma^a$ 是泡利矩阵）。\n\n在自发对称性破缺后，希格斯场获得一个 VEV，在幺正规范下可以写为：\n$$\n\\langle \\Phi \\rangle = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0 \\\\ v \\end{pmatrix}\n$$\n其中 $v$ 是希格斯 VEV，作为一个以 $\\mathrm{GeV}$ 为单位的参数给出。将此代入希格斯动能项，由于 VEV 是常数，导数部分 $\\partial_\\mu \\langle \\Phi \\rangle$ 为零。该项变为：\n$$\n\\mathcal{L}_{\\text{mass}} = \\left| \\left( - i g \\frac{\\sigma^a}{2} W_\\mu^a - i g' \\frac{1}{2} B_\\mu \\right) \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0 \\\\ v \\end{pmatrix} \\right|^2\n$$\n计算矩阵-向量乘积得到：\n$$\n\\left( g \\frac{\\sigma^a}{2} W_\\mu^a + g' \\frac{1}{2} B_\\mu \\right) \\begin{pmatrix} 0 \\\\ v \\end{pmatrix} = \\frac{v}{2} \\begin{pmatrix} g(W_\\mu^1 - iW_\\mu^2) \\\\ -g W_\\mu^3 + g' B_\\mu \\end{pmatrix}\n$$\n将带电弱玻色子场定义为 $W_\\mu^\\pm = \\frac{1}{\\sqrt{2}}(W_\\mu^1 \\mp iW_\\mu^2)$，表达式简化为：\n$$\n\\frac{v}{2} \\begin{pmatrix} g \\sqrt{2} W_\\mu^+ \\\\ -g W_\\mu^3 + g' B_\\mu \\end{pmatrix}\n$$\n将此代回拉格朗日项并取其范数的平方，得到：\n$$\n\\mathcal{L}_{\\text{mass}} = \\frac{1}{2} \\frac{v^2}{4} \\left( 2g^2 W_\\mu^+ W^{\\mu-} + (-g W_\\mu^3 + g' B_\\mu)^2 \\right) = \\frac{g^2v^2}{4} W_\\mu^+ W^{\\mu-} + \\frac{v^2}{8} (g W_\\mu^3 - g' B_\\mu)^2\n$$\n从这个表达式中，我们可以识别出质量项。对于复矢量场 $W^\\pm$，质量项为 $m_W^2 W_\\mu^+ W^{\\mu-}$，这意味着 $W$ 玻色子的质量平方为 $m_W^2 = \\frac{g^2v^2}{4}$，因此质量为：\n$$\nm_W = \\frac{g v}{2}\n$$\n中性规范玻色子 $W_\\mu^3$ 和 $B_\\mu$ 发生混合。它们的质量项可以写成矩阵形式 $\\frac{1}{2} \\begin{pmatrix} W_\\mu^3  B_\\mu \\end{pmatrix} M^2 \\begin{pmatrix} W^{\\mu 3} \\\\ B^\\mu \\end{pmatrix}$，其中质量平方矩阵为：\n$$\nM^2 = \\frac{v^2}{4} \\begin{pmatrix} g^2  -gg' \\\\ -gg'  g'^2 \\end{pmatrix}\n$$\n该矩阵的本征值是物理中性玻色子的质量平方。特征方程 $\\det(M^2 - \\lambda \\mathbb{1}) = 0$ 产生本征值 $\\lambda_1 = 0$ 和 $\\lambda_2 = \\frac{v^2}{4}(g^2+g'^2)$。无质量的本征态是光子 ($A_\\mu$)，有质量的本征态是 $Z$ 玻色子，其质量为：\n$$\nm_Z = \\frac{v \\sqrt{g^2+g'^2}}{2}\n$$\n弱混合角 $\\theta_W$ 由 $\\cos\\theta_W = g/\\sqrt{g^2+g'^2}$ 定义。$\\rho$ 参数 $\\rho = m_W/(m_Z \\cos\\theta_W)$ 是一个关键预测。代入我们的结果：\n$$\n\\rho = \\frac{g v/2}{(v\\sqrt{g^2+g'^2}/2) \\cdot (g/\\sqrt{g^2+g'^2})} = \\frac{g}{g} = 1\n$$\n这个 $\\rho = 1$ 的关系是使用单个标量二重态的希格斯机制的直接结果，并且必须在树图级成立。\n\n**2. 费米子质量生成和混合矩阵推导**\n\n费米子质量来源于拉格朗日量的汤川扇形。对于三代费米子，汤川耦合由每个费米子类型 $f \\in \\{u, d, e, \\nu\\}$ 的广义 $3 \\times 3$ 复数矩阵 $Y_f$ 描述。汤川拉格朗日量包含诸如 $- Y_d^{ij} \\bar{Q}_L^i \\Phi d_R^j + \\text{h.c.}$ 的项，其中 $Q_L$ 是一个左手夸克二重态。当 $\\Phi$ 获得其 VEV $\\langle\\Phi\\rangle = (0, v/\\sqrt{2})^T$ 时，中性分量与下型夸克耦合，生成质量矩阵 $M_d = \\frac{v}{\\sqrt{2}} Y_d$。使用 $\\Phi$ 或其共轭 $\\tilde{\\Phi}$ 的类似机制为所有费米子类型提供了质量矩阵：\n$$\nM_f = \\frac{v}{\\sqrt{2}} Y_f\n$$\n这些质量矩阵通常不是厄米矩阵。为了找到具有确定质量的物理质量本征态，我们必须使用双幺正变换对 $M_f$ 进行对角化，这等效于奇异值分解 (SVD)：\n$$\nM_f = U_{f,L} \\Sigma_f U_{f,R}^\\dagger\n$$\n此处，$U_{f,L}$ 和 $U_{f,R}$ 是幺正矩阵，它们分别将左手和右手的味本征态场旋转为质量本征态场。$\\Sigma_f$ 是一个由实数、非负质量本征值组成的对角矩阵。幺正矩阵 $U_{f,L}$ 直接从汤川矩阵 $Y_f$ 的 SVD 中获得。\n\n弱带电流相互作用耦合了左手味本征态（例如 $\\bar{u}'_L \\gamma^\\mu d'_L$）。在质量基矢 ($\\psi'_L = U_{\\psi,L} \\psi_L$) 中表示这些场，揭示了相互作用项中的一个混合矩阵：\n$$\n\\bar{u}'_L \\gamma^\\mu d'_L = (\\bar{u}_L U_{u,L}^\\dagger) \\gamma^\\mu (U_{d,L} d_L) = \\bar{u}_L \\gamma^\\mu (U_{u,L}^\\dagger U_{d,L}) d_L\n$$\n因此，Cabibbo-Kobayashi-Maskawa (CKM) 矩阵是 $V_{\\text{CKM}} = U_{u,L}^\\dagger U_{d,L}$。类似地，在轻子扇形中，问题将 Pontecorvo-Maki-Nakagawa-Sakata (PMNS) 矩阵定义为 $U_{\\text{PMNS}} = U_{e,L}^\\dagger U_{\\nu,L}$。\n\n**3. 幺正性和 $\\mathcal{CP}$ 破坏**\n\nCKM 和 PMNS 矩阵作为幺正矩阵的乘积，其本身也必须是幺正的 ($V^\\dagger V = \\mathbb{1}$)。这是一个基本的一致性检查。我们通过计算与单位矩阵偏差的弗罗贝尼乌斯范数 $\\left\\|V^\\dagger V - \\mathbb{1}\\right\\|_F$ 来量化这一点，并检查其是否在指定的容差内接近于零。\n\n如果混合矩阵包含一个不能通过重定费米子场相位来吸收的复相位，它将导致 $\\mathcal{CP}$ 破坏。对此的一个重定相位不变量度是 Jarlskog 不变量 $J$。对于一个 $3 \\times 3$ 的幺正矩阵 $V$，它可以计算为：\n$$\nJ = \\mathrm{Im}\\!\\left(V_{11} V_{22} V_{12}^\\ast V_{21}^\\ast\\right)\n$$\n$J$ 的非零值表示相应扇形中存在 $\\mathcal{CP}$ 破坏。对于所提供的具有对角汤川矩阵的测试用例，左手幺正矩阵是单位矩阵，导致混合矩阵也是单位矩阵，Jarlskog 不变量为 $0$。\n\n所实现的算法将首先根据 $v, g, g'$ 计算 $m_W$ 和 $m_Z$。然后，对每个费米子扇形，它将对汤川矩阵 $Y_f$ 执行 SVD 以获得 $U_{f,L}$。这些矩阵被组合起来构造 $V_{\\text{CKM}}$ 和 $U_{\\text{PMNS}}$。最后，计算这些混合矩阵的幺正性和 Jarlskog 不变量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes gauge boson masses, fermion mixing matrices (CKM, PMNS),\n    and related physical quantities from Standard Model parameters.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases_data = [\n        # Test Case A\n        {\n            \"v\": 246.0, \"g\": 0.65, \"g_prime\": 0.36,\n            \"Yu\": np.array([\n                [1.20e-5, 3.10e-3*(1+0.5j), -1.50e-2j],\n                [2.50e-5*(1-0.3j), 7.50e-3, 1.20e-2*(1+0.2j)],\n                [1.10e-4, -2.20e-2*(1-0.4j), 9.50e-1]\n            ], dtype=complex),\n            \"Yd\": np.array([\n                [1.00e-5, 2.00e-4*(1-0.2j), -3.00e-4j],\n                [4.00e-5*(1+0.1j), 6.00e-4, 3.50e-3*(1-0.1j)],\n                [2.00e-4, -5.00e-3*(1+0.3j), 2.50e-2]\n            ], dtype=complex),\n            \"Ye\": np.array([\n                [3.00e-6*(1+0.1j), 1.00e-5, -2.00e-5j],\n                [2.00e-6*(1-0.2j), 6.00e-4, 1.00e-3*(1+0.3j)],\n                [1.00e-5, -2.00e-3*(1-0.1j), 1.02e-2]\n            ], dtype=complex),\n            \"Ynu\": np.array([\n                [1.00e-8, 2.00e-8*(1+0.4j), -1.00e-8j],\n                [3.00e-8*(1-0.5j), 5.00e-8, 2.00e-7*(1+0.1j)],\n                [1.00e-7, -4.00e-7*(1-0.2j), 1.00e-6]\n            ], dtype=complex)\n        },\n        # Test Case B\n        {\n            \"v\": 246.0, \"g\": 0.70, \"g_prime\": 0.0,\n            \"Yu\": np.diag([1.30e-5, 6.30e-3, 9.90e-1]).astype(complex),\n            \"Yd\": np.diag([2.50e-5, 5.00e-4, 2.00e-2]).astype(complex),\n            \"Ye\": np.diag([2.80e-6, 5.90e-4, 1.00e-2]).astype(complex),\n            \"Ynu\": np.diag([1.00e-8, 2.00e-8, 3.00e-8]).astype(complex)\n        },\n        # Test Case C\n        {\n            \"v\": 100.0, \"g\": 0.50, \"g_prime\": 0.50,\n            \"Yu\": np.array([\n                [1.000000e-1, 1.00e-5*(1+0.2j), -2.00e-5j],\n                [1.00e-5*(1-0.3j), 1.000002e-1, 3.00e-5*(1+0.1j)],\n                [2.00e-5, -1.00e-5*(1-0.4j), 5.00e-1]\n            ], dtype=complex),\n            \"Yd\": np.array([\n                [2.00e-2, 5.00e-6*(1-0.2j), 0],\n                [5.00e-6*(1+0.3j), 2.000010e-2, 1.00e-5*(1-0.1j)],\n                [0, 2.00e-5*(1+0.2j), 1.00e-1]\n            ], dtype=complex),\n            \"Ye\": np.diag([3.00e-4, 6.00e-3, 1.00e-2]).astype(complex),\n            \"Ynu\": np.array([\n                [1.00e-5, 2.00e-5*(1+0.5j), -3.00e-6j],\n                [2.00e-5*(1-0.1j), 3.00e-5, 1.00e-5*(1+0.2j)],\n                [-1.00e-5j, 2.00e-5*(1-0.3j), 4.00e-5]\n            ], dtype=complex)\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases_data:\n        v = case[\"v\"]\n        g = case[\"g\"]\n        gp = case[\"g_prime\"]\n        Yu = case[\"Yu\"]\n        Yd = case[\"Yd\"]\n        Ye = case[\"Ye\"]\n        Ynu = case[\"Ynu\"]\n        \n        # 1. Gauge boson masses\n        m_W = g * v / 2.0\n        m_Z = np.sqrt(g**2 + gp**2) * v / 2.0\n\n        # 2. Rho parameter check\n        # The algebraic relation rho = 1 holds for this model.\n        # The check confirms this up to numerical precision.\n        denominator_g_sq_gp_sq = g**2 + gp**2\n        if denominator_g_sq_gp_sq  1e-15:\n            cos_theta_W = g / np.sqrt(denominator_g_sq_gp_sq)\n            if abs(m_Z * cos_theta_W)  1e-15:\n                rho = m_W / (m_Z * cos_theta_W)\n            else: # Caters for g=0, where m_W=0 and cos_theta_W=0\n                rho = 1.0 # Relation holds by L'Hopital's or algebraic inspection\n        else: # g=g'=0\n            rho = 1.0 # m_W=m_Z=0, relation holds trivially\n\n        rho_ok = np.abs(rho - 1.0)  1e-12\n\n        # 3. SVD of Yukawa matrices to get left-handed unitary matrices\n        # The U matrix from numpy.linalg.svd is U_L\n        UuL, _, _ = np.linalg.svd(Yu)\n        UdL, _, _ = np.linalg.svd(Yd)\n        UeL, _, _ = np.linalg.svd(Ye)\n        UnuL, _, _ = np.linalg.svd(Ynu)\n        \n        # 4. Construct CKM and PMNS matrices\n        # V_CKM = U_uL^dagger * U_dL\n        # U_PMNS = U_eL^dagger * U_nuL\n        V_CKM = UuL.conj().T @ UdL\n        U_PMNS = UeL.conj().T @ UnuL\n        \n        # 5. Unitarity check using Frobenius norm\n        identity = np.identity(3, dtype=complex)\n        ckm_unitarity_dev = np.linalg.norm(V_CKM.conj().T @ V_CKM - identity, 'fro')\n        pmns_unitarity_dev = np.linalg.norm(U_PMNS.conj().T @ U_PMNS - identity, 'fro')\n        \n        ckm_unitary = ckm_unitarity_dev  1e-12\n        pmns_unitary = pmns_unitarity_dev  1e-12\n\n        # 6. Jarlskog invariant calculation\n        J_CKM = np.imag(V_CKM[0,0] * V_CKM[1,1] * V_CKM[0,1].conj() * V_CKM[1,0].conj())\n        J_PMNS = np.imag(U_PMNS[0,0] * U_PMNS[1,1] * U_PMNS[0,1].conj() * U_PMNS[1,0].conj())\n        \n        # 7. Collect and format results for the current case\n        case_result = [\n            round(m_W, 3),\n            round(m_Z, 3),\n            rho_ok,\n            ckm_unitary,\n            pmns_unitary,\n            round(J_CKM, 10),\n            round(J_PMNS, 10)\n        ]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    formatted_results = []\n    for res in results:\n        # Convert each item to string; booleans become 'True'/'False'\n        # Format list to string without spaces after commas.\n        s = f\"[{res[0]},{res[1]},{str(res[2]).lower()},{str(res[3]).lower()},{str(res[4]).lower()},{res[5]},{res[6]}]\"\n        formatted_results.append(s)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们通过树图计算得到的物理图像虽然强大，但并不完整。量子修正会引入微妙而重要的效应。这项高级实践将探讨标准模型希格斯部分的一个近似对称性——“守护对称性”——以及它是如何被量子修正所破坏的，特别是来自重顶夸克的贡献。通过计算 $\\rho$ 参数的单圈修正并分析其对能量标度的依赖性，您将深入理解电弱精确检验的本质，以及重整化在量子场论中的关键作用。",
            "id": "3537699",
            "problem": "你需要编写一个程序，定量地探究标准模型（SM）中的监护对称性破缺。重点关注全局监护 $SU(2)_V$ 对称性，该对称性在超荷规范耦合为零且第三代夸克汤川耦合简并的极限下是精确的。你将评估由第三代夸克双重态引起的单圈修正 $\\Delta \\rho$（也称为斜参数 $\\alpha T$），并研究其由标准模型规范耦合和汤川耦合的单圈重整化群方程（RGEs）驱动的重整化标度依赖性。\n\n你的推理应基于以下基本事实和定义：\n\n- 电弱规范对称性是 $SU(2)_L \\times U(1)_Y$，其规范耦合分别为 $g$ 和 $g'$。量子色动力学（QCD）的规范耦合是 $g_3$。\n- 对于单个 Higgs 双重态，监护 $SU(2)_V$ 对称性意味着在树图级别上 $\\rho \\equiv M_W^2/(M_Z^2 \\cos^2 \\theta_W) = 1$。该对称性被超荷（$g' \\neq 0$）以及顶夸克和底夸克汤川耦合的差异（$y_t \\neq y_b$，导致 $m_t \\neq m_b$）所破缺。\n- 在单圈水平上，标准模型中由分量质量为 $m_1$ 和 $m_2$ 的费米子双重态引起的主要监护对称性破缺被编码在 $\\Delta \\rho$ 中，它可以表示为零动量下电弱规范玻色子自能的差异。在此任务中，你将实现标准的单圈费米子双重态对 $\\Delta \\rho$ 的贡献，并为具有 $N_c = 3$ 种颜色的第三代夸克双重态进行评估。\n- 使用由费米常数 $G_F$ 定义的 Higgs 真空期望值 $v$，即 $v \\equiv (\\sqrt{2} G_F)^{-1/2}$。\n\n为了解决重整化标度的依赖性，使用规范耦合和第三代汤川耦合的单圈标准模型 RGEs 来演化这些耦合。使用标准模型正则归一化（而非大统一理论归一化）下的电弱超荷耦合。令 $\\mu$ 表示重整化标度，且 $t \\equiv \\ln \\mu$。单圈 RGEs 如下：\n\n- 规范耦合：\n$$\n16\\pi^2 \\,\\frac{d g'}{d t} \\;=\\; \\frac{41}{6}\\, g'^3,\\qquad\n16\\pi^2 \\,\\frac{d g}{d t} \\;=\\; -\\frac{19}{6}\\, g^3,\\qquad\n16\\pi^2 \\,\\frac{d g_3}{d t} \\;=\\; -7\\, g_3^3.\n$$\n\n- 第三代汤川耦合（忽略代际混合）：\n$$\n16\\pi^2 \\,\\frac{d y_t}{d t} \\;=\\; y_t\\!\\left(\\frac{9}{2} y_t^2 + \\frac{3}{2} y_b^2 + y_\\tau^2 - \\frac{17}{12} g'^2 - \\frac{9}{4} g^2 - 8 g_3^2 \\right),\n$$\n$$\n16\\pi^2 \\,\\frac{d y_b}{d t} \\;=\\; y_b\\!\\left(\\frac{9}{2} y_b^2 + \\frac{3}{2} y_t^2 + y_\\tau^2 - \\frac{5}{12} g'^2 - \\frac{9}{4} g^2 - 8 g_3^2 \\right),\n$$\n$$\n16\\pi^2 \\,\\frac{d y_\\tau}{d t} \\;=\\; y_\\tau\\!\\left(\\frac{5}{2} y_\\tau^2 + 3 y_b^2 + 3 y_t^2 - \\frac{15}{4} g'^2 - \\frac{9}{4} g^2 \\right).\n$$\n\n在目标标度 $\\mu$ 处获得 $y_t(\\mu)$ 和 $y_b(\\mu)$ 后，定义跑动质量\n$$\nm_t(\\mu) \\equiv \\frac{y_t(\\mu)\\, v}{\\sqrt{2}},\\qquad m_b(\\mu) \\equiv \\frac{y_b(\\mu)\\, v}{\\sqrt{2}}.\n$$\n为 $N_c=3$ 种颜色实现标准的单圈费米子双重态对 $\\Delta \\rho$ 的贡献，\n$$\n\\Delta \\rho_{tb}(\\mu) \\;=\\; \\frac{N_c}{16\\pi^2\\, v^2}\\left[m_t(\\mu)^2 + m_b(\\mu)^2 - \\frac{2 m_t(\\mu)^2 m_b(\\mu)^2}{m_t(\\mu)^2 - m_b(\\mu)^2}\\,\\ln\\!\\left(\\frac{m_t(\\mu)^2}{m_b(\\mu)^2}\\right)\\right],\n$$\n并对 $m_t(\\mu)\\to m_b(\\mu)$ 极限进行数值稳定的处理。当第三代双重态的监护对称性精确时，即当 $m_t(\\mu)=m_b(\\mu)$ 时，此可观测量为零。\n\n数值输入和单位：\n\n- 使用 $G_F = 1.1663787\\times 10^{-5}\\,\\mathrm{GeV}^{-2}$，因此 $v = (\\sqrt{2} G_F)^{-1/2}$ 的单位是 $\\mathrm{GeV}$。\n- 使用参考标度 $\\mu_0 = 173.0\\,\\mathrm{GeV}$ 作为初始条件。\n- 在 $\\mu_0$ 处初始化规范耦合为 $g_3(\\mu_0) = 1.1666$，$g(\\mu_0) = 0.648$，$g'(\\mu_0) = 0.358$。\n- 在 $\\mu_0$ 处通过跑动质量代理来初始化汤川耦合：$m_t(\\mu_0) = 173.0\\,\\mathrm{GeV}$，$m_b(\\mu_0) = 2.78\\,\\mathrm{GeV}$，$m_\\tau(\\mu_0) = 1.777\\,\\mathrm{GeV}$，通过 $y_f(\\mu_0) = \\sqrt{2}\\,m_f(\\mu_0)/v$ 计算，其中 $f \\in \\{t,b,\\tau\\}$。\n\n用于分离监护对称性破缺来源的场景：\n\n- 完全跑动：按给定方式将 RGEs 从 $\\mu_0$ 积分到目标 $\\mu$。\n- 无超荷跑动：对所有 $\\mu$ 设置 $g'(\\mu)=0$，并从汤川 β 函数和 $g'$ β 函数中移除所有 $g'$ 项；将其余耦合从 $\\mu_0$ 演化到 $\\mu$。\n- 简并双重态检验：对于一个假设的简并费米子双重态（$m_1 = m_2 = 100.0\\,\\mathrm{GeV}$），直接评估单圈 $\\Delta \\rho$；这应返回一个在数值上与零一致的值。\n\n任务：\n\n1. 在变量 $t=\\ln \\mu$ 中实现 $g'$、$g$、$g_3$、$y_t$、$y_b$ 和 $y_\\tau$ 的单圈 RGEs，并根据每个测试用例的要求，在 $t_0 = \\ln \\mu_0$ 和 $t = \\ln \\mu$ 之间对它们进行数值求解。所有质量均以 $\\mathrm{GeV}$ 表示。\n2. 根据演化后的 $y_t(\\mu)$ 和 $y_b(\\mu)$，计算 $m_t(\\mu)$ 和 $m_b(\\mu)$，然后使用上述单圈费米子双重态表达式计算 $\\Delta \\rho_{tb}(\\mu)$。确保在 $m_t(\\mu)\\approx m_b(\\mu)$ 时的数值稳定性。\n3. 对于简并双重态检验，计算 $N_c=3$ 且 $m_1 = m_2 = 100.0\\,\\mathrm{GeV}$ 时的单圈 $\\Delta \\rho$。\n4. 按照以下确切顺序，为下列测试用例套件生成结果：\n   - 情况 1：完全跑动到 $\\mu = 100.0\\,\\mathrm{GeV}$。\n   - 情况 2：完全跑动到 $\\mu = 173.0\\,\\mathrm{GeV}$。\n   - 情况 3：完全跑动到 $\\mu = 1000.0\\,\\mathrm{GeV}$。\n   - 情况 4：无超荷跑动到 $\\mu = 173.0\\,\\mathrm{GeV}$。\n   - 情况 5：简并双重态，$m_1 = m_2 = 100.0\\,\\mathrm{GeV}$。\n\n答案规格和最终输出格式：\n\n- 每个情况必须产生一个等于 $\\Delta \\rho$（无量纲）的实数，表示为浮点数。此问题中没有角度或百分比。\n- 你的程序应产生单行输出，其中包含一个逗号分隔的列表，用方括号括起来，结果按上述指定情况的顺序排列，例如 $\\texttt{[r_1,r_2,r_3,r_4,r_5]}$，其中每个 $r_i$ 是情况 $i$ 的浮点结果。",
            "solution": "该问题要求计算标准模型（SM）中来自第三代夸克双重态的单圈修正 $\\Delta \\rho$，并考虑相关耦合的重整化标度依赖性。这是一个基于量子场论的计算物理问题，特别是标准模型参数的重整化群演化。解决方案需要对一个耦合常微分方程（ODEs）组进行数值积分，这些方程是规范耦合和汤川耦合的单圈重整化群方程（RGEs）。\n\n首先，我们确定基本常数和初始条件。Higgs 真空期望值 $v$ 由费米常数 $G_F = 1.1663787\\times 10^{-5}\\,\\mathrm{GeV}^{-2}$ 导出：\n$$\nv = \\left(\\sqrt{2} G_F\\right)^{-1/2}\n$$\n使用给定的 $G_F$ 值，可得 $v \\approx 246.2197\\,\\mathrm{GeV}$。\n\nRGEs 的初始条件在参考标度 $\\mu_0 = 173.0\\,\\mathrm{GeV}$ 处给出。规范耦合直接给出：$g_3(\\mu_0) = 1.1666$，$g(\\mu_0) = 0.648$，$g'(\\mu_0) = 0.358$。第三代汤川耦合 $y_f(\\mu_0)$ 由其在同一标度下的相应跑动质量 $m_f(\\mu_0)$ 通过关系式 $m_f(\\mu) = y_f(\\mu) v / \\sqrt{2}$ 导出。初始质量为 $m_t(\\mu_0) = 173.0\\,\\mathrm{GeV}$，$m_b(\\mu_0) = 2.78\\,\\mathrm{GeV}$ 和 $m_\\tau(\\mu_0) = 1.777\\,\\mathrm{GeV}$。因此，初始汤川耦合为：\n$$\ny_f(\\mu_0) = \\frac{\\sqrt{2}\\,m_f(\\mu_0)}{v} \\quad \\text{for } f \\in \\{t, b, \\tau\\}\n$$\n\n问题的核心是将这些耦合从初始标度 $\\mu_0$ 演化到目标标度 $\\mu$。此演化由单圈标准模型 RGEs 控制。定义演化变量为 $t \\equiv \\ln \\mu$，RGEs 构成一个一阶常微分方程组 $\\frac{d\\vec{C}}{dt} = \\vec{\\beta}(\\vec{C})$，其中 $\\vec{C}(t) = [g'(t), g(t), g_3(t), y_t(t), y_b(t), y_\\tau(t)]$。β 函数 $\\vec{\\beta}$ 由以下公式给出：\n$$\n\\frac{d g'}{d t} = \\frac{1}{16\\pi^2}\\left(\\frac{41}{6}\\right) g'^3\n$$\n$$\n\\frac{d g}{d t} = \\frac{1}{16\\pi^2}\\left(-\\frac{19}{6}\\right) g^3\n$$\n$$\n\\frac{d g_3}{d t} = \\frac{1}{16\\pi^2}\\left(-7\\right) g_3^3\n$$\n$$\n\\frac{d y_t}{d t} = \\frac{y_t}{16\\pi^2}\\left(\\frac{9}{2} y_t^2 + \\frac{3}{2} y_b^2 + y_\\tau^2 - \\frac{17}{12} g'^2 - \\frac{9}{4} g^2 - 8 g_3^2 \\right)\n$$\n$$\n\\frac{d y_b}{d t} = \\frac{y_b}{16\\pi^2}\\left(\\frac{9}{2} y_b^2 + \\frac{3}{2} y_t^2 + y_\\tau^2 - \\frac{5}{12} g'^2 - \\frac{9}{4} g^2 - 8 g_3^2 \\right)\n$$\n$$\n\\frac{d y_\\tau}{d t} = \\frac{y_\\tau}{16\\pi^2}\\left(\\frac{5}{2} y_\\tau^2 + 3 y_b^2 + 3 y_t^2 - \\frac{15}{4} g'^2 - \\frac{9}{4} g^2 \\right)\n$$\n这个常微分方程组将使用标准的初值问题求解器（如 `scipy.integrate` 库中的 `solve_ivp` 函数）进行数值求解。积分在区间 $[t_0, t_f] = [\\ln \\mu_0, \\ln \\mu]$ 上进行。对于“无超荷”跑动场景（情况4），通过在整个演化过程中设置 $g'=0$ 来修改 RGEs，这意味着汤川 β 函数中与 $g'^2$ 成正比的项被舍弃，并且 $g'$ 的 β 函数本身为零。\n\n一旦在目标标度 $\\mu$ 处获得演化后的汤川耦合 $y_t(\\mu)$ 和 $y_b(\\mu)$，跑动质量计算如下：\n$$\nm_t(\\mu) = \\frac{y_t(\\mu) v}{\\sqrt{2}}, \\quad m_b(\\mu) = \\frac{y_b(\\mu) v}{\\sqrt{2}}\n$$\n利用这些质量，计算来自顶-底夸克双重态的单圈修正 $\\Delta \\rho_{tb}(\\mu)$。量 $\\Delta \\rho$ 是监护对称性破缺的度量。提供的公式是：\n$$\n\\Delta \\rho_{tb}(\\mu) = \\frac{N_c}{16\\pi^2 v^2}\\left[m_t(\\mu)^2 + m_b(\\mu)^2 - \\frac{2 m_t(\\mu)^2 m_b(\\mu)^2}{m_t(\\mu)^2 - m_b(\\mu)^2}\\ln\\left(\\frac{m_t(\\mu)^2}{m_b(\\mu)^2}\\right)\\right]\n$$\n其中颜色数 $N_c = 3$。该表达式在监护对称性极限下，即当 $m_t(\\mu) = m_b(\\mu)$ 时，值为零。在数值上，涉及对数的项在此极限下呈 $0/0$ 的不定形式。正确的极限值为零。对 $m_b^2 \\to m_t^2$ 进行泰勒展开可以证实这一点。在实现中，如果 $|m_t(\\mu) - m_b(\\mu)|$ 小于机器精度，则结果设为 $0$。\n\n具体情况处理如下：\n- **情况 1（完全跑动到 $\\mu = 100.0\\,\\mathrm{GeV}$）和情况 3（完全跑动到 $\\mu = 1000.0\\,\\mathrm{GeV}$）：** 我们求解从 $\\mu_0=173.0\\,\\mathrm{GeV}$ 到相应目标标度 $\\mu=100.0\\,\\mathrm{GeV}$ 和 $\\mu=1000.0\\,\\mathrm{GeV}$ 的完整 RGEs 系统。然后，我们使用演化后的耦合计算 $\\Delta \\rho_{tb}$。\n- **情况 2（完全跑动到 $\\mu = 173.0\\,\\mathrm{GeV}$）：** 目标标度 $\\mu$ 与初始标度 $\\mu_0$ 相同。演化区间为 $t-t_0 = \\ln(\\mu/\\mu_0) = 0$。不需要积分。我们直接使用初始质量 $m_t(\\mu_0)$ 和 $m_b(\\mu_0)$ 计算 $\\Delta \\rho_{tb}$。\n- **情况 4（无超荷跑动到 $\\mu = 173.0\\,\\mathrm{GeV}$）：** 与情况 2 类似，演化区间为零。尽管 RGEs 被修改以排除超荷，但由于没有演化，耦合不会从其初始值改变。因此，这种情况在计算上与情况 2 相同，我们使用相同的初始质量计算 $\\Delta \\rho_{tb}$。结果将与情况 2 的结果相同，这一发现证实了对问题规范的仔细解读。\n- **情况 5（简并双重态检验）：** 这是对一个假设双重态的 $\\Delta \\rho$ 公式的直接评估。它不涉及 RGE 演化。我们设置 $N_c=3$，$m_1 = m_2 = 100.0\\,\\mathrm{GeV}$，这使得质量简并。根据关于监护对称性极限的讨论，结果必须精确为 $0$。\n\n以下程序实现了这一逻辑来解决五个指定的情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Calculates the one-loop correction Delta_rho for various scenarios\n    by solving the Standard Model Renormalization Group Equations (RGEs).\n    \"\"\"\n\n    # --- Constants and Initial Conditions ---\n    G_F = 1.1663787e-5  # GeV^-2\n    v = (np.sqrt(2) * G_F)**-0.5  # GeV\n    Nc = 3.0\n\n    mu0 = 173.0  # Reference scale in GeV\n\n    # Initial gauge couplings at mu0\n    g_prime_0 = 0.358\n    g_0 = 0.648\n    g3_0 = 1.1666\n\n    # Initial running masses at mu0\n    mt_0 = 173.0   # GeV\n    mb_0 = 2.78    # GeV\n    mtau_0 = 1.777 # GeV\n\n    # Initial Yukawa couplings at mu0, derived from masses\n    yt_0 = np.sqrt(2) * mt_0 / v\n    yb_0 = np.sqrt(2) * mb_0 / v\n    ytau_0 = np.sqrt(2) * mtau_0 / v\n\n    # Initial state vector for RGEs\n    y0 = np.array([g_prime_0, g_0, g3_0, yt_0, yb_0, ytau_0])\n    \n    # --- RGE System Definition ---\n    def rge_system(t, y, mode='full'):\n        \"\"\"\n        Defines the system of one-loop RGEs for SM couplings.\n        t: evolution variable, log(mu)\n        y: vector of couplings [g', g, g3, yt, yb, ytau]\n        mode: 'full' or 'no_hypercharge'\n        \"\"\"\n        g_prime, g, g3, yt, yb, ytau = y\n\n        # Beta functions for gauge couplings\n        dg_prime_dt = (1 / (16 * np.pi**2)) * (41 / 6) * g_prime**3\n        dg_dt = (1 / (16 * np.pi**2)) * (-19 / 6) * g**3\n        dg3_dt = (1 / (16 * np.pi**2)) * (-7) * g3**3\n\n        # Beta functions for Yukawa couplings\n        # Common terms first\n        common_yt_yb = (9 / 4) * g**2 + 8 * g3**2\n        \n        # Hypercharge contributions\n        g_prime_term_t = (17 / 12) * g_prime**2\n        g_prime_term_b = (5 / 12) * g_prime**2\n        g_prime_term_tau = (15 / 4) * g_prime**2\n\n        if mode == 'no_hypercharge':\n            dg_prime_dt = 0.0\n            g_prime_term_t = 0.0\n            g_prime_term_b = 0.0\n            g_prime_term_tau = 0.0\n        \n        dyt_dt = (yt / (16 * np.pi**2)) * (\n            (9 / 2) * yt**2 + (3 / 2) * yb**2 + ytau**2 - g_prime_term_t - common_yt_yb\n        )\n        dyb_dt = (yb / (16 * np.pi**2)) * (\n            (9 / 2) * yb**2 + (3 / 2) * yt**2 + ytau**2 - g_prime_term_b - common_yt_yb\n        )\n        dytau_dt = (ytau / (16 * np.pi**2)) * (\n            (5 / 2) * ytau**2 + 3 * yt**2 + 3 * yb**2 - g_prime_term_tau - (9/4) * g**2\n        )\n        \n        return np.array([dg_prime_dt, dg_dt, dg3_dt, dyt_dt, dyb_dt, dytau_dt])\n    \n    # --- Delta rho Calculation ---\n    def calculate_delta_rho(mt, mb):\n        \"\"\"\n        Computes the one-loop fermionic contribution to Delta_rho.\n        Handles the degenerate mass limit numerically.\n        \"\"\"\n        if np.isclose(mt, mb):\n            return 0.0\n\n        mt2 = mt**2\n        mb2 = mb**2\n        \n        # Numerically stable calculation of the bracketed term\n        log_term = (2 * mt2 * mb2) / (mt2 - mb2) * np.log(mt2 / mb2)\n        numerator_term = mt2 + mb2 - log_term\n        \n        delta_rho_val = (Nc / (16 * np.pi**2 * v**2)) * numerator_term\n        return delta_rho_val\n\n    # --- Process Test Cases ---\n    test_cases = [\n        {'case': 1, 'mu': 100.0, 'mode': 'full'},\n        {'case': 2, 'mu': 173.0, 'mode': 'full'},\n        {'case': 3, 'mu': 1000.0, 'mode': 'full'},\n        {'case': 4, 'mu': 173.0, 'mode': 'no_hypercharge'},\n        {'case': 5, 'm1': 100.0, 'm2': 100.0, 'mode': 'degenerate'}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        if case['mode'] == 'degenerate':\n            # Case 5: Direct calculation for a degenerate doublet\n            result = calculate_delta_rho(case['m1'], case['m2'])\n            results.append(result)\n            continue\n            \n        mu_target = case['mu']\n        mode = case['mode']\n\n        # Determine the running masses at the target scale\n        if np.isclose(mu_target, mu0):\n            # No evolution needed if target scale is the initial scale\n            mt_final = mt_0\n            mb_final = mb_0\n        else:\n            # Evolve couplings using RGEs\n            t_span = [np.log(mu0), np.log(mu_target)]\n            \n            # For 'no_hypercharge', we must start the evolution with g'=0 if we were to evolve.\n            # However, since mu=mu0 for case 4, we use initial masses directly.\n            # If we were to evolve with no_hypercharge, the initial state would need g'=0.\n            # Here, we stick to the problem statement which leads to identical results for Case 2  4.\n            initial_state = y0\n            \n            sol = solve_ivp(\n                lambda t, y: rge_system(t, y, mode=mode), \n                t_span, \n                initial_state, \n                method='RK45', \n                dense_output=True,\n                rtol=1e-8, atol=1e-10\n            )\n            \n            # Extract final couplings\n            couplings_final = sol.y[:, -1]\n            yt_final = couplings_final[3]\n            yb_final = couplings_final[4]\n\n            # Calculate final running masses\n            mt_final = yt_final * v / np.sqrt(2)\n            mb_final = yb_final * v / np.sqrt(2)\n            \n        # Calculate Delta_rho with the final masses\n        result = calculate_delta_rho(mt_final, mb_final)\n        results.append(result)\n\n    # Format the final output as specified\n    # The problem asks for float results, not strings with a specific format.\n    # The example [r1, r2, ...] implies the standard python list representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}