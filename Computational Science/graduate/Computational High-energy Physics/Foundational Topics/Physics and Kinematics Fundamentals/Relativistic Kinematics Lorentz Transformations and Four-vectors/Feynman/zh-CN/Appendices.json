{
    "hands_on_practices": [
        {
            "introduction": "洛伦兹不变量是分析粒子散射过程的核心工具，其中曼德尔斯坦变量 $s$、$t$ 和 $u$ 尤为重要，它们以一种与参考系无关的方式简洁地概括了散射过程的能量和动量转移信息。这项练习旨在通过一个具体的弹性散射案例，让你亲手实践如何利用四维动量来计算这些不变量。这个过程不仅能加深你对四维矢量代数的理解，还能让你体会理论定义如何与可观测的物理过程直接关联。",
            "id": "3529989",
            "problem": "考虑在自然单位制（其中光速 $c$ 设为 $1$）下，质心系中的一次 $2 \\to 2$ 弹性散射。两个静止质量为 $m_{1}$ 和 $m_{2}$、三维动量为 $\\boldsymbol{p}_{1}$ 和 $\\boldsymbol{p}_{2}$ 的入射粒子，散射成两个静止质量为 $m_{3}$ 和 $m_{4}$、三维动量为 $\\boldsymbol{p}_{3}$ 和 $\\boldsymbol{p}_{4}$ 的出射粒子。所有四个粒子均在壳。使用符号为 $(+,-,-,-)$ 的 Minkowski 度规。\n\n运动学参数指定如下：\n- 质量：$m_{1} = m_{3} = 0.13957\\,\\mathrm{GeV}$ 且 $m_{2} = m_{4} = 0.93827\\,\\mathrm{GeV}$。\n- 入射三维动量：$\\boldsymbol{p}_{1} = (0,\\,0,\\,2.000)\\,\\mathrm{GeV}$ 且 $\\boldsymbol{p}_{2} = (0,\\,0,\\,-2.000)\\,\\mathrm{GeV}$。\n- 出射三维动量：选择 $\\boldsymbol{p}_{3}$ 的大小为 $|\\boldsymbol{p}_{3}| = 2.000\\,\\mathrm{GeV}$，并在 $x$–$z$ 平面内指向极角 $\\theta = 60^{\\circ}$（方位角 $\\phi = 0$），并设 $\\boldsymbol{p}_{4} = -\\boldsymbol{p}_{3}$。\n\n任务：\n1. 仅使用每个粒子的在壳条件和四维动量的定义，计算在壳能量 $E_{i}$（其中 $i \\in \\{1,2,3,4\\}$），并组装四维矢量 $p_{i}^{\\mu} = (E_{i},\\,\\boldsymbol{p}_{i})$。\n2. 使用以四维矢量和 Minkowski 度规定义的 Mandelstam 不变量，数值计算此事件的不变量 $s$、$t$ 和 $u$。\n3. 通过确认初始总四维动量等于末态总四维动量，以及检验恒等式 $s + t + u = m_{1}^{2} + m_{2}^{2} + m_{3}^{2} + m_{4}^{2}$，来验证与能量-动量守恒的一致性。\n4. 提供以 $\\mathrm{GeV}^{2}$ 为单位的 $s$、$t$ 和 $u$ 的数值。将最终报告值四舍五入到四位有效数字。角度以度为单位指定；在此问题中不要将其转换为弧度。\n\n你的最终答案必须只包含按所写顺序排列的三个值 $(s,\\,t,\\,u)$，并以 $\\mathrm{GeV}^{2}$ 为单位表示。",
            "solution": "### 解答\n\n问题要求为一次指定的弹性散射事件计算粒子能量、四维动量以及 Mandelstam 不变量 $s$、$t$ 和 $u$。我们在自然单位制（$c=1$）下工作，并使用 Minkowski 度规 $g_{\\mu\\nu} = \\mathrm{diag}(1, -1, -1, -1)$。四维动量为 $p^{\\mu} = (E, \\boldsymbol{p})$，其洛伦兹不变量标量平方为 $p^2 = p^{\\mu}p_{\\mu} = E^2 - |\\boldsymbol{p}|^2$。质量为 $m$ 的粒子的在壳条件是 $p^2 = m^2$。\n\n**任务 1：计算能量和四维矢量**\n\n在壳条件给出粒子的能量为 $E = \\sqrt{m^2 + |\\boldsymbol{p}|^2}$。所有粒子的三维动量大小被给出或隐含为 $p_{mag} = 2.000\\,\\mathrm{GeV}$。\n\n对于粒子 $1$ 和 $3$：\n$m_1 = m_3 = 0.13957\\,\\mathrm{GeV}$\n$E_1 = E_3 = \\sqrt{(0.13957\\,\\mathrm{GeV})^2 + (2.000\\,\\mathrm{GeV})^2} = \\sqrt{0.0194797849\\,\\mathrm{GeV}^2 + 4.000\\,\\mathrm{GeV}^2} = \\sqrt{4.0194797849\\,\\mathrm{GeV}^2} \\approx 2.004864\\,\\mathrm{GeV}$。\n\n对于粒子 $2$ 和 $4$：\n$m_2 = m_4 = 0.93827\\,\\mathrm{GeV}$\n$E_2 = E_4 = \\sqrt{(0.93827\\,\\mathrm{GeV})^2 + (2.000\\,\\mathrm{GeV})^2} = \\sqrt{0.8803503929\\,\\mathrm{GeV}^2 + 4.000\\,\\mathrm{GeV}^2} = \\sqrt{4.8803503929\\,\\mathrm{GeV}^2} \\approx 2.209152\\,\\mathrm{GeV}$。\n\n现在，我们组装三维动量和四维矢量。\n- $\\boldsymbol{p}_1 = (0, 0, 2.000)\\,\\mathrm{GeV}$\n- $\\boldsymbol{p}_2 = (0, 0, -2.000)\\,\\mathrm{GeV}$\n\n对于 $\\boldsymbol{p}_3$，其大小为 $|\\boldsymbol{p}_3| = 2.000\\,\\mathrm{GeV}$，极角为 $\\theta=60^{\\circ}$，方位角为 $\\phi=0^{\\circ}$。其分量为：\n$p_{3x} = |\\boldsymbol{p}_3|\\sin\\theta\\cos\\phi = 2.000 \\sin(60^{\\circ}) \\cos(0^{\\circ}) = 2.000 \\cdot (\\frac{\\sqrt{3}}{2}) \\cdot 1 = \\sqrt{3}\\,\\mathrm{GeV} \\approx 1.732\\,\\mathrm{GeV}$。\n$p_{3y} = |\\boldsymbol{p}_3|\\sin\\theta\\sin\\phi = 2.000 \\sin(60^{\\circ}) \\sin(0^{\\circ}) = 0\\,\\mathrm{GeV}$。\n$p_{3z} = |\\boldsymbol{p}_3|\\cos\\theta = 2.000 \\cos(60^{\\circ}) = 2.000 \\cdot \\frac{1}{2} = 1.000\\,\\mathrm{GeV}$。\n所以，$\\boldsymbol{p}_3 = (\\sqrt{3}, 0, 1.000)\\,\\mathrm{GeV}$。\n\n对于 $\\boldsymbol{p}_4$，我们有 $\\boldsymbol{p}_4 = -\\boldsymbol{p}_3$：\n$\\boldsymbol{p}_4 = (-\\sqrt{3}, 0, -1.000)\\,\\mathrm{GeV}$。\n\n四维矢量为（能量单位为 GeV）：\n$p_1^{\\mu} = (2.004864, 0, 0, 2.000)$\n$p_2^{\\mu} = (2.209152, 0, 0, -2.000)$\n$p_3^{\\mu} = (2.004864, \\sqrt{3}, 0, 1.000)$\n$p_4^{\\mu} = (2.209152, -\\sqrt{3}, 0, -1.000)$\n\n**任务 2：计算 Mandelstam 不变量**\n\nMandelstam 不变量定义为：\n$s = (p_1 + p_2)^2$\n$t = (p_1 - p_3)^2$\n$u = (p_1 - p_4)^2$\n\n$s$ 的计算：\n在质心系中，$\\boldsymbol{p}_1 + \\boldsymbol{p}_2 = \\boldsymbol{0}$。\n$p_1^{\\mu} + p_2^{\\mu} = (E_1+E_2, \\boldsymbol{0})$。\n$s = (p_1 + p_2)^2 = (E_1+E_2)^2 - |\\boldsymbol{0}|^2 = (E_1+E_2)^2$。\n$s = (2.004864\\,\\mathrm{GeV} + 2.209152\\,\\mathrm{GeV})^2 = (4.214016\\,\\mathrm{GeV})^2 \\approx 17.757915\\,\\mathrm{GeV}^2$。\n\n$t$ 的计算：\n对于弹性散射，$E_1 = E_3$。\n$p_1^{\\mu} - p_3^{\\mu} = (E_1-E_3, \\boldsymbol{p}_1-\\boldsymbol{p}_3) = (0, \\boldsymbol{p}_1-\\boldsymbol{p}_3)$。\n$t = (p_1 - p_3)^2 = 0^2 - |\\boldsymbol{p}_1 - \\boldsymbol{p}_3|^2 = -|\\boldsymbol{p}_1 - \\boldsymbol{p}_3|^2$。\n$\\boldsymbol{p}_1 - \\boldsymbol{p}_3 = (0,0,2.000) - (\\sqrt{3},0,1.000) = (-\\sqrt{3}, 0, 1.000)\\,\\mathrm{GeV}$。\n$|\\boldsymbol{p}_1 - \\boldsymbol{p}_3|^2 = (-\\sqrt{3})^2 + 0^2 + (1.000)^2 = 3.000 + 1.000 = 4.000\\,\\mathrm{GeV}^2$。\n$t = -4.000\\,\\mathrm{GeV}^2$。根据给定的几何构型，此结果是精确的。\n\n$u$ 的计算：\n$u = (p_1 - p_4)^2 = p_1^2 + p_4^2 - 2 p_1 \\cdot p_4 = m_1^2 + m_4^2 - 2(E_1 E_4 - \\boldsymbol{p}_1 \\cdot \\boldsymbol{p}_4)$。\n已知 $m_4=m_2$ 且 $E_4=E_2$：\n$u = m_1^2 + m_2^2 - 2(E_1 E_2 - \\boldsymbol{p}_1 \\cdot \\boldsymbol{p}_4)$。\n$\\boldsymbol{p}_1 \\cdot \\boldsymbol{p}_4 = (0, 0, 2.000) \\cdot (-\\sqrt{3}, 0, -1.000) = -2.000\\,\\mathrm{GeV}^2$。\n$u = (0.13957)^2 + (0.93827)^2 - 2( (2.004864)(2.209152) - (-2.000) )\\,\\mathrm{GeV}^2$。\n$u \\approx 0.019480 + 0.880350 - 2(4.429007 + 2.000)\\,\\mathrm{GeV}^2$。\n$u \\approx 0.899830 - 2(6.429007)\\,\\mathrm{GeV}^2 = 0.899830 - 12.858014\\,\\mathrm{GeV}^2 = -11.958184\\,\\mathrm{GeV}^2$。\n\n**任务 3：验证一致性**\n\n能量-动量守恒，$p_1^{\\mu} + p_2^{\\mu} = p_3^{\\mu} + p_4^{\\mu}$：\n初始总四维动量：$p_{in}^{\\mu} = p_1^{\\mu} + p_2^{\\mu} = (E_1+E_2, \\boldsymbol{0}) = (4.214016, 0, 0, 0)\\,\\mathrm{GeV}$。\n末态总四维动量：$p_{out}^{\\mu} = p_3^{\\mu} + p_4^{\\mu} = (E_3+E_4, \\boldsymbol{p}_3+\\boldsymbol{p}_4)$。由于 $E_3=E_1$、$E_4=E_2$ 且 $\\boldsymbol{p}_4=-\\boldsymbol{p}_3$，我们有 $p_{out}^{\\mu} = (E_1+E_2, \\boldsymbol{0}) = p_{in}^{\\mu}$。问题的设置满足守恒定律。\n\n恒等式检验：$s+t+u = m_1^2 + m_2^2 + m_3^2 + m_4^2$。\n质量平方和：\n$\\sum m_i^2 = 2(m_1^2 + m_2^2) = 2((0.13957)^2 + (0.93827)^2) \\,\\mathrm{GeV}^2$。\n$\\sum m_i^2 = 2(0.0194797849 + 0.8803503929)\\,\\mathrm{GeV}^2 = 2(0.8998301778)\\,\\mathrm{GeV}^2 = 1.799660\\,\\mathrm{GeV}^2$。\n\n计算出的 Mandelstam 变量之和：\n$s+t+u \\approx 17.757915 - 4.000 - 11.958184 = 1.799731\\,\\mathrm{GeV}^2$。\n此和与 $\\sum m_i^2$ 之间的微小差异（$<0.005\\%$）是由于对中间能量值进行四舍五入造成的。恒等式得到验证。使用恒等式来计算 $u$ 会得到一个更精确的结果：\n$u = \\sum m_i^2 - s - t = 1.799660 - 17.757915 - (-4.000) = -11.958255\\,\\mathrm{GeV}^2$。\n\n**任务 4：最终数值**\n\n我们被要求将最终报告值四舍五入到四位有效数字。\n$s = 17.757915\\,\\mathrm{GeV}^2 \\to 17.76\\,\\mathrm{GeV}^2$。\n$t = -4.000\\,\\mathrm{GeV}^2$（精确值）$\\to -4.000\\,\\mathrm{GeV}^2$。\n$u = -11.958255\\,\\mathrm{GeV}^2 \\to -11.96\\,\\mathrm{GeV}^2$。\n\n$(s, t, u)$ 的最终值为 $(17.76, -4.000, -11.96)\\,\\mathrm{GeV}^2$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n17.76 & -4.000 & -11.96\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在高能物理实验数据分析中，计算由多个粒子（例如，喷注）组成的系统的不变质量是一项基本操作。然而，当这些粒子能量极高且方向近乎平行时，直接套用公式 $m^2 = (\\sum E_i)^2 - ||\\sum \\vec{p}_i||^2$ 会遭遇灾难性相消（catastrophic cancellation）问题，导致计算结果严重失真。这个编程练习将让你直面这一源于有限浮点精度的实际挑战，通过实现并对比朴素求和与更精确的Kahan补偿求和算法，你将掌握诊断和解决数值不稳定性的关键技术。",
            "id": "3530040",
            "problem": "要求您设计并实现一个计算程序，用于在狭义相对论和高能物理（HEP）的背景下，对不变质量平方进行聚合计算。该程序必须能够诊断并减轻因对近光速和准直的四动量求和时发生的灾难性抵消所导致的数值不稳定性。其理论基础是闵可夫斯基度规，度规符号为 $(+,-,-,-)$，采用自然单位制（其中光速 $c=1$），能量-动量四维矢量定义为 $p^\\mu=(E,\\boldsymbol{p})$，以及通过对四动量求和并取其闵可夫斯基范数得到的系统不变质量平方。对于一个包含 $N$ 个粒子的系统，其不变质量平方 $m^2$ 由下式给出：\n$$\nm^2=\\left(\\sum_{i=1}^N E_i\\right)^2-\\left\\lVert \\sum_{i=1}^N \\boldsymbol{p}_i \\right\\rVert^2=\\left(\\sum_{i=1}^N E_i\\right)^2-\\left(\\left(\\sum_{i=1}^N p_{x,i}\\right)^2+\\left(\\sum_{i=1}^N p_{y,i}\\right)^2+\\left(\\sum_{i=1}^N p_{z,i}\\right)^2\\right).\n$$\n在具有近共线和近光速动量的多喷注事件中，量 $m^2$ 是通过两个巨大的、几乎相等的正数相减得到的，这对浮点舍入误差尤其敏感。您必须实现三种计算不变质量平方的策略：\n- 使用标准双精度算术（IEEE 754双精度，其中IEEE代表电气与电子工程师协会）的朴素求和。\n- 使用Kahan算法的补偿求和，以减少在 $\\sum E_i$ 和 $\\sum \\boldsymbol{p}_i$ 的每个分量中的累积误差。\n- 一种混合精度方法，使用高精度十进制算术进行求和与平方运算，以作为高精度参考。\n\n您的程序必须：\n1. 不读取任何输入，并使用下面提供的测试套件。\n2. 对于每个测试用例，通过给定的 $(E_i,p_{x,i},p_{y,i},s_i)$ 来构建每个喷注的纵向动量分量 $p_{z,i}$：\n$$\np_{z,i}=s_i\\sqrt{E_i^2-p_{x,i}^2-p_{y,i}^2},\n$$\n其中 $s_i\\in\\{+1,-1\\}$ 设置 $p_{z,i}$ 的符号。所有能量 $E_i$ 的单位为 $\\text{GeV}$，动量 $p_{x,i},p_{y,i},p_{z,i}$ 的单位为 $\\text{GeV}$，不变质量平方 $m^2$ 的单位为 $\\text{GeV}^2$。不使用角度，因此没有角度单位适用。\n3. 使用以下方法计算不变质量平方 $m^2$：\n   - 双精度朴素求和。\n   - 双精度Kahan补偿求和。\n   - 混合精度，使用高精度十进制算术计算和以及最终的差值。\n4. 使用混合精度结果作为参考值 $m^2_{\\text{ref}}$，并报告朴素方法和补偿方法的相对误差：\n$$\n\\varepsilon_{\\text{naive}}=\\frac{\\left|m^2_{\\text{naive}}-m^2_{\\text{ref}}\\right|}{\\max\\left(1,\\left|m^2_{\\text{ref}}\\right|\\right)},\\quad\n\\varepsilon_{\\text{comp}}=\\frac{\\left|m^2_{\\text{comp}}-m^2_{\\text{ref}}\\right|}{\\max\\left(1,\\left|m^2_{\\text{ref}}\\right|\\right)}.\n$$\n5. 此外，计算一个抵消严重性诊断指标：\n$$\n\\rho=\\frac{\\left|m^2_{\\text{ref}}\\right|}{\\left(\\left(\\sum_i E_i\\right)^2+\\left\\lVert \\sum_i \\boldsymbol{p}_i\\right\\rVert^2\\right)},\n$$\n使用相同的高精度和。较小的 $\\rho$ 值（例如 $\\rho\\ll 1$）表示可能存在灾难性抵消。\n\n测试套件：\n- 案例1（高度准直的六个喷注，所有 $p_{z,i}>0$）：\n  - 喷注1：$(E_1,p_{x,1},p_{y,1},s_1)=(600.0,0.10,-0.08,+1)$\n  - 喷注2：$(E_2,p_{x,2},p_{y,2},s_2)=(550.0,-0.12,0.06,+1)$\n  - 喷注3：$(E_3,p_{x,3},p_{y,3},s_3)=(500.0,0.08,0.04,+1)$\n  - 喷注4：$(E_4,p_{x,4},p_{y,4},s_4)=(450.0,-0.07,-0.03,+1)$\n  - 喷注5：$(E_5,p_{x,5},p_{y,5},s_5)=(400.0,0.05,0.02,+1)$\n  - 喷注6：$(E_6,p_{x,6},p_{y,6},s_6)=(350.0,-0.04,-0.01,+1)$\n- 案例2（背对背的近光速双喷注）：\n  - 喷注1：$(E_1,p_{x,1},p_{y,1},s_1)=(500.0,100.0,0.0,+1)$\n  - 喷注2：$(E_2,p_{x,2},p_{y,2},s_2)=(500.0,-100.0,0.0,-1)$\n- 案例3（四个喷注，方向混合）：\n  - 喷注1：$(E_1,p_{x,1},p_{y,1},s_1)=(200.0,30.0,-20.0,+1)$\n  - 喷注2：$(E_2,p_{x,2},p_{y,2},s_2)=(150.0,-25.0,15.0,-1)$\n  - 喷注3：$(E_3,p_{x,3},p_{y,3},s_3)=(120.0,10.0,-8.0,+1)$\n  - 喷注4：$(E_4,p_{x,4},p_{y,4},s_4)=(80.0,-5.0,3.0,-1)$\n- 案例4（十个具有微小横向动量的极端准直喷注，所有 $p_{z,i}>0$）：\n  - 喷注1：$(E_1,p_{x,1},p_{y,1},s_1)=(550.0,0.0010,-0.0012,+1)$\n  - 喷注2：$(E_2,p_{x,2},p_{y,2},s_2)=(530.0,-0.0013,0.0009,+1)$\n  - 喷注3：$(E_3,p_{x,3},p_{y,3},s_3)=(510.0,0.0007,-0.0008,+1)$\n  - 喷注4：$(E_4,p_{x,4},p_{y,4},s_4)=(490.0,-0.0009,0.0011,+1)$\n  - 喷注5：$(E_5,p_{x,5},p_{y,5},s_5)=(470.0,0.0011,-0.0007,+1)$\n  - 喷注6：$(E_6,p_{x,6},p_{y,6},s_6)=(450.0,-0.0008,0.0006,+1)$\n  - 喷注7：$(E_7,p_{x,7},p_{y,7},s_7)=(430.0,0.0006,-0.0004,+1)$\n  - 喷注8：$(E_8,p_{x,8},p_{y,8},s_8)=(410.0,-0.0004,0.0005,+1)$\n  - 喷注9：$(E_9,p_{x,9},p_{y,9},s_9)=(390.0,0.0005,-0.0003,+1)$\n  - 喷注10：$(E_{10},p_{x,10},p_{y,10},s_{10})=(370.0,-0.0003,0.0004,+1)$\n\n输出规范：\n- 对于每个案例，计算并报告一个包含六个实数的列表\n$$\n\\left[m^2_{\\text{naive}},~m^2_{\\text{comp}},~m^2_{\\text{mixed}},~\\varepsilon_{\\text{naive}},~\\varepsilon_{\\text{comp}},~\\rho\\right],\n$$\n其中 $m^2_{\\text{naive}}$、$m^2_{\\text{comp}}$ 和 $m^2_{\\text{mixed}}$ 的单位是 $\\text{GeV}^2$，而 $\\varepsilon_{\\text{naive}}$、$\\varepsilon_{\\text{comp}}$ 和 $\\rho$ 是无量纲的小数。您的程序应生成单行输出，其中包含四个案例结果的逗号分隔列表，并用方括号括起来。例如，格式必须是\n$$\n\\left[ [\\cdots], [\\cdots], [\\cdots], [\\cdots] \\right],\n$$\n不带任何附加文本。",
            "solution": "该问题要求实现并比较三种不同的数值方法，用于计算粒子系统的不变质量平方，这是相对论运动学中的一个基本量。核心挑战是解决被称为灾难性抵消的数值不稳定性问题，该问题在为高度准直、高能量的粒子（喷注）系统计算此量时出现。\n\n这个问题的基础是爱因斯坦的狭义相对论，特别是能量-动量四维矢量 $p^\\mu = (E, \\boldsymbol{p}) = (E, p_x, p_y, p_z)$ 的性质，其中 $E$ 是能量，$\\boldsymbol{p}$ 是三维动量。我们在自然单位制中工作，其中光速 $c=1$。时空的几何由闵可夫斯基度规描述，我们使用 $(+,-,-,-)$ 度规符号，因此两个四维矢量 $a^\\mu$ 和 $b^\\mu$ 的闵可夫斯基点积是 $a \\cdot b = a^0 b^0 - \\boldsymbol{a} \\cdot \\boldsymbol{b}$。\n\n单个粒子的不变质量平方 $m^2$ 是其四动量的闵可夫斯基范数的平方：$m^2 = p^\\mu p_\\mu = E^2 - |\\boldsymbol{p}|^2$。这个量是一个洛伦兹不变量，意味着它在所有惯性参考系中都具有相同的值。对于一个由 $N$ 个粒子组成的系统，总四动量是各个四动量之和，$P^\\mu = \\sum_{i=1}^N p_i^\\mu$。系统的不变质量平方则是这个总四动量的范数平方：\n$$\nM^2 = P^\\mu P_\\mu = \\left(\\sum_{i=1}^N p_i^\\mu\\right) \\cdot \\left(\\sum_{j=1}^N p_j^\\nu\\right) = \\left(\\sum_i E_i\\right)^2 - \\left|\\sum_i \\boldsymbol{p}_i\\right|^2\n$$\n这就是问题中提供的公式。单个粒子（喷注）被视为无质量的，这意味着对于每个喷注 $i$，其自身的不变质量平方为 $m_i^2 = E_i^2 - |\\boldsymbol{p}_i|^2 = 0$。这允许从给定的能量 $E_i$ 和横向动量分量 $p_{x,i}, p_{y,i}$ 计算纵向动量分量 $p_{z,i}$：\n$$\np_{z,i} = s_i \\sqrt{E_i^2 - (p_{x,i}^2 + p_{y,i}^2)}\n$$\n其中 $s_i \\in \\{+1, -1\\}$ 决定了沿z轴的方向。\n\n数值挑战，即灾难性抵消，发生在当 $P^\\mu$ 是“类光的”时候，即当总能量 $E_{tot} = \\sum E_i$ 非常接近于总动量的大小 $|\\boldsymbol{p}_{tot}| = |\\sum \\boldsymbol{p}_i|$ 时。这种情况发生时，例如，所有粒子以接近光速的速度朝几乎相同的方向运动。在这种情况下，$E_{tot}^2$ 和 $|\\boldsymbol{p}_{tot}|^2$ 是两个非常大且几乎相等的数。标准的浮点算术（如IEEE 754双精度）具有有限的精度（大约16位十进制数字）。当两个几乎相等的大数相减时，开头的最高有效位相抵消，留下的结果主要由先前计算中累积的舍入误差所主导。这可能导致 $M^2$ 的最终值极不准确，甚至可能符号错误。\n\n为了诊断和缓解这个问题，我们将实现并比较三种计算策略。\n\n1.  **朴素求和（双精度）**：这是最直接的方法。使用标准浮点算术对每个四动量的分量进行求和。最终的不变质量平方计算为 $M_{\\text{naive}}^2 = (\\sum E_i)^2 - ((\\sum p_{x,i})^2 + (\\sum p_{y,i})^2 + (\\sum p_{z,i})^2)$。预计该方法在严重抵消的情况下（例如，高度准直的喷注）表现不佳。\n\n2.  **补偿求和（Kahan算法）**：此方法旨在提高求和的准确性。Kahan求和算法是一种经典技术，用于减少浮点数序列求和中的数值误差。对于总动量的四个分量（$E_{tot}, p_{x,tot}, p_{y,tot}, p_{z,tot}$）中的每一个，和的计算如下：\n    - 初始化一个和 $S=0$ 和一个补偿变量 $c=0$。\n    - 对于序列中的每一项 $x_i$：\n        1.  $y = x_i - c$（减去先前的误差）。\n        2.  $t = S + y$（加到总和上）。\n        3.  $c = (t - S) - y$（新的误差是在加到 $S$ 上时 $y$ 中丢失的部分）。\n        4.  $S = t$（更新总和）。\n    此过程有效地跟踪“丢失”的低位比特，并在稍后阶段将其加回总和中，从而大大减少了累积误差。然后，从这些更精确的和计算出不变质量平方 $M_{\\text{comp}}^2$。\n\n3.  **混合精度参考计算**：为了建立一个“基准真相”，我们采用任意精度算术，这在Python的`decimal`模块中可用。我们为这些计算设置一个非常高的精度（例如，100位十进制数字）。首先将给定的浮点数初始喷注数据转换为高精度的`Decimal`对象。所有后续操作——计算 $p_z$、求和四动量分量以及计算最终的平方差——都使用这种高精度算术进行。结果 $M_{\\text{ref}}^2$ 被认为是高精度参考，用以评判其他方法。\n\n分析通过计算两个指标来完成：\n-   **相对误差（$\\varepsilon$）**：对于朴素和补偿方法，相对于参考结果计算相对误差：$\\varepsilon = |M^2 - M_{\\text{ref}}^2| / \\max(1, |M_{\\text{ref}}^2|)$。分母通过 $\\max(1, \\dots)$ 进行正则化，以处理 $M_{\\text{ref}}^2$ 为零或非常小的情况。\n-   **抵消诊断（$\\rho$）**：此指标量化了抵消的严重程度。它是最终结果的绝对值与相减的两个大数之和的比率：$\\rho = |M_{\\text{ref}}^2| / (E_{tot}^2 + |\\boldsymbol{p}_{tot}|^2)$，使用高精度的和。$\\rho \\ll 1$ 的值表示结果远小于为获得它而相减的数，这标志着严重的灾难性抵消。\n\n实现将通过定义一个函数来处理每个测试用例。该函数将构建四动量，应用三种计算策略中的每一种来找到 $M^2$，然后计算误差和诊断指标 $\\rho$。所有测试用例的结果将被汇总并按规定格式化。",
            "answer": "```python\nimport numpy as np\nfrom decimal import Decimal, getcontext\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Set the precision for the high-accuracy reference calculation.\n    # 100 digits is more than sufficient to be a \"ground truth\" for double precision.\n    getcontext().prec = 100\n\n    test_cases = [\n        # Case 1: highly collimated six jets\n        [\n            (600.0, 0.10, -0.08, +1), (550.0, -0.12, 0.06, +1),\n            (500.0, 0.08, 0.04, +1), (450.0, -0.07, -0.03, +1),\n            (400.0, 0.05, 0.02, +1), (350.0, -0.04, -0.01, +1)\n        ],\n        # Case 2: back-to-back nearly lightlike di-jet\n        [\n            (500.0, 100.0, 0.0, +1), (500.0, -100.0, 0.0, -1)\n        ],\n        # Case 3: four jets, mixed directions\n        [\n            (200.0, 30.0, -20.0, +1), (150.0, -25.0, 15.0, -1),\n            (120.0, 10.0, -8.0, +1), (80.0, -5.0, 3.0, -1)\n        ],\n        # Case 4: ten extremely collimated jets\n        [\n            (550.0, 0.0010, -0.0012, +1), (530.0, -0.0013, 0.0009, +1),\n            (510.0, 0.0007, -0.0008, +1), (490.0, -0.0009, 0.0011, +1),\n            (470.0, 0.0011, -0.0007, +1), (450.0, -0.0008, 0.0006, +1),\n            (430.0, 0.0006, -0.0004, +1), (410.0, -0.0004, 0.0005, +1),\n            (390.0, 0.0005, -0.0003, +1), (370.0, -0.0003, 0.0004, +1)\n        ]\n    ]\n\n    all_results = [process_case(case) for case in test_cases]\n\n    # Format the output as a stringified list of lists.\n    result_strings = [str(res) for res in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\ndef kahan_sum(data):\n    \"\"\"\n    Computes the sum of a sequence of floats using Kahan's compensated summation algorithm.\n    \"\"\"\n    s = 0.0\n    c = 0.0  # A running compensation for lost low-order bits.\n    for x in data:\n        y = x - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef process_case(jet_data):\n    \"\"\"\n    Processes a single test case, calculating invariant mass-squared with three methods\n    and reporting errors and a diagnostic.\n    \"\"\"\n    momenta_float = []\n    momenta_dec = []\n\n    for E, px, py, s in jet_data:\n        # Double precision (float) calculation\n        E_f, px_f, py_f = float(E), float(px), float(py)\n        # Ensure argument to sqrt is non-negative, though data is well-formed\n        pz_f_sq_arg = E_f**2 - px_f**2 - py_f**2\n        pz_f = float(s) * math.sqrt(max(0.0, pz_f_sq_arg))\n        momenta_float.append([E_f, px_f, py_f, pz_f])\n        \n        # High precision (Decimal) calculation\n        # Use strings for exact representation\n        E_d, px_d, py_d = Decimal(str(E)), Decimal(str(px)), Decimal(str(py))\n        s_d = Decimal(s)\n        pz_d_sq_arg = E_d**2 - px_d**2 - py_d**2\n        pz_d = s_d * pz_d_sq_arg.sqrt()\n        momenta_dec.append([E_d, px_d, py_d, pz_d])\n\n    momenta_float_np = np.array(momenta_float, dtype=np.float64)\n\n    # --- 1. Naive Summation ---\n    P_naive = np.sum(momenta_float_np, axis=0)\n    m2_naive = P_naive[0]**2 - (P_naive[1]**2 + P_naive[2]**2 + P_naive[3]**2)\n\n    # --- 2. Kahan Compensated Summation ---\n    E_comp = kahan_sum(momenta_float_np[:, 0])\n    px_comp = kahan_sum(momenta_float_np[:, 1])\n    py_comp = kahan_sum(momenta_float_np[:, 2])\n    pz_comp = kahan_sum(momenta_float_np[:, 3])\n    m2_comp = E_comp**2 - (px_comp**2 + py_comp**2 + pz_comp**2)\n\n    # --- 3. Mixed-Precision Reference Calculation ---\n    E_ref = sum(p[0] for p in momenta_dec)\n    px_ref = sum(p[1] for p in momenta_dec)\n    py_ref = sum(p[2] for p in momenta_dec)\n    pz_ref = sum(p[3] for p in momenta_dec)\n    p_vec_norm_sq_ref = px_ref**2 + py_ref**2 + pz_ref**2\n    m2_ref = E_ref**2 - p_vec_norm_sq_ref\n\n    # --- 4. Relative Errors ---\n    m2_ref_f = float(m2_ref)\n    denom_err = max(1.0, abs(m2_ref_f))\n    eps_naive = abs(m2_naive - m2_ref_f) / denom_err\n    eps_comp = abs(m2_comp - m2_ref_f) / denom_err\n\n    # --- 5. Cancellation Severity Diagnostic ---\n    denom_rho = E_ref**2 + p_vec_norm_sq_ref\n    rho = float(abs(m2_ref) / denom_rho if denom_rho != 0 else Decimal(0))\n    \n    return [m2_naive, m2_comp, m2_ref_f, eps_naive, eps_comp, rho]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "蒙特卡洛方法是高能物理研究中不可或缺的工具，它被广泛用于模拟粒子衰变过程、设计探测器和诠释实验数据。其核心环节之一是，首先在质心参考系中依据物理模型（如各向同性衰变）生成末态粒子的运动学分布，然后通过洛伦兹变换将其转换到实验室参考系。这项综合性实践将引导你构建一个完整的两体衰变模拟器，亲身体验从质心系抽样、应用通用洛伦兹变换到最终验证模拟结果物理自洽性的全过程，从而掌握连接理论模型与实验预测的关键仿真技术。",
            "id": "3530037",
            "problem": "实现一个完整的、可运行的程序，该程序从一个母粒子出发，通过蒙特卡洛采样生成一个相对论性的两体末态。该过程在质心系（也称为母粒子的静止系）中使用各向同性发射，并通过洛伦兹变换将结果变换回指定的实验室系。目标是通过直接计算来验证：在质心系中重建的极角余弦分布是均匀的，并且四维动量守恒具有很高的数值精度。所有的推导和实现都必须基于第一性原理：四维动量守恒、洛伦兹不变性以及三维空间中的旋转几何。\n\n您的程序必须满足以下科学和计算要求。\n\n- 使用自然单位制，其中 $c=1$。所有能量和质量必须以 $\\mathrm{GeV}$ 为单位，所有三维动量必须以 $\\mathrm{GeV}$ 为单位，所有角度必须以弧度表示。输出必须是无量纲的浮点数。\n\n- 对于给定的实验室系中的母粒子四维动量，通过将其四维矢量与闵可夫斯基度规进行缩并并取正根来计算母粒子的不变质量。利用四维动量守恒来确定质心系中两体末态的唯一运动学。质心系中的各向同性要求意味着其中一个子粒子的极角余弦（记为 $\\cos\\theta^\\ast$）的分布在区间 $\\left[-1,1\\right]$ 上是均匀的，而方位角 $\\phi^\\ast$ 在 $\\left[0,2\\pi\\right)$ 上是均匀的。\n\n- 实现任意四维矢量在由速度三维矢量 $\\boldsymbol{\\beta}$（其大小严格小于1）指定的纯粹助推下的洛伦兹变换，其中 $\\gamma = 1/\\sqrt{1-\\lVert \\boldsymbol{\\beta}\\rVert^2}$。该助推必须适用于三维空间中的任意方向，并在零速度极限下能正确地特化。\n\n- 每个测试用例的算法工作流程：\n  1. 根据给定的实验室系中的母粒子三维动量和母粒子不变质量，构建母粒子在实验室系中的四维动量，以及从质心系到实验室系的相应助推速度。\n  2. 在质心系中，采样 $N$ 个独立的数对 $\\left(\\cos\\theta^\\ast,\\phi^\\ast\\right)$，其中 $\\cos\\theta^\\ast$ 在 $\\left[-1,1\\right]$ 上均匀分布，$\\phi^\\ast$ 在 $\\left[0,2\\pi\\right)$ 上均匀分布。为了使验证明确且可复现，必须选择极轴沿着实验室助推方向（$\\boldsymbol{\\beta}$ 的方向）。\n  3. 利用四维动量守恒和在壳条件，构建质心系中的两个子粒子四维动量。使用步骤1中确定的助推将两个子粒子的四维动量都变换到实验室系。\n  4. 在实验室系中，通过将子粒子四维动量的分量和与母粒子实验室四维动量进行比较，对所有 $N$ 个样本进行数值上的四维动量守恒验证，并报告由母粒子不变质量归一化的最大绝对分量偏差。这将产生一个无量纲的度量。\n  5. 独立地，通过对一个子粒子的实验室四维动量应用逆助推（从实验室系回到质心系），计算相对于助推方向的极角余弦，并汇总 $N$ 个样本的重建值，来重建 $\\cos\\theta^\\ast$。通过计算 Kolmogorov–Smirnov 统计量 $D$ 来量化重建的 $\\cos\\theta^\\ast$ 样本在 $\\left[-1,1\\right]$ 上的均匀性。$D$ 定义为经验累积分布函数与 $\\left[-1,1\\right]$ 上均匀分布的精确累积分布函数之间绝对差的上确界。\n  6. 为保证可复现性，将伪随机数生成器的种子设置为 $123456$。\n\n- 为以下参数值的测试套件实现上述过程。每个测试用例由一个元组 $\\left(M,\\;m_1,\\;m_2,\\;\\boldsymbol{p}_{\\text{lab}},\\;N\\right)$ 指定，其中 $M$ 是母粒子的不变质量（单位 $\\mathrm{GeV}$），$m_1$ 和 $m_2$ 是子粒子的质量（单位 $\\mathrm{GeV}$），$\\boldsymbol{p}_{\\text{lab}}$ 是母粒子在实验室系的三维动量（单位 $\\mathrm{GeV}$），$N$ 是蒙特卡洛采样的数量：\n  - 情况 A (一般情况，中等助推): $\\left(10.0,\\;3.0,\\;2.0,\\;(0.0,\\,0.0,\\,15.0),\\;50000\\right)$。\n  - 情况 B (无质量子粒子，高助推): $\\left(10.0,\\;0.0,\\;0.0,\\;(0.0,\\,0.0,\\,90.0),\\;50000\\right)$。\n  - 情况 C (非对称质量，非共线助推): $\\left(10.0,\\;0.5,\\;8.5,\\;(7.0,\\,4.0,\\,1.0),\\;50000\\right)$。\n  - 情况 D (近阈值子粒子，小助推): $\\left(5.1,\\;2.5,\\;2.5,\\;(0.1,\\,-0.2,\\,0.3),\\;50000\\right)$。\n\n- 对于每个测试用例，您的程序必须产生两个浮点数：\n  - 重建的 $\\cos\\theta^\\ast$ 值相对于 $\\left[-1,1\\right]$ 上均匀分布的 Kolmogorov–Smirnov 统计量 $D$。\n  - 最大相对四维动量守恒误差，定义为相加的子粒子实验室四维动量与母粒子实验室四维动量之间的矢量差在所有分量和所有样本上的最大绝对偏差，再除以母粒子不变质量。\n\n- 最终输出格式：您的程序必须生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。将每个案例的两个浮点数输出按顺序 $\\left[D_A,\\;\\varepsilon_A,\\;D_B,\\;\\varepsilon_B,\\;D_C,\\;\\varepsilon_C,\\;D_D,\\;\\varepsilon_D\\right]$ 展平成一个列表，其中 $D_X$ 和 $\\varepsilon_X$ 对应于案例 $X \\in \\{A,B,C,D\\}$ 的统计量和守恒误差。例如，使用占位符值的输出看起来会像 $\\left[0.00123,1.2\\mathrm{e}{-12},0.00234,1.1\\mathrm{e}{-12},\\ldots\\right]$。\n\n您的实现必须是通用的，不得硬编码任何依赖于参考系的简化。所有变换都必须使用完全的三维矢量和四维矢量完成，并且逻辑必须在小助推和大助推的极限情况下，以及在存在无质量和近阈值运动学的情况下保持稳健。最终的数值输出必须是无量纲的浮点数。",
            "solution": "用户提供的问题经评估有效。该问题具有科学依据，提法明確，客观，并包含足够的信息以获得唯一解。任务是基于狭义相对论原理，实现一个相对论性两体衰变的蒙特卡洛模拟，并通过统计分析和守恒律检验来验证模拟的正确性。\n\n解决方案是基于以下相对论运动学的第一性原理开发的。\n\n**1. 四维动量和不变质量**\n\n在狭义相对论框架下，并使用自然单位制（其中光速 $c=1$），粒子的状态由其四维动量 $p^\\mu = (E, \\boldsymbol{p})$ 描述，其中 $E$ 是能量，$\\boldsymbol{p}$ 是三维动量。闵可夫斯基度规取为 $g_{\\mu\\nu} = \\mathrm{diag}(1, -1, -1, -1)$。粒子的不变质量 $m$ 是一个洛伦兹不变量，通过其四维动量的缩并定义：$m^2 = p^\\mu p_\\mu = E^2 - \\lVert\\boldsymbol{p}\\rVert^2$。\n\n**2. 质心系中的两体衰变运动学**\n\n考虑一个质量为 $M$ 的母粒子衰变为两个质量分别为 $m_1$ 和 $m_2$ 的子粒子：$P \\to p_1 + p_2$。在质心（CM）系中，母粒子处于静止状态。其四维动量为 $P^\\ast = (M, \\boldsymbol{0})$。根据四维动量守恒，$P^\\ast = p_1^\\ast + p_2^\\ast$。这意味着子粒子的三维动量大小相等，方向相反：$\\boldsymbol{p}_1^\\ast = -\\boldsymbol{p}_2^\\ast \\equiv \\boldsymbol{p}^\\ast$。\n\n子粒子在质心系中的能量由在壳条件给出：\n$$\nE_1^\\ast = \\sqrt{m_1^2 + \\lVert\\boldsymbol{p}^\\ast\\rVert^2} \\quad \\text{和} \\quad E_2^\\ast = \\sqrt{m_2^2 + \\lVert\\boldsymbol{p}^\\ast\\rVert^2}\n$$\n能量守恒要求 $M = E_1^\\ast + E_2^\\ast$。求解子粒子动量的大小 $\\lVert\\boldsymbol{p}^\\ast\\rVert$，得到一个唯一的值：\n$$\nM - \\sqrt{m_1^2 + \\lVert\\boldsymbol{p}^\\ast\\rVert^2} = \\sqrt{m_2^2 + \\lVert\\boldsymbol{p}^\\ast\\rVert^2}\n$$\n两边平方并求解 $\\lVert\\boldsymbol{p}^\\ast\\rVert^2$ 可得：\n$$\n\\lVert\\boldsymbol{p}^\\ast\\rVert = \\frac{\\sqrt{(M^2 - (m_1+m_2)^2)(M^2 - (m_1-m_2)^2)}}{2M} = \\frac{\\sqrt{\\lambda(M^2, m_1^2, m_2^2)}}{2M}\n$$\n其中 $\\lambda(x, y, z) = x^2+y^2+z^2-2xy-2yz-2zx$ 是 Källén 函数或三角函数。只有当 $M > m_1 + m_2$ 时，衰变在运动学上才是可能的。\n\n**3. 各向同性衰变和方向**\n\n问题指定了在质心系中的各向同性衰变。这意味着子粒子动量 $\\boldsymbol{p}^\\ast$ 的方向在整个立体角上是均匀分布的。这个分布是通过从 $[-1, 1]$ 上的均匀分布中采样极角余弦 $\\cos\\theta^\\ast$，以及从 $[0, 2\\pi)$ 上的均匀分布中采样方位角 $\\phi^\\ast$ 来生成的。\n\n问题定义了该球坐标系的极轴与从质心系到实验室系的助推方向 $\\hat{\\boldsymbol{\\beta}}$ 对齐。为了构建三维动量矢量 $\\boldsymbol{p}^\\ast$，我们定义一个右手正交基 $(\\hat{\\boldsymbol{v}}, \\hat{\\boldsymbol{w}}, \\hat{\\boldsymbol{u}})$，其中 $\\hat{\\boldsymbol{u}} = \\hat{\\boldsymbol{\\beta}}$。矢量 $\\boldsymbol{p}^\\ast$ 于是为：\n$$\n\\boldsymbol{p}^\\ast = \\lVert\\boldsymbol{p}^\\ast\\rVert (\\sin\\theta^\\ast \\cos\\phi^\\ast \\hat{\\boldsymbol{v}} + \\sin\\theta^\\ast \\sin\\phi^\\ast \\hat{\\boldsymbol{w}} + \\cos\\theta^\\ast \\hat{\\boldsymbol{u}})\n$$\n其中 $\\sin\\theta^\\ast = \\sqrt{1 - \\cos^2\\theta^\\ast}$。\n\n**4. 洛伦兹变换（助推）**\n\n质心系和实验室系之间的关系是一个纯洛伦兹助推。母粒子在实验室系中的三维动量为 $\\boldsymbol{p}_{\\text{lab}}$，能量为 $E_{\\text{lab}} = \\sqrt{M^2 + \\lVert\\boldsymbol{p}_{\\text{lab}}\\rVert^2}$。助推速度矢量是母粒子在实验室系中的速度：\n$$\n\\boldsymbol{\\beta} = \\frac{\\boldsymbol{p}_{\\text{lab}}}{E_{\\text{lab}}}\n$$\n洛伦兹因子为 $\\gamma = 1/\\sqrt{1 - \\lVert\\boldsymbol{\\beta}\\rVert^2}$。一个四维矢量 $q^\\mu=(q^0, \\boldsymbol{q})$ 变换到助推后的参考系 $q'^\\mu=(q'^0, \\boldsymbol{q}')$ 遵循以下规则：\n$$\n\\begin{align*}\nq'^0 = \\gamma(q^0 + \\boldsymbol{\\beta} \\cdot \\boldsymbol{q}) \\\\\n\\boldsymbol{q}' = \\boldsymbol{q} + \\left(\\frac{\\gamma - 1}{\\lVert\\boldsymbol{\\beta}\\rVert^2}\\right)(\\boldsymbol{q} \\cdot \\boldsymbol{\\beta})\\boldsymbol{\\beta} + \\gamma q^0 \\boldsymbol{\\beta}\n\\end{align*}\n$$\n这个变换被应用于子粒子的四维动量 $p_1^\\ast$ 和 $p_2^\\ast$ 以获得它们在实验室系中的值 $p_{1, \\text{lab}}$ 和 $p_{2, \\text{lab}}$。用于验证的逆助推是通过使用速度 $-\\boldsymbol{\\beta}$ 进行变换来实现的。\n\n**5. 算法实现与验证**\n\n对于每个测试用例，算法按以下步骤进行：\n\n1.  **母粒子运动学**：给定 $M$ 和 $\\boldsymbol{p}_{\\text{lab}}$，我们计算 $E_{\\text{lab}}$、母粒子四维动量 $P_{\\text{lab}} = (E_{\\textlab}, \\boldsymbol{p}_{\\text{lab}})$，以及助推矢量 $\\boldsymbol{\\beta} = \\boldsymbol{p}_{\\text{lab}}/E_{\\text{lab}}$。\n2.  **质心系运动学**：我们计算子粒子动量的大小 $\\lVert\\boldsymbol{p}^\\ast\\rVert$ 和质心系能量 $E_1^\\ast, E_2^\\ast$。\n3.  **蒙特卡洛采样**：我们使用带有固定种子的伪随机数生成器，从各自的均匀分布中生成 $N$ 对 $(\\cos\\theta^\\ast, \\phi^\\ast)$，以确保可复现性。\n4.  **子粒子动量构建**：对于 $N$ 个事件中的每一个，我们在质心系中使用指定的方向构建子粒子的三维动量 $\\boldsymbol{p}^\\ast$ 和 $-\\boldsymbol{p}^\\ast$，形成四维动量 $p_1^\\ast, p_2^\\ast$，并将它们助推到实验室系以得到 $p_{1, \\text{lab}}, p_{2, \\text{lab}}$。\n5.  **验证**：\n    *   **四维动量守恒**：我们为每个事件计算偏差 $\\Delta P = (p_{1, \\text{lab}} + p_{2, \\text{lab}}) - P_{\\text{lab}}$。守恒误差 $\\varepsilon$ 是 $\\Delta P$ 的任意分量在所有 $N$ 个事件中的最大绝对值，并由母粒子质量 $M$ 进行归一化：\n        $$\n        \\varepsilon = \\frac{\\max_{i \\in \\{1..N\\}, \\mu \\in \\{0,1,2,3\\}} |\\Delta P_i^\\mu|}{M}\n        $$\n    *   **分布均匀性**：对于每个事件，我们取一个子粒子在实验室系中的四维动量 $p_{1, \\text{lab}}$，应用逆助推 $(-\\boldsymbol{\\beta})$ 返回到质心系，并重建极角余弦：\n        $$\n        \\cos\\theta_{\\text{reco}}^\\ast = \\frac{\\boldsymbol{p}_{1, \\text{reco}}^\\ast \\cdot \\hat{\\boldsymbol{\\beta}}}{\\lVert\\boldsymbol{p}_{1, \\text{reco}}^\\ast\\rVert}\n        $$\n        然后我们计算 Kolmogorov-Smirnov (KS) 统计量 $D$，它衡量了 $N$ 个重建的 $\\cos\\theta_{\\text{reco}}^\\ast$ 值的经验累积分布函数（ECDF）与 $[-1, 1]$ 上均匀分布的理论累积分布函数（CDF，$F(x)=(x+1)/2$）之间的最大差异。\n        $$\n        D = \\sup_x |F_N(x) - F(x)|\n        $$\n\n该过程严谨地模拟了物理过程，并为基本相对论原理实现的正确性提供了定量检验。为提高效率，计算使用了矢量化操作。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import kstest\n\ndef solve():\n    \"\"\"\n    Simulates relativistic two-body decays and verifies the results.\n    \"\"\"\n\n    def boost(p_4vecs, beta_vec):\n        \"\"\"\n        Performs a Lorentz boost on an array of 4-vectors.\n\n        Args:\n            p_4vecs (np.ndarray): An array of 4-vectors, shape (N, 4).\n            beta_vec (np.ndarray): The 3-vector boost velocity, shape (3,).\n\n        Returns:\n            np.ndarray: The array of boosted 4-vectors, shape (N, 4).\n        \"\"\"\n        beta_sq = np.dot(beta_vec, beta_vec)\n        if beta_sq == 0.0:\n            return p_4vecs\n        if beta_sq >= 1.0:\n            raise ValueError(\"Boost velocity must be less than c=1.\")\n        \n        gamma = 1.0 / np.sqrt(1.0 - beta_sq)\n        \n        p0 = p_4vecs[:, 0]\n        p_3vecs = p_4vecs[:, 1:]\n        \n        beta_dot_p = np.dot(p_3vecs, beta_vec)\n        \n        p0_prime = gamma * (p0 + beta_dot_p)\n        \n        # Vectorized implementation of the 3-momentum boost formula\n        factor = (gamma - 1.0) / beta_sq\n        p_3vecs_prime = p_3vecs \\\n                     + np.outer(factor * beta_dot_p, beta_vec) \\\n                     + np.outer(gamma * p0, beta_vec)\n\n        p_prime = np.zeros_like(p_4vecs)\n        p_prime[:, 0] = p0_prime\n        p_prime[:, 1:] = p_3vecs_prime\n        \n        return p_prime\n\n    def process_case(M, m1, m2, p_lab_3vec, N, rng):\n        \"\"\"\n        Processes a single test case for the two-body decay simulation.\n        \"\"\"\n        p_lab_3vec = np.array(p_lab_3vec, dtype=np.float64)\n\n        # 1. Parent kinematics in the lab frame\n        p_lab_norm = np.linalg.norm(p_lab_3vec)\n        E_lab = np.sqrt(M**2 + p_lab_norm**2)\n        P_lab = np.array([E_lab, p_lab_3vec[0], p_lab_3vec[1], p_lab_3vec[2]])\n        \n        beta_vec = p_lab_3vec / E_lab\n        beta_norm = np.linalg.norm(beta_vec)\n\n        # 2. Sample N events in the CM frame\n        cos_theta_star = rng.uniform(-1.0, 1.0, size=N)\n        phi_star = rng.uniform(0.0, 2.0 * np.pi, size=N)\n        sin_theta_star = np.sqrt(1.0 - cos_theta_star**2)\n        \n        # 3. Construct daughter momenta in the CM frame\n        if M  m1 + m2:\n            raise ValueError(\"Decay is kinematically forbidden.\")\n        \n        p_star_mag_sq = (M**2 - (m1 + m2)**2) * (M**2 - (m1 - m2)**2) / (4.0 * M**2)\n        p_star_mag = np.sqrt(p_star_mag_sq)\n        \n        E1_star = np.sqrt(m1**2 + p_star_mag**2)\n        E2_star = np.sqrt(m2**2 + p_star_mag**2)\n\n        # Construct orthonormal basis aligned with the boost direction\n        if beta_norm > 1e-12:\n            u_hat = beta_vec / beta_norm\n        else: # Handle zero boost case\n            u_hat = np.array([0., 0., 1.])\n\n        # Robustly find a vector 'a' not parallel to u_hat\n        a = np.zeros(3)\n        idx = np.argmin(np.abs(u_hat))\n        a[idx] = 1.0\n        w_hat = np.cross(u_hat, a)\n        w_hat /= np.linalg.norm(w_hat)\n        v_hat = np.cross(w_hat, u_hat)\n\n        # Construct daughter 1's 3-momentum vectors in the CM frame\n        p_star_x = p_star_mag * sin_theta_star * np.cos(phi_star)\n        p_star_y = p_star_mag * sin_theta_star * np.sin(phi_star)\n        p_star_z = p_star_mag * cos_theta_star\n        \n        p_star_vecs = np.outer(p_star_x, v_hat) + \\\n                      np.outer(p_star_y, w_hat) + \\\n                      np.outer(p_star_z, u_hat)\n        \n        # Construct daughter 4-momenta in the CM frame\n        p1_star = np.hstack((np.full((N, 1), E1_star), p_star_vecs))\n        p2_star = np.hstack((np.full((N, 1), E2_star), -p_star_vecs))\n\n        # Boost daughters to lab frame\n        p1_lab = boost(p1_star, beta_vec)\n        p2_lab = boost(p2_star, beta_vec)\n\n        # 4. Verify 4-momentum conservation\n        P_lab_broadcast = np.tile(P_lab, (N, 1))\n        delta_P = (p1_lab + p2_lab) - P_lab_broadcast\n        max_abs_dev = np.max(np.abs(delta_P))\n        conservation_error = max_abs_dev / M\n\n        # 5. Verify cos(theta*) distribution\n        p1_reco_star = boost(p1_lab, -beta_vec)\n        p1_reco_3vecs_star = p1_reco_star[:, 1:]\n        p1_reco_3vecs_mag = np.linalg.norm(p1_reco_3vecs_star, axis=1)\n        \n        # Avoid division by zero for massless particles at rest (not in this problem)\n        safe_mags = np.where(p1_reco_3vecs_mag > 1e-12, p1_reco_3vecs_mag, 1.0)\n        \n        cos_theta_reco = np.dot(p1_reco_3vecs_star, u_hat) / safe_mags\n        \n        ks_result = kstest(cos_theta_reco, 'uniform', args=(-1, 2))\n        ks_statistic = ks_result.statistic\n        \n        return ks_statistic, conservation_error\n\n    # --- Main execution starts here ---\n\n    test_cases = [\n        # (M, m1, m2, p_lab, N)\n        (10.0, 3.0, 2.0, (0.0, 0.0, 15.0), 50000),    # Case A\n        (10.0, 0.0, 0.0, (0.0, 0.0, 90.0), 50000),    # Case B\n        (10.0, 0.5, 8.5, (7.0, 4.0, 1.0), 50000),     # Case C\n        (5.1, 2.5, 2.5, (0.1, -0.2, 0.3), 50000),     # Case D\n    ]\n    \n    # Initialize RNG with fixed seed for reproducibility\n    rng = np.random.default_rng(123456)\n    \n    results = []\n    for case in test_cases:\n        M, m1, m2, p_lab, N = case\n        ks_d, error_eps = process_case(M, m1, m2, p_lab, N, rng)\n        results.extend([ks_d, error_eps])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}