{
    "hands_on_practices": [
        {
            "introduction": "A core principle of reliable simulation is understanding the limitations of its tools. While pseudo-random number generators (PRNGs) produce sequences that appear random, they are fundamentally deterministic and can possess hidden structures. This exercise demonstrates in a stark and memorable way how the regular lattice structure inherent in a Linear Congruential Generator can lead to a catastrophic failure in a Monte Carlo integration . By working through this calculation, you will see how a seemingly reasonable simulation can produce a result that is not just slightly inaccurate, but completely wrong, cementing the importance of critically evaluating a PRNG's structural properties.",
            "id": "3333392",
            "problem": "Consider the multiplicative linear congruential generator (LCG) defined by\n$$x_{k+1} \\equiv a\\,x_{k} \\pmod{m},$$\nwith modulus $m = 2^{31}-1$, multiplier $a = 16807$, and seed $x_{0} \\in \\{1,2,\\dots,m-1\\}$. Assume $a$ is a primitive root modulo $m$, so that the period is $m-1$. The output mapping is $u_{k} = x_{k}/m \\in (0,1)$, yielding a pseudo-random number generator (PRNG).\n\nDefine the Monte Carlo estimator\n$$\\widehat{I}_{n} = \\frac{1}{n}\\sum_{k=1}^{n} f(u_{k}),$$\nfor the integral\n$$I = \\int_{0}^{1} f(u)\\,du,$$\nwhere the integrand is\n$$f(u) = \\cos\\!\\big(2\\pi m\\,u\\big).$$\n\nStarting from core definitions of linear congruential generators and Monte Carlo estimation, and without assuming any special structure beyond the given information, construct the logical steps to determine the asymptotic bias\n$$b \\equiv \\lim_{n\\to\\infty} \\widehat{I}_{n} - I.$$\nYour final answer must be a single real number. If any intermediate numerical approximations are needed, do not round. No units are required for the final answer.",
            "solution": "The objective is to determine the asymptotic bias, defined as $b \\equiv \\lim_{n\\to\\infty} \\widehat{I}_{n} - I$. This requires the calculation of two quantities: the true value of the integral, $I$, and the asymptotic limit of the Monte Carlo estimator, $\\lim_{n\\to\\infty} \\widehat{I}_{n}$.\n\nFirst, we calculate the true value of the integral $I$. The integral is defined as:\n$$I = \\int_{0}^{1} f(u)\\,du = \\int_{0}^{1} \\cos(2\\pi m u)\\,du$$\nTo evaluate this integral, we can use a substitution. Let $v = 2\\pi m u$, which implies $du = \\frac{dv}{2\\pi m}$. The limits of integration change from $u=0$ to $v=0$ and from $u=1$ to $v=2\\pi m$.\n$$I = \\int_{0}^{2\\pi m} \\cos(v) \\frac{dv}{2\\pi m} = \\frac{1}{2\\pi m} [\\sin(v)]_{0}^{2\\pi m}$$\nThe modulus $m$ is given as $m = 2^{31}-1$, which is an integer. Therefore, the upper limit of integration $2\\pi m$ is an integer multiple of $2\\pi$. The sine function is zero for all integer multiples of $\\pi$.\n$$I = \\frac{1}{2\\pi m} (\\sin(2\\pi m) - \\sin(0)) = \\frac{1}{2\\pi m} (0 - 0) = 0$$\nThus, the exact value of the integral is $I=0$.\n\nNext, we must determine the asymptotic limit of the Monte Carlo estimator, $\\lim_{n\\to\\infty} \\widehat{I}_{n}$. The estimator is given by:\n$$\\widehat{I}_{n} = \\frac{1}{n}\\sum_{k=1}^{n} f(u_{k})$$\nThe function to be evaluated is $f(u) = \\cos(2\\pi m u)$. The pseudo-random numbers $u_k$ are generated by the output mapping $u_k = x_k/m$, where $x_k$ is the sequence of states from the linear congruential generator (LCG).\nLet us analyze a single term in the sum, $f(u_k)$:\n$$f(u_k) = f(x_k/m) = \\cos\\left(2\\pi m \\frac{x_k}{m}\\right) = \\cos(2\\pi x_k)$$\nThe LCG is defined by $x_{k+1} \\equiv a x_k \\pmod{m}$. The seed is $x_0 \\in \\{1, 2, \\dots, m-1\\}$. Since the modulus $m$ is prime and the multiplier $a$ is a primitive root modulo $m$, the sequence $\\{x_k\\}_{k \\ge 1}$ cycles through all integers in the set $\\{1, 2, \\dots, m-1\\}$. Crucially, every state $x_k$ is an integer.\n\nFor any integer value $j$, the cosine function evaluated at $2\\pi j$ is:\n$$\\cos(2\\pi j) = 1$$\nSince each state $x_k$ is an integer for all $k \\ge 1$, we have:\n$$f(u_k) = \\cos(2\\pi x_k) = 1 \\quad \\text{for all } k \\ge 1$$\nEvery single term in the Monte Carlo sum is exactly equal to $1$. Substituting this result back into the expression for the estimator $\\widehat{I}_n$:\n$$\\widehat{I}_{n} = \\frac{1}{n}\\sum_{k=1}^{n} 1 = \\frac{1}{n} \\cdot n = 1$$\nThis result holds for any sample size $n \\ge 1$. The sequence of estimators is constant, $\\widehat{I}_n = 1$ for all $n$. Therefore, the limit is trivial to compute:\n$$\\lim_{n\\to\\infty} \\widehat{I}_{n} = \\lim_{n\\to\\infty} 1 = 1$$\nThe problem statement notes that the period of the generator is $m-1$. This guarantees that the sequence $\\{u_k\\}$ is periodic, which ensures that the limit $\\lim_{n\\to\\infty} \\widehat{I}_n$ exists and is equal to the average of $f(u_k)$ over one full period. While this information is useful for rigorously establishing the existence of the limit, our direct evaluation of $f(u_k)$ shows that every term is identically $1$, making the calculation of the limit straightforward.\n\nFinally, we can compute the asymptotic bias $b$.\n$$b = \\lim_{n\\to\\infty} \\widehat{I}_{n} - I$$\nSubstituting the values we found:\n$$b = 1 - 0 = 1$$\nThe asymptotic bias is exactly $1$. This illustrates a critical failure of this specific PRNG for this specific integrand. The discrete nature of the generated points $u_k=x_k/m$ perfectly aligns with the high frequency of the function $f(u)=\\cos(2\\pi m u)$, causing the Monte Carlo method to systematically sample the function only at its maxima.",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "Beyond the large-scale lattice defects explored previously , PRNGs can exhibit more subtle flaws in the form of short-range correlations. A classic example is the poor performance of the low-order bits in LCGs that use a power-of-two modulus. This practice moves from identifying qualitative failures to quantitatively assessing their impact on a statistical estimator . By deriving the deterministic relationship between successive outputs and calculating the precise effect on the variance of a sample mean, you will develop the analytical skills needed to diagnose and understand the consequences of correlational defects in a random number stream.",
            "id": "3333419",
            "problem": "Consider a Linear Congruential Generator (LCG) defined by the recurrence $x_{t+1} \\equiv a x_t + c \\pmod{m}$ with modulus $m = 2^w$, multiplier $a$, and increment $c$. It is widely recognized that in modulo arithmetic, congruences propagate down to residues modulo divisors, so the recurrence for the $k$ lowest-order bits (i.e., modulo $2^k$ with $k \\leq w$) is $x_{t+1} \\equiv a x_t + c \\pmod{2^k}$. In this problem, you will analyze the impact of using low-order bits to form pseudo-random variates in stochastic simulation.\n\nLet $w = 3$, $a = 1$, $c = 1$, and $m = 2^w = 8$. Define the pseudo-random variate $U_t$ by mapping the $k = 3$ lowest-order bits of $x_t$ into the unit interval via $U_t = (x_t \\bmod 2^k)/2^k$. Assume an unknown seed $x_0$ that is uniformly distributed on $\\{0,1,\\dots,7\\}$, and consider the Monte Carlo estimator of the mean, $\\hat{\\mu}_n = \\frac{1}{n} \\sum_{t=1}^{n} U_t$.\n\nYour tasks are:\n1. Starting from the definition of the LCG, formally show that with the above parameters the sequence of low-order-bit variates obeys $U_{t+1} \\equiv U_t + 2^{-3} \\pmod{1}$, and deduce that this induces severe serial correlations. Your argument must rely only on the recurrence definition, modular arithmetic, and the mapping from bits to the unit interval.\n2. Using only first principles for the variance of averages of dependent sequences, compute the exact variance $\\operatorname{Var}[\\hat{\\mu}_n]$ when $n = 3$, taking the expectation with respect to the uniform seed $x_0$.\n\nExpress your final answer as an exact fraction. Do not round.",
            "solution": "The problem is divided into two parts. The first is to establish a deterministic recurrence for the pseudo-random variates $U_t$. The second is to compute the variance of a Monte Carlo estimator based on a sequence of these variates.\n\n**Part 1: Recurrence Relation for $U_t$**\n\nThe Linear Congruential Generator (LCG) is defined by the recurrence relation $x_{t+1} \\equiv a x_t + c \\pmod{m}$. The problem provides the specific parameters: multiplier $a=1$, increment $c=1$, and modulus $m=2^w$ with $w=3$, so $m=2^3=8$. The recurrence is thus:\n$$\nx_{t+1} \\equiv x_t + 1 \\pmod{8}\n$$\nThis means that for any integer state $x_t \\in \\{0, 1, \\dots, 7\\}$, the next state $x_{t+1}$ is given by $x_{t+1} = (x_t + 1) \\bmod 8$.\n\nThe pseudo-random variate $U_t$ is defined by mapping the $k$ lowest-order bits of $x_t$ to the unit interval $[0, 1)$. The number of bits is specified as $k=3$. The mapping is $U_t = (x_t \\bmod 2^k)/2^k$. With $k=3$, this becomes:\n$$\nU_t = \\frac{x_t \\bmod 2^3}{2^3} = \\frac{x_t \\bmod 8}{8}\n$$\nSince the states $x_t$ are themselves the result of a modulo $8$ operation, they are always in the set $\\{0, 1, \\dots, 7\\}$. For any such $x_t$, we have $x_t \\bmod 8 = x_t$. Therefore, the relation simplifies to:\n$$\nU_t = \\frac{x_t}{8}\n$$\nThis implies $x_t = 8 U_t$. We can substitute this into the recurrence for $x_t$. The next state is given by $x_{t+1} = (x_t + 1) \\bmod 8$. The corresponding variate $U_{t+1}$ is:\n$$\nU_{t+1} = \\frac{x_{t+1}}{8} = \\frac{(x_t + 1) \\bmod 8}{8}\n$$\nSubstituting $x_t = 8 U_t$:\n$$\nU_{t+1} = \\frac{(8 U_t + 1) \\bmod 8}{8}\n$$\nThe operation $(z \\bmod N)/N$ gives the fractional part of the number $z/N$, which can be written as $\\{z/N\\}$ or $z/N \\pmod 1$. Applying this insight, we get:\n$$\nU_{t+1} = \\frac{8 U_t + 1}{8} \\pmod 1 = \\left(U_t + \\frac{1}{8}\\right) \\pmod 1\n$$\nWith $2^{-3} = 1/8$, we have successfully shown that the sequence of variates obeys the relation:\n$$\nU_{t+1} \\equiv U_t + 2^{-3} \\pmod{1}\n$$\nThis recurrence is fully deterministic. Given any $U_t$, the value of $U_{t+1}$ is uniquely determined. This demonstrates a perfect linear relationship between successive values, which represents an extreme case of serial correlation. A plot of pairs $(U_t, U_{t+1})$ would show points lying on just two parallel lines, $y=x+1/8$ and $y=x-7/8$, which is a catastrophic failure for a sequence intended to be pseudo-random.\n\n**Part 2: Variance Calculation for $\\hat{\\mu}_3$**\n\nThe Monte Carlo estimator for the mean is given by $\\hat{\\mu}_n = \\frac{1}{n} \\sum_{t=1}^{n} U_t$. We are asked to compute its variance for $n=3$, which is $\\operatorname{Var}[\\hat{\\mu}_3]$.\n$$\n\\operatorname{Var}[\\hat{\\mu}_3] = \\operatorname{Var}\\left[\\frac{1}{3}(U_1 + U_2 + U_3)\\right] = \\frac{1}{9} \\operatorname{Var}[U_1 + U_2 + U_3]\n$$\nThe variance of a sum of random variables is given by:\n$$\n\\operatorname{Var}\\left[\\sum_{t=1}^{n} U_t\\right] = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\operatorname{Cov}[U_i, U_j] = \\sum_{t=1}^{n} \\operatorname{Var}[U_t] + 2 \\sum_{1 \\le i < j \\le n} \\operatorname{Cov}[U_i, U_j]\n$$\nFor $n=3$, this expands to:\n$$\n\\operatorname{Var}[U_1 + U_2 + U_3] = \\operatorname{Var}[U_1] + \\operatorname{Var}[U_2] + \\operatorname{Var}[U_3] + 2(\\operatorname{Cov}[U_1, U_2] + \\operatorname{Cov}[U_1, U_3] + \\operatorname{Cov}[U_2, U_3])\n$$\nThe expectation is taken over the distribution of the seed $x_0$, which is uniform on $\\{0, 1, \\dots, 7\\}$. The sequence of states is $x_t = (x_0 + t) \\bmod 8$, and the variates are $U_t = x_t/8$.\n\nFirst, we establish the properties of the sequence $\\{U_t\\}$. Since $x_0$ is a uniform random variable on $\\{0, 1, \\dots, 7\\}$, and $t$ is a constant, the variable $x_t = (x_0 + t) \\bmod 8$ is also uniformly distributed on $\\{0, 1, \\dots, 7\\}$ for any $t \\ge 1$. Consequently, each $U_t$ follows the same discrete uniform distribution on the set $\\{0, \\frac{1}{8}, \\frac{2}{8}, \\dots, \\frac{7}{8}\\}$, with $P(U_t = i/8) = 1/8$ for $i \\in \\{0, \\dots, 7\\}$. This implies the sequence is stationary, so $\\operatorname{E}[U_t]$ and $\\operatorname{Var}[U_t]$ are constant for all $t$, and the autocovariance $\\operatorname{Cov}[U_t, U_{t+k}]$ depends only on the lag $k$.\n\nWe compute the first and second moments of $U_t$:\n$$\n\\operatorname{E}[U_t] = \\sum_{i=0}^{7} \\frac{i}{8} P\\left(x_t = i\\right) = \\frac{1}{8} \\sum_{i=0}^{7} \\frac{i}{8} = \\frac{1}{64} \\frac{7(8)}{2} = \\frac{28}{64} = \\frac{7}{16}\n$$\n$$\n\\operatorname{E}[U_t^2] = \\sum_{i=0}^{7} \\left(\\frac{i}{8}\\right)^2 P\\left(x_t = i\\right) = \\frac{1}{8} \\sum_{i=0}^{7} \\frac{i^2}{64} = \\frac{1}{512} \\sum_{i=0}^{7} i^2 = \\frac{1}{512} \\frac{7(7+1)(2 \\cdot 7+1)}{6} = \\frac{140}{512} = \\frac{35}{128}\n$$\nThe variance is:\n$$\n\\operatorname{Var}[U_t] = \\operatorname{E}[U_t^2] - (\\operatorname{E}[U_t])^2 = \\frac{35}{128} - \\left(\\frac{7}{16}\\right)^2 = \\frac{35}{128} - \\frac{49}{256} = \\frac{70 - 49}{256} = \\frac{21}{256}\n$$\nSo, $\\operatorname{Var}[U_1] = \\operatorname{Var}[U_2] = \\operatorname{Var}[U_3] = 21/256$.\n\nNext, we compute the autocovariances $\\gamma(k) = \\operatorname{Cov}[U_t, U_{t+k}]$.\n$\\gamma(k) = \\operatorname{E}[U_t U_{t+k}] - \\operatorname{E}[U_t]\\operatorname{E}[U_{t+k}] = \\operatorname{E}[U_t U_{t+k}] - (7/16)^2$.\nWe have $U_{t+k} = ((x_t+k)\\pmod 8)/8$.\n$$\n\\operatorname{E}[U_t U_{t+k}] = \\operatorname{E}\\left[\\frac{x_t}{8} \\frac{(x_t+k)\\pmod 8}{8}\\right] = \\frac{1}{64}\\operatorname{E}[x_t ((x_t+k)\\pmod 8)]\n$$\nThe expectation is over $x_t \\sim U\\{0, \\dots, 7\\}$.\n$$\n\\operatorname{E}[x_t ((x_t+k)\\pmod 8)] = \\frac{1}{8}\\sum_{j=0}^{7} j ((j+k)\\pmod 8)\n$$\nFor lag $k=1$:\n$$\n\\frac{1}{8}\\sum_{j=0}^{7} j ((j+1)\\pmod 8) = \\frac{1}{8}(0 \\cdot 1 + 1 \\cdot 2 + 2 \\cdot 3 + 3 \\cdot 4 + 4 \\cdot 5 + 5 \\cdot 6 + 6 \\cdot 7 + 7 \\cdot 0) = \\frac{112}{8} = 14\n$$\nSo $\\operatorname{E}[U_t U_{t+1}] = 14/64 = 7/32$.\n$\\gamma(1) = \\operatorname{Cov}[U_1, U_2] = \\operatorname{Cov}[U_2, U_3] = \\frac{7}{32} - \\frac{49}{256} = \\frac{56 - 49}{256} = \\frac{7}{256}$.\n\nFor lag $k=2$:\n$$\n\\frac{1}{8}\\sum_{j=0}^{7} j ((j+2)\\pmod 8) = \\frac{1}{8}(0 \\cdot 2 + 1 \\cdot 3 + 2 \\cdot 4 + 3 \\cdot 5 + 4 \\cdot 6 + 5 \\cdot 7 + 6 \\cdot 0 + 7 \\cdot 1) = \\frac{92}{8} = \\frac{23}{2}\n$$\nSo $\\operatorname{E}[U_t U_{t+2}] = (23/2)/64 = 23/128$.\n$\\gamma(2) = \\operatorname{Cov}[U_1, U_3] = \\frac{23}{128} - \\frac{49}{256} = \\frac{46 - 49}{256} = -\\frac{3}{256}$.\n\nNow we assemble the variance of the sum:\n\\begin{align*} \\operatorname{Var}[U_1 + U_2 + U_3] &= 3 \\operatorname{Var}[U_t] + 2(2\\gamma(1) + \\gamma(2)) \\\\ &= 3\\left(\\frac{21}{256}\\right) + 2\\left(2\\left(\\frac{7}{256}\\right) - \\frac{3}{256}\\right) \\\\ &= \\frac{63}{256} + 2\\left(\\frac{14 - 3}{256}\\right) \\\\ &= \\frac{63}{256} + 2\\left(\\frac{11}{256}\\right) = \\frac{63+22}{256} = \\frac{85}{256} \\end{align*}\nFinally, the variance of the estimator $\\hat{\\mu}_3$ is:\n$$\n\\operatorname{Var}[\\hat{\\mu}_3] = \\frac{1}{9} \\operatorname{Var}[U_1 + U_2 + U_3] = \\frac{1}{9} \\cdot \\frac{85}{256} = \\frac{85}{2304}\n$$\nThe numerator is $85 = 5 \\times 17$ and the denominator is $2304 = 9 \\times 256 = 3^2 \\times 2^8$, so the fraction is in its simplest form.",
            "answer": "$$\n\\boxed{\\frac{85}{2304}}\n$$"
        },
        {
            "introduction": "After investigating the potential failures of PRNGs, we now focus on a powerful and essential technique for their proper use in high-performance computing. To achieve scalable and reproducible results in parallel Monte Carlo simulations, it is critical to ensure each process uses a unique, non-overlapping stream of random numbers. This hands-on practice guides you through the derivation and implementation of an efficient \"skip-ahead\" algorithm for LCGs . Mastering this technique, which relies on the algebraic properties of the generator's update rule, is a vital practical skill for deploying robust and statistically sound simulations in computational physics.",
            "id": "3529403",
            "problem": "You are tasked with formalizing and implementing an efficient skip-ahead method for a Linear Congruential Generator (LCG), a widely used pseudo-random number generator in computational high-energy physics (HEP), particularly for large-scale Monte Carlo event generation where reproducibility, parallelism, and stream partitioning are essential. The base process is the LCG recurrence on integers modulo a positive integer modulus:\n- The state update is given by $x_{t+1} = (a x_t + c) \\bmod m$ for all integers $t \\ge 0$, where the parameters $a$, $c$, and $m$ are fixed integers with $m \\ge 2$, and $x_t \\in \\{0,1,\\dots,m-1\\}$.\n\nStarting from this fundamental definition of the LCG and standard properties of modular arithmetic (such as associativity and distributivity of addition and multiplication modulo $m$), derive a closed-form expression for $x_{t+n}$ as a function of $a$, $c$, $m$, $x_t$, and $n$, without assuming any special number-theoretic properties of $m$ (do not assume primality or coprimality conditions). Your derivation must begin from the recurrence definition and must not assume any pre-known closed form. The resulting formula must be valid for all integers $n \\ge 0$, including special cases such as $a = 1$ and $c = 0$.\n\nThen, design an algorithm that computes $x_{t+n}$ in time polylogarithmic in $n$, specifically with asymptotic complexity $\\mathcal{O}(\\log n)$ arithmetic operations modulo $m$, so that it remains computationally feasible when $n$ is as large as $10^{12}$. The algorithm must avoid modular inverses and should be correct for arbitrary $m$ (including $m$ that are powers of two). Your design must be grounded in first principles and must clearly identify the algebraic structure being exponentiated.\n\nFinally, implement your algorithm as a complete program that produces the outputs for the following test suite. Each test case is independent. For each, compute the single requested result and collect all results in the specified output format.\n\nTest suite:\n- Case A (identity boundary): parameters $m = 97$, $a = 5$, $c = 3$, $x_t = 42$, $n = 0$. Output the integer $x_{t+n}$.\n- Case B (single-step check): parameters $m = 97$, $a = 5$, $c = 3$, $x_t = 42$, $n = 1$. Output the integer $x_{t+n}$.\n- Case C (two-step check): parameters $m = 97$, $a = 5$, $c = 3$, $x_t = 42$, $n = 2$. Output the integer $x_{t+n}$.\n- Case D (large $n$ with small prime modulus): parameters $m = 97$, $a = 5$, $c = 3$, $x_t = 42$, $n = 10^{12}$. Output the integer $x_{t+n}$.\n- Case E (large $n$ with power-of-two modulus used in practice): parameters $m = 2^{48}$, $a = 25214903917$, $c = 11$, $x_t = 0$, $n = 10^{12}$. Output the integer $x_{t+n}$.\n- Case F (multiplicative generator edge case): parameters $m = 2^{48}$, $a = 25214903917$, $c = 0$, $x_t = 1$, $n = 10^{12}$. Output the integer $x_{t+n}$.\n- Case G (degenerate multiplier $a = 1$ edge case): parameters $m = 1{,}000{,}000{,}007$, $a = 1$, $c = 123{,}456{,}789$, $x_t = 987{,}654{,}321$, $n = 10^{12}$. Output the integer $x_{t+n}$.\n- Case H (semigroup consistency property as a boolean): parameters $m = 2^{48}$, $a = 25214903917$, $c = 11$, $x_t = 123{,}456{,}789{,}012{,}345$, $n_1 = 10^{12} - 1{,}234{,}567$, $n_2 = 1{,}234{,}567$. Compute the boolean truth value of the statement that $x_{t+(n_1+n_2)}$ equals the result of applying skip-ahead by $n_1$ and then by $n_2$, i.e., whether\n$$\n\\bigl(x_{t+n_1}\\bigr) \\xrightarrow{\\text{skip by } n_2} x_{t+n_1+n_2}\n\\quad \\text{equals} \\quad\nx_{t+(n_1+n_2)}\n$$\nwhen both are computed by your $\\mathcal{O}(\\log n)$ algorithm.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for Cases A through H, in order, as a comma-separated list enclosed in square brackets (for example, $[r_A,r_B,\\dots,r_H]$), where each $r$ is either an integer or a boolean as specified above. No additional text should be printed.\n\nNo physical units or angle units are involved. All numeric outputs must be exact integers or booleans as specified. The algorithm must run in time feasible for $n = 10^{12}$ on a modern machine, by employing an $\\mathcal{O}(\\log n)$ skip-ahead strategy.",
            "solution": "The problem asks for the derivation and implementation of an efficient skip-ahead algorithm for a Linear Congruential Generator (LCG). An LCG is defined by the recurrence relation:\n$$x_{t+1} = (a x_t + c) \\bmod m$$\nfor integers $t \\ge 0$, where $a$ (the multiplier), $c$ (the increment), and $m$ (the modulus) are fixed integer parameters with $m \\ge 2$. The state of the generator at time $t$ is $x_t$, an integer in the set $\\{0, 1, \\dots, m-1\\}$. The task is to find $x_{t+n}$ given $x_t$ and a large integer step $n$, in a time complexity polylogarithmic in $n$, specifically $\\mathcal{O}(\\log n)$.\n\nFirst, we derive a closed-form expression for $x_{t+n}$ by unrolling the recurrence.\nFor $n=1$:\n$$x_{t+1} = a x_t + c$$\nFor $n=2$:\n$$x_{t+2} = a x_{t+1} + c = a(a x_t + c) + c = a^2 x_t + ac + c$$\nFor $n=3$:\n$$x_{t+3} = a x_{t+2} + c = a(a^2 x_t + ac + c) + c = a^3 x_t + a^2 c + ac + c$$\nObserving the pattern, we hypothesize that for any integer $n \\ge 0$, the state $x_{t+n}$ is given by:\n$$x_{t+n} = a^n x_t + c \\left(\\sum_{i=0}^{n-1} a^i\\right)$$\nAll arithmetic is performed modulo $m$. We prove this formula by mathematical induction on $n$.\n\n**Base Case ($n=0$):** The formula gives $x_{t+0} = a^0 x_t + c \\sum_{i=0}^{-1} a^i$. The empty sum is $0$, so $x_{t+0} = 1 \\cdot x_t + c \\cdot 0 = x_t$. This is correct.\n**Base Case ($n=1$):** The formula gives $x_{t+1} = a^1 x_t + c \\sum_{i=0}^{0} a^i = a x_t + c \\cdot a^0 = a x_t + c$. This matches the LCG recurrence.\n\n**Inductive Step:** Assume the formula is true for some integer $k \\ge 0$:\n$$x_{t+k} = a^k x_t + c \\left(\\sum_{i=0}^{k-1} a^i\\right)$$\nWe now find an expression for $x_{t+k+1}$:\n$$x_{t+k+1} = a x_{t+k} + c$$\nSubstituting the inductive hypothesis for $x_{t+k}$:\n$$x_{t+k+1} = a \\left( a^k x_t + c \\sum_{i=0}^{k-1} a^i \\right) + c$$\n$$x_{t+k+1} = a^{k+1} x_t + a c \\sum_{i=0}^{k-1} a^i + c$$\n$$x_{t+k+1} = a^{k+1} x_t + c \\left( a \\sum_{i=0}^{k-1} a^i + 1 \\right)$$\n$$x_{t+k+1} = a^{k+1} x_t + c \\left( \\sum_{i=0}^{k-1} a^{i+1} + a^0 \\right)$$\n$$x_{t+k+1} = a^{k+1} x_t + c \\left( \\sum_{j=1}^{k} a^{j} + a^0 \\right) = a^{k+1} x_t + c \\left( \\sum_{j=0}^{k} a^{j} \\right)$$\nThis is the hypothesized formula for $n=k+1$. The induction is complete. The closed-form expression for $x_{t+n}$ is:\n$$x_{t+n} = \\left(a^n x_t + c \\left(\\sum_{i=0}^{n-1} a^i\\right)\\right) \\bmod m$$\nThe term $\\sum_{i=0}^{n-1} a^i$ is a geometric series. If $a \\ne 1$, its sum is $\\frac{a^n-1}{a-1}$. Using this would require computing the modular multiplicative inverse of $(a-1) \\pmod m$, which may not exist if $\\gcd(a-1, m) \\ne 1$. The problem explicitly forbids this approach. If $a=1$, the sum is simply $n$. A general method is needed.\n\nTo achieve $\\mathcal{O}(\\log n)$ complexity without modular inverses, we can represent the LCG update as an affine transformation and use exponentiation by squaring on this transformation. The function $f(x) = (ax+c) \\pmod m$ maps a state $x_t$ to $x_{t+1}$. Applying the LCG for $n$ steps is equivalent to composing this function with itself $n$ times: $f^n(x_t) = f(f(\\dots f(x_t)\\dots))$.\n\nThe algebraic structure of these affine transformations can be captured using $2 \\times 2$ matrices. We augment the state $x_t$ into a vector $\\begin{pmatrix} x_t \\\\ 1 \\end{pmatrix}$. The LCG update can then be written as a matrix-vector product:\n$$ \\begin{pmatrix} x_{t+1} \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} a & c \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} x_t \\\\ 1 \\end{pmatrix} \\pmod m $$\nLet $T = \\begin{pmatrix} a & c \\\\ 0 & 1 \\end{pmatrix}$. Applying the transformation $n$ times corresponds to raising the matrix $T$ to the $n$-th power:\n$$ \\begin{pmatrix} x_{t+n} \\\\ 1 \\end{pmatrix} = T^n \\begin{pmatrix} x_t \\\\ 1 \\end{pmatrix} \\pmod m $$\nThe power $T^n$ can be computed efficiently in $\\mathcal{O}(\\log n)$ time using exponentiation by squaring. The operations are $2 \\times 2$ matrix multiplications modulo $m$.\nThe structure of $T^n$ is $T^n = \\begin{pmatrix} a^n & c \\sum_{i=0}^{n-1} a^i \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} A_n & C_n \\\\ 0 & 1 \\end{pmatrix}$, where $A_n = a^n$ and $C_n = c \\sum_{i=0}^{n-1} a^i$ are the effective multiplier and increment for $n$ steps.\nInstead of implementing full matrix multiplication, we can work directly with the pair of coefficients $(A, C)$ that define the affine transformation $x \\mapsto Ax+C$.\nThe composition of two transformations, $(A_1, C_1)$ followed by $(A_2, C_2)$, is:\n$x \\xrightarrow{(A_1, C_1)} A_1 x + C_1 \\xrightarrow{(A_2, C_2)} A_2(A_1 x + C_1) + C_2 = (A_2 A_1) x + (A_2 C_1 + C_2)$.\nThis defines a composition law for the transformation pairs:\n$$(A_2, C_2) \\circ (A_1, C_1) = (A_2 A_1, A_2 C_1 + C_2)$$\nThis composition is associative. We want to compute $(a,c)^n$, which is $(a,c)$ composed with itself $n$ times. We can use binary exponentiation (exponentiation by squaring) on this pair structure.\n\nThe algorithm to compute $(A_n, C_n) = (a, c)^n$ is as follows:\n1. Initialize a result pair $(A_{res}, C_{res})$ to the identity transformation, which is $(1, 0)$ (since $1 \\cdot x + 0 = x$).\n2. Initialize an accumulator pair $(A_{acc}, C_{acc})$ to the base transformation, $(a, c)$.\n3. Iterate while $n > 0$:\n   a. If $n$ is odd, compose the result with the accumulator: $(A_{res}, C_{res}) \\leftarrow (A_{acc}, C_{acc}) \\circ (A_{res}, C_{res})$.\n      - $A_{res}' = (A_{acc} \\cdot A_{res}) \\bmod m$\n      - $C_{res}' = (A_{acc} \\cdot C_{res} + C_{acc}) \\bmod m$\n   b. Square the accumulator: $(A_{acc}, C_{acc}) \\leftarrow (A_{acc}, C_{acc}) \\circ (A_{acc}, C_{acc})$.\n      - $A_{acc}' = (A_{acc} \\cdot A_{acc}) \\bmod m$\n      - $C_{acc}' = (A_{acc} \\cdot C_{acc} + C_{acc}) \\bmod m$\n   c. Update $n$ to $n \\leftarrow \\lfloor n/2 \\rfloor$.\n4. The final pair $(A_{res}, C_{res})$ is $(A_n, C_n)$.\n\nAfter computing $(A_n, C_n)$, the final state $x_{t+n}$ is calculated as:\n$$x_{t+n} = (A_n \\cdot x_t + C_n) \\bmod m$$\nThis entire process involves a number of modular multiplications and additions proportional to $\\log_2 n$, fulfilling the complexity requirement. It avoids modular inverses and is valid for any choice of parameters $m, a, c$ as specified. This principled approach, grounded in the algebraic structure of affine transformations, yields a robust and efficient algorithm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LCG skip-ahead problem for a suite of test cases.\n    \"\"\"\n    \n    def lcg_skip_ahead(m, a, c, x0, n):\n        \"\"\"\n        Computes the n-th state of an LCG starting from x0 in O(log n) time.\n        The LCG is defined by x_next = (a * x + c) % m.\n\n        Args:\n            m (int): The modulus.\n            a (int): The multiplier.\n            c (int): The increment.\n            x0 (int): The initial state.\n            n (int): The number of steps to advance.\n\n        Returns:\n            int: The state x_n.\n        \"\"\"\n        if n == 0:\n            return x0\n\n        # The LCG recurrence x_next = a*x + c is an affine transformation.\n        # Advancing n steps is equivalent to composing this transformation n times.\n        # We can represent the transformation as a pair (A, C) for x -> A*x + C.\n        # The composition of (A1, C1) and (A2, C2) is (A2*A1, A2*C1 + C2).\n        # We use binary exponentiation (exponentiation by squaring) on this\n        # transformation pair to compute the n-step transformation (A_n, C_n).\n\n        # Ensure all initial parameters are within the modulus\n        a %= m\n        c %= m\n\n        # A_res, C_res store the resulting n-step transformation.\n        # Initialize to the identity transformation (A=1, C=0).\n        A_res, C_res = 1, 0  \n\n        # A_acc, C_acc store the transformation for the current power of 2.\n        # Initialize to the single-step transformation (a, c).\n        A_acc, C_acc = a, c\n        \n        k = n\n        while k > 0:\n            if k % 2 == 1:\n                # Compose the result with the current power-of-2 transformation.\n                # (A_res, C_res) -> (A_acc, C_acc) o (A_res, C_res)\n                # A_res' = A_acc * A_res\n                # C_res' = A_acc * C_res + C_acc\n                A_res_new = (A_acc * A_res) % m\n                C_res_new = (A_acc * C_res + C_acc) % m\n                A_res, C_res = A_res_new, C_res_new\n\n            # Square the power-of-2 transformation.\n            # (A_acc, C_acc) -> (A_acc, C_acc) o (A_acc, Cacc)\n            # A_acc' = A_acc * A_acc\n            # C_acc' = A_acc * C_acc + C_acc\n            A_acc_new = (A_acc * A_acc) % m\n            C_acc_new = (A_acc * C_acc + C_acc) % m\n            A_acc, C_acc = A_acc_new, C_acc_new\n            \n            k //= 2\n\n        # After the loop, (A_res, C_res) is the n-step transformation.\n        # Apply it to the initial state x0.\n        return (A_res * x0 + C_res) % m\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, a, c, x_t, n_or_n1, n2)\n        ('A', 97, 5, 3, 42, 0, None),\n        ('B', 97, 5, 3, 42, 1, None),\n        ('C', 97, 5, 3, 42, 2, None),\n        ('D', 97, 5, 3, 42, 10**12, None),\n        ('E', 2**48, 25214903917, 11, 0, 10**12, None),\n        ('F', 2**48, 25214903917, 0, 1, 10**12, None),\n        ('G', 1000000007, 1, 123456789, 987654321, 10**12, None),\n        ('H', 2**48, 25214903917, 11, 123456789012345, 10**12 - 1234567, 1234567),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_id, m, a, c, x_t, n1, n2 = case\n        \n        if case_id != 'H':\n            result = lcg_skip_ahead(m, a, c, x_t, n1)\n        else:\n            # Case H: Check semigroup property\n            n_total = n1 + n2\n            \n            # Compute x_{t + n1 + n2} directly\n            res_direct = lcg_skip_ahead(m, a, c, x_t, n_total)\n            \n            # Compute sequentially: skip by n1, then by n2\n            x_intermediate = lcg_skip_ahead(m, a, c, x_t, n1)\n            res_sequential = lcg_skip_ahead(m, a, c, x_intermediate, n2)\n            \n            result = (res_direct == res_sequential)\n            \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}