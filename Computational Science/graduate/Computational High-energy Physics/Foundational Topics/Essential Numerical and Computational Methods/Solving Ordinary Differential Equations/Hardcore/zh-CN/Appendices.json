{
    "hands_on_practices": [
        {
            "introduction": "龙格-库塔（Runge-Kutta）方法并非一组任意的公式，而是通过将其单步展开式与解的泰勒级数展开式进行匹配，以达到特定精度阶数而系统构建的。本练习将引导您从第一性原理出发，为整个二阶、两阶段显式龙格-库塔方法族推导出“阶条件”，从而建立对这些数值积分方法来源的基础理解。",
            "id": "3537359",
            "problem": "在计算高能物理中，许多动力学量是通过对常微分方程进行积分来演化的，例如在对数能量标度变量下耦合常数的重整化群流。考虑一个由下式决定的自治标量流 $g(s)$：\n$$\n\\frac{dg}{ds} = \\beta(g),\n$$\n其中 $s = \\ln(\\mu/\\mu_{0})$，$\\mu$ 是能量标度，而 $\\beta$ 是一个足够光滑的 beta 函数。为了从 $s$ 数值积分到 $s+h$，构建一个具有单个自由级横坐标参数 $c_{2}$ 的两级显式 Runge–Kutta (RK) 方法：\n$$\nk_{1} = \\beta\\!\\big(g(s)\\big), \\quad k_{2} = \\beta\\!\\big(g(s) + h\\,a_{21}\\,k_{1}\\big),\n$$\n以及更新步骤\n$$\ng(s+h) \\approx g(s) + h\\big(b_{1}\\,k_{1} + b_{2}\\,k_{2}\\big).\n$$\n通过将该方法的单步展开式与精确解的泰勒展开式匹配至 $h^{2}$ 阶项，来施加二阶精度要求。推导过程仅从导数、链式法则和泰勒定理的核心定义出发。求解由此得到的阶条件，以获得一个由 $c_{2}$ 参数化的二阶显式 RK 格式族，并推导出 $(a_{21}, b_{1}, b_{2})$ 关于 $c_{2}$ 的解析表达式。指出确保系数良定义所需的对 $c_{2}$ 的任何必要约束。将最终答案表示为三元组 $(a_{21}, b_{1}, b_{2})$ 的单一闭式解析表达式。最终表达式无需四舍五入，也不应包含任何单位。",
            "solution": "该问题要求推导一种通用的两级显式 Runge-Kutta (RK) 方法的系数，该方法对于形式为 $\\frac{dg}{ds} = \\beta(g)$ 的自治常微分方程 (ODE) 能达到二阶精度。推导必须从第一性原理出发，通过将该方法的单步展开式与精确解的泰勒级数进行匹配。\n\n首先，我们建立精确解 $g(s+h)$ 在点 $s$ 附近的泰勒级数展开式。展开到 $h^2$ 阶项，表达式为\n$$\ng(s+h) = g(s) + h \\frac{dg}{ds} \\bigg|_s + \\frac{h^2}{2!} \\frac{d^2g}{ds^2} \\bigg|_s + O(h^3).\n$$\n我们使用给定的 ODE $\\frac{dg}{ds} = \\beta(g)$，将 $g$ 的导数用函数 $\\beta$ 及其关于 $g$ 的导数来表示。为简洁起见，我们将 $g(s)$ 记为 $g_s$。\n一阶导数为\n$$\n\\frac{dg}{ds} \\bigg|_s = \\beta(g_s).\n$$\n二阶导数使用链式法则求得：\n$$\n\\frac{d^2g}{ds^2} \\bigg|_s = \\frac{d}{ds} \\left( \\beta(g(s)) \\right) \\bigg|_s = \\frac{d\\beta}{dg} \\bigg|_{g_s} \\frac{dg}{ds} \\bigg|_s = \\beta'(g_s) \\beta(g_s).\n$$\n此处，$\\beta'(g_s)$ 表示 $\\beta$ 对其自变量 $g$ 的导数在 $g_s$ 处的值。将这些导数代入泰勒展开式，得到精确解的展开式：\n$$\ng(s+h) = g_s + h \\beta(g_s) + \\frac{h^2}{2} \\beta'(g_s) \\beta(g_s) + O(h^3).\n$$\n\n接下来，我们展开指定的两级 RK 方法所提供的数值近似。该方法由以下几个级定义\n$$\nk_{1} = \\beta(g_s),\n$$\n$$\nk_{2} = \\beta(g_s + h a_{21} k_{1}),\n$$\n以及更新法则\n$$\ng_{s+h} \\approx g_s + h(b_{1} k_{1} + b_{2} k_{2}).\n$$\n为分析精度，我们使用关于变量 $h$ 在 $h=0$ 附近的泰勒级数展开 $k_{2}$。$k_2$ 中 $\\beta$ 的自变量是 $g_s + h a_{21} \\beta(g_s)$。\n$$\nk_2 = \\beta(g_s) + \\big(h a_{21} \\beta(g_s)\\big) \\beta'(g_s) + \\frac{1}{2!} \\big(h a_{21} \\beta(g_s)\\big)^2 \\beta''(g_s) + \\dots\n$$\n截断到与精确解展开式相同的阶，我们只需要到 $O(h)$ 的项：\n$$\nk_2 = \\beta(g_s) + h a_{21} \\beta(g_s) \\beta'(g_s) + O(h^2).\n$$\n现在，我们将 $k_1$ 的表达式和 $k_2$ 的展开式代入更新法则：\n$$\ng_{s+h} \\approx g_s + h \\left( b_1 \\beta(g_s) + b_2 \\left[ \\beta(g_s) + h a_{21} \\beta(g_s) \\beta'(g_s) + O(h^2) \\right] \\right).\n$$\n分配各项，我们得到数值方法的展开式：\n$$\ng_{s+h} \\approx g_s + h (b_1 + b_2) \\beta(g_s) + h^2 (b_2 a_{21}) \\beta(g_s) \\beta'(g_s) + O(h^3).\n$$\n\n为使该方法具有二阶精度，此展开式必须与 $g(s+h)$ 的精确泰勒展开式在 $h^2$ 阶项上完全匹配。通过比较包含 $\\beta(g_s)$ 和 $\\beta(g_s)\\beta'(g_s)$ 的项的系数，我们推导出阶条件。\n比较 $h^1$ 阶的项：\n$$\n(b_1 + b_2) \\beta(g_s) = 1 \\cdot \\beta(g_s) \\implies b_1 + b_2 = 1.\n$$\n这是一阶条件。\n比较 $h^2$ 阶的项：\n$$\n(b_2 a_{21}) \\beta(g_s) \\beta'(g_s) = \\frac{1}{2} \\beta(g_s) \\beta'(g_s) \\implies b_2 a_{21} = \\frac{1}{2}.\n$$\n这是二阶条件。\n\n问题指明该方法具有单个自由的级横坐标参数 $c_2$。在 Runge-Kutta 方法的标准形式中，级横坐标 $c_i$ 与系数 $a_{ij}$ 通过关系式 $c_i = \\sum_{j=1}^{i-1} a_{ij}$ 相关联。对于两级方法，这得到 $c_2 = a_{21}$。我们使用这个标准定义来用 $c_2$ 表示这些系数。\n阶条件方程组变为：\n1. $b_1 + b_2 = 1$\n2. $b_2 c_2 = \\frac{1}{2}$\n3. $a_{21} = c_2$\n\n我们求解这个方程组，用 $c_2$ 表示 $(a_{21}, b_1, b_2)$。\n从第二个方程，我们可以表示出 $b_2$：\n$$\nb_2 = \\frac{1}{2c_2}.\n$$\n这个表达式立即揭示了对参数 $c_2$ 的一个必要约束：为使系数 $b_2$ 是良定义的，我们必须有 $c_2 \\neq 0$。\n\n将 $b_2$ 的这个表达式代入第一个方程，我们求解出 $b_1$：\n$$\nb_1 = 1 - b_2 = 1 - \\frac{1}{2c_2}.\n$$\n系数 $a_{21}$ 仅仅等于 $c_2$。\n因此，由 $c_2$ 参数化的二阶显式两级 Runge-Kutta 方法族由以下系数定义：\n$$\na_{21} = c_2\n$$\n$$\nb_1 = 1 - \\frac{1}{2c_2}\n$$\n$$\nb_2 = \\frac{1}{2c_2}\n$$\n使这些系数良定义的约束是 $c_2 \\neq 0$。问题要求将三元组 $(a_{21}, b_1, b_2)$ 表示为单一的闭式解析表达式。\n\n解是有序三元组：\n$$\n(a_{21}, b_{1}, b_{2}) = \\left( c_2, 1 - \\frac{1}{2c_2}, \\frac{1}{2c_2} \\right).\n$$\n这提供了一个完整的解族，从中可以恢复出诸如中点法（$c_2 = 1/2$）和 Heun 方法（$c_2 = 1$）等著名方法。",
            "answer": "$$\n\\boxed{\\left( c_2, 1 - \\frac{1}{2c_2}, \\frac{1}{2c_2} \\right)}\n$$"
        },
        {
            "introduction": "在理解了如何为保证精度而构建数值方法之后，下一个关键概念是稳定性，尤其是在处理高能物理中常见的刚性问题时。对于显式方法，步长的选择往往受限于稳定性而非精度。本练习将推导经典四阶龙格-库塔（RK4）方法的稳定性函数，这是理解其在模拟具有不同时间尺度的系统时表现的关键。",
            "id": "3537385",
            "problem": "在计算高能物理模拟中，针对背景场周围线性化涨落的半离散演化方程，在对相对论场方程进行空间离散化后，常常会因色散和阻尼而逐模式地简化为标量测试常微分方程(ODE) $y^{\\prime}(t)=\\lambda\\,y(t)$，其中 $\\lambda\\in\\mathbb{C}$。考虑使用经典的4级显式龙格-库塔(RK)方法，在一个大小为 $h>0$ 的时间步长上推进此ODE。该方法由以下阶段系统定义：\n$$\n\\begin{aligned}\nk_{1}=f(t_{n},y_{n}),\\\\\nk_{2}=f\\!\\left(t_{n}+\\tfrac{h}{2},\\,y_{n}+\\tfrac{h}{2}k_{1}\\right),\\\\\nk_{3}=f\\!\\left(t_{n}+\\tfrac{h}{2},\\,y_{n}+\\tfrac{h}{2}k_{2}\\right),\\\\\nk_{4}=f\\!\\left(t_{n}+h,\\,y_{n}+h\\,k_{3}\\right),\n\\end{aligned}\n$$\n更新方程为\n$$\ny_{n+1}=y_{n}+\\tfrac{h}{6}\\left(k_{1}+2\\,k_{2}+2\\,k_{3}+k_{4}\\right).\n$$\n此处 $f(t,y)=\\lambda\\,y$。当一个单步法应用于 $y^{\\prime}=\\lambda\\,y$ 时，其绝对稳定函数 $R(z)$ 由标量关系式 $y_{n+1}=R(z)\\,y_{n}$ 定义，其中 $z=\\lambda\\,h$。请仅从这些定义出发，通过对各阶段进行代数运算，推导出 $R(z)$ 作为 $z$ 的一个闭式多项式。请提供 $R(z)$ 的精确表达式作为您的最终答案。无需进行四舍五入，也无需报告任何单位。",
            "solution": "目标是推导当经典的4级龙格-库塔(RK4)方法应用于标量测试方程 $y^{\\prime}(t) = \\lambda y(t)$ 时的绝对稳定函数 $R(z)$。该稳定函数由关系式 $y_{n+1} = R(z) y_n$ 定义，其中 $z = \\lambda h$。\n\nODE右端的函数为 $f(t,y) = \\lambda y$。由于 $f$ 不依赖于 $t$，我们可以写作 $f(y) = \\lambda y$。我们来系统地计算各个阶段 $k_i$。\n\n步骤1：计算第一阶段 $k_1$。\n$$\nk_1 = f(t_n, y_n) = \\lambda y_n\n$$\n\n步骤2：使用 $k_1$ 的结果计算第二阶段 $k_2$。\n$$\nk_2 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1\\right) = \\lambda \\left(y_n + \\frac{h}{2}k_1\\right)\n$$\n代入 $k_1 = \\lambda y_n$：\n$$\nk_2 = \\lambda \\left(y_n + \\frac{h}{2}(\\lambda y_n)\\right) = \\lambda y_n \\left(1 + \\frac{\\lambda h}{2}\\right)\n$$\n\n步骤3：使用 $k_2$ 的结果计算第三阶段 $k_3$。\n$$\nk_3 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2\\right) = \\lambda \\left(y_n + \\frac{h}{2}k_2\\right)\n$$\n代入 $k_2$ 的表达式：\n$$\nk_3 = \\lambda \\left(y_n + \\frac{h}{2} \\left[\\lambda y_n \\left(1 + \\frac{\\lambda h}{2}\\right)\\right]\\right) = \\lambda y_n \\left(1 + \\frac{\\lambda h}{2}\\left(1 + \\frac{\\lambda h}{2}\\right)\\right)\n$$\n$$\nk_3 = \\lambda y_n \\left(1 + \\frac{\\lambda h}{2} + \\frac{(\\lambda h)^2}{4}\\right)\n$$\n\n步骤4：使用 $k_3$ 的结果计算第四阶段 $k_4$。\n$$\nk_4 = f(t_n + h, y_n + h k_3) = \\lambda (y_n + h k_3)\n$$\n代入 $k_3$ 的表达式：\n$$\nk_4 = \\lambda \\left(y_n + h \\left[\\lambda y_n \\left(1 + \\frac{\\lambda h}{2} + \\frac{(\\lambda h)^2}{4}\\right)\\right]\\right) = \\lambda y_n \\left(1 + \\lambda h \\left(1 + \\frac{\\lambda h}{2} + \\frac{(\\lambda h)^2}{4}\\right)\\right)\n$$\n$$\nk_4 = \\lambda y_n \\left(1 + \\lambda h + \\frac{(\\lambda h)^2}{2} + \\frac{(\\lambda h)^3}{4}\\right)\n$$\n\n步骤5：将所有四个阶段的表达式代入最终的更新公式中。\n更新规则由下式给出：\n$$\ny_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\n我们代入推导出的 $k_1, k_2, k_3$ 和 $k_4$ 的表达式：\n$$\ny_{n+1} = y_n + \\frac{h}{6} \\left[ \\lambda y_n + 2\\lambda y_n \\left(1 + \\frac{\\lambda h}{2}\\right) + 2\\lambda y_n \\left(1 + \\frac{\\lambda h}{2} + \\frac{(\\lambda h)^2}{4}\\right) + \\lambda y_n \\left(1 + \\lambda h + \\frac{(\\lambda h)^2}{2} + \\frac{(\\lambda h)^3}{4}\\right) \\right]\n$$\n从括号内的表达式中提出公因子 $\\lambda y_n$：\n$$\ny_{n+1} = y_n + \\frac{h \\lambda y_n}{6} \\left[ 1 + 2\\left(1 + \\frac{\\lambda h}{2}\\right) + 2\\left(1 + \\frac{\\lambda h}{2} + \\frac{(\\lambda h)^2}{4}\\right) + \\left(1 + \\lambda h + \\frac{(\\lambda h)^2}{2} + \\frac{(\\lambda h)^3}{4}\\right) \\right]\n$$\n现在，代入 $z = \\lambda h$：\n$$\ny_{n+1} = y_n + \\frac{z y_n}{6} \\left[ 1 + 2\\left(1 + \\frac{z}{2}\\right) + 2\\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right) + \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\\right) \\right]\n$$\n展开括号内的项：\n$$\ny_{n+1} = y_n + \\frac{z y_n}{6} \\left[ 1 + (2 + z) + \\left(2 + z + \\frac{z^2}{2}\\right) + \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\\right) \\right]\n$$\n合并括号内 $z$ 的同次幂项：\n常数项为 $1 + 2 + 2 + 1 = 6$。\n$z$ 的系数为 $1 + 1 + 1 = 3$。\n$z^2$ 的系数为 $\\frac{1}{2} + \\frac{1}{2} = 1$。\n$z^3$ 的系数为 $\\frac{1}{4}$。\n因此，括号内的表达式简化为 $6 + 3z + z^2 + \\frac{z^3}{4}$。\n\n将此结果代回到 $y_{n+1}$ 的方程中：\n$$\ny_{n+1} = y_n + \\frac{z y_n}{6} \\left(6 + 3z + z^2 + \\frac{z^3}{4}\\right)\n$$\n将 $\\frac{z}{6}$ 项分配进去：\n$$\ny_{n+1} = y_n + y_n \\left(\\frac{6z}{6} + \\frac{3z^2}{6} + \\frac{z^3}{6} + \\frac{z^4}{24}\\right)\n$$\n$$\ny_{n+1} = y_n + y_n \\left(z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}\\right)\n$$\n最后，提出因子 $y_n$：\n$$\ny_{n+1} = y_n \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}\\right)\n$$\n根据定义，$y_{n+1} = R(z) y_n$。将此式与推导出的表达式进行比较，我们确定稳定函数 $R(z)$ 为：\n$$\nR(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}\n$$\n这个多项式是 $\\exp(z)$ 的泰勒级数截断到 $z^4$ 项的结果，这与该方法的四阶精度相符。\n注意到 $2! = 2$，$3! = 6$ 和 $4! = 24$，我们可以将其写作：\n$$\nR(z) = 1 + \\frac{z}{1!} + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!}\n$$\n问题要求的是闭式多项式。",
            "answer": "$$\n\\boxed{1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}}\n$$"
        },
        {
            "introduction": "除了精度和稳定性，物理系统的几何结构是选择积分器时必须考虑的另一个重要因素。哈密顿系统在理论上能量守恒，但像RK4这样的通用数值方法通常无法保持这一结构，导致能量在长时间模拟中出现非物理的漂移。本练习通过对比RK4与一种辛积分器（Störmer-Verlet），展示了为守恒物理系统选择保结构算法的极端重要性，这是计算物理中一个核心的高级主题。",
            "id": "3537380",
            "problem": "考虑一个双分量实标量场的截断一维晶格，采用自然单位制，其中 $\\hbar=c=1$。设晶格包含 $N$ 个格点，具有周期性边界条件，在格点 $n \\in \\{0,1,\\dots,N-1\\}$ 处有场坐标 $\\boldsymbol{\\phi}_n(t) \\in \\mathbb{R}^2$ 和共轭动量 $\\boldsymbol{\\pi}_n(t) \\in \\mathbb{R}^2$。定义哈密顿量\n$$\nH(\\{\\boldsymbol{\\phi}_n,\\boldsymbol{\\pi}_n\\}) \\equiv \\sum_{n=0}^{N-1} \\left( \\frac{1}{2}\\lVert \\boldsymbol{\\pi}_n \\rVert^2 + \\frac{1}{2} m^2 \\lVert \\boldsymbol{\\phi}_n \\rVert^2 + \\frac{1}{2} c^2 \\lVert \\boldsymbol{\\phi}_{n+1}-\\boldsymbol{\\phi}_n \\rVert^2 + \\frac{\\lambda}{4} \\lVert \\boldsymbol{\\phi}_n \\rVert^4 \\right),\n$$\n其中 $\\lVert \\cdot \\rVert$ 表示 $\\mathbb{R}^2$ 中的欧几里得范数，且索引 $n+1$ 对 $N$ 取模。\n\n正则运动方程为哈密顿常微分方程 (ODEs)\n$$\n\\dot{\\boldsymbol{\\phi}}_n(t) = \\boldsymbol{\\pi}_n(t), \\quad \\dot{\\boldsymbol{\\pi}}_n(t) = - \\nabla_{\\boldsymbol{\\phi}_n} V(\\{\\ \\boldsymbol{\\phi}_k\\ \\}),\n$$\n其势能为\n$$\nV(\\{\\ \\boldsymbol{\\phi}_k\\ \\}) \\equiv \\sum_{n=0}^{N-1} \\left( \\frac{1}{2} m^2 \\lVert \\boldsymbol{\\phi}_n \\rVert^2 + \\frac{1}{2} c^2 \\lVert \\boldsymbol{\\phi}_{n+1}-\\boldsymbol{\\phi}_n \\rVert^2 + \\frac{\\lambda}{4} \\lVert \\boldsymbol{\\phi}_n \\rVert^4 \\right).\n$$\n等价地，用收集了所有 $\\boldsymbol{\\phi}_n$ 和 $\\boldsymbol{\\pi}_n$ 的相空间矢量 $y(t)$ 来表示，该系统具有哈密顿形式 $\\dot y(t) = J \\nabla H(y(t))$，其中 $J$ 是正则辛矩阵，满足 $J^\\top = -J$ 和 $J^2 = -I$。\n\n该哈密顿量在两个场分量的内部 $\\mathrm{O}(2)$ 旋转下保持不变，这意味着 Noether 荷守恒\n$$\nQ(\\{\\boldsymbol{\\phi}_n,\\boldsymbol{\\pi}_n\\}) \\equiv \\sum_{n=0}^{N-1} \\left( \\phi_{n,1}\\,\\pi_{n,2} - \\phi_{n,2}\\,\\pi_{n,1} \\right),\n$$\n其中 $\\phi_{n,1}$ 和 $\\phi_{n,2}$ 表示 $\\boldsymbol{\\phi}_n$ 的两个分量，$\\pi_{n,1}$ 和 $\\pi_{n,2}$ 表示 $\\boldsymbol{\\pi}_n$ 的两个分量。\n\n从基本的哈密顿动力学和正则定义出发，为上述系统实现并比较两种时间积分方案：\n- 标准显式四阶 Runge–Kutta 方法 (RK4)，其中 Runge–Kutta (RK) 指的是经典的基于分段的显式积分器。\n- 一种适用于可分离哈密顿量 $H(\\boldsymbol{\\phi},\\boldsymbol{\\pi}) = T(\\boldsymbol{\\pi}) + V(\\boldsymbol{\\phi})$ 的辛、配分 Runge–Kutta 方案，特别是 Störmer–Verlet (也称为蛙跳) 方法。\n\n使用以下具有振幅参数 $A$ 的确定性初始条件：\n$$\n\\boldsymbol{\\phi}_n(0) = A \\begin{bmatrix} \\cos\\left( \\frac{2\\pi n}{N} \\right) \\\\ \\sin\\left( \\frac{2\\pi n}{N} \\right) \\end{bmatrix}, \\quad\n\\boldsymbol{\\pi}_n(0) = \\begin{bmatrix} 0 \\\\ A \\cos\\left( \\frac{2\\pi n}{N} \\right) \\end{bmatrix}.\n$$\n这一选择确保了对于下面指定的参数，初始电荷 $Q(0)$ 非零，且能量有界且物理上现实。\n\n对于每种积分器和每个测试用例，使用均匀时间步长 $\\Delta t$ 将系统从 $t=0$ 演化到 $t=T$，并报告在整个积分区间内能量 $H$ 和电荷 $Q$ 的最大相对漂移，\n$$\n\\delta_H \\equiv \\max_{0 \\le t \\le T} \\frac{\\left|H(t) - H(0)\\right|}{\\left|H(0)\\right|}, \\qquad\n\\delta_Q \\equiv \\max_{0 \\le t \\le T} \\frac{\\left|Q(t) - Q(0)\\right|}{\\max\\left( \\left|Q(0)\\right|, 10^{-12} \\right)},\n$$\n表示为十进制浮点数（在自然单位制下无量纲）。最大值操作应通过在每个离散时间步评估 $H$ 和 $Q$ 来近似。\n\n测试套件：\n- 情况 A (非线性，耦合)：$N=16$, $m=1.0$, $c=1.0$, $\\lambda=0.1$, $A=0.2$, $\\Delta t = 0.01$, $T = 50.0$。\n- 情况 B (线性，非耦合振子)：$N=16$, $m=0.5$, $c=0.0$, $\\lambda=0.0$, $A=0.2$, $\\Delta t = 0.02$, $T = 50.0$。\n- 情况 C (更强的非线性，耦合)：$N=16$, $m=2.0$, $c=1.0$, $\\lambda=0.5$, $A=0.2$, $\\Delta t = 0.005$, $T = 30.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，返回一个包含四个浮点数的列表 $\\left[\\delta_H^{\\mathrm{RK4}}, \\delta_Q^{\\mathrm{RK4}}, \\delta_H^{\\mathrm{Verlet}}, \\delta_Q^{\\mathrm{Verlet}}\\right]$。因此，最终输出必须是一个包含三个列表的列表，每个列表对应一个测试用例，例如：\n$$\n\\left[ [d_{1,1}, d_{1,2}, d_{1,3}, d_{1,4}], [d_{2,1}, d_{2,2}, d_{2,3}, d_{2,4}], [d_{3,1}, d_{3,2}, d_{3,3}, d_{3,4}] \\right],\n$$\n其中每个 $d_{\\cdot,\\cdot}$ 都是一个十进制浮点数。由于问题是在自然单位制 ($\\hbar=c=1$) 中提出的，因此无需报告物理单位。",
            "solution": "该问题要求实现并比较两种数值积分方案——四阶显式 Runge-Kutta 方法 (RK4) 和 Störmer-Verlet 方法——用于一个描述一维晶格上双分量实标量场的哈密顿系统。这些积分器的性能将根据它们守恒系统总能量 $H$ 和特定 Noether 荷 $Q$ 的能力进行评估。\n\n首先，我们必须将运动方程形式化。在时间 $t$ 时系统的状态由 $N$ 个场坐标 $\\boldsymbol{\\phi}_n(t) \\in \\mathbb{R}^2$ 及其共轭动量 $\\boldsymbol{\\pi}_n(t) \\in \\mathbb{R}^2$ 的集合定义，其中 $n \\in \\{0, 1, \\dots, N-1\\}$ 为每个晶格格点。哈密顿量如下所示：\n$$\nH = \\sum_{n=0}^{N-1} \\left( \\underbrace{\\frac{1}{2}\\lVert \\boldsymbol{\\pi}_n \\rVert^2}_{T(\\boldsymbol{\\pi})} + \\underbrace{\\frac{1}{2} m^2 \\lVert \\boldsymbol{\\phi}_n \\rVert^2 + \\frac{1}{2} c^2 \\lVert \\boldsymbol{\\phi}_{n+1}-\\boldsymbol{\\phi}_n \\rVert^2 + \\frac{\\lambda}{4} \\lVert \\boldsymbol{\\phi}_n \\rVert^4}_{V(\\boldsymbol{\\phi})} \\right)\n$$\n这个哈密顿量是可分离的，意味着它可以写成一个仅依赖于动量的动能项 $T(\\boldsymbol{\\pi})$ 和一个仅依赖于坐标的势能项 $V(\\boldsymbol{\\phi})$ 的和。此属性对于 Störmer-Verlet 方法的适用性至关重要。\n\n动力学由哈密顿方程控制：\n$$\n\\dot{\\boldsymbol{\\phi}}_n = \\frac{\\partial H}{\\partial \\boldsymbol{\\pi}_n}, \\qquad \\dot{\\boldsymbol{\\pi}}_n = -\\frac{\\partial H}{\\partial \\boldsymbol{\\phi}_n}\n$$\n第一个方程得出 $\\dot{\\boldsymbol{\\phi}}_n = \\boldsymbol{\\pi}_n$。对于第二个方程，我们必须计算势能 $V(\\boldsymbol{\\phi})$ 相对于 $\\boldsymbol{\\phi}_n$ 的梯度。涉及 $\\boldsymbol{\\phi}_n$ 的势能项是索引为 $n$ 的项以及索引为 $n-1$ 和 $n$ 的耦合项。考虑到周期性边界条件（$n \\pm 1$ 对 $N$ 取模），梯度为：\n$$\n\\nabla_{\\boldsymbol{\\phi}_n} V = \\frac{\\partial V}{\\partial \\boldsymbol{\\phi}_n} = m^2 \\boldsymbol{\\phi}_n + \\lambda \\lVert\\boldsymbol{\\phi}_n\\rVert^2 \\boldsymbol{\\phi}_n + c^2(\\boldsymbol{\\phi}_n - \\boldsymbol{\\phi}_{n-1}) + c^2(\\boldsymbol{\\phi}_n - \\boldsymbol{\\phi}_{n+1})\n$$\n格点 $n$ 处场受到的力为 $F_n = -\\nabla_{\\boldsymbol{\\phi}_n} V$。重排各项，我们识别出离散晶格拉普拉斯算子 $\\Delta \\boldsymbol{\\phi}_n = \\boldsymbol{\\phi}_{n+1} + \\boldsymbol{\\phi}_{n-1} - 2\\boldsymbol{\\phi}_n$：\n$$\nF_n(\\{\\boldsymbol{\\phi}_k\\}) = - \\left( (m^2 + \\lambda \\lVert\\boldsymbol{\\phi}_n\\rVert^2) \\boldsymbol{\\phi}_n - c^2(\\boldsymbol{\\phi}_{n+1} - 2\\boldsymbol{\\phi}_n + \\boldsymbol{\\phi}_{n-1}) \\right)\n$$\n因此，完整的一阶常微分方程组 (ODEs) 为：\n$$\n\\dot{\\boldsymbol{\\phi}}_n(t) = \\boldsymbol{\\pi}_n(t)\n$$\n$$\n\\dot{\\boldsymbol{\\pi}}_n(t) = F_n(\\{\\boldsymbol{\\phi}_k(t)\\})\n$$\n这构成了一个包含 $4N$ 个耦合一阶常微分方程的系统，其中 $N$ 是晶格格点的数量。\n\n现在我们来描述数值积分方案。设状态矢量为 $y(t) = (\\boldsymbol{\\phi}_0(t), \\dots, \\boldsymbol{\\phi}_{N-1}(t), \\boldsymbol{\\pi}_0(t), \\dots, \\boldsymbol{\\pi}_{N-1}(t))$，且常微分方程组为 $\\dot{y} = f(y)$。\n\n**1. 四阶 Runge-Kutta (RK4)**\nRK4 是一种通用的显式单步常微分方程求解器。对于时间步长 $\\Delta t$，从 $y_t$ 到 $y_{t+\\Delta t}$ 的更新过程如下：\n$$\n\\begin{align*}\nk_1 = \\Delta t \\cdot f(y_t) \\\\\nk_2 = \\Delta t \\cdot f(y_t + k_1/2) \\\\\nk_3 = \\Delta t \\cdot f(y_t + k_2/2) \\\\\nk_4 = \\Delta t \\cdot f(y_t + k_3) \\\\\ny_{t+\\Delta t} = y_t + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n$$\nRK4 因其高精度（局部截断误差为 $\\mathcal{O}(\\Delta t^5)$，全局误差为 $\\mathcal{O}(\\Delta t^4)$）以及在合理范围的 $\\Delta t$ 内的稳定性而被广泛使用。然而，它不是一个辛积分器，这意味着对于哈密顿系统，像能量这样的守恒量在长时间积分中先验地不能被很好地保持。能量误差通常表现出长期漂移。\n\n**2. Störmer-Verlet (蛙跳) 方法**\n该方法是一种专为可分离哈密顿量设计的几何积分器。它属于辛配分 Runge-Kutta 方法。其“蛙跳”变体在交错的时间点更新位置和动量：\n$$\n\\begin{align*}\n\\boldsymbol{\\pi}_{n, t+\\Delta t/2} = \\boldsymbol{\\pi}_{n, t} + \\frac{\\Delta t}{2} F_n(\\{\\boldsymbol{\\phi}_{k, t}\\}) \\\\\n\\boldsymbol{\\phi}_{n, t+\\Delta t} = \\boldsymbol{\\phi}_{n, t} + \\Delta t \\cdot \\boldsymbol{\\pi}_{n, t+\\Delta t/2} \\\\\n\\boldsymbol{\\pi}_{n, t+\\Delta t} = \\boldsymbol{\\pi}_{n, t+\\Delta t/2} + \\frac{\\Delta t}{2} F_n(\\{\\boldsymbol{\\phi}_{k, t+\\Delta t}\\})\n\\end{align*}\n$$\n该方法具有二阶精度 ($\\mathcal{O}(\\Delta t^2)$)。其关键优势在于其辛性质。对于哈密顿系统，此性质确保了相空间体积的守恒，并导致能量误差在长时间内有界，使其在保守系统的长期模拟中优于像 RK4 这样的非辛方法。\n\n**Noether 荷 $Q$ 的守恒**\n哈密顿量在内部场空间的 $\\mathrm{O}(2)$ 旋转下保持不变，即对于任何旋转矩阵 $g \\in \\mathrm{O}(2)$，变换形式为 $(\\boldsymbol{\\phi}_n, \\boldsymbol{\\pi}_n) \\to (g\\boldsymbol{\\phi}_n, g\\boldsymbol{\\pi}_n)$。这种对称性产生了守恒的 Noether 荷：\n$$\nQ = \\sum_{n=0}^{N-1} \\left( \\phi_{n,1}\\,\\pi_{n,2} - \\phi_{n,2}\\,\\pi_{n,1} \\right)\n$$\n如果一个积分器的更新映射与对称作用对易，则称其为等变的。力函数 $F_n(\\{\\boldsymbol{\\phi}_k\\})$ 是等变的，因为 $\\lVert g\\boldsymbol{\\phi}\\rVert = \\lVert\\boldsymbol{\\phi}\\rVert$ 且矩阵乘法对加法满足分配律。仔细分析表明，如果力函数是等变的，那么 Störmer-Verlet 方法和任何经典的 Runge-Kutta 方法（包括 RK4）都是等变的。因此，两种积分器都应在机器浮点精度范围内守恒电荷 $Q$。$Q$ 的任何显著数值漂移都可能表明存在实现错误。因此，两种方法之间的主要区别预计将体现在能量 $H$ 的长期守恒上。\n\n实现将通过定义 Python 函数来计算力、哈密顿量 $H$ 和电荷 $Q$ 来进行。对于每个测试用例，系统被初始化，然后使用 RK4 和 Verlet 积分器从 $t=0$ 演化到 $t=T$。在每个时间步，计算相对漂移 $\\delta_H$ 和 $\\delta_Q$，并记录它们的最大值。\n具体的初始条件是：\n$$\n\\boldsymbol{\\phi}_n(0) = A \\begin{bmatrix} \\cos\\left( \\frac{2\\pi n}{N} \\right) \\\\ \\sin\\left( \\frac{2\\pi n}{N} \\right) \\end{bmatrix}, \\quad\n\\boldsymbol{\\pi}_n(0) = \\begin{bmatrix} 0 \\\\ A \\cos\\left( \\frac{2\\pi n}{N} \\right) \\end{bmatrix}\n$$\n程序将为三个指定的测试用例系统地执行模拟，并报告每个用例的四个测量的漂移值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A (nonlinear, coupled)\n        {'N': 16, 'm': 1.0, 'c': 1.0, 'lambda_val': 0.1, 'A': 0.2, 'dt': 0.01, 'T': 50.0},\n        # Case B (linear, uncoupled oscillators)\n        {'N': 16, 'm': 0.5, 'c': 0.0, 'lambda_val': 0.0, 'A': 0.2, 'dt': 0.02, 'T': 50.0},\n        # Case C (stiffer nonlinear, coupled)\n        {'N': 16, 'm': 2.0, 'c': 1.0, 'lambda_val': 0.5, 'A': 0.2, 'dt': 0.005, 'T': 30.0},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N, m, c, lambda_val, A, dt, T = case.values()\n\n        # Initial conditions\n        n_indices = np.arange(N)\n        angles = 2 * np.pi * n_indices / N\n        cos_angles = np.cos(angles)\n        sin_angles = np.sin(angles)\n\n        phi0 = A * np.vstack((cos_angles, sin_angles)).T\n        pi0 = A * np.vstack((np.zeros(N), cos_angles)).T\n        \n        y0 = np.concatenate((phi0.flatten(), pi0.flatten()))\n        \n        # Run simulations\n        rk4_results = run_rk4_simulation(y0, N, m, c, lambda_val, dt, T)\n        verlet_results = run_verlet_simulation(phi0, pi0, N, m, c, lambda_val, dt, T)\n        \n        case_results = [*rk4_results, *verlet_results]\n        all_results.append(case_results)\n\n    # Format and print the final output\n    output_str = \"[\" + \", \".join([f\"[{', '.join(map(str, res))}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\ndef compute_H(phi, pi, m, c, lambda_val, N):\n    \"\"\"Computes the Hamiltonian H.\"\"\"\n    kinetic_energy = 0.5 * np.sum(pi**2)\n    \n    phi_norm_sq = np.sum(phi**2, axis=1)\n    mass_term = 0.5 * m**2 * np.sum(phi_norm_sq)\n    interaction_term = 0.25 * lambda_val * np.sum(phi_norm_sq**2)\n    \n    phi_next = np.roll(phi, -1, axis=0)\n    diff_phi = phi_next - phi\n    coupling_term = 0.5 * c**2 * np.sum(diff_phi**2)\n    \n    return kinetic_energy + mass_term + interaction_term + coupling_term\n\ndef compute_Q(phi, pi):\n    \"\"\"Computes the Noether charge Q.\"\"\"\n    return np.sum(phi[:, 0] * pi[:, 1] - phi[:, 1] * pi[:, 0])\n\ndef compute_forces(phi, m, c, lambda_val, N):\n    \"\"\"Computes the force F = -dV/dphi.\"\"\"\n    phi_norm_sq = np.sum(phi**2, axis=1, keepdims=True)\n    \n    phi_next = np.roll(phi, -1, axis=0)\n    phi_prev = np.roll(phi, 1, axis=0)\n    laplacian = phi_next + phi_prev - 2 * phi\n    \n    force_on_site = (m**2 + lambda_val * phi_norm_sq) * phi\n    force_coupling = -c**2 * laplacian\n    \n    return -(force_on_site + force_coupling)\n\ndef get_derivatives(y, N, m, c, lambda_val):\n    \"\"\"Computes the time derivative of the state vector y for RK4.\"\"\"\n    phi = y[:2*N].reshape((N, 2))\n    pi = y[2*N:].reshape((N, 2))\n    \n    d_phi_dt = pi\n    d_pi_dt = compute_forces(phi, m, c, lambda_val, N)\n    \n    return np.concatenate((d_phi_dt.flatten(), d_pi_dt.flatten()))\n\ndef run_rk4_simulation(y0, N, m, c, lambda_val, dt, T):\n    \"\"\"Evolves the system using the RK4 method.\"\"\"\n    y = y0.copy()\n    num_steps = int(round(T / dt))\n    \n    phi_init = y[:2*N].reshape((N, 2))\n    pi_init = y[2*N:].reshape((N, 2))\n    \n    H0 = compute_H(phi_init, pi_init, m, c, lambda_val, N)\n    Q0 = compute_Q(phi_init, pi_init)\n    \n    H0_abs = np.abs(H0)\n    Q0_abs_norm = max(np.abs(Q0), 1e-12)\n\n    max_delta_H = 0.0\n    max_delta_Q = 0.0\n    \n    for _ in range(num_steps):\n        k1 = dt * get_derivatives(y, N, m, c, lambda_val)\n        k2 = dt * get_derivatives(y + 0.5 * k1, N, m, c, lambda_val)\n        k3 = dt * get_derivatives(y + 0.5 * k2, N, m, c, lambda_val)\n        k4 = dt * get_derivatives(y + k3, N, m, c, lambda_val)\n        y += (k1 + 2 * k2 + 2 * k3 + k4) / 6\n        \n        phi = y[:2*N].reshape((N, 2))\n        pi = y[2*N:].reshape((N, 2))\n        \n        H_t = compute_H(phi, pi, m, c, lambda_val, N)\n        Q_t = compute_Q(phi, pi)\n        \n        delta_H = np.abs(H_t - H0) / H0_abs if H0_abs > 0 else 0\n        delta_Q = np.abs(Q_t - Q0) / Q0_abs_norm\n        \n        if delta_H > max_delta_H:\n            max_delta_H = delta_H\n        if delta_Q > max_delta_Q:\n            max_delta_Q = delta_Q\n            \n    return max_delta_H, max_delta_Q\n\ndef run_verlet_simulation(phi0, pi0, N, m, c, lambda_val, dt, T):\n    \"\"\"Evolves the system using the Störmer-Verlet method.\"\"\"\n    phi = phi0.copy()\n    pi = pi0.copy()\n    num_steps = int(round(T / dt))\n\n    H0 = compute_H(phi, pi, m, c, lambda_val, N)\n    Q0 = compute_Q(phi, pi)\n\n    H0_abs = np.abs(H0)\n    Q0_abs_norm = max(np.abs(Q0), 1e-12)\n\n    max_delta_H = 0.0\n    max_delta_Q = 0.0\n    \n    # First half-step for momentum to align with leapfrog scheme\n    force = compute_forces(phi, m, c, lambda_val, N)\n    pi_half = pi + 0.5 * dt * force\n\n    for _ in range(num_steps):\n        # Full step for position\n        phi += dt * pi_half\n        \n        # Full step for momentum\n        force = compute_forces(phi, m, c, lambda_val, N)\n        pi = pi_half + 0.5 * dt * force\n        \n        # to calculate H, Q we need phi and pi at the same time `t`\n        # current pi is at t + dt. current phi is at t + dt.\n        # current pi_half is at t + dt/2. So we can sync pi back to t+dt.\n        \n        H_t = compute_H(phi, pi, m, c, lambda_val, N)\n        Q_t = compute_Q(phi, pi)\n        \n        delta_H = np.abs(H_t - H0) / H0_abs if H0_abs > 0 else 0\n        delta_Q = np.abs(Q_t - Q0) / Q0_abs_norm\n        \n        if delta_H > max_delta_H:\n            max_delta_H = delta_H\n        if delta_Q > max_delta_Q:\n            max_delta_Q = delta_Q\n        \n        # Update for next iteration\n        pi_half = pi + 0.5 * dt * force\n\n    return max_delta_H, max_delta_Q\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}