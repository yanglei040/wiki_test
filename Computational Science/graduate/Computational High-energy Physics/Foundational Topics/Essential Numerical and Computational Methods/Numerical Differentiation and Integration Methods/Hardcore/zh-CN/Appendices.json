{
    "hands_on_practices": [
        {
            "introduction": "在任何数值计算中，精度都受到截断误差和舍入误差的根本限制。此练习将指导您为中心差分法推导这两种误差的来源，并找到一个最佳步长 $h_{\\mathrm{opt}}$，以平衡它们之间的消长。通过为指数函数这个在物理学中无处不在的模型求解，您将掌握在有限精度计算中最大化导数精度的核心技能 。",
            "id": "3525181",
            "problem": "考虑在计算高能物理中，对生成泛函和传播子中的指数因子求导时出现的导数数值计算问题。您将分析导数的中心有限差分近似，并确定在电气和电子工程师协会 (IEEE) 双精度算术中能够平衡截断误差和浮点舍入误差的步长。\n\n从数值分析和物理计算的基本原理出发：\n- 对于一个光滑标量函数 $f(x)$，使用其在某点周围的泰勒展开以及导数 $f'(x)$ 的定义。\n- 在 IEEE 双精度下对浮点运算进行建模，其单位舍入误差为 $\\epsilon$，满足 $\\epsilon \\approx 2^{-53}$。\n\n您的任务是：\n1. 从泰勒展开和导数的定义出发，推导中心差分公式\n$$\nD_h f(x) \\equiv \\frac{f(x+h) - f(x-h)}{2h}\n$$\n作为 $f'(x)$ 近似的领先阶截断误差，并确定乘以 $h^2$ 的领先阶系数，该系数用在 $x$ 点计算的 $f$ 的导数表示。\n2. 使用一个标准的浮点舍入模型，其中每次基本函数求值都会引入一个量级为 $\\epsilon$ 的相对误差。注意到分子中存在两个几乎相等的数相减，为 $D_h f(x)$ 构造一个形式为 $C\\epsilon/h$ 的领先阶舍入误差模型，其中系数 $C$ 用 $f(x)$ 表示。\n3. 将截断误差和舍入误差模型合并为一个单一的领先阶误差估计 $E(h)$，并通过解析方法最小化 $E(h)$（相对于 $h$），以获得用 $f(x)$、$f'''(x)$ 和 $\\epsilon$ 表示的最优步长 $h_{\\mathrm{opt}}$ 的公式。\n4. 将您的结果应用于 $f(x) = \\exp(k x)$ 在 $x=1$ 处的情况，其中 $k$ 是一个实数参数。使用 IEEE 双精度和 $\\epsilon = 2^{-53}$，根据您的公式数值计算 $h_{\\mathrm{opt}}$。\n5. 对于每个参数值，当使用中心差分近似和您计算出的 $h_{\\mathrm{opt}}$ 时，估计 $f'(1)$ 的预期正确十进制数字位数。使用领先阶误差模型获得预期相对误差 $\\delta_{\\mathrm{exp}}$，然后将预期数字位数报告为 $-\\log_{10}(\\delta_{\\mathrm{exp}})$。\n6. 通过在 IEEE 双精度下实际计算中心差分近似 $D_{h_{\\mathrm{opt}}} f(1)$ 并测量与精确导数 $f'(1)$ 的实际相对误差 $\\delta_{\\mathrm{meas}}$ 来验证您的模型，然后将测量的数字位数报告为 $-\\log_{10}(\\delta_{\\mathrm{meas}})$。\n\n测试套件：\n- 在 $x=1$ 处使用以下参数 $k$ 的值：\n    - 情况 A（一般参考尺度）：$k = 1$。\n    - 情况 B（与刚性尺度相关的陡峭指数）：$k = 10$。\n    - 情况 C（平缓指数）：$k = 0.1$。\n    - 情况 D（非常陡峭的指数，但在双精度下不会溢出）：$k = 100$。\n\n对于每种情况，计算并报告：\n- 最优步长 $h_{\\mathrm{opt}}$。\n- 预期数字位数 $-\\log_{10}(\\delta_{\\mathrm{exp}})$。\n- 使用中心差分在 $h_{\\mathrm{opt}}$ 处计算的测量数字位数 $-\\log_{10}(\\delta_{\\mathrm{meas}})$。\n- 一个布尔值，当且仅当测量的数字位数与预期的数字位数之差不超过 $0.5$ 时为 True。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含情况 A、B、C 和 D 的四元组，平铺成一个列表：\n$$\n[ h_A, d^{\\mathrm{exp}}_A, d^{\\mathrm{meas}}_A, \\mathrm{ok}_A, h_B, d^{\\mathrm{exp}}_B, d^{\\mathrm{meas}}_B, \\mathrm{ok}_B, h_C, d^{\\mathrm{exp}}_C, d^{\\mathrm{meas}}_C, \\mathrm{ok}_C, h_D, d^{\\mathrm{exp}}_D, d^{\\mathrm{meas}}_D, \\mathrm{ok}_D ]\n$$\n其中每个 $h$ 是一个浮点数，每个 $d$ 是一个浮点数，每个 $\\mathrm{ok}$ 是一个布尔值。不需要物理单位，也不涉及角度。将所有数字位数表示为实数（浮点数），而不是百分比。",
            "solution": "问题陈述已经过严格验证，被认为是科学上可靠、适定、客观和完整的。它代表了科学计算数值分析中的一个标准且具有指导意义的练习。因此，我们可以进行形式化的求解。\n\n任务是分析函数 $f(x)$ 一阶导数的中心有限差分近似，记为 $D_h f(x)$，并平衡其固有的截断误差与浮点运算引入的舍入误差。\n\n$$\nD_h f(x) \\equiv \\frac{f(x+h) - f(x-h)}{2h}\n$$\n\n### 1. 截断误差的推导\n\n截断误差是在假设精确算术的情况下，用有限差分公式近似真实导数 $f'(x)$ 时产生的数学误差。我们通过将函数 $f(x)$ 在点 $x$ 附近进行泰勒级数展开来推导这个误差。对于一个足够光滑的函数， $f(x+h)$ 和 $f(x-h)$ 的展开式为：\n\n$$\nf(x+h) = f(x) + hf'(x) + \\frac{h^2}{2!}f''(x) + \\frac{h^3}{3!}f'''(x) + \\frac{h^4}{4!}f^{(4)}(x) + \\frac{h^5}{5!}f^{(5)}(x) + \\mathcal{O}(h^6)\n$$\n$$\nf(x-h) = f(x) - hf'(x) + \\frac{h^2}{2!}f''(x) - \\frac{h^3}{3!}f'''(x) + \\frac{h^4}{4!}f^{(4)}(x) - \\frac{h^5}{5!}f^{(5)}(x) + \\mathcal{O}(h^6)\n$$\n\n用第一个展开式减去第二个展开式，可以消掉所有 $h$ 的偶次幂项：\n$$\nf(x+h) - f(x-h) = 2hf'(x) + 2\\frac{h^3}{3!}f'''(x) + 2\\frac{h^5}{5!}f^{(5)}(x) + \\mathcal{O}(h^7)\n$$\n\n除以 $2h$ 得到中心差分公式的表达式：\n$$\n\\frac{f(x+h) - f(x-h)}{2h} = f'(x) + \\frac{h^2}{6}f'''(x) + \\frac{h^4}{120}f^{(5)}(x) + \\mathcal{O}(h^6)\n$$\n\n截断误差 $E_{\\mathrm{trunc}}(h)$ 是近似值与精确值之差。对于小的 $h$，领先阶项占主导地位：\n$$\nE_{\\mathrm{trunc}}(h) = D_h f(x) - f'(x) = \\frac{h^2}{6}f'''(x) + \\mathcal{O}(h^4)\n$$\n\n因此，领先阶截断误差的量级为 $|E_{\\mathrm{trunc}}(h)| \\approx \\left|\\frac{f'''(x)}{6}\\right| h^2$。乘以 $h^2$ 的系数是 $\\frac{1}{6}f'''(x)$。\n\n### 2. 舍入误差的建模\n\n在浮点运算中，函数 $f(z)$ 的求值会得到一个计算值 $\\hat{f}(z)$，其相对误差的量级为机器精度或单位舍入误差 $\\epsilon$。我们将其建模为 $\\hat{f}(z) = f(z)(1+\\delta)$，其中 $|\\delta| \\le \\epsilon$。问题指定了 IEEE 双精度，其 $\\epsilon = 2^{-53}$。\n\n$D_h f(x)$ 的分子涉及两个几乎相等的量 $f(x+h)$ 和 $f(x-h)$ 的相减，这是舍入误差的主要来源。设计算值为 $\\hat{f}(x+h) = f(x+h)(1+\\delta_1)$ 和 $\\hat{f}(x-h) = f(x-h)(1+\\delta_2)$。计算出的分子的误差近似为：\n$$\n\\Delta_{\\mathrm{num}} \\approx f(x+h)\\delta_1 - f(x-h)\\delta_2\n$$\n\n对于小的 $h$，我们有 $f(x+h) \\approx f(x-h) \\approx f(x)$。那么分子中绝对误差的量级由以下公式界定：\n$$\n|\\Delta_{\\mathrm{num}}| \\lesssim |f(x)||\\delta_1| + |f(x)||\\delta_2| \\approx 2\\epsilon|f(x)|\n$$\n\n更直接的分析认为，两个几乎相等的数 $a \\approx b$ 的浮点减法 $a \\ominus b$ 的舍入误差量级为 $\\epsilon|a|$。$D_h f(x)$ 最终计算中的绝对舍入误差是这个分子误差除以 $2h$。因此，舍入误差 $E_{\\mathrm{round}}(h)$ 的量级为：\n$$\n|E_{\\mathrm{round}}(h)| \\approx \\frac{\\epsilon |f(x)|}{h}\n$$\n\n这与所要求的形式 $C\\epsilon/h$ 相匹配，系数为 $C = |f(x)|$。\n\n### 3. 最优步长的推导\n\n总误差 $E(h)$ 是截断误差和舍入误差的量级之和：\n$$\nE(h) \\approx |E_{\\mathrm{trunc}}(h)| + |E_{\\mathrm{round}}(h)| = \\left|\\frac{f'''(x)}{6}\\right| h^2 + \\frac{|f(x)| \\epsilon}{h}\n$$\n\n为了找到最小化总误差的步长 $h_{\\mathrm{opt}}$，我们将 $E(h)$ 对 $h$ 求导，并令结果为零：\n$$\n\\frac{dE}{dh} = 2\\left|\\frac{f'''(x)}{6}\\right| h - \\frac{|f(x)| \\epsilon}{h^2} = 0\n$$\n\n解出 $h$ 即可得到最优步长 $h_{\\mathrm{opt}}$：\n$$\n2\\left|\\frac{f'''(x)}{6}\\right| h^3 = |f(x)| \\epsilon \\implies h^3 = \\frac{3|f(x)|\\epsilon}{|f'''(x)|}\n$$\n$$\nh_{\\mathrm{opt}} = \\left( \\frac{3|f(x)|\\epsilon}{|f'''(x)|} \\right)^{1/3}\n$$\n\n### 4. 对 $f(x) = \\exp(kx)$ 的特例分析\n\n我们现在将此结果应用于在 $x=1$ 处求值的函数 $f(x) = \\exp(kx)$。所需的导数为：\n$$\nf(x) = e^{kx} \\implies f(1) = e^k\n$$\n$$\nf'(x) = ke^{kx} \\implies f'(1) = ke^k\n$$\n$$\nf'''(x) = k^3e^{kx} \\implies f'''(1) = k^3e^k\n$$\n\n将这些代入 $h_{\\mathrm{opt}}$ 的公式中：\n$$\nh_{\\mathrm{opt}} = \\left( \\frac{3|e^k|\\epsilon}{|k^3e^k|} \\right)^{1/3} = \\left( \\frac{3\\epsilon}{|k|^3} \\right)^{1/3} = \\frac{(3\\epsilon)^{1/3}}{|k|}\n$$\nIEEE 双精度的机器 epsilon 值为 $\\epsilon = 2^{-53}$。\n\n### 5. 预期正确数字位数\n\n预期相对误差 $\\delta_{\\mathrm{exp}}$ 是最小总误差 $E(h_{\\mathrm{opt}})$ 除以真实导数的量级 $|f'(1)|$。在 $h=h_{\\mathrm{opt}}$ 时，两个误差贡献的量级相同。总误差为：\n$$\nE(h_{\\mathrm{opt}}) = \\left|\\frac{f'''(1)}{6}\\right| h_{\\mathrm{opt}}^2 + \\frac{|f(1)| \\epsilon}{h_{\\mathrm{opt}}}\n$$\n最优相对误差 $\\delta_{\\mathrm{exp}} = E(h_{\\mathrm{opt}})/|f'(1)|$ 是：\n$$\n\\delta_{\\mathrm{exp}} = \\frac{1}{|ke^k|}\\left( \\left|\\frac{k^3e^k}{6}\\right| \\left(\\frac{3\\epsilon}{|k|^3}\\right)^{2/3} + \\frac{e^k \\epsilon}{|k|^{-1}(3\\epsilon)^{1/3}} \\right)\n$$\n$$\n\\delta_{\\mathrm{exp}} = \\frac{1}{|k|e^k}\\left( \\frac{|k|^3e^k}{6} \\frac{(3\\epsilon)^{2/3}}{|k|^2} + |k|e^k\\epsilon(3\\epsilon)^{-1/3} \\right)\n$$\n$$\n\\delta_{\\mathrm{exp}} = \\frac{|k|^2}{6|k|} (3\\epsilon)^{2/3} + \\epsilon^{2/3} 3^{-1/3} = \\frac{|k|}{6} (3\\epsilon)^{2/3} + \\frac{|k|}{3|k|} (3\\epsilon)^{2/3} = \\frac{|k|e^k}{|ke^k|} \\left( \\frac{(3\\epsilon)^{2/3}}{6} + \\frac{(3\\epsilon)^{2/3}}{3} \\right)\n$$\n化简，我们将 $h_{\\mathrm{opt}} = (3\\epsilon/|k|^3)^{1/3}$ 代入相对误差表达式 $\\delta(h) = |\\frac{k^2}{6}| h^2 + \\frac{\\epsilon}{|k|h}$。\n$$\n\\delta_{\\mathrm{exp}} = \\frac{|k|^2}{6} \\left(\\frac{3\\epsilon}{|k|^3}\\right)^{2/3} + \\frac{\\epsilon}{|k|} \\left(\\frac{3\\epsilon}{|k|^3}\\right)^{-1/3} = \\frac{|k|^2}{6} \\frac{(3\\epsilon)^{2/3}}{|k|^2} + \\frac{\\epsilon}{|k|} \\frac{|k|}{(3\\epsilon)^{1/3}} = \\frac{(3\\epsilon)^{2/3}}{6} + \\frac{3\\epsilon}{3(3\\epsilon)^{1/3}} = \\frac{(3\\epsilon)^{2/3}}{6} + \\frac{(3\\epsilon)^{2/3}}{3} = \\frac{3(3\\epsilon)^{2/3}}{6} = \\frac{(3\\epsilon)^{2/3}}{2}\n$$\n$$\n\\delta_{\\mathrm{exp}} = \\frac{3^{2/3}}{2} \\epsilon^{2/3}\n$$\n值得注意的是，预期的最优相对误差与参数 $k$ 无关。\n预期的正确十进制数字位数由 $d^{\\mathrm{exp}} = -\\log_{10}(\\delta_{\\mathrm{exp}})$ 给出。\n\n### 6. 测量的正确数字位数\n\n对于每个 $k$ 值，我们将数值计算 $h_{\\mathrm{opt}}$，然后使用标准双精度算术评估 $D_{h_{\\mathrm{opt}}} f(1)$。然后按如下方式计算测量的相对误差 $\\delta_{\\mathrm{meas}}$：\n$$\n\\delta_{\\mathrm{meas}} = \\frac{|D_{h_{\\mathrm{opt}}}f(1) - f'(1)|}{|f'(1)|}\n$$\n测量的数字位数为 $d^{\\mathrm{meas}} = -\\log_{10}(\\delta_{\\mathrm{meas}})$。$d^{\\mathrm{exp}}$ 和 $d^{\\mathrm{meas}}$ 的比较验证了误差模型的稳健性。对于较大的 $k$ 值，灾难性抵消预计会降低精度，可能导致测量误差显著大于（且 $d^{\\mathrm{meas}}$ 小于）我们简化模型的预测值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the central finite-difference method for f(x) = exp(kx),\n    calculating the optimal step size and comparing theoretical vs. measured error.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Case parameters are values of k, with x=1 fixed.\n    test_cases = [\n        1.0,    # Case A: General reference scale\n        10.0,   # Case B: Steep exponential\n        0.1,    # Case C: Gentle exponential\n        100.0   # Case D: Very steep exponential\n    ]\n\n    # IEEE 754 double precision unit roundoff\n    epsilon = 2**-53\n\n    results = []\n    \n    # The expected relative error, derived in the solution, is independent of k.\n    # δ_exp = (3^(2/3) / 2) * ε^(2/3)\n    delta_exp = (3**(2/3) / 2) * (epsilon**(2/3))\n    \n    # The expected number of correct digits.\n    d_exp = -np.log10(delta_exp)\n\n    for k in test_cases:\n        x = 1.0\n\n        # Task 4: Compute the optimal step size h_opt for f(x) = exp(kx).\n        # h_opt = (|k|)^-1 * (3*ε)^(1/3)\n        # Using abs(k) to handle potential negative k, though not in test suite.\n        h_opt = (1 / np.abs(k)) * (3 * epsilon)**(1/3)\n\n        # Task 5: The expected number of correct digits, d_exp, is already computed.\n\n        # Task 6: Validate the model by direct computation.\n        # Exact derivative: f'(x) = k * exp(kx)\n        f_prime_exact = k * np.exp(k * x)\n\n        # Numerical derivative using the central difference formula.\n        # All calculations are implicitly in float64 (double precision).\n        f_plus_h = np.exp(k * (x + h_opt))\n        f_minus_h = np.exp(k * (x - h_opt))\n        f_prime_numerical = (f_plus_h - f_minus_h) / (2 * h_opt)\n\n        # Calculate the measured relative error.\n        # Add a small quantity to the denominator to prevent division by zero\n        # if the exact derivative happens to be zero.\n        delta_meas = np.abs(f_prime_numerical - f_prime_exact) / (np.abs(f_prime_exact) + epsilon)\n        \n        # Calculate the measured number of correct digits.\n        # If delta_meas is zero, it implies precision to the limits of float64.\n        # In that rare case, we can use a proxy for a very large number of digits.\n        if delta_meas == 0.0:\n            d_meas = -np.log10(epsilon) # A reasonable upper bound on measurable precision\n        else:\n            d_meas = -np.log10(delta_meas)\n\n        # Compare expected vs. measured digit counts.\n        ok = np.abs(d_exp - d_meas) = 0.5\n        \n        results.extend([h_opt, d_exp, d_meas, ok])\n\n    # Final print statement in the exact required format.\n    # The boolean values will be correctly converted to 'True' or 'False' by str().\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "高能物理中的许多积分，例如来自相空间或传播子的积分，都带有会破坏标准求积法则收敛速度的可积奇点。与其直接应用数值方法，不如先通过解析变换来“驯服”被积函数。本练习将引导您分析如何通过变量替换 $x=u^2$ 来消除端点奇性，从而显著提高复合辛普森法则的收敛阶数，将缓慢的 $\\mathcal{O}(N^{-1/2})$ 收敛提升为快速的 $\\mathcal{O}(M^{-4})$ 收敛 。",
            "id": "3525153",
            "problem": "在计算高能物理的相空间积分的确定性求积中，人们通常会遇到具有可积端点奇性的被积函数，例如在产生阈值附近，运动学雅可比量会产生诸如 $x^{-\\alpha}$（其中 $0  \\alpha  1$）的因子。考虑以下一维模型积分：\n$$\nI \\;=\\; \\int_{0}^{1} x^{-1/2}\\, G(x)\\, dx,\n$$\n其中 $G$ 是一个实值函数，满足 $G\\in C^{4}([0,1])$ 且 $G(0)\\neq 0$，用于模拟一个光滑的可观测量权重。假设将复合 Simpson 法则直接应用于 $I$，该法则使用大小为 $h=1/N$ 的 $N$ 个子区间（$N$ 为偶数）的均匀网格。作为替代方案，执行变量代换 $x=u^{2}$，使得 $I=\\int_{0}^{1} F(u)\\,du$，其中被积函数为变换后的 $F(u)$，然后对变量 $u$ 应用复合 Simpson 法则，该法则使用大小为 $H=1/M$ 的 $M$ 个子区间（$M$ 为偶数）的均匀网格。\n\n在所述的光滑性假设下，哪项陈述最能描述变量代换 $x=u^{2}$ 如何正则化可积端点奇性，以及在未变换和变换后的公式之间，复合 Simpson 法则的领头阶渐近全局误差（用 $N$ 或 $M$ 表示）如何比较？\n\nA. 该代换将被积函数映射为 $F(u)=2\\,G(u^{2})$，它在 $[0,1]$ 上是 $C^{4}$ 函数，在 $u=0$ 处具有有界导数，从而消除了端点奇性；未变换的复合 Simpson 误差由靠近 $x=0$ 的第一个区间主导，其量级为 $\\mathcal{O}(N^{-1/2})$，而变换后的复合 Simpson 误差的量级为 $\\mathcal{O}(M^{-4})$。\n\nB. 该代换将被积函数映射为 $F(u)=2\\,G(u^{2})$，但在 $u=0$ 处留下一个残余的对数奇性；未变换和变换后的复合 Simpson 误差的量级均为 $\\mathcal{O}(N^{-2})$（或 $\\mathcal{O}(M^{-2})$）。\n\nC. 该代换将被积函数映射为 $F(u)=2\\,G(u^{2})$，它在 $u=0$ 处连续但不可导；变换后的复合 Simpson 误差的量级为 $\\mathcal{O}(M^{-2})$，而未变换的复合 Simpson 误差的量级为 $\\mathcal{O}(N^{-1})$。\n\nD. 该代换消除了可积奇性，并进一步引发超收敛，使得变换后的复合 Simpson 误差的量级为 $\\mathcal{O}(M^{-6})$，而未变换的复合 Simpson 误差在原始被积函数上已经达到了 $\\mathcal{O}(N^{-4})$。",
            "solution": "用户提供了一个关于对具有可积端点奇性的函数进行数值积分的问题。我的任务是验证问题陈述，如果有效，则推导数值方法的正确行为并评估给定的选项。\n\n### 问题验证\n\n**第1步：提取已知条件**\n\n1.  **待求积分：** $I \\;=\\; \\int_{0}^{1} x^{-1/2}\\, G(x)\\, dx$。\n2.  **函数性质：** $G(x)$ 是一个实值函数，$G\\in C^{4}([0,1])$，且 $G(0)\\neq 0$。因子 $x^{-\\alpha}$（其中 $0  \\alpha  1$）作为一个通用例子给出，在模型积分中使用了 $\\alpha=1/2$。\n3.  **方法1（未变换）：** 将复合 Simpson 法则直接应用于 $I$，使用大小为 $h=1/N$（$N$ 为偶数）的 $N$ 个子区间的均匀网格。\n4.  **方法2（变换后）：**\n    *   变量代换：$x=u^{2}$。\n    *   积分变为 $I=\\int_{0}^{1} F(u)\\,du$。\n    *   将复合 Simpson 法则应用于此变换后的积分，使用大小为 $H=1/M$（$M$ 为偶数）的 $M$ 个子区间的均匀网格。\n5.  **问题：** 描述该代换对奇性的正则化效果，并比较两种方法的复合 Simpson 法则的领头阶渐近全局误差。\n\n**第2步：使用提取的已知条件进行验证**\n\n*   **科学依据：** 该问题在科学和数学上是合理的。它涉及数值分析中的一个经典课题：求积中可积奇性的处理。使用变量代换 ($x=u^2$) 来正则化平方根奇性 ($x^{-1/2}$) 是一种标准且有效的技术。高能物理的背景是恰当的，因为相空间积分经常表现出此类运动学奇性。\n*   **适定性：** 问题是适定的。积分、函数 $G(x)$ 的性质、数值方法（复合 Simpson 法则）和变换都已明确定义。问题要求比较误差量级，这可以使用已建立的数值积分理论来确定。\n*   **客观性：** 问题是用精确、客观的数学语言陈述的。\n*   **缺陷分析：**\n    *   短语“直接应用”于奇异被积函数可能被视为模棱两可，因为 Simpson 法则公式 $\\frac{h}{3}(f(x_{2k-2}) + 4f(x_{2k-1}) + f(x_{2k}))$ 在第一个节点 $x_0=0$ 处是未良定义的，因为被积函数 $x^{-1/2} G(x)$ 在该点为无穷大。然而，在渐近误差分析的背景下，这被理解为应用求积法则并使用可以处理此类奇性的框架（如针对具有代数端点奇性函数的 Euler-Maclaurin 公式）来分析误差。该框架提供了一个良定义的渐近误差展开，而无需解决计算 $f(0)$ 的实际问题。鉴于这是数值分析中的标准解释，该问题并非存在致命缺陷。\n    *   检查清单中的其他缺陷均不存在。\n\n**第3步：结论与行动**\n\n问题是**有效的**。我将继续进行求解推导。\n\n### 求解推导\n\n求解需要两个主要部分：分析变量代换对被积函数的影响，然后分析复合 Simpson 法则对于原始和变换后的被积函数的收敛行为。\n\n**1. 变量代换分析**\n\n积分为 $I = \\int_{0}^{1} x^{-1/2}\\, G(x)\\, dx$。我们进行代换 $x=u^{2}$。\n$u$ 的积分限从 $u=\\sqrt{0}=0$ 到 $u=\\sqrt{1}=1$。\n微分变为 $dx = 2u\\,du$。\n将这些代入积分：\n$$\nI = \\int_{0}^{1} (u^2)^{-1/2}\\, G(u^2)\\, (2u\\,du) = \\int_{0}^{1} u^{-1}\\, G(u^2)\\, (2u\\,du) = \\int_{0}^{1} 2\\,G(u^2)\\,du\n$$\n因此，变换后的被积函数为 $F(u) = 2\\,G(u^2)$。\n\n现在，我们必须确定 $F(u)$ 的光滑性。已知 $G \\in C^4([0,1])$，这意味着其直到4阶的导数在闭区间 $[0,1]$ 上是连续的。我们来检查 $F(u) = 2\\,G(u^2)$ 的导数：\n*   $F(u) = 2\\,G(u^2)$。由于 $G$ 连续，所以 $F$ 连续。\n*   $F'(u) = \\frac{d}{du} (2\\,G(u^2)) = 2\\,G'(u^2) \\cdot (2u) = 4u\\,G'(u^2)$。\n*   $F''(u) = \\frac{d}{du} (4u\\,G'(u^2)) = 4\\,G'(u^2) + 4u \\cdot (G''(u^2) \\cdot 2u) = 4\\,G'(u^2) + 8u^2\\,G''(u^2)$。\n*   $F'''(u) = \\frac{d}{du} (4\\,G'(u^2) + 8u^2\\,G''(u^2)) = 4\\,G''(u^2)\\cdot 2u + 16u\\,G''(u^2) + 8u^2\\,G'''(u^2)\\cdot 2u = 24u\\,G''(u^2) + 16u^3\\,G'''(u^2)$。\n*   $F^{(4)}(u) = \\frac{d}{du} (24u\\,G''(u^2) + 16u^3\\,G'''(u^2)) = 24\\,G''(u^2) + 24u\\,G'''(u^2)\\cdot 2u + 48u^2\\,G'''(u^2) + 16u^3\\,G^{(4)}(u^2)\\cdot 2u = 24\\,G''(u^2) + 96u^2\\,G'''(u^2) + 32u^4\\,G^{(4)}(u^2)$。\n\n由于 $G \\in C^4([0,1])$，函数 $G, G', G'', G''', G^{(4)}$ 在 $[0,1]$ 上都是连续且有界的。$F(u)$ 及其前四阶导数的表达式是这些连续函数和 $u$ 的多项式的复合与乘积。因此，$F(u)$ 及其直到4阶的导数在 $[0,1]$ 上是连续的。这意味着 $F(u) \\in C^4([0,1])$。代换 $x=u^2$ 成功地移除了奇性，得到了一个光滑的被积函数。\n\n**2. 复合 Simpson 法则的误差分析**\n\n**变换后积分的误差：**\n复合 Simpson 法则应用于 $I = \\int_0^1 F(u)\\,du$，其中 $F(u) \\in C^4([0,1])$。在区间 $[a,b]$ 上，使用大小为 $H=(b-a)/M$ 的 $M$ 个子区间的复合 Simpson 法则的标准误差公式为：\n$$\nE_M = -\\frac{(b-a)H^4}{180} F^{(4)}(\\xi)\n$$\n对于某个 $\\xi \\in [a,b]$。在我们的情况下，$a=0, b=1, H=1/M$。误差为：\n$$\nE_M = -\\frac{1}{180 M^4} F^{(4)}(\\xi) \\quad \\text{对于某个 } \\xi \\in [0,1].\n$$\n由于 $F^{(4)}$ 在 $[0,1]$ 上连续，所以它是有界的。因此，全局误差的量级为 $\\mathcal{O}(H^4)$，即 $\\mathcal{O}(M^{-4})$。\n\n**未变换积分的误差：**\n复合 Simpson 法则应用于 $I = \\int_{0}^{1} f(x)\\,dx$，其中 $f(x) = x^{-1/2}G(x)$。函数 $f(x)$ 在 $x=0$ 处有奇性，其导数在 $[0,1]$ 上是无界的。例如，$f'(x) = -\\frac{1}{2}x^{-3/2}G(x) + x^{-1/2}G'(x)$，由于 $G(0)\\neq 0$，当 $x \\to 0^+$ 时发散。因此，标准误差公式不适用。\n\n我们必须使用针对具有代数端点奇性函数的数值积分理论，该理论通常基于 Euler-Maclaurin 展开。对于在 $x=0$ 附近具有领头行为 $x^{-\\alpha}$（对于非整数 $\\alpha > -1$）的被积函数，求积法则的误差由一个形如 $C h^{1-\\alpha}$ 的项主导。\n对于复合梯形法则，误差有一个包含形如 $h^{k-\\alpha}$（对于整数 $k \\ge 1$）项的渐近展开。领头项为 $\\mathcal{O}(h^{1-\\alpha})$。当 $\\alpha=1/2$ 时，这为 $\\mathcal{O}(h^{1/2})$。\n\nSimpson 法则的和 $S_N$ 可以通过 Richardson 外推从梯形法则的和 $T_N$ 和 $T_{2N}$ 构建：$S_N = \\frac{4T_{2N} - T_N}{3}$。如果梯形法则的误差展开纯粹是 $h$ 的偶次幂（即 $E_T(h) = c_2 h^2 + c_4 h^4 + \\dots$），这将消除 $h^2$ 项并导致 $\\mathcal{O}(h^4)$ 的误差。\n然而，对于我们的奇异被积函数，梯形法则的误差展开形式为：\n$$\nE_T(h) = c_{1/2} h^{1/2} + c_{3/2} h^{3/2} + \\dots + (\\text{h 的偶数整数次幂})\n$$\n应用 Richardson 外推：\n$$\nE_S(h) = \\frac{4 E_T(h/2) - E_T(h)}{3} = \\frac{4(c_{1/2}(h/2)^{1/2} + \\dots) - (c_{1/2}h^{1/2} + \\dots)}{3} = \\frac{c_{1/2}h^{1/2}(4/\\sqrt{2} - 1)}{3} + \\dots\n$$\n$h^{1/2}$ 项没有被抵消。因此，复合 Simpson 法则的领头误差的量级也为 $\\mathcal{O}(h^{1/2})$。当 $h=1/N$ 时，误差为 $\\mathcal{O}(N^{-1/2})$。这种慢收敛主要是由于在靠近奇点的第一个子区间内对被积函数的不良近似。\n\n**结论总结：**\n*   **正则化：** 代换 $x=u^2$ 将被积函数变换为 $F(u)=2G(u^2)$，这是一个在 $[0,1]$ 上的 $C^4$ 函数，完全移除了奇性。\n*   **误差（未变换）：** 误差的量级为 $\\mathcal{O}(N^{-1/2})$。\n*   **误差（变换后）：** 误差的量级为 $\\mathcal{O}(M^{-4})$。\n\n###逐项分析\n\n*   **A. 该代换将被积函数映射为 $F(u)=2\\,G(u^{2})$，它在 $[0,1]$ 上是 $C^{4}$ 函数，在 $u=0$ 处具有有界导数，从而消除了端点奇性；未变换的复合 Simpson 误差由靠近 $x=0$ 的第一个区间主导，其量级为 $\\mathcal{O}(N^{-1/2})$，而变换后的复合 Simpson 误差的量级为 $\\mathcal{O}(M^{-4})$。**\n    该陈述与我们推导出的所有结论完全匹配。变换得到 $F(u)=2G(u^2)$，我们已证明其为 $C^4$ 函数。未变换的误差量级为 $\\mathcal{O}(N^{-1/2})$，变换后的误差量级为 $\\mathcal{O}(M^{-4})$。\n    **结论：正确。**\n\n*   **B. 该代换将被积函数映射为 $F(u)=2\\,G(u^{2})$，但在 $u=0$ 处留下一个残余的对数奇性；未变换和变换后的复合 Simpson 误差的量级均为 $\\mathcal{O}(N^{-2})$（或 $\\mathcal{O}(M^{-2})$）。**\n    这是不正确的。该代换没有留下对数奇性；它产生了一个 $C^4$ 函数。所述的两个误差量级也都不正确。未变换的误差为 $\\mathcal{O}(N^{-1/2})$，变换后的误差为 $\\mathcal{O}(M^{-4})$。\n    **结论：不正确。**\n\n*   **C. 该代换将被积函数映射为 $F(u)=2\\,G(u^{2})$，它在 $u=0$ 处连续但不可导；变换后的复合 Simpson 误差的量级为 $\\mathcal{O}(M^{-2})$，而未变换的复合 Simpson 误差的量级为 $\\mathcal{O}(N^{-1})$。**\n    这是不正确的。我们证明了 $F(u)$ 不仅可导，而且属于 $C^4([0,1])$。变换后的误差量级为 $\\mathcal{O}(M^{-4})$，而不是 $\\mathcal{O}(M^{-2})$。未变换的误差量级为 $\\mathcal{O}(N^{-1/2})$，而不是 $\\mathcal{O}(N^{-1})$。\n    **结论：不正确。**\n\n*   **D. 该代换消除了可积奇性，并进一步引发超收敛，使得变换后的复合 Simpson 误差的量级为 $\\mathcal{O}(M^{-6})$，而未变换的复合 Simpson 误差在原始被积函数上已经达到了 $\\mathcal{O}(N^{-4})$。**\n    这是不正确的。未变换的误差没有达到 $\\mathcal{O}(N^{-4})$；它要差得多，为 $\\mathcal{O}(N^{-1/2})$。虽然代换确实消除了奇性，但它通常不会引发超收敛到 $\\mathcal{O}(M^{-6})$。这将需要函数 $G(x)$ 具有特殊性质（例如 $F'''(1) = 0$），而这些性质并未给出。标准的收敛率是 $\\mathcal{O}(M^{-4})$。\n    **结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "当我们将数值积分从一维推广到多维时，“维度灾难”便成为一个核心挑战，即求积点数会随维度呈指数增长，使得天真地使用张量积网格很快变得不切实际。本练习将让您亲手实现并比较两种策略：一种是张量积高斯求积，另一种是更高级的Smolyak稀疏网格法 。通过这个对比，您将深刻理解稀疏网格是如何通过巧妙地组合低阶求积法则，以远低于张量积的计算成本，来高效地计算高维积分的。",
            "id": "3525193",
            "problem": "考虑在三维单位立方体上的一个可分离指数权重积分，定义为 $\\int_{[0,1]^3} \\exp(-\\alpha \\sum_{i=1}^3 x_i)\\,dx$，其中 $\\alpha$ 是一个正参数且 $(x_1,x_2,x_3)\\in[0,1]^3$。在计算高能物理学中，此类积分用于模拟带指数抑制的简化相空间平均值，当存在精确表达式可供验证时，对其进行精确的数值评估至关重要。从微积分和数值分析的基本原理出发，设计并实现一个程序，在固定参数值 $\\alpha=10$ 的条件下，比较两种用于此积分的数值积分策略：一种是张量积高斯求积，另一种是三维的2级Smolyak稀疏网格。\n\n您的程序必须遵守以下要求：\n\n1. 使用 $[-1,1]$ 上变换到 $[0,1]$ 的 Gauss-Legendre 族，实现一个张量积高斯求积，每个空间维度有 $N$ 个点。三维张量积法则应使用一维节点和权重的笛卡尔积。\n\n2. 使用一系列变换到 $[0,1]$ 的一维 Gauss-Legendre 法则 $U^{(l)}$（其中 $l\\in\\{1,2\\}$ 且节点数为 $N(l)=2l-1$），在 $d=3$ 维中实现一个2级 Smolyak 稀疏网格。通过经典的层级差分公式 $\\Delta^{(l)}=U^{(l)}-U^{(l-1)}$（其中 $U^{(0)}=0$）构建2级 Smolyak 算子，组合所有满足 $l_i\\ge 1$ 和 $l_1+l_2+l_3=4$ 的多重指标 $(l_1,l_2,l_3)$。您的实现必须显式地构建组合后的三维求积节点和权重，正确处理负权重并通过求和其权重来合并重复节点，并且必须报告所使用的唯一函数求值点的总数。\n\n3. 使用微积分的第一性原理和被积函数的可分离性，解析地计算积分的精确值，不依赖外部资源或预制表格结果。使用此精确值计算每种数值方法的绝对误差。\n\n4. 所有计算均使用固定参数值 $\\alpha=10$。该积分不涉及任何物理单位；所有量均为无量纲。\n\n5. 测试套件：\n   - 对每个维度 $N\\in\\{1,3,5\\}$ 个点的情况，评估张量积高斯求积。\n   - 对于测试套件中的每个 $N$，计算：\n     - 张量积高斯求积的绝对误差。\n     - 2级Smolyak稀疏网格的绝对误差（该值与 $N$ 无关）。\n     - 张量积法则使用的总点数，即 $N^3$。\n     - Smolyak稀疏网格实现所使用的唯一总点数（根据指定规则构建并合并重复点）。\n   该测试套件涵盖了一个边界情况（$N=1$）、一个典型的中等精度情况（$N=3$）和一个更高精度的情况（$N=5$）。\n\n6. 最终输出格式：\n   您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例对应一个形式为 $[E_{\\mathrm{tensor}},E_{\\mathrm{smolyak}},P_{\\mathrm{tensor}},P_{\\mathrm{smolyak}}]$ 的子列表，其中 $E_{\\mathrm{tensor}}$ 和 $E_{\\mathrm{smolyak}}$ 是浮点数（绝对误差），$P_{\\mathrm{tensor}}$ 和 $P_{\\mathrm{smolyak}}$ 是整数（点数）。例如，最终打印的行必须类似于 $[[e_{1},e_{2},p_{1},p_{2}],[e_{3},e_{4},p_{3},p_{4}],\\ldots]$，不含空格。\n\n您的实现必须是一个完整、可运行的程序，并且不得从文件或网络读取输入。程序必须在内部计算精确积分，并按规定执行所有数值求积计算。",
            "solution": "该问题被验证为具有科学依据、适定且客观的。它提出了一个数值分析中的具体且可形式化的任务，即为一个定义明确的积分比较两种标准求积方法。所有必要的参数和定义都已提供。\n\n### 1. 解析解\n\n待求的积分为：\n$$\nI = \\int_{[0,1]^3} \\exp\\left(-\\alpha \\sum_{i=1}^3 x_i\\right) d\\mathbf{x}\n$$\n其中 $d\\mathbf{x} = dx_1 dx_2 dx_3$，积分域为单位立方体 $[0,1]^3$。给定参数 $\\alpha=10$。\n\n被积函数 $f(x_1, x_2, x_3) = \\exp(-\\alpha(x_1+x_2+x_3))$ 是一个可分离函数，因为它可以写成单变量函数的乘积：\n$$\nf(x_1, x_2, x_3) = e^{-\\alpha x_1} e^{-\\alpha x_2} e^{-\\alpha x_3}\n$$\n由于被积函数的可分离性和矩形积分域，该三维积分可以表示为一个一维积分的立方：\n$$\nI = \\left( \\int_0^1 e^{-\\alpha x} dx \\right) \\left( \\int_0^1 e^{-\\alpha y} dy \\right) \\left( \\int_0^1 e^{-\\alpha z} dz \\right) = \\left( \\int_0^1 e^{-\\alpha x} dx \\right)^3\n$$\n该一维积分可使用微积分基本定理进行计算：\n$$\n\\int_0^1 e^{-\\alpha x} dx = \\left[ -\\frac{1}{\\alpha} e^{-\\alpha x} \\right]_0^1 = -\\frac{1}{\\alpha} (e^{-\\alpha \\cdot 1} - e^{-\\alpha \\cdot 0}) = -\\frac{1}{\\alpha} (e^{-\\alpha} - 1) = \\frac{1 - e^{-\\alpha}}{\\alpha}\n$$\n将此结果代回，三维积分的精确值为：\n$$\nI_{\\text{exact}} = \\left( \\frac{1 - e^{-\\alpha}}{\\alpha} \\right)^3\n$$\n对于给定参数 $\\alpha=10$，精确值为：\n$$\nI_{\\text{exact}} = \\left( \\frac{1 - e^{-10}}{10} \\right)^3 \\approx (0.09999546...)^3 \\approx 9.9986389... \\times 10^{-4}\n$$\n\n### 2. 数值积分方法\n\n我们将实现并比较两种数值求积方法。对于任何求积法则，函数 $g(\\mathbf{p})$ 在域 $\\Omega$ 上的积分通过在特定点（节点）$\\mathbf{p}_j$ 处的函数值的加权和来近似：\n$$\n\\int_\\Omega g(\\mathbf{p}) d\\mathbf{p} \\approx \\sum_{j=1}^M w_j g(\\mathbf{p}_j)\n$$\n\n一维 Gauss-Legendre 求积法则定义在区间 $[-1,1]$ 上。要将其应用于 $[0,1]$ 上的积分，必须对节点 $x_i \\in [-1,1]$ 和权重 $w_i$ 进行变换。线性映射为 $x' = (x+1)/2$。对于区间 $[0,1]$，新的节点 $x'_i$ 和权重 $w'_i$ 为：\n$$\nx'_i = \\frac{x_i + 1}{2}, \\quad w'_i = \\frac{w_i}{2}\n$$\n\n#### 2.1. 张量积高斯求积\n\n三维张量积法则是从一维法则构建的。给定在 $[0,1]$ 上有 $N$ 个节点 $\\{x'_i\\}_{i=1}^N$ 和权重 $\\{w'_i\\}_{i=1}^N$ 的一维 Gauss-Legendre 法则，三维张量积法则使用 $N^3$ 个点。节点是一维节点的笛卡尔积，形成一个网格：$\\mathbf{p}_{ijk} = (x'_i, x'_j, x'_k)$。相应的权重是一维权重的乘积：$W_{ijk} = w'_i w'_j w'_k$。积分近似值为：\n$$\nI_{\\text{tensor}} \\approx \\sum_{i=1}^N \\sum_{j=1}^N \\sum_{k=1}^N (w'_i w'_j w'_k) f(x'_i, x'_j, x'_k)\n$$\n此方法所用的函数求值点总数为 $P_{\\text{tensor}} = N^3$。\n\n#### 2.2. Smolyak 稀疏网格求积\n\n问题指定了一种在 $d=3$ 维中构建2级 Smolyak 稀疏网格的特定方法。该构建基于一系列一维 Gauss-Legendre 法则 $U^{(l)}$，其中第 $l$ 个法则使用 $N(l) = 2l-1$ 个点。\n-   $l=1 \\implies N(1)=1$ 个点（中点法则）。\n-   $l=2 \\implies N(2)=3$ 个点。\n\n该构建使用差分算子 $\\Delta^{(l)} = U^{(l)} - U^{(l-1)}$，并约定 $U^{(0)}=0$。因此，$\\Delta^{(1)} = U^{(1)}$。\n指定的 Smolyak 算子是通过组合这些差分算子的张量积来构成的，适用于所有 $l_i \\ge 1$ 且其和为 $|\\mathbf{l}|_1 = l_1+l_2+l_3=4$ 的多重指标 $\\mathbf{l} = (l_1, l_2, l_3)$。符合条件的多重指标集合为 $\\{(2,1,1), (1,2,1), (1,1,2)\\}$。\n\n因此，Smolyak 求积法则 $Q_{\\text{smolyak}}$ 为：\n$$\nQ_{\\text{smolyak}} = \\Delta^{(2)} \\otimes \\Delta^{(1)} \\otimes \\Delta^{(1)} + \\Delta^{(1)} \\otimes \\Delta^{(2)} \\otimes \\Delta^{(1)} + \\Delta^{(1)} \\otimes \\Delta^{(1)} \\otimes \\Delta^{(2)}\n$$\n代入 $\\Delta^{(1)} = U^{(1)}$ 和 $\\Delta^{(2)} = U^{(2)} - U^{(1)}$，展开为：\n$$\nQ_{\\text{smolyak}} = (U^{(2)}-U^{(1)}) \\otimes U^{(1)} \\otimes U^{(1)} + U^{(1)} \\otimes (U^{(2)}-U^{(1)}) \\otimes U^{(1)} + U^{(1)} \\otimes U^{(1)} \\otimes (U^{(2)}-U^{(1)})\n$$\n\n为实现这一点，我们计算每一项的节点和权重并将它们相加，通过加和权重来合并重复的节点。\n-   $[0,1]$ 上的 $U^{(1)}$：1个节点 $x_1^{(1)}=0.5$，权重 $w_1^{(1)}=1.0$。\n-   $[0,1]$ 上的 $U^{(2)}$：3个节点 $\\{x_1^{(2)}, x_2^{(2)}, x_3^{(2)}\\} = \\{(1-\\sqrt{3/5})/2, 0.5, (1+\\sqrt{3/5})/2\\}$，权重 $\\{w_1^{(2)}, w_2^{(2)}, w_3^{(2)}\\} = \\{5/18, 8/18, 5/18\\}$。\n\n算子 $\\Delta^{(2)} = U^{(2)} - U^{(1)}$ 使用 $U^{(2)}$ 的节点。节点 $x_2^{(2)}=0.5$（同时也是 $U^{(1)}$ 的节点）的权重被修改为：$w_2^{\\Delta(2)} = w_2^{(2)} - w_1^{(1)} = 8/18 - 1 = -10/18$。其他权重不变。$\\Delta^{(2)}$ 的节点和权重为：\n-   节点：$\\{(1-\\sqrt{3/5})/2, 0.5, (1+\\sqrt{3/5})/2\\}$\n-   权重：$\\{5/18, -10/18, 5/18\\}$\n\n完整的稀疏网格是通过从 $Q_{\\text{smolyak}}$ 表达式中的三个张量积项创建所有点及其对应权重的列表来构建的。\n-   $\\Delta^{(2)}\\otimes\\Delta^{(1)}\\otimes\\Delta^{(1)}$ 贡献了3个形式为（来自 $\\Delta^{(2)}$ 的节点, $0.5, 0.5$）的点。\n-   $\\Delta^{(1)}\\otimes\\Delta^{(2)}\\otimes\\Delta^{(1)}$ 贡献了3个形式为（$0.5$, 来自 $\\Delta^{(2)}$ 的节点, $0.5$）的点。\n-   $\\Delta^{(1)}\\otimes\\Delta^{(1)}\\otimes\\Delta^{(2)}$ 贡献了3个形式为（$0.5, 0.5$, 来自 $\\Delta^{(2)}$ 的节点）的点。\n\n这总共产生 $3+3+3=9$ 个初始点。其中几个点是重复的。例如，点 $(0.5, 0.5, 0.5)$ 由所有三项生成。合并重复点并求和其权重后，我们剩下7个唯一的点。\n-   1个中心点：$(0.5, 0.5, 0.5)$。其权重是三项权重之和：$3 \\times (-10/18) = -30/18$。\n-   6个“轴向”点：例如， $((1\\pm\\sqrt{3/5})/2, 0.5, 0.5)$ 及其排列。这些唯一的点每个都只出现一次，权重为 $5/18$。\n\n唯一的函数求值总数为 $P_{\\text{smolyak}} = 7$。\n\n### 3. 误差计算\n\n每种数值方法的绝对误差计算为数值近似值与精确解析值之差的绝对值：\n$$\nE = |I_{\\text{numerical}} - I_{\\text{exact}}|\n$$\n这将对 $I_{\\text{tensor}}$ 和 $I_{\\text{smolyak}}$ 分别计算。\n\n### 4. 测试用例\n\n测试套件要求对每个 $N \\in \\{1, 3, 5\\}$ 进行以下计算：\n1.  $N$ 点张量积法则的绝对误差 $E_{\\text{tensor}}$。\n2.  2级 Smolyak 法则的绝对误差 $E_{\\text{smolyak}}$（此值将是恒定的）。\n3.  总点数 $P_{\\text{tensor}} = N^3$。\n4.  总点数 $P_{\\text{smolyak}} = 7$（此值将是恒定的）。\n\n最终程序将执行这些计算并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes and compares tensor-product and Smolyak sparse grid quadratures\n    for a 3D exponential integral.\n    \"\"\"\n    # Define the problem parameter and test cases from the problem statement.\n    ALPHA = 10.0\n    TEST_N_VALUES = [1, 3, 5]\n    \n    # 1. ANALYTICAL SOLUTION\n    # The exact value of the integral I = ( (1 - exp(-alpha)) / alpha )^3\n    exact_value = ((1.0 - np.exp(-ALPHA)) / ALPHA)**3\n\n    # Define the integrand function\n    # It accepts a batch of points (N, 3) and returns (N,) results.\n    def integrand(points):\n        return np.exp(-ALPHA * np.sum(points, axis=1))\n\n    def get_transformed_gl_rule(n):\n        \"\"\"\n        Gets Gauss-Legendre nodes and weights for interval [0, 1].\n        \"\"\"\n        nodes_std, weights_std = roots_legendre(n)\n        # Transform from [-1, 1] to [0, 1]\n        nodes_transformed = (nodes_std + 1.0) / 2.0\n        weights_transformed = weights_std / 2.0\n        return nodes_transformed, weights_transformed\n\n    # 2. SMOLYAK SPARSE GRID IMPLEMENTATION\n    def calculate_smolyak_quadrature():\n        \"\"\"\n        Constructs the specified level-2 Smolyak sparse grid and computes the integral.\n        This is a fixed rule, so its result is computed once.\n        \"\"\"\n        # Get 1D base rules U^(l) for l=1, 2 on [0,1]\n        # U^(1) corresponds to n=1, U^(2) to n=3 (since N(l)=2l-1)\n        u1_nodes, u1_weights = get_transformed_gl_rule(1)\n        u2_nodes, u2_weights = get_transformed_gl_rule(3)\n        \n        # Define difference operators Delta^(l)\n        # Delta^(1) = U^(1)\n        d1_nodes, d1_weights = u1_nodes, u1_weights\n        \n        # Delta^(2) = U^(2) - U^(1)\n        d2_nodes = u2_nodes\n        d2_weights = u2_weights.copy()\n        # Find the index of the common node (0.5) in U^(2)\n        common_node_idx = np.where(u2_nodes == u1_nodes[0])[0][0]\n        d2_weights[common_node_idx] -= u1_weights[0]\n\n        # Use a dictionary to store points and sum weights for duplicates\n        # Rounding keys to handle floating point inaccuracies\n        sparse_grid = {}\n        \n        # Rule is sum over permutations of (Delta^2, Delta^1, Delta^1)\n        deltas = [(d1_nodes, d1_weights), (d2_nodes, d2_weights)]\n        multi_indices = [(2, 1, 1), (1, 2, 1), (1, 1, 2)]\n\n        for l1, l2, l3 in multi_indices:\n            nodes_x, weights_x = deltas[l1 - 1]\n            nodes_y, weights_y = deltas[l2 - 1]\n            nodes_z, weights_z = deltas[l3 - 1]\n            \n            for i, (nx, wx) in enumerate(zip(nodes_x, weights_x)):\n                for j, (ny, wy) in enumerate(zip(nodes_y, weights_y)):\n                    for k, (nz, wz) in enumerate(zip(nodes_z, weights_z)):\n                        point = (nx, ny, nz)\n                        # Round to ensure consistent keys for duplicate points\n                        key = tuple(np.round(point, 15))\n                        weight = wx * wy * wz\n                        sparse_grid[key] = sparse_grid.get(key, 0.0) + weight\n\n        # Extract unique points and final weights\n        final_points = np.array(list(sparse_grid.keys()))\n        final_weights = np.array(list(sparse_grid.values()))\n        \n        # Calculate the integral value\n        integral_value = np.sum(final_weights * integrand(final_points))\n        num_points = len(final_points)\n        \n        return integral_value, num_points\n\n    # 3. TENSOR-PRODUCT GAUSSIAN QUADRATURE IMPLEMENTATION\n    def calculate_tensor_product_quadrature(N):\n        \"\"\"\n        Constructs an N-point (per dim) tensor-product grid and computes the integral.\n        \"\"\"\n        nodes_1d, weights_1d = get_transformed_gl_rule(N)\n        \n        # Create 3D grid points and weights\n        x, y, z = np.meshgrid(nodes_1d, nodes_1d, nodes_1d, indexing='ij')\n        points = np.vstack([x.ravel(), y.ravel(), z.ravel()]).T\n        \n        wx, wy, wz = np.meshgrid(weights_1d, weights_1d, weights_1d, indexing='ij')\n        weights = (wx * wy * wz).ravel()\n\n        # Calculate the integral value\n        integral_value = np.sum(weights * integrand(points))\n        num_points = N**3\n        \n        return integral_value, num_points\n\n    # 4. EXECUTE TEST SUITE AND COLLECT RESULTS\n    results = []\n\n    # Pre-calculate the Smolyak result as it's constant for all test cases\n    smolyak_value, smolyak_points_count = calculate_smolyak_quadrature()\n    error_smolyak = abs(smolyak_value - exact_value)\n\n    for N in TEST_N_VALUES:\n        # Calculate tensor product quadrature for the current N\n        tensor_value, tensor_points_count = calculate_tensor_product_quadrature(N)\n        error_tensor = abs(tensor_value - exact_value)\n        \n        # Store results for this test case\n        case_result = [\n            error_tensor,\n            error_smolyak,\n            tensor_points_count,\n            smolyak_points_count\n        ]\n        results.append(case_result)\n\n    # 5. FINAL OUTPUT FORMATTING\n    # Format each sub-list: [val1,val2,...]\n    sub_lists_str = [f\"[{','.join(map(str, r))}]\" for r in results]\n    # Join sub-lists into the final format: [[...],[...],...]\n    final_output = f\"[{','.join(sub_lists_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}