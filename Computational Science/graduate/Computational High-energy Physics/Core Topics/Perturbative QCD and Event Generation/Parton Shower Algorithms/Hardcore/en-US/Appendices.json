{
    "hands_on_practices": [
        {
            "introduction": "At the heart of any reliable particle physics simulation is the strict enforcement of fundamental conservation laws. This first practice focuses on the cornerstone principle of four-momentum conservation in the context of a parton shower. You will implement and verify two distinct kinematic \"recoil\" schemes—a local angular-ordered scheme and a global dipole scheme—to see firsthand how algorithms are engineered to ensure that energy and momentum are perfectly balanced at every branching step .",
            "id": "3527678",
            "problem": "Consider the construction and verification of energy–momentum conservation in simplified models of Quantum Chromodynamics (QCD) parton showers. Use the fundamental base that, in special relativity, isolated systems conserve total four-momentum, so the sum of all final-state four-momenta equals the initial four-momentum. Let the four-momentum be denoted by $p^{\\mu} = (E, p_x, p_y, p_z)$ in four-dimensional Minkowski space with metric signature $(+,-,-,-)$, and let all partons be treated as point-like with specified invariant masses. The task is to implement two distinct shower kinematics and a verification routine:\n\n1. Angular-ordered time-like branching modeled as successive two-body decays, where a massive parent parton with mass $M$ decays into two daughters with invariant masses $m_1$ and $m_2$. In the parent rest frame, exact two-body relativistic decay kinematics impose that the daughter three-momentum magnitude equals\n$$\np^* = \\frac{\\sqrt{\\lambda(M^2,m_1^2,m_2^2)}}{2M}, \\quad \\lambda(a,b,c) = a^2 + b^2 + c^2 - 2ab - 2ac - 2bc,\n$$\nand the daughter energies are\n$$\nE_1 = \\frac{M^2 + m_1^2 - m_2^2}{2M}, \\quad E_2 = \\frac{M^2 + m_2^2 - m_1^2}{2M}.\n$$\nA subsequent decay occurs in the rest frame of the decaying daughter, and the daughters are then boosted back to the laboratory frame using the Lorentz transformation. Emission directions are specified by polar and azimuthal angles $(\\theta,\\phi)$; angular ordering is enforced by requiring that successive emissions satisfy $\\theta_{\\text{next}} \\le \\theta_{\\text{previous}}$. This local recoil scheme ensures exact conservation at each branching because the two daughters share recoil internally such that their four-vectors add to the parent four-vector in its rest frame before boosting, and Lorentz boosts preserve four-momentum sums.\n\n2. Dipole recoil mapping for a final-state dipole initially composed of two massless partons in the center-of-mass (CM) frame with total four-momentum $P^{\\mu} = (Q, 0, 0, 0)$, where $Q$ is the CM energy. A single massless emission with three-momentum magnitude $|\\vec{k}|$ and direction $\\hat{k}$ ($\\theta_k,\\phi_k$) is produced, with energy $E_k = |\\vec{k}|$, subject to $0  |\\vec{k}|  Q/2$. The remaining two recoil partons are taken massless and share recoil symmetrically so that their three-momenta sum to $-\\vec{k}$, and their energies sum to $Q - E_k$. Define\n$$\nE = \\frac{Q - |\\vec{k}|}{2}, \\quad \\cos\\alpha = \\frac{|\\vec{k}|}{Q - |\\vec{k}|}, \\quad \\alpha = \\arccos\\left(\\frac{|\\vec{k}|}{Q - |\\vec{k}|}\\right).\n$$\nChoose a unit vector $\\hat{u}$ orthogonal to $\\hat{k}$. Then construct two unit vectors\n$$\n\\hat{n}_1 = -\\cos\\alpha\\,\\hat{k} + \\sin\\alpha\\,\\hat{u}, \\quad \\hat{n}_2 = -\\cos\\alpha\\,\\hat{k} - \\sin\\alpha\\,\\hat{u},\n$$\nand set the recoil four-vectors to\n$$\np_1^{\\mu} = (E, E\\,\\hat{n}_1), \\quad p_2^{\\mu} = (E, E\\,\\hat{n}_2), \\quad k^{\\mu} = (|\\vec{k}|, |\\vec{k}|\\,\\hat{k}),\n$$\nwhich ensures $p_1^{\\mu} + p_2^{\\mu} + k^{\\mu} = (Q, 0, 0, 0)$ exactly by construction.\n\nImplement a program that:\n- Assembles final-state four-vectors for both kinematics using the provided parameters.\n- Sums final-state four-vectors and compares the result to the initial four-momentum to verify energy–momentum conservation.\n- Uses a numerical tolerance of $10^{-9}\\,\\mathrm{GeV}$ for each component of the four-momentum comparison.\n\nAll energies must be expressed in $\\mathrm{GeV}$, all angles must be in radians. The program must output booleans indicating whether conservation holds within tolerance for each test case.\n\nTest suite. For angular-ordered branching, use three parameter sets, each specifying $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2)$:\n- Case A1: $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2) = (100, 20, 0, 0.6, 1.0, 0.3, 0.4)$.\n- Case A2 (soft first emission): $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2) = (50, 49, 0, 0.2, 2.2, 0.1, 1.7)$.\n- Case A3 (near-collinear first emission): $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2) = (80, 10, 0, 0.000001, 0.0, 0.0000005, 1.1)$.\n\nFor dipole recoil mapping, use three parameter sets, each specifying $(Q, |\\vec{k}|, \\theta_k, \\phi_k)$:\n- Case D1: $(Q, |\\vec{k}|, \\theta_k, \\phi_k) = (100, 20, 1.0, 2.4)$.\n- Case D2 (soft emission): $(Q, |\\vec{k}|, \\theta_k, \\phi_k) = (100, 1.0, 0.8, 0.5)$.\n- Case D3 (near-maximum emission): $(Q, |\\vec{k}|, \\theta_k, \\phi_k) = (100, 49.999, 2.0, 0.1)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$), where each $result_i$ is either $\\texttt{True}$ or $\\texttt{False}$.",
            "solution": "The user's request is to validate and solve a problem concerning energy-momentum conservation in two simplified parton shower kinematic models.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n*   **Principle**: Four-momentum is conserved in isolated systems.\n*   **Four-momentum**: $p^{\\mu} = (E, p_x, p_y, p_z)$, with metric signature $(+,-,-,-)$.\n*   **Tolerance**: Numerical comparison tolerance is $10^{-9}\\,\\mathrm{GeV}$.\n*   **Units**: $\\mathrm{GeV}$ for energy/mass, radians for angles.\n\n*   **Model 1 (Angular-ordered time-like branching)**:\n    *   A sequence of $1 \\to 2$ decays.\n    *   Initial particle: Mass $M$, at rest. Initial four-momentum $p_{init}^{\\mu} = (M,0,0,0)$.\n    *   Generic decay $A \\to B+C$: In rest frame of $A$ (mass $M_A$), daughters (masses $m_B, m_C$) have momentum magnitude $p^* = \\frac{\\sqrt{\\lambda(M_A^2, m_B^2, m_C^2)}}{2M_A}$ and energies $E_B = \\frac{M_A^2 + m_B^2 - m_C^2}{2M_A}$, $E_C = \\frac{M_A^2 + m_C^2 - m_B^2}{2M_A}$, where $\\lambda(a,b,c) = a^2 + b^2 + c^2 - 2ab - 2ac - 2bc$ is the Källén function.\n    *   A subsequent decay's products are boosted from the parent's rest frame back to the lab frame.\n    *   Test cases provide parameters $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2)$.\n        *   A1: $(100, 20, 0, 0.6, 1.0, 0.3, 0.4)$\n        *   A2: $(50, 49, 0, 0.2, 2.2, 0.1, 1.7)$\n        *   A3: $(80, 10, 0, 0.000001, 0.0, 0.0000005, 1.1)$\n\n*   **Model 2 (Dipole recoil mapping)**:\n    *   Initial state: Center-of-mass frame with total four-momentum $P^{\\mu} = (Q, 0, 0, 0)$.\n    *   Final state: One massless emission $k$, two massless recoil partons $p_1, p_2$.\n    *   Emission has momentum magnitude $|\\vec{k}|$, energy $E_k = |\\vec{k}|$ in direction $\\hat{k}(\\theta_k, \\phi_k)$, with $0  |\\vec{k}|  Q/2$.\n    *   Recoil parameters: $E = \\frac{Q-|\\vec{k}|}{2}$ and $\\cos\\alpha = \\frac{|\\vec{k}|}{Q-|\\vec{k}|}$.\n    *   Recoil directions: For $\\hat{u}$ orthogonal to $\\hat{k}$, $\\hat{n}_1 = -\\cos\\alpha\\,\\hat{k} + \\sin\\alpha\\,\\hat{u}$ and $\\hat{n}_2 = -\\cos\\alpha\\,\\hat{k} - \\sin\\alpha\\,\\hat{u}$.\n    *   Final four-vectors: $k^{\\mu}=(|\\vec{k}|, |\\vec{k}|\\hat{k})$, $p_1^{\\mu}=(E, E\\hat{n}_1)$, $p_2^{\\mu}=(E, E\\hat{n}_2)$.\n    *   Test cases provide parameters $(Q, |\\vec{k}|, \\theta_k, \\phi_k)$.\n        *   D1: $(100, 20, 1.0, 2.4)$\n        *   D2: $(100, 1.0, 0.8, 0.5)$\n        *   D3: $(100, 49.999, 2.0, 0.1)$\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically grounded in special relativity and standard high-energy physics kinematics. It is objective and formalizable.\n\nThere are two points of ambiguity:\n1.  **Model 1**: The problem describes \"successive two-body decays\" and provides a parameter tuple $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2)$. The masses of the intermediate particles from the first decay are not explicitly stated. This constitutes an **Incomplete Setup (underspecified)** flaw. However, a plausible and standard interpretation resolves this:\n    *   The first decay is $P_0(M) \\to P_1(m_1) + P_2(m_2)$, where $M, m_1, m_2$ are given in the test case.\n    *   The second decay is $P_1(m_1) \\to P_{11} + P_{12}$. The masses of the final products $P_{11}$ and $P_{12}$ must be assumed. A standard assumption in such simplified models is that they are massless.\n    This interpretation uses all provided parameters in a physically consistent sequence and renders the problem solvable.\n2.  **Model 2**: The construction requires choosing a unit vector $\\hat{u}$ orthogonal to $\\hat{k}$. The choice of $\\hat{u}$ is not specified, which is an **Ill-Posed/Ambiguous** flaw. However, analytical inspection shows that the sum of final four-momenta $p_1^\\mu + p_2^\\mu + k^\\mu$ is independent of the choice of $\\hat{u}$. Thus, any valid choice of $\\hat{u}$ will lead to the same conclusion regarding four-momentum conservation. The ambiguity does not affect the final answer to the question posed.\n\nGiven that the ambiguities can be resolved through a reasonable and standard interpretation (Model 1) or do not affect the final result (Model 2), the problem is deemed valid.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. Proceed to solution.\n\n### Solution\n\nThe solution requires implementing the two kinematic schemes described and numerically verifying four-momentum conservation for the provided test cases.\n\n**Model 1: Angular-Ordered Branching**\n\nThe process is interpreted as a two-step decay chain.\n1.  **Initial State**: A particle $P_0$ of mass $M$ is at rest in the laboratory frame. Its four-momentum is $p_{P_0}^\\mu = (M, 0, 0, 0)$.\n2.  **First Decay**: $P_0$ decays into $P_1$ (mass $m_1$) and $P_2$ (mass $m_2$). Since $P_0$ is at rest, this decay occurs in the lab frame.\n    *   The momentum magnitude $p^*$ of the daughters is calculated using the Källén function: $p^* = \\frac{\\sqrt{\\lambda(M^2,m_1^2,m_2^2)}}{2M}$.\n    *   The energies are $E_1 = \\frac{M^2+m_1^2-m_2^2}{2M}$ and $E_2 = \\frac{M^2+m_2^2-m_1^2}{2M}$.\n    *   The direction of $P_1$ is given by $(\\theta_1, \\phi_1)$. We construct a unit vector $\\hat{n}_1$ and find the 3-momenta $\\vec{p}_1 = p^*\\hat{n}_1$ and $\\vec{p}_2 = -p^*\\hat{n}_1$.\n    *   The four-momenta in the lab frame are $p_1^\\mu = (E_1, \\vec{p}_1)$ and $p_2^\\mu = (E_2, \\vec{p}_2)$. Particle $P_2$ is a final-state particle.\n3.  **Second Decay**: Particle $P_1$ decays into two massless daughters, $P_{11}$ and $P_{12}$. This decay occurs in the rest frame of $P_1$.\n    *   In the $P_1$ rest frame, the parent mass is $m_1$, and the daughter masses are $0$.\n    *   The momentum magnitude of the daughters is $p' = \\frac{\\sqrt{\\lambda(m_1^2,0,0)}}{2m_1} = \\frac{m_1}{2}$. Their energies are $E'_{11}=E'_{12}=\\frac{m_1}{2}$.\n    *   The decay direction is given by $(\\theta_2, \\phi_2)$, defining a unit vector $\\hat{n}_2$. The 3-momenta are $\\vec{p}'_{11} = p'\\hat{n}_2$ and $\\vec{p}'_{12} = -p'\\hat{n}_2$.\n    *   The four-momenta in the rest frame are $p_{11}^{\\prime\\mu} = (m_1/2, \\vec{p}'_{11})$ and $p_{12}^{\\prime\\mu} = (m_1/2, \\vec{p}'_{12})$.\n4.  **Lorentz Boost**: The four-momenta $p_{11}^{\\prime\\mu}$ and $p_{12}^{\\prime\\mu}$ are boosted from the $P_1$ rest frame back to the lab frame. The boost velocity vector is $\\vec{\\beta} = \\vec{p}_1/E_1$. Applying the standard Lorentz transformation yields the lab-frame four-momenta $p_{11}^\\mu$ and $p_{12}^\\mu$.\n5.  **Verification**: The sum of the final-state four-momenta, $p_{final}^\\mu = p_2^\\mu + p_{11}^\\mu + p_{12}^\\mu$, is compared to the initial four-momentum $p_{P_0}^\\mu$. Each component must match within the tolerance of $10^{-9}\\,\\mathrm{GeV}$.\n\n**Model 2: Dipole Recoil Mapping**\n\n1.  **Initial State**: The system's total four-momentum is $P_{init}^\\mu = (Q, 0, 0, 0)$.\n2.  **Emission Construction**: The emitted massless particle $k$ has energy $E_k=|\\vec{k}|$ and its 3-momentum $\\vec{k}$ is constructed from $|\\vec{k}|$, $\\theta_k$, and $\\phi_k$. Its four-momentum is $k^\\mu=(|\\vec{k}|, \\vec{k})$.\n3.  **Recoil Construction**: The two massless recoil partons ($p_1, p_2$) have equal energy $E = (Q-|\\vec{k}|)/2$.\n    *   We compute $\\cos\\alpha = \\frac{|\\vec{k}|}{Q-|\\vec{k}|}$ and $\\sin\\alpha = \\sqrt{1-\\cos^2\\alpha}$.\n    *   A unit vector $\\hat{u}$ orthogonal to the emission direction $\\hat{k}$ is constructed programmatically.\n    *   The recoil direction unit vectors are $\\hat{n}_1 = -\\cos\\alpha\\,\\hat{k} + \\sin\\alpha\\,\\hat{u}$ and $\\hat{n}_2 =-\\cos\\alpha\\,\\hat{k} - \\sin\\alpha\\,\\hat{u}$.\n    *   The recoil four-momenta are $p_1^\\mu = (E, E\\hat{n}_1)$ and $p_2^\\mu = (E, E\\hat{n}_2)$.\n4.  **Verification**: The sum of the final four-momenta, $p_{final}^\\mu = k^\\mu + p_1^\\mu + p_2^\\mu$, is compared to the initial four-momentum $P_{init}^\\mu$.\n\nThe implementation will show that conservation holds for all test cases, as the kinematics are constructed to be exact.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef spherical_to_cartesian(r, theta, phi):\n    \"\"\"Converts spherical coordinates to a Cartesian 3-vector.\"\"\"\n    x = r * np.sin(theta) * np.cos(phi)\n    y = r * np.sin(theta) * np.sin(phi)\n    z = r * np.cos(theta)\n    return np.array([x, y, z])\n\ndef kallen_lambda(a, b, c):\n    \"\"\"Calculates the Källén function lambda(a, b, c).\"\"\"\n    return a**2 + b**2 + c**2 - 2*a*b - 2*a*c - 2*b*c\n\ndef lorentz_boost(p_prime, beta_vec):\n    \"\"\"\n    Boosts a 4-vector p_prime from a frame moving with velocity beta_vec.\n    p_prime: 4-vector (E', p'_x, p'_y, p'_z) in the moving frame.\n    beta_vec: 3-vector velocity of the moving frame relative to the lab frame.\n    Returns: Boosted 4-vector (E, p_x, p_y, p_z) in the lab frame.\n    \"\"\"\n    beta_sq = np.dot(beta_vec, beta_vec)\n    if beta_sq = 1.0:\n        raise ValueError(\"Velocity must be less than the speed of light (c=1).\")\n    if beta_sq  1e-16:\n        return p_prime\n\n    beta = np.sqrt(beta_sq)\n    gamma = 1.0 / np.sqrt(1.0 - beta_sq)\n    beta_hat = beta_vec / beta\n\n    E_prime = p_prime[0]\n    p_prime_vec = p_prime[1:]\n\n    p_prime_parallel_mag = np.dot(p_prime_vec, beta_hat)\n    p_prime_parallel = p_prime_parallel_mag * beta_hat\n    p_prime_perp = p_prime_vec - p_prime_parallel\n\n    p_parallel_mag_boosted = gamma * (p_prime_parallel_mag + beta * E_prime)\n    p_parallel_boosted = p_parallel_mag_boosted * beta_hat\n    E_boosted = gamma * (E_prime + beta * p_prime_parallel_mag)\n\n    p_vec_boosted = p_parallel_boosted + p_prime_perp\n\n    return np.array([E_boosted, p_vec_boosted[0], p_vec_boosted[1], p_vec_boosted[2]])\n\ndef get_orthogonal_unit_vector(v):\n    \"\"\"Computes a unit vector that is orthogonal to the input 3-vector v.\"\"\"\n    v_norm = np.linalg.norm(v)\n    if v_norm  1e-12:\n        return np.array([1.0, 0.0, 0.0])\n    v_unit = v / v_norm\n\n    if np.abs(v_unit[2])  0.9: \n        fixed_vec = np.array([0.0, 0.0, 1.0])\n    else:\n        fixed_vec = np.array([1.0, 0.0, 0.0])\n    \n    ortho_vec = np.cross(v_unit, fixed_vec)\n    return ortho_vec / np.linalg.norm(ortho_vec)\n\ndef solve_angular_ordered(M, m1, m2, theta1, phi1, theta2, phi2, tol):\n    \"\"\"Solution for the angular-ordered branching case.\"\"\"\n    p_initial = np.array([M, 0.0, 0.0, 0.0])\n    \n    if M = m1 + m2: return False\n    lambda_val = kallen_lambda(M**2, m1**2, m2**2)\n    if lambda_val  0: return False\n    p_star = np.sqrt(lambda_val) / (2 * M)\n\n    E1 = (M**2 + m1**2 - m2**2) / (2 * M)\n    E2 = (M**2 + m2**2 - m1**2) / (2 * M)\n\n    n1_vec = spherical_to_cartesian(1.0, theta1, phi1)\n    p1 = np.concatenate(([E1], p_star * n1_vec))\n    p2 = np.concatenate(([E2], -p_star * n1_vec))\n\n    final_momenta = [p2]\n\n    if m1  1e-12:\n        final_momenta.append(p1)\n    else:\n        p_prime = m1 / 2.0\n        E_prime_daughter = m1 / 2.0\n\n        n2_vec = spherical_to_cartesian(1.0, theta2, phi2)\n        p11_prime = np.concatenate(([E_prime_daughter], p_prime * n2_vec))\n        p12_prime = np.concatenate(([E_prime_daughter], -p_prime * n2_vec))\n    \n        beta_vec_p1 = p1[1:] / p1[0]\n        p11 = lorentz_boost(p11_prime, beta_vec_p1)\n        p12 = lorentz_boost(p12_prime, beta_vec_p1)\n\n        final_momenta.append(p11)\n        final_momenta.append(p12)\n\n    p_final = np.sum(final_momenta, axis=0)\n    return np.all(np.abs(p_final - p_initial)  tol)\n\ndef solve_dipole_recoil(Q, k_mag, theta_k, phi_k, tol):\n    \"\"\"Solution for the dipole recoil mapping case.\"\"\"\n    p_initial = np.array([Q, 0.0, 0.0, 0.0])\n\n    k_vec = spherical_to_cartesian(k_mag, theta_k, phi_k)\n    k_hat = k_vec / k_mag if k_mag  0 else np.array([0., 0., 0.])\n    p_k = np.concatenate(([k_mag], k_vec))\n\n    if Q - k_mag = 0 or k_mag = Q - k_mag: return False\n    \n    E = (Q - k_mag) / 2.0\n    cos_alpha = k_mag / (Q - k_mag)\n    sin_alpha = np.sqrt(1.0 - cos_alpha**2)\n\n    u_hat = get_orthogonal_unit_vector(k_hat)\n    \n    n1_hat = -cos_alpha * k_hat + sin_alpha * u_hat\n    n2_hat = -cos_alpha * k_hat - sin_alpha * u_hat\n    \n    p1 = np.concatenate(([E], E * n1_hat))\n    p2 = np.concatenate(([E], E * n2_hat))\n\n    p_final = p_k + p1 + p2\n    return np.all(np.abs(p_final - p_initial)  tol)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    angular_cases = [\n        (100, 20, 0, 0.6, 1.0, 0.3, 0.4),\n        (50, 49, 0, 0.2, 2.2, 0.1, 1.7),\n        (80, 10, 0, 0.000001, 0.0, 0.0000005, 1.1),\n    ]\n    dipole_cases = [\n        (100, 20, 1.0, 2.4),\n        (100, 1.0, 0.8, 0.5),\n        (100, 49.999, 2.0, 0.1),\n    ]\n\n    tolerance = 1e-9\n    results = []\n\n    for case in angular_cases:\n        result = solve_angular_ordered(*case, tol=tolerance)\n        results.append(result)\n\n    for case in dipole_cases:\n        result = solve_dipole_recoil(*case, tol=tolerance)\n        results.append(result)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once momentum conservation is guaranteed, the next step is to construct a precise and robust recipe, or \"kinematic map,\" that translates the abstract variables of a splitting (like energy fraction $z$ and transverse momentum $p_T$) into concrete four-momenta for the final-state partons. This exercise challenges you to derive the physical phase space boundaries for a modern dipole kinematic map and then test its numerical implementation, particularly in the difficult soft ($z \\to 0$) and collinear ($z \\to 1$) limits where algorithms can become unstable . Successfully completing this demonstrates how showers maintain physical consistency across all kinematic regimes.",
            "id": "3527734",
            "problem": "A final-state time-like parton shower can be modeled using a dipole picture in which two outgoing massless partons with four-momenta denoted by $p_i$ and $p_j$ form a color-connected dipole with invariant mass squared $s = (p_i + p_j)^2$. A collinear emission is represented by a splitting of the emitter $i$ into two massless daughters with four-momenta $p_a$ and $p_b$, while the spectator $j$ is recoiled to a new four-momentum $p_j'$, such that overall four-momentum conservation holds and all outgoing partons remain on their respective mass shells. The splitting is parameterized by an energy-sharing variable $z \\in (0,1)$ and a transverse momentum scale $p_T^2 \\ge 0$ defined with respect to the dipole axis. The mapping must be exact in the sense that it is algebraically consistent in Minkowski space and avoids any spacelike virtualities for all outgoing partons, while also ensuring non-negative energies.\n\nStarting from first principles applicable to computational high-energy physics, namely:\n- The mass-shell condition for a particle with four-momentum $p$ and mass $m$ is $p^2 = m^2$, with $p^2 = p^\\mu p_\\mu$ computed using the Minkowski metric of signature $(+,-,-,-)$.\n- For massless partons, the condition is $p^2 = 0$.\n- Four-momentum conservation requires $p_i + p_j = p_a + p_b + p_j'$.\n- Physical momenta must have non-negative energy components, $p^0 \\ge 0$.\n\nYour tasks are:\n1. Derive, from these principles alone, conditions on the kinematic mapping parameters ensuring that $p_a^2 = p_b^2 = p_j'^2 = 0$, $p_a^0 \\ge 0$, $p_b^0 \\ge 0$, $p_j'^0 \\ge 0$, and $p_i + p_j = p_a + p_b + p_j'$ are simultaneously satisfied, for arbitrary $z \\in (0,1)$ and $p_T^2 \\ge 0$. Express your conditions explicitly in terms of $z$, $p_T^2$, and $s$.\n2. Implement a program that constructs a dipole kinematic map consistent with the derived conditions in the dipole center-of-mass frame. In this frame, use $p_i = (\\sqrt{s}/2, 0, 0, \\sqrt{s}/2)$ and $p_j = (\\sqrt{s}/2, 0, 0, -\\sqrt{s}/2)$, both massless and back-to-back. Use a transverse four-vector $k_T = (0, \\sqrt{p_T^2}, 0, 0)$, which is orthogonal to both $p_i$ and $p_j$ and satisfies $k_T^2 = -p_T^2$. Construct $p_a$, $p_b$, and $p_j'$ in terms of $p_i$, $p_j$, $z$, $p_T^2$, and $k_T$ so that exact momentum conservation and on-shell conditions are satisfied.\n3. Test the numerical stability and physical validity of the dipole map in the extreme energy-sharing limits $z \\to 0$ and $z \\to 1$, as well as at typical and boundary configurations, by checking the following for each test case:\n   - On-shellness: $|p_a^2|$, $|p_b^2|$, and $|p_j'^2|$ are each less than a tolerance proportional to $s$, specifically $\\epsilon_{\\text{mass}} = 10^{-12} \\, s$.\n   - Energy non-negativity: $p_a^0 \\ge -\\epsilon_E$, $p_b^0 \\ge -\\epsilon_E$, $p_j'^0 \\ge -\\epsilon_E$, with $\\epsilon_E = 10^{-12} \\, \\sqrt{s}$.\n   - Exact four-momentum conservation within numerical tolerance: $\\|p_i + p_j - (p_a + p_b + p_j')\\|_2 \\le \\epsilon_{\\text{mom}}$, with $\\epsilon_{\\text{mom}} = 10^{-12} \\, \\sqrt{s}$.\n\nThe quantities $s$ and $p_T^2$ must be expressed in units of $\\mathrm{GeV}^2$, energies in $\\mathrm{GeV}$, and the program must treat all angles implicitly via the transverse construction without introducing any angle variables. The output should be unitless booleans.\n\nUse the following test suite, which is designed to probe typical, boundary, and extreme conditions:\n- Case 1 (typical interior): $s = 10^{4}$, $z = 0.5$, $p_T^2 = 0.5 \\, s \\, z (1 - z)$.\n- Case 2 (near-boundary below): $s = 10^{4}$, $z = 0.5$, $p_T^2 = s \\, z (1 - z) - 10^{-5}$.\n- Case 3 (exact boundary): $s = 10^{4}$, $z = 0.5$, $p_T^2 = s \\, z (1 - z)$.\n- Case 4 (above-boundary invalid): $s = 10^{4}$, $z = 0.5$, $p_T^2 = 1.01 \\, s \\, z (1 - z)$.\n- Case 5 (extreme $z \\to 0$): $s = 10^{4}$, $z = 10^{-12}$, $p_T^2 = 0.9 \\, s \\, z (1 - z)$.\n- Case 6 (extreme $z \\to 1$): $s = 10^{4}$, $z = 1 - 10^{-12}$, $p_T^2 = 0.9 \\, s \\, z (1 - z)$.\n- Case 7 (large scale): $s = 10^{8}$, $z = 0.5$, $p_T^2 = 0.1 \\, s \\, z (1 - z)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each entry is a boolean indicating whether the kinematic map passed all checks for that test case.",
            "solution": "The problem is to derive the kinematic constraints for a dipole parton shower splitting and to implement and test a corresponding kinematic map. The process involves a color-connected pair of massless partons, the emitter $i$ and spectator $j$, which undergo a splitting $i \\to a+b$ with a recoil taken by the spectator, $j \\to j'$. This must be done in a way that respects fundamental physical principles: four-momentum conservation and the on-shell condition for all final-state massless particles, alongside the requirement of non-negative energies.\n\nWe begin by formally deriving the constraints on the kinematic parameters, namely the energy-sharing fraction $z$ and the squared transverse momentum $p_T^2$, from first principles.\n\n### Part 1: Derivation of Kinematic Conditions\n\nWe are given the initial state with two massless partons, $p_i$ and $p_j$, satisfying $p_i^2=0$ and $p_j^2=0$. Their total invariant mass squared is $s=(p_i+p_j)^2 = p_i^2 + p_j^2 + 2p_i \\cdot p_j = 2p_i \\cdot p_j$. The final state consists of three massless partons $p_a$, $p_b$, and $p_j'$, which must satisfy $p_a^2=0$, $p_b^2=0$, and $p_j'^2=0$. The process conserves four-momentum: $p_i+p_j = p_a+p_b+p_j'$.\n\nTo construct the final-state momenta, we need a parameterization in terms of the initial momenta $p_i, p_j$ and the kinematic variables $z$ and $p_T^2$. A general and physically motivated ansatz for a splitting $i \\to a+b$ is to express the daughter momenta as a combination of the parent momentum $p_i$, a transverse component $k_T$, and a correction term proportional to the other dipole leg $p_j$ to maintain the on-shell conditions. We define a transverse four-vector $k_T$ which satisfies $k_T \\cdot p_i = 0$, $k_T \\cdot p_j = 0$, and $k_T^2=-p_T^2$. The proposed parameterization is:\n$$p_a = z p_i + \\alpha p_j + k_T$$\n$$p_b = (1-z) p_i + \\beta p_j - k_T$$\nHere, $z$ represents the energy fraction of parton $a$ in the collinear limit ($p_T^2 \\to 0$). The coefficients $\\alpha$ and $\\beta$ are unknowns to be determined by the on-shell conditions.\n\nNext, we impose the on-shell condition $p_a^2=0$:\n$$p_a^2 = (z p_i + \\alpha p_j + k_T)^2 = z^2 p_i^2 + \\alpha^2 p_j^2 + k_T^2 + 2z\\alpha (p_i \\cdot p_j) + 2z (p_i \\cdot k_T) + 2\\alpha (p_j \\cdot k_T) = 0$$\nUsing the known properties $p_i^2=0$, $p_j^2=0$, $k_T^2=-p_T^2$, $p_i \\cdot k_T=0$, $p_j \\cdot k_T=0$, and $p_i \\cdot p_j = s/2$, the equation simplifies significantly:\n$$0 + 0 - p_T^2 + 2z\\alpha (s/2) + 0 + 0 = 0$$\n$$- p_T^2 + z\\alpha s = 0$$\nSolving for $\\alpha$ yields:\n$$\\alpha = \\frac{p_T^2}{zs}$$\n\nSimilarly, we impose the on-shell condition $p_b^2=0$:\n$$p_b^2 = ((1-z)p_i + \\beta p_j - k_T)^2 = (1-z)^2 p_i^2 + \\beta^2 p_j^2 + k_T^2 + 2(1-z)\\beta (p_i \\cdot p_j) - 2(1-z) (p_i \\cdot k_T) - 2\\beta (p_j \\cdot k_T) = 0$$\nThis simplifies to:\n$$-p_T^2 + (1-z)\\beta s = 0$$\nSolving for $\\beta$ yields:\n$$\\beta = \\frac{p_T^2}{(1-z)s}$$\n\nWith $\\alpha$ and $\\beta$ determined, the momenta $p_a$ and $p_b$ are fully specified:\n$$p_a = z p_i + \\frac{p_T^2}{zs} p_j + k_T$$\n$$p_b = (1-z) p_i + \\frac{p_T^2}{(1-z)s} p_j - k_T$$\n\nNow, we determine the recoiled spectator momentum $p_j'$ using four-momentum conservation:\n$$p_j' = p_i + p_j - (p_a + p_b)$$\nSubstituting the expressions for $p_a$ and $p_b$:\n$$p_j' = p_i + p_j - \\left( \\left(z p_i + \\frac{p_T^2}{zs} p_j + k_T\\right) + \\left((1-z) p_i + \\frac{p_T^2}{(1-z)s} p_j - k_T\\right) \\right)$$\n$$p_j' = p_i + p_j - \\left( (z+1-z)p_i + \\left(\\frac{p_T^2}{zs} + \\frac{p_T^2}{(1-z)s}\\right)p_j \\right)$$\n$$p_j' = p_i + p_j - p_i - \\frac{p_T^2}{s}\\left(\\frac{1}{z} + \\frac{1}{1-z}\\right)p_j$$\n$$p_j' = p_j - \\frac{p_T^2}{s}\\left(\\frac{1-z+z}{z(1-z)}\\right)p_j$$\n$$p_j' = \\left( 1 - \\frac{p_T^2}{s z(1-z)} \\right) p_j$$\nThis remarkably simple form for the recoiled spectator momentum ensures that its on-shell condition $p_j'^2=0$ is automatically satisfied, since $p_j'^2 = (\\text{scalar factor})^2 p_j^2$ and $p_j^2=0$.\n\nFinally, we must enforce the condition that all final-state particles have non-negative energies ($p^0 \\ge 0$). We evaluate the energy components in the specified dipole center-of-mass frame:\n$$p_i = (\\sqrt{s}/2, 0, 0, \\sqrt{s}/2)$$\n$$p_j = (\\sqrt{s}/2, 0, 0, -\\sqrt{s}/2)$$\n$$k_T = (0, \\sqrt{p_T^2}, 0, 0)$$\nThe energy components are:\n$$p_a^0 = z p_i^0 + \\frac{p_T^2}{zs} p_j^0 + k_T^0 = z \\frac{\\sqrt{s}}{2} + \\frac{p_T^2}{zs} \\frac{\\sqrt{s}}{2} + 0 = \\frac{\\sqrt{s}}{2} \\left( z + \\frac{p_T^2}{zs} \\right)$$\n$$p_b^0 = (1-z) p_i^0 + \\frac{p_T^2}{(1-z)s} p_j^0 - k_T^0 = (1-z) \\frac{\\sqrt{s}}{2} + \\frac{p_T^2}{(1-z)s} \\frac{\\sqrt{s}}{2} - 0 = \\frac{\\sqrt{s}}{2} \\left( 1-z + \\frac{p_T^2}{(1-z)s} \\right)$$\n$$p_j'^0 = \\left( 1 - \\frac{p_T^2}{s z(1-z)} \\right) p_j^0 = \\frac{\\sqrt{s}}{2} \\left( 1 - \\frac{p_T^2}{s z(1-z)} \\right)$$\nGiven that $s0$, $z \\in (0,1)$, and $p_T^2 \\ge 0$, the expressions for $p_a^0$ and $p_b^0$ are manifestly non-negative sums of non-negative terms. The only non-trivial constraint arises from requiring $p_j'^0 \\ge 0$:\n$$\\frac{\\sqrt{s}}{2} \\left( 1 - \\frac{p_T^2}{s z(1-z)} \\right) \\ge 0$$\nSince $\\sqrt{s}/2  0$, this implies:\n$$1 - \\frac{p_T^2}{s z(1-z)} \\ge 0$$\n$$\\implies p_T^2 \\le s z(1-z)$$\n\nIn summary, for a physically valid kinematic mapping with parameters $z \\in (0,1)$ and $p_T^2 \\ge 0$, the following condition must be satisfied:\n$$0 \\le p_T^2 \\le s z(1-z)$$\nThis defines the accessible phase space for the emission.\n\n### Part 2: Implementation and Testing\nThe program will implement the derived kinematic map and subject it to a series of tests specified in the problem statement. A function will construct the final-state four-momenta $p_a, p_b, p_j'$ based on the input parameters $s, z, p_T^2$. These momenta will then be validated against three criteria: on-shellness, non-negative energy, and four-momentum conservation, all within specified numerical tolerances. The results of these checks for each test case will determine the final boolean output. Case 4, where $p_T^2  s z(1-z)$, is expected to fail the energy non-negativity test for $p_j'$, confirming the validity of our derived boundary. All other cases are constructed to be within or on the boundary of the physical phase space and are expected to pass the checks, testing the numerical stability of the implementation, particularly in the soft ($z \\to 0$) and collinear ($z \\to 1$) limits.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the dipole kinematic map tests.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: typical interior\n        {'s': 1e4, 'z': 0.5, 'pT2': 0.5 * 1e4 * 0.5 * (1 - 0.5)},\n        # Case 2: near-boundary below\n        {'s': 1e4, 'z': 0.5, 'pT2': 1e4 * 0.5 * (1 - 0.5) - 1e-5},\n        # Case 3: exact boundary\n        {'s': 1e4, 'z': 0.5, 'pT2': 1e4 * 0.5 * (1 - 0.5)},\n        # Case 4: above-boundary invalid\n        {'s': 1e4, 'z': 0.5, 'pT2': 1.01 * 1e4 * 0.5 * (1 - 0.5)},\n        # Case 5: extreme z - 0\n        {'s': 1e4, 'z': 1e-12, 'pT2': 0.9 * 1e4 * 1e-12 * (1 - 1e-12)},\n        # Case 6: extreme z - 1\n        {'s': 1e4, 'z': 1.0 - 1e-12, 'pT2': 0.9 * 1e4 * (1.0 - 1e-12) * (1 - (1.0 - 1e-12))},\n        # Case 7: large scale\n        {'s': 1e8, 'z': 0.5, 'pT2': 0.1 * 1e8 * 0.5 * (1 - 0.5)},\n    ]\n\n    results = []\n    for case in test_cases:\n        s, z, pT2 = case['s'], case['z'], case['pT2']\n        \n        # Perform the kinematic test for the current case\n        passed = test_kinematic_map(s, z, pT2)\n        results.append(passed)\n\n    # Format and print the final output as a single-line string.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef dot_product(p1, p2):\n    \"\"\"\n    Computes the Minkowski dot product of two four-vectors.\n    Metric signature is (+, -, -, -).\n    \"\"\"\n    return p1[0] * p2[0] - p1[1] * p2[1] - p1[2] * p2[2] - p1[3] * p2[3]\n\ndef mass_sq(p):\n    \"\"\"Computes the squared invariant mass of a four-vector.\"\"\"\n    return dot_product(p, p)\n\ndef construct_kinematic_map(s, z, pT2):\n    \"\"\"\n    Constructs the final-state four-momenta for a dipole splitting.\n    \n    Args:\n        s (float): Invariant mass squared of the dipole.\n        z (float): Energy sharing fraction.\n        pT2 (float): Transverse momentum squared of the emission.\n        \n    Returns:\n        tuple: A tuple containing the four-momenta of the initial state (p_i, p_j)\n               and final state (p_a, p_b, p_j_prime).\n    \"\"\"\n    sqrt_s = np.sqrt(s)\n    E_cm_half = sqrt_s / 2.0\n    \n    # Define initial state momenta in the CM frame\n    p_i = np.array([E_cm_half, 0.0, 0.0, E_cm_half])\n    p_j = np.array([E_cm_half, 0.0, 0.0, -E_cm_half])\n    \n    # Define the transverse vector. Handle pT2  0 case for safety, though not expected by givens.\n    pT = np.sqrt(max(0, pT2))\n    k_T = np.array([0.0, pT, 0.0, 0.0])\n\n    # Calculate coefficients for the kinematic map based on the derivation\n    alpha = pT2 / (z * s)\n    beta = pT2 / ((1.0 - z) * s)\n    \n    # Construct final state momenta\n    p_a = z * p_i + alpha * p_j + k_T\n    p_b = (1.0 - z) * p_i + beta * p_j - k_T\n    \n    # The recoil factor for p_j' can lead to precision loss if pT2 is very close\n    # to the kinematic limit. Reconstructing from conservation is more robust for tests.\n    p_j_prime_reco = p_i + p_j - (p_a + p_b)\n\n    return p_i, p_j, p_a, p_b, p_j_prime_reco\n\n\ndef test_kinematic_map(s, z, pT2):\n    \"\"\"\n    Tests the physical validity of the kinematic map for a given set of parameters.\n    \n    Args:\n        s (float): Invariant mass squared of the dipole.\n        z (float): Energy sharing fraction.\n        pT2 (float): Transverse momentum squared of the emission.\n        \n    Returns:\n        bool: True if all checks pass, False otherwise.\n    \"\"\"\n    sqrt_s = np.sqrt(s)\n\n    # Define numerical tolerances\n    eps_mass = 1e-12 * s\n    eps_E = 1e-12 * sqrt_s\n    eps_mom = 1e-12 * sqrt_s\n    \n    # The derived condition for physical kinematics\n    kinematic_limit = s * z * (1 - z)\n    \n    # If pT2 is clearly unphysical, fail early. This is primarily for the energy check.\n    # The code must still be able to handle this case numerically.\n    # Note: pT2 can be slightly above the limit due to float precision issues\n    # in the test case definitions. The energy check is the ultimate arbiter.\n    \n    # Construct the momenta\n    p_i, p_j, p_a, p_b, p_j_prime = construct_kinematic_map(s, z, pT2)\n\n    # 1. On-shellness check\n    # Check that final state particles are on their mass shell (m=0)\n    check_a_mass = np.abs(mass_sq(p_a))  eps_mass\n    check_b_mass = np.abs(mass_sq(p_b))  eps_mass\n    check_j_mass = np.abs(mass_sq(p_j_prime))  eps_mass\n    \n    # 2. Energy non-negativity check\n    # The tolerance eps_E allows for small negative values from floating-point errors.\n    check_a_E = p_a[0] = -eps_E\n    check_b_E = p_b[0] = -eps_E\n    check_j_E = p_j_prime[0] = -eps_E\n    \n    # 3. Four-momentum conservation check\n    p_initial = p_i + p_j\n    p_final = p_a + p_b + p_j_prime\n    mom_diff_vec = p_initial - p_final\n    # The problem specifies the L2 norm of the difference 4-vector.\n    check_mom_cons = np.linalg.norm(mom_diff_vec) = eps_mom\n\n    # The case passes only if all checks are satisfied\n    all_checks_passed = all([\n        check_a_mass, check_b_mass, check_j_mass,\n        check_a_E, check_b_E, check_j_E,\n        check_mom_cons\n    ])\n    \n    # Un-comment the following block to debug individual checks for a failing case.\n    # if not all_checks_passed:\n    #     print(f\"\\n--- FAILED CASE: s={s}, z={z}, pT2={pT2} ---\")\n    #     print(f\"pT2_limit = {kinematic_limit}\")\n    #     print(f\"Mass checks (a, b, j'): {check_a_mass}, {check_b_mass}, {check_j_mass}\")\n    #     print(f\"  Values: p_a^2={mass_sq(p_a)}, p_b^2={mass_sq(p_b)}, p_j'^2={mass_sq(p_j_prime)}\")\n    #     print(f\"Energy checks (a, b, j'): {check_a_E}, {check_b_E}, {check_j_E}\")\n    #     print(f\"  Values: E_a={p_a[0]}, E_b={p_b[0]}, E_j'={p_j_prime[0]}\")\n    #     print(f\"Momentum conservation check: {check_mom_cons}\")\n    #     print(f\"  Value: ||diff|| = {np.linalg.norm(mom_diff_vec)}\")\n    #     print(f\"Tolerances: eps_mass={eps_mass}, eps_E={eps_E}, eps_mom={eps_mom}\")\n    \n    return all_checks_passed\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "A parton shower is not just a sequence of kinematic splits, but a Monte Carlo simulation governed by the laws of quantum probability. This final practice takes you inside the probabilistic engine of the shower: the veto algorithm. You will derive the analytical \"no-emission probability,\" or Sudakov form factor, and then verify it by simulating the veto algorithm and constructing two different statistical estimators . This provides a deep, hands-on understanding of how the abstract quantum mechanical probabilities of parton emissions are realized as a concrete and efficient computational process.",
            "id": "3527761",
            "problem": "Consider a single, time-like parton evolution variable $t$ ordered from an initial scale $t_0$ down to a cutoff $t_{\\min}$, in a Markovian parton shower. The fundamental base is the representation of emissions as an inhomogeneous Poisson process with instantaneous intensity (hazard) $\\lambda_{\\text{true}}(t)$ along the ordered evolution. The no-emission probability, also called the Sudakov form factor, is defined by the standard formula\n$$\n\\Delta(t) = \\exp\\!\\left(-\\int_{t}^{t_0} \\lambda_{\\text{true}}(t')\\, dt'\\right),\n$$\nwhich is the probability that zero points of the inhomogeneous Poisson process occur in the interval $[t, t_0]$.\n\nIn the veto algorithm used in parton shower Monte Carlo, one introduces an overestimate intensity $\\lambda_{\\text{over}}(t)$ such that $\\lambda_{\\text{true}}(t) \\le \\lambda_{\\text{over}}(t)$ for all $t \\in [t_{\\min}, t_0]$, and generates proposal points according to $\\lambda_{\\text{over}}(t)$. Each proposal at scale $t_i$ is accepted with probability $p(t_i) = \\lambda_{\\text{true}}(t_i)/\\lambda_{\\text{over}}(t_i)$, otherwise vetoed (rejected). The accepted proposals define the thinned point process that reproduces the true emission distribution.\n\nYour tasks are:\n\n1. Starting from the definition of the Sudakov form factor, derive $\\Delta(t_{\\min})$ for the specific true intensity\n$$\n\\lambda_{\\text{true}}(t) = \\frac{A + B\\, t}{t}\n$$\nwith fixed real parameters $A \\ge 0$ and $B \\ge 0$, for $t \\in [t_{\\min}, t_0]$. Express your final formula for $\\Delta(t_{\\min})$ in terms of $A$, $B$, $t_0$, and $t_{\\min}$.\n\n2. Using the thinning representation of the veto algorithm with overestimate intensity\n$$\n\\lambda_{\\text{over}}(t) = \\frac{C_{\\text{over}}}{t},\n$$\nderive two unbiased Monte Carlo estimators for $\\Delta(t_{\\min})$:\n   - A product-of-rejections estimator,\n     $$\n     \\hat{\\Delta}_{\\Pi} = \\left\\langle \\prod_{i=1}^{N_{\\text{prop}}} \\bigl(1 - p(t_i)\\bigr) \\right\\rangle,\n     $$\n     where $t_i$ are proposal scales generated according to $\\lambda_{\\text{over}}(t)$ in $[t_{\\min}, t_0]$, $p(t_i) = \\lambda_{\\text{true}}(t_i)/\\lambda_{\\text{over}}(t_i)$, and $N_{\\text{prop}}$ is the (random) number of proposals generated in the interval.\n   - A zero-acceptance indicator estimator,\n     $$\n     \\hat{\\Delta}_0 = \\left\\langle \\mathbb{I}\\{N_{\\text{acc}} = 0\\} \\right\\rangle,\n     $$\n     where $N_{\\text{acc}}$ is the number of accepted proposals in $[t_{\\min}, t_0]$ under thinning with acceptance probability $p(t_i)$ and $\\mathbb{I}\\{\\cdot\\}$ is the indicator function.\n\n3. Implement a complete, runnable program that:\n   - Simulates $N$ independent evolution intervals for each test case by generating proposal scales $t_i$ from $\\lambda_{\\text{over}}(t)$ from $t_0$ down to $t_{\\min}$, using a statistically correct method. For numerical stability, you may reparameterize the evolution variable as $u = \\ln t$, and note that proposal generation in $u$ becomes homogeneous.\n   - For each evolution interval, computes the product $\\prod_i (1 - p(t_i))$ and the zero-acceptance indicator $\\mathbb{I}\\{N_{\\text{acc}} = 0\\}$ with $p(t_i) = \\min\\!\\left( \\frac{A + B\\, t_i}{C_{\\text{over}}},\\, 1 \\right)$.\n   - Estimates the sampling mean and sampling standard error (standard deviation of the sample mean) of $\\hat{\\Delta}_{\\Pi}$ and $\\hat{\\Delta}_0$ across the $N$ intervals via the sample variance.\n   - Compares each estimator to the analytic $\\Delta(t_{\\min})$ from part 1 and reports whether the absolute difference is less than or equal to $3$ times its estimated sampling standard error. For each test case, produce two boolean results: one for $\\hat{\\Delta}_{\\Pi}$ and one for $\\hat{\\Delta}_0$.\n   - Uses the following test suite, which covers a constant-intensity case, a $t$-dependent intensity case saturating the overestimate, and a boundary case with zero true intensity:\n     - Case $1$: $t_0 = 1.0$, $t_{\\min} = 10^{-3}$, $A = 0.5$, $B = 0.0$, $C_{\\text{over}} = 1.0$, $N = 100000$.\n     - Case $2$: $t_0 = 1.0$, $t_{\\min} = 10^{-3}$, $A = 0.4$, $B = 0.5$, $C_{\\text{over}} = 0.9$, $N = 120000$.\n     - Case $3$: $t_0 = 10^{-2}$, $t_{\\min} = 10^{-3}$, $A = 0.0$, $B = 0.0$, $C_{\\text{over}} = 0.3$, $N = 80000$.\n\n4. Final output format specification:\n   - Your program should produce a single line of output containing the six boolean results as a comma-separated list enclosed in square brackets, ordered as\n     $$\n     [\\text{Case1-}\\hat{\\Delta}_{\\Pi},\\, \\text{Case1-}\\hat{\\Delta}_0,\\, \\text{Case2-}\\hat{\\Delta}_{\\Pi},\\, \\text{Case2-}\\hat{\\Delta}_0,\\, \\text{Case3-}\\hat{\\Delta}_{\\Pi},\\, \\text{Case3-}\\hat{\\Delta}_0].\n     $$\n\nAngles, physical units, and percentages do not appear in this problem. All quantities are dimensionless. The verification criterion for each boolean is whether $\\left|\\hat{\\Delta} - \\Delta(t_{\\min})\\right| \\le 3\\, \\sigma_{\\hat{\\Delta}}$, where $\\sigma_{\\hat{\\Delta}}$ is the estimated sampling standard error of the corresponding Monte Carlo estimator. The program must be self-contained, require no input, and adhere to the specified runtime environment.",
            "solution": "The problem is well-posed, scientifically sound, and internally consistent. We proceed with the solution, which consists of three parts: an analytical derivation, a theoretical justification of the Monte Carlo estimators, and a numerical implementation to verify the results.\n\nThe problem revolves around the simulation of a time-like parton evolution, modeled as an inhomogeneous Poisson process over an evolution variable $t \\in [t_{\\min}, t_0]$. The instantaneous rate of this process is given by $\\lambda_{\\text{true}}(t)$. The probability of no emissions occurring between a starting scale $t_0$ and a lower scale $t$ is the Sudakov form factor, $\\Delta(t)$.\n\n**Part 1: Analytical Calculation of the Sudakov Form Factor**\n\nThe Sudakov form factor is defined as:\n$$\n\\Delta(t) = \\exp\\left(-\\int_{t}^{t_0} \\lambda_{\\text{true}}(t')\\, dt'\\right)\n$$\nWe are asked to compute $\\Delta(t_{\\min})$ for the specific true intensity function:\n$$\n\\lambda_{\\text{true}}(t) = \\frac{A + B\\, t}{t}\n$$\nwhere $A \\ge 0$ and $B \\ge 0$ are constants.\n\nFirst, we evaluate the definite integral in the exponent, which we denote as $I$:\n$$\nI = \\int_{t_{\\min}}^{t_0} \\lambda_{\\text{true}}(t')\\, dt' = \\int_{t_{\\min}}^{t_0} \\frac{A + B\\, t'}{t'}\\, dt'\n$$\nThe integrand can be separated into two terms:\n$$\nI = \\int_{t_{\\min}}^{t_0} \\left( \\frac{A}{t'} + B \\right) dt'\n$$\nPerforming the integration yields:\n$$\nI = \\left[ A \\ln|t'| + B t' \\right]_{t_{\\min}}^{t_0}\n$$\nSince the evolution variable $t$ is positive ($t_{\\min}  0$), we can drop the absolute value:\n$$\nI = (A \\ln(t_0) + B t_0) - (A \\ln(t_{\\min}) + B t_{\\min})\n$$\nGrouping terms by the constants $A$ and $B$:\n$$\nI = A (\\ln(t_0) - \\ln(t_{\\min})) + B (t_0 - t_{\\min})\n$$\nUsing the property of logarithms, $\\ln(x) - \\ln(y) = \\ln(x/y)$, we get:\n$$\nI = A \\ln\\left(\\frac{t_0}{t_{\\min}}\\right) + B (t_0 - t_{\\min})\n$$\nSubstituting this integral back into the definition of the Sudakov form factor gives the final analytical expression for $\\Delta(t_{\\min})$:\n$$\n\\Delta(t_{\\min}) = \\exp(-I) = \\exp\\left( -A \\ln\\left(\\frac{t_0}{t_{\\min}}\\right) - B (t_0 - t_{\\min}) \\right)\n$$\nThis formula can also be written in the form:\n$$\n\\Delta(t_{\\min}) = \\left(\\frac{t_0}{t_{\\min}}\\right)^{-A} \\exp(-B (t_0 - t_{\\min}))\n$$\n\n**Part 2: Derivation of Unbiased Monte Carlo Estimators**\n\nThe veto algorithm generates events for a process with intensity $\\lambda_{\\text{true}}(t)$ by thinning a proposal stream generated from an easier-to-sample overestimate process with intensity $\\lambda_{\\text{over}}(t) \\ge \\lambda_{\\text{true}}(t)$. An accepted emission from the thinning procedure is a point of the true Poisson process.\n\n**Estimator $\\hat{\\Delta}_0 = \\left\\langle \\mathbb{I}\\{N_{\\text{acc}} = 0\\} \\right\\rangle$ (Zero-Acceptance Indicator)**\n\nBy definition, $\\Delta(t_{\\min})$ is the probability that the number of true emissions, $N_{\\text{emissions}}$, in the interval $[t_{\\min}, t_0]$ is zero. The number of accepted proposals from the veto algorithm, $N_{\\text{acc}}$, in this interval follows the same distribution as $N_{\\text{emissions}}$. Specifically, $N_{\\text{acc}}$ is a Poisson-distributed random variable with mean $\\mu_{\\text{acc}} = \\int_{t_{\\min}}^{t_0} \\lambda_{\\text{true}}(t') dt'$.\n\nThe probability of observing $N_{\\text{acc}} = 0$ is given by the Poisson probability for zero events:\n$$\nP(N_{\\text{acc}} = 0) = \\frac{\\mu_{\\text{acc}}^0 e^{-\\mu_{\\text{acc}}}}{0!} = e^{-\\mu_{\\text{acc}}} = \\exp\\left(-\\int_{t_{\\min}}^{t_0} \\lambda_{\\text{true}}(t') dt'\\right) = \\Delta(t_{\\min})\n$$\nThe expectation of the indicator function $\\mathbb{I}\\{N_{\\text{acc}} = 0\\}$ is, by definition, the probability of the event it indicates:\n$$\n\\left\\langle \\mathbb{I}\\{N_{\\text{acc}} = 0\\} \\right\\rangle = P(N_{\\text{acc}} = 0) = \\Delta(t_{\\min})\n$$\nTherefore, $\\hat{\\Delta}_0$ is an unbiased estimator of $\\Delta(t_{\\min})$. A Monte Carlo estimate is obtained by averaging the value of $\\mathbb{I}\\{N_{\\text{acc}} = 0\\}$ over many independent simulations.\n\n**Estimator $\\hat{\\Delta}_{\\Pi} = \\left\\langle \\prod_{i=1}^{N_{\\text{prop}}} \\bigl(1 - p(t_i)\\bigr) \\right\\rangle$ (Product-of-Rejections)**\n\nThis estimator's unbiasedness can be shown using the properties of Poisson point processes. The proposal scales $\\{t_i\\}$ form a Poisson point process with intensity $\\lambda_{\\text{over}}(t)$. For any function $g(t)$, the expectation of the product $\\prod_i g(t_i)$ over all points of a Poisson process with rate $\\lambda(t)$ in an interval $[a,b]$ is given by its characteristic functional:\n$$\n\\mathbb{E}\\left[ \\prod_{i} g(t_i) \\right] = \\exp\\left( \\int_a^b (g(t)-1) \\lambda(t) dt \\right)\n$$\nIn our case, the process is the proposal process on $[t_{\\min}, t_0]$, so $\\lambda(t) = \\lambda_{\\text{over}}(t)$. The function being multiplied is $g(t_i) = 1 - p(t_i)$, where $p(t_i) = \\lambda_{\\text{true}}(t_i)/\\lambda_{\\text{over}}(t_i)$ is the acceptance probability.\nSubstituting these into the formula:\n$$\n\\hat{\\Delta}_{\\Pi} = \\mathbb{E}\\left[ \\prod_{i=1}^{N_{\\text{prop}}} \\left(1 - \\frac{\\lambda_{\\text{true}}(t_i)}{\\lambda_{\\text{over}}(t_i)}\\right) \\right]\n= \\exp\\left( \\int_{t_{\\min}}^{t_0} \\left( \\left(1 - \\frac{\\lambda_{\\text{true}}(t')}{\\lambda_{\\text{over}}(t')}\\right) - 1 \\right) \\lambda_{\\text{over}}(t') dt' \\right)\n$$\nThe term inside the integral simplifies:\n$$\n\\left( 1 - \\frac{\\lambda_{\\text{true}}(t')}{\\lambda_{\\text{over}}(t')} - 1 \\right) \\lambda_{\\text{over}}(t') = \\left( - \\frac{\\lambda_{\\text{true}}(t')}{\\lambda_{\\text{over}}(t')} \\right) \\lambda_{\\text{over}}(t') = - \\lambda_{\\text{true}}(t')\n$$\nThus, the expectation becomes:\n$$\n\\hat{\\Delta}_{\\Pi} = \\exp\\left( - \\int_{t_{\\min}}^{t_0} \\lambda_{\\text{true}}(t') dt' \\right) = \\Delta(t_{\\min})\n$$\nThis shows that $\\hat{\\Delta}_{\\Pi}$ is also an unbiased estimator of $\\Delta(t_{\\min})$. Each simulation trial produces a weight, and the average of these weights over many trials converges to the true Sudakov form factor.\n\n**Part 3: Monte Carlo Simulation Strategy**\n\nThe implementation will follow the derived principles to numerically estimate $\\Delta(t_{\\min})$ and verify the estimators.\n\n**Generation of Proposal Scales:** The proposal intensity is $\\lambda_{\\text{over}}(t) = C_{\\text{over}}/t$. Generating sequential emissions can be slow. A more efficient method is to reparameterize the evolution variable. Let $u = \\ln t$. The evolution from $t_0$ down to $t_{\\min}$ corresponds to evolution from $u_0 = \\ln t_0$ down to $u_{\\min} = \\ln t_{\\min}$. The intensity measure transforms as $d\\mu = \\lambda(t) dt$. In the new variable $u$, the intensity becomes $\\lambda_u(u) = \\lambda_t(t(u)) |dt/du| = (C_{\\text{over}}/e^u) \\cdot e^u = C_{\\text{over}}$.\nThe proposal process in the $u$ variable is a homogeneous Poisson process with a constant rate $C_{\\text{over}}$ over the interval $[u_{\\min}, u_0]$. This can be simulated efficiently:\n1.  Calculate the mean number of proposals: $\\mu_{\\text{prop}} = C_{\\text{over}} (u_0 - u_{\\min}) = C_{\\text{over}} \\ln(t_0/t_{\\min})$.\n2.  Draw the actual number of proposals, $N_{\\text{prop}}$, for a given trial from a Poisson distribution with mean $\\mu_{\\text{prop}}$.\n3.  Generate $N_{\\text{prop}}$ values $u_i$ uniformly distributed in the interval $[u_{\\min}, u_0]$.\n4.  Transform back to the original variable: $t_i = \\exp(u_i)$.\n\n**Calculation of Estimators:** For each of the $N$ independent trials:\n1.  A set of proposal scales $\\{t_i\\}_{i=1}^{N_{\\text{prop}}}$ is generated as described above.\n2.  The acceptance probability for each proposal is calculated as $p(t_i) = (A + B t_i) / C_{\\text{over}}$. The problem provides $p(t_i) = \\min\\!\\left( \\frac{A + B\\, t_i}{C_{\\text{over}}},\\, 1 \\right)$, but since $A + Bt \\le C_{\\text{over}}$ is guaranteed for all test cases and $t \\in [t_{\\min}, t_0]$, the $\\min$ operation is redundant.\n3.  The trial's value for the $\\hat{\\Delta}_{\\Pi}$ estimator is $V_{\\Pi} = \\prod_{i=1}^{N_{\\text{prop}}} (1 - p(t_i))$.\n4.  To get the trial's value for the $\\hat{\\Delta}_0$ estimator, we simulate the thinning: for each proposal $t_i$, generate a uniform random number $r_i \\in [0,1)$ and accept if $r_i  p(t_i)$. We count the total number of accepted proposals, $N_{\\text{acc}}$. The estimator value is $V_0 = \\mathbb{I}\\{N_{\\text{acc}}=0\\}$, which is $1$ if $N_{\\text{acc}}=0$ and $0$ otherwise.\n\n**Statistical Analysis:** After $N$ trials, we obtain two sets of results, $\\{V_{\\Pi,j}\\}_{j=1}^N$ and $\\{V_{0,j}\\}_{j=1}^N$.\nFor each estimator $\\hat{\\Delta}$ (representing either $\\hat{\\Delta}_{\\Pi}$ or $\\hat{\\Delta}_0$), we compute:\n- The sample mean: $\\bar{V} = \\frac{1}{N} \\sum_{j=1}^N V_j$. This is our numerical estimate for $\\Delta(t_{\\min})$.\n- The sample standard deviation: $s = \\sqrt{\\frac{1}{N-1} \\sum_{j=1}^N (V_j - \\bar{V})^2}$.\n- The sampling standard error of the mean: $\\sigma_{\\bar{V}} = s / \\sqrt{N}$.\n\nThe final verification step is to check if the analytical value $\\Delta(t_{\\min})$ lies within $3$ standard errors of the estimated mean, i.e., whether $|\\bar{V} - \\Delta(t_{\\min})| \\le 3 \\sigma_{\\bar{V}}$. This is a standard statistical test for consistency, where a result within $3\\sigma$ is generally considered compatible. A boolean value (`True` or `False`) will be reported for each estimator in each test case.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (t0, t_min, A, B, C_over, N)\n        (1.0, 1e-3, 0.5, 0.0, 1.0, 100000),\n        (1.0, 1e-3, 0.4, 0.5, 0.9, 120000),\n        (1e-2, 1e-3, 0.0, 0.0, 0.3, 80000),\n    ]\n\n    all_results = []\n    # A fixed seed ensures reproducibility of the Monte Carlo simulation.\n    seed = 12345\n    rng = np.random.default_rng(seed)\n\n    for i, case in enumerate(test_cases):\n        t0, t_min, A, B, C_over, N = case\n        \n        # 1. Analytical Sudakov calculation\n        log_ratio = np.log(t0 / t_min)\n        t_diff = t0 - t_min\n        integral_val = A * log_ratio + B * t_diff\n        delta_analytic = np.exp(-integral_val)\n\n        # 2. Monte Carlo simulation setup\n        u0 = np.log(t0)\n        u_min = np.log(t_min)\n        # Mean number of proposals in u-space for a homogeneous Poisson process\n        mu_prop = C_over * (u0 - u_min)\n\n        pi_estimator_values = np.zeros(N)\n        zero_estimator_values = np.zeros(N)\n\n        for j in range(N):\n            # Generate number of proposals from Poisson distribution\n            N_prop = rng.poisson(mu_prop)\n\n            if N_prop == 0:\n                pi_estimator_values[j] = 1.0\n                zero_estimator_values[j] = 1.0\n            else:\n                # Generate proposal locations in u-space (uniform)\n                u_proposals = rng.uniform(u_min, u0, size=N_prop)\n                # Transform back to t-space\n                t_proposals = np.exp(u_proposals)\n                \n                # Acceptance probabilities for each proposal\n                # The min(..., 1) is not strictly needed due to problem constraints\n                # but included for robustness.\n                p_values = np.minimum((A + B * t_proposals) / C_over, 1.0)\n                \n                # Estimator 1: Product of rejections\n                pi_estimator_values[j] = np.prod(1.0 - p_values)\n                \n                # Estimator 2: Zero acceptances\n                # Perform thinning to find number of accepted proposals\n                accept_rolls = rng.uniform(0.0, 1.0, size=N_prop)\n                N_acc = np.sum(accept_rolls  p_values)\n                zero_estimator_values[j] = 1.0 if N_acc == 0 else 0.0\n        \n        # 3. Statistical analysis and verification\n        # For pi_estimator\n        mean_pi = np.mean(pi_estimator_values)\n        std_pi = np.std(pi_estimator_values, ddof=1)\n        sem_pi = std_pi / np.sqrt(N)\n        \n        # Handle the case where standard error is zero (e.g., constant results)\n        if sem_pi  0:\n            is_valid_pi = np.abs(mean_pi - delta_analytic) = 3 * sem_pi\n        else:\n            is_valid_pi = np.isclose(mean_pi, delta_analytic)\n            \n        all_results.append(is_valid_pi)\n        \n        # For zero_estimator\n        mean_zero = np.mean(zero_estimator_values)\n        std_zero = np.std(zero_estimator_values, ddof=1)\n        sem_zero = std_zero / np.sqrt(N)\n\n        if sem_zero  0:\n            is_valid_zero = np.abs(mean_zero - delta_analytic) = 3 * sem_zero\n        else:\n            is_valid_zero = np.isclose(mean_zero, delta_analytic)\n\n        all_results.append(is_valid_zero)\n\n    # 4. Final print statement in the exact required format\n    # The output will be like [True,True,True,True,True,True]\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}