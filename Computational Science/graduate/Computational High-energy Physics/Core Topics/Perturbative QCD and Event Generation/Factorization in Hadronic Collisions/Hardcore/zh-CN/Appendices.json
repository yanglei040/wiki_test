{
    "hands_on_practices": [
        {
            "introduction": "强子对撞中的物理过程本质上是其内部部分子（夸克和胶子）之间的相互作用。因子分解定理为我们提供了一个坚实的理论框架，它将复杂的强子截面 $\\sigma$ 分解为可计算的短程部分子截面 $\\hat{\\sigma}$ 与非微扰的长程部分子分布函数 (PDF) $f(x, \\mu)$ 的卷积。本练习将通过一个简化的模型，指导您从零开始实现这一核心的卷积积分，让您亲手处理在实际计算中常见的、由PDF在小 $x$ 区域的尖锐行为所带来的数值挑战。",
            "id": "3514288",
            "problem": "实现一个完整的程序，根据量子色动力学 (QCD) 中的因子化定理，数值计算强子截面。强子过程的截面由部分子分布函数 (PDF) 与部分子截面的卷积定义。从因子化原理出发，强子截面由关于纵向动量分数的二重积分给出。您必须设计一种在PDF呈尖峰分布时依然稳健的数值积分方法，并验证其收敛性。\n\n您必须使用以下建模假设，这些是适用于计算测试的、科学上合理的近似：\n\n1. 因子化公式定义为\n$$\n\\sigma(s,\\mu) = \\sum_{i,j} \\int_0^1 dx_1 \\int_0^1 dx_2 \\, f_i(x_1,\\mu)\\, f_j(x_2,\\mu) \\, \\hat{\\sigma}_{ij}(x_1 x_2 s, \\mu),\n$$\n其中 $s$ 是强子质心能量平方，$\\mu$ 是因子化标度，$f_i$ 和 $f_j$ 是部分子 $i$ 和 $j$ 的PDF，$\\hat{\\sigma}_{ij}$ 是子过程 $i j \\to X$ 的部分子截面。\n\n2. 模拟两种有效的部分子类型 $i \\in \\{q, g\\}$（夸克和胶子）。每种类型 $i$ 的PDF由一个归一化的类Beta函数形状参数化：\n$$\nf_i(x;\\lambda_i,\\eta_i) = \\mathcal{N}_i(\\lambda_i,\\eta_i)\\, x^{-\\lambda_i}\\, (1-x)^{\\eta_i}, \\quad x \\in (0,1),\n$$\n其中归一化常数 $\\mathcal{N}_i(\\lambda_i,\\eta_i)$ 的选择需满足\n$$\n\\int_0^1 f_i(x;\\lambda_i,\\eta_i)\\,dx = 1.\n$$\n为保证可积性和科学真实性，请强制要求 $\\lambda_i  1$ 和 $\\eta_i  -1$。\n\n3. 使用以下部分子截面：\n   - 夸克-夸克通道 $(q,q)$（类Breit-Wigner共振形状）：\n     $$\n     \\hat{\\sigma}_{qq}(s_{\\mathrm{hat}}; M, \\Gamma, K_{qq}) = K_{qq}\\, \\frac{M \\Gamma}{\\left(s_{\\mathrm{hat}} - M^2\\right)^2 + M^2 \\Gamma^2},\n     $$\n     其值为非负，并在 $s_{\\mathrm{hat}} \\approx M^2$ 附近呈尖峰。\n   - 胶子-胶子通道 $(g,g)$（类阈值连续谱）：\n     $$ \n     \\hat{\\sigma}_{gg}(s_{\\mathrm{hat}}; s_{\\mathrm{thr}}, p, \\sigma_{0,gg}) = \n     \\begin{cases}\n     \\sigma_{0,gg}\\, \\dfrac{\\left(1 - s_{\\mathrm{thr}}/s_{\\mathrm{hat}}\\right)^p}{s_{\\mathrm{hat}}},  s_{\\mathrm{hat}} \\ge s_{\\mathrm{thr}}, \\\\\n     0,  s_{\\mathrm{hat}}  s_{\\mathrm{thr}},\n     \\end{cases}\n     $$\n     其值仅在物理阈值 $s_{\\mathrm{thr}}$ 以上非零，并在 $s_{\\mathrm{hat}}$ 较大时减小。\n\n所有部分子截面均以皮可靶 (pb) 表示，强子截面必须以皮可靶 (pb) 返回和打印。如果出现任何角度量（此处未出现），必须使用弧度。任何地方都不得使用百分比；请将分数公差表示为小数。\n\n您的程序必须：\n- 使用张量积高斯-勒让德积分法在 $[0,1]\\times[0,1]$ 上实现二重积分，其中每个维度的点数 $N$ 可调。\n- 通过比较粗略积分 ($N_{\\mathrm{coarse}}$) 和精细积分 ($N_{\\mathrm{fine}}$) 的结果来验证收敛性，使用相对差异判据\n$$\n\\delta = \\frac{\\left|\\sigma_{N_{\\mathrm{fine}}} - \\sigma_{N_{\\mathrm{coarse}}}\\right|}{\\left|\\sigma_{N_{\\mathrm{fine}}}\\right|} \\le \\text{tol},\n$$\n其中 $\\text{tol}$ 是一个指定的小数公差。返回一个布尔值，指示是否满足收敛判据。\n\n测试套件：\n评估以下四个测试用例。对每个用例，使用精细积分计算强子截面，并报告通过比较粗略与精细积分得到的收敛布尔值。请使用下方的精确参数值。所有能量必须以 $\\mathrm{GeV}$ 为单位处理，截面以 $\\mathrm{pb}$ 为单位，并且您必须以 $\\mathrm{pb}$ 为单位打印最终截面。\n\n- 用例1（理想情况，中等程度尖峰的PDF）：\n  - $s = (13000\\,\\mathrm{GeV})^2$\n  - $\\mu = 91\\,\\mathrm{GeV}$\n  - 夸克 PDF: $\\lambda_q = 0.6$, $\\eta_q = 3.0$\n  - 胶子 PDF: $\\lambda_g = 0.3$, $\\eta_g = 5.0$\n  - 夸克-夸克通道: $M = 91\\,\\mathrm{GeV}$, $\\Gamma = 2.5\\,\\mathrm{GeV}$, $K_{qq} = 1.0\\times 10^4\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 胶子-胶子通道: $s_{\\mathrm{thr}} = (350\\,\\mathrm{GeV})^2$, $p = 2$, $\\sigma_{0,gg} = 1.0\\times 10^5\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 收敛性设置: $N_{\\mathrm{coarse}} = 64$, $N_{\\mathrm{fine}} = 128$, $\\text{tol} = 1.0\\times 10^{-3}$\n\n- 用例2（在 $x \\to 0$ 附近呈尖峰的PDF）：\n  - $s = (13000\\,\\mathrm{GeV})^2$\n  - $\\mu = 50\\,\\mathrm{GeV}$\n  - 夸克 PDF: $\\lambda_q = 0.95$, $\\eta_q = 4.0$\n  - 胶子 PDF: $\\lambda_g = 0.9$, $\\eta_g = 6.0$\n  - 夸克-夸克通道: $M = 91\\,\\mathrm{GeV}$, $\\Gamma = 2.5\\,\\mathrm{GeV}$, $K_{qq} = 1.0\\times 10^4\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 胶子-胶子通道: $s_{\\mathrm{thr}} = (350\\,\\mathrm{GeV})^2$, $p = 2$, $\\sigma_{0,gg} = 1.0\\times 10^5\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 收敛性设置: $N_{\\mathrm{coarse}} = 64$, $N_{\\mathrm{fine}} = 128$, $\\text{tol} = 2.0\\times 10^{-3}$\n\n- 用例3（非常尖锐的PDF和窄共振）：\n  - $s = (13000\\,\\mathrm{GeV})^2$\n  - $\\mu = 20\\,\\mathrm{GeV}$\n  - 夸克 PDF: $\\lambda_q = 0.99$, $\\eta_q = 5.0$\n  - 胶子 PDF: $\\lambda_g = 0.95$, $\\eta_g = 7.0$\n  - 夸克-夸克通道: $M = 91\\,\\mathrm{GeV}$, $\\Gamma = 0.5\\,\\mathrm{GeV}$, $K_{qq} = 1.0\\times 10^4\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 胶子-胶子通道: $s_{\\mathrm{thr}} = (350\\,\\mathrm{GeV})^2$, $p = 3$, $\\sigma_{0,gg} = 1.0\\times 10^5\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 收敛性设置: $N_{\\mathrm{coarse}} = 64$, $N_{\\mathrm{fine}} = 128$, $\\text{tol} = 3.0\\times 10^{-3}$\n\n- 用例4（靠近相空间边界的高质量共振）：\n  - $s = (13000\\,\\mathrm{GeV})^2$\n  - $\\mu = 200\\,\\mathrm{GeV}$\n  - 夸克 PDF: $\\lambda_q = 0.7$, $\\eta_q = 3.0$\n  - 胶子 PDF: $\\lambda_g = 0.5$, $\\eta_g = 5.0$\n  - 夸克-夸克通道: $M = 6000\\,\\mathrm{GeV}$, $\\Gamma = 100\\,\\mathrm{GeV}$, $K_{qq} = 5.0\\times 10^4\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 胶子-胶子通道: $s_{\\mathrm{thr}} = (2000\\,\\mathrm{GeV})^2$, $p = 2$, $\\sigma_{0,gg} = 2.0\\times 10^5\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 收敛性设置: $N_{\\mathrm{coarse}} = 64$, $N_{\\mathrm{fine}} = 128$, $\\text{tol} = 1.0\\times 10^{-3}$\n\n输出规范：\n您的程序必须生成单行输出，其中包含一个由序对组成的列表，每个测试用例对应一个序对。每个序对的形式必须为 $[\\sigma_{\\mathrm{fine}}, \\mathrm{conv\\_ok}]$，其中 $\\sigma_{\\mathrm{fine}}$ 是用 $N_{\\mathrm{fine}}$ 计算出的截面（单位为 $\\mathrm{pb}$，浮点数），$\\mathrm{conv\\_ok}$ 是一个布尔值，指示是否满足收敛判据。最后一行必须严格按照Python列表的列表格式打印，例如：\n$$\n[\\,[\\sigma_1,\\mathrm{True}],[\\sigma_2,\\mathrm{False}],\\ldots\\,].\n$$",
            "solution": "用户提供的问题被认为是有效的。它科学地基于量子色动力学（QCD）的原理，问题定义良好、客观且计算上可行。该问题要求数值计算强子截面，这是计算高能物理中的一项核心任务。所提供的模型虽然是完整QCD的简化，但使用了标准的参数化形式并且内部一致。\n\n目标是计算双部分子模型的强子截面 $\\sigma$，该截面由QCD因子化定理给出。在强子质心能量平方为 $s$ 时的总截面 $\\sigma$ 的公式是所有可能的初始部分子类型 $i, j$ 贡献的总和。对于指定的具有两种有效部分子类型——夸克 ($q$) 和胶子 ($g$) 的模型，部分子集合为 $\\{q, g\\}$。主导表达式为：\n$$\n\\sigma(s) = \\sum_{i,j \\in \\{q,g\\}} \\int_0^1 dx_1 \\int_0^1 dx_2 \\, f_i(x_1)\\, f_j(x_2) \\, \\hat{\\sigma}_{ij}(x_1 x_2 s, \\mu)\n$$\n问题提供了夸克-夸克 $(q,q)$ 和胶子-胶子 $(g,g)$ 通道的模型。混合通道——夸克-胶子 $(q,g)$ 和胶子-夸克 $(g,q)$——定义的省略意味着它们的贡献被视为零，即 $\\hat{\\sigma}_{qg} = \\hat{\\sigma}_{gq} = 0$。这是教学模型中常见且可接受的简化。在此假设下，总截面是两项之和：\n$$\n\\sigma(s) = \\int_0^1 dx_1 \\int_0^1 dx_2 \\, f_q(x_1) f_q(x_2) \\hat{\\sigma}_{qq}(x_1 x_2 s) + \\int_0^1 dx_1 \\int_0^1 dx_2 \\, f_g(x_1) f_g(x_2) \\hat{\\sigma}_{gg}(x_1 x_2 s)\n$$\n需要注意的是，因子化标度 $\\mu$ 虽然在每个测试用例中都已提供，但在问题定义的简化、与标度无关的部分子分布函数 (PDF) $f_i(x)$ 或部分子截面 $\\hat{\\sigma}_{ij}$ 的形式中并未显式出现。因此，根据所提供的模型，$\\mu$ 在计算中不是一个活动参数。\n\nPDF $f_i(x; \\lambda_i, \\eta_i)$ 描述了在父强子中找到携带能量分数 $x$ 的部分子 $i$ 的概率密度，其参数化形式为：\n$$\nf_i(x;\\lambda_i,\\eta_i) = \\mathcal{N}_i(\\lambda_i,\\eta_i)\\, x^{-\\lambda_i}\\, (1-x)^{\\eta_i}\n$$\n对于 $x \\in (0,1)$。归一化常数 $\\mathcal{N}_i$ 由找到该部分子具有任意动量分数的总概率为1的条件固定：\n$$\n\\int_0^1 f_i(x;\\lambda_i,\\eta_i)\\,dx = 1\n$$\n这要求 $\\mathcal{N}_i$ 是未归一化函数积分的倒数。该积分是欧拉Beta函数 $B(a,b)$ 的一种表示：\n$$\n\\int_0^1 x^{-\\lambda_i}\\, (1-x)^{\\eta_i} dx = \\int_0^1 x^{(1-\\lambda_i)-1}\\, (1-x)^{(\\eta_i+1)-1} dx = B(1-\\lambda_i, \\eta_i+1)\n$$\n约束条件 $\\lambda_i  1$ 和 $\\eta_i  -1$ 确保该积分收敛。因此，归一化常数由下式给出：\n$$\n\\mathcal{N}_i(\\lambda_i,\\eta_i) = \\frac{1}{B(1-\\lambda_i, \\eta_i+1)}\n$$\n该常数使用 `scipy.special.beta` 函数计算。\n\n部分子截面 $\\hat{\\sigma}_{ij}(s_{\\mathrm{hat}})$ 描述了在部分子质心能量平方 $s_{\\mathrm{hat}} = x_1 x_2 s$ 下，部分子 $i$ 和 $j$ 之间的基本相互作用。指定的模型是：\n1. 夸克-夸克通道：这通过一个Breit-Wigner共振形状来建模，这是产生不稳定粒子的特征。\n$$\n\\hat{\\sigma}_{qq}(s_{\\mathrm{hat}}; M, \\Gamma, K_{qq}) = K_{qq}\\, \\frac{M \\Gamma}{\\left(s_{\\mathrm{hat}} - M^2\\right)^2 + M^2 \\Gamma^2}\n$$\n2. 胶子-胶子通道：这被建模为运动学阈值 $s_{\\mathrm{thr}}$ 以上的连续谱产生。\n$$\n\\hat{\\sigma}_{gg}(s_{\\mathrm{hat}}; s_{\\mathrm{thr}}, p, \\sigma_{0,gg}) =\n\\begin{cases}\n\\sigma_{0,gg}\\, \\dfrac{\\left(1 - s_{\\mathrm{thr}}/s_{\\mathrm{hat}}\\right)^p}{s_{\\mathrm{hat}}},  s_{\\mathrm{hat}} \\ge s_{\\mathrm{thr}} \\\\\n0,  s_{\\mathrm{hat}}  s_{\\mathrm{thr}}\n\\end{cases}\n$$\n\n二重积分的数值计算是使用张量积高斯-勒让德积分法则进行的。对于单位平方上的一个通用二维积分，该方法给出的近似值为：\n$$\n\\int_0^1 \\int_0^1 G(x_1, x_2) \\,dx_1 dx_2 \\approx \\sum_{k=1}^{N} \\sum_{l=1}^{N} w_k w_l \\, G(p_k, p_l)\n$$\n这里，$\\{p_k\\}_{k=1}^N$ 和 $\\{w_k\\}_{k=1}^N$ 分别是单个维度上在区间 $[0,1]$ 上的积分点（节点）和权重。它们是通过对定义在 $[-1,1]$ 上的标准高斯-勒让德积分元素进行线性变换得到的。如果 $\\{z_k, w'_k\\}$ 是 $[-1,1]$ 上的标准节点和权重，变换 $x = (z+1)/2$ 将它们映射到 $[0,1]$，得到节点 $p_k = (z_k+1)/2$ 和权重 $w_k = w'_k/2$。`numpy.polynomial.legendre.leggauss` 函数用于生成标准节点和权重。\n\n算法如下：\n1. 对于给定的积分点数 $N$，在区间 $[0,1]$ 上生成节点 $\\{p_k\\}$ 和权重 $\\{w_k\\}$。\n2. 对于每种部分子类型（$q$ 和 $g$），使用指定的参数和预先计算的归一化常数构造PDF函数 $f_q(x)$ 和 $f_g(x)$。\n3. 构造部分子截面函数 $\\hat{\\sigma}_{qq}(s_{\\mathrm{hat}})$ 和 $\\hat{\\sigma}_{gg}(s_{\\mathrm{hat}})$。\n4. 每个通道（例如 $(q,q)$）的积分是通过在所有节点对 $(p_k, p_l)$ 上评估完整的被积函数 $I_{qq}(x_1, x_2) = f_q(x_1) f_q(x_2) \\hat{\\sigma}_{qq}(x_1 x_2 s)$ 并进行加权求和来计算的。此计算使用向量化的 `numpy` 操作得以高效实现。我们构成一个部分子能量矩阵 $S_{\\mathrm{hat}, kl} = p_k p_l s$，并使用外积从节点向量构造的矩阵上评估所有函数。\n5. 对 $(g,g)$ 通道应用相同的过程。\n6. 总强子截面 $\\sigma$ 是 $(q,q)$ 和 $(g,g)$ 通道结果的总和。\n\n通过使用两种不同的积分点数 $N_{\\mathrm{coarse}}$ 和 $N_{\\mathrm{fine}}$ 计算截面来验证收敛性。然后将相对差异 $\\delta = |\\sigma_{N_{\\mathrm{fine}}} - \\sigma_{N_{\\mathrm{coarse}}}| / |\\sigma_{N_{\\mathrm{fine}}}|$ 与指定的公差 $\\text{tol}$ 进行比较。结果是一个布尔变量，记作 $\\text{conv\\_ok}$，如果 $\\delta \\le \\text{tol}$ 则为真。对四个测试用例中的每一个都执行此过程。最终结果是一个序对列表，$[\\sigma_{N_{\\mathrm{fine}}}, \\text{conv\\_ok}]$，每个用例对应一个。当 $x \\to 0$ 时PDF的强尖峰行为（对于 $\\lambda_i  0$）需要一个稳健的积分方案。高斯-勒让德积分是合适的，因为其节点严格位于积分区间内部，从而避免了在可能存在奇点的端点上直接求值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import beta\n\ndef pdf_factory(lambda_i, eta_i):\n    \"\"\"\n    Creates a normalized Parton Distribution Function (PDF).\n\n    Args:\n        lambda_i (float): The 'x - 0' behavior parameter.\n        eta_i (float): The 'x - 1' behavior parameter.\n\n    Returns:\n        A function that computes the PDF f_i(x).\n    \"\"\"\n    if not (lambda_i  1.0 and eta_i > -1.0):\n        # This check is for correctness, but test cases are valid.\n        raise ValueError(\"PDF parameters must satisfy lambda_i  1 and eta_i > -1\")\n    \n    # Normalization constant derived from the Beta function\n    try:\n        norm = 1.0 / beta(1.0 - lambda_i, eta_i + 1.0)\n    except (ValueError, TypeError):\n        # Fallback for invalid beta function arguments, though problem constraints prevent this.\n        norm = 0.0\n\n    def pdf(x):\n        \"\"\"\n        Computes the PDF value at x.\n        x can be a float or a numpy array.\n        \"\"\"\n        # Gauss-Legendre nodes are in (0, 1), so no division by zero at x=0.\n        # Add a small epsilon to 1-x to avoid log(0) if x=1 node ever appears.\n        x_safe = np.asarray(x)\n        return norm * (x_safe**(-lambda_i)) * ((1.0 - x_safe)**eta_i)\n        \n    return pdf\n\ndef hat_sigma_qq_factory(M, Gamma, K_qq):\n    \"\"\"\n    Creates the quark-quark partonic cross section function.\n    \"\"\"\n    M2 = M**2\n    MGamma = M * Gamma\n    \n    def hat_sigma_qq(s_hat):\n        \"\"\"Computes the Breit-Wigner cross section.\"\"\"\n        return K_qq * MGamma / ((s_hat - M2)**2 + M2 * Gamma**2)\n        \n    return hat_sigma_qq\n\ndef hat_sigma_gg_factory(s_thr, p, sigma0_gg):\n    \"\"\"\n    Creates the gluon-gluon partonic cross section function.\n    \"\"\"\n    def hat_sigma_gg(s_hat):\n        \"\"\"Computes the threshold-like cross section.\"\"\"\n        # Use np.where for vectorized conditional logic.\n        # Ensure s_hat is not zero to avoid division by zero warnings,\n        # although s_hat will always be positive in this problem.\n        s_hat_safe = np.where(s_hat > 0, s_hat, 1.0)\n        ratio = s_thr / s_hat_safe\n        value = sigma0_gg * ((1.0 - ratio)**p) / s_hat_safe\n        return np.where(s_hat >= s_thr, value, 0.0)\n        \n    return hat_sigma_gg\n\ndef calculate_cross_section(N_points, s, f_q, f_g, hat_sigma_qq, hat_sigma_gg):\n    \"\"\"\n    Calculates the total hadronic cross section using Gauss-Legendre quadrature.\n    \"\"\"\n    if N_points = 0:\n        return 0.0\n\n    # Get standard Gauss-Legendre points and weights on [-1, 1]\n    z, w_hat = np.polynomial.legendre.leggauss(N_points)\n    \n    # Transform nodes and weights to the integration interval [0, 1]\n    x_nodes = (z + 1.0) / 2.0\n    w_nodes = w_hat / 2.0\n    \n    # Evaluate PDFs at the quadrature nodes\n    fq_vals = f_q(x_nodes)\n    fg_vals = f_g(x_nodes)\n    \n    # Vectorized calculation using outer products\n    w_matrix = np.outer(w_nodes, w_nodes)\n    x1x2_matrix = np.outer(x_nodes, x_nodes)\n    shat_matrix = x1x2_matrix * s\n    \n    # Quark-quark channel contribution\n    fqfq_matrix = np.outer(fq_vals, fq_vals)\n    sigma_qq_integrand_matrix = fqfq_matrix * hat_sigma_qq(shat_matrix)\n    sigma_qq = np.sum(w_matrix * sigma_qq_integrand_matrix)\n    \n    # Gluon-gluon channel contribution\n    fgfg_matrix = np.outer(fg_vals, fg_vals)\n    sigma_gg_integrand_matrix = fgfg_matrix * hat_sigma_gg(shat_matrix)\n    sigma_gg = np.sum(w_matrix * sigma_gg_integrand_matrix)\n    \n    # Total cross section is sum of channels (qg, gq assumed zero)\n    total_sigma = sigma_qq + sigma_gg\n    return total_sigma\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'s': 13000.0**2, 'lambda_q': 0.6, 'eta_q': 3.0, 'lambda_g': 0.3, 'eta_g': 5.0,\n         'M': 91.0, 'Gamma': 2.5, 'K_qq': 1.0e4, 's_thr': 350.0**2, 'p': 2.0, 'sigma0_gg': 1.0e5,\n         'N_coarse': 64, 'N_fine': 128, 'tol': 1.0e-3},\n        # Case 2\n        {'s': 13000.0**2, 'lambda_q': 0.95, 'eta_q': 4.0, 'lambda_g': 0.9, 'eta_g': 6.0,\n         'M': 91.0, 'Gamma': 2.5, 'K_qq': 1.0e4, 's_thr': 350.0**2, 'p': 2.0, 'sigma0_gg': 1.0e5,\n         'N_coarse': 64, 'N_fine': 128, 'tol': 2.0e-3},\n        # Case 3\n        {'s': 13000.0**2, 'lambda_q': 0.99, 'eta_q': 5.0, 'lambda_g': 0.95, 'eta_g': 7.0,\n         'M': 91.0, 'Gamma': 0.5, 'K_qq': 1.0e4, 's_thr': 350.0**2, 'p': 3.0, 'sigma0_gg': 1.0e5,\n         'N_coarse': 64, 'N_fine': 128, 'tol': 3.0e-3},\n        # Case 4\n        {'s': 13000.0**2, 'lambda_q': 0.7, 'eta_q': 3.0, 'lambda_g': 0.5, 'eta_g': 5.0,\n         'M': 6000.0, 'Gamma': 100.0, 'K_qq': 5.0e4, 's_thr': 2000.0**2, 'p': 2.0, 'sigma0_gg': 2.0e5,\n         'N_coarse': 64, 'N_fine': 128, 'tol': 1.0e-3}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Create function objects for the current case's parameters\n        f_q = pdf_factory(case['lambda_q'], case['eta_q'])\n        f_g = pdf_factory(case['lambda_g'], case['eta_g'])\n        hat_sigma_qq = hat_sigma_qq_factory(case['M'], case['Gamma'], case['K_qq'])\n        hat_sigma_gg = hat_sigma_gg_factory(case['s_thr'], case['p'], case['sigma0_gg'])\n        \n        # Calculate cross sections for coarse and fine quadrature\n        sigma_coarse = calculate_cross_section(\n            case['N_coarse'], case['s'], f_q, f_g, hat_sigma_qq, hat_sigma_gg\n        )\n        sigma_fine = calculate_cross_section(\n            case['N_fine'], case['s'], f_q, f_g, hat_sigma_qq, hat_sigma_gg\n        )\n        \n        # Check convergence criterion\n        if sigma_fine != 0.0:\n            rel_diff = np.abs(sigma_fine - sigma_coarse) / np.abs(sigma_fine)\n        # Handle the case where sigma_fine is zero to avoid division by zero\n        elif sigma_coarse != 0.0:\n            rel_diff = np.inf \n        else: # Both are zero\n            rel_diff = 0.0\n            \n        conv_ok = bool(rel_diff = case['tol'])\n        \n        results.append([float(sigma_fine), conv_ok])\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nsolve()\n```"
        },
        {
            "introduction": "领头阶 (LO) 计算为我们提供了物理过程的初步图像，但精确的预测需要更高阶的修正，如次领头阶 (NLO) 计算。进入NLO领域，我们将不可避免地遇到由实发射和虚修正项产生的红外发散，而这些发散必须在计算IRC安全的可观测量时精确相消。本练习通过一个精简的偶极子减除 (dipole subtraction) 方案，让您亲身体验如何实现这种至关重要的奇点对消，从而从数值上验证减除法是如何将发散的中间步骤转化为一个有限、有预测能力的最终结果。",
            "id": "3514222",
            "problem": "你的任务是用代码实现一个减除框架，该框架能捕捉Drell–Yan产生过程的部分子通道$q\\bar{q}\\to \\gamma^* g$在次领头阶（NLO）下，量子色动力学（QCD）红外奇异性的普适因子化结构。你的目标是数值验证对于一组测试输入，带有Catani–Seymour偶极减除的实发射贡献之和，与虚修正加质量因子化抵消项之和，结果是有限的。\n\n基本依据与范围：\n- 从强子截面的因子化定理和量子色动力学（QCD）的普适红外结构出发。使用领头阶Altarelli–Parisi分裂函数来描述夸克分裂为夸克和胶子的过程，其定义为\n  $$\n  P_{qq}(z) = C_F \\frac{1+z^2}{1-z},\n  $$\n  其中 $z \\in (0,1)$ 是共线发射后夸克携带的动量分数，$C_F$ 是基础表示中的二次Casimir算符。在下面的玩具模型中，设置 $C_F = 1$ 和一个总归一化常数等于 $1$，以保持可观测量无量纲。\n- 在部分子层面，针对初态奇异性，使用Catani–Seymour减除思想。在部分子质心系中，考虑入射夸克沿$+z$方向，入射反夸克沿$-z$方向。用$\\theta$表示发射的胶子相对于入射夸克的散射角，并定义$c \\equiv \\cos\\theta \\in [-1,1]$。软区对应于$z \\to 1$，而两个共线区对应于$c \\to +1$（与入射夸克共线）和$c \\to -1$（与入射反夸克共线）。\n- 定义一个玩具Catani–Seymour偶极核，它能再现实发射矩阵元平方的正确软奇异和共线奇异行为：\n  $$\n  \\mathcal{D}(z,c) \\equiv \\frac{1+z^2}{1-z}\\left(\\frac{1}{1-c} + \\frac{1}{1+c}\\right).\n  $$\n  这包含了正确的$z\\to 1$和$c\\to \\pm 1$奇异性，仅相差一些总因子。\n- 定义一个玩具实发射微分密度，它包含与物理矩阵元相同的奇异性以及一个有限的余项：\n  $$\n  \\mathcal{R}(z,c) \\equiv \\mathcal{D}(z,c) + f_{\\mathrm{fin}}(z), \\quad f_{\\mathrm{fin}}(z) \\equiv 1 - z.\n  $$\n  该构造与奇异性的因子化是一致的：差值$\\mathcal{R}-\\mathcal{D}$在四维中可积，并且在相空间的任何地方都是有限的。\n- 在减除形式体系中，NLO部分子截面可以示意性地表示为\n  $$\n  \\sigma^{\\mathrm{NLO}} = \\underbrace{\\int_{z_{\\min}}^{1}\\int_{-1}^{1}\\left[\\mathcal{R}(z,c) - \\mathcal{D}(z,c)\\right]\\mathrm{d}c\\,\\mathrm{d}z}_{\\sigma_{\\mathrm{real}}^{\\mathrm{sub}}}\n  + \\underbrace{\\left(\\sigma_{\\mathrm{virt}} + \\sigma_{\\mathrm{int.\\,dipole}} + \\sigma_{\\mathrm{mf}}\\right)}_{\\sigma_{\\mathrm{counter}}}.\n  $$\n  此处，$\\sigma_{\\mathrm{virt}}$表示虚修正，$\\sigma_{\\mathrm{int.\\,dipole}}$表示积分后的偶极贡献，而$\\sigma_{\\mathrm{mf}}$表示质量因子化抵消项，该项将初态共线奇异性吸收到部分子分布函数（PDF）中。在此玩具模型中，你需要假定一个有限的重整化方案，使得虚修正和质量因子化抵消项之和，再加上积分后的偶极项，是有限的且为零：\n  $$\n  \\sigma_{\\mathrm{counter}} = 0.\n  $$\n  这个选择反映了在将这些部分求和后，所有的红外奇异性都被移除了，只留下$\\sigma_{\\mathrm{real}}^{\\mathrm{sub}}$的有限贡献。\n\n数值实现要求：\n- 使用高斯-勒让德求积法为$z$和$c$实现一个稳定的$\\sigma_{\\mathrm{real}}^{\\mathrm{sub}}$数值积分器。你必须计算\n  $$\n  \\sigma_{\\mathrm{real}}^{\\mathrm{sub}}(z_{\\min}) = \\int_{z_{\\min}}^{1}\\int_{-1}^{1}\\left[\\mathcal{R}(z,c) - \\mathcal{D}(z,c)\\right]\\mathrm{d}c\\,\\mathrm{d}z.\n  $$\n- 为了模拟蒙特卡洛事件生成器中常见的数值稳定性保障措施，在计算形如$1-c$、$1+c$或$1-z$的分母时，你必须用用户指定的微小正常数$\\varepsilon_c$和$\\varepsilon_z$对它们进行正则化，即$1-c \\to 1-c+\\varepsilon_c$、$1+c\\to 1+c+\\varepsilon_c$和$1-z\\to 1-z+\\varepsilon_z$。减除法的物理原理保证了最终的被减除积分函数是有限的，并且在$\\varepsilon_c$和$\\varepsilon_z$趋于无穷小的极限下，积分结果不依赖于这些正则化参数。\n- 由于$\\mathcal{R}(z,c) - \\mathcal{D}(z,c) = f_{\\mathrm{fin}}(z) = 1-z$是有限的且与$c$无关，积分后的减除实发射部分的精确值为\n  $$\n  \\sigma_{\\mathrm{real}}^{\\mathrm{sub}}(z_{\\min}) = \\int_{z_{\\min}}^{1}\\int_{-1}^{1}(1-z)\\,\\mathrm{d}c\\,\\mathrm{d}z = 2\\int_{z_{\\min}}^{1}(1-z)\\,\\mathrm{d}z = (1 - z_{\\min})^2,\n  $$\n  这是一个有用的交叉检验，但不应作为硬编码结果。你的代码必须通过对$\\mathcal{R}-\\mathcal{D}$进行积分来数值计算该积分。\n- 对于此问题，你必须将实修正、虚修正和质量因子化抵消项的总和取为\n  $$\n  \\sigma_{\\mathrm{total}}(z_{\\min};\\varepsilon_c,\\varepsilon_z) \\equiv \\sigma_{\\mathrm{real}}^{\\mathrm{sub}}(z_{\\min}) + \\sigma_{\\mathrm{counter}} = \\sigma_{\\mathrm{real}}^{\\mathrm{sub}}(z_{\\min}),\n  $$\n  并数值上证明它是有限的且与正则化参数无关。\n\n角度和单位约定：\n- 所有角度都应以弧度处理。输出的可观测量是无量纲的。\n\n测试套件：\n- 使用以下四个测试用例，它们探测了典型区域、边界区域以及对正则化参数的独立性：\n  1. $z_{\\min} = 0.2$，$\\varepsilon_c = 10^{-6}$，$\\varepsilon_z = 10^{-9}$。\n  2. $z_{\\min} = 0.95$，$\\varepsilon_c = 10^{-6}$，$\\varepsilon_z = 10^{-12}$。\n  3. $z_{\\min} = 0.2$，$\\varepsilon_c = 10^{-12}$，$\\varepsilon_z = 10^{-6}$。\n  4. $z_{\\min} = 0.5$，$\\varepsilon_c = 10^{-9}$，$\\varepsilon_z = 10^{-9}$。\n\n要求的输出：\n- 对于每个测试用例，计算单个浮点数\n  $$\n  \\sigma_{\\mathrm{total}}(z_{\\min};\\varepsilon_c,\\varepsilon_z).\n  $$\n- 你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4]”）。结果的顺序必须与上面列出的测试套件的顺序相同。\n\n实现约束：\n- 你必须在$z$和$c$的积分中都使用至少$32$个节点的高斯-勒让德求积法，以确保数值稳定性和准确性。\n- 你的实现必须是完全确定性的，不使用任何随机性，并且不应需要任何用户输入。",
            "solution": "该问题陈述已经过严格验证，并被认为是有效的。其科学基础在于量子色动力学（QCD）的原理，特别是红外奇异性的因子化和Catani-Seymour偶极减除法。它提出了一个定义清晰、约束明确、目标明确的适定的、自洽的数值问题。该玩具模型虽然经过简化，但在概念上是合理的，并为减除形式体系的数值实现提供了严格的测试。\n\n任务是为一个Drell-Yan产生过程的玩具模型$q\\bar{q}\\to \\gamma^* g$，数值计算其次领头阶（NLO）部分子截面中的减除后实发射贡献。这个可观测量记为$\\sigma_{\\mathrm{real}}^{\\mathrm{sub}}(z_{\\min})$，需要计算的是它与其他NLO贡献的总和$\\sigma_{\\mathrm{total}}$。该问题通过假设虚修正和抵消项之和为零（$\\sigma_{\\mathrm{counter}} = 0$）简化了计算，这在玩具模型中是有效假设。因此，需要计算的量是\n$$\n\\sigma_{\\mathrm{total}}(z_{\\min};\\varepsilon_c,\\varepsilon_z) = \\sigma_{\\mathrm{real}}^{\\mathrm{sub}}(z_{\\min}) = \\int_{z_{\\min}}^{1}\\int_{-1}^{1}\\left[\\mathcal{R}(z,c) - \\mathcal{D}(z,c)\\right]\\mathrm{d}c\\,\\mathrm{d}z.\n$$\n函数$\\mathcal{R}(z,c)$和$\\mathcal{D}(z,c)$定义如下：\n$$\n\\mathcal{D}(z,c) \\equiv \\frac{1+z^2}{1-z}\\left(\\frac{1}{1-c} + \\frac{1}{1+c}\\right)\n$$\n$$\n\\mathcal{R}(z,c) \\equiv \\mathcal{D}(z,c) + f_{\\mathrm{fin}}(z), \\quad \\text{with } f_{\\mathrm{fin}}(z) = 1 - z.\n$$\n减除法的一个关键特征是，虽然$\\mathcal{R}(z,c)$和$\\mathcal{D}(z,c)$在软（$z \\to 1$）和共线（$c \\to \\pm 1$）极限下各自是奇异的，但它们的差值在任何地方都是有限的：\n$$\n\\mathcal{R}(z,c) - \\mathcal{D}(z,c) = 1 - z.\n$$\n该问题要求对此抵消进行数值演示。我们必须数值计算正则化后的表达式，其中分母由微小的正常数$\\varepsilon_z$和$\\varepsilon_c$保护。正则化后的偶极项是\n$$\n\\mathcal{D}_{\\mathrm{reg}}(z,c; \\varepsilon_c, \\varepsilon_z) = \\frac{1+z^2}{1-z+\\varepsilon_z}\\left(\\frac{1}{1-c+\\varepsilon_c} + \\frac{1}{1+c+\\varepsilon_c}\\right).\n$$\n正则化后的实发射项是$\\mathcal{R}_{\\mathrm{reg}}(z,c; \\varepsilon_c, \\varepsilon_z) = \\mathcal{D}_{\\mathrm{reg}}(z,c; \\varepsilon_c, \\varepsilon_z) + (1 - z)$。必须在每个求值点上对差值$\\mathcal{R}_{\\mathrm{reg}} - \\mathcal{D}_{\\mathrm{reg}}$进行数值积分。这个过程测试了减除法的数值稳定性，因为单个正则化项在奇异区域附近可能变得非常大，但它们的差值仍必须产生正确的有限结果。\n\n根据规定，将使用高斯-勒让德求积法对$z$和$c$进行数值积分。函数$F(z,c)$在区域$[z_{\\min}, 1] \\times [-1, 1]$上的二重积分近似为：\n$$\n\\int_{z_{\\min}}^{1}\\int_{-1}^{1} F(z,c) \\,\\mathrm{d}c\\,\\mathrm{d}z \\approx \\frac{1-z_{\\min}}{2} \\sum_{i=1}^{N_z} w_i^z \\left( \\frac{1-(-1)}{2} \\sum_{j=1}^{N_c} w_j^c F(z_i, c_j) \\right)\n$$\n其中$(x_k, w_k)$是区间$[-1, 1]$上的$N$点高斯-勒让德节点和权重。积分变量$z_i$和$c_j$是通过将标准节点$x_k$映射到相应的积分区间得到的：\n$$\nz_i = \\frac{1-z_{\\min}}{2}x_i^z + \\frac{1+z_{\\min}}{2} \\quad \\text{和} \\quad c_j = x_j^c.\n$$\n问题规定至少使用$N_z = N_c = 32$个节点。实现将在两个维度上都使用$N=32$个节点。所需的节点和权重将从`scipy.special.roots_legendre`获取。将对每个测试用例进行计算，其结果应与积分的解析值一致，这是一个关键的交叉检验：\n$$\n\\sigma_{\\mathrm{real}}^{\\mathrm{sub}}(z_{\\min}) = \\int_{z_{\\min}}^{1}\\int_{-1}^{1}(1-z)\\,\\mathrm{d}c\\,\\mathrm{d}z = 2 \\int_{z_{\\min}}^{1}(1-z)\\,\\mathrm{d}z = 2\\left[z - \\frac{z^2}{2}\\right]_{z_{\\min}}^1 = (1-z_{\\min})^2.\n$$\n数值结果预期将非常接近此解析公式，从而证明减除方案被正确实现且数值稳定，并且结果与为正则化参数$\\varepsilon_c$和$\\varepsilon_z$选择的特定小值无关。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Calculates the total cross section for a toy QCD process\n    using the Catani-Seymour dipole subtraction method.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (z_min, eps_c, eps_z)\n        (0.2, 1e-6, 1e-9),\n        (0.95, 1e-6, 1e-12),\n        (0.2, 1e-12, 1e-6),\n        (0.5, 1e-9, 1e-9),\n    ]\n\n    # Set the number of nodes for Gauss-Legendre quadrature.\n    # The problem requires at least 32 nodes.\n    NUM_NODES = 32\n    nodes, weights = roots_legendre(NUM_NODES)\n\n    def D_regulated(z, c, eps_z, eps_c):\n        \"\"\"\n        Calculates the regulated toy Catani-Seymour dipole kernel D(z,c).\n        \"\"\"\n        term_z = (1.0 + z**2) / (1.0 - z + eps_z)\n        term_c = 1.0 / (1.0 - c + eps_c) + 1.0 / (1.0 + c + eps_c)\n        return term_z * term_c\n\n    def R_regulated(z, c, eps_z, eps_c):\n        \"\"\"\n        Calculates the regulated toy real-emission differential density R(z,c).\n        \"\"\"\n        return D_regulated(z, c, eps_z, eps_c) + (1.0 - z)\n\n    def calculate_sigma_total(z_min, eps_c, eps_z):\n        \"\"\"\n        Performs the 2D numerical integration of (R - D) using\n        Gauss-Legendre quadrature.\n        \"\"\"\n        # Map the standard [-1, 1] nodes to the integration intervals.\n        # For c, the interval is [-1, 1], so c_coords = nodes.\n        c_coords = nodes\n        # For z, the interval is [z_min, 1].\n        z_map_factor = 0.5 * (1.0 - z_min)\n        z_map_offset = 0.5 * (1.0 + z_min)\n        z_coords = z_map_factor * nodes + z_map_offset\n\n        # Create 2D grids for coordinates and weights for vectorized evaluation.\n        z_grid, c_grid = np.meshgrid(z_coords, c_coords, indexing='ij')\n        w_z_grid, w_c_grid = np.meshgrid(weights, weights, indexing='ij')\n\n        # Evaluate the regulated R and D functions on the grid.\n        # The core of the subtraction method is to compute the difference of the\n        # full expressions numerically at each point.\n        r_vals = R_regulated(z_grid, c_grid, eps_z, eps_c)\n        d_vals = D_regulated(z_grid, c_grid, eps_z, eps_c)\n\n        # The integrand is the difference, which should be finite.\n        integrand = r_vals - d_vals\n\n        # Perform the weighted sum over the 2D grid.\n        # The integration weight for the c-integral is (1 - (-1))/2 = 1.\n        # The integration weight for the z-integral is (1 - z_min)/2.\n        integral = np.sum(w_z_grid * w_c_grid * integrand) * z_map_factor\n\n        return integral\n\n    results = []\n    for case in test_cases:\n        z_min_val, eps_c_val, eps_z_val = case\n        # According to the problem, sigma_total = sigma_real_sub, as sigma_counter = 0.\n        sigma_total = calculate_sigma_total(z_min_val, eps_c_val, eps_z_val)\n        results.append(sigma_total)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}