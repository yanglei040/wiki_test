{
    "hands_on_practices": [
        {
            "introduction": "这第一个练习是进入计算高能物理世界的基础一步。你将实现量子色动力学 (QCD) 因子分解的核心公式，该公式描述了强子散射截面如何由部分子分布函数 (PDFs) 和短程部分子散射截面的卷积构成。这项实践将锻炼你的数值积分技能，并展示我们如何将一个基本定理转化为一个可预测的计算工具。",
            "id": "3514288",
            "problem": "实现一个完整的程序，该程序基于量子色动力学（QCD）中的因子化定理，对强子截面进行数值评估。强子过程的截面由部分子分布函数（PDF）与部分子截面的卷积定义。从因子化原理出发，强子截面由纵向动量分数上的二重积分给出。您必须设计一种对具有尖锐峰值的PDF也具有鲁棒性的数值积分方法，并验证其收敛性。\n\n您必须使用以下建模假设，这些是科学上合理且适合计算测试的近似：\n\n1. 因子化公式定义为\n$$\n\\sigma(s,\\mu) = \\sum_{i,j} \\int_0^1 dx_1 \\int_0^1 dx_2 \\, f_i(x_1,\\mu)\\, f_j(x_2,\\mu) \\, \\hat{\\sigma}_{ij}(x_1 x_2 s, \\mu),\n$$\n其中，$s$ 是强子质心能量的平方，$\\mu$ 是因子化标度，$f_i$ 和 $f_j$ 是部分子 $i$ 和 $j$ 的PDF，$\\hat{\\sigma}_{ij}$ 是子过程 $i j \\to X$ 的部分子截面。\n\n2. 建立两种有效部分子种类 $i \\in \\{q, g\\}$（夸克和胶子）的模型。每个种类 $i$ 的PDF由一个归一化的类贝塔分布形状参数化：\n$$\nf_i(x;\\lambda_i,\\eta_i) = \\mathcal{N}_i(\\lambda_i,\\eta_i)\\, x^{-\\lambda_i}\\, (1-x)^{\\eta_i}, \\quad x \\in (0,1),\n$$\n其归一化常数 $\\mathcal{N}_i(\\lambda_i,\\eta_i)$ 的选择使得\n$$\n\\int_0^1 f_i(x;\\lambda_i,\\eta_i)\\,dx = 1.\n$$\n为保证可积性和科学真实性，强制要求 $\\lambda_i  1$ 且 $\\eta_i > -1$。\n\n3. 使用以下部分子截面：\n   - 夸克-夸克通道 $(q,q)$ (类Breit-Wigner共振形状):\n     $$\n     \\hat{\\sigma}_{qq}(s_{\\mathrm{hat}}; M, \\Gamma, K_{qq}) = K_{qq}\\, \\frac{M \\Gamma}{\\left(s_{\\mathrm{hat}} - M^2\\right)^2 + M^2 \\Gamma^2},\n     $$\n     其为非负，并在 $s_{\\mathrm{hat}} \\approx M^2$ 附近有尖锐峰值。\n   - 胶子-胶子通道 $(g,g)$ (类阈值连续谱):\n     $$ \n     \\hat{\\sigma}_{gg}(s_{\\mathrm{hat}}; s_{\\mathrm{thr}}, p, \\sigma_{0,gg}) = \n     \\begin{cases}\n     \\sigma_{0,gg}\\, \\dfrac{\\left(1 - s_{\\mathrm{thr}}/s_{\\mathrm{hat}}\\right)^p}{s_{\\mathrm{hat}}},  s_{\\mathrm{hat}} \\ge s_{\\mathrm{thr}}, \\\\\n     0,  s_{\\mathrm{hat}}  s_{\\mathrm{thr}},\n     \\end{cases}\n     $$\n     其仅在物理阈值 $s_{\\mathrm{thr}}$ 之上非零，并在大的 $s_{\\mathrm{hat}}$ 处减小。\n\n所有部分子截面均以皮靶（pb）表示，强子截面必须以皮靶（pb）返回和打印。如果出现任何角量，必须使用弧度（此处没有出现）。任何地方都不得使用百分比；分数容差应以小数表示。\n\n您的程序必须：\n- 使用在 $[0,1]\\times[0,1]$ 上的张量积高斯-勒让德积分法实现二重积分，每维的点数 $N$ 可调。\n- 通过使用相对差异准则\n$$\n\\delta = \\frac{\\left|\\sigma_{N_{\\mathrm{fine}}} - \\sigma_{N_{\\mathrm{coarse}}}\\right|}{\\left|\\sigma_{N_{\\mathrm{fine}}}\\right|} \\le \\text{tol},\n$$\n比较粗略积分 ($N_{\\mathrm{coarse}}$) 和精细积分 ($N_{\\mathrm{fine}}$) 的结果来验证收敛性，其中 $\\text{tol}$ 是一个指定的小数容差。返回一个布尔值，指示是否满足收敛准则。\n\n测试套件：\n评估以下四个测试用例。对于每个用例，使用精细积分计算强子截面，并报告通过比较粗略积分与精细积分获得的收敛布尔值。请使用下方的确切参数值。所有能量必须以 $\\mathrm{GeV}$ 为单位处理，截面以 $\\mathrm{pb}$ 为单位，并且您必须以 $\\mathrm{pb}$ 为单位打印最终截面。\n\n- 用例 1 (理想情况，中等尖锐的PDF):\n  - $s = (13000\\,\\mathrm{GeV})^2$\n  - $\\mu = 91\\,\\mathrm{GeV}$\n  - 夸克 PDF: $\\lambda_q = 0.6$, $\\eta_q = 3.0$\n  - 胶子 PDF: $\\lambda_g = 0.3$, $\\eta_g = 5.0$\n  - 夸克-夸克通道: $M = 91\\,\\mathrm{GeV}$, $\\Gamma = 2.5\\,\\mathrm{GeV}$, $K_{qq} = 1.0\\times 10^4\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 胶子-胶子通道: $s_{\\mathrm{thr}} = (350\\,\\mathrm{GeV})^2$, $p = 2$, $\\sigma_{0,gg} = 1.0\\times 10^5\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 收敛性设置: $N_{\\mathrm{coarse}} = 64$, $N_{\\mathrm{fine}} = 128$, $\\text{tol} = 1.0\\times 10^{-3}$\n\n- 用例 2 (在 $x \\to 0$ 附近有尖锐峰值的PDF):\n  - $s = (13000\\,\\mathrm{GeV})^2$\n  - $\\mu = 50\\,\\mathrm{GeV}$\n  - 夸克 PDF: $\\lambda_q = 0.95$, $\\eta_q = 4.0$\n  - 胶子 PDF: $\\lambda_g = 0.9$, $\\eta_g = 6.0$\n  - 夸克-夸克通道: $M = 91\\,\\mathrm{GeV}$, $\\Gamma = 2.5\\,\\mathrm{GeV}$, $K_{qq} = 1.0\\times 10^4\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 胶子-胶子通道: $s_{\\mathrm{thr}} = (350\\,\\mathrm{GeV})^2$, $p = 2$, $\\sigma_{0,gg} = 1.0\\times 10^5\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 收敛性设置: $N_{\\mathrm{coarse}} = 64$, $N_{\\mathrm{fine}} = 128$, $\\text{tol} = 2.0\\times 10^{-3}$\n\n- 用例 3 (非常尖锐的PDF和窄共振):\n  - $s = (13000\\,\\mathrm{GeV})^2$\n  - $\\mu = 20\\,\\mathrm{GeV}$\n  - 夸克 PDF: $\\lambda_q = 0.99$, $\\eta_q = 5.0$\n  - 胶子 PDF: $\\lambda_g = 0.95$, $\\eta_g = 7.0$\n  - 夸克-夸克通道: $M = 91\\,\\mathrm{GeV}$, $\\Gamma = 0.5\\,\\mathrm{GeV}$, $K_{qq} = 1.0\\times 10^4\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 胶子-胶子通道: $s_{\\mathrm{thr}} = (350\\,\\mathrm{GeV})^2$, $p = 3$, $\\sigma_{0,gg} = 1.0\\times 10^5\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 收敛性设置: $N_{\\mathrm{coarse}} = 64$, $N_{\\mathrm{fine}} = 128$, $\\text{tol} = 3.0\\times 10^{-3}$\n\n- 用例 4 (靠近相空间边界的高质量共振):\n  - $s = (13000\\,\\mathrm{GeV})^2$\n  - $\\mu = 200\\,\\mathrm{GeV}$\n  - 夸克 PDF: $\\lambda_q = 0.7$, $\\eta_q = 3.0$\n  - 胶子 PDF: $\\lambda_g = 0.5$, $\\eta_g = 5.0$\n  - 夸克-夸克通道: $M = 6000\\,\\mathrm{GeV}$, $\\Gamma = 100\\,\\mathrm{GeV}$, $K_{qq} = 5.0\\times 10^4\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 胶子-胶子通道: $s_{\\mathrm{thr}} = (2000\\,\\mathrm{GeV})^2$, $p = 2$, $\\sigma_{0,gg} = 2.0\\times 10^5\\,\\mathrm{pb}\\cdot\\mathrm{GeV}^2$\n  - 收敛性设置: $N_{\\mathrm{coarse}} = 64$, $N_{\\mathrm{fine}} = 128$, $\\text{tol} = 1.0\\times 10^{-3}$\n\n输出规范：\n您的程序必须生成一行输出，其中包含一个对的列表，每个测试用例一个对。每对必须是 $[\\sigma_{\\mathrm{fine}}, \\mathrm{conv\\_ok}]$ 的形式，其中 $\\sigma_{\\mathrm{fine}}$ 是用 $N_{\\mathrm{fine}}$ 计算的截面（以 $\\mathrm{pb}$ 为单位的浮点数），而 $\\mathrm{conv\\_ok}$ 是一个布尔值，指示是否满足收敛准则。最后一行必须精确地打印为 Python 的列表的列表，例如：\n$$\n[\\,[\\sigma_1,\\mathrm{True}],[\\sigma_2,\\mathrm{False}],\\ldots\\,].\n$$",
            "solution": "用户提供的问题被认为是有效的。它科学上基于量子色动力学（QCD）的原理，问题定义明确、客观且计算上可行。该问题要求数值评估强子截面，这是计算高能物理学中的一项核心任务。所提供的模型虽然是完整 QCD 的简化，但使用了标准的参数化方法并且内部一致。\n\n目标是根据 QCD 因子化定理，计算一个双部分子模型的强子截面 $\\sigma$。在强子质心能量平方为 $s$ 时，总截面 $\\sigma$ 的公式是所有可能的初始部分子类型 $i, j$ 贡献的总和。对于指定的具有两种有效部分子种类——夸克（$q$）和胶子（$g$）的模型，部分子集合为 $\\{q, g\\}$。控制表达式为：\n$$\n\\sigma(s) = \\sum_{i,j \\in \\{q,g\\}} \\int_0^1 dx_1 \\int_0^1 dx_2 \\, f_i(x_1)\\, f_j(x_2) \\, \\hat{\\sigma}_{ij}(x_1 x_2 s, \\mu)\n$$\n问题为夸克-夸克 $(q,q)$ 和胶子-胶子 $(g,g)$ 通道提供了模型。混合通道，即夸克-胶子 $(q,g)$ 和胶子-夸克 $(g,q)$，的定义被省略，这意味着它们的贡献被视为零，即 $\\hat{\\sigma}_{qg} = \\hat{\\sigma}_{gq} = 0$。在教学模型中，这是一种常见且可接受的简化。根据这个假设，总截面是两项之和：\n$$\n\\sigma(s) = \\int_0^1 dx_1 \\int_0^1 dx_2 \\, f_q(x_1) f_q(x_2) \\hat{\\sigma}_{qq}(x_1 x_2 s) + \\int_0^1 dx_1 \\int_0^1 dx_2 \\, f_g(x_1) f_g(x_2) \\hat{\\sigma}_{gg}(x_1 x_2 s)\n$$\n注意到，因子化标度 $\\mu$ 虽然在每个测试用例中都提供，但并未在部分子分布函数（PDFs）$f_i(x)$ 或部分子截面 $\\hat{\\sigma}_{ij}$ 的简化、标度无关形式中明确出现，正如它们在问题中的定义。因此，根据所提供的模型，$\\mu$ 在计算中不是一个活动参数。\n\nPDF，$f_i(x; \\lambda_i, \\eta_i)$，描述了在父强子中找到携带其动量分数 $x$ 的部分子 $i$ 的概率密度，其参数化形式为：\n$$\nf_i(x;\\lambda_i,\\eta_i) = \\mathcal{N}_i(\\lambda_i,\\eta_i)\\, x^{-\\lambda_i}\\, (1-x)^{\\eta_i}\n$$\n对于 $x \\in (0,1)$。归一化常数 $\\mathcal{N}_i$ 由找到具有任何动量分数的部分子的总概率为1的条件确定：\n$$\n\\int_0^1 f_i(x;\\lambda_i,\\eta_i)\\,dx = 1\n$$\n这要求 $\\mathcal{N}_i$ 是未归一化函数积分的倒数。这个积分是欧拉贝塔函数 $B(a,b)$ 的一种表示：\n$$\n\\int_0^1 x^{-\\lambda_i}\\, (1-x)^{\\eta_i} dx = \\int_0^1 x^{(1-\\lambda_i)-1}\\, (1-x)^{(\\eta_i+1)-1} dx = B(1-\\lambda_i, \\eta_i+1)\n$$\n约束条件 $\\lambda_i  1$ 和 $\\eta_i > -1$ 确保此积分收敛。因此归一化常数由下式给出：\n$$\n\\mathcal{N}_i(\\lambda_i,\\eta_i) = \\frac{1}{B(1-\\lambda_i, \\eta_i+1)}\n$$\n该常数使用 `scipy.special.beta` 函数计算。\n\n部分子截面 $\\hat{\\sigma}_{ij}(s_{\\mathrm{hat}})$ 描述了在部分子质心能量平方 $s_{\\mathrm{hat}} = x_1 x_2 s$ 下，部分子 $i$ 和 $j$ 之间的基本相互作用。指定的模型是：\n1. 夸克-夸克通道：这由一个 Breit-Wigner 共振形状建模，这是产生不稳定粒子的特征。\n$$\n\\hat{\\sigma}_{qq}(s_{\\mathrm{hat}}; M, \\Gamma, K_{qq}) = K_{qq}\\, \\frac{M \\Gamma}{\\left(s_{\\mathrm{hat}} - M^2\\right)^2 + M^2 \\Gamma^2}\n$$\n2. 胶子-胶子通道：这被建模为在运动学阈值 $s_{\\mathrm{thr}}$ 以上的连续谱产生。\n$$\n\\hat{\\sigma}_{gg}(s_{\\mathrm{hat}}; s_{\\mathrm{thr}}, p, \\sigma_{0,gg}) =\n\\begin{cases}\n\\sigma_{0,gg}\\, \\dfrac{\\left(1 - s_{\\mathrm{thr}}/s_{\\mathrm{hat}}\\right)^p}{s_{\\mathrm{hat}}},  s_{\\mathrm{hat}} \\ge s_{\\mathrm{thr}} \\\\\n0,  s_{\\mathrm{hat}}  s_{\\mathrm{thr}}\n\\end{cases}\n$$\n\n二重积分的数值评估使用张量积高斯-勒让德求积法则进行。对于单位正方形上的通用二维积分，此方法给出近似值：\n$$\n\\int_0^1 \\int_0^1 G(x_1, x_2) \\,dx_1 dx_2 \\approx \\sum_{k=1}^{N} \\sum_{l=1}^{N} w_k w_l \\, G(p_k, p_l)\n$$\n在这里，$\\{p_k\\}_{k=1}^N$ 和 $\\{w_k\\}_{k=1}^N$ 分别是单个维度上在区间 $[0,1]$ 内的积分点（节点）和权重。这些是通过对定义在 $[-1,1]$ 上的标准高斯-勒让德求积元进行线性变换得到的。如果 $\\{z_k, w'_k\\}$ 是 $[-1,1]$ 上的标准节点和权重，则变换 $x = (z+1)/2$ 将它们映射到 $[0,1]$，产生节点 $p_k = (z_k+1)/2$ 和权重 $w_k = w'_k/2$。使用 `numpy.polynomial.legendre.leggauss` 函数生成标准节点和权重。\n\n算法如下：\n1. 对于给定的积分点数 $N$，在区间 $[0,1]$ 上生成节点 $\\{p_k\\}$ 和权重 $\\{w_k\\}$。\n2. 对于每种部分子类型（$q$ 和 $g$），使用指定的参数和预先计算的归一化常数构造 PDF 函数 $f_q(x)$ 和 $f_g(x)$。\n3. 构造部分子截面函数 $\\hat{\\sigma}_{qq}(s_{\\mathrm{hat}})$ 和 $\\hat{\\sigma}_{gg}(s_{\\mathrm{hat}})$。\n4. 每个通道（例如 $(q,q)$）的积分是通过在所有节点对 $(p_k, p_l)$ 上评估完整的被积函数 $I_{qq}(x_1, x_2) = f_q(x_1) f_q(x_2) \\hat{\\sigma}_{qq}(x_1 x_2 s)$ 并执行加权求和来计算的。此计算使用向量化的 `numpy` 操作高效实现。我们形成一个部分子能量矩阵 $S_{\\mathrm{hat}, kl} = p_k p_l s$，并使用外积从节点向量构建的矩阵上评估所有函数。\n5. 对 $(g,g)$ 通道应用相同的过程。\n6. 总强子截面 $\\sigma$ 是 $(q,q)$ 和 $(g,g)$ 通道结果的总和。\n\n通过用两种不同的积分点数 $N_{\\mathrm{coarse}}$ 和 $N_{\\mathrm{fine}}$ 计算截面来验证收敛性。然后将相对差异 $\\delta = |\\sigma_{N_{\\mathrm{fine}}} - \\sigma_{N_{\\mathrm{coarse}}}| / |\\sigma_{N_{\\mathrm{fine}}}|$ 与指定的容差 $\\text{tol}$ 进行比较。结果是一个布尔变量，记为 $\\text{conv\\_ok}$，如果 $\\delta \\le \\text{tol}$ 则为真。对四个测试用例中的每一个都执行此过程。最终结果是一个对的列表，$[\\sigma_{N_{\\mathrm{fine}}}, \\text{conv\\_ok}]$，每个用例一个。PDF 在 $x \\to 0$ 时的强峰值（对于 $\\lambda_i > 0$）需要一个稳健的积分方案。高斯-勒让德积分是合适的，因为其节点严格位于积分区间内，从而避免了在可能存在奇点的端点处进行直接评估。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import beta\n\ndef pdf_factory(lambda_i, eta_i):\n    \"\"\"\n    Creates a normalized Parton Distribution Function (PDF).\n\n    Args:\n        lambda_i (float): The 'x -> 0' behavior parameter.\n        eta_i (float): The 'x -> 1' behavior parameter.\n\n    Returns:\n        A function that computes the PDF f_i(x).\n    \"\"\"\n    if not (lambda_i  1.0 and eta_i > -1.0):\n        # This check is for correctness, but test cases are valid.\n        raise ValueError(\"PDF parameters must satisfy lambda_i  1 and eta_i > -1\")\n    \n    # Normalization constant derived from the Beta function\n    try:\n        norm = 1.0 / beta(1.0 - lambda_i, eta_i + 1.0)\n    except (ValueError, TypeError):\n        # Fallback for invalid beta function arguments, though problem constraints prevent this.\n        norm = 0.0\n\n    def pdf(x):\n        \"\"\"\n        Computes the PDF value at x.\n        x can be a float or a numpy array.\n        \"\"\"\n        # Gauss-Legendre nodes are in (0, 1), so no division by zero at x=0.\n        # Add a small epsilon to 1-x to avoid log(0) if x=1 node ever appears.\n        x_safe = np.asarray(x)\n        return norm * (x_safe**(-lambda_i)) * ((1.0 - x_safe)**eta_i)\n        \n    return pdf\n\ndef hat_sigma_qq_factory(M, Gamma, K_qq):\n    \"\"\"\n    Creates the quark-quark partonic cross section function.\n    \"\"\"\n    M2 = M**2\n    MGamma = M * Gamma\n    \n    def hat_sigma_qq(s_hat):\n        \"\"\"Computes the Breit-Wigner cross section.\"\"\"\n        return K_qq * MGamma / ((s_hat - M2)**2 + M2 * Gamma**2)\n        \n    return hat_sigma_qq\n\ndef hat_sigma_gg_factory(s_thr, p, sigma0_gg):\n    \"\"\"\n    Creates the gluon-gluon partonic cross section function.\n    \"\"\"\n    def hat_sigma_gg(s_hat):\n        \"\"\"Computes the threshold-like cross section.\"\"\"\n        # Use np.where for vectorized conditional logic.\n        # Ensure s_hat is not zero to avoid division by zero warnings,\n        # although s_hat will always be positive in this problem.\n        s_hat_safe = np.where(s_hat > 0, s_hat, 1.0)\n        ratio = s_thr / s_hat_safe\n        value = sigma0_gg * ((1.0 - ratio)**p) / s_hat_safe\n        return np.where(s_hat >= s_thr, value, 0.0)\n        \n    return hat_sigma_gg\n\ndef calculate_cross_section(N_points, s, f_q, f_g, hat_sigma_qq, hat_sigma_gg):\n    \"\"\"\n    Calculates the total hadronic cross section using Gauss-Legendre quadrature.\n    \"\"\"\n    if N_points = 0:\n        return 0.0\n\n    # Get standard Gauss-Legendre points and weights on [-1, 1]\n    z, w_hat = np.polynomial.legendre.leggauss(N_points)\n    \n    # Transform nodes and weights to the integration interval [0, 1]\n    x_nodes = (z + 1.0) / 2.0\n    w_nodes = w_hat / 2.0\n    \n    # Evaluate PDFs at the quadrature nodes\n    fq_vals = f_q(x_nodes)\n    fg_vals = f_g(x_nodes)\n    \n    # Vectorized calculation using outer products\n    w_matrix = np.outer(w_nodes, w_nodes)\n    x1x2_matrix = np.outer(x_nodes, x_nodes)\n    shat_matrix = x1x2_matrix * s\n    \n    # Quark-quark channel contribution\n    fqfq_matrix = np.outer(fq_vals, fq_vals)\n    sigma_qq_integrand_matrix = fqfq_matrix * hat_sigma_qq(shat_matrix)\n    sigma_qq = np.sum(w_matrix * sigma_qq_integrand_matrix)\n    \n    # Gluon-gluon channel contribution\n    fgfg_matrix = np.outer(fg_vals, fg_vals)\n    sigma_gg_integrand_matrix = fgfg_matrix * hat_sigma_gg(shat_matrix)\n    sigma_gg = np.sum(w_matrix * sigma_gg_integrand_matrix)\n    \n    # Total cross section is sum of channels (qg, gq assumed zero)\n    total_sigma = sigma_qq + sigma_gg\n    return total_sigma\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'s': 13000.0**2, 'lambda_q': 0.6, 'eta_q': 3.0, 'lambda_g': 0.3, 'eta_g': 5.0,\n         'M': 91.0, 'Gamma': 2.5, 'K_qq': 1.0e4, 's_thr': 350.0**2, 'p': 2.0, 'sigma0_gg': 1.0e5,\n         'N_coarse': 64, 'N_fine': 128, 'tol': 1.0e-3},\n        # Case 2\n        {'s': 13000.0**2, 'lambda_q': 0.95, 'eta_q': 4.0, 'lambda_g': 0.9, 'eta_g': 6.0,\n         'M': 91.0, 'Gamma': 2.5, 'K_qq': 1.0e4, 's_thr': 350.0**2, 'p': 2.0, 'sigma0_gg': 1.0e5,\n         'N_coarse': 64, 'N_fine': 128, 'tol': 2.0e-3},\n        # Case 3\n        {'s': 13000.0**2, 'lambda_q': 0.99, 'eta_q': 5.0, 'lambda_g': 0.95, 'eta_g': 7.0,\n         'M': 91.0, 'Gamma': 0.5, 'K_qq': 1.0e4, 's_thr': 350.0**2, 'p': 3.0, 'sigma0_gg': 1.0e5,\n         'N_coarse': 64, 'N_fine': 128, 'tol': 3.0e-3},\n        # Case 4\n        {'s': 13000.0**2, 'lambda_q': 0.7, 'eta_q': 3.0, 'lambda_g': 0.5, 'eta_g': 5.0,\n         'M': 6000.0, 'Gamma': 100.0, 'K_qq': 5.0e4, 's_thr': 2000.0**2, 'p': 2.0, 'sigma0_gg': 2.0e5,\n         'N_coarse': 64, 'N_fine': 128, 'tol': 1.0e-3}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Create function objects for the current case's parameters\n        f_q = pdf_factory(case['lambda_q'], case['eta_q'])\n        f_g = pdf_factory(case['lambda_g'], case['eta_g'])\n        hat_sigma_qq = hat_sigma_qq_factory(case['M'], case['Gamma'], case['K_qq'])\n        hat_sigma_gg = hat_sigma_gg_factory(case['s_thr'], case['p'], case['sigma0_gg'])\n        \n        # Calculate cross sections for coarse and fine quadrature\n        sigma_coarse = calculate_cross_section(\n            case['N_coarse'], case['s'], f_q, f_g, hat_sigma_qq, hat_sigma_gg\n        )\n        sigma_fine = calculate_cross_section(\n            case['N_fine'], case['s'], f_q, f_g, hat_sigma_qq, hat_sigma_gg\n        )\n        \n        # Check convergence criterion\n        if sigma_fine != 0.0:\n            rel_diff = np.abs(sigma_fine - sigma_coarse) / np.abs(sigma_fine)\n        # Handle the case where sigma_fine is zero to avoid division by zero\n        elif sigma_coarse != 0.0:\n            rel_diff = np.inf \n        else: # Both are zero\n            rel_diff = 0.0\n            \n        conv_ok = bool(rel_diff = case['tol'])\n        \n        results.append([float(sigma_fine), conv_ok])\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nsolve()\n```"
        },
        {
            "introduction": "在基本框架的基础上，本练习将探索因子分解最强大的推论之一：部分子分布函数的普适性。你将使用同一组 PDF 来预测两种不同过程的截面，从而展示因子分解如何为看似无关的测量之间提供预测性的联系。这项实践还引入了标度变化的概念，这是估算 QCD 预测中理论不确定度的关键方法。",
            "id": "3514246",
            "problem": "您需要设计并实现一个完整的、自包含的计算，以利用强子对撞中的共线因子分解原理，来检验部分子分布函数（Parton Distribution Function, PDF）在不同强子过程中的普适性。从质子-质子对撞中产生包容性电弱玻色子的共线因子分解定理开始，该定理指出，一个可观测的领头幂次截面可以表示为短程硬散射系数与长程PDF的卷积。具体来说，对于质心能量为 $\\sqrt{S}$、快度为 $y$ 的对撞中，包容性产生一个不变质量为 $Q$ 的玻色子，其部分子动量分数由运动学确定为 $x_1 = \\frac{Q}{\\sqrt{S}} e^{y}$ 和 $x_2 = \\frac{Q}{\\sqrt{S}} e^{-y}$，前提是 $0  x_1  1$ 且 $0  x_2  1$。您必须推导并实现 $pp \\to \\gamma^*$ 和 $pp \\to W^\\pm$ 过程的领头阶快度微分截面的表达式，该表达式需明确体现因子分解结构，对两个过程使用相同的PDF，并将短程依赖性分离到硬散射系数中。您的实现必须接着在两个过程中协同地改变共同的因子分解标度 $\\mu_F$，以量化标度不确定性的相关性。\n\n请使用以下源于核心定义、科学上合理且计算上可行的模型选择：\n\n- 实现来自量子色动力学（QCD）的、具有 $n_f$ 个活性味夸克的单圈强耦合常数的跑动。使用标准的单圈形式 $\\alpha_s(\\mu) = \\left[\\beta_0 \\ln\\left(\\mu^2/\\Lambda^2\\right)\\right]^{-1}$，其中 $\\beta_0 = \\frac{33 - 2 n_f}{12 \\pi}$，$n_f = 5$，且 $\\Lambda = 0.2\\,\\mathrm{GeV}$。确保所有计算中 $\\mu > \\Lambda$。\n\n- 实现一个玩具但定性上真实的PDF族，其通过缓慢变化的指数依赖于因子分解标度 $\\mu_F$，以捕捉随着 $\\mu_F$ 增大而增强的小-$x$ 增长和大-$x$ 压低效应。对于夸克味 $q \\in \\{u,d\\}$，定义一个价部分子和一个海部分子。对于 $q \\in \\{s,c\\}$，仅定义一个海部分子。设价部分子和海部分子为\n  $f_q^{\\mathrm{val}}(x,\\mu_F) = N_q^{\\mathrm{val}}\\, x^{-a_v(\\mu_F)} (1-x)^{b_v(\\mu_F)}$ 和 $f_q^{\\mathrm{sea}}(x,\\mu_F) = N_q^{\\mathrm{sea}}\\, x^{-a_s(\\mu_F)} (1-x)^{b_s(\\mu_F)}$，其指数为\n  $a_v(\\mu_F) = a_{v,0} + \\alpha_v \\ln\\left(\\mu_F/\\mu_0\\right)$, $b_v(\\mu_F) = b_{v,0} - \\beta_v \\ln\\left(\\mu_F/\\mu_0\\right)$, 以及\n  $a_s(\\mu_F) = a_{s,0} + \\alpha_s^{\\mathrm{exp}} \\ln\\left(\\mu_F/\\mu_0\\right)$, $b_s(\\mu_F) = b_{s,0} - \\beta_s^{\\mathrm{exp}} \\ln\\left(\\mu_F/\\mu_0\\right)$,\n  其中 $\\mu_0 = 2\\,\\mathrm{GeV}$, $a_{v,0} = 0.3$, $\\alpha_v = 0.03$, $b_{v,0} = 3.0$, $\\beta_v = 0.1$, $a_{s,0} = 0.7$, $\\alpha_s^{\\mathrm{exp}} = 0.05$, $b_{s,0} = 5.0$, $\\beta_s^{\\mathrm{exp}} = 0.2$。使用归一化系数 $N_u^{\\mathrm{val}} = 2.0$, $N_d^{\\mathrm{val}} = 1.0$, $N_u^{\\mathrm{sea}} = 0.10$, $N_d^{\\mathrm{sea}} = 0.10$, $N_s^{\\mathrm{sea}} = 0.06$, $N_c^{\\mathrm{sea}} = 0.02$。\n  将味夸克PDF及其反夸克定义为\n  $f_u(x,\\mu_F) = f_u^{\\mathrm{val}}(x,\\mu_F) + f_u^{\\mathrm{sea}}(x,\\mu_F)$, $f_d(x,\\mu_F) = f_d^{\\mathrm{val}}(x,\\mu_F) + f_d^{\\mathrm{sea}}(x,\\mu_F)$,\n  $f_s(x,\\mu_F) = f_s^{\\mathrm{sea}}(x,\\mu_F)$, $f_c(x,\\mu_F) = f_c^{\\mathrm{sea}}(x,\\mu_F)$，对于反夸克 $f_{\\bar{q}}(x,\\mu_F) = f_q^{\\mathrm{sea}}(x,\\mu_F)$，其中 $q \\in \\{u,d,s,c\\}$。强制当 $x \\not\\in (0,1)$ 或 $\\mu_F \\le \\Lambda$ 时，$f_i(x,\\mu_F) = 0$。\n\n- 使用共同的重整化标度 $\\mu_R = \\mu_F$，对短程硬散射系数 $H_{ij}(Q^2,\\mu_R)$ 在领头阶加上领头重整化标度对数进行建模。设 $H_{ij}(Q^2,\\mu_R) = K_{\\mathrm{proc}}\\, w_{ij} \\left[1 + \\alpha_s(\\mu_R)\\, \\ln\\left(Q^2/\\mu_R^2\\right)\\right]$，其中 $K_{\\mathrm{proc}}$ 是一个过程归一化常数，$w_{ij}$ 编码了电弱荷和味选择定则。使用 $K_{\\gamma^*} = 1$ 和 $K_{W^\\pm} = 1$（无量纲归一化）。对于 $\\gamma^*$ 产生，允许的道是 $q \\bar{q}$，其 $w_{q \\bar{q}} = e_q^2$，其中 $e_u = +\\frac{2}{3}$, $e_d = e_s = e_c = -\\frac{1}{3}$。对于 $W^+$ 产生，允许的道是 $u \\bar{d}$ 和 $c \\bar{s}$，其 $w_{u \\bar{d}} = |V_{ud}|^2$ 和 $w_{c \\bar{s}} = |V_{cs}|^2$。对于 $W^-$ 产生，允许的道是 $d \\bar{u}$ 和 $s \\bar{c}$，其 $w_{d \\bar{u}} = |V_{ud}|^2$ 和 $w_{s \\bar{c}} = |V_{cs}|^2$。使用 Cabibbo–Kobayashi–Maskawa (CKM) 值 $|V_{ud}| = 0.974$ 和 $|V_{cs}| = 0.973$。\n\n- 通过对允许的道进行求和（包括两种束流次序），推导并实现每个过程的领头阶快度微分截面。对于给定 $Q$、$y$、$\\sqrt{S}$ 和 $\\mu_F$ 下，具有道 $(i,j)$ 的过程，定义\n  $d\\sigma_{\\mathrm{proc}}(Q,y,\\mu_F;\\sqrt{S}) = \\sum_{(i,j)\\in \\mathrm{channels}} H_{ij}(Q^2,\\mu_F)\\, \\left[f_i(x_1,\\mu_F)\\, f_j(x_2,\\mu_F) + f_i(x_2,\\mu_F)\\, f_j(x_1,\\mu_F)\\right]$。\n  在此归一化下，该可观测量是无量纲的。如果 $x_1$ 或 $x_2$ 位于 $(0,1)$ 之外，则设 $d\\sigma_{\\mathrm{proc}} = 0$。\n\n为检验部分子分布函数（PDF）的普适性，在 $\\gamma^*$ 和 $W^\\pm$ 过程中使用相同的 $f_i(x,\\mu_F)$，并协同地改变共同的 $\\mu_F$ 以引发标度变化。对于下述每个测试案例，定义三点标度集 $\\mu_F \\in \\{0.5 Q, Q, 2 Q\\}$，并计算 $\\gamma^*$ 以及 $W^+$ 和 $W^-$ 各自的截面数组。然后，使用列表 $\\{g_k\\}$ 和 $\\{w_k\\}$（其中 $k \\in \\{1,2,3\\}$）的标准定义，计算 $\\gamma^*$ 与 $W^+$ 之间以及 $\\gamma^*$ 与 $W^-$ 之间的标度依赖性的皮尔逊相关系数：\n$\\rho = \\frac{\\sum_k \\left(g_k - \\bar{g}\\right)\\left(w_k - \\bar{w}\\right)}{\\sqrt{\\sum_k \\left(g_k - \\bar{g}\\right)^2}\\, \\sqrt{\\sum_k \\left(w_k - \\bar{w}\\right)^2}}$,\n其中 $\\bar{g}$ 和 $\\bar{w}$ 是在这三个标度上的算术平均值。\n\n运动学点的测试集，所有能量单位均为 $\\mathrm{GeV}$：\n- 案例 1：$\\sqrt{S} = 13000$, $Q = 80$, $y = 0$。\n- 案例 2：$\\sqrt{S} = 13000$, $Q = 10$, $y = 2$。\n- 案例 3：$\\sqrt{S} = 13000$, $Q = 80$, $y = 4$。\n- 案例 4：$\\sqrt{S} = 200$, $Q = 60$, $y = 0$。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。该列表必须按顺序包含每个案例的 $(\\gamma^*,W^+)$ 和 $(\\gamma^*,W^-)$ 的 $\\rho$ 值，因此输出顺序为\n$[\\rho_{1}^{+}, \\rho_{1}^{-}, \\rho_{2}^{+}, \\rho_{2}^{-}, \\rho_{3}^{+}, \\rho_{3}^{-}, \\rho_{4}^{+}, \\rho_{4}^{-}]$。\n所有输出均为无量纲浮点数。不涉及角度，因此无需指定角度单位。所采用的无量纲归一化不需要物理单位。",
            "solution": "目标是构建并实现一个计算，通过改变共同标度并量化其引发的变化如何相关，从而揭示部分子分布函数（PDF）在不同强子过程中的普适性。其概念基础是量子色动力学（QCD）中的共线因子分解定理，该定理指出，在领头幂次下，包容性强子截面可以因子分解为短程硬散射系数和长程部分子分布函数（PDF）分量。对于从质心能量为 $\\sqrt{S}$ 的质子-质子对撞中、在快度为 $y$ 处产生一个不变质量为 $Q$ 的玻色子，领头阶运动学将入射部分子的动量分数固定为 $x_1 = \\frac{Q}{\\sqrt{S}} e^{y}$ 和 $x_2 = \\frac{Q}{\\sqrt{S}} e^{-y}$。当 $x_1$ 或 $x_2$ 之一位于 $(0,1)$ 之外时，该过程在运动学上是被禁止的，在我们的归一化中，其截面被设为 $0$。\n\n从因子分解定理出发，我们识别并分离出两种成分：\n\n- 短程硬散射系数 $H_{ij}(Q^2,\\mu_R)$，它捕捉与部分子过程 $i+j \\to \\mathrm{boson}$ 相关的微扰贡献，并依赖于重整化标度 $\\mu_R$。在领头阶， $H_{ij}$ 与电弱荷的平方成正比。为了编码领头的重整化标度敏感性，我们通过增加第一个对数增强项来扩充领头阶表达式，得到 $H_{ij}(Q^2,\\mu_R) = K_{\\mathrm{proc}}\\, w_{ij} \\left[1 + \\alpha_s(\\mu_R)\\, \\ln\\left(Q^2/\\mu_R^2\\right)\\right]$，其中 $K_{\\gamma^*} = 1$ 和 $K_{W^\\pm} = 1$ 用于无量纲归一化，$w_{ij}$ 源自电弱荷和 Cabibbo–Kobayashi–Maskawa (CKM) 矩阵。对于 $\\gamma^*$，$w_{q\\bar{q}} = e_q^2$，其中 $e_u = +\\frac{2}{3}$ 且 $e_d = e_s = e_c = -\\frac{1}{3}$。对于 $W^+$，允许的道是 $u \\bar{d}$ 和 $c \\bar{s}$，其权重为 $w_{u \\bar{d}} = |V_{ud}|^2$ 和 $w_{c \\bar{s}} = |V_{cs}|^2$。对于 $W^-$，允许的道是 $d \\bar{u}$ 和 $s \\bar{c}$，其权重为 $w_{d \\bar{u}} = |V_{ud}|^2$ 和 $w_{s \\bar{c}} = |V_{cs}|^2$。我们设置 $|V_{ud}| = 0.974$ 和 $|V_{cs}| = 0.973$。\n\n- 长程部分子分布函数 $f_i(x,\\mu_F)$，它编码了非微扰的质子结构并依赖于因子分解标度 $\\mu_F$。虽然真实的PDF需要全局拟合和DGLAP演化，我们采用一个玩具函数形式，但它仍遵循关键的定性特征：随着 $\\mu_F$ 的增加而增强的小-$x$ 增长和大-$x$ 压低。对于夸克味 $u$ 和 $d$，我们同时包含价部分子和海部分子，而对于 $s$ 和 $c$，我们只包含海部分子。我们定义一个价形状 $f_q^{\\mathrm{val}}(x,\\mu_F) = N_q^{\\mathrm{val}}\\, x^{-a_v(\\mu_F)} (1-x)^{b_v(\\mu_F)}$ 和一个海形状 $f_q^{\\mathrm{sea}}(x,\\mu_F) = N_q^{\\mathrm{sea}}\\, x^{-a_s(\\mu_F)} (1-x)^{b_s(\\mu_F)}$，其指数为 $a_v(\\mu_F) = a_{v,0} + \\alpha_v \\ln\\left(\\mu_F/\\mu_0\\right)$、$b_v(\\mu_F) = b_{v,0} - \\beta_v \\ln\\left(\\mu_F/\\mu_0\\right)$ 以及 $a_s(\\mu_F) = a_{s,0} + \\alpha_s^{\\mathrm{exp}} \\ln\\left(\\mu_F/\\mu_0\\right)$、$b_s(\\mu_F) = b_{s,0} - \\beta_s^{\\mathrm{exp}} \\ln\\left(\\mu_F/\\mu_0\\right)$，取 $\\mu_0 = 2\\,\\mathrm{GeV}$、$a_{v,0} = 0.3$、$\\alpha_v = 0.03$、$b_{v,0} = 3.0$、$\\beta_v = 0.1$、$a_{s,0} = 0.7$、$\\alpha_s^{\\mathrm{exp}} = 0.05$、$b_{s,0} = 5.0$、$\\beta_s^{\\mathrm{exp}} = 0.2$。归一化系数为 $N_u^{\\mathrm{val}} = 2.0$、$N_d^{\\mathrm{val}} = 1.0$、$N_u^{\\mathrm{sea}} = 0.10$、$N_d^{\\mathrm{sea}} = 0.10$、$N_s^{\\mathrm{sea}} = 0.06$、$N_c^{\\mathrm{sea}} = 0.02$。反夸克分布与海部分子等同，$f_{\\bar{q}}(x,\\mu_F) = f_q^{\\mathrm{sea}}(x,\\mu_F)$，这反映了质子中不存在价反夸克。我们强制要求如果 $x \\not\\in (0,1)$ 或 $\\mu_F \\le \\Lambda$，则 $f_i(x,\\mu_F) = 0$，以确保运动学和标度的一致性。\n\n强耦合常数 $\\alpha_s(\\mu)$ 在单圈水平上使用经过充分检验的公式 $\\alpha_s(\\mu) = \\left[\\beta_0 \\ln\\left(\\mu^2/\\Lambda^2\\right)\\right]^{-1}$ 来实现，其中 $\\beta_0 = \\frac{33 - 2 n_f}{12 \\pi}$，$n_f = 5$，且 $\\Lambda = 0.2\\,\\mathrm{GeV}$。这捕捉了渐近自由行为：$\\alpha_s$ 随着 $\\mu$ 的增加而减小。\n\n有了这些成分，对于给定的 $Q$、$y$、$\\sqrt{S}$ 和 $\\mu_F$，过程“proc”的领头阶快度微分截面具有因子分解形式\n$d\\sigma_{\\mathrm{proc}}(Q,y,\\mu_F;\\sqrt{S}) = \\sum_{(i,j)\\in \\mathrm{channels}} H_{ij}(Q^2,\\mu_F)\\, \\left[f_i(x_1,\\mu_F)\\, f_j(x_2,\\mu_F) + f_i(x_2,\\mu_F)\\, f_j(x_1,\\mu_F)\\right]$，\n其中求和遍及该过程允许的味夸克道，并包括两种束流次序。因为PDF在不同过程中是相同的，并且使用相同的 $\\mu_F$，所以由改变 $\\mu_F$ 引起的任何标度变化将通过共同的 $f_i(x,\\mu_F)$ 和 $H_{ij}(Q^2,\\mu_F)$ 中相似的对数依赖性在不同过程之间产生关联。\n\n量化标度不确定性相关性的算法如下：\n\n- 对于每个测试案例 $(\\sqrt{S}, Q, y)$，计算 $x_1 = \\frac{Q}{\\sqrt{S}} e^{y}$ 和 $x_2 = \\frac{Q}{\\sqrt{S}} e^{-y}$。如果 $x_1 \\not\\in (0,1)$ 或 $x_2 \\not\\in (0,1)$，则将该案例的所有截面设为 $0$。\n\n- 定义共同的标度集 $\\mu_F \\in \\{0.5 Q, Q, 2 Q\\}$，并对每个标度计算 $\\alpha_s(\\mu_F)$、相关过程和道的 $H_{ij}(Q^2,\\mu_F)$，以及PDF $f_i(x,\\mu_F)$ 和 $f_j(x,\\mu_F)$。\n\n- 对三个 $\\mu_F$ 值中的每一个，评估 $d\\sigma_{\\gamma^*}(Q,y,\\mu_F;\\sqrt{S})$ 和 $d\\sigma_{W^\\pm}(Q,y,\\mu_F;\\sqrt{S})$。\n\n- 将 $\\gamma^*$ 的三个值记为 $\\{g_k\\}$，将 $W^+$ 的值记为 $\\{w_k^{+}\\}$，类似地，$W^-$ 的值为 $\\{w_k^{-}\\}$。计算皮尔逊相关系数\n$\\rho^{+} = \\frac{\\sum_k (g_k - \\bar{g})(w_k^{+} - \\bar{w}^{+})}{\\sqrt{\\sum_k (g_k - \\bar{g})^2}\\sqrt{\\sum_k (w_k^{+} - \\bar{w}^{+})^2}}$ 和\n$\\rho^{-} = \\frac{\\sum_k (g_k - \\bar{g})(w_k^{-} - \\bar{w}^{-})}{\\sqrt{\\sum_k (g_k - \\bar{g})^2}\\sqrt{\\sum_k (w_k^{-} - \\bar{w}^{-})^2}}$，\n其中 $\\bar{g}$、$\\bar{w}^{+}$ 和 $\\bar{w}^{-}$ 是三个标度上的算术平均值。如果分母中的任何一个标准差为零（表示没有变化），则将相关性定义为 $0$。\n\n此过程通过在不同过程中应用相同的部分子分布函数（PDF）并协同改变标度来分离出普适性检验；相关系数 $\\rho^{\\pm}$ 量化了这两个过程对共同 $\\mu_F$ 变化的响应相似程度。因为 $pp \\to \\gamma^*$ 和 $pp \\to W^\\pm$ 共享由电弱权重区分的 $q\\bar{q}$ 初态道，并且都依赖于相同的PDF和相似的对数硬系数，我们预期在大多数运动学区域中存在强的正相关。差异可能源于味的选择性（例如 $W^\\pm$ 主要耦合到特定的夸克组合）以及某些运动学区域，在这些区域中，一个过程主要由价-海相互作用主导，而另一个过程则取样不同的味混合。\n\n该实现直接遵循这些推导，并为指定的测试集计算相关性列表 $[\\rho_{1}^{+}, \\rho_{1}^{-}, \\rho_{2}^{+}, \\rho_{2}^{-}, \\rho_{3}^{+}, \\rho_{3}^{-}, \\rho_{4}^{+}, \\rho_{4}^{-}]$，作为一行用方括号括起来的无量纲浮点数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Constants for QCD running and electroweak inputs\nLAMBDA_QCD = 0.2  # GeV\nN_F = 5\nBETA0 = (33.0 - 2.0 * N_F) / (12.0 * np.pi)\n\n# CKM elements\nV_ud = 0.974\nV_cs = 0.973\n\n# Electric charges squared for gamma*\nCHARGE2 = {\n    'u': (2.0/3.0)**2,\n    'd': (1.0/3.0)**2,  # sign does not matter when squaring\n    's': (1.0/3.0)**2,\n    'c': (2.0/3.0)**2\n}\n\n# PDF parameters\nMU0 = 2.0  # GeV\n# Valence exponents\na_v0 = 0.3\nalpha_v = 0.03\nb_v0 = 3.0\nbeta_v = 0.1\n# Sea exponents\na_s0 = 0.7\nalpha_s_exp = 0.05\nb_s0 = 5.0\nbeta_s_exp = 0.2\n# Normalizations\nN_val = {'u': 2.0, 'd': 1.0}\nN_sea = {'u': 0.10, 'd': 0.10, 's': 0.06, 'c': 0.02}\n\ndef alpha_s(mu):\n    \"\"\"One-loop running strong coupling.\"\"\"\n    if mu = LAMBDA_QCD:\n        # Unphysical; return a large value to flag but code will avoid using mu = Lambda\n        return np.inf\n    return 1.0 / (BETA0 * np.log((mu * mu) / (LAMBDA_QCD * LAMBDA_QCD)))\n\ndef exponents(mu):\n    \"\"\"Compute valence and sea exponents at scale mu.\"\"\"\n    t = np.log(mu / MU0)\n    a_v = a_v0 + alpha_v * t\n    b_v = b_v0 - beta_v * t\n    a_s = a_s0 + alpha_s_exp * t\n    b_s = b_s0 - beta_s_exp * t\n    return a_v, b_v, a_s, b_s\n\ndef pdf_quark(name, x, mu):\n    \"\"\"Toy PDF for quarks and antiquarks name in {'u','d','s','c','ubar','dbar','sbar','cbar'}.\"\"\"\n    if x = 0.0 or x >= 1.0 or mu = LAMBDA_QCD:\n        return 0.0\n    a_v, b_v, a_s, b_s = exponents(mu)\n    # Handle antiquarks: only sea component\n    is_bar = name.endswith('bar')\n    base = name[:-3] if is_bar else name\n    # Compute sea component\n    if base in N_sea:\n        f_sea = N_sea[base] * (x ** (-a_s)) * ((1.0 - x) ** b_s)\n    else:\n        f_sea = 0.0\n    if is_bar:\n        return f_sea\n    # Quark: add valence if u or d\n    if base in N_val:\n        f_val = N_val[base] * (x ** (-a_v)) * ((1.0 - x) ** b_v)\n    else:\n        f_val = 0.0\n    return f_val + f_sea\n\ndef hard_weight_gamma(channel):\n    \"\"\"Electromagnetic weight e_q^2 for q qbar channels.\"\"\"\n    q, qbar = channel\n    base_q = q.replace('bar', '')\n    # Allowed only q with corresponding antiquark of same flavor\n    if qbar != base_q + 'bar':\n        return 0.0\n    return CHARGE2.get(base_q, 0.0)\n\ndef hard_weight_Wplus(channel):\n    \"\"\"Weights for W+ channels: u dbar and c sbar.\"\"\"\n    i, j = channel\n    if i == 'u' and j == 'dbar':\n        return V_ud**2\n    if i == 'c' and j == 'sbar':\n        return V_cs**2\n    return 0.0\n\ndef hard_weight_Wminus(channel):\n    \"\"\"Weights for W- channels: d ubar and s cbar.\"\"\"\n    i, j = channel\n    if i == 'd' and j == 'ubar':\n        return V_ud**2\n    if i == 's' and j == 'cbar':\n        return V_cs**2\n    return 0.0\n\ndef hard_coefficient(Q, mu, weight):\n    \"\"\"Hard coefficient H_ij(Q^2, mu) = K_proc * w_ij * (1 + alpha_s(mu) * ln(Q^2/mu^2)).\"\"\"\n    as_mu = alpha_s(mu)\n    # If alpha_s is inf due to invalid mu, return 0\n    if not np.isfinite(as_mu):\n        return 0.0\n    return weight * (1.0 + as_mu * np.log((Q*Q) / (mu*mu)))\n\ndef dsigma_process(Q, y, sqrtS, mu, process):\n    \"\"\"Compute dimensionless LO rapidity-differential cross section for given process.\"\"\"\n    # Kinematics\n    x1 = (Q / sqrtS) * np.exp(y)\n    x2 = (Q / sqrtS) * np.exp(-y)\n    if not (0.0  x1  1.0 and 0.0  x2  1.0):\n        return 0.0\n    # Define channels and weight functions\n    if process == 'gamma':\n        # q qbar for q in {u,d,s,c}\n        channels = [('u', 'ubar'), ('d', 'dbar'), ('s', 'sbar'), ('c', 'cbar')]\n        weight_fn = hard_weight_gamma\n    elif process == 'Wplus':\n        channels = [('u', 'dbar'), ('c', 'sbar')]\n        weight_fn = hard_weight_Wplus\n    elif process == 'Wminus':\n        channels = [('d', 'ubar'), ('s', 'cbar')]\n        weight_fn = hard_weight_Wminus\n    else:\n        raise ValueError(\"Unknown process\")\n    total = 0.0\n    for (i, j) in channels:\n        w_ij = weight_fn((i, j))\n        if w_ij == 0.0:\n            continue\n        H = hard_coefficient(Q, mu, w_ij)\n        # Sum both beam orderings\n        fi_x1 = pdf_quark(i, x1, mu)\n        fj_x2 = pdf_quark(j, x2, mu)\n        fi_x2 = pdf_quark(i, x2, mu)\n        fj_x1 = pdf_quark(j, x1, mu)\n        total += H * (fi_x1 * fj_x2 + fi_x2 * fj_x1)\n    return float(total)\n\ndef pearson_corr(a, b):\n    \"\"\"Pearson correlation coefficient between arrays a and b of length >= 2.\"\"\"\n    a = np.asarray(a, dtype=float)\n    b = np.asarray(b, dtype=float)\n    ma = np.mean(a)\n    mb = np.mean(b)\n    da = a - ma\n    db = b - mb\n    sa = np.sqrt(np.sum(da*da))\n    sb = np.sqrt(np.sum(db*db))\n    if sa == 0.0 or sb == 0.0:\n        return 0.0\n    return float(np.sum(da*db) / (sa * sb))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (sqrtS [GeV], Q [GeV], y)\n    test_cases = [\n        (13000.0, 80.0, 0.0),  # Case 1\n        (13000.0, 10.0, 2.0),  # Case 2\n        (13000.0, 80.0, 4.0),  # Case 3\n        (200.0,   60.0, 0.0),  # Case 4\n    ]\n\n    # Scale variation factors\n    kappa = [0.5, 1.0, 2.0]\n\n    results = []\n    for sqrtS, Q, y in test_cases:\n        # Compute cross sections at the three scales for gamma*, W+, W-\n        sig_gamma = []\n        sig_Wp = []\n        sig_Wm = []\n        for k in kappa:\n            muF = k * Q\n            sig_gamma.append(dsigma_process(Q, y, sqrtS, muF, 'gamma'))\n            sig_Wp.append(dsigma_process(Q, y, sqrtS, muF, 'Wplus'))\n            sig_Wm.append(dsigma_process(Q, y, sqrtS, muF, 'Wminus'))\n        # Compute correlations\n        rho_plus = pearson_corr(sig_gamma, sig_Wp)\n        rho_minus = pearson_corr(sig_gamma, sig_Wm)\n        results.append(rho_plus)\n        results.append(rho_minus)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了获得更高的精度，理论预测必须在 QCD 的次领头阶 (NLO) 进行计算，但这会引入必须小心消除的红外奇异性。本实践将指导你实现 Catani-Seymour 偶极子减除法，这是一种以数值稳定的方式处理这些奇异性的基石技术。通过这个玩具模型，你将亲身体验现代高精度物理计算所需的复杂方法。",
            "id": "3514222",
            "problem": "您的任务是在代码中实现一个减除框架，该框架能够捕捉量子色动力学（QCD）红外奇异点在次领头阶（NLO）Drell-Yan 产生过程的部分子通道（$q\\bar{q}\\to \\gamma^* g$）中的普适因子分解结构。您的目标是数值验证，对于一组测试输入，经过 Catani–Seymour 偶极减除后的实发射贡献与虚部加质量因子分解抵消项之和是有限的。\n\n基础和范围：\n- 从强子截面的因子分解定理以及量子色动力学（QCD）的普适红外结构出发。使用领头阶 Altarelli–Parisi 分裂函数来描述夸克到夸克-胶子的分裂，定义为\n  $$\n  P_{qq}(z) = C_F \\frac{1+z^2}{1-z},\n  $$\n  其中 $z \\in (0,1)$ 是共线发射后夸克携带的动量分数，$C_F$ 是基本表示下的二次 Casimir 算子。在下面的玩具模型中，设置 $C_F = 1$ 和一个等于 $1$ 的总归一化常数，以保持可观测量无量纲。\n- 在部分子层面，针对初态奇异点使用 Catani–Seymour 减除思想。在部分子质心系中，考虑入射夸克沿 $+z$ 方向，入射反夸克沿 $-z$ 方向。用 $\\theta$ 表示出射胶子相对于入射夸克的散射角，并定义 $c \\equiv \\cos\\theta \\in [-1,1]$。软区对应于 $z \\to 1$，而两个共线区分别对应于 $c \\to +1$（与入射夸克共线）和 $c \\to -1$（与入射反夸克共线）。\n- 定义一个玩具 Catani–Seymour 偶极核，它能够重现实发射矩阵元平方的正确软奇异和共线奇异行为：\n  $$\n  \\mathcal{D}(z,c) \\equiv \\frac{1+z^2}{1-z}\\left(\\frac{1}{1-c} + \\frac{1}{1+c}\\right).\n  $$\n  除了某些总体因子，它包含了正确的 $z\\to 1$ 和 $c\\to \\pm 1$ 奇异点。\n- 定义一个玩具实发射微分密度，它包含与物理矩阵元相同的奇异点以及一个有限的余项：\n  $$\n  \\mathcal{R}(z,c) \\equiv \\mathcal{D}(z,c) + f_{\\mathrm{fin}}(z), \\quad f_{\\mathrm{fin}}(z) \\equiv 1 - z.\n  $$\n  这个构造与奇异点的因子分解是一致的：差值 $\\mathcal{R}-\\mathcal{D}$ 在四维中是可积的，并且在相空间的任何地方都是有限的。\n- 在减除形式主义中，NLO 部分子截面可以示意性地表示为\n  $$\n  \\sigma^{\\mathrm{NLO}} = \\underbrace{\\int_{z_{\\min}}^{1}\\int_{-1}^{1}\\left[\\mathcal{R}(z,c) - \\mathcal{D}(z,c)\\right]\\mathrm{d}c\\,\\mathrm{d}z}_{\\sigma_{\\mathrm{real}}^{\\mathrm{sub}}}\n  + \\underbrace{\\left(\\sigma_{\\mathrm{virt}} + \\sigma_{\\mathrm{int.\\,dipole}} + \\sigma_{\\mathrm{mf}}\\right)}_{\\sigma_{\\mathrm{counter}}}.\n  $$\n  此处 $\\sigma_{\\mathrm{virt}}$ 表示虚修正，$\\sigma_{\\mathrm{int.\\,dipole}}$ 表示积分后的偶极贡献，$\\sigma_{\\mathrm{mf}}$ 表示质量因子分解抵消项，它将初态共线奇异点吸收到部分子分布函数（PDF）中。在这个玩具模型中，您需要假设一个有限的重整化方案，使得虚部和质量因子分解抵消项与积分偶极项之和是有限且为零：\n  $$\n  \\sigma_{\\mathrm{counter}} = 0.\n  $$\n  这个选择反映了在将这些部分相加后，所有的红外奇异点都被移除了，只留下一个来自 $\\sigma_{\\mathrm{real}}^{\\mathrm{sub}}$ 的有限贡献。\n\n数值实现要求：\n- 为 $\\sigma_{\\mathrm{real}}^{\\mathrm{sub}}$ 实现一个稳定的数值积分器，对 $z$ 和 $c$ 都使用高斯-勒让德求积法。您必须计算\n  $$\n  \\sigma_{\\mathrm{real}}^{\\mathrm{sub}}(z_{\\min}) = \\int_{z_{\\min}}^{1}\\int_{-1}^{1}\\left[\\mathcal{R}(z,c) - \\mathcal{D}(z,c)\\right]\\mathrm{d}c\\,\\mathrm{d}z.\n  $$\n- 为了模拟蒙特卡洛事件生成器中常见的数值稳定性保障措施，在计算形如 $1-c$、$1+c$ 或 $1-z$ 的分母时，您必须使用用户指定的微小正参数 $\\varepsilon_c$ 和 $\\varepsilon_z$ 将它们正则化为 $1-c \\to 1-c+\\varepsilon_c$、$1+c\\to 1+c+\\varepsilon_c$ 和 $1-z\\to 1-z+\\varepsilon_z$。减除法的物理原理保证了最终的被减除被积函数是有限的，并且在 $\\varepsilon_c$ 和 $\\varepsilon_z$ 趋于无穷小的极限下，积分结果不依赖于这些调节子。\n- 因为 $\\mathcal{R}(z,c) - \\mathcal{D}(z,c) = f_{\\mathrm{fin}}(z) = 1-z$ 是有限的且不依赖于 $c$，所以积分后的减除实发射部分的精确值为\n  $$\n  \\sigma_{\\mathrm{real}}^{\\mathrm{sub}}(z_{\\min}) = \\int_{z_{\\min}}^{1}\\int_{-1}^{1}(1-z)\\,\\mathrm{d}c\\,\\mathrm{d}z = 1 - 2 z_{\\min} + z_{\\min}^2,\n  $$\n  这是一个有用的交叉检验，但不应将其硬编码为结果。您的代码必须通过对 $\\mathcal{R}-\\mathcal{D}$ 进行积分来数值计算该积分。\n- 对于这个问题，您必须将实部、虚部和质量因子分解抵消项的总和视为\n  $$\n  \\sigma_{\\mathrm{total}}(z_{\\min};\\varepsilon_c,\\varepsilon_z) \\equiv \\sigma_{\\mathrm{real}}^{\\mathrm{sub}}(z_{\\min}) + \\sigma_{\\mathrm{counter}} = \\sigma_{\\mathrm{real}}^{\\mathrm{sub}}(z_{\\min}),\n  $$\n  并通过数值方法证明其是有限的且不依赖于调节子。\n\n角度和单位约定：\n- 所有角度都应以弧度处理。输出的可观测量是无量纲的。\n\n测试套件：\n- 使用以下四个测试用例，它们探测了典型区域、边界区域以及对调节子的不依赖性：\n  1. $z_{\\min} = 0.2$，$\\varepsilon_c = 10^{-6}$，$\\varepsilon_z = 10^{-9}$。\n  2. $z_{\\min} = 0.95$，$\\varepsilon_c = 10^{-6}$，$\\varepsilon_z = 10^{-12}$。\n  3. $z_{\\min} = 0.2$，$\\varepsilon_c = 10^{-12}$，$\\varepsilon_z = 10^{-6}$。\n  4. $z_{\\min} = 0.5$，$\\varepsilon_c = 10^{-9}$，$\\varepsilon_z = 10^{-9}$。\n\n所需输出：\n- 对每个测试用例，计算单个浮点数\n  $$\n  \\sigma_{\\mathrm{total}}(z_{\\min};\\varepsilon_c,\\varepsilon_z).\n  $$\n- 您的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[result1,result2,result3,result4]\"）。结果的顺序必须与上面列出的测试套件的顺序相同。\n\n实现约束：\n- 您必须对 $z$ 和 $c$ 的积分都实现高斯-勒让德求积法，每个积分至少使用 32 个节点，以确保数值稳定性和准确性。\n- 您的实现必须是完全确定性的，不使用任何随机性，并且不应需要任何用户输入。",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于量子色动力学（QCD）的原理，特别是红外奇异点的因子分解和 Catani-Seymour 偶极减除方法。它提出了一个适定、自洽的数值问题，具有清晰的定义、约束和目标。该玩具模型虽然经过简化，但在概念上是合理的，并为减除形式主义的数值实现提供了严格的测试。\n\n任务是针对一个 Drell-Yan 产生的玩具模型 $q\\bar{q}\\to \\gamma^* g$，数值计算减除后的实发射对次领头阶（NLO）部分子截面的贡献。该可观测量记为 $\\sigma_{\\mathrm{real}}^{\\mathrm{sub}}(z_{\\min})$，并且需要计算其与其它 NLO 贡献的总和 $\\sigma_{\\mathrm{total}}$。问题通过假定虚修正和抵消项之和为零（$\\sigma_{\\mathrm{counter}} = 0$）来简化计算，这在玩具模型中是一个有效的假设。因此，要计算的量是\n$$\n\\sigma_{\\mathrm{total}}(z_{\\min};\\varepsilon_c,\\varepsilon_z) = \\sigma_{\\mathrm{real}}^{\\mathrm{sub}}(z_{\\min}) = \\int_{z_{\\min}}^{1}\\int_{-1}^{1}\\left[\\mathcal{R}(z,c) - \\mathcal{D}(z,c)\\right]\\mathrm{d}c\\,\\mathrm{d}z.\n$$\n函数 $\\mathcal{R}(z,c)$ 和 $\\mathcal{D}(z,c)$ 定义为：\n$$\n\\mathcal{D}(z,c) \\equiv \\frac{1+z^2}{1-z}\\left(\\frac{1}{1-c} + \\frac{1}{1+c}\\right)\n$$\n$$\n\\mathcal{R}(z,c) \\equiv \\mathcal{D}(z,c) + f_{\\mathrm{fin}}(z), \\quad \\text{with } f_{\\mathrm{fin}}(z) = 1 - z.\n$$\n减除法的一个关键特征是，虽然 $\\mathcal{R}(z,c)$ 和 $\\mathcal{D}(z,c)$ 在软极限（$z \\to 1$）和共线极限（$c \\to \\pm 1$）中各自是奇异的，但它们的差值在任何地方都是有限的：\n$$\n\\mathcal{R}(z,c) - \\mathcal{D}(z,c) = 1 - z.\n$$\n问题要求对这种抵消进行数值演示。我们必须数值计算正则化后的表达式，其中分母由微小的正参数 $\\varepsilon_z$ 和 $\\varepsilon_c$ 保护。正则化后的偶极项是\n$$\n\\mathcal{D}_{\\mathrm{reg}}(z,c; \\varepsilon_c, \\varepsilon_z) = \\frac{1+z^2}{1-z+\\varepsilon_z}\\left(\\frac{1}{1-c+\\varepsilon_c} + \\frac{1}{1+c+\\varepsilon_c}\\right).\n$$\n正则化后的实发射项为 $\\mathcal{R}_{\\mathrm{reg}}(z,c; \\varepsilon_c, \\varepsilon_z) = \\mathcal{D}_{\\mathrm{reg}}(z,c; \\varepsilon_c, \\varepsilon_z) + (1 - z)$。必须在每个计算点上对差值 $\\mathcal{R}_{\\mathrm{reg}} - \\mathcal{D}_{\\mathrm{reg}}$ 执行数值积分。这个过程测试了减除法的数值稳定性，因为单个正则化项在奇异区域附近可能会变得非常大，而它们的差值仍必须得出正确的有限结果。\n\n如所指定，对 $z$ 和 $c$ 的积分都将使用高斯-勒让德求积法进行。函数 $F(z,c)$ 在区域 $[z_{\\min}, 1] \\times [-1, 1]$ 上的二重积分近似为：\n$$\n\\int_{z_{\\min}}^{1}\\int_{-1}^{1} F(z,c) \\,\\mathrm{d}c\\,\\mathrm{d}z \\approx \\frac{1-z_{\\min}}{2} \\sum_{i=1}^{N_z} w_i^z \\left( \\frac{1-(-1)}{2} \\sum_{j=1}^{N_c} w_j^c F(z_i, c_j) \\right)\n$$\n其中 $(x_k, w_k)$ 是区间 $[-1, 1]$ 上的 $N$ 点高斯-勒让德节点和权重。积分变量 $z_i$ 和 $c_j$ 是通过将标准节点 $x_k$ 映射到各自的积分区间得到的：\n$$\nz_i = \\frac{1-z_{\\min}}{2}x_i^z + \\frac{1+z_{\\min}}{2} \\quad \\text{and} \\quad c_j = x_j^c.\n$$\n问题指定至少使用 $N_z = N_c = 32$ 个节点。实现将对两个维度都使用 $N=32$ 个节点。所需的节点和权重将从 `scipy.special.roots_legendre` 中获得。将对每个测试用例进行计算，并且结果应与积分的解析值一致，这可作为一个关键的交叉检验：\n$$\n\\sigma_{\\mathrm{real}}^{\\mathrm{sub}}(z_{\\min}) = \\int_{z_{\\min}}^{1}\\int_{-1}^{1}(1-z)\\,\\mathrm{d}c\\,\\mathrm{d}z = 2 \\int_{z_{\\min}}^{1}(1-z)\\,\\mathrm{d}z = 2\\left[z - \\frac{z^2}{2}\\right]_{z_{\\min}}^1 = (1-z_{\\min})^2.\n$$\n数值结果预期将非常接近这个解析公式，这表明减除方案被正确实现且数值稳定，并且结果不依赖于为调节子 $\\varepsilon_c$ 和 $\\varepsilon_z$ 选择的特定小值。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Calculates the total cross section for a toy QCD process\n    using the Catani-Seymour dipole subtraction method.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (z_min, eps_c, eps_z)\n        (0.2, 1e-6, 1e-9),\n        (0.95, 1e-6, 1e-12),\n        (0.2, 1e-12, 1e-6),\n        (0.5, 1e-9, 1e-9),\n    ]\n\n    # Set the number of nodes for Gauss-Legendre quadrature.\n    # The problem requires at least 32 nodes.\n    NUM_NODES = 32\n    nodes, weights = roots_legendre(NUM_NODES)\n\n    def D_regulated(z, c, eps_z, eps_c):\n        \"\"\"\n        Calculates the regulated toy Catani-Seymour dipole kernel D(z,c).\n        \"\"\"\n        term_z = (1.0 + z**2) / (1.0 - z + eps_z)\n        term_c = 1.0 / (1.0 - c + eps_c) + 1.0 / (1.0 + c + eps_c)\n        return term_z * term_c\n\n    def R_regulated(z, c, eps_z, eps_c):\n        \"\"\"\n        Calculates the regulated toy real-emission differential density R(z,c).\n        \"\"\"\n        return D_regulated(z, c, eps_z, eps_c) + (1.0 - z)\n\n    def calculate_sigma_total(z_min, eps_c, eps_z):\n        \"\"\"\n        Performs the 2D numerical integration of (R - D) using\n        Gauss-Legendre quadrature.\n        \"\"\"\n        # Map the standard [-1, 1] nodes to the integration intervals.\n        # For c, the interval is [-1, 1], so c_coords = nodes.\n        c_coords = nodes\n        # For z, the interval is [z_min, 1].\n        z_map_factor = 0.5 * (1.0 - z_min)\n        z_map_offset = 0.5 * (1.0 + z_min)\n        z_coords = z_map_factor * nodes + z_map_offset\n\n        # Create 2D grids for coordinates and weights for vectorized evaluation.\n        z_grid, c_grid = np.meshgrid(z_coords, c_coords, indexing='ij')\n        w_z_grid, w_c_grid = np.meshgrid(weights, weights, indexing='ij')\n\n        # Evaluate the regulated R and D functions on the grid.\n        # The core of the subtraction method is to compute the difference of the\n        # full expressions numerically at each point.\n        r_vals = R_regulated(z_grid, c_grid, eps_z, eps_c)\n        d_vals = D_regulated(z_grid, c_grid, eps_z, eps_c)\n\n        # The integrand is the difference, which should be finite.\n        integrand = r_vals - d_vals\n\n        # Perform the weighted sum over the 2D grid.\n        # The integration weight for the c-integral is (1 - (-1))/2 = 1.\n        # The integration weight for the z-integral is (1 - z_min)/2.\n        integral = np.sum(w_z_grid * w_c_grid * integrand) * z_map_factor\n\n        return integral\n\n    results = []\n    for case in test_cases:\n        z_min_val, eps_c_val, eps_z_val = case\n        # According to the problem, sigma_total = sigma_real_sub, as sigma_counter = 0.\n        sigma_total = calculate_sigma_total(z_min_val, eps_c_val, eps_z_val)\n        results.append(sigma_total)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}