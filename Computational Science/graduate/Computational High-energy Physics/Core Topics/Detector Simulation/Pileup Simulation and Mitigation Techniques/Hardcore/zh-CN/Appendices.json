{
    "hands_on_practices": [
        {
            "introduction": "在高能物理实验中，蒙特卡洛（MC）模拟的pileup环境与真实数据之间存在差异是一个普遍问题。解决该问题的第一步通常是对MC模拟进行校正，使其与数据保持一致。将指导你构建一个基于pileup相互作用数 $\\mu$ 的重加权方案，亲身体验如何通过校正pileup分布来直接影响例如触发效率等关键物理量。",
            "id": "3528671",
            "problem": "你的任务是在一个简化的、但基于物理现实的高能质子-质子对撞计算模型中，构建并评估一个自洽的堆积（pileup）重加权方案。目标是将蒙特卡洛（MC）的堆积多重数谱映射到一个目标“类数据”谱，评估其对触发器开启（trigger turn-on）行为的影响，并将非弹性质子-质子散射截面的不确定度传播到一个物理可观测量上。你的程序必须是一个完整的、可运行的实现，能够执行所有步骤，并为一组给定的测试用例返回所要求的量。\n\n基本原理和定义：\n- 每个束团穿越（bunch crossing）中额外的非弹性相互作用（即堆积）的数量被建模为一个泊松（Poisson）随机变量。对于给定的平均堆積多重数 $\\lambda$，其概率质量函数为\n$$\nP(k \\mid \\lambda) = \\frac{e^{-\\lambda}\\,\\lambda^k}{k!}, \\quad k \\in \\{0,1,2,\\dots\\}.\n$$\n- 一个将MC分布的变量 $X$ 重塑以匹配目标“类数据”分布的数据-MC重加权方案使用以下权重\n$$\nw(x) = \\frac{p_{\\text{data}}(x)}{p_{\\text{MC}}(x)},\n$$\n使得任何可积函数 $g$ 的加权MC期望值等于目标期望值：$\\mathbb{E}_{\\text{MC}}[w(X) g(X)] = \\mathbb{E}_{\\text{data}}[g(X)]$.\n- 具有有限分辨率的单个对象的触发器响应被建模为一个平滑的探测概率，它是离线横向动量 $p_T$ 的函数。我们使用逻辑斯谛函数（误差函数开启曲线的一个平滑近似）来描述，其参数包括阈值偏移和分辨率：\n$$\nS(p_T,\\mu) = \\frac{1}{1 + \\exp\\!\\left(-\\frac{p_T - T_0 - a\\,\\mu}{b}\\right)},\n$$\n其中 $T_0$ 是一个名义上的硬件阈值，$a$ 表示有效阈值随堆积多重数 $\\mu$ 的线性劣化程度，而 $b$ 控制开启曲线的陡峭程度。\n- 我们感兴趣的物理过程的遍举离线 $p_T$ 谱被建模为一个归一化的修正幂律分布，\n$$\nf(p_T) \\propto \\left(1 + \\frac{p_T}{p_0}\\right)^{-n}, \\quad p_T \\ge 0,\n$$\n其参数为 $p_0$ 和 $n$，且与 $\\mu$ 无关。\n\n每个测试用例需要实现的计算任务：\n1. 构建一个离散的堆积多重数网格 $\\mu \\in \\{0,1,2,\\dots,\\mu_{\\max}\\}$，其中 $\\mu_{\\max} = 200$。计算MC堆积分布 $p_{\\text{MC}}(\\mu)$（均值为 $\\lambda_{\\text{MC}}$ 的泊松分布）和目标“类数据”堆积分布 $p_{\\text{data}}(\\mu)$（均值为 $\\lambda_{\\text{data}}$ 的泊松分布）。将两者各自归一化，使其在截断的网格上求和为1。\n2. 在网格上定义权重 $w(\\mu) = p_{\\text{data}}(\\mu)/p_{\\text{MC}}(\\mu)$。使用这些权重构建一个加权堆积分布 $p_{\\text{w}}(\\mu)$，它与 $p_{\\text{MC}}(\\mu)\\,w(\\mu)$ 成正比，并将其归一化使其求和为1。\n3. 在一个横向动量网格 $p_T \\in \\{0,1,2,\\dots,200\\}$（单位为 $\\text{GeV}$）上，计算两条触发器开启曲线：\n   - 未加权的MC平均曲线\n   $$\n   \\varepsilon_{\\text{before}}(p_T) = \\sum_{\\mu=0}^{\\mu_{\\max}} p_{\\text{MC}}(\\mu)\\, S(p_T,\\mu).\n   $$\n   - 重加权后的（类数据）曲线\n   $$\n   \\varepsilon_{\\text{after}}(p_T) = \\sum_{\\mu=0}^{\\mu_{\\max}} p_{\\text{w}}(\\mu)\\, S(p_T,\\mu).\n   $$\n   通过均方根曲线差来量化重加权对开启曲线的影响\n   $$\n   D_{\\text{curve}} = \\sqrt{\\frac{1}{N_{p_T}} \\sum_{i=1}^{N_{p_T}} \\left(\\varepsilon_{\\text{after}}(p_T^{(i)}) - \\varepsilon_{\\text{before}}(p_T^{(i)})\\right)^2},\n   $$\n   其中 $N_{p_T}$ 是 $p_T$ 网格点的数量。\n4. 将物理可观测量定义为触发器平均的遍举效率\n   $$\n   Q = \\frac{\\int_0^{\\infty} f(p_T)\\, \\varepsilon_{\\text{after}}(p_T)\\, dp_T}{\\int_0^{\\infty} f(p_T)\\, dp_T}.\n   $$\n   在相同的 $p_T$ 网格上使用黎曼（Riemann）和（仓宽 $\\Delta p_T = 1\\,\\text{GeV}$）对此积分进行数值近似；确保 $f(p_T)$ 在离散网格上是归一化的。\n5. 将非弹性截面 $\\sigma_{\\text{inel}}$ 的不确定度传播到可观测量 $Q$ 上。为此，假设目标平均堆积数与 $\\sigma_{\\text{inel}}$ 线性相关，即对于相对不确定度 $\\delta = \\Delta \\sigma_{\\text{inel}} / \\sigma_{\\text{inel}}$，有 $\\lambda_{\\text{data}} \\mapsto \\lambda_{\\text{data}}(1 \\pm \\delta)$。使用 $\\lambda_{\\text{data}}^{\\text{up}} = \\lambda_{\\text{data}}(1+\\delta)$ 和 $\\lambda_{\\text{data}}^{\\text{down}} = \\lambda_{\\text{data}}(1-\\delta)$ 重新计算重加权分布以及相应的 $Q_{\\text{up}}$ 和 $Q_{\\text{down}}$。将对称不确定度报告为\n   $$\n   \\Delta Q = \\max\\!\\left(\\left|Q_{\\text{up}} - Q\\right|, \\left|Q_{\\text{down}} - Q\\right|\\right).\n   $$\n\n测试套件：\n提供三个测试用例，每个用例由元组 $(\\lambda_{\\text{MC}}, \\lambda_{\\text{data}}, \\delta, T_0, a, b, p_0, n)$ 指定，其值如下：\n- 用例 1（一般情况）：$(30, 40, 0.05, 28, 0.35, 3.0, 35, 5.0)$\n- 用例 2（低堆积）：$(2, 3, 0.02, 20, 0.10, 2.0, 20, 4.0)$\n- 用例 3（分布不匹配）：$(50, 20, 0.10, 30, 0.50, 5.0, 40, 6.0)$\n\n单位与数值约定：\n- 使用的 $p_T$ 单位为 $\\text{GeV}$。所有输出均为纯数字（无量纲）。\n- 相对不确定度输入 $\\delta$ 以小数形式给出（例如，百分之五的相对不确定度为 $0.05$）。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含所有结果，格式为方括号内的逗号分隔列表。\n- 对于每个测试用例，按顺序输出以下三个浮点数：$D_{\\text{curve}}$、$Q$ 和 $\\Delta Q$。按给定顺序连接这三个测试用例的三元组，生成一个包含9个浮点数的扁平列表。\n- 每个浮点数打印时四舍五入到六位小数。\n- 示例格式（使用占位符）：$[D_1,Q_1,\\Delta Q_1,D_2,Q_2,\\Delta Q_2,D_3,Q_3,\\Delta Q_3]$。\n\n你的程序必须是自包含的，不接受任何输入，并且在不使用任何外部文件或网络访问的情况下实现上述定义和计算。",
            "solution": "问题要求实现一个堆积重加权过程，并评估其对触发效率曲线和物理可观测量的影响。解决方案的结构将是依次执行五个指定的计算任务来处理每个测试用例。\n\n首先，我将定义堆积多重数 $\\mu$ 和横向动量 $p_T$ 的离散网格。按照规定，$\\mu$ 的范围是从 $0$到 $\\mu_{\\max} = 200$，$p_T$ 的范围是从 $0$ 到 $200$ GeV，步长为 $1$ GeV。这些将表示为一维 NumPy 数组。\n\n对于每个测试用例，解决方案按以下步骤进行：\n\n**任务1和2：堆积分布和权重**\n堆积相互作用的数量由泊松（Poisson）分布 $P(k \\mid \\lambda) = e^{-\\lambda}\\lambda^k / k!$ 建模。我将在离散网格 $\\mu \\in \\{0, 1, \\dots, 200\\}$ 上计算蒙特卡洛（MC）平均堆积数 $\\lambda_{\\text{MC}}$ 和类数据的目标平均值 $\\lambda_{\\text{data}}$ 的概率质量函数（PMF）。由于泊松分布定义在 $k \\in [0, \\infty)$ 上，因此在截断网格 $\\{\\mu_i\\}$ 上计算的 PMF 求和不为1。因此，我将通过除以各自在网格上的总和来重新归一化 $p_{\\text{MC}}(\\mu)$ 和 $p_{\\text{data}}(\\mu)$ 这两个分布。\n\n问题定义加权分布 $p_{\\text{w}}(\\mu)$ 与 $p_{\\text{MC}}(\\mu) w(\\mu)$ 成正比，其中权重为 $w(\\mu) = p_{\\text{data}}(\\mu)/p_{\\text{MC}}(\\mu)$。代入权重定义，我们得到 $p_{\\text{MC}}(\\mu)w(\\mu) = p_{\\text{MC}}(\\mu) \\frac{p_{\\text{data}}(\\mu)}{p_{\\text{MC}}(\\mu)} = p_{\\text{data}}(\\mu)$。因此，$p_{\\text{w}}(\\mu)$ 就是归一化后的 $p_{\\text{data}}(\\mu)$ 分布。这是重加权的一个基本一致性检验：加权后的MC分布应与目标数据分布完全相同。\n\n**任务3：触发效率曲线及其影响**\n触发器响应由逻辑斯谛函数 $S(p_T, \\mu; T_0, a, b) = [1 + \\exp(-[p_T - T_0 - a\\mu]/b)]^{-1}$ 给出。该函数将在我们的离散网格上为每一对 $(p_T, \\mu)$ 进行评估。这可以通过使用 NumPy 的广播功能创建一个维度为 $(N_{p_T}, N_{\\mu})$ 的二维 $S$ 值矩阵来高效计算。\n\n未加权的（MC）和重加权的（类数据）触发效率 $\\varepsilon_{\\text{before}}(p_T)$ 和 $\\varepsilon_{\\text{after}}(p_T)$ 分别是 $S(p_T, \\mu)$ 关于 $p_{\\text{MC}}(\\mu)$ 和 $p_{\\text{w}}(\\mu)$ 分布的期望值。它们通过对 $\\mu$ 求和来计算：\n$$\n\\varepsilon(p_T) = \\sum_{\\mu=0}^{\\mu_{\\max}} p(\\mu) S(p_T, \\mu)\n$$\n此操作等效于 $S(p_T, \\mu)$ 矩阵与相应的堆积概率向量之间的矩阵-向量乘积。\n\n重加权的影响 $D_{\\text{curve}}$ 是两条效率曲线之间的均方根差，计算遍及所有 $p_T$ 网格点。\n$$\nD_{\\text{curve}} = \\sqrt{\\frac{1}{N_{p_T}} \\sum_{i=1}^{N_{p_T}} (\\varepsilon_{\\text{after}}(p_T^{(i)}) - \\varepsilon_{\\text{before}}(p_T^{(i)}))^2}\n$$\n\n**任务4：物理可观测量 $Q$**\n物理可观测量 $Q$ 是触发器平均效率，通过对离线 $p_T$ 谱 $f(p_T)$ 和重加权触发效率 $\\varepsilon_{\\text{after}}(p_T)$ 的乘积进行积分来计算。谱分布为 $f(p_T) \\propto (1 + p_T/p_0)^{-n}$。问题指定使用离散黎曼（Riemann）和，其中 $\\Delta p_T = 1$。公式为：\n$$\nQ = \\frac{\\sum_i f(p_T^{(i)}) \\varepsilon_{\\text{after}}(p_T^{(i)}) \\Delta p_T}{\\sum_i f(p_T^{(i)}) \\Delta p_T}\n$$\n在 $\\Delta p_T = 1$ 且要求在离散网格上归一化 $f(p_T)$ 的情况下，分母变为 $1$，$Q$ 简化为归一化谱向量与 $\\varepsilon_{\\text{after}}(p_T)$ 向量的点积：$Q = \\sum_i f_{\\text{norm}}(p_T^{(i)}) \\varepsilon_{\\text{after}}(p_T^{(i)})$。\n\n**任务5：不确定度传播**\n为了评估由非弹性截面不确定度 $\\delta$ 引起的 $Q$ 的不确定度，我们将目标平均堆积数变化为 $\\lambda_{\\text{data}}^{\\text{up}} = \\lambda_{\\text{data}}(1+\\delta)$ 和 $\\lambda_{\\text{data}}^{\\text{down}} = \\lambda_{\\text{data}}(1-\\delta)$。对于每种变化，都计算一个新的加权堆积分布（$p_{\\text{w}}^{\\text{up}}$ 和 $p_{\\text{w}}^{\\text{down}}$）。然后用这些分布重新计算重加权的触发效率曲线（$\\varepsilon_{\\text{after}}^{\\text{up}}$ 和 $\\varepsilon_{\\text{after}}^{\\text{down}}$），并随后计算可观测量（$Q_{\\text{up}}$ 和 $Q_{\\text{down}}$）。最终的对称不确定度 $\\Delta Q$ 是两个与名义值 $Q$ 的绝对偏差中的较大者：\n$$\n\\Delta Q = \\max(|Q_{\\text{up}} - Q|, |Q_{\\text{down}} - Q|)\n$$\n整个过程被封装在一个函数中，该函数处理单个测试用例并返回三元组 $(D_{\\text{curve}}, Q, \\Delta Q)$。一个主循环遍历测试套件，收集结果，并将其格式化为指定的最终输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import poisson\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the pileup reweighting simulation.\n    It defines test cases, processes each, and prints the final results.\n    \"\"\"\n    \n    # Define problem constants and grids\n    MU_MAX = 200\n    PT_MAX = 200\n    MU_GRID = np.arange(MU_MAX + 1)\n    PT_GRID = np.arange(PT_MAX + 1)\n\n    # --- Helper functions for physical models and calculations ---\n\n    def get_normalized_poisson(lam, grid):\n        \"\"\"Computes a normalized Poisson PMF on a truncated grid.\"\"\"\n        dist = poisson.pmf(grid, lam)\n        dist_sum = np.sum(dist)\n        if dist_sum > 0:\n            return dist / dist_sum\n        return dist\n\n    def s_func(p_T, mu, T0, a, b):\n        \"\"\"Computes the trigger turn-on probability (logistic function).\"\"\"\n        # Using np.clip to prevent overflow in np.exp for large negative arguments\n        arg = np.clip(-(p_T - T0 - a * mu) / b, -700, 700)\n        return 1.0 / (1.0 + np.exp(arg))\n\n    def f_spec(p_T, p0, n):\n        \"\"\"Computes the unnormalized pT spectrum (modified power law).\"\"\"\n        # Adding a small epsilon to p0 to avoid division by zero if p0=0\n        return (1.0 + p_T / (p0 + 1e-9))**(-n)\n\n    def process_case(case_params):\n        \"\"\"\n        Processes a single test case and returns D_curve, Q, and Delta_Q.\n        \"\"\"\n        lambda_mc, lambda_data, delta, T0, a, b, p0, n = case_params\n\n        # --- Pre-calculate constant matrices/vectors for the case ---\n\n        # 2D matrix of trigger probabilities S(pT, mu)\n        # S_matrix[i, j] = S(pT_i, mu_j)\n        S_matrix = s_func(PT_GRID[:, None], MU_GRID[None, :], T0, a, b)\n        \n        # Normalized offline pT spectrum\n        f_values = f_spec(PT_GRID, p0, n)\n        f_sum = np.sum(f_values)\n        f_norm = f_values / f_sum if f_sum > 0 else f_values\n\n        # --- Main Calculations ---\n\n        # Task 1: Pileup Distributions\n        p_mc = get_normalized_poisson(lambda_mc, MU_GRID)\n        p_data_nominal = get_normalized_poisson(lambda_data, MU_GRID)\n\n        # Task 2: Weighted Distribution\n        # As per the problem, p_w is the normalized p_data distribution.\n        p_w_nominal = p_data_nominal\n\n        # Task 3: Trigger Curves and D_curve\n        eps_before = S_matrix @ p_mc\n        eps_after_nominal = S_matrix @ p_w_nominal\n        D_curve = np.sqrt(np.mean((eps_after_nominal - eps_before)**2))\n\n        # Task 4: Physics Observable Q\n        Q_nominal = np.dot(f_norm, eps_after_nominal)\n\n        # Task 5: Uncertainty Propagation\n        lambda_data_up = lambda_data * (1.0 + delta)\n        lambda_data_down = lambda_data * (1.0 - delta)\n\n        p_w_up = get_normalized_poisson(lambda_data_up, MU_GRID)\n        p_w_down = get_normalized_poisson(lambda_data_down, MU_GRID)\n        \n        eps_after_up = S_matrix @ p_w_up\n        eps_after_down = S_matrix @ p_w_down\n        \n        Q_up = np.dot(f_norm, eps_after_up)\n        Q_down = np.dot(f_norm, eps_after_down)\n        \n        delta_Q = max(abs(Q_up - Q_nominal), abs(Q_down - Q_nominal))\n\n        return D_curve, Q_nominal, delta_Q\n        \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (30, 40, 0.05, 28, 0.35, 3.0, 35, 5.0),    # Case 1\n        (2, 3, 0.02, 20, 0.10, 2.0, 20, 4.0),       # Case 2\n        (50, 20, 0.10, 30, 0.50, 5.0, 40, 6.0),    # Case 3\n    ]\n\n    all_results = []\n    for case in test_cases:\n        D, Q, dQ = process_case(case)\n        all_results.extend([D, Q, dQ])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{val:.6f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了进行统计上的校正，我们还可以利用先进的探测器信息来主动抑制pileup效应。将带领你探索如何使用精确的时间信息来区分来自主顶点（PV）和来自pileup的粒子。你将基于高斯模型构建一个简化的pileup抑制算法，并使用接收者操作特征（ROC）曲线等标准工具来评估其性能。",
            "id": "3528655",
            "problem": "您的任务是构建一个基于原理的模拟和分析研究，以探讨在计算高能物理学中使用精确授时技术进行堆积（pileup）缓解的方法。目标是为时间刻度残差建模，并量化其在拒绝非源于主顶点（PV）的径迹方面的效果。您必须计算不同时间分辨率下的接收者操作特征（ROC）曲线，并分析与主顶点（PV）的错误关联。\n\n推导过程需基于以下基本定义和事实：\n- 时间测量残差被建模为一个服从高斯（正态）分布的随机变量。如果一个探测器具有标准差为 $\\sigma_{\\mathrm{det}}$ 的固有时间噪声和一个标准差为 $\\sigma_{\\mathrm{cal}}$ 的刻度残差 $\\delta t$，那么由于高斯贡献的独立性，总时间分辨率 $\\sigma_t$ 服从方和根关系 $\\,\\sigma_t^2 = \\sigma_{\\mathrm{det}}^2 + \\sigma_{\\mathrm{cal}}^2\\,$。\n- 非主顶点（堆积）相互作用与主顶点时间之间的时间偏移被建模为一个标准差为 $\\sigma_b$ 的高斯随机变量，代表粒子束团的时间展宽。\n- 对于一条径迹，其相对于主顶点（PV）的测量时间是其真实时间偏移（对于主顶点径迹为零，对于堆积径迹则以 $\\sigma_b$ 的展宽分布）与总时间噪声之和。如果测量的绝对时间与主顶点（PV）的接近程度小于或等于一个截断阈值 $\\tau$，则将该径迹归类为源于主顶点。\n- 接收者操作特征（ROC）被定义为当决策阈值 $\\tau$ 变化时，真阳性率（TPR）作为假阳性率（FPR）的函数。此处：\n  - 真阳性率（TPR）：被正确分类为主顶点（PV）径迹的PV径迹所占的比例。\n  - 假阳性率（FPR）：被错误分类为主顶点（PV）径迹的堆积径迹所占的比例。\n- ROC曲线下面积（AUC）是指随机抽取的PV分数优于（即绝对时间接近程度更小）随机抽取的堆积分数的概率。\n\n请在纯数学术语下，使用以下建模假设进行工作：\n- 总时间噪声服从均值为零、标准差为 $\\sigma_t$ 的高斯分布。\n- 相对于主顶点（PV）的堆积时间偏移服从均值为零、标准差为 $\\sigma_b$ 的高斯分布，并且独立于时间噪声。\n- 每条径迹的判别分数是其测量时间与主顶点（PV）接近程度的绝对值，分类阈值 $\\tau$ 应用于此绝对值。\n- 时间量以皮秒（ps）为单位表示，但输出指标是无单位的概率。\n\n实现一个程序，对每个指定的参数集执行以下操作：\n1. 基于上述高斯假设，从第一性原理出发，推导并计算在一个密集的阈值 $\\tau$ 网格上的ROC曲线点以及相应的AUC。\n2. 计算在三个特定阈值下的假阳性率（FPR）：$\\tau = 0.5\\,\\sigma_t$、$\\tau = 1.0\\,\\sigma_t$ 和 $\\tau = 2.0\\,\\sigma_t$。\n3. 对于每个参数集，汇总并报告AUC和三个FPR值，以小数形式表示。\n\n使用以下参数集测试套件，每个集合由 $(\\sigma_{\\mathrm{det}}, \\sigma_{\\mathrm{cal}}, \\sigma_b)$ 指定，单位均为皮秒：\n- 案例 1：$(\\sigma_{\\mathrm{det}}, \\sigma_{\\mathrm{cal}}, \\sigma_b) = (\\,20\\,\\mathrm{ps},\\,10\\,\\mathrm{ps},\\,180\\,\\mathrm{ps}\\,)$。\n- 案例 2：$(\\sigma_{\\mathrm{det}}, \\sigma_{\\mathrm{cal}}, \\sigma_b) = (\\,30\\,\\mathrm{ps},\\,30\\,\\mathrm{ps},\\,180\\,\\mathrm{ps}\\,)$。\n- 案例 3：$(\\sigma_{\\mathrm{det}}, \\sigma_{\\mathrm{cal}}, \\sigma_b) = (\\,20\\,\\mathrm{ps},\\,60\\,\\mathrm{ps},\\,180\\,\\mathrm{ps}\\,)$。\n- 案例 4：$(\\sigma_{\\mathrm{det}}, \\sigma_{\\mathrm{cal}}, \\sigma_b) = (\\,0\\,\\mathrm{ps},\\,0\\,\\mathrm{ps},\\,180\\,\\mathrm{ps}\\,)$。\n- 案例 5：$(\\sigma_{\\mathrm{det}}, \\sigma_{\\mathrm{cal}}, \\sigma_b) = (\\,150\\,\\mathrm{ps},\\,100\\,\\mathrm{ps},\\,180\\,\\mathrm{ps}\\,)$。\n\n数值和输出要求：\n- 所有内部阈值计算均以皮秒为单位。\n- 所有报告的概率必须以小数形式表示。\n- 所有报告的浮点数必须四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。\n- 每个案例的输出必须是 $[\\,\\mathrm{AUC},\\,\\mathrm{FPR}_{0.5\\sigma_t},\\,\\mathrm{FPR}_{1.0\\sigma_t},\\,\\mathrm{FPR}_{2.0\\sigma_t}\\,]$ 形式的内部列表。将五个内部列表聚合到一个外部列表中，例如 $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],\\dots]$。\n\n科学真实性和推导要求：\n- 从高斯贡献的独立性和方差的方和根组合出发，得到 $\\sigma_t$。\n- 从高斯模型和绝对值决策规则出发，明确推导出控制PV和堆积分数的分布，以及由此产生的TPR和FPR作为 $\\tau$ 的函数。\n- 使用第一性原理推导ROC和AUC的解析表达式，而不是引用现有的快捷公式。",
            "solution": "用户提供了一个有效、适定且具有科学依据的问题。任务是基于时间测量的高斯模型，推导并计算使用精确授时技术在高能物理学中进行堆积缓解的关键性能指标。该问题是自洽的，其参数在对撞机实验的现实范围内。\n\n解决方案以分步、基于原理的方式进行，从基础统计模型开始，推导出所需指标的表达式：接收者操作特征（ROC）曲线下面积（AUC）和特定的假阳性率（FPR）。\n\n### 1. 测量时间的统计模型\n\n问题定义了时间不确定性的来源。单条径迹的总时间分辨率 $\\sigma_t$ 是固有探测器噪声 $\\sigma_{\\mathrm{det}}$ 和刻度残差 $\\sigma_{\\mathrm{cal}}$ 的组合。由于这些是独立的高斯源，它们的方差正交相加：\n$$\n\\sigma_t^2 = \\sigma_{\\mathrm{det}}^2 + \\sigma_{\\mathrm{cal}}^2 \\implies \\sigma_t = \\sqrt{\\sigma_{\\mathrm{det}}^2 + \\sigma_{\\mathrm{cal}}^2}\n$$\n测量时间 $t_{meas}$ 被建模为径迹真实起源时间 $t_{true}$ 与随机测量误差 $\\epsilon_t \\sim \\mathcal{N}(0, \\sigma_t^2)$ 之和，其中 $\\mathcal{N}(\\mu, \\sigma^2)$ 表示均值为 $\\mu$、方差为 $\\sigma^2$ 的高斯分布。\n\n对于源于主顶点（PV）的径迹，根据定义其真实时间为 $t_{true, PV} = 0$。因此，测量时间为：\n$$\nt_{meas, PV} = 0 + \\epsilon_t \\sim \\mathcal{N}(0, \\sigma_t^2)\n$$\n\n对于来自堆积（PU）相互作用的径迹，其真实起源时间 $t_{true, PU}$ 相对于主顶点存在一个偏移。该偏移被建模为一个均值为零、标准差为 $\\sigma_b$ 的高斯随机变量，代表粒子束团的时间展宽。因此，$t_{true, PU} \\sim \\mathcal{N}(0, \\sigma_b^2)$。PU径迹的测量时间为：\n$$\nt_{meas, PU} = t_{true, PU} + \\epsilon_t\n$$\n由于 $t_{true, PU}$ 和 $\\epsilon_t$ 是独立的高斯变量，它们的和也是一个高斯变量。和的均值是均值之和（$0+0=0$），和的方差是方差之和。我们将PU径迹的总有效标准差记为 $\\sigma_{PU}$：\n$$\n\\sigma_{PU}^2 = \\sigma_b^2 + \\sigma_t^2 \\implies \\sigma_{PU} = \\sqrt{\\sigma_b^2 + \\sigma_t^2}\n$$\n因此，PU径迹的测量时间分布为：\n$$\nt_{meas, PU} \\sim \\mathcal{N}(0, \\sigma_{PU}^2)\n$$\n\n### 2. 真阳性率和假阳性率的推导\n\n如果一条径迹的测量时间与主顶点（PV）的接近程度 $|t_{meas}|$ 小于或等于决策阈值 $\\tau$，则该径迹被分类为源于PV。\n\n真阳性率 $TPR(\\tau)$ 是PV径迹被正确分类的概率：\n$$\nTPR(\\tau) = P(|t_{meas, PV}| \\le \\tau) = P(-\\tau \\le t_{meas, PV} \\le \\tau)\n$$\n给定 $t_{meas, PV} \\sim \\mathcal{N}(0, \\sigma_t^2)$，此概率是高斯概率密度函数（PDF）从 $-\\tau$ 到 $\\tau$ 的积分。用标准正态累积分布函数（CDF）$\\Phi(z) = \\int_{-\\infty}^{z} \\frac{1}{\\sqrt{2\\pi}} e^{-x^2/2} dx$ 表示：\n$$\nTPR(\\tau) = \\Phi\\left(\\frac{\\tau}{\\sigma_t}\\right) - \\Phi\\left(\\frac{-\\tau}{\\sigma_t}\\right)\n$$\n利用对称性质 $\\Phi(-z) = 1 - \\Phi(z)$，上式可简化为 $2\\Phi(\\frac{\\tau}{\\sigma_t}) - 1$。这等价于误差函数 $\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}}\\int_0^z e^{-x^2} dx$，如下所示：\n$$\nTPR(\\tau) = \\text{erf}\\left(\\frac{\\tau}{\\sqrt{2}\\sigma_t}\\right)\n$$\n\n假阳性率 $FPR(\\tau)$ 是PU径迹被错误分类为PV径迹的概率：\n$$\nFPR(\\tau) = P(|t_{meas, PU}| \\le \\tau) = P(-\\tau \\le t_{meas, PU} \\le \\tau)\n$$\n遵循同样的逻辑，对于 $t_{meas, PU} \\sim \\mathcal{N}(0, \\sigma_{PU}^2)$：\n$$\nFPR(\\tau) = \\text{erf}\\left(\\frac{\\tau}{\\sqrt{2}\\sigma_{PU}}\\right)\n$$\nROC曲线是当 $\\tau \\in [0, \\infty)$ 时，点集 $(FPR(\\tau), TPR(\\tau))$ 的轨迹。\n\n### 3. ROC曲线下面积（AUC）的推导\n\n问题将AUC定义为随机抽取的PV分数优于（即更小）随机抽取的PU分数的概率。判别分数为 $s = |t_{meas}|$。因此，我们必须计算 $AUC = P(|t_{meas, PV}|  |t_{meas, PU}|)$。\n\n设 $X = t_{meas, PV} \\sim \\mathcal{N}(0, \\sigma_t^2)$ 且 $Y = t_{meas, PU} \\sim \\mathcal{N}(0, \\sigma_{PU}^2)$。我们需要计算 $P(|X|  |Y|)$。这可以通过对 $Y$ 的值取条件，并在其分布上积分来构建：\n$$\nAUC = \\int_{-\\infty}^{\\infty} P(|X|  |y|) f_Y(y) dy\n$$\n其中 $f_Y(y)$ 是 $Y$ 的概率密度函数（PDF）。内部的概率是 $P(-|y|  X  |y|)$，这正是我们之前看到的TPR的形式，得到 $\\text{erf}\\left(\\frac{|y|}{\\sqrt{2}\\sigma_t}\\right)$。$Y$ 的PDF是 $f_Y(y) = \\frac{1}{\\sqrt{2\\pi}\\sigma_{PU}} e^{-y^2/(2\\sigma_{PU}^2)}$。\n将这些代入积分中：\n$$\nAUC = \\int_{-\\infty}^{\\infty} \\frac{1}{\\sqrt{2\\pi}\\sigma_{PU}} e^{-y^2/(2\\sigma_{PU}^2)} \\text{erf}\\left(\\frac{|y|}{\\sqrt{2}\\sigma_t}\\right) dy\n$$\n被积函数是 y 的偶函数，所以我们可以从 0 积分到 $\\infty$ 并乘以 2：\n$$\nAUC = 2 \\int_{0}^{\\infty} \\frac{1}{\\sqrt{2\\pi}\\sigma_{PU}} e^{-y^2/(2\\sigma_{PU}^2)} \\text{erf}\\left(\\frac{y}{\\sqrt{2}\\sigma_t}\\right) dy\n$$\n为求解此积分，我们使用换元法 $u = y/(\\sqrt{2}\\sigma_{PU})$，得到 $y = u\\sqrt{2}\\sigma_{PU}$ 和 $dy = \\sqrt{2}\\sigma_{PU} du$：\n$$\nAUC = 2 \\int_{0}^{\\infty} \\frac{1}{\\sqrt{2\\pi}\\sigma_{PU}} e^{-u^2} \\text{erf}\\left(\\frac{u\\sqrt{2}\\sigma_{PU}}{\\sqrt{2}\\sigma_t}\\right) (\\sqrt{2}\\sigma_{PU} du)\n$$\n$$\nAUC = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{\\infty} e^{-u^2} \\text{erf}\\left(u \\frac{\\sigma_{PU}}{\\sigma_t}\\right) du\n$$\n这个积分有一个标准形式。使用恒等式 $\\int_0^\\infty e^{-c^2x^2}\\text{erf}(ax)dx = \\frac{1}{c\\sqrt{\\pi}}\\arctan(\\frac{a}{c})$，其中 $c=1$ 且 $a = \\sigma_{PU}/\\sigma_t$：\n$$\nAUC = \\frac{2}{\\sqrt{\\pi}} \\left[ \\frac{1}{1 \\cdot \\sqrt{\\pi}} \\arctan\\left(\\frac{\\sigma_{PU}/\\sigma_t}{1}\\right) \\right]\n$$\n这可以简化为一个非常简洁的结果：\n$$\nAUC = \\frac{2}{\\pi} \\arctan\\left(\\frac{\\sigma_{PU}}{\\sigma_t}\\right) = \\frac{2}{\\pi} \\arctan\\left(\\frac{\\sqrt{\\sigma_t^2 + \\sigma_b^2}}{\\sigma_t}\\right) = \\frac{2}{\\pi} \\arctan\\left(\\sqrt{1 + \\left(\\frac{\\sigma_b}{\\sigma_t}\\right)^2}\\right)\n$$\n在 $\\sigma_t \\to 0$ 的理想极限下，arctan的参数趋于 $\\infty$，所以 $\\arctan(\\infty) = \\pi/2$，且 $AUC \\to \\frac{2}{\\pi}(\\frac{\\pi}{2}) = 1$，这对应于完美判别。\n\n### 4. 用于实现的公式总结\n\n对于每个参数集 $(\\sigma_{\\mathrm{det}}, \\sigma_{\\mathrm{cal}}, \\sigma_b)$：\n1.  计算总时间分辨率：$\\sigma_t = \\sqrt{\\sigma_{\\mathrm{det}}^2 + \\sigma_{\\mathrm{cal}}^2}$。如果 $\\sigma_{\\mathrm{det}} = \\sigma_{\\mathrm{cal}} = 0$，则 $\\sigma_t=0$。\n2.  计算有效堆积时间展宽：$\\sigma_{PU} = \\sqrt{\\sigma_t^2 + \\sigma_b^2}$。\n3.  计算AUC。如果 $\\sigma_t > 0$：$AUC = \\frac{2}{\\pi} \\arctan(\\sigma_{PU}/\\sigma_t)$。如果 $\\sigma_t=0$，则 $AUC=1$。\n4.  计算三个阈值 $\\tau_k = k \\cdot \\sigma_t$（其中 $k \\in \\{0.5, 1.0, 2.0\\}$）下的FPR。通用公式为：\n    $$\n    FPR(\\tau_k) = \\text{erf}\\left(\\frac{k \\cdot \\sigma_t}{\\sqrt{2}\\sigma_{PU}}\\right)\n    $$\n    如果 $\\sigma_t = 0$，则所有阈值均为 $0$，且 $FPR(0) = \\text{erf}(0) = 0$。\n\n这些公式将被用于实现计算 5 个测试案例所需指标的程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\nimport math\n\ndef solve():\n    \"\"\"\n    Computes pileup mitigation metrics based on a Gaussian timing model.\n\n    For each parameter set (sigma_det, sigma_cal, sigma_b), this function\n    calculates:\n    1. The Area Under the ROC Curve (AUC).\n    2. The False Positive Rate (FPR) at three thresholds: tau = 0.5*sigma_t,\n       1.0*sigma_t, and 2.0*sigma_t.\n\n    The derivations are based on first principles as outlined in the solution.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (sigma_det, sigma_cal, sigma_b) in picoseconds.\n    test_cases = [\n        (20.0, 10.0, 180.0),  # Case 1\n        (30.0, 30.0, 180.0),  # Case 2\n        (20.0, 60.0, 180.0),  # Case 3\n        (0.0, 0.0, 180.0),    # Case 4 (ideal resolution)\n        (150.0, 100.0, 180.0) # Case 5\n    ]\n\n    results_as_strings = []\n\n    for case in test_cases:\n        sigma_det, sigma_cal, sigma_b = case\n\n        # Step 1: Calculate total timing resolution (sigma_t)\n        sigma_t_sq = sigma_det**2 + sigma_cal**2\n        sigma_t = np.sqrt(sigma_t_sq)\n\n        # Handle the ideal case of perfect timing resolution (sigma_t = 0)\n        if sigma_t == 0.0:\n            # AUC is 1, representing perfect discrimination.\n            auc = 1.0\n            # Thresholds are tau = k * sigma_t = 0.\n            # FPR at tau=0 is erf(0) = 0.\n            fpr_0_5 = 0.0\n            fpr_1_0 = 0.0\n            fpr_2_0 = 0.0\n        else:\n            # Step 2: Calculate effective pileup time spread (sigma_PU)\n            sigma_pu_sq = sigma_t_sq + sigma_b**2\n            sigma_pu = np.sqrt(sigma_pu_sq)\n\n            # Step 3: Calculate AUC\n            # AUC = (2/pi) * arctan(sigma_PU / sigma_t)\n            auc = (2.0 / np.pi) * np.arctan(sigma_pu / sigma_t)\n\n            # Step 4: Calculate FPRs at specified thresholds\n            # FPR(tau) = erf(tau / (sqrt(2) * sigma_PU))\n            # Thresholds are tau_k = k * sigma_t\n            \n            # For tau = 0.5 * sigma_t\n            arg_0_5 = (0.5 * sigma_t) / (np.sqrt(2) * sigma_pu)\n            fpr_0_5 = erf(arg_0_5)\n\n            # For tau = 1.0 * sigma_t\n            arg_1_0 = (1.0 * sigma_t) / (np.sqrt(2) * sigma_pu)\n            fpr_1_0 = erf(arg_1_0)\n\n            # For tau = 2.0 * sigma_t\n            arg_2_0 = (2.0 * sigma_t) / (np.sqrt(2) * sigma_pu)\n            fpr_2_0 = erf(arg_2_0)\n\n        # Aggregate and format results for the current case\n        current_result = [auc, fpr_0_5, fpr_1_0, fpr_2_0]\n        \n        # Format each number to 6 decimal places and join into a string \"[v1,v2,...]\"\n        result_str_list = [f\"{x:.6f}\" for x in current_result]\n        case_string = f\"[{','.join(result_str_list)}]\"\n        results_as_strings.append(case_string)\n\n    # Final print statement in the exact required format.\n    # The format is '[[...],[...],...]'\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "任何pileup抑制技术都不是完美的，我们对pileup环境和探测器响应的理解都存在不确定性。旨在连接pileup抑制算法与最终物理分析之间的鸿沟，量化这些不确定性如何传播到最终的物理测量结果中。你将使用费雪信息矩阵（Fisher information matrix）这一强大的统计框架，来评估pileup抑制中的系统不确定性对信号强度测量的具体影响。",
            "id": "3528710",
            "problem": "您的任务是为一个简化的、带有堆积抑制讨厌参数的高能物理拟合，实现一种有原则的、端到端的不确定性传播。从一个泊松计数模型和高斯约束的讨厌参数出发，您必须在标称点构建预期的费雪信息，将其求逆以获得感兴趣的物理参数的协方差，并评估每个讨厌参数对该物理参数不确定性的影响。\n\n基本基础和定义：\n- 每个区间 $j$ 的总预期产额被建模为泊松均值 $\\lambda_j(\\mu,\\theta)$，其中 $\\mu$ 是一个无量纲的物理信号强度，用于缩放已知的信号模板，$\\theta$ 是描述堆积（每次束团碰撞中的多个质子-质子相互作用）抑制不确定性的讨厌参数。\n- 对于均值为 $\\lambda_j(\\mu,\\theta)$ 的泊松观测和一个在标称点的 Asimov 数据集，参数 $\\vartheta_a$ 和 $\\vartheta_b$ 的预期费雪信息矩阵元素为\n$$\nI_{ab} \\;=\\; \\sum_{j} \\frac{1}{\\lambda_j(\\mu_0,\\theta_0)} \\left( \\frac{\\partial \\lambda_j}{\\partial \\vartheta_a} \\right)_{\\mu_0,\\theta_0} \\left( \\frac{\\partial \\lambda_j}{\\partial \\vartheta_b} \\right)_{\\mu_0,\\theta_0} \\;+\\; \\Pi_{ab},\n$$\n其中 $\\Pi$ 是来自讨厌参数高斯约束的先验精度矩阵。协方差矩阵是其逆矩阵 $C = I^{-1}$，$\\mu$ 的边际标准差是 $\\sigma_\\mu = \\sqrt{C_{\\mu\\mu}}$。\n- 考虑的讨厌参数有：\n  - $\\rho$ 标度 $s_\\rho$（无量纲），定义为堆积密度校正的乘法标度；先验为 $s_\\rho \\sim \\mathcal{N}(1, \\delta_\\rho)$，其中 $\\delta_\\rho$ 是一个无量纲的宽度。\n  - 时间分辨率 $\\sigma_t$（单位：皮秒），参数化中性粒子的飞行时间剔除；先验为 $\\sigma_t \\sim \\mathcal{N}(\\sigma_t^0, \\delta_t)$。\n  - 径迹-顶点效率 $\\varepsilon_{\\mathrm{tv}}$（无量纲，分数），参数化带电径迹正确关联到主顶点的概率；先验为 $\\varepsilon_{\\mathrm{tv}} \\sim \\mathcal{N}(\\varepsilon_{\\mathrm{tv}}^0, \\delta_e)$。\n- 这些讨厌参数对区间 $j$ 中本底预期的影响通过围绕标称值的一阶泰勒展开进行建模：\n$$\nb_j(s_\\rho,\\sigma_t,\\varepsilon_{\\mathrm{tv}}) \\;\\approx\\; b_j^0 \\left[ 1 + a_j (s_\\rho - 1) + t_j \\frac{\\sigma_t - \\sigma_t^0}{\\sigma_t^0} + e_j \\frac{\\varepsilon_{\\mathrm{tv}} - \\varepsilon_{\\mathrm{tv}}^0}{\\varepsilon_{\\mathrm{tv}}^0} \\right],\n$$\n其中 $b_j^0$ 是区间 $j$ 中的标称本底；$a_j$、$t_j$ 和 $e_j$ 是无量纲的灵敏度系数，描述了本底如何随每个讨厌参数发生一阶变化。预期的泊松均值为\n$$\n\\lambda_j(\\mu,s_\\rho,\\sigma_t,\\varepsilon_{\\mathrm{tv}}) \\;=\\; \\mu\\, s_j \\;+\\; b_j(s_\\rho,\\sigma_t,\\varepsilon_{\\mathrm{tv}}),\n$$\n其中 $s_j$ 是区间 $j$ 中的标称信号。标称参数点为 $\\mu_0 = 1$、$s_{\\rho,0}=1$、$\\sigma_{t,0}=\\sigma_t^0$、$\\varepsilon_{\\mathrm{tv},0}=\\varepsilon_{\\mathrm{tv}}^0$。高斯先验精度以对角元素 $\\Pi_{s_\\rho s_\\rho} = 1/\\delta_\\rho^2$、$\\Pi_{\\sigma_t \\sigma_t} = 1/\\delta_t^2$ 和 $\\Pi_{\\varepsilon_{\\mathrm{tv}}\\varepsilon_{\\mathrm{tv}}} = 1/\\delta_e^2$ 的形式加性地贡献于费雪矩阵，非对角先验相关性为零。\n\n需要实现的推导：\n- 计算在标称点的 Asimov 预期值，$\\lambda_{j,0} = \\lambda_j(\\mu_0,s_{\\rho,0},\\sigma_{t,0},\\varepsilon_{\\mathrm{tv},0})$。\n- 推导在标称点的偏导数：\n$$\n\\frac{\\partial \\lambda_j}{\\partial \\mu} = s_j,\\quad\n\\frac{\\partial \\lambda_j}{\\partial s_\\rho} = b_j^0\\, a_j,\\quad\n\\frac{\\partial \\lambda_j}{\\partial \\sigma_t} = b_j^0\\, t_j \\frac{1}{\\sigma_t^0},\\quad\n\\frac{\\partial \\lambda_j}{\\partial \\varepsilon_{\\mathrm{tv}}} = b_j^0\\, e_j \\frac{1}{\\varepsilon_{\\mathrm{tv}}^0}.\n$$\n- 将费雪信息矩阵组装为秩为1的贡献在各区间上的总和，再加上先验精度矩阵，然后将其求逆以获得协方差矩阵，并报告 $\\sigma_\\mu$。\n- 将固定单个讨厌参数 $k \\in \\{ s_\\rho, \\sigma_t, \\varepsilon_{\\mathrm{tv}} \\}$ 对 $\\mu$ 不确定性的影响定义为正交分量\n$$\n\\Delta_k \\;=\\; \\sqrt{\\max\\!\\left(0,\\, \\sigma_{\\mu,\\mathrm{all}}^2 \\;-\\; \\sigma_{\\mu,\\mathrm{fixed}\\;k}^2 \\right)}.\n$$\n固定一个讨厌参数的实现方式是将其先验精度设为有效无穷大（例如，添加一个非常大的对角先验元素），这对应于以该讨厌参数已知为条件。\n\n实现约束和单位：\n- 所有时间量（$\\sigma_t^0$ 和 $\\delta_t$）都必须以皮秒为单位。\n- 所有输出必须报告为小数点后六位四舍五入的十进制浮点数。\n- 不涉及角度。\n- 除非特别说明，所有量都是无量纲的。\n\n要实现和评估的测试套件：\n- 案例1（三个区间，中等不确定性）：\n  - $s = [30,22,12]$, $b^0 = [100,80,60]$, $a = [0.15,0.20,0.25]$, $t = [-0.10,-0.06,-0.04]$, $e = [-0.30,-0.20,-0.15]$.\n  - 先验：$\\delta_\\rho = 0.10$, $\\sigma_t^0 = 50$ ps, $\\delta_t = 10$ ps, $\\varepsilon_{\\mathrm{tv}}^0 = 0.95$, $\\delta_e = 0.02$.\n- 案例2（三个区间，无时间灵敏度）：\n  - $s = [5,5,5]$, $b^0 = [200,150,100]$, $a = [0.05,0.04,0.03]$, $t = [0,0,0]$, $e = [-0.10,-0.08,-0.06]$.\n  - 先验：$\\delta_\\rho = 0.05$, $\\sigma_t^0 = 30$ ps, $\\delta_t = 5$ ps, $\\varepsilon_{\\mathrm{tv}}^0 = 0.98$, $\\delta_e = 0.01$.\n- 案例3（四个区间，信号主导，弱先验）：\n  - $s = [120,90,70,50]$, $b^0 = [60,45,35,25]$, $a = [0.20,0.20,0.20,0.20]$, $t = [-0.05,-0.05,-0.05,-0.05]$, $e = [-0.15,-0.15,-0.15,-0.15]$.\n  - 先验：$\\delta_\\rho = 0.20$, $\\sigma_t^0 = 80$ ps, $\\delta_t = 40$ ps, $\\varepsilon_{\\mathrm{tv}}^0 = 0.90$, $\\delta_e = 0.05$.\n\n程序要求：\n- 按照上述规定实现预期的费雪信息构建、协方差求逆和不确定性提取。\n- 对于每个测试案例，计算：\n  - $\\sigma_{\\mu,\\mathrm{all}}$，所有讨厌参数在其高斯先验下浮动。\n  - $\\sigma_{\\mu,\\mathrm{fixed}\\;s_\\rho}$, $\\sigma_{\\mu,\\mathrm{fixed}\\;\\sigma_t}$ 和 $\\sigma_{\\mu,\\mathrm{fixed}\\;\\varepsilon_{\\mathrm{tv}}}$，通过无限先验精度一次有效地固定一个讨厌参数。\n  - 影响 $\\Delta_{s_\\rho}$, $\\Delta_{\\sigma_t}$ 和 $\\Delta_{\\varepsilon_{\\mathrm{tv}}}$，如上定义。\n- 最终输出格式：您的程序应生成一行输出，其中包含所有案例的所有结果，平坦化为一个用方括号括起来的逗号分隔列表。对于每个案例，按顺序附加七个浮点数 $[\\sigma_{\\mu,\\mathrm{all}}, \\sigma_{\\mu,\\mathrm{fixed}\\;s_\\rho}, \\sigma_{\\mu,\\mathrm{fixed}\\;\\sigma_t}, \\sigma_{\\mu,\\mathrm{fixed}\\;\\varepsilon_{\\mathrm{tv}}}, \\Delta_{s_\\rho}, \\Delta_{\\sigma_t}, \\Delta_{\\varepsilon_{\\mathrm{tv}}}]$, 每个都四舍五入到小数点后六位。因此，最终输出是针对三个案例的包含 $21$ 个浮点数的单个列表。",
            "solution": "此问题已经过验证。\n\n### 步骤 1：提取已知条件\n- **模型**：区间 $j$ 的总预期产额为泊松均值 $\\lambda_j(\\mu, \\theta)$，其中 $\\mu$ 是信号强度，$\\theta$ 是讨厌参数。\n- **费雪信息**：参数 $\\vartheta_a, \\vartheta_b$ 的预期费雪信息矩阵为 $I_{ab} = \\sum_{j} \\frac{1}{\\lambda_j(\\mu_0,\\theta_0)} \\left( \\frac{\\partial \\lambda_j}{\\partial \\vartheta_a} \\right)_{\\mu_0,\\theta_0} \\left( \\frac{\\partial \\lambda_j}{\\partial \\vartheta_b} \\right)_{\\mu_0,\\theta_0} + \\Pi_{ab}$。\n- **协方差**：协方差矩阵 $C = I^{-1}$。$\\mu$ 的边际标准差为 $\\sigma_\\mu = \\sqrt{C_{\\mu\\mu}}$。\n- **讨厌参数 (NPs)**：\n    - $\\rho$ 标度 $s_\\rho$：先验 $s_\\rho \\sim \\mathcal{N}(1, \\delta_\\rho)$。\n    - 时间分辨率 $\\sigma_t$：先验 $\\sigma_t \\sim \\mathcal{N}(\\sigma_t^0, \\delta_t)$。\n    - 径迹-顶点效率 $\\varepsilon_{\\mathrm{tv}}$：先验 $\\varepsilon_{\\mathrm{tv}} \\sim \\mathcal{N}(\\varepsilon_{\\mathrm{tv}}^0, \\delta_e)$。\n- **本底模型**：$b_j(s_\\rho,\\sigma_t,\\varepsilon_{\\mathrm{tv}}) \\approx b_j^0 \\left[ 1 + a_j (s_\\rho - 1) + t_j \\frac{\\sigma_t - \\sigma_t^0}{\\sigma_t^0} + e_j \\frac{\\varepsilon_{\\mathrm{tv}} - \\varepsilon_{\\mathrm{tv}}^0}{\\varepsilon_{\\mathrm{tv}}^0} \\right]$。\n- **总产额模型**：$\\lambda_j(\\mu,s_\\rho,\\sigma_t,\\varepsilon_{\\mathrm{tv}}) = \\mu s_j + b_j(s_\\rho,\\sigma_t,\\varepsilon_{\\mathrm{tv}})$。\n- **标称点**：$\\mu_0 = 1$, $s_{\\rho,0}=1$, $\\sigma_{t,0}=\\sigma_t^0$, $\\varepsilon_{\\mathrm{tv},0}=\\varepsilon_{\\mathrm{tv}}^0$。\n- **先验精度矩阵 ($\\Pi$) 元素**：$\\Pi_{s_\\rho s_\\rho} = 1/\\delta_\\rho^2$, $\\Pi_{\\sigma_t \\sigma_t} = 1/\\delta_t^2$, $\\Pi_{\\varepsilon_{\\mathrm{tv}}\\varepsilon_{\\mathrm{tv}}} = 1/\\delta_e^2$。非对角元素为零。$\\mu$ 没有先验。\n- **在标称点的偏导数**：\n    - $\\frac{\\partial \\lambda_j}{\\partial \\mu} = s_j$\n    - $\\frac{\\partial \\lambda_j}{\\partial s_\\rho} = b_j^0\\, a_j$\n    - $\\frac{\\partial \\lambda_j}{\\partial \\sigma_t} = b_j^0\\, t_j \\frac{1}{\\sigma_t^0}$\n    - $\\frac{\\partial \\lambda_j}{\\partial \\varepsilon_{\\mathrm{tv}}} = b_j^0\\, e_j \\frac{1}{\\varepsilon_{\\mathrm{tv}}^0}$\n- **Asimov 预期**：$\\lambda_{j,0} = \\lambda_j(\\mu_0,s_{\\rho,0},\\sigma_{t,0},\\varepsilon_{\\mathrm{tv},0})$。\n- **固定讨厌参数 $k$ 的影响**：$\\Delta_k = \\sqrt{\\max(0, \\sigma_{\\mu,\\mathrm{all}}^2 - \\sigma_{\\mu,\\mathrm{fixed}\\;k}^2)}$。固定通过将先验精度设为有效无穷大来实现。\n- **测试案例**：提供了三组参数。\n- **输出格式**：包含 21 个浮点数的单行列表，四舍五入到小数点后六位。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学性**：该问题基于使用费雪信息矩阵近似的似然推断这一成熟的统计方法，这是实验高能物理中进行灵敏度研究（Asimov 数据集）的标准实践。对讨厌参数及其影响的建模虽然经过简化，但代表了堆积抑制中的真实场景。该问题不含伪科学。\n2.  **良构性**：该问题在数学上是良构的。它要求根据提供的输入构建和求逆一个矩阵。对于每个测试案例，此过程都会产生一个唯一、稳定且有意义的解。\n3.  **客观性**：语言精确且量化。所有术语都在统计建模的背景下有正式定义。\n4.  **完整性和一致性**：问题提供了所有必要的数据和公式。给定的偏导数与定义的 $\\lambda_j$ 模型一致。整个设置是自洽的。\n5.  **可行性**：所需的计算是标准的线性代数运算，在数值上是可行的。在简化的模型背景下，所提供的数据值在物理上是合理的。\n\n### 步骤 3：结论与行动\n此问题有效。这是一个在物理学中常见的、良构且具有科学依据的统计数据分析练习。将提供完整解答。\n\n目标是计算信号强度参数的不确定性 $\\sigma_\\mu$，以及几个讨厌参数对该不确定性的影响。这需要构建并求逆费雪信息矩阵。我们模型的参数矢量为 $\\vartheta = (\\mu, s_\\rho, \\sigma_t, \\varepsilon_{\\mathrm{tv}})$。费雪信息矩阵 $I$ 是一个关于这些参数的 $4 \\times 4$ 矩阵。\n\n**1. 费雪信息矩阵的构建**\n\n费雪信息矩阵 $I$ 是两个分量的和：一个是从分箱计数的泊松似然中导出的统计部分 $I^{\\mathrm{stat}}$，另一个是来自讨厌参数高斯约束的先验部分 $\\Pi$。\n$I_{ab} = I^{\\mathrm{stat}}_{ab} + \\Pi_{ab}$\n统计部分由以下公式给出：\n$$\nI^{\\mathrm{stat}}_{ab} = \\sum_{j} \\frac{1}{\\lambda_{j,0}} \\left( \\frac{\\partial \\lambda_j}{\\partial \\vartheta_a} \\right)_{\\vartheta_0} \\left( \\frac{\\partial \\lambda_j}{\\partial \\vartheta_b} \\right)_{\\vartheta_0}\n$$\n其中总和遍历所有分析区间 $j$，并在标称参数点 $\\vartheta_0 = (\\mu_0, s_{\\rho,0}, \\sigma_{t,0}, \\varepsilon_{\\mathrm{tv},0})$ 进行计算。\n\n首先，我们计算 Asimov 数据集在每个区间 $j$ 中的预期产额 $\\lambda_{j,0}$，该值在标称点 $\\mu_0=1$、$s_{\\rho,0}=1$、$\\sigma_{t,0}=\\sigma_t^0$、$\\varepsilon_{\\mathrm{tv},0}=\\varepsilon_{\\mathrm{tv}}^0$ 处计算。在该点，本底展开式简化为 $b_j(1, \\sigma_t^0, \\varepsilon_{\\mathrm{tv}}^0) = b_j^0$。\n$$\n\\lambda_{j,0} = \\lambda_j(1, 1, \\sigma_t^0, \\varepsilon_{\\mathrm{tv}}^0) = 1 \\cdot s_j + b_j^0 = s_j + b_j^0\n$$\n\n接下来，我们建立关于每个参数的偏导数矢量，并在标称点进行计算。设参数 $\\vartheta_a$ 在所有区间上的导数矢量为 $D_a$。\n\\begin{align*}\n(D_\\mu)_j = \\frac{\\partial \\lambda_j}{\\partial \\mu} = s_j \\\\\n(D_{s_\\rho})_j = \\frac{\\partial \\lambda_j}{\\partial s_\\rho} = b_j^0 a_j \\\\\n(D_{\\sigma_t})_j = \\frac{\\partial \\lambda_j}{\\partial \\sigma_t} = b_j^0 t_j \\frac{1}{\\sigma_t^0} \\\\\n(D_{\\varepsilon_{\\mathrm{tv}}})_j = \\frac{\\partial \\lambda_j}{\\partial \\varepsilon_{\\mathrm{tv}}} = b_j^0 e_j \\frac{1}{\\varepsilon_{\\mathrm{tv}}^0}\n\\end{align*}\n使用这些导数矢量，统计信息矩阵的一个元素可以写成内积形式：\n$$\nI^{\\mathrm{stat}}_{ab} = \\sum_j \\frac{(D_a)_j (D_b)_j}{\\lambda_{j,0}}\n$$\n\n先验精度矩阵 $\\Pi$ 是对角的，因为假设讨厌参数具有不相关的高斯先验。信号强度 $\\mu$ 没有先验。\n$$\n\\Pi = \\mathrm{diag}\\left(0, \\frac{1}{\\delta_\\rho^2}, \\frac{1}{\\delta_t^2}, \\frac{1}{\\delta_e^2}\\right)\n$$\n\n然后通过将 $I^{\\mathrm{stat}}$ 和 $\\Pi$ 相加来组装完整的费雪信息矩阵 $I$。\n\n**2. 协方差和不确定性计算 ($\\sigma_{\\mu,\\mathrm{all}}$)**\n\n协方差矩阵 $C$ 是费雪信息矩阵的逆，即 $C = I^{-1}$。参数 $\\mu$ 的方差是对应于 $\\mu$ 的对角元素，在我们选择的参数排序中是第一个元素。\n$$\n\\sigma_{\\mu,\\mathrm{all}}^2 = C_{\\mu\\mu} = (I^{-1})_{\\mu\\mu}\n$$\n标准差，即不确定性，是方差的平方根：\n$$\n\\sigma_{\\mu,\\mathrm{all}} = \\sqrt{C_{\\mu\\mu}}\n$$\n\n**3. 固定讨厌参数时的不确定性 ($\\sigma_{\\mu,\\mathrm{fixed}\\;k}$)**\n\n为了计算当某个特定的讨厌参数 $k \\in \\{s_\\rho, \\sigma_t, \\varepsilon_{\\mathrm{tv}}\\}$ 被固定时 $\\mu$ 的不确定性，我们需要修改费雪信息矩阵。固定一个参数等同于完全知道它的值，这对应于该参数的不确定性为零。在贝叶斯框架中，这是通过施加一个无限精确的先验来实现的。精度是方差的倒数，所以我们让先验精度 $\\Pi_{kk} \\to \\infty$。\n\n在数值上，我们将先验矩阵 $\\Pi$ 中相应的对角元素替换为一个非常大的数（例如，$10^{30}$）。例如，要固定 $s_\\rho$，我们构建一个修改后的先验精度矩阵：\n$$\n\\Pi_{\\mathrm{fixed}\\;s_\\rho} = \\mathrm{diag}\\left(0, \\infty, \\frac{1}{\\delta_t^2}, \\frac{1}{\\delta_e^2}\\right)\n$$\n然后我们形成修改后的费雪矩阵 $I_{\\mathrm{fixed}\\;s_\\rho} = I^{\\mathrm{stat}} + \\Pi_{\\mathrm{fixed}\\;s_\\rho}$，将其求逆得到 $C_{\\mathrm{fixed}\\;s_\\rho}$，并提取新的不确定性 $\\sigma_{\\mu,\\mathrm{fixed}\\;s_\\rho} = \\sqrt{(C_{\\mathrm{fixed}\\;s_\\rho})_{\\mu\\mu}}$。对每个讨厌参数重复此过程。\n\n**4. 影响计算 ($\\Delta_k$)**\n\n讨厌参数 $k$ 对 $\\mu$ 不确定性的影响定义为，当该讨厌参数被固定时，$\\mu$ 的总方差减少的量。这通过正交差计算：\n$$\n\\Delta_k = \\sqrt{\\max(0, \\sigma_{\\mu,\\mathrm{all}}^2 - \\sigma_{\\mu,\\mathrm{fixed}\\;k}^2)}\n$$\n$\\max(0, \\dots)$ 函数确保结果为非负，以防止可能使差值略为负的微小数值浮点不精确性。此计算量化了每个讨厌参数对信号强度参数 $\\mu$ 总不确定性的贡献。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    test_cases = [\n        {\n            # Case 1 (three bins, moderate uncertainties)\n            's': np.array([30, 22, 12]),\n            'b0': np.array([100, 80, 60]),\n            'a': np.array([0.15, 0.20, 0.25]),\n            't': np.array([-0.10, -0.06, -0.04]),\n            'e': np.array([-0.30, -0.20, -0.15]),\n            'delta_rho': 0.10,\n            'sigma_t0': 50.0,\n            'delta_t': 10.0,\n            'eps_tv0': 0.95,\n            'delta_e': 0.02,\n        },\n        {\n            # Case 2 (three bins, no timing sensitivity)\n            's': np.array([5, 5, 5]),\n            'b0': np.array([200, 150, 100]),\n            'a': np.array([0.05, 0.04, 0.03]),\n            't': np.array([0.0, 0.0, 0.0]),\n            'e': np.array([-0.10, -0.08, -0.06]),\n            'delta_rho': 0.05,\n            'sigma_t0': 30.0,\n            'delta_t': 5.0,\n            'eps_tv0': 0.98,\n            'delta_e': 0.01,\n        },\n        {\n            # Case 3 (four bins, signal dominated, weak priors)\n            's': np.array([120, 90, 70, 50]),\n            'b0': np.array([60, 45, 35, 25]),\n            'a': np.array([0.20, 0.20, 0.20, 0.20]),\n            't': np.array([-0.05, -0.05, -0.05, -0.05]),\n            'e': np.array([-0.15, -0.15, -0.15, -0.15]),\n            'delta_rho': 0.20,\n            'sigma_t0': 80.0,\n            'delta_t': 40.0,\n            'eps_tv0': 0.90,\n            'delta_e': 0.05,\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = compute_uncertainties_and_impacts(case)\n        all_results.extend(results)\n\n    # Format the final output string as required.\n    formatted_results = [f\"{r:.6f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_uncertainties_and_impacts(params: dict) -> list:\n    \"\"\"\n    Computes the uncertainties and impacts for a single set of parameters.\n\n    The order of parameters in the Fisher matrix is:\n    0: mu (signal strength)\n    1: s_rho (rho scale)\n    2: sigma_t (timing resolution)\n    3: eps_tv (track-to-vertex efficiency)\n    \"\"\"\n    # Large number to represent infinite precision for fixing a parameter.\n    FIX_PRECISION = 1.0e30\n\n    # Extract parameters from the dictionary\n    s, b0, a, t, e = params['s'], params['b0'], params['a'], params['t'], params['e']\n    delta_rho, sigma_t0, delta_t, eps_tv0, delta_e = \\\n        params['delta_rho'], params['sigma_t0'], params['delta_t'], params['eps_tv0'], params['delta_e']\n\n    # 1. Compute nominal yields and partial derivatives\n    lambda_0 = s + b0\n    \n    d_mu = s\n    d_s_rho = b0 * a\n    # Handle division by zero if sigma_t0 is zero, although not in test cases\n    d_sigma_t = (b0 * t) / sigma_t0 if sigma_t0 != 0 else np.zeros_like(b0)\n    d_eps_tv = (b0 * e) / eps_tv0 if eps_tv0 != 0 else np.zeros_like(b0)\n    \n    derivatives = [d_mu, d_s_rho, d_sigma_t, d_eps_tv]\n    \n    # 2. Construct the statistical part of the Fisher information matrix\n    n_params = len(derivatives)\n    I_stat = np.zeros((n_params, n_params))\n    for i in range(n_params):\n        for j in range(i, n_params):\n            # Sum over bins\n            val = np.sum(derivatives[i] * derivatives[j] / lambda_0)\n            I_stat[i, j] = val\n            if i != j:\n                I_stat[j, i] = val\n\n    # 3. Define prior precision matrices and compute uncertainties\n    # Base prior precisions\n    pi_s_rho = 1.0 / delta_rho**2\n    pi_sigma_t = 1.0 / delta_t**2\n    pi_eps_tv = 1.0 / delta_e**2\n    \n    prior_precisions = [\n        np.diag([0, pi_s_rho, pi_sigma_t, pi_eps_tv]),        # All floating\n        np.diag([0, FIX_PRECISION, pi_sigma_t, pi_eps_tv]),   # s_rho fixed\n        np.diag([0, pi_s_rho, FIX_PRECISION, pi_eps_tv]),     # sigma_t fixed\n        np.diag([0, pi_s_rho, pi_sigma_t, FIX_PRECISION])     # eps_tv fixed\n    ]\n\n    variances = []\n    for Pi in prior_precisions:\n        I_full = I_stat + Pi\n        try:\n            C = np.linalg.inv(I_full)\n            variances.append(C[0, 0])\n        except np.linalg.LinAlgError:\n            # Should not happen with well-posed problems\n            variances.append(np.inf)\n            \n    sigma_mu_all_sq = variances[0]\n    sigma_mu_all = np.sqrt(sigma_mu_all_sq)\n    \n    sigma_mu_fixed_s_rho = np.sqrt(variances[1])\n    sigma_mu_fixed_sigma_t = np.sqrt(variances[2])\n    sigma_mu_fixed_eps_tv = np.sqrt(variances[3])\n\n    # 4. Compute impacts\n    delta_s_rho = np.sqrt(max(0, sigma_mu_all_sq - sigma_mu_fixed_s_rho**2))\n    delta_sigma_t = np.sqrt(max(0, sigma_mu_all_sq - sigma_mu_fixed_sigma_t**2))\n    delta_eps_tv = np.sqrt(max(0, sigma_mu_all_sq - sigma_mu_fixed_eps_tv**2))\n    \n    return [\n        sigma_mu_all,\n        sigma_mu_fixed_s_rho,\n        sigma_mu_fixed_sigma_t,\n        sigma_mu_fixed_eps_tv,\n        delta_s_rho,\n        delta_sigma_t,\n        delta_eps_tv\n    ]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}