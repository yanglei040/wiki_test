{
    "hands_on_practices": [
        {
            "introduction": "本章节的第一个练习旨在为顶点拟合奠定理论基础。在构建复杂的算法之前，理解单根径迹的精度如何影响重建顶点整体分辨率至关重要。通过一个简化的加权最小二乘模型，你将使用费雪信息矩阵（Fisher Information Matrix）从第一性原理出发，推导期望的顶点分辨率，从而深入理解如何以最优方式组合来自多个测量的信​​息。",
            "id": "3528910",
            "problem": "考虑一个对撞机探测器中简化的线性化主顶点重建问题，其中沿局部探测器 $x$ 轴的横向坐标和纵向坐标 $z$ 是根据径迹层级的约束独立估计的。每条重建的 $N$ 条带电粒子径迹都提供了相对于未知主顶点位置的两个一维残差，其模型如下：\n$$\ny_{x,i} \\;=\\; x \\;+\\; \\epsilon_{x,i}, \\qquad y_{z,i} \\;=\\; z \\;+\\; \\epsilon_{z,i}, \\qquad i = 1,\\dots,N,\n$$\n其中，$x$ 和 $z$ 是待估计的真实主顶点坐标，而 $\\epsilon_{x,i}$ 和 $\\epsilon_{z,i}$ 是独立的、均值为零且已知方差分别为 $\\sigma_{d0,i}^{2}$ 和 $\\sigma_{z0,i}^{2}$ 的高斯噪声。假设所有径迹相互独立，并且横向和纵向拟合是解耦的，因此在线性化中交叉导数消失。\n\n一个稳健的顶点拟合为每条径迹分配一个确定性权重 $w_i \\in [0,1]$，该权重在不改变每条径迹的高斯噪声模型的情况下，调节其对目标函数的贡献。该拟合旨在最小化加权平方和目标函数\n$$\n\\mathcal{L}(x,z) \\;=\\; \\frac{1}{2}\\sum_{i=1}^{N} w_i\\left(\\frac{(y_{x,i}-x)^{2}}{\\sigma_{d0,i}^{2}} \\;+\\; \\frac{(y_{z,i}-z)^{2}}{\\sigma_{z0,i}^{2}}\\right).\n$$\n在最优值附近的标准高斯近似下，通过最大似然估计（MLE）获得的估计量的协方差，是从独立径迹约束中累积的 Fisher 信息矩阵（FIM）的逆矩阵。\n\n仅从上述高斯测量模型、独立性假设以及高斯噪声的 Fisher 信息矩阵的定义出发，推导 $x$ 和 $z$ 方向上预期主顶点分辨率（一个标准差）的闭式解析表达式，该表达式应是 $N$、径迹权重 $w_i$ 以及每条径迹的不确定度 $\\sigma_{d0,i}$ 和 $\\sigma_{z0,i}$ 的函数。请将您的最终答案表示为包含两个分辨率的单行矩阵。不要代入任何数值；只提供解析表达式。不需要单位转换。为清晰起见，请用 $w_i$、$\\sigma_{d0,i}$ 和 $\\sigma_{z0,i}$ 表示最终表达式。",
            "solution": "此问题是有效的，因为它在统计估计领域提出了一个自洽、有科学依据且适定的问题，这与高能物理数据分析相关。\n\n目标是求解估计的顶点坐标 $\\hat{x}$ 和 $\\hat{z}$ 的分辨率。分辨率定义为估计量的标准差。问题陈述，估计量的协方差矩阵是 Fisher 信息矩阵（FIM）的逆矩阵。待估计的参数为 $\\theta = \\begin{pmatrix} x \\\\ z \\end{pmatrix}$。FIM，记作 $\\mathbf{I}$，是一个 $2 \\times 2$ 矩阵，其元素由下式给出：\n$$\nI_{jk} = -E\\left[\\frac{\\partial^2 \\ln L}{\\partial \\theta_j \\partial \\theta_k}\\right]\n$$\n其中 $L$ 是似然函数。对于具有高斯噪声模型的最小二乘问题，最小化平方和目标函数等价于最大化似然函数。给定的目标函数为\n$$\n\\mathcal{L}(x,z) = \\frac{1}{2}\\sum_{i=1}^{N} w_i\\left(\\frac{(y_{x,i}-x)^{2}}{\\sigma_{d0,i}^{2}} + \\frac{(y_{z,i}-z)^{2}}{\\sigma_{z0,i}^{2}}\\right)\n$$\n这个加权平方和函数扮演着负对数似然的角色（相差一个可加常数）。我们定义一个有效的对数似然 $l_{\\text{eff}}(x,z)$ 如下：\n$$\nl_{\\text{eff}}(x,z) = - \\mathcal{L}(x,z) = -\\frac{1}{2}\\sum_{i=1}^{N} w_i\\left(\\frac{(y_{x,i}-x)^{2}}{\\sigma_{d0,i}^{2}} + \\frac{(y_{z,i}-z)^{2}}{\\sigma_{z0,i}^{2}}\\right)\n$$\n我们基于这个有效的对数似然来计算 FIM。FIM 的元素是 $l_{\\text{eff}}$ 的二阶偏导数的负期望值。\n\n首先，我们计算关于 $x$ 的二阶偏导数：\n$$\n\\frac{\\partial l_{\\text{eff}}}{\\partial x} = -\\frac{1}{2} \\sum_{i=1}^{N} w_i \\frac{\\partial}{\\partial x} \\left(\\frac{(y_{x,i}-x)^{2}}{\\sigma_{d0,i}^{2}}\\right) = -\\frac{1}{2} \\sum_{i=1}^{N} w_i \\frac{2(y_{x,i}-x)(-1)}{\\sigma_{d0,i}^{2}} = \\sum_{i=1}^{N} w_i \\frac{y_{x,i}-x}{\\sigma_{d0,i}^{2}}\n$$\n$$\n\\frac{\\partial^2 l_{\\text{eff}}}{\\partial x^2} = \\frac{\\partial}{\\partial x} \\left( \\sum_{i=1}^{N} w_i \\frac{y_{x,i}-x}{\\sigma_{d0,i}^{2}} \\right) = \\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{d0,i}^{2}} (-1) = - \\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{d0,i}^{2}}\n$$\n这个二阶导数相对于随机变量 $y_{x,i}$ 是一个常数，所以它的期望就是它本身。FIM 的 $(1,1)$ 元素是：\n$$\nI_{xx} = -E\\left[\\frac{\\partial^2 l_{\\text{eff}}}{\\partial x^2}\\right] = - \\left( - \\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{d0,i}^{2}} \\right) = \\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{d0,i}^{2}}\n$$\n类似地，对于 $z$ 坐标：\n$$\n\\frac{\\partial^2 l_{\\text{eff}}}{\\partial z^2} = - \\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{z0,i}^{2}}\n$$\nFIM 的 $(2,2)$ 元素是：\n$$\nI_{zz} = -E\\left[\\frac{\\partial^2 l_{\\text{eff}}}{\\partial z^2}\\right] = - \\left( - \\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{z0,i}^{2}} \\right) = \\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{z0,i}^{2}}\n$$\n最后，我们计算非对角元素。由于目标函数 $\\mathcal{L}(x,z)$ 可分离为关于 $x$ 和 $z$ 的函数，混合偏导数为零：\n$$\n\\frac{\\partial^2 l_{\\text{eff}}}{\\partial x \\partial z} = \\frac{\\partial}{\\partial x} \\left( \\frac{\\partial l_{\\text{eff}}}{\\partial z} \\right) = \\frac{\\partial}{\\partial x} \\left( \\sum_{i=1}^{N} w_i \\frac{y_{z,i}-z}{\\sigma_{z0,i}^{2}} \\right) = 0\n$$\n因此，FIM 的非对角元素为零：$I_{xz} = I_{zx} = 0$。这证实了问题陈述中拟合是解耦的条件。\n\nFIM 是一个对角矩阵：\n$$\n\\mathbf{I} = \\begin{pmatrix} \\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{d0,i}^{2}}  0 \\\\ 0  \\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{z0,i}^{2}} \\end{pmatrix}\n$$\n估计量的协方差矩阵 $\\mathbf{C}$ 是 FIM 的逆矩阵：\n$$\n\\mathbf{C} = \\mathbf{I}^{-1} = \\begin{pmatrix} \\left(\\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{d0,i}^{2}}\\right)^{-1}  0 \\\\ 0  \\left(\\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{z0,i}^{2}}\\right)^{-1} \\end{pmatrix}\n$$\n估计量 $\\hat{x}$ 和 $\\hat{z}$ 的方差是协方差矩阵的对角元素：\n$$\n\\text{Var}(\\hat{x}) = C_{11} = \\left(\\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{d0,i}^{2}}\\right)^{-1}\n$$\n$$\n\\text{Var}(\\hat{z}) = C_{22} = \\left(\\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{z0,i}^{2}}\\right)^{-1}\n$$\n预期的分辨率是标准差，即方差的平方根。\n$x$ 方向的分辨率 $\\sigma_{\\hat{x}}$ 是：\n$$\n\\sigma_{\\hat{x}} = \\sqrt{\\text{Var}(\\hat{x})} = \\left(\\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{d0,i}^{2}}\\right)^{-1/2}\n$$\n$z$ 方向的分辨率 $\\sigma_{\\hat{z}}$ 是：\n$$\n\\sigma_{\\hat{z}} = \\sqrt{\\text{Var}(\\hat{z})} = \\left(\\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{z0,i}^{2}}\\right)^{-1/2}\n$$\n最终答案以包含这两个分辨率的行矩阵形式呈现。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left(\\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{d0,i}^{2}}\\right)^{-\\frac{1}{2}}  \\left(\\sum_{i=1}^{N} \\frac{w_i}{\\sigma_{z0,i}^{2}}\\right)^{-\\frac{1}{2}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "标准的最小二乘拟合对离群值非常敏感，单根质量差的径迹就可能严重破坏顶点估计的准确性。本实践直接应对这一真实世界中的挑战。你将探索从拟合中移除一个具有较大卡方（$\\chi^2$）值的径迹所带来的影响，并通过应用谢尔曼-莫里森（Sherman-Morrison）公式来高效地更新结果，而不是从头重新计算整个拟合。这个练习展示了一种强大且计算上极为巧妙的技术，是许多自适应和鲁棒拟合算法的核心。",
            "id": "3528987",
            "problem": "在横向平面内的最小二乘主顶点拟合中，顶点位置 $\\mathbf{x} \\in \\mathbb{R}^{2}$ 通过求解正规方程 $\\mathbf{N}\\,\\mathbf{x}=\\mathbf{b}$ 来估计，其中 $\\mathbf{N}=\\sum_{i} w_{i}\\,\\mathbf{n}_{i}\\mathbf{n}_{i}^{\\top}$ 且 $\\mathbf{b}=\\sum_{i} w_{i}\\,\\mathbf{n}_{i}\\,d_{i}$，其中 $w_{i}$ 是径迹到顶点的线性化约束的反方差权重，$\\mathbf{n}_{i}$ 是这些约束的单位法线方向，$d_{i}$ 是相对于当前线性化点的带符号标量残差（碰撞参数）。考虑一个拟合，其参数为\n$$\n\\mathbf{N}=\\begin{pmatrix}50  5 \\\\ 5  20\\end{pmatrix}, \\quad \\mathbf{b}=\\begin{pmatrix}10 \\\\ -5\\end{pmatrix},\n$$\n因此当前的顶点估计为 $\\mathbf{x}=\\mathbf{N}^{-1}\\mathbf{b}$。现在，识别出一条产生较大卡方值（卡方用希腊字母 $\\chi^{2}$ 表示）的径迹，其单位法线方向为\n$$\n\\mathbf{n}=\\begin{pmatrix} \\tfrac{3}{5} \\\\ \\tfrac{4}{5} \\end{pmatrix},\n$$\n权重为\n$$\nw=100,\n$$\n带符号残差为\n$$\nd=\\tfrac{3}{2} \\text{ mm}.\n$$\n从拟合中移除该径迹会将正规矩阵和等式右侧项变为\n$$\n\\mathbf{N}'=\\mathbf{N}-w\\,\\mathbf{n}\\mathbf{n}^{\\top}, \\qquad \\mathbf{b}'=\\mathbf{b}-w\\,\\mathbf{n}\\,d.\n$$\n从最小二乘正规方程的公式和矩阵的秩-1逆更新恒等式（Sherman–Morrison）出发，推导更新后的顶点 $\\mathbf{x}'=\\mathbf{N}'^{-1}\\mathbf{b}'$ 的解析表达式，并用它来计算移除该径迹所引起的 $x$ 分量的变化量 $\\Delta x_{x}=\\left(x'_{x}-x_{x}\\right)$。将 $\\Delta x_{x}$ 的最终数值以微米表示，并将答案四舍五入到四位有效数字。避免中间过程的四舍五入；在最终转换为微米之前，进行精确或符号运算。",
            "solution": "问题要求计算在从最小二乘拟合中移除一条离群径迹后，顶点位置 $x$ 分量的变化量 $\\Delta x_{x} = x'_{x}-x_{x}$。初始顶点位置为 $\\mathbf{x}=\\mathbf{N}^{-1}\\mathbf{b}$，更新后的顶点位置为 $\\mathbf{x}'=\\mathbf{N}'^{-1}\\mathbf{b}'$。\n\n首先，我们推导顶点位置向量变化量 $\\Delta\\mathbf{x} = \\mathbf{x}' - \\mathbf{x}$ 的通用解析表达式。\n更新后的正规矩阵和等式右侧向量由下式给出：\n$$ \\mathbf{N}' = \\mathbf{N} - w\\,\\mathbf{n}\\mathbf{n}^{\\top} $$\n$$ \\mathbf{b}' = \\mathbf{b} - w\\,d\\,\\mathbf{n} $$\n其中 $w$、$\\mathbf{n}$ 和 $d$ 分别是移除径迹的权重、法线方向和带符号残差。\n\n更新后的顶点 $\\mathbf{x}'$ 满足新的正规方程：\n$$ \\mathbf{N}'\\mathbf{x}' = \\mathbf{b}' $$\n代入 $\\mathbf{N}'$ 和 $\\mathbf{b}'$ 的表达式：\n$$ (\\mathbf{N} - w\\,\\mathbf{n}\\mathbf{n}^{\\top})\\mathbf{x}' = \\mathbf{b} - w\\,d\\,\\mathbf{n} $$\n我们将左侧的项展开：\n$$ \\mathbf{N}\\mathbf{x}' - w\\,\\mathbf{n}(\\mathbf{n}^{\\top}\\mathbf{x}') = \\mathbf{b} - w\\,d\\,\\mathbf{n} $$\n由于初始正规矩阵 $\\mathbf{N}$ 是可逆的（我们将验证这一点），我们可以从左侧乘以 $\\mathbf{N}^{-1}$：\n$$ \\mathbf{N}^{-1}\\mathbf{N}\\mathbf{x}' - w\\,\\mathbf{N}^{-1}\\mathbf{n}(\\mathbf{n}^{\\top}\\mathbf{x}') = \\mathbf{N}^{-1}\\mathbf{b} - w\\,d\\,\\mathbf{N}^{-1}\\mathbf{n} $$\n使用定义 $\\mathbf{I}=\\mathbf{N}^{-1}\\mathbf{N}$ 和 $\\mathbf{x}=\\mathbf{N}^{-1}\\mathbf{b}$，上式简化为：\n$$ \\mathbf{x}' - w\\,(\\mathbf{N}^{-1}\\mathbf{n})(\\mathbf{n}^{\\top}\\mathbf{x}') = \\mathbf{x} - w\\,d\\,(\\mathbf{N}^{-1}\\mathbf{n}) $$\n重新整理以找到变化量 $\\Delta \\mathbf{x} = \\mathbf{x}' - \\mathbf{x}$ 的表达式：\n$$ \\Delta\\mathbf{x} = \\mathbf{x}' - \\mathbf{x} = w\\,(\\mathbf{N}^{-1}\\mathbf{n})(\\mathbf{n}^{\\top}\\mathbf{x}') - w\\,d\\,(\\mathbf{N}^{-1}\\mathbf{n}) $$\n$$ \\Delta\\mathbf{x} = w\\,(\\mathbf{n}^{\\top}\\mathbf{x}' - d)(\\mathbf{N}^{-1}\\mathbf{n}) $$\n这个 $\\Delta\\mathbf{x}$ 的表达式通过标量项 $\\mathbf{n}^{\\top}\\mathbf{x}' - d$ 依赖于未知的更新后顶点 $\\mathbf{x}'$。为了求出这一项，我们可以用 $\\mathbf{n}^{\\top}$ 左乘 $\\Delta\\mathbf{x}$ 的方程：\n$$ \\mathbf{n}^{\\top}(\\mathbf{x}' - \\mathbf{x}) = w\\,(\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n})(\\mathbf{n}^{\\top}\\mathbf{x}' - d) $$\n令移除的径迹相对于新顶点的标量残差为 $r' = \\mathbf{n}^{\\top}\\mathbf{x}' - d$，相对于旧顶点的残差为 $r = \\mathbf{n}^{\\top}\\mathbf{x} - d$。方程变为：\n$$ (r' + d) - (r + d) = w\\,(\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n})r' $$\n$$ r' - r = w\\,(\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n})r' $$\n$$ r'(1 - w\\,\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n}) = r $$\n求解 $r'$ 得：\n$$ r' = \\frac{r}{1 - w\\,\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n}} = \\frac{\\mathbf{n}^{\\top}\\mathbf{x} - d}{1 - w\\,\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n}} $$\n将此结果代回 $\\Delta\\mathbf{x}$ 的表达式：\n$$ \\Delta\\mathbf{x} = w\\,\n\\left( \\frac{\\mathbf{n}^{\\top}\\mathbf{x} - d}{1 - w\\,\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n}} \\right)\n(\\mathbf{N}^{-1}\\mathbf{n}) $$\n这就是所求的解析表达式。我们现在使用所提供的值进行数值计算。\n\n给定的量为：\n$$ \\mathbf{N}=\\begin{pmatrix} 50  5 \\\\ 5  20 \\end{pmatrix}, \\quad \\mathbf{b}=\\begin{pmatrix} 10 \\\\ -5 \\end{pmatrix}, \\quad \\mathbf{n}=\\begin{pmatrix} 3/5 \\\\ 4/5 \\end{pmatrix}, \\quad w=100, \\quad d=\\frac{3}{2} \\, \\text{mm} $$\n所有与长度相关的量的单位都假定为毫米（$mm$）。\n\n1.  计算 $\\mathbf{N}^{-1}$：\n    $\\det(\\mathbf{N}) = (50)(20) - (5)(5) = 1000 - 25 = 975$。由于 $\\det(\\mathbf{N}) \\neq 0$，该矩阵是可逆的。\n    $$ \\mathbf{N}^{-1} = \\frac{1}{975}\\begin{pmatrix} 20  -5 \\\\ -5  50 \\end{pmatrix} = \\frac{5}{975}\\begin{pmatrix} 4  -1 \\\\ -1  10 \\end{pmatrix} = \\frac{1}{195}\\begin{pmatrix} 4  -1 \\\\ -1  10 \\end{pmatrix} $$\n\n2.  计算初始顶点位置 $\\mathbf{x}$：\n    $$ \\mathbf{x} = \\mathbf{N}^{-1}\\mathbf{b} = \\frac{1}{195}\\begin{pmatrix} 4  -1 \\\\ -1  10 \\end{pmatrix}\\begin{pmatrix} 10 \\\\ -5 \\end{pmatrix} = \\frac{1}{195}\\begin{pmatrix} 4(10)+(-1)(-5) \\\\ -1(10)+10(-5) \\end{pmatrix} = \\frac{1}{195}\\begin{pmatrix} 45 \\\\ -60 \\end{pmatrix} = \\frac{15}{195}\\begin{pmatrix} 3 \\\\ -4 \\end{pmatrix} = \\frac{1}{13}\\begin{pmatrix} 3 \\\\ -4 \\end{pmatrix} $$\n\n3.  计算项 $\\mathbf{n}^{\\top}\\mathbf{x} - d$：\n    $$ \\mathbf{n}^{\\top}\\mathbf{x} = \\begin{pmatrix} \\frac{3}{5}  \\frac{4}{5} \\end{pmatrix} \\frac{1}{13}\\begin{pmatrix} 3 \\\\ -4 \\end{pmatrix} = \\frac{1}{65}(3 \\cdot 3 + 4 \\cdot (-4)) = \\frac{9-16}{65} = -\\frac{7}{65} $$\n    $$ \\mathbf{n}^{\\top}\\mathbf{x} - d = -\\frac{7}{65} - \\frac{3}{2} = \\frac{-14 - 3(65)}{130} = \\frac{-14-195}{130} = -\\frac{209}{130} $$\n\n4.  计算向量 $\\mathbf{v} = \\mathbf{N}^{-1}\\mathbf{n}$：\n    $$ \\mathbf{v} = \\frac{1}{195}\\begin{pmatrix} 4  -1 \\\\ -1  10 \\end{pmatrix}\\begin{pmatrix} 3/5 \\\\ 4/5 \\end{pmatrix} = \\frac{1}{195 \\cdot 5}\\begin{pmatrix} 4(3)-1(4) \\\\ -1(3)+10(4) \\end{pmatrix} = \\frac{1}{975}\\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} $$\n\n5.  计算分母中的标量 $1 - w\\,\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n}$。首先，求出 $\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n} = \\mathbf{n}^{\\top}\\mathbf{v}$：\n    $$ \\mathbf{n}^{\\top}\\mathbf{v} = \\begin{pmatrix} \\frac{3}{5}  \\frac{4}{5} \\end{pmatrix} \\frac{1}{975}\\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} = \\frac{1}{5 \\cdot 975}(3 \\cdot 8 + 4 \\cdot 37) = \\frac{24+148}{4875} = \\frac{172}{4875} $$\n    现在计算完整的分母：\n    $$ 1 - w\\,\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n} = 1 - 100\\left(\\frac{172}{4875}\\right) = 1 - 4 \\cdot 25 \\left(\\frac{172}{195 \\cdot 25}\\right) = 1 - \\frac{688}{195} = \\frac{195-688}{195} = -\\frac{493}{195} $$\n\n6.  组合 $\\Delta\\mathbf{x}$ 的表达式：\n    $$ \\Delta\\mathbf{x} = \\frac{w(\\mathbf{n}^{\\top}\\mathbf{x} - d)}{1 - w\\,\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n}} (\\mathbf{N}^{-1}\\mathbf{n}) = \\frac{100(-\\frac{209}{130})}{-\\frac{493}{195}} \\left( \\frac{1}{975}\\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} \\right) $$\n    前面的标量因子是：\n    $$ \\frac{-20900/130}{-493/195} = \\frac{2090}{13}\\frac{195}{493} = \\frac{2090}{13} \\frac{15 \\cdot 13}{493} = \\frac{2090 \\cdot 15}{493} = \\frac{31350}{493} $$\n    所以，\n    $$ \\Delta\\mathbf{x} = \\frac{31350}{493} \\left( \\frac{1}{975}\\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} \\right) = \\frac{31350}{493 \\cdot 975} \\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} $$\n    简化标量分数：\n    $$ \\frac{31350}{975} = \\frac{31350/25}{975/25} = \\frac{1254}{39} = \\frac{1254/3}{39/3} = \\frac{418}{13} $$\n    因此，向量变为：\n    $$ \\Delta\\mathbf{x} = \\frac{418/13}{493} \\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} = \\frac{418}{13 \\cdot 493} \\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} = \\frac{418}{6409} \\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} $$\n\n7.  提取 $x$ 分量 $\\Delta x_{x}$：\n    $$ \\Delta x_{x} = \\frac{418}{6409} \\cdot 8 = \\frac{3344}{6409} \\, \\text{mm} $$\n\n8.  转换为微米（$\\mu\\text{m}$）并四舍五入到四位有效数字。\n    $$ \\Delta x_{x} = \\frac{3344}{6409} \\times 1000 \\, \\mu\\text{m} \\approx 0.521766266... \\times 1000 \\, \\mu\\text{m} = 521.766266... \\, \\mu\\text{m} $$\n    四舍五入到四位有效数字得到 $521.8 \\, \\mu\\text{m}$。",
            "answer": "$$\\boxed{521.8}$$"
        },
        {
            "introduction": "为了构建真正有韧性的重建算法，我们必须从临时移除离群点的方法，转向系统性的鲁棒估计。这项综合性练习将引导你完成基于M估计（M-estimation）原理的现代鲁棒顶点拟合器的设计、实现和评估。你将在迭代重加权最小二乘（Iteratively Reweighted Least Squares, IRLS）框架内，为胡贝尔（Huber）损失和学生t（Student-t）损失推导并实现权重函数，并通过研究它们在面对严重离群值污染时的经验击穿点，来严格评估其性能。",
            "id": "3528981",
            "problem": "您的任务是设计、推导和评估用于对撞机事件中三维主顶点位置的稳健估计器，其中每条重建径迹都提供了一个最近接点位置及其相关的协方差。顶点位置由三维向量 $\\vec{v} \\in \\mathbb{R}^{3}$ 表示，第 $i$ 条径迹的测量值为 $\\vec{r}_{i} \\in \\mathbb{R}^{3}$，其协方差矩阵 $C_{i} \\in \\mathbb{R}^{3 \\times 3}$ 是对称正定的。马氏残差范数（Mahalanobis residual norm）定义为\n$$\n\\rho_{i}(\\vec{v}) = \\sqrt{(\\vec{r}_{i} - \\vec{v})^{\\top} C_{i}^{-1} (\\vec{r}_{i} - \\vec{v})}.\n$$\n稳健拟合的范式是通过最小化一系列稳健损失之和来估计 $\\vec{v}$，\n$$\n\\min_{\\vec{v} \\in \\mathbb{R}^{3}} \\sum_{i=1}^{N} \\phi(\\rho_{i}(\\vec{v})),\n$$\n其中 $\\phi(\\cdot)$ 是一个非负、可微的损失函数。从以下基本基础开始：\n- 高斯误差下的最大似然法产生最小二乘法，即 $\\phi(\\rho) = \\tfrac{1}{2}\\rho^{2}$。\n- 对于一般的稳健损失，一阶最优性条件导出一个迭代重加权最小二乘方案，该方案基于得分函数 $\\psi(\\rho) = \\tfrac{d\\phi(\\rho)}{d\\rho}$ 和权重函数 $w(\\rho) = \\psi(\\rho)/\\rho$，并约定在需要时，$w(0)$ 是极限 $\\lim_{\\rho \\to 0^{+}} \\psi(\\rho)/\\rho$。\n- 给定权重 $w_{i} \\equiv w(\\rho_{i})$，$\\vec{v}$ 的重加权正规方程的一次迭代形式为\n$$\n\\left(\\sum_{i=1}^{N} w_{i} C_{i}^{-1}\\right)\\vec{v} = \\sum_{i=1}^{N} w_{i} C_{i}^{-1} \\vec{r}_{i}.\n$$\n您的任务是：\n1) 使用上述定义，为以下两种稳健损失推导权重函数 $w_{i}(\\rho_{i})$，并用残差范数 $\\rho$ 表示：\n- Huber 损失，其截断参数 $k0$，由一个分段函数 $\\phi(\\rho)$ 定义，该函数在 $\\rho$ 较小时为二次函数，在 $\\rho$ 较大时为线性函数。\n- 具有 $\\nu0$ 自由度的 $d$ 维观测值的多元 Student-$t$ 负对数似然，它产生一个形式为 $\\phi(\\rho)$ 的损失函数，该函数通过一个包含 $1+\\rho^{2}/\\nu$ 的对数项依赖于 $d$、$\\nu$ 和 $\\rho$。\n2) 实现一个迭代重加权最小二乘算法，对于上述两种稳健损失中的每一种，根据给定的 $\\{\\vec{r}_{i}, C_{i}\\}_{i=1}^{N}$ 估计主顶点 $\\vec{v}$。使用维度 $d=3$。通过使用收敛容差和最大迭代次数来确保数值稳定性。所有坐标均以毫米（mm）为单位；在本部分中，您需要报告的输出量是无量纲的，但算法内部必须处理以毫米为单位的位置。\n3) 通过模拟含有不断增加比例的离群点的数据，研究污染下的经验性崩溃行为。使用以下物理上和数值上合理的场景：\n- 真实顶点 $\\vec{v}_{\\text{true}} = (0,0,0)$ mm。\n- 径迹数量 $N=100$。\n- 内点：$N_{\\text{in}} = \\lfloor (1-p) N \\rfloor$ 条径迹，独立采样自以 $\\vec{v}_{\\text{true}}$ 为中心、各向同性协方差为 $\\sigma_{\\text{in}}^{2} I_{3}$ 的正态分布，其中 $\\sigma_{\\text{in}} = 0.03$ mm。每个内点的协方差为 $C_{i} = \\sigma_{\\text{in}}^{2} I_{3}$。\n- 离群点：$N_{\\text{out}} = N - N_{\\text{in}}$ 条径迹，独立采样自均值为 $\\vec{\\mu}_{\\text{out}} = (10,-10,5)$ mm、各向同性协方差为 $\\sigma_{\\text{out}}^{2} I_{3}$ 的正态分布，其中 $\\sigma_{\\text{out}} = 2.0$ mm。为简单起见，离群点也使用相同的每条径迹的协方差 $C_{i} = \\sigma_{\\text{in}}^{2} I_{3}$，这代表了对不良径迹不确定度的低估。\n- 考虑离群点比例 $p \\in \\{0.0, 0.2, 0.4, 0.6\\}$。\n- 如果在给定的 $p$ 下，估计的顶点 $\\hat{\\vec{v}}$ 满足 $\\|\\hat{\\vec{v}} - \\vec{v}_{\\text{true}}\\|_{2}  1.0$ mm，则定义为失效（崩溃）。\n- 对于每种稳健损失，报告给定集合中导致失效的最小 $p$ 值。如果集合中没有任何 $p$ 值导致失效，则报告 $1.0$。\n为保证数值可复现性，请在模拟中使用固定的随机种子。不涉及角度；无需角度单位。所有距离均以毫米为单位；下面要求的输出是无量纲的。\n测试套件和要求输出：\n- 在残差范数 $\\rho \\in \\{0.5, 1.5, 3.0\\}$ 处使用以下参数进行权重函数评估测试：\n  - Huber: $k = 1.5$。\n  - Student-$t$: $\\nu = 4$, $d = 3$。\n- 使用 $p \\in \\{0.0, 0.2, 0.4, 0.6\\}$ 和上述模拟设计进行崩溃研究。\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[w_{H}(0.5), w_{H}(1.5), w_{H}(3.0), w_{T}(0.5), w_{T}(1.5), w_{T}(3.0), p_{\\text{break,Huber}}, p_{\\text{break,Student}}]$,\n其中 $w_{H}(\\cdot)$ 和 $w_{T}(\\cdot)$ 分别是为 Huber 和 Student-$t$ 推导的权重函数，而 $p_{\\text{break,Huber}}$ 和 $p_{\\text{break,Student}}$ 是如上定义的测试集中的最小失效比例。这八个输出是无量纲的实数。该单行必须严格包含此列表格式，不得有任何附加文本。",
            "solution": "主顶点重建问题是实验粒子物理学中的一项基本任务。它可以被看作是统计学中的一个 M-估计问题，其目标是找到一个顶点位置 $\\vec{v} \\in \\mathbb{R}^{3}$，以最小化应用于测量径迹残差的一系列损失函数之和。使用稳健损失函数对于降低那些并非源自主要相互作用的离群径迹的影响至关重要。本解决方案首先为指定的稳健损失推导权重函数，然后描述用于寻找顶点的迭代重加权最小二乘（IRLS）算法，最后详细说明旨在测试估计器崩溃点的模拟设计。\n\n**1. 权重函数的推导**\n\nIRLS 算法依赖于从所选损失函数 $\\phi(\\rho)$ 推导出的权重函数 $w(\\rho)$。权重函数通过得分函数 $\\psi(\\rho) = \\frac{d\\phi}{d\\rho}$ 定义为 $w(\\rho) = \\psi(\\rho)/\\rho$。\n\n**Huber 损失**\n带有截断参数 $k  0$ 的 Huber 损失函数是小残差的二次损失和大残差的线性损失的混合体。由于马氏范数 $\\rho$ 始终为非负值，损失函数为：\n$$\n\\phi_H(\\rho) = \\begin{cases} \\frac{1}{2}\\rho^2  \\text{if } 0 \\le \\rho \\le k \\\\ k\\rho - \\frac{1}{2}k^2  \\text{if } \\rho  k \\end{cases}\n$$\n相应的得分函数 $\\psi_H(\\rho) = \\frac{d\\phi_H}{d\\rho}$ 是通过对 $\\rho$ 求导得到的：\n$$\n\\psi_H(\\rho) = \\begin{cases} \\rho  \\text{if } 0 \\le \\rho \\le k \\\\ k  \\text{if } \\rho  k \\end{cases}\n$$\n这可以更紧凑地写作 $\\psi_H(\\rho) = \\min(\\rho, k)$。因此，权重函数 $w_H(\\rho) = \\psi_H(\\rho)/\\rho$ 为：\n$$\nw_H(\\rho) = \\begin{cases} 1  \\text{if } 0 \\le \\rho \\le k \\\\ k/\\rho  \\text{if } \\rho  k \\end{cases}\n$$\n这可以表示为 $w_H(\\rho) = \\min(1, k/\\rho)$。该函数为在截断值 $k$ 以内的残差分配常数权重 $1$（相当于标准最小二乘法），并对大于 $k$ 的残差进行降权。\n\n**Student-t 损失**\n该损失函数源自具有 $\\nu$ 自由度的 $d$ 维多元 Student-$t$ 分布的负对数似然。其概率密度函数与 $(1 + \\frac{1}{\\nu} \\rho^2)^{-(\\nu+d)/2}$ 成正比，其中 $\\rho^2 = (\\vec{r} - \\vec{v})^\\top C^{-1} (\\vec{r} - \\vec{v})$ 是马氏距离的平方。忽略加性常数后，负对数似然给出了损失函数：\n$$\n\\phi_T(\\rho) = \\frac{\\nu+d}{2} \\log\\left(1 + \\frac{\\rho^2}{\\nu}\\right)\n$$\n使用链式法则可以找到得分函数 $\\psi_T(\\rho) = \\frac{d\\phi_T}{d\\rho}$：\n$$\n\\psi_T(\\rho) = \\frac{\\nu+d}{2} \\cdot \\frac{1}{1 + \\rho^2/\\nu} \\cdot \\frac{d}{d\\rho}\\left(\\frac{\\rho^2}{\\nu}\\right) = \\frac{\\nu+d}{2} \\cdot \\frac{\\nu}{\\nu + \\rho^2} \\cdot \\frac{2\\rho}{\\nu} = \\frac{(\\nu+d)\\rho}{\\nu + \\rho^2}\n$$\n相应的权重函数 $w_T(\\rho) = \\psi_T(\\rho)/\\rho$ 是：\n$$\nw_T(\\rho) = \\frac{\\nu+d}{\\nu + \\rho^2}\n$$\n随着残差范数 $\\rho$ 的增加，该权重函数平滑地减小，从而对离群点进行软降权。与 Huber 损失不同，它没有一个尖锐的截断点。\n\n**2. 迭代重加权最小二乘（IRLS）算法**\n\n$\\sum_i \\phi(\\rho_i(\\vec{v}))$ 的最小化是一个非线性优化问题。IRLS 算法是找到解的一个迭代过程。每次迭代都涉及解决一个加权最小二乘问题，其中权重根据前一次迭代的残差进行更新。一般的更新步骤由正规方程决定：\n$$\n\\vec{v}^{(t+1)} = \\left(\\sum_{i=1}^{N} w_{i}^{(t)} C_{i}^{-1}\\right)^{-1} \\left(\\sum_{i=1}^{N} w_{i}^{(t)} C_{i}^{-1} \\vec{r}_{i}\\right)\n$$\n其中 $w_i^{(t)} = w(\\rho_i(\\vec{v}^{(t)}))$ 是使用前一次迭代的顶点估计值 $\\vec{v}^{(t)}$ 计算出的权重。\n\n问题的模拟设计带来了一个显著的简化，其中所有协方差矩阵都是相同且各向同性的：对所有 $i$，都有 $C_i = \\sigma_{\\text{in}}^2 I_3$。因此，其逆矩阵为 $C_i^{-1} = (1/\\sigma_{\\text{in}}^2) I_3$。将此代入正规方程：\n$$\n\\left(\\sum_{i=1}^{N} w_{i}^{(t)} \\frac{1}{\\sigma_{\\text{in}}^2} I_3\\right)\\vec{v}^{(t+1)} = \\sum_{i=1}^{N} w_{i}^{(t)} \\frac{1}{\\sigma_{\\text{in}}^2} I_3 \\vec{r}_{i}\n$$\n常数矩阵项 $(1/\\sigma_{\\text{in}}^2) I_3$ 可以从两侧提取并消去，得到：\n$$\n\\left(\\sum_{i=1}^{N} w_{i}^{(t)}\\right) \\vec{v}^{(t+1)} = \\sum_{i=1}^{N} w_{i}^{(t)} \\vec{r}_{i}\n$$\n这表明更新后的顶点估计值就是径迹位置的加权平均值：\n$$\n\\vec{v}^{(t+1)} = \\frac{\\sum_{i=1}^{N} w_i^{(t)} \\vec{r}_i}{\\sum_{i=1}^{N} w_i^{(t)}}\n$$\n马氏范数也简化为：\n$$\n\\rho_i(\\vec{v}) = \\sqrt{(\\vec{r}_i - \\vec{v})^\\top \\left(\\frac{1}{\\sigma_{\\text{in}}^2}I_3\\right) (\\vec{r}_i - \\vec{v})} = \\frac{1}{\\sigma_{\\text{in}}} \\sqrt{(\\vec{r}_i - \\vec{v})^\\top (\\vec{r}_i - \\vec{v})} = \\frac{\\|\\vec{r}_i - \\vec{v}\\|_2}{\\sigma_{\\text{in}}}\n$$\n算法流程如下：\n1.  初始化 $\\vec{v}^{(0)}$ 为所有 $\\vec{r}_i$ 的未加权平均值。\n2.  对于 $t = 0, 1, 2, \\dots$ 直到达到最大迭代次数：\n    a.  计算范数 $\\rho_i^{(t)} = \\|\\vec{r}_i - \\vec{v}^{(t)}\\|_2 / \\sigma_{\\text{in}}$。\n    b.  使用相应的推导函数（Huber 或 Student-t）计算权重 $w_i^{(t)} = w(\\rho_i^{(t)})$。\n    c.  使用加权平均公式更新顶点估计值 $\\vec{v}^{(t+1)}$。\n    d.  检查收敛性：如果 $\\|\\vec{v}^{(t+1)} - \\vec{v}^{(t)}\\|_2$ 小于指定的容差，则终止。\n3.  最终的 $\\vec{v}^{(t+1)}$ 即为估计的顶点位置。\n\n**3. 经验性崩溃研究**\n\n估计器的崩溃点，通俗地讲，是它在产生任意错误的估计之前所能容忍的污染数据的最大比例。该研究通过经验方法分析这种行为。\n对于每个离群点比例 $p \\in \\{0.0, 0.2, 0.4, 0.6\\}$：\n- 模拟一个包含 $N=100$ 条径迹的数据集。\n- 从以真实顶点 $\\vec{v}_{\\text{true}} = (0,0,0)$ mm 为中心、$\\sigma_{\\text{in}} = 0.03$ mm 的窄高斯分布中抽取 $N_{\\text{in}} = \\lfloor (1-p)N \\rfloor$ 个内点位置。\n- 从另一个以 $\\vec{\\mu}_{\\text{out}} = (10,-10,5)$ mm 为中心、展宽较大（$\\sigma_{\\text{out}} = 2.0$ mm）的高斯分布中抽取 $N_{\\text{out}} = N - N_{\\text{in}}$ 个离群点位置。\n- 在这个组合数据集上，对 Huber 和 Student-t 损失分别运行 IRLS 算法以获得估计值 $\\hat{\\vec{v}}$。所有径迹的协方差都假定为 $C_i = \\sigma_{\\text{in}}^2 I_3$。\n- 如果估计值与真实顶点的距离超过阈值：$\\|\\hat{\\vec{v}} - \\vec{v}_{\\text{true}}\\|_2  1.0$ mm，则声明为“崩溃”或“失效”。\n- 为每个损失函数报告的量是测试集中导致失效的最小 $p$ 值。如果在所有测试比例下均未发生失效，则报告值为 $1.0$，表示至少在 $p=0.6$ 时仍保持稳健性。\n固定的随机种子确保了模拟的可复现性。\n\n这为解决该问题提供了理论和方法论框架。具体实现将直接遵循这些原则。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the robust vertex reconstruction problem by:\n    1. Deriving and evaluating weight functions for Huber and Student-t losses.\n    2. Implementing an Iteratively Reweighted Least Squares (IRLS) algorithm.\n    3. Performing a breakdown study to find the failure point for each estimator.\n    \"\"\"\n\n    # --- Part 1: Weight Function Definitions and Evaluation ---\n\n    def w_huber(rho, k):\n        \"\"\"Calculates the Huber weight function.\"\"\"\n        rho = np.asarray(rho)\n        # The weight is min(1, k/|rho|). Since rho is a norm, it's non-negative.\n        # We need to handle the case rho = 0, where the weight is 1.\n        weights = np.ones_like(rho, dtype=float)\n        mask = rho > 0\n        weights[mask] = np.minimum(1.0, k / rho[mask])\n        return weights\n\n    def w_student_t(rho, nu, d):\n        \"\"\"Calculates the Student-t weight function.\"\"\"\n        rho = np.asarray(rho)\n        return (nu + d) / (nu + rho**2)\n\n    # Test parameters\n    rhos_test = np.array([0.5, 1.5, 3.0])\n    k_huber = 1.5\n    nu_student_t = 4.0\n    d_student_t = 3.0\n\n    # Evaluate weights for the test cases\n    weights_huber = w_huber(rhos_test, k=k_huber)\n    weights_student_t = w_student_t(rhos_test, nu=nu_student_t, d=d_student_t)\n\n    # --- Part 2: IRLS Algorithm ---\n\n    def irls_vertex_fit(r_tracks, sigma_in, weight_func, *args, max_iter=100, tol=1e-6):\n        \"\"\"\n        Performs an Iteratively Reweighted Least Squares fit for the vertex position.\n        This simplified version assumes C_i = sigma_in^2 * I_3 for all i.\n        \"\"\"\n        # Initial guess: unweighted mean (least squares solution)\n        v = np.mean(r_tracks, axis=0)\n\n        for _ in range(max_iter):\n            v_old = v\n            \n            # Calculate Mahalanobis norms (simplified form)\n            distances = np.linalg.norm(r_tracks - v, axis=1)\n            rhos = distances / sigma_in\n            \n            # Calculate weights\n            weights = weight_func(rhos, *args)\n            \n            # Update vertex as a weighted average\n            sum_weights = np.sum(weights)\n            if sum_weights  1e-9: # Avoid division by zero if all weights are tiny\n                # This could happen if all points are extreme outliers. Reset to mean.\n                v = np.mean(r_tracks, axis=0)\n            else:\n                v = np.sum(r_tracks * weights[:, np.newaxis], axis=0) / sum_weights\n\n            # Check for convergence\n            if np.linalg.norm(v - v_old)  tol:\n                break\n        \n        return v\n\n    # --- Part 3: Breakdown Study ---\n\n    def run_breakdown_study():\n        \"\"\"\n        Simulates track data with outliers and finds the breakdown point.\n        \"\"\"\n        # Fixed random seed for reproducibility\n        rng = np.random.default_rng(12345)\n        \n        # Simulation parameters from the problem description\n        v_true = np.array([0.0, 0.0, 0.0])\n        num_tracks = 100\n        sigma_in = 0.03  # mm\n        mu_out = np.array([10.0, -10.0, 5.0]) # mm\n        sigma_out = 2.0  # mm\n        outlier_fractions = [0.0, 0.2, 0.4, 0.6]\n        breakdown_threshold = 1.0  # mm\n\n        p_break_huber = 1.0\n        p_break_student = 1.0\n        huber_failed = False\n        student_failed = False\n\n        for p in sorted(outlier_fractions):\n            # Generate data\n            num_inliers = int(np.floor((1 - p) * num_tracks))\n            num_outliers = num_tracks - num_inliers\n\n            inliers = rng.normal(loc=v_true, scale=sigma_in, size=(num_inliers, 3))\n            outliers = rng.normal(loc=mu_out, scale=sigma_out, size=(num_outliers, 3))\n\n            if num_outliers > 0:\n                tracks = np.vstack((inliers, outliers))\n            else:\n                tracks = inliers\n\n            # Run IRLS for Huber loss\n            if not huber_failed:\n                v_huber = irls_vertex_fit(tracks, sigma_in, w_huber, k_huber)\n                error_huber = np.linalg.norm(v_huber - v_true)\n                if error_huber > breakdown_threshold:\n                    p_break_huber = p\n                    huber_failed = True\n\n            # Run IRLS for Student-t loss\n            if not student_failed:\n                v_student = irls_vertex_fit(tracks, sigma_in, w_student_t, nu_student_t, d_student_t)\n                error_student = np.linalg.norm(v_student - v_true)\n                if error_student > breakdown_threshold:\n                    p_break_student = p\n                    student_failed = True\n            \n            # If both have failed, we can stop early\n            if huber_failed and student_failed:\n                break\n\n        return p_break_huber, p_break_student\n\n    p_break_huber, p_break_student = run_breakdown_study()\n\n    # --- Final Output Formatting ---\n    results = [\n        *weights_huber,\n        *weights_student_t,\n        p_break_huber,\n        p_break_student\n    ]\n    \n    # Format the final output string exactly as required.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}