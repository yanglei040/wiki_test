{
    "hands_on_practices": [
        {
            "introduction": "The reconstruction of missing transverse energy begins with the vector sum of all detected particles in an event. However, at a high-luminosity hadron collider, this sum is contaminated by particles from extraneous \"pileup\" collisions that occur in the same bunch crossing. This exercise  introduces two powerful and widely used algorithms, Charged Hadron Subtraction (CHS) and Pileup Per Particle Identification (PUPPI), designed to mitigate this effect and recover a more accurate measure of the true underlying MET. By implementing these schemes, you will gain hands-on experience with the practical challenges of MET reconstruction in a realistic experimental environment.",
            "id": "3522767",
            "problem": "You are given a set of Particle Flow (PF) candidates per event, each candidate characterized on the transverse plane by its transverse momentum components, a charge flag, a primary-vertex association flag, and a local-shape-based weight. Your task is to implement two standard schemes for pileup mitigation and Missing Transverse Energy (MET) reconstruction used in computational high-energy physics: Charged Hadron Subtraction (CHS) and PileUp Per Particle Identification (PUPPI). Starting from momentum conservation on the transverse plane and the definition of MET as the negative of the vector sum of reconstructed transverse momenta, compute the resulting MET vectors under both schemes for a small, well-specified test suite.\n\nFundamental base:\n- Momentum conservation on the transverse plane implies that, for a reconstructed event consisting of PF candidates with transverse momenta $\\vec{p}_{T}^{(i)} = (p_{x}^{(i)}, p_{y}^{(i)})$ expressed in $\\text{GeV}$, the Missing Transverse Energy vector is defined by the negative sum of the transverse momenta:\n$$\n\\vec{E}_{T}^{\\text{miss}} = - \\sum_{i} \\vec{p}_{T}^{(i)} = \\left( E_{x}^{\\text{miss}}, E_{y}^{\\text{miss}} \\right) ,\n$$\nwhere\n$$\nE_{x}^{\\text{miss}} = - \\sum_{i} p_{x}^{(i)}, \\quad E_{y}^{\\text{miss}} = - \\sum_{i} p_{y}^{(i)} ,\n$$\nand the magnitude is\n$$\n\\left| \\vec{E}_{T}^{\\text{miss}} \\right| = \\sqrt{ \\left( E_{x}^{\\text{miss}} \\right)^{2} + \\left( E_{y}^{\\text{miss}} \\right)^{2} } .\n$$\n\nDefinitions to implement:\n- Charged Hadron Subtraction (CHS): Let each PF candidate be defined by the tuple $\\left( p_{x}, p_{y}, q, b, w \\right)$ where $p_{x}$ and $p_{y}$ are in $\\text{GeV}$, $q \\in \\{0,1\\}$ is a charge flag with $q = 1$ denoting a charged candidate and $q = 0$ denoting a neutral candidate, $b \\in \\{0,1\\}$ indicates primary-vertex association with $b = 1$ denoting association to the selected primary vertex and $b = 0$ denoting association to a non-primary vertex, and $w \\in [0,1]$ is a local-shape-based weight used by the PUPPI algorithm. In CHS, include all neutral candidates regardless of $b$, include charged candidates only if $b = 1$, and exclude charged candidates with $b = 0$. No per-particle reweighting is applied to included candidates in CHS, that is, they contribute their full $\\left( p_{x}, p_{y} \\right)$.\n- PileUp Per Particle Identification (PUPPI): For charged candidates, set an effective weight $\\alpha$ equal to $1$ if $b = 1$ and equal to $0$ if $b = 0$. For neutral candidates, set $\\alpha = w$. For any provided $w$ outside the interval $\\left[0,1\\right]$, clamp it to the interval $\\left[0,1\\right]$. The weighted transverse momentum entering the sum is then $\\alpha \\, \\vec{p}_{T}^{(i)} = \\left( \\alpha \\, p_{x}^{(i)}, \\alpha \\, p_{y}^{(i)} \\right)$.\n\nYour program must:\n- Implement the computation of $\\vec{E}_{T}^{\\text{miss}}$ using the CHS and PUPPI schemes as defined above.\n- Use the test suite below and compute, for each test case, the quantities $E_{x}^{\\text{miss,CHS}}$, $E_{y}^{\\text{miss,CHS}}$, $\\left| \\vec{E}_{T}^{\\text{miss,CHS}} \\right|$, $E_{x}^{\\text{miss,PUPPI}}$, $E_{y}^{\\text{miss,PUPPI}}$, and $\\left| \\vec{E}_{T}^{\\text{miss,PUPPI}} \\right|$.\n- Express all outputs in $\\text{GeV}$ as floating-point numbers. No angles are required for this task.\n\nTest suite (each event is a list of PF candidate tuples $\\left( p_{x}, p_{y}, q, b, w \\right)$ where $p_{x}$ and $p_{y}$ are in $\\text{GeV}$):\n- Test case $1$ (mixed event):\n  - $\\left( 35, 15, 1, 1, 1 \\right)$\n  - $\\left( -20, 5, 0, 0, 0.8 \\right)$\n  - $\\left( 10, -10, 1, 0, 0 \\right)$\n  - $\\left( -5, -7, 0, 0, 0.1 \\right)$\n  - $\\left( 1, 2, 1, 1, 1 \\right)$\n  - $\\left( -3, 4, 0, 0, 0.95 \\right)$\n- Test case $2$ (no pileup, balanced sums and a zero-candidate):\n  - $\\left( 10, 0, 1, 1, 1 \\right)$\n  - $\\left( -10, 0, 0, 0, 1 \\right)$\n  - $\\left( 0, 5, 1, 1, 1 \\right)$\n  - $\\left( 0, -5, 0, 0, 1 \\right)$\n  - $\\left( 0, 0, 0, 0, 0.3 \\right)$\n- Test case $3$ (all charged are pileup, neutrals dominate):\n  - $\\left( 50, 0, 1, 0, 0 \\right)$\n  - $\\left( 5, 5, 0, 0, 0.2 \\right)$\n  - $\\left( -3, 7, 0, 0, 0.9 \\right)$\n  - $\\left( -2, -1, 0, 0, 0 \\right)$\n  - $\\left( -10, -10, 1, 0, 0 \\right)$\n- Test case $4$ (boundary weights and charged pileup):\n  - $\\left( 1, 0, 0, 0, 1 \\right)$\n  - $\\left( 100, 0, 0, 0, 0 \\right)$\n  - $\\left( -2, 0, 1, 1, 1 \\right)$\n  - $\\left( -3, 4, 1, 0, 0 \\right)$\n- Test case $5$ (numerical stability with small charged-PV momenta and zero-weight neutrals):\n  - $\\left( 0.1, -0.1, 1, 1, 1 \\right)$\n  - $\\left( 20, -20, 0, 0, 0 \\right)$\n  - $\\left( -0.2, 0.2, 1, 0, 0 \\right)$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a list of six floating-point numbers in $\\text{GeV}$, ordered as $\\left[ E_{x}^{\\text{miss,CHS}}, E_{y}^{\\text{miss,CHS}}, \\left| \\vec{E}_{T}^{\\text{miss,CHS}} \\right|, E_{x}^{\\text{miss,PUPPI}}, E_{y}^{\\text{miss,PUPPI}}, \\left| \\vec{E}_{T}^{\\text{miss,PUPPI}} \\right| \\right]$, written without spaces. For example, the output should look like $\\left[ [a_{1},b_{1},c_{1},d_{1},e_{1},f_{1}], [a_{2},b_{2},c_{2},d_{2},e_{2},f_{2}], \\dots \\right]$ where each $a_{k}, b_{k}, \\dots, f_{k}$ is a float in $\\text{GeV}$.",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in the principles of momentum conservation in high-energy physics, well-posed with clear and unambiguous definitions for the Charged Hadron Subtraction (CHS) and PileUp Per Particle Identification (PUPPI) algorithms, and objective in its formulation. The provided data and conditions are self-contained and sufficient to derive a unique solution.\n\nThe task is to compute the Missing Transverse Energy ($\\vec{E}_{T}^{\\text{miss}}$) for a series of events, each composed of Particle Flow (PF) candidates. The $\\vec{E}_{T}^{\\text{miss}}$ is defined as the negative of the vector sum of the transverse momenta ($\\vec{p}_{T}$) of a selected set of particles.\n$$\n\\vec{E}_{T}^{\\text{miss}} = - \\sum_{i \\in \\text{selected}} \\vec{p}_{T}^{(i)}\n$$\nWe will apply two different selection and weighting schemes, CHS and PUPPI, to determine the final set of momentum vectors to be summed for each event.\n\nA PF candidate $i$ is described by the tuple $\\left( p_{x}^{(i)}, p_{y}^{(i)}, q^{(i)}, b^{(i)}, w^{(i)} \\right)$, where $\\vec{p}_{T}^{(i)} = (p_{x}^{(i)}, p_{y}^{(i)})$ is the transverse momentum, $q^{(i)}$ is the charge flag ($1$ for charged, $0$ for neutral), $b^{(i)}$ is the primary vertex association flag ($1$ for PV-associated, $0$ for not), and $w^{(i)}$ is a weight for the PUPPI algorithm.\n\n**Charged Hadron Subtraction (CHS)**\n\nIn the CHS scheme, a particle is included in the momentum sum if it is either neutral, or if it is charged and associated with the primary vertex. Charged particles not associated with the primary vertex (pileup) are discarded. No weights are applied.\nThe set of indices of particles to include, $S_{\\text{CHS}}$, is defined as:\n$$\nS_{\\text{CHS}} = \\{ i \\mid (q^{(i)} = 0) \\lor (q^{(i)} = 1 \\land b^{(i)} = 1) \\}\n$$\nThe total transverse momentum vector for CHS is:\n$$\n\\vec{P}_{\\text{CHS}} = \\sum_{i \\in S_{\\text{CHS}}} \\vec{p}_{T}^{(i)} = \\left( \\sum_{i \\in S_{\\text{CHS}}} p_{x}^{(i)}, \\sum_{i \\in S_{\\text{CHS}}} p_{y}^{(i)} \\right)\n$$\nThe resulting MET vector is $\\vec{E}_{T}^{\\text{miss,CHS}} = -\\vec{P}_{\\text{CHS}}$.\n\n**PileUp Per Particle Identification (PUPPI)**\n\nIn the PUPPI scheme, every particle contributes to the sum, but with a specific weight $\\alpha^{(i)}$. For charged particles, the weight is binary: $1$ if associated with the PV, $0$ otherwise. For neutral particles, the weight is taken from the provided value $w^{(i)}$, clamped to the interval $[0, 1]$.\nThe weight $\\alpha^{(i)}$ for particle $i$ is defined as:\n$$\n\\alpha^{(i)} =\n\\begin{cases}\n1  \\text{if } q^{(i)} = 1 \\text{ and } b^{(i)} = 1 \\\\\n0  \\text{if } q^{(i)} = 1 \\text{ and } b^{(i)} = 0 \\\\\n\\text{clamp}(w^{(i)}, 0, 1)  \\text{if } q^{(i)} = 0\n\\end{cases}\n$$\nThe total weighted transverse momentum vector for PUPPI is:\n$$\n\\vec{P}_{\\text{PUPPI}} = \\sum_{i} \\alpha^{(i)} \\vec{p}_{T}^{(i)} = \\left( \\sum_{i} \\alpha^{(i)} p_{x}^{(i)}, \\sum_{i} \\alpha^{(i)} p_{y}^{(i)} \\right)\n$$\nThe resulting MET vector is $\\vec{E}_{T}^{\\text{miss,PUPPI}} = -\\vec{P}_{\\text{PUPPI}}$.\n\nWe now apply these algorithms to each test case.\n\n**Test Case 1**\nParticles: $(35, 15, 1, 1, 1)$, $(-20, 5, 0, 0, 0.8)$, $(10, -10, 1, 0, 0)$, $(-5, -7, 0, 0, 0.1)$, $(1, 2, 1, 1, 1)$, $(-3, 4, 0, 0, 0.95)$.\n- **CHS:** Particles $1, 2, 4, 5, 6$ are included. Particle $3$ (charged, non-PV) is excluded.\n  $\\vec{P}_{\\text{CHS}} = (35, 15) + (-20, 5) + (-5, -7) + (1, 2) + (-3, 4) = (8, 19)$.\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (-8, -19)$. Magnitude $|\\vec{E}_{T}^{\\text{miss,CHS}}| = \\sqrt{(-8)^2 + (-19)^2} = \\sqrt{64 + 361} = \\sqrt{425} \\approx 20.6155 \\text{ GeV}$.\n- **PUPPI:** Weights $\\alpha$ are: $1, 0.8, 0, 0.1, 1, 0.95$.\n  $\\vec{P}_{\\text{PUPPI}} = 1(35, 15) + 0.8(-20, 5) + 0.1(-5, -7) + 1(1, 2) + 0.95(-3, 4) = (35-16-0.5+1-2.85, 15+4-0.7+2+3.8) = (16.65, 24.1)$.\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (-16.65, -24.1)$. Magnitude $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = \\sqrt{(-16.65)^2 + (-24.1)^2} = \\sqrt{277.2225 + 580.81} = \\sqrt{858.0325} \\approx 29.2922 \\text{ GeV}$.\n\n**Test Case 2**\nParticles: $(10, 0, 1, 1, 1)$, $(-10, 0, 0, 0, 1)$, $(0, 5, 1, 1, 1)$, $(0, -5, 0, 0, 1)$, $(0, 0, 0, 0, 0.3)$.\n- **CHS:** All particles are included (charged are PV-associated, others are neutral).\n  $\\vec{P}_{\\text{CHS}} = (10, 0) + (-10, 0) + (0, 5) + (0, -5) + (0, 0) = (0, 0)$.\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (0, 0)$. Magnitude $|\\vec{E}_{T}^{\\text{miss,CHS}}| = 0 \\text{ GeV}$.\n- **PUPPI:** Weights $\\alpha$ are: $1, 1, 1, 1, 0.3$.\n  $\\vec{P}_{\\text{PUPPI}} = 1(10, 0) + 1(-10, 0) + 1(0, 5) + 1(0, -5) + 0.3(0, 0) = (0, 0)$.\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (0, 0)$. Magnitude $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = 0 \\text{ GeV}$.\n\n**Test Case 3**\nParticles: $(50, 0, 1, 0, 0)$, $(5, 5, 0, 0, 0.2)$, $(-3, 7, 0, 0, 0.9)$, $(-2, -1, 0, 0, 0)$, $(-10, -10, 1, 0, 0)$.\n- **CHS:** Particles $2, 3, 4$ are included (all neutral). Particles $1, 5$ (charged, non-PV) are excluded.\n  $\\vec{P}_{\\text{CHS}} = (5, 5) + (-3, 7) + (-2, -1) = (0, 11)$.\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (0, -11)$. Magnitude $|\\vec{E}_{T}^{\\text{miss,CHS}}| = 11 \\text{ GeV}$.\n- **PUPPI:** Weights $\\alpha$ are: $0, 0.2, 0.9, 0, 0$.\n  $\\vec{P}_{\\text{PUPPI}} = 0.2(5, 5) + 0.9(-3, 7) = (1, 1) + (-2.7, 6.3) = (-1.7, 7.3)$.\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (1.7, -7.3)$. Magnitude $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = \\sqrt{(1.7)^2 + (-7.3)^2} = \\sqrt{2.89 + 53.29} = \\sqrt{56.18} \\approx 7.4953 \\text{ GeV}$.\n\n**Test Case 4**\nParticles: $(1, 0, 0, 0, 1)$, $(100, 0, 0, 0, 0)$, $(-2, 0, 1, 1, 1)$, $(-3, 4, 1, 0, 0)$.\n- **CHS:** Particles $1, 2, 3$ are included. Particle $4$ (charged, non-PV) is excluded.\n  $\\vec{P}_{\\text{CHS}} = (1, 0) + (100, 0) + (-2, 0) = (99, 0)$.\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (-99, 0)$. Magnitude $|\\vec{E}_{T}^{\\text{miss,CHS}}| = 99 \\text{ GeV}$.\n- **PUPPI:** Weights $\\alpha$ are: $1, 0, 1, 0$.\n  $\\vec{P}_{\\text{PUPPI}} = 1(1, 0) + 1(-2, 0) = (-1, 0)$.\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (1, 0)$. Magnitude $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = 1 \\text{ GeV}$.\n\n**Test Case 5**\nParticles: $(0.1, -0.1, 1, 1, 1)$, $(20, -20, 0, 0, 0)$, $(-0.2, 0.2, 1, 0, 0)$.\n- **CHS:** Particles $1, 2$ are included. Particle $3$ (charged, non-PV) is excluded.\n  $\\vec{P}_{\\text{CHS}} = (0.1, -0.1) + (20, -20) = (20.1, -20.1)$.\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (-20.1, 20.1)$. Magnitude $|\\vec{E}_{T}^{\\text{miss,CHS}}| = \\sqrt{(-20.1)^2 + (20.1)^2} = \\sqrt{2 \\cdot 404.01} = 20.1\\sqrt{2} \\approx 28.4255 \\text{ GeV}$.\n- **PUPPI:** Weights $\\alpha$ are: $1, 0, 0$.\n  $\\vec{P}_{\\text{PUPPI}} = 1(0.1, -0.1) = (0.1, -0.1)$.\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (-0.1, 0.1)$. Magnitude $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = \\sqrt{(-0.1)^2 + (0.1)^2} = \\sqrt{0.02} = 0.1\\sqrt{2} \\approx 0.1414 \\text{ GeV}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Missing Transverse Energy (MET) using CHS and PUPPI schemes for a suite of test cases.\n    \"\"\"\n    # Test suite: each event is a list of PF candidate tuples\n    # (p_x, p_y, q, b, w) where p_x, p_y are in GeV.\n    test_cases = [\n        # Test case 1 (mixed event)\n        [\n            (35, 15, 1, 1, 1.0),\n            (-20, 5, 0, 0, 0.8),\n            (10, -10, 1, 0, 0.0),\n            (-5, -7, 0, 0, 0.1),\n            (1, 2, 1, 1, 1.0),\n            (-3, 4, 0, 0, 0.95),\n        ],\n        # Test case 2 (no pileup, balanced sums and a zero-candidate)\n        [\n            (10, 0, 1, 1, 1.0),\n            (-10, 0, 0, 0, 1.0),\n            (0, 5, 1, 1, 1.0),\n            (0, -5, 0, 0, 1.0),\n            (0, 0, 0, 0, 0.3),\n        ],\n        # Test case 3 (all charged are pileup, neutrals dominate)\n        [\n            (50, 0, 1, 0, 0.0),\n            (5, 5, 0, 0, 0.2),\n            (-3, 7, 0, 0, 0.9),\n            (-2, -1, 0, 0, 0.0),\n            (-10, -10, 1, 0, 0.0),\n        ],\n        # Test case 4 (boundary weights and charged pileup)\n        [\n            (1, 0, 0, 0, 1.0),\n            (100, 0, 0, 0, 0.0),\n            (-2, 0, 1, 1, 1.0),\n            (-3, 4, 1, 0, 0.0),\n        ],\n        # Test case 5 (numerical stability with small charged-PV momenta and zero-weight neutrals)\n        [\n            (0.1, -0.1, 1, 1, 1.0),\n            (20, -20, 0, 0, 0.0),\n            (-0.2, 0.2, 1, 0, 0.0),\n        ],\n    ]\n\n    results = []\n    for event in test_cases:\n        sum_p_chs = np.array([0.0, 0.0])\n        sum_p_puppi = np.array([0.0, 0.0])\n\n        for particle in event:\n            p_x, p_y, q, b, w = particle\n            p_T = np.array([p_x, p_y])\n\n            # Charged Hadron Subtraction (CHS) logic\n            # Include if neutral (q=0) or charged from primary vertex (q=1, b=1)\n            if q == 0 or (q == 1 and b == 1):\n                sum_p_chs += p_T\n\n            # PileUp Per Particle Identification (PUPPI) logic\n            alpha = 0.0\n            if q == 1:  # Charged particle\n                alpha = 1.0 if b == 1 else 0.0\n            else:  # Neutral particle\n                alpha = np.clip(w, 0.0, 1.0)\n            \n            sum_p_puppi += alpha * p_T\n\n        # Calculate MET vector (negative of the momentum sum)\n        met_chs = -sum_p_chs\n        met_puppi = -sum_p_puppi\n\n        # Calculate MET magnitude\n        mag_met_chs = np.linalg.norm(met_chs)\n        mag_met_puppi = np.linalg.norm(met_puppi)\n\n        # Store results for the current event\n        case_result = [\n            met_chs[0], met_chs[1], mag_met_chs,\n            met_puppi[0], met_puppi[1], mag_met_puppi,\n        ]\n        results.append(case_result)\n        \n    # Format the final output string as specified, without spaces in sub-lists.\n    formatted_results = []\n    for res in results:\n        # Manually format each sub-list to avoid spaces from standard list-to-string conversion.\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]},{res[5]}]\"\n        formatted_results.append(res_str)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once a value for $\\vec{E}_T^{\\text{miss}}$ is reconstructed, the crucial next step is to assess its statistical significance. A large measured MET could be a sign of new physics involving invisible particles, or it could simply be a large fluctuation arising from finite detector resolution. This practice  guides you through the process of constructing a proper statistical test, accounting for measurement uncertainties and their correlations, to quantify how incompatible an observation is with the null hypothesis of no true missing energy. This is a fundamental skill for interpreting experimental results and making discoveries.",
            "id": "3522796",
            "problem": "In a proton-proton collision analysis of missing transverse energy (MET), consider a single event for which the measured missing transverse energy vector is $\\vec{E}_T^{\\text{miss}} = (E_x, E_y)$, with $E_x = 36\\,\\text{GeV}$ and $E_y = -24\\,\\text{GeV}$. The combined detector response and reconstruction uncertainty on the transverse plane is modeled as a bivariate Gaussian with zero mean under the null hypothesis that the true missing energy is zero, and with a known covariance matrix\n$$\n\\mathbf{V} \\;=\\;\n\\begin{pmatrix}\n400  180 \\\\\n180  900\n\\end{pmatrix}\\,\\text{GeV}^2 \\, .\n$$\nStarting from the definition of the multivariate Gaussian likelihood and basic properties of quadratic forms, derive an appropriate test statistic $S$ for assessing the null hypothesis of no true missing energy, and justify its sampling distribution under the null hypothesis in two dimensions. Then compute the numerical values of $S$ and the associated $p$-value for observing a fluctuation at least as extreme as the measured $\\vec{E}_T^{\\text{miss}}$ assuming the null hypothesis is true. Round both $S$ and the $p$-value to four significant figures. Express the $p$-value as a decimal. Do not include any units in the final numerical values.",
            "solution": "The problem asks for the derivation of a test statistic to assess a null hypothesis, its sampling distribution, the definition and calculation of a corresponding test statistic $S$, and the associated $p$-value for a given measurement of missing transverse energy.\n\nStep 1: Problem Formulation and Null Hypothesis\nThe measured missing transverse energy vector is given by $\\vec{E}_T^{\\text{miss}} = (E_x, E_y)^T$, with $E_x = 36\\,\\text{GeV}$ and $E_y = -24\\,\\text{GeV}$. We can represent this measurement as a column vector $\\vec{x} = \\begin{pmatrix} 36 \\\\ -24 \\end{pmatrix}\\,\\text{GeV}$.\nThe null hypothesis, $H_0$, is that there is no true missing energy. Under $H_0$, the expected value of the measurement is the zero vector, $\\vec{\\mu}_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\\,\\text{GeV}$.\nThe problem states that the combined detector response and reconstruction uncertainty are modeled by a bivariate Gaussian distribution with mean $\\vec{\\mu}_0$ under $H_0$, and a given covariance matrix $\\mathbf{V}$:\n$$\n\\mathbf{V} =\n\\begin{pmatrix}\n400  180 \\\\\n180  900\n\\end{pmatrix}\\,\\text{GeV}^2\n$$\nThus, under $H_0$, the measurement vector $\\vec{x}$ is a sample from a bivariate normal distribution, $\\vec{x} \\sim \\mathcal{N}(\\vec{0}, \\mathbf{V})$.\n\nStep 2: Derivation of the Test Statistic\nThe probability density function (PDF) for a $k$-dimensional multivariate normal distribution is\n$$\nf(\\vec{x}; \\vec{\\mu}, \\mathbf{V}) = \\frac{1}{\\sqrt{(2\\pi)^k \\det(\\mathbf{V})}} \\exp\\left(-\\frac{1}{2}(\\vec{x}-\\vec{\\mu})^T \\mathbf{V}^{-1}(\\vec{x}-\\vec{\\mu})\\right)\n$$\nUnder the null hypothesis $H_0$, we have $k=2$ and $\\vec{\\mu}=\\vec{0}$. The likelihood of observing the measurement $\\vec{x}$ is proportional to the PDF evaluated under $H_0$:\n$$\nL(\\vec{x} | H_0) \\propto \\exp\\left(-\\frac{1}{2}\\vec{x}^T \\mathbf{V}^{-1}\\vec{x}\\right)\n$$\nThe quadratic form in the exponent, $S = \\vec{x}^T \\mathbf{V}^{-1}\\vec{x}$, is the squared Mahalanobis distance of the measurement $\\vec{x}$ from the expected mean $\\vec{0}$. This quantity provides a measure of how \"extreme\" or \"unlikely\" the observation is under the null hypothesis. Larger values of $S$ correspond to observations that are less consistent with $H_0$. Therefore, $S = \\vec{x}^T \\mathbf{V}^{-1}\\vec{x}$ is an appropriate test statistic for this problem, and is consistent with the definition of the significance variable in the main body of the article.\n\nStep 3: Sampling Distribution of the Test Statistic\nA fundamental property of the multivariate normal distribution is that if a random vector $\\vec{X}$ is drawn from a $k$-dimensional normal distribution $\\mathcal{N}(\\vec{\\mu}, \\mathbf{V})$, then the quadratic form $S = (\\vec{X}-\\vec{\\mu})^T \\mathbf{V}^{-1} (\\vec{X}-\\vec{\\mu})$ follows a chi-squared ($\\chi^2$) distribution with $k$ degrees of freedom.\nIn our case, under $H_0$, the measurement vector is assumed to be drawn from a $k=2$ dimensional normal distribution with mean $\\vec{\\mu}=\\vec{0}$. Therefore, our test statistic $S$ follows a $\\chi^2$ distribution with $2$ degrees of freedom, denoted as $\\chi^2(2)$.\n\nStep 4: Definition of Test Statistic S\nThe test statistic $S$ is defined as the squared Mahalanobis distance.\n$$\nS \\equiv \\vec{x}^T \\mathbf{V}^{-1}\\vec{x}\n$$\nThis quantity is dimensionless because the units of $\\vec{x}^T$ are $\\text{GeV}$, the units of $\\mathbf{V}^{-1}$ are $\\text{GeV}^{-2}$, and the units of $\\vec{x}$ are $\\text{GeV}$, resulting in a dimensionless product.\n\nStep 5: Numerical Calculation\nFirst, we must compute the inverse of the covariance matrix $\\mathbf{V}$. For a $2 \\times 2$ matrix $\\mathbf{A} = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$, the inverse is $\\mathbf{A}^{-1} = \\frac{1}{ad-bc} \\begin{pmatrix} d  -b \\\\ -c  a \\end{pmatrix}$.\nFor our covariance matrix $\\mathbf{V} = \\begin{pmatrix} 400  180 \\\\ 180  900 \\end{pmatrix}$, the determinant is:\n$$\n\\det(\\mathbf{V}) = (400)(900) - (180)(180) = 360000 - 32400 = 327600\\,\\text{GeV}^4\n$$\nThe inverse matrix is:\n$$\n\\mathbf{V}^{-1} = \\frac{1}{327600}\n\\begin{pmatrix}\n900  -180 \\\\\n-180  400\n\\end{pmatrix}\\,\\text{GeV}^{-2}\n$$\nNow, we can calculate the value of the test statistic $S_{obs}$ for the observed measurement $\\vec{x} = \\begin{pmatrix} 36 \\\\ -24 \\end{pmatrix}$:\n$$\nS_{obs} = \\vec{x}^T \\mathbf{V}^{-1} \\vec{x} = \\begin{pmatrix} 36  -24 \\end{pmatrix} \\frac{1}{327600} \\begin{pmatrix} 900  -180 \\\\ -180  400 \\end{pmatrix} \\begin{pmatrix} 36 \\\\ -24 \\end{pmatrix}\n$$\nPerforming the matrix multiplication:\n$$\n\\begin{pmatrix} 900  -180 \\\\ -180  400 \\end{pmatrix} \\begin{pmatrix} 36 \\\\ -24 \\end{pmatrix} = \\begin{pmatrix} 900(36) + (-180)(-24) \\\\ -180(36) + 400(-24) \\end{pmatrix} = \\begin{pmatrix} 32400 + 4320 \\\\ -6480 - 9600 \\end{pmatrix} = \\begin{pmatrix} 36720 \\\\ -16080 \\end{pmatrix}\n$$\nNext, we compute the final dot product:\n$$\nS_{obs} = \\frac{1}{327600} \\begin{pmatrix} 36  -24 \\end{pmatrix} \\begin{pmatrix} 36720 \\\\ -16080 \\end{pmatrix} = \\frac{1}{327600} \\left( 36(36720) + (-24)(-16080) \\right)\n$$\n$$\nS_{obs} = \\frac{1321920 + 385920}{327600} = \\frac{1707840}{327600} \\approx 5.2131868\n$$\nRounding to four significant figures, we get $S \\approx 5.213$.\n\nStep 6: Calculation of the $p$-value\nThe $p$-value is the probability of obtaining a test statistic value at least as large as the observed one, assuming $H_0$ is true. This corresponds to the upper tail probability of the $\\chi^2(2)$ distribution:\n$$\np = P(S \\ge S_{obs} | H_0) = \\int_{S_{obs}}^{\\infty} f_{\\chi^2(2)}(s) \\, ds\n$$\nThe PDF for a $\\chi^2$ distribution with $k=2$ degrees of freedom is $f(s; 2) = \\frac{1}{2} \\exp(-s/2)$ for $s \\ge 0$. The integral is:\n$$\np = \\int_{S_{obs}}^{\\infty} \\frac{1}{2} \\exp(-s/2) \\, ds = \\left[ -\\exp(-s/2) \\right]_{S_{obs}}^{\\infty} = 0 - (-\\exp(-S_{obs}/2)) = \\exp(-S_{obs}/2)\n$$\nUsing the calculated value for $S_{obs}$:\n$$\np \\approx \\exp(-5.2131868 / 2) = \\exp(-2.6065934) \\approx 0.0737875\n$$\nRounding the $p$-value to four significant figures, we get $p \\approx 0.07379$.\n\nThe computed test statistic is $S \\approx 5.213$ and the associated $p$-value is $p \\approx 0.07379$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n5.213  0.07379\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The calculation of $\\vec{E}_T^{\\text{miss}}$ is not a static, one-time process; it must be updated whenever our understanding of the detector response changes, most notably through jet energy corrections. Recomputing the full momentum sum for every systematic variation is computationally prohibitive in the context of large modern datasets. This exercise  challenges you to move beyond naive recomputation by designing and implementing an efficient incremental algorithm that updates MET in response to jet corrections, a core task in managing systematic uncertainties in high-energy physics analyses.",
            "id": "3522768",
            "problem": "Design and implement a program that, for a single high-energy physics event in a hadron collider, updates the Missing Transverse Energy (MET) vector incrementally when applying type-I jet energy corrections, without recomputing the full visible transverse momentum sum. Base your derivation and algorithm design on the conservation of momentum in the plane transverse to the beam and the definition of MET. Provide a rigorous derivation of the incremental update rule from these principles and analyze the computational complexity of your method. Then implement the algorithm and run it on the specified test suite. All energies must be in giga-electronvolts (GeV), all azimuthal angles must be in radians, and any angle in the output must be normalized to the interval $\\left(-\\pi,\\pi\\right]$. Output floating-point numbers must be rounded to six decimal places.\n\nFoundational starting point and definitions to be used:\n- The Missing Transverse Energy (MET) vector, denoted $\\vec{E}_{T}^{\\text{miss}}$, is defined by the condition of transverse momentum conservation: if $\\sum \\vec{p}_{T}^{\\text{vis}}$ is the vector sum of all visible transverse momenta in the event, then\n$$\n\\vec{E}_{T}^{\\text{miss}} + \\sum \\vec{p}_{T}^{\\text{vis}} = \\vec{0},\n$$\nso that\n$$\n\\vec{E}_{T}^{\\text{miss}} = - \\sum \\vec{p}_{T}^{\\text{vis}}.\n$$\n- A jet has raw transverse momentum magnitude $p_{T,i}^{\\text{raw}}$ and azimuthal angle $\\phi_{i}$. Its raw transverse momentum vector is $\\vec{p}_{T,i}^{\\text{raw}} = p_{T,i}^{\\text{raw}} \\left(\\cos \\phi_{i}, \\sin \\phi_{i}\\right)$.\n- A type-I jet correction for jet $i$ is modeled as a multiplicative factor $c_{i}$ applied to the raw jet transverse momentum magnitude, producing a corrected vector $\\vec{p}_{T,i}^{\\text{corr}} = c_{i} \\, \\vec{p}_{T,i}^{\\text{raw}}$. The corresponding correction vector is the difference $\\Delta \\vec{p}_{T,i} = \\vec{p}_{T,i}^{\\text{corr}} - \\vec{p}_{T,i}^{\\text{raw}} = \\left(c_{i} - 1\\right) \\, \\vec{p}_{T,i}^{\\text{raw}}$.\n- Type-I corrections are applied only to jets that satisfy a selection, namely $p_{T,i}^{\\text{raw}} \\ge T$ and $\\left|\\eta_{i}\\right|  \\eta_{\\max}$, where $\\eta_{i}$ is the pseudorapidity of jet $i$, $T$ is a transverse momentum threshold, and $\\eta_{\\max}$ is a pseudorapidity acceptance.\n\nRequired tasks:\n1. Derive, from the above principles, an incremental update rule to obtain the corrected MET vector $\\vec{E}_{T}^{\\text{miss,\\,corr}}$ from a given raw MET vector $\\vec{E}_{T}^{\\text{miss,\\,raw}}$ when a set of type-I corrections $\\left\\{c_{i}\\right\\}$ is applied. Then derive how to update $\\vec{E}_{T}^{\\text{miss}}$ incrementally if a subset of jet correction factors is updated from $\\left\\{c_{i}^{\\text{old}}\\right\\}$ to $\\left\\{c_{i}^{\\text{new}}\\right\\}$, without fully recomputing the sum over all jets.\n2. Analyze the time and space complexity of:\n   - A naive recomputation strategy that, upon any update, recomputes the full corrected MET from scratch by summing all selected jets.\n   - An incremental strategy that maintains per-jet state and updates the MET using only the changed jets. State clearly the asymptotic complexity in terms of the number of jets $N$ and the number of updated jets $k$ in an update batch. Discuss the cost of trigonometric function evaluations and how to minimize it.\n3. Implement the incremental algorithm as a deterministic program. Your program must:\n   - Accept no input and read no files.\n   - Hard-code the following test suite, each with an initial raw MET vector $\\left(E_{x}^{\\text{raw}}, E_{y}^{\\text{raw}}\\right)$ in GeV, a list of jets with $\\left(p_{T,i}^{\\text{raw}}, \\phi_{i}, \\eta_{i}\\right)$, a selection defined by $T$ in GeV and $\\eta_{\\max}$ (dimensionless), and an ordered list of update batches. Each update batch is a mapping from jet index to its new correction factor $c_{i}$. For each test case, apply the update batches in order and report the final corrected MET vector and its polar representation.\n   - Use the selection rule $p_{T,i}^{\\textraw} \\ge T$ and $\\left|\\eta_{i}\\right|  \\eta_{\\max}$. Jets failing the selection must be ignored in all corrections, even if they have provided $c_{i}$ values.\n   - Precompute and reuse $\\cos \\phi_{i}$ and $\\sin \\phi_{i}$ to minimize trigonometric calls.\n   - For each test case, compute and return a list of four floats: $\\left[E_{x}^{\\text{corr}}, E_{y}^{\\text{corr}}, E_{T}^{\\text{corr}}, \\phi^{\\text{corr}}\\right]$, where $E_{x}^{\\text{corr}}$ and $E_{y}^{\\text{corr}}$ are the components of the final corrected MET in GeV, $E_{T}^{\\text{corr}} = \\sqrt{\\left(E_{x}^{\\text{corr}}\\right)^{2} + \\left(E_{y}^{\\text{corr}}\\right)^{2}}$ in GeV is the magnitude, and $\\phi^{\\text{corr}} = \\mathrm{atan2}\\!\\left(E_{y}^{\\text{corr}}, E_{x}^{\\text{corr}}\\right)$ in radians is normalized to $\\left(-\\pi,\\pi\\right]$.\n   - Round each float to exactly six decimal places.\n\nTest suite to implement:\n- Test case $1$ (general case with mixed corrections and a sub-threshold jet):\n  - $\\left(E_{x}^{\\text{raw}}, E_{y}^{\\text{raw}}\\right) = \\left(-30.0, 20.0\\right)$.\n  - Jets: index $0$: $\\left(p_{T}, \\phi, \\eta\\right) = \\left(50.0, 0.3, 0.5\\right)$; index $1$: $\\left(40.0, -2.5, 1.2\\right)$; index $2$: $\\left(10.0, 1.5, 2.0\\right)$.\n  - Selection: $T = 20.0$, $\\eta_{\\max} = 4.7$.\n  - Update batches: batch $1$: $\\{0 \\mapsto 1.10,\\, 1 \\mapsto 0.95,\\, 2 \\mapsto 1.20\\}$.\n- Test case $2$ (no selected jets; MET unchanged):\n  - $\\left(E_{x}^{\\text{raw}}, E_{y}^{\\text{raw}}\\right) = \\left(5.0, -5.0\\right)$.\n  - Jets: index $0$: $\\left(15.0, 0.2, 0.3\\right)$; index $1$: $\\left(18.0, -1.0, 5.1\\right)$; index $2$: $\\left(35.0, 1.2, 5.5\\right)$.\n  - Selection: $T = 20.0$, $\\eta_{\\max} = 4.7$.\n  - Update batches: batch $1$: $\\{0 \\mapsto 1.10,\\, 1 \\mapsto 1.05,\\, 2 \\mapsto 0.90\\}$.\n- Test case $3$ (boundary at threshold and a neutral correction):\n  - $\\left(E_{x}^{\\text{raw}}, E_{y}^{\\text{raw}}\\right) = \\left(0.0, 0.0\\right)$.\n  - Jets: index $0$: $\\left(20.0, 0.7853981633974483, 0.0\\right)$; index $1$: $\\left(100.0, -0.7853981633974483, 0.0\\right)$.\n  - Selection: $T = 20.0$, $\\eta_{\\max} = 4.7$.\n  - Update batches: batch $1$: $\\{0 \\mapsto 1.05,\\, 1 \\mapsto 1.0\\}$.\n- Test case $4$ (multiple batches and a re-updated jet; also an ignored sub-threshold jet):\n  - $\\left(E_{x}^{\\text{raw}}, E_{y}^{\\text{raw}}\\right) = \\left(10.0, -12.0\\right)$.\n  - Jets: index $0$: $\\left(45.0, 1.0, 0.3\\right)$; index $1$: $\\left(60.0, -2.0, 2.0\\right)$; index $2$: $\\left(18.0, 0.5, 0.1\\right)$.\n  - Selection: $T = 20.0$, $\\eta_{\\max} = 4.7$.\n  - Update batches: batch $1$: $\\{0 \\mapsto 1.10,\\, 1 \\mapsto 0.90\\}$; batch $2$: $\\{1 \\mapsto 0.95,\\, 2 \\mapsto 1.50\\}$.\n- Test case $5$ (angle wrap-around near $\\pm \\pi$):\n  - $\\left(E_{x}^{\\text{raw}}, E_{y}^{\\text{raw}}\\right) = \\left(0.0, 0.0\\right)$.\n  - Jets: index $0$: $\\left(30.0, 3.131592653589793, 0.0\\right)$; index $1$: $\\left(50.0, -3.131592653589793, 0.0\\right)$.\n  - Selection: $T = 20.0$, $\\eta_{\\max} = 4.7$.\n  - Update batches: batch $1$: $\\{0 \\mapsto 1.02,\\, 1 \\mapsto 1.02\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the five test cases as a comma-separated list of lists, each inner list ordered as $\\left[E_{x}^{\\text{corr}}, E_{y}^{\\text{corr}}, E_{T}^{\\text{corr}}, \\phi^{\\text{corr}}\\right]$ with all four floats rounded to six decimal places, and no spaces. For example, the overall structure must be\n$[\\,[E_{x,1},E_{y,1},E_{T,1},\\phi_{1}],\\,[E_{x,2},E_{y,2},E_{T,2},\\phi_{2}],\\,\\ldots\\,]$.",
            "solution": "The problem requires the design and implementation of an incremental algorithm to update the Missing Transverse Energy (MET) vector when jet energy corrections are applied in a high-energy physics event. We must first validate the problem, then derive the update rule from first principles, analyze its computational complexity, and finally implement it.\n\n### **Problem Validation**\n\nThe problem statement has been evaluated and is determined to be **valid**.\n\n1.  **Givens Extracted:**\n    *   Definition of MET: $\\vec{E}_{T}^{\\text{miss}} = - \\sum \\vec{p}_{T}^{\\text{vis}}$.\n    *   Raw jet momentum vector: $\\vec{p}_{T,i}^{\\text{raw}} = p_{T,i}^{\\text{raw}} (\\cos \\phi_{i}, \\sin \\phi_{i})$.\n    *   Type-I jet correction: $\\vec{p}_{T,i}^{\\text{corr}} = c_{i} \\, \\vec{p}_{T,i}^{\\text{raw}}$.\n    *   Correction vector: $\\Delta \\vec{p}_{T,i} = (c_{i} - 1) \\, \\vec{p}_{T,i}^{\\text{raw}}$.\n    *   Jet selection criteria: $p_{T,i}^{\\text{raw}} \\ge T$ and $|\\eta_{i}|  \\eta_{\\max}$.\n    *   All required test data and output formatting specifications are provided.\n\n2.  **Validation Verdict:**\n    *   **Scientifically Grounded:** The problem is based on the fundamental principle of momentum conservation and employs standard definitions and procedures from experimental particle physics (MET, jet corrections). It is factually sound.\n    *   **Well-Posed:** All necessary information, including definitions, initial conditions, constants, and test data, is provided. The task is specific and leads to a unique, deterministic solution.\n    *   **Objective:** The problem is stated using precise, formal language, free of ambiguity or subjective claims.\n\nThe problem is a well-defined computational task in physics and is suitable for a rigorous solution.\n\n### **1. Derivation of the Incremental Update Rule**\n\nWe begin from the foundational definition of the Missing Transverse Energy vector, $\\vec{E}_{T}^{\\text{miss}}$, which is the negative of the vector sum of the transverse momenta of all visible particles in the event.\n$$\n\\vec{E}_{T}^{\\text{miss}} = - \\sum_{\\text{all vis}} \\vec{p}_{T}^{\\text{vis}}\n$$\nThe collection of all visible particles can be partitioned into jets and other objects (e.g., leptons, photons, and unclustered energy). Type-I corrections, by definition, only modify the momenta of jets that pass a certain selection criteria. Let $S$ be the set of indices for jets that satisfy the selection $p_{T,i}^{\\text{raw}} \\ge T$ and $|\\eta_{i}|  \\eta_{\\max}$.\n\nThe total visible transverse momentum before any correction is applied (the \"raw\" state) is:\n$$\n\\sum \\vec{p}_{T}^{\\text{vis, raw}} = \\sum_{i \\in \\text{all jets}} \\vec{p}_{T,i}^{\\text{raw}} + \\sum_{\\text{non-jet}} \\vec{p}_{T}^{\\text{non-jet, raw}}\n$$\nThe corresponding raw MET is $\\vec{E}_{T}^{\\text{miss, raw}} = - \\sum \\vec{p}_{T}^{\\text{vis, raw}}$.\n\nWhen type-I corrections are applied, a set of correction factors $\\{c_i\\}$ is applied to the selected jets $i \\in S$. The momentum of a selected jet becomes $\\vec{p}_{T,i}^{\\text{corr}} = c_{i} \\vec{p}_{T,i}^{\\text{raw}}$. The momenta of unselected jets and non-jet objects remain unchanged. The new total visible transverse momentum is:\n$$\n\\sum \\vec{p}_{T}^{\\text{vis, corr}} = \\sum_{i \\in S} \\vec{p}_{T,i}^{\\text{corr}} + \\sum_{i \\notin S} \\vec{p}_{T,i}^{\\text{raw}} + \\sum_{\\text{non-jet}} \\vec{p}_{T}^{\\text{non-jet, raw}}\n$$\nThe change in the total visible momentum is the difference between the corrected and raw sums:\n$$\n\\Delta \\left(\\sum \\vec{p}_{T}^{\\text{vis}}\\right) = \\sum \\vec{p}_{T}^{\\text{vis, corr}} - \\sum \\vec{p}_{T}^{\\text{vis, raw}} = \\sum_{i \\in S} \\left(\\vec{p}_{T,i}^{\\text{corr}} - \\vec{p}_{T,i}^{\\text{raw}}\\right)\n$$\nUsing the definition of the correction vector, $\\Delta \\vec{p}_{T,i} = \\vec{p}_{T,i}^{\\text{corr}} - \\vec{p}_{T,i}^{\\text{raw}} = (c_i - 1)\\vec{p}_{T,i}^{\\text{raw}}$, this becomes:\n$$\n\\Delta \\left(\\sum \\vec{p}_{T}^{\\text{vis}}\\right) = \\sum_{i \\in S} (c_i - 1)\\vec{p}_{T,i}^{\\text{raw}}\n$$\nThe corrected MET is $\\vec{E}_{T}^{\\text{miss, corr}} = - \\sum \\vec{p}_{T}^{\\text{vis, corr}}$. The change in MET is $\\Delta \\vec{E}_{T}^{\\text{miss}} = \\vec{E}_{T}^{\\text{miss, corr}} - \\vec{E}_{T}^{\\text{miss, raw}} = - \\Delta (\\sum \\vec{p}_{T}^{\\text{vis}})$. Therefore, the first update rule, to get the corrected MET from the raw MET, is:\n$$\n\\vec{E}_{T}^{\\text{miss, corr}} = \\vec{E}_{T}^{\\text{miss, raw}} - \\sum_{i \\in S} (c_i - 1)\\vec{p}_{T,i}^{\\text{raw}}\n$$\nIn this initial step, we can consider the \"old\" correction factors to be $c_i=1$ for all jets.\n\nNow, we derive the rule for an incremental update. Suppose we have a MET vector $\\vec{E}_{T}^{\\text{miss, old}}$ calculated with a set of correction factors $\\{c_i^{\\text{old}}\\}_{i \\in S}$.\n$$\n\\vec{E}_{T}^{\\text{miss, old}} = \\vec{E}_{T}^{\\text{miss, raw}} - \\sum_{i \\in S} (c_i^{\\text{old}} - 1)\\vec{p}_{T,i}^{\\text{raw}}\n$$\nA new update arrives for a subset of jets $K \\subseteq S$, changing their correction factors to $\\{c_i^{\\text{new}}\\}_{i \\in K}$. The new MET vector, $\\vec{E}_{T}^{\\text{miss, new}}$, will be:\n$$\n\\vec{E}_{T}^{\\text{miss, new}} = \\vec{E}_{T}^{\\text{miss, raw}} - \\left( \\sum_{i \\in K} (c_i^{\\text{new}} - 1)\\vec{p}_{T,i}^{\\text{raw}} + \\sum_{i \\in S \\setminus K} (c_i^{\\text{old}} - 1)\\vec{p}_{T,i}^{\\text{raw}} \\right)\n$$\nThe incremental change to the MET is $\\Delta \\vec{E}_{T}^{\\text{miss}} = \\vec{E}_{T}^{\\text{miss, new}} - \\vec{E}_{T}^{\\text{miss, old}}$. Subtracting the two expressions, we get:\n$$\n\\Delta \\vec{E}_{T}^{\\text{miss}} = \\left( - \\sum_{i \\in K} (c_i^{\\text{new}} - 1)\\vec{p}_{T,i}^{\\text{raw}} \\right) - \\left( - \\sum_{i \\in K} (c_i^{\\text{old}} - 1)\\vec{p}_{T,i}^{\\text{raw}} \\right)\n$$\n$$\n\\Delta \\vec{E}_{T}^{\\text{miss}} = - \\sum_{i \\in K} \\left[ (c_i^{\\text{new}} - 1) - (c_i^{\\text{old}} - 1) \\right] \\vec{p}_{T,i}^{\\text{raw}}\n$$\n$$\n\\Delta \\vec{E}_{T}^{\\text{miss}} = - \\sum_{i \\in K} (c_i^{\\text{new}} - c_i^{\\text{old}}) \\vec{p}_{T,i}^{\\text{raw}}\n$$\nThis leads to the final incremental update rule for the MET vector:\n$$\n\\vec{E}_{T}^{\\text{miss, new}} = \\vec{E}_{T}^{\\text{miss, old}} - \\sum_{i \\in K} (c_i^{\\text{new}} - c_i^{\\text{old}}) \\vec{p}_{T,i}^{\\text{raw}}\n$$\nThis rule states that the MET is updated by subtracting the change in the momentum of each updated jet, where the change is proportional to the difference between the new and old correction factors.\n\n### **2. Complexity Analysis**\n\nLet $N$ be the total number of jets in the event, and $k$ be the number of jets in an update batch (with $k \\le N$).\n\n**Naive Recomputation Strategy:**\nThis strategy recomputes the MET from scratch after every update.\n1.  Start with the raw MET, $\\vec{E}_{T}^{\\text{miss, raw}}$.\n2.  Iterate through all $N$ jets. For each jet, check if it passes the selection criteria.\n3.  For each selected jet $i$, calculate its contribution to the MET correction, $(c_i - 1)\\vec{p}_{T,i}^{\\text{raw}}$, and subtract it from the running MET sum.\n*   **Time Complexity:** The dominant operation is the loop over all $N$ jets. This must be done for every update. Thus, the time complexity per update is $O(N)$. If trigonometric functions were not precomputed, there would be an additional cost of $O(N_S)$ calls to `cos` and `sin`, where $N_S$ is the number of selected jets.\n*   **Space Complexity:** Requires storing the raw properties of $N$ jets and their correction factors, leading to a space complexity of $O(N)$.\n\n**Incremental Strategy:**\nThis strategy maintains the state of the MET and per-jet corrections, applying updates only for the changed jets.\n1.  **One-time Setup:**\n    a. Loop through all $N$ jets to determine which ones are selected.\n    b. Precompute and store the Cartesian components of the raw transverse momentum, $\\vec{p}_{T,i}^{\\text{raw}} = (p_{T,i}^{\\text{raw}} \\cos \\phi_i, p_{T,i}^{\\text{raw}} \\sin \\phi_i)$, for each jet. This requires $N$ calls to trigonometric functions.\n    c. Initialize an array of current correction factors, $c_i=1.0$ for all $i$.\n    The setup cost is $O(N)$.\n2.  **Per-Update (for $k$ updated jets):**\n    a. For each of the $k$ jets in the update batch:\n    b. Check if the jet is selected.\n    c. If so, retrieve its old correction factor $c_i^{\\text{old}}$, the new factor $c_i^{\\text{new}}$, and its precomputed $\\vec{p}_{T,i}^{\\text{raw}}$.\n    d. Calculate the change to MET using the derived rule: $-\\Delta c_i \\cdot \\vec{p}_{T,i}^{\\text{raw}}$, where $\\Delta c_i = c_i^{\\text{new}} - c_i^{\\text{old}}$.\n    e. Add this vector change to the current MET vector.\n    f. Update the stored factor: $c_i \\leftarrow c_i^{\\text{new}}$.\n*   **Time Complexity:** The setup cost is $O(N)$. Crucially, the cost of each subsequent update depends only on the size of the update batch, $k$. The complexity per update is $O(k)$. Since in typical applications $k \\ll N$, this is a substantial improvement. Trigonometric function calls are eliminated from the update loop, their cost being amortized into the one-time setup.\n*   **Space Complexity:** Requires storing raw jet data, precomputed momentum components, and current correction factors for all $N$ jets. The space complexity is $O(N)$.\n\nThe incremental strategy offers a significant performance advantage in time complexity per update, $O(k)$ versus $O(N)$, at the cost of a slightly larger, but asymptotically identical, space complexity of $O(N)$.\n\n### **3. Algorithm Implementation**\n\nThe implementation will follow the incremental strategy. For each test case, we will:\n1.  Initialize the MET with its raw value.\n2.  Perform the one-time setup: precompute raw momentum vectors for all jets, determine which jets are selected, and initialize all correction factors to $1.0$.\n3.  Sequentially process each update batch. For each jet in the batch, if it is selected, apply the incremental update formula using its precomputed raw momentum.\n4.  After all batches are processed, calculate the final MET magnitude and angle.\n5.  Format the results as specified.\n\nThe final polar representation $(E_{T}^{\\text{corr}}, \\phi^{\\text{corr}})$ is computed from the final Cartesian components $(E_{x}^{\\text{corr}}, E_{y}^{\\text{corr}})$ as:\n$$\nE_{T}^{\\text{corr}} = \\sqrt{(E_{x}^{\\text{corr}})^2 + (E_{y}^{\\text{corr}})^2}\n$$\n$$\n\\phi^{\\text{corr}} = \\mathrm{atan2}(E_{y}^{\\text{corr}}, E_{x}^{\\text{corr}})\n$$\nThe `atan2` function correctly handles all quadrants and ensures the angle is in the required interval $(-\\pi, \\pi]$. All final floating-point numbers are rounded to six decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the incremental MET correction problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"raw_met\": (-30.0, 20.0),\n            \"jets\": [\n                (50.0, 0.3, 0.5),    # index 0\n                (40.0, -2.5, 1.2),   # index 1\n                (10.0, 1.5, 2.0),    # index 2\n            ],\n            \"selection\": {\"T\": 20.0, \"eta_max\": 4.7},\n            \"updates\": [{0: 1.10, 1: 0.95, 2: 1.20}],\n        },\n        {\n            \"raw_met\": (5.0, -5.0),\n            \"jets\": [\n                (15.0, 0.2, 0.3),    # index 0\n                (18.0, -1.0, 5.1),   # index 1\n                (35.0, 1.2, 5.5),    # index 2\n            ],\n            \"selection\": {\"T\": 20.0, \"eta_max\": 4.7},\n            \"updates\": [{0: 1.10, 1: 1.05, 2: 0.90}],\n        },\n        {\n            \"raw_met\": (0.0, 0.0),\n            \"jets\": [\n                (20.0, 0.7853981633974483, 0.0), # index 0\n                (100.0, -0.7853981633974483, 0.0),# index 1\n            ],\n            \"selection\": {\"T\": 20.0, \"eta_max\": 4.7},\n            \"updates\": [{0: 1.05, 1: 1.0}],\n        },\n        {\n            \"raw_met\": (10.0, -12.0),\n            \"jets\": [\n                (45.0, 1.0, 0.3),    # index 0\n                (60.0, -2.0, 2.0),   # index 1\n                (18.0, 0.5, 0.1),    # index 2\n            ],\n            \"selection\": {\"T\": 20.0, \"eta_max\": 4.7},\n            \"updates\": [\n                {0: 1.10, 1: 0.90},  # batch 1\n                {1: 0.95, 2: 1.50},  # batch 2\n            ],\n        },\n        {\n            \"raw_met\": (0.0, 0.0),\n            \"jets\": [\n                (30.0, 3.131592653589793, 0.0),  # index 0\n                (50.0, -3.131592653589793, 0.0), # index 1\n            ],\n            \"selection\": {\"T\": 20.0, \"eta_max\": 4.7},\n            \"updates\": [{0: 1.02, 1: 1.02}],\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Initialize state for the current test case.\n        current_met_x, current_met_y = case[\"raw_met\"]\n        jets = case[\"jets\"]\n        selection_T = case[\"selection\"][\"T\"]\n        selection_eta_max = case[\"selection\"][\"eta_max\"]\n        num_jets = len(jets)\n\n        # State storage for the incremental algorithm.\n        jet_pT_xy_raw = np.zeros((num_jets, 2))\n        is_selected = [False] * num_jets\n        current_c = [1.0] * num_jets\n\n        # One-time setup: precomputation and initial selection.\n        for i, (pT_raw, phi, eta) in enumerate(jets):\n            # Check if jet passes selection criteria.\n            if pT_raw = selection_T and abs(eta)  selection_eta_max:\n                is_selected[i] = True\n            \n            # Precompute raw momentum components to avoid repeated trig calls.\n            cos_phi = np.cos(phi)\n            sin_phi = np.sin(phi)\n            jet_pT_xy_raw[i] = [pT_raw * cos_phi, pT_raw * sin_phi]\n\n        # Process all update batches sequentially.\n        for batch in case[\"updates\"]:\n            for jet_idx, c_new in batch.items():\n                if is_selected[jet_idx]:\n                    c_old = current_c[jet_idx]\n                    delta_c = c_new - c_old\n                    \n                    pTx_raw, pTy_raw = jet_pT_xy_raw[jet_idx]\n                    \n                    # Apply the incremental update rule derived from momentum conservation.\n                    # E_miss_new = E_miss_old - (c_new - c_old) * pT_raw_jet\n                    current_met_x -= delta_c * pTx_raw\n                    current_met_y -= delta_c * pTy_raw\n                    \n                    # Update the stored correction factor for the jet.\n                    current_c[jet_idx] = c_new\n        \n        # Calculate final polar coordinates of the corrected MET.\n        corr_met_mag = np.sqrt(current_met_x**2 + current_met_y**2)\n        corr_met_phi = np.arctan2(current_met_y, current_met_x)\n\n        # Round all results to six decimal places and store them.\n        result = [\n            round(current_met_x, 6),\n            round(current_met_y, 6),\n            round(corr_met_mag, 6),\n            round(corr_met_phi, 6)\n        ]\n        all_results.append(result)\n\n    # Format the final output string exactly as specified, with no spaces.\n    results_str = \",\".join([f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in all_results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        }
    ]
}