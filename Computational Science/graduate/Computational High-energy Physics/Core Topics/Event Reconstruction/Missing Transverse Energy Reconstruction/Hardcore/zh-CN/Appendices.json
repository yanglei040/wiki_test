{
    "hands_on_practices": [
        {
            "introduction": "在强子对撞机的高光度环境中，每次束流交叉不仅会发生一次感兴趣的硬散射相互作用，还会伴随多次额外的质子-质子碰撞，即所谓的“堆积效应”（pileup）。这个练习旨在通过实现两种在高能物理实验中广泛使用的标准算法——带电强子减除（Charged Hadron Subtraction, CHS）和逐粒子堆积识别（PileUp Per Particle Identification, PUPPI），来解决堆积效应对横向缺失能量（MET）重建的污染问题。通过这个实践，您将亲手处理粒子流候选者，区分来自主顶点的粒子和来自堆积效应的粒子，从而更精确地重建MET。",
            "id": "3522767",
            "problem": "给定每个事件的一组粒子流（Particle Flow, PF）候选者，每个候选者在横向平面上的特征由其横向动量分量、一个电荷标记、一个主顶点关联标记以及一个基于局域形状的权重来描述。您的任务是实现计算高能物理中用于堆积抑制（pileup mitigation）和横向缺失能量（Missing Transverse Energy, MET）重建的两种标准方案：带电强子减除（Charged Hadron Subtraction, CHS）和逐粒子堆积识别（PileUp Per Particle Identification, PUPPI）。从横向平面上的动量守恒和MET作为重建横向动量矢量和的负值的定义出发，为一个小的、明确指定的测试套件计算两种方案下得到的MET矢量。\n\n基本原理：\n- 横向平面上的动量守恒意味着，对于一个由横向动量为 $\\vec{p}_{T}^{(i)} = (p_{x}^{(i)}, p_{y}^{(i)})$（以 $\\text{GeV}$ 为单位）的PF候选者组成的重建事件，横向缺失能量矢量定义为横向动量的负总和：\n$$\n\\vec{E}_{T}^{\\text{miss}} = - \\sum_{i} \\vec{p}_{T}^{(i)} = \\left( E_{x}^{\\text{miss}}, E_{y}^{\\text{miss}} \\right) ,\n$$\n其中\n$$\nE_{x}^{\\text{miss}} = - \\sum_{i} p_{x}^{(i)}, \\quad E_{y}^{\\text{miss}} = - \\sum_{i} p_{y}^{(i)} ,\n$$\n其大小为\n$$\n\\left| \\vec{E}_{T}^{\\text{miss}} \\right| = \\sqrt{ \\left( E_{x}^{\\text{miss}} \\right)^{2} + \\left( E_{y}^{\\text{miss}} \\right)^{2} } .\n$$\n\n需要实现的定义：\n- 带电强子减除（CHS）：设每个PF候选者由元组 $\\left( p_{x}, p_{y}, q, b, w \\right)$ 定义，其中 $p_{x}$ 和 $p_{y}$ 的单位为 $\\text{GeV}$，$q \\in \\{0,1\\}$ 是一个电荷标记，$q = 1$ 表示带电候选者，$q = 0$ 表示中性候选者，$b \\in \\{0,1\\}$ 表示主顶点关联，$b = 1$ 表示与选定的主顶点相关联，$b = 0$ 表示与非主顶点相关联，而 $w \\in [0,1]$ 是PUPPI算法使用的基于局域形状的权重。在CHS中，包含所有中性候选者（无论 $b$ 为何值），仅在 $b = 1$ 时包含带电候选者，并排除 $b = 0$ 的带电候选者。在CHS中，不对包含的候选者应用逐粒子重加权，即它们贡献其完整的 $\\left( p_{x}, p_{y} \\right)$。\n- 逐粒子堆积识别（PUPPI）：对于带电候选者，若 $b = 1$ 则设置有效权重 $\\alpha$ 等于 $1$，若 $b = 0$ 则等于 $0$。对于中性候选者，设置 $\\alpha = w$。对于任何在区间 $\\left[0,1\\right]$ 之外的给定 $w$ 值，需将其限制在区间 $\\left[0,1\\right]$ 内。计入总和的加权横向动量则为 $\\alpha \\, \\vec{p}_{T}^{(i)} = \\left( \\alpha \\, p_{x}^{(i)}, \\alpha \\, p_{y}^{(i)} \\right)$。\n\n你的程序必须：\n- 使用上述定义的CHS和PUPPI方案，实现 $\\vec{E}_{T}^{\\text{miss}}$ 的计算。\n- 使用下方的测试套件，并为每个测试用例计算 $E_{x}^{\\text{miss,CHS}}$、$E_{y}^{\\text{miss,CHS}}$、$\\left| \\vec{E}_{T}^{\\text{miss,CHS}} \\right|$、$E_{x}^{\\text{miss,PUPPI}}$、$E_{y}^{\\text{miss,PUPPI}}$ 和 $\\left| \\vec{E}_{T}^{\\text{miss,PUPPI}} \\right|$ 等量。\n- 所有输出均以 $\\text{GeV}$ 为单位，表示为浮点数。此任务不要求计算角度。\n\n测试套件（每个事件是PF候选者元组 $\\left( p_{x}, p_{y}, q, b, w \\right)$ 的列表，其中 $p_{x}$ 和 $p_{y}$ 的单位为 $\\text{GeV}$）：\n- 测试用例 1（混合事件）：\n  - $\\left( 35, 15, 1, 1, 1 \\right)$\n  - $\\left( -20, 5, 0, 0, 0.8 \\right)$\n  - $\\left( 10, -10, 1, 0, 0 \\right)$\n  - $\\left( -5, -7, 0, 0, 0.1 \\right)$\n  - $\\left( 1, 2, 1, 1, 1 \\right)$\n  - $\\left( -3, 4, 0, 0, 0.95 \\right)$\n- 测试用例 2（无堆积，平衡总和与一个零候选者）：\n  - $\\left( 10, 0, 1, 1, 1 \\right)$\n  - $\\left( -10, 0, 0, 0, 1 \\right)$\n  - $\\left( 0, 5, 1, 1, 1 \\right)$\n  - $\\left( 0, -5, 0, 0, 1 \\right)$\n  - $\\left( 0, 0, 0, 0, 0.3 \\right)$\n- 测试用例 3（所有带电粒子均为堆积，中性粒子占主导）：\n  - $\\left( 50, 0, 1, 0, 0 \\right)$\n  - $\\left( 5, 5, 0, 0, 0.2 \\right)$\n  - $\\left( -3, 7, 0, 0, 0.9 \\right)$\n  - $\\left( -2, -1, 0, 0, 0 \\right)$\n  - $\\left( -10, -10, 1, 0, 0 \\right)$\n- 测试用例 4（边界权重和带电堆积）：\n  - $\\left( 1, 0, 0, 0, 1 \\right)$\n  - $\\left( 100, 0, 0, 0, 0 \\right)$\n  - $\\left( -2, 0, 1, 1, 1 \\right)$\n  - $\\left( -3, 4, 1, 0, 0 \\right)$\n- 测试用例 5（小动量的带电-主顶点粒子和零权重中性粒子的数值稳定性）：\n  - $\\left( 0.1, -0.1, 1, 1, 1 \\right)$\n  - $\\left( 20, -20, 0, 0, 0 \\right)$\n  - $\\left( -0.2, 0.2, 1, 0, 0 \\right)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是一个包含六个以 $\\text{GeV}$ 为单位的浮点数的列表，顺序为 $\\left[ E_{x}^{\\text{miss,CHS}}, E_{y}^{\\text{miss,CHS}}, \\left| \\vec{E}_{T}^{\\text{miss,CHS}} \\right|, E_{x}^{\\text{miss,PUPPI}}, E_{y}^{\\text{miss,PUPPI}}, \\left| \\vec{E}_{T}^{\\text{miss,PUPPI}} \\right| \\right]$，书写时不带空格。例如，输出应类似于 $\\left[ [a_{1},b_{1},c_{1},d_{1},e_{1},f_{1}], [a_{2},b_{2},c_{2},d_{2},e_{2},f_{2}], \\dots \\right]$，其中每个 $a_{k}, b_{k}, \\dots, f_{k}$ 是一个以 $\\text{GeV}$ 为单位的浮点数。",
            "solution": "问题陈述已通过验证，被认为是有效的。它在科学上基于高能物理中的动量守恒原理，问题设定良好，对带电强子减除（CHS）和逐粒子堆积识别（PUPPI）算法有清晰明确的定义，且其表述客观。所提供的数据和条件是自洽的，足以推导出一个唯一的解。\n\n任务是为一系列事件计算横向缺失能量（$\\vec{E}_{T}^{\\text{miss}}$），每个事件由粒子流（PF）候选者组成。$\\vec{E}_{T}^{\\text{miss}}$ 定义为选定粒子集合的横向动量（$\\vec{p}_{T}$）矢量和的负值。\n$$\n\\vec{E}_{T}^{\\text{miss}} = - \\sum_{i \\in \\text{selected}} \\vec{p}_{T}^{(i)}\n$$\n我们将应用两种不同的选择和加权方案，即CHS和PUPPI，来确定每个事件中要求和的最终动量矢量集合。\n\n一个PF候选者 $i$ 由元组 $\\left( p_{x}^{(i)}, p_{y}^{(i)}, q^{(i)}, b^{(i)}, w^{(i)} \\right)$ 描述，其中 $\\vec{p}_{T}^{(i)} = (p_{x}^{(i)}, p_{y}^{(i)})$ 是横向动量，$q^{(i)}$ 是电荷标记（$1$ 表示带电，$0$ 表示中性），$b^{(i)}$ 是主顶点关联标记（$1$ 表示与主顶点关联，$0$ 表示不关联），$w^{(i)}$ 是PUPPI算法的权重。\n\n**带电强子减除（CHS）**\n\n在CHS方案中，如果一个粒子是中性的，或者它带电且与主顶点相关联，那么它就被包含在动量总和中。与主顶点不关联的带电粒子（堆积）被丢弃。不应用任何权重。\n要包含的粒子索引集合 $S_{\\text{CHS}}$ 定义如下：\n$$\nS_{\\text{CHS}} = \\{ i \\mid (q^{(i)} = 0) \\lor (q^{(i)} = 1 \\land b^{(i)} = 1) \\}\n$$\nCHS的总横向动量矢量为：\n$$\n\\vec{P}_{\\text{CHS}} = \\sum_{i \\in S_{\\text{CHS}}} \\vec{p}_{T}^{(i)} = \\left( \\sum_{i \\in S_{\\text{CHS}}} p_{x}^{(i)}, \\sum_{i \\in S_{\\text{CHS}}} p_{y}^{(i)} \\right)\n$$\n得到的MET矢量为 $\\vec{E}_{T}^{\\text{miss,CHS}} = -\\vec{P}_{\\text{CHS}}$。\n\n**逐粒子堆积识别（PUPPI）**\n\n在PUPPI方案中，每个粒子都对总和有贡献，但带有一个特定的权重 $\\alpha^{(i)}$。对于带电粒子，权重是二元的：如果与主顶点（PV）关联，则为 $1$，否则为 $0$。对于中性粒子，权重取自提供的值 $w^{(i)}$，并限制在 $[0, 1]$ 区间内。\n粒子 $i$ 的权重 $\\alpha^{(i)}$ 定义如下：\n$$\n\\alpha^{(i)} =\n\\begin{cases}\n1  \\text{if } q^{(i)} = 1 \\text{ and } b^{(i)} = 1 \\\\\n0  \\text{if } q^{(i)} = 1 \\text{ and } b^{(i)} = 0 \\\\\n\\text{clamp}(w^{(i)}, 0, 1)  \\text{if } q^{(i)} = 0\n\\end{cases}\n$$\nPUPPI的总加权横向动量矢量为：\n$$\n\\vec{P}_{\\text{PUPPI}} = \\sum_{i} \\alpha^{(i)} \\vec{p}_{T}^{(i)} = \\left( \\sum_{i} \\alpha^{(i)} p_{x}^{(i)}, \\sum_{i} \\alpha^{(i)} p_{y}^{(i)} \\right)\n$$\n得到的MET矢量为 $\\vec{E}_{T}^{\\text{miss,PUPPI}} = -\\vec{P}_{\\text{PUPPI}}$。\n\n我们现在将这些算法应用于每个测试用例。\n\n**测试用例 1**\n粒子： $(35, 15, 1, 1, 1)$, $(-20, 5, 0, 0, 0.8)$, $(10, -10, 1, 0, 0)$, $(-5, -7, 0, 0, 0.1)$, $(1, 2, 1, 1, 1)$, $(-3, 4, 0, 0, 0.95)$。\n- **CHS：** 包含粒子 $1, 2, 4, 5, 6$。粒子 $3$（带电，非主顶点）被排除。\n  $\\vec{P}_{\\text{CHS}} = (35, 15) + (-20, 5) + (-5, -7) + (1, 2) + (-3, 4) = (8, 19)$。\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (-8, -19)$。大小 $|\\vec{E}_{T}^{\\text{miss,CHS}}| = \\sqrt{(-8)^2 + (-19)^2} = \\sqrt{64 + 361} = \\sqrt{425} \\approx 20.6155 \\text{ GeV}$。\n- **PUPPI：** 权重 $\\alpha$ 分别为：$1, 0.8, 0, 0.1, 1, 0.95$。\n  $\\vec{P}_{\\text{PUPPI}} = 1(35, 15) + 0.8(-20, 5) + 0.1(-5, -7) + 1(1, 2) + 0.95(-3, 4) = (35-16-0.5+1-2.85, 15+4-0.7+2+3.8) = (16.65, 24.1)$。\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (-16.65, -24.1)$。大小 $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = \\sqrt{(-16.65)^2 + (-24.1)^2} = \\sqrt{277.2225 + 580.81} = \\sqrt{858.0325} \\approx 29.2922 \\text{ GeV}$。\n\n**测试用例 2**\n粒子： $(10, 0, 1, 1, 1)$, $(-10, 0, 0, 0, 1)$, $(0, 5, 1, 1, 1)$, $(0, -5, 0, 0, 1)$, $(0, 0, 0, 0, 0.3)$。\n- **CHS：** 所有粒子均被包含（带电粒子与主顶点关联，其他为中性粒子）。\n  $\\vec{P}_{\\text{CHS}} = (10, 0) + (-10, 0) + (0, 5) + (0, -5) + (0, 0) = (0, 0)$。\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (0, 0)$。大小 $|\\vec{E}_{T}^{\\text{miss,CHS}}| = 0 \\text{ GeV}$。\n- **PUPPI：** 权重 $\\alpha$ 分别为：$1, 1, 1, 1, 0.3$。\n  $\\vec{P}_{\\text{PUPPI}} = 1(10, 0) + 1(-10, 0) + 1(0, 5) + 1(0, -5) + 0.3(0, 0) = (0, 0)$。\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (0, 0)$。大小 $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = 0 \\text{ GeV}$。\n\n**测试用例 3**\n粒子： $(50, 0, 1, 0, 0)$, $(5, 5, 0, 0, 0.2)$, $(-3, 7, 0, 0, 0.9)$, $(-2, -1, 0, 0, 0)$, $(-10, -10, 1, 0, 0)$。\n- **CHS：** 包含粒子 $2, 3, 4$（均为中性）。粒子 $1, 5$（带电，非主顶点）被排除。\n  $\\vec{P}_{\\text{CHS}} = (5, 5) + (-3, 7) + (-2, -1) = (0, 11)$。\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (0, -11)$。大小 $|\\vec{E}_{T}^{\\text{miss,CHS}}| = 11 \\text{ GeV}$。\n- **PUPPI：** 权重 $\\alpha$ 分别为：$0, 0.2, 0.9, 0, 0$。\n  $\\vec{P}_{\\text{PUPPI}} = 0.2(5, 5) + 0.9(-3, 7) = (1, 1) + (-2.7, 6.3) = (-1.7, 7.3)$。\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (1.7, -7.3)$。大小 $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = \\sqrt{(1.7)^2 + (-7.3)^2} = \\sqrt{2.89 + 53.29} = \\sqrt{56.18} \\approx 7.4953 \\text{ GeV}$。\n\n**测试用例 4**\n粒子： $(1, 0, 0, 0, 1)$, $(100, 0, 0, 0, 0)$, $(-2, 0, 1, 1, 1)$, $(-3, 4, 1, 0, 0)$。\n- **CHS：** 包含粒子 $1, 2, 3$。粒子 $4$（带电，非主顶点）被排除。\n  $\\vec{P}_{\\text{CHS}} = (1, 0) + (100, 0) + (-2, 0) = (99, 0)$。\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (-99, 0)$。大小 $|\\vec{E}_{T}^{\\text{miss,CHS}}| = 99 \\text{ GeV}$。\n- **PUPPI：** 权重 $\\alpha$ 分别为：$1, 0, 1, 0$。\n  $\\vec{P}_{\\text{PUPPI}} = 1(1, 0) + 1(-2, 0) = (-1, 0)$。\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (1, 0)$。大小 $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = 1 \\text{ GeV}$。\n\n**测试用例 5**\n粒子： $(0.1, -0.1, 1, 1, 1)$, $(20, -20, 0, 0, 0)$, $(-0.2, 0.2, 1, 0, 0)$。\n- **CHS：** 包含粒子 $1, 2$。粒子 $3$（带电，非主顶点）被排除。\n  $\\vec{P}_{\\text{CHS}} = (0.1, -0.1) + (20, -20) = (20.1, -20.1)$。\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (-20.1, 20.1)$。大小 $|\\vec{E}_{T}^{\\text{miss,CHS}}| = \\sqrt{(-20.1)^2 + (20.1)^2} = \\sqrt{2 \\cdot 404.01} = 20.1\\sqrt{2} \\approx 28.4255 \\text{ GeV}$。\n- **PUPPI：** 权重 $\\alpha$ 分别为：$1, 0, 0$。\n  $\\vec{P}_{\\text{PUPPI}} = 1(0.1, -0.1) = (0.1, -0.1)$。\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (-0.1, 0.1)$。大小 $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = \\sqrt{(-0.1)^2 + (0.1)^2} = \\sqrt{0.02} = 0.1\\sqrt{2} \\approx 0.1414 \\text{ GeV}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Missing Transverse Energy (MET) using CHS and PUPPI schemes for a suite of test cases.\n    \"\"\"\n    # Test suite: each event is a list of PF candidate tuples\n    # (p_x, p_y, q, b, w) where p_x, p_y are in GeV.\n    test_cases = [\n        # Test case 1 (mixed event)\n        [\n            (35, 15, 1, 1, 1.0),\n            (-20, 5, 0, 0, 0.8),\n            (10, -10, 1, 0, 0.0),\n            (-5, -7, 0, 0, 0.1),\n            (1, 2, 1, 1, 1.0),\n            (-3, 4, 0, 0, 0.95),\n        ],\n        # Test case 2 (no pileup, balanced sums and a zero-candidate)\n        [\n            (10, 0, 1, 1, 1.0),\n            (-10, 0, 0, 0, 1.0),\n            (0, 5, 1, 1, 1.0),\n            (0, -5, 0, 0, 1.0),\n            (0, 0, 0, 0, 0.3),\n        ],\n        # Test case 3 (all charged are pileup, neutrals dominate)\n        [\n            (50, 0, 1, 0, 0.0),\n            (5, 5, 0, 0, 0.2),\n            (-3, 7, 0, 0, 0.9),\n            (-2, -1, 0, 0, 0.0),\n            (-10, -10, 1, 0, 0.0),\n        ],\n        # Test case 4 (boundary weights and charged pileup)\n        [\n            (1, 0, 0, 0, 1.0),\n            (100, 0, 0, 0, 0.0),\n            (-2, 0, 1, 1, 1.0),\n            (-3, 4, 1, 0, 0.0),\n        ],\n        # Test case 5 (numerical stability with small charged-PV momenta and zero-weight neutrals)\n        [\n            (0.1, -0.1, 1, 1, 1.0),\n            (20, -20, 0, 0, 0.0),\n            (-0.2, 0.2, 1, 0, 0.0),\n        ],\n    ]\n\n    results = []\n    for event in test_cases:\n        sum_p_chs = np.array([0.0, 0.0])\n        sum_p_puppi = np.array([0.0, 0.0])\n\n        for particle in event:\n            p_x, p_y, q, b, w = particle\n            p_T = np.array([p_x, p_y])\n\n            # Charged Hadron Subtraction (CHS) logic\n            # Include if neutral (q=0) or charged from primary vertex (q=1, b=1)\n            if q == 0 or (q == 1 and b == 1):\n                sum_p_chs += p_T\n\n            # PileUp Per Particle Identification (PUPPI) logic\n            alpha = 0.0\n            if q == 1:  # Charged particle\n                alpha = 1.0 if b == 1 else 0.0\n            else:  # Neutral particle\n                alpha = np.clip(w, 0.0, 1.0)\n            \n            sum_p_puppi += alpha * p_T\n\n        # Calculate MET vector (negative of the momentum sum)\n        met_chs = -sum_p_chs\n        met_puppi = -sum_p_puppi\n\n        # Calculate MET magnitude\n        mag_met_chs = np.linalg.norm(met_chs)\n        mag_met_puppi = np.linalg.norm(met_puppi)\n\n        # Store results for the current event\n        case_result = [\n            met_chs[0], met_chs[1], mag_met_chs,\n            met_puppi[0], met_puppi[1], mag_met_puppi,\n        ]\n        results.append(case_result)\n        \n    # Format the final output string as specified, without spaces in sub-lists.\n    formatted_results = []\n    for res in results:\n        # Manually format each sub-list to avoid spaces from standard list-to-string conversion.\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]},{res[5]}]\"\n        formatted_results.append(res_str)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在重建MET时，我们需要对事件中成千上万个粒子的横向动量进行矢量求和。这个练习将探讨一个关键的计算物理问题：有限精度浮点数算术对大规模求和结果的影响。您将通过一个模拟程序，比较使用32位单精度浮点数和64位双精度浮点数计算MET所产生的差异，这种差异在高多重数环境中可能变得不可忽略。此练习揭示了数值稳定性在科学计算中的重要性，并让您对计算结果的潜在偏差有更深刻的认识。",
            "id": "3522729",
            "problem": "要求您量化有限精度浮点运算对缺失横向能量 (MET) 重建产生的数值影响，其定义为缺失横向能量 (MET) $E_T^{\\text{miss}}$，向量为 $\\vec{E}_T^{\\text{miss}} = -\\sum_i \\vec{p}_{T,i}$，适用于包含 $\\mathcal{O}(10^5)$ 个粒子流 (PF) 候选者横向动量向量 $\\vec{p}_{T,i}$ 的事例。目标是评估使用 $32$ 位浮点数 (float32) 与 $64$ 位浮点数 (float64) 对最终计算出的量值 $E_T^{\\text{miss}}$ 的影响，并估计由较低精度引起的偏差。对于给定的事例，偏差定义为差值 $E_T^{\\text{miss}}(\\text{float32}) - E_T^{\\text{miss}}(\\text{float64})$，以 $\\text{GeV}$ 为单位表示。\n\n请从以下基本定义出发：\n- 每个 PF 候选者的横向动量 $\\vec{p}_{T,i}$ 定义为 $\\vec{p}_{T,i} = (p_{x,i}, p_{y,i}) = (p_{T,i}\\cos\\phi_i, p_{T,i}\\sin\\phi_i)$，其中 $\\phi_i$ 是以弧度为单位的方位角。\n- 缺失横向能量向量 $\\vec{E}_T^{\\text{miss}} = -\\sum_i \\vec{p}_{T,i}$ 和标量 $E_T^{\\text{miss}} = \\left\\lVert \\vec{E}_T^{\\text{miss}} \\right\\rVert$ 的定义。\n- 在电气与电子工程师协会 (IEEE) 754 算术标准下，浮点加法的数值特性，包括舍入到最近可表示值以及存在控制舍入误差的机器ε。\n\n您必须实现一个程序，该程序：\n1. 为几种科学上合理的情景生成 PF 候选者的横向动量，使用 $32$ 位和 $64$ 位两种算术精度通过顺序累加计算 $\\sum_i p_{x,i}$ 和 $\\sum_i p_{y,i}$，然后为每种精度计算 $E_T^{\\text{miss}}$。\n2. 对于每种情景，报告定义为 $E_T^{\\text{miss}}(\\text{float32}) - E_T^{\\text{miss}}(\\text{float64})$ 的偏差，以 $\\text{GeV}$ 为单位。\n\n所有角度必须以弧度为单位。所有能量和动量必须以 $\\text{GeV}$ 为单位。最终的数值答案必须以 $\\text{GeV}$ 为单位，表示为浮点数。\n\n为保证科学真实性，请使用以下事例生成规则：\n- 令 $\\phi_i \\sim \\text{Uniform}(0, 2\\pi)$。\n- 令 $p_{T,i}$ 服从指数分布（代表软 PF 候选者）或对数正态分布（代表较硬的类喷注 PF 候选者）：\n  - 软成分：$p_{T,i} \\sim \\text{Exponential}(\\lambda)$，均值为 $\\lambda^{-1} = 0.7\\,\\text{GeV}$。\n  - 硬成分：$p_{T,i} \\sim \\text{LogNormal}(\\mu, \\sigma)$，校准后均值为 $30\\,\\text{GeV}$，其中 $\\sigma = 0.5$ 且 $\\mu = \\ln(30) - \\sigma^2/2$。\n- 在下文情景定义中指定的地方使用混合模型。\n\n您必须对求和 $S_x = \\sum_i p_{x,i}$ 和 $S_y = \\sum_i p_{y,i}$ 实现朴素顺序累加，包括 $32$ 位和 $64$ 位两种算术精度。具体来说，通过在一个简单的循环中逐个添加每一项来更新目标精度的累加器，以确保每次加法都在该精度下进行。\n\n确保覆盖率的测试套件：\n- 测试用例 1 (正常路径，类似 HL-LHC 的高堆积情景)：$N = 100{,}000$ 个 PF 候选者。混合模型：以 $0.95$ 的概率使用软指数成分；以 $0.05$ 的概率使用硬对数正态成分。随机数生成器种子为 $42$。\n- 测试用例 2 (边界抵消)：$N = 2$ 个 PF 候选者，其中 $p_{T,1} = p_{T,2} = 50\\,\\text{GeV}$，$\\phi_1 = 0$ 且 $\\phi_2 = \\pi$，因此在实数运算中，其真实总和会精确抵消。不进行随机抽样。\n- 测试用例 3 (大规模工程化的近乎完美抵消)：$N = 100{,}000$ 个 PF 候选者，由 $50{,}000$ 个随机对组成。对于 $i=1,\\dots,50{,}000$，使用种子 $123$ 从均值为 $0.7\\,\\text{GeV}$ 的指数分布 $p_{T,i} \\sim \\text{Exponential}$ 和均匀分布 $\\phi_i \\sim \\text{Uniform}(0, 2\\pi)$ 中抽取，并设置候选者 $i+50{,}000$ 具有相同的 $p_{T}$ 但方位角为 $\\phi_{i+50{,}000} = \\phi_i + \\pi$ (模 $2\\pi$ 解释)，从而在实数运算中实现精确抵消。\n- 测试用例 4 (离群值)：$N = 100{,}000$ 个 PF 候选者，由使用种子 $31415$ 的测试用例 1 中的混合模型生成的 $99{,}980$ 个候选者，加上 $20$ 个 $p_T = 500\\,\\text{GeV}$ 且 $\\phi \\sim \\text{Uniform}(0, 2\\pi)$ 的离群值构成，用以代表非常硬的喷注。\n\n对于每个测试用例，计算：\n- 偏差 $b = E_T^{\\text{miss}}(\\text{float32}) - E_T^{\\text{miss}}(\\text{float64})$，以 $\\text{GeV}$ 为单位。\n\n答案要求：\n- 单位：所有报告的偏差必须以 $\\text{GeV}$ 为单位。\n- 输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按四个测试用例的顺序排列结果，例如，\"[b1,b2,b3,b4]\"。\n- 数值报告：列表中的每个元素必须是浮点数。程序不得打印任何其他内容。\n\n解决方案必须是完全自包含且可运行的，不得需要任何外部输入或文件。除了 Python 标准库、NumPy 和 SciPy (尽管此处不需要 SciPy)，您不得使用任何其他库。",
            "solution": "该任务旨在量化在使用 $32$ 位单精度浮点数 (float32) 与 $64$ 位双精度浮点数 (float64) 计算缺失横向能量 $E_T^{\\text{miss}}$ 时产生的数值偏差。此偏差定义为 $b = E_T^{\\text{miss}}(\\text{float32}) - E_T^{\\text{miss}}(\\text{float64})$。\n\n缺失横向能量向量 $\\vec{E}_T^{\\text{miss}}$ 是实验粒子物理学中的一个关键可观测量，定义为一次碰撞事例中所有探测到的粒子（粒子流候选者）的横向动量 $\\vec{p}_{T,i}$ 的负向量和：\n$$\n\\vec{E}_T^{\\text{miss}} = -\\sum_{i=1}^{N} \\vec{p}_{T,i}\n$$\n其中 $N$ 是粒子数。第 $i$ 个粒子的横向动量向量由其在垂直于对撞束流的平面中的分量给出：\n$$\n\\vec{p}_{T,i} = (p_{x,i}, p_{y,i}) = (p_{T,i}\\cos\\phi_i, p_{T,i}\\sin\\phi_i)\n$$\n这里，$p_{T,i}$ 是横向动量的模，$\\phi_i$ 是方位角。标量 $E_T^{\\text{miss}}$ 是向量 $\\vec{E}_T^{\\text{miss}}$ 的模：\n$$\nE_T^{\\text{miss}} = \\left\\lVert \\vec{E}_T^{\\text{miss}} \\right\\rVert = \\sqrt{\\left(\\sum_i p_{x,i}\\right)^2 + \\left(\\sum_i p_{y,i}\\right)^2}\n$$\n\n问题的核心在于由电气与电子工程师协会 (IEEE) 754 标准定义的浮点运算特性。浮点数由一个符号、一个有效数（或尾数）和一个指数表示。精度由分配给有效数的比特数决定。对于 float32，这是 $24$ 比特（包括隐含的前导比特），而对于 float64，则是 $53$ 比特。这一差异导致了截然不同的机器ε ($\\epsilon_m$)，即当其与 $1$ 相加时能得到大于 $1$ 的结果的最小数字。近似地，$\\epsilon_{m,32} \\approx 1.2 \\times 10^{-7}$ 且 $\\epsilon_{m,64} \\approx 2.2 \\times 10^{-16}$。\n\n当对大量浮点值求和时（如计算 $\\sum p_{x,i}$ 和 $\\sum p_{y,i}$ 所需），舍入误差会累积。问题指定了朴素顺序累加，即各项被逐一添加到一个运行总和中：$S_k = S_{k-1} + x_k$。这种方法对操作顺序和各项的相对大小特别敏感。当一个小数 $x_k$ 被加到一个大的运行总和 $S_{k-1}$ 上时，$x_k$ 的有效数位在指数对齐过程中可能会被移出可表示范围，导致精度损失，这种效应被称为“吸收”(absorption)。由于 float32 的有效数较小，这种效应在 float32 中比在 float64 中要显著得多。\n\n计算偏差的算法如下：\n1.  对于每个测试用例，使用指定的分布和随机数生成器种子，生成粒子横向动量集合 $\\{p_{T,i}\\}$ 和方位角集合 $\\{\\phi_i\\}$。这些初始值以 float64 精度生成并存储，作为高质量的基准。\n2.  计算所有粒子的动量分量 $p_{x,i}$ 和 $p_{y,i}$。这将产生两组分量数组：一组是 float64 格式（`px_64`、`py_64`），另一组是通过将前者转换为 float32 格式（`px_32`、`py_32`）创建的。这模拟了测量值可能以单精度存储的情景。\n3.  为每个分量和每种精度分别执行朴素顺序求和。使用一个简单的 `for` 循环遍历分量数组，将每个元素添加到一个目标精度的累加器中（例如，`sum_px_32 = numpy.float32(0); for p in px_32: sum_px_32 += p`）。\n4.  在计算出两种精度的总和 $S_x = \\sum p_{x,i}$ 和 $S_y = \\sum p_{y,i}$ 后，计算相应的标量 $E_T^{\\text{miss}}$ 值。对于 float32 的计算，$E_T^{\\text{miss}}(\\text{float32}) = \\sqrt{S_x(\\text{float32})^2 + S_y(\\text{float32})^2}$，会使用 float32 运算来正确传播精度限制。\n5.  最终偏差计算为差值 $b = E_T^{\\text{miss}}(\\text{float32}) - E_T^{\\text{miss}}(\\text{float64})$。\n\n这些测试用例旨在探究此数值问题的不同方面：\n-   **测试用例 1 (高堆积):** 模拟一个真实的高粒子数事例。$p_x$ 和 $p_y$ 的求和是随机游走，而 $N=100,000$ 次加法为舍入误差的累积提供了充分的机会。由于统计涨落，最终的 $E_T^{\\text{miss}}$ 预计不为零，而 float32 和 float64 的结果将会出现分歧。\n-   **测试用例 2 (边界抵消):** 一个简单的例子，包含两个具有相同 $p_T$ 且背对背角度（$\\phi_1=0$, $\\phi_2=\\pi$）的粒子。在精确算术中，$\\vec{p}_{T,1} + \\vec{p}_{T,2} = \\vec{0}$。由于 $p_{T,i}=50$ 和 $\\cos(\\pi)=-1$ 在 float32 和 float64 中都能精确表示，因此求和 $p_{x,1}+p_{x,2}$ 和 $p_{y,1}+p_{y,2}$ 在两种精度下都应该精确计算为 $0$。预期的偏差是 $0$。\n-   **测试用例 3 (工程化抵消):** 大规模版本的抵消。通过构建 $50,000$ 对在实数运算中能完美抵消的随机粒子对，真实的总结向量 $\\vec{E}_T^{\\text{miss}}$ 是 $\\vec{0}$。然而，对 $100,000$ 个伪随机浮点数进行顺序求和将累积显著的误差。精度较低的 float32 求和将比 float64 求和更明显地偏离零，从而导致一个非零的计算结果 $E_T^{\\text{miss}}(\\text{float32})$，并因此产生一个正偏差。\n-   **测试用例 4 (离群值):** 该情景通过向大量低 $p_T$ 粒子样本中添加少数几个非常高 $p_T$ 的粒子，引入了大的 $p_T$ 值动态范围。在求和时，如果一个非常大的值被加到由较小值构成的运行总和上，那么在 float32 运算中，这些较小值的贡献可能会部分或完全丢失。此用例测试了当输入数据具有大动态范围时，朴素求和法对吸收误差的敏感性，预计会产生明显的偏差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_met_bias(pT, phi):\n    \"\"\"\n    Calculates the MET reconstruction bias between float32 and float64 precision.\n\n    Args:\n        pT (np.ndarray): Array of transverse momentum magnitudes in GeV.\n        phi (np.ndarray): Array of azimuthal angles in radians.\n\n    Returns:\n        float: The bias E_T^miss(float32) - E_T^miss(float64) in GeV.\n    \"\"\"\n    # Ensure inputs are high precision for the reference calculation\n    pT_64 = np.asarray(pT, dtype=np.float64)\n    phi_64 = np.asarray(phi, dtype=np.float64)\n\n    # 1. Calculate components in float64\n    px_64 = pT_64 * np.cos(phi_64)\n    py_64 = pT_64 * np.sin(phi_64)\n\n    # Cast initial components to float32 for the test calculation\n    px_32 = px_64.astype(np.float32)\n    py_32 = py_64.astype(np.float32)\n\n    # 2. Sequential summation for float64\n    sum_px_64 = 0.0\n    sum_py_64 = 0.0\n    for p in px_64:\n        sum_px_64 += p\n    for p in py_64:\n        sum_py_64 += p\n        \n    # 3. Sequential summation for float32\n    sum_px_32 = np.float32(0.0)\n    sum_py_32 = np.float32(0.0)\n    for p in px_32:\n        sum_px_32 += p\n    for p in py_32:\n        sum_py_32 += p\n\n    # 4. Calculate MET magnitude for both precisions\n    met_64 = np.sqrt(sum_px_64**2 + sum_py_64**2)\n    \n    # Perform the float32 magnitude calculation preserving precision\n    sum_px_32_sq = sum_px_32 * sum_px_32\n    sum_py_32_sq = sum_py_32 * sum_py_32\n    met_32 = np.sqrt(sum_px_32_sq + sum_py_32_sq)\n\n    # 5. Compute the bias\n    bias = float(met_32) - float(met_64)\n    \n    return bias\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'id': 1, 'type': 'high_pileup', 'N': 100000, 'seed': 42},\n        {'id': 2, 'type': 'boundary_cancellation', 'N': 2, 'seed': None},\n        {'id': 3, 'type': 'engineered_cancellation', 'N': 100000, 'seed': 123},\n        {'id': 4, 'type': 'outliers', 'N': 100000, 'seed': 31415},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        pT, phi = None, None\n        \n        if case['type'] == 'high_pileup':\n            rng = np.random.default_rng(case['seed'])\n            N = case['N']\n            p_hard = 0.05\n            \n            is_hard = rng.random(N)  p_hard\n            n_hard = np.sum(is_hard)\n            n_soft = N - n_hard\n\n            pT_soft = rng.exponential(scale=0.7, size=n_soft)\n            \n            sigma_hard = 0.5\n            mean_hard = 30.0\n            mu_hard = np.log(mean_hard) - sigma_hard**2 / 2.0\n            pT_hard = rng.lognormal(mean=mu_hard, sigma=sigma_hard, size=n_hard)\n            \n            pT = np.zeros(N, dtype=np.float64)\n            pT[is_hard] = pT_hard\n            pT[~is_hard] = pT_soft\n            phi = rng.uniform(0, 2 * np.pi, N)\n\n        elif case['type'] == 'boundary_cancellation':\n            pT = np.array([50.0, 50.0], dtype=np.float64)\n            phi = np.array([0.0, np.pi], dtype=np.float64)\n\n        elif case['type'] == 'engineered_cancellation':\n            rng = np.random.default_rng(case['seed'])\n            N = case['N']\n            N_half = N // 2\n            \n            pT_half = rng.exponential(scale=0.7, size=N_half)\n            phi_half = rng.uniform(0, 2 * np.pi, size=N_half)\n            \n            pT = np.concatenate((pT_half, pT_half))\n            phi = np.concatenate((phi_half, phi_half + np.pi))\n\n        elif case['type'] == 'outliers':\n            rng = np.random.default_rng(case['seed'])\n            N_main = 99980\n            N_outlier = 20\n            p_hard = 0.05\n\n            is_hard = rng.random(N_main)  p_hard\n            n_hard = np.sum(is_hard)\n            n_soft = N_main - n_hard\n            \n            pT_soft = rng.exponential(scale=0.7, size=n_soft)\n            \n            sigma_hard = 0.5\n            mean_hard = 30.0\n            mu_hard = np.log(mean_hard) - sigma_hard**2 / 2.0\n            pT_hard = rng.lognormal(mean=mu_hard, sigma=sigma_hard, size=n_hard)\n            \n            pT_main = np.zeros(N_main, dtype=np.float64)\n            pT_main[is_hard] = pT_hard\n            pT_main[~is_hard] = pT_soft\n            phi_main = rng.uniform(0, 2 * np.pi, N_main)\n\n            pT_outlier = np.full(N_outlier, 500.0, dtype=np.float64)\n            phi_outlier = rng.uniform(0, 2 * np.pi, N_outlier)\n            \n            pT = np.concatenate((pT_main, pT_outlier))\n            phi = np.concatenate((phi_main, phi_outlier))\n            \n        bias = calculate_met_bias(pT, phi)\n        results.append(bias)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "计算出一个非零的MET向量后，我们必须回答一个核心问题：这个信号在多大程度上是显著的，即它究竟是源于未被探测到的粒子（如中微子），还是仅仅是探测器测量误差的涨落？这个练习将引导您进入MET的统计解释层面。您将学习如何利用MET向量及其协方差矩阵，构建一个检验统计量（test statistic），并计算其显著性（significance）和对应的$p$值。这个过程是连接测量与物理发现的关键一步，它将测得的数值转化为统计上可量化的置信度。",
            "id": "3522796",
            "problem": "在一次质子-质子对撞的横向缺失能量（MET）分析中，考虑一个单一事件，其测得的横向缺失能量向量为 $\\vec{E}_T^{\\text{miss}} = (E_x, E_y)$，其中 $E_x = 36\\,\\text{GeV}$ 且 $E_y = -24\\,\\text{GeV}$。在真实缺失能量为零的原假设下，横向平面上的组合探测器响应和重建不确定度被建模为一个均值为零的二元高斯分布，其协方差矩阵已知为\n$$\n\\mathbf{V} \\;=\\;\n\\begin{pmatrix}\n400  180 \\\\\n180  900\n\\end{pmatrix}\\,\\text{GeV}^2 \\, .\n$$\n从多元高斯似然的定义和二次型的基本性质出发，推导一个合适的检验统计量来评估真实缺失能量为零的原假设，证明其在二维情况下原假设下的抽样分布，并将相应的显著性 $S$ 定义为一个无量纲的量。然后，假设原假设为真，计算观察到至少与测得的 $\\vec{E}_T^{\\text{miss}}$ 一样极端的涨落所对应的 $S$ 和相关的 $p$ 值的数值。将 $S$ 和 $p$ 值都四舍五入到四位有效数字。将 $p$ 值表示为小数。最终数值中不包含任何单位。",
            "solution": "该问题要求推导一个用于评估原假设的检验统计量，其抽样分布，相应显著性 $S$ 的定义和计算，以及对于给定的横向缺失能量测量值所关联的 $p$ 值。\n\n第1步：问题陈述与原假设\n测得的横向缺失能量向量由 $\\vec{E}_T^{\\text{miss}} = (E_x, E_y)^T$ 给出，其中 $E_x = 36\\,\\text{GeV}$ 且 $E_y = -24\\,\\text{GeV}$。我们可以将此测量值表示为一个列向量 $\\vec{x} = \\begin{pmatrix} 36 \\\\ -24 \\end{pmatrix}\\,\\text{GeV}$。\n原假设 $H_0$ 是不存在真实的缺失能量。在 $H_0$ 下，测量值的期望值为零向量，$\\vec{\\mu}_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\\,\\text{GeV}$。\n问题陈述，在 $H_0$ 下，组合探测器响应和重建不确定度被建模为一个均值为 $\\vec{\\mu}_0$ 且协方差矩阵 $\\mathbf{V}$ 已知的二元高斯分布：\n$$\n\\mathbf{V} =\n\\begin{pmatrix}\n400  180 \\\\\n180  900\n\\end{pmatrix}\\,\\text{GeV}^2\n$$\n因此，在 $H_0$ 下，测量向量 $\\vec{x}$ 是来自二元正态分布 $\\vec{x} \\sim \\mathcal{N}(\\vec{0}, \\mathbf{V})$ 的一个样本。\n\n第2步：检验统计量的推导\n一个 $k$ 维多元正态分布的概率密度函数（PDF）为\n$$\nf(\\vec{x}; \\vec{\\mu}, \\mathbf{V}) = \\frac{1}{\\sqrt{(2\\pi)^k \\det(\\mathbf{V})}} \\exp\\left(-\\frac{1}{2}(\\vec{x}-\\vec{\\mu})^T \\mathbf{V}^{-1}(\\vec{x}-\\vec{\\mu})\\right)\n$$\n在原假设 $H_0$ 下，我们有 $k=2$ 且 $\\vec{\\mu}=\\vec{0}$。观测到测量值 $\\vec{x}$ 的似然与在 $H_0$ 下评估的PDF成正比：\n$$\nL(\\vec{x} | H_0) \\propto \\exp\\left(-\\frac{1}{2}\\vec{x}^T \\mathbf{V}^{-1}\\vec{x}\\right)\n$$\n指数中的二次型 $T = \\vec{x}^T \\mathbf{V}^{-1}\\vec{x}$ 是测量值 $\\vec{x}$ 相对于期望均值 $\\vec{0}$ 的马氏距离（Mahalanobis distance）的平方。该量提供了一个衡量在原假设下观测值有多“极端”或“不可能”的尺度。$T$ 值越大，对应的观测结果与 $H_0$ 的一致性越差。因此，$T = \\vec{x}^T \\mathbf{V}^{-1}\\vec{x}$ 是此问题的一个合适的检验统计量。\n\n第3步：检验统计量的抽样分布\n多元正态分布的一个基本性质是，如果一个随机向量 $\\vec{X}$ 来自一个 $k$ 维正态分布 $\\mathcal{N}(\\vec{\\mu}, \\mathbf{V})$，那么二次型 $T = (\\vec{X}-\\vec{\\mu})^T \\mathbf{V}^{-1} (\\vec{X}-\\vec{\\mu})$ 服从一个自由度为 $k$ 的卡方（$\\chi^2$）分布。\n在我们的情况下，根据 $H_0$，测量向量被假定为来自一个均值为 $\\vec{\\mu}=\\vec{0}$ 的 $k=2$ 维正态分布。因此，我们的检验统计量 $T = \\vec{x}^T \\mathbf{V}^{-1}\\vec{x}$ 服从自由度为 $2$ 的 $\\chi^2$ 分布，记为 $\\chi^2(2)$。\n\n第4步：显著性 $S$ 的定义\n一次观测的显著性量化了其与原假设的不相容程度。在缺失能量重建的背景下，一个常用且方便的显著性 $S$ 定义是检验统计量 $T$ 的平方根。\n$$\nS \\equiv \\sqrt{T} = \\sqrt{\\vec{x}^T \\mathbf{V}^{-1}\\vec{x}}\n$$\n这个量是无量纲的，因为 $\\vec{x}^T$ 的单位是 $\\text{GeV}$，$\\mathbf{V}^{-1}$ 的单位是 $\\text{GeV}^{-2}$，而 $\\vec{x}$ 的单位是 $\\text{GeV}$，导致乘积为无量纲。这个定义具有直观上的吸引力，因为它类似于一维情况下的标准分数 $Z = (x-\\mu)/\\sigma$，其中 $Z^2 = (x-\\mu)^2/\\sigma^2$ 是一维的 $\\chi^2$ 统计量。\n\n第5步：数值计算\n首先，我们必须计算协方差矩阵 $\\mathbf{V}$ 的逆矩阵。对于一个 $2 \\times 2$ 矩阵 $\\mathbf{A} = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$，其逆矩阵为 $\\mathbf{A}^{-1} = \\frac{1}{ad-bc} \\begin{pmatrix} d  -b \\\\ -c  a \\end{pmatrix}$。\n对于我们的协方差矩阵 $\\mathbf{V} = \\begin{pmatrix} 400  180 \\\\ 180  900 \\end{pmatrix}$，其行列式为：\n$$\n\\det(\\mathbf{V}) = (400)(900) - (180)(180) = 360000 - 32400 = 327600\\,\\text{GeV}^4\n$$\n逆矩阵是：\n$$\n\\mathbf{V}^{-1} = \\frac{1}{327600}\n\\begin{pmatrix}\n900  -180 \\\\\n-180  400\n\\end{pmatrix}\\,\\text{GeV}^{-2}\n$$\n现在，我们可以为观测到的测量值 $\\vec{x} = \\begin{pmatrix} 36 \\\\ -24 \\end{pmatrix}$ 计算检验统计量 $T_{obs}$ 的值：\n$$\nT_{obs} = \\vec{x}^T \\mathbf{V}^{-1} \\vec{x} = \\begin{pmatrix} 36  -24 \\end{pmatrix} \\frac{1}{327600} \\begin{pmatrix} 900  -180 \\\\ -180  400 \\end{pmatrix} \\begin{pmatrix} 36 \\\\ -24 \\end{pmatrix}\n$$\n执行矩阵乘法：\n$$\n\\begin{pmatrix} 900  -180 \\\\ -180  400 \\end{pmatrix} \\begin{pmatrix} 36 \\\\ -24 \\end{pmatrix} = \\begin{pmatrix} 900(36) + (-180)(-24) \\\\ -180(36) + 400(-24) \\end{pmatrix} = \\begin{pmatrix} 32400 + 4320 \\\\ -6480 - 9600 \\end{pmatrix} = \\begin{pmatrix} 36720 \\\\ -16080 \\end{pmatrix}\n$$\n接下来，我们计算最终的点积：\n$$\nT_{obs} = \\frac{1}{327600} \\begin{pmatrix} 36  -24 \\end{pmatrix} \\begin{pmatrix} 36720 \\\\ -16080 \\end{pmatrix} = \\frac{1}{327600} \\left( 36(36720) + (-24)(-16080) \\right)\n$$\n$$\nT_{obs} = \\frac{1321920 + 385920}{327600} = \\frac{1707840}{327600} \\approx 5.2131868\n$$\n现在我们计算显著性 $S$：\n$$\nS = \\sqrt{T_{obs}} \\approx \\sqrt{5.2131868} \\approx 2.2832404\n$$\n四舍五入到四位有效数字，我们得到 $S \\approx 2.283$。\n\n第6步：$p$ 值的计算\n$p$ 值是在假设 $H_0$ 为真的情况下，获得一个至少与观测值一样大的检验统计量值的概率。这对应于 $\\chi^2(2)$ 分布的上尾概率：\n$$\np = P(T \\ge T_{obs} | H_0) = \\int_{T_{obs}}^{\\infty} f_{\\chi^2(2)}(t) \\, dt\n$$\n自由度为 $k=2$ 的 $\\chi^2$ 分布的PDF是 $f(t; 2) = \\frac{1}{2} \\exp(-t/2)$，其中 $t \\ge 0$。该积分为：\n$$\np = \\int_{T_{obs}}^{\\infty} \\frac{1}{2} \\exp(-t/2) \\, dt = \\left[ -\\exp(-t/2) \\right]_{T_{obs}}^{\\infty} = 0 - (-\\exp(-T_{obs}/2)) = \\exp(-T_{obs}/2)\n$$\n使用计算出的 $T_{obs}$ 值：\n$$\np \\approx \\exp(-5.2131868 / 2) = \\exp(-2.6065934) \\approx 0.0737875\n$$\n将 $p$ 值四舍五入到四位有效数字，我们得到 $p \\approx 0.07379$。\n\n计算出的显著性为 $S \\approx 2.283$，相关的 $p$ 值为 $p \\approx 0.07379$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2.283  0.07379\n\\end{pmatrix}\n}\n$$"
        }
    ]
}