{
    "hands_on_practices": [
        {
            "introduction": "在高能物理实验中，测量带电粒子的动量是重建和识别过程的第一步，也是最核心的步骤之一。本练习将带您深入探讨在磁场中测量动量的基本原理。通过从第一性原理推导横动量分辨率，您将深刻理解探测器几何构型、磁场强度以及测量精度如何共同决定我们对粒子动量测量的极限。",
            "id": "3520912",
            "problem": "在高能对撞机探测器中，弯曲平面内的μ子横向动量重建依赖于测量由磁场中洛伦兹力产生的径迹曲率。考虑一个电荷大小为 $|q|$、横向动量为 $p_T$ 的带电粒子，穿过一个磁场区域，该区域内存在一个垂直于径迹的、经径迹平均的磁场分量，记为 $B$。两个外部精确测量站之间的径迹段被近似为弯曲平面中的一段圆弧，其半径为 $R$，对应的弦长为 $L$。圆弧与弦之间的最大偏离，即矢高 $s$，由一个中间精确测量站测量。假设在小偏转极限下，即 $L \\ll R$。\n\n可作为出发点的基本关系如下：\n- 横向平面内洛伦兹力与向心力的平衡，意味着 $p_T$、$B$、$R$ 和 $|q|$ 之间存在一个关系。\n- 对于半径为 $R$、弦长为 $L$ 的圆弧，其精确的几何矢高为 $s = R - \\sqrt{R^2 - (L/2)^2}$。\n\n假设由于径迹探测器的有限空间分辨率，矢高测量存在一个统计不确定度 $\\sigma_s$。此外，谱仪的准直贡献了一个独立的、构型稳定的矢高不确定度 $\\sigma_a$（假设与 $\\sigma_s$ 不相关）。两个不确定度均被视为高斯的和独立的，因此它们以平方和的形式相加。在整个推导过程中，使用高能物理中的实用单位约定 $p_T \\, [\\mathrm{GeV}] = c_B \\, |q| \\, B \\, [\\mathrm{T}] \\, R \\, [\\mathrm{m}]$，其中 $c_B \\approx 0.3$。并且，$B$ 代表在螺线管谱仪或环形谱仪中与弯曲相关的、经径迹平均的垂直磁场。\n\n仅从给定的基本关系和近似出发，推导一个关于相对横向动量分辨率 $\\sigma_{p_T}/p_T$ 的闭式解析表达式。该分辨率由联合的矢高测量和准直不确定度引起，并用 $p_T$、$B$、$L$、$|q|$、$c_B$、$\\sigma_s$ 和 $\\sigma_a$ 表示。你的最终表达式必须明确显示出其与 $L$ 和 $B$ 的标度关系。请以单个闭式表达式的形式给出最终答案。最终答案是无量纲的；不需要进行数值计算，方框内的最终答案中也不应包含单位。",
            "solution": "问题的原理经确认为具有科学依据、良定且客观。该问题描述了高能物理中带电粒子动量重建的一个标准情景。我们将开始推导。\n\n出发点是给定的两个基本关系。首先，对于电荷大小为 $|q|$ 的粒子，其横向动量 $p_T$、磁场 $B$ 和曲率半径 $R$ 之间的关系是：\n$$p_T = c_B |q| B R$$\n此处，$c_B$ 是一个比例常数，用于处理问题中指定的单位转换，其值约等于 $0.3$。\n\n其次，矢高 $s$、曲率半径 $R$ 和弦长 $L$ 之间的精确几何关系是：\n$$s = R - \\sqrt{R^2 - \\left(\\frac{L}{2}\\right)^2}$$\n\n问题规定使用小偏转极限，即 $L \\ll R$。我们可以利用这个条件来寻找矢高 $s$ 的一个简化的近似表达式。我们从平方根项中提出因子 $R$：\n$$s = R - R \\sqrt{1 - \\frac{L^2}{4R^2}}$$\n由于 $L \\ll R$，项 $\\frac{L^2}{4R^2}$ 远小于 $1$。因此，对于小的 $x$，我们可以使用平方根的二项式近似 $\\sqrt{1-x} \\approx 1 - \\frac{x}{2}$。令 $x = \\frac{L^2}{4R^2}$，我们得到：\n$$s \\approx R - R \\left(1 - \\frac{1}{2} \\frac{L^2}{4R^2}\\right) = R - \\left(R - \\frac{RL^2}{8R^2}\\right) = \\frac{L^2}{8R}$$\n这就给出了矢高著名的近似关系：\n$$s \\approx \\frac{L^2}{8R}$$\n\n我们的目标是求出相对动量分辨率 $\\frac{\\sigma_{p_T}}{p_T}$。为此，我们必须首先用测量量，即矢高 $s$，来表示 $p_T$。根据矢高的近似公式，我们可以将曲率半径 $R$ 表示为：\n$$R \\approx \\frac{L^2}{8s}$$\n将这个 $R$ 的表达式代入动量方程，得到：\n$$p_T \\approx c_B |q| B \\left(\\frac{L^2}{8s}\\right) = \\frac{c_B |q| B L^2}{8s}$$\n\n现在我们可以确定由 $s$ 的测量不确定度引起的 $p_T$ 的不确定度。问题陈述，总矢高不确定度是统计不确定度 $\\sigma_s$ 和准直不确定度 $\\sigma_a$ 的平方和，这两者是独立的。设总矢高不确定度为 $\\sigma_{s, \\text{tot}}$。\n$$\\sigma_{s, \\text{tot}}^2 = \\sigma_s^2 + \\sigma_a^2 \\implies \\sigma_{s, \\text{tot}} = \\sqrt{\\sigma_s^2 + \\sigma_a^2}$$\n\n为了求出 $p_T$ 的不确定度，我们使用标准误差传播法。在此推导中，量 $c_B$、$|q|$、$B$ 和 $L$ 被视为没有不确定度的已知常数。动量 $p_T$ 是单个不确定变量 $s$ 的函数。\n$$p_T(s) = \\left(\\frac{c_B |q| B L^2}{8}\\right) s^{-1}$$\n不确定度 $\\sigma_{p_T}$ 通过以下关系与不确定度 $\\sigma_{s, \\text{tot}}$ 相关联：\n$$\\sigma_{p_T} = \\left|\\frac{dp_T}{ds}\\right| \\sigma_{s, \\text{tot}}$$\n我们计算 $p_T$ 对 $s$ 的导数：\n$$\\frac{dp_T}{ds} = \\frac{d}{ds} \\left(\\frac{c_B |q| B L^2}{8s}\\right) = -\\frac{c_B |q| B L^2}{8s^2}$$\n我们可以用 $p_T$ 本身来重新表示这个导数：\n$$\\frac{dp_T}{ds} = -\\frac{1}{s} \\left(\\frac{c_B |q| B L^2}{8s}\\right) = -\\frac{p_T}{s}$$\n因此，导数的大小为：\n$$\\left|\\frac{dp_T}{ds}\\right| = \\frac{p_T}{s}$$\n将此代入误差传播公式，得到：\n$$\\sigma_{p_T} = \\frac{p_T}{s} \\sigma_{s, \\text{tot}}$$\n于是，相对横向动量分辨率为：\n$$\\frac{\\sigma_{p_T}}{p_T} = \\frac{\\sigma_{s, \\text{tot}}}{s} = \\frac{\\sqrt{\\sigma_s^2 + \\sigma_a^2}}{s}$$\n\n最后一步是用指定的自变量来表示这个结果，这些变量包括 $p_T$ 但不包括 $s$。我们使用早先推导出的关系 $p_T \\approx \\frac{c_B |q| B L^2}{8s}$ 来消去 $s$：\n$$s \\approx \\frac{c_B |q| B L^2}{8 p_T}$$\n将这个 $s$ 的表达式代入我们的相对分辨率方程：\n$$\\frac{\\sigma_{p_T}}{p_T} = \\frac{\\sqrt{\\sigma_s^2 + \\sigma_a^2}}{\\frac{c_B |q| B L^2}{8 p_T}}$$\n化简此表达式，得到相对横向动量分辨率的最终闭式结果：\n$$\\frac{\\sigma_{p_T}}{p_T} = \\frac{8 p_T \\sqrt{\\sigma_s^2 + \\sigma_a^2}}{c_B |q| B L^2}$$\n该表达式明确显示了动量分辨率随横向动量 $p_T$、磁场 $B$ 和弦长 $L$ 的标度关系。具体来说，分辨率随 $p_T$ 的增加而线性变差，并随更强的磁场 ($B^{-1}$) 和更长的杠杆臂 ($L^{-2}$，二次方关系) 而改善。",
            "answer": "$$\\boxed{\\frac{8 p_T \\sqrt{\\sigma_s^2 + \\sigma_a^2}}{c_B |q| B L^2}}$$"
        },
        {
            "introduction": "在真实的对撞机环境中，大量的“堆积效应”会导致重建出许多由无关探测器信号随机组合而成的“伪径迹”。本练习将引导您应用统计学工具来评估径迹拟合的质量。您将学习如何计算卡方($\\chi^2$)统计量，并利用它来设计一个强大的筛选算法，以有效剔除这些伪径迹，这是高亮度环境下数据分析的一项关键技能。",
            "id": "3520905",
            "problem": "在高能物理探测器中重建的一个带电轻子候选者与一组径迹击中点相关联。在每次束团穿越存在额外质子-质子相互作用（称为堆积，PU）的情况下，由于击中点的随机组合，会产生不可忽略比例的伪径迹。为了以可计算复现的方式量化径迹拟合质量并剔除伪径迹，请使用以下基本依据：在一个具有独立高斯击中误差的线性化测量模型下，最优径迹拟合的残差矢量 $\\mathbf{r} \\in \\mathbb{R}^N$ 服从一个多元正态概率密度函数（PDF），其协方差矩阵 $\\mathbf{V} \\in \\mathbb{R}^{N \\times N}$ 是对称正定的，并且用于拟合优度检验的经典似然比检验统计量简化为一个卡方随机变量，其自由度（DoF）为 $\\nu = N - k$，其中 $k$ 是拟合所估计的自由径迹参数的数量。观测到至少与测量值一样差的拟合质量的概率是卡方分布的右尾概率（生存函数）。\n\n您的任务是：\n- 对于每个测试用例，使用所提供的残差和协方差矩阵，计算径迹拟合的卡方统计量以及在卡方分布下对应的拟合质量右尾概率。残差以毫米（mm）为单位，协方差矩阵的条目以平方毫米（$\\text{mm}^2$）为单位。计算出的卡方值和概率是无量纲的；请将它们表示为不带单位的纯数字。\n- 设计并实现一个有数学依据的径迹接受准则，以剔除由堆积产生的伪径迹。该准则必须随着堆积参数 $\\mu$ 的增加而收紧，方法是同时要求：(i) 通过一个随 $\\mu$ 单调递减的最小 $p$ 值阈值 $t_p(\\mu)$ 来表达更强的拟合优度，(ii) 对每自由度归一化卡方值施加一个随 $\\mu$ 单调递减的上限 $t_{\\chi}(\\mu)$，以及 (iii) 要求与主顶点（PV）相关联的击中点的最小比例 $f_{\\text{PV}}$ 随 $\\mu$ 单调递增并在 $1$ 处饱和。在您的实现中使用以下固定常数：$t_0 = 0.05$，$t_{\\chi,0} = 3.0$，$f_0 = 0.6$，$\\lambda = 0.01$，$\\kappa = 0.01$，$s = 0.01$。定义 $t_p(\\mu) = t_0 \\exp(-\\lambda \\mu)$，$t_{\\chi}(\\mu) = t_{\\chi,0} \\exp(-\\kappa \\mu)$，以及 $t_f(\\mu) = \\min\\!\\big(1, f_0 + s \\mu\\big)$。一条径迹被接受当且仅当 $p \\ge t_p(\\mu)$ 且 $(\\chi^2/\\nu) \\le t_{\\chi}(\\mu)$ 且 $f_{\\text{PV}} \\ge t_f(\\mu)$，其中 $f_{\\text{PV}} = n_{\\text{PV}}/N$ 且 $n_{\\text{PV}}$ 是与主顶点相关联的击中点数量。\n\n物理和数值单位：\n- 残差必须视为毫米（mm）。\n- 协方差条目必须视为平方毫米（$\\text{mm}^2$）。\n- 输出 $\\chi^2$、$p$ 和 $\\chi^2/\\nu$ 是无量纲的；请将它们表示为纯数字，并根据您编程语言的默认行为进行四舍五入。\n\n测试套件：\n- 案例1（正常路径，中等堆积）：\n  - $N = 5$，$\\mathbf{r} = [\\,0.02,\\,-0.01,\\,0.015,\\,-0.005,\\,0.01\\,]$ mm,\n  - $\\mathbf{V} = \\begin{pmatrix}\n  0.0009  0.00001  0  0  0\\\\\n  0.00001  0.0009  0.00001  0  0\\\\\n  0  0.00001  0.0009  0.00001  0\\\\\n  0  0  0.00001  0.0009  0.00001\\\\\n  0  0  0  0.00001  0.0009\n  \\end{pmatrix}$ $\\text{mm}^2$, $k = 3$, $\\mu = 20$, $n_{\\text{PV}} = 4$。\n- 案例2（明显伪径迹，高堆积）：\n  - $N = 6$, $\\mathbf{r} = [\\,0.12,\\,-0.15,\\,0.10,\\,-0.20,\\,0.18,\\,0.16\\,]$ mm,\n  - $\\mathbf{V} = \\begin{pmatrix}\n  0.0004  0.000005  0  0  0  0\\\\\n  0.000005  0.0004  0.000005  0  0  0\\\\\n  0  0.000005  0.0004  0.000005  0  0\\\\\n  0  0  0.000005  0.0004  0.000005  0\\\\\n  0  0  0  0.000005  0.0004  0.000005\\\\\n  0  0  0  0  0.000005  0.0004\n  \\end{pmatrix}$ $\\text{mm}^2$, $k = 4$, $\\mu = 60$, $n_{\\text{PV}} = 1$。\n- 案例3（临界拟合，低堆积）：\n  - $N = 5$, $\\mathbf{r} = [\\,0.04,\\,-0.03,\\,0.05,\\,-0.02,\\,0.04\\,]$ mm,\n  - $\\mathbf{V} = \\begin{pmatrix}\n  0.0009  0.00001  0  0  0\\\\\n  0.00001  0.0009  0.00001  0  0\\\\\n  0  0.00001  0.0009  0.00001  0\\\\\n  0  0  0.00001  0.0009  0.00001\\\\\n  0  0  0  0.00001  0.0009\n  \\end{pmatrix}$ $\\text{mm}^2$, $k = 3$, $\\mu = 5$, $n_{\\text{PV}} = 3$。\n- 案例4（边缘情况，完美拟合残差）：\n  - $N = 4$, $\\mathbf{r} = [\\,0.0,\\,0.0,\\,0.0,\\,0.0\\,]$ mm,\n  - $\\mathbf{V} = \\begin{pmatrix}\n  0.0004  0.000002  0  0\\\\\n  0.000002  0.0004  0.000002  0\\\\\n  0  0.000002  0.0004  0.000002\\\\\n  0  0  0.000002  0.0004\n  \\end{pmatrix}$ $\\text{mm}^2$, $k = 3$, $\\mu = 40$, $n_{\\text{PV}} = 4$。\n\n程序输出规范：\n- 对于每个测试用例，您的程序必须计算并返回一个列表 $[\\,\\chi^2,\\,p,\\,\\chi^2/\\nu,\\,\\text{accepted}\\,]$，其中 $\\chi^2$ 是卡方值，$p$ 是在卡方分布下的右尾概率，$\\chi^2/\\nu$ 是每自由度归一化卡方值，而 $\\text{accepted}$ 是一个布尔值，指示该径迹是否通过了考虑堆积的准则。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[\\,\\text{result}_1,\\,\\text{result}_2,\\,\\text{result}_3,\\,\\text{result}_4\\,]$，其中每个 $\\text{result}_i$ 是对应测试用例的列表。不应打印任何额外文本。",
            "solution": "该问题是有效的。所有提供的数据和定义都有科学依据、一致，并且足以形成唯一的解决方案。\n\n任务是评估一组来自高能物理实验的带电轻子径迹候选者。对每个候选者，这涉及两个主要步骤：首先，计算拟合优度统计量；其次，应用一组依赖于堆积的准则来决定是接受还是拒绝该径迹。\n\n### 1. 径迹拟合质量评估\n径迹拟合的质量通过 $\\chi^2$（卡方）统计量来量化。该统计量衡量了测量的击中点位置与拟合的径迹轨迹预测的位置之间的差异，同时考虑了测量不确定性。\n\n**卡方统计量 ($\\chi^2$)**\n\n在假设线性化径迹模型和 $N$ 个击中点具有独立高斯误差的情况下，残差矢量 $\\mathbf{r} \\in \\mathbb{R}^N$（测量坐标与预测坐标之间的差异）服从多元正态分布。这些残差的协方差矩阵为 $\\mathbf{V} \\in \\mathbb{R}^{N \\times N}$。\n\n$\\chi^2$ 统计量由以下二次型定义：\n$$\n\\chi^2 = \\mathbf{r}^T \\mathbf{V}^{-1} \\mathbf{r}\n$$\n其中 $\\mathbf{r}$ 是残差的列矢量（单位为毫米，mm），$\\mathbf{V}$ 是对称正定协方差矩阵（单位为 $\\text{mm}^2$），$\\mathbf{V}^{-1}$ 是其逆矩阵。该乘积在量纲上是一致的：$(\\text{mm}) \\cdot (\\text{mm}^{-2}) \\cdot (\\text{mm})$，得到一个无量纲的 $\\chi^2$ 值。计算需要求协方差矩阵 $\\mathbf{V}$ 的逆。\n\n**自由度 ($\\nu$) 和 $p$ 值**\n\n$\\chi^2$ 统计量服从卡方概率分布。该分布的自由度（DoF）数量 $\\nu$ 由下式给出：\n$$\n\\nu = N - k\n$$\n其中 $N$ 是击中点的数量（即 $\\mathbf{r}$ 的维度），$k$ 是径迹拟合中估计的参数数量（例如，位置、动量分量）。对于所有测试用例，$\\nu  0$。\n\n拟合优度通常表示为 $p$ 值。$p$ 值是在假设径迹假说正确的情况下，观测到大于或等于从数据中计算出的 $\\chi^2$ 值的概率。非常小的 $p$ 值表明，在给定模型下，观测到的数据不太可能出现，这表示拟合效果差。$p$ 值计算为具有 $\\nu$ 个自由度的 $\\chi^2$ 分布的生存函数（1减去累积分布函数）：\n$$\np = P(\\chi^2_{\\nu} \\ge \\chi^2_{\\text{observed}}) = \\int_{\\chi^2_{\\text{observed}}}^{\\infty} f(x; \\nu) dx\n$$\n其中 $f(x; \\nu)$ 是具有 $\\nu$ 个自由度的卡方分布的概率密度函数。\n\n### 2. 依赖于堆积的选择准则\n为了区分源于堆积（额外的质子-质子相互作用）的真实径迹和伪径迹，应用了一套选择准则。随着平均堆积相互作用数 $\\mu$ 的增加，这些准则变得更加严格。一条径迹被接受当且仅当以下所有三个条件都得到满足：\n\n**条件1：$p$ 值阈值**\n径迹的 $p$ 值必须大于或等于一个依赖于堆积的阈值 $t_p(\\mu)$：\n$$\np \\ge t_p(\\mu) \\quad \\text{其中} \\quad t_p(\\mu) = t_0 \\exp(-\\lambda \\mu)\n$$\n给定的常数为 $t_0 = 0.05$ 和 $\\lambda = 0.01$。随着 $\\mu$ 的增加，该阈值减小，使得这个特定的筛选条件变得更宽松。这可能是为了在高堆积环境下，对那些拟合质量可能略有下降的真实径迹保持效率。\n\n**条件2：归一化卡方阈值**\n归一化卡方值 $\\chi^2/\\nu$ 代表每个自由度对 $\\chi^2$ 的平均贡献，它必须低于一个依赖于堆积的阈值 $t_{\\chi}(\\mu)$：\n$$\n\\frac{\\chi^2}{\\nu} \\le t_{\\chi}(\\mu) \\quad \\text{其中} \\quad t_{\\chi}(\\mu) = t_{\\chi,0} \\exp(-\\kappa \\mu)\n$$\n给定的常数为 $t_{\\chi,0} = 3.0$ 和 $\\kappa = 0.01$。随着 $\\mu$ 的增加，该阈值减小，使得筛选更加严格，要求更高质量的拟合。\n\n**条件3：主顶点击中点比例**\n径迹上与主相互作用顶点（PV）相关联的击中点比例 $f_{\\text{PV}}$ 必须高于一个依赖于堆积的阈值 $t_f(\\mu)$：\n$$\nf_{\\text{PV}} \\ge t_f(\\mu) \\quad \\text{其中} \\quad f_{\\text{PV}} = \\frac{n_{\\text{PV}}}{N} \\quad \\text{且} \\quad t_f(\\mu) = \\min(1, f_0 + s \\mu)\n$$\n其中 $n_{\\text{PV}}$ 是来自主顶点的击中点数量。给定的常数为 $f_0 = 0.6$ 和 $s = 0.01$。随着 $\\mu$ 的增加，该阈值增加（并在 $1$ 处饱和），使得筛选更加严格。这能有效剔除堆积径迹，因为预计这些径迹很少或没有击中点源于主碰撞顶点。\n\n由于这些准则的综合效应，总体选择随着 $\\mu$ 的增加而收紧，这主要是由归一化 $\\chi^2$ 和主顶点比例筛选条件的收紧所驱动的。\n\n### 3. 测试用例的计算\n对于每个测试用例，按顺序计算以下量：\n1.  自由度 $\\nu = N - k$。\n2.  通过对 $\\mathbf{V}$ 求逆并计算 $\\mathbf{r}^T \\mathbf{V}^{-1} \\mathbf{r}$ 来得到 $\\chi^2$ 统计量。\n3.  使用 $\\chi^2$ 分布的生存函数计算 $p$ 值。\n4.  归一化卡方值 $\\chi^2/\\nu$。\n5.  依赖于堆积的阈值 $t_p(\\mu)$、$t_{\\chi}(\\mu)$ 和 $t_f(\\mu)$。\n6.  主顶点击中点比例 $f_{\\text{PV}}$。\n7.  基于这三个条件的最终布尔型接受决定。\n\n每个案例的结果被收集并以所需的列表的列表格式呈现。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the track-fit validation problem for all test cases.\n    \"\"\"\n    # Define the fixed constants for the selection criteria.\n    t0 = 0.05\n    t_chi0 = 3.0\n    f0 = 0.6\n    lambda_ = 0.01  # Use lambda_ to avoid conflict with Python's lambda keyword.\n    kappa = 0.01\n    s = 0.01\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, moderate pileup)\n        {\n            'N': 5,\n            'r': [0.02, -0.01, 0.015, -0.005, 0.01],\n            'V': [\n                [0.0009, 0.00001, 0, 0, 0],\n                [0.00001, 0.0009, 0.00001, 0, 0],\n                [0, 0.00001, 0.0009, 0.00001, 0],\n                [0, 0, 0.00001, 0.0009, 0.00001],\n                [0, 0, 0, 0.00001, 0.0009]\n            ],\n            'k': 3, 'mu': 20, 'n_pv': 4\n        },\n        # Case 2 (clear fake, high pileup)\n        {\n            'N': 6,\n            'r': [0.12, -0.15, 0.10, -0.20, 0.18, 0.16],\n            'V': [\n                [0.0004, 0.000005, 0, 0, 0, 0],\n                [0.000005, 0.0004, 0.000005, 0, 0, 0],\n                [0, 0.000005, 0.0004, 0.000005, 0, 0],\n                [0, 0, 0.000005, 0.0004, 0.000005, 0],\n                [0, 0, 0, 0.000005, 0.0004, 0.000005],\n                [0, 0, 0, 0, 0.000005, 0.0004]\n            ],\n            'k': 4, 'mu': 60, 'n_pv': 1\n        },\n        # Case 3 (borderline fit, low pileup)\n        {\n            'N': 5,\n            'r': [0.04, -0.03, 0.05, -0.02, 0.04],\n            'V': [\n                [0.0009, 0.00001, 0, 0, 0],\n                [0.00001, 0.0009, 0.00001, 0, 0],\n                [0, 0.00001, 0.0009, 0.00001, 0],\n                [0, 0, 0.00001, 0.0009, 0.00001],\n                [0, 0, 0, 0.00001, 0.0009]\n            ],\n            'k': 3, 'mu': 5, 'n_pv': 3\n        },\n        # Case 4 (edge case, perfect fit residuals)\n        {\n            'N': 4,\n            'r': [0.0, 0.0, 0.0, 0.0],\n            'V': [\n                [0.0004, 0.000002, 0, 0],\n                [0.000002, 0.0004, 0.000002, 0],\n                [0, 0.000002, 0.0004, 0.000002],\n                [0, 0, 0.000002, 0.0004]\n            ],\n            'k': 3, 'mu': 40, 'n_pv': 4\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N = case['N']\n        r = np.array(case['r'])\n        V = np.array(case['V'])\n        k = case['k']\n        mu = case['mu']\n        n_pv = case['n_pv']\n        \n        # 1. Compute chi-squared statistic\n        V_inv = np.linalg.inv(V)\n        chi2_val = r.T @ V_inv @ r\n        \n        # 2. Compute degrees of freedom, p-value, and normalized chi-squared\n        nu = N - k\n        p_val = chi2.sf(chi2_val, nu)  # Survival function (1 - CDF)\n        chi2_norm = chi2_val / nu if nu > 0 else np.inf\n\n        # 3. Compute pileup-dependent thresholds\n        t_p = t0 * np.exp(-lambda_ * mu)\n        t_chi = t_chi0 * np.exp(-kappa * mu)\n        t_f = min(1.0, f0 + s * mu)\n        \n        # 4. Compute PV hit fraction\n        f_pv = n_pv / N\n        \n        # 5. Apply acceptance criteria\n        cond1 = p_val >= t_p\n        cond2 = chi2_norm = t_chi\n        cond3 = f_pv >= t_f\n        \n        accepted = cond1 and cond2 and cond3\n        \n        all_results.append([chi2_val, p_val, chi2_norm, accepted])\n\n    # Final print statement in the exact required format.\n    # The `str()` of a list produces spaces, e.g., '[1, 2]'.\n    # Joining these string representations produces the specified output format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "电子和光子的精确识别，依赖于综合利用来自径迹探测器和电磁量能器的信息，这是一个复杂的决策过程。这项综合性练习将指导您实现一个简化的粒子流（Particle Flow）算法。通过亲手编写连接径迹与量能器簇的判别逻辑，您将掌握现代粒子物理实验如何根据电子、转换光子和非转换光子在探测器中留下的独特信号来对它们进行分类。",
            "id": "3520857",
            "problem": "您必须用代码实现一个简化但科学上一致的粒子流（PF）分类方法，用于在轻子和光子重建与识别的背景下对电子和光子进行分类。从基本的物理和算法基础出发，推导出决策规则，用于将带电粒子径迹与电磁量能器（ECAL）簇相关联，识别轫致辐射光子，识别光子转换，并编码对象的创建与合并。程序必须处理一个固定的测试集，并生成一个汇总结果的单行输出。\n\n基本原理如下。利用能量动量守恒和方向性：如果一个带电轻子（电子）发出轫致辐射，发射的光子方向近似沿着电子的轨迹。设 $\\vec{p}$ 表示动量，$E$ 表示能量，$\\hat{u}$ 为径迹的单位方向向量，$\\hat{n}$ 为ECAL簇的单位方向向量。对于小角度，径迹和簇之间的角间距可以近似为张角 $\\theta = \\arccos(\\hat{u} \\cdot \\hat{n})$，这在中心区域与通常的 $\\Delta R$ 度量是一致的。光子在材料中的转换产生两条电荷相反、张角很小的径迹，其初始段有内部探测器失踪击中；它们的合成方向指向ECAL的能量沉积。电子主要在ECAL中沉积其能量；轫致辐射光子沿着电子的路径发射，并被附近的ECAL簇捕获。\n\n实现以下数学上定义的决策规则。\n\n1. 径迹-簇的角距离：对于每个径迹 $i$ 和簇 $j$，计算\n$$\nd_{ij} = \\arccos\\!\\left( \\hat{u}_i \\cdot \\hat{n}_j \\right).\n$$\n当 $d_{ij} \\le \\Delta R_{\\mathrm{link}}$ 且 $\\Delta R_{\\mathrm{link}} = 0.03$ $\\mathrm{rad}$ 时，认为径迹和簇在几何上是关联的。\n\n2. 转换光子识别：对于任何与至少两条径迹 $i$ 和 $\\ell$ 关联的ECAL簇 $j$，如果所有条件都满足，则声明一个转换光子：\n- 电荷相反：$q_i \\cdot q_\\ell = -1$。\n- 两条径迹之间的张角很小：$\\theta_{i\\ell} = \\arccos\\!\\left( \\hat{u}_i \\cdot \\hat{u}_\\ell \\right) \\le \\theta_{\\mathrm{conv}}$，其中 $\\theta_{\\mathrm{conv}} = 0.02$ $\\mathrm{rad}$。\n- 两条径迹都有足够的内部探测器失踪击中：$h_i \\ge h_{\\mathrm{conv}}$ 和 $h_\\ell \\ge h_{\\mathrm{conv}}$，其中 $h_{\\mathrm{conv}} = 0.6$。\n如果这些条件得到满足，创建一个能量为 $E_{\\gamma}^{\\mathrm{conv}} = E_j$ 的转换光子对象，并将这两条径迹和该簇标记为已消耗。\n\n3. 电子识别与主簇选择：对于每个剩余的径迹 $i$，在未被消耗的簇 $j$ 中，找到满足 $d_{ij} \\le \\Delta R_{\\mathrm{link}}$ 的集合，并选择使 $d_{ij}$ 最小化的簇作为主簇 $j^\\star$。如果一个径迹的主簇能量满足\n$$\nE_{j^\\star} \\ge \\alpha \\, p_i, \\quad \\text{其中 } \\alpha = 0.5.\n$$\n则该径迹成为一个电子。如果被识别为电子，则将主簇标记为已消耗。\n\n4. 轫致辐射簇的关联与合并：对于一个已识别的电子径迹 $i$ 及其主簇 $j^\\star$，任何其他尚未被消耗的簇 $k$，如果满足 $d_{ik} \\le \\Delta R_{\\mathrm{brem}}$（其中 $\\Delta R_{\\mathrm{brem}} = 0.05$ $\\mathrm{rad}$）并且在所有径迹中与径迹 $i$ 最近，则被视为轫致辐射光子簇，并合并到电子的能量中。重建的电子能量为\n$$\nE_e = E_{j^\\star} + \\sum_{k \\in \\mathcal{B}_i} E_k,\n$$\n其中 $\\mathcal{B}_i$ 是与径迹 $i$ 相关联的轫致辐射簇的集合。将任何合并的轫致辐射簇标记为已消耗。\n\n5. 未转换光子的创建：任何在步骤2-4中未被消耗的剩余ECAL簇，都成为一个能量为 $E_\\gamma = E_j$ 的未转换光子。\n\n方向的几何表示将使用球面坐标来构造单位向量。对于角度 $(\\theta, \\phi)$，定义单位向量\n$$\n\\hat{n}(\\theta,\\phi) = \\left( \\sin\\theta \\cos\\phi,\\; \\sin\\theta \\sin\\phi,\\; \\cos\\theta \\right).\n$$\n角度必须以 $\\mathrm{radians}$（弧度）提供和使用。能量必须以 $\\mathrm{GeV}$ 表示。\n\n输出的对象编码如下：电子 $\\rightarrow 0$，未转换光子 $\\rightarrow 1$，转换光子 $\\rightarrow 2$。每个重建的对象必须表示为 $[\\mathrm{code}, E]$ 形式的列表，其中 $E$ 是对象的能量，单位为 $\\mathrm{GeV}$，并四舍五入到两位小数。\n\n测试集。在以下四个案例上实现该流程，这四个案例分别测试一个一般情况、一个边界、一个转换和一个模糊性解决：\n\n- 案例1（带有一个轫致辐射和一个孤立光子的电子）：\n  - 径迹：一条类电子径迹，其 $p = 50$ $\\mathrm{GeV}$，$q = -1$，$h = 0.1$，$(\\theta, \\phi) = (1.2, 0.1)$。\n  - ECAL簇：主候选簇 $E = 45$ $\\mathrm{GeV}$，位于 $(\\theta, \\phi) = (1.21, 0.1)$；轫致辐射候选簇 $E = 8$ $\\mathrm{GeV}$，位于 $(\\theta, \\phi) = (1.23, 0.1)$；孤立光子 $E = 20$ $\\mathrm{GeV}$，位于 $(\\theta, \\phi) = (0.3, 2.0)$。\n\n- 案例2（链接边界失效：簇恰好在链接阈值之外）：\n  - 径迹：一条径迹，其 $p = 20$ $\\mathrm{GeV}$，$q = +1$，$h = 0.1$，$(\\theta, \\phi) = (1.0, 0.5)$。\n  - ECAL簇：一个簇，其 $E = 20$ $\\mathrm{GeV}$，位于 $(\\theta, \\phi) = (1.032, 0.5)$。\n\n- 案例3（转换光子）：\n  - 径迹：两条径迹，其 $(p, q, h, \\theta, \\phi)$ 分别为 $(15, +1, 0.7, 1.60, 0.2)$ 和 $(14, -1, 0.7, 1.61, 0.2)$。\n  - ECAL簇：一个簇，其 $E = 29$ $\\mathrm{GeV}$，位于 $(\\theta, \\phi) = (1.605, 0.2)$。\n\n- 案例4（靠近两条径迹的模糊簇，非转换，以及一个低能量的邻近簇）：\n  - 径迹：$(p, q, h, \\theta, \\phi)$ 分别为 $(40, -1, 0.1, 0.70, -1.0)$ 和 $(38, +1, 0.1, 0.74, -1.0)$。\n  - ECAL簇：共享候选簇 $E = 42$ $\\mathrm{GeV}$，位于 $(\\theta, \\phi) = (0.715, -1.0)$；邻近的低能量簇 $E = 5$ $\\mathrm{GeV}$，位于 $(\\theta, \\phi) = (0.76, -1.0)$。\n\n要求的输出格式：您的程序应生成一个单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试案例贡献其重建对象的列表。例如，最外层的列表有四个元素，每个案例一个，每个元素本身也是一个对象列表的列表。能量必须以 $\\mathrm{GeV}$ 为单位，并四舍五入到两位小数。角度必须以 $\\mathrm{radians}$ 为单位。聚合的输出必须是Python风格的列表字面量，例如 $[[[0, E_1], [1, E_2]], [[1, E_3]], [[2, E_4]], [[0, E_5], [1, E_6]]]$，其中所有 $E_k$ 都以 $\\mathrm{GeV}$ 为单位并四舍五入到两位小数。",
            "solution": "问题陈述是有效的。它概述了一个简化但科学上一致的算法流程，用于基于高能物理实验中使用的粒子流（PF）范式进行粒子识别。该问题定义明确，提供了一系列清晰的操作和一套完整的参数与测试数据。其物理原理——如能量动量守恒、电子和光子在探测器中的行为，以及轫致辐射和电子对转换等过程的信号特征——都得到了正确（尽管是简化的）表述。其数学形式是明确的，足以通过算法确定唯一的解。\n\n解决方案通过实现指定的重建步骤序列来执行。该算法的核心是系统性地消耗探测器信号（带电粒子径迹和量能器能量沉积，即簇），以形成具有物理意义的对象（电子和光子）。这个过程是顺序执行的，以解决模糊性，其中像光子转换这样特定的、高纯度的信号会首先被识别。\n\n首先，我们定义几何表示。粒子轨迹或能量簇的位置由球面坐标 $(\\theta, \\phi)$ 给出。为了计算角间距，我们使用标准变换将这些坐标转换为三维笛卡尔单位向量 $\\hat{n}$：\n$$\n\\hat{n}(\\theta,\\phi) = \\left( \\sin\\theta \\cos\\phi,\\; \\sin\\theta \\sin\\phi,\\; \\cos\\theta \\right)\n$$\n由单位向量 $\\hat{u}_1$ 和 $\\hat{u}_2$ 表示的两个方向之间的角距离 $d_{12}$ 由它们点积的反余弦给出，这源于球面余弦定律：\n$$\nd_{12} = \\arccos(\\hat{u}_1 \\cdot \\hat{u}_2)\n$$\n这个距离度量是所有链接和关联步骤的基础。\n\n对每个测试案例，重建逻辑按一系列互斥的步骤执行。对象一旦被分配给一个重建粒子，就会被标记为“已消耗”，以防止其被重复使用。\n\n1.  **光子转换识别**：第一步是寻找光子在探测器材料中转换为电子-正电子对的独特信号。一个高能光子（$E \\gtrsim 2m_e c^2$）与原子核的电磁场相互作用，可以产生一对电荷相反的轻子。在探测器中，这表现为一个ECAL簇，没有从相互作用点指向它的关联径迹，但附近有两条源于同一顶点（该顶点偏离主相互作用点）的、电荷相反的径迹。我们的算法通过寻找一个与两条径迹 $i$ 和 $\\ell$ 在几何上关联的ECAL簇 $j$（即 $d_{ij}, d_{\\ell j} \\le \\Delta R_{\\mathrm{link}} = 0.03$）来模拟这一点。要使这种结构成为一个有效的转换，必须满足三个反映其物理特性的条件：\n    - 径迹必须具有相反的电荷：$q_i \\cdot q_\\ell = -1$。\n    - 径迹之间的张角必须很小，这是由单个高能母粒子产生的粒子对的特征：$\\theta_{i\\ell} = \\arccos(\\hat{u}_i \\cdot \\hat{u}_\\ell) \\le \\theta_{\\mathrm{conv}} = 0.02$ rad。\n    - 径迹必须显示出源于次级顶点的证据，这被简化为对“失踪击中”变量的要求：$h_i, h_\\ell \\ge h_{\\mathrm{conv}} = 0.6$。\n    如果所有条件都满足，则创建一个能量等于簇能量的转换光子，即 $E_{\\gamma}^{\\mathrm{conv}} = E_j$。其组成的径迹和簇随后被标记为已消耗。\n\n2.  **电子识别**：在搜索转换之后，算法尝试从剩余的未消耗径迹和簇中识别电子。电子是一种带电粒子，将其大部分能量沉积在ECAL中。这通过将径迹 $i$ 与一个主ECAL簇 $j^\\star$ 关联来建模。主簇是从所有与该径迹关联的未消耗簇（$d_{ij} \\le \\Delta R_{\\mathrm{link}}$）中选择的角距离 $d_{ij}$ 最小的那个。如果一个径迹的主簇能量是该径迹动量的很大一部分，满足 $E_{j^\\star} \\ge \\alpha \\, p_i$（阈值因子 $\\alpha = 0.5$），则该径迹被确认为电子。如果一条径迹被识别为电子，它及其主簇 $j^\\star$ 将被消耗。此步骤对所有径迹顺序执行；第一条声明一个簇的径迹会消耗它，使其对其他径迹不可用。\n\n3.  **轫致辐射簇关联**：电子穿过材料时会通过称为轫致辐射的过程辐射光子。这些光子几乎与电子同向传播，并将其能量沉积在ECAL中，通常形成靠近电子主撞击点的独立簇。该算法通过搜索已识别电子径迹 $i$ 附近的其他未消耗簇 $k$ 来解释这一点。如果一个簇 $k$ 满足以下条件，它被认为是轫致辐射光子并与电子合并：\n    - 它位于电子径迹周围一个较大的锥体内：$d_{ik} \\le \\Delta R_{\\mathrm{brem}} = 0.05$ rad。\n    - 为解决一个簇靠近多条径迹时的模糊性，电子径迹 $i$ 必须是所有径迹中离该簇 $k$ 最近的。\n    任何此类关联的轫致辐射簇的能量都会加到电子的能量上：$E_e = E_{j^\\star} + \\sum_{k \\in \\mathcal{B}_i} E_k$，其中 $\\mathcal{B}_i$ 是与径迹 $i$ 关联的轫致辐射簇的集合。这些合并的簇随后被消耗。\n\n4.  **未转换光子识别**：最后，任何在前述步骤中未被消耗的ECAL簇——即它既不是转换的一部分，也不是电子的主簇或轫致辐射簇——都被解释为未转换光子。这假设任何未与带电粒子径迹关联的ECAL显著能量沉积都可能来自主相互作用产生的光子。对于每个这样的剩余簇 $j$，创建一个能量为 $E_\\gamma = E_j$ 的未转换光子对象。\n\n这个完整的序列确保每个簇和径迹都按一个合乎逻辑、有物理动机的顺序被考虑，以产生一个最终的、排他性的重建电子和光子列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a simplified Particle Flow (PF) categorization for electrons and photons.\n    The function processes a fixed test suite of four cases and prints the aggregated results.\n    \"\"\"\n    \n    # --- Constants from the problem statement ---\n    DELTA_R_LINK = 0.03\n    THETA_CONV = 0.02\n    H_CONV = 0.6\n    ALPHA = 0.5\n    DELTA_R_BREM = 0.05\n    \n    # --- Object codes ---\n    ELECTRON_CODE = 0\n    UNCONVERTED_PHOTON_CODE = 1\n    CONVERTED_PHOTON_CODE = 2\n\n    # --- Test Suite Data ---\n    test_cases = [\n        {\n            \"tracks\": [\n                {\"p\": 50, \"q\": -1, \"h\": 0.1, \"theta\": 1.2, \"phi\": 0.1}\n            ],\n            \"clusters\": [\n                {\"E\": 45, \"theta\": 1.21, \"phi\": 0.1},\n                {\"E\": 8, \"theta\": 1.23, \"phi\": 0.1},\n                {\"E\": 20, \"theta\": 0.3, \"phi\": 2.0}\n            ]\n        },\n        {\n            \"tracks\": [\n                {\"p\": 20, \"q\": +1, \"h\": 0.1, \"theta\": 1.0, \"phi\": 0.5}\n            ],\n            \"clusters\": [\n                {\"E\": 20, \"theta\": 1.032, \"phi\": 0.5}\n            ]\n        },\n        {\n            \"tracks\": [\n                {\"p\": 15, \"q\": +1, \"h\": 0.7, \"theta\": 1.60, \"phi\": 0.2},\n                {\"p\": 14, \"q\": -1, \"h\": 0.7, \"theta\": 1.61, \"phi\": 0.2}\n            ],\n            \"clusters\": [\n                {\"E\": 29, \"theta\": 1.605, \"phi\": 0.2}\n            ]\n        },\n        {\n            \"tracks\": [\n                {\"p\": 40, \"q\": -1, \"h\": 0.1, \"theta\": 0.70, \"phi\": -1.0},\n                {\"p\": 38, \"q\": +1, \"h\": 0.1, \"theta\": 0.74, \"phi\": -1.0}\n            ],\n            \"clusters\": [\n                {\"E\": 42, \"theta\": 0.715, \"phi\": -1.0},\n                {\"E\": 5, \"theta\": 0.76, \"phi\": -1.0}\n            ]\n        }\n    ]\n\n    def unit_vector(theta, phi):\n        \"\"\"Computes the Cartesian unit vector from spherical coordinates.\"\"\"\n        return np.array([\n            np.sin(theta) * np.cos(phi),\n            np.sin(theta) * np.sin(phi),\n            np.cos(theta)\n        ])\n\n    def angular_distance(v1, v2):\n        \"\"\"Computes the angular distance between two unit vectors.\"\"\"\n        dot_product = np.clip(np.dot(v1, v2), -1.0, 1.0)\n        return np.arccos(dot_product)\n\n    def process_case(tracks_data, clusters_data):\n        \"\"\"Applies the PF algorithm to a single case.\"\"\"\n        \n        # Initialize objects with unique IDs and consumed flags\n        tracks = [dict(t, id=i, consumed=False, vec=unit_vector(t['theta'], t['phi'])) for i, t in enumerate(tracks_data)]\n        clusters = [dict(c, id=i, consumed=False, vec=unit_vector(c['theta'], c['phi'])) for i, c in enumerate(clusters_data)]\n        \n        reco_particles = []\n\n        # 1. Conversion Identification\n        # Use a copy of cluster list to allow modification while iterating\n        for j, cluster in enumerate(clusters):\n            if cluster['consumed']:\n                continue\n            \n            linked_tracks = []\n            for i, track in enumerate(tracks):\n                if not track['consumed']:\n                    dist = angular_distance(track['vec'], cluster['vec'])\n                    if dist = DELTA_R_LINK:\n                        linked_tracks.append(track)\n            \n            if len(linked_tracks) >= 2:\n                # Find the first valid conversion pair\n                found_conversion = False\n                for i1 in range(len(linked_tracks)):\n                    for i2 in range(i1 + 1, len(linked_tracks)):\n                        t1 = linked_tracks[i1]\n                        t2 = linked_tracks[i2]\n                        \n                        if t1['q'] * t2['q'] == -1 and \\\n                           angular_distance(t1['vec'], t2['vec']) = THETA_CONV and \\\n                           t1['h'] >= H_CONV and t2['h'] >= H_CONV:\n                            \n                            energy = round(cluster['E'], 2)\n                            reco_particles.append([CONVERTED_PHOTON_CODE, energy])\n                            \n                            cluster['consumed'] = True\n                            t1['consumed'] = True\n                            t2['consumed'] = True\n                            found_conversion = True\n                            break\n                    if found_conversion:\n                        break\n\n        # 2. Electron Identification and 4. Bremsstrahlung Association\n        identified_electrons = []\n        for track in tracks:\n            if track['consumed']:\n                continue\n\n            # Find primary cluster\n            best_cluster = None\n            min_dist = float('inf')\n            \n            linked_unconsumed_clusters = []\n            for cluster in clusters:\n                if not cluster['consumed']:\n                    dist = angular_distance(track['vec'], cluster['vec'])\n                    if dist = DELTA_R_LINK:\n                        linked_unconsumed_clusters.append((dist, cluster))\n            \n            if not linked_unconsumed_clusters:\n                continue\n\n            min_dist, best_cluster = min(linked_unconsumed_clusters, key=lambda x: x[0])\n\n            # Electron check\n            if best_cluster['E'] >= ALPHA * track['p']:\n                track['consumed'] = True\n                best_cluster['consumed'] = True\n                electron_energy = best_cluster['E']\n                # identified_electrons will store electron track and its growing energy\n                identified_electrons.append({'track': track, 'energy': electron_energy})\n        \n        # Now handle bremsstrahlung for the identified electrons\n        for electron in identified_electrons:\n            electron_track = electron['track']\n            \n            brem_clusters_to_add = []\n            for cluster in clusters:\n                if cluster['consumed']:\n                    continue\n                \n                dist_to_electron = angular_distance(electron_track['vec'], cluster['vec'])\n                if dist_to_electron = DELTA_R_BREM:\n                    # Check if this electron track is the closest track to the cluster\n                    closest_track_dist = float('inf')\n                    closest_track = None\n                    for any_track in tracks:\n                        d = angular_distance(any_track['vec'], cluster['vec'])\n                        if d  closest_track_dist:\n                            closest_track_dist = d\n                            closest_track = any_track\n                    \n                    if closest_track['id'] == electron_track['id']:\n                        brem_clusters_to_add.append(cluster)\n            \n            for brem_cluster in brem_clusters_to_add:\n                electron['energy'] += brem_cluster['E']\n                brem_cluster['consumed'] = True\n            \n            energy = round(electron['energy'], 2)\n            reco_particles.append([ELECTRON_CODE, energy])\n\n        # 5. Unconverted Photon Creation\n        for cluster in clusters:\n            if not cluster['consumed']:\n                energy = round(cluster['E'], 2)\n                reco_particles.append([UNCONVERTED_PHOTON_CODE, energy])\n\n        return reco_particles\n\n    # --- Main Execution Loop ---\n    all_results = []\n    for case in test_cases:\n        result = process_case(case['tracks'], case['clusters'])\n        all_results.append(result)\n\n    # Format output as a single-line Python-style list literal string\n    # E.g., [[[0, 53.0], [1, 20.0]], [[1, 20.0]], ...]\n    # str() adds spaces, so we remove them.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}