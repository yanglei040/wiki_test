{
    "hands_on_practices": [
        {
            "introduction": "精确测量带电粒子的动量是重建过程的第一步，也是最关键的一步。本练习将引导你从基本物理原理（洛伦兹力）和几何学出发，推导探测器对粒子横动量 $p_T$ 的测量分辨率。通过这个推导，你将深刻理解动量分辨率如何依赖于探测器的关键设计参数，如磁场强度 $B$ 和测量臂长 $L$，这对于评估和设计径迹探测器至关重要 ()。",
            "id": "3520912",
            "problem": "在高能对撞机探测器中，缪子在弯曲平面内的横向动量重建依赖于测量由洛伦兹力在磁场中产生的径迹曲率。考虑一个电荷大小为 $|q|$、横向动量为 $p_T$ 的带电粒子，穿过一个磁场区域，该区域内垂直于径迹的磁场分量的径迹平均值近似为 $B$。两个外部精确测量站之间的径迹段可近似为弯曲平面内的一个圆弧，其半径为 $R$，对应的弦长为 $L$。使用一个中间精确测量站来测量圆弧与弦之间的最大偏离，即矢高 $s$。假设在小偏转极限下，$L \\ll R$。\n\n可作为起点的基本关系式是：\n- 横向平面内洛伦兹力与向心力的平衡意味着 $p_T$、$B$、$R$ 和 $|q|$ 之间存在一个关系。\n- 对于半径为 $R$、弦长为 $L$ 的圆弧，其精确的几何矢高为 $s = R - \\sqrt{R^2 - (L/2)^2}$。\n\n假设由于径迹探测器的有限空间分辨率，矢高测量存在一个统计不确定度 $\\sigma_s$；此外，谱仪的对准贡献了一个独立的、与配置相关的稳定矢高不确定度 $\\sigma_a$（假设与 $\\sigma_s$ 不相关）。这两个不确定度都被视为高斯分布且独立的，因此它们以平方和再开方的方式相加。在整个推导过程中，使用高能物理中的实用单位约定 $p_T \\, [\\mathrm{GeV}] = c_B \\, |q| \\, B \\, [\\mathrm{T}] \\, R \\, [\\mathrm{m}]$，其中 $c_B \\approx 0.3$。并且，令 $B$ 代表在螺线管谱仪或环形谱仪中与弯曲相关的径迹平均垂直磁场。\n\n仅从给定的基本关系和近似出发，推导出一个关于相对横向动量分辨率 $\\sigma_{p_T}/p_T$ 的闭式解析表达式。该分辨率由矢高测量不确定度和对准不确定度共同引起，并用 $p_T$、$B$、$L$、$|q|$、$c_B$、$\\sigma_s$ 和 $\\sigma_a$ 表示。你的最终表达式必须明确显示出与 $L$ 和 $B$ 的标度关系。请以单个闭式表达式的形式给出你的最终答案。最终答案是无量纲的；不需要进行数值计算，最终的方框答案中不应包含任何单位。",
            "solution": "该问题的原理经核实具有科学依据、问题设定合理且客观。该问题描述了高能物理中重建带电粒子动量的标准情景。我们将开始推导。\n\n起点是所提供的两个基本关系式。首先，对于电荷大小为 $|q|$ 的粒子，其横向动量 $p_T$、磁场 $B$ 和曲率半径 $R$ 之间的关系是：\n$$p_T = c_B |q| B R$$\n此处，$c_B$ 是一个比例常数，用于处理问题中指定的单位转换，约等于 $0.3$。\n\n其次，矢高 $s$、曲率半径 $R$ 和弦长 $L$ 之间的精确几何关系是：\n$$s = R - \\sqrt{R^2 - \\left(\\frac{L}{2}\\right)^2}$$\n\n问题规定使用小偏转极限，即 $L \\ll R$。我们可以利用这个条件来找到矢高 $s$ 的一个简化近似表达式。我们从平方根项中提出因子 $R$：\n$$s = R - R \\sqrt{1 - \\frac{L^2}{4R^2}}$$\n由于 $L \\ll R$，项 $\\frac{L^2}{4R^2}$ 远小于 $1$。因此，对于小的 $x$，我们可以使用二项式近似来处理平方根，即 $\\sqrt{1-x} \\approx 1 - \\frac{x}{2}$。令 $x = \\frac{L^2}{4R^2}$，我们得到：\n$$s \\approx R - R \\left(1 - \\frac{1}{2} \\frac{L^2}{4R^2}\\right) = R - \\left(R - \\frac{RL^2}{8R^2}\\right) = \\frac{L^2}{8R}$$\n这就给出了矢高著名的近似关系式：\n$$s \\approx \\frac{L^2}{8R}$$\n\n我们的目标是求相对动量分辨率 $\\frac{\\sigma_{p_T}}{p_T}$。为此，我们必须首先用测量量，即矢高 $s$，来表示 $p_T$。根据矢高的近似公式，我们可以将曲率半径 $R$ 表示为：\n$$R \\approx \\frac{L^2}{8s}$$\n将这个 $R$ 的表达式代入动量方程，得到：\n$$p_T \\approx c_B |q| B \\left(\\frac{L^2}{8s}\\right) = \\frac{c_B |q| B L^2}{8s}$$\n\n现在我们可以确定由 $s$ 的测量不确定度引起的 $p_T$ 的不确定度。问题指出，总的矢高不确定度是统计不确定度 $\\sigma_s$ 和对准不确定度 $\\sigma_a$ 的平方和再开方，这两者是独立的。设总矢高不确定度为 $\\sigma_{s, \\text{tot}}$。\n$$\\sigma_{s, \\text{tot}}^2 = \\sigma_s^2 + \\sigma_a^2 \\implies \\sigma_{s, \\text{tot}} = \\sqrt{\\sigma_s^2 + \\sigma_a^2}$$\n\n为了求出 $p_T$ 的不确定度，我们使用标准误差传播方法。在此推导中，$c_B$、|q|、$B$ 和 $L$ 被视为没有不确定度的已知常数。动量 $p_T$ 是单个不确定变量 $s$ 的函数。\n$$p_T(s) = \\left(\\frac{c_B |q| B L^2}{8}\\right) s^{-1}$$\n不确定度 $\\sigma_{p_T}$ 通过以下方式与不确定度 $\\sigma_{s, \\text{tot}}$ 相关联：\n$$\\sigma_{p_T} = \\left|\\frac{dp_T}{ds}\\right| \\sigma_{s, \\text{tot}}$$\n我们计算 $p_T$ 对 $s$ 的导数：\n$$\\frac{dp_T}{ds} = \\frac{d}{ds} \\left(\\frac{c_B |q| B L^2}{8s}\\right) = -\\frac{c_B |q| B L^2}{8s^2}$$\n我们可以用 $p_T$ 本身来重新表达这个导数：\n$$\\frac{dp_T}{ds} = -\\frac{1}{s} \\left(\\frac{c_B |q| B L^2}{8s}\\right) = -\\frac{p_T}{s}$$\n因此，导数的绝对值为：\n$$\\left|\\frac{dp_T}{ds}\\right| = \\frac{p_T}{s}$$\n将此代入误差传播公式，得到：\n$$\\sigma_{p_T} = \\frac{p_T}{s} \\sigma_{s, \\text{tot}}$$\n于是，相对横向动量分辨率为：\n$$\\frac{\\sigma_{p_T}}{p_T} = \\frac{\\sigma_{s, \\text{tot}}}{s} = \\frac{\\sqrt{\\sigma_s^2 + \\sigma_a^2}}{s}$$\n\n最后一步是用指定的自变量来表示这个结果，这些变量包括 $p_T$ 但不包括 $s$。我们使用前面导出的关系式 $p_T \\approx \\frac{c_B |q| B L^2}{8s}$ 来消去 $s$：\n$$s \\approx \\frac{c_B |q| B L^2}{8 p_T}$$\n将这个 $s$ 的表达式代入我们的相对分辨率方程中：\n$$\\frac{\\sigma_{p_T}}{p_T} = \\frac{\\sqrt{\\sigma_s^2 + \\sigma_a^2}}{\\frac{c_B |q| B L^2}{8 p_T}}$$\n简化该表达式，得到相对横向动量分辨率的最终闭式结果：\n$$\\frac{\\sigma_{p_T}}{p_T} = \\frac{8 p_T \\sqrt{\\sigma_s^2 + \\sigma_a^2}}{c_B |q| B L^2}$$\n该表达式明确地显示了动量分辨率随横向动量 $p_T$、磁场 $B$ 和弦长 $L$ 的标度关系。具体来说，分辨率随 $p_T$ 的增加而线性变差，随磁场增强（$B^{-1}$）和杠杆臂增长（$L^{-2}$）而二次改善。",
            "answer": "$$\\boxed{\\frac{8 p_T \\sqrt{\\sigma_s^2 + \\sigma_a^2}}{c_B |q| B L^2}}$$"
        },
        {
            "introduction": "在重建出一条候选径迹后，我们必须评估其质量并剔除由高堆积（pileup）环境产生的伪径迹。本练习模拟了这一关键的“质量控制”步骤，要求你使用 $\\chi^2$ 统计量来量化径迹的拟合优度。更进一步，你将设计并实现一套依赖于堆积参数的真实筛选标准，从而在实践中学习如何区分来自真实轻子的径迹和由无关探测器信号随机组合而成的“赝品” ()。",
            "id": "3520905",
            "problem": "在高能物理探测器中重建的带电轻子候选者与一组径迹击中点相关联。在每次束团穿越存在额外质子-质子相互作用（称为堆积效应，PU）的情况下，有不可忽略的一部分伪径迹是由击中点的随机组合产生的。为了以计算上可复现的方式量化径迹拟合质量并剔除伪径迹，请使用以下基本原理：在线性化测量模型下，假设击中误差是独立的高斯分布，最优径迹拟合的残差向量 $\\mathbf{r} \\in \\mathbb{R}^N$ 服从一个多元正态概率密度函数（PDF），其协方差矩阵 $\\mathbf{V} \\in \\mathbb{R}^{N \\times N}$ 是对称正定的，而经典的拟合优度似然比检验统计量简化为一个自由度（DoF）为 $\\nu = N - k$ 的卡方随机变量，其中 $k$ 是拟合所估计的自由径迹参数的数量。观测到至少与测量值一样差的拟合质量的概率是卡方分布的上尾概率（生存函数）。\n\n您的任务是：\n- 对于每个测试用例，使用提供的残差和协方差矩阵，计算径迹拟合的卡方统计量以及在卡方分布下相应的拟合质量上尾概率。残差单位为毫米（mm），协方差矩阵条目单位为平方毫米（$\\text{mm}^2$）。计算出的卡方值和概率是无量纲的；请将它们表示为不带单位的纯数字。\n- 设计并实现一个数学上合理的径迹接受准则，以剔除由堆积效应产生的伪径迹。该准则必须随着堆积效应参数 $\\mu$ 的增加而收紧，方法是同时要求：(i) 通过一个随 $\\mu$ 单调递减的最小 $p$ 值阈值 $t_p(\\mu)$ 来表达更强的拟合优度，(ii) 对每个自由度的归一化卡方值施加一个随 $\\mu$ 单调递减的上限 $t_{\\chi}(\\mu)$，以及 (iii) 要求与主顶点（PV）关联的击中点所占的最小比例 $f_{\\text{PV}}$ 随 $\\mu$ 单调递增并在 $1$ 处饱和。在您的实现中使用以下固定常量：$t_0 = 0.05$, $t_{\\chi,0} = 3.0$, $f_0 = 0.6$, $\\lambda = 0.01$, $\\kappa = 0.01$, $s = 0.01$。定义 $t_p(\\mu) = t_0 \\exp(-\\lambda \\mu)$, $t_{\\chi}(\\mu) = t_{\\chi,0} \\exp(-\\kappa \\mu)$, 以及 $t_f(\\mu) = \\min\\!\\big(1, f_0 + s \\mu\\big)$。一条径迹被接受当且仅当 $p \\ge t_p(\\mu)$ 且 $(\\chi^2/\\nu) \\le t_{\\chi}(\\mu)$ 且 $f_{\\text{PV}} \\ge t_f(\\mu)$，其中 $f_{\\text{PV}} = n_{\\text{PV}}/N$，$n_{\\text{PV}}$ 是与主顶点关联的击中点数量。\n\n物理和数值单位：\n- 残差必须被视为毫米（mm）。\n- 协方差条目必须被视为平方毫米（$\\text{mm}^2$）。\n- 输出 $\\chi^2$、$p$ 和 $\\chi^2/\\nu$ 是无量纲的；请将它们表示为纯数字，并根据您编程语言的默认行为进行四舍五入。\n\n测试套件：\n- 用例 1（理想路径，中等堆积效应）：\n  - $N = 5$，$\\mathbf{r} = [\\,0.02,\\,-0.01,\\,0.015,\\,-0.005,\\,0.01\\,]$ mm，\n  - $\\mathbf{V} = \\begin{pmatrix}\n  0.0009  0.00001  0  0  0\\\\\n  0.00001  0.0009  0.00001  0  0\\\\\n  0  0.00001  0.0009  0.00001  0\\\\\n  0  0  0.00001  0.0009  0.00001\\\\\n  0  0  0  0.00001  0.0009\n  \\end{pmatrix}$ $\\text{mm}^2$，$k = 3$，$\\mu = 20$，$n_{\\text{PV}} = 4$。\n- 用例 2（明确的伪径迹，高堆积效应）：\n  - $N = 6$，$\\mathbf{r} = [\\,0.12,\\,-0.15,\\,0.10,\\,-0.20,\\,0.18,\\,0.16\\,]$ mm，\n  - $\\mathbf{V} = \\begin{pmatrix}\n  0.0004  0.000005  0  0  0  0\\\\\n  0.000005  0.0004  0.000005  0  0  0\\\\\n  0  0.000005  0.0004  0.000005  0  0\\\\\n  0  0  0.000005  0.0004  0.000005  0\\\\\n  0  0  0  0.000005  0.0004  0.000005\\\\\n  0  0  0  0  0.000005  0.0004\n  \\end{pmatrix}$ $\\text{mm}^2$，$k = 4$，$\\mu = 60$，$n_{\\text{PV}} = 1$。\n- 用例 3（临界拟合，低堆积效应）：\n  - $N = 5$，$\\mathbf{r} = [\\,0.04,\\,-0.03,\\,0.05,\\,-0.02,\\,0.04\\,]$ mm，\n  - $\\mathbf{V} = \\begin{pmatrix}\n  0.0009  0.00001  0  0  0\\\\\n  0.00001  0.0009  0.00001  0  0\\\\\n  0  0.00001  0.0009  0.00001  0\\\\\n  0  0  0.00001  0.0009  0.00001\\\\\n  0  0  0  0.00001  0.0009\n  \\end{pmatrix}$ $\\text{mm}^2$，$k = 3$，$\\mu = 5$，$n_{\\text{PV}} = 3$。\n- 用例 4（边界情况，完美拟合残差）：\n  - $N = 4$，$\\mathbf{r} = [\\,0.0,\\,0.0,\\,0.0,\\,0.0\\,]$ mm，\n  - $\\mathbf{V} = \\begin{pmatrix}\n  0.0004  0.000002  0  0\\\\\n  0.000002  0.0004  0.000002  0\\\\\n  0  0.000002  0.0004  0.000002\\\\\n  0  0  0.000002  0.0004\n  \\end{pmatrix}$ $\\text{mm}^2$，$k = 3$，$\\mu = 40$，$n_{\\text{PV}} = 4$。\n\n程序输出规范：\n- 对于每个测试用例，您的程序必须计算并返回一个列表 $[\\,\\chi^2,\\,p,\\,\\chi^2/\\nu,\\,\\text{accepted}\\,]$，其中 $\\chi^2$ 是卡方值，$p$ 是卡方分布下的上尾概率，$\\chi^2/\\nu$ 是每个自由度的归一化卡方值，$\\text{accepted}$ 是一个布尔值，表示该径迹是否通过了考虑堆积效应的准则。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[\\,\\text{result}_1,\\,\\text{result}_2,\\,\\text{result}_3,\\,\\text{result}_4\\,]$，其中每个 $\\text{result}_i$ 是对应测试用例的列表。不应打印任何额外文本。",
            "solution": "该问题是有效的。所有提供的数据和定义都具有科学依据、一致，并且足以形成唯一的解决方案。\n\n任务是评估一组来自高能物理实验的带电轻子径迹候选者。对每个候选者，这涉及两个主要步骤：首先，计算拟合优度统计量；其次，应用一组依赖于堆积效应的准则来决定是接受还是拒绝该径迹。\n\n### 1. 径迹拟合质量评估\n径迹拟合的质量使用 $\\chi^2$（卡方）统计量来量化。该统计量测量了测量的击中点位置与拟合的径迹轨迹预测的位置之间的差异，同时考虑了测量不确定性。\n\n**卡方统计量 ($\\chi^2$)**\n\n在假设径迹模型是线性的且 $N$ 个击中点的误差是独立高斯分布的情况下，残差向量 $\\mathbf{r} \\in \\mathbb{R}^N$（测量和预测的击中点坐标之差）遵循一个多元正态分布。这些残差的协方差矩阵为 $\\mathbf{V} \\in \\mathbb{R}^{N \\times N}$。\n\n$\\chi^2$ 统计量由以下二次型定义：\n$$\n\\chi^2 = \\mathbf{r}^T \\mathbf{V}^{-1} \\mathbf{r}\n$$\n其中 $\\mathbf{r}$ 是残差的列向量（单位为毫米，mm），$\\mathbf{V}$ 是对称正定协方差矩阵（单位为 $\\text{mm}^2$），$\\mathbf{V}^{-1}$ 是其逆矩阵。该乘积在量纲上是一致的：$(\\text{mm}) \\cdot (\\text{mm}^{-2}) \\cdot (\\text{mm})$，得到一个无量纲的 $\\chi^2$ 值。计算需要求协方差矩阵 $\\mathbf{V}$ 的逆。\n\n**自由度 ($\\nu$) 和 $p$ 值**\n\n$\\chi^2$ 统计量遵循卡方概率分布。该分布的自由度（DoF）$\\nu$ 由下式给出：\n$$\n\\nu = N - k\n$$\n其中 $N$ 是击中点的数量（即 $\\mathbf{r}$ 的维度），$k$ 是径迹拟合中估计的参数数量（例如，位置、动量分量）。对于所有测试用例，$\\nu  0$。\n\n拟合优度通常表示为 $p$ 值。$p$ 值是在假设径迹假说正确的情况下，观测到大于或等于从数据计算出的 $\\chi^2$ 值的概率。一个非常小的 $p$ 值表明，在给定模型下观测到的数据是不太可能出现的，这表示拟合效果很差。$p$ 值计算为具有 $\\nu$ 自由度的 $\\chi^2$ 分布的生存函数（1 减去累积分布函数）：\n$$\np = P(\\chi^2_{\\nu} \\ge \\chi^2_{\\text{observed}}) = \\int_{\\chi^2_{\\text{observed}}}^{\\infty} f(x; \\nu) dx\n$$\n其中 $f(x; \\nu)$ 是具有 $\\nu$ 自由度的卡方分布的概率密度函数。\n\n### 2. 依赖于堆积效应的选择准则\n为了区分源于堆積效應（额外的质子-质子相互作用）的真实径迹和伪径迹，应用了一套选择准则。这些准则随着平均堆积相互作用数 $\\mu$ 的增加而变得更加严格。一条径迹被接受当且仅当以下所有三个条件都得到满足：\n\n**条件 1：$p$ 值阈值**\n径迹的 $p$ 值必须大于或等于一个依赖于堆积效应的阈值 $t_p(\\mu)$：\n$$\np \\ge t_p(\\mu) \\quad \\text{其中} \\quad t_p(\\mu) = t_0 \\exp(-\\lambda \\mu)\n$$\n给定的常量为 $t_0 = 0.05$ 和 $\\lambda = 0.01$。随着 $\\mu$ 的增加，该阈值降低，使得这个特定的截断条件变得更为宽松。这可能是为了在真实径迹的拟合质量在高堆积环境中可能略有下降时，仍能保持其效率。\n\n**条件 2：归一化卡方阈值**\n归一化卡方值 $\\chi^2/\\nu$（代表每个自由度对 $\\chi^2$ 的平均贡献）必须低于一个依赖于堆积效应的阈值 $t_{\\chi}(\\mu)$：\n$$\n\\frac{\\chi^2}{\\nu} \\le t_{\\chi}(\\mu) \\quad \\text{其中} \\quad t_{\\chi}(\\mu) = t_{\\chi,0} \\exp(-\\kappa \\mu)\n$$\n给定的常量为 $t_{\\chi,0} = 3.0$ 和 $\\kappa = 0.01$。随着 $\\mu$ 的增加，该阈值降低，使得截断条件更加严格，要求更高质量的拟合。\n\n**条件 3：主顶点击中点比例**\n径迹上与主相互作用顶点（PV）关联的击中点比例 $f_{\\text{PV}}$ 必须高于一个依赖于堆积效应的阈值 $t_f(\\mu)$：\n$$\nf_{\\text{PV}} \\ge t_f(\\mu) \\quad \\text{其中} \\quad f_{\\text{PV}} = \\frac{n_{\\text{PV}}}{N} \\quad \\text{且} \\quad t_f(\\mu) = \\min(1, f_0 + s \\mu)\n$$\n其中 $n_{\\text{PV}}$ 是来自主顶点的击中点数。给定的常量为 $f_0 = 0.6$ 和 $s = 0.01$。随着 $\\mu$ 的增加，该阈值增加（在 1 处饱和），使得截断条件更加严格。这能有效地剔除堆积径迹，因为预计这些径迹很少或没有源自主要碰撞顶点的击中点。\n\n由于这些准则的综合效应，总体选择随着 $\\mu$ 的增加而收紧，这主要是由归一化 $\\chi^2$ 和主顶点击中点比例截断的收紧所驱动的。\n\n### 3. 测试用例的计算\n对于每个测试用例，按顺序计算以下量：\n1.  自由度 $\\nu = N - k$。\n2.  通过对 $\\mathbf{V}$ 求逆并计算 $\\mathbf{r}^T \\mathbf{V}^{-1} \\mathbf{r}$ 来得到 $\\chi^2$ 统计量。\n3.  使用 $\\chi^2$ 分布的生存函数计算 $p$ 值。\n4.  归一化卡方值 $\\chi^2/\\nu$。\n5.  依赖于堆积效应的阈值 $t_p(\\mu)$、$t_{\\chi}(\\mu)$ 和 $t_f(\\mu)$。\n6.  主顶点击中点比例 $f_{\\text{PV}}$。\n7.  基于三个条件的最终布尔接受决策。\n\n每个用例的结果被收集并以所需的列表的列表格式呈现。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the track-fit validation problem for all test cases.\n    \"\"\"\n    # Define the fixed constants for the selection criteria.\n    t0 = 0.05\n    t_chi0 = 3.0\n    f0 = 0.6\n    lambda_ = 0.01  # Use lambda_ to avoid conflict with Python's lambda keyword.\n    kappa = 0.01\n    s = 0.01\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, moderate pileup)\n        {\n            'N': 5,\n            'r': [0.02, -0.01, 0.015, -0.005, 0.01],\n            'V': [\n                [0.0009, 0.00001, 0, 0, 0],\n                [0.00001, 0.0009, 0.00001, 0, 0],\n                [0, 0.00001, 0.0009, 0.00001, 0],\n                [0, 0, 0.00001, 0.0009, 0.00001],\n                [0, 0, 0, 0.00001, 0.0009]\n            ],\n            'k': 3, 'mu': 20, 'n_pv': 4\n        },\n        # Case 2 (clear fake, high pileup)\n        {\n            'N': 6,\n            'r': [0.12, -0.15, 0.10, -0.20, 0.18, 0.16],\n            'V': [\n                [0.0004, 0.000005, 0, 0, 0, 0],\n                [0.000005, 0.0004, 0.000005, 0, 0, 0],\n                [0, 0.000005, 0.0004, 0.000005, 0, 0],\n                [0, 0, 0.000005, 0.0004, 0.000005, 0],\n                [0, 0, 0, 0.000005, 0.0004, 0.000005],\n                [0, 0, 0, 0, 0.000005, 0.0004]\n            ],\n            'k': 4, 'mu': 60, 'n_pv': 1\n        },\n        # Case 3 (borderline fit, low pileup)\n        {\n            'N': 5,\n            'r': [0.04, -0.03, 0.05, -0.02, 0.04],\n            'V': [\n                [0.0009, 0.00001, 0, 0, 0],\n                [0.00001, 0.0009, 0.00001, 0, 0],\n                [0, 0.00001, 0.0009, 0.00001, 0],\n                [0, 0, 0.00001, 0.0009, 0.00001],\n                [0, 0, 0, 0.00001, 0.0009]\n            ],\n            'k': 3, 'mu': 5, 'n_pv': 3\n        },\n        # Case 4 (edge case, perfect fit residuals)\n        {\n            'N': 4,\n            'r': [0.0, 0.0, 0.0, 0.0],\n            'V': [\n                [0.0004, 0.000002, 0, 0],\n                [0.000002, 0.0004, 0.000002, 0],\n                [0, 0.000002, 0.0004, 0.000002],\n                [0, 0, 0.000002, 0.0004]\n            ],\n            'k': 3, 'mu': 40, 'n_pv': 4\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N = case['N']\n        r = np.array(case['r'])\n        V = np.array(case['V'])\n        k = case['k']\n        mu = case['mu']\n        n_pv = case['n_pv']\n        \n        # 1. Compute chi-squared statistic\n        V_inv = np.linalg.inv(V)\n        chi2_val = r.T @ V_inv @ r\n        \n        # 2. Compute degrees of freedom, p-value, and normalized chi-squared\n        nu = N - k\n        p_val = chi2.sf(chi2_val, nu)  # Survival function (1 - CDF)\n        chi2_norm = chi2_val / nu if nu  0 else np.inf\n\n        # 3. Compute pileup-dependent thresholds\n        t_p = t0 * np.exp(-lambda_ * mu)\n        t_chi = t_chi0 * np.exp(-kappa * mu)\n        t_f = min(1.0, f0 + s * mu)\n        \n        # 4. Compute PV hit fraction\n        f_pv = n_pv / N\n        \n        # 5. Apply acceptance criteria\n        cond1 = p_val = t_p\n        cond2 = chi2_norm = t_chi\n        cond3 = f_pv = t_f\n        \n        accepted = cond1 and cond2 and cond3\n        \n        all_results.append([chi2_val, p_val, chi2_norm, accepted])\n\n    # Final print statement in the exact required format.\n    # The `str()` of a list produces spaces, e.g., '[1, 2]'.\n    # Joining these string representations produces the specified output format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "重建的最后阶段是将来自不同子探测器的信息综合起来，形成对物理对象的完整描述。本练习将指导你实现一个简化的粒子流（Particle Flow, PF）算法，这是一个现代高能物理实验中用于全局事件重建的核心思想。你将学习如何智能地连接径迹与电磁量能器中的能量簇，以构建最终的电子和光子对象，并正确处理如轫致辐射和光子转换等关键物理过程 ()。",
            "id": "3520857",
            "problem": "您必须用代码实现一个简化的、但科学上一致的粒子流 (PF) 分类方法，用于在轻子和光子重建与识别的背景下对电子和光子进行分类。从基本的物理和算法基础出发，推导出用于将带电粒子径迹与电磁量能器 (ECAL) 簇关联、识别轫致辐射光子、识别光子转换以及编码对象创建和合并的决策规则。程序必须处理一个固定的测试套件，并生成一个聚合结果的单行输出。\n\n基本依据如下。使用能量动量守恒和方向性：如果一个带电轻子（电子）发射轫致辐射，发射出的光子方向近似沿着电子的轨迹。设 $\\vec{p}$ 表示动量，$E$ 表示能量，$\\hat{u}$ 为径迹的单位方向矢量，$\\hat{n}$ 为 ECAL 簇的单位方向矢量。对于小角度，径迹与簇之间的角间距可由张角 $\\theta = \\arccos(\\hat{u} \\cdot \\hat{n})$ 近似，这在中心区域与通常的 $\\Delta R$ 度量一致。材料中的光子转换会产生两条电荷相反、张角很小的径迹，其初始段有内部探测器失踪击中；它们的合成方向指向 ECAL 的能量沉积。电子主要将其能量沉积在 ECAL 中；轫致辐射光子沿着电子的路径发射，并被附近的 ECAL 簇捕获。\n\n实现以下数学上定义的决策规则。\n\n1. 径迹-簇角距离：对于每条径迹 $i$ 和每个簇 $j$，计算\n$$\nd_{ij} = \\arccos\\!\\left( \\hat{u}_i \\cdot \\hat{n}_j \\right).\n$$\n当 $d_{ij} \\le \\Delta R_{\\mathrm{link}}$（其中 $\\Delta R_{\\mathrm{link}} = 0.03$ $\\mathrm{rad}$）时，一条径迹和一个簇被视为几何上关联。\n\n2. 转换事件识别：对于任何与至少两条径迹 $i$ 和 $\\ell$ 关联的 ECAL 簇 $j$，如果所有条件都满足，则声明一个转换光子：\n- 电荷相反：$q_i \\cdot q_\\ell = -1$。\n- 两条径迹之间的张角很小：$\\theta_{i\\ell} = \\arccos\\!\\left( \\hat{u}_i \\cdot \\hat{u}_\\ell \\right) \\le \\theta_{\\mathrm{conv}}$，其中 $\\theta_{\\mathrm{conv}} = 0.02$ $\\mathrm{rad}$。\n- 两条径迹都有足够的内部探测器失踪击中：$h_i \\ge h_{\\mathrm{conv}}$ 且 $h_\\ell \\ge h_{\\mathrm{conv}}$，其中 $h_{\\mathrm{conv}} = 0.6$。\n如果这些条件得到满足，创建一个能量为 $E_{\\gamma}^{\\mathrm{conv}} = E_j$ 的转换光子对象，并将这两条径迹和该簇标记为已消耗。\n\n3. 电子识别与主簇选择：对于每条剩余的径迹 $i$，在未被消耗的簇 $j$ 中，找到满足 $d_{ij} \\le \\Delta R_{\\mathrm{link}}$ 的集合，并选择使 $d_{ij}$ 最小化的主簇 $j^\\star$。如果一条径迹的主簇能量满足\n$$\nE_{j^\\star} \\ge \\alpha \\, p_i, \\quad \\text{其中 } \\alpha = 0.5.\n$$\n则该径迹成为一个电子。如果被识别为电子，则将其主簇标记为已消耗。\n\n4. 轫致辐射簇的关联与合并：对于一个已识别的电子径迹 $i$ 及其主簇 $j^\\star$，任何尚未被消耗且满足 $d_{ik} \\le \\Delta R_{\\mathrm{brem}}$（其中 $\\Delta R_{\\mathrm{brem}} = 0.05$ $\\mathrm{rad}$）的额外簇 $k$，并且在所有径迹中与簇 $k$ 最近的是径迹 $i$，则该簇被视为一个轫致辐射光子簇，并合并到电子的能量中。重建的电子能量为\n$$\nE_e = E_{j^\\star} + \\sum_{k \\in \\mathcal{B}_i} E_k,\n$$\n其中 $\\mathcal{B}_i$ 是与径迹 $i$ 关联的轫致辐射簇的集合。将任何合并的轫致辐射簇标记为已消耗。\n\n5. 未转换光子的创建：任何在步骤 $2$–$4$ 中未被消耗的剩余 ECAL 簇都成为一个能量为 $E_\\gamma = E_j$ 的未转换光子。\n\n方向的几何表示将使用球坐标来构建单位矢量。对于角度 $(\\theta, \\phi)$，定义单位矢量\n$$\n\\hat{n}(\\theta,\\phi) = \\left( \\sin\\theta \\cos\\phi,\\; \\sin\\theta \\sin\\phi,\\; \\cos\\theta \\right).\n$$\n角度必须以 $\\mathrm{radians}$（弧度）为单位提供和使用。能量必须以 $\\mathrm{GeV}$ 表示。\n\n输出的对象编码如下：电子 $\\rightarrow 0$，未转换光子 $\\rightarrow 1$，转换光子 $\\rightarrow 2$。每个重建的对象必须表示为一个 $[\\mathrm{code}, E]$ 形式的列表，其中 $E$ 是对象的能量，单位为 $\\mathrm{GeV}$，四舍五入到两位小数。\n\n测试套件。在以下四种情况下实现该流程，这四种情况分别测试一个一般情况、一个边界、一个转换和一个模糊性解决：\n\n- 情况 1（带轫致辐射的电子和孤立光子）：\n  - 径迹：一条类电子径迹，其 $p = 50$ $\\mathrm{GeV}$，$q = -1$，$h = 0.1$，$(\\theta, \\phi) = (1.2, 0.1)$。\n  - ECAL 簇：主候选簇 $E = 45$ $\\mathrm{GeV}$，位于 $(\\theta, \\phi) = (1.21, 0.1)$；轫致辐射候选簇 $E = 8$ $\\mathrm{GeV}$，位于 $(\\theta, \\phi) = (1.23, 0.1)$；孤立光子 $E = 20$ $\\mathrm{GeV}$，位于 $(\\theta, \\phi) = (0.3, 2.0)$。\n\n- 情况 2（链接边界失效：簇恰好在链接阈值之外）：\n  - 径迹：一条径迹，其 $p = 20$ $\\mathrm{GeV}$，$q = +1$，$h = 0.1$，$(\\theta, \\phi) = (1.0, 0.5)$。\n  - ECAL 簇：一个簇，其 $E = 20$ $\\mathrm{GeV}$，位于 $(\\theta, \\phi) = (1.032, 0.5)$。\n\n- 情况 3（转换光子）：\n  - 径迹：两条径迹，其 $(p, q, h, \\theta, \\phi)$ 分别为 $(15, +1, 0.7, 1.60, 0.2)$ 和 $(14, -1, 0.7, 1.61, 0.2)$。\n  - ECAL 簇：一个簇，其 $E = 29$ $\\mathrm{GeV}$，位于 $(\\theta, \\phi) = (1.605, 0.2)$。\n\n- 情况 4（靠近两条径迹的模糊簇、非转换事件及一个低能量邻近簇）：\n  - 径迹：$(p, q, h, \\theta, \\phi)$ 分别为 $(40, -1, 0.1, 0.70, -1.0)$ 和 $(38, +1, 0.1, 0.74, -1.0)$。\n  - ECAL 簇：共享候选簇 $E = 42$ $\\mathrm{GeV}$，位于 $(\\theta, \\phi) = (0.715, -1.0)$；邻近低能量簇 $E = 5$ $\\mathrm{GeV}$，位于 $(\\theta, \\phi) = (0.76, -1.0)$。\n\n要求的输出格式：您的程序应生成一个单行输出，其中包含一个用方括号括起来的逗号分隔列表。其中，每个测试用例贡献其重建对象列表。因此，最外层的列表有四个元素，每个元素对应一个用例，而每个元素本身就是一个对象列表的列表。能量必须以 $\\mathrm{GeV}$ 为单位，并四舍五入到两位小数。角度必须以 $\\mathrm{radians}$（弧度）为单位。聚合的输出必须是 Python 风格的列表字面量，例如 $[[[0, E_1], [1, E_2]], [[1, E_3]], [[2, E_4]], [[0, E_5], [1, E_6]]]$，其中所有的 $E_k$ 都以 $\\mathrm{GeV}$ 为单位，并四舍五入到两位小数。",
            "solution": "问题陈述是有效的。它概述了一个简化的、但科学上一致的算法流程，用于基于高能物理实验中使用的粒子流 (PF) 范式进行粒子识别。该问题是提法明确的（well-posed），提供了清晰的操作序列和一套完整的参数及测试数据。物理原理——例如能量动量守恒、电子和光子在探测器中的行为，以及像轫致辐射和电子对转换这类过程的特征——都得到了正确（尽管是简化的）表述。其数学形式是明确的，足以通过算法确定唯一的解。\n\n解决方案通过执行指定的重建步骤序列来进行。该算法的核心是系统性地消耗探测器信号（带电粒子径迹和量能器能量沉积，或称簇），以形成有物理意义的对象（电子和光子）。为了解决模糊性，该过程是顺序执行的，像光子转换这类具有特定高纯度信号特征的事件会被首先识别。\n\n首先，我们定义几何表示。一个粒子的轨迹或一个能量簇的位置由球坐标 $(\\theta, \\phi)$ 给出。为了计算角间距，我们使用标准变换将这些坐标转换为三维笛卡尔单位矢量 $\\hat{n}$：\n$$\n\\hat{n}(\\theta,\\phi) = \\left( \\sin\\theta \\cos\\phi,\\; \\sin\\theta \\sin\\phi,\\; \\cos\\theta \\right)\n$$\n由单位矢量 $\\hat{u}_1$ 和 $\\hat{u}_2$ 表示的两个方向之间的角距离 $d_{12}$ 由它们点积的反余弦给出，这源于球面余弦定理：\n$$\nd_{12} = \\arccos(\\hat{u}_1 \\cdot \\hat{u}_2)\n$$\n这个距离度量是所有关联和联系步骤的基础。\n\n重建逻辑对每个测试用例按一系列互斥的步骤执行。对象一旦被分配给一个重建的粒子，就会被标记为“已消耗”，以防止其被重复使用。\n\n1.  **转换事件识别**：第一步是寻找光子在探测器材料中转换为电子-正电子对的独特信号特征。一个高能光子（$E \\gtrsim 2m_e c^2$）与原子核的电磁场相互作用，可以产生一对电荷相反的轻子。在探测器中，这表现为一个 ECAL 簇，没有从相互作用点指向它的关联径迹，但有两条来自主相互作用点之外某个共同顶点的邻近且电荷相反的径迹。我们的算法通过寻找一个与两条径迹 $i$ 和 $\\ell$ 几何上关联的 ECAL 簇 $j$（即 $d_{ij}, d_{\\ell j} \\le \\Delta R_{\\mathrm{link}} = 0.03$）来模拟这一点。要使这种构型成为一个有效的转换事件，必须满足三个反映其物理过程的条件：\n    - 径迹必须带有相反电荷：$q_i \\cdot q_\\ell = -1$。\n    - 径迹之间的张角必须很小，这是由单个高能母粒子产生的粒子对的特征：$\\theta_{i\\ell} = \\arccos(\\hat{u}_i \\cdot \\hat{u}_\\ell) \\le \\theta_{\\mathrm{conv}} = 0.02$ rad。\n    - 径迹必须显示出源于次级顶点的证据，这被简化为对“失踪击中”变量的要求：$h_i, h_\\ell \\ge h_{\\mathrm{conv}} = 0.6$。\n    如果所有条件都满足，则创建一个能量等于簇能量 $E_{\\gamma}^{\\mathrm{conv}} = E_j$ 的转换光子。其组成的径迹和簇随后被标记为已消耗。\n\n2.  **电子识别**：在寻找转换事件之后，算法尝试从剩余的未消耗径迹和簇中识别电子。电子是一种带电粒子，它将其大部分能量沉积在 ECAL 中。这通过将一条径迹 $i$ 与一个主 ECAL 簇 $j^\\star$ 关联来建模。主簇是从所有与该径迹关联的未消耗簇（$d_{ij} \\le \\Delta R_{\\mathrm{link}}$）中选出的角距离 $d_{ij}$ 最小的那个。如果一条径迹的主簇能量是该径迹动量的很大一部分，满足 $E_{j^\\star} \\ge \\alpha \\, p_i$（阈值因子 $\\alpha = 0.5$），则该径迹被确认为电子。如果一条径迹被识别为电子，它及其主簇 $j^\\star$ 将被消耗。此步骤对所有径迹顺序执行；第一条声明拥有某个簇的径迹会消耗它，使其对其他径迹不可用。\n\n3.  **轫致辐射簇的关联**：电子穿过材料时会通过一个称为轫致辐射的过程辐射光子。这些光子几乎与电子沿同一方向传播，并将其能量沉积在 ECAL 中，通常在电子主撞击点附近形成单独的簇。该算法通过在已识别的电子径迹 $i$ 附近搜索额外的未消耗簇 $k$ 来考虑这一点。如果一个簇 $k$ 满足以下条件，它将被视为轫致辐射光子并与电子合并：\n    - 它位于电子径迹周围一个更大的圆锥内：$d_{ik} \\le \\Delta R_{\\mathrm{brem}} = 0.05$ rad。\n    - 为解决当一个簇靠近多条径迹时的模糊性，电子径迹 $i$ 必须是所有径迹中离该簇 $k$ 最近的。\n    任何此类关联的轫致辐射簇的能量都会加到电子的能量上：$E_e = E_{j^\\star} + \\sum_{k \\in \\mathcal{B}_i} E_k$，其中 $\\mathcal{B}_i$ 是与径迹 $i$ 关联的轫致辐射簇的集合。这些合并的簇随后被消耗。\n\n4.  **未转换光子识别**：最后，任何在前述步骤中未被消耗的 ECAL 簇——即它既不属于转换事件，也不是电子的主簇或轫致辐射簇——都被解释为未转换光子。这假设任何未与带电粒子径迹关联的显著 ECAL 能量沉积都可能来自主相互作用点产生的光子。对于每个这样的剩余簇 $j$，会创建一个能量为 $E_\\gamma = E_j$ 的未转换光子对象。\n\n这个完整的序列确保了每个簇和每条径迹都按照逻辑上、有物理动机的顺序被考虑，以产生一个最终的、排他的重建电子和光子列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a simplified Particle Flow (PF) categorization for electrons and photons.\n    The function processes a fixed test suite of four cases and prints the aggregated results.\n    \"\"\"\n    \n    # --- Constants from the problem statement ---\n    DELTA_R_LINK = 0.03\n    THETA_CONV = 0.02\n    H_CONV = 0.6\n    ALPHA = 0.5\n    DELTA_R_BREM = 0.05\n    \n    # --- Object codes ---\n    ELECTRON_CODE = 0\n    UNCONVERTED_PHOTON_CODE = 1\n    CONVERTED_PHOTON_CODE = 2\n\n    # --- Test Suite Data ---\n    test_cases = [\n        {\n            \"tracks\": [\n                {\"p\": 50, \"q\": -1, \"h\": 0.1, \"theta\": 1.2, \"phi\": 0.1}\n            ],\n            \"clusters\": [\n                {\"E\": 45, \"theta\": 1.21, \"phi\": 0.1},\n                {\"E\": 8, \"theta\": 1.23, \"phi\": 0.1},\n                {\"E\": 20, \"theta\": 0.3, \"phi\": 2.0}\n            ]\n        },\n        {\n            \"tracks\": [\n                {\"p\": 20, \"q\": +1, \"h\": 0.1, \"theta\": 1.0, \"phi\": 0.5}\n            ],\n            \"clusters\": [\n                {\"E\": 20, \"theta\": 1.032, \"phi\": 0.5}\n            ]\n        },\n        {\n            \"tracks\": [\n                {\"p\": 15, \"q\": +1, \"h\": 0.7, \"theta\": 1.60, \"phi\": 0.2},\n                {\"p\": 14, \"q\": -1, \"h\": 0.7, \"theta\": 1.61, \"phi\": 0.2}\n            ],\n            \"clusters\": [\n                {\"E\": 29, \"theta\": 1.605, \"phi\": 0.2}\n            ]\n        },\n        {\n            \"tracks\": [\n                {\"p\": 40, \"q\": -1, \"h\": 0.1, \"theta\": 0.70, \"phi\": -1.0},\n                {\"p\": 38, \"q\": +1, \"h\": 0.1, \"theta\": 0.74, \"phi\": -1.0}\n            ],\n            \"clusters\": [\n                {\"E\": 42, \"theta\": 0.715, \"phi\": -1.0},\n                {\"E\": 5, \"theta\": 0.76, \"phi\": -1.0}\n            ]\n        }\n    ]\n\n    def unit_vector(theta, phi):\n        \"\"\"Computes the Cartesian unit vector from spherical coordinates.\"\"\"\n        return np.array([\n            np.sin(theta) * np.cos(phi),\n            np.sin(theta) * np.sin(phi),\n            np.cos(theta)\n        ])\n\n    def angular_distance(v1, v2):\n        \"\"\"Computes the angular distance between two unit vectors.\"\"\"\n        dot_product = np.clip(np.dot(v1, v2), -1.0, 1.0)\n        return np.arccos(dot_product)\n\n    def process_case(tracks_data, clusters_data):\n        \"\"\"Applies the PF algorithm to a single case.\"\"\"\n        \n        # Initialize objects with unique IDs and consumed flags\n        tracks = [dict(t, id=i, consumed=False, vec=unit_vector(t['theta'], t['phi'])) for i, t in enumerate(tracks_data)]\n        clusters = [dict(c, id=i, consumed=False, vec=unit_vector(c['theta'], c['phi'])) for i, c in enumerate(clusters_data)]\n        \n        reco_particles = []\n\n        # 1. Conversion Identification\n        # Use a copy of cluster list to allow modification while iterating\n        for j, cluster in enumerate(clusters):\n            if cluster['consumed']:\n                continue\n            \n            linked_tracks = []\n            for i, track in enumerate(tracks):\n                if not track['consumed']:\n                    dist = angular_distance(track['vec'], cluster['vec'])\n                    if dist = DELTA_R_LINK:\n                        linked_tracks.append(track)\n            \n            if len(linked_tracks) = 2:\n                # Find the first valid conversion pair\n                found_conversion = False\n                for i1 in range(len(linked_tracks)):\n                    for i2 in range(i1 + 1, len(linked_tracks)):\n                        t1 = linked_tracks[i1]\n                        t2 = linked_tracks[i2]\n                        \n                        if t1['q'] * t2['q'] == -1 and \\\n                           angular_distance(t1['vec'], t2['vec']) = THETA_CONV and \\\n                           t1['h'] = H_CONV and t2['h'] = H_CONV:\n                            \n                            energy = round(cluster['E'], 2)\n                            reco_particles.append([CONVERTED_PHOTON_CODE, energy])\n                            \n                            cluster['consumed'] = True\n                            t1['consumed'] = True\n                            t2['consumed'] = True\n                            found_conversion = True\n                            break\n                    if found_conversion:\n                        break\n\n        # 2. Electron Identification and 4. Bremsstrahlung Association\n        identified_electrons = []\n        for track in tracks:\n            if track['consumed']:\n                continue\n\n            # Find primary cluster\n            best_cluster = None\n            min_dist = float('inf')\n            \n            linked_unconsumed_clusters = []\n            for cluster in clusters:\n                if not cluster['consumed']:\n                    dist = angular_distance(track['vec'], cluster['vec'])\n                    if dist = DELTA_R_LINK:\n                        linked_unconsumed_clusters.append((dist, cluster))\n            \n            if not linked_unconsumed_clusters:\n                continue\n\n            min_dist, best_cluster = min(linked_unconsumed_clusters, key=lambda x: x[0])\n\n            # Electron check\n            if best_cluster['E'] = ALPHA * track['p']:\n                track['consumed'] = True\n                best_cluster['consumed'] = True\n                electron_energy = best_cluster['E']\n                # identified_electrons will store electron track and its growing energy\n                identified_electrons.append({'track': track, 'energy': electron_energy})\n        \n        # Now handle bremsstrahlung for the identified electrons\n        for electron in identified_electrons:\n            electron_track = electron['track']\n            \n            brem_clusters_to_add = []\n            for cluster in clusters:\n                if cluster['consumed']:\n                    continue\n                \n                dist_to_electron = angular_distance(electron_track['vec'], cluster['vec'])\n                if dist_to_electron = DELTA_R_BREM:\n                    # Check if this electron track is the closest track to the cluster\n                    closest_track_dist = float('inf')\n                    closest_track = None\n                    for any_track in tracks:\n                        d = angular_distance(any_track['vec'], cluster['vec'])\n                        if d  closest_track_dist:\n                            closest_track_dist = d\n                            closest_track = any_track\n                    \n                    if closest_track['id'] == electron_track['id']:\n                        brem_clusters_to_add.append(cluster)\n            \n            for brem_cluster in brem_clusters_to_add:\n                electron['energy'] += brem_cluster['E']\n                brem_cluster['consumed'] = True\n            \n            energy = round(electron['energy'], 2)\n            reco_particles.append([ELECTRON_CODE, energy])\n\n        # 5. Unconverted Photon Creation\n        for cluster in clusters:\n            if not cluster['consumed']:\n                energy = round(cluster['E'], 2)\n                reco_particles.append([UNCONVERTED_PHOTON_CODE, energy])\n\n        return reco_particles\n\n    # --- Main Execution Loop ---\n    all_results = []\n    for case in test_cases:\n        result = process_case(case['tracks'], case['clusters'])\n        all_results.append(result)\n\n    # Format output as a single-line Python-style list literal string\n    # E.g., [[[0, 53.0], [1, 20.0]], [[1, 20.0]], ...]\n    # str() adds spaces, so we remove them.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}