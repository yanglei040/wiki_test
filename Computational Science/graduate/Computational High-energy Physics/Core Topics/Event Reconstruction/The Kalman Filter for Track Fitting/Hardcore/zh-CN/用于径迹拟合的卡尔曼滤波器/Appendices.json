{
    "hands_on_practices": [
        {
            "introduction": "扩展卡尔曼滤波器（EKF）的威力源于其对非线性动力学的局部线性化处理，但这种近似并非完美无瑕。第一个练习  提供了一个动手实践的机会，通过将 EKF 的一阶预测与更精确的二阶泰勒展开进行比较，来量化这种线性化误差。通过分析带电粒子在磁场中的圆周运动，你将推导出一个步长选择准则，以将这个基本误差控制在可容忍的范围内。",
            "id": "3538947",
            "problem": "带有电荷 $q$ 和动量 $p$ 的带电粒子在沿 $\\hat{z}$ 轴方向的均匀磁场中穿行时，在横向平面上进行圆周运动。在计算高能物理的径迹拟合中，扩展卡尔曼滤波器 (EKF) 通过对非线性运动模型进行局部线性化，来传播径迹状态及其在探测器层之间的不确定性。考虑一个简化的、科学上真实的运动学模型，该模型由弧长 $s$ 参数化，状态向量为 $\\mathbf{x}(s) = (x(s), y(s), \\varphi(s))$，其中 $\\varphi$ 是以弧度为单位的航向角。假设曲率 $\\kappa$（单位为米^-1）在一个小的传播步长 $\\Delta s$ 内是恒定的，并由 $\\kappa = \\frac{q B}{p}$ 给出，其中 $B$ 是磁场强度。在此步长内忽略能量损失和材料效应。运动方程为\n$$\n\\frac{d x}{d s} = \\cos \\varphi, \\quad \\frac{d y}{d s} = \\sin \\varphi, \\quad \\frac{d \\varphi}{d s} = \\kappa.\n$$\n设非线性漂移函数为 $f(\\mathbf{x}) = (\\cos \\varphi, \\sin \\varphi, \\kappa)$，并令 $J(\\mathbf{x}) = \\frac{\\partial f}{\\partial \\mathbf{x}}$ 表示其雅可比矩阵。EKF 对一个步长 $\\Delta s$ 内平均状态增量的一阶预测使用关于当前均值的线性化来近似流的一阶项。流的二阶泰勒展开涉及 $J(\\mathbf{x}) f(\\mathbf{x})$，并量化了动力学的局部曲率。\n\n你的任务是编写一个完整的、可运行的程序，对每个指定的测试用例，以米和弧度为单位执行以下计算：\n- 计算 EKF 对位置分量的一阶预测增量，\n$$\n\\Delta \\mathbf{r}_{\\mathrm{EKF}} = \\begin{pmatrix} \\Delta x \\\\ \\Delta y \\end{pmatrix} = \\Delta s \\begin{pmatrix} \\cos \\varphi_0 \\\\ \\sin \\varphi_0 \\end{pmatrix},\n$$\n其中 $\\varphi_0$ 是以弧度为单位的初始角度。\n- 计算二阶泰勒预测的位置分量增量，\n$$\n\\Delta \\mathbf{r}_{2} = \\Delta s \\begin{pmatrix} \\cos \\varphi_0 \\\\ \\sin \\varphi_0 \\end{pmatrix} + \\frac{1}{2} \\Delta s^2 \\, \\big[J(\\mathbf{x}_0) f(\\mathbf{x}_0)\\big]_{x,y},\n$$\n其中 $\\mathbf{x}_0 = (x_0, y_0, \\varphi_0)$ 是初始状态，$[\\,\\cdot\\,]_{x,y}$ 选择位置分量。明确地，使用 $J(\\mathbf{x}_0) f(\\mathbf{x}_0) = \\kappa \\, (-\\sin \\varphi_0, \\cos \\varphi_0, 0)$。\n- 定义并计算线性化误差，\n$$\ne_{\\mathrm{lin}} = \\left\\| \\Delta \\mathbf{r}_{2} - \\Delta \\mathbf{r}_{\\mathrm{EKF}} \\right\\|,\n$$\n以米为单位表示，使用位置分量上的欧几里得范数。\n- 提出并计算一个步长准则 $\\Delta s_{\\max}$，以使被忽略的二阶项保持在指定的容差 $\\tau$（单位为米）以下。使用从模型推导出的界限，\n$$\n\\left\\| \\Delta \\mathbf{r}_{2} - \\Delta \\mathbf{r}_{\\mathrm{EKF}} \\right\\| \\le \\frac{1}{2} \\, |\\kappa| \\, \\Delta s^2,\n$$\n并设置\n$$\n\\Delta s_{\\max} = \n\\begin{cases}\n\\sqrt{\\dfrac{2 \\tau}{|\\kappa|}},  \\text{if } \\kappa \\ne 0, \\\\\n10^9,  \\text{if } \\kappa = 0,\n\\end{cases}\n$$\n其中 $10^9$ 米的值作为一个大的哨兵值，代表直线情况下一个有效无界的步长。\n- 每个测试用例返回两个布尔值：实际计算的 $e_{\\mathrm{lin}}$ 是否小于或等于容差 $\\tau$，以及提供的步长 $\\Delta s$ 是否满足准则 $\\Delta s \\le \\Delta s_{\\max}$。\n\n所有角度必须以弧度为单位，弧长以米为单位，曲率以米^-1为单位，容差以米为单位。最终的程序输出必须将所有测试用例的结果汇总到一行，以方括号括起来的逗号分隔列表形式打印到标准输出，其中每个测试用例贡献一个形式为 $[e_{\\mathrm{lin}}, \\text{ok\\_actual}, \\text{ok\\_criterion}, \\Delta s_{\\max}]$ 的列表。量 $e_{\\mathrm{lin}}$ 和 $\\Delta s_{\\max}$ 必须以米为单位提供。\n\n测试套件：\n- 一般情况：$\\varphi_0 = 0.0$ 弧度，$\\kappa = 0.001$ 米^-1，$\\Delta s = 0.1$ 米，$\\tau = 0.0001$ 米。\n- 边界情况：$\\varphi_0 = \\frac{\\pi}{4}$ 弧度，$\\kappa = 0.01$ 米^-1，$\\Delta s = \\sqrt{10^{-5}}$ 米，$\\tau = 0.00005$ 米。\n- 边缘情况（直线）：$\\varphi_0 = \\pi$ 弧度，$\\kappa = 0.0$ 米^-1，$\\Delta s = 10.0$ 米，$\\tau = 0.000001$ 米。\n- 高曲率违规：$\\varphi_0 = \\frac{\\pi}{3}$ 弧度，$\\kappa = 1.0$ 米^-1，$\\Delta s = 0.05$ 米，$\\tau = 0.001$ 米。\n- 负曲率：$\\varphi_0 = \\frac{\\pi}{6}$ 弧度，$\\kappa = -0.5$ 米^-1，$\\Delta s = 0.03$ 米，$\\tau = 0.0005$ 米。\n\n你的程序应该产生单行输出，包含一个方括号括起来的逗号分隔列表形式的结果（例如，$[ [a,b,c,d], [\\dots], \\dots ]$），其中 $a$ 和 $d$ 是以米为单位的浮点数，而 $b$ 和 $c$ 是布尔值。",
            "solution": "当前的问题是在运动学和数值方法方面一个适定且科学严谨的练习，特别涉及到高能物理中的径迹拟合。它要求在一个简化的粒子轨迹模型中，对扩展卡尔曼滤波器 (EKF) 上下文中的线性化误差进行分析。我们将首先验证所提供的公式，然后概述计算过程。\n\n一个带有动量 $p$ 和电荷 $q$ 的带电粒子穿过一个与 $\\hat{z}$ 轴对齐的均匀磁场 $B$。它在横向 $(x, y)$ 平面上的轨迹是一个圆。粒子的状态由向量 $\\mathbf{x}(s) = (x(s), y(s), \\varphi(s))^T$ 描述，该向量由弧长 $s$ 参数化。其分量是笛卡尔坐标 $x$ 和 $y$，以及航向角 $\\varphi$。\n\n动力学由以下常微分方程组控制：\n$$\n\\frac{d\\mathbf{x}}{ds} = \n\\begin{pmatrix} dx/ds \\\\ dy/ds \\\\ d\\varphi/ds \\end{pmatrix} =\n\\begin{pmatrix} \\cos\\varphi \\\\ \\sin\\varphi \\\\ \\kappa \\end{pmatrix} = f(\\mathbf{x})\n$$\n这里，$\\kappa = qB/p$ 是带符号曲率，假设在一个小的传播步长 $\\Delta s$ 内是恒定的。函数 $f(\\mathbf{x})$ 是非线性漂移函数。\n\nEKF 通过线性化动力学来传播状态估计。状态向量增量 $\\Delta\\mathbf{x} = \\mathbf{x}(s_0 + \\Delta s) - \\mathbf{x}(s_0)$ 在初始状态 $\\mathbf{x}_0 = \\mathbf{x}(s_0)$ 附近的泰勒展开为：\n$$\n\\Delta\\mathbf{x} = \\Delta s \\left.\\frac{d\\mathbf{x}}{ds}\\right|_{s_0} + \\frac{(\\Delta s)^2}{2!} \\left.\\frac{d^2\\mathbf{x}}{ds^2}\\right|_{s_0} + O((\\Delta s)^3)\n$$\n导数由下式给出：\n$$\n\\frac{d\\mathbf{x}}{ds} = f(\\mathbf{x})\n$$\n$$\n\\frac{d^2\\mathbf{x}}{ds^2} = \\frac{d}{ds}f(\\mathbf{x}(s)) = \\frac{\\partial f}{\\partial \\mathbf{x}} \\frac{d\\mathbf{x}}{ds} = J(\\mathbf{x}) f(\\mathbf{x})\n$$\n其中 $J(\\mathbf{x}) = \\frac{\\partial f}{\\partial \\mathbf{x}}$ 是漂移函数的雅可比矩阵。因此，截至二阶的增量为：\n$$\n\\Delta\\mathbf{x} \\approx \\Delta s \\, f(\\mathbf{x}_0) + \\frac{(\\Delta s)^2}{2} J(\\mathbf{x}_0) f(\\mathbf{x}_0)\n$$\nEKF 对位置增量 $\\Delta\\mathbf{r}_{\\mathrm{EKF}}$ 的一阶预测对应于第一项，并限定在位置分量 $(x, y)$ 上：\n$$\n\\Delta\\mathbf{r}_{\\mathrm{EKF}} = \\Delta s \\begin{pmatrix} \\cos\\varphi_0 \\\\ \\sin\\varphi_0 \\end{pmatrix}\n$$\n二阶泰勒预测 $\\Delta\\mathbf{r}_2$ 包括下一项：\n$$\n\\Delta\\mathbf{r}_{2} = \\Delta s \\begin{pmatrix} \\cos\\varphi_0 \\\\ \\sin\\varphi_0 \\end{pmatrix} + \\frac{(\\Delta s)^2}{2} \\big[J(\\mathbf{x}_0) f(\\mathbf{x}_0)\\big]_{x,y}\n$$\n为了验证问题中提供的项，我们计算雅可比矩阵 $J(\\mathbf{x})$：\n$$\nJ(\\mathbf{x}) = \\frac{\\partial}{\\partial (x,y,\\varphi)} \\begin{pmatrix} \\cos\\varphi \\\\ \\sin\\varphi \\\\ \\kappa \\end{pmatrix} = \\begin{pmatrix} 0  0  -\\sin\\varphi \\\\ 0  0  \\cos\\varphi \\\\ 0  0  0 \\end{pmatrix}\n$$\n然后我们计算乘积 $J(\\mathbf{x})f(\\mathbf{x})$：\n$$\nJ(\\mathbf{x})f(\\mathbf{x}) = \\begin{pmatrix} 0  0  -\\sin\\varphi \\\\ 0  0  \\cos\\varphi \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} \\cos\\varphi \\\\ \\sin\\varphi \\\\ \\kappa \\end{pmatrix} = \\begin{pmatrix} -\\kappa\\sin\\varphi \\\\ \\kappa\\cos\\varphi \\\\ 0 \\end{pmatrix}\n$$\n这证实了问题陈述中给出的表达式 $J(\\mathbf{x}_0) f(\\mathbf{x}_0) = \\kappa(-\\sin\\varphi_0, \\cos\\varphi_0, 0)^T$。\n\n线性化误差 $e_{\\mathrm{lin}}$ 定义为位置增量的二阶预测和一阶预测之差的模：\n$$\ne_{\\mathrm{lin}} = \\| \\Delta\\mathbf{r}_2 - \\Delta\\mathbf{r}_{\\mathrm{EKF}} \\| = \\left\\| \\frac{(\\Delta s)^2}{2} \\big[J(\\mathbf{x}_0) f(\\mathbf{x}_0)\\big]_{x,y} \\right\\|\n$$\n代入推导出的表达式：\n$$\ne_{\\mathrm{lin}} = \\left\\| \\frac{(\\Delta s)^2}{2} \\begin{pmatrix} -\\kappa\\sin\\varphi_0 \\\\ \\kappa\\cos\\varphi_0 \\end{pmatrix} \\right\\| = \\frac{(\\Delta s)^2}{2} |\\kappa| \\sqrt{(-\\sin\\varphi_0)^2 + (\\cos\\varphi_0)^2} = \\frac{1}{2} |\\kappa| (\\Delta s)^2\n$$\n这个结果是显著的。它表明，问题中给出的误差界限 $\\left\\| \\Delta \\mathbf{r}_{2} - \\Delta \\mathbf{r}_{\\mathrm{EKF}} \\right\\| \\le \\frac{1}{2} |\\kappa| (\\Delta s)^2$ 对于这个特定的运动学模型实际上是一个等式。\n\n该任务要求计算两个布尔标志。第一个 $ok_{\\mathrm{actual}}$ 检查计算出的线性化误差是否在指定的容差 $\\tau$ 之内：\n$$\nok_{\\mathrm{actual}} \\iff e_{\\mathrm{lin}} \\le \\tau \\iff \\frac{1}{2} |\\kappa| (\\Delta s)^2 \\le \\tau\n$$\n第二个 $ok_{\\mathrm{criterion}}$ 检查步长 $\\Delta s$ 是否遵守推导出的最大步长 $\\Delta s_{\\max}$。这个最大步长被定义为将误差界限保持在 $\\tau$ 以下。对于 $\\kappa \\ne 0$：\n$$\n\\frac{1}{2} |\\kappa| (\\Delta s)^2 \\le \\tau \\implies (\\Delta s)^2 \\le \\frac{2\\tau}{|\\kappa|} \\implies \\Delta s \\le \\sqrt{\\frac{2\\tau}{|\\kappa|}}\n$$\n这给出了 $\\Delta s_{\\max} = \\sqrt{\\frac{2\\tau}{|\\kappa|}}$。因此，条件 $\\Delta s \\le \\Delta s_{\\max}$ 在数学上等同于 $e_{\\mathrm{lin}} \\le \\tau$。对于 $\\kappa = 0$ 的情况，$e_{\\mathrm{lin}} = 0$，所以对于任何 $\\tau \\ge 0$，$e_{\\mathrm{lin}} \\le \\tau$ 都成立。相应的 $\\Delta s_{\\max}$ 被取为一个大数（$10^9$ 米），所以对于任何合理的步长，$\\Delta s \\le \\Delta s_{\\max}$ 也将成立。因此，对于所有有效的测试用例，两个布尔标志 $ok_{\\mathrm{actual}}$ 和 $ok_{\\mathrm{criterion}}$ 必须是相同的。\n\n每个测试用例 $(\\varphi_0, \\kappa, \\Delta s, \\tau)$ 的计算步骤如下：\n$1$. 计算线性化误差：$e_{\\mathrm{lin}} = \\frac{1}{2} |\\kappa| (\\Delta s)^2$。\n$2$. 确定第一个布尔值：$ok_{\\mathrm{actual}} = (e_{\\mathrm{lin}} \\le \\tau)$。\n$3$. 计算最大允许步长：如果 $\\kappa \\ne 0$，则 $\\Delta s_{\\max} = \\sqrt{2\\tau/|\\kappa|}$；如果 $\\kappa = 0$，则 $\\Delta s_{\\max} = 10^9$。\n$4$. 确定第二个布尔值：$ok_{\\mathrm{criterion}} = (\\Delta s \\le \\Delta s_{\\max})$。\n$5$. 收集四个结果：$[e_{\\mathrm{lin}}, ok_{\\mathrm{actual}}, ok_{\\mathrm{criterion}}, \\Delta s_{\\max}]$。\n将对每个提供的测试用例实施此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs computations related to the EKF linearization error for a simplified\n    particle tracking model, as specified in the problem statement.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (phi0_rad, kappa_inv_m, ds_m, tau_m)\n    test_cases = [\n        # General case\n        (0.0, 0.001, 0.1, 0.0001),\n        # Boundary case\n        (np.pi / 4, 0.01, np.sqrt(1e-5), 0.00005),\n        # Edge case (straight line)\n        (np.pi, 0.0, 10.0, 0.000001),\n        # High-curvature violation\n        (np.pi / 3, 1.0, 0.05, 0.001),\n        # Negative curvature\n        (np.pi / 6, -0.5, 0.03, 0.0005),\n    ]\n\n    results = []\n    for case in test_cases:\n        phi0, kappa, ds, tau = case\n\n        # 1. Compute the linearization error, e_lin\n        # As derived, e_lin = 0.5 * |kappa| * ds^2\n        e_lin = 0.5 * np.abs(kappa) * ds**2\n\n        # 2. Check if the actual computed e_lin is less than or equal to the tolerance tau\n        ok_actual = e_lin = tau\n\n        # 3. Compute the step-size criterion, ds_max\n        if kappa != 0:\n            ds_max = np.sqrt(2 * tau / np.abs(kappa))\n        else:\n            # Sentinel value for an effectively unbounded step in the straight-line case\n            ds_max = 1e9\n        \n        # 4. Check if the provided step size ds satisfies the criterion ds = ds_max\n        ok_criterion = ds = ds_max\n        \n        # Aggregate the results for the current test case.\n        # As established by the derivation, ok_actual and ok_criterion should be identical.\n        # This serves as an internal consistency check of the model and its implementation.\n        results.append([e_lin, ok_actual, ok_criterion, ds_max])\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists, constructed by joining\n    # the string representations of the inner lists with a comma.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个高效的径迹拟合算法必须使其步长适应粒子的局部环境。这项练习  将我们从误差分析推进到主动控制误差，要求你设计一个自适应步长控制器。你将实现一个算法，该算法会平衡多个约束条件——几何线性化误差、方向变化以及材料效应引起的过程噪声累积——以最小化总步数，从而降低计算成本。",
            "id": "3538976",
            "problem": "考虑一个带电粒子以恒定速率在静态磁场和物质中传播，正如在计算高能物理中为使用卡尔曼滤波器进行径迹拟合所模拟的那样。粒子的轨迹由洛伦兹力决定，这是电磁学的一项基本定律。令 $q$ 表示带符号电荷，$p$ 表示粒子动量的大小，$\\mathbf{v}$ 表示其速度，$\\mathbf{B}(\\mathbf{r})$ 表示在位置 $\\mathbf{r}$ 处的磁场。洛伦兹力定律为\n$$\n\\frac{d\\mathbf{p}}{dt} = q\\,\\mathbf{v} \\times \\mathbf{B}(\\mathbf{r}) \\, ,\n$$\n在短段上能量损失可忽略的假设下，速率近似恒定，且轨迹在垂直于磁场的平面上的投影曲率大小为\n$$\n\\kappa(s) = \\frac{|q|\\,B_\\perp(s)}{p} \\, ,\n$$\n其中 $s$ 是沿轨迹的弧长参数，$B_\\perp(s)$ 是在 $s$ 处 $\\mathbf{B}$ 垂直于 $\\mathbf{v}$ 的分量的大小。\n\n在用于径迹拟合的卡尔曼滤波中，在一个小的弧长步长 $\\Delta s$ 上的局部传播是围绕一个参考状态进行线性化的。截断高阶项会引入线性化误差。对于圆弧上的位置线性化误差，一个物理上有意义且被广泛使用的几何界限是矢高，对于小的角位移，其上界为\n$$\n\\delta_{\\text{geom}} \\le \\frac{|\\kappa|\\,(\\Delta s)^2}{8} \\, .\n$$\n在该步长内的方向变化遵循\n$$\n\\Delta \\theta \\approx |\\kappa|\\,\\Delta s \\, ,\n$$\n为保证一阶线性化的有效性，此变化必须保持很小。\n\n诸如多次库仑散射和随机能量损失等物质效应，通过每一步的过程噪声协方差增量被纳入卡尔曼滤波器中。对于一个单位长度过程噪声速率矩阵为 $\\mathbf{Q}'(s)$ 的连续时间扩散，每步过程噪声是路径积分\n$$\n\\mathbf{Q}_{\\text{step}} = \\int_{s}^{s+\\Delta s} \\mathbf{Q}'(\\sigma)\\, d\\sigma \\, ,\n$$\n并且在 $\\mathbf{Q}'(s)$ 在 $\\Delta s$ 上近似恒定的假设下，这变为\n$$\n\\mathbf{Q}_{\\text{step}} \\approx \\mathbf{Q}'(s)\\, \\Delta s \\, .\n$$\n$\\mathbf{Q}_{\\text{step}}$ 大小的一个标量界限可以通过弗罗贝尼乌斯范数施加，从而有\n$$\n\\left\\|\\mathbf{Q}_{\\text{step}}\\right\\|_F \\approx \\left\\|\\mathbf{Q}'(s)\\right\\|_F\\,\\Delta s \\le q_{\\max} \\, .\n$$\n\n为了平衡线性化误差和运行时间，将总长度为 $L$ 的路径分割成步长 $\\Delta s$ 时，应在满足将每步的线性化误差和过程噪声保持在用户指定容差范围内的约束条件下，使分割尽可能粗略。定义以下每步约束：\n- 位置线性化误差容差：$\\delta_{\\text{geom}} \\le \\varepsilon_{\\text{pos}}$。\n- 方向变化容差：$\\Delta \\theta \\le \\theta_{\\max}$，其中角度以弧度为单位。\n- 过程噪声容差：$\\left\\|\\mathbf{Q}_{\\text{step}}\\right\\|_F \\le q_{\\max}$。\n\n使用以上界限，对于给定的局部曲率 $\\kappa(s)$ 和过程噪声速率范数 $q'(s) = \\left\\|\\mathbf{Q}'(s)\\right\\|_F$，在弧长 $s$ 处允许的最大 $\\Delta s$ 受以下约束：\n$$\n\\Delta s \\le \\sqrt{\\frac{8\\,\\varepsilon_{\\text{pos}}}{|\\kappa(s)|}} \\quad \\text{（如果 $\\kappa(s) \\ne 0$；否则无几何限制）},\n$$\n$$\n\\Delta s \\le \\frac{\\theta_{\\max}}{|\\kappa(s)|} \\quad \\text{（如果 $\\kappa(s) \\ne 0$；否则无方向限制）},\n$$\n$$\n\\Delta s \\le \\frac{q_{\\max}}{q'(s)} \\quad \\text{（如果 $q'(s)  0$；否则无过程噪声限制）} \\, .\n$$\n在约束条件下最小化步数的最优自适应控制器，在每个 $s$ 处选择遵循所有活动界限且不超过剩余路径长度的最大 $\\Delta s$。\n\n你的任务是实现这个自适应步长控制器。对于每个测试用例，你将获得总路径长度 $L$（单位：米），曲率描述 $\\kappa(s)$（单位：反米），过程噪声速率描述 $q'(s)$（单位：每米，其单位与状态协方差一致），以及容差 $\\varepsilon_{\\text{pos}}$（单位：米）、$\\theta_{\\max}$（单位：弧度）和 $q_{\\max}$（单位与 $\\left\\|\\mathbf{Q}_{\\text{step}}\\right\\|_F$ 相同）。你的程序应该使用控制器选择的自适应步长遍历从 $s=0$ 到 $s=L$ 的路径，并返回所需的整数步数。\n\n角度输入和输出必须以弧度为单位。所有距离必须以米为单位。过程噪声量使用与协方差一致的单位，但出于界定范围的目的，你应将 $q'(s)$ 和 $q_{\\max}$ 视为标量大小。\n\n按照描述实现控制器，并为以下每个测试用例计算步数：\n\n- 测试用例 1（一般情况）：$L = 1.0$ 米，$\\kappa(s) = 0.5$ 反米，$q'(s) = 0.02$ 每米，$\\varepsilon_{\\text{pos}} = 10^{-4}$ 米，$\\theta_{\\max} = 0.05$ 弧度，$q_{\\max} = 0.005$。\n- 测试用例 2（高曲率）：$L = 1.0$ 米，$\\kappa(s) = 2.0$ 反米，$q'(s) = 0.02$ 每米，$\\varepsilon_{\\text{pos}} = 10^{-4}$ 米，$\\theta_{\\max} = 0.05$ 弧度，$q_{\\max} = 0.005$。\n- 测试用例 3（过程噪声受限）：$L = 1.0$ 米，$\\kappa(s) = 0.5$ 反米，$q'(s) = 0.2$ 每米，$\\varepsilon_{\\text{pos}} = 10^{-4}$ 米，$\\theta_{\\max} = 0.05$ 弧度，$q_{\\max} = 0.002$。\n- 测试用例 4（零曲率边界）：$L = 1.0$ 米，对所有 $s$，$\\kappa(s) = 0$ 反米，$q'(s) = 0.02$ 每米，$\\varepsilon_{\\text{pos}} = 10^{-4}$ 米，$\\theta_{\\max} = 0.05$ 弧度，$q_{\\max} = 0.005$。\n- 测试用例 5（空间变化曲率）：$L = 1.0$ 米，$\\kappa(s) = 0.5 + 0.4\\sin\\!\\left(2\\pi s / 0.25\\right)$ 反米，$q'(s) = 0.02$ 每米，$\\varepsilon_{\\text{pos}} = 10^{-4}$ 米，$\\theta_{\\max} = 0.05$ 弧度，$q_{\\max} = 0.005$。正弦函数的参数是无量纲的，且 $s$ 的单位是米。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”），每个结果是相应测试用例的整数步数。",
            "solution": "该问题要求实现一个自适应步长控制器，用于模拟带电粒子在含磁场的介质中的轨迹。这是高能物理实验中使用的径迹拟合算法（如卡尔曼滤波器）中的一个常见问题。控制器的目标是以最少的离散步数遍历总长度为 $L$ 的路径，同时确保每一步的局部误差保持在指定的容差以下。\n\n该算法的核心原理是，在当前弧长位置 $s$ 迭代地确定能够满足所有给定约束的可能的最大步长 $\\Delta s$。这个最优步长是指在不违反任何指定的物理或数值限制的情况下，使粒子前进尽可能远的步长。\n\n在任何给定的弧长位置 $s$，允许的最大步长 $\\Delta s$ 由三个独立的约束决定：\n\n1.  **位置线性化误差**：圆弧段的矢高可作为几何线性化误差 $\\delta_{\\text{geom}}$ 的一个界限，它必须小于或等于容差 $\\varepsilon_{\\text{pos}}$。所提供的界限是 $\\delta_{\\text{geom}} \\le \\frac{|\\kappa(s)|(\\Delta s)^2}{8}$，这可转化为约束 $\\frac{|\\kappa(s)|(\\Delta s)^2}{8} \\le \\varepsilon_{\\textpos}$。对于非零的曲率大小 $|\\kappa(s)|  0$，这意味着步长的一个上限：\n    $$\n    \\Delta s \\le \\sqrt{\\frac{8\\,\\varepsilon_{\\text{pos}}}{|\\kappa(s)|}}\n    $$\n    如果 $\\kappa(s) = 0$，轨迹局部为一条直线，这个几何约束变为非活动状态。\n\n2.  **方向变化**：粒子在一个步长内的方向变化 $\\Delta \\theta$ 对于小步长可近似为 $\\Delta \\theta \\approx |\\kappa(s)|\\,\\Delta s$。这个变化不能超过最大角度 $\\theta_{\\max}$。对于 $|\\kappa(s)|  0$，这施加了以下界限：\n    $$\n    \\Delta s \\le \\frac{\\theta_{\\max}}{|\\kappa(s)|}\n    $$\n    如果 $\\kappa(s) = 0$，则没有方向变化，这个约束也变为非活动状态。\n\n3.  **过程噪声累积**：物质效应，如多次散射，被建模为连续过程噪声。一个步长内累积的噪声，其大小受 $\\left\\|\\mathbf{Q}'(s)\\right\\|_F\\,\\Delta s$ 限制，必须小于容差 $q_{\\max}$。令 $q'(s) = \\left\\|\\mathbf{Q}'(s)\\right\\|_F$ 表示过程噪声速率的大小，对于非零速率 $q'(s)  0$，我们有以下约束：\n    $$\n    \\Delta s \\le \\frac{q_{\\max}}{q'(s)}\n    $$\n    如果 $q'(s) = 0$，则没有过程噪声累积，这个约束变为非活动状态。\n\n自适应步进算法实现为一个迭代过程：\n\n设当前弧长为 $s$，已走的步数为 $N$。\n1.  初始化 $s \\leftarrow 0$ 和 $N \\leftarrow 0$。\n2.  启动一个循环，只要 $s  L$ 就继续。\n3.  在循环内部，首先增加步数计数：$N \\leftarrow N+1$。\n4.  在当前位置 $s$，评估局部参数 $\\kappa(s)$ 和 $q'(s)$。\n5.  从所有活动约束中计算上限集合 $\\{ \\Delta s_k \\}$。对于一个约束 $k$ 要成为活动的，相关的物理量（例如 $|\\kappa(s)|$ 或 $q'(s)$）必须大于零。\n6.  最严格的界限，即物理和数值计算允许的最大步长，是 $\\Delta s_{\\text{limit}} = \\min_k(\\{ \\Delta s_k \\})$。如果没有活动的约束（例如，在真空中沿直线轨迹），步长不受这些限制，$\\Delta s_{\\text{limit}}$ 可被视为无穷大。\n7.  实际要走的步长 $\\Delta s$ 不能超过总路径长度 $L$。因此，它是限制值和剩余距离中较小的一个：$\\Delta s = \\min(\\Delta s_{\\text{limit}}, L-s)$。\n8.  更新位置：$s \\leftarrow s + \\Delta s$。\n9.  当 $s$ 达到 $L$ 时，循环终止。$N$ 的最终值是遍历完整长度 $L$ 所需的总步数。\n\n这个过程保证了在路径上的每一点所有约束都得到满足，同时通过最大化步长来最小化总步数，而步数是计算成本的一个代表。\n对于 $\\kappa(s)$ 和 $q'(s)$ 是常数的测试用例，$\\Delta s_{\\text{limit}}$ 对于所有步长也是恒定的。在这种情况下，总步数是 $\\lceil L / \\Delta s_{\\text{limit}} \\rceil$。\n对于具有空间变化参数的情况，如测试用例5，必须数值化地执行完整的迭代算法，因为 $\\Delta s_{\\text{limit}}$ 必须在每个新步骤开始时重新计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the adaptive step-size control problem for all test cases.\n    \"\"\"\n\n    def calculate_steps(L, kappa_func, q_prime_func, eps_pos, theta_max, q_max):\n        \"\"\"\n        Implements the adaptive step-size controller.\n\n        Args:\n            L (float): Total path length in meters.\n            kappa_func (callable): Function kappa(s) returning curvature in m^-1.\n            q_prime_func (callable): Function q'(s) returning process noise rate.\n            eps_pos (float): Position linearization error tolerance in meters.\n            theta_max (float): Direction change tolerance in radians.\n            q_max (float): Process noise tolerance.\n\n        Returns:\n            int: The total number of steps required to traverse the path.\n        \"\"\"\n        s = 0.0\n        num_steps = 0\n        # Use a small epsilon to handle floating point comparisons safely\n        epsilon = 1e-9\n\n        while s  L - epsilon:\n            num_steps += 1\n\n            # Get local parameters at current position s\n            kappa_val = kappa_func(s)\n            q_prime_val = q_prime_func(s)\n\n            ds_bounds = []\n\n            # 1. Position linearization error constraint\n            abs_kappa = np.abs(kappa_val)\n            if abs_kappa > 0:\n                ds_pos = np.sqrt(8 * eps_pos / abs_kappa)\n                ds_bounds.append(ds_pos)\n\n            # 2. Direction change constraint\n            if abs_kappa > 0:\n                ds_dir = theta_max / abs_kappa\n                ds_bounds.append(ds_dir)\n\n            # 3. Process noise constraint\n            if q_prime_val > 0:\n                ds_noise = q_max / q_prime_val\n                ds_bounds.append(ds_noise)\n\n            # Determine the maximum allowed step size from active constraints\n            if not ds_bounds:\n                # If no constraints are active, we can step to the end.\n                ds_limit = L - s\n            else:\n                ds_limit = min(ds_bounds)\n\n            # The step taken is the minimum of the limit and the remaining distance\n            ds = min(ds_limit, L - s)\n            \n            s += ds\n\n        return num_steps\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # case 1: general\n        {'L': 1.0, 'kappa_func': lambda s: 0.5, 'q_prime_func': lambda s: 0.02,\n         'eps_pos': 1e-4, 'theta_max': 0.05, 'q_max': 0.005},\n        # case 2: high curvature\n        {'L': 1.0, 'kappa_func': lambda s: 2.0, 'q_prime_func': lambda s: 0.02,\n         'eps_pos': 1e-4, 'theta_max': 0.05, 'q_max': 0.005},\n        # case 3: process-noise limited\n        {'L': 1.0, 'kappa_func': lambda s: 0.5, 'q_prime_func': lambda s: 0.2,\n         'eps_pos': 1e-4, 'theta_max': 0.05, 'q_max': 0.002},\n        # case 4: zero curvature\n        {'L': 1.0, 'kappa_func': lambda s: 0.0, 'q_prime_func': lambda s: 0.02,\n         'eps_pos': 1e-4, 'theta_max': 0.05, 'q_max': 0.005},\n        # case 5: spatially varying curvature\n        {'L': 1.0, 'kappa_func': lambda s: 0.5 + 0.4 * np.sin(2 * np.pi * s / 0.25),\n         'q_prime_func': lambda s: 0.02, 'eps_pos': 1e-4, 'theta_max': 0.05,\n         'q_max': 0.005}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_steps( case['L'], case['kappa_func'], case['q_prime_func'],\n                                 case['eps_pos'], case['theta_max'], case['q_max'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "一个理论上完美的算法在实践中可能会因为有限精度计算的限制而失败。这最后一个练习  探讨了一个关键的实现细节：卡尔曼滤波器协方差更新步骤的数值稳定性。你将比较常用的、代数上简单的更新公式与更为稳健的 Joseph 形式，量化数值发散的风险，并探索如混合精度计算之类的保护措施。",
            "id": "3538970",
            "problem": "考虑在计算高能物理中，一个带电粒子穿过一个硅探测器平面时的线性化径迹参数更新。设状态向量为 $x \\in \\mathbb{R}^4$，按顺序包含局部参数x位置、y位置、x斜率和y斜率。位置以毫米为单位测量，而斜率是无量纲的。单次测量 $z \\in \\mathbb{R}^2$ 提供了横向位置，其测量噪声协方差已知。假设一个线性高斯测量模型，其具有一个已知的雅可比矩阵，该矩阵将状态映射到测量。给定一个预测状态协方差 $P^- \\in \\mathbb{R}^{4 \\times 4}$、一个测量雅可比矩阵 $H \\in \\mathbb{R}^{2 \\times 4}$ 和一个测量噪声协方差 $R \\in \\mathbb{R}^{2 \\times 2}$。你的任务是实现三种不同的协方差更新方法，在有限精度算术下，量化更新后协方差丧失半正定性和对称性的风险，并实现一种能够降低这些风险的混合精度保障策略。\n\n实现要求：\n- 处理 $4 \\times 4$ 的协方差矩阵 $P^-$。位置单位为毫米，斜率无量纲。\n- 测量雅可比矩阵 $H$ 将状态映射到测量的横向位置，代表了局部平面近似：具体来说，使用选择前两个状态分量的 $H$。\n- 测量噪声协方差 $R$ 是对角矩阵，其对角线元素等于以毫米为单位的测量分辨率的平方。\n- 实现三种协方差更新：\n  1. 代数简化的协方差更新 $(I-KH)P^-$ 的单精度算术实现。\n  2. 数值稳定的 Joseph 形式协方差更新 $(I-KH)P^-(I-KH)^\\top + KRK^\\top$ 的单精度算术实现。\n  3. 一种混合精度保障变体，它以双精度执行 Joseph 形式的关键矩阵乘积和求逆运算，应用对称性恢复，并返回一个单精度协方差。\n\n风险量化指标：\n- 对于每个更新后的协方差 $P^+ \\in \\mathbb{R}^{4 \\times 4}$，计算对称化矩阵 $\\frac{1}{2}(P^+ + (P^+)^\\top)$ 的最小特征值，记为 $\\lambda_{\\min}$（浮点数）。负的 $\\lambda_{\\min}$ 表示丧失了半正定性。此量在不同状态分量上具有混合物理单位，应报告为无单位的浮点数。\n- 计算相对对称误差 $\\|\\Delta\\|_F / \\|P^+\\|_F$，其中 $\\Delta = P^+ - (P^+)^\\top$，$\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。以浮点数形式报告。\n- 仅针对位置子块，计算一个具有物理意义的对角膨胀量，定义为必须在对角线上添加到 $2 \\times 2$ 位置块的最小非负抖动 $j_{\\text{pos}}$（单位为 $\\text{mm}^2$），以使该位置块成为半正定的。具体而言，如果 $P^+$ 的对称化 $2 \\times 2$左上角子块的最小特征值为 $\\lambda_{\\min}^{\\text{pos}}$，则 $j_{\\text{pos}} = \\max(0, -\\lambda_{\\min}^{\\text{pos}})$。将 $j_{\\text{pos}}$ 以 $\\text{mm}^2$ 为单位，表示为浮点数。\n\n测试套件和参数：\n使用以下四个测试用例来检验不同的数值区域。对于每个用例，构造 $P^-$ 为 $P^- = D + U U^\\top$，其中 $D$ 是对角矩阵，其元素等于状态分量标准差的平方，$U \\in \\mathbb{R}^{4 \\times 2}$ 是一个提供相关性的固定低秩扰动。在每个用例中，使用选择位置的 $H$：$H = \\begin{bmatrix} 1  0  0  0 \\\\ 0  1  0  0 \\end{bmatrix}$。\n\n- 用例1（状态良好，典型的硅击中分辨率）：\n  - 状态标准差：$\\sigma_x = 0.05\\,\\text{mm}$，$\\sigma_y = 0.05\\,\\text{mm}$，$\\sigma_{t_x} = 0.001$，$\\sigma_{t_y} = 0.001$。\n  - 测量分辨率：$r_x = 0.02\\,\\text{mm}$，$r_y = 0.02\\,\\text{mm}$，所以 $R = \\operatorname{diag}(r_x^2, r_y^2)$。\n  - 低秩扰动：\n    $$U = \\begin{bmatrix}\n    0.005  -0.003 \\\\\n    0.004  0.002 \\\\\n    0.0005  -0.0002 \\\\\n    0.0004  0.0006\n    \\end{bmatrix}.$$\n- 用例2（近奇异的位置协方差和微小的测量噪声，对求逆和单精度舍入构成压力）：\n  - 状态标准差：$\\sigma_x = 10^{-6}\\,\\text{mm}$，$\\sigma_y = 10^{-6}\\,\\text{mm}$，$\\sigma_{t_x} = 10^{2}$，$\\sigma_{t_y} = 10^{2}$。\n  - 测量分辨率：$r_x = 10^{-6}\\,\\text{mm}$，$r_y = 10^{-6}\\,\\text{mm}$。\n  - 低秩扰动：\n    $$U = \\begin{bmatrix}\n    10^{-9}  -10^{-9} \\\\\n    10^{-9}  10^{-9} \\\\\n    0.1  -0.1 \\\\\n    0.1  0.1\n    \\end{bmatrix}.$$\n- 用例3（高测量噪声主导更新）：\n  - 状态标准差：$\\sigma_x = 0.01\\,\\text{mm}$，$\\sigma_y = 0.01\\,\\text{mm}$，$\\sigma_{t_x} = 0.005$, $\\sigma_{t_y} = 0.005$。\n  - 测量分辨率：$r_x = 5.0\\,\\text{mm}$，$r_y = 5.0\\,\\text{mm}$。\n  - 低秩扰动：\n    $$U = \\begin{bmatrix}\n    0.002  0.0015 \\\\\n    0.001  -0.002 \\\\\n    0.0005  0.0003 \\\\\n    0.0004  -0.0001\n    \\end{bmatrix}.$$\n- 用例4（具有大动态范围的强病态协方差）：\n  - 状态标准差：$\\sigma_x = 10^{3}\\,\\text{mm}$，$\\sigma_y = 10^{-6}\\,\\text{mm}$，$\\sigma_{t_x} = 10.0$，$\\sigma_{t_y} = 10^{-3}$。\n  - 测量分辨率：$r_x = 0.1\\,\\text{mm}$，$r_y = 0.1\\,\\text{mm}$。\n  - 低秩扰动：\n    $$U = \\begin{bmatrix}\n    1.0  0.0 \\\\\n    0.0  10^{-7} \\\\\n    0.01  -0.02 \\\\\n    10^{-4}  5 \\times 10^{-5}\n    \\end{bmatrix}.$$\n\n程序输出：\n对于每个测试用例，按此确切顺序计算并收集以下六个浮点数：$[\\lambda_{\\min}^{\\text{simp32}}, \\lambda_{\\min}^{\\text{joseph32}}, \\lambda_{\\min}^{\\text{mixed}}, \\text{sym\\_err}^{\\text{simp32}}, \\text{sym\\_err}^{\\text{joseph32}}, j_{\\text{pos}}^{\\text{simp32}}]$，其中上标指示使用了哪种更新方法。将所有四个测试用例的结果按用例顺序聚合到一个列表中，展平每个用例的列表。你的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔的结果列表（例如，$[r_1,r_2,\\dots,r_{24}]$）。所有抖动量 $j_{\\text{pos}}$ 必须以 $\\text{mm}^2$ 为单位表示，并报告为浮点数。本问题不使用角度。不使用百分比；所有量均以小数（浮点数）报告。",
            "solution": "该问题要求从第一性原理出发，推导卡尔曼滤波器协方差更新的两种形式，并分析它们在有限精度算术中的数值稳定性。\n\n### **1. 从第一性原理推导**\n\n我们首先形式化线性高斯测量模型。设测量前的状态向量为一个随机变量 $x \\in \\mathbb{R}^4$，服从均值为 $x^-$、协方差为 $P^- \\in \\mathbb{R}^{4 \\times 4}$ 的高斯概率密度函数。我们记为 $x \\sim \\mathcal{N}(x^-, P^-)$。状态向量的分量为 $(x_{\\text{pos}}, y_{\\text{pos}}, t_x, t_y)$，其中位置以毫米为单位，斜率 $t_x, t_y$ 是无量纲的。\n\n测量过程被建模为状态的线性变换，并受加性高斯噪声的干扰。一次测量 $z \\in \\mathbb{R}^2$ 与状态 $x$ 通过以下方程相关联：\n$$z = Hx + v$$\n其中 $H \\in \\mathbb{R}^{2 \\times 4}$ 是测量雅可比矩阵，$v \\in \\mathbb{R}^2$ 是测量噪声。假设噪声是一个零均值高斯随机变量，$v \\sim \\mathcal{N}(0, R)$，其协方差 $R \\in \\mathbb{R}^{2 \\times 2}$ 已知。状态 $x$ 和噪声 $v$ 被假定为不相关的。\n\n滤波步骤的目标是找到以测量 $z$ 为条件的状态 $x$ 的后验分布，即 $p(x|z)$。对于线性高斯系统，该后验分布也是高斯的，$x|z \\sim \\mathcal{N}(x^+, P^+)$。更新后的协方差 $P^+$ 与状态均值和具体测量值 $z$ 无关；它仅依赖于先验协方差 $P^-$ 和测量模型参数 $H$ 和 $R$。\n\n为了推导 $P^+$，我们考虑堆叠向量 $\\begin{pmatrix} x \\\\ z \\end{pmatrix}$ 的联合分布。由于 $x$ 和 $z$ 是联合高斯分布的，该向量服从多元正态分布。其均值为：\n$$E\\left[\\begin{pmatrix} x \\\\ z \\end{pmatrix}\\right] = \\begin{pmatrix} E[x] \\\\ E[Hx + v] \\end{pmatrix} = \\begin{pmatrix} x^- \\\\ H E[x] + E[v] \\end{pmatrix} = \\begin{pmatrix} x^- \\\\ Hx^- \\end{pmatrix}$$\n该联合向量的协方差矩阵是一个块矩阵：\n$$\\text{Cov}\\left(\\begin{pmatrix} x \\\\ z \\end{pmatrix}\\right) = \\begin{pmatrix} \\text{Cov}(x, x)  \\text{Cov}(x, z) \\\\ \\text{Cov}(z, x)  \\text{Cov}(z, z) \\end{pmatrix}$$\n我们计算每个块：\n- $\\text{Cov}(x, x) = P^-$ (根据定义)。\n- $\\text{Cov}(x, z) = \\text{Cov}(x, Hx + v) = \\text{Cov}(x, Hx) + \\text{Cov}(x, v) = \\text{Cov}(x, x)H^\\top + 0 = P^- H^\\top$，因为 $x$ 和 $v$不相关。\n- $\\text{Cov}(z, x) = \\text{Cov}(Hx + v, x) = (\\text{Cov}(x, Hx+v))^\\top = (P^- H^\\top)^\\top = H (P^-)^\\top$。由于协方差矩阵是对称的，$(P^-)^\\top = P^-$，所以 $\\text{Cov}(z, x) = H P^-$。\n- $\\text{Cov}(z, z) = \\text{Cov}(Hx + v, Hx + v) = \\text{Cov}(Hx, Hx) + \\text{Cov}(Hx, v) + \\text{Cov}(v, Hx) + \\text{Cov}(v, v)$。交叉项为零。因此，$\\text{Cov}(z, z) = H \\text{Cov}(x, x) H^\\top + R = H P^- H^\\top + R$。此项是*残差协方差*，记为 $S$。\n\n因此，联合协方差矩阵为：\n$$\\text{Cov}\\left(\\begin{pmatrix} x \\\\ z \\end{pmatrix}\\right) = \\begin{pmatrix} P^-  P^- H^\\top \\\\ H P^-  S \\end{pmatrix} \\quad \\text{其中} \\quad S = H P^- H^\\top + R$$\n\n对于一个分块高斯向量 $\\begin{pmatrix} y_1 \\\\ y_2 \\end{pmatrix}$，其协方差为 $\\begin{pmatrix} \\Sigma_{11}  \\Sigma_{12} \\\\ \\Sigma_{21}  \\Sigma_{22} \\end{pmatrix}$，给定 $y_2$ 时 $y_1$ 的条件协方差由公式 $\\text{Cov}(y_1|y_2) = \\Sigma_{11} - \\Sigma_{12} \\Sigma_{22}^{-1} \\Sigma_{21}$ 给出。\n将此应用于我们的系统，令 $y_1 \\leftrightarrow x$ 和 $y_2 \\leftrightarrow z$，更新后的状态协方差 $P^+$ 为：\n$$P^+ = P^- - (P^- H^\\top) S^{-1} (H P^-)$$\n\n该方程为两种所需实现提供了基础。\n\n#### **形式1：代数简化更新**\n\n我们可以定义卡尔曼增益矩阵 $K \\in \\mathbb{R}^{4 \\times 2}$ 为 $K = P^- H^\\top S^{-1}$。将此代入 $P^+$ 的方程中得到：\n$$P^+ = P^- - K S K^\\top$$\n然而，一种更常见的代数简化形式是：\n$$P^+ = P^- - K (H P^-) = (I - KH) P^-$$\n其中 $I$ 是 $4 \\times 4$ 的单位矩阵。这种形式计算效率高，需要一次 $2 \\times 2$ 矩阵求逆和几次矩阵乘法。然而，众所周知它在数值上是不稳定的。在有限精度算术中，$(I - KH)$ 和 $P^-$ 可能都很大，它们的乘积再从 $P^-$ 中减去可能导致精度损失。如果 $P^-$ 在由 $H$ 测量的子空间中接近奇异，这种减法可能导致 $P^+$ 在数值上不再对称或半正定，从而违反了协方差矩阵的性质。\n\n#### **形式2：数值稳定的 (Joseph) 更新**\n\n一种数值上更鲁棒的公式，称为 Joseph 形式，是通过重写更新以避免大矩阵相减而得到的。可以证明它与上述形式代数等价：\n$$P^+ = (I - KH) P^- (I - KH)^\\top + K R K^\\top$$\n其等价性可通过展开各项来验证：\n\\begin{align*} P^+ = (P^- - KHP^-)(I - H^\\top K^\\top) + KRK^\\top \\\\ = P^- - P^-H^\\top K^\\top - KHP^- + KHP^-H^\\top K^\\top + KRK^\\top \\\\ = P^- - (KHP^-)^\\top - KHP^- + K(HP^-H^\\top + R)K^\\top \\\\ = P^- - (KHP^-)^\\top - KHP^- + K S K^\\top \\end{align*}\n代入 $K = P^- H^\\top S^{-1}$ 并利用 $P^-$ 和 $S$ 的对称性：\n\\begin{align*} P^+ = P^- - (P^-H^\\top S^{-1} H P^-)^\\top - P^-H^\\top S^{-1} H P^- + (P^-H^\\top S^{-1}) S (S^{-1}H P^-) \\\\ = P^- - P^-H^\\top S^{-1} H P^- - P^-H^\\top S^{-1} H P^- + P^-H^\\top S^{-1} H P^- \\\\ = P^- - P^- H^\\top S^{-1} H P^- \\end{align*}\n这证实了代数等价性。Joseph 形式的数值稳定性源于它被表示为两个矩阵的和。项 $(I - KH) P^- (I - KH)^\\top$ 具有 $A \\Sigma A^\\top$ 的结构，因此保持了 $P^-$ 的半正定性。项 $K R K^\\top$ 也具有此结构（因为 $R$ 是正定的），因此也是半正定的。两个半正定矩阵之和总是半正定的。这种结构确保了在精确算术下，$P^+$ 总是一个有效的协方差矩阵。在有限精度算術中，这种形式产生非半正定结果的可能性要小得多。\n\n### **2. 混合精度保障策略**\n\n使用单精度（`float32`）算术会加剧数值问题，因为它只有有限的有效数字（大约7位）。病态问题，例如协方差矩阵元素具有大动态范围或残差协方差 $S$ 近奇异的问题，尤其脆弱。\n\n一种鲁棒的保障措施是在双精度（`float64`，约16位数字）下执行最数值敏感的操作。所提出的混合精度策略利用了 Joseph 形式的优越稳定性，并通过为关键步骤使用更高精度来增强它：\n1.  将输入矩阵 $P^-$、 $H$ 和 $R$ 从单精度转换为双精度。\n2.  以双精度计算所有中间量——$S$、$S^{-1}$、$K$以及 Joseph 形式更新的两项。\n3.  将各项相加以获得双精度的更新后协方差 $P^+_{64}$。\n4.  应用一个显式的对称化步骤：$P^+_{\\text{sym}, 64} = \\frac{1}{2}(P^+_{64} + (P^+_{64})^\\top)$。这可以纠正由浮点矩阵乘法的非结合性引入的微小不对称性。\n5.  将最终的、对称化的双精度结果转换回单精度矩阵。\n\n这种方法减轻了灾难性抵消和矩阵求逆不准确的风险，同时通过构造确保最终矩阵是对称的。最终转换为单精度是为了符合高能物理数据处理框架中经常存在的内存或存储限制。\n\n### **3. 风险量化指标**\n\n为了量化每种实现的数值鲁棒性，使用以下指标：\n-   **最小特征值 ($\\lambda_{\\min}$)**：对称化更新后协方差 $\\frac{1}{2}(P^+ + (P^+)^\\top)$ 的最小特征值。$\\lambda_{\\min}$ 的负值表示结果矩阵丧失了半正定性的关键属性。\n-   **相对对称误差**：$P^+$ 的斜对称部分的弗罗贝尼乌斯范数，由 $P^+$ 的范数归一化，即 $\\|P^+ - (P^+)^\\top\\|_F / \\|P^+\\|_F$。这衡量了由浮点舍入误差引入的不对称程度。\n-   **位置抖动 ($j_{\\text{pos}}$)**：一个具有物理意义的度量，定义为 $j_{\\text{pos}} = \\max(0, -\\lambda_{\\min}^{\\text{pos}})$，其中 $\\lambda_{\\min}^{\\text{pos}}$ 是 $P^+$ 的对称化 $2 \\times 2$ 位置子块的最小特征值。该值表示必须添加到对角位置分量上以恢复协方差位置相关部分的半正定性的最小平方误差（单位为 $\\text{mm}^2$）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef update_simp32(p_minus: np.ndarray, h: np.ndarray, r: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the covariance update using the algebraically simplified form\n    P+ = (I - K*H)*P- in single precision.\n    \"\"\"\n    s = h @ p_minus @ h.T + r\n    k = p_minus @ h.T @ np.linalg.inv(s)\n    p_plus = (np.eye(4, dtype=np.float32) - k @ h) @ p_minus\n    return p_plus\n\ndef update_joseph32(p_minus: np.ndarray, h: np.ndarray, r: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the covariance update using the numerically stable Joseph form\n    P+ = (I-K*H)*P-*(I-K*H).T + K*R*K.T in single precision.\n    \"\"\"\n    s = h @ p_minus @ h.T + r\n    k = p_minus @ h.T @ np.linalg.inv(s)\n    \n    i_kh = np.eye(4, dtype=np.float32) - k @ h\n    term1 = i_kh @ p_minus @ i_kh.T\n    term2 = k @ r @ k.T\n    p_plus = term1 + term2\n    return p_plus\n\ndef update_mixed(p_minus_32: np.ndarray, h_32: np.ndarray, r_32: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the covariance update using the Joseph form in double precision\n    with an explicit symmetrization step, then casts back to single precision.\n    \"\"\"\n    p_minus_64 = p_minus_32.astype(np.float64)\n    h_64 = h_32.astype(np.float64)\n    r_64 = r_32.astype(np.float64)\n\n    s_64 = h_64 @ p_minus_64 @ h_64.T + r_64\n    k_64 = p_minus_64 @ h_64.T @ np.linalg.inv(s_64)\n\n    i_kh_64 = np.eye(4, dtype=np.float64) - k_64 @ h_64\n    term1_64 = i_kh_64 @ p_minus_64 @ i_kh_64.T\n    term2_64 = k_64 @ r_64 @ k_64.T\n    p_plus_64 = term1_64 + term2_64\n\n    # Explicit symmetry restoration\n    p_plus_sym_64 = 0.5 * (p_plus_64 + p_plus_64.T)\n\n    return p_plus_sym_64.astype(np.float32)\n\ndef calculate_min_eigenvalue(p_plus: np.ndarray) -> float:\n    \"\"\"Computes the minimum eigenvalue of the symmetrized matrix.\"\"\"\n    p_sym = 0.5 * (p_plus + p_plus.T)\n    # Use eigvalsh for hermitian (real-symmetric) matrices\n    min_eig = np.min(np.linalg.eigvalsh(p_sym))\n    return min_eig.item()\n\ndef calculate_rel_symmetry_error(p_plus: np.ndarray) -> float:\n    \"\"\"Computes the relative symmetry error.\"\"\"\n    delta = p_plus - p_plus.T\n    norm_delta = np.linalg.norm(delta, 'fro')\n    norm_p = np.linalg.norm(p_plus, 'fro')\n    if norm_p == 0:\n        return 0.0\n    return (norm_delta / norm_p).item()\n\ndef calculate_positional_jitter(p_plus: np.ndarray) -> float:\n    \"\"\"Computes the positional jitter j_pos.\"\"\"\n    p_pos = p_plus[:2, :2]\n    p_pos_sym = 0.5 * (p_pos + p_pos.T)\n    min_eig_pos = np.min(np.linalg.eigvalsh(p_pos_sym))\n    jitter = np.maximum(0.0, -min_eig_pos, dtype=np.float32)\n    return jitter.item()\n\ndef solve():\n    test_cases = [\n        # Case 1: well-conditioned\n        {'s': [0.05, 0.05, 0.001, 0.001], 'r': [0.02, 0.02], 'u': np.array([[0.005, -0.003], [0.004, 0.002], [0.0005, -0.0002], [0.0004, 0.0006]])},\n        # Case 2: near-singular\n        {'s': [1e-6, 1e-6, 1e2, 1e2], 'r': [1e-6, 1e-6], 'u': np.array([[1e-9, -1e-9], [1e-9, 1e-9], [0.1, -0.1], [0.1, 0.1]])},\n        # Case 3: high measurement noise\n        {'s': [0.01, 0.01, 0.005, 0.005], 'r': [5.0, 5.0], 'u': np.array([[0.002, 0.0015], [0.001, -0.002], [0.0005, 0.0003], [0.0004, -0.0001]])},\n        # Case 4: ill-conditioned\n        {'s': [1e3, 1e-6, 10.0, 1e-3], 'r': [0.1, 0.1], 'u': np.array([[1.0, 0.0], [0.0, 1e-7], [0.01, -0.02], [1e-4, 5e-5]])}\n    ]\n\n    h_matrix = np.array([[1, 0, 0, 0], [0, 1, 0, 0]], dtype=np.float32)\n    results = []\n\n    for case in test_cases:\n        sigmas = np.array(case['s'], dtype=np.float32)\n        res = np.array(case['r'], dtype=np.float32)\n        u_matrix = case['u'].astype(np.float32)\n\n        d_matrix = np.diag(sigmas**2)\n        p_minus = (d_matrix + u_matrix @ u_matrix.T).astype(np.float32)\n        r_matrix = np.diag(res**2).astype(np.float32)\n\n        # Run the three update implementations\n        p_simp32 = update_simp32(p_minus, h_matrix, r_matrix)\n        p_joseph32 = update_joseph32(p_minus, h_matrix, r_matrix)\n        p_mixed = update_mixed(p_minus, h_matrix, r_matrix)\n\n        # Calculate metrics as per output specification\n        lam_simp32 = calculate_min_eigenvalue(p_simp32)\n        lam_joseph32 = calculate_min_eigenvalue(p_joseph32)\n        lam_mixed = calculate_min_eigenvalue(p_mixed)\n        \n        sym_err_simp32 = calculate_rel_symmetry_error(p_simp32)\n        sym_err_joseph32 = calculate_rel_symmetry_error(p_joseph32)\n\n        j_pos_simp32 = calculate_positional_jitter(p_simp32)\n\n        case_results = [\n            lam_simp32, lam_joseph32, lam_mixed,\n            sym_err_simp32, sym_err_joseph32,\n            j_pos_simp32\n        ]\n        results.extend(case_results)\n\n    # Format output to match problem specification\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}