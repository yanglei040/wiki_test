{
    "hands_on_practices": [
        {
            "introduction": "The power of the Kalman filter lies in its optimal handling of linear systems, but particle trajectories in magnetic fields are inherently nonlinear. The Extended Kalman Filter (EKF) bridges this gap by repeatedly linearizing the equations of motion, a step that introduces a manageable, but non-zero, error. This practice provides a direct, hands-on way to quantify this linearization error by comparing the first-order EKF prediction with a more accurate second-order expansion . Mastering this analysis is crucial as it forms the basis for developing adaptive step-size controllers that balance computational speed and tracking accuracy.",
            "id": "3538947",
            "problem": "A charged particle of charge $q$ and momentum $p$ traversing a uniform magnetic field aligned along the $\\hat{z}$ axis follows circular motion in the transverse plane. In computational high-energy physics track fitting, the Extended Kalman Filter (EKF) propagates the track state and its uncertainty between detector layers by locally linearizing the nonlinear motion model. Consider a simplified, scientifically realistic kinematic model parameterized by arc length $s$ with the state vector $\\mathbf{x}(s) = (x(s), y(s), \\varphi(s))$, where $\\varphi$ is the heading angle in radians. Assume the curvature $\\kappa$ in inverse meters is constant over a small propagation step $\\Delta s$ and given by $\\kappa = \\frac{q B}{p}$, with $B$ the magnetic field magnitude. Neglect energy loss and material effects within the step. The equations of motion are\n$$\n\\frac{d x}{d s} = \\cos \\varphi, \\quad \\frac{d y}{d s} = \\sin \\varphi, \\quad \\frac{d \\varphi}{d s} = \\kappa.\n$$\nLet the nonlinear drift function be $f(\\mathbf{x}) = (\\cos \\varphi, \\sin \\varphi, \\kappa)$ and let $J(\\mathbf{x}) = \\frac{\\partial f}{\\partial \\mathbf{x}}$ denote its Jacobian. The EKF's first-order prediction of the mean state increment over a step $\\Delta s$ uses the linearization about the current mean to approximate the flow by the first-order term. The second-order Taylor expansion of the flow involves $J(\\mathbf{x}) f(\\mathbf{x})$ and quantifies the local curvature of the dynamics.\n\nYour task is to write a complete, runnable program that, for each specified test case, performs the following computations in meters and radians:\n- Compute the EKF first-order predicted increment for the position components,\n$$\n\\Delta \\mathbf{r}_{\\mathrm{EKF}} = \\begin{pmatrix} \\Delta x \\\\ \\Delta y \\end{pmatrix} = \\Delta s \\begin{pmatrix} \\cos \\varphi_0 \\\\ \\sin \\varphi_0 \\end{pmatrix},\n$$\nwhere $\\varphi_0$ is the initial angle in radians.\n- Compute the second-order Taylor predicted increment for the position components,\n$$\n\\Delta \\mathbf{r}_{2} = \\Delta s \\begin{pmatrix} \\cos \\varphi_0 \\\\ \\sin \\varphi_0 \\end{pmatrix} + \\frac{1}{2} \\Delta s^2 \\, \\big[J(\\mathbf{x}_0) f(\\mathbf{x}_0)\\big]_{x,y},\n$$\nwhere $\\mathbf{x}_0 = (x_0, y_0, \\varphi_0)$ is the initial state and $[\\,\\cdot\\,]_{x,y}$ selects the position components. Explicitly, use $J(\\mathbf{x}_0) f(\\mathbf{x}_0) = \\kappa \\, (-\\sin \\varphi_0, \\cos \\varphi_0, 0)$.\n- Define and compute the linearization error,\n$$\ne_{\\mathrm{lin}} = \\left\\| \\Delta \\mathbf{r}_{2} - \\Delta \\mathbf{r}_{\\mathrm{EKF}} \\right\\|,\n$$\nexpressed in meters, using the Euclidean norm over the position components.\n- Propose and compute a step-size criterion $\\Delta s_{\\max}$ to keep the neglected second-order term below a specified tolerance $\\tau$ (in meters). Use the bound derived from the model,\n$$\n\\left\\| \\Delta \\mathbf{r}_{2} - \\Delta \\mathbf{r}_{\\mathrm{EKF}} \\right\\| \\le \\frac{1}{2} \\, |\\kappa| \\, \\Delta s^2,\n$$\nand set\n$$\n\\Delta s_{\\max} = \n\\begin{cases}\n\\sqrt{\\dfrac{2 \\tau}{|\\kappa|}},  \\text{if } \\kappa \\ne 0, \\\\\n10^9,  \\text{if } \\kappa = 0,\n\\end{cases}\n$$\nwhere the value $10^9$ meters serves as a large sentinel representing an effectively unbounded step in the straight-line case.\n- Return two booleans per test case: whether the actual computed $e_{\\mathrm{lin}}$ is less than or equal to the tolerance $\\tau$, and whether the provided step size $\\Delta s$ satisfies the criterion $\\Delta s \\le \\Delta s_{\\max}$.\n\nAll angles must be in radians, arc lengths in meters, curvature in inverse meters, and tolerances in meters. The final program output must aggregate the results of all test cases into a single line printed to standard output as a comma-separated list enclosed in square brackets, where each test case contributes a list of the form $[e_{\\mathrm{lin}}, \\text{ok\\_actual}, \\text{ok\\_criterion}, \\Delta s_{\\max}]$. The quantities $e_{\\mathrm{lin}}$ and $\\Delta s_{\\max}$ must be provided in meters.\n\nTest suite:\n- General case: $\\varphi_0 = 0.0$ radians, $\\kappa = 0.001$ inverse meters, $\\Delta s = 0.1$ meters, $\\tau = 0.0001$ meters.\n- Boundary case: $\\varphi_0 = \\frac{\\pi}{4}$ radians, $\\kappa = 0.01$ inverse meters, $\\Delta s = \\sqrt{10^{-5}}$ meters, $\\tau = 0.00005$ meters.\n- Edge case (straight line): $\\varphi_0 = \\pi$ radians, $\\kappa = 0.0$ inverse meters, $\\Delta s = 10.0$ meters, $\\tau = 0.000001$ meters.\n- High-curvature violation: $\\varphi_0 = \\frac{\\pi}{3}$ radians, $\\kappa = 1.0$ inverse meters, $\\Delta s = 0.05$ meters, $\\tau = 0.001$ meters.\n- Negative curvature: $\\varphi_0 = \\frac{\\pi}{6}$ radians, $\\kappa = -0.5$ inverse meters, $\\Delta s = 0.03$ meters, $\\tau = 0.0005$ meters.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[ [a,b,c,d], [\\dots], \\dots ]$), where $a$ and $d$ are floats in meters, and $b$ and $c$ are booleans.",
            "solution": "The problem at hand is a well-posed and scientifically sound exercise in kinematics and numerical methods, specifically pertaining to track fitting in high-energy physics. It asks for the analysis of the linearization error in an Extended Kalman Filter (EKF) context for a simplified particle trajectory model. We shall first validate the provided formulas and then outline the computational procedure.\n\nA charged particle with momentum $p$ and charge $q$ travels through a uniform magnetic field $B$ aligned with the $\\hat{z}$-axis. Its trajectory in the transverse $(x, y)$ plane is a circle. The state of the particle is described by the vector $\\mathbf{x}(s) = (x(s), y(s), \\varphi(s))^T$, parameterized by the arc length $s$. The components are the Cartesian coordinates $x$ and $y$, and the heading angle $\\varphi$.\n\nThe dynamics are governed by the system of ordinary differential equations:\n$$\n\\frac{d\\mathbf{x}}{ds} = \n\\begin{pmatrix} dx/ds \\\\ dy/ds \\\\ d\\varphi/ds \\end{pmatrix} =\n\\begin{pmatrix} \\cos\\varphi \\\\ \\sin\\varphi \\\\ \\kappa \\end{pmatrix} = f(\\mathbf{x})\n$$\nHere, $\\kappa = qB/p$ is the signed curvature, assumed constant over a small propagation step $\\Delta s$. The function $f(\\mathbf{x})$ is the nonlinear drift function.\n\nThe EKF propagates the state estimate by linearizing the dynamics. A Taylor expansion of the state vector increment $\\Delta\\mathbf{x} = \\mathbf{x}(s_0 + \\Delta s) - \\mathbf{x}(s_0)$ around the initial state $\\mathbf{x}_0 = \\mathbf{x}(s_0)$ gives:\n$$\n\\Delta\\mathbf{x} = \\Delta s \\left.\\frac{d\\mathbf{x}}{ds}\\right|_{s_0} + \\frac{(\\Delta s)^2}{2!} \\left.\\frac{d^2\\mathbf{x}}{ds^2}\\right|_{s_0} + O((\\Delta s)^3)\n$$\nThe derivatives are given by:\n$$\n\\frac{d\\mathbf{x}}{ds} = f(\\mathbf{x})\n$$\n$$\n\\frac{d^2\\mathbf{x}}{ds^2} = \\frac{d}{ds}f(\\mathbf{x}(s)) = \\frac{\\partial f}{\\partial \\mathbf{x}} \\frac{d\\mathbf{x}}{ds} = J(\\mathbf{x}) f(\\mathbf{x})\n$$\nwhere $J(\\mathbf{x}) = \\frac{\\partial f}{\\partial \\mathbf{x}}$ is the Jacobian matrix of the drift function. The increment up to second order is thus:\n$$\n\\Delta\\mathbf{x} \\approx \\Delta s \\, f(\\mathbf{x}_0) + \\frac{(\\Delta s)^2}{2} J(\\mathbf{x}_0) f(\\mathbf{x}_0)\n$$\nThe EKF's first-order prediction for the position increment $\\Delta\\mathbf{r}_{\\mathrm{EKF}}$ corresponds to the first term, restricted to the position components $(x, y)$:\n$$\n\\Delta\\mathbf{r}_{\\mathrm{EKF}} = \\Delta s \\begin{pmatrix} \\cos\\varphi_0 \\\\ \\sin\\varphi_0 \\end{pmatrix}\n$$\nThe second-order Taylor prediction, $\\Delta\\mathbf{r}_2$, includes the next term:\n$$\n\\Delta\\mathbf{r}_{2} = \\Delta s \\begin{pmatrix} \\cos\\varphi_0 \\\\ \\sin\\varphi_0 \\end{pmatrix} + \\frac{(\\Delta s)^2}{2} \\big[J(\\mathbf{x}_0) f(\\mathbf{x}_0)\\big]_{x,y}\n$$\nTo verify the term provided in the problem, we compute the Jacobian $J(\\mathbf{x})$:\n$$\nJ(\\mathbf{x}) = \\frac{\\partial}{\\partial (x,y,\\varphi)} \\begin{pmatrix} \\cos\\varphi \\\\ \\sin\\varphi \\\\ \\kappa \\end{pmatrix} = \\begin{pmatrix} 0  0  -\\sin\\varphi \\\\ 0  0  \\cos\\varphi \\\\ 0  0  0 \\end{pmatrix}\n$$\nThen we compute the product $J(\\mathbf{x})f(\\mathbf{x})$:\n$$\nJ(\\mathbf{x})f(\\mathbf{x}) = \\begin{pmatrix} 0  0  -\\sin\\varphi \\\\ 0  0  \\cos\\varphi \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} \\cos\\varphi \\\\ \\sin\\varphi \\\\ \\kappa \\end{pmatrix} = \\begin{pmatrix} -\\kappa\\sin\\varphi \\\\ \\kappa\\cos\\varphi \\\\ 0 \\end{pmatrix}\n$$\nThis confirms the expression $J(\\mathbf{x}_0) f(\\mathbf{x}_0) = \\kappa(-\\sin\\varphi_0, \\cos\\varphi_0, 0)^T$ given in the problem statement.\n\nThe linearization error, $e_{\\mathrm{lin}}$, is defined as the magnitude of the difference between the second-order and first-order predictions for the position increment:\n$$\ne_{\\mathrm{lin}} = \\| \\Delta\\mathbf{r}_2 - \\Delta\\mathbf{r}_{\\mathrm{EKF}} \\| = \\left\\| \\frac{(\\Delta s)^2}{2} \\big[J(\\mathbf{x}_0) f(\\mathbf{x}_0)\\big]_{x,y} \\right\\|\n$$\nSubstituting the derived expression:\n$$\ne_{\\mathrm{lin}} = \\left\\| \\frac{(\\Delta s)^2}{2} \\begin{pmatrix} -\\kappa\\sin\\varphi_0 \\\\ \\kappa\\cos\\varphi_0 \\end{pmatrix} \\right\\| = \\frac{(\\Delta s)^2}{2} |\\kappa| \\sqrt{(-\\sin\\varphi_0)^2 + (\\cos\\varphi_0)^2} = \\frac{1}{2} |\\kappa| (\\Delta s)^2\n$$\nThis result is notable. It shows that the error bound given in the problem, $\\left\\| \\Delta \\mathbf{r}_{2} - \\Delta \\mathbf{r}_{\\mathrm{EKF}} \\right\\| \\le \\frac{1}{2} |\\kappa| (\\Delta s)^2$, is in fact an equality for this specific kinematic model.\n\nThe task requires computing two boolean flags. The first, $ok_{\\mathrm{actual}}$, checks if the computed linearization error is within a specified tolerance $\\tau$:\n$$\nok_{\\mathrm{actual}} \\iff e_{\\mathrm{lin}} \\le \\tau \\iff \\frac{1}{2} |\\kappa| (\\Delta s)^2 \\le \\tau\n$$\nThe second, $ok_{\\mathrm{criterion}}$, checks if the step size $\\Delta s$ adheres to a derived maximum step size $\\Delta s_{\\max}$. This maximum step size is defined to keep the error bound below $\\tau$. For $\\kappa \\ne 0$:\n$$\n\\frac{1}{2} |\\kappa| (\\Delta s)^2 \\le \\tau \\implies (\\Delta s)^2 \\le \\frac{2\\tau}{|\\kappa|} \\implies \\Delta s \\le \\sqrt{\\frac{2\\tau}{|\\kappa|}}\n$$\nThis gives $\\Delta s_{\\max} = \\sqrt{\\frac{2\\tau}{|\\kappa|}}$. The condition $\\Delta s \\le \\Delta s_{\\max}$ is therefore mathematically equivalent to $e_{\\mathrm{lin}} \\le \\tau$. For the case $\\kappa = 0$, $e_{\\mathrm{lin}} = 0$, so $e_{\\mathrm{lin}} \\le \\tau$ is true for any $\\tau \\ge 0$. The corresponding $\\Delta s_{\\max}$ is taken as a large number ($10^9$ m), so $\\Delta s \\le \\Delta s_{\\max}$ will also be true for any reasonable step size. Consequently, the two boolean flags, $ok_{\\mathrm{actual}}$ and $ok_{\\mathrm{criterion}}$, must be identical for all valid test cases.\n\nThe computational steps for each test case $(\\varphi_0, \\kappa, \\Delta s, \\tau)$ are as follows:\n$1$. Compute the linearization error: $e_{\\mathrm{lin}} = \\frac{1}{2} |\\kappa| (\\Delta s)^2$.\n$2$. Determine the first boolean: $ok_{\\mathrm{actual}} = (e_{\\mathrm{lin}} \\le \\tau)$.\n$3$. Compute the maximum allowed step size: $\\Delta s_{\\max} = \\sqrt{2\\tau/|\\kappa|}$ if $\\kappa \\ne 0$, and $\\Delta s_{\\max} = 10^9$ if $\\kappa = 0$.\n$4$. Determine the second boolean: $ok_{\\mathrm{criterion}} = (\\Delta s \\le \\Delta s_{\\max})$.\n$5$. Collect the four results: $[e_{\\mathrm{lin}}, ok_{\\mathrm{actual}}, ok_{\\mathrm{criterion}}, \\Delta s_{\\max}]$.\nThis procedure will be implemented for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs computations related to the EKF linearization error for a simplified\n    particle tracking model, as specified in the problem statement.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (phi0_rad, kappa_inv_m, ds_m, tau_m)\n    test_cases = [\n        # General case\n        (0.0, 0.001, 0.1, 0.0001),\n        # Boundary case\n        (np.pi / 4, 0.01, np.sqrt(1e-5), 0.00005),\n        # Edge case (straight line)\n        (np.pi, 0.0, 10.0, 0.000001),\n        # High-curvature violation\n        (np.pi / 3, 1.0, 0.05, 0.001),\n        # Negative curvature\n        (np.pi / 6, -0.5, 0.03, 0.0005),\n    ]\n\n    results = []\n    for case in test_cases:\n        phi0, kappa, ds, tau = case\n\n        # 1. Compute the linearization error, e_lin\n        # As derived, e_lin = 0.5 * |kappa| * ds^2\n        e_lin = 0.5 * np.abs(kappa) * ds**2\n\n        # 2. Check if the actual computed e_lin is less than or equal to the tolerance tau\n        ok_actual = e_lin = tau\n\n        # 3. Compute the step-size criterion, ds_max\n        if kappa != 0:\n            ds_max = np.sqrt(2 * tau / np.abs(kappa))\n        else:\n            # Sentinel value for an effectively unbounded step in the straight-line case\n            ds_max = 1e9\n        \n        # 4. Check if the provided step size ds satisfies the criterion ds = ds_max\n        ok_criterion = ds = ds_max\n        \n        # Aggregate the results for the current test case.\n        # As established by the derivation, ok_actual and ok_criterion should be identical.\n        # This serves as an internal consistency check of the model and its implementation.\n        results.append([e_lin, ok_actual, ok_criterion, ds_max])\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists, constructed by joining\n    # the string representations of the inner lists with a comma.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A successful track fit is predicated on a simple but critical condition: the detector's measurements must provide enough information to uniquely determine all track parameters. This exercise explores this fundamental concept of *observability* by connecting it to the physical layout of the tracking sensors . By constructing and analyzing the rank of the cumulative observability matrix for different detector geometries, you will develop a first-principles understanding of why certain sensor arrangements can resolve a particle's momentum while others lead to ambiguities.",
            "id": "3538929",
            "problem": "A charged particle of high momentum travels in a uniform magnetic field pointing along the $z$-axis, so that in the transverse $(x,y)$ plane the trajectory is a plane curve with curvature $\\kappa \\propto q/p$. Consider a Kalman Filter (KF) linearization about a straight reference trajectory with unit tangent $\\mathbf{t}^{\\ast}=(1,0)$ at curvilinear arc length $s=0$ and nominal curvature $\\kappa^{\\ast}=0$. Use the Frenet–Serret relations $d\\mathbf{r}/ds=\\mathbf{t}$ and $d\\mathbf{t}/ds=\\kappa\\,\\mathbf{n}$ with $\\mathbf{n}=R\\,\\mathbf{t}$, where $R=\\begin{pmatrix}0  -1\\\\ 1  0\\end{pmatrix}$ rotates a vector by $+90^{\\circ}$, to obtain the second-order expansion of the transverse position,\n$$\n\\mathbf{r}(s)\\approx \\mathbf{r}_0 + s\\,\\mathbf{t}_0 + \\tfrac{1}{2}s^2\\,\\kappa\\,R\\,\\mathbf{t}^{\\ast},\n$$\nvalid to first order in the state perturbations about $(\\mathbf{r}_0,\\mathbf{t}_0,\\kappa)=(\\mathbf{r}^{\\ast}_0,\\mathbf{t}^{\\ast},\\kappa^{\\ast})$ with $\\kappa^{\\ast}=0$ and $\\mathbf{t}^{\\ast}=(1,0)$. Each tracker layer $i$ at arc length $s_i$ carries parallel strips with normal (measurement) direction $\\mathbf{m}_i=(\\cos\\psi_i,\\sin\\psi_i)$, so the scalar hit coordinate is $u_i=\\mathbf{m}_i^{\\mathsf T}\\mathbf{r}(s_i)$. The linearized measurement Jacobian row is the gradient of $u_i$ with respect to the 5-parameter state at $s=0$, taken as $\\mathbf{x}=(x_0,y_0,t_{x},t_{y},\\kappa)^{\\mathsf T}$.\n\nAssume five equally spaced layers at arc lengths $s_i=iL$ for $i=1,2,3,4,5$ with fixed $L0$. Consider the three sensor layouts below; an axial layer has $\\psi_i=0$ and a stereo layer has $\\psi_i=\\pi/2$.\n\n- Layout A: $\\psi=[0,\\,0,\\,\\pi/2,\\,0,\\,0]$.\n- Layout B: $\\psi=[0,\\,\\pi/2,\\,0,\\,\\pi/2,\\,0]$.\n- Layout C: $\\psi=[0,\\,\\pi/2,\\,\\pi/2,\\,\\pi/2,\\,0]$.\n\nConstruct the cumulative observability matrix $\\mathcal{O}$ by stacking the five linearized measurement Jacobians. Compute the rank of $\\mathcal{O}$ for each layout and, by reasoning from the linearized model, identify which of these layouts loses sensitivity to the inverse momentum parameter $q/p$ (represented here by $\\kappa$) at first order. Report your three ranks as a single row matrix. No rounding is required and no units are to be reported in the final answer.",
            "solution": "The user has requested an analysis of a linearized Kalman filter model for particle tracking to determine the observability of state parameters for different sensor layouts.\n\n### Step 1: Problem Validation\n\n**1.1. Extract Givens**\n- State vector at curvilinear arc length $s=0$: $\\mathbf{x}=(x_0,y_0,t_{x},t_{y},\\kappa)^{\\mathsf T}$.\n- Particle trajectory model: $\\mathbf{r}(s)\\approx \\mathbf{r}_0 + s\\,\\mathbf{t}_0 + \\tfrac{1}{2}s^2\\,\\kappa\\,R\\,\\mathbf{t}^{\\ast}$.\n- Initial position and tangent: $\\mathbf{r}_0=(x_0, y_0)^{\\mathsf T}$, $\\mathbf{t}_0=(t_x, t_y)^{\\mathsf T}$.\n- Rotation matrix: $R=\\begin{pmatrix}0  -1\\\\ 1  0\\end{pmatrix}$.\n- Reference tangent vector: $\\mathbf{t}^{\\ast}=(1,0)^{\\mathsf T}$.\n- Measurement at layer $i$: $u_i=\\mathbf{m}_i^{\\mathsf T}\\mathbf{r}(s_i)$.\n- Measurement normal vector: $\\mathbf{m}_i=(\\cos\\psi_i,\\sin\\psi_i)^{\\mathsf T}$.\n- Sensor positions: $s_i=iL$ for $i=1,2,3,4,5$, with constant $L0$.\n- Sensor layouts:\n    - Layout A: $\\psi=[\\,0,\\,0,\\,\\pi/2,\\,0,\\,0\\,]$.\n    - Layout B: $\\psi=[\\,0,\\,\\pi/2,\\,0,\\,\\pi/2,\\,0\\,]$.\n    - Layout C: $\\psi=[\\,0,\\,\\pi/2,\\,\\pi/2,\\,\\pi/2,\\,0\\,]$.\n- Task: Construct the observability matrix $\\mathcal{O}$ for each layout, compute its rank, identify the layout that loses sensitivity to $\\kappa$, and report the three ranks.\n\n**1.2. Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem uses a standard linearized model for charged particle tracking in a uniform magnetic field, based on the Frenet-Serret formalism. The relationship between curvature $\\kappa$ and momentum $p$ is physically correct. The Kalman filter concepts (state vector, measurement Jacobian, observability) are appropriately applied. The model is scientifically sound.\n- **Well-Posedness**: The problem asks for the rank of a matrix, which is a well-defined mathematical task leading to a unique solution for each case.\n- **Objectivity**: The problem is stated in precise mathematical and physical terms, free of subjective language.\n- **Completeness and Consistency**: All necessary definitions, equations, and data are provided to construct the required matrices. The linearized model is a consistent approximation commonly used in this field.\n\n**1.3. Verdict and Action**\nThe problem statement is valid. A full solution will be provided.\n\n### Step 2: Derivation of the Observability Matrix\n\nThe state vector at $s=0$ is given as $\\mathbf{x} = \\begin{pmatrix} x_0  y_0  t_x  t_y  \\kappa \\end{pmatrix}^{\\mathsf T}$. The particle's transverse position $\\mathbf{r}(s)$ at arc length $s$ is approximated by:\n$$\n\\mathbf{r}(s) \\approx \\mathbf{r}_0 + s\\,\\mathbf{t}_0 + \\frac{1}{2}s^2\\,\\kappa\\,R\\,\\mathbf{t}^{\\ast}\n$$\nSubstituting the vector components:\n$$\n\\mathbf{r}(s) \\approx \\begin{pmatrix} x_0 \\\\ y_0 \\end{pmatrix} + s \\begin{pmatrix} t_x \\\\ t_y \\end{pmatrix} + \\frac{1}{2}s^2 \\kappa \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} x_0 + s t_x \\\\ y_0 + s t_y + \\frac{1}{2}s^2 \\kappa \\end{pmatrix}\n$$\nThe measurement $u_i$ at layer $i$, located at $s_i=iL$, is the projection of $\\mathbf{r}(s_i)$ onto the measurement direction $\\mathbf{m}_i = \\begin{pmatrix} \\cos\\psi_i  \\sin\\psi_i \\end{pmatrix}^{\\mathsf T}$:\n$$\nu_i = \\mathbf{m}_i^{\\mathsf T} \\mathbf{r}(s_i) = (\\cos\\psi_i)(x_0 + s_i t_x) + (\\sin\\psi_i)\\left(y_0 + s_i t_y + \\frac{1}{2}s_i^2 \\kappa\\right)\n$$\nThe linearized measurement Jacobian for layer $i$ is a $1 \\times 5$ row vector $H_i$, representing the gradient of $u_i$ with respect to the state vector $\\mathbf{x}$:\n$$\nH_i = \\frac{\\partial u_i}{\\partial \\mathbf{x}} = \\begin{pmatrix} \\frac{\\partial u_i}{\\partial x_0}  \\frac{\\partial u_i}{\\partial y_0}  \\frac{\\partial u_i}{\\partial t_x}  \\frac{\\partial u_i}{\\partial t_y}  \\frac{\\partial u_i}{\\partial \\kappa} \\end{pmatrix}\n$$\nCalculating the partial derivatives:\n$$\nH_i = \\begin{pmatrix} \\cos\\psi_i  \\sin\\psi_i  s_i \\cos\\psi_i  s_i \\sin\\psi_i  \\frac{1}{2}s_i^2 \\sin\\psi_i \\end{pmatrix}\n$$\nThe cumulative observability matrix $\\mathcal{O}$ is formed by stacking the Jacobian rows $H_i$ for $i=1, \\dots, 5$, with $s_i=iL$:\n$$\n\\mathcal{O} = \\begin{pmatrix} H_1 \\\\ H_2 \\\\ H_3 \\\\ H_4 \\\\ H_5 \\end{pmatrix}\n$$\nThe rank of $\\mathcal{O}$ determines the number of linearly independent constraints on the state vector, and thus the number of parameters that can be resolved. A rank of $5$ implies all parameters are observable. A rank less than $5$ indicates degeneracies.\n\n### Step 3: Analysis of Each Layout\n\n**Layout A: $\\psi_A = [0, 0, \\pi/2, 0, 0]$**\n- For $\\psi_i=0$, the row is $(1, 0, iL, 0, 0)$. This applies to $i=1, 2, 4, 5$.\n- For $\\psi_3=\\pi/2$, the row is $(0, 1, 0, 3L, \\frac{1}{2}(3L)^2)$.\nThe matrix is:\n$$\n\\mathcal{O}_A = \\begin{pmatrix}\n1  0  L  0  0 \\\\\n1  0  2L  0  0 \\\\\n0  1  0  3L  \\frac{9}{2}L^2 \\\\\n1  0  4L  0  0 \\\\\n1  0  5L  0  0\n\\end{pmatrix}\n$$\nThe four \"axial\" rows (1, 2, 4, 5) constrain only $x_0$ and $t_x$. Since there are more than two such rows with distinct $s_i$, they provide two independent constraints, determining $x_0$ and $t_x$. The single \"stereo\" row (3) provides one constraint on the three parameters $y_0, t_y, \\kappa$. The system is underconstrained. The total number of independent constraints is $2+1=3$.\nTherefore, $\\text{rank}(\\mathcal{O}_A) = 3$.\n\n**Layout B: $\\psi_B = [0, \\pi/2, 0, \\pi/2, 0]$**\n- For $\\psi_i=0$, the row is $(1, 0, iL, 0, 0)$. This applies to $i=1, 3, 5$.\n- For $\\psi_i=\\pi/2$, the row is $(0, 1, 0, iL, \\frac{1}{2}(iL)^2)$. This applies to $i=2, 4$.\nThe matrix is:\n$$\n\\mathcal{O}_B = \\begin{pmatrix}\n1  0  L  0  0 \\\\\n0  1  0  2L  2L^2 \\\\\n1  0  3L  0  0 \\\\\n0  1  0  4L  8L^2 \\\\\n1  0  5L  0  0\n\\end{pmatrix}\n$$\nThe system decouples. The three axial layers (1, 3, 5) provide two independent constraints for the two parameters $x_0, t_x$. The two stereo layers (2, 4) provide two independent constraints for the three parameters $y_0, t_y, \\kappa$. The total number of independent constraints is $2+2=4$.\nTherefore, $\\text{rank}(\\mathcal{O}_B) = 4$.\n\n**Layout C: $\\psi_C = [0, \\pi/2, \\pi/2, \\pi/2, 0]$**\n- For $\\psi_i=0$, the row is $(1, 0, iL, 0, 0)$. This applies to $i=1, 5$.\n- For $\\psi_i=\\pi/2$, the row is $(0, 1, 0, iL, \\frac{1}{2}(iL)^2)$. This applies to $i=2, 3, 4$.\nThe matrix is:\n$$\n\\mathcal{O}_C = \\begin{pmatrix}\n1  0  L  0  0 \\\\\n0  1  0  2L  2L^2 \\\\\n0  1  0  3L  \\frac{9}{2}L^2 \\\\\n0  1  0  4L  8L^2 \\\\\n1  0  5L  0  0\n\\end{pmatrix}\n$$\nThe two axial layers (1, 5) provide two independent constraints for $x_0, t_x$. The three stereo layers (2, 3, 4) provide three constraints for the three parameters $y_0, t_y, \\kappa$. The corresponding $3 \\times 3$ submatrix for these parameters is a Vandermonde-type matrix with distinct $s_i$, which is full rank. Thus, it provides three independent constraints. The total number of independent constraints is $2+3=5$.\nTherefore, $\\text{rank}(\\mathcal{O}_C) = 5$.\n\n### Step 4: Identification of the Layout with Lost Sensitivity\n\nA layout \"loses sensitivity\" to $\\kappa$ if the parameter is not fully observable. Mathematically, this occurs if the observability matrix $\\mathcal{O}$ has a rank less than the number of state parameters ($5$), and the corresponding null space includes a component along the $\\kappa$ direction. Both Layout A ($\\text{rank}=3$) and Layout B ($\\text{rank}=4$) are not fully observable.\n\nThe question asks \"which of these layouts\" (singular), suggesting we must identify the one with the most significant loss of sensitivity. In Layout A, with only one stereo layer, the Jacobian columns corresponding to $y_0, t_y, \\kappa$ are all proportional to one another (specifically, they are all multiples of the vector $(0,0,1,0,0)^{\\mathsf T}$). This means it is fundamentally impossible to distinguish the effects of $y_0, t_y,$ and $\\kappa$ from this geometry. This represents a severe degeneracy.\n\nIn Layout B, there are two stereo layers. The columns for $y_0, t_y, \\kappa$ are no longer collinear, and two independent combinations of these parameters can be measured. While still underconstrained (rank 4), the degeneracy is less severe than in Layout A.\n\nLayout C, with three stereo layers, is fully observable (rank 5) and does not lose sensitivity to any parameter.\n\nThus, Layout A is the configuration that most definitively \"loses sensitivity\" to the curvature $\\kappa$. The requested ranks for layouts A, B, and C are $3, 4,$ and $5$ respectively.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 3  4  5 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "This practice graduates from analyzing individual filter components to implementing a complete, realistic track fitting application: determining a particle's charge sign. You will simulate a track subject to both magnetic deflection and stochastic multiple scattering, and then apply two competing Kalman filters initialized with opposite charge hypotheses . By comparing the goodness-of-fit, quantified by the $\\chi^2$ statistic from each filter's innovation sequence, you will learn a powerful and widely used technique for model selection and hypothesis testing in experimental physics.",
            "id": "3539001",
            "problem": "You are tasked with implementing a numerical study of the sensitivity of charge sign determination in track fitting using the Kalman filter, by comparing innovation sequences from two competing fits initialized with opposite signs of the charge-over-momentum parameter. Work in the transverse plane $x$-$y$ under a uniform magnetic field $B$ oriented along the $z$ axis. Use physics-based modeling and algorithmic derivation starting from fundamental laws and well-tested formulas, and produce a single, runnable program that carries out the simulation and the fits for a set of specified test cases.\n\nThe fundamental basis to use is as follows. The motion of a relativistic charged particle in a uniform magnetic field is governed by the Lorentz force law and results in circular motion in the transverse plane. The curvature is related to the charge-over-momentum by the widely used relation $R = \\frac{p}{0.3\\,|q|\\,B}$ expressed in meters when $B$ is in Tesla and $p$ is in $\\mathrm{GeV}/c$, giving a curvature $\\kappa = \\frac{1}{R} = \\frac{0.3\\,q\\,B}{p}$ in units of $\\mathrm{m}^{-1}$. For multiple scattering in thin materials, use the Highland formula for the root mean square scattering angle $\\theta_0$ in radians: $\\theta_0 \\approx \\frac{13.6\\,\\mathrm{MeV}}{\\beta\\,p\\,c}\\sqrt{\\frac{x}{X_0}}\\left[1 + 0.038 \\ln\\left(\\frac{x}{X_0}\\right)\\right]$, where $\\beta \\approx 1$ for relativistic particles, $p$ is the momentum, $x$ is the thickness, and $X_0$ is the radiation length. In this study, you may assume $\\beta \\approx 1$ and express $13.6\\,\\mathrm{MeV}$ as $0.0136\\,\\mathrm{GeV}$.\n\nDerive a small-angle, linearized kinematic model in the $x$-projection suitable for a Kalman filter state parameterization that includes $q/p$. The state should be represented as $x_k = [y_k, t_k, (q/p)_k]^\\top$, where $y_k$ is the transverse position in meters, $t_k = \\frac{dy}{dx}$ is the local slope (dimensionless, equal to the tangent of the angle, which under small-angle approximation is approximately an angle in radians), and $(q/p)_k$ is the charge-over-momentum in $(\\mathrm{GeV}/c)^{-1}$. Under a uniform magnetic field $B$, derive the linearized propagation over a step $\\Delta x_k$ and formulate the corresponding state transition model and process noise model informed by multiple scattering as a Gaussian with variance on the slope component derived from the Highland formula. The measurement model consists of noisy measurements of $y$ with Gaussian noise of known variance.\n\nThe Kalman filter should compute the innovation $e_k = z_k - H x_{k|k-1}$ at each layer, the innovation covariance $S_k$, and the whitened innovation sequence $w_k = \\frac{e_k}{\\sqrt{S_k}}$. Define a discrimination statistic for each fit as the sum of squared whitened innovations $J = \\sum_k w_k^2$. Perform two fits initialized with identical prior means and covariances except for the sign of the initial $(q/p)$ component (one positive and one negative of the same magnitude). Decide the charge sign by selecting the fit with the lower $J$. If the absolute difference in $J$ between the two fits is less than a fixed threshold $\\tau$ (which must be chosen and justified based on the expected scale of $J$), resolve the tie by selecting the positive sign.\n\nYou must implement a full simulation of tracks and hits for the following test suite. For each case, generate $N$ measurement layers spaced by $\\Delta x$ along the $x$ axis starting at $x = 0$, with initial transverse position $y_0 = 0\\,\\mathrm{m}$ and initial slope $t_0 = 0$ (angle in radians). In each step, apply the kinematics for the true track parameters, add a Gaussian multiple scattering kick to the slope drawn with standard deviation $\\theta_0$ computed from the Highland formula using the specified $x/X_0$, and finally produce a noisy measurement $z_k$ of $y_k$ with Gaussian noise of standard deviation $\\sigma_{\\mathrm{meas}}$. Angles must be treated in radians, and lengths in meters. The magnetic field must be in Tesla; momentum in $\\mathrm{GeV}/c$.\n\nUse the following test suite parameter sets, with all non-specified physical quantities defaulting to the descriptions above. For each test case, the ground-truth charge sign is specified and must be used to generate the hits; your program should report whether the algorithm’s selected sign matches the ground truth. The multiple scattering fraction $x/X_0$ is per layer.\n\n- Case $1$: $N = 12$, $\\Delta x = 0.05\\,\\mathrm{m}$, $B = 2.0\\,\\mathrm{T}$, $p = 3.0\\,\\mathrm{GeV}/c$, $q = +1$, $\\sigma_{\\mathrm{meas}} = 5.0\\times 10^{-4}\\,\\mathrm{m}$, $x/X_0 = 5.0\\times 10^{-3}$.\n- Case $2$: $N = 10$, $\\Delta x = 0.03\\,\\mathrm{m}$, $B = 3.8\\,\\mathrm{T}$, $p = 1.5\\,\\mathrm{GeV}/c$, $q = -1$, $\\sigma_{\\mathrm{meas}} = 8.0\\times 10^{-4}\\,\\mathrm{m}$, $x/X_0 = 1.0\\times 10^{-2}$.\n- Case $3$: $N = 15$, $\\Delta x = 0.04\\,\\mathrm{m}$, $B = 0.02\\,\\mathrm{T}$, $p = 10.0\\,\\mathrm{GeV}/c$, $q = -1$, $\\sigma_{\\mathrm{meas}} = 1.0\\times 10^{-3}\\,\\mathrm{m}$, $x/X_0 = 5.0\\times 10^{-3}$.\n- Case $4$: $N = 12$, $\\Delta x = 0.06\\,\\mathrm{m}$, $B = 1.0\\,\\mathrm{T}$, $p = 2.0\\,\\mathrm{GeV}/c$, $q = +1$, $\\sigma_{\\mathrm{meas}} = 5.0\\times 10^{-3}\\,\\mathrm{m}$, $x/X_0 = 2.0\\times 10^{-2}$.\n- Case $5$: $N = 3$, $\\Delta x = 0.08\\,\\mathrm{m}$, $B = 2.0\\,\\mathrm{T}$, $p = 4.0\\,\\mathrm{GeV}/c$, $q = -1$, $\\sigma_{\\mathrm{meas}} = 2.0\\times 10^{-3}\\,\\mathrm{m}$, $x/X_0 = 5.0\\times 10^{-3}$.\n\nYour program must:\n\n- Implement physically consistent kinematics derived from the Lorentz force, linearized for small angles, and a Kalman filter model including a process noise term informed by multiple scattering in the slope component.\n- For each test case, simulate the hit sequence and perform two Kalman filter fits initialized with $(q/p)_0 = \\pm |q/p|_{\\mathrm{true}}$ and identical prior covariances; compute the innovation sequences, the corresponding $J$ values, and select the sign based on the smallest $J$ with the tie-break rule for $\\Delta J  \\tau$.\n- Report, for each test case, a boolean indicating whether the selected sign equals the ground-truth sign used in simulation.\n\nAngle units must be radians, magnetic field in Tesla, momentum in $\\mathrm{GeV}/c$, distances in meters. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for instance $[{\\mathrm{result}_1},{\\mathrm{result}_2},\\dots]$, where each ${\\mathrm{result}_i}$ is a boolean value computed for the corresponding test case.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of particle physics and state estimation, well-posed with a clear objective and sufficient information, and uses objective, formal language. The task is to implement a numerical study of charge sign determination for a tracked particle in a magnetic field using a Kalman filter, a standard and non-trivial problem in computational high-energy physics.\n\nThe solution proceeds by first deriving the necessary state-space model, then specifying the Kalman filter algorithm, outlining the simulation procedure, and finally detailing the charge discrimination methodology.\n\n**1. State-Space Model Derivation**\n\nThe motion of a charged particle in the transverse $x$-$y$ plane under a uniform magnetic field $B$ along the $z$-axis is analyzed. We adopt a state-space representation suitable for a Kalman filter, where the state is evolved along the $x$-axis.\n\n**State Vector:** The state of the particle at a given plane $x=x_k$ is described by the vector:\n$$\n\\mathbf{x}_k = \\begin{pmatrix} y_k \\\\ t_k \\\\ \\eta_k \\end{pmatrix}\n$$\nwhere $y_k$ is the transverse position in meters, $t_k = \\frac{dy}{dx}$ is the track slope (approximated as the tangent of the pitch angle, $\\tan\\phi_y$), and $\\eta_k = (q/p)_k$ is the signed charge-over-momentum ratio in $(\\mathrm{GeV}/c)^{-1}$.\n\n**State Transition Model (Kinematics):**\nThe Lorentz force law dictates a circular trajectory in the $x$-$y$ plane. For small angles, where the path length $ds \\approx dx$, the change in slope with respect to $x$ is given by:\n$$\n\\frac{dt}{dx} \\approx \\frac{d^2y}{dx^2} \\approx \\kappa = \\frac{1}{R}\n$$\nwhere $\\kappa$ is the curvature. Using the provided formula, $\\kappa = c_B \\eta$, with the constant $c_B = 0.3 B$. The momentum $p$ is assumed constant (no energy loss), so $\\eta_k$ is constant. The differential equations governing the deterministic motion are:\n$$\n\\frac{dy}{dx} = t(x), \\quad \\frac{dt}{dx} = c_B \\eta, \\quad \\frac{d\\eta}{dx} = 0\n$$\nIntegrating these equations over a step from $x_{k-1}$ to $x_k = x_{k-1} + \\Delta x$ yields the exact propagation for the state variables, assuming $\\eta$ is constant over the step:\n\\begin{align*}\nt_k = t_{k-1} + \\int_{x_{k-1}}^{x_k} c_B \\eta_{k-1} \\,dx' = t_{k-1} + c_B \\eta_{k-1} \\Delta x \\\\\ny_k = y_{k-1} + \\int_{x_{k-1}}^{x_k} t(x') \\,dx' = y_{k-1} + \\int_{x_{k-1}}^{x_k} (t_{k-1} + c_B \\eta_{k-1} (x' - x_{k-1})) \\,dx' \\\\\n= y_{k-1} + t_{k-1} \\Delta x + \\frac{1}{2} c_B \\eta_{k-1} (\\Delta x)^2 \\\\\n\\eta_k = \\eta_{k-1}\n\\end{align*}\nThis leads to the linearized state transition model $\\mathbf{x}_{k|k-1} = F_k \\mathbf{x}_{k-1|k-1}$, where the state transition matrix $F_k$ (constant for fixed $\\Delta x$) is:\n$$\nF = \\begin{pmatrix}\n1  \\Delta x  \\frac{1}{2} c_B (\\Delta x)^2 \\\\\n0  1  c_B \\Delta x \\\\\n0  0  1\n\\end{pmatrix}\n$$\n\n**Process Noise Model (Multiple Scattering):**\nAs the particle traverses material, it undergoes multiple Coulomb scattering, which is a stochastic process that primarily deflects its angle. This is modeled as process noise. The variance of the projected scattering angle over a step of length $\\Delta x$ is given by the square of the Highland formula, $\\theta_0^2$:\n$$\n\\theta_0^2 = \\left( \\frac{0.0136\\,\\mathrm{GeV}}{p} \\sqrt{\\frac{\\Delta x}{X_0}} \\left[1 + 0.038 \\ln\\left(\\frac{\\Delta x}{X_0}\\right)\\right] \\right)^2\n$$\nwhere $p = |q|/|\\eta| \\approx 1/|\\eta_{k-1|k-1}|$. Treating scattering as a continuous random walk (Wiener process) in angle along the path, the resulting covariance on the state $(y, t)$ over a step $\\Delta x$ can be found by integrating the effects. This yields the process noise covariance matrix $Q_k$:\n$$\nQ_k = \\theta_0^2 \\begin{pmatrix}\n(\\Delta x)^2/3  \\Delta x/2  0 \\\\\n\\Delta x/2  1  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\nThe full state transition with noise is $\\mathbf{x}_k = F \\mathbf{x}_{k-1} + \\mathbf{w}_{k-1}$, where $\\mathbf{w}_{k-1}$ is a zero-mean Gaussian noise with covariance $Q_k$.\n\n**Measurement Model:**\nThe detectors provide noisy measurements of the transverse position $y_k$.\n$$\nz_k = y_k + \\nu_k, \\quad \\nu_k \\sim \\mathcal{N}(0, \\sigma_{\\mathrm{meas}}^2)\n$$\nIn state-space form, $z_k = H \\mathbf{x}_k + \\nu_k$, with the measurement matrix $H$ and measurement noise covariance $R_k$ given by:\n$$\nH = \\begin{pmatrix} 1  0  0 \\end{pmatrix}, \\quad R_k = \\sigma_{\\mathrm{meas}}^2\n$$\n\n**2. Kalman Filter Algorithm**\n\nThe filter iteratively predicts the state to the next measurement layer and then updates the prediction using the measurement information. Starting with a prior estimate $\\mathbf{x}_{0|0}$ and its covariance $C_{0|0}$, for each measurement $z_k$ at layer $k=1, \\dots, N$:\n\n1.  **Prediction:**\n    \\begin{align*}\n    \\mathbf{x}_{k|k-1} = F \\mathbf{x}_{k-1|k-1} \\quad (\\text{Predicted state}) \\\\\n    C_{k|k-1} = F C_{k-1|k-1} F^\\top + Q_{k-1} \\quad (\\text{Predicted covariance})\n    \\end{align*}\n    where $Q_{k-1}$ is computed using the momentum estimate from $\\mathbf{x}_{k-1|k-1}$.\n\n2.  **Update:**\n    \\begin{align*}\n    e_k = z_k - H \\mathbf{x}_{k|k-1} \\quad (\\text{Innovation}) \\\\\n    S_k = H C_{k|k-1} H^\\top + R_k \\quad (\\text{Innovation covariance}) \\\\\n    K_k = C_{k|k-1} H^\\top S_k^{-1} \\quad (\\text{Kalman gain}) \\\\\n    \\mathbf{x}_{k|k} = \\mathbf{x}_{k|k-1} + K_k e_k \\quad (\\text{Updated state}) \\\\\n    C_{k|k} = (I - K_k H) C_{k|k-1} \\quad (\\text{Updated covariance})\n    \\end{align*}\n\n**3. Simulation and Charge Discrimination**\n\nFor each test case, a ground truth track trajectory and corresponding measurements are simulated.\n\n**Simulation:**\n- A true initial state $\\mathbf{x}_{\\mathrm{true},0} = [0, 0, (q/p)_{\\mathrm{true}}]^T$ is defined.\n- For each layer $k=1, \\dots, N$:\n    1. The true state is propagated deterministically using the kinematic model to find the position $y_{\\mathrm{true}, k}$ and slope $t_{\\mathrm{true}, k, \\text{no scatter}}$.\n    2. A random angular kick $\\delta t_k \\sim \\mathcal{N}(0, \\theta_{0, \\mathrm{true}}^2)$ is added to the slope to simulate multiple scattering: $t_{\\mathrm{true}, k} = t_{\\mathrm{true},k, \\text{no scatter}} + \\delta t_k$.\n    3. A measurement $z_k = y_{\\mathrm{true},k} + \\nu_k$ is generated, with $\\nu_k \\sim \\mathcal{N}(0, \\sigma_{\\mathrm{meas}}^2)$.\n\n**Charge Sign Determination:**\nTwo separate Kalman filters are run on the simulated measurement set $\\{z_k\\}_{k=1}^N$:\n- **Fit 1 (Positive Hypothesis):** Initialized with $\\mathbf{x}_{0|0}^+ = [0, 0, |(q/p)_{\\mathrm{true}}|]^T$.\n- **Fit 2 (Negative Hypothesis):** Initialized with $\\mathbf{x}_{0|0}^- = [0, 0, -|(q/p)_{\\mathrm{true}}|]^T$.\n\nBoth fits use an identical initial covariance matrix $C_{0|0}$, chosen to reflect high confidence in the initial position and slope ($y_0=0, t_0=0$) and a moderate uncertainty in the initial momentum guess.\n\nFor each fit, the discrimination statistic $J$, representing the total chi-squared of the fit, is computed as the sum of squared whitened innovations:\n$$\nJ = \\sum_{k=1}^{N} w_k^2 = \\sum_{k=1}^{N} \\frac{e_k^2}{S_k}\n$$\nThe charge sign is determined by comparing $J_+$ and $J_-$:\n- If $|J_+ - J_-|  \\tau$, the ambiguity is resolved by choosing the positive charge sign.\n- Otherwise, the sign corresponding to the lower $J$ value is chosen.\n\nA fixed threshold $\\tau=1.0$ is chosen. This is a common choice corresponding to a $\\Delta\\chi^2=1$ criterion, which relates to a one-standard-deviation confidence interval for a single parameter estimate. It provides a reasonable, albeit not exceptionally strong, threshold to declare two hypotheses as statistically indistinguishable.\n\nThe program then compares the determined sign with the ground-truth sign used in the simulation and reports the outcome as a boolean value for each test case.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and Kalman filter fits for all test cases.\n    \"\"\"\n    # Set a fixed random seed for reproducibility of the simulation.\n    np.random.seed(42)\n\n    # Test cases as specified in the problem statement.\n    # Format: (N, dx, B, p, q, sigma_meas, dx/X0)\n    test_cases = [\n        (12, 0.05, 2.0, 3.0, +1, 5.0e-4, 5.0e-3),\n        (10, 0.03, 3.8, 1.5, -1, 8.0e-4, 1.0e-2),\n        (15, 0.04, 0.02, 10.0, -1, 1.0e-3, 5.0e-3),\n        (12, 0.06, 1.0, 2.0, +1, 5.0e-3, 2.0e-2),\n        (3, 0.08, 2.0, 4.0, -1, 2.0e-3, 5.0e-3),\n    ]\n\n    results = []\n    \n    # Threshold for charge-sign ambiguity. Justified as a standard Delta chi^2 = 1 cut.\n    tau = 1.0\n\n    for params in test_cases:\n        _, _, _, p_true, q_true, _, _ = params\n        \n        # 1. Simulate the track to generate measurements.\n        measurements = _simulate_track(params)\n        \n        # 2. Run two Kalman filter fits with opposite charge hypotheses.\n        # Positive charge hypothesis\n        q_p_pos_hyp = abs(q_true / p_true)\n        J_pos = _run_kalman_filter(measurements, params, q_p_pos_hyp)\n\n        # Negative charge hypothesis\n        q_p_neg_hyp = -abs(q_true / p_true)\n        J_neg = _run_kalman_filter(measurements, params, q_p_neg_hyp)\n\n        # 3. Apply the decision logic to determine the charge sign.\n        determined_q = 0\n        if abs(J_pos - J_neg)  tau:\n            determined_q = +1  # Tie-breaking rule: select positive sign\n        elif J_pos  J_neg:\n            determined_q = +1\n        else:\n            determined_q = -1\n        \n        # 4. Compare the determined sign with the ground truth.\n        is_correct = (determined_q == q_true)\n        results.append(is_correct)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\n\ndef _highland_formula(p_gev, dx_over_X0):\n    \"\"\"\n    Calculates the RMS multiple scattering angle using the Highland formula.\n    \n    Args:\n        p_gev (float): Momentum in GeV/c.\n        dx_over_X0 (float): Material thickness in units of radiation length.\n        \n    Returns:\n        float: Root mean square of the projected scattering angle (theta_0) in radians.\n    \"\"\"\n    if p_gev = 0: return float('inf')\n    # The term dx_over_X0 is assumed to be  0.\n    if dx_over_X0 = 0: return 0.0\n    \n    term_sqrt = np.sqrt(dx_over_X0)\n    term_log = 1.0 + 0.038 * np.log(dx_over_X0) if dx_over_X0  0 else 1.0\n    theta0 = (0.0136 / p_gev) * term_sqrt * term_log\n    return theta0\n\n\ndef _simulate_track(params):\n    \"\"\"\n    Generates a sequence of measurements for a particle traversing a detector.\n    This function uses a more precise propagation model than the filter for realism.\n    \n    Args:\n        params (tuple): A tuple containing the simulation parameters.\n        \n    Returns:\n        list: A list of noisy position measurements (z_k).\n    \"\"\"\n    N, dx, B, p_true, q_true, sigma_meas, dx_over_X0 = params\n    eta_true = q_true / p_true\n    C_B = 0.3 * B\n\n    y_true = 0.0\n    t_true = 0.0\n    measurements = []\n    \n    for _ in range(N):\n        # Propagate deterministically (bend in B-field)\n        y_next = y_true + t_true * dx + 0.5 * C_B * eta_true * dx**2\n        t_next_no_scatter = t_true + C_B * eta_true * dx\n\n        # Add multiple scattering kick at the end of the step\n        theta0_true = _highland_formula(p_true, dx_over_X0)\n        delta_t = np.random.normal(0.0, theta0_true)\n        t_next = t_next_no_scatter + delta_t\n\n        # Update true state for the next step\n        y_true, t_true = y_next, t_next\n\n        # Generate a noisy measurement of the position\n        measurement_noise = np.random.normal(0.0, sigma_meas)\n        z = y_true + measurement_noise\n        measurements.append(z)\n\n    return measurements\n\n\ndef _run_kalman_filter(measurements, params, initial_q_over_p):\n    \"\"\"\n    Runs a Kalman filter over a sequence of measurements.\n    \n    Args:\n        measurements (list): The sequence of position measurements.\n        params (tuple): A tuple containing the simulation parameters.\n        initial_q_over_p (float): The initial guess for the q/p state component.\n        \n    Returns:\n        float: The total chi-squared (J) for the fit.\n    \"\"\"\n    N, dx, B, _, _, sigma_meas, dx_over_X0 = params\n    C_B = 0.3 * B\n    \n    # Initial state vector: [y, t, q/p]\n    x_est = np.array([0.0, 0.0, initial_q_over_p])\n\n    # Initial covariance matrix C_0|0 reflects prior knowledge at x=0.\n    # y0=0, t0=0 are known, so their initial variances are small.\n    # The initial q/p guess has a larger uncertainty (e.g., 50% on momentum).\n    sigma_y0_sq = (1e-6)**2\n    sigma_t0_sq = (1e-4)**2\n    sigma_q_p_sq = (0.5 * initial_q_over_p)**2 if initial_q_over_p != 0 else 1.0\n    C_est = np.diag([sigma_y0_sq, sigma_t0_sq, sigma_q_p_sq])\n\n    H = np.array([[1.0, 0.0, 0.0]])\n    R_k = np.array([[sigma_meas**2]])\n    F = np.array([\n        [1.0, dx, 0.5 * C_B * dx**2],\n        [0.0, 1.0, C_B * dx],\n        [0.0, 0.0, 1.0]\n    ])\n\n    J_statistic = 0.0\n\n    for z_k in measurements:\n        # --- PREDICTION STEP ---\n        # Process noise covariance Q depends on the momentum from the previous step.\n        q_p_est = x_est[2]\n        p_est = abs(1.0 / q_p_est) if q_p_est != 0 else float('inf')\n        theta0 = _highland_formula(p_est, dx_over_X0)\n        theta0_sq = theta0**2\n        \n        Q_k_minus_1 = np.zeros((3, 3))\n        if theta0_sq  0 and not np.isinf(theta0_sq):\n            Q_k_minus_1[0, 0] = theta0_sq * (dx**2) / 3.0\n            Q_k_minus_1[0, 1] = theta0_sq * dx / 2.0\n            Q_k_minus_1[1, 0] = theta0_sq * dx / 2.0\n            Q_k_minus_1[1, 1] = theta0_sq\n            \n        x_pred = F @ x_est\n        C_pred = F @ C_est @ F.T + Q_k_minus_1\n\n        # --- UPDATE STEP ---\n        e_k = z_k - (H @ x_pred)[0]\n        S_k = (H @ C_pred @ H.T + R_k)[0, 0]\n        \n        if S_k = 0: return float('inf')\n\n        K_k = (C_pred @ H.T) / S_k\n        x_est = x_pred + K_k.flatten() * e_k\n        C_est = (np.eye(3) - K_k @ H) @ C_pred\n        \n        # Accumulate the chi-squared statistic J.\n        w_k_sq = (e_k**2) / S_k\n        J_statistic += w_k_sq\n\n    return J_statistic\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}