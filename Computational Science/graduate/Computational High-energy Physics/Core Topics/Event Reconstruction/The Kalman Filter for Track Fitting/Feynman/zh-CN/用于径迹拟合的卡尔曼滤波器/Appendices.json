{
    "hands_on_practices": [
        {
            "introduction": "扩展卡尔曼滤波器 (EKF) 通过在每一步对非线性系统动力学进行局部线性化来处理问题。本实践深入探讨了该近似方法的核心，即量化其产生的线性化误差。通过将 EKF 的一阶预测与更精确的粒子轨迹二阶泰勒展开进行比较，您将具体理解误差对曲率等物理参数和所选步长 $\\Delta s$ 的依赖性 。这项分析不仅仅是理论练习，它还使您能够为自适应步长控制建立实用标准，这是平衡计算效率和追踪精度的关键技术。",
            "id": "3538947",
            "problem": "一个电荷为 $q$、动量为 $p$ 的带电粒子，在沿 $\\hat{z}$ 轴方向的匀强磁场中穿行时，在横向平面上做圆周运动。在计算高能物理的径迹拟合中，扩展卡尔曼滤波器（EKF）通过对非线性运动模型进行局部线性化，来传播径迹状态及其在探测器各层之间的不确定性。考虑一个简化的、科学上真实的运动学模型，该模型由弧长 $s$ 参数化，其状态向量为 $\\mathbf{x}(s) = (x(s), y(s), \\varphi(s))$，其中 $\\varphi$ 是以弧度为单位的航向角。假设曲率 $\\kappa$（单位为逆米）在一个小的传播步长 $\\Delta s$ 内是恒定的，并由 $\\kappa = \\frac{q B}{p}$ 给出，其中 $B$ 是磁场强度。在该步长内忽略能量损失和材料效应。运动方程为\n$$\n\\frac{d x}{d s} = \\cos \\varphi, \\quad \\frac{d y}{d s} = \\sin \\varphi, \\quad \\frac{d \\varphi}{d s} = \\kappa.\n$$\n设非线性漂移函数为 $f(\\mathbf{x}) = (\\cos \\varphi, \\sin \\varphi, \\kappa)$，并令 $J(\\mathbf{x}) = \\frac{\\partial f}{\\partial \\mathbf{x}}$ 表示其雅可比矩阵。EKF 对一个步长 $\\Delta s$ 内的平均状态增量的一阶预测，使用关于当前均值的线性化来通过一阶项近似流。流的二阶泰勒展开涉及 $J(\\mathbf{x}) f(\\mathbf{x})$，并量化了动力学的局部曲率。\n\n您的任务是编写一个完整的、可运行的程序，为每个指定的测试用例执行以下计算（单位为米和弧度）：\n- 计算位置分量的 EKF 一阶预测增量，\n$$\n\\Delta \\mathbf{r}_{\\mathrm{EKF}} = \\begin{pmatrix} \\Delta x \\\\ \\Delta y \\end{pmatrix} = \\Delta s \\begin{pmatrix} \\cos \\varphi_0 \\\\ \\sin \\varphi_0 \\end{pmatrix},\n$$\n其中 $\\varphi_0$ 是初始角度（以弧度为单位）。\n- 计算位置分量的二阶泰勒预测增量，\n$$\n\\Delta \\mathbf{r}_{2} = \\Delta s \\begin{pmatrix} \\cos \\varphi_0 \\\\ \\sin \\varphi_0 \\end{pmatrix} + \\frac{1}{2} \\Delta s^2 \\, \\big[J(\\mathbf{x}_0) f(\\mathbf{x}_0)\\big]_{x,y},\n$$\n其中 $\\mathbf{x}_0 = (x_0, y_0, \\varphi_0)$ 是初始状态，$[\\,\\cdot\\,]_{x,y}$ 选择位置分量。明确地，使用 $J(\\mathbf{x}_0) f(\\mathbf{x}_0) = \\kappa \\, (-\\sin \\varphi_0, \\cos \\varphi_0, 0)$。\n- 定义并计算线性化误差，\n$$\ne_{\\mathrm{lin}} = \\left\\| \\Delta \\mathbf{r}_{2} - \\Delta \\mathbf{r}_{\\mathrm{EKF}} \\right\\|,\n$$\n以米为单位表示，使用位置分量上的欧几里得范数。\n- 提出并计算一个步长判据 $\\Delta s_{\\max}$，以使被忽略的二阶项低于指定的容差 $\\tau$（单位为米）。使用从模型推导出的界限，\n$$\n\\left\\| \\Delta \\mathbf{r}_{2} - \\Delta \\mathbf{r}_{\\mathrm{EKF}} \\right\\| \\le \\frac{1}{2} \\, |\\kappa| \\, \\Delta s^2,\n$$\n并设置\n$$\n\\Delta s_{\\max} = \n\\begin{cases}\n\\sqrt{\\dfrac{2 \\tau}{|\\kappa|}},  \\text{若 } \\kappa \\ne 0, \\\\\n10^9,  \\text{若 } \\kappa = 0,\n\\end{cases}\n$$\n其中值 $10^9$ 米作为一个大的哨兵值，代表在直线情况下一个实际上无界的步长。\n- 为每个测试用例返回两个布尔值：实际计算出的 $e_{\\mathrm{lin}}$ 是否小于或等于容差 $\\tau$，以及所提供的步长 $\\Delta s$ 是否满足判据 $\\Delta s \\le \\Delta s_{\\max}$。\n\n所有角度必须以弧度为单位，弧长以米为单位，曲率以逆米为单位，容差以米为单位。最终的程序输出必须将所有测试用例的结果汇总到一行，以方括号括起来的逗号分隔列表形式打印到标准输出，其中每个测试用例贡献一个形式为 $[e_{\\mathrm{lin}}, \\text{ok\\_actual}, \\text{ok\\_criterion}, \\Delta s_{\\max}]$ 的列表。量 $e_{\\mathrm{lin}}$ 和 $\\Delta s_{\\max}$ 必须以米为单位提供。\n\n测试套件：\n- 一般情况：$\\varphi_0 = 0.0$ 弧度，$\\kappa = 0.001$ 逆米，$\\Delta s = 0.1$ 米，$\\tau = 0.0001$ 米。\n- 边界情况：$\\varphi_0 = \\frac{\\pi}{4}$ 弧度，$\\kappa = 0.01$ 逆米，$\\Delta s = \\sqrt{10^{-5}}$ 米，$\\tau = 0.00005$ 米。\n- 边缘情况（直线）：$\\varphi_0 = \\pi$ 弧度，$\\kappa = 0.0$ 逆米，$\\Delta s = 10.0$ 米，$\\tau = 0.000001$ 米。\n- 高曲率违规：$\\varphi_0 = \\frac{\\pi}{3}$ 弧度，$\\kappa = 1.0$ 逆米，$\\Delta s = 0.05$ 米，$\\tau = 0.001$ 米。\n- 负曲率：$\\varphi_0 = \\frac{\\pi}{6}$ 弧度，$\\kappa = -0.5$ 逆米，$\\Delta s = 0.03$ 米，$\\tau = 0.0005$ 米。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果（例如，$[[a,b,c,d], [\\dots], \\dots ]$），其中 $a$ 和 $d$ 是以米为单位的浮点数，而 $b$ 和 $c$ 是布尔值。",
            "solution": "当前的问题是一个在运动学和数值方法方面适定且科学上合理的练习，特别关于高能物理中的径迹拟合。它要求在一个简化的粒子轨迹模型下，对扩展卡尔曼滤波器（EKF）背景中的线性化误差进行分析。我们将首先验证所提供的公式，然后概述计算过程。\n\n一个动量为 $p$、电荷为 $q$ 的带电粒子穿过一个沿 $\\hat{z}$ 轴方向的匀强磁场 $B$。其在横向 $(x, y)$ 平面内的轨迹是一个圆。粒子的状态由向量 $\\mathbf{x}(s) = (x(s), y(s), \\varphi(s))^T$ 描述，该向量由弧长 $s$ 参数化。其分量是笛卡尔坐标 $x$ 和 $y$，以及航向角 $\\varphi$。\n\n动力学由以下常微分方程组决定：\n$$\n\\frac{d\\mathbf{x}}{ds} = \n\\begin{pmatrix} dx/ds \\\\ dy/ds \\\\ d\\varphi/ds \\end{pmatrix} =\n\\begin{pmatrix} \\cos\\varphi \\\\ \\sin\\varphi \\\\ \\kappa \\end{pmatrix} = f(\\mathbf{x})\n$$\n此处，$\\kappa = qB/p$ 是有符号曲率，假定在一个小的传播步长 $\\Delta s$ 内是恒定的。函数 $f(\\mathbf{x})$ 是非线性漂移函数。\n\nEKF 通过对动力学进行线性化来传播状态估计。状态向量增量 $\\Delta\\mathbf{x} = \\mathbf{x}(s_0 + \\Delta s) - \\mathbf{x}(s_0)$ 在初始状态 $\\mathbf{x}_0 = \\mathbf{x}(s_0)$ 附近的泰勒展开为：\n$$\n\\Delta\\mathbf{x} = \\Delta s \\left.\\frac{d\\mathbf{x}}{ds}\\right|_{s_0} + \\frac{(\\Delta s)^2}{2!} \\left.\\frac{d^2\\mathbf{x}}{ds^2}\\right|_{s_0} + O((\\Delta s)^3)\n$$\n导数由以下公式给出：\n$$\n\\frac{d\\mathbf{x}}{ds} = f(\\mathbf{x})\n$$\n$$\n\\frac{d^2\\mathbf{x}}{ds^2} = \\frac{d}{ds}f(\\mathbf{x}(s)) = \\frac{\\partial f}{\\partial \\mathbf{x}} \\frac{d\\mathbf{x}}{ds} = J(\\mathbf{x}) f(\\mathbf{x})\n$$\n其中 $J(\\mathbf{x}) = \\frac{\\partial f}{\\partial \\mathbf{x}}$ 是漂移函数的雅可比矩阵。因此，截至二阶的增量为：\n$$\n\\Delta\\mathbf{x} \\approx \\Delta s \\, f(\\mathbf{x}_0) + \\frac{(\\Delta s)^2}{2} J(\\mathbf{x}_0) f(\\mathbf{x}_0)\n$$\nEKF 对位置增量 $\\Delta\\mathbf{r}_{\\mathrm{EKF}}$ 的一阶预测对应于第一项，并限制在位置分量 $(x, y)$ 上：\n$$\n\\Delta\\mathbf{r}_{\\mathrm{EKF}} = \\Delta s \\begin{pmatrix} \\cos\\varphi_0 \\\\ \\sin\\varphi_0 \\end{pmatrix}\n$$\n二阶泰勒预测 $\\Delta\\mathbf{r}_2$ 包括下一项：\n$$\n\\Delta\\mathbf{r}_{2} = \\Delta s \\begin{pmatrix} \\cos\\varphi_0 \\\\ \\sin\\varphi_0 \\end{pmatrix} + \\frac{(\\Delta s)^2}{2} \\big[J(\\mathbf{x}_0) f(\\mathbf{x}_0)\\big]_{x,y}\n$$\n为验证问题中提供的项，我们计算雅可比矩阵 $J(\\mathbf{x})$：\n$$\nJ(\\mathbf{x}) = \\frac{\\partial}{\\partial (x,y,\\varphi)} \\begin{pmatrix} \\cos\\varphi \\\\ \\sin\\varphi \\\\ \\kappa \\end{pmatrix} = \\begin{pmatrix} 0  0  -\\sin\\varphi \\\\ 0  0  \\cos\\varphi \\\\ 0  0  0 \\end{pmatrix}\n$$\n然后我们计算乘积 $J(\\mathbf{x})f(\\mathbf{x})$：\n$$\nJ(\\mathbf{x})f(\\mathbf{x}) = \\begin{pmatrix} 0  0  -\\sin\\varphi \\\\ 0  0  \\cos\\varphi \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} \\cos\\varphi \\\\ \\sin\\varphi \\\\ \\kappa \\end{pmatrix} = \\begin{pmatrix} -\\kappa\\sin\\varphi \\\\ \\kappa\\cos\\varphi \\\\ 0 \\end{pmatrix}\n$$\n这证实了问题描述中给出的表达式 $J(\\mathbf{x}_0) f(\\mathbf{x}_0) = \\kappa(-\\sin\\varphi_0, \\cos\\varphi_0, 0)^T$。\n\n线性化误差 $e_{\\mathrm{lin}}$ 定义为二阶和一阶位置增量预测值之差的模：\n$$\ne_{\\mathrm{lin}} = \\| \\Delta\\mathbf{r}_2 - \\Delta\\mathbf{r}_{\\mathrm{EKF}} \\| = \\left\\| \\frac{(\\Delta s)^2}{2} \\big[J(\\mathbf{x}_0) f(\\mathbf{x}_0)\\big]_{x,y} \\right\\|\n$$\n代入推导出的表达式：\n$$\ne_{\\mathrm{lin}} = \\left\\| \\frac{(\\Delta s)^2}{2} \\begin{pmatrix} -\\kappa\\sin\\varphi_0 \\\\ \\kappa\\cos\\varphi_0 \\end{pmatrix} \\right\\| = \\frac{(\\Delta s)^2}{2} |\\kappa| \\sqrt{(-\\sin\\varphi_0)^2 + (\\cos\\varphi_0)^2} = \\frac{1}{2} |\\kappa| (\\Delta s)^2\n$$\n这个结果值得注意。它表明，对于这个特定的运动学模型，问题中给出的误差界 $\\left\\| \\Delta \\mathbf{r}_{2} - \\Delta \\mathbf{r}_{\\mathrm{EKF}} \\right\\| \\le \\frac{1}{2} |\\kappa| (\\Delta s)^2$ 实际上是一个等式。\n\n任务要求计算两个布尔标志。第一个，$ok_{\\mathrm{actual}}$，检查计算出的线性化误差是否在指定的容差 $\\tau$ 之内：\n$$\nok_{\\mathrm{actual}} \\iff e_{\\mathrm{lin}} \\le \\tau \\iff \\frac{1}{2} |\\kappa| (\\Delta s)^2 \\le \\tau\n$$\n第二个，$ok_{\\mathrm{criterion}}$，检查步长 $\\Delta s$ 是否遵守推导出的最大步长 $\\Delta s_{\\max}$。这个最大步长的定义是为了将误差界保持在 $\\tau$ 以下。对于 $\\kappa \\ne 0$：\n$$\n\\frac{1}{2} |\\kappa| (\\Delta s)^2 \\le \\tau \\implies (\\Delta s)^2 \\le \\frac{2\\tau}{|\\kappa|} \\implies \\Delta s \\le \\sqrt{\\frac{2\\tau}{|\\kappa|}}\n$$\n这得出 $\\Delta s_{\\max} = \\sqrt{\\frac{2\\tau}{|\\kappa|}}$。因此，条件 $\\Delta s \\le \\Delta s_{\\max}$ 在数学上等价于 $e_{\\mathrm{lin}} \\le \\tau$。对于 $\\kappa = 0$ 的情况，$e_{\\mathrm{lin}} = 0$，所以对于任何 $\\tau \\ge 0$，$e_{\\mathrm{lin}} \\le \\tau$ 都成立。相应的 $\\Delta s_{\\max}$ 取为一个大数（$10^9$ 米），因此对于任何合理的步长，$\\Delta s \\le \\Delta s_{\\max}$ 也将成立。因此，对于所有有效的测试用例，两个布尔标志 $ok_{\\mathrm{actual}}$ 和 $ok_{\\mathrm{criterion}}$ 必须相同。\n\n每个测试用例 $(\\varphi_0, \\kappa, \\Delta s, \\tau)$ 的计算步骤如下：\n$1$. 计算线性化误差：$e_{\\mathrm{lin}} = \\frac{1}{2} |\\kappa| (\\Delta s)^2$。\n$2$. 确定第一个布尔值：$ok_{\\mathrm{actual}} = (e_{\\mathrm{lin}} \\le \\tau)$。\n$3$. 计算最大允许步长：如果 $\\kappa \\ne 0$，则 $\\Delta s_{\\max} = \\sqrt{2\\tau/|\\kappa|}$；如果 $\\kappa = 0$，则 $\\Delta s_{\\max} = 10^9$。\n$4$. 确定第二个布尔值：$ok_{\\mathrm{criterion}} = (\\Delta s \\le \\Delta s_{\\max})$。\n$5$. 收集四个结果：$[e_{\\mathrm{lin}}, ok_{\\mathrm{actual}}, ok_{\\mathrm{criterion}}, \\Delta s_{\\max}]$。\n将为每个提供的测试用例实施此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs computations related to the EKF linearization error for a simplified\n    particle tracking model, as specified in the problem statement.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (phi0_rad, kappa_inv_m, ds_m, tau_m)\n    test_cases = [\n        # General case\n        (0.0, 0.001, 0.1, 0.0001),\n        # Boundary case\n        (np.pi / 4, 0.01, np.sqrt(1e-5), 0.00005),\n        # Edge case (straight line)\n        (np.pi, 0.0, 10.0, 0.000001),\n        # High-curvature violation\n        (np.pi / 3, 1.0, 0.05, 0.001),\n        # Negative curvature\n        (np.pi / 6, -0.5, 0.03, 0.0005),\n    ]\n\n    results = []\n    for case in test_cases:\n        phi0, kappa, ds, tau = case\n\n        # 1. Compute the linearization error, e_lin\n        # As derived, e_lin = 0.5 * |kappa| * ds^2\n        e_lin = 0.5 * np.abs(kappa) * ds**2\n\n        # 2. Check if the actual computed e_lin is less than or equal to the tolerance tau\n        ok_actual = e_lin = tau\n\n        # 3. Compute the step-size criterion, ds_max\n        if kappa != 0:\n            ds_max = np.sqrt(2 * tau / np.abs(kappa))\n        else:\n            # Sentinel value for an effectively unbounded step in the straight-line case\n            ds_max = 1e9\n        \n        # 4. Check if the provided step size ds satisfies the criterion ds = ds_max\n        ok_criterion = ds = ds_max\n        \n        # Aggregate the results for the current test case.\n        # As established by the derivation, ok_actual and ok_criterion should be identical.\n        # This serves as an internal consistency check of the model and its implementation.\n        results.append([e_lin, ok_actual, ok_criterion, ds_max])\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists, constructed by joining\n    # the string representations of the inner lists with a comma.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了估计连续的径迹参数外，卡尔曼滤波器还是一个用于统计假设检验的强大框架。径迹重建中的一个基本问题是确定粒子的电荷符号，因为它决定了粒子在磁场中的偏转方向。这个动手实践问题演示了如何通过并行运行两个竞争性的卡尔曼滤波器来解决这个模糊性：一个假设为正电荷，另一个假设为负电荷 。通过比较每次拟合的拟合优度统计量（即白化新息的平方和，或称 $\\chi^2$），您将学会如何做出基于统计的决策，从而展示该滤波器如何用于区分不同的物理模型。",
            "id": "3539001",
            "problem": "您的任务是实现一项数值研究，通过比较从两个以相反符号的荷动比参数初始化的竞争拟合中获得的创新序列，来分析使用卡尔曼滤波器进行径迹拟合时电荷符号判定的灵敏度。工作在横向 $x$-$y$ 平面内，存在一个沿 $z$ 轴方向的均匀磁场 $B$。您需要从基本定律和经过充分检验的公式出发，进行基于物理的建模和算法推导，并生成一个单一的可运行程序，对一组指定的测试用例执行模拟和拟合。\n\n使用的基本原理如下。在均匀磁场中，相对论性带电粒子的运动由洛伦兹力定律支配，在横向平面上产生圆周运动。曲率与荷动比之间的关系由广泛使用的公式 $R = \\frac{p}{0.3\\,|q|\\,B}$ 给出，当 $B$ 的单位为特斯拉、$p$ 的单位为 $\\mathrm{GeV}/c$ 时，半径 $R$ 的单位为米。这给出的曲率 $\\kappa = \\frac{1}{R} = \\frac{0.3\\,q\\,B}{p}$ 的单位为 $\\mathrm{m}^{-1}$。对于薄材料中的多重散射，使用 Highland 公式计算散射角均方根 $\\theta_0$（单位为弧度）：$\\theta_0 \\approx \\frac{13.6\\,\\mathrm{MeV}}{\\beta\\,p\\,c}\\sqrt{\\frac{x}{X_0}}\\left[1 + 0.038 \\ln\\left(\\frac{x}{X_0}\\right)\\right]$，其中对于相对论性粒子 $\\beta \\approx 1$，$p$ 是动量，$x$ 是厚度，$X_0$ 是辐射长度。在本研究中，您可以假设 $\\beta \\approx 1$ 并将 $13.6\\,\\mathrm{MeV}$ 表示为 $0.0136\\,\\mathrm{GeV}$。\n\n请推导一个适用于包含 $q/p$ 的卡尔曼滤波器状态参数化的小角度线性化 $x$ 投影运动学模型。状态应表示为 $x_k = [y_k, t_k, (q/p)_k]^T$，其中 $y_k$ 是横向位置（单位：米），$t_k = \\frac{dy}{dx}$ 是局部斜率（无量纲，等于角度的正切，在小角度近似下约等于角度的弧度值），$(q/p)_k$ 是荷动比（单位：$(\\mathrm{GeV}/c)^{-1}$）。在均匀磁场 $B$ 下，推导经过一个步长 $\\Delta x_k$ 的线性化传播，并构建相应的状态转移模型和过程噪声模型。过程噪声模型应由多重散射提供信息，表现为斜率分量上的一个高斯分布，其方差根据 Highland 公式推导。测量模型包括对 $y$ 的带噪声测量，噪声为已知方差的高斯噪声。\n\n卡尔曼滤波器应在每一层计算新息 $e_k = z_k - H x_{k|k-1}$、新息协方差 $S_k$ 和白化新息序列 $w_k = \\frac{e_k}{\\sqrt{S_k}}$。为每次拟合定义一个判别统计量，即白化新息平方和 $J = \\sum_k w_k^2$。执行两次拟合，初始化的先验均值和协方差完全相同，除了初始 $(q/p)$ 分量的符号相反（一个为正，一个为负，大小相同）。通过选择具有较小 $J$ 值的拟合来决定电荷符号。如果两次拟合的 $J$ 值绝对差小于一个固定的阈值 $\\tau$（必须根据 $J$ 的预期尺度选择并给出理由），则通过选择正符号来解决平局。\n\n您必须为以下测试套件实现径迹和击中点的完整模拟。对于每个案例，在沿 $x$ 轴从 $x = 0$ 开始，生成 $N$ 个间距为 $\\Delta x$ 的测量层，初始横向位置 $y_0 = 0\\,\\mathrm{m}$，初始斜率 $t_0 = 0$（弧度）。在每一步中，应用真实径迹参数的运动学，向斜率添加一个高斯多重散射扰动（其标准差 $\\theta_0$ 根据指定的 $x/X_0$ 由 Highland 公式计算得出），最后生成一个对 $y_k$ 的带噪声测量 $z_k$，其高斯噪声的标准差为 $\\sigma_{\\mathrm{meas}}$。角度必须以弧度为单位，长度以米为单位。磁场单位必须是特斯拉；动量单位是 $\\mathrm{GeV}/c$。\n\n使用以下测试套件参数集，所有未指定的物理量均默认为上述描述。对于每个测试用例，都指定了基准真相电荷符号，必须用其生成击中点；您的程序应报告算法选择的符号是否与基准真相匹配。多重散射分数 $x/X_0$ 是每层的数值。\n\n- 案例 1：$N = 12$，$\\Delta x = 0.05\\,\\mathrm{m}$，$B = 2.0\\,\\mathrm{T}$，$p = 3.0\\,\\mathrm{GeV}/c$，$q = +1$，$\\sigma_{\\mathrm{meas}} = 5.0\\times 10^{-4}\\,\\mathrm{m}$，$x/X_0 = 5.0\\times 10^{-3}$。\n- 案例 2：$N = 10$，$\\Delta x = 0.03\\,\\mathrm{m}$，$B = 3.8\\,\\mathrm{T}$，$p = 1.5\\,\\mathrm{GeV}/c$，$q = -1$，$\\sigma_{\\mathrm{meas}} = 8.0\\times 10^{-4}\\,\\mathrm{m}$，$x/X_0 = 1.0\\times 10^{-2}$。\n- 案例 3：$N = 15$，$\\Delta x = 0.04\\,\\mathrm{m}$，$B = 0.02\\,\\mathrm{T}$，$p = 10.0\\,\\mathrm{GeV}/c$，$q = -1$，$\\sigma_{\\mathrm{meas}} = 1.0\\times 10^{-3}\\,\\mathrm{m}$，$x/X_0 = 5.0\\times 10^{-3}$。\n- 案例 4：$N = 12$，$\\Delta x = 0.06\\,\\mathrm{m}$，$B = 1.0\\,\\mathrm{T}$，$p = 2.0\\,\\mathrm{GeV}/c$，$q = +1$，$\\sigma_{\\mathrm{meas}} = 5.0\\times 10^{-3}\\,\\mathrm{m}$，$x/X_0 = 2.0\\times 10^{-2}$。\n- 案例 5：$N = 3$，$\\Delta x = 0.08\\,\\mathrm{m}$，$B = 2.0\\,\\mathrm{T}$，$p = 4.0\\,\\mathrm{GeV}/c$，$q = -1$，$\\sigma_{\\mathrm{meas}} = 2.0\\times 10^{-3}\\,\\mathrm{m}$，$x/X_0 = 5.0\\times 10^{-3}$。\n\n您的程序必须：\n\n- 实现一个从洛伦兹力推导出的、为小角度线性化的、物理上一致的运动学模型，以及一个包含由多重散射提供的斜率分量过程噪声项的卡尔曼滤波器模型。\n- 对于每个测试用例，模拟击中点序列，并执行两次卡尔曼滤波器拟合，分别以 $(q/p)_0 = \\pm |q/p|_{\\mathrm{true}}$ 和相同的先验协方差进行初始化；计算新息序列、相应的 $J$ 值，并根据最小的 $J$ 值选择符号，同时应用 $\\Delta J  \\tau$ 的平局解决规则。\n- 对于每个测试用例，报告一个布尔值，指示所选符号是否与模拟中使用的基准真相符号相等。\n\n角度单位必须是弧度，磁场单位是特斯拉，动量单位是 $\\mathrm{GeV}/c$，距离单位是米。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[{\\mathrm{result}_1},{\\mathrm{result}_2},\\dots]$，其中每个 ${\\mathrm{result}_i}$ 是为相应测试用例计算的布尔值。",
            "solution": "该问题被评估为有效。它在科学上基于粒子物理学和状态估计的原理，问题设定清晰，目标明确，信息充分，并使用客观、正式的语言。任务是使用卡尔曼滤波器实现对磁场中被跟踪粒子的电荷符号判定的数值研究，这是一个计算高能物理学中的标准且不平凡的问题。\n\n解决方案首先推导必要的状态空间模型，然后指定卡尔曼滤波器算法，概述模拟过程，最后详细说明电荷判别方法。\n\n**1. 状态空间模型推导**\n\n分析了带电粒子在沿 $z$ 轴的均匀磁场 $B$ 下于横向 $x$-$y$ 平面内的运动。我们采用适合卡尔曼滤波器的状态空间表示，其中状态沿 $x$ 轴演化。\n\n**状态向量：** 粒子在给定平面 $x=x_k$ 的状态由向量描述：\n$$\n\\mathbf{x}_k = \\begin{pmatrix} y_k \\\\ t_k \\\\ \\eta_k \\end{pmatrix}\n$$\n其中 $y_k$ 是横向位置（单位：米），$t_k = \\frac{dy}{dx}$ 是径迹斜率（近似为俯仰角 $\\tan\\phi_y$ 的正切），$\\eta_k = (q/p)_k$ 是带符号的荷动比（单位：$(\\mathrm{GeV}/c)^{-1}$）。\n\n**状态转移模型（运动学）：**\n洛伦兹力定律决定了在 $x$-$y$ 平面上的圆形轨迹。对于小角度，路径长度 $ds \\approx dx$，斜率相对于 $x$ 的变化由下式给出：\n$$\n\\frac{dt}{dx} \\approx \\frac{d^2y}{dx^2} \\approx \\kappa = \\frac{1}{R}\n$$\n其中 $\\kappa$ 是曲率。使用给定的公式，$\\kappa = c_B \\eta$，常数 $c_B = 0.3 B$。动量 $p$ 假设恒定（无能量损失），因此 $\\eta_k$ 是恒定的。控制确定性运动的微分方程是：\n$$\n\\frac{dy}{dx} = t(x), \\quad \\frac{dt}{dx} = c_B \\eta, \\quad \\frac{d\\eta}{dx} = 0\n$$\n假设在一个步长内 $\\eta$ 恒定，将这些方程从 $x_{k-1}$ 积分到 $x_k = x_{k-1} + \\Delta x$ 得到状态变量的精确传播：\n\\begin{align*}\nt_k = t_{k-1} + \\int_{x_{k-1}}^{x_k} c_B \\eta_{k-1} \\,dx' = t_{k-1} + c_B \\eta_{k-1} \\Delta x \\\\\ny_k = y_{k-1} + \\int_{x_{k-1}}^{x_k} t(x') \\,dx' = y_{k-1} + \\int_{x_{k-1}}^{x_k} (t_{k-1} + c_B \\eta_{k-1} (x' - x_{k-1})) \\,dx' \\\\\n= y_{k-1} + t_{k-1} \\Delta x + \\frac{1}{2} c_B \\eta_{k-1} (\\Delta x)^2 \\\\\n\\eta_k = \\eta_{k-1}\n\\end{align*}\n这导出了线性化状态转移模型 $\\mathbf{x}_{k|k-1} = F_k \\mathbf{x}_{k-1|k-1}$，其中状态转移矩阵 $F_k$（对于固定的 $\\Delta x$ 是常数）为：\n$$\nF = \\begin{pmatrix}\n1  \\Delta x  \\frac{1}{2} c_B (\\Delta x)^2 \\\\\n0  1  c_B \\Delta x \\\\\n0  0  1\n\\end{pmatrix}\n$$\n\n**过程噪声模型（多重散射）：**\n当粒子穿过材料时，它会经历多重库仑散射，这是一个主要使其角度偏转的随机过程。这被建模为过程噪声。在一个步长 $\\Delta x$ 内，投影散射角的方差由 Highland 公式的平方给出，即 $\\theta_0^2$：\n$$\n\\theta_0^2 = \\left( \\frac{0.0136\\,\\mathrm{GeV}}{p} \\sqrt{\\frac{\\Delta x}{X_0}} \\left[1 + 0.038 \\ln\\left(\\frac{\\Delta x}{X_0}\\right)\\right] \\right)^2\n$$\n其中 $p = |q|/|\\eta| \\approx 1/|\\eta_{k-1|k-1}|_。将散射视为沿路径的角度上的连续随机游走（维纳过程），可以通过积分效应得到状态 $(y, t)$ 在一个步长 $\\Delta x$ 上的协方差。这产生了过程噪声协方差矩阵 $Q_k$：\n$$\nQ_k = \\theta_0^2 \\begin{pmatrix}\n(\\Delta x)^2/3  \\Delta x/2  0 \\\\\n\\Delta x/2  1  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n带有噪声的完整状态转移为 $\\mathbf{x}_k = F \\mathbf{x}_{k-1} + \\mathbf{w}_{k-1}$，其中 $\\mathbf{w}_{k-1}$ 是均值为零、协方差为 $Q_k$ 的高斯噪声。\n\n**测量模型：**\n探测器提供对横向位置 $y_k$ 的带噪声测量。\n$$\nz_k = y_k + \\nu_k, \\quad \\nu_k \\sim \\mathcal{N}(0, \\sigma_{\\mathrm{meas}}^2)\n$$\n在状态空间形式中，$z_k = H \\mathbf{x}_k + \\nu_k$，测量矩阵 $H$ 和测量噪声协方差 $R_k$ 由下式给出：\n$$\nH = \\begin{pmatrix} 1  0  0 \\end{pmatrix}, \\quad R_k = \\sigma_{\\mathrm{meas}}^2\n$$\n\n**2. 卡尔曼滤波器算法**\n\n滤波器迭代地预测状态到下一个测量层，然后使用测量信息更新预测。从一个先验估计 $\\mathbf{x}_{0|0}$ 及其协方差 $C_{0|0}$ 开始，对于在层 $k=1, \\dots, N$ 的每个测量 $z_k$：\n\n1.  **预测：**\n    \\begin{align*}\n    \\mathbf{x}_{k|k-1} = F \\mathbf{x}_{k-1|k-1} \\quad (\\text{预测状态}) \\\\\n    C_{k|k-1} = F C_{k-1|k-1} F^T + Q_{k-1} \\quad (\\text{预测协方差})\n    \\end{align*}\n    其中 $Q_{k-1}$ 使用来自 $\\mathbf{x}_{k-1|k-1}$ 的动量估计来计算。\n\n2.  **更新：**\n    \\begin{align*}\n    e_k = z_k - H \\mathbf{x}_{k|k-1} \\quad (\\text{新息}) \\\\\n    S_k = H C_{k|k-1} H^T + R_k \\quad (\\text{新息协方差}) \\\\\n    K_k = C_{k|k-1} H^T S_k^{-1} \\quad (\\text{卡尔曼增益}) \\\\\n    \\mathbf{x}_{k|k} = \\mathbf{x}_{k|k-1} + K_k e_k \\quad (\\text{更新后状态}) \\\\\n    C_{k|k} = (I - K_k H) C_{k|k-1} \\quad (\\text{更新后协方差})\n    \\end{align*}\n\n**3. 模拟与电荷判别**\n\n对于每个测试用例，模拟一个基准真相径迹轨迹和相应的测量。\n\n**模拟：**\n- 定义一个真实的初始状态 $\\mathbf{x}_{\\mathrm{true},0} = [0, 0, (q/p)_{\\mathrm{true}}]^T$。\n- 对于每一层 $k=1, \\dots, N$：\n    1. 使用运动学模型确定性地传播真实状态，以找到位置 $y_{\\mathrm{true}, k}$ 和斜率 $t_{\\mathrm{true}, k, \\text{no scatter}}$。\n    2. 向斜率添加一个随机角度扰动 $\\delta t_k \\sim \\mathcal{N}(0, \\theta_{0, \\mathrm{true}}^2)$ 来模拟多重散射：$t_{\\mathrm{true}, k} = t_{\\mathrm{true},k, \\text{no scatter}} + \\delta t_k$。\n    3. 生成一个测量 $z_k = y_{\\mathrm{true},k} + \\nu_k$，其中 $\\nu_k \\sim \\mathcal{N}(0, \\sigma_{\\mathrm{meas}}^2)$。\n\n**电荷符号判定：**\n对模拟的测量集 $\\{z_k\\}_{k=1}^N$ 运行两个独立的卡尔曼滤波器：\n- **拟合 1 (正电荷假设):** 初始化 $\\mathbf{x}_{0|0}^+ = [0, 0, |(q/p)_{\\mathrm{true}}|]^T$。\n- **拟合 2 (负电荷假设):** 初始化 $\\mathbf{x}_{0|0}^- = [0, 0, -|(q/p)_{\\mathrm{true}}|]^T$。\n\n两个拟合都使用相同的初始协方差矩阵 $C_{0|0}$，该矩阵选择为反映对初始位置和斜率（$y_0=0, t_0=0$）的高置信度以及对初始动量猜测的中等不确定性。\n\n对于每次拟合，计算代表拟合总卡方值的判别统计量 $J$，即白化新息的平方和：\n$$\nJ = \\sum_{k=1}^{N} w_k^2 = \\sum_{k=1}^{N} \\frac{e_k^2}{S_k}\n$$\n通过比较 $J_+$ 和 $J_-$ 来确定电荷符号：\n- 如果 $|J_+ - J_-|  \\tau$，则通过选择正电荷符号来解决模糊性。\n- 否则，选择对应于较小 $J$ 值的符号。\n\n选择一个固定的阈值 $\\tau=1.0$。这是一个常见的选择，对应于 $\\Delta\\chi^2=1$ 准则，它与单个参数估计的一倍标准差置信区间相关。它为宣告两个假设在统计上不可区分提供了一个合理但非特别强的阈值。\n\n程序随后将确定的符号与模拟中使用的基准真相符号进行比较，并为每个测试用例报告一个布尔值结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and Kalman filter fits for all test cases.\n    \"\"\"\n    # Set a fixed random seed for reproducibility of the simulation.\n    np.random.seed(42)\n\n    # Test cases as specified in the problem statement.\n    # Format: (N, dx, B, p, q, sigma_meas, dx/X0)\n    test_cases = [\n        (12, 0.05, 2.0, 3.0, +1, 5.0e-4, 5.0e-3),\n        (10, 0.03, 3.8, 1.5, -1, 8.0e-4, 1.0e-2),\n        (15, 0.04, 0.02, 10.0, -1, 1.0e-3, 5.0e-3),\n        (12, 0.06, 1.0, 2.0, +1, 5.0e-3, 2.0e-2),\n        (3, 0.08, 2.0, 4.0, -1, 2.0e-3, 5.0e-3),\n    ]\n\n    results = []\n    \n    # Threshold for charge-sign ambiguity. Justified as a standard Delta chi^2 = 1 cut.\n    tau = 1.0\n\n    for params in test_cases:\n        _, _, _, p_true, q_true, _, _ = params\n        \n        # 1. Simulate the track to generate measurements.\n        measurements = _simulate_track(params)\n        \n        # 2. Run two Kalman filter fits with opposite charge hypotheses.\n        # Positive charge hypothesis\n        q_p_pos_hyp = abs(q_true / p_true)\n        J_pos = _run_kalman_filter(measurements, params, q_p_pos_hyp)\n\n        # Negative charge hypothesis\n        q_p_neg_hyp = -abs(q_true / p_true)\n        J_neg = _run_kalman_filter(measurements, params, q_p_neg_hyp)\n\n        # 3. Apply the decision logic to determine the charge sign.\n        determined_q = 0\n        if abs(J_pos - J_neg)  tau:\n            determined_q = +1  # Tie-breaking rule: select positive sign\n        elif J_pos  J_neg:\n            determined_q = +1\n        else:\n            determined_q = -1\n        \n        # 4. Compare the determined sign with the ground truth.\n        is_correct = (determined_q == q_true)\n        results.append(is_correct)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef _highland_formula(p_gev, dx_over_X0):\n    \"\"\"\n    Calculates the RMS multiple scattering angle using the Highland formula.\n    \n    Args:\n        p_gev (float): Momentum in GeV/c.\n        dx_over_X0 (float): Material thickness in units of radiation length.\n        \n    Returns:\n        float: Root mean square of the projected scattering angle (theta_0) in radians.\n    \"\"\"\n    if p_gev == 0: return float('inf')\n    # The term dx_over_X0 is assumed to be > 0.\n    if dx_over_X0 == 0: return 0.0\n    \n    term_sqrt = np.sqrt(dx_over_X0)\n    term_log = 1.0 + 0.038 * np.log(dx_over_X0) if dx_over_X0 > 0 else 1.0\n    theta0 = (0.0136 / p_gev) * term_sqrt * term_log\n    return theta0\n\n\ndef _simulate_track(params):\n    \"\"\"\n    Generates a sequence of measurements for a particle traversing a detector.\n    This function uses a more precise propagation model than the filter for realism.\n    \n    Args:\n        params (tuple): A tuple containing the simulation parameters.\n        \n    Returns:\n        list: A list of noisy position measurements (z_k).\n    \"\"\"\n    N, dx, B, p_true, q_true, sigma_meas, dx_over_X0 = params\n    eta_true = q_true / p_true\n    C_B = 0.3 * B\n\n    y_true = 0.0\n    t_true = 0.0\n    measurements = []\n    \n    for _ in range(N):\n        # Propagate deterministically (bend in B-field)\n        y_next = y_true + t_true * dx + 0.5 * C_B * eta_true * dx**2\n        t_next_no_scatter = t_true + C_B * eta_true * dx\n\n        # Add multiple scattering kick at the end of the step\n        theta0_true = _highland_formula(p_true, dx_over_X0)\n        delta_t = np.random.normal(0.0, theta0_true)\n        t_next = t_next_no_scatter + delta_t\n\n        # Update true state for the next step\n        y_true, t_true = y_next, t_next\n\n        # Generate a noisy measurement of the position\n        measurement_noise = np.random.normal(0.0, sigma_meas)\n        z = y_true + measurement_noise\n        measurements.append(z)\n\n    return measurements\n\n\ndef _run_kalman_filter(measurements, params, initial_q_over_p):\n    \"\"\"\n    Runs a Kalman filter over a sequence of measurements.\n    \n    Args:\n        measurements (list): The sequence of position measurements.\n        params (tuple): A tuple containing the simulation parameters.\n        initial_q_over_p (float): The initial guess for the q/p state component.\n        \n    Returns:\n        float: The total chi-squared (J) for the fit.\n    \"\"\"\n    N, dx, B, _, _, sigma_meas, dx_over_X0 = params\n    C_B = 0.3 * B\n    \n    # Initial state vector: [y, t, q/p]\n    x_est = np.array([0.0, 0.0, initial_q_over_p])\n\n    # Initial covariance matrix C_0|0 reflects prior knowledge at x=0.\n    # y0=0, t0=0 are known, so their initial variances are small.\n    # The initial q/p guess has a larger uncertainty (e.g., 50% on momentum).\n    sigma_y0_sq = (1e-6)**2\n    sigma_t0_sq = (1e-4)**2\n    sigma_q_p_sq = (0.5 * initial_q_over_p)**2 if initial_q_over_p != 0 else 1.0\n    C_est = np.diag([sigma_y0_sq, sigma_t0_sq, sigma_q_p_sq])\n\n    H = np.array([[1.0, 0.0, 0.0]])\n    R_k = np.array([[sigma_meas**2]])\n    F = np.array([\n        [1.0, dx, 0.5 * C_B * dx**2],\n        [0.0, 1.0, C_B * dx],\n        [0.0, 0.0, 1.0]\n    ])\n\n    J_statistic = 0.0\n\n    for z_k in measurements:\n        # --- PREDICTION STEP ---\n        # Process noise covariance Q depends on the momentum from the previous step.\n        q_p_est = x_est[2]\n        p_est = abs(1.0 / q_p_est) if q_p_est != 0 else float('inf')\n        theta0 = _highland_formula(p_est, dx_over_X0)\n        theta0_sq = theta0**2\n        \n        Q_k_minus_1 = np.zeros((3, 3))\n        if theta0_sq > 0 and not np.isinf(theta0_sq):\n            Q_k_minus_1[0, 0] = theta0_sq * (dx**2) / 3.0\n            Q_k_minus_1[0, 1] = theta0_sq * dx / 2.0\n            Q_k_minus_1[1, 0] = theta0_sq * dx / 2.0\n            Q_k_minus_1[1, 1] = theta0_sq\n            \n        x_pred = F @ x_est\n        C_pred = F @ C_est @ F.T + Q_k_minus_1\n\n        # --- UPDATE STEP ---\n        e_k = z_k - (H @ x_pred)[0]\n        S_k = (H @ C_pred @ H.T + R_k)[0, 0]\n        \n        if S_k == 0: return float('inf')\n\n        K_k = (C_pred @ H.T) / S_k\n        x_est = x_pred + K_k.flatten() * e_k\n        C_est = (np.eye(3) - K_k @ H) @ C_pred\n        \n        # Accumulate the chi-squared statistic J.\n        w_k_sq = (e_k**2) / S_k\n        J_statistic += w_k_sq\n\n    return J_statistic\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一个理论上正确的算法在实践中可能会因为有限精度计算的限制而彻底失败。协方差更新是卡尔曼滤波器的核心，但也是其在数值上最脆弱的部分，舍入误差可能导致协方差矩阵失去其对称性和正定性的基本属性，从而导致滤波器发散。本练习直面这一挑战，比较了标准的、计算上简洁的协方差更新公式与其代数上等价但在数值上更优越的“约瑟夫形式” 。通过在病态场景下实现并测试这两种形式，您将学会诊断、量化和缓解数值不稳定性，这是开发稳健的、生产级别的科学软件的一项至关重要的技能。",
            "id": "3538970",
            "problem": "考虑计算高能物理中用于带电粒子穿过硅探测器平面的线性化径迹参数更新。设状态向量为 $x \\in \\mathbb{R}^4$，按顺序包含局部参数 $x$-位置、$y$-位置、$x$-斜率和$y$-斜率。位置以毫米为单位测量，而斜率是无量纲的。单次测量 $z \\in \\mathbb{R}^2$ 提供了横向位置，其测量噪声协方差已知。假设一个线性高斯测量模型，其雅可比矩阵已知，该矩阵将状态映射到测量值。给定一个预测状态协方差 $P^- \\in \\mathbb{R}^{4 \\times 4}$、一个测量雅可比矩阵 $H \\in \\mathbb{R}^{2 \\times 4}$和一个测量噪声协方差 $R \\in \\mathbb{R}^{2 \\times 2}$。您的任务是从第一性原理出发，使用单精度算术实现两种不同的协方差更新实现：一种是源于线性高斯模型精确贝叶斯处理的数值稳定更新，另一种是常用的代数简化形式。然后，在有限精度算术中量化更新后协方差失去正半定性和对称性的风险，并提出一种混合精度保护策略以降低这些风险。\n\n使用以下符合上下文的基础和假设：线性高斯测量模型、联合高斯变量的条件协方差定义以及基本矩阵恒等式。所有数学实体用 LaTeX 表示。在问题陈述中，不要使用任何预先推导的协方差更新捷径公式。\n\n实现要求：\n- 处理 $4 \\times 4$ 协方差矩阵 $P^-$。位置以毫米为单位，斜率无量纲。\n- 测量雅可比矩阵 $H$ 将状态映射到测量的横向位置，代表局部平面近似：具体来说，使用一个选择前两个状态分量的 $H$。\n- 测量噪声协方差 $R$ 是对角矩阵，其对角线元素等于测量分辨率的平方（单位为毫米）。\n- 实现三种协方差更新：\n  1. 从线性高斯贝叶斯推导中获得的代数简化协方差更新的单精度算术实现。\n  2. 从相同推导中获得的数值稳定协方差更新的单精度算术实现，该实现在精确算术中保持正半定性。\n  3. 一种混合精度保护变体，它在双精度下执行关键的矩阵乘法和求逆，应用对称性恢复，并返回一个单精度协方差。\n\n风险量化指标：\n- 对于每个更新后的协方差 $P^+ \\in \\mathbb{R}^{4 \\times 4}$，计算对称化矩阵 $\\frac{1}{2}(P^+ + (P^+)^\\top)$ 的最小特征值，记为 $\\lambda_{\\min}$（浮点数）。负的 $\\lambda_{\\min}$ 表示失去了正半定性。该量在不同状态分量上具有混合的物理单位，应报告为无单位的浮点数。\n- 计算相对对称误差 $\\|\\Delta\\|_F / \\|P^+\\|_F$，其中 $\\Delta = P^+ - (P^+)^\\top$，$\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。报告为浮点数。\n- 仅针对位置子块计算一个具有物理意义的对角膨胀量，定义为必须在对角线上添加到 $2 \\times 2$ 位置块的最小非负抖动 $j_{\\text{pos}}$（单位为 $\\text{mm}^2$），以使该位置块成为正半定的。具体来说，如果 $P^+$ 的左上角 $2 \\times 2$ 对称化子块的最小特征值为 $\\lambda_{\\min}^{\\text{pos}}$，则 $j_{\\text{pos}} = \\max(0, -\\lambda_{\\min}^{\\text{pos}})$。将 $j_{\\text{pos}}$ 以 $\\text{mm}^2$ 为单位表示为浮点数。\n\n测试套件和参数：\n使用以下四个测试用例来检验不同的数值区间。对于每个用例，构造 $P^-$ 为 $P^- = D + U U^\\top$，其中 $D$ 是对角矩阵，其元素为状态分量标准差的平方，$U \\in \\mathbb{R}^{4 \\times 2}$ 是一个固定的低秩扰动，提供相关性。在每个用例中，使用选择位置的 $H$：$H = \\begin{bmatrix} 1  0  0  0 \\\\ 0  1  0  0 \\end{bmatrix}$。\n\n- 情况1（良态，典型的硅击中分辨率）：\n  - 状态标准差：$\\sigma_x = 0.05\\,\\text{mm}$，$\\sigma_y = 0.05\\,\\text{mm}$，$\\sigma_{t_x} = 0.001$，$\\sigma_{t_y} = 0.001$。\n  - 测量分辨率：$r_x = 0.02\\,\\text{mm}$，$r_y = 0.02\\,\\text{mm}$，所以 $R = \\operatorname{diag}(r_x^2, r_y^2)$。\n  - 低秩扰动：\n    $$U = \\begin{bmatrix}\n    0.005  -0.003 \\\\\n    0.004  0.002 \\\\\n    0.0005  -0.0002 \\\\\n    0.0004  0.0006\n    \\end{bmatrix}.$$\n- 情况2（位置协方差接近奇异，测量噪声极小，对求逆和单精度舍入构成压力）：\n  - 状态标准差：$\\sigma_x = 10^{-6}\\,\\text{mm}$，$\\sigma_y = 10^{-6}\\,\\text{mm}$，$\\sigma_{t_x} = 10^{2}$，$\\sigma_{t_y} = 10^{2}$。\n  - 测量分辨率：$r_x = 10^{-6}\\,\\text{mm}$，$r_y = 10^{-6}\\,\\text{mm}$。\n  - 低秩扰动：\n    $$U = \\begin{bmatrix}\n    10^{-9}  -10^{-9} \\\\\n    10^{-9}  10^{-9} \\\\\n    0.1  -0.1 \\\\\n    0.1  0.1\n    \\end{bmatrix}.$$\n- 情况3（高测量噪声主导更新）：\n  - 状态标准差：$\\sigma_x = 0.01\\,\\text{mm}$，$\\sigma_y = 0.01\\,\\text{mm}$，$\\sigma_{t_x} = 0.005$，$\\sigma_{t_y} = 0.005$。\n  - 测量分辨率：$r_x = 5.0\\,\\text{mm}$，$r_y = 5.0\\,\\text{mm}$。\n  - 低秩扰动：\n    $$U = \\begin{bmatrix}\n    0.002  0.0015 \\\\\n    0.001  -0.002 \\\\\n    0.0005  0.0003 \\\\\n    0.0004  -0.0001\n    \\end{bmatrix}.$$\n- 情况4（具有大动态范围的强病态协方差）：\n  - 状态标准差：$\\sigma_x = 10^{3}\\,\\text{mm}$，$\\sigma_y = 10^{-6}\\,\\text{mm}$，$\\sigma_{t_x} = 10.0$，$\\sigma_{t_y} = 10^{-3}$。\n  - 测量分辨率：$r_x = 0.1\\,\\text{mm}$，$r_y = 0.1\\,\\text{mm}$。\n  - 低秩扰动：\n    $$U = \\begin{bmatrix}\n    1.0  0.0 \\\\\n    0.0  10^{-7} \\\\\n    0.01  -0.02 \\\\\n    10^{-4}  5 \\times 10^{-5}\n    \\end{bmatrix}.$$\n\n程序输出：\n对于每个测试用例，按此确切顺序计算并收集以下六个浮点数：\n$[\\lambda_{\\min}^{\\text{simp32}}, \\lambda_{\\min}^{\\text{joseph32}}, \\lambda_{\\min}^{\\text{mixed}}, \\text{sym\\_err}^{\\text{simp32}}, \\text{sym\\_err}^{\\text{joseph32}}, j_{\\text{pos}}^{\\text{simp32}}]$，\n其中上标表示使用了哪种更新。将所有四个测试用例的结果按用例顺序聚合到一个列表中，并将每个用例的列表展平。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,\\dots,r_{24}]$）。所有抖动量 $j_{\\text{pos}}$ 必须以 $\\text{mm}^2$ 为单位表示，并报告为浮点数。此问题不使用角度。不使用百分比；所有量均以小数（浮点数）报告。",
            "solution": "该问题要求从第一性原理推导卡尔曼滤波器协方差更新的两种形式，并分析它们在有限精度算术中的数值稳定性。\n\n### **1. 从第一性原理推导**\n\n我们首先将线性高斯测量模型形式化。设测量前的状态向量为一个随机变量 $x \\in \\mathbb{R}^4$，服从均值为 $x^-$、协方差为 $P^- \\in \\mathbb{R}^{4 \\times 4}$ 的高斯概率密度函数。我们记作 $x \\sim \\mathcal{N}(x^-, P^-)$。状态向量的分量为 $(x_{\\text{pos}}, y_{\\text{pos}}, t_x, t_y)$，其中位置以毫米为单位，斜率 $t_x, t_y$ 无量纲。\n\n测量过程被建模为状态的线性变换，并受到加性高斯噪声的干扰。测量值 $z \\in \\mathbb{R}^2$ 与状态 $x$ 通过以下方程相关联：\n$$z = Hx + v$$\n其中 $H \\in \\mathbb{R}^{2 \\times 4}$ 是测量雅可比矩阵，$v \\in \\mathbb{R}^2$ 是测量噪声。噪声被假设为一个零均值高斯随机变量，$v \\sim \\mathcal{N}(0, R)$，其协方差 $R \\in \\mathbb{R}^{2 \\times 2}$ 已知。状态 $x$ 和噪声 $v$ 被假设为不相关。\n\n滤波步骤的目标是找到在给定测量值 $z$ 条件下状态 $x$ 的后验分布，即 $p(x|z)$。对于线性高斯系统，该后验分布也是高斯的，$x|z \\sim \\mathcal{N}(x^+, P^+)$。更新后的协方差 $P^+$ 与状态均值和具体的测量值 $z$ 无关；它仅依赖于先验协方差 $P^-$ 以及测量模型的参数 $H$ 和 $R$。\n\n为了推导 $P^+$，我们考虑堆叠向量 $\\begin{pmatrix} x \\\\ z \\end{pmatrix}$ 的联合分布。由于 $x$ 和 $z$ 是联合高斯分布的，该向量服从多元正态分布。其均值为：\n$$E\\left[\\begin{pmatrix} x \\\\ z \\end{pmatrix}\\right] = \\begin{pmatrix} E[x] \\\\ E[Hx + v] \\end{pmatrix} = \\begin{pmatrix} x^- \\\\ H E[x] + E[v] \\end{pmatrix} = \\begin{pmatrix} x^- \\\\ Hx^- \\end{pmatrix}$$\n联合向量的协方差矩阵是一个分块矩阵：\n$$\\text{Cov}\\left(\\begin{pmatrix} x \\\\ z \\end{pmatrix}\\right) = \\begin{pmatrix} \\text{Cov}(x, x)  \\text{Cov}(x, z) \\\\ \\text{Cov}(z, x)  \\text{Cov}(z, z) \\end{pmatrix}$$\n我们计算每个分块：\n- $\\text{Cov}(x, x) = P^-$ (根据定义)。\n- $\\text{Cov}(x, z) = \\text{Cov}(x, Hx + v) = \\text{Cov}(x, Hx) + \\text{Cov}(x, v) = \\text{Cov}(x, x)H^\\top + 0 = P^- H^\\top$，因为 $x$ 和 $v$ 不相关。\n- $\\text{Cov}(z, x) = \\text{Cov}(Hx + v, x) = (\\text{Cov}(x, Hx+v))^\\top = (P^- H^\\top)^\\top = H (P^-)^\\top$。由于协方差矩阵是对称的，$(P^-)^\\top = P^-$，所以 $\\text{Cov}(z, x) = H P^-$。\n- $\\text{Cov}(z, z) = \\text{Cov}(Hx + v, Hx + v) = \\text{Cov}(Hx, Hx) + \\text{Cov}(Hx, v) + \\text{Cov}(v, Hx) + \\text{Cov}(v, v)$。交叉项为零。因此，$\\text{Cov}(z, z) = H \\text{Cov}(x, x) H^\\top + R = H P^- H^\\top + R$。这个项是*残差协方差*，记为 $S$。\n\n因此，联合协方差矩阵为：\n$$\\text{Cov}\\left(\\begin{pmatrix} x \\\\ z \\end{pmatrix}\\right) = \\begin{pmatrix} P^-  P^- H^\\top \\\\ H P^-  S \\end{pmatrix} \\quad \\text{其中} \\quad S = H P^- H^\\top + R$$\n\n对于一个分块高斯向量 $\\begin{pmatrix} y_1 \\\\ y_2 \\end{pmatrix}$，其协方差为 $\\begin{pmatrix} \\Sigma_{11}  \\Sigma_{12} \\\\ \\Sigma_{21}  \\Sigma_{22} \\end{pmatrix}$，给定 $y_2$ 时 $y_1$ 的条件协方差由公式 $\\text{Cov}(y_1|y_2) = \\Sigma_{11} - \\Sigma_{12} \\Sigma_{22}^{-1} \\Sigma_{21}$ 给出。\n将此应用于我们的系统，其中 $y_1 \\leftrightarrow x$ 和 $y_2 \\leftrightarrow z$，更新后的状态协方差 $P^+$ 为：\n$$P^+ = P^- - (P^- H^\\top) S^{-1} (H P^-)$$\n\n这个方程为两种要求的实现提供了基础。\n\n#### **形式1：代数简化更新**\n\n我们可以定义卡尔曼增益矩阵 $K \\in \\mathbb{R}^{4 \\times 2}$ 为 $K = P^- H^\\top S^{-1}$。将其代入 $P^+$ 的方程中得到：\n$$P^+ = P^- - K S K^\\top$$\n然而，一个更常见的代数简化是：\n$$P^+ = P^- - K (H P^-) = (I - KH) P^-$$\n其中 $I$ 是 $4 \\times 4$ 单位矩阵。这种形式计算效率高，需要一次 $2 \\times 2$ 矩阵求逆和几次矩阵乘法。然而，众所周知它在数值上是不稳定的。在有限精度算术中，$(I - KH)$ 和 $P^-$ 都可能很大，它们的乘积再从 $P^-$ 中减去可能导致精度损失。如果 $P^-$ 在由 $H$ 测量的子空间中接近奇异，减法可能导致得到的 $P^+$ 在数值上不再对称或正半定，从而违反了协方差矩阵的性质。\n\n#### **形式2：数值稳定（Joseph）更新**\n\n一种在数值上更稳健的公式，称为 Joseph 形式，是通过重写更新以避免大矩阵相减而推导出来的。它可以被证明在代数上等价于上述形式：\n$$P^+ = (I - KH) P^- (I - KH)^\\top + K R K^\\top$$\n通过展开各项来验证等价性：\n\\begin{align*} P^+ = (P^- - KHP^-)(I - H^\\top K^\\top) + KRK^\\top \\\\ = P^- - P^-H^\\top K^\\top - KHP^- + KHP^-H^\\top K^\\top + KRK^\\top \\\\ = P^- - (KHP^-)^\\top - KHP^- + K(HP^-H^\\top + R)K^\\top \\\\ = P^- - (KHP^-)^\\top - KHP^- + K S K^\\top \\end{align*}\n代入 $K = P^- H^\\top S^{-1}$ 并利用 $P^-$ 和 $S$ 的对称性：\n\\begin{align*} P^+ = P^- - (P^-H^\\top S^{-1} H P^-)^\\top - P^-H^\\top S^{-1} H P^- + (P^-H^\\top S^{-1}) S (S^{-1}H P^-) \\\\ = P^- - P^-H^\\top S^{-1} H P^- - P^-H^\\top S^{-1} H P^- + P^-H^\\top S^{-1} H P^- \\\\ = P^- - P^- H^\\top S^{-1} H P^- \\end{align*}\n这证实了代数等价性。Joseph 形式的数值稳定性源于它被表示为两个矩阵的和。项 $(I - KH) P^- (I - KH)^\\top$ 具有 $A \\Sigma A^\\top$ 的结构，因此保持了 $P^-$ 的正半定性。项 $K R K^\\top$ 也具有这种结构（因为 $R$ 是正定的），因此也是正半定的。两个正半定矩阵的和总是正半定的。这种结构确保了在精确算术中，$P^+$ 始终是一个有效的协方差矩阵。在有限精度算术中，这种形式产生非正半定结果的可能性要小得多。\n\n### **2. 混合精度保护策略**\n\n使用单精度（`float32`）算术会加剧数值问题，因为其有效数字位数有限（约7位）。病态问题，例如协方差矩阵元素动态范围大或残差协方差 $S$ 接近奇异的问题，尤其容易受到影响。\n\n一个稳健的保护措施是在双精度（`float64`，约16位有效数字）下执行最数值敏感的操作。所提出的混合精度策略利用了 Joseph 形式的优越稳定性，并通过为关键步骤使用更高精度来增强它：\n1.  将输入矩阵 $P^-$、$H$ 和 $R$ 从单精度转换为双精度。\n2.  在双精度下计算所有中间量——$S$、$S^{-1}$、$K$以及 Joseph 形式更新的两个项。\n3.  将各项相加得到双精度的更新后协方差 $P^+_{64}$。\n4.  应用一个显式的对称化步骤：$P^+_{\\text{sym}, 64} = \\frac{1}{2}(P^+_{64} + (P^+_{64})^\\top)$。这可以纠正由浮点矩阵乘法的非结合性引入的任何微小不对称。\n5.  将最终的、对称化的双精度结果转换回单精度矩阵。\n\n这种方法减轻了灾难性抵消和不精确矩阵求逆的风险，同时通过构造确保最终矩阵是对称的。最后的单精度转换是为了符合高能物理数据处理框架中常见的内存或存储限制。\n\n### **3. 风险量化指标**\n\n为了量化每种实现的数值稳健性，使用以下指标：\n-   **最小特征值 ($\\lambda_{\\min}$)**：对称化更新协方差 $\\frac{1}{2}(P^+ + (P^+)^\\top)$ 的最小特征值。负值表示矩阵失去了正半定性的关键属性。\n-   **相对对称误差**：$P^+$ 的斜对称部分的弗罗贝尼乌斯范数，通过 $P^+$ 的范数进行归一化，即 $\\|P^+ - (P^+)^\\top\\|_F / \\|P^+\\|_F$。这衡量了由浮点舍入误差引入的不对称程度。\n-   **位置抖动 ($j_{\\text{pos}}$)**：一个具有物理动机的度量，定义为 $j_{\\text{pos}} = \\max(0, -\\lambda_{\\min}^{\\text{pos}})$，其中 $\\lambda_{\\min}^{\\text{pos}}$ 是 $P^+$ 的 $2 \\times 2$ 对称化位置子块的最小特征值。该值表示必须添加到对角位置分量上的最小平方误差（单位为 $\\text{mm}^2$），以恢复协方差位置相关部分的正半定性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef update_simp32(p_minus: np.ndarray, h: np.ndarray, r: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the covariance update using the algebraically simplified form\n    P+ = (I - K*H)*P- in single precision.\n    \"\"\"\n    s = h @ p_minus @ h.T + r\n    k = p_minus @ h.T @ np.linalg.inv(s)\n    p_plus = (np.eye(4, dtype=np.float32) - k @ h) @ p_minus\n    return p_plus\n\ndef update_joseph32(p_minus: np.ndarray, h: np.ndarray, r: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the covariance update using the numerically stable Joseph form\n    P+ = (I-K*H)*P-*(I-K*H).T + K*R*K.T in single precision.\n    \"\"\"\n    s = h @ p_minus @ h.T + r\n    k = p_minus @ h.T @ np.linalg.inv(s)\n    \n    i_kh = np.eye(4, dtype=np.float32) - k @ h\n    term1 = i_kh @ p_minus @ i_kh.T\n    term2 = k @ r @ k.T\n    p_plus = term1 + term2\n    return p_plus\n\ndef update_mixed(p_minus_32: np.ndarray, h_32: np.ndarray, r_32: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the covariance update using the Joseph form in double precision\n    with an explicit symmetrization step, then casts back to single precision.\n    \"\"\"\n    p_minus_64 = p_minus_32.astype(np.float64)\n    h_64 = h_32.astype(np.float64)\n    r_64 = r_32.astype(np.float64)\n\n    s_64 = h_64 @ p_minus_64 @ h_64.T + r_64\n    k_64 = p_minus_64 @ h_64.T @ np.linalg.inv(s_64)\n\n    i_kh_64 = np.eye(4, dtype=np.float64) - k_64 @ h_64\n    term1_64 = i_kh_64 @ p_minus_64 @ i_kh_64.T\n    term2_64 = k_64 @ r_64 @ k_64.T\n    p_plus_64 = term1_64 + term2_64\n\n    # Explicit symmetry restoration\n    p_plus_sym_64 = 0.5 * (p_plus_64 + p_plus_64.T)\n\n    return p_plus_sym_64.astype(np.float32)\n\ndef calculate_min_eigenvalue(p_plus: np.ndarray) -> float:\n    \"\"\"Computes the minimum eigenvalue of the symmetrized matrix.\"\"\"\n    p_sym = 0.5 * (p_plus + p_plus.T)\n    # Use eigvalsh for hermitian (real-symmetric) matrices\n    min_eig = np.min(np.linalg.eigvalsh(p_sym))\n    return min_eig.item()\n\ndef calculate_rel_symmetry_error(p_plus: np.ndarray) -> float:\n    \"\"\"Computes the relative symmetry error.\"\"\"\n    delta = p_plus - p_plus.T\n    norm_delta = np.linalg.norm(delta, 'fro')\n    norm_p = np.linalg.norm(p_plus, 'fro')\n    if norm_p == 0:\n        return 0.0\n    return (norm_delta / norm_p).item()\n\ndef calculate_positional_jitter(p_plus: np.ndarray) -> float:\n    \"\"\"Computes the positional jitter j_pos.\"\"\"\n    p_pos = p_plus[:2, :2]\n    p_pos_sym = 0.5 * (p_pos + p_pos.T)\n    min_eig_pos = np.min(np.linalg.eigvalsh(p_pos_sym))\n    jitter = np.maximum(0.0, -min_eig_pos, dtype=np.float32)\n    return jitter.item()\n\ndef solve():\n    test_cases = [\n        # Case 1: well-conditioned\n        {'s': [0.05, 0.05, 0.001, 0.001], 'r': [0.02, 0.02], 'u': np.array([[0.005, -0.003], [0.004, 0.002], [0.0005, -0.0002], [0.0004, 0.0006]])},\n        # Case 2: near-singular\n        {'s': [1e-6, 1e-6, 1e2, 1e2], 'r': [1e-6, 1e-6], 'u': np.array([[1e-9, -1e-9], [1e-9, 1e-9], [0.1, -0.1], [0.1, 0.1]])},\n        # Case 3: high measurement noise\n        {'s': [0.01, 0.01, 0.005, 0.005], 'r': [5.0, 5.0], 'u': np.array([[0.002, 0.0015], [0.001, -0.002], [0.0005, 0.0003], [0.0004, -0.0001]])},\n        # Case 4: ill-conditioned\n        {'s': [1e3, 1e-6, 10.0, 1e-3], 'r': [0.1, 0.1], 'u': np.array([[1.0, 0.0], [0.0, 1e-7], [0.01, -0.02], [1e-4, 5e-5]])}\n    ]\n\n    h_matrix = np.array([[1, 0, 0, 0], [0, 1, 0, 0]], dtype=np.float32)\n    results = []\n\n    for case in test_cases:\n        sigmas = np.array(case['s'], dtype=np.float32)\n        res = np.array(case['r'], dtype=np.float32)\n        u_matrix = case['u'].astype(np.float32)\n\n        d_matrix = np.diag(sigmas**2)\n        p_minus = (d_matrix + u_matrix @ u_matrix.T).astype(np.float32)\n        r_matrix = np.diag(res**2).astype(np.float32)\n\n        # Run the three update implementations\n        p_simp32 = update_simp32(p_minus, h_matrix, r_matrix)\n        p_joseph32 = update_joseph32(p_minus, h_matrix, r_matrix)\n        p_mixed = update_mixed(p_minus, h_matrix, r_matrix)\n\n        # Calculate metrics as per output specification\n        lam_simp32 = calculate_min_eigenvalue(p_simp32)\n        lam_joseph32 = calculate_min_eigenvalue(p_joseph32)\n        lam_mixed = calculate_min_eigenvalue(p_mixed)\n        \n        sym_err_simp32 = calculate_rel_symmetry_error(p_simp32)\n        sym_err_joseph32 = calculate_rel_symmetry_error(p_joseph32)\n\n        j_pos_simp32 = calculate_positional_jitter(p_simp32)\n\n        case_results = [\n            lam_simp32, lam_joseph32, lam_mixed,\n            sym_err_simp32, sym_err_joseph32,\n            j_pos_simp32\n        ]\n        results.extend(case_results)\n\n    # Format output to match problem specification\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}