{
    "hands_on_practices": [
        {
            "introduction": "理解红外与共线 (IRC) 安全性的最好方法之一是亲眼见证其失效时的后果。本练习将现代、安全的 anti-$k_T$ 算法与一种简化的、历史上使用过的、已知不安全的“种子-锥形”算法进行对比。通过编程实现这两种算法，并让它们处理一个受控的共线分裂情景，您将能够从数值上验证 anti-$k_T$ 算法的稳定性以及锥形算法的失效。这项实践旨在为您建立一个坚实直观的理解，即为何像 anti-$k_T$ 这样的算法在现代粒子物理学中是不可或缺的 。",
            "id": "3517907",
            "problem": "你的任务是编写一个完整的、自包含的程序，构建一个受控的共线分裂情景，并数值上验证 anti-$k_{T}$ 聚类算法的共线安全性，以对比基于种子的锥形算法在种子有阈值时表现出的不稳定性。在末态粒子无质量近似下工作，粒子由横向动量、快度和方位角 $(p_{T}, y, \\phi)$ 表示，其四维动量由通常的关系式定义。使用 Minkowski 度规符号 $(+,-,-,-)$ 和 E-方案重组（四维矢量求和）。\n\n使用的基本依据和定义：\n- 使用 Minkowski 度规计算喷注质量平方，$m_{J}^{2} = \\left(\\sum_{i} p_{i}^{\\mu}\\right)^{2} = \\left(\\sum_{i} E_{i}\\right)^{2} - \\left\\|\\sum_{i} \\vec{p}_{i}\\right\\|^{2}$。\n- 通过 $(p_{T}, y, \\phi)$ 与四维动量分量之间的映射来模拟无质量粒子：$p_{x} = p_{T} \\cos\\phi$, $p_{y} = p_{T} \\sin\\phi$, $p_{z} = p_{T} \\sinh y$, $E = p_{T} \\cosh y$。\n- 使用快度-方位角距离 $\\Delta R = \\sqrt{(\\Delta y)^{2} + (\\Delta \\phi)^{2}}$，其中 $\\Delta \\phi$ 定义为圆周上的最小角差。\n- 实现 anti-$k_{T}$ 顺序重组算法，其距离度量为\n$$\nd_{ij} = \\min\\left(p_{T,i}^{-2}, p_{T,j}^{-2}\\right)\\,\\frac{\\Delta R_{ij}^{2}}{R^{2}}, \\quad d_{iB} = p_{T,i}^{-2},\n$$\n其中 $R$ 是喷注半径参数，使用 E-方案重组，直到所有剩余的对象都被声明为喷注。\n- 实现一个简化的基于种子的迭代锥形算法，其种子阈值为 $p_{T}^{\\text{seed}}$：种子是所有 $p_{T} \\ge p_{T}^{\\text{seed}}$ 的粒子；对每个种子，围绕一个初始化为种子方向的轴构建一个半径为 $R$ 的锥体；包含所有 $\\Delta R \\le R$ 的粒子；根据求和后的四维动量重新计算轴；迭代直至轴在小的容差范围内稳定；将所有不同的稳定锥体作为喷注返回。如果没有种子存在，该算法不返回任何喷注。\n\n要构建的情景：\n- 考虑一个未分裂事件 $\\mathcal{E}_{0}$，它由一个具有四维动量 $p^{\\mu}$ 的无质量粒子组成，该粒子由 $(p_{T,0}, y_{0}, \\phi_{0})$ 定义。\n- 通过将 $p^{\\mu}$ 替换为两个共线子粒子来构建一个分裂事件 $\\mathcal{E}_{\\text{split}}$，它们的动量分别为 $z\\,p^{\\mu}$ 和 $(1-z)\\,p^{\\mu}$，并由一个微小但受控的快度-方位角距离 $\\Delta R$ 分开。为了在大致保留净轴向的同时参数化该分离，将两个子粒子分别放置在 $(y_{0} - \\Delta R/2, \\phi_{0})$ 和 $(y_{0} + \\Delta R/2, \\phi_{0})$，其横向动量分别为 $z\\,p_{T,0}$ 和 $(1-z)\\,p_{T,0}$。在精确共线极限下，通过将两个子粒子都放在 $(y_{0}, \\phi_{0})$ 来取 $\\Delta R = 0$。\n\n必需的计算：\n- 对每个事件，使用 anti-$k_{T}$ 算法（半径为 $R$）聚类喷注，并使用 E-方案对喷注组分进行四维矢量求和，计算领头喷注质量平方 $m_{J}^{2}$（单位 $\\text{GeV}^{2}$）。\n- 使用相同的 $R$ 和种子阈值 $p_{T}^{\\text{seed}}$，用基于种子的锥形算法重复上述过程。如果该算法不返回任何喷注，则为比较目的，将领头喷注质量平方视为未定义。\n- 通过绝对差值量化 anti-$k_{T}$ 的共线安全性：\n$$\n\\Delta m^{2}_{\\text{anti-}k_{T}} = \\left| m_{J}^{2}\\left(\\mathcal{E}_{\\text{split}}\\right) - m_{J}^{2}\\left(\\mathcal{E}_{0}\\right) \\right|,\n$$\n如果 $\\Delta m^{2}_{\\text{anti-}k_{T}} \\le \\varepsilon$（其中 $\\varepsilon$ 是数值容差），则声明其为数值上不变。\n- 通过以下方式量化基于种子的锥形算法的行为：\n$$\n\\Delta m^{2}_{\\text{cone}} = \\left| m_{J}^{2}\\left(\\mathcal{E}_{\\text{split}}\\right) - m_{J}^{2}\\left(\\mathcal{E}_{0}\\right) \\right|\n$$\n（如果两个质量都有定义）；否则，如果分裂事件不返回任何喷注，则设置一个哨兵值 $-1$ 来表示因缺少种子而导致的不稳定性。\n\n单位和角度：\n- 能量单位使用 $\\text{GeV}$，喷注质量平方以 $\\text{GeV}^{2}$ 报告。\n- 角度单位使用弧度。\n\n数值参数：\n- 使用 $R = 0.4$, $p_{T,0} = 100\\,\\text{GeV}$, $(y_{0}, \\phi_{0}) = (0, 0)$, $p_{T}^{\\text{seed}} = 65\\,\\text{GeV}$，以及数值容差 $\\varepsilon = 10^{-12}\\,\\text{GeV}^{2}$。\n\n测试套件：\n对于下面的每个元组 $(z, \\Delta R)$，按所述构建 $\\mathcal{E}_{0}$ 和 $\\mathcal{E}_{\\text{split}}$，为两种算法计算上述量，并记录结果。\n\n- 测试 1 (理想情况，明显的种子不稳定性): $(z, \\Delta R) = (0.6, 0.0)$。\n- 测试 2 (带有幸存种子的非对称分裂): $(z, \\Delta R) = (0.9, 10^{-6})$。\n- 测试 3 (对称的、微小但有限的分离): $(z, \\Delta R) = (0.5, 10^{-3})$。\n- 测试 4 (处于种子阈值的边界): $(z, \\Delta R) = (0.65, 10^{-6})$。\n- 测试 5 (远小于锥体半径的非零分离): $(z, \\Delta R) = (0.6, 0.2)$。\n\n答案规格：\n- 对每个测试，程序必须输出一个三元列表 $[\\Delta m^{2}_{\\text{anti-}k_{T}}, \\Delta m^{2}_{\\text{cone}} \\text{ or } -1.0, \\text{invariance}]$，其中第三个元素是一个布尔值，如果 $\\Delta m^{2}_{\\text{anti-}k_{T}} \\le \\varepsilon$ 则为 $\\text{True}$，否则为 $\\text{False}$。\n- 将五个测试的列表按原始测试顺序聚合到单个列表中。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个元素本身都是按指定顺序排列的三元列表（例如，$[[a_{1},b_{1},c_{1}],[a_{2},b_{2},c_{2}],\\dots]$）。所有喷注质量平方值必须是表示 $\\text{GeV}^{2}$ 的浮点数，不变性标志必须是布尔值。",
            "solution": "该问题要求对两种不同的喷注聚类算法——顺序重组 anti-$k_T$ 算法和简化的基于种子的迭代锥形算法——进行共线安全性分析。我们的任务是构建一个受控的共线分裂情景，并数值上验证每种算法的预期行为。\n\n**1. 理论框架和定义**\n\n我们在无质量粒子近似下操作，其中每个粒子的状态由其横向动量 $p_T$、快度 $y$ 和方位角 $\\phi$ 定义。其四维动量 $p^\\mu = (E, p_x, p_y, p_z)$ 通过以下关系构建：\n$$\np_x = p_T \\cos\\phi\n$$\n$$\np_y = p_T \\sin\\phi\n$$\n$$\np_z = p_T \\sinh y\n$$\n$$\nE = \\sqrt{p_x^2 + p_y^2 + p_z^2} = \\sqrt{p_T^2 + (p_T \\sinh y)^2} = p_T \\cosh y\n$$\n快度-方位角平面中粒子间的距离由 $\\Delta R = \\sqrt{(\\Delta y)^2 + (\\Delta \\phi)^2}$ 给出，其中 $\\Delta \\phi$ 是最短角距离。一个由一组组分粒子 $\\{i\\}$ 构成的喷注 $J$ 的不变质量平方，使用 E-方案（四维矢量求和）和符号为 $(+,-,-,-)$ 的 Minkowski 度规计算：\n$$\nm_J^2 = P_J^\\mu P_{J, \\mu} = \\left(\\sum_i p_i^\\mu\\right)^2 = \\left(\\sum_i E_i\\right)^2 - \\left\\|\\sum_i \\vec{p}_i\\right\\|^2\n$$\n\n**2. 共线分裂情景**\n\n为了测试共线安全性，我们比较在一个事件 $\\mathcal{E}_0$ 上计算的可观测量与在一个修改后的事件 $\\mathcal{E}_{\\text{split}}$ 上计算的可观测量。\n- 事件 $\\mathcal{E}_0$：一个单一的无质量粒子，其四维动量 $p^\\mu$ 对应于 $(p_{T,0}, y_0, \\phi_0)$。由单个无质量粒子组成的喷注其 $m_J^2 = (p^\\mu)^2 = 0$。\n- 事件 $\\mathcal{E}_{\\text{split}}$：粒子 $p^\\mu$ 被两个共线子粒子 $p_1^\\mu$ 和 $p_2^\\mu$ 替换。它们的动量分别是原始粒子动量的 $z$ 和 $(1-z)$ 部分。它们由一个微小的距离 $\\Delta R$ 分开。具体的参数化为：\n  - 粒子 1: $(p_T, y, \\phi) = (z p_{T,0}, y_0 - \\Delta R/2, \\phi_0)$\n  - 粒子 2: $(p_T, y, \\phi) = ((1-z) p_{T,0}, y_0 + \\Delta R/2, \\phi_0)$\n\n如果一个可观测量在 $\\mathcal{E}_{\\text{split}}$ 上的值随着分裂距离 $\\Delta R \\to 0$ 而平滑地趋近于它在 $\\mathcal{E}_0$ 上的值，那么该可观测量是**共线安全**的。\n\n**3. 算法设计和预期行为**\n\n**Anti-$k_T$ 算法：**\n这是一个顺序重组算法。它迭代地合并具有最小距离的一对对象（粒子或原喷注），直到所有对象之间的距离都大于与束流距离相关的某个阈值。距离定义为：\n$$\nd_{ij} = \\min\\left(p_{T,i}^{-2}, p_{T,j}^{-2}\\right)\\,\\frac{\\Delta R_{ij}^{2}}{R^{2}}, \\quad d_{iB} = p_{T,i}^{-2}\n$$\n在我们的情景中，有两个靠近的粒子，$\\Delta R_{12} = \\Delta R$。对于任何 $\\Delta R  R$ 的构型，粒子间距离 $d_{12}$ 将小于束流距离 $d_{1B}$ 和 $d_{2B}$。因此，两个子粒子将首先被合并。产生的喷注将具有四维动量 $P_J^\\mu = p_1^\\mu + p_2^\\mu$。这个喷注的不变质量平方可以解析计算。当 $y_0 = 0$ 和 $\\phi_0=0$ 时：\n$$\nm_J^2(\\mathcal{E}_{\\text{split}}) = 4z(1-z) p_{T,0}^2 \\sinh^2(\\Delta R/2)\n$$\n当 $\\Delta R \\to 0$ 时，$m_J^2(\\mathcal{E}_{\\text{split}}) \\to 0$，这恰好是 $m_J^2(\\mathcal{E}_0)$。这表明 anti-$k_T$ 算法得出的喷注质量是一个共线安全的可观测量。通过检查 $\\Delta m^2_{\\text{anti-}k_T} = |m_J^2(\\mathcal{E}_{\\text{split}}) - m_J^2(\\mathcal{E}_0)| \\le \\varepsilon$（其中 $\\varepsilon$ 是一个小的容差）来进行数值测试。对于任何有限的 $\\Delta R > 0$，我们预计这个差异不为零，且可能大于一个非常小的 $\\varepsilon$，但对于 $\\Delta R = 0$，它必须精确为零。\n\n**基于种子的锥形算法：**\n这个算法在本质上是不同的。它寻找围绕高 $p_T$ “种子”的稳定粒子锥。\n1. 识别所有 $p_T \\ge p_T^{\\text{seed}}$ 的粒子。这些是种子。\n2. 如果不存在种子，则找不到喷注。\n3. 对每个种子进行迭代：围绕一个轴形成一个半径为 $R$ 的锥体，对其中的粒子动量求和，并使用该总和的方向作为新轴。当轴稳定时，该过程停止。\n\n预计该算法是**共线不安全**的。考虑一个 $p_T > p_T^{\\text{seed}}$ 的粒子分裂成两个子粒子，而两个子粒子的 $p_T$ 都小于 $p_T^{\\text{seed}}$。\n- 在 $\\mathcal{E}_0$ 中，单个粒子是一个种子，会找到一个喷注。\n- 在 $\\mathcal{E}_{\\text{split}}$ 中，两个子粒子都不符合种子条件。该算法找不到种子，因此不返回任何喷注。\n喷注寻找的结果因事件的无穷小变化（分裂）而从一个喷注突然变为零个喷注，这是不安全算法的标志。这将由哨兵值 $-1$ 来表示。如果分裂后有种子幸存，该算法将找到一个喷注，并且可以计算质量差异 $\\Delta m^2_{\\text{cone}}$，其结果通常与 anti-$k_T$ 相似，因为锥体将包含两个共线子粒子。\n\n**4. 实现策略**\n\n我们将实现辅助函数来管理四维矢量转换和运动学计算。两种喷注算法将作为独立的函数实现。主程序将循环遍历指定的测试用例。对于每个用例，它将构建 $\\mathcal{E}_0$ 和 $\\mathcal{E}_{\\text{split}}$，应用两种算法，计算领头喷注质量平方，然后计算所需的量 $\\Delta m^2_{\\text{anti-}k_T}$、其不变性状态，以及 $\\Delta m^2_{\\text{cone}}$（或哨兵值）。最终结果将按规定聚合为一个列表的列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the jet algorithm safety analysis.\n    \"\"\"\n    # Global parameters\n    R = 0.4\n    PT0 = 100.0  # GeV\n    Y0, PHI0 = 0.0, 0.0\n    PT_SEED = 65.0  # GeV\n    EPSILON = 1e-12  # GeV^2\n\n    CONE_STABILITY_TOL = 1e-9\n\n    # Test suite\n    test_cases = [\n        # (z, DeltaR)\n        (0.6, 0.0),\n        (0.9, 1e-6),\n        (0.5, 1e-3),\n        (0.65, 1e-6),\n        (0.6, 0.2),\n    ]\n\n    # Helper class for particles\n    class Particle:\n        def __init__(self, pt, y, phi):\n            self.pt = pt\n            self.y = y\n            self.phi = phi\n            self.pmu = self.to_pmu()\n\n        def to_pmu(self):\n            px = self.pt * np.cos(self.phi)\n            py = self.pt * np.sin(self.phi)\n            pz = self.pt * np.sinh(self.y)\n            e = self.pt * np.cosh(self.y)\n            return np.array([e, px, py, pz])\n\n        @staticmethod\n        def from_pmu(pmu):\n            e, px, py, pz = pmu\n            pt = np.sqrt(px**2 + py**2)\n            if pt  1e-15:\n                return 0.0, 0.0, 0.0\n            \n            # Rapidity y = 0.5 * log((E+pz)/(E-pz))\n            # phi = atan2(py, px)\n            y = 0.5 * np.log((e + pz) / (e - pz))\n            phi = np.arctan2(py, px)\n            return pt, y, phi\n\n    # Kinematic helpers\n    def delta_phi(phi1, phi2):\n        dphi = phi1 - phi2\n        while dphi > np.pi: dphi -= 2 * np.pi\n        while dphi = -np.pi: dphi += 2 * np.pi\n        return dphi\n\n    def delta_R2(y1, phi1, y2, phi2):\n        dy = y1 - y2\n        dphi = delta_phi(phi1, phi2)\n        return dy**2 + dphi**2\n\n    def get_jet_mass_sq(pmu_sum):\n        return pmu_sum[0]**2 - pmu_sum[1]**2 - pmu_sum[2]**2 - pmu_sum[3]**2\n\n    # Algorithm implementations\n    def anti_kt_cluster(particles):\n        protojets = {i: p.pmu for i, p in enumerate(particles)}\n        protojets_coords = {i: (p.y, p.phi, p.pt) for i, p in enumerate(particles)}\n        jets = []\n        \n        while protojets:\n            min_dist = np.inf\n            merge_pair = None # (i, j)\n            beam_jet_idx = None # i\n            \n            ids = list(protojets.keys())\n\n            # d_iB distances\n            for i in ids:\n                dist_ib = 1.0 / (protojets_coords[i][2]**2)\n                if dist_ib  min_dist:\n                    min_dist = dist_ib\n                    beam_jet_idx = i\n                    merge_pair = None\n            \n            # d_ij distances\n            for i in range(len(ids)):\n                for j in range(i + 1, len(ids)):\n                    id_i, id_j = ids[i], ids[j]\n                    y_i, phi_i, pt_i = protojets_coords[id_i]\n                    y_j, phi_j, pt_j = protojets_coords[id_j]\n                    \n                    dr2 = delta_R2(y_i, phi_i, y_j, phi_j)\n                    dist_ij = min(1.0/pt_i**2, 1.0/pt_j**2) * dr2 / R**2\n                    \n                    if dist_ij  min_dist:\n                        min_dist = dist_ij\n                        merge_pair = (id_i, id_j)\n                        beam_jet_idx = None\n\n            if beam_jet_idx is not None:\n                jets.append(protojets[beam_jet_idx])\n                del protojets[beam_jet_idx]\n                del protojets_coords[beam_jet_idx]\n            elif merge_pair:\n                i, j = merge_pair\n                pmu_i, pmu_j = protojets[i], protojets[j]\n                \n                new_pmu = pmu_i + pmu_j\n                new_pt, new_y, new_phi = Particle.from_pmu(new_pmu)\n                \n                del protojets[i]\n                del protojets_coords[i]\n                del protojets[j]\n                del protojets_coords[j]\n                \n                new_id = max(ids) + 1 if ids else 0\n                protojets[new_id] = new_pmu\n                protojets_coords[new_id] = (new_y, new_phi, new_pt)\n                \n        # Sort jets by pT and return\n        jets.sort(key=lambda pmu: Particle.from_pmu(pmu)[0], reverse=True)\n        return jets\n\n    def cone_cluster(particles):\n        seeds = [p for p in particles if p.pt >= PT_SEED]\n        if not seeds:\n            return []\n\n        stable_cones_pmu = []\n        for seed in seeds:\n            axis_y, axis_phi = seed.y, seed.phi\n            \n            for _ in range(100): # max iterations\n                old_axis_y, old_axis_phi = axis_y, axis_phi\n                \n                constituents_pmu = np.array([0.0, 0.0, 0.0, 0.0])\n                for p in particles:\n                    if delta_R2(p.y, p.phi, axis_y, axis_phi) = R**2:\n                        constituents_pmu += p.pmu\n                \n                if constituents_pmu[0]  1e-15:\n                    # no particles in cone, rare but possible\n                    break\n                \n                _, new_y, new_phi = Particle.from_pmu(constituents_pmu)\n                axis_y, axis_phi = new_y, new_phi\n\n                if delta_R2(old_axis_y, old_axis_phi, axis_y, axis_phi)  CONE_STABILITY_TOL**2:\n                    break\n            \n            stable_cones_pmu.append(constituents_pmu)\n        \n        # Remove duplicate cones (very simple check for this problem)\n        unique_cones = []\n        for cone_pmu in stable_cones_pmu:\n            is_duplicate = False\n            for unique_pmu in unique_cones:\n                 if np.allclose(cone_pmu, unique_pmu):\n                    is_duplicate = True\n                    break\n            if not is_duplicate:\n                unique_cones.append(cone_pmu)\n        \n        unique_cones.sort(key=lambda pmu: Particle.from_pmu(pmu)[0], reverse=True)\n        return unique_cones\n\n\n    results = []\n    for z, delta_R in test_cases:\n        # Event E0: unsplit\n        event0 = [Particle(PT0, Y0, PHI0)]\n        \n        # Event E_split\n        p1 = Particle(z * PT0, Y0 - delta_R / 2, PHI0)\n        p2 = Particle((1 - z) * PT0, Y0 + delta_R / 2, PHI0)\n        event_split = [p1, p2]\n\n        # Process E0\n        jets0_akt = anti_kt_cluster(event0)\n        m2_0_akt = get_jet_mass_sq(jets0_akt[0]) if jets0_akt else 0.0\n        \n        jets0_cone = cone_cluster(event0)\n        m2_0_cone = get_jet_mass_sq(jets0_cone[0]) if jets0_cone else 0.0\n\n        # Process E_split\n        jets_split_akt = anti_kt_cluster(event_split)\n        m2_split_akt = get_jet_mass_sq(jets_split_akt[0]) if jets_split_akt else 0.0\n\n        jets_split_cone = cone_cluster(event_split)\n        m2_split_cone_defined = bool(jets_split_cone)\n        m2_split_cone = get_jet_mass_sq(jets_split_cone[0]) if m2_split_cone_defined else 0.0\n        \n        # Calculate differences\n        delta_m2_akt = abs(m2_split_akt - m2_0_akt)\n        invariance_akt = delta_m2_akt = EPSILON\n\n        if m2_split_cone_defined:\n            delta_m2_cone = abs(m2_split_cone - m2_0_cone)\n        else:\n            delta_m2_cone = -1.0\n            \n        results.append([float(delta_m2_akt), float(delta_m2_cone), invariance_akt])\n\n    # Final print statement\n    formatted_results = [f\"[{r[0]},{r[1]},{str(r[2])}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "拥有一个 IRC 安全的喷注算法只是第一步；从喷注组分计算出的可观测量本身也必须是安全的。本练习将展示一个场景，其中一个可观测量——最后一次合并的动量共享分数 $z_{\\text{last}}$——虽然是共线安全的，却是软非安全的。您将接着实现“软下降”（Soft Drop）修饰程序，观察它如何系统地移除软的、大角度的辐射，从而恢复完整的 IRC（或苏达科夫）安全性，这是现代喷注子结构研究的基石 。",
            "id": "3517881",
            "problem": "本题要求您使用一个简单的确定性聚类模型，构建并分析一个共线安全但软不安全的事件形态可观测量，然后应用修饰程序来恢复 Sudakov 安全性。您将在一维角空间中实现 Cambridge/Aachen 聚类算法，并从生成的二元聚类树中计算两个可观测量：一个是未经修饰的末次分裂动量分配分数，它是共线安全但软不安全的；另一个是使用 Soft Drop 修饰的修饰后动量分配分数，它是 Sudakov 安全的。然后，您将数值研究当 Soft Drop 阈值参数 $z_\\text{cut}$ 趋近于 $0$ 时，修饰后的可观测量如何过渡到未经修饰的可观测量。\n\n基本原理：\n- 核心行为由量子色动力学（QCD）的红外和共线结构决定。如果一个可观测量对增加动量为零的发射不敏感，则它是红外安全的；如果它对用两个动量之和等于原始动量的共线粒子替换一个粒子不敏感，则它是共线安全的。像 Cambridge/Aachen 这样的确定性聚类算法被设计成在喷注层面上是红外和共线安全的。\n- 您必须使用以下定义和事实作为基本原理：\n  1. Cambridge/Aachen 聚类：在每次迭代中，合并角距离最小的一对赝喷注，其中在一维方位角空间中的成对角分离为 $\\Delta\\phi_{ij} = |\\phi_i - \\phi_j|$。持续进行直到只剩下一个赝喷注，从而产生一个二元聚类树。使用 $p_T$ 方案重组，即合并节点 $a$ 和 $b$ 时，新的赝喷注的总横向动量为 $p_{T,\\text{new}} = p_{T,a} + p_{T,b}$，角度为 $\\phi_{\\text{new}} = \\frac{p_{T,a}\\phi_a + p_{T,b}\\phi_b}{p_{T,a} + p_{T,b}}$。\n  2. 未经修饰的末次分裂事件形态是在最后一次聚类步骤中的动量分配：\n     $$ z_{\\text{last}} = \\frac{\\min(p_{T,1}, p_{T,2})}{p_{T,1} + p_{T,2}}. $$\n     这是共线安全的，因为任何共线分裂都发生在零角度处，并在末次分裂之前被合并，使得末次分裂保持不变。它是软不安全的，因为增加一个动量为 $\\epsilon$ 的宽角发射可以产生一个末次分裂，其 $z_{\\text{last}} \\approx \\epsilon/(p_{T,\\text{hard}} + \\epsilon) \\to 0$ 当 $\\epsilon \\to 0$ 时。\n  3. 具有角指数 $\\beta = 0$ 的 Soft Drop 修饰通过从根部对 C/A 树进行解聚来递归定义：在每次分裂成横向动量为 $p_{T,1}$ 和 $p_{T,2}$ 的两个分支时，计算\n     $$ z = \\frac{\\min(p_{T,1}, p_{T,2})}{p_{T,1} + p_{T,2}}. $$\n     如果 $z > z_\\text{cut}$，则接受该分裂并定义 $z_g = z$。如果 $z \\le z_\\text{cut}$，则丢弃较软的分支并继续对较硬的分支进行解聚。如果没有分裂通过阈值，则定义 $z_g = 0$。对于固定的 $z_\\text{cut} > 0$，$z_g$ 是 Sudakov 安全的；当 $z_\\text{cut} \\to 0$ 时，$z_g$ 趋近于未经修饰的 $z_{\\text{last}}$ 并失去软安全性。\n\n任务：\n- 实现一维 Cambridge/Aachen 聚类算法，处理由横向动量 $p_T$（单位 $\\text{GeV}$）和角度 $\\phi$（单位弧度）表示的粒子列表。将 $\\phi$ 视为实数弧度，不进行任何周期性环绕处理；仅使用 $\\Delta\\phi = |\\phi_i - \\phi_j|$。\n- 通过重复合并 $\\Delta\\phi$ 最小的对，使用上述重组方案构建二元树。最后一次合并定义了末次分裂。对于只有一个粒子的集合，按惯例定义 $z_{\\text{last}} = 0$。\n- 实现具有 $\\beta = 0$ 和阈值 $z_\\text{cut}$ 的 Soft Drop 修饰。解聚从聚类树的根部开始：在每次分裂成动量为 $p_{T,1}$ 和 $p_{T,2}$ 的子节点时，如上计算 $z$ 并与 $z_\\text{cut}$ 比较。如果 $z > z_\\text{cut}$，则设置 $z_g = z$；否则，通过丢弃较软的子节点并沿较硬的子节点继续解聚。如果到达叶节点而未接受任何分裂，则定义 $z_g = 0$。对于单粒子输入，对所有 $z_\\text{cut}$ 定义 $z_g = 0$。\n- 对测试套件中的每个事件，计算一个列表，其中包含 $[z_{\\text{last}}, z_g(z_\\text{cut} = 0.1), z_g(z_\\text{cut} = 0.01), z_g(z_\\text{cut} = 10^{-9})]$。所有输出都是无量纲的实数。不要进行四舍五入；报告您的实现所产生的全精度浮点结果。\n\n单位和约定：\n- 所有横向动量 $p_T$ 均以 $\\text{GeV}$ 为单位。\n- 所有角度 $\\phi$ 均以弧度为单位。\n- 输出 $z_{\\text{last}}$ 和 $z_g$ 是无量纲的。\n\n测试套件：\n- 事件 $1$（软不安全演示）：三个粒子， $[(p_T,\\phi)] = [(100, 0.0), (50, 0.1), (10^{-6}, 1.0)]$。这会在硬簇和宽角软粒子之间产生一次末次分裂，使 $z_{\\text{last}}$ 对软发射敏感。对于 $z_\\text{cut} \\in \\{0.1, 0.01\\}$，修饰后的 $z_g$ 会选择硬分裂，并随着 $z_\\text{cut} \\to 0$ 而过渡到 $z_{\\text{last}}$。\n- 事件 $2$（共线安全检查）：三个粒子， $[(p_T,\\phi)] = [(70, 0.0), (30, 10^{-6}), (50, 0.8)]$。两个几乎共线的粒子模拟了一个 $100$ $\\text{GeV}$ 叉的一次共线分裂；C/A 算法首先将它们合并，因此末次分裂以及 $z_{\\text{last}}$ 和 $z_g$ 保持与相应的双叉情况的值相等。\n- 事件 $3$（边界情况）：一个粒子， $[(p_T,\\phi)] = [(123, 0.5)]$。没有分裂；按照惯例，对于所有 $z_\\text{cut}$，$z_{\\text{last}} = 0$ 且 $z_g = 0$。\n\n您的程序应生成单行输出，其中包含三个事件的结果，格式为逗号分隔的列表的列表，顺序如上，例如：\n\"[[z_last_1,zg_1_0.1,zg_1_0.01,zg_1_1e-9],[z_last_2,zg_2_0.1,zg_2_0.01,zg_2_1e-9],[z_last_3,zg_3_0.1,zg_3_0.01,zg_3_1e-9]]\"\n用数值填充占位符。不应打印任何其他文本。",
            "solution": "用户提供了有效的问题陈述。\n\n### 第一步：提取已知条件\n- **任务**：实现 Cambridge/Aachen (C/A) 聚类、一个未经修饰的可观测量 $z_{\\text{last}}$ 和一个使用 Soft Drop 修饰的可观测量 $z_g$。在给定的测试套件上分析它们的行为。\n- **聚类算法**：一维 Cambridge/Aachen (C/A)。\n    - **度量**：迭代地合并角距离 $\\Delta\\phi_{ij} = |\\phi_i - \\phi_j|$ 最小的一对赝喷注 $(i, j)$。\n    - **重组方案**：对于合并横向动量为 $p_{T,a}$、$p_{T,b}$ 和角度为 $\\phi_a$、$\\phi_b$ 的赝喷注 $a$ 和 $b$：\n        - $p_{T,\\text{new}} = p_{T,a} + p_{T,b}$\n        - $\\phi_{\\text{new}} = \\frac{p_{T,a}\\phi_a + p_{T,b}\\phi_b}{p_{T,a} + p_{T,b}}$\n- **未经修饰的可观测量 ($z_{\\text{last}}$)**：\n    - 定义为最后一次聚类步骤中的动量分配。对于两个动量为 $p_{T,1}$ 和 $p_{T,2}$ 的子喷注，$z_{\\text{last}} = \\frac{\\min(p_{T,1}, p_{T,2})}{p_{T,1} + p_{T,2}}$。\n    - 对于只有一个粒子的事件，$z_{\\text{last}} = 0$。\n- **修饰后的可观测量 ($z_g$)**：\n    - **算法**：Soft Drop 修饰，角指数 $\\beta = 0$，动量分配阈值 $z_\\text{cut}$。\n    - **过程**：从根部对 C/A 树进行递归解聚。在每次分裂成动量为 $p_{T,1}$ 和 $p_{T,2}$ 的分支时，计算 $z = \\frac{\\min(p_{T,1}, p_{T,2})}{p_{T,1} + p_{T,2}}$。\n        - 如果 $z > z_\\text{cut}$，则接受该分裂。定义 $z_g = z$ 并停止。\n        - 如果 $z \\le z_\\text{cut}$，则丢弃较软的分支。在较硬的分支上继续解聚。\n        - 如果没有分裂通过阈值（即到达叶节点），则定义 $z_g = 0$。\n    - 对于只有一个粒子的事件，$z_g = 0$。\n- **计算任务**：对每个事件，计算一个包含四个值的列表：$[z_{\\text{last}}, z_g(z_\\text{cut} = 0.1), z_g(z_\\text{cut} = 0.01), z_g(z_\\text{cut} = 10^{-9})]$。\n- **测试套件**：\n    - 事件 1：$[(p_T=100\\,\\text{GeV}, \\phi=0.0), (p_T=50\\,\\text{GeV}, \\phi=0.1), (p_T=10^{-6}\\,\\text{GeV}, \\phi=1.0)]$\n    - 事件 2：$[(p_T=70\\,\\text{GeV}, \\phi=0.0), (p_T=30\\,\\text{GeV}, \\phi=10^{-6}), (p_T=50\\,\\text{GeV}, \\phi=0.8)]$\n    - 事件 3：$[(p_T=123\\,\\text{GeV}, \\phi=0.5)]$\n\n### 第二步：使用提取的已知条件进行验证\n该问题在科学上基于量子色动力学（QCD）和喷注物理，具体涉及红外和共线（IRC）安全性、喷注聚类算法（C/A）和喷注修饰技术（Soft Drop）等公认概念。为算法和可观测量提供的定义是标准且正确的。该问题是适定（well-posed）的，因为 C/A 算法和 Soft Drop 过程的确定性确保了对于任何给定的输入都有唯一的解。问题陈述是客观、完整且自洽的，提供了所有必要的定义、常数和测试用例。物理场景虽被简化，但仍是合理的，可作为关键物理原理的有效教学示例。因此，该问题被认为是**有效的**。\n\n### 第三步：进行求解\n\n#### 基于原理的算法设计\n\n解决方案的关键在于构建并分析一个二元聚类树。这个由 Cambridge/Aachen (C/A) 算法生成的结构，编码了喷注形成的几何历史。然后通过遍历这棵树来计算可观测量。\n\n**1. 赝喷注的数据结构与树的构建**\n\n为了表示聚类过程中任何时刻的系统状态，我们定义一个 `PseudoJet` 对象。该对象封装了粒子或粒子簇的运动学属性，特别是其横向动量 $p_T$ 和角度 $\\phi$。关键的是，为了形成二元树，每个由合并产生的 `PseudoJet` 还必须存储对其两个组成部分（在解聚意义上是子节点）的引用。代表初始粒子的 `PseudoJet` 是一个没有子节点的叶节点。\n\n**2. Cambridge/Aachen (C/A) 聚类实现**\n\nC/A 算法遵循角度排序原则。它通过迭代合并角分离 $\\Delta\\phi_{ij} = |\\phi_i - \\phi_j|$ 最小的一对赝喷注来构建喷注结构。此过程实现如下：\n1. 从输入粒子初始化一个 `PseudoJet` 对象列表。\n2. 当列表中还存在多于一个 `PseudoJet` 时：\n    a. 找到使 $\\Delta\\phi_{ij}$ 最小的一对 $(i, j)$。这是一个对所有唯一对的暴力搜索。\n    b. 使用指定的 $p_T$ 方案重组规则将这对合并成一个新的 `PseudoJet`：$p_{T,\\text{new}} = p_{T,i} + p_{T,j}$ 和 $\\phi_{\\text{new}} = (p_{T,i}\\phi_i + p_{T,j}\\phi_j) / p_{T,\\text{new}}$。两个被合并的赝喷注被存储为新赝喷注的子节点。\n    c. 从活动列表中移除被合并的赝喷注，并加入新形成的赝喷注。\n3. 当只剩下一个 `PseudoJet` 时，过程终止。这个 `PseudoJet` 就是聚类树的根。\n\n**3. 未经修饰的可观测量：$z_{\\text{last}}$**\n\n可观测量 $z_{\\text{last}}$ 是对 C/A 序列中最后一次分裂的动量平衡的度量。它是直接从树的根节点的两个子节点计算得出的。如果它们的动量是 $p_{T,1}$ 和 $p_{T,2}$，则 $z_{\\text{last}} = \\min(p_{T,1}, p_{T,2}) / (p_{T,1} + p_{T,2})$。\n\n这个可观测量是共线安全的，因为共线分裂产生的粒子具有非常小的角分离。C/A 算法会在早期阶段将它们合并，从而使最后的、角度最宽的分裂保持不变。然而，$z_{\\text{last}}$ 是软不安全的。如事件 1 所示，一个宽角度的软粒子（例如，$p_T = 10^{-6}\\,\\text{GeV}$ 在 $\\phi=1.0$ 处）最后被合并。这个末次分裂变得极不平衡，导致当软粒子的动量趋于零时 $z_{\\text{last}} \\to 0$，使得该可观测量对软辐射敏感。\n\n**4. 修饰后的可观测量：使用 Soft Drop 的 $z_g$**\n\nSoft Drop 修饰旨在通过移除软的、宽角度的辐射来恢复 Sudakov 安全性。它通过“解聚”C/A 树来操作，实际上是反转了聚类过程。我们的实现是一个从根向下遍历树的递归函数：\n\n`get_zg(node, z_cut)`:\n1.  **基例**：如果 `node` 是一个叶节点（没有子节点），这意味着我们已经解聚到了一个初始粒子，但没有找到满足修饰条件的分裂。根据定义，我们返回 $z_g=0$。\n2.  **递归步骤**：如果 `node` 有动量为 $p_{T,1}$ 和 $p_{T,2}$ 的子节点，我们计算动量分配 $z = \\min(p_{T,1}, p_{T,2}) / (p_{T,1} + p_{T,2})$。\n    a.  **条件通过**：如果 $z > z_\\text{cut}$，则该分裂被认为“足够硬”。我们接受这个分裂，并返回其 $z$ 值作为最终的 $z_g$。递归终止。\n    b.  **条件失败**：如果 $z \\le z_\\text{cut}$，则该分裂太软。丢弃较软的子分支，并在较硬的子分支上递归调用函数：`get_zg(harder_child, z_cut)`。\n\n对于事件 1，当 $z_\\text{cut}=0.1$ 或 $z_\\text{cut}=0.01$ 时，树根处的初始软分裂不满足条件。算法继续到硬喷注内部的下一个分裂，这个分裂是平衡的（$z=1/3$）并且通过了条件，得出 $z_g=1/3$。这展示了软污染的移除。当 $z_\\text{cut} \\to 0$（例如，$z_\\text{cut} = 10^{-9}$）时，Soft Drop 条件变得更加宽松。最初的软分裂现在满足条件（$z_{\\text{last}} \\approx 6.7 \\times 10^{-9} > 10^{-9}$），因此 $z_g$ 变得等于 $z_{\\text{last}}$，恢复了未经修饰的、软不安全的行为。\n\n对于事件 2，几乎共线的粒子首先被合并，模拟了一个单一的硬叉。末次分裂发生在两个硬组分之间，产生了一个大的 $z_{\\text{last}} = 1/3$。这个分裂立即满足所有给定 $z_\\text{cut}$ 值的 Soft Drop 条件，因此始终有 $z_g = z_{\\text{last}} = 1/3$。这说明了该过程的共线安全性。\n\n边界情况，即事件 3，只有一个粒子，没有分裂，因此按照惯例，无论是 $z_{\\text{last}}$ 还是所有的 $z_g$ 值都定义为 $0$。\n\n实现将为所有测试用例计算这些值，并按要求格式化它们。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are permitted.\n\nclass PseudoJet:\n    \"\"\"\n    Represents a particle or a cluster of particles (jet) with its kinematic\n    properties and clustering history.\n    \"\"\"\n    def __init__(self, pT, phi, children=None):\n        self.pT = np.float64(pT)\n        self.phi = np.float64(phi)\n        self.children = children  # A tuple (child1, child2) or None for leaves\n\ndef solve_for_event(particles_data):\n    \"\"\"\n    Performs C/A clustering and calculates z_last and z_g for a single event.\n    \"\"\"\n    num_particles = len(particles_data)\n\n    # Handle boundary cases as per problem definition\n    if num_particles = 1:\n        return [0.0, 0.0, 0.0, 0.0]\n\n    # Initialize list of active pseudojets\n    active_jets = [PseudoJet(pT, phi) for pT, phi in particles_data]\n\n    # Cambridge/Aachen clustering loop\n    while len(active_jets) > 1:\n        min_dist = np.inf\n        best_pair_indices = None\n\n        # Find pair with minimum angular distance\n        for i in range(len(active_jets)):\n            for j in range(i + 1, len(active_jets)):\n                dist = np.abs(active_jets[i].phi - active_jets[j].phi)\n                if dist  min_dist:\n                    min_dist = dist\n                    best_pair_indices = (i, j)\n        \n        # Unpack indices, ensuring i  j for easier list manipulation\n        i, j = sorted(best_pair_indices)\n        jet1, jet2 = active_jets[i], active_jets[j]\n\n        # pT-scheme recombination\n        new_pT = jet1.pT + jet2.pT\n        new_phi = (jet1.pT * jet1.phi + jet2.pT * jet2.phi) / new_pT\n        \n        # Create new jet, storing its history\n        new_jet = PseudoJet(new_pT, new_phi, children=(jet1, jet2))\n        \n        # Update the list of active jets for the next iteration\n        # Remove merged jets (larger index first) and add the new one\n        active_jets.pop(j)\n        active_jets.pop(i)\n        active_jets.append(new_jet)\n        \n    root_node = active_jets[0]\n\n    # Calculate z_last from the final split\n    child1, child2 = root_node.children\n    z_last = np.min([child1.pT, child2.pT]) / (child1.pT + child2.pT)\n\n    # Calculate z_g for specified z_cut values\n    z_cuts = [0.1, 0.01, 1e-9]\n    z_g_values = []\n    \n    def get_zg_recursive(node, z_cut):\n        \"\"\"\n        Recursively applies the Soft Drop grooming condition.\n        \"\"\"\n        # Base case: leaf node reached, no split passed the condition\n        if not node.children:\n            return np.float64(0.0)\n\n        pT1, pT2 = node.children[0].pT, node.children[1].pT\n        \n        # Momentum sharing for the current split\n        z = np.min([pT1, pT2]) / (pT1 + pT2)\n\n        if z > z_cut:\n            # Soft Drop condition passed, this is the groomed split\n            return z\n        else:\n            # Condition failed, drop softer branch and continue on harder branch\n            if pT1 > pT2:\n                harder_child = node.children[0]\n            else:\n                harder_child = node.children[1]\n            return get_zg_recursive(harder_child, z_cut)\n\n    for z_cut in z_cuts:\n        zg = get_zg_recursive(root_node, z_cut)\n        z_g_values.append(zg)\n\n    return [z_last] + z_g_values\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Event 1: soft-unsafe demonstration\n        [(100, 0.0), (50, 0.1), (1e-6, 1.0)],\n        # Event 2: collinear safety check\n        [(70, 0.0), (30, 1e-6), (50, 0.8)],\n        # Event 3: boundary case with one particle\n        [(123, 0.5)],\n    ]\n\n    results = []\n    for case in test_cases:\n        result_list = solve_for_event(case)\n        results.append(result_list)\n\n    # Format the output exactly as specified.\n    # The output is a string representation of a list of lists of floats.\n    list_strs = []\n    for res_list in results:\n        # Format each inner list to \"[v1,v2,v3,v4]\"\n        list_str = f\"[{','.join(map(str, res_list))}]\"\n        list_strs.append(list_str)\n\n    # Join the inner list strings into the final format \"[[...],[...]]\"\n    final_output_str = f\"[{','.join(list_strs)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "即使在 IRC 安全算法家族内部，不同的参数选择也会导致具有重要物理意义的独特行为。本练习聚焦于 $k_T$ 算法，并研究一个发生在两个喷注边界附近的硬共线分裂，如何导致其碎片被划分到不同的末态喷注中。这个练习揭示了 IRC 安全性是一个极限性质，对于有限的分离角，聚类动力学可能相当复杂，这凸显了理解所选喷注定义的具体属性的重要性 。",
            "id": "3517893",
            "problem": "您必须实现一个完整的、可运行的程序，该程序使用幂参数 $p=1$（即 $k_T$ 算法）的广义 $k_T$ 度规对顺序重组喷注算法进行基准测试，并在受控的合成事件中演示，在有限张角下，靠近喷注边界的硬共线分裂如何改变喷注归属，同时该算法在极限情况下仍保持红外和共线 (Infrared and Collinear (IRC)) 安全。程序必须在快度-方位角平面中构建事件，并严格按照规定运行 $k_T$ 聚类。输出必须是单行内容，包含一个由方括号括起来、逗号分隔的布尔值列表，对应所提供的测试套件。\n\n使用的基本原理：\n- 对于幂参数 $p$，广义 $k_T$ 算法的距离定义为\n$$\nd_{ij} = \\min\\left(p_{T,i}^{2p},\\,p_{T,j}^{2p}\\right)\\,\\frac{\\Delta R_{ij}^{2}}{R^{2}},\\qquad d_{iB}=p_{T,i}^{2p},\n$$\n其中 $p_{T,i}$ 是粒子 $i$ 的横向动量，$R$ 是半径参数，$\\Delta R_{ij}^{2} = (\\Delta y_{ij})^{2}+(\\Delta \\phi_{ij})^{2}$，$y$ 是快度，$\\phi$ 是以弧度为单位的方位角。对于 $k_T$ 算法，$p=1$。\n- 聚类过程重复寻找所有 $d_{ij}$ 和 $d_{iB}$ 中的最小值：\n  - 如果某个 $d_{ij}$ 最小，则使用四动量（$E$-方案）重组来合并 $i$ 和 $j$。\n  - 如果某个 $d_{iB}$ 最小，则将 $i$ 从列表中移除，并宣布其为一个最终喷注。\n- 红外和共线安全意味着，在 $p_T\\to 0$ 或张角 $\\epsilon\\to 0$ 的极限下，添加一个 $p_T$ 趋于零的粒子或将一个粒子分裂成共线碎片，都不会改变 IRC 安全的可观测量。\n\n事件构建：\n- 您将在 $(y,\\phi)$ 平面中构建合成事件，所有粒子的快度均为 $y=0$。角度以弧度为单位，横向动量以吉电子伏特 (GeV) 为单位。\n- 两个硬核初始喷注被放置在固定的方位角上：\n  - 喷注 A：方位角 $\\phi_A = 0.0$，横向动量 $p_{T,A} = 100.0$ GeV。\n  - 喷注 B：方位角 $\\phi_B = 1.2$，横向动量 $p_{T,B} = 100.0$ GeV。\n- 第三个硬粒子（“父粒子”）被放置在 A 和 B 之间几何中点边界附近。几何中点位于 $\\phi_{\\text{mid}} = (\\phi_A+\\phi_B)/2 = 0.6$。父粒子的横向动量为 $p_{T,P} = 30.0$ GeV，方位角为\n$$\n\\phi_P = \\phi_{\\text{mid}} - \\delta = 0.6 - \\delta,\n$$\n其中 $\\delta$ 是一个小的正偏移量，使其刚好位于边界的 A 侧。\n- 在“分裂”构型中，父粒子被替换为两个子粒子，其张角为 $\\epsilon$（方位角上的完全分离），动量分数为 $z$：\n  - 子粒子 1：$p_{T,1} = z\\,p_{T,P}$，位于 $\\phi_1 = \\phi_P - \\epsilon/2$。\n  - 子粒子 2：$p_{T,2} = (1-z)\\,p_{T,P}$，位于 $\\phi_2 = \\phi_P + \\epsilon/2$。\n- 在“未分裂”构型中，父粒子作为一个单独的粒子包含在内，位于 $\\phi_P$，动量为 $p_{T,P}$。\n\n聚类和归属判据：\n- 使用 $k_T$ 算法，其中 $p=1$，半径 $R=1.0$。\n- 使用四动量（$E$-方案）重组，所有粒子均视为在 $y=0$ 处的无质量粒子。每次合并后，您必须根据重组后的四动量重新计算 $p_T$ 和 $\\phi$。\n- 跟踪每个最终喷注的组分，以便保留硬核标签。\n- 定义“喷注归属改变”布尔值如下。在未分裂事件中，确定父粒子最终属于包含硬核种子 A 还是硬核种子 B 的最终喷注。在分裂事件中，确定两个子粒子被分配到哪个最终硬核喷注。当且仅当在未分裂和分裂事件中，捕获父粒子动量的硬核喷注集合不同时，返回“改变”为 true。具体来说：\n  - 如果在未分裂事件中，父粒子归于硬核喷注 A，但在分裂事件中，至少有一个子粒子归于硬核喷注 B，则归属发生改变 (true)。\n  - 如果在分裂事件中，两个子粒子最终都归于与未分裂父粒子相同的硬核喷注，则归属未改变 (false)。\n  - 如果两个子粒子最终分裂到 A 和 B 两个喷注中，这也算作改变 (true)，除非未分裂的父粒子也被分裂了（在这些受控事件中不应发生这种情况）。\n- 您的程序必须为每个提供的测试用例计算此布尔值，无需任何用户输入。\n\n科学目标：\n- 证明对于边界附近有限但小的张角 $\\epsilon$，$k_T$ 度规可以改变聚类序列，从而导致与未分裂的父粒子相比，不同的硬核种子捕获这些碎片，进而改变喷注归属。\n- 通过显示当 $\\epsilon \\to 0$ 时，归属恢复到未分裂时的结果，从而在数值上验证共线安全性。\n\n单位与数值精度：\n- 所有角度均以弧度为单位。\n- 所有横向动量均以吉电子伏特 (GeV) 为单位。\n- 输出为布尔值，因此无需进行单位转换。\n- 使用标准的双精度算术。\n\n测试套件：\n- 使用 $R=1.0$, $\\phi_A=0.0$, $\\phi_B=1.2$, $p_{T,A}=100.0$ GeV, $p_{T,B}=100.0$ GeV, $p_{T,P}=30.0$ GeV, 快度 $y=0$。\n- 对于每个测试用例，元组为 $(\\epsilon, z, \\delta)$。\n  1. $(0.41, 0.5, 2\\times 10^{-4})$。\n  2. $(0.2, 0.5, 2\\times 10^{-4})$。\n  3. $(10^{-3}, 0.5, 2\\times 10^{-4})$。\n  4. $(0.41, 0.9, 2\\times 10^{-4})$。\n  5. $(0.41, 0.5, 0.05)$。\n- 将这些解释为：张角 $\\epsilon$、动量分数 $z$ 和边界偏移量 $\\delta$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由逗号分隔并用方括号括起来的结果列表（例如，`[result_1,result_2,result_3,result_4,result_5]`），其中每个 `result_i` 要么是 `True` 要么是 `False`，按顺序对应每个测试用例。\n\n约束条件：\n- 程序必须是自包含的，不需要输入，只使用 Python 标准库和指定的库，并精确实现上述的距离度量和聚类方法。",
            "solution": "对用户提供的问题陈述进行严格的验证过程，以确定其科学和逻辑上的完整性。\n\n### 第 1 步：提取已知条件\n问题提供了以下数据、定义和约束：\n- **算法**：广义 $k_T$ 喷注算法，幂参数 $p=1$。\n- **距离度规**：\n  - 对距离：$d_{ij} = \\min(p_{T,i}^{2p}, p_{T,j}^{2p}) \\frac{\\Delta R_{ij}^{2}}{R^{2}}$，其中 $p=1$。\n  - 束流距离：$d_{iB} = p_{T,i}^{2p}$，其中 $p=1$。\n  - 角距离：$\\Delta R_{ij}^{2} = (\\Delta y_{ij})^{2} + (\\Delta \\phi_{ij})^{2}$。\n- **聚类过程**：在每一步中，找到所有 $d_{ij}$ 和 $d_{iB}$ 中的最小值。如果 $d_{ij}$ 是最小值，则合并粒子 $i$ 和 $j$。如果 $d_{iB}$ 是最小值，则宣布粒子 $i$ 为一个最终喷注。此过程持续进行，直到没有剩余粒子可供聚类。\n- **重组**：指定了 $E$-方案（四动量相加）。粒子被视为快度 $y=0$ 处的无质量实体。\n- **事件参数**：\n  - 喷注半径：$R=1.0$。\n  - 硬核“种子”粒子：\n    - 喷注 A：$p_{T,A} = 100.0$ GeV, $\\phi_A = 0.0$ rad, $y_A=0$。\n    - 喷注 B：$p_{T,B} = 100.0$ GeV, $\\phi_B = 1.2$ rad, $y_B=0$。\n  - 附加粒子（“父粒子”P）：$p_{T,P} = 30.0$ GeV，位于方位角 $\\phi_P = 0.6 - \\delta$，其中 $\\phi_{\\text{mid}}=(\\phi_A+\\phi_B)/2 = 0.6$。\n- **事件构型**：\n  - **未分裂**：事件包含粒子 A、B 和 P。\n  - **分裂**：粒子 P 被一次共线分裂产生的两个子粒子（D1、D2）取代：\n    - 子粒子 1：$p_{T,1} = z \\cdot p_{T,P}$, $\\phi_1 = \\phi_P - \\epsilon/2$。\n    - 子粒子 2：$p_{T,2} = (1-z) \\cdot p_{T,P}$, $\\phi_2 = \\phi_P + \\epsilon/2$。\n- **归属改变判据**：一个布尔值，指示在未分裂和分裂构型之间，捕获父粒子（P）或其子粒子（D1、D2）动量的硬核喷注（A 或 B）集合是否不同。\n- **测试套件**：一组五个测试用例，每个由一个元组 $(\\epsilon, z, \\delta)$ 定义：\n  1. $(0.41, 0.5, 2 \\times 10^{-4})$\n  2. $(0.2, 0.5, 2 \\times 10^{-4})$\n  3. $(10^{-3}, 0.5, 2 \\times 10^{-4})$\n  4. $(0.41, 0.9, 2 \\times 10^{-4})$\n  5. $(0.41, 0.5, 0.05)$\n- **输出**：单行内容，包含一个由方括号括起来、逗号分隔的布尔结果列表（例如 `[True,False,True,True,False]`）。\n\n### 第 2 步：验证\n根据所需标准对问题进行评估：\n- **有科学依据**：问题基于高能物理学的标准概念，即喷注算法（$k_T$ 算法）和红外与共线（IRC）安全性。该设置是探测算法属性的有效理论练习。\n- **问题明确**：问题是确定性的。给定一组粒子，$k_T$ 算法会产生一组唯一的喷注。所有参数、重组方案和评估标准都得到了明确无歧义的定义。\n- **客观性**：问题以精确、正式的语言陈述，没有主观性或个人意见。\n- **完整性和一致性**：提供了所有必要的值（$p_T$、$\\phi$、$R$、$p$ 等）和定义。没有内部矛盾。\n- **可行性**：该设置是一个受控的数值实验，就其目的而言，在计算上是可行的，在科学上是合理的。\n\n### 第 3 步：结论与行动\n问题被判定为**有效**。这是一个在高能物理学领域中定义明确的计算任务。可以继续进行求解过程。\n\n### 解决方案\n\n目标是实现 $k_T$ 喷注聚类算法 ($p=1$)，并将其应用于合成的粒子碰撞事件，以测试靠近喷注边界的共线分裂如何影响最终的喷注结构。该分析突出了算法的一个关键特性：虽然它在零张角（$\\epsilon \\to 0$）的极限下是 IRC 安全的，但对于有限的 $\\epsilon$，聚类结果可能是非平凡的。\n\n首先，我们建立运动学表示。所有粒子都是无质量的，并且位于快度 $y=0$。一个具有横向动量 $p_{T,i}$ 和方位角 $\\phi_i$ 的粒子 $i$，其四动量 $P_i^\\mu = (E_i, p_{x,i}, p_{y,i}, p_{z,i})$ 由以下公式给出：\n$$\nP_i^\\mu = (p_{T,i}, p_{T,i} \\cos\\phi_i, p_{T,i} \\sin\\phi_i, 0)\n$$\n因为对于无质量粒子 $E = |\\vec{p}|$，且对于 $y=0$，$p_z=0$，因此 $E=|\\vec{p}_T|=p_T$。\n\n$k_T$ 算法 ($p=1$) 使用以下距离度量：\n- 两个粒子 $i$ 和 $j$ 之间的距离：\n$$\nd_{ij} = \\min(p_{T,i}^2, p_{T,j}^2) \\frac{\\Delta R_{ij}^2}{R^2}\n$$\n- 一个粒子 $i$ 和束流之间的距离（“束流距离”）：\n$$\nd_{iB} = p_{T,i}^2\n$$\n这里，$R=1.0$ 是喷注半径参数。在快度-方位角平面中的分离 $\\Delta R_{ij}^2$ 是 $\\Delta R_{ij}^2 = (\\Delta y_{ij})^2 + (\\Delta \\phi_{ij})^2$。由于在整个聚类过程中所有粒子的 $y=0$，这简化为 $\\Delta R_{ij}^2 = (\\phi_i - \\phi_j)^2$。问题中的方位角都在 $[0, 1.2]$ 范围内，因此不需要考虑 $\\phi$ 的周期性边界条件。\n\n聚类算法过程如下：\n1. 初始化一个活动粒子列表。\n2. 在一个循环中，计算列表中当前所有粒子的成对距离 $d_{ij}$ 和所有束流距离 $d_{iB}$。\n3. 在所有计算出的距离中找到最小值。\n4. 如果最小值是成对距离 $d_{ij}$，则合并粒子 $i$ 和 $j$。这通过将它们从活动列表中移除，并添加一个新粒子来完成，新粒子的四动量是它们四动量之和（$P_{\\text{new}}^\\mu = P_i^\\mu + P_j^\\mu$）。然后从 $P_{\\text{new}}^\\mu$ 计算新粒子的运动学属性（$p_T, \\phi$）。具体来说，\n   $$\n   p_{T,\\text{new}} = \\sqrt{(p_{x,i} + p_{x,j})^2 + (p_{y,i} + p_{y,j})^2}\n   $$\n   $$\n   \\phi_{\\text{new}} = \\text{atan2}(p_{y,i} + p_{y,j}, p_{x,i} + p_{x,j})\n   $$\n5. 如果最小距离是束流距离 $d_{iB}$，则将粒子 $i$ 从活动列表中移除，并宣布其为末态喷注。\n6. 当活动列表为空时，循环终止。\n\n为了确定喷注归属是否因分裂而改变，我们必须跟踪能量的来源。每个初始粒子都被赋予一个唯一的标签（例如，'A', 'B', 'P'）。当两个粒子合并时，新粒子继承其组分标签的并集。聚类之后，我们检查最终喷注的组分。\n\n对于每个测试用例 $(\\epsilon, z, \\delta)$：\n- 我们构建并聚类一个包含粒子 A、B 和 P 的“未分裂”事件。我们通过找到包含标签 'P' 的最终喷注，并检查它是否也包含 'A' 或 'B'，来确定哪个硬核种子（'A' 或 'B'）捕获了粒子 P。这定义了基线归属。\n- 然后我们构建并聚类一个包含粒子 A、B 和两个子粒子 D1、D2 的“分裂”事件。我们找到哪些最终喷注包含标签 'D1' 和 'D2'，并识别它们各自的硬核种子（'A' 或 'B'）。\n- 如果在分裂情况下捕获父粒子动量的硬核种子集合与未分裂情况下的单个硬核种子不同，则归属被声明为“已改变”（True）。对于指定的场景，未分裂的父粒子 P 总是更靠近 A，并将被聚类到喷注 A 中。如果 D1 或 D2（或两者）被聚类到喷注 B 中，则发生改变。\n\n问题的核心在于探究子粒子之间相互的距离 $d_{D1,D2}$ 与它们到硬核种子的距离 $d_{A,Dk}$ 和 $d_{B,Dk}$ 之间的竞争。\n- 如果分裂角 $\\epsilon$ 非常小，$d_{D1,D2} \\propto \\epsilon^2$ 将是最小的距离。子粒子将首先相互合并，有效地重新创建父粒子 P。随后的聚类将与未分裂情况相同，导致没有变化。这证明了共线安全性的原理。\n- 如果 $\\epsilon$ 足够大，一个子粒子可能会被“拉”向另一个硬核喷注 B。对于距离中点 $\\phi_{\\text{mid}}$ 为 $\\delta$ 的父粒子，子粒子 D2 位于 $\\phi_2 = \\phi_{\\text{mid}} - \\delta + \\epsilon/2$。如果 $\\phi_2 > \\phi_{\\text{mid}}$，它在几何上会比喷注 A（在 $\\phi_A=0$）更接近喷注 B（在 $\\phi_B=2\\phi_{\\text{mid}}$），这在 $\\epsilon > 2\\delta$ 时发生。如果这种几何上的拉力没有被距离度规中的 $p_T$ 因子抵消，D2 可能会与 B 合并，导致喷注归属的改变。这正是问题旨在为有限 $\\epsilon$ 演示的效果。",
            "answer": "```python\nimport numpy as np\n\n# No other libraries are permitted.\n\nclass Particle:\n    \"\"\"Represents a particle in the event.\"\"\"\n    def __init__(self, pt, phi, constituents):\n        self.pt = pt\n        self.phi = phi\n        self.y = 0.0  # All particles at y=0 as per problem spec\n        # constituents is a set of original particle labels (e.g., {'A', 'P'})\n        self.constituents = frozenset(constituents)\n        \n        # Pre-calculate Cartesian components for E-scheme recombination\n        self.px = self.pt * np.cos(self.phi)\n        self.py = self.pt * np.sin(self.phi)\n\ndef recombine(p1, p2):\n    \"\"\"\n    Merges two particles using E-scheme recombination.\n    Assumes massless particles at y=0.\n    \"\"\"\n    new_px = p1.px + p2.px\n    new_py = p1.py + p2.py\n    \n    new_pt = np.sqrt(new_px**2 + new_py**2)\n    new_phi = np.arctan2(new_py, new_px)\n    \n    new_constituents = p1.constituents.union(p2.constituents)\n    \n    return Particle(new_pt, new_phi, new_constituents)\n\ndef run_clustering(initial_particles, R):\n    \"\"\"\n    Performs sequential recombination jet clustering with the k_T algorithm (p=1).\n    \"\"\"\n    particles = list(initial_particles)\n    jets = []\n    R2 = R**2\n\n    while particles:\n        if len(particles) == 1:\n            jets.append(particles[0])\n            break\n\n        min_dist = float('inf')\n        min_idx = (-1, -1)\n        is_beam_merge = False\n\n        # Calculate beam distances (d_iB)\n        for i, p in enumerate(particles):\n            dist = p.pt**2\n            if dist  min_dist:\n                min_dist = dist\n                min_idx = (i, -1) # -1 indicates beam merge\n                is_beam_merge = True\n\n        # Calculate pair distances (d_ij)\n        num_particles = len(particles)\n        for i in range(num_particles):\n            for j in range(i + 1, num_particles):\n                p_i, p_j = particles[i], particles[j]\n                \n                # Since y=0 for all particles, delta_R^2 = delta_phi^2\n                # Azimuthal difference is simple subtraction as values are in [0, 1.2]\n                delta_phi = p_i.phi - p_j.phi\n                delta_R2 = delta_phi**2\n                \n                min_pt2 = min(p_i.pt**2, p_j.pt**2)\n                dist = min_pt2 * delta_R2 / R2\n                \n                if dist  min_dist:\n                    min_dist = dist\n                    min_idx = (i, j)\n                    is_beam_merge = False\n        \n        if is_beam_merge:\n            i = min_idx[0]\n            jets.append(particles.pop(i))\n        else:\n            i, j = min_idx\n            # Ensure j > i for correct pop order\n            if i > j: \n                i, j = j, i\n            \n            p_i = particles[i]\n            p_j = particles[j]\n            \n            new_p = recombine(p_i, p_j)\n            \n            # Remove in reverse index order to avoid shifting\n            particles.pop(j)\n            particles.pop(i)\n            particles.append(new_p)\n            \n    return jets\n\ndef get_jet_seeds(jets, particle_labels):\n    \"\"\"\n    Finds which hard jets ('A' or 'B') captured specified particle labels.\n    \"\"\"\n    seeds = set()\n    for label in particle_labels:\n        for jet in jets:\n            if label in jet.constituents:\n                if 'A' in jet.constituents:\n                    seeds.add('A')\n                elif 'B' in jet.constituents:\n                    seeds.add('B')\n                # If a jet contains a daughter but not A or B, it's a new jet.\n                # In this problem, due to high pT of A, B, this won't happen.\n    return seeds\n\ndef solve():\n    test_cases = [\n        # (epsilon, z, delta)\n        (0.41, 0.5, 2e-4),\n        (0.2, 0.5, 2e-4),\n        (1e-3, 0.5, 2e-4),\n        (0.41, 0.9, 2e-4),\n        (0.41, 0.5, 0.05),\n    ]\n\n    # Global parameters\n    R = 1.0\n    pT_A, phi_A = 100.0, 0.0\n    pT_B, phi_B = 100.0, 1.2\n    pT_P = 30.0\n    phi_mid = (phi_A + phi_B) / 2.0 # 0.6\n\n    results = []\n    \n    for epsilon, z, delta in test_cases:\n        # Define hard seeds, common to both configurations\n        particle_A = Particle(pT_A, phi_A, {'A'})\n        particle_B = Particle(pT_B, phi_B, {'B'})\n\n        phi_P = phi_mid - delta\n\n        # 1. Unsplit configuration\n        particle_P = Particle(pT_P, phi_P, {'P'})\n        unsplit_initial = [particle_A, particle_B, particle_P]\n        unsplit_jets = run_clustering(unsplit_initial, R)\n        unsplit_assignment = get_jet_seeds(unsplit_jets, {'P'})\n\n        # 2. Split configuration\n        pT_D1 = z * pT_P\n        phi_D1 = phi_P - epsilon / 2.0\n        daughter1 = Particle(pT_D1, phi_D1, {'D1'})\n\n        pT_D2 = (1.0 - z) * pT_P\n        phi_D2 = phi_P + epsilon / 2.0\n        daughter2 = Particle(pT_D2, phi_D2, {'D2'})\n        \n        split_initial = [particle_A, particle_B, daughter1, daughter2]\n        split_jets = run_clustering(split_initial, R)\n        split_assignment = get_jet_seeds(split_jets, {'D1', 'D2'})\n        \n        # 3. Compare assignments\n        assignment_changed = (unsplit_assignment != split_assignment)\n        results.append(str(assignment_changed))\n\n    # Format and print the final output exactly as required\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}