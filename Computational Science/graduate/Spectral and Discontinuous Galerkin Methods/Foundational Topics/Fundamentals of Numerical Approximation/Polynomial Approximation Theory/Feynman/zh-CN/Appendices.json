{
    "hands_on_practices": [
        {
            "introduction": "在多项式逼近理论中，核心目标是找到一个“最接近”给定函数的多项式。我们通常使用 $L^2$ 范数来度量这种“接近”程度，而 $L^2$ 投影则是找到最佳逼近的数学工具。本练习  以一个简单的函数 $f(x)=x^2$ 为例，通过计算其勒让德 (Legendre) 级数并进行截断，具体展示了如何构造其在低阶多项式空间中的最佳 $L^2$ 逼近，并验证其最优性。",
            "id": "3408976",
            "problem": "考虑守恒律的高阶谱方法和间断Galerkin方法中使用的一维参考元 $[-1,1]$。设 $\\{P_n(x)\\}_{n=0}^{\\infty}$ 表示 $[-1,1]$ 上的Legendre多项式，其权重为 $w(x)=1$，特征为 $P_0(x)=1$, $P_1(x)=x$，且满足正交性 $\\int_{-1}^{1} P_n(x) P_m(x)\\,dx = \\frac{2}{2n+1}\\,\\delta_{nm}$。设内积和诱导范数分别为 $\\langle u,v\\rangle := \\int_{-1}^{1} u(x)v(x)\\,dx$ 和 $\\|u\\|_{L^2(-1,1)} := \\sqrt{\\langle u,u\\rangle}$。定义 $f(x)=x^2$。\n\n仅使用Legendre基的正交性以及到 $\\mathbb{P}_1 := \\operatorname{span}\\{1,x\\}$ 上的 $L^2$ 投影的变分表征（即投影 $p_1 \\in \\mathbb{P}_1$ 满足对于所有 $q \\in \\mathbb{P}_1$ 都有 $\\langle f-p_1, q\\rangle = 0$），完成以下任务：\n\n1) 计算函数 $f$ 在基 $\\{P_n\\}$ 中的Legendre模态系数。\n\n2) 使用这些系数构造函数 $f$ 到 $\\mathbb{P}_1$ 上的 $L^2$ 投影 $p_1$。\n\n3) 通过检查正交条件以及利用Legendre基正交性所诱导的勾股分解，来验证 $p_1$ 是 $f$ 的唯一最佳 $L^2$ 近似。\n\n以 $p_1(x)$ 的精确解析表达式的形式报告你的最终答案。无需四舍五入，不涉及单位。你的最终方框答案必须只包含 $p_1(x)$ 的表达式。",
            "solution": "该问题是适定的，具有科学依据，并包含了获得唯一解所需的所有信息。这是多项式逼近理论中的一个标准练习。我们将按照指定的三个步骤进行求解。\n\n待逼近的函数是区间 $[-1,1]$ 上的 $f(x)=x^2$。逼近空间是 $\\mathbb{P}_1$，即次数至多为1的多项式空间，它由前两个Legendre多项式 $\\{P_0(x), P_1(x)\\}$ 张成。Legendre多项式 $\\{P_n(x)\\}$ 构成了平方可积函数空间 $L^2(-1,1)$ 关于内积 $\\langle u,v\\rangle = \\int_{-1}^{1} u(x)v(x)\\,dx$ 的一个正交基。其正交性质为 $\\langle P_n, P_m \\rangle = \\frac{2}{2n+1}\\delta_{nm}$。\n\n**1) 计算Legendre模态系数**\n\n任何函数 $f \\in L^2(-1,1)$ 都可以用其Legendre级数展开来表示：\n$$f(x) = \\sum_{n=0}^{\\infty} \\hat{f}_n P_n(x)$$\n其中模态系数 $\\hat{f}_n$ 是通过将 $f$ 投影到每个基函数 $P_n$ 上得到的：\n$$\\hat{f}_n = \\frac{\\langle f, P_n \\rangle}{\\langle P_n, P_n \\rangle} = \\frac{\\langle f, P_n \\rangle}{\\|P_n\\|^2}$$\n使用给定的归一化 $\\|P_n\\|^2 = \\frac{2}{2n+1}$，系数的公式变为：\n$$\\hat{f}_n = \\frac{2n+1}{2} \\int_{-1}^{1} f(x) P_n(x) \\,dx$$\n在本问题中，$f(x)=x^2$。由于 $f(x)$ 是一个2次多项式，其Legendre级数将是有限的，在 $n=2$ 处终止。我们可以通过直接的代数变换来求系数。给定 $P_0(x)=1$ 和 $P_1(x)=x$。第三个Legendre多项式是 $P_2(x) = \\frac{1}{2}(3x^2-1)$。我们可以用 $P_0(x)$ 和 $P_2(x)$ 来表示 $x^2$：\n$$P_2(x) = \\frac{3}{2}x^2 - \\frac{1}{2}P_0(x) \\implies \\frac{3}{2}x^2 = P_2(x) + \\frac{1}{2}P_0(x)$$\n$$x^2 = \\frac{2}{3}P_2(x) + \\frac{1}{3}P_0(x)$$\n因此，$f(x)=x^2$ 的精确Legendre级数为：\n$$f(x) = \\frac{1}{3}P_0(x) + 0 \\cdot P_1(x) + \\frac{2}{3}P_2(x)$$\n从这个展开式中，我们可以直接确定模态系数：\n$\\hat{f}_0 = \\frac{1}{3}$\n$\\hat{f}_1 = 0$\n$\\hat{f}_2 = \\frac{2}{3}$\n对于所有 $n > 2$，$\\hat{f}_n = 0$。\n\n**2) 构造 $L^2$ 投影**\n\n函数 $f$ 到子空间 $\\mathbb{P}_k$（次数至多为 $k$ 的多项式）上的 $L^2$ 投影是通过在 $n=k$ 处截断Legendre级数得到的。在我们的例子中，我们寻求到 $\\mathbb{P}_1 = \\operatorname{span}\\{P_0, P_1\\}$ 上的投影 $p_1(x)$。它由下式给出：\n$$p_1(x) = \\sum_{n=0}^{1} \\hat{f}_n P_n(x) = \\hat{f}_0 P_0(x) + \\hat{f}_1 P_1(x)$$\n代入我们求出的系数：\n$$p_1(x) = \\left(\\frac{1}{3}\\right) P_0(x) + (0) P_1(x) = \\frac{1}{3}(1) + 0(x) = \\frac{1}{3}$$\n函数 $f(x)=x^2$ 到 $\\mathbb{P}_1$ 上的 $L^2$ 投影是常数函数 $p_1(x) = \\frac{1}{3}$。\n\n**3) 验证最佳逼近**\n\n我们必须验证 $p_1(x) = \\frac{1}{3}$ 是 $f(x)=x^2$ 在 $\\mathbb{P}_1$ 中的唯一最佳 $L^2$ 近似。\n\n**通过正交条件进行验证：**\n变分表征指出，$p_1$ 是 $L^2$ 投影当且仅当误差 $f-p_1$ 与逼近空间 $\\mathbb{P}_1$ 正交。即，对于所有 $q \\in \\mathbb{P}_1$ 都有 $\\langle f-p_1, q \\rangle = 0$。我们只需对 $\\mathbb{P}_1$ 的一个基（例如 $\\{P_0(x), P_1(x)\\} = \\{1, x\\}$）进行检查即可。\n误差函数为 $e(x) = f(x) - p_1(x) = x^2 - \\frac{1}{3}$。\n对于 $q(x) = P_0(x) = 1$：\n$$\\langle e, P_0 \\rangle = \\int_{-1}^{1} \\left(x^2 - \\frac{1}{3}\\right) (1) \\,dx = \\left[\\frac{x^3}{3} - \\frac{x}{3}\\right]_{-1}^{1} = \\left(\\frac{1}{3} - \\frac{1}{3}\\right) - \\left(-\\frac{1}{3} - (-\\frac{1}{3})\\right) = 0 - 0 = 0$$\n对于 $q(x) = P_1(x) = x$：\n$$\\langle e, P_1 \\rangle = \\int_{-1}^{1} \\left(x^2 - \\frac{1}{3}\\right) (x) \\,dx = \\int_{-1}^{1} \\left(x^3 - \\frac{x}{3}\\right) \\,dx$$\n被积函数是一个奇函数，且积分区间 $[-1,1]$ 是对称的，因此结果为 $0$。\n由于误差与 $\\mathbb{P}_1$ 的基向量正交，因此它与整个空间正交，从而证实 $p_1(x) = \\frac{1}{3}$ 是正确的 $L^2$ 投影。\n\n**通过勾股分解进行验证：**\n设 $q(x)$ 是 $\\mathbb{P}_1$ 中的任意多项式。我们要证明 $\\|f-p_1\\|^2 \\le \\|f-q\\|^2$。我们将误差 $f-q$ 分解为：\n$$f-q = (f-p_1) + (p_1-q)$$\n现在考虑 $L^2$范数的平方：\n$$\\|f-q\\|^2 = \\langle (f-p_1) + (p_1-q), (f-p_1) + (p_1-q) \\rangle$$\n$$= \\langle f-p_1, f-p_1 \\rangle + 2\\langle f-p_1, p_1-q \\rangle + \\langle p_1-q, p_1-q \\rangle$$\n$$= \\|f-p_1\\|^2 + 2\\langle f-p_1, p_1-q \\rangle + \\|p_1-q\\|^2$$\n项 $p_1-q$ 是 $\\mathbb{P}_1$ 中两个多项式的差，所以它也在 $\\mathbb{P}_1$ 中。误差项 $f-p_1$ 是 $x^2 - \\frac{1}{3} = \\frac{2}{3}P_2(x)$。根据Legendre多项式的正交性，$P_2$ 与 $\\mathbb{P}_1 = \\operatorname{span}\\{P_0, P_1\\}$ 中的每个多项式都正交。因此，交叉项为零：\n$$\\langle f-p_1, p_1-q \\rangle = \\left\\langle \\frac{2}{3}P_2(x), p_1(x)-q(x) \\right\\rangle = 0$$\n范数的平方简化为正交向量的勾股定理：\n$$\\|f-q\\|^2 = \\|f-p_1\\|^2 + \\|p_1-q\\|^2$$\n由于 $\\|p_1-q\\|^2 \\ge 0$，显然有 $\\|f-q\\|^2 \\ge \\|f-p_1\\|^2$。当 $\\|p_1-q\\|^2 = 0$ 时，达到最小逼近误差，这意味着 $p_1-q=0$（几乎处处成立）。这在 $q=p_1$ 时唯一发生。这证实了 $p_1(x)=\\frac{1}{3}$ 是从空间 $\\mathbb{P}_1$ 中对 $f(x)=x^2$ 的唯一最佳 $L^2$ 近似。",
            "answer": "$$\\boxed{\\frac{1}{3}}$$"
        },
        {
            "introduction": "虽然模态系数（如前一练习中所见）提供了函数逼近的完整描述，但在实际应用（尤其是在节点型不连续伽辽金方法中）中，我们更关心多项式在特定点上的值。本练习  旨在建立模态空间和节点空间之间的桥梁，通过在Gauss–Lobatto–Legendre (GLL) 节点上构造一个拉格朗日 (Lagrange) 插值多项式。通过亲手构建模态到节点的转换矩阵并计算一个具体的插值误差，您将对GLL节点和插值的机制有更深入的理解。",
            "id": "3409031",
            "problem": "考虑一维参考区间 $[-1,1]$ 以及在谱方法和间断伽辽金(DG)方法中使用的多项式插值框架。令 $\\{P_{n}(x)\\}_{n=0}^{\\infty}$ 表示在 $[-1,1]$ 上的勒让德多项式，它们关于权重 $1$ 是正交的，并被归一化以满足 $P_{n}(1)=1$。对于给定的多项式次数 $N$，高斯-洛巴托-勒让德(GLL)节点被定义为端点 $\\{-1,1\\}$ 与 $P_{N}'(x)$ 的 $N-1$ 个不同内部根的并集。\n\n使用次数 $N=3$ 进行计算。模态到节点插值矩阵 $V$ 定义为 $V_{jk}=P_{k}(x_{j})$，其中 $j=1,\\dots,N+1$ 且 $k=0,\\dots,N$，而 $\\{x_{j}\\}_{j=1}^{N+1}$ 是GLL节点。该矩阵将模态勒让德系数映射到GLL网格上一个 $N$ 次多项式的节点值。请在区间 $[-1,1]$ 上为 $N=3$ 显式构造此矩阵 $V$。\n\n然后，考虑函数 $f(x)=\\exp(x)$，并令 $p_{3}(x)$ 是其在 $N+1=4$ 个GLL节点上的 $3$ 次拉格朗日插值多项式。使用在不同节点上的拉格朗日插值的基本定义，推导出在 $x=0$ 处的插值权重 $\\{\\ell_{j}(0)\\}_{j=1}^{4}$，并计算在 $x=0$ 处的点态插值误差，定义为 $E(0)=f(0)-p_{3}(0)$。请将您的最终答案表示为单个闭式解析表达式。无需四舍五入，且不涉及单位。",
            "solution": "该问题是良定的，具有科学依据，并包含获得唯一解所需的所有信息。这是多项式逼近理论中的一个标准练习，具体涉及在高斯-洛巴托-勒让德节点上的拉格朗日插值。该问题被认为是有效的。\n\n解答按要求分三部分构建：首先，确定高斯-洛巴托-勒让德(GLL)节点并构造模态到节点矩阵 $V$；其次，推导在 $x=0$ 处的拉格朗日插值权重；第三，计算在 $x=0$ 处的点态插值误差。\n\n首先，我们确定在区间 $[-1,1]$ 上多项式次数为 $N=3$ 时的GLL节点。这些节点由端点 $\\{-1,1\\}$ 和勒让德多项式 $P_3(x)$ 的导数的根组成。归一化使得 $P_n(1)=1$ 的勒让德多项式为：\n$P_0(x) = 1$\n$P_1(x) = x$\n$P_2(x) = \\frac{1}{2}(3x^2 - 1)$\n$P_3(x) = \\frac{1}{2}(5x^3 - 3x)$\n\n$P_3(x)$ 的导数为：\n$$P_3'(x) = \\frac{d}{dx} \\left( \\frac{1}{2}(5x^3 - 3x) \\right) = \\frac{1}{2}(15x^2 - 3)$$\n令 $P_3'(x)=0$ 以求得内部节点：\n$$15x^2 - 3 = 0 \\implies x^2 = \\frac{3}{15} = \\frac{1}{5} \\implies x = \\pm \\frac{1}{\\sqrt{5}} = \\pm \\frac{\\sqrt{5}}{5}$$\n$N+1=4$ 个GLL节点，从小到大排序为：\n$$x_1 = -1, \\quad x_2 = -\\frac{\\sqrt{5}}{5}, \\quad x_3 = \\frac{\\sqrt{5}}{5}, \\quad x_4 = 1$$\n\n接下来，我们构造模态到节点插值矩阵 $V$，其定义为 $V_{jk} = P_k(x_j)$，其中 $j \\in \\{1, 2, 3, 4\\}$ 且 $k \\in \\{0, 1, 2, 3\\}$。我们在每个GLL节点上计算前四个勒让德多项式的值。\n对于 $x_1=-1$：$P_0(-1)=1$, $P_1(-1)=-1$, $P_2(-1)=1$, $P_3(-1)=-1$。\n对于 $x_4=1$：$P_0(1)=1$, $P_1(1)=1$, $P_2(1)=1$, $P_3(1)=1$。\n对于 $x_2=-\\frac{\\sqrt{5}}{5}$：\n$P_0(-\\frac{\\sqrt{5}}{5}) = 1$\n$P_1(-\\frac{\\sqrt{5}}{5}) = -\\frac{\\sqrt{5}}{5}$\n$P_2(-\\frac{\\sqrt{5}}{5}) = \\frac{1}{2}\\left(3\\left(-\\frac{\\sqrt{5}}{5}\\right)^2 - 1\\right) = \\frac{1}{2}\\left(\\frac{3}{5} - 1\\right) = -\\frac{1}{5}$\n$P_3(-\\frac{\\sqrt{5}}{5}) = \\frac{1}{2}\\left(5\\left(-\\frac{\\sqrt{5}}{5}\\right)^3 - 3\\left(-\\frac{\\sqrt{5}}{5}\\right)\\right) = \\frac{1}{2}\\left(-\\frac{1}{\\sqrt{5}} + \\frac{3}{\\sqrt{5}}\\right) = \\frac{1}{\\sqrt{5}} = \\frac{\\sqrt{5}}{5}$\n对于 $x_3=\\frac{\\sqrt{5}}{5}$：\n$P_0(\\frac{\\sqrt{5}}{5}) = 1$\n$P_1(\\frac{\\sqrt{5}}{5}) = \\frac{\\sqrt{5}}{5}$\n$P_2(\\frac{\\sqrt{5}}{5}) = \\frac{1}{2}\\left(3\\left(\\frac{\\sqrt{5}}{5}\\right)^2 - 1\\right) = -\\frac{1}{5}$\n$P_3(\\frac{\\sqrt{5}}{5}) = \\frac{1}{2}\\left(5\\left(\\frac{\\sqrt{5}}{5}\\right)^3 - 3\\left(\\frac{\\sqrt{5}}{5}\\right)\\right) = \\frac{1}{2}\\left(\\frac{1}{\\sqrt{5}} - \\frac{3}{\\sqrt{5}}\\right) = -\\frac{1}{\\sqrt{5}} = -\\frac{\\sqrt{5}}{5}$\n\n得到的模态到节点矩阵 $V$ 是：\n$$V = \\begin{pmatrix} P_0(x_1) & P_1(x_1) & P_2(x_1) & P_3(x_1) \\\\ P_0(x_2) & P_1(x_2) & P_2(x_2) & P_3(x_2) \\\\ P_0(x_3) & P_1(x_3) & P_2(x_3) & P_3(x_3) \\\\ P_0(x_4) & P_1(x_4) & P_2(x_4) & P_3(x_4) \\end{pmatrix} = \\begin{pmatrix} 1 & -1 & 1 & -1 \\\\ 1 & -\\frac{\\sqrt{5}}{5} & -\\frac{1}{5} & \\frac{\\sqrt{5}}{5} \\\\ 1 & \\frac{\\sqrt{5}}{5} & -\\frac{1}{5} & -\\frac{\\sqrt{5}}{5} \\\\ 1 & 1 & 1 & 1 \\end{pmatrix}$$\n\n最后，我们计算点态插值误差 $E(0) = f(0) - p_3(0)$，其中 $p_3(x)$ 是函数 $f(x) = \\exp(x)$ 在GLL节点上的 $3$ 次拉格朗日插值多项式。插值多项式在 $x=0$ 处的值为 $p_3(0) = \\sum_{j=1}^{4} f(x_j) \\ell_j(0)$，其中 $\\ell_j(x)$ 是拉格朗日基多项式。权重 $\\ell_j(0)$ 由 $\\ell_j(0) = \\prod_{k=1, k \\ne j}^{4} \\frac{0-x_k}{x_j-x_k}$ 给出。\n\n权重计算如下：\n$\\ell_1(0) = \\frac{(-x_2)(-x_3)(-x_4)}{(x_1-x_2)(x_1-x_3)(x_1-x_4)} = \\frac{(\\frac{\\sqrt{5}}{5})(-\\frac{\\sqrt{5}}{5})(-1)}{(-1+\\frac{\\sqrt{5}}{5})(-1-\\frac{\\sqrt{5}}{5})(-1-1)} = \\frac{\\frac{1}{5}}{(1 - \\frac{1}{5})(-2)} = \\frac{\\frac{1}{5}}{(\\frac{4}{5})(-2)} = \\frac{1/5}{-8/5} = -\\frac{1}{8}$。\n\n由于节点关于 $x=0$ 对称 ($x_1=-x_4, x_2=-x_3$)，我们可以推断出 $\\ell_4(0) = \\ell_1(0) = -\\frac{1}{8}$。我们来验证一下：\n$\\ell_4(0) = \\frac{(-x_1)(-x_2)(-x_3)}{(x_4-x_1)(x_4-x_2)(x_4-x_3)} = \\frac{(1)(\\frac{\\sqrt{5}}{5})(-\\frac{\\sqrt{5}}{5})}{(1-(-1))(1-(-\\frac{\\sqrt{5}}{5}))(1-\\frac{\\sqrt{5}}{5})} = \\frac{-1/5}{2(1-\\frac{1}{5})} = \\frac{-1/5}{2(4/5)} = \\frac{-1/5}{8/5} = -\\frac{1}{8}$。\n\n$\\ell_2(0) = \\frac{(-x_1)(-x_3)(-x_4)}{(x_2-x_1)(x_2-x_3)(x_2-x_4)} = \\frac{(1)(-\\frac{\\sqrt{5}}{5})(-1)}{(-\\frac{\\sqrt{5}}{5}-(-1))(-\\frac{\\sqrt{5}}{5}-\\frac{\\sqrt{5}}{5})(-\\frac{\\sqrt{5}}{5}-1)} = \\frac{\\frac{\\sqrt{5}}{5}}{(1-\\frac{\\sqrt{5}}{5})(-\\frac{2\\sqrt{5}}{5})(-1-\\frac{\\sqrt{5}}{5})} = \\frac{\\frac{\\sqrt{5}}{5}}{-(1-\\frac{1}{5})(-\\frac{2\\sqrt{5}}{5})} = \\frac{\\frac{\\sqrt{5}}{5}}{(\\frac{4}{5})(\\frac{2\\sqrt{5}}{5})} = \\frac{\\frac{\\sqrt{5}}{5}}{\\frac{8\\sqrt{5}}{25}} = \\frac{\\sqrt{5}}{5} \\frac{25}{8\\sqrt{5}} = \\frac{5}{8}$。\n\n同样，由于对称性，$\\ell_3(0) = \\ell_2(0) = \\frac{5}{8}$。权重之和为 $\\sum_{j=1}^{4} \\ell_j(0) = -\\frac{1}{8} + \\frac{5}{8} + \\frac{5}{8} - \\frac{1}{8} = \\frac{8}{8} = 1$，正如预期。\n\n在 $x=0$ 处的插值为：\n$$p_3(0) = f(x_1)\\ell_1(0) + f(x_2)\\ell_2(0) + f(x_3)\\ell_3(0) + f(x_4)\\ell_4(0)$$\n$$p_3(0) = \\exp(-1)\\left(-\\frac{1}{8}\\right) + \\exp\\left(-\\frac{\\sqrt{5}}{5}\\right)\\left(\\frac{5}{8}\\right) + \\exp\\left(\\frac{\\sqrt{5}}{5}\\right)\\left(\\frac{5}{8}\\right) + \\exp(1)\\left(-\\frac{1}{8}\\right)$$\n我们可以合并项：\n$$p_3(0) = \\frac{5}{8} \\left( \\exp\\left(\\frac{\\sqrt{5}}{5}\\right) + \\exp\\left(-\\frac{\\sqrt{5}}{5}\\right) \\right) - \\frac{1}{8} \\left( \\exp(1) + \\exp(-1) \\right)$$\n使用恒等式 $\\cosh(z) = \\frac{\\exp(z)+\\exp(-z)}{2}$：\n$$p_3(0) = \\frac{5}{8} \\left( 2\\cosh\\left(\\frac{\\sqrt{5}}{5}\\right) \\right) - \\frac{1}{8} \\left( 2\\cosh(1) \\right) = \\frac{5}{4}\\cosh\\left(\\frac{\\sqrt{5}}{5}\\right) - \\frac{1}{4}\\cosh(1)$$\n\n在 $x=0$ 处的插值误差为 $E(0) = f(0) - p_3(0)$。由于 $f(0)=\\exp(0)=1$：\n$$E(0) = 1 - \\left( \\frac{5}{4}\\cosh\\left(\\frac{\\sqrt{5}}{5}\\right) - \\frac{1}{4}\\cosh(1) \\right) = 1 - \\frac{5}{4}\\cosh\\left(\\frac{\\sqrt{5}}{5}\\right) + \\frac{1}{4}\\cosh(1)$$",
            "answer": "$$\\boxed{1 + \\frac{1}{4}\\cosh(1) - \\frac{5}{4}\\cosh\\left(\\frac{\\sqrt{5}}{5}\\right)}$$"
        },
        {
            "introduction": "多项式逼近在处理不连续函数时会遇到一个重大挑战：在间断点附近产生被称为吉布斯 (Gibbs) 现象的伪振荡。这本质上是由于高频模态系数衰减缓慢所致。本计算练习  将通过为一个符号函数 $f(x)=\\mathrm{sign}(x)$ 编写程序，来演示一种常见的解决方案——模态滤波，并定量地评估该技术在平滑逼近和抑制振荡方面的效果。",
            "id": "3409037",
            "problem": "在谱方法和间断伽辽金（DG）方法的背景下，考虑用勒让德多项式对分段常数函数进行多项式逼近。设 $P_k(x)$ 表示区间 $[-1,1]$ 上的第 $k$ 个勒让德多项式，其归一化条件为 $P_k(1)=1$。勒让德多项式构成 $L^2([-1,1])$ 空间中关于单位权重的正交基。函数 $f(x)$ 到最高次数为 $N$ 的多项式空间上的 $L^2$ 正交投影可以表示为在次数 $N$ 处截断的勒让德级数：\n$$\n\\Pi_N f(x) = \\sum_{k=0}^{N} a_k P_k(x),\n$$\n其中模态系数 $a_k$ 由下式给出：\n$$\na_k = \\frac{2k+1}{2} \\int_{-1}^{1} f(x) P_k(x)\\,dx.\n$$\n在谱方法和间断伽辽金（DG）逼近中，$f(x)$ 的间断点会导致称为吉布斯现象的振荡误差。减缓这些振荡的一个常用策略是对系数应用模态滤波器。一个阶数为 $p$、强度为 $\\alpha$ 的指数滤波器将每个模态系数 $a_k$ 乘以一个阻尼因子\n$$\n\\sigma_k = \\exp\\left(-\\alpha \\left(\\frac{k}{N}\\right)^p\\right),\n$$\n从而产生一个滤波后的逼近\n$$\n\\Pi_N^{\\sigma} f(x) = \\sum_{k=0}^{N} \\sigma_k a_k P_k(x).\n$$\n\n您的任务是实现一个程序，该程序能够：\n1. 计算函数 $f(x) = \\mathrm{sign}(x)$ 的勒让德系数 $a_k$，其中当 $x \\in [-1,0)$ 时 $f(x) = -1$，当 $x \\in (0,1]$ 时 $f(x) = 1$，并且为了确定性，设 $f(0)=0$。\n2. 对于指定的次数 $N$、滤波器阶数 $p$ 和滤波器强度 $\\alpha$，构建截断勒让德逼近 $\\Pi_N f(x)$ 和指数滤波逼近 $\\Pi_N^{\\sigma} f(x)$。\n3. 在远离间断点 $x=0$ 的指定评估点 $x$ 处，评估逐点绝对误差 $|f(x) - \\Pi_N^{\\sigma} f(x)|$，并将其与未滤波误差 $|f(x) - \\Pi_N f(x)|$进行比较，以评估滤波器对逐点误差的影响。\n\n使用的基本原理：\n- 勒让德多项式在 $L^2([-1,1])$ 空间中对于权重 $1$ 的正交性和完备性。\n- 通过 $a_k$ 的内积积分定义，在勒让德基中进行谱投影。\n- 如上所述的指数模态滤波器的定义和实现。\n\n算法要求：\n- 使用对多项式精确的求积方法计算 $a_k$：在 $[-1,0]$ 和 $[0,1]$ 上分别执行高斯求积，以稳健地计算 $\\int_{-1}^{1} \\mathrm{sign}(x) P_k(x)\\,dx$，确保对每个 $k \\leq N$ 的精度。\n- 逐点计算 $P_k(x)$ 以构建 $\\Pi_N f(x)$ 和 $\\Pi_N^{\\sigma} f(x)$。\n- 使用指定的 $(\\alpha,p)$ 进行指数滤波；对于未滤波的情况，不进行滤波（即对所有 $k$ 都有 $\\sigma_k=1$）。\n\n测试套件：\n对于以下每种情况，计算所要求的度量，并将所有结果汇总到单个列表中作为最终输出。\n\n- 情况1（基线，“理想路径”）：$N=16$，未滤波，评估点 $x \\in \\{-0.9,-0.5,-0.25,0.25,0.5,0.9\\}$。输出平均绝对误差 $\\frac{1}{6}\\sum |f(x)-\\Pi_N f(x)|$，作为一个浮点数。\n\n- 情况2（滤波对应情况）：$N=16$，使用 $\\alpha=36, p=8$ 进行滤波，评估点相同。输出平均绝对误差 $\\frac{1}{6}\\sum |f(x)-\\Pi_N^{\\sigma} f(x)|$，作为一个浮点数。\n\n- 情况3（中等次数下的改善因子）：$N=32$，在相同的评估点上比较未滤波与滤波后（$\\alpha=36, p=8$）的情况。输出定义为未滤波平均绝对误差与滤波后平均绝对误差之比的改善因子（一个浮点数）。\n\n- 情况4（间断点附近的行为）：$N=32$，在 $x \\in \\{-10^{-3},10^{-3}\\}$ 处进行评估，以探究非常靠近 $x=0$ 处的行为。输出定义为未滤波平均绝对误差与滤波后平均绝对误差之比的改善因子（一个浮点数）。这用于测试滤波器在跳跃点紧邻区域的局限性。\n\n- 情况5（更高次数下的行为）：$N=64$，使用 $\\alpha=36, p=8$ 进行滤波，在 $x \\in \\{-0.9,-0.5,-0.25,0.25,0.5,0.9\\}$ 处进行评估。输出该集合上的最大绝对误差 $\\max |f(x)-\\Pi_N^{\\sigma} f(x)|$，作为一个浮点数。\n\n所有评估点都是无量纲的，不需要物理单位。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按情况1到5的顺序排列的结果，格式为逗号分隔的列表并用方括号括起，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是一个Python浮点数。不应打印任何其他文本。",
            "solution": "该问题要求实现并分析在区间 $[-1,1]$ 上对分段常数函数 $f(x) = \\mathrm{sign}(x)$ 的多项式逼近。该逼近基于截断的勒让德级数，并研究了指数模态滤波器对逼近精度的影响。解决方案涉及计算勒让德系数，构建标准和滤波后的多项式逼近，并评估它们相对于真实函数的逐点误差。\n\n该方法论的核心是谱方法和类傅里叶级数展开的原理。希尔伯特空间 $L^2([-1,1])$ 中的函数 $f(x)$ 可以用其在正交基上的级数展开来表示。对于在 $[-1,1]$ 上关于单位权重函数正交的勒让德多项式基 $\\{P_k(x)\\}_{k=0}^{\\infty}$，此展开式由下式给出：\n$$\nf(x) = \\sum_{k=0}^{\\infty} a_k P_k(x)\n$$\n模态系数 $a_k$ 由 $f(x)$ 在每个基函数 $P_k(x)$ 上的正交投影确定：\n$$\na_k = \\frac{\\langle f, P_k \\rangle}{\\langle P_k, P_k \\rangle} = \\frac{\\int_{-1}^{1} f(x) P_k(x) \\,dx}{\\int_{-1}^{1} P_k(x)^2 \\,dx}\n$$\n在标准归一化 $\\int_{-1}^{1} P_k(x)^2 \\,dx = \\frac{2}{2k+1}$ 的条件下，系数公式简化为问题陈述中给出的形式：\n$$\na_k = \\frac{2k+1}{2} \\int_{-1}^{1} f(x) P_k(x)\\,dx\n$$\n在实践中，无穷级数在有限次数 $N$ 处被截断，从而得到多项式逼近 $\\Pi_N f(x) = \\sum_{k=0}^{N} a_k P_k(x)$。\n\n对于特定函数 $f(x) = \\mathrm{sign}(x)$，它是一个奇函数，其在勒让德基中的表示将只包含奇数索引的勒让德多项式，因为这些多项式本身也是奇函数。因此，所有偶数索引 $k$ 的系数 $a_k$ 必定为零。奇数 $k$ 的非零系数通过计算其定义积分来获得。由于 $f(x)$ 在 $x=0$ 处存在间断点，问题中指定了一种稳健的数值方法来计算该积分。该积分被分成两部分：\n$$\n\\int_{-1}^{1} \\mathrm{sign}(x) P_k(x)\\,dx = \\int_{-1}^{0} (-1) P_k(x)\\,dx + \\int_{0}^{1} (1) P_k(x)\\,dx\n$$\n在子区间 $[-1,0]$ 和 $[0,1]$ 上的每个积分都涉及一个光滑的被积函数（一个多项式）。在实现中，这些积分使用高阶高斯-勒让德求积法计算，该方法对达到特定次数的多项式是精确的。选择求积点数 $M$，使得求积法对最高次数为 $N$ 的多项式是精确的，即 $2M-1 \\ge N$。\n\n当逼近像 $\\mathrm{sign}(x)$ 这样的间断函数时，截断级数 $\\Pi_N f(x)$ 在间断点附近表现出伪振荡，这种现象被称为吉布斯现象。为减缓这些振荡，对模态系数应用一个滤波器。问题指定了一个指数滤波器，其中每个系数 $a_k$ 都乘以一个阻尼因子 $\\sigma_k$：\n$$\n\\sigma_k = \\exp\\left(-\\alpha \\left(\\frac{k}{N}\\right)^p\\right)\n$$\n参数 $\\alpha > 0$ 和 $p \\ge 2$ 分别控制滤波器的强度和阶数。高阶模态（大的 $k$）被更强烈地阻尼，从而平滑了逼近结果。于是，滤波后的逼近为：\n$$\n\\Pi_N^{\\sigma} f(x) = \\sum_{k=0}^{N} \\sigma_k a_k P_k(x)\n$$\n未滤波情况即不应用滤波器，对应于对所有 $k$ 都有 $\\sigma_k=1$。\n\n最后一步是评估未滤波逼近 $\\Pi_N f(x)$ 和滤波后逼近 $\\Pi_N^{\\sigma} f(x)$ 的逐点精度。对于一组给定的评估点 $\\{x_j\\}$，通过对级数求和来计算逼近值。级数求值使用 Clenshaw 算法高效执行，该算法在 `numpy.polynomial.legendre.legval` 中实现。然后计算绝对误差 $|f(x_j) - \\Pi_N f(x_j)|$ 和 $|f(x_j) - \\Pi_N^{\\sigma} f(x_j)|$。测试用例要求基于这些误差计算特定的度量，例如平均绝对误差、最大绝对误差以及未滤波误差与滤波误差之比，以量化滤波器的性能。\n\n对于每个测试用例，整体算法按以下步骤进行：\n1.  确定所需的多项式次数 $N$。\n2.  使用分段高斯-勒让德求积法计算勒让德系数 $a_k$ (对于 $k=0, \\dots, N$)。这些系数被缓存以避免冗余计算。\n3.  对于滤波和未滤波的逼近，构建级数系数向量。对于未滤波的情况，这只是 $\\{a_k\\}$。对于滤波的情况，这是 $\\{ \\sigma_k a_k \\}$。\n4.  在指定的评估点 $x_j$ 处，计算多项式逼近的值。\n5.  计算相对于真实函数 $\\mathrm{sign}(x_j)$ 的逐点绝对误差。\n6.  根据特定测试用例的要求，计算并存储最终度量（平均误差、最大误差或误差比）。\n所有测试用例的结果被汇总到一个列表中作为最终输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre, eval_legendre\nfrom numpy.polynomial.legendre import legval\n\ndef solve():\n    \"\"\"\n    Solves the polynomial approximation problem by computing Legendre coefficients,\n    applying a modal filter, evaluating errors, and reporting the specified metrics.\n    \"\"\"\n\n    # Cache for Legendre coefficients to avoid recomputation for the same degree N.\n    coeffs_cache = {}\n\n    def get_legendre_coeffs_sign_x(N: int) -> np.ndarray:\n        \"\"\"\n        Computes the Legendre series coefficients for f(x) = sign(x) up to degree N.\n        The coefficients are computed using Gauss-Legendre quadrature on sub-intervals\n        [-1,0] and [0,1] to handle the discontinuity at x=0.\n        \"\"\"\n        if N in coeffs_cache:\n            return coeffs_cache[N]\n\n        coeffs = np.zeros(N + 1)\n        \n        # An M-point Gauss rule is exact for polynomials of degree 2M-1.\n        # We integrate f(x)*P_k(x), where f is piecewise constant. So we integrate P_k(x) on\n        # subdomains, which is a polynomial of degree k. To be exact for all k=N, we need 2M-1 >= N.\n        num_points = int(np.ceil((N + 1) / 2.0))\n        nodes, weights = roots_legendre(num_points)\n\n        # Map nodes and weights for integral over [0, 1]\n        nodes_01 = 0.5 * (nodes + 1)\n        weights_01 = 0.5 * weights\n\n        # Map nodes and weights for integral over [-1, 0]\n        nodes_m10 = 0.5 * (nodes - 1)\n        weights_m10 = 0.5 * weights\n\n        for k in range(N + 1):\n            # The function sign(x)*P_k(x) is odd if k is even, so its integral is 0.\n            # Its integral is non-zero only if k is odd.\n            if k % 2 == 0:\n                coeffs[k] = 0.0\n                continue\n\n            # Integral of P_k(x) over [0, 1]\n            pk_vals_01 = eval_legendre(k, nodes_01)\n            integral_01 = np.sum(weights_01 * pk_vals_01)\n\n            # Integral of P_k(x) over [-1, 0]\n            pk_vals_m10 = eval_legendre(k, nodes_m10)\n            integral_m10 = np.sum(weights_m10 * pk_vals_m10)\n            \n            # Integral of sign(x)*P_k(x) over [-1, 1] is\n            # = integral[-1,0] (-1)*P_k(x) dx + integral[0,1] (1)*P_k(x) dx\n            integral_total = -integral_m10 + integral_01\n            \n            coeffs[k] = (2 * k + 1) / 2.0 * integral_total\n        \n        coeffs_cache[N] = coeffs\n        return coeffs\n\n    def calculate_approximation_error(N, p, alpha, x_eval, unfiltered):\n        \"\"\"\n        Calculates the pointwise absolute error of the (filtered) approximation.\n        \"\"\"\n        a_k = get_legendre_coeffs_sign_x(N)\n        \n        if unfiltered:\n            # Per problem statement, sigma_k = 1 for the unfiltered case.\n            coeffs_to_eval = a_k\n        else:\n            k_indices = np.arange(N + 1, dtype=float)\n            # Handle N=0 case to avoid division by zero.\n            if N > 0:\n                eta = k_indices / N\n            else:\n                eta = np.zeros_like(k_indices)\n            sigma = np.exp(-alpha * eta**p)\n            coeffs_to_eval = a_k * sigma\n\n        y_approx = legval(x_eval, coeffs_to_eval)\n        y_true = np.sign(x_eval)\n        \n        return np.abs(y_true - y_approx)\n\n    results = []\n    \n    # Common evaluation points for Cases 1, 2, 3, 5\n    x_eval_common = np.array([-0.9, -0.5, -0.25, 0.25, 0.5, 0.9])\n\n    # Case 1: N=16, unfiltered, mean absolute error\n    N1 = 16\n    errors1 = calculate_approximation_error(N1, p=0, alpha=0, x_eval=x_eval_common, unfiltered=True)\n    result1 = np.mean(errors1)\n    results.append(result1)\n    \n    # Case 2: N=16, filtered, mean absolute error\n    N2, p2, alpha2 = 16, 8, 36\n    errors2 = calculate_approximation_error(N2, p=p2, alpha=alpha2, x_eval=x_eval_common, unfiltered=False)\n    result2 = np.mean(errors2)\n    results.append(result2)\n    \n    # Case 3: N=32, improvement factor\n    N3, p3, alpha3 = 32, 8, 36\n    unfiltered_errors3 = calculate_approximation_error(N3, p=0, alpha=0, x_eval=x_eval_common, unfiltered=True)\n    filtered_errors3 = calculate_approximation_error(N3, p=p3, alpha=alpha3, x_eval=x_eval_common, unfiltered=False)\n    mean_err_unfiltered3 = np.mean(unfiltered_errors3)\n    mean_err_filtered3 = np.mean(filtered_errors3)\n    result3 = mean_err_unfiltered3 / mean_err_filtered3\n    results.append(result3)\n\n    # Case 4: N=32, improvement factor near discontinuity\n    N4, p4, alpha4 = 32, 8, 36\n    x_eval4 = np.array([-1e-3, 1e-3])\n    unfiltered_errors4 = calculate_approximation_error(N4, p=0, alpha=0, x_eval=x_eval4, unfiltered=True)\n    filtered_errors4 = calculate_approximation_error(N4, p=p4, alpha=alpha4, x_eval=x_eval4, unfiltered=False)\n    mean_err_unfiltered4 = np.mean(unfiltered_errors4)\n    mean_err_filtered4 = np.mean(filtered_errors4)\n    result4 = mean_err_unfiltered4 / mean_err_filtered4\n    results.append(result4)\n    \n    # Case 5: N=64, filtered, max absolute error\n    N5, p5, alpha5 = 64, 8, 36\n    errors5 = calculate_approximation_error(N5, p=p5, alpha=alpha5, x_eval=x_eval_common, unfiltered=False)\n    result5 = np.max(errors5)\n    results.append(result5)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}