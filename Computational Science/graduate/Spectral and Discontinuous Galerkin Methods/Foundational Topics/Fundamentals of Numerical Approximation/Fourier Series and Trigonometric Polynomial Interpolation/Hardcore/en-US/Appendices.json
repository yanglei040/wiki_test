{
    "hands_on_practices": [
        {
            "introduction": "To build a solid foundation, our first practice involves a direct, computational exploration of the link between a function's smoothness and its Fourier spectrum . In this exercise, you will programmatically generate periodic functions with tunable smoothness, controlled by a spectral decay parameter $p$. By applying the Discrete Fourier Transform (DFT), you will then numerically verify the theoretical relationship between smoothness and the rate at which Fourier coefficient amplitudes decrease, providing a concrete understanding of one of the most powerful properties of Fourier analysis.",
            "id": "3284382",
            "problem": "You are asked to design and implement a program that constructs trigonometric interpolation polynomials from equispaced samples of synthetic periodic functions, where the spectral content of these functions is controlled by a tunable decay parameter. The program must then validate smoothness by estimating the decay rate of the Fourier coefficients and quantify the effect of spectral filtering. All angles must be in radians.\n\nFundamental base and definitions to be used:\n- A real-valued, $2\\pi$-periodic function $f$ can be approximated by a trigonometric polynomial constructed from the basis $\\{1, \\cos(kx), \\sin(kx)\\}$ for $k \\in \\mathbb{N}$. The trigonometric interpolation polynomial of degree at most $\\lfloor (N-1)/2 \\rfloor$ that interpolates $N$ equispaced samples is unique.\n- Using equispaced nodes $x_j = 2\\pi j/N$ with $j = 0, 1, \\dots, N-1$, discrete orthogonality of the complex exponential basis $\\{e^{\\mathrm{i}kx}\\}$ ensures that the discrete Fourier transform coefficients $c_k$ can be computed and the original samples exactly recovered by the inverse transform. For real signals, the amplitude of the harmonic pair at frequency $k$ is related to the magnitude of the complex coefficient.\n- The smoothness of a periodic function is reflected in the decay of its Fourier coefficients; smoother functions exhibit faster decay of harmonic amplitudes as a function of frequency index.\n\nTask:\n1. Synthetic dataset generation with controlled smoothness:\n   - For given integers $N$ and $K$ with $N \\ge 2$ and $1 \\le K  N$, consider the equispaced grid $x_j = 2\\pi j/N$.\n   - Define coefficients $a_k$ and $b_k$ for $k = 1, 2, \\dots, K$ using a decay parameter $p > 0$ as\n     $$a_k = k^{-p} + \\Delta_a(k), \\quad b_k = s_k\\left(\\tfrac{1}{2}k^{-p} + \\Delta_b(k)\\right),$$\n     where $s_k = (-1)^k$, and\n     $$\\Delta_a(k) = \\begin{cases} \\delta,  k \\ge k_0 \\\\ 0,  k  k_0 \\end{cases}, \\quad \\Delta_b(k) = \\begin{cases} \\tfrac{\\delta}{2},  k \\ge k_0 \\\\ 0,  k  k_0 \\end{cases}.$$\n     The pair $(\\Delta_a(k), \\Delta_b(k))$ introduces a high-frequency plateau of level $\\delta \\ge 0$ starting at index $k_0$ (if $k_0$ is specified), otherwise disabled when $\\delta = 0$ or $k_0$ is not provided.\n   - Construct the synthetic periodic samples\n     $$s_j = \\sum_{k=1}^{K} \\left( a_k \\cos(k x_j) + b_k \\sin(k x_j) \\right), \\quad j = 0, 1, \\dots, N-1.$$\n2. Trigonometric interpolation via discrete Fourier transform:\n   - Compute the discrete Fourier transform coefficients $c_k$ of the sample sequence $\\{s_j\\}$ for $k = 0, 1, \\dots, N-1$ using standard complex-exponential orthogonality on the equispaced grid.\n   - Define the harmonic amplitude envelope for $k = 1, 2, \\dots, m$ where $m = \\lfloor N/2 \\rfloor$ by\n     $$A_k = \\begin{cases} 2|c_k|,  1 \\le k  m \\\\ |c_m|,  k = m \\text{ and } N \\text{ even} \\end{cases}.$$\n     This convention avoids double-counting the Nyquist frequency when $N$ is even and captures the amplitude of each sine-cosine harmonic pair.\n3. Smoothness validation via coefficient decay:\n   - Estimate the decay rate $p_{\\mathrm{est}}$ by performing least-squares linear regression of $\\log(A_k)$ versus $\\log(k)$ over the indices where $A_k$ is numerically significant (exclude values with $A_k \\le 10^{-12}$) and excluding the Nyquist index when $N$ is even. Specifically, fit\n     $$\\log(A_k) \\approx \\alpha - p_{\\mathrm{est}} \\log(k).$$\n4. Spectral filtering and error quantification:\n   - For a given cutoff $M_{\\mathrm{cut}}$ with $1 \\le M_{\\mathrm{cut}} \\le m$, construct a filtered reconstruction by zeroing all discrete Fourier coefficients $\\{c_k\\}$ with $k > M_{\\mathrm{cut}}$ and $k  N - M_{\\mathrm{cut}}$, and then applying the inverse discrete Fourier transform to obtain filtered samples $\\{\\hat{s}_j\\}$.\n   - Compute the maximum absolute interpolation error\n     $$E_{\\max} = \\max_{0 \\le j  N} | \\hat{s}_j - s_j |.$$\n   - Compute the tail energy ratio beyond the cutoff\n     $$R_{\\mathrm{tail}} = \\frac{ \\sum_{k = M_{\\mathrm{cut}}+1}^{m} A_k^2 }{ \\sum_{k = 1}^{m} A_k^2 }.$$\n5. Validation logic:\n   - The pass/fail criterion combines decay estimation and tail energy behavior:\n     - If the test case specifies no plateau (i.e., expects a decaying spectrum), then declare pass if $|p_{\\mathrm{est}} - p| \\le \\tau_p$ and $R_{\\mathrm{tail}}  \\rho$.\n     - If the test case specifies a plateau (i.e., expects non-decaying high-frequency content), then declare pass if $R_{\\mathrm{tail}} \\ge \\rho$. In this plateau case, no condition is imposed on $p_{\\mathrm{est}}$.\n\nTesting:\nProvide the following test suite, each test case defined by a tuple $(N, K, p, M_{\\mathrm{cut}}, k_0, \\delta, \\tau_p, \\rho, \\text{expect\\_plateau})$:\n- Case $1$ (happy path, smooth decay): $(N, K, p, M_{\\mathrm{cut}}, k_0, \\delta, \\tau_p, \\rho, \\text{expect\\_plateau}) = (128, 30, 2.5, 20, \\text{none}, 0.0, 0.1, 0.05, \\text{False})$.\n- Case $2$ (boundary with smaller $N$): $(N, K, p, M_{\\mathrm{cut}}, k_0, \\delta, \\tau_p, \\rho, \\text{expect\\_plateau}) = (32, 10, 1.0, 8, \\text{none}, 0.0, 0.2, 0.05, \\text{False})$.\n- Case $3$ (edge case with high-frequency plateau): $(N, K, p, M_{\\mathrm{cut}}, k_0, \\delta, \\tau_p, \\rho, \\text{expect\\_plateau}) = (256, 60, 2.0, 30, 40, 0.1, 0.2, 0.1, \\text{True})$.\n\nFinal output specification:\n- For each test case, produce a sublist $[p_{\\mathrm{est}}, E_{\\max}, R_{\\mathrm{tail}}, \\text{pass}]$ where $p_{\\mathrm{est}}$, $E_{\\max}$, and $R_{\\mathrm{tail}}$ are floats rounded to six decimal places, and $\\text{pass}$ is either $\\text{True}$ or $\\text{False}$.\n- Your program should produce a single line of output containing the results as a comma-separated list of these sublists, enclosed in square brackets, with no spaces. For example, an output for three test cases must look like $[[p_1,E_1,R_1,\\text{True}],[p_2,E_2,R_2,\\text{False}],[p_3,E_3,R_3,\\text{True}]]$ with all floats shown to six decimal places.",
            "solution": "The user-provided problem is evaluated as **valid** because it is scientifically grounded in the principles of Fourier analysis and numerical methods, is well-posed, and provides a complete, consistent, and formalizable set of instructions. The problem asks for the implementation of a numerical procedure involving trigonometric interpolation, spectral analysis, and filtering, which is a standard topic in scientific computing. All provided definitions, formulas, and test cases are consistent and allow for the development of a unique, verifiable solution.\n\nThe solution proceeds by implementing the specified steps for each test case.\n\n**1. Synthetic Dataset Generation**\nFor each test case, we are given parameters $(N, K, p, M_{\\mathrm{cut}}, k_0, \\delta, \\tau_p, \\rho, \\text{expect\\_plateau})$. We first construct the signal $s_j$ on an equispaced grid of $N$ points $x_j = \\frac{2\\pi j}{N}$ for $j=0, \\dots, N-1$. The signal is a sum of $K$ harmonics:\n$$s_j = \\sum_{k=1}^{K} \\left( a_k \\cos(k x_j) + b_k \\sin(k x_j) \\right)$$\nThe coefficients $a_k$ and $b_k$ are defined to model a power-law spectral decay with a potential high-frequency plateau:\n$$a_k = k^{-p} + \\Delta_a(k), \\quad b_k = (-1)^k\\left(\\tfrac{1}{2}k^{-p} + \\Delta_b(k)\\right)$$\nThe plateau terms $\\Delta_a(k)$ and $\\Delta_b(k)$ are non-zero only if a start index $k_0$ is provided and $\\delta > 0$. Specifically, $\\Delta_a(k) = \\delta$ and $\\Delta_b(k) = \\frac{\\delta}{2}$ for $k \\ge k_0$, and are zero otherwise. This construction can be efficiently implemented using vectorized NumPy operations.\n\n**2. Discrete Fourier Transform and Harmonic Amplitudes**\nThe trigonometric interpolation polynomial is implicitly found by computing the Discrete Fourier Transform (DFT) of the samples $\\{s_j\\}$. The DFT coefficients, which we denote $C_k^{\\text{unnorm}} = \\sum_{j=0}^{N-1} s_j e^{-i k x_j}$, are computed using `numpy.fft.fft`. For theoretical consistency, these are normalized to obtain $c_k = \\frac{1}{N} C_k^{\\text{unnorm}}$.\nFor a real-valued signal, the amplitude of the $k$-th harmonic is related to the magnitude of $c_k$. The harmonic amplitude envelope $A_k$ is defined for the positive frequencies $k=1, \\dots, m$, where $m = \\lfloor N/2 \\rfloor$. As all test cases use an even $N$, $m=N/2$. The definition is:\n$$A_k = \\begin{cases} 2|c_k|,  1 \\le k  m \\\\ |c_m|,  k = m \\end{cases}$$\nThe factor of $2$ accounts for the energy from both positive ($k$) and negative ($-k \\equiv N-k$) frequency components, which are complex conjugates. The Nyquist frequency component ($k=m$) has no conjugate counterpart in the unique frequency range and is treated separately. Since the input signal has no DC component ($s(x)$ integrates to zero over a period), $c_0=0$.\nA key theoretical insight is that for a signal constructed as above with $K  N/2$, there is no aliasing, and the computed-from-samples amplitude $A_k$ should be directly related to the generating coefficients: $A_k \\approx \\sqrt{a_k^2 + b_k^2}$ for $k \\le K$, and $A_k \\approx 0$ for $k > K$.\n\n**3. Smoothness Validation via Decay Rate Estimation**\nThe smoothness of the underlying continuous function is related to how fast its Fourier coefficients decay. We estimate the decay exponent $p$ by fitting a linear model to the logarithm of the amplitudes:\n$$\\log(A_k) \\approx \\alpha - p_{\\mathrm{est}} \\log(k)$$\nThis is a linear regression of $y = \\log(A_k)$ on $x = \\log(k)$. The estimated decay rate, $p_{\\mathrm{est}}$, is the negative of the slope of this line. The fit is performed using a least-squares method (`numpy.polyfit`) over the frequency range $k=1, \\dots, m-1$. The Nyquist frequency is excluded, a standard practice as it behaves differently. To avoid numerical issues with $\\log(0)$, only amplitudes $A_k > 10^{-12}$ are included in the regression.\n\n**4. Spectral Filtering and Error Analysis**\nTo simulate the effect of a low-pass filter, we truncate the spectrum. A filtered signal $\\{\\hat{s}_j\\}$ is reconstructed by first zeroing out the DFT coefficients $C_k^{\\text{unnorm}}$ for all frequencies with indices $k$ such that $M_{\\mathrm{cut}}  k  N - M_{\\mathrm{cut}}$. Then, the Inverse DFT (`numpy.fft.ifft`) is applied to this modified spectrum. The resulting $\\hat{s}_j$ is the best approximation of $s_j$ using only the first $M_{\\mathrm{cut}}$ harmonics.\nThe filtering error is quantified by the maximum absolute error $E_{\\max} = \\max_{j} | \\hat{s}_j - s_j |$.\nThe energy lost due to filtering is quantified by the tail energy ratio, $R_{\\mathrm{tail}}$. By Parseval's theorem, energy in the signal domain is proportional to the sum of squared amplitudes in the frequency domain. Thus, the ratio is:\n$$R_{\\mathrm{tail}} = \\frac{ \\sum_{k = M_{\\mathrm{cut}}+1}^{m} A_k^2 }{ \\sum_{k = 1}^{m} A_k^2 }$$\nThis measures the fraction of spectral energy contained in frequencies above the cutoff $M_{\\mathrm{cut}}$.\n\n**5. Validation Logic**\nThe final step is to apply the pass/fail criteria based on the problem specification:\n- If a smooth decay is expected (`expect_plateau` is False), the test passes if the estimated decay rate $p_{\\mathrm{est}}$ is close to the true rate $p$ (i.e., $|p_{\\mathrm{est}} - p| \\le \\tau_p$) AND the tail energy $R_{\\mathrm{tail}}$ is small (i.e., $R_{\\mathrm{tail}}  \\rho$).\n- If a high-frequency plateau is expected (`expect_plateau` is True), the test passes if the tail energy $R_{\\mathrm{tail}}$ is significant (i.e., $R_{\\mathrm{tail}} \\ge \\rho$), indicating that the high-frequency components are not negligible.\n\nThe computed values $p_{\\mathrm{est}}$, $E_{\\max}$, and $R_{\\mathrm{tail}}$ are rounded to six decimal places, and the boolean pass/fail result is determined for each case. These results are then formatted into the specified string output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main entry point for solving the problem. It defines the test cases,\n    processes each one, and prints the formatted results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, K, p, M_cut, k0, delta, tau_p, rho, expect_plateau)\n        (128, 30, 2.5, 20, None, 0.0, 0.1, 0.05, False),\n        (32, 10, 1.0, 8, None, 0.0, 0.2, 0.05, False),\n        (256, 60, 2.0, 30, 40, 0.1, 0.2, 0.1, True),\n    ]\n\n    # This list will store the sublist strings for final concatenation.\n    results_as_strings = []\n    \n    for case in test_cases:\n        N, K, p, M_cut, k0, delta, tau_p, rho, expect_plateau = case\n        \n        # 1. Synthetic dataset generation\n        x_j = (2 * np.pi / N) * np.arange(N)\n        k_vals = np.arange(1, K + 1)\n        \n        p_decay = k_vals**(-p)\n        \n        delta_a = np.zeros(K)\n        delta_b = np.zeros(K)\n        if k0 is not None and delta > 0:\n            indices_to_modify = k_vals >= k0\n            delta_a[indices_to_modify] = delta\n            delta_b[indices_to_modify] = delta / 2.0\n            \n        a_k = p_decay + delta_a\n        s_k_sign = (-1)**k_vals\n        b_k = s_k_sign * (0.5 * p_decay + delta_b)\n        \n        outer_prod = np.outer(x_j, k_vals)\n        s_j = np.cos(outer_prod) @ a_k + np.sin(outer_prod) @ b_k\n\n        # 2. Trigonometric interpolation via DFT\n        C_k_unnormalized = np.fft.fft(s_j)\n        c_k = C_k_unnormalized / N\n        \n        m = N // 2\n        \n        # Harmonic amplitude envelope A_k for k=1..m (0-indexed array)\n        A_k = np.zeros(m)\n        if m > 1: # Handles N=2 case\n            A_k[:m-1] = 2 * np.abs(c_k[1:m])\n        A_k[m-1] = np.abs(c_k[m]) # Nyquist frequency (all test cases have even N)\n\n        # 3. Smoothness validation via coefficient decay\n        k_for_fit = np.arange(1, m)\n        A_for_fit = A_k[:m-1]\n        \n        significant_mask = A_for_fit > 1e-12\n        k_reg = k_for_fit[significant_mask]\n        \n        p_est = 0.0\n        if len(k_reg) >= 2:\n            A_reg = A_for_fit[significant_mask]\n            log_k = np.log(k_reg)\n            log_A = np.log(A_reg)\n            slope, _ = np.polyfit(log_k, log_A, 1)\n            p_est = -slope\n\n        # 4. Spectral filtering and error quantification\n        C_filtered = C_k_unnormalized.copy()\n        C_filtered[M_cut + 1 : N - M_cut] = 0.0\n        \n        s_hat_j = np.real(np.fft.ifft(C_filtered))\n        E_max = np.max(np.abs(s_hat_j - s_j))\n\n        # 5. Tail energy ratio\n        numerator = np.sum(A_k[M_cut:]**2)\n        denominator = np.sum(A_k**2)\n        R_tail = numerator / denominator if denominator > 1e-15 else 0.0\n\n        # 6. Validation logic\n        if expect_plateau:\n            is_pass = R_tail >= rho\n        else:\n            is_pass = (np.abs(p_est - p) = tau_p) and (R_tail  rho)\n        \n        # Format the sublist as a string according to requirements\n        sublist_str = f\"[{p_est:.6f},{E_max:.6f},{R_tail:.6f},{is_pass}]\"\n        results_as_strings.append(sublist_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from a single uniform domain to a more complex setting, this practice explores how Fourier interpolation concepts apply within the framework of multi-element methods like the Discontinuous Galerkin (DG) method . You will derive the maximum global wavenumber $k_{\\star}$ that can be resolved without aliasing across a non-uniform mesh, where each element has its own local polynomial degree. This calculation-based exercise illuminates a critical trade-off in modern numerical methods: how local resolution choices on individual elements constrain the ability to accurately represent global-scale phenomena.",
            "id": "3387856",
            "problem": "Consider a periodic domain of length $L=2\\pi$ partitioned into $E=3$ elements with lengths $h_{1}=\\frac{\\pi}{3}$, $h_{2}=\\frac{\\pi}{2}$, and $h_{3}=\\frac{7\\pi}{6}$, so that $h_{1}+h_{2}+h_{3}=2\\pi$. On each element $e\\in\\{1,2,3\\}$, define the local angular coordinate $\\theta_{e}=2\\pi\\,(x-x_{e-1})/h_{e}\\in[0,2\\pi)$ where $x_{e-1}$ is the left endpoint of the $e$-th element. The local approximation space is the span of complex exponentials $\\{\\exp(\\mathrm{i}j\\theta_{e})\\}_{j=-N_{e}}^{N_{e}}$, i.e., trigonometric polynomials of degree $N_{e}$, with interpolation at $2N_{e}+1$ equispaced nodes in $\\theta_{e}$. Angles are in radians. Assume the piecewise approximation is assembled with the Discontinuous Galerkin (DG) method, so values are not enforced to be continuous across interfaces.\n\nA global Fourier mode is given by $u_{k}(x)=\\exp(\\mathrm{i}k x)$ with integer wavenumber $k\\geq 0$. Starting from the definitions of trigonometric polynomial interpolation on each element and the sampling theorem for uniform grids, derive the necessary and sufficient condition under which the global mode $u_{k}$ is represented without aliasing on every element. Use this to establish the expression for the maximum resolvable global wavenumber $k_{\\star}$ in terms of the local degrees $N_{e}$ and element lengths $h_{e}$ that ensures no aliasing and, consequently, no interface inconsistency in the element-wise representations.\n\nFinally, specialize your expression to the given mesh and degrees $N_{1}=5$, $N_{2}=3$, and $N_{3}=8$, and compute the largest integer $k_{\\star}$ that satisfies the no-aliasing condition. Provide the single value of $k_{\\star}$ as your final answer. No rounding is required. Angles are in radians.",
            "solution": "The problem requires the derivation of a condition to ensure that a global Fourier mode, $u_{k}(x) = \\exp(\\mathrm{i}k x)$, is represented without aliasing on every element of a non-uniform mesh under a Discontinuous Galerkin (DG) framework. This condition will lead to the maximum resolvable global wavenumber, $k_{\\star}$.\n\nFirst, we must express the global function $u_{k}(x)$ in terms of the local coordinate $\\theta_{e}$ for each element $e$. The problem defines the local angular coordinate on element $e$ as $\\theta_{e} = 2\\pi(x - x_{e-1})/h_{e}$, where $x_{e-1}$ is the left endpoint of the element and $h_e$ is its length. The domain of the local coordinate is $\\theta_{e} \\in [0, 2\\pi)$. We can invert this relationship to express the global coordinate $x$ in terms of the local coordinate $\\theta_{e}$:\n$$\nx = x_{e-1} + \\frac{h_{e}}{2\\pi} \\theta_{e}\n$$\nSubstituting this into the expression for the global Fourier mode $u_{k}(x)$, we obtain its representation in the local coordinate system of element $e$:\n$$\nu_{k}(x(\\theta_e)) = \\exp\\left(\\mathrm{i}k \\left(x_{e-1} + \\frac{h_{e}}{2\\pi} \\theta_{e}\\right)\\right) = \\exp(\\mathrm{i}k x_{e-1}) \\exp\\left(\\mathrm{i} \\frac{kh_{e}}{2\\pi} \\theta_{e}\\right)\n$$\nThe term $\\exp(\\mathrm{i}k x_{e-1})$ is a constant phase factor on element $e$. The functional dependence on the local coordinate is entirely contained in the term $\\exp(\\mathrm{i} J_{e} \\theta_{e})$, where we define the dimensionless local wavenumber on element $e$ as:\n$$\nJ_{e} = \\frac{kh_{e}}{2\\pi}\n$$\nThe local approximation space on element $e$ is the space of trigonometric polynomials of degree $N_{e}$, which is the span of the basis functions $\\{\\exp(\\mathrm{i}j\\theta_{e})\\}_{j=-N_{e}}^{N_{e}}$. This space can uniquely represent any trigonometric polynomial whose frequencies $j$ are within the range $[-N_{e}, N_{e}]$.\n\nThe problem states that the approximation is constructed via interpolation at $2N_{e}+1$ equispaced nodes in $\\theta_{e}$. According to the sampling theorem for trigonometric polynomials, if we sample a function $f(\\theta_e) = \\exp(\\mathrm{i}J_{e}\\theta_{e})$ at $2N_{e}+1$ equispaced points, the resulting trigonometric interpolant will be an aliased version of the original function. The interpolant will exactly match the original function if and only if the frequency $J_e$ lies within the range of uniquely representable frequencies of the polynomial space. For half-open intervals like $[0, 2\\pi)$ and a basis indexed from $-N_e$ to $N_e$, the condition to avoid aliasing is:\n$$\n-N_{e} \\leq J_{e} \\leq N_{e}\n$$\nOr, more compactly, $|J_{e}| \\leq N_{e}$. Since the global wavenumber $k$ is given as a non-negative integer ($k \\geq 0$) and element lengths $h_{e}$ are positive, the local wavenumber $J_{e} = kh_{e}/(2\\pi)$ is also non-negative. The no-aliasing condition simplifies to:\n$$\nJ_{e} \\leq N_{e}\n$$\nSubstituting the definition of $J_{e}$, we obtain the condition on the global wavenumber $k$ for no aliasing on element $e$:\n$$\n\\frac{kh_{e}}{2\\pi} \\leq N_{e}\n$$\nRearranging for $k$, we get:\n$$\nk \\leq \\frac{2\\pi N_{e}}{h_{e}}\n$$\nThis inequality provides the maximum resolvable global wavenumber on a single element $e$. For the global mode $u_{k}(x)$ to be represented without aliasing on *every* element in the mesh, this condition must hold simultaneously for all $e \\in \\{1, 2, ..., E\\}$. Therefore, $k$ must be less than or equal to the minimum of these upper bounds over all elements:\n$$\nk \\leq \\min_{e \\in \\{1, \\dots, E\\}} \\left( \\frac{2\\pi N_{e}}{h_{e}} \\right)\n$$\nThe maximum resolvable global wavenumber, $k_{\\star}$, is the largest integer $k$ that satisfies this condition. This is given by the floor of the minimum value:\n$$\nk_{\\star} = \\left\\lfloor \\min_{e \\in \\{1, \\dots, E\\}} \\left( \\frac{2\\pi N_{e}}{h_{e}} \\right) \\right\\rfloor\n$$\nThis is the general expression for $k_{\\star}$. Now, we specialize this result to the given mesh with $E=3$ elements and the specified parameters. The data are:\n- Element 1: $h_{1} = \\frac{\\pi}{3}$, $N_{1} = 5$\n- Element 2: $h_{2} = \\frac{\\pi}{2}$, $N_{2} = 3$\n- Element 3: $h_{3} = \\frac{7\\pi}{6}$, $N_{3} = 8$\n\nWe compute the maximum resolvable wavenumber for each element:\nFor element 1:\n$$\n\\frac{2\\pi N_{1}}{h_{1}} = \\frac{2\\pi (5)}{\\frac{\\pi}{3}} = \\frac{10\\pi}{\\frac{\\pi}{3}} = 10 \\times 3 = 30\n$$\nFor element 2:\n$$\n\\frac{2\\pi N_{2}}{h_{2}} = \\frac{2\\pi (3)}{\\frac{\\pi}{2}} = \\frac{6\\pi}{\\frac{\\pi}{2}} = 6 \\times 2 = 12\n$$\nFor element 3:\n$$\n\\frac{2\\pi N_{3}}{h_{3}} = \\frac{2\\pi (8)}{\\frac{7\\pi}{6}} = \\frac{16\\pi}{\\frac{7\\pi}{6}} = 16 \\times \\frac{6}{7} = \\frac{96}{7}\n$$\nNow we find the minimum of these three values:\n$$\n\\min\\left(30, 12, \\frac{96}{7}\\right)\n$$\nTo compare the values, we note that $\\frac{96}{7} \\approx 13.714$. The minimum is therefore $12$.\n$$\n\\min\\left(30, 12, \\frac{96}{7}\\right) = 12\n$$\nThe maximum integer wavenumber $k_{\\star}$ that can be represented without aliasing on all three elements is the floor of this minimum value:\n$$\nk_{\\star} = \\lfloor 12 \\rfloor = 12\n$$\nThus, the largest integer global wavenumber that satisfies the no-aliasing condition on every element is $12$.",
            "answer": "$$\n\\boxed{12}\n$$"
        },
        {
            "introduction": "This final practice synthesizes our understanding by employing Fourier analysis as a core component in an advanced numerical algorithm: a domain decomposition preconditioner . Here, Fourier modes are not just for representing a solution but for accelerating its computation by efficiently handling the global exchange of information between subdomains. You will implement and compare a Fourier-based coarse correction with a traditional physical-space approach using Robin boundary conditions, offering deep insight into the design and performance of modern, high-performance solvers for partial differential equations.",
            "id": "3387897",
            "problem": "Consider the periodic interval $[0,1]$ with periodic boundary conditions and let $N$ be an even integer representing the number of equispaced grid points with spacing $h = 1/N$. Define the discrete second-order finite difference Laplacian $\\Delta_h$ on the grid with periodic wrapping by the stencil $(1,-2,1)/h^2$, i.e., for a grid function $u \\in \\mathbb{R}^N$, \n$$\n\\left(\\Delta_h u\\right)_i = \\frac{u_{i-1} - 2 u_i + u_{i+1}}{h^2}, \\quad \\text{with indices modulo } N,\n$$\nand define the symmetric positive definite operator \n$$\nA u = \\beta u - \\Delta_h u\n$$\nwith $\\beta > 0$. \n\nYou will construct two domain decomposition preconditioners and study the error propagation operator of a one-step preconditioned Richardson iteration. The iteration updates $u^{(n+1)} = u^{(n)} + z^{(n)}$ where $z^{(n)}$ is the preconditioned correction to the residual $r^{(n)} = f - A u^{(n)}$. When $f = 0$ (homogeneous forcing), the error $e^{(n)} = u^{(n)}$ updates as $e^{(n+1)} = \\left(I - M^{-1} A\\right) e^{(n)}$, where $M^{-1}$ is the linear preconditioner. The convergence rate for one preconditioned Richardson step is quantified by the spectral radius \n$$\n\\rho\\left(I - M^{-1} A\\right) = \\max\\{ |\\lambda| : \\lambda \\text{ is an eigenvalue of } I - M^{-1} A \\}.\n$$\n\nDefine a nonoverlapping split of the grid into two subdomains that overlap by $o$ grid points. Specifically, set the first subdomain index set \n$$\n\\Omega_A = \\{0,1,2,\\dots, N/2 + o - 1\\},\n$$ \nand the second subdomain index set \n$$\n\\Omega_B = \\{N/2 - o, N/2 - o + 1, \\dots, N-1\\}.\n$$\nThese sets overlap on $2o$ indices.\n\nConstruct two preconditioners:\n\n1) Fourier-based two-level additive Schwarz with truncated spectrum exchange. Let $R_A$ and $R_B$ be restriction operators that extract the interior unknowns of each subdomain when homogeneous Dirichlet boundary conditions are imposed at the artificial subdomain end points. For subdomain $\\Omega_A$ with local length $m_A = N/2 + o$, the interior unknowns are the $m_A - 2$ nodes excluding the first and last in $\\Omega_A$. For subdomain $\\Omega_B$ with local length $m_B = N - (N/2 - o)$, the interior unknowns are the $m_B - 2$ nodes excluding the first and last in $\\Omega_B$. Let $A_A$ and $A_B$ denote the local discrete operators on these interior unknowns induced by $A$ with homogeneous Dirichlet boundary conditions at the subdomain boundaries (i.e., ghost values are zero). The one-level additive Schwarz action is \n$$\nM_{\\text{AS}}^{-1} r = R_A^\\top A_A^{-1} R_A r \\;+\\; R_B^\\top A_B^{-1} R_B r.\n$$\nAugment this with a Fourier coarse correction that exchanges only the truncated spectrum $\\{\\hat{u}_k : |k| \\le K\\}$ of the global residual. Denote by $\\mathcal{F}$ the discrete Fourier transform on the periodic grid and by $\\widehat{r}_k$ the Fourier coefficient at integer wavenumber $k$. Define the truncated low-mode projector $P_K$ acting on $r$ by keeping only $\\widehat{r}_k$ for $|k| \\le K$ and setting others to zero, and define the coarse solve on those modes by \n$$\n\\widehat{z}_k = \\frac{\\widehat{r}_k}{\\beta + (2\\pi k)^2}, \\quad \\text{for } |k| \\le K, \\quad \\widehat{z}_k = 0 \\text{ otherwise}.\n$$\nThe Fourier-based preconditioner is \n$$\nM_K^{-1} r = M_{\\text{AS}}^{-1} r \\;+\\; \\mathcal{F}^{-1}\\left( \\widehat{z} \\right),\n$$\nwhich can be interpreted as subdomain solutions exchanging only the truncated spectrum $\\{ \\widehat{u}_k : |k| \\le K \\}$ globally via the coarse correction.\n\n2) Physical-space Robin-coupled one-level additive Schwarz. On each subdomain, include the endpoints in the local unknown vector and impose homogeneous Robin boundary conditions at the artificial subdomain boundaries. For subdomain $\\Omega_A$ with local grid unknowns $u_0,\\dots,u_{m_A-1}$, the boundary conditions at the left endpoint and right endpoint are \n$$\n\\frac{u_0 - u_{-1}}{h} + \\theta u_0 = 0, \\quad \\frac{u_{m_A} - u_{m_A-1}}{h} + \\theta u_{m_A-1} = 0,\n$$\nrespectively; eliminate the ghost values $u_{-1}$ and $u_{m_A}$ to obtain a local operator acting on all $m_A$ local unknowns. The same construction applies for $\\Omega_B$ with its local unknowns. Let $A_A^{(\\theta)}$ and $A_B^{(\\theta)}$ denote these Robin-modified local operators. The Robin-coupled one-level additive Schwarz preconditioner is \n$$\nM_{\\text{Rb}(\\theta)}^{-1} r = R_A^\\top \\left(A_A^{(\\theta)}\\right)^{-1} R_A r \\;+\\; R_B^\\top \\left(A_B^{(\\theta)}\\right)^{-1} R_B r,\n$$\nwhere now $R_A$ and $R_B$ restrict to all subdomain nodes, including endpoints, and $R_A^\\top$, $R_B^\\top$ prolong by zero-filling outside the subdomain.\n\nTasks:\n\na) Implement the periodic operator $A$ and compute the error propagation operators \n$$\nE_K = I - M_K^{-1} A, \\quad E_{\\text{Rb}(\\theta)} = I - M_{\\text{Rb}(\\theta)}^{-1} A.\n$$\nUse the exact linear action of these operators on canonical basis vectors to assemble the dense matrices for $E_K$ and $E_{\\text{Rb}(\\theta)}$.\n\nb) Using the discrete Fourier transform on the periodic grid, implement the truncated spectrum coarse correction for $M_K^{-1}$. For the Robin subdomain operators, implement the homogeneous Robin boundary conditions by eliminating the ghost points using the discrete approximation \n$$\nu_{-1} = u_0 (1 + \\theta h), \\quad u_{m_A} = u_{m_A-1} (1 - \\theta h),\n$$\nand analogously for $\\Omega_B$.\n\nc) Compute the spectral radii $\\rho(E_K)$ and $\\rho\\left(E_{\\text{Rb}(\\theta)}\\right)$ for a set of test cases, defined below, that vary the truncation level $K$ and the Robin parameter $\\theta$. Return the spectral radii as floating-point numbers.\n\nFundamental base and facts to use:\n\n- Use the finite difference Laplacian on a periodic grid and the fact that discrete Fourier series diagonalize convolution operators on periodic grids.\n- Use the definition of the spectral radius $\\rho(T)$ of a matrix $T$ as the maximum absolute value of its eigenvalues.\n- Use standard domain decomposition preconditioner constructions: additive Schwarz with homogeneous Dirichlet boundary conditions; Robin boundary conditions enforced via ghost point elimination; and a global Fourier coarse correction acting only on low modes.\n\nAngle unit specification: Any Fourier analysis must treat angles in radians. The Fourier wavenumber $k$ is an integer and the angular frequency is $2\\pi k$ radians per unit interval length.\n\nTest suite:\n\n- Use $N = 64$, $\\beta = 1.0$, and overlap $o = 8$.\n- Evaluate the spectral radii for the following $(K,\\theta)$ pairs:\n  1. $(0, 0.1)$ [boundary case: no coarse correction]\n  2. $(2, 0.1)$ [small coarse space versus weak Robin]\n  3. $(4, 1.0)$ [moderate coarse space versus moderate Robin]\n  4. $(8, 1.0)$ [larger coarse space versus moderate Robin]\n  5. $(16, 10.0)$ [large coarse space versus strong Robin]\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with entries ordered as \n$$\n[\\rho(E_K)_{(K,\\theta)_1}, \\rho(E_{\\text{Rb}(\\theta)})_{(K,\\theta)_1}, \\dots, \\rho(E_K)_{(K,\\theta)_5}, \\rho(E_{\\text{Rb}(\\theta)})_{(K,\\theta)_5}],\n$$\nwhere the subscript indicates the test case index from 1 to 5. Each entry must be a floating-point number in radians-based spectral analysis (unitless). No other text should be printed.",
            "solution": "The problem asks for the computation of spectral radii for two types of preconditioned iterations for the operator $A = \\beta I - \\Delta_h$ on a periodic domain. The spectral radius of the error propagation operator $E = I - M^{-1}A$ determines the asymptotic convergence rate of the preconditioned Richardson iteration. We will construct the dense matrix representations for the operator $A$ and the preconditioners $M_K^{-1}$ and $M_{\\text{Rb}(\\theta)}^{-1}$ to form the matrices for $E_K$ and $E_{\\text{Rb}(\\theta)}$.\n\n**1. Global Operator $A$**\nThe operator $A u = \\beta u - \\Delta_h u$ is defined on a periodic grid of $N$ points with spacing $h=1/N$. The discrete Laplacian $(\\Delta_h u)_i = (u_{i-1} - 2u_i + u_{i+1})/h^2$ with periodic indices (modulo $N$) means that $A$ can be represented by an $N \\times N$ symmetric circulant matrix. The $i$-th row of matrix $A$ corresponds to the equation:\n$$ (A u)_i = \\beta u_i - \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = -\\frac{1}{h^2} u_{i-1} + \\left(\\beta + \\frac{2}{h^2}\\right) u_i - \\frac{1}{h^2} u_{i+1} $$\nThe diagonal entries are $A_{ii} = \\beta + 2/h^2$, and the sub- and super-diagonal entries are $A_{i, i\\pm 1} = -1/h^2$. Due to periodicity, the corner entries are $A_{0, N-1} = A_{N-1, 0} = -1/h^2$.\n\n**2. Fourier-based Preconditioner $M_K^{-1}$**\nThis preconditioner is the sum of two components, $M_K^{-1} = M_{\\text{AS}}^{-1} + M_{\\text{coarse}}^{-1}$. We construct the matrix for each part.\n\n**2.1. Additive Schwarz Part $M_{\\text{AS}}^{-1}$**\nThe one-level Additive Schwarz preconditioner is given by $M_{\\text{AS}}^{-1} = R_A^\\top A_A^{-1} R_A + R_B^\\top A_B^{-1} R_B$. The subdomains are $\\Omega_A$ (indices $\\{0, ..., m_A-1\\}$) and $\\Omega_B$ (indices $\\{N/2-o, ..., N-1\\}$), where $m_A = m_B = N/2+o$. For this preconditioner, local problems are posed on the interior nodes of each subdomain with homogeneous Dirichlet boundary conditions.\n- The interior of $\\Omega_A$ consists of $m_A-2$ nodes, corresponding to global indices $\\{1, ..., m_A-2\\}$.\n- The interior of $\\Omega_B$ consists of $m_B-2$ nodes, corresponding to global indices $\\{N/2-o+1, ..., N-1-1=N/2+o-2\\}$. The local operator $A_A$ (and $A_B$, which is identical) is the $(m_A-2) \\times (m_A-2)$ tridiagonal matrix representing $\\beta I - \\Delta_h$ with Dirichlet conditions: diagonal entries are $\\beta+2/h^2$ and off-diagonals are $-1/h^2$.\nThe restriction operators $R_A$ and $R_B$ extract the relevant interior components, while the prolongation operators $R_A^\\top$ and $R_B^\\top$ place the local solutions back into a global vector, padding with zeros. The matrix for $M_{\\text{AS}}^{-1}$ is an $N \\times N$ matrix. The action of $R^\\top (\\cdot) R$ corresponds to embedding the inverse local operator matrix $A_{\\text{local}}^{-1}$ into the global matrix at the indices corresponding to the subdomain. Thus, we form the matrix for $M_{\\text{AS}}^{-1}$ by first computing $A_A^{-1}$ and then adding this $(m_A-2) \\times (m_A-2)$ matrix into the block of $M_{\\text{AS}}^{-1}$ corresponding to the interior of $\\Omega_A$, and again for $\\Omega_B$.\n\n**2.2. Coarse Correction Part**\nThe coarse correction is defined in Fourier space as applying the spectral multiplier $\\widehat{z}_k = [\\beta + (2\\pi k)^2]^{-1} \\widehat{r}_k$ for integer wavenumbers $|k| \\le K$, and $0$ otherwise. This operation is a convolution. The matrix representation of a convolution operator on a periodic grid is a circulant matrix. Its first column is the result of applying the operator to the first canonical basis vector $e_0 = [1, 0, \\dots, 0]^\\top$. The discrete Fourier transform of $e_0$ is a vector of all ones, i.e., $\\widehat{(e_0)}_k = 1$ for all wavenumbers $k$.\nTherefore, the Fourier coefficients of the first column of the coarse correction matrix are $\\widehat{c}_k = 1/[\\beta + (2\\pi k)^2]$ for $|k| \\le K$ and $0$ otherwise. The first column itself is obtained by the inverse discrete Fourier transform, $c = \\mathcal{F}^{-1}(\\widehat{c})$. The full $N \\times N$ matrix for the coarse correction is the circulant matrix generated from this column vector $c$. The total preconditioner matrix is $M_K^{-1} = M_{\\text{AS}}^{-1} + M_{\\text{coarse}}^{-1}$.\n\n**3. Robin-Coupled Preconditioner $M_{\\text{Rb}(\\theta)}^{-1}$**\nThis preconditioner is given by $M_{\\text{Rb}(\\theta)}^{-1} = R_A^\\top (A_A^{(\\theta)})^{-1} R_A + R_B^\\top (A_B^{(\\theta)})^{-1} R_B$. Here, the local problems are solved on all nodes of the subdomains $\\Omega_A$ and $\\Omega_B$, which have size $m=N/2+o$.\nThe local operators $A_A^{(\\theta)}$ and $A_B^{(\\theta)}$ are constructed by imposing Robin boundary conditions at both ends of each subdomain segment. For a generic local problem on $m$ nodes $u_0, \\dots, u_{m-1}$, the discrete operator equation $(\\beta I - \\Delta_h)u = f$ is modified at the boundaries.\n- At the left boundary ($i=0$), the equation is $(\\beta+2/h^2)u_0 - u_{-1}/h^2 - u_1/h^2 = f_0$. The ghost point $u_{-1}$ is eliminated using the given condition $u_{-1} = u_0(1+\\theta h)$, resulting in the modified equation $(\\beta+1/h^2-\\theta/h)u_0 - u_1/h^2 = f_0$.\n- At the right boundary ($i=m-1$), the equation is $(\\beta+2/h^2)u_{m-1} - u_{m-2}/h^2 - u_m/h^2 = f_{m-1}$. The ghost point $u_m$ is eliminated using $u_m = u_{m-1}(1-\\theta h)$, yielding $-u_{m-2}/h^2 + (\\beta+1/h^2+\\theta/h)u_{m-1} = f_{m-1}$.\nThe resulting $m \\times m$ local operator matrix, denoted $A^{(\\theta)}$, is tridiagonal with modified diagonal entries at the corners, rendering it non-symmetric. As per the instruction \"The same construction applies for $\\Omega_B$,\" we use this same local operator matrix $A^{(\\theta)}$ for both subdomains.\nThe matrix for $M_{\\text{Rb}(\\theta)}^{-1}$ is constructed by computing $(A^{(\\theta)})^{-1}$ and adding this $m \\times m$ block matrix into the corresponding blocks of the global $N \\times N$ matrix for the indices of $\\Omega_A$ and $\\Omega_B$.\n\n**4. Spectral Radius Calculation**\nFor each test case $(K, \\theta)$, we assemble the dense $N \\times N$ matrices for $A$, $M_K^{-1}$, and $M_{\\text{Rb}(\\theta)}^{-1}$. We then compute the error propagation matrices $E_K = I - M_K^{-1} A$ and $E_{\\text{Rb}(\\theta)} = I - M_{\\text{Rb}(\\theta)}^{-1} A$. The spectral radius is found by numerically computing all eigenvalues of these matrices and finding the one with the largest magnitude: $\\rho(E) = \\max_j |\\lambda_j(E)|$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import circulant\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 0.1),\n        (2, 0.1),\n        (4, 1.0),\n        (8, 1.0),\n        (16, 10.0),\n    ]\n\n    # Global parameters\n    N = 64\n    beta = 1.0\n    o = 8\n    h = 1.0 / N\n    h_sq_inv = 1.0 / (h * h)\n\n    # 1. Construct the global operator A\n    diag_val = beta + 2.0 * h_sq_inv\n    off_diag_val = -h_sq_inv\n    A = np.zeros((N, N))\n    A += np.diag(np.full(N, diag_val))\n    A += np.diag(np.full(N - 1, off_diag_val), k=1)\n    A += np.diag(np.full(N - 1, off_diag_val), k=-1)\n    A[0, N - 1] = off_diag_val\n    A[N - 1, 0] = off_diag_val\n    \n    identity_N = np.eye(N)\n    \n    results = []\n    for K, theta in test_cases:\n        # 2. Construct Fourier-based preconditioner M_K^-1\n        \n        # 2.1 Additive Schwarz part (M_AS^-1)\n        m_A_int = N // 2 + o - 2  # Size of interior subdomain\n        A_local_dirichlet = np.zeros((m_A_int, m_A_int))\n        A_local_dirichlet += np.diag(np.full(m_A_int, diag_val))\n        A_local_dirichlet += np.diag(np.full(m_A_int - 1, off_diag_val), k=1)\n        A_local_dirichlet += np.diag(np.full(m_A_int - 1, off_diag_val), k=-1)\n\n        A_local_dirichlet_inv = np.linalg.inv(A_local_dirichlet)\n\n        M_AS_inv = np.zeros((N, N))\n        \n        # Subdomain A interior indices\n        idx_A_int = slice(1, 1 + m_A_int)\n        # Subdomain B interior indices\n        idx_B_int = slice(N // 2 - o + 1, N // 2 - o + 1 + m_A_int)\n        \n        M_AS_inv[idx_A_int, idx_A_int] += A_local_dirichlet_inv\n        M_AS_inv[idx_B_int, idx_B_int] += A_local_dirichlet_inv\n\n        # 2.2 Coarse correction part\n        k_wave = np.fft.fftfreq(N) * N\n        z_hat = np.zeros(N, dtype=complex)\n        mask = np.abs(k_wave) = K\n        \n        # To avoid division by zero if beta=0 and k=0\n        denom = beta + (2 * np.pi * k_wave[mask])**2\n        # np.fft.fft of identity vector is a vector of ones\n        r_hat_e0 = np.ones(N) \n        z_hat[mask] = 1.0 / denom\n\n        first_col = np.fft.ifft(z_hat).real\n        M_coarse_inv = circulant(first_col)\n\n        # 2.3 Total preconditioner M_K^-1\n        M_K_inv = M_AS_inv + M_coarse_inv\n        \n        # 2.4 Compute spectral radius for M_K\n        E_K = identity_N - M_K_inv @ A\n        rho_K = np.max(np.abs(np.linalg.eigvals(E_K)))\n        results.append(rho_K)\n\n        # 3. Construct Robin-coupled preconditioner M_Rb(theta)^-1\n        m_A_full = N // 2 + o # Size of full subdomain\n        A_theta = np.zeros((m_A_full, m_A_full))\n        A_theta += np.diag(np.full(m_A_full, diag_val))\n        A_theta += np.diag(np.full(m_A_full - 1, off_diag_val), k=1)\n        A_theta += np.diag(np.full(m_A_full - 1, off_diag_val), k=-1)\n\n        # Apply Robin boundary conditions\n        A_theta[0, 0] = beta + h_sq_inv - theta / h\n        A_theta[m_A_full - 1, m_A_full - 1] = beta + h_sq_inv + theta / h\n        \n        A_theta_inv = np.linalg.inv(A_theta)\n\n        M_Rb_inv = np.zeros((N, N))\n        \n        # Subdomain A full indices\n        idx_A_full = slice(0, m_A_full)\n        # Subdomain B full indices\n        idx_B_full = slice(N // 2 - o, N // 2 - o + m_A_full)\n        \n        M_Rb_inv[idx_A_full, idx_A_full] += A_theta_inv\n        M_Rb_inv[idx_B_full, idx_B_full] += A_theta_inv\n        \n        # 3.1 Compute spectral radius for M_Rb\n        E_Rb = identity_N - M_Rb_inv @ A\n        rho_Rb = np.max(np.abs(np.linalg.eigvals(E_Rb)))\n        results.append(rho_Rb)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}