{
    "hands_on_practices": [
        {
            "introduction": "Spectral filtering is a primary tool for mitigating the Gibbs phenomenon, but its application involves inherent trade-offs. This exercise provides a quantitative framework for exploring two key side effects: dissipation, which attenuates the signal's energy, and dispersion, which introduces phase errors that can shift features. By implementing and testing a parameterized filter on a canonical square wave, you will gain hands-on experience in measuring these effects and understanding the fundamental balance required in designing effective de-Gibbs methods. ",
            "id": "3373752",
            "problem": "Consider a $2\\pi$-periodic piecewise constant function with a jump discontinuity,\n$$\nf(x) = \\begin{cases}\n1, & x \\in (0,\\pi),\\\\\n-1, & x \\in (\\pi,2\\pi),\n\\end{cases}\n$$\nextended periodically to all $x \\in \\mathbb{R}$. This function has a classical Fourier series with only sine harmonics and exhibits the Gibbs phenomenon when approximated by truncated series. Let $K \\in \\mathbb{N}$ denote the highest retained harmonic index in a truncated complex Fourier series, and let $\\{c_k\\}_{k=-K}^K$ be the corresponding complex Fourier coefficients of $f(x)$ in the $2\\pi$-periodic convention. Define a filtered truncated reconstruction operator acting on the coefficients by complex multipliers $\\{\\sigma_k\\}_{k=-K}^K$, yielding the filtered approximation\n$$\nu_K(x) = \\sum_{k=-K}^K \\sigma_k \\, c_k \\, e^{i k x}.\n$$\nA de-Gibbs method in this setting is any choice of $\\{\\sigma_k\\}$ that reduces oscillations near jumps. In order to quantify dispersion versus dissipation introduced by such methods, consider the following one-parameter family of filters that combines amplitude attenuation and phase modulation while preserving the reality of $u_K(x)$:\n$$\n\\sigma_k = \\exp\\!\\Big(-\\alpha \\, \\big(\\tfrac{|k|}{K}\\big)^{p}\\Big) \\, \\exp\\!\\Big(i\\, \\beta \\, \\big(\\tfrac{k}{K}\\big)^{q}\\Big),\n$$\nwith parameters $\\alpha \\ge 0$, $p \\in \\mathbb{N}$, $\\beta \\in \\mathbb{R}$, and odd $q \\in \\mathbb{N}$. The oddness of $q$ ensures $\\sigma_{-k} = \\overline{\\sigma_k}$ so that $u_K(x)$ is real-valued whenever $f(x)$ is real-valued.\n\nStarting from the fundamental definitions of Fourier series, orthogonality on $[0,2\\pi]$, and the complex-exponential representation of truncated reconstructions, implement a program that, for each parameter set in the test suite below, computes three quantitative metrics:\n- Normalized overshoot amplitude near the jump (Gibbs oscillation): define\n$$\n\\mathcal{A}_{\\mathrm{over}} = \\frac{\\max_{x \\in (0,\\pi)} \\big(u_K(x) - 1\\big)_+}{2},\n$$\nwhere $(\\cdot)_+ = \\max(\\cdot,0)$ and the denominator $2$ is the jump magnitude.\n- Spectral dissipation ratio due to filtering:\n$$\n\\mathcal{E}_{\\mathrm{ratio}} = \\frac{\\sum_{k=-K}^K |\\sigma_k \\, c_k|^2}{\\sum_{k=-K}^K |c_k|^2},\n$$\nwhich measures the energy attenuation in coefficient space and isolates dissipation from sampling effects.\n- Dispersion-induced jump shift in radians (angle unit is radians): define $\\Delta$ as the absolute difference between $x=\\pi$ and the zero-crossing location of $u_K(x)$ that is closest to $\\pi$, computed on a uniform grid, i.e.,\n$$\n\\Delta = \\min\\{|x_0 - \\pi|: u_K(x_0) = 0\\},\n$$\nwhere the minimization is taken over zero-crossings identified from a fine uniform grid on $[0,2\\pi)$.\n\nImplementation requirements:\n- Use a uniform grid of $M$ points with $M = 32768$ on $[0,2\\pi)$ to evaluate $u_K(x)$ via a discrete inverse transform consistent with the complex-exponential representation. You must ensure $K \\ll M/2$ to prevent aliasing in the evaluation.\n- Use the exact complex Fourier coefficients $c_k$ of $f(x)$, determined from orthogonality on $[0,2\\pi]$, rather than estimating them from sampled data.\n- Compute $\\mathcal{A}_{\\mathrm{over}}$ by scanning the half-interval $(0,\\pi)$ on the grid.\n- Compute $\\mathcal{E}_{\\mathrm{ratio}}$ directly from the coefficients $\\{c_k\\}$ and multipliers $\\{\\sigma_k\\}$, not from sampled values.\n- Compute $\\Delta$ by locating zero-crossings on the grid and selecting the crossing with minimal absolute distance to $\\pi$; if a grid point is exactly zero at $\\pi$, take $\\Delta = 0$.\n- All angles must be handled in radians.\n\nTest suite:\nUse $K = 255$ and the following filter parameter sets $(p,\\alpha,\\beta,q)$:\n- Case $1$: $(8,\\, 0.0,\\, 0.0,\\, 3)$.\n- Case $2$: $(8,\\, 36.0,\\, 0.0,\\, 3)$.\n- Case $3$: $(8,\\, 36.0,\\, 0.1,\\, 3)$.\n- Case $4$: $(8,\\, 36.0,\\, 0.6,\\, 3)$.\n- Case $5$: $(8,\\, 200.0,\\, 0.0,\\, 3)$.\n\nYour program should output, for each case, a list of three floating-point numbers $[\\mathcal{A}_{\\mathrm{over}}, \\mathcal{E}_{\\mathrm{ratio}}, \\Delta]$, each rounded to six decimal places. Your program should produce a single line of output containing the results as a comma-separated list of these triplets, enclosed in square brackets, for example:\n$$\n[\\,[a_1, e_1, d_1],\\,[a_2, e_2, d_2],\\,\\dots\\,]\n$$\nwhere each $a_j$, $e_j$, and $d_j$ are floats rounded to six decimal places.",
            "solution": "The user has requested a solution to a problem involving the analysis of filtered Fourier series reconstructions of a piecewise constant function. The task requires calculating three specific metrics: normalized overshoot amplitude, spectral dissipation ratio, and dispersion-induced jump shift. I will first validate the problem statement, then provide a detailed solution methodology, culminating in a Python implementation.\n\n### Problem Validation\n\n**Step 1: Extracted Givens**\n- **Function**: A $2\\pi$-periodic function $f(x)$ where $f(x)=1$ for $x \\in (0,\\pi)$ and $f(x)=-1$ for $x \\in (\\pi,2\\pi)$.\n- **Truncation Index**: $K \\in \\mathbb{N}$, set to $K=255$.\n- **Reconstruction**: $u_K(x) = \\sum_{k=-K}^K \\sigma_k \\, c_k \\, e^{i k x}$, where $\\{c_k\\}$ are the complex Fourier coefficients.\n- **Filter Multipliers**: $\\sigma_k = \\exp(-\\alpha (\\frac{|k|}{K})^{p}) \\exp(i \\beta (\\frac{k}{K})^{q})$ with parameters $(\\alpha, p, \\beta, q)$.\n- **Metrics**: $\\mathcal{A}_{\\mathrm{over}} = \\frac{\\max_{x \\in (0,\\pi)} (u_K(x) - 1)_+}{2}$, $\\mathcal{E}_{\\mathrm{ratio}} = \\frac{\\sum_{k=-K}^K |\\sigma_k c_k|^2}{\\sum_{k=-K}^K |c_k|^2}$, and $\\Delta = \\min\\{|x_0 - \\pi|: u_K(x_0) = 0\\}$.\n- **Numerical Parameters**: Grid size $M = 32768$ on $[0,2\\pi)$.\n- **Test Cases for $(p,\\alpha,\\beta,q)$**:\n  1. $(8, 0.0, 0.0, 3)$\n  2. $(8, 36.0, 0.0, 3)$\n  3. $(8, 36.0, 0.1, 3)$\n  4. $(8, 36.0, 0.6, 3)$\n  5. $(8, 200.0, 0.0, 3)$\n\n**Step 2: Validation of Givens**\nThe problem is scientifically grounded in the established theory of Fourier analysis and signal processing. It addresses the well-known Gibbs phenomenon and methods for its mitigation (spectral filtering). All terms are standard or explicitly defined with mathematical precision. The given parameters are self-consistent and numerically feasible ($K=255 \\ll M/2=16384$, satisfying the anti-aliasing condition). The problem is objective, well-posed, and requires non-trivial computation and analysis. No flaws are identified.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n### Solution Methodology\n\nThe solution requires a sequence of analytical and numerical steps. First, we derive the exact Fourier coefficients of the given function. Second, we implement the filtered reconstruction numerically. Finally, we compute the specified metrics for each test case.\n\n**1. Derivation of Fourier Coefficients**\nThe complex Fourier coefficients $c_k$ for a $2\\pi$-periodic function are defined by the analysis integral over one period, $[0, 2\\pi]$:\n$$\nc_k = \\frac{1}{2\\pi} \\int_0^{2\\pi} f(x) e^{-ikx} \\,dx\n$$\nSubstituting the piecewise definition of $f(x)$:\n$$\nc_k = \\frac{1}{2\\pi} \\left( \\int_0^\\pi (1) e^{-ikx} \\,dx + \\int_\\pi^{2\\pi} (-1) e^{-ikx} \\,dx \\right)\n$$\nFor $k=0$, the mean value is $c_0 = \\frac{1}{2\\pi}(\\int_0^\\pi 1 \\,dx + \\int_\\pi^{2\\pi} -1 \\,dx) = \\frac{1}{2\\pi}(\\pi - \\pi) = 0$.\nFor $k \\neq 0$, the integral is:\n$$\nc_k = \\frac{1}{2\\pi} \\left( \\left[\\frac{e^{-ikx}}{-ik}\\right]_0^\\pi - \\left[\\frac{e^{-ikx}}{-ik}\\right]_\\pi^{2\\pi} \\right) = \\frac{1}{-i2\\pi k} \\left( (e^{-ik\\pi}-1) - (e^{-ik2\\pi}-e^{-ik\\pi}) \\right)\n$$\nUsing Euler's identity, $e^{-ik\\pi} = (-1)^k$ and $e^{-ik2\\pi} = 1$:\n$$\nc_k = \\frac{1}{-i2\\pi k} \\left( (-1)^k - 1 - 1 + (-1)^k \\right) = \\frac{2((-1)^k - 1)}{-i2\\pi k}\n$$\nThis expression can be simplified by considering the parity of $k$:\n- If $k$ is even and non-zero, $1 - (-1)^k = 1 - 1 = 0$, so $c_k = 0$.\n- If $k$ is odd, $1 - (-1)^k = 1 - (-1) = 2$. The expression for $c_k$ becomes $\\frac{2(-2)}{-i2\\pi k} = \\frac{-4}{-i2\\pi k} = \\frac{-2i}{\\pi k}$.\n\nSo the coefficients are:\n$$\nc_k = \\begin{cases}\n0, & \\text{if } k \\text{ is even} \\\\\n-\\frac{2i}{\\pi k}, & \\text{if } k \\text{ is odd}\n\\end{cases}\n$$\nThese values are computed for $k \\in [-K, K]$.\n\n**2. Numerical Reconstruction**\nThe filtered reconstruction $u_K(x) = \\sum_{k=-K}^{K} \\sigma_k c_k e^{ikx}$ is evaluated on a uniform grid $x_j = j \\frac{2\\pi}{M}$ for $j=0, \\dots, M-1$. This sum has the structure of an Inverse Discrete Fourier Transform (IDFT). We can leverage the highly efficient Fast Fourier Transform (FFT) algorithm.\nAn $M$-point FFT requires an array of $M$ coefficients, let's call it $U$. These are related to our filtered coefficients $\\hat{c}_k = \\sigma_k c_k$ as follows:\n- The coefficient for frequency index $k \\in [0, K]$ is placed at index $k$ of the array $U$: $U_k = \\hat{c}_k$.\n- The coefficient for frequency index $k \\in [-K, -1]$ is placed at index $M+k$: $U_{M+k} = \\hat{c}_k$.\n- All other coefficients of $U$ (for $|k| > K$) are zero.\n\nThe reconstruction on the grid is then given by $u_K(x_j) = M \\cdot \\text{IDFT}(U)_j$. We use `numpy.fft.ifft`. The property $\\sigma_{-k} = \\overline{\\sigma_k}$ and $c_{-k} = \\overline{c_k}$ (true for any real function, and holds for our odd function) ensures that the resulting Fourier array $U$ has conjugate symmetry ($U_{M-k} = \\overline{U_k}$), which guarantees that the `ifft` result is real-valued (up to machine precision).\n\n**3. Computation of Metrics**\n- **$\\mathcal{A}_{\\mathrm{over}}$ (Normalized Overshoot Amplitude)**: The grid points corresponding to the interval $(0, \\pi)$ are $x_j$ for $j \\in [1, M/2-1]$. We find the maximum value of $u_K(x_j)$ in this range, compute the overshoot above the target value of $1$, and normalize by the total jump magnitude of $1 - (-1) = 2$.\n$$ \\mathcal{A}_{\\mathrm{over}} = \\frac{\\max_{j \\in [1, M/2-1]} \\max(0, u_K(x_j) - 1)}{2} $$\n\n- **$\\mathcal{E}_{\\mathrm{ratio}}$ (Spectral Dissipation Ratio)**: This metric is computed directly from the coefficients. It is the ratio of the energy of the filtered coefficients to the energy of the original coefficients.\n$$ \\mathcal{E}_{\\mathrm{ratio}} = \\frac{\\sum_{k=-K}^K |\\sigma_k c_k|^2}{\\sum_{k=-K}^K |c_k|^2} $$\nSince $|\\sigma_k| = \\exp(-\\alpha (|k|/K)^p)$, this ratio depends on the filter's amplitude response ($\\alpha, p$) but not its phase response ($\\beta, q$).\n\n- **$\\Delta$ (Dispersion-induced Jump Shift)**: This measures the shift of the jump's center. For the unfiltered series ($\\beta=0$), the reconstruction is zero at $x=\\pi$. For $\\beta \\neq 0$, a phase shift is introduced, moving the zero-crossing away from $\\pi$.\n  - For cases where $\\beta=0$, the filter $\\sigma_k$ is real. This preserves the symmetry properties that lead to $u_K(\\pi)=0$. Thus, $\\Delta=0$.\n  - For cases where $\\beta \\neq 0$, $u_K(\\pi)$ is generally non-zero. We must locate the zero-crossing of $u_K(x)$ closest to $x=\\pi$. We identify all grid intervals $[x_j, x_{j+1}]$ where the sign of $u_K(x)$ changes, i.e., $u_K(x_j)u_K(x_{j+1}) < 0$. For each such interval, we find a more precise zero-crossing location $x_0$ using linear interpolation:\n    $$ x_0 = x_j - u_K(x_j) \\frac{x_{j+1} - x_j}{u_K(x_{j+1}) - u_K(x_j)} $$\n  We also include any grid points $x_j$ where $u_K(x_j)$ is exactly zero. From this set of all located zeros, we find the one closest to $\\pi$, and its distance is $\\Delta$.\n\nThese steps will be executed for each parameter set provided in the test suite.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes overshoot, dissipation, and jump shift for filtered Fourier series.\n\n    The solution proceeds as follows:\n    1. Define problem parameters (K, M) and the test suite.\n    2. Pre-compute the exact complex Fourier coefficients `c_k` for the given\n       piecewise constant function.\n    3. For each test case in the suite:\n       a. Compute the filter multipliers `sigma_k`.\n       b. Calculate the spectral dissipation ratio `E_ratio` from the coefficients.\n       c. Construct the full M-point coefficient array `U` for the IFFT.\n       d. Evaluate the filtered reconstruction `u_K(x)` on the grid using `np.fft.ifft`.\n       e. Calculate the normalized overshoot `A_over` by scanning the first half of\n          the spatial domain.\n       f. Calculate the jump shift `Delta`. If the filter is purely real (beta=0),\n          the shift is zero. Otherwise, locate zero-crossings near the jump\n          using linear interpolation between grid points where a sign change occurs.\n    4. Format the results for all cases into the required string format and print.\n    \"\"\"\n    K = 255\n    M = 32768\n\n    test_cases = [\n        # (p, alpha, beta, q)\n        (8, 0.0, 0.0, 3),    # Case 1: Unfiltered\n        (8, 36.0, 0.0, 3),   # Case 2: Strong dissipation, no dispersion\n        (8, 36.0, 0.1, 3),   # Case 3: Strong dissipation, small dispersion\n        (8, 36.0, 0.6, 3),   # Case 4: Strong dissipation, large dispersion\n        (8, 200.0, 0.0, 3)   # Case 5: Very strong dissipation, no dispersion\n    ]\n\n    # --- Step 1: Compute base Fourier coefficients c_k ---\n    k_vals = np.arange(-K, K + 1)\n    c = np.zeros(2 * K + 1, dtype=np.complex128)\n    # The function is odd, so c_k = 0 for k even.\n    # For k odd, c_k = -2i / (pi * k).\n    for i, k in enumerate(k_vals):\n        if k % 2 != 0:\n            c[i] = -2j / (np.pi * k)\n\n    # Calculate total energy of original coefficients for E_ratio denominator\n    c_energy = np.sum(np.abs(c)**2)\n\n    # --- Step 2: Define spatial grid ---\n    x_grid = np.linspace(0, 2 * np.pi, M, endpoint=False)\n\n    all_results = []\n    for p, alpha, beta, q in test_cases:\n        # --- Step 3a: Compute filter coefficients sigma_k ---\n        k_norm_abs = np.abs(k_vals) / K\n        k_norm = k_vals / K\n        \n        # Guard against 0^q for negative bases, even though k_norm is real\n        # and this is not an issue here, it's good practice.\n        phase_term = np.sign(k_norm) * np.abs(k_norm)**q\n        sigma = np.exp(-alpha * (k_norm_abs**p)) * np.exp(1j * beta * phase_term)\n\n\n        filtered_c = sigma * c\n\n        # --- Step 3b: Compute Metric 2: E_ratio ---\n        filtered_c_energy = np.sum(np.abs(filtered_c)**2)\n        # Avoid division by zero if K=0 (not the case here)\n        E_ratio = filtered_c_energy / c_energy if c_energy > 0 else 0.0\n\n        # --- Step 3c & 3d: Evaluate u_K(x) using IFFT ---\n        U = np.zeros(M, dtype=np.complex128)\n        # Positive frequencies k=0...K map to array indices 0...K\n        U[0:K + 1] = filtered_c[K:(2 * K + 1)]\n        # Negative frequencies k=-K...-1 map to array indices M-K...M-1\n        U[M - K:] = filtered_c[0:K]\n        \n        u = (M * np.fft.ifft(U)).real\n\n        # --- Step 3e: Compute Metric 1: A_over ---\n        # The relevant interval is (0, pi), which corresponds to grid indices 1 to M/2-1.\n        # The jump is from -1 to 1, total magnitude 2. Overshoot is relative to 1.\n        u_half_interval = u[1:M // 2]\n        overshoot_values = np.maximum(u_half_interval - 1.0, 0)\n        max_overshoot = np.max(overshoot_values)\n        A_over = max_overshoot / 2.0\n\n        # --- Step 3f: Compute Metric 3: Delta ---\n        Delta = 0.0\n        if beta != 0.0:\n            zero_crossings = []\n            \n            # Find exact zeros on the grid\n            exact_zeros = np.where(u == 0)[0]\n            if len(exact_zeros) > 0:\n                zero_crossings.extend(x_grid[exact_zeros])\n            \n            # Find sign changes between grid points and interpolate\n            # Use u[:-1] * u[1:] < 0 to robustly find sign changes\n            cross_indices = np.where(u[:-1] * u[1:] < 0)[0]\n            dx = x_grid[1] - x_grid[0]\n            for j in cross_indices:\n                x0 = x_grid[j] - u[j] * dx / (u[j + 1] - u[j])\n                zero_crossings.append(x0)\n            \n            if zero_crossings:\n                # Find the minimum absolute distance to pi\n                distances = np.abs(np.array(zero_crossings) - np.pi)\n                Delta = np.min(distances)\n\n        case_results = [A_over, E_ratio, Delta]\n        \n        # --- Step 4: Format output ---\n        formatted_case_results = [f\"{val:.6f}\" for val in case_results]\n        all_results.append(f\"[{','.join(formatted_case_results)}]\")\n        \n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While filtering can suppress spurious oscillations, a crucial challenge in practice is to do so without corrupting the genuine, physically meaningful variations within a signal. This practice moves beyond simple step functions to a composite signal containing both a sharp discontinuity and smooth, wavelike features. You will implement and compare standard spectral filters, learning to use diagnostic metrics to disentangle the unwanted Gibbs artifacts from the true underlying oscillations and evaluate how well each filter preserves the signal's integrity. ",
            "id": "3373741",
            "problem": "Consider the $2\\pi$-periodic function $f(x)$ on the interval $[0,2\\pi)$ (angles in radians) composed of a single jump and a smooth oscillatory part. Let $a_L=-1$ and $a_R=1$, and define the piecewise constant function $h(x)$ by $h(x)=a_L$ for $x\\in[0,\\pi)$ and $h(x)=a_R$ for $x\\in[\\pi,2\\pi)$. Let the smooth oscillatory component be $g(x)=b_1\\sin(\\kappa_1 x)+b_2\\cos(\\kappa_2 x)$ with $b_1=0.15$, $b_2=0.10$, $\\kappa_1=7$, and $\\kappa_2=13$. The target function is $f(x)=h(x)+g(x)$. The jump set is the singleton $\\{x=\\pi\\}$, and the jump height is $J=a_R-a_L=2$.\n\nYou will approximate $f(x)$ by truncated Fourier series using the discrete Fourier transform on a uniform grid of $M$ equispaced points $x_j=\\frac{2\\pi j}{M}$ for $j=0,1,\\dots,M-1$, with $M=4096$. Let $\\widehat{f}_k$ be the discrete Fourier coefficients obtained by the standard Fast Fourier Transform (FFT) convention, where the forward transform is the discrete sum and the inverse transform includes the factor $1/M$. A truncated spectral approximation with cutoff $N$ is constructed by retaining Fourier modes with $|k|\\le N$ and zeroing modes with $|k|>N$. To study both unfiltered and filtered reconstructions, introduce spectral multipliers (filters) $\\sigma(|k|)$ that act on retained modes with $|k|\\le N$:\n- No filter: $\\sigma(|k|)=1$ for $|k|\\le N$ and $\\sigma(|k|)=0$ for $|k|>N$.\n- Exponential filter: for parameters $\\alpha=36$ and $p=8$, define $\\sigma(|k|)=\\exp\\!\\big(-\\alpha \\, (|k|/N)^p\\big)$ for $|k|\\le N$ and $\\sigma(|k|)=0$ for $|k|>N$.\n- Lanczos filter: define $\\sigma(0)=1$ and for $1\\le |k|\\le N$ set $\\sigma(|k|)=\\dfrac{\\sin\\!\\big(\\pi |k|/(N+1)\\big)}{\\pi |k|/(N+1)}$, and $\\sigma(|k|)=0$ for $|k|>N$.\n\nFrom the foundational standpoint, you must use the following base and definitions:\n- The Fourier series of a $2\\pi$-periodic function $f(x)$ has complex coefficients $a_k$ defined by $a_k=\\frac{1}{2\\pi}\\int_{0}^{2\\pi} f(x)\\,e^{-ikx}\\,dx$, and the $N$th partial sum is $S_N f(x)=\\sum_{k=-N}^{N} a_k e^{ikx}$.\n- The discrete Fourier transform evaluated on a uniform grid with the trapezoidal rule consistently approximates the continuous Fourier coefficients for sufficiently smooth $f(x)$, and, for piecewise smooth $f(x)$, the truncated reconstructions exhibit the Gibbs phenomenon near jumps.\n- The Gibbs phenomenon refers to the non-vanishing overshoot and oscillations near discontinuities in $S_N f(x)$ that do not diminish in amplitude as $N\\to\\infty$, though they become more localized.\n- Spectral filters are smooth multipliers $\\sigma(|k|)$ applied to Fourier coefficients to attenuate high modes and reduce spurious oscillations while striving to preserve smooth features away from jumps. This paradigm is shared with stabilization techniques used in high-order spectral and Discontinuous Galerkin (DG) methods.\n\nYour task is to implement a diagnostic that disentangles Gibbs oscillations (spurious) from genuine smooth oscillations (physical) through two quantitative metrics computed from reconstructions $u_{N,\\sigma}(x)$ obtained by inverse transforming filtered coefficients:\n- Normalized Gibbs overshoot near the jump: choose a symmetric window of half-width $w=0.2$ around the jump location $x=\\pi$. Let $U_\\text{win}$ be the set of reconstructed values $u_{N,\\sigma}(x)$ for $x\\in[\\pi-w,\\pi+w]$. Define the positive overshoot as $\\max\\{0,\\max U_\\text{win}-\\max(a_L,a_R)\\}$ and the negative undershoot as $\\max\\{0,\\min(a_L,a_R)-\\min U_\\text{win}\\}$. The Gibbs metric is $\\mathcal{G}=\\max\\{\\text{overshoot},\\text{undershoot}\\}/J$, a dimensionless float in $[0,\\infty)$.\n- Smooth-region root-mean-square error: on the interval $I=[0.1\\pi,0.9\\pi]$ (which contains no jump), compute the discrete root-mean-square error between $u_{N,\\sigma}(x)$ and the exact $f(x)$ using the uniform grid points lying in $I$. Denote this metric by $\\mathcal{E}$, a float in $[0,\\infty)$.\n\nInterpretation guidelines grounded in the definitions above: if $\\mathcal{G}$ remains significant while $\\mathcal{E}$ is small, the oscillations near $x=\\pi$ are dominated by Gibbs effects. If an appropriate filter decreases $\\mathcal{G}$ without substantially increasing $\\mathcal{E}$, then the filter effectively suppresses spurious oscillations while preserving the genuine smooth oscillations.\n\nYour program must implement the spectral truncation and filtering via the FFT using the precise filters above, compute the two metrics for each test case, and output their values.\n\nTest suite. Use the following seven test cases, each specified by the truncation $N$ and the filter type:\n- Case $1$: $N=16$, filter type $=$ none.\n- Case $2$: $N=16$, filter type $=$ exponential.\n- Case $3$: $N=64$, filter type $=$ none.\n- Case $4$: $N=64$, filter type $=$ exponential.\n- Case $5$: $N=64$, filter type $=$ Lanczos.\n- Case $6$: $N=256$, filter type $=$ none.\n- Case $7$: $N=256$, filter type $=$ exponential.\n\nAngle unit is radians. There are no physical units.\n\nRequired final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, for each test case the pair of floats $(\\mathcal{G},\\mathcal{E})$ formatted to six decimal places, concatenated across all cases in the given order. For example, an output with three cases would look like $[\\mathcal{G}_1,\\mathcal{E}_1,\\mathcal{G}_2,\\mathcal{E}_2,\\mathcal{G}_3,\\mathcal{E}_3]$. For this problem with seven cases, the output must therefore contain $14$ floats in total on a single line, with no additional text.",
            "solution": "The problem is valid. It is a well-posed, scientifically grounded exercise in numerical analysis, specifically concerning the approximation of discontinuous functions by truncated and filtered Fourier series. All parameters, functions, and metrics are unambiguously defined, allowing for a unique and verifiable numerical solution. The problem correctly frames the task within the context of spectral methods and the mitigation of the Gibbs phenomenon.\n\nThe solution methodology proceeds as follows:\n\nFirst, we establish the computational domain and the function to be approximated. A uniform grid of $M=4096$ points, $x_j = \\frac{2\\pi j}{M}$ for $j=0, 1, \\dots, M-1$, is defined on the interval $[0, 2\\pi)$. On this grid, we sample the target function $f(x) = h(x) + g(x)$. The function $h(x)$ is a piecewise constant step function defined as\n$$\nh(x) = \\begin{cases} a_L = -1 & \\text{if } x \\in [0, \\pi) \\\\ a_R = 1 & \\text{if } x \\in [\\pi, 2\\pi) \\end{cases}\n$$\nand the smooth component $g(x)$ is given by\n$$\ng(x) = b_1\\sin(\\kappa_1 x) + b_2\\cos(\\kappa_2 x)\n$$\nwith constants $b_1=0.15$, $b_2=0.10$, $\\kappa_1=7$, and $\\kappa_2=13$. The composite function $f(x)$ is then evaluated at each grid point $x_j$.\n\nNext, we compute the discrete Fourier transform (DFT) of the sampled function $f(x_j)$. The discrete Fourier coefficients $\\widehat{f}_k$ are obtained using the Fast Fourier Transform (FFT) algorithm. Let $\\{f_j\\}_{j=0}^{M-1}$ be the set of sampled function values. The forward transform is $\\widehat{f}_k = \\sum_{j=0}^{M-1} f_j e^{-i 2\\pi jk/M}$. The inverse transform, which reconstructs the signal, is $f_j = \\frac{1}{M} \\sum_{k=0}^{M-1} \\widehat{f}_k e^{i 2\\pi jk/M}$. This convention aligns with standard numerical libraries such as NumPy. The integer indices $k$ of the FFT output correspond to wavenumbers; for a signal on $[0, 2\\pi)$, the wavenumbers are integers. We can map the FFT indices $k \\in \\{0, \\dots, M-1\\}$ to the physical wavenumbers, which are approximately $[0, \\dots, M/2-1, -M/2, \\dots, -1]$.\n\nFor each test case, specified by a truncation number $N$ and a filter type, we construct a spectral multiplier (filter) array $\\sigma_k$. This array is applied element-wise to the computed Fourier coefficients $\\widehat{f}_k$. The filter is defined based on the wavenumber $|k|$ and the cutoff $N$.\n1.  **No filter (truncation only)**: This is equivalent to applying a sharp spectral filter, or a rectangular window, in Fourier space.\n    $$\n    \\sigma_k = \\begin{cases} 1 & \\text{if } |k| \\le N \\\\ 0 & \\text{if } |k| > N \\end{cases}\n    $$\n2.  **Exponential filter**: This is a smooth filter that decays rapidly for high wavenumbers. For parameters $\\alpha=36$ and $p=8$, it is defined as:\n    $$\n    \\sigma_k = \\begin{cases} \\exp\\left(-\\alpha \\left(\\frac{|k|}{N}\\right)^p\\right) & \\text{if } |k| \\le N \\\\ 0 & \\text{if } |k| > N \\end{cases}\n    $$\n    This filter preserves low-frequency modes and smoothly tapers high-frequency modes toward zero, reducing the Gibbs phenomenon.\n3.  **Lanczos filter**: This filter is derived from a sinc function.\n    $$\n    \\sigma_k = \\begin{cases} \\dfrac{\\sin(\\pi |k|/(N+1))}{\\pi |k|/(N+1)} & \\text{if } 1 \\le |k| \\le N \\\\ 1 & \\text{if } k=0 \\\\ 0 & \\text{if } |k| > N \\end{cases}\n    $$\n    Note that $\\lim_{z\\to 0} \\frac{\\sin(\\pi z)}{\\pi z} = 1$, so the formula is well-defined at $k=0$.\n\nThe filtered coefficients are computed as $\\widehat{u}_k = \\widehat{f}_k \\cdot \\sigma_k$. The reconstructed function on the grid, $u_{N,\\sigma}(x_j)$, is then obtained by applying the inverse FFT to the filtered coefficients $\\widehat{u}_k$. Since the original function $f(x)$ is real-valued, the reconstruction $u_{N,\\sigma}(x)$ should also be real, so we take the real part of the inverse FFT output, discarding any small imaginary parts that arise from numerical floating-point inaccuracies.\n\nFinally, we compute the two diagnostic metrics for each reconstruction.\n-   **Gibbs metric $\\mathcal{G}$**: This metric quantifies the overshoot/undershoot near the discontinuity at $x=\\pi$. We identify all grid points $x_j$ within the window $[\\pi - w, \\pi + w]$, where $w=0.2$. Let $U_\\text{win}$ be the set of reconstructed values $u_{N,\\sigma}(x_j)$ at these points. The overshoot is $\\max\\{0, \\max(U_\\text{win}) - a_R\\}$ and the undershoot is $\\max\\{0, a_L - \\min(U_\\text{win})\\}$, since $a_R = \\max(a_L, a_R) = 1$ and $a_L = \\min(a_L, a_R) = -1$. The metric is then the normalized maximum of these two values: $\\mathcal{G} = \\frac{\\max\\{\\text{overshoot}, \\text{undershoot}\\}}{J}$, where the jump height is $J=a_R-a_L=2$.\n\n-   **Smooth-region error $\\mathcal{E}$**: This metric measures the accuracy of the reconstruction in a region away from the discontinuity. We select the interval $I=[0.1\\pi, 0.9\\pi]$, which is devoid of jumps. We identify all grid points $x_j$ lying in this interval. The metric $\\mathcal{E}$ is the discrete root-mean-square error (RMSE) between the reconstructed values $u_{N,\\sigma}(x_j)$ and the exact values $f(x_j)$ for these points:\n$$\n\\mathcal{E} = \\sqrt{\\frac{1}{N_I} \\sum_{x_j \\in I} (u_{N,\\sigma}(x_j) - f(x_j))^2}\n$$\nwhere $N_I$ is the number of grid points in the interval $I$.\n\nThis entire procedure is repeated for each of the seven test cases, and the resulting pairs of metrics $(\\mathcal{G}, \\mathcal{E})$ are collected and formatted as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of evaluating Fourier-based reconstructions of a\n    piecewise smooth function using Gibbs and smooth-region error metrics.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    # Discretization\n    M = 4096\n    \n    # Function h(x) parameters\n    a_L = -1.0\n    a_R = 1.0\n    J = a_R - a_L\n\n    # Function g(x) parameters\n    b1 = 0.15\n    b2 = 0.10\n    kappa1 = 7.0\n    kappa2 = 13.0\n\n    # Exponential filter parameters\n    alpha = 36.0\n    p = 8.0\n\n    # Metric parameters\n    gibbs_window_half_width = 0.2\n    smooth_interval_start = 0.1 * np.pi\n    smooth_interval_end = 0.9 * np.pi\n    \n    # Test cases: (N, filter_type)\n    test_cases = [\n        (16, 'none'),\n        (16, 'exponential'),\n        (64, 'none'),\n        (64, 'exponential'),\n        (64, 'lanczos'),\n        (256, 'none'),\n        (256, 'exponential'),\n    ]\n\n    # --- Setup Grid and Exact Function ---\n    x = (2 * np.pi / M) * np.arange(M)\n\n    # h(x): piecewise constant\n    h = np.ones(M) * a_R\n    h[x < np.pi] = a_L\n\n    # g(x): smooth oscillatory part\n    g = b1 * np.sin(kappa1 * x) + b2 * np.cos(kappa2 * x)\n\n    # f(x): composite function\n    f = h + g\n\n    # --- FFT of the exact function ---\n    f_hat = np.fft.fft(f)\n    # Wavenumbers corresponding to FFT output\n    k = np.fft.fftfreq(M) * M\n\n    results = []\n\n    for N, filter_type in test_cases:\n        # --- 1. Construct the filter ---\n        sigma = np.zeros(M, dtype=float)\n        truncation_mask = np.abs(k) <= N\n        \n        if filter_type == 'none':\n            sigma[truncation_mask] = 1.0\n        \n        elif filter_type == 'exponential':\n            k_abs_in_mask = np.abs(k[truncation_mask])\n            if N > 0:\n                vals = np.exp(-alpha * (k_abs_in_mask / N)**p)\n            else: # Handle N=0 case although not in test suite\n                vals = np.array([1.0]) if 0 in k_abs_in_mask else np.array([])\n            sigma[truncation_mask] = vals\n\n        elif filter_type == 'lanczos':\n            k_abs_in_mask = np.abs(k[truncation_mask])\n            # np.sinc(x) is sin(pi*x)/(pi*x). Problem def is sin(pi*|k|/(N+1))/(pi*|k|/(N+1))\n            # so x = |k|/(N+1)\n            vals = np.sinc(k_abs_in_mask / (N + 1))\n            sigma[truncation_mask] = vals\n\n        # --- 2. Filter and Reconstruct ---\n        f_hat_filtered = f_hat * sigma\n        u = np.fft.ifft(f_hat_filtered).real\n\n        # --- 3. Compute Metrics ---\n\n        # Metric G: Gibbs Overshoot\n        window_mask = (x >= np.pi - gibbs_window_half_width) & \\\n                      (x <= np.pi + gibbs_window_half_width)\n        u_win = u[window_mask]\n        \n        max_val = np.max(u_win)\n        min_val = np.min(u_win)\n        \n        overshoot = max(0.0, max_val - a_R)\n        undershoot = max(0.0, a_L - min_val)\n        \n        G = max(overshoot, undershoot) / J\n\n        # Metric E: Smooth-region RMSE\n        smooth_mask = (x >= smooth_interval_start) & (x <= smooth_interval_end)\n        u_smooth = u[smooth_mask]\n        f_smooth = f[smooth_mask]\n        \n        E = np.sqrt(np.mean((u_smooth - f_smooth)**2))\n\n        # Store results formatted to six decimal places\n        results.append(f\"{G:.6f}\")\n        results.append(f\"{E:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Beyond simply damping oscillations, a more powerful approach is to remove the source of the Gibbs phenomenon altogether. This practice introduces the concept of jump lifting, a form of singularity subtraction where the discontinuous part of a function is explicitly represented by an analytic expression and removed before spectral approximation. By implementing this technique, you will see how transforming a discontinuous problem into a continuous one allows the Fourier series to achieve rapid, uniform convergence, effectively eliminating the Gibbs effect rather than just suppressing it. ",
            "id": "3373762",
            "problem": "Consider $2\\pi$-periodic Fourier series on the unit torus, represented as $1$-periodic functions on the interval $[0,1)$. Let $f \\in L^{2}([0,1))$ be piecewise smooth with a finite set of jump discontinuities at locations $\\{x_{j}\\}_{j=1}^{J} \\subset [0,1)$ with jump magnitudes $J_{j} = f(x_{j}^{+}) - f(x_{j}^{-})$, where $f(x_{j}^{\\pm})$ denote one-sided limits.\n\nFundamental base and definitions to be used:\n- The complex Fourier coefficients $c_{k}$ of $f$ are given by $c_{k} = \\int_{0}^{1} f(x) e^{-2\\pi i k x} \\, dx$ for all integers $k$, and $f(x)$ admits a Fourier series $f(x) \\sim \\sum_{k\\in\\mathbb{Z}} c_{k} e^{2\\pi i k x}$.\n- The truncated Fourier partial sum of order $N$ is $S_{N}[f](x) = \\sum_{k=-N}^{N} c_{k} e^{2\\pi i k x}$.\n- The Dirichlet kernel $D_{N}(x) = \\sum_{k=-N}^{N} e^{2\\pi i k x}$ governs the pointwise convergence $S_{N}[f] = D_{N} * f$, where $*$ is convolution. For piecewise smooth $f$, $S_{N}[f](x)$ converges pointwise away from jumps but exhibits the Gibbs phenomenon near jumps.\n- Define the periodic sawtooth $s(x)$ of zero mean and unit negative jump at $x=0$ by $s(x) = x - \\tfrac{1}{2}$ for $x \\in [0,1)$ and periodic extension to $\\mathbb{R}$. Then $s$ has jump $-1$ at $x \\equiv 0 \\mod 1$ and is $1$-periodic. A shift $s(x-x_{0})$ has its unit negative jump at $x=x_{0}$.\n- Given prescribed jumps $\\{(x_{j}, J_{j})\\}_{j=1}^{J}$, define the lifting function $L(x)$ by\n$$\nL(x) = - \\sum_{j=1}^{J} J_{j} \\, s(x - x_{j}),\n$$\nso that $L$ has the same jumps as $f$ at each $x_{j}$. The jump-lifted residual $f_{c}(x) := f(x) - L(x)$ is then continuous at $\\{x_{j}\\}$.\n- The endpoint correction in discontinuous Galerkin methods (DG) is conceptually analogous: the lifting operator maps interface jumps into interior corrections. Here, $L$ plays the role of a global lifting that removes endpoint and interior jumps before spectral projection.\n\nTask:\nFor each test case below, implement the following computational experiment from first principles:\n\n1) Construct $f$ explicitly on $[0,1)$ and list its jumps $\\{(x_{j}, J_{j})\\}$. Use the definitions above to form $L$ and the continuous residual $f_{c} = f - L$.\n\n2) For a given integer truncation order $N$, compute the truncated Fourier partial sums $S_{N}[f]$ and $S_{N}[f_{c}]$ on a uniform grid of $M$ points with $M$ sufficiently large. Then form the lifted reconstruction\n$$\nR_{N}(x) := S_{N}[f_{c}](x) + L(x).\n$$\n\n3) Quantify the Gibbs phenomenon and its mitigation by computing:\n- The maximal overshoot amplitude near the jumps. For each jump location $x_{j}$, let $w = \\alpha/N$ be a window half-width with $\\alpha = 4$. Define the signed periodic distance $d(x;x_{j})$ to $x_{j}$ as the unique value in $(-\\tfrac{1}{2},\\tfrac{1}{2}]$ congruent to $x-x_{j} \\mod 1$. On the left side, take points where $d(x;x_{j}) \\in [-w,0)$ and compare to the left limiting value $f(x_{j}^{-})$; on the right side, take points where $d(x;x_{j}) \\in (0,w]$ and compare to the right limiting value $f(x_{j}^{+})$. The overshoot amplitude for a reconstruction $u$ is the maximum over all jumps and sides of the absolute deviation $|u(x) - f(x_{j}^{\\pm})|$ in these windows. Compute this for $u = S_{N}[f]$ and $u = R_{N}$.\n- The root-mean-square (RMS) error away from jumps. Let the exclusion radius be $r = 3/N$. Exclude all grid points whose periodic distance to any $x_{j}$ is less than $r$, and compute the RMS error of $u - f$ over the remaining grid points, for $u = S_{N}[f]$ and $u = R_{N}$.\n\n4) For each test case, report two floats:\n- The ratio of overshoot amplitudes: $\\mathrm{ratio}_{\\mathrm{over}} = \\dfrac{\\text{overshoot of } R_{N}}{\\text{overshoot of } S_{N}[f]}$.\n- The ratio of RMS errors away from jumps: $\\mathrm{ratio}_{\\mathrm{rms}} = \\dfrac{\\|R_{N} - f\\|_{\\mathrm{RMS,away}}}{\\|S_{N}[f] - f\\|_{\\mathrm{RMS,away}}}$.\n\nNumerical requirements:\n- Use a uniform grid with $M = 65536$ points on $[0,1)$ and treat periodicity exactly.\n- Angles and phases, when needed, are in radians.\n- All constructions must respect periodicity on $[0,1)$.\n\nTest Suite:\n- Case A (interior and endpoint jumps, two-plateau): Let $a = 0.3$. Define $f(x) = 1$ for $x \\in [0,a)$ and $f(x) = -1$ for $x \\in [a,1)$. Then $J_{1} = 2$ at $x_{1} = 0$ and $J_{2} = -2$ at $x_{2} = a$. Use $N = 64$.\n- Case B (endpoint-only jump, ramp): Define $f(x) = x - \\tfrac{1}{2}$ for $x \\in [0,1)$, so there is only the endpoint jump $J_{1} = -1$ at $x_{1} = 0$. Use $N = 64$.\n- Case C (multiple interior and endpoint jumps, three-plateau): Let $a = 0.25$, $b = 0.7$ and define $f(x) = v_{0}$ for $x \\in [0,a)$, $f(x) = v_{1}$ for $x \\in [a,b)$, and $f(x) = v_{2}$ for $x \\in [b,1)$ with $v_{0} = 1$, $v_{1} = -0.5$, $v_{2} = 0.3$. The jumps are $J_{1} = v_{0} - v_{2}$ at $x_{1} = 0$, $J_{2} = v_{1} - v_{0}$ at $x_{2} = a$, and $J_{3} = v_{2} - v_{1}$ at $x_{3} = b$. Use $N = 32$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the six floats\n$[\\mathrm{ratio}_{\\mathrm{over}}^{A},\\mathrm{ratio}_{\\mathrm{rms}}^{A},\\mathrm{ratio}_{\\mathrm{over}}^{B},\\mathrm{ratio}_{\\mathrm{rms}}^{B},\\mathrm{ratio}_{\\mathrm{over}}^{C},\\mathrm{ratio}_{\\mathrm{rms}}^{C}]$\nas a comma-separated list enclosed in square brackets (e.g., $[0.12,0.03,0.00001,0.00001,0.2,0.1]$). No other text should be printed.",
            "solution": "The user-provided problem is a well-posed computational task in the field of numerical analysis, specifically concerning the convergence characteristics of Fourier series for discontinuous functions. The problem is scientifically grounded, requires no external information, and its instructions are clear and unambiguous. A solution can be constructed by directly implementing the specified procedures. The problem is declared **valid**.\n\nThe core of this problem lies in understanding and mitigating the Gibbs phenomenon, a persistent oscillatory artifact that arises when using a truncated Fourier series, $S_{N}[f](x)$, to approximate a piecewise smooth function $f(x)$ near its jump discontinuities. For a function with a jump of magnitude $J$ at a point $x_j$, the partial sum $S_N[f]$ will exhibit an overshoot and undershoot in the vicinity of $x_j$. As the number of modes $N$ increases, this oscillation localizes closer to the jump, but its amplitude does not decrease. The maximum overshoot converges to a fixed fraction of the jump magnitude, approximately $9\\%$, specifically $\\frac{J}{\\pi} \\int_{0}^{\\pi} \\frac{\\sin(t)}{t} dt - \\frac{J}{2} \\approx 0.08949 J$. This slow, non-uniform convergence significantly degrades the quality of the Fourier approximation.\n\nThe proposed mitigation strategy is based on the principle of \"regularization by lifting.\" The key insight is that the Gibbs phenomenon is a direct consequence of approximating a discontinuity with a basis of globally smooth functions (complex exponentials). If we can remove the discontinuities from the target function *before* approximation, the remaining continuous part can be represented much more accurately by a truncated Fourier series.\n\nThis procedure unfolds as follows:\n\n1.  **Jump Identification and Lifting**: For a given piecewise smooth function $f(x)$ on $[0,1)$, we first identify its jump discontinuities. A jump at position $x_j$ is characterized by its magnitude $J_j = f(x_j^+) - f(x_j^-)$, where $f(x_j^\\pm)$ are the one-sided limits. A special \"lifting\" function, $L(x)$, is constructed to have precisely the same jump structure as $f(x)$. The problem provides the form for $L(x)$ based on the periodic sawtooth function $s(x) = x - \\frac{1}{2}$ for $x \\in [0,1)$:\n    $$\n    L(x) = - \\sum_{j=1}^{J} J_{j} \\, s(x - x_{j})\n    $$\n    The jump of the term $-J_j s(x-x_j)$ at $x=x_j$ is $-J_j \\times (\\text{jump of } s(x) \\text{ at } 0) = -J_j \\times (-1) = J_j$. Since other terms are continuous at $x_j$, the total jump of $L(x)$ at $x_j$ is $J_j$, matching that of $f(x)$.\n\n2.  **Formation of a Continuous Residual**: By subtracting the lifting function from the original function, we create a \"jump-lifted residual\" $f_c(x)$:\n    $$\n    f_c(x) := f(x) - L(x)\n    $$\n    By construction, the jump of $f_c(x)$ at each $x_j$ is $\\text{jump}(f) - \\text{jump}(L) = J_j - J_j = 0$. Thus, $f_c(x)$ is continuous everywhere, and if $f(x)$ is piecewise smooth, $f_c(x)$ will be at least continuous and piecewise smooth, possibly smoother.\n\n3.  **Spectral Approximation**: We can now compute the truncated Fourier series of this continuous residual, $S_N[f_c](x)$. Because $f_c(x)$ is continuous, its Fourier coefficients decay much faster than those of the original discontinuous function $f(x)$, and its partial sum $S_N[f_c](x)$ converges much more rapidly and uniformly, free of the Gibbs phenomenon.\n\n4.  **Lifted Reconstruction**: The final, improved approximation for $f(x)$, denoted $R_N(x)$, is formed by adding the lifting function back to the approximation of the residual:\n    $$\n    R_{N}(x) := S_{N}[f_{c}](x) + L(x)\n    $$\n    The rationale is that since $S_N[f_c](x)$ is a very good approximation of $f_c(x)$, then $R_N(x) \\approx f_c(x) + L(x) = (f(x) - L(x)) + L(x) = f(x)$. This reconstruction elegantly localizes all discontinuities within the analytically known function $L(x)$, which is added back *after* the spectral projection step, thereby circumventing the source of the Gibbs phenomenon.\n\nThe computational experiment requested involves implementing this procedure and quantifying its effectiveness. For each test case, we perform the following steps on a fine uniform grid of $M$ points on $[0,1)$:\n\n1.  Construct the discrete representations of $f(x)$, its jumps $\\{(x_j, J_j, f(x_j^-), f(x_j^+))\\}$, and the corresponding lifting function $L(x)$. Form the continuous residual $f_c(x) = f(x) - L(x)$.\n\n2.  Compute the standard Fourier partial sum $S_N[f]$ and the residual partial sum $S_N[f_c]$. This is done efficiently using the Fast Fourier Transform (FFT). The Fourier series truncated to modes $|k| \\le N$ is calculated by:\n    a. Computing the Discrete Fourier Transform (DFT) of the function samples using `fft`.\n    b. Setting all frequency components corresponding to modes $|k| > N$ to zero.\n    c. Computing the Inverse Discrete Fourier Transform (IDFT) of the filtered coefficients using `ifft`.\n    The lifted reconstruction is then $R_N(x) = S_N[f_c](x) + L(x)$.\n\n3.  Quantify the error for both the standard reconstruction $S_N[f]$ and the lifted reconstruction $R_N$. Two metrics are used:\n    - **Maximal Overshoot Amplitude**: This measures the peak deviation from the true limiting values, $f(x_j^\\pm)$, in a small window of half-width $w = 4/N$ around each jump. This directly quantifies the Gibbs phenomenon.\n    - **Root-Mean-Square (RMS) Error Away from Jumps**: This measures the average approximation error on the parts of the domain that are not immediately adjacent to the jumps, specifically outside an exclusion radius $r = 3/N$ around each discontinuity. This quantifies the overall convergence quality in the \"smooth\" regions.\n\n4.  Finally, the ratios of these error metrics, $\\mathrm{ratio}_{\\mathrm{over}}$ and $\\mathrm{ratio}_{\\mathrm{rms}}$, are computed to provide a normalized measure of the improvement gained by the lifting technique. A ratio significantly less than $1$ indicates a substantial improvement.\n\nThis procedure is systematically applied to the three test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment for all test cases.\n    \"\"\"\n    \n    # Global numerical parameters\n    M = 65536  # Number of grid points\n    \n    # Test cases definition\n    test_cases = [\n        # Case A: Two-plateau function\n        {\n            \"name\": \"Case A\",\n            \"N\": 64,\n            \"f_def\": lambda x, a=0.3: np.where(x < a, 1.0, -1.0),\n            \"jumps\": [\n                # (xj, Jj, f(xj-), f(xj+))\n                (0.0, 2.0, -1.0, 1.0),\n                (0.3, -2.0, 1.0, -1.0)\n            ],\n        },\n        # Case B: Sawtooth function (ramp)\n        {\n            \"name\": \"Case B\",\n            \"N\": 64,\n            \"f_def\": lambda x: x - 0.5,\n            \"jumps\": [\n                (0.0, -1.0, 0.5, -0.5)\n            ],\n        },\n        # Case C: Three-plateau function\n        {\n            \"name\": \"Case C\",\n            \"N\": 32,\n            \"f_def\": lambda x, a=0.25, b=0.7, v0=1.0, v1=-0.5, v2=0.3: \\\n                np.select([x < a, (x >= a) & (x < b), x >= b], [v0, v1, v2]),\n            \"jumps\": [\n                (0.0, 0.7, 0.3, 1.0),       # J1 = v0 - v2\n                (0.25, -1.5, 1.0, -0.5),   # J2 = v1 - v0\n                (0.7, 0.8, -0.5, 0.3)        # J3 = v2 - v1\n            ],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        ratios = process_case(M, case['N'], case['f_def'], case['jumps'])\n        results.extend(ratios)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(M, N, f_def, jumps):\n    \"\"\"\n    Processes a single test case and returns the error ratios.\n    \"\"\"\n\n    # 1. Grid and function setup\n    x = np.arange(M) / M\n    f_vals = f_def(x)\n\n    # 2. Construct the lifting function L(x)\n    L_vals = np.zeros(M)\n    for xj, Jj, _, _ in jumps:\n        # Periodic sawtooth: s(y) = y - 0.5 for y in [0,1)\n        # s(x - xj) evaluated on the grid\n        shifted_x_mod1 = (x - xj + 1.0) % 1.0\n        sawtooth_vals = shifted_x_mod1 - 0.5\n        L_vals -= Jj * sawtooth_vals\n\n    # 3. Form the continuous residual f_c = f - L\n    fc_vals = f_vals - L_vals\n\n    # 4. Compute Fourier partial sums using FFT\n    k_modes = np.fft.fftfreq(M, d=1.0/M)\n    mask_N = np.abs(k_modes) <= N\n    \n    # S_N[f]\n    F_f = np.fft.fft(f_vals)\n    F_f_trunc = F_f * mask_N\n    SN_f = np.real(np.fft.ifft(F_f_trunc))\n    \n    # S_N[f_c]\n    F_fc = np.fft.fft(fc_vals)\n    F_fc_trunc = F_fc * mask_N\n    SN_fc = np.real(np.fft.ifft(F_fc_trunc))\n    \n    # 5. Form the lifted reconstruction R_N\n    R_N = SN_fc + L_vals\n\n    # 6. Quantify errors\n    overshoot_SN, rms_SN = calculate_errors(SN_f, f_vals, jumps, N, x, M)\n    overshoot_RN, rms_RN = calculate_errors(R_N, f_vals, jumps, N, x, M)\n\n    # 7. Compute ratios\n    # Handle the case where the denominator is zero (perfect reconstruction)\n    ratio_over = 0.0 if overshoot_SN == 0 else overshoot_RN / overshoot_SN\n    ratio_rms = 0.0 if rms_SN == 0 else rms_RN / rms_SN\n\n    return ratio_over, ratio_rms\n\ndef periodic_dist(x, x0):\n    \"\"\"\n    Computes the signed periodic distance from points x to x0 on the torus [0,1).\n    The result lies in [-0.5, 0.5).\n    \"\"\"\n    d = x - x0\n    return (d + 0.5) % 1.0 - 0.5\n\ndef calculate_errors(u, f, jumps, N, x, M):\n    \"\"\"\n    Calculates overshoot and RMS error for a given reconstruction u.\n    \"\"\"\n    # ----- Overshoot calculation -----\n    w = 4.0 / N\n    max_overshoot = 0.0\n    \n    for xj, _, f_minus, f_plus in jumps:\n        dist_from_jump = periodic_dist(x, xj)\n        \n        # Left side window: [-w, 0)\n        left_mask = (dist_from_jump >= -w) & (dist_from_jump < 0)\n        if np.any(left_mask):\n            dev_left = np.max(np.abs(u[left_mask] - f_minus))\n            max_overshoot = max(max_overshoot, dev_left)\n            \n        # Right side window: (0, w]\n        right_mask = (dist_from_jump > 0) & (dist_from_jump <= w)\n        if np.any(right_mask):\n            dev_right = np.max(np.abs(u[right_mask] - f_plus))\n            max_overshoot = max(max_overshoot, dev_right)\n\n    # ----- RMS error away from jumps -----\n    r = 3.0 / N\n    away_mask = np.ones(M, dtype=bool)\n    \n    for xj, _, _, _ in jumps:\n        dist_from_jump = np.abs(periodic_dist(x, xj))\n        away_mask &= (dist_from_jump >= r)\n    \n    error_vals = u - f\n    \n    # Ensure there are points in the 'away' region to avoid division by zero\n    if np.sum(away_mask) > 0:\n        rms_error = np.sqrt(np.mean(error_vals[away_mask]**2))\n    else:\n        # This case is unlikely but handled for robustness\n        rms_error = 0.0\n        \n    return max_overshoot, rms_error\n\n# Run the main solver function\nsolve()\n```"
        }
    ]
}