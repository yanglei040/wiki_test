{
    "hands_on_practices": [
        {
            "introduction": "本次实践的核心挑战在于如何区分信号中虚假的吉布斯现象与真实的物理振荡。我们将对一个同时包含跳变间断点和平滑波动部分的函数，应用并比较不同的谱滤波器（如截断、指数和 Lanczos 滤波器）。通过量化诊断来评估滤波器的性能，学生将学会如何抑制伪影，同时努力保留信号中的重要特征。",
            "id": "3373741",
            "problem": "考虑在区间 $[0,2\\pi)$（角度以弧度为单位）上的 $2\\pi$-周期函数 $f(x)$，该函数由一个跳跃和一个光滑振荡部分组成。设 $a_L=-1$ 和 $a_R=1$，并定义分段常数函数 $h(x)$ 为：当 $x\\in[0,\\pi)$ 时 $h(x)=a_L$，当 $x\\in[\\pi,2\\pi)$ 时 $h(x)=a_R$。设光滑振荡分量为 $g(x)=b_1\\sin(\\kappa_1 x)+b_2\\cos(\\kappa_2 x)$，其中 $b_1=0.15$，$b_2=0.10$，$\\kappa_1=7$，$\\kappa_2=13$。目标函数为 $f(x)=h(x)+g(x)$。跳跃点集是单点集 $\\{x=\\pi\\}$，跳跃高度为 $J=a_R-a_L=2$。\n\n您将使用离散傅里叶变换，在一个包含 $M=4096$ 个等距点 $x_j=\\frac{2\\pi j}{M}$（其中 $j=0,1,\\dots,M-1$）的均匀网格上，通过截断傅里叶级数来近似 $f(x)$。设 $\\widehat{f}_k$ 是通过标准快速傅里叶变换 (FFT) 约定得到的离散傅里叶系数，其中正变换是离散求和，逆变换包含因子 $1/M$。一个截断数为 $N$ 的截断谱近似是通过保留 $|k|\\le N$ 的傅里叶模态并将 $|k|N$ 的模态置零来构造的。为了研究未滤波和滤波后的重构，引入谱乘子（滤波器）$\\sigma(|k|)$，它作用于 $|k|\\le N$ 的保留模态上：\n- 无滤波器：当 $|k|\\le N$ 时，$\\sigma(|k|)=1$；当 $|k|N$ 时，$\\sigma(|k|)=0$。\n- 指数滤波器：对于参数 $\\alpha=36$ 和 $p=8$，定义当 $|k|\\le N$ 时，$\\sigma(|k|)=\\exp\\!\\big(-\\alpha \\, (|k|/N)^p\\big)$；当 $|k|N$ 时，$\\sigma(|k|)=0$。\n- Lanczos 滤波器：定义 $\\sigma(0)=1$；当 $1\\le |k|\\le N$ 时，设 $\\sigma(|k|)=\\dfrac{\\sin\\!\\big(\\pi |k|/(N+1)\\big)}{\\pi |k|/(N+1)}$；当 $|k|N$ 时，$\\sigma(|k|)=0$。\n\n从基本原理的角度，您必须使用以下基础和定义：\n- 一个 $2\\pi$-周期函数 $f(x)$ 的傅里叶级数具有复系数 $a_k$，定义为 $a_k=\\frac{1}{2\\pi}\\int_{0}^{2\\pi} f(x)\\,e^{-ikx}\\,dx$，其第 $N$ 部分和为 $S_N f(x)=\\sum_{k=-N}^{N} a_k e^{ikx}$。\n- 在均匀网格上使用梯形法则计算的离散傅里叶变换，对于足够光滑的 $f(x)$，能一致地近似连续傅里叶系数；而对于分段光滑的 $f(x)$，截断重构在跳跃点附近表现出吉布斯现象 (Gibbs phenomenon)。\n- 吉布斯现象指的是 $S_N f(x)$ 在间断点附近出现的不会消失的过冲和振荡，其振幅不随 $N\\to\\infty$ 而减小，尽管它们会变得更加局部化。\n- 谱滤波器是应用于傅里叶系数的光滑乘子 $\\sigma(|k|)$，用以衰减高频模态并减少伪振荡，同时力求保留远离跳跃点的光滑特征。这一范式与高阶谱方法和间断伽辽金 (DG) 方法中使用的稳定化技术是共通的。\n\n您的任务是实现一个诊断工具，通过两个定量度量来分离吉布斯振荡（伪振荡）和真实的光滑振荡（物理振荡）。这两个度量从通过对滤波后的系数进行逆变换得到的重构 $u_{N,\\sigma}(x)$ 计算得出：\n- 跳跃点附近的归一化吉布斯过冲：在跳跃位置 $x=\\pi$ 周围选择一个半宽为 $w=0.2$ 的对称窗口。设 $U_\\text{win}$ 为该窗口内 $x\\in[\\pi-w,\\pi+w]$ 的重构值 $u_{N,\\sigma}(x)$ 的集合。定义正过冲为 $\\max\\{0,\\max U_\\text{win}-\\max(a_L,a_R)\\}$，负下冲为 $\\max\\{0,\\min(a_L,a_R)-\\min U_\\text{win}\\}$。吉布斯度量为 $\\mathcal{G}=\\max\\{\\text{overshoot},\\text{undershoot}\\}/J$，是一个在 $[0,\\infty)$ 区间内的无量纲浮点数。\n- 光滑区域均方根误差：在不含跳跃点的区间 $I=[0.1\\pi,0.9\\pi]$ 上，使用位于 $I$ 内的均匀网格点，计算 $u_{N,\\sigma}(x)$ 与精确函数 $f(x)$ 之间的离散均方根误差。将此度量记为 $\\mathcal{E}$，是一个在 $[0,\\infty)$ 区间内的浮点数。\n\n基于上述定义的解释指南：如果 $\\mathcal{G}$ 保持显著而 $\\mathcal{E}$ 很小，则 $x=\\pi$ 附近的振荡主要由吉布斯效应引起。如果一个合适的滤波器在不显著增加 $\\mathcal{E}$ 的情况下减小了 $\\mathcal{G}$，则该滤波器有效地抑制了伪振荡，同时保留了真实的光滑振荡。\n\n您的程序必须使用上述精确的滤波器，通过 FFT 实现谱截断和滤波，为每个测试案例计算这两个度量，并输出它们的值。\n\n测试套件。使用以下七个测试案例，每个案例由截断数 $N$ 和滤波器类型指定：\n- 案例 1：$N=16$，滤波器类型 = 无。\n- 案例 2：$N=16$，滤波器类型 = 指数。\n- 案例 3：$N=64$，滤波器类型 = 无。\n- 案例 4：$N=64$，滤波器类型 = 指数。\n- 案例 5：$N=64$，滤波器类型 = Lanczos。\n- 案例 6：$N=256$，滤波器类型 = 无。\n- 案例 7：$N=256$，滤波器类型 = 指数。\n\n角度单位是弧度。没有物理单位。\n\n最终输出格式要求。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含每个测试案例的浮点数对 $(\\mathcal{G},\\mathcal{E})$，格式化为六位小数，并按给定顺序连接所有案例的结果。例如，一个包含三个案例的输出应形如 $[\\mathcal{G}_1,\\mathcal{E}_1,\\mathcal{G}_2,\\mathcal{E}_2,\\mathcal{G}_3,\\mathcal{E}_3]$。对于本问题中的七个案例，输出因此必须在单行上总共包含 $14$ 个浮点数，且无任何附加文本。",
            "solution": "该问题是有效的。这是一个适定且有科学依据的数值分析练习，具体涉及通过截断和滤波的傅里叶级数来近似不连续函数。所有参数、函数和度量都得到了明确的定义，从而可以得到唯一且可验证的数值解。该问题正确地将任务置于谱方法和缓解吉布斯现象的框架内。\n\n求解方法如下：\n\n首先，我们建立计算域和待近似的函数。在区间 $[0, 2\\pi)$ 上定义一个包含 $M=4096$ 个点的均匀网格，$x_j = \\frac{2\\pi j}{M}$，其中 $j=0, 1, \\dots, M-1$。在此网格上，我们对目标函数 $f(x) = h(x) + g(x)$ 进行采样。函数 $h(x)$ 是一个分段常数阶跃函数，定义为\n$$\nh(x) = \\begin{cases} a_L = -1  \\text{若 } x \\in [0, \\pi) \\\\ a_R = 1  \\text{若 } x \\in [\\pi, 2\\pi) \\end{cases}\n$$\n光滑分量 $g(x)$ 由下式给出\n$$\ng(x) = b_1\\sin(\\kappa_1 x) + b_2\\cos(\\kappa_2 x)\n$$\n其中常数 $b_1=0.15$，$b_2=0.10$，$\\kappa_1=7$，$\\kappa_2=13$。然后，在每个网格点 $x_j$ 上计算复合函数 $f(x)$ 的值。\n\n接下来，我们计算采样函数 $f(x_j)$ 的离散傅里叶变换 (DFT)。离散傅里叶系数 $\\widehat{f}_k$ 通过快速傅里叶变换 (FFT) 算法获得。设 $\\{f_j\\}_{j=0}^{M-1}$ 为采样函数值的集合。正变换为 $\\widehat{f}_k = \\sum_{j=0}^{M-1} f_j e^{-i 2\\pi jk/M}$。用于重构信号的逆变换为 $f_j = \\frac{1}{M} \\sum_{k=0}^{M-1} \\widehat{f}_k e^{i 2\\pi jk/M}$。此约定与 NumPy 等标准数值库一致。FFT 输出的整数索引 $k$ 对应于波数；对于 $[0, 2\\pi)$ 上的信号，波数为整数。我们可以将 FFT 索引 $k \\in \\{0, \\dots, M-1\\}$ 映射到物理波数，后者约等于 $[0, \\dots, M/2-1, -M/2, \\dots, -1]$。\n\n对于每个由截断数 $N$ 和滤波器类型指定的测试案例，我们构造一个谱乘子（滤波器）数组 $\\sigma_k$。该数组逐元素地应用于计算出的傅里叶系数 $\\widehat{f}_k$。滤波器根据波数 $|k|$ 和截断数 $N$ 定义。\n1.  **无滤波器（仅截断）**：这等效于在傅里叶空间中应用一个锐利谱滤波器或矩形窗。\n    $$\n    \\sigma_k = \\begin{cases} 1  \\text{若 } |k| \\le N \\\\ 0  \\text{若 } |k|  N \\end{cases}\n    $$\n2.  **指数滤波器**：这是一种对高波数快速衰减的光滑滤波器。对于参数 $\\alpha=36$ 和 $p=8$，其定义为：\n    $$\n    \\sigma_k = \\begin{cases} \\exp\\left(-\\alpha \\left(\\frac{|k|}{N}\\right)^p\\right)  \\text{若 } |k| \\le N \\\\ 0  \\text{若 } |k|  N \\end{cases}\n    $$\n    该滤波器保留低频模态，并将高频模态平滑地衰减至零，从而减少吉布斯现象。\n3.  **Lanczos 滤波器**：此滤波器源自 sinc 函数。\n    $$\n    \\sigma_k = \\begin{cases} \\dfrac{\\sin(\\pi |k|/(N+1))}{\\pi |k|/(N+1)}  \\text{若 } 1 \\le |k| \\le N \\\\ 1  \\text{若 } k=0 \\\\ 0  \\text{若 } |k|  N \\end{cases}\n    $$\n    注意，$\\lim_{z\\to 0} \\frac{\\sin(\\pi z)}{\\pi z} = 1$，因此该公式在 $k=0$ 处有良好定义。\n\n滤波后的系数计算为 $\\widehat{u}_k = \\widehat{f}_k \\cdot \\sigma_k$。然后，通过对滤波后的系数 $\\widehat{u}_k$ 应用逆 FFT，得到网格上的重构函数 $u_{N,\\sigma}(x_j)$。由于原始函数 $f(x)$ 是实值的，重构函数 $u_{N,\\sigma}(x)$ 也应为实数，因此我们取逆 FFT 输出的实部，并丢弃由数值浮点误差产生的任何微小的虚部。\n\n最后，我们为每个重构计算两个诊断度量。\n-   **吉布斯度量 $\\mathcal{G}$**：该度量量化了间断点 $x=\\pi$ 附近的过冲/下冲。我们找出窗口 $[\\pi - w, \\pi + w]$ 内的所有网格点 $x_j$，其中 $w=0.2$。设 $U_\\text{win}$ 为这些点上重构值 $u_{N,\\sigma}(x_j)$ 的集合。过冲为 $\\max\\{0, \\max(U_\\text{win}) - a_R\\}$，下冲为 $\\max\\{0, a_L - \\min(U_\\text{win})\\}$，因为 $a_R = \\max(a_L, a_R) = 1$ 且 $a_L = \\min(a_L, a_R) = -1$。该度量即为这两个值的归一化最大值：$\\mathcal{G} = \\frac{\\max\\{\\text{overshoot}, \\text{undershoot}\\}}{J}$，其中跳跃高度 $J=a_R-a_L=2$。\n\n-   **光滑区域误差 $\\mathcal{E}$**：该度量衡量了在远离间断点的区域内重构的准确性。我们选择不含跳跃点的区间 $I=[0.1\\pi, 0.9\\pi]$。我们找出位于此区间内的所有网格点 $x_j$。度量 $\\mathcal{E}$ 是这些点上重构值 $u_{N,\\sigma}(x_j)$ 和精确值 $f(x_j)$ 之间的离散均方根误差 (RMSE)：\n$$\n\\mathcal{E} = \\sqrt{\\frac{1}{N_I} \\sum_{x_j \\in I} (u_{N,\\sigma}(x_j) - f(x_j))^2}\n$$\n其中 $N_I$ 是区间 $I$ 内的网格点数。\n\n对七个测试案例中的每一个重复此完整过程，并收集所得的度量对 $(\\mathcal{G}, \\mathcal{E})$，按要求格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of evaluating Fourier-based reconstructions of a\n    piecewise smooth function using Gibbs and smooth-region error metrics.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    # Discretization\n    M = 4096\n    \n    # Function h(x) parameters\n    a_L = -1.0\n    a_R = 1.0\n    J = a_R - a_L\n\n    # Function g(x) parameters\n    b1 = 0.15\n    b2 = 0.10\n    kappa1 = 7.0\n    kappa2 = 13.0\n\n    # Exponential filter parameters\n    alpha = 36.0\n    p = 8.0\n\n    # Metric parameters\n    gibbs_window_half_width = 0.2\n    smooth_interval_start = 0.1 * np.pi\n    smooth_interval_end = 0.9 * np.pi\n    \n    # Test cases: (N, filter_type)\n    test_cases = [\n        (16, 'none'),\n        (16, 'exponential'),\n        (64, 'none'),\n        (64, 'exponential'),\n        (64, 'lanczos'),\n        (256, 'none'),\n        (256, 'exponential'),\n    ]\n\n    # --- Setup Grid and Exact Function ---\n    x = (2 * np.pi / M) * np.arange(M)\n\n    # h(x): piecewise constant\n    h = np.ones(M) * a_R\n    h[x  np.pi] = a_L\n\n    # g(x): smooth oscillatory part\n    g = b1 * np.sin(kappa1 * x) + b2 * np.cos(kappa2 * x)\n\n    # f(x): composite function\n    f = h + g\n\n    # --- FFT of the exact function ---\n    f_hat = np.fft.fft(f)\n    # Wavenumbers corresponding to FFT output\n    k = np.fft.fftfreq(M) * M\n\n    results = []\n\n    for N, filter_type in test_cases:\n        # --- 1. Construct the filter ---\n        sigma = np.zeros(M, dtype=float)\n        truncation_mask = np.abs(k) = N\n        \n        if filter_type == 'none':\n            sigma[truncation_mask] = 1.0\n        \n        elif filter_type == 'exponential':\n            k_abs_in_mask = np.abs(k[truncation_mask])\n            if N > 0:\n                vals = np.exp(-alpha * (k_abs_in_mask / N)**p)\n            else: # Handle N=0 case although not in test suite\n                vals = np.array([1.0]) if 0 in k_abs_in_mask else np.array([])\n            sigma[truncation_mask] = vals\n\n        elif filter_type == 'lanczos':\n            k_abs_in_mask = np.abs(k[truncation_mask])\n            # np.sinc(x) is sin(pi*x)/(pi*x). Problem def is sin(pi*|k|/(N+1))/(pi*|k|/(N+1))\n            # so x = |k|/(N+1)\n            vals = np.sinc(k_abs_in_mask / (N + 1))\n            sigma[truncation_mask] = vals\n\n        # --- 2. Filter and Reconstruct ---\n        f_hat_filtered = f_hat * sigma\n        u = np.fft.ifft(f_hat_filtered).real\n\n        # --- 3. Compute Metrics ---\n\n        # Metric G: Gibbs Overshoot\n        window_mask = (x >= np.pi - gibbs_window_half_width)  \\\n                      (x = np.pi + gibbs_window_half_width)\n        u_win = u[window_mask]\n        \n        max_val = np.max(u_win)\n        min_val = np.min(u_win)\n        \n        overshoot = max(0.0, max_val - a_R)\n        undershoot = max(0.0, a_L - min_val)\n        \n        G = max(overshoot, undershoot) / J\n\n        # Metric E: Smooth-region RMSE\n        smooth_mask = (x >= smooth_interval_start)  (x = smooth_interval_end)\n        u_smooth = u[smooth_mask]\n        f_smooth = f[smooth_mask]\n        \n        E = np.sqrt(np.mean((u_smooth - f_smooth)**2))\n\n        # Store results formatted to six decimal places\n        results.append(f\"{G:.6f}\")\n        results.append(f\"{E:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在简单滤波的基础上，本次实践将介绍一种更强大的消除吉布斯现象的技术：奇异点减除法，也称为“提升法”。学生将实现一种方法，构造一个解析函数来精确匹配目标函数的间断特性。通过对余下的光滑残差进行傅里叶逼近，本练习展示了如何实现高阶精度并从根本上消除吉布斯振荡。",
            "id": "3373762",
            "problem": "考虑单位环面上的 $2\\pi$-周期傅里叶级数，表示为区间 $[0,1)$ 上的 $1$-周期函数。设 $f \\in L^{2}([0,1))$ 是分段光滑的，在位置 $\\{x_{j}\\}_{j=1}^{J} \\subset [0,1)$ 处有有限个跳跃间断点，其跳跃幅度为 $J_{j} = f(x_{j}^{+}) - f(x_{j}^{-})$，其中 $f(x_{j}^{\\pm})$ 表示单侧极限。\n\n将使用的基本基底和定义：\n- $f$ 的复傅里叶系数 $c_{k}$ 由 $c_{k} = \\int_{0}^{1} f(x) e^{-2\\pi i k x} \\, dx$ 给出，适用于所有整数 $k$，且 $f(x)$ 具有傅里叶级数 $f(x) \\sim \\sum_{k\\in\\mathbb{Z}} c_{k} e^{2\\pi i k x}$。\n- $N$ 阶截断傅里叶部分和为 $S_{N}[f](x) = \\sum_{k=-N}^{N} c_{k} e^{2\\pi i k x}$。\n- Dirichlet 核 $D_{N}(x) = \\sum_{k=-N}^{N} e^{2\\pi i k x}$ 控制逐点收敛 $S_{N}[f] = D_{N} * f$，其中 $*$ 是卷积。对于分段光滑的 $f$，$S_{N}[f](x)$ 在远离跳跃点处逐点收敛，但在跳跃点附近表现出吉布斯现象 (Gibbs phenomenon)。\n- 定义周期性锯齿波函数 $s(x)$，其均值为零，在 $x=0$ 处有单位负跳跃，由 $s(x) = x - \\tfrac{1}{2}$（对于 $x \\in [0,1)$）并周期性延拓至 $\\mathbb{R}$ 给出。那么 $s$ 在 $x \\equiv 0 \\mod 1$ 处有 $-1$ 的跳跃，并且是 $1$-周期的。平移 $s(x-x_{0})$ 将其单位负跳跃置于 $x=x_{0}$ 处。\n- 给定预设的跳跃 $\\{(x_{j}, J_{j})\\}_{j=1}^{J}$，定义提升函数 $L(x)$ 为\n$$\nL(x) = - \\sum_{j=1}^{J} J_{j} \\, s(x - x_{j}),\n$$\n使得 $L$ 在每个 $x_{j}$ 处具有与 $f$ 相同的跳跃。跳跃提升后的残差 $f_{c}(x) := f(x) - L(x)$ 则在 $\\{x_{j}\\}$ 处是连续的。\n- 间断 Galerkin 方法 (DG) 中的端点修正在概念上是类似的：提升算子将界面跳跃映射到内部修正。在这里，$L$ 扮演一个全局提升的角色，在进行谱投影之前移除端点和内部的跳跃。\n\n任务：\n对于下方的每个测试用例，从基本原理出发，实现以下计算实验：\n\n1) 在 $[0,1)$ 上显式构造 $f$，并列出其跳跃 $\\{(x_{j}, J_{j})\\}$。使用上述定义构建 $L$ 和连续残差 $f_{c} = f - L$。\n\n2) 对于给定的整数截断阶数 $N$，在具有足够大数量 $M$ 个点的均匀网格上，计算截断傅里叶部分和 $S_{N}[f]$ 和 $S_{N}[f_{c}]$。然后构建提升重构\n$$\nR_{N}(x) := S_{N}[f_{c}](x) + L(x).\n$$\n\n3) 通过计算以下内容来量化吉布斯现象及其缓解效果：\n- 跳跃点附近的最大过冲幅度。对于每个跳跃位置 $x_{j}$，令 $w = \\alpha/N$ 为窗口半宽度，其中 $\\alpha = 4$。定义到 $x_{j}$ 的有符号周期距离 $d(x;x_{j})$ 为与 $x-x_{j} \\mod 1$ 同余的在 $(-\\tfrac{1}{2},\\tfrac{1}{2}]$ 内的唯一值。在左侧，取点满足 $d(x;x_{j}) \\in [-w,0)$ 并与左极限值 $f(x_{j}^{-})$ 比较；在右侧，取点满足 $d(x;x_{j}) \\in (0,w]$ 并与右极限值 $f(x_{j}^{+})$ 比较。对于一个重构 $u$，其过冲幅度是在这些窗口中，对所有跳跃点和两侧计算的绝对偏差 $|u(x) - f(x_{j}^{\\pm})|$ 的最大值。为 $u = S_{N}[f]$ 和 $u = R_{N}$ 计算此值。\n- 远离跳跃点的均方根 (RMS) 误差。令排除半径为 $r = 3/N$。排除所有到任一 $x_{j}$ 的周期距离小于 $r$ 的网格点，并在剩余的网格点上计算 $u - f$ 的 RMS 误差，其中 $u = S_{N}[f]$ 和 $u = R_{N}$。\n\n4) 对于每个测试用例，报告两个浮点数：\n- 过冲幅度的比率：$\\mathrm{ratio}_{\\mathrm{over}} = \\dfrac{\\text{overshoot of } R_{N}}{\\text{overshoot of } S_{N}[f]}$。\n- 远离跳跃点的 RMS 误差的比率：$\\mathrm{ratio}_{\\mathrm{rms}} = \\dfrac{\\|R_{N} - f\\|_{\\mathrm{RMS,away}}}{\\|S_{N}[f] - f\\|_{\\mathrm{RMS,away}}}$。\n\n数值要求：\n- 使用在 $[0,1)$ 上的 $M = 65536$ 个点的均匀网格，并精确处理周期性。\n- 当需要时，角度和相位以弧度为单位。\n- 所有构造都必须遵循在 $[0,1)$ 上的周期性。\n\n测试套件：\n- 用例 A（内部和端点跳跃，双平台）：令 $a = 0.3$。定义当 $x \\in [0,a)$ 时 $f(x) = 1$，当 $x \\in [a,1)$ 时 $f(x) = -1$。那么在 $x_{1} = 0$ 处 $J_{1} = 2$，在 $x_{2} = a$ 处 $J_{2} = -2$。使用 $N = 64$。\n- 用例 B（仅端点跳跃，斜坡）：定义当 $x \\in [0,1)$ 时 $f(x) = x - \\tfrac{1}{2}$，因此仅在 $x_{1} = 0$ 处有端点跳跃 $J_{1} = -1$。使用 $N = 64$。\n- 用例 C（多个内部和端点跳跃，三平台）：令 $a = 0.25$，$b = 0.7$ 并定义当 $x \\in [0,a)$ 时 $f(x) = v_{0}$，当 $x \\in [a,b)$ 时 $f(x) = v_{1}$，当 $x \\in [b,1)$ 时 $f(x) = v_{2}$，其中 $v_{0} = 1$，$v_{1} = -0.5$，$v_{2} = 0.3$。跳跃点为：在 $x_{1} = 0$ 处 $J_{1} = v_{0} - v_{2}$，在 $x_{2} = a$ 处 $J_{2} = v_{1} - v_{0}$，在 $x_{3} = b$ 处 $J_{3} = v_{2} - v_{1}$。使用 $N = 32$。\n\n最终输出格式：\n您的程序应生成单行输出，包含六个浮点数\n$[\\mathrm{ratio}_{\\mathrm{over}}^{A},\\mathrm{ratio}_{\\mathrm{rms}}^{A},\\mathrm{ratio}_{\\mathrm{over}}^{B},\\mathrm{ratio}_{\\mathrm{rms}}^{B},\\mathrm{ratio}_{\\mathrm{over}}^{C},\\mathrm{ratio}_{\\mathrm{rms}}^{C}]$\n以逗号分隔的列表形式，并用方括号括起来（例如，$[0.12,0.03,0.00001,0.00001,0.2,0.1]$）。不应打印任何其他文本。",
            "solution": "用户提供的问题是数值分析领域一个适定的计算任务，具体涉及不连续函数的傅里叶级数的收敛特性。该问题具有科学依据，不需要外部信息，其指令清晰明确。可以通过直接实现指定的程序来构建解决方案。该问题被声明为 **有效 (valid)**。\n\n此问题的核心在于理解和缓解吉布斯现象 (Gibbs phenomenon)，这是一种在使用截断傅里叶级数 $S_{N}[f](x)$ 逼近分段光滑函数 $f(x)$ 的跳跃间断点附近时出现的持续振荡伪影。对于在点 $x_j$ 处有幅度为 $J$ 的跳跃的函数，部分和 $S_N[f]$ 将在 $x_j$ 附近表现出过冲和下冲。随着模态数 $N$ 的增加，这种振荡会更靠近跳跃点，但其幅度不会减小。最大过冲收敛到跳跃幅度的固定分数，约 $9\\%$, 具体为 $\\frac{J}{\\pi} \\int_{0}^{\\pi} \\frac{\\sin(t)}{t} dt - \\frac{J}{2} \\approx 0.08949 J$。这种缓慢的、非一致的收敛显著降低了傅里叶近似的质量。\n\n所提出的缓解策略基于“通过提升进行正则化”的原则。关键的见解是，吉布斯现象是用全局光滑函数基（复指数）来逼近间断点的直接后果。如果能在逼近*之前*从目标函数中移除间断点，那么剩余的连续部分就可以用截断傅里叶级数更精确地表示。\n\n该过程按以下步骤展开：\n\n1.  **跳跃识别与提升**：对于 $[0,1)$ 上的给定分段光滑函数 $f(x)$，我们首先识别其跳跃间断点。位置 $x_j$ 处的跳跃由其幅度 $J_j = f(x_j^+) - f(x_j^-)$ 来表征，其中 $f(x_j^\\pm)$ 是单侧极限。构造一个特殊的“提升”函数 $L(x)$，使其具有与 $f(x)$ 完全相同的跳跃结构。问题基于周期性锯齿波函数 $s(x) = x - \\frac{1}{2}$（对于 $x \\in [0,1)$）提供了 $L(x)$ 的形式：\n    $$\n    L(x) = - \\sum_{j=1}^{J} J_{j} \\, s(x - x_{j})\n    $$\n    项 $-J_j s(x-x_j)$ 在 $x=x_j$ 处的跳跃是 $-J_j \\times (s(x) \\text{ 在 } 0 \\text{ 处的跳跃}) = -J_j \\times (-1) = J_j$。由于其他项在 $x_j$ 处是连续的，所以 $L(x)$ 在 $x_j$ 处的总跳跃是 $J_j$，与 $f(x)$ 的跳跃相匹配。\n\n2.  **形成连续残差**：通过从原始函数中减去提升函数，我们创建了一个“跳跃提升后的残差” $f_c(x)$：\n    $$\n    f_c(x) := f(x) - L(x)\n    $$\n    根据构造， $f_c(x)$ 在每个 $x_j$ 处的跳跃是 $\\text{jump}(f) - \\text{jump}(L) = J_j - J_j = 0$。因此，$f_c(x)$ 处处连续，并且如果 $f(x)$ 是分段光滑的，$f_c(x)$ 将至少是连续且分段光滑的，甚至可能更光滑。\n\n3.  **谱近似**：我们现在可以计算这个连续残差的截断傅里叶级数 $S_N[f_c](x)$。因为 $f_c(x)$ 是连续的，其傅里叶系数比原始不连续函数 $f(x)$ 的系数衰减得快得多，其部分和 $S_N[f_c](x)$ 的收敛速度更快、更一致，且没有吉布斯现象。\n\n4.  **提升重构**：最终的、改进的 $f(x)$ 近似，记为 $R_N(x)$，是通过将提升函数加回到残差的近似上形成的：\n    $$\n    R_{N}(x) := S_{N}[f_{c}](x) + L(x)\n    $$\n    其基本原理是，由于 $S_N[f_c](x)$ 是 $f_c(x)$ 的一个非常好的近似，那么 $R_N(x) \\approx f_c(x) + L(x) = (f(x) - L(x)) + L(x) = f(x)$。这种重构巧妙地将所有间断点局部化在解析已知的函数 $L(x)$ 中，该函数在谱投影步骤*之后*被加回，从而规避了吉布斯现象的根源。\n\n所要求的计算实验涉及实现此过程并量化其有效性。对于每个测试用例，我们在 $[0,1)$ 上的一个精细的、包含 $M$ 个点的均匀网格上执行以下步骤：\n\n1.  构造 $f(x)$ 的离散表示、其跳跃 $\\{(x_j, J_j, f(x_j^-), f(x_j^+))\\}$ 以及相应的提升函数 $L(x)$。形成连续残差 $f_c(x) = f(x) - L(x)$。\n\n2.  计算标准傅里叶部分和 $S_N[f]$ 和残差部分和 $S_N[f_c]$。这可以使用快速傅里叶变换 (FFT) 高效完成。截断到模态 $|k| \\le N$ 的傅里叶级数通过以下方式计算：\n    a. 使用 `fft` 计算函数样本的离散傅里叶变换 (DFT)。\n    b. 将对应于模态 $|k|  N$ 的所有频率分量设置为零。\n    c. 使用 `ifft` 计算滤波后系数的逆离散傅里叶变换 (IDFT)。\n    然后，提升重构为 $R_N(x) = S_N[f_c](x) + L(x)$。\n\n3.  对标准重构 $S_N[f]$ 和提升重构 $R_N$ 的误差进行量化。使用两个度量标准：\n    - **最大过冲幅度**：这测量了在每个跳跃点周围半宽度为 $w = 4/N$ 的小窗口内，与真实极限值 $f(x_j^\\pm)$ 的峰值偏差。这直接量化了吉布斯现象。\n    - **远离跳跃点的均方根 (RMS) 误差**：这测量了在不与跳跃点直接相邻的定义域部分上的平均近似误差，特别是在每个间断点周围排除半径为 $r = 3/N$ 的区域之外。这量化了“光滑”区域的整体收敛质量。\n\n4.  最后，计算这些误差度量的比率 $\\mathrm{ratio}_{\\mathrm{over}}$ 和 $\\mathrm{ratio}_{\\mathrm{rms}}$，以提供一个归一化的度量，衡量提升技术所带来的改进。远小于 $1$ 的比率表明有显著的改进。\n\n此过程被系统地应用于所提供的三个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment for all test cases.\n    \"\"\"\n    \n    # Global numerical parameters\n    M = 65536  # Number of grid points\n    \n    # Test cases definition\n    test_cases = [\n        # Case A: Two-plateau function\n        {\n            \"name\": \"Case A\",\n            \"N\": 64,\n            \"f_def\": lambda x, a=0.3: np.where(x  a, 1.0, -1.0),\n            \"jumps\": [\n                # (xj, Jj, f(xj-), f(xj+))\n                (0.0, 2.0, -1.0, 1.0),\n                (0.3, -2.0, 1.0, -1.0)\n            ],\n        },\n        # Case B: Sawtooth function (ramp)\n        {\n            \"name\": \"Case B\",\n            \"N\": 64,\n            \"f_def\": lambda x: x - 0.5,\n            \"jumps\": [\n                (0.0, -1.0, 0.5, -0.5)\n            ],\n        },\n        # Case C: Three-plateau function\n        {\n            \"name\": \"Case C\",\n            \"N\": 32,\n            \"f_def\": lambda x, a=0.25, b=0.7, v0=1.0, v1=-0.5, v2=0.3: \\\n                np.select([x  a, (x >= a)  (x  b), x >= b], [v0, v1, v2]),\n            \"jumps\": [\n                (0.0, 0.7, 0.3, 1.0),       # J1 = v0 - v2\n                (0.25, -1.5, 1.0, -0.5),   # J2 = v1 - v0\n                (0.7, 0.8, -0.5, 0.3)        # J3 = v2 - v1\n            ],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        ratios = process_case(M, case['N'], case['f_def'], case['jumps'])\n        results.extend(ratios)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\ndef process_case(M, N, f_def, jumps):\n    \"\"\"\n    Processes a single test case and returns the error ratios.\n    \"\"\"\n\n    # 1. Grid and function setup\n    x = np.arange(M) / M\n    f_vals = f_def(x)\n\n    # 2. Construct the lifting function L(x)\n    L_vals = np.zeros(M)\n    for xj, Jj, _, _ in jumps:\n        # Periodic sawtooth: s(y) = y - 0.5 for y in [0,1)\n        # s(x - xj) evaluated on the grid\n        shifted_x_mod1 = (x - xj + 1.0) % 1.0\n        sawtooth_vals = shifted_x_mod1 - 0.5\n        L_vals -= Jj * sawtooth_vals\n\n    # 3. Form the continuous residual f_c = f - L\n    fc_vals = f_vals - L_vals\n\n    # 4. Compute Fourier partial sums using FFT\n    k_modes = np.fft.fftfreq(M, d=1.0/M)\n    mask_N = np.abs(k_modes) = N\n    \n    # S_N[f]\n    F_f = np.fft.fft(f_vals)\n    F_f_trunc = F_f * mask_N\n    SN_f = np.real(np.fft.ifft(F_f_trunc))\n    \n    # S_N[f_c]\n    F_fc = np.fft.fft(fc_vals)\n    F_fc_trunc = F_fc * mask_N\n    SN_fc = np.real(np.fft.ifft(F_fc_trunc))\n    \n    # 5. Form the lifted reconstruction R_N\n    R_N = SN_fc + L_vals\n\n    # 6. Quantify errors\n    overshoot_SN, rms_SN = calculate_errors(SN_f, f_vals, jumps, N, x, M)\n    overshoot_RN, rms_RN = calculate_errors(R_N, f_vals, jumps, N, x, M)\n\n    # 7. Compute ratios\n    # Handle the case where the denominator is zero (perfect reconstruction)\n    ratio_over = 0.0 if overshoot_SN == 0 else overshoot_RN / overshoot_SN\n    ratio_rms = 0.0 if rms_SN == 0 else rms_RN / rms_SN\n\n    return ratio_over, ratio_rms\n\ndef periodic_dist(x, x0):\n    \"\"\"\n    Computes the signed periodic distance from points x to x0 on the torus [0,1).\n    The result lies in [-0.5, 0.5).\n    \"\"\"\n    d = x - x0\n    return (d + 0.5) % 1.0 - 0.5\n\ndef calculate_errors(u, f, jumps, N, x, M):\n    \"\"\"\n    Calculates overshoot and RMS error for a given reconstruction u.\n    \"\"\"\n    # ----- Overshoot calculation -----\n    w = 4.0 / N\n    max_overshoot = 0.0\n    \n    for xj, _, f_minus, f_plus in jumps:\n        dist_from_jump = periodic_dist(x, xj)\n        \n        # Left side window: [-w, 0)\n        left_mask = (dist_from_jump >= -w)  (dist_from_jump  0)\n        if np.any(left_mask):\n            dev_left = np.max(np.abs(u[left_mask] - f_minus))\n            max_overshoot = max(max_overshoot, dev_left)\n            \n        # Right side window: (0, w]\n        right_mask = (dist_from_jump > 0)  (dist_from_jump = w)\n        if np.any(right_mask):\n            dev_right = np.max(np.abs(u[right_mask] - f_plus))\n            max_overshoot = max(max_overshoot, dev_right)\n\n    # ----- RMS error away from jumps -----\n    r = 3.0 / N\n    away_mask = np.ones(M, dtype=bool)\n    \n    for xj, _, _, _ in jumps:\n        dist_from_jump = np.abs(periodic_dist(x, xj))\n        away_mask = (dist_from_jump >= r)\n    \n    error_vals = u - f\n    \n    # Ensure there are points in the 'away' region to avoid division by zero\n    if np.sum(away_mask) > 0:\n        rms_error = np.sqrt(np.mean(error_vals[away_mask]**2))\n    else:\n        # This case is unlikely but handled for robustness\n        rms_error = 0.0\n        \n    return max_overshoot, rms_error\n\n# Run the main solver function\nsolve()\n```"
        },
        {
            "introduction": "最后的这项实践旨在解决一个常见问题：如何将傅里叶方法应用于有限区间上的非周期函数。在这种情况下，周期性延拓会在区间端点产生人为的间断，从而引发吉布斯振荡。学生将实现傅里叶延拓法，该方法通过最小二乘拟合将原函数嵌入到一个更大的周期性定义域中。这项高级练习阐明了如何将间断点“移出”我们关心的区域，从而显著提高在边界处的逼近精度。",
            "id": "3373768",
            "problem": "考虑一个实值非周期函数 $u:[0,1]\\to\\mathbb{R}$，该函数是分段连续可微的，当以周期 $1$ 进行周期性延拓时，在区间端点处至多有有限个跳跃间断点。在谱方法的框架内，并应用于间断伽辽金（DG）离散化中，$u$ 的周期为 1 的延拓的傅里叶部分和会表现出与吉布斯现象相关的端点振荡。为了减轻这些振荡，设计一种谱延拓方法，通过最小二乘傅里叶延拓将 $u$ 嵌入到一个更长的周期区间中。目标是构建、分析和测试一种方法，该方法通过在 $[0,L]$（其中 $L1$）上周期的三角多项式来近似 $[0,1]$ 上的 $u$，从而将间断点移出目标区间，并减少 $[0,1]$ 内部的吉布斯振荡。\n\n你的任务：\n\n1) 从第一性原理出发设计方法。设 $L1$ 为一个固定的延拓长度，并设 $K\\in\\mathbb{N}$ 为最大傅里叶模，因此近似空间为\n$$\n\\mathcal{T}_{K}^{(L)} = \\operatorname{span}\\left\\{\\mathrm{e}^{\\mathrm{i} 2\\pi k x / L} : k=-K,-K+1,\\dots,K\\right\\}.\n$$\n通过在 $[0,1)$ 内的一组 $N$ 个等距点 $\\{x_j\\}_{j=0}^{N-1}$ 上对 $u$ 进行采样，并最小化离散平方误差\n$$\n\\sum_{j=0}^{N-1} \\left|u_{K,L}(x_j)-u(x_j)\\right|^2\n$$\n来构造最小二乘（LS）近似 $u_{K,L}\\in \\mathcal{T}_{K}^{(L)}$，该最小化过程在所有 $u_{K,L}\\in \\mathcal{T}_{K}^{(L)}$ 上进行。推导系数必须满足的线性正规方程，并指明在任意 $x\\in [0,1]$ 处计算 $u_{K,L}$ 所需的算法步骤。所有角度必须以弧度为单位进行解释。\n\n2) 吉布斯振荡减少的概念性证明。利用关于正交投影、最小二乘近似和三角多项式局部化核的基本事实，解释为什么选择 $L1$ 相比于阶数为 $K$ 的标准周期为 1 的傅里叶部分和，能够减少 $[0,1]$ 内部的吉布斯振荡。你的推理必须从核心定义（如最小二乘投影的性质）和经过充分检验的事实（如傅里叶部分和的狄利克雷核结构）出发。避免使用任何未经证明的快捷公式来得出目标结果。你的证明必须基于原理，依赖于有效近似核的行为，以及将间断点移离 $[0,1]$ 如何减弱目标区间内的伪振荡。\n\n3) 将误差量化为延拓长度的函数。对于固定的边界层宽度 $\\delta\\in(0,1/2)$，定义以下两个误差度量：\n- 边界吉布斯幅度\n$$\n\\mathcal{G}(u_{K,L}) \\equiv \\max\\left\\{\\max_{x\\in[0,\\delta]}\\left(u_{K,L}(x)-u(x)\\right),\\,\\max_{x\\in[1-\\delta,1]}\\left(u(x)-u_{K,L}(x)\\right)\\right\\},\n$$\n它捕捉了左端点和右端点附近的经典过冲/下冲现象。\n- 内部一致误差\n$$\n\\mathcal{E}_{\\mathrm{int}}(u_{K,L}) \\equiv \\max_{x\\in[\\delta,\\,1-\\delta]} \\left|u_{K,L}(x)-u(x)\\right|.\n$$\n解释如何从样本中数值计算这些度量，而无需借助任何外部数据。为你选择的任何数值参数（例如，$N$、求值网格分辨率）提供理由，确保科学真实性。\n\n4) 实现和测试套件。为 $[0,1]$ 上的具体函数 $u(x)=x$ 实现该方法。使用固定的模数 $K=25$，在 $[0,1)$ 上使用 $N=2048$ 个等距节点的最小二乘采样大小，并在 $[0,1]$（包含端点）上使用至少 $10000$ 个等距点的求值网格来估计这些度量。使用 $\\delta=0.05$。\n\n将标准周期为 1 的傅里叶近似 $u_{K,1}$ 定义为在相同的 $N$ 个样本上对 $\\mathcal{T}_{K}^{(1)}$ 空间的最小二乘拟合。对于傅里叶延拓近似，使用延拓长度 $L\\in\\{1.2,1.6,2.5,4.0\\}$。计算：\n- 比率 $r_{\\mathrm{G}}=\\mathcal{G}(u_{K,2.5}) / \\mathcal{G}(u_{K,1})$。\n- 布尔值 $b_{\\mathrm{mono}}$，指示边界吉布斯幅度是否随着 $L$ 在有序列表 $\\{1.2,1.6,2.5,4.0\\}$ 中增加而严格减小，角度以弧度解释。\n- 比率 $r_{\\mathrm{int}}=\\mathcal{E}_{\\mathrm{int}}(u_{K,2.5}) / \\mathcal{E}_{\\mathrm{int}}(u_{K,1})$。\n- 四个边界吉布斯幅度 $\\mathcal{G}(u_{K,L})$，对应于 $L\\in\\{1.2,1.6,2.5,4.0\\}$，按此顺序。\n\n5) 最终输出格式。你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果：\n- 条目 1: 浮点数 $r_{\\mathrm{G}}$。\n- 条目 2: 布尔值 $b_{\\mathrm{mono}}$。\n- 条目 3: 浮点数 $r_{\\mathrm{int}}$。\n- 条目 4–7: 分别对应 $L=1.2,1.6,2.5,4.0$ 的四个浮点数 $\\mathcal{G}(u_{K,L})$。\n例如，一个有效的输出看起来像\"[0.312345,True,0.102938,0.08123,0.06111,0.03210,0.01876]\"。不应打印任何其他文本。\n\n你的代码必须是完全自包含的，不需要任何输入，并在指定环境下运行。所有角度都必须是弧度。所有输出必须是指定的实数或布尔值。此问题不涉及物理单位，因此不需要单位转换。\n\n测试套件包含以下参数值，你必须在程序中将其硬编码：\n- 函数 $u(x)=x$ on $[0,1]$。\n- 模数 $K=25$。\n- 在 $[0,1)$ 上的最小二乘采样大小 $N=2048$。\n- 在 $[0,1]$ 上包括端点的求值网格大小至少为 $10000$ 个点。\n- 边界层宽度 $\\delta=0.05$。\n- 延拓长度 $L\\in\\{1,1.2,1.6,2.5,4.0\\}$，其中 $L=1$ 用于标准近似，$L1$ 用于傅里叶延拓近似。\n\n你的程序必须仅使用这些参数计算上述输出，并以要求的格式单行打印。",
            "solution": "该问题要求设计、分析和实现一种傅里叶延拓方法，以减轻有限区间上分段光滑函数的吉布斯振荡。该方法涉及将函数定义域 $[0,1]$ 嵌入到一个更大的周期域 $[0,L]$（其中 $L1$）中，并使用三角多项式进行最小二乘拟合。\n\n### 1) 从第一性原理出发设计方法\n\n设近似函数 $u_{K,L}(x)$ 是空间 $\\mathcal{T}_{K}^{(L)}$ 中的一个元素。任何此类函数都可以写成基函数的线性组合：\n$$\nu_{K,L}(x) = \\sum_{k'=-K}^{K} c_{k'} e^{i 2\\pi k' x / L}\n$$\n其中 $\\{c_{k'}\\}_{k'=-K}^K$ 是待确定的复数值系数。目标是找到一组系数，使得在 $[0,1)$ 内的一组 $N$ 个等距点 $\\{x_j\\}_{j=0}^{N-1}$（其中 $x_j = j/N$）上的离散平方误差最小。需要最小化的误差泛函为：\n$$\nE(\\mathbf{c}) = \\sum_{j=0}^{N-1} \\left| u_{K,L}(x_j) - u(x_j) \\right|^2 = \\sum_{j=0}^{N-1} \\left| \\sum_{k'=-K}^{K} c_{k'} e^{i 2\\pi k' x_j / L} - u(x_j) \\right|^2\n$$\n这是一个标准的线性最小二乘问题。为了以矩阵形式表示它，我们定义以下向量和矩阵：\n- 未知系数向量：$\\mathbf{c} = [c_{-K}, c_{-K+1}, \\dots, c_K]^T \\in \\mathbb{C}^{2K+1}$。为了实现方便，可以通过 $k' = k - K$ 将索引 $k' \\in \\{-K, \\dots, K\\}$ 映射到索引 $k \\in \\{0, \\dots, 2K\\}$。\n- 函数样本向量：$\\mathbf{u} = [u(x_0), u(x_1), \\dots, u(x_{N-1})]^T \\in \\mathbb{R}^N$。\n- $N \\times (2K+1)$ 的设计矩阵 $A$，其元素是在采样点处求值的基函数。第 $j$ 行第 $k$ 列（对应于模 $k' = k-K$）的元素是：\n$$\nA_{j,k} = e^{i 2\\pi (k-K) x_j / L}\n$$\n在采样点处的近似值向量则为 $A\\mathbf{c}$。最小化问题重写为：\n$$\n\\min_{\\mathbf{c} \\in \\mathbb{C}^{2K+1}} \\| A\\mathbf{c} - \\mathbf{u} \\|_2^2\n$$\n此最小化问题的解由正规方程给出，其推导过程是将 $E(\\mathbf{c})$ 相对于 $\\mathbf{c}$ 的实部和虚部的梯度设为零。这得到线性系统：\n$$\nA^H A \\mathbf{c} = A^H \\mathbf{u}\n$$\n其中 $A^H$ 是 $A$ 的共轭转置（埃尔米特转置）。矩阵 $M = A^H A$ 是一个 $(2K+1) \\times (2K+1)$ 的埃尔米特矩阵。对于 $N \\ge 2K+1$ 和不同的采样点，$A$ 的列是线性无关的，这使得 $M$ 是正定的，因此是可逆的。系数的唯一最小二乘解是 $\\mathbf{c} = (A^H A)^{-1} A^H \\mathbf{u}$。\n\n在任意点 $x \\in [0,1]$ 计算近似值 $u_{K,L}(x)$ 的算法如下：\n1.  **设置：** 定义参数 $K$、$L$、$N$ 和采样点 $x_j = j/N$ for $j=0, \\dots, N-1$。\n2.  **采样：** 通过计算 $u(x_j)$ 构造数据向量 $\\mathbf{u}$。\n3.  **矩阵构造：** 构造 $N \\times (2K+1)$ 矩阵 $A$，其中 $A_{j,k} = e^{i 2\\pi (k-K) x_j / L}$。\n4.  **求解系数：** 求解最小二乘系统 $A\\mathbf{c} \\approx \\mathbf{u}$ 以获得系数向量 $\\mathbf{c}$。应优先使用数值稳定的方法，例如基于 QR 或 SVD 分解的方法（如 `numpy.linalg.lstsq` 中的实现），而不是直接构造并求逆 $A^H A$。\n5.  **求值：** 要在一个新点 $x$ 处找到 $u_{K,L}(x)$，计算和 $\\sum_{k'=-K}^{K} c_{k'} e^{i 2\\pi k' x / L}$。这可以通过构造一个求值矩阵 $A_{\\text{eval}}$（其元素为 $e^{i 2\\pi k' z_m / L}$），并计算矩阵向量积 $A_{\\text{eval}}\\mathbf{c}$ 来为一组求值点 $\\{z_m\\}$ 进行计算。由于 $u(x)$ 是实值函数，得到的近似 $u_{K,L}(x)$ 也应是实数，通常取计算出的和的实部，以舍弃由浮点误差产生的微小虚部。\n\n### 2) 吉布斯振荡减少的概念性证明\n\n$[0,1]$ 上的标准傅里叶级数近似（即 $L=1$ 的情况）对应于到周期为 1 的三角多项式空间 $\\mathcal{T}_K^{(1)}$ 上的正交投影。该近似可以写成与狄利克雷核的卷积，$S_K[u](x) = (u * D_K)(x)$。狄利克雷核 $D_K(t) = \\sum_{k=-K}^K e^{i2\\pi kt}$ 在远离 $t=0$ 时以 $1/|t|$ 的速度缓慢衰减，并且其积分范数 $\\int|D_K(t)|dt$ 当 $K \\to \\infty$ 时是无界的。这种差的局部化特性意味着在某点 $x$ 的近似值会受到远离 $x$ 的函数值的显著影响。当函数存在跳跃间断点时，这种非局部影响表现为吉布斯现象中持续的过冲和下冲。\n\n傅里叶延拓方法将底层近似空间更改为 $\\mathcal{T}_K^{(L)}$，其中 $L1$。基函数 $\\{e^{i2\\pi kx/L}\\}$ 在更大的区间 $[0,L]$ 上是周期的。函数 $u(x)$ 定义在 $[0,1]$ 上，其周期为 1 的延拓在整数点处有跳跃间断点（例如，从 $u(1^-)$ 到 $u(0^+)$）。根据构造，近似 $u_{K,L}(x)$ 在 $[0,L]$ 上是周期的。它被设计为在最小二乘意义上匹配 $[0,1]$ 上的 $u(x)$。这个过程隐式地寻找一个在 $[0,L]$ 上的函数，该函数在 $[0,1]$ 上接近 $u(x)$，并在延拓区间 $(1,L)$ 上将 $x=1$ 处的值平滑地连接到 $x=0$ 处的值。\n\n因此，被三角多项式 $u_{K,L}(x)$ 近似的函数，其主要间断点位于 $[0,L]$ 区间的端点，而不是 $[0,1]$ 区间的端点。虽然 $u_{K,L}(x)$ 仍然会表现出吉布斯振荡，但这些振荡将局限于其自身周期性延拓的间断点周围，即在 $L$ 的整数倍处。\n\n对于一个点 $x \\in [0,1]$，它到最近的显著间断点（在周期意义上）的距离现在变得大得多。例如，从 $u(1)$ 到 $u(0)$ 的跳跃被有效地从 $(1,0)$ “移动”到了 $(L,0)$。用于从 $[0,1]$ 上的数据合成 $x$ 处近似值的近似核，仍然有振荡的尾部。然而，由于间断点现在“远离”区间 $[0,1]$，这些振荡尾部的幅度在到达 $[0,1]$ 时已经显著衰减。延拓长度 $L$ 越大，间断点被推得越远，在原始目标区间内吉布斯振荡的衰减就越大。\n\n### 3) 误差量化\n\n数值计算误差度量 $\\mathcal{G}(u_{K,L})$ 和 $\\mathcal{E}_{\\mathrm{int}}(u_{K,L})$ 的算法依赖于对区间 $[0,1]$ 的精细离散化。\n\n1.  **求值网格：** 在 $[0,1]$ 上定义一个包含 $M$ 个点的等距网格 $\\{z_m\\}_{m=0}^{M-1}$，其中 $z_m = m/(M-1)$。该网格必须足够密集以捕捉误差函数振荡的峰值。$M \\ge 10000$ 点的规模在科学上是可行的，因为约 $10^{-4}$ 的网格间距远小于误差振荡的特征波长（对于给定参数，量级约为 $L/K \\approx 0.04 - 0.16$），确保了对上确界范数的准确近似。\n2.  **计算值：** 真实函数 $u(x)$ 和近似函数 $u_{K,L}(x)$（通过任务1中的方法计算）在该网格上求值，得到向量 $\\mathbf{u}_{\\text{true}}$ 和 $\\mathbf{u}_{\\text{approx}}$。\n3.  **逐点误差：** 计算逐点误差向量：$\\mathbf{e} = \\mathbf{u}_{\\text{approx}} - \\mathbf{u}_{\\text{true}}$。\n4.  **计算边界吉布斯幅度 $\\mathcal{G}(u_{K,L})$：**\n    a. 识别出对应于边界层 $[0,\\delta]$ 和 $[1-\\delta,1]$ 的网格索引。\n    b. 左侧过冲通过 $\\max_{x\\in[0,\\delta]}(u_{K,L}(x)-u(x))$ 来衡量。在离散网格上，这是误差向量 $\\mathbf{e}$ 在左边界索引上的最大值。\n    c. 右侧下冲/过冲通过 $\\max_{x\\in[1-\\delta,1]}(u(x)-u_{K,L}(x))$ 来衡量。这是 $-\\mathbf{e}$ 在右边界索引上的最大值。（对于 $u(x)=x$，跳跃是向下的，所以我们预期会出现下冲，即 $u_{K,L}(x)  u(x)$，使得这个量为正）。\n    d. $\\mathcal{G}(u_{K,L})$ 是这两个计算值的最大值。\n5.  **计算内部一致误差 $\\mathcal{E}_{\\mathrm{int}}(u_{K,L})$：**\n    a. 识别出对应于内部区间 $[\\delta, 1-\\delta]$ 的网格索引。\n    b. 该度量计算为误差向量绝对值 $|\\mathbf{e}|$ 在这些内部索引上的最大值。\n\n只要评估网格的分辨率 $M$ 足够高，并且用于最小二乘拟合的参数 $N$ 足够大以防止混叠，这个数值程序就能提供对连续误差度量的稳健估计，而问题选择的 $N=2048$ 对于 $2K+1=51$ 个模是满足条件的。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Fourier continuation method to mitigate Gibbs oscillations\n    and computes the specified error metrics and ratios.\n    \"\"\"\n\n    # 4) Implementation and Test Suite Parameters\n    u = lambda x: x\n    K = 25\n    N = 2048\n    M = 10001  # Evaluation grid size, >= 10000 and inclusive of endpoints\n    delta = 0.05\n    L_values = [1.0, 1.2, 1.6, 2.5, 4.0]\n\n    # LS sampling grid on [0, 1)\n    x_j = np.arange(N) / N\n    # Evaluation grid on [0, 1]\n    x_eval = np.linspace(0, 1, M)\n\n    # Vector of true function values at sampling and evaluation points\n    u_j = u(x_j)\n    u_eval = u(x_eval)\n\n    # Indices for boundary layers and interior on the evaluation grid\n    # z_m = delta  => m/(M-1) = delta => m = delta * (M-1)\n    # z_m >= 1-delta => m/(M-1) >= 1-delta => m >= (1-delta)*(M-1)\n    idx_left_boundary = np.where(x_eval = delta)[0]\n    idx_right_boundary = np.where(x_eval >= 1 - delta)[0]\n    idx_interior = np.where((x_eval > delta)  (x_eval  1 - delta))[0]\n\n    # Fourier modes k' = -K, ..., K\n    k_modes = np.arange(-K, K + 1)\n    \n    gibbs_magnitudes = {}\n    interior_errors = {}\n\n    def compute_metrics(L, k_modes, x_j, u_j, x_eval, u_eval):\n        \"\"\"\n        Computes the approximation u_K,L and the corresponding error metrics.\n        \n        Args:\n            L (float): Extension length.\n            k_modes (np.ndarray): Array of Fourier modes.\n            x_j (np.ndarray): Sampling points.\n            u_j (np.ndarray): Function values at sampling points.\n            x_eval (np.ndarray): Evaluation points.\n            u_eval (np.ndarray): Function values at evaluation points.\n\n        Returns:\n            tuple: (Gibbs magnitude, Interior uniform error)\n        \"\"\"\n        # 1) Method design: Construct and solve the LS problem\n        # Basis functions evaluated at sample points\n        # A_jk = exp(i * 2*pi * k_modes[k] * x_j[j] / L)\n        A = np.exp(1j * 2 * np.pi * np.outer(x_j, k_modes) / L)\n\n        # Solve the least-squares problem Ac = u_j for the coefficients c\n        c, _, _, _ = np.linalg.lstsq(A, u_j, rcond=None)\n\n        # Evaluate the approximation on the fine grid\n        A_eval = np.exp(1j * 2 * np.pi * np.outer(x_eval, k_modes) / L)\n        u_approx = np.real(A_eval @ c)\n\n        # Pointwise error\n        error = u_approx - u_eval\n\n        # 3) Quantification of error: Compute metrics\n        # Boundary Gibbs magnitude is defined as:\n        # max( max_{x in [0,d]}(u_K,L - u), max_{x in [1-d,1]}(u - u_K,L) )\n        left_overshoot = np.max(error[idx_left_boundary])\n        right_undershoot = np.max(-error[idx_right_boundary])\n        g_metric = max(left_overshoot, right_undershoot)\n\n        # Interior uniform error\n        e_int_metric = np.max(np.abs(error[idx_interior]))\n        \n        return g_metric, e_int_metric\n\n    # Compute metrics for each L\n    for L in L_values:\n        g, e_int = compute_metrics(L, k_modes, x_j, u_j, x_eval, u_eval)\n        gibbs_magnitudes[L] = g\n        interior_errors[L] = e_int\n        \n    # 5) Final Output Computation\n    # Ratio r_G\n    g_1_0 = gibbs_magnitudes[1.0]\n    g_2_5 = gibbs_magnitudes[2.5]\n    r_G = g_2_5 / g_1_0\n\n    # Monotonicity boolean b_mono\n    g_continuation = [gibbs_magnitudes[l] for l in [1.2, 1.6, 2.5, 4.0]]\n    b_mono = all(g_continuation[i] > g_continuation[i+1] for i in range(len(g_continuation)-1))\n\n    # Ratio r_int\n    e_int_1_0 = interior_errors[1.0]\n    e_int_2_5 = interior_errors[2.5]\n    r_int = e_int_2_5 / e_int_1_0\n    \n    # Collate results for printing\n    final_results = [\n        r_G,\n        b_mono,\n        r_int\n    ] + g_continuation\n    \n    # Format and print the final output string\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}