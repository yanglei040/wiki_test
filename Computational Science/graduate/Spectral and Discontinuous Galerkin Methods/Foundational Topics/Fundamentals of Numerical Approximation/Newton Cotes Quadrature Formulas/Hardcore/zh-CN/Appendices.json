{
    "hands_on_practices": [
        {
            "introduction": "任何数值方法在理论上都有其精度极限。对于求积公式，这个极限由“代数精度”来量化。本练习将通过推导封闭型 Newton-Cotes 公式所能精确积分的最高次多项式次数，来探索其代数精度。这个过程不仅能加深您对求积公式构造（基于多项式插值）与其性能之间联系的理解，还将揭示一个与节点对称性相关的有趣性质。 ",
            "id": "3401945",
            "problem": "考虑谱间断 Galerkin (DG) 方法中的一个参考单元 $[0,1]$，其中多项式基函数的内积通过求积法计算。定义 $[0,1]$ 上指数为 $n$ 的闭合 Newton–Cotes (NC) 法则如下：令 $x_j = \\frac{j}{n}$，其中 $j=0,1,\\dots,n$，并令 $\\ell_j(x)$ 为与这些节点相关联的、次数至多为 $n$ 的 Lagrange 插值基多项式。该求积是一个线性泛函\n$$\nQ_n(f) = \\sum_{j=0}^{n} w_j f(x_j), \\quad \\text{其中} \\quad w_j = \\int_{0}^{1} \\ell_j(x)\\,dx,\n$$\n根据其构造，该求积能在 $[0,1]$ 上精确地对 $f$ 的 $n$ 次插值多项式进行积分。\n\n在使用单项式基 $x^k$ 组装 DG 质量矩阵的背景下，检验 $Q_n$ 对单项式 $x^k$ (其中 $k=0,1,\\dots,n+1$) 的精确性。仅从上述定义以及多项式插值和对称性的基本性质出发，确定集合 $\\{0,1,\\dots,n+1\\}$ 中的最大整数 $k$，使得 $Q_n(x^k) = \\int_{0}^{1} x^k\\,dx$ 成立。将你的最终答案表示为关于 $n$ 的单个闭式解析表达式。无需四舍五入，也不涉及任何物理单位。",
            "solution": "问题要求在集合 $\\{0, 1, \\dots, n+1\\}$ 中，使得区间 $[0,1]$ 上的闭合 Newton-Cotes 求积法则 $Q_n$ 对单项式 $x^k$ 精确的最大整数 $k$。也就是说，我们要寻找最大的 $k \\in \\{0, 1, \\dots, n+1\\}$，使得 $Q_n(x^k) = \\int_{0}^{1} x^k \\,dx$。\n\n求积法则定义为\n$$\nQ_n(f) = \\sum_{j=0}^{n} w_j f(x_j)\n$$\n节点为 $x_j = \\frac{j}{n}$，其中 $j=0, 1, \\dots, n$，权重为 $w_j = \\int_{0}^{1} \\ell_j(x) \\,dx$，其中 $\\ell_j(x)$ 是与节点 $\\{x_j\\}$ 相关联的、次数至多为 $n$ 的 Lagrange 基多项式。\n\n根据权重的定义，我们可以将求积法则写为\n$$\nQ_n(f) = \\sum_{j=0}^{n} \\left(\\int_{0}^{1} \\ell_j(x) \\,dx\\right) f(x_j) = \\int_{0}^{1} \\left(\\sum_{j=0}^{n} f(x_j) \\ell_j(x)\\right) \\,dx\n$$\n积分内的和式 $\\sum_{j=0}^{n} f(x_j) \\ell_j(x)$ 是在 $n+1$ 个节点 $\\{x_j\\}_{j=0}^n$ 上对函数 $f(x)$ 进行插值的、次数至多为 $n$ 的唯一多项式。我们将此插值多项式记为 $I_n(f)(x)$。因此，该求积法则被构造为插值多项式的精确积分：\n$$\nQ_n(f) = \\int_{0}^{1} I_n(f)(x) \\,dx\n$$\n\n首先，我们证明该法则对次数至多为 $n$ 的多项式是精确的。设 $P(x)$ 为任意次数至多为 $n$ 的多项式。Lagrange 插值的一个基本性质是，对于 $P(x)$，经过其图像上 $n+1$ 个点的次数至多为 $n$ 的插值多项式就是 $P(x)$ 本身。因此，$I_n(P)(x) = P(x)$。\n\n将此性质应用于求积法则，我们有：\n$$\nQ_n(P) = \\int_{0}^{1} I_n(P)(x) \\,dx = \\int_{0}^{1} P(x) \\,dx\n$$\n这表明指数为 $n$ 的闭合 Newton-Cotes 法则对所有次数至多为 $n$ 的多项式都是精确的。对于 $k=0, 1, \\dots, n$，单项式 $x^k$ 都是次数至多为 $n$ 的多项式。因此，该法则对这些单项式是精确的：\n$$\nQ_n(x^k) = \\int_{0}^{1} x^k \\,dx \\quad \\text{对于 } k=0, 1, \\dots, n\n$$\n这证明了我们所求的最大整数 $k$ 至少为 $n$。\n\n现在，我们必须研究 $k=n+1$ 的情况。精确性条件是 $Q_n(x^{n+1}) = \\int_{0}^{1} x^{n+1} \\,dx$。对于函数 $f(x) = x^{n+1}$，求积法则的误差由下式给出：\n$$\nE_n(x^{n+1}) = \\int_{0}^{1} x^{n+1} \\,dx - Q_n(x^{n+1})\n$$\n使用 $Q_n$ 的定义，误差可以表示为：\n$$\nE_n(x^{n+1}) = \\int_{0}^{1} x^{n+1} \\,dx - \\int_{0}^{1} I_n(x^{n+1})(x) \\,dx = \\int_{0}^{1} \\left( x^{n+1} - I_n(x^{n+1})(x) \\right) \\,dx\n$$\n积分内的项是函数 $f(x)=x^{n+1}$ 的多项式插值误差。插值误差的标准公式是\n$$\nf(x) - I_n(f)(x) = \\frac{f^{(n+1)}(\\xi_x)}{(n+1)!} \\prod_{j=0}^{n} (x-x_j)\n$$\n其中 $\\xi_x$ 在由 $x$ 和节点所张成的区间内。对于 $f(x) = x^{n+1}$，其 $(n+1)$ 阶导数是一个常数：$f^{(n+1)}(x) = (n+1)!$。因此，插值误差简化为：\n$$\nx^{n+1} - I_n(x^{n+1})(x) = \\frac{(n+1)!}{(n+1)!} \\prod_{j=0}^{n} (x-x_j) = \\prod_{j=0}^{n} (x-x_j)\n$$\n我们定义节点多项式 $\\pi_{n+1}(x) = \\prod_{j=0}^{n} (x-x_j) = \\prod_{j=0}^{n} (x - \\frac{j}{n})$。$x^{n+1}$ 的求积误差就是该多项式的积分：\n$$\nE_n(x^{n+1}) = \\int_{0}^{1} \\pi_{n+1}(x) \\,dx\n$$\n求积法则对 $k=n+1$ 精确，当且仅当该积分为零。为了计算该积分，我们分析被积函数的对称性。节点 $x_j = j/n$ 关于积分区间 $[0,1]$ 的中点 $x=1/2$ 是对称的。具体来说，对于任何 $j \\in \\{0, 1, \\dots, n\\}$，节点 $x_j$ 和节点 $x_{n-j}$ 到中点的距离相等：\n$$\nx_j - \\frac{1}{2} = \\frac{j}{n} - \\frac{1}{2} = \\frac{2j-n}{2n}\n$$\n$$\nx_{n-j} - \\frac{1}{2} = \\frac{n-j}{n} - \\frac{1}{2} = \\frac{2(n-j)-n}{2n} = \\frac{n-2j}{2n} = -\\left(\\frac{2j-n}{2n}\\right) = -(x_j - \\frac{1}{2})\n$$\n我们进行变量替换 $u = x - 1/2$，因此 $x = u + 1/2$。积分区间 $[0,1]$ 变为 $[-1/2, 1/2]$。函数 $\\pi_{n+1}(x)$ 变为 $\\tilde{\\pi}_{n+1}(u) = \\pi_{n+1}(u+1/2)$。\n$$\n\\tilde{\\pi}_{n+1}(u) = \\prod_{j=0}^{n} \\left(u + \\frac{1}{2} - x_j\\right) = \\prod_{j=0}^{n} \\left(u - \\left(x_j - \\frac{1}{2}\\right)\\right)\n$$\n我们检验 $\\tilde{\\pi}_{n+1}(u)$ 的奇偶性。\n$$\n\\tilde{\\pi}_{n+1}(-u) = \\prod_{j=0}^{n} \\left(-u - (x_j - \\frac{1}{2})\\right) = (-1)^{n+1} \\prod_{j=0}^{n} \\left(u + (x_j - \\frac{1}{2})\\right)\n$$\n利用对称性质 $x_j - 1/2 = -(x_{n-j} - 1/2)$，节点偏移量集合 $\\{x_j-1/2\\}_{j=0}^n$ 是关于 0 对称的。因此，$\\prod_{j=0}^{n} (u + (x_j - 1/2)) = \\prod_{j=0}^{n} (u - (x_{n-j} - 1/2)) = \\prod_{k=0}^{n} (u - (x_k - 1/2)) = \\tilde{\\pi}_{n+1}(u)$。\n因此，我们有如下对称关系：\n$$\n\\tilde{\\pi}_{n+1}(-u) = (-1)^{n+1} \\tilde{\\pi}_{n+1}(u)\n$$\n这意味着如果 $n+1$ 是奇数（即 $n$ 是偶数），$\\tilde{\\pi}_{n+1}(u)$ 是一个奇函数；如果 $n+1$ 是偶数（即 $n$ 是奇数），它是一个偶函数。\n\n误差积分为 $E_n(x^{n+1}) = \\int_{-1/2}^{1/2} \\tilde{\\pi}_{n+1}(u) \\,du$。\n\n情况 1：$n$ 是偶数。\n在这种情况下，$n+1$ 是奇数，$\\tilde{\\pi}_{n+1}(u)$ 是一个奇函数。奇函数在对称区间 $[-1/2, 1/2]$ 上的积分为零。\n$$\nE_n(x^{n+1}) = \\int_{-1/2}^{1/2} \\tilde{\\pi}_{n+1}(u) \\,du = 0\n$$\n因此，当 $n$ 为偶数时，求积法则对 $k=n+1$ 是精确的。\n\n情况 2：$n$ 是奇数。\n在这种情况下，$n+1$ 是偶数，$\\tilde{\\pi}_{n+1}(u)$ 是一个偶函数。一个非恒等于零的偶多项式在对称区间 $[-a,a]$ 上的积分不为零，除非它恒等于零。$\\tilde{\\pi}_{n+1}(u)$ 是一个次数为 $n+1$ 的非零多项式，所以它的积分非零。例如，当 $n=1$ 时，我们得到梯形法则，误差积分为 $\\int_0^1 x(x-1)dx = [x^3/3 - x^2/2]_0^1 = 1/3 - 1/2 = -1/6 \\neq 0$。\n因此，当 $n$ 为奇数时，求积法则对 $k=n+1$ 不精确。\n\n结果总结：\n- 对于任何 $n$，$Q_n(x^k)$ 对 $k=0, 1, \\dots, n$ 精确。\n- 如果 $n$ 是偶数，$Q_n(x^{n+1})$ 也精确。可以证明 $Q_n(x^{n+2})$ 不精确。\n- 如果 $n$ 是奇数，$Q_n(x^{n+1})$ 不精确。\n\n问题要求在集合 $\\{0, 1, \\dots, n+1\\}$ 中该法则精确的最大整数 $k$。\n- 如果 $n$ 是偶数，该法则对 $k=0, \\dots, n, n+1$ 精确。这样的最大 $k$ 是 $n+1$。\n- 如果 $n$ 是奇数，该法则对 $k=0, \\dots, n$ 精确，但对 $k=n+1$ 不精确。这样的最大 $k$ 是 $n$。\n\n我们需要为此结果找到一个单一的闭式表达式。当 $n$ 为偶数时，该值为 $n+1$；当 $n$ 为奇数时，该值为 $n$。这可以写成：\n$$\nk_{\\text{max}} = n + \\begin{cases} 1  \\text{若 } n \\text{ 为偶数} \\\\ 0  \\text{若 } n \\text{ 为奇数} \\end{cases}\n$$\n这种分情况讨论可以用 $(-1)^n$ 来表示，它在 $n$ 为偶数时为 $1$，在 $n$ 为奇数时为 $-1$。附加项的表达式为 $\\frac{1+(-1)^n}{2}$。当 $n$ 为偶数时，此表达式为 $1$；当 $n$ 为奇数时，为 $0$。\n因此，最大整数 $k$ 由表达式 $n + \\frac{1+(-1)^n}{2}$ 给出。",
            "answer": "$$\n\\boxed{n + \\frac{1+(-1)^{n}}{2}}\n$$"
        },
        {
            "introduction": "理论精度是一回事，但在实际问题上的表现则是另一回事。物理和工程领域的积分常常包含奇异点，这些奇异点无法用光滑多项式很好地近似。在本练习中，我们将推导一个简单的开型 Newton-Cotes 规则，并将其应用于一个带有常见端点奇异性的函数 $x^{-1/2}$。这项实践  突出了 Newton-Cotes 方法的一个关键局限性，并促使我们思考其适用范围，从而引出对坐标变换或加权求积等更高级技术的需求，这些技术在谱方法和间断 Galerkin 方法中至关重要。",
            "id": "3401936",
            "problem": "在高阶间断伽辽金 (DG) 和谱元离散的背景下，边界邻近积分可能会表现出代数端点奇点，这对标准的闭式牛顿-柯特斯求积公式构成了挑战。考虑积分\n$$\n\\int_{0}^{1} x^{-1/2}\\,dx,\n$$\n该积分是可积的，但在左端点有一个平方根奇点。为了模拟 DG 通量积分中排除端点的常见做法，请从第一性原理推导在区间 $[0,1]$ 上具有等距内节点的三点开式牛顿-柯特斯求积法则，并用它来生成一个近似上述积分的单一精确解析表达式。\n\n您的推导必须从基本定义开始：在三个等距内节点上构建2次拉格朗日插值多项式，并将其在 $[0,1]$ 上精确积分以获得求积权重。然后，将得到的求积公式应用于函数 $f(x)=x^{-1/2}$，在指定节点上进行求值，以获得所要求的精确解析表达式。\n\n最后，请解释为什么变量替换（使端点奇点正则化）或与奇异权重对齐的加权正交多项式求积能够显著提高谱方法和间断伽辽金 (DG) 方法的精度，解释过程不得引用任何预先制表的求积公式。您可以引用高斯-雅可比求积（首次使用时全称为 Gauss–Jacobi Quadrature (GJQ)）来从概念上说明加权方法，但不要计算任何替代的数值近似值。\n\n不要进行四舍五入；以单一闭式解析表达式的形式提供开式牛顿-柯特斯近似值。",
            "solution": "任务是推导并应用三点开式牛顿-柯特斯求积法则来近似积分 $\\int_{0}^{1} x^{-1/2}\\,dx$，然后为处理此类奇异积分时替代方法的优越性提供概念性解释。\n\n首先，我们推导在区间 $[0, 1]$ 上的三点开式牛顿-柯特斯求积法则。该法则使用三个等距的内节点。对于区间 $[a, b]$ 和 $n=3$ 个内节点，步长 $h$ 由 $h = (b-a)/(n+1)$ 给出。当 $a=0$ 且 $b=1$ 时，我们有 $h = (1-0)/(3+1) = 1/4$。对于 $j=1, 2, 3$，节点 $x_j$ 位于 $x_j = a + j h$。\n求积节点为：\n$$\nx_1 = 0 + 1 \\cdot \\frac{1}{4} = \\frac{1}{4} \\\\\nx_2 = 0 + 2 \\cdot \\frac{1}{4} = \\frac{1}{2} \\\\\nx_3 = 0 + 3 \\cdot \\frac{1}{4} = \\frac{3}{4}\n$$\n求积法则通过对穿过这些节点的2次拉格朗日插值多项式 $P_2(x)$ 进行积分来近似函数 $f(x)$ 的积分。该多项式由 $P_2(x) = \\sum_{j=1}^{3} f(x_j) L_j(x)$ 给出，其中 $L_j(x)$ 是拉格朗日基多项式。\n求积近似值为 $\\int_0^1 f(x) dx \\approx \\int_0^1 P_2(x) dx = \\sum_{j=1}^{3} f(x_j) \\left(\\int_0^1 L_j(x) dx\\right) = \\sum_{j=1}^{3} w_j f(x_j)$。权重 $w_j$ 是基多项式 $L_j(x)$ 在 $[0, 1]$ 上的积分。\n\n对于节点 $x_1=1/4$, $x_2=1/2$, 和 $x_3=3/4$，拉格朗日基多项式为：\n$$\nL_1(x) = \\frac{(x-x_2)(x-x_3)}{(x_1-x_2)(x_1-x_3)} = \\frac{(x-1/2)(x-3/4)}{(1/4-1/2)(1/4-3/4)} = \\frac{x^2 - \\frac{5}{4}x + \\frac{3}{8}}{(-\\frac{1}{4})(-\\frac{2}{4})} = \\frac{x^2 - \\frac{5}{4}x + \\frac{3}{8}}{1/8} = 8x^2 - 10x + 3\n$$\n$$\nL_2(x) = \\frac{(x-x_1)(x-x_3)}{(x_2-x_1)(x_2-x_3)} = \\frac{(x-1/4)(x-3/4)}{(1/2-1/4)(1/2-3/4)} = \\frac{x^2 - x + \\frac{3}{16}}{(\\frac{1}{4})(-\\frac{1}{4})} = \\frac{x^2 - x + \\frac{3}{16}}{-1/16} = -16x^2 + 16x - 3\n$$\n$$\nL_3(x) = \\frac{(x-x_1)(x-x_2)}{(x_3-x_1)(x_3-x_2)} = \\frac{(x-1/4)(x-1/2)}{(3/4-1/4)(3/4-1/2)} = \\frac{x^2 - \\frac{3}{4}x + \\frac{1}{8}}{(\\frac{2}{4})(\\frac{1}{4})} = \\frac{x^2 - \\frac{3}{4}x + \\frac{1}{8}}{1/8} = 8x^2 - 6x + 1\n$$\n接下来，我们通过将这些多项式从 $0$ 到 $1$ 积分来计算权重 $w_j$：\n$$\nw_1 = \\int_{0}^{1} (8x^2 - 10x + 3) dx = \\left[ \\frac{8}{3}x^3 - 5x^2 + 3x \\right]_{0}^{1} = \\frac{8}{3} - 5 + 3 = \\frac{2}{3}\n$$\n$$\nw_2 = \\int_{0}^{1} (-16x^2 + 16x - 3) dx = \\left[ -\\frac{16}{3}x^3 + 8x^2 - 3x \\right]_{0}^{1} = -\\frac{16}{3} + 8 - 3 = -\\frac{1}{3}\n$$\n$$\nw_3 = \\int_{0}^{1} (8x^2 - 6x + 1) dx = \\left[ \\frac{8}{3}x^3 - 3x^2 + x \\right]_{0}^{1} = \\frac{8}{3} - 3 + 1 = \\frac{2}{3}\n$$\n因此，在 $[0, 1]$ 上的三点开式牛顿-柯特斯法则是：\n$$\n\\int_0^1 f(x) dx \\approx \\frac{2}{3}f\\left(\\frac{1}{4}\\right) - \\frac{1}{3}f\\left(\\frac{1}{2}\\right) + \\frac{2}{3}f\\left(\\frac{3}{4}\\right)\n$$\n现在，我们将此法则应用于函数 $f(x) = x^{-1/2}$。求积法则的开式性质至关重要，因为它避免了在奇点 $x=0$ 处对函数求值。\n我们在节点上计算 $f(x)$ 的值：\n$$\nf(x_1) = f\\left(\\frac{1}{4}\\right) = \\left(\\frac{1}{4}\\right)^{-1/2} = 4^{1/2} = 2\n$$\n$$\nf(x_2) = f\\left(\\frac{1}{2}\\right) = \\left(\\frac{1}{2}\\right)^{-1/2} = 2^{1/2} = \\sqrt{2}\n$$\n$$\nf(x_3) = f\\left(\\frac{3}{4}\\right) = \\left(\\frac{3}{4}\\right)^{-1/2} = \\left(\\frac{4}{3}\\right)^{1/2} = \\frac{2}{\\sqrt{3}} = \\frac{2\\sqrt{3}}{3}\n$$\n将这些值代入求积公式，得到积分的近似值：\n$$\n\\int_{0}^{1} x^{-1/2}\\,dx \\approx \\frac{2}{3}(2) - \\frac{1}{3}(\\sqrt{2}) + \\frac{2}{3}\\left(\\frac{2\\sqrt{3}}{3}\\right) = \\frac{4}{3} - \\frac{\\sqrt{2}}{3} + \\frac{4\\sqrt{3}}{9}\n$$\n为了将其表示为单个分数，我们找到公分母，即 $9$：\n$$\n\\frac{4 \\cdot 3}{9} - \\frac{\\sqrt{2} \\cdot 3}{9} + \\frac{4\\sqrt{3}}{9} = \\frac{12 - 3\\sqrt{2} + 4\\sqrt{3}}{9}\n$$\n\n最后，我们解释为什么对于这类问题，替代方法更为优越。核心问题在于，牛顿-柯特斯法则使用一个单一的、全局光滑的多项式来近似被积函数 $f(x)$。函数 $f(x) = x^{-1/2}$ 在 $x=0$ 处有一条垂直渐近线，并且其各阶导数在该点也是奇异的。没有任何一个低次多项式能够准确地在整个区间 $[0, 1]$ 上捕捉这种行为。光滑多项式逼近与奇异函数之间的这种不匹配导致了巨大的误差和缓慢的收敛速度，这在高阶方法（如 DG 和谱元法）中是一个严重问题，因为这些方法在处理光滑问题时追求快速（指数级）收敛。\n\n两种更优的策略是：\n1.  **变量替换（正则化）**：该技术将积分变换为一个具有正则（光滑）被积函数的积分。对于 $\\int_0^1 x^{-1/2} dx$，使用替换 $x = u^2$ 和 $dx = 2u\\,du$ 将积分变换为 $\\int_0^1 (u^2)^{-1/2} (2u\\,du) = \\int_0^1 u^{-1} (2u\\,du) = \\int_0^1 2\\,du$。新的被积函数是一个常数 $g(u)=2$，它是无穷光滑的。现在，任何标准的求积法则都可以以非常高（通常是精确）的精度对其进行积分。这消除了奇点，恢复了高阶方法的快速收敛性。\n\n2.  **加权正交多项式求积**：这种方法修改求积法则，使其对特定类别的奇异函数达到最优。该积分被视为 $\\int_0^1 w(x)g(x)dx$，其中 $w(x)=x^{-1/2}$ 是一个权重函数，$g(x)=1$。高斯求积法则为给定数量的节点提供针对特定权重函数的最佳精度。对于区间 $[-1, 1]$ 上形式为 $(1-z)^\\alpha (1+z)^\\beta$ 的权重函数，相应的最优法则是高斯-雅可比求积（GJQ）。$[0, 1]$ 上的奇点 $x^{-1/2}$ 可以映射到 $[-1, 1]$ 上的一个雅可比类型的权重。GJQ 法则的节点和权重是专门选择的，旨在精确积分权重函数与高达某个高次多项式的乘积。通过将奇异行为“构建”到求积法则本身中，GJQ 即使使用很少的节点也能达到非常高的精度，因为它只需要近似被积函数的非奇异部分（在本例中为 $g(x)=1$），而这部分是微不足道的。在谱方法和 DG 方法中，这对应于使用相对于奇异权重正交的基函数（例如，雅可比多项式），这也再次恢复了指数收敛性。\n\n相比之下，为无权积分（即 $w(x)=1$）设计的牛顿-柯特斯公式从根本上不适合这项任务，其精度无法仅仅通过增加节点数量来大幅提高。",
            "answer": "$$\n\\boxed{\\frac{12 - 3\\sqrt{2} + 4\\sqrt{3}}{9}}\n$$"
        },
        {
            "introduction": "在谱方法和间断 Galerkin (DG) 方法中，选择求积公式不仅仅是为了保证积分精度，它还会直接影响整个数值格式的稳定性。众所周知，高阶 Newton-Cotes 公式会出现负权系数，这可能会破坏离散算子必要的数学性质。这项综合性练习  将具体展示使用高阶 Newton-Cotes 公式如何破坏离散扩散算子的对称正定性，从而将抽象的数值分析概念（求积权）与偏微分方程求解器的实际稳定性联系起来，并强调了为何保证权系数为正的求积方法（如高斯求积）在高阶离散中更受青睐。",
            "id": "3401958",
            "problem": "考虑一维扩散算子的间断 Galerkin (DG) 形式，该算子被限制在映射到参考区间 $\\left[-1,1\\right]$ 的单个单元上。扩散双线性形式的单元体积贡献定义为\n$$\na(u,v) \\;=\\; \\int_{-1}^{1} \\partial_x u(x)\\,\\partial_x v(x)\\,\\mathrm{d}x,\n$$\n其中 $u$ 和 $v$ 属于参考单元上的一个多项式空间。在谱 DG 实践中，一种常见的选择是使用 $\\left[-1,1\\right]$ 上的 Legendre 多项式 $\\{P_n(x)\\}_{n\\ge 0}$ 来表示函数。为避免扩散能中的零模态，我们考虑由 $\\{P_n(x)\\}_{n=1}^{p}$ 张成的子空间，即我们排除了常数模态 $P_0$。\n\n数值积分通过 Newton-Cotes 求积公式执行。设一个闭合 Newton-Cotes 法则在 $\\left[-1,1\\right]$ 上由 $N$ 个包括端点在内的等距节点定义：\n$$\nx_k \\;=\\; -1 + \\frac{2k}{N-1}, \\quad k=0,1,\\dots,N-1,\n$$\n并具有相关的权重 $\\{w_k\\}_{k=0}^{N-1}$。该求积公式通过加权和 $\\sum_{k=0}^{N-1} w_k\\,g(x_k)$ 来近似 $\\int_{-1}^{1} g(x)\\,\\mathrm{d}x$ 形式的积分。闭合 Newton-Cotes 权重由其对最高 $N-1$ 次的代数单项式的精确性来定义：\n$$\n\\sum_{k=0}^{N-1} w_k\\,x_k^m \\;=\\; \\int_{-1}^{1} x^m\\,\\mathrm{d}x, \\quad m=0,1,\\dots,N-1.\n$$\n众所周知，对于足够大的 $N$，一些闭合 Newton-Cotes 权重会变为负值。欠积分指的是使用一个求积公式，其精确阶数低于在所选多项式空间上精确积分双线性形式所需的阶数。\n\n离散单元算子（双线性形式的 Gram 矩阵）构造如下。令 $D(x)$ 表示 Legendre 基函数导数的列向量，\n$$\nD(x) \\;=\\; \\begin{bmatrix} P_1'(x) \\\\ P_2'(x) \\\\ \\vdots \\\\ P_p'(x) \\end{bmatrix},\n$$\n并定义离散 Gram 矩阵 $G\\in\\mathbb{R}^{p\\times p}$ 为\n$$\nG \\;=\\; \\sum_{k=0}^{N-1} w_k\\, D(x_k)\\,D(x_k)^\\top.\n$$\n该构造对应于对所有基函数索引 $i,j$ 的被积函数 $\\partial_x P_i(x)\\,\\partial_x P_j(x)$ 应用闭合 Newton-Cotes 求积。如果 $G$ 的最小特征值为非正数，则双线性形式的对称正定性会丧失，这可能是由秩亏（例如，欠积分导致零特征值）或不定性（例如，负权重导致负特征值）引起的。\n\n您的任务是实现一个程序，对于一组给定的多项式阶数 $p$ 和求积点数 $N$，通过上述过程构造 $G$，计算其谱，并确定对称正定性是否丧失。使用以下测试套件：\n- 案例 1：$p=3$, $N=5$。\n- 案例 2：$p=5$, $N=4$（欠积分，求积点数少于基维度）。\n- 案例 3：$p=9$, $N=11$（具有已知负权重的高阶闭合 Newton-Cotes）。\n- 案例 4：$p=1$, $N=2$（基准梯形法则）。\n- 案例 5：$p=8$, $N=9$（具有负权重的闭合 Newton-Cotes）。\n\n对于每种情况：\n1. 通过在 $\\left[-1,1\\right]$ 上的等距节点上强制多项式精确性达到 $N-1$ 次，构造闭合 Newton-Cotes 权重 $\\{w_k\\}_{k=0}^{N-1}$。\n2. 在所有求积节点 $x_k$ 处，计算 $n=1,\\dots,p$ 的 $P_n'(x_k)$。\n3. 如上组装 $G$，并通过取 $\\frac{1}{2}\\left(G+G^\\top\\right)$ 将其对称化。\n4. 按升序计算 $G$ 的排序特征值。\n5. 通过检查最小特征值是否小于或等于容差 $\\varepsilon=10^{-10}$ 来确定对称正定性是否丧失。\n\n您的程序必须输出单行，其中包含一个列表，其长度等于测试用例的数量。此列表中的每个条目本身都必须是一个列表，由排序后的特征值（浮点数）和一个指示对称正定性是否丧失的布尔值组成（如果最小特征值 $\\le \\varepsilon$，则使用 $True$，否则使用 $False$）。例如，输出格式必须类似于\n$$\n\\big[ \\,[\\lambda_1,\\lambda_2,\\dots,\\lambda_p,\\text{flag}],\\; \\dots \\,\\big],\n$$\n打印的字符串中没有空格。\n\n不涉及物理单位或角度单位。所有数值必须表示为浮点数，所有逻辑决策必须表示为布尔值。您的程序生成的最后一行应与上述列表完全相同，打印为单行，条目之间用逗号分隔，并用方括号括起来。",
            "solution": "该问题要求分析一个离散一维扩散算子的对称正定性，该算子在间断 Galerkin (DG) 框架内，使用 Legendre 多项式的谱基构造。积分使用闭合 Newton-Cotes 求积法则进行数值计算。对于给定的多项式阶数 $p$ 和求积点数 $N$，我们需要构造离散 Gram 矩阵 $G$，计算其特征值，并确定正定性是否丧失。正定性的丧失定义为最小特征值小于或等于容差 $\\varepsilon = 10^{-10}$。\n\n该过程涉及几个不同的数学和计算步骤，详述如下。\n\n首先，我们定义计算环境。分析在参考单元，即区间 $\\left[-1, 1\\right]$ 上进行。DG 空间的多项式基选择为 $\\{P_n(x)\\}_{n=1}^p$，其中 $P_n(x)$ 是 $n$ 次 Legendre 多项式。排除常数模态 $P_0(x)$ 以消除扩散算子的平凡零模态。\n\n问题的核心在于离散 Gram 矩阵 $G$ 的构造和分析，其元素由双线性形式 $a(u,v) = \\int_{-1}^{1} (\\partial_x u)(\\partial_x v) \\mathrm{d}x$（其中 $u=P_i(x)$ 且 $v=P_j(x)$）的数值求积给出。离散矩阵 $G \\in \\mathbb{R}^{p\\times p}$ 定义为：\n$$\nG_{ij} = \\sum_{k=0}^{N-1} w_k P_i'(x_k) P_j'(x_k).\n$$\n\n对于每个测试用例 $(p, N)$，总体算法如下：\n\n1.  **构造闭合 Newton-Cotes 求积法则**\n\n    在区间 $\\left[-1, 1\\right]$ 上具有 $N$ 个点的闭合 Newton-Cotes 求积法则由一组 $N$ 个等距节点 $\\{x_k\\}_{k=0}^{N-1}$ 和相应的权重 $\\{w_k\\}_{k=0}^{N-1}$ 定义。\n\n    节点由以下公式给出：\n    $$\n    x_k = -1 + \\frac{2k}{N-1}, \\quad \\text{for } k=0, 1, \\dots, N-1.\n    $$\n    权重通过强制该求积法则精确积分最高 $N-1$ 次的多项式来确定。这导致了一个关于 $N$ 个权重的 $N$ 个线性方程组：\n    $$\n    \\sum_{k=0}^{N-1} w_k x_k^m = \\int_{-1}^{1} x^m \\mathrm{d}x, \\quad \\text{for } m=0, 1, \\dots, N-1.\n    $$\n    右侧的积分计算结果为：\n    $$\n    \\int_{-1}^{1} x^m \\mathrm{d}x = \\frac{1 - (-1)^{m+1}}{m+1} = \\begin{cases} \\frac{2}{m+1}  \\text{如果 } m \\text{ 是偶数} \\\\ 0  \\text{如果 } m \\text{ 是奇数} \\end{cases}.\n    $$\n    该线性系统可以写成矩阵形式 $V \\mathbf{w} = \\mathbf{b}$，其中 $V$ 是一个 Vandermonde 矩阵，其元素为 $V_{mk} = x_k^m$，$\\mathbf{w}$ 是权重列向量 $[w_0, \\dots, w_{N-1}]^\\top$，$\\mathbf{b}$ 是单项式积分的列向量。求解该系统可得到所需的权重。对于 $N \\ge 9$（以及像 $N=8$ 这样的其他一些值），这些权重中的一些会变为负值，这可能会损害所得离散算子的正定性。\n\n2.  **计算 Legendre 多项式的导数**\n\n    基函数是 Legendre 多项式 $\\{P_n(x)\\}_{n=1}^p$。我们需要它们的一阶导数 $\\{P_n'(x)\\}_{n=1}^p$。这些导数本身也是多项式。对于每个基函数 $P_n'(x)$，我们必须在所有求积节点 $\\{x_k\\}$ 处对其进行求值。这将产生一组值 $P_n'(x_k)$，其中 $n \\in \\{1, \\dots, p\\}$ 且 $k \\in \\{0, \\dots, N-1\\}$。这些求值结果可以组织成一个矩阵 $D_{\\text{eval}} \\in \\mathbb{R}^{p \\times N}$，其中 $(D_{\\text{eval}})_{nk} = P_{n+1}'(x_k)$（行使用基于 0 的索引）。\n\n3.  **组装离散 Gram 矩阵 $G$**\n\n    Gram 矩阵 $G$ 由以下求和定义：\n    $$\n    G = \\sum_{k=0}^{N-1} w_k D(x_k) D(x_k)^\\top,\n    $$\n    其中 $D(x_k)$ 是在节点 $x_k$ 处求值的基函数导数列向量：\n    $$\n    D(x_k) = \\begin{bmatrix} P_1'(x_k) \\\\ P_2'(x_k) \\\\ \\vdots \\\\ P_p'(x_k) \\end{bmatrix}.\n    $$\n    使用上一步中的求值矩阵 $D_{\\text{eval}}$ 和对角矩阵 $W = \\text{diag}(w_0, \\dots, w_{N-1})$，矩阵 $G$ 可以高效地计算为：\n    $$\n    G = D_{\\text{eval}} W D_{\\text{eval}}^\\top.\n    $$\n    从这个构造中，我们可以推断出秩亏的潜在来源。$G$ 的秩最多为 $W$ 的秩（如果所有权重非零，则为 $N$），且最多为 $D_{\\text{eval}}$ 的秩（最多为 $\\min(p, N)$）。如果 $N  p$，$G$ 的秩最多为 $N$，这意味着 $G$ 将是一个秩小于 $p$ 的 $p \\times p$ 矩阵。因此，它将至少有 $p-N$ 个零特征值，导致正定性丧失。这种情况被称为欠积分。\n\n4.  **分析对称正定性**\n\n    理论上，这样构造的矩阵 $G$ 是对称的。然而，由于浮点运算，可能会出现微小的不对称性。为确保对称矩阵的有效特征值分解，我们首先显式地对称化 $G$：\n    $$\n    G_{\\text{sym}} = \\frac{1}{2} (G + G^\\top).\n    $$\n    接下来，我们计算 $G_{\\text{sym}}$ 的特征值。由于 $G_{\\text{sym}}$ 是一个实对称矩阵，其所有特征值都是实数。我们将这些特征值按升序排序：$\\lambda_1 \\le \\lambda_2 \\le \\dots \\le \\lambda_p$。\n\n    一个矩阵是当且仅当其所有特征值都严格为正时，才是对称正定的。该问题将对称正定性的丧失定义为最小特征值 $\\lambda_1$ 为非正的情况。我们使用给定的容差 $\\varepsilon = 10^{-10}$ 来检查这个条件：\n    $$\n    \\text{对称正定性丧失} \\iff \\lambda_1 \\le \\varepsilon.\n    $$\n    根据此结果设置一个布尔标志（$True$ 表示丧失，$False$ 表示保留）。每种情况的最终结果包括排序后的特征值列表和这个布尔标志。\n\n将此过程应用于每个指定的测试用例，并将结果汇总为最终的输出格式。所选的测试用例旨在突出不同的数值现象：稳定积分（$p=3, N=5$）、欠积分引起的秩亏（$p=5, N=4$）以及负求积权重引起的不定性（$p=9, N=11$ 和 $p=8, N=9$）。案例 $p=1, N=2$ 作为一个简单、稳定的基准，对应于梯形法则。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases, analyzing the symmetric positive\n    definiteness of a DG diffusion operator matrix.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 5),   # Case 1\n        (5, 4),   # Case 2\n        (9, 11),  # Case 3\n        (1, 2),   # Case 4\n        (8, 9),   # Case 5\n    ]\n    \n    epsilon = 1e-10\n    all_results = []\n\n    for p, N in test_cases:\n        # Step 1: Construct the Closed Newton-Cotes Quadrature Rule\n        # Generate N equispaced nodes on [-1, 1]\n        nodes = np.linspace(-1.0, 1.0, N)\n\n        # Determine weights by solving the linear system for polynomial exactness\n        # The system is V.T @ w = b, where V is a Vandermonde matrix\n        V = np.vander(nodes, N, increasing=True).T\n        \n        # Right-hand side: integrals of x^m from -1 to 1\n        b = np.zeros(N)\n        for m in range(N):\n            if (m + 1) % 2 != 0:\n                b[m] = 2.0 / (m + 1)\n        \n        weights = np.linalg.solve(V, b)\n\n        # Step 2: Evaluate Derivatives of Legendre Polynomials\n        # D_eval is a p x N matrix where D_eval[i, j] = P_{i+1}'(nodes[j])\n        D_eval = np.zeros((p, N))\n        for n_poly in range(1, p + 1):\n            P_n = legendre(n_poly)\n            P_n_prime = P_n.deriv()\n            D_eval[n_poly - 1, :] = P_n_prime(nodes)\n\n        # Step 3: Assemble the Discrete Gram Matrix G\n        # G = D_eval @ diag(weights) @ D_eval.T\n        G = D_eval @ np.diag(weights) @ D_eval.T\n        \n        # Step 4: Analyze Symmetric Positive Definiteness\n        # Symmetrize the matrix to correct for potential floating point inaccuracies\n        G_sym = 0.5 * (G + G.T)\n        \n        # Compute eigenvalues. eigvalsh returns them sorted in ascending order.\n        eigenvalues = np.linalg.eigvalsh(G_sym)\n        \n        # Check if the smallest eigenvalue is non-positive within the tolerance\n        is_lost = eigenvalues[0] = epsilon\n        \n        # Format the result for this test case\n        result_case = eigenvalues.tolist() + [is_lost]\n        all_results.append(result_case)\n\n    # Final print statement in the exact required format.\n    results_str_list = []\n    for res in all_results:\n        # The last element is a boolean, the rest are floats.\n        # str() on a boolean gives 'True' or 'False' with a capital letter, as required.\n        str_vals = [f\"{v}\" for v in res]\n        results_str_list.append(f\"[{','.join(str_vals)}]\")\n    \n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```"
        }
    ]
}