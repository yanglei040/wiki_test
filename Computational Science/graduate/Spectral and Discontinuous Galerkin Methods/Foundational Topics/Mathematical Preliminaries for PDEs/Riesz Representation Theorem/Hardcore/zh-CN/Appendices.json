{
    "hands_on_practices": [
        {
            "introduction": "将抽象的理论转化为高效的计算方法，第一步是理解不同数学选择所带来的结构性影响。本实践旨在探讨函数空间中基底选择的核心作用。通过在标准 $L^2$ 内积下比较勒让德 (Legendre) 多项式基和切比雪夫 (Chebyshev) 多项式基，您将深入理解正交性和奇偶性等基本性质如何直接决定格兰姆 (Gram) 矩阵的稀疏性，这对于设计高效的数值求解器至关重要。",
            "id": "3413340",
            "problem": "在区间 $[-1,1]$ 上的高阶谱方法和间断 Galerkin (DG) 方法中，通常将在一个被赋予标准 $L^2$ 内积的有限维多项式空间中近似函数。设 $V_N$ 表示 $(N+1)$ 维空间 $V_N=\\operatorname{span}\\{\\varphi_0,\\dots,\\varphi_N\\}$，其内积为 $\\langle u,v\\rangle=\\int_{-1}^1 u(x)\\,v(x)\\,dx$。考虑 $V_N$ 的两种基的选择：由 Legendre 多项式构成的 Legendre 基 $\\{\\varphi_n\\}=\\{P_n\\}_{n=0}^N$ 和由第一类 Chebyshev 多项式构成的 Chebyshev 基 $\\{\\varphi_n\\}=\\{T_n\\}_{n=0}^N$。对于由 $F(u)=u(0)$ 定义的线性泛函 $F:V_N\\to\\mathbb{R}$，Riesz 表示定理保证了存在唯一的 $r\\in V_N$，使得对于所有 $v\\in V_N$，都有 $\\langle r, v\\rangle = F(v)$。\n\n设 $G\\in\\mathbb{R}^{(N+1)\\times(N+1)}$ 表示 Gram 矩阵，其元素为 $G_{ij}=\\langle \\varphi_i,\\varphi_j\\rangle$；设 $c\\in\\mathbb{R}^{N+1}$ 表示 $r$ 在所选基下的系数向量，使得 $r=\\sum_{j=0}^N c_j \\varphi_j$；并设 $b\\in\\mathbb{R}^{N+1}$ 表示数据向量 $b_j=F(\\varphi_j)=\\varphi_j(0)$。那么 $c$ 是线性系统 $G c = b$ 的解。\n\n仅使用以下基本性质：(i) Legendre 多项式在 $[-1,1]$ 上关于权重 $w(x)=1$ 是正交的，(ii) 第一类 Chebyshev 多项式在 $[-1,1]$ 上关于权重 $w(x)=(1-x^2)^{-1/2}$ 是正交的，但关于权重 $w(x)=1$ 不是正交的，以及 (iii) $P_n$ 和 $T_n$ 都具有奇偶性 $P_n(-x)=(-1)^n P_n(x)$ 和 $T_n(-x)=(-1)^n T_n(x)$，请比较在相同的标准 $L^2$ 内积 $\\langle\\cdot,\\cdot\\rangle$ 下，这两种基的 Gram 矩阵 $G$ 的稀疏模式和系数向量 $c$ 的结构。\n\n选择所有正确的陈述。\n\nA. 对于 Legendre 基 $\\{P_n\\}_{n=0}^N$ 和标准 $L^2([-1,1])$ 内积，$G$ 是对角矩阵，且 Riesz 表示子的系数满足 $c_{2k+1}=0$ 和 $c_{2k} = P_{2k}(0)\\big/\\|P_{2k}\\|_{L^2([-1,1])}^2$，对所有满足 $0\\le 2k\\le N$ 的整数 $k$ 成立。\n\nB. 对于 Chebyshev 基 $\\{T_n\\}_{n=0}^N$ 和标准 $L^2([-1,1])$ 内积，$G$ 是对角矩阵，因此对所有满足 $0\\le n\\le N$ 的整数 $n$，$c_n = T_n(0)\\big/\\|T_n\\|_{L^2([-1,1])}^2$。\n\nC. 对于 Chebyshev 基 $\\{T_n\\}_{n=0}^N$ 和标准 $L^2([-1,1])$ 内积，当 $i+j$ 为奇数时，$G_{ij}=0$，但偶-偶和奇-奇块通常是稠密的；Riesz 表示子有 $c_{2k+1}=0$，并且偶数系数 $c_{2k}$ 求解一个建立在偶-偶块上的耦合线性系统。\n\nD. 在两种基中，Riesz 表示子 $r$ 都与限制在 $V_N$ 上的 $x=0$ 处的 Dirac 分布一致。\n\nE. 在两种基中，奇偶性意味着 $G$ 相对于偶数次和奇数次的分解是块对角矩阵；因此，对于 $F(u)=u(0)$，系统 $G c = b$ 的奇数块是齐次的，并迫使所有满足 $2k+1\\le N$ 的整数 $k$ 都有 $c_{2k+1}=0$。",
            "solution": "首先将验证问题陈述的科学合理性、一致性和清晰性。\n\n### 步骤 1：提取已知条件\n- **问题域：** 区间为 $[-1, 1]$。\n- **函数空间：** $V_N = \\operatorname{span}\\{\\varphi_0, \\dots, \\varphi_N\\}$，一个 $(N+1)$ 维多项式空间。\n- **内积：** 标准 $L^2$ 内积，$\\langle u, v \\rangle = \\int_{-1}^1 u(x)v(x)dx$。\n- **$V_N$ 的基**：\n    1. Legendre 基：$\\{\\varphi_n\\} = \\{P_n\\}_{n=0}^N$。\n    2. Chebyshev 基 (第一类)：$\\{\\varphi_n\\} = \\{T_n\\}_{n=0}^N$。\n- **线性泛函：** $F: V_N \\to \\mathbb{R}$ 定义为 $F(u) = u(0)$。\n- **Riesz 表示子：** 唯一的元素 $r \\in V_N$，使得对于所有 $v \\in V_N$ 都有 $\\langle r, v \\rangle = F(v)$。\n- **系统表示：** 表示子 $r = \\sum_{j=0}^N c_j \\varphi_j$ 的系数向量 $c \\in \\mathbb{R}^{N+1}$ 是线性系统 $Gc = b$ 的解，其中：\n    - Gram 矩阵：$G_{ij} = \\langle \\varphi_i, \\varphi_j \\rangle$。\n    - 数据向量：$b_j = F(\\varphi_j) = \\varphi_j(0)$。\n- **陈述的性质：**\n    - (i) Legendre 多项式 $\\{P_n\\}$ 在 $[-1, 1]$ 上关于权重函数 $w(x)=1$ 是正交的。\n    - (ii) Chebyshev 多项式 $\\{T_n\\}$ 在 $[-1, 1]$ 上关于权重函数 $w(x)=(1-x^2)^{-1/2}$ 是正交的，但关于 $w(x)=1$ 不是正交的。\n    - (iii) 两种基都具有确定的奇偶性：$P_n(-x) = (-1)^n P_n(x)$ 和 $T_n(-x) = (-1)^n T_n(x)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在泛函分析和偏微分方程数值方法领域内是良定义的。\n- **科学依据：** 该问题使用了多项式空间、 $L^2$ 内积、Legendre 和 Chebyshev 多项式以及 Riesz 表示定理的标准定义。所有概念和陈述的性质在数学上都是合理的，并且是文献中的标准内容。\n- **良定的：** 在有限维 Hilbert 空间 $(V_N, \\langle \\cdot, \\cdot \\rangle)$ 中，Riesz 表示子 $r$ 的存在性和唯一性是有保证的。线性系统 $Gc=b$ 有唯一解，因为对于任何线性无关函数的基，Gram 矩阵 $G$ 都是对称正定的。问题要求比较结构性质，这是一个有意义的数学探究。\n- **客观性：** 问题以精确、客观的数学语言陈述，没有歧义或主观性陈述。\n- **完备性与一致性：** 提供了所有必要的定义和性质。没有矛盾之处。Chebyshev 多项的正交权重与内积中使用的权重之间的关键区别被明确且正确地指出。\n\n### 步骤 3：结论与行动\n问题陈述是有效的。我将继续推导解决方案。\n\n### 推导\n问题的核心在于，在相同的内积 $\\langle u, v \\rangle = \\int_{-1}^1 u(x)v(x)dx$ 下，分析对于两种不同的基 $\\{\\varphi_n\\}$ 的选择，线性系统 $Gc = b$ 的结构。\n\n**基于奇偶性的一般分析（适用于两种基）**\n问题陈述指出，Legendre ($P_n$) 和 Chebyshev ($T_n$) 多项式都具有确定的奇偶性：$\\varphi_n(-x) = (-1)^n \\varphi_n(x)$。这个性质对系统 $Gc=b$ 具有深刻的结构性影响。\n\n1.  **Gram 矩阵 $G$ 的结构**：\n    其元素为 $G_{ij} = \\int_{-1}^1 \\varphi_i(x) \\varphi_j(x) dx$。被积函数是两个奇偶性分别为 $(-1)^i$ 和 $(-1)^j$ 的多项式的乘积，因此被积函数的奇偶性为 $(-1)^{i+j}$。积分区间是对称区间 $[-1, 1]$。\n    如果 $i+j$ 是奇数（即一个下标是偶数，另一个是奇数），被积函数 $\\varphi_i(x) \\varphi_j(x)$ 是一个奇函数。奇函数在对称区间上的积分为零。\n    $$ G_{ij} = 0 \\quad \\text{if } i+j \\text{ is odd.} $$\n    这意味着 Gram 矩阵 $G$ 是块对角矩阵，其中一个块耦合了偶数下标的基函数，另一个块耦合了奇数下标的基函数。\n\n2.  **数据向量 $b$ 的结构**：\n    其元素为 $b_j = F(\\varphi_j) = \\varphi_j(0)$。\n    在 $x=0$ 处使用奇偶性性质：$\\varphi_j(0) = (-1)^j \\varphi_j(0)$。\n    如果 $j$ 是奇数，这变成 $\\varphi_j(0) = - \\varphi_j(0)$，这意味着 $\\varphi_j(0) = 0$。\n    因此，对于任何奇数下标 $j=2k+1$，我们有 $b_{2k+1} = 0$。\n\n3.  **系数向量 $c$ 的结构**：\n    将下标划分为偶数 ($E$) 和奇数 ($O$)。系统 $Gc=b$ 解耦为两个独立的系统：\n    $$ G_{EE} c_E = b_E $$\n    $$ G_{OO} c_O = b_O $$\n    根据我们对 $b$ 的分析，向量 $b_O$ 是零向量。所以，第二个系统是一个齐次系统：\n    $$ G_{OO} c_O = 0 $$\n    函数 $\\{\\varphi_j\\}_{j \\in O}$ 是线性无关的。因此，由它们构造的 Gram 矩阵 $G_{OO}$ 是可逆的。齐次系统的唯一解是平凡解：$c_O = 0$。\n    这意味着所有对应于奇数下标基函数的系数都为零：\n    $$ c_{2k+1} = 0 \\quad \\text{for all } k \\text{ such that } 2k+1 \\le N. $$\n    这个结论对 Legendre 基和 Chebyshev 基都成立，因为它只依赖于它们共有的奇偶性。\n\n**具体分析：Legendre 基 $\\{P_n\\}$**\n-   **Gram 矩阵：** 根据性质 (i)，Legendre 多项式关于权重 $w(x)=1$ 是正交的。这意味着当 $i \\neq j$ 时，$\\langle P_i, P_j \\rangle = \\int_{-1}^1 P_i(x)P_j(x)dx = 0$。因此，$G$ 是一个对角矩阵。对角线元素为 $G_{nn} = \\langle P_n, P_n \\rangle = \\|P_n\\|_{L^2([-1,1])}^2$。\n-   **系统解：** 由于 $G$ 是对角的，系统 $Gc=b$ 的求解是平凡的：$G_{nn}c_n = b_n$，这给出 $c_n = b_n/G_{nn} = P_n(0) \\big/ \\|P_n\\|_{L^2([-1,1])}^2$。\n-   **系数：** 如一般推导所示，$P_{2k+1}(0)=0$，所以 $c_{2k+1}=0$。对于偶数下标，公式成立为 $c_{2k} = P_{2k}(0) \\big/ \\|P_{2k}\\|_{L^2([-1,1])}^2$。\n\n**具体分析：Chebyshev 基 $\\{T_n\\}$**\n-   **Gram 矩阵：** 根据性质 (ii)，Chebyshev 多项式关于权重 $w(x)=1$ *不是*正交的。因此，对于 $i \\neq j$，$G_{ij} = \\int_{-1}^1 T_i(x) T_j(x) dx$ 通常不为零。Gram 矩阵 $G$ **不是**对角矩阵。\n    如一般分析所示，$G$ 是块对角的。偶-偶块 $G_{EE}$ 和奇-奇块 $G_{OO}$ 将是非对角的（通常是稠密的）。例如，$T_0(x)=1, T_2(x)=2x^2-1$，所以 $G_{02} = \\int_{-1}^1 T_0(x)T_2(x)dx = \\int_{-1}^1 (2x^2-1)dx = [2x^3/3 - x]_{-1}^1 = -2/3 \\neq 0$。\n-   **系统解：** 系统解耦为 $G_{EE} c_E = b_E$ 和 $G_{OO} c_O = b_O$。\n-   **系数：** 如一般推导所示，$b_O=0$ 因此 $c_O = 0$ (即 $c_{2k+1}=0$)。偶数系数 $c_E$ 必须通过求解耦合线性系统 $G_{EE} c_E = b_E$ 来找到，其中 $b_E$ 包含元素 $T_{2k}(0)$。\n\n### 逐项分析\n\n**A. 对于 Legendre 基 $\\{P_n\\}_{n=0}^N$ 和标准 $L^2([-1,1])$ 内积，$G$ 是对角矩阵，且 Riesz 表示子的系数满足 $c_{2k+1}=0$ 和 $c_{2k} = P_{2k}(0)\\big/\\|P_{2k}\\|_{L^2([-1,1])}^2$，对所有满足 $0\\le 2k\\le N$ 的整数 $k$ 成立。**\n这个陈述与我们对 Legendre 基的具体分析完全一致。Legendre 多项式关于权重 $w(x)=1$ 的正交性使得标准 $L^2$ 内积的 Gram 矩阵 $G$ 是一个对角矩阵。随后的系数公式是其直接结果。\n**结论：正确。**\n\n**B. 对于 Chebyshev 基 $\\{T_n\\}_{n=0}^N$ 和标准 $L^2([-1,1])$ 内积，$G$ 是对角矩阵，因此对所有满足 $0\\le n\\le N$ 的整数 $n$，$c_n = T_n(0)\\big/\\|T_n\\|_{L^2([-1,1])}^2$。**\n这个陈述的前提就是错误的。问题明确指出（这也是一个已知事实）Chebyshev 多项式关于权重 $w(x)=1$ 不是正交的。因此，标准 $L^2$ 内积的 Gram 矩阵 $G$ 不是对角矩阵。结论是基于一个错误的前提。\n**结论：错误。**\n\n**C. 对于 Chebyshev 基 $\\{T_n\\}_{n=0}^N$ 和标准 $L^2([-1,1])$ 内积，当 $i+j$ 为奇数时，$G_{ij}=0$，但偶-偶和奇-奇块通常是稠密的；Riesz 表示子有 $c_{2k+1}=0$，并且偶数系数 $c_{2k}$ 求解一个建立在偶-偶块上的耦合线性系统。**\n这个陈述与我们对 Chebyshev 基的具体分析完全一致。奇偶性导致当 $i+j$ 为奇数时 $G_{ij}=0$。缺少标准 $L^2$ 正交性意味着块不是对角的（通常是稠密的）。基函数在 $x=0$ 处的奇偶性保证了 $b_{2k+1}=0$，这迫使 $c_{2k+1}=0$。然后，偶数系数 $c_{2k}$ 由涉及 $G$ 的偶-偶块的耦合系统确定。\n**结论：正确。**\n\n**D. 在两种基中，Riesz 表示子 $r$ 都与限制在 $V_N$ 上的 $x=0$ 处的 Dirac 分布一致。**\n这个陈述犯了范畴错误。Riesz 表示子 $r$ 是 $V_N$ 的一个元素，这意味着它是一个次数最多为 $N$ 的多项式。而 Dirac 分布 $\\delta_0$ 甚至不是 $L^2([-1,1])$ 中的函数，更不用说多项式了。两个数学对象“一致”意味着它们是等同的。一个多项式不可能与一个不是函数的分布等同。虽然 $r$ 确实是 $V_N$ 中满足对所有 $v \\in V_N$ 都有 $\\langle r, v \\rangle = v(0)$ 的唯一元素，这模拟了 Dirac delta 泛函在子空间 $V_N$ 上的作用，但术语“一致”是一种滥用，字面上是错误的。\n**结论：错误。**\n\n**E. 在两种基中，奇偶性意味着 $G$ 相对于偶数次和奇数次的分解是块对角矩阵；因此，对于 $F(u)=u(0)$，系统 $G c = b$ 的奇数块是齐次的，并迫使所有满足 $2k+1\\le N$ 的整数 $k$ 都有 $c_{2k+1}=0$。**\n这个陈述是对两种基所观察到的现象的正确概括。我们的一般分析表明，两种基共有的奇偶性 $\\varphi_n(-x)=(-1)^n\\varphi_n(x)$ 足以证明 $G$ 是块对角的。同样的奇偶性也意味着对于奇数 $j$，$b_j = \\varphi_j(0) = 0$。这使得针对奇数下标系数的线性系统 $G_{OO}c_O = b_O$ 是齐次的 ($b_O=0$)。由于奇数基函数是线性无关的，$G_{OO}$ 是可逆的，从而迫使解为 $c_O=0$，即 $c_{2k+1}=0$。该陈述完全正确且逻辑上合理。\n**结论：正确。**",
            "answer": "$$\\boxed{ACE}$$"
        },
        {
            "introduction": "认识到正交基能够简化问题后，我们便可以专注于计算离散 Riesz 表征的核心算法任务。本实践利用勒让德基在标准 $L^2$ 内积下的正交性，从而避免了矩阵求逆，让您能直接通过计算线性泛函在每个基函数上的作用来求解表征的系数。这个过程清晰地揭示了如何为间断伽辽金 (DG) 方法中常见的体积、界面和通量等不同类型的泛函构建其数值表征。",
            "id": "3413278",
            "problem": "给定参考一维单元 $K = [-1,1]$ 和局部间断 Galerkin (DG) 有限维空间 $V_p(K) = \\mathbb{P}_p(K)$，该空间由次数至多为 $p$ 的多项式构成。考虑配备有内积 $(u,v)_K = \\int_{K} u(x)\\,v(x)\\,dx$ 的希尔伯特空间 $(V_p(K),(\\cdot,\\cdot)_K)$。根据 Riesz 表示定理，对于每个有界线性泛函 $L: V_p(K)\\to\\mathbb{R}$，存在一个唯一的表示元 $r \\in V_p(K)$，使得对于所有 $v \\in V_p(K)$，都有 $(r,v)_K = L(v)$。您的任务是，对于间断 Galerkin (DG) 方法中常见的几种黑箱线性泛函，在每个单元上局部地通过算法计算这个离散 Riesz 表示元，并对计算结果进行数值验证和分析。\n\n基本依据和设置：\n- 使用 $K$ 上的 $L^2$ 内积定义以及多项式空间 $V_p(K)$ 的性质。\n- 对于 $K$ 上的数值积分，您必须使用具有 $n_q$ 个点的 Gauss–Legendre 求积，该方法对于次数高达 $2n_q-1$ 的多项式是精确的。您必须确保所选的 $n_q$ 足以精确计算次数 $\\leq 2p$ 的多项式所需积分，并能稳健地构建验证积分。\n- 使用 $[-1,1]$ 上的 Legendre 多项式基 $\\{P_n\\}_{n=0}^p$ 来表示 $V_p(K)$ 中的函数。\n\n待考虑的黑箱线性泛函：\n1. 体泛函：$L_{\\mathrm{vol}}(v) = \\int_K g(x)\\,v(x)\\,dx$，其中 $g(x)$ 明确给定为 $g(x) = x^2$。\n2. 左端点上的面求值泛函：$L_{\\mathrm{face}}(v) = v(-1)$。\n3. 两点数值通量泛函：$L_{\\mathrm{flux}}(v) = \\alpha\\,v(-1) + \\beta\\,v(1)$，其中 $\\alpha$ 和 $\\beta$ 是实数参数。\n\n算法要求：\n- 将每个泛函视为一个黑箱，可以在基函数上查询它，以形成计算其在 $V_p(K)$ 中的离散 Riesz 表示元所需的数据。\n- 在单个参考单元 $K$ 上，组装计算唯一 $r \\in V_p(K)$ 所需的离散对象，该 $r$ 满足对于所有 $v \\in V_p(K)$ 都有 $(r,v)_K = L(v)$。\n- 在每个单元上局部求解 $r$ 在 Legendre 基中的系数。\n\n测试套件：\n实现以下测试用例以验证正确性并研究复杂度。每个测试按规定生成一个布尔值或一个浮点数。\n- 案例 A（理想情况，精确可表示性）：次数 $p=3$，体泛函为 $g(x)=x^2$。计算其离散 Riesz 表示元 $r_{\\mathrm{vol}}$。在 $[-1,1]$ 区间的 $201$ 个等距点上评估 $r_{\\mathrm{vol}}(x)$ 和 $g(x)$，并计算最大绝对点态误差。返回一个布尔值，指示该误差是否小于 $\\varepsilon = 10^{-12}$。\n- 案例 B（面泛函）：次数 $p=4$，面泛函为 $L_{\\mathrm{face}}(v)=v(-1)$。通过使用具有足够多点的 Gauss–Legendre 求积，为每个基函数计算量 $(r_{\\mathrm{face}},\\phi_j)_K - L_{\\mathrm{face}}(\\phi_j)$，从而验证 Riesz 恒等式。返回一个布尔值，指示在所有基函数索引上的最大绝对值是否小于 $\\varepsilon = 10^{-12}$。\n- 案例 C（通量泛函，一般情况）：次数 $p=2$，通量参数为 $(\\alpha,\\beta)=(2,-1)$。如案例 B 一样验证 $(r_{\\mathrm{flux}},\\phi_j)_K - L_{\\mathrm{flux}}(\\phi_j)$，并返回一个布尔值，指示最大绝对值是否小于 $\\varepsilon = 10^{-12}$。\n- 案例 D（通量泛函，边界情况）：次数 $p=0$（常数），通量参数为 $(\\alpha,\\beta)=(3,5)$。计算 Riesz 表示元在基 $\\{P_0\\}$ 中的系数 $c_0$。返回一个布尔值，指示 $|c_0 - (\\alpha+\\beta)/2| < 10^{-15}$ 是否成立。\n- 案例 E（关于 $p$ 的复杂度）：使用一个反映每个单元的局部组装和直接稠密求解的成本模型，将每个单元的成本定义为 $C(p) = (p+1)^2\\,(p+3) + (p+1)^3$，其中第一项对应于使用 $n_q = p+3$ 个求积点组装内积和右端项，第二项对应于稠密线性求解。对于次数集合 $\\{2,4,6,8,10,12\\}$，计算 $\\log C(p)$ 相对于 $\\log p$ 的最小二乘斜率 $\\gamma$，并将此 $\\gamma$ 作为四舍五入到两位小数的浮点数返回。\n\n数值细节：\n- 对于组装过程，使用 $[-1,1]$ 上的 Legendre 多项式 $\\{P_n\\}_{n=0}^p$ 和具有 $n_q=p+3$ 个点的 Gauss–Legendre 求积。对于案例 B 和 C 中的验证积分，使用大小为 $n_q^{\\mathrm{check}} = 2p+9$ 的更大求积规则。\n- 案例 A–C 的容差为 $\\varepsilon = 10^{-12}$，案例 D 的容差为 $10^{-15}$。\n- 所有角度（若有）必须以弧度为单位；然而，此处不需要角度。\n- 不涉及物理单位。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按案例 A–E 顺序排列的结果，形式为方括号内以逗号分隔的列表。例如，一个有效的输出应如下所示：$[{\\rm True},{\\rm True},{\\rm True},{\\rm True},2.98]$。",
            "solution": "该问题要求计算给定有界线性泛函 $L: V_p(K) \\to \\mathbb{R}$ 的 Riesz 表示元 $r \\in V_p(K)$，其中 $V_p(K) = \\mathbb{P}_p(K)$ 是参考单元 $K = [-1,1]$ 上次数至多为 $p$ 的多项式空间。该空间赋有 $L^2$ 内积 $(u,v)_K = \\int_{-1}^1 u(x)v(x)dx$。Riesz 表示定理保证了存在唯一的 $r \\in V_p(K)$，使得对于所有 $v \\in V_p(K)$，以下恒等式成立：\n$$\n(r, v)_K = L(v)\n$$\n\n为了通过算法找到 $r$，我们采用 Galerkin 方法。我们在 $V_p(K)$ 的一组基中表示未知多项式 $r$。问题指定了 Legendre 多项式基 $\\{\\phi_j(x)\\}_{j=0}^p = \\{P_j(x)\\}_{j=0}^p$。因此，我们可以将 $r(x)$ 写成这些基函数的线性组合：\n$$\nr(x) = \\sum_{i=0}^p c_i \\phi_i(x)\n$$\n其中 $\\mathbf{c} = [c_0, c_1, \\dots, c_p]^T$ 是未知系数向量。\n\n将此展开式代入 Riesz 恒等式，并利用内积的线性性质，我们得到：\n$$\n\\left(\\sum_{i=0}^p c_i \\phi_i, v\\right)_K = \\sum_{i=0}^p c_i (\\phi_i, v)_K = L(v)\n$$\n该方程必须对所有 $v \\in V_p(K)$ 成立。只需对 $V_p(K)$ 的一组基强制该方程成立即可。我们选择测试函数与基函数相同，即 $v = \\phi_j$，其中 $j=0, 1, \\dots, p$。这样就得到了一个关于 $p+1$ 个未知系数 $c_i$ 的 $p+1$ 个线性方程组：\n$$\n\\sum_{i=0}^p c_i (\\phi_i, \\phi_j)_K = L(\\phi_j), \\quad \\text{for } j=0, 1, \\dots, p\n$$\n该方程组可以写成矩阵形式：\n$$\nM \\mathbf{c} = \\mathbf{b}\n$$\n其中：\n-   $M$ 是 $(p+1) \\times (p+1)$ 的**质量矩阵**，其元素为 $M_{ji} = (\\phi_i, \\phi_j)_K$。\n-   $\\mathbf{c}$ 是未知系数向量。\n-   $\\mathbf{b}$ 是 $(p+1) \\times 1$ 的**载荷向量**，其元素为 $b_j = L(\\phi_j)$。\n\nLegendre 多项式 $\\{P_n\\}$ 在区间 $[-1,1]$ 上是正交的，这极大地简化了质量矩阵。其正交性为：\n$$\n(P_i, P_j)_K = \\int_{-1}^1 P_i(x) P_j(x) dx = \\frac{2}{2i+1} \\delta_{ij}\n$$\n其中 $\\delta_{ij}$ 是 Kronecker delta 符号。因此，质量矩阵 $M$ 是对角矩阵：\n$$\nM_{ji} = \\frac{2}{2j+1} \\delta_{ij}\n$$\n线性系统 $M\\mathbf{c}=\\mathbf{b}$ 因此解耦为 $p+1$ 个独立的标量方程：\n$$\nM_{jj} c_j = b_j \\implies \\frac{2}{2j+1} c_j = b_j\n$$\n系数的解可以直接求出：\n$$\nc_j = \\frac{2j+1}{2} b_j = \\frac{2j+1}{2} L(\\phi_j)\n$$\n这避免了使用通用线性求解器。主要的计算任务简化为通过在每个基函数 $\\phi_j = P_j$ 上评估泛函 $L$ 来组装载荷向量 $\\mathbf{b}$。\n\n**各泛函的载荷向量组装：**\n1.  **体泛函**：$L_{\\mathrm{vol}}(v) = \\int_K g(x)v(x)dx$。载荷向量的分量为 $b_j = L_{\\mathrm{vol}}(P_j) = \\int_{-1}^1 g(x)P_j(x)dx$。对于 $g(x)=x^2$，被积函数是 $x^2 P_j(x)$，一个次数为 $j+2$ 的多项式。指定的具有 $n_q = p+3$ 个点的 Gauss-Legendre 求积对于次数高达 $2(p+3)-1 = 2p+5$ 的多项式是精确的。这足以对所有 $j \\le p$ 精确计算该积分，因为对于 $p \\ge -3$，有 $j+2 \\le p+2 \\le 2p+5$。\n\n2.  **面求值泛函**：$L_{\\mathrm{face}}(v) = v(-1)$。载荷向量的分量为 $b_j = L_{\\mathrm{face}}(P_j) = P_j(-1)$。这依赖于 Legendre 多项式的已知性质 $P_j(-1) = (-1)^j$。不需要数值积分。\n\n3.  **两点数值通量泛函**：$L_{\\mathrm{flux}}(v) = \\alpha v(-1) + \\beta v(1)$。分量为 $b_j = L_{\\mathrm{flux}}(P_j) = \\alpha P_j(-1) + \\beta P_j(1)$。利用性质 $P_j(-1)=(-1)^j$ 和 $P_j(1)=1$，我们得到 $b_j = \\alpha(-1)^j + \\beta$。\n\n**测试用例分析：**\n\n-   **案例 A ($p=3, g(x)=x^2$)**：函数 $g(x)=x^2$ 是一个 2 次多项式，因此它位于空间 $V_3(K)$ 内。对于任何 $v \\in V_3(K)$，该泛函为 $L_{\\mathrm{vol}}(v) = (g,v)_K$。根据 Riesz 表示元的定义，满足对所有 $v \\in V_3(K)$ 都有 $(r,v)_K = (g,v)_K$ 的唯一元素 $r \\in V_3(K)$ 必然是 $r=g$。因此，计算出的 Riesz 表示元 $r_{\\mathrm{vol}}(x)$ 必须与 $g(x)=x^2$ 完全相同。该测试验证了计算出的多项式与 $x^2$ 之间的点态误差低于一个很小的容差，从而证实了实现的正确性。\n\n-   **案例 B ($p=4, L_{\\mathrm{face}}(v)=v(-1)$)**：此泛函无法表示为与一个多项式的 $L^2$ 内积，因为它对应于一个 Dirac delta 分布。然而，在有限维空间 $V_p(K)$ 内，存在一个唯一的多项式表示元。该测试用例通过检查 $(r_{\\mathrm{face}}, P_j)_K - L_{\\mathrm{face}}(P_j)$ 对于所有基函数 $P_j$ 是否接近于零，来验证计算出的表示元 $r_{\\mathrm{face}}$ 的基本定义属性。此过程使用高阶求积法则（$n_q^{\\mathrm{check}} = 2p+9$）进行评估，以确保积分以高精度计算，从而将任何误差隔离到底层浮点运算中。\n\n-   **案例 C ($p=2, L_{\\mathrm{flux}}(v)$)**：与案例 B 类似，此泛函涉及点值评估，并在 $V_2(K)$ 中有一个唯一的表示元。测试过程是相同的：对所有基函数，数值上验证其定义的 Riesz 恒等式。\n\n-   **案例 D ($p=0, L_{\\mathrm{flux}}(v)$)**：此案例提供了一个简单的解析基准。对于 $p=0$，空间 $V_0(K)$ 由常数函数组成，基为 $\\{P_0(x)=1\\}$。表示元为 $r(x) = c_0 P_0(x) = c_0$。Riesz 恒等式变为 $(c_0, P_0)_K = L_{\\mathrm{flux}}(P_0)$。左边是 $\\int_{-1}^1 c_0 \\cdot 1 dx = 2c_0$。右边是 $\\alpha P_0(-1) + \\beta P_0(1) = \\alpha + \\beta$。令两者相等得到 $2c_0 = \\alpha + \\beta$，所以 $c_0 = (\\alpha+\\beta)/2$。该测试证实了通用算法能够复现此解析结果。\n\n-   **案例 E（复杂度）**：此案例分析计算成本的缩放规律。提供的成本模型是 $C(p) = (p+1)^2(p+3) + (p+1)^3$。第一项模拟了使用具有 $p+3$ 个求积点的求积法则组装稠密质量矩阵和载荷向量的成本，而第二项模拟了稠密线性求解的成本。尽管我们使用正交基使得求解步骤的复杂度为 $\\mathcal{O}(p+1)$，但这个成本模型反映了一个更通用的实现。简化模型得到 $C(p) = (p+1)^2((p+3)+(p+1)) = 2(p+1)^3$。我们预期 $C(p)$ 的缩放级别为 $\\mathcal{O}(p^3)$。为了找到经验缩放指数 $\\gamma$，我们对给定 $p$ 值集合的数据 $(\\log p, \\log C(p))$ 进行线性拟合。这条线的斜率就是所求的指数 $\\gamma$。由于 $\\log C(p) = \\log 2 + 3 \\log(p+1)$，且对于大的 $p$，$\\log(p+1) \\approx \\log p$，斜率 $\\gamma$ 应接近 3。该计算通过执行线性最小二乘拟合来数值地找到这个斜率。",
            "answer": "```python\nimport numpy as np\nfrom scipy import special\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the Riesz representer for several linear functionals and performs validation tests.\n    \"\"\"\n    \n    results = []\n\n    # Case A: Happy path, exact representability\n    p_A = 3\n    # Assemble load vector b_j = integral(x^2 * P_j(x) dx)\n    n_q_A = p_A + 3\n    xq, wq = np.polynomial.legendre.leggauss(n_q_A)\n    b_A = np.zeros(p_A + 1)\n    g_vals = xq**2\n    for j in range(p_A + 1):\n        P_j_vals = np.polynomial.legendre.legval(xq, [1.0 if i == j else 0.0 for i in range(p_A + 1)])\n        b_A[j] = np.sum(wq * g_vals * P_j_vals)\n    \n    # Compute coefficients c_j = ((2j+1)/2) * b_j\n    j_vals = np.arange(p_A + 1)\n    c_A = (2 * j_vals + 1) / 2.0 * b_A\n    \n    # Evaluate error\n    x_eval = np.linspace(-1, 1, 201)\n    r_vol_eval = np.polynomial.legendre.legval(x_eval, c_A)\n    g_eval = x_eval**2\n    max_err_A = np.max(np.abs(r_vol_eval - g_eval))\n    results.append(max_err_A  1e-12)\n\n    # Case B: Face functional\n    p_B = 4\n    # Assemble load vector b_j = P_j(-1)\n    b_B = np.array([(-1)**j for j in range(p_B + 1)], dtype=float)\n    \n    # Compute coefficients\n    j_vals = np.arange(p_B + 1)\n    c_B = (2 * j_vals + 1) / 2.0 * b_B\n    \n    # Verify Riesz identity\n    n_q_B_check = 2 * p_B + 9\n    xq_check, wq_check = np.polynomial.legendre.leggauss(n_q_B_check)\n    r_face_eval = np.polynomial.legendre.legval(xq_check, c_B)\n    \n    errors_B = []\n    for j in range(p_B + 1):\n        P_j_vals = np.polynomial.legendre.legval(xq_check, [1.0 if i == j else 0.0 for i in range(p_B + 1)])\n        inner_prod = np.sum(wq_check * r_face_eval * P_j_vals)\n        L_val = (-1)**j\n        errors_B.append(np.abs(inner_prod - L_val))\n    \n    max_err_B = np.max(errors_B)\n    results.append(max_err_B  1e-12)\n\n    # Case C: Flux functional, general\n    p_C = 2\n    alpha_C, beta_C = 2.0, -1.0\n    # Assemble load vector b_j = alpha*P_j(-1) + beta*P_j(1)\n    b_C = np.array([alpha_C * (-1)**j + beta_C * 1 for j in range(p_C + 1)], dtype=float)\n\n    # Compute coefficients\n    j_vals = np.arange(p_C + 1)\n    c_C = (2 * j_vals + 1) / 2.0 * b_C\n    \n    # Verify Riesz identity\n    n_q_C_check = 2 * p_C + 9\n    xq_check, wq_check = np.polynomial.legendre.leggauss(n_q_C_check)\n    r_flux_eval = np.polynomial.legendre.legval(xq_check, c_C)\n    \n    errors_C = []\n    for j in range(p_C + 1):\n        P_j_vals = np.polynomial.legendre.legval(xq_check, [1.0 if i == j else 0.0 for i in range(p_C + 1)])\n        inner_prod = np.sum(wq_check * r_flux_eval * P_j_vals)\n        L_val = alpha_C * (-1)**j + beta_C * 1\n        errors_C.append(np.abs(inner_prod - L_val))\n    \n    max_err_C = np.max(errors_C)\n    results.append(max_err_C  1e-12)\n\n    # Case D: Flux functional, boundary case\n    p_D = 0\n    alpha_D, beta_D = 3.0, 5.0\n    # Assemble load vector\n    b_D = np.array([alpha_D * (-1)**0 + beta_D * 1])\n    \n    # Compute coefficients\n    j_vals = np.arange(p_D + 1)\n    c_D0 = ((2 * j_vals + 1) / 2.0 * b_D)[0]\n    \n    # Check against analytical result\n    analytical_c0 = (alpha_D + beta_D) / 2.0\n    results.append(abs(c_D0 - analytical_c0)  1e-15)\n\n    # Case E: Complexity in p\n    p_vals = np.array([2, 4, 6, 8, 10, 12], dtype=float)\n    cost = (p_vals + 1)**2 * (p_vals + 3) + (p_vals + 1)**3\n    \n    log_p = np.log(p_vals)\n    log_cost = np.log(cost)\n    \n    # Perform linear least-squares fit (degree 1 polynomial)\n    gamma, _ = np.polyfit(log_p, log_cost, 1)\n    \n    results.append(round(gamma, 2))\n\n    # Format final output\n    str_results = []\n    for res in results:\n        if isinstance(res, bool):\n            str_results.append(str(res))\n        else:\n            str_results.append(f\"{res:.2f}\" if isinstance(res, float) and res == 2.98 else str(res))\n\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本实践将前面的练习推广到更贴近实际谱方法和 DG 程序代码的计算场景中。您将实现一个完整的计算流程：在从参考单元映射到物理单元上，使用数值积分来组装质量矩阵和载荷向量，然后求解完整的线性系统以找到 Riesz 表征。这个练习为您处理更复杂的几何形状和问题提供了坚实的基础，并展示了如何将理论概念转化为稳健的数值代码。",
            "id": "3413329",
            "problem": "考虑希尔伯特空间 $H = L^{2}(\\Omega)$，其定义在一个有界区间域 $\\Omega \\subset \\mathbb{R}$ 上，内积为 $(u,v)_{L^{2}(\\Omega)} = \\int_{\\Omega} u(x)\\,v(x)\\,dx$。根据里斯表示定理，每个有界线性泛函 $F : H \\to \\mathbb{R}$ 都存在一个唯一的表示元 $g \\in H$，使得对于所有 $u \\in H$ 都有 $F(u) = (g,u)_{L^{2}(\\Omega)}$。在谱方法和间断伽辽金方法中，我们通过将 $g$ 投影到有限维多项式子空间上来近似它，得到 $g_{h}$。设 $\\{\\varphi_{i}\\}_{i=0}^{N}$ 表示参考域 $[-1,1]$ 上的一个多项式基；对于本问题，使用 $[-1,1]$ 上的勒让德多项式 $\\{\\mathcal{P}_{i}\\}_{i=0}^{N}$。在一个物理区间 $[a,b]$ 上，使用仿射映射 $x(\\xi) = \\frac{b-a}{2}\\,\\xi + \\frac{a+b}{2}$，其雅可比行列式为 $J = \\frac{b-a}{2}$。在 $[a,b]$ 上，基函数的离散内积为 $(\\varphi_{i},\\varphi_{j})_{L^{2}([a,b])} = \\int_{-1}^{1} \\varphi_{i}(\\xi)\\,\\varphi_{j}(\\xi)\\,J\\,d\\xi$。\n\n给定一族形式为 $F(u) = \\int_{\\Omega} f_{0}(x)\\,u(x)\\,dx$ 的有界线性泛函，其中 $f_{0}$ 是一个多项式。在由 $\\{\\mathcal{P}_{i}\\}_{i=0}^{N}$ 逐单元张成的多项式子空间中，离散里斯表示 $g_{h}$ 由条件 $(g_{h},v_{h})_{L^{2}(\\Omega)} = F(v_{h})$ 定义，该条件对子空间中所有的 $v_{h}$ 都成立。如果 $g_{h}$ 在单个单元上展开为 $g_{h}(x) = \\sum_{i=0}^{N} c_{i}\\,\\mathcal{P}_{i}(\\xi(x))$，或在每个单元 $K$ 上逐单元展开为 $g_{h}|_{K}(x) = \\sum_{i=0}^{N_{K}} c_{K,i}\\,\\mathcal{P}_{i}(\\xi_{K}(x))$，那么确定系数向量 $\\{c_{i}\\}$ 或 $\\{c_{K,i}\\}$ 就简化为组装一个质量矩阵（来自 $(\\mathcal{P}_{i},\\mathcal{P}_{j})_{L^{2}}$）和一个载荷向量（来自 $F(\\mathcal{P}_{i})$），并为每个单元求解一个线性系统。您的任务是通过使用高斯-勒让德求积（使用足够多的求积点以精确积分所涉及的多项式）来组装单元质量矩阵和载荷向量，然后求解得到的线性系统，从而计算这些系数向量。\n\n使用的基本基和事实：\n- 勒让德多项式 $\\{\\mathcal{P}_{n}\\}_{n=0}^{\\infty}$ 在 $[-1,1]$ 上关于权重 $w(\\xi) = 1$ 正交，并满足一个三项递推关系。它们构成了多项式的一个基。\n- 对于一个单元 $[a,b]$，仿射映射 $x(\\xi)$ 和雅可比行列式 $J$ 得到 $\\int_{a}^{b} q(x)\\,dx = \\int_{-1}^{1} q(x(\\xi))\\,J\\,d\\xi$，对于可积函数 $q$ 成立。\n- 具有 $Q$ 个节点的高斯-勒让德求积可以精确积分最高为 $2Q-1$ 次的多项式。\n\n算法要求：\n- 对于每个单元 $[a,b]$ 和局部次数 $N$，使用高斯-勒让德求积组装局部质量矩阵 $M \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，其元素为 $M_{ij} = \\int_{-1}^{1} \\mathcal{P}_{i}(\\xi)\\,\\mathcal{P}_{j}(\\xi)\\,J\\,d\\xi$。\n- 使用高斯-勒让德求积组装局部载荷向量 $b \\in \\mathbb{R}^{N+1}$，其元素为 $b_{i} = \\int_{-1}^{1} f_{0}(x(\\xi))\\,\\mathcal{P}_{i}(\\xi)\\,J\\,d\\xi$。\n- 选择一个足以精确积分 $M$ 和 $b$ 中出现的所有多项式的求积阶数 $Q$。您必须根据被积函数中出现的最大多项式次数来证明您的选择。\n- 在每个单元上局部求解 $M\\,c = b$ 以获得系数向量 $c$。对于单单元谱方法的情况，这是全局系数向量。\n\n测试套件：\n实现您的程序以计算以下五个测试用例的系数向量。在所有情况下，基都是参考区间 $[-1,1]$ 上的勒让德基，单元映射和雅可比行列式如上所述。\n- 测试 A（单单元，次数 $N = 0$）：$\\Omega = [-1,1]$，$f_{0}(x) = 3$。\n- 测试 B（单单元，次数 $N = 2$）：$\\Omega = [-1,1]$，$f_{0}(x) = x$。\n- 测试 C（单单元，次数 $N = 3$）：$\\Omega = [-1,1]$，$f_{0}(x) = x^{2} + \\tfrac{1}{2}x^{3}$。\n- 测试 D（单单元，次数 $N = 1$）：$\\Omega = [-1,1]$，$f_{0}(x) = x^{2}$。\n- 测试 E（双单元间断伽辽金，每个单元上的局部次数 $N = 1$）：$\\Omega = [-1,1]$ 划分为 $[-1,0]$ 和 $[0,1]$，$f_{0}(x) = x$。\n\n角度单位不适用。没有需要报告的物理单位。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。对于测试 A-D，将单个单元的系数向量作为实数列表，按基的升序排列 $[\\;c_{0},c_{1},\\dots,c_{N}\\;]$。对于测试 E，按从左到右的单元区间顺序，以相同约定包含两个单元各自的系数向量列表。因此，最终输出必须具有以下形式\n$[\\,[c^{A}_{0},\\dots],\\,[c^{B}_{0},\\dots],\\,[c^{C}_{0},\\dots],\\,[c^{D}_{0},\\dots],\\;[[c^{E,1}_{0},c^{E,1}_{1}],\\,[c^{E,2}_{0},c^{E,2}_{1}]]\\,]$,\n并且必须打印在单行上。所有数字必须输出为标准十进制浮点字面量。",
            "solution": "该问题要求计算函数 $f_0$ 在多项式子空间 $V_h$ 上的 $L^2(\\Omega)$ 投影的系数。这个投影 $g_h$ 是泛函 $F(u) = (f_0, u)_{L^2(\\Omega)}$ 在子空间 $V_h$ （赋有 $L^2$ 内积）中的里斯表示。\n\n$g_h \\in V_h$ 的定义条件是：\n$$\n(g_h, v_h)_{L^2(\\Omega)} = (f_0, v_h)_{L^2(\\Omega)} \\quad \\forall v_h \\in V_h\n$$\n我们在单个物理单元 $[a, b]$ 上，使用次数为 $N$ 的局部多项式基 $\\{\\phi_i(\\xi(x))\\}_{i=0}^N$ 进行分析，其中 $\\phi_i(\\xi) = \\mathcal{P}_i(\\xi)$ 是参考区间 $[-1, 1]$ 上的勒让德多项式。未知函数 $g_h$ 在该基中展开为：\n$$\ng_h(x) = \\sum_{j=0}^N c_j \\phi_j(\\xi(x))\n$$\n将此展开式代入定义方程，并选择检验函数 $v_h$ 为基函数 $\\phi_i(\\xi(x))$，我们得到一个线性系统 $M\\mathbf{c} = \\mathbf{b}$：\n$$\n\\sum_{j=0}^N c_j (\\phi_j, \\phi_i)_{L^2([a,b])} = (f_0, \\phi_i)_{L^2([a,b])}, \\quad \\text{for } i=0, \\dots, N\n$$\n质量矩阵 $M$ 和载荷向量 $\\mathbf{b}$ 的各项通过将积分变换到参考单元 $[-1,1]$ 来计算。变换使用仿射映射 $x(\\xi) = \\frac{b-a}{2}\\xi + \\frac{a+b}{2}$，其雅可比行列式为 $J = \\frac{b-a}{2}$：\n$$\nM_{ij} = (\\phi_j, \\phi_i)_{L^2([a,b])} = \\int_a^b \\phi_i(\\xi(x))\\phi_j(\\xi(x)) dx = \\int_{-1}^1 \\mathcal{P}_i(\\xi)\\mathcal{P}_j(\\xi) J d\\xi\n$$\n$$\nb_i = (f_0, \\phi_i)_{L^2([a,b])} = \\int_a^b f_0(x)\\phi_i(\\xi(x)) dx = \\int_{-1}^1 f_0(x(\\xi))\\mathcal{P}_i(\\xi) J d\\xi\n$$\n由于勒让德多项式在 $[-1,1]$ 上的正交性，质量矩阵是对角的：\n$$\nM_{ij} = J \\int_{-1}^1 \\mathcal{P}_i(\\xi)\\mathcal{P}_j(\\xi) d\\xi = J \\frac{2}{2i+1}\\delta_{ij}\n$$\n线性系统因此解耦，每个系数的解为：\n$$\nc_i = \\frac{b_i}{M_{ii}} = \\frac{\\int_{-1}^1 f_0(x(\\xi))\\mathcal{P}_i(\\xi) J d\\xi}{J \\frac{2}{2i+1}} = \\frac{2i+1}{2} \\int_{-1}^1 f_0(x(\\xi))\\mathcal{P}_i(\\xi) d\\xi\n$$\n该算法要求使用高斯-勒让德求积来计算这些积分。为了精确积分一个次数为 $d$ 的多项式，求积规则必须至少有 $Q = \\lceil(d+1)/2\\rceil$ 个点。\n- 对于质量矩阵 $M_{ij}$，被积函数 $\\mathcal{P}_i(\\xi)\\mathcal{P}_j(\\xi)$ 的次数为 $i+j$，最大为 $2N$。\n- 对于载荷向量 $b_i$，被积函数 $f_0(x(\\xi))\\mathcal{P}_i(\\xi)$ 的次数为 $\\deg(f_0) + i$，最大为 $\\deg(f_0) + N$。\n我们必须选择足以精确计算这些积分中最大次数多项式的 $Q$。\n\n**案例 A ($N=0, \\Omega=[-1,1], f_0=3$)**: $J=1$。$f_0(x(\\xi))=3$。\n$c_0 = \\frac{1}{2}\\int_{-1}^1 3 \\cdot \\mathcal{P}_0(\\xi) d\\xi = \\frac{3}{2}\\int_{-1}^1 1 d\\xi = \\frac{3}{2}(2) = 3$。结果: `[3.0]`。\n\n**案例 B ($N=2, \\Omega=[-1,1], f_0=x$)**: $J=1$。$f_0(x(\\xi))=\\xi = \\mathcal{P}_1(\\xi)$。因为 $f_0 \\in V_h$，投影是精确的，$g_h=f_0$。其系数为 `[0.0, 1.0, 0.0]`。\n\n**案例 C ($N=3, \\Omega=[-1,1], f_0 = x^2 + 0.5x^3$)**: $J=1$。$f_0 \\in V_h$，所以 $g_h=f_0$。我们将 $f_0$ 展开为勒让德基： $x^2 = \\frac{2}{3}\\mathcal{P}_2 + \\frac{1}{3}\\mathcal{P}_0$；$x^3 = \\frac{2}{5}\\mathcal{P}_3 + \\frac{3}{5}\\mathcal{P}_1$。\n$f_0 = (\\frac{2}{3}\\mathcal{P}_2 + \\frac{1}{3}\\mathcal{P}_0) + 0.5(\\frac{2}{5}\\mathcal{P}_3 + \\frac{3}{5}\\mathcal{P}_1) = \\frac{1}{3}\\mathcal{P}_0 + 0.3\\mathcal{P}_1 + \\frac{2}{3}\\mathcal{P}_2 + 0.2\\mathcal{P}_3$。系数: `[0.333..., 0.3, 0.666..., 0.2]`。\n\n**案例 D ($N=1, \\Omega=[-1,1], f_0=x^2$)**: 我们将 $x^2$ 投影到 $\\mathbb{P}_1$ 上。\n$c_0 = \\frac{1}{2}\\int_{-1}^1 \\xi^2 \\mathcal{P}_0(\\xi) d\\xi = \\frac{1}{2}\\int_{-1}^1 \\xi^2 d\\xi = \\frac{1}{2}[\\frac{\\xi^3}{3}]_{-1}^1 = \\frac{1}{3}$。\n$c_1 = \\frac{3}{2}\\int_{-1}^1 \\xi^2 \\mathcal{P}_1(\\xi) d\\xi = \\frac{3}{2}\\int_{-1}^1 \\xi^3 d\\xi = 0$ (奇函数)。\n系数: `[0.333..., 0.0]`。\n\n**案例 E (2 单元, $N=1, f_0=x$)**:\n- 单元 1: $[-1,0]$。$J=1/2$, $x(\\xi) = \\frac{1}{2}\\xi - \\frac{1}{2}$。$f_0(x(\\xi))=\\frac{1}{2}\\xi - \\frac{1}{2}$。\n  $c_0 = \\frac{1}{2}\\int_{-1}^1 (\\frac{1}{2}\\xi - \\frac{1}{2})\\mathcal{P}_0(\\xi) d\\xi = \\frac{1}{2} [-\\frac{1}{2}(2)] = -0.5$。\n  $c_1 = \\frac{3}{2}\\int_{-1}^1 (\\frac{1}{2}\\xi - \\frac{1}{2})\\mathcal{P}_1(\\xi) d\\xi = \\frac{3}{2}\\int_{-1}^1 \\frac{1}{2}\\xi^2 d\\xi = \\frac{3}{4}[\\frac{\\xi^3}{3}]_{-1}^1 = \\frac{3}{4}(\\frac{2}{3})=0.5$。\n  单元 1 的系数: `[-0.5, 0.5]`。\n- 单元 2: $[0,1]$。$J=1/2$, $x(\\xi) = \\frac{1}{2}\\xi + \\frac{1}{2}$。$f_0(x(\\xi))=\\frac{1}{2}\\xi + \\frac{1}{2}$。\n  $c_0 = \\frac{1}{2}\\int_{-1}^1 (\\frac{1}{2}\\xi + \\frac{1}{2})\\mathcal{P}_0(\\xi) d\\xi = \\frac{1}{2} [\\frac{1}{2}(2)] = 0.5$。\n  $c_1 = \\frac{3}{2}\\int_{-1}^1 (\\frac{1}{2}\\xi + \\frac{1}{2})\\mathcal{P}_1(\\xi) d\\xi = \\frac{3}{2}\\int_{-1}^1 \\frac{1}{2}\\xi^2 d\\xi = 0.5$。\n  单元 2 的系数: `[0.5, 0.5]`。\n结果: `[[-0.5, 0.5], [0.5, 0.5]]`。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre, roots_legendre\n\ndef solve_element(a, b, N, f0_poly_coeffs):\n    \"\"\"\n    Computes the coefficient vector for the L2 projection on a single element.\n\n    Args:\n        a (float): The left boundary of the physical element.\n        b (float): The right boundary of the physical element.\n        N (int): The maximum polynomial degree for the basis.\n        f0_poly_coeffs (list[float]): Coefficients of the polynomial f_0 in power basis, ascending order.\n\n    Returns:\n        list[float]: The computed coefficient vector.\n    \"\"\"\n    # 1. Define element geometry and function\n    f0_poly = np.polynomial.Polynomial(f0_poly_coeffs)\n    J = (b - a) / 2.0  # Jacobian of the affine map\n    \n    # 2. Determine quadrature order Q for exact integration\n    deg_f0 = f0_poly.degree()\n    # The integrand for the mass matrix M_ij has polynomial degree i+j. Max is 2*N.\n    max_deg_M = 2 * N\n    # The integrand for the load vector b_i has polynomial degree deg(f0) + i. Max is deg(f0) + N.\n    max_deg_b = deg_f0 + N\n    # For a quadrature rule with Q points to be exact for a polynomial of degree d, we need 2Q-1 >= d.\n    # Therefore, Q >= (d+1)/2. We choose the smallest Q that satisfies this for all integrals.\n    max_integrand_deg = max(max_deg_M, max_deg_b)\n    Q = (max_integrand_deg + 2) // 2\n\n    # 3. Get Gauss-Legendre quadrature nodes and weights on [-1, 1]\n    # For scipy, roots_legendre returns nodes and weights.\n    nodes, weights = roots_legendre(Q)\n    \n    # 4. Evaluate f0 and basis functions at quadrature points\n    # Map quadrature nodes from reference element [-1,1] to physical element [a,b]\n    x_at_nodes = J * nodes + (a + b) / 2.0\n    f0_at_nodes = f0_poly(x_at_nodes)\n    \n    # Pre-evaluate all required Legendre polynomials P_i at all nodes\n    # P_vals is a (N+1) x Q matrix where P_vals[i, q] = P_i(node_q)\n    P_vals = np.array([eval_legendre(i, nodes) for i in range(N + 1)])\n\n    # 5. Assemble the mass matrix M and load vector b\n    # M_ij = integral(P_i * P_j * J dxi) approx. J * sum(w_q * P_i(xi_q) * P_j(xi_q))\n    # Using matrix operations: M = J * P_vals @ diag(weights) @ P_vals.T\n    M = J * (P_vals @ np.diag(weights) @ P_vals.T)\n    \n    # b_i = integral(f0 * P_i * J dxi) approx. J * sum(w_q * f0(x(xi_q)) * P_i(xi_q))\n    # Using matrix operations: b = J * P_vals @ (weights * f0_at_nodes)\n    b_vec = J * (P_vals @ (weights * f0_at_nodes))\n        \n    # 6. Solve the linear system Mc = b\n    # The mass matrix M is symmetric positive-definite, so a unique solution exists.\n    # For Legendre basis, M is analytically diagonal. Numerically, it's diagonally dominant.\n    c = np.linalg.solve(M, b_vec)\n    \n    return c.tolist()\n\ndef format_list_str(data):\n    \"\"\"Custom formatter to produce comma-separated list strings without spaces.\"\"\"\n    if isinstance(data, (list, tuple)):\n        return f\"[{','.join(format_list_str(item) for item in data)}]\"\n    elif isinstance(data, float):\n        # np.isclose is used to handle floating point representation of zero.\n        if np.isclose(data, 0.0, atol=1e-9): return \"0.0\"\n        return str(data)\n    else:\n        return str(data)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Test A: single element, N=0, f0(x) = 3\n    coeffs_A = solve_element(a=-1.0, b=1.0, N=0, f0_poly_coeffs=[3.0])\n    \n    # Test B: single element, N=2, f0(x) = x\n    coeffs_B = solve_element(a=-1.0, b=1.0, N=2, f0_poly_coeffs=[0.0, 1.0])\n    \n    # Test C: single element, N=3, f0(x) = x^2 + 0.5x^3\n    coeffs_C = solve_element(a=-1.0, b=1.0, N=3, f0_poly_coeffs=[0.0, 0.0, 1.0, 0.5])\n\n    # Test D: single element, N=1, f0(x) = x^2\n    coeffs_D = solve_element(a=-1.0, b=1.0, N=1, f0_poly_coeffs=[0.0, 0.0, 1.0])\n\n    # Test E: two elements, N=1, f0(x) = x\n    c_E1 = solve_element(a=-1.0, b=0.0, N=1, f0_poly_coeffs=[0.0, 1.0])\n    c_E2 = solve_element(a=0.0, b=1.0, N=1, f0_poly_coeffs=[0.0, 1.0])\n    coeffs_E = [c_E1, c_E2]\n\n    # Collect and format all results for the final output string.\n    results = [\n        format_list_str(coeffs_A),\n        format_list_str(coeffs_B),\n        format_list_str(coeffs_C),\n        format_list_str(coeffs_D),\n        format_list_str(coeffs_E),\n    ]\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}