{
    "hands_on_practices": [
        {
            "introduction": "The Bubnov-Galerkin method, where the trial and test spaces are identical, represents the foundational approach in finite element and spectral methods. For self-adjoint operators, this choice is optimal and leads to the celebrated Rayleigh-Ritz principle, guaranteeing real eigenvalues that provide upper bounds on the true eigenvalues. This first exercise  provides a concrete application of this principle by asking you to discretize a classic Sturm-Liouville eigenvalue problem. By constructing the mass and stiffness matrices and solving the resulting generalized eigenvalue problem, you will gain hands-on experience with the core mechanics of the spectral Bubnov-Galerkin method in its most natural setting.",
            "id": "3368169",
            "problem": "Consider the Sturm–Liouville eigenvalue problem for the one-dimensional Laplacian with homogeneous Dirichlet boundary conditions on the symmetric interval:\nfind nontrivial $u \\in H_{0}^{1}(-1,1)$ and $\\lambda \\in \\mathbb{R}$ such that\n$$\n- u''(x) = \\lambda\\, u(x), \\quad x \\in (-1,1), \\qquad u(-1)=u(1)=0.\n$$\nThe exact spectrum is $\\lambda_{n}^{\\star} = \\left(\\frac{n\\pi}{2}\\right)^{2}$ for $n \\in \\mathbb{N}$, so the first two exact eigenvalues are $\\lambda_{1}^{\\star} = \\pi^{2}/4$ and $\\lambda_{2}^{\\star} = \\pi^{2}$.\n\nUsing a Legendre spectral Bubnov Galerkin discretization with polynomial trial space $\\mathbb{P}_{3}^{0} := \\{ p \\in \\mathbb{P}_{3} : p(\\pm 1)=0\\}$, proceed as follows:\n- Start from the weak formulation derived from Green’s identity and the Dirichlet boundary conditions.\n- Choose the modal Legendre basis functions for the trial space given by $\\phi_{0}(x) = L_{2}(x)-L_{0}(x)$ and $\\phi_{1}(x) = L_{3}(x)-L_{1}(x)$, where $L_{n}(x)$ denotes the Legendre polynomial of degree $n$ normalized by $L_{n}(1)=1$.\n- Assemble the stiffness matrix $K$ with entries $K_{ij} = \\int_{-1}^{1} \\phi'_{i}(x)\\,\\phi'_{j}(x)\\,dx$ and the mass matrix $M$ with entries $M_{ij} = \\int_{-1}^{1} \\phi_{i}(x)\\,\\phi_{j}(x)\\,dx$.\n- Solve the resulting $2\\times 2$ generalized eigenvalue problem $K \\mathbf{a} = \\lambda_{h}\\, M \\mathbf{a}$ to obtain the two Rayleigh–Ritz approximations $\\lambda_{h,1}$ and $\\lambda_{h,2}$ of the first two eigenvalues.\n\nIn addition, briefly justify whether a Petrov Galerkin choice with the same two boundary-vanishing test functions leads to a different discrete spectrum for this problem, given the self-adjoint form of the bilinear form.\n\nDefine the dimensionless quantity\n$$\n\\Pi := \\left(\\frac{\\lambda_{h,1}}{\\pi^{2}/4}\\right)\\left(\\frac{\\lambda_{h,2}}{\\pi^{2}}\\right).\n$$\nCompute $\\Pi$ exactly and express your final answer as a closed-form analytic expression in terms of $\\pi$. Do not provide intermediate numerical approximations. The final answer must be a single expression.",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded, well-posed, and objective, presenting a standard problem in the numerical analysis of differential equations. All necessary information is provided, and there are no contradictions or ambiguities.\n\nThe problem asks for the solution of a Sturm-Liouville eigenvalue problem using a Legendre spectral Bubnov-Galerkin method. The problem is to find nontrivial $u \\in H_{0}^{1}(-1,1)$ and $\\lambda \\in \\mathbb{R}$ such that:\n$$\n- u''(x) = \\lambda\\, u(x), \\quad x \\in (-1,1), \\qquad u(-1)=u(1)=0.\n$$\nFirst, we derive the weak formulation. We multiply the differential equation by a test function $v \\in H_{0}^{1}(-1,1)$ and integrate over the domain $(-1,1)$:\n$$\n-\\int_{-1}^{1} u''(x)v(x) \\,dx = \\lambda \\int_{-1}^{1} u(x)v(x) \\,dx.\n$$\nApplying integration by parts (Green's first identity) to the left-hand side gives:\n$$\n\\int_{-1}^{1} u'(x)v'(x) \\,dx - \\left[u'(x)v(x)\\right]_{-1}^{1} = \\lambda \\int_{-1}^{1} u(x)v(x) \\,dx.\n$$\nSince the test function $v$ is in $H_{0}^{1}(-1,1)$, it satisfies the homogeneous Dirichlet boundary conditions $v(-1)=v(1)=0$. Thus, the boundary term vanishes. The weak formulation is: find $u \\in H_{0}^{1}(-1,1)$ and $\\lambda \\in \\mathbb{R}$ such that\n$$\na(u,v) = \\lambda (u,v)_{L^2} \\qquad \\forall v \\in H_{0}^{1}(-1,1),\n$$\nwhere $a(u,v) := \\int_{-1}^{1} u'(x)v'(x) \\,dx$ is a symmetric bilinear form and $(u,v)_{L^2} := \\int_{-1}^{1} u(x)v(x) \\,dx$ is the $L^2$ inner product.\n\nFor the Bubnov-Galerkin method, we seek an approximate solution $u_h(x)$ in a finite-dimensional trial space $\\mathbb{P}_{3}^{0} = \\{ p \\in \\mathbb{P}_{3} : p(\\pm 1)=0\\}$. The approximate solution is expressed as a linear combination of basis functions, $u_h(x) = \\sum_{j=0}^{1} a_j \\phi_j(x)$. The test functions are chosen from the same space. The given basis functions are $\\phi_{0}(x) = L_{2}(x)-L_{0}(x)$ and $\\phi_{1}(x) = L_{3}(x)-L_{1}(x)$, where $L_n(x)$ are the Legendre polynomials normalized such that $L_n(1)=1$. These are:\n$L_0(x) = 1$\n$L_1(x) = x$\n$L_2(x) = \\frac{1}{2}(3x^2-1)$\n$L_3(x) = \\frac{1}{2}(5x^3-3x)$\nWe have already verified in the problem validation phase that these basis functions satisfy the required boundary conditions, i.e., $\\phi_i(\\pm 1)=0$ for $i=0,1$.\n\nThe Bubnov-Galerkin method leads to the generalized matrix eigenvalue problem $K \\mathbf{a} = \\lambda_{h} M \\mathbf{a}$, where $\\mathbf{a}$ is the vector of coefficients $[a_0, a_1]^T$, and the stiffness matrix $K$ and mass matrix $M$ have entries:\n$K_{ij} = a(\\phi_j, \\phi_i) = \\int_{-1}^{1} \\phi'_{j}(x)\\phi'_{i}(x)\\,dx$\n$M_{ij} = (\\phi_j, \\phi_i)_{L^2} = \\int_{-1}^{1} \\phi_{j}(x)\\phi_{i}(x)\\,dx$\n\nWe compute the derivatives of the basis functions:\n$\\phi'_{0}(x) = L'_{2}(x) - L'_{0}(x) = 3x - 0 = 3x$\n$\\phi'_{1}(x) = L'_{3}(x) - L'_{1}(x) = \\frac{1}{2}(15x^2 - 3) - 1 = \\frac{15}{2}x^2 - \\frac{5}{2}$\n\nNow, we assemble the stiffness matrix $K$:\n$K_{00} = \\int_{-1}^{1} (3x)^2 \\,dx = 9 \\int_{-1}^{1} x^2 \\,dx = 9 \\left[\\frac{x^3}{3}\\right]_{-1}^{1} = 9\\left(\\frac{2}{3}\\right) = 6$.\n$K_{11} = \\int_{-1}^{1} \\left(\\frac{15}{2}x^2 - \\frac{5}{2}\\right)^2 \\,dx = \\frac{25}{4} \\int_{-1}^{1} (3x^2 - 1)^2 \\,dx = \\frac{25}{4} \\int_{-1}^{1} (9x^4 - 6x^2 + 1) \\,dx = \\frac{25}{4} \\left[9\\frac{x^5}{5} - 6\\frac{x^3}{3} + x\\right]_{-1}^{1} = \\frac{25}{4} \\cdot 2\\left(\\frac{9}{5} - 2 + 1\\right) = \\frac{25}{2}\\left(\\frac{4}{5}\\right) = 10$.\n$K_{01} = K_{10} = \\int_{-1}^{1} (3x)\\left(\\frac{15}{2}x^2 - \\frac{5}{2}\\right) \\,dx = \\int_{-1}^{1} \\left(\\frac{45}{2}x^3 - \\frac{15}{2}x\\right) \\,dx = 0$, since the integrand is an odd function integrated over a symmetric interval.\nThus, the stiffness matrix is $K = \\begin{pmatrix} 6 & 0 \\\\ 0 & 10 \\end{pmatrix}$.\n\nNext, we assemble the mass matrix $M$. We use the orthogonality property of Legendre polynomials: $\\int_{-1}^{1} L_m(x)L_n(x)\\,dx = \\frac{2}{2n+1}\\delta_{mn}$.\n$M_{00} = \\int_{-1}^{1} (\\phi_0(x))^2 \\,dx = \\int_{-1}^{1} (L_2(x)-L_0(x))^2 \\,dx = \\int_{-1}^{1} (L_2^2 - 2L_2L_0 + L_0^2) \\,dx$. Due to orthogonality, $\\int L_2L_0 \\,dx = 0$.\n$M_{00} = \\int_{-1}^{1} L_2^2 \\,dx + \\int_{-1}^{1} L_0^2 \\,dx = \\frac{2}{2(2)+1} + \\frac{2}{2(0)+1} = \\frac{2}{5} + 2 = \\frac{12}{5}$.\n$M_{11} = \\int_{-1}^{1} (\\phi_1(x))^2 \\,dx = \\int_{-1}^{1} (L_3(x)-L_1(x))^2 \\,dx = \\int_{-1}^{1} L_3^2 \\,dx + \\int_{-1}^{1} L_1^2 \\,dx = \\frac{2}{2(3)+1} + \\frac{2}{2(1)+1} = \\frac{2}{7} + \\frac{2}{3} = \\frac{6+14}{21} = \\frac{20}{21}$.\n$M_{01} = M_{10} = \\int_{-1}^{1} (L_2(x)-L_0(x))(L_3(x)-L_1(x)) \\,dx = 0$, due to the orthogonality of Legendre polynomials of different parity.\nThus, the mass matrix is $M = \\begin{pmatrix} 12/5 & 0 \\\\ 0 & 20/21 \\end{pmatrix}$.\n\nThe matrices $K$ and $M$ are diagonal because the basis functions were chosen to have definite parity (even/odd), which separates the problem into two uncoupled subproblems corresponding to even and odd eigenfunctions. The even basis function $\\phi_0(x)$ approximates the first (even) eigenfunction of the continuous problem, and the odd basis function $\\phi_1(x)$ approximates the second (odd) eigenfunction.\nThe generalized eigenvalue problem $K \\mathbf{a} = \\lambda_h M \\mathbf{a}$ simplifies to:\n$\\lambda_{h,1} = \\frac{K_{00}}{M_{00}} = \\frac{6}{12/5} = \\frac{30}{12} = \\frac{5}{2}$.\n$\\lambda_{h,2} = \\frac{K_{11}}{M_{11}} = \\frac{10}{20/21} = \\frac{210}{20} = \\frac{21}{2}$.\nThese are the Rayleigh-Ritz approximations for the first two eigenvalues.\n\nRegarding the Petrov-Galerkin method, the defining characteristic is the use of a test space $W_h$ that is different from the trial space $V_h$. The query asks about a \"Petrov Galerkin choice with the same two boundary-vanishing test functions\". This implies using a test space spanned by $\\{\\phi_0, \\phi_1\\}$, which is identical to the trial space $V_h = \\text{span}\\{\\phi_0, \\phi_1\\}$. When the test space and trial space are the same ($W_h=V_h$), the method is, by definition, the Bubnov-Galerkin method. Therefore, the resulting discrete spectrum would be identical. For a self-adjoint problem like this one, the symmetric bilinear form $a(u,v)$ makes the Bubnov-Galerkin method the natural choice, guaranteeing real eigenvalues that are upper bounds on the true eigenvalues (Rayleigh-Ritz principle). A genuine Petrov-Galerkin method ($W_h \\neq V_h$) would generally lead to non-symmetric matrices and a different, less optimal, discrete spectrum.\n\nFinally, we compute the dimensionless quantity $\\Pi$:\n$$\n\\Pi := \\left(\\frac{\\lambda_{h,1}}{\\pi^{2}/4}\\right)\\left(\\frac{\\lambda_{h,2}}{\\pi^{2}}\\right)\n$$\nSubstituting the computed eigenvalues $\\lambda_{h,1} = 5/2$ and $\\lambda_{h,2} = 21/2$:\n$$\n\\Pi = \\left(\\frac{5/2}{\\pi^{2}/4}\\right)\\left(\\frac{21/2}{\\pi^{2}}\\right) = \\left(\\frac{5}{2} \\cdot \\frac{4}{\\pi^2}\\right)\\left(\\frac{21}{2\\pi^2}\\right) = \\left(\\frac{10}{\\pi^2}\\right)\\left(\\frac{21}{2\\pi^2}\\right) = \\frac{210}{2\\pi^4} = \\frac{105}{\\pi^4}.\n$$",
            "answer": "$$\\boxed{\\frac{105}{\\pi^4}}$$"
        },
        {
            "introduction": "While the Bubnov-Galerkin method is ideal for self-adjoint problems, its performance degrades for non-self-adjoint operators, such as those found in convection-dominated transport phenomena. In such cases, the standard Galerkin solution is often plagued by non-physical oscillations. This necessitates a move to Petrov-Galerkin methods, where the test space is deliberately chosen to be different from the trial space to introduce stability. This coding exercise  guides you through implementing and comparing a standard Bubnov-Galerkin scheme with a Streamline Upwind Petrov-Galerkin (SUPG) method for a convection-diffusion problem. By analyzing the spectrum of the resulting discrete operators, you will directly observe how the SUPG formulation effectively adds numerical dissipation to control spurious oscillations, a cornerstone of modern computational fluid dynamics.",
            "id": "3368137",
            "problem": "Design and implement a one-dimensional spectral element discretization of the steady linear convection–diffusion operator for the scalar field $u$ on the interval $[0,1]$ with homogeneous Dirichlet boundary conditions. The strong form is given by $u' - \\epsilon u'' = f$ on $x \\in (0,1)$ with $u(0)=u(1)=0$, where $\\epsilon \\ge 0$ is a real parameter and $'$ denotes derivative with respect to $x$. Take the convection speed to be $a=1$. Use a partition of $[0,1]$ into $E$ equal elements of length $h = 1/E$, and on each element use a polynomial basis of degree $p$ with Legendre–Gauss–Lobatto (LGL) interpolation nodes. Derive and implement the following two discrete operators:\n- Bubnov–Galerkin formulation (trial equals test): starting from the standard weak form with test functions in the Sobolev space $H_0^1(0,1)$, integrate the diffusion term by parts once and the convection term by parts once so that the elementwise bilinear form uses $-\\int v' u \\, dx + \\epsilon \\int v' u' \\, dx$; use Lagrange shape functions $\\{\\ell_j\\}$ at the LGL nodes and LGL quadrature with weights $\\{\\omega_i\\}$ to form the element matrices\n  - $M_e = \\dfrac{h}{2} \\operatorname{diag}(\\omega)$,\n  - $D_{ij} = \\ell_j'(\\xi_i)$ on the reference interval $[-1,1]$ at the LGL nodes $\\{\\xi_i\\}_{i=0}^p$,\n  - $K_e = \\dfrac{2}{h} D^\\top \\operatorname{diag}(\\omega) D$,\n  - $C_e = - D^\\top \\operatorname{diag}(\\omega)$,\n  so that the element operator is $A^{\\text{BG}}_e = C_e + \\epsilon K_e$. Assemble these into the global matrix $A^{\\text{BG}}$ with standard $C^0$ continuity at interfaces and enforce the Dirichlet conditions by eliminating the boundary degrees of freedom.\n- Petrov–Galerkin upwind-biased formulation: adopt a Streamline Upwind Petrov–Galerkin (SUPG) test space defined by $w = v + \\tau v'$ with constant convection $a = 1$ and elementwise stabilization parameter $\\tau_e = \\theta \\, \\dfrac{h}{2p+1}$ with $\\theta = \\dfrac{1}{2}$. In the resulting discrete bilinear form, retain the leading consistent SUPG contribution and implement it as an additional streamline diffusion along with the diffusion term, i.e., on each element take $A^{\\text{PG}}_e = C_e + (\\epsilon + \\tau_e) K_e$. Assemble into the global matrix $A^{\\text{PG}}$ and enforce the same Dirichlet conditions.\n\nFor each assembled global operator (after applying the boundary conditions), compute the spectrum (all eigenvalues) of the matrix using complex arithmetic. Then, for each operator $A$, compute the following two spectral diagnostics:\n- the spectral radius $\\rho(A) = \\max_i |\\lambda_i|$,\n- the spectral abscissa $\\alpha(A) = \\max_i \\operatorname{Re}(\\lambda_i)$.\n\nYour program must implement the above for a set of test cases that probe the limit $\\epsilon \\to 0$ and the effect of increasing polynomial degree $p$. Use the following test suite, each specified as a triple $(\\epsilon, p, E)$:\n- Test $1$: $(10^{-2}, 2, 3)$,\n- Test $2$: $(10^{-6}, 2, 3)$,\n- Test $3$: $(10^{-6}, 6, 3)$,\n- Test $4$: $(0, 4, 2)$.\n\nFor each test case, compute four floating-point values:\n- $\\rho\\!\\left(A^{\\text{BG}}\\right)$,\n- $\\rho\\!\\left(A^{\\text{PG}}\\right)$,\n- $\\alpha\\!\\left(A^{\\text{BG}}\\right)$,\n- $\\alpha\\!\\left(A^{\\text{PG}}\\right)$.\n\nAll floating-point outputs must be reported as decimal numbers in scientific notation with exactly six digits after the decimal point.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list of lists, one per test case, in the order given above. Each inner list must be ordered as $[\\rho(A^{\\text{BG}}), \\rho(A^{\\text{PG}}), \\alpha(A^{\\text{BG}}), \\alpha(A^{\\text{PG}})]$. For example, an output with two test cases should look like $[[x_1,x_2,x_3,x_4],[y_1,y_2,y_3,y_4]]$ with all numbers in the specified format.\n\nNo physical units are involved. All angles, if any, are to be treated in radians. The answers for each test case must be floating-point numbers as specified.",
            "solution": "The present problem requires the design and implementation of a one-dimensional spectral element method for the steady linear convection-diffusion equation, followed by a spectral analysis of the resulting discrete operators. We consider two formulations: a standard Bubnov-Galerkin (BG) method and a stabilized Streamline Upwind Petrov-Galerkin (SUPG) method.\n\nThe strong form of the governing equation on the domain $x \\in [0,1]$ is:\n$$ u' - \\epsilon u'' = f $$\nwith homogeneous Dirichlet boundary conditions $u(0)=u(1)=0$. Here, the convection speed is taken as $a=1$, and $\\epsilon \\ge 0$ is the diffusion coefficient.\n\nThe solution domain $[0,1]$ is partitioned into $E$ non-overlapping elements of equal length $h=1/E$. Within each element, the solution $u$ is approximated by a polynomial of degree $p$.\n\nThe standard weak form is obtained by multiplying the equation by a test function $v \\in H_0^1(0,1)$ and integrating over the domain. The problem specifies a particular weak form where both the convection and diffusion terms are integrated by parts. For the convection term $\\int v u' dx$, integration by parts yields $[vu]|_0^1 - \\int v' u dx$. For the diffusion term $-\\int v (\\epsilon u'') dx$, integration by parts yields $-[v \\epsilon u']|_0^1 + \\int v' (\\epsilon u') dx$. Since $v \\in H_0^1(0,1)$, the boundary terms vanish, leading to the bilinear form:\n$$ B(u, v) = \\int_0^1 \\left( -v' u + \\epsilon v' u' \\right) dx $$\n\nThe spectral element method approximates $u$ and $v$ on each element using a sum of basis functions. On a reference element $\\xi \\in [-1,1]$, the solution is represented using Lagrange polynomials $\\{\\ell_j(\\xi)\\}_{j=0}^p$ defined at the $p+1$ Legendre-Gauss-Lobatto (LGL) nodes $\\{\\xi_j\\}_{j=0}^p$:\n$$ u(\\xi) = \\sum_{j=0}^p u_j \\ell_j(\\xi) \\quad \\text{and} \\quad v(\\xi) = \\sum_{i=0}^p v_i \\ell_i(\\xi) $$\nThe physical coordinate $x$ on an element is mapped from the reference coordinate $\\xi$ via $x(\\xi) = x_k + \\frac{h}{2}(\\xi+1)$, where $x_k$ is the start of the element. This implies the relationships $dx = \\frac{h}{2} d\\xi$ and $\\frac{d}{dx} = \\frac{2}{h} \\frac{d}{d\\xi}$.\n\nThe bilinear form $B(u,v)$ can be computed element by element. Substituting the basis expansion and using LGL quadrature with weights $\\{\\omega_k\\}$ for integration, we derive the element matrices.\n\nThe element convection matrix $C_e$ arises from the term $-\\int v' u dx$. Transformed to the reference element, its $(i, j)$ entry is:\n$$ (C_e)_{ij} = -\\int_{-1}^1 \\left(\\frac{2}{h} \\ell_i'(\\xi)\\right) \\ell_j(\\xi) \\left(\\frac{h}{2} d\\xi\\right) = -\\int_{-1}^1 \\ell_i'(\\xi) \\ell_j(\\xi) d\\xi $$\nApplying LGL quadrature, and using the property $\\ell_j(\\xi_k) = \\delta_{jk}$:\n$$ (C_e)_{ij} \\approx -\\sum_{k=0}^p \\omega_k \\ell_i'(\\xi_k) \\ell_j(\\xi_k) = -\\sum_{k=0}^p \\omega_k (D)_{ki} \\delta_{jk} = -\\omega_j (D)_{ji} $$\nwhere $D$ is the LGL differentiation matrix with entries $D_{kj} = \\ell_j'(\\xi_k)$. In matrix form, this is $C_e = - D^\\top \\operatorname{diag}(\\omega)$, as specified.\n\nThe element stiffness matrix $K_e$ arises from the term $\\int \\epsilon v' u' dx$. Its $(i, j)$ entry is:\n$$ (K_e)_{ij} = \\epsilon \\int_{-1}^1 \\left(\\frac{2}{h} \\ell_i'(\\xi)\\right) \\left(\\frac{2}{h} \\ell_j'(\\xi)\\right) \\left(\\frac{h}{2} d\\xi\\right) = \\epsilon \\frac{2}{h} \\int_{-1}^1 \\ell_i'(\\xi) \\ell_j'(\\xi) d\\xi $$\nUsing LGL quadrature:\n$$ (K_e)_{ij} \\approx \\epsilon \\frac{2}{h} \\sum_{k=0}^p \\omega_k \\ell_i'(\\xi_k) \\ell_j'(\\xi_k) = \\epsilon \\frac{2}{h} \\sum_{k=0}^p \\omega_k (D)_{ki} (D)_{kj} $$\nIn matrix form, this is $\\epsilon \\frac{2}{h} D^\\top \\operatorname{diag}(\\omega) D$. The problem defines $K_e = \\frac{2}{h} D^\\top \\operatorname{diag}(\\omega) D$, so the term is $\\epsilon K_e$.\n\n**Bubnov-Galerkin (BG) Formulation:**\nThe BG method uses the same space for trial and test functions. The element operator matrix is the sum of the convection and stiffness contributions:\n$$ A^{\\text{BG}}_e = C_e + \\epsilon K_e $$\n\n**Petrov-Galerkin (PG) Formulation (SUPG):**\nFor small $\\epsilon$, the BG formulation is prone to producing spurious oscillations. The SUPG method stabilizes the discretization by adding artificial diffusion in the streamline direction. This is achieved by using a modified test function space, $w = v + \\tau_e v'$, where $\\tau_e$ is an element-wise stabilization parameter. The problem specifies a simplified SUPG implementation where the final element operator is:\n$$ A^{\\text{PG}}_e = C_e + (\\epsilon + \\tau_e) K_e $$\nwith $\\tau_e = \\theta \\frac{h}{2p+1}$ and $\\theta = 1/2$. This adds an artificial diffusion of magnitude $\\tau_e$ to the physical diffusion $\\epsilon$.\n\n**Global Assembly and Boundary Conditions:**\nThe global matrices, $A^{\\text{BG}}$ and $A^{\\text{PG}}$, are assembled by summing the contributions from all element matrices $A^{\\text{BG}}_e$ and $A^{\\text{PG}}_e$ into the appropriate locations corresponding to the global degrees of freedom. This procedure, known as direct stiffness summation, naturally enforces $C^0$ continuity at element interfaces.\nThe homogeneous Dirichlet boundary conditions, $u(0)=0$ and $u(1)=0$, are enforced by removing the rows and columns of the global matrices that correspond to the boundary nodes (the first and last global degrees of freedom).\n\n**Spectral Analysis:**\nAfter assembly and enforcement of boundary conditions, we obtain the final system matrices. The stability and behavior of the numerical scheme can be analyzed through the eigenvalues $\\{\\lambda_i\\}$ of these matrices. We compute two key spectral diagnostics:\n- The spectral radius, $\\rho(A) = \\max_i |\\lambda_i|$, which governs the amplification of errors in iterative methods.\n- The spectral abscissa, $\\alpha(A) = \\max_i \\operatorname{Re}(\\lambda_i)$, which is related to the stability of time-marching schemes for the corresponding time-dependent problem. For the discrete convection-diffusion operator, a non-negative spectral abscissa is desirable.\n\nThe implementation will proceed by first generating the LGL nodes, weights, and differentiation matrix for a given polynomial degree $p$. Then, for each test case, the element matrices will be computed and assembled into the global operators. After applying boundary conditions, the eigenvalues will be computed to find the spectral radius and abscissa.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, eval_legendre\n\ndef get_lgl_nodes_weights_deriv_matrix(p):\n    \"\"\"\n    Computes Legendre-Gauss-Lobatto (LGL) nodes, weights, and the\n    first derivative matrix for a given polynomial degree p.\n    \"\"\"\n    if p == 0:\n        # LGL is not defined for p=0 in a way that makes sense for C0 elements.\n        # However, the smallest p in the test suite is 2.\n        raise ValueError(\"LGL elements require p >= 1.\")\n\n    # LGL nodes are roots of (1-x^2) * P_p'(x)\n    # The interior nodes are the roots of P_p'(x)\n    if p > 1:\n        p_poly = legendre(p)\n        p_deriv_roots = p_poly.deriv().roots\n        nodes = np.concatenate(([-1.0], np.sort(p_deriv_roots), [1.0]))\n    else: # p == 1\n        nodes = np.array([-1.0, 1.0])\n\n    # LGL weights\n    weights = 2.0 / (p * (p + 1) * (eval_legendre(p, nodes)**2))\n\n    # Differentiation matrix D\n    D = np.zeros((p + 1, p + 1))\n    p_at_nodes = eval_legendre(p, nodes) #\n    for i in range(p + 1):\n        for j in range(p + 1):\n            if i != j:\n                D[i, j] = p_at_nodes[i] / (p_at_nodes[j] * (nodes[i] - nodes[j]))\n            else:\n                if i == 0:\n                    D[i, j] = -p * (p + 1) / 4.0\n                elif i == p:\n                    D[i, j] = p * (p + 1) / 4.0\n                else:\n                    D[i, j] = 0.0\n    return nodes, weights, D\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and generate the final output.\n    \"\"\"\n    test_cases = [\n        (1e-2, 2, 3),\n        (1e-6, 2, 3),\n        (1e-6, 6, 3),\n        (0.0, 4, 2),\n    ]\n\n    all_results = []\n\n    for epsilon, p, E in test_cases:\n        # Step 1: Get LGL data for the reference element\n        _, weights, D = get_lgl_nodes_weights_deriv_matrix(p)\n        omega_diag = np.diag(weights)\n\n        # Step 2: Form element matrices\n        h = 1.0 / E\n        \n        # Convection matrix Ce = -D^T * diag(w)\n        C_e = -D.T @ omega_diag\n        \n        # Stiffness matrix Ke = (2/h) * D^T * diag(w) * D\n        K_e = (2.0 / h) * D.T @ omega_diag @ D\n\n        # Element operator for Bubnov-Galerkin\n        A_bg_e = C_e + epsilon * K_e\n\n        # Element operator for Petrov-Galerkin (SUPG)\n        theta = 0.5\n        tau_e = theta * h / (2 * p + 1)\n        A_pg_e = C_e + (epsilon + tau_e) * K_e\n\n        # Step 3: Assemble global matrices\n        n_dof_total = E * p + 1\n        A_bg = np.zeros((n_dof_total, n_dof_total), dtype=np.complex128)\n        A_pg = np.zeros((n_dof_total, n_dof_total), dtype=np.complex128)\n\n        for e in range(E):\n            # Map local DoFs to global DoFs\n            global_indices = np.arange(e * p, e * p + p + 1)\n            # Direct stiffness summation\n            idx = np.ix_(global_indices, global_indices)\n            A_bg[idx] += A_bg_e\n            A_pg[idx] += A_pg_e\n\n        # Step 4: Apply homogeneous Dirichlet boundary conditions\n        # Eliminate first and last rows and columns\n        A_bg_int = A_bg[1:-1, 1:-1]\n        A_pg_int = A_pg[1:-1, 1:-1]\n        \n        # Step 5: Spectral Analysis\n        # Bubnov-Galerkin\n        eigvals_bg = np.linalg.eigvals(A_bg_int)\n        rho_bg = np.max(np.abs(eigvals_bg))\n        alpha_bg = np.max(np.real(eigvals_bg))\n        \n        # Petrov-Galerkin\n        eigvals_pg = np.linalg.eigvals(A_pg_int)\n        rho_pg = np.max(np.abs(eigvals_pg))\n        alpha_pg = np.max(np.real(eigvals_pg))\n        \n        case_results = [rho_bg, rho_pg, alpha_bg, alpha_pg]\n        all_results.append(case_results)\n\n    # Format the final output string\n    formatted_results = []\n    for case_res in all_results:\n        formatted_case = [f\"{v:.6e}\" for v in case_res]\n        formatted_results.append(f\"[{','.join(formatted_case)}]\")\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "The power of the Petrov-Galerkin framework extends beyond stabilizing convection-dominated flows. The freedom to select a distinct test space can be strategically used to enforce critical physical laws that are only weakly satisfied in a Bubnov-Galerkin formulation. This final practice problem  explores this concept in the context of diffusion through heterogeneous media. You will implement a method where the standard \"hat\" test function at a material interface is replaced by a functional that strongly enforces flux continuity. By comparing the results to a conventional Bubnov-Galerkin method, you will see how a tailored Petrov-Galerkin approach can eliminate local flux errors and suppress spurious oscillations that arise from sharp jumps in material coefficients.",
            "id": "3368141",
            "problem": "Consider the one-dimensional elliptic interface problem on the domain $[0,1]$ with a discontinuous diffusion coefficient:\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) = f(x) \\quad \\text{for } x \\in (0,1),\n$$\nwith homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$. The diffusion coefficient is piecewise constant with a single jump at $x=\\tfrac{1}{2}$:\n$$\na(x) = \\begin{cases}\na_L, & x \\in [0,\\tfrac{1}{2}),\\\\\na_R, & x \\in (\\tfrac{1}{2},1],\n\\end{cases}\n$$\nand the source term is $f(x) \\equiv 1$. The problem is to compare two discretizations on a uniform mesh with $N$ elements (nodes $x_i = i/N$ for $i=0,1,\\dots,N$), focusing on how choosing Petrov test functionals that enforce local flux continuity constraints strongly affects spurious oscillations when compared to a Bubnov Galerkin method with the standard handling of discontinuous coefficients (which, on an interface-aligned mesh, is equivalent to harmonic averaging in the sense of two-point flux approximations).\n\nYou must implement the following two discrete methods:\n\n1. Bubnov Galerkin method (continuous, piecewise linear trial and test functions):\n   - Use standard assembly of the stiffness matrix with piecewise constant $a(x)$. On each element $K_e = [x_e, x_{e+1}]$, the local stiffness is\n     $$\n     K_e = \\frac{a_e}{h}\\begin{bmatrix}1 & -1\\\\ -1 & 1\\end{bmatrix}, \\quad h = \\frac{1}{N},\n     $$\n     where $a_e$ is the value of $a(x)$ on $K_e$, and the local load vector is\n     $$\n     F_e = \\frac{h}{2}\\begin{bmatrix}1\\\\1\\end{bmatrix}\n     $$\n     since $f(x)\\equiv 1$. Assemble to form the global system and impose $u(0)=u(1)=0$ strongly by eliminating the boundary degrees of freedom. Solve for the interior nodal values.\n\n2. Petrov Galerkin variant with strong local flux continuity at the interface:\n   - Start from the same global assembled system as in the Bubnov method. Let $j = N/2$ be the index of the interface node (assume $N$ is even so the interface coincides with a mesh node). Replace the discrete equation corresponding to the interior node $x_j$ by the strong flux continuity constraint derived from the fundamental law of continuity of physical flux in the absence of singular sources:\n     $$\n     a_L \\frac{u_j - u_{j-1}}{h} = a_R \\frac{u_{j+1} - u_j}{h},\n     $$\n     which can be written equivalently as a linear functional of the nodal values,\n     $$\n     -\\frac{a_L}{h} u_{j-1} + \\left(\\frac{a_L}{h} + \\frac{a_R}{h}\\right) u_j - \\frac{a_R}{h} u_{j+1} = 0.\n     $$\n     This replacement defines a Petrov Galerkin test (the test at the interface node is no longer the standard hat function but an interface flux continuity functional), enforcing flux continuity locally and strongly. Solve the resulting square linear system with Dirichlet boundary conditions enforced as before.\n\nFor each method, compute the following diagnostics:\n\n- The magnitude of the physical flux jump at the interface node $x_j=\\tfrac{1}{2}$, defined by\n  $$\n  J = \\left| \\left(-a_L \\frac{u_j - u_{j-1}}{h}\\right) - \\left(-a_R \\frac{u_{j+1} - u_j}{h}\\right) \\right|.\n  $$\n  This quantifies how strongly the method satisfies physical flux continuity across the coefficient jump.\n\n- A spurious oscillation metric based on discrete gradient sign changes. Let $u_i$ denote the nodal solution. Define the forward differences $\\Delta_i = u_{i+1}-u_i$. For the given data $f(x)\\equiv 1$ and homogeneous Dirichlet boundaries, the continuous solution is unimodal, implying exactly one sign change in the gradient across the domain. Count the number of sign changes in the sequence $\\{\\Delta_i\\}$ after removing zeros; define the excess sign changes as\n  $$\n  S_{\\text{excess}} = \\max\\{0, S - 1\\},\n  $$\n  where $S$ is the total number of sign flips in the nonzero-difference sequence. Larger $S_{\\text{excess}}$ indicates more spurious oscillations.\n\nTest Suite:\nImplement your program to run the following parameter sets, each defined by a tuple $(N, a_L, a_R)$:\n\n- Case A (moderate contrast, well-resolved): $(N, a_L, a_R) = (10, 1.0, 10.0)$.\n- Case B (high contrast, well-resolved): $(N, a_L, a_R) = (10, 10^{-3}, 1.0)$.\n- Case C (high contrast, coarse mesh): $(N, a_L, a_R) = (4, 1.0, 1000.0)$.\n\nFor each case, for both methods, compute:\n- The flux jump magnitude $J$ at the interface node.\n- The excess sign changes $S_{\\text{excess}}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for all test cases as a list of lists. For each case, report a list\n$$\n[\\;J_{\\text{Bubnov}},\\;J_{\\text{Petrov}},\\;S_{\\text{excess,Bubnov}},\\;S_{\\text{excess,Petrov}}\\;],\n$$\nwith $J$ reported as floating-point numbers and $S_{\\text{excess}}$ as integers. Aggregate the three case results into a single list printed as a comma-separated list enclosed in square brackets, for example:\n[[JB1,JP1,SB1,SP1],[JB2,JP2,SB2,SP2],[JB3,JP3,SB3,SP3]]\n\nNo physical units are involved. Angles are not used. Percentages are not used. The entire program must be self-contained and require no user input. The final printed line must exactly match the specified format with numeric entries.",
            "solution": "The user has provided a well-defined problem in the field of numerical analysis for partial differential equations. The problem is scientifically grounded, objective, and contains all necessary information to proceed with a solution.\n\n### Step 1: Problem Validation\n\n**Extracted Givens:**\n-   **Governing Equation:** $-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) = f(x)$ on the domain $x \\in (0,1)$.\n-   **Boundary Conditions:** Homogeneous Dirichlet, $u(0)=0$ and $u(1)=0$.\n-   **Diffusion Coefficient:** A piecewise constant function $a(x)$ with a jump discontinuity at $x = \\tfrac{1}{2}$.\n    $$\n    a(x) = \\begin{cases}\n    a_L, & x \\in [0,\\tfrac{1}{2}),\\\\\n    a_R, & x \\in (\\tfrac{1}{2},1].\n    \\end{cases}\n    $$\n-   **Source Term:** $f(x) = 1$.\n-   **Discretization:** A uniform mesh with $N$ elements and $N+1$ nodes $x_i = i/N$. The mesh is aligned with the interface, meaning $N$ is an even integer and the interface is located at node $j = N/2$. The mesh spacing is $h=1/N$.\n-   **Method 1 (Bubnov-Galerkin):**\n    -   Uses continuous, piecewise linear basis functions for both trial and test spaces.\n    -   The system is assembled from elemental contributions: stiffness matrix $K_e = \\frac{a_e}{h}\\begin{bmatrix}1 & -1\\\\ -1 & 1\\end{bmatrix}$ and load vector $F_e = \\frac{h}{2}\\begin{bmatrix}1\\\\1\\end{bmatrix}$.\n    -   Boundary conditions are imposed by solving for interior degrees of freedom only.\n-   **Method 2 (Petrov-Galerkin):**\n    -   The discrete system is identical to the Bubnov-Galerkin method, except for the equation at the interface node $x_j$.\n    -   The equation at node $x_j$ is replaced by the strong flux continuity constraint:\n    $$-\\frac{a_L}{h} u_{j-1} + \\left(\\frac{a_L}{h} + \\frac{a_R}{h}\\right) u_j - \\frac{a_R}{h} u_{j+1} = 0.$$\n-   **Diagnostics:**\n    -   Interface Flux Jump: $J = \\left| \\left(-a_L \\frac{u_j - u_{j-1}}{h}\\right) - \\left(-a_R \\frac{u_{j+1} - u_j}{h}\\right) \\right|$.\n    -   Excess Sign Changes: $S_{\\text{excess}} = \\max\\{0, S - 1\\}$, where $S$ is the number of sign changes in the sequence of discrete gradients $\\Delta_i = u_{i+1}-u_i$.\n-   **Test Parameters:** Three cases for $(N, a_L, a_R)$ are specified: $(10, 1.0, 10.0)$, $(10, 10^{-3}, 1.0)$, and $(4, 1.0, 1000.0)$.\n\n**Validation Verdict:**\nThe problem is **valid**. It is a standard, well-posed problem in computational science, specifically the numerical solution of elliptic PDEs with discontinuous coefficients. The methods described are standard techniques (Bubnov-Galerkin) and a well-known variant for handling interfaces (a specific Petrov-Galerkin method). The problem is self-contained, logically consistent, and free from any scientific flaws or ambiguities.\n\n### Step 2: Solution Derivation and Implementation Strategy\n\nThe core of the problem is to construct and solve a linear system of equations, $K\\mathbf{u} = \\mathbf{F}$, for the unknown nodal values $\\mathbf{u} = [u_1, u_2, \\dots, u_{N-1}]^T$ of the solution at the $N-1$ interior nodes.\n\n**System Assembly (Bubnov-Galerkin):**\nThe weak form of the problem is: find $u \\in H_0^1(0,1)$ such that\n$$\n\\int_0^1 a(x) \\frac{du}{dx} \\frac{dv}{dx} \\, dx = \\int_0^1 f(x) v(x) \\, dx, \\quad \\forall v \\in H_0^1(0,1).\n$$\nDiscretizing with piecewise linear basis functions $\\phi_i(x)$ (hat functions), we seek $u_h(x) = \\sum_{i=1}^{N-1} u_i \\phi_i(x)$. Choosing the test functions $v(x)$ to be the same basis functions $\\phi_i(x)$ (Bubnov-Galerkin) yields a system of equations. The equation for an interior node $i$ is:\n$$\n\\int_0^1 a(x) \\frac{d\\phi_i}{dx} \\sum_{k=1}^{N-1} u_k \\frac{d\\phi_k}{dx} \\, dx = \\int_0^1 f(x) \\phi_i(x) \\, dx\n$$\nThis results in a tridiagonal stiffness matrix $K$.\nFor a generic interior node $i$ away from the interface, where the coefficient is constant (e.g., $a_L$), the equation is:\n$\\frac{a_L}{h}(-u_{i-1} + 2u_i - u_{i+1}) = h$, (since $f(x) \\equiv 1$)\nAt the interface node $j=N/2$, the coefficient changes from $a_L$ to $a_R$ within the support of $\\phi_j$. The equation becomes:\n$$\n\\int_{x_{j-1}}^{x_j} a_L \\frac{d\\phi_j}{dx}\\frac{du_h}{dx} \\, dx + \\int_{x_j}^{x_{j+1}} a_R \\frac{d\\phi_j}{dx}\\frac{du_h}{dx} \\, dx = \\int_{x_{j-1}}^{x_{j+1}} 1 \\cdot \\phi_j(x) \\, dx\n$$\nEvaluating this gives:\n$$\n\\frac{a_L}{h}(u_j - u_{j-1}) + \\frac{a_R}{h}(u_j - u_{j+1}) = h\n$$\n$$\n-\\frac{a_L}{h}u_{j-1} + \\left(\\frac{a_L+a_R}{h}\\right)u_j - \\frac{a_R}{h}u_{j+1} = h\n$$\nThe right-hand side vector $\\mathbf{F}$ has components $F_i = \\int_0^1 f(x)\\phi_i(x) dx = h$ for all $i=1, \\dots, N-1$.\nThis defines the system $K_{Bubnov}\\mathbf{u} = \\mathbf{F}_{Bubnov}$.\n\n**System Assembly (Petrov-Galerkin):**\nThis method starts with the same system and modifies the equation for the interface node $j$. The original equation (the $(j-1)$-th row of the system for interior nodes) is replaced by the discrete form of the flux continuity condition:\n$$\n-\\frac{a_L}{h}u_{j-1} + \\left(\\frac{a_L+a_R}{h}\\right)u_j - \\frac{a_R}{h}u_{j+1} = 0\n$$\nThis means the stiffness matrix $K_{Petrov}$ is identical to $K_{Bubnov}$, but the right-hand side vector $\\mathbf{F}_{Petrov}$ is modified such that its $(j-1)$-th element is $0$, while all other elements remain $h$.\n\n**Diagnostic Computation:**\nOnce the solutions $u_{Bubnov}$ and $u_{Petrov}$ are found, the diagnostics are computed as follows.\n\n1.  **Flux Jump ($J$)**: The numerical fluxes from the left and right of the interface node $j$ are $\\mathcal{F}_L = -a_L \\frac{u_j - u_{j-1}}{h}$ and $\\mathcal{F}_R = -a_R \\frac{u_{j+1} - u_j}{h}$. The jump is $J = |\\mathcal{F}_L - \\mathcal{F}_R|$.\n    -   For the Bubnov-Galerkin method, the discrete equation at node $j$ can be rearranged to $a_L(u_j - u_{j-1}) - a_R(u_{j+1} - u_j) = h^2$. This is equivalent to $h(\\mathcal{F}_R - \\mathcal{F}_L) = h^2$, which implies that the flux jump $|\\mathcal{F}_L - \\mathcal{F}_R| = |-h| = h = 1/N$.\n    -   For the Petrov-Galerkin method, the imposed equation is $a_L(u_j - u_{j-1}) - a_R(u_{j+1} - u_j) = 0$. Thus, $J=0$ by construction.\n\n2.  **Excess Sign Changes ($S_{\\text{excess}}$)**:\n    -   The sequence of forward differences $\\Delta_i = u_{i+1} - u_i$ is computed for the full solution vector, including the zero boundary values.\n    -   Zeros are filtered from this sequence.\n    -   The number of times the sign changes in the resulting sequence is counted, giving $S$.\n    -   The excess sign changes are $S_{\\text{excess}} = \\max(0, S-1)$, since the exact solution's gradient has only one sign change.\n\nThe implementation will follow these steps for each test case provided. The final results will be aggregated and printed in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_diagnostics(u_full, N, a_L, a_R):\n    \"\"\"\n    Computes the flux jump and excess sign changes for a given solution.\n    \"\"\"\n    h = 1.0 / N\n    # The interface is at node j = N/2. The problem guarantees N is even.\n    j = N // 2\n    \n    u = np.array(u_full)\n\n    # 1. Compute the magnitude of the physical flux jump J\n    flux_L = -a_L * (u[j] - u[j-1]) / h\n    flux_R = -a_R * (u[j+1] - u[j]) / h\n    J = np.abs(flux_L - flux_R)\n\n    # 2. Compute the excess sign changes S_excess\n    deltas = u[1:] - u[:-1]\n    # Use a small tolerance for floating point comparisons to zero\n    non_zero_deltas = deltas[np.abs(deltas) > 1e-15]\n    \n    if len(non_zero_deltas)  2:\n        S_excess = 0\n    else:\n        signs = np.sign(non_zero_deltas)\n        # Count number of times the sign flips\n        sign_flips = np.sum(signs[:-1] != signs[1:])\n        # The exact solution is unimodal, so its derivative changes sign once.\n        S_excess = max(0, sign_flips - 1)\n        \n    return J, int(S_excess)\n\ndef solve_case(N, a_L, a_R):\n    \"\"\"\n    Solves the 1D elliptic interface problem for a given set of parameters\n    using both Bubnov-Galerkin and Petrov-Galerkin methods.\n    \"\"\"\n    h = 1.0 / N\n    # Interface node index j, and number of interior nodes\n    j = N // 2\n    num_interior_nodes = N - 1\n\n    # --- Assemble Stiffness Matrix (common to both methods) ---\n    # The system is for the N-1 interior nodes u_1, ..., u_{N-1}\n    K = np.zeros((num_interior_nodes, num_interior_nodes))\n\n    # Loop over interior nodes i = 1, ..., N-1\n    # The corresponding matrix row/column index is k = i - 1\n    for i in range(1, N):\n        k = i - 1\n        if i  j:\n            # Region with coefficient a_L\n            if k > 0:\n                K[k, k-1] = -a_L / h\n            K[k, k] = 2.0 * a_L / h\n            K[k, k+1] = -a_L / h\n        elif i > j:\n            # Region with coefficient a_R\n            K[k, k-1] = -a_R / h\n            K[k, k] = 2.0 * a_R / h\n            if k  num_interior_nodes - 1:\n                K[k, k+1] = -a_R / h\n        else:  # i == j (interface node)\n            K[k, k-1] = -a_L / h\n            K[k, k] = (a_L + a_R) / h\n            K[k, k+1] = -a_R / h\n    \n    # --- 1. Bubnov-Galerkin Method ---\n    K_bubnov = K\n    # Right-hand side vector F, where F_i = integral(f*phi_i) = h since f=1\n    F_bubnov = np.full(num_interior_nodes, h)\n    \n    u_interior_bubnov = np.linalg.solve(K_bubnov, F_bubnov)\n    # Reconstruct full solution with boundary conditions u(0)=0, u(1)=0\n    u_bubnov = np.concatenate(([0], u_interior_bubnov, [0]))\n    \n    J_bubnov, S_bubnov = calculate_diagnostics(u_bubnov, N, a_L, a_R)\n\n    # --- 2. Petrov-Galerkin Method ---\n    K_petrov = K  # Stiffness matrix is the same\n    F_petrov = np.copy(F_bubnov)\n    # Modify the RHS for the interface node equation (row j-1) to enforce flux continuity\n    F_petrov[j-1] = 0.0\n    \n    u_interior_petrov = np.linalg.solve(K_petrov, F_petrov)\n    u_petrov = np.concatenate(([0], u_interior_petrov, [0]))\n\n    J_petrov, S_petrov = calculate_diagnostics(u_petrov, N, a_L, a_R)\n    \n    return [J_bubnov, J_petrov, S_bubnov, S_petrov]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, a_L, a_R)\n        (10, 1.0, 10.0),      # Case A\n        (10, 1e-3, 1.0),      # Case B\n        (4, 1.0, 1000.0)      # Case C\n    ]\n\n    results_str_list = []\n    for case in test_cases:\n        N, a_L, a_R = case\n        result_vals = solve_case(N, a_L, a_R)\n        # Format each inner list string without spaces to match example\n        inner_list_str = f\"[{result_vals[0]},{result_vals[1]},{result_vals[2]},{result_vals[3]}]\"\n        results_str_list.append(inner_list_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```"
        }
    ]
}