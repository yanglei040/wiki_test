{
    "hands_on_practices": [
        {
            "introduction": "双权残差(DWR)方法的核心在于利用伴随解（或对偶解）$z$ 对局部残差 $R_K$ 进行加权，以估计误差。这个加权后的乘积，即误差指示器 $\\eta_K$, 衡量了每个网格单元对我们所关心的目标泛函 $J(u)$ 的总误差贡献。本练习将让您直接上手计算这些误差指示器并对网格单元进行排序，从而剥离求解偏微分方程的复杂性，聚焦于DWR方法驱动自适应网格加密(AMR)的核心机制。",
            "id": "3514494",
            "problem": "考虑一个针对线性化多物理场耦合系统的有限元法 (FEM) 离散化的目标导向自适应网格加密 (AMR) 程序，其中我们关心的是一个标量输出泛函 $J(u)$。设 $u$ 为精确解，$u_{h}$ 为离散解。在对偶加权残差 (DWR) 框架中，$J(u)$ 误差的带符号单元贡献是通过用伴随（对偶）解的样本对单元残差进行加权来确定的，该伴随解解析了 $J(u)$ 对 $u$ 中扰动的敏感度。假设采用协调离散和分段光滑系数，从而使得单元残差在检验函数空间上被良好地定义为线性泛函，并且对偶解足够正则，可以按单元进行采样。\n\n给定三个对 $J(u)$ 有贡献的单元 $K=1,2,3$，其单元残差值为 $\\{R_{K}\\}=\\{\\,1.2,\\,-0.5,\\,0.8\\,\\}$，相应的采样对偶权重为 $\\{z_{h,K}\\}=\\{\\,0.4,\\,1.1,\\,0.2\\,\\}$。在标准 DWR 局部性假设下，取每个单元 $K$ 的带符号贡献为其残差与对偶样本加权的结果，并通过将其带符号贡献的绝对值大小按降序排序来确定单元的加密优先级。如果出现绝对值完全相等的情况，则优先选择较小的单元索引。\n\n计算这三个带符号的贡献值，并按绝对贡献值的降序提供三个单元索引的排名。将您的最终答案表示为一个包含六个条目的单行矩阵：首先按 $K=1,2,3$ 的顺序列出三个带符号的贡献值，然后是按要求排序的三个单元索引。无需四舍五入；请报告精确的小数值。这些量是无量纲的。",
            "solution": "用户提供了一个关于使用对偶加权残差 (DWR) 方法进行目标导向自适应网格加密 (AMR) 的问题。\n\n### 步骤 1：提取已知条件\n- **方法**：使用对偶加权残差 (DWR) 框架对有限元法 (FEM) 离散化进行目标导向自适应网格加密 (AMR)。\n- **关注量**：一个标量输出泛函 $J(u)$。\n- **单元**：三个索引为 $K=1, 2, 3$ 的单元。\n- **单元残差**：单元残差值集合为 $\\{R_K\\} = \\{1.2, -0.5, 0.8\\}$，其中 $R_1=1.2$, $R_2=-0.5$，$R_3=0.8$。\n- **采样对偶权重**：相应的采样对偶权重集合为 $\\{z_{h,K}\\} = \\{0.4, 1.1, 0.2\\}$，其中 $z_{h,1}=0.4$, $z_{h,2}=1.1$，$z_{h,3}=0.2$。\n- **误差指示器计算**：每个单元 $K$ 对误差的带符号贡献是通过其残差与对偶样本加权得到的。设此贡献为 $\\eta_K$。因此，$\\eta_K = R_K \\cdot z_{h,K}$。这基于 DWR 局部性假设。\n- **排名标准**：单元按其带符号贡献的绝对值 $|\\eta_K|$ 的降序进行排名。\n- **平局处理规则**：如果 $|\\eta_K|$ 出现平局，则优先选择索引 $K$ 较小的单元。\n- **要求输出**：一个包含六个条目的单行矩阵：按顺序排列的三个带符号贡献 $\\eta_1, \\eta_2, \\eta_3$，后跟按加密优先级降序排列的三个单元索引 $K$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，因为 DWR 方法是计算工程和科学领域中用于后验误差估计和网格自适应的标准且成熟的技术。该问题是适定的，提供了所有必要的数据（$R_K$, $z_{h,K}$）以及清晰明确的计算和排名程序。语言客观且专业。该问题未违反任何无效标准。它是偏微分方程数值分析中一个关键概念的直接且有效的应用。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### 解答\n该问题要求计算三个有限元的带符号误差贡献，并基于 DWR 方法对它们进行网格加密的后续排名。\n\n每个单元 $K$ 的带符号贡献（或误差指示器）$\\eta_K$ 由该单元的残差 $R_K$ 与从对偶（伴随）解中采样的相应值 $z_{h,K}$ 的乘积给出。公式为：\n$$\n\\eta_K = R_K \\cdot z_{h,K}\n$$\n\n给定单元 $K=1, 2, 3$ 的以下值：\n- 对于单元 $K=1$：$R_1 = 1.2$，$z_{h,1} = 0.4$。\n- 对于单元 $K=2$：$R_2 = -0.5$，$z_{h,2} = 1.1$。\n- 对于单元 $K=3$：$R_3 = 0.8$，$z_{h,3} = 0.2$。\n\n首先，我们计算每个单元的带符号贡献 $\\eta_K$。\n\n对于单元 $K=1$：\n$$\n\\eta_1 = R_1 \\cdot z_{h,1} = (1.2) \\cdot (0.4) = 0.48\n$$\n\n对于单元 $K=2$：\n$$\n\\eta_2 = R_2 \\cdot z_{h,2} = (-0.5) \\cdot (1.1) = -0.55\n$$\n\n对于单元 $K=3$：\n$$\n\\eta_3 = R_3 \\cdot z_{h,3} = (0.8) \\cdot (0.2) = 0.16\n$$\n\n按单元索引（$K=1, 2, 3$）顺序排列的三个带符号贡献是 $\\{0.48, -0.55, 0.16\\}$。\n\n接下来，我们对单元进行加密优先级的排名。排名基于这些贡献的绝对值 $|\\eta_K|$，按降序排列。\n\n我们计算每个贡献的绝对值：\n- 对于 $K=1$：$|\\eta_1| = |0.48| = 0.48$。\n- 对于 $K=2$：$|\\eta_2| = |-0.55| = 0.55$。\n- 对于 $K=3$：$|\\eta_3| = |0.16| = 0.16$。\n\n现在，我们将这些绝对值按降序排列：\n$$\n0.55 > 0.48 > 0.16\n$$\n这些值对应于以下单元：\n- 最大值 $0.55$ 对应于单元 $K=2$。\n- 第二大值 $0.48$ 对应于单元 $K=1$。\n- 最小值 $0.16$ 对应于单元 $K=3$。\n\n绝对值没有出现平局，因此不启用平局处理规则。\n\n因此，按加密优先级降序排列的单元索引为 $2, 1, 3$。\n\n最终答案要求一个包含六个条目的单行矩阵：三个带符号贡献（$\\eta_1, \\eta_2, \\eta_3$），后跟三个排好序的单元索引。这些条目是：$0.48, -0.55, 0.16, 2, 1, 3$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.48  -0.55  0.16  2  1  3\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在理解了如何使用残差和伴随权重之后，一个自然的问题是：这些量从何而来？本练习通过一个完整但简单的一维泊松问题，揭示了伽辽金正交性这一有限元方法的基石 ()。您将发现，由于伽辽金正交性，如果伴随问题在与原始问题完全相同的离散空间中求解，DWR误差估计将恒为零。这凸显了“伴随加密”的必要性——即在更高阶或更精细的网格上求解伴随问题，这是获得有效误差估计的关键一步。",
            "id": "3330525",
            "problem": "考虑在域$\\Omega=(0,1)$上带有齐次狄利克雷边界条件的一维泊松问题，其中主变量$u$满足强形式$-u''=f$（在$\\Omega$中），$u(0)=u(1)=0$，源项为常数$f(x)=1$。目标泛函为$J(u)=\\int_{0}^{1} u\\,dx$。相应的弱形式为：寻找$u\\in H_{0}^{1}(\\Omega)$，使得对于所有$v\\in H_{0}^{1}(\\Omega)$，有$\\int_{0}^{1} u' v'\\,dx = \\int_{0}^{1} f v\\,dx$。对偶加权残差（DWR）方法旨在求解由$J$的Gateaux导数导出的伴随问题，即寻找$z\\in H_{0}^{1}(\\Omega)$，使得对于所有$v\\in H_{0}^{1}(\\Omega)$，有$\\int_{0}^{1} v' z'\\,dx = \\int_{0}^{1} v\\,dx$。\n\n在一个包含两个单元$K_{1}=(0,\\tfrac{1}{2})$和$K_{2}=(\\tfrac{1}{2},1)$的均匀网格上，考虑连续有限元（FE）逼近$u_{h}\\in V_{h}\\subset H_{0}^{1}(\\Omega)$，其中$V_{h}$是在$x=0$和$x=1$处为零的连续分片线性函数空间。离散伴随解$z_{h}\\in V_{h}$的定义类似，即对于所有$v_{h}\\in V_{h}$，有$\\int_{0}^{1} v_{h}' z_{h}'\\,dx = \\int_{0}^{1} v_{h}\\,dx$。对于对偶加权残差，主问题逼近的弱残差为$R(u_{h})(w):=\\int_{0}^{1} f w\\,dx - \\int_{0}^{1} u_{h}' w'\\,dx$（对于任意$w\\in H_{0}^{1}(\\Omega)$），而单元指示子（使用伴随权重）与分解$R(u_{h})(w)=\\sum_{K\\in\\{K_{1},K_{2}\\}} \\Big(\\int_{K} f w\\,dx - \\int_{K} u_{h}' w'\\,dx\\Big)$相关联。\n\n任务：\n- 在给定的双单元网格上计算连续有限元解$u_{h}$。\n- 计算精确伴随解$z$，并将其用作加细的伴随权重来定义单元指示子$\\eta_{K}:=\\int_{K} f z\\,dx - \\int_{K} u_{h}' z'\\,dx$（对于$K\\in\\{K_{1},K_{2}\\}$）。\n- 使用仅加细伴随空间的廉价估计子理念，将全局估计子取为$\\mathcal{E}_{\\text{cheap}}:=\\eta_{K_{1}}+\\eta_{K_{2}}=R(u_{h})(z)$并计算其值。\n\n最后，从概念上解释当伴随解未被加细（即$z_{h}\\in V_{h}$）时$R(u_{h})(z_{h})$会发生什么，并将其与仅加细伴随空间的情况进行比较。在你的解释中，简要评论相同的思想如何扩展到间断Galerkin（DG）方法，其中单元内部残差$f+\\nabla\\cdot(\\nabla u_{h})$和单元间通量跳跃会进入指示子。将$\\mathcal{E}_{\\text{cheap}}$的最终数值表示为精确分数；无需四舍五入。",
            "solution": "该问题陈述经证实具有科学依据、适定且客观。它提出了一个使用对偶加权残差（DWR）技术进行有限元方法后验误差分析的标准练习，这是计算科学中的一个核心课题。所有数据和定义都已提供且一致。因此，我们可以着手求解。\n\n求解过程包括三个主要的计算步骤，之后是一个概念性解释。\n\n首先，我们计算在指定网格上的连续分片线性有限元（FE）解$u_h$。网格由两个单元$K_1 = (0, \\frac{1}{2})$和$K_2 = (\\frac{1}{2}, 1)$组成。有限元空间$V_h$由在每个单元上是线性的、且在域边界$x=0$和$x=1$处为零的连续函数构成。这只留下一个自由度，即解在内部节点$x=\\frac{1}{2}$处的值。设$\\phi(x)$是与此节点相关的标准线性“帽子”基函数：\n$$\n\\phi(x) = \\begin{cases}\n2x  \\text{若 } x \\in [0, \\frac{1}{2}] \\\\\n2(1-x)  \\text{若 } x \\in [\\frac{1}{2}, 1]\n\\end{cases}\n$$\n有限元解$u_h$可以写成$u_h(x) = U \\phi(x)$，其中$U = u_h(\\frac{1}{2})$是待确定的未知系数。其导数为$u_h'(x) = U \\phi'(x)$，其中\n$$\n\\phi'(x) = \\begin{cases}\n2  \\text{若 } x \\in (0, \\frac{1}{2}) \\\\\n-2  \\text{若 } x \\in (\\frac{1}{2}, 1)\n\\end{cases}\n$$\n通过求解离散弱形式（取$v_h = \\phi(x)$）来找到未知数$U$：\n$$\n\\int_{0}^{1} u_h'(x) \\phi'(x) \\,dx = \\int_{0}^{1} f(x) \\phi(x) \\,dx\n$$\n代入$u_h'(x) = U \\phi'(x)$和$f(x)=1$，我们得到：\n$$\nU \\int_{0}^{1} (\\phi'(x))^2 \\,dx = \\int_{0}^{1} \\phi(x) \\,dx\n$$\n我们计算这两个积分：\n左侧积分为：\n$$\n\\int_{0}^{1} (\\phi'(x))^2 \\,dx = \\int_{0}^{1/2} (2)^2 \\,dx + \\int_{1/2}^{1} (-2)^2 \\,dx = 4 \\cdot \\frac{1}{2} + 4 \\cdot \\frac{1}{2} = 4\n$$\n右侧积分为：\n$$\n\\int_{0}^{1} \\phi(x) \\,dx = \\int_{0}^{1/2} 2x \\,dx + \\int_{1/2}^{1} 2(1-x) \\,dx = [x^2]_0^{1/2} + [2x - x^2]_{1/2}^1 = \\frac{1}{4} + \\left( (2-1) - (1 - \\frac{1}{4}) \\right) = \\frac{1}{4} + \\frac{1}{4} = \\frac{1}{2}\n$$\n关于$U$的方程变为$4U = \\frac{1}{2}$，解得$U = \\frac{1}{8}$。\n因此，有限元解为：\n$$\nu_h(x) = \\frac{1}{8} \\phi(x) = \\begin{cases}\n\\frac{x}{4}  \\text{若 } x \\in [0, \\frac{1}{2}] \\\\\n\\frac{1-x}{4}  \\text{若 } x \\in [\\frac{1}{2}, 1]\n\\end{cases}\n$$\n其导数为：\n$$\nu_h'(x) = \\begin{cases}\n\\frac{1}{4}  \\text{若 } x \\in (0, \\frac{1}{2}) \\\\\n-\\frac{1}{4}  \\text{若 } x \\in (\\frac{1}{2}, 1)\n\\end{cases}\n$$\n\n其次，我们计算精确伴随解$z$。$z$的弱形式为$\\int_{0}^{1} v' z'\\,dx = \\int_{0}^{1} v\\,dx$，对所有$v\\in H_{0}^{1}(\\Omega)$成立。这对应于强形式$-z'' = 1$（在$\\Omega=(0,1)$中）和齐次狄利克雷边界条件$z(0)=z(1)=0$。积分两次得到$z(x) = -\\frac{x^2}{2} + C_1 x + C_2$。边界条件$z(0)=0$和$z(1)=0$给出$C_2=0$和$C_1=\\frac{1}{2}$。精确伴随解为：\n$$\nz(x) = \\frac{x}{2} - \\frac{x^2}{2} = \\frac{1}{2}x(1-x)\n$$\n其导数为$z'(x) = \\frac{1}{2} - x$。\n\n第三，我们计算单元指示子$\\eta_K$和全局估计子$\\mathcal{E}_{\\text{cheap}}$。一个单元$K$的指示子定义为$\\eta_K = \\int_K f z \\,dx - \\int_K u_h' z' \\,dx$。\n\n对于单元$K_1 = (0, \\frac{1}{2})$：\n$$\n\\eta_{K_1} = \\int_{0}^{1/2} (1) \\left(\\frac{x}{2} - \\frac{x^2}{2}\\right) \\,dx - \\int_{0}^{1/2} \\left(\\frac{1}{4}\\right) \\left(\\frac{1}{2} - x\\right) \\,dx\n$$\n第一个积分为$\\frac{1}{2} [\\frac{x^2}{2} - \\frac{x^3}{3}]_0^{1/2} = \\frac{1}{2} \\left(\\frac{1}{8} - \\frac{1}{24}\\right) = \\frac{1}{2} \\left(\\frac{2}{24}\\right) = \\frac{1}{24}$。\n第二个积分为$\\frac{1}{4} [\\frac{x}{2} - \\frac{x^2}{2}]_0^{1/2} = \\frac{1}{4} \\left(\\frac{1}{4} - \\frac{1}{8}\\right) = \\frac{1}{4} \\left(\\frac{1}{8}\\right) = \\frac{1}{32}$。\n所以，$\\eta_{K_1} = \\frac{1}{24} - \\frac{1}{32} = \\frac{4-3}{96} = \\frac{1}{96}$。\n\n对于单元$K_2 = (\\frac{1}{2}, 1)$：\n$$\n\\eta_{K_2} = \\int_{1/2}^{1} (1) \\left(\\frac{x}{2} - \\frac{x^2}{2}\\right) \\,dx - \\int_{1/2}^{1} \\left(-\\frac{1}{4}\\right) \\left(\\frac{1}{2} - x\\right) \\,dx\n$$\n第一个积分为$\\frac{1}{2} [\\frac{x^2}{2} - \\frac{x^3}{3}]_{1/2}^{1} = \\frac{1}{2} \\left[ \\left(\\frac{1}{2} - \\frac{1}{3}\\right) - \\left(\\frac{1}{8} - \\frac{1}{24}\\right) \\right] = \\frac{1}{2} \\left[ \\frac{1}{6} - \\frac{2}{24} \\right] = \\frac{1}{2} \\left[ \\frac{1}{6} - \\frac{1}{12} \\right] = \\frac{1}{24}$。\n第二个积分为$\\frac{1}{4} \\int_{1/2}^{1} \\left(x - \\frac{1}{2}\\right) \\,dx = \\frac{1}{4} [\\frac{x^2}{2} - \\frac{x}{2}]_{1/2}^{1} = \\frac{1}{4} \\left[ \\left(\\frac{1}{2} - \\frac{1}{2}\\right) - \\left(\\frac{1}{8} - \\frac{1}{4}\\right) \\right] = \\frac{1}{4} \\left[ - \\left(-\\frac{1}{8}\\right) \\right] = \\frac{1}{32}$。\n所以，$\\eta_{K_2} = \\frac{1}{24} - \\frac{1}{32} = \\frac{4-3}{96} = \\frac{1}{96}$。\n\n全局估计子是单元指示子之和：\n$$\n\\mathcal{E}_{\\text{cheap}} = \\eta_{K_1} + \\eta_{K_2} = \\frac{1}{96} + \\frac{1}{96} = \\frac{2}{96} = \\frac{1}{48}\n$$\n\n最后，我们提供概念性解释。弱残差定义为$R(u_{h})(w) = \\int_{0}^{1} f w\\,dx - \\int_{0}^{1} u_{h}' w'\\,dx$。有限元解$u_h \\in V_h$的定义恰好是，对于任何测试函数$v_h \\in V_h$，此残差为零。这个性质被称为Galerkin正交性。如果伴随逼近$z_h$在与主问题逼近$u_h$相同的空间$V_h$中求解（即没有加细），那么$z_h$是主问题的一个有效测试函数。因此，$R(u_h)(z_h) = 0$。一个基于$R(u_h)(z_h)$的误差估计子将总是为零，无论实际误差如何，这使其在自适应性或误差量化方面毫无用处。\n\n这突显了DWR方法的核心原则：要获得一个非零、有意义的误差估计，伴随问题必须在一个比主有限元空间$V_h$更“丰富”的空间中逼近。通过“加细”伴随空间（例如，使用更高阶的多项式或更密的网格），我们得到一个不属于$V_h$的逼近伴随解$z_{h, \\text{rich}}$。此时残差$R(u_h)(z_{h, \\text{rich}})$非零，并提供了目标泛函中误差$J(u) - J(u_h)$的一个估计。在本问题中，我们使用精确解$z$作为加细的最终形式。DWR理论的一个关键结果指出，泛函中的精确误差恰好是由精确伴随误差加权的残差，即$J(u)-J(u_h) = R(u_h)(z-z_h)$。由于$R(u_h)(z_h)=0$，这可以简化为$J(u)-J(u_h) = R(u_h)(z)$。因此，我们的计算结果$\\mathcal{E}_{\\text{cheap}} = R(u_h)(z) = \\frac{1}{48}$不是一个估计，而是泛函$J(u)$中的精确误差。\n\n这个概念直接扩展到间断Galerkin（DG）方法。在DG设置中，解空间允许在单元面上存在间断。相应的弱形式不仅包括单元内部的积分，还包括单元面上的积分（通量项），用于惩罚跳跃。分部积分后，DG方法的单元DWR指示子$\\eta_K$将包含来自单元内部残差（例如，$f + \\Delta_h u_h$）和单元间跳跃残差（例如，$u_h$的值或法向通量的跳跃）的贡献。与连续情形一样，Galerkin正交性确保如果伴随测试函数选自与主问题解相同的DG空间，那么所有这些加权残差之和为零。因此，在DG背景下，加细伴随空间对于获得一个用于驱动自适应网格加密的非平凡且有效的误差估计子同样至关重要。",
            "answer": "$$\n\\boxed{\\frac{1}{48}}\n$$"
        },
        {
            "introduction": "这个更高级的练习旨在揭示DWR方法的一个深刻见解：目标泛函的误差并非简单取决于残差的大小，而是取决于残差与伴随解之间的“相关性”或“谱对齐”。您将构建一个特殊的场景：尽管局部残差很大，但由于它们与伴随解的乘积在全局积分时相互抵消，最终的全局误差却非常小 ()。这项实践阐明了DWR方法的真正威力，它能精确识别出那些对目标物理量有显著影响的误差来源，从而避免在不重要的区域进行不必要的计算资源投入。",
            "id": "3381923",
            "problem": "考虑区间 $[0,1]$ 上具有齐次狄利克雷边界条件的一维稳态椭圆边值问题：求精确解 $u$，使得\n$$\n-\\frac{d^2 u}{dx^2} = f \\quad \\text{in } (0,1), \\qquad u(0)=u(1)=0,\n$$\n其中源项 $f$ 由给定的精确解 $u$ 通过算子 $L u = -u'' = f$ 导出。设目标量为线性泛函\n$$\nJ(u) = \\int_0^1 \\psi(x)\\,u(x)\\,dx,\n$$\n其中 $\\psi$ 为给定的权重函数。对偶加权余量 (DWR) 方法通过求解权重 $z$ 的伴随（对偶）问题来评估 $J$ 中的误差，该问题定义为\n$$\n-\\frac{d^2 z}{dx^2} = \\psi(x) \\quad \\text{in } (0,1), \\qquad z(0)=z(1)=0.\n$$\n在将域划分为单元 $\\{K\\}$ 的间断伽辽金框架中，单元余量 $R_K$ 是原始余量 $R = L(u_h) - f$ 在 $K$ 上的限制，其中 $u_h$ 是 $u$ 的一个近似解。DWR 误差表示汇集了局部加权贡献 $\\langle R_K, z\\rangle = \\int_K R(x)\\,z(x)\\,dx$。您的任务是构建并量化一个场景，该场景表现为局部余量 $R_K$ 很大但伴随权重 $z$ 很小，导致在全局总和 $\\sum_K \\langle R_K, z\\rangle$ 中几乎完全抵消，然后解释为何 $J(u)$ 中的误差可以忽略不计的机制。\n\n您必须实现与上述模型一致的谱构造和单元聚合。请使用以下设置。\n\n1. 域和算子：\n   - 域为 $[0,1]$。\n   - 算子为 $L = -\\frac{d^2}{dx^2}$，带有齐次狄利克雷边界条件。\n\n2. 精确解 $u$：\n   - 通过满足边界条件的有限正弦级数定义 $u(x)$：\n     $$\n     u(x) = \\sum_{n\\in \\{1,2,10,15\\}} a_n \\sin(n\\pi x),\n     $$\n     系数为 $a_1=0.5$，$a_2=0.3$，$a_{10}=1.0$，$a_{15}=0.8$。\n   - 源项 $f$ 随之定义为 $f(x) = \\sum_{n\\in \\{1,2,10,15\\}} (n\\pi)^2 a_n \\sin(n\\pi x)$。\n\n3. 近似解 $u_h$（欠解析的谱离散化）：\n   - 通过截断和扰动低频部分来定义 $u_h(x)$：\n     $$\n     u_h(x) = \\sum_{n\\in \\{1,2\\}} b_n \\sin(n\\pi x),\n     $$\n     系数为 $b_1=0.48$，$b_2=0.28$。\n\n4. 余量和伴随问题：\n   - 定义原始余量 $R(x) = L(u_h)(x) - f(x) = -u_h''(x) - f(x)$。\n   - 对于每个测试案例，求解伴随问题 $-z'' = \\psi$ 并满足 $z(0)=z(1)=0$。您将使用与所选 $\\psi$ 对应的 $z$ 的闭式解。\n\n5. 单元聚合：\n   - 将 $[0,1]$ 划分为 $N_{\\mathrm{el}}=20$ 个单元 $K_j = \\left[\\frac{j}{N_{\\mathrm{el}}}, \\frac{j+1}{N_{\\mathrm{el}}}\\right]$, $j=0,\\dots,19$。\n   - 对于每个单元 $K$，使用每个单元 $Q=100$ 个点的高斯求积计算 $\\langle R_K, z\\rangle = \\int_K R(x)\\,z(x)\\,dx$。\n   - 计算全局加权余量总和 $E = \\sum_K \\langle R_K, z\\rangle$。\n   - 计算局部贡献的总量级 $S = \\sum_K \\left|\\langle R_K, z\\rangle\\right|$。\n   - 定义抵消率 $C = \\frac{|E|}{S}$，并约定当 $S=0$ 时 $C=0$。\n\n6. 目标量误差：\n   - 通过在 $[0,1]$ 上使用足够精确的高斯求积（使用 $Q_{\\mathrm{global}}=2000$ 个点）计算 $J(u)-J(u_h)$。这为具有齐次边界条件的自伴随算子的加权余量和 $E$ 提供了独立检验。\n\n7. 测试套件：\n   - 案例1（低频权重加上一个微小的高频扰动）：$\\psi_1(x) = \\sin(\\pi x) + \\alpha \\sin(10\\pi x)$，其中 $\\alpha = 0.01$。\n     预期的机制是 $R$ 的高频分量与 $z$ 的对齐较弱，因此局部贡献的符号会振荡并大部分相互抵消，而微小的低频失配则导致一个小的净误差。\n   - 案例2（与余量匹配的高频权重）：$\\psi_2(x) = \\sin(10\\pi x)$。\n     预期的机制是 $z$ 与 $u_h$ 中缺失的主导模式相匹配，因此局部贡献会相长地叠加，导致一个具有最小抵消的大误差。\n   - 案例3（光滑非振荡权重）：$\\psi_3(x) = 1$（常数函数）。\n     在这种情况下，$z(x)$ 是二次且光滑的。预期的机制是 $R$ 快速振荡，其与光滑 $z$ 的乘积在局部上被平均掉，从而产生强烈的抵消和一个可忽略的净误差。\n\n8. 输出要求：\n   - 对于每个测试案例，计算两个浮点数：DWR 误差 $E$ 和抵消率 $C$。\n   - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表中的六个结果，顺序为 $[E_1,C_1,E_2,C_2,E_3,C_3]$，其中 $E_i$ 和 $C_i$ 对应于测试案例 $i=1,2,3$。\n\n所有量都是无量纲的；不涉及物理单位。适用时，角度以弧度为单位。使用指定的求积阶数和单元划分，确保数值稳定性和准确性。该场景必须在科学上是现实的，并从上面提供的基本设置中导出。实现的程序必须完全自包含，不需要任何输入，并遵守输出规范。",
            "solution": "该问题被评估为有效，因为它在科学上基于数值分析和后验误差估计的原理，提法良好并提供了所有必要信息，且表述客观。所提供的设置是一个自洽且定义明确的数值实验，用于演示对偶加权余量 (DWR) 方法的机制。\n\n求解过程如下。首先，我们建立所有相关函数的解析形式：精确解 $u$、近似解 $u_h$、由此产生的余量 $R$ 以及每个测试案例的对偶解 $z$。其次，我们描述用于计算逐单元加权余量并将其聚合以求得总估计误差 $E$ 和抵消率 $C$ 的数值程序。最后，我们分析每个测试案例，将函数的数学结构与预期的数值结果联系起来。\n\n**1. 解析框架**\n\n问题围绕区间 $[0,1]$ 上具有齐次狄利克雷边界条件的一维泊松方程展开：\n$$\nL u = -\\frac{d^2 u}{dx^2} = f(x) \\quad \\text{for } x \\in (0,1), \\quad u(0)=u(1)=0.\n$$\n目标量是一个线性泛函 $J(u) = \\int_0^1 \\psi(x) u(x) dx$。相关的对偶（或伴随）问题由以下公式给出：\n$$\nL^* z = -\\frac{d^2 z}{dx^2} = \\psi(x) \\quad \\text{for } x \\in (0,1), \\quad z(0)=z(1)=0.\n$$\n由于带有这些边界条件的算子 $L$ 是自伴随的 ($L^*=L$)，目标量中的误差 $J(u) - J(u_h)$ 可以与原始余量 $R(x)$ 和对偶解 $z(x)$ 相关联。令 $e(x) = u(x) - u_h(x)$ 为近似误差。\n$$\nJ(u) - J(u_h) = J(e) = \\int_0^1 \\psi(x) e(x) dx = \\int_0^1 (-z''(x)) e(x) dx.\n$$\n两次分部积分并利用 $e$ 和 $z$ 的齐次边界条件可得：\n$$\nJ(e) = \\int_0^1 z(x) (-e''(x)) dx = \\int_0^1 z(x) (-u''(x) + u_h''(x)) dx.\n$$\n使用 $-u''(x)=f(x)$，上式变为：\n$$\nJ(e) = \\int_0^1 z(x) (f(x) + u_h''(x)) dx = - \\int_0^1 z(x) (-u_h''(x) - f(x)) dx.\n$$\n问题将原始余量定义为 $R(x) = L(u_h)(x) - f(x) = -u_h''(x) - f(x)$。因此，精确的误差表示为：\n$$\nJ(u) - J(u_h) = -\\int_0^1 R(x) z(x) dx.\n$$\n问题要求计算量 $E = \\sum_K \\langle R_K, z \\rangle = \\int_0^1 R(x) z(x) dx$。因此，$E$ 表示目标量误差的负值，即 $E = -(J(u)-J(u_h))$。在整个计算过程中都遵循此符号约定。\n\n**2. 函数定义**\n\n- **精确解 $u(x)$**：\n  $u(x) = \\sum_{n \\in \\{1,2,10,15\\}} a_n \\sin(n\\pi x)$，系数为 $a_1=0.5$，$a_2=0.3$，$a_{10}=1.0$，$a_{15}=0.8$。\n  $$u(x) = 0.5 \\sin(\\pi x) + 0.3 \\sin(2\\pi x) + 1.0 \\sin(10\\pi x) + 0.8 \\sin(15\\pi x)$$\n\n- **源项 $f(x)$**：\n  $f(x) = -u''(x) = \\sum_{n \\in \\{1,2,10,15\\}} (n\\pi)^2 a_n \\sin(n\\pi x)$。\n\n- **近似解 $u_h(x)$**：\n  $u_h(x) = \\sum_{n \\in \\{1,2\\}} b_n \\sin(n\\pi x)$，系数为 $b_1=0.48$，$b_2=0.28$。\n  $$u_h(x) = 0.48 \\sin(\\pi x) + 0.28 \\sin(2\\pi x)$$\n\n- **原始余量 $R(x)$**：\n  $R(x) = -u_h''(x) - f(x) = \\sum_{n \\in \\{1,2\\}} (n\\pi)^2 (b_n - a_n) \\sin(n\\pi x) - \\sum_{n \\in \\{10,15\\}} (n\\pi)^2 a_n \\sin(n\\pi x)$。\n  代入系数：\n  $$R(x) = -(0.02)\\pi^2\\sin(\\pi x) - (0.02)(2\\pi)^2\\sin(2\\pi x) - (1.0)(10\\pi)^2\\sin(10\\pi x) - (0.8)(15\\pi)^2\\sin(15\\pi x)$$\n  余量由解的已解析分量中的误差引起的小振幅、低频模式，以及由未解析分量引起的大振幅、高频模式组成。\n\n- **对偶解 $z(x)$**：我们求解 $-z''=\\psi$ 并满足 $z(0)=z(1)=0$。对于 $\\sin(k\\pi x)$ 的右侧项，解为 $z(x) = \\frac{1}{(k\\pi)^2}\\sin(k\\pi x)$。对于 $\\psi=1$，解为 $z(x)=\\frac{x}{2}(1-x)$。\n  - **案例1**：$\\psi_1(x) = \\sin(\\pi x) + 0.01 \\sin(10\\pi x)$\n    $$z_1(x) = \\frac{1}{\\pi^2}\\sin(\\pi x) + \\frac{0.01}{(10\\pi)^2}\\sin(10\\pi x)$$\n  - **案例2**：$\\psi_2(x) = \\sin(10\\pi x)$\n    $$z_2(x) = \\frac{1}{(10\\pi)^2}\\sin(10\\pi x)$$\n  - **案例3**：$\\psi_3(x) = 1$\n    $$z_3(x) = \\frac{x}{2}(1-x)$$\n\n**3. 数值计算与分析**\n\n域 $[0,1]$ 被划分为 $N_{\\mathrm{el}}=20$ 个单元 $K_j$。在每个单元上，我们使用 $Q=100$ 个点的高斯求积来计算局部加权余量 $\\langle R_K, z \\rangle_j = \\int_{K_j} R(x)z(x)dx$。这些局部值被汇集以形成：\n- 全局加权余量和：$E = \\sum_{j=0}^{N_{\\mathrm{el}}-1} \\langle R_K, z \\rangle_j$。\n- 局部贡献的总量级：$S = \\sum_{j=0}^{N_{\\mathrm{el}}-1} |\\langle R_K, z \\rangle_j|$。\n- 抵消率：$C = \\frac{|E|}{S}$。\n\n比率 $C$ 衡量了局部加权余量之间的抵消程度。$C \\approx 1$ 的值表示所有局部贡献都具有相同的符号并相长地叠加，意味着没有抵消。$C \\ll 1$ 的值表示局部贡献的符号振荡并大部分相互抵消，导致全局误差估计 $|E|$ 远小于局部指标的量级之和 $S$。\n\n- **案例1分析**：对偶解 $z_1(x)$ 由其低频分量主导。余量 $R(x)$ 具有大的高频分量。乘积 $R(x)z_1(x)$ 包含诸如 $\\sin(10\\pi x)\\sin(\\pi x)$ 之类的项，这些项会快速振荡。当在每个单元上积分时，这些项产生的值很小，并且倾向于在不同单元之间改变符号，从而导致在全局总和 $E_1$ 中发生显著的抵消。净误差主要由 $R(x)$ 和 $z_1(x)$ 的微小低频部分的乘积决定。因此，我们预期误差 $E_1$ 和抵消率 $C_1$ 都会很小。\n\n- **案例2分析**：对偶解 $z_2(x)$ 是一个单一的高频模式，它直接对应于近似解 $u_h$ 中最大的未解析模式（$\\sin(10\\pi x)$ 项）。被积函数 $R(x)z_2(x)$ 有一个主导项 $-(\\sin(10\\pi x))^2 \\cdot (10\\pi)^2 / (10\\pi)^2 = -\\sin^2(10\\pi x)$。该项在任何地方都是非正的，因此局部积分 $\\langle R_K, z_2 \\rangle_j$ 全为负。它们会相长地叠加。这导致一个大的全局误差 $E_2$ 和一个接近于 1 的抵消率 $C_2$。\n\n- **案例3分析**：对偶解 $z_3(x)$ 是一个光滑、非振荡的二次函数。余量 $R(x)$ 是高度振荡的。乘积 $R(x)z_3(x)$ 是一个受 $z_3(x)$ 光滑外形调制的快速振荡函数。在每个单元上，由于局部平均效应，该乘积的积分趋于很小。此外，由于 $R(x)$ 中模式的相位演进，这些微小局部积分的符号很可能会在单元边界处翻转。这导致强烈的全局抵消。我们预期误差 $E_3$ 会很小，抵消率 $C_3$ 会非常小。\n\n以下 Python 代码实现了此过程，以计算每种情况下的 $E$ 和 $C$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes DWR error estimates and cancellation ratios for three test cases\n    of a 1D elliptic problem.\n    \"\"\"\n    # 1. Setup of problem parameters and analytical functions\n\n    # Coefficients for exact solution u(x)\n    a_coeffs = {1: 0.5, 2: 0.3, 10: 1.0, 15: 0.8}\n    # Coefficients for approximate solution u_h(x)\n    b_coeffs = {1: 0.48, 2: 0.28}\n\n    # Numerical parameters\n    N_el = 20  # Number of elements\n    Q = 100    # Quadrature points per element\n\n    # Define the residual function R(x) = -u_h''(x) - f(x)\n    # R(x) = sum_{n} (n*pi)^2 * (b_n - a_n) * sin(n*pi*x)\n    # Note: b_n is zero for n=10, 15\n    def R_func(x):\n        res = 0.0\n        pi = np.pi\n        \n        # Low frequency errors\n        res += (1 * pi)**2 * (b_coeffs[1] - a_coeffs[1]) * np.sin(1 * pi * x)\n        res += (2 * pi)**2 * (b_coeffs[2] - a_coeffs[2]) * np.sin(2 * pi * x)\n        \n        # High frequency (unresolved) errors\n        res += (10 * pi)**2 * (0 - a_coeffs[10]) * np.sin(10 * pi * x)\n        res += (15 * pi)**2 * (0 - a_coeffs[15]) * np.sin(15 * pi * x)\n        \n        return res\n\n    # Define the dual solutions z(x) for each case\n    pi = np.pi\n    alpha = 0.01\n\n    def z1_func(x):\n        # Corresponds to psi_1(x) = sin(pi*x) + alpha*sin(10*pi*x)\n        return (1 / pi**2) * np.sin(pi * x) + (alpha / (10 * pi)**2) * np.sin(10 * pi * x)\n\n    def z2_func(x):\n        # Corresponds to psi_2(x) = sin(10*pi*x)\n        return (1 / (10 * pi)**2) * np.sin(10 * pi * x)\n\n    def z3_func(x):\n        # Corresponds to psi_3(x) = 1\n        return 0.5 * x * (1 - x)\n\n    test_z_funcs = [z1_func, z2_func, z3_func]\n    \n    # 2. Gaussian Quadrature helper function\n    \n    # Pre-calculate Gauss-Legendre points and weights for [-1, 1]\n    gauss_points, gauss_weights = np.polynomial.legendre.leggauss(Q)\n\n    def gauss_quadrature(func, a, b):\n        \"\"\"\n        Integrates a function from a to b using pre-calculated Gauss points.\n        \"\"\"\n        # Map points from [-1, 1] to [a, b]\n        mapped_points = 0.5 * (b - a) * gauss_points + 0.5 * (a + b)\n        \n        # Evaluate the function at mapped points\n        func_vals = func(mapped_points)\n        \n        # Compute the integral\n        integral = 0.5 * (b - a) * np.sum(gauss_weights * func_vals)\n        return integral\n\n    # 3. Main computation loop for each test case\n    \n    results = []\n    \n    for z_func in test_z_funcs:\n        \n        E = 0.0  # Global weighted residual sum\n        S = 0.0  # Sum of absolute local contributions\n        \n        # Define the integrand for this case\n        integrand = lambda x: R_func(x) * z_func(x)\n        \n        # Loop over elements\n        for j in range(N_el):\n            x_left = j / N_el\n            x_right = (j + 1) / N_el\n            \n            # Compute local weighted residual\n            local_integral = gauss_quadrature(integrand, x_left, x_right)\n            \n            E += local_integral\n            S += np.abs(local_integral)\n            \n        # Compute cancellation ratio\n        # Use a small tolerance for floating point comparison to zero\n        C = np.abs(E) / S if S > 1e-15 else 0.0\n        \n        results.extend([E, C])\n\n    # 4. Final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}