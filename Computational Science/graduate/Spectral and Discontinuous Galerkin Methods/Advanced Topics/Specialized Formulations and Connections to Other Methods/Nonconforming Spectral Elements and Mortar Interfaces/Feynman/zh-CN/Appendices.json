{
    "hands_on_practices": [
        {
            "introduction": "当两个谱单元的界面上存在多项式阶数跳跃（即p-型不整合）时，最直接的后果是自由度的不匹配。这个练习将引导你计算在一个标准的砂浆法设置中，为了处理这种不匹配需要施加多少个约束。这是理解界面信息如何被平衡的基础，也是掌握非协调离散方法的关键第一步 。",
            "id": "3403322",
            "problem": "考虑二维空间中两个四边形谱元之间的一个非协调界面。沿共享边的几何映射是仿射的，因此多项式迹是同构映射。左侧（密）单元在每个坐标方向上使用多项式阶为 $p_{f}$ 的分层模态谱基，右侧（疏）单元在每个坐标方向上使用多项式阶为 $p_{c}$ 的分层模态谱基，且 $p_{f} > p_{c}$。在它们共同的直边上，迹空间分别是参考区间 $[-1,1]$ 上的一维多项式空间 $P_{p_{f}}$ 和 $P_{p_{c}}$。假设边上的分层基的构造使得 $P_{p_{c}} \\subset P_{p_{f}}$ 作为子空间成立，并且边自由度恰好是这些分层边基的系数。\n\n跨越非协调界面的连续性是通过经典的砂浆法施加的，其中疏侧为主，密侧为从：密侧上的迹受到弱约束，使其在 $P_{p_{c}}$ 上的投影与疏侧的迹相匹配，而密侧迹中任何与 $P_{p_{c}}$ 正交的分量都必须通过独立的代数约束来消除。两个共享顶点的端点连续性通过网格连接性强加，不应单独计算。\n\n仅使用迹空间、多项式阶和分层子空间嵌套的核心定义，确定当 $p_{f} = 6$ 和 $p_{c} = 3$ 时，仅因 $p$-跳跃而必须在密侧边自由度上增加的独立代数约束的数量。您的最终答案必须是一个整数，无需四舍五入。",
            "solution": "用户要求我解决一个谱方法和间断Galerkin方法领域的问题。\n\n### 第一步：提取已知条件\n- **域：** 二维空间中两个四边形谱元之间的非协调界面。\n- **界面边：** 共享边是直的，且几何映射是仿射的。\n- **单元属性：**\n    - 左单元（密）：多项式阶为 $p_f$ 的分层模态谱基。\n    - 右单元（疏）：多项式阶为 $p_c$ 的分层模态谱基。\n- **多项式阶条件：** $p_f > p_c$。\n- **迹空间：** 沿共享边（一个参考区间 $[-1,1]$），迹空间为：\n    - 密侧：$P_{p_f}$，次数最多为 $p_f$ 的一维多项式空间。\n    - 疏侧：$P_{p_c}$，次数最多为 $p_c$ 的一维多项式空间。\n- **基属性：** 分层基确保 $P_{p_c}$ 是 $P_{p_f}$ 的一个子空间，即 $P_{p_c} \\subset P_{p_f}$。\n- **自由度 (DOFs)：** 边自由度是分层边基的系数。\n- **连续性施加（砂浆法）：**\n    - 疏侧为主；密侧为从。\n    - **耦合约束：** 密侧上的迹 $u_f \\in P_{p_f}$ 受到弱约束，使其在 $P_{p_c}$ 上的投影与疏侧的迹 $u_c \\in P_{p_c}$ 相匹配。\n    - **附加约束：** 密侧迹中任何与 $P_{p_c}$ 正交的分量都必须通过独立的代数约束来消除。\n- **顶点处理：** 两个共享顶点的端点连续性是强加的，不计入最终答案。\n- **具体值：** $p_f = 6$ 和 $p_c = 3$。\n- **问题：** 确定仅因 $p$-跳跃而必须在密侧边自由度上增加的独立代数约束的数量。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学依据：** 该问题牢固地植根于偏微分方程数值方法的理论，特别是谱元法和间断Galerkin方法。迹空间、分层基、p-非协调性和砂浆法等概念在该领域是标准且明确定义的。整个设置在科学和数学上是合理的。\n- **适定性：** 问题是适定的。它清晰完整地描述了数学空间、自由度和约束机制。问题要求一个特定的整数值，该值可以从所提供的定义和数据中唯一确定。\n- **客观性：** 问题以精确、客观、技术性的语言陈述，没有歧义或主观论断。\n\n### 第三步：结论与行动\n该问题是有效的。这是一个关于理解 $p$-型谱元离散化中非协调界面上自由度和约束的标准练习。我将继续进行求解。\n\n该问题要求在一种特定的砂浆式耦合策略下，由于多项式阶的跳跃，施加在密侧边自由度上的独立代数约束的数量。\n\n单元边上的自由度（DOFs）由该边上多项式迹空间的维度给出。一维上次数最多为 $p$ 的多项式空间（记为 $P_p$）的维度为 $p+1$。\n\n对于界面的密侧，迹空间为 $P_{p_f}$。此侧的自由度数量 $N_f$ 是该空间的维度：\n$$N_f = \\dim(P_{p_f}) = p_f + 1$$\n\n对于界面的疏侧，迹空间为 $P_{p_c}$。此侧的自由度数量 $N_c$ 是该空间的维度：\n$$N_c = \\dim(P_{p_c}) = p_c + 1$$\n\n问题陈述中提到基是分层的，这确保了疏侧的多项式空间是密侧多项式空间的真子空间，因为 $p_f > p_c$。这表示为 $P_{p_c} \\subset P_{p_f}$。\n\n连续性的施加分为两部分：\n1.  密侧上的迹（$u_f \\in P_{p_f}$）受到约束，使其在疏空间 $P_{p_c}$ 上的投影与疏侧上的迹（$u_c \\in P_{p_c}$）相匹配。这是砂浆法的耦合部分。它有效地将密侧上等于 $P_{p_c}$ 维度的自由度数量与疏侧上相应的自由度联系起来。这类耦合条件的数量是 $\\dim(P_{p_c}) = p_c + 1$。\n\n2.  密侧迹中任何与 $P_{p_c}$ 正交的分量都必须被消除。这指的是解 $u_f$ 中位于 $P_{p_f}$ 内 $P_{p_c}$ 的补空间中的部分。我们将此补空间记为 $P_{p_f} \\setminus P_{p_c}$。该补空间的维度是两个空间维度之差：\n$$\\dim(P_{p_f} \\setminus P_{p_c}) = \\dim(P_{p_f}) - \\dim(P_{p_c}) = N_f - N_c$$\n代入维度的表达式：\n$$\\dim(P_{p_f} \\setminus P_{p_c}) = (p_f + 1) - (p_c + 1) = p_f - p_c$$\n“消除”解在该空间中的分量意味着将其约束为零。这需要施加数量等于该空间维度的独立代数约束。这些是仅应用于密侧自由度的约束，用以处理在疏侧没有对应项的高阶模态。\n\n问题明确要求这些“消除”约束的数量，这些约束“仅因 $p$-跳跃而”产生。关于顶点连续性强加的说明是为了确认我们应关注多项式函数空间本身的不匹配，而不是边的共享端点。我们基于完整多项式空间的维度进行的计算，$\\dim(P_{p_f}) - \\dim(P_{p_c})$，正确地分离了多项式阶不匹配的影响。\n\n因此，所需的独立代数约束数量为 $p_f - p_c$。\n\n给定具体值 $p_f = 6$ 和 $p_c = 3$，我们可以计算约束的数量：\n$$\\text{约束数量} = p_f - p_c = 6 - 3 = 3$$\n这 $3$ 个约束强制使密侧边上次数为 $4$、$5$ 和 $6$ 的分层基函数的系数为零。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "在理解了如何量化不匹配的自由度之后，本练习将深入探讨砂浆方法的核心机制：$L^2$ 投影。通过对特定多项式显式地计算其投影，你将具体地看到该方法如何精确地传递低阶信息，并量化那些无法在较粗糙一侧表示的高阶分量的投影误差 。这种分析对于建立关于砂浆耦合算子性质的深刻直觉至关重要。",
            "id": "3403327",
            "problem": "考虑一个粗糙父边和两个精细子边之间的一维非协调界面（砂浆）。设父界面为 $\\Gamma=[-1,1]$，两个子界面为 $\\Gamma_{L}=[-1,0]$ 和 $\\Gamma_{R}=[0,1]$。设父迹空间为 $\\Gamma$ 上所有次数至多为 $3$ 的实多项式构成的多项式空间 $\\mathbb{P}_{3}(\\Gamma)$，并设每个子迹是 $\\mathbb{P}_{3}([-1,1])$ 中的多项式在 $\\Gamma_{L}$ 或 $\\Gamma_{R}$ 上的限制。通过变分条件定义典范砂浆投影 $\\Pi_{M}:\\left.\\mathbb{P}_{3}([-1,1])\\right|_{\\Gamma_{L}\\cup\\Gamma_{R}}\\to \\mathbb{P}_{3}(\\Gamma)$\n$$\n\\int_{-1}^{1} (\\Pi_{M} u)(s)\\, v(s)\\, \\mathrm{d}s \\;=\\; \\int_{-1}^{0} u(s)\\, v(s)\\, \\mathrm{d}s \\;+\\; \\int_{0}^{1} u(s)\\, v(s)\\, \\mathrm{d}s\\quad \\text{对于所有 } v\\in \\mathbb{P}_{3}(\\Gamma).\n$$\n假设所有积分都精确计算。\n\n从 $L^{2}$ 内积的定义和 $[-1,1]$ 上正交多项式的基本性质出发，完成以下任务：\n\n- 通过上述变分定义和多项式正交性的显式推理，证明如果 $u\\in \\mathbb{P}_{3}([-1,1])$，则对所有 $s\\in [-1,1]$ 都有 $(\\Pi_{M}u)(s)=u(s)$；也就是说，次数至多为 $3$ 的多项式能精确地通过砂浆层。\n\n- 接下来，取 $u(s)=s^{4}$ 并计算在 $\\Gamma$ 上的砂浆投影误差 $e(s):=u(s)-(\\Pi_{M}u)(s)$。将 $e(s)$ 表示为关于 $s$ 的单个闭式解析表达式。\n\n你的最终答案应为 $e(s)$ 关于 $s$ 的简化表达式。无需四舍五入。",
            "solution": "在尝试求解之前，将首先根据指定标准对问题进行验证。\n\n### 步骤 1：提取已知条件\n问题陈述中明确给出的数据、变量和条件如下：\n- 父界面：$\\Gamma = [-1, 1]$。\n- 子界面：$\\Gamma_{L} = [-1, 0]$ 和 $\\Gamma_{R} = [0, 1]$。\n- 父迹空间：$\\mathbb{P}_{3}(\\Gamma)$，即 $\\Gamma$ 上次数至多为 $3$ 的实多项式空间。\n- 子迹：$\\mathbb{P}_{3}([-1,1])$ 中多项式在 $\\Gamma_{L}$ 或 $\\Gamma_{R}$ 上的限制。\n- 砂浆投影算子：$\\Pi_{M}:\\left.\\mathbb{P}_{3}([-1,1])\\right|_{\\Gamma_{L}\\cup\\Gamma_{R}}\\to \\mathbb{P}_{3}(\\Gamma)$。\n- 砂浆投影的变分定义：\n$$\n\\int_{-1}^{1} (\\Pi_{M} u)(s)\\, v(s)\\, \\mathrm{d}s \\;=\\; \\int_{-1}^{0} u(s)\\, v(s)\\, \\mathrm{d}s \\;+\\; \\int_{0}^{1} u(s)\\, v(s)\\, \\mathrm{d}s\\quad \\text{对于所有 } v\\in \\mathbb{P}_{3}(\\Gamma).\n$$\n- 假设：所有积分都精确计算。\n- 任务 1：证明如果 $u\\in \\mathbb{P}_{3}([-1,1])$，则对所有 $s\\in [-1,1]$ 都有 $(\\Pi_{M}u)(s)=u(s)$。\n- 任务 2：对于 $u(s)=s^{4}$，计算砂浆投影误差 $e(s):=u(s)-(\\Pi_{M}u)(s)$。\n- 要求的最终答案：$e(s)$ 的简化闭式解析表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n对问题进行关键的验证检查。\n- **科学依据：** 该问题牢固地植根于数值分析这一数学领域，特别是谱方法和间断 Galerkin 方法的理论。砂浆法、多项式空间 ($\\mathbb{P}_k$) 和 $L^2$ 投影是标准的、定义明确的概念。该设置是用于分析此类方法性质的典范一维示例。\n- **适定性：** 该问题是适定的。所提供的变分定义唯一地将算子 $\\Pi_M$ 定义为到有限维空间 $\\mathbb{P}_3(\\Gamma)$ 上的 $L^2$ 投影，这保证了投影函数 $(\\Pi_M u)$ 的存在性和唯一性。任务是具体的，并能导出一个唯一的、有意义的解。\n- **客观性：** 问题以精确、客观的数学语言表述，没有任何主观性或歧义。\n- **完整性和一致性：** 问题是自洽的。所有关于空间、定义域和投影算子的必要定义都已提供。没有缺失的数据或矛盾的约束。定积分的可加性简化了变分定义的右侧，但这是问题的一个特点，而不是缺陷。\n\n该问题不违反任何无效标准。这是一个应用数学中的标准、形式化问题。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。将提供完整解答。\n\n### 解答\n解答分为两部分，对应于问题陈述中指定的两个任务。\n\n**第一部分：对 $u \\in \\mathbb{P}_{3}(\\Gamma)$ 的砂浆投影的精确性**\n\n砂浆投影 $\\Pi_{M}$ 的变分定义由下式给出：\n$$\n\\int_{-1}^{1} (\\Pi_{M} u)(s)\\, v(s)\\, \\mathrm{d}s \\;=\\; \\int_{-1}^{0} u(s)\\, v(s)\\, \\mathrm{d}s \\;+\\; \\int_{0}^{1} u(s)\\, v(s)\\, \\mathrm{d}s\n$$\n对于所有测试函数 $v \\in \\mathbb{P}_{3}(\\Gamma)$。\n\n根据定积分的可加性，右侧可以合并为在父域 $\\Gamma = [-1, 1]$ 上的单个积分：\n$$\n\\int_{-1}^{0} u(s)\\, v(s)\\, \\mathrm{d}s \\;+\\; \\int_{0}^{1} u(s)\\, v(s)\\, \\mathrm{d}s = \\int_{-1}^{1} u(s)\\, v(s)\\, \\mathrm{d}s\n$$\n因此，变分定义简化为：\n$$\n\\int_{-1}^{1} (\\Pi_{M} u)(s)\\, v(s)\\, \\mathrm{d}s = \\int_{-1}^{1} u(s)\\, v(s)\\, \\mathrm{d}s \\quad \\text{对于所有 } v\\in \\mathbb{P}_{3}(\\Gamma).\n$$\n这可以通过将所有项移到一边来改写：\n$$\n\\int_{-1}^{1} \\left( u(s) - (\\Pi_{M} u)(s) \\right) v(s)\\, \\mathrm{d}s = 0 \\quad \\text{对于所有 } v\\in \\mathbb{P}_{3}(\\Gamma).\n$$\n该方程表明函数 $u(s) - (\\Pi_{M} u)(s)$ 与空间 $\\mathbb{P}_{3}(\\Gamma)$ 中的每个函数都是 $L^2$ 正交的。注意，根据算子余域的定义，$\\Pi_M u$ 本身就是 $\\mathbb{P}_3(\\Gamma)$ 的一个元素。\n\n现在，考虑输入函数 $u$ 本身就是 $\\mathbb{P}_{3}(\\Gamma)$ 中的一个多项式的情况。在这种情况下，差值，我们称之为 $w(s) = u(s) - (\\Pi_{M} u)(s)$，也是一个次数至多为 $3$ 的多项式，即 $w \\in \\mathbb{P}_{3}(\\Gamma)$。\n\n正交条件表明，对于所有 $v \\in \\mathbb{P}_{3}(\\Gamma)$，有 $\\int_{-1}^{1} w(s) v(s) \\mathrm{d}s = 0$。由于 $w(s)$ 本身就是 $\\mathbb{P}_{3}(\\Gamma)$ 的一个元素，我们可以自由选择 $v(s) = w(s)$。代入这个选择得到：\n$$\n\\int_{-1}^{1} (w(s))^2\\, \\mathrm{d}s = 0.\n$$\n被积函数 $(w(s))^2$ 是区间 $[-1, 1]$ 上的一个非负连续函数（因为 $w(s)$ 是一个多项式）。这样一个函数的积分只有当该函数本身在积分区间上处处恒为零时才可能为零。\n因此，对于所有 $s \\in [-1, 1]$，我们必须有 $(w(s))^2 = 0$，这意味着对于所有 $s \\in [-1, 1]$，有 $w(s) = 0$。\n\n回想 $w(s)$ 的定义，这意味着：\n$$\nu(s) - (\\Pi_{M} u)(s) = 0 \\quad \\implies \\quad (\\Pi_{M} u)(s) = u(s) \\quad \\text{for all } s \\in [-1, 1].\n$$\n这证明了对于任何次数至多为 $3$ 的多项式 $u$，砂浆投影是恒等算子，意味着这样的多项式被精确传递。这是 $L^2$ 投影的一个基本性质：如果一个函数已经位于目标空间中，它的投影就是它自身。\n\n**第二部分：计算 $u(s) = s^4$ 的投影误差**\n\n我们需要计算 $u(s)=s^4$ 的投影误差 $e(s) = u(s) - (\\Pi_{M}u)(s)$。\n从第一部分我们知道，$(\\Pi_M u)(s)$ 是 $u(s)$ 到空间 $\\mathbb{P}_3(\\Gamma)$ 上的 $L^2$ 投影。设 $p(s) = (\\Pi_M u)(s) \\in \\mathbb{P}_3(\\Gamma)$。误差 $e(s) = u(s) - p(s) = s^4 - p(s)$ 必须与整个空间 $\\mathbb{P}_3(\\Gamma)$ 是 $L^2$ 正交的。\n\n为了找到这个投影和误差，我们利用 Legendre 多项式基 $\\{L_k(s)\\}_{k=0}^\\infty$，它们在区间 $[-1, 1]$ 上关于 $L^2$ 内积是正交的：$\\int_{-1}^1 L_j(s) L_k(s) \\mathrm{d}s = \\frac{2}{2k+1}\\delta_{jk}$，其中 $\\delta_{jk}$ 是 Kronecker delta。\n\n一个函数 $u(s)$ 到 $\\mathbb{P}_N(\\Gamma)$ 上的投影 $p(s)$ 是其 Legendre 级数展开在 $N$ 次的截断。这里，$N=3$。我们将 $u(s)=s^4$ 在 Legendre 基中展开：\n$$\nu(s) = \\sum_{k=0}^{4} c_k L_k(s), \\quad \\text{where} \\quad c_k = \\frac{\\langle u, L_k \\rangle}{\\langle L_k, L_k \\rangle} = \\frac{2k+1}{2} \\int_{-1}^1 u(s) L_k(s) \\mathrm{d}s.\n$$\n那么到 $\\mathbb{P}_3(\\Gamma)$ 上的投影是 $p(s) = \\sum_{k=0}^{3} c_k L_k(s)$，误差是 $e(s) = u(s) - p(s) = c_4 L_4(s)$。\n\n前几个 Legendre 多项式是：\n$L_0(s) = 1$\n$L_1(s) = s$\n$L_2(s) = \\frac{1}{2}(3s^2-1)$\n$L_3(s) = \\frac{1}{2}(5s^3-3s)$\n$L_4(s) = \\frac{1}{8}(35s^4 - 30s^2 + 3)$\n\n我们可以通过代数运算找到 $s^4$ 的展开式。从 $L_4(s)$ 的定义出发：\n$8 L_4(s) = 35s^4 - 30s^2 + 3$\n$35s^4 = 8L_4(s) + 30s^2 - 3$\n$s^4 = \\frac{8}{35}L_4(s) + \\frac{30}{35}s^2 - \\frac{3}{35} = \\frac{8}{35}L_4(s) + \\frac{6}{7}s^2 - \\frac{3}{35}$\n\n接下来，我们用 $L_2(s)$ 和 $L_0(s)$ 来表示 $s^2$：\n$L_2(s) = \\frac{3}{2}s^2 - \\frac{1}{2} \\implies 3s^2 = 2L_2(s) + 1 \\implies s^2 = \\frac{2}{3}L_2(s) + \\frac{1}{3}L_0(s)$。\n\n将此代入 $s^4$ 的表达式中：\n$s^4 = \\frac{8}{35}L_4(s) + \\frac{6}{7}\\left(\\frac{2}{3}L_2(s) + \\frac{1}{3}L_0(s)\\right) - \\frac{3}{35}L_0(s)$\n$s^4 = \\frac{8}{35}L_4(s) + \\frac{4}{7}L_2(s) + \\frac{2}{7}L_0(s) - \\frac{3}{35}L_0(s)$\n$s^4 = \\frac{8}{35}L_4(s) + \\frac{4}{7}L_2(s) + \\left(\\frac{10}{35} - \\frac{3}{35}\\right)L_0(s)$\n$s^4 = \\frac{8}{35}L_4(s) + \\frac{4}{7}L_2(s) + \\frac{1}{5}L_0(s)$\n\n函数 $u(s) = s^4$ 是一个偶函数，所以它的展开式只包含偶数指标的 Legendre 多项式，这与我们的结果一致。到 $\\mathbb{P}_3(\\Gamma)$ 上的投影是次数小于或等于 $3$ 的项之和：\n$$\np(s) = (\\Pi_M u)(s) = \\frac{1}{5}L_0(s) + \\frac{4}{7}L_2(s)\n$$\n投影误差 $e(s)$ 是展开式的剩余部分：\n$$\ne(s) = u(s) - p(s) = \\frac{8}{35}L_4(s)\n$$\n为了得到 $e(s)$ 关于 $s$ 的最终表达式，我们代入 $L_4(s)$ 的定义：\n$$\ne(s) = \\frac{8}{35} \\left( \\frac{1}{8}(35s^4 - 30s^2 + 3) \\right)\n$$\n$$\ne(s) = \\frac{1}{35} (35s^4 - 30s^2 + 3)\n$$\n$$\ne(s) = s^4 - \\frac{30}{35}s^2 + \\frac{3}{35}\n$$\n简化分数得到误差的最终解析表达式：\n$$\ne(s) = s^4 - \\frac{6}{7}s^2 + \\frac{3}{35}\n$$\n这就是所要求的砂浆投影误差的闭式表达式。",
            "answer": "$$\\boxed{s^4 - \\frac{6}{7}s^2 + \\frac{3}{35}}$$"
        },
        {
            "introduction": "最后的这个实践练习将理论与应用联系起来，指导你完成一个砂浆耦合系统的数值实现。你将亲手构建单元矩阵，使用拉格朗日乘子定义约束，并计算最终的舒尔补系统——这是许多高级求解器中的关键步骤 。通过分析其数值属性，如对称性和条件数，你将掌握在实际模拟中遇到的稳定性和适定性等关键实践问题。",
            "id": "3403378",
            "problem": "考虑一个一维反应扩散模型问题，该问题包含两个相邻的谱元，一个在区间 $[-1,0]$ 上的左单元和一个在区间 $[0,1]$ 上的右单元。设左侧多项式次数为 $p=2$，右侧为 $q=3$。偏微分方程为\n$$\n- u''(x) + \\alpha\\, u(x) = f(x) \\quad \\text{for } x \\in [-1,0]\\cup[0,1],\n$$\n在外边界上施加齐次约束，并在 $x=0$ 处施加一个弱界面约束：\n$$\nu(-1) = 0, \\quad u(1) = 0, \\quad \\text{and} \\quad u(0^-)=u(0^+).\n$$\n界面约束通过一个砂浆型拉格朗日乘子来强制施加。弱形式使用标准的能量泛函，并通过拉格朗日乘子施加约束，从而得到一个对称的鞍点系统。\n\n在每个子区间上使用谱元法，基函数采用与 Gauss–Lobatto–Legendre (GLL) 节点相关联的拉格朗日基函数。记其多项式次数为 $n=p$ 和 $m=q$，因此左单元有 $n+1$ 个 GLL 节点，右单元有 $m+1$ 个 GLL 节点。对于一个长度为 $h$ 的单元，从参考元到物理元的映射是线性的，其雅可比行列式为 $J=h/2$。使用 GLL 求积权重，单元级质量矩阵和刚度矩阵定义为\n$$\nM_e = \\frac{h}{2}\\, W, \\qquad K_e = \\frac{2}{h}\\, D^\\top W D + \\alpha\\, M_e,\n$$\n其中 $W$ 是 GLL 权重的对角矩阵，$D$ 是 GLL 微分矩阵，其元素为 $D_{ij} = \\ell_j'(\\xi_i)$，$\\ell_j$ 是在 GLL 节点 $\\{\\xi_i\\}$ 上求值的第 $j$ 个拉格朗日基函数。\n\n通过对左、右单元矩阵进行分块对角拼接来组装全局矩阵 $K$，不强加边界条件，而是通过一个拉格朗日乘子向量 $\\lambda \\in \\mathbb{R}^3$ 来施加约束。约束条件如下：\n- 左狄利克雷边界：$u_L(\\xi=-1)=0$，\n- 砂浆界面连续性：$u_L(\\xi=+1)=u_R(\\xi=-1)$，\n- 右狄利克雷边界：$u_R(\\xi=+1)=0$，\n这些约束由一个矩阵 $B \\in \\mathbb{R}^{3 \\times (n+1+m+1)}$ 编码，作用于两个单元拼接后的节点向量 $u$ 上。\n\n最终的 Karush–Kuhn–Tucker (KKT) 系统为\n$$\n\\begin{bmatrix}\nK  B^\\top \\\\\nB  0\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf \\\\ 0\n\\end{bmatrix},\n$$\n其中 $f$ 取为零向量（齐次情况），因此只有舒尔补的结构才重要。\n\n任务：\n1. 从第一性原理出发，使用 GLL 求积和微分矩阵 $D$ 推导出离散单元矩阵 $M_e$ 和 $K_e$。如上所述，构建全局分块对角矩阵 $K$ 和约束矩阵 $B$。\n2. 计算拉格朗日乘子的舒尔补矩阵\n$$\nS = - B\\, K^{-1} B^\\top,\n$$\n并针对指定配置进行显式和数值计算。\n3. 数值验证舒尔补 $S$ 的对称性和条件数，报告以下指标：\n   - 相对对称误差 $\\|S - S^\\top\\|_2 \\big/ \\|S\\|_2$，\n   - $-S$ 的谱条件数，定义为 $\\kappa(-S) = \\lambda_{\\max}(-S) / \\lambda_{\\min}(-S)$。\n以浮点数形式提供数值。\n\n使用以下参数值 $(h_L,h_R,\\alpha)$ 的测试套件来探究不同的单元尺寸和反应强度：\n- 情况 A（基准）：$(h_L,h_R,\\alpha) = (1.0, 1.0, 1.0)$，\n- 情况 B（左侧短单元）：$(h_L,h_R,\\alpha) = (0.5, 1.0, 1.0)$，\n- 情况 C（弱反应，右侧长单元）：$(h_L,h_R,\\alpha) = (1.0, 2.0, 0.01)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每种情况贡献一个包含两个浮点数的列表，顺序为 $[\\text{symmetry\\_error}, \\text{condition\\_number}]$。最终输出必须是\n$$\n\\big[ [\\text{A\\_sym}, \\text{A\\_cond}], [\\text{B\\_sym}, \\text{B\\_cond}], [\\text{C\\_sym}, \\text{C\\_cond}] \\big].\n$$\n不涉及物理单位；不适用角度。所有数值答案必须是浮点数。代码必须是自包含的，无需用户输入即可运行，并且必须使用上述第一性原理的定义（GLL 求积、拉格朗日基函数导数、组装和舒尔补）来实现计算。",
            "solution": "该问题要求对一个由砂浆型方法强制实现两个非协调谱元之间界面连续性所产生的舒尔补矩阵，进行数值构建和分析。该分析将针对一个一维反应扩散模型进行。解决方案分几个阶段进行：推导必要的谱方法组件、组装全局系统、计算舒尔补，最后对指定测试用例的其属性进行数值验证。\n\n### 1. 通过谱元法离散化\n\n该区域被分解为两个单元：一个长度为 $h_L$ 的左单元和一个长度为 $h_R$ 的右单元，它们在一个界面处相遇。在每个单元内部，解 $u(x)$ 由一个多项式来近似。我们采用节点方法，其中多项式由其在一组 Gauss-Lobatto-Legendre (GLL) 点上的值来表示。\n\n#### 1.1. Gauss-Lobatto-Legendre (GLL) 求积与基函数\n\n对于参考单元 $[-1, 1]$，使用 $N+1$ 个 GLL 节点（表示为 $\\{\\xi_i\\}_{i=0}^N$）定义一个次数为 $N$ 的多项式近似。这些节点是 $(1-\\xi^2)P'_N(\\xi) = 0$ 的根，其中 $P_N(\\xi)$ 是 $N$ 次 Legendre 多项式。该节点集包括端点 $\\xi_0 = -1$ 和 $\\xi_{N} = 1$。相关的求积权重为 $\\{w_i\\}_{i=0}^N$。\n\n基函数是拉格朗日多项式 $\\{\\ell_j(\\xi)\\}_{j=0}^N$，定义为 $\\ell_j(\\xi_k) = \\delta_{jk}$。这些基函数在 GLL 节点处的导数构成了微分矩阵 $D$，其元素为 $D_{ij} = \\ell'_j(\\xi_i)$。\n\n对于本问题，左单元的多项式次数为 $p=n=2$，对应于 $n+1=3$ 个 GLL 节点。右单元的次数为 $q=m=3$，对应于 $m+1=4$ 个 GLL 节点。\n\n- **左单元 ($n=2$)：**\n  - 节点: $\\xi_L = [-1, 0, 1]$。\n  - 权重: $w_L = [1/3, 4/3, 1/3]$。\n- **右单元 ($m=3$)：**\n  - 节点: $\\xi_R = [-1, -1/\\sqrt{5}, 1/\\sqrt{5}, 1]$。\n  - 权重: $w_R = [1/6, 5/6, 5/6, 1/6]$。\n\n微分矩阵 $D_L$（对于 $n=2$）和 $D_R$（对于 $m=3$）由 $\\ell'_j(\\xi_i)$ 的解析公式构建。\n\n#### 1.2. 单元级矩阵\n\n在单个长度为 $h = x_b-x_a$ 的单元 $[x_a, x_b]$ 上的偏微分方程弱形式为\n$$\n\\int_{x_a}^{x_b} (u'v' + \\alpha uv) dx = \\int_{x_a}^{x_b} fv dx,\n$$\n这里忽略了由组装和约束处理的边界/通量项。使用从参考单元 $[-1,1]$ 出发的线性映射 $x(\\xi) = (h/2)\\xi + (x_a+x_b)/2$，其雅可比行列式为 $J = h/2$，双线性形式变换为：\n$$\n\\int_{x_a}^{x_b} u'v' dx = \\frac{2}{h} \\int_{-1}^{1} \\frac{du}{d\\xi}\\frac{dv}{d\\xi} d\\xi \\quad \\text{和} \\quad \\int_{x_a}^{x_b} uv dx = \\frac{h}{2} \\int_{-1}^{1} uv d\\xi.\n$$\n应用 GLL 求积法，对这些积分进行近似。最终的单元刚度矩阵 $K_e$ 是拉普拉斯部分和质量部分之和：\n$$\nK_e = A_e + \\alpha M_e.\n$$\n问题陈述给出了标准的谱精确（对角）质量矩阵 $M_e = \\frac{h}{2} W$，其中 $W$ 是 GLL 权重的对角矩阵。离散拉普拉斯矩阵是 $A_e = \\frac{2}{h} D^\\top W D$。因此，单元刚度矩阵为：\n$$\nK_e = \\frac{2}{h} D^\\top W D + \\alpha \\frac{h}{2} W.\n$$\n由于所有测试用例中 $\\alpha > 0$ 且 $W$ 是正定的，因此 $K_e$ 将是对称且正定的。\n\n### 2. 全局系统组装与约束\n\n全局刚度矩阵 $K$ 是由左、右单元矩阵 $K_L$ 和 $K_R$ 分块对角组装而成的：\n$$\nK = \\begin{bmatrix} K_L  0 \\\\ 0  K_R \\end{bmatrix}.\n$$\n总自由度是拼接后的节点值 $u = [u_L^\\top, u_R^\\top]^\\top$，这是一个大小为 $(n+1) + (m+1) = 3+4=7$ 的向量。索引方式为 $u = [u_{L,0}, u_{L,1}, u_{L,2}, u_{R,0}, u_{R,1}, u_{R,2}, u_{R,3}]^\\top$。\n\n约束通过一个拉格朗日乘子向量 $\\lambda \\in \\mathbb{R}^3$ 来强制施加，对应于三个约束方程，记作 $Bu=0$：\n1.  **左狄利克雷约束：** $u(-h_L) = 0$。这是左单元第一个节点处的值，$u_{L,0}=0$。\n2.  **界面连续性：** $u(0^-) = u(0^+)$。这将左单元最后一个节点的值 $u_{L,n}$ 与右单元第一个节点的值 $u_{R,0}$ 等同起来。对于 $n=2$，即为 $u_{L,2} - u_{R,0} = 0$。\n3.  **右狄利克雷约束：** $u(h_R) = 0$。这是右单元最后一个节点处的值，$u_{R,m}=0$。对于 $m=3$，即为 $u_{R,3}=0$。\n\n这三个关于向量 $u$ 的线性方程定义了 $3 \\times 7$ 的约束矩阵 $B$：\n$$\nB = \\begin{pmatrix}\n1  0  0  0  0  0  0 \\\\\n0  0  1  -1  0  0  0 \\\\\n0  0  0  0  0  0  1\n\\end{pmatrix}.\n$$\n\n### 3. 舒尔补矩阵\n\n完整的鞍点系统由 Karush-Kuhn-Tucker (KKT) 方程给出：\n$$\n\\begin{bmatrix}\nK  B^\\top \\\\\nB  0\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf \\\\ 0\n\\end{bmatrix}.\n$$\n通过消去 $u = K^{-1}(f - B^\\top \\lambda)$，我们得到关于拉格朗日乘子 $\\lambda$ 的系统：$(B K^{-1} B^\\top) \\lambda = B K^{-1} f$。块 $K$ 的舒尔补是 $S_{KKT} = -B K^{-1} B^\\top$。问题将舒尔补定义为 $S = S_{KKT}$。\n$$\nS = -B K^{-1} B^\\top.\n$$\n由于 $K$ 是对称的，$K^{-1}$ 也是对称的。因此，$S$ 必须是对称的，因为 $S^\\top = -(B K^{-1} B^\\top)^\\top = -(B^\\top)^\\top (K^{-1})^\\top B^\\top = -B K^{-1} B^\\top = S$。任何与对称性的数值偏差都是由浮点算术误差引起的。\n\n矩阵 $-S = B K^{-1} B^\\top$ 预期是正定的。由于当 $\\alpha > 0$ 时 $K$ 是正定的，所以 $K^{-1}$ 也是正定的。对于任意非零向量 $v \\in \\mathbb{R}^3$，二次型 $v^\\top(-S)v = v^\\top B K^{-1} B^\\top v = (B^\\top v)^\\top K^{-1} (B^\\top v)$ 是正的，前提是 $B^\\top v \\neq 0$。矩阵 $B$ 具有满行秩，这意味着其转置 $B^\\top$ 具有平凡的零空间。因此，对于任何 $v \\neq 0$，都有 $B^\\top v \\neq 0$，从而保证了 $-S$ 是正定的。这使得其谱条件数 $\\kappa(-S) = \\lambda_{\\max}(-S) / \\lambda_{\\min}(-S)$ 的计算有意义。\n\n数值步骤包括：\n1.  对于每个测试用例 $(h_L, h_R, \\alpha)$，构建 $K_L$ 和 $K_R$。\n2.  组装全局矩阵 $K$ 和约束矩阵 $B$。\n3.  计算 $K^{-1}$ 并随后计算 $S = -B K^{-1} B^\\top$。\n4.  计算相对对称误差 $\\|S - S^\\top\\|_2 / \\|S\\|_2$。\n5.  计算对称正定矩阵 $-S$ 的特征值以求其条件数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre, roots_jacobi\n\ndef gll_data(N):\n    \"\"\"\n    Computes Gauss-Lobatto-Legendre (GLL) nodes, weights, and differentiation matrix.\n    \n    Args:\n        N (int): Polynomial degree.\n        \n    Returns:\n        tuple: A tuple containing:\n            - xi (np.ndarray): GLL nodes on [-1, 1].\n            - w (np.ndarray): GLL quadrature weights.\n            - D (np.ndarray): GLL differentiation matrix.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0]), np.array([2.0]), np.array([[0.0]])\n    if N == 1:\n        return np.array([-1., 1.]), np.array([1., 1.]), np.array([[-0.5, 0.5], [-0.5, 0.5]])\n\n    # Nodes are roots of (1-x^2)P'_N(x)\n    # The internal nodes are roots of P'_N(x), which are roots of Jacobi polynomial P_{N-1}^{(1,1)}(x)\n    if N > 1:\n        internal_nodes, _ = roots_jacobi(N - 1, 1, 1)\n    else:\n        internal_nodes = np.array([])\n    xi = np.concatenate(([-1.0], np.sort(internal_nodes), [1.0]))\n\n    # Weights\n    p_N = legendre(N)\n    w = 2 / (N * (N + 1) * p_N(xi)**2)\n\n    # Differentiation Matrix\n    D = np.zeros((N + 1, N + 1))\n    p_N_vals = p_N(xi)\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = p_N_vals[i] / (p_N_vals[j] * (xi[i] - xi[j]))\n            elif i == 0:\n                D[0, 0] = -N * (N + 1) / 4.0\n            elif i == N:\n                D[N, N] = N * (N + 1) / 4.0\n            else:\n                # Based on sum-to-zero property. For internal nodes this is 0.\n                D[i, i] = 0.0\n    \n    return xi, w, D\n\ndef solve_case(h_L, h_R, alpha):\n    \"\"\"\n    Solves one case of the problem by constructing matrices and computing metrics.\n    \n    Args:\n        h_L (float): Length of the left element.\n        h_R (float): Length of the right element.\n        alpha (float): Reaction coefficient.\n        \n    Returns:\n        list: A list containing [symmetry_error, condition_number].\n    \"\"\"\n    # 1. Get GLL data for left (n=2) and right (m=3) elements\n    n, m = 2, 3\n    _, w_L, D_L = gll_data(n)\n    _, w_R, D_R = gll_data(m)\n\n    # 2. Construct element stiffness matrices K_L and K_R\n    W_L = np.diag(w_L)\n    K_L = (2 / h_L) * (D_L.T @ W_L @ D_L) + alpha * (h_L / 2) * W_L\n\n    W_R = np.diag(w_R)\n    K_R = (2 / h_R) * (D_R.T @ W_R @ D_R) + alpha * (h_R / 2) * W_R\n\n    # 3. Assemble global block-diagonal stiffness matrix K\n    N_L, N_R = n + 1, m + 1\n    K = np.zeros((N_L + N_R, N_L + N_R))\n    K[0:N_L, 0:N_L] = K_L\n    K[N_L:N_L + N_R, N_L:N_L + N_R] = K_R\n\n    # 4. Construct constraint matrix B\n    # u = [u_L_0, u_L_1, u_L_2, u_R_0, u_R_1, u_R_2, u_R_3]^T\n    # Constraints are:\n    # 1. u_L(-1) = u_L,0 = 0\n    # 2. u_L(1) = u_R(-1) => u_L,n = u_R,0 => u_L,2 = u_R,0\n    # 3. u_R(1) = u_R,m = 0 => u_R,3 = 0\n    B = np.zeros((3, N_L + N_R))\n    B[0, 0] = 1.0          # u_L,0 = 0\n    B[1, n] = 1.0          # u_L,n - u_R,0 = 0\n    B[1, N_L] = -1.0\n    B[2, N_L + N_R - 1] = 1.0 # u_R,m = 0\n\n    # 5. Compute Schur complement S = -B K^{-1} B^T\n    K_inv = np.linalg.inv(K)\n    S = -B @ K_inv @ B.T\n    \n    # 6. Compute metrics for S\n    # Relative symmetry error using spectral norm\n    norm_S = np.linalg.norm(S, 2)\n    # Avoid division by zero if S is the zero matrix\n    sym_err = np.linalg.norm(S - S.T, 2) / norm_S if norm_S > 0 else 0.0\n    \n    # Condition number of -S\n    neg_S = -S\n    # -S is symmetric, so we can use eigvalsh for efficiency and stability\n    eigvals = np.linalg.eigvalsh(neg_S)\n    \n    # Check for positive definiteness\n    if np.any(eigvals <= 0):\n        raise ValueError(f\"Matrix -S is not positive definite for case ({h_L}, {h_R}, {alpha}). Eigenvalues: {eigvals}\")\n        \n    min_eig = np.min(eigvals)\n    cond_num = np.max(eigvals) / min_eig if min_eig > 0 else float('inf')\n\n    return [sym_err, cond_num]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (h_L, h_R, alpha) = (1.0, 1.0, 1.0)\n        (1.0, 1.0, 1.0),\n        # Case B: (h_L, h_R, alpha) = (0.5, 1.0, 1.0)\n        (0.5, 1.0, 1.0),\n        # Case C: (h_L, h_R, alpha) = (1.0, 2.0, 0.01)\n        (1.0, 2.0, 0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        h_L, h_R, alpha = case\n        result = solve_case(h_L, h_R, alpha)\n        results.append(result)\n\n    # Format output as specified: [[A_sym, A_cond], [B_sym, B_cond], [C_sym, C_cond]]\n    # Using a more explicit formatting to match the desired output string\n    # like [[val1, val2], [val3, val4], [val5, val6]]\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\n# The expected output from the problem is a single line, generated by calling solve().\n# For demonstration and validation, I will call the main function.\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}