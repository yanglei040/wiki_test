{
    "hands_on_practices": [
        {
            "introduction": "This practice is about engaging with the fundamental operators of Finite Element Exterior Calculus (FEEC) at the most granular level. We will compute the action of the discrete codifferential, $\\delta_h$, on a single triangular element, starting from its definition as the adjoint of the exterior derivative $d_h$. This exercise will solidify your understanding of how abstract concepts translate into concrete matrix operations involving incidence matrices and mass matrices derived from Whitney forms .",
            "id": "3372195",
            "problem": "Consider a single triangular mesh in the plane consisting of one equilateral triangle with vertices $v_{1}=(0,0)$, $v_{2}=(1,0)$, and $v_{3}=\\left(\\frac{1}{2},\\frac{\\sqrt{3}}{2}\\right)$. Let the oriented edges be $e_{12}$ from $v_{1}$ to $v_{2}$, $e_{23}$ from $v_{2}$ to $v_{3}$, and $e_{31}$ from $v_{3}$ to $v_{1}$, and orient the face by the ordering $(v_{1},v_{2},v_{3})$. Work in the standard Euclidean metric on $\\mathbb{R}^{2}$.\n\nUsing the framework of Finite Element Exterior Calculus (FEEC), let $\\{\\lambda_{i}\\}_{i=1}^{3}$ denote the barycentric coordinate functions (Whitney $0$-forms) and let the Whitney $1$-forms associated to the oriented edges be defined by\n$$\nW_{ij}=\\lambda_{i}\\,\\mathrm{d}\\lambda_{j}-\\lambda_{j}\\,\\mathrm{d}\\lambda_{i}.\n$$\nDefine the discrete codifferential $\\delta_{h}$ to be the adjoint of the discrete exterior derivative with respect to the $L^{2}$ inner products induced by the Whitney forms; that is, assemble the primal incidence matrix $D_{0}$ and compute the discrete Hodge star operators on Whitney $0$- and $1$-forms as the corresponding $L^{2}$ mass matrices. Then, apply $\\delta_{h}$ to the $1$-cochain $x\\in\\mathbb{R}^{3}$ whose coefficients on the oriented edge basis $\\{e_{12},e_{23},e_{31}\\}$ are $(1,0,0)$.\n\nCompute the component of the vector $\\delta_{h}x$ corresponding to the vertex $v_{2}$. Express your final answer as an exact number. No rounding is required.",
            "solution": "The user wants to compute a specific component of the vector resulting from the application of the discrete codifferential operator, $\\delta_{h}$, to a given $1$-cochain. The problem is set in the context of Finite Element Exterior Calculus (FEEC) on a single equilateral triangle.\n\n### Step 1: Problem Validation\n\nThe problem is a well-defined mathematical exercise within the field of numerical analysis and computational mathematics, specifically FEEC.\n- **Givens**:\n    - A single 2D mesh element: an equilateral triangle $T$.\n    - Vertices: $v_{1}=(0,0)$, $v_{2}=(1,0)$, and $v_{3}=(\\frac{1}{2},\\frac{\\sqrt{3}}{2})$. The side length is $s=1$.\n    - Oriented edges: $e_{12}$ (from $v_{1}$ to $v_{2}$), $e_{23}$ (from $v_{2}$ to $v_{3}$), and $e_{31}$ (from $v_{3}$ to $v_{1}$).\n    - Basis for $0$-forms (functions on vertices): Whitney $0$-forms $\\{\\lambda_i\\}_{i=1}^3$, which are the barycentric coordinates.\n    - Basis for $1$-forms (functions on edges): Whitney $1$-forms $\\{W_{12}, W_{23}, W_{31}\\}$ corresponding to the oriented edges. $W_{ij} = \\lambda_i d\\lambda_j - \\lambda_j d\\lambda_i$.\n    - The discrete codifferential $\\delta_h$ is defined as the adjoint of the discrete exterior derivative $d_h$ with respect to the $L^2$ inner products.\n    - The input is the $1$-cochain $x$ with coefficients $(1,0,0)$ in the edge basis $\\{e_{12}, e_{23}, e_{31}\\}$.\n- **Validation Verdict**: The problem is scientifically grounded, well-posed, objective, and self-contained. It relies on standard definitions from FEEC. The calculations are feasible. The problem is therefore deemed **valid**.\n\n### Step 2: Formulation of the Discrete Codifferential\n\nThe discrete codifferential $\\delta_{h,1}: C^1 \\to C^0$ maps $1$-cochains (vectors of coefficients for $1$-forms) to $0$-cochains (vectors of coefficients for $0$-forms). It is defined as the adjoint of the discrete exterior derivative $d_{h,0}: C^0 \\to C^1$ with respect to the $L^2$ inner products. These inner products are represented by mass matrices.\n\nLet $u \\in C^0$ be a $0$-cochain and $v \\in C^1$ be a $1$-cochain. The adjoint relationship is:\n$$\n\\langle d_{h,0} u, v \\rangle_1 = \\langle u, \\delta_{h,1} v \\rangle_0\n$$\nIn matrix terms, let $D_0$ be the incidence matrix representing $d_{h,0}$. Let $M_0$ and $M_1$ be the mass matrices for $0$-forms and $1$-forms, respectively. The inner products are defined as $\\langle a,b \\rangle_k = a^T M_k b$. The adjoint relationship becomes:\n$$\n(D_0 u)^T M_1 v = u^T M_0 (\\delta_{h,1} v)\n$$\n$$\nu^T D_0^T M_1 v = u^T M_0 (\\delta_{h,1} v)\n$$\nSince this must hold for all $u$, we have:\n$$\nD_0^T M_1 v = M_0 (\\delta_{h,1} v)\n$$\nSolving for the cochain $\\delta_{h,1} v$, we get its matrix representation:\n$$\n\\delta_{h,1} v = M_0^{-1} D_0^T M_1 v\n$$\nOur goal is to compute $y = \\delta_{h,1} x$, where $x = (1, 0, 0)^T$.\n\n### Step 3: Assembling the Matrices\n\nWe need to assemble the matrices $D_0$, $M_0$, and $M_1$.\n\n**A. Incidence Matrix $D_0$**\n$D_0$ is a $3 \\times 3$ matrix mapping from vertices to edges. The columns correspond to vertices $(v_1, v_2, v_3)$ and rows to oriented edges $(e_{12}, e_{23}, e_{31})$.\n- For edge $e_{12}$ (from $v_1$ to $v_2$): row is $(-1, 1, 0)$.\n- For edge $e_{23}$ (from $v_2$ to $v_3$): row is $(0, -1, 1)$.\n- For edge $e_{31}$ (from $v_3$ to $v_1$): row is $(1, 0, -1)$.\n$$\nD_0 = \\begin{pmatrix}\n-1 & 1 & 0 \\\\\n0 & -1 & 1 \\\\\n1 & 0 & -1\n\\end{pmatrix}\n$$\nThe transpose is:\n$$\nD_0^T = \\begin{pmatrix}\n-1 & 0 & 1 \\\\\n1 & -1 & 0 \\\\\n0 & 1 & -1\n\\end{pmatrix}\n$$\n\n**B. Mass Matrix for $0$-forms, $M_0$**\nThe entries are $(M_0)_{ij} = \\int_T \\lambda_i \\lambda_j \\, dA$. The area of the equilateral triangle with side length $s=1$ is $A = \\frac{\\sqrt{3}}{4}s^2 = \\frac{\\sqrt{3}}{4}$. Using the standard integral formula for barycentric coordinates over a triangle of area $A$:\n$$\n\\int_T \\lambda_i^p \\lambda_j^q \\lambda_k^r \\, dA = \\frac{p! q! r! 2!}{(p+q+r+2)!} A\n$$\n- Diagonal elements: $\\int_T \\lambda_i^2 \\, dA = \\frac{2!0!0!2!}{(2+2)!} A = \\frac{4}{24} A = \\frac{A}{6}$.\n- Off-diagonal elements: $\\int_T \\lambda_i \\lambda_j \\, dA = \\frac{1!1!0!2!}{(1+1+2)!} A = \\frac{2}{24} A = \\frac{A}{12}$.\nSo the mass matrix is:\n$$\nM_0 = \\frac{A}{12} \\begin{pmatrix}\n2 & 1 & 1 \\\\\n1 & 2 & 1 \\\\\n1 & 1 & 2\n\\end{pmatrix} = \\frac{\\sqrt{3}}{48} \\begin{pmatrix}\n2 & 1 & 1 \\\\\n1 & 2 & 1 \\\\\n1 & 1 & 2\n\\end{pmatrix}\n$$\n\n**C. Mass Matrix for $1$-forms, $M_1$**\nThe entries are $(M_1)_{IJ} = \\int_T W_I \\cdot W_J \\, dA$, where $I, J$ are from the edge basis $\\{e_{12}, e_{23}, e_{31}\\}$. The dot product is induced by the Euclidean metric. The gradients of the barycentric coordinates are constant vectors. For an equilateral triangle, $|\\nabla\\lambda_k|^2 = 4/3$ and for $i \\ne j$, $\\nabla\\lambda_i \\cdot \\nabla\\lambda_j = -2/3$.\n\n- Diagonal elements $(M_1)_{11} = \\int_T W_{12} \\cdot W_{12} \\, dA$:\n$$\n\\int_T (\\lambda_1 \\nabla\\lambda_2 - \\lambda_2 \\nabla\\lambda_1) \\cdot (\\lambda_1 \\nabla\\lambda_2 - \\lambda_2 \\nabla\\lambda_1) \\, dA = \\int_T (\\lambda_1^2 |\\nabla\\lambda_2|^2 - 2\\lambda_1\\lambda_2(\\nabla\\lambda_1\\cdot\\nabla\\lambda_2) + \\lambda_2^2|\\nabla\\lambda_1|^2) \\, dA\n$$\n$$\n= \\frac{4}{3}\\int_T \\lambda_1^2 \\, dA - 2(-\\frac{2}{3})\\int_T \\lambda_1\\lambda_2 \\, dA + \\frac{4}{3}\\int_T\\lambda_2^2 \\, dA = \\frac{4}{3}\\frac{A}{6} + \\frac{4}{3}\\frac{A}{12} + \\frac{4}{3}\\frac{A}{6} = \\frac{4A}{3}\\left(\\frac{1}{6} + \\frac{1}{12} + \\frac{1}{6}\\right) = \\frac{4A}{3}\\left(\\frac{2+1+2}{12}\\right) = \\frac{4A}{3}\\frac{5}{12} = \\frac{5A}{9}\n$$\nBy symmetry, all diagonal elements are $\\frac{5A}{9}$.\n\n- Off-diagonal elements $(M_1)_{12} = \\int_T W_{12} \\cdot W_{23} \\, dA$:\n$$\n\\int_T (\\lambda_1 \\nabla\\lambda_2 - \\lambda_2 \\nabla\\lambda_1) \\cdot (\\lambda_2 \\nabla\\lambda_3 - \\lambda_3 \\nabla\\lambda_2) \\, dA\n$$\n$$\n= \\int_T (\\lambda_1 \\lambda_2(\\nabla\\lambda_2\\cdot\\nabla\\lambda_3) - \\lambda_1 \\lambda_3|\\nabla\\lambda_2|^2 - \\lambda_2^2(\\nabla\\lambda_1\\cdot\\nabla\\lambda_3) + \\lambda_2 \\lambda_3(\\nabla\\lambda_1\\cdot\\nabla\\lambda_2)) \\, dA\n$$\n$$\n= (-\\frac{2}{3}) \\int_T \\lambda_1\\lambda_2 \\, dA - \\frac{4}{3} \\int_T \\lambda_1\\lambda_3 \\, dA - (-\\frac{2}{3}) \\int_T \\lambda_2^2 \\, dA + (-\\frac{2}{3}) \\int_T \\lambda_2\\lambda_3 \\, dA\n$$\n$$\n= -\\frac{2}{3}\\frac{A}{12} - \\frac{4}{3}\\frac{A}{12} + \\frac{2}{3}\\frac{A}{6} - \\frac{2}{3}\\frac{A}{12} = A\\left(-\\frac{2}{36} - \\frac{4}{36} + \\frac{4}{36} - \\frac{2}{36}\\right) = A\\left(\\frac{-2-4+4-2}{36}\\right) = -\\frac{4A}{36} = -\\frac{A}{9}\n$$\nBy symmetry, all off-diagonal elements are $-\\frac{A}{9}$.\n$$\nM_1 = \\frac{A}{9} \\begin{pmatrix}\n5 & -1 & -1 \\\\\n-1 & 5 & -1 \\\\\n-1 & -1 & 5\n\\end{pmatrix} = \\frac{\\sqrt{3}}{36} \\begin{pmatrix}\n5 & -1 & -1 \\\\\n-1 & 5 & -1 \\\\\n-1 & -1 & 5\n\\end{pmatrix}\n$$\n\n### Step 4: Calculation\n\nWe compute $y = M_0^{-1} D_0^T M_1 x$ step-by-step. The input cochain is $x = (1, 0, 0)^T$.\n\n**A. Compute $M_1 x$**\nThis is the first column of $M_1$:\n$$\nM_1 x = \\frac{A}{9} \\begin{pmatrix}\n5 & -1 & -1 \\\\\n-1 & 5 & -1 \\\\\n-1 & -1 & 5\n\\end{pmatrix}\n\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n= \\frac{A}{9} \\begin{pmatrix} 5 \\\\ -1 \\\\ -1 \\end{pmatrix}\n$$\n\n**B. Compute $D_0^T (M_1 x)$**\n$$\nD_0^T (M_1 x) = \\begin{pmatrix}\n-1 & 0 & 1 \\\\\n1 & -1 & 0 \\\\\n0 & 1 & -1\n\\end{pmatrix}\n\\left( \\frac{A}{9} \\begin{pmatrix} 5 \\\\ -1 \\\\ -1 \\end{pmatrix} \\right)\n= \\frac{A}{9} \\begin{pmatrix}\n(-1)(5) + (0)(-1) + (1)(-1) \\\\\n(1)(5) + (-1)(-1) + (0)(-1) \\\\\n(0)(5) + (1)(-1) + (-1)(-1)\n\\end{pmatrix}\n= \\frac{A}{9} \\begin{pmatrix} -6 \\\\ 6 \\\\ 0 \\end{pmatrix}\n= \\frac{A}{3} \\begin{pmatrix} -2 \\\\ 2 \\\\ 0 \\end{pmatrix}\n$$\n\n**C. Compute $M_0^{-1}$**\nLet $K = \\begin{pmatrix} 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{pmatrix}$. We have $\\det(K) = 4$.\nThe inverse is $K^{-1} = \\frac{1}{4} \\begin{pmatrix} 3 & -1 & -1 \\\\ -1 & 3 & -1 \\\\ -1 & -1 & 3 \\end{pmatrix}$.\nSince $M_0 = \\frac{A}{12} K$, its inverse is $M_0^{-1} = \\frac{12}{A} K^{-1} = \\frac{12}{A} \\frac{1}{4} \\begin{pmatrix} 3 & -1 & -1 \\\\ -1 & 3 & -1 \\\\ -1 & -1 & 3 \\end{pmatrix} = \\frac{3}{A} \\begin{pmatrix} 3 & -1 & -1 \\\\ -1 & 3 & -1 \\\\ -1 & -1 & 3 \\end{pmatrix}$.\n\n**D. Compute $y = M_0^{-1} (D_0^T M_1 x)$**\n$$\ny = \\left( \\frac{3}{A} \\begin{pmatrix} 3 & -1 & -1 \\\\ -1 & 3 & -1 \\\\ -1 & -1 & 3 \\end{pmatrix} \\right) \\left( \\frac{A}{3} \\begin{pmatrix} -2 \\\\ 2 \\\\ 0 \\end{pmatrix} \\right)\n$$\nThe scalar factors $\\frac{3}{A}$ and $\\frac{A}{3}$ cancel.\n$$\ny = \\begin{pmatrix} 3 & -1 & -1 \\\\ -1 & 3 & -1 \\\\ -1 & -1 & 3 \\end{pmatrix}\n\\begin{pmatrix} -2 \\\\ 2 \\\\ 0 \\end{pmatrix}\n= \\begin{pmatrix}\n(3)(-2) + (-1)(2) + (-1)(0) \\\\\n(-1)(-2) + (3)(2) + (-1)(0) \\\\\n(-1)(-2) + (-1)(2) + (3)(0)\n\\end{pmatrix}\n= \\begin{pmatrix}\n-6 - 2 \\\\\n2 + 6 \\\\\n2 - 2\n\\end{pmatrix}\n= \\begin{pmatrix}\n-8 \\\\\n8 \\\\\n0\n\\end{pmatrix}\n$$\nThe resulting vector $y$ represents the coefficients of the $0$-form $\\delta_h x$ in the vertex basis $\\{v_1, v_2, v_3\\}$. The component corresponding to vertex $v_2$ is the second element of this vector.\n\nThe component of $\\delta_h x$ corresponding to $v_2$ is $8$.",
            "answer": "$$\n\\boxed{8}\n$$"
        },
        {
            "introduction": "Moving from a single element to a full mesh, this practice explores the deep connection between differential forms and the underlying topology of the domain. You will numerically validate the discrete Poincaré lemma, which states that on a contractible domain, every closed form is exact. By constructing and analyzing discrete forms on meshes with and without holes, you will gain practical insight into how topological features, like the first Betti number, manifest as obstructions to finding a potential for a given field .",
            "id": "3372213",
            "problem": "You are asked to numerically validate a discrete version of the Poincaré lemma in the setting of Compatible and Mimetic Methods and Finite Element Exterior Calculus (FEEC) within Spectral and Discontinuous Galerkin (DG) methods. The foundational base you must use is the cochain model of the de Rham complex on a contractible mesh, in which the coboundary operators represent the discrete exterior derivative, arising from combinatorial topology and Stokes’ theorem. In particular, represent discrete $0$-forms as values at mesh vertices (nodes), discrete $1$-forms as values on oriented mesh edges, and discrete $2$-forms as values on oriented mesh cells. The discrete exterior derivative is modeled as an incidence matrix mapping node values to edge differences for the gradient, and as an incidence matrix mapping oriented edge circulations to oriented cell circulations for the curl, with the exactness property that the composition of consecutive incidence operators is the zero map.\n\nYour program must:\n- Construct a uniform Cartesian mesh on the unit square $[0,1]^2$ with $n_x$ intervals in the $x$-direction and $n_y$ intervals in the $y$-direction, define the following:\n  - The node set $\\mathcal{N}=\\{(i,j): i\\in\\{0,\\dots,n_x\\}, j\\in\\{0,\\dots,n_y\\}\\}$ with coordinates $(x_i,y_j)=(i/n_x,j/n_y)$.\n  - The oriented edge set $\\mathcal{E}$ consisting of all horizontal edges $((i,j)\\to(i+1,j))$ oriented in the positive $x$-direction and all vertical edges $((i,j)\\to(i,j+1))$ oriented in the positive $y$-direction.\n  - The oriented cell set $\\mathcal{C}$ consisting of all unit squares $(i,j)$ with counter-clockwise orientation. Optionally, a single cell $(i_0,j_0)$ may be removed to produce a simply connected domain with a single hole.\n- Build the two incidence matrices:\n  - The node-to-edge incidence matrix $A\\in\\mathbb{R}^{m\\times n}$ that represents the discrete gradient (coboundary operator) $d:\\Lambda^0_h\\to\\Lambda^1_h$, with one row per edge and one column per node, having entries $-1$ at the tail node and $+1$ at the head node of the edge, and zeros elsewhere.\n  - The edge-to-cell incidence matrix $B\\in\\mathbb{R}^{p\\times m}$ that represents the discrete curl $d:\\Lambda^1_h\\to\\Lambda^2_h$, with one row per oriented cell and four nonzero entries per cell at its boundary edges: $+1$ for the bottom and right edges (which align with the counter-clockwise boundary orientation), and $-1$ for the top and left edges (which are opposite to the counter-clockwise boundary orientation). If a cell is removed (a hole), that cell does not contribute a row in $B$.\n- Implement the following tasks, justified from the FEEC perspective:\n  1. If $\\omega\\in\\Lambda^1_h$ is a discrete $1$-form with $d\\omega=0$ (i.e., $B\\,\\omega=0$), then on a simply connected mesh (no holes), the discrete Poincaré lemma predicts that there exists a discrete potential $\\phi\\in\\Lambda^0_h$ such that $\\omega=d\\phi$ (i.e., $\\omega=A\\,\\phi$), up to an additive constant. Numerically demonstrate a reconstruction of $\\phi$ by solving the constrained least squares problem\n     $$\\min_{\\phi\\in\\mathbb{R}^n}\\|A\\,\\phi-\\omega\\|_2\\quad\\text{subject to}\\quad \\phi_{k}=0,$$\n     where $\\phi_k$ is fixed at one reference node to enforce uniqueness of the additive constant. Verify that the residual $\\|A\\,\\phi-\\omega\\|_2$ is small when $\\omega$ is closed on a simply connected domain.\n  2. For a mesh with one removed cell (a hole), construct a nontrivial closed discrete $1$-form $\\omega$ that is not exact by solving the minimum-norm problem\n     $$\\min_{\\omega\\in\\mathbb{R}^m}\\frac{1}{2}\\|\\omega\\|_2^2\\quad\\text{subject to}\\quad B\\,\\omega=0,\\quad C^\\top\\omega=1,$$\n     where $C\\in\\mathbb{R}^m$ encodes the oriented indicator of a non-contractible cycle around the hole (counter-clockwise). Show that the residual of the potential reconstruction problem does not vanish on this domain, i.e., $\\min_{\\phi}\\|A\\,\\phi-\\omega\\|_2>0$.\n  3. Construct closed and non-closed discrete $1$-forms on simply connected meshes via midpoint approximations of line integrals from smooth vector fields, using tangent vectors scaled by physical edge lengths to approximate edge integrals. Use a smooth potential $\\phi^\\star(x,y)$ to obtain a target curl-free field and a smooth field with nonzero curl to produce a non-closed example.\n\nFoundational definitions you must use:\n- The de Rham complex is discretized as the cochain complex $(\\Lambda^0_h, d)\\xrightarrow{d}(\\Lambda^1_h,d)\\xrightarrow{d}(\\Lambda^2_h,0)$ with $d\\circ d=0$ encoded by the combinatorial identity $B\\,A=0$.\n- Exactness on contractible domains states that $\\ker(B)=\\operatorname{im}(A)$; the first cohomology group is trivial.\n- The Discontinuous Galerkin (DG) viewpoint is realized by allowing discontinuities across elements and representing forms by cochains endowed with the combinatorial exterior derivative and incidence orientation; compatibility comes from preserving the topological structure $d\\circ d=0$.\n\nUse the following specific test suite. For each case, compute two floats:\n- The closedness defect $c=\\|B\\,\\omega\\|_2$.\n- The potential reconstruction residual ratio $r=\\|A\\,\\phi-\\omega\\|_2/\\|\\omega\\|_2$, where $\\phi$ is the least-squares solution with a fixed reference node set to zero (choose the node $(0,0)$).\nReport the results for all cases concatenated as a single list in the specified order.\n\nTest suite:\n- Case $1$ (simply connected, exactly closed from nodal potential differences): use $n_x=4$, $n_y=3$. Let $\\phi^\\star(x,y)=\\exp(x)\\sin(2\\pi y)$, define $\\phi$ at nodes by $\\phi_{i,j}=\\phi^\\star(i/n_x,j/n_y)$, and set $\\omega=A\\,\\phi$.\n- Case $2$ (simply connected, approximately closed from midpoint quadrature): use $n_x=7$, $n_y=5$. Let $\\phi^\\star(x,y)=\\exp(x)\\sin(2\\pi y)$ and define a vector field $\\mathbf{v}=\\nabla\\phi^\\star$. Approximate $\\omega$ on each edge by $\\mathbf{v}$ evaluated at the edge midpoint, dotted with the oriented tangent vector scaled by the edge length.\n- Case $3$ (simply connected, non-closed): use $n_x=7$, $n_y=5$. Let $\\mathbf{v}(x,y)=(-y,x)$, and approximate $\\omega$ on each edge by the midpoint rule as above.\n- Case $4$ (with a hole, closed but not exact): use $n_x=6$, $n_y=6$ and remove the cell $(i_0,j_0)=(3,3)$ (zero-based indexing). Construct the oriented cycle vector $C$ around the missing cell with counter-clockwise orientation. Compute $\\omega$ by solving the minimum-norm constrained problem\n  $$\\min_{\\omega}\\frac{1}{2}\\|\\omega\\|_2^2\\ \\text{s.t.}\\ B\\,\\omega=0,\\ C^\\top\\omega=1,$$\n  using first-order necessary conditions with Lagrange multipliers.\n\nAngle units are not involved. There are no physical units. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$$[c_1,r_1,c_2,r_2,c_3,r_3,c_4,r_4],$$\nwhere $c_k$ and $r_k$ are the closedness defect and reconstruction residual ratio for case $k$, respectively. Each item must be a float.",
            "solution": "The problem statement is a valid and well-posed exercise in computational algebraic topology, specifically within the framework of Finite Element Exterior Calculus (FEEC) and mimetic discretization methods. It is scientifically grounded, objective, and contains all necessary information to proceed.\n\n### Theoretical Foundation\n\nThe problem asks for a numerical validation of the discrete Poincaré lemma using a cochain model of the de Rham complex on a two-dimensional Cartesian mesh. This approach is central to compatible and mimetic discretizations, which aim to preserve fundamental structures of vector calculus and differential geometry at the discrete level.\n\nLet the computational domain $\\Omega = [0,1]^2$ be discretized into a cell complex consisting of nodes (0-cells), edges (1-cells), and rectangular cells (2-cells). We define spaces of discrete differential forms (cochains):\n- $\\Lambda^0_h$: The space of discrete $0$-forms, which are real values assigned to each of the $n$ nodes. A vector $\\phi \\in \\mathbb{R}^n$ represents a discrete $0$-form.\n- $\\Lambda^1_h$: The space of discrete $1$-forms, which are real values assigned to each of the $m$ oriented edges. A vector $\\omega \\in \\mathbb{R}^m$ represents a discrete $1$-form.\n- $\\Lambda^2_h$: The space of discrete $2$-forms, which are real values assigned to each of the $p$ oriented cells. A vector $\\tau \\in \\mathbb{R}^p$ represents a discrete $2$-form.\n\nThe exterior derivative $d$ is discretized by coboundary operators, which are represented by incidence matrices derived from the mesh topology.\n1.  The discrete gradient, $d_0: \\Lambda^0_h \\to \\Lambda^1_h$, maps a $0$-form (potential at nodes) to a $1$-form (potential differences on edges). It is represented by the node-to-edge incidence matrix $A \\in \\mathbb{R}^{m \\times n}$. For an edge $e$ connecting node $v_{tail}$ to $v_{head}$, the corresponding row of $A$ has an entry of $-1$ in the column for $v_{tail}$ and $+1$ in the column for $v_{head}$. If $\\omega = A\\phi$, then $\\omega_e = \\phi_{head} - \\phi_{tail}$.\n\n2.  The discrete curl, $d_1: \\Lambda^1_h \\to \\Lambda^2_h$, maps a $1$-form (circulation on edges) to a $2$-form (vorticity on cells). It is represented by the edge-to-cell incidence matrix $B \\in \\mathbb{R}^{p \\times m}$. For a cell $c$, the corresponding row of $B$ encodes the oriented sum of the $1$-form values on its boundary edges, $\\partial c$. This is a discrete version of Stokes' theorem. For a cell with counter-clockwise (CCW) orientation, an edge in its boundary receives a coefficient of $+1$ if its orientation aligns with the CCW traversal and $-1$ if it is opposite.\n\nA fundamental property of the de Rham complex is that the composition of two consecutive exterior derivatives is zero: $d \\circ d = 0$. In our discrete setting, this translates to the exact combinatorial identity $B A = 0$. This ensures that any exact form (a form that is the derivative of another form, i.e., $\\omega = A\\phi$) is also closed (its derivative is zero, i.e., $B\\omega = B(A\\phi) = (BA)\\phi = 0$).\n\nThe Poincaré lemma states that on a contractible domain, the converse is also true: every closed form is exact. For a simply connected mesh (no holes), the domain is contractible. The discrete analogue of the lemma implies that the first cohomology group is trivial, meaning $\\ker(B) = \\text{im}(A)$. That is, if a discrete $1$-form $\\omega$ is closed ($B\\omega=0$), there must exist a discrete $0$-form $\\phi$ such that $\\omega = A\\phi$.\n\n### Implementation Strategy\n\nThe implementation proceeds by first constructing the mesh entities (nodes, edges, cells) and their corresponding incidence matrices $A$ and $B$. Then, for each test case, the discrete $1$-form $\\omega$ is constructed according to the problem specification. Finally, we compute the required metrics: the closedness defect and the potential reconstruction residual.\n\n**Potential Reconstruction:**\nTo find the potential $\\phi$ for a given $1$-form $\\omega$, we aim to solve $A\\phi = \\omega$. The kernel of $A$ on a connected domain is one-dimensional, consisting of constant $0$-forms (i.e., $A\\phi=0$ if $\\phi$ is constant). To obtain a unique solution, we must fix the potential at one reference node. We choose the node at $(0,0)$ and set its potential to $0$, i.e., $\\phi_0 = 0$. The problem then becomes a constrained least-squares problem:\n$$ \\min_{\\phi \\in \\mathbb{R}^n} \\|A\\phi - \\omega\\|_2 \\quad \\text{subject to} \\quad \\phi_0=0 $$\nThis is solved by removing the first column of $A$ and the first entry of $\\phi$, solving the resulting unconstrained least-squares problem, and then re-inserting the zero value for $\\phi_0$. The residual norm $\\|A\\phi - \\omega\\|_2$ quantifies how close $\\omega$ is to being in the image of $A$ (i.e., being exact). The ratio $r = \\|A\\phi - \\omega\\|_2 / \\|\\omega\\|_2$ provides a normalized measure of this inexactness. The closedness defect $c = \\|B\\omega\\|_2$ measures how far $\\omega$ is from being in the kernel of $B$.\n\n### Case-by-Case Analysis\n\n**Case 1: Simply connected, exactly closed form**\n- We are given $n_x=4$, $n_y=3$. The domain is simply connected.\n- A discrete potential $\\phi$ is defined by sampling a smooth function $\\phi^\\star(x,y)=\\exp(x)\\sin(2\\pi y)$ at the mesh nodes.\n- The $1$-form is constructed as $\\omega = A\\phi$. By construction, $\\omega$ is in the image of $A$, so it is exact.\n- Since $BA=0$, it must also be closed, so we expect the closedness defect $c = \\|B\\omega\\|_2$ to be zero (or machine precision).\n- Since $\\omega$ is exactly in the image of $A$, the reconstruction of $\\phi$ should be perfect (up to the constant), and the reconstruction residual ratio $r$ should also be zero (or machine precision).\n\n**Case 2: Simply connected, approximately closed form**\n- We are given $n_x=7$, $n_y=5$. The domain is simply connected.\n- The $1$-form $\\omega$ is constructed by approximating line integrals of a conservative vector field $\\mathbf{v} = \\nabla\\phi^\\star$ using the midpoint rule on each edge. The integral over an edge $e$ is approximated as $\\omega_e \\approx \\mathbf{v}(\\mathbf{x}_{mid}) \\cdot \\mathbf{t}_e$, where $\\mathbf{x}_{mid}$ is the edge midpoint and $\\mathbf{t}_e$ is the oriented tangent vector (whose magnitude is the edge length).\n- Since the continuous vector field is curl-free, the discrete curl of $\\omega$ should be small, but non-zero due to the quadrature error. Thus, we expect a small closedness defect $c > 0$.\n- Because $\\omega$ is only an approximation of an exact form, it will not lie perfectly in $\\text{im}(A)$. We expect a small but non-zero reconstruction residual ratio $r > 0$.\n\n**Case 3: Simply connected, non-closed form**\n- We are given $n_x=7$, $n_y=5$. The domain is simply connected.\n- The $1$-form $\\omega$ is constructed as in Case $2$, but from a non-conservative vector field $\\mathbf{v}(x,y) = (-y, x)$, which has a constant curl of $2$.\n- The discrete curl $B\\omega$ approximates the continuous curl, so it should be significantly non-zero. We expect a large closedness defect $c > 0$.\n- A non-closed form cannot be exact. Therefore, we expect a large reconstruction residual ratio $r > 0$.\n\n**Case 4: Domain with a hole, closed but not exact form**\n- We are given $n_x=6$, $n_y=6$, and a hole is created by removing cell $(3,3)$. The domain is no longer contractible. Its first homology group is non-trivial, implying the existence of closed $1$-forms that are not exact.\n- We seek such a form $\\omega$ by solving a constrained optimization problem: $\\min \\frac{1}{2}\\|\\omega\\|_2^2$ subject to $B\\omega=0$ and $C^\\top\\omega=1$.\n- The constraint $B\\omega=0$ enforces that the form is closed. Note that the matrix $B$ for this domain is missing the row corresponding to the removed cell.\n- The constraint $C^\\top\\omega=1$ enforces that the line integral of $\\omega$ around a non-contractible cycle $C$ (the boundary of the hole) is $1$. This ensures that $\\omega$ cannot be exact, because if $\\omega = A\\phi$, the integral around any closed loop must be zero, by the discrete analogue of the fundamental theorem of calculus for line integrals.\n- This problem is solved using the method of Lagrange multipliers, leading to the KKT system:\n  $$ \\begin{pmatrix} I & B^\\top & C \\\\ B & 0 & 0 \\\\ C^\\top & 0 & 0 \\end{pmatrix} \\begin{pmatrix} \\omega \\\\ \\mu \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} $$\n  where $\\mu$ and $\\lambda$ are Lagrange multipliers. Solving this system yields the desired harmonic $1$-form $\\omega$.\n- By construction, $B\\omega=0$, so we expect $c \\approx 0$.\n- Because $C^\\top\\omega=1 \\neq 0$, $\\omega$ cannot be in $\\text{im}(A)$. Thus, we expect a significant non-zero reconstruction residual $r > 0$, demonstrating the failure of the Poincaré lemma on a non-contractible domain.",
            "answer": "```python\nimport numpy as np\n\ndef build_matrices_and_indices(nx, ny, hole=None):\n    \"\"\"\n    Builds the node, edge, cell index mappings and the incidence matrices A and B.\n    \"\"\"\n    # Dimensions\n    num_nodes = (nx + 1) * (ny + 1)\n    num_h_edges = nx * (ny + 1)\n    num_v_edges = (nx + 1) * ny\n    num_edges = num_h_edges + num_v_edges\n    num_cells = nx * ny\n\n    # Indexing helper functions\n    def node_idx(i, j): return j * (nx + 1) + i\n    def h_edge_idx(i, j): return j * nx + i\n    def v_edge_idx(i, j): return num_h_edges + j * (nx + 1) + i\n    def cell_idx(i, j): return j * nx + i\n\n    # Matrix A: node-to-edge incidence (discrete gradient)\n    A = np.zeros((num_edges, num_nodes))\n    for j in range(ny + 1):\n        for i in range(nx):\n            idx = h_edge_idx(i, j)\n            A[idx, node_idx(i, j)] = -1\n            A[idx, node_idx(i + 1, j)] = 1\n    for j in range(ny):\n        for i in range(nx + 1):\n            idx = v_edge_idx(i, j)\n            A[idx, node_idx(i, j)] = -1\n            A[idx, node_idx(i, j + 1)] = 1\n\n    # Matrix B: edge-to-cell incidence (discrete curl)\n    rows_B, cols_B, data_B = [], [], []\n    num_cells_with_hole = num_cells\n    hole_cell_index = -1\n    if hole:\n        hole_cell_index = cell_idx(hole[0], hole[1])\n        num_cells_with_hole -= 1\n\n    cell_row_counter = 0\n    for j in range(ny):\n        for i in range(nx):\n            current_cell_index = cell_idx(i, j)\n            if current_cell_index == hole_cell_index:\n                continue\n            \n            # Bottom edge: (i,j) -> (i+1,j) -> sign +1\n            rows_B.append(cell_row_counter); cols_B.append(h_edge_idx(i, j)); data_B.append(1)\n            # Right edge: (i+1,j) -> (i+1,j+1) -> sign +1\n            rows_B.append(cell_row_counter); cols_B.append(v_edge_idx(i + 1, j)); data_B.append(1)\n            # Top edge: (i,j+1) -> (i+1,j+1) -> sign -1\n            rows_B.append(cell_row_counter); cols_B.append(h_edge_idx(i, j + 1)); data_B.append(-1)\n            # Left edge: (i,j) -> (i,j+1) -> sign -1\n            rows_B.append(cell_row_counter); cols_B.append(v_edge_idx(i, j)); data_B.append(-1)\n            cell_row_counter += 1\n            \n    # Using a COO-like format and then building the matrix\n    B = np.zeros((num_cells_with_hole, num_edges))\n    for r, c, d in zip(rows_B, cols_B, data_B):\n        B[r, c] = d\n        \n    indices = {\n        'node': node_idx, 'h_edge': h_edge_idx, 'v_edge': v_edge_idx, 'cell': cell_idx,\n        'num_nodes': num_nodes, 'num_edges': num_edges, 'num_h_edges': num_h_edges\n    }\n    return A, B, indices\n\ndef calculate_metrics(A, B, omega):\n    \"\"\"\n    Computes closedness defect and potential reconstruction residual ratio.\n    \"\"\"\n    # Closedness defect\n    c = np.linalg.norm(B @ omega) if B.shape[0] > 0 else 0.0\n\n    # Potential reconstruction\n    ref_node_idx = 0  # Node (0,0) as reference\n    \n    # Handle case where omega is zero vector\n    omega_norm = np.linalg.norm(omega)\n    if omega_norm  1e-15:\n        return c, 0.0\n        \n    # Solve constrained least squares: min ||A*phi - omega||^2 s.t. phi[0]=0\n    A_constrained = np.delete(A, ref_node_idx, axis=1)\n    phi_constrained, _, _, _ = np.linalg.lstsq(A_constrained, omega, rcond=None)\n    \n    phi = np.insert(phi_constrained, ref_node_idx, 0)\n    \n    # Reconstruction residual ratio\n    residual_norm = np.linalg.norm(A @ phi - omega)\n    r = residual_norm / omega_norm\n\n    return c, r\n\ndef solve():\n    results = []\n\n    # Case 1: Simply connected, exactly closed from potential\n    nx, ny = 4, 3\n    A, B, idx = build_matrices_and_indices(nx, ny)\n    phi = np.zeros(idx['num_nodes'])\n    for j in range(ny + 1):\n        for i in range(nx + 1):\n            x, y = i / nx, j / ny\n            node_k = idx['node'](i, j)\n            phi[node_k] = np.exp(x) * np.sin(2 * np.pi * y)\n    omega1 = A @ phi\n    c1, r1 = calculate_metrics(A, B, omega1)\n    results.extend([c1, r1])\n\n    # Case 2: Simply connected, approximately closed from conservative field\n    nx, ny = 7, 5\n    A, B, idx = build_matrices_and_indices(nx, ny)\n    omega2 = np.zeros(idx['num_edges'])\n    dx, dy = 1/nx, 1/ny\n    def v_field_conservative(x, y):\n        ex = np.exp(x)\n        sin_2py, cos_2py = np.sin(2 * np.pi * y), np.cos(2 * np.pi * y)\n        return ex * sin_2py, 2 * np.pi * ex * cos_2py\n    # Horizontal edges\n    for j in range(ny + 1):\n        for i in range(nx):\n            mid_x, mid_y = (i + 0.5) / nx, j / ny\n            vx, _ = v_field_conservative(mid_x, mid_y)\n            omega2[idx['h_edge'](i, j)] = vx * dx\n    # Vertical edges\n    for j in range(ny):\n        for i in range(nx + 1):\n            mid_x, mid_y = i / nx, (j + 0.5) / ny\n            _, vy = v_field_conservative(mid_x, mid_y)\n            omega2[idx['v_edge'](i, j)] = vy * dy\n    c2, r2 = calculate_metrics(A, B, omega2)\n    results.extend([c2, r2])\n\n    # Case 3: Simply connected, non-closed field\n    nx, ny = 7, 5\n    A, B, idx = build_matrices_and_indices(nx, ny)\n    omega3 = np.zeros(idx['num_edges'])\n    dx, dy = 1/nx, 1/ny\n    def v_field_non_conservative(x, y): return -y, x\n    # Horizontal edges\n    for j in range(ny + 1):\n        for i in range(nx):\n            mid_x, mid_y = (i + 0.5) / nx, j / ny\n            vx, _ = v_field_non_conservative(mid_x, mid_y)\n            omega3[idx['h_edge'](i, j)] = vx * dx\n    # Vertical edges  \n    for j in range(ny):\n        for i in range(nx + 1):\n            mid_x, mid_y = i / nx, (j + 0.5) / ny\n            _, vy = v_field_non_conservative(mid_x, mid_y)\n            omega3[idx['v_edge'](i, j)] = vy * dy\n    c3, r3 = calculate_metrics(A, B, omega3)\n    results.extend([c3, r3])\n\n    # Case 4: Hole, closed but not exact form\n    nx, ny = 6, 6\n    hole_loc = (3, 3)\n    A, B, idx = build_matrices_and_indices(nx, ny, hole=hole_loc)\n    # Construct cycle vector C\n    C = np.zeros(idx['num_edges'])\n    i0, j0 = hole_loc\n    C[idx['h_edge'](i0, j0)] = 1      # Bottom\n    C[idx['v_edge'](i0 + 1, j0)] = 1  # Right\n    C[idx['h_edge'](i0, j0 + 1)] = -1 # Top\n    C[idx['v_edge'](i0, j0)] = -1    # Left\n    # Solve KKT system for mu, lambda\n    num_remaining_cells = B.shape[0]\n    KKT_size = num_remaining_cells + 1\n    KKT_mat = np.zeros((KKT_size, KKT_size))\n    \n    BBT = B @ B.T\n    BC = B @ C\n    CTC = C.T @ C\n    \n    KKT_mat[:num_remaining_cells, :num_remaining_cells] = BBT\n    KKT_mat[:num_remaining_cells, -1] = BC\n    KKT_mat[-1, :num_remaining_cells] = BC.T\n    KKT_mat[-1, -1] = CTC\n    \n    rhs = np.zeros(KKT_size)\n    rhs[-1] = 1.0\n    \n    sol = np.linalg.solve(KKT_mat, rhs)\n    mu = sol[:-1]\n    lambda_val = sol[-1]\n    \n    omega4 = B.T @ mu + C * lambda_val\n    c4, r4 = calculate_metrics(A, B, omega4)\n    results.extend([c4, r4])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The Hodge decomposition theorem is a cornerstone of vector calculus and FEEC, providing a canonical way to split a vector field into its fundamental components. In this exercise, you will implement the orthogonal projection of a discrete $1$-form into its exact (gradient), coexact (curl), and harmonic parts. This practice demonstrates how to turn the abstract theorem into a computational tool for analyzing discrete vector fields, a technique essential for solving partial differential equations in a stable, structure-preserving manner .",
            "id": "3372181",
            "problem": "Consider the discrete Hodge decomposition for a finite cell complex representing a two-dimensional square subdivided into two oriented triangles. Let the vertex set be $\\{v_0,v_1,v_2,v_3\\}$ with coordinates $(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$, and edges $\\{e_0,e_1,e_2,e_3,e_4\\}$ oriented as $e_0: v_0 \\to v_1$, $e_1: v_1 \\to v_2$, $e_2: v_2 \\to v_3$, $e_3: v_3 \\to v_0$, and $e_4: v_0 \\to v_2$. The face set consists of two oriented triangles $f_0: (v_0,v_1,v_2)$ and $f_1: (v_0,v_2,v_3)$, each oriented counterclockwise. The discrete gradient (coboundary) operators are given by the incidence matrices $D_0 \\in \\mathbb{R}^{5 \\times 4}$ (from vertices to edges) and $D_1 \\in \\mathbb{R}^{2 \\times 5}$ (from edges to faces), constructed from the oriented connectivity of edges and faces. Let the mass matrices $M_0 \\in \\mathbb{R}^{4 \\times 4}$, $M_1 \\in \\mathbb{R}^{5 \\times 5}$, and $M_2 \\in \\mathbb{R}^{2 \\times 2}$ be symmetric positive definite choices that approximate the $L^2$ inner product on $0$-, $1$-, and $2$-forms, respectively, by:\n- $M_2$ diagonal with face areas,\n- $M_1$ diagonal with edge lengths,\n- $M_0$ diagonal with vertex lumped areas, where each vertex receives one third of the area of each adjacent face.\n\nFinite Element Exterior Calculus (FEEC) defines the discrete differential $d_k$ via $D_k$, and the discrete codifferential $\\delta_k$ as the adjoint of $d_k$ with respect to the $M_k$ inner product. The Hodge decomposition of a discrete $k$-form $u \\in V_k$ seeks an orthogonal split $u = u_{\\mathrm{ex}} + u_{\\mathrm{coex}} + u_{\\mathrm{harm}}$, where $u_{\\mathrm{ex}}$ is exact ($u_{\\mathrm{ex}} \\in \\mathrm{im}(d_{k-1})$), $u_{\\mathrm{coex}}$ is coexact ($u_{\\mathrm{coex}} \\in \\mathrm{im}(\\delta_k)$), and $u_{\\mathrm{harm}}$ is harmonic (orthogonal to both exact and coexact components under the $M_k$ inner product). Your task is to:\n1. Construct $D_0$ and $D_1$ from the oriented mesh described above, and $M_0$, $M_1$, $M_2$ from geometric measures.\n2. Using only the fundamental definitions of orthogonal projection in an inner product space and adjoint operators, design and implement a method to compute the orthogonal projections of a given discrete $k$-form $u$ onto its exact, coexact, and harmonic components with respect to the inner product induced by $M_k$, for $k \\in \\{0,1,2\\}$.\n3. For the following test suite, compute the quantities specified:\n   - Test case 1 (happy path, exact): $k=1$, take $a \\in V_0$ with components $[0,1,2,1]$ on $(v_0,v_1,v_2,v_3)$, and set $u = d_0 a$. Output the $M_1$-norm of $u_{\\mathrm{harm}}$.\n   - Test case 2 (happy path, coexact): $k=1$, take $b \\in V_2$ with components $[1,-0.5]$ on $(f_0,f_1)$, and set $u = \\delta_1 b$. Output the $M_1$-norm of $u_{\\mathrm{harm}}$.\n   - Test case 3 (general case): $k=1$, take $u \\in V_1$ with components $[0.1,-0.3,0.2,0.5,-0.4]$ on $(e_0,e_1,e_2,e_3,e_4)$. Output the $M_1$-norm of $u_{\\mathrm{harm}}$.\n   - Test case 4 (boundary condition edge case for $k=0$): $k=0$, take $u \\in V_0$ with components $[0.3,-0.1,0.2,0.5]$ on $(v_0,v_1,v_2,v_3)$. Output the $M_1$-norm of $d_0 u_{\\mathrm{harm}}$.\n   - Test case 5 (top-degree form edge case for $k=2$): $k=2$, take $u \\in V_2$ with components $[0.7,-0.2]$ on $(f_0,f_1)$. Output the $M_2$-norm of $u_{\\mathrm{coex}}$.\n4. The $M_k$-norm of a discrete $k$-form $w \\in V_k$ must be computed as $\\|w\\|_{M_k} = \\sqrt{w^\\top M_k w}$.\n5. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the five test cases above. All outputs are real numbers (unitless floats).\n\nEnsure mathematical correctness by deriving the algorithm from first principles (orthogonal projection in inner product spaces and adjoint operators), and by using the provided mesh, orientations, and mass constructions. No external input is required, and all constants are to be as specified above. The final outputs are floats.",
            "solution": "We begin from the discrete de Rham complex on a finite cell complex, where spaces of discrete $k$-forms $V_k$ are associated to $k$-cells, and the coboundary operator $d_k: V_k \\to V_{k+1}$ is represented by the incidence matrix $D_k$. The inner product on $V_k$ is defined by a symmetric positive definite (SPD) mass matrix $M_k$, i.e., for $u,v \\in V_k$, $\\langle u,v \\rangle_{M_k} := u^\\top M_k v$. The discrete codifferential $\\delta_k: V_{k+1} \\to V_k$ is the adjoint of $d_k$ with respect to $\\langle \\cdot,\\cdot \\rangle_{M_k}$, i.e., it satisfies\n$$\n\\langle \\delta_k w, v \\rangle_{M_k} = \\langle w, d_k v \\rangle_{M_{k+1}} \\quad \\text{for all } v \\in V_k, \\, w \\in V_{k+1}.\n$$\nIn matrix form, this implies\n$$\n\\delta_k = M_k^{-1} D_k^\\top M_{k+1},\n$$\nsince\n$$\n(\\delta_k w)^\\top M_k v = w^\\top D_k v \\, M_{k+1} = w^\\top D_k^\\top M_{k+1} v \\quad \\Rightarrow \\quad \\delta_k = M_k^{-1} D_k^\\top M_{k+1}.\n$$\n\nThe Hodge decomposition of $u \\in V_k$ is defined as\n$$\nu = u_{\\mathrm{ex}} + u_{\\mathrm{coex}} + u_{\\mathrm{harm}},\n$$\nwhere $u_{\\mathrm{ex}} \\in \\mathrm{im}(d_{k-1})$, $u_{\\mathrm{coex}} \\in \\mathrm{im}(\\delta_k)$, and $u_{\\mathrm{harm}}$ is orthogonal to both $\\mathrm{im}(d_{k-1})$ and $\\mathrm{im}(\\delta_k)$ under $\\langle \\cdot,\\cdot \\rangle_{M_k}$. Orthogonal projections onto closed subspaces in a Hilbert space are characterized by minimization of the residual norm. Therefore, to compute $u_{\\mathrm{ex}}$ as the orthogonal projection of $u$ onto $\\mathrm{im}(d_{k-1})$, we seek $a \\in V_{k-1}$ minimizing\n$$\n\\|u - d_{k-1} a\\|_{M_k}^2 = (u - D_{k-1} a)^\\top M_k (u - D_{k-1} a).\n$$\nSetting the derivative with respect to $a$ to zero yields the normal equations\n$$\nD_{k-1}^\\top M_k D_{k-1} \\, a = D_{k-1}^\\top M_k u.\n$$\nThis linear system is symmetric positive semidefinite; its solutions define the orthogonal projector. Selecting the minimum-norm solution (via the Moore–Penrose pseudoinverse) gives $a$, and then\n$$\nu_{\\mathrm{ex}} = D_{k-1} a.\n$$\n\nSimilarly, to compute $u_{\\mathrm{coex}}$ as the orthogonal projection onto $\\mathrm{im}(\\delta_k)$, we seek $b \\in V_{k+1}$ minimizing\n$$\n\\|u - \\delta_k b\\|_{M_k}^2 = (u - \\delta_k b)^\\top M_k (u - \\delta_k b).\n$$\nThe stationarity condition is\n$$\n\\delta_k^\\top M_k (u - \\delta_k b) = 0 \\quad \\Rightarrow \\quad \\delta_k^\\top M_k \\delta_k \\, b = \\delta_k^\\top M_k u.\n$$\nUsing $\\delta_k = M_k^{-1} D_k^\\top M_{k+1}$ and its adjoint $\\delta_k^\\top = M_{k+1} D_k M_k^{-1}$ (since mass matrices are symmetric), we obtain the normal equations for $b$:\n$$\n(M_{k+1} D_k M_k^{-1} D_k^\\top M_{k+1}) \\, b = M_{k+1} D_k u.\n$$\nThis is again symmetric positive semidefinite. Choosing the minimal-norm solution by pre-multiplying with $M_{k+1}^{-1}$ and using the pseudoinverse yields $b$, and\n$$\nu_{\\mathrm{coex}} = \\delta_k b = M_k^{-1} D_k^\\top M_{k+1} b.\n$$\nThe harmonic component is then the residual\n$$\nu_{\\mathrm{harm}} = u - u_{\\mathrm{ex}} - u_{\\mathrm{coex}}.\n$$\nBy construction, $u_{\\mathrm{harm}}$ is orthogonal to both $\\mathrm{im}(d_{k-1})$ and $\\mathrm{im}(\\delta_k)$ with respect to $\\langle \\cdot,\\cdot \\rangle_{M_k}$, so it lies in the orthogonal complement of the sum of exact and coexact subspaces. On simply connected meshes with no boundary conditions imposed, the harmonic subspace dimension equals the corresponding Betti number of the cell complex; specifically for our mesh, the first Betti number is zero, so for $k=1$ we expect $u_{\\mathrm{harm}}$ to be (numerically) zero for arbitrary $u \\in V_1$. For $k=0$, constants form the harmonic subspace, characterized by $d_0 u_{\\mathrm{harm}} = 0$. For $k=2$ in two dimensions, $\\delta_2$ is trivial and the coexact subspace is $\\{0\\}$; exact components arise from $d_1$, and the harmonic component is the residual.\n\nWe now specify the mesh algebra:\n- Construct $D_0$ with entries $-1$ at the tail vertex and $+1$ at the head vertex for each oriented edge.\n- Construct $D_1$ with entries $+1$ if the edge orientation agrees with the induced face boundary orientation and $-1$ if opposite.\n- Compute $M_1$ as diagonal of edge lengths: for an edge with endpoints $(x_i,y_i)$ and $(x_j,y_j)$, the length is $\\sqrt{(x_j-x_i)^2+(y_j-y_i)^2}$.\n- Compute $M_2$ as diagonal of triangle areas: for oriented triangle $(p,q,r)$, the area is $\\frac{1}{2} |(q-p) \\times (r-p)|$.\n- Compute $M_0$ by lumping areas: for each triangle, add $\\frac{\\mathrm{area}}{3}$ to each of its vertices' diagonal entries.\n\nWith these, we compute $\\delta_k$ via $\\delta_k = M_k^{-1} D_k^\\top M_{k+1}$ and solve the normal equations using the Moore–Penrose pseudoinverse $A^+$ to handle semidefinite matrices:\n- For exact projection:\n$$\nA_{\\mathrm{ex}} = D_{k-1}^\\top M_k D_{k-1}, \\quad \\text{solve } a = A_{\\mathrm{ex}}^+ D_{k-1}^\\top M_k u, \\quad u_{\\mathrm{ex}} = D_{k-1} a.\n$$\n- For coexact projection:\n$$\nA_{\\mathrm{coex}} = D_k M_k^{-1} D_k^\\top M_{k+1}, \\quad \\text{solve } b = A_{\\mathrm{coex}}^+ D_k u, \\quad u_{\\mathrm{coex}} = M_k^{-1} D_k^\\top M_{k+1} b.\n$$\n- Harmonic residual:\n$$\nu_{\\mathrm{harm}} = u - u_{\\mathrm{ex}} - u_{\\mathrm{coex}}.\n$$\n\nFor the test suite:\n1. For $k=1$, $u = d_0 a$ with $a=[0,1,2,1]$, exactness implies $u_{\\mathrm{harm}}$ should be near zero; we report $\\|u_{\\mathrm{harm}}\\|_{M_1}$.\n2. For $k=1$, $u = \\delta_1 b$ with $b=[1,-0.5]$, coexactness implies $u_{\\mathrm{harm}}$ should be near zero; we report $\\|u_{\\mathrm{harm}}\\|_{M_1}$.\n3. For $k=1$, arbitrary $u=[0.1,-0.3,0.2,0.5,-0.4]$, simply connected topology implies $u_{\\mathrm{harm}}$ should be near zero; we report $\\|u_{\\mathrm{harm}}\\|_{M_1}$.\n4. For $k=0$, $u=[0.3,-0.1,0.2,0.5]$, the harmonic component should be approximately constant; we verify closedness by computing $\\|d_0 u_{\\mathrm{harm}}\\|_{M_1}$, which should be near zero.\n5. For $k=2$, $u=[0.7,-0.2]$, the coexact component vanishes because $\\delta_2$ is trivial in two dimensions with no $3$-cells; we report $\\|u_{\\mathrm{coex}}\\|_{M_2}$, which should be exactly zero.\n\nFinally, the program computes these five floats and prints them in a single line as a comma-separated list enclosed in square brackets.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_mesh():\n    # Vertex coordinates\n    V = np.array([\n        [0.0, 0.0],  # v0\n        [1.0, 0.0],  # v1\n        [1.0, 1.0],  # v2\n        [0.0, 1.0],  # v3\n    ])\n\n    # Oriented edges as (tail, head)\n    edges = [\n        (0, 1),  # e0\n        (1, 2),  # e1\n        (2, 3),  # e2\n        (3, 0),  # e3\n        (0, 2),  # e4 (diagonal)\n    ]\n\n    # Oriented faces: triangles with CCW orientation\n    faces = [\n        (0, 1, 2),  # f0\n        (0, 2, 3),  # f1\n    ]\n\n    # Incidence matrix D0: edges x vertices\n    nV = len(V)\n    nE = len(edges)\n    D0 = np.zeros((nE, nV))\n    for ei, (tail, head) in enumerate(edges):\n        D0[ei, tail] = -1.0\n        D0[ei, head] = +1.0\n\n    # Helper: map edge tuple to index for quick lookup\n    edge_to_index = {edges[i]: i for i in range(nE)}\n    # Also include reversed edges for sign handling\n    rev_edge_to_index = {(h, t): i for i, (t, h) in enumerate(edges)}\n\n    # Incidence matrix D1: faces x edges\n    nF = len(faces)\n    D1 = np.zeros((nF, nE))\n\n    def add_face_boundary(face_index, verts):\n        # verts is (a, b, c) oriented CCW.\n        # Boundary edges: a-b, b-c, c-a\n        boundary = [(verts[0], verts[1]), (verts[1], verts[2]), (verts[2], verts[0])]\n        for (t, h) in boundary:\n            sign = 0.0\n            if (t, h) in edge_to_index:\n                ei = edge_to_index[(t, h)]\n                sign = +1.0\n            elif (h, t) in edge_to_index:\n                ei = edge_to_index[(h, t)]\n                sign = -1.0\n            else:\n                # Should not happen in this mesh\n                raise RuntimeError(\"Boundary edge not found in edge list\")\n            D1[face_index, ei] = sign\n\n    for fi, tri in enumerate(faces):\n        add_face_boundary(fi, tri)\n\n    # Mass matrices\n    # M1: diagonal of edge lengths\n    M1 = np.zeros((nE, nE))\n    for i, (tail, head) in enumerate(edges):\n        p = V[tail]\n        q = V[head]\n        length = np.linalg.norm(q - p)\n        M1[i, i] = length\n\n    # M2: diagonal of triangle areas\n    M2 = np.zeros((nF, nF))\n    # Function to compute area of triangle (p, q, r)\n    def tri_area(p, q, r):\n        # area = 0.5 * |(q-p) x (r-p)|\n        return 0.5 * abs((q[0]-p[0])*(r[1]-p[1]) - (q[1]-p[1])*(r[0]-p[0]))\n\n    areas = []\n    for fi, (a, b, c) in enumerate(faces):\n        area = tri_area(V[a], V[b], V[c])\n        areas.append(area)\n        M2[fi, fi] = area\n\n    # M0: lumped areas at vertices (each triangle contributes area/3 to its vertices)\n    M0 = np.zeros((nV, nV))\n    for fi, (a, b, c) in enumerate(faces):\n        area = areas[fi]\n        M0[a, a] += area / 3.0\n        M0[b, b] += area / 3.0\n        M0[c, c] += area / 3.0\n\n    return D0, D1, M0, M1, M2\n\ndef pinv_solve(A, b):\n    # Solve A x = b in the minimum-norm sense using Moore-Penrose pseudoinverse.\n    # Stable for symmetric positive semidefinite matrices.\n    return np.linalg.pinv(A) @ b\n\ndef delta_k(Dk, Mk, Mk1):\n    # Compute discrete codifferential: delta_k = Mk^{-1} Dk^T Mk1\n    # Since Mk is diagonal, we can compute inverse efficiently.\n    Mk_inv = np.linalg.inv(Mk)\n    return Mk_inv @ Dk.T @ Mk1\n\ndef project_components(u, k, D_list, M_list):\n    # u in V_k; D_list = [D0, D1]; M_list = [M0, M1, M2]\n    Mk = M_list[k]\n    # Exact component\n    if k - 1 >= 0:\n        Dkm1 = D_list[k - 1]\n        A_ex = Dkm1.T @ Mk @ Dkm1\n        rhs_ex = Dkm1.T @ Mk @ u\n        a = pinv_solve(A_ex, rhs_ex)\n        u_ex = Dkm1 @ a\n    else:\n        u_ex = np.zeros_like(u)\n\n    # Coexact component\n    if k + 1 = 2:\n        Dk = D_list[k]\n        Mk_inv = np.linalg.inv(Mk)\n        Mk1 = M_list[k + 1]\n        \n        A_coex = Dk @ Mk_inv @ Dk.T @ Mk1\n        rhs_coex = Dk @ u\n        b = pinv_solve(A_coex, rhs_coex)\n        \n        u_coex = Mk_inv @ Dk.T @ Mk1 @ b\n    else:\n        u_coex = np.zeros_like(u)\n\n    # Harmonic residual\n    u_harm = u - u_ex - u_coex\n    return u_ex, u_coex, u_harm\n\ndef norm_M(u, M):\n    if u.size == 0:\n        return 0.0\n    val = u.T @ M @ u\n    # Handle potential small negative values from floating point error\n    return float(np.sqrt(max(0, val)))\n\ndef solve():\n    # Build mesh and operators\n    D0, D1, M0, M1, M2 = build_mesh()\n    D_list = [D0, D1]\n    M_list = [M0, M1, M2]\n\n    results = []\n\n    # Test case 1: k=1, u = d0 a with a=[0,1,2,1], output ||u_harm||_{M1}\n    a = np.array([0.0, 1.0, 2.0, 1.0])\n    u1_case1 = D0 @ a\n    u_ex, u_coex, u_harm = project_components(u1_case1, 1, D_list, M_list)\n    results.append(norm_M(u_harm, M1))\n\n    # Test case 2: k=1, u = delta1 b with b=[1,-0.5], output ||u_harm||_{M1}\n    b = np.array([1.0, -0.5])\n    delta1 = delta_k(D1, M1, M2)\n    u1_case2 = delta1 @ b\n    u_ex, u_coex, u_harm = project_components(u1_case2, 1, D_list, M_list)\n    results.append(norm_M(u_harm, M1))\n\n    # Test case 3: k=1, arbitrary u, output ||u_harm||_{M1}\n    u1_case3 = np.array([0.1, -0.3, 0.2, 0.5, -0.4])\n    u_ex, u_coex, u_harm = project_components(u1_case3, 1, D_list, M_list)\n    results.append(norm_M(u_harm, M1))\n\n    # Test case 4: k=0, arbitrary u, output ||d0 u_harm||_{M1}\n    u0_case4 = np.array([0.3, -0.1, 0.2, 0.5])\n    u_ex, u_coex, u_harm = project_components(u0_case4, 0, D_list, M_list)\n    d0_u_harm = D0 @ u_harm\n    results.append(norm_M(d0_u_harm, M1))\n\n    # Test case 5: k=2, arbitrary u, output ||u_coex||_{M2}\n    u2_case5 = np.array([0.7, -0.2])\n    u_ex, u_coex, u_harm = project_components(u2_case5, 2, D_list, M_list)\n    results.append(norm_M(u_coex, M2))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}