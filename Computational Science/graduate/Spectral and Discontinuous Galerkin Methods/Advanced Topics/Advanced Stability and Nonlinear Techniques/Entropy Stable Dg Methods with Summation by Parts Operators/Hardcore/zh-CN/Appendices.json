{
    "hands_on_practices": [
        {
            "introduction": "理论的理解始于具体的验证。本练习将引导你完成一个简单系统的分步计算，具体展示一个熵稳定数值格式如何在一个时间步内导致离散熵的减少。通过这个直接的计算，你将亲手验证熵稳定性的核心特性，并为理解更复杂的格式奠定坚实的基础。",
            "id": "3384653",
            "problem": "考虑线性标量守恒律 $u_{t} + a\\,u_{x} = 0$，其定义在一个周期性区域上。该区域被划分为两个长度为 $h$ 的均匀单元，未知量为分片常数（多项式次数 $p=0$）。使用分部求和 (SBP) 形式的间断伽辽金 (DG) 空间离散，其中质量矩阵为对角阵 $M = h I$，界面耦合通过耗散参数为 $\\alpha = |a|$ 的对称 Lax–Friedrichs (Rusanov) 通量实现。取严格凸二次熵 $U(u) = \\tfrac{1}{2} u^{2}$ 及其对应的离散熵 $S(u) = \\tfrac{1}{2} u^{\\top} M u$。假设采用周期性边界条件，并做出与 $\\alpha = |a|$ 一致的迎风偏置选择，已知这种选择对于二次熵能产生一个熵稳定的通量。\n\n设 $a = 1$ 且 $h = 1$。使用单元平均状态 $u_{1}^{n} = 1$ 和 $u_{2}^{n} = 0$ 进行初始化。使用三阶强稳定性保持龙格-库塔方法 (SSPRK(3)) 向前推进一个时间步：\n- $u^{(1)} = u^{n} + \\Delta t\\,L(u^{n})$,\n- $u^{(2)} = \\tfrac{3}{4} u^{n} + \\tfrac{1}{4}\\big(u^{(1)} + \\Delta t\\,L(u^{(1)})\\big)$,\n- $u^{n+1} = \\tfrac{1}{3} u^{n} + \\tfrac{2}{3}\\big(u^{(2)} + \\Delta t\\,L(u^{(2)})\\big)$,\n\n其中 $L(\\cdot)$ 表示使用熵稳定 Rusanov 通量的 SBP-DG 半离散算子。选择时间步长使得 Courant–Friedrichs–Lewy (CFL) 数 $\\lambda = a\\,\\Delta t/h$ 等于 $\\lambda = 1$。\n\n计算在这一个 SSPRK(3) 时间步内离散熵的变化量，\n$$\\Delta S \\equiv S(u^{n+1}) - S(u^{n}),$$\n并验证其为非正值。请给出 $\\Delta S$ 的精确值（无需四舍五入）。你的最终答案必须是一个没有单位的实数。",
            "solution": "从问题定义开始：偏微分方程、区域、离散化。\n半离散系统为 $M \\frac{d\\vec{u}}{dt} = \\vec{L}(\\vec{u})$。\n对于 $p=0$ 的 DG 方法，这是一个有限体积法：$h_k \\frac{du_k}{dt} + f^*_{k+1/2} - f^*_{k-1/2} = 0$。\n这里，$k \\in \\{1, 2\\}$，$h_k=h$。\n区域是周期性的。对于单元 1，界面是 $1+1/2$（右侧）和 $1-1/2$（左侧）。左边的邻居是单元 2，右边的邻居也是单元 2。\n右侧界面的状态：$u_L = u_1$，$u_R = u_2$。通量为 $f^*(u_1, u_2)$。\n左侧界面的状态：$u_L = u_2$，$u_R = u_1$。通量为 $f^*(u_2, u_1)$。\n$u_1$ 的方程：$h \\frac{du_1}{dt} + f^*(u_1, u_2) - f^*(u_2, u_1) = 0$。\n$u_2$ 的方程：$h \\frac{du_2}{dt} + f^*(u_2, u_1) - f^*(u_1, u_2) = 0$。\n这表明 $\\frac{d}{dt}(u_1+u_2)=0$。\n数值通量是 $f(u) = au$ 的 Rusanov 通量：$f^*(u_L, u_R) = \\frac{a u_L + a u_R}{2} - \\frac{\\alpha}{2}(u_R-u_L)$。\n给定 $\\alpha = |a|$ 和 $a=1$，该式变为 $f^*(u_L, u_R) = \\frac{u_L + u_R}{2} - \\frac{1}{2}(u_R-u_L) = u_L$。这就是迎风通量。\n因此，$f^*(u_1, u_2) = u_1$ 且 $f^*(u_2, u_1) = u_2$。\n常微分方程（ODE）系统为：\n$h \\frac{du_1}{dt} + u_1 - u_2 = 0 \\implies \\frac{du_1}{dt} = \\frac{1}{h}(u_2-u_1)$。\n$h \\frac{du_2}{dt} + u_2 - u_1 = 0 \\implies \\frac{du_2}{dt} = \\frac{1}{h}(u_1-u_2)$。\n写成向量形式为 $\\frac{d\\vec{u}}{dt} = L(\\vec{u})$，其中 $\\vec{u} = \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix}$ 且 $L(\\vec{u}) = \\frac{1}{h} \\begin{pmatrix} -1  1 \\\\ 1  -1 \\end{pmatrix} \\vec{u}$。\n质量矩阵为 $M=hI$。问题陈述半离散方程为 SBP 形式 $M \\frac{d\\vec{u}}{dt} = \\text{...}$。我的推导是 $\\frac{d\\vec{u}}{dt} = L(\\vec{u})$，此时相当于 $M=I$，这与问题陈述 $M=hI$ 且 $h=1$ 是一致的。我们需要小心。标准的 DG 形式是 $\\int \\phi_i u_t ... = 0$。当 $p=0$ 时，$\\phi=1$，这给出 $h \\frac{du_k}{dt} ... = 0$。所以我的推导是正确的。问题中的 $u^{n+1} = ... + \\Delta t L(...)$ 里的 $L(\\cdot)$ 必须是 $\\frac{d\\vec{u}}{dt} = L(\\vec{u})$ 的右端项。因此我得到的算子 $L(\\vec{u})$ 就是要使用的那个。\n\n给定参数 $a=1, h=1$。这得到 $L(\\vec{u}) = \\begin{pmatrix} -1  1 \\\\ 1  -1 \\end{pmatrix} \\vec{u}$。\nCFL 数 $\\lambda = a \\Delta t/h = 1 \\cdot \\Delta t/1 = 1$，所以 $\\Delta t=1$。\n初始状态：$\\vec{u}^n = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n\nSSPRK(3) 的步骤：\n1. $\\vec{u}^{(1)} = \\vec{u}^n + \\Delta t L(\\vec{u}^n)$。\n   $L(\\vec{u}^n) = \\begin{pmatrix} -1  1 \\\\ 1  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}$。\n   $\\vec{u}^{(1)} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + 1 \\cdot \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$。\n\n2. $\\vec{u}^{(2)} = \\frac{3}{4} \\vec{u}^n + \\frac{1}{4}(\\vec{u}^{(1)} + \\Delta t L(\\vec{u}^{(1)}))$。\n   $L(\\vec{u}^{(1)}) = \\begin{pmatrix} -1  1 \\\\ 1  -1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}$。\n   $\\vec{u}^{(2)} = \\frac{3}{4} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + \\frac{1}{4} \\left( \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} + 1 \\cdot \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix} \\right) = \\frac{3}{4} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + \\frac{1}{4} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n\n3. $\\vec{u}^{n+1} = \\frac{1}{3} \\vec{u}^n + \\frac{2}{3}(\\vec{u}^{(2)} + \\Delta t L(\\vec{u}^{(2)}))$。\n   $\\vec{u}^{(2)} = \\vec{u}^n$，所以 $L(\\vec{u}^{(2)}) = L(\\vec{u}^n) = \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}$。\n   $\\vec{u}^{n+1} = \\frac{1}{3} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + \\frac{2}{3} \\left( \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + 1 \\cdot \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} \\right) = \\frac{1}{3} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + \\frac{2}{3} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1/3 \\\\ 2/3 \\end{pmatrix}$。\n\n熵的计算：\n离散熵为 $S(\\vec{u}) = \\frac{1}{2}\\vec{u}^T M \\vec{u}$。\n当 $h=1$ 时，$M=I$，所以 $S(\\vec{u}) = \\frac{1}{2} \\vec{u}^T \\vec{u} = \\frac{1}{2} (u_1^2 + u_2^2)$。\n初始熵：$S(\\vec{u}^n) = \\frac{1}{2}(1^2 + 0^2) = \\frac{1}{2}$。\n最终熵：$S(\\vec{u}^{n+1}) = \\frac{1}{2} \\left( (\\frac{1}{3})^2 + (\\frac{2}{3})^2 \\right) = \\frac{1}{2} \\left( \\frac{1}{9} + \\frac{4}{9} \\right) = \\frac{1}{2} \\frac{5}{9} = \\frac{5}{18}$。\n熵的变化量：$\\Delta S = S(\\vec{u}^{n+1}) - S(\\vec{u}^n) = \\frac{5}{18} - \\frac{1}{2} = \\frac{5}{18} - \\frac{9}{18} = -\\frac{4}{18} = -\\frac{2}{9}$。\n结果 $\\Delta S = -2/9$ 是非正的，这与在适当的 CFL 条件下，将 SSPRK 格式应用于熵稳定的半离散化方案所得到的熵稳定性是一致的。\n\n所有检查都已完成。逻辑合理，计算已验证。我准备好写解答了。\n题目提到了 DG-SBP 形式。我应该简要地说明一下。对于 $p=0$ 的分片常数，微分算子为空。SBP 结构主要体现在边界/界面项中。半离散格式 $h_k \\frac{du_k}{dt} + f^*_{k+1/2} - f^*_{k-1/2} = 0$ 是一个标准的有限体积法，它是 $p=0$ 时 DG-SBP 公式的一个特例。界面项由给定的数值通量处理。我的方法与此描述一致。\n问题陈述本身有点像现代数值方法术语（DG、SBP、SSPRK、熵稳定性）的大杂烩，但实际问题归结为一个非常简单的 $2 \\times 2$ ODE 系统。这可能看起来有点“故作高深”，但它是这些概念的一个有效的、具体的实例，需要正确地应用定义。这是对理解能力的一个很好的检验。我判定它是有效的。\n\n最后确认所用的 SSPRK(3) 公式：\n- $u^{(1)} = u^{n} + \\Delta t\\,L(u^{n})$\n- $u^{(2)} = \\tfrac{3}{4} u^{n} + \\tfrac{1}{4}\\big(u^{(1)} + \\Delta t\\,L(u^{(1)})\\big)$\n- $u^{n+1} = \\tfrac{1}{3} u^{n} + \\tfrac{2}{3}\\big(u^{(2)} + \\Delta t\\,L(u^{(2)})\\big)$\n这是 Shu-Osher SSPRK(3,2) 的一个标准表示。但关键在于它可以写成一系列前向欧拉步的凸组合。问题中的形式就是这样一种表示。我将相信问题陈述中给出的公式。我的计算完全遵循了它，并得出了与理论一致的结果，所以它极有可能是正确的。这个问题是自洽的。我必须按其陈述来解决。\n计算看起来很稳健。没有理由怀疑它。",
            "answer": "$$\n\\boxed{-\\frac{2}{9}}\n$$"
        },
        {
            "introduction": "在验证了熵稳定性的“现象”之后，我们来探究其背后的“原理”。现代DG-SBP方法的一个关键创新是利用通量差分（flux differencing）来处理非线性项，从而避免由于混叠误差（aliasing error）导致的伪熵产生。这个练习将让你通过编程对比一个朴素的强形式离散和一个熵守恒的通量差分離散，直观地揭示后者如何在单元内部从根本上保证熵守恒。",
            "id": "3384682",
            "problem": "考虑参考区间 $[-1,1]$ 上带周期性边界条件的一维标量守恒律 $u_t + \\partial_x f(u) = 0$。令 $f(u)$ 表示物理通量。您将研究使用分部求和 (Summation-By-Parts, SBP) 算子的配置形式的间断 Galerkin 谱元法 (Discontinuous Galerkin Spectral Element Method, DGSEM)，并评估当使用两点熵守恒通量时，通量差分如何消除体积混叠。您将比较在高斯-勒让德-洛巴托 (Gauss-Legendre-Lobatto, GLL) 和高斯-勒让德 (Gauss-Legendre, Gauss) 求积法则下计算的离散熵收支。\n\n使用无粘性 Burgers 方程，其中 $f(u) = \\frac{1}{2}u^2$。为其配备标准凸熵 $U(u) = \\frac{1}{2}u^2$、熵变量 $v(u) = U'(u) = u$、熵通量 $F(u) = \\frac{1}{3}u^3$ 和通量势 $\\psi(u) = v(u) f(u) - F(u) = \\frac{1}{6}u^3$。对于通量差分，使用两点熵守恒通量\n$$\nf^{ec}(u_L,u_R) = \\frac{1}{6}\\left(u_L^2 + u_L u_R + u_R^2\\right).\n$$\n\n在 $[-1,1]$ 上的单个谱元上进行计算。对于选定的多项式次数 $N$，构造 $N+1$ 个高斯-勒让德-洛巴托节点和权重，或 $N+1$ 个高斯-勒让德节点和权重。使用以下方式构建 SBP 算子：\n- 对角质量矩阵 $M = \\operatorname{diag}(w_1,\\dots,w_{N+1})$，其中 $w_i$ 为求积权重，\n- 与所选节点上的拉格朗日插值相关联的节点微分矩阵 $D$，\n- SBP 算子 $Q = M D$。\n\n将在配置节点上采样的周期性初始条件定义为\n$$\nu(x) = a \\sin(\\pi x) + b \\cos(3\\pi x),\n$$\n其中 $a$ 和 $b$ 是实数参数。对于此 $u$，使用两种不同的公式评估熵收支的半离散体积贡献：\n\n1. 朴素强形式体积离散化：\n$$\n\\frac{d}{dt} \\sum_{i=1}^{N+1} w_i U(u_i) \\bigg|_{\\text{naive}} = - v^T Q f(u),\n$$\n其中 $u_i = u(x_i)$，$v_i = v(u_i)$，且 $f(u_i) = \\frac{1}{2}u_i^2$。\n\n2. 使用两点熵守恒通量的通量差分体积离散化：\n$$\n\\frac{d}{dt} \\sum_{i=1}^{N+1} w_i U(u_i) \\bigg|_{\\text{fd}} = -2 \\sum_{i=1}^{N+1}\\sum_{j=1}^{N+1} v_i \\, Q_{ij} \\, f^{ec}(u_i,u_j).\n$$\n\n在周期性边界条件下，对于体积项，熵守恒的通量差分公式在精确计算中应产生恒等于零的离散熵率，而朴素强形式由于在配置点上计算非线性通量所引入的混叠，可能会产生非零的离散熵产。您将数值评估两种公式中离散熵率的大小，并比较在 GLL 和 Gauss 求积法则下的行为。\n\n在一个完整且可运行的程序中实现以下步骤：\n- 为高斯-勒让德-洛巴托求积（含 $N+1$ 个点）和高斯-勒让德求积（含 $N+1$ 个点）构造节点和权重。\n- 通过给定节点的重心权重计算拉格朗日节点微分矩阵 $D$。\n- 构建 $M$ 和 $Q = M D$。\n- 对于每个测试用例，对 $u(x)$ 进行采样并计算：\n  - 在 GLL 下，朴素强形式离散熵率的绝对值 $| - v^T Q f(u) |$，\n  - 在 GLL 下，通量差分離散熵率的绝对值 $| -2 \\sum_{i,j} v_i Q_{ij} f^{ec}(u_i,u_j) |$，\n  - 在 Gauss 求积下计算的相同两个绝对值。\n\n设计一个测试套件，以探究多项式次数和非线性幅度的变化：\n- 测试用例 $1$（理想情况）：$N=5$, $a=1.0$, $b=0.1$。\n- 测试用例 $2$（低次边界情况）：$N=1$, $a=1.0$, $b=0.5$。\n- 测试用例 $3$（高次混叠压力）：$N=12$, $a=1.0$, $b=1.0$。\n- 测试用例 $4$（强非线性）：$N=8$, $a=2.5$, $b=2.0$。\n\n对于每个测试用例，您的程序必须返回一个包含四个浮点数的列表：\n- 在 GLL 下的 $| - v^T Q f(u) |$，\n- 在 GLL 下的 $| -2 \\sum_{i,j} v_i Q_{ij} f^{ec}(u_i,u_j) |$，\n- 在 Gauss 下的 $| - v^T Q f(u) |$，\n- 在 Gauss 下的 $| -2 \\sum_{i,j} v_i Q_{ij} f^{ec}(u_i,u_j) |$。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为由逗号分隔的这四个数字的列表，并用方括号括起来。也就是说，最终输出必须是\n$$\n\\texttt{[[r_{11},r_{12},r_{13},r_{14}],[r_{21},r_{22},r_{23},r_{24}],[r_{31},r_{32},r_{33},r_{34}],[r_{41},r_{42},r_{43},r_{44}]]}\n$$\n的形式，所有条目都以标准 Python 浮点字面量打印。此问题不涉及任何物理单位或角度单位；所有量均为无量纲。",
            "solution": "该问题经评估有效。它在科学上基于守恒律数值方法的理论，问题适定，具有唯一的可计算答案，并且表述客观。所有必要的数据和定义均已提供。\n\n目标是数值研究现代间断 Galerkin 谱元法 (DGSEM) 的一个关键特性：通量差分在实现熵稳定性中的作用。我们将一个标准的（或称“朴素的”）强形式离散化与一个熵守恒的通量差分公式进行比较。该比较针对一维无粘性 Burgers 方程 $u_t + \\partial_x (\\frac{1}{2}u^2) = 0$ 在具有周期性边界条件的单个单元上进行，同时使用高斯-勒让德-洛巴托 (GLL) 和高斯-勒让德 (Gauss) 求积点。\n\n### 1. 连续和离散熵守恒\n\n对于标量守恒律 $u_t + f(u)_x = 0$，凸熵函数 $U(u)$ 的变化率由熵不等式 $U(u)_t + F(u)_x \\le 0$ 控制，其中 $F(u)$ 是熵通量，定义为 $F'(u) = U'(u)f'(u)$。对于在半离散层面考虑的光滑解，这作为一个等式成立，$U(u)_t + F(u)_x = 0$。在区域 $[-1, 1]$ 上积分可得\n$$\n\\frac{d}{dt} \\int_{-1}^1 U(u) \\, dx = - \\int_{-1}^1 F(u)_x \\, dx = -[F(u(1)) - F(u(-1))]\n$$\n对于周期性边界条件，$u(-1) = u(1)$，这意味着 $F(u(-1)) = F(u(1))$，因此总熵是守恒的。\n\n如果一个数值格式满足此守恒性质的离散模拟，则称其为熵守恒的。我们将解近似为 $N$ 次多项式，并用其在一组 $N+1$ 个配置点 $x_i$ 上的值 $u_i$ 来表示。总离散熵为 $\\mathcal{U} = \\sum_{i=1}^{N+1} w_i U(u_i)$，其中 $w_i$ 是求积权重。\n\nDGSEM-SBP 公式使用离散微分算子 $D$ 和对角质量矩阵 $M = \\operatorname{diag}(w_i)$ 来构成一个分部求和 (SBP) 算子 $Q=MD$。这类算子的一个关键性质是 $Q+Q^T=B$，其中 $B$ 是一个边界矩阵，其非零项仅对应于区域端点。对于 GLL 节点，$B=\\operatorname{diag}(-1, 0, \\dots, 0, 1)$。对于任何 SBP 算子，我们还有 $D\\mathbf{1}=\\mathbf{0}$，这意味着 $Q\\mathbf{1}=\\mathbf{0}$。\n\n### 2. 朴素强形式离散化的分析\n\n强形式的半离散化为 $\\frac{d u_h}{dt} = -D f(u_h)$，其中 $u_h$ 是节点值的向量。总离散熵的变化率为：\n$$\n\\frac{d\\mathcal{U}}{dt} = \\frac{d}{dt} \\sum_i w_i U(u_i) = \\sum_i w_i U'(u_i) \\frac{du_i}{dt} = v^T M \\frac{du_h}{dt}\n$$\n其中 $v_i = U'(u_i)$ 是熵变量。对于带有 $U(u) = \\frac{1}{2}u^2$ 的 Burgers 方程，我们有 $v(u)=u$。代入半离散化，我们得到要评估的表达式：\n$$\n\\frac{d\\mathcal{U}}{dt} \\bigg|_{\\text{naive}} = v^T M (-D f(u_h)) = -v^T Q f(u_h)\n$$\n这个公式通常不是熵守恒的。乘积 $v^T Q f(u_h)$ 是积分 $\\int_{-1}^1 v(u) \\partial_x f(u) \\, dx$ 的离散近似。项 $f(u_h)$ 包含 $u_h$ 的非线性函数。如果 $u_h$ 由一个 $N$ 次多项式表示，那么 $f(u_h) = \\frac{1}{2}u_h^2$ 就是一个 $2N$ 次多项式。整个表达式涉及项的乘积，其多项式次数可能超过基础求积法则（$GLL$ 或 $Gauss$）能够精确计算的次数。这种离散积分中的不精确性，称为混叠，导致非零的熵产生率，从而违反了守恒原理。\n\n### 3. 通量差分离散化的分析\n\n通量差分方法重新构建空间算子以内置守恒属性。总离散熵的变化率由下式给出：\n$$\n\\frac{d\\mathcal{U}}{dt} \\bigg|_{\\text{fd}} = -2 \\sum_{i=1}^{N+1}\\sum_{j=1}^{N+1} v_i \\, Q_{ij} \\, f^{ec}(u_i,u_j)\n$$\n其中 $f^{ec}(u_L, u_R)$ 是一个两点熵守恒通量。它是对称的，$f^{ec}(u_L, u_R) = f^{ec}(u_R, u_L)$，并且是一致的，$f^{ec}(u,u) = f(u)$。最重要的是，它满足关系 $(v(u_L) - v(u_R))f^{ec}(u_L, u_R) = \\psi(u_L) - \\psi(u_R)$，其中 $\\psi(u)$ 是熵通量势。\n\n为了证明这个公式是守恒的，我们操作这个双重求和。我们使用恒等式 $2v_i = (v_i+v_j) + (v_i-v_j)$。\n$$\n\\begin{aligned}\n\\sum_{i,j} v_i Q_{ij} f^{ec}(u_i, u_j) = \\frac{1}{2} \\sum_{i,j} \\left( v_i Q_{ij} f^{ec}(u_i, u_j) + v_j Q_{ji} f^{ec}(u_j, u_i) \\right) \\quad (\\text{通过交换索引 } i,j) \\\\\n= \\frac{1}{2} \\sum_{i,j} \\left( v_i Q_{ij} + v_j Q_{ji} \\right) f^{ec}(u_i, u_j) \\quad (\\text{根据 } f^{ec} \\text{ 的对称性})\n\\end{aligned}\n$$\n对体积使用适用于周期性问题的斜对称形式的 SBP 性质，$Q_{ji} \\approx -Q_{ij}$，该项变为：\n$$\n\\frac{1}{2} \\sum_{i,j} (v_i-v_j) Q_{ij} f^{ec}(u_i,u_j) = \\frac{1}{2} \\sum_{i,j} Q_{ij} (v_i-v_j) f^{ec}(u_i,u_j)\n$$\n使用 EC 通量的性质，$(v_i-v_j)f^{ec}(u_i,u_j) = \\psi_i - \\psi_j$：\n$$\n= \\frac{1}{2} \\sum_{i,j} Q_{ij} (\\psi_i - \\psi_j) = \\frac{1}{2} \\left( \\sum_{i,j} Q_{ij}\\psi_i - \\sum_{i,j} Q_{ij}\\psi_j \\right)\n$$\n第一个和是 $\\sum_i \\psi_i \\left( \\sum_j Q_{ij} \\right)$。因为 $Q\\mathbf{1}=\\mathbf{0}$，所以行和 $\\sum_j Q_{ij}$ 为零。此项消失。第二个和是 $\\sum_j \\psi_j \\left( \\sum_i Q_{ij} \\right)$。这是 $\\sum_j \\psi_j (\\mathbf{1}^T Q)_j = \\psi^T (Q^T\\mathbf{1})$。从 $Q+Q^T=B$ 和 $Q\\mathbf{1}=0$，我们有 $Q^T\\mathbf{1}=(B-Q)\\mathbf{1}=B\\mathbf{1}-Q\\mathbf{1}=B\\mathbf{1}$。\n因此，该和的计算结果为：\n$$\n\\frac{d\\mathcal{U}}{dt} \\bigg|_{\\text{fd}} = -2 \\left( -\\frac{1}{2} \\psi^T B \\mathbf{1} \\right) = \\psi^T B \\mathbf{1}\n$$\n对于 GLL 节点，$B\\mathbf{1}$ 是向量 $[ -1, 0, \\dots, 0, 1 ]^T$。这得到 $\\psi^T B \\mathbf{1} = \\psi_{N+1} - \\psi_1$。对于基于 Gauss 的 SBP 算子，也存在类似的结果，其中边界算子 $B$ 提取单元边界处的值。对于周期性边界条件，$u(-1)=u(1)$，这意味着 $u_1=u_{N+1}$，因此 $\\psi_1 = \\psi_{N+1}$。边界项抵消，熵率恒等于零。这对于 GLL 和基于 Gauss 的 SBP 算子都成立，与多项式次数无关。\n\n### 4. 实现与预期结果\n\n实现部分计算给定测试用例的这两种率。\n- **朴素率**：由于混叠，预期为非零，这表明未能守恒熵。此误差的大小对于 Gauss 求积可能小于 GLL，因为 Gauss 法则对更高次的多项式是精确的。\n- **通量差分率**：对于所有情况，预期为零（或在机器精度范围内），这证明了熵守恒公式的成功。\n\n代码将为每个测试用例执行以下操作：\n1.  为给定次数 $N$ 的 GLL 和 Gauss 求积生成节点 ($x_i$) 和权重 ($w_i$)。\n2.  为这些节点构造重心微分矩阵 $D$。\n3.  构建质量矩阵 $M=\\operatorname{diag}(w_i)$ 和 SBP 算子 $Q=MD$。\n4.  在节点上对初始条件 $u(x) = a \\sin(\\pi x) + b \\cos(3\\pi x)$ 进行采样。\n5.  计算朴素熵率，$|-v^T Q f(u)|$。\n6.  计算通量差分熵率，$|-2 \\sum_{i,j} v_i Q_{ij} f^{ec}(u_i,u_j)|$。\n7.  为每个测试用例返回这四个值（两个用于 GLL，两个用于 Gauss）。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi, legendre\n\ndef gll_nodes_weights(N):\n    \"\"\"\n    Computes N+1 Gauss-Legendre-Lobatto nodes and weights for polynomials of degree N.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0]), np.array([2.0])\n    \n    # Interior nodes are roots of P_N'(x), which are roots of Jacobi poly P_{N-1}^{(1,1)}(x)\n    if N > 1:\n        interior_nodes = roots_jacobi(N - 1, 1, 1)[0]\n    else: # N=1\n        interior_nodes = np.array([])\n        \n    nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n    \n    # Weights\n    PN_func = legendre(N)\n    weights = 2.0 / (N * (N + 1) * PN_func(nodes)**2)\n    \n    return nodes, weights\n\ndef gauss_nodes_weights(N):\n    \"\"\"\n    Computes N+1 Gauss-Legendre nodes and weights.\n    \"\"\"\n    # This rule is exact for polynomials of degree 2*(N+1)-1 = 2N+1\n    nodes, weights = np.polynomial.legendre.leggauss(N + 1)\n    return nodes, weights\n\ndef barycentric_diff_matrix(nodes):\n    \"\"\"\n    Computes the differentiation matrix for a given set of nodes using barycentric weights.\n    \"\"\"\n    n_points = len(nodes)\n    bary_weights = np.ones(n_points)\n    for j in range(n_points):\n        for k in range(n_points):\n            if k != j:\n                bary_weights[j] /= (nodes[j] - nodes[k])\n\n    D = np.zeros((n_points, n_points))\n    for i in range(n_points):\n        sum_row = 0.0\n        for j in range(n_points):\n            if i != j:\n                D[i, j] = (bary_weights[j] / bary_weights[i]) / (nodes[i] - nodes[j])\n                sum_row += D[i, j]\n        D[i, i] = -sum_row\n    return D\n\ndef calculate_entropy_rates(N, a, b, quadrature_type):\n    \"\"\"\n    Calculates the two discrete entropy rates for a given quadrature type.\n    \"\"\"\n    if quadrature_type == 'GLL':\n        nodes, weights = gll_nodes_weights(N)\n    elif quadrature_type == 'Gauss':\n        nodes, weights = gauss_nodes_weights(N)\n    else:\n        raise ValueError(\"Unknown quadrature type\")\n\n    # Construct SBP operators\n    D = barycentric_diff_matrix(nodes)\n    M = np.diag(weights)\n    Q = M @ D\n\n    # Sample the initial condition and define related quantities\n    u = a * np.sin(np.pi * nodes) + b * np.cos(3 * np.pi * nodes)\n    v = u  # Entropy variable for U(u) = u^2/2\n    f_u_vec = 0.5 * u**2  # Flux vector\n\n    # 1. Naive strong-form entropy rate\n    # rate = -v^T * Q * f(u)\n    rate_naive = -np.dot(v, Q @ f_u_vec)\n\n    # 2. Flux-differencing entropy rate\n    # rate = -2 * sum_{i,j} v_i * Q_ij * f^ec(u_i, u_j)\n    ui_col = u[:, np.newaxis]\n    uj_row = u[np.newaxis, :]\n    f_ec_matrix = (ui_col**2 + ui_col * uj_row + uj_row**2) / 6.0\n    \n    term_to_sum = v[:, np.newaxis] * Q * f_ec_matrix\n    rate_fd = -2.0 * np.sum(term_to_sum)\n    \n    return [np.abs(rate_naive), np.abs(rate_fd)]\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (5, 1.0, 0.1),\n        (1, 1.0, 0.5),\n        (12, 1.0, 1.0),\n        (8, 2.5, 2.0)\n    ]\n\n    results = []\n    for N, a, b in test_cases:\n        case_result = []\n        # GLL Quadrature\n        res_gll = calculate_entropy_rates(N, a, b, 'GLL')\n        case_result.extend(res_gll)\n        # Gauss Quadrature\n        res_gauss = calculate_entropy_rates(N, a, b, 'Gauss')\n        case_result.extend(res_gauss)\n        \n        results.append(case_result)\n\n    # Format the output string to match the required format\n    # e.g., [[r11,r12,r13,r14],[r21,r22,r23,r24],...]\n    formatted_results = []\n    for res_list in results:\n        formatted_results.append(f\"[{','.join(map(str, res_list))}]\")\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "真实的科学计算问题往往需要处理复杂的几何和非均匀的网格剖分，这给保持数值稳定性带来了挑战。本练习将我们从单个单元的内部机制带入到单元之间的耦合问题，特别是当界面不协调（nonconforming）时。你将学习并实现一种先进的“砂浆法”（mortar method），并验证专门设计的$M$-正交投影算子对于跨分辨率界面传递信息并维持整体熵稳定性是何等重要。",
            "id": "3384666",
            "problem": "构建一个自洽的数值实验，用于评估标量守恒律在非协调界面上使用带有对角质量矩阵和质量正交（记为 $M$-正交）SBP 投影算子的分部求和（SBP）算子时，砂浆耦合的熵稳定性。考虑一维标量 Burgers 方程 $u_t + \\partial_x f(u) = 0$，其通量为 $f(u) = \\frac{1}{2}u^2$，熵对为 $(U(u), F(u)) = \\left(\\frac{1}{2}u^2, \\frac{1}{3}u^3\\right)$。熵变量为 $v(u) = \\frac{\\partial U}{\\partial u} = u$，熵势为 $\\psi(u) = v(u) f(u) - F(u) = \\frac{1}{6}u^3$。\n\n给定一个由两个谱/间断 Galerkin 单元（左侧和右侧）共享的非协调界面，这些单元的边界面求积基于 Gauss–Legendre 节点和权重。左侧单元的边界面求积使用 $N_L$ 个点，节点为 $x_L$，对角质量矩阵为 $M_L = \\mathrm{diag}(w_L)$；右侧单元的边界面求积使用 $N_R$ 个点，节点为 $x_R$，对角质量矩阵为 $M_R = \\mathrm{diag}(w_R)$。引入一个具有 $N_m$ 个 Gauss–Legendre 点的砂浆界面，其节点为 $x_m$，对角质量矩阵为 $M_m = \\mathrm{diag}(w_m)$。\n\n定义以下离散算子：\n- 从一组源节点 $x_{\\mathrm{src}}$ 到目标节点 $x_{\\mathrm{tgt}}$ 的插值矩阵，定义为节点 Lagrange 插值矩阵 $I_{\\mathrm{src}\\to\\mathrm{tgt}}$，它将源节点 $x_{\\mathrm{src}}$ 上的节点值向量映射到目标节点 $x_{\\mathrm{tgt}}$ 上的节点值。\n- 从单元面到砂浆的 $M$-正交投影定义为\n$$\nP_{L\\to m} = M_m^{-1} I_{m\\to L}^T M_L, \\qquad P_{R\\to m} = M_m^{-1} I_{m\\to R}^T M_R,\n$$\n其中 $I_{m\\to L}$ 和 $I_{m\\to R}$ 分别是从砂浆到左侧面节点和从砂浆到右侧面节点的插值矩阵。砂浆通量通过 $I_{m\\to L}$ 和 $I_{m\\to R}$ 反向传递到单元面。\n\n在砂浆上，定义两种数值通量：\n- 一种熵守恒通量 $f^{\\mathrm{ec}}(u_L, u_R)$，满足 Burgers 方程的 Tadmor 条件，逐点构造为\n$$\nf^{\\mathrm{ec}}(u_L, u_R) = \\frac{1}{6}\\left(u_L^2 + u_L u_R + u_R^2\\right).\n$$\n- 一种带有界面耗散的熵稳定通量\n$$\nf^{\\mathrm{es}}(u_L, u_R) = f^{\\mathrm{ec}}(u_L, u_R) - \\frac{\\alpha}{2}\\left(v_R - v_L\\right),\n$$\n其中 $v = u$，耗散参数 $\\alpha > 0$。\n\n对于在砂浆上根据迹 $u_{L,m}$ 和 $u_{R,m}$ 计算的给定通量 $f^\\star \\in \\{f^{\\mathrm{ec}}, f^{\\mathrm{es}}\\}$，将熵率的离散内部界面贡献定义为\n$$\n\\mathcal{J} = \\left(v_L\\right)^T M_L I_{m\\to L} f^\\star - \\left(\\psi(u_L)\\right)^T \\mathbf{1}_L - \\left[\\left(v_R\\right)^T M_R I_{m\\to R} f^\\star - \\left(\\psi(u_R)\\right)^T \\mathbf{1}_R\\right],\n$$\n其中 $v_L = u_L$，$v_R = u_R$，且 $\\mathbf{1}_L$ 和 $\\mathbf{1}_R$ 分别表示大小为 $N_L$ 和 $N_R$ 的全一向量。该表达式模拟了与内部界面相关的净半离散熵产生，是一个代数量，其符号应能反映熵的稳定性。\n\n您必须比较计算砂浆迹 $(u_{L,m}, u_{R,m})$ 的两种策略：\n- 策略 A（$M$-正交）：$u_{L,m} = P_{L\\to m} u_L$ 和 $u_{R,m} = P_{R\\to m} u_R$。\n- 策略 B（朴素插值）：$u_{L,m} = I_{L\\to m} u_L$ 和 $u_{R,m} = I_{R\\to m} u_R$。\n\n对每种策略和每种通量，量化以下指标：\n- 熵传递误差 $\\mathrm{E}_{\\mathrm{transfer}} = \\left|\\mathcal{J}\\right|$，针对 $f^\\star = f^{\\mathrm{ec}}$。如果耦合在界面上正确传递熵，该误差应接近于零。\n- 界面耗散误差，针对 $f^\\star = f^{\\mathrm{es}}$，定义为\n$$\n\\mathrm{E}_{\\mathrm{diss}} = \\left|\\mathcal{J} - \\mathcal{J}_{\\mathrm{theory}}\\right|,\n$$\n其中理论耗散为\n$$\n\\mathcal{J}_{\\mathrm{theory}} = -\\frac{1}{2}\\left(v_{R,m} - v_{L,m}\\right)^T M_m \\left(\\alpha I\\right) \\left(v_{R,m} - v_{L,m}\\right),\n$$\n其中 $v_{L,m} = u_{L,m}$ 和 $v_{R,m} = u_{R,m}$，$I$ 是大小为 $N_m$ 的单位矩阵。\n\n实现一个程序，完成以下操作：\n- 在 $[-1,1]$ 上为 $N_L$、$N_R$ 和 $N_m$ 构造 Gauss–Legendre 节点和权重，并形成 $M_L$、$M_R$、$M_m$。\n- 使用节点 Lagrange 插值法构造所有需要的插值矩阵 $I_{L\\to m}$、$I_{R\\to m}$、$I_{m\\to L}$、$I_{m\\to R}$。\n- 构造 $M$-正交投影算子 $P_{L\\to m}$ 和 $P_{R\\to m}$。\n- 对于每个测试用例，在其各自的面节点上评估节点状态 $u_L$ 和 $u_R$，为策略 A 和策略 B 构建砂浆迹，在砂浆上评估 $f^{\\mathrm{ec}}$ 和 $f^{\\mathrm{es}}$，并计算如上定义的 $\\mathcal{J}$、$\\mathrm{E}_{\\mathrm{transfer}}$ 和 $\\mathrm{E}_{\\mathrm{diss}}$。\n\n使用以下固定参数和测试套件：\n- 使用 $N_L = 3$，$N_R = 2$，$N_m = 4$。\n- 使用耗散参数 $\\alpha = 1.3$。\n- 通过指定界面参数 $s \\in [-1,1]$ 的函数来定义三个测试用例：\n    - 用例 1（一般光滑失配）：$u_L(s) = \\frac{1}{2} + s$，$u_R(s) = -\\frac{1}{5} + \\frac{3}{10}s^2$。\n    - 用例 2（迹匹配，零跳跃）：$u_L(s) = \\frac{1}{3} - \\frac{1}{4}s + \\frac{1}{5}s^2$，$u_R(s) = u_L(s)$。\n    - 用例 3（强常数跳跃）：$u_L(s) = 1$，$u_R(s) = -1$。\n\n您的程序应针对每个用例，按此确切顺序生成一个包含四个浮点数结果的列表：\n- 使用 $f^{\\mathrm{ec}}$ 的策略 A（$M$-正交）的 $\\mathrm{E}_{\\mathrm{transfer}}$。\n- 使用 $f^{\\mathrm{ec}}$ 的策略 B（朴素）的 $\\mathrm{E}_{\\mathrm{transfer}}$。\n- 使用 $f^{\\mathrm{es}}$ 的策略 A（$M$-正交）的 $\\mathrm{E}_{\\mathrm{diss}}$。\n- 使用 $f^{\\mathrm{es}}$ 的策略 B（朴素）的 $\\mathrm{E}_{\\mathrm{diss}}$。\n\n将三个测试用例的所有结果汇总到单行输出中，格式为方括号内以逗号分隔的列表，例如 $[\\mathrm{r}_1,\\mathrm{r}_2,\\ldots,\\mathrm{r}_{12}]$。不应打印任何额外文本。\n\n所有数学量均为无量纲，因此不需要物理单位。不涉及角度。要求的最终输出是浮点数。通过使用给定的精确数学定义，并完全按照规定构造插值和投影算子（无快捷方式或外部文件），确保科学真实性。程序必须是完全确定性的，并且不需要任何输入。",
            "solution": "本问题的目标是进行一个数值实验，以评估一维标量 Burgers 方程 $u_t + \\partial_x f(u) = 0$（其中通量为 $f(u) = \\frac{1}{2}u^2$）的砂浆耦合的熵稳定性特性。分析重点在于两个单元之间的非协调界面。我们将比较两种将解数据投影到砂浆空间上的不同策略：一种是朴素的 Lagrange 插值，另一种是考虑了质量矩阵的（$M$-正交）投影。评估是通过量化每种策略在界面上保持离散熵守恒和耗散特性的优劣程度来进行的。\n\n首先，我们建立数学和数值框架。问题设定在两个一维单元（称为左侧 L 和右侧 R）之间的界面上。界面物理通过第三个空间——砂浆（m）——进行调节。这三个域中的每一个都使用一组 Gauss-Legendre 求积点进行离散化。\n\n左侧单元面使用 $N_L = 3$ 个点，节点为 $x_L$，权重为 $w_L$。\n右侧单元面使用 $N_R = 2$ 个点，节点为 $x_R$，权重为 $w_R$。\n砂浆空间使用 $N_m = 4$ 个点，节点为 $x_m$，权重为 $w_m$。\n\n对于每组点，我们定义一个对角质量矩阵 $M = \\mathrm{diag}(w)$，其中 $w$ 是求积权重的向量。因此，我们有 $M_L$、$M_R$ 和 $M_m$。所有节点和权重都在规范区间 $[-1, 1]$上定义。\n\n一个关键组成部分是在这些不同节点集之间传递信息。这是通过 Lagrange 插值矩阵实现的。矩阵 $I_{\\mathrm{src}\\to\\mathrm{tgt}}$ 将一个由源网格 $x_{\\mathrm{src}}$ 上的节点值表示的函数插值到目标网格 $x_{\\mathrm{tgt}}$ 上。矩阵的第 $(k, j)$ 个元素是源网格的第 $j$ 个 Lagrange 基多项式在目标网格的第 $k$ 个节点上的值。我们需要构造四个这样的矩阵：$I_{L\\to m}$、$I_{R\\to m}$、$I_{m\\to L}$ 和 $I_{m\\to R}$。\n\n问题指定了两种策略，用于根据单元面解 $u_L$ 和 $u_R$ 计算砂浆网格上的解的迹 $u_{L,m}$ 和 $u_{R,m}$。\n策略 B，即朴素方法，使用直接插值：\n$$\nu_{L,m} = I_{L\\to m} u_L, \\qquad u_{R,m} = I_{R\\to m} u_R\n$$\n策略 A 采用更复杂的 $M$-正交投影，其定义旨在尊重底层离散（求积）内积的性质。投影算子为：\n$$\nP_{L\\to m} = M_m^{-1} I_{m\\to L}^T M_L, \\qquad P_{R\\to m} = M_m^{-1} I_{m\\to R}^T M_R\n$$\n使用这些算子，策略 A 的砂浆迹为：\n$$\nu_{L,m} = P_{L\\to m} u_L, \\qquad u_{R,m} = P_{R\\to m} u_R\n$$\n这些投影旨在满足分部求和（SBP）或“对偶一致性”属性 $M_m P_{\\alpha \\to m} = I_{m \\to \\alpha}^T M_\\alpha$（对于 $\\alpha \\in \\{L, R\\}$），这对于证明离散稳定性至关重要。\n\n该分析取决于对 Burgers 方程的熵分析。所选的熵对是 $(U(u), F(u)) = (\\frac{1}{2}u^2, \\frac{1}{3}u^3)$。相应的熵变量是 $v(u) = \\frac{\\partial U}{\\partial u} = u$，熵势是 $\\psi(u) = v(u)f(u) - F(u) = \\frac{1}{6}u^3$。\n\n在砂浆上，我们使用根据砂浆迹 $u_{L,m}$ 和 $u_{R,m}$ 计算的两种数值通量：\n1.  一种熵守恒（EC）通量：$f^{\\mathrm{ec}}(u_L, u_R) = \\frac{1}{6}(u_L^2 + u_L u_R + u_R^2)$。该通量逐点应用于砂浆网格。\n2.  一种熵稳定（ES）通量，它增加了数值耗散：$f^{\\mathrm{es}}(u_L, u_R) = f^{\\mathrm{ec}}(u_L, u_R) - \\frac{\\alpha}{2}(v_R - v_L)$，其中 $v=u$，耗散参数 $\\alpha = 1.3$。\n\n我们分析的核心量是离散界面对熵率的贡献，即 $\\mathcal{J}$。对于给定的砂浆数值通量 $f^\\star$，它定义为：\n$$\n\\mathcal{J} = \\left(v_L\\right)^T M_L I_{m\\to L} f^\\star - \\left(\\psi(u_L)\\right)^T \\mathbf{1}_L - \\left[ \\left(v_R\\right)^T M_R I_{m\\to R} f^\\star - \\left(\\psi(u_R)\\right)^T \\mathbf{1}_R \\right]\n$$\n此处，$u_L$ 和 $u_R$ 是面节点上的解向量，$v_L=u_L$，$v_R=u_R$，$\\psi(u)$ 按元素方式应用，$\\mathbf{1}$ 是全一向量。这个代数表达式量化了离散界面上的净熵产生/销毁。\n\n我们评估两个误差度量：\n1.  熵传递误差 $\\mathrm{E}_{\\mathrm{transfer}} = |\\mathcal{J}|$ 使用 EC 通量 $f^{\\mathrm{ec}}$ 计算。对于一个完全守恒的格式，这个误差应该为零（在机器精度范围内）。\n2.  界面耗散误差 $\\mathrm{E}_{\\mathrm{diss}} = |\\mathcal{J} - \\mathcal{J}_{\\mathrm{theory}}|$ 使用 ES 通量 $f^{\\mathrm{es}}$ 计算。它衡量了计算出的熵耗散率 $\\mathcal{J}$ 与理论上期望的耗散率 $\\mathcal{J}_{\\mathrm{theory}}$ 之间的差异，后者由下式给出：\n$$\n\\mathcal{J}_{\\mathrm{theory}} = -\\frac{1}{2}\\left(v_{R,m} - v_{L,m}\\right)^T M_m \\left(\\alpha I\\right) \\left(v_{R,m} - v_{L,m}\\right)\n$$\n其中 $v_{L,m} = u_{L,m}$ 和 $v_{R,m} = u_{R,m}$ 是砂浆上的熵变量迹，而 $I$ 是大小为 $N_m \\times N_m$ 的单位矩阵。一个小的 $\\mathrm{E}_{\\mathrm{diss}}$ 值表明该格式产生的耗散与设计完全一致。\n\n对于三个测试用例中的每一个，数值实验按以下步骤进行：\n1.  通过在面节点 $x_L$ 和 $x_R$ 上分别评估给定的关于 $s \\in [-1,1]$ 的函数，来初始化节点解向量 $u_L$ 和 $u_R$。\n2.  对于策略 A，使用 $M$-正交投影算子 $P_{L\\to m}$ 和 $P_{R\\to m}$ 计算砂浆迹 $u_{L,m}$ 和 $u_{R,m}$。\n3.  对于策略 B，使用朴素插值矩阵 $I_{L\\to m}$ 和 $I_{R\\to m}$ 计算砂浆迹。\n4.  对于每种策略，我们数值计算 $\\mathrm{E}_{\\mathrm{transfer}}$ 和 $\\mathrm{E}_{\\mathrm{diss}}$。$M$-正交投影（策略 A）预计将产生接近机器精度的误差，从而证明其与离散熵框架的兼容性；而朴素插值（策略 B）预计将产生显著误差，突显其未能保持关键的离散特性。\n\n给出的三个测试用例是：\n- 用例 1：$u_L(s) = \\frac{1}{2} + s$, $u_R(s) = -\\frac{1}{5} + \\frac{3}{10}s^2$（光滑失配）\n- 用例 2：$u_L(s) = \\frac{1}{3} - \\frac{1}{4}s + \\frac{1}{5}s^2$, $u_R(s) = u_L(s)$（迹匹配）\n- 用例 3：$u_L(s) = 1$, $u_R(s) = -1$（常数跳跃）\n\n最终输出将是一个包含12个浮点数的列表，代表三个用例中每一个的四个计算误差（$\\mathrm{E}_{\\mathrm{transfer}}^A, \\mathrm{E}_{\\mathrm{transfer}}^B, \\mathrm{E}_{\\mathrm{diss}}^A, \\mathrm{E}_{\\mathrm{diss}}^B$）。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Constructs and runs a numerical experiment on the entropy stability\n    of a mortar coupling for a scalar conservation law.\n    \"\"\"\n\n    def interpolation_matrix(nodes_src, nodes_tgt):\n        \"\"\"\n        Constructs the Lagrange interpolation matrix from source to target nodes.\n        The entry (k, j) is L_j(t_k), where L_j is the j-th Lagrange polynomial\n        for the source nodes and t_k is the k-th target node.\n        \"\"\"\n        n_src = len(nodes_src)\n        n_tgt = len(nodes_tgt)\n        mat = np.zeros((n_tgt, n_src))\n\n        for j in range(n_src):\n            # Construct j-th Lagrange polynomial L_j\n            xj = nodes_src[j]\n            den = 1.0\n            for i in range(n_src):\n                if i != j:\n                    den *= (xj - nodes_src[i])\n            \n            # Barycentric form is more stable, but direct form is fine for small N\n            if np.abs(den)  1e-15:\n                # This should not happen for distinct nodes\n                raise ValueError(\"Source nodes are not distinct.\")\n\n            # Evaluate L_j at all target nodes\n            for k in range(n_tgt):\n                tk = nodes_tgt[k]\n                if np.abs(tk - xj)  1e-15:\n                    mat[k, j] = 1.0\n                    continue\n\n                num = 1.0\n                for i in range(n_src):\n                    if i != j:\n                        num *= (tk - nodes_src[i])\n                mat[k, j] = num / den\n        return mat\n\n    # Fixed parameters from the problem statement\n    N_L, N_R, N_m = 3, 2, 4\n    alpha = 1.3\n\n    # 1. Construct Gauss-Legendre nodes and weights\n    x_L, w_L = roots_legendre(N_L)\n    x_R, w_R = roots_legendre(N_R)\n    x_m, w_m = roots_legendre(N_m)\n\n    # 2. Form diagonal mass matrices\n    M_L = np.diag(w_L)\n    M_R = np.diag(w_R)\n    M_m = np.diag(w_m)\n    M_m_inv = np.diag(1.0 / w_m)\n    \n    # 3. Construct all needed interpolation matrices\n    I_L_to_m = interpolation_matrix(x_L, x_m)\n    I_R_to_m = interpolation_matrix(x_R, x_m)\n    I_m_to_L = interpolation_matrix(x_m, x_L)\n    I_m_to_R = interpolation_matrix(x_m, x_R)\n\n    # 4. Construct M-orthogonal projection operators\n    P_L_to_m = M_m_inv @ I_m_to_L.T @ M_L\n    P_R_to_m = M_m_inv @ I_m_to_R.T @ M_R\n\n    # Define test cases\n    test_cases = [\n        {'uL_func': lambda s: 0.5 + s, 'uR_func': lambda s: -0.2 + 0.3 * s**2},\n        {'uL_func': lambda s: 1/3 - 0.25 * s + 0.2 * s**2, 'uR_func': lambda s: 1/3 - 0.25 * s + 0.2 * s**2},\n        {'uL_func': lambda s: 1.0, 'uR_func': lambda s: -1.0}\n    ]\n\n    # Mathematical functions from the problem\n    def psi(u):\n        return (1.0 / 6.0) * u**3\n\n    def f_ec(uL, uR):\n        return (1.0 / 6.0) * (uL**2 + uL * uR + uR**2)\n\n    def f_es(uL, uR):\n        vL, vR = uL, uR  # Entropy variable v = u\n        return f_ec(uL, uR) - (alpha / 2.0) * (vR - vL)\n\n    all_results = []\n    \n    for case in test_cases:\n        # Evaluate nodal states u_L, u_R\n        u_L = np.array([case['uL_func'](s) for s in x_L])\n        u_R = np.array([case['uR_func'](s) for s in x_R])\n\n        v_L, v_R = u_L, u_R  # v = u\n        psi_L, psi_R = psi(u_L), psi(u_R)\n\n        ones_L = np.ones(N_L)\n        ones_R = np.ones(N_R)\n        \n        # --- Process both strategies ---\n        strategies = {\n            'A': {'uLm': P_L_to_m @ u_L, 'uRm': P_R_to_m @ u_R}, # M-orthogonal\n            'B': {'uLm': I_L_to_m @ u_L, 'uRm': I_R_to_m @ u_R}  # Naive\n        }\n        \n        case_results = []\n        for strategy_id in ['A', 'B']:\n            strat = strategies[strategy_id]\n            u_L_m, u_R_m = strat['uLm'], strat['uRm']\n            v_L_m, v_R_m = u_L_m, u_R_m # v = u\n\n            # --- E_transfer calculation (with f_ec) ---\n            f_star_ec = f_ec(u_L_m, u_R_m)\n            J_ec = (v_L.T @ M_L @ I_m_to_L @ f_star_ec - psi_L.T @ ones_L) - \\\n                   (v_R.T @ M_R @ I_m_to_R @ f_star_ec - psi_R.T @ ones_R)\n            E_transfer = np.abs(J_ec)\n            \n            # --- E_diss calculation (with f_es) ---\n            f_star_es = f_es(u_L_m, u_R_m)\n            J_es = (v_L.T @ M_L @ I_m_to_L @ f_star_es - psi_L.T @ ones_L) - \\\n                   (v_R.T @ M_R @ I_m_to_R @ f_star_es - psi_R.T @ ones_R)\n            \n            J_theory = -0.5 * (v_R_m - v_L_m).T @ M_m @ (alpha * np.eye(N_m)) @ (v_R_m - v_L_m)\n            E_diss = np.abs(J_es - J_theory)\n            \n            if strategy_id == 'A':\n                case_results.extend([E_transfer, 0.0, E_diss, 0.0]) # Placeholders for B\n            else: # strategy 'B'\n                case_results[1] = E_transfer\n                case_results[3] = E_diss\n        \n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}