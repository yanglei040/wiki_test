{
    "hands_on_practices": [
        {
            "introduction": "In Discontinuous Galerkin methods, a common strategy for controlling spurious oscillations near shocks is to apply a hierarchical limiter directly to the modal coefficients of the polynomial solution. This practice provides a concrete look at this technique by examining how selectively scaling the highest-order modal coefficient of a cubic polynomial affects the solution's nodal values. By working through this exercise , you will verify the crucial property that such limiters must preserve the cell average, a cornerstone of conservation.",
            "id": "3414617",
            "problem": "Consider a one-dimensional scalar conservation law discretized by the Discontinuous Galerkin (DG) method, where the local representation in a cell mapped to the reference interval $[-1,1]$ uses a polynomial of degree $P^3$ in the modal Legendre basis. Let the solution be expressed as $u(x) = \\sum_{k=0}^{3} a_k L_k(x)$, where $L_k(x)$ are the standard Legendre polynomials on $[-1,1]$. To capture shocks with minimal spurious oscillations, a hierarchical slope limiter scales only the highest modal coefficient, replacing $a_3$ by $\\lambda a_3$ with a limiter factor $\\lambda \\in [0,1]$, while leaving $a_0$, $a_1$, and $a_2$ unchanged. The Gauss–Lobatto interpolation points for $P^3$ on $[-1,1]$ are $x=-1$, $x=-1/\\sqrt{5}$, $x=1/\\sqrt{5}$, and $x=1$.\n\nStarting from the fundamental properties of Legendre polynomials and their orthogonality with respect to the $L^2([-1,1])$ inner product, derive the nodal values $u(x)$ at the four Gauss–Lobatto points after limiting the $k=3$ mode, and verify from first principles that the cell average is preserved by this limiter. Express your final answer as a single row matrix containing, in order, the four nodal values and the cell average after limiting, in exact symbolic form in terms of $a_0$, $a_1$, $a_2$, $a_3$, and $\\lambda$.",
            "solution": "The problem is valid. It is scientifically grounded in the theory of numerical methods for partial differential equations, specifically the Discontinuous Galerkin (DG) method. It is well-posed, objective, and contains all necessary information to derive a unique solution without contradiction.\n\nThe objective is to analyze the effect of a hierarchical slope limiter on a polynomial solution representation within a DG framework. We are given a solution $u(x)$ in a cell, represented on the reference interval $[-1, 1]$ as a degree-$3$ polynomial expressed in a modal Legendre basis:\n$$\nu(x) = \\sum_{k=0}^{3} a_k L_k(x) = a_0 L_0(x) + a_1 L_1(x) + a_2 L_2(x) + a_3 L_3(x)\n$$\nwhere $L_k(x)$ are the standard Legendre polynomials and $a_k$ are the modal coefficients.\n\nThe hierarchical limiter acts by scaling only the highest-order coefficient, $a_3$, by a factor $\\lambda \\in [0,1]$. The limited solution, which we will denote as $u_{lim}(x)$, is therefore:\n$$\nu_{lim}(x) = a_0 L_0(x) + a_1 L_1(x) + a_2 L_2(x) + (\\lambda a_3) L_3(x)\n$$\nWe need to perform two tasks:\n1. Verify from first principles that the cell average of the solution is preserved by this limiter.\n2. Derive the nodal values of the limited solution, $u_{lim}(x)$, at the four specified Gauss-Lobatto points.\n\nFirst, we verify the preservation of the cell average. The cell average of a function $f(x)$ on the reference interval $[-1, 1]$ is defined as:\n$$\n\\bar{f} = \\frac{1}{1 - (-1)} \\int_{-1}^{1} f(x) \\, dx = \\frac{1}{2} \\int_{-1}^{1} f(x) \\, dx\n$$\nThe Legendre polynomials, $L_k(x)$, are orthogonal with respect to the $L^2([-1,1])$ inner product, which is defined as $\\langle f, g \\rangle = \\int_{-1}^{1} f(x)g(x) \\, dx$. The orthogonality relation is:\n$$\n\\int_{-1}^{1} L_k(x) L_j(x) \\, dx = \\frac{2}{2k+1} \\delta_{kj}\n$$\nwhere $\\delta_{kj}$ is the Kronecker delta.\n\nThe first Legendre polynomial is $L_0(x) = 1$. The cell average of the limited solution $u_{lim}(x)$ is:\n$$\n\\bar{u}_{lim} = \\frac{1}{2} \\int_{-1}^{1} u_{lim}(x) \\, dx = \\frac{1}{2} \\int_{-1}^{1} \\left( a_0 L_0(x) + a_1 L_1(x) + a_2 L_2(x) + \\lambda a_3 L_3(x) \\right) dx\n$$\nBy linearity of the integral, we can write this as:\n$$\n\\bar{u}_{lim} = \\frac{1}{2} \\left( a_0 \\int_{-1}^{1} L_0(x) \\, dx + a_1 \\int_{-1}^{1} L_1(x) \\, dx + a_2 \\int_{-1}^{1} L_2(x) \\, dx + \\lambda a_3 \\int_{-1}^{1} L_3(x) \\, dx \\right)\n$$\nWe can express each integral using the orthogonality property by noting that $\\int_{-1}^{1} L_k(x) \\, dx = \\int_{-1}^{1} L_k(x) L_0(x) \\, dx$. Based on the orthogonality relation, this integral is non-zero only for $k=0$:\n$$\n\\int_{-1}^{1} L_k(x) L_0(x) \\, dx = \\frac{2}{2(0)+1} \\delta_{k0} = 2 \\delta_{k0}\n$$\nTherefore, the integrals for $L_1(x)$, $L_2(x)$, and $L_3(x)$ are all zero. The expression for the cell average simplifies to:\n$$\n\\bar{u}_{lim} = \\frac{1}{2} \\left( a_0 (2\\delta_{00}) + a_1 (2\\delta_{10}) + a_2 (2\\delta_{20}) + \\lambda a_3 (2\\delta_{30}) \\right) = \\frac{1}{2} (a_0 \\cdot 2) = a_0\n$$\nThe cell average of the original unlimited solution, $\\bar{u}$, is also $a_0$. Thus, $\\bar{u}_{lim} = \\bar{u} = a_0$. The cell average is preserved and is equal to the first modal coefficient, $a_0$. This fundamental property is a direct consequence of using an orthogonal basis where the first basis function is a constant.\n\nNext, we derive the nodal values of $u_{lim}(x)$ at the specified Gauss-Lobatto points: $x = -1$, $x = -1/\\sqrt{5}$, $x = 1/\\sqrt{5}$, and $x=1$. To do this, we need the expressions for the first four Legendre polynomials:\n$L_0(x) = 1$\n$L_1(x) = x$\n$L_2(x) = \\frac{1}{2}(3x^2 - 1)$\n$L_3(x) = \\frac{1}{2}(5x^3 - 3x)$\n\nWe evaluate these polynomials at each of the four points:\n\n1. At $x = -1$:\n$L_0(-1) = 1$\n$L_1(-1) = -1$\n$L_2(-1) = \\frac{1}{2}(3(-1)^2 - 1) = 1$\n$L_3(-1) = \\frac{1}{2}(5(-1)^3 - 3(-1)) = -1$\n\n2. At $x = -1/\\sqrt{5}$:\n$L_0(-1/\\sqrt{5}) = 1$\n$L_1(-1/\\sqrt{5}) = -1/\\sqrt{5}$\n$L_2(-1/\\sqrt{5}) = \\frac{1}{2}(3(-1/\\sqrt{5})^2 - 1) = \\frac{1}{2}(\\frac{3}{5} - 1) = -\\frac{1}{5}$\n$L_3(-1/\\sqrt{5}) = \\frac{1}{2}(5(-1/\\sqrt{5})^3 - 3(-1/\\sqrt{5})) = \\frac{1}{2}(-\\frac{5}{5\\sqrt{5}} + \\frac{3}{\\sqrt{5}}) = \\frac{1}{2}(\\frac{2}{\\sqrt{5}}) = \\frac{1}{\\sqrt{5}}$\n\n3. At $x = 1/\\sqrt{5}$:\n$L_0(1/\\sqrt{5}) = 1$\n$L_1(1/\\sqrt{5}) = 1/\\sqrt{5}$\n$L_2(1/\\sqrt{5}) = \\frac{1}{2}(3(1/\\sqrt{5})^2 - 1) = \\frac{1}{2}(\\frac{3}{5} - 1) = -\\frac{1}{5}$\n$L_3(1/\\sqrt{5}) = \\frac{1}{2}(5(1/\\sqrt{5})^3 - 3(1/\\sqrt{5})) = \\frac{1}{2}(\\frac{5}{5\\sqrt{5}} - \\frac{3}{\\sqrt{5}}) = \\frac{1}{2}(-\\frac{2}{\\sqrt{5}}) = -\\frac{1}{\\sqrt{5}}$\n\n4. At $x = 1$:\n$L_0(1) = 1$\n$L_1(1) = 1$\n$L_2(1) = \\frac{1}{2}(3(1)^2 - 1) = 1$\n$L_3(1) = \\frac{1}{2}(5(1)^3 - 3(1)) = 1$\n\nNow, we substitute these values into the expression for $u_{lim}(x)$ to find the nodal values.\n\nNodal value at $x=-1$:\n$u_{lim}(-1) = a_0 L_0(-1) + a_1 L_1(-1) + a_2 L_2(-1) + \\lambda a_3 L_3(-1)$\n$u_{lim}(-1) = a_0(1) + a_1(-1) + a_2(1) + \\lambda a_3(-1) = a_0 - a_1 + a_2 - \\lambda a_3$\n\nNodal value at $x=-1/\\sqrt{5}$:\n$u_{lim}(-1/\\sqrt{5}) = a_0 L_0(-1/\\sqrt{5}) + a_1 L_1(-1/\\sqrt{5}) + a_2 L_2(-1/\\sqrt{5}) + \\lambda a_3 L_3(-1/\\sqrt{5})$\n$u_{lim}(-1/\\sqrt{5}) = a_0(1) + a_1(-1/\\sqrt{5}) + a_2(-1/5) + \\lambda a_3(1/\\sqrt{5}) = a_0 - \\frac{a_1}{\\sqrt{5}} - \\frac{a_2}{5} + \\frac{\\lambda a_3}{\\sqrt{5}}$\n\nNodal value at $x=1/\\sqrt{5}$:\n$u_{lim}(1/\\sqrt{5}) = a_0 L_0(1/\\sqrt{5}) + a_1 L_1(1/\\sqrt{5}) + a_2 L_2(1/\\sqrt{5}) + \\lambda a_3 L_3(1/\\sqrt{5})$\n$u_{lim}(1/\\sqrt{5}) = a_0(1) + a_1(1/\\sqrt{5}) + a_2(-1/5) + \\lambda a_3(-1/\\sqrt{5}) = a_0 + \\frac{a_1}{\\sqrt{5}} - \\frac{a_2}{5} - \\frac{\\lambda a_3}{\\sqrt{5}}$\n\nNodal value at $x=1$:\n$u_{lim}(1) = a_0 L_0(1) + a_1 L_1(1) + a_2 L_2(1) + \\lambda a_3 L_3(1)$\n$u_{lim}(1) = a_0(1) + a_1(1) + a_2(1) + \\lambda a_3(1) = a_0 + a_1 + a_2 + \\lambda a_3$\n\nThe final result is a collection of these four nodal values and the conserved cell average, $a_0$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\na_0 - a_1 + a_2 - \\lambda a_3 & a_0 - \\frac{a_1}{\\sqrt{5}} - \\frac{a_2}{5} + \\frac{\\lambda a_3}{\\sqrt{5}} & a_0 + \\frac{a_1}{\\sqrt{5}} - \\frac{a_2}{5} - \\frac{\\lambda a_3}{\\sqrt{5}} & a_0 + a_1 + a_2 + \\lambda a_3 & a_0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "A robust numerical method must not introduce errors when simulating trivial physical states, a property known as free-stream preservation. This principle becomes particularly important for high-order methods on curved meshes, where the geometry itself can be a source of numerical artifacts. This exercise  exposes a common implementation pitfall, demonstrating how a limiter applied naively in reference coordinates can misinterpret geometric curvature as a physical gradient, leading to the spurious modification of a perfectly constant solution.",
            "id": "3414596",
            "problem": "Consider the one-dimensional linear advection conservation law $\\partial_{t} u + a \\, \\partial_{x} u = 0$ with constant advection speed $a$, discretized by a degree-$1$ Discontinuous Galerkin (DG) method on a single curved isoparametric element. The physical coordinate $x$ is mapped from the reference coordinate $\\xi \\in [-1,1]$ via $x(\\xi) = \\xi + \\alpha \\, \\xi^{2}$, where $\\alpha$ is a nonzero curvature parameter, and the mapping Jacobian is $J(\\xi) = \\frac{dx}{d\\xi} = 1 + 2 \\alpha \\, \\xi$. Assume the exact physical solution is a free stream $u(x) \\equiv u_{0}$ with $u_{0} \\neq 0$ constant. In the weak conservative form on the reference element, the conservative variable represented in the DG polynomial is $q(\\xi) = J(\\xi) \\, u(\\xi)$.\n\nA Total Variation Diminishing (TVD) minmod-type slope limiter is applied in reference coordinates to the conservative variable $q(\\xi)$, using the degree-$1$ polynomial representation $q(\\xi) = c_{0} + c_{1} \\, \\xi$. The limiter reconstructs $q^{L}(\\xi) = \\bar{q} + s^{L} \\, \\xi$, where $\\bar{q}$ is the reference-cell average defined by $\\bar{q} = \\frac{1}{2} \\int_{-1}^{1} q(\\xi) \\, d\\xi$, the prelimited slope is $s = c_{1}$, and a shock sensor triggers if $S = \\frac{|s|}{|\\bar{q}|} > \\kappa$ for a given threshold $\\kappa \\in (0,1)$. When the sensor triggers, the limiter sets $s^{L} = 0$ (otherwise $s^{L} = s$). In contrast, a physically consistent limiter would operate in physical coordinates on $u(\\xi)$ instead of $q(\\xi)$.\n\nStarting from these definitions and the mapping, derive the activation condition in terms of $\\alpha$ and $\\kappa$, explain why limiting in reference coordinates on $q(\\xi)$ can bias the limiter on curved elements and break free-stream preservation, and compute the resulting limited physical solution $u^{L}(\\xi)$ when the sensor triggers and $s^{L} = 0$. Your final answer must be the single closed-form analytic expression for $u^{L}(\\xi)$ using the given $J(\\xi)$. No numerical approximation or rounding is required, and no units are to be reported.",
            "solution": "The problem is validated as sound, well-posed, and based on established principles of numerical methods for conservation laws. We may proceed with the solution.\n\nThe problem considers a one-dimensional linear advection equation, $\\partial_{t} u + a \\, \\partial_{x} u = 0$, with an exact free-stream solution $u(x) = u_{0}$, where $u_{0} \\neq 0$ is a constant. The discretization is performed using a degree-$1$ Discontinuous Galerkin (DG) method on a single curved element. The geometry is defined by the mapping from the reference coordinate $\\xi \\in [-1,1]$ to the physical coordinate $x$ via $x(\\xi) = \\xi + \\alpha \\, \\xi^{2}$. The Jacobian of this mapping is $J(\\xi) = \\frac{dx}{d\\xi} = 1 + 2 \\alpha \\, \\xi$.\n\nThe DG method operates on a polynomial representation of the conservative variable in the reference element, which is defined as $q(\\xi) = J(\\xi) \\, u(\\xi)$. Since the physical solution is a constant $u_{0}$, the corresponding solution in the reference frame is also constant, $u(\\xi) = u_{0}$.\nTherefore, the exact conservative variable is:\n$$q(\\xi) = J(\\xi) u_{0} = (1 + 2 \\alpha \\, \\xi) u_{0} = u_{0} + 2 \\alpha u_{0} \\, \\xi$$\nThis is a linear polynomial in $\\xi$.\n\nThe degree-$1$ DG representation of this variable is given as $q(\\xi) = c_{0} + c_{1} \\, \\xi$. Since the exact expression for $q(\\xi)$ is already a degree-$1$ polynomial, the DG representation is exact, and we can directly identify the coefficients by comparison:\n$$c_{0} = u_{0}$$\n$$c_{1} = 2 \\alpha u_{0}$$\n\nA minmod-type slope limiter is applied to this representation. The limiter operates on the reference-cell average, $\\bar{q}$, and the prelimited slope, $s$.\n\nFirst, we compute the reference-cell average $\\bar{q}$:\n$$\\bar{q} = \\frac{1}{2} \\int_{-1}^{1} q(\\xi) \\, d\\xi = \\frac{1}{2} \\int_{-1}^{1} (u_{0} + 2 \\alpha u_{0} \\, \\xi) \\, d\\xi$$\n$$\\bar{q} = \\frac{u_{0}}{2} \\left[ \\xi + \\alpha \\, \\xi^{2} \\right]_{-1}^{1} = \\frac{u_{0}}{2} \\left( (1 + \\alpha) - (-1 + \\alpha) \\right) = \\frac{u_{0}}{2} (2) = u_{0}$$\nAlternatively, using the polynomial coefficients, the average of $c_{0} + c_{1} \\xi$ over the symmetric interval $[-1,1]$ is simply $c_{0}$. Thus, $\\bar{q} = c_{0} = u_{0}$.\n\nThe prelimited slope, $s$, is given as the coefficient of the linear term, $s = c_{1}$.\n$$s = 2 \\alpha u_{0}$$\n\nThe shock sensor is defined as $S = \\frac{|s|}{|\\bar{q}|}$, and it triggers if $S > \\kappa$ for a given threshold $\\kappa \\in (0,1)$. We can substitute our computed values for $s$ and $\\bar{q}$:\n$$S = \\frac{|2 \\alpha u_{0}|}{|u_{0}|} = 2 |\\alpha| \\frac{|u_{0}|}{|u_{0}|}$$\nSince $u_{0} \\neq 0$, this simplifies to:\n$$S = 2 |\\alpha|$$\nThe activation condition for the limiter is therefore $S > \\kappa$, which translates to:\n$$2 |\\alpha| > \\kappa$$\n\nThis condition reveals why limiting in reference coordinates on $q(\\xi)$ can be problematic and break free-stream preservation. The physical solution $u(x) = u_{0}$ is a constant, representing a perfectly smooth free stream. Any physically consistent numerical method should preserve this solution exactly without modification. However, the limiter is applied to $q(\\xi) = J(\\xi) u(\\xi)$. On a curved element ($\\alpha \\neq 0$), the Jacobian $J(\\xi)$ is not constant. Multiplying the constant physical solution $u_{0}$ by the spatially varying Jacobian $J(\\xi)$ results in a conservative variable $q(\\xi)$ that has a non-zero slope, $s = 2 \\alpha u_{0}$. The limiter misinterprets this slope, which is purely an artifact of the element's curvature, as a physical gradient or oscillation in the solution itself. If the curvature is large enough such that $2|\\alpha| > \\kappa$, the limiter is spuriously activated. This modification of a perfectly smooth solution is the definition of breaking free-stream preservation. A consistent limiter would need to operate on the physical variable $u(\\xi)$, which it would reconstruct as $u(\\xi) = q(\\xi) / J(\\xi) = (u_0 + 2\\alpha u_0 \\xi)/(1+2\\alpha\\xi) = u_0(1+2\\alpha\\xi)/(1+2\\alpha\\xi) = u_0$. The slope of this reconstructed physical variable is zero, so a physically consistent limiter would not trigger.\n\nFinally, we compute the resulting limited physical solution $u^{L}(\\xi)$ when the sensor triggers. According to the problem statement, when the sensor triggers, the limiter sets the new slope to zero, $s^{L} = 0$. The limited conservative variable is then reconstructed as:\n$$q^{L}(\\xi) = \\bar{q} + s^{L} \\, \\xi$$\nSubstituting $\\bar{q} = u_{0}$ and $s^{L} = 0$:\n$$q^{L}(\\xi) = u_{0} + (0) \\xi = u_{0}$$\nThe limiter has effectively flattened the conservative variable representation to its cell average.\n\nTo find the limited physical solution $u^{L}(\\xi)$, we must transform back from the conservative variable in the reference frame by dividing by the Jacobian:\n$$u^{L}(\\xi) = \\frac{q^{L}(\\xi)}{J(\\xi)}$$\nSubstituting $q^{L}(\\xi) = u_{0}$ and $J(\\xi) = 1 + 2 \\alpha \\, \\xi$:\n$$u^{L}(\\xi) = \\frac{u_{0}}{1 + 2 \\alpha \\, \\xi}$$\nThis is the final expression for the physical solution inside the element after the spurious limiting action. It is no longer constant, demonstrating the error introduced by the limiter.",
            "answer": "$$\\boxed{\\frac{u_{0}}{1 + 2 \\alpha \\, \\xi}}$$"
        },
        {
            "introduction": "Moving from analysis to synthesis, this final practice guides you through the design and implementation of a modern, bound-preserving limiter from first principles. You will derive the scaling factor for a moment-based limiter, a robust technique that ensures the solution remains within physical bounds, and prove its key theoretical property of linearity preservation. By translating this theory into a working program , you will bridge the gap between abstract concepts and the practical code needed for high-fidelity simulations.",
            "id": "3414588",
            "problem": "Consider a scalar Discontinuous Galerkin (DG) approximation on the one-dimensional reference element $K = [-1,1]$ expressed in a hierarchical modal basis of Legendre polynomials $\\{P_k(x)\\}_{k=0}^p$. Let the polynomial be\n$$\nu_h(x) = \\sum_{k=0}^p \\hat{u}_k P_k(x),\n$$\nwhere $\\hat{u}_k \\in \\mathbb{R}$ are the modal coefficients and $P_k(x)$ is the Legendre polynomial of degree $k$. Let $\\{x_i\\}_{i=1}^m$ be the Gauss–Legendre quadrature nodes of order $m$. Suppose we are given element-wise bounds $u_{\\min}, u_{\\max} \\in \\mathbb{R}$ and we wish to ensure the bound-preserving property at the quadrature points:\n$$\nu_{\\min} \\le u_h(x_i) \\le u_{\\max} \\quad \\text{for all } i \\in \\{1,\\dots,m\\}.\n$$\n\nTask A (derivation): Starting from the modal representation and the definition of the Gauss–Legendre quadrature nodes, derive a moment-based limiter that rescales only the higher-than-linear modes to enforce the bounds at the quadrature nodes, under the assumption that the degree-$1$ projection\n$$\nu^{(1)}(x) = \\hat{u}_0 P_0(x) + \\hat{u}_1 P_1(x)\n$$\nalready satisfies the bounds at the quadrature nodes, i.e.,\n$$\nu_{\\min} \\le u^{(1)}(x_i) \\le u_{\\max} \\quad \\text{for all } i.\n$$\nYour limiter should find a scaling factor $\\theta \\in [0,1]$ such that the limited polynomial\n$$\nu_h^{\\text{lim}}(x) = u^{(1)}(x) + \\theta \\left( u_h(x) - u^{(1)}(x) \\right)\n$$\nsatisfies $u_{\\min} \\le u_h^{\\text{lim}}(x_i) \\le u_{\\max}$ for all quadrature nodes $x_i$, and the limited modal coefficients are\n$$\n\\hat{u}_0^{\\text{lim}} = \\hat{u}_0, \\quad \\hat{u}_1^{\\text{lim}} = \\hat{u}_1, \\quad \\hat{u}_k^{\\text{lim}} = \\theta \\hat{u}_k \\ \\text{for all } k \\ge 2.\n$$\nExplicitly derive $\\theta$ from first principles based on the inequalities at the quadrature nodes.\n\nTask B (proof): Prove that the above limiter is linearity preserving for polynomials of degree $1$. That is, show that if $u_h$ is of degree at most $1$, then the limiter leaves $u_h$ unchanged.\n\nTask C (implementation and verification): Implement the derived limiter for the reference element $K=[-1,1]$, using Gauss–Legendre nodes for the set $\\{x_i\\}_{i=1}^m$. Your program must:\n- Evaluate Legendre polynomials at the given nodes.\n- Apply the limiter to scale only the modes of degree greater than or equal to $2$.\n- Verify whether the limited polynomial satisfies the bounds at the quadrature nodes within a tolerance of $\\varepsilon = 10^{-12}$.\n- Detect infeasibility when the degree-$1$ projection violates the bounds at any quadrature node; in that case, report failure for that test.\n\nUse the following test suite (each test provides $p$, $m$, the coefficient list $[\\hat{u}_0,\\hat{u}_1,\\dots,\\hat{u}_p]$, and bounds $u_{\\min},u_{\\max}$):\n- Test $1$ (happy path, cubic with overshoot): $p=3$, $m=10$, coefficients $[0.6,\\,0.1,\\,0.8,\\,-0.5]$, $u_{\\min}=0.0$, $u_{\\max}=1.0$.\n- Test $2$ (infeasible due to linear part): $p=1$, $m=10$, coefficients $[0.9,\\,0.3]$, $u_{\\min}=0.0$, $u_{\\max}=1.0$.\n- Test $3$ (linearity preserved, inside bounds): $p=1$, $m=10$, coefficients $[0.4,\\,0.2]$, $u_{\\min}=0.0$, $u_{\\max}=1.0$.\n- Test $4$ (quadratic overshoot damped by limiting): $p=2$, $m=10$, coefficients $[0.05,\\,0.0,\\,0.9]$, $u_{\\min}=0.0$, $u_{\\max}=1.0$.\n- Test $5$ (linearity preserved at bounds): $p=1$, $m=10$, coefficients $[0.5,\\,0.5]$, $u_{\\min}=0.0$, $u_{\\max}=1.0$.\n\nYour program should return a list of booleans, one per test, defined as follows:\n- For tests with $p \\ge 2$: return $\\text{True}$ if the limiter succeeds and the limited values at all quadrature nodes lie in $[u_{\\min}-\\varepsilon, u_{\\max}+\\varepsilon]$; otherwise return $\\text{False}$.\n- For tests with $p \\le 1$: return $\\text{True}$ if the limiter succeeds and the limited coefficients equal the original coefficients within tolerance $\\varepsilon$ (linearity preserving) and the values at quadrature nodes lie in $[u_{\\min}-\\varepsilon, u_{\\max}+\\varepsilon]$; otherwise return $\\text{False}$. If the degree-$1$ projection violates the bounds at any quadrature node, the test must return $\\text{False}$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[ \\text{True},\\text{False},\\text{True} ]$).",
            "solution": "The problem requires the derivation, proof, and implementation of a moment-based limiter for a Discontinuous Galerkin approximation on the reference element $K = [-1,1]$. The solution is constructed using a modal basis of Legendre polynomials.\n\n### Task A: Derivation of the Scaling Factor $\\theta$\n\nWe are given a polynomial approximation of degree $p$:\n$$\nu_h(x) = \\sum_{k=0}^p \\hat{u}_k P_k(x)\n$$\nThe goal is to enforce the bounds $u_{\\min} \\le u_h(x_i) \\le u_{\\max}$ at a set of Gauss-Legendre quadrature nodes $\\{x_i\\}_{i=1}^m$. The limiter modifies the polynomial to the form:\n$$\nu_h^{\\text{lim}}(x) = u^{(1)}(x) + \\theta \\left( u_h(x) - u^{(1)}(x) \\right)\n$$\nwhere $u^{(1)}(x) = \\hat{u}_0 P_0(x) + \\hat{u}_1 P_1(x)$ is the linear part of the solution, and $\\theta \\in [0,1]$ is a scaling factor to be determined. The derivation proceeds under the critical assumption that the linear part already satisfies the bounds at all quadrature nodes, i.e., $u_{\\min} \\le u^{(1)}(x_i) \\le u_{\\max}$ for all $i \\in \\{1, \\dots, m\\}$.\n\nThe limited solution must satisfy the bounds at each quadrature node $x_i$:\n$$\nu_{\\min} \\le u_h^{\\text{lim}}(x_i) \\le u_{\\max}\n$$\nSubstituting the expression for $u_h^{\\text{lim}}(x_i)$:\n$$\nu_{\\min} \\le u^{(1)}(x_i) + \\theta \\left( u_h(x_i) - u^{(1)}(x_i) \\right) \\le u_{\\max}\n$$\nLet us define the value of the linear part at node $x_i$ as $u^{(1)}_i = u^{(1)}(x_i)$ and the difference between the full solution and its linear part as $d_i = u_h(x_i) - u^{(1)}_i$. The double inequality becomes:\n$$\nu_{\\min} \\le u^{(1)}_i + \\theta d_i \\le u_{\\max}\n$$\nThis can be split into two separate inequalities:\n1. $u_{\\min} - u^{(1)}_i \\le \\theta d_i$\n2. $\\theta d_i \\le u_{\\max} - u^{(1)}_i$\n\nWe must find the largest $\\theta \\in [0,1]$ that satisfies these two inequalities for all $i \\in \\{1,\\dots,m\\}$. We analyze the constraints on $\\theta$ by considering the sign of $d_i$.\n\n**Case 1: $d_i > 0$**\nIf $d_i > 0$, the solution $u_h(x_i)$ is greater than its linear part $u^{(1)}_i$. This corresponds to a potential overshoot of the upper bound $u_{\\max}$. Dividing the inequalities by the positive quantity $d_i$ preserves their direction:\n- $\\frac{u_{\\min} - u^{(1)}_i}{d_i} \\le \\theta$\n- $\\theta \\le \\frac{u_{\\max} - u^{(1)}_i}{d_i}$\n\nBy the initial assumption, $u_{\\min} \\le u^{(1)}_i$, which implies $u_{\\min} - u^{(1)}_i \\le 0$. Since $d_i > 0$, the lower bound on $\\theta$ is non-positive, i.e., $\\frac{u_{\\min} - u^{(1)}_i}{d_i} \\le 0$. As we seek $\\theta \\in [0,1]$, this lower bound is automatically satisfied. The only effective constraint from this case is the upper bound:\n$$\n\\theta \\le \\frac{u_{\\max} - u^{(1)}_i}{d_i}\n$$\n\n**Case 2: $d_i < 0$**\nIf $d_i < 0$, the solution $u_h(x_i)$ is less than its linear part $u^{(1)}_i$. This corresponds to a potential undershoot of the lower bound $u_{\\min}$. Dividing the inequalities by the negative quantity $d_i$ reverses their direction:\n- $\\frac{u_{\\min} - u^{(1)}_i}{d_i} \\ge \\theta \\implies \\theta \\le \\frac{u_{\\min} - u^{(1)}_i}{d_i}$\n- $\\theta \\ge \\frac{u_{\\max} - u^{(1)}_i}{d_i}$\n\nBy the initial assumption, $u^{(1)}_i \\le u_{\\max}$, which implies $u_{\\max} - u^{(1)}_i \\ge 0$. Since $d_i < 0$, the lower bound on $\\theta$ is non-positive, i.e., $\\frac{u_{\\max} - u^{(1)}_i}{d_i} \\le 0$. This is again satisfied for any $\\theta \\in [0,1]$. The effective constraint is the upper bound:\n$$\n\\theta \\le \\frac{u_{\\min} - u^{(1)}_i}{d_i}\n$$\nNote that since $u_{\\min} - u^{(1)}_i \\le 0$ and $d_i < 0$, their ratio is non-negative, yielding a meaningful upper bound for $\\theta$.\n\n**Case 3: $d_i = 0$**\nIf $d_i = 0$, the inequalities reduce to $u_{\\min} - u^{(1)}_i \\le 0$ and $0 \\le u_{\\max} - u^{(1)}_i$. Both are equivalent to $u_{\\min} \\le u^{(1)}_i \\le u_{\\max}$, which is true by our initial assumption. Thus, this case imposes no constraint on $\\theta$.\n\n**Combining Constraints**\nTo satisfy the bounds at all quadrature nodes simultaneously, $\\theta$ must be less than or equal to the minimum of all derived upper bounds over all nodes. Let $S_+ = \\{i \\mid d_i > 0\\}$ and $S_- = \\{i \\mid d_i < 0\\}$. The constraints are:\n$$\n\\theta \\le \\min_{i \\in S_+} \\left( \\frac{u_{\\max} - u^{(1)}_i}{d_i} \\right) \\quad \\text{and} \\quad \\theta \\le \\min_{i \\in S_-} \\left( \\frac{u_{\\min} - u^{(1)}_i}{d_i} \\right)\n$$\nTo obtain the largest possible $\\theta$ (i.e., the least dissipative limiter) that is guaranteed to be in $[0,1]$, we combine these constraints and also enforce $\\theta \\le 1$. The final expression for $\\theta$ is:\n$$\n\\theta = \\min \\left( \\{1\\} \\cup \\left\\{ \\frac{u_{\\max} - u^{(1)}(x_i)}{u_h(x_i) - u^{(1)}(x_i)} \\;\\middle|\\; i \\in S_+ \\right\\} \\cup \\left\\{ \\frac{u_{\\min} - u^{(1)}(x_i)}{u_h(x_i) - u^{(1)}(x_i)} \\;\\middle|\\; i \\in S_- \\right\\} \\right)\n$$\nIf $u_h(x_i) = u^{(1)}(x_i)$ for all $i$, both sets $S_+$ and $S_-$ are empty. In this scenario, no limiting is required, and the formula correctly yields $\\theta=1$.\n\nThe limited modal coefficients are then given by:\n$$\n\\hat{u}_0^{\\text{lim}} = \\hat{u}_0, \\quad \\hat{u}_1^{\\text{lim}} = \\hat{u}_1, \\quad \\hat{u}_k^{\\text{lim}} = \\theta \\hat{u}_k \\ \\text{for all } k \\ge 2.\n$$\n\n### Task B: Proof of Linearity Preservation\n\nA limiter is linearity preserving if, given an input polynomial $u_h(x)$ that is already of degree at most $1$, the limited polynomial $u_h^{\\text{lim}}(x)$ is identical to $u_h(x)$.\n\n**Proof:**\nAssume $u_h(x)$ is a polynomial of degree at most $1$. By definition of the Legendre basis, this means that its representation contains only the first two modes:\n$$\nu_h(x) = \\hat{u}_0 P_0(x) + \\hat{u}_1 P_1(x)\n$$\nAll higher-degree coefficients are zero: $\\hat{u}_k = 0$ for all $k \\ge 2$.\n\nThe degree-$1$ projection of $u_h(x)$ is, by definition:\n$$\nu^{(1)}(x) = \\hat{u}_0 P_0(x) + \\hat{u}_1 P_1(x)\n$$\nTherefore, for a polynomial $u_h(x)$ of degree at most $1$, we have $u_h(x) = u^{(1)}(x)$ for all $x \\in [-1,1]$.\n\nThe limited polynomial is defined as:\n$$\nu_h^{\\text{lim}}(x) = u^{(1)}(x) + \\theta \\left( u_h(x) - u^{(1)}(x) \\right)\n$$\nSubstituting $u_h(x) = u^{(1)}(x)$ into this expression, we get:\n$$\nu_h^{\\text{lim}}(x) = u^{(1)}(x) + \\theta \\left( u^{(1)}(x) - u^{(1)}(x) \\right) = u^{(1)}(x) + \\theta \\cdot 0 = u^{(1)}(x)\n$$\nSince $u_h(x) = u^{(1)}(x)$, we conclude that:\n$$\nu_h^{\\text{lim}}(x) = u_h(x)\n$$\nThis shows that the limiter leaves polynomials of degree at most $1$ unchanged.\nRegarding the coefficients, for $k \\ge 2$, we have $\\hat{u}_k = 0$. The limited coefficients are $\\hat{u}_k^{\\text{lim}} = \\theta \\hat{u}_k = \\theta \\cdot 0 = 0$. Thus, $\\hat{u}_k^{\\text{lim}} = \\hat{u}_k$ for all $k$. The coefficients are also unchanged. This completes the proof.\n\n### Task C: Implementation and Verification Strategy\n\nThe implementation will follow the derived formula for $\\theta$ and the logic for handling different cases. The core algorithm for a given test case ($p$, $m$, coefficients, and bounds) is as follows:\n\n1.  **Generate Quadrature Nodes**: Use `numpy.polynomial.legendre.leggauss(m)` to get the $m$ Gauss-Legendre quadrature nodes $\\{x_i\\}$ on the interval $[-1,1]$.\n2.  **Evaluate Polynomials**:\n    - Evaluate the full polynomial $u_h(x)$ at each node $x_i$ using the given coefficients $[\\hat{u}_0, \\dots, \\hat{u}_p]$. This can be done efficiently using `numpy.polynomial.legendre.legval`.\n    - Evaluate the linear part $u^{(1)}(x)$ at each node $x_i$ using coefficients $[\\hat{u}_0, \\hat{u}_1]$.\n3.  **Check Feasibility (Assumption Verification)**:\n    - Verify that the linear part $u^{(1)}(x_i)$ satisfies the bounds $u_{\\min} \\le u^{(1)}(x_i) \\le u_{\\max}$ at all nodes $x_i$.\n    - If this assumption is violated for any node, the problem setup for the limiter is invalid. The test case is deemed a failure, and the function must report this.\n4.  **Handle Linear Case ($p \\le 1$)**:\n    - If the degree $p$ is at most $1$, $u_h(x) = u^{(1)}(x)$. The feasibility check from the previous step is sufficient. If $u^{(1)}$ is within bounds, the test passes (as the limiter is linearity preserving, $\\theta=1$, and no change occurs). If it is not, the test fails.\n5.  **Calculate Scaling Factor $\\theta$ (for $p \\ge 2$)**:\n    - Calculate the differences $d_i = u_h(x_i) - u^{(1)}(x_i)$ for all $i$.\n    - If all $d_i$ are approximately zero, no limiting is needed; set $\\theta=1$.\n    - Otherwise, iterate through the nodes and compute the ratios for the upper bounds on $\\theta$ according to the sign of $d_i$, as derived in Task A.\n    - Determine $\\theta$ by taking the minimum of $1.0$ and all computed ratios.\n6.  **Apply Limiter and Verify**:\n    - Calculate the values of the limited polynomial at the nodes: $u_h^{\\text{lim}}(x_i) = u^{(1)}(x_i) + \\theta d_i$.\n    - Check if $u_{\\min} - \\varepsilon \\le u_h^{\\text{lim}}(x_i) \\le u_{\\max} + \\varepsilon$ for all nodes $x_i$, using the given tolerance $\\varepsilon = 10^{-12}$.\n7.  **Return Result**: Based on the outcomes of the checks, return `True` for a successful and verified test, and `False` otherwise, according to the specific rules laid out in the problem statement.\n\nThis systematic procedure correctly implements the derived theory and handles all specified test conditions and edge cases.",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss, legval\n\ndef process_case(p: int, m: int, coeffs: list, u_min: float, u_max: float, tol: float) -> bool:\n    \"\"\"\n    Applies and verifies the moment-based limiter for a single test case.\n\n    Args:\n        p: Polynomial degree.\n        m: Number of quadrature nodes.\n        coeffs: List of modal Legendre coefficients [u_0, u_1, ..., u_p].\n        u_min: Lower bound for the solution.\n        u_max: Upper bound for the solution.\n        tol: Numerical tolerance for comparisons.\n\n    Returns:\n        True if the test passes according to the problem criteria, False otherwise.\n    \"\"\"\n    # Ensure coeffs is a numpy array for easier slicing and calculations\n    u_coeffs = np.array(coeffs, dtype=float)\n\n    # Step 1: Get Gauss-Legendre quadrature nodes\n    # leggauss returns nodes and weights; we only need the nodes.\n    x_nodes, _ = leggauss(m)\n\n    # Step 2: Evaluate polynomials at the nodes\n    u_h_vals = legval(x_nodes, u_coeffs)\n    \n    # The linear part u^(1) has coefficients [u_0, u_1]\n    # For p=0, coeffs is [u_0]. We need to handle this by padding.\n    if p == 0:\n        u1_coeffs = np.array([u_coeffs[0], 0.0])\n    else:\n        u1_coeffs = u_coeffs[:2]\n    u1_vals = legval(x_nodes, u1_coeffs)\n\n    # Step 3: Check feasibility of the degree-1 projection\n    if np.any(u1_vals < u_min - tol) or np.any(u1_vals > u_max + tol):\n        # The assumption that the linear part is within bounds is violated.\n        return False\n\n    # Step 4: Handle linear cases (p <= 1)\n    if p <= 1:\n        # For p <= 1, u_h = u^(1). We've already checked if it's within bounds.\n        # The limiter should be inactive (theta=1), preserving the solution.\n        # The problem requires checking that limited coeffs == original coeffs.\n        # This is equivalent to checking if no limiting was needed.\n        # If u^(1) is in bounds, the test passes.\n        return True\n\n    # Step 5: Calculate scaling factor theta for p >= 2\n    theta = 1.0\n    d_vals = u_h_vals - u1_vals\n    \n    ratios = []\n    for i in range(m):\n        d_i = d_vals[i]\n        u1_i = u1_vals[i]\n        \n        if d_i > tol: # potential overshoot\n            ratios.append((u_max - u1_i) / d_i)\n        elif d_i < -tol: # potential undershoot\n            ratios.append((u_min - u1_i) / d_i)\n    \n    if ratios:\n        theta = min(1.0, min(ratios))\n\n    # Step 6: Apply limiter and verify the result\n    u_lim_vals = u1_vals + theta * d_vals\n    \n    # Verify if the limited solution is within the bounds [u_min, u_max]\n    # with the specified tolerance.\n    is_within_bounds = np.all((u_lim_vals >= u_min - tol) & (u_lim_vals <= u_max + tol))\n    \n    return is_within_bounds\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test suite from the problem statement\n    test_cases = [\n        # p, m, coefficients, u_min, u_max\n        (3, 10, [0.6, 0.1, 0.8, -0.5], 0.0, 1.0),   # Test 1\n        (1, 10, [0.9, 0.3], 0.0, 1.0),              # Test 2\n        (1, 10, [0.4, 0.2], 0.0, 1.0),              # Test 3\n        (2, 10, [0.05, 0.0, 0.9], 0.0, 1.0),        # Test 4\n        (1, 10, [0.5, 0.5], 0.0, 1.0),              # Test 5\n    ]\n\n    tolerance = 1e-12\n    results = []\n    \n    for case in test_cases:\n        p, m, coeffs, u_min, u_max = case\n        result = process_case(p, m, coeffs, u_min, u_max, tolerance)\n        results.append(result)\n\n    # Format output as a list of capitalized booleans with spaces after commas.\n    formatted_results = [str(r) for r in results]\n    print(f\"[{', '.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}