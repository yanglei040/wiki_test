{
    "hands_on_practices": [
        {
            "introduction": "在将子单元有限体积（FV）限制器应用于任意形状的网格时，一个基础且关键的步骤是精确计算每个物理子单元的体积（或二维中的面积）。这对于保证数值格式的守恒性至关重要，因为FV通量的更新依赖于这些体积。本练习 () 将引导你通过一个双线性等参映射，推导雅可比行列式并计算物理子单元的精确面积，从而为复杂的几何结构建立守恒的离散化基础。",
            "id": "3421998",
            "problem": "考虑一个从局部坐标为 $(\\xi,\\eta)\\in[0,1]\\times[0,1]$ 的参考四边形到由双线性形函数定义的物理曲边四边形 $\\Omega_{K}$ 的二维等参映射。设参考节点 $(\\xi,\\eta)=(0,0)$, $(1,0)$, $(0,1)$, $(1,1)$ 处的物理角点坐标分别为 $(x_{1},y_{1})=(0,0)$, $(x_{2},y_{2})=(3,0)$, $(x_{3},y_{3})=(0,2)$, $(x_{4},y_{4})=(4,3)$。等参映射为\n$$\nx(\\xi,\\eta)=\\sum_{i=1}^{4} x_{i} N_{i}(\\xi,\\eta),\\qquad y(\\xi,\\eta)=\\sum_{i=1}^{4} y_{i} N_{i}(\\xi,\\eta),\n$$\n其中 $N_{1}(\\xi,\\eta)=(1-\\xi)(1-\\eta)$, $N_{2}(\\xi,\\eta)=\\xi(1-\\eta)$, $N_{3}(\\xi,\\eta)=(1-\\xi)\\eta$ 以及 $N_{4}(\\xi,\\eta)=\\xi\\eta$。在一个带有用于激波的子网格有限体积 (FV) 限制的高阶间断 Galerkin (DG) 方法中，对子网格划分的守恒更新需要使用物理子网格的体积（面积），这由变量替换定理给出\n$$\nV_{S}=\\iint_{S} J(\\xi,\\eta)\\, \\mathrm{d}\\xi\\,\\mathrm{d}\\eta,\\qquad J(\\xi,\\eta)=\\det\\left(\\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)}\\right).\n$$\n对参考单元 $[0,1]\\times[0,1]$ 构建一个均匀的 $2\\times 2$ 子网格划分，其子网格为 $S_{11}=[0,\\tfrac{1}{2}]\\times[0,\\tfrac{1}{2}]$, $S_{12}=[\\tfrac{1}{2},1]\\times[0,\\tfrac{1}{2}]$, $S_{21}=[0,\\tfrac{1}{2}]\\times[\\tfrac{1}{2},1]$ 和 $S_{22}=[\\tfrac{1}{2},1]\\times[\\tfrac{1}{2},1]$。从基本的面积变量替换公式和等参双线性映射的定义出发，推导雅可比行列式 $J(\\xi,\\eta)$ 以及参考空间中任意一个轴对齐的矩形子网格 $S=[\\xi_{a},\\xi_{b}]\\times[\\eta_{a},\\eta_{b}]$ 的物理子网格体积 $V_{S}$ 的表达式。然后，精确计算子网格 $S_{11}=[0,\\tfrac{1}{2}]\\times[0,\\tfrac{1}{2}]$ 的体积 $V_{S_{11}}$。您的最终答案必须是一个精确的数值（不要四舍五入）。",
            "solution": "该问题要求首先推导一个特定的双线性等参映射的雅可比行列式，然后推导参考域中矩形子网格的物理面积（体积）的通用公式，最后精确计算特定子网格 $S_{11}$ 的面积。\n\n首先，我们建立从参考坐标 $(\\xi, \\eta)$ 到物理坐标 $(x, y)$ 的等参映射的显式形式。映射由下式给出：\n$$\nx(\\xi,\\eta)=\\sum_{i=1}^{4} x_{i} N_{i}(\\xi,\\eta)\n$$\n$$\ny(\\xi,\\eta)=\\sum_{i=1}^{4} y_{i} N_{i}(\\xi,\\eta)\n$$\n角点坐标为 $(x_{1},y_{1})=(0,0)$, $(x_{2},y_{2})=(3,0)$, $(x_{3},y_{3})=(0,2)$ 和 $(x_{4},y_{4})=(4,3)$。双线性形函数为 $N_{1}(\\xi,\\eta)=(1-\\xi)(1-\\eta)$, $N_{2}(\\xi,\\eta)=\\xi(1-\\eta)$, $N_{3}(\\xi,\\eta)=(1-\\xi)\\eta$ 和 $N_{4}(\\xi,\\eta)=\\xi\\eta$。\n\n将给定的坐标值代入映射方程：\n$$\nx(\\xi,\\eta) = (0)N_{1}(\\xi,\\eta) + (3)N_{2}(\\xi,\\eta) + (0)N_{3}(\\xi,\\eta) + (4)N_{4}(\\xi,\\eta) = 3\\xi(1-\\eta) + 4\\xi\\eta = 3\\xi - 3\\xi\\eta + 4\\xi\\eta = 3\\xi + \\xi\\eta\n$$\n$$\ny(\\xi,\\eta) = (0)N_{1}(\\xi,\\eta) + (0)N_{2}(\\xi,\\eta) + (2)N_{3}(\\xi,\\eta) + (3)N_{4}(\\xi,\\eta) = 2(1-\\xi)\\eta + 3\\xi\\eta = 2\\eta - 2\\xi\\eta + 3\\xi\\eta = 2\\eta + \\xi\\eta\n$$\n\n接下来，我们计算变换的雅可比矩阵 $\\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)}$。这需要计算 $x$ 和 $y$ 关于 $\\xi$ 和 $\\eta$ 的偏导数。\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}(3\\xi + \\xi\\eta) = 3 + \\eta\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}(3\\xi + \\xi\\eta) = \\xi\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}(2\\eta + \\xi\\eta) = \\eta\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}(2\\eta + \\xi\\eta) = 2 + \\xi\n$$\n雅可比矩阵为：\n$$\n\\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} 3+\\eta & \\xi \\\\ \\eta & 2+\\xi \\end{pmatrix}\n$$\n雅可比行列式 $J(\\xi,\\eta)$ 是该矩阵的行列式：\n$$\nJ(\\xi,\\eta) = \\det\\left(\\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)}\\right) = (3+\\eta)(2+\\xi) - (\\xi)(\\eta) = 6 + 3\\xi + 2\\eta + \\xi\\eta - \\xi\\eta = 6 + 3\\xi + 2\\eta\n$$\n\n现在我们推导参考空间中任意一个轴对齐的矩形子网格 $S=[\\xi_{a},\\xi_{b}]\\times[\\eta_{a},\\eta_{b}]$ 的物理体积（面积）$V_{S}$ 的表达式。体积由雅可比行列式在子网格 S 上的积分给出。\n$$\nV_{S} = \\iint_{S} J(\\xi,\\eta)\\, \\mathrm{d}\\xi\\,\\mathrm{d}\\eta = \\int_{\\eta_{a}}^{\\eta_{b}} \\int_{\\xi_{a}}^{\\xi_{b}} (6 + 3\\xi + 2\\eta) \\, \\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n$$\n我们进行积分，首先计算关于 $\\xi$ 的内层积分：\n$$\n\\int_{\\xi_{a}}^{\\xi_{b}} (6 + 3\\xi + 2\\eta) \\, \\mathrm{d}\\xi = \\left[ 6\\xi + \\frac{3}{2}\\xi^2 + 2\\eta\\xi \\right]_{\\xi_{a}}^{\\xi_{b}} = (6\\xi_{b} + \\frac{3}{2}\\xi_{b}^2 + 2\\eta\\xi_{b}) - (6\\xi_{a} + \\frac{3}{2}\\xi_{a}^2 + 2\\eta\\xi_{a})\n$$\n$$\n= 6(\\xi_{b} - \\xi_{a}) + \\frac{3}{2}(\\xi_{b}^2 - \\xi_{a}^2) + 2\\eta(\\xi_{b} - \\xi_{a})\n$$\n接下来，我们将此结果从 $\\eta_{a}$ 到 $\\eta_{b}$ 对 $\\eta$ 进行积分：\n$$\nV_{S} = \\int_{\\eta_{a}}^{\\eta_{b}} \\left( 6(\\xi_{b} - \\xi_{a}) + \\frac{3}{2}(\\xi_{b}^2 - \\xi_{a}^2) + 2\\eta(\\xi_{b} - \\xi_{a}) \\right) \\mathrm{d}\\eta\n$$\n$$\nV_{S} = \\left[ \\left( 6(\\xi_{b} - \\xi_{a}) + \\frac{3}{2}(\\xi_{b}^2 - \\xi_{a}^2) \\right)\\eta + \\eta^2(\\xi_{b} - \\xi_{a}) \\right]_{\\eta_{a}}^{\\eta_{b}}\n$$\n$$\nV_{S} = \\left( 6(\\xi_{b} - \\xi_{a}) + \\frac{3}{2}(\\xi_{b}^2 - \\xi_{a}^2) \\right)(\\eta_{b}-\\eta_{a}) + (\\eta_{b}^2 - \\eta_{a}^2)(\\xi_{b} - \\xi_{a})\n$$\n这就是子网格体积的通用表达式。\n\n最后，我们为特定子网格 $S_{11}=[0,\\tfrac{1}{2}]\\times[0,\\tfrac{1}{2}]$ 计算该表达式的值。对于此子网格，积分限为 $\\xi_{a}=0$, $\\xi_{b}=\\frac{1}{2}$, $\\eta_{a}=0$ 和 $\\eta_{b}=\\frac{1}{2}$。我们可以将这些值代入推导出的通用公式，或直接计算定积分。我们来计算定积分：\n$$\nV_{S_{11}} = \\int_{0}^{1/2} \\int_{0}^{1/2} (6 + 3\\xi + 2\\eta) \\, \\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n$$\n内层积分为：\n$$\n\\int_{0}^{1/2} (6 + 3\\xi + 2\\eta) \\, \\mathrm{d}\\xi = \\left[ 6\\xi + \\frac{3}{2}\\xi^2 + 2\\eta\\xi \\right]_{0}^{1/2} = \\left(6\\left(\\frac{1}{2}\\right) + \\frac{3}{2}\\left(\\frac{1}{2}\\right)^2 + 2\\eta\\left(\\frac{1}{2}\\right)\\right) - (0) = 3 + \\frac{3}{8} + \\eta\n$$\n外层积分为：\n$$\nV_{S_{11}} = \\int_{0}^{1/2} \\left(3 + \\frac{3}{8} + \\eta\\right) \\mathrm{d}\\eta = \\left[ 3\\eta + \\frac{3}{8}\\eta + \\frac{1}{2}\\eta^2 \\right]_{0}^{1/2}\n$$\n$$\nV_{S_{11}} = \\left(3\\left(\\frac{1}{2}\\right) + \\frac{3}{8}\\left(\\frac{1}{2}\\right) + \\frac{1}{2}\\left(\\frac{1}{2}\\right)^2\\right) - (0) = \\frac{3}{2} + \\frac{3}{16} + \\frac{1}{2}\\left(\\frac{1}{4}\\right) = \\frac{3}{2} + \\frac{3}{16} + \\frac{1}{8}\n$$\n为了将这些分数相加，我们找到公分母 16：\n$$\nV_{S_{11}} = \\frac{3 \\times 8}{16} + \\frac{3}{16} + \\frac{1 \\times 2}{16} = \\frac{24}{16} + \\frac{3}{16} + \\frac{2}{16} = \\frac{24+3+2}{16} = \\frac{29}{16}\n$$\n子网格 $S_{11}$ 的精确体积为 $\\frac{29}{16}$。",
            "answer": "$$\n\\boxed{\\frac{29}{16}}\n$$"
        },
        {
            "introduction": "当一个单元被标记为“有问题”并切换到子单元有限体积方法后，我们可能需要在下一时间步将其状态重建回高阶多项式形式。这个重建过程必须是守恒的，即保持单元的平均值不变。本练习 () 将通过一个约束最小二乘问题，探索如何从分片常数的子单元平均值中，以保平均值的方式，重建一个最优的二阶间断伽辽金多项式。",
            "id": "3422067",
            "problem": "考虑一个标量守恒律，它在一个坐标为 $\\xi \\in [-1,1]$ 的单一参考单元上通过间断伽辽金（DG）方法进行离散化。一个子单元有限体积（FV）限制器在三个等尺寸的子单元 $I_{1}=[-1,-\\tfrac{1}{3}]$、$I_{2}=[-\\tfrac{1}{3},\\tfrac{1}{3}]$ 和 $I_{3}=[\\tfrac{1}{3},1]$ 上提供了分片常数的子单元平均值 $\\{m_{j}\\}_{j=1}^{3}$。你需要通过求解一个强制执行单元平均值守恒的约束最小二乘问题，在 $[-1,1]$ 上的二次勒让德基（即 $P_{0}(\\xi)=1$、$P_{1}(\\xi)=\\xi$ 和 $P_{2}(\\xi)=\\tfrac{1}{2}(3\\xi^{2}-1)$）中重构一个2次DG多项式 $u_{h}(\\xi)$。\n\n形式上，定义分片常数数据函数 $m(\\xi)$ 为当 $\\xi \\in I_{j}$ 时 $m(\\xi)=m_{j}$，并寻找\n$$\nu_{h}(\\xi)=c_{0}P_{0}(\\xi)+c_{1}P_{1}(\\xi)+c_{2}P_{2}(\\xi)\n$$\n以最小化平方$L^{2}$偏差\n$$\nJ(c_{0},c_{1},c_{2})=\\sum_{j=1}^{3}\\int_{I_{j}}\\left(u_{h}(\\xi)-m(\\xi)\\right)^{2}\\,d\\xi\n$$\n同时满足守恒约束，即DG单元平均值等于FV计算的单元平均值，\n$$\n\\frac{1}{2}\\int_{-1}^{1}u_{h}(\\xi)\\,d\\xi=\\bar{m},\\quad \\bar{m}=\\frac{1}{2}\\sum_{j=1}^{3}\\int_{I_{j}}m(\\xi)\\,d\\xi=\\frac{m_{1}+m_{2}+m_{3}}{3}.\n$$\n推导唯一的极小值点，并以 $\\xi$、$m_{1}$、$m_{2}$ 和 $m_{3}$ 的显式函数形式给出最终的重构多项式 $u_{h}(\\xi)$。你的最终答案必须是 $u_{h}(\\xi)$ 的一个单一闭式解析表达式，不得有四舍五入，也没有单位。",
            "solution": "该问题要求找到一个二次多项式 $u_{h}(\\xi)$，使其相对于分片常数函数 $m(\\xi)$ 的平方$L^{2}$偏差最小，且其单元平均值满足一个积分约束。这是一个约束优化问题，可以使用拉格朗日乘子法求解，或者通过直接代入约束来减少自由变量的数量。我们将采用后者，即更直接的方法。\n\n待重构的多项式为2次，并以区间 $[-1,1]$ 上的勒让德多项式为基进行表示：\n$$\nu_{h}(\\xi) = c_{0}P_{0}(\\xi) + c_{1}P_{1}(\\xi) + c_{2}P_{2}(\\xi)\n$$\n其中 $P_{0}(\\xi)=1$，$P_{1}(\\xi)=\\xi$，以及 $P_{2}(\\xi)=\\frac{1}{2}(3\\xi^{2}-1)$。\n\n该约束强制单元平均值守恒：\n$$\n\\frac{1}{2}\\int_{-1}^{1}u_{h}(\\xi)\\,d\\xi = \\bar{m}\n$$\n其中 $\\bar{m}$ 是子单元数据 $\\{m_{1}, m_{2}, m_{3}\\}$ 在单元 $[-1,1]$ 上的平均值。根据题目所给，$\\bar{m} = \\frac{m_{1}+m_{2}+m_{3}}{3}$。我们首先分析该约束。将 $u_{h}(\\xi)$ 的表达式代入约束积分中：\n$$\n\\frac{1}{2}\\int_{-1}^{1} \\left(c_{0}P_{0}(\\xi) + c_{1}P_{1}(\\xi) + c_{2}P_{2}(\\xi)\\right) \\,d\\xi = \\bar{m}\n$$\n勒让德多项式在 $[-1,1]$ 上是正交的，满足 $\\int_{-1}^{1}P_{n}(\\xi)P_{k}(\\xi)\\,d\\xi = \\frac{2}{2n+1}\\delta_{nk}$。我们可以将该积分写成与 $P_{0}(\\xi)=1$ 的内积。\n$$\n\\frac{1}{2}\\int_{-1}^{1} u_{h}(\\xi)P_{0}(\\xi)\\,d\\xi = \\frac{1}{2} \\left( c_{0}\\int_{-1}^{1}P_{0}^{2}(\\xi)\\,d\\xi + c_{1}\\int_{-1}^{1}P_{1}(\\xi)P_{0}(\\xi)\\,d\\xi + c_{2}\\int_{-1}^{1}P_{2}(\\xi)P_{0}(\\xi)\\,d\\xi \\right) = \\bar{m}\n$$\n由于正交性，涉及 $P_1 P_0$ 和 $P_2 P_0$ 的积分为零。第一个积分给出 $\\int_{-1}^{1}P_{0}^{2}(\\xi)\\,d\\xi = \\int_{-1}^{1}1^{2}\\,d\\xi = 2$。\n约束简化为：\n$$\n\\frac{1}{2} (c_{0} \\cdot 2) = c_{0} = \\bar{m} = \\frac{m_{1}+m_{2}+m_{3}}{3}\n$$\n因此，守恒约束直接确定了第一个系数 $c_{0}$。\n\n问题现在简化为在 $c_{0}$ 固定为 $\\bar{m}$ 的情况下，寻找最小化目标函数 $J$ 的系数 $c_{1}$ 和 $c_{2}$。\n$$\nJ(c_{1},c_{2}) = \\int_{-1}^{1} \\left(u_{h}(\\xi)-m(\\xi)\\right)^{2}\\,d\\xi\n$$\n为使 $J$ 达到最小值，其关于自由变量 $c_{1}$ 和 $c_{2}$ 的偏导数必须为零。\n$$\n\\frac{\\partial J}{\\partial c_{1}} = \\int_{-1}^{1} 2\\left(u_{h}(\\xi)-m(\\xi)\\right)\\frac{\\partial u_{h}}{\\partial c_{1}}\\,d\\xi = \\int_{-1}^{1} 2\\left(u_{h}(\\xi)-m(\\xi)\\right)P_{1}(\\xi)\\,d\\xi = 0\n$$\n$$\n\\frac{\\partial J}{\\partial c_{2}} = \\int_{-1}^{1} 2\\left(u_{h}(\\xi)-m(\\xi)\\right)\\frac{\\partial u_{h}}{\\partial c_{2}}\\,d\\xi = \\int_{-1}^{1} 2\\left(u_{h}(\\xi)-m(\\xi)\\right)P_{2}(\\xi)\\,d\\xi = 0\n$$\n这些条件为 $c_1$ 和 $c_2$ 导出了一个二元线性方程组：\n1. $\\int_{-1}^{1} u_{h}(\\xi)P_{1}(\\xi)\\,d\\xi = \\int_{-1}^{1} m(\\xi)P_{1}(\\xi)\\,d\\xi$\n2. $\\int_{-1}^{1} u_{h}(\\xi)P_{2}(\\xi)\\,d\\xi = \\int_{-1}^{1} m(\\xi)P_{2}(\\xi)\\,d\\xi$\n\n我们利用勒让德多项式的正交性来计算这些方程的左侧（LHS）：\n(1) 的 LHS： $\\int_{-1}^{1} (c_{0}P_{0}+c_{1}P_{1}+c_{2}P_{2})P_{1}\\,d\\xi = c_{1}\\int_{-1}^{1}P_{1}^{2}(\\xi)\\,d\\xi = c_{1}\\frac{2}{2(1)+1} = \\frac{2}{3}c_{1}$。\n(2) 的 LHS： $\\int_{-1}^{1} (c_{0}P_{0}+c_{1}P_{1}+c_{2}P_{2})P_{2}\\,d\\xi = c_{2}\\int_{-1}^{1}P_{2}^{2}(\\xi)\\,d\\xi = c_{2}\\frac{2}{2(2)+1} = \\frac{2}{5}c_{2}$。\n\n接下来，我们计算方程的右侧（RHS）。函数 $m(\\xi)$ 在子单元 $I_{1}=[-1,-\\frac{1}{3}]$、$I_{2}=[-\\frac{1}{3},\\frac{1}{3}]$ 和 $I_{3}=[\\frac{1}{3},1]$ 上是分片常数的。\n(1) 的 RHS： $\\int_{-1}^{1} m(\\xi)P_{1}(\\xi)\\,d\\xi = \\int_{-1}^{1} m(\\xi)\\xi\\,d\\xi$\n$$\n= \\int_{-1}^{-1/3} m_{1}\\xi\\,d\\xi + \\int_{-1/3}^{1/3} m_{2}\\xi\\,d\\xi + \\int_{1/3}^{1} m_{3}\\xi\\,d\\xi\n$$\n$$\n= m_{1}\\left[\\frac{\\xi^{2}}{2}\\right]_{-1}^{-1/3} + m_{2}\\left[\\frac{\\xi^{2}}{2}\\right]_{-1/3}^{1/3} + m_{3}\\left[\\frac{\\xi^{2}}{2}\\right]_{1/3}^{1}\n$$\n$$\n= m_{1}\\left(\\frac{1}{18}-\\frac{1}{2}\\right) + m_{2}\\left(\\frac{1}{18}-\\frac{1}{18}\\right) + m_{3}\\left(\\frac{1}{2}-\\frac{1}{18}\\right) = m_{1}\\left(-\\frac{8}{18}\\right) + m_{3}\\left(\\frac{8}{18}\\right) = \\frac{4}{9}(m_{3}-m_{1})\n$$\n令(1)的LHS和RHS相等：$\\frac{2}{3}c_{1} = \\frac{4}{9}(m_{3}-m_{1})$，得到 $c_{1} = \\frac{3}{2}\\frac{4}{9}(m_{3}-m_{1}) = \\frac{2}{3}(m_{3}-m_{1})$。\n\n(2) 的 RHS： $\\int_{-1}^{1} m(\\xi)P_{2}(\\xi)\\,d\\xi = \\int_{-1}^{1} m(\\xi)\\frac{1}{2}(3\\xi^{2}-1)\\,d\\xi$\n$$\n= \\frac{1}{2}\\left( m_{1}\\int_{-1}^{-1/3}(3\\xi^{2}-1)d\\xi + m_{2}\\int_{-1/3}^{1/3}(3\\xi^{2}-1)d\\xi + m_{3}\\int_{1/3}^{1}(3\\xi^{2}-1)d\\xi \\right)\n$$\n其反导数是 $\\int(3\\xi^{2}-1)d\\xi = \\xi^{3}-\\xi$。令 $F(\\xi) = \\xi^{3}-\\xi$。\n$$\n\\int_{-1}^{-1/3}(3\\xi^{2}-1)d\\xi = F(-\\tfrac{1}{3}) - F(-1) = (-\\tfrac{1}{27}+\\tfrac{1}{3}) - (-1+1) = \\tfrac{8}{27}\n$$\n$$\n\\int_{-1/3}^{1/3}(3\\xi^{2}-1)d\\xi = F(\\tfrac{1}{3}) - F(-\\tfrac{1}{3}) = (\\tfrac{1}{27}-\\tfrac{1}{3}) - (-\\tfrac{1}{27}+\\tfrac{1}{3}) = 2(\\tfrac{1}{27}-\\tfrac{1}{3}) = -\\tfrac{16}{27}\n$$\n$$\n\\int_{1/3}^{1}(3\\xi^{2}-1)d\\xi = F(1) - F(\\tfrac{1}{3}) = (1-1) - (\\tfrac{1}{27}-\\tfrac{1}{3}) = \\tfrac{8}{27}\n$$\n因此(2)的RHS为：\n$$\n\\frac{1}{2}\\left(m_{1}\\frac{8}{27} + m_{2}\\frac{-16}{27} + m_{3}\\frac{8}{27}\\right) = \\frac{4}{27}(m_{1}-2m_{2}+m_{3})\n$$\n令(2)的LHS和RHS相等：$\\frac{2}{5}c_{2} = \\frac{4}{27}(m_{1}-2m_{2}+m_{3})$，得到 $c_{2} = \\frac{5}{2}\\frac{4}{27}(m_{1}-2m_{2}+m_{3}) = \\frac{10}{27}(m_{1}-2m_{2}+m_{3})$。\n\n现在我们已经确定了所有系数：\n$c_{0} = \\frac{m_{1}+m_{2}+m_{3}}{3}$\n$c_{1} = \\frac{2}{3}(m_{3}-m_{1})$\n$c_{2} = \\frac{10}{27}(m_{1}-2m_{2}+m_{3})$\n\n最终的重构多项式是 $u_{h}(\\xi)=c_{0}P_{0}(\\xi)+c_{1}P_{1}(\\xi)+c_{2}P_{2}(\\xi)$。\n代入勒让德多项式和系数：\n$$\nu_{h}(\\xi) = \\left(\\frac{m_{1}+m_{2}+m_{3}}{3}\\right) + \\left(\\frac{2}{3}(m_{3}-m_{1})\\right)\\xi + \\left(\\frac{10}{27}(m_{1}-2m_{2}+m_{3})\\right)\\left(\\frac{3\\xi^{2}-1}{2}\\right)\n$$\n为了得到关于 $\\xi$ 的标准多项式表达式，我们合并 $\\xi$ 的同次幂项。\n$\\xi^2$ 的系数是： $\\frac{10}{27}(m_{1}-2m_{2}+m_{3}) \\cdot \\frac{3}{2} = \\frac{5}{9}(m_{1}-2m_{2}+m_{3})$。\n$\\xi$ 的系数是： $\\frac{2}{3}(m_{3}-m_{1})$。\n常数项是：\n$$\nc_{0} - \\frac{1}{2}c_{2} = \\frac{m_{1}+m_{2}+m_{3}}{3} - \\frac{1}{2}\\frac{10}{27}(m_{1}-2m_{2}+m_{3})\n$$\n$$\n= \\frac{9(m_{1}+m_{2}+m_{3})}{27} - \\frac{5(m_{1}-2m_{2}+m_{3})}{27}\n$$\n$$\n= \\frac{9m_{1}+9m_{2}+9m_{3} - 5m_{1}+10m_{2}-5m_{3}}{27} = \\frac{4m_{1}+19m_{2}+4m_{3}}{27}\n$$\n合并这些项，我们得到重构多项式的最终表达式：\n$$\nu_{h}(\\xi) = \\left(\\frac{5}{9}(m_{1}-2m_{2}+m_{3})\\right)\\xi^{2} + \\left(\\frac{2}{3}(m_{3}-m_{1})\\right)\\xi + \\frac{4m_{1}+19m_{2}+4m_{3}}{27}\n$$",
            "answer": "$$\n\\boxed{\\left(\\frac{5}{9}(m_{1}-2m_{2}+m_{3})\\right)\\xi^{2} + \\left(\\frac{2}{3}(m_{3}-m_{1})\\right)\\xi + \\frac{4m_{1}+19m_{2}+4m_{3}}{27}}\n$$"
        },
        {
            "introduction": "设计一个高效的限制器需要在激波捕捉的鲁棒性和光滑流区域的精度保持之间做出权衡。此外，对于特定的物理问题，如可压缩流，保持离散能量等性质也可能至关重要。本综合练习 () 要求你设计并实现一个完整的限制器算法，它不仅要能通过“问题单元”指示器识别激波，还要在施加限制的同时满足物理上的正定性约束和离散动能的保持，让你亲身体验在实际应用中平衡这些复杂需求的挑战。",
            "id": "3421986",
            "problem": "考虑一个由可压缩欧拉方程控制的一维可压缩流，该方程描述了质量、动量和能量守恒。令守恒状态向量为 $U = (\\rho, m, E)$，其中 $\\rho$ 是密度， $m = \\rho u$ 是动量（$u$ 为速度），$E$ 是总能量。压力由 $p = (\\gamma - 1)\\left(E - \\tfrac{1}{2}\\tfrac{m^2}{\\rho}\\right)$ 给出，其中比热比 $\\gamma > 1$。在参考区间 $x \\in [-1,1]$ 上的单个 Discontinuous Galerkin (DG) 单元上，假设原始场 $\\rho(x)$、$u(x)$ 和 $p(x)$ 由 $N$ 次 Legendre 展开表示，\n$$\n\\rho(x) = \\sum_{k=0}^N a_k P_k(x), \\quad\nu(x) = \\sum_{k=0}^N b_k P_k(x), \\quad\np(x) = \\sum_{k=0}^N c_k P_k(x),\n$$\n其中 $P_k(x)$ 是 $[-1,1]$ 上的第 $k$ 阶 Legendre 多项式，系数 $\\{a_k\\}$、$\\{b_k\\}$ 和 $\\{c_k\\}$ 是给定的。DG 多项式状态 $U_{\\mathrm{DG}}(x)$ 是通过构造 $m(x) = \\rho(x) u(x)$ 和 $E(x) = \\tfrac{p(x)}{\\gamma - 1} + \\tfrac{1}{2}\\rho(x)u(x)^2$ 得到的。\n\n子单元有限体积 (FV) 限制器被定义为 DG 多项式状态与一个子单元常数状态之间的凸组合，该常数状态等于 $U_{\\mathrm{DG}}(x)$ 的单元平均值。具体来说，将 $[-1,1]$ 划分成 $M$ 个等长的子单元，其中心为 $\\{x_j\\}_{j=1}^M$，并定义常数平均值\n$$\n\\overline{U} = \\frac{1}{2}\\int_{-1}^1 U_{\\mathrm{DG}}(x)\\,dx,\n$$\n使得在任意空间位置 $x$ 处的限制后状态为\n$$\nU_\\alpha(x) = (1-\\alpha)\\,\\overline{U} + \\alpha\\, U_{\\mathrm{DG}}(x), \\quad \\alpha \\in [0,1].\n$$\n令单元上的离散动能泛函定义为\n$$\nK[U] = \\frac{1}{2}\\cdot\\frac{1}{2}\\int_{-1}^1 \\frac{m(x)^2}{\\rho(x)}\\,dx,\n$$\n我们使用足够精确的 Gauss–Legendre 求积法来近似该泛函。在用于无粘性可压缩流的斜对称 DG 格式（体积项以分裂形式书写）中，对于周期域上的光滑解，离散动能 $K[U_{\\mathrm{DG}}]$ 在体积项的贡献下是守恒的（不考虑压力功和边界项）。我们将要求限制器尊重这种离散动能守恒特性，即限制后的动能不超过原始 DG 动能：\n$$\nK[U_\\alpha] \\le K[U_{\\mathrm{DG}}] + \\varepsilon_{\\mathrm{KE}},\n$$\n其中 $\\varepsilon_{\\mathrm{KE}} \\ge 0$ 是一个小的容差。\n\n定义正性阈值 $\\rho_{\\min} > 0$ 和 $p_{\\min} > 0$。限制器必须在每个子单元中心强制保持正性：\n$$\n\\rho_\\alpha(x_j) \\ge \\rho_{\\min}, \\quad p_\\alpha(x_j) \\ge p_{\\min}, \\quad j=1,\\dots,M,\n$$\n其中 $p_\\alpha(x) = (\\gamma - 1)\\left(E_\\alpha(x) - \\tfrac{1}{2}\\tfrac{m_\\alpha(x)^2}{\\rho_\\alpha(x)}\\right)$，且 $U_\\alpha(x) = (\\rho_\\alpha(x), m_\\alpha(x), E_\\alpha(x))$。\n\n为避免在光滑区域进行不必要的限制，我们基于压力展开的最高阶模态内容定义一个问题单元指示器。令\n$$\nR = \\frac{\\sum_{k=N}^N c_k^2}{\\sum_{k=0}^N c_k^2}.\n$$\n如果 $R > s_0 N^{-4}$，则将单元声明为问题单元，其中 $s_0 > 0$ 是用户指定的阈值。如果单元不是问题单元，限制器必须保持非激活状态（$\\alpha = 1$），以在光滑区域保留斜对称离散动能特性。如果单元是问题单元，则选择 $\\alpha$ 以在满足所有约束条件的情况下最大化精度：\n- 所有子单元中心的正性，\n- 动能不增加 $K[U_\\alpha] \\le K[U_{\\mathrm{DG}}] + \\varepsilon_{\\mathrm{KE}}$。\n\n这可以被描述为从两个约束中找到 $\\alpha$ 的可行区间，并选择该区间中最大的 $\\alpha$。对于一般数据，确定最大的 $\\alpha \\in [0,1]$ 以使所有正性约束都成立。另外，确定最小的 $\\alpha \\in [0,1]$ 以使 $K[U_\\alpha] \\le K[U_{\\mathrm{DG}}] + \\varepsilon_{\\mathrm{KE}}$ 成立。如果可行区间为空，则限制器失败；否则，选择等于可行区间上界的 $\\alpha$ 以最大化精度。\n\n使用两个度量标准来量化激波捕捉的鲁棒性：\n- 限制后满足正性的子单元比例，定义为\n$$\n\\phi = \\frac{1}{M}\\sum_{j=1}^M \\mathbf{1}\\big(\\rho_\\alpha(x_j) \\ge \\rho_{\\min} \\wedge p_\\alpha(x_j) \\ge p_{\\min}\\big),\n$$\n其中 $\\mathbf{1}(\\cdot)$ 是指示函数；\n- 子单元中心速度的总变差减小量，\n$$\n\\mathrm{TV}(u) = \\sum_{j=1}^{M-1} \\left|u(x_{j+1}) - u(x_{j})\\right|, \\quad \\Delta \\mathrm{TV} = \\mathrm{TV}(u_{\\mathrm{DG}}) - \\mathrm{TV}(u_\\alpha).\n$$\n\n您的任务是实现上述限制器和度量标准。使用足够高阶的 Gauss-Legendre 求积法来近似计算平均值和 $K[U]$ 的积分。使用 $p_{\\min} = 10^{-8}$，$\\rho_{\\min} = 10^{-8}$ 和 $\\varepsilon_{\\mathrm{KE}} = 10^{-12}$。\n\n按如下方式实现问题单元检测和限制器选择算法：\n1. 根据壓力系数计算 $R$。如果 $R \\le s_0 N^{-4}$，则设置 $\\alpha = 1$。\n2. 如果 $R > s_0 N^{-4}$，通过 Gauss-Legendre 求积法计算常数平均状态 $\\overline{U}$。\n3. 利用约束的单调可行性，通过对 $\\alpha$ 进行二分法来确定满足所有子单元中心正性条件的最大 $\\alpha \\in [0,1]$。\n4. 利用 $K[U_\\alpha]$ 的单调行为，通过对 $\\alpha$ 进行二分法来确定满足 $K[U_\\alpha] \\le K[U_{\\mathrm{DG}}] + \\varepsilon_{\\mathrm{KE}}$ 的最小 $\\alpha \\in [0,1]$。\n5. 如果区间 $[\\alpha_{\\mathrm{KE,min}}, \\alpha_{\\mathrm{pos,max}}]$ 非空，选择 $\\alpha = \\alpha_{\\mathrm{pos,max}}$。如果为空，仍然选择 $\\alpha = \\alpha_{\\mathrm{pos,max}}$，并在动能变化中记录对动能约束的违反情况。\n\n对每个测试用例，计算并报告：\n- 最终的限制器参数 $\\alpha$，\n- 动能变化 $\\Delta K = K[U_\\alpha] - K[U_{\\mathrm{DG}}]$，\n- 总变差减小量 $\\Delta \\mathrm{TV}$，\n- 正性比例 $\\phi$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个结果本身是一个包含四个浮点数的列表 $[\\alpha, \\Delta K, \\Delta \\mathrm{TV}, \\phi]$，对应每个测试用例。\n\n使用以下参数值测试套件；对于每个用例，输入为 $(N, M, \\gamma, s_0, a, b, c)$，其中 $a$、$b$ 和 $c$ 分别是 $\\rho$、$u$ 和 $p$ 的 Legendre 系数数组：\n- 用例 1 (光滑，非问题单元): $N=3$, $M=8$, $\\gamma=1.4$, $s_0=10^{-6}$,\n  $a = [1.0, 0.05, -0.02, 0.0]$, $b = [0.2, -0.03, 0.01, 0.0]$, $c = [1.0, 0.04, -0.01, 0.0]$。\n- 用例 2 (类激波，带压力下冲): $N=3$, $M=16$, $\\gamma=1.4$, $s_0=10^{-4}$,\n  $a = [1.0, 0.2, -0.25, 0.1]$, $b = [0.5, -0.7, 0.2, -0.05]$, $c = [0.8, -0.9, 0.3, -0.1]$。\n- 用例 3 (近真空密度区): $N=4$, $M=12, \\gamma=1.4, s_0=10^{-4}$,\n  $a = [0.22, -0.21, 0.08, -0.02, 0.0]$, $b = [0.1, 0.2, -0.15, 0.05, -0.01]$, $c = [0.25, 0.02, -0.03, 0.01, 0.0]$。\n- 用例 4 (光滑但动能高，使用紧凑的指示器阈值以测试假阳性和动能可行性): $N=3$, $M=10$, $\\gamma=1.4$, $s_0=10^{-12}$,\n  $a = [1.0, -0.3, 0.2, -0.05]$, $b = [0.9, 0.4, -0.3, 0.1]$, $c = [1.2, 0.1, -0.08, 0.02]$。\n\n角度单位不适用。所有量均为无量纲。您的最终输出必须是以下形式的单行：\n$$\n[\\,[\\alpha_1, \\Delta K_1, \\Delta \\mathrm{TV}_1, \\phi_1],\\,[\\alpha_2, \\Delta K_2, \\Delta \\mathrm{TV}_2, \\phi_2],\\,[\\alpha_3, \\Delta K_3, \\Delta \\mathrm{TV}_3, \\phi_3],\\,[\\alpha_4, \\Delta K_4, \\Delta \\mathrm{TV}_4, \\phi_4]\\,].\n$$",
            "solution": "问题陈述被认为是有效的。它在计算流体动力学的高阶数值方法这一成熟科学领域内，具体来说是 Discontinuous Galerkin (DG) 方法，提出了一个定义明确的任务。该问题是自洽的，提供了所有必要的物理方程、数值定义、算法步骤和测试数据。尽管在约束冲突时选择限制器参数 $\\alpha$ 的指令中存在轻微的歧义，但在实现细节中提供了一个具体、可操作的规则，这为创建一个功能性算法消除了歧义。在此解释下，该问题具有科学依据、客观且是适定的。\n\n解决方案通过在单个单元上为 DG 格式实现指定的子单元有限体积 (FV) 限制器来展开。任务的核心是确定混合参数 $\\alpha \\in [0,1]$，该参数将状态从高阶 DG 多项式 $U_{\\mathrm{DG}}(x)$ 过渡到其单元常数平均值 $\\overline{U}$，其方式是在强制实现物理可容许性（密度和压力的正性）的同时，尝试保持一个离散动能不变量。\n\n流体的状态由守恒变量向量 $U(x) = (\\rho(x), m(x), E(x))$ 描述，其中 $\\rho$ 是密度，$m = \\rho u$ 是动量，$E$ 是单位体积的总能量。压力 $p$ 由状态方程 $p = (\\gamma - 1)(E - \\frac{1}{2} m^2/\\rho)$ 导出。在参考区间 $x \\in [-1,1]$ 上的 DG 单元内，原始变量 $\\rho(x)$、$u(x)$ 和 $p(x)$ 表示为 $N$ 次 Legendre 多项式展开。基于这些，构造出守恒变量多项式 $U_{\\mathrm{DG}}(x)$。\n\n该算法按以下步骤为每个测试用例执行：\n\n1.  **问题单元检测**：第一步是决定是否需要限制器。不必要的限制会降低 DG 方法在流场光滑区域的精度。计算一个问题单元指示器 $R$，该指示器基于压力的最高阶 Legendre 系数的平方 $c_N^2$ 与所有压力系数平方和 $\\sum_{k=0}^N c_k^2$ 的比值。\n    $$\n    R = \\frac{c_N^2}{\\sum_{k=0}^N c_k^2}\n    $$\n    如果该指示器超过预设阈值 $R > s_0 N^{-4}$，则将该单元标记为“问题单元”。$R$ 值小表明解是光滑的且能被多项式很好地解析，而 $R$ 值大则表示存在振荡行为，例如激波或接触间断，可能需要限制。如果单元不是问题单元，我们设置 $\\alpha = 1$，保留原始 DG 状态，并继续进行度量标准计算。\n\n2.  **状态表示与平均**：如果单元是问题单元，我们继续执行限制程序。限制后的状态是一个凸组合：\n    $$\n    U_\\alpha(x) = (1-\\alpha)\\,\\overline{U} + \\alpha\\, U_{\\mathrm{DG}}(x)\n    $$\n    其中 $\\overline{U}$ 是 DG 状态的单元平均值。$\\overline{U}$ 的分量通过高阶 Gauss-Legendre 求积法进行数值积分计算。具体来说，对于一个通用函数 $f(x)$，其在 $[-1,1]$ 上的平均值为 $\\bar{f} = \\frac{1}{2}\\int_{-1}^1 f(x) dx \\approx \\frac{1}{2}\\sum_{i=1}^{N_q} w_i f(x_i)$，其中 $\\{x_i, w_i\\}$ 是求积点和权重。注意，由于 Legendre 多项式的正交性，平均密度 $\\bar{\\rho}$ 简化为零阶 Legendre 系数 $\\bar{\\rho} = a_0$。平均动量 $\\bar{m}$ 和能量 $\\bar{E}$ 需要数值求积，因为 $m(x)$ 和 $E(x)$ 不是简单的多项式。我们使用一个有 $N_q=32$ 个点的求积法则，这对于所涉及的多项式次数是足够的。\n\n3.  **限制器参数选择**：限制器的核心是选择一个合适的 $\\alpha$。主要约束是物理可容许性，要求密度 $\\rho_\\alpha(x_j)$ 和压力 $p_\\alpha(x_j)$ 在 $M$ 个子单元中心 $\\{x_j\\}$ 的离散集合上保持正值。\n    $$\n    \\rho_\\alpha(x_j) \\ge \\rho_{\\min} \\quad \\text{且} \\quad p_\\alpha(x_j) \\ge p_{\\min} \\quad \\text{对于 } j=1, \\dots, M.\n    $$\n    压力是混合守恒状态 $U_\\alpha(x_j)$ 的一个非线性函数：$p_\\alpha(x_j) = (\\gamma - 1)(E_\\alpha(x_j) - \\frac{1}{2}m_\\alpha(x_j)^2/\\rho_\\alpha(x_j))$。\n    次要约束涉及一个离散动能泛函 $K[U] = \\frac{1}{4}\\int_{-1}^1 \\frac{m(x)^2}{\\rho(x)} dx$，它不应显著增加：$K[U_\\alpha] \\le K[U_{\\mathrm{DG}}] + \\varepsilon_{\\mathrm{KE}}$。\n    问题陈述为确定 $\\alpha$ 提供了一套具体但可能存在矛盾的指令。实现部分最直接的指令是优先考虑正性约束。它指出要找到满足正性条件的最大 $\\alpha \\in [0,1]$，并为可能违反动能约束的情况提供了一个规则。这表明 $\\alpha$ 的最终选择仅由正性约束决定。我们遵循这一具体指令。\n    我们使用二分搜索法找到 $\\alpha_{\\mathrm{pos,max}}$，即在 $[0,1]$ 中使所有子单元中心都满足正性约束的最大值。这依赖于单调可行性的假设：如果一个值 $\\alpha^*$ 可行，那么任何 $\\alpha  \\alpha^*$ 也可行。二分搜索从区间 $[0,1]$ 开始，并迭代地缩小它，以找到可行与不可行区域的边界。最终的限制器参数被设置为 $\\alpha = \\alpha_{\\mathrm{pos,max}}$。\n\n4.  **度量标准计算**：一旦确定了最终的 $\\alpha$，我们使用四个度量标准来量化限制器的性能：\n    -   限制器参数的最终值 $\\alpha$。\n    -   动能的变化 $\\Delta K = K[U_\\alpha] - K[U_{\\mathrm{DG}}]$。这通过对两项进行数值求积来计算。\n    -   速度总变差 (TV) 的减小量 $\\Delta \\mathrm{TV} = \\mathrm{TV}(u_{\\mathrm{DG}}) - \\mathrm{TV}(u_\\alpha)$，其中 $\\mathrm{TV}(u) = \\sum_{j=1}^{M-1} |u(x_{j+1}) - u(x_j)|$ 在子单元中心进行评估。正的 $\\Delta \\mathrm{TV}$ 表示限制器减少了振荡。\n    -   满足正性的子单元比例 $\\phi = \\frac{1}{M}\\sum_{j=1}^M \\mathbf{1}(\\rho_\\alpha(x_j) \\ge \\rho_{\\min} \\wedge p_\\alpha(x_j) \\ge p_{\\min})$。$\\phi=1.0$ 的值表示限制器成功地在所有地方强制执行了正性。\n\n实现过程将这些步骤封装在一个函数中，该函数处理每个测试用例并计算所需的度量标准，然后将其格式化为指定的输出字符串。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre\n\n# Constants from the problem statement\nP_MIN = 1e-8\nRHO_MIN = 1e-8\nEPS_KE = 1e-12\nQUADRATURE_POINTS = 32\nBISECTION_ITERATIONS = 100\n\ndef legendre_poly_eval(coeffs, x):\n    \"\"\"Evaluates a Legendre series at point(s) x.\"\"\"\n    n_coeffs = len(coeffs)\n    # The 'coeffs' array has a_k at index k. eval_legendre needs a list where\n    # the k-th element is P_k.\n    # We can do this by summing up coeffs[k] * P_k(x)\n    y = np.zeros_like(x, dtype=float)\n    for k in range(n_coeffs):\n        if coeffs[k] != 0:\n            y += coeffs[k] * eval_legendre(k, x)\n    return y\n\nclass DGState:\n    \"\"\"Represents the state within a DG element.\"\"\"\n    def __init__(self, N, M, gamma, s0, a, b, c):\n        self.N, self.M, self.gamma, self.s0 = N, M, gamma, s0\n        self.a, self.b, self.c = np.array(a), np.array(b), np.array(c)\n\n        # Quadrature setup for integrals over [-1, 1]\n        self.quad_pts, self.quad_w = np.polynomial.legendre.leggauss(QUADRATURE_POINTS)\n        \n        # Subcell centers\n        self.subcell_centers = -1.0 + (np.arange(1, M + 1) - 0.5) * (2.0 / M)\n\n        # DG state evaluation functions\n        self.rho_dg_func = lambda x: legendre_poly_eval(self.a, x)\n        self.u_dg_func = lambda x: legendre_poly_eval(self.b, x)\n        self.p_dg_func = lambda x: legendre_poly_eval(self.c, x)\n\n        self.m_dg_func = lambda x: self.rho_dg_func(x) * self.u_dg_func(x)\n        self.e_dg_func = lambda x: self.p_dg_func(x) / (self.gamma - 1.0) + 0.5 * self.rho_dg_func(x) * self.u_dg_func(x)**2\n\n        # Cell average state\n        self.rho_bar = self.a[0]\n        self.m_bar = 0.5 * np.sum(self.quad_w * self.m_dg_func(self.quad_pts))\n        self.e_bar = 0.5 * np.sum(self.quad_w * self.e_dg_func(self.quad_pts))\n\n    def is_troubled(self):\n        \"\"\"Checks if the cell is troubled.\"\"\"\n        if self.N == 0:\n            return False\n        if len(self.c) = self.N or sum(ci**2 for ci in self.c) == 0:\n            return False\n        \n        c_N_sq = self.c[self.N]**2\n        sum_ck_sq = np.sum(self.c**2)\n        if sum_ck_sq == 0:\n            return False\n        \n        R = c_N_sq / sum_ck_sq\n        threshold = self.s0 * self.N**(-4)\n        return R > threshold\n\n    def get_limited_state(self, x, alpha):\n        \"\"\"Computes the limited state U_alpha at point(s) x.\"\"\"\n        rho_limited = (1 - alpha) * self.rho_bar + alpha * self.rho_dg_func(x)\n        m_limited = (1 - alpha) * self.m_bar + alpha * self.m_dg_func(x)\n        e_limited = (1 - alpha) * self.e_bar + alpha * self.e_dg_func(x)\n        return rho_limited, m_limited, e_limited\n\n    def check_positivity(self, alpha):\n        \"\"\"Checks if positivity constraints are met for a given alpha.\"\"\"\n        rho_a, m_a, e_a = self.get_limited_state(self.subcell_centers, alpha)\n        \n        if np.any(rho_a  RHO_MIN):\n            return False\n\n        # Avoid division by zero\n        internal_energy_density = e_a - 0.5 * m_a**2 / rho_a\n        p_a = (self.gamma - 1.0) * internal_energy_density\n        \n        if np.any(p_a  P_MIN):\n            return False\n            \n        return True\n\n    def find_alpha_pos_max(self):\n        \"\"\"Finds max alpha satisfying positivity using bisection.\"\"\"\n        low, high = 0.0, 1.0\n        \n        # The average state itself might not be positive\n        if not self.check_positivity(0.0):\n            return 0.0\n\n        for _ in range(BISECTION_ITERATIONS):\n            mid = (low + high) / 2.0\n            if self.check_positivity(mid):\n                low = mid\n            else:\n                high = mid\n        return low\n\n    def compute_K(self, alpha):\n        \"\"\"Computes the kinetic energy functional K[U_alpha].\"\"\"\n        rho_a, m_a, _ = self.get_limited_state(self.quad_pts, alpha)\n        \n        # Avoid division by zero if density is negative\n        integrand = np.zeros_like(rho_a)\n        positive_rho_mask = rho_a > 0\n        integrand[positive_rho_mask] = m_a[positive_rho_mask]**2 / rho_a[positive_rho_mask]\n        \n        integral = np.sum(self.quad_w * integrand)\n        return 0.5 * 0.5 * integral\n    \n    def compute_TV(self, alpha):\n        \"\"\"Computes the total variation of velocity TV(u_alpha).\"\"\"\n        rho_a, m_a, _ = self.get_limited_state(self.subcell_centers, alpha)\n        \n        # Avoid division by zero\n        u_a = np.zeros_like(rho_a)\n        positive_rho_mask = rho_a > 0\n        u_a[positive_rho_mask] = m_a[positive_rho_mask] / rho_a[positive_rho_mask]\n\n        return np.sum(np.abs(np.diff(u_a)))\n\n    def get_positivity_fraction(self, alpha):\n        \"\"\"Computes the fraction of subcells with positive state.\"\"\"\n        rho_a, m_a, e_a = self.get_limited_state(self.subcell_centers, alpha)\n        \n        positive_rho = rho_a >= RHO_MIN\n        \n        p_a = np.full_like(rho_a, -1.0) # Assume negative pressure initially\n        valid_rho_mask = rho_a > 0\n        internal_energy_density = e_a[valid_rho_mask] - 0.5 * m_a[valid_rho_mask]**2 / rho_a[valid_rho_mask]\n        p_a[valid_rho_mask] = (self.gamma - 1.0) * internal_energy_density\n        \n        positive_p = p_a >= P_MIN\n\n        return np.mean(positive_rho  positive_p)\n\n\ndef solve_case(params):\n    \"\"\"Solves a single test case.\"\"\"\n    N, M, gamma, s0, a, b, c = params\n    state = DGState(N, M, gamma, s0, a, b, c)\n\n    if not state.is_troubled():\n        alpha = 1.0\n    else:\n        alpha = state.find_alpha_pos_max()\n    \n    # Calculate metrics with final alpha\n    K_dg = state.compute_K(1.0)\n    K_alpha = state.compute_K(alpha)\n    delta_K = K_alpha - K_dg\n\n    TV_dg = state.compute_TV(1.0)\n    TV_alpha = state.compute_TV(alpha)\n    delta_TV = TV_dg - TV_alpha\n    \n    phi = state.get_positivity_fraction(alpha)\n\n    return [alpha, delta_K, delta_TV, phi]\n\ndef solve():\n    test_cases = [\n        (3, 8, 1.4, 1e-6, [1.0, 0.05, -0.02, 0.0], [0.2, -0.03, 0.01, 0.0], [1.0, 0.04, -0.01, 0.0]),\n        (3, 16, 1.4, 1e-4, [1.0, 0.2, -0.25, 0.1], [0.5, -0.7, 0.2, -0.05], [0.8, -0.9, 0.3, -0.1]),\n        (4, 12, 1.4, 1e-4, [0.22, -0.21, 0.08, -0.02, 0.0], [0.1, 0.2, -0.15, 0.05, -0.01], [0.25, 0.02, -0.03, 0.01, 0.0]),\n        (3, 10, 1.4, 1e-12, [1.0, -0.3, 0.2, -0.05], [0.9, 0.4, -0.3, 0.1], [1.2, 0.1, -0.08, 0.02])\n    ]\n\n    results = [solve_case(case) for case in test_cases]\n    \n    # Format the final output string\n    result_str = ','.join([f\"[{','.join(f'{v:.7e}' for v in r)}]\" for r in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}