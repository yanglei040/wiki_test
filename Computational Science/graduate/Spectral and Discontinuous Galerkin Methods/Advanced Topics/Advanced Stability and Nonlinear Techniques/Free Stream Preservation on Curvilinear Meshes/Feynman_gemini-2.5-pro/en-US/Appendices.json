{
    "hands_on_practices": [
        {
            "introduction": "The foundation of free-stream preservation on curvilinear meshes lies in satisfying a discrete version of the geometric conservation law (GCL). This practice guides you through the numerical verification of this principle on a single element . You will implement the Vinokur discrete metric definition and confirm that when the same Summation-By-Parts (SBP) differentiation operator is used in each coordinate direction, the discrete divergence of the metric terms vanishes, ensuring that the scheme can perfectly preserve a constant flow.",
            "id": "3388173",
            "problem": "Construct a self-contained program that, on a single reference quadrilateral, implements the Vinokur discrete metric definition for a curvilinear mapping and verifies the Summation-By-Parts (SBP)-compatible discrete metric identity that guarantees free stream preservation when the same tensor-product SBP operator is used in each coordinate direction. Work entirely in two spatial dimensions. Let the reference element be $[-1,1]^2$ with computational coordinates $(\\xi,\\eta) \\in [-1,1]^2$ and a smooth mapping $(x(\\xi,\\eta),y(\\xi,\\eta))$ onto the physical space. Use a nodal Spectral Collocation Summation-By-Parts (SBP) operator built from Gauss–Lobatto–Legendre (GLL) nodes of polynomial degree $p$ per coordinate with the canonical diagonal SBP norm. The $1$-dimensional nodes must include the endpoints and the differentiation matrix must be the standard barycentric Lagrange differentiation matrix on those nodes. The two-dimensional operators are formed by tensor products.\n\nDefinitions to implement:\n- The one-dimensional SBP differentiation matrix $D \\in \\mathbb{R}^{(p+1)\\times(p+1)}$ on GLL nodes must be constructed using barycentric weights on those nodes. The two-dimensional operators on the tensor grid are $D_\\xi = D \\otimes I$ and $D_\\eta = I \\otimes D$, where $I$ is the identity matrix of size $p+1$ and $\\otimes$ denotes the Kronecker product.\n- Using the same SBP operator in both directions, define the Vinokur discrete metric components on the nodal grid by\n  $G_{11} = y_\\eta$, $G_{21} = -x_\\eta$, $G_{12} = -y_\\xi$, and $G_{22} = x_\\xi$,\n  where subscripts denote discrete derivatives taken with $D_\\xi$ and $D_\\eta$ through the tensor-product action.\n- The SBP-compatible discrete metric identity to verify is that the discrete divergence of each contravariant column vanishes:\n  $r_x = D_\\xi G_{11} + D_\\eta G_{12}$ and $r_y = D_\\xi G_{21} + D_\\eta G_{22}$,\n  which should evaluate to the zero vector (up to floating-point rounding) if the same SBP operator is used consistently in both directions.\n\nYou must:\n- Construct the one-dimensional Gauss–Lobatto–Legendre (GLL) nodes and weights for a given integer polynomial degree $p \\ge 1$ using Newton iterations to find the zeros of $P_p'(\\xi)$, where $P_p$ is the Legendre polynomial of degree $p$. Construct the barycentric Lagrange differentiation matrix $D$ on these nodes.\n- Build the two-dimensional tensor grid and apply the discrete derivatives by matrix multiplication along each coordinate direction.\n- Implement two mapping families for $(x(\\xi,\\eta),y(\\xi,\\eta))$:\n  1. A sinusoidal curvilinear mapping parametrized by scalars $a$ and $b$:\n     $x(\\xi,\\eta) = \\xi + a \\sin(\\pi \\xi)\\sin(\\pi \\eta)$ and $y(\\xi,\\eta) = \\eta + b \\cos(\\pi \\xi)\\sin(\\pi \\eta)$, where angles are in radians.\n  2. A linear affine mapping with matrix $A \\in \\mathbb{R}^{2\\times 2}$ and zero translation: $$\\begin{bmatrix} x \\\\ y \\end{bmatrix} = A \\begin{bmatrix} \\xi \\\\ \\eta \\end{bmatrix}.$$\n\nFor each test case below, compute the maximum-infinity-norm residual\n$r_{\\max} = \\max(\\|r_x\\|_\\infty, \\|r_y\\|_\\infty)$\nand report it as a floating-point number.\n\nTest suite:\n- Test $1$ (happy path): $p = 5$, sinusoidal mapping with $a = 0.2$ and $b = -0.1$.\n- Test $2$ (boundary degree): $p = 1$, sinusoidal mapping with $a = 0.7$ and $b = 0.3$.\n- Test $3$ (strong curvature): $p = 8$, sinusoidal mapping with $a = 0.9$ and $b = 0.7$.\n- Test $4$ (affine linear map): $p = 3$, affine mapping with $$A = \\begin{bmatrix} 1.2 & -0.3 \\\\ 0.5 & 0.8 \\end{bmatrix}.$$\n\nFinal output format:\nYour program should produce a single line of output containing the values of $r_{\\max}$ for Tests $1$ through $4$ in order, as a comma-separated list enclosed in square brackets. For example, it should look like \"[v1,v2,v3,v4]\". Angles must be in radians, and there are no physical units. The reported values must be floating-point numbers.",
            "solution": "The user-provided problem is valid. It is scientifically grounded in the field of numerical methods for partial differential equations, specifically concerning high-order spectral and discontinuous Galerkin methods. The problem is well-posed, objective, and contains all necessary information for a unique solution. The core of the problem is to numerically verify the discrete geometric conservation law, also known as the free stream preservation property, which relies on the commutation of discrete differentiation operators on a tensor-product grid.\n\nThe analytical basis for this property is Clairaut's theorem on the equality of mixed partial derivatives, i.e., $$\\frac{\\partial^2 f}{\\partial\\xi\\partial\\eta} = \\frac{\\partial^2 f}{\\partial\\eta\\partial\\xi}.$$ The problem asks to verify the discrete analogue of this theorem for specific operators. The discrete operators for partial differentiation with respect to the computational coordinates $\\xi$ and $\\eta$ are given as Kronecker products of a one-dimensional differentiation matrix $D$ and an identity matrix $I$: $D_\\xi = D \\otimes I$ and $D_\\eta = I \\otimes D$. The commutativity property follows directly from the properties of the Kronecker product:\n$$\nD_\\xi D_\\eta = (D \\otimes I)(I \\otimes D) = (D \\cdot I) \\otimes (I \\cdot D) = D \\otimes D\n$$\n$$\nD_\\eta D_\\xi = (I \\otimes D)(D \\otimes I) = (I \\cdot D) \\otimes (D \\cdot I) = D \\otimes D\n$$\nThus, $D_\\xi D_\\eta = D_\\eta D_\\xi$, which implies $(D_\\xi D_\\eta - D_\\eta D_\\xi) = 0$.\n\nThe Vinokur discrete metric components are defined as:\n$G_{11} = y_\\eta = D_\\eta y$\n$G_{12} = -y_\\xi = -D_\\xi y$\n$G_{21} = -x_\\eta = -D_\\eta x$\n$G_{22} = x_\\xi = D_\\xi x$\n\nThe discrete metric identities to be verified are the residuals $r_x$ and $r_y$:\n$$\nr_x = D_\\xi G_{11} + D_\\eta G_{12} = D_\\xi (D_\\eta y) + D_\\eta (-D_\\xi y) = (D_\\xi D_\\eta - D_\\eta D_\\xi) y\n$$\n$$\nr_y = D_\\xi G_{21} + D_\\eta G_{22} = D_\\xi (-D_\\eta x) + D_\\eta (D_\\xi x) = (-D_\\xi D_\\eta + D_\\eta D_\\xi) x\n$$\nSince the operators commute, both $r_x$ and $r_y$ should be analytically zero. The numerical implementation will yield values that are close to zero, limited by floating-point precision. The goal is to implement the necessary components and compute the maximum-infinity-norm of these residuals.\n\nThe implementation steps are as follows:\n1.  **Gauss–Lobatto–Legendre (GLL) Nodes**: For a given polynomial degree $p$, the $p+1$ GLL nodes are computed. These are the endpoints $[-1, 1]$ and the $p-1$ roots of the first derivative of the Legendre polynomial of degree $p$, $P_p'(\\xi)$. These roots are found numerically using Newton's method, which requires computing $P_p'(\\xi)$ and $P_p''(\\xi)$. These polynomial values and their derivatives are obtained through standard recurrence relations.\n\n2.  **Barycentric Differentiation Matrix**: On the set of $p+1$ GLL nodes, the differentiation matrix $D$ is constructed. The entries of this matrix are determined by the barycentric interpolation formula, which provides a numerically stable way to compute the derivative of the Lagrange interpolating polynomial at the nodes.\n\n3.  **Tensor-Product Grid and Operators**: A two-dimensional tensor-product grid is formed from the one-dimensional GLL nodes. The physical coordinates $(x, y)$ of the grid points are calculated using the specified curvilinear or affine mappings. The function values on this grid are stored in a one-dimensional array (vector) using a column-major flattening scheme. This storage convention is crucial for the correct application of the $2D$ differentiation operators $D_\\xi = D \\otimes I$ and $D_\\eta = I \\otimes D$, constructed via the Kronecker product.\n\n4.  **Verification**: The discrete metric components are computed by applying $D_\\xi$ and $D_\\eta$ to the flattened vectors of physical coordinates. The residuals $r_x$ and $r_y$ are then calculated. Finally, the maximum-infinity-norm, $r_{\\max} = \\max(\\|r_x\\|_\\infty, \\|r_y\\|_\\infty)$, is determined for each test case specified in the problem. The expected result for $r_{\\max}$ is a small number on the order of machine epsilon, confirming the free stream preservation property for the implemented scheme.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs discrete operators and verifies the free stream preservation\n    metric identity for various curvilinear mappings and polynomial degrees.\n    \"\"\"\n\n    def get_legendre_poly_and_derivs(degree, x):\n        \"\"\"\n        Computes P_d(x), P'_d(x), and P''_d(x) for a given degree d.\n        Uses stable recurrence relations.\n        \"\"\"\n        if degree == 0:\n            return 1.0, 0.0, 0.0\n\n        p_k_minus_1 = 1.0  # P_0(x)\n        p_k = x          # P_1(x)\n\n        for k in range(1, degree):\n            p_k_plus_1 = ((2.0 * k + 1.0) * x * p_k - k * p_k_minus_1) / (k + 1.0)\n            p_k_minus_1 = p_k\n            p_k = p_k_plus_1\n        \n        # p_k is P_d(x), p_k_minus_1 is P_{d-1}(x)\n\n        if abs(1.0 - x**2) < 1e-14:\n            pd_k = 0.5 * degree * (degree + 1.0)\n            if x < 0:\n                pd_k *= (-1.0)**(degree + 1.0)\n            \n            pdd_k = (degree * (degree + 1.0) - 2.0) * pd_k / 4.0\n            if x < 0:\n               pdd_k *= -1.0 # Sign follows from P'_d parity\n        else:\n            pd_k = degree * (p_k_minus_1 - x * p_k) / (1.0 - x**2)\n            pdd_k = (2.0 * x * pd_k - degree * (degree + 1.0) * p_k) / (1.0 - x**2)\n            \n        return p_k, pd_k, pdd_k\n\n    def get_gll_nodes(p):\n        \"\"\"\n        Computes the (p+1) GLL nodes, which are the roots of (1-x^2)P'_p(x).\n        \"\"\"\n        if p == 0:\n            return np.array([0.0])\n        if p == 1:\n            return np.array([-1.0, 1.0])\n        \n        nodes = np.zeros(p + 1)\n        nodes[0], nodes[-1] = -1.0, 1.0\n        \n        initial_guesses = np.cos(np.arange(1, p) * np.pi / p)\n\n        for i, x0 in enumerate(initial_guesses):\n            x = x0\n            for _ in range(10): # Newton's method for roots of P'_p(x)\n                _, p_prime, p_second_prime = get_legendre_poly_and_derivs(p, x)\n                \n                if abs(p_second_prime) < 1e-14: break\n                \n                delta = p_prime / p_second_prime\n                x -= delta\n                \n                if abs(delta) < 1e-15: break\n            nodes[i + 1] = x\n        \n        nodes.sort()\n        return nodes\n\n    def get_barycentric_diff_matrix(nodes):\n        \"\"\"\n        Constructs the differentiation matrix D for a given set of nodes.\n        \"\"\"\n        n_pts = len(nodes)\n        D = np.zeros((n_pts, n_pts))\n        \n        weights = np.ones(n_pts)\n        for j in range(n_pts):\n            for k in range(n_pts):\n                if j != k:\n                    weights[j] *= (nodes[j] - nodes[k])\n        weights = 1.0 / weights\n        \n        for i in range(n_pts):\n            for j in range(n_pts):\n                if i != j:\n                    D[i, j] = (weights[j] / weights[i]) / (nodes[i] - nodes[j])\n\n        for i in range(n_pts):\n            D[i, i] = -np.sum(D[i, :])\n            \n        return D\n    \n    test_cases = [\n        {'p': 5, 'type': 'sinusoidal', 'params': {'a': 0.2, 'b': -0.1}},\n        {'p': 1, 'type': 'sinusoidal', 'params': {'a': 0.7, 'b': 0.3}},\n        {'p': 8, 'type': 'sinusoidal', 'params': {'a': 0.9, 'b': 0.7}},\n        {'p': 3, 'type': 'affine', 'params': {'A': np.array([[1.2, -0.3], [0.5, 0.8]])}},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        p = case['p']\n        n_pts = p + 1\n        \n        # 1. 1D operators and nodes\n        xi_1d = get_gll_nodes(p)\n        D = get_barycentric_diff_matrix(xi_1d)\n        \n        # 2. 2D tensor-product setup\n        I = np.identity(n_pts)\n        D_xi = np.kron(D, I)\n        D_eta = np.kron(I, D)\n        \n        # Grid and mapping\n        # `indexing='xy'` with `flatten('F')` creates a data layout where\n        # eta is the fast index and xi is the slow index. This is consistent\n        # with the problem's Kronecker product definitions.\n        xi_grid, eta_grid = np.meshgrid(xi_1d, xi_1d, indexing='xy')\n        xi_flat = xi_grid.flatten('F')\n        eta_flat = eta_grid.flatten('F')\n        \n        if case['type'] == 'sinusoidal':\n            a = case['params']['a']\n            b = case['params']['b']\n            x_flat = xi_flat + a * np.sin(np.pi * xi_flat) * np.sin(np.pi * eta_flat)\n            y_flat = eta_flat + b * np.cos(np.pi * xi_flat) * np.sin(np.pi * eta_flat)\n        elif case['type'] == 'affine':\n            A = case['params']['A']\n            x_flat = A[0, 0] * xi_flat + A[0, 1] * eta_flat\n            y_flat = A[1, 0] * xi_flat + A[1, 1] * eta_flat\n        \n        # Discrete derivatives of coordinates\n        x_xi = D_xi @ x_flat\n        y_xi = D_xi @ y_flat\n        x_eta = D_eta @ x_flat\n        y_eta = D_eta @ y_flat\n        \n        # Vinokur discrete metric components\n        G11 = y_eta\n        G21 = -x_eta\n        G12 = -y_xi\n        G22 = x_xi\n        \n        # Residuals of metric identities\n        rx = D_xi @ G11 + D_eta @ G12\n        ry = D_xi @ G21 + D_eta @ G22\n        \n        # Maximum-infinity-norm residual\n        r_max = max(np.max(np.abs(rx)), np.max(np.abs(ry)))\n        results.append(r_max)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While the geometric conservation law addresses the interior of an element, free-stream preservation for Discontinuous Galerkin (DG) methods also critically depends on the treatment of boundary fluxes. This exercise explores how the computation of face normal vectors impacts the overall conservation property . By comparing normals derived from the exact analytical mapping against those from a consistent polynomial approximation of the face geometry, you will discover why the latter is essential for achieving a discretely conservative scheme that robustly preserves constant states.",
            "id": "3388203",
            "problem": "Consider a two-dimensional linear advection equation on a single curvilinear quadrilateral element, discretized by a high-order Discontinuous Galerkin (DG) method with Legendre–Gauss–Lobatto (LGL) nodes. The governing partial differential equation is $u_t + \\mathbf{a}\\cdot\\nabla u = 0$, where $\\mathbf{a}\\in\\mathbb{R}^2$ is a constant advection velocity. For a constant free stream $u(x,y,t)\\equiv u_0$, Free Stream Preservation (FSP) requires the semi-discrete DG residual to be identically zero when geometry-induced metric terms and numerical fluxes are treated consistently.\n\nDefine the curvilinear mapping from the reference square $(\\xi,\\eta)\\in[-1,1]^2$ to physical coordinates $(x,y)$ by\n$$x(\\xi,\\eta) = \\xi + \\alpha_c\\,\\xi\\eta + \\alpha_s \\sin(\\pi \\xi),\\qquad y(\\xi,\\eta) = \\eta + \\beta_q\\,\\xi^2 + \\beta_s \\sin(\\pi \\eta),$$\nwith parameters $\\alpha_c,\\alpha_s,\\beta_q,\\beta_s\\in\\mathbb{R}$ chosen sufficiently small so that the mapping remains one-to-one. Let the constant advection vector be $\\mathbf{a}=(a_x,a_y)$ and the constant free stream be $u_0$.\n\nFor a single element, using an upwind numerical flux for the linear advection equation and a constant state $u_0$ yields a face contribution $\\hat{f} = u_0\\,\\mathbf{a}\\cdot \\mathbf{n}$ at every face point, where $\\mathbf{n}$ is the outward unit normal and $ds$ is the face line element. Thus, the semi-discrete DG residual on the element reduces to the boundary integral\n$$R = u_0 \\oint_{\\partial \\Omega_e} \\mathbf{a}\\cdot \\mathbf{n}\\,ds.$$\nBy the divergence theorem and since $\\nabla\\cdot\\mathbf{a} = 0$ for constant $\\mathbf{a}$, the continuous residual equals $R=0$. However, the discrete counterpart depends on how $\\mathbf{n}\\,ds$ is computed at the quadrature nodes.\n\nYou must compare two face-normal computations:\n- Exact geometry normals: compute the tangent vector $\\mathbf{t}$ on each face using the exact parametric derivatives of $\\mathbf{X}(\\xi,\\eta)=(x(\\xi,\\eta),y(\\xi,\\eta))$; then use the identity $\\mathbf{n}\\,ds = \\mathcal{R}_{-90}(\\mathbf{t})\\,d\\lambda$, where $\\mathcal{R}_{-90}([t_x,t_y])=[t_y,-t_x]$ and $d\\lambda$ is the reference face parameter differential, and approximate the integral using LGL quadrature.\n- Polynomial approximations: along each face, interpolate the physical coordinates $\\mathbf{X}$ at $N$ LGL nodes by a polynomial of degree $N-1$ in the face parameter, differentiate that polynomial using the barycentric differentiation matrix to obtain a polynomial approximation of the tangent $\\mathbf{t}$ at the nodes, form $\\mathbf{n}\\,ds$ via $\\mathcal{R}_{-90}$, and approximate the integral using LGL quadrature.\n\nImplement both computations and evaluate FSP numerically as a boolean condition $|R|\\le \\varepsilon$, with a specified tolerance $\\varepsilon$. Use the following analytic derivatives of the mapping:\n$$\\frac{\\partial x}{\\partial \\xi} = 1 + \\alpha_c\\,\\eta + \\alpha_s \\pi \\cos(\\pi \\xi),\\quad \\frac{\\partial x}{\\partial \\eta} = \\alpha_c\\,\\xi,$$\n$$\\frac{\\partial y}{\\partial \\xi} = 2\\beta_q\\,\\xi,\\quad \\frac{\\partial y}{\\partial \\eta} = 1 + \\beta_s \\pi \\cos(\\pi \\eta).$$\nTraverse the element boundary counterclockwise. For the bottom face use $\\eta=-1$ and increase $\\xi$; for the right face use $\\xi=+1$ and increase $\\eta$; for the top face use $\\eta=+1$ and decrease $\\xi$; for the left face use $\\xi=-1$ and decrease $\\eta$. At each LGL node $s\\in[-1,1]$ along a face, the outward normal-times-measure vector is $\\mathbf{n}\\,ds = \\mathcal{R}_{-90}(\\mathbf{t}(s))\\,ds$, and the quadrature approximates $\\int_{-1}^{1}$ by $\\sum_{i=1}^N w_i(\\cdot)$.\n\nYour program must:\n- Construct Legendre–Gauss–Lobatto nodes and weights with $N$ points per face; the weights must satisfy the LGL formula for integrating polynomials up to degree $2N-3$.\n- Construct the barycentric differentiation matrix on the LGL nodes to differentiate the face-interpolated polynomial for the polynomial-normal method.\n- For each test case below, compute the two boolean outcomes indicating whether FSP holds (i.e., $|R|\\le \\varepsilon$) for the exact-normal method and the polynomial-normal method, respectively.\n\nUse the following test suite of parameter values spanning a typical case, a boundary condition, and edge cases:\n- Case $1$: $N=5$, $\\alpha_c=0.3$, $\\alpha_s=0.2$, $\\beta_q=0.1$, $\\beta_s=0.2$, $\\mathbf{a}=(1.0,0.3)$, $u_0=1$, $\\varepsilon=10^{-10}$.\n- Case $2$: $N=3$, $\\alpha_c=0$, $\\alpha_s=0$, $\\beta_q=0$, $\\beta_s=0$, $\\mathbf{a}=(0.7,-0.4)$, $u_0=1$, $\\varepsilon=10^{-12}$.\n- Case $3$: $N=5$, $\\alpha_c=0.5$, $\\alpha_s=0.5$, $\\beta_q=0.3$, $\\beta_s=0.5$, $\\mathbf{a}=(1.0,1.0)$, $u_0=1$, $\\varepsilon=10^{-10}$.\n- Case $4$: $N=4$, $\\alpha_c=0.3$, $\\alpha_s=0.4$, $\\beta_q=0.0$, $\\beta_s=0.6$, $\\mathbf{a}=(0.0,1.0)$, $u_0=1$, $\\varepsilon=10^{-10}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$), where the results are ordered as pairs per case: first the boolean for the exact-normal method, then the boolean for the polynomial-normal method. No physical units are involved, and angles are understood as dimensionless arguments to trigonometric functions. The final outputs must be booleans.",
            "solution": "We start from the two-dimensional linear advection equation $u_t + \\mathbf{a}\\cdot\\nabla u = 0$, where $\\mathbf{a}=(a_x,a_y)$ is a constant vector. In a conservative formulation, the flux is $\\mathbf{f}(u) = u\\,\\mathbf{a}$, and a Discontinuous Galerkin (DG) discretization on a single curved element with upwind numerical flux uses the boundary integral of the numerical flux $\\hat{f}$. For a constant free stream $u(x,y,t)\\equiv u_0$, the upwind flux value coincides from both sides of a face, yielding $\\hat{f}=u_0\\,\\mathbf{a}\\cdot \\mathbf{n}$, where $\\mathbf{n}$ is the outward unit normal vector and $ds$ is the face line element. Therefore, the semi-discrete DG residual simplifies to\n$$R = u_0 \\oint_{\\partial \\Omega_e} \\mathbf{a}\\cdot \\mathbf{n}\\,ds.$$\nBy the divergence theorem, $$\\oint_{\\partial \\Omega_e} \\mathbf{a}\\cdot \\mathbf{n}\\,ds = \\iint_{\\Omega_e} \\nabla\\cdot\\mathbf{a}\\,dA,$$ and since $\\nabla\\cdot\\mathbf{a}=0$ for constant $\\mathbf{a}$, the continuous residual satisfies $R=0$. Free Stream Preservation (FSP) in the semi-discrete setting requires that the discretization, including geometry and quadrature, reproduces $R=0$ when $u=u_0$ is constant.\n\nTo evaluate $R$ numerically, we parametrize each face by a reference coordinate $s\\in[-1,1]$ and traverse the boundary counterclockwise. Let $\\mathbf{X}(\\xi,\\eta)=[x(\\xi,\\eta),y(\\xi,\\eta)]$ be the physical mapping from reference coordinates $(\\xi,\\eta)$, with\n$$x(\\xi,\\eta)=\\xi+\\alpha_c\\,\\xi\\eta+\\alpha_s\\sin(\\pi\\xi),\\qquad y(\\xi,\\eta)=\\eta+\\beta_q\\,\\xi^2+\\beta_s\\sin(\\pi\\eta).$$\nWe use the analytic mapping derivatives\n$$\\frac{\\partial x}{\\partial \\xi} = 1 + \\alpha_c\\,\\eta + \\alpha_s \\pi \\cos(\\pi \\xi),\\quad \\frac{\\partial x}{\\partial \\eta} = \\alpha_c\\,\\xi,$$\n$$\\frac{\\partial y}{\\partial \\xi} = 2\\beta_q\\,\\xi,\\quad \\frac{\\partial y}{\\partial \\eta} = 1 + \\beta_s \\pi \\cos(\\pi \\eta).$$\nOn a face, the tangent vector $\\mathbf{t}$ equals either $\\partial\\mathbf{X}/\\partial \\xi$ (when the face is parametrized by $\\xi$) or $\\partial\\mathbf{X}/\\partial \\eta$ (when parametrized by $\\eta$). The outward normal-times-measure vector $\\mathbf{n}\\,ds$ is obtained by rotating the tangent $-90^\\circ$: $\\mathbf{n}\\,ds = \\mathcal{R}_{-90}(\\mathbf{t})\\,d\\lambda$, with $\\mathcal{R}_{-90}([t_x,t_y])=[t_y,-t_x]$, and $d\\lambda$ is the reference line differential (which we absorb in the LGL quadrature weights). The boundary integral becomes\n$$R \\approx u_0 \\sum_{\\text{faces}} \\sum_{i=1}^{N} w_i \\left( \\mathbf{a}\\cdot \\mathcal{R}_{-90}(\\mathbf{t}(s_i)) \\right)\\sigma_{\\text{face}},$$\nwhere $s_i$ and $w_i$ are the LGL nodes and weights on $[-1,1]$, $N$ is the number of quadrature nodes per face, and $\\sigma_{\\text{face}}\\in\\{+1,-1\\}$ encodes the orientation (bottom and right faces use $+1$; top and left use $-1$ to achieve counterclockwise traversal consistently).\n\nWe compare two ways to compute $\\mathbf{t}(s_i)$ and thus $\\mathbf{n}\\,ds$:\n\n1. Exact geometry normals: Compute $\\mathbf{t}$ using the analytic derivatives of $\\mathbf{X}$ at the face points, then form $\\mathbf{n}\\,ds = \\mathcal{R}_{-90}(\\mathbf{t})$, and evaluate the LGL quadrature. Because the mapping involves non-polynomial terms $\\sin(\\pi\\xi)$ and $\\sin(\\pi\\eta)$, the integrand on a given face is a smooth non-polynomial function of the face parameter $s$. LGL quadrature is exact only for polynomials up to degree $2N-3$, so the discrete integral generally exhibits a nonzero aliasing error even though the exact continuous integral is zero. Therefore, the discrete residual may not vanish, potentially violating FSP.\n\n2. Polynomial approximations for curved faces: On each face, interpolate the physical coordinates $\\mathbf{X}$ at $N$ LGL nodes by a polynomial of degree $N-1$ in the face parameter $s$. Let this interpolant be $\\mathbf{X}_{\\text{poly}}(s)$, and compute the tangent $\\mathbf{t}_{\\text{poly}}(s_i)$ by differentiating the interpolant using the barycentric differentiation matrix constructed on the same LGL nodes. Then form $\\mathbf{n}\\,ds$ via $\\mathcal{R}_{-90}(\\mathbf{t}_{\\text{poly}})$ and evaluate the LGL quadrature. A key property is that integrating the derivative of a polynomial interpolant using LGL quadrature yields the exact endpoint difference for each face. Specifically, for each face,\n$$\\sum_{i=1}^{N} w_i \\,\\mathbf{t}_{\\text{poly}}(s_i) = \\mathbf{X}_{\\text{poly}}(1) - \\mathbf{X}_{\\text{poly}}(-1),$$\ncomponentwise, because $\\mathbf{t}_{\\text{poly}}$ has degree at most $N-2$, which is within the exactness range of LGL quadrature. Summing these contributions around the closed boundary telescopes: the endpoint contributions cancel at the shared corners under a counterclockwise traversal. Consequently,\n$$\\sum_{\\text{faces}} \\sum_{i=1}^{N} w_i \\,\\mathcal{R}_{-90}(\\mathbf{t}_{\\text{poly}}(s_i))\\,\\sigma_{\\text{face}} = \\mathbf{0},$$\nand hence the discrete residual $R$ vanishes exactly up to floating-point roundoff. This is an instance of the discrete Geometric Conservation Law (GCL), which ensures metric consistency and thus Free Stream Preservation (FSP) for constant states.\n\nAlgorithmic steps implemented in the program:\n- Construct $N$ LGL nodes $s_i$ and weights $w_i$ on $[-1,1]$ using the derivative roots of the Legendre polynomial of degree $N-1$ and the standard weight formula $$w_i = \\frac{2}{N(N-1)P_{N-1}(s_i)^2},$$ where $P_{N-1}$ is the Legendre polynomial of degree $N-1$ evaluated at $s_i$.\n- Construct the barycentric differentiation matrix $D$ on the LGL nodes using barycentric weights $$\\lambda_i = \\prod_{j\\ne i}(s_i - s_j)^{-1},$$ with $$D_{ij} = \\frac{\\lambda_j}{\\lambda_i (s_i - s_j)}$$ for $i\\ne j$ and $$D_{ii} = -\\sum_{j\\ne i} D_{ij}.$$\n- For each face and each method:\n  - Exact normals: Evaluate the analytic derivatives $\\partial\\mathbf{X}/\\partial \\xi$ or $\\partial\\mathbf{X}/\\partial \\eta$ at the face points to obtain $\\mathbf{t}$; compute $\\mathbf{n}\\,ds=\\mathcal{R}_{-90}(\\mathbf{t})$; sum $\\mathbf{a}\\cdot\\mathbf{n}\\,ds$ with LGL weights and orientation $\\sigma_{\\text{face}}$.\n  - Polynomial normals: Interpolate the face mapping $\\mathbf{X}(s)$ at LGL nodes; compute $\\mathbf{t}_{\\text{poly}} = D\\,\\mathbf{X}$ componentwise; compute $\\mathbf{n}\\,ds=\\mathcal{R}_{-90}(\\mathbf{t}_{\\text{poly}})$; sum $\\mathbf{a}\\cdot\\mathbf{n}\\,ds$ with LGL weights and orientation.\n- Aggregate the contributions over the four faces. The discrete residual is $R = u_0$ times the total boundary integral. Declare FSP preserved if $|R|\\le \\varepsilon$, where $\\varepsilon$ is the case-specific tolerance.\n\nThe test suite covers:\n- A general curved case (Case $1$) to observe that exact normals may not preserve FSP due to quadrature aliasing, while polynomial normals do.\n- A boundary condition (Case $2$) where the mapping is affine ($\\alpha_c=\\alpha_s=\\beta_q=\\beta_s=0$), so both methods should preserve FSP exactly (up to roundoff).\n- A strongly curved case (Case $3$) amplifying non-polynomial geometry effects.\n- An edge case (Case $4$) with anisotropic curvature affecting only one coordinate sinusoid, testing sensitivity to the advection direction.\n\nThe final program outputs a single line with a list of booleans in the order: for each case, first the exact-normal outcome, then the polynomial-normal outcome. No physical units are needed, and all trigonometric function arguments are dimensionless.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef legendre_lobatto_nodes_weights(N):\n    \"\"\"\n    Compute Legendre-Gauss-Lobatto (LGL) nodes and weights on [-1,1] with N nodes.\n    Nodes are [-1] + roots of P_{N-1}' + [1]. Weights use the standard formula.\n    \"\"\"\n    from numpy.polynomial.legendre import Legendre\n    p = N - 1\n    P = Legendre.basis(p)\n    dP = P.deriv()\n    interior = dP.roots()\n    # Sort interior roots to be in ascending order\n    interior.sort()\n    x = np.empty(N)\n    x[0] = -1.0\n    x[-1] = 1.0\n    if N > 2:\n        x[1:-1] = interior\n    # Weights: w_i = 2 / (N*(N-1)) * 1 / (P_{N-1}(x_i)^2)\n    P_vals = P(x)\n    w = 2.0 / (N * (N - 1)) / (P_vals ** 2)\n    return x, w\n\ndef barycentric_diff_matrix(x):\n    \"\"\"\n    Construct the barycentric differentiation matrix D for nodes x.\n    D_ij = lambda_j / (lambda_i * (x_i - x_j)) for i != j,\n    D_ii = -sum_{j != i} D_ij.\n    \"\"\"\n    N = len(x)\n    # Compute barycentric weights lambda_i = 1 / prod_{j != i} (x_i - x_j)\n    lam = np.ones(N)\n    for i in range(N):\n        diff = x[i] - np.delete(x, i)\n        lam[i] = 1.0 / np.prod(diff)\n    D = np.zeros((N, N))\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                D[i, j] = lam[j] / (lam[i] * (x[i] - x[j]))\n    D[np.diag_indices(N)] = -np.sum(D, axis=1)\n    return D\n\ndef mapping_and_derivs(xi, eta, params):\n    \"\"\"\n    Compute physical coordinates X = (x,y) and analytic derivatives:\n    dx/dxi, dx/deta, dy/dxi, dy/deta\n    for the mapping:\n      x = xi + alpha_c * xi * eta + alpha_s * sin(pi * xi)\n      y = eta + beta_q * xi**2 + beta_s * sin(pi * eta)\n    \"\"\"\n    alpha_c, alpha_s, beta_q, beta_s = params\n    x = xi + alpha_c * xi * eta + alpha_s * np.sin(np.pi * xi)\n    y = eta + beta_q * xi**2 + beta_s * np.sin(np.pi * eta)\n    dx_dxi = 1.0 + alpha_c * eta + alpha_s * np.pi * np.cos(np.pi * xi)\n    dx_deta = alpha_c * xi\n    dy_dxi = 2.0 * beta_q * xi\n    dy_deta = 1.0 + beta_s * np.pi * np.cos(np.pi * eta)\n    return x, y, dx_dxi, dx_deta, dy_dxi, dy_deta\n\ndef rotate_minus_90(t):\n    \"\"\"\n    Rotate 2D tangent vector(s) t by -90 degrees: [tx, ty] -> [ty, -tx]\n    t can be shape (N, 2); returns same shape.\n    \"\"\"\n    return np.stack((t[:, 1], -t[:, 0]), axis=1)\n\ndef boundary_flux_exact(N, params, a):\n    \"\"\"\n    Compute boundary integral of a · n ds using exact analytic derivatives\n    and LGL quadrature with N nodes per face, traversing counterclockwise.\n    \"\"\"\n    s, w = legendre_lobatto_nodes_weights(N)\n    ax, ay = a\n    total = 0.0\n\n    # Bottom face: eta = -1, param by xi = s, orientation +1\n    eta = -1.0 * np.ones_like(s)\n    xi = s\n    _, _, dx_dxi, _, dy_dxi, _ = mapping_and_derivs(xi, eta, params)\n    t = np.stack((dx_dxi, dy_dxi), axis=1)\n    n_ds = rotate_minus_90(t)  # incorporates ds via tangent magnitude in param measure\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total += contrib  # orientation +1\n\n    # Right face: xi = +1, param by eta = s, orientation +1\n    xi = 1.0 * np.ones_like(s)\n    eta = s\n    _, _, _, dx_deta, _, dy_deta = mapping_and_derivs(xi, eta, params)\n    t = np.stack((dx_deta, dy_deta), axis=1)\n    n_ds = rotate_minus_90(t)\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total += contrib  # orientation +1\n\n    # Top face: eta = +1, param by xi = s, but orientation is reversed (-1)\n    eta = 1.0 * np.ones_like(s)\n    xi = s\n    _, _, dx_dxi, _, dy_dxi, _ = mapping_and_derivs(xi, eta, params)\n    t = np.stack((dx_dxi, dy_dxi), axis=1)\n    n_ds = rotate_minus_90(t)\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total -= contrib  # orientation -1\n\n    # Left face: xi = -1, param by eta = s, orientation -1\n    xi = -1.0 * np.ones_like(s)\n    eta = s\n    _, _, _, dx_deta, _, dy_deta = mapping_and_derivs(xi, eta, params)\n    t = np.stack((dx_deta, dy_deta), axis=1)\n    n_ds = rotate_minus_90(t)\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total -= contrib  # orientation -1\n\n    return total\n\ndef boundary_flux_poly(N, params, a):\n    \"\"\"\n    Compute boundary integral of a · n ds using polynomial interpolation\n    of the face mapping and barycentric differentiation to obtain tangents,\n    then LGL quadrature with N nodes per face, traversing counterclockwise.\n    \"\"\"\n    s, w = legendre_lobatto_nodes_weights(N)\n    D = barycentric_diff_matrix(s)\n    ax, ay = a\n    total = 0.0\n\n    # Helper to interpolate X along a face and compute tangent via D\n    def face_tangent_x_y(xi_vals, eta_vals):\n        x, y, _, _, _, _ = mapping_and_derivs(xi_vals, eta_vals, params)\n        dxds = D @ x\n        dyds = D @ y\n        return np.stack((dxds, dyds), axis=1)\n\n    # Bottom face: eta = -1, xi = s, orientation +1\n    xi = s\n    eta = -1.0 * np.ones_like(s)\n    t = face_tangent_x_y(xi, eta)\n    n_ds = rotate_minus_90(t)\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total += contrib\n\n    # Right face: xi = +1, eta = s, orientation +1\n    xi = 1.0 * np.ones_like(s)\n    eta = s\n    t = face_tangent_x_y(xi, eta)\n    n_ds = rotate_minus_90(t)\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total += contrib\n\n    # Top face: eta = +1, xi = s, orientation -1\n    xi = s\n    eta = 1.0 * np.ones_like(s)\n    t = face_tangent_x_y(xi, eta)\n    n_ds = rotate_minus_90(t)\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total -= contrib\n\n    # Left face: xi = -1, eta = s, orientation -1\n    xi = -1.0 * np.ones_like(s)\n    eta = s\n    t = face_tangent_x_y(xi, eta)\n    n_ds = rotate_minus_90(t)\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total -= contrib\n\n    return total\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, alpha_c, alpha_s, beta_q, beta_s, ax, ay, u0, epsilon)\n    test_cases = [\n        (5, 0.3, 0.2, 0.1, 0.2, 1.0, 0.3, 1.0, 1e-10),  # Case 1\n        (3, 0.0, 0.0, 0.0, 0.0, 0.7, -0.4, 1.0, 1e-12), # Case 2\n        (5, 0.5, 0.5, 0.3, 0.5, 1.0, 1.0, 1.0, 1e-10),  # Case 3\n        (4, 0.3, 0.4, 0.0, 0.6, 0.0, 1.0, 1.0, 1e-10),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        N, alpha_c, alpha_s, beta_q, beta_s, ax, ay, u0, eps = case\n        params = (alpha_c, alpha_s, beta_q, beta_s)\n        a = (ax, ay)\n        # Exact normals method\n        I_exact = boundary_flux_exact(N, params, a)\n        R_exact = u0 * I_exact\n        preserved_exact = abs(R_exact) <= eps\n        results.append(preserved_exact)\n        # Polynomial normals method\n        I_poly = boundary_flux_poly(N, params, a)\n        R_poly = u0 * I_poly\n        preserved_poly = abs(R_poly) <= eps\n        results.append(preserved_poly)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from a single element to a multi-element domain introduces new challenges, especially in adaptive simulations where adjacent elements may have different polynomial orders ($p$-adaptivity). This practice investigates how to maintain free-stream preservation across such non-conforming interfaces . You will quantify the flux mismatch that arises from a naive coupling and then implement a projection-based strategy to define a consistent, single-valued flux at the interface, thereby restoring the global conservation property.",
            "id": "3388222",
            "problem": "Consider the two-dimensional conservative linear advection equation in a time-invariant curvilinear coordinate mapping, discretized using a Spectral Element Method (SEM) or a Discontinuous Galerkin (DG) method with Legendre-Gauss-Lobatto collocation in each element. The physical space mapping is defined by a smooth bijection from a reference square to a curved quadrilateral. The central property under investigation is free-stream preservation (constant-state invariance) on curvilinear meshes, when polynomial orders vary per element (also known as $p$-adaptivity). We study the discrete condition implied by the geometric conservation law and metric identities, and how failure to enforce interface consistency of metric terms can break free-stream preservation.\n\nFundamental bases are: change of variables in multivariate calculus, continuity and differentiability of mappings, equality of mixed partial derivatives for smooth functions, and the conservation property of divergence through the Summation-By-Parts (SBP) structure of Legendre-Gauss-Lobatto collocation. The reference domain is split into two adjacent elements sharing a vertical interior interface.\n\nLet $\\boldsymbol{x} = (x,y)$ be the smooth physical mapping defined on global coordinates $(S,T)$, where each element uses local collocation coordinates $(\\xi,\\eta)$ and an affine relation $(S,T) = (\\xi + s_0, \\eta)$ with constant shift $s_0 \\in \\{-1, +1\\}$ to tile the global domain $S \\in [-2,2]$, $T \\in [-1,1]$. The physical mapping is specified as\n$$\nx(S,T) = S + a \\cos\\left(\\frac{\\pi T}{2}\\right), \\quad\ny(S,T) = T + a \\sin\\left(\\frac{\\pi S}{2}\\right)\\cos\\left(\\frac{\\pi T}{2}\\right),\n$$\nwhere $a$ is a nonnegative curvature amplitude and all trigonometric functions use angles in radians. Let the free-stream advection velocity be constant $\\boldsymbol{v} = (u_0, v_0)$.\n\nFor a constant scalar state $U \\equiv U_0$, the mapped contravariant advection flux components at a collocation point are defined by the physical derivatives and velocity,\n$$\nc^{\\xi} = u_0\\,y_{\\eta} - v_0\\,x_{\\eta}, \\qquad\nc^{\\eta} = -u_0\\,y_{\\xi} + v_0\\,x_{\\xi},\n$$\nwith partial derivatives taken with respect to local collocation coordinates $(\\xi,\\eta)$. In exact calculus, the metric identities enforce $\\partial_{\\xi} c^{\\xi} + \\partial_{\\eta} c^{\\eta} = 0$. At the discrete level with Legendre-Gauss-Lobatto collocation and Summation-By-Parts operators, the element-wise integral of the discrete divergence equals the net flux through the element boundary computed by edge quadratures. If adjacent elements use different polynomial orders, the shared interior edge flux computed from each side on its own edge nodes and weights may not cancel exactly, which breaks free-stream preservation.\n\nYour task is to implement a program that for each test case:\n- Constructs two adjacent elements (left and right) on the global strip using local Legendre-Gauss-Lobatto nodes of orders $p_L$ and $p_R$ respectively, applies the above mapping with curvature amplitude $a$, and computes $x_{\\xi}$, $x_{\\eta}$, $y_{\\xi}$, $y_{\\eta}$ using one-dimensional Legendre-Gauss-Lobatto differentiation matrices via tensor-product operations.\n- Computes the interior-interface outward flux contributions along the shared vertical edge for both elements using their own edge nodes and edge weights, namely the $\\xi$-flux line integral obtained by edge quadrature of $c^{\\xi}$ on the right edge of the left element and the outward (opposite sign) $\\xi$-flux line integral on the left edge of the right element. Let the absolute sum of these two contributions be the pre-projection mismatch error $E_{\\text{before}}$.\n- Enforces metric identity consistency at the interface by projecting the edge flux to a common interface polynomial of degree $\\max(p_L,p_R)$: interpolate the left and right edge flux samples to the common Legendre-Gauss-Lobatto interface nodes in $\\eta$ and define the common interface flux to be the average of the two interpolants. Use this common interface flux and common edge weights to recompute the two outward contributions; the absolute sum defines the post-projection mismatch error $E_{\\text{after}}$.\n- Reports the pair $(E_{\\text{before}}, E_{\\text{after}})$ for each test case.\n\nAngle unit is radians. No physical units are involved, and all results are dimensionless floats.\n\nThe required output format is a single line containing a comma-separated list enclosed in square brackets, ordered by test case, each contributing two floats $[E_{\\text{before}}, E_{\\text{after}}]$ in sequence:\n$$\n[\\;E_{\\text{before}}^{(1)}, E_{\\text{after}}^{(1)}, E_{\\text{before}}^{(2)}, E_{\\text{after}}^{(2)}, \\ldots\\;].\n$$\n\nImplement your solution under the following test suite covering distinct aspects of robustness:\n\n- Case 1 (mismatched moderate orders, moderate curvature): $p_L = 3$, $p_R = 5$, $a = 0.25$, $u_0 = 1.0$, $v_0 = 0.3$.\n- Case 2 (matched low orders, zero curvature boundary case): $p_L = 2$, $p_R = 2$, $a = 0.0$, $u_0 = 1.0$, $v_0 = 0.3$.\n- Case 3 (mismatched high contrast orders, strong curvature): $p_L = 6$, $p_R = 3$, $a = 0.5$, $u_0 = 1.0$, $v_0 = -0.4$.\n- Case 4 (extreme mismatch): $p_L = 1$, $p_R = 8$, $a = 0.4$, $u_0 = -0.7$, $v_0 = 0.9$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4]$ with all $r_i$ as floats).",
            "solution": "The problem requires an investigation into the free-stream preservation property of a high-order Spectral Element Method (SEM) or Discontinuous Galerkin (DG) discretization of the linear advection equation on a curvilinear mesh. Specifically, it examines the flux mismatch at the interface between two elements with different polynomial orders ($p$-adaptivity) and demonstrates how to restore conservation.\n\nFirst, we establish the theoretical background. The two-dimensional linear advection equation for a scalar quantity $U$ with a constant velocity field $\\boldsymbol{v} = (u_0, v_0)$ is $\\partial_t U + \\boldsymbol{v} \\cdot \\nabla U = 0$. In conservative form, this is $\\partial_t U + \\nabla \\cdot (U\\boldsymbol{v}) = 0$. For a constant (\"free-stream\") state $U \\equiv U_0$, the equation simplifies to $\\nabla \\cdot (U_0\\boldsymbol{v}) = U_0 (\\nabla \\cdot \\boldsymbol{v}) = 0$, which is trivially satisfied as $\\boldsymbol{v}$ is constant.\n\nWhen the equation is transformed from physical coordinates $\\boldsymbol{x}=(x,y)$ to reference coordinates $\\boldsymbol{\\xi}=(\\xi,\\eta)$, the conservation law becomes $\\partial_t (JU) + \\partial_{\\xi}(JUc^{\\xi}) + \\partial_{\\eta}(JUc^{\\eta}) = 0$, where $J$ is the Jacobian of the mapping and $c^{\\xi}, c^{\\eta}$ are the contravariant velocity components. For a constant state $U_0$, this reduces to the Geometric Conservation Law (GCL):\n$$\n\\partial_{\\xi}(J U_0 c^{\\xi}) + \\partial_{\\eta}(J U_0 c^{\\eta}) = U_0 (\\partial_{\\xi}(Jc^{\\xi}) + \\partial_{\\eta}(Jc^{\\eta})) = 0\n$$\nThe quantities $Jc^{\\xi}$ and $Jc^{\\eta}$ can be written in terms of the mapping derivatives (metric terms):\n$$\nJc^{\\xi} = u_0 y_{\\eta} - v_0 x_{\\eta}\n$$\n$$\nJc^{\\eta} = -u_0 y_{\\xi} + v_0 x_{\\xi}\n$$\n(Note: The problem statement defines $c^\\xi, c^\\eta$ as what are commonly known as the unscaled contravariant fluxes, equivalent to $Jc^\\xi, Jc^\\eta$. We will adopt the problem's notation.) Let's call the problem's definitions $\\tilde{c}^\\xi=Jc^\\xi$ and $\\tilde{c}^\\eta=Jc^\\eta$. The GCL is $\\partial_\\xi \\tilde{c}^\\xi + \\partial_\\eta \\tilde{c}^\\eta = 0$. This identity holds analytically if the mapping is smooth, due to the equality of mixed partial derivatives (Clairaut's theorem), e.g., $\\partial_\\xi y_\\eta = \\partial_\\eta y_\\xi$.\n\nAt the discrete level, using a nodal DG or SEM approach on Legendre-Gauss-Lobatto (LGL) points, derivatives are replaced by matrix-vector products with a differentiation matrix $D$. The GCL is no longer guaranteed to hold exactly, i.e., $\\partial_\\xi^{\\text{discrete}} \\tilde{c}^\\xi + \\partial_\\eta^{\\text{discrete}} \\tilde{c}^\\eta \\neq 0$. However, the Summation-By-Parts (SBP) property of the LGL differentiation and quadrature rules ensures that the discrete integral of the divergence over an element is exactly equal to the numerical flux integral over its boundary. For a constant state, free-stream preservation is maintained if the numerical fluxes at an interface between two elements, say $K_L$ and $K_R$, cancel out.\n\nThe total outward flux across the shared interface must be zero. The outward flux from the left element $K_L$ across its right boundary ($\\xi=1$) is $\\int \\tilde{c}^\\xi|_L d\\eta$. The outward flux from the right element $K_R$ across its left boundary ($\\xi=-1$) is $-\\int \\tilde{c}^\\xi|_R d\\eta$. Free-stream preservation requires $\\int \\tilde{c}^\\xi|_L d\\eta - \\int \\tilde{c}^\\xi|_R d\\eta = 0$.\n\nThe core of the problem lies in the fact that when $p_L \\neq p_R$, the discrete representation of the interface flux is inconsistent.\n1.  The LGL nodes and quadrature weights along the interface are different for each element.\n2.  The metric terms ($x_\\eta, y_\\eta$) are computed by differentiating the coordinate fields, which are represented as polynomials of different degrees ($p_L$ and $p_R$) in each element.\nThis leads to two different polynomial representations of the flux, $\\tilde{c}^\\xi|_L$ and $\\tilde{c}^\\xi|_R$. The numerical quadratures $\\sum_j (\\tilde{c}^\\xi|_L)_j w_j^L$ and $\\sum_j (\\tilde{c}^\\xi|_R)_j w_j^R$ will not be equal in general. The mismatch, $E_{\\text{before}} = |\\sum (\\tilde{c}^\\xi|_L)_j w_j^L - \\sum (\\tilde{c}^\\xi|_R)_j w_j^R|$, quantifies this failure of conservation.\n\nTo restore conservation, a single-valued numerical flux must be defined at the interface. This is achieved by projecting both local flux representations onto a common function space.\n1.  A common interface grid is chosen based on the LGL nodes for polynomial order $p_I = \\max(p_L, p_R)$.\n2.  The flux values from the left element, $(\\tilde{c}^\\xi|_L)_j$ at the $p_L+1$ nodes, are interpolated to the $p_I+1$ common nodes, yielding $\\tilde{c}^\\xi_{L \\to I}$.\n3.  Similarly, the flux values from the right element are interpolated to the common nodes, yielding $\\tilde{c}^\\xi_{R \\to I}$.\n4.  A common, conservative numerical flux is defined, typically as the average: $\\hat{c}^\\xi = \\frac{1}{2}(\\tilde{c}^\\xi_{L \\to I} + \\tilde{c}^\\xi_{R \\to I})$.\n5.  The flux integral contributions from both sides are now re-computed using this common flux $\\hat{c}^\\xi$ and the common quadrature rule for order $p_I$. The outward flux from the left is $F'_L = \\sum_j \\hat{c}^\\xi_j w_j^I$. The outward flux from the right is $-F'_R = -\\sum_j \\hat{c}^\\xi_j w_j^I$.\n6.  The new total mismatch is $E_{\\text{after}} = |F'_L - F'_R|$. By construction, since both integrals are computed from the identical common flux data and weights, $F'_L = F'_R$, and thus $E_{\\text{after}}$ will be zero up to floating-point precision.\n\nThe algorithm to be implemented is as follows:\nFor each test case ($p_L, p_R, a, u_0, v_0$):\n1.  Generate LGL nodes, weights, and differentiation matrices for orders $p_L$ and $p_R$.\n2.  For the left element, define the mapping from local $(\\xi, \\eta) \\in [-1,1]^2$ to physical $(x,y)$ via the intermediate map $(S,T) = (\\xi-1, \\eta)$. Evaluate the physical coordinates $(x_{ij}, y_{ij})$ on the $p_L+1 \\times p_L+1$ LGL grid.\n3.  Compute the discrete metric derivatives $x_\\eta, y_\\eta$ on the grid using the $p_L$ order differentiation matrix $D_L$.\n4.  Extract the values of $x_\\eta, y_\\eta$ on the right edge ($\\xi=1$) and compute the flux values $\\tilde{c}^\\xi_L$.\n5.  Calculate the integrated flux $F_L$ using the $p_L$ order LGL quadrature rule.\n6.  Repeat steps 2-5 for the right element, using order $p_R$ and the mapping $(S,T) = (\\xi+1, \\eta)$. Extract metrics from the left edge ($\\xi=-1$) to compute $\\tilde{c}^\\xi_R$ and the integrated flux $F_R$.\n7.  Calculate the pre-projection mismatch error: $E_{\\text{before}} = |F_L - F_R|$.\n8.  Define the common interface basis of order $p_I = \\max(p_L, p_R)$.\n9.  Interpolate the flux arrays $\\tilde{c}^\\xi_L$ (from $p_L+1$ nodes) and $\\tilde{c}^\\xi_R$ (from $p_R+1$ nodes) to the common $p_I+1$ interface nodes.\n10. Compute the common flux $\\hat{c}^\\xi$ by averaging the two interpolated flux arrays.\n11. Compute the new flux integral $F' = \\sum_j \\hat{c}^\\xi_j w_j^I$ using the common quadrature rule.\n12. Calculate the post-projection mismatch error: $E_{\\text{after}} = |F' - F'| = 0$.\n13. Store the pair $(E_{\\text{before}}, E_{\\text{after}})$.\n\nThis procedure will be executed for each provided test case, and the results will be reported in the specified format.",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import Legendre\n\nlgl_cache = {}\n\ndef get_lgl(p):\n    \"\"\"\n    Computes and caches Legendre-Gauss-Lobatto nodes, weights, and differentiation matrix.\n    Args:\n        p (int): Polynomial order, p >= 1.\n    Returns:\n        tuple: (nodes, weights, differentiation_matrix)\n    \"\"\"\n    if p in lgl_cache:\n        return lgl_cache[p]\n\n    if p < 1:\n        raise ValueError(\"Polynomial order p must be >= 1.\")\n\n    # Nodes\n    # Interior nodes are roots of P'_p(xi)\n    leg_poly = Legendre.basis(p)\n    # The derivative of the Legendre polynomial P_p is a polynomial of degree p-1\n    # For p=1, its derivative is a constant, with no roots.\n    if p > 1:\n        leg_poly_deriv = leg_poly.deriv(1)\n        interior_nodes = leg_poly_deriv.roots()\n    else: # p=1\n        interior_nodes = np.array([])\n    \n    nodes = np.concatenate(([-1.0], np.sort(np.real_if_close(interior_nodes)), [1.0]))\n\n    # Weights\n    leg_poly_vals_at_nodes = leg_poly(nodes)\n    weights = 2.0 / (p * (p + 1) * leg_poly_vals_at_nodes**2)\n    \n    # Differentiation Matrix\n    D = np.zeros((p + 1, p + 1))\n    # Off-diagonal\n    for i in range(p + 1):\n        for j in range(p + 1):\n            if i != j:\n                D[i, j] = leg_poly_vals_at_nodes[i] / (leg_poly_vals_at_nodes[j] * (nodes[i] - nodes[j]))\n    \n    # Diagonal\n    D[0, 0] = -p * (p + 1) / 4.0\n    D[p, p] = p * (p + 1) / 4.0\n\n    lgl_cache[p] = (nodes, weights, D)\n    return nodes, weights, D\n\ndef lagrange_interp_matrix(nodes_from, nodes_to):\n    \"\"\"\n    Computes the matrix for Lagrange interpolation between two sets of 1D nodes.\n    \"\"\"\n    n_from = len(nodes_from)\n    n_to = len(nodes_to)\n    I = np.zeros((n_to, n_from))\n    \n    for j in range(n_from):\n        den_nodes = [nodes_from[k] for k in range(n_from) if k != j]\n        den = np.prod([nodes_from[j] - node for node in den_nodes])\n        \n        if abs(den) < 1e-20:\n             # This handles case where a node in nodes_from is also in nodes_to\n             # The basis function will be 1 at that node and 0 at others\n             for i in range(n_to):\n                 if abs(nodes_to[i] - nodes_from[j]) < 1e-15:\n                     I[i,j] = 1.0\n             continue\n\n        for i in range(n_to):\n            num_nodes = [nodes_from[k] for k in range(n_from) if k != j]\n            num = np.prod([nodes_to[i] - node for node in num_nodes])\n            I[i, j] = num / den\n            \n    return I\n\ndef physical_mapping(S, T, a):\n    \"\"\"\n    Computes physical coordinates (x, y) from intermediate (S, T) coordinates.\n    \"\"\"\n    x = S + a * np.cos(np.pi * T / 2.0)\n    y = T + a * np.sin(np.pi * S / 2.0) * np.cos(np.pi * T / 2.0)\n    return x, y\n\ndef solve_case(p_L, p_R, a, u0, v0):\n    \"\"\"\n    Calculates the pre- and post-projection mismatch errors for a single test case.\n    \"\"\"\n    # Get LGL data for left, right, and interface elements\n    nodes_L, weights_L, D_L = get_lgl(p_L)\n    nodes_R, weights_R, D_R = get_lgl(p_R)\n    \n    # --- Left Element ---\n    xi_L, eta_L = np.meshgrid(nodes_L, nodes_L)\n    S_L, T_L = xi_L - 1.0, eta_L\n    x_L, y_L = physical_mapping(S_L, T_L, a)\n    \n    # Differentiate along eta (rows)\n    x_eta_L = D_L @ x_L\n    y_eta_L = D_L @ y_L\n\n    # Extract interface data (right edge, xi=1, last column)\n    x_eta_edge_L = x_eta_L[:, -1]\n    y_eta_edge_L = y_eta_L[:, -1]\n\n    # Compute flux and its integral\n    c_xi_L = u0 * y_eta_edge_L - v0 * x_eta_edge_L\n    F_L = np.dot(weights_L, c_xi_L)\n    \n    # --- Right Element ---\n    xi_R, eta_R = np.meshgrid(nodes_R, nodes_R)\n    S_R, T_R = xi_R + 1.0, eta_R\n    x_R, y_R = physical_mapping(S_R, T_R, a)\n    \n    # Differentiate along eta (rows)\n    x_eta_R = D_R @ x_R\n    y_eta_R = D_R @ y_R\n    \n    # Extract interface data (left edge, xi=-1, first column)\n    x_eta_edge_R = x_eta_R[:, 0]\n    y_eta_edge_R = y_eta_R[:, 0]\n    \n    # Compute flux and its integral\n    c_xi_R = u0 * y_eta_edge_R - v0 * x_eta_edge_R\n    F_R = np.dot(weights_R, c_xi_R)\n    \n    # --- Error Before Projection ---\n    E_before = np.abs(F_L - F_R)\n\n    # --- Error After Projection ---\n    p_I = max(p_L, p_R)\n    nodes_I, weights_I, _ = get_lgl(p_I)\n    \n    # Interpolate fluxes to common interface nodes\n    interp_L_to_I = lagrange_interp_matrix(nodes_L, nodes_I)\n    c_xi_L_interp = interp_L_to_I @ c_xi_L\n    \n    interp_R_to_I = lagrange_interp_matrix(nodes_R, nodes_I)\n    c_xi_R_interp = interp_R_to_I @ c_xi_R\n    \n    # Define common flux\n    c_xi_common = 0.5 * (c_xi_L_interp + c_xi_R_interp)\n\n    # Recompute flux integral using common flux and weights\n    F_common = np.dot(weights_I, c_xi_common)\n    \n    # The sum of outward contributions is |F_common - F_common|\n    E_after = np.abs(F_common - F_common) # This is zero by construction\n    \n    return E_before, E_after\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (p_L, p_R, a, u0, v0)\n        (3, 5, 0.25, 1.0, 0.3),\n        (2, 2, 0.0, 1.0, 0.3),\n        (6, 3, 0.5, 1.0, -0.4),\n        (1, 8, 0.4, -0.7, 0.9),\n    ]\n\n    results = []\n    for case in test_cases:\n        E_before, E_after = solve_case(*case)\n        results.extend([E_before, E_after])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}